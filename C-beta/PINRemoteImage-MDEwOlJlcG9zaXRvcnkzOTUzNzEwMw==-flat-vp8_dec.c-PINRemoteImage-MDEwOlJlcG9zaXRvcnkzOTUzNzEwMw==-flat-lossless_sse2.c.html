
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 9.217101610216547%, Tokens: 8, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>PINRemoteImage-MDEwOlJlcG9zaXRvcnkzOTUzNzEwMw==-flat-vp8_dec.c</h3>
            <pre><code>1  #include <stdlib.h>
2  #include "src/dec/alphai_dec.h"
3  #include "src/dec/vp8i_dec.h"
4  #include "src/dec/vp8li_dec.h"
5  #include "src/dec/webpi_dec.h"
6  #include "src/utils/bit_reader_inl_utils.h"
7  #include "src/utils/utils.h"
8  int WebPGetDecoderVersion(void) {
9    return (DEC_MAJ_VERSION << 16) | (DEC_MIN_VERSION << 8) | DEC_REV_VERSION;
10  }
11  typedef int (*GetCoeffsFunc)(VP8BitReader* const br,
12                               const VP8BandProbas* const prob[],
13                               int ctx, const quant_t dq, int n, int16_t* out);
14  static volatile GetCoeffsFunc GetCoeffs = NULL;
15  static void InitGetCoeffs(void);
16  static void SetOk(VP8Decoder* const dec) {
17    dec->status_ = VP8_STATUS_OK;
18    dec->error_msg_ = "OK";
19  }
20  int VP8InitIoInternal(VP8Io* const io, int version) {
21    if (WEBP_ABI_IS_INCOMPATIBLE(version, WEBP_DECODER_ABI_VERSION)) {
22      return 0;  
23    }
24    if (io != NULL) {
25      memset(io, 0, sizeof(*io));
26    }
27    return 1;
28  }
29  VP8Decoder* VP8New(void) {
30    VP8Decoder* const dec = (VP8Decoder*)WebPSafeCalloc(1ULL, sizeof(*dec));
31    if (dec != NULL) {
32      SetOk(dec);
33      WebPGetWorkerInterface()->Init(&dec->worker_);
34      dec->ready_ = 0;
35      dec->num_parts_minus_one_ = 0;
36      InitGetCoeffs();
37    }
38    return dec;
39  }
40  VP8StatusCode VP8Status(VP8Decoder* const dec) {
41    if (!dec) return VP8_STATUS_INVALID_PARAM;
42    return dec->status_;
43  }
44  const char* VP8StatusMessage(VP8Decoder* const dec) {
45    if (dec == NULL) return "no object";
46    if (!dec->error_msg_) return "OK";
47    return dec->error_msg_;
48  }
49  void VP8Delete(VP8Decoder* const dec) {
50    if (dec != NULL) {
51      VP8Clear(dec);
52      WebPSafeFree(dec);
53    }
54  }
55  int VP8SetError(VP8Decoder* const dec,
56                  VP8StatusCode error, const char* const msg) {
57    if (dec->status_ == VP8_STATUS_OK) {
58      dec->status_ = error;
59      dec->error_msg_ = msg;
60      dec->ready_ = 0;
61    }
62    return 0;
63  }
64  int VP8CheckSignature(const uint8_t* const data, size_t data_size) {
65    return (data_size >= 3 &&
66            data[0] == 0x9d && data[1] == 0x01 && data[2] == 0x2a);
67  }
68  int VP8GetInfo(const uint8_t* data, size_t data_size, size_t chunk_size,
69                 int* const width, int* const height) {
70    if (data == NULL || data_size < VP8_FRAME_HEADER_SIZE) {
71      return 0;         
72    }
73    if (!VP8CheckSignature(data + 3, data_size - 3)) {
74      return 0;         
75    } else {
76      const uint32_t bits = data[0] | (data[1] << 8) | (data[2] << 16);
77      const int key_frame = !(bits & 1);
78      const int w = ((data[7] << 8) | data[6]) & 0x3fff;
79      const int h = ((data[9] << 8) | data[8]) & 0x3fff;
80      if (!key_frame) {   
81        return 0;
82      }
83      if (((bits >> 1) & 7) > 3) {
84        return 0;         
85      }
86      if (!((bits >> 4) & 1)) {
87        return 0;         
88      }
89      if (((bits >> 5)) >= chunk_size) {  
90        return 0;         
91      }
92      if (w == 0 || h == 0) {
93        return 0;         
94      }
95      if (width) {
96        *width = w;
97      }
98      if (height) {
99        *height = h;
100      }
101      return 1;
102    }
103  }
104  static void ResetSegmentHeader(VP8SegmentHeader* const hdr) {
105    assert(hdr != NULL);
106    hdr->use_segment_ = 0;
107    hdr->update_map_ = 0;
108    hdr->absolute_delta_ = 1;
109    memset(hdr->quantizer_, 0, sizeof(hdr->quantizer_));
110    memset(hdr->filter_strength_, 0, sizeof(hdr->filter_strength_));
111  }
112  static int ParseSegmentHeader(VP8BitReader* br,
113                                VP8SegmentHeader* hdr, VP8Proba* proba) {
114    assert(br != NULL);
115    assert(hdr != NULL);
116    hdr->use_segment_ = VP8Get(br, "global-header");
117    if (hdr->use_segment_) {
118      hdr->update_map_ = VP8Get(br, "global-header");
119      if (VP8Get(br, "global-header")) {   
120        int s;
121        hdr->absolute_delta_ = VP8Get(br, "global-header");
122        for (s = 0; s < NUM_MB_SEGMENTS; ++s) {
123          hdr->quantizer_[s] = VP8Get(br, "global-header") ?
124              VP8GetSignedValue(br, 7, "global-header") : 0;
125        }
126        for (s = 0; s < NUM_MB_SEGMENTS; ++s) {
127          hdr->filter_strength_[s] = VP8Get(br, "global-header") ?
128              VP8GetSignedValue(br, 6, "global-header") : 0;
129        }
130      }
131      if (hdr->update_map_) {
132        int s;
133        for (s = 0; s < MB_FEATURE_TREE_PROBS; ++s) {
134          proba->segments_[s] = VP8Get(br, "global-header") ?
135              VP8GetValue(br, 8, "global-header") : 255u;
136        }
137      }
138    } else {
139      hdr->update_map_ = 0;
140    }
<span onclick='openModal()' class='match'>141    return !br->eof_;
142  }
143  static VP8StatusCode ParsePartitions(VP8Decoder* const dec,
144                                       const uint8_t* buf, size_t size) {
145    VP8BitReader* const br = &dec->br_;
</span>146    const uint8_t* sz = buf;
147    const uint8_t* buf_end = buf + size;
148    const uint8_t* part_start;
149    size_t size_left = size;
150    size_t last_part;
151    size_t p;
152    dec->num_parts_minus_one_ = (1 << VP8GetValue(br, 2, "global-header")) - 1;
153    last_part = dec->num_parts_minus_one_;
154    if (size < 3 * last_part) {
155      return VP8_STATUS_NOT_ENOUGH_DATA;
156    }
157    part_start = buf + last_part * 3;
158    size_left -= last_part * 3;
159    for (p = 0; p < last_part; ++p) {
160      size_t psize = sz[0] | (sz[1] << 8) | (sz[2] << 16);
161      if (psize > size_left) psize = size_left;
162      VP8InitBitReader(dec->parts_ + p, part_start, psize);
163      part_start += psize;
164      size_left -= psize;
165      sz += 3;
166    }
167    VP8InitBitReader(dec->parts_ + last_part, part_start, size_left);
168    return (part_start < buf_end) ? VP8_STATUS_OK :
169             VP8_STATUS_SUSPENDED;   
170  }
171  static int ParseFilterHeader(VP8BitReader* br, VP8Decoder* const dec) {
172    VP8FilterHeader* const hdr = &dec->filter_hdr_;
173    hdr->simple_    = VP8Get(br, "global-header");
174    hdr->level_     = VP8GetValue(br, 6, "global-header");
175    hdr->sharpness_ = VP8GetValue(br, 3, "global-header");
176    hdr->use_lf_delta_ = VP8Get(br, "global-header");
177    if (hdr->use_lf_delta_) {
178      if (VP8Get(br, "global-header")) {   
179        int i;
180        for (i = 0; i < NUM_REF_LF_DELTAS; ++i) {
181          if (VP8Get(br, "global-header")) {
182            hdr->ref_lf_delta_[i] = VP8GetSignedValue(br, 6, "global-header");
183          }
184        }
185        for (i = 0; i < NUM_MODE_LF_DELTAS; ++i) {
186          if (VP8Get(br, "global-header")) {
187            hdr->mode_lf_delta_[i] = VP8GetSignedValue(br, 6, "global-header");
188          }
189        }
190      }
191    }
192    dec->filter_type_ = (hdr->level_ == 0) ? 0 : hdr->simple_ ? 1 : 2;
193    return !br->eof_;
194  }
195  int VP8GetHeaders(VP8Decoder* const dec, VP8Io* const io) {
196    const uint8_t* buf;
197    size_t buf_size;
198    VP8FrameHeader* frm_hdr;
199    VP8PictureHeader* pic_hdr;
200    VP8BitReader* br;
201    VP8StatusCode status;
202    if (dec == NULL) {
203      return 0;
204    }
205    SetOk(dec);
206    if (io == NULL) {
207      return VP8SetError(dec, VP8_STATUS_INVALID_PARAM,
208                         "null VP8Io passed to VP8GetHeaders()");
209    }
210    buf = io->data;
211    buf_size = io->data_size;
212    if (buf_size < 4) {
213      return VP8SetError(dec, VP8_STATUS_NOT_ENOUGH_DATA,
214                         "Truncated header.");
215    }
216    {
217      const uint32_t bits = buf[0] | (buf[1] << 8) | (buf[2] << 16);
218      frm_hdr = &dec->frm_hdr_;
219      frm_hdr->key_frame_ = !(bits & 1);
220      frm_hdr->profile_ = (bits >> 1) & 7;
221      frm_hdr->show_ = (bits >> 4) & 1;
222      frm_hdr->partition_length_ = (bits >> 5);
223      if (frm_hdr->profile_ > 3) {
224        return VP8SetError(dec, VP8_STATUS_BITSTREAM_ERROR,
225                           "Incorrect keyframe parameters.");
226      }
227      if (!frm_hdr->show_) {
228        return VP8SetError(dec, VP8_STATUS_UNSUPPORTED_FEATURE,
229                           "Frame not displayable.");
230      }
231      buf += 3;
232      buf_size -= 3;
233    }
234    pic_hdr = &dec->pic_hdr_;
235    if (frm_hdr->key_frame_) {
236      if (buf_size < 7) {
237        return VP8SetError(dec, VP8_STATUS_NOT_ENOUGH_DATA,
238                           "cannot parse picture header");
239      }
240      if (!VP8CheckSignature(buf, buf_size)) {
241        return VP8SetError(dec, VP8_STATUS_BITSTREAM_ERROR,
242                           "Bad code word");
243      }
244      pic_hdr->width_ = ((buf[4] << 8) | buf[3]) & 0x3fff;
245      pic_hdr->xscale_ = buf[4] >> 6;   
246      pic_hdr->height_ = ((buf[6] << 8) | buf[5]) & 0x3fff;
247      pic_hdr->yscale_ = buf[6] >> 6;
248      buf += 7;
249      buf_size -= 7;
250      dec->mb_w_ = (pic_hdr->width_ + 15) >> 4;
251      dec->mb_h_ = (pic_hdr->height_ + 15) >> 4;
252      io->width = pic_hdr->width_;
253      io->height = pic_hdr->height_;
254      io->use_cropping = 0;
255      io->crop_top  = 0;
256      io->crop_left = 0;
257      io->crop_right  = io->width;
258      io->crop_bottom = io->height;
259      io->use_scaling  = 0;
260      io->scaled_width = io->width;
261      io->scaled_height = io->height;
262      io->mb_w = io->width;   
263      io->mb_h = io->height;  
264      VP8ResetProba(&dec->proba_);
265      ResetSegmentHeader(&dec->segment_hdr_);
266    }
267    if (frm_hdr->partition_length_ > buf_size) {
268      return VP8SetError(dec, VP8_STATUS_NOT_ENOUGH_DATA,
269                         "bad partition length");
270    }
271    br = &dec->br_;
272    VP8InitBitReader(br, buf, frm_hdr->partition_length_);
273    buf += frm_hdr->partition_length_;
274    buf_size -= frm_hdr->partition_length_;
275    if (frm_hdr->key_frame_) {
276      pic_hdr->colorspace_ = VP8Get(br, "global-header");
277      pic_hdr->clamp_type_ = VP8Get(br, "global-header");
278    }
279    if (!ParseSegmentHeader(br, &dec->segment_hdr_, &dec->proba_)) {
280      return VP8SetError(dec, VP8_STATUS_BITSTREAM_ERROR,
281                         "cannot parse segment header");
282    }
283    if (!ParseFilterHeader(br, dec)) {
284      return VP8SetError(dec, VP8_STATUS_BITSTREAM_ERROR,
285                         "cannot parse filter header");
286    }
287    status = ParsePartitions(dec, buf, buf_size);
288    if (status != VP8_STATUS_OK) {
289      return VP8SetError(dec, status, "cannot parse partitions");
290    }
291    VP8ParseQuant(dec);
292    if (!frm_hdr->key_frame_) {
293      return VP8SetError(dec, VP8_STATUS_UNSUPPORTED_FEATURE,
294                         "Not a key frame.");
295    }
296    VP8Get(br, "global-header");   
297    VP8ParseProba(br, dec);
298    dec->ready_ = 1;
299    return 1;
300  }
301  static const uint8_t kCat3[] = { 173, 148, 140, 0 };
302  static const uint8_t kCat4[] = { 176, 155, 140, 135, 0 };
303  static const uint8_t kCat5[] = { 180, 157, 141, 134, 130, 0 };
304  static const uint8_t kCat6[] =
305    { 254, 254, 243, 230, 196, 177, 153, 140, 133, 130, 129, 0 };
306  static const uint8_t* const kCat3456[] = { kCat3, kCat4, kCat5, kCat6 };
307  static const uint8_t kZigzag[16] = {
308    0, 1, 4, 8,  5, 2, 3, 6,  9, 12, 13, 10,  7, 11, 14, 15
309  };
310  static int GetLargeValue(VP8BitReader* const br, const uint8_t* const p) {
311    int v;
312    if (!VP8GetBit(br, p[3], "coeffs")) {
313      if (!VP8GetBit(br, p[4], "coeffs")) {
314        v = 2;
315      } else {
316        v = 3 + VP8GetBit(br, p[5], "coeffs");
317      }
318    } else {
319      if (!VP8GetBit(br, p[6], "coeffs")) {
320        if (!VP8GetBit(br, p[7], "coeffs")) {
321          v = 5 + VP8GetBit(br, 159, "coeffs");
322        } else {
323          v = 7 + 2 * VP8GetBit(br, 165, "coeffs");
324          v += VP8GetBit(br, 145, "coeffs");
325        }
326      } else {
327        const uint8_t* tab;
328        const int bit1 = VP8GetBit(br, p[8], "coeffs");
329        const int bit0 = VP8GetBit(br, p[9 + bit1], "coeffs");
330        const int cat = 2 * bit1 + bit0;
331        v = 0;
332        for (tab = kCat3456[cat]; *tab; ++tab) {
333          v += v + VP8GetBit(br, *tab, "coeffs");
334        }
335        v += 3 + (8 << cat);
336      }
337    }
338    return v;
339  }
340  static int GetCoeffsFast(VP8BitReader* const br,
341                           const VP8BandProbas* const prob[],
342                           int ctx, const quant_t dq, int n, int16_t* out) {
343    const uint8_t* p = prob[n]->probas_[ctx];
344    for (; n < 16; ++n) {
345      if (!VP8GetBit(br, p[0], "coeffs")) {
346        return n;  
347      }
348      while (!VP8GetBit(br, p[1], "coeffs")) {       
349        p = prob[++n]->probas_[0];
350        if (n == 16) return 16;
351      }
352      {        
353        const VP8ProbaArray* const p_ctx = &prob[n + 1]->probas_[0];
354        int v;
355        if (!VP8GetBit(br, p[2], "coeffs")) {
356          v = 1;
357          p = p_ctx[1];
358        } else {
359          v = GetLargeValue(br, p);
360          p = p_ctx[2];
361        }
362        out[kZigzag[n]] = VP8GetSigned(br, v, "coeffs") * dq[n > 0];
363      }
364    }
365    return 16;
366  }
367  static int GetCoeffsAlt(VP8BitReader* const br,
368                          const VP8BandProbas* const prob[],
369                          int ctx, const quant_t dq, int n, int16_t* out) {
370    const uint8_t* p = prob[n]->probas_[ctx];
371    for (; n < 16; ++n) {
372      if (!VP8GetBitAlt(br, p[0], "coeffs")) {
373        return n;  
374      }
375      while (!VP8GetBitAlt(br, p[1], "coeffs")) {       
376        p = prob[++n]->probas_[0];
377        if (n == 16) return 16;
378      }
379      {        
380        const VP8ProbaArray* const p_ctx = &prob[n + 1]->probas_[0];
381        int v;
382        if (!VP8GetBitAlt(br, p[2], "coeffs")) {
383          v = 1;
384          p = p_ctx[1];
385        } else {
386          v = GetLargeValue(br, p);
387          p = p_ctx[2];
388        }
389        out[kZigzag[n]] = VP8GetSigned(br, v, "coeffs") * dq[n > 0];
390      }
391    }
392    return 16;
393  }
394  static WEBP_TSAN_IGNORE_FUNCTION void InitGetCoeffs(void) {
395    if (GetCoeffs == NULL) {
396      if (VP8GetCPUInfo != NULL && VP8GetCPUInfo(kSlowSSSE3)) {
397        GetCoeffs = GetCoeffsAlt;
398      } else {
399        GetCoeffs = GetCoeffsFast;
400      }
401    }
402  }
403  static WEBP_INLINE uint32_t NzCodeBits(uint32_t nz_coeffs, int nz, int dc_nz) {
404    nz_coeffs <<= 2;
405    nz_coeffs |= (nz > 3) ? 3 : (nz > 1) ? 2 : dc_nz;
406    return nz_coeffs;
407  }
408  static int ParseResiduals(VP8Decoder* const dec,
409                            VP8MB* const mb, VP8BitReader* const token_br) {
410    const VP8BandProbas* (* const bands)[16 + 1] = dec->proba_.bands_ptr_;
411    const VP8BandProbas* const * ac_proba;
412    VP8MBData* const block = dec->mb_data_ + dec->mb_x_;
413    const VP8QuantMatrix* const q = &dec->dqm_[block->segment_];
414    int16_t* dst = block->coeffs_;
415    VP8MB* const left_mb = dec->mb_info_ - 1;
416    uint8_t tnz, lnz;
417    uint32_t non_zero_y = 0;
418    uint32_t non_zero_uv = 0;
419    int x, y, ch;
420    uint32_t out_t_nz, out_l_nz;
421    int first;
422    memset(dst, 0, 384 * sizeof(*dst));
423    if (!block->is_i4x4_) {    
424      int16_t dc[16] = { 0 };
425      const int ctx = mb->nz_dc_ + left_mb->nz_dc_;
426      const int nz = GetCoeffs(token_br, bands[1], ctx, q->y2_mat_, 0, dc);
427      mb->nz_dc_ = left_mb->nz_dc_ = (nz > 0);
428      if (nz > 1) {   
429        VP8TransformWHT(dc, dst);
430      } else {        
431        int i;
432        const int dc0 = (dc[0] + 3) >> 3;
433        for (i = 0; i < 16 * 16; i += 16) dst[i] = dc0;
434      }
435      first = 1;
436      ac_proba = bands[0];
437    } else {
438      first = 0;
439      ac_proba = bands[3];
440    }
441    tnz = mb->nz_ & 0x0f;
442    lnz = left_mb->nz_ & 0x0f;
443    for (y = 0; y < 4; ++y) {
444      int l = lnz & 1;
445      uint32_t nz_coeffs = 0;
446      for (x = 0; x < 4; ++x) {
447        const int ctx = l + (tnz & 1);
448        const int nz = GetCoeffs(token_br, ac_proba, ctx, q->y1_mat_, first, dst);
449        l = (nz > first);
450        tnz = (tnz >> 1) | (l << 7);
451        nz_coeffs = NzCodeBits(nz_coeffs, nz, dst[0] != 0);
452        dst += 16;
453      }
454      tnz >>= 4;
455      lnz = (lnz >> 1) | (l << 7);
456      non_zero_y = (non_zero_y << 8) | nz_coeffs;
457    }
458    out_t_nz = tnz;
459    out_l_nz = lnz >> 4;
460    for (ch = 0; ch < 4; ch += 2) {
461      uint32_t nz_coeffs = 0;
462      tnz = mb->nz_ >> (4 + ch);
463      lnz = left_mb->nz_ >> (4 + ch);
464      for (y = 0; y < 2; ++y) {
465        int l = lnz & 1;
466        for (x = 0; x < 2; ++x) {
467          const int ctx = l + (tnz & 1);
468          const int nz = GetCoeffs(token_br, bands[2], ctx, q->uv_mat_, 0, dst);
469          l = (nz > 0);
470          tnz = (tnz >> 1) | (l << 3);
471          nz_coeffs = NzCodeBits(nz_coeffs, nz, dst[0] != 0);
472          dst += 16;
473        }
474        tnz >>= 2;
475        lnz = (lnz >> 1) | (l << 5);
476      }
477      non_zero_uv |= nz_coeffs << (4 * ch);
478      out_t_nz |= (tnz << 4) << ch;
479      out_l_nz |= (lnz & 0xf0) << ch;
480    }
481    mb->nz_ = out_t_nz;
482    left_mb->nz_ = out_l_nz;
483    block->non_zero_y_ = non_zero_y;
484    block->non_zero_uv_ = non_zero_uv;
485    block->dither_ = (non_zero_uv & 0xaaaa) ? 0 : q->dither_;
486    return !(non_zero_y | non_zero_uv);  
487  }
488  int VP8DecodeMB(VP8Decoder* const dec, VP8BitReader* const token_br) {
489    VP8MB* const left = dec->mb_info_ - 1;
490    VP8MB* const mb = dec->mb_info_ + dec->mb_x_;
491    VP8MBData* const block = dec->mb_data_ + dec->mb_x_;
492    int skip = dec->use_skip_proba_ ? block->skip_ : 0;
493    if (!skip) {
494      skip = ParseResiduals(dec, mb, token_br);
495    } else {
496      left->nz_ = mb->nz_ = 0;
497      if (!block->is_i4x4_) {
498        left->nz_dc_ = mb->nz_dc_ = 0;
499      }
500      block->non_zero_y_ = 0;
501      block->non_zero_uv_ = 0;
502      block->dither_ = 0;
503    }
504    if (dec->filter_type_ > 0) {  
505      VP8FInfo* const finfo = dec->f_info_ + dec->mb_x_;
506      *finfo = dec->fstrengths_[block->segment_][block->is_i4x4_];
507      finfo->f_inner_ |= !skip;
508    }
509    return !token_br->eof_;
510  }
511  void VP8InitScanline(VP8Decoder* const dec) {
512    VP8MB* const left = dec->mb_info_ - 1;
513    left->nz_ = 0;
514    left->nz_dc_ = 0;
515    memset(dec->intra_l_, B_DC_PRED, sizeof(dec->intra_l_));
516    dec->mb_x_ = 0;
517  }
518  static int ParseFrame(VP8Decoder* const dec, VP8Io* io) {
519    for (dec->mb_y_ = 0; dec->mb_y_ < dec->br_mb_y_; ++dec->mb_y_) {
520      VP8BitReader* const token_br =
521          &dec->parts_[dec->mb_y_ & dec->num_parts_minus_one_];
522      if (!VP8ParseIntraModeRow(&dec->br_, dec)) {
523        return VP8SetError(dec, VP8_STATUS_NOT_ENOUGH_DATA,
524                           "Premature end-of-partition0 encountered.");
525      }
526      for (; dec->mb_x_ < dec->mb_w_; ++dec->mb_x_) {
527        if (!VP8DecodeMB(dec, token_br)) {
528          return VP8SetError(dec, VP8_STATUS_NOT_ENOUGH_DATA,
529                             "Premature end-of-file encountered.");
530        }
531      }
532      VP8InitScanline(dec);   
533      if (!VP8ProcessRow(dec, io)) {
534        return VP8SetError(dec, VP8_STATUS_USER_ABORT, "Output aborted.");
535      }
536    }
537    if (dec->mt_method_ > 0) {
538      if (!WebPGetWorkerInterface()->Sync(&dec->worker_)) return 0;
539    }
540    return 1;
541  }
542  int VP8Decode(VP8Decoder* const dec, VP8Io* const io) {
543    int ok = 0;
544    if (dec == NULL) {
545      return 0;
546    }
547    if (io == NULL) {
548      return VP8SetError(dec, VP8_STATUS_INVALID_PARAM,
549                         "NULL VP8Io parameter in VP8Decode().");
550    }
551    if (!dec->ready_) {
552      if (!VP8GetHeaders(dec, io)) {
553        return 0;
554      }
555    }
556    assert(dec->ready_);
557    ok = (VP8EnterCritical(dec, io) == VP8_STATUS_OK);
558    if (ok) {   
559      if (ok) ok = VP8InitFrame(dec, io);
560      if (ok) ok = ParseFrame(dec, io);
561      ok &= VP8ExitCritical(dec, io);
562    }
563    if (!ok) {
564      VP8Clear(dec);
565      return 0;
566    }
567    dec->ready_ = 0;
568    return ok;
569  }
570  void VP8Clear(VP8Decoder* const dec) {
571    if (dec == NULL) {
572      return;
573    }
574    WebPGetWorkerInterface()->End(&dec->worker_);
575    WebPDeallocateAlphaMemory(dec);
576    WebPSafeFree(dec->mem_);
577    dec->mem_ = NULL;
578    dec->mem_size_ = 0;
579    memset(&dec->br_, 0, sizeof(dec->br_));
580    dec->ready_ = 0;
581  }
</code></pre>
        </div>
        <div class="column">
            <h3>PINRemoteImage-MDEwOlJlcG9zaXRvcnkzOTUzNzEwMw==-flat-lossless_sse2.c</h3>
            <pre><code>1  #include "src/dsp/dsp.h"
2  #if defined(WEBP_USE_SSE2)
3  #include "src/dsp/common_sse2.h"
4  #include "src/dsp/lossless.h"
5  #include "src/dsp/lossless_common.h"
6  #include <assert.h>
7  #include <emmintrin.h>
8  static WEBP_INLINE uint32_t ClampedAddSubtractFull_SSE2(uint32_t c0,
9                                                          uint32_t c1,
10                                                          uint32_t c2) {
11    const __m128i zero = _mm_setzero_si128();
12    const __m128i C0 = _mm_unpacklo_epi8(_mm_cvtsi32_si128(c0), zero);
13    const __m128i C1 = _mm_unpacklo_epi8(_mm_cvtsi32_si128(c1), zero);
14    const __m128i C2 = _mm_unpacklo_epi8(_mm_cvtsi32_si128(c2), zero);
15    const __m128i V1 = _mm_add_epi16(C0, C1);
16    const __m128i V2 = _mm_sub_epi16(V1, C2);
17    const __m128i b = _mm_packus_epi16(V2, V2);
18    const uint32_t output = _mm_cvtsi128_si32(b);
<span onclick='openModal()' class='match'>19    return output;
20  }
21  static WEBP_INLINE uint32_t ClampedAddSubtractHalf_SSE2(uint32_t c0,
22                                                          uint32_t c1,
23                                                          uint32_t c2) {
24    const __m128i zero = _mm_setzero_si128();
</span>25    const __m128i C0 = _mm_unpacklo_epi8(_mm_cvtsi32_si128(c0), zero);
26    const __m128i C1 = _mm_unpacklo_epi8(_mm_cvtsi32_si128(c1), zero);
27    const __m128i B0 = _mm_unpacklo_epi8(_mm_cvtsi32_si128(c2), zero);
28    const __m128i avg = _mm_add_epi16(C1, C0);
29    const __m128i A0 = _mm_srli_epi16(avg, 1);
30    const __m128i A1 = _mm_sub_epi16(A0, B0);
31    const __m128i BgtA = _mm_cmpgt_epi16(B0, A0);
32    const __m128i A2 = _mm_sub_epi16(A1, BgtA);
33    const __m128i A3 = _mm_srai_epi16(A2, 1);
34    const __m128i A4 = _mm_add_epi16(A0, A3);
35    const __m128i A5 = _mm_packus_epi16(A4, A4);
36    const uint32_t output = _mm_cvtsi128_si32(A5);
37    return output;
38  }
39  static WEBP_INLINE uint32_t Select_SSE2(uint32_t a, uint32_t b, uint32_t c) {
40    int pa_minus_pb;
41    const __m128i zero = _mm_setzero_si128();
42    const __m128i A0 = _mm_cvtsi32_si128(a);
43    const __m128i B0 = _mm_cvtsi32_si128(b);
44    const __m128i C0 = _mm_cvtsi32_si128(c);
45    const __m128i AC0 = _mm_subs_epu8(A0, C0);
46    const __m128i CA0 = _mm_subs_epu8(C0, A0);
47    const __m128i BC0 = _mm_subs_epu8(B0, C0);
48    const __m128i CB0 = _mm_subs_epu8(C0, B0);
49    const __m128i AC = _mm_or_si128(AC0, CA0);
50    const __m128i BC = _mm_or_si128(BC0, CB0);
51    const __m128i pa = _mm_unpacklo_epi8(AC, zero);  
52    const __m128i pb = _mm_unpacklo_epi8(BC, zero);  
53    const __m128i diff = _mm_sub_epi16(pb, pa);
54    {
55      int16_t out[8];
56      _mm_storeu_si128((__m128i*)out, diff);
57      pa_minus_pb = out[0] + out[1] + out[2] + out[3];
58    }
59    return (pa_minus_pb <= 0) ? a : b;
60  }
61  static WEBP_INLINE void Average2_m128i(const __m128i* const a0,
62                                         const __m128i* const a1,
63                                         __m128i* const avg) {
64    const __m128i ones = _mm_set1_epi8(1);
65    const __m128i avg1 = _mm_avg_epu8(*a0, *a1);
66    const __m128i one = _mm_and_si128(_mm_xor_si128(*a0, *a1), ones);
67    *avg = _mm_sub_epi8(avg1, one);
68  }
69  static WEBP_INLINE void Average2_uint32_SSE2(const uint32_t a0,
70                                               const uint32_t a1,
71                                               __m128i* const avg) {
72    const __m128i ones = _mm_set1_epi8(1);
73    const __m128i A0 = _mm_cvtsi32_si128(a0);
74    const __m128i A1 = _mm_cvtsi32_si128(a1);
75    const __m128i avg1 = _mm_avg_epu8(A0, A1);
76    const __m128i one = _mm_and_si128(_mm_xor_si128(A0, A1), ones);
77    *avg = _mm_sub_epi8(avg1, one);
78  }
79  static WEBP_INLINE __m128i Average2_uint32_16_SSE2(uint32_t a0, uint32_t a1) {
80    const __m128i zero = _mm_setzero_si128();
81    const __m128i A0 = _mm_unpacklo_epi8(_mm_cvtsi32_si128(a0), zero);
82    const __m128i A1 = _mm_unpacklo_epi8(_mm_cvtsi32_si128(a1), zero);
83    const __m128i sum = _mm_add_epi16(A1, A0);
84    return _mm_srli_epi16(sum, 1);
85  }
86  static WEBP_INLINE uint32_t Average2_SSE2(uint32_t a0, uint32_t a1) {
87    __m128i output;
88    Average2_uint32_SSE2(a0, a1, &output);
89    return _mm_cvtsi128_si32(output);
90  }
91  static WEBP_INLINE uint32_t Average3_SSE2(uint32_t a0, uint32_t a1,
92                                            uint32_t a2) {
93    const __m128i zero = _mm_setzero_si128();
94    const __m128i avg1 = Average2_uint32_16_SSE2(a0, a2);
95    const __m128i A1 = _mm_unpacklo_epi8(_mm_cvtsi32_si128(a1), zero);
96    const __m128i sum = _mm_add_epi16(avg1, A1);
97    const __m128i avg2 = _mm_srli_epi16(sum, 1);
98    const __m128i A2 = _mm_packus_epi16(avg2, avg2);
99    const uint32_t output = _mm_cvtsi128_si32(A2);
100    return output;
101  }
102  static WEBP_INLINE uint32_t Average4_SSE2(uint32_t a0, uint32_t a1,
103                                            uint32_t a2, uint32_t a3) {
104    const __m128i avg1 = Average2_uint32_16_SSE2(a0, a1);
105    const __m128i avg2 = Average2_uint32_16_SSE2(a2, a3);
106    const __m128i sum = _mm_add_epi16(avg2, avg1);
107    const __m128i avg3 = _mm_srli_epi16(sum, 1);
108    const __m128i A0 = _mm_packus_epi16(avg3, avg3);
109    const uint32_t output = _mm_cvtsi128_si32(A0);
110    return output;
111  }
112  static uint32_t Predictor5_SSE2(uint32_t left, const uint32_t* const top) {
113    const uint32_t pred = Average3_SSE2(left, top[0], top[1]);
114    return pred;
115  }
116  static uint32_t Predictor6_SSE2(uint32_t left, const uint32_t* const top) {
117    const uint32_t pred = Average2_SSE2(left, top[-1]);
118    return pred;
119  }
120  static uint32_t Predictor7_SSE2(uint32_t left, const uint32_t* const top) {
121    const uint32_t pred = Average2_SSE2(left, top[0]);
122    return pred;
123  }
124  static uint32_t Predictor8_SSE2(uint32_t left, const uint32_t* const top) {
125    const uint32_t pred = Average2_SSE2(top[-1], top[0]);
126    (void)left;
127    return pred;
128  }
129  static uint32_t Predictor9_SSE2(uint32_t left, const uint32_t* const top) {
130    const uint32_t pred = Average2_SSE2(top[0], top[1]);
131    (void)left;
132    return pred;
133  }
134  static uint32_t Predictor10_SSE2(uint32_t left, const uint32_t* const top) {
135    const uint32_t pred = Average4_SSE2(left, top[-1], top[0], top[1]);
136    return pred;
137  }
138  static uint32_t Predictor11_SSE2(uint32_t left, const uint32_t* const top) {
139    const uint32_t pred = Select_SSE2(top[0], left, top[-1]);
140    return pred;
141  }
142  static uint32_t Predictor12_SSE2(uint32_t left, const uint32_t* const top) {
143    const uint32_t pred = ClampedAddSubtractFull_SSE2(left, top[0], top[-1]);
144    return pred;
145  }
146  static uint32_t Predictor13_SSE2(uint32_t left, const uint32_t* const top) {
147    const uint32_t pred = ClampedAddSubtractHalf_SSE2(left, top[0], top[-1]);
148    return pred;
149  }
150  static void PredictorAdd0_SSE2(const uint32_t* in, const uint32_t* upper,
151                                 int num_pixels, uint32_t* out) {
152    int i;
153    const __m128i black = _mm_set1_epi32(ARGB_BLACK);
154    for (i = 0; i + 4 <= num_pixels; i += 4) {
155      const __m128i src = _mm_loadu_si128((const __m128i*)&in[i]);
156      const __m128i res = _mm_add_epi8(src, black);
157      _mm_storeu_si128((__m128i*)&out[i], res);
158    }
159    if (i != num_pixels) {
160      VP8LPredictorsAdd_C[0](in + i, NULL, num_pixels - i, out + i);
161    }
162    (void)upper;
163  }
164  static void PredictorAdd1_SSE2(const uint32_t* in, const uint32_t* upper,
165                                 int num_pixels, uint32_t* out) {
166    int i;
167    __m128i prev = _mm_set1_epi32(out[-1]);
168    for (i = 0; i + 4 <= num_pixels; i += 4) {
169      const __m128i src = _mm_loadu_si128((const __m128i*)&in[i]);
170      const __m128i shift0 = _mm_slli_si128(src, 4);
171      const __m128i sum0 = _mm_add_epi8(src, shift0);
172      const __m128i shift1 = _mm_slli_si128(sum0, 8);
173      const __m128i sum1 = _mm_add_epi8(sum0, shift1);
174      const __m128i res = _mm_add_epi8(sum1, prev);
175      _mm_storeu_si128((__m128i*)&out[i], res);
176      prev = _mm_shuffle_epi32(res, (3 << 0) | (3 << 2) | (3 << 4) | (3 << 6));
177    }
178    if (i != num_pixels) {
179      VP8LPredictorsAdd_C[1](in + i, upper + i, num_pixels - i, out + i);
180    }
181  }
182  #define GENERATE_PREDICTOR_1(X, IN)                                           \
183  static void PredictorAdd##X##_SSE2(const uint32_t* in, const uint32_t* upper, \
184                                    int num_pixels, uint32_t* out) {            \
185    int i;                                                                      \
186    for (i = 0; i + 4 <= num_pixels; i += 4) {                                  \
187      const __m128i src = _mm_loadu_si128((const __m128i*)&in[i]);              \
188      const __m128i other = _mm_loadu_si128((const __m128i*)&(IN));             \
189      const __m128i res = _mm_add_epi8(src, other);                             \
190      _mm_storeu_si128((__m128i*)&out[i], res);                                 \
191    }                                                                           \
192    if (i != num_pixels) {                                                      \
193      VP8LPredictorsAdd_C[(X)](in + i, upper + i, num_pixels - i, out + i);     \
194    }                                                                           \
195  }
196  GENERATE_PREDICTOR_1(2, upper[i])
197  GENERATE_PREDICTOR_1(3, upper[i + 1])
198  GENERATE_PREDICTOR_1(4, upper[i - 1])
199  #undef GENERATE_PREDICTOR_1
200  GENERATE_PREDICTOR_ADD(Predictor5_SSE2, PredictorAdd5_SSE2)
201  GENERATE_PREDICTOR_ADD(Predictor6_SSE2, PredictorAdd6_SSE2)
202  GENERATE_PREDICTOR_ADD(Predictor7_SSE2, PredictorAdd7_SSE2)
203  #define GENERATE_PREDICTOR_2(X, IN)                                           \
204  static void PredictorAdd##X##_SSE2(const uint32_t* in, const uint32_t* upper, \
205                                     int num_pixels, uint32_t* out) {           \
206    int i;                                                                      \
207    for (i = 0; i + 4 <= num_pixels; i += 4) {                                  \
208      const __m128i Tother = _mm_loadu_si128((const __m128i*)&(IN));            \
209      const __m128i T = _mm_loadu_si128((const __m128i*)&upper[i]);             \
210      const __m128i src = _mm_loadu_si128((const __m128i*)&in[i]);              \
211      __m128i avg, res;                                                         \
212      Average2_m128i(&T, &Tother, &avg);                                        \
213      res = _mm_add_epi8(avg, src);                                             \
214      _mm_storeu_si128((__m128i*)&out[i], res);                                 \
215    }                                                                           \
216    if (i != num_pixels) {                                                      \
217      VP8LPredictorsAdd_C[(X)](in + i, upper + i, num_pixels - i, out + i);     \
218    }                                                                           \
219  }
220  GENERATE_PREDICTOR_2(8, upper[i - 1])
221  GENERATE_PREDICTOR_2(9, upper[i + 1])
222  #undef GENERATE_PREDICTOR_2
223  #define DO_PRED10(OUT) do {               \
224    __m128i avgLTL, avg;                    \
225    Average2_m128i(&L, &TL, &avgLTL);       \
226    Average2_m128i(&avgTTR, &avgLTL, &avg); \
227    L = _mm_add_epi8(avg, src);             \
228    out[i + (OUT)] = _mm_cvtsi128_si32(L);  \
229  } while (0)
230  #define DO_PRED10_SHIFT do {                                  \
231     \
232    avgTTR = _mm_srli_si128(avgTTR, 4);                         \
233    TL = _mm_srli_si128(TL, 4);                                 \
234    src = _mm_srli_si128(src, 4);                               \
235  } while (0)
236  static void PredictorAdd10_SSE2(const uint32_t* in, const uint32_t* upper,
237                                  int num_pixels, uint32_t* out) {
238    int i;
239    __m128i L = _mm_cvtsi32_si128(out[-1]);
240    for (i = 0; i + 4 <= num_pixels; i += 4) {
241      __m128i src = _mm_loadu_si128((const __m128i*)&in[i]);
242      __m128i TL = _mm_loadu_si128((const __m128i*)&upper[i - 1]);
243      const __m128i T = _mm_loadu_si128((const __m128i*)&upper[i]);
244      const __m128i TR = _mm_loadu_si128((const __m128i*)&upper[i + 1]);
245      __m128i avgTTR;
246      Average2_m128i(&T, &TR, &avgTTR);
247      DO_PRED10(0);
248      DO_PRED10_SHIFT;
249      DO_PRED10(1);
250      DO_PRED10_SHIFT;
251      DO_PRED10(2);
252      DO_PRED10_SHIFT;
253      DO_PRED10(3);
254    }
255    if (i != num_pixels) {
256      VP8LPredictorsAdd_C[10](in + i, upper + i, num_pixels - i, out + i);
257    }
258  }
259  #undef DO_PRED10
260  #undef DO_PRED10_SHIFT
261  #define DO_PRED11(OUT) do {                                            \
262    const __m128i L_lo = _mm_unpacklo_epi32(L, T);                       \
263    const __m128i TL_lo = _mm_unpacklo_epi32(TL, T);                     \
264    const __m128i pb = _mm_sad_epu8(L_lo, TL_lo); &bsol;* pb = sum |L-TL|*/   \
265    const __m128i mask = _mm_cmpgt_epi32(pb, pa);                        \
266    const __m128i A = _mm_and_si128(mask, L);                            \
267    const __m128i B = _mm_andnot_si128(mask, T);                         \
268    const __m128i pred = _mm_or_si128(A, B); &bsol;* pred = (pa > b)? L : T*/ \
269    L = _mm_add_epi8(src, pred);                                         \
270    out[i + (OUT)] = _mm_cvtsi128_si32(L);                               \
271  } while (0)
272  #define DO_PRED11_SHIFT do {                                \
273     \
274    T = _mm_srli_si128(T, 4);                                 \
275    TL = _mm_srli_si128(TL, 4);                               \
276    src = _mm_srli_si128(src, 4);                             \
277    pa = _mm_srli_si128(pa, 4);                               \
278  } while (0)
279  static void PredictorAdd11_SSE2(const uint32_t* in, const uint32_t* upper,
280                                  int num_pixels, uint32_t* out) {
281    int i;
282    __m128i pa;
283    __m128i L = _mm_cvtsi32_si128(out[-1]);
284    for (i = 0; i + 4 <= num_pixels; i += 4) {
285      __m128i T = _mm_loadu_si128((const __m128i*)&upper[i]);
286      __m128i TL = _mm_loadu_si128((const __m128i*)&upper[i - 1]);
287      __m128i src = _mm_loadu_si128((const __m128i*)&in[i]);
288      {
289        const __m128i T_lo = _mm_unpacklo_epi32(T, T);
290        const __m128i TL_lo = _mm_unpacklo_epi32(TL, T);
291        const __m128i T_hi = _mm_unpackhi_epi32(T, T);
292        const __m128i TL_hi = _mm_unpackhi_epi32(TL, T);
293        const __m128i s_lo = _mm_sad_epu8(T_lo, TL_lo);
294        const __m128i s_hi = _mm_sad_epu8(T_hi, TL_hi);
295        pa = _mm_packs_epi32(s_lo, s_hi);  
296      }
297      DO_PRED11(0);
298      DO_PRED11_SHIFT;
299      DO_PRED11(1);
300      DO_PRED11_SHIFT;
301      DO_PRED11(2);
302      DO_PRED11_SHIFT;
303      DO_PRED11(3);
304    }
305    if (i != num_pixels) {
306      VP8LPredictorsAdd_C[11](in + i, upper + i, num_pixels - i, out + i);
307    }
308  }
309  #undef DO_PRED11
310  #undef DO_PRED11_SHIFT
311  #define DO_PRED12(DIFF, LANE, OUT) do {            \
312    const __m128i all = _mm_add_epi16(L, (DIFF));    \
313    const __m128i alls = _mm_packus_epi16(all, all); \
314    const __m128i res = _mm_add_epi8(src, alls);     \
315    out[i + (OUT)] = _mm_cvtsi128_si32(res);         \
316    L = _mm_unpacklo_epi8(res, zero);                \
317  } while (0)
318  #define DO_PRED12_SHIFT(DIFF, LANE) do {                    \
319     \
320    if ((LANE) == 0) (DIFF) = _mm_srli_si128((DIFF), 8);      \
321    src = _mm_srli_si128(src, 4);                             \
322  } while (0)
323  static void PredictorAdd12_SSE2(const uint32_t* in, const uint32_t* upper,
324                                  int num_pixels, uint32_t* out) {
325    int i;
326    const __m128i zero = _mm_setzero_si128();
327    const __m128i L8 = _mm_cvtsi32_si128(out[-1]);
328    __m128i L = _mm_unpacklo_epi8(L8, zero);
329    for (i = 0; i + 4 <= num_pixels; i += 4) {
330      __m128i src = _mm_loadu_si128((const __m128i*)&in[i]);
331      const __m128i T = _mm_loadu_si128((const __m128i*)&upper[i]);
332      const __m128i T_lo = _mm_unpacklo_epi8(T, zero);
333      const __m128i T_hi = _mm_unpackhi_epi8(T, zero);
334      const __m128i TL = _mm_loadu_si128((const __m128i*)&upper[i - 1]);
335      const __m128i TL_lo = _mm_unpacklo_epi8(TL, zero);
336      const __m128i TL_hi = _mm_unpackhi_epi8(TL, zero);
337      __m128i diff_lo = _mm_sub_epi16(T_lo, TL_lo);
338      __m128i diff_hi = _mm_sub_epi16(T_hi, TL_hi);
339      DO_PRED12(diff_lo, 0, 0);
340      DO_PRED12_SHIFT(diff_lo, 0);
341      DO_PRED12(diff_lo, 1, 1);
342      DO_PRED12_SHIFT(diff_lo, 1);
343      DO_PRED12(diff_hi, 0, 2);
344      DO_PRED12_SHIFT(diff_hi, 0);
345      DO_PRED12(diff_hi, 1, 3);
346    }
347    if (i != num_pixels) {
348      VP8LPredictorsAdd_C[12](in + i, upper + i, num_pixels - i, out + i);
349    }
350  }
351  #undef DO_PRED12
352  #undef DO_PRED12_SHIFT
353  GENERATE_PREDICTOR_ADD(Predictor13_SSE2, PredictorAdd13_SSE2)
354  static void AddGreenToBlueAndRed_SSE2(const uint32_t* const src, int num_pixels,
355                                        uint32_t* dst) {
356    int i;
357    for (i = 0; i + 4 <= num_pixels; i += 4) {
358      const __m128i in = _mm_loadu_si128((const __m128i*)&src[i]); 
359      const __m128i A = _mm_srli_epi16(in, 8);     
360      const __m128i B = _mm_shufflelo_epi16(A, _MM_SHUFFLE(2, 2, 0, 0));
361      const __m128i C = _mm_shufflehi_epi16(B, _MM_SHUFFLE(2, 2, 0, 0));  
362      const __m128i out = _mm_add_epi8(in, C);
363      _mm_storeu_si128((__m128i*)&dst[i], out);
364    }
365    if (i != num_pixels) {
366      VP8LAddGreenToBlueAndRed_C(src + i, num_pixels - i, dst + i);
367    }
368  }
369  static void TransformColorInverse_SSE2(const VP8LMultipliers* const m,
370                                         const uint32_t* const src,
371                                         int num_pixels, uint32_t* dst) {
372  #define CST(X)  (((int16_t)(m->X << 8)) >> 5)   
373  #define MK_CST_16(HI, LO) \
374    _mm_set1_epi32((int)(((uint32_t)(HI) << 16) | ((LO) & 0xffff)))
375    const __m128i mults_rb = MK_CST_16(CST(green_to_red_), CST(green_to_blue_));
376    const __m128i mults_b2 = MK_CST_16(CST(red_to_blue_), 0);
377  #undef MK_CST_16
378  #undef CST
379    const __m128i mask_ag = _mm_set1_epi32(0xff00ff00);  
380    int i;
381    for (i = 0; i + 4 <= num_pixels; i += 4) {
382      const __m128i in = _mm_loadu_si128((const __m128i*)&src[i]); 
383      const __m128i A = _mm_and_si128(in, mask_ag);     
384      const __m128i B = _mm_shufflelo_epi16(A, _MM_SHUFFLE(2, 2, 0, 0));
385      const __m128i C = _mm_shufflehi_epi16(B, _MM_SHUFFLE(2, 2, 0, 0));  
386      const __m128i D = _mm_mulhi_epi16(C, mults_rb);    
387      const __m128i E = _mm_add_epi8(in, D);             
388      const __m128i F = _mm_slli_epi16(E, 8);            
389      const __m128i G = _mm_mulhi_epi16(F, mults_b2);    
390      const __m128i H = _mm_srli_epi32(G, 8);            
391      const __m128i I = _mm_add_epi8(H, F);              
392      const __m128i J = _mm_srli_epi16(I, 8);            
393      const __m128i out = _mm_or_si128(J, A);
394      _mm_storeu_si128((__m128i*)&dst[i], out);
395    }
396    if (i != num_pixels) {
397      VP8LTransformColorInverse_C(m, src + i, num_pixels - i, dst + i);
398    }
399  }
400  static void ConvertBGRAToRGB_SSE2(const uint32_t* src, int num_pixels,
401                                    uint8_t* dst) {
402    const __m128i* in = (const __m128i*)src;
403    __m128i* out = (__m128i*)dst;
404    while (num_pixels >= 32) {
405      __m128i in0 = _mm_loadu_si128(in + 0);
406      __m128i in1 = _mm_loadu_si128(in + 1);
407      __m128i in2 = _mm_loadu_si128(in + 2);
408      __m128i in3 = _mm_loadu_si128(in + 3);
409      __m128i in4 = _mm_loadu_si128(in + 4);
410      __m128i in5 = _mm_loadu_si128(in + 5);
411      __m128i in6 = _mm_loadu_si128(in + 6);
412      __m128i in7 = _mm_loadu_si128(in + 7);
413      VP8L32bToPlanar_SSE2(&in0, &in1, &in2, &in3);
414      VP8L32bToPlanar_SSE2(&in4, &in5, &in6, &in7);
415      VP8PlanarTo24b_SSE2(&in1, &in5, &in2, &in6, &in3, &in7);
416      _mm_storeu_si128(out + 0, in1);
417      _mm_storeu_si128(out + 1, in5);
418      _mm_storeu_si128(out + 2, in2);
419      _mm_storeu_si128(out + 3, in6);
420      _mm_storeu_si128(out + 4, in3);
421      _mm_storeu_si128(out + 5, in7);
422      in += 8;
423      out += 6;
424      num_pixels -= 32;
425    }
426    if (num_pixels > 0) {
427      VP8LConvertBGRAToRGB_C((const uint32_t*)in, num_pixels, (uint8_t*)out);
428    }
429  }
430  static void ConvertBGRAToRGBA_SSE2(const uint32_t* src,
431                                     int num_pixels, uint8_t* dst) {
432    const __m128i red_blue_mask = _mm_set1_epi32(0x00ff00ffu);
433    const __m128i* in = (const __m128i*)src;
434    __m128i* out = (__m128i*)dst;
435    while (num_pixels >= 8) {
436      const __m128i A1 = _mm_loadu_si128(in++);
437      const __m128i A2 = _mm_loadu_si128(in++);
438      const __m128i B1 = _mm_and_si128(A1, red_blue_mask);     
439      const __m128i B2 = _mm_and_si128(A2, red_blue_mask);     
440      const __m128i C1 = _mm_andnot_si128(red_blue_mask, A1);  
441      const __m128i C2 = _mm_andnot_si128(red_blue_mask, A2);  
442      const __m128i D1 = _mm_shufflelo_epi16(B1, _MM_SHUFFLE(2, 3, 0, 1));
443      const __m128i D2 = _mm_shufflelo_epi16(B2, _MM_SHUFFLE(2, 3, 0, 1));
444      const __m128i E1 = _mm_shufflehi_epi16(D1, _MM_SHUFFLE(2, 3, 0, 1));
445      const __m128i E2 = _mm_shufflehi_epi16(D2, _MM_SHUFFLE(2, 3, 0, 1));
446      const __m128i F1 = _mm_or_si128(E1, C1);
447      const __m128i F2 = _mm_or_si128(E2, C2);
448      _mm_storeu_si128(out++, F1);
449      _mm_storeu_si128(out++, F2);
450      num_pixels -= 8;
451    }
452    if (num_pixels > 0) {
453      VP8LConvertBGRAToRGBA_C((const uint32_t*)in, num_pixels, (uint8_t*)out);
454    }
455  }
456  static void ConvertBGRAToRGBA4444_SSE2(const uint32_t* src,
457                                         int num_pixels, uint8_t* dst) {
458    const __m128i mask_0x0f = _mm_set1_epi8(0x0f);
459    const __m128i mask_0xf0 = _mm_set1_epi8(0xf0);
460    const __m128i* in = (const __m128i*)src;
461    __m128i* out = (__m128i*)dst;
462    while (num_pixels >= 8) {
463      const __m128i bgra0 = _mm_loadu_si128(in++);     
464      const __m128i bgra4 = _mm_loadu_si128(in++);     
465      const __m128i v0l = _mm_unpacklo_epi8(bgra0, bgra4);  
466      const __m128i v0h = _mm_unpackhi_epi8(bgra0, bgra4);  
467      const __m128i v1l = _mm_unpacklo_epi8(v0l, v0h);    
468      const __m128i v1h = _mm_unpackhi_epi8(v0l, v0h);    
469      const __m128i v2l = _mm_unpacklo_epi8(v1l, v1h);    
470      const __m128i v2h = _mm_unpackhi_epi8(v1l, v1h);    
471      const __m128i ga0 = _mm_unpackhi_epi64(v2l, v2h);   
472      const __m128i rb0 = _mm_unpacklo_epi64(v2h, v2l);   
473      const __m128i ga1 = _mm_srli_epi16(ga0, 4);         
474      const __m128i rb1 = _mm_and_si128(rb0, mask_0xf0);  
475      const __m128i ga2 = _mm_and_si128(ga1, mask_0x0f);  
476      const __m128i rgba0 = _mm_or_si128(ga2, rb1);       
477      const __m128i rgba1 = _mm_srli_si128(rgba0, 8);     
478  #if (WEBP_SWAP_16BIT_CSP == 1)
479      const __m128i rgba = _mm_unpacklo_epi8(rgba1, rgba0);  
480  #else
481      const __m128i rgba = _mm_unpacklo_epi8(rgba0, rgba1);  
482  #endif
483      _mm_storeu_si128(out++, rgba);
484      num_pixels -= 8;
485    }
486    if (num_pixels > 0) {
487      VP8LConvertBGRAToRGBA4444_C((const uint32_t*)in, num_pixels, (uint8_t*)out);
488    }
489  }
490  static void ConvertBGRAToRGB565_SSE2(const uint32_t* src,
491                                       int num_pixels, uint8_t* dst) {
492    const __m128i mask_0xe0 = _mm_set1_epi8(0xe0);
493    const __m128i mask_0xf8 = _mm_set1_epi8(0xf8);
494    const __m128i mask_0x07 = _mm_set1_epi8(0x07);
495    const __m128i* in = (const __m128i*)src;
496    __m128i* out = (__m128i*)dst;
497    while (num_pixels >= 8) {
498      const __m128i bgra0 = _mm_loadu_si128(in++);     
499      const __m128i bgra4 = _mm_loadu_si128(in++);     
500      const __m128i v0l = _mm_unpacklo_epi8(bgra0, bgra4);  
501      const __m128i v0h = _mm_unpackhi_epi8(bgra0, bgra4);  
502      const __m128i v1l = _mm_unpacklo_epi8(v0l, v0h);      
503      const __m128i v1h = _mm_unpackhi_epi8(v0l, v0h);      
504      const __m128i v2l = _mm_unpacklo_epi8(v1l, v1h);      
505      const __m128i v2h = _mm_unpackhi_epi8(v1l, v1h);      
506      const __m128i ga0 = _mm_unpackhi_epi64(v2l, v2h);     
507      const __m128i rb0 = _mm_unpacklo_epi64(v2h, v2l);     
508      const __m128i rb1 = _mm_and_si128(rb0, mask_0xf8);    
509      const __m128i g_lo1 = _mm_srli_epi16(ga0, 5);
510      const __m128i g_lo2 = _mm_and_si128(g_lo1, mask_0x07);  
511      const __m128i g_hi1 = _mm_slli_epi16(ga0, 3);
512      const __m128i g_hi2 = _mm_and_si128(g_hi1, mask_0xe0);  
513      const __m128i b0 = _mm_srli_si128(rb1, 8);              
514      const __m128i rg1 = _mm_or_si128(rb1, g_lo2);           
515      const __m128i b1 = _mm_srli_epi16(b0, 3);
516      const __m128i gb1 = _mm_or_si128(b1, g_hi2);            
517  #if (WEBP_SWAP_16BIT_CSP == 1)
518      const __m128i rgba = _mm_unpacklo_epi8(gb1, rg1);     
519  #else
520      const __m128i rgba = _mm_unpacklo_epi8(rg1, gb1);     
521  #endif
522      _mm_storeu_si128(out++, rgba);
523      num_pixels -= 8;
524    }
525    if (num_pixels > 0) {
526      VP8LConvertBGRAToRGB565_C((const uint32_t*)in, num_pixels, (uint8_t*)out);
527    }
528  }
529  static void ConvertBGRAToBGR_SSE2(const uint32_t* src,
530                                    int num_pixels, uint8_t* dst) {
531    const __m128i mask_l = _mm_set_epi32(0, 0x00ffffff, 0, 0x00ffffff);
532    const __m128i mask_h = _mm_set_epi32(0x00ffffff, 0, 0x00ffffff, 0);
533    const __m128i* in = (const __m128i*)src;
534    const uint8_t* const end = dst + num_pixels * 3;
535    while (dst + 26 <= end) {
536      const __m128i bgra0 = _mm_loadu_si128(in++);     
537      const __m128i bgra4 = _mm_loadu_si128(in++);     
538      const __m128i a0l = _mm_and_si128(bgra0, mask_l);   
539      const __m128i a4l = _mm_and_si128(bgra4, mask_l);   
540      const __m128i a0h = _mm_and_si128(bgra0, mask_h);   
541      const __m128i a4h = _mm_and_si128(bgra4, mask_h);   
542      const __m128i b0h = _mm_srli_epi64(a0h, 8);         
543      const __m128i b4h = _mm_srli_epi64(a4h, 8);         
544      const __m128i c0 = _mm_or_si128(a0l, b0h);          
545      const __m128i c4 = _mm_or_si128(a4l, b4h);          
546      const __m128i c2 = _mm_srli_si128(c0, 8);
547      const __m128i c6 = _mm_srli_si128(c4, 8);
548      _mm_storel_epi64((__m128i*)(dst +   0), c0);
549      _mm_storel_epi64((__m128i*)(dst +   6), c2);
550      _mm_storel_epi64((__m128i*)(dst +  12), c4);
551      _mm_storel_epi64((__m128i*)(dst +  18), c6);
552      dst += 24;
553      num_pixels -= 8;
554    }
555    if (num_pixels > 0) {
556      VP8LConvertBGRAToBGR_C((const uint32_t*)in, num_pixels, dst);
557    }
558  }
559  extern void VP8LDspInitSSE2(void);
560  WEBP_TSAN_IGNORE_FUNCTION void VP8LDspInitSSE2(void) {
561    VP8LPredictors[5] = Predictor5_SSE2;
562    VP8LPredictors[6] = Predictor6_SSE2;
563    VP8LPredictors[7] = Predictor7_SSE2;
564    VP8LPredictors[8] = Predictor8_SSE2;
565    VP8LPredictors[9] = Predictor9_SSE2;
566    VP8LPredictors[10] = Predictor10_SSE2;
567    VP8LPredictors[11] = Predictor11_SSE2;
568    VP8LPredictors[12] = Predictor12_SSE2;
569    VP8LPredictors[13] = Predictor13_SSE2;
570    VP8LPredictorsAdd[0] = PredictorAdd0_SSE2;
571    VP8LPredictorsAdd[1] = PredictorAdd1_SSE2;
572    VP8LPredictorsAdd[2] = PredictorAdd2_SSE2;
573    VP8LPredictorsAdd[3] = PredictorAdd3_SSE2;
574    VP8LPredictorsAdd[4] = PredictorAdd4_SSE2;
575    VP8LPredictorsAdd[5] = PredictorAdd5_SSE2;
576    VP8LPredictorsAdd[6] = PredictorAdd6_SSE2;
577    VP8LPredictorsAdd[7] = PredictorAdd7_SSE2;
578    VP8LPredictorsAdd[8] = PredictorAdd8_SSE2;
579    VP8LPredictorsAdd[9] = PredictorAdd9_SSE2;
580    VP8LPredictorsAdd[10] = PredictorAdd10_SSE2;
581    VP8LPredictorsAdd[11] = PredictorAdd11_SSE2;
582    VP8LPredictorsAdd[12] = PredictorAdd12_SSE2;
583    VP8LPredictorsAdd[13] = PredictorAdd13_SSE2;
584    VP8LAddGreenToBlueAndRed = AddGreenToBlueAndRed_SSE2;
585    VP8LTransformColorInverse = TransformColorInverse_SSE2;
586    VP8LConvertBGRAToRGB = ConvertBGRAToRGB_SSE2;
587    VP8LConvertBGRAToRGBA = ConvertBGRAToRGBA_SSE2;
588    VP8LConvertBGRAToRGBA4444 = ConvertBGRAToRGBA4444_SSE2;
589    VP8LConvertBGRAToRGB565 = ConvertBGRAToRGB565_SSE2;
590    VP8LConvertBGRAToBGR = ConvertBGRAToBGR_SSE2;
591  }
592  #else  
593  WEBP_DSP_INIT_STUB(VP8LDspInitSSE2)
594  #endif  
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from PINRemoteImage-MDEwOlJlcG9zaXRvcnkzOTUzNzEwMw==-flat-vp8_dec.c</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from PINRemoteImage-MDEwOlJlcG9zaXRvcnkzOTUzNzEwMw==-flat-lossless_sse2.c</div>
                </div>
                <div class="column column_space"><pre><code>141    return !br->eof_;
142  }
143  static VP8StatusCode ParsePartitions(VP8Decoder* const dec,
144                                       const uint8_t* buf, size_t size) {
145    VP8BitReader* const br = &dec->br_;
</pre></code></div>
                <div class="column column_space"><pre><code>19    return output;
20  }
21  static WEBP_INLINE uint32_t ClampedAddSubtractHalf_SSE2(uint32_t c0,
22                                                          uint32_t c1,
23                                                          uint32_t c2) {
24    const __m128i zero = _mm_setzero_si128();
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    