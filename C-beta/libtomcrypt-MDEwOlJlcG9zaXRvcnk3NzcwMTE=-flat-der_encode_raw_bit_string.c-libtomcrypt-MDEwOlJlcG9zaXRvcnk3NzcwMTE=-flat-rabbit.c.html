
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 3.45489443378119%, Tokens: 9, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>libtomcrypt-MDEwOlJlcG9zaXRvcnk3NzcwMTE=-flat-der_encode_raw_bit_string.c</h3>
            <pre><code>1  #include "tomcrypt_private.h"
2  #ifdef LTC_DER
3  #define getbit(n, k) (((n) & ( 1 << (k) )) >> (k))
<span onclick='openModal()' class='match'>4  int der_encode_raw_bit_string(const unsigned char *in, unsigned long inlen,
5                                  unsigned char *out, unsigned long *outlen)
6  {
7     unsigned long len, x, y;
8     unsigned char buf;
</span>9     int           err;
10     LTC_ARGCHK(in     != NULL);
11     LTC_ARGCHK(out    != NULL);
12     LTC_ARGCHK(outlen != NULL);
13     if ((err = der_length_bit_string(inlen, &len)) != CRYPT_OK) {
14        return err;
15     }
16     if (len > *outlen) {
17        *outlen = len;
18        return CRYPT_BUFFER_OVERFLOW;
19     }
20     x = 0;
21     y = ((inlen + 7) >> 3) + 1;
22     out[x++] = 0x03;
23     len = *outlen - x;
24     if ((err = der_encode_asn1_length(y, out + x, &len)) != CRYPT_OK) {
25        return err;
26     }
27     x += len;
28     out[x++] = (unsigned char)((8 - inlen) & 7);
29     for (y = buf = 0; y < inlen; y++) {
30        buf |= (getbit(in[y/8],7-y%8)?1:0) << (7 - (y & 7));
31        if ((y & 7) == 7) {
32           out[x++] = buf;
33           buf      = 0;
34        }
35     }
36     if (inlen & 7) {
37        out[x++] = buf;
38     }
39     *outlen = x;
40     return CRYPT_OK;
41  }
42  #endif
</code></pre>
        </div>
        <div class="column">
            <h3>libtomcrypt-MDEwOlJlcG9zaXRvcnk3NzcwMTE=-flat-rabbit.c</h3>
            <pre><code>1  #include "tomcrypt_private.h"
2  #ifdef LTC_RABBIT
3  static LTC_INLINE ulong32 ss_rabbit_g_func(ulong32 x);
4  static LTC_INLINE void ss_rabbit_next_state(rabbit_ctx *p_instance);
5  static LTC_INLINE void ss_rabbit_gen_1_block(rabbit_state* st, unsigned char *out);
6  static LTC_INLINE ulong32 ss_rabbit_g_func(ulong32 x)
7  {
8     ulong32 a, b, h, l;
9     a = x &  0xFFFF;
10     b = x >> 16;
11     h = ((((ulong32)(a*a)>>17) + (ulong32)(a*b))>>15) + b*b;
12     l = x * x;
13     return (ulong32)(h^l);
14  }
15  static LTC_INLINE void ss_rabbit_next_state(rabbit_ctx *p_instance)
16  {
17     ulong32 g[8], c_old[8], i;
18     for (i=0; i<8; i++) {
19        c_old[i] = p_instance->c[i];
20     }
21     p_instance->c[0] = (ulong32)(p_instance->c[0] + 0x4D34D34D + p_instance->carry);
22     p_instance->c[1] = (ulong32)(p_instance->c[1] + 0xD34D34D3 + (p_instance->c[0] < c_old[0]));
23     p_instance->c[2] = (ulong32)(p_instance->c[2] + 0x34D34D34 + (p_instance->c[1] < c_old[1]));
24     p_instance->c[3] = (ulong32)(p_instance->c[3] + 0x4D34D34D + (p_instance->c[2] < c_old[2]));
25     p_instance->c[4] = (ulong32)(p_instance->c[4] + 0xD34D34D3 + (p_instance->c[3] < c_old[3]));
26     p_instance->c[5] = (ulong32)(p_instance->c[5] + 0x34D34D34 + (p_instance->c[4] < c_old[4]));
27     p_instance->c[6] = (ulong32)(p_instance->c[6] + 0x4D34D34D + (p_instance->c[5] < c_old[5]));
28     p_instance->c[7] = (ulong32)(p_instance->c[7] + 0xD34D34D3 + (p_instance->c[6] < c_old[6]));
29     p_instance->carry = (p_instance->c[7] < c_old[7]);
30     for (i=0;i<8;i++) {
31        g[i] = ss_rabbit_g_func((ulong32)(p_instance->x[i] + p_instance->c[i]));
32     }
33     p_instance->x[0] = (ulong32)(g[0] + ROLc(g[7],16) + ROLc(g[6], 16));
34     p_instance->x[1] = (ulong32)(g[1] + ROLc(g[0], 8) + g[7]);
35     p_instance->x[2] = (ulong32)(g[2] + ROLc(g[1],16) + ROLc(g[0], 16));
36     p_instance->x[3] = (ulong32)(g[3] + ROLc(g[2], 8) + g[1]);
37     p_instance->x[4] = (ulong32)(g[4] + ROLc(g[3],16) + ROLc(g[2], 16));
38     p_instance->x[5] = (ulong32)(g[5] + ROLc(g[4], 8) + g[3]);
39     p_instance->x[6] = (ulong32)(g[6] + ROLc(g[5],16) + ROLc(g[4], 16));
40     p_instance->x[7] = (ulong32)(g[7] + ROLc(g[6], 8) + g[5]);
41  }
42  static LTC_INLINE void ss_rabbit_gen_1_block(rabbit_state* st, unsigned char *out)
43  {
44      ulong32 *ptr;
45      ss_rabbit_next_state(&(st->work_ctx));
46      ptr = (ulong32*)&(st->work_ctx.x);
47      STORE32L((ptr[0] ^ (ptr[5]>>16) ^ (ulong32)(ptr[3]<<16)), out+ 0);
48      STORE32L((ptr[2] ^ (ptr[7]>>16) ^ (ulong32)(ptr[5]<<16)), out+ 4);
49      STORE32L((ptr[4] ^ (ptr[1]>>16) ^ (ulong32)(ptr[7]<<16)), out+ 8);
50      STORE32L((ptr[6] ^ (ptr[3]>>16) ^ (ulong32)(ptr[1]<<16)), out+12);
51  }
52  int rabbit_setup(rabbit_state* st, const unsigned char *key, unsigned long keylen)
53  {
54     ulong32 k0, k1, k2, k3, i;
55     unsigned char  tmpkey[16] = {0};
56     LTC_ARGCHK(st != NULL);
57     LTC_ARGCHK(key != NULL);
58     LTC_ARGCHK(keylen <= 16);
59     XMEMSET(st, 0, sizeof(rabbit_state));
60     XMEMCPY(tmpkey, key, keylen);
61     LOAD32L(k0, tmpkey+ 0);
62     LOAD32L(k1, tmpkey+ 4);
63     LOAD32L(k2, tmpkey+ 8);
64     LOAD32L(k3, tmpkey+12);
65  #ifdef LTC_CLEAN_STACK
66     zeromem(tmpkey, sizeof(tmpkey));
67  #endif
68     st->master_ctx.x[0] = k0;
69     st->master_ctx.x[2] = k1;
70     st->master_ctx.x[4] = k2;
71     st->master_ctx.x[6] = k3;
72     st->master_ctx.x[1] = (ulong32)(k3<<16) | (k2>>16);
73     st->master_ctx.x[3] = (ulong32)(k0<<16) | (k3>>16);
74     st->master_ctx.x[5] = (ulong32)(k1<<16) | (k0>>16);
75     st->master_ctx.x[7] = (ulong32)(k2<<16) | (k1>>16);
76     st->master_ctx.c[0] = ROLc(k2, 16);
77     st->master_ctx.c[2] = ROLc(k3, 16);
78     st->master_ctx.c[4] = ROLc(k0, 16);
79     st->master_ctx.c[6] = ROLc(k1, 16);
80     st->master_ctx.c[1] = (k0&0xFFFF0000) | (k1&0xFFFF);
81     st->master_ctx.c[3] = (k1&0xFFFF0000) | (k2&0xFFFF);
82     st->master_ctx.c[5] = (k2&0xFFFF0000) | (k3&0xFFFF);
83     st->master_ctx.c[7] = (k3&0xFFFF0000) | (k0&0xFFFF);
84     st->master_ctx.carry = 0;
85     for (i=0; i<4; i++) {
86        ss_rabbit_next_state(&(st->master_ctx));
87     }
88     for (i=0; i<8; i++) {
89        st->master_ctx.c[i] ^= st->master_ctx.x[(i+4)&0x7];
90     }
91     for (i=0; i<8; i++) {
92        st->work_ctx.x[i] = st->master_ctx.x[i];
93        st->work_ctx.c[i] = st->master_ctx.c[i];
94     }
95     st->work_ctx.carry = st->master_ctx.carry;
96     XMEMSET(&(st->block), 0, sizeof(st->block));
97     st->unused = 0;
98     return CRYPT_OK;
99  }
100  int rabbit_setiv(rabbit_state* st, const unsigned char *iv, unsigned long ivlen)
101  {
102     ulong32 i0, i1, i2, i3, i;
103     unsigned char  tmpiv[8] = {0};
104     LTC_ARGCHK(st != NULL);
105     LTC_ARGCHK(iv != NULL || ivlen == 0);
106     LTC_ARGCHK(ivlen <= 8);
107     if (iv && ivlen > 0) XMEMCPY(tmpiv, iv, ivlen);
108     LOAD32L(i0, tmpiv+0);
109     LOAD32L(i2, tmpiv+4);
110     i1 = (i0>>16) | (i2&0xFFFF0000);
111     i3 = (i2<<16) | (i0&0x0000FFFF);
112     st->work_ctx.c[0] = st->master_ctx.c[0] ^ i0;
113     st->work_ctx.c[1] = st->master_ctx.c[1] ^ i1;
114     st->work_ctx.c[2] = st->master_ctx.c[2] ^ i2;
115     st->work_ctx.c[3] = st->master_ctx.c[3] ^ i3;
116     st->work_ctx.c[4] = st->master_ctx.c[4] ^ i0;
117     st->work_ctx.c[5] = st->master_ctx.c[5] ^ i1;
118     st->work_ctx.c[6] = st->master_ctx.c[6] ^ i2;
119     st->work_ctx.c[7] = st->master_ctx.c[7] ^ i3;
120     for (i=0; i<8; i++) {
121        st->work_ctx.x[i] = st->master_ctx.x[i];
122     }
123     st->work_ctx.carry = st->master_ctx.carry;
124     for (i=0; i<4; i++) {
125        ss_rabbit_next_state(&(st->work_ctx));
126     }
127     XMEMSET(&(st->block), 0, sizeof(st->block));
128     st->unused = 0;
129     return CRYPT_OK;
130  }
<span onclick='openModal()' class='match'>131  int rabbit_crypt(rabbit_state* st, const unsigned char *in, unsigned long inlen, unsigned char *out)
132  {
133     unsigned char buf[16];
134     unsigned long i, j;
</span>135     if (inlen == 0) return CRYPT_OK; &bsol;* nothing to do */
136     LTC_ARGCHK(st        != NULL);
137     LTC_ARGCHK(in        != NULL);
138     LTC_ARGCHK(out       != NULL);
139     if (st->unused > 0) {
140        j = MIN(st->unused, inlen);
141        for (i = 0; i < j; ++i, st->unused--) out[i] = in[i] ^ st->block[16 - st->unused];
142        inlen -= j;
143        if (inlen == 0) return CRYPT_OK;
144        out += j;
145        in  += j;
146     }
147     for (;;) {
148       ss_rabbit_gen_1_block(st, buf);
149       if (inlen <= 16) {
150         for (i = 0; i < inlen; ++i) out[i] = in[i] ^ buf[i];
151         st->unused = 16 - inlen;
152         for (i = inlen; i < 16; ++i) st->block[i] = buf[i];
153         return CRYPT_OK;
154       }
155       for (i = 0; i < 16; ++i) out[i] = in[i] ^ buf[i];
156       inlen -= 16;
157       out += 16;
158       in  += 16;
159     }
160  }
161  int rabbit_keystream(rabbit_state *st, unsigned char *out, unsigned long outlen)
162  {
163     if (outlen == 0) return CRYPT_OK; &bsol;* nothing to do */
164     LTC_ARGCHK(out != NULL);
165     XMEMSET(out, 0, outlen);
166     return rabbit_crypt(st, out, outlen, out);
167  }
168  int rabbit_done(rabbit_state *st)
169  {
170     LTC_ARGCHK(st != NULL);
171     zeromem(st, sizeof(rabbit_state));
172     return CRYPT_OK;
173  }
174  int rabbit_test(void)
175  {
176  #ifndef LTC_TEST
177     return CRYPT_NOP;
178  #else
179     rabbit_state st;
180     int err;
181     unsigned char out[1000] = { 0 };
182     {
183        {
184           unsigned char k[]  = { 0x0F, 0x62, 0xB5, 0x08, 0x5B, 0xAE, 0x01, 0x54,
185                                  0xA7, 0xFA, 0x4D, 0xA0, 0xF3, 0x46, 0x99, 0xEC };
186           unsigned char iv[] = { 0x28, 0x8F, 0xF6, 0x5D, 0xC4, 0x2B, 0x92, 0xF9 };
187           char pt[64]        = { 0 };
188           unsigned char ct[] = { 0x61, 0x3C, 0xB0, 0xBA, 0x96, 0xAF, 0xF6, 0xCA,
189                                  0xCF, 0x2A, 0x45, 0x9A, 0x10, 0x2A, 0x7F, 0x78,
190                                  0xCA, 0x98, 0x5C, 0xF8, 0xFD, 0xD1, 0x47, 0x40,
191                                  0x18, 0x75, 0x8E, 0x36, 0xAE, 0x99, 0x23, 0xF5,
192                                  0x19, 0xD1, 0x3D, 0x71, 0x8D, 0xAF, 0x8D, 0x7C,
193                                  0x0C, 0x10, 0x9B, 0x79, 0xD5, 0x74, 0x94, 0x39,
194                                  0xB7, 0xEF, 0xA4, 0xC4, 0xC9, 0xC8, 0xD2, 0x9D,
195                                  0xC5, 0xB3, 0x88, 0x83, 0x14, 0xA6, 0x81, 0x6F };
196           unsigned long ptlen = sizeof(pt);
197           if ((err = rabbit_setup(&st, k, sizeof(k)))                   != CRYPT_OK) return err;
198           if ((err = rabbit_setiv(&st, iv, sizeof(iv)))                 != CRYPT_OK) return err;
199           if ((err = rabbit_crypt(&st, (unsigned char*)pt, ptlen, out)) != CRYPT_OK) return err;
200           if (compare_testvector(out, ptlen, ct, ptlen, "RABBIT-TV1", 1))   return CRYPT_FAIL_TESTVECTOR;
201        }
202        {
203           unsigned char k[]  = { 0x0F, 0x62, 0xB5, 0x08, 0x5B, 0xAE, 0x01, 0x54,
204                                  0xA7, 0xFA, 0x4D, 0xA0, 0xF3, 0x46, 0x99, 0xEC };
205           unsigned char iv[] = { 0x28, 0x8F, 0xF6, 0x5D, 0xC4, 0x2B, 0x92, 0xF9 };
206           char          pt[39] = { 0 };
207           unsigned char ct[] = { 0x61, 0x3C, 0xB0, 0xBA,   0x96, 0xAF, 0xF6, 0xCA,
208                                  0xCF, 0x2A, 0x45, 0x9A,   0x10, 0x2A, 0x7F, 0x78,
209                                  0xCA, 0x98, 0x5C, 0xF8,   0xFD, 0xD1, 0x47, 0x40,
210                                  0x18, 0x75, 0x8E, 0x36,   0xAE, 0x99, 0x23, 0xF5,
211                                  0x19, 0xD1, 0x3D, 0x71,   0x8D, 0xAF, 0x8D };
212           unsigned long ptlen = sizeof(pt);
213           if ((err = rabbit_setup(&st, k, sizeof(k)))                          != CRYPT_OK) return err;
214           if ((err = rabbit_setiv(&st, iv, sizeof(iv)))                        != CRYPT_OK) return err;
215           if ((err = rabbit_crypt(&st, (unsigned char*)pt,       5, out))      != CRYPT_OK) return err;
216           if ((err = rabbit_crypt(&st, (unsigned char*)pt +  5, 11, out +  5)) != CRYPT_OK) return err;
217           if ((err = rabbit_crypt(&st, (unsigned char*)pt + 16, 14, out + 16)) != CRYPT_OK) return err;
218           if ((err = rabbit_crypt(&st, (unsigned char*)pt + 30,  2, out + 30)) != CRYPT_OK) return err;
219           if ((err = rabbit_crypt(&st, (unsigned char*)pt + 32,  7, out + 32)) != CRYPT_OK) return err;
220           if (compare_testvector(out, ptlen, ct, ptlen, "RABBIT-TV2", 1))   return CRYPT_FAIL_TESTVECTOR;
221        }
222        {
223           unsigned char k[]  = { 0x0F, 0x62, 0xB5, 0x08, 0x5B, 0xAE, 0x01, 0x54,
224                                  0xA7, 0xFA, 0x4D, 0xA0, 0xF3, 0x46, 0x99, 0xEC };
225           unsigned char iv[] = { 0x28, 0x8F, 0xF6, 0x5D, 0xC4, 0x2B, 0x92, 0xF9 };
226           char          pt[] = "Kilroy was here, there, and everywhere!";
227           unsigned char ct[] = { 0x2a, 0x55, 0xdc, 0xc8,   0xf9, 0xd6, 0xd6, 0xbd,
228                                  0xae, 0x59, 0x65, 0xf2,   0x75, 0x58, 0x1a, 0x54,
229                                  0xea, 0xec, 0x34, 0x9d,   0x8f, 0xb4, 0x6b, 0x60,
230                                  0x79, 0x1b, 0xea, 0x16,   0xcb, 0xef, 0x46, 0x87,
231                                  0x60, 0xa6, 0x55, 0x14,   0xff, 0xca, 0xac };
232           unsigned long ptlen = XSTRLEN(pt);
233           unsigned char out2[1000] = { 0 };
234           unsigned char nulls[1000] = { 0 };
235           if ((err = rabbit_setup(&st, k, sizeof(k)))                          != CRYPT_OK) return err;
236           if ((err = rabbit_setiv(&st, iv, sizeof(iv)))                        != CRYPT_OK) return err;
237           if ((err = rabbit_crypt(&st, (unsigned char*)pt,       5, out))      != CRYPT_OK) return err;
238           if ((err = rabbit_crypt(&st, (unsigned char*)pt +  5, 29, out +  5)) != CRYPT_OK) return err;
239           if ((err = rabbit_crypt(&st, (unsigned char*)pt + 34,  5, out + 34)) != CRYPT_OK) return err;
240           if (compare_testvector(out, ptlen, ct, ptlen, "RABBIT-TV3", 1))   return CRYPT_FAIL_TESTVECTOR;
241           if ((err = rabbit_memory(k, sizeof(k), iv, sizeof(iv),
242                                     (unsigned char*)pt, sizeof(pt), out))      != CRYPT_OK) return err;
243           if (compare_testvector(out, ptlen, ct, ptlen, "RABBIT-TV4", 1))   return CRYPT_FAIL_TESTVECTOR;
244           if ((err = rabbit_setiv(&st, iv, sizeof(iv)))                        != CRYPT_OK) return err;
245           if ((err = rabbit_crypt(&st, out, ptlen, out2))                      != CRYPT_OK) return err;
246           if (compare_testvector(out2, ptlen, pt, ptlen, "RABBIT-TV5", 1))  return CRYPT_FAIL_TESTVECTOR;
247           if ((err = rabbit_done(&st))                      != CRYPT_OK) return err;
248           if (compare_testvector(&st, sizeof(st), nulls, sizeof(st), "RABBIT-TV6", 1))  return CRYPT_FAIL_TESTVECTOR;
249        }
250        return CRYPT_OK;
251     }
252  #endif
253  }
254  #endif
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from libtomcrypt-MDEwOlJlcG9zaXRvcnk3NzcwMTE=-flat-der_encode_raw_bit_string.c</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from libtomcrypt-MDEwOlJlcG9zaXRvcnk3NzcwMTE=-flat-rabbit.c</div>
                </div>
                <div class="column column_space"><pre><code>4  int der_encode_raw_bit_string(const unsigned char *in, unsigned long inlen,
5                                  unsigned char *out, unsigned long *outlen)
6  {
7     unsigned long len, x, y;
8     unsigned char buf;
</pre></code></div>
                <div class="column column_space"><pre><code>131  int rabbit_crypt(rabbit_state* st, const unsigned char *in, unsigned long inlen, unsigned char *out)
132  {
133     unsigned char buf[16];
134     unsigned long i, j;
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    