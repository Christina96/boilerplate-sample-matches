
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 6.2015503875969%, Tokens: 8, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>Adafruit_nRF52_Arduino-MDEwOlJlcG9zaXRvcnk3NDM1NDcyOQ==-flat-ble_types.h</h3>
            <pre><code>1  #ifndef BLE_TYPES_H__
2  #define BLE_TYPES_H__
3  #include <stdint.h>
4  #ifdef __cplusplus
5  extern "C" {
6  #endif
7  #define BLE_CONN_HANDLE_INVALID 0xFFFF  &bsol;**< Invalid Connection Handle. */
8  #define BLE_CONN_HANDLE_ALL     0xFFFE  &bsol;**< Applies to all Connection Handles. */
9  #define BLE_UUID_UNKNOWN                              0x0000 &bsol;**< Reserved UUID. */
10  #define BLE_UUID_SERVICE_PRIMARY                      0x2800 &bsol;**< Primary Service. */
11  #define BLE_UUID_SERVICE_SECONDARY                    0x2801 &bsol;**< Secondary Service. */
12  #define BLE_UUID_SERVICE_INCLUDE                      0x2802 &bsol;**< Include. */
13  #define BLE_UUID_CHARACTERISTIC                       0x2803 &bsol;**< Characteristic. */
14  #define BLE_UUID_DESCRIPTOR_CHAR_EXT_PROP             0x2900 &bsol;**< Characteristic Extended Properties Descriptor. */
15  #define BLE_UUID_DESCRIPTOR_CHAR_USER_DESC            0x2901 &bsol;**< Characteristic User Description Descriptor. */
16  #define BLE_UUID_DESCRIPTOR_CLIENT_CHAR_CONFIG        0x2902 &bsol;**< Client Characteristic Configuration Descriptor. */
17  #define BLE_UUID_DESCRIPTOR_SERVER_CHAR_CONFIG        0x2903 &bsol;**< Server Characteristic Configuration Descriptor. */
18  #define BLE_UUID_DESCRIPTOR_CHAR_PRESENTATION_FORMAT  0x2904 &bsol;**< Characteristic Presentation Format Descriptor. */
19  #define BLE_UUID_DESCRIPTOR_CHAR_AGGREGATE_FORMAT     0x2905 &bsol;**< Characteristic Aggregate Format Descriptor. */
20  #define BLE_UUID_GATT                                 0x1801 &bsol;**< Generic Attribute Profile. */
21  #define BLE_UUID_GATT_CHARACTERISTIC_SERVICE_CHANGED  0x2A05 &bsol;**< Service Changed Characteristic. */
22  #define BLE_UUID_GAP                                  0x1800 &bsol;**< Generic Access Profile. */
23  #define BLE_UUID_GAP_CHARACTERISTIC_DEVICE_NAME       0x2A00 &bsol;**< Device Name Characteristic. */
24  #define BLE_UUID_GAP_CHARACTERISTIC_APPEARANCE        0x2A01 &bsol;**< Appearance Characteristic. */
25  #define BLE_UUID_GAP_CHARACTERISTIC_RECONN_ADDR       0x2A03 &bsol;**< Reconnection Address Characteristic. */
26  #define BLE_UUID_GAP_CHARACTERISTIC_PPCP              0x2A04 &bsol;**< Peripheral Preferred Connection Parameters Characteristic. */
27  #define BLE_UUID_GAP_CHARACTERISTIC_CAR               0x2AA6 &bsol;**< Central Address Resolution Characteristic. */
28  #define BLE_UUID_GAP_CHARACTERISTIC_RPA_ONLY          0x2AC9 &bsol;**< Resolvable Private Address Only Characteristic. */
29  #define BLE_UUID_TYPE_UNKNOWN       0x00 &bsol;**< Invalid UUID type. */
30  #define BLE_UUID_TYPE_BLE           0x01 &bsol;**< Bluetooth SIG UUID (16-bit). */
31  #define BLE_UUID_TYPE_VENDOR_BEGIN  0x02 &bsol;**< Vendor UUID types start at this index (128-bit). */
32  #define BLE_APPEARANCE_UNKNOWN                                0 &bsol;**< Unknown. */
33  #define BLE_APPEARANCE_GENERIC_PHONE                         64 &bsol;**< Generic Phone. */
34  #define BLE_APPEARANCE_GENERIC_COMPUTER                     128 &bsol;**< Generic Computer. */
35  #define BLE_APPEARANCE_GENERIC_WATCH                        192 &bsol;**< Generic Watch. */
36  #define BLE_APPEARANCE_WATCH_SPORTS_WATCH                   193 &bsol;**< Watch: Sports Watch. */
37  #define BLE_APPEARANCE_GENERIC_CLOCK                        256 &bsol;**< Generic Clock. */
38  #define BLE_APPEARANCE_GENERIC_DISPLAY                      320 &bsol;**< Generic Display. */
39  #define BLE_APPEARANCE_GENERIC_REMOTE_CONTROL               384 &bsol;**< Generic Remote Control. */
40  #define BLE_APPEARANCE_GENERIC_EYE_GLASSES                  448 &bsol;**< Generic Eye-glasses. */
41  #define BLE_APPEARANCE_GENERIC_TAG                          512 &bsol;**< Generic Tag. */
42  #define BLE_APPEARANCE_GENERIC_KEYRING                      576 &bsol;**< Generic Keyring. */
43  #define BLE_APPEARANCE_GENERIC_MEDIA_PLAYER                 640 &bsol;**< Generic Media Player. */
44  #define BLE_APPEARANCE_GENERIC_BARCODE_SCANNER              704 &bsol;**< Generic Barcode Scanner. */
45  #define BLE_APPEARANCE_GENERIC_THERMOMETER                  768 &bsol;**< Generic Thermometer. */
46  #define BLE_APPEARANCE_THERMOMETER_EAR                      769 &bsol;**< Thermometer: Ear. */
47  #define BLE_APPEARANCE_GENERIC_HEART_RATE_SENSOR            832 &bsol;**< Generic Heart rate Sensor. */
48  #define BLE_APPEARANCE_HEART_RATE_SENSOR_HEART_RATE_BELT    833 &bsol;**< Heart Rate Sensor: Heart Rate Belt. */
49  #define BLE_APPEARANCE_GENERIC_BLOOD_PRESSURE               896 &bsol;**< Generic Blood Pressure. */
50  #define BLE_APPEARANCE_BLOOD_PRESSURE_ARM                   897 &bsol;**< Blood Pressure: Arm. */
51  #define BLE_APPEARANCE_BLOOD_PRESSURE_WRIST                 898 &bsol;**< Blood Pressure: Wrist. */
52  #define BLE_APPEARANCE_GENERIC_HID                          960 &bsol;**< Human Interface Device (HID). */
53  #define BLE_APPEARANCE_HID_KEYBOARD                         961 &bsol;**< Keyboard (HID Subtype). */
54  #define BLE_APPEARANCE_HID_MOUSE                            962 &bsol;**< Mouse (HID Subtype). */
55  #define BLE_APPEARANCE_HID_JOYSTICK                         963 &bsol;**< Joystick (HID Subtype). */
56  #define BLE_APPEARANCE_HID_GAMEPAD                          964 &bsol;**< Gamepad (HID Subtype). */
57  #define BLE_APPEARANCE_HID_DIGITIZERSUBTYPE                 965 &bsol;**< Digitizer Tablet (HID Subtype). */
58  #define BLE_APPEARANCE_HID_CARD_READER                      966 &bsol;**< Card Reader (HID Subtype). */
59  #define BLE_APPEARANCE_HID_DIGITAL_PEN                      967 &bsol;**< Digital Pen (HID Subtype). */
60  #define BLE_APPEARANCE_HID_BARCODE                          968 &bsol;**< Barcode Scanner (HID Subtype). */
61  #define BLE_APPEARANCE_GENERIC_GLUCOSE_METER               1024 &bsol;**< Generic Glucose Meter. */
62  #define BLE_APPEARANCE_GENERIC_RUNNING_WALKING_SENSOR      1088 &bsol;**< Generic Running Walking Sensor. */
63  #define BLE_APPEARANCE_RUNNING_WALKING_SENSOR_IN_SHOE      1089 &bsol;**< Running Walking Sensor: In-Shoe. */
64  #define BLE_APPEARANCE_RUNNING_WALKING_SENSOR_ON_SHOE      1090 &bsol;**< Running Walking Sensor: On-Shoe. */
65  #define BLE_APPEARANCE_RUNNING_WALKING_SENSOR_ON_HIP       1091 &bsol;**< Running Walking Sensor: On-Hip. */
66  #define BLE_APPEARANCE_GENERIC_CYCLING                     1152 &bsol;**< Generic Cycling. */
67  #define BLE_APPEARANCE_CYCLING_CYCLING_COMPUTER            1153 &bsol;**< Cycling: Cycling Computer. */
68  #define BLE_APPEARANCE_CYCLING_SPEED_SENSOR                1154 &bsol;**< Cycling: Speed Sensor. */
69  #define BLE_APPEARANCE_CYCLING_CADENCE_SENSOR              1155 &bsol;**< Cycling: Cadence Sensor. */
70  #define BLE_APPEARANCE_CYCLING_POWER_SENSOR                1156 &bsol;**< Cycling: Power Sensor. */
71  #define BLE_APPEARANCE_CYCLING_SPEED_CADENCE_SENSOR        1157 &bsol;**< Cycling: Speed and Cadence Sensor. */
72  #define BLE_APPEARANCE_GENERIC_PULSE_OXIMETER              3136 &bsol;**< Generic Pulse Oximeter. */
73  #define BLE_APPEARANCE_PULSE_OXIMETER_FINGERTIP            3137 &bsol;**< Fingertip (Pulse Oximeter subtype). */
74  #define BLE_APPEARANCE_PULSE_OXIMETER_WRIST_WORN           3138 &bsol;**< Wrist Worn(Pulse Oximeter subtype). */
75  #define BLE_APPEARANCE_GENERIC_WEIGHT_SCALE                3200 &bsol;**< Generic Weight Scale. */
76  #define BLE_APPEARANCE_GENERIC_OUTDOOR_SPORTS_ACT          5184 &bsol;**< Generic Outdoor Sports Activity. */
77  #define BLE_APPEARANCE_OUTDOOR_SPORTS_ACT_LOC_DISP         5185 &bsol;**< Location Display Device (Outdoor Sports Activity subtype). */
78  #define BLE_APPEARANCE_OUTDOOR_SPORTS_ACT_LOC_AND_NAV_DISP 5186 &bsol;**< Location and Navigation Display Device (Outdoor Sports Activity subtype). */
79  #define BLE_APPEARANCE_OUTDOOR_SPORTS_ACT_LOC_POD          5187 &bsol;**< Location Pod (Outdoor Sports Activity subtype). */
80  #define BLE_APPEARANCE_OUTDOOR_SPORTS_ACT_LOC_AND_NAV_POD  5188 &bsol;**< Location and Navigation Pod (Outdoor Sports Activity subtype). */
81  #define BLE_UUID_BLE_ASSIGN(instance, value) do {\
82              instance.type = BLE_UUID_TYPE_BLE; \
83              instance.uuid = value;} while(0)
84  #define BLE_UUID_COPY_PTR(dst, src) do {\
85              (dst)->type = (src)->type; \
86              (dst)->uuid = (src)->uuid;} while(0)
87  #define BLE_UUID_COPY_INST(dst, src) do {\
88              (dst).type = (src).type; \
89              (dst).uuid = (src).uuid;} while(0)
90  #define BLE_UUID_EQ(p_uuid1, p_uuid2) \
91              (((p_uuid1)->type == (p_uuid2)->type) && ((p_uuid1)->uuid == (p_uuid2)->uuid))
92  #define BLE_UUID_NEQ(p_uuid1, p_uuid2) \
93              (((p_uuid1)->type != (p_uuid2)->type) || ((p_uuid1)->uuid != (p_uuid2)->uuid))
94  typedef struct
95  {
<span onclick='openModal()' class='match'>96    uint8_t uuid128[16]; &bsol;**< Little-Endian UUID bytes. */
97  } ble_uuid128_t;
98  typedef struct
99  {
100    uint16_t    uuid; &bsol;**< 16-bit UUID value or octets 12-13 of 128-bit UUID. */
101    uint8_t     type; &bsol;**< UUID type, see @ref BLE_UUID_TYPES. If type is @ref BLE_UUID_TYPE_UNKNOWN, the value of uuid is undefined. */
</span>102  } ble_uuid_t;
103  typedef struct
104  {
105    uint8_t     *p_data;  &bsol;**< Pointer to the data buffer provided to/from the application. */
106    uint16_t     len;     &bsol;**< Length of the data buffer, in bytes. */
107  } ble_data_t;
108  #ifdef __cplusplus
109  }
110  #endif
111  #endif &bsol;* BLE_TYPES_H__ */
</code></pre>
        </div>
        <div class="column">
            <h3>libtomcrypt-MDEwOlJlcG9zaXRvcnk3NzcwMTE=-flat-sober128.c</h3>
            <pre><code>1  #include "tomcrypt_private.h"
2  #ifdef LTC_SOBER128
3  const struct ltc_prng_descriptor sober128_desc =
4  {
5     "sober128",
6     40,
7     &sober128_start,
8     &sober128_add_entropy,
9     &sober128_ready,
10     &sober128_read,
11     &sober128_done,
12     &sober128_export,
13     &sober128_import,
14     &sober128_test
15  };
16  int sober128_start(prng_state *prng)
17  {
18     LTC_ARGCHK(prng != NULL);
19     prng->ready = 0;
20     XMEMSET(&prng->u.sober128.ent, 0, sizeof(prng->u.sober128.ent));
21     prng->u.sober128.idx = 0;
22     LTC_MUTEX_INIT(&prng->lock)
23     return CRYPT_OK;
24  }
<span onclick='openModal()' class='match'>25  int sober128_add_entropy(const unsigned char *in, unsigned long inlen, prng_state *prng)
26  {
27     unsigned char buf[40];
28     unsigned long i;
29     int err;
</span>30     LTC_ARGCHK(prng != NULL);
31     LTC_ARGCHK(in != NULL);
32     LTC_ARGCHK(inlen > 0);
33     LTC_MUTEX_LOCK(&prng->lock);
34     if (prng->ready) {
35        if ((err = sober128_stream_keystream(&prng->u.sober128.s, buf, sizeof(buf))) != CRYPT_OK) goto LBL_UNLOCK;
36        for(i = 0; i < inlen; i++) buf[i % sizeof(buf)] ^= in[i];
37        if ((err = sober128_stream_setup(&prng->u.sober128.s, buf, 32)) != CRYPT_OK)     goto LBL_UNLOCK;
38        if ((err = sober128_stream_setiv(&prng->u.sober128.s, buf + 32, 8)) != CRYPT_OK) goto LBL_UNLOCK;
39        zeromem(buf, sizeof(buf));
40     }
41     else {
42        while (inlen--) prng->u.sober128.ent[prng->u.sober128.idx++ % sizeof(prng->u.sober128.ent)] ^= *in++;
43     }
44     err = CRYPT_OK;
45  LBL_UNLOCK:
46     LTC_MUTEX_UNLOCK(&prng->lock);
47     return err;
48  }
49  int sober128_ready(prng_state *prng)
50  {
51     int err;
52     LTC_ARGCHK(prng != NULL);
53     LTC_MUTEX_LOCK(&prng->lock);
54     if (prng->ready)                                                            { err = CRYPT_OK; goto LBL_UNLOCK; }
55     if ((err = sober128_stream_setup(&prng->u.sober128.s, prng->u.sober128.ent, 32)) != CRYPT_OK)     goto LBL_UNLOCK;
56     if ((err = sober128_stream_setiv(&prng->u.sober128.s, prng->u.sober128.ent + 32, 8)) != CRYPT_OK) goto LBL_UNLOCK;
57     XMEMSET(&prng->u.sober128.ent, 0, sizeof(prng->u.sober128.ent));
58     prng->u.sober128.idx = 0;
59     prng->ready = 1;
60  LBL_UNLOCK:
61     LTC_MUTEX_UNLOCK(&prng->lock);
62     return err;
63  }
64  unsigned long sober128_read(unsigned char *out, unsigned long outlen, prng_state *prng)
65  {
66     if (outlen == 0 || prng == NULL || out == NULL) return 0;
67     LTC_MUTEX_LOCK(&prng->lock);
68     if (!prng->ready) { outlen = 0; goto LBL_UNLOCK; }
69     if (sober128_stream_keystream(&prng->u.sober128.s, out, outlen) != CRYPT_OK) outlen = 0;
70  LBL_UNLOCK:
71     LTC_MUTEX_UNLOCK(&prng->lock);
72     return outlen;
73  }
74  int sober128_done(prng_state *prng)
75  {
76     int err;
77     LTC_ARGCHK(prng != NULL);
78     LTC_MUTEX_LOCK(&prng->lock);
79     prng->ready = 0;
80     err = sober128_stream_done(&prng->u.sober128.s);
81     LTC_MUTEX_UNLOCK(&prng->lock);
82     LTC_MUTEX_DESTROY(&prng->lock);
83     return err;
84  }
85  LTC_PRNG_EXPORT(sober128)
86  int sober128_import(const unsigned char *in, unsigned long inlen, prng_state *prng)
87  {
88     int err;
89     LTC_ARGCHK(prng != NULL);
90     LTC_ARGCHK(in   != NULL);
91     if (inlen < (unsigned long)sober128_desc.export_size) return CRYPT_INVALID_ARG;
92     if ((err = sober128_start(prng)) != CRYPT_OK) return err;
93     if ((err = sober128_add_entropy(in, inlen, prng)) != CRYPT_OK) return err;
94     return CRYPT_OK;
95  }
96  int sober128_test(void)
97  {
98  #ifndef LTC_TEST
99     return CRYPT_NOP;
100  #else
101     prng_state st;
102     unsigned char en[] = { 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a,
103                            0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x10, 0x11, 0x12, 0x13, 0x14,
104                            0x15, 0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e,
105                            0x1f, 0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28,
106                            0x29, 0x2a, 0x2b, 0x2c, 0x2d, 0x2e, 0x2f, 0x30, 0x31, 0x32 };
107     unsigned char dmp[300];
108     unsigned long dmplen = sizeof(dmp);
109     unsigned char out[500];
110     unsigned char t1[] = { 0x31, 0x82, 0xA7, 0xA5, 0x8B, 0xD7, 0xCB, 0x39, 0x86, 0x1A };
111     unsigned char t2[] = { 0x6B, 0x43, 0x9E, 0xBC, 0xE7, 0x62, 0x9B, 0xE6, 0x9B, 0x83 };
112     unsigned char t3[] = { 0x4A, 0x0E, 0x6C, 0xC1, 0xCF, 0xB4, 0x73, 0x49, 0x99, 0x05 };
113     int err;
114     if ((err = sober128_start(&st)) != CRYPT_OK)                         return err;
115     if ((err = sober128_add_entropy(en, sizeof(en), &st)) != CRYPT_OK)   return err;
116     if ((err = sober128_ready(&st)) != CRYPT_OK)                         return err;
117     if (sober128_read(out, 10, &st) != 10)                               return CRYPT_ERROR_READPRNG; &bsol;* 10 bytes for testing */
118     if (compare_testvector(out, 10, t1, sizeof(t1), "SOBER128-PRNG", 1)) return CRYPT_FAIL_TESTVECTOR;
119     if (sober128_read(out, 500, &st) != 500)                             return CRYPT_ERROR_READPRNG; &bsol;* skip 500 bytes */
120     if ((err = sober128_add_entropy(en, sizeof(en), &st)) != CRYPT_OK)   return err;
121     if (sober128_read(out, 500, &st) != 500)                             return CRYPT_ERROR_READPRNG; &bsol;* skip 500 bytes */
122     if ((err = sober128_export(dmp, &dmplen, &st)) != CRYPT_OK)          return err;
123     if (sober128_read(out, 500, &st) != 500)                             return CRYPT_ERROR_READPRNG; &bsol;* skip 500 bytes */
124     if (sober128_read(out, 10, &st) != 10)                               return CRYPT_ERROR_READPRNG; &bsol;* 10 bytes for testing */
125     if (compare_testvector(out, 10, t2, sizeof(t2), "SOBER128-PRNG", 2)) return CRYPT_FAIL_TESTVECTOR;
126     if ((err = sober128_done(&st)) != CRYPT_OK)                          return err;
127     if ((err = sober128_import(dmp, dmplen, &st)) != CRYPT_OK)           return err;
128     if ((err = sober128_ready(&st)) != CRYPT_OK)                         return err;
129     if (sober128_read(out, 500, &st) != 500)                             return CRYPT_ERROR_READPRNG; &bsol;* skip 500 bytes */
130     if (sober128_read(out, 10, &st) != 10)                               return CRYPT_ERROR_READPRNG; &bsol;* 10 bytes for testing */
131     if (compare_testvector(out, 10, t3, sizeof(t3), "SOBER128-PRNG", 3)) return CRYPT_FAIL_TESTVECTOR;
132     if ((err = sober128_done(&st)) != CRYPT_OK)                          return err;
133     return CRYPT_OK;
134  #endif
135  }
136  #endif
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from Adafruit_nRF52_Arduino-MDEwOlJlcG9zaXRvcnk3NDM1NDcyOQ==-flat-ble_types.h</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from libtomcrypt-MDEwOlJlcG9zaXRvcnk3NzcwMTE=-flat-sober128.c</div>
                </div>
                <div class="column column_space"><pre><code>96    uint8_t uuid128[16]; &bsol;**< Little-Endian UUID bytes. */
97  } ble_uuid128_t;
98  typedef struct
99  {
100    uint16_t    uuid; &bsol;**< 16-bit UUID value or octets 12-13 of 128-bit UUID. */
101    uint8_t     type; &bsol;**< UUID type, see @ref BLE_UUID_TYPES. If type is @ref BLE_UUID_TYPE_UNKNOWN, the value of uuid is undefined. */
</pre></code></div>
                <div class="column column_space"><pre><code>25  int sober128_add_entropy(const unsigned char *in, unsigned long inlen, prng_state *prng)
26  {
27     unsigned char buf[40];
28     unsigned long i;
29     int err;
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    