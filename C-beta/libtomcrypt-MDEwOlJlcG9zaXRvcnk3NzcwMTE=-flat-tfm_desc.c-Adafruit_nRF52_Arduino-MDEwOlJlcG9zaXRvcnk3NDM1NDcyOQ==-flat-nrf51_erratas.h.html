
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 1.033434650455927%, Tokens: 9, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>libtomcrypt-MDEwOlJlcG9zaXRvcnk3NzcwMTE=-flat-tfm_desc.c</h3>
            <pre><code>1  #define DESC_DEF_ONLY
2  #include "tomcrypt_private.h"
3  #ifdef TFM_DESC
4  #include <tfm.h>
5  static const struct {
6      int tfm_code, ltc_code;
7  } tfm_to_ltc_codes[] = {
8     { FP_OKAY ,  CRYPT_OK},
9     { FP_MEM  ,  CRYPT_MEM},
10     { FP_VAL  ,  CRYPT_INVALID_ARG},
11  };
12  static int tfm_to_ltc_error(int err)
13  {
14     int x;
15     for (x = 0; x < (int)(sizeof(tfm_to_ltc_codes)/sizeof(tfm_to_ltc_codes[0])); x++) {
16         if (err == tfm_to_ltc_codes[x].tfm_code) {
17            return tfm_to_ltc_codes[x].ltc_code;
18         }
19     }
20     return CRYPT_ERROR;
21  }
22  static int init(void **a)
23  {
24     LTC_ARGCHK(a != NULL);
25     *a = XCALLOC(1, sizeof(fp_int));
26     if (*a == NULL) {
27        return CRYPT_MEM;
28     }
29     fp_init(*a);
30     return CRYPT_OK;
31  }
32  static void deinit(void *a)
33  {
34     LTC_ARGCHKVD(a != NULL);
35     XFREE(a);
36  }
37  static int neg(void *a, void *b)
38  {
39     LTC_ARGCHK(a != NULL);
40     LTC_ARGCHK(b != NULL);
41     fp_neg(((fp_int*)a), ((fp_int*)b));
42     return CRYPT_OK;
43  }
44  static int copy(void *a, void *b)
45  {
46     LTC_ARGCHK(a != NULL);
47     LTC_ARGCHK(b != NULL);
48     fp_copy(a, b);
49     return CRYPT_OK;
50  }
51  static int init_copy(void **a, void *b)
52  {
53     if (init(a) != CRYPT_OK) {
54        return CRYPT_MEM;
55     }
56     return copy(b, *a);
57  }
58  static int set_int(void *a, ltc_mp_digit b)
59  {
60     LTC_ARGCHK(a != NULL);
61     fp_set(a, b);
62     return CRYPT_OK;
63  }
64  static unsigned long get_int(void *a)
65  {
66     fp_int *A;
67     LTC_ARGCHK(a != NULL);
68     A = a;
69     return A->used > 0 ? A->dp[0] : 0;
70  }
71  static ltc_mp_digit get_digit(void *a, int n)
72  {
73     fp_int *A;
74     LTC_ARGCHK(a != NULL);
75     A = a;
76     return (n >= A->used || n < 0) ? 0 : A->dp[n];
77  }
78  static int get_digit_count(void *a)
79  {
80     fp_int *A;
81     LTC_ARGCHK(a != NULL);
82     A = a;
83     return A->used;
84  }
85  static int compare(void *a, void *b)
86  {
87     int ret;
88     LTC_ARGCHK(a != NULL);
89     LTC_ARGCHK(b != NULL);
90     ret = fp_cmp(a, b);
91     switch (ret) {
92        case FP_LT: return LTC_MP_LT;
93        case FP_EQ: return LTC_MP_EQ;
94        case FP_GT: return LTC_MP_GT;
95     }
96     return 0;
97  }
98  static int compare_d(void *a, ltc_mp_digit b)
99  {
100     int ret;
101     LTC_ARGCHK(a != NULL);
102     ret = fp_cmp_d(a, b);
103     switch (ret) {
104        case FP_LT: return LTC_MP_LT;
105        case FP_EQ: return LTC_MP_EQ;
106        case FP_GT: return LTC_MP_GT;
107     }
108     return 0;
109  }
110  static int count_bits(void *a)
111  {
112     LTC_ARGCHK(a != NULL);
113     return fp_count_bits(a);
114  }
115  static int count_lsb_bits(void *a)
116  {
117     LTC_ARGCHK(a != NULL);
118     return fp_cnt_lsb(a);
119  }
120  static int twoexpt(void *a, int n)
121  {
122     LTC_ARGCHK(a != NULL);
123     fp_2expt(a, n);
124     return CRYPT_OK;
125  }
126  static int read_radix(void *a, const char *b, int radix)
127  {
128     LTC_ARGCHK(a != NULL);
129     LTC_ARGCHK(b != NULL);
130     return tfm_to_ltc_error(fp_read_radix(a, (char *)b, radix));
131  }
132  static int write_radix(void *a, char *b, int radix)
133  {
134     LTC_ARGCHK(a != NULL);
135     LTC_ARGCHK(b != NULL);
136     return tfm_to_ltc_error(fp_toradix(a, b, radix));
137  }
138  static unsigned long unsigned_size(void *a)
139  {
140     LTC_ARGCHK(a != NULL);
141     return fp_unsigned_bin_size(a);
142  }
143  static int unsigned_write(void *a, unsigned char *b)
144  {
145     LTC_ARGCHK(a != NULL);
146     LTC_ARGCHK(b != NULL);
147     fp_to_unsigned_bin(a, b);
148     return CRYPT_OK;
149  }
150  static int unsigned_read(void *a, unsigned char *b, unsigned long len)
151  {
152     LTC_ARGCHK(a != NULL);
153     LTC_ARGCHK(b != NULL);
154     fp_read_unsigned_bin(a, b, len);
155     return CRYPT_OK;
156  }
157  static int add(void *a, void *b, void *c)
158  {
159     LTC_ARGCHK(a != NULL);
160     LTC_ARGCHK(b != NULL);
161     LTC_ARGCHK(c != NULL);
162     fp_add(a, b, c);
163     return CRYPT_OK;
164  }
165  static int addi(void *a, ltc_mp_digit b, void *c)
166  {
167     LTC_ARGCHK(a != NULL);
168     LTC_ARGCHK(c != NULL);
169     fp_add_d(a, b, c);
170     return CRYPT_OK;
171  }
172  static int sub(void *a, void *b, void *c)
173  {
174     LTC_ARGCHK(a != NULL);
175     LTC_ARGCHK(b != NULL);
176     LTC_ARGCHK(c != NULL);
177     fp_sub(a, b, c);
178     return CRYPT_OK;
179  }
180  static int subi(void *a, ltc_mp_digit b, void *c)
181  {
182     LTC_ARGCHK(a != NULL);
183     LTC_ARGCHK(c != NULL);
184     fp_sub_d(a, b, c);
185     return CRYPT_OK;
186  }
187  static int mul(void *a, void *b, void *c)
188  {
189     LTC_ARGCHK(a != NULL);
190     LTC_ARGCHK(b != NULL);
191     LTC_ARGCHK(c != NULL);
192     fp_mul(a, b, c);
193     return CRYPT_OK;
194  }
195  static int muli(void *a, ltc_mp_digit b, void *c)
196  {
197     LTC_ARGCHK(a != NULL);
198     LTC_ARGCHK(c != NULL);
199     fp_mul_d(a, b, c);
200     return CRYPT_OK;
201  }
202  static int sqr(void *a, void *b)
203  {
204     LTC_ARGCHK(a != NULL);
205     LTC_ARGCHK(b != NULL);
206     fp_sqr(a, b);
207     return CRYPT_OK;
208  }
209  static int divide(void *a, void *b, void *c, void *d)
210  {
211     LTC_ARGCHK(a != NULL);
212     LTC_ARGCHK(b != NULL);
213     return tfm_to_ltc_error(fp_div(a, b, c, d));
214  }
215  static int div_2(void *a, void *b)
216  {
217     LTC_ARGCHK(a != NULL);
218     LTC_ARGCHK(b != NULL);
219     fp_div_2(a, b);
220     return CRYPT_OK;
221  }
222  static int modi(void *a, ltc_mp_digit b, ltc_mp_digit *c)
223  {
224     fp_digit tmp;
225     int      err;
226     LTC_ARGCHK(a != NULL);
227     LTC_ARGCHK(c != NULL);
228     if ((err = tfm_to_ltc_error(fp_mod_d(a, b, &tmp))) != CRYPT_OK) {
229        return err;
230     }
231     *c = tmp;
232     return CRYPT_OK;
233  }
234  static int gcd(void *a, void *b, void *c)
235  {
236     LTC_ARGCHK(a != NULL);
237     LTC_ARGCHK(b != NULL);
238     LTC_ARGCHK(c != NULL);
239     fp_gcd(a, b, c);
240     return CRYPT_OK;
241  }
242  static int lcm(void *a, void *b, void *c)
243  {
244     LTC_ARGCHK(a != NULL);
245     LTC_ARGCHK(b != NULL);
246     LTC_ARGCHK(c != NULL);
247     fp_lcm(a, b, c);
248     return CRYPT_OK;
249  }
250  static int addmod(void *a, void *b, void *c, void *d)
251  {
252     LTC_ARGCHK(a != NULL);
253     LTC_ARGCHK(b != NULL);
254     LTC_ARGCHK(c != NULL);
255     LTC_ARGCHK(d != NULL);
256     return tfm_to_ltc_error(fp_addmod(a,b,c,d));
257  }
258  static int submod(void *a, void *b, void *c, void *d)
259  {
260     LTC_ARGCHK(a != NULL);
261     LTC_ARGCHK(b != NULL);
262     LTC_ARGCHK(c != NULL);
263     LTC_ARGCHK(d != NULL);
264     return tfm_to_ltc_error(fp_submod(a,b,c,d));
265  }
266  static int mulmod(void *a, void *b, void *c, void *d)
267  {
268     LTC_ARGCHK(a != NULL);
269     LTC_ARGCHK(b != NULL);
270     LTC_ARGCHK(c != NULL);
271     LTC_ARGCHK(d != NULL);
272     return tfm_to_ltc_error(fp_mulmod(a,b,c,d));
273  }
274  static int sqrmod(void *a, void *b, void *c)
275  {
276     LTC_ARGCHK(a != NULL);
277     LTC_ARGCHK(b != NULL);
278     LTC_ARGCHK(c != NULL);
279     return tfm_to_ltc_error(fp_sqrmod(a,b,c));
280  }
281  static int invmod(void *a, void *b, void *c)
282  {
283     LTC_ARGCHK(a != NULL);
284     LTC_ARGCHK(b != NULL);
285     LTC_ARGCHK(c != NULL);
286     return tfm_to_ltc_error(fp_invmod(a, b, c));
287  }
288  static int montgomery_setup(void *a, void **b)
289  {
290     int err;
291     LTC_ARGCHK(a != NULL);
292     LTC_ARGCHK(b != NULL);
293     *b = XCALLOC(1, sizeof(fp_digit));
294     if (*b == NULL) {
295        return CRYPT_MEM;
296     }
297     if ((err = tfm_to_ltc_error(fp_montgomery_setup(a, (fp_digit *)*b))) != CRYPT_OK) {
298        XFREE(*b);
299     }
300     return err;
301  }
302  static int montgomery_normalization(void *a, void *b)
303  {
304     LTC_ARGCHK(a != NULL);
305     LTC_ARGCHK(b != NULL);
306     fp_montgomery_calc_normalization(a, b);
307     return CRYPT_OK;
308  }
309  static int montgomery_reduce(void *a, void *b, void *c)
310  {
311     LTC_ARGCHK(a != NULL);
312     LTC_ARGCHK(b != NULL);
313     LTC_ARGCHK(c != NULL);
314     fp_montgomery_reduce(a, b, *((fp_digit *)c));
315     return CRYPT_OK;
316  }
317  static void montgomery_deinit(void *a)
318  {
319     XFREE(a);
320  }
321  static int exptmod(void *a, void *b, void *c, void *d)
322  {
323     LTC_ARGCHK(a != NULL);
324     LTC_ARGCHK(b != NULL);
325     LTC_ARGCHK(c != NULL);
326     LTC_ARGCHK(d != NULL);
327     return tfm_to_ltc_error(fp_exptmod(a,b,c,d));
328  }
329  static int isprime(void *a, int b, int *c)
330  {
331     LTC_ARGCHK(a != NULL);
332     LTC_ARGCHK(c != NULL);
333     if (b == 0) {
334         b = LTC_MILLER_RABIN_REPS;
335     } &bsol;* if */
336     *c = (fp_isprime_ex(a, b) == FP_YES) ? LTC_MP_YES : LTC_MP_NO;
337     return CRYPT_OK;
338  }
339  #if defined(LTC_MECC) && defined(LTC_MECC_ACCEL)
340  static int tfm_ecc_projective_dbl_point(const ecc_point *P, ecc_point *R, void *ma, void *modulus, void *Mp)
341  {
342     fp_int t1, t2;
343     fp_digit mp;
344     int err, inf;
345     LTC_ARGCHK(P       != NULL);
346     LTC_ARGCHK(R       != NULL);
347     LTC_ARGCHK(modulus != NULL);
348     LTC_ARGCHK(Mp      != NULL);
349     mp = *((fp_digit*)Mp);
350     fp_init(&t1);
351     fp_init(&t2);
352     if (P != R) {
353        fp_copy(P->x, R->x);
354        fp_copy(P->y, R->y);
355        fp_copy(P->z, R->z);
356     }
357     if ((err = ltc_ecc_is_point_at_infinity(P, modulus, &inf)) != CRYPT_OK) return err;
358     if (inf) {
359        ltc_mp.set_int(R->x, 1);
360        ltc_mp.set_int(R->y, 1);
361        ltc_mp.set_int(R->z, 0);
362        return CRYPT_OK;
363     }
364     fp_sqr(R->z, &t1);
365     fp_montgomery_reduce(&t1, modulus, mp);
366     fp_mul(R->z, R->y, R->z);
367     fp_montgomery_reduce(R->z, modulus, mp);
368     fp_add(R->z, R->z, R->z);
369     if (fp_cmp(R->z, modulus) != FP_LT) {
370        fp_sub(R->z, modulus, R->z);
371     }
372     if (ma == NULL) { &bsol;* special case for curves with a == -3 (10% faster than general case) */
373        fp_sub(R->x, &t1, &t2);
374        if (fp_cmp_d(&t2, 0) == LTC_MP_LT) {
375           fp_add(&t2, modulus, &t2);
376        }
377        fp_add(&t1, R->x, &t1);
378        if (fp_cmp(&t1, modulus) != FP_LT) {
379           fp_sub(&t1, modulus, &t1);
380        }
381        fp_mul(&t1, &t2, &t2);
382        fp_montgomery_reduce(&t2, modulus, mp);
383        fp_add(&t2, &t2, &t1);
384        if (fp_cmp(&t1, modulus) != FP_LT) {
385           fp_sub(&t1, modulus, &t1);
386        }
387        fp_add(&t1, &t2, &t1);
388        if (fp_cmp(&t1, modulus) != FP_LT) {
389           fp_sub(&t1, modulus, &t1);
390        }
391     }
392     else {
393        fp_sqr(&t1, &t2);
394        fp_montgomery_reduce(&t2, modulus, mp);
395        fp_mul(&t2, ma, &t1);
396        fp_montgomery_reduce(&t1, modulus, mp);
397        fp_sqr(R->x, &t2);
398        fp_montgomery_reduce(&t2, modulus, mp);
399        fp_add(&t1, &t2, &t1);
400        if (fp_cmp(&t1, modulus) != FP_LT) {
401           fp_sub(&t1, modulus, &t1);
402        }
403        fp_add(&t1, &t2, &t1);
404        if (fp_cmp(&t1, modulus) != FP_LT) {
405           fp_sub(&t1, modulus, &t1);
406        }
407        fp_add(&t1, &t2, &t1);
408        if (fp_cmp(&t1, modulus) != FP_LT) {
409           fp_sub(&t1, modulus, &t1);
410        }
411     }
412     fp_add(R->y, R->y, R->y);
413     if (fp_cmp(R->y, modulus) != FP_LT) {
414        fp_sub(R->y, modulus, R->y);
415     }
416     fp_sqr(R->y, R->y);
417     fp_montgomery_reduce(R->y, modulus, mp);
418     fp_sqr(R->y, &t2);
419     fp_montgomery_reduce(&t2, modulus, mp);
420     if (fp_isodd(&t2)) {
421        fp_add(&t2, modulus, &t2);
422     }
423     fp_div_2(&t2, &t2);
424     fp_mul(R->y, R->x, R->y);
425     fp_montgomery_reduce(R->y, modulus, mp);
426     fp_sqr(&t1, R->x);
427     fp_montgomery_reduce(R->x, modulus, mp);
428     fp_sub(R->x, R->y, R->x);
429     if (fp_cmp_d(R->x, 0) == FP_LT) {
430        fp_add(R->x, modulus, R->x);
431     }
432     fp_sub(R->x, R->y, R->x);
433     if (fp_cmp_d(R->x, 0) == FP_LT) {
434        fp_add(R->x, modulus, R->x);
435     }
436     fp_sub(R->y, R->x, R->y);
437     if (fp_cmp_d(R->y, 0) == FP_LT) {
438        fp_add(R->y, modulus, R->y);
439     }
440     fp_mul(R->y, &t1, R->y);
441     fp_montgomery_reduce(R->y, modulus, mp);
442     fp_sub(R->y, &t2, R->y);
443     if (fp_cmp_d(R->y, 0) == FP_LT) {
444        fp_add(R->y, modulus, R->y);
445     }
446     return CRYPT_OK;
447  }
<span onclick='openModal()' class='match'>448  static int tfm_ecc_projective_add_point(const ecc_point *P, const ecc_point *Q, ecc_point *R, void *ma, void *modulus, void *Mp)
449  {
450     fp_int  t1, t2, x, y, z;
451     fp_digit mp;
452     int err, inf;
</span>453     LTC_ARGCHK(P       != NULL);
454     LTC_ARGCHK(Q       != NULL);
455     LTC_ARGCHK(R       != NULL);
456     LTC_ARGCHK(modulus != NULL);
457     LTC_ARGCHK(Mp      != NULL);
458     mp = *((fp_digit*)Mp);
459     fp_init(&t1);
460     fp_init(&t2);
461     fp_init(&x);
462     fp_init(&y);
463     fp_init(&z);
464     if ((err = ltc_ecc_is_point_at_infinity(P, modulus, &inf)) != CRYPT_OK) return err;
465     if (inf) {
466        ltc_mp.copy(Q->x, R->x);
467        ltc_mp.copy(Q->y, R->y);
468        ltc_mp.copy(Q->z, R->z);
469        return CRYPT_OK;
470     }
471     if ((err = ltc_ecc_is_point_at_infinity(Q, modulus, &inf)) != CRYPT_OK) return err;
472     if (inf) {
473        ltc_mp.copy(P->x, R->x);
474        ltc_mp.copy(P->y, R->y);
475        ltc_mp.copy(P->z, R->z);
476        return CRYPT_OK;
477     }
478     fp_sub(modulus, Q->y, &t1);
479     if ( (fp_cmp(P->x, Q->x) == FP_EQ) &&
480          (Q->z != NULL && fp_cmp(P->z, Q->z) == FP_EQ) &&
481          (fp_cmp(P->y, Q->y) == FP_EQ || fp_cmp(P->y, &t1) == FP_EQ)) {
482          return tfm_ecc_projective_dbl_point(P, R, ma, modulus, Mp);
483     }
484     fp_copy(P->x, &x);
485     fp_copy(P->y, &y);
486     fp_copy(P->z, &z);
487     if (Q->z != NULL) {
488        fp_sqr(Q->z, &t1);
489        fp_montgomery_reduce(&t1, modulus, mp);
490        fp_mul(&t1, &x, &x);
491        fp_montgomery_reduce(&x, modulus, mp);
492        fp_mul(Q->z, &t1, &t1);
493        fp_montgomery_reduce(&t1, modulus, mp);
494        fp_mul(&t1, &y, &y);
495        fp_montgomery_reduce(&y, modulus, mp);
496     }
497     fp_sqr(&z, &t1);
498     fp_montgomery_reduce(&t1, modulus, mp);
499     fp_mul(Q->x, &t1, &t2);
500     fp_montgomery_reduce(&t2, modulus, mp);
501     fp_mul(&z, &t1, &t1);
502     fp_montgomery_reduce(&t1, modulus, mp);
503     fp_mul(Q->y, &t1, &t1);
504     fp_montgomery_reduce(&t1, modulus, mp);
505     fp_sub(&y, &t1, &y);
506     if (fp_cmp_d(&y, 0) == FP_LT) {
507        fp_add(&y, modulus, &y);
508     }
509     fp_add(&t1, &t1, &t1);
510     if (fp_cmp(&t1, modulus) != FP_LT) {
511        fp_sub(&t1, modulus, &t1);
512     }
513     fp_add(&t1, &y, &t1);
514     if (fp_cmp(&t1, modulus) != FP_LT) {
515        fp_sub(&t1, modulus, &t1);
516     }
517     fp_sub(&x, &t2, &x);
518     if (fp_cmp_d(&x, 0) == FP_LT) {
519        fp_add(&x, modulus, &x);
520     }
521     fp_add(&t2, &t2, &t2);
522     if (fp_cmp(&t2, modulus) != FP_LT) {
523        fp_sub(&t2, modulus, &t2);
524     }
525     fp_add(&t2, &x, &t2);
526     if (fp_cmp(&t2, modulus) != FP_LT) {
527        fp_sub(&t2, modulus, &t2);
528     }
529     if (Q->z != NULL) {
530        fp_mul(&z, Q->z, &z);
531        fp_montgomery_reduce(&z, modulus, mp);
532     }
533     fp_mul(&z, &x, &z);
534     fp_montgomery_reduce(&z, modulus, mp);
535     fp_mul(&t1, &x, &t1);
536     fp_montgomery_reduce(&t1, modulus, mp);
537     fp_sqr(&x, &x);
538     fp_montgomery_reduce(&x, modulus, mp);
539     fp_mul(&t2, &x, &t2);
540     fp_montgomery_reduce(&t2, modulus, mp);
541     fp_mul(&t1, &x, &t1);
542     fp_montgomery_reduce(&t1, modulus, mp);
543     fp_sqr(&y, &x);
544     fp_montgomery_reduce(&x, modulus, mp);
545     fp_sub(&x, &t2, &x);
546     if (fp_cmp_d(&x, 0) == FP_LT) {
547        fp_add(&x, modulus, &x);
548     }
549     fp_sub(&t2, &x, &t2);
550     if (fp_cmp_d(&t2, 0) == FP_LT) {
551        fp_add(&t2, modulus, &t2);
552     }
553     fp_sub(&t2, &x, &t2);
554     if (fp_cmp_d(&t2, 0) == FP_LT) {
555        fp_add(&t2, modulus, &t2);
556     }
557     fp_mul(&t2, &y, &t2);
558     fp_montgomery_reduce(&t2, modulus, mp);
559     fp_sub(&t2, &t1, &y);
560     if (fp_cmp_d(&y, 0) == FP_LT) {
561        fp_add(&y, modulus, &y);
562     }
563     if (fp_isodd(&y)) {
564        fp_add(&y, modulus, &y);
565     }
566     fp_div_2(&y, &y);
567     fp_copy(&x, R->x);
568     fp_copy(&y, R->y);
569     fp_copy(&z, R->z);
570     return CRYPT_OK;
571  }
572  #endif
573  static int set_rand(void *a, int size)
574  {
575     LTC_ARGCHK(a != NULL);
576     fp_rand(a, size);
577     return CRYPT_OK;
578  }
579  const ltc_math_descriptor tfm_desc = {
580     "TomsFastMath",
581     (int)DIGIT_BIT,
582     &init,
583     &init_copy,
584     &deinit,
585     &neg,
586     &copy,
587     &set_int,
588     &get_int,
589     &get_digit,
590     &get_digit_count,
591     &compare,
592     &compare_d,
593     &count_bits,
594     &count_lsb_bits,
595     &twoexpt,
596     &read_radix,
597     &write_radix,
598     &unsigned_size,
599     &unsigned_write,
600     &unsigned_read,
601     &add,
602     &addi,
603     &sub,
604     &subi,
605     &mul,
606     &muli,
607     &sqr,
608     NULL, &bsol;* TODO: &sqrtmod_prime */
609     &divide,
610     &div_2,
611     &modi,
612     &gcd,
613     &lcm,
614     &mulmod,
615     &sqrmod,
616     &invmod,
617     &montgomery_setup,
618     &montgomery_normalization,
619     &montgomery_reduce,
620     &montgomery_deinit,
621     &exptmod,
622     &isprime,
623  #ifdef LTC_MECC
624  #ifdef LTC_MECC_FP
625     &ltc_ecc_fp_mulmod,
626  #else
627     &ltc_ecc_mulmod,
628  #endif &bsol;* LTC_MECC_FP */
629  #ifdef LTC_MECC_ACCEL
630     &tfm_ecc_projective_add_point,
631     &tfm_ecc_projective_dbl_point,
632  #else
633     &ltc_ecc_projective_add_point,
634     &ltc_ecc_projective_dbl_point,
635  #endif &bsol;* LTC_MECC_ACCEL */
636     &ltc_ecc_map,
637  #ifdef LTC_ECC_SHAMIR
638  #ifdef LTC_MECC_FP
639     &ltc_ecc_fp_mul2add,
640  #else
641     &ltc_ecc_mul2add,
642  #endif &bsol;* LTC_MECC_FP */
643  #else
644     NULL,
645  #endif &bsol;* LTC_ECC_SHAMIR */
646  #else
647     NULL, NULL, NULL, NULL, NULL,
648  #endif &bsol;* LTC_MECC */
649  #ifdef LTC_MRSA
650     &rsa_make_key,
651     &rsa_exptmod,
652  #else
653     NULL, NULL,
654  #endif
655     &addmod,
656     &submod,
657     set_rand,
658  };
659  #endif
</code></pre>
        </div>
        <div class="column">
            <h3>Adafruit_nRF52_Arduino-MDEwOlJlcG9zaXRvcnk3NDM1NDcyOQ==-flat-nrf51_erratas.h</h3>
            <pre><code>1  #ifndef NRF51_ERRATAS_H
2  #define NRF51_ERRATAS_H
3  #include <stdint.h>
4  #include <stdbool.h>
5  #include "compiler_abstraction.h"
<span onclick='openModal()' class='match'>6  static bool nrf51_errata_1(void) __UNUSED;
7  static bool nrf51_errata_2(void) __UNUSED;
8  static bool nrf51_errata_3(void) __UNUSED;
9  static bool nrf51_errata_4(void) __UNUSED;
10  static bool nrf51_errata_5(void) __UNUSED;
11  static bool nrf51_errata_6(void) __UNUSED;
12  static bool nrf51_errata_7(void) __UNUSED;
13  static bool nrf51_errata_8(void) __UNUSED;
14  static bool nrf51_errata_9(void) __UNUSED;
</span>15  static bool nrf51_errata_10(void) __UNUSED;
16  static bool nrf51_errata_11(void) __UNUSED;
17  static bool nrf51_errata_12(void) __UNUSED;
18  static bool nrf51_errata_13(void) __UNUSED;
19  static bool nrf51_errata_14(void) __UNUSED;
20  static bool nrf51_errata_15(void) __UNUSED;
21  static bool nrf51_errata_16(void) __UNUSED;
22  static bool nrf51_errata_17(void) __UNUSED;
23  static bool nrf51_errata_18(void) __UNUSED;
24  static bool nrf51_errata_19(void) __UNUSED;
25  static bool nrf51_errata_20(void) __UNUSED;
26  static bool nrf51_errata_21(void) __UNUSED;
27  static bool nrf51_errata_22(void) __UNUSED;
28  static bool nrf51_errata_23(void) __UNUSED;
29  static bool nrf51_errata_24(void) __UNUSED;
30  static bool nrf51_errata_25(void) __UNUSED;
31  static bool nrf51_errata_26(void) __UNUSED;
32  static bool nrf51_errata_27(void) __UNUSED;
33  static bool nrf51_errata_28(void) __UNUSED;
34  static bool nrf51_errata_29(void) __UNUSED;
35  static bool nrf51_errata_30(void) __UNUSED;
36  static bool nrf51_errata_31(void) __UNUSED;
37  static bool nrf51_errata_32(void) __UNUSED;
38  static bool nrf51_errata_33(void) __UNUSED;
39  static bool nrf51_errata_34(void) __UNUSED;
40  static bool nrf51_errata_35(void) __UNUSED;
41  static bool nrf51_errata_36(void) __UNUSED;
42  static bool nrf51_errata_37(void) __UNUSED;
43  static bool nrf51_errata_38(void) __UNUSED;
44  static bool nrf51_errata_39(void) __UNUSED;
45  static bool nrf51_errata_40(void) __UNUSED;
46  static bool nrf51_errata_41(void) __UNUSED;
47  static bool nrf51_errata_42(void) __UNUSED;
48  static bool nrf51_errata_43(void) __UNUSED;
49  static bool nrf51_errata_44(void) __UNUSED;
50  static bool nrf51_errata_45(void) __UNUSED;
51  static bool nrf51_errata_46(void) __UNUSED;
52  static bool nrf51_errata_47(void) __UNUSED;
53  static bool nrf51_errata_48(void) __UNUSED;
54  static bool nrf51_errata_49(void) __UNUSED;
55  static bool nrf51_errata_50(void) __UNUSED;
56  static bool nrf51_errata_51(void) __UNUSED;
57  static bool nrf51_errata_52(void) __UNUSED;
58  static bool nrf51_errata_53(void) __UNUSED;
59  static bool nrf51_errata_54(void) __UNUSED;
60  static bool nrf51_errata_55(void) __UNUSED;
61  static bool nrf51_errata_56(void) __UNUSED;
62  static bool nrf51_errata_57(void) __UNUSED;
63  static bool nrf51_errata_58(void) __UNUSED;
64  static bool nrf51_errata_59(void) __UNUSED;
65  static bool nrf51_errata_60(void) __UNUSED;
66  static bool nrf51_errata_61(void) __UNUSED;
67  static bool nrf51_errata_62(void) __UNUSED;
68  static bool nrf51_errata_63(void) __UNUSED;
69  static bool nrf51_errata_64(void) __UNUSED;
70  static bool nrf51_errata_65(void) __UNUSED;
71  static bool nrf51_errata_66(void) __UNUSED;
72  static bool nrf51_errata_67(void) __UNUSED;
73  static bool nrf51_errata_68(void) __UNUSED;
74  static bool nrf51_errata_69(void) __UNUSED;
75  static bool nrf51_errata_70(void) __UNUSED;
76  static bool nrf51_errata_71(void) __UNUSED;
77  static bool nrf51_errata_72(void) __UNUSED;
78  static bool nrf51_errata_73(void) __UNUSED;
79  static bool nrf51_errata_74(void) __UNUSED;
80  static bool nrf51_errata_75(void) __UNUSED;
81  static bool nrf51_errata_76(void) __UNUSED;
82  static bool nrf51_errata_77(void) __UNUSED;
83  static bool nrf51_errata_78(void) __UNUSED;
84  static bool nrf51_errata_1(void)
85  {
86      #ifndef NRF51_SERIES
87          return false;
88      #else
89          #if defined (NRF51422_XXAA) || defined (DEVELOP_IN_NRF51422)\
90           || defined (NRF51422_XXAB) || defined (DEVELOP_IN_NRF51422)\
91           || defined (NRF51422_XXAC) || defined (DEVELOP_IN_NRF51422)
92              uint32_t var1 = ((*(uint32_t *)0xF0000FE0ul) & 0x000000FFul);
93              uint32_t var2 = ((*(uint32_t *)0xF0000FE8ul) & 0x000000F0ul) >> 4;
94          #endif
95          #if defined (NRF51422_XXAA) || defined (DEVELOP_IN_NRF51422)\
96           || defined (NRF51422_XXAB) || defined (DEVELOP_IN_NRF51422)\
97           || defined (NRF51422_XXAC) || defined (DEVELOP_IN_NRF51422)
98              if (var1 == 0x01)
99              {
100                  switch(var2)
101                  {
102                      case 0x00ul:
103                          return true;
104                      case 0x01ul:
105                          return true;
106                      case 0x02ul:
107                          return false;
108                      case 0x03ul:
109                          return true;
110                      case 0x04ul:
111                          return false;
112                      case 0x07ul:
113                          return false;
114                      case 0x08ul:
115                          return false;
116                      case 0x09ul:
117                          return false;
118                      case 0x0Aul:
119                          return false;
120                      case 0x0Bul:
121                          return false;
122                      case 0x0Cul:
123                          return false;
124                      case 0x0Dul:
125                          return false;
126                  }
127              }
128          #endif
129          return false;
130      #endif
131  }
132  static bool nrf51_errata_2(void)
133  {
134      #ifndef NRF51_SERIES
135          return false;
136      #else
137          #if defined (NRF51422_XXAA) || defined (DEVELOP_IN_NRF51422)\
138           || defined (NRF51422_XXAB) || defined (DEVELOP_IN_NRF51422)\
139           || defined (NRF51422_XXAC) || defined (DEVELOP_IN_NRF51422)
140              uint32_t var1 = ((*(uint32_t *)0xF0000FE0ul) & 0x000000FFul);
141              uint32_t var2 = ((*(uint32_t *)0xF0000FE8ul) & 0x000000F0ul) >> 4;
142          #endif
143          #if defined (NRF51422_XXAA) || defined (DEVELOP_IN_NRF51422)\
144           || defined (NRF51422_XXAB) || defined (DEVELOP_IN_NRF51422)\
145           || defined (NRF51422_XXAC) || defined (DEVELOP_IN_NRF51422)
146              if (var1 == 0x01)
147              {
148                  switch(var2)
149                  {
150                      case 0x00ul:
151                          return true;
152                      case 0x01ul:
153                          return true;
154                      case 0x02ul:
155                          return false;
156                      case 0x03ul:
157                          return true;
158                      case 0x04ul:
159                          return false;
160                      case 0x07ul:
161                          return false;
162                      case 0x08ul:
163                          return false;
164                      case 0x09ul:
165                          return false;
166                      case 0x0Aul:
167                          return false;
168                      case 0x0Bul:
169                          return false;
170                      case 0x0Cul:
171                          return false;
172                      case 0x0Dul:
173                          return false;
174                  }
175              }
176          #endif
177          return false;
178      #endif
179  }
180  static bool nrf51_errata_3(void)
181  {
182      #ifndef NRF51_SERIES
183          return false;
184      #else
185          #if defined (NRF51422_XXAA) || defined (DEVELOP_IN_NRF51422)\
186           || defined (NRF51422_XXAB) || defined (DEVELOP_IN_NRF51422)\
187           || defined (NRF51422_XXAC) || defined (DEVELOP_IN_NRF51422)
188              uint32_t var1 = ((*(uint32_t *)0xF0000FE0ul) & 0x000000FFul);
189              uint32_t var2 = ((*(uint32_t *)0xF0000FE8ul) & 0x000000F0ul) >> 4;
190          #endif
191          #if defined (NRF51422_XXAA) || defined (DEVELOP_IN_NRF51422)\
192           || defined (NRF51422_XXAB) || defined (DEVELOP_IN_NRF51422)\
193           || defined (NRF51422_XXAC) || defined (DEVELOP_IN_NRF51422)
194              if (var1 == 0x01)
195              {
196                  switch(var2)
197                  {
198                      case 0x00ul:
199                          return true;
200                      case 0x01ul:
201                          return true;
202                      case 0x02ul:
203                          return false;
204                      case 0x03ul:
205                          return true;
206                      case 0x04ul:
207                          return false;
208                      case 0x07ul:
209                          return false;
210                      case 0x08ul:
211                          return false;
212                      case 0x09ul:
213                          return false;
214                      case 0x0Aul:
215                          return false;
216                      case 0x0Bul:
217                          return false;
218                      case 0x0Cul:
219                          return false;
220                      case 0x0Dul:
221                          return false;
222                  }
223              }
224          #endif
225          return false;
226      #endif
227  }
228  static bool nrf51_errata_4(void)
229  {
230      #ifndef NRF51_SERIES
231          return false;
232      #else
233          return false;
234      #endif
235  }
236  static bool nrf51_errata_5(void)
237  {
238      #ifndef NRF51_SERIES
239          return false;
240      #else
241          return false;
242      #endif
243  }
244  static bool nrf51_errata_6(void)
245  {
246      #ifndef NRF51_SERIES
247          return false;
248      #else
249          #if defined (NRF51422_XXAA) || defined (DEVELOP_IN_NRF51422)\
250           || defined (NRF51422_XXAB) || defined (DEVELOP_IN_NRF51422)\
251           || defined (NRF51422_XXAC) || defined (DEVELOP_IN_NRF51422)
252              uint32_t var1 = ((*(uint32_t *)0xF0000FE0ul) & 0x000000FFul);
253              uint32_t var2 = ((*(uint32_t *)0xF0000FE8ul) & 0x000000F0ul) >> 4;
254          #endif
255          #if defined (NRF51422_XXAA) || defined (DEVELOP_IN_NRF51422)\
256           || defined (NRF51422_XXAB) || defined (DEVELOP_IN_NRF51422)\
257           || defined (NRF51422_XXAC) || defined (DEVELOP_IN_NRF51422)
258              if (var1 == 0x01)
259              {
260                  switch(var2)
261                  {
262                      case 0x00ul:
263                          return true;
264                      case 0x01ul:
265                          return true;
266                      case 0x02ul:
267                          return false;
268                      case 0x03ul:
269                          return true;
270                      case 0x04ul:
271                          return false;
272                      case 0x07ul:
273                          return false;
274                      case 0x08ul:
275                          return false;
276                      case 0x09ul:
277                          return false;
278                      case 0x0Aul:
279                          return false;
280                      case 0x0Bul:
281                          return false;
282                      case 0x0Cul:
283                          return false;
284                      case 0x0Dul:
285                          return false;
286                  }
287              }
288          #endif
289          return false;
290      #endif
291  }
292  static bool nrf51_errata_7(void)
293  {
294      #ifndef NRF51_SERIES
295          return false;
296      #else
297          #if defined (NRF51422_XXAA) || defined (DEVELOP_IN_NRF51422)\
298           || defined (NRF51422_XXAB) || defined (DEVELOP_IN_NRF51422)\
299           || defined (NRF51422_XXAC) || defined (DEVELOP_IN_NRF51422)
300              uint32_t var1 = ((*(uint32_t *)0xF0000FE0ul) & 0x000000FFul);
301              uint32_t var2 = ((*(uint32_t *)0xF0000FE8ul) & 0x000000F0ul) >> 4;
302          #endif
303          #if defined (NRF51422_XXAA) || defined (DEVELOP_IN_NRF51422)\
304           || defined (NRF51422_XXAB) || defined (DEVELOP_IN_NRF51422)\
305           || defined (NRF51422_XXAC) || defined (DEVELOP_IN_NRF51422)
306              if (var1 == 0x01)
307              {
308                  switch(var2)
309                  {
310                      case 0x00ul:
311                          return true;
312                      case 0x01ul:
313                          return true;
314                      case 0x02ul:
315                          return false;
316                      case 0x03ul:
317                          return true;
318                      case 0x04ul:
319                          return false;
320                      case 0x07ul:
321                          return false;
322                      case 0x08ul:
323                          return false;
324                      case 0x09ul:
325                          return false;
326                      case 0x0Aul:
327                          return false;
328                      case 0x0Bul:
329                          return false;
330                      case 0x0Cul:
331                          return false;
332                      case 0x0Dul:
333                          return false;
334                  }
335              }
336          #endif
337          return false;
338      #endif
339  }
340  static bool nrf51_errata_8(void)
341  {
342      #ifndef NRF51_SERIES
343          return false;
344      #else
345          #if defined (NRF51422_XXAA) || defined (DEVELOP_IN_NRF51422)\
346           || defined (NRF51422_XXAB) || defined (DEVELOP_IN_NRF51422)\
347           || defined (NRF51422_XXAC) || defined (DEVELOP_IN_NRF51422)
348              uint32_t var1 = ((*(uint32_t *)0xF0000FE0ul) & 0x000000FFul);
349              uint32_t var2 = ((*(uint32_t *)0xF0000FE8ul) & 0x000000F0ul) >> 4;
350          #endif
351          #if defined (NRF51422_XXAA) || defined (DEVELOP_IN_NRF51422)\
352           || defined (NRF51422_XXAB) || defined (DEVELOP_IN_NRF51422)\
353           || defined (NRF51422_XXAC) || defined (DEVELOP_IN_NRF51422)
354              if (var1 == 0x01)
355              {
356                  switch(var2)
357                  {
358                      case 0x00ul:
359                          return true;
360                      case 0x01ul:
361                          return true;
362                      case 0x02ul:
363                          return false;
364                      case 0x03ul:
365                          return true;
366                      case 0x04ul:
367                          return false;
368                      case 0x07ul:
369                          return false;
370                      case 0x08ul:
371                          return false;
372                      case 0x09ul:
373                          return false;
374                      case 0x0Aul:
375                          return false;
376                      case 0x0Bul:
377                          return false;
378                      case 0x0Cul:
379                          return false;
380                      case 0x0Dul:
381                          return false;
382                  }
383              }
384          #endif
385          return false;
386      #endif
387  }
388  static bool nrf51_errata_9(void)
389  {
390      #ifndef NRF51_SERIES
391          return false;
392      #else
393          #if defined (NRF51422_XXAA) || defined (DEVELOP_IN_NRF51422)\
394           || defined (NRF51422_XXAB) || defined (DEVELOP_IN_NRF51422)\
395           || defined (NRF51422_XXAC) || defined (DEVELOP_IN_NRF51422)
396              uint32_t var1 = ((*(uint32_t *)0xF0000FE0ul) & 0x000000FFul);
397              uint32_t var2 = ((*(uint32_t *)0xF0000FE8ul) & 0x000000F0ul) >> 4;
398          #endif
399          #if defined (NRF51422_XXAA) || defined (DEVELOP_IN_NRF51422)\
400           || defined (NRF51422_XXAB) || defined (DEVELOP_IN_NRF51422)\
401           || defined (NRF51422_XXAC) || defined (DEVELOP_IN_NRF51422)
402              if (var1 == 0x01)
403              {
404                  switch(var2)
405                  {
406                      case 0x00ul:
407                          return true;
408                      case 0x01ul:
409                          return true;
410                      case 0x02ul:
411                          return false;
412                      case 0x03ul:
413                          return true;
414                      case 0x04ul:
415                          return false;
416                      case 0x07ul:
417                          return false;
418                      case 0x08ul:
419                          return false;
420                      case 0x09ul:
421                          return false;
422                      case 0x0Aul:
423                          return false;
424                      case 0x0Bul:
425                          return false;
426                      case 0x0Cul:
427                          return false;
428                      case 0x0Dul:
429                          return false;
430                  }
431              }
432          #endif
433          return false;
434      #endif
435  }
436  static bool nrf51_errata_10(void)
437  {
438      #ifndef NRF51_SERIES
439          return false;
440      #else
441          #if defined (NRF51422_XXAA) || defined (DEVELOP_IN_NRF51422)\
442           || defined (NRF51422_XXAB) || defined (DEVELOP_IN_NRF51422)\
443           || defined (NRF51422_XXAC) || defined (DEVELOP_IN_NRF51422)
444              uint32_t var1 = ((*(uint32_t *)0xF0000FE0ul) & 0x000000FFul);
445              uint32_t var2 = ((*(uint32_t *)0xF0000FE8ul) & 0x000000F0ul) >> 4;
446          #endif
447          #if defined (NRF51422_XXAA) || defined (DEVELOP_IN_NRF51422)\
448           || defined (NRF51422_XXAB) || defined (DEVELOP_IN_NRF51422)\
449           || defined (NRF51422_XXAC) || defined (DEVELOP_IN_NRF51422)
450              if (var1 == 0x01)
451              {
452                  switch(var2)
453                  {
454                      case 0x00ul:
455                          return true;
456                      case 0x01ul:
457                          return true;
458                      case 0x02ul:
459                          return false;
460                      case 0x03ul:
461                          return true;
462                      case 0x04ul:
463                          return false;
464                      case 0x07ul:
465                          return false;
466                      case 0x08ul:
467                          return false;
468                      case 0x09ul:
469                          return false;
470                      case 0x0Aul:
471                          return false;
472                      case 0x0Bul:
473                          return false;
474                      case 0x0Cul:
475                          return false;
476                      case 0x0Dul:
477                          return false;
478                  }
479              }
480          #endif
481          return false;
482      #endif
483  }
484  static bool nrf51_errata_11(void)
485  {
486      #ifndef NRF51_SERIES
487          return false;
488      #else
489          #if defined (NRF51422_XXAA) || defined (DEVELOP_IN_NRF51422)\
490           || defined (NRF51422_XXAB) || defined (DEVELOP_IN_NRF51422)\
491           || defined (NRF51422_XXAC) || defined (DEVELOP_IN_NRF51422)
492              uint32_t var1 = ((*(uint32_t *)0xF0000FE0ul) & 0x000000FFul);
493              uint32_t var2 = ((*(uint32_t *)0xF0000FE8ul) & 0x000000F0ul) >> 4;
494          #endif
495          #if defined (NRF51422_XXAA) || defined (DEVELOP_IN_NRF51422)\
496           || defined (NRF51422_XXAB) || defined (DEVELOP_IN_NRF51422)\
497           || defined (NRF51422_XXAC) || defined (DEVELOP_IN_NRF51422)
498              if (var1 == 0x01)
499              {
500                  switch(var2)
501                  {
502                      case 0x00ul:
503                          return true;
504                      case 0x01ul:
505                          return true;
506                      case 0x02ul:
507                          return false;
508                      case 0x03ul:
509                          return true;
510                      case 0x04ul:
511                          return false;
512                      case 0x07ul:
513                          return false;
514                      case 0x08ul:
515                          return false;
516                      case 0x09ul:
517                          return false;
518                      case 0x0Aul:
519                          return false;
520                      case 0x0Bul:
521                          return false;
522                      case 0x0Cul:
523                          return false;
524                      case 0x0Dul:
525                          return false;
526                  }
527              }
528          #endif
529          return false;
530      #endif
531  }
532  static bool nrf51_errata_12(void)
533  {
534      #ifndef NRF51_SERIES
535          return false;
536      #else
537          #if defined (NRF51422_XXAA) || defined (DEVELOP_IN_NRF51422)\
538           || defined (NRF51422_XXAB) || defined (DEVELOP_IN_NRF51422)\
539           || defined (NRF51422_XXAC) || defined (DEVELOP_IN_NRF51422)
540              uint32_t var1 = ((*(uint32_t *)0xF0000FE0ul) & 0x000000FFul);
541              uint32_t var2 = ((*(uint32_t *)0xF0000FE8ul) & 0x000000F0ul) >> 4;
542          #endif
543          #if defined (NRF51422_XXAA) || defined (DEVELOP_IN_NRF51422)\
544           || defined (NRF51422_XXAB) || defined (DEVELOP_IN_NRF51422)\
545           || defined (NRF51422_XXAC) || defined (DEVELOP_IN_NRF51422)
546              if (var1 == 0x01)
547              {
548                  switch(var2)
549                  {
550                      case 0x00ul:
551                          return true;
552                      case 0x01ul:
553                          return true;
554                      case 0x02ul:
555                          return false;
556                      case 0x03ul:
557                          return true;
558                      case 0x04ul:
559                          return false;
560                      case 0x07ul:
561                          return false;
562                      case 0x08ul:
563                          return false;
564                      case 0x09ul:
565                          return false;
566                      case 0x0Aul:
567                          return false;
568                      case 0x0Bul:
569                          return false;
570                      case 0x0Cul:
571                          return false;
572                      case 0x0Dul:
573                          return false;
574                  }
575              }
576          #endif
577          return false;
578      #endif
579  }
580  static bool nrf51_errata_13(void)
581  {
582      #ifndef NRF51_SERIES
583          return false;
584      #else
585          #if defined (NRF51422_XXAA) || defined (DEVELOP_IN_NRF51422)\
586           || defined (NRF51422_XXAB) || defined (DEVELOP_IN_NRF51422)\
587           || defined (NRF51422_XXAC) || defined (DEVELOP_IN_NRF51422)
588              uint32_t var1 = ((*(uint32_t *)0xF0000FE0ul) & 0x000000FFul);
589              uint32_t var2 = ((*(uint32_t *)0xF0000FE8ul) & 0x000000F0ul) >> 4;
590          #endif
591          #if defined (NRF51422_XXAA) || defined (DEVELOP_IN_NRF51422)\
592           || defined (NRF51422_XXAB) || defined (DEVELOP_IN_NRF51422)\
593           || defined (NRF51422_XXAC) || defined (DEVELOP_IN_NRF51422)
594              if (var1 == 0x01)
595              {
596                  switch(var2)
597                  {
598                      case 0x00ul:
599                          return true;
600                      case 0x01ul:
601                          return true;
602                      case 0x02ul:
603                          return false;
604                      case 0x03ul:
605                          return true;
606                      case 0x04ul:
607                          return false;
608                      case 0x07ul:
609                          return false;
610                      case 0x08ul:
611                          return false;
612                      case 0x09ul:
613                          return false;
614                      case 0x0Aul:
615                          return false;
616                      case 0x0Bul:
617                          return false;
618                      case 0x0Cul:
619                          return false;
620                      case 0x0Dul:
621                          return false;
622                  }
623              }
624          #endif
625          return false;
626      #endif
627  }
628  static bool nrf51_errata_14(void)
629  {
630      #ifndef NRF51_SERIES
631          return false;
632      #else
633          #if defined (NRF51422_XXAA) || defined (DEVELOP_IN_NRF51422)\
634           || defined (NRF51422_XXAB) || defined (DEVELOP_IN_NRF51422)\
635           || defined (NRF51422_XXAC) || defined (DEVELOP_IN_NRF51422)
636              uint32_t var1 = ((*(uint32_t *)0xF0000FE0ul) & 0x000000FFul);
637              uint32_t var2 = ((*(uint32_t *)0xF0000FE8ul) & 0x000000F0ul) >> 4;
638          #endif
639          #if defined (NRF51422_XXAA) || defined (DEVELOP_IN_NRF51422)\
640           || defined (NRF51422_XXAB) || defined (DEVELOP_IN_NRF51422)\
641           || defined (NRF51422_XXAC) || defined (DEVELOP_IN_NRF51422)
642              if (var1 == 0x01)
643              {
644                  switch(var2)
645                  {
646                      case 0x00ul:
647                          return true;
648                      case 0x01ul:
649                          return true;
650                      case 0x02ul:
651                          return false;
652                      case 0x03ul:
653                          return true;
654                      case 0x04ul:
655                          return false;
656                      case 0x07ul:
657                          return false;
658                      case 0x08ul:
659                          return false;
660                      case 0x09ul:
661                          return false;
662                      case 0x0Aul:
663                          return false;
664                      case 0x0Bul:
665                          return false;
666                      case 0x0Cul:
667                          return false;
668                      case 0x0Dul:
669                          return false;
670                  }
671              }
672          #endif
673          return false;
674      #endif
675  }
676  static bool nrf51_errata_15(void)
677  {
678      #ifndef NRF51_SERIES
679          return false;
680      #else
681          #if defined (NRF51422_XXAA) || defined (DEVELOP_IN_NRF51422)\
682           || defined (NRF51422_XXAB) || defined (DEVELOP_IN_NRF51422)\
683           || defined (NRF51422_XXAC) || defined (DEVELOP_IN_NRF51422)
684              uint32_t var1 = ((*(uint32_t *)0xF0000FE0ul) & 0x000000FFul);
685              uint32_t var2 = ((*(uint32_t *)0xF0000FE8ul) & 0x000000F0ul) >> 4;
686          #endif
687          #if defined (NRF51422_XXAA) || defined (DEVELOP_IN_NRF51422)\
688           || defined (NRF51422_XXAB) || defined (DEVELOP_IN_NRF51422)\
689           || defined (NRF51422_XXAC) || defined (DEVELOP_IN_NRF51422)
690              if (var1 == 0x01)
691              {
692                  switch(var2)
693                  {
694                      case 0x00ul:
695                          return true;
696                      case 0x01ul:
697                          return true;
698                      case 0x02ul:
699                          return false;
700                      case 0x03ul:
701                          return true;
702                      case 0x04ul:
703                          return false;
704                      case 0x07ul:
705                          return false;
706                      case 0x08ul:
707                          return false;
708                      case 0x09ul:
709                          return false;
710                      case 0x0Aul:
711                          return false;
712                      case 0x0Bul:
713                          return false;
714                      case 0x0Cul:
715                          return false;
716                      case 0x0Dul:
717                          return false;
718                  }
719              }
720          #endif
721          return false;
722      #endif
723  }
724  static bool nrf51_errata_16(void)
725  {
726      #ifndef NRF51_SERIES
727          return false;
728      #else
729          #if defined (NRF51422_XXAA) || defined (DEVELOP_IN_NRF51422)\
730           || defined (NRF51422_XXAB) || defined (DEVELOP_IN_NRF51422)\
731           || defined (NRF51422_XXAC) || defined (DEVELOP_IN_NRF51422)
732              uint32_t var1 = ((*(uint32_t *)0xF0000FE0ul) & 0x000000FFul);
733              uint32_t var2 = ((*(uint32_t *)0xF0000FE8ul) & 0x000000F0ul) >> 4;
734          #endif
735          #if defined (NRF51422_XXAA) || defined (DEVELOP_IN_NRF51422)\
736           || defined (NRF51422_XXAB) || defined (DEVELOP_IN_NRF51422)\
737           || defined (NRF51422_XXAC) || defined (DEVELOP_IN_NRF51422)
738              if (var1 == 0x01)
739              {
740                  switch(var2)
741                  {
742                      case 0x00ul:
743                          return true;
744                      case 0x01ul:
745                          return true;
746                      case 0x02ul:
747                          return false;
748                      case 0x03ul:
749                          return true;
750                      case 0x04ul:
751                          return false;
752                      case 0x07ul:
753                          return false;
754                      case 0x08ul:
755                          return false;
756                      case 0x09ul:
757                          return false;
758                      case 0x0Aul:
759                          return false;
760                      case 0x0Bul:
761                          return false;
762                      case 0x0Cul:
763                          return false;
764                      case 0x0Dul:
765                          return false;
766                  }
767              }
768          #endif
769          return false;
770      #endif
771  }
772  static bool nrf51_errata_17(void)
773  {
774      #ifndef NRF51_SERIES
775          return false;
776      #else
777          #if defined (NRF51422_XXAA) || defined (DEVELOP_IN_NRF51422)\
778           || defined (NRF51422_XXAB) || defined (DEVELOP_IN_NRF51422)\
779           || defined (NRF51422_XXAC) || defined (DEVELOP_IN_NRF51422)
780              uint32_t var1 = ((*(uint32_t *)0xF0000FE0ul) & 0x000000FFul);
781              uint32_t var2 = ((*(uint32_t *)0xF0000FE8ul) & 0x000000F0ul) >> 4;
782          #endif
783          #if defined (NRF51422_XXAA) || defined (DEVELOP_IN_NRF51422)\
784           || defined (NRF51422_XXAB) || defined (DEVELOP_IN_NRF51422)\
785           || defined (NRF51422_XXAC) || defined (DEVELOP_IN_NRF51422)
786              if (var1 == 0x01)
787              {
788                  switch(var2)
789                  {
790                      case 0x00ul:
791                          return true;
792                      case 0x01ul:
793                          return true;
794                      case 0x02ul:
795                          return false;
796                      case 0x03ul:
797                          return true;
798                      case 0x04ul:
799                          return false;
800                      case 0x07ul:
801                          return false;
802                      case 0x08ul:
803                          return false;
804                      case 0x09ul:
805                          return false;
806                      case 0x0Aul:
807                          return false;
808                      case 0x0Bul:
809                          return false;
810                      case 0x0Cul:
811                          return false;
812                      case 0x0Dul:
813                          return false;
814                  }
815              }
816          #endif
817          return false;
818      #endif
819  }
820  static bool nrf51_errata_18(void)
821  {
822      #ifndef NRF51_SERIES
823          return false;
824      #else
825          #if defined (NRF51422_XXAA) || defined (DEVELOP_IN_NRF51422)\
826           || defined (NRF51422_XXAB) || defined (DEVELOP_IN_NRF51422)\
827           || defined (NRF51422_XXAC) || defined (DEVELOP_IN_NRF51422)
828              uint32_t var1 = ((*(uint32_t *)0xF0000FE0ul) & 0x000000FFul);
829              uint32_t var2 = ((*(uint32_t *)0xF0000FE8ul) & 0x000000F0ul) >> 4;
830          #endif
831          #if defined (NRF51422_XXAA) || defined (DEVELOP_IN_NRF51422)\
832           || defined (NRF51422_XXAB) || defined (DEVELOP_IN_NRF51422)\
833           || defined (NRF51422_XXAC) || defined (DEVELOP_IN_NRF51422)
834              if (var1 == 0x01)
835              {
836                  switch(var2)
837                  {
838                      case 0x00ul:
839                          return true;
840                      case 0x01ul:
841                          return true;
842                      case 0x02ul:
843                          return false;
844                      case 0x03ul:
845                          return true;
846                      case 0x04ul:
847                          return false;
848                      case 0x07ul:
849                          return false;
850                      case 0x08ul:
851                          return false;
852                      case 0x09ul:
853                          return false;
854                      case 0x0Aul:
855                          return false;
856                      case 0x0Bul:
857                          return false;
858                      case 0x0Cul:
859                          return false;
860                      case 0x0Dul:
861                          return false;
862                  }
863              }
864          #endif
865          return false;
866      #endif
867  }
868  static bool nrf51_errata_19(void)
869  {
870      #ifndef NRF51_SERIES
871          return false;
872      #else
873          #if defined (NRF51422_XXAA) || defined (DEVELOP_IN_NRF51422)\
874           || defined (NRF51422_XXAB) || defined (DEVELOP_IN_NRF51422)\
875           || defined (NRF51422_XXAC) || defined (DEVELOP_IN_NRF51422)
876              uint32_t var1 = ((*(uint32_t *)0xF0000FE0ul) & 0x000000FFul);
877              uint32_t var2 = ((*(uint32_t *)0xF0000FE8ul) & 0x000000F0ul) >> 4;
878          #endif
879          #if defined (NRF51422_XXAA) || defined (DEVELOP_IN_NRF51422)\
880           || defined (NRF51422_XXAB) || defined (DEVELOP_IN_NRF51422)\
881           || defined (NRF51422_XXAC) || defined (DEVELOP_IN_NRF51422)
882              if (var1 == 0x01)
883              {
884                  switch(var2)
885                  {
886                      case 0x00ul:
887                          return true;
888                      case 0x01ul:
889                          return true;
890                      case 0x02ul:
891                          return false;
892                      case 0x03ul:
893                          return true;
894                      case 0x04ul:
895                          return false;
896                      case 0x07ul:
897                          return false;
898                      case 0x08ul:
899                          return false;
900                      case 0x09ul:
901                          return false;
902                      case 0x0Aul:
903                          return false;
904                      case 0x0Bul:
905                          return false;
906                      case 0x0Cul:
907                          return false;
908                      case 0x0Dul:
909                          return false;
910                  }
911              }
912          #endif
913          return false;
914      #endif
915  }
916  static bool nrf51_errata_20(void)
917  {
918      #ifndef NRF51_SERIES
919          return false;
920      #else
921          #if defined (NRF51422_XXAA) || defined (DEVELOP_IN_NRF51422)\
922           || defined (NRF51422_XXAB) || defined (DEVELOP_IN_NRF51422)\
923           || defined (NRF51422_XXAC) || defined (DEVELOP_IN_NRF51422)
924              uint32_t var1 = ((*(uint32_t *)0xF0000FE0ul) & 0x000000FFul);
925              uint32_t var2 = ((*(uint32_t *)0xF0000FE8ul) & 0x000000F0ul) >> 4;
926          #endif
927          #if defined (NRF51422_XXAA) || defined (DEVELOP_IN_NRF51422)\
928           || defined (NRF51422_XXAB) || defined (DEVELOP_IN_NRF51422)\
929           || defined (NRF51422_XXAC) || defined (DEVELOP_IN_NRF51422)
930              if (var1 == 0x01)
931              {
932                  switch(var2)
933                  {
934                      case 0x00ul:
935                          return true;
936                      case 0x01ul:
937                          return true;
938                      case 0x02ul:
939                          return false;
940                      case 0x03ul:
941                          return true;
942                      case 0x04ul:
943                          return false;
944                      case 0x07ul:
945                          return false;
946                      case 0x08ul:
947                          return false;
948                      case 0x09ul:
949                          return false;
950                      case 0x0Aul:
951                          return false;
952                      case 0x0Bul:
953                          return false;
954                      case 0x0Cul:
955                          return false;
956                      case 0x0Dul:
957                          return false;
958                  }
959              }
960          #endif
961          return false;
962      #endif
963  }
964  static bool nrf51_errata_21(void)
965  {
966      #ifndef NRF51_SERIES
967          return false;
968      #else
969          #if defined (NRF51422_XXAA) || defined (DEVELOP_IN_NRF51422)\
970           || defined (NRF51422_XXAB) || defined (DEVELOP_IN_NRF51422)\
971           || defined (NRF51422_XXAC) || defined (DEVELOP_IN_NRF51422)
972              uint32_t var1 = ((*(uint32_t *)0xF0000FE0ul) & 0x000000FFul);
973              uint32_t var2 = ((*(uint32_t *)0xF0000FE8ul) & 0x000000F0ul) >> 4;
974          #endif
975          #if defined (NRF51422_XXAA) || defined (DEVELOP_IN_NRF51422)\
976           || defined (NRF51422_XXAB) || defined (DEVELOP_IN_NRF51422)\
977           || defined (NRF51422_XXAC) || defined (DEVELOP_IN_NRF51422)
978              if (var1 == 0x01)
979              {
980                  switch(var2)
981                  {
982                      case 0x00ul:
983                          return true;
984                      case 0x01ul:
985                          return true;
986                      case 0x02ul:
987                          return false;
988                      case 0x03ul:
989                          return true;
990                      case 0x04ul:
991                          return false;
992                      case 0x07ul:
993                          return false;
994                      case 0x08ul:
995                          return false;
996                      case 0x09ul:
997                          return false;
998                      case 0x0Aul:
999                          return false;
1000                      case 0x0Bul:
1001                          return false;
1002                      case 0x0Cul:
1003                          return false;
1004                      case 0x0Dul:
1005                          return false;
1006                  }
1007              }
1008          #endif
1009          return false;
1010      #endif
1011  }
1012  static bool nrf51_errata_22(void)
1013  {
1014      #ifndef NRF51_SERIES
1015          return false;
1016      #else
1017          #if defined (NRF51422_XXAA) || defined (DEVELOP_IN_NRF51422)\
1018           || defined (NRF51422_XXAB) || defined (DEVELOP_IN_NRF51422)\
1019           || defined (NRF51422_XXAC) || defined (DEVELOP_IN_NRF51422)
1020              uint32_t var1 = ((*(uint32_t *)0xF0000FE0ul) & 0x000000FFul);
1021              uint32_t var2 = ((*(uint32_t *)0xF0000FE8ul) & 0x000000F0ul) >> 4;
1022          #endif
1023          #if defined (NRF51422_XXAA) || defined (DEVELOP_IN_NRF51422)\
1024           || defined (NRF51422_XXAB) || defined (DEVELOP_IN_NRF51422)\
1025           || defined (NRF51422_XXAC) || defined (DEVELOP_IN_NRF51422)
1026              if (var1 == 0x01)
1027              {
1028                  switch(var2)
1029                  {
1030                      case 0x00ul:
1031                          return true;
1032                      case 0x01ul:
1033                          return true;
1034                      case 0x02ul:
1035                          return false;
1036                      case 0x03ul:
1037                          return true;
1038                      case 0x04ul:
1039                          return false;
1040                      case 0x07ul:
1041                          return false;
1042                      case 0x08ul:
1043                          return false;
1044                      case 0x09ul:
1045                          return false;
1046                      case 0x0Aul:
1047                          return false;
1048                      case 0x0Bul:
1049                          return false;
1050                      case 0x0Cul:
1051                          return false;
1052                      case 0x0Dul:
1053                          return false;
1054                  }
1055              }
1056          #endif
1057          return false;
1058      #endif
1059  }
1060  static bool nrf51_errata_23(void)
1061  {
1062      #ifndef NRF51_SERIES
1063          return false;
1064      #else
1065          #if defined (NRF51422_XXAA) || defined (DEVELOP_IN_NRF51422)\
1066           || defined (NRF51422_XXAB) || defined (DEVELOP_IN_NRF51422)\
1067           || defined (NRF51422_XXAC) || defined (DEVELOP_IN_NRF51422)
1068              uint32_t var1 = ((*(uint32_t *)0xF0000FE0ul) & 0x000000FFul);
1069              uint32_t var2 = ((*(uint32_t *)0xF0000FE8ul) & 0x000000F0ul) >> 4;
1070          #endif
1071          #if defined (NRF51422_XXAA) || defined (DEVELOP_IN_NRF51422)\
1072           || defined (NRF51422_XXAB) || defined (DEVELOP_IN_NRF51422)\
1073           || defined (NRF51422_XXAC) || defined (DEVELOP_IN_NRF51422)
1074              if (var1 == 0x01)
1075              {
1076                  switch(var2)
1077                  {
1078                      case 0x00ul:
1079                          return true;
1080                      case 0x01ul:
1081                          return true;
1082                      case 0x02ul:
1083                          return false;
1084                      case 0x03ul:
1085                          return true;
1086                      case 0x04ul:
1087                          return false;
1088                      case 0x07ul:
1089                          return false;
1090                      case 0x08ul:
1091                          return false;
1092                      case 0x09ul:
1093                          return false;
1094                      case 0x0Aul:
1095                          return false;
1096                      case 0x0Bul:
1097                          return false;
1098                      case 0x0Cul:
1099                          return false;
1100                      case 0x0Dul:
1101                          return false;
1102                  }
1103              }
1104          #endif
1105          return false;
1106      #endif
1107  }
1108  static bool nrf51_errata_24(void)
1109  {
1110      #ifndef NRF51_SERIES
1111          return false;
1112      #else
1113          #if defined (NRF51422_XXAA) || defined (DEVELOP_IN_NRF51422)\
1114           || defined (NRF51422_XXAB) || defined (DEVELOP_IN_NRF51422)\
1115           || defined (NRF51422_XXAC) || defined (DEVELOP_IN_NRF51422)
1116              uint32_t var1 = ((*(uint32_t *)0xF0000FE0ul) & 0x000000FFul);
1117              uint32_t var2 = ((*(uint32_t *)0xF0000FE8ul) & 0x000000F0ul) >> 4;
1118          #endif
1119          #if defined (NRF51422_XXAA) || defined (DEVELOP_IN_NRF51422)\
1120           || defined (NRF51422_XXAB) || defined (DEVELOP_IN_NRF51422)\
1121           || defined (NRF51422_XXAC) || defined (DEVELOP_IN_NRF51422)
1122              if (var1 == 0x01)
1123              {
1124                  switch(var2)
1125                  {
1126                      case 0x00ul:
1127                          return true;
1128                      case 0x01ul:
1129                          return true;
1130                      case 0x02ul:
1131                          return false;
1132                      case 0x03ul:
1133                          return true;
1134                      case 0x04ul:
1135                          return false;
1136                      case 0x07ul:
1137                          return false;
1138                      case 0x08ul:
1139                          return false;
1140                      case 0x09ul:
1141                          return false;
1142                      case 0x0Aul:
1143                          return false;
1144                      case 0x0Bul:
1145                          return false;
1146                      case 0x0Cul:
1147                          return false;
1148                      case 0x0Dul:
1149                          return false;
1150                  }
1151              }
1152          #endif
1153          return false;
1154      #endif
1155  }
1156  static bool nrf51_errata_25(void)
1157  {
1158      #ifndef NRF51_SERIES
1159          return false;
1160      #else
1161          #if defined (NRF51422_XXAA) || defined (DEVELOP_IN_NRF51422)\
1162           || defined (NRF51422_XXAB) || defined (DEVELOP_IN_NRF51422)\
1163           || defined (NRF51422_XXAC) || defined (DEVELOP_IN_NRF51422)
1164              uint32_t var1 = ((*(uint32_t *)0xF0000FE0ul) & 0x000000FFul);
1165              uint32_t var2 = ((*(uint32_t *)0xF0000FE8ul) & 0x000000F0ul) >> 4;
1166          #endif
1167          #if defined (NRF51422_XXAA) || defined (DEVELOP_IN_NRF51422)\
1168           || defined (NRF51422_XXAB) || defined (DEVELOP_IN_NRF51422)\
1169           || defined (NRF51422_XXAC) || defined (DEVELOP_IN_NRF51422)
1170              if (var1 == 0x01)
1171              {
1172                  switch(var2)
1173                  {
1174                      case 0x00ul:
1175                          return true;
1176                      case 0x01ul:
1177                          return true;
1178                      case 0x02ul:
1179                          return false;
1180                      case 0x03ul:
1181                          return true;
1182                      case 0x04ul:
1183                          return false;
1184                      case 0x07ul:
1185                          return false;
1186                      case 0x08ul:
1187                          return false;
1188                      case 0x09ul:
1189                          return false;
1190                      case 0x0Aul:
1191                          return false;
1192                      case 0x0Bul:
1193                          return false;
1194                      case 0x0Cul:
1195                          return false;
1196                      case 0x0Dul:
1197                          return false;
1198                  }
1199              }
1200          #endif
1201          return false;
1202      #endif
1203  }
1204  static bool nrf51_errata_26(void)
1205  {
1206      #ifndef NRF51_SERIES
1207          return false;
1208      #else
1209          #if defined (NRF51422_XXAA) || defined (DEVELOP_IN_NRF51422)\
1210           || defined (NRF51422_XXAB) || defined (DEVELOP_IN_NRF51422)\
1211           || defined (NRF51422_XXAC) || defined (DEVELOP_IN_NRF51422)
1212              uint32_t var1 = ((*(uint32_t *)0xF0000FE0ul) & 0x000000FFul);
1213              uint32_t var2 = ((*(uint32_t *)0xF0000FE8ul) & 0x000000F0ul) >> 4;
1214          #endif
1215          #if defined (NRF51422_XXAA) || defined (DEVELOP_IN_NRF51422)\
1216           || defined (NRF51422_XXAB) || defined (DEVELOP_IN_NRF51422)\
1217           || defined (NRF51422_XXAC) || defined (DEVELOP_IN_NRF51422)
1218              if (var1 == 0x01)
1219              {
1220                  switch(var2)
1221                  {
1222                      case 0x00ul:
1223                          return true;
1224                      case 0x01ul:
1225                          return true;
1226                      case 0x02ul:
1227                          return false;
1228                      case 0x03ul:
1229                          return true;
1230                      case 0x04ul:
1231                          return false;
1232                      case 0x07ul:
1233                          return false;
1234                      case 0x08ul:
1235                          return false;
1236                      case 0x09ul:
1237                          return false;
1238                      case 0x0Aul:
1239                          return false;
1240                      case 0x0Bul:
1241                          return false;
1242                      case 0x0Cul:
1243                          return false;
1244                      case 0x0Dul:
1245                          return false;
1246                  }
1247              }
1248          #endif
1249          return false;
1250      #endif
1251  }
1252  static bool nrf51_errata_27(void)
1253  {
1254      #ifndef NRF51_SERIES
1255          return false;
1256      #else
1257          #if defined (NRF51422_XXAA) || defined (DEVELOP_IN_NRF51422)\
1258           || defined (NRF51422_XXAB) || defined (DEVELOP_IN_NRF51422)\
1259           || defined (NRF51422_XXAC) || defined (DEVELOP_IN_NRF51422)
1260              uint32_t var1 = ((*(uint32_t *)0xF0000FE0ul) & 0x000000FFul);
1261              uint32_t var2 = ((*(uint32_t *)0xF0000FE8ul) & 0x000000F0ul) >> 4;
1262          #endif
1263          #if defined (NRF51422_XXAA) || defined (DEVELOP_IN_NRF51422)\
1264           || defined (NRF51422_XXAB) || defined (DEVELOP_IN_NRF51422)\
1265           || defined (NRF51422_XXAC) || defined (DEVELOP_IN_NRF51422)
1266              if (var1 == 0x01)
1267              {
1268                  switch(var2)
1269                  {
1270                      case 0x00ul:
1271                          return true;
1272                      case 0x01ul:
1273                          return true;
1274                      case 0x02ul:
1275                          return false;
1276                      case 0x03ul:
1277                          return true;
1278                      case 0x04ul:
1279                          return false;
1280                      case 0x07ul:
1281                          return false;
1282                      case 0x08ul:
1283                          return false;
1284                      case 0x09ul:
1285                          return false;
1286                      case 0x0Aul:
1287                          return false;
1288                      case 0x0Bul:
1289                          return false;
1290                      case 0x0Cul:
1291                          return false;
1292                      case 0x0Dul:
1293                          return false;
1294                  }
1295              }
1296          #endif
1297          return false;
1298      #endif
1299  }
1300  static bool nrf51_errata_28(void)
1301  {
1302      #ifndef NRF51_SERIES
1303          return false;
1304      #else
1305          #if defined (NRF51422_XXAA) || defined (DEVELOP_IN_NRF51422)\
1306           || defined (NRF51422_XXAB) || defined (DEVELOP_IN_NRF51422)\
1307           || defined (NRF51422_XXAC) || defined (DEVELOP_IN_NRF51422)
1308              uint32_t var1 = ((*(uint32_t *)0xF0000FE0ul) & 0x000000FFul);
1309              uint32_t var2 = ((*(uint32_t *)0xF0000FE8ul) & 0x000000F0ul) >> 4;
1310          #endif
1311          #if defined (NRF51422_XXAA) || defined (DEVELOP_IN_NRF51422)\
1312           || defined (NRF51422_XXAB) || defined (DEVELOP_IN_NRF51422)\
1313           || defined (NRF51422_XXAC) || defined (DEVELOP_IN_NRF51422)
1314              if (var1 == 0x01)
1315              {
1316                  switch(var2)
1317                  {
1318                      case 0x00ul:
1319                          return true;
1320                      case 0x01ul:
1321                          return true;
1322                      case 0x02ul:
1323                          return false;
1324                      case 0x03ul:
1325                          return true;
1326                      case 0x04ul:
1327                          return false;
1328                      case 0x07ul:
1329                          return false;
1330                      case 0x08ul:
1331                          return false;
1332                      case 0x09ul:
1333                          return false;
1334                      case 0x0Aul:
1335                          return false;
1336                      case 0x0Bul:
1337                          return false;
1338                      case 0x0Cul:
1339                          return false;
1340                      case 0x0Dul:
1341                          return false;
1342                  }
1343              }
1344          #endif
1345          return false;
1346      #endif
1347  }
1348  static bool nrf51_errata_29(void)
1349  {
1350      #ifndef NRF51_SERIES
1351          return false;
1352      #else
1353          #if defined (NRF51422_XXAA) || defined (DEVELOP_IN_NRF51422)\
1354           || defined (NRF51422_XXAB) || defined (DEVELOP_IN_NRF51422)\
1355           || defined (NRF51422_XXAC) || defined (DEVELOP_IN_NRF51422)
1356              uint32_t var1 = ((*(uint32_t *)0xF0000FE0ul) & 0x000000FFul);
1357              uint32_t var2 = ((*(uint32_t *)0xF0000FE8ul) & 0x000000F0ul) >> 4;
1358          #endif
1359          #if defined (NRF51422_XXAA) || defined (DEVELOP_IN_NRF51422)\
1360           || defined (NRF51422_XXAB) || defined (DEVELOP_IN_NRF51422)\
1361           || defined (NRF51422_XXAC) || defined (DEVELOP_IN_NRF51422)
1362              if (var1 == 0x01)
1363              {
1364                  switch(var2)
1365                  {
1366                      case 0x00ul:
1367                          return true;
1368                      case 0x01ul:
1369                          return true;
1370                      case 0x02ul:
1371                          return false;
1372                      case 0x03ul:
1373                          return true;
1374                      case 0x04ul:
1375                          return false;
1376                      case 0x07ul:
1377                          return false;
1378                      case 0x08ul:
1379                          return false;
1380                      case 0x09ul:
1381                          return false;
1382                      case 0x0Aul:
1383                          return false;
1384                      case 0x0Bul:
1385                          return false;
1386                      case 0x0Cul:
1387                          return false;
1388                      case 0x0Dul:
1389                          return false;
1390                  }
1391              }
1392          #endif
1393          return false;
1394      #endif
1395  }
1396  static bool nrf51_errata_30(void)
1397  {
1398      #ifndef NRF51_SERIES
1399          return false;
1400      #else
1401          #if defined (NRF51422_XXAA) || defined (DEVELOP_IN_NRF51422)\
1402           || defined (NRF51422_XXAB) || defined (DEVELOP_IN_NRF51422)\
1403           || defined (NRF51422_XXAC) || defined (DEVELOP_IN_NRF51422)
1404              uint32_t var1 = ((*(uint32_t *)0xF0000FE0ul) & 0x000000FFul);
1405              uint32_t var2 = ((*(uint32_t *)0xF0000FE8ul) & 0x000000F0ul) >> 4;
1406          #endif
1407          #if defined (NRF51422_XXAA) || defined (DEVELOP_IN_NRF51422)\
1408           || defined (NRF51422_XXAB) || defined (DEVELOP_IN_NRF51422)\
1409           || defined (NRF51422_XXAC) || defined (DEVELOP_IN_NRF51422)
1410              if (var1 == 0x01)
1411              {
1412                  switch(var2)
1413                  {
1414                      case 0x00ul:
1415                          return true;
1416                      case 0x01ul:
1417                          return true;
1418                      case 0x02ul:
1419                          return false;
1420                      case 0x03ul:
1421                          return true;
1422                      case 0x04ul:
1423                          return false;
1424                      case 0x07ul:
1425                          return false;
1426                      case 0x08ul:
1427                          return false;
1428                      case 0x09ul:
1429                          return false;
1430                      case 0x0Aul:
1431                          return false;
1432                      case 0x0Bul:
1433                          return false;
1434                      case 0x0Cul:
1435                          return false;
1436                      case 0x0Dul:
1437                          return false;
1438                  }
1439              }
1440          #endif
1441          return false;
1442      #endif
1443  }
1444  static bool nrf51_errata_31(void)
1445  {
1446      #ifndef NRF51_SERIES
1447          return false;
1448      #else
1449          #if defined (NRF51422_XXAA) || defined (DEVELOP_IN_NRF51422)\
1450           || defined (NRF51422_XXAB) || defined (DEVELOP_IN_NRF51422)\
1451           || defined (NRF51422_XXAC) || defined (DEVELOP_IN_NRF51422)
1452              uint32_t var1 = ((*(uint32_t *)0xF0000FE0ul) & 0x000000FFul);
1453              uint32_t var2 = ((*(uint32_t *)0xF0000FE8ul) & 0x000000F0ul) >> 4;
1454          #endif
1455          #if defined (NRF51422_XXAA) || defined (DEVELOP_IN_NRF51422)\
1456           || defined (NRF51422_XXAB) || defined (DEVELOP_IN_NRF51422)\
1457           || defined (NRF51422_XXAC) || defined (DEVELOP_IN_NRF51422)
1458              if (var1 == 0x01)
1459              {
1460                  switch(var2)
1461                  {
1462                      case 0x00ul:
1463                          return true;
1464                      case 0x01ul:
1465                          return true;
1466                      case 0x02ul:
1467                          return false;
1468                      case 0x03ul:
1469                          return true;
1470                      case 0x04ul:
1471                          return false;
1472                      case 0x07ul:
1473                          return false;
1474                      case 0x08ul:
1475                          return false;
1476                      case 0x09ul:
1477                          return false;
1478                      case 0x0Aul:
1479                          return false;
1480                      case 0x0Bul:
1481                          return false;
1482                      case 0x0Cul:
1483                          return false;
1484                      case 0x0Dul:
1485                          return false;
1486                  }
1487              }
1488          #endif
1489          return false;
1490      #endif
1491  }
1492  static bool nrf51_errata_32(void)
1493  {
1494      #ifndef NRF51_SERIES
1495          return false;
1496      #else
1497          #if defined (NRF51422_XXAA) || defined (DEVELOP_IN_NRF51422)\
1498           || defined (NRF51422_XXAB) || defined (DEVELOP_IN_NRF51422)\
1499           || defined (NRF51422_XXAC) || defined (DEVELOP_IN_NRF51422)
1500              uint32_t var1 = ((*(uint32_t *)0xF0000FE0ul) & 0x000000FFul);
1501              uint32_t var2 = ((*(uint32_t *)0xF0000FE8ul) & 0x000000F0ul) >> 4;
1502          #endif
1503          #if defined (NRF51422_XXAA) || defined (DEVELOP_IN_NRF51422)\
1504           || defined (NRF51422_XXAB) || defined (DEVELOP_IN_NRF51422)\
1505           || defined (NRF51422_XXAC) || defined (DEVELOP_IN_NRF51422)
1506              if (var1 == 0x01)
1507              {
1508                  switch(var2)
1509                  {
1510                      case 0x00ul:
1511                          return true;
1512                      case 0x01ul:
1513                          return true;
1514                      case 0x02ul:
1515                          return false;
1516                      case 0x03ul:
1517                          return true;
1518                      case 0x04ul:
1519                          return false;
1520                      case 0x07ul:
1521                          return false;
1522                      case 0x08ul:
1523                          return false;
1524                      case 0x09ul:
1525                          return false;
1526                      case 0x0Aul:
1527                          return false;
1528                      case 0x0Bul:
1529                          return false;
1530                      case 0x0Cul:
1531                          return false;
1532                      case 0x0Dul:
1533                          return false;
1534                  }
1535              }
1536          #endif
1537          return false;
1538      #endif
1539  }
1540  static bool nrf51_errata_33(void)
1541  {
1542      #ifndef NRF51_SERIES
1543          return false;
1544      #else
1545          #if defined (NRF51422_XXAA) || defined (DEVELOP_IN_NRF51422)\
1546           || defined (NRF51422_XXAB) || defined (DEVELOP_IN_NRF51422)\
1547           || defined (NRF51422_XXAC) || defined (DEVELOP_IN_NRF51422)
1548              uint32_t var1 = ((*(uint32_t *)0xF0000FE0ul) & 0x000000FFul);
1549              uint32_t var2 = ((*(uint32_t *)0xF0000FE8ul) & 0x000000F0ul) >> 4;
1550          #endif
1551          #if defined (NRF51422_XXAA) || defined (DEVELOP_IN_NRF51422)\
1552           || defined (NRF51422_XXAB) || defined (DEVELOP_IN_NRF51422)\
1553           || defined (NRF51422_XXAC) || defined (DEVELOP_IN_NRF51422)
1554              if (var1 == 0x01)
1555              {
1556                  switch(var2)
1557                  {
1558                      case 0x00ul:
1559                          return true;
1560                      case 0x01ul:
1561                          return true;
1562                      case 0x02ul:
1563                          return false;
1564                      case 0x03ul:
1565                          return true;
1566                      case 0x04ul:
1567                          return false;
1568                      case 0x07ul:
1569                          return false;
1570                      case 0x08ul:
1571                          return false;
1572                      case 0x09ul:
1573                          return false;
1574                      case 0x0Aul:
1575                          return false;
1576                      case 0x0Bul:
1577                          return false;
1578                      case 0x0Cul:
1579                          return false;
1580                      case 0x0Dul:
1581                          return false;
1582                  }
1583              }
1584          #endif
1585          return false;
1586      #endif
1587  }
1588  static bool nrf51_errata_34(void)
1589  {
1590      #ifndef NRF51_SERIES
1591          return false;
1592      #else
1593          #if defined (NRF51422_XXAA) || defined (DEVELOP_IN_NRF51422)\
1594           || defined (NRF51422_XXAB) || defined (DEVELOP_IN_NRF51422)\
1595           || defined (NRF51422_XXAC) || defined (DEVELOP_IN_NRF51422)
1596              uint32_t var1 = ((*(uint32_t *)0xF0000FE0ul) & 0x000000FFul);
1597              uint32_t var2 = ((*(uint32_t *)0xF0000FE8ul) & 0x000000F0ul) >> 4;
1598          #endif
1599          #if defined (NRF51422_XXAA) || defined (DEVELOP_IN_NRF51422)\
1600           || defined (NRF51422_XXAB) || defined (DEVELOP_IN_NRF51422)\
1601           || defined (NRF51422_XXAC) || defined (DEVELOP_IN_NRF51422)
1602              if (var1 == 0x01)
1603              {
1604                  switch(var2)
1605                  {
1606                      case 0x00ul:
1607                          return true;
1608                      case 0x01ul:
1609                          return true;
1610                      case 0x02ul:
1611                          return false;
1612                      case 0x03ul:
1613                          return true;
1614                      case 0x04ul:
1615                          return false;
1616                      case 0x07ul:
1617                          return false;
1618                      case 0x08ul:
1619                          return false;
1620                      case 0x09ul:
1621                          return false;
1622                      case 0x0Aul:
1623                          return false;
1624                      case 0x0Bul:
1625                          return false;
1626                      case 0x0Cul:
1627                          return false;
1628                      case 0x0Dul:
1629                          return false;
1630                  }
1631              }
1632          #endif
1633          return false;
1634      #endif
1635  }
1636  static bool nrf51_errata_35(void)
1637  {
1638      #ifndef NRF51_SERIES
1639          return false;
1640      #else
1641          #if defined (NRF51422_XXAA) || defined (DEVELOP_IN_NRF51422)\
1642           || defined (NRF51422_XXAB) || defined (DEVELOP_IN_NRF51422)\
1643           || defined (NRF51422_XXAC) || defined (DEVELOP_IN_NRF51422)
1644              uint32_t var1 = ((*(uint32_t *)0xF0000FE0ul) & 0x000000FFul);
1645              uint32_t var2 = ((*(uint32_t *)0xF0000FE8ul) & 0x000000F0ul) >> 4;
1646          #endif
1647          #if defined (NRF51422_XXAA) || defined (DEVELOP_IN_NRF51422)\
1648           || defined (NRF51422_XXAB) || defined (DEVELOP_IN_NRF51422)\
1649           || defined (NRF51422_XXAC) || defined (DEVELOP_IN_NRF51422)
1650              if (var1 == 0x01)
1651              {
1652                  switch(var2)
1653                  {
1654                      case 0x00ul:
1655                          return true;
1656                      case 0x01ul:
1657                          return true;
1658                      case 0x02ul:
1659                          return true;
1660                      case 0x03ul:
1661                          return true;
1662                      case 0x04ul:
1663                          return true;
1664                      case 0x07ul:
1665                          return false;
1666                      case 0x08ul:
1667                          return false;
1668                      case 0x09ul:
1669                          return false;
1670                      case 0x0Aul:
1671                          return false;
1672                      case 0x0Bul:
1673                          return false;
1674                      case 0x0Cul:
1675                          return false;
1676                      case 0x0Dul:
1677                          return false;
1678                  }
1679              }
1680          #endif
1681          return false;
1682      #endif
1683  }
1684  static bool nrf51_errata_36(void)
1685  {
1686      #ifndef NRF51_SERIES
1687          return false;
1688      #else
1689          #if defined (NRF51422_XXAA) || defined (DEVELOP_IN_NRF51422)\
1690           || defined (NRF51422_XXAB) || defined (DEVELOP_IN_NRF51422)\
1691           || defined (NRF51422_XXAC) || defined (DEVELOP_IN_NRF51422)
1692              uint32_t var1 = ((*(uint32_t *)0xF0000FE0ul) & 0x000000FFul);
1693              uint32_t var2 = ((*(uint32_t *)0xF0000FE8ul) & 0x000000F0ul) >> 4;
1694          #endif
1695          #if defined (NRF51422_XXAA) || defined (DEVELOP_IN_NRF51422)\
1696           || defined (NRF51422_XXAB) || defined (DEVELOP_IN_NRF51422)\
1697           || defined (NRF51422_XXAC) || defined (DEVELOP_IN_NRF51422)
1698              if (var1 == 0x01)
1699              {
1700                  switch(var2)
1701                  {
1702                      case 0x00ul:
1703                          return true;
1704                      case 0x01ul:
1705                          return true;
1706                      case 0x02ul:
1707                          return false;
1708                      case 0x03ul:
1709                          return true;
1710                      case 0x04ul:
1711                          return false;
1712                      case 0x07ul:
1713                          return false;
1714                      case 0x08ul:
1715                          return false;
1716                      case 0x09ul:
1717                          return false;
1718                      case 0x0Aul:
1719                          return false;
1720                      case 0x0Bul:
1721                          return false;
1722                      case 0x0Cul:
1723                          return false;
1724                      case 0x0Dul:
1725                          return false;
1726                  }
1727              }
1728          #endif
1729          return false;
1730      #endif
1731  }
1732  static bool nrf51_errata_37(void)
1733  {
1734      #ifndef NRF51_SERIES
1735          return false;
1736      #else
1737          #if defined (NRF51422_XXAA) || defined (DEVELOP_IN_NRF51422)\
1738           || defined (NRF51422_XXAB) || defined (DEVELOP_IN_NRF51422)\
1739           || defined (NRF51422_XXAC) || defined (DEVELOP_IN_NRF51422)
1740              uint32_t var1 = ((*(uint32_t *)0xF0000FE0ul) & 0x000000FFul);
1741              uint32_t var2 = ((*(uint32_t *)0xF0000FE8ul) & 0x000000F0ul) >> 4;
1742          #endif
1743          #if defined (NRF51422_XXAA) || defined (DEVELOP_IN_NRF51422)\
1744           || defined (NRF51422_XXAB) || defined (DEVELOP_IN_NRF51422)\
1745           || defined (NRF51422_XXAC) || defined (DEVELOP_IN_NRF51422)
1746              if (var1 == 0x01)
1747              {
1748                  switch(var2)
1749                  {
1750                      case 0x00ul:
1751                          return true;
1752                      case 0x01ul:
1753                          return true;
1754                      case 0x02ul:
1755                          return false;
1756                      case 0x03ul:
1757                          return true;
1758                      case 0x04ul:
1759                          return false;
1760                      case 0x07ul:
1761                          return false;
1762                      case 0x08ul:
1763                          return false;
1764                      case 0x09ul:
1765                          return false;
1766                      case 0x0Aul:
1767                          return false;
1768                      case 0x0Bul:
1769                          return false;
1770                      case 0x0Cul:
1771                          return false;
1772                      case 0x0Dul:
1773                          return false;
1774                  }
1775              }
1776          #endif
1777          return false;
1778      #endif
1779  }
1780  static bool nrf51_errata_38(void)
1781  {
1782      #ifndef NRF51_SERIES
1783          return false;
1784      #else
1785          #if defined (NRF51422_XXAA) || defined (DEVELOP_IN_NRF51422)\
1786           || defined (NRF51422_XXAB) || defined (DEVELOP_IN_NRF51422)\
1787           || defined (NRF51422_XXAC) || defined (DEVELOP_IN_NRF51422)
1788              uint32_t var1 = ((*(uint32_t *)0xF0000FE0ul) & 0x000000FFul);
1789              uint32_t var2 = ((*(uint32_t *)0xF0000FE8ul) & 0x000000F0ul) >> 4;
1790          #endif
1791          #if defined (NRF51422_XXAA) || defined (DEVELOP_IN_NRF51422)\
1792           || defined (NRF51422_XXAB) || defined (DEVELOP_IN_NRF51422)\
1793           || defined (NRF51422_XXAC) || defined (DEVELOP_IN_NRF51422)
1794              if (var1 == 0x01)
1795              {
1796                  switch(var2)
1797                  {
1798                      case 0x00ul:
1799                          return true;
1800                      case 0x01ul:
1801                          return true;
1802                      case 0x02ul:
1803                          return true;
1804                      case 0x03ul:
1805                          return true;
1806                      case 0x04ul:
1807                          return true;
1808                      case 0x07ul:
1809                          return true;
1810                      case 0x08ul:
1811                          return true;
1812                      case 0x09ul:
1813                          return true;
1814                      case 0x0Aul:
1815                          return true;
1816                      case 0x0Bul:
1817                          return true;
1818                      case 0x0Cul:
1819                          return true;
1820                      case 0x0Dul:
1821                          return true;
1822                  }
1823              }
1824          #endif
1825          return false;
1826      #endif
1827  }
1828  static bool nrf51_errata_39(void)
1829  {
1830      #ifndef NRF51_SERIES
1831          return false;
1832      #else
1833          #if defined (NRF51422_XXAA) || defined (DEVELOP_IN_NRF51422)\
1834           || defined (NRF51422_XXAB) || defined (DEVELOP_IN_NRF51422)\
1835           || defined (NRF51422_XXAC) || defined (DEVELOP_IN_NRF51422)
1836              uint32_t var1 = ((*(uint32_t *)0xF0000FE0ul) & 0x000000FFul);
1837              uint32_t var2 = ((*(uint32_t *)0xF0000FE8ul) & 0x000000F0ul) >> 4;
1838          #endif
1839          #if defined (NRF51422_XXAA) || defined (DEVELOP_IN_NRF51422)\
1840           || defined (NRF51422_XXAB) || defined (DEVELOP_IN_NRF51422)\
1841           || defined (NRF51422_XXAC) || defined (DEVELOP_IN_NRF51422)
1842              if (var1 == 0x01)
1843              {
1844                  switch(var2)
1845                  {
1846                      case 0x00ul:
1847                          return true;
1848                      case 0x01ul:
1849                          return true;
1850                      case 0x02ul:
1851                          return true;
1852                      case 0x03ul:
1853                          return true;
1854                      case 0x04ul:
1855                          return true;
1856                      case 0x07ul:
1857                          return false;
1858                      case 0x08ul:
1859                          return false;
1860                      case 0x09ul:
1861                          return false;
1862                      case 0x0Aul:
1863                          return false;
1864                      case 0x0Bul:
1865                          return false;
1866                      case 0x0Cul:
1867                          return false;
1868                      case 0x0Dul:
1869                          return false;
1870                  }
1871              }
1872          #endif
1873          return false;
1874      #endif
1875  }
1876  static bool nrf51_errata_40(void)
1877  {
1878      #ifndef NRF51_SERIES
1879          return false;
1880      #else
1881          #if defined (NRF51422_XXAA) || defined (DEVELOP_IN_NRF51422)\
1882           || defined (NRF51422_XXAB) || defined (DEVELOP_IN_NRF51422)\
1883           || defined (NRF51422_XXAC) || defined (DEVELOP_IN_NRF51422)
1884              uint32_t var1 = ((*(uint32_t *)0xF0000FE0ul) & 0x000000FFul);
1885              uint32_t var2 = ((*(uint32_t *)0xF0000FE8ul) & 0x000000F0ul) >> 4;
1886          #endif
1887          #if defined (NRF51422_XXAA) || defined (DEVELOP_IN_NRF51422)\
1888           || defined (NRF51422_XXAB) || defined (DEVELOP_IN_NRF51422)\
1889           || defined (NRF51422_XXAC) || defined (DEVELOP_IN_NRF51422)
1890              if (var1 == 0x01)
1891              {
1892                  switch(var2)
1893                  {
1894                      case 0x00ul:
1895                          return true;
1896                      case 0x01ul:
1897                          return true;
1898                      case 0x02ul:
1899                          return true;
1900                      case 0x03ul:
1901                          return true;
1902                      case 0x04ul:
1903                          return true;
1904                      case 0x07ul:
1905                          return false;
1906                      case 0x08ul:
1907                          return false;
1908                      case 0x09ul:
1909                          return false;
1910                      case 0x0Aul:
1911                          return false;
1912                      case 0x0Bul:
1913                          return false;
1914                      case 0x0Cul:
1915                          return false;
1916                      case 0x0Dul:
1917                          return false;
1918                  }
1919              }
1920          #endif
1921          return false;
1922      #endif
1923  }
1924  static bool nrf51_errata_41(void)
1925  {
1926      #ifndef NRF51_SERIES
1927          return false;
1928      #else
1929          #if defined (NRF51422_XXAA) || defined (DEVELOP_IN_NRF51422)\
1930           || defined (NRF51422_XXAB) || defined (DEVELOP_IN_NRF51422)\
1931           || defined (NRF51422_XXAC) || defined (DEVELOP_IN_NRF51422)
1932              uint32_t var1 = ((*(uint32_t *)0xF0000FE0ul) & 0x000000FFul);
1933              uint32_t var2 = ((*(uint32_t *)0xF0000FE8ul) & 0x000000F0ul) >> 4;
1934          #endif
1935          #if defined (NRF51422_XXAA) || defined (DEVELOP_IN_NRF51422)\
1936           || defined (NRF51422_XXAB) || defined (DEVELOP_IN_NRF51422)\
1937           || defined (NRF51422_XXAC) || defined (DEVELOP_IN_NRF51422)
1938              if (var1 == 0x01)
1939              {
1940                  switch(var2)
1941                  {
1942                      case 0x00ul:
1943                          return true;
1944                      case 0x01ul:
1945                          return true;
1946                      case 0x02ul:
1947                          return true;
1948                      case 0x03ul:
1949                          return true;
1950                      case 0x04ul:
1951                          return true;
1952                      case 0x07ul:
1953                          return false;
1954                      case 0x08ul:
1955                          return false;
1956                      case 0x09ul:
1957                          return false;
1958                      case 0x0Aul:
1959                          return false;
1960                      case 0x0Bul:
1961                          return false;
1962                      case 0x0Cul:
1963                          return false;
1964                      case 0x0Dul:
1965                          return false;
1966                  }
1967              }
1968          #endif
1969          return false;
1970      #endif
1971  }
1972  static bool nrf51_errata_42(void)
1973  {
1974      #ifndef NRF51_SERIES
1975          return false;
1976      #else
1977          #if defined (NRF51422_XXAA) || defined (DEVELOP_IN_NRF51422)\
1978           || defined (NRF51422_XXAB) || defined (DEVELOP_IN_NRF51422)\
1979           || defined (NRF51422_XXAC) || defined (DEVELOP_IN_NRF51422)
1980              uint32_t var1 = ((*(uint32_t *)0xF0000FE0ul) & 0x000000FFul);
1981              uint32_t var2 = ((*(uint32_t *)0xF0000FE8ul) & 0x000000F0ul) >> 4;
1982          #endif
1983          #if defined (NRF51422_XXAA) || defined (DEVELOP_IN_NRF51422)\
1984           || defined (NRF51422_XXAB) || defined (DEVELOP_IN_NRF51422)\
1985           || defined (NRF51422_XXAC) || defined (DEVELOP_IN_NRF51422)
1986              if (var1 == 0x01)
1987              {
1988                  switch(var2)
1989                  {
1990                      case 0x00ul:
1991                          return true;
1992                      case 0x01ul:
1993                          return true;
1994                      case 0x02ul:
1995                          return true;
1996                      case 0x03ul:
1997                          return true;
1998                      case 0x04ul:
1999                          return true;
2000                      case 0x07ul:
2001                          return false;
2002                      case 0x08ul:
2003                          return false;
2004                      case 0x09ul:
2005                          return false;
2006                      case 0x0Aul:
2007                          return false;
2008                      case 0x0Bul:
2009                          return false;
2010                      case 0x0Cul:
2011                          return false;
2012                      case 0x0Dul:
2013                          return false;
2014                  }
2015              }
2016          #endif
2017          return false;
2018      #endif
2019  }
2020  static bool nrf51_errata_43(void)
2021  {
2022      #ifndef NRF51_SERIES
2023          return false;
2024      #else
2025          #if defined (NRF51422_XXAA) || defined (DEVELOP_IN_NRF51422)\
2026           || defined (NRF51422_XXAB) || defined (DEVELOP_IN_NRF51422)\
2027           || defined (NRF51422_XXAC) || defined (DEVELOP_IN_NRF51422)
2028              uint32_t var1 = ((*(uint32_t *)0xF0000FE0ul) & 0x000000FFul);
2029              uint32_t var2 = ((*(uint32_t *)0xF0000FE8ul) & 0x000000F0ul) >> 4;
2030          #endif
2031          #if defined (NRF51422_XXAA) || defined (DEVELOP_IN_NRF51422)\
2032           || defined (NRF51422_XXAB) || defined (DEVELOP_IN_NRF51422)\
2033           || defined (NRF51422_XXAC) || defined (DEVELOP_IN_NRF51422)
2034              if (var1 == 0x01)
2035              {
2036                  switch(var2)
2037                  {
2038                      case 0x00ul:
2039                          return false;
2040                      case 0x01ul:
2041                          return false;
2042                      case 0x02ul:
2043                          return true;
2044                      case 0x03ul:
2045                          return false;
2046                      case 0x04ul:
2047                          return true;
2048                      case 0x07ul:
2049                          return false;
2050                      case 0x08ul:
2051                          return false;
2052                      case 0x09ul:
2053                          return false;
2054                      case 0x0Aul:
2055                          return false;
2056                      case 0x0Bul:
2057                          return false;
2058                      case 0x0Cul:
2059                          return false;
2060                      case 0x0Dul:
2061                          return false;
2062                  }
2063              }
2064          #endif
2065          return false;
2066      #endif
2067  }
2068  static bool nrf51_errata_44(void)
2069  {
2070      #ifndef NRF51_SERIES
2071          return false;
2072      #else
2073          #if defined (NRF51422_XXAA) || defined (DEVELOP_IN_NRF51422)\
2074           || defined (NRF51422_XXAB) || defined (DEVELOP_IN_NRF51422)\
2075           || defined (NRF51422_XXAC) || defined (DEVELOP_IN_NRF51422)
2076              uint32_t var1 = ((*(uint32_t *)0xF0000FE0ul) & 0x000000FFul);
2077              uint32_t var2 = ((*(uint32_t *)0xF0000FE8ul) & 0x000000F0ul) >> 4;
2078          #endif
2079          #if defined (NRF51422_XXAA) || defined (DEVELOP_IN_NRF51422)\
2080           || defined (NRF51422_XXAB) || defined (DEVELOP_IN_NRF51422)\
2081           || defined (NRF51422_XXAC) || defined (DEVELOP_IN_NRF51422)
2082              if (var1 == 0x01)
2083              {
2084                  switch(var2)
2085                  {
2086                      case 0x00ul:
2087                          return true;
2088                      case 0x01ul:
2089                          return true;
2090                      case 0x02ul:
2091                          return true;
2092                      case 0x03ul:
2093                          return true;
2094                      case 0x04ul:
2095                          return true;
2096                      case 0x07ul:
2097                          return false;
2098                      case 0x08ul:
2099                          return false;
2100                      case 0x09ul:
2101                          return false;
2102                      case 0x0Aul:
2103                          return false;
2104                      case 0x0Bul:
2105                          return false;
2106                      case 0x0Cul:
2107                          return false;
2108                      case 0x0Dul:
2109                          return false;
2110                  }
2111              }
2112          #endif
2113          return false;
2114      #endif
2115  }
2116  static bool nrf51_errata_45(void)
2117  {
2118      #ifndef NRF51_SERIES
2119          return false;
2120      #else
2121          #if defined (NRF51422_XXAA) || defined (DEVELOP_IN_NRF51422)\
2122           || defined (NRF51422_XXAB) || defined (DEVELOP_IN_NRF51422)\
2123           || defined (NRF51422_XXAC) || defined (DEVELOP_IN_NRF51422)
2124              uint32_t var1 = ((*(uint32_t *)0xF0000FE0ul) & 0x000000FFul);
2125              uint32_t var2 = ((*(uint32_t *)0xF0000FE8ul) & 0x000000F0ul) >> 4;
2126          #endif
2127          #if defined (NRF51422_XXAA) || defined (DEVELOP_IN_NRF51422)\
2128           || defined (NRF51422_XXAB) || defined (DEVELOP_IN_NRF51422)\
2129           || defined (NRF51422_XXAC) || defined (DEVELOP_IN_NRF51422)
2130              if (var1 == 0x01)
2131              {
2132                  switch(var2)
2133                  {
2134                      case 0x00ul:
2135                          return true;
2136                      case 0x01ul:
2137                          return true;
2138                      case 0x02ul:
2139                          return true;
2140                      case 0x03ul:
2141                          return true;
2142                      case 0x04ul:
2143                          return true;
2144                      case 0x07ul:
2145                          return false;
2146                      case 0x08ul:
2147                          return false;
2148                      case 0x09ul:
2149                          return false;
2150                      case 0x0Aul:
2151                          return false;
2152                      case 0x0Bul:
2153                          return false;
2154                      case 0x0Cul:
2155                          return false;
2156                      case 0x0Dul:
2157                          return false;
2158                  }
2159              }
2160          #endif
2161          return false;
2162      #endif
2163  }
2164  static bool nrf51_errata_46(void)
2165  {
2166      #ifndef NRF51_SERIES
2167          return false;
2168      #else
2169          #if defined (NRF51422_XXAA) || defined (DEVELOP_IN_NRF51422)\
2170           || defined (NRF51422_XXAB) || defined (DEVELOP_IN_NRF51422)\
2171           || defined (NRF51422_XXAC) || defined (DEVELOP_IN_NRF51422)
2172              uint32_t var1 = ((*(uint32_t *)0xF0000FE0ul) & 0x000000FFul);
2173              uint32_t var2 = ((*(uint32_t *)0xF0000FE8ul) & 0x000000F0ul) >> 4;
2174          #endif
2175          #if defined (NRF51422_XXAA) || defined (DEVELOP_IN_NRF51422)\
2176           || defined (NRF51422_XXAB) || defined (DEVELOP_IN_NRF51422)\
2177           || defined (NRF51422_XXAC) || defined (DEVELOP_IN_NRF51422)
2178              if (var1 == 0x01)
2179              {
2180                  switch(var2)
2181                  {
2182                      case 0x00ul:
2183                          return false;
2184                      case 0x01ul:
2185                          return false;
2186                      case 0x02ul:
2187                          return true;
2188                      case 0x03ul:
2189                          return false;
2190                      case 0x04ul:
2191                          return true;
2192                      case 0x07ul:
2193                          return true;
2194                      case 0x08ul:
2195                          return true;
2196                      case 0x09ul:
2197                          return true;
2198                      case 0x0Aul:
2199                          return false;
2200                      case 0x0Bul:
2201                          return true;
2202                      case 0x0Cul:
2203                          return true;
2204                      case 0x0Dul:
2205                          return false;
2206                  }
2207              }
2208          #endif
2209          return false;
2210      #endif
2211  }
2212  static bool nrf51_errata_47(void)
2213  {
2214      #ifndef NRF51_SERIES
2215          return false;
2216      #else
2217          #if defined (NRF51422_XXAA) || defined (DEVELOP_IN_NRF51422)\
2218           || defined (NRF51422_XXAB) || defined (DEVELOP_IN_NRF51422)\
2219           || defined (NRF51422_XXAC) || defined (DEVELOP_IN_NRF51422)
2220              uint32_t var1 = ((*(uint32_t *)0xF0000FE0ul) & 0x000000FFul);
2221              uint32_t var2 = ((*(uint32_t *)0xF0000FE8ul) & 0x000000F0ul) >> 4;
2222          #endif
2223          #if defined (NRF51422_XXAA) || defined (DEVELOP_IN_NRF51422)\
2224           || defined (NRF51422_XXAB) || defined (DEVELOP_IN_NRF51422)\
2225           || defined (NRF51422_XXAC) || defined (DEVELOP_IN_NRF51422)
2226              if (var1 == 0x01)
2227              {
2228                  switch(var2)
2229                  {
2230                      case 0x00ul:
2231                          return true;
2232                      case 0x01ul:
2233                          return true;
2234                      case 0x02ul:
2235                          return true;
2236                      case 0x03ul:
2237                          return true;
2238                      case 0x04ul:
2239                          return true;
2240                      case 0x07ul:
2241                          return false;
2242                      case 0x08ul:
2243                          return false;
2244                      case 0x09ul:
2245                          return false;
2246                      case 0x0Aul:
2247                          return false;
2248                      case 0x0Bul:
2249                          return false;
2250                      case 0x0Cul:
2251                          return false;
2252                      case 0x0Dul:
2253                          return false;
2254                  }
2255              }
2256          #endif
2257          return false;
2258      #endif
2259  }
2260  static bool nrf51_errata_48(void)
2261  {
2262      #ifndef NRF51_SERIES
2263          return false;
2264      #else
2265          #if defined (NRF51422_XXAA) || defined (DEVELOP_IN_NRF51422)\
2266           || defined (NRF51422_XXAB) || defined (DEVELOP_IN_NRF51422)\
2267           || defined (NRF51422_XXAC) || defined (DEVELOP_IN_NRF51422)
2268              uint32_t var1 = ((*(uint32_t *)0xF0000FE0ul) & 0x000000FFul);
2269              uint32_t var2 = ((*(uint32_t *)0xF0000FE8ul) & 0x000000F0ul) >> 4;
2270          #endif
2271          #if defined (NRF51422_XXAA) || defined (DEVELOP_IN_NRF51422)\
2272           || defined (NRF51422_XXAB) || defined (DEVELOP_IN_NRF51422)\
2273           || defined (NRF51422_XXAC) || defined (DEVELOP_IN_NRF51422)
2274              if (var1 == 0x01)
2275              {
2276                  switch(var2)
2277                  {
2278                      case 0x00ul:
2279                          return true;
2280                      case 0x01ul:
2281                          return true;
2282                      case 0x02ul:
2283                          return true;
2284                      case 0x03ul:
2285                          return true;
2286                      case 0x04ul:
2287                          return true;
2288                      case 0x07ul:
2289                          return false;
2290                      case 0x08ul:
2291                          return false;
2292                      case 0x09ul:
2293                          return false;
2294                      case 0x0Aul:
2295                          return false;
2296                      case 0x0Bul:
2297                          return false;
2298                      case 0x0Cul:
2299                          return false;
2300                      case 0x0Dul:
2301                          return false;
2302                  }
2303              }
2304          #endif
2305          return false;
2306      #endif
2307  }
2308  static bool nrf51_errata_49(void)
2309  {
2310      #ifndef NRF51_SERIES
2311          return false;
2312      #else
2313          #if defined (NRF51422_XXAA) || defined (DEVELOP_IN_NRF51422)\
2314           || defined (NRF51422_XXAB) || defined (DEVELOP_IN_NRF51422)\
2315           || defined (NRF51422_XXAC) || defined (DEVELOP_IN_NRF51422)
2316              uint32_t var1 = ((*(uint32_t *)0xF0000FE0ul) & 0x000000FFul);
2317              uint32_t var2 = ((*(uint32_t *)0xF0000FE8ul) & 0x000000F0ul) >> 4;
2318          #endif
2319          #if defined (NRF51422_XXAA) || defined (DEVELOP_IN_NRF51422)\
2320           || defined (NRF51422_XXAB) || defined (DEVELOP_IN_NRF51422)\
2321           || defined (NRF51422_XXAC) || defined (DEVELOP_IN_NRF51422)
2322              if (var1 == 0x01)
2323              {
2324                  switch(var2)
2325                  {
2326                      case 0x00ul:
2327                          return false;
2328                      case 0x01ul:
2329                          return false;
2330                      case 0x02ul:
2331                          return true;
2332                      case 0x03ul:
2333                          return false;
2334                      case 0x04ul:
2335                          return true;
2336                      case 0x07ul:
2337                          return false;
2338                      case 0x08ul:
2339                          return false;
2340                      case 0x09ul:
2341                          return false;
2342                      case 0x0Aul:
2343                          return false;
2344                      case 0x0Bul:
2345                          return false;
2346                      case 0x0Cul:
2347                          return false;
2348                      case 0x0Dul:
2349                          return false;
2350                  }
2351              }
2352          #endif
2353          return false;
2354      #endif
2355  }
2356  static bool nrf51_errata_50(void)
2357  {
2358      #ifndef NRF51_SERIES
2359          return false;
2360      #else
2361          return false;
2362      #endif
2363  }
2364  static bool nrf51_errata_51(void)
2365  {
2366      #ifndef NRF51_SERIES
2367          return false;
2368      #else
2369          return false;
2370      #endif
2371  }
2372  static bool nrf51_errata_52(void)
2373  {
2374      #ifndef NRF51_SERIES
2375          return false;
2376      #else
2377          return false;
2378      #endif
2379  }
2380  static bool nrf51_errata_53(void)
2381  {
2382      #ifndef NRF51_SERIES
2383          return false;
2384      #else
2385          return false;
2386      #endif
2387  }
2388  static bool nrf51_errata_54(void)
2389  {
2390      #ifndef NRF51_SERIES
2391          return false;
2392      #else
2393          return false;
2394      #endif
2395  }
2396  static bool nrf51_errata_55(void)
2397  {
2398      #ifndef NRF51_SERIES
2399          return false;
2400      #else
2401          #if defined (NRF51422_XXAA) || defined (DEVELOP_IN_NRF51422)\
2402           || defined (NRF51422_XXAB) || defined (DEVELOP_IN_NRF51422)\
2403           || defined (NRF51422_XXAC) || defined (DEVELOP_IN_NRF51422)
2404              uint32_t var1 = ((*(uint32_t *)0xF0000FE0ul) & 0x000000FFul);
2405              uint32_t var2 = ((*(uint32_t *)0xF0000FE8ul) & 0x000000F0ul) >> 4;
2406          #endif
2407          #if defined (NRF51422_XXAA) || defined (DEVELOP_IN_NRF51422)\
2408           || defined (NRF51422_XXAB) || defined (DEVELOP_IN_NRF51422)\
2409           || defined (NRF51422_XXAC) || defined (DEVELOP_IN_NRF51422)
2410              if (var1 == 0x01)
2411              {
2412                  switch(var2)
2413                  {
2414                      case 0x00ul:
2415                          return true;
2416                      case 0x01ul:
2417                          return true;
2418                      case 0x02ul:
2419                          return false;
2420                      case 0x03ul:
2421                          return true;
2422                      case 0x04ul:
2423                          return false;
2424                      case 0x07ul:
2425                          return false;
2426                      case 0x08ul:
2427                          return false;
2428                      case 0x09ul:
2429                          return false;
2430                      case 0x0Aul:
2431                          return false;
2432                      case 0x0Bul:
2433                          return false;
2434                      case 0x0Cul:
2435                          return false;
2436                      case 0x0Dul:
2437                          return false;
2438                  }
2439              }
2440          #endif
2441          return false;
2442      #endif
2443  }
2444  static bool nrf51_errata_56(void)
2445  {
2446      #ifndef NRF51_SERIES
2447          return false;
2448      #else
2449          #if defined (NRF51422_XXAA) || defined (DEVELOP_IN_NRF51422)\
2450           || defined (NRF51422_XXAB) || defined (DEVELOP_IN_NRF51422)\
2451           || defined (NRF51422_XXAC) || defined (DEVELOP_IN_NRF51422)
2452              uint32_t var1 = ((*(uint32_t *)0xF0000FE0ul) & 0x000000FFul);
2453              uint32_t var2 = ((*(uint32_t *)0xF0000FE8ul) & 0x000000F0ul) >> 4;
2454          #endif
2455          #if defined (NRF51422_XXAA) || defined (DEVELOP_IN_NRF51422)\
2456           || defined (NRF51422_XXAB) || defined (DEVELOP_IN_NRF51422)\
2457           || defined (NRF51422_XXAC) || defined (DEVELOP_IN_NRF51422)
2458              if (var1 == 0x01)
2459              {
2460                  switch(var2)
2461                  {
2462                      case 0x00ul:
2463                          return true;
2464                      case 0x01ul:
2465                          return true;
2466                      case 0x02ul:
2467                          return true;
2468                      case 0x03ul:
2469                          return true;
2470                      case 0x04ul:
2471                          return true;
2472                      case 0x07ul:
2473                          return false;
2474                      case 0x08ul:
2475                          return false;
2476                      case 0x09ul:
2477                          return false;
2478                      case 0x0Aul:
2479                          return false;
2480                      case 0x0Bul:
2481                          return false;
2482                      case 0x0Cul:
2483                          return false;
2484                      case 0x0Dul:
2485                          return false;
2486                  }
2487              }
2488          #endif
2489          return false;
2490      #endif
2491  }
2492  static bool nrf51_errata_57(void)
2493  {
2494      #ifndef NRF51_SERIES
2495          return false;
2496      #else
2497          #if defined (NRF51422_XXAA) || defined (DEVELOP_IN_NRF51422)\
2498           || defined (NRF51422_XXAB) || defined (DEVELOP_IN_NRF51422)\
2499           || defined (NRF51422_XXAC) || defined (DEVELOP_IN_NRF51422)
2500              uint32_t var1 = ((*(uint32_t *)0xF0000FE0ul) & 0x000000FFul);
2501              uint32_t var2 = ((*(uint32_t *)0xF0000FE8ul) & 0x000000F0ul) >> 4;
2502          #endif
2503          #if defined (NRF51422_XXAA) || defined (DEVELOP_IN_NRF51422)\
2504           || defined (NRF51422_XXAB) || defined (DEVELOP_IN_NRF51422)\
2505           || defined (NRF51422_XXAC) || defined (DEVELOP_IN_NRF51422)
2506              if (var1 == 0x01)
2507              {
2508                  switch(var2)
2509                  {
2510                      case 0x00ul:
2511                          return true;
2512                      case 0x01ul:
2513                          return true;
2514                      case 0x02ul:
2515                          return true;
2516                      case 0x03ul:
2517                          return true;
2518                      case 0x04ul:
2519                          return true;
2520                      case 0x07ul:
2521                          return false;
2522                      case 0x08ul:
2523                          return false;
2524                      case 0x09ul:
2525                          return false;
2526                      case 0x0Aul:
2527                          return false;
2528                      case 0x0Bul:
2529                          return false;
2530                      case 0x0Cul:
2531                          return false;
2532                      case 0x0Dul:
2533                          return false;
2534                  }
2535              }
2536          #endif
2537          return false;
2538      #endif
2539  }
2540  static bool nrf51_errata_58(void)
2541  {
2542      #ifndef NRF51_SERIES
2543          return false;
2544      #else
2545          #if defined (NRF51422_XXAA) || defined (DEVELOP_IN_NRF51422)\
2546           || defined (NRF51422_XXAB) || defined (DEVELOP_IN_NRF51422)\
2547           || defined (NRF51422_XXAC) || defined (DEVELOP_IN_NRF51422)
2548              uint32_t var1 = ((*(uint32_t *)0xF0000FE0ul) & 0x000000FFul);
2549              uint32_t var2 = ((*(uint32_t *)0xF0000FE8ul) & 0x000000F0ul) >> 4;
2550          #endif
2551          #if defined (NRF51422_XXAA) || defined (DEVELOP_IN_NRF51422)\
2552           || defined (NRF51422_XXAB) || defined (DEVELOP_IN_NRF51422)\
2553           || defined (NRF51422_XXAC) || defined (DEVELOP_IN_NRF51422)
2554              if (var1 == 0x01)
2555              {
2556                  switch(var2)
2557                  {
2558                      case 0x00ul:
2559                          return false;
2560                      case 0x01ul:
2561                          return false;
2562                      case 0x02ul:
2563                          return true;
2564                      case 0x03ul:
2565                          return false;
2566                      case 0x04ul:
2567                          return true;
2568                      case 0x07ul:
2569                          return false;
2570                      case 0x08ul:
2571                          return false;
2572                      case 0x09ul:
2573                          return false;
2574                      case 0x0Aul:
2575                          return false;
2576                      case 0x0Bul:
2577                          return false;
2578                      case 0x0Cul:
2579                          return false;
2580                      case 0x0Dul:
2581                          return false;
2582                  }
2583              }
2584          #endif
2585          return false;
2586      #endif
2587  }
2588  static bool nrf51_errata_59(void)
2589  {
2590      #ifndef NRF51_SERIES
2591          return false;
2592      #else
2593          #if defined (NRF51422_XXAA) || defined (DEVELOP_IN_NRF51422)\
2594           || defined (NRF51422_XXAB) || defined (DEVELOP_IN_NRF51422)\
2595           || defined (NRF51422_XXAC) || defined (DEVELOP_IN_NRF51422)
2596              uint32_t var1 = ((*(uint32_t *)0xF0000FE0ul) & 0x000000FFul);
2597              uint32_t var2 = ((*(uint32_t *)0xF0000FE8ul) & 0x000000F0ul) >> 4;
2598          #endif
2599          #if defined (NRF51422_XXAA) || defined (DEVELOP_IN_NRF51422)\
2600           || defined (NRF51422_XXAB) || defined (DEVELOP_IN_NRF51422)\
2601           || defined (NRF51422_XXAC) || defined (DEVELOP_IN_NRF51422)
2602              if (var1 == 0x01)
2603              {
2604                  switch(var2)
2605                  {
2606                      case 0x00ul:
2607                          return false;
2608                      case 0x01ul:
2609                          return false;
2610                      case 0x02ul:
2611                          return true;
2612                      case 0x03ul:
2613                          return false;
2614                      case 0x04ul:
2615                          return true;
2616                      case 0x07ul:
2617                          return false;
2618                      case 0x08ul:
2619                          return false;
2620                      case 0x09ul:
2621                          return false;
2622                      case 0x0Aul:
2623                          return false;
2624                      case 0x0Bul:
2625                          return false;
2626                      case 0x0Cul:
2627                          return false;
2628                      case 0x0Dul:
2629                          return false;
2630                  }
2631              }
2632          #endif
2633          return false;
2634      #endif
2635  }
2636  static bool nrf51_errata_60(void)
2637  {
2638      #ifndef NRF51_SERIES
2639          return false;
2640      #else
2641          #if defined (NRF51422_XXAA) || defined (DEVELOP_IN_NRF51422)\
2642           || defined (NRF51422_XXAB) || defined (DEVELOP_IN_NRF51422)\
2643           || defined (NRF51422_XXAC) || defined (DEVELOP_IN_NRF51422)
2644              uint32_t var1 = ((*(uint32_t *)0xF0000FE0ul) & 0x000000FFul);
2645              uint32_t var2 = ((*(uint32_t *)0xF0000FE8ul) & 0x000000F0ul) >> 4;
2646          #endif
2647          #if defined (NRF51422_XXAA) || defined (DEVELOP_IN_NRF51422)\
2648           || defined (NRF51422_XXAB) || defined (DEVELOP_IN_NRF51422)\
2649           || defined (NRF51422_XXAC) || defined (DEVELOP_IN_NRF51422)
2650              if (var1 == 0x01)
2651              {
2652                  switch(var2)
2653                  {
2654                      case 0x00ul:
2655                          return false;
2656                      case 0x01ul:
2657                          return false;
2658                      case 0x02ul:
2659                          return true;
2660                      case 0x03ul:
2661                          return false;
2662                      case 0x04ul:
2663                          return true;
2664                      case 0x07ul:
2665                          return false;
2666                      case 0x08ul:
2667                          return false;
2668                      case 0x09ul:
2669                          return false;
2670                      case 0x0Aul:
2671                          return false;
2672                      case 0x0Bul:
2673                          return false;
2674                      case 0x0Cul:
2675                          return false;
2676                      case 0x0Dul:
2677                          return false;
2678                  }
2679              }
2680          #endif
2681          return false;
2682      #endif
2683  }
2684  static bool nrf51_errata_61(void)
2685  {
2686      #ifndef NRF51_SERIES
2687          return false;
2688      #else
2689          #if defined (NRF51422_XXAA) || defined (DEVELOP_IN_NRF51422)\
2690           || defined (NRF51422_XXAB) || defined (DEVELOP_IN_NRF51422)\
2691           || defined (NRF51422_XXAC) || defined (DEVELOP_IN_NRF51422)
2692              uint32_t var1 = ((*(uint32_t *)0xF0000FE0ul) & 0x000000FFul);
2693              uint32_t var2 = ((*(uint32_t *)0xF0000FE8ul) & 0x000000F0ul) >> 4;
2694          #endif
2695          #if defined (NRF51422_XXAA) || defined (DEVELOP_IN_NRF51422)\
2696           || defined (NRF51422_XXAB) || defined (DEVELOP_IN_NRF51422)\
2697           || defined (NRF51422_XXAC) || defined (DEVELOP_IN_NRF51422)
2698              if (var1 == 0x01)
2699              {
2700                  switch(var2)
2701                  {
2702                      case 0x00ul:
2703                          return false;
2704                      case 0x01ul:
2705                          return false;
2706                      case 0x02ul:
2707                          return true;
2708                      case 0x03ul:
2709                          return false;
2710                      case 0x04ul:
2711                          return true;
2712                      case 0x07ul:
2713                          return true;
2714                      case 0x08ul:
2715                          return true;
2716                      case 0x09ul:
2717                          return true;
2718                      case 0x0Aul:
2719                          return true;
2720                      case 0x0Bul:
2721                          return true;
2722                      case 0x0Cul:
2723                          return true;
2724                      case 0x0Dul:
2725                          return true;
2726                  }
2727              }
2728          #endif
2729          return false;
2730      #endif
2731  }
2732  static bool nrf51_errata_62(void)
2733  {
2734      #ifndef NRF51_SERIES
2735          return false;
2736      #else
2737          #if defined (NRF51422_XXAA) || defined (DEVELOP_IN_NRF51422)\
2738           || defined (NRF51422_XXAB) || defined (DEVELOP_IN_NRF51422)\
2739           || defined (NRF51422_XXAC) || defined (DEVELOP_IN_NRF51422)
2740              uint32_t var1 = ((*(uint32_t *)0xF0000FE0ul) & 0x000000FFul);
2741              uint32_t var2 = ((*(uint32_t *)0xF0000FE8ul) & 0x000000F0ul) >> 4;
2742          #endif
2743          #if defined (NRF51422_XXAA) || defined (DEVELOP_IN_NRF51422)\
2744           || defined (NRF51422_XXAB) || defined (DEVELOP_IN_NRF51422)\
2745           || defined (NRF51422_XXAC) || defined (DEVELOP_IN_NRF51422)
2746              if (var1 == 0x01)
2747              {
2748                  switch(var2)
2749                  {
2750                      case 0x00ul:
2751                          return false;
2752                      case 0x01ul:
2753                          return false;
2754                      case 0x02ul:
2755                          return true;
2756                      case 0x03ul:
2757                          return false;
2758                      case 0x04ul:
2759                          return true;
2760                      case 0x07ul:
2761                          return false;
2762                      case 0x08ul:
2763                          return false;
2764                      case 0x09ul:
2765                          return false;
2766                      case 0x0Aul:
2767                          return false;
2768                      case 0x0Bul:
2769                          return false;
2770                      case 0x0Cul:
2771                          return false;
2772                      case 0x0Dul:
2773                          return false;
2774                  }
2775              }
2776          #endif
2777          return false;
2778      #endif
2779  }
2780  static bool nrf51_errata_63(void)
2781  {
2782      #ifndef NRF51_SERIES
2783          return false;
2784      #else
2785          #if defined (NRF51422_XXAA) || defined (DEVELOP_IN_NRF51422)\
2786           || defined (NRF51422_XXAB) || defined (DEVELOP_IN_NRF51422)\
2787           || defined (NRF51422_XXAC) || defined (DEVELOP_IN_NRF51422)
2788              uint32_t var1 = ((*(uint32_t *)0xF0000FE0ul) & 0x000000FFul);
2789              uint32_t var2 = ((*(uint32_t *)0xF0000FE8ul) & 0x000000F0ul) >> 4;
2790          #endif
2791          #if defined (NRF51422_XXAA) || defined (DEVELOP_IN_NRF51422)\
2792           || defined (NRF51422_XXAB) || defined (DEVELOP_IN_NRF51422)\
2793           || defined (NRF51422_XXAC) || defined (DEVELOP_IN_NRF51422)
2794              if (var1 == 0x01)
2795              {
2796                  switch(var2)
2797                  {
2798                      case 0x00ul:
2799                          return true;
2800                      case 0x01ul:
2801                          return true;
2802                      case 0x02ul:
2803                          return true;
2804                      case 0x03ul:
2805                          return true;
2806                      case 0x04ul:
2807                          return true;
2808                      case 0x07ul:
2809                          return false;
2810                      case 0x08ul:
2811                          return false;
2812                      case 0x09ul:
2813                          return false;
2814                      case 0x0Aul:
2815                          return false;
2816                      case 0x0Bul:
2817                          return false;
2818                      case 0x0Cul:
2819                          return false;
2820                      case 0x0Dul:
2821                          return false;
2822                  }
2823              }
2824          #endif
2825          return false;
2826      #endif
2827  }
2828  static bool nrf51_errata_64(void)
2829  {
2830      #ifndef NRF51_SERIES
2831          return false;
2832      #else
2833          #if defined (NRF51422_XXAA) || defined (DEVELOP_IN_NRF51422)\
2834           || defined (NRF51422_XXAB) || defined (DEVELOP_IN_NRF51422)\
2835           || defined (NRF51422_XXAC) || defined (DEVELOP_IN_NRF51422)
2836              uint32_t var1 = ((*(uint32_t *)0xF0000FE0ul) & 0x000000FFul);
2837              uint32_t var2 = ((*(uint32_t *)0xF0000FE8ul) & 0x000000F0ul) >> 4;
2838          #endif
2839          #if defined (NRF51422_XXAA) || defined (DEVELOP_IN_NRF51422)\
2840           || defined (NRF51422_XXAB) || defined (DEVELOP_IN_NRF51422)\
2841           || defined (NRF51422_XXAC) || defined (DEVELOP_IN_NRF51422)
2842              if (var1 == 0x01)
2843              {
2844                  switch(var2)
2845                  {
2846                      case 0x00ul:
2847                          return true;
2848                      case 0x01ul:
2849                          return true;
2850                      case 0x02ul:
2851                          return true;
2852                      case 0x03ul:
2853                          return true;
2854                      case 0x04ul:
2855                          return true;
2856                      case 0x07ul:
2857                          return false;
2858                      case 0x08ul:
2859                          return false;
2860                      case 0x09ul:
2861                          return false;
2862                      case 0x0Aul:
2863                          return false;
2864                      case 0x0Bul:
2865                          return false;
2866                      case 0x0Cul:
2867                          return false;
2868                      case 0x0Dul:
2869                          return false;
2870                  }
2871              }
2872          #endif
2873          return false;
2874      #endif
2875  }
2876  static bool nrf51_errata_65(void)
2877  {
2878      #ifndef NRF51_SERIES
2879          return false;
2880      #else
2881          #if defined (NRF51422_XXAA) || defined (DEVELOP_IN_NRF51422)\
2882           || defined (NRF51422_XXAB) || defined (DEVELOP_IN_NRF51422)\
2883           || defined (NRF51422_XXAC) || defined (DEVELOP_IN_NRF51422)
2884              uint32_t var1 = ((*(uint32_t *)0xF0000FE0ul) & 0x000000FFul);
2885              uint32_t var2 = ((*(uint32_t *)0xF0000FE8ul) & 0x000000F0ul) >> 4;
2886          #endif
2887          #if defined (NRF51422_XXAA) || defined (DEVELOP_IN_NRF51422)\
2888           || defined (NRF51422_XXAB) || defined (DEVELOP_IN_NRF51422)\
2889           || defined (NRF51422_XXAC) || defined (DEVELOP_IN_NRF51422)
2890              if (var1 == 0x01)
2891              {
2892                  switch(var2)
2893                  {
2894                      case 0x00ul:
2895                          return true;
2896                      case 0x01ul:
2897                          return true;
2898                      case 0x02ul:
2899                          return true;
2900                      case 0x03ul:
2901                          return true;
2902                      case 0x04ul:
2903                          return true;
2904                      case 0x07ul:
2905                          return false;
2906                      case 0x08ul:
2907                          return false;
2908                      case 0x09ul:
2909                          return false;
2910                      case 0x0Aul:
2911                          return false;
2912                      case 0x0Bul:
2913                          return false;
2914                      case 0x0Cul:
2915                          return false;
2916                      case 0x0Dul:
2917                          return false;
2918                  }
2919              }
2920          #endif
2921          return false;
2922      #endif
2923  }
2924  static bool nrf51_errata_66(void)
2925  {
2926      #ifndef NRF51_SERIES
2927          return false;
2928      #else
2929          #if defined (NRF51422_XXAA) || defined (DEVELOP_IN_NRF51422)\
2930           || defined (NRF51422_XXAB) || defined (DEVELOP_IN_NRF51422)\
2931           || defined (NRF51422_XXAC) || defined (DEVELOP_IN_NRF51422)
2932              uint32_t var1 = ((*(uint32_t *)0xF0000FE0ul) & 0x000000FFul);
2933              uint32_t var2 = ((*(uint32_t *)0xF0000FE8ul) & 0x000000F0ul) >> 4;
2934          #endif
2935          #if defined (NRF51422_XXAA) || defined (DEVELOP_IN_NRF51422)\
2936           || defined (NRF51422_XXAB) || defined (DEVELOP_IN_NRF51422)\
2937           || defined (NRF51422_XXAC) || defined (DEVELOP_IN_NRF51422)
2938              if (var1 == 0x01)
2939              {
2940                  switch(var2)
2941                  {
2942                      case 0x00ul:
2943                          return false;
2944                      case 0x01ul:
2945                          return false;
2946                      case 0x02ul:
2947                          return true;
2948                      case 0x03ul:
2949                          return false;
2950                      case 0x04ul:
2951                          return true;
2952                      case 0x07ul:
2953                          return true;
2954                      case 0x08ul:
2955                          return true;
2956                      case 0x09ul:
2957                          return true;
2958                      case 0x0Aul:
2959                          return false;
2960                      case 0x0Bul:
2961                          return true;
2962                      case 0x0Cul:
2963                          return true;
2964                      case 0x0Dul:
2965                          return false;
2966                  }
2967              }
2968          #endif
2969          return false;
2970      #endif
2971  }
2972  static bool nrf51_errata_67(void)
2973  {
2974      #ifndef NRF51_SERIES
2975          return false;
2976      #else
2977          #if defined (NRF51422_XXAA) || defined (DEVELOP_IN_NRF51422)\
2978           || defined (NRF51422_XXAB) || defined (DEVELOP_IN_NRF51422)\
2979           || defined (NRF51422_XXAC) || defined (DEVELOP_IN_NRF51422)
2980              uint32_t var1 = ((*(uint32_t *)0xF0000FE0ul) & 0x000000FFul);
2981              uint32_t var2 = ((*(uint32_t *)0xF0000FE8ul) & 0x000000F0ul) >> 4;
2982          #endif
2983          #if defined (NRF51422_XXAA) || defined (DEVELOP_IN_NRF51422)\
2984           || defined (NRF51422_XXAB) || defined (DEVELOP_IN_NRF51422)\
2985           || defined (NRF51422_XXAC) || defined (DEVELOP_IN_NRF51422)
2986              if (var1 == 0x01)
2987              {
2988                  switch(var2)
2989                  {
2990                      case 0x00ul:
2991                          return false;
2992                      case 0x01ul:
2993                          return false;
2994                      case 0x02ul:
2995                          return true;
2996                      case 0x03ul:
2997                          return false;
2998                      case 0x04ul:
2999                          return true;
3000                      case 0x07ul:
3001                          return true;
3002                      case 0x08ul:
3003                          return true;
3004                      case 0x09ul:
3005                          return true;
3006                      case 0x0Aul:
3007                          return true;
3008                      case 0x0Bul:
3009                          return true;
3010                      case 0x0Cul:
3011                          return true;
3012                      case 0x0Dul:
3013                          return true;
3014                  }
3015              }
3016          #endif
3017          return false;
3018      #endif
3019  }
3020  static bool nrf51_errata_68(void)
3021  {
3022      #ifndef NRF51_SERIES
3023          return false;
3024      #else
3025          #if defined (NRF51422_XXAA) || defined (DEVELOP_IN_NRF51422)\
3026           || defined (NRF51422_XXAB) || defined (DEVELOP_IN_NRF51422)\
3027           || defined (NRF51422_XXAC) || defined (DEVELOP_IN_NRF51422)
3028              uint32_t var1 = ((*(uint32_t *)0xF0000FE0ul) & 0x000000FFul);
3029              uint32_t var2 = ((*(uint32_t *)0xF0000FE8ul) & 0x000000F0ul) >> 4;
3030          #endif
3031          #if defined (NRF51422_XXAA) || defined (DEVELOP_IN_NRF51422)\
3032           || defined (NRF51422_XXAB) || defined (DEVELOP_IN_NRF51422)\
3033           || defined (NRF51422_XXAC) || defined (DEVELOP_IN_NRF51422)
3034              if (var1 == 0x01)
3035              {
3036                  switch(var2)
3037                  {
3038                      case 0x00ul:
3039                          return false;
3040                      case 0x01ul:
3041                          return false;
3042                      case 0x02ul:
3043                          return true;
3044                      case 0x03ul:
3045                          return false;
3046                      case 0x04ul:
3047                          return true;
3048                      case 0x07ul:
3049                          return false;
3050                      case 0x08ul:
3051                          return false;
3052                      case 0x09ul:
3053                          return false;
3054                      case 0x0Aul:
3055                          return false;
3056                      case 0x0Bul:
3057                          return false;
3058                      case 0x0Cul:
3059                          return false;
3060                      case 0x0Dul:
3061                          return false;
3062                  }
3063              }
3064          #endif
3065          return false;
3066      #endif
3067  }
3068  static bool nrf51_errata_69(void)
3069  {
3070      #ifndef NRF51_SERIES
3071          return false;
3072      #else
3073          #if defined (NRF51422_XXAA) || defined (DEVELOP_IN_NRF51422)\
3074           || defined (NRF51422_XXAB) || defined (DEVELOP_IN_NRF51422)\
3075           || defined (NRF51422_XXAC) || defined (DEVELOP_IN_NRF51422)
3076              uint32_t var1 = ((*(uint32_t *)0xF0000FE0ul) & 0x000000FFul);
3077              uint32_t var2 = ((*(uint32_t *)0xF0000FE8ul) & 0x000000F0ul) >> 4;
3078          #endif
3079          #if defined (NRF51422_XXAA) || defined (DEVELOP_IN_NRF51422)\
3080           || defined (NRF51422_XXAB) || defined (DEVELOP_IN_NRF51422)\
3081           || defined (NRF51422_XXAC) || defined (DEVELOP_IN_NRF51422)
3082              if (var1 == 0x01)
3083              {
3084                  switch(var2)
3085                  {
3086                      case 0x00ul:
3087                          return false;
3088                      case 0x01ul:
3089                          return false;
3090                      case 0x02ul:
3091                          return false;
3092                      case 0x03ul:
3093                          return false;
3094                      case 0x04ul:
3095                          return false;
3096                      case 0x07ul:
3097                          return true;
3098                      case 0x08ul:
3099                          return true;
3100                      case 0x09ul:
3101                          return false;
3102                      case 0x0Aul:
3103                          return false;
3104                      case 0x0Bul:
3105                          return true;
3106                      case 0x0Cul:
3107                          return true;
3108                      case 0x0Dul:
3109                          return false;
3110                  }
3111              }
3112          #endif
3113          return false;
3114      #endif
3115  }
3116  static bool nrf51_errata_70(void)
3117  {
3118      #ifndef NRF51_SERIES
3119          return false;
3120      #else
3121          #if defined (NRF51422_XXAA) || defined (DEVELOP_IN_NRF51422)\
3122           || defined (NRF51422_XXAB) || defined (DEVELOP_IN_NRF51422)\
3123           || defined (NRF51422_XXAC) || defined (DEVELOP_IN_NRF51422)
3124              uint32_t var1 = ((*(uint32_t *)0xF0000FE0ul) & 0x000000FFul);
3125              uint32_t var2 = ((*(uint32_t *)0xF0000FE8ul) & 0x000000F0ul) >> 4;
3126          #endif
3127          #if defined (NRF51422_XXAA) || defined (DEVELOP_IN_NRF51422)\
3128           || defined (NRF51422_XXAB) || defined (DEVELOP_IN_NRF51422)\
3129           || defined (NRF51422_XXAC) || defined (DEVELOP_IN_NRF51422)
3130              if (var1 == 0x01)
3131              {
3132                  switch(var2)
3133                  {
3134                      case 0x00ul:
3135                          return false;
3136                      case 0x01ul:
3137                          return false;
3138                      case 0x02ul:
3139                          return true;
3140                      case 0x03ul:
3141                          return false;
3142                      case 0x04ul:
3143                          return true;
3144                      case 0x07ul:
3145                          return true;
3146                      case 0x08ul:
3147                          return true;
3148                      case 0x09ul:
3149                          return true;
3150                      case 0x0Aul:
3151                          return true;
3152                      case 0x0Bul:
3153                          return true;
3154                      case 0x0Cul:
3155                          return true;
3156                      case 0x0Dul:
3157                          return true;
3158                  }
3159              }
3160          #endif
3161          return false;
3162      #endif
3163  }
3164  static bool nrf51_errata_71(void)
3165  {
3166      #ifndef NRF51_SERIES
3167          return false;
3168      #else
3169          #if defined (NRF51422_XXAA) || defined (DEVELOP_IN_NRF51422)\
3170           || defined (NRF51422_XXAB) || defined (DEVELOP_IN_NRF51422)\
3171           || defined (NRF51422_XXAC) || defined (DEVELOP_IN_NRF51422)
3172              uint32_t var1 = ((*(uint32_t *)0xF0000FE0ul) & 0x000000FFul);
3173              uint32_t var2 = ((*(uint32_t *)0xF0000FE8ul) & 0x000000F0ul) >> 4;
3174          #endif
3175          #if defined (NRF51422_XXAA) || defined (DEVELOP_IN_NRF51422)\
3176           || defined (NRF51422_XXAB) || defined (DEVELOP_IN_NRF51422)\
3177           || defined (NRF51422_XXAC) || defined (DEVELOP_IN_NRF51422)
3178              if (var1 == 0x01)
3179              {
3180                  switch(var2)
3181                  {
3182                      case 0x00ul:
3183                          return false;
3184                      case 0x01ul:
3185                          return false;
3186                      case 0x02ul:
3187                          return false;
3188                      case 0x03ul:
3189                          return false;
3190                      case 0x04ul:
3191                          return false;
3192                      case 0x07ul:
3193                          return true;
3194                      case 0x08ul:
3195                          return true;
3196                      case 0x09ul:
3197                          return false;
3198                      case 0x0Aul:
3199                          return false;
3200                      case 0x0Bul:
3201                          return true;
3202                      case 0x0Cul:
3203                          return true;
3204                      case 0x0Dul:
3205                          return false;
3206                  }
3207              }
3208          #endif
3209          return false;
3210      #endif
3211  }
3212  static bool nrf51_errata_72(void)
3213  {
3214      #ifndef NRF51_SERIES
3215          return false;
3216      #else
3217          #if defined (NRF51422_XXAA) || defined (DEVELOP_IN_NRF51422)\
3218           || defined (NRF51422_XXAB) || defined (DEVELOP_IN_NRF51422)\
3219           || defined (NRF51422_XXAC) || defined (DEVELOP_IN_NRF51422)
3220              uint32_t var1 = ((*(uint32_t *)0xF0000FE0ul) & 0x000000FFul);
3221              uint32_t var2 = ((*(uint32_t *)0xF0000FE8ul) & 0x000000F0ul) >> 4;
3222          #endif
3223          #if defined (NRF51422_XXAA) || defined (DEVELOP_IN_NRF51422)\
3224           || defined (NRF51422_XXAB) || defined (DEVELOP_IN_NRF51422)\
3225           || defined (NRF51422_XXAC) || defined (DEVELOP_IN_NRF51422)
3226              if (var1 == 0x01)
3227              {
3228                  switch(var2)
3229                  {
3230                      case 0x00ul:
3231                          return true;
3232                      case 0x01ul:
3233                          return true;
3234                      case 0x02ul:
3235                          return true;
3236                      case 0x03ul:
3237                          return true;
3238                      case 0x04ul:
3239                          return true;
3240                      case 0x07ul:
3241                          return true;
3242                      case 0x08ul:
3243                          return true;
3244                      case 0x09ul:
3245                          return true;
3246                      case 0x0Aul:
3247                          return true;
3248                      case 0x0Bul:
3249                          return true;
3250                      case 0x0Cul:
3251                          return true;
3252                      case 0x0Dul:
3253                          return true;
3254                  }
3255              }
3256          #endif
3257          return false;
3258      #endif
3259  }
3260  static bool nrf51_errata_73(void)
3261  {
3262      #ifndef NRF51_SERIES
3263          return false;
3264      #else
3265          #if defined (NRF51422_XXAA) || defined (DEVELOP_IN_NRF51422)\
3266           || defined (NRF51422_XXAB) || defined (DEVELOP_IN_NRF51422)\
3267           || defined (NRF51422_XXAC) || defined (DEVELOP_IN_NRF51422)
3268              uint32_t var1 = ((*(uint32_t *)0xF0000FE0ul) & 0x000000FFul);
3269              uint32_t var2 = ((*(uint32_t *)0xF0000FE8ul) & 0x000000F0ul) >> 4;
3270          #endif
3271          #if defined (NRF51422_XXAA) || defined (DEVELOP_IN_NRF51422)\
3272           || defined (NRF51422_XXAB) || defined (DEVELOP_IN_NRF51422)\
3273           || defined (NRF51422_XXAC) || defined (DEVELOP_IN_NRF51422)
3274              if (var1 == 0x01)
3275              {
3276                  switch(var2)
3277                  {
3278                      case 0x00ul:
3279                          return false;
3280                      case 0x01ul:
3281                          return false;
3282                      case 0x02ul:
3283                          return false;
3284                      case 0x03ul:
3285                          return false;
3286                      case 0x04ul:
3287                          return false;
3288                      case 0x07ul:
3289                          return true;
3290                      case 0x08ul:
3291                          return true;
3292                      case 0x09ul:
3293                          return true;
3294                      case 0x0Aul:
3295                          return false;
3296                      case 0x0Bul:
3297                          return true;
3298                      case 0x0Cul:
3299                          return true;
3300                      case 0x0Dul:
3301                          return false;
3302                  }
3303              }
3304          #endif
3305          return false;
3306      #endif
3307  }
3308  static bool nrf51_errata_74(void)
3309  {
3310      #ifndef NRF51_SERIES
3311          return false;
3312      #else
3313          #if defined (NRF51422_XXAA) || defined (DEVELOP_IN_NRF51422)\
3314           || defined (NRF51422_XXAB) || defined (DEVELOP_IN_NRF51422)\
3315           || defined (NRF51422_XXAC) || defined (DEVELOP_IN_NRF51422)
3316              uint32_t var1 = ((*(uint32_t *)0xF0000FE0ul) & 0x000000FFul);
3317              uint32_t var2 = ((*(uint32_t *)0xF0000FE8ul) & 0x000000F0ul) >> 4;
3318          #endif
3319          #if defined (NRF51422_XXAA) || defined (DEVELOP_IN_NRF51422)\
3320           || defined (NRF51422_XXAB) || defined (DEVELOP_IN_NRF51422)\
3321           || defined (NRF51422_XXAC) || defined (DEVELOP_IN_NRF51422)
3322              if (var1 == 0x01)
3323              {
3324                  switch(var2)
3325                  {
3326                      case 0x00ul:
3327                          return false;
3328                      case 0x01ul:
3329                          return false;
3330                      case 0x02ul:
3331                          return true;
3332                      case 0x03ul:
3333                          return false;
3334                      case 0x04ul:
3335                          return true;
3336                      case 0x07ul:
3337                          return true;
3338                      case 0x08ul:
3339                          return true;
3340                      case 0x09ul:
3341                          return true;
3342                      case 0x0Aul:
3343                          return false;
3344                      case 0x0Bul:
3345                          return true;
3346                      case 0x0Cul:
3347                          return true;
3348                      case 0x0Dul:
3349                          return false;
3350                  }
3351              }
3352          #endif
3353          return false;
3354      #endif
3355  }
3356  static bool nrf51_errata_75(void)
3357  {
3358      #ifndef NRF51_SERIES
3359          return false;
3360      #else
3361          #if defined (NRF51422_XXAA) || defined (DEVELOP_IN_NRF51422)\
3362           || defined (NRF51422_XXAB) || defined (DEVELOP_IN_NRF51422)\
3363           || defined (NRF51422_XXAC) || defined (DEVELOP_IN_NRF51422)
3364              uint32_t var1 = ((*(uint32_t *)0xF0000FE0ul) & 0x000000FFul);
3365              uint32_t var2 = ((*(uint32_t *)0xF0000FE8ul) & 0x000000F0ul) >> 4;
3366          #endif
3367          #if defined (NRF51422_XXAA) || defined (DEVELOP_IN_NRF51422)\
3368           || defined (NRF51422_XXAB) || defined (DEVELOP_IN_NRF51422)\
3369           || defined (NRF51422_XXAC) || defined (DEVELOP_IN_NRF51422)
3370              if (var1 == 0x01)
3371              {
3372                  switch(var2)
3373                  {
3374                      case 0x00ul:
3375                          return false;
3376                      case 0x01ul:
3377                          return false;
3378                      case 0x02ul:
3379                          return true;
3380                      case 0x03ul:
3381                          return false;
3382                      case 0x04ul:
3383                          return true;
3384                      case 0x07ul:
3385                          return true;
3386                      case 0x08ul:
3387                          return true;
3388                      case 0x09ul:
3389                          return true;
3390                      case 0x0Aul:
3391                          return true;
3392                      case 0x0Bul:
3393                          return true;
3394                      case 0x0Cul:
3395                          return true;
3396                      case 0x0Dul:
3397                          return true;
3398                  }
3399              }
3400          #endif
3401          return false;
3402      #endif
3403  }
3404  static bool nrf51_errata_76(void)
3405  {
3406      #ifndef NRF51_SERIES
3407          return false;
3408      #else
3409          #if defined (NRF51422_XXAA) || defined (DEVELOP_IN_NRF51422)\
3410           || defined (NRF51422_XXAB) || defined (DEVELOP_IN_NRF51422)\
3411           || defined (NRF51422_XXAC) || defined (DEVELOP_IN_NRF51422)
3412              uint32_t var1 = ((*(uint32_t *)0xF0000FE0ul) & 0x000000FFul);
3413              uint32_t var2 = ((*(uint32_t *)0xF0000FE8ul) & 0x000000F0ul) >> 4;
3414          #endif
3415          #if defined (NRF51422_XXAA) || defined (DEVELOP_IN_NRF51422)\
3416           || defined (NRF51422_XXAB) || defined (DEVELOP_IN_NRF51422)\
3417           || defined (NRF51422_XXAC) || defined (DEVELOP_IN_NRF51422)
3418              if (var1 == 0x01)
3419              {
3420                  switch(var2)
3421                  {
3422                      case 0x00ul:
3423                          return false;
3424                      case 0x01ul:
3425                          return false;
3426                      case 0x02ul:
3427                          return false;
3428                      case 0x03ul:
3429                          return false;
3430                      case 0x04ul:
3431                          return false;
3432                      case 0x07ul:
3433                          return false;
3434                      case 0x08ul:
3435                          return false;
3436                      case 0x09ul:
3437                          return false;
3438                      case 0x0Aul:
3439                          return true;
3440                      case 0x0Bul:
3441                          return false;
3442                      case 0x0Cul:
3443                          return false;
3444                      case 0x0Dul:
3445                          return true;
3446                  }
3447              }
3448          #endif
3449          return false;
3450      #endif
3451  }
3452  static bool nrf51_errata_77(void)
3453  {
3454      #ifndef NRF51_SERIES
3455          return false;
3456      #else
3457          return false;
3458      #endif
3459  }
3460  static bool nrf51_errata_78(void)
3461  {
3462      #ifndef NRF51_SERIES
3463          return false;
3464      #else
3465          #if defined (NRF51422_XXAA) || defined (DEVELOP_IN_NRF51422)\
3466           || defined (NRF51422_XXAB) || defined (DEVELOP_IN_NRF51422)\
3467           || defined (NRF51422_XXAC) || defined (DEVELOP_IN_NRF51422)
3468              uint32_t var1 = ((*(uint32_t *)0xF0000FE0ul) & 0x000000FFul);
3469              uint32_t var2 = ((*(uint32_t *)0xF0000FE8ul) & 0x000000F0ul) >> 4;
3470          #endif
3471          #if defined (NRF51422_XXAA) || defined (DEVELOP_IN_NRF51422)\
3472           || defined (NRF51422_XXAB) || defined (DEVELOP_IN_NRF51422)\
3473           || defined (NRF51422_XXAC) || defined (DEVELOP_IN_NRF51422)
3474              if (var1 == 0x01)
3475              {
3476                  switch(var2)
3477                  {
3478                      case 0x00ul:
3479                          return false;
3480                      case 0x01ul:
3481                          return false;
3482                      case 0x02ul:
3483                          return true;
3484                      case 0x03ul:
3485                          return false;
3486                      case 0x04ul:
3487                          return true;
3488                      case 0x07ul:
3489                          return true;
3490                      case 0x08ul:
3491                          return true;
3492                      case 0x09ul:
3493                          return true;
3494                      case 0x0Aul:
3495                          return false;
3496                      case 0x0Bul:
3497                          return true;
3498                      case 0x0Cul:
3499                          return true;
3500                      case 0x0Dul:
3501                          return false;
3502                  }
3503              }
3504          #endif
3505          return false;
3506      #endif
3507  }
3508  #endif &bsol;* NRF51_ERRATAS_H */
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from libtomcrypt-MDEwOlJlcG9zaXRvcnk3NzcwMTE=-flat-tfm_desc.c</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from Adafruit_nRF52_Arduino-MDEwOlJlcG9zaXRvcnk3NDM1NDcyOQ==-flat-nrf51_erratas.h</div>
                </div>
                <div class="column column_space"><pre><code>448  static int tfm_ecc_projective_add_point(const ecc_point *P, const ecc_point *Q, ecc_point *R, void *ma, void *modulus, void *Mp)
449  {
450     fp_int  t1, t2, x, y, z;
451     fp_digit mp;
452     int err, inf;
</pre></code></div>
                <div class="column column_space"><pre><code>6  static bool nrf51_errata_1(void) __UNUSED;
7  static bool nrf51_errata_2(void) __UNUSED;
8  static bool nrf51_errata_3(void) __UNUSED;
9  static bool nrf51_errata_4(void) __UNUSED;
10  static bool nrf51_errata_5(void) __UNUSED;
11  static bool nrf51_errata_6(void) __UNUSED;
12  static bool nrf51_errata_7(void) __UNUSED;
13  static bool nrf51_errata_8(void) __UNUSED;
14  static bool nrf51_errata_9(void) __UNUSED;
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    