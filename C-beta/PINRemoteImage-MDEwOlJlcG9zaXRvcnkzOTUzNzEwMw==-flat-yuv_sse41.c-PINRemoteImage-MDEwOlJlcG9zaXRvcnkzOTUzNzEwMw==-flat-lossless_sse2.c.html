
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 23.754789272030653%, Tokens: 49, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>PINRemoteImage-MDEwOlJlcG9zaXRvcnkzOTUzNzEwMw==-flat-yuv_sse41.c</h3>
            <pre><code>1  #include "src/dsp/yuv.h"
2  #if defined(WEBP_USE_SSE41)
3  #include "src/dsp/common_sse41.h"
4  #include <stdlib.h>
5  #include <smmintrin.h>
6  static void ConvertYUV444ToRGB_SSE41(const __m128i* const Y0,
7                                       const __m128i* const U0,
8                                       const __m128i* const V0,
9                                       __m128i* const R,
10                                       __m128i* const G,
11                                       __m128i* const B) {
12    const __m128i k19077 = _mm_set1_epi16(19077);
13    const __m128i k26149 = _mm_set1_epi16(26149);
14    const __m128i k14234 = _mm_set1_epi16(14234);
15    const __m128i k33050 = _mm_set1_epi16((short)33050);
<span onclick='openModal()' class='match'>16    const __m128i k17685 = _mm_set1_epi16(17685);
17    const __m128i k6419  = _mm_set1_epi16(6419);
18    const __m128i k13320 = _mm_set1_epi16(13320);
19    const __m128i k8708  = _mm_set1_epi16(8708);
20    const __m128i Y1 = _mm_mulhi_epu16(*Y0, k19077);
21    const __m128i R0 = _mm_mulhi_epu16(*V0, k26149);
22    const __m128i R1 = _mm_sub_epi16(Y1, k14234);
23    const __m128i R2 = _mm_add_epi16(R1, R0);
24    const __m128i G0 = _mm_mulhi_epu16(*U0, k6419);
25    const __m128i G1 = _mm_mulhi_epu16(*V0, k13320);
26    const __m128i G2 = _mm_add_epi16(Y1, k8708);
27    const __m128i G3 = _mm_add_epi16(G0, G1);
28    const __m128i G4 = _mm_sub_epi16(G2, G3);
29    const __m128i B0 = _mm_mulhi_epu16(*U0, k33050);
30    const __m128i B1 = _mm_adds_epu16(B0, Y1);
31    const __m128i B2 = _mm_subs_epu16(B1, k17685);
32    *R = _mm_srai_epi16(R2, 6);   
</span>33    *G = _mm_srai_epi16(G4, 6);   
34    *B = _mm_srli_epi16(B2, 6);   
35  }
36  static WEBP_INLINE __m128i Load_HI_16_SSE41(const uint8_t* src) {
37    const __m128i zero = _mm_setzero_si128();
38    return _mm_unpacklo_epi8(zero, _mm_loadl_epi64((const __m128i*)src));
39  }
40  static WEBP_INLINE __m128i Load_UV_HI_8_SSE41(const uint8_t* src) {
41    const __m128i zero = _mm_setzero_si128();
42    const __m128i tmp0 = _mm_cvtsi32_si128(*(const uint32_t*)src);
43    const __m128i tmp1 = _mm_unpacklo_epi8(zero, tmp0);
44    return _mm_unpacklo_epi16(tmp1, tmp1);   
45  }
46  static void YUV444ToRGB_SSE41(const uint8_t* const y,
47                                const uint8_t* const u,
48                                const uint8_t* const v,
49                                __m128i* const R, __m128i* const G,
50                                __m128i* const B) {
51    const __m128i Y0 = Load_HI_16_SSE41(y), U0 = Load_HI_16_SSE41(u),
52                  V0 = Load_HI_16_SSE41(v);
53    ConvertYUV444ToRGB_SSE41(&Y0, &U0, &V0, R, G, B);
54  }
55  static void YUV420ToRGB_SSE41(const uint8_t* const y,
56                                const uint8_t* const u,
57                                const uint8_t* const v,
58                                __m128i* const R, __m128i* const G,
59                                __m128i* const B) {
60    const __m128i Y0 = Load_HI_16_SSE41(y), U0 = Load_UV_HI_8_SSE41(u),
61                  V0 = Load_UV_HI_8_SSE41(v);
62    ConvertYUV444ToRGB_SSE41(&Y0, &U0, &V0, R, G, B);
63  }
64  static WEBP_INLINE void PlanarTo24b_SSE41(
65      __m128i* const in0, __m128i* const in1, __m128i* const in2,
66      __m128i* const in3, __m128i* const in4, __m128i* const in5,
67      uint8_t* const rgb) {
68    VP8PlanarTo24b_SSE41(in0, in1, in2, in3, in4, in5);
69    _mm_storeu_si128((__m128i*)(rgb +  0), *in0);
70    _mm_storeu_si128((__m128i*)(rgb + 16), *in1);
71    _mm_storeu_si128((__m128i*)(rgb + 32), *in2);
72    _mm_storeu_si128((__m128i*)(rgb + 48), *in3);
73    _mm_storeu_si128((__m128i*)(rgb + 64), *in4);
74    _mm_storeu_si128((__m128i*)(rgb + 80), *in5);
75  }
76  void VP8YuvToRgb32_SSE41(const uint8_t* y, const uint8_t* u, const uint8_t* v,
77                           uint8_t* dst) {
78    __m128i R0, R1, R2, R3, G0, G1, G2, G3, B0, B1, B2, B3;
79    __m128i rgb0, rgb1, rgb2, rgb3, rgb4, rgb5;
80    YUV444ToRGB_SSE41(y + 0, u + 0, v + 0, &R0, &G0, &B0);
81    YUV444ToRGB_SSE41(y + 8, u + 8, v + 8, &R1, &G1, &B1);
82    YUV444ToRGB_SSE41(y + 16, u + 16, v + 16, &R2, &G2, &B2);
83    YUV444ToRGB_SSE41(y + 24, u + 24, v + 24, &R3, &G3, &B3);
84    rgb0 = _mm_packus_epi16(R0, R1);
85    rgb1 = _mm_packus_epi16(R2, R3);
86    rgb2 = _mm_packus_epi16(G0, G1);
87    rgb3 = _mm_packus_epi16(G2, G3);
88    rgb4 = _mm_packus_epi16(B0, B1);
89    rgb5 = _mm_packus_epi16(B2, B3);
90    PlanarTo24b_SSE41(&rgb0, &rgb1, &rgb2, &rgb3, &rgb4, &rgb5, dst);
91  }
92  void VP8YuvToBgr32_SSE41(const uint8_t* y, const uint8_t* u, const uint8_t* v,
93                           uint8_t* dst) {
94    __m128i R0, R1, R2, R3, G0, G1, G2, G3, B0, B1, B2, B3;
95    __m128i bgr0, bgr1, bgr2, bgr3, bgr4, bgr5;
96    YUV444ToRGB_SSE41(y +  0, u +  0, v +  0, &R0, &G0, &B0);
97    YUV444ToRGB_SSE41(y +  8, u +  8, v +  8, &R1, &G1, &B1);
98    YUV444ToRGB_SSE41(y + 16, u + 16, v + 16, &R2, &G2, &B2);
99    YUV444ToRGB_SSE41(y + 24, u + 24, v + 24, &R3, &G3, &B3);
100    bgr0 = _mm_packus_epi16(B0, B1);
101    bgr1 = _mm_packus_epi16(B2, B3);
102    bgr2 = _mm_packus_epi16(G0, G1);
103    bgr3 = _mm_packus_epi16(G2, G3);
104    bgr4 = _mm_packus_epi16(R0, R1);
105    bgr5= _mm_packus_epi16(R2, R3);
106    PlanarTo24b_SSE41(&bgr0, &bgr1, &bgr2, &bgr3, &bgr4, &bgr5, dst);
107  }
108  static void YuvToRgbRow_SSE41(const uint8_t* y,
109                                const uint8_t* u, const uint8_t* v,
110                                uint8_t* dst, int len) {
111    int n;
112    for (n = 0; n + 32 <= len; n += 32, dst += 32 * 3) {
113      __m128i R0, R1, R2, R3, G0, G1, G2, G3, B0, B1, B2, B3;
114      __m128i rgb0, rgb1, rgb2, rgb3, rgb4, rgb5;
115      YUV420ToRGB_SSE41(y +  0, u +  0, v +  0, &R0, &G0, &B0);
116      YUV420ToRGB_SSE41(y +  8, u +  4, v +  4, &R1, &G1, &B1);
117      YUV420ToRGB_SSE41(y + 16, u +  8, v +  8, &R2, &G2, &B2);
118      YUV420ToRGB_SSE41(y + 24, u + 12, v + 12, &R3, &G3, &B3);
119      rgb0 = _mm_packus_epi16(R0, R1);
120      rgb1 = _mm_packus_epi16(R2, R3);
121      rgb2 = _mm_packus_epi16(G0, G1);
122      rgb3 = _mm_packus_epi16(G2, G3);
123      rgb4 = _mm_packus_epi16(B0, B1);
124      rgb5 = _mm_packus_epi16(B2, B3);
125      PlanarTo24b_SSE41(&rgb0, &rgb1, &rgb2, &rgb3, &rgb4, &rgb5, dst);
126      y += 32;
127      u += 16;
128      v += 16;
129    }
130    for (; n < len; ++n) {   
131      VP8YuvToRgb(y[0], u[0], v[0], dst);
132      dst += 3;
133      y += 1;
134      u += (n & 1);
135      v += (n & 1);
136    }
137  }
138  static void YuvToBgrRow_SSE41(const uint8_t* y,
139                                const uint8_t* u, const uint8_t* v,
140                                uint8_t* dst, int len) {
141    int n;
142    for (n = 0; n + 32 <= len; n += 32, dst += 32 * 3) {
143      __m128i R0, R1, R2, R3, G0, G1, G2, G3, B0, B1, B2, B3;
144      __m128i bgr0, bgr1, bgr2, bgr3, bgr4, bgr5;
145      YUV420ToRGB_SSE41(y +  0, u +  0, v +  0, &R0, &G0, &B0);
146      YUV420ToRGB_SSE41(y +  8, u +  4, v +  4, &R1, &G1, &B1);
147      YUV420ToRGB_SSE41(y + 16, u +  8, v +  8, &R2, &G2, &B2);
148      YUV420ToRGB_SSE41(y + 24, u + 12, v + 12, &R3, &G3, &B3);
149      bgr0 = _mm_packus_epi16(B0, B1);
150      bgr1 = _mm_packus_epi16(B2, B3);
151      bgr2 = _mm_packus_epi16(G0, G1);
152      bgr3 = _mm_packus_epi16(G2, G3);
153      bgr4 = _mm_packus_epi16(R0, R1);
154      bgr5 = _mm_packus_epi16(R2, R3);
155      PlanarTo24b_SSE41(&bgr0, &bgr1, &bgr2, &bgr3, &bgr4, &bgr5, dst);
156      y += 32;
157      u += 16;
158      v += 16;
159    }
160    for (; n < len; ++n) {   
161      VP8YuvToBgr(y[0], u[0], v[0], dst);
162      dst += 3;
163      y += 1;
164      u += (n & 1);
165      v += (n & 1);
166    }
167  }
168  extern void WebPInitSamplersSSE41(void);
169  WEBP_TSAN_IGNORE_FUNCTION void WebPInitSamplersSSE41(void) {
170    WebPSamplers[MODE_RGB]  = YuvToRgbRow_SSE41;
171    WebPSamplers[MODE_BGR]  = YuvToBgrRow_SSE41;
172  }
173  #define LOAD_16(src) _mm_loadu_si128((const __m128i*)(src))
174  #define STORE_16(V, dst) _mm_storeu_si128((__m128i*)(dst), (V))
175  #define WEBP_SSE41_SHUFF(OUT)  do {                  \
176    const __m128i tmp0 = _mm_shuffle_epi8(A0, shuff0); \
177    const __m128i tmp1 = _mm_shuffle_epi8(A1, shuff1); \
178    const __m128i tmp2 = _mm_shuffle_epi8(A2, shuff2); \
179    const __m128i tmp3 = _mm_shuffle_epi8(A3, shuff0); \
180    const __m128i tmp4 = _mm_shuffle_epi8(A4, shuff1); \
181    const __m128i tmp5 = _mm_shuffle_epi8(A5, shuff2); \
182                                                       \
183                 \
184    const __m128i tmp6 = _mm_or_si128(tmp0, tmp1);     \
185    const __m128i tmp7 = _mm_or_si128(tmp3, tmp4);     \
186    out[OUT + 0] = _mm_or_si128(tmp6, tmp2);           \
187    out[OUT + 1] = _mm_or_si128(tmp7, tmp5);           \
188  } while (0);
189  static WEBP_INLINE void RGB24PackedToPlanar_SSE41(
190      const uint8_t* const rgb, __m128i* const out &bsol;*out[6]*/) {
191    const __m128i A0 = _mm_loadu_si128((const __m128i*)(rgb +  0));
192    const __m128i A1 = _mm_loadu_si128((const __m128i*)(rgb + 16));
193    const __m128i A2 = _mm_loadu_si128((const __m128i*)(rgb + 32));
194    const __m128i A3 = _mm_loadu_si128((const __m128i*)(rgb + 48));
195    const __m128i A4 = _mm_loadu_si128((const __m128i*)(rgb + 64));
196    const __m128i A5 = _mm_loadu_si128((const __m128i*)(rgb + 80));
197    {
198      const __m128i shuff0 = _mm_set_epi8(
199          -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 15, 12, 9, 6, 3, 0);
200      const __m128i shuff1 = _mm_set_epi8(
201          -1, -1, -1, -1, -1, 14, 11, 8, 5, 2, -1, -1, -1, -1, -1, -1);
202      const __m128i shuff2 = _mm_set_epi8(
203          13, 10, 7, 4, 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1);
204      WEBP_SSE41_SHUFF(0)
205    }
206    {
207      const __m128i shuff0 = _mm_set_epi8(
208          -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 13, 10, 7, 4, 1);
209      const __m128i shuff1 = _mm_set_epi8(
210          -1, -1, -1, -1, -1, 15, 12, 9, 6, 3, 0, -1, -1, -1, -1, -1);
211      const __m128i shuff2 = _mm_set_epi8(
212          14, 11, 8, 5, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1);
213      WEBP_SSE41_SHUFF(2)
214    }
215    {
216      const __m128i shuff0 = _mm_set_epi8(
217          -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 14, 11, 8, 5, 2);
218      const __m128i shuff1 = _mm_set_epi8(
219          -1, -1, -1, -1, -1, -1, 13, 10, 7, 4, 1, -1, -1, -1, -1, -1);
220      const __m128i shuff2 = _mm_set_epi8(
221          15, 12, 9, 6, 3, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1);
222      WEBP_SSE41_SHUFF(4)
223    }
224  }
225  #undef WEBP_SSE41_SHUFF
226  static WEBP_INLINE void RGB32PackedToPlanar_SSE41(
227      const uint32_t* const argb, __m128i* const rgb &bsol;*in[6]*/) {
228    const __m128i zero = _mm_setzero_si128();
229    __m128i a0 = LOAD_16(argb + 0);
230    __m128i a1 = LOAD_16(argb + 4);
231    __m128i a2 = LOAD_16(argb + 8);
232    __m128i a3 = LOAD_16(argb + 12);
233    VP8L32bToPlanar_SSE41(&a0, &a1, &a2, &a3);
234    rgb[0] = _mm_unpacklo_epi8(a1, zero);
235    rgb[1] = _mm_unpackhi_epi8(a1, zero);
236    rgb[2] = _mm_unpacklo_epi8(a2, zero);
237    rgb[3] = _mm_unpackhi_epi8(a2, zero);
238    rgb[4] = _mm_unpacklo_epi8(a3, zero);
239    rgb[5] = _mm_unpackhi_epi8(a3, zero);
240  }
241  #define TRANSFORM(RG_LO, RG_HI, GB_LO, GB_HI, MULT_RG, MULT_GB, \
242                    ROUNDER, DESCALE_FIX, OUT) do {               \
243    const __m128i V0_lo = _mm_madd_epi16(RG_LO, MULT_RG);         \
244    const __m128i V0_hi = _mm_madd_epi16(RG_HI, MULT_RG);         \
245    const __m128i V1_lo = _mm_madd_epi16(GB_LO, MULT_GB);         \
246    const __m128i V1_hi = _mm_madd_epi16(GB_HI, MULT_GB);         \
247    const __m128i V2_lo = _mm_add_epi32(V0_lo, V1_lo);            \
248    const __m128i V2_hi = _mm_add_epi32(V0_hi, V1_hi);            \
249    const __m128i V3_lo = _mm_add_epi32(V2_lo, ROUNDER);          \
250    const __m128i V3_hi = _mm_add_epi32(V2_hi, ROUNDER);          \
251    const __m128i V5_lo = _mm_srai_epi32(V3_lo, DESCALE_FIX);     \
252    const __m128i V5_hi = _mm_srai_epi32(V3_hi, DESCALE_FIX);     \
253    (OUT) = _mm_packs_epi32(V5_lo, V5_hi);                        \
254  } while (0)
255  #define MK_CST_16(A, B) _mm_set_epi16((B), (A), (B), (A), (B), (A), (B), (A))
256  static WEBP_INLINE void ConvertRGBToY_SSE41(const __m128i* const R,
257                                              const __m128i* const G,
258                                              const __m128i* const B,
259                                              __m128i* const Y) {
260    const __m128i kRG_y = MK_CST_16(16839, 33059 - 16384);
261    const __m128i kGB_y = MK_CST_16(16384, 6420);
262    const __m128i kHALF_Y = _mm_set1_epi32((16 << YUV_FIX) + YUV_HALF);
263    const __m128i RG_lo = _mm_unpacklo_epi16(*R, *G);
264    const __m128i RG_hi = _mm_unpackhi_epi16(*R, *G);
265    const __m128i GB_lo = _mm_unpacklo_epi16(*G, *B);
266    const __m128i GB_hi = _mm_unpackhi_epi16(*G, *B);
267    TRANSFORM(RG_lo, RG_hi, GB_lo, GB_hi, kRG_y, kGB_y, kHALF_Y, YUV_FIX, *Y);
268  }
269  static WEBP_INLINE void ConvertRGBToUV_SSE41(const __m128i* const R,
270                                               const __m128i* const G,
271                                               const __m128i* const B,
272                                               __m128i* const U,
273                                               __m128i* const V) {
274    const __m128i kRG_u = MK_CST_16(-9719, -19081);
275    const __m128i kGB_u = MK_CST_16(0, 28800);
276    const __m128i kRG_v = MK_CST_16(28800, 0);
277    const __m128i kGB_v = MK_CST_16(-24116, -4684);
278    const __m128i kHALF_UV = _mm_set1_epi32(((128 << YUV_FIX) + YUV_HALF) << 2);
279    const __m128i RG_lo = _mm_unpacklo_epi16(*R, *G);
280    const __m128i RG_hi = _mm_unpackhi_epi16(*R, *G);
281    const __m128i GB_lo = _mm_unpacklo_epi16(*G, *B);
282    const __m128i GB_hi = _mm_unpackhi_epi16(*G, *B);
283    TRANSFORM(RG_lo, RG_hi, GB_lo, GB_hi, kRG_u, kGB_u,
284              kHALF_UV, YUV_FIX + 2, *U);
285    TRANSFORM(RG_lo, RG_hi, GB_lo, GB_hi, kRG_v, kGB_v,
286              kHALF_UV, YUV_FIX + 2, *V);
287  }
288  #undef MK_CST_16
289  #undef TRANSFORM
290  static void ConvertRGB24ToY_SSE41(const uint8_t* rgb, uint8_t* y, int width) {
291    const int max_width = width & ~31;
292    int i;
293    for (i = 0; i < max_width; rgb += 3 * 16 * 2) {
294      __m128i rgb_plane[6];
295      int j;
296      RGB24PackedToPlanar_SSE41(rgb, rgb_plane);
297      for (j = 0; j < 2; ++j, i += 16) {
298        const __m128i zero = _mm_setzero_si128();
299        __m128i r, g, b, Y0, Y1;
300        r = _mm_unpacklo_epi8(rgb_plane[0 + j], zero);
301        g = _mm_unpacklo_epi8(rgb_plane[2 + j], zero);
302        b = _mm_unpacklo_epi8(rgb_plane[4 + j], zero);
303        ConvertRGBToY_SSE41(&r, &g, &b, &Y0);
304        r = _mm_unpackhi_epi8(rgb_plane[0 + j], zero);
305        g = _mm_unpackhi_epi8(rgb_plane[2 + j], zero);
306        b = _mm_unpackhi_epi8(rgb_plane[4 + j], zero);
307        ConvertRGBToY_SSE41(&r, &g, &b, &Y1);
308        STORE_16(_mm_packus_epi16(Y0, Y1), y + i);
309      }
310    }
311    for (; i < width; ++i, rgb += 3) {   
312      y[i] = VP8RGBToY(rgb[0], rgb[1], rgb[2], YUV_HALF);
313    }
314  }
315  static void ConvertBGR24ToY_SSE41(const uint8_t* bgr, uint8_t* y, int width) {
316    const int max_width = width & ~31;
317    int i;
318    for (i = 0; i < max_width; bgr += 3 * 16 * 2) {
319      __m128i bgr_plane[6];
320      int j;
321      RGB24PackedToPlanar_SSE41(bgr, bgr_plane);
322      for (j = 0; j < 2; ++j, i += 16) {
323        const __m128i zero = _mm_setzero_si128();
324        __m128i r, g, b, Y0, Y1;
325        b = _mm_unpacklo_epi8(bgr_plane[0 + j], zero);
326        g = _mm_unpacklo_epi8(bgr_plane[2 + j], zero);
327        r = _mm_unpacklo_epi8(bgr_plane[4 + j], zero);
328        ConvertRGBToY_SSE41(&r, &g, &b, &Y0);
329        b = _mm_unpackhi_epi8(bgr_plane[0 + j], zero);
330        g = _mm_unpackhi_epi8(bgr_plane[2 + j], zero);
331        r = _mm_unpackhi_epi8(bgr_plane[4 + j], zero);
332        ConvertRGBToY_SSE41(&r, &g, &b, &Y1);
333        STORE_16(_mm_packus_epi16(Y0, Y1), y + i);
334      }
335    }
336    for (; i < width; ++i, bgr += 3) {  
337      y[i] = VP8RGBToY(bgr[2], bgr[1], bgr[0], YUV_HALF);
338    }
339  }
340  static void ConvertARGBToY_SSE41(const uint32_t* argb, uint8_t* y, int width) {
341    const int max_width = width & ~15;
342    int i;
343    for (i = 0; i < max_width; i += 16) {
344      __m128i Y0, Y1, rgb[6];
345      RGB32PackedToPlanar_SSE41(&argb[i], rgb);
346      ConvertRGBToY_SSE41(&rgb[0], &rgb[2], &rgb[4], &Y0);
347      ConvertRGBToY_SSE41(&rgb[1], &rgb[3], &rgb[5], &Y1);
348      STORE_16(_mm_packus_epi16(Y0, Y1), y + i);
349    }
350    for (; i < width; ++i) {   
351      const uint32_t p = argb[i];
352      y[i] = VP8RGBToY((p >> 16) & 0xff, (p >> 8) & 0xff, (p >>  0) & 0xff,
353                       YUV_HALF);
354    }
355  }
356  static void HorizontalAddPack_SSE41(const __m128i* const A,
357                                      const __m128i* const B,
358                                      __m128i* const out) {
359    const __m128i k2 = _mm_set1_epi16(2);
360    const __m128i C = _mm_madd_epi16(*A, k2);
361    const __m128i D = _mm_madd_epi16(*B, k2);
362    *out = _mm_packs_epi32(C, D);
363  }
364  static void ConvertARGBToUV_SSE41(const uint32_t* argb,
365                                    uint8_t* u, uint8_t* v,
366                                    int src_width, int do_store) {
367    const int max_width = src_width & ~31;
368    int i;
369    for (i = 0; i < max_width; i += 32, u += 16, v += 16) {
370      __m128i rgb[6], U0, V0, U1, V1;
371      RGB32PackedToPlanar_SSE41(&argb[i], rgb);
372      HorizontalAddPack_SSE41(&rgb[0], &rgb[1], &rgb[0]);
373      HorizontalAddPack_SSE41(&rgb[2], &rgb[3], &rgb[2]);
374      HorizontalAddPack_SSE41(&rgb[4], &rgb[5], &rgb[4]);
375      ConvertRGBToUV_SSE41(&rgb[0], &rgb[2], &rgb[4], &U0, &V0);
376      RGB32PackedToPlanar_SSE41(&argb[i + 16], rgb);
377      HorizontalAddPack_SSE41(&rgb[0], &rgb[1], &rgb[0]);
378      HorizontalAddPack_SSE41(&rgb[2], &rgb[3], &rgb[2]);
379      HorizontalAddPack_SSE41(&rgb[4], &rgb[5], &rgb[4]);
380      ConvertRGBToUV_SSE41(&rgb[0], &rgb[2], &rgb[4], &U1, &V1);
381      U0 = _mm_packus_epi16(U0, U1);
382      V0 = _mm_packus_epi16(V0, V1);
383      if (!do_store) {
384        const __m128i prev_u = LOAD_16(u);
385        const __m128i prev_v = LOAD_16(v);
386        U0 = _mm_avg_epu8(U0, prev_u);
387        V0 = _mm_avg_epu8(V0, prev_v);
388      }
389      STORE_16(U0, u);
390      STORE_16(V0, v);
391    }
392    if (i < src_width) {  
393      WebPConvertARGBToUV_C(argb + i, u, v, src_width - i, do_store);
394    }
395  }
396  static WEBP_INLINE void RGBA32PackedToPlanar_16b_SSE41(
397      const uint16_t* const rgbx,
398      __m128i* const r, __m128i* const g, __m128i* const b) {
399    const __m128i in0 = LOAD_16(rgbx +  0);  
400    const __m128i in1 = LOAD_16(rgbx +  8);  
401    const __m128i in2 = LOAD_16(rgbx + 16);  
402    const __m128i in3 = LOAD_16(rgbx + 24);  
403    const __m128i shuff0 =
404        _mm_set_epi8(-1, -1, -1, -1, 13, 12, 5, 4, 11, 10, 3, 2, 9, 8, 1, 0);
405    const __m128i shuff1 =
406        _mm_set_epi8(13, 12, 5, 4, -1, -1, -1, -1, 11, 10, 3, 2, 9, 8, 1, 0);
407    const __m128i A0 = _mm_shuffle_epi8(in0, shuff0);
408    const __m128i A1 = _mm_shuffle_epi8(in1, shuff1);
409    const __m128i A2 = _mm_shuffle_epi8(in2, shuff0);
410    const __m128i A3 = _mm_shuffle_epi8(in3, shuff1);
411    const __m128i B0 = _mm_unpacklo_epi32(A0, A1);
412    const __m128i B1 = _mm_or_si128(A0, A1);
413    const __m128i B2 = _mm_unpacklo_epi32(A2, A3);
414    const __m128i B3 = _mm_or_si128(A2, A3);
415    *r = _mm_unpacklo_epi64(B0, B2);
416    *g = _mm_unpackhi_epi64(B0, B2);
417    *b = _mm_unpackhi_epi64(B1, B3);
418  }
419  static void ConvertRGBA32ToUV_SSE41(const uint16_t* rgb,
420                                      uint8_t* u, uint8_t* v, int width) {
421    const int max_width = width & ~15;
422    const uint16_t* const last_rgb = rgb + 4 * max_width;
423    while (rgb < last_rgb) {
424      __m128i r, g, b, U0, V0, U1, V1;
425      RGBA32PackedToPlanar_16b_SSE41(rgb +  0, &r, &g, &b);
426      ConvertRGBToUV_SSE41(&r, &g, &b, &U0, &V0);
427      RGBA32PackedToPlanar_16b_SSE41(rgb + 32, &r, &g, &b);
428      ConvertRGBToUV_SSE41(&r, &g, &b, &U1, &V1);
429      STORE_16(_mm_packus_epi16(U0, U1), u);
430      STORE_16(_mm_packus_epi16(V0, V1), v);
431      u += 16;
432      v += 16;
433      rgb += 2 * 32;
434    }
435    if (max_width < width) {  
436      WebPConvertRGBA32ToUV_C(rgb, u, v, width - max_width);
437    }
438  }
439  extern void WebPInitConvertARGBToYUVSSE41(void);
440  WEBP_TSAN_IGNORE_FUNCTION void WebPInitConvertARGBToYUVSSE41(void) {
441    WebPConvertARGBToY = ConvertARGBToY_SSE41;
442    WebPConvertARGBToUV = ConvertARGBToUV_SSE41;
443    WebPConvertRGB24ToY = ConvertRGB24ToY_SSE41;
444    WebPConvertBGR24ToY = ConvertBGR24ToY_SSE41;
445    WebPConvertRGBA32ToUV = ConvertRGBA32ToUV_SSE41;
446  }
447  #else  
448  WEBP_DSP_INIT_STUB(WebPInitSamplersSSE41)
449  WEBP_DSP_INIT_STUB(WebPInitConvertARGBToYUVSSE41)
450  #endif  
</code></pre>
        </div>
        <div class="column">
            <h3>PINRemoteImage-MDEwOlJlcG9zaXRvcnkzOTUzNzEwMw==-flat-lossless_sse2.c</h3>
            <pre><code>1  #include "src/dsp/dsp.h"
2  #if defined(WEBP_USE_SSE2)
3  #include "src/dsp/common_sse2.h"
4  #include "src/dsp/lossless.h"
5  #include "src/dsp/lossless_common.h"
6  #include <assert.h>
7  #include <emmintrin.h>
8  static WEBP_INLINE uint32_t ClampedAddSubtractFull_SSE2(uint32_t c0,
9                                                          uint32_t c1,
10                                                          uint32_t c2) {
11    const __m128i zero = _mm_setzero_si128();
12    const __m128i C0 = _mm_unpacklo_epi8(_mm_cvtsi32_si128(c0), zero);
13    const __m128i C1 = _mm_unpacklo_epi8(_mm_cvtsi32_si128(c1), zero);
14    const __m128i C2 = _mm_unpacklo_epi8(_mm_cvtsi32_si128(c2), zero);
15    const __m128i V1 = _mm_add_epi16(C0, C1);
16    const __m128i V2 = _mm_sub_epi16(V1, C2);
17    const __m128i b = _mm_packus_epi16(V2, V2);
18    const uint32_t output = _mm_cvtsi128_si32(b);
19    return output;
20  }
21  static WEBP_INLINE uint32_t ClampedAddSubtractHalf_SSE2(uint32_t c0,
22                                                          uint32_t c1,
23                                                          uint32_t c2) {
24    const __m128i zero = _mm_setzero_si128();
25    const __m128i C0 = _mm_unpacklo_epi8(_mm_cvtsi32_si128(c0), zero);
26    const __m128i C1 = _mm_unpacklo_epi8(_mm_cvtsi32_si128(c1), zero);
27    const __m128i B0 = _mm_unpacklo_epi8(_mm_cvtsi32_si128(c2), zero);
28    const __m128i avg = _mm_add_epi16(C1, C0);
29    const __m128i A0 = _mm_srli_epi16(avg, 1);
30    const __m128i A1 = _mm_sub_epi16(A0, B0);
31    const __m128i BgtA = _mm_cmpgt_epi16(B0, A0);
32    const __m128i A2 = _mm_sub_epi16(A1, BgtA);
33    const __m128i A3 = _mm_srai_epi16(A2, 1);
34    const __m128i A4 = _mm_add_epi16(A0, A3);
35    const __m128i A5 = _mm_packus_epi16(A4, A4);
36    const uint32_t output = _mm_cvtsi128_si32(A5);
37    return output;
38  }
39  static WEBP_INLINE uint32_t Select_SSE2(uint32_t a, uint32_t b, uint32_t c) {
40    int pa_minus_pb;
41    const __m128i zero = _mm_setzero_si128();
42    const __m128i A0 = _mm_cvtsi32_si128(a);
43    const __m128i B0 = _mm_cvtsi32_si128(b);
44    const __m128i C0 = _mm_cvtsi32_si128(c);
45    const __m128i AC0 = _mm_subs_epu8(A0, C0);
46    const __m128i CA0 = _mm_subs_epu8(C0, A0);
47    const __m128i BC0 = _mm_subs_epu8(B0, C0);
48    const __m128i CB0 = _mm_subs_epu8(C0, B0);
49    const __m128i AC = _mm_or_si128(AC0, CA0);
50    const __m128i BC = _mm_or_si128(BC0, CB0);
51    const __m128i pa = _mm_unpacklo_epi8(AC, zero);  
52    const __m128i pb = _mm_unpacklo_epi8(BC, zero);  
53    const __m128i diff = _mm_sub_epi16(pb, pa);
54    {
55      int16_t out[8];
56      _mm_storeu_si128((__m128i*)out, diff);
57      pa_minus_pb = out[0] + out[1] + out[2] + out[3];
58    }
59    return (pa_minus_pb <= 0) ? a : b;
60  }
61  static WEBP_INLINE void Average2_m128i(const __m128i* const a0,
62                                         const __m128i* const a1,
63                                         __m128i* const avg) {
64    const __m128i ones = _mm_set1_epi8(1);
65    const __m128i avg1 = _mm_avg_epu8(*a0, *a1);
66    const __m128i one = _mm_and_si128(_mm_xor_si128(*a0, *a1), ones);
67    *avg = _mm_sub_epi8(avg1, one);
68  }
69  static WEBP_INLINE void Average2_uint32_SSE2(const uint32_t a0,
70                                               const uint32_t a1,
71                                               __m128i* const avg) {
72    const __m128i ones = _mm_set1_epi8(1);
73    const __m128i A0 = _mm_cvtsi32_si128(a0);
74    const __m128i A1 = _mm_cvtsi32_si128(a1);
75    const __m128i avg1 = _mm_avg_epu8(A0, A1);
76    const __m128i one = _mm_and_si128(_mm_xor_si128(A0, A1), ones);
77    *avg = _mm_sub_epi8(avg1, one);
78  }
79  static WEBP_INLINE __m128i Average2_uint32_16_SSE2(uint32_t a0, uint32_t a1) {
80    const __m128i zero = _mm_setzero_si128();
81    const __m128i A0 = _mm_unpacklo_epi8(_mm_cvtsi32_si128(a0), zero);
82    const __m128i A1 = _mm_unpacklo_epi8(_mm_cvtsi32_si128(a1), zero);
83    const __m128i sum = _mm_add_epi16(A1, A0);
84    return _mm_srli_epi16(sum, 1);
85  }
86  static WEBP_INLINE uint32_t Average2_SSE2(uint32_t a0, uint32_t a1) {
87    __m128i output;
88    Average2_uint32_SSE2(a0, a1, &output);
89    return _mm_cvtsi128_si32(output);
90  }
91  static WEBP_INLINE uint32_t Average3_SSE2(uint32_t a0, uint32_t a1,
92                                            uint32_t a2) {
93    const __m128i zero = _mm_setzero_si128();
94    const __m128i avg1 = Average2_uint32_16_SSE2(a0, a2);
95    const __m128i A1 = _mm_unpacklo_epi8(_mm_cvtsi32_si128(a1), zero);
96    const __m128i sum = _mm_add_epi16(avg1, A1);
97    const __m128i avg2 = _mm_srli_epi16(sum, 1);
98    const __m128i A2 = _mm_packus_epi16(avg2, avg2);
99    const uint32_t output = _mm_cvtsi128_si32(A2);
100    return output;
101  }
102  static WEBP_INLINE uint32_t Average4_SSE2(uint32_t a0, uint32_t a1,
103                                            uint32_t a2, uint32_t a3) {
104    const __m128i avg1 = Average2_uint32_16_SSE2(a0, a1);
105    const __m128i avg2 = Average2_uint32_16_SSE2(a2, a3);
106    const __m128i sum = _mm_add_epi16(avg2, avg1);
107    const __m128i avg3 = _mm_srli_epi16(sum, 1);
108    const __m128i A0 = _mm_packus_epi16(avg3, avg3);
109    const uint32_t output = _mm_cvtsi128_si32(A0);
110    return output;
111  }
112  static uint32_t Predictor5_SSE2(uint32_t left, const uint32_t* const top) {
113    const uint32_t pred = Average3_SSE2(left, top[0], top[1]);
114    return pred;
115  }
116  static uint32_t Predictor6_SSE2(uint32_t left, const uint32_t* const top) {
117    const uint32_t pred = Average2_SSE2(left, top[-1]);
118    return pred;
119  }
120  static uint32_t Predictor7_SSE2(uint32_t left, const uint32_t* const top) {
121    const uint32_t pred = Average2_SSE2(left, top[0]);
122    return pred;
123  }
124  static uint32_t Predictor8_SSE2(uint32_t left, const uint32_t* const top) {
125    const uint32_t pred = Average2_SSE2(top[-1], top[0]);
126    (void)left;
127    return pred;
128  }
129  static uint32_t Predictor9_SSE2(uint32_t left, const uint32_t* const top) {
130    const uint32_t pred = Average2_SSE2(top[0], top[1]);
131    (void)left;
132    return pred;
133  }
134  static uint32_t Predictor10_SSE2(uint32_t left, const uint32_t* const top) {
135    const uint32_t pred = Average4_SSE2(left, top[-1], top[0], top[1]);
136    return pred;
137  }
138  static uint32_t Predictor11_SSE2(uint32_t left, const uint32_t* const top) {
139    const uint32_t pred = Select_SSE2(top[0], left, top[-1]);
140    return pred;
141  }
142  static uint32_t Predictor12_SSE2(uint32_t left, const uint32_t* const top) {
143    const uint32_t pred = ClampedAddSubtractFull_SSE2(left, top[0], top[-1]);
144    return pred;
145  }
146  static uint32_t Predictor13_SSE2(uint32_t left, const uint32_t* const top) {
147    const uint32_t pred = ClampedAddSubtractHalf_SSE2(left, top[0], top[-1]);
148    return pred;
149  }
150  static void PredictorAdd0_SSE2(const uint32_t* in, const uint32_t* upper,
151                                 int num_pixels, uint32_t* out) {
152    int i;
153    const __m128i black = _mm_set1_epi32(ARGB_BLACK);
154    for (i = 0; i + 4 <= num_pixels; i += 4) {
155      const __m128i src = _mm_loadu_si128((const __m128i*)&in[i]);
156      const __m128i res = _mm_add_epi8(src, black);
157      _mm_storeu_si128((__m128i*)&out[i], res);
158    }
159    if (i != num_pixels) {
160      VP8LPredictorsAdd_C[0](in + i, NULL, num_pixels - i, out + i);
161    }
162    (void)upper;
163  }
164  static void PredictorAdd1_SSE2(const uint32_t* in, const uint32_t* upper,
165                                 int num_pixels, uint32_t* out) {
166    int i;
167    __m128i prev = _mm_set1_epi32(out[-1]);
168    for (i = 0; i + 4 <= num_pixels; i += 4) {
169      const __m128i src = _mm_loadu_si128((const __m128i*)&in[i]);
170      const __m128i shift0 = _mm_slli_si128(src, 4);
171      const __m128i sum0 = _mm_add_epi8(src, shift0);
172      const __m128i shift1 = _mm_slli_si128(sum0, 8);
173      const __m128i sum1 = _mm_add_epi8(sum0, shift1);
174      const __m128i res = _mm_add_epi8(sum1, prev);
175      _mm_storeu_si128((__m128i*)&out[i], res);
176      prev = _mm_shuffle_epi32(res, (3 << 0) | (3 << 2) | (3 << 4) | (3 << 6));
177    }
178    if (i != num_pixels) {
179      VP8LPredictorsAdd_C[1](in + i, upper + i, num_pixels - i, out + i);
180    }
181  }
182  #define GENERATE_PREDICTOR_1(X, IN)                                           \
183  static void PredictorAdd##X##_SSE2(const uint32_t* in, const uint32_t* upper, \
184                                    int num_pixels, uint32_t* out) {            \
185    int i;                                                                      \
186    for (i = 0; i + 4 <= num_pixels; i += 4) {                                  \
187      const __m128i src = _mm_loadu_si128((const __m128i*)&in[i]);              \
188      const __m128i other = _mm_loadu_si128((const __m128i*)&(IN));             \
189      const __m128i res = _mm_add_epi8(src, other);                             \
190      _mm_storeu_si128((__m128i*)&out[i], res);                                 \
191    }                                                                           \
192    if (i != num_pixels) {                                                      \
193      VP8LPredictorsAdd_C[(X)](in + i, upper + i, num_pixels - i, out + i);     \
194    }                                                                           \
195  }
196  GENERATE_PREDICTOR_1(2, upper[i])
197  GENERATE_PREDICTOR_1(3, upper[i + 1])
198  GENERATE_PREDICTOR_1(4, upper[i - 1])
199  #undef GENERATE_PREDICTOR_1
200  GENERATE_PREDICTOR_ADD(Predictor5_SSE2, PredictorAdd5_SSE2)
201  GENERATE_PREDICTOR_ADD(Predictor6_SSE2, PredictorAdd6_SSE2)
202  GENERATE_PREDICTOR_ADD(Predictor7_SSE2, PredictorAdd7_SSE2)
203  #define GENERATE_PREDICTOR_2(X, IN)                                           \
204  static void PredictorAdd##X##_SSE2(const uint32_t* in, const uint32_t* upper, \
205                                     int num_pixels, uint32_t* out) {           \
206    int i;                                                                      \
207    for (i = 0; i + 4 <= num_pixels; i += 4) {                                  \
208      const __m128i Tother = _mm_loadu_si128((const __m128i*)&(IN));            \
209      const __m128i T = _mm_loadu_si128((const __m128i*)&upper[i]);             \
210      const __m128i src = _mm_loadu_si128((const __m128i*)&in[i]);              \
211      __m128i avg, res;                                                         \
212      Average2_m128i(&T, &Tother, &avg);                                        \
213      res = _mm_add_epi8(avg, src);                                             \
214      _mm_storeu_si128((__m128i*)&out[i], res);                                 \
215    }                                                                           \
216    if (i != num_pixels) {                                                      \
217      VP8LPredictorsAdd_C[(X)](in + i, upper + i, num_pixels - i, out + i);     \
218    }                                                                           \
219  }
220  GENERATE_PREDICTOR_2(8, upper[i - 1])
221  GENERATE_PREDICTOR_2(9, upper[i + 1])
222  #undef GENERATE_PREDICTOR_2
223  #define DO_PRED10(OUT) do {               \
224    __m128i avgLTL, avg;                    \
225    Average2_m128i(&L, &TL, &avgLTL);       \
226    Average2_m128i(&avgTTR, &avgLTL, &avg); \
227    L = _mm_add_epi8(avg, src);             \
228    out[i + (OUT)] = _mm_cvtsi128_si32(L);  \
229  } while (0)
230  #define DO_PRED10_SHIFT do {                                  \
231     \
232    avgTTR = _mm_srli_si128(avgTTR, 4);                         \
233    TL = _mm_srli_si128(TL, 4);                                 \
234    src = _mm_srli_si128(src, 4);                               \
235  } while (0)
236  static void PredictorAdd10_SSE2(const uint32_t* in, const uint32_t* upper,
237                                  int num_pixels, uint32_t* out) {
238    int i;
239    __m128i L = _mm_cvtsi32_si128(out[-1]);
240    for (i = 0; i + 4 <= num_pixels; i += 4) {
241      __m128i src = _mm_loadu_si128((const __m128i*)&in[i]);
242      __m128i TL = _mm_loadu_si128((const __m128i*)&upper[i - 1]);
243      const __m128i T = _mm_loadu_si128((const __m128i*)&upper[i]);
244      const __m128i TR = _mm_loadu_si128((const __m128i*)&upper[i + 1]);
245      __m128i avgTTR;
246      Average2_m128i(&T, &TR, &avgTTR);
247      DO_PRED10(0);
248      DO_PRED10_SHIFT;
249      DO_PRED10(1);
250      DO_PRED10_SHIFT;
251      DO_PRED10(2);
252      DO_PRED10_SHIFT;
253      DO_PRED10(3);
254    }
255    if (i != num_pixels) {
256      VP8LPredictorsAdd_C[10](in + i, upper + i, num_pixels - i, out + i);
257    }
258  }
259  #undef DO_PRED10
260  #undef DO_PRED10_SHIFT
261  #define DO_PRED11(OUT) do {                                            \
262    const __m128i L_lo = _mm_unpacklo_epi32(L, T);                       \
263    const __m128i TL_lo = _mm_unpacklo_epi32(TL, T);                     \
264    const __m128i pb = _mm_sad_epu8(L_lo, TL_lo); &bsol;* pb = sum |L-TL|*/   \
265    const __m128i mask = _mm_cmpgt_epi32(pb, pa);                        \
266    const __m128i A = _mm_and_si128(mask, L);                            \
267    const __m128i B = _mm_andnot_si128(mask, T);                         \
268    const __m128i pred = _mm_or_si128(A, B); &bsol;* pred = (pa > b)? L : T*/ \
269    L = _mm_add_epi8(src, pred);                                         \
270    out[i + (OUT)] = _mm_cvtsi128_si32(L);                               \
271  } while (0)
272  #define DO_PRED11_SHIFT do {                                \
273     \
274    T = _mm_srli_si128(T, 4);                                 \
275    TL = _mm_srli_si128(TL, 4);                               \
276    src = _mm_srli_si128(src, 4);                             \
277    pa = _mm_srli_si128(pa, 4);                               \
278  } while (0)
279  static void PredictorAdd11_SSE2(const uint32_t* in, const uint32_t* upper,
280                                  int num_pixels, uint32_t* out) {
281    int i;
282    __m128i pa;
283    __m128i L = _mm_cvtsi32_si128(out[-1]);
284    for (i = 0; i + 4 <= num_pixels; i += 4) {
285      __m128i T = _mm_loadu_si128((const __m128i*)&upper[i]);
286      __m128i TL = _mm_loadu_si128((const __m128i*)&upper[i - 1]);
287      __m128i src = _mm_loadu_si128((const __m128i*)&in[i]);
288      {
289        const __m128i T_lo = _mm_unpacklo_epi32(T, T);
290        const __m128i TL_lo = _mm_unpacklo_epi32(TL, T);
291        const __m128i T_hi = _mm_unpackhi_epi32(T, T);
292        const __m128i TL_hi = _mm_unpackhi_epi32(TL, T);
293        const __m128i s_lo = _mm_sad_epu8(T_lo, TL_lo);
294        const __m128i s_hi = _mm_sad_epu8(T_hi, TL_hi);
295        pa = _mm_packs_epi32(s_lo, s_hi);  
296      }
297      DO_PRED11(0);
298      DO_PRED11_SHIFT;
299      DO_PRED11(1);
300      DO_PRED11_SHIFT;
301      DO_PRED11(2);
302      DO_PRED11_SHIFT;
303      DO_PRED11(3);
304    }
305    if (i != num_pixels) {
306      VP8LPredictorsAdd_C[11](in + i, upper + i, num_pixels - i, out + i);
307    }
308  }
309  #undef DO_PRED11
310  #undef DO_PRED11_SHIFT
311  #define DO_PRED12(DIFF, LANE, OUT) do {            \
312    const __m128i all = _mm_add_epi16(L, (DIFF));    \
313    const __m128i alls = _mm_packus_epi16(all, all); \
314    const __m128i res = _mm_add_epi8(src, alls);     \
315    out[i + (OUT)] = _mm_cvtsi128_si32(res);         \
316    L = _mm_unpacklo_epi8(res, zero);                \
317  } while (0)
318  #define DO_PRED12_SHIFT(DIFF, LANE) do {                    \
319     \
320    if ((LANE) == 0) (DIFF) = _mm_srli_si128((DIFF), 8);      \
321    src = _mm_srli_si128(src, 4);                             \
322  } while (0)
323  static void PredictorAdd12_SSE2(const uint32_t* in, const uint32_t* upper,
324                                  int num_pixels, uint32_t* out) {
325    int i;
326    const __m128i zero = _mm_setzero_si128();
327    const __m128i L8 = _mm_cvtsi32_si128(out[-1]);
328    __m128i L = _mm_unpacklo_epi8(L8, zero);
329    for (i = 0; i + 4 <= num_pixels; i += 4) {
330      __m128i src = _mm_loadu_si128((const __m128i*)&in[i]);
331      const __m128i T = _mm_loadu_si128((const __m128i*)&upper[i]);
332      const __m128i T_lo = _mm_unpacklo_epi8(T, zero);
333      const __m128i T_hi = _mm_unpackhi_epi8(T, zero);
334      const __m128i TL = _mm_loadu_si128((const __m128i*)&upper[i - 1]);
335      const __m128i TL_lo = _mm_unpacklo_epi8(TL, zero);
336      const __m128i TL_hi = _mm_unpackhi_epi8(TL, zero);
337      __m128i diff_lo = _mm_sub_epi16(T_lo, TL_lo);
338      __m128i diff_hi = _mm_sub_epi16(T_hi, TL_hi);
339      DO_PRED12(diff_lo, 0, 0);
340      DO_PRED12_SHIFT(diff_lo, 0);
341      DO_PRED12(diff_lo, 1, 1);
342      DO_PRED12_SHIFT(diff_lo, 1);
343      DO_PRED12(diff_hi, 0, 2);
344      DO_PRED12_SHIFT(diff_hi, 0);
345      DO_PRED12(diff_hi, 1, 3);
346    }
347    if (i != num_pixels) {
348      VP8LPredictorsAdd_C[12](in + i, upper + i, num_pixels - i, out + i);
349    }
350  }
351  #undef DO_PRED12
352  #undef DO_PRED12_SHIFT
353  GENERATE_PREDICTOR_ADD(Predictor13_SSE2, PredictorAdd13_SSE2)
354  static void AddGreenToBlueAndRed_SSE2(const uint32_t* const src, int num_pixels,
355                                        uint32_t* dst) {
356    int i;
357    for (i = 0; i + 4 <= num_pixels; i += 4) {
358      const __m128i in = _mm_loadu_si128((const __m128i*)&src[i]); 
359      const __m128i A = _mm_srli_epi16(in, 8);     
360      const __m128i B = _mm_shufflelo_epi16(A, _MM_SHUFFLE(2, 2, 0, 0));
361      const __m128i C = _mm_shufflehi_epi16(B, _MM_SHUFFLE(2, 2, 0, 0));  
362      const __m128i out = _mm_add_epi8(in, C);
363      _mm_storeu_si128((__m128i*)&dst[i], out);
364    }
365    if (i != num_pixels) {
366      VP8LAddGreenToBlueAndRed_C(src + i, num_pixels - i, dst + i);
367    }
368  }
369  static void TransformColorInverse_SSE2(const VP8LMultipliers* const m,
370                                         const uint32_t* const src,
371                                         int num_pixels, uint32_t* dst) {
372  #define CST(X)  (((int16_t)(m->X << 8)) >> 5)   
373  #define MK_CST_16(HI, LO) \
374    _mm_set1_epi32((int)(((uint32_t)(HI) << 16) | ((LO) & 0xffff)))
375    const __m128i mults_rb = MK_CST_16(CST(green_to_red_), CST(green_to_blue_));
376    const __m128i mults_b2 = MK_CST_16(CST(red_to_blue_), 0);
377  #undef MK_CST_16
378  #undef CST
379    const __m128i mask_ag = _mm_set1_epi32(0xff00ff00);  
380    int i;
381    for (i = 0; i + 4 <= num_pixels; i += 4) {
382      const __m128i in = _mm_loadu_si128((const __m128i*)&src[i]); 
383      const __m128i A = _mm_and_si128(in, mask_ag);     
384      const __m128i B = _mm_shufflelo_epi16(A, _MM_SHUFFLE(2, 2, 0, 0));
385      const __m128i C = _mm_shufflehi_epi16(B, _MM_SHUFFLE(2, 2, 0, 0));  
386      const __m128i D = _mm_mulhi_epi16(C, mults_rb);    
387      const __m128i E = _mm_add_epi8(in, D);             
388      const __m128i F = _mm_slli_epi16(E, 8);            
389      const __m128i G = _mm_mulhi_epi16(F, mults_b2);    
390      const __m128i H = _mm_srli_epi32(G, 8);            
391      const __m128i I = _mm_add_epi8(H, F);              
392      const __m128i J = _mm_srli_epi16(I, 8);            
393      const __m128i out = _mm_or_si128(J, A);
394      _mm_storeu_si128((__m128i*)&dst[i], out);
395    }
396    if (i != num_pixels) {
397      VP8LTransformColorInverse_C(m, src + i, num_pixels - i, dst + i);
398    }
399  }
400  static void ConvertBGRAToRGB_SSE2(const uint32_t* src, int num_pixels,
401                                    uint8_t* dst) {
402    const __m128i* in = (const __m128i*)src;
403    __m128i* out = (__m128i*)dst;
404    while (num_pixels >= 32) {
405      __m128i in0 = _mm_loadu_si128(in + 0);
406      __m128i in1 = _mm_loadu_si128(in + 1);
407      __m128i in2 = _mm_loadu_si128(in + 2);
408      __m128i in3 = _mm_loadu_si128(in + 3);
409      __m128i in4 = _mm_loadu_si128(in + 4);
410      __m128i in5 = _mm_loadu_si128(in + 5);
411      __m128i in6 = _mm_loadu_si128(in + 6);
412      __m128i in7 = _mm_loadu_si128(in + 7);
413      VP8L32bToPlanar_SSE2(&in0, &in1, &in2, &in3);
414      VP8L32bToPlanar_SSE2(&in4, &in5, &in6, &in7);
415      VP8PlanarTo24b_SSE2(&in1, &in5, &in2, &in6, &in3, &in7);
416      _mm_storeu_si128(out + 0, in1);
417      _mm_storeu_si128(out + 1, in5);
418      _mm_storeu_si128(out + 2, in2);
419      _mm_storeu_si128(out + 3, in6);
420      _mm_storeu_si128(out + 4, in3);
421      _mm_storeu_si128(out + 5, in7);
422      in += 8;
423      out += 6;
424      num_pixels -= 32;
425    }
426    if (num_pixels > 0) {
427      VP8LConvertBGRAToRGB_C((const uint32_t*)in, num_pixels, (uint8_t*)out);
428    }
429  }
430  static void ConvertBGRAToRGBA_SSE2(const uint32_t* src,
431                                     int num_pixels, uint8_t* dst) {
432    const __m128i red_blue_mask = _mm_set1_epi32(0x00ff00ffu);
433    const __m128i* in = (const __m128i*)src;
434    __m128i* out = (__m128i*)dst;
435    while (num_pixels >= 8) {
436      const __m128i A1 = _mm_loadu_si128(in++);
437      const __m128i A2 = _mm_loadu_si128(in++);
438      const __m128i B1 = _mm_and_si128(A1, red_blue_mask);     
439      const __m128i B2 = _mm_and_si128(A2, red_blue_mask);     
440      const __m128i C1 = _mm_andnot_si128(red_blue_mask, A1);  
441      const __m128i C2 = _mm_andnot_si128(red_blue_mask, A2);  
442      const __m128i D1 = _mm_shufflelo_epi16(B1, _MM_SHUFFLE(2, 3, 0, 1));
443      const __m128i D2 = _mm_shufflelo_epi16(B2, _MM_SHUFFLE(2, 3, 0, 1));
444      const __m128i E1 = _mm_shufflehi_epi16(D1, _MM_SHUFFLE(2, 3, 0, 1));
445      const __m128i E2 = _mm_shufflehi_epi16(D2, _MM_SHUFFLE(2, 3, 0, 1));
446      const __m128i F1 = _mm_or_si128(E1, C1);
447      const __m128i F2 = _mm_or_si128(E2, C2);
448      _mm_storeu_si128(out++, F1);
449      _mm_storeu_si128(out++, F2);
450      num_pixels -= 8;
451    }
452    if (num_pixels > 0) {
453      VP8LConvertBGRAToRGBA_C((const uint32_t*)in, num_pixels, (uint8_t*)out);
454    }
455  }
456  static void ConvertBGRAToRGBA4444_SSE2(const uint32_t* src,
457                                         int num_pixels, uint8_t* dst) {
458    const __m128i mask_0x0f = _mm_set1_epi8(0x0f);
459    const __m128i mask_0xf0 = _mm_set1_epi8(0xf0);
460    const __m128i* in = (const __m128i*)src;
461    __m128i* out = (__m128i*)dst;
462    while (num_pixels >= 8) {
463      const __m128i bgra0 = _mm_loadu_si128(in++);     
464      const __m128i bgra4 = _mm_loadu_si128(in++);     
465      const __m128i v0l = _mm_unpacklo_epi8(bgra0, bgra4);  
466      const __m128i v0h = _mm_unpackhi_epi8(bgra0, bgra4);  
467      const __m128i v1l = _mm_unpacklo_epi8(v0l, v0h);    
468      const __m128i v1h = _mm_unpackhi_epi8(v0l, v0h);    
469      const __m128i v2l = _mm_unpacklo_epi8(v1l, v1h);    
470      const __m128i v2h = _mm_unpackhi_epi8(v1l, v1h);    
471      const __m128i ga0 = _mm_unpackhi_epi64(v2l, v2h);   
472      const __m128i rb0 = _mm_unpacklo_epi64(v2h, v2l);   
473      const __m128i ga1 = _mm_srli_epi16(ga0, 4);         
474      const __m128i rb1 = _mm_and_si128(rb0, mask_0xf0);  
475      const __m128i ga2 = _mm_and_si128(ga1, mask_0x0f);  
476      const __m128i rgba0 = _mm_or_si128(ga2, rb1);       
477      const __m128i rgba1 = _mm_srli_si128(rgba0, 8);     
478  #if (WEBP_SWAP_16BIT_CSP == 1)
479      const __m128i rgba = _mm_unpacklo_epi8(rgba1, rgba0);  
480  #else
481      const __m128i rgba = _mm_unpacklo_epi8(rgba0, rgba1);  
482  #endif
483      _mm_storeu_si128(out++, rgba);
484      num_pixels -= 8;
485    }
486    if (num_pixels > 0) {
487      VP8LConvertBGRAToRGBA4444_C((const uint32_t*)in, num_pixels, (uint8_t*)out);
488    }
489  }
490  static void ConvertBGRAToRGB565_SSE2(const uint32_t* src,
491                                       int num_pixels, uint8_t* dst) {
492    const __m128i mask_0xe0 = _mm_set1_epi8(0xe0);
493    const __m128i mask_0xf8 = _mm_set1_epi8(0xf8);
494    const __m128i mask_0x07 = _mm_set1_epi8(0x07);
495    const __m128i* in = (const __m128i*)src;
496    __m128i* out = (__m128i*)dst;
497    while (num_pixels >= 8) {
498      const __m128i bgra0 = _mm_loadu_si128(in++);     
499      const __m128i bgra4 = _mm_loadu_si128(in++);     
500      const __m128i v0l = _mm_unpacklo_epi8(bgra0, bgra4);  
501      const __m128i v0h = _mm_unpackhi_epi8(bgra0, bgra4);  
502      const __m128i v1l = _mm_unpacklo_epi8(v0l, v0h);      
<span onclick='openModal()' class='match'>503      const __m128i v1h = _mm_unpackhi_epi8(v0l, v0h);      
504      const __m128i v2l = _mm_unpacklo_epi8(v1l, v1h);      
505      const __m128i v2h = _mm_unpackhi_epi8(v1l, v1h);      
506      const __m128i ga0 = _mm_unpackhi_epi64(v2l, v2h);     
507      const __m128i rb0 = _mm_unpacklo_epi64(v2h, v2l);     
508      const __m128i rb1 = _mm_and_si128(rb0, mask_0xf8);    
509      const __m128i g_lo1 = _mm_srli_epi16(ga0, 5);
510      const __m128i g_lo2 = _mm_and_si128(g_lo1, mask_0x07);  
511      const __m128i g_hi1 = _mm_slli_epi16(ga0, 3);
512      const __m128i g_hi2 = _mm_and_si128(g_hi1, mask_0xe0);  
513      const __m128i b0 = _mm_srli_si128(rb1, 8);              
514      const __m128i rg1 = _mm_or_si128(rb1, g_lo2);           
515      const __m128i b1 = _mm_srli_epi16(b0, 3);
516      const __m128i gb1 = _mm_or_si128(b1, g_hi2);            
517  #if (WEBP_SWAP_16BIT_CSP == 1)
518      const __m128i rgba = _mm_unpacklo_epi8(gb1, rg1);     
519  #else
520      const __m128i rgba = _mm_unpacklo_epi8(rg1, gb1);     
521  #endif
522      _mm_storeu_si128(out++, rgba);
</span>523      num_pixels -= 8;
524    }
525    if (num_pixels > 0) {
526      VP8LConvertBGRAToRGB565_C((const uint32_t*)in, num_pixels, (uint8_t*)out);
527    }
528  }
529  static void ConvertBGRAToBGR_SSE2(const uint32_t* src,
530                                    int num_pixels, uint8_t* dst) {
531    const __m128i mask_l = _mm_set_epi32(0, 0x00ffffff, 0, 0x00ffffff);
532    const __m128i mask_h = _mm_set_epi32(0x00ffffff, 0, 0x00ffffff, 0);
533    const __m128i* in = (const __m128i*)src;
534    const uint8_t* const end = dst + num_pixels * 3;
535    while (dst + 26 <= end) {
536      const __m128i bgra0 = _mm_loadu_si128(in++);     
537      const __m128i bgra4 = _mm_loadu_si128(in++);     
538      const __m128i a0l = _mm_and_si128(bgra0, mask_l);   
539      const __m128i a4l = _mm_and_si128(bgra4, mask_l);   
540      const __m128i a0h = _mm_and_si128(bgra0, mask_h);   
541      const __m128i a4h = _mm_and_si128(bgra4, mask_h);   
542      const __m128i b0h = _mm_srli_epi64(a0h, 8);         
543      const __m128i b4h = _mm_srli_epi64(a4h, 8);         
544      const __m128i c0 = _mm_or_si128(a0l, b0h);          
545      const __m128i c4 = _mm_or_si128(a4l, b4h);          
546      const __m128i c2 = _mm_srli_si128(c0, 8);
547      const __m128i c6 = _mm_srli_si128(c4, 8);
548      _mm_storel_epi64((__m128i*)(dst +   0), c0);
549      _mm_storel_epi64((__m128i*)(dst +   6), c2);
550      _mm_storel_epi64((__m128i*)(dst +  12), c4);
551      _mm_storel_epi64((__m128i*)(dst +  18), c6);
552      dst += 24;
553      num_pixels -= 8;
554    }
555    if (num_pixels > 0) {
556      VP8LConvertBGRAToBGR_C((const uint32_t*)in, num_pixels, dst);
557    }
558  }
559  extern void VP8LDspInitSSE2(void);
560  WEBP_TSAN_IGNORE_FUNCTION void VP8LDspInitSSE2(void) {
561    VP8LPredictors[5] = Predictor5_SSE2;
562    VP8LPredictors[6] = Predictor6_SSE2;
563    VP8LPredictors[7] = Predictor7_SSE2;
564    VP8LPredictors[8] = Predictor8_SSE2;
565    VP8LPredictors[9] = Predictor9_SSE2;
566    VP8LPredictors[10] = Predictor10_SSE2;
567    VP8LPredictors[11] = Predictor11_SSE2;
568    VP8LPredictors[12] = Predictor12_SSE2;
569    VP8LPredictors[13] = Predictor13_SSE2;
570    VP8LPredictorsAdd[0] = PredictorAdd0_SSE2;
571    VP8LPredictorsAdd[1] = PredictorAdd1_SSE2;
572    VP8LPredictorsAdd[2] = PredictorAdd2_SSE2;
573    VP8LPredictorsAdd[3] = PredictorAdd3_SSE2;
574    VP8LPredictorsAdd[4] = PredictorAdd4_SSE2;
575    VP8LPredictorsAdd[5] = PredictorAdd5_SSE2;
576    VP8LPredictorsAdd[6] = PredictorAdd6_SSE2;
577    VP8LPredictorsAdd[7] = PredictorAdd7_SSE2;
578    VP8LPredictorsAdd[8] = PredictorAdd8_SSE2;
579    VP8LPredictorsAdd[9] = PredictorAdd9_SSE2;
580    VP8LPredictorsAdd[10] = PredictorAdd10_SSE2;
581    VP8LPredictorsAdd[11] = PredictorAdd11_SSE2;
582    VP8LPredictorsAdd[12] = PredictorAdd12_SSE2;
583    VP8LPredictorsAdd[13] = PredictorAdd13_SSE2;
584    VP8LAddGreenToBlueAndRed = AddGreenToBlueAndRed_SSE2;
585    VP8LTransformColorInverse = TransformColorInverse_SSE2;
586    VP8LConvertBGRAToRGB = ConvertBGRAToRGB_SSE2;
587    VP8LConvertBGRAToRGBA = ConvertBGRAToRGBA_SSE2;
588    VP8LConvertBGRAToRGBA4444 = ConvertBGRAToRGBA4444_SSE2;
589    VP8LConvertBGRAToRGB565 = ConvertBGRAToRGB565_SSE2;
590    VP8LConvertBGRAToBGR = ConvertBGRAToBGR_SSE2;
591  }
592  #else  
593  WEBP_DSP_INIT_STUB(VP8LDspInitSSE2)
594  #endif  
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from PINRemoteImage-MDEwOlJlcG9zaXRvcnkzOTUzNzEwMw==-flat-yuv_sse41.c</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from PINRemoteImage-MDEwOlJlcG9zaXRvcnkzOTUzNzEwMw==-flat-lossless_sse2.c</div>
                </div>
                <div class="column column_space"><pre><code>16    const __m128i k17685 = _mm_set1_epi16(17685);
17    const __m128i k6419  = _mm_set1_epi16(6419);
18    const __m128i k13320 = _mm_set1_epi16(13320);
19    const __m128i k8708  = _mm_set1_epi16(8708);
20    const __m128i Y1 = _mm_mulhi_epu16(*Y0, k19077);
21    const __m128i R0 = _mm_mulhi_epu16(*V0, k26149);
22    const __m128i R1 = _mm_sub_epi16(Y1, k14234);
23    const __m128i R2 = _mm_add_epi16(R1, R0);
24    const __m128i G0 = _mm_mulhi_epu16(*U0, k6419);
25    const __m128i G1 = _mm_mulhi_epu16(*V0, k13320);
26    const __m128i G2 = _mm_add_epi16(Y1, k8708);
27    const __m128i G3 = _mm_add_epi16(G0, G1);
28    const __m128i G4 = _mm_sub_epi16(G2, G3);
29    const __m128i B0 = _mm_mulhi_epu16(*U0, k33050);
30    const __m128i B1 = _mm_adds_epu16(B0, Y1);
31    const __m128i B2 = _mm_subs_epu16(B1, k17685);
32    *R = _mm_srai_epi16(R2, 6);   
</pre></code></div>
                <div class="column column_space"><pre><code>503      const __m128i v1h = _mm_unpackhi_epi8(v0l, v0h);      
504      const __m128i v2l = _mm_unpacklo_epi8(v1l, v1h);      
505      const __m128i v2h = _mm_unpackhi_epi8(v1l, v1h);      
506      const __m128i ga0 = _mm_unpackhi_epi64(v2l, v2h);     
507      const __m128i rb0 = _mm_unpacklo_epi64(v2h, v2l);     
508      const __m128i rb1 = _mm_and_si128(rb0, mask_0xf8);    
509      const __m128i g_lo1 = _mm_srli_epi16(ga0, 5);
510      const __m128i g_lo2 = _mm_and_si128(g_lo1, mask_0x07);  
511      const __m128i g_hi1 = _mm_slli_epi16(ga0, 3);
512      const __m128i g_hi2 = _mm_and_si128(g_hi1, mask_0xe0);  
513      const __m128i b0 = _mm_srli_si128(rb1, 8);              
514      const __m128i rg1 = _mm_or_si128(rb1, g_lo2);           
515      const __m128i b1 = _mm_srli_epi16(b0, 3);
516      const __m128i gb1 = _mm_or_si128(b1, g_hi2);            
517  #if (WEBP_SWAP_16BIT_CSP == 1)
518      const __m128i rgba = _mm_unpacklo_epi8(gb1, rg1);     
519  #else
520      const __m128i rgba = _mm_unpacklo_epi8(rg1, gb1);     
521  #endif
522      _mm_storeu_si128(out++, rgba);
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    