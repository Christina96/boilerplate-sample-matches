
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 5.9620596205962055%, Tokens: 11, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>libtomcrypt-MDEwOlJlcG9zaXRvcnk3NzcwMTE=-flat-der_encode_setof.c</h3>
            <pre><code>1  #include "tomcrypt_private.h"
2  #ifdef LTC_DER
3  struct edge {
4     unsigned char *start;
5     unsigned long  size;
6  };
7  static int s_qsort_helper(const void *a, const void *b)
8  {
9     struct edge   *A = (struct edge *)a, *B = (struct edge *)b;
10     int            r;
11     unsigned long  x;
12     r = XMEMCMP(A->start, B->start, MIN(A->size, B->size));
13     if (r == 0 && A->size != B->size) {
14        if (A->size > B->size) {
15           for (x = B->size; x < A->size; x++) {
16              if (A->start[x]) {
17                 return 1;
18              }
19           }
20        } else {
21           for (x = A->size; x < B->size; x++) {
22              if (B->start[x]) {
23                 return -1;
24              }
25           }
26        }
27     }
28     return r;
29  }
<span onclick='openModal()' class='match'>30  int der_encode_setof(const ltc_asn1_list *list, unsigned long inlen,
31                       unsigned char *out,        unsigned long *outlen)
32  {
33     unsigned long  x, y, z;
34     ptrdiff_t hdrlen;
35     int            err;
36     struct edge   *edges;
37     unsigned char *ptr, *buf;
</span>38     for (x = 1; x < inlen; x++) {
39        if (list[x].type != list[x-1].type) {
40           return CRYPT_INVALID_ARG;
41        }
42     }
43     buf = XCALLOC(1, *outlen);
44     if (buf == NULL) {
45        return CRYPT_MEM;
46     }
47     if ((err = der_encode_sequence_ex(list, inlen, buf, outlen, LTC_ASN1_SETOF)) != CRYPT_OK) {
48         XFREE(buf);
49         return err;
50     }
51     edges = XCALLOC(inlen, sizeof(*edges));
52     if (edges == NULL) {
53        XFREE(buf);
54        return CRYPT_MEM;
55     }
56     ptr = buf + 1;
57     x = *ptr++;
58     if (x >= 0x80) {
59        ptr += (x & 0x7F);
60     }
61     hdrlen = ptr - buf;
62     x = 0;
63     while (ptr < (buf + *outlen)) {
64        edges[x].start = ptr;
65        z = 1;
66        y = ptr[z++];
67        if (y < 128) {
68           edges[x].size = y;
69        } else {
70           y &= 0x7F;
71           edges[x].size = 0;
72           while (y--) {
73              edges[x].size = (edges[x].size << 8) | ((unsigned long)ptr[z++]);
74           }
75        }
76        edges[x].size += z;
77        ptr           += edges[x].size;
78        ++x;
79     }
80     XQSORT(edges, inlen, sizeof(*edges), &s_qsort_helper);
81     XMEMCPY(out, buf, hdrlen);
82     for (y = (unsigned long)hdrlen, x = 0; x < inlen; x++) {
83        XMEMCPY(out+y, edges[x].start, edges[x].size);
84        y += edges[x].size;
85     }
86  #ifdef LTC_CLEAN_STACK
87     zeromem(buf, *outlen);
88  #endif
89     XFREE(edges);
90     XFREE(buf);
91     return CRYPT_OK;
92  }
93  #endif
</code></pre>
        </div>
        <div class="column">
            <h3>redis-MDEwOlJlcG9zaXRvcnkxMDgxMTA3MDY=-flat-lstate.h</h3>
            <pre><code>1  #ifndef lstate_h
2  #define lstate_h
3  #include "lua.h"
4  #include "lobject.h"
5  #include "ltm.h"
6  #include "lzio.h"
7  struct lua_longjmp;  &bsol;* defined in ldo.c */
8  #define gt(L)	(&L->l_gt)
9  #define registry(L)	(&G(L)->l_registry)
10  #define EXTRA_STACK   5
11  #define BASIC_CI_SIZE           8
12  #define BASIC_STACK_SIZE        (2*LUA_MINSTACK)
13  typedef struct stringtable {
14    GCObject **hash;
15    lu_int32 nuse;  &bsol;* number of elements */
16    int size;
17  } stringtable;
18  typedef struct CallInfo {
19    StkId base;  &bsol;* base for this function */
20    StkId func;  &bsol;* function index in the stack */
21    StkId	top;  &bsol;* top for this function */
22    const Instruction *savedpc;
23    int nresults;  &bsol;* expected number of results from this function */
24    int tailcalls;  &bsol;* number of tail calls lost under this entry */
25  } CallInfo;
26  #define curr_func(L)	(clvalue(L->ci->func))
27  #define ci_func(ci)	(clvalue((ci)->func))
28  #define f_isLua(ci)	(!ci_func(ci)->c.isC)
29  #define isLua(ci)	(ttisfunction((ci)->func) && f_isLua(ci))
30  typedef struct global_State {
31    stringtable strt;  &bsol;* hash table for strings */
32    lua_Alloc frealloc;  &bsol;* function to reallocate memory */
33    void *ud;         &bsol;* auxiliary data to `frealloc' */
34    lu_byte currentwhite;
35    lu_byte gcstate;  &bsol;* state of garbage collector */
36    int sweepstrgc;  &bsol;* position of sweep in `strt' */
37    GCObject *rootgc;  &bsol;* list of all collectable objects */
38    GCObject **sweepgc;  &bsol;* position of sweep in `rootgc' */
39    GCObject *gray;  &bsol;* list of gray objects */
40    GCObject *grayagain;  &bsol;* list of objects to be traversed atomically */
41    GCObject *weak;  &bsol;* list of weak tables (to be cleared) */
42    GCObject *tmudata;  &bsol;* last element of list of userdata to be GC */
43    Mbuffer buff;  &bsol;* temporary buffer for string concatentation */
44    lu_mem GCthreshold;
45    lu_mem totalbytes;  &bsol;* number of bytes currently allocated */
46    lu_mem estimate;  &bsol;* an estimate of number of bytes actually in use */
47    lu_mem gcdept;  &bsol;* how much GC is `behind schedule' */
48    int gcpause;  &bsol;* size of pause between successive GCs */
49    int gcstepmul;  &bsol;* GC `granularity' */
50    lua_CFunction panic;  &bsol;* to be called in unprotected errors */
51    TValue l_registry;
52    struct lua_State *mainthread;
53    UpVal uvhead;  &bsol;* head of double-linked list of all open upvalues */
54    struct Table *mt[NUM_TAGS];  &bsol;* metatables for basic types */
55    TString *tmname[TM_N];  &bsol;* array with tag-method names */
56  } global_State;
<span onclick='openModal()' class='match'>57  struct lua_State {
58    CommonHeader;
59    lu_byte status;
60    StkId top;  &bsol;* first free slot in the stack */
61    StkId base;  &bsol;* base of current function */
</span>62    global_State *l_G;
63    CallInfo *ci;  &bsol;* call info for current function */
64    const Instruction *savedpc;  &bsol;* `savedpc' of current function */
65    StkId stack_last;  &bsol;* last free slot in the stack */
66    StkId stack;  &bsol;* stack base */
67    CallInfo *end_ci;  &bsol;* points after end of ci array*/
68    CallInfo *base_ci;  &bsol;* array of CallInfo's */
69    int stacksize;
70    int size_ci;  &bsol;* size of array `base_ci' */
71    unsigned short nCcalls;  &bsol;* number of nested C calls */
72    unsigned short baseCcalls;  &bsol;* nested C calls when resuming coroutine */
73    lu_byte hookmask;
74    lu_byte allowhook;
75    int basehookcount;
76    int hookcount;
77    lua_Hook hook;
78    TValue l_gt;  &bsol;* table of globals */
79    TValue env;  &bsol;* temporary place for environments */
80    GCObject *openupval;  &bsol;* list of open upvalues in this stack */
81    GCObject *gclist;
82    struct lua_longjmp *errorJmp;  &bsol;* current error recover point */
83    ptrdiff_t errfunc;  &bsol;* current error handling function (stack index) */
84  };
85  #define G(L)	(L->l_G)
86  union GCObject {
87    GCheader gch;
88    union TString ts;
89    union Udata u;
90    union Closure cl;
91    struct Table h;
92    struct Proto p;
93    struct UpVal uv;
94    struct lua_State th;  &bsol;* thread */
95  };
96  #define rawgco2ts(o)	check_exp((o)->gch.tt == LUA_TSTRING, &((o)->ts))
97  #define gco2ts(o)	(&rawgco2ts(o)->tsv)
98  #define rawgco2u(o)	check_exp((o)->gch.tt == LUA_TUSERDATA, &((o)->u))
99  #define gco2u(o)	(&rawgco2u(o)->uv)
100  #define gco2cl(o)	check_exp((o)->gch.tt == LUA_TFUNCTION, &((o)->cl))
101  #define gco2h(o)	check_exp((o)->gch.tt == LUA_TTABLE, &((o)->h))
102  #define gco2p(o)	check_exp((o)->gch.tt == LUA_TPROTO, &((o)->p))
103  #define gco2uv(o)	check_exp((o)->gch.tt == LUA_TUPVAL, &((o)->uv))
104  #define ngcotouv(o) \
105  	check_exp((o) == NULL || (o)->gch.tt == LUA_TUPVAL, &((o)->uv))
106  #define gco2th(o)	check_exp((o)->gch.tt == LUA_TTHREAD, &((o)->th))
107  #define obj2gco(v)	(cast(GCObject *, (v)))
108  LUAI_FUNC lua_State *luaE_newthread (lua_State *L);
109  LUAI_FUNC void luaE_freethread (lua_State *L, lua_State *L1);
110  #endif
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from libtomcrypt-MDEwOlJlcG9zaXRvcnk3NzcwMTE=-flat-der_encode_setof.c</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from redis-MDEwOlJlcG9zaXRvcnkxMDgxMTA3MDY=-flat-lstate.h</div>
                </div>
                <div class="column column_space"><pre><code>30  int der_encode_setof(const ltc_asn1_list *list, unsigned long inlen,
31                       unsigned char *out,        unsigned long *outlen)
32  {
33     unsigned long  x, y, z;
34     ptrdiff_t hdrlen;
35     int            err;
36     struct edge   *edges;
37     unsigned char *ptr, *buf;
</pre></code></div>
                <div class="column column_space"><pre><code>57  struct lua_State {
58    CommonHeader;
59    lu_byte status;
60    StkId top;  &bsol;* first free slot in the stack */
61    StkId base;  &bsol;* base of current function */
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    