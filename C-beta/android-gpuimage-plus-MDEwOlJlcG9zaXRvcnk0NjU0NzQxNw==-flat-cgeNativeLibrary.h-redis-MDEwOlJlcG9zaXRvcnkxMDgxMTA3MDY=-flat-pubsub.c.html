
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 10.933940774487471%, Tokens: 8, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>android-gpuimage-plus-MDEwOlJlcG9zaXRvcnk0NjU0NzQxNw==-flat-cgeNativeLibrary.h</h3>
            <pre><code>1  #include <jni.h>
2  #ifndef _Included_org_wysaid_nativePort_CGENativeLibrary
3  #define _Included_org_wysaid_nativePort_CGENativeLibrary
4  #ifdef __cplusplus
5  extern "C"
6  {
7  #endif
8  JNIEXPORT jobject JNICALL Java_org_wysaid_nativePort_CGENativeLibrary_cgeFilterImage_1MultipleEffects(JNIEnv*, jclass, jobject, jstring, jfloat);
9  JNIEXPORT void JNICALL Java_org_wysaid_nativePort_CGENativeLibrary_cgeFilterImage_1MultipleEffectsWriteBack(JNIEnv*, jclass, jobject, jstring, jfloat);
10  JNIEXPORT jlong JNICALL Java_org_wysaid_nativePort_CGENativeLibrary_cgeCreateFilterWithConfig(JNIEnv*, jclass, jstring);
11  JNIEXPORT void JNICALL Java_org_wysaid_nativePort_CGENativeLibrary_cgeDeleteFilterWithAddress(JNIEnv*, jclass, jlong);
<span onclick='openModal()' class='match'>12  JNIEXPORT jlong JNICALL Java_org_wysaid_nativePort_CGENativeLibrary_cgeCreateBlendFilter(JNIEnv*, jclass, jint, jint, jint, jint, jint, jfloat);
12  JNIEXPORT jlong JNICALL Java_org_wysaid_nativePort_CGENativeLibrary_cgeCreateBlendFilter(JNIEnv*, jclass, jint, jint, jint, jint, jint, jfloat);
</span>13  #ifdef __cplusplus
14  }
15  #endif
16  #endif
</code></pre>
        </div>
        <div class="column">
            <h3>redis-MDEwOlJlcG9zaXRvcnkxMDgxMTA3MDY=-flat-pubsub.c</h3>
            <pre><code>1  #include "server.h"
2  void freePubsubPattern(void *p) {
3      pubsubPattern *pat = p;
4      decrRefCount(pat->pattern);
5      zfree(pat);
6  }
7  int listMatchPubsubPattern(void *a, void *b) {
8      pubsubPattern *pa = a, *pb = b;
9      return (pa->client == pb->client) &&
10             (equalStringObjects(pa->pattern,pb->pattern));
11  }
12  int clientSubscriptionsCount(client *c) {
13      return (int)(dictSize(c->pubsub_channels)+                                  WIN_PORT_FIX &bsol;* cast (int) */
14             listLength(c->pubsub_patterns));
15  }
16  int pubsubSubscribeChannel(client *c, robj *channel) {
17      dictEntry *de;
18      list *clients = NULL;
19      int retval = 0;
20      if (dictAdd(c->pubsub_channels,channel,NULL) == DICT_OK) {
21          retval = 1;
22          incrRefCount(channel);
23          de = dictFind(server.pubsub_channels,channel);
24          if (de == NULL) {
25              clients = listCreate();
26              dictAdd(server.pubsub_channels,channel,clients);
27              incrRefCount(channel);
28          } else {
29              clients = dictGetVal(de);
30          }
31          listAddNodeTail(clients,c);
32      }
33      addReply(c,shared.mbulkhdr[3]);
34      addReply(c,shared.subscribebulk);
35      addReplyBulk(c,channel);
36      addReplyLongLong(c,clientSubscriptionsCount(c));
37      return retval;
38  }
39  int pubsubUnsubscribeChannel(client *c, robj *channel, int notify) {
40      dictEntry *de;
41      list *clients;
42      listNode *ln;
43      int retval = 0;
44      incrRefCount(channel); &bsol;* channel may be just a pointer to the same object
45                              we have in the hash tables. Protect it... */
46      if (dictDelete(c->pubsub_channels,channel) == DICT_OK) {
47          retval = 1;
48          de = dictFind(server.pubsub_channels,channel);
49          serverAssertWithInfo(c,NULL,de != NULL);
50          clients = dictGetVal(de);
51          ln = listSearchKey(clients,c);
52          serverAssertWithInfo(c,NULL,ln != NULL);
53          listDelNode(clients,ln);
54          if (listLength(clients) == 0) {
55              dictDelete(server.pubsub_channels,channel);
56          }
57      }
58      if (notify) {
59          addReply(c,shared.mbulkhdr[3]);
60          addReply(c,shared.unsubscribebulk);
61          addReplyBulk(c,channel);
62          addReplyLongLong(c,dictSize(c->pubsub_channels)+
63                         listLength(c->pubsub_patterns));
64      }
65      decrRefCount(channel); &bsol;* it is finally safe to release it */
66      return retval;
67  }
68  int pubsubSubscribePattern(client *c, robj *pattern) {
69      int retval = 0;
70      if (listSearchKey(c->pubsub_patterns,pattern) == NULL) {
71          retval = 1;
72          pubsubPattern *pat;
73          listAddNodeTail(c->pubsub_patterns,pattern);
74          incrRefCount(pattern);
75          pat = zmalloc(sizeof(*pat));
76          pat->pattern = getDecodedObject(pattern);
77          pat->client = c;
78          listAddNodeTail(server.pubsub_patterns,pat);
79      }
80      addReply(c,shared.mbulkhdr[3]);
81      addReply(c,shared.psubscribebulk);
82      addReplyBulk(c,pattern);
83      addReplyLongLong(c,clientSubscriptionsCount(c));
84      return retval;
85  }
86  int pubsubUnsubscribePattern(client *c, robj *pattern, int notify) {
87      listNode *ln;
88      pubsubPattern pat;
89      int retval = 0;
<span onclick='openModal()' class='match'>90      incrRefCount(pattern); &bsol;* Protect the object. May be the same we remove */
90      incrRefCount(pattern); &bsol;* Protect the object. May be the same we remove */
</span>91      if ((ln = listSearchKey(c->pubsub_patterns,pattern)) != NULL) {
92          retval = 1;
93          listDelNode(c->pubsub_patterns,ln);
94          pat.client = c;
95          pat.pattern = pattern;
96          ln = listSearchKey(server.pubsub_patterns,&pat);
97          listDelNode(server.pubsub_patterns,ln);
98      }
99      if (notify) {
100          addReply(c,shared.mbulkhdr[3]);
101          addReply(c,shared.punsubscribebulk);
102          addReplyBulk(c,pattern);
103          addReplyLongLong(c,dictSize(c->pubsub_channels)+
104                         listLength(c->pubsub_patterns));
105      }
106      decrRefCount(pattern);
107      return retval;
108  }
109  int pubsubUnsubscribeAllChannels(client *c, int notify) {
110      dictIterator *di = dictGetSafeIterator(c->pubsub_channels);
111      dictEntry *de;
112      int count = 0;
113      while((de = dictNext(di)) != NULL) {
114          robj *channel = dictGetKey(de);
115          count += pubsubUnsubscribeChannel(c,channel,notify);
116      }
117      if (notify && count == 0) {
118          addReply(c,shared.mbulkhdr[3]);
119          addReply(c,shared.unsubscribebulk);
120          addReply(c,shared.nullbulk);
121          addReplyLongLong(c,dictSize(c->pubsub_channels)+
122                         listLength(c->pubsub_patterns));
123      }
124      dictReleaseIterator(di);
125      return count;
126  }
127  int pubsubUnsubscribeAllPatterns(client *c, int notify) {
128      listNode *ln;
129      listIter li;
130      int count = 0;
131      listRewind(c->pubsub_patterns,&li);
132      while ((ln = listNext(&li)) != NULL) {
133          robj *pattern = ln->value;
134          count += pubsubUnsubscribePattern(c,pattern,notify);
135      }
136      if (notify && count == 0) {
137          addReply(c,shared.mbulkhdr[3]);
138          addReply(c,shared.punsubscribebulk);
139          addReply(c,shared.nullbulk);
140          addReplyLongLong(c,dictSize(c->pubsub_channels)+
141                         listLength(c->pubsub_patterns));
142      }
143      return count;
144  }
145  int pubsubPublishMessage(robj *channel, robj *message) {
146      int receivers = 0;
147      dictEntry *de;
148      listNode *ln;
149      listIter li;
150      de = dictFind(server.pubsub_channels,channel);
151      if (de) {
152          list *list = dictGetVal(de);
153          listNode *ln;
154          listIter li;
155          listRewind(list,&li);
156          while ((ln = listNext(&li)) != NULL) {
157              client *c = ln->value;
158              addReply(c,shared.mbulkhdr[3]);
159              addReply(c,shared.messagebulk);
160              addReplyBulk(c,channel);
161              addReplyBulk(c,message);
162              receivers++;
163          }
164      }
165      if (listLength(server.pubsub_patterns)) {
166          listRewind(server.pubsub_patterns,&li);
167          channel = getDecodedObject(channel);
168          while ((ln = listNext(&li)) != NULL) {
169              pubsubPattern *pat = ln->value;
170              if (stringmatchlen((char*)pat->pattern->ptr,
171                                  (int)sdslen(pat->pattern->ptr),                 WIN_PORT_FIX &bsol;* cast (int) */
172                                  (char*)channel->ptr,
173                                  (int)sdslen(channel->ptr),0)) {                 WIN_PORT_FIX &bsol;* cast (int) */
174                  addReply(pat->client,shared.mbulkhdr[4]);
175                  addReply(pat->client,shared.pmessagebulk);
176                  addReplyBulk(pat->client,pat->pattern);
177                  addReplyBulk(pat->client,channel);
178                  addReplyBulk(pat->client,message);
179                  receivers++;
180              }
181          }
182          decrRefCount(channel);
183      }
184      return receivers;
185  }
186  void subscribeCommand(client *c) {
187      int j;
188      for (j = 1; j < c->argc; j++)
189          pubsubSubscribeChannel(c,c->argv[j]);
190      c->flags |= CLIENT_PUBSUB;
191  }
192  void unsubscribeCommand(client *c) {
193      if (c->argc == 1) {
194          pubsubUnsubscribeAllChannels(c,1);
195      } else {
196          int j;
197          for (j = 1; j < c->argc; j++)
198              pubsubUnsubscribeChannel(c,c->argv[j],1);
199      }
200      if (clientSubscriptionsCount(c) == 0) c->flags &= ~CLIENT_PUBSUB;
201  }
202  void psubscribeCommand(client *c) {
203      int j;
204      for (j = 1; j < c->argc; j++)
205          pubsubSubscribePattern(c,c->argv[j]);
206      c->flags |= CLIENT_PUBSUB;
207  }
208  void punsubscribeCommand(client *c) {
209      if (c->argc == 1) {
210          pubsubUnsubscribeAllPatterns(c,1);
211      } else {
212          int j;
213          for (j = 1; j < c->argc; j++)
214              pubsubUnsubscribePattern(c,c->argv[j],1);
215      }
216      if (clientSubscriptionsCount(c) == 0) c->flags &= ~CLIENT_PUBSUB;
217  }
218  void publishCommand(client *c) {
219      int receivers = pubsubPublishMessage(c->argv[1],c->argv[2]);
220      if (server.cluster_enabled)
221          clusterPropagatePublish(c->argv[1],c->argv[2]);
222      else
223          forceCommandPropagation(c,PROPAGATE_REPL);
224      addReplyLongLong(c,receivers);
225  }
226  void pubsubCommand(client *c) {
227      if (c->argc == 2 && !strcasecmp(c->argv[1]->ptr,"help")) {
228          const char *help[] = {
229  "CHANNELS [<pattern>] -- Return the currently active channels matching a pattern (default: all).",
230  "NUMPAT -- Return number of subscriptions to patterns.",
231  "NUMSUB [channel-1 .. channel-N] -- Returns the number of subscribers for the specified channels (excluding patterns, default: none).",
232  NULL
233          };
234          addReplyHelp(c, help);
235      } else if (!strcasecmp(c->argv[1]->ptr,"channels") &&
236          (c->argc == 2 || c->argc == 3))
237      {
238          sds pat = (c->argc == 2) ? NULL : c->argv[2]->ptr;
239          dictIterator *di = dictGetIterator(server.pubsub_channels);
240          dictEntry *de;
241          PORT_LONG mblen = 0;
242          void *replylen;
243          replylen = addDeferredMultiBulkLength(c);
244          while((de = dictNext(di)) != NULL) {
245              robj *cobj = dictGetKey(de);
246              sds channel = cobj->ptr;
247              if (!pat || stringmatchlen(pat, (int)sdslen(pat),                   WIN_PORT_FIX &bsol;* cast (int) */
248                                         channel, (int)sdslen(channel),0))        WIN_PORT_FIX &bsol;* cast (int) */
249              {
250                  addReplyBulk(c,cobj);
251                  mblen++;
252              }
253          }
254          dictReleaseIterator(di);
255          setDeferredMultiBulkLength(c,replylen,mblen);
256      } else if (!strcasecmp(c->argv[1]->ptr,"numsub") && c->argc >= 2) {
257          int j;
258          addReplyMultiBulkLen(c,(c->argc-2)*2);
259          for (j = 2; j < c->argc; j++) {
260              list *l = dictFetchValue(server.pubsub_channels,c->argv[j]);
261              addReplyBulk(c,c->argv[j]);
262              addReplyLongLong(c,l ? listLength(l) : 0);
263          }
264      } else if (!strcasecmp(c->argv[1]->ptr,"numpat") && c->argc == 2) {
265          addReplyLongLong(c,listLength(server.pubsub_patterns));
266      } else {
267          addReplySubcommandSyntaxError(c);
268      }
269  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from android-gpuimage-plus-MDEwOlJlcG9zaXRvcnk0NjU0NzQxNw==-flat-cgeNativeLibrary.h</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from redis-MDEwOlJlcG9zaXRvcnkxMDgxMTA3MDY=-flat-pubsub.c</div>
                </div>
                <div class="column column_space"><pre><code>12  JNIEXPORT jlong JNICALL Java_org_wysaid_nativePort_CGENativeLibrary_cgeCreateBlendFilter(JNIEnv*, jclass, jint, jint, jint, jint, jint, jfloat);
12  JNIEXPORT jlong JNICALL Java_org_wysaid_nativePort_CGENativeLibrary_cgeCreateBlendFilter(JNIEnv*, jclass, jint, jint, jint, jint, jint, jfloat);
</pre></code></div>
                <div class="column column_space"><pre><code>90      incrRefCount(pattern); &bsol;* Protect the object. May be the same we remove */
90      incrRefCount(pattern); &bsol;* Protect the object. May be the same we remove */
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    