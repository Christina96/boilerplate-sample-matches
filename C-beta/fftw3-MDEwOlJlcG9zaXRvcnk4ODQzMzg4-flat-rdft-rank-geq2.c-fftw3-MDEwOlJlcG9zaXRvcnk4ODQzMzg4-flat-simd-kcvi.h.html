
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 9.67741935483871%, Tokens: 8, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>fftw3-MDEwOlJlcG9zaXRvcnk4ODQzMzg4-flat-rdft-rank-geq2.c</h3>
            <pre><code>1  #include "mpi-rdft.h"
2  typedef struct {
3       solver super;
4       int preserve_input; &bsol;* preserve input even if DESTROY_INPUT was passed */
5  } S;
6  typedef struct {
7       plan_mpi_rdft super;
8       plan *cld1, *cld2;
9       int preserve_input;
10  } P;
11  static void apply(const plan *ego_, R *I, R *O)
12  {
13       const P *ego = (const P *) ego_;
14       plan_rdft *cld1, *cld2;
15       cld1 = (plan_rdft *) ego->cld1;
16       if (ego->preserve_input) {
17  	  cld1->apply(ego->cld1, I, O);
18  	  I = O;
19       }
20       else
21  	  cld1->apply(ego->cld1, I, I);
22       cld2 = (plan_rdft *) ego->cld2;
<span onclick='openModal()' class='match'>23       cld2->apply(ego->cld2, I, O);
24  }
25  static int applicable(const S *ego, const problem *p_,
26  		      const planner *plnr)
27  {
28       const problem_mpi_rdft *p = (const problem_mpi_rdft *) p_;
</span>29       return (1
30  	     && p->sz->rnk > 1
31  	     && p->flags == 0 &bsol;* TRANSPOSED/SCRAMBLED_IN/OUT not supported */
32  	     && (!ego->preserve_input || (!NO_DESTROY_INPUTP(plnr)
33  					  && p->I != p->O))
34  	     && XM(is_local_after)(1, p->sz, IB)
35  	     && XM(is_local_after)(1, p->sz, OB)
36  	     && (!NO_SLOWP(plnr) &bsol;* slow if rdft-serial is applicable */
37  		 || !XM(rdft_serial_applicable)(p))
38  	  );
39  }
40  static void awake(plan *ego_, enum wakefulness wakefulness)
41  {
42       P *ego = (P *) ego_;
43       X(plan_awake)(ego->cld1, wakefulness);
44       X(plan_awake)(ego->cld2, wakefulness);
45  }
46  static void destroy(plan *ego_)
47  {
48       P *ego = (P *) ego_;
49       X(plan_destroy_internal)(ego->cld2);
50       X(plan_destroy_internal)(ego->cld1);
51  }
52  static void print(const plan *ego_, printer *p)
53  {
54       const P *ego = (const P *) ego_;
55       p->print(p, "(mpi-rdft-rank-geq2%s%(%p%)%(%p%))", 
56  	      ego->preserve_input==2 ?"/p":"", ego->cld1, ego->cld2);
57  }
58  static plan *mkplan(const solver *ego_, const problem *p_, planner *plnr)
59  {
60       const S *ego = (const S *) ego_;
61       const problem_mpi_rdft *p;
62       P *pln;
63       plan *cld1 = 0, *cld2 = 0;
64       R *I, *O, *I2;
65       tensor *sz;
66       dtensor *sz2;
67       int i, my_pe, n_pes;
68       INT nrest;
69       static const plan_adt padt = {
70            XM(rdft_solve), awake, print, destroy
71       };
72       UNUSED(ego);
73       if (!applicable(ego, p_, plnr))
74            return (plan *) 0;
75       p = (const problem_mpi_rdft *) p_;
76       I2 = I = p->I;
77       O = p->O;
78       if (ego->preserve_input || NO_DESTROY_INPUTP(plnr)) 
79  	  I = O; 
80       MPI_Comm_rank(p->comm, &my_pe);
81       MPI_Comm_size(p->comm, &n_pes);
82       sz = X(mktensor)(p->sz->rnk - 1); &bsol;* tensor of last rnk-1 dimensions */
83       i = p->sz->rnk - 2; A(i >= 0);
84       sz->dims[i].n = p->sz->dims[i+1].n;
85       sz->dims[i].is = sz->dims[i].os = p->vn;
86       for (--i; i >= 0; --i) {
87  	  sz->dims[i].n = p->sz->dims[i+1].n;
88  	  sz->dims[i].is = sz->dims[i].os = sz->dims[i+1].n * sz->dims[i+1].is;
89       }
90       nrest = X(tensor_sz)(sz);
91       {
92            INT is = sz->dims[0].n * sz->dims[0].is;
93            INT b = XM(block)(p->sz->dims[0].n, p->sz->dims[0].b[IB], my_pe);
94  	  cld1 = X(mkplan_d)(plnr,
95                               X(mkproblem_rdft_d)(sz,
96  						 X(mktensor_2d)(b, is, is,
97  								p->vn, 1, 1),
98  						 I2, I, p->kind + 1));
99  	  if (XM(any_true)(!cld1, p->comm)) goto nada;
100       }
101       sz2 = XM(mkdtensor)(1); &bsol;* tensor for first (distributed) dimension */
102       sz2->dims[0] = p->sz->dims[0];
103       cld2 = X(mkplan_d)(plnr, XM(mkproblem_rdft_d)(sz2, nrest * p->vn,
104  						   I, O,
105  						   p->comm, p->kind,
106  						   RANK1_BIGVEC_ONLY));
107       if (XM(any_true)(!cld2, p->comm)) goto nada;
108       pln = MKPLAN_MPI_RDFT(P, &padt, apply);
109       pln->cld1 = cld1;
110       pln->cld2 = cld2;
111       pln->preserve_input = ego->preserve_input ? 2 : NO_DESTROY_INPUTP(plnr);
112       X(ops_add)(&cld1->ops, &cld2->ops, &pln->super.super.ops);
113       return &(pln->super.super);
114   nada:
115       X(plan_destroy_internal)(cld2);
116       X(plan_destroy_internal)(cld1);
117       return (plan *) 0;
118  }
119  static solver *mksolver(int preserve_input)
120  {
121       static const solver_adt sadt = { PROBLEM_MPI_RDFT, mkplan, 0 };
122       S *slv = MKSOLVER(S, &sadt);
123       slv->preserve_input = preserve_input;
124       return &(slv->super);
125  }
126  void XM(rdft_rank_geq2_register)(planner *p)
127  {
128       int preserve_input;
129       for (preserve_input = 0; preserve_input <= 1; ++preserve_input)
130  	  REGISTER_SOLVER(p, mksolver(preserve_input));
131  }
</code></pre>
        </div>
        <div class="column">
            <h3>fftw3-MDEwOlJlcG9zaXRvcnk4ODQzMzg4-flat-simd-kcvi.h</h3>
            <pre><code>1  #if defined(FFTW_LDOUBLE) || defined(FFTW_QUAD)
2  #error "Knights Corner vector instructions only works in single or double precision"
3  #endif
4  #ifdef FFTW_SINGLE
5  #  define DS(d,s) s &bsol;* single-precision option */
6  #  define SUFF(name) name ## _ps
7  #  define SCAL(x) x ## f
8  #else &bsol;* !FFTW_SINGLE */
9  #  define DS(d,s) d &bsol;* double-precision option */
10  #  define SUFF(name) name ## _pd
11  #  define SCAL(x) x
12  #endif &bsol;* FFTW_SINGLE */
13  #define SIMD_SUFFIX  _kcvi  &bsol;* for renaming */
14  #define VL DS(4, 8)        &bsol;* SIMD complex vector length */
15  #define SIMD_VSTRIDE_OKA(x) ((x) == 2) 
16  #define SIMD_STRIDE_OKPAIR SIMD_STRIDE_OK
17  #define KCVI_VBYI_SINGLE_USE_MUL 0
18  #define KCVI_VBYI_DOUBLE_USE_MUL 0
19  #define KCVI_LD_DOUBLE_USE_UNPACK 1
20  #define KCVI_ST_DOUBLE_USE_PACK 1
21  #define KCVI_ST2_DOUBLE_USE_STN2 0
22  #define KCVI_MULZ_USE_SWIZZLE 1
23  #include <immintrin.h>
24  typedef DS(__m512d, __m512) V;
25  #define VADD(a,b) SUFF(_mm512_add)(a,b)
26  #define VSUB(a,b) SUFF(_mm512_sub)(a,b)
27  #define VMUL(a,b) SUFF(_mm512_mul)(a,b)
28  #define VFMA(a, b, c) SUFF(_mm512_fmadd)(a, b, c) 
29  #define VFMS(a, b, c) SUFF(_mm512_fmsub)(a, b, c) 
30  #define VFNMS(a, b, c) SUFF(_mm512_fnmadd)(a, b, c) 
31  #define LDK(x) x
32  #define VLIT(re, im) SUFF(_mm512_setr4)(im, re, im, re)
33  #define DVK(var, val) V var = SUFF(_mm512_set1)(val)
34  static inline V LDA(const R *x, INT ivs, const R *aligned_like) {
35    return SUFF(_mm512_load)(x);
36  }
37  static inline void STA(R *x, V v, INT ovs, const R *aligned_like) {
38    SUFF(_mm512_store)(x, v);
39  }
40  #if FFTW_SINGLE
41  #define VXOR(a,b) _mm512_xor_epi32(a,b)
42  static inline V LDu(const R *x, INT ivs, const R *aligned_like)
43  {
44    (void)aligned_like; &bsol;* UNUSED */
45    __m512i index = _mm512_set_epi32(7 * ivs + 1, 7 * ivs,
46                                     6 * ivs + 1, 6 * ivs,
47                                     5 * ivs + 1, 5 * ivs,
48                                     4 * ivs + 1, 4 * ivs,
49                                     3 * ivs + 1, 3 * ivs,
50                                     2 * ivs + 1, 2 * ivs,
51                                     1 * ivs + 1, 1 * ivs,
52                                     0 * ivs + 1, 0 * ivs);
53    return _mm512_i32gather_ps(index, x, _MM_SCALE_4);
54  }
55  static inline void STu(R *x, V v, INT ovs, const R *aligned_like)
56  {
57    (void)aligned_like; &bsol;* UNUSED */
58    __m512i index = _mm512_set_epi32(7 * ovs + 1, 7 * ovs,
59                                     6 * ovs + 1, 6 * ovs,
60                                     5 * ovs + 1, 5 * ovs,
61                                     4 * ovs + 1, 4 * ovs,
62                                     3 * ovs + 1, 3 * ovs,
63                                     2 * ovs + 1, 2 * ovs,
64                                     1 * ovs + 1, 1 * ovs,
65                                     0 * ovs + 1, 0 * ovs);
66    _mm512_i32scatter_ps(x, index, v, _MM_SCALE_4);
67  }
68  static inline V FLIP_RI(V x)
69  {
<span onclick='openModal()' class='match'>70    return (V)_mm512_shuffle_epi32((__m512i)x, _MM_PERM_CDAB);
71  }
72  #define VDUPH(a) (V)_mm512_shuffle_epi32((__m512i)a, _MM_PERM_DDBB);
73  #define VDUPL(a) (V)_mm512_shuffle_epi32((__m512i)a, _MM_PERM_CCAA);
74  #else &bsol;* !FFTW_SINGLE */
75  #define VXOR(a,b) _mm512_xor_epi64(a,b)
76  #if defined (KCVI_LD_DOUBLE_USE_UNPACK) && KCVI_LD_DOUBLE_USE_UNPACK
77  static inline V LDu(const R *x, INT ivs, const R *aligned_like)
78  {
79    (void)aligned_like; &bsol;* UNUSED */
80    V temp;
81    temp = _mm512_mask_loadunpacklo_pd(temp, 0x0003, x + (0 * ivs));
</span>82    temp = _mm512_mask_loadunpacklo_pd(temp, 0x000c, x + (1 * ivs));
83    temp = _mm512_mask_loadunpacklo_pd(temp, 0x0030, x + (2 * ivs));
84    temp = _mm512_mask_loadunpacklo_pd(temp, 0x00c0, x + (3 * ivs));
85    return temp;
86  }
87  #else
88  static inline V LDu(const R *x, INT ivs, const R *aligned_like)
89  {
90    (void)aligned_like; &bsol;* UNUSED */
91    __declspec(align(64)) R temp[8]; 
92    int i;
93    for (i = 0 ; i < 4 ; i++) {
94      temp[i*2]   = x[i * ivs];
95      temp[i*2+1] = x[i * ivs + 1];
96    }
97    return _mm512_load_pd(temp);
98  }
99  #endif
100  #if defined(KCVI_ST_DOUBLE_USE_PACK) && KCVI_ST_DOUBLE_USE_PACK
101  static inline void STu(R *x, V v, INT ovs, const R *aligned_like)
102  {
103    (void)aligned_like; &bsol;* UNUSED */
104    _mm512_mask_packstorelo_pd(x + (0 * ovs), 0x0003, v);
105    _mm512_mask_packstorelo_pd(x + (1 * ovs), 0x000c, v);
106    _mm512_mask_packstorelo_pd(x + (2 * ovs), 0x0030, v);
107    _mm512_mask_packstorelo_pd(x + (3 * ovs), 0x00c0, v);
108  }
109  #else
110  static inline void STu(R *x, V v, INT ovs, const R *aligned_like)
111  {
112    (void)aligned_like; &bsol;* UNUSED */
113    __declspec(align(64)) R temp[8];
114    int i;
115    _mm512_store_pd(temp, v);
116    for (i = 0 ; i < 4 ; i++) {
117      x[i * ovs] = temp[i*2];
118      x[i * ovs + 1] = temp[i*2+1];
119    } 
120  }
121  #endif
122  static inline V FLIP_RI(V x)
123  {
124    return (V)_mm512_shuffle_epi32((__m512i)x, _MM_PERM_BADC);
125  }
126  #define VDUPH(a) (V)_mm512_shuffle_epi32((__m512i)a, _MM_PERM_DCDC);
127  #define VDUPL(a) (V)_mm512_shuffle_epi32((__m512i)a, _MM_PERM_BABA);
128  #endif &bsol;* FFTW_SINGLE */
129  #define LD LDu
130  #define ST STu
131  #ifdef FFTW_SINGLE
132  #define STM2(x, v, ovs, a) ST(x, v, ovs, a)
133  #define STN2(x, v0, v1, ovs) &bsol;* nop */
134  static inline void STM4(R *x, V v, INT ovs, const R *aligned_like)
135  {
136    (void)aligned_like; &bsol;* UNUSED */
137    __m512i index = _mm512_set_epi32(15 * ovs, 14 * ovs,
138                                     13 * ovs, 12 * ovs,
139                                     11 * ovs, 10 * ovs,
140                                     9 * ovs, 8 * ovs,
141                                     7 * ovs, 6 * ovs,
142                                     5 * ovs, 4 * ovs,
143                                     3 * ovs, 2 * ovs,
144                                     1 * ovs, 0 * ovs);
145    _mm512_i32scatter_ps(x, index, v, _MM_SCALE_4);
146  }
147  #define STN4(x, v0, v1, v2, v3, ovs)  &bsol;* no-op */
148  #else &bsol;* !FFTW_SINGLE */
149  #if defined(KCVI_ST2_DOUBLE_USE_STN2) && KCVI_ST2_DOUBLE_USE_STN2
150  #define STM2(x, v, ovs, a) &bsol;* no-op */
151  static inline void STN2(R *x, V v0, V v1, INT ovs) {
152    V x00 = (V)_mm512_mask_permute4f128_epi32((__m512i)v0, 0xF0F0, (__m512i)v1, _MM_PERM_CDAB);
153    V x01 = (V)_mm512_mask_permute4f128_epi32((__m512i)v1, 0x0F0F, (__m512i)v0, _MM_PERM_CDAB);
154    _mm512_mask_packstorelo_pd(x + (0 * ovs) + 0, 0x000F, x00);
155    _mm512_mask_packstorelo_pd(x + (2 * ovs) + 0, 0x00F0, x00);
156    _mm512_mask_packstorelo_pd(x + (1 * ovs) + 0, 0x000F, x01);
157    _mm512_mask_packstorelo_pd(x + (3 * ovs) + 0, 0x00F0, x01);
158  }
159  #else
160  #define STM2(x, v, ovs, a) ST(x, v, ovs, a)
161  #define STN2(x, v0, v1, ovs) &bsol;* nop */
162  #endif
163  static inline void STM4(R *x, V v, INT ovs, const R *aligned_like)
164  {
165    (void)aligned_like; &bsol;* UNUSED */
166    __m512i index = _mm512_set_epi32(0, 0, 0, 0, 0, 0, 0, 0,
167                                     7 * ovs, 6 * ovs,
168                                     5 * ovs, 4 * ovs,
169                                     3 * ovs, 2 * ovs,
170                                     1 * ovs, 0 * ovs);
171    _mm512_i32loscatter_pd(x, index, v, _MM_SCALE_8);
172  }
173  #define STN4(x, v0, v1, v2, v3, ovs)  &bsol;* no-op */
174  #endif &bsol;* FFTW_SINGLE */
175  static inline V VFMAI(V b, V c) {
176    V mpmp = VLIT(SCAL(1.0), SCAL(-1.0));
177    return SUFF(_mm512_fmadd)(mpmp, SUFF(_mm512_swizzle)(b, _MM_SWIZ_REG_CDAB), c);
178  }
179  static inline V VFNMSI(V b, V c) {
180    V mpmp = VLIT(SCAL(1.0), SCAL(-1.0));
181    return SUFF(_mm512_fnmadd)(mpmp, SUFF(_mm512_swizzle)(b, _MM_SWIZ_REG_CDAB), c);
182  }
183  static inline V VFMACONJ(V b, V c) {
184    V pmpm = VLIT(SCAL(-1.0), SCAL(1.0));
185    return SUFF(_mm512_fmadd)(pmpm, b, c);
186  }
187  static inline V VFMSCONJ(V b, V c) {
188    V pmpm = VLIT(SCAL(-1.0), SCAL(1.0));
189    return SUFF(_mm512_fmsub)(pmpm, b, c);
190  }
191  static inline V VFNMSCONJ(V b, V c) {
192    V pmpm = VLIT(SCAL(-1.0), SCAL(1.0));
193    return SUFF(_mm512_fnmadd)(pmpm, b, c);
194  }
195  static inline V VCONJ(V x)
196  {
197       V pmpm = VLIT(SCAL(-0.0), SCAL(0.0));
198       return (V)VXOR((__m512i)pmpm, (__m512i)x);
199  }
200  #ifdef FFTW_SINGLE
201  #if defined(KCVI_VBYI_SINGLE_USE_MUL) && KCVI_VBYI_SINGLE_USE_MUL
202  static inline V VBYI(V x)
203  {
204    V mpmp = VLIT(SCAL(1.0), SCAL(-1.0));
205    return _mm512_mul_ps(mpmp, _mm512_swizzle_ps(x, _MM_SWIZ_REG_CDAB));
206  }
207  #else
208  static inline V VBYI(V x)
209  {
210       return FLIP_RI(VCONJ(x));
211  }
212  #endif
213  #else &bsol;* !FFTW_SINGLE */
214  #if defined(KCVI_VBYI_DOUBLE_USE_MUL) && KCVI_VBYI_DOUBLE_USE_MUL
215  static inline V VBYI(V x)
216  {
217    V mpmp = VLIT(SCAL(1.0), SCAL(-1.0));
218    return _mm512_mul_pd(mpmp, _mm512_swizzle_pd(x, _MM_SWIZ_REG_CDAB));
219  }
220  #else
221  static inline V VBYI(V x)
222  {
223       return FLIP_RI(VCONJ(x));
224  }
225  #endif
226  #endif &bsol;* FFTW_SINGLE */
227  #if defined(KCVI_MULZ_USE_SWIZZLE) && KCVI_MULZ_USE_SWIZZLE
228  static inline V VZMUL(V tx, V sr) &bsol;* (a,b) (c,d) */
229  {
230    V ac = SUFF(_mm512_mul)(tx, sr); &bsol;* (a*c,b*d) */
231    V ad = SUFF(_mm512_mul)(tx, SUFF(_mm512_swizzle)(sr, _MM_SWIZ_REG_CDAB)); &bsol;* (a*d,b*c) */
232    V acmbd = SUFF(_mm512_sub)(ac, SUFF(_mm512_swizzle)(ac, _MM_SWIZ_REG_CDAB)); &bsol;* (a*c-b*d, b*d-a*c) */
233    V res = SUFF(_mm512_mask_add)(acmbd, DS(0x00aa,0xaaaa), ad, SUFF(_mm512_swizzle)(ad, _MM_SWIZ_REG_CDAB)); &bsol;* ([a*c+b*c] a*c-b*d, b*c+a*d) */
234    return res;
235  }
236  static inline V VZMULJ(V tx, V sr) &bsol;* (a,b) (c,d) */
237  {
238    V ac = SUFF(_mm512_mul)(tx, sr); &bsol;* (a*c,b*d) */
239    V ad = SUFF(_mm512_mul)(tx, SUFF(_mm512_swizzle)(sr, _MM_SWIZ_REG_CDAB)); &bsol;* (a*d,b*c) */
240    V acmbd = SUFF(_mm512_add)(ac, SUFF(_mm512_swizzle)(ac, _MM_SWIZ_REG_CDAB)); &bsol;* (a*c+b*d, b*d+a*c) */
241    V res = SUFF(_mm512_mask_subr)(acmbd, DS(0x00aa,0xaaaa), ad, SUFF(_mm512_swizzle)(ad, _MM_SWIZ_REG_CDAB)); &bsol;* ([a*c+b*c] a*c+b*d, a*d-b*c) */
242    return res;
243  }
244  static inline V VZMULI(V tx, V sr) &bsol;* (a,b) (c,d) */
245  {
246    DVK(zero, SCAL(0.0));
247    V ac = SUFF(_mm512_mul)(tx, sr); &bsol;* (a*c,b*d) */
248    V ad = SUFF(_mm512_fnmadd)(tx, SUFF(_mm512_swizzle)(sr, _MM_SWIZ_REG_CDAB), zero); &bsol;* (-a*d,-b*c) */
249    V acmbd = SUFF(_mm512_subr)(ac, SUFF(_mm512_swizzle)(ac, _MM_SWIZ_REG_CDAB)); &bsol;* (b*d-a*c, a*c-b*d) */
250    V res = SUFF(_mm512_mask_add)(acmbd, DS(0x0055,0x5555), ad, SUFF(_mm512_swizzle)(ad, _MM_SWIZ_REG_CDAB)); &bsol;*  (-a*d-b*c, a*c-b*d) */
251    return res;
252  }
253  static inline V VZMULIJ(V tx, V sr) &bsol;* (a,b) (c,d) */
254  {
255    DVK(zero, SCAL(0.0));
256    V ac = SUFF(_mm512_mul)(tx, sr); &bsol;* (a*c,b*d) */
257    V ad = SUFF(_mm512_fnmadd)(tx, SUFF(_mm512_swizzle)(sr, _MM_SWIZ_REG_CDAB), zero); &bsol;* (-a*d,-b*c) */
258    V acmbd = SUFF(_mm512_add)(ac, SUFF(_mm512_swizzle)(ac, _MM_SWIZ_REG_CDAB)); &bsol;* (b*d+a*c, a*c+b*d) */
259    V res = SUFF(_mm512_mask_sub)(acmbd, DS(0x0055,0x5555), ad, SUFF(_mm512_swizzle)(ad, _MM_SWIZ_REG_CDAB)); &bsol;*  (-a*d+b*c, a*c-b*d) */
260    return res;
261  }
262  #else
263  static inline V VZMUL(V tx, V sr)
264  {
265       V tr = VDUPL(tx);
266       V ti = VDUPH(tx);
267       tr = VMUL(sr, tr);
268       sr = VBYI(sr);
269       return VFMA(ti, sr, tr);
270  }
271  static inline V VZMULJ(V tx, V sr)
272  {
273       V tr = VDUPL(tx);
274       V ti = VDUPH(tx);
275       tr = VMUL(sr, tr);
276       sr = VBYI(sr);
277       return VFNMS(ti, sr, tr);
278  }
279  static inline V VZMULI(V tx, V sr)
280  {
281       V tr = VDUPL(tx);
282       V ti = VDUPH(tx);
283       ti = VMUL(ti, sr);
284       sr = VBYI(sr);
285       return VFMS(tr, sr, ti);
286  }
287  static inline V VZMULIJ(V tx, V sr)
288  {
289       V tr = VDUPL(tx);
290       V ti = VDUPH(tx);
291       ti = VMUL(ti, sr);
292       sr = VBYI(sr);
293       return VFMA(tr, sr, ti);
294  }
295  #endif
296  #ifdef FFTW_SINGLE
297  # define VTW1(v,x) {TW_CEXP, v, x}, {TW_CEXP, v+1, x}, {TW_CEXP, v+2, x}, {TW_CEXP, v+3, x}, {TW_CEXP, v+4, x}, {TW_CEXP, v+5, x}, {TW_CEXP, v+6, x}, {TW_CEXP, v+7, x}
298  #else &bsol;* !FFTW_SINGLE */
299  # define VTW1(v,x) {TW_CEXP, v, x}, {TW_CEXP, v+1, x}, {TW_CEXP, v+2, x}, {TW_CEXP, v+3, x}
300  #endif &bsol;* FFTW_SINGLE */
301  #define TWVL1 (VL)
302  static inline V BYTW1(const R *t, V sr)
303  {
304       return VZMUL(LDA(t, 2, t), sr);
305  }
306  static inline V BYTWJ1(const R *t, V sr)
307  {
308       return VZMULJ(LDA(t, 2, t), sr);
309  }
310  #ifdef FFTW_SINGLE
311  # define VTW2(v,x)							     \
312     {TW_COS, v  ,  x}, {TW_COS, v  , x}, {TW_COS, v+1,  x}, {TW_COS, v+1, x}, \
313     {TW_COS, v+2,  x}, {TW_COS, v+2, x}, {TW_COS, v+3,  x}, {TW_COS, v+3, x}, \
314     {TW_COS, v+4,  x}, {TW_COS, v+4, x}, {TW_COS, v+5,  x}, {TW_COS, v+5, x}, \
315     {TW_COS, v+6,  x}, {TW_COS, v+6, x}, {TW_COS, v+7,  x}, {TW_COS, v+7, x}, \
316     {TW_SIN, v  , -x}, {TW_SIN, v  , x}, {TW_SIN, v+1, -x}, {TW_SIN, v+1, x}, \
317     {TW_SIN, v+2, -x}, {TW_SIN, v+2, x}, {TW_SIN, v+3, -x}, {TW_SIN, v+3, x}, \
318     {TW_SIN, v+4, -x}, {TW_SIN, v+4, x}, {TW_SIN, v+5, -x}, {TW_SIN, v+5, x}, \
319     {TW_SIN, v+6, -x}, {TW_SIN, v+6, x}, {TW_SIN, v+7, -x}, {TW_SIN, v+7, x}
320  #else &bsol;* !FFTW_SINGLE */
321  # define VTW2(v,x)							     \
322     {TW_COS, v  ,  x}, {TW_COS, v  , x}, {TW_COS, v+1,  x}, {TW_COS, v+1, x}, \
323     {TW_COS, v+2,  x}, {TW_COS, v+2, x}, {TW_COS, v+3,  x}, {TW_COS, v+3, x}, \
324     {TW_SIN, v  , -x}, {TW_SIN, v  , x}, {TW_SIN, v+1, -x}, {TW_SIN, v+1, x}, \
325     {TW_SIN, v+2, -x}, {TW_SIN, v+2, x}, {TW_SIN, v+3, -x}, {TW_SIN, v+3, x}
326  #endif &bsol;* FFTW_SINGLE */
327  #define TWVL2 (2 * VL)
328  static inline V BYTW2(const R *t, V sr)
329  {
330       const V *twp = (const V *)t;
331       V si = FLIP_RI(sr);
332       V tr = twp[0], ti = twp[1];
333       return VFMA(tr, sr, VMUL(ti, si));
334  }
335  static inline V BYTWJ2(const R *t, V sr)
336  {
337       const V *twp = (const V *)t;
338       V si = FLIP_RI(sr);
339       V tr = twp[0], ti = twp[1];
340       return VFNMS(ti, si, VMUL(tr, sr));
341  }
342  #define VTW3(v,x) VTW1(v,x)
343  #define TWVL3 TWVL1
344  #ifdef FFTW_SINGLE
345  # define VTWS(v,x)                                                            \
346    {TW_COS, v   , x}, {TW_COS, v+1 , x}, {TW_COS, v+2 , x}, {TW_COS, v+3 , x}, \
347    {TW_COS, v+4 , x}, {TW_COS, v+5 , x}, {TW_COS, v+6 , x}, {TW_COS, v+7 , x}, \
348    {TW_COS, v+8 , x}, {TW_COS, v+9 , x}, {TW_COS, v+10, x}, {TW_COS, v+11, x}, \
349    {TW_COS, v+12, x}, {TW_COS, v+13, x}, {TW_COS, v+14, x}, {TW_COS, v+15, x}, \
350    {TW_SIN, v   , x}, {TW_SIN, v+1 , x}, {TW_SIN, v+2 , x}, {TW_SIN, v+3 , x}, \
351    {TW_SIN, v+4 , x}, {TW_SIN, v+5 , x}, {TW_SIN, v+6 , x}, {TW_SIN, v+7 , x}, \
352    {TW_SIN, v+8 , x}, {TW_SIN, v+9 , x}, {TW_SIN, v+10, x}, {TW_SIN, v+11, x}, \
353    {TW_SIN, v+12, x}, {TW_SIN, v+13, x}, {TW_SIN, v+14, x}, {TW_SIN, v+15, x}
354  #else &bsol;* !FFTW_SINGLE */
355  # define VTWS(v,x)							  \
356    {TW_COS, v  , x}, {TW_COS, v+1, x}, {TW_COS, v+2, x}, {TW_COS, v+3, x}, \
357    {TW_COS, v+4, x}, {TW_COS, v+5, x}, {TW_COS, v+6, x}, {TW_COS, v+7, x}, \
358    {TW_SIN, v  , x}, {TW_SIN, v+1, x}, {TW_SIN, v+2, x}, {TW_SIN, v+3, x}, \
359    {TW_SIN, v+4, x}, {TW_SIN, v+5, x}, {TW_SIN, v+6, x}, {TW_SIN, v+7, x}
360  #endif &bsol;* FFTW_SINGLE */
361  #define TWVLS (2 * VL)
362  #define VLEAVE() &bsol;* nothing */
363  #include "simd-common.h"
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from fftw3-MDEwOlJlcG9zaXRvcnk4ODQzMzg4-flat-rdft-rank-geq2.c</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from fftw3-MDEwOlJlcG9zaXRvcnk4ODQzMzg4-flat-simd-kcvi.h</div>
                </div>
                <div class="column column_space"><pre><code>23       cld2->apply(ego->cld2, I, O);
24  }
25  static int applicable(const S *ego, const problem *p_,
26  		      const planner *plnr)
27  {
28       const problem_mpi_rdft *p = (const problem_mpi_rdft *) p_;
</pre></code></div>
                <div class="column column_space"><pre><code>70    return (V)_mm512_shuffle_epi32((__m512i)x, _MM_PERM_CDAB);
71  }
72  #define VDUPH(a) (V)_mm512_shuffle_epi32((__m512i)a, _MM_PERM_DDBB);
73  #define VDUPL(a) (V)_mm512_shuffle_epi32((__m512i)a, _MM_PERM_CCAA);
74  #else &bsol;* !FFTW_SINGLE */
75  #define VXOR(a,b) _mm512_xor_epi64(a,b)
76  #if defined (KCVI_LD_DOUBLE_USE_UNPACK) && KCVI_LD_DOUBLE_USE_UNPACK
77  static inline V LDu(const R *x, INT ivs, const R *aligned_like)
78  {
79    (void)aligned_like; &bsol;* UNUSED */
80    V temp;
81    temp = _mm512_mask_loadunpacklo_pd(temp, 0x0003, x + (0 * ivs));
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    