
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 1.8671454219030519%, Tokens: 15, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>libtomcrypt-MDEwOlJlcG9zaXRvcnk3NzcwMTE=-flat-rmd320.c</h3>
            <pre><code>1  #include "tomcrypt_private.h"
2  #ifdef LTC_RIPEMD320
3  const struct ltc_hash_descriptor rmd320_desc =
4  {
5      "rmd320",
6      14,
7      40,
8      64,
9     { 0 },
10     0,
11      &rmd320_init,
12      &rmd320_process,
13      &rmd320_done,
14      &rmd320_test,
15      NULL
16  };
17  #define F(x, y, z)        ((x) ^ (y) ^ (z))
18  #define G(x, y, z)        (((x) & (y)) | (~(x) & (z)))
19  #define H(x, y, z)        (((x) | ~(y)) ^ (z))
20  #define I(x, y, z)        (((x) & (z)) | ((y) & ~(z)))
21  #define J(x, y, z)        ((x) ^ ((y) | ~(z)))
22  #define FF(a, b, c, d, e, x, s)        \
23        (a) += F((b), (c), (d)) + (x);\
24        (a) = ROLc((a), (s)) + (e);\
25        (c) = ROLc((c), 10);
26  #define GG(a, b, c, d, e, x, s)        \
27        (a) += G((b), (c), (d)) + (x) + 0x5a827999UL;\
28        (a) = ROLc((a), (s)) + (e);\
29        (c) = ROLc((c), 10);
30  #define HH(a, b, c, d, e, x, s)        \
31        (a) += H((b), (c), (d)) + (x) + 0x6ed9eba1UL;\
32        (a) = ROLc((a), (s)) + (e);\
33        (c) = ROLc((c), 10);
34  #define II(a, b, c, d, e, x, s)        \
35        (a) += I((b), (c), (d)) + (x) + 0x8f1bbcdcUL;\
36        (a) = ROLc((a), (s)) + (e);\
37        (c) = ROLc((c), 10);
38  #define JJ(a, b, c, d, e, x, s)        \
39        (a) += J((b), (c), (d)) + (x) + 0xa953fd4eUL;\
40        (a) = ROLc((a), (s)) + (e);\
41        (c) = ROLc((c), 10);
42  #define FFF(a, b, c, d, e, x, s)        \
43        (a) += F((b), (c), (d)) + (x);\
44        (a) = ROLc((a), (s)) + (e);\
45        (c) = ROLc((c), 10);
46  #define GGG(a, b, c, d, e, x, s)        \
47        (a) += G((b), (c), (d)) + (x) + 0x7a6d76e9UL;\
48        (a) = ROLc((a), (s)) + (e);\
49        (c) = ROLc((c), 10);
50  #define HHH(a, b, c, d, e, x, s)        \
51        (a) += H((b), (c), (d)) + (x) + 0x6d703ef3UL;\
52        (a) = ROLc((a), (s)) + (e);\
53        (c) = ROLc((c), 10);
54  #define III(a, b, c, d, e, x, s)        \
55        (a) += I((b), (c), (d)) + (x) + 0x5c4dd124UL;\
56        (a) = ROLc((a), (s)) + (e);\
57        (c) = ROLc((c), 10);
58  #define JJJ(a, b, c, d, e, x, s)        \
59        (a) += J((b), (c), (d)) + (x) + 0x50a28be6UL;\
60        (a) = ROLc((a), (s)) + (e);\
61        (c) = ROLc((c), 10);
62  #ifdef LTC_CLEAN_STACK
63  static int ss_rmd320_compress(hash_state *md, const unsigned char *buf)
64  #else
65  static int  s_rmd320_compress(hash_state *md, const unsigned char *buf)
66  #endif
67  {
68     ulong32 aa,bb,cc,dd,ee,aaa,bbb,ccc,ddd,eee,tmp,X[16];
69     int i;
70     for (i = 0; i < 16; i++){
71        LOAD32L(X[i], buf + (4 * i));
72     }
73     aa = md->rmd320.state[0];
74     bb = md->rmd320.state[1];
75     cc = md->rmd320.state[2];
76     dd = md->rmd320.state[3];
77     ee = md->rmd320.state[4];
78     aaa = md->rmd320.state[5];
79     bbb = md->rmd320.state[6];
80     ccc = md->rmd320.state[7];
81     ddd = md->rmd320.state[8];
82     eee = md->rmd320.state[9];
83     FF(aa, bb, cc, dd, ee, X[ 0], 11);
84     FF(ee, aa, bb, cc, dd, X[ 1], 14);
85     FF(dd, ee, aa, bb, cc, X[ 2], 15);
86     FF(cc, dd, ee, aa, bb, X[ 3], 12);
87     FF(bb, cc, dd, ee, aa, X[ 4],  5);
88     FF(aa, bb, cc, dd, ee, X[ 5],  8);
89     FF(ee, aa, bb, cc, dd, X[ 6],  7);
90     FF(dd, ee, aa, bb, cc, X[ 7],  9);
91     FF(cc, dd, ee, aa, bb, X[ 8], 11);
92     FF(bb, cc, dd, ee, aa, X[ 9], 13);
93     FF(aa, bb, cc, dd, ee, X[10], 14);
94     FF(ee, aa, bb, cc, dd, X[11], 15);
95     FF(dd, ee, aa, bb, cc, X[12],  6);
96     FF(cc, dd, ee, aa, bb, X[13],  7);
97     FF(bb, cc, dd, ee, aa, X[14],  9);
98     FF(aa, bb, cc, dd, ee, X[15],  8);
99     JJJ(aaa, bbb, ccc, ddd, eee, X[ 5],  8);
100     JJJ(eee, aaa, bbb, ccc, ddd, X[14],  9);
101     JJJ(ddd, eee, aaa, bbb, ccc, X[ 7],  9);
102     JJJ(ccc, ddd, eee, aaa, bbb, X[ 0], 11);
103     JJJ(bbb, ccc, ddd, eee, aaa, X[ 9], 13);
104     JJJ(aaa, bbb, ccc, ddd, eee, X[ 2], 15);
105     JJJ(eee, aaa, bbb, ccc, ddd, X[11], 15);
106     JJJ(ddd, eee, aaa, bbb, ccc, X[ 4],  5);
107     JJJ(ccc, ddd, eee, aaa, bbb, X[13],  7);
108     JJJ(bbb, ccc, ddd, eee, aaa, X[ 6],  7);
109     JJJ(aaa, bbb, ccc, ddd, eee, X[15],  8);
110     JJJ(eee, aaa, bbb, ccc, ddd, X[ 8], 11);
111     JJJ(ddd, eee, aaa, bbb, ccc, X[ 1], 14);
112     JJJ(ccc, ddd, eee, aaa, bbb, X[10], 14);
113     JJJ(bbb, ccc, ddd, eee, aaa, X[ 3], 12);
114     JJJ(aaa, bbb, ccc, ddd, eee, X[12],  6);
115     tmp = aa; aa = aaa; aaa = tmp;
116     GG(ee, aa, bb, cc, dd, X[ 7],  7);
117     GG(dd, ee, aa, bb, cc, X[ 4],  6);
118     GG(cc, dd, ee, aa, bb, X[13],  8);
119     GG(bb, cc, dd, ee, aa, X[ 1], 13);
120     GG(aa, bb, cc, dd, ee, X[10], 11);
121     GG(ee, aa, bb, cc, dd, X[ 6],  9);
122     GG(dd, ee, aa, bb, cc, X[15],  7);
123     GG(cc, dd, ee, aa, bb, X[ 3], 15);
124     GG(bb, cc, dd, ee, aa, X[12],  7);
125     GG(aa, bb, cc, dd, ee, X[ 0], 12);
126     GG(ee, aa, bb, cc, dd, X[ 9], 15);
127     GG(dd, ee, aa, bb, cc, X[ 5],  9);
128     GG(cc, dd, ee, aa, bb, X[ 2], 11);
129     GG(bb, cc, dd, ee, aa, X[14],  7);
130     GG(aa, bb, cc, dd, ee, X[11], 13);
131     GG(ee, aa, bb, cc, dd, X[ 8], 12);
132     III(eee, aaa, bbb, ccc, ddd, X[ 6],  9);
133     III(ddd, eee, aaa, bbb, ccc, X[11], 13);
134     III(ccc, ddd, eee, aaa, bbb, X[ 3], 15);
135     III(bbb, ccc, ddd, eee, aaa, X[ 7],  7);
136     III(aaa, bbb, ccc, ddd, eee, X[ 0], 12);
137     III(eee, aaa, bbb, ccc, ddd, X[13],  8);
138     III(ddd, eee, aaa, bbb, ccc, X[ 5],  9);
139     III(ccc, ddd, eee, aaa, bbb, X[10], 11);
140     III(bbb, ccc, ddd, eee, aaa, X[14],  7);
141     III(aaa, bbb, ccc, ddd, eee, X[15],  7);
142     III(eee, aaa, bbb, ccc, ddd, X[ 8], 12);
143     III(ddd, eee, aaa, bbb, ccc, X[12],  7);
144     III(ccc, ddd, eee, aaa, bbb, X[ 4],  6);
145     III(bbb, ccc, ddd, eee, aaa, X[ 9], 15);
146     III(aaa, bbb, ccc, ddd, eee, X[ 1], 13);
147     III(eee, aaa, bbb, ccc, ddd, X[ 2], 11);
148     tmp = bb; bb = bbb; bbb = tmp;
149     HH(dd, ee, aa, bb, cc, X[ 3], 11);
150     HH(cc, dd, ee, aa, bb, X[10], 13);
151     HH(bb, cc, dd, ee, aa, X[14],  6);
152     HH(aa, bb, cc, dd, ee, X[ 4],  7);
153     HH(ee, aa, bb, cc, dd, X[ 9], 14);
154     HH(dd, ee, aa, bb, cc, X[15],  9);
155     HH(cc, dd, ee, aa, bb, X[ 8], 13);
156     HH(bb, cc, dd, ee, aa, X[ 1], 15);
157     HH(aa, bb, cc, dd, ee, X[ 2], 14);
158     HH(ee, aa, bb, cc, dd, X[ 7],  8);
159     HH(dd, ee, aa, bb, cc, X[ 0], 13);
160     HH(cc, dd, ee, aa, bb, X[ 6],  6);
161     HH(bb, cc, dd, ee, aa, X[13],  5);
162     HH(aa, bb, cc, dd, ee, X[11], 12);
163     HH(ee, aa, bb, cc, dd, X[ 5],  7);
164     HH(dd, ee, aa, bb, cc, X[12],  5);
165     HHH(ddd, eee, aaa, bbb, ccc, X[15],  9);
166     HHH(ccc, ddd, eee, aaa, bbb, X[ 5],  7);
167     HHH(bbb, ccc, ddd, eee, aaa, X[ 1], 15);
168     HHH(aaa, bbb, ccc, ddd, eee, X[ 3], 11);
169     HHH(eee, aaa, bbb, ccc, ddd, X[ 7],  8);
170     HHH(ddd, eee, aaa, bbb, ccc, X[14],  6);
171     HHH(ccc, ddd, eee, aaa, bbb, X[ 6],  6);
172     HHH(bbb, ccc, ddd, eee, aaa, X[ 9], 14);
173     HHH(aaa, bbb, ccc, ddd, eee, X[11], 12);
174     HHH(eee, aaa, bbb, ccc, ddd, X[ 8], 13);
175     HHH(ddd, eee, aaa, bbb, ccc, X[12],  5);
176     HHH(ccc, ddd, eee, aaa, bbb, X[ 2], 14);
177     HHH(bbb, ccc, ddd, eee, aaa, X[10], 13);
178     HHH(aaa, bbb, ccc, ddd, eee, X[ 0], 13);
179     HHH(eee, aaa, bbb, ccc, ddd, X[ 4],  7);
180     HHH(ddd, eee, aaa, bbb, ccc, X[13],  5);
181     tmp = cc; cc = ccc; ccc = tmp;
182     II(cc, dd, ee, aa, bb, X[ 1], 11);
183     II(bb, cc, dd, ee, aa, X[ 9], 12);
184     II(aa, bb, cc, dd, ee, X[11], 14);
185     II(ee, aa, bb, cc, dd, X[10], 15);
186     II(dd, ee, aa, bb, cc, X[ 0], 14);
187     II(cc, dd, ee, aa, bb, X[ 8], 15);
188     II(bb, cc, dd, ee, aa, X[12],  9);
189     II(aa, bb, cc, dd, ee, X[ 4],  8);
190     II(ee, aa, bb, cc, dd, X[13],  9);
191     II(dd, ee, aa, bb, cc, X[ 3], 14);
192     II(cc, dd, ee, aa, bb, X[ 7],  5);
193     II(bb, cc, dd, ee, aa, X[15],  6);
194     II(aa, bb, cc, dd, ee, X[14],  8);
195     II(ee, aa, bb, cc, dd, X[ 5],  6);
196     II(dd, ee, aa, bb, cc, X[ 6],  5);
197     II(cc, dd, ee, aa, bb, X[ 2], 12);
198     GGG(ccc, ddd, eee, aaa, bbb, X[ 8], 15);
199     GGG(bbb, ccc, ddd, eee, aaa, X[ 6],  5);
200     GGG(aaa, bbb, ccc, ddd, eee, X[ 4],  8);
201     GGG(eee, aaa, bbb, ccc, ddd, X[ 1], 11);
202     GGG(ddd, eee, aaa, bbb, ccc, X[ 3], 14);
203     GGG(ccc, ddd, eee, aaa, bbb, X[11], 14);
204     GGG(bbb, ccc, ddd, eee, aaa, X[15],  6);
205     GGG(aaa, bbb, ccc, ddd, eee, X[ 0], 14);
206     GGG(eee, aaa, bbb, ccc, ddd, X[ 5],  6);
207     GGG(ddd, eee, aaa, bbb, ccc, X[12],  9);
208     GGG(ccc, ddd, eee, aaa, bbb, X[ 2], 12);
209     GGG(bbb, ccc, ddd, eee, aaa, X[13],  9);
210     GGG(aaa, bbb, ccc, ddd, eee, X[ 9], 12);
211     GGG(eee, aaa, bbb, ccc, ddd, X[ 7],  5);
212     GGG(ddd, eee, aaa, bbb, ccc, X[10], 15);
213     GGG(ccc, ddd, eee, aaa, bbb, X[14],  8);
<span onclick='openModal()' class='match'>214     tmp = dd; dd = ddd; ddd = tmp;
215     JJ(bb, cc, dd, ee, aa, X[ 4],  9);
216     JJ(aa, bb, cc, dd, ee, X[ 0], 15);
217     JJ(ee, aa, bb, cc, dd, X[ 5],  5);
218     JJ(dd, ee, aa, bb, cc, X[ 9], 11);
219     JJ(cc, dd, ee, aa, bb, X[ 7],  6);
220     JJ(bb, cc, dd, ee, aa, X[12],  8);
221     JJ(aa, bb, cc, dd, ee, X[ 2], 13);
222     JJ(ee, aa, bb, cc, dd, X[10], 12);
223     JJ(dd, ee, aa, bb, cc, X[14],  5);
224     JJ(cc, dd, ee, aa, bb, X[ 1], 12);
225     JJ(bb, cc, dd, ee, aa, X[ 3], 13);
226     JJ(aa, bb, cc, dd, ee, X[ 8], 14);
227     JJ(ee, aa, bb, cc, dd, X[11], 11);
228     JJ(dd, ee, aa, bb, cc, X[ 6],  8);
229     JJ(cc, dd, ee, aa, bb, X[15],  5);
230     JJ(bb, cc, dd, ee, aa, X[13],  6);
231     FFF(bbb, ccc, ddd, eee, aaa, X[12] ,  8);
232     FFF(aaa, bbb, ccc, ddd, eee, X[15] ,  5);
233     FFF(eee, aaa, bbb, ccc, ddd, X[10] , 12);
234     FFF(ddd, eee, aaa, bbb, ccc, X[ 4] ,  9);
235     FFF(ccc, ddd, eee, aaa, bbb, X[ 1] , 12);
236     FFF(bbb, ccc, ddd, eee, aaa, X[ 5] ,  5);
237     FFF(aaa, bbb, ccc, ddd, eee, X[ 8] , 14);
238     FFF(eee, aaa, bbb, ccc, ddd, X[ 7] ,  6);
239     FFF(ddd, eee, aaa, bbb, ccc, X[ 6] ,  8);
240     FFF(ccc, ddd, eee, aaa, bbb, X[ 2] , 13);
241     FFF(bbb, ccc, ddd, eee, aaa, X[13] ,  6);
242     FFF(aaa, bbb, ccc, ddd, eee, X[14] ,  5);
243     FFF(eee, aaa, bbb, ccc, ddd, X[ 0] , 15);
244     FFF(ddd, eee, aaa, bbb, ccc, X[ 3] , 13);
245     FFF(ccc, ddd, eee, aaa, bbb, X[ 9] , 11);
246     FFF(bbb, ccc, ddd, eee, aaa, X[11] , 11);
247     tmp = ee; ee = eee; eee = tmp;
248     md->rmd320.state[0] += aa;
249     md->rmd320.state[1] += bb;
250     md->rmd320.state[2] += cc;
251     md->rmd320.state[3] += dd;
252     md->rmd320.state[4] += ee;
253     md->rmd320.state[5] += aaa;
254     md->rmd320.state[6] += bbb;
255     md->rmd320.state[7] += ccc;
256     md->rmd320.state[8] += ddd;
257     md->rmd320.state[9] += eee;
258     return CRYPT_OK;
</span>259  }
260  #ifdef LTC_CLEAN_STACK
261  static int s_rmd320_compress(hash_state *md, const unsigned char *buf)
262  {
263     int err;
264     err = ss_rmd320_compress(md, buf);
265     burn_stack(sizeof(ulong32) * 27 + sizeof(int));
266     return err;
267  }
268  #endif
269  int rmd320_init(hash_state * md)
270  {
271     LTC_ARGCHK(md != NULL);
272     md->rmd320.state[0] = 0x67452301UL;
273     md->rmd320.state[1] = 0xefcdab89UL;
274     md->rmd320.state[2] = 0x98badcfeUL;
275     md->rmd320.state[3] = 0x10325476UL;
276     md->rmd320.state[4] = 0xc3d2e1f0UL;
277     md->rmd320.state[5] = 0x76543210UL;
278     md->rmd320.state[6] = 0xfedcba98UL;
279     md->rmd320.state[7] = 0x89abcdefUL;
280     md->rmd320.state[8] = 0x01234567UL;
281     md->rmd320.state[9] = 0x3c2d1e0fUL;
282     md->rmd320.curlen   = 0;
283     md->rmd320.length   = 0;
284     return CRYPT_OK;
285  }
286  HASH_PROCESS(rmd320_process, s_rmd320_compress, rmd320, 64)
287  int rmd320_done(hash_state * md, unsigned char *out)
288  {
289      int i;
290      LTC_ARGCHK(md  != NULL);
291      LTC_ARGCHK(out != NULL);
292      if (md->rmd320.curlen >= sizeof(md->rmd320.buf)) {
293         return CRYPT_INVALID_ARG;
294      }
295      md->rmd320.length += md->rmd320.curlen * 8;
296      md->rmd320.buf[md->rmd320.curlen++] = (unsigned char)0x80;
297      if (md->rmd320.curlen > 56) {
298          while (md->rmd320.curlen < 64) {
299              md->rmd320.buf[md->rmd320.curlen++] = (unsigned char)0;
300          }
301          s_rmd320_compress(md, md->rmd320.buf);
302          md->rmd320.curlen = 0;
303      }
304      while (md->rmd320.curlen < 56) {
305          md->rmd320.buf[md->rmd320.curlen++] = (unsigned char)0;
306      }
307      STORE64L(md->rmd320.length, md->rmd320.buf+56);
308      s_rmd320_compress(md, md->rmd320.buf);
309      for (i = 0; i < 10; i++) {
310          STORE32L(md->rmd320.state[i], out+(4*i));
311      }
312  #ifdef LTC_CLEAN_STACK
313      zeromem(md, sizeof(hash_state));
314  #endif
315      return CRYPT_OK;
316  }
317  int rmd320_test(void)
318  {
319  #ifndef LTC_TEST
320     return CRYPT_NOP;
321  #else
322     static const struct {
323          const char *msg;
324          unsigned char hash[40];
325     } tests[] = {
326     { "",
327       { 0x22, 0xd6, 0x5d, 0x56, 0x61, 0x53, 0x6c, 0xdc, 0x75, 0xc1,
328         0xfd, 0xf5, 0xc6, 0xde, 0x7b, 0x41, 0xb9, 0xf2, 0x73, 0x25,
329         0xeb, 0xc6, 0x1e, 0x85, 0x57, 0x17, 0x7d, 0x70, 0x5a, 0x0e,
330         0xc8, 0x80, 0x15, 0x1c, 0x3a, 0x32, 0xa0, 0x08, 0x99, 0xb8 }
331     },
332     { "a",
333       { 0xce, 0x78, 0x85, 0x06, 0x38, 0xf9, 0x26, 0x58, 0xa5, 0xa5,
334         0x85, 0x09, 0x75, 0x79, 0x92, 0x6d, 0xda, 0x66, 0x7a, 0x57,
335         0x16, 0x56, 0x2c, 0xfc, 0xf6, 0xfb, 0xe7, 0x7f, 0x63, 0x54,
336         0x2f, 0x99, 0xb0, 0x47, 0x05, 0xd6, 0x97, 0x0d, 0xff, 0x5d }
337     },
338     { "abc",
339       { 0xde, 0x4c, 0x01, 0xb3, 0x05, 0x4f, 0x89, 0x30, 0xa7, 0x9d,
340         0x09, 0xae, 0x73, 0x8e, 0x92, 0x30, 0x1e, 0x5a, 0x17, 0x08,
341         0x5b, 0xef, 0xfd, 0xc1, 0xb8, 0xd1, 0x16, 0x71, 0x3e, 0x74,
342         0xf8, 0x2f, 0xa9, 0x42, 0xd6, 0x4c, 0xdb, 0xc4, 0x68, 0x2d }
343     },
344     { "message digest",
345       { 0x3a, 0x8e, 0x28, 0x50, 0x2e, 0xd4, 0x5d, 0x42, 0x2f, 0x68,
346         0x84, 0x4f, 0x9d, 0xd3, 0x16, 0xe7, 0xb9, 0x85, 0x33, 0xfa,
347         0x3f, 0x2a, 0x91, 0xd2, 0x9f, 0x84, 0xd4, 0x25, 0xc8, 0x8d,
348         0x6b, 0x4e, 0xff, 0x72, 0x7d, 0xf6, 0x6a, 0x7c, 0x01, 0x97 }
349     },
350     { "abcdefghijklmnopqrstuvwxyz",
351       { 0xca, 0xbd, 0xb1, 0x81, 0x0b, 0x92, 0x47, 0x0a, 0x20, 0x93,
352         0xaa, 0x6b, 0xce, 0x05, 0x95, 0x2c, 0x28, 0x34, 0x8c, 0xf4,
353         0x3f, 0xf6, 0x08, 0x41, 0x97, 0x51, 0x66, 0xbb, 0x40, 0xed,
354         0x23, 0x40, 0x04, 0xb8, 0x82, 0x44, 0x63, 0xe6, 0xb0, 0x09 }
355     },
356     { "abcdbcdecdefdefgefghfghighijhijkijkljklmklmnlmnomnopnopq",
357       { 0xd0, 0x34, 0xa7, 0x95, 0x0c, 0xf7, 0x22, 0x02, 0x1b, 0xa4,
358         0xb8, 0x4d, 0xf7, 0x69, 0xa5, 0xde, 0x20, 0x60, 0xe2, 0x59,
359         0xdf, 0x4c, 0x9b, 0xb4, 0xa4, 0x26, 0x8c, 0x0e, 0x93, 0x5b,
360         0xbc, 0x74, 0x70, 0xa9, 0x69, 0xc9, 0xd0, 0x72, 0xa1, 0xac }
361     }
362     };
363     int i;
364     unsigned char tmp[40];
365     hash_state md;
366     for (i = 0; i < (int)(sizeof(tests)/sizeof(tests[0])); i++) {
367         rmd320_init(&md);
368         rmd320_process(&md, (unsigned char *)tests[i].msg, XSTRLEN(tests[i].msg));
369         rmd320_done(&md, tmp);
370         if (compare_testvector(tmp, sizeof(tmp), tests[i].hash, sizeof(tests[i].hash), "RIPEMD320", i)) {
371            return CRYPT_FAIL_TESTVECTOR;
372         }
373     }
374     return CRYPT_OK;
375  #endif
376  }
377  #endif
</code></pre>
        </div>
        <div class="column">
            <h3>libpcap-MDEwOlJlcG9zaXRvcnk5NDM1ODg3-flat-pcap-rpcap.c</h3>
            <pre><code>1  #ifdef HAVE_CONFIG_H
2  #include <config.h>
3  #endif
4  #include "ftmacros.h"
5  #include "diag-control.h"
6  #include <string.h>		&bsol;* for strlen(), ... */
7  #include <stdlib.h>		&bsol;* for malloc(), free(), ... */
8  #include <stdarg.h>		&bsol;* for functions with variable number of arguments */
9  #include <errno.h>		&bsol;* for the errno variable */
10  #include <limits.h>		&bsol;* for INT_MAX */
11  #include "sockutils.h"
12  #include "pcap-int.h"
13  #include "pcap-util.h"
14  #include "rpcap-protocol.h"
15  #include "pcap-rpcap.h"
16  #ifdef _WIN32
17  #include "charconv.h"		&bsol;* for utf_8_to_acp_truncated() */
18  #endif
19  #ifdef HAVE_OPENSSL
20  #include "sslutils.h"
21  #endif
22  #define PCAP_STATS_STANDARD	0	&bsol;* Used by pcap_stats_rpcap to see if we want standard or extended statistics */
23  #ifdef _WIN32
24  #define PCAP_STATS_EX		1	&bsol;* Used by pcap_stats_rpcap to see if we want standard or extended statistics */
25  #endif
26  struct activehosts
27  {
28  	struct sockaddr_storage host;
29  	SOCKET sockctrl;
30  	SSL *ssl;
31  	uint8_t protocol_version;
32  	int byte_swapped;
33  	struct activehosts *next;
34  };
35  static struct activehosts *activeHosts;
36  static SOCKET sockmain;
37  static SSL *ssl_main;
38  struct pcap_rpcap {
39  	int rmt_clientside;
40  	SOCKET rmt_sockctrl;		&bsol;* socket ID of the socket used for the control connection */
41  	SOCKET rmt_sockdata;		&bsol;* socket ID of the socket used for the data connection */
42  	SSL *ctrl_ssl, *data_ssl;	&bsol;* optional transport of rmt_sockctrl and rmt_sockdata via TLS */
43  	int rmt_flags;			&bsol;* we have to save flags, since they are passed by the pcap_open_live(), but they are used by the pcap_startcapture() */
44  	int rmt_capstarted;		&bsol;* 'true' if the capture is already started (needed to knoe if we have to call the pcap_startcapture() */
45  	char *currentfilter;		&bsol;* Pointer to a buffer (allocated at run-time) that stores the current filter. Needed when flag PCAP_OPENFLAG_NOCAPTURE_RPCAP is turned on. */
46  	uint8_t protocol_version;	&bsol;* negotiated protocol version */
47  	uint8_t uses_ssl;		&bsol;* User asked for rpcaps scheme */
48  	int byte_swapped;		&bsol;* Server byte order is swapped from ours */
49  	unsigned int TotNetDrops;	&bsol;* keeps the number of packets that have been dropped by the network */
50  	unsigned int TotCapt;
51  	struct pcap_stat stat;
52  	struct pcap *next;		&bsol;* list of open pcaps that need stuff cleared on close */
53  };
54  static struct pcap_stat *rpcap_stats_rpcap(pcap_t *p, struct pcap_stat *ps, int mode);
55  static int pcap_pack_bpffilter(pcap_t *fp, char *sendbuf, int *sendbufidx, struct bpf_program *prog);
56  static int pcap_createfilter_norpcappkt(pcap_t *fp, struct bpf_program *prog);
57  static int pcap_updatefilter_remote(pcap_t *fp, struct bpf_program *prog);
58  static void pcap_save_current_filter_rpcap(pcap_t *fp, const char *filter);
59  static int pcap_setfilter_rpcap(pcap_t *fp, struct bpf_program *prog);
60  static int pcap_setsampling_remote(pcap_t *fp);
61  static int pcap_startcapture_remote(pcap_t *fp);
62  static int rpcap_recv_msg_header(SOCKET sock, SSL *, struct rpcap_header *header, char *errbuf);
63  static int rpcap_check_msg_ver(SOCKET sock, SSL *, uint8_t expected_ver, struct rpcap_header *header, char *errbuf);
64  static int rpcap_check_msg_type(SOCKET sock, SSL *, uint8_t request_type, struct rpcap_header *header, uint16_t *errcode, char *errbuf);
65  static int rpcap_process_msg_header(SOCKET sock, SSL *, uint8_t ver, uint8_t request_type, struct rpcap_header *header, char *errbuf);
66  static int rpcap_recv(SOCKET sock, SSL *, void *buffer, size_t toread, uint32_t *plen, char *errbuf);
67  static void rpcap_msg_err(SOCKET sockctrl, SSL *, uint32_t plen, char *remote_errbuf);
68  static int rpcap_discard(SOCKET sock, SSL *, uint32_t len, char *errbuf);
69  static int rpcap_read_packet_msg(struct pcap_rpcap const *, pcap_t *p, size_t size);
70  #define SOCKADDR_IN_LEN		16	&bsol;* length of struct sockaddr_in */
71  #define SOCKADDR_IN6_LEN	28	&bsol;* length of struct sockaddr_in6 */
72  #define NEW_BSD_AF_INET_BE	((SOCKADDR_IN_LEN << 8) | 2)
73  #define NEW_BSD_AF_INET_LE	(SOCKADDR_IN_LEN << 8)
74  #define NEW_BSD_AF_INET6_BSD_BE		((SOCKADDR_IN6_LEN << 8) | 24)	&bsol;* NetBSD, OpenBSD, BSD/OS */
75  #define NEW_BSD_AF_INET6_FREEBSD_BE	((SOCKADDR_IN6_LEN << 8) | 28)	&bsol;* FreeBSD, DragonFly BSD */
76  #define NEW_BSD_AF_INET6_DARWIN_BE	((SOCKADDR_IN6_LEN << 8) | 30)	&bsol;* macOS, iOS, anything else Darwin-based */
77  #define NEW_BSD_AF_INET6_LE		(SOCKADDR_IN6_LEN << 8)
78  #define LINUX_AF_INET6			10
79  #define HPUX_AF_INET6			22
80  #define AIX_AF_INET6			24
81  #define SOLARIS_AF_INET6		26
82  static int
83  rpcap_deseraddr(struct rpcap_sockaddr *sockaddrin, struct sockaddr_storage **sockaddrout, char *errbuf)
84  {
85  	switch (ntohs(sockaddrin->family))
86  	{
87  	case RPCAP_AF_INET:
88  	case NEW_BSD_AF_INET_BE:
89  	case NEW_BSD_AF_INET_LE:
90  		{
91  		struct rpcap_sockaddr_in *sockaddrin_ipv4;
92  		struct sockaddr_in *sockaddrout_ipv4;
93  		(*sockaddrout) = (struct sockaddr_storage *) malloc(sizeof(struct sockaddr_in));
94  		if ((*sockaddrout) == NULL)
95  		{
96  			pcap_fmt_errmsg_for_errno(errbuf, PCAP_ERRBUF_SIZE,
97  			    errno, "malloc() failed");
98  			return -1;
99  		}
100  		sockaddrin_ipv4 = (struct rpcap_sockaddr_in *) sockaddrin;
101  		sockaddrout_ipv4 = (struct sockaddr_in *) (*sockaddrout);
102  		sockaddrout_ipv4->sin_family = AF_INET;
103  		sockaddrout_ipv4->sin_port = ntohs(sockaddrin_ipv4->port);
104  		memcpy(&sockaddrout_ipv4->sin_addr, &sockaddrin_ipv4->addr, sizeof(sockaddrout_ipv4->sin_addr));
105  		memset(sockaddrout_ipv4->sin_zero, 0, sizeof(sockaddrout_ipv4->sin_zero));
106  		break;
107  		}
108  #ifdef AF_INET6
109  	case RPCAP_AF_INET6:
110  	case NEW_BSD_AF_INET6_BSD_BE:
111  	case NEW_BSD_AF_INET6_FREEBSD_BE:
112  	case NEW_BSD_AF_INET6_DARWIN_BE:
113  	case NEW_BSD_AF_INET6_LE:
114  	case LINUX_AF_INET6:
115  	case HPUX_AF_INET6:
116  	case AIX_AF_INET6:
117  	case SOLARIS_AF_INET6:
118  		{
119  		struct rpcap_sockaddr_in6 *sockaddrin_ipv6;
120  		struct sockaddr_in6 *sockaddrout_ipv6;
121  		(*sockaddrout) = (struct sockaddr_storage *) malloc(sizeof(struct sockaddr_in6));
122  		if ((*sockaddrout) == NULL)
123  		{
124  			pcap_fmt_errmsg_for_errno(errbuf, PCAP_ERRBUF_SIZE,
125  			    errno, "malloc() failed");
126  			return -1;
127  		}
128  		sockaddrin_ipv6 = (struct rpcap_sockaddr_in6 *) sockaddrin;
129  		sockaddrout_ipv6 = (struct sockaddr_in6 *) (*sockaddrout);
130  		sockaddrout_ipv6->sin6_family = AF_INET6;
131  		sockaddrout_ipv6->sin6_port = ntohs(sockaddrin_ipv6->port);
132  		sockaddrout_ipv6->sin6_flowinfo = ntohl(sockaddrin_ipv6->flowinfo);
133  		memcpy(&sockaddrout_ipv6->sin6_addr, &sockaddrin_ipv6->addr, sizeof(sockaddrout_ipv6->sin6_addr));
134  		sockaddrout_ipv6->sin6_scope_id = ntohl(sockaddrin_ipv6->scope_id);
135  		break;
136  		}
137  #endif
138  	default:
139  		*sockaddrout = NULL;
140  		break;
141  	}
142  	return 0;
143  }
144  static int pcap_read_nocb_remote(pcap_t *p, struct pcap_pkthdr *pkt_header, u_char **pkt_data)
145  {
146  	struct pcap_rpcap *pr = p->priv;	&bsol;* structure used when doing a remote live capture */
147  	struct rpcap_header *header;		&bsol;* general header according to the RPCAP format */
148  	struct rpcap_pkthdr *net_pkt_header;	&bsol;* header of the packet, from the message */
149  	u_char *net_pkt_data;			&bsol;* packet data from the message */
150  	uint32_t plen;
151  	int retval = 0;				&bsol;* generic return value */
152  	int msglen;
153  	struct timeval tv;			&bsol;* maximum time the select() can block waiting for data */
154  	fd_set rfds;				&bsol;* set of socket descriptors we have to check */
155  	tv.tv_sec = p->opt.timeout / 1000;
156  	tv.tv_usec = (suseconds_t)((p->opt.timeout - tv.tv_sec * 1000) * 1000);
157  #ifdef HAVE_OPENSSL
158  	retval = pr->data_ssl && SSL_pending(pr->data_ssl) > 0;
159  #endif
160  	if (! retval)
161  	{
162  		FD_ZERO(&rfds);
163  		FD_SET(pr->rmt_sockdata, &rfds);
164  #ifdef FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION
165  		retval = 1;
166  #else
167  		retval = select((int) pr->rmt_sockdata + 1, &rfds, NULL, NULL, &tv);
168  #endif
169  		if (retval == -1)
170  		{
171  #ifndef _WIN32
172  			if (errno == EINTR)
173  			{
174  				return 0;
175  			}
176  #endif
177  			sock_geterrmsg(p->errbuf, PCAP_ERRBUF_SIZE,
178  			    "select() failed");
179  			return -1;
180  		}
181  	}
182  	if (retval == 0)
183  		return 0;
184  	header = (struct rpcap_header *) p->buffer;
185  	net_pkt_header = (struct rpcap_pkthdr *) ((char *)p->buffer + sizeof(struct rpcap_header));
186  	net_pkt_data = p->buffer + sizeof(struct rpcap_header) + sizeof(struct rpcap_pkthdr);
187  	if (pr->rmt_flags & PCAP_OPENFLAG_DATATX_UDP)
188  	{
189  		msglen = sock_recv_dgram(pr->rmt_sockdata, pr->data_ssl, p->buffer,
190  		    p->bufsize, p->errbuf, PCAP_ERRBUF_SIZE);
191  		if (msglen == -1)
192  		{
193  			return -1;
194  		}
195  		if (msglen == -3)
196  		{
197  			return 0;
198  		}
199  		if ((size_t)msglen < sizeof(struct rpcap_header))
200  		{
201  			snprintf(p->errbuf, PCAP_ERRBUF_SIZE,
202  			    "UDP packet message is shorter than an rpcap header");
203  			return -1;
204  		}
205  		plen = ntohl(header->plen);
206  		if ((size_t)msglen < sizeof(struct rpcap_header) + plen)
207  		{
208  			snprintf(p->errbuf, PCAP_ERRBUF_SIZE,
209  			    "UDP packet message is shorter than its rpcap header claims");
210  			return -1;
211  		}
212  	}
213  	else
214  	{
215  		int status;
216  		if ((size_t)p->cc < sizeof(struct rpcap_header))
217  		{
218  			status = rpcap_read_packet_msg(pr, p, sizeof(struct rpcap_header));
219  			if (status == -1)
220  			{
221  				return -1;
222  			}
223  			if (status == -3)
224  			{
225  				return 0;
226  			}
227  		}
228  		plen = ntohl(header->plen);
229  		if (plen > p->bufsize - sizeof(struct rpcap_header))
230  		{
231  			snprintf(p->errbuf, PCAP_ERRBUF_SIZE,
232  			    "Server sent us a message larger than the largest expected packet message");
233  			return -1;
234  		}
235  		status = rpcap_read_packet_msg(pr, p, sizeof(struct rpcap_header) + plen);
236  		if (status == -1)
237  		{
238  			return -1;
239  		}
240  		if (status == -3)
241  		{
242  			return 0;
243  		}
244  		p->bp = p->buffer;
245  		p->cc = 0;
246  	}
247  	header->plen = plen;
248  	if (rpcap_check_msg_ver(pr->rmt_sockdata, pr->data_ssl, pr->protocol_version,
249  	    header, p->errbuf) == -1)
250  	{
251  		return 0;	&bsol;* Return 'no packets received' */
252  	}
253  	if (header->type != RPCAP_MSG_PACKET)
254  	{
255  		return 0;	&bsol;* Return 'no packets received' */
256  	}
257  	if (ntohl(net_pkt_header->caplen) > plen)
258  	{
259  		snprintf(p->errbuf, PCAP_ERRBUF_SIZE,
260  		    "Packet's captured data goes past the end of the received packet message.");
261  		return -1;
262  	}
263  	pkt_header->caplen = ntohl(net_pkt_header->caplen);
264  	pkt_header->len = ntohl(net_pkt_header->len);
265  	pkt_header->ts.tv_sec = ntohl(net_pkt_header->timestamp_sec);
266  	pkt_header->ts.tv_usec = ntohl(net_pkt_header->timestamp_usec);
267  	*pkt_data = net_pkt_data;
268  	pr->TotCapt++;
269  	if (pr->rmt_flags & PCAP_OPENFLAG_DATATX_UDP)
270  	{
271  		unsigned int npkt;
272  		npkt = ntohl(net_pkt_header->npkt);
273  		if (pr->TotCapt != npkt)
274  		{
275  			pr->TotNetDrops += (npkt - pr->TotCapt);
276  			pr->TotCapt = npkt;
277  		}
278  	}
279  	return 1;
280  }
281  static int pcap_read_rpcap(pcap_t *p, int cnt, pcap_handler callback, u_char *user)
282  {
283  	struct pcap_rpcap *pr = p->priv;	&bsol;* structure used when doing a remote live capture */
284  	struct pcap_pkthdr pkt_header;
285  	u_char *pkt_data;
286  	int n = 0;
287  	int ret;
288  	if (pr->rmt_clientside)
289  	{
290  		if (!pr->rmt_capstarted)
291  		{
292  			if (pcap_startcapture_remote(p))
293  				return -1;
294  		}
295  	}
296  	if (PACKET_COUNT_IS_UNLIMITED(cnt))
297  		cnt = INT_MAX;
298  	while (n < cnt || PACKET_COUNT_IS_UNLIMITED(cnt))
299  	{
300  		if (p->break_loop) {
301  			p->break_loop = 0;
302  			return (PCAP_ERROR_BREAK);
303  		}
304  		ret = pcap_read_nocb_remote(p, &pkt_header, &pkt_data);
305  		if (ret == 1)
306  		{
307  			pcap_post_process(p->linktype, pr->byte_swapped,
308  			    &pkt_header, pkt_data);
309  			(*callback)(user, &pkt_header, pkt_data);
310  			n++;
311  		}
312  		else if (ret == -1)
313  		{
314  			return ret;
315  		}
316  		else
317  		{
318  			if (p->break_loop) {
319  				p->break_loop = 0;
320  				return (PCAP_ERROR_BREAK);
321  			}
322  			return n;
323  		}
324  	}
325  	return n;
326  }
327  static void pcap_cleanup_rpcap(pcap_t *fp)
328  {
329  	struct pcap_rpcap *pr = fp->priv;	&bsol;* structure used when doing a remote live capture */
330  	struct rpcap_header header;		&bsol;* header of the RPCAP packet */
331  	struct activehosts *temp;		&bsol;* temp var needed to scan the host list chain, to detect if we're in active mode */
332  	int active = 0;				&bsol;* active mode or not? */
333  	temp = activeHosts;
334  	while (temp)
335  	{
336  		if (temp->sockctrl == pr->rmt_sockctrl)
337  		{
338  			active = 1;
339  			break;
340  		}
341  		temp = temp->next;
342  	}
343  	if (!active)
344  	{
345  		rpcap_createhdr(&header, pr->protocol_version,
346  		    RPCAP_MSG_CLOSE, 0, 0);
347  		(void)sock_send(pr->rmt_sockctrl, pr->ctrl_ssl, (char *)&header,
348  		    sizeof(struct rpcap_header), NULL, 0);
349  	}
350  	else
351  	{
352  		rpcap_createhdr(&header, pr->protocol_version,
353  		    RPCAP_MSG_ENDCAP_REQ, 0, 0);
354  		if (sock_send(pr->rmt_sockctrl, pr->ctrl_ssl, (char *)&header,
355  		    sizeof(struct rpcap_header), NULL, 0) == 0)
356  		{
357  			if (rpcap_process_msg_header(pr->rmt_sockctrl, pr->ctrl_ssl,
358  			    pr->protocol_version, RPCAP_MSG_ENDCAP_REQ,
359  			    &header, NULL) == 0)
360  			{
361  				(void)rpcap_discard(pr->rmt_sockctrl, pr->ctrl_ssl,
362  				    header.plen, NULL);
363  			}
364  		}
365  	}
366  	if (pr->rmt_sockdata)
367  	{
368  #ifdef HAVE_OPENSSL
369  		if (pr->data_ssl)
370  		{
371  			ssl_finish(pr->data_ssl);
372  			pr->data_ssl = NULL;
373  		}
374  #endif
375  		sock_close(pr->rmt_sockdata, NULL, 0);
376  		pr->rmt_sockdata = 0;
377  	}
378  	if ((!active) && (pr->rmt_sockctrl))
379  	{
380  #ifdef HAVE_OPENSSL
381  		if (pr->ctrl_ssl)
382  		{
383  			ssl_finish(pr->ctrl_ssl);
384  			pr->ctrl_ssl = NULL;
385  		}
386  #endif
387  		sock_close(pr->rmt_sockctrl, NULL, 0);
388  	}
389  	pr->rmt_sockctrl = 0;
390  	pr->ctrl_ssl = NULL;
391  	if (pr->currentfilter)
392  	{
393  		free(pr->currentfilter);
394  		pr->currentfilter = NULL;
395  	}
396  	pcap_cleanup_live_common(fp);
397  	sock_cleanup();
398  }
399  static int pcap_stats_rpcap(pcap_t *p, struct pcap_stat *ps)
400  {
401  	struct pcap_stat *retval;
402  	retval = rpcap_stats_rpcap(p, ps, PCAP_STATS_STANDARD);
403  	if (retval)
404  		return 0;
405  	else
406  		return -1;
407  }
408  #ifdef _WIN32
409  static struct pcap_stat *pcap_stats_ex_rpcap(pcap_t *p, int *pcap_stat_size)
410  {
411  	*pcap_stat_size = sizeof (p->stat);
412  	return (rpcap_stats_rpcap(p, &(p->stat), PCAP_STATS_EX));
413  }
414  #endif
415  static struct pcap_stat *rpcap_stats_rpcap(pcap_t *p, struct pcap_stat *ps, int mode)
416  {
417  	struct pcap_rpcap *pr = p->priv;	&bsol;* structure used when doing a remote live capture */
418  	struct rpcap_header header;		&bsol;* header of the RPCAP packet */
419  	struct rpcap_stats netstats;		&bsol;* statistics sent on the network */
420  	uint32_t plen;				&bsol;* data remaining in the message */
421  #ifdef _WIN32
422  	if (mode != PCAP_STATS_STANDARD && mode != PCAP_STATS_EX)
423  #else
424  	if (mode != PCAP_STATS_STANDARD)
425  #endif
426  	{
427  		snprintf(p->errbuf, PCAP_ERRBUF_SIZE,
428  		    "Invalid stats mode %d", mode);
429  		return NULL;
430  	}
431  	if (!pr->rmt_capstarted)
432  	{
433  		ps->ps_drop = 0;
434  		ps->ps_ifdrop = 0;
435  		ps->ps_recv = 0;
436  #ifdef _WIN32
437  		if (mode == PCAP_STATS_EX)
438  		{
439  			ps->ps_capt = 0;
440  			ps->ps_sent = 0;
441  			ps->ps_netdrop = 0;
442  		}
443  #endif &bsol;* _WIN32 */
444  		return ps;
445  	}
446  	rpcap_createhdr(&header, pr->protocol_version,
447  	    RPCAP_MSG_STATS_REQ, 0, 0);
448  	if (sock_send(pr->rmt_sockctrl, pr->ctrl_ssl, (char *)&header,
449  	    sizeof(struct rpcap_header), p->errbuf, PCAP_ERRBUF_SIZE) < 0)
450  		return NULL;		&bsol;* Unrecoverable network error */
451  	if (rpcap_process_msg_header(pr->rmt_sockctrl, pr->ctrl_ssl, pr->protocol_version,
452  	    RPCAP_MSG_STATS_REQ, &header, p->errbuf) == -1)
453  		return NULL;		&bsol;* Error */
454  	plen = header.plen;
455  	if (rpcap_recv(pr->rmt_sockctrl, pr->ctrl_ssl, (char *)&netstats,
456  	    sizeof(struct rpcap_stats), &plen, p->errbuf) == -1)
457  		goto error;
458  	ps->ps_drop = ntohl(netstats.krnldrop);
459  	ps->ps_ifdrop = ntohl(netstats.ifdrop);
460  	ps->ps_recv = ntohl(netstats.ifrecv);
461  #ifdef _WIN32
462  	if (mode == PCAP_STATS_EX)
463  	{
464  		ps->ps_capt = pr->TotCapt;
465  		ps->ps_netdrop = pr->TotNetDrops;
466  		ps->ps_sent = ntohl(netstats.svrcapt);
467  	}
468  #endif &bsol;* _WIN32 */
469  	if (rpcap_discard(pr->rmt_sockctrl, pr->ctrl_ssl, plen, p->errbuf) == -1)
470  		goto error_nodiscard;
471  	return ps;
472  error:
473  	(void)rpcap_discard(pr->rmt_sockctrl, pr->ctrl_ssl, plen, NULL);
474  error_nodiscard:
475  	return NULL;
476  }
477  static struct activehosts *
478  rpcap_remoteact_getsock(const char *host, int *error, char *errbuf)
479  {
480  	struct activehosts *temp;			&bsol;* temp var needed to scan the host list chain */
481  	struct addrinfo hints, *addrinfo, *ai_next;	&bsol;* temp var needed to translate between hostname to its address */
482  	int retval;
483  	addrinfo = NULL;
484  	memset(&hints, 0, sizeof(struct addrinfo));
485  	hints.ai_family = PF_UNSPEC;
486  	hints.ai_socktype = SOCK_STREAM;
487  	retval = sock_initaddress(host, NULL, &hints, &addrinfo, errbuf,
488  	    PCAP_ERRBUF_SIZE);
489  	if (retval != 0)
490  	{
491  		*error = 1;
492  		return NULL;
493  	}
494  	temp = activeHosts;
495  	while (temp)
496  	{
497  		ai_next = addrinfo;
498  		while (ai_next)
499  		{
500  			if (sock_cmpaddr(&temp->host, (struct sockaddr_storage *) ai_next->ai_addr) == 0)
501  			{
502  				*error = 0;
503  				freeaddrinfo(addrinfo);
504  				return temp;
505  			}
506  			ai_next = ai_next->ai_next;
507  		}
508  		temp = temp->next;
509  	}
510  	if (addrinfo)
511  		freeaddrinfo(addrinfo);
512  	*error = 0;
513  	return NULL;
514  }
515  static int pcap_startcapture_remote(pcap_t *fp)
516  {
517  	struct pcap_rpcap *pr = fp->priv;	&bsol;* structure used when doing a remote live capture */
518  	char sendbuf[RPCAP_NETBUF_SIZE];	&bsol;* temporary buffer in which data to be sent is buffered */
519  	int sendbufidx = 0;			&bsol;* index which keeps the number of bytes currently buffered */
520  	uint16_t portdata = 0;			&bsol;* temp variable needed to keep the network port for the data connection */
521  	uint32_t plen;
522  	int active = 0;				&bsol;* '1' if we're in active mode */
523  	struct activehosts *temp;		&bsol;* temp var needed to scan the host list chain, to detect if we're in active mode */
524  	char host[INET6_ADDRSTRLEN + 1];	&bsol;* numeric name of the other host */
525  	struct addrinfo hints;			&bsol;* temp, needed to open a socket connection */
526  	struct addrinfo *addrinfo;		&bsol;* temp, needed to open a socket connection */
527  	SOCKET sockdata = 0;			&bsol;* socket descriptor of the data connection */
528  	struct sockaddr_storage saddr;		&bsol;* temp, needed to retrieve the network data port chosen on the local machine */
529  	socklen_t saddrlen;			&bsol;* temp, needed to retrieve the network data port chosen on the local machine */
530  	int ai_family;				&bsol;* temp, keeps the address family used by the control connection */
531  	struct sockaddr_in *sin4;
532  	struct sockaddr_in6 *sin6;
533  	struct rpcap_header header;			&bsol;* header of the RPCAP packet */
534  	struct rpcap_startcapreq *startcapreq;		&bsol;* start capture request message */
535  	struct rpcap_startcapreply startcapreply;	&bsol;* start capture reply message */
536  	int res;
537  	socklen_t itemp;
538  	int sockbufsize = 0;
539  	uint32_t server_sockbufsize;
540  	pr->data_ssl = NULL;
541  	if (pcap_setsampling_remote(fp) != 0)
542  		return -1;
543  	temp = activeHosts;
544  	while (temp)
545  	{
546  		if (temp->sockctrl == pr->rmt_sockctrl)
547  		{
548  			active = 1;
549  			break;
550  		}
551  		temp = temp->next;
552  	}
553  	addrinfo = NULL;
554  	saddrlen = sizeof(struct sockaddr_storage);
555  	if (getpeername(pr->rmt_sockctrl, (struct sockaddr *) &saddr, &saddrlen) == -1)
556  	{
557  		sock_geterrmsg(fp->errbuf, PCAP_ERRBUF_SIZE,
558  		    "getsockname() failed");
559  		goto error_nodiscard;
560  	}
561  	ai_family = ((struct sockaddr_storage *) &saddr)->ss_family;
562  	if (getnameinfo((struct sockaddr *) &saddr, saddrlen, host,
563  		sizeof(host), NULL, 0, NI_NUMERICHOST))
564  	{
565  		sock_geterrmsg(fp->errbuf, PCAP_ERRBUF_SIZE,
566  		    "getnameinfo() failed");
567  		goto error_nodiscard;
568  	}
569  	if ((active) || (pr->rmt_flags & PCAP_OPENFLAG_DATATX_UDP))
570  	{
571  		memset(&hints, 0, sizeof(struct addrinfo));
572  		hints.ai_family = ai_family;	&bsol;* Use the same address family of the control socket */
573  		hints.ai_socktype = (pr->rmt_flags & PCAP_OPENFLAG_DATATX_UDP) ? SOCK_DGRAM : SOCK_STREAM;
574  		hints.ai_flags = AI_PASSIVE;	&bsol;* Data connection is opened by the server toward the client */
575  		if (sock_initaddress(NULL, NULL, &hints, &addrinfo, fp->errbuf, PCAP_ERRBUF_SIZE) == -1)
576  			goto error_nodiscard;
577  		if ((sockdata = sock_open(NULL, addrinfo, SOCKOPEN_SERVER,
578  			1 &bsol;* max 1 connection in queue */, fp->errbuf, PCAP_ERRBUF_SIZE)) == INVALID_SOCKET)
579  			goto error_nodiscard;
580  		freeaddrinfo(addrinfo);
581  		addrinfo = NULL;
582  		saddrlen = sizeof(struct sockaddr_storage);
583  		if (getsockname(sockdata, (struct sockaddr *) &saddr, &saddrlen) == -1)
584  		{
585  			sock_geterrmsg(fp->errbuf, PCAP_ERRBUF_SIZE,
586  			    "getsockname() failed");
587  			goto error_nodiscard;
588  		}
589  		switch (saddr.ss_family) {
590  		case AF_INET:
591  			sin4 = (struct sockaddr_in *)&saddr;
592  			portdata = sin4->sin_port;
593  			break;
594  		case AF_INET6:
595  			sin6 = (struct sockaddr_in6 *)&saddr;
596  			portdata = sin6->sin6_port;
597  			break;
598  		default:
599  			snprintf(fp->errbuf, PCAP_ERRBUF_SIZE,
600  			    "Local address has unknown address family %u",
601  			    saddr.ss_family);
602  			goto error_nodiscard;
603  		}
604  	}
605  	if (sock_bufferize(NULL, sizeof(struct rpcap_header), NULL,
606  		&sendbufidx, RPCAP_NETBUF_SIZE, SOCKBUF_CHECKONLY, fp->errbuf, PCAP_ERRBUF_SIZE))
607  		goto error_nodiscard;
608  	rpcap_createhdr((struct rpcap_header *) sendbuf,
609  	    pr->protocol_version, RPCAP_MSG_STARTCAP_REQ, 0,
610  	    sizeof(struct rpcap_startcapreq) + sizeof(struct rpcap_filter) + fp->fcode.bf_len * sizeof(struct rpcap_filterbpf_insn));
611  	startcapreq = (struct rpcap_startcapreq *) &sendbuf[sendbufidx];
612  	if (sock_bufferize(NULL, sizeof(struct rpcap_startcapreq), NULL,
613  		&sendbufidx, RPCAP_NETBUF_SIZE, SOCKBUF_CHECKONLY, fp->errbuf, PCAP_ERRBUF_SIZE))
614  		goto error_nodiscard;
615  	memset(startcapreq, 0, sizeof(struct rpcap_startcapreq));
616  	fp->opt.timeout = fp->opt.timeout / 2;
617  	startcapreq->read_timeout = htonl(fp->opt.timeout);
618  	if ((active) || (pr->rmt_flags & PCAP_OPENFLAG_DATATX_UDP))
619  	{
620  		startcapreq->portdata = portdata;
621  	}
622  	startcapreq->snaplen = htonl(fp->snapshot);
623  	startcapreq->flags = 0;
624  	if (pr->rmt_flags & PCAP_OPENFLAG_PROMISCUOUS)
625  		startcapreq->flags |= RPCAP_STARTCAPREQ_FLAG_PROMISC;
626  	if (pr->rmt_flags & PCAP_OPENFLAG_DATATX_UDP)
627  		startcapreq->flags |= RPCAP_STARTCAPREQ_FLAG_DGRAM;
628  	if (active)
629  		startcapreq->flags |= RPCAP_STARTCAPREQ_FLAG_SERVEROPEN;
630  	startcapreq->flags = htons(startcapreq->flags);
631  	if (pcap_pack_bpffilter(fp, &sendbuf[sendbufidx], &sendbufidx, &fp->fcode))
632  		goto error_nodiscard;
633  	if (sock_send(pr->rmt_sockctrl, pr->ctrl_ssl, sendbuf, sendbufidx, fp->errbuf,
634  	    PCAP_ERRBUF_SIZE) < 0)
635  		goto error_nodiscard;
636  	if (rpcap_process_msg_header(pr->rmt_sockctrl, pr->ctrl_ssl, pr->protocol_version,
637  	    RPCAP_MSG_STARTCAP_REQ, &header, fp->errbuf) == -1)
638  		goto error_nodiscard;
639  	plen = header.plen;
640  	if (rpcap_recv(pr->rmt_sockctrl, pr->ctrl_ssl, (char *)&startcapreply,
641  	    sizeof(struct rpcap_startcapreply), &plen, fp->errbuf) == -1)
642  		goto error;
643  	if (!(pr->rmt_flags & PCAP_OPENFLAG_DATATX_UDP))
644  	{
645  		if (!active)
646  		{
647  			char portstring[PCAP_BUF_SIZE];
648  			memset(&hints, 0, sizeof(struct addrinfo));
649  			hints.ai_family = ai_family;		&bsol;* Use the same address family of the control socket */
650  			hints.ai_socktype = (pr->rmt_flags & PCAP_OPENFLAG_DATATX_UDP) ? SOCK_DGRAM : SOCK_STREAM;
651  			snprintf(portstring, PCAP_BUF_SIZE, "%d", ntohs(startcapreply.portdata));
652  			if (sock_initaddress(host, portstring, &hints, &addrinfo, fp->errbuf, PCAP_ERRBUF_SIZE) == -1)
653  				goto error;
654  			if ((sockdata = sock_open(host, addrinfo, SOCKOPEN_CLIENT, 0, fp->errbuf, PCAP_ERRBUF_SIZE)) == INVALID_SOCKET)
655  				goto error;
656  			freeaddrinfo(addrinfo);
657  			addrinfo = NULL;
658  		}
659  		else
660  		{
661  			SOCKET socktemp;	&bsol;* We need another socket, since we're going to accept() a connection */
662  			saddrlen = sizeof(struct sockaddr_storage);
663  			socktemp = accept(sockdata, (struct sockaddr *) &saddr, &saddrlen);
664  			if (socktemp == INVALID_SOCKET)
665  			{
666  				sock_geterrmsg(fp->errbuf, PCAP_ERRBUF_SIZE,
667  				    "accept() failed");
668  				goto error;
669  			}
670  			sock_close(sockdata, fp->errbuf, PCAP_ERRBUF_SIZE);
671  			sockdata = socktemp;
672  		}
673  	}
674  	pr->rmt_sockdata = sockdata;
675  #ifdef HAVE_OPENSSL
676  	if (pr->uses_ssl)
677  	{
678  		pr->data_ssl = ssl_promotion(0, sockdata, fp->errbuf, PCAP_ERRBUF_SIZE);
679  		if (! pr->data_ssl) goto error;
680  	}
681  #endif
682  	server_sockbufsize = ntohl(startcapreply.bufsize);
683  	itemp = sizeof(sockbufsize);
684  	res = getsockopt(sockdata, SOL_SOCKET, SO_RCVBUF, (char *)&sockbufsize, &itemp);
685  	if (res == -1)
686  	{
687  		sock_geterrmsg(fp->errbuf, PCAP_ERRBUF_SIZE,
688  		    "pcap_startcapture_remote(): getsockopt() failed");
689  		goto error;
690  	}
691  	if (server_sockbufsize <= (u_int) fp->snapshot)
692  		server_sockbufsize += sizeof(struct pcap_pkthdr);
693  	if ((u_int) sockbufsize < server_sockbufsize)
694  	{
695  		for (;;)
696  		{
697  			res = setsockopt(sockdata, SOL_SOCKET, SO_RCVBUF,
698  			    (char *)&(server_sockbufsize),
699  			    sizeof(server_sockbufsize));
700  			if (res == 0)
701  				break;
702  			server_sockbufsize /= 2;
703  			if ((u_int) sockbufsize >= server_sockbufsize)
704  			{
705  				server_sockbufsize = sockbufsize;
706  				break;
707  			}
708  		}
709  	}
710  	fp->bufsize = sizeof(struct rpcap_header) + sizeof(struct rpcap_pkthdr) + fp->snapshot;
711  	fp->buffer = (u_char *)malloc(fp->bufsize);
712  	if (fp->buffer == NULL)
713  	{
714  		pcap_fmt_errmsg_for_errno(fp->errbuf, PCAP_ERRBUF_SIZE,
715  		    errno, "malloc");
716  		goto error;
717  	}
718  	fp->bp = fp->buffer;
719  	fp->cc = 0;
720  	if (rpcap_discard(pr->rmt_sockctrl, pr->ctrl_ssl, plen, fp->errbuf) == -1)
721  		goto error_nodiscard;
722  	if (pr->rmt_flags & PCAP_OPENFLAG_NOCAPTURE_RPCAP)
723  	{
724  		struct bpf_program fcode;
725  		if (pcap_createfilter_norpcappkt(fp, &fcode) == -1)
726  			goto error;
727  		if (pcap_updatefilter_remote(fp, &fcode) == -1)
728  			goto error;
729  		pcap_freecode(&fcode);
730  	}
731  	pr->rmt_capstarted = 1;
732  	return 0;
733  error:
734  	(void)rpcap_discard(pr->rmt_sockctrl, pr->ctrl_ssl, plen, NULL);
735  error_nodiscard:
736  #ifdef HAVE_OPENSSL
737  	if (pr->data_ssl)
738  	{
739  		ssl_finish(pr->data_ssl);
740  		pr->data_ssl = NULL;
741  	}
742  #endif
743  	if ((sockdata != 0) && (sockdata != INVALID_SOCKET))
744  		sock_close(sockdata, NULL, 0);
745  	if (!active)
746  	{
747  #ifdef HAVE_OPENSSL
748  		if (pr->ctrl_ssl)
749  		{
750  			ssl_finish(pr->ctrl_ssl);
751  			pr->ctrl_ssl = NULL;
752  		}
753  #endif
754  		sock_close(pr->rmt_sockctrl, NULL, 0);
755  	}
756  	if (addrinfo != NULL)
757  		freeaddrinfo(addrinfo);
758  #if 0
759  	if (fp)
760  	{
761  		pcap_close(fp);
762  		fp= NULL;
763  	}
764  #endif
765  	return -1;
766  }
767  static int pcap_pack_bpffilter(pcap_t *fp, char *sendbuf, int *sendbufidx, struct bpf_program *prog)
768  {
769  	struct rpcap_filter *filter;
770  	struct rpcap_filterbpf_insn *insn;
771  	struct bpf_insn *bf_insn;
772  	struct bpf_program fake_prog;		&bsol;* To be used just in case the user forgot to set a filter */
773  	unsigned int i;
774  	if (prog->bf_len == 0)	&bsol;* No filters have been specified; so, let's apply a "fake" filter */
775  	{
776  		if (pcap_compile(fp, &fake_prog, NULL &bsol;* buffer */, 1, 0) == -1)
777  			return -1;
778  		prog = &fake_prog;
779  	}
780  	filter = (struct rpcap_filter *) sendbuf;
781  	if (sock_bufferize(NULL, sizeof(struct rpcap_filter), NULL, sendbufidx,
782  		RPCAP_NETBUF_SIZE, SOCKBUF_CHECKONLY, fp->errbuf, PCAP_ERRBUF_SIZE))
783  		return -1;
784  	filter->filtertype = htons(RPCAP_UPDATEFILTER_BPF);
785  	filter->nitems = htonl((int32_t)prog->bf_len);
786  	if (sock_bufferize(NULL, prog->bf_len * sizeof(struct rpcap_filterbpf_insn),
787  		NULL, sendbufidx, RPCAP_NETBUF_SIZE, SOCKBUF_CHECKONLY, fp->errbuf, PCAP_ERRBUF_SIZE))
788  		return -1;
789  	insn = (struct rpcap_filterbpf_insn *) (filter + 1);
790  	bf_insn = prog->bf_insns;
791  	for (i = 0; i < prog->bf_len; i++)
792  	{
793  		insn->code = htons(bf_insn->code);
794  		insn->jf = bf_insn->jf;
795  		insn->jt = bf_insn->jt;
796  		insn->k = htonl(bf_insn->k);
797  		insn++;
798  		bf_insn++;
799  	}
800  	return 0;
801  }
802  static int pcap_updatefilter_remote(pcap_t *fp, struct bpf_program *prog)
803  {
804  	struct pcap_rpcap *pr = fp->priv;	&bsol;* structure used when doing a remote live capture */
805  	char sendbuf[RPCAP_NETBUF_SIZE];	&bsol;* temporary buffer in which data to be sent is buffered */
806  	int sendbufidx = 0;			&bsol;* index which keeps the number of bytes currently buffered */
807  	struct rpcap_header header;		&bsol;* To keep the reply message */
808  	if (sock_bufferize(NULL, sizeof(struct rpcap_header), NULL, &sendbufidx,
809  		RPCAP_NETBUF_SIZE, SOCKBUF_CHECKONLY, fp->errbuf, PCAP_ERRBUF_SIZE))
810  		return -1;
811  	rpcap_createhdr((struct rpcap_header *) sendbuf,
812  	    pr->protocol_version, RPCAP_MSG_UPDATEFILTER_REQ, 0,
813  	    sizeof(struct rpcap_filter) + prog->bf_len * sizeof(struct rpcap_filterbpf_insn));
814  	if (pcap_pack_bpffilter(fp, &sendbuf[sendbufidx], &sendbufidx, prog))
815  		return -1;
816  	if (sock_send(pr->rmt_sockctrl, pr->ctrl_ssl, sendbuf, sendbufidx, fp->errbuf,
817  	    PCAP_ERRBUF_SIZE) < 0)
818  		return -1;
819  	if (rpcap_process_msg_header(pr->rmt_sockctrl, pr->ctrl_ssl, pr->protocol_version,
820  	    RPCAP_MSG_UPDATEFILTER_REQ, &header, fp->errbuf) == -1)
821  		return -1;
822  	if (rpcap_discard(pr->rmt_sockctrl, pr->ctrl_ssl, header.plen, fp->errbuf) == -1)
823  		return -1;
824  	return 0;
825  }
826  static void
827  pcap_save_current_filter_rpcap(pcap_t *fp, const char *filter)
828  {
829  	struct pcap_rpcap *pr = fp->priv;	&bsol;* structure used when doing a remote live capture */
830  	if (pr->rmt_clientside &&
831  	    (pr->rmt_flags & PCAP_OPENFLAG_NOCAPTURE_RPCAP))
832  	{
833  		if (pr->currentfilter)
834  			free(pr->currentfilter);
835  		if (filter == NULL)
836  			filter = "";
837  		pr->currentfilter = strdup(filter);
838  	}
839  }
840  static int pcap_setfilter_rpcap(pcap_t *fp, struct bpf_program *prog)
841  {
842  	struct pcap_rpcap *pr = fp->priv;	&bsol;* structure used when doing a remote live capture */
843  	if (!pr->rmt_capstarted)
844  	{
845  		if (pcap_install_bpf_program(fp, prog) == -1)
846  			return -1;
847  		return 0;
848  	}
849  	if (pcap_updatefilter_remote(fp, prog))
850  		return -1;
851  	return 0;
852  }
853  static int pcap_createfilter_norpcappkt(pcap_t *fp, struct bpf_program *prog)
854  {
855  	struct pcap_rpcap *pr = fp->priv;	&bsol;* structure used when doing a remote live capture */
856  	int RetVal = 0;
857  	if (pr->rmt_flags & PCAP_OPENFLAG_NOCAPTURE_RPCAP)
858  	{
859  		struct sockaddr_storage saddr;		&bsol;* temp, needed to retrieve the network data port chosen on the local machine */
860  		socklen_t saddrlen;					&bsol;* temp, needed to retrieve the network data port chosen on the local machine */
861  		char myaddress[128];
862  		char myctrlport[128];
863  		char mydataport[128];
864  		char peeraddress[128];
865  		char peerctrlport[128];
866  		char *newfilter;
867  		saddrlen = sizeof(struct sockaddr_storage);
868  		if (getpeername(pr->rmt_sockctrl, (struct sockaddr *) &saddr, &saddrlen) == -1)
869  		{
870  			sock_geterrmsg(fp->errbuf, PCAP_ERRBUF_SIZE,
871  			    "getpeername() failed");
872  			return -1;
873  		}
874  		if (getnameinfo((struct sockaddr *) &saddr, saddrlen, peeraddress,
875  			sizeof(peeraddress), peerctrlport, sizeof(peerctrlport), NI_NUMERICHOST | NI_NUMERICSERV))
876  		{
877  			sock_geterrmsg(fp->errbuf, PCAP_ERRBUF_SIZE,
878  			    "getnameinfo() failed");
879  			return -1;
880  		}
881  		if (getsockname(pr->rmt_sockctrl, (struct sockaddr *) &saddr, &saddrlen) == -1)
882  		{
883  			sock_geterrmsg(fp->errbuf, PCAP_ERRBUF_SIZE,
884  			    "getsockname() failed");
885  			return -1;
886  		}
887  		if (getnameinfo((struct sockaddr *) &saddr, saddrlen, myaddress,
888  			sizeof(myaddress), myctrlport, sizeof(myctrlport), NI_NUMERICHOST | NI_NUMERICSERV))
889  		{
890  			sock_geterrmsg(fp->errbuf, PCAP_ERRBUF_SIZE,
891  			    "getnameinfo() failed");
892  			return -1;
893  		}
894  		if (getsockname(pr->rmt_sockdata, (struct sockaddr *) &saddr, &saddrlen) == -1)
895  		{
896  			sock_geterrmsg(fp->errbuf, PCAP_ERRBUF_SIZE,
897  			    "getsockname() failed");
898  			return -1;
899  		}
900  		if (getnameinfo((struct sockaddr *) &saddr, saddrlen, NULL, 0, mydataport, sizeof(mydataport), NI_NUMERICSERV))
901  		{
902  			sock_geterrmsg(fp->errbuf, PCAP_ERRBUF_SIZE,
903  			    "getnameinfo() failed");
904  			return -1;
905  		}
906  		if (pr->currentfilter && pr->currentfilter[0] != '\0')
907  		{
908  			if (pcap_asprintf(&newfilter,
909  			    "(%s) and not (host %s and host %s and port %s and port %s) and not (host %s and host %s and port %s)",
910  			    pr->currentfilter, myaddress, peeraddress,
911  			    myctrlport, peerctrlport, myaddress, peeraddress,
912  			    mydataport) == -1)
913  			{
914  				snprintf(fp->errbuf, PCAP_ERRBUF_SIZE,
915  				    "Can't allocate memory for new filter");
916  				return -1;
917  			}
918  		}
919  		else
920  		{
921  			if (pcap_asprintf(&newfilter,
922  			    "not (host %s and host %s and port %s and port %s) and not (host %s and host %s and port %s)",
923  			    myaddress, peeraddress, myctrlport, peerctrlport,
924  			    myaddress, peeraddress, mydataport) == -1)
925  			{
926  				snprintf(fp->errbuf, PCAP_ERRBUF_SIZE,
927  				    "Can't allocate memory for new filter");
928  				return -1;
929  			}
930  		}
931  		pr->rmt_clientside = 0;
932  		if (pcap_compile(fp, prog, newfilter, 1, 0) == -1)
933  			RetVal = -1;
934  		pr->rmt_clientside = 1;
935  		free(newfilter);
936  	}
937  	return RetVal;
938  }
939  static int pcap_setsampling_remote(pcap_t *fp)
940  {
941  	struct pcap_rpcap *pr = fp->priv;	&bsol;* structure used when doing a remote live capture */
942  	char sendbuf[RPCAP_NETBUF_SIZE];&bsol;* temporary buffer in which data to be sent is buffered */
943  	int sendbufidx = 0;			&bsol;* index which keeps the number of bytes currently buffered */
944  	struct rpcap_header header;		&bsol;* To keep the reply message */
945  	struct rpcap_sampling *sampling_pars;	&bsol;* Structure that is needed to send sampling parameters to the remote host */
946  	if (fp->rmt_samp.method == PCAP_SAMP_NOSAMP)
947  		return 0;
948  	if (fp->rmt_samp.method < 0 || fp->rmt_samp.method > 255) {
949  		snprintf(fp->errbuf, PCAP_ERRBUF_SIZE,
950  		    "Invalid sampling method %d", fp->rmt_samp.method);
951  		return -1;
952  	}
953  	if (fp->rmt_samp.value < 0 || fp->rmt_samp.value > 65535) {
954  		snprintf(fp->errbuf, PCAP_ERRBUF_SIZE,
955  		    "Invalid sampling value %d", fp->rmt_samp.value);
956  		return -1;
957  	}
958  	if (sock_bufferize(NULL, sizeof(struct rpcap_header), NULL,
959  		&sendbufidx, RPCAP_NETBUF_SIZE, SOCKBUF_CHECKONLY, fp->errbuf, PCAP_ERRBUF_SIZE))
960  		return -1;
961  	rpcap_createhdr((struct rpcap_header *) sendbuf,
962  	    pr->protocol_version, RPCAP_MSG_SETSAMPLING_REQ, 0,
963  	    sizeof(struct rpcap_sampling));
964  	sampling_pars = (struct rpcap_sampling *) &sendbuf[sendbufidx];
965  	if (sock_bufferize(NULL, sizeof(struct rpcap_sampling), NULL,
966  		&sendbufidx, RPCAP_NETBUF_SIZE, SOCKBUF_CHECKONLY, fp->errbuf, PCAP_ERRBUF_SIZE))
967  		return -1;
968  	memset(sampling_pars, 0, sizeof(struct rpcap_sampling));
969  	sampling_pars->method = (uint8_t)fp->rmt_samp.method;
970  	sampling_pars->value = (uint16_t)htonl(fp->rmt_samp.value);
971  	if (sock_send(pr->rmt_sockctrl, pr->ctrl_ssl, sendbuf, sendbufidx, fp->errbuf,
972  	    PCAP_ERRBUF_SIZE) < 0)
973  		return -1;
974  	if (rpcap_process_msg_header(pr->rmt_sockctrl, pr->ctrl_ssl, pr->protocol_version,
975  	    RPCAP_MSG_SETSAMPLING_REQ, &header, fp->errbuf) == -1)
976  		return -1;
977  	if (rpcap_discard(pr->rmt_sockctrl, pr->ctrl_ssl, header.plen, fp->errbuf) == -1)
978  		return -1;
979  	return 0;
980  }
981  static int rpcap_doauth(SOCKET sockctrl, SSL *ssl, uint8_t *ver,
982      int *byte_swapped, struct pcap_rmtauth *auth, char *errbuf)
983  {
984  	char sendbuf[RPCAP_NETBUF_SIZE];	&bsol;* temporary buffer in which data that has to be sent is buffered */
985  	int sendbufidx = 0;			&bsol;* index which keeps the number of bytes currently buffered */
986  	uint16_t length;			&bsol;* length of the payload of this message */
987  	struct rpcap_auth *rpauth;
988  	uint16_t auth_type;
989  	struct rpcap_header header;
990  	size_t str_length;
991  	uint32_t plen;
992  	struct rpcap_authreply authreply;	&bsol;* authentication reply message */
993  	uint8_t ourvers;
994  	int has_byte_order;			&bsol;* The server sent its version of the byte-order magic number */
995  	u_int their_byte_order_magic;		&bsol;* Here's what it is */
996  	if (auth)
997  	{
998  		switch (auth->type)
999  		{
1000  		case RPCAP_RMTAUTH_NULL:
1001  			length = sizeof(struct rpcap_auth);
1002  			break;
1003  		case RPCAP_RMTAUTH_PWD:
1004  			length = sizeof(struct rpcap_auth);
1005  			if (auth->username)
1006  			{
1007  				str_length = strlen(auth->username);
1008  				if (str_length > 65535)
1009  				{
1010  					snprintf(errbuf, PCAP_ERRBUF_SIZE, "User name is too long (> 65535 bytes)");
1011  					return -1;
1012  				}
1013  				length += (uint16_t)str_length;
1014  			}
1015  			if (auth->password)
1016  			{
1017  				str_length = strlen(auth->password);
1018  				if (str_length > 65535)
1019  				{
1020  					snprintf(errbuf, PCAP_ERRBUF_SIZE, "Password is too long (> 65535 bytes)");
1021  					return -1;
1022  				}
1023  				length += (uint16_t)str_length;
1024  			}
1025  			break;
1026  		default:
1027  			snprintf(errbuf, PCAP_ERRBUF_SIZE, "Authentication type not recognized.");
1028  			return -1;
1029  		}
1030  		auth_type = (uint16_t)auth->type;
1031  	}
1032  	else
1033  	{
1034  		auth_type = RPCAP_RMTAUTH_NULL;
1035  		length = sizeof(struct rpcap_auth);
1036  	}
1037  	if (sock_bufferize(NULL, sizeof(struct rpcap_header), NULL,
1038  		&sendbufidx, RPCAP_NETBUF_SIZE, SOCKBUF_CHECKONLY, errbuf, PCAP_ERRBUF_SIZE))
1039  		return -1;
1040  	rpcap_createhdr((struct rpcap_header *) sendbuf, 0,
1041  	    RPCAP_MSG_AUTH_REQ, 0, length);
1042  	rpauth = (struct rpcap_auth *) &sendbuf[sendbufidx];
1043  	if (sock_bufferize(NULL, sizeof(struct rpcap_auth), NULL,
1044  		&sendbufidx, RPCAP_NETBUF_SIZE, SOCKBUF_CHECKONLY, errbuf, PCAP_ERRBUF_SIZE))
1045  		return -1;
1046  	memset(rpauth, 0, sizeof(struct rpcap_auth));
1047  	rpauth->type = htons(auth_type);
1048  	if (auth_type == RPCAP_RMTAUTH_PWD)
1049  	{
1050  		if (auth->username)
1051  			rpauth->slen1 = (uint16_t)strlen(auth->username);
1052  		else
1053  			rpauth->slen1 = 0;
1054  		if (sock_bufferize(auth->username, rpauth->slen1, sendbuf,
1055  			&sendbufidx, RPCAP_NETBUF_SIZE, SOCKBUF_BUFFERIZE, errbuf, PCAP_ERRBUF_SIZE))
1056  			return -1;
1057  		if (auth->password)
1058  			rpauth->slen2 = (uint16_t)strlen(auth->password);
1059  		else
1060  			rpauth->slen2 = 0;
1061  		if (sock_bufferize(auth->password, rpauth->slen2, sendbuf,
1062  			&sendbufidx, RPCAP_NETBUF_SIZE, SOCKBUF_BUFFERIZE, errbuf, PCAP_ERRBUF_SIZE))
1063  			return -1;
1064  		rpauth->slen1 = htons(rpauth->slen1);
1065  		rpauth->slen2 = htons(rpauth->slen2);
1066  	}
1067  	if (sock_send(sockctrl, ssl, sendbuf, sendbufidx, errbuf,
1068  	    PCAP_ERRBUF_SIZE) < 0)
1069  		return -1;
1070  	if (rpcap_process_msg_header(sockctrl, ssl, 0, RPCAP_MSG_AUTH_REQ,
1071  	    &header, errbuf) == -1)
1072  		return -1;
1073  	plen = header.plen;
1074  	if (plen != 0)
1075  	{
1076  		size_t reply_len;
1077  		if (plen < sizeof(struct rpcap_authreply_old))
1078  		{
1079  			snprintf(errbuf, PCAP_ERRBUF_SIZE,
1080  			    "Authenticaton reply from server is too short");
1081  			(void)rpcap_discard(sockctrl, ssl, plen, NULL);
1082  			return -1;
1083  		}
1084  		if (plen == sizeof(struct rpcap_authreply_old))
1085  		{
1086  			has_byte_order = 0;
1087  			reply_len = sizeof(struct rpcap_authreply_old);
1088  		}
1089  		else if (plen >= sizeof(struct rpcap_authreply_old))
1090  		{
1091  			has_byte_order = 1;
1092  			reply_len = sizeof(struct rpcap_authreply);
1093  		}
1094  		else
1095  		{
1096  			snprintf(errbuf, PCAP_ERRBUF_SIZE,
1097  			    "Authenticaton reply from server is too short");
1098  			(void)rpcap_discard(sockctrl, ssl, plen, NULL);
1099  			return -1;
1100  		}
1101  		if (rpcap_recv(sockctrl, ssl, (char *)&authreply,
1102  		    reply_len, &plen, errbuf) == -1)
1103  		{
1104  			(void)rpcap_discard(sockctrl, ssl, plen, NULL);
1105  			return -1;
1106  		}
1107  		if (rpcap_discard(sockctrl, ssl, plen, errbuf) == -1)
1108  			return -1;
1109  		if (authreply.minvers > authreply.maxvers)
1110  		{
1111  			snprintf(errbuf, PCAP_ERRBUF_SIZE,
1112  			    "The server's minimum supported protocol version is greater than its maximum supported protocol version");
1113  			return -1;
1114  		}
1115  		if (has_byte_order)
1116  		{
1117  			their_byte_order_magic = authreply.byte_order_magic;
1118  		}
1119  		else
1120  		{
1121  			their_byte_order_magic = RPCAP_BYTE_ORDER_MAGIC;
1122  		}
1123  	}
1124  	else
1125  	{
1126  		authreply.minvers = 0;
1127  		authreply.maxvers = 0;
1128  		has_byte_order = 0;
1129  		their_byte_order_magic = RPCAP_BYTE_ORDER_MAGIC;
1130  	}
1131  	ourvers = authreply.maxvers;
1132  #if RPCAP_MIN_VERSION != 0
1133  	if (ourvers < RPCAP_MIN_VERSION)
1134  		goto novers;
1135  #endif
1136  	if (ourvers > RPCAP_MAX_VERSION)
1137  	{
1138  		ourvers = RPCAP_MAX_VERSION;
1139  		if (ourvers < authreply.minvers)
1140  			goto novers;
1141  	}
1142  	if (their_byte_order_magic == RPCAP_BYTE_ORDER_MAGIC)
1143  	{
1144  		*byte_swapped = 0;
1145  	}
1146  	else if (their_byte_order_magic == RPCAP_BYTE_ORDER_MAGIC_SWAPPED)
1147  	{
1148  		*byte_swapped = 1;
1149  	}
1150  	else
1151  	{
1152  		snprintf(errbuf, PCAP_ERRBUF_SIZE,
1153  		    "The server did not send us a valid byte order value");
1154  		return -1;
1155  	}
1156  	*ver = ourvers;
1157  	return 0;
1158  novers:
1159  	snprintf(errbuf, PCAP_ERRBUF_SIZE,
1160  	    "The server doesn't support any protocol version that we support");
1161  	return -1;
1162  }
1163  static const char userinfo_allowed_symbols[] = "-._~!&'()*+,;=";
1164  static int rpcap_doauth_userinfo(SOCKET sockctrl, SSL *ssl, uint8_t *ver,
1165      int *byte_swapped, const char *userinfo, char *errbuf)
1166  {
1167  	struct pcap_rmtauth auth;
1168  	const char *ptr;
1169  	char *buf, username[256], password[256];
1170  	auth.type = RPCAP_RMTAUTH_PWD;
1171  	auth.username = username;
1172  	auth.password = password;
1173  	buf = username;
1174  	username[0] = password[0] = '\0';
1175  	if ((ptr = userinfo) != NULL)
1176  	{
1177  		for (int pos = -1; (buf[++pos] = *ptr) != '\0'; ++ptr)
1178  		{
1179  			if (*ptr == '%')
1180  			{
1181  				if (sscanf(ptr, "%%%02hhx", (unsigned char *)(buf+pos)) == 1)
1182  					ptr += 2;
1183  				if (buf[pos] == '\0')
1184  				{
1185  					snprintf(errbuf, PCAP_ERRBUF_SIZE, "Invalid escape `%%00` in userinfo");
1186  					return -1;
1187  				}
1188  			}
1189  			else if (*ptr == ':' && buf == username)
1190  			{
1191  				buf[pos] = '\0';
1192  				buf = password;
1193  				pos = -1;
1194  			}
1195  			else if (*ptr >= 'A' && *ptr <= 'Z')
1196  				continue;
1197  			else if (*ptr >= 'a' && *ptr <= 'z')
1198  				continue;
1199  			else if (*ptr >= '0' && *ptr <= '9')
1200  				continue;
1201  			else if (*ptr < ' ' || *ptr > '~')
1202  			{
1203  				snprintf(errbuf, PCAP_ERRBUF_SIZE, "Invalid character `\\%o` in userinfo", *ptr);
1204  				return -1;
1205  			}
1206  			else if (strchr(userinfo_allowed_symbols, *ptr) == NULL)
1207  			{
1208  				snprintf(errbuf, PCAP_ERRBUF_SIZE, "Invalid character `%c` in userinfo", *ptr);
1209  				return -1;
1210  			}
1211  		}
1212  		return rpcap_doauth(sockctrl, ssl, ver, byte_swapped, &auth,
1213  		    errbuf);
1214  	}
1215  	return rpcap_doauth(sockctrl, ssl, ver, byte_swapped, NULL, errbuf);
1216  }
1217  static int
1218  pcap_getnonblock_rpcap(pcap_t *p)
1219  {
1220  	snprintf(p->errbuf, PCAP_ERRBUF_SIZE,
1221  	    "Non-blocking mode isn't supported for capturing remotely with rpcap");
1222  	return (-1);
1223  }
1224  static int
1225  pcap_setnonblock_rpcap(pcap_t *p, int nonblock _U_)
1226  {
1227  	snprintf(p->errbuf, PCAP_ERRBUF_SIZE,
1228  	    "Non-blocking mode isn't supported for capturing remotely with rpcap");
1229  	return (-1);
1230  }
1231  static int
1232  rpcap_setup_session(const char *source, struct pcap_rmtauth *auth,
1233      int *activep, SOCKET *sockctrlp, uint8_t *uses_sslp, SSL **sslp,
1234      int rmt_flags, uint8_t *protocol_versionp, int *byte_swappedp,
1235      char *host, char *port, char *iface, char *errbuf)
1236  {
1237  	int type;
1238  	int auth_result;
1239  	char userinfo[512];			&bsol;* 256 characters each for username and password */
1240  	struct activehosts *activeconn;		&bsol;* active connection, if there is one */
1241  	int error;				&bsol;* 1 if rpcap_remoteact_getsock got an error */
1242  	userinfo[0] = '\0';
1243  	if (pcap_parsesrcstr_ex(source, &type, userinfo, host, port, iface, uses_sslp,
1244  	    errbuf) == -1)
1245  		return -1;
1246  	if (type != PCAP_SRC_IFREMOTE)
1247  	{
1248  		snprintf(errbuf, PCAP_ERRBUF_SIZE,
1249  		    "Non-remote interface passed to remote capture routine");
1250  		return -1;
1251  	}
1252  	if (*uses_sslp && (rmt_flags & PCAP_OPENFLAG_DATATX_UDP))
1253  	{
1254  		snprintf(errbuf, PCAP_ERRBUF_SIZE,
1255  		    "TLS not supported with UDP forward of remote packets");
1256  		return -1;
1257  	}
1258  	if (sock_init(errbuf, PCAP_ERRBUF_SIZE) == -1)
1259  		return -1;
1260  	activeconn = rpcap_remoteact_getsock(host, &error, errbuf);
1261  	if (activeconn != NULL)
1262  	{
1263  		*activep = 1;
1264  		*sockctrlp = activeconn->sockctrl;
1265  		*sslp = activeconn->ssl;
1266  		*protocol_versionp = activeconn->protocol_version;
1267  		*byte_swappedp = activeconn->byte_swapped;
1268  	}
1269  	else
1270  	{
1271  		*activep = 0;
1272  		struct addrinfo hints;		&bsol;* temp variable needed to resolve hostnames into to socket representation */
1273  		struct addrinfo *addrinfo;	&bsol;* temp variable needed to resolve hostnames into to socket representation */
1274  		if (error)
1275  		{
1276  			return -1;
1277  		}
1278  		memset(&hints, 0, sizeof(struct addrinfo));
1279  		hints.ai_family = PF_UNSPEC;
1280  		hints.ai_socktype = SOCK_STREAM;
1281  		if (port[0] == 0)
1282  		{
1283  			if (sock_initaddress(host, RPCAP_DEFAULT_NETPORT,
1284  			    &hints, &addrinfo, errbuf, PCAP_ERRBUF_SIZE) == -1)
1285  				return -1;
1286  		}
1287  		else
1288  		{
1289  			if (sock_initaddress(host, port, &hints, &addrinfo,
1290  			    errbuf, PCAP_ERRBUF_SIZE) == -1)
1291  				return -1;
1292  		}
1293  		if ((*sockctrlp = sock_open(host, addrinfo, SOCKOPEN_CLIENT, 0,
1294  		    errbuf, PCAP_ERRBUF_SIZE)) == INVALID_SOCKET)
1295  		{
1296  			freeaddrinfo(addrinfo);
1297  			return -1;
1298  		}
1299  		freeaddrinfo(addrinfo);
1300  		addrinfo = NULL;
1301  		if (*uses_sslp)
1302  		{
1303  #ifdef HAVE_OPENSSL
1304  			*sslp = ssl_promotion(0, *sockctrlp, errbuf,
1305  			    PCAP_ERRBUF_SIZE);
1306  			if (!*sslp)
1307  			{
1308  				sock_close(*sockctrlp, NULL, 0);
1309  				return -1;
1310  			}
1311  #else
1312  			snprintf(errbuf, PCAP_ERRBUF_SIZE,
1313  			    "No TLS support");
1314  			sock_close(*sockctrlp, NULL, 0);
1315  			return -1;
1316  #endif
1317  		}
1318  		if (auth == NULL && *userinfo != '\0')
1319  		{
1320  			auth_result = rpcap_doauth_userinfo(*sockctrlp, *sslp,
1321  			    protocol_versionp, byte_swappedp, userinfo, errbuf);
1322  		}
1323  		else
1324  		{
1325  			auth_result = rpcap_doauth(*sockctrlp, *sslp,
1326  			    protocol_versionp, byte_swappedp, auth, errbuf);
1327  		}
1328  		if (auth_result == -1)
1329  		{
1330  #ifdef HAVE_OPENSSL
1331  			if (*sslp)
1332  			{
1333  				ssl_finish(*sslp);
1334  			}
1335  #endif
1336  			sock_close(*sockctrlp, NULL, 0);
1337  			return -1;
1338  		}
1339  	}
1340  	return 0;
1341  }
1342  pcap_t *pcap_open_rpcap(const char *source, int snaplen, int flags, int read_timeout, struct pcap_rmtauth *auth, char *errbuf)
1343  {
1344  	pcap_t *fp;
1345  	char *source_str;
1346  	struct pcap_rpcap *pr;		&bsol;* structure used when doing a remote live capture */
1347  	char host[PCAP_BUF_SIZE], ctrlport[PCAP_BUF_SIZE], iface[PCAP_BUF_SIZE];
1348  	SOCKET sockctrl;
1349  	SSL *ssl = NULL;
1350  	uint8_t protocol_version;		&bsol;* negotiated protocol version */
1351  	int byte_swapped;			&bsol;* server is known to be byte-swapped */
1352  	int active;
1353  	uint32_t plen;
1354  	char sendbuf[RPCAP_NETBUF_SIZE];	&bsol;* temporary buffer in which data to be sent is buffered */
1355  	int sendbufidx = 0;			&bsol;* index which keeps the number of bytes currently buffered */
1356  	struct rpcap_header header;		&bsol;* header of the RPCAP packet */
1357  	struct rpcap_openreply openreply;	&bsol;* open reply message */
1358  	fp = PCAP_CREATE_COMMON(errbuf, struct pcap_rpcap);
1359  	if (fp == NULL)
1360  	{
1361  		return NULL;
1362  	}
1363  	source_str = strdup(source);
1364  	if (source_str == NULL) {
1365  		pcap_fmt_errmsg_for_errno(errbuf, PCAP_ERRBUF_SIZE,
1366  		    errno, "malloc");
1367  		return NULL;
1368  	}
1369  	if (snaplen <= 0 || snaplen > MAXIMUM_SNAPLEN)
1370  		snaplen = MAXIMUM_SNAPLEN;
1371  	fp->opt.device = source_str;
1372  	fp->snapshot = snaplen;
1373  	fp->opt.timeout = read_timeout;
1374  	pr = fp->priv;
1375  	pr->rmt_flags = flags;
1376  	if (rpcap_setup_session(fp->opt.device, auth, &active, &sockctrl,
1377  	    &pr->uses_ssl, &ssl, flags, &protocol_version, &byte_swapped,
1378  	    host, ctrlport, iface, errbuf) == -1)
1379  	{
1380  		pcap_close(fp);
1381  		return NULL;
1382  	}
1383  	ssl_main = ssl;
1384  	if (sock_bufferize(NULL, sizeof(struct rpcap_header), NULL,
1385  		&sendbufidx, RPCAP_NETBUF_SIZE, SOCKBUF_CHECKONLY, errbuf, PCAP_ERRBUF_SIZE))
1386  		goto error_nodiscard;
1387  	rpcap_createhdr((struct rpcap_header *) sendbuf, protocol_version,
1388  	    RPCAP_MSG_OPEN_REQ, 0, (uint32_t) strlen(iface));
1389  	if (sock_bufferize(iface, (int) strlen(iface), sendbuf, &sendbufidx,
1390  		RPCAP_NETBUF_SIZE, SOCKBUF_BUFFERIZE, errbuf, PCAP_ERRBUF_SIZE))
1391  		goto error_nodiscard;
1392  	if (sock_send(sockctrl, ssl, sendbuf, sendbufidx, errbuf,
1393  	    PCAP_ERRBUF_SIZE) < 0)
1394  		goto error_nodiscard;
1395  	if (rpcap_process_msg_header(sockctrl, ssl, protocol_version,
1396  	    RPCAP_MSG_OPEN_REQ, &header, errbuf) == -1)
1397  		goto error_nodiscard;
1398  	plen = header.plen;
1399  	if (rpcap_recv(sockctrl, ssl, (char *)&openreply,
1400  	    sizeof(struct rpcap_openreply), &plen, errbuf) == -1)
1401  		goto error;
1402  	if (rpcap_discard(sockctrl, ssl, plen, errbuf) == -1)
1403  		goto error_nodiscard;
1404  	fp->linktype = ntohl(openreply.linktype);
<span onclick='openModal()' class='match'>1405  	pr->rmt_sockctrl = sockctrl;
1406  	pr->ctrl_ssl = ssl;
1407  	pr->protocol_version = protocol_version;
1408  	pr->byte_swapped = byte_swapped;
1409  	pr->rmt_clientside = 1;
1410  	fp->read_op = pcap_read_rpcap;
1411  	fp->save_current_filter_op = pcap_save_current_filter_rpcap;
1412  	fp->setfilter_op = pcap_setfilter_rpcap;
1413  	fp->getnonblock_op = pcap_getnonblock_rpcap;
1414  	fp->setnonblock_op = pcap_setnonblock_rpcap;
1415  	fp->stats_op = pcap_stats_rpcap;
1416  #ifdef _WIN32
1417  	fp->stats_ex_op = pcap_stats_ex_rpcap;
1418  #endif
1419  	fp->cleanup_op = pcap_cleanup_rpcap;
1420  	fp->activated = 1;
1421  	return fp;
</span>1422  error:
1423  	(void)rpcap_discard(sockctrl, pr->ctrl_ssl, plen, NULL);
1424  error_nodiscard:
1425  	if (!active)
1426  	{
1427  #ifdef HAVE_OPENSSL
1428  		if (ssl)
1429  		{
1430  			ssl_finish(ssl);
1431  		}
1432  #endif
1433  		sock_close(sockctrl, NULL, 0);
1434  	}
1435  	pcap_close(fp);
1436  	return NULL;
1437  }
1438  #define PCAP_TEXT_SOURCE_ADAPTER "Network adapter"
1439  #define PCAP_TEXT_SOURCE_ADAPTER_LEN (sizeof PCAP_TEXT_SOURCE_ADAPTER - 1)
1440  #define PCAP_TEXT_SOURCE_ON_REMOTE_HOST "on remote node"
1441  #define PCAP_TEXT_SOURCE_ON_REMOTE_HOST_LEN (sizeof PCAP_TEXT_SOURCE_ON_REMOTE_HOST - 1)
1442  static void
1443  freeaddr(struct pcap_addr *addr)
1444  {
1445  	free(addr->addr);
1446  	free(addr->netmask);
1447  	free(addr->broadaddr);
1448  	free(addr->dstaddr);
1449  	free(addr);
1450  }
1451  int
1452  pcap_findalldevs_ex_remote(const char *source, struct pcap_rmtauth *auth, pcap_if_t **alldevs, char *errbuf)
1453  {
1454  	uint8_t protocol_version;	&bsol;* protocol version */
1455  	int byte_swapped;		&bsol;* Server byte order is swapped from ours */
1456  	SOCKET sockctrl;		&bsol;* socket descriptor of the control connection */
1457  	SSL *ssl = NULL;		&bsol;* optional SSL handler for sockctrl */
1458  	uint32_t plen;
1459  	struct rpcap_header header;	&bsol;* structure that keeps the general header of the rpcap protocol */
1460  	int i, j;		&bsol;* temp variables */
1461  	int nif;		&bsol;* Number of interfaces listed */
1462  	int active;			&bsol;* 'true' if we the other end-party is in active mode */
1463  	uint8_t uses_ssl;
1464  	char host[PCAP_BUF_SIZE], port[PCAP_BUF_SIZE];
1465  	char tmpstring[PCAP_BUF_SIZE + 1];		&bsol;* Needed to convert names and descriptions from 'old' syntax to the 'new' one */
1466  	pcap_if_t *lastdev;	&bsol;* Last device in the pcap_if_t list */
1467  	pcap_if_t *dev;		&bsol;* Device we're adding to the pcap_if_t list */
1468  	(*alldevs) = NULL;
1469  	lastdev = NULL;
1470  	if (rpcap_setup_session(source, auth, &active, &sockctrl, &uses_ssl,
1471  	    &ssl, 0, &protocol_version, &byte_swapped, host, port, NULL,
1472  	    errbuf) == -1)
1473  	{
1474  		return -1;
1475  	}
1476  	rpcap_createhdr(&header, protocol_version, RPCAP_MSG_FINDALLIF_REQ,
1477  	    0, 0);
1478  	if (sock_send(sockctrl, ssl, (char *)&header, sizeof(struct rpcap_header),
1479  	    errbuf, PCAP_ERRBUF_SIZE) < 0)
1480  		goto error_nodiscard;
1481  	if (rpcap_process_msg_header(sockctrl, ssl, protocol_version,
1482  	    RPCAP_MSG_FINDALLIF_REQ, &header, errbuf) == -1)
1483  		goto error_nodiscard;
1484  	plen = header.plen;
1485  	nif = ntohs(header.value);
1486  	for (i = 0; i < nif; i++)
1487  	{
1488  		struct rpcap_findalldevs_if findalldevs_if;
1489  		char tmpstring2[PCAP_BUF_SIZE + 1];		&bsol;* Needed to convert names and descriptions from 'old' syntax to the 'new' one */
1490  		struct pcap_addr *addr, *prevaddr;
1491  		tmpstring2[PCAP_BUF_SIZE] = 0;
1492  		if (rpcap_recv(sockctrl, ssl, (char *)&findalldevs_if,
1493  		    sizeof(struct rpcap_findalldevs_if), &plen, errbuf) == -1)
1494  			goto error;
1495  		findalldevs_if.namelen = ntohs(findalldevs_if.namelen);
1496  		findalldevs_if.desclen = ntohs(findalldevs_if.desclen);
1497  		findalldevs_if.naddr = ntohs(findalldevs_if.naddr);
1498  		dev = (pcap_if_t *)malloc(sizeof(pcap_if_t));
1499  		if (dev == NULL)
1500  		{
1501  			pcap_fmt_errmsg_for_errno(errbuf, PCAP_ERRBUF_SIZE,
1502  			    errno, "malloc() failed");
1503  			goto error;
1504  		}
1505  		memset(dev, 0, sizeof(pcap_if_t));
1506  		if (lastdev == NULL)
1507  		{
1508  			*alldevs = dev;
1509  		}
1510  		else
1511  		{
1512  			lastdev->next = dev;
1513  		}
1514  		lastdev = dev;
1515  		if (findalldevs_if.namelen)
1516  		{
1517  			if (findalldevs_if.namelen >= sizeof(tmpstring))
1518  			{
1519  				snprintf(errbuf, PCAP_ERRBUF_SIZE, "Interface name too long");
1520  				goto error;
1521  			}
1522  			if (rpcap_recv(sockctrl, ssl, tmpstring,
1523  			    findalldevs_if.namelen, &plen, errbuf) == -1)
1524  				goto error;
1525  			tmpstring[findalldevs_if.namelen] = 0;
1526  			if (pcap_createsrcstr_ex(tmpstring2, PCAP_SRC_IFREMOTE,
1527  			    NULL, host, port, tmpstring, uses_ssl, errbuf) == -1)
1528  				goto error;
1529  			dev->name = strdup(tmpstring2);
1530  			if (dev->name == NULL)
1531  			{
1532  				pcap_fmt_errmsg_for_errno(errbuf,
1533  				    PCAP_ERRBUF_SIZE, errno, "malloc() failed");
1534  				goto error;
1535  			}
1536  		}
1537  		if (findalldevs_if.desclen)
1538  		{
1539  			if (findalldevs_if.desclen >= sizeof(tmpstring))
1540  			{
1541  				snprintf(errbuf, PCAP_ERRBUF_SIZE, "Interface description too long");
1542  				goto error;
1543  			}
1544  			if (rpcap_recv(sockctrl, ssl, tmpstring,
1545  			    findalldevs_if.desclen, &plen, errbuf) == -1)
1546  				goto error;
1547  			tmpstring[findalldevs_if.desclen] = 0;
1548  			if (pcap_asprintf(&dev->description,
1549  			    "%s '%s' %s %s", PCAP_TEXT_SOURCE_ADAPTER,
1550  			    tmpstring, PCAP_TEXT_SOURCE_ON_REMOTE_HOST, host) == -1)
1551  			{
1552  				pcap_fmt_errmsg_for_errno(errbuf,
1553  				    PCAP_ERRBUF_SIZE, errno, "malloc() failed");
1554  				goto error;
1555  			}
1556  		}
1557  		dev->flags = ntohl(findalldevs_if.flags);
1558  		prevaddr = NULL;
1559  		for (j = 0; j < findalldevs_if.naddr; j++)
1560  		{
1561  			struct rpcap_findalldevs_ifaddr ifaddr;
1562  			if (rpcap_recv(sockctrl, ssl, (char *)&ifaddr,
1563  			    sizeof(struct rpcap_findalldevs_ifaddr),
1564  			    &plen, errbuf) == -1)
1565  				goto error;
1566  			addr = (struct pcap_addr *) malloc(sizeof(struct pcap_addr));
1567  			if (addr == NULL)
1568  			{
1569  				pcap_fmt_errmsg_for_errno(errbuf,
1570  				    PCAP_ERRBUF_SIZE, errno, "malloc() failed");
1571  				goto error;
1572  			}
1573  			addr->next = NULL;
1574  			addr->addr = NULL;
1575  			addr->netmask = NULL;
1576  			addr->broadaddr = NULL;
1577  			addr->dstaddr = NULL;
1578  			if (rpcap_deseraddr(&ifaddr.addr,
1579  				(struct sockaddr_storage **) &addr->addr, errbuf) == -1)
1580  			{
1581  				freeaddr(addr);
1582  				goto error;
1583  			}
1584  			if (rpcap_deseraddr(&ifaddr.netmask,
1585  				(struct sockaddr_storage **) &addr->netmask, errbuf) == -1)
1586  			{
1587  				freeaddr(addr);
1588  				goto error;
1589  			}
1590  			if (rpcap_deseraddr(&ifaddr.broadaddr,
1591  				(struct sockaddr_storage **) &addr->broadaddr, errbuf) == -1)
1592  			{
1593  				freeaddr(addr);
1594  				goto error;
1595  			}
1596  			if (rpcap_deseraddr(&ifaddr.dstaddr,
1597  				(struct sockaddr_storage **) &addr->dstaddr, errbuf) == -1)
1598  			{
1599  				freeaddr(addr);
1600  				goto error;
1601  			}
1602  			if ((addr->addr == NULL) && (addr->netmask == NULL) &&
1603  				(addr->broadaddr == NULL) && (addr->dstaddr == NULL))
1604  			{
1605  				free(addr);
1606  			}
1607  			else
1608  			{
1609  				if (prevaddr == NULL)
1610  				{
1611  					dev->addresses = addr;
1612  				}
1613  				else
1614  				{
1615  					prevaddr->next = addr;
1616  				}
1617  				prevaddr = addr;
1618  			}
1619  		}
1620  	}
1621  	if (rpcap_discard(sockctrl, ssl, plen, errbuf) == 1)
1622  		goto error_nodiscard;
1623  	if (!active)
1624  	{
1625  #ifdef HAVE_OPENSSL
1626  		if (ssl)
1627  		{
1628  			ssl_finish(ssl);
1629  		}
1630  #endif
1631  		if (sock_close(sockctrl, errbuf, PCAP_ERRBUF_SIZE))
1632  			return -1;
1633  	}
1634  	sock_cleanup();
1635  	return 0;
1636  error:
1637  	(void) rpcap_discard(sockctrl, ssl, plen, NULL);
1638  error_nodiscard:
1639  	if (!active)
1640  	{
1641  #ifdef HAVE_OPENSSL
1642  		if (ssl)
1643  		{
1644  			ssl_finish(ssl);
1645  		}
1646  #endif
1647  		sock_close(sockctrl, NULL, 0);
1648  	}
1649  	sock_cleanup();
1650  	pcap_freealldevs(*alldevs);
1651  	return -1;
1652  }
1653  SOCKET pcap_remoteact_accept_ex(const char *address, const char *port, const char *hostlist, char *connectinghost, struct pcap_rmtauth *auth, int uses_ssl, char *errbuf)
1654  {
1655  	struct addrinfo hints;			&bsol;* temporary struct to keep settings needed to open the new socket */
1656  	struct addrinfo *addrinfo;		&bsol;* keeps the addrinfo chain; required to open a new socket */
1657  	struct sockaddr_storage from;	&bsol;* generic sockaddr_storage variable */
1658  	socklen_t fromlen;				&bsol;* keeps the length of the sockaddr_storage variable */
1659  	SOCKET sockctrl;				&bsol;* keeps the main socket identifier */
1660  	SSL *ssl = NULL;				&bsol;* Optional SSL handler for sockctrl */
1661  	uint8_t protocol_version;		&bsol;* negotiated protocol version */
1662  	int byte_swapped;			&bsol;* 1 if server byte order is known to be the reverse of ours */
1663  	struct activehosts *temp, *prev;	&bsol;* temp var needed to scan he host list chain */
1664  	*connectinghost = 0;		&bsol;* just in case */
1665  	memset(&hints, 0, sizeof(struct addrinfo));
1666  	hints.ai_family = AF_INET;		&bsol;* PF_UNSPEC to have both IPv4 and IPv6 server */
1667  	hints.ai_flags = AI_PASSIVE;	&bsol;* Ready to a bind() socket */
1668  	hints.ai_socktype = SOCK_STREAM;
1669  	if (sock_init(errbuf, PCAP_ERRBUF_SIZE) == -1)
1670  		return (SOCKET)-1;
1671  	if ((port == NULL) || (port[0] == 0))
1672  	{
1673  		if (sock_initaddress(address, RPCAP_DEFAULT_NETPORT_ACTIVE, &hints, &addrinfo, errbuf, PCAP_ERRBUF_SIZE) == -1)
1674  		{
1675  			return (SOCKET)-2;
1676  		}
1677  	}
1678  	else
1679  	{
1680  		if (sock_initaddress(address, port, &hints, &addrinfo, errbuf, PCAP_ERRBUF_SIZE) == -1)
1681  		{
1682  			return (SOCKET)-2;
1683  		}
1684  	}
1685  	if ((sockmain = sock_open(NULL, addrinfo, SOCKOPEN_SERVER, 1, errbuf, PCAP_ERRBUF_SIZE)) == INVALID_SOCKET)
1686  	{
1687  		freeaddrinfo(addrinfo);
1688  		return (SOCKET)-2;
1689  	}
1690  	freeaddrinfo(addrinfo);
1691  	fromlen = sizeof(struct sockaddr_storage);
1692  	sockctrl = accept(sockmain, (struct sockaddr *) &from, &fromlen);
1693  	closesocket(sockmain);
1694  	sockmain = 0;
1695  	if (sockctrl == INVALID_SOCKET)
1696  	{
1697  		sock_geterrmsg(errbuf, PCAP_ERRBUF_SIZE, "accept() failed");
1698  		return (SOCKET)-2;
1699  	}
1700  	if (uses_ssl)
1701  	{
1702  #ifdef HAVE_OPENSSL
1703  		ssl = ssl_promotion(0, sockctrl, errbuf, PCAP_ERRBUF_SIZE);
1704  		if (! ssl)
1705  		{
1706  			sock_close(sockctrl, NULL, 0);
1707  			return (SOCKET)-1;
1708  		}
1709  #else
1710  		snprintf(errbuf, PCAP_ERRBUF_SIZE, "No TLS support");
1711  		sock_close(sockctrl, NULL, 0);
1712  		return (SOCKET)-1;
1713  #endif
1714  	}
1715  	if (getnameinfo((struct sockaddr *) &from, fromlen, connectinghost, RPCAP_HOSTLIST_SIZE, NULL, 0, NI_NUMERICHOST))
1716  	{
1717  		sock_geterrmsg(errbuf, PCAP_ERRBUF_SIZE,
1718  		    "getnameinfo() failed");
1719  		rpcap_senderror(sockctrl, ssl, 0, PCAP_ERR_REMOTEACCEPT, errbuf, NULL);
1720  #ifdef HAVE_OPENSSL
1721  		if (ssl)
1722  		{
1723  			ssl_finish(ssl);
1724  		}
1725  #endif
1726  		sock_close(sockctrl, NULL, 0);
1727  		return (SOCKET)-1;
1728  	}
1729  	if (sock_check_hostlist((char *)hostlist, RPCAP_HOSTLIST_SEP, &from, errbuf, PCAP_ERRBUF_SIZE) < 0)
1730  	{
1731  		rpcap_senderror(sockctrl, ssl, 0, PCAP_ERR_REMOTEACCEPT, errbuf, NULL);
1732  #ifdef HAVE_OPENSSL
1733  		if (ssl)
1734  		{
1735  			ssl_finish(ssl);
1736  		}
1737  #endif
1738  		sock_close(sockctrl, NULL, 0);
1739  		return (SOCKET)-1;
1740  	}
1741  	if (rpcap_doauth(sockctrl, ssl, &protocol_version, &byte_swapped,
1742  	    auth, errbuf) == -1)
1743  	{
1744  		rpcap_senderror(sockctrl, ssl, 0, PCAP_ERR_REMOTEACCEPT, errbuf, NULL);
1745  #ifdef HAVE_OPENSSL
1746  		if (ssl)
1747  		{
1748  			ssl_finish(ssl);
1749  		}
1750  #endif
1751  		sock_close(sockctrl, NULL, 0);
1752  		return (SOCKET)-3;
1753  	}
1754  	temp = activeHosts;
1755  	prev = NULL;
1756  	while (temp)
1757  	{
1758  		if (sock_cmpaddr(&temp->host, &from) == 0)
1759  			return sockctrl;
1760  		prev = temp;
1761  		temp = temp->next;
1762  	}
1763  	if (prev)
1764  	{
1765  		prev->next = (struct activehosts *) malloc(sizeof(struct activehosts));
1766  		temp = prev->next;
1767  	}
1768  	else
1769  	{
1770  		activeHosts = (struct activehosts *) malloc(sizeof(struct activehosts));
1771  		temp = activeHosts;
1772  	}
1773  	if (temp == NULL)
1774  	{
1775  		pcap_fmt_errmsg_for_errno(errbuf, PCAP_ERRBUF_SIZE,
1776  		    errno, "malloc() failed");
1777  		rpcap_senderror(sockctrl, ssl, protocol_version, PCAP_ERR_REMOTEACCEPT, errbuf, NULL);
1778  #ifdef HAVE_OPENSSL
1779  		if (ssl)
1780  		{
1781  			ssl_finish(ssl);
1782  		}
1783  #endif
1784  		sock_close(sockctrl, NULL, 0);
1785  		return (SOCKET)-1;
1786  	}
1787  	memcpy(&temp->host, &from, fromlen);
1788  	temp->sockctrl = sockctrl;
1789  	temp->ssl = ssl;
1790  	temp->protocol_version = protocol_version;
1791  	temp->byte_swapped = byte_swapped;
1792  	temp->next = NULL;
1793  	return sockctrl;
1794  }
1795  SOCKET pcap_remoteact_accept(const char *address, const char *port, const char *hostlist, char *connectinghost, struct pcap_rmtauth *auth, char *errbuf)
1796  {
1797  	return pcap_remoteact_accept_ex(address, port, hostlist, connectinghost, auth, 0, errbuf);
1798  }
1799  int pcap_remoteact_close(const char *host, char *errbuf)
1800  {
1801  	struct activehosts *temp, *prev;	&bsol;* temp var needed to scan the host list chain */
1802  	struct addrinfo hints, *addrinfo, *ai_next;	&bsol;* temp var needed to translate between hostname to its address */
1803  	int retval;
1804  	temp = activeHosts;
1805  	prev = NULL;
1806  	addrinfo = NULL;
1807  	memset(&hints, 0, sizeof(struct addrinfo));
1808  	hints.ai_family = PF_UNSPEC;
1809  	hints.ai_socktype = SOCK_STREAM;
1810  	retval = sock_initaddress(host, NULL, &hints, &addrinfo, errbuf,
1811  	    PCAP_ERRBUF_SIZE);
1812  	if (retval != 0)
1813  	{
1814  		return -1;
1815  	}
1816  	while (temp)
1817  	{
1818  		ai_next = addrinfo;
1819  		while (ai_next)
1820  		{
1821  			if (sock_cmpaddr(&temp->host, (struct sockaddr_storage *) ai_next->ai_addr) == 0)
1822  			{
1823  				struct rpcap_header header;
1824  				int status = 0;
1825  				rpcap_createhdr(&header, temp->protocol_version,
1826  				    RPCAP_MSG_CLOSE, 0, 0);
1827  				if (sock_send(temp->sockctrl, temp->ssl,
1828  				    (char *)&header,
1829  				    sizeof(struct rpcap_header), errbuf,
1830  				    PCAP_ERRBUF_SIZE) < 0)
1831  				{
1832  #ifdef HAVE_OPENSSL
1833  					if (temp->ssl)
1834  					{
1835  						ssl_finish(temp->ssl);
1836  					}
1837  #endif
1838  					(void)sock_close(temp->sockctrl, NULL,
1839  					   0);
1840  					status = -1;
1841  				}
1842  				else
1843  				{
1844  #ifdef HAVE_OPENSSL
1845  					if (temp->ssl)
1846  					{
1847  						ssl_finish(temp->ssl);
1848  					}
1849  #endif
1850  					if (sock_close(temp->sockctrl, errbuf,
1851  					   PCAP_ERRBUF_SIZE) == -1)
1852  						status = -1;
1853  				}
1854  				if (prev)
1855  					prev->next = temp->next;
1856  				else
1857  					activeHosts = temp->next;
1858  				freeaddrinfo(addrinfo);
1859  				free(temp);
1860  				sock_cleanup();
1861  				return status;
1862  			}
1863  			ai_next = ai_next->ai_next;
1864  		}
1865  		prev = temp;
1866  		temp = temp->next;
1867  	}
1868  	if (addrinfo)
1869  		freeaddrinfo(addrinfo);
1870  	sock_cleanup();
1871  	snprintf(errbuf, PCAP_ERRBUF_SIZE, "The host you want to close the active connection is not known");
1872  	return -1;
1873  }
1874  void pcap_remoteact_cleanup(void)
1875  {
1876  #	ifdef HAVE_OPENSSL
1877  	if (ssl_main)
1878  	{
1879  		ssl_finish(ssl_main);
1880  		ssl_main = NULL;
1881  	}
1882  #	endif
1883  	if (sockmain)
1884  	{
1885  		closesocket(sockmain);
1886  		sock_cleanup();
1887  	}
1888  }
1889  int pcap_remoteact_list(char *hostlist, char sep, int size, char *errbuf)
1890  {
1891  	struct activehosts *temp;	&bsol;* temp var needed to scan the host list chain */
1892  	size_t len;
1893  	char hoststr[RPCAP_HOSTLIST_SIZE + 1];
1894  	temp = activeHosts;
1895  	len = 0;
1896  	*hostlist = 0;
1897  	while (temp)
1898  	{
1899  		if (sock_getascii_addrport((struct sockaddr_storage *) &temp->host, hoststr,
1900  			RPCAP_HOSTLIST_SIZE, NULL, 0, NI_NUMERICHOST, errbuf, PCAP_ERRBUF_SIZE) != -1)
1901  		{
1902  			return -1;
1903  		}
1904  		len = len + strlen(hoststr) + 1 &bsol;* the separator */;
1905  		if ((size < 0) || (len >= (size_t)size))
1906  		{
1907  			snprintf(errbuf, PCAP_ERRBUF_SIZE, "The string you provided is not able to keep "
1908  				"the hostnames for all the active connections");
1909  			return -1;
1910  		}
1911  		pcap_strlcat(hostlist, hoststr, PCAP_ERRBUF_SIZE);
1912  		hostlist[len - 1] = sep;
1913  		hostlist[len] = 0;
1914  		temp = temp->next;
1915  	}
1916  	return 0;
1917  }
1918  static int rpcap_recv_msg_header(SOCKET sock, SSL *ssl, struct rpcap_header *header, char *errbuf)
1919  {
1920  	int nrecv;
1921  	nrecv = sock_recv(sock, ssl, (char *) header, sizeof(struct rpcap_header),
1922  	    SOCK_RECEIVEALL_YES|SOCK_EOF_IS_ERROR, errbuf,
1923  	    PCAP_ERRBUF_SIZE);
1924  	if (nrecv == -1)
1925  	{
1926  		return -1;
1927  	}
1928  	header->plen = ntohl(header->plen);
1929  	return 0;
1930  }
1931  static int rpcap_check_msg_ver(SOCKET sock, SSL *ssl, uint8_t expected_ver, struct rpcap_header *header, char *errbuf)
1932  {
1933  	if (header->ver != expected_ver)
1934  	{
1935  		if (rpcap_discard(sock, ssl, header->plen, errbuf) == -1)
1936  			return -1;
1937  		if (errbuf != NULL)
1938  		{
1939  			snprintf(errbuf, PCAP_ERRBUF_SIZE,
1940  			    "Server sent us a message with version %u when we were expecting %u",
1941  			    header->ver, expected_ver);
1942  		}
1943  		return -1;
1944  	}
1945  	return 0;
1946  }
1947  static int rpcap_check_msg_type(SOCKET sock, SSL *ssl, uint8_t request_type, struct rpcap_header *header, uint16_t *errcode, char *errbuf)
1948  {
1949  	const char *request_type_string;
1950  	const char *msg_type_string;
1951  	if (header->type == RPCAP_MSG_ERROR)
1952  	{
1953  		*errcode = ntohs(header->value);
1954  		rpcap_msg_err(sock, ssl, header->plen, errbuf);
1955  		return -1;
1956  	}
1957  	*errcode = 0;
1958  	if (header->type != (request_type | RPCAP_MSG_IS_REPLY))
1959  	{
1960  		if (rpcap_discard(sock, ssl, header->plen, errbuf) == -1)
1961  			return -1;
1962  		request_type_string = rpcap_msg_type_string(request_type);
1963  		msg_type_string = rpcap_msg_type_string(header->type);
1964  		if (errbuf != NULL)
1965  		{
1966  			if (request_type_string == NULL)
1967  			{
1968  				snprintf(errbuf, PCAP_ERRBUF_SIZE,
1969  				    "rpcap_check_msg_type called for request message with type %u",
1970  				    request_type);
1971  				return -1;
1972  			}
1973  			if (msg_type_string != NULL)
1974  				snprintf(errbuf, PCAP_ERRBUF_SIZE,
1975  				    "%s message received in response to a %s message",
1976  				    msg_type_string, request_type_string);
1977  			else
1978  				snprintf(errbuf, PCAP_ERRBUF_SIZE,
1979  				    "Message of unknown type %u message received in response to a %s request",
1980  				    header->type, request_type_string);
1981  		}
1982  		return -1;
1983  	}
1984  	return 0;
1985  }
1986  static int rpcap_process_msg_header(SOCKET sock, SSL *ssl, uint8_t expected_ver, uint8_t request_type, struct rpcap_header *header, char *errbuf)
1987  {
1988  	uint16_t errcode;
1989  	if (rpcap_recv_msg_header(sock, ssl, header, errbuf) == -1)
1990  	{
1991  		return -1;
1992  	}
1993  	if (rpcap_check_msg_ver(sock, ssl, expected_ver, header, errbuf) == -1)
1994  		return -1;
1995  	return rpcap_check_msg_type(sock, ssl, request_type, header,
1996  	    &errcode, errbuf);
1997  }
1998  static int rpcap_recv(SOCKET sock, SSL *ssl, void *buffer, size_t toread, uint32_t *plen, char *errbuf)
1999  {
2000  	int nread;
2001  	if (toread > *plen)
2002  	{
2003  		snprintf(errbuf, PCAP_ERRBUF_SIZE, "Message payload is too short");
2004  		return -1;
2005  	}
2006  	nread = sock_recv(sock, ssl, buffer, toread,
2007  	    SOCK_RECEIVEALL_YES|SOCK_EOF_IS_ERROR, errbuf, PCAP_ERRBUF_SIZE);
2008  	if (nread == -1)
2009  	{
2010  		return -1;
2011  	}
2012  	*plen -= nread;
2013  	return 0;
2014  }
2015  static void rpcap_msg_err(SOCKET sockctrl, SSL *ssl, uint32_t plen, char *remote_errbuf)
2016  {
2017  	char errbuf[PCAP_ERRBUF_SIZE];
2018  	if (plen >= PCAP_ERRBUF_SIZE)
2019  	{
2020  		if (sock_recv(sockctrl, ssl, remote_errbuf, PCAP_ERRBUF_SIZE - 1,
2021  		    SOCK_RECEIVEALL_YES|SOCK_EOF_IS_ERROR, errbuf,
2022  		    PCAP_ERRBUF_SIZE) == -1)
2023  		{
2024  			DIAG_OFF_FORMAT_TRUNCATION
2025  			snprintf(remote_errbuf, PCAP_ERRBUF_SIZE, "Read of error message from client failed: %s", errbuf);
2026  			DIAG_ON_FORMAT_TRUNCATION
2027  			return;
2028  		}
2029  		remote_errbuf[PCAP_ERRBUF_SIZE - 1] = '\0';
2030  #ifdef _WIN32
2031  		if (!pcap_utf_8_mode)
2032  			utf_8_to_acp_truncated(remote_errbuf);
2033  #endif
2034  		(void)rpcap_discard(sockctrl, ssl, plen - (PCAP_ERRBUF_SIZE - 1), remote_errbuf);
2035  	}
2036  	else if (plen == 0)
2037  	{
2038  		remote_errbuf[0] = '\0';
2039  	}
2040  	else
2041  	{
2042  		if (sock_recv(sockctrl, ssl, remote_errbuf, plen,
2043  		    SOCK_RECEIVEALL_YES|SOCK_EOF_IS_ERROR, errbuf,
2044  		    PCAP_ERRBUF_SIZE) == -1)
2045  		{
2046  			DIAG_OFF_FORMAT_TRUNCATION
2047  			snprintf(remote_errbuf, PCAP_ERRBUF_SIZE, "Read of error message from client failed: %s", errbuf);
2048  			DIAG_ON_FORMAT_TRUNCATION
2049  			return;
2050  		}
2051  		remote_errbuf[plen] = '\0';
2052  	}
2053  }
2054  static int rpcap_discard(SOCKET sock, SSL *ssl, uint32_t len, char *errbuf)
2055  {
2056  	if (len != 0)
2057  	{
2058  		if (sock_discard(sock, ssl, len, errbuf, PCAP_ERRBUF_SIZE) == -1)
2059  		{
2060  			return -1;
2061  		}
2062  	}
2063  	return 0;
2064  }
2065  static int rpcap_read_packet_msg(struct pcap_rpcap const *rp, pcap_t *p, size_t size)
2066  {
2067  	u_char *bp;
2068  	int cc;
2069  	int bytes_read;
2070  	bp = p->bp;
2071  	cc = p->cc;
2072  	while ((size_t)cc < size)
2073  	{
2074  		bytes_read = sock_recv(rp->rmt_sockdata, rp->data_ssl, bp, size - cc,
2075  		    SOCK_RECEIVEALL_NO|SOCK_EOF_IS_ERROR, p->errbuf,
2076  		    PCAP_ERRBUF_SIZE);
2077  		if (bytes_read == -1)
2078  		{
2079  			p->bp = bp;
2080  			p->cc = cc;
2081  			return -1;
2082  		}
2083  		if (bytes_read == -3)
2084  		{
2085  			p->bp = bp;
2086  			p->cc = cc;
2087  			return -3;
2088  		}
2089  		if (bytes_read == 0)
2090  		{
2091  			snprintf(p->errbuf, PCAP_ERRBUF_SIZE,
2092  			    "The server terminated the connection.");
2093  			return -1;
2094  		}
2095  		bp += bytes_read;
2096  		cc += bytes_read;
2097  	}
2098  	p->bp = bp;
2099  	p->cc = cc;
2100  	return 0;
2101  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from libtomcrypt-MDEwOlJlcG9zaXRvcnk3NzcwMTE=-flat-rmd320.c</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from libpcap-MDEwOlJlcG9zaXRvcnk5NDM1ODg3-flat-pcap-rpcap.c</div>
                </div>
                <div class="column column_space"><pre><code>214     tmp = dd; dd = ddd; ddd = tmp;
215     JJ(bb, cc, dd, ee, aa, X[ 4],  9);
216     JJ(aa, bb, cc, dd, ee, X[ 0], 15);
217     JJ(ee, aa, bb, cc, dd, X[ 5],  5);
218     JJ(dd, ee, aa, bb, cc, X[ 9], 11);
219     JJ(cc, dd, ee, aa, bb, X[ 7],  6);
220     JJ(bb, cc, dd, ee, aa, X[12],  8);
221     JJ(aa, bb, cc, dd, ee, X[ 2], 13);
222     JJ(ee, aa, bb, cc, dd, X[10], 12);
223     JJ(dd, ee, aa, bb, cc, X[14],  5);
224     JJ(cc, dd, ee, aa, bb, X[ 1], 12);
225     JJ(bb, cc, dd, ee, aa, X[ 3], 13);
226     JJ(aa, bb, cc, dd, ee, X[ 8], 14);
227     JJ(ee, aa, bb, cc, dd, X[11], 11);
228     JJ(dd, ee, aa, bb, cc, X[ 6],  8);
229     JJ(cc, dd, ee, aa, bb, X[15],  5);
230     JJ(bb, cc, dd, ee, aa, X[13],  6);
231     FFF(bbb, ccc, ddd, eee, aaa, X[12] ,  8);
232     FFF(aaa, bbb, ccc, ddd, eee, X[15] ,  5);
233     FFF(eee, aaa, bbb, ccc, ddd, X[10] , 12);
234     FFF(ddd, eee, aaa, bbb, ccc, X[ 4] ,  9);
235     FFF(ccc, ddd, eee, aaa, bbb, X[ 1] , 12);
236     FFF(bbb, ccc, ddd, eee, aaa, X[ 5] ,  5);
237     FFF(aaa, bbb, ccc, ddd, eee, X[ 8] , 14);
238     FFF(eee, aaa, bbb, ccc, ddd, X[ 7] ,  6);
239     FFF(ddd, eee, aaa, bbb, ccc, X[ 6] ,  8);
240     FFF(ccc, ddd, eee, aaa, bbb, X[ 2] , 13);
241     FFF(bbb, ccc, ddd, eee, aaa, X[13] ,  6);
242     FFF(aaa, bbb, ccc, ddd, eee, X[14] ,  5);
243     FFF(eee, aaa, bbb, ccc, ddd, X[ 0] , 15);
244     FFF(ddd, eee, aaa, bbb, ccc, X[ 3] , 13);
245     FFF(ccc, ddd, eee, aaa, bbb, X[ 9] , 11);
246     FFF(bbb, ccc, ddd, eee, aaa, X[11] , 11);
247     tmp = ee; ee = eee; eee = tmp;
248     md->rmd320.state[0] += aa;
249     md->rmd320.state[1] += bb;
250     md->rmd320.state[2] += cc;
251     md->rmd320.state[3] += dd;
252     md->rmd320.state[4] += ee;
253     md->rmd320.state[5] += aaa;
254     md->rmd320.state[6] += bbb;
255     md->rmd320.state[7] += ccc;
256     md->rmd320.state[8] += ddd;
257     md->rmd320.state[9] += eee;
258     return CRYPT_OK;
</pre></code></div>
                <div class="column column_space"><pre><code>1405  	pr->rmt_sockctrl = sockctrl;
1406  	pr->ctrl_ssl = ssl;
1407  	pr->protocol_version = protocol_version;
1408  	pr->byte_swapped = byte_swapped;
1409  	pr->rmt_clientside = 1;
1410  	fp->read_op = pcap_read_rpcap;
1411  	fp->save_current_filter_op = pcap_save_current_filter_rpcap;
1412  	fp->setfilter_op = pcap_setfilter_rpcap;
1413  	fp->getnonblock_op = pcap_getnonblock_rpcap;
1414  	fp->setnonblock_op = pcap_setnonblock_rpcap;
1415  	fp->stats_op = pcap_stats_rpcap;
1416  #ifdef _WIN32
1417  	fp->stats_ex_op = pcap_stats_ex_rpcap;
1418  #endif
1419  	fp->cleanup_op = pcap_cleanup_rpcap;
1420  	fp->activated = 1;
1421  	return fp;
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    