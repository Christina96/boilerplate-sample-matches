
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 8.633093525179856%, Tokens: 12, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>android-gpuimage-plus-MDEwOlJlcG9zaXRvcnk0NjU0NzQxNw==-flat-tree.h</h3>
            <pre><code>1  #ifndef AVUTIL_TREE_H
2  #define AVUTIL_TREE_H
3  #include "attributes.h"
4  #include "version.h"
5  struct AVTreeNode;
<span onclick='openModal()' class='match'>6  extern const int av_tree_node_size;
7  struct AVTreeNode *av_tree_node_alloc(void);
8  void *av_tree_find(const struct AVTreeNode *root, void *key,
9                     int (*cmp)(const void *key, const void *b), void *next[2]);
10  void *av_tree_insert(struct AVTreeNode **rootp, void *key,
11                       int (*cmp)(const void *key, const void *b),
</span>12                       struct AVTreeNode **next);
13  void av_tree_destroy(struct AVTreeNode *t);
14  void av_tree_enumerate(struct AVTreeNode *t, void *opaque,
15                         int (*cmp)(void *opaque, void *elem),
16                         int (*enu)(void *opaque, void *elem));
17  #endif &bsol;* AVUTIL_TREE_H */
</code></pre>
        </div>
        <div class="column">
            <h3>libpcap-MDEwOlJlcG9zaXRvcnk5NDM1ODg3-flat-filtertest.c</h3>
            <pre><code>1  #include "varattrs.h"
2  #ifndef lint
3  static const char copyright[] _U_ =
4      "@(#) Copyright (c) 1988, 1989, 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1997, 2000\n\
5  The Regents of the University of California.  All rights reserved.\n";
6  #endif
7  #ifdef HAVE_CONFIG_H
8  #include <config.h>
9  #endif
10  #include <pcap.h>
11  #include <stdio.h>
12  #include <stdlib.h>
13  #include <string.h>
14  #include <stdarg.h>
15  #include <limits.h>
16  #ifdef _WIN32
17    #include "getopt.h"
18    #include "unix.h"
19  #else
20    #include <unistd.h>
21  #endif
22  #include <fcntl.h>
23  #include <errno.h>
24  #ifdef _WIN32
25    #include <winsock2.h>
26    #include <ws2tcpip.h>
27  #else
28    #include <sys/socket.h>
29    #include <arpa/inet.h>
30  #endif
31  #include <sys/types.h>
32  #include <sys/stat.h>
33  #include "pcap/funcattrs.h"
34  #define MAXIMUM_SNAPLEN		262144
35  #ifdef BDEBUG
36  PCAP_API void pcap_set_optimizer_debug(int);
37  PCAP_API void pcap_set_print_dot_graph(int);
38  #endif
39  static char *program_name;
40  static void PCAP_NORETURN usage(void);
41  static void PCAP_NORETURN error(const char *, ...) PCAP_PRINTFLIKE(1, 2);
42  static void warn(const char *, ...) PCAP_PRINTFLIKE(1, 2);
43  #ifndef O_BINARY
44  #define O_BINARY	0
45  #endif
46  static char *
47  read_infile(char *fname)
48  {
49  	register int i, fd, cc;
50  	register char *cp;
51  	struct stat buf;
52  	fd = open(fname, O_RDONLY|O_BINARY);
53  	if (fd < 0)
54  		error("can't open %s: %s", fname, pcap_strerror(errno));
55  	if (fstat(fd, &buf) < 0)
56  		error("can't stat %s: %s", fname, pcap_strerror(errno));
57  	if (buf.st_size > INT_MAX - 1)
58  		error("%s is larger than %d bytes; that's too large", fname,
59  		    INT_MAX - 1);
60  	cp = malloc((u_int)buf.st_size + 1);
61  	if (cp == NULL)
62  		error("malloc(%d) for %s: %s", (u_int)buf.st_size + 1,
63  			fname, pcap_strerror(errno));
64  	cc = (int)read(fd, cp, (u_int)buf.st_size);
65  	if (cc < 0)
66  		error("read %s: %s", fname, pcap_strerror(errno));
67  	if (cc != buf.st_size)
68  		error("short read %s (%d != %d)", fname, cc, (int)buf.st_size);
69  	close(fd);
70  	for (i = 0; i < cc; i++) {
71  		if (cp[i] == '#')
72  			while (i < cc && cp[i] != '\n')
73  				cp[i++] = ' ';
74  	}
75  	cp[cc] = '\0';
76  	return (cp);
77  }
78  static void
79  error(const char *fmt, ...)
80  {
81  	va_list ap;
82  	(void)fprintf(stderr, "%s: ", program_name);
83  	va_start(ap, fmt);
84  	(void)vfprintf(stderr, fmt, ap);
85  	va_end(ap);
86  	if (*fmt) {
87  		fmt += strlen(fmt);
88  		if (fmt[-1] != '\n')
89  			(void)fputc('\n', stderr);
90  	}
91  	exit(1);
92  }
93  static void
94  warn(const char *fmt, ...)
95  {
96  	va_list ap;
97  	(void)fprintf(stderr, "%s: WARNING: ", program_name);
98  	va_start(ap, fmt);
99  	(void)vfprintf(stderr, fmt, ap);
100  	va_end(ap);
101  	if (*fmt) {
102  		fmt += strlen(fmt);
103  		if (fmt[-1] != '\n')
104  			(void)fputc('\n', stderr);
105  	}
106  }
107  static char *
108  copy_argv(register char **argv)
109  {
110  	register char **p;
111  	register size_t len = 0;
112  	char *buf;
113  	char *src, *dst;
114  	p = argv;
115  	if (*p == 0)
116  		return 0;
117  	while (*p)
118  		len += strlen(*p++) + 1;
119  	buf = (char *)malloc(len);
120  	if (buf == NULL)
121  		error("copy_argv: malloc");
122  	p = argv;
123  	dst = buf;
124  	while ((src = *p++) != NULL) {
125  		while ((*dst++ = *src++) != '\0')
126  			;
127  		dst[-1] = ' ';
128  	}
129  	dst[-1] = '\0';
130  	return buf;
131  }
132  int
<span onclick='openModal()' class='match'>133  main(int argc, char **argv)
134  {
135  	char *cp;
136  	int op;
137  	int dflag;
138  #ifdef BDEBUG
139  	int gflag;
140  #endif
141  	char *infile;
142  	int Oflag;
143  	int snaplen;
144  	char *p;
145  	int dlt;
146  	bpf_u_int32 netmask = PCAP_NETMASK_UNKNOWN;
</span>147  	char *cmdbuf;
148  	pcap_t *pd;
149  	struct bpf_program fcode;
150  #ifdef _WIN32
151  	if (pcap_wsockinit() != 0)
152  		return 1;
153  #endif &bsol;* _WIN32 */
154  	dflag = 1;
155  #ifdef BDEBUG
156  	gflag = 0;
157  #endif
158  	infile = NULL;
159  	Oflag = 1;
160  	snaplen = MAXIMUM_SNAPLEN;
161  	if ((cp = strrchr(argv[0], '/')) != NULL)
162  		program_name = cp + 1;
163  	else
164  		program_name = argv[0];
165  	opterr = 0;
166  	while ((op = getopt(argc, argv, "dF:gm:Os:")) != -1) {
167  		switch (op) {
168  		case 'd':
169  			++dflag;
170  			break;
171  		case 'g':
172  #ifdef BDEBUG
173  			++gflag;
174  #else
175  			error("libpcap and filtertest not built with optimizer debugging enabled");
176  #endif
177  			break;
178  		case 'F':
179  			infile = optarg;
180  			break;
181  		case 'O':
182  			Oflag = 0;
183  			break;
184  		case 'm': {
185  			bpf_u_int32 addr;
186  			switch (inet_pton(AF_INET, optarg, &addr)) {
187  			case 0:
188  				error("invalid netmask %s", optarg);
189  				break;
190  			case -1:
191  				error("invalid netmask %s: %s", optarg,
192  				    pcap_strerror(errno));
193  				break;
194  			case 1:
195  				netmask = addr;
196  				break;
197  			}
198  			break;
199  		}
200  		case 's': {
201  			char *end;
202  			long long_snaplen;
203  			long_snaplen = strtol(optarg, &end, 0);
204  			if (optarg == end || *end != '\0'
205  			    || long_snaplen < 0
206  			    || long_snaplen > MAXIMUM_SNAPLEN)
207  				error("invalid snaplen %s", optarg);
208  			else {
209  				if (snaplen == 0)
210  					snaplen = MAXIMUM_SNAPLEN;
211  				else
212  					snaplen = (int)long_snaplen;
213  			}
214  			break;
215  		}
216  		default:
217  			usage();
218  		}
219  	}
220  	if (optind >= argc) {
221  		usage();
222  	}
223  	dlt = pcap_datalink_name_to_val(argv[optind]);
224  	if (dlt < 0) {
225  		dlt = (int)strtol(argv[optind], &p, 10);
226  		if (p == argv[optind] || *p != '\0')
227  			error("invalid data link type %s", argv[optind]);
228  	}
229  	if (infile)
230  		cmdbuf = read_infile(infile);
231  	else
232  		cmdbuf = copy_argv(&argv[optind+1]);
233  #ifdef BDEBUG
234  	pcap_set_optimizer_debug(dflag);
235  	pcap_set_print_dot_graph(gflag);
236  #endif
237  	pd = pcap_open_dead(dlt, snaplen);
238  	if (pd == NULL)
239  		error("Can't open fake pcap_t");
240  	if (pcap_compile(pd, &fcode, cmdbuf, Oflag, netmask) < 0)
241  		error("%s", pcap_geterr(pd));
242  	if (!bpf_validate(fcode.bf_insns, fcode.bf_len))
243  		warn("Filter doesn't pass validation");
244  #ifdef BDEBUG
245  	if (cmdbuf != NULL) {
246  		for (cp = cmdbuf; *cp != '\0'; ++cp) {
247  			if (*cp == '\r' || *cp == '\n') {
248  				*cp = ' ';
249  			}
250  		}
251  		printf("machine codes for filter: %s\n", cmdbuf);
252  	} else
253  		printf("machine codes for empty filter:\n");
254  #endif
255  	bpf_dump(&fcode, dflag);
256  	free(cmdbuf);
257  	pcap_freecode (&fcode);
258  	pcap_close(pd);
259  	exit(0);
260  }
261  static void
262  usage(void)
263  {
264  	(void)fprintf(stderr, "%s, with %s\n", program_name,
265  	    pcap_lib_version());
266  	(void)fprintf(stderr,
267  #ifdef BDEBUG
268  	    "Usage: %s [-dgO] [ -F file ] [ -m netmask] [ -s snaplen ] dlt [ expression ]\n",
269  #else
270  	    "Usage: %s [-dO] [ -F file ] [ -m netmask] [ -s snaplen ] dlt [ expression ]\n",
271  #endif
272  	    program_name);
273  	exit(1);
274  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from android-gpuimage-plus-MDEwOlJlcG9zaXRvcnk0NjU0NzQxNw==-flat-tree.h</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from libpcap-MDEwOlJlcG9zaXRvcnk5NDM1ODg3-flat-filtertest.c</div>
                </div>
                <div class="column column_space"><pre><code>6  extern const int av_tree_node_size;
7  struct AVTreeNode *av_tree_node_alloc(void);
8  void *av_tree_find(const struct AVTreeNode *root, void *key,
9                     int (*cmp)(const void *key, const void *b), void *next[2]);
10  void *av_tree_insert(struct AVTreeNode **rootp, void *key,
11                       int (*cmp)(const void *key, const void *b),
</pre></code></div>
                <div class="column column_space"><pre><code>133  main(int argc, char **argv)
134  {
135  	char *cp;
136  	int op;
137  	int dflag;
138  #ifdef BDEBUG
139  	int gflag;
140  #endif
141  	char *infile;
142  	int Oflag;
143  	int snaplen;
144  	char *p;
145  	int dlt;
146  	bpf_u_int32 netmask = PCAP_NETMASK_UNKNOWN;
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    