
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 7.252747252747254%, Tokens: 9, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>PINRemoteImage-MDEwOlJlcG9zaXRvcnkzOTUzNzEwMw==-flat-picture_psnr_enc.c</h3>
            <pre><code>1  #include "src/webp/encode.h"
2  #if !(defined(WEBP_DISABLE_STATS) || defined(WEBP_REDUCE_SIZE))
3  #include <math.h>
4  #include <stdlib.h>
5  #include "src/dsp/dsp.h"
6  #include "src/enc/vp8i_enc.h"
7  #include "src/utils/utils.h"
8  typedef double (*AccumulateFunc)(const uint8_t* src, int src_stride,
9                                   const uint8_t* ref, int ref_stride,
10                                   int w, int h);
11  #define RADIUS 2  
12  static double AccumulateLSIM(const uint8_t* src, int src_stride,
13                               const uint8_t* ref, int ref_stride,
14                               int w, int h) {
15    int x, y;
16    double total_sse = 0.;
17    for (y = 0; y < h; ++y) {
18      const int y_0 = (y - RADIUS < 0) ? 0 : y - RADIUS;
19      const int y_1 = (y + RADIUS + 1 >= h) ? h : y + RADIUS + 1;
20      for (x = 0; x < w; ++x) {
21        const int x_0 = (x - RADIUS < 0) ? 0 : x - RADIUS;
22        const int x_1 = (x + RADIUS + 1 >= w) ? w : x + RADIUS + 1;
23        double best_sse = 255. * 255.;
24        const double value = (double)ref[y * ref_stride + x];
25        int i, j;
26        for (j = y_0; j < y_1; ++j) {
27          const uint8_t* const s = src + j * src_stride;
28          for (i = x_0; i < x_1; ++i) {
29            const double diff = s[i] - value;
30            const double sse = diff * diff;
31            if (sse < best_sse) best_sse = sse;
32          }
33        }
34        total_sse += best_sse;
35      }
36    }
37    return total_sse;
38  }
39  #undef RADIUS
40  static double AccumulateSSE(const uint8_t* src, int src_stride,
41                              const uint8_t* ref, int ref_stride,
42                              int w, int h) {
43    int y;
44    double total_sse = 0.;
45    for (y = 0; y < h; ++y) {
46      total_sse += VP8AccumulateSSE(src, ref, w);
47      src += src_stride;
48      ref += ref_stride;
49    }
50    return total_sse;
51  }
52  static double AccumulateSSIM(const uint8_t* src, int src_stride,
53                               const uint8_t* ref, int ref_stride,
54                               int w, int h) {
55    const int w0 = (w < VP8_SSIM_KERNEL) ? w : VP8_SSIM_KERNEL;
56    const int w1 = w - VP8_SSIM_KERNEL - 1;
57    const int h0 = (h < VP8_SSIM_KERNEL) ? h : VP8_SSIM_KERNEL;
58    const int h1 = h - VP8_SSIM_KERNEL - 1;
59    int x, y;
60    double sum = 0.;
61    for (y = 0; y < h0; ++y) {
62      for (x = 0; x < w; ++x) {
63        sum += VP8SSIMGetClipped(src, src_stride, ref, ref_stride, x, y, w, h);
64      }
65    }
66    for (; y < h1; ++y) {
67      for (x = 0; x < w0; ++x) {
68        sum += VP8SSIMGetClipped(src, src_stride, ref, ref_stride, x, y, w, h);
69      }
70      for (; x < w1; ++x) {
71        const int off1 = x - VP8_SSIM_KERNEL + (y - VP8_SSIM_KERNEL) * src_stride;
72        const int off2 = x - VP8_SSIM_KERNEL + (y - VP8_SSIM_KERNEL) * ref_stride;
73        sum += VP8SSIMGet(src + off1, src_stride, ref + off2, ref_stride);
74      }
75      for (; x < w; ++x) {
76        sum += VP8SSIMGetClipped(src, src_stride, ref, ref_stride, x, y, w, h);
77      }
78    }
79    for (; y < h; ++y) {
80      for (x = 0; x < w; ++x) {
81        sum += VP8SSIMGetClipped(src, src_stride, ref, ref_stride, x, y, w, h);
82      }
83    }
84    return sum;
85  }
86  static const double kMinDistortion_dB = 99.;
87  static double GetPSNR(double v, double size) {
88    return (v > 0. && size > 0.) ? -4.3429448 * log(v / (size * 255 * 255.))
89                                 : kMinDistortion_dB;
90  }
91  static double GetLogSSIM(double v, double size) {
92    v = (size > 0.) ? v / size : 1.;
93    return (v < 1.) ? -10.0 * log10(1. - v) : kMinDistortion_dB;
94  }
95  int WebPPlaneDistortion(const uint8_t* src, size_t src_stride,
96                          const uint8_t* ref, size_t ref_stride,
97                          int width, int height, size_t x_step,
98                          int type, float* distortion, float* result) {
99    uint8_t* allocated = NULL;
100    const AccumulateFunc metric = (type == 0) ? AccumulateSSE :
101                                  (type == 1) ? AccumulateSSIM :
102                                                AccumulateLSIM;
103    if (src == NULL || ref == NULL ||
104        src_stride < x_step * width || ref_stride < x_step * width ||
105        result == NULL || distortion == NULL) {
106      return 0;
107    }
108    VP8SSIMDspInit();
109    if (x_step != 1) {   
110      int x, y;
111      uint8_t* tmp1;
112      uint8_t* tmp2;
113      allocated =
114          (uint8_t*)WebPSafeMalloc(2ULL * width * height, sizeof(*allocated));
115      if (allocated == NULL) return 0;
116      tmp1 = allocated;
117      tmp2 = tmp1 + (size_t)width * height;
118      for (y = 0; y < height; ++y) {
119        for (x = 0; x < width; ++x) {
120          tmp1[x + y * width] = src[x * x_step + y * src_stride];
121          tmp2[x + y * width] = ref[x * x_step + y * ref_stride];
122        }
123      }
124      src = tmp1;
125      ref = tmp2;
126    }
127    *distortion = (float)metric(src, width, ref, width, width, height);
128    WebPSafeFree(allocated);
129    *result = (type == 1) ? (float)GetLogSSIM(*distortion, (double)width * height)
<span onclick='openModal()' class='match'>130                          : (float)GetPSNR(*distortion, (double)width * height);
131    return 1;
132  }
133  #ifdef WORDS_BIGENDIAN
134  #define BLUE_OFFSET 3   
135  #else
136  #define BLUE_OFFSET 0   
137  #endif
138  int WebPPictureDistortion(const WebPPicture* src, const WebPPicture* ref,
139                            int type, float results[5]) {
140    int w, h, c;
</span>141    int ok = 0;
142    WebPPicture p0, p1;
143    double total_size = 0., total_distortion = 0.;
144    if (src == NULL || ref == NULL ||
145        src->width != ref->width || src->height != ref->height ||
146        results == NULL) {
147      return 0;
148    }
149    VP8SSIMDspInit();
150    if (!WebPPictureInit(&p0) || !WebPPictureInit(&p1)) return 0;
151    w = src->width;
152    h = src->height;
153    if (!WebPPictureView(src, 0, 0, w, h, &p0)) goto Error;
154    if (!WebPPictureView(ref, 0, 0, w, h, &p1)) goto Error;
155    if (p0.use_argb == 0 && !WebPPictureYUVAToARGB(&p0)) goto Error;
156    if (p1.use_argb == 0 && !WebPPictureYUVAToARGB(&p1)) goto Error;
157    for (c = 0; c < 4; ++c) {
158      float distortion;
159      const size_t stride0 = 4 * (size_t)p0.argb_stride;
160      const size_t stride1 = 4 * (size_t)p1.argb_stride;
161      const int offset = c ^ BLUE_OFFSET;
162      if (!WebPPlaneDistortion((const uint8_t*)p0.argb + offset, stride0,
163                               (const uint8_t*)p1.argb + offset, stride1,
164                               w, h, 4, type, &distortion, results + c)) {
165        goto Error;
166      }
167      total_distortion += distortion;
168      total_size += w * h;
169    }
170    results[4] = (type == 1) ? (float)GetLogSSIM(total_distortion, total_size)
171                             : (float)GetPSNR(total_distortion, total_size);
172    ok = 1;
173   Error:
174    WebPPictureFree(&p0);
175    WebPPictureFree(&p1);
176    return ok;
177  }
178  #undef BLUE_OFFSET
179  #else  
180  int WebPPlaneDistortion(const uint8_t* src, size_t src_stride,
181                          const uint8_t* ref, size_t ref_stride,
182                          int width, int height, size_t x_step,
183                          int type, float* distortion, float* result) {
184    (void)src;
185    (void)src_stride;
186    (void)ref;
187    (void)ref_stride;
188    (void)width;
189    (void)height;
190    (void)x_step;
191    (void)type;
192    if (distortion == NULL || result == NULL) return 0;
193    *distortion = 0.f;
194    *result = 0.f;
195    return 1;
196  }
197  int WebPPictureDistortion(const WebPPicture* src, const WebPPicture* ref,
198                            int type, float results[5]) {
199    int i;
200    (void)src;
201    (void)ref;
202    (void)type;
203    if (results == NULL) return 0;
204    for (i = 0; i < 5; ++i) results[i] = 0.f;
205    return 1;
206  }
207  #endif  
</code></pre>
        </div>
        <div class="column">
            <h3>libtomcrypt-MDEwOlJlcG9zaXRvcnk3NzcwMTE=-flat-tfm_desc.c</h3>
            <pre><code>1  #define DESC_DEF_ONLY
2  #include "tomcrypt_private.h"
3  #ifdef TFM_DESC
4  #include <tfm.h>
5  static const struct {
6      int tfm_code, ltc_code;
7  } tfm_to_ltc_codes[] = {
8     { FP_OKAY ,  CRYPT_OK},
9     { FP_MEM  ,  CRYPT_MEM},
10     { FP_VAL  ,  CRYPT_INVALID_ARG},
11  };
12  static int tfm_to_ltc_error(int err)
13  {
14     int x;
15     for (x = 0; x < (int)(sizeof(tfm_to_ltc_codes)/sizeof(tfm_to_ltc_codes[0])); x++) {
16         if (err == tfm_to_ltc_codes[x].tfm_code) {
17            return tfm_to_ltc_codes[x].ltc_code;
18         }
19     }
20     return CRYPT_ERROR;
21  }
22  static int init(void **a)
23  {
24     LTC_ARGCHK(a != NULL);
25     *a = XCALLOC(1, sizeof(fp_int));
26     if (*a == NULL) {
27        return CRYPT_MEM;
28     }
29     fp_init(*a);
30     return CRYPT_OK;
31  }
32  static void deinit(void *a)
33  {
34     LTC_ARGCHKVD(a != NULL);
35     XFREE(a);
36  }
37  static int neg(void *a, void *b)
38  {
39     LTC_ARGCHK(a != NULL);
40     LTC_ARGCHK(b != NULL);
41     fp_neg(((fp_int*)a), ((fp_int*)b));
42     return CRYPT_OK;
43  }
44  static int copy(void *a, void *b)
45  {
46     LTC_ARGCHK(a != NULL);
47     LTC_ARGCHK(b != NULL);
48     fp_copy(a, b);
49     return CRYPT_OK;
50  }
51  static int init_copy(void **a, void *b)
52  {
53     if (init(a) != CRYPT_OK) {
54        return CRYPT_MEM;
55     }
56     return copy(b, *a);
57  }
58  static int set_int(void *a, ltc_mp_digit b)
59  {
60     LTC_ARGCHK(a != NULL);
61     fp_set(a, b);
62     return CRYPT_OK;
63  }
64  static unsigned long get_int(void *a)
65  {
66     fp_int *A;
67     LTC_ARGCHK(a != NULL);
68     A = a;
69     return A->used > 0 ? A->dp[0] : 0;
70  }
71  static ltc_mp_digit get_digit(void *a, int n)
72  {
73     fp_int *A;
74     LTC_ARGCHK(a != NULL);
75     A = a;
76     return (n >= A->used || n < 0) ? 0 : A->dp[n];
77  }
78  static int get_digit_count(void *a)
79  {
80     fp_int *A;
81     LTC_ARGCHK(a != NULL);
82     A = a;
83     return A->used;
84  }
85  static int compare(void *a, void *b)
86  {
87     int ret;
88     LTC_ARGCHK(a != NULL);
89     LTC_ARGCHK(b != NULL);
90     ret = fp_cmp(a, b);
91     switch (ret) {
92        case FP_LT: return LTC_MP_LT;
93        case FP_EQ: return LTC_MP_EQ;
94        case FP_GT: return LTC_MP_GT;
95     }
96     return 0;
97  }
98  static int compare_d(void *a, ltc_mp_digit b)
99  {
100     int ret;
101     LTC_ARGCHK(a != NULL);
102     ret = fp_cmp_d(a, b);
103     switch (ret) {
104        case FP_LT: return LTC_MP_LT;
105        case FP_EQ: return LTC_MP_EQ;
106        case FP_GT: return LTC_MP_GT;
107     }
108     return 0;
109  }
110  static int count_bits(void *a)
111  {
112     LTC_ARGCHK(a != NULL);
113     return fp_count_bits(a);
114  }
115  static int count_lsb_bits(void *a)
116  {
117     LTC_ARGCHK(a != NULL);
118     return fp_cnt_lsb(a);
119  }
120  static int twoexpt(void *a, int n)
121  {
122     LTC_ARGCHK(a != NULL);
123     fp_2expt(a, n);
124     return CRYPT_OK;
125  }
126  static int read_radix(void *a, const char *b, int radix)
127  {
128     LTC_ARGCHK(a != NULL);
129     LTC_ARGCHK(b != NULL);
130     return tfm_to_ltc_error(fp_read_radix(a, (char *)b, radix));
131  }
132  static int write_radix(void *a, char *b, int radix)
133  {
134     LTC_ARGCHK(a != NULL);
135     LTC_ARGCHK(b != NULL);
136     return tfm_to_ltc_error(fp_toradix(a, b, radix));
137  }
138  static unsigned long unsigned_size(void *a)
139  {
140     LTC_ARGCHK(a != NULL);
141     return fp_unsigned_bin_size(a);
142  }
143  static int unsigned_write(void *a, unsigned char *b)
144  {
145     LTC_ARGCHK(a != NULL);
146     LTC_ARGCHK(b != NULL);
147     fp_to_unsigned_bin(a, b);
148     return CRYPT_OK;
149  }
150  static int unsigned_read(void *a, unsigned char *b, unsigned long len)
151  {
152     LTC_ARGCHK(a != NULL);
153     LTC_ARGCHK(b != NULL);
154     fp_read_unsigned_bin(a, b, len);
155     return CRYPT_OK;
156  }
157  static int add(void *a, void *b, void *c)
158  {
159     LTC_ARGCHK(a != NULL);
160     LTC_ARGCHK(b != NULL);
161     LTC_ARGCHK(c != NULL);
162     fp_add(a, b, c);
163     return CRYPT_OK;
164  }
165  static int addi(void *a, ltc_mp_digit b, void *c)
166  {
167     LTC_ARGCHK(a != NULL);
168     LTC_ARGCHK(c != NULL);
169     fp_add_d(a, b, c);
170     return CRYPT_OK;
171  }
172  static int sub(void *a, void *b, void *c)
173  {
174     LTC_ARGCHK(a != NULL);
175     LTC_ARGCHK(b != NULL);
176     LTC_ARGCHK(c != NULL);
177     fp_sub(a, b, c);
178     return CRYPT_OK;
179  }
180  static int subi(void *a, ltc_mp_digit b, void *c)
181  {
182     LTC_ARGCHK(a != NULL);
183     LTC_ARGCHK(c != NULL);
184     fp_sub_d(a, b, c);
185     return CRYPT_OK;
186  }
187  static int mul(void *a, void *b, void *c)
188  {
189     LTC_ARGCHK(a != NULL);
190     LTC_ARGCHK(b != NULL);
191     LTC_ARGCHK(c != NULL);
192     fp_mul(a, b, c);
193     return CRYPT_OK;
194  }
195  static int muli(void *a, ltc_mp_digit b, void *c)
196  {
197     LTC_ARGCHK(a != NULL);
198     LTC_ARGCHK(c != NULL);
199     fp_mul_d(a, b, c);
200     return CRYPT_OK;
201  }
202  static int sqr(void *a, void *b)
203  {
204     LTC_ARGCHK(a != NULL);
205     LTC_ARGCHK(b != NULL);
206     fp_sqr(a, b);
207     return CRYPT_OK;
208  }
209  static int divide(void *a, void *b, void *c, void *d)
210  {
211     LTC_ARGCHK(a != NULL);
212     LTC_ARGCHK(b != NULL);
213     return tfm_to_ltc_error(fp_div(a, b, c, d));
214  }
215  static int div_2(void *a, void *b)
216  {
217     LTC_ARGCHK(a != NULL);
218     LTC_ARGCHK(b != NULL);
<span onclick='openModal()' class='match'>219     fp_div_2(a, b);
220     return CRYPT_OK;
221  }
222  static int modi(void *a, ltc_mp_digit b, ltc_mp_digit *c)
223  {
224     fp_digit tmp;
225     int      err;
</span>226     LTC_ARGCHK(a != NULL);
227     LTC_ARGCHK(c != NULL);
228     if ((err = tfm_to_ltc_error(fp_mod_d(a, b, &tmp))) != CRYPT_OK) {
229        return err;
230     }
231     *c = tmp;
232     return CRYPT_OK;
233  }
234  static int gcd(void *a, void *b, void *c)
235  {
236     LTC_ARGCHK(a != NULL);
237     LTC_ARGCHK(b != NULL);
238     LTC_ARGCHK(c != NULL);
239     fp_gcd(a, b, c);
240     return CRYPT_OK;
241  }
242  static int lcm(void *a, void *b, void *c)
243  {
244     LTC_ARGCHK(a != NULL);
245     LTC_ARGCHK(b != NULL);
246     LTC_ARGCHK(c != NULL);
247     fp_lcm(a, b, c);
248     return CRYPT_OK;
249  }
250  static int addmod(void *a, void *b, void *c, void *d)
251  {
252     LTC_ARGCHK(a != NULL);
253     LTC_ARGCHK(b != NULL);
254     LTC_ARGCHK(c != NULL);
255     LTC_ARGCHK(d != NULL);
256     return tfm_to_ltc_error(fp_addmod(a,b,c,d));
257  }
258  static int submod(void *a, void *b, void *c, void *d)
259  {
260     LTC_ARGCHK(a != NULL);
261     LTC_ARGCHK(b != NULL);
262     LTC_ARGCHK(c != NULL);
263     LTC_ARGCHK(d != NULL);
264     return tfm_to_ltc_error(fp_submod(a,b,c,d));
265  }
266  static int mulmod(void *a, void *b, void *c, void *d)
267  {
268     LTC_ARGCHK(a != NULL);
269     LTC_ARGCHK(b != NULL);
270     LTC_ARGCHK(c != NULL);
271     LTC_ARGCHK(d != NULL);
272     return tfm_to_ltc_error(fp_mulmod(a,b,c,d));
273  }
274  static int sqrmod(void *a, void *b, void *c)
275  {
276     LTC_ARGCHK(a != NULL);
277     LTC_ARGCHK(b != NULL);
278     LTC_ARGCHK(c != NULL);
279     return tfm_to_ltc_error(fp_sqrmod(a,b,c));
280  }
281  static int invmod(void *a, void *b, void *c)
282  {
283     LTC_ARGCHK(a != NULL);
284     LTC_ARGCHK(b != NULL);
285     LTC_ARGCHK(c != NULL);
286     return tfm_to_ltc_error(fp_invmod(a, b, c));
287  }
288  static int montgomery_setup(void *a, void **b)
289  {
290     int err;
291     LTC_ARGCHK(a != NULL);
292     LTC_ARGCHK(b != NULL);
293     *b = XCALLOC(1, sizeof(fp_digit));
294     if (*b == NULL) {
295        return CRYPT_MEM;
296     }
297     if ((err = tfm_to_ltc_error(fp_montgomery_setup(a, (fp_digit *)*b))) != CRYPT_OK) {
298        XFREE(*b);
299     }
300     return err;
301  }
302  static int montgomery_normalization(void *a, void *b)
303  {
304     LTC_ARGCHK(a != NULL);
305     LTC_ARGCHK(b != NULL);
306     fp_montgomery_calc_normalization(a, b);
307     return CRYPT_OK;
308  }
309  static int montgomery_reduce(void *a, void *b, void *c)
310  {
311     LTC_ARGCHK(a != NULL);
312     LTC_ARGCHK(b != NULL);
313     LTC_ARGCHK(c != NULL);
314     fp_montgomery_reduce(a, b, *((fp_digit *)c));
315     return CRYPT_OK;
316  }
317  static void montgomery_deinit(void *a)
318  {
319     XFREE(a);
320  }
321  static int exptmod(void *a, void *b, void *c, void *d)
322  {
323     LTC_ARGCHK(a != NULL);
324     LTC_ARGCHK(b != NULL);
325     LTC_ARGCHK(c != NULL);
326     LTC_ARGCHK(d != NULL);
327     return tfm_to_ltc_error(fp_exptmod(a,b,c,d));
328  }
329  static int isprime(void *a, int b, int *c)
330  {
331     LTC_ARGCHK(a != NULL);
332     LTC_ARGCHK(c != NULL);
333     if (b == 0) {
334         b = LTC_MILLER_RABIN_REPS;
335     } &bsol;* if */
336     *c = (fp_isprime_ex(a, b) == FP_YES) ? LTC_MP_YES : LTC_MP_NO;
337     return CRYPT_OK;
338  }
339  #if defined(LTC_MECC) && defined(LTC_MECC_ACCEL)
340  static int tfm_ecc_projective_dbl_point(const ecc_point *P, ecc_point *R, void *ma, void *modulus, void *Mp)
341  {
342     fp_int t1, t2;
343     fp_digit mp;
344     int err, inf;
345     LTC_ARGCHK(P       != NULL);
346     LTC_ARGCHK(R       != NULL);
347     LTC_ARGCHK(modulus != NULL);
348     LTC_ARGCHK(Mp      != NULL);
349     mp = *((fp_digit*)Mp);
350     fp_init(&t1);
351     fp_init(&t2);
352     if (P != R) {
353        fp_copy(P->x, R->x);
354        fp_copy(P->y, R->y);
355        fp_copy(P->z, R->z);
356     }
357     if ((err = ltc_ecc_is_point_at_infinity(P, modulus, &inf)) != CRYPT_OK) return err;
358     if (inf) {
359        ltc_mp.set_int(R->x, 1);
360        ltc_mp.set_int(R->y, 1);
361        ltc_mp.set_int(R->z, 0);
362        return CRYPT_OK;
363     }
364     fp_sqr(R->z, &t1);
365     fp_montgomery_reduce(&t1, modulus, mp);
366     fp_mul(R->z, R->y, R->z);
367     fp_montgomery_reduce(R->z, modulus, mp);
368     fp_add(R->z, R->z, R->z);
369     if (fp_cmp(R->z, modulus) != FP_LT) {
370        fp_sub(R->z, modulus, R->z);
371     }
372     if (ma == NULL) { &bsol;* special case for curves with a == -3 (10% faster than general case) */
373        fp_sub(R->x, &t1, &t2);
374        if (fp_cmp_d(&t2, 0) == LTC_MP_LT) {
375           fp_add(&t2, modulus, &t2);
376        }
377        fp_add(&t1, R->x, &t1);
378        if (fp_cmp(&t1, modulus) != FP_LT) {
379           fp_sub(&t1, modulus, &t1);
380        }
381        fp_mul(&t1, &t2, &t2);
382        fp_montgomery_reduce(&t2, modulus, mp);
383        fp_add(&t2, &t2, &t1);
384        if (fp_cmp(&t1, modulus) != FP_LT) {
385           fp_sub(&t1, modulus, &t1);
386        }
387        fp_add(&t1, &t2, &t1);
388        if (fp_cmp(&t1, modulus) != FP_LT) {
389           fp_sub(&t1, modulus, &t1);
390        }
391     }
392     else {
393        fp_sqr(&t1, &t2);
394        fp_montgomery_reduce(&t2, modulus, mp);
395        fp_mul(&t2, ma, &t1);
396        fp_montgomery_reduce(&t1, modulus, mp);
397        fp_sqr(R->x, &t2);
398        fp_montgomery_reduce(&t2, modulus, mp);
399        fp_add(&t1, &t2, &t1);
400        if (fp_cmp(&t1, modulus) != FP_LT) {
401           fp_sub(&t1, modulus, &t1);
402        }
403        fp_add(&t1, &t2, &t1);
404        if (fp_cmp(&t1, modulus) != FP_LT) {
405           fp_sub(&t1, modulus, &t1);
406        }
407        fp_add(&t1, &t2, &t1);
408        if (fp_cmp(&t1, modulus) != FP_LT) {
409           fp_sub(&t1, modulus, &t1);
410        }
411     }
412     fp_add(R->y, R->y, R->y);
413     if (fp_cmp(R->y, modulus) != FP_LT) {
414        fp_sub(R->y, modulus, R->y);
415     }
416     fp_sqr(R->y, R->y);
417     fp_montgomery_reduce(R->y, modulus, mp);
418     fp_sqr(R->y, &t2);
419     fp_montgomery_reduce(&t2, modulus, mp);
420     if (fp_isodd(&t2)) {
421        fp_add(&t2, modulus, &t2);
422     }
423     fp_div_2(&t2, &t2);
424     fp_mul(R->y, R->x, R->y);
425     fp_montgomery_reduce(R->y, modulus, mp);
426     fp_sqr(&t1, R->x);
427     fp_montgomery_reduce(R->x, modulus, mp);
428     fp_sub(R->x, R->y, R->x);
429     if (fp_cmp_d(R->x, 0) == FP_LT) {
430        fp_add(R->x, modulus, R->x);
431     }
432     fp_sub(R->x, R->y, R->x);
433     if (fp_cmp_d(R->x, 0) == FP_LT) {
434        fp_add(R->x, modulus, R->x);
435     }
436     fp_sub(R->y, R->x, R->y);
437     if (fp_cmp_d(R->y, 0) == FP_LT) {
438        fp_add(R->y, modulus, R->y);
439     }
440     fp_mul(R->y, &t1, R->y);
441     fp_montgomery_reduce(R->y, modulus, mp);
442     fp_sub(R->y, &t2, R->y);
443     if (fp_cmp_d(R->y, 0) == FP_LT) {
444        fp_add(R->y, modulus, R->y);
445     }
446     return CRYPT_OK;
447  }
448  static int tfm_ecc_projective_add_point(const ecc_point *P, const ecc_point *Q, ecc_point *R, void *ma, void *modulus, void *Mp)
449  {
450     fp_int  t1, t2, x, y, z;
451     fp_digit mp;
452     int err, inf;
453     LTC_ARGCHK(P       != NULL);
454     LTC_ARGCHK(Q       != NULL);
455     LTC_ARGCHK(R       != NULL);
456     LTC_ARGCHK(modulus != NULL);
457     LTC_ARGCHK(Mp      != NULL);
458     mp = *((fp_digit*)Mp);
459     fp_init(&t1);
460     fp_init(&t2);
461     fp_init(&x);
462     fp_init(&y);
463     fp_init(&z);
464     if ((err = ltc_ecc_is_point_at_infinity(P, modulus, &inf)) != CRYPT_OK) return err;
465     if (inf) {
466        ltc_mp.copy(Q->x, R->x);
467        ltc_mp.copy(Q->y, R->y);
468        ltc_mp.copy(Q->z, R->z);
469        return CRYPT_OK;
470     }
471     if ((err = ltc_ecc_is_point_at_infinity(Q, modulus, &inf)) != CRYPT_OK) return err;
472     if (inf) {
473        ltc_mp.copy(P->x, R->x);
474        ltc_mp.copy(P->y, R->y);
475        ltc_mp.copy(P->z, R->z);
476        return CRYPT_OK;
477     }
478     fp_sub(modulus, Q->y, &t1);
479     if ( (fp_cmp(P->x, Q->x) == FP_EQ) &&
480          (Q->z != NULL && fp_cmp(P->z, Q->z) == FP_EQ) &&
481          (fp_cmp(P->y, Q->y) == FP_EQ || fp_cmp(P->y, &t1) == FP_EQ)) {
482          return tfm_ecc_projective_dbl_point(P, R, ma, modulus, Mp);
483     }
484     fp_copy(P->x, &x);
485     fp_copy(P->y, &y);
486     fp_copy(P->z, &z);
487     if (Q->z != NULL) {
488        fp_sqr(Q->z, &t1);
489        fp_montgomery_reduce(&t1, modulus, mp);
490        fp_mul(&t1, &x, &x);
491        fp_montgomery_reduce(&x, modulus, mp);
492        fp_mul(Q->z, &t1, &t1);
493        fp_montgomery_reduce(&t1, modulus, mp);
494        fp_mul(&t1, &y, &y);
495        fp_montgomery_reduce(&y, modulus, mp);
496     }
497     fp_sqr(&z, &t1);
498     fp_montgomery_reduce(&t1, modulus, mp);
499     fp_mul(Q->x, &t1, &t2);
500     fp_montgomery_reduce(&t2, modulus, mp);
501     fp_mul(&z, &t1, &t1);
502     fp_montgomery_reduce(&t1, modulus, mp);
503     fp_mul(Q->y, &t1, &t1);
504     fp_montgomery_reduce(&t1, modulus, mp);
505     fp_sub(&y, &t1, &y);
506     if (fp_cmp_d(&y, 0) == FP_LT) {
507        fp_add(&y, modulus, &y);
508     }
509     fp_add(&t1, &t1, &t1);
510     if (fp_cmp(&t1, modulus) != FP_LT) {
511        fp_sub(&t1, modulus, &t1);
512     }
513     fp_add(&t1, &y, &t1);
514     if (fp_cmp(&t1, modulus) != FP_LT) {
515        fp_sub(&t1, modulus, &t1);
516     }
517     fp_sub(&x, &t2, &x);
518     if (fp_cmp_d(&x, 0) == FP_LT) {
519        fp_add(&x, modulus, &x);
520     }
521     fp_add(&t2, &t2, &t2);
522     if (fp_cmp(&t2, modulus) != FP_LT) {
523        fp_sub(&t2, modulus, &t2);
524     }
525     fp_add(&t2, &x, &t2);
526     if (fp_cmp(&t2, modulus) != FP_LT) {
527        fp_sub(&t2, modulus, &t2);
528     }
529     if (Q->z != NULL) {
530        fp_mul(&z, Q->z, &z);
531        fp_montgomery_reduce(&z, modulus, mp);
532     }
533     fp_mul(&z, &x, &z);
534     fp_montgomery_reduce(&z, modulus, mp);
535     fp_mul(&t1, &x, &t1);
536     fp_montgomery_reduce(&t1, modulus, mp);
537     fp_sqr(&x, &x);
538     fp_montgomery_reduce(&x, modulus, mp);
539     fp_mul(&t2, &x, &t2);
540     fp_montgomery_reduce(&t2, modulus, mp);
541     fp_mul(&t1, &x, &t1);
542     fp_montgomery_reduce(&t1, modulus, mp);
543     fp_sqr(&y, &x);
544     fp_montgomery_reduce(&x, modulus, mp);
545     fp_sub(&x, &t2, &x);
546     if (fp_cmp_d(&x, 0) == FP_LT) {
547        fp_add(&x, modulus, &x);
548     }
549     fp_sub(&t2, &x, &t2);
550     if (fp_cmp_d(&t2, 0) == FP_LT) {
551        fp_add(&t2, modulus, &t2);
552     }
553     fp_sub(&t2, &x, &t2);
554     if (fp_cmp_d(&t2, 0) == FP_LT) {
555        fp_add(&t2, modulus, &t2);
556     }
557     fp_mul(&t2, &y, &t2);
558     fp_montgomery_reduce(&t2, modulus, mp);
559     fp_sub(&t2, &t1, &y);
560     if (fp_cmp_d(&y, 0) == FP_LT) {
561        fp_add(&y, modulus, &y);
562     }
563     if (fp_isodd(&y)) {
564        fp_add(&y, modulus, &y);
565     }
566     fp_div_2(&y, &y);
567     fp_copy(&x, R->x);
568     fp_copy(&y, R->y);
569     fp_copy(&z, R->z);
570     return CRYPT_OK;
571  }
572  #endif
573  static int set_rand(void *a, int size)
574  {
575     LTC_ARGCHK(a != NULL);
576     fp_rand(a, size);
577     return CRYPT_OK;
578  }
579  const ltc_math_descriptor tfm_desc = {
580     "TomsFastMath",
581     (int)DIGIT_BIT,
582     &init,
583     &init_copy,
584     &deinit,
585     &neg,
586     &copy,
587     &set_int,
588     &get_int,
589     &get_digit,
590     &get_digit_count,
591     &compare,
592     &compare_d,
593     &count_bits,
594     &count_lsb_bits,
595     &twoexpt,
596     &read_radix,
597     &write_radix,
598     &unsigned_size,
599     &unsigned_write,
600     &unsigned_read,
601     &add,
602     &addi,
603     &sub,
604     &subi,
605     &mul,
606     &muli,
607     &sqr,
608     NULL, &bsol;* TODO: &sqrtmod_prime */
609     &divide,
610     &div_2,
611     &modi,
612     &gcd,
613     &lcm,
614     &mulmod,
615     &sqrmod,
616     &invmod,
617     &montgomery_setup,
618     &montgomery_normalization,
619     &montgomery_reduce,
620     &montgomery_deinit,
621     &exptmod,
622     &isprime,
623  #ifdef LTC_MECC
624  #ifdef LTC_MECC_FP
625     &ltc_ecc_fp_mulmod,
626  #else
627     &ltc_ecc_mulmod,
628  #endif &bsol;* LTC_MECC_FP */
629  #ifdef LTC_MECC_ACCEL
630     &tfm_ecc_projective_add_point,
631     &tfm_ecc_projective_dbl_point,
632  #else
633     &ltc_ecc_projective_add_point,
634     &ltc_ecc_projective_dbl_point,
635  #endif &bsol;* LTC_MECC_ACCEL */
636     &ltc_ecc_map,
637  #ifdef LTC_ECC_SHAMIR
638  #ifdef LTC_MECC_FP
639     &ltc_ecc_fp_mul2add,
640  #else
641     &ltc_ecc_mul2add,
642  #endif &bsol;* LTC_MECC_FP */
643  #else
644     NULL,
645  #endif &bsol;* LTC_ECC_SHAMIR */
646  #else
647     NULL, NULL, NULL, NULL, NULL,
648  #endif &bsol;* LTC_MECC */
649  #ifdef LTC_MRSA
650     &rsa_make_key,
651     &rsa_exptmod,
652  #else
653     NULL, NULL,
654  #endif
655     &addmod,
656     &submod,
657     set_rand,
658  };
659  #endif
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from PINRemoteImage-MDEwOlJlcG9zaXRvcnkzOTUzNzEwMw==-flat-picture_psnr_enc.c</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from libtomcrypt-MDEwOlJlcG9zaXRvcnk3NzcwMTE=-flat-tfm_desc.c</div>
                </div>
                <div class="column column_space"><pre><code>130                          : (float)GetPSNR(*distortion, (double)width * height);
131    return 1;
132  }
133  #ifdef WORDS_BIGENDIAN
134  #define BLUE_OFFSET 3   
135  #else
136  #define BLUE_OFFSET 0   
137  #endif
138  int WebPPictureDistortion(const WebPPicture* src, const WebPPicture* ref,
139                            int type, float results[5]) {
140    int w, h, c;
</pre></code></div>
                <div class="column column_space"><pre><code>219     fp_div_2(a, b);
220     return CRYPT_OK;
221  }
222  static int modi(void *a, ltc_mp_digit b, ltc_mp_digit *c)
223  {
224     fp_digit tmp;
225     int      err;
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    