
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 22.085889570552148%, Tokens: 9, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>redis-MDEwOlJlcG9zaXRvcnkxMDgxMTA3MDY=-flat-malloc_io_7.c</h3>
            <pre><code>1  #define JEMALLOC_MALLOC_IO_C_
2  #include "jemalloc/internal/jemalloc_preamble.h"
3  #include "jemalloc/internal/jemalloc_internal_includes.h"
4  #include "jemalloc/internal/malloc_io.h"
5  #include "jemalloc/internal/util.h"
6  #ifdef assert
7  #  undef assert
8  #endif
9  #ifdef not_reached
10  #  undef not_reached
11  #endif
12  #ifdef not_implemented
13  #  undef not_implemented
14  #endif
15  #ifdef assert_not_implemented
16  #  undef assert_not_implemented
17  #endif
18  #define assert(e) do {							\
19  	if (config_debug && !(e)) {					\
20  		malloc_write("<jemalloc>: Failed assertion\n");		\
21  		abort();						\
22  	}								\
23  } while (0)
24  #define not_reached() do {						\
25  	if (config_debug) {						\
26  		malloc_write("<jemalloc>: Unreachable code reached\n");	\
27  		abort();						\
28  	}								\
29  	unreachable();							\
30  } while (0)
31  #define not_implemented() do {						\
32  	if (config_debug) {						\
33  		malloc_write("<jemalloc>: Not implemented\n");		\
34  		abort();						\
35  	}								\
36  } while (0)
37  #define assert_not_implemented(e) do {					\
38  	if (unlikely(config_debug && !(e))) {				\
39  		not_implemented();					\
40  	}								\
41  } while (0)
42  static void wrtmessage(void *cbopaque, const char *s);
43  #define U2S_BUFSIZE ((1U << (LG_SIZEOF_INTMAX_T + 3)) + 1)
44  static char *u2s(uintmax_t x, unsigned base, bool uppercase, char *s,
45      size_t *slen_p);
46  #define D2S_BUFSIZE (1 + U2S_BUFSIZE)
<span onclick='openModal()' class='match'>47  static char *d2s(intmax_t x, char sign, char *s, size_t *slen_p);
48  #define O2S_BUFSIZE (1 + U2S_BUFSIZE)
49  static char *o2s(uintmax_t x, bool alt_form, char *s, size_t *slen_p);
50  #define X2S_BUFSIZE (2 + U2S_BUFSIZE)
51  static char *x2s(uintmax_t x, bool alt_form, bool uppercase, char *s,
</span>52      size_t *slen_p);
53  static void
54  wrtmessage(void *cbopaque, const char *s) {
55  	malloc_write_fd(STDERR_FILENO, s, strlen(s));
56  }
57  JEMALLOC_EXPORT void	(*je_malloc_message)(void *, const char *s);
58  void
59  malloc_write(const char *s) {
60  	if (je_malloc_message != NULL) {
61  		je_malloc_message(NULL, s);
62  	} else {
63  		wrtmessage(NULL, s);
64  	}
65  }
66  int
67  buferror(int err, char *buf, size_t buflen) {
68  #ifdef _WIN32
69  	FormatMessageA(FORMAT_MESSAGE_FROM_SYSTEM, NULL, err, 0,
70  	    (LPSTR)buf, (DWORD)buflen, NULL);
71  	return 0;
72  #elif defined(JEMALLOC_STRERROR_R_RETURNS_CHAR_WITH_GNU_SOURCE) && defined(_GNU_SOURCE)
73  	char *b = strerror_r(err, buf, buflen);
74  	if (b != buf) {
75  		strncpy(buf, b, buflen);
76  		buf[buflen-1] = '\0';
77  	}
78  	return 0;
79  #else
80  	return strerror_r(err, buf, buflen);
81  #endif
82  }
83  uintmax_t
84  malloc_strtoumax(const char *restrict nptr, char **restrict endptr, int base) {
85  	uintmax_t ret, digit;
86  	unsigned b;
87  	bool neg;
88  	const char *p, *ns;
89  	p = nptr;
90  	if (base < 0 || base == 1 || base > 36) {
91  		ns = p;
92  		set_errno(EINVAL);
93  		ret = UINTMAX_MAX;
94  		goto label_return;
95  	}
96  	b = base;
97  	neg = false;
98  	while (true) {
99  		switch (*p) {
100  		case '\t': case '\n': case '\v': case '\f': case '\r': case ' ':
101  			p++;
102  			break;
103  		case '-':
104  			neg = true;
105  		case '+':
106  			p++;
107  		default:
108  			goto label_prefix;
109  		}
110  	}
111  	label_prefix:
112  	ns = p;
113  	if (*p == '0') {
114  		switch (p[1]) {
115  		case '0': case '1': case '2': case '3': case '4': case '5':
116  		case '6': case '7':
117  			if (b == 0) {
118  				b = 8;
119  			}
120  			if (b == 8) {
121  				p++;
122  			}
123  			break;
124  		case 'X': case 'x':
125  			switch (p[2]) {
126  			case '0': case '1': case '2': case '3': case '4':
127  			case '5': case '6': case '7': case '8': case '9':
128  			case 'A': case 'B': case 'C': case 'D': case 'E':
129  			case 'F':
130  			case 'a': case 'b': case 'c': case 'd': case 'e':
131  			case 'f':
132  				if (b == 0) {
133  					b = 16;
134  				}
135  				if (b == 16) {
136  					p += 2;
137  				}
138  				break;
139  			default:
140  				break;
141  			}
142  			break;
143  		default:
144  			p++;
145  			ret = 0;
146  			goto label_return;
147  		}
148  	}
149  	if (b == 0) {
150  		b = 10;
151  	}
152  	ret = 0;
153  	while ((*p >= '0' && *p <= '9' && (digit = *p - '0') < b)
154  	    || (*p >= 'A' && *p <= 'Z' && (digit = 10 + *p - 'A') < b)
155  	    || (*p >= 'a' && *p <= 'z' && (digit = 10 + *p - 'a') < b)) {
156  		uintmax_t pret = ret;
157  		ret *= b;
158  		ret += digit;
159  		if (ret < pret) {
160  			set_errno(ERANGE);
161  			ret = UINTMAX_MAX;
162  			goto label_return;
163  		}
164  		p++;
165  	}
166  	if (neg) {
167  		ret = (uintmax_t)(-((intmax_t)ret));
168  	}
169  	if (p == ns) {
170  		set_errno(EINVAL);
171  		ret = UINTMAX_MAX;
172  		goto label_return;
173  	}
174  label_return:
175  	if (endptr != NULL) {
176  		if (p == ns) {
177  			*endptr = (char *)nptr;
178  		} else {
179  			*endptr = (char *)p;
180  		}
181  	}
182  	return ret;
183  }
184  static char *
185  u2s(uintmax_t x, unsigned base, bool uppercase, char *s, size_t *slen_p) {
186  	unsigned i;
187  	i = U2S_BUFSIZE - 1;
188  	s[i] = '\0';
189  	switch (base) {
190  	case 10:
191  		do {
192  			i--;
193  			s[i] = "0123456789"[x % (uint64_t)10];
194  			x /= (uint64_t)10;
195  		} while (x > 0);
196  		break;
197  	case 16: {
198  		const char *digits = (uppercase)
199  		    ? "0123456789ABCDEF"
200  		    : "0123456789abcdef";
201  		do {
202  			i--;
203  			s[i] = digits[x & 0xf];
204  			x >>= 4;
205  		} while (x > 0);
206  		break;
207  	} default: {
208  		const char *digits = (uppercase)
209  		    ? "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"
210  		    : "0123456789abcdefghijklmnopqrstuvwxyz";
211  		assert(base >= 2 && base <= 36);
212  		do {
213  			i--;
214  			s[i] = digits[x % (uint64_t)base];
215  			x /= (uint64_t)base;
216  		} while (x > 0);
217  	}}
218  	*slen_p = U2S_BUFSIZE - 1 - i;
219  	return &s[i];
220  }
221  static char *
222  d2s(intmax_t x, char sign, char *s, size_t *slen_p) {
223  	bool neg;
224  	if ((neg = (x < 0))) {
225  		x = -x;
226  	}
227  	s = u2s(x, 10, false, s, slen_p);
228  	if (neg) {
229  		sign = '-';
230  	}
231  	switch (sign) {
232  	case '-':
233  		if (!neg) {
234  			break;
235  		}
236  	case ' ':
237  	case '+':
238  		s--;
239  		(*slen_p)++;
240  		*s = sign;
241  		break;
242  	default: not_reached();
243  	}
244  	return s;
245  }
246  static char *
247  o2s(uintmax_t x, bool alt_form, char *s, size_t *slen_p) {
248  	s = u2s(x, 8, false, s, slen_p);
249  	if (alt_form && *s != '0') {
250  		s--;
251  		(*slen_p)++;
252  		*s = '0';
253  	}
254  	return s;
255  }
256  static char *
257  x2s(uintmax_t x, bool alt_form, bool uppercase, char *s, size_t *slen_p) {
258  	s = u2s(x, 16, uppercase, s, slen_p);
259  	if (alt_form) {
260  		s -= 2;
261  		(*slen_p) += 2;
262  		memcpy(s, uppercase ? "0X" : "0x", 2);
263  	}
264  	return s;
265  }
266  size_t
267  malloc_vsnprintf(char *str, size_t size, const char *format, va_list ap) {
268  	size_t i;
269  	const char *f;
270  #define APPEND_C(c) do {						\
271  	if (i < size) {							\
272  		str[i] = (c);						\
273  	}								\
274  	i++;								\
275  } while (0)
276  #define APPEND_S(s, slen) do {						\
277  	if (i < size) {							\
278  		size_t cpylen = (slen <= size - i) ? slen : size - i;	\
279  		memcpy(&str[i], s, cpylen);				\
280  	}								\
281  	i += slen;							\
282  } while (0)
283  #define APPEND_PADDED_S(s, slen, width, left_justify) do {		\
284  							\
285  	size_t pad_len = (width == -1) ? 0 : ((slen < (size_t)width) ?	\
286  	    (size_t)width - slen : 0);					\
287  	if (!left_justify && pad_len != 0) {				\
288  		size_t j;						\
289  		for (j = 0; j < pad_len; j++) {				\
290  			APPEND_C(' ');					\
291  		}							\
292  	}								\
293  								\
294  	APPEND_S(s, slen);						\
295  							\
296  	if (left_justify && pad_len != 0) {				\
297  		size_t j;						\
298  		for (j = 0; j < pad_len; j++) {				\
299  			APPEND_C(' ');					\
300  		}							\
301  	}								\
302  } while (0)
303  #define GET_ARG_NUMERIC(val, len) do {					\
304  	switch ((unsigned char)len) {					\
305  	case '?':							\
306  		val = va_arg(ap, int);					\
307  		break;							\
308  	case '?' | 0x80:						\
309  		val = va_arg(ap, unsigned int);				\
310  		break;							\
311  	case 'l':							\
312  		val = va_arg(ap, long);					\
313  		break;							\
314  	case 'l' | 0x80:						\
315  		val = va_arg(ap, unsigned long);			\
316  		break;							\
317  	case 'q':							\
318  		val = va_arg(ap, long long);				\
319  		break;							\
320  	case 'q' | 0x80:						\
321  		val = va_arg(ap, unsigned long long);			\
322  		break;							\
323  	case 'j':							\
324  		val = va_arg(ap, intmax_t);				\
325  		break;							\
326  	case 'j' | 0x80:						\
327  		val = va_arg(ap, uintmax_t);				\
328  		break;							\
329  	case 't':							\
330  		val = va_arg(ap, ptrdiff_t);				\
331  		break;							\
332  	case 'z':							\
333  		val = va_arg(ap, ssize_t);				\
334  		break;							\
335  	case 'z' | 0x80:						\
336  		val = va_arg(ap, size_t);				\
337  		break;							\
338  	case 'p': &bsol;* Synthetic; used for %p. */				\
339  		val = va_arg(ap, uintptr_t);				\
340  		break;							\
341  	default:							\
342  		not_reached();						\
343  		val = 0;						\
344  	}								\
345  } while (0)
346  	i = 0;
347  	f = format;
348  	while (true) {
349  		switch (*f) {
350  		case '\0': goto label_out;
351  		case '%': {
352  			bool alt_form = false;
353  			bool left_justify = false;
354  			bool plus_space = false;
355  			bool plus_plus = false;
356  			int prec = -1;
357  			int width = -1;
358  			unsigned char len = '?';
359  			char *s;
360  			size_t slen;
361  			f++;
362  			while (true) {
363  				switch (*f) {
364  				case '#':
365  					assert(!alt_form);
366  					alt_form = true;
367  					break;
368  				case '-':
369  					assert(!left_justify);
370  					left_justify = true;
371  					break;
372  				case ' ':
373  					assert(!plus_space);
374  					plus_space = true;
375  					break;
376  				case '+':
377  					assert(!plus_plus);
378  					plus_plus = true;
379  					break;
380  				default: goto label_width;
381  				}
382  				f++;
383  			}
384  			label_width:
385  			switch (*f) {
386  			case '*':
387  				width = va_arg(ap, int);
388  				f++;
389  				if (width < 0) {
390  					left_justify = true;
391  					width = -width;
392  				}
393  				break;
394  			case '0': case '1': case '2': case '3': case '4':
395  			case '5': case '6': case '7': case '8': case '9': {
396  				uintmax_t uwidth;
397  				set_errno(0);
398  				uwidth = malloc_strtoumax(f, (char **)&f, 10);
399  				assert(uwidth != UINTMAX_MAX || get_errno() !=
400  				    ERANGE);
401  				width = (int)uwidth;
402  				break;
403  			} default:
404  				break;
405  			}
406  			if (*f == '.') {
407  				f++;
408  			} else {
409  				goto label_length;
410  			}
411  			switch (*f) {
412  			case '*':
413  				prec = va_arg(ap, int);
414  				f++;
415  				break;
416  			case '0': case '1': case '2': case '3': case '4':
417  			case '5': case '6': case '7': case '8': case '9': {
418  				uintmax_t uprec;
419  				set_errno(0);
420  				uprec = malloc_strtoumax(f, (char **)&f, 10);
421  				assert(uprec != UINTMAX_MAX || get_errno() !=
422  				    ERANGE);
423  				prec = (int)uprec;
424  				break;
425  			}
426  			default: break;
427  			}
428  			label_length:
429  			switch (*f) {
430  			case 'l':
431  				f++;
432  				if (*f == 'l') {
433  					len = 'q';
434  					f++;
435  				} else {
436  					len = 'l';
437  				}
438  				break;
439  			case 'q': case 'j': case 't': case 'z':
440  				len = *f;
441  				f++;
442  				break;
443  			default: break;
444  			}
445  			switch (*f) {
446  			case '%':
447  				APPEND_C(*f);
448  				f++;
449  				break;
450  			case 'd': case 'i': {
451  				intmax_t val JEMALLOC_CC_SILENCE_INIT(0);
452  				char buf[D2S_BUFSIZE];
453  				GET_ARG_NUMERIC(val, len);
454  				s = d2s(val, (plus_plus ? '+' : (plus_space ?
455  				    ' ' : '-')), buf, &slen);
456  				APPEND_PADDED_S(s, slen, width, left_justify);
457  				f++;
458  				break;
459  			} case 'o': {
460  				uintmax_t val JEMALLOC_CC_SILENCE_INIT(0);
461  				char buf[O2S_BUFSIZE];
462  				GET_ARG_NUMERIC(val, len | 0x80);
463  				s = o2s(val, alt_form, buf, &slen);
464  				APPEND_PADDED_S(s, slen, width, left_justify);
465  				f++;
466  				break;
467  			} case 'u': {
468  				uintmax_t val JEMALLOC_CC_SILENCE_INIT(0);
469  				char buf[U2S_BUFSIZE];
470  				GET_ARG_NUMERIC(val, len | 0x80);
471  				s = u2s(val, 10, false, buf, &slen);
472  				APPEND_PADDED_S(s, slen, width, left_justify);
473  				f++;
474  				break;
475  			} case 'x': case 'X': {
476  				uintmax_t val JEMALLOC_CC_SILENCE_INIT(0);
477  				char buf[X2S_BUFSIZE];
478  				GET_ARG_NUMERIC(val, len | 0x80);
479  				s = x2s(val, alt_form, *f == 'X', buf, &slen);
480  				APPEND_PADDED_S(s, slen, width, left_justify);
481  				f++;
482  				break;
483  			} case 'c': {
484  				unsigned char val;
485  				char buf[2];
486  				assert(len == '?' || len == 'l');
487  				assert_not_implemented(len != 'l');
488  				val = va_arg(ap, int);
489  				buf[0] = val;
490  				buf[1] = '\0';
491  				APPEND_PADDED_S(buf, 1, width, left_justify);
492  				f++;
493  				break;
494  			} case 's':
495  				assert(len == '?' || len == 'l');
496  				assert_not_implemented(len != 'l');
497  				s = va_arg(ap, char *);
498  				slen = (prec < 0) ? strlen(s) : (size_t)prec;
499  				APPEND_PADDED_S(s, slen, width, left_justify);
500  				f++;
501  				break;
502  			case 'p': {
503  				uintmax_t val;
504  				char buf[X2S_BUFSIZE];
505  				GET_ARG_NUMERIC(val, 'p');
506  				s = x2s(val, true, false, buf, &slen);
507  				APPEND_PADDED_S(s, slen, width, left_justify);
508  				f++;
509  				break;
510  			} default: not_reached();
511  			}
512  			break;
513  		} default: {
514  			APPEND_C(*f);
515  			f++;
516  			break;
517  		}}
518  	}
519  	label_out:
520  	if (i < size) {
521  		str[i] = '\0';
522  	} else {
523  		str[size - 1] = '\0';
524  	}
525  #undef APPEND_C
526  #undef APPEND_S
527  #undef APPEND_PADDED_S
528  #undef GET_ARG_NUMERIC
529  	return i;
530  }
531  JEMALLOC_FORMAT_PRINTF(3, 4)
532  size_t
533  malloc_snprintf(char *str, size_t size, const char *format, ...) {
534  	size_t ret;
535  	va_list ap;
536  	va_start(ap, format);
537  	ret = malloc_vsnprintf(str, size, format, ap);
538  	va_end(ap);
539  	return ret;
540  }
541  void
542  malloc_vcprintf(void (*write_cb)(void *, const char *), void *cbopaque,
543      const char *format, va_list ap) {
544  	char buf[MALLOC_PRINTF_BUFSIZE];
545  	if (write_cb == NULL) {
546  		write_cb = (je_malloc_message != NULL) ? je_malloc_message :
547  		    wrtmessage;
548  	}
549  	malloc_vsnprintf(buf, sizeof(buf), format, ap);
550  	write_cb(cbopaque, buf);
551  }
552  JEMALLOC_FORMAT_PRINTF(3, 4)
553  void
554  malloc_cprintf(void (*write_cb)(void *, const char *), void *cbopaque,
555      const char *format, ...) {
556  	va_list ap;
557  	va_start(ap, format);
558  	malloc_vcprintf(write_cb, cbopaque, format, ap);
559  	va_end(ap);
560  }
561  JEMALLOC_FORMAT_PRINTF(1, 2)
562  void
563  malloc_printf(const char *format, ...) {
564  	va_list ap;
565  	va_start(ap, format);
566  	malloc_vcprintf(NULL, NULL, format, ap);
567  	va_end(ap);
568  }
569  #undef assert
570  #undef not_reached
571  #undef not_implemented
572  #undef assert_not_implemented
573  #include "jemalloc/internal/assert.h"
</code></pre>
        </div>
        <div class="column">
            <h3>xmrig-MDEwOlJlcG9zaXRvcnk4ODMyNzQwNg==-flat-DaemonClient.h</h3>
            <pre><code>1  #ifndef XMRIG_DAEMONCLIENT_H
2  #define XMRIG_DAEMONCLIENT_H
3  #include "base/kernel/interfaces/IDnsListener.h"
4  #include "base/kernel/interfaces/IHttpListener.h"
5  #include "base/kernel/interfaces/ITimerListener.h"
6  #include "base/net/stratum/BaseClient.h"
7  #include "base/net/tools/Storage.h"
8  #include "base/tools/cryptonote/BlockTemplate.h"
9  #include "base/tools/cryptonote/WalletAddress.h"
10  #include <memory>
11  using uv_buf_t      = struct uv_buf_t;
12  using uv_connect_t  = struct uv_connect_s;
13  using uv_handle_t   = struct uv_handle_s;
14  using uv_stream_t   = struct uv_stream_s;
15  using uv_tcp_t      = struct uv_tcp_s;
16  #ifdef XMRIG_FEATURE_TLS
17  using BIO           = struct bio_st;
18  using SSL           = struct ssl_st;
19  using SSL_CTX       = struct ssl_ctx_st;
20  #endif
21  namespace xmrig {
22  class DnsRequest;
23  class DaemonClient : public BaseClient, public IDnsListener, public ITimerListener, public IHttpListener
24  {
25  public:
26      XMRIG_DISABLE_COPY_MOVE_DEFAULT(DaemonClient)
27      DaemonClient(int id, IClientListener *listener);
28      ~DaemonClient() override;
29  protected:
30      bool disconnect() override;
31      bool isTLS() const override;
32      int64_t submit(const JobResult &result) override;
33      void connect() override;
34      void connect(const Pool &pool) override;
35      void setPool(const Pool &pool) override;
36      void onHttpData(const HttpData &data) override;
37      void onTimer(const Timer *timer) override;
38      void onResolved(const DnsRecords &records, int status, const char* error) override;
39      inline bool hasExtension(Extension) const noexcept override         { return false; }
40      inline const char *mode() const override                            { return "daemon"; }
41      inline const char *tlsFingerprint() const override                  { return m_tlsFingerprint; }
42      inline const char *tlsVersion() const override                      { return m_tlsVersion; }
43      inline int64_t send(const rapidjson::Value &, Callback) override    { return -1; }
44      inline int64_t send(const rapidjson::Value &) override              { return -1; }
45      void deleteLater() override;
46      inline void tick(uint64_t) override                                 {}
47  private:
48      bool isOutdated(uint64_t height, const char *hash) const;
49      bool parseJob(const rapidjson::Value &params, int *code);
50      bool parseResponse(int64_t id, const rapidjson::Value &result, const rapidjson::Value &error);
51      int64_t getBlockTemplate();
52      int64_t rpcSend(const rapidjson::Document &doc, const std::map<std::string, std::string> &headers = {});
53      void retry();
54      void send(const char *path);
55      void setState(SocketState state);
56      enum {
57          API_CRYPTONOTE_DEFAULT,
58          API_MONERO,
59      } m_apiVersion = API_MONERO;
<span onclick='openModal()' class='match'>60      BlockTemplate m_blocktemplate;
61      Coin m_coin;
62      std::shared_ptr<IHttpListener> m_httpListener;
63      String m_blockhashingblob;
64      String m_blocktemplateRequestHash;
65      String m_blocktemplateStr;
66      String m_currentJobId;
67      String m_prevHash;
68      uint64_t m_jobSteadyMs = 0;
</span>69      String m_tlsFingerprint;
70      String m_tlsVersion;
71      Timer *m_timer;
72      uint64_t m_blocktemplateRequestHeight = 0;
73      WalletAddress m_walletAddress;
74  private:
75      static inline DaemonClient* getClient(void* data) { return m_storage.get(data); }
76      uintptr_t m_key = 0;
77      static Storage<DaemonClient> m_storage;
78      static void onZMQConnect(uv_connect_t* req, int status);
79      static void onZMQRead(uv_stream_t* stream, ssize_t nread, const uv_buf_t* buf);
80      static void onZMQClose(uv_handle_t* handle);
81      static void onZMQShutdown(uv_handle_t* handle);
82      void ZMQConnected();
83      bool ZMQWrite(const char* data, size_t size);
84      void ZMQRead(ssize_t nread, const uv_buf_t* buf);
85      void ZMQParse();
86      bool ZMQClose(bool shutdown = false);
87      std::shared_ptr<DnsRequest> m_dns;
88      uv_tcp_t* m_ZMQSocket = nullptr;
89      enum {
90          ZMQ_NOT_CONNECTED,
91          ZMQ_GREETING_1,
92          ZMQ_GREETING_2,
93          ZMQ_HANDSHAKE,
94          ZMQ_CONNECTED,
95          ZMQ_DISCONNECTING,
96      } m_ZMQConnectionState = ZMQ_NOT_CONNECTED;
97      std::vector<char> m_ZMQSendBuf;
98      std::vector<char> m_ZMQRecvBuf;
99  };
100  } &bsol;* namespace xmrig */
101  #endif &bsol;* XMRIG_DAEMONCLIENT_H */
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from redis-MDEwOlJlcG9zaXRvcnkxMDgxMTA3MDY=-flat-malloc_io_7.c</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from xmrig-MDEwOlJlcG9zaXRvcnk4ODMyNzQwNg==-flat-DaemonClient.h</div>
                </div>
                <div class="column column_space"><pre><code>47  static char *d2s(intmax_t x, char sign, char *s, size_t *slen_p);
48  #define O2S_BUFSIZE (1 + U2S_BUFSIZE)
49  static char *o2s(uintmax_t x, bool alt_form, char *s, size_t *slen_p);
50  #define X2S_BUFSIZE (2 + U2S_BUFSIZE)
51  static char *x2s(uintmax_t x, bool alt_form, bool uppercase, char *s,
</pre></code></div>
                <div class="column column_space"><pre><code>60      BlockTemplate m_blocktemplate;
61      Coin m_coin;
62      std::shared_ptr<IHttpListener> m_httpListener;
63      String m_blockhashingblob;
64      String m_blocktemplateRequestHash;
65      String m_blocktemplateStr;
66      String m_currentJobId;
67      String m_prevHash;
68      uint64_t m_jobSteadyMs = 0;
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    