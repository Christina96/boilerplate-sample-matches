
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 12.174940898345152%, Tokens: 13, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>libpcap-MDEwOlJlcG9zaXRvcnk5NDM1ODg3-flat-pcap_0.h</h3>
            <pre><code>1  #ifndef lib_pcap_pcap_h
2  #define lib_pcap_pcap_h
3  #if defined(_MSC_VER)
4    #if !defined(_MSC_FULL_VER)
5      #if _MSC_VER > 1200
6        #undef _MSC_VER
7      #endif
8    #endif
9  #endif
10  #include <pcap/funcattrs.h>
11  #include <pcap/pcap-inttypes.h>
12  #if defined(_WIN32)
13    #include <winsock2.h>		&bsol;* u_int, u_char etc. */
14    #include <io.h>		&bsol;* _get_osfhandle() */
15  #elif defined(MSDOS)
16    #include <sys/types.h>	&bsol;* u_int, u_char etc. */
17    #include <sys/socket.h>
18  #else &bsol;* UN*X */
19    #include <sys/types.h>	&bsol;* u_int, u_char etc. */
20    #include <sys/time.h>
21  #endif &bsol;* _WIN32/MSDOS/UN*X */
22  #include <pcap/socket.h>	&bsol;* for SOCKET, as the active-mode rpcap APIs use it */
23  #ifndef PCAP_DONT_INCLUDE_PCAP_BPF_H
24  #include <pcap/bpf.h>
25  #endif
26  #include <stdio.h>
27  #ifdef __cplusplus
28  extern "C" {
29  #endif
30  #define PCAP_VERSION_MAJOR 2
31  #define PCAP_VERSION_MINOR 4
32  #define PCAP_ERRBUF_SIZE 256
33  #if BPF_RELEASE - 0 < 199406
34  typedef	int bpf_int32;
35  typedef	u_int bpf_u_int32;
36  #endif
37  typedef struct pcap pcap_t;
38  typedef struct pcap_dumper pcap_dumper_t;
39  typedef struct pcap_if pcap_if_t;
40  typedef struct pcap_addr pcap_addr_t;
41  struct pcap_file_header {
42  	bpf_u_int32 magic;
43  	u_short version_major;
44  	u_short version_minor;
45  	bpf_int32 thiszone;	&bsol;* not used - SHOULD be filled with 0 */
46  	bpf_u_int32 sigfigs;	&bsol;* not used - SHOULD be filled with 0 */
47  	bpf_u_int32 snaplen;	&bsol;* max length saved portion of each pkt */
48  	bpf_u_int32 linktype;	&bsol;* data link type (LINKTYPE_*) */
49  };
50  #define LT_LINKTYPE(x)			((x) & 0x0000FFFF)
51  #define LT_LINKTYPE_EXT(x)		((x) & 0xFFFF0000)
52  #define LT_RESERVED1(x)			((x) & 0x03FF0000)
53  #define LT_FCS_LENGTH_PRESENT(x)	((x) & 0x04000000)
54  #define LT_FCS_LENGTH(x)		(((x) & 0xF0000000) >> 28)
55  #define LT_FCS_DATALINK_EXT(x)		((((x) & 0xF) << 28) | 0x04000000)
56  typedef enum {
57         PCAP_D_INOUT = 0,
58         PCAP_D_IN,
59         PCAP_D_OUT
60  } pcap_direction_t;
61  struct pcap_pkthdr {
62  	struct timeval ts;	&bsol;* time stamp */
63  	bpf_u_int32 caplen;	&bsol;* length of portion present */
64  	bpf_u_int32 len;	&bsol;* length of this packet (off wire) */
<span onclick='openModal()' class='match'>65  };
66  struct pcap_stat {
67  	u_int ps_recv;		&bsol;* number of packets received */
68  	u_int ps_drop;		&bsol;* number of packets dropped */
69  	u_int ps_ifdrop;	&bsol;* drops by interface -- only supported on some platforms */
</span>70  #ifdef _WIN32
71  	u_int ps_capt;		&bsol;* number of packets that reach the application */
72  	u_int ps_sent;		&bsol;* number of packets sent by the server on the network */
73  	u_int ps_netdrop;	&bsol;* number of packets lost on the network */
74  #endif &bsol;* _WIN32 */
75  };
76  #ifdef MSDOS
77  struct pcap_stat_ex {
78         u_long  rx_packets;        &bsol;* total packets received       */
79         u_long  tx_packets;        &bsol;* total packets transmitted    */
80         u_long  rx_bytes;          &bsol;* total bytes received         */
81         u_long  tx_bytes;          &bsol;* total bytes transmitted      */
82         u_long  rx_errors;         &bsol;* bad packets received         */
83         u_long  tx_errors;         &bsol;* packet transmit problems     */
84         u_long  rx_dropped;        &bsol;* no space in Rx buffers       */
85         u_long  tx_dropped;        &bsol;* no space available for Tx    */
86         u_long  multicast;         &bsol;* multicast packets received   */
87         u_long  collisions;
88         u_long  rx_length_errors;
89         u_long  rx_over_errors;    &bsol;* receiver ring buff overflow  */
90         u_long  rx_crc_errors;     &bsol;* recv'd pkt with crc error    */
91         u_long  rx_frame_errors;   &bsol;* recv'd frame alignment error */
92         u_long  rx_fifo_errors;    &bsol;* recv'r fifo overrun          */
93         u_long  rx_missed_errors;  &bsol;* recv'r missed packet         */
94         u_long  tx_aborted_errors;
95         u_long  tx_carrier_errors;
96         u_long  tx_fifo_errors;
97         u_long  tx_heartbeat_errors;
98         u_long  tx_window_errors;
99       };
100  #endif
101  struct pcap_if {
102  	struct pcap_if *next;
103  	char *name;		&bsol;* name to hand to "pcap_open_live()" */
104  	char *description;	&bsol;* textual description of interface, or NULL */
105  	struct pcap_addr *addresses;
106  	bpf_u_int32 flags;	&bsol;* PCAP_IF_ interface flags */
107  };
108  #define PCAP_IF_LOOPBACK				0x00000001	&bsol;* interface is loopback */
109  #define PCAP_IF_UP					0x00000002	&bsol;* interface is up */
110  #define PCAP_IF_RUNNING					0x00000004	&bsol;* interface is running */
111  #define PCAP_IF_WIRELESS				0x00000008	&bsol;* interface is wireless (*NOT* necessarily Wi-Fi!) */
112  #define PCAP_IF_CONNECTION_STATUS			0x00000030	&bsol;* connection status: */
113  #define PCAP_IF_CONNECTION_STATUS_UNKNOWN		0x00000000	&bsol;* unknown */
114  #define PCAP_IF_CONNECTION_STATUS_CONNECTED		0x00000010	&bsol;* connected */
115  #define PCAP_IF_CONNECTION_STATUS_DISCONNECTED		0x00000020	&bsol;* disconnected */
116  #define PCAP_IF_CONNECTION_STATUS_NOT_APPLICABLE	0x00000030	&bsol;* not applicable */
117  struct pcap_addr {
118  	struct pcap_addr *next;
119  	struct sockaddr *addr;		&bsol;* address */
120  	struct sockaddr *netmask;	&bsol;* netmask for that address */
121  	struct sockaddr *broadaddr;	&bsol;* broadcast address for that address */
122  	struct sockaddr *dstaddr;	&bsol;* P2P destination address for that address */
123  };
124  typedef void (*pcap_handler)(u_char *, const struct pcap_pkthdr *,
125  			     const u_char *);
126  #define PCAP_ERROR			-1	&bsol;* generic error code */
127  #define PCAP_ERROR_BREAK		-2	&bsol;* loop terminated by pcap_breakloop */
128  #define PCAP_ERROR_NOT_ACTIVATED	-3	&bsol;* the capture needs to be activated */
129  #define PCAP_ERROR_ACTIVATED		-4	&bsol;* the operation can't be performed on already activated captures */
130  #define PCAP_ERROR_NO_SUCH_DEVICE	-5	&bsol;* no such device exists */
131  #define PCAP_ERROR_RFMON_NOTSUP		-6	&bsol;* this device doesn't support rfmon (monitor) mode */
132  #define PCAP_ERROR_NOT_RFMON		-7	&bsol;* operation supported only in monitor mode */
133  #define PCAP_ERROR_PERM_DENIED		-8	&bsol;* no permission to open the device */
134  #define PCAP_ERROR_IFACE_NOT_UP		-9	&bsol;* interface isn't up */
135  #define PCAP_ERROR_CANTSET_TSTAMP_TYPE	-10	&bsol;* this device doesn't support setting the time stamp type */
136  #define PCAP_ERROR_PROMISC_PERM_DENIED	-11	&bsol;* you don't have permission to capture in promiscuous mode */
137  #define PCAP_ERROR_TSTAMP_PRECISION_NOTSUP -12  &bsol;* the requested time stamp precision is not supported */
138  #define PCAP_WARNING			1	&bsol;* generic warning code */
139  #define PCAP_WARNING_PROMISC_NOTSUP	2	&bsol;* this device doesn't support promiscuous mode */
140  #define PCAP_WARNING_TSTAMP_TYPE_NOTSUP	3	&bsol;* the requested time stamp type is not supported */
141  #define PCAP_NETMASK_UNKNOWN	0xffffffff
142  #define PCAP_CHAR_ENC_LOCAL	0x00000000U	&bsol;* strings are in the local character encoding */
143  #define PCAP_CHAR_ENC_UTF_8	0x00000001U	&bsol;* strings are in UTF-8 */
144  #define PCAP_MMAP_32BIT	0x00000002U	&bsol;* map packet buffers with 32-bit addresses */
145  PCAP_AVAILABLE_1_10
146  PCAP_API int	pcap_init(unsigned int, char *);
147  PCAP_AVAILABLE_0_4
148  PCAP_DEPRECATED("use 'pcap_findalldevs' and use the first device")
149  PCAP_API char	*pcap_lookupdev(char *);
150  PCAP_AVAILABLE_0_4
151  PCAP_API int	pcap_lookupnet(const char *, bpf_u_int32 *, bpf_u_int32 *, char *);
152  PCAP_AVAILABLE_1_0
153  PCAP_API pcap_t	*pcap_create(const char *, char *);
154  PCAP_AVAILABLE_1_0
155  PCAP_API int	pcap_set_snaplen(pcap_t *, int);
156  PCAP_AVAILABLE_1_0
157  PCAP_API int	pcap_set_promisc(pcap_t *, int);
158  PCAP_AVAILABLE_1_0
159  PCAP_API int	pcap_can_set_rfmon(pcap_t *);
160  PCAP_AVAILABLE_1_0
161  PCAP_API int	pcap_set_rfmon(pcap_t *, int);
162  PCAP_AVAILABLE_1_0
163  PCAP_API int	pcap_set_timeout(pcap_t *, int);
164  PCAP_AVAILABLE_1_2
165  PCAP_API int	pcap_set_tstamp_type(pcap_t *, int);
166  PCAP_AVAILABLE_1_5
167  PCAP_API int	pcap_set_immediate_mode(pcap_t *, int);
168  PCAP_AVAILABLE_1_0
169  PCAP_API int	pcap_set_buffer_size(pcap_t *, int);
170  PCAP_AVAILABLE_1_5
171  PCAP_API int	pcap_set_tstamp_precision(pcap_t *, int);
172  PCAP_AVAILABLE_1_5
173  PCAP_API int	pcap_get_tstamp_precision(pcap_t *);
174  PCAP_AVAILABLE_1_0
175  PCAP_API int	pcap_activate(pcap_t *);
176  PCAP_AVAILABLE_1_2
177  PCAP_API int	pcap_list_tstamp_types(pcap_t *, int **);
178  PCAP_AVAILABLE_1_2
179  PCAP_API void	pcap_free_tstamp_types(int *);
180  PCAP_AVAILABLE_1_2
181  PCAP_API int	pcap_tstamp_type_name_to_val(const char *);
182  PCAP_AVAILABLE_1_2
183  PCAP_API const char *pcap_tstamp_type_val_to_name(int);
184  PCAP_AVAILABLE_1_2
185  PCAP_API const char *pcap_tstamp_type_val_to_description(int);
186  #ifdef __linux__
187  PCAP_AVAILABLE_1_9
188  PCAP_API int	pcap_set_protocol_linux(pcap_t *, int);
189  #endif
190  #define PCAP_TSTAMP_HOST			0	&bsol;* host-provided, unknown characteristics */
191  #define PCAP_TSTAMP_HOST_LOWPREC		1	&bsol;* host-provided, low precision, synced with the system clock */
192  #define PCAP_TSTAMP_HOST_HIPREC			2	&bsol;* host-provided, high precision, synced with the system clock */
193  #define PCAP_TSTAMP_ADAPTER			3	&bsol;* device-provided, synced with the system clock */
194  #define PCAP_TSTAMP_ADAPTER_UNSYNCED		4	&bsol;* device-provided, not synced with the system clock */
195  #define PCAP_TSTAMP_HOST_HIPREC_UNSYNCED	5	&bsol;* host-provided, high precision, not synced with the system clock */
196  #define PCAP_TSTAMP_PRECISION_MICRO	0	&bsol;* use timestamps with microsecond precision, default */
197  #define PCAP_TSTAMP_PRECISION_NANO	1	&bsol;* use timestamps with nanosecond precision */
198  PCAP_AVAILABLE_0_4
199  PCAP_API pcap_t	*pcap_open_live(const char *, int, int, int, char *);
200  PCAP_AVAILABLE_0_6
201  PCAP_API pcap_t	*pcap_open_dead(int, int);
202  PCAP_AVAILABLE_1_5
203  PCAP_API pcap_t	*pcap_open_dead_with_tstamp_precision(int, int, u_int);
204  PCAP_AVAILABLE_1_5
205  PCAP_API pcap_t	*pcap_open_offline_with_tstamp_precision(const char *, u_int, char *);
206  PCAP_AVAILABLE_0_4
207  PCAP_API pcap_t	*pcap_open_offline(const char *, char *);
208  #ifdef _WIN32
209    PCAP_AVAILABLE_1_5
210    PCAP_API pcap_t  *pcap_hopen_offline_with_tstamp_precision(intptr_t, u_int, char *);
211    PCAP_API pcap_t  *pcap_hopen_offline(intptr_t, char *);
212    #ifndef BUILDING_PCAP
213      #define pcap_fopen_offline_with_tstamp_precision(f,p,b) \
214  	pcap_hopen_offline_with_tstamp_precision(_get_osfhandle(_fileno(f)), p, b)
215      #define pcap_fopen_offline(f,b) \
216  	pcap_hopen_offline(_get_osfhandle(_fileno(f)), b)
217    #endif
218  #else &bsol;*_WIN32*/
219    PCAP_AVAILABLE_1_5
220    PCAP_API pcap_t	*pcap_fopen_offline_with_tstamp_precision(FILE *, u_int, char *);
221    PCAP_AVAILABLE_0_9
222    PCAP_API pcap_t	*pcap_fopen_offline(FILE *, char *);
223  #endif &bsol;*_WIN32*/
224  PCAP_AVAILABLE_0_4
225  PCAP_API void	pcap_close(pcap_t *);
226  PCAP_AVAILABLE_0_4
227  PCAP_API int	pcap_loop(pcap_t *, int, pcap_handler, u_char *);
228  PCAP_AVAILABLE_0_4
229  PCAP_API int	pcap_dispatch(pcap_t *, int, pcap_handler, u_char *);
230  PCAP_AVAILABLE_0_4
231  PCAP_API const u_char *pcap_next(pcap_t *, struct pcap_pkthdr *);
232  PCAP_AVAILABLE_0_8
233  PCAP_API int	pcap_next_ex(pcap_t *, struct pcap_pkthdr **, const u_char **);
234  PCAP_AVAILABLE_0_8
235  PCAP_API void	pcap_breakloop(pcap_t *);
236  PCAP_AVAILABLE_0_4
237  PCAP_API int	pcap_stats(pcap_t *, struct pcap_stat *);
238  PCAP_AVAILABLE_0_4
239  PCAP_API int	pcap_setfilter(pcap_t *, struct bpf_program *);
240  PCAP_AVAILABLE_0_9
241  PCAP_API int	pcap_setdirection(pcap_t *, pcap_direction_t);
242  PCAP_AVAILABLE_0_7
243  PCAP_API int	pcap_getnonblock(pcap_t *, char *);
244  PCAP_AVAILABLE_0_7
245  PCAP_API int	pcap_setnonblock(pcap_t *, int, char *);
246  PCAP_AVAILABLE_0_9
247  PCAP_API int	pcap_inject(pcap_t *, const void *, size_t);
248  PCAP_AVAILABLE_0_8
249  PCAP_API int	pcap_sendpacket(pcap_t *, const u_char *, int);
250  PCAP_AVAILABLE_1_0
251  PCAP_API const char *pcap_statustostr(int);
252  PCAP_AVAILABLE_0_4
253  PCAP_API const char *pcap_strerror(int);
254  PCAP_AVAILABLE_0_4
255  PCAP_API char	*pcap_geterr(pcap_t *);
256  PCAP_AVAILABLE_0_4
257  PCAP_API void	pcap_perror(pcap_t *, const char *);
258  PCAP_AVAILABLE_0_4
259  PCAP_API int	pcap_compile(pcap_t *, struct bpf_program *, const char *, int,
260  	    bpf_u_int32);
261  PCAP_AVAILABLE_0_5
262  PCAP_DEPRECATED("use pcap_open_dead(), pcap_compile() and pcap_close()")
263  PCAP_API int	pcap_compile_nopcap(int, int, struct bpf_program *,
264  	    const char *, int, bpf_u_int32);
265  PCAP_AVAILABLE_0_6
266  PCAP_API void	pcap_freecode(struct bpf_program *);
267  PCAP_AVAILABLE_1_0
268  PCAP_API int	pcap_offline_filter(const struct bpf_program *,
269  	    const struct pcap_pkthdr *, const u_char *);
270  PCAP_AVAILABLE_0_4
271  PCAP_API int	pcap_datalink(pcap_t *);
272  PCAP_AVAILABLE_1_0
273  PCAP_API int	pcap_datalink_ext(pcap_t *);
274  PCAP_AVAILABLE_0_8
275  PCAP_API int	pcap_list_datalinks(pcap_t *, int **);
276  PCAP_AVAILABLE_0_8
277  PCAP_API int	pcap_set_datalink(pcap_t *, int);
278  PCAP_AVAILABLE_0_8
279  PCAP_API void	pcap_free_datalinks(int *);
280  PCAP_AVAILABLE_0_8
281  PCAP_API int	pcap_datalink_name_to_val(const char *);
282  PCAP_AVAILABLE_0_8
283  PCAP_API const char *pcap_datalink_val_to_name(int);
284  PCAP_AVAILABLE_0_8
285  PCAP_API const char *pcap_datalink_val_to_description(int);
286  PCAP_AVAILABLE_1_10
287  PCAP_API const char *pcap_datalink_val_to_description_or_dlt(int);
288  PCAP_AVAILABLE_0_4
289  PCAP_API int	pcap_snapshot(pcap_t *);
290  PCAP_AVAILABLE_0_4
291  PCAP_API int	pcap_is_swapped(pcap_t *);
292  PCAP_AVAILABLE_0_4
293  PCAP_API int	pcap_major_version(pcap_t *);
294  PCAP_AVAILABLE_0_4
295  PCAP_API int	pcap_minor_version(pcap_t *);
296  PCAP_AVAILABLE_1_9
297  PCAP_API int	pcap_bufsize(pcap_t *);
298  PCAP_AVAILABLE_0_4
299  PCAP_API FILE	*pcap_file(pcap_t *);
300  #ifdef _WIN32
301  PCAP_AVAILABLE_0_4
302  PCAP_DEPRECATED("request a 'pcap_handle' that returns a HANDLE if you need it")
303  PCAP_API int	pcap_fileno(pcap_t *);
304  #else &bsol;* _WIN32 */
305  PCAP_AVAILABLE_0_4
306  PCAP_API int	pcap_fileno(pcap_t *);
307  #endif &bsol;* _WIN32 */
308  #ifdef _WIN32
309    PCAP_API int	pcap_wsockinit(void);
310  #endif
311  PCAP_AVAILABLE_0_4
312  PCAP_API pcap_dumper_t *pcap_dump_open(pcap_t *, const char *);
313  #ifdef _WIN32
314    PCAP_AVAILABLE_0_9
315    PCAP_API pcap_dumper_t *pcap_dump_hopen(pcap_t *, intptr_t);
316    #ifndef BUILDING_PCAP
317      #define pcap_dump_fopen(p,f) \
318  	pcap_dump_hopen(p, _get_osfhandle(_fileno(f)))
319    #endif
320  #else &bsol;*_WIN32*/
321    PCAP_AVAILABLE_0_9
322    PCAP_API pcap_dumper_t *pcap_dump_fopen(pcap_t *, FILE *fp);
323  #endif &bsol;*_WIN32*/
324  PCAP_AVAILABLE_1_7
325  PCAP_API pcap_dumper_t *pcap_dump_open_append(pcap_t *, const char *);
326  PCAP_AVAILABLE_0_8
327  PCAP_API FILE	*pcap_dump_file(pcap_dumper_t *);
328  PCAP_AVAILABLE_0_9
329  PCAP_API long	pcap_dump_ftell(pcap_dumper_t *);
330  PCAP_AVAILABLE_1_9
331  PCAP_API int64_t	pcap_dump_ftell64(pcap_dumper_t *);
332  PCAP_AVAILABLE_0_8
333  PCAP_API int	pcap_dump_flush(pcap_dumper_t *);
334  PCAP_AVAILABLE_0_4
335  PCAP_API void	pcap_dump_close(pcap_dumper_t *);
336  PCAP_AVAILABLE_0_4
337  PCAP_API void	pcap_dump(u_char *, const struct pcap_pkthdr *, const u_char *);
338  PCAP_AVAILABLE_0_7
339  PCAP_API int	pcap_findalldevs(pcap_if_t **, char *);
340  PCAP_AVAILABLE_0_7
341  PCAP_API void	pcap_freealldevs(pcap_if_t *);
342  PCAP_AVAILABLE_0_8
343  PCAP_API const char *pcap_lib_version(void);
344  #if defined(_WIN32)
345    struct pcap_send_queue
346    {
347  	u_int maxlen;	&bsol;* Maximum size of the queue, in bytes. This
348  			   variable contains the size of the buffer field. */
349  	u_int len;	&bsol;* Current size of the queue, in bytes. */
350  	char *buffer;	&bsol;* Buffer containing the packets to be sent. */
351    };
352    typedef struct pcap_send_queue pcap_send_queue;
353    #if !defined(AIRPCAP_HANDLE__EAE405F5_0171_9592_B3C2_C19EC426AD34__DEFINED_)
354      #define AIRPCAP_HANDLE__EAE405F5_0171_9592_B3C2_C19EC426AD34__DEFINED_
355      typedef struct _AirpcapHandle *PAirpcapHandle;
356    #endif
357    PCAP_API int pcap_setbuff(pcap_t *p, int dim);
358    PCAP_API int pcap_setmode(pcap_t *p, int mode);
359    PCAP_API int pcap_setmintocopy(pcap_t *p, int size);
360    PCAP_API HANDLE pcap_getevent(pcap_t *p);
361    PCAP_AVAILABLE_1_8
362    PCAP_API int pcap_oid_get_request(pcap_t *, bpf_u_int32, void *, size_t *);
363    PCAP_AVAILABLE_1_8
364    PCAP_API int pcap_oid_set_request(pcap_t *, bpf_u_int32, const void *, size_t *);
365    PCAP_API pcap_send_queue* pcap_sendqueue_alloc(u_int memsize);
366    PCAP_API void pcap_sendqueue_destroy(pcap_send_queue* queue);
367    PCAP_API int pcap_sendqueue_queue(pcap_send_queue* queue, const struct pcap_pkthdr *pkt_header, const u_char *pkt_data);
368    PCAP_API u_int pcap_sendqueue_transmit(pcap_t *p, pcap_send_queue* queue, int sync);
369    PCAP_API struct pcap_stat *pcap_stats_ex(pcap_t *p, int *pcap_stat_size);
370    PCAP_API int pcap_setuserbuffer(pcap_t *p, int size);
371    PCAP_API int pcap_live_dump(pcap_t *p, char *filename, int maxsize, int maxpacks);
372    PCAP_API int pcap_live_dump_ended(pcap_t *p, int sync);
373    PCAP_API int pcap_start_oem(char* err_str, int flags);
374    PCAP_API PAirpcapHandle pcap_get_airpcap_handle(pcap_t *p);
375    #define MODE_CAPT 0
376    #define MODE_STAT 1
377    #define MODE_MON 2
378  #elif defined(MSDOS)
379    PCAP_API int  pcap_stats_ex (pcap_t *, struct pcap_stat_ex *);
380    PCAP_API void pcap_set_wait (pcap_t *p, void (*yield)(void), int wait);
381    PCAP_API u_long pcap_mac_packets (void);
382  #else &bsol;* UN*X */
383    PCAP_AVAILABLE_0_8
384    PCAP_API int	pcap_get_selectable_fd(pcap_t *);
385    PCAP_AVAILABLE_1_9
386    PCAP_API const struct timeval *pcap_get_required_select_timeout(pcap_t *);
387  #endif &bsol;* _WIN32/MSDOS/UN*X */
388  #define PCAP_BUF_SIZE 1024
389  #define PCAP_SRC_FILE		2	&bsol;* local savefile */
390  #define PCAP_SRC_IFLOCAL	3	&bsol;* local network interface */
391  #define PCAP_SRC_IFREMOTE	4	&bsol;* interface on a remote host, using RPCAP */
392  #define PCAP_SRC_FILE_STRING "file:&bsol;&bsol;"
393  #define PCAP_SRC_IF_STRING "rpcap:&bsol;&bsol;"
394  #define PCAP_OPENFLAG_PROMISCUOUS		0x00000001
395  #define PCAP_OPENFLAG_DATATX_UDP		0x00000002
396  #define PCAP_OPENFLAG_NOCAPTURE_RPCAP		0x00000004
397  #define PCAP_OPENFLAG_NOCAPTURE_LOCAL		0x00000008
398  #define PCAP_OPENFLAG_MAX_RESPONSIVENESS	0x00000010
399  #define RPCAP_RMTAUTH_NULL 0
400  #define RPCAP_RMTAUTH_PWD 1
401  struct pcap_rmtauth
402  {
403  	int type;
404  	char *username;
405  	char *password;
406  };
407  PCAP_AVAILABLE_1_9
408  PCAP_API pcap_t	*pcap_open(const char *source, int snaplen, int flags,
409  	    int read_timeout, struct pcap_rmtauth *auth, char *errbuf);
410  PCAP_AVAILABLE_1_9
411  PCAP_API int	pcap_createsrcstr(char *source, int type, const char *host,
412  	    const char *port, const char *name, char *errbuf);
413  PCAP_AVAILABLE_1_9
414  PCAP_API int	pcap_parsesrcstr(const char *source, int *type, char *host,
415  	    char *port, char *name, char *errbuf);
416  PCAP_AVAILABLE_1_9
417  PCAP_API int	pcap_findalldevs_ex(const char *source,
418  	    struct pcap_rmtauth *auth, pcap_if_t **alldevs, char *errbuf);
419  #define PCAP_SAMP_NOSAMP	0
420  #define PCAP_SAMP_1_EVERY_N	1
421  #define PCAP_SAMP_FIRST_AFTER_N_MS 2
422  struct pcap_samp
423  {
424  	int method;
425  	int value;
426  };
427  PCAP_AVAILABLE_1_9
428  PCAP_API struct pcap_samp *pcap_setsampling(pcap_t *p);
429  #define RPCAP_HOSTLIST_SIZE 1024
430  PCAP_AVAILABLE_1_9
431  PCAP_API SOCKET	pcap_remoteact_accept(const char *address, const char *port,
432  	    const char *hostlist, char *connectinghost,
433  	    struct pcap_rmtauth *auth, char *errbuf);
434  PCAP_AVAILABLE_1_10
435  PCAP_API SOCKET	pcap_remoteact_accept_ex(const char *address, const char *port,
436  	    const char *hostlist, char *connectinghost,
437  	    struct pcap_rmtauth *auth, int uses_ssl, char *errbuf);
438  PCAP_AVAILABLE_1_9
439  PCAP_API int	pcap_remoteact_list(char *hostlist, char sep, int size,
440  	    char *errbuf);
441  PCAP_AVAILABLE_1_9
442  PCAP_API int	pcap_remoteact_close(const char *host, char *errbuf);
443  PCAP_AVAILABLE_1_9
444  PCAP_API void	pcap_remoteact_cleanup(void);
445  enum pcap_option_name {  &bsol;* never renumber this */
446  		       PON_TSTAMP_PRECISION = 1,  &bsol;* int */
447  		       PON_IO_READ_PLUGIN   = 2,  &bsol;* char * */
448  		       PON_IO_WRITE_PLUGIN  = 3,  &bsol;* char * */
449  };
450  typedef struct pcap_options pcap_options;
451  PCAP_AVAILABLE_1_11
452  PCAP_API pcap_options *pcap_alloc_option(void);
453  PCAP_AVAILABLE_1_11
454  PCAP_API void pcap_free_option(pcap_options *po);
455  PCAP_AVAILABLE_1_11
456  PCAP_API int pcap_set_option_string(pcap_options *po,
457  				    enum pcap_option_name pon, const char *value);
458  PCAP_AVAILABLE_1_11
459  PCAP_API int pcap_set_option_int(pcap_options *po,
460  				 enum pcap_option_name pon, const int value);
461  PCAP_AVAILABLE_1_11
462  PCAP_API const char *pcap_get_option_string(pcap_options *po, enum pcap_option_name pon);
463  PCAP_AVAILABLE_1_11
464  PCAP_API int pcap_get_option_int(pcap_options *po, enum pcap_option_name pon);
465  #ifdef __cplusplus
466  }
467  #endif
468  #endif &bsol;* lib_pcap_pcap_h */
</code></pre>
        </div>
        <div class="column">
            <h3>xmrig-MDEwOlJlcG9zaXRvcnk4ODMyNzQwNg==-flat-topology-windows.c</h3>
            <pre><code>1  #define _WIN32_WINNT 0x0601
2  #include "private/autogen/config.h"
3  #include "hwloc.h"
4  #include "hwloc/windows.h"
5  #include "private/private.h"
6  #include "private/windows.h" &bsol;* must be before windows.h */
7  #include "private/debug.h"
8  #include <windows.h>
9  #ifndef HAVE_KAFFINITY
10  typedef ULONG_PTR KAFFINITY, *PKAFFINITY;
11  #endif
12  #ifndef HAVE_PROCESSOR_CACHE_TYPE
13  typedef enum _PROCESSOR_CACHE_TYPE {
14    CacheUnified,
15    CacheInstruction,
16    CacheData,
17    CacheTrace
18  } PROCESSOR_CACHE_TYPE;
19  #endif
20  #ifndef CACHE_FULLY_ASSOCIATIVE
21  #define CACHE_FULLY_ASSOCIATIVE 0xFF
22  #endif
23  #ifndef MAXIMUM_PROC_PER_GROUP &bsol;* missing in MinGW */
24  #define MAXIMUM_PROC_PER_GROUP 64
25  #endif
26  #ifndef HAVE_CACHE_DESCRIPTOR
27  typedef struct _CACHE_DESCRIPTOR {
28    BYTE Level;
29    BYTE Associativity;
30    WORD LineSize;
31    DWORD Size; &bsol;* in bytes */
32    PROCESSOR_CACHE_TYPE Type;
33  } CACHE_DESCRIPTOR, *PCACHE_DESCRIPTOR;
34  #endif
35  #ifndef HAVE_LOGICAL_PROCESSOR_RELATIONSHIP
36  typedef enum _LOGICAL_PROCESSOR_RELATIONSHIP {
37    RelationProcessorCore,
38    RelationNumaNode,
39    RelationCache,
40    RelationProcessorPackage,
41    RelationGroup,
42    RelationAll = 0xffff
43  } LOGICAL_PROCESSOR_RELATIONSHIP;
44  #else &bsol;* HAVE_LOGICAL_PROCESSOR_RELATIONSHIP */
45  #  ifndef HAVE_RELATIONPROCESSORPACKAGE
46  #    define RelationProcessorPackage 3
47  #    define RelationGroup 4
48  #    define RelationAll 0xffff
49  #  endif &bsol;* HAVE_RELATIONPROCESSORPACKAGE */
50  #endif &bsol;* HAVE_LOGICAL_PROCESSOR_RELATIONSHIP */
51  #ifndef HAVE_GROUP_AFFINITY
52  typedef struct _GROUP_AFFINITY {
53    KAFFINITY Mask;
54    WORD Group;
55    WORD Reserved[3];
56  } GROUP_AFFINITY, *PGROUP_AFFINITY;
57  #endif
58  typedef struct HWLOC_PROCESSOR_RELATIONSHIP {
59    BYTE Flags;
60    BYTE EfficiencyClass; &bsol;* for RelationProcessorCore, higher means greater performance but less efficiency */
61    BYTE Reserved[20];
62    WORD GroupCount;
63    GROUP_AFFINITY GroupMask[ANYSIZE_ARRAY];
64  } HWLOC_PROCESSOR_RELATIONSHIP;
65  typedef struct HWLOC_NUMA_NODE_RELATIONSHIP {
66    DWORD NodeNumber;
67    BYTE Reserved[18];
68    WORD GroupCount;
69    _ANONYMOUS_UNION
70    union {
71      GROUP_AFFINITY GroupMask;
72      GROUP_AFFINITY GroupMasks[ANYSIZE_ARRAY];
73    } DUMMYUNIONNAME;
74  } HWLOC_NUMA_NODE_RELATIONSHIP;
75  typedef struct HWLOC_CACHE_RELATIONSHIP {
76    BYTE Level;
77    BYTE Associativity;
78    WORD LineSize;
79    DWORD CacheSize;
80    PROCESSOR_CACHE_TYPE Type;
81    BYTE Reserved[18];
82    WORD GroupCount;
83    union {
84      GROUP_AFFINITY GroupMask;
85      GROUP_AFFINITY GroupMasks[ANYSIZE_ARRAY];
86    } DUMMYUNIONNAME;
87  } HWLOC_CACHE_RELATIONSHIP;
88  #ifndef HAVE_PROCESSOR_GROUP_INFO
89  typedef struct _PROCESSOR_GROUP_INFO {
90    BYTE MaximumProcessorCount;
91    BYTE ActiveProcessorCount;
92    BYTE Reserved[38];
93    KAFFINITY ActiveProcessorMask;
94  } PROCESSOR_GROUP_INFO, *PPROCESSOR_GROUP_INFO;
95  #endif
96  #ifndef HAVE_GROUP_RELATIONSHIP
97  typedef struct _GROUP_RELATIONSHIP {
98    WORD MaximumGroupCount;
99    WORD ActiveGroupCount;
100    ULONGLONG Reserved[2];
101    PROCESSOR_GROUP_INFO GroupInfo[ANYSIZE_ARRAY];
102  } GROUP_RELATIONSHIP, *PGROUP_RELATIONSHIP;
103  #endif
104  typedef struct HWLOC_SYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX {
105    LOGICAL_PROCESSOR_RELATIONSHIP Relationship;
106    DWORD Size;
107    _ANONYMOUS_UNION
108    union {
109      HWLOC_PROCESSOR_RELATIONSHIP Processor;
110      HWLOC_NUMA_NODE_RELATIONSHIP NumaNode;
111      HWLOC_CACHE_RELATIONSHIP Cache;
112      GROUP_RELATIONSHIP Group;
113    } DUMMYUNIONNAME;
114  } HWLOC_SYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX;
115  #ifndef HAVE_PSAPI_WORKING_SET_EX_BLOCK
116  typedef union _PSAPI_WORKING_SET_EX_BLOCK {
117    ULONG_PTR Flags;
118    struct {
119      unsigned Valid  :1;
120      unsigned ShareCount  :3;
121      unsigned Win32Protection  :11;
122      unsigned Shared  :1;
123      unsigned Node  :6;
124      unsigned Locked  :1;
125      unsigned LargePage  :1;
126    };
127  } PSAPI_WORKING_SET_EX_BLOCK;
128  #endif
129  #ifndef HAVE_PSAPI_WORKING_SET_EX_INFORMATION
130  typedef struct _PSAPI_WORKING_SET_EX_INFORMATION {
131    PVOID VirtualAddress;
132    PSAPI_WORKING_SET_EX_BLOCK VirtualAttributes;
133  } PSAPI_WORKING_SET_EX_INFORMATION;
134  #endif
135  #ifndef HAVE_PROCESSOR_NUMBER
136  typedef struct _PROCESSOR_NUMBER {
137    WORD Group;
138    BYTE Number;
139    BYTE Reserved;
140  } PROCESSOR_NUMBER, *PPROCESSOR_NUMBER;
141  #endif
142  typedef WORD (WINAPI *PFN_GETACTIVEPROCESSORGROUPCOUNT)(void);
143  static PFN_GETACTIVEPROCESSORGROUPCOUNT GetActiveProcessorGroupCountProc;
144  typedef WORD (WINAPI *PFN_GETACTIVEPROCESSORCOUNT)(WORD);
145  static PFN_GETACTIVEPROCESSORCOUNT GetActiveProcessorCountProc;
146  typedef DWORD (WINAPI *PFN_GETCURRENTPROCESSORNUMBER)(void);
147  static PFN_GETCURRENTPROCESSORNUMBER GetCurrentProcessorNumberProc;
148  typedef VOID (WINAPI *PFN_GETCURRENTPROCESSORNUMBEREX)(PPROCESSOR_NUMBER);
149  static PFN_GETCURRENTPROCESSORNUMBEREX GetCurrentProcessorNumberExProc;
150  typedef BOOL (WINAPI *PFN_GETLOGICALPROCESSORINFORMATIONEX)(LOGICAL_PROCESSOR_RELATIONSHIP relationship, HWLOC_SYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX *Buffer, PDWORD ReturnLength);
151  static PFN_GETLOGICALPROCESSORINFORMATIONEX GetLogicalProcessorInformationExProc;
152  typedef BOOL (WINAPI *PFN_SETTHREADGROUPAFFINITY)(HANDLE hThread, const GROUP_AFFINITY *GroupAffinity, PGROUP_AFFINITY PreviousGroupAffinity);
153  static PFN_SETTHREADGROUPAFFINITY SetThreadGroupAffinityProc;
154  typedef BOOL (WINAPI *PFN_GETTHREADGROUPAFFINITY)(HANDLE hThread, PGROUP_AFFINITY GroupAffinity);
155  static PFN_GETTHREADGROUPAFFINITY GetThreadGroupAffinityProc;
156  typedef BOOL (WINAPI *PFN_GETNUMAAVAILABLEMEMORYNODE)(UCHAR Node, PULONGLONG AvailableBytes);
157  static PFN_GETNUMAAVAILABLEMEMORYNODE GetNumaAvailableMemoryNodeProc;
158  typedef BOOL (WINAPI *PFN_GETNUMAAVAILABLEMEMORYNODEEX)(USHORT Node, PULONGLONG AvailableBytes);
159  static PFN_GETNUMAAVAILABLEMEMORYNODEEX GetNumaAvailableMemoryNodeExProc;
160  typedef LPVOID (WINAPI *PFN_VIRTUALALLOCEXNUMA)(HANDLE hProcess, LPVOID lpAddress, SIZE_T dwSize, DWORD flAllocationType, DWORD flProtect, DWORD nndPreferred);
161  static PFN_VIRTUALALLOCEXNUMA VirtualAllocExNumaProc;
162  typedef BOOL (WINAPI *PFN_VIRTUALFREEEX)(HANDLE hProcess, LPVOID lpAddress, SIZE_T dwSize, DWORD dwFreeType);
163  static PFN_VIRTUALFREEEX VirtualFreeExProc;
164  typedef BOOL (WINAPI *PFN_QUERYWORKINGSETEX)(HANDLE hProcess, PVOID pv, DWORD cb);
165  static PFN_QUERYWORKINGSETEX QueryWorkingSetExProc;
166  typedef NTSTATUS (WINAPI *PFN_RTLGETVERSION)(OSVERSIONINFOEX*);
167  PFN_RTLGETVERSION RtlGetVersionProc;
168  static void hwloc_win_get_function_ptrs(void)
169  {
170    HMODULE kernel32, ntdll;
171  #if HWLOC_HAVE_GCC_W_CAST_FUNCTION_TYPE
172  #pragma GCC diagnostic ignored "-Wcast-function-type"
173  #endif
174      kernel32 = LoadLibrary("kernel32.dll");
175      if (kernel32) {
176        GetActiveProcessorGroupCountProc =
177  	(PFN_GETACTIVEPROCESSORGROUPCOUNT) GetProcAddress(kernel32, "GetActiveProcessorGroupCount");
178        GetActiveProcessorCountProc =
179  	(PFN_GETACTIVEPROCESSORCOUNT) GetProcAddress(kernel32, "GetActiveProcessorCount");
180        GetCurrentProcessorNumberProc =
181  	(PFN_GETCURRENTPROCESSORNUMBER) GetProcAddress(kernel32, "GetCurrentProcessorNumber");
182        GetCurrentProcessorNumberExProc =
183  	(PFN_GETCURRENTPROCESSORNUMBEREX) GetProcAddress(kernel32, "GetCurrentProcessorNumberEx");
184        SetThreadGroupAffinityProc =
185  	(PFN_SETTHREADGROUPAFFINITY) GetProcAddress(kernel32, "SetThreadGroupAffinity");
186        GetThreadGroupAffinityProc =
187  	(PFN_GETTHREADGROUPAFFINITY) GetProcAddress(kernel32, "GetThreadGroupAffinity");
188        GetNumaAvailableMemoryNodeProc =
189  	(PFN_GETNUMAAVAILABLEMEMORYNODE) GetProcAddress(kernel32, "GetNumaAvailableMemoryNode");
190        GetNumaAvailableMemoryNodeExProc =
191  	(PFN_GETNUMAAVAILABLEMEMORYNODEEX) GetProcAddress(kernel32, "GetNumaAvailableMemoryNodeEx");
192        GetLogicalProcessorInformationExProc =
193  	(PFN_GETLOGICALPROCESSORINFORMATIONEX)GetProcAddress(kernel32, "GetLogicalProcessorInformationEx");
194        QueryWorkingSetExProc =
195  	(PFN_QUERYWORKINGSETEX) GetProcAddress(kernel32, "K32QueryWorkingSetEx");
196        VirtualAllocExNumaProc =
197  	(PFN_VIRTUALALLOCEXNUMA) GetProcAddress(kernel32, "VirtualAllocExNuma");
198        VirtualFreeExProc =
199  	(PFN_VIRTUALFREEEX) GetProcAddress(kernel32, "VirtualFreeEx");
200      }
201      if (!QueryWorkingSetExProc) {
202        HMODULE psapi = LoadLibrary("psapi.dll");
203        if (psapi)
204          QueryWorkingSetExProc = (PFN_QUERYWORKINGSETEX) GetProcAddress(psapi, "QueryWorkingSetEx");
205      }
206      ntdll = GetModuleHandle("ntdll");
207      RtlGetVersionProc = (PFN_RTLGETVERSION) GetProcAddress(ntdll, "RtlGetVersion");
208  #if HWLOC_HAVE_GCC_W_CAST_FUNCTION_TYPE
209  #pragma GCC diagnostic warning "-Wcast-function-type"
210  #endif
211  }
212  static void hwloc_bitmap_from_ULONG_PTR(hwloc_bitmap_t set, ULONG_PTR mask)
213  {
214  #if SIZEOF_VOID_P == 8
215    hwloc_bitmap_from_ulong(set, mask & 0xffffffff);
216    hwloc_bitmap_set_ith_ulong(set, 1, mask >> 32);
217  #else
218    hwloc_bitmap_from_ulong(set, mask);
219  #endif
220  }
221  static void hwloc_bitmap_from_ith_ULONG_PTR(hwloc_bitmap_t set, unsigned i, ULONG_PTR mask)
222  {
223  #if SIZEOF_VOID_P == 8
224    hwloc_bitmap_from_ith_ulong(set, 2*i, mask & 0xffffffff);
225    hwloc_bitmap_set_ith_ulong(set, 2*i+1, mask >> 32);
226  #else
227    hwloc_bitmap_from_ith_ulong(set, i, mask);
228  #endif
229  }
230  static void hwloc_bitmap_set_ith_ULONG_PTR(hwloc_bitmap_t set, unsigned i, ULONG_PTR mask)
231  {
232  #if SIZEOF_VOID_P == 8
233    hwloc_bitmap_set_ith_ulong(set, 2*i, mask & 0xffffffff);
234    hwloc_bitmap_set_ith_ulong(set, 2*i+1, mask >> 32);
235  #else
236    hwloc_bitmap_set_ith_ulong(set, i, mask);
237  #endif
238  }
239  static ULONG_PTR hwloc_bitmap_to_ULONG_PTR(hwloc_const_bitmap_t set)
240  {
241  #if SIZEOF_VOID_P == 8
242    ULONG_PTR up = hwloc_bitmap_to_ith_ulong(set, 1);
243    up <<= 32;
244    up |= hwloc_bitmap_to_ulong(set);
245    return up;
246  #else
247    return hwloc_bitmap_to_ulong(set);
248  #endif
249  }
250  static ULONG_PTR hwloc_bitmap_to_ith_ULONG_PTR(hwloc_const_bitmap_t set, unsigned i)
251  {
252  #if SIZEOF_VOID_P == 8
253    ULONG_PTR up = hwloc_bitmap_to_ith_ulong(set, 2*i+1);
254    up <<= 32;
255    up |= hwloc_bitmap_to_ith_ulong(set, 2*i);
256    return up;
257  #else
258    return hwloc_bitmap_to_ith_ulong(set, i);
259  #endif
260  }
261  static int hwloc_bitmap_to_single_ULONG_PTR(hwloc_const_bitmap_t set, unsigned *index, ULONG_PTR *mask)
262  {
263    unsigned first_ulp, last_ulp;
264    if (hwloc_bitmap_weight(set) == -1)
265      return -1;
266    first_ulp = hwloc_bitmap_first(set) / (sizeof(ULONG_PTR)*8);
267    last_ulp = hwloc_bitmap_last(set) / (sizeof(ULONG_PTR)*8);
268    if (first_ulp != last_ulp)
269      return -1;
270    *mask = hwloc_bitmap_to_ith_ULONG_PTR(set, first_ulp);
271    *index = first_ulp;
272    return 0;
273  }
274  static unsigned long max_numanode_index = 0;
275  static unsigned long nr_processor_groups = 1;
276  static hwloc_cpuset_t * processor_group_cpusets = NULL;
277  static void
278  hwloc_win_get_processor_groups(void)
279  {
280    HWLOC_SYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX *procInfoTotal, *tmpprocInfoTotal, *procInfo;
281    DWORD length;
282    unsigned i;
283    hwloc_debug("querying windows processor groups\n");
284    if (!GetLogicalProcessorInformationExProc)
285      goto error;
286    nr_processor_groups = GetActiveProcessorGroupCountProc();
287    if (!nr_processor_groups)
288      goto error;
289    hwloc_debug("found %lu windows processor groups\n", nr_processor_groups);
290    if (nr_processor_groups > 1 && SIZEOF_VOID_P == 4) {
291      if (HWLOC_SHOW_ALL_ERRORS())
292        fprintf(stderr, "hwloc: multiple processor groups found on 32bits Windows, topology may be invalid/incomplete.\n");
293    }
294    length = 0;
295    procInfoTotal = NULL;
296    while (1) {
297      if (GetLogicalProcessorInformationExProc(RelationGroup, procInfoTotal, &length))
298        break;
299      if (GetLastError() != ERROR_INSUFFICIENT_BUFFER)
300        goto error;
301      tmpprocInfoTotal = realloc(procInfoTotal, length);
302      if (!tmpprocInfoTotal)
303        goto error_with_procinfo;
304      procInfoTotal = tmpprocInfoTotal;
305    }
306    processor_group_cpusets = calloc(nr_processor_groups, sizeof(*processor_group_cpusets));
307    if (!processor_group_cpusets)
308      goto error_with_procinfo;
309    for (procInfo = procInfoTotal;
310         (void*) procInfo < (void*) ((uintptr_t) procInfoTotal + length);
311         procInfo = (void*) ((uintptr_t) procInfo + procInfo->Size)) {
312      unsigned id;
313      assert(procInfo->Relationship == RelationGroup);
314      hwloc_debug("Found %u active windows processor groups\n",
315                  (unsigned) procInfo->Group.ActiveGroupCount);
316      for (id = 0; id < procInfo->Group.ActiveGroupCount; id++) {
317        KAFFINITY mask;
318        hwloc_bitmap_t set;
319        set = hwloc_bitmap_alloc();
320        if (!set)
321          goto error_with_cpusets;
322        mask = procInfo->Group.GroupInfo[id].ActiveProcessorMask;
323        hwloc_debug("group %u with %u cpus mask 0x%llx\n", id,
324                    (unsigned) procInfo->Group.GroupInfo[id].ActiveProcessorCount, (unsigned long long) mask);
325        hwloc_bitmap_set_ith_ULONG_PTR(set, id, mask);
326        hwloc_debug_2args_bitmap("group %u %d bitmap %s\n", id, procInfo->Group.GroupInfo[id].ActiveProcessorCount, set);
327        processor_group_cpusets[id] = set;
328      }
329    }
330    free(procInfoTotal);
331    return;
332   error_with_cpusets:
333    for(i=0; i<nr_processor_groups; i++) {
334      if (processor_group_cpusets[i])
335        hwloc_bitmap_free(processor_group_cpusets[i]);
336    }
337    free(processor_group_cpusets);
338    processor_group_cpusets = NULL;
339   error_with_procinfo:
340    free(procInfoTotal);
341   error:
342    nr_processor_groups = 1;
343  }
344  static void
345  hwloc_win_free_processor_groups(void)
346  {
347    unsigned i;
348    for(i=0; i<nr_processor_groups; i++) {
349      if (processor_group_cpusets[i])
350        hwloc_bitmap_free(processor_group_cpusets[i]);
351    }
352    free(processor_group_cpusets);
353    processor_group_cpusets = NULL;
354    nr_processor_groups = 1;
355  }
356  int
357  hwloc_windows_get_nr_processor_groups(hwloc_topology_t topology, unsigned long flags)
358  {
359    if (!topology->is_loaded || !topology->is_thissystem) {
360      errno = EINVAL;
361      return -1;
362    }
363    if (flags) {
364      errno = EINVAL;
365      return -1;
366    }
367    return nr_processor_groups;
368  }
369  int
370  hwloc_windows_get_processor_group_cpuset(hwloc_topology_t topology, unsigned pg_index, hwloc_cpuset_t cpuset, unsigned long flags)
371  {
372    if (!topology->is_loaded || !topology->is_thissystem) {
373      errno = EINVAL;
374      return -1;
375    }
376    if (!cpuset) {
377      errno = EINVAL;
378      return -1;
379    }
380    if (flags) {
381      errno = EINVAL;
382      return -1;
383    }
384    if (pg_index >= nr_processor_groups) {
385      errno = ENOENT;
386      return -1;
387    }
388    if (!processor_group_cpusets) {
389      assert(nr_processor_groups == 1);
390      hwloc_bitmap_copy(cpuset, topology->levels[0][0]->cpuset);
391      return 0;
392    }
393    if (!processor_group_cpusets[pg_index]) {
394      errno = ENOENT;
395      return -1;
396    }
397    hwloc_bitmap_copy(cpuset, processor_group_cpusets[pg_index]);
398    return 0;
399  }
400  static int
401  hwloc_win_get_thisthread_last_cpu_location(hwloc_topology_t topology __hwloc_attribute_unused, hwloc_cpuset_t set, int flags __hwloc_attribute_unused)
402  {
403    assert(GetCurrentProcessorNumberExProc || (GetCurrentProcessorNumberProc && nr_processor_groups == 1));
404    if (nr_processor_groups > 1 || !GetCurrentProcessorNumberProc) {
405      PROCESSOR_NUMBER num;
406      GetCurrentProcessorNumberExProc(&num);
407      hwloc_bitmap_from_ith_ULONG_PTR(set, num.Group, ((ULONG_PTR)1) << num.Number);
408      return 0;
409    }
410    hwloc_bitmap_from_ith_ULONG_PTR(set, 0, ((ULONG_PTR)1) << GetCurrentProcessorNumberProc());
411    return 0;
412  }
413  static int
414  hwloc_win_set_thread_cpubind(hwloc_topology_t topology __hwloc_attribute_unused, hwloc_thread_t thread, hwloc_const_bitmap_t hwloc_set, int flags)
415  {
416    DWORD_PTR mask;
417    unsigned group;
418    if (flags & HWLOC_CPUBIND_NOMEMBIND) {
419      errno = ENOSYS;
420      return -1;
421    }
422    if (hwloc_bitmap_to_single_ULONG_PTR(hwloc_set, &group, &mask) < 0) {
423      errno = ENOSYS;
424      return -1;
425    }
426    assert(nr_processor_groups == 1 || SetThreadGroupAffinityProc);
427    if (nr_processor_groups > 1) {
428      GROUP_AFFINITY aff;
429      memset(&aff, 0, sizeof(aff)); &bsol;* we get Invalid Parameter error if Reserved field isn't cleared */
430      aff.Group = group;
431      aff.Mask = mask;
432      if (!SetThreadGroupAffinityProc(thread, &aff, NULL))
433        return -1;
434    } else {
435      if (!SetThreadAffinityMask(thread, mask))
436        return -1;
437    }
438    return 0;
439  }
440  static int
441  hwloc_win_set_thisthread_cpubind(hwloc_topology_t topology, hwloc_const_bitmap_t hwloc_set, int flags)
442  {
443    return hwloc_win_set_thread_cpubind(topology, GetCurrentThread(), hwloc_set, flags);
444  }
445  static int
446  hwloc_win_set_thisthread_membind(hwloc_topology_t topology, hwloc_const_nodeset_t nodeset, hwloc_membind_policy_t policy, int flags)
447  {
448    int ret;
449    hwloc_const_cpuset_t cpuset;
450    hwloc_cpuset_t _cpuset = NULL;
451    if ((policy != HWLOC_MEMBIND_DEFAULT && policy != HWLOC_MEMBIND_BIND)
452        || flags & HWLOC_MEMBIND_NOCPUBIND) {
453      errno = ENOSYS;
454      return -1;
455    }
456    if (policy == HWLOC_MEMBIND_DEFAULT) {
457      cpuset = hwloc_topology_get_complete_cpuset(topology);
458    } else {
459      cpuset = _cpuset = hwloc_bitmap_alloc();
460      hwloc_cpuset_from_nodeset(topology, _cpuset, nodeset);
461    }
462    ret = hwloc_win_set_thisthread_cpubind(topology, cpuset,
463  					 (flags & HWLOC_MEMBIND_STRICT) ? HWLOC_CPUBIND_STRICT : 0);
464    hwloc_bitmap_free(_cpuset);
465    return ret;
466  }
467  static int
468  hwloc_win_get_thread_cpubind(hwloc_topology_t topology __hwloc_attribute_unused, hwloc_thread_t thread, hwloc_cpuset_t set, int flags __hwloc_attribute_unused)
469  {
470    GROUP_AFFINITY aff;
471    assert(GetThreadGroupAffinityProc);
472    if (!GetThreadGroupAffinityProc(thread, &aff))
473      return -1;
474    hwloc_bitmap_from_ith_ULONG_PTR(set, aff.Group, aff.Mask);
475    return 0;
476  }
477  static int
478  hwloc_win_get_thisthread_cpubind(hwloc_topology_t topology __hwloc_attribute_unused, hwloc_cpuset_t set, int flags __hwloc_attribute_unused)
479  {
480    return hwloc_win_get_thread_cpubind(topology, GetCurrentThread(), set, flags);
481  }
482  static int
483  hwloc_win_get_thisthread_membind(hwloc_topology_t topology, hwloc_nodeset_t nodeset, hwloc_membind_policy_t * policy, int flags)
484  {
485    int ret;
486    hwloc_cpuset_t cpuset = hwloc_bitmap_alloc();
487    ret = hwloc_win_get_thread_cpubind(topology, GetCurrentThread(), cpuset, flags);
488    if (!ret) {
489      *policy = HWLOC_MEMBIND_BIND;
490      hwloc_cpuset_to_nodeset(topology, cpuset, nodeset);
491    }
492    hwloc_bitmap_free(cpuset);
493    return ret;
494  }
495  static int
496  hwloc_win_set_proc_cpubind(hwloc_topology_t topology __hwloc_attribute_unused, hwloc_pid_t proc, hwloc_const_bitmap_t hwloc_set, int flags)
497  {
498    DWORD_PTR mask;
499    assert(nr_processor_groups == 1);
500    if (flags & HWLOC_CPUBIND_NOMEMBIND) {
501      errno = ENOSYS;
502      return -1;
503    }
504    mask = hwloc_bitmap_to_ULONG_PTR(hwloc_set);
505    if (!SetProcessAffinityMask(proc, mask))
506      return -1;
507    return 0;
508  }
509  static int
510  hwloc_win_set_thisproc_cpubind(hwloc_topology_t topology, hwloc_const_bitmap_t hwloc_set, int flags)
511  {
512    return hwloc_win_set_proc_cpubind(topology, GetCurrentProcess(), hwloc_set, flags);
513  }
514  static int
515  hwloc_win_set_proc_membind(hwloc_topology_t topology, hwloc_pid_t pid, hwloc_const_nodeset_t nodeset, hwloc_membind_policy_t policy, int flags)
516  {
517    int ret;
518    hwloc_const_cpuset_t cpuset;
519    hwloc_cpuset_t _cpuset = NULL;
520    if ((policy != HWLOC_MEMBIND_DEFAULT && policy != HWLOC_MEMBIND_BIND)
521        || flags & HWLOC_MEMBIND_NOCPUBIND) {
522      errno = ENOSYS;
523      return -1;
524    }
525    if (policy == HWLOC_MEMBIND_DEFAULT) {
526      cpuset = hwloc_topology_get_complete_cpuset(topology);
527    } else {
528      cpuset = _cpuset = hwloc_bitmap_alloc();
529      hwloc_cpuset_from_nodeset(topology, _cpuset, nodeset);
530    }
531    ret = hwloc_win_set_proc_cpubind(topology, pid, cpuset,
532  				   (flags & HWLOC_MEMBIND_STRICT) ? HWLOC_CPUBIND_STRICT : 0);
533    hwloc_bitmap_free(_cpuset);
534    return ret;
535  }
536  static int
537  hwloc_win_set_thisproc_membind(hwloc_topology_t topology, hwloc_const_nodeset_t nodeset, hwloc_membind_policy_t policy, int flags)
538  {
539    return hwloc_win_set_proc_membind(topology, GetCurrentProcess(), nodeset, policy, flags);
540  }
541  static int
542  hwloc_win_get_proc_cpubind(hwloc_topology_t topology __hwloc_attribute_unused, hwloc_pid_t proc, hwloc_bitmap_t hwloc_set, int flags)
543  {
544    DWORD_PTR proc_mask, sys_mask;
545    assert(nr_processor_groups == 1);
546    if (flags & HWLOC_CPUBIND_NOMEMBIND) {
547      errno = ENOSYS;
548      return -1;
549    }
550    if (!GetProcessAffinityMask(proc, &proc_mask, &sys_mask))
551      return -1;
552    hwloc_bitmap_from_ULONG_PTR(hwloc_set, proc_mask);
553    return 0;
554  }
555  static int
556  hwloc_win_get_proc_membind(hwloc_topology_t topology, hwloc_pid_t pid, hwloc_nodeset_t nodeset, hwloc_membind_policy_t * policy, int flags)
557  {
558    int ret;
559    hwloc_cpuset_t cpuset = hwloc_bitmap_alloc();
560    ret = hwloc_win_get_proc_cpubind(topology, pid, cpuset,
561  				   (flags & HWLOC_MEMBIND_STRICT) ? HWLOC_CPUBIND_STRICT : 0);
562    if (!ret) {
563      *policy = HWLOC_MEMBIND_BIND;
564      hwloc_cpuset_to_nodeset(topology, cpuset, nodeset);
565    }
566    hwloc_bitmap_free(cpuset);
567    return ret;
568  }
569  static int
570  hwloc_win_get_thisproc_cpubind(hwloc_topology_t topology, hwloc_bitmap_t hwloc_cpuset, int flags)
571  {
572    return hwloc_win_get_proc_cpubind(topology, GetCurrentProcess(), hwloc_cpuset, flags);
573  }
574  static int
575  hwloc_win_get_thisproc_membind(hwloc_topology_t topology, hwloc_nodeset_t nodeset, hwloc_membind_policy_t * policy, int flags)
576  {
577    return hwloc_win_get_proc_membind(topology, GetCurrentProcess(), nodeset, policy, flags);
578  }
579  static void *
580  hwloc_win_alloc(hwloc_topology_t topology __hwloc_attribute_unused, size_t len) {
581    return VirtualAlloc(NULL, len, MEM_COMMIT|MEM_RESERVE, PAGE_EXECUTE_READWRITE);
582  }
583  static void *
584  hwloc_win_alloc_membind(hwloc_topology_t topology __hwloc_attribute_unused, size_t len, hwloc_const_nodeset_t nodeset, hwloc_membind_policy_t policy, int flags) {
585    int node;
586    switch (policy) {
587      case HWLOC_MEMBIND_DEFAULT:
588      case HWLOC_MEMBIND_BIND:
589        break;
590      default:
591        errno = ENOSYS;
592        return hwloc_alloc_or_fail(topology, len, flags);
593    }
594    if (flags & HWLOC_MEMBIND_STRICT) {
595      errno = ENOSYS;
596      return NULL;
597    }
598    if (policy == HWLOC_MEMBIND_DEFAULT
599        || hwloc_bitmap_isequal(nodeset, hwloc_topology_get_complete_nodeset(topology)))
600      return hwloc_win_alloc(topology, len);
601    if (hwloc_bitmap_weight(nodeset) != 1) {
602      errno = EXDEV;
603      return hwloc_alloc_or_fail(topology, len, flags);
604    }
605    node = hwloc_bitmap_first(nodeset);
606    return VirtualAllocExNumaProc(GetCurrentProcess(), NULL, len, MEM_COMMIT|MEM_RESERVE, PAGE_EXECUTE_READWRITE, node);
607  }
608  static int
609  hwloc_win_free_membind(hwloc_topology_t topology __hwloc_attribute_unused, void *addr, size_t len __hwloc_attribute_unused) {
610    if (!addr)
611      return 0;
612    if (!VirtualFreeExProc(GetCurrentProcess(), addr, 0, MEM_RELEASE))
613      return -1;
614    return 0;
<span onclick='openModal()' class='match'>615  }
616  static int
617  hwloc_win_get_area_memlocation(hwloc_topology_t topology __hwloc_attribute_unused, const void *addr, size_t len, hwloc_nodeset_t nodeset, int flags __hwloc_attribute_unused)
618  {
619    SYSTEM_INFO SystemInfo;
620    DWORD page_size;
621    uintptr_t start;
622    unsigned nb;
623    PSAPI_WORKING_SET_EX_INFORMATION *pv;
624    unsigned i;
</span>625    GetSystemInfo(&SystemInfo);
626    page_size = SystemInfo.dwPageSize;
627    start = (((uintptr_t) addr) / page_size) * page_size;
628    nb = (unsigned)((((uintptr_t) addr + len - start) + page_size - 1) / page_size);
629    if (!nb)
630      nb = 1;
631    pv = calloc(nb, sizeof(*pv));
632    if (!pv)
633      return -1;
634    for (i = 0; i < nb; i++)
635      pv[i].VirtualAddress = (void*) (start + i * page_size);
636    if (!QueryWorkingSetExProc(GetCurrentProcess(), pv, nb * sizeof(*pv))) {
637      free(pv);
638      return -1;
639    }
640    for (i = 0; i < nb; i++) {
641      if (pv[i].VirtualAttributes.Valid)
642        hwloc_bitmap_set(nodeset, pv[i].VirtualAttributes.Node);
643    }
644    free(pv);
645    return 0;
646  }
647  struct hwloc_win_efficiency_classes {
648    unsigned nr_classes;
649    unsigned nr_classes_allocated;
650    struct hwloc_win_efficiency_class {
651      unsigned value;
652      hwloc_bitmap_t cpuset;
653    } *classes;
654  };
655  static void
656  hwloc_win_efficiency_classes_init(struct hwloc_win_efficiency_classes *classes)
657  {
658    classes->classes = NULL;
659    classes->nr_classes_allocated = 0;
660    classes->nr_classes = 0;
661  }
662  static int
663  hwloc_win_efficiency_classes_add(struct hwloc_win_efficiency_classes *classes,
664                                   hwloc_const_bitmap_t cpuset,
665                                   unsigned value)
666  {
667    unsigned i;
668    for(i=0; i<classes->nr_classes; i++) {
669      if (classes->classes[i].value == value) {
670        hwloc_bitmap_or(classes->classes[i].cpuset, classes->classes[i].cpuset, cpuset);
671        return 0;
672      }
673    }
674    if (classes->nr_classes == classes->nr_classes_allocated) {
675      struct hwloc_win_efficiency_class *tmp;
676      unsigned new_nr_allocated = 2*classes->nr_classes_allocated;
677      if (!new_nr_allocated) {
678  #define HWLOC_WIN_EFFICIENCY_CLASSES_DEFAULT_MAX 4 &bsol;* 2 should be enough is most cases */
679        new_nr_allocated = HWLOC_WIN_EFFICIENCY_CLASSES_DEFAULT_MAX;
680      }
681      tmp = realloc(classes->classes, new_nr_allocated * sizeof(*classes->classes));
682      if (!tmp)
683        return -1;
684      classes->classes = tmp;
685      classes->nr_classes_allocated = new_nr_allocated;
686    }
687    classes->classes[classes->nr_classes].cpuset = hwloc_bitmap_alloc();
688    if (!classes->classes[classes->nr_classes].cpuset)
689      return -1;
690    classes->classes[classes->nr_classes].value = value;
691    hwloc_bitmap_copy(classes->classes[classes->nr_classes].cpuset, cpuset);
692    classes->nr_classes++;
693    return 0;
694  }
695  static void
696  hwloc_win_efficiency_classes_register(hwloc_topology_t topology,
697                                        struct hwloc_win_efficiency_classes *classes)
698  {
699    unsigned i;
700    for(i=0; i<classes->nr_classes; i++) {
701      hwloc_internal_cpukinds_register(topology, classes->classes[i].cpuset, classes->classes[i].value, NULL, 0, 0);
702      classes->classes[i].cpuset = NULL; &bsol;* given to cpukinds */
703    }
704  }
705  static void
706  hwloc_win_efficiency_classes_destroy(struct hwloc_win_efficiency_classes *classes)
707  {
708    unsigned i;
709    for(i=0; i<classes->nr_classes; i++)
710      hwloc_bitmap_free(classes->classes[i].cpuset);
711    free(classes->classes);
712  }
713  static int
714  hwloc_look_windows(struct hwloc_backend *backend, struct hwloc_disc_status *dstatus)
715  {
716    struct hwloc_topology *topology = backend->topology;
717    hwloc_bitmap_t groups_pu_set = NULL;
718    SYSTEM_INFO SystemInfo;
719    DWORD length;
720    int gotnuma = 0;
721    int gotnumamemory = 0;
722    OSVERSIONINFOEX osvi;
723    char versionstr[20];
724    char hostname[122] = "";
725    unsigned hostname_size = sizeof(hostname);
726    int has_efficiencyclass = 0;
727    struct hwloc_win_efficiency_classes eclasses;
728    char *env = getenv("HWLOC_WINDOWS_PROCESSOR_GROUP_OBJS");
729    int keep_pgroup_objs = (env && atoi(env));
730    assert(dstatus->phase == HWLOC_DISC_PHASE_CPU);
731    if (topology->levels[0][0]->cpuset)
732      return -1;
733    ZeroMemory(&osvi, sizeof(OSVERSIONINFOEX));
734    osvi.dwOSVersionInfoSize = sizeof(OSVERSIONINFOEX);
735    if (RtlGetVersionProc) {
736      RtlGetVersionProc(&osvi);
737    } else {
738      GetVersionEx((LPOSVERSIONINFO)&osvi);
739    }
740    if (osvi.dwMajorVersion >= 10) {
741      has_efficiencyclass = 1;
742      hwloc_win_efficiency_classes_init(&eclasses);
743    }
744    hwloc_alloc_root_sets(topology->levels[0][0]);
745    GetSystemInfo(&SystemInfo);
746    if (GetLogicalProcessorInformationExProc) {
747        HWLOC_SYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX *procInfoTotal, *tmpprocInfoTotal, *procInfo;
748        unsigned id;
749        struct hwloc_obj *obj;
750        hwloc_obj_type_t type;
751        length = 0;
752        procInfoTotal = NULL;
753        while (1) {
754  	if (GetLogicalProcessorInformationExProc(RelationAll, procInfoTotal, &length))
755  	  break;
756  	if (GetLastError() != ERROR_INSUFFICIENT_BUFFER)
757  	  return -1;
758          tmpprocInfoTotal = realloc(procInfoTotal, length);
759  	if (!tmpprocInfoTotal) {
760  	  free(procInfoTotal);
761  	  goto out;
762  	}
763  	procInfoTotal = tmpprocInfoTotal;
764        }
765        for (procInfo = procInfoTotal;
766  	   (void*) procInfo < (void*) ((uintptr_t) procInfoTotal + length);
767  	   procInfo = (void*) ((uintptr_t) procInfo + procInfo->Size)) {
768          unsigned num, i;
769          unsigned efficiency_class = 0;
770          GROUP_AFFINITY *GroupMask;
771  	if (procInfo->Relationship == RelationCache
772  		&& procInfo->Cache.Type != CacheUnified
773  		&& procInfo->Cache.Type != CacheData
774  		&& procInfo->Cache.Type != CacheInstruction)
775  	  continue;
776  	id = HWLOC_UNKNOWN_INDEX;
777  	switch (procInfo->Relationship) {
778  	  case RelationNumaNode:
779  	    type = HWLOC_OBJ_NUMANODE;
780              if (procInfo->NumaNode.GroupCount) {
781                num = procInfo->NumaNode.GroupCount;
782                GroupMask = procInfo->NumaNode.GroupMasks;
783              } else {
784                num = 1;
785                GroupMask = &procInfo->NumaNode.GroupMask;
786              }
787  	    id = procInfo->NumaNode.NodeNumber;
788  	    gotnuma++;
789  	    if (id > max_numanode_index)
790  	      max_numanode_index = id;
791  	    break;
792  	  case RelationProcessorPackage:
793  	    type = HWLOC_OBJ_PACKAGE;
794              num = procInfo->Processor.GroupCount;
795              GroupMask = procInfo->Processor.GroupMask;
796  	    break;
797  	  case RelationCache:
798  	    type = (procInfo->Cache.Type == CacheInstruction ? HWLOC_OBJ_L1ICACHE : HWLOC_OBJ_L1CACHE) + procInfo->Cache.Level - 1;
799              if (procInfo->Cache.GroupCount) {
800                num = procInfo->Cache.GroupCount;
801                GroupMask = procInfo->Cache.GroupMasks;
802              } else {
803                num = 1;
804                GroupMask = &procInfo->Cache.GroupMask;
805              }
806  	    break;
807  	  case RelationProcessorCore:
808  	    type = HWLOC_OBJ_CORE;
809              num = procInfo->Processor.GroupCount;
810              GroupMask = procInfo->Processor.GroupMask;
811              efficiency_class = procInfo->Processor.EfficiencyClass;
812  	    break;
813  	  case RelationGroup:
814  	    for (id = 0; id < procInfo->Group.ActiveGroupCount; id++) {
815                KAFFINITY mask;
816  	      hwloc_bitmap_t set;
817  	      set = hwloc_bitmap_alloc();
818  	      mask = procInfo->Group.GroupInfo[id].ActiveProcessorMask;
819  	      hwloc_debug("group %u %d cpus mask %lx\n", id,
820  			  procInfo->Group.GroupInfo[id].ActiveProcessorCount, mask);
821  	      hwloc_bitmap_set_ith_ULONG_PTR(set, id, mask);
822  	      hwloc_debug_2args_bitmap("group %u %d bitmap %s\n", id, procInfo->Group.GroupInfo[id].ActiveProcessorCount, set);
823  	      if (!groups_pu_set)
824  		groups_pu_set = hwloc_bitmap_alloc();
825  	      hwloc_bitmap_or(groups_pu_set, groups_pu_set, set);
826                if (keep_pgroup_objs && hwloc_filter_check_keep_object_type(topology, HWLOC_OBJ_GROUP)) {
827  		obj = hwloc_alloc_setup_object(topology, HWLOC_OBJ_GROUP, id);
828  		obj->cpuset = set;
829  		obj->attr->group.kind = HWLOC_GROUP_KIND_WINDOWS_PROCESSOR_GROUP;
830  		hwloc__insert_object_by_cpuset(topology, NULL, obj, "windows:GetLogicalProcessorInformationEx:ProcessorGroup");
831  	      } else
832  		hwloc_bitmap_free(set);
833  	    }
834  	    continue;
835  	  default:
836              hwloc_debug("unknown relation %d\n", procInfo->Relationship);
837  	    continue;
838  	}
839  	if (!hwloc_filter_check_keep_object_type(topology, type))
840  	  continue;
841  	obj = hwloc_alloc_setup_object(topology, type, id);
842          obj->cpuset = hwloc_bitmap_alloc();
843          for (i = 0; i < num; i++) {
844            hwloc_debug("%s#%u %d: mask %d:%lx\n", hwloc_obj_type_string(type), id, i, GroupMask[i].Group, GroupMask[i].Mask);
845  	  hwloc_bitmap_set_ith_ULONG_PTR(obj->cpuset, GroupMask[i].Group, GroupMask[i].Mask);
846          }
847  	hwloc_debug_2args_bitmap("%s#%u bitmap %s\n", hwloc_obj_type_string(type), id, obj->cpuset);
848  	switch (type) {
849          case HWLOC_OBJ_CORE: {
850            if (has_efficiencyclass)
851              hwloc_win_efficiency_classes_add(&eclasses, obj->cpuset, efficiency_class);
852            break;
853          }
854  	  case HWLOC_OBJ_NUMANODE:
855  	    {
856  	      ULONGLONG avail;
857  	      obj->nodeset = hwloc_bitmap_alloc();
858  	      hwloc_bitmap_set(obj->nodeset, id);
859  	      if ((GetNumaAvailableMemoryNodeExProc && GetNumaAvailableMemoryNodeExProc(id, &avail))
860  		  || (GetNumaAvailableMemoryNodeProc && GetNumaAvailableMemoryNodeProc(id, &avail))) {
861  	        obj->attr->numanode.local_memory = avail;
862  		gotnumamemory++;
863  	      }
864  	      obj->attr->numanode.page_types = malloc(2 * sizeof(*obj->attr->numanode.page_types));
865  	      memset(obj->attr->numanode.page_types, 0, 2 * sizeof(*obj->attr->numanode.page_types));
866  	      obj->attr->numanode.page_types_len = 1;
867  	      obj->attr->numanode.page_types[0].size = SystemInfo.dwPageSize;
868  #if HAVE_DECL__SC_LARGE_PAGESIZE
869  	      obj->attr->numanode.page_types_len++;
870  	      obj->attr->numanode.page_types[1].size = sysconf(_SC_LARGE_PAGESIZE);
871  #endif
872  	      break;
873  	    }
874  	  case HWLOC_OBJ_L1CACHE:
875  	  case HWLOC_OBJ_L2CACHE:
876  	  case HWLOC_OBJ_L3CACHE:
877  	  case HWLOC_OBJ_L4CACHE:
878  	  case HWLOC_OBJ_L5CACHE:
879  	  case HWLOC_OBJ_L1ICACHE:
880  	  case HWLOC_OBJ_L2ICACHE:
881  	  case HWLOC_OBJ_L3ICACHE:
882  	    obj->attr->cache.size = procInfo->Cache.CacheSize;
883  	    obj->attr->cache.associativity = procInfo->Cache.Associativity == CACHE_FULLY_ASSOCIATIVE ? -1 : procInfo->Cache.Associativity ;
884  	    obj->attr->cache.linesize = procInfo->Cache.LineSize;
885  	    obj->attr->cache.depth = procInfo->Cache.Level;
886  	    switch (procInfo->Cache.Type) {
887  	      case CacheUnified:
888  		obj->attr->cache.type = HWLOC_OBJ_CACHE_UNIFIED;
889  		break;
890  	      case CacheData:
891  		obj->attr->cache.type = HWLOC_OBJ_CACHE_DATA;
892  		break;
893  	      case CacheInstruction:
894  		obj->attr->cache.type = HWLOC_OBJ_CACHE_INSTRUCTION;
895  		break;
896  	      default:
897  		hwloc_free_unlinked_object(obj);
898  		continue;
899  	    }
900  	    break;
901  	  default:
902  	    break;
903  	}
904  	hwloc__insert_object_by_cpuset(topology, NULL, obj, "windows:GetLogicalProcessorInformationEx");
905        }
906        free(procInfoTotal);
907    }
908    topology->support.discovery->pu = 1;
909    topology->support.discovery->numa = gotnuma;
910    topology->support.discovery->numa_memory = gotnumamemory;
911    if (groups_pu_set) {
912      hwloc_obj_t obj;
913      unsigned idx;
914      hwloc_bitmap_foreach_begin(idx, groups_pu_set) {
915        obj = hwloc_alloc_setup_object(topology, HWLOC_OBJ_PU, idx);
916        obj->cpuset = hwloc_bitmap_alloc();
917        hwloc_bitmap_only(obj->cpuset, idx);
918        hwloc_debug_1arg_bitmap("cpu %u has cpuset %s\n",
919  			      idx, obj->cpuset);
920        hwloc__insert_object_by_cpuset(topology, NULL, obj, "windows:ProcessorGroup:pu");
921      } hwloc_bitmap_foreach_end();
922      hwloc_bitmap_free(groups_pu_set);
923    } else {
924      hwloc_obj_t obj;
925      unsigned idx;
926      for(idx=0; idx<32; idx++)
927        if (SystemInfo.dwActiveProcessorMask & (((DWORD_PTR)1)<<idx)) {
928  	obj = hwloc_alloc_setup_object(topology, HWLOC_OBJ_PU, idx);
929  	obj->cpuset = hwloc_bitmap_alloc();
930  	hwloc_bitmap_only(obj->cpuset, idx);
931  	hwloc_debug_1arg_bitmap("cpu %u has cpuset %s\n",
932  				idx, obj->cpuset);
933  	hwloc__insert_object_by_cpuset(topology, NULL, obj, "windows:pu");
934        }
935    }
936    if (has_efficiencyclass) {
937      topology->support.discovery->cpukind_efficiency = 1;
938      hwloc_win_efficiency_classes_register(topology, &eclasses);
939    }
940   out:
941    if (has_efficiencyclass)
942      hwloc_win_efficiency_classes_destroy(&eclasses);
943    hwloc_obj_add_info(topology->levels[0][0], "Backend", "Windows");
944    hwloc_obj_add_info(topology->levels[0][0], "OSName", "Windows");
945  #if defined(__CYGWIN__)
946    hwloc_obj_add_info(topology->levels[0][0], "WindowsBuildEnvironment", "Cygwin");
947  #elif defined(__MINGW32__)
948    hwloc_obj_add_info(topology->levels[0][0], "WindowsBuildEnvironment", "MinGW");
949  #endif
950    if (osvi.dwMajorVersion == 10) {
951      if (osvi.dwMinorVersion == 0)
952        hwloc_obj_add_info(topology->levels[0][0], "OSRelease", "10");
953    } else if (osvi.dwMajorVersion == 6) {
954      if (osvi.dwMinorVersion == 3)
955        hwloc_obj_add_info(topology->levels[0][0], "OSRelease", "8.1"); &bsol;* or "Server 2012 R2" */
956      else if (osvi.dwMinorVersion == 2)
957        hwloc_obj_add_info(topology->levels[0][0], "OSRelease", "8"); &bsol;* or "Server 2012" */
958      else if (osvi.dwMinorVersion == 1)
959        hwloc_obj_add_info(topology->levels[0][0], "OSRelease", "7"); &bsol;* or "Server 2008 R2" */
960      else if (osvi.dwMinorVersion == 0)
961        hwloc_obj_add_info(topology->levels[0][0], "OSRelease", "Vista"); &bsol;* or "Server 2008" */
962    } &bsol;* earlier versions are ignored */
963    snprintf(versionstr, sizeof(versionstr), "%u.%u.%u", osvi.dwMajorVersion, osvi.dwMinorVersion, osvi.dwBuildNumber);
964    hwloc_obj_add_info(topology->levels[0][0], "OSVersion", versionstr);
965  #if !defined(__CYGWIN__)
966    GetComputerName(hostname, &hostname_size);
967  #else
968    gethostname(hostname, hostname_size);
969  #endif
970    if (*hostname)
971      hwloc_obj_add_info(topology->levels[0][0], "Hostname", hostname);
972    switch (SystemInfo.wProcessorArchitecture) {
973    case 0:
974      hwloc_obj_add_info(topology->levels[0][0], "Architecture", "i686");
975      break;
976    case 9:
977      hwloc_obj_add_info(topology->levels[0][0], "Architecture", "x86_64");
978      break;
979    case 5:
980      hwloc_obj_add_info(topology->levels[0][0], "Architecture", "arm");
981      break;
982    case 12:
983      hwloc_obj_add_info(topology->levels[0][0], "Architecture", "arm64");
984      break;
985    case 6:
986      hwloc_obj_add_info(topology->levels[0][0], "Architecture", "ia64");
987      break;
988    }
989    return 0;
990  }
991  void
992  hwloc_set_windows_hooks(struct hwloc_binding_hooks *hooks,
993  			struct hwloc_topology_support *support)
994  {
995    if (GetCurrentProcessorNumberExProc || (GetCurrentProcessorNumberProc && nr_processor_groups == 1))
996      hooks->get_thisthread_last_cpu_location = hwloc_win_get_thisthread_last_cpu_location;
997    if (nr_processor_groups == 1) {
998      hooks->set_proc_cpubind = hwloc_win_set_proc_cpubind;
999      hooks->get_proc_cpubind = hwloc_win_get_proc_cpubind;
1000      hooks->set_thisproc_cpubind = hwloc_win_set_thisproc_cpubind;
1001      hooks->get_thisproc_cpubind = hwloc_win_get_thisproc_cpubind;
1002      hooks->set_proc_membind = hwloc_win_set_proc_membind;
1003      hooks->get_proc_membind = hwloc_win_get_proc_membind;
1004      hooks->set_thisproc_membind = hwloc_win_set_thisproc_membind;
1005      hooks->get_thisproc_membind = hwloc_win_get_thisproc_membind;
1006    }
1007    if (nr_processor_groups == 1 || SetThreadGroupAffinityProc) {
1008      hooks->set_thread_cpubind = hwloc_win_set_thread_cpubind;
1009      hooks->set_thisthread_cpubind = hwloc_win_set_thisthread_cpubind;
1010      hooks->set_thisthread_membind = hwloc_win_set_thisthread_membind;
1011    }
1012    if (GetThreadGroupAffinityProc) {
1013      hooks->get_thread_cpubind = hwloc_win_get_thread_cpubind;
1014      hooks->get_thisthread_cpubind = hwloc_win_get_thisthread_cpubind;
1015      hooks->get_thisthread_membind = hwloc_win_get_thisthread_membind;
1016    }
1017    if (VirtualAllocExNumaProc) {
1018      hooks->alloc_membind = hwloc_win_alloc_membind;
1019      hooks->alloc = hwloc_win_alloc;
1020      hooks->free_membind = hwloc_win_free_membind;
1021      support->membind->bind_membind = 1;
1022    }
1023    if (QueryWorkingSetExProc && max_numanode_index <= 63 &bsol;* PSAPI_WORKING_SET_EX_BLOCK.Node is 6 bits only */)
1024      hooks->get_area_memlocation = hwloc_win_get_area_memlocation;
1025  }
1026  static int hwloc_windows_component_init(unsigned long flags __hwloc_attribute_unused)
1027  {
1028    hwloc_win_get_function_ptrs();
1029    hwloc_win_get_processor_groups();
1030    return 0;
1031  }
1032  static void hwloc_windows_component_finalize(unsigned long flags __hwloc_attribute_unused)
1033  {
1034    hwloc_win_free_processor_groups();
1035  }
1036  static struct hwloc_backend *
1037  hwloc_windows_component_instantiate(struct hwloc_topology *topology,
1038  				    struct hwloc_disc_component *component,
1039  				    unsigned excluded_phases __hwloc_attribute_unused,
1040  				    const void *_data1 __hwloc_attribute_unused,
1041  				    const void *_data2 __hwloc_attribute_unused,
1042  				    const void *_data3 __hwloc_attribute_unused)
1043  {
1044    struct hwloc_backend *backend;
1045    backend = hwloc_backend_alloc(topology, component);
1046    if (!backend)
1047      return NULL;
1048    backend->discover = hwloc_look_windows;
1049    return backend;
1050  }
1051  static struct hwloc_disc_component hwloc_windows_disc_component = {
1052    "windows",
1053    HWLOC_DISC_PHASE_CPU,
1054    HWLOC_DISC_PHASE_GLOBAL,
1055    hwloc_windows_component_instantiate,
1056    50,
1057    1,
1058    NULL
1059  };
1060  const struct hwloc_component hwloc_windows_component = {
1061    HWLOC_COMPONENT_ABI,
1062    hwloc_windows_component_init, hwloc_windows_component_finalize,
1063    HWLOC_COMPONENT_TYPE_DISC,
1064    0,
1065    &hwloc_windows_disc_component
1066  };
1067  int
1068  hwloc_fallback_nbprocessors(unsigned flags __hwloc_attribute_unused) {
1069    int n;
1070    SYSTEM_INFO sysinfo;
1071    GetSystemInfo(&sysinfo);
1072    n = sysinfo.dwNumberOfProcessors; &bsol;* FIXME could be non-contigous, rather return a mask from dwActiveProcessorMask? */
1073    if (nr_processor_groups > 1) {
1074      if (GetActiveProcessorCountProc)
1075        n = MAXIMUM_PROC_PER_GROUP*(nr_processor_groups-1)
1076  	+ GetActiveProcessorCountProc((WORD)nr_processor_groups-1);
1077      else
1078        n = MAXIMUM_PROC_PER_GROUP*nr_processor_groups;
1079    }
1080    return n;
1081  }
1082  int64_t
1083  hwloc_fallback_memsize(void) {
1084    return -1;
1085  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from libpcap-MDEwOlJlcG9zaXRvcnk5NDM1ODg3-flat-pcap_0.h</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from xmrig-MDEwOlJlcG9zaXRvcnk4ODMyNzQwNg==-flat-topology-windows.c</div>
                </div>
                <div class="column column_space"><pre><code>65  };
66  struct pcap_stat {
67  	u_int ps_recv;		&bsol;* number of packets received */
68  	u_int ps_drop;		&bsol;* number of packets dropped */
69  	u_int ps_ifdrop;	&bsol;* drops by interface -- only supported on some platforms */
</pre></code></div>
                <div class="column column_space"><pre><code>615  }
616  static int
617  hwloc_win_get_area_memlocation(hwloc_topology_t topology __hwloc_attribute_unused, const void *addr, size_t len, hwloc_nodeset_t nodeset, int flags __hwloc_attribute_unused)
618  {
619    SYSTEM_INFO SystemInfo;
620    DWORD page_size;
621    uintptr_t start;
622    unsigned nb;
623    PSAPI_WORKING_SET_EX_INFORMATION *pv;
624    unsigned i;
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    