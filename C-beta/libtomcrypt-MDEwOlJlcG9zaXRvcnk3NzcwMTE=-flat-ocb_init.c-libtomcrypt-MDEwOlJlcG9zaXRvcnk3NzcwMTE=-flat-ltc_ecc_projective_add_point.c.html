
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 7.782101167315175%, Tokens: 11, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>libtomcrypt-MDEwOlJlcG9zaXRvcnk3NzcwMTE=-flat-ocb_init.c</h3>
            <pre><code>1  #include "tomcrypt_private.h"
2  #ifdef LTC_OCB_MODE
3  static const struct {
4      int           len;
5      unsigned char poly_div[MAXBLOCKSIZE],
6                    poly_mul[MAXBLOCKSIZE];
7  } polys[] = {
8  {
9      8,
10      { 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0D },
11      { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1B }
12  }, {
13      16,
14      { 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
15        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x43 },
16      { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
17        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x87 }
18  }
19  };
<span onclick='openModal()' class='match'>20  int ocb_init(ocb_state *ocb, int cipher,
21               const unsigned char *key, unsigned long keylen, const unsigned char *nonce)
22  {
23     int poly, x, y, m, err;
24     LTC_ARGCHK(ocb   != NULL);
25     LTC_ARGCHK(key   != NULL);
26     LTC_ARGCHK(nonce != NULL);
27     if ((err = cipher_is_valid(cipher)) != CRYPT_OK) {
28        return err;
29     }
</span>30     ocb->block_len = cipher_descriptor[cipher].block_length;
31     x = (int)(sizeof(polys)/sizeof(polys[0]));
32     for (poly = 0; poly < x; poly++) {
33         if (polys[poly].len == ocb->block_len) {
34            break;
35         }
36     }
37     if (poly == x) {
38        return CRYPT_INVALID_ARG; &bsol;* block_len not found in polys */
39     }
40     if (polys[poly].len != ocb->block_len) {
41        return CRYPT_INVALID_ARG;
42     }
43     if ((err = cipher_descriptor[cipher].setup(key, keylen, 0, &ocb->key)) != CRYPT_OK) {
44        return err;
45     }
46     zeromem(ocb->L, ocb->block_len);
47     if ((err = cipher_descriptor[cipher].ecb_encrypt(ocb->L, ocb->L, &ocb->key)) != CRYPT_OK) {
48        return err;
49     }
50     for (x = 0; x < ocb->block_len; x++) {
51         ocb->R[x] = ocb->L[x] ^ nonce[x];
52     }
53     if ((err = cipher_descriptor[cipher].ecb_encrypt(ocb->R, ocb->R, &ocb->key)) != CRYPT_OK) {
54        return err;
55     }
56     XMEMCPY(ocb->Ls[0], ocb->L, ocb->block_len);
57     for (x = 1; x < 32; x++) {
58         m = ocb->Ls[x-1][0] >> 7;
59         for (y = 0; y < ocb->block_len-1; y++) {
60             ocb->Ls[x][y] = ((ocb->Ls[x-1][y] << 1) | (ocb->Ls[x-1][y+1] >> 7)) & 255;
61         }
62         ocb->Ls[x][ocb->block_len-1] = (ocb->Ls[x-1][ocb->block_len-1] << 1) & 255;
63         if (m == 1) {
64            for (y = 0; y < ocb->block_len; y++) {
65                ocb->Ls[x][y] ^= polys[poly].poly_mul[y];
66            }
67         }
68     }
69     m = ocb->L[ocb->block_len-1] & 1;
70     for (x = ocb->block_len - 1; x > 0; x--) {
71        ocb->Lr[x] = ((ocb->L[x] >> 1) | (ocb->L[x-1] << 7)) & 255;
72     }
73     ocb->Lr[0] = ocb->L[0] >> 1;
74     if (m == 1) {
75        for (x = 0; x < ocb->block_len; x++) {
76           ocb->Lr[x] ^= polys[poly].poly_div[x];
77        }
78     }
79     zeromem(ocb->Li,       ocb->block_len);
80     zeromem(ocb->checksum, ocb->block_len);
81     ocb->block_index = 1;
82     ocb->cipher      = cipher;
83     return CRYPT_OK;
84  }
85  #endif
</code></pre>
        </div>
        <div class="column">
            <h3>libtomcrypt-MDEwOlJlcG9zaXRvcnk3NzcwMTE=-flat-ltc_ecc_projective_add_point.c</h3>
            <pre><code>1  #include "tomcrypt_private.h"
2  #if defined(LTC_MECC) && (!defined(LTC_MECC_ACCEL) || defined(LTM_DESC))
<span onclick='openModal()' class='match'>3  int ltc_ecc_projective_add_point(const ecc_point *P, const ecc_point *Q, ecc_point *R, void *ma, void *modulus, void *mp)
4  {
5     void  *t1, *t2, *x, *y, *z;
6     int    err, inf;
7     LTC_ARGCHK(P       != NULL);
8     LTC_ARGCHK(Q       != NULL);
9     LTC_ARGCHK(R       != NULL);
10     LTC_ARGCHK(modulus != NULL);
11     LTC_ARGCHK(mp      != NULL);
12     if ((err = mp_init_multi(&t1, &t2, &x, &y, &z, LTC_NULL)) != CRYPT_OK) {
13        return err;
14     }
</span>15     if ((err = ltc_ecc_is_point_at_infinity(P, modulus, &inf)) != CRYPT_OK) return err;
16     if (inf) {
17        err = ltc_ecc_copy_point(Q, R);
18        goto done;
19     }
20     if ((err = ltc_ecc_is_point_at_infinity(Q, modulus, &inf)) != CRYPT_OK) return err;
21     if (inf) {
22        err = ltc_ecc_copy_point(P, R);
23        goto done;
24     }
25     if ((mp_cmp(P->x, Q->x) == LTC_MP_EQ) && (mp_cmp(P->z, Q->z) == LTC_MP_EQ)) {
26        if (mp_cmp(P->y, Q->y) == LTC_MP_EQ) {
27           mp_clear_multi(t1, t2, x, y, z, LTC_NULL);
28           return ltc_ecc_projective_dbl_point(P, R, ma, modulus, mp);
29        }
30        if ((err = mp_sub(modulus, Q->y, t1)) != CRYPT_OK)                       { goto done; }
31        if (mp_cmp(P->y, t1) == LTC_MP_EQ) {
32           err = ltc_ecc_set_point_xyz(1, 1, 0, R);
33           goto done;
34        }
35     }
36     if ((err = mp_copy(P->x, x)) != CRYPT_OK)                                   { goto done; }
37     if ((err = mp_copy(P->y, y)) != CRYPT_OK)                                   { goto done; }
38     if ((err = mp_copy(P->z, z)) != CRYPT_OK)                                   { goto done; }
39     if (Q->z != NULL) {
40        if ((err = mp_sqr(Q->z, t1)) != CRYPT_OK)                                { goto done; }
41        if ((err = mp_montgomery_reduce(t1, modulus, mp)) != CRYPT_OK)           { goto done; }
42        if ((err = mp_mul(t1, x, x)) != CRYPT_OK)                                { goto done; }
43        if ((err = mp_montgomery_reduce(x, modulus, mp)) != CRYPT_OK)            { goto done; }
44        if ((err = mp_mul(Q->z, t1, t1)) != CRYPT_OK)                            { goto done; }
45        if ((err = mp_montgomery_reduce(t1, modulus, mp)) != CRYPT_OK)           { goto done; }
46        if ((err = mp_mul(t1, y, y)) != CRYPT_OK)                                { goto done; }
47        if ((err = mp_montgomery_reduce(y, modulus, mp)) != CRYPT_OK)            { goto done; }
48     }
49     if ((err = mp_sqr(z, t1)) != CRYPT_OK)                                      { goto done; }
50     if ((err = mp_montgomery_reduce(t1, modulus, mp)) != CRYPT_OK)              { goto done; }
51     if ((err = mp_mul(Q->x, t1, t2)) != CRYPT_OK)                               { goto done; }
52     if ((err = mp_montgomery_reduce(t2, modulus, mp)) != CRYPT_OK)              { goto done; }
53     if ((err = mp_mul(z, t1, t1)) != CRYPT_OK)                                  { goto done; }
54     if ((err = mp_montgomery_reduce(t1, modulus, mp)) != CRYPT_OK)              { goto done; }
55     if ((err = mp_mul(Q->y, t1, t1)) != CRYPT_OK)                               { goto done; }
56     if ((err = mp_montgomery_reduce(t1, modulus, mp)) != CRYPT_OK)              { goto done; }
57     if ((err = mp_sub(y, t1, y)) != CRYPT_OK)                                   { goto done; }
58     if (mp_cmp_d(y, 0) == LTC_MP_LT) {
59        if ((err = mp_add(y, modulus, y)) != CRYPT_OK)                           { goto done; }
60     }
61     if ((err = mp_add(t1, t1, t1)) != CRYPT_OK)                                 { goto done; }
62     if (mp_cmp(t1, modulus) != LTC_MP_LT) {
63        if ((err = mp_sub(t1, modulus, t1)) != CRYPT_OK)                         { goto done; }
64     }
65     if ((err = mp_add(t1, y, t1)) != CRYPT_OK)                                  { goto done; }
66     if (mp_cmp(t1, modulus) != LTC_MP_LT) {
67        if ((err = mp_sub(t1, modulus, t1)) != CRYPT_OK)                         { goto done; }
68     }
69     if ((err = mp_sub(x, t2, x)) != CRYPT_OK)                                   { goto done; }
70     if (mp_cmp_d(x, 0) == LTC_MP_LT) {
71        if ((err = mp_add(x, modulus, x)) != CRYPT_OK)                           { goto done; }
72     }
73     if ((err = mp_add(t2, t2, t2)) != CRYPT_OK)                                 { goto done; }
74     if (mp_cmp(t2, modulus) != LTC_MP_LT) {
75        if ((err = mp_sub(t2, modulus, t2)) != CRYPT_OK)                         { goto done; }
76     }
77     if ((err = mp_add(t2, x, t2)) != CRYPT_OK)                                  { goto done; }
78     if (mp_cmp(t2, modulus) != LTC_MP_LT) {
79        if ((err = mp_sub(t2, modulus, t2)) != CRYPT_OK)                         { goto done; }
80     }
81     if (Q->z != NULL) {
82        if ((err = mp_mul(z, Q->z, z)) != CRYPT_OK)                              { goto done; }
83        if ((err = mp_montgomery_reduce(z, modulus, mp)) != CRYPT_OK)            { goto done; }
84     }
85     if ((err = mp_mul(z, x, z)) != CRYPT_OK)                                    { goto done; }
86     if ((err = mp_montgomery_reduce(z, modulus, mp)) != CRYPT_OK)               { goto done; }
87     if ((err = mp_mul(t1, x, t1)) != CRYPT_OK)                                  { goto done; }
88     if ((err = mp_montgomery_reduce(t1, modulus, mp)) != CRYPT_OK)              { goto done; }
89     if ((err = mp_sqr(x, x)) != CRYPT_OK)                                       { goto done; }
90     if ((err = mp_montgomery_reduce(x, modulus, mp)) != CRYPT_OK)               { goto done; }
91     if ((err = mp_mul(t2, x, t2)) != CRYPT_OK)                                  { goto done; }
92     if ((err = mp_montgomery_reduce(t2, modulus, mp)) != CRYPT_OK)              { goto done; }
93     if ((err = mp_mul(t1, x, t1)) != CRYPT_OK)                                  { goto done; }
94     if ((err = mp_montgomery_reduce(t1, modulus, mp)) != CRYPT_OK)              { goto done; }
95     if ((err = mp_sqr(y, x)) != CRYPT_OK)                                       { goto done; }
96     if ((err = mp_montgomery_reduce(x, modulus, mp)) != CRYPT_OK)               { goto done; }
97     if ((err = mp_sub(x, t2, x)) != CRYPT_OK)                                   { goto done; }
98     if (mp_cmp_d(x, 0) == LTC_MP_LT) {
99        if ((err = mp_add(x, modulus, x)) != CRYPT_OK)                           { goto done; }
100     }
101     if ((err = mp_sub(t2, x, t2)) != CRYPT_OK)                                  { goto done; }
102     if (mp_cmp_d(t2, 0) == LTC_MP_LT) {
103        if ((err = mp_add(t2, modulus, t2)) != CRYPT_OK)                         { goto done; }
104     }
105     if ((err = mp_sub(t2, x, t2)) != CRYPT_OK)                                  { goto done; }
106     if (mp_cmp_d(t2, 0) == LTC_MP_LT) {
107        if ((err = mp_add(t2, modulus, t2)) != CRYPT_OK)                         { goto done; }
108     }
109     if ((err = mp_mul(t2, y, t2)) != CRYPT_OK)                                  { goto done; }
110     if ((err = mp_montgomery_reduce(t2, modulus, mp)) != CRYPT_OK)              { goto done; }
111     if ((err = mp_sub(t2, t1, y)) != CRYPT_OK)                                  { goto done; }
112     if (mp_cmp_d(y, 0) == LTC_MP_LT) {
113        if ((err = mp_add(y, modulus, y)) != CRYPT_OK)                           { goto done; }
114     }
115     if (mp_isodd(y)) {
116        if ((err = mp_add(y, modulus, y)) != CRYPT_OK)                           { goto done; }
117     }
118     if ((err = mp_div_2(y, y)) != CRYPT_OK)                                     { goto done; }
119     if ((err = mp_copy(x, R->x)) != CRYPT_OK)                                   { goto done; }
120     if ((err = mp_copy(y, R->y)) != CRYPT_OK)                                   { goto done; }
121     if ((err = mp_copy(z, R->z)) != CRYPT_OK)                                   { goto done; }
122     err = CRYPT_OK;
123  done:
124     mp_clear_multi(t1, t2, x, y, z, LTC_NULL);
125     return err;
126  }
127  #endif
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from libtomcrypt-MDEwOlJlcG9zaXRvcnk3NzcwMTE=-flat-ocb_init.c</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from libtomcrypt-MDEwOlJlcG9zaXRvcnk3NzcwMTE=-flat-ltc_ecc_projective_add_point.c</div>
                </div>
                <div class="column column_space"><pre><code>20  int ocb_init(ocb_state *ocb, int cipher,
21               const unsigned char *key, unsigned long keylen, const unsigned char *nonce)
22  {
23     int poly, x, y, m, err;
24     LTC_ARGCHK(ocb   != NULL);
25     LTC_ARGCHK(key   != NULL);
26     LTC_ARGCHK(nonce != NULL);
27     if ((err = cipher_is_valid(cipher)) != CRYPT_OK) {
28        return err;
29     }
</pre></code></div>
                <div class="column column_space"><pre><code>3  int ltc_ecc_projective_add_point(const ecc_point *P, const ecc_point *Q, ecc_point *R, void *ma, void *modulus, void *mp)
4  {
5     void  *t1, *t2, *x, *y, *z;
6     int    err, inf;
7     LTC_ARGCHK(P       != NULL);
8     LTC_ARGCHK(Q       != NULL);
9     LTC_ARGCHK(R       != NULL);
10     LTC_ARGCHK(modulus != NULL);
11     LTC_ARGCHK(mp      != NULL);
12     if ((err = mp_init_multi(&t1, &t2, &x, &y, &z, LTC_NULL)) != CRYPT_OK) {
13        return err;
14     }
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    