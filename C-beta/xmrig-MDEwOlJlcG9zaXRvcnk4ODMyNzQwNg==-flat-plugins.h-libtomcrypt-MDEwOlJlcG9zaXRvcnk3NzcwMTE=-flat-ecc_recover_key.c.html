
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 9.73630831643002%, Tokens: 9, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>xmrig-MDEwOlJlcG9zaXRvcnk4ODMyNzQwNg==-flat-plugins.h</h3>
            <pre><code>1  #ifndef HWLOC_PLUGINS_H
2  #define HWLOC_PLUGINS_H
3  struct hwloc_backend;
4  #include "hwloc.h"
5  #ifdef HWLOC_INSIDE_PLUGIN
6  #ifdef HWLOC_HAVE_LTDL
7  #include <ltdl.h>
8  #else
9  #include <dlfcn.h>
10  #endif
11  #endif
12  struct hwloc_disc_component {
13    const char *name;
14    unsigned phases;
15    unsigned excluded_phases;
16    struct hwloc_backend * (*instantiate)(struct hwloc_topology *topology, struct hwloc_disc_component *component, unsigned excluded_phases, const void *data1, const void *data2, const void *data3);
17    unsigned priority;
18    unsigned enabled_by_default;
19    struct hwloc_disc_component * next;
20  };
21  typedef enum hwloc_disc_phase_e {
22    HWLOC_DISC_PHASE_GLOBAL = (1U<<0),
23    HWLOC_DISC_PHASE_CPU = (1U<<1),
24    HWLOC_DISC_PHASE_MEMORY = (1U<<2),
25    HWLOC_DISC_PHASE_PCI = (1U<<3),
26    HWLOC_DISC_PHASE_IO = (1U<<4),
27    HWLOC_DISC_PHASE_MISC = (1U<<5),
28    HWLOC_DISC_PHASE_ANNOTATE = (1U<<6),
29    HWLOC_DISC_PHASE_TWEAK = (1U<<7)
30  } hwloc_disc_phase_t;
31  enum hwloc_disc_status_flag_e {
32    HWLOC_DISC_STATUS_FLAG_GOT_ALLOWED_RESOURCES = (1UL<<1)
33  };
34  struct hwloc_disc_status {
35    hwloc_disc_phase_t phase;
36    unsigned excluded_phases;
37    unsigned long flags;
38  };
39  struct hwloc_backend {
40    struct hwloc_disc_component * component;
41    struct hwloc_topology * topology;
42    int envvar_forced;
43    struct hwloc_backend * next;
44    unsigned phases;
45    unsigned long flags;
46    int is_thissystem;
47    void * private_data;
48    void (*disable)(struct hwloc_backend *backend);
49    int (*discover)(struct hwloc_backend *backend, struct hwloc_disc_status *status);
50    int (*get_pci_busid_cpuset)(struct hwloc_backend *backend, struct hwloc_pcidev_attr_s *busid, hwloc_bitmap_t cpuset);
51  };
52  HWLOC_DECLSPEC struct hwloc_backend * hwloc_backend_alloc(struct hwloc_topology *topology, struct hwloc_disc_component *component);
53  HWLOC_DECLSPEC int hwloc_backend_enable(struct hwloc_backend *backend);
54  typedef enum hwloc_component_type_e {
55    HWLOC_COMPONENT_TYPE_DISC,
56    HWLOC_COMPONENT_TYPE_XML
57  } hwloc_component_type_t;
58  struct hwloc_component {
59    unsigned abi;
60    int (*init)(unsigned long flags);
61    void (*finalize)(unsigned long flags);
62    hwloc_component_type_t type;
63    unsigned long flags;
64    void * data;
65  };
66  HWLOC_DECLSPEC int hwloc_hide_errors(void);
67  #define HWLOC_SHOW_CRITICAL_ERRORS() (hwloc_hide_errors() < 2)
68  #define HWLOC_SHOW_ALL_ERRORS() (hwloc_hide_errors() == 0)
69  HWLOC_DECLSPEC hwloc_obj_t
70  hwloc__insert_object_by_cpuset(struct hwloc_topology *topology, hwloc_obj_t root,
71                                 hwloc_obj_t obj, const char *reason);
72  HWLOC_DECLSPEC void hwloc_insert_object_by_parent(struct hwloc_topology *topology, hwloc_obj_t parent, hwloc_obj_t obj);
<span onclick='openModal()' class='match'>73  HWLOC_DECLSPEC hwloc_obj_t hwloc_alloc_setup_object(hwloc_topology_t topology, hwloc_obj_type_t type, unsigned os_index);
74  HWLOC_DECLSPEC int hwloc_obj_add_children_sets(hwloc_obj_t obj);
75  HWLOC_DECLSPEC int hwloc_topology_reconnect(hwloc_topology_t topology, unsigned long flags __hwloc_attribute_unused);
76  static __hwloc_inline int
77  hwloc_plugin_check_namespace(const char *pluginname __hwloc_attribute_unused, const char *symbol __hwloc_attribute_unused)
78  {
79  #ifdef HWLOC_INSIDE_PLUGIN
80    void *sym;
81  #ifdef HWLOC_HAVE_LTDL
82    lt_dlhandle handle = lt_dlopen(NULL);
</span>83  #else
84    void *handle = dlopen(NULL, RTLD_NOW|RTLD_LOCAL);
85  #endif
86    if (!handle)
87      return 0;
88  #ifdef HWLOC_HAVE_LTDL
89    sym = lt_dlsym(handle, symbol);
90    lt_dlclose(handle);
91  #else
92    sym = dlsym(handle, symbol);
93    dlclose(handle);
94  #endif
95    if (!sym) {
96      static int verboseenv_checked = 0;
97      static int verboseenv_value = 0;
98      if (!verboseenv_checked) {
99        const char *verboseenv = getenv("HWLOC_PLUGINS_VERBOSE");
100        verboseenv_value = verboseenv ? atoi(verboseenv) : 0;
101        verboseenv_checked = 1;
102      }
103      if (verboseenv_value)
104        fprintf(stderr, "Plugin `%s' disabling itself because it cannot find the `%s' core symbol.\n",
105  	      pluginname, symbol);
106      return -1;
107    }
108  #endif &bsol;* HWLOC_INSIDE_PLUGIN */
109    return 0;
110  }
111  static __hwloc_inline int
112  hwloc_filter_check_pcidev_subtype_important(unsigned classid)
113  {
114    unsigned baseclass = classid >> 8;
115    return (baseclass == 0x03 &bsol;* PCI_BASE_CLASS_DISPLAY */
116  	  || baseclass == 0x02 &bsol;* PCI_BASE_CLASS_NETWORK */
117  	  || baseclass == 0x01 &bsol;* PCI_BASE_CLASS_STORAGE */
118  	  || baseclass == 0x00 &bsol;* Unclassified, for Atos/Bull BXI */
119  	  || baseclass == 0x0b &bsol;* PCI_BASE_CLASS_PROCESSOR */
120  	  || classid == 0x0c04 &bsol;* PCI_CLASS_SERIAL_FIBER */
121  	  || classid == 0x0c06 &bsol;* PCI_CLASS_SERIAL_INFINIBAND */
122            || classid == 0x0502 &bsol;* PCI_CLASS_MEMORY_CXL */
123            || baseclass == 0x06 &bsol;* PCI_BASE_CLASS_BRIDGE with non-PCI downstream. the core will drop the useless ones later */
124  	  || baseclass == 0x12 &bsol;* Processing Accelerators */);
125  }
126  static __hwloc_inline int
127  hwloc_filter_check_osdev_subtype_important(hwloc_obj_osdev_type_t subtype)
128  {
129    return (subtype != HWLOC_OBJ_OSDEV_DMA);
130  }
131  static __hwloc_inline int
132  hwloc_filter_check_keep_object_type(hwloc_topology_t topology, hwloc_obj_type_t type)
133  {
134    enum hwloc_type_filter_e filter = HWLOC_TYPE_FILTER_KEEP_NONE;
135    hwloc_topology_get_type_filter(topology, type, &filter);
136    assert(filter != HWLOC_TYPE_FILTER_KEEP_IMPORTANT); &bsol;* IMPORTANT only used for I/O */
137    return filter == HWLOC_TYPE_FILTER_KEEP_NONE ? 0 : 1;
138  }
139  static __hwloc_inline int
140  hwloc_filter_check_keep_object(hwloc_topology_t topology, hwloc_obj_t obj)
141  {
142    hwloc_obj_type_t type = obj->type;
143    enum hwloc_type_filter_e filter = HWLOC_TYPE_FILTER_KEEP_NONE;
144    hwloc_topology_get_type_filter(topology, type, &filter);
145    if (filter == HWLOC_TYPE_FILTER_KEEP_NONE)
146      return 0;
147    if (filter == HWLOC_TYPE_FILTER_KEEP_IMPORTANT) {
148      if (type == HWLOC_OBJ_PCI_DEVICE)
149        return hwloc_filter_check_pcidev_subtype_important(obj->attr->pcidev.class_id);
150      if (type == HWLOC_OBJ_OS_DEVICE)
151        return hwloc_filter_check_osdev_subtype_important(obj->attr->osdev.type);
152    }
153    return 1;
154  }
155  HWLOC_DECLSPEC unsigned hwloc_pcidisc_find_cap(const unsigned char *config, unsigned cap);
156  HWLOC_DECLSPEC int hwloc_pcidisc_find_linkspeed(const unsigned char *config, unsigned offset, float *linkspeed);
157  HWLOC_DECLSPEC hwloc_obj_type_t hwloc_pcidisc_check_bridge_type(unsigned device_class, const unsigned char *config);
158  HWLOC_DECLSPEC int hwloc_pcidisc_find_bridge_buses(unsigned domain, unsigned bus, unsigned dev, unsigned func,
159  						   unsigned *secondary_busp, unsigned *subordinate_busp,
160  						   const unsigned char *config);
161  HWLOC_DECLSPEC void hwloc_pcidisc_tree_insert_by_busid(struct hwloc_obj **treep, struct hwloc_obj *obj);
162  HWLOC_DECLSPEC int hwloc_pcidisc_tree_attach(struct hwloc_topology *topology, struct hwloc_obj *tree);
163  HWLOC_DECLSPEC struct hwloc_obj * hwloc_pci_find_parent_by_busid(struct hwloc_topology *topology, unsigned domain, unsigned bus, unsigned dev, unsigned func);
164  HWLOC_DECLSPEC struct hwloc_obj * hwloc_pci_find_by_busid(struct hwloc_topology *topology, unsigned domain, unsigned bus, unsigned dev, unsigned func);
165  typedef void * hwloc_backend_distances_add_handle_t;
166  HWLOC_DECLSPEC hwloc_backend_distances_add_handle_t
167  hwloc_backend_distances_add_create(hwloc_topology_t topology,
168                                     const char *name, unsigned long kind,
169                                     unsigned long flags);
170  HWLOC_DECLSPEC int
171  hwloc_backend_distances_add_values(hwloc_topology_t topology,
172                                     hwloc_backend_distances_add_handle_t handle,
173                                     unsigned nbobjs, hwloc_obj_t *objs,
174                                     hwloc_uint64_t *values,
175                                     unsigned long flags);
176  HWLOC_DECLSPEC int
177  hwloc_backend_distances_add_commit(hwloc_topology_t topology,
178                                     hwloc_backend_distances_add_handle_t handle,
179                                     unsigned long flags);
180  #endif &bsol;* HWLOC_PLUGINS_H */
</code></pre>
        </div>
        <div class="column">
            <h3>libtomcrypt-MDEwOlJlcG9zaXRvcnk3NzcwMTE=-flat-ecc_recover_key.c</h3>
            <pre><code>1  #include "tomcrypt_private.h"
2  #ifdef LTC_MECC
3  #ifdef LTC_ECC_SHAMIR
<span onclick='openModal()' class='match'>4  int ecc_recover_key(const unsigned char *sig,  unsigned long siglen,
5                      const unsigned char *hash, unsigned long hashlen,
6                      int recid, ecc_signature_type sigformat, ecc_key *key)
7  {
8     ecc_point     *mG = NULL, *mQ = NULL, *mR = NULL;
</span>9     void          *p, *m, *a, *b;
10     void          *r, *s, *v, *w, *t1, *t2, *u1, *u2, *v1, *v2, *e, *x, *y, *a_plus3;
11     void          *mu = NULL, *ma = NULL;
12     void          *mp = NULL;
13     int           err;
14     unsigned long pbits, pbytes, i, shift_right;
15     unsigned char ch, buf[MAXBLOCKSIZE];
16     LTC_ARGCHK(sig  != NULL);
17     LTC_ARGCHK(hash != NULL);
18     LTC_ARGCHK(key  != NULL);
19     if (ltc_mp.sqrtmod_prime == NULL) {
20        return CRYPT_ERROR;
21     }
22     if ((err = mp_init_multi(&r, &s, &v, &w, &t1, &t2, &u1, &u2, &v1, &v2, &e, &x, &y, &a_plus3, LTC_NULL)) != CRYPT_OK) {
23        return err;
24     }
25     p = key->dp.order;
26     m = key->dp.prime;
27     a = key->dp.A;
28     b = key->dp.B;
29     if ((err = mp_add_d(a, 3, a_plus3)) != CRYPT_OK) {
30        goto error;
31     }
32     mG = ltc_ecc_new_point();
33     mQ = ltc_ecc_new_point();
34     mR = ltc_ecc_new_point();
35     if (mR == NULL || mQ  == NULL || mG == NULL) {
36        err = CRYPT_MEM;
37        goto error;
38     }
39     if (sigformat == LTC_ECCSIG_ANSIX962) {
40        if ((err = der_decode_sequence_multi_ex(sig, siglen, LTC_DER_SEQ_SEQUENCE | LTC_DER_SEQ_STRICT,
41                                       LTC_ASN1_INTEGER, 1UL, r,
42                                       LTC_ASN1_INTEGER, 1UL, s,
43                                       LTC_ASN1_EOL, 0UL, LTC_NULL)) != CRYPT_OK)                         { goto error; }
44     }
45     else if (sigformat == LTC_ECCSIG_RFC7518) {
46        i = mp_unsigned_bin_size(key->dp.order);
47        if (siglen != (2*i)) {
48           err = CRYPT_INVALID_PACKET;
49           goto error;
50        }
51        if ((err = mp_read_unsigned_bin(r, (unsigned char *)sig,   i)) != CRYPT_OK)                       { goto error; }
52        if ((err = mp_read_unsigned_bin(s, (unsigned char *)sig+i, i)) != CRYPT_OK)                       { goto error; }
53     }
54     else if (sigformat == LTC_ECCSIG_ETH27) {
55        if (pk_oid_cmp_with_ulong("1.3.132.0.10", key->dp.oid, key->dp.oidlen) != CRYPT_OK) {
56           err = CRYPT_ERROR; goto error;
57        }
58        if (siglen != 65) { &bsol;* Only secp256k1 curves use this format, so must be 65 bytes long */
59           err = CRYPT_INVALID_PACKET;
60           goto error;
61        }
62        i = (unsigned long)sig[64];
63        if ((i>=27) && (i<31)) i -= 27; &bsol;* Ethereum adds 27 to recovery ID */
64        if (recid >= 0 && ((unsigned long)recid != i)) {
65           err = CRYPT_INVALID_PACKET;
66           goto error;
67        }
68        recid = i;
69        if ((err = mp_read_unsigned_bin(r, (unsigned char *)sig,  32)) != CRYPT_OK)                       { goto error; }
70        if ((err = mp_read_unsigned_bin(s, (unsigned char *)sig+32, 32)) != CRYPT_OK)                     { goto error; }
71     }
72  #ifdef LTC_SSH
73     else if (sigformat == LTC_ECCSIG_RFC5656) {
74        char name[64], name2[64];
75        unsigned long namelen = sizeof(name);
76        unsigned long name2len = sizeof(name2);
77        if ((err = ssh_decode_sequence_multi(sig, &siglen,
78                                             LTC_SSHDATA_STRING, name, &namelen,
79                                             LTC_SSHDATA_MPINT,  r,
80                                             LTC_SSHDATA_MPINT,  s,
81                                             LTC_SSHDATA_EOL,    NULL)) != CRYPT_OK)                      { goto error; }
82        if ((err = ecc_ssh_ecdsa_encode_name(name2, &name2len, key)) != CRYPT_OK)                         { goto error; }
83        if ((namelen != name2len) || (XSTRCMP(name, name2) != 0)) {
84           err = CRYPT_INVALID_ARG;
85           goto error;
86        }
87     }
88  #endif
89     else {
90        err = CRYPT_ERROR;
91        goto error;
92     }
93     if (recid < 0 || (unsigned long)recid >= 2*(key->dp.cofactor+1)) {
94        err = CRYPT_INVALID_ARG;
95        goto error;
96     }
97     if (mp_cmp_d(r, 0) != LTC_MP_GT || mp_cmp_d(s, 0) != LTC_MP_GT ||
98         mp_cmp(r, p) != LTC_MP_LT || mp_cmp(s, p) != LTC_MP_LT) {
99        err = CRYPT_INVALID_PACKET;
100        goto error;
101     }
102     pbits = mp_count_bits(p);
103     pbytes = (pbits+7) >> 3;
104     if (pbits > hashlen*8) {
105        if ((err = mp_read_unsigned_bin(e, (unsigned char *)hash, hashlen)) != CRYPT_OK)                  { goto error; }
106     }
107     else if (pbits % 8 == 0) {
108        if ((err = mp_read_unsigned_bin(e, (unsigned char *)hash, pbytes)) != CRYPT_OK)                   { goto error; }
109     }
110     else {
111        shift_right = 8 - pbits % 8;
112        for (i=0, ch=0; i<pbytes; i++) {
113          buf[i] = ch;
114          ch = (hash[i] << (8-shift_right));
115          buf[i] = buf[i] ^ (hash[i] >> shift_right);
116        }
117        if ((err = mp_read_unsigned_bin(e, (unsigned char *)buf, pbytes)) != CRYPT_OK)                    { goto error; }
118     }
119     if ((err = mp_set(x, recid/2)) != CRYPT_OK)                                                          { goto error; }
120     if ((err = mp_mulmod(p, x, m, x)) != CRYPT_OK)                                                       { goto error; }
121     if ((err = mp_add(x, r, x)) != CRYPT_OK)                                                             { goto error; }
122     if ((err = mp_sqr(x, t1)) != CRYPT_OK)                                                               { goto error; }
123     if ((err = mp_mulmod(t1, x, m, t1)) != CRYPT_OK)                                                     { goto error; }
124     if ((err = mp_mulmod(a, x, m, t2)) != CRYPT_OK)                                                      { goto error; }
125     if ((err = mp_add(t1, t2, t1)) != CRYPT_OK)                                                          { goto error; }
126     if ((err = mp_add(t1, b, t1)) != CRYPT_OK)                                                           { goto error; }
127     if ((err = mp_sqrtmod_prime(t1, m, t2)) != CRYPT_OK)                                                 { goto error; }
128     if ((err = mp_copy(x, mR->x)) != CRYPT_OK)                                                           { goto error; }
129     if ((mp_isodd(t2) && (recid%2)) || (!mp_isodd(t2) && !(recid%2))) {
130        if ((err = mp_mod(t2, m, mR->y)) != CRYPT_OK)                                                     { goto error; }
131     }
132     else {
133        if ((err = mp_submod(m, t2, m, mR->y)) != CRYPT_OK)                                               { goto error; }
134     }
135     if ((err = mp_set(mR->z, 1)) != CRYPT_OK)                                                            { goto error; }
136     if ((err = mp_invmod(r, p, w)) != CRYPT_OK)                                                          { goto error; }
137     if ((err = mp_mulmod(s, w, p, v1)) != CRYPT_OK)                                                      { goto error; }
138     if ((err = mp_mulmod(e, w, p, v2)) != CRYPT_OK)                                                      { goto error; }
139     if ((err = mp_submod(p, v2, p, v2)) != CRYPT_OK)                                                     { goto error; }
140     if ((err = mp_invmod(s, p, w)) != CRYPT_OK)                                                          { goto error; }
141     if ((err = mp_mulmod(e, w, p, u1)) != CRYPT_OK)                                                      { goto error; }
142     if ((err = mp_mulmod(r, w, p, u2)) != CRYPT_OK)                                                      { goto error; }
143     if ((err = ltc_ecc_copy_point(&key->dp.base, mG)) != CRYPT_OK)                                       { goto error; }
144     if ((err = mp_montgomery_setup(m, &mp)) != CRYPT_OK)                                                 { goto error; }
145     if (mp_cmp(a_plus3, m) != LTC_MP_EQ) {
146        if ((err = mp_init_multi(&mu, &ma, LTC_NULL)) != CRYPT_OK)                                        { goto error; }
147        if ((err = mp_montgomery_normalization(mu, m)) != CRYPT_OK)                                       { goto error; }
148        if ((err = mp_mulmod(a, mu, m, ma)) != CRYPT_OK)                                                  { goto error; }
149     }
150     if ((err = ltc_mp.ecc_mul2add(mR, v1, mG, v2, mQ, ma, m)) != CRYPT_OK)                               { goto error; }
151     if ((err = ltc_mp.ecc_mul2add(mG, u1, mQ, u2, mG, ma, m)) != CRYPT_OK)                               { goto error; }
152     if ((err = mp_mod(mG->x, p, v)) != CRYPT_OK)                                                         { goto error; }
153     if (mp_cmp(v, r) == LTC_MP_EQ) {
154        if ((err = ltc_ecc_copy_point(mQ, &key->pubkey)) != CRYPT_OK)                                     { goto error; }
155        if ((err = ltc_ecc_verify_key(key)) != CRYPT_OK)                                                  { goto error; }
156        key->type = PK_PUBLIC;
157        err = CRYPT_OK;
158     }
159     else {
160        err = CRYPT_INVALID_ARG;
161     }
162  error:
163     if (ma != NULL) mp_clear(ma);
164     if (mu != NULL) mp_clear(mu);
165     if (mp != NULL) mp_montgomery_free(mp);
166     if (mR != NULL) ltc_ecc_del_point(mR);
167     if (mQ != NULL) ltc_ecc_del_point(mQ);
168     if (mG != NULL) ltc_ecc_del_point(mG);
169     mp_clear_multi(a_plus3, y, x, e, v2, v1, u2, u1, t2, t1, w, v, s, r, LTC_NULL);
170     return err;
171  }
172  #endif
173  #endif
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from xmrig-MDEwOlJlcG9zaXRvcnk4ODMyNzQwNg==-flat-plugins.h</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from libtomcrypt-MDEwOlJlcG9zaXRvcnk3NzcwMTE=-flat-ecc_recover_key.c</div>
                </div>
                <div class="column column_space"><pre><code>73  HWLOC_DECLSPEC hwloc_obj_t hwloc_alloc_setup_object(hwloc_topology_t topology, hwloc_obj_type_t type, unsigned os_index);
74  HWLOC_DECLSPEC int hwloc_obj_add_children_sets(hwloc_obj_t obj);
75  HWLOC_DECLSPEC int hwloc_topology_reconnect(hwloc_topology_t topology, unsigned long flags __hwloc_attribute_unused);
76  static __hwloc_inline int
77  hwloc_plugin_check_namespace(const char *pluginname __hwloc_attribute_unused, const char *symbol __hwloc_attribute_unused)
78  {
79  #ifdef HWLOC_INSIDE_PLUGIN
80    void *sym;
81  #ifdef HWLOC_HAVE_LTDL
82    lt_dlhandle handle = lt_dlopen(NULL);
</pre></code></div>
                <div class="column column_space"><pre><code>4  int ecc_recover_key(const unsigned char *sig,  unsigned long siglen,
5                      const unsigned char *hash, unsigned long hashlen,
6                      int recid, ecc_signature_type sigformat, ecc_key *key)
7  {
8     ecc_point     *mG = NULL, *mQ = NULL, *mR = NULL;
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    