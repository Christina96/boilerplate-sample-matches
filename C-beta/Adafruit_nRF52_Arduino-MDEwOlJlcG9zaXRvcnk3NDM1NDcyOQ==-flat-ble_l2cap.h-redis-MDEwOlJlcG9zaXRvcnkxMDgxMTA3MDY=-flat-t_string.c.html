
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 4.375%, Tokens: 14, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>Adafruit_nRF52_Arduino-MDEwOlJlcG9zaXRvcnk3NDM1NDcyOQ==-flat-ble_l2cap.h</h3>
            <pre><code>1  #ifndef BLE_L2CAP_H__
2  #define BLE_L2CAP_H__
3  #include <stdint.h>
4  #include "nrf_svc.h"
5  #include "nrf_error.h"
6  #include "ble_ranges.h"
7  #include "ble_types.h"
8  #include "ble_err.h"
9  #ifdef __cplusplus
10  extern "C" {
11  #endif
12  enum BLE_L2CAP_SVCS
13  {
14    SD_BLE_L2CAP_CH_SETUP        = BLE_L2CAP_SVC_BASE + 0, &bsol;**< Set up an L2CAP channel. */
15    SD_BLE_L2CAP_CH_RELEASE      = BLE_L2CAP_SVC_BASE + 1, &bsol;**< Release an L2CAP channel. */
16    SD_BLE_L2CAP_CH_RX           = BLE_L2CAP_SVC_BASE + 2, &bsol;**< Receive an SDU on an L2CAP channel. */
17    SD_BLE_L2CAP_CH_TX           = BLE_L2CAP_SVC_BASE + 3, &bsol;**< Transmit an SDU on an L2CAP channel. */
18    SD_BLE_L2CAP_CH_FLOW_CONTROL = BLE_L2CAP_SVC_BASE + 4, &bsol;**< Advanced SDU reception flow control. */
19  };
20  enum BLE_L2CAP_EVTS
21  {
22    BLE_L2CAP_EVT_CH_SETUP_REQUEST    = BLE_L2CAP_EVT_BASE + 0,    &bsol;**< L2CAP Channel Setup Request event.
23                                                                     \n See @ref ble_l2cap_evt_ch_setup_request_t. */
24    BLE_L2CAP_EVT_CH_SETUP_REFUSED    = BLE_L2CAP_EVT_BASE + 1,    &bsol;**< L2CAP Channel Setup Refused event.
25                                                                     \n See @ref ble_l2cap_evt_ch_setup_refused_t. */
26    BLE_L2CAP_EVT_CH_SETUP            = BLE_L2CAP_EVT_BASE + 2,    &bsol;**< L2CAP Channel Setup Completed event.
27                                                                     \n See @ref ble_l2cap_evt_ch_setup_t. */
<span onclick='openModal()' class='match'>28    BLE_L2CAP_EVT_CH_RELEASED         = BLE_L2CAP_EVT_BASE + 3,    &bsol;**< L2CAP Channel Released event.
29                                                                     \n No additional event structure applies. */
30    BLE_L2CAP_EVT_CH_SDU_BUF_RELEASED = BLE_L2CAP_EVT_BASE + 4,    &bsol;**< L2CAP Channel SDU data buffer released event.
</span>31                                                                     \n See @ref ble_l2cap_evt_ch_sdu_buf_released_t. */
32    BLE_L2CAP_EVT_CH_CREDIT           = BLE_L2CAP_EVT_BASE + 5,    &bsol;**< L2CAP Channel Credit received.
33                                                                     \n See @ref ble_l2cap_evt_ch_credit_t. */
34    BLE_L2CAP_EVT_CH_RX               = BLE_L2CAP_EVT_BASE + 6,    &bsol;**< L2CAP Channel SDU received.
35                                                                     \n See @ref ble_l2cap_evt_ch_rx_t. */
36    BLE_L2CAP_EVT_CH_TX               = BLE_L2CAP_EVT_BASE + 7,   &bsol;**< L2CAP Channel SDU transmitted.
37                                                                     \n See @ref ble_l2cap_evt_ch_tx_t. */
38  };
39  #define BLE_L2CAP_CH_COUNT_MAX    (64)
40  #define BLE_L2CAP_MTU_MIN         (23)
41  #define BLE_L2CAP_MPS_MIN         (23)
42  #define BLE_L2CAP_CID_INVALID     (0x0000)
43  #define BLE_L2CAP_CREDITS_DEFAULT (1)
44  #define BLE_L2CAP_CH_SETUP_REFUSED_SRC_LOCAL            (0x01)    &bsol;**< Local. */
45  #define BLE_L2CAP_CH_SETUP_REFUSED_SRC_REMOTE           (0x02)    &bsol;**< Remote. */
46  #define BLE_L2CAP_CH_STATUS_CODE_SUCCESS                (0x0000)  &bsol;**< Success. */
47  #define BLE_L2CAP_CH_STATUS_CODE_LE_PSM_NOT_SUPPORTED   (0x0002)  &bsol;**< LE_PSM not supported. */
48  #define BLE_L2CAP_CH_STATUS_CODE_NO_RESOURCES           (0x0004)  &bsol;**< No resources available. */
49  #define BLE_L2CAP_CH_STATUS_CODE_INSUFF_AUTHENTICATION  (0x0005)  &bsol;**< Insufficient authentication. */
50  #define BLE_L2CAP_CH_STATUS_CODE_INSUFF_AUTHORIZATION   (0x0006)  &bsol;**< Insufficient authorization. */
51  #define BLE_L2CAP_CH_STATUS_CODE_INSUFF_ENC_KEY_SIZE    (0x0007)  &bsol;**< Insufficient encryption key size. */
52  #define BLE_L2CAP_CH_STATUS_CODE_INSUFF_ENC             (0x0008)  &bsol;**< Insufficient encryption. */
53  #define BLE_L2CAP_CH_STATUS_CODE_INVALID_SCID           (0x0009)  &bsol;**< Invalid Source CID. */
54  #define BLE_L2CAP_CH_STATUS_CODE_SCID_ALLOCATED         (0x000A)  &bsol;**< Source CID already allocated. */
55  #define BLE_L2CAP_CH_STATUS_CODE_UNACCEPTABLE_PARAMS    (0x000B)  &bsol;**< Unacceptable parameters. */
56  #define BLE_L2CAP_CH_STATUS_CODE_NOT_UNDERSTOOD         (0x8000)  &bsol;**< Command Reject received instead of LE Credit Based Connection Response. */
57  #define BLE_L2CAP_CH_STATUS_CODE_TIMEOUT                (0xC000)  &bsol;**< Operation timed out. */
58  typedef struct
59  {
60    uint16_t    rx_mps;        &bsol;**< The maximum L2CAP PDU payload size, in bytes, that L2CAP shall
61                                    be able to receive on L2CAP channels on connections with this
62                                    configuration. The minimum value is @ref BLE_L2CAP_MPS_MIN. */
63    uint16_t    tx_mps;        &bsol;**< The maximum L2CAP PDU payload size, in bytes, that L2CAP shall
64                                    be able to transmit on L2CAP channels on connections with this
65                                    configuration. The minimum value is @ref BLE_L2CAP_MPS_MIN. */
66    uint8_t     rx_queue_size; &bsol;**< Number of SDU data buffers that can be queued for reception per
67                                    L2CAP channel. The minimum value is one. */
68    uint8_t     tx_queue_size; &bsol;**< Number of SDU data buffers that can be queued for transmission
69                                    per L2CAP channel. The minimum value is one. */
70    uint8_t     ch_count;      &bsol;**< Number of L2CAP channels the application can create per connection
71                                    with this configuration. The default value is zero, the maximum
72                                    value is @ref BLE_L2CAP_CH_COUNT_MAX.
73                                    @note if this parameter is set to zero, all other parameters in
74                                    @ref ble_l2cap_conn_cfg_t are ignored. */
75  } ble_l2cap_conn_cfg_t;
76  typedef struct
77  {
78    uint16_t    rx_mtu;        &bsol;**< The maximum L2CAP SDU size, in bytes, that L2CAP shall be able to
79                                    receive on this L2CAP channel.
80                                    - Must be equal to or greater than @ref BLE_L2CAP_MTU_MIN. */
81    uint16_t    rx_mps;        &bsol;**< The maximum L2CAP PDU payload size, in bytes, that L2CAP shall be
82                                    able to receive on this L2CAP channel.
83                                    - Must be equal to or greater than @ref BLE_L2CAP_MPS_MIN.
84                                    - Must be equal to or less than @ref ble_l2cap_conn_cfg_t::rx_mps. */
85    ble_data_t  sdu_buf;       &bsol;**< SDU data buffer for reception.
86                                    - If @ref ble_data_t::p_data is non-NULL, initial credits are
87                                      issued to the peer.
88                                    - If @ref ble_data_t::p_data is NULL, no initial credits are
89                                      issued to the peer. */
90  } ble_l2cap_ch_rx_params_t;
91  typedef struct
92  {
93    ble_l2cap_ch_rx_params_t      rx_params;  &bsol;**< L2CAP channel RX parameters. */
94    uint16_t                      le_psm;     &bsol;**< LE Protocol/Service Multiplexer. Used when requesting
95                                                   setup of an L2CAP channel, ignored otherwise. */
96    uint16_t                      status;     &bsol;**< Status code, see @ref BLE_L2CAP_CH_STATUS_CODES.
97                                                   Used when replying to a setup request of an L2CAP
98                                                   channel, ignored otherwise. */
99  } ble_l2cap_ch_setup_params_t;
100  typedef struct
101  {
102    uint16_t    tx_mtu;        &bsol;**< The maximum L2CAP SDU size, in bytes, that L2CAP is able to
103                                    transmit on this L2CAP channel. */
104    uint16_t    peer_mps;      &bsol;**< The maximum L2CAP PDU payload size, in bytes, that the peer is
105                                    able to receive on this L2CAP channel. */
106    uint16_t    tx_mps;        &bsol;**< The maximum L2CAP PDU payload size, in bytes, that L2CAP is able
107                                    to transmit on this L2CAP channel. This is effective tx_mps,
108                                    selected by the SoftDevice as
109                                    MIN( @ref ble_l2cap_ch_tx_params_t::peer_mps, @ref ble_l2cap_conn_cfg_t::tx_mps ) */
110    uint16_t    credits;       &bsol;**< Initial credits given by the peer. */
111  } ble_l2cap_ch_tx_params_t;
112  typedef struct
113  {
114    ble_l2cap_ch_tx_params_t  tx_params;  &bsol;**< L2CAP channel TX parameters. */
115    uint16_t                  le_psm;     &bsol;**< LE Protocol/Service Multiplexer. */
116  } ble_l2cap_evt_ch_setup_request_t;
117  typedef struct
118  {
119    uint8_t  source;           &bsol;**< Source, see @ref BLE_L2CAP_CH_SETUP_REFUSED_SRCS */
120    uint16_t status;           &bsol;**< Status code, see @ref BLE_L2CAP_CH_STATUS_CODES */
121  } ble_l2cap_evt_ch_setup_refused_t;
122  typedef struct
123  {
124    ble_l2cap_ch_tx_params_t tx_params;  &bsol;**< L2CAP channel TX parameters. */
125  } ble_l2cap_evt_ch_setup_t;
126  typedef struct
127  {
128    ble_data_t  sdu_buf;       &bsol;**< Returned reception or transmission SDU data buffer. The SoftDevice
129                                    returns SDU data buffers supplied by the application, which have
130                                    not yet been returned previously via a @ref BLE_L2CAP_EVT_CH_RX or
131                                    @ref BLE_L2CAP_EVT_CH_TX event. */
132  } ble_l2cap_evt_ch_sdu_buf_released_t;
133  typedef struct
134  {
135    uint16_t  credits;         &bsol;**< Additional credits given by the peer. */
136  } ble_l2cap_evt_ch_credit_t;
137  typedef struct
138  {
139    uint16_t    sdu_len;       &bsol;**< Total SDU length, in bytes. */
140    ble_data_t  sdu_buf;       &bsol;**< SDU data buffer.
141                                    @note If there is not enough space in the buffer
142                                          (sdu_buf.len < sdu_len) then the rest of the SDU will be
143                                          silently discarded by the SoftDevice. */
144  } ble_l2cap_evt_ch_rx_t;
145  typedef struct
146  {
147    ble_data_t  sdu_buf;       &bsol;**< SDU data buffer. */
148  } ble_l2cap_evt_ch_tx_t;
149  typedef struct
150  {
151    uint16_t conn_handle;                                     &bsol;**< Connection Handle on which the event occured. */
152    uint16_t local_cid;                                       &bsol;**< Local Channel ID of the L2CAP channel, or
153                                                                   @ref BLE_L2CAP_CID_INVALID if not present. */
154    union
155    {
156      ble_l2cap_evt_ch_setup_request_t    ch_setup_request;   &bsol;**< L2CAP Channel Setup Request Event Parameters. */
157      ble_l2cap_evt_ch_setup_refused_t    ch_setup_refused;   &bsol;**< L2CAP Channel Setup Refused Event Parameters. */
158      ble_l2cap_evt_ch_setup_t            ch_setup;           &bsol;**< L2CAP Channel Setup Completed Event Parameters. */
159      ble_l2cap_evt_ch_sdu_buf_released_t ch_sdu_buf_released;&bsol;**< L2CAP Channel SDU Data Buffer Released Event Parameters. */
160      ble_l2cap_evt_ch_credit_t           credit;             &bsol;**< L2CAP Channel Credit Received Event Parameters. */
161      ble_l2cap_evt_ch_rx_t               rx;                 &bsol;**< L2CAP Channel SDU Received Event Parameters. */
162      ble_l2cap_evt_ch_tx_t               tx;                 &bsol;**< L2CAP Channel SDU Transmitted Event Parameters. */
163    } params;                                                 &bsol;**< Event Parameters. */
164  } ble_l2cap_evt_t;
165  SVCALL(SD_BLE_L2CAP_CH_SETUP, uint32_t, sd_ble_l2cap_ch_setup(uint16_t conn_handle, uint16_t *p_local_cid, ble_l2cap_ch_setup_params_t const *p_params));
166  SVCALL(SD_BLE_L2CAP_CH_RELEASE, uint32_t, sd_ble_l2cap_ch_release(uint16_t conn_handle, uint16_t local_cid));
167  SVCALL(SD_BLE_L2CAP_CH_RX, uint32_t, sd_ble_l2cap_ch_rx(uint16_t conn_handle, uint16_t local_cid, ble_data_t const *p_sdu_buf));
168  SVCALL(SD_BLE_L2CAP_CH_TX, uint32_t, sd_ble_l2cap_ch_tx(uint16_t conn_handle, uint16_t local_cid, ble_data_t const *p_sdu_buf));
169  SVCALL(SD_BLE_L2CAP_CH_FLOW_CONTROL, uint32_t, sd_ble_l2cap_ch_flow_control(uint16_t conn_handle, uint16_t local_cid, uint16_t credits, uint16_t *p_credits));
170  #ifdef __cplusplus
171  }
172  #endif
173  #endif 
</code></pre>
        </div>
        <div class="column">
            <h3>redis-MDEwOlJlcG9zaXRvcnkxMDgxMTA3MDY=-flat-t_string.c</h3>
            <pre><code>1  #include "server.h"
2  #include <math.h> &bsol;* isnan(), isinf() */
3  static int checkStringLength(client *c, PORT_LONGLONG size) {
4      if (size > 512*1024*1024) {
5          addReplyError(c,"string exceeds maximum allowed size (512MB)");
6          return C_ERR;
7      }
8      return C_OK;
9  }
10  #define OBJ_SET_NO_FLAGS 0
11  #define OBJ_SET_NX (1<<0)     &bsol;* Set if key not exists. */
12  #define OBJ_SET_XX (1<<1)     &bsol;* Set if key exists. */
13  #define OBJ_SET_EX (1<<2)     &bsol;* Set if time in seconds is given */
14  #define OBJ_SET_PX (1<<3)     &bsol;* Set if time in ms in given */
<span onclick='openModal()' class='match'>15  void setGenericCommand(client *c, int flags, robj *key, robj *val, robj *expire, int unit, robj *ok_reply, robj *abort_reply) {
16      PORT_LONGLONG milliseconds = 0; &bsol;* initialized to avoid any harmness warning */
</span>17      if (expire) {
18          if (getLongLongFromObjectOrReply(c, expire, &milliseconds, NULL) != C_OK)
19              return;
20          if (milliseconds <= 0) {
21              addReplyErrorFormat(c,"invalid expire time in %s",c->cmd->name);
22              return;
23          }
24          if (unit == UNIT_SECONDS) milliseconds *= 1000;
25      }
26      if ((flags & OBJ_SET_NX && lookupKeyWrite(c->db,key) != NULL) ||
27          (flags & OBJ_SET_XX && lookupKeyWrite(c->db,key) == NULL))
28      {
29          addReply(c, abort_reply ? abort_reply : shared.nullbulk);
30          return;
31      }
32      setKey(c->db,key,val);
33      server.dirty++;
34      if (expire) setExpire(c,c->db,key,mstime()+milliseconds);
35      notifyKeyspaceEvent(NOTIFY_STRING,"set",key,c->db->id);
36      if (expire) notifyKeyspaceEvent(NOTIFY_GENERIC,
37          "expire",key,c->db->id);
38      addReply(c, ok_reply ? ok_reply : shared.ok);
39  }
40  void setCommand(client *c) {
41      int j;
42      robj *expire = NULL;
43      int unit = UNIT_SECONDS;
44      int flags = OBJ_SET_NO_FLAGS;
45      for (j = 3; j < c->argc; j++) {
46          char *a = c->argv[j]->ptr;
47          robj *next = (j == c->argc-1) ? NULL : c->argv[j+1];
48          if ((a[0] == 'n' || a[0] == 'N') &&
49              (a[1] == 'x' || a[1] == 'X') && a[2] == '\0' &&
50              !(flags & OBJ_SET_XX))
51          {
52              flags |= OBJ_SET_NX;
53          } else if ((a[0] == 'x' || a[0] == 'X') &&
54                     (a[1] == 'x' || a[1] == 'X') && a[2] == '\0' &&
55                     !(flags & OBJ_SET_NX))
56          {
57              flags |= OBJ_SET_XX;
58          } else if ((a[0] == 'e' || a[0] == 'E') &&
59                     (a[1] == 'x' || a[1] == 'X') && a[2] == '\0' &&
60                     !(flags & OBJ_SET_PX) && next)
61          {
62              flags |= OBJ_SET_EX;
63              unit = UNIT_SECONDS;
64              expire = next;
65              j++;
66          } else if ((a[0] == 'p' || a[0] == 'P') &&
67                     (a[1] == 'x' || a[1] == 'X') && a[2] == '\0' &&
68                     !(flags & OBJ_SET_EX) && next)
69          {
70              flags |= OBJ_SET_PX;
71              unit = UNIT_MILLISECONDS;
72              expire = next;
73              j++;
74          } else {
75              addReply(c,shared.syntaxerr);
76              return;
77          }
78      }
79      c->argv[2] = tryObjectEncoding(c->argv[2]);
80      setGenericCommand(c,flags,c->argv[1],c->argv[2],expire,unit,NULL,NULL);
81  }
82  void setnxCommand(client *c) {
83      c->argv[2] = tryObjectEncoding(c->argv[2]);
84      setGenericCommand(c,OBJ_SET_NX,c->argv[1],c->argv[2],NULL,0,shared.cone,shared.czero);
85  }
86  void setexCommand(client *c) {
87      c->argv[3] = tryObjectEncoding(c->argv[3]);
88      setGenericCommand(c,OBJ_SET_NO_FLAGS,c->argv[1],c->argv[3],c->argv[2],UNIT_SECONDS,NULL,NULL);
89  }
90  void psetexCommand(client *c) {
91      c->argv[3] = tryObjectEncoding(c->argv[3]);
92      setGenericCommand(c,OBJ_SET_NO_FLAGS,c->argv[1],c->argv[3],c->argv[2],UNIT_MILLISECONDS,NULL,NULL);
93  }
94  int getGenericCommand(client *c) {
95      robj *o;
96      if ((o = lookupKeyReadOrReply(c,c->argv[1],shared.nullbulk)) == NULL)
97          return C_OK;
98      if (o->type != OBJ_STRING) {
99          addReply(c,shared.wrongtypeerr);
100          return C_ERR;
101      } else {
102          addReplyBulk(c,o);
103          return C_OK;
104      }
105  }
106  void getCommand(client *c) {
107      getGenericCommand(c);
108  }
109  void getsetCommand(client *c) {
110      if (getGenericCommand(c) == C_ERR) return;
111      c->argv[2] = tryObjectEncoding(c->argv[2]);
112      setKey(c->db,c->argv[1],c->argv[2]);
113      notifyKeyspaceEvent(NOTIFY_STRING,"set",c->argv[1],c->db->id);
114      server.dirty++;
115  }
116  void setrangeCommand(client *c) {
117      robj *o;
118      PORT_LONG offset;
119      sds value = c->argv[3]->ptr;
120      if (getLongFromObjectOrReply(c,c->argv[2],&offset,NULL) != C_OK)
121          return;
122      if (offset < 0) {
123          addReplyError(c,"offset is out of range");
124          return;
125      }
126      o = lookupKeyWrite(c->db,c->argv[1]);
127      if (o == NULL) {
128          if (sdslen(value) == 0) {
129              addReply(c,shared.czero);
130              return;
131          }
132          if (checkStringLength(c,offset+sdslen(value)) != C_OK)
133              return;
134          o = createObject(OBJ_STRING,sdsnewlen(NULL, offset+sdslen(value)));
135          dbAdd(c->db,c->argv[1],o);
136      } else {
137          size_t olen;
138          if (checkType(c,o,OBJ_STRING))
139              return;
140          olen = stringObjectLen(o);
141          if (sdslen(value) == 0) {
142              addReplyLongLong(c,olen);
143              return;
144          }
145          if (checkStringLength(c,offset+sdslen(value)) != C_OK)
146              return;
147          o = dbUnshareStringValue(c->db,c->argv[1],o);
148      }
149      if (sdslen(value) > 0) {
150          o->ptr = sdsgrowzero(o->ptr,offset+sdslen(value));
151          memcpy((char*)o->ptr+offset,value,sdslen(value));
152          signalModifiedKey(c->db,c->argv[1]);
153          notifyKeyspaceEvent(NOTIFY_STRING,
154              "setrange",c->argv[1],c->db->id);
155          server.dirty++;
156      }
157      addReplyLongLong(c,sdslen(o->ptr));
158  }
159  void getrangeCommand(client *c) {
160      robj *o;
161      PORT_LONGLONG start, end;
162      char *str, llbuf[32];
163      size_t strlen;
164      if (getLongLongFromObjectOrReply(c,c->argv[2],&start,NULL) != C_OK)
165          return;
166      if (getLongLongFromObjectOrReply(c,c->argv[3],&end,NULL) != C_OK)
167          return;
168      if ((o = lookupKeyReadOrReply(c,c->argv[1],shared.emptybulk)) == NULL ||
169          checkType(c,o,OBJ_STRING)) return;
170      if (o->encoding == OBJ_ENCODING_INT) {
171          str = llbuf;
172          strlen = ll2string(llbuf,sizeof(llbuf),(PORT_LONG)o->ptr);
173      } else {
174          str = o->ptr;
175          strlen = sdslen(str);
176      }
177      if (start < 0 && end < 0 && start > end) {
178          addReply(c,shared.emptybulk);
179          return;
180      }
181      if (start < 0) start = strlen+start;
182      if (end < 0) end = strlen+end;
183      if (start < 0) start = 0;
184      if (end < 0) end = 0;
185      if ((PORT_ULONGLONG)end >= strlen) end = strlen-1;
186      if (start > end || strlen == 0) {
187          addReply(c,shared.emptybulk);
188      } else {
189          addReplyBulkCBuffer(c,(char*)str+start,end-start+1);
190      }
191  }
192  void mgetCommand(client *c) {
193      int j;
194      addReplyMultiBulkLen(c,c->argc-1);
195      for (j = 1; j < c->argc; j++) {
196          robj *o = lookupKeyRead(c->db,c->argv[j]);
197          if (o == NULL) {
198              addReply(c,shared.nullbulk);
199          } else {
200              if (o->type != OBJ_STRING) {
201                  addReply(c,shared.nullbulk);
202              } else {
203                  addReplyBulk(c,o);
204              }
205          }
206      }
207  }
208  void msetGenericCommand(client *c, int nx) {
209      int j;
210      if ((c->argc % 2) == 0) {
211          addReplyError(c,"wrong number of arguments for MSET");
212          return;
213      }
214      if (nx) {
215          for (j = 1; j < c->argc; j += 2) {
216              if (lookupKeyWrite(c->db,c->argv[j]) != NULL) {
217                  addReply(c, shared.czero);
218                  return;
219              }
220          }
221      }
222      for (j = 1; j < c->argc; j += 2) {
223          c->argv[j+1] = tryObjectEncoding(c->argv[j+1]);
224          setKey(c->db,c->argv[j],c->argv[j+1]);
225          notifyKeyspaceEvent(NOTIFY_STRING,"set",c->argv[j],c->db->id);
226      }
227      server.dirty += (c->argc-1)/2;
228      addReply(c, nx ? shared.cone : shared.ok);
229  }
230  void msetCommand(client *c) {
231      msetGenericCommand(c,0);
232  }
233  void msetnxCommand(client *c) {
234      msetGenericCommand(c,1);
235  }
236  void incrDecrCommand(client *c, PORT_LONGLONG incr) {
237      PORT_LONGLONG value, oldvalue;
238      robj *o, *new;
239      o = lookupKeyWrite(c->db,c->argv[1]);
240      if (o != NULL && checkType(c,o,OBJ_STRING)) return;
241      if (getLongLongFromObjectOrReply(c,o,&value,NULL) != C_OK) return;
242      oldvalue = value;
243      if ((incr < 0 && oldvalue < 0 && incr < (LLONG_MIN-oldvalue)) ||
244          (incr > 0 && oldvalue > 0 && incr > (LLONG_MAX-oldvalue))) {
245          addReplyError(c,"increment or decrement would overflow");
246          return;
247      }
248      value += incr;
249      if (o && o->refcount == 1 && o->encoding == OBJ_ENCODING_INT &&
250          (value < 0 || value >= OBJ_SHARED_INTEGERS) &&
251          value >= LONG_MIN && value <= LONG_MAX)
252      {
253          new = o;
254          o->ptr = (void*)((PORT_LONG)value);
255      } else {
256          new = createStringObjectFromLongLongForValue(value);
257          if (o) {
258              dbOverwrite(c->db,c->argv[1],new);
259          } else {
260              dbAdd(c->db,c->argv[1],new);
261          }
262      }
263      signalModifiedKey(c->db,c->argv[1]);
264      notifyKeyspaceEvent(NOTIFY_STRING,"incrby",c->argv[1],c->db->id);
265      server.dirty++;
266      addReply(c,shared.colon);
267      addReply(c,new);
268      addReply(c,shared.crlf);
269  }
270  void incrCommand(client *c) {
271      incrDecrCommand(c,1);
272  }
273  void decrCommand(client *c) {
274      incrDecrCommand(c,-1);
275  }
276  void incrbyCommand(client *c) {
277      PORT_LONGLONG incr;
278      if (getLongLongFromObjectOrReply(c, c->argv[2], &incr, NULL) != C_OK) return;
279      incrDecrCommand(c,incr);
280  }
281  void decrbyCommand(client *c) {
282      PORT_LONGLONG incr;
283      if (getLongLongFromObjectOrReply(c, c->argv[2], &incr, NULL) != C_OK) return;
284      incrDecrCommand(c,-incr);
285  }
286  void incrbyfloatCommand(client *c) {
287      PORT_LONGDOUBLE incr, value;
288      robj *o, *new, *aux;
289      o = lookupKeyWrite(c->db,c->argv[1]);
290      if (o != NULL && checkType(c,o,OBJ_STRING)) return;
291      if (getLongDoubleFromObjectOrReply(c,o,&value,NULL) != C_OK ||
292          getLongDoubleFromObjectOrReply(c,c->argv[2],&incr,NULL) != C_OK)
293          return;
294      value += incr;
295      if (isnan(value) || isinf(value)) {
296          addReplyError(c,"increment would produce NaN or Infinity");
297          return;
298      }
299      new = createStringObjectFromLongDouble(value,1);
300      if (o)
301          dbOverwrite(c->db,c->argv[1],new);
302      else
303          dbAdd(c->db,c->argv[1],new);
304      signalModifiedKey(c->db,c->argv[1]);
305      notifyKeyspaceEvent(NOTIFY_STRING,"incrbyfloat",c->argv[1],c->db->id);
306      server.dirty++;
307      addReplyBulk(c,new);
308      aux = createStringObject("SET",3);
309      rewriteClientCommandArgument(c,0,aux);
310      decrRefCount(aux);
311      rewriteClientCommandArgument(c,2,new);
312  }
313  void appendCommand(client *c) {
314      size_t totlen;
315      robj *o, *append;
316      o = lookupKeyWrite(c->db,c->argv[1]);
317      if (o == NULL) {
318          c->argv[2] = tryObjectEncoding(c->argv[2]);
319          dbAdd(c->db,c->argv[1],c->argv[2]);
320          incrRefCount(c->argv[2]);
321          totlen = stringObjectLen(c->argv[2]);
322      } else {
323          if (checkType(c,o,OBJ_STRING))
324              return;
325          append = c->argv[2];
326          totlen = stringObjectLen(o)+sdslen(append->ptr);
327          if (checkStringLength(c,totlen) != C_OK)
328              return;
329          o = dbUnshareStringValue(c->db,c->argv[1],o);
330          o->ptr = sdscatlen(o->ptr,append->ptr,sdslen(append->ptr));
331          totlen = sdslen(o->ptr);
332      }
333      signalModifiedKey(c->db,c->argv[1]);
334      notifyKeyspaceEvent(NOTIFY_STRING,"append",c->argv[1],c->db->id);
335      server.dirty++;
336      addReplyLongLong(c,totlen);
337  }
338  void strlenCommand(client *c) {
339      robj *o;
340      if ((o = lookupKeyReadOrReply(c,c->argv[1],shared.czero)) == NULL ||
341          checkType(c,o,OBJ_STRING)) return;
342      addReplyLongLong(c,stringObjectLen(o));
343  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from Adafruit_nRF52_Arduino-MDEwOlJlcG9zaXRvcnk3NDM1NDcyOQ==-flat-ble_l2cap.h</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from redis-MDEwOlJlcG9zaXRvcnkxMDgxMTA3MDY=-flat-t_string.c</div>
                </div>
                <div class="column column_space"><pre><code>28    BLE_L2CAP_EVT_CH_RELEASED         = BLE_L2CAP_EVT_BASE + 3,    &bsol;**< L2CAP Channel Released event.
29                                                                     \n No additional event structure applies. */
30    BLE_L2CAP_EVT_CH_SDU_BUF_RELEASED = BLE_L2CAP_EVT_BASE + 4,    &bsol;**< L2CAP Channel SDU data buffer released event.
</pre></code></div>
                <div class="column column_space"><pre><code>15  void setGenericCommand(client *c, int flags, robj *key, robj *val, robj *expire, int unit, robj *ok_reply, robj *abort_reply) {
16      PORT_LONGLONG milliseconds = 0; &bsol;* initialized to avoid any harmness warning */
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    