
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 14.035087719298245%, Tokens: 24, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>Adafruit_nRF52_Arduino-MDEwOlJlcG9zaXRvcnk3NDM1NDcyOQ==-flat-nrf_rtc.h</h3>
            <pre><code>1  #ifndef NRF_RTC_H
2  #define NRF_RTC_H
3  #include <nrfx.h>
4  #ifdef __cplusplus
5  extern "C" {
6  #endif
7  #define NRF_RTC_CC_CHANNEL_COUNT(id)  NRFX_CONCAT_3(RTC, id, _CC_NUM)
8  #define RTC_INPUT_FREQ 32768
9  #define RTC_FREQ_TO_PRESCALER(FREQ) (uint16_t)(((RTC_INPUT_FREQ) / (FREQ)) - 1)
10  #define RTC_WRAP(val) ((val) & RTC_COUNTER_COUNTER_Msk)
11  #define RTC_CHANNEL_INT_MASK(ch)    ((uint32_t)(NRF_RTC_INT_COMPARE0_MASK) << (ch))
12  #define RTC_CHANNEL_EVENT_ADDR(ch)  (nrf_rtc_event_t)((NRF_RTC_EVENT_COMPARE_0) + (ch) * sizeof(uint32_t))
13  typedef enum
14  {
15      NRF_RTC_TASK_START            = offsetof(NRF_RTC_Type,TASKS_START),     &bsol;**< Start. */
16      NRF_RTC_TASK_STOP             = offsetof(NRF_RTC_Type,TASKS_STOP),      &bsol;**< Stop. */
17      NRF_RTC_TASK_CLEAR            = offsetof(NRF_RTC_Type,TASKS_CLEAR),     &bsol;**< Clear. */
18      NRF_RTC_TASK_TRIGGER_OVERFLOW = offsetof(NRF_RTC_Type,TASKS_TRIGOVRFLW),&bsol;**< Trigger overflow. */
19  } nrf_rtc_task_t;
20  typedef enum
21  {
22      NRF_RTC_EVENT_TICK        = offsetof(NRF_RTC_Type,EVENTS_TICK),       &bsol;**< Tick event. */
23      NRF_RTC_EVENT_OVERFLOW    = offsetof(NRF_RTC_Type,EVENTS_OVRFLW),     &bsol;**< Overflow event. */
24      NRF_RTC_EVENT_COMPARE_0   = offsetof(NRF_RTC_Type,EVENTS_COMPARE[0]), &bsol;**< Compare 0 event. */
25      NRF_RTC_EVENT_COMPARE_1   = offsetof(NRF_RTC_Type,EVENTS_COMPARE[1]), &bsol;**< Compare 1 event. */
26      NRF_RTC_EVENT_COMPARE_2   = offsetof(NRF_RTC_Type,EVENTS_COMPARE[2]), &bsol;**< Compare 2 event. */
27      NRF_RTC_EVENT_COMPARE_3   = offsetof(NRF_RTC_Type,EVENTS_COMPARE[3])  &bsol;**< Compare 3 event. */
28  } nrf_rtc_event_t;
29  typedef enum
30  {
31      NRF_RTC_INT_TICK_MASK     = RTC_INTENSET_TICK_Msk,     &bsol;**< RTC interrupt from tick event. */
32      NRF_RTC_INT_OVERFLOW_MASK = RTC_INTENSET_OVRFLW_Msk,   &bsol;**< RTC interrupt from overflow event. */
33      NRF_RTC_INT_COMPARE0_MASK = RTC_INTENSET_COMPARE0_Msk, &bsol;**< RTC interrupt from compare event on channel 0. */
34      NRF_RTC_INT_COMPARE1_MASK = RTC_INTENSET_COMPARE1_Msk, &bsol;**< RTC interrupt from compare event on channel 1. */
35      NRF_RTC_INT_COMPARE2_MASK = RTC_INTENSET_COMPARE2_Msk, &bsol;**< RTC interrupt from compare event on channel 2. */
36      NRF_RTC_INT_COMPARE3_MASK = RTC_INTENSET_COMPARE3_Msk  &bsol;**< RTC interrupt from compare event on channel 3. */
37  } nrf_rtc_int_t;
38  NRF_STATIC_INLINE  void nrf_rtc_cc_set(NRF_RTC_Type * p_reg, uint32_t ch, uint32_t cc_val);
39  NRF_STATIC_INLINE  uint32_t nrf_rtc_cc_get(NRF_RTC_Type const * p_reg, uint32_t ch);
40  NRF_STATIC_INLINE void nrf_rtc_int_enable(NRF_RTC_Type * p_reg, uint32_t mask);
41  NRF_STATIC_INLINE void nrf_rtc_int_disable(NRF_RTC_Type * p_reg, uint32_t mask);
42  NRF_STATIC_INLINE uint32_t nrf_rtc_int_enable_check(NRF_RTC_Type const * p_reg, uint32_t mask);
43  #if defined(DPPI_PRESENT) || defined(__NRFX_DOXYGEN__)
44  NRF_STATIC_INLINE void nrf_rtc_subscribe_set(NRF_RTC_Type * p_reg,
45                                               nrf_rtc_task_t task,
46                                               uint8_t        channel);
47  NRF_STATIC_INLINE void nrf_rtc_subscribe_clear(NRF_RTC_Type * p_reg,
48                                                 nrf_rtc_task_t task);
49  NRF_STATIC_INLINE void nrf_rtc_publish_set(NRF_RTC_Type *  p_reg,
50                                             nrf_rtc_event_t event,
51                                             uint8_t         channel);
<span onclick='openModal()' class='match'>52  NRF_STATIC_INLINE void nrf_rtc_publish_clear(NRF_RTC_Type *  p_reg,
53                                               nrf_rtc_event_t event);
54  #endif 
55  NRF_STATIC_INLINE bool nrf_rtc_event_check(NRF_RTC_Type const * p_reg, nrf_rtc_event_t event);
56  NRF_STATIC_INLINE void nrf_rtc_event_clear(NRF_RTC_Type * p_reg, nrf_rtc_event_t event);
57  NRF_STATIC_INLINE uint32_t nrf_rtc_counter_get(NRF_RTC_Type const * p_reg);
58  NRF_STATIC_INLINE void nrf_rtc_prescaler_set(NRF_RTC_Type * p_reg, uint32_t val);
59  NRF_STATIC_INLINE uint32_t nrf_rtc_prescaler_get(NRF_RTC_Type const * p_reg);
60  NRF_STATIC_INLINE uint32_t nrf_rtc_event_address_get(NRF_RTC_Type const * p_reg,
61                                                       nrf_rtc_event_t      event);
62  NRF_STATIC_INLINE uint32_t nrf_rtc_task_address_get(NRF_RTC_Type const * p_reg,
63                                                      nrf_rtc_task_t       task);
64  NRF_STATIC_INLINE void nrf_rtc_task_trigger(NRF_RTC_Type * p_reg, nrf_rtc_task_t task);
65  NRF_STATIC_INLINE void nrf_rtc_event_enable(NRF_RTC_Type * p_reg, uint32_t mask);
66  NRF_STATIC_INLINE void nrf_rtc_event_disable(NRF_RTC_Type * p_reg, uint32_t event);
67  NRF_STATIC_INLINE nrf_rtc_event_t nrf_rtc_compare_event_get(uint8_t index);
68  #ifndef NRF_DECLARE_ONLY
69  NRF_STATIC_INLINE  void nrf_rtc_cc_set(NRF_RTC_Type * p_reg, uint32_t ch, uint32_t cc_val)
</span>70  {
71      p_reg->CC[ch] = cc_val;
72  }
73  NRF_STATIC_INLINE  uint32_t nrf_rtc_cc_get(NRF_RTC_Type const * p_reg, uint32_t ch)
74  {
75      return p_reg->CC[ch];
76  }
77  NRF_STATIC_INLINE void nrf_rtc_int_enable(NRF_RTC_Type * p_reg, uint32_t mask)
78  {
79      p_reg->INTENSET = mask;
80  }
81  NRF_STATIC_INLINE void nrf_rtc_int_disable(NRF_RTC_Type * p_reg, uint32_t mask)
82  {
83      p_reg->INTENCLR = mask;
84  }
85  NRF_STATIC_INLINE uint32_t nrf_rtc_int_enable_check(NRF_RTC_Type const * p_reg, uint32_t mask)
86  {
87      return p_reg->INTENSET & mask;
88  }
89  #if defined(DPPI_PRESENT)
90  NRF_STATIC_INLINE void nrf_rtc_subscribe_set(NRF_RTC_Type * p_reg,
91                                               nrf_rtc_task_t task,
92                                               uint8_t        channel)
93  {
94      *((volatile uint32_t *) ((uint8_t *) p_reg + (uint32_t) task + 0x80uL)) =
95              ((uint32_t)channel | RTC_SUBSCRIBE_START_EN_Msk);
96  }
97  NRF_STATIC_INLINE void nrf_rtc_subscribe_clear(NRF_RTC_Type * p_reg,
98                                                 nrf_rtc_task_t task)
99  {
100      *((volatile uint32_t *) ((uint8_t *) p_reg + (uint32_t) task + 0x80uL)) = 0;
101  }
102  NRF_STATIC_INLINE void nrf_rtc_publish_set(NRF_RTC_Type *  p_reg,
103                                             nrf_rtc_event_t event,
104                                             uint8_t         channel)
105  {
106      *((volatile uint32_t *) ((uint8_t *) p_reg + (uint32_t) event + 0x80uL)) =
107              ((uint32_t)channel | RTC_PUBLISH_TICK_EN_Msk);
108  }
109  NRF_STATIC_INLINE void nrf_rtc_publish_clear(NRF_RTC_Type *  p_reg,
110                                               nrf_rtc_event_t event)
111  {
112      *((volatile uint32_t *) ((uint8_t *) p_reg + (uint32_t) event + 0x80uL)) = 0;
113  }
114  #endif 
115  NRF_STATIC_INLINE bool nrf_rtc_event_check(NRF_RTC_Type const * p_reg, nrf_rtc_event_t event)
116  {
117      return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
118  }
119  NRF_STATIC_INLINE void nrf_rtc_event_clear(NRF_RTC_Type * p_reg, nrf_rtc_event_t event)
120  {
121      *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0;
122  #if __CORTEX_M == 0x04
123      volatile uint32_t dummy = *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event));
124      (void)dummy;
125  #endif
126  }
127  NRF_STATIC_INLINE uint32_t nrf_rtc_counter_get(NRF_RTC_Type const * p_reg)
128  {
129       return p_reg->COUNTER;
130  }
131  NRF_STATIC_INLINE void nrf_rtc_prescaler_set(NRF_RTC_Type * p_reg, uint32_t val)
132  {
133      NRFX_ASSERT(val <= (RTC_PRESCALER_PRESCALER_Msk >> RTC_PRESCALER_PRESCALER_Pos));
134      p_reg->PRESCALER = val;
135  }
136  NRF_STATIC_INLINE uint32_t nrf_rtc_prescaler_get(NRF_RTC_Type const * p_reg)
137  {
138      return p_reg->PRESCALER;
139  }
140  NRF_STATIC_INLINE uint32_t nrf_rtc_event_address_get(NRF_RTC_Type const * p_reg,
141                                                       nrf_rtc_event_t      event)
142  {
143      return (uint32_t)p_reg + event;
144  }
145  NRF_STATIC_INLINE uint32_t nrf_rtc_task_address_get(NRF_RTC_Type const * p_reg,
146                                                      nrf_rtc_task_t       task)
147  {
148      return (uint32_t)p_reg + task;
149  }
150  NRF_STATIC_INLINE void nrf_rtc_task_trigger(NRF_RTC_Type * p_reg, nrf_rtc_task_t task)
151  {
152      *(__IO uint32_t *)((uint32_t)p_reg + task) = 1;
153  }
154  NRF_STATIC_INLINE void nrf_rtc_event_enable(NRF_RTC_Type * p_reg, uint32_t mask)
155  {
156      p_reg->EVTENSET = mask;
157  }
158  NRF_STATIC_INLINE void nrf_rtc_event_disable(NRF_RTC_Type * p_reg, uint32_t mask)
159  {
160      p_reg->EVTENCLR = mask;
161  }
162  NRF_STATIC_INLINE nrf_rtc_event_t nrf_rtc_compare_event_get(uint8_t index)
163  {
164      return (nrf_rtc_event_t)NRFX_OFFSETOF(NRF_RTC_Type, EVENTS_COMPARE[index]);
165  }
166  #endif 
167  #ifdef __cplusplus
168  }
169  #endif
170  #endif  &bsol;* NRF_RTC_H */
</code></pre>
        </div>
        <div class="column">
            <h3>Adafruit_nRF52_Arduino-MDEwOlJlcG9zaXRvcnk3NDM1NDcyOQ==-flat-nrf_nvic_17.h</h3>
            <pre><code>1  #ifndef NRF_NVIC_H__
2  #define NRF_NVIC_H__
3  #include <stdint.h>
4  #include "nrf.h"
5  #include "nrf_svc.h"
6  #include "nrf_error.h"
7  #include "nrf_error_soc.h"
8  #ifdef __cplusplus
9  extern "C" {
10  #endif
11  #define __NRF_NVIC_NVMC_IRQn (30) &bsol;**< The peripheral ID of the NVMC. IRQ numbers are used to identify peripherals, but the NVMC doesn't have an IRQ number in the MDK. */
12  #define __NRF_NVIC_ISER_COUNT (2) &bsol;**< The number of ISER/ICER registers in the NVIC that are used. */
13  #define __NRF_NVIC_SD_IRQ_PRIOS ((uint8_t)( \
14        (1U << 0)  &bsol;**< Priority level high .*/   \
15      | (1U << 1)  &bsol;**< Priority level medium. */ \
16      | (1U << 4)  &bsol;**< Priority level low. */    \
17    ))
18  #define __NRF_NVIC_APP_IRQ_PRIOS ((uint8_t)~__NRF_NVIC_SD_IRQ_PRIOS)
19  #define __NRF_NVIC_SD_IRQS_0 ((uint32_t)( \
20        (1U << POWER_CLOCK_IRQn) \
21      | (1U << RADIO_IRQn) \
22      | (1U << RTC0_IRQn) \
23      | (1U << TIMER0_IRQn) \
24      | (1U << RNG_IRQn) \
25      | (1U << ECB_IRQn) \
26      | (1U << CCM_AAR_IRQn) \
27      | (1U << TEMP_IRQn) \
28      | (1U << __NRF_NVIC_NVMC_IRQn) \
29      | (1U << (uint32_t)SWI5_IRQn) \
30    ))
31  #define __NRF_NVIC_SD_IRQS_1 ((uint32_t)0)
32  #define __NRF_NVIC_APP_IRQS_0 (~__NRF_NVIC_SD_IRQS_0)
33  #define __NRF_NVIC_APP_IRQS_1 (~__NRF_NVIC_SD_IRQS_1)
34  typedef struct
35  {
<span onclick='openModal()' class='match'>36    uint32_t volatile __irq_masks[__NRF_NVIC_ISER_COUNT]; &bsol;**< IRQs enabled by the application in the NVIC. */
37    uint32_t volatile __cr_flag;                          &bsol;**< Non-zero if already in a critical region */
38  } nrf_nvic_state_t;
39  extern nrf_nvic_state_t nrf_nvic_state;
40  __STATIC_INLINE int __sd_nvic_irq_disable(void);
41  __STATIC_INLINE void __sd_nvic_irq_enable(void);
42  __STATIC_INLINE uint32_t __sd_nvic_app_accessible_irq(IRQn_Type IRQn);
43  __STATIC_INLINE uint32_t __sd_nvic_is_app_accessible_priority(uint32_t priority);
44  __STATIC_INLINE uint32_t sd_nvic_EnableIRQ(IRQn_Type IRQn);
45  __STATIC_INLINE uint32_t sd_nvic_DisableIRQ(IRQn_Type IRQn);
46  __STATIC_INLINE uint32_t sd_nvic_GetPendingIRQ(IRQn_Type IRQn, uint32_t * p_pending_irq);
47  __STATIC_INLINE uint32_t sd_nvic_SetPendingIRQ(IRQn_Type IRQn);
48  __STATIC_INLINE uint32_t sd_nvic_ClearPendingIRQ(IRQn_Type IRQn);
49  __STATIC_INLINE uint32_t sd_nvic_SetPriority(IRQn_Type IRQn, uint32_t priority);
50  __STATIC_INLINE uint32_t sd_nvic_GetPriority(IRQn_Type IRQn, uint32_t * p_priority);
51  __STATIC_INLINE uint32_t sd_nvic_SystemReset(void);
52  __STATIC_INLINE uint32_t sd_nvic_critical_region_enter(uint8_t * p_is_nested_critical_region);
53  __STATIC_INLINE uint32_t sd_nvic_critical_region_exit(uint8_t is_nested_critical_region);
54  #ifndef SUPPRESS_INLINE_IMPLEMENTATION
55  __STATIC_INLINE int __sd_nvic_irq_disable(void)
56  {
57    int pm = __get_PRIMASK();
</span>58    __disable_irq();
59    return pm;
60  }
61  __STATIC_INLINE void __sd_nvic_irq_enable(void)
62  {
63    __enable_irq();
64  }
65  __STATIC_INLINE uint32_t __sd_nvic_app_accessible_irq(IRQn_Type IRQn)
66  {
67    if (IRQn < 32)
68    {
69      return ((1UL<<IRQn) & __NRF_NVIC_APP_IRQS_0) != 0;
70    }
71    else if (IRQn < 64)
72    {
73      return ((1UL<<(IRQn-32)) & __NRF_NVIC_APP_IRQS_1) != 0;
74    }
75    else
76    {
77      return 1;
78    }
79  }
80  __STATIC_INLINE uint32_t __sd_nvic_is_app_accessible_priority(uint32_t priority)
81  {
82    if( (priority >= (1 << __NVIC_PRIO_BITS))
83     || (((1 << priority) & __NRF_NVIC_APP_IRQ_PRIOS) == 0)
84      )
85    {
86      return 0;
87    }
88    return 1;
89  }
90  __STATIC_INLINE uint32_t sd_nvic_EnableIRQ(IRQn_Type IRQn)
91  {
92    if (!__sd_nvic_app_accessible_irq(IRQn))
93    {
94      return NRF_ERROR_SOC_NVIC_INTERRUPT_NOT_AVAILABLE;
95    }
96    if (!__sd_nvic_is_app_accessible_priority(NVIC_GetPriority(IRQn)))
97    {
98      return NRF_ERROR_SOC_NVIC_INTERRUPT_PRIORITY_NOT_ALLOWED;
99    }
100    if (nrf_nvic_state.__cr_flag)
101    {
102      nrf_nvic_state.__irq_masks[(uint32_t)((int32_t)IRQn) >> 5] |= (uint32_t)(1 << ((uint32_t)((int32_t)IRQn) & (uint32_t)0x1F));
103    }
104    else
105    {
106      NVIC_EnableIRQ(IRQn);
107    }
108    return NRF_SUCCESS;
109  }
110  __STATIC_INLINE uint32_t sd_nvic_DisableIRQ(IRQn_Type IRQn)
111  {
112    if (!__sd_nvic_app_accessible_irq(IRQn))
113    {
114      return NRF_ERROR_SOC_NVIC_INTERRUPT_NOT_AVAILABLE;
115    }
116    if (nrf_nvic_state.__cr_flag)
117    {
118      nrf_nvic_state.__irq_masks[(uint32_t)((int32_t)IRQn) >> 5] &= ~(1UL << ((uint32_t)(IRQn) & 0x1F));
119    }
120    else
121    {
122      NVIC_DisableIRQ(IRQn);
123    }
124    return NRF_SUCCESS;
125  }
126  __STATIC_INLINE uint32_t sd_nvic_GetPendingIRQ(IRQn_Type IRQn, uint32_t * p_pending_irq)
127  {
128    if (__sd_nvic_app_accessible_irq(IRQn))
129    {
130      *p_pending_irq = NVIC_GetPendingIRQ(IRQn);
131      return NRF_SUCCESS;
132    }
133    else
134    {
135      return NRF_ERROR_SOC_NVIC_INTERRUPT_NOT_AVAILABLE;
136    }
137  }
138  __STATIC_INLINE uint32_t sd_nvic_SetPendingIRQ(IRQn_Type IRQn)
139  {
140    if (__sd_nvic_app_accessible_irq(IRQn))
141    {
142      NVIC_SetPendingIRQ(IRQn);
143      return NRF_SUCCESS;
144    }
145    else
146    {
147      return NRF_ERROR_SOC_NVIC_INTERRUPT_NOT_AVAILABLE;
148    }
149  }
150  __STATIC_INLINE uint32_t sd_nvic_ClearPendingIRQ(IRQn_Type IRQn)
151  {
152    if (__sd_nvic_app_accessible_irq(IRQn))
153    {
154      NVIC_ClearPendingIRQ(IRQn);
155      return NRF_SUCCESS;
156    }
157    else
158    {
159      return NRF_ERROR_SOC_NVIC_INTERRUPT_NOT_AVAILABLE;
160    }
161  }
162  __STATIC_INLINE uint32_t sd_nvic_SetPriority(IRQn_Type IRQn, uint32_t priority)
163  {
164    if (!__sd_nvic_app_accessible_irq(IRQn))
165    {
166      return NRF_ERROR_SOC_NVIC_INTERRUPT_NOT_AVAILABLE;
167    }
168    if (!__sd_nvic_is_app_accessible_priority(priority))
169    {
170      return NRF_ERROR_SOC_NVIC_INTERRUPT_PRIORITY_NOT_ALLOWED;
171    }
172    NVIC_SetPriority(IRQn, (uint32_t)priority);
173    return NRF_SUCCESS;
174  }
175  __STATIC_INLINE uint32_t sd_nvic_GetPriority(IRQn_Type IRQn, uint32_t * p_priority)
176  {
177    if (__sd_nvic_app_accessible_irq(IRQn))
178    {
179      *p_priority = (NVIC_GetPriority(IRQn) & 0xFF);
180      return NRF_SUCCESS;
181    }
182    else
183    {
184      return NRF_ERROR_SOC_NVIC_INTERRUPT_NOT_AVAILABLE;
185    }
186  }
187  __STATIC_INLINE uint32_t sd_nvic_SystemReset(void)
188  {
189    NVIC_SystemReset();
190    return NRF_ERROR_SOC_NVIC_SHOULD_NOT_RETURN;
191  }
192  __STATIC_INLINE uint32_t sd_nvic_critical_region_enter(uint8_t * p_is_nested_critical_region)
193  {
194    int was_masked = __sd_nvic_irq_disable();
195    if (!nrf_nvic_state.__cr_flag)
196    {
197      nrf_nvic_state.__cr_flag = 1;
198      nrf_nvic_state.__irq_masks[0] = ( NVIC->ICER[0] & __NRF_NVIC_APP_IRQS_0 );
199      NVIC->ICER[0] = __NRF_NVIC_APP_IRQS_0;
200      nrf_nvic_state.__irq_masks[1] = ( NVIC->ICER[1] & __NRF_NVIC_APP_IRQS_1 );
201      NVIC->ICER[1] = __NRF_NVIC_APP_IRQS_1;
202      *p_is_nested_critical_region = 0;
203    }
204    else
205    {
206      *p_is_nested_critical_region = 1;
207    }
208    if (!was_masked)
209    {
210      __sd_nvic_irq_enable();
211    }
212    return NRF_SUCCESS;
213  }
214  __STATIC_INLINE uint32_t sd_nvic_critical_region_exit(uint8_t is_nested_critical_region)
215  {
216    if (nrf_nvic_state.__cr_flag && (is_nested_critical_region == 0))
217    {
218      int was_masked = __sd_nvic_irq_disable();
219      NVIC->ISER[0] = nrf_nvic_state.__irq_masks[0];
220      NVIC->ISER[1] = nrf_nvic_state.__irq_masks[1];
221      nrf_nvic_state.__cr_flag = 0;
222      if (!was_masked)
223      {
224        __sd_nvic_irq_enable();
225      }
226    }
227    return NRF_SUCCESS;
228  }
229  #endif &bsol;* SUPPRESS_INLINE_IMPLEMENTATION */
230  #ifdef __cplusplus
231  }
232  #endif
233  #endif 
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from Adafruit_nRF52_Arduino-MDEwOlJlcG9zaXRvcnk3NDM1NDcyOQ==-flat-nrf_rtc.h</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from Adafruit_nRF52_Arduino-MDEwOlJlcG9zaXRvcnk3NDM1NDcyOQ==-flat-nrf_nvic_17.h</div>
                </div>
                <div class="column column_space"><pre><code>52  NRF_STATIC_INLINE void nrf_rtc_publish_clear(NRF_RTC_Type *  p_reg,
53                                               nrf_rtc_event_t event);
54  #endif 
55  NRF_STATIC_INLINE bool nrf_rtc_event_check(NRF_RTC_Type const * p_reg, nrf_rtc_event_t event);
56  NRF_STATIC_INLINE void nrf_rtc_event_clear(NRF_RTC_Type * p_reg, nrf_rtc_event_t event);
57  NRF_STATIC_INLINE uint32_t nrf_rtc_counter_get(NRF_RTC_Type const * p_reg);
58  NRF_STATIC_INLINE void nrf_rtc_prescaler_set(NRF_RTC_Type * p_reg, uint32_t val);
59  NRF_STATIC_INLINE uint32_t nrf_rtc_prescaler_get(NRF_RTC_Type const * p_reg);
60  NRF_STATIC_INLINE uint32_t nrf_rtc_event_address_get(NRF_RTC_Type const * p_reg,
61                                                       nrf_rtc_event_t      event);
62  NRF_STATIC_INLINE uint32_t nrf_rtc_task_address_get(NRF_RTC_Type const * p_reg,
63                                                      nrf_rtc_task_t       task);
64  NRF_STATIC_INLINE void nrf_rtc_task_trigger(NRF_RTC_Type * p_reg, nrf_rtc_task_t task);
65  NRF_STATIC_INLINE void nrf_rtc_event_enable(NRF_RTC_Type * p_reg, uint32_t mask);
66  NRF_STATIC_INLINE void nrf_rtc_event_disable(NRF_RTC_Type * p_reg, uint32_t event);
67  NRF_STATIC_INLINE nrf_rtc_event_t nrf_rtc_compare_event_get(uint8_t index);
68  #ifndef NRF_DECLARE_ONLY
69  NRF_STATIC_INLINE  void nrf_rtc_cc_set(NRF_RTC_Type * p_reg, uint32_t ch, uint32_t cc_val)
</pre></code></div>
                <div class="column column_space"><pre><code>36    uint32_t volatile __irq_masks[__NRF_NVIC_ISER_COUNT]; &bsol;**< IRQs enabled by the application in the NVIC. */
37    uint32_t volatile __cr_flag;                          &bsol;**< Non-zero if already in a critical region */
38  } nrf_nvic_state_t;
39  extern nrf_nvic_state_t nrf_nvic_state;
40  __STATIC_INLINE int __sd_nvic_irq_disable(void);
41  __STATIC_INLINE void __sd_nvic_irq_enable(void);
42  __STATIC_INLINE uint32_t __sd_nvic_app_accessible_irq(IRQn_Type IRQn);
43  __STATIC_INLINE uint32_t __sd_nvic_is_app_accessible_priority(uint32_t priority);
44  __STATIC_INLINE uint32_t sd_nvic_EnableIRQ(IRQn_Type IRQn);
45  __STATIC_INLINE uint32_t sd_nvic_DisableIRQ(IRQn_Type IRQn);
46  __STATIC_INLINE uint32_t sd_nvic_GetPendingIRQ(IRQn_Type IRQn, uint32_t * p_pending_irq);
47  __STATIC_INLINE uint32_t sd_nvic_SetPendingIRQ(IRQn_Type IRQn);
48  __STATIC_INLINE uint32_t sd_nvic_ClearPendingIRQ(IRQn_Type IRQn);
49  __STATIC_INLINE uint32_t sd_nvic_SetPriority(IRQn_Type IRQn, uint32_t priority);
50  __STATIC_INLINE uint32_t sd_nvic_GetPriority(IRQn_Type IRQn, uint32_t * p_priority);
51  __STATIC_INLINE uint32_t sd_nvic_SystemReset(void);
52  __STATIC_INLINE uint32_t sd_nvic_critical_region_enter(uint8_t * p_is_nested_critical_region);
53  __STATIC_INLINE uint32_t sd_nvic_critical_region_exit(uint8_t is_nested_critical_region);
54  #ifndef SUPPRESS_INLINE_IMPLEMENTATION
55  __STATIC_INLINE int __sd_nvic_irq_disable(void)
56  {
57    int pm = __get_PRIMASK();
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    