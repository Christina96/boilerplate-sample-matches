
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 2.1256931608133085%, Tokens: 23, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>libtomcrypt-MDEwOlJlcG9zaXRvcnk3NzcwMTE=-flat-tomcrypt_math.h</h3>
            <pre><code>1  #define LTC_MP_LT   -1
2  #define LTC_MP_EQ    0
3  #define LTC_MP_GT    1
4  #define LTC_MP_NO    0
5  #define LTC_MP_YES   1
6  #ifndef LTC_MECC
7     typedef void ecc_point;
8  #endif
9  #ifndef LTC_MRSA
10     typedef void rsa_key;
11  #endif
12  #ifndef LTC_MILLER_RABIN_REPS
13     #define LTC_MILLER_RABIN_REPS    40
14  #endif
15  int radix_to_bin(const void *in, int radix, void *out, unsigned long *len);
16  typedef struct {
<span onclick='openModal()' class='match'>17     const char *name;
18     int  bits_per_digit;
19     int (*init)(void **a);
20     int (*init_copy)(void **dst, void *src);
21     void (*deinit)(void *a);
22     int (*neg)(void *src, void *dst);
23     int (*copy)(void *src, void *dst);
</span>24     int (*set_int)(void *a, ltc_mp_digit n);
25     unsigned long (*get_int)(void *a);
26     ltc_mp_digit (*get_digit)(void *a, int n);
27     int (*get_digit_count)(void *a);
28     int (*compare)(void *a, void *b);
29     int (*compare_d)(void *a, ltc_mp_digit n);
30     int (*count_bits)(void * a);
31     int (*count_lsb_bits)(void *a);
32     int (*twoexpt)(void *a , int n);
33     int (*read_radix)(void *a, const char *str, int radix);
34     int (*write_radix)(void *a, char *str, int radix);
35     unsigned long (*unsigned_size)(void *a);
36     int (*unsigned_write)(void *src, unsigned char *dst);
37     int (*unsigned_read)(         void *dst,
38                          unsigned char *src,
39                          unsigned long  len);
40     int (*add)(void *a, void *b, void *c);
41     int (*addi)(void *a, ltc_mp_digit b, void *c);
42     int (*sub)(void *a, void *b, void *c);
43     int (*subi)(void *a, ltc_mp_digit b, void *c);
44     int (*mul)(void *a, void *b, void *c);
45     int (*muli)(void *a, ltc_mp_digit b, void *c);
46     int (*sqr)(void *a, void *b);
47     int (*sqrtmod_prime)(void *a, void *b, void *c);
48     int (*mpdiv)(void *a, void *b, void *c, void *d);
49     int (*div_2)(void *a, void *b);
50     int (*modi)(void *a, ltc_mp_digit b, ltc_mp_digit *c);
51     int (*gcd)(void *a, void *b, void *c);
52     int (*lcm)(void *a, void *b, void *c);
53     int (*mulmod)(void *a, void *b, void *c, void *d);
54     int (*sqrmod)(void *a, void *b, void *c);
55     int (*invmod)(void *, void *, void *);
56     int (*montgomery_setup)(void *a, void **b);
57     int (*montgomery_normalization)(void *a, void *b);
58     int (*montgomery_reduce)(void *a, void *b, void *c);
59     void (*montgomery_deinit)(void *a);
60     int (*exptmod)(void *a, void *b, void *c, void *d);
61     int (*isprime)(void *a, int b, int *c);
62     int (*ecc_ptmul)(     void *k,
63                      const ecc_point *G,
64                            ecc_point *R,
65                                 void *a,
66                                 void *modulus,
67                                  int  map);
68     int (*ecc_ptadd)(const ecc_point *P,
69                      const ecc_point *Q,
70                            ecc_point *R,
71                                 void *ma,
72                                 void *modulus,
73                                 void *mp);
74     int (*ecc_ptdbl)(const ecc_point *P,
75                            ecc_point *R,
76                                 void *ma,
77                                 void *modulus,
78                                 void *mp);
79     int (*ecc_map)(ecc_point *P, void *modulus, void *mp);
80     int (*ecc_mul2add)(const ecc_point *A, void *kA,
81                        const ecc_point *B, void *kB,
82                              ecc_point *C,
83                                   void *ma,
84                                   void *modulus);
85      int (*rsa_keygen)(prng_state *prng,
86                               int  wprng,
87                               int  size,
88                              long  e,
89                           rsa_key *key);
90     int (*rsa_me)(const unsigned char *in,   unsigned long inlen,
91                         unsigned char *out,  unsigned long *outlen, int which,
92                   const rsa_key *key);
93     int (*addmod)(void *a, void *b, void *c, void *d);
94     int (*submod)(void *a, void *b, void *c, void *d);
95     int (*rand)(void *a, int size);
96  } ltc_math_descriptor;
97  extern ltc_math_descriptor ltc_mp;
98  int ltc_init_multi(void **a, ...) LTC_NULL_TERMINATED;
99  void ltc_deinit_multi(void *a, ...) LTC_NULL_TERMINATED;
100  void ltc_cleanup_multi(void **a, ...) LTC_NULL_TERMINATED;
101  #ifdef LTM_DESC
102  extern const ltc_math_descriptor ltm_desc;
103  #endif
104  #ifdef TFM_DESC
105  extern const ltc_math_descriptor tfm_desc;
106  #endif
107  #ifdef GMP_DESC
108  extern const ltc_math_descriptor gmp_desc;
109  #endif
</code></pre>
        </div>
        <div class="column">
            <h3>PINRemoteImage-MDEwOlJlcG9zaXRvcnkzOTUzNzEwMw==-flat-lossless_enc.c</h3>
            <pre><code>1  #include "src/dsp/dsp.h"
2  #include <assert.h>
3  #include <math.h>
4  #include <stdlib.h>
5  #include "src/dec/vp8li_dec.h"
6  #include "src/utils/endian_inl_utils.h"
7  #include "src/dsp/lossless.h"
8  #include "src/dsp/lossless_common.h"
9  #include "src/dsp/yuv.h"
10  const float kLog2Table[LOG_LOOKUP_IDX_MAX] = {
11    0.0000000000000000f, 0.0000000000000000f,
12    1.0000000000000000f, 1.5849625007211560f,
13    2.0000000000000000f, 2.3219280948873621f,
14    2.5849625007211560f, 2.8073549220576041f,
15    3.0000000000000000f, 3.1699250014423121f,
16    3.3219280948873621f, 3.4594316186372973f,
17    3.5849625007211560f, 3.7004397181410921f,
18    3.8073549220576041f, 3.9068905956085187f,
19    4.0000000000000000f, 4.0874628412503390f,
20    4.1699250014423121f, 4.2479275134435852f,
21    4.3219280948873626f, 4.3923174227787606f,
22    4.4594316186372973f, 4.5235619560570130f,
23    4.5849625007211560f, 4.6438561897747243f,
24    4.7004397181410917f, 4.7548875021634682f,
25    4.8073549220576037f, 4.8579809951275718f,
26    4.9068905956085187f, 4.9541963103868749f,
27    5.0000000000000000f, 5.0443941193584533f,
28    5.0874628412503390f, 5.1292830169449663f,
29    5.1699250014423121f, 5.2094533656289501f,
30    5.2479275134435852f, 5.2854022188622487f,
31    5.3219280948873626f, 5.3575520046180837f,
32    5.3923174227787606f, 5.4262647547020979f,
33    5.4594316186372973f, 5.4918530963296747f,
34    5.5235619560570130f, 5.5545888516776376f,
35    5.5849625007211560f, 5.6147098441152083f,
36    5.6438561897747243f, 5.6724253419714951f,
37    5.7004397181410917f, 5.7279204545631987f,
38    5.7548875021634682f, 5.7813597135246599f,
39    5.8073549220576037f, 5.8328900141647412f,
40    5.8579809951275718f, 5.8826430493618415f,
41    5.9068905956085187f, 5.9307373375628866f,
42    5.9541963103868749f, 5.9772799234999167f,
43    6.0000000000000000f, 6.0223678130284543f,
44    6.0443941193584533f, 6.0660891904577720f,
45    6.0874628412503390f, 6.1085244567781691f,
46    6.1292830169449663f, 6.1497471195046822f,
47    6.1699250014423121f, 6.1898245588800175f,
48    6.2094533656289501f, 6.2288186904958804f,
49    6.2479275134435852f, 6.2667865406949010f,
50    6.2854022188622487f, 6.3037807481771030f,
51    6.3219280948873626f, 6.3398500028846243f,
52    6.3575520046180837f, 6.3750394313469245f,
53    6.3923174227787606f, 6.4093909361377017f,
54    6.4262647547020979f, 6.4429434958487279f,
55    6.4594316186372973f, 6.4757334309663976f,
56    6.4918530963296747f, 6.5077946401986963f,
57    6.5235619560570130f, 6.5391588111080309f,
58    6.5545888516776376f, 6.5698556083309478f,
59    6.5849625007211560f, 6.5999128421871278f,
60    6.6147098441152083f, 6.6293566200796094f,
61    6.6438561897747243f, 6.6582114827517946f,
62    6.6724253419714951f, 6.6865005271832185f,
63    6.7004397181410917f, 6.7142455176661224f,
64    6.7279204545631987f, 6.7414669864011464f,
65    6.7548875021634682f, 6.7681843247769259f,
66    6.7813597135246599f, 6.7944158663501061f,
67    6.8073549220576037f, 6.8201789624151878f,
68    6.8328900141647412f, 6.8454900509443747f,
69    6.8579809951275718f, 6.8703647195834047f,
70    6.8826430493618415f, 6.8948177633079437f,
71    6.9068905956085187f, 6.9188632372745946f,
72    6.9307373375628866f, 6.9425145053392398f,
73    6.9541963103868749f, 6.9657842846620869f,
74    6.9772799234999167f, 6.9886846867721654f,
75    7.0000000000000000f, 7.0112272554232539f,
76    7.0223678130284543f, 7.0334230015374501f,
77    7.0443941193584533f, 7.0552824355011898f,
78    7.0660891904577720f, 7.0768155970508308f,
79    7.0874628412503390f, 7.0980320829605263f,
80    7.1085244567781691f, 7.1189410727235076f,
81    7.1292830169449663f, 7.1395513523987936f,
82    7.1497471195046822f, 7.1598713367783890f,
83    7.1699250014423121f, 7.1799090900149344f,
84    7.1898245588800175f, 7.1996723448363644f,
85    7.2094533656289501f, 7.2191685204621611f,
86    7.2288186904958804f, 7.2384047393250785f,
87    7.2479275134435852f, 7.2573878426926521f,
88    7.2667865406949010f, 7.2761244052742375f,
89    7.2854022188622487f, 7.2946207488916270f,
90    7.3037807481771030f, 7.3128829552843557f,
91    7.3219280948873626f, 7.3309168781146167f,
92    7.3398500028846243f, 7.3487281542310771f,
93    7.3575520046180837f, 7.3663222142458160f,
94    7.3750394313469245f, 7.3837042924740519f,
95    7.3923174227787606f, 7.4008794362821843f,
96    7.4093909361377017f, 7.4178525148858982f,
97    7.4262647547020979f, 7.4346282276367245f,
98    7.4429434958487279f, 7.4512111118323289f,
99    7.4594316186372973f, 7.4676055500829976f,
100    7.4757334309663976f, 7.4838157772642563f,
101    7.4918530963296747f, 7.4998458870832056f,
102    7.5077946401986963f, 7.5156998382840427f,
103    7.5235619560570130f, 7.5313814605163118f,
104    7.5391588111080309f, 7.5468944598876364f,
105    7.5545888516776376f, 7.5622424242210728f,
106    7.5698556083309478f, 7.5774288280357486f,
107    7.5849625007211560f, 7.5924570372680806f,
108    7.5999128421871278f, 7.6073303137496104f,
109    7.6147098441152083f, 7.6220518194563764f,
110    7.6293566200796094f, 7.6366246205436487f,
111    7.6438561897747243f, 7.6510516911789281f,
112    7.6582114827517946f, 7.6653359171851764f,
113    7.6724253419714951f, 7.6794800995054464f,
114    7.6865005271832185f, 7.6934869574993252f,
115    7.7004397181410917f, 7.7073591320808825f,
116    7.7142455176661224f, 7.7210991887071855f,
117    7.7279204545631987f, 7.7347096202258383f,
118    7.7414669864011464f, 7.7481928495894605f,
119    7.7548875021634682f, 7.7615512324444795f,
120    7.7681843247769259f, 7.7747870596011736f,
121    7.7813597135246599f, 7.7879025593914317f,
122    7.7944158663501061f, 7.8008998999203047f,
123    7.8073549220576037f, 7.8137811912170374f,
124    7.8201789624151878f, 7.8265484872909150f,
125    7.8328900141647412f, 7.8392037880969436f,
126    7.8454900509443747f, 7.8517490414160571f,
127    7.8579809951275718f, 7.8641861446542797f,
128    7.8703647195834047f, 7.8765169465649993f,
129    7.8826430493618415f, 7.8887432488982591f,
130    7.8948177633079437f, 7.9008668079807486f,
131    7.9068905956085187f, 7.9128893362299619f,
132    7.9188632372745946f, 7.9248125036057812f,
133    7.9307373375628866f, 7.9366379390025709f,
134    7.9425145053392398f, 7.9483672315846778f,
135    7.9541963103868749f, 7.9600019320680805f,
136    7.9657842846620869f, 7.9715435539507719f,
137    7.9772799234999167f, 7.9829935746943103f,
138    7.9886846867721654f, 7.9943534368588577f
139  };
140  const float kSLog2Table[LOG_LOOKUP_IDX_MAX] = {
141    0.00000000f,    0.00000000f,  2.00000000f,   4.75488750f,
142    8.00000000f,   11.60964047f,  15.50977500f,  19.65148445f,
143    24.00000000f,  28.52932501f,  33.21928095f,  38.05374781f,
144    43.01955001f,  48.10571634f,  53.30296891f,  58.60335893f,
145    64.00000000f,  69.48686830f,  75.05865003f,  80.71062276f,
146    86.43856190f,  92.23866588f,  98.10749561f,  104.04192499f,
147    110.03910002f, 116.09640474f, 122.21143267f, 128.38196256f,
148    134.60593782f, 140.88144886f, 147.20671787f, 153.58008562f,
149    160.00000000f, 166.46500594f, 172.97373660f, 179.52490559f,
150    186.11730005f, 192.74977453f, 199.42124551f, 206.13068654f,
151    212.87712380f, 219.65963219f, 226.47733176f, 233.32938445f,
152    240.21499122f, 247.13338933f, 254.08384998f, 261.06567603f,
153    268.07820003f, 275.12078236f, 282.19280949f, 289.29369244f,
154    296.42286534f, 303.57978409f, 310.76392512f, 317.97478424f,
155    325.21187564f, 332.47473081f, 339.76289772f, 347.07593991f,
156    354.41343574f, 361.77497759f, 369.16017124f, 376.56863518f,
157    384.00000000f, 391.45390785f, 398.93001188f, 406.42797576f,
158    413.94747321f, 421.48818752f, 429.04981119f, 436.63204548f,
159    444.23460010f, 451.85719280f, 459.49954906f, 467.16140179f,
160    474.84249102f, 482.54256363f, 490.26137307f, 497.99867911f,
161    505.75424759f, 513.52785023f, 521.31926438f, 529.12827280f,
162    536.95466351f, 544.79822957f, 552.65876890f, 560.53608414f,
163    568.42998244f, 576.34027536f, 584.26677867f, 592.20931226f,
164    600.16769996f, 608.14176943f, 616.13135206f, 624.13628279f,
165    632.15640007f, 640.19154569f, 648.24156472f, 656.30630539f,
166    664.38561898f, 672.47935976f, 680.58738488f, 688.70955430f,
167    696.84573069f, 704.99577935f, 713.15956818f, 721.33696754f,
168    729.52785023f, 737.73209140f, 745.94956849f, 754.18016116f,
169    762.42375127f, 770.68022275f, 778.94946161f, 787.23135586f,
170    795.52579543f, 803.83267219f, 812.15187982f, 820.48331383f,
171    828.82687147f, 837.18245171f, 845.54995518f, 853.92928416f,
172    862.32034249f, 870.72303558f, 879.13727036f, 887.56295522f,
173    896.00000000f, 904.44831595f, 912.90781569f, 921.37841320f,
174    929.86002376f, 938.35256392f, 946.85595152f, 955.37010560f,
175    963.89494641f, 972.43039537f, 980.97637504f, 989.53280911f,
176    998.09962237f, 1006.67674069f, 1015.26409097f, 1023.86160116f,
177    1032.46920021f, 1041.08681805f, 1049.71438560f, 1058.35183469f,
178    1066.99909811f, 1075.65610955f, 1084.32280357f, 1092.99911564f,
179    1101.68498204f, 1110.38033993f, 1119.08512727f, 1127.79928282f,
180    1136.52274614f, 1145.25545758f, 1153.99735821f, 1162.74838989f,
181    1171.50849518f, 1180.27761738f, 1189.05570047f, 1197.84268914f,
182    1206.63852876f, 1215.44316535f, 1224.25654560f, 1233.07861684f,
183    1241.90932703f, 1250.74862473f, 1259.59645914f, 1268.45278005f,
184    1277.31753781f, 1286.19068338f, 1295.07216828f, 1303.96194457f,
185    1312.85996488f, 1321.76618236f, 1330.68055071f, 1339.60302413f,
186    1348.53355734f, 1357.47210556f, 1366.41862452f, 1375.37307041f,
187    1384.33539991f, 1393.30557020f, 1402.28353887f, 1411.26926400f,
188    1420.26270412f, 1429.26381818f, 1438.27256558f, 1447.28890615f,
189    1456.31280014f, 1465.34420819f, 1474.38309138f, 1483.42941118f,
190    1492.48312945f, 1501.54420843f, 1510.61261078f, 1519.68829949f,
191    1528.77123795f, 1537.86138993f, 1546.95871952f, 1556.06319119f,
192    1565.17476976f, 1574.29342040f, 1583.41910860f, 1592.55180020f,
193    1601.69146137f, 1610.83805860f, 1619.99155871f, 1629.15192882f,
194    1638.31913637f, 1647.49314911f, 1656.67393509f, 1665.86146266f,
195    1675.05570047f, 1684.25661744f, 1693.46418280f, 1702.67836605f,
196    1711.89913698f, 1721.12646563f, 1730.36032233f, 1739.60067768f,
197    1748.84750254f, 1758.10076802f, 1767.36044551f, 1776.62650662f,
198    1785.89892323f, 1795.17766747f, 1804.46271172f, 1813.75402857f,
199    1823.05159087f, 1832.35537170f, 1841.66534438f, 1850.98148244f,
200    1860.30375965f, 1869.63214999f, 1878.96662767f, 1888.30716711f,
201    1897.65374295f, 1907.00633003f, 1916.36490342f, 1925.72943838f,
202    1935.09991037f, 1944.47629506f, 1953.85856831f, 1963.24670620f,
203    1972.64068498f, 1982.04048108f, 1991.44607117f, 2000.85743204f,
204    2010.27454072f, 2019.69737440f, 2029.12591044f, 2038.56012640f
205  };
206  const VP8LPrefixCode kPrefixEncodeCode[PREFIX_LOOKUP_IDX_MAX] = {
207    { 0, 0}, { 0, 0}, { 1, 0}, { 2, 0}, { 3, 0}, { 4, 1}, { 4, 1}, { 5, 1},
208    { 5, 1}, { 6, 2}, { 6, 2}, { 6, 2}, { 6, 2}, { 7, 2}, { 7, 2}, { 7, 2},
209    { 7, 2}, { 8, 3}, { 8, 3}, { 8, 3}, { 8, 3}, { 8, 3}, { 8, 3}, { 8, 3},
210    { 8, 3}, { 9, 3}, { 9, 3}, { 9, 3}, { 9, 3}, { 9, 3}, { 9, 3}, { 9, 3},
211    { 9, 3}, {10, 4}, {10, 4}, {10, 4}, {10, 4}, {10, 4}, {10, 4}, {10, 4},
212    {10, 4}, {10, 4}, {10, 4}, {10, 4}, {10, 4}, {10, 4}, {10, 4}, {10, 4},
213    {10, 4}, {11, 4}, {11, 4}, {11, 4}, {11, 4}, {11, 4}, {11, 4}, {11, 4},
214    {11, 4}, {11, 4}, {11, 4}, {11, 4}, {11, 4}, {11, 4}, {11, 4}, {11, 4},
215    {11, 4}, {12, 5}, {12, 5}, {12, 5}, {12, 5}, {12, 5}, {12, 5}, {12, 5},
216    {12, 5}, {12, 5}, {12, 5}, {12, 5}, {12, 5}, {12, 5}, {12, 5}, {12, 5},
217    {12, 5}, {12, 5}, {12, 5}, {12, 5}, {12, 5}, {12, 5}, {12, 5}, {12, 5},
218    {12, 5}, {12, 5}, {12, 5}, {12, 5}, {12, 5}, {12, 5}, {12, 5}, {12, 5},
219    {12, 5}, {13, 5}, {13, 5}, {13, 5}, {13, 5}, {13, 5}, {13, 5}, {13, 5},
220    {13, 5}, {13, 5}, {13, 5}, {13, 5}, {13, 5}, {13, 5}, {13, 5}, {13, 5},
221    {13, 5}, {13, 5}, {13, 5}, {13, 5}, {13, 5}, {13, 5}, {13, 5}, {13, 5},
222    {13, 5}, {13, 5}, {13, 5}, {13, 5}, {13, 5}, {13, 5}, {13, 5}, {13, 5},
223    {13, 5}, {14, 6}, {14, 6}, {14, 6}, {14, 6}, {14, 6}, {14, 6}, {14, 6},
224    {14, 6}, {14, 6}, {14, 6}, {14, 6}, {14, 6}, {14, 6}, {14, 6}, {14, 6},
225    {14, 6}, {14, 6}, {14, 6}, {14, 6}, {14, 6}, {14, 6}, {14, 6}, {14, 6},
226    {14, 6}, {14, 6}, {14, 6}, {14, 6}, {14, 6}, {14, 6}, {14, 6}, {14, 6},
227    {14, 6}, {14, 6}, {14, 6}, {14, 6}, {14, 6}, {14, 6}, {14, 6}, {14, 6},
228    {14, 6}, {14, 6}, {14, 6}, {14, 6}, {14, 6}, {14, 6}, {14, 6}, {14, 6},
229    {14, 6}, {14, 6}, {14, 6}, {14, 6}, {14, 6}, {14, 6}, {14, 6}, {14, 6},
230    {14, 6}, {14, 6}, {14, 6}, {14, 6}, {14, 6}, {14, 6}, {14, 6}, {14, 6},
231    {14, 6}, {15, 6}, {15, 6}, {15, 6}, {15, 6}, {15, 6}, {15, 6}, {15, 6},
232    {15, 6}, {15, 6}, {15, 6}, {15, 6}, {15, 6}, {15, 6}, {15, 6}, {15, 6},
233    {15, 6}, {15, 6}, {15, 6}, {15, 6}, {15, 6}, {15, 6}, {15, 6}, {15, 6},
234    {15, 6}, {15, 6}, {15, 6}, {15, 6}, {15, 6}, {15, 6}, {15, 6}, {15, 6},
235    {15, 6}, {15, 6}, {15, 6}, {15, 6}, {15, 6}, {15, 6}, {15, 6}, {15, 6},
236    {15, 6}, {15, 6}, {15, 6}, {15, 6}, {15, 6}, {15, 6}, {15, 6}, {15, 6},
237    {15, 6}, {15, 6}, {15, 6}, {15, 6}, {15, 6}, {15, 6}, {15, 6}, {15, 6},
238    {15, 6}, {15, 6}, {15, 6}, {15, 6}, {15, 6}, {15, 6}, {15, 6}, {15, 6},
239    {15, 6}, {16, 7}, {16, 7}, {16, 7}, {16, 7}, {16, 7}, {16, 7}, {16, 7},
240    {16, 7}, {16, 7}, {16, 7}, {16, 7}, {16, 7}, {16, 7}, {16, 7}, {16, 7},
241    {16, 7}, {16, 7}, {16, 7}, {16, 7}, {16, 7}, {16, 7}, {16, 7}, {16, 7},
242    {16, 7}, {16, 7}, {16, 7}, {16, 7}, {16, 7}, {16, 7}, {16, 7}, {16, 7},
243    {16, 7}, {16, 7}, {16, 7}, {16, 7}, {16, 7}, {16, 7}, {16, 7}, {16, 7},
244    {16, 7}, {16, 7}, {16, 7}, {16, 7}, {16, 7}, {16, 7}, {16, 7}, {16, 7},
245    {16, 7}, {16, 7}, {16, 7}, {16, 7}, {16, 7}, {16, 7}, {16, 7}, {16, 7},
246    {16, 7}, {16, 7}, {16, 7}, {16, 7}, {16, 7}, {16, 7}, {16, 7}, {16, 7},
247    {16, 7}, {16, 7}, {16, 7}, {16, 7}, {16, 7}, {16, 7}, {16, 7}, {16, 7},
248    {16, 7}, {16, 7}, {16, 7}, {16, 7}, {16, 7}, {16, 7}, {16, 7}, {16, 7},
249    {16, 7}, {16, 7}, {16, 7}, {16, 7}, {16, 7}, {16, 7}, {16, 7}, {16, 7},
250    {16, 7}, {16, 7}, {16, 7}, {16, 7}, {16, 7}, {16, 7}, {16, 7}, {16, 7},
251    {16, 7}, {16, 7}, {16, 7}, {16, 7}, {16, 7}, {16, 7}, {16, 7}, {16, 7},
252    {16, 7}, {16, 7}, {16, 7}, {16, 7}, {16, 7}, {16, 7}, {16, 7}, {16, 7},
253    {16, 7}, {16, 7}, {16, 7}, {16, 7}, {16, 7}, {16, 7}, {16, 7}, {16, 7},
254    {16, 7}, {16, 7}, {16, 7}, {16, 7}, {16, 7}, {16, 7}, {16, 7}, {16, 7},
255    {16, 7}, {17, 7}, {17, 7}, {17, 7}, {17, 7}, {17, 7}, {17, 7}, {17, 7},
256    {17, 7}, {17, 7}, {17, 7}, {17, 7}, {17, 7}, {17, 7}, {17, 7}, {17, 7},
257    {17, 7}, {17, 7}, {17, 7}, {17, 7}, {17, 7}, {17, 7}, {17, 7}, {17, 7},
258    {17, 7}, {17, 7}, {17, 7}, {17, 7}, {17, 7}, {17, 7}, {17, 7}, {17, 7},
259    {17, 7}, {17, 7}, {17, 7}, {17, 7}, {17, 7}, {17, 7}, {17, 7}, {17, 7},
260    {17, 7}, {17, 7}, {17, 7}, {17, 7}, {17, 7}, {17, 7}, {17, 7}, {17, 7},
261    {17, 7}, {17, 7}, {17, 7}, {17, 7}, {17, 7}, {17, 7}, {17, 7}, {17, 7},
262    {17, 7}, {17, 7}, {17, 7}, {17, 7}, {17, 7}, {17, 7}, {17, 7}, {17, 7},
263    {17, 7}, {17, 7}, {17, 7}, {17, 7}, {17, 7}, {17, 7}, {17, 7}, {17, 7},
264    {17, 7}, {17, 7}, {17, 7}, {17, 7}, {17, 7}, {17, 7}, {17, 7}, {17, 7},
265    {17, 7}, {17, 7}, {17, 7}, {17, 7}, {17, 7}, {17, 7}, {17, 7}, {17, 7},
266    {17, 7}, {17, 7}, {17, 7}, {17, 7}, {17, 7}, {17, 7}, {17, 7}, {17, 7},
267    {17, 7}, {17, 7}, {17, 7}, {17, 7}, {17, 7}, {17, 7}, {17, 7}, {17, 7},
268    {17, 7}, {17, 7}, {17, 7}, {17, 7}, {17, 7}, {17, 7}, {17, 7}, {17, 7},
269    {17, 7}, {17, 7}, {17, 7}, {17, 7}, {17, 7}, {17, 7}, {17, 7}, {17, 7},
270    {17, 7}, {17, 7}, {17, 7}, {17, 7}, {17, 7}, {17, 7}, {17, 7}, {17, 7},
271  };
272  const uint8_t kPrefixEncodeExtraBitsValue[PREFIX_LOOKUP_IDX_MAX] = {
273     0,  0,  0,  0,  0,  0,  1,  0,  1,  0,  1,  2,  3,  0,  1,  2,  3,
274     0,  1,  2,  3,  4,  5,  6,  7,  0,  1,  2,  3,  4,  5,  6,  7,
275     0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15,
276     0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15,
277     0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15,
278    16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31,
279     0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15,
280    16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31,
281     0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15,
282    16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31,
283    32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47,
284    48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63,
285     0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15,
286    16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31,
287    32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47,
288    48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63,
289     0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15,
290    16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31,
291    32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47,
292    48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63,
293    64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79,
294    80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95,
295    96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111,
296    112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126,
297    127,
298     0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15,
299    16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31,
300    32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47,
301    48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63,
302    64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79,
303    80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95,
304    96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111,
305    112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126
306  };
307  static float FastSLog2Slow_C(uint32_t v) {
308    assert(v >= LOG_LOOKUP_IDX_MAX);
309    if (v < APPROX_LOG_WITH_CORRECTION_MAX) {
310      int log_cnt = 0;
311      uint32_t y = 1;
312      int correction = 0;
313      const float v_f = (float)v;
314      const uint32_t orig_v = v;
315      do {
316        ++log_cnt;
317        v = v >> 1;
318        y = y << 1;
319      } while (v >= LOG_LOOKUP_IDX_MAX);
320      correction = (23 * (orig_v & (y - 1))) >> 4;
321      return v_f * (kLog2Table[v] + log_cnt) + correction;
322    } else {
323      return (float)(LOG_2_RECIPROCAL * v * log((double)v));
324    }
325  }
326  static float FastLog2Slow_C(uint32_t v) {
327    assert(v >= LOG_LOOKUP_IDX_MAX);
328    if (v < APPROX_LOG_WITH_CORRECTION_MAX) {
329      int log_cnt = 0;
330      uint32_t y = 1;
331      const uint32_t orig_v = v;
332      double log_2;
333      do {
334        ++log_cnt;
335        v = v >> 1;
336        y = y << 1;
337      } while (v >= LOG_LOOKUP_IDX_MAX);
338      log_2 = kLog2Table[v] + log_cnt;
339      if (orig_v >= APPROX_LOG_MAX) {
340        const int correction = (23 * (orig_v & (y - 1))) >> 4;
341        log_2 += (double)correction / orig_v;
342      }
343      return (float)log_2;
344    } else {
345      return (float)(LOG_2_RECIPROCAL * log((double)v));
346    }
347  }
348  static float CombinedShannonEntropy_C(const int X[256], const int Y[256]) {
349    int i;
350    double retval = 0.;
351    int sumX = 0, sumXY = 0;
352    for (i = 0; i < 256; ++i) {
353      const int x = X[i];
354      if (x != 0) {
355        const int xy = x + Y[i];
356        sumX += x;
357        retval -= VP8LFastSLog2(x);
358        sumXY += xy;
359        retval -= VP8LFastSLog2(xy);
360      } else if (Y[i] != 0) {
361        sumXY += Y[i];
362        retval -= VP8LFastSLog2(Y[i]);
363      }
364    }
365    retval += VP8LFastSLog2(sumX) + VP8LFastSLog2(sumXY);
366    return (float)retval;
367  }
368  void VP8LBitEntropyInit(VP8LBitEntropy* const entropy) {
369    entropy->entropy = 0.;
370    entropy->sum = 0;
371    entropy->nonzeros = 0;
372    entropy->max_val = 0;
373    entropy->nonzero_code = VP8L_NON_TRIVIAL_SYM;
374  }
375  void VP8LBitsEntropyUnrefined(const uint32_t* const array, int n,
376                                VP8LBitEntropy* const entropy) {
377    int i;
378    VP8LBitEntropyInit(entropy);
379    for (i = 0; i < n; ++i) {
380      if (array[i] != 0) {
381        entropy->sum += array[i];
382        entropy->nonzero_code = i;
383        ++entropy->nonzeros;
384        entropy->entropy -= VP8LFastSLog2(array[i]);
385        if (entropy->max_val < array[i]) {
386          entropy->max_val = array[i];
387        }
388      }
389    }
390    entropy->entropy += VP8LFastSLog2(entropy->sum);
391  }
392  static WEBP_INLINE void GetEntropyUnrefinedHelper(
393      uint32_t val, int i, uint32_t* const val_prev, int* const i_prev,
394      VP8LBitEntropy* const bit_entropy, VP8LStreaks* const stats) {
395    const int streak = i - *i_prev;
396    if (*val_prev != 0) {
397      bit_entropy->sum += (*val_prev) * streak;
398      bit_entropy->nonzeros += streak;
399      bit_entropy->nonzero_code = *i_prev;
400      bit_entropy->entropy -= VP8LFastSLog2(*val_prev) * streak;
401      if (bit_entropy->max_val < *val_prev) {
402        bit_entropy->max_val = *val_prev;
403      }
404    }
405    stats->counts[*val_prev != 0] += (streak > 3);
406    stats->streaks[*val_prev != 0][(streak > 3)] += streak;
407    *val_prev = val;
408    *i_prev = i;
409  }
410  static void GetEntropyUnrefined_C(const uint32_t X[], int length,
411                                    VP8LBitEntropy* const bit_entropy,
412                                    VP8LStreaks* const stats) {
413    int i;
414    int i_prev = 0;
415    uint32_t x_prev = X[0];
416    memset(stats, 0, sizeof(*stats));
417    VP8LBitEntropyInit(bit_entropy);
418    for (i = 1; i < length; ++i) {
419      const uint32_t x = X[i];
420      if (x != x_prev) {
421        GetEntropyUnrefinedHelper(x, i, &x_prev, &i_prev, bit_entropy, stats);
422      }
423    }
424    GetEntropyUnrefinedHelper(0, i, &x_prev, &i_prev, bit_entropy, stats);
425    bit_entropy->entropy += VP8LFastSLog2(bit_entropy->sum);
426  }
427  static void GetCombinedEntropyUnrefined_C(const uint32_t X[],
428                                            const uint32_t Y[],
429                                            int length,
430                                            VP8LBitEntropy* const bit_entropy,
431                                            VP8LStreaks* const stats) {
432    int i = 1;
433    int i_prev = 0;
434    uint32_t xy_prev = X[0] + Y[0];
435    memset(stats, 0, sizeof(*stats));
436    VP8LBitEntropyInit(bit_entropy);
437    for (i = 1; i < length; ++i) {
438      const uint32_t xy = X[i] + Y[i];
439      if (xy != xy_prev) {
440        GetEntropyUnrefinedHelper(xy, i, &xy_prev, &i_prev, bit_entropy, stats);
441      }
442    }
443    GetEntropyUnrefinedHelper(0, i, &xy_prev, &i_prev, bit_entropy, stats);
444    bit_entropy->entropy += VP8LFastSLog2(bit_entropy->sum);
445  }
446  void VP8LSubtractGreenFromBlueAndRed_C(uint32_t* argb_data, int num_pixels) {
447    int i;
448    for (i = 0; i < num_pixels; ++i) {
449      const int argb = argb_data[i];
450      const int green = (argb >> 8) & 0xff;
451      const uint32_t new_r = (((argb >> 16) & 0xff) - green) & 0xff;
452      const uint32_t new_b = (((argb >>  0) & 0xff) - green) & 0xff;
453      argb_data[i] = (argb & 0xff00ff00u) | (new_r << 16) | new_b;
454    }
455  }
456  static WEBP_INLINE int ColorTransformDelta(int8_t color_pred, int8_t color) {
457    return ((int)color_pred * color) >> 5;
458  }
459  static WEBP_INLINE int8_t U32ToS8(uint32_t v) {
460    return (int8_t)(v & 0xff);
461  }
462  void VP8LTransformColor_C(const VP8LMultipliers* const m, uint32_t* data,
463                            int num_pixels) {
464    int i;
465    for (i = 0; i < num_pixels; ++i) {
466      const uint32_t argb = data[i];
467      const int8_t green = U32ToS8(argb >>  8);
468      const int8_t red   = U32ToS8(argb >> 16);
469      int new_red = red & 0xff;
470      int new_blue = argb & 0xff;
471      new_red -= ColorTransformDelta(m->green_to_red_, green);
472      new_red &= 0xff;
473      new_blue -= ColorTransformDelta(m->green_to_blue_, green);
474      new_blue -= ColorTransformDelta(m->red_to_blue_, red);
475      new_blue &= 0xff;
476      data[i] = (argb & 0xff00ff00u) | (new_red << 16) | (new_blue);
477    }
478  }
479  static WEBP_INLINE uint8_t TransformColorRed(uint8_t green_to_red,
480                                               uint32_t argb) {
481    const int8_t green = U32ToS8(argb >> 8);
482    int new_red = argb >> 16;
483    new_red -= ColorTransformDelta(green_to_red, green);
484    return (new_red & 0xff);
485  }
486  static WEBP_INLINE uint8_t TransformColorBlue(uint8_t green_to_blue,
487                                                uint8_t red_to_blue,
488                                                uint32_t argb) {
489    const int8_t green = U32ToS8(argb >>  8);
490    const int8_t red   = U32ToS8(argb >> 16);
491    uint8_t new_blue = argb & 0xff;
492    new_blue -= ColorTransformDelta(green_to_blue, green);
493    new_blue -= ColorTransformDelta(red_to_blue, red);
494    return (new_blue & 0xff);
495  }
496  void VP8LCollectColorRedTransforms_C(const uint32_t* argb, int stride,
497                                       int tile_width, int tile_height,
498                                       int green_to_red, int histo[]) {
499    while (tile_height-- > 0) {
500      int x;
501      for (x = 0; x < tile_width; ++x) {
502        ++histo[TransformColorRed((uint8_t)green_to_red, argb[x])];
503      }
504      argb += stride;
505    }
506  }
507  void VP8LCollectColorBlueTransforms_C(const uint32_t* argb, int stride,
508                                        int tile_width, int tile_height,
509                                        int green_to_blue, int red_to_blue,
510                                        int histo[]) {
511    while (tile_height-- > 0) {
512      int x;
513      for (x = 0; x < tile_width; ++x) {
514        ++histo[TransformColorBlue((uint8_t)green_to_blue, (uint8_t)red_to_blue,
515                                   argb[x])];
516      }
517      argb += stride;
518    }
519  }
520  static int VectorMismatch_C(const uint32_t* const array1,
521                              const uint32_t* const array2, int length) {
522    int match_len = 0;
523    while (match_len < length && array1[match_len] == array2[match_len]) {
524      ++match_len;
525    }
526    return match_len;
527  }
528  void VP8LBundleColorMap_C(const uint8_t* const row, int width, int xbits,
529                            uint32_t* dst) {
530    int x;
531    if (xbits > 0) {
532      const int bit_depth = 1 << (3 - xbits);
533      const int mask = (1 << xbits) - 1;
534      uint32_t code = 0xff000000;
535      for (x = 0; x < width; ++x) {
536        const int xsub = x & mask;
537        if (xsub == 0) {
538          code = 0xff000000;
539        }
540        code |= row[x] << (8 + bit_depth * xsub);
541        dst[x >> xbits] = code;
542      }
543    } else {
544      for (x = 0; x < width; ++x) dst[x] = 0xff000000 | (row[x] << 8);
545    }
546  }
547  static double ExtraCost_C(const uint32_t* population, int length) {
548    int i;
549    double cost = 0.;
550    for (i = 2; i < length - 2; ++i) cost += (i >> 1) * population[i + 2];
551    return cost;
552  }
553  static double ExtraCostCombined_C(const uint32_t* X, const uint32_t* Y,
554                                    int length) {
555    int i;
556    double cost = 0.;
557    for (i = 2; i < length - 2; ++i) {
558      const int xy = X[i + 2] + Y[i + 2];
559      cost += (i >> 1) * xy;
560    }
561    return cost;
562  }
563  static void AddVector_C(const uint32_t* a, const uint32_t* b, uint32_t* out,
564                          int size) {
565    int i;
566    for (i = 0; i < size; ++i) out[i] = a[i] + b[i];
567  }
568  static void AddVectorEq_C(const uint32_t* a, uint32_t* out, int size) {
569    int i;
570    for (i = 0; i < size; ++i) out[i] += a[i];
571  }
572  #define ADD(X, ARG, LEN) do {                                                  \
573    if (a->is_used_[X]) {                                                        \
574      if (b->is_used_[X]) {                                                      \
575        VP8LAddVector(a->ARG, b->ARG, out->ARG, (LEN));                          \
576      } else {                                                                   \
577        memcpy(&out->ARG[0], &a->ARG[0], (LEN) * sizeof(out->ARG[0]));           \
578      }                                                                          \
579    } else if (b->is_used_[X]) {                                                 \
580      memcpy(&out->ARG[0], &b->ARG[0], (LEN) * sizeof(out->ARG[0]));             \
581    } else {                                                                     \
582      memset(&out->ARG[0], 0, (LEN) * sizeof(out->ARG[0]));                      \
583    }                                                                            \
584  } while (0)
585  #define ADD_EQ(X, ARG, LEN) do {                                               \
586    if (a->is_used_[X]) {                                                        \
587      if (out->is_used_[X]) {                                                    \
588        VP8LAddVectorEq(a->ARG, out->ARG, (LEN));                                \
589      } else {                                                                   \
590        memcpy(&out->ARG[0], &a->ARG[0], (LEN) * sizeof(out->ARG[0]));           \
591      }                                                                          \
592    }                                                                            \
593  } while (0)
594  void VP8LHistogramAdd(const VP8LHistogram* const a,
595                        const VP8LHistogram* const b, VP8LHistogram* const out) {
596    int i;
597    const int literal_size = VP8LHistogramNumCodes(a->palette_code_bits_);
598    assert(a->palette_code_bits_ == b->palette_code_bits_);
599    if (b != out) {
600      ADD(0, literal_, literal_size);
601      ADD(1, red_, NUM_LITERAL_CODES);
602      ADD(2, blue_, NUM_LITERAL_CODES);
603      ADD(3, alpha_, NUM_LITERAL_CODES);
604      ADD(4, distance_, NUM_DISTANCE_CODES);
605      for (i = 0; i < 5; ++i) {
606        out->is_used_[i] = (a->is_used_[i] | b->is_used_[i]);
607      }
608    } else {
609      ADD_EQ(0, literal_, literal_size);
610      ADD_EQ(1, red_, NUM_LITERAL_CODES);
611      ADD_EQ(2, blue_, NUM_LITERAL_CODES);
612      ADD_EQ(3, alpha_, NUM_LITERAL_CODES);
613      ADD_EQ(4, distance_, NUM_DISTANCE_CODES);
614      for (i = 0; i < 5; ++i) out->is_used_[i] |= a->is_used_[i];
615    }
616  }
617  #undef ADD
618  #undef ADD_EQ
619  static WEBP_INLINE uint32_t Average2(uint32_t a0, uint32_t a1) {
620    return (((a0 ^ a1) & 0xfefefefeu) >> 1) + (a0 & a1);
621  }
622  static WEBP_INLINE uint32_t Average3(uint32_t a0, uint32_t a1, uint32_t a2) {
623    return Average2(Average2(a0, a2), a1);
624  }
625  static WEBP_INLINE uint32_t Average4(uint32_t a0, uint32_t a1,
626                                       uint32_t a2, uint32_t a3) {
627    return Average2(Average2(a0, a1), Average2(a2, a3));
628  }
629  static WEBP_INLINE uint32_t Clip255(uint32_t a) {
630    if (a < 256) {
631      return a;
632    }
633    return ~a >> 24;
634  }
635  static WEBP_INLINE int AddSubtractComponentFull(int a, int b, int c) {
636    return Clip255(a + b - c);
637  }
638  static WEBP_INLINE uint32_t ClampedAddSubtractFull(uint32_t c0, uint32_t c1,
639                                                     uint32_t c2) {
640    const int a = AddSubtractComponentFull(c0 >> 24, c1 >> 24, c2 >> 24);
641    const int r = AddSubtractComponentFull((c0 >> 16) & 0xff,
642                                           (c1 >> 16) & 0xff,
643                                           (c2 >> 16) & 0xff);
644    const int g = AddSubtractComponentFull((c0 >> 8) & 0xff,
645                                           (c1 >> 8) & 0xff,
646                                           (c2 >> 8) & 0xff);
647    const int b = AddSubtractComponentFull(c0 & 0xff, c1 & 0xff, c2 & 0xff);
648    return ((uint32_t)a << 24) | (r << 16) | (g << 8) | b;
649  }
650  static WEBP_INLINE int AddSubtractComponentHalf(int a, int b) {
651    return Clip255(a + (a - b) / 2);
652  }
653  static WEBP_INLINE uint32_t ClampedAddSubtractHalf(uint32_t c0, uint32_t c1,
654                                                     uint32_t c2) {
655    const uint32_t ave = Average2(c0, c1);
656    const int a = AddSubtractComponentHalf(ave >> 24, c2 >> 24);
657    const int r = AddSubtractComponentHalf((ave >> 16) & 0xff, (c2 >> 16) & 0xff);
658    const int g = AddSubtractComponentHalf((ave >> 8) & 0xff, (c2 >> 8) & 0xff);
659    const int b = AddSubtractComponentHalf((ave >> 0) & 0xff, (c2 >> 0) & 0xff);
660    return ((uint32_t)a << 24) | (r << 16) | (g << 8) | b;
661  }
662  #if defined(__arm__) && \
663      (LOCAL_GCC_VERSION == 0x409 || LOCAL_GCC_VERSION == 0x408)
664  # define LOCAL_INLINE __attribute__ ((noinline))
665  #else
666  # define LOCAL_INLINE WEBP_INLINE
667  #endif
668  static LOCAL_INLINE int Sub3(int a, int b, int c) {
669    const int pb = b - c;
670    const int pa = a - c;
671    return abs(pb) - abs(pa);
672  }
673  #undef LOCAL_INLINE
674  static WEBP_INLINE uint32_t Select(uint32_t a, uint32_t b, uint32_t c) {
675    const int pa_minus_pb =
676        Sub3((a >> 24)       , (b >> 24)       , (c >> 24)       ) +
677        Sub3((a >> 16) & 0xff, (b >> 16) & 0xff, (c >> 16) & 0xff) +
678        Sub3((a >>  8) & 0xff, (b >>  8) & 0xff, (c >>  8) & 0xff) +
679        Sub3((a      ) & 0xff, (b      ) & 0xff, (c      ) & 0xff);
680    return (pa_minus_pb <= 0) ? a : b;
681  }
682  static uint32_t Predictor2(uint32_t left, const uint32_t* const top) {
683    (void)left;
684    return top[0];
685  }
686  static uint32_t Predictor3(uint32_t left, const uint32_t* const top) {
687    (void)left;
688    return top[1];
689  }
690  static uint32_t Predictor4(uint32_t left, const uint32_t* const top) {
691    (void)left;
692    return top[-1];
693  }
694  static uint32_t Predictor5(uint32_t left, const uint32_t* const top) {
695    const uint32_t pred = Average3(left, top[0], top[1]);
696    return pred;
697  }
698  static uint32_t Predictor6(uint32_t left, const uint32_t* const top) {
699    const uint32_t pred = Average2(left, top[-1]);
700    return pred;
701  }
702  static uint32_t Predictor7(uint32_t left, const uint32_t* const top) {
703    const uint32_t pred = Average2(left, top[0]);
704    return pred;
705  }
706  static uint32_t Predictor8(uint32_t left, const uint32_t* const top) {
707    const uint32_t pred = Average2(top[-1], top[0]);
708    (void)left;
709    return pred;
710  }
711  static uint32_t Predictor9(uint32_t left, const uint32_t* const top) {
712    const uint32_t pred = Average2(top[0], top[1]);
713    (void)left;
714    return pred;
715  }
716  static uint32_t Predictor10(uint32_t left, const uint32_t* const top) {
717    const uint32_t pred = Average4(left, top[-1], top[0], top[1]);
718    return pred;
719  }
720  static uint32_t Predictor11(uint32_t left, const uint32_t* const top) {
721    const uint32_t pred = Select(top[0], left, top[-1]);
722    return pred;
723  }
724  static uint32_t Predictor12(uint32_t left, const uint32_t* const top) {
725    const uint32_t pred = ClampedAddSubtractFull(left, top[0], top[-1]);
726    return pred;
727  }
728  static uint32_t Predictor13(uint32_t left, const uint32_t* const top) {
729    const uint32_t pred = ClampedAddSubtractHalf(left, top[0], top[-1]);
730    return pred;
731  }
732  static void PredictorSub0_C(const uint32_t* in, const uint32_t* upper,
733                              int num_pixels, uint32_t* out) {
734    int i;
735    for (i = 0; i < num_pixels; ++i) out[i] = VP8LSubPixels(in[i], ARGB_BLACK);
736    (void)upper;
737  }
738  static void PredictorSub1_C(const uint32_t* in, const uint32_t* upper,
739                              int num_pixels, uint32_t* out) {
740    int i;
741    for (i = 0; i < num_pixels; ++i) out[i] = VP8LSubPixels(in[i], in[i - 1]);
742    (void)upper;
743  }
744  GENERATE_PREDICTOR_SUB(Predictor2, PredictorSub2_C)
745  GENERATE_PREDICTOR_SUB(Predictor3, PredictorSub3_C)
746  GENERATE_PREDICTOR_SUB(Predictor4, PredictorSub4_C)
747  GENERATE_PREDICTOR_SUB(Predictor5, PredictorSub5_C)
748  GENERATE_PREDICTOR_SUB(Predictor6, PredictorSub6_C)
749  GENERATE_PREDICTOR_SUB(Predictor7, PredictorSub7_C)
750  GENERATE_PREDICTOR_SUB(Predictor8, PredictorSub8_C)
751  GENERATE_PREDICTOR_SUB(Predictor9, PredictorSub9_C)
752  GENERATE_PREDICTOR_SUB(Predictor10, PredictorSub10_C)
753  GENERATE_PREDICTOR_SUB(Predictor11, PredictorSub11_C)
754  GENERATE_PREDICTOR_SUB(Predictor12, PredictorSub12_C)
755  GENERATE_PREDICTOR_SUB(Predictor13, PredictorSub13_C)
<span onclick='openModal()' class='match'>756  VP8LProcessEncBlueAndRedFunc VP8LSubtractGreenFromBlueAndRed;
757  VP8LTransformColorFunc VP8LTransformColor;
758  VP8LCollectColorBlueTransformsFunc VP8LCollectColorBlueTransforms;
759  VP8LCollectColorRedTransformsFunc VP8LCollectColorRedTransforms;
760  VP8LFastLog2SlowFunc VP8LFastLog2Slow;
761  VP8LFastLog2SlowFunc VP8LFastSLog2Slow;
762  VP8LCostFunc VP8LExtraCost;
763  VP8LCostCombinedFunc VP8LExtraCostCombined;
764  VP8LCombinedShannonEntropyFunc VP8LCombinedShannonEntropy;
765  VP8LGetEntropyUnrefinedFunc VP8LGetEntropyUnrefined;
766  VP8LGetCombinedEntropyUnrefinedFunc VP8LGetCombinedEntropyUnrefined;
767  VP8LAddVectorFunc VP8LAddVector;
768  VP8LAddVectorEqFunc VP8LAddVectorEq;
769  VP8LVectorMismatchFunc VP8LVectorMismatch;
770  VP8LBundleColorMapFunc VP8LBundleColorMap;
771  VP8LPredictorAddSubFunc VP8LPredictorsSub[16];
772  VP8LPredictorAddSubFunc VP8LPredictorsSub_C[16];
773  extern void VP8LEncDspInitSSE2(void);
774  extern void VP8LEncDspInitSSE41(void);
775  extern void VP8LEncDspInitNEON(void);
776  extern void VP8LEncDspInitMIPS32(void);
777  extern void VP8LEncDspInitMIPSdspR2(void);
778  extern void VP8LEncDspInitMSA(void);
</span>779  WEBP_DSP_INIT_FUNC(VP8LEncDspInit) {
780    VP8LDspInit();
781  #if !WEBP_NEON_OMIT_C_CODE
782    VP8LSubtractGreenFromBlueAndRed = VP8LSubtractGreenFromBlueAndRed_C;
783    VP8LTransformColor = VP8LTransformColor_C;
784  #endif
785    VP8LCollectColorBlueTransforms = VP8LCollectColorBlueTransforms_C;
786    VP8LCollectColorRedTransforms = VP8LCollectColorRedTransforms_C;
787    VP8LFastLog2Slow = FastLog2Slow_C;
788    VP8LFastSLog2Slow = FastSLog2Slow_C;
789    VP8LExtraCost = ExtraCost_C;
790    VP8LExtraCostCombined = ExtraCostCombined_C;
791    VP8LCombinedShannonEntropy = CombinedShannonEntropy_C;
792    VP8LGetEntropyUnrefined = GetEntropyUnrefined_C;
793    VP8LGetCombinedEntropyUnrefined = GetCombinedEntropyUnrefined_C;
794    VP8LAddVector = AddVector_C;
795    VP8LAddVectorEq = AddVectorEq_C;
796    VP8LVectorMismatch = VectorMismatch_C;
797    VP8LBundleColorMap = VP8LBundleColorMap_C;
798    VP8LPredictorsSub[0] = PredictorSub0_C;
799    VP8LPredictorsSub[1] = PredictorSub1_C;
800    VP8LPredictorsSub[2] = PredictorSub2_C;
801    VP8LPredictorsSub[3] = PredictorSub3_C;
802    VP8LPredictorsSub[4] = PredictorSub4_C;
803    VP8LPredictorsSub[5] = PredictorSub5_C;
804    VP8LPredictorsSub[6] = PredictorSub6_C;
805    VP8LPredictorsSub[7] = PredictorSub7_C;
806    VP8LPredictorsSub[8] = PredictorSub8_C;
807    VP8LPredictorsSub[9] = PredictorSub9_C;
808    VP8LPredictorsSub[10] = PredictorSub10_C;
809    VP8LPredictorsSub[11] = PredictorSub11_C;
810    VP8LPredictorsSub[12] = PredictorSub12_C;
811    VP8LPredictorsSub[13] = PredictorSub13_C;
812    VP8LPredictorsSub[14] = PredictorSub0_C;  
813    VP8LPredictorsSub[15] = PredictorSub0_C;
814    VP8LPredictorsSub_C[0] = PredictorSub0_C;
815    VP8LPredictorsSub_C[1] = PredictorSub1_C;
816    VP8LPredictorsSub_C[2] = PredictorSub2_C;
817    VP8LPredictorsSub_C[3] = PredictorSub3_C;
818    VP8LPredictorsSub_C[4] = PredictorSub4_C;
819    VP8LPredictorsSub_C[5] = PredictorSub5_C;
820    VP8LPredictorsSub_C[6] = PredictorSub6_C;
821    VP8LPredictorsSub_C[7] = PredictorSub7_C;
822    VP8LPredictorsSub_C[8] = PredictorSub8_C;
823    VP8LPredictorsSub_C[9] = PredictorSub9_C;
824    VP8LPredictorsSub_C[10] = PredictorSub10_C;
825    VP8LPredictorsSub_C[11] = PredictorSub11_C;
826    VP8LPredictorsSub_C[12] = PredictorSub12_C;
827    VP8LPredictorsSub_C[13] = PredictorSub13_C;
828    VP8LPredictorsSub_C[14] = PredictorSub0_C;  
829    VP8LPredictorsSub_C[15] = PredictorSub0_C;
830    if (VP8GetCPUInfo != NULL) {
831  #if defined(WEBP_USE_SSE2)
832      if (VP8GetCPUInfo(kSSE2)) {
833        VP8LEncDspInitSSE2();
834  #if defined(WEBP_USE_SSE41)
835        if (VP8GetCPUInfo(kSSE4_1)) {
836          VP8LEncDspInitSSE41();
837        }
838  #endif
839      }
840  #endif
841  #if defined(WEBP_USE_MIPS32)
842      if (VP8GetCPUInfo(kMIPS32)) {
843        VP8LEncDspInitMIPS32();
844      }
845  #endif
846  #if defined(WEBP_USE_MIPS_DSP_R2)
847      if (VP8GetCPUInfo(kMIPSdspR2)) {
848        VP8LEncDspInitMIPSdspR2();
849      }
850  #endif
851  #if defined(WEBP_USE_MSA)
852      if (VP8GetCPUInfo(kMSA)) {
853        VP8LEncDspInitMSA();
854      }
855  #endif
856    }
857  #if defined(WEBP_USE_NEON)
858    if (WEBP_NEON_OMIT_C_CODE ||
859        (VP8GetCPUInfo != NULL && VP8GetCPUInfo(kNEON))) {
860      VP8LEncDspInitNEON();
861    }
862  #endif
863    assert(VP8LSubtractGreenFromBlueAndRed != NULL);
864    assert(VP8LTransformColor != NULL);
865    assert(VP8LCollectColorBlueTransforms != NULL);
866    assert(VP8LCollectColorRedTransforms != NULL);
867    assert(VP8LFastLog2Slow != NULL);
868    assert(VP8LFastSLog2Slow != NULL);
869    assert(VP8LExtraCost != NULL);
870    assert(VP8LExtraCostCombined != NULL);
871    assert(VP8LCombinedShannonEntropy != NULL);
872    assert(VP8LGetEntropyUnrefined != NULL);
873    assert(VP8LGetCombinedEntropyUnrefined != NULL);
874    assert(VP8LAddVector != NULL);
875    assert(VP8LAddVectorEq != NULL);
876    assert(VP8LVectorMismatch != NULL);
877    assert(VP8LBundleColorMap != NULL);
878    assert(VP8LPredictorsSub[0] != NULL);
879    assert(VP8LPredictorsSub[1] != NULL);
880    assert(VP8LPredictorsSub[2] != NULL);
881    assert(VP8LPredictorsSub[3] != NULL);
882    assert(VP8LPredictorsSub[4] != NULL);
883    assert(VP8LPredictorsSub[5] != NULL);
884    assert(VP8LPredictorsSub[6] != NULL);
885    assert(VP8LPredictorsSub[7] != NULL);
886    assert(VP8LPredictorsSub[8] != NULL);
887    assert(VP8LPredictorsSub[9] != NULL);
888    assert(VP8LPredictorsSub[10] != NULL);
889    assert(VP8LPredictorsSub[11] != NULL);
890    assert(VP8LPredictorsSub[12] != NULL);
891    assert(VP8LPredictorsSub[13] != NULL);
892    assert(VP8LPredictorsSub[14] != NULL);
893    assert(VP8LPredictorsSub[15] != NULL);
894    assert(VP8LPredictorsSub_C[0] != NULL);
895    assert(VP8LPredictorsSub_C[1] != NULL);
896    assert(VP8LPredictorsSub_C[2] != NULL);
897    assert(VP8LPredictorsSub_C[3] != NULL);
898    assert(VP8LPredictorsSub_C[4] != NULL);
899    assert(VP8LPredictorsSub_C[5] != NULL);
900    assert(VP8LPredictorsSub_C[6] != NULL);
901    assert(VP8LPredictorsSub_C[7] != NULL);
902    assert(VP8LPredictorsSub_C[8] != NULL);
903    assert(VP8LPredictorsSub_C[9] != NULL);
904    assert(VP8LPredictorsSub_C[10] != NULL);
905    assert(VP8LPredictorsSub_C[11] != NULL);
906    assert(VP8LPredictorsSub_C[12] != NULL);
907    assert(VP8LPredictorsSub_C[13] != NULL);
908    assert(VP8LPredictorsSub_C[14] != NULL);
909    assert(VP8LPredictorsSub_C[15] != NULL);
910  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from libtomcrypt-MDEwOlJlcG9zaXRvcnk3NzcwMTE=-flat-tomcrypt_math.h</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from PINRemoteImage-MDEwOlJlcG9zaXRvcnkzOTUzNzEwMw==-flat-lossless_enc.c</div>
                </div>
                <div class="column column_space"><pre><code>17     const char *name;
18     int  bits_per_digit;
19     int (*init)(void **a);
20     int (*init_copy)(void **dst, void *src);
21     void (*deinit)(void *a);
22     int (*neg)(void *src, void *dst);
23     int (*copy)(void *src, void *dst);
</pre></code></div>
                <div class="column column_space"><pre><code>756  VP8LProcessEncBlueAndRedFunc VP8LSubtractGreenFromBlueAndRed;
757  VP8LTransformColorFunc VP8LTransformColor;
758  VP8LCollectColorBlueTransformsFunc VP8LCollectColorBlueTransforms;
759  VP8LCollectColorRedTransformsFunc VP8LCollectColorRedTransforms;
760  VP8LFastLog2SlowFunc VP8LFastLog2Slow;
761  VP8LFastLog2SlowFunc VP8LFastSLog2Slow;
762  VP8LCostFunc VP8LExtraCost;
763  VP8LCostCombinedFunc VP8LExtraCostCombined;
764  VP8LCombinedShannonEntropyFunc VP8LCombinedShannonEntropy;
765  VP8LGetEntropyUnrefinedFunc VP8LGetEntropyUnrefined;
766  VP8LGetCombinedEntropyUnrefinedFunc VP8LGetCombinedEntropyUnrefined;
767  VP8LAddVectorFunc VP8LAddVector;
768  VP8LAddVectorEqFunc VP8LAddVectorEq;
769  VP8LVectorMismatchFunc VP8LVectorMismatch;
770  VP8LBundleColorMapFunc VP8LBundleColorMap;
771  VP8LPredictorAddSubFunc VP8LPredictorsSub[16];
772  VP8LPredictorAddSubFunc VP8LPredictorsSub_C[16];
773  extern void VP8LEncDspInitSSE2(void);
774  extern void VP8LEncDspInitSSE41(void);
775  extern void VP8LEncDspInitNEON(void);
776  extern void VP8LEncDspInitMIPS32(void);
777  extern void VP8LEncDspInitMIPSdspR2(void);
778  extern void VP8LEncDspInitMSA(void);
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    