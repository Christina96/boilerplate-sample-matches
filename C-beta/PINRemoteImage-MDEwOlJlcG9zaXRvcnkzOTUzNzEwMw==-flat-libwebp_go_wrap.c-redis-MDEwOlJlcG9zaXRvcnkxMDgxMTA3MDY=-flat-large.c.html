
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 6.7164179104477615%, Tokens: 8, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>PINRemoteImage-MDEwOlJlcG9zaXRvcnkzOTUzNzEwMw==-flat-libwebp_go_wrap.c</h3>
            <pre><code>1  #define SWIGMODULE libwebp
2  #ifndef SWIGTEMPLATEDISAMBIGUATOR
3  # if defined(__SUNPRO_CC) && (__SUNPRO_CC <= 0x560)
4  #  define SWIGTEMPLATEDISAMBIGUATOR template
5  # elif defined(__HP_aCC)
6  #  define SWIGTEMPLATEDISAMBIGUATOR template
7  # else
8  #  define SWIGTEMPLATEDISAMBIGUATOR
9  # endif
10  #endif
11  #ifndef SWIGINLINE
12  # if defined(__cplusplus) || (defined(__GNUC__) && !defined(__STRICT_ANSI__))
13  #   define SWIGINLINE inline
14  # else
15  #   define SWIGINLINE
16  # endif
17  #endif
18  #ifndef SWIGUNUSED
19  # if defined(__GNUC__)
20  #   if !(defined(__cplusplus)) || (__GNUC__ > 3 || (__GNUC__ == 3 && __GNUC_MINOR__ >= 4))
21  #     define SWIGUNUSED __attribute__ ((__unused__))
22  #   else
23  #     define SWIGUNUSED
24  #   endif
25  # elif defined(__ICC)
26  #   define SWIGUNUSED __attribute__ ((__unused__))
27  # else
28  #   define SWIGUNUSED
29  # endif
30  #endif
31  #ifndef SWIG_MSC_UNSUPPRESS_4505
32  # if defined(_MSC_VER)
33  #   pragma warning(disable : 4505) &bsol;* unreferenced local function has been removed */
34  # endif
35  #endif
36  #ifndef SWIGUNUSEDPARM
37  # ifdef __cplusplus
38  #   define SWIGUNUSEDPARM(p)
39  # else
40  #   define SWIGUNUSEDPARM(p) p SWIGUNUSED
41  # endif
42  #endif
43  #ifndef SWIGINTERN
44  # define SWIGINTERN static SWIGUNUSED
45  #endif
46  #ifndef SWIGINTERNINLINE
47  # define SWIGINTERNINLINE SWIGINTERN SWIGINLINE
48  #endif
49  #if (__GNUC__ >= 4) || (__GNUC__ == 3 && __GNUC_MINOR__ >= 4)
50  #  ifndef GCC_HASCLASSVISIBILITY
51  #    define GCC_HASCLASSVISIBILITY
52  #  endif
53  #endif
54  #ifndef SWIGEXPORT
55  # if defined(_WIN32) || defined(__WIN32__) || defined(__CYGWIN__)
56  #   if defined(STATIC_LINKED)
57  #     define SWIGEXPORT
58  #   else
59  #     define SWIGEXPORT __declspec(dllexport)
60  #   endif
61  # else
62  #   if defined(__GNUC__) && defined(GCC_HASCLASSVISIBILITY)
63  #     define SWIGEXPORT __attribute__ ((visibility("default")))
64  #   else
65  #     define SWIGEXPORT
66  #   endif
67  # endif
68  #endif
69  #ifndef SWIGSTDCALL
70  # if defined(_WIN32) || defined(__WIN32__) || defined(__CYGWIN__)
71  #   define SWIGSTDCALL __stdcall
72  # else
73  #   define SWIGSTDCALL
74  # endif
75  #endif
76  #if !defined(SWIG_NO_CRT_SECURE_NO_DEPRECATE) && defined(_MSC_VER) && !defined(_CRT_SECURE_NO_DEPRECATE)
77  # define _CRT_SECURE_NO_DEPRECATE
78  #endif
79  #if !defined(SWIG_NO_SCL_SECURE_NO_DEPRECATE) && defined(_MSC_VER) && !defined(_SCL_SECURE_NO_DEPRECATE)
80  # define _SCL_SECURE_NO_DEPRECATE
81  #endif
82  #include <stddef.h>
83  #include <stdio.h>
84  #include <stdlib.h>
85  #include <string.h>
86  #include <sys/types.h>
87  typedef long long intgo;
88  typedef unsigned long long uintgo;
89  typedef struct { char *p; intgo n; } _gostring_;
90  typedef struct { void* array; intgo len; intgo cap; } _goslice_;
91  #define swiggo_size_assert_eq(x, y, name) typedef char name[(x-y)*(x-y)*-2+1];
92  #define swiggo_size_assert(t, n) swiggo_size_assert_eq(sizeof(t), n, swiggo_sizeof_##t##_is_not_##n)
93  swiggo_size_assert(char, 1)
94  swiggo_size_assert(short, 2)
95  swiggo_size_assert(int, 4)
96  typedef long long swiggo_long_long;
97  swiggo_size_assert(swiggo_long_long, 8)
98  swiggo_size_assert(float, 4)
99  swiggo_size_assert(double, 8)
100  #ifdef __cplusplus
101  extern "C" {
102  #endif
103  extern void crosscall2(void (*fn)(void *, int), void *, int);
104  extern void _cgo_allocate(void *, int);
105  extern void _cgo_panic(void *, int);
106  #ifdef __cplusplus
107  }
108  #endif
109  static void *_swig_goallocate(size_t len) {
110    struct {
111      size_t len;
112      void *ret;
113    } a;
114    a.len = len;
115    crosscall2(_cgo_allocate, &a, (int) sizeof a);
116    return a.ret;
117  }
118  static void _swig_gopanic(const char *p) {
119    struct {
120      const char *p;
121    } a;
122    a.p = p;
<span onclick='openModal()' class='match'>123    crosscall2(_cgo_panic, &a, (int) sizeof a);
124  }
125  static _gostring_ _swig_makegostring(const char *p, size_t l) {
126    _gostring_ ret;
127    ret.p = (char*)_swig_goallocate(l + 1);
</span>128    memcpy(ret.p, p, l);
129    ret.n = l;
130    return ret;
131  }
132  #define SWIG_contract_assert(expr, msg) \
133    if (!(expr)) { _swig_gopanic(msg); } else
134  #define SWIG_exception(code, msg) _swig_gopanic(msg)
135  #include "webp/decode.h"
136  #include "webp/encode.h"
137  #ifdef __cplusplus
138  extern "C" {
139  #endif
140  void
141  _wrap_WebPGetDecoderVersion(void *swig_v)
142  {
143    int result;
144    struct swigargs {
145      long : 0;
146      intgo result;
147    } *swig_a = (struct swigargs *) swig_v;
148    result = (int)WebPGetDecoderVersion();
149    swig_a->result = result;
150  }
151  void
152  _wrap_wrapped_WebPGetInfo(void *swig_v)
153  {
154    uint8_t *arg1 = (uint8_t *) 0 ;
155    size_t arg2 ;
156    int *arg3 = (int *) 0 ;
157    int *arg4 = (int *) 0 ;
158    int temp3 ;
159    int temp4 ;
160    int result;
161    struct swigargs {
162      _gostring_ arg1;
163      _goslice_ arg3;
164      _goslice_ arg4;
165      long : 0;
166      intgo result;
167    } *swig_a = (struct swigargs *) swig_v;
168    arg1 = (uint8_t *)swig_a->arg1.p;
169    arg2 = (size_t)swig_a->arg1.n;
170    {
171      if (swig_a->arg3.len == 0) {
172        _swig_gopanic("array must contain at least 1 element");
173      }
174      arg3 = &temp3;
175    }
176    {
177      if (swig_a->arg4.len == 0) {
178        _swig_gopanic("array must contain at least 1 element");
179      }
180      arg4 = &temp4;
181    }
182    result = (int)WebPGetInfo((uint8_t const *)arg1,arg2,arg3,arg4);
183    swig_a->result = result;
184    {
185      int* a = (int *) swig_a->arg3.array;
186      a[0] = temp3;
187    }
188    {
189      int* a = (int *) swig_a->arg4.array;
190      a[0] = temp4;
191    }
192  }
193  #ifdef __cplusplus
194  }
195  #endif
</code></pre>
        </div>
        <div class="column">
            <h3>redis-MDEwOlJlcG9zaXRvcnkxMDgxMTA3MDY=-flat-large.c</h3>
            <pre><code>1  #define JEMALLOC_LARGE_C_
2  #include "jemalloc/internal/jemalloc_preamble.h"
3  #include "jemalloc/internal/jemalloc_internal_includes.h"
4  #include "jemalloc/internal/assert.h"
5  #include "jemalloc/internal/extent_mmap.h"
6  #include "jemalloc/internal/mutex.h"
7  #include "jemalloc/internal/rtree.h"
8  #include "jemalloc/internal/util.h"
9  void *
10  large_malloc(tsdn_t *tsdn, arena_t *arena, size_t usize, bool zero) {
11  	assert(usize == sz_s2u(usize));
12  	return large_palloc(tsdn, arena, usize, CACHELINE, zero);
13  }
14  void *
15  large_palloc(tsdn_t *tsdn, arena_t *arena, size_t usize, size_t alignment,
16      bool zero) {
17  	size_t ausize;
18  	extent_t *extent;
19  	bool is_zeroed;
20  	UNUSED bool idump JEMALLOC_CC_SILENCE_INIT(false);
21  	assert(!tsdn_null(tsdn) || arena != NULL);
22  	ausize = sz_sa2u(usize, alignment);
23  	if (unlikely(ausize == 0 || ausize > SC_LARGE_MAXCLASS)) {
24  		return NULL;
25  	}
26  	if (config_fill && unlikely(opt_zero)) {
27  		zero = true;
28  	}
29  	is_zeroed = zero;
30  	if (likely(!tsdn_null(tsdn))) {
31  		arena = arena_choose_maybe_huge(tsdn_tsd(tsdn), arena, usize);
32  	}
33  	if (unlikely(arena == NULL) || (extent = arena_extent_alloc_large(tsdn,
34  	    arena, usize, alignment, &is_zeroed)) == NULL) {
35  		return NULL;
36  	}
37  	if (!arena_is_auto(arena)) {
38  		malloc_mutex_lock(tsdn, &arena->large_mtx);
39  		extent_list_append(&arena->large, extent);
40  		malloc_mutex_unlock(tsdn, &arena->large_mtx);
41  	}
42  	if (config_prof && arena_prof_accum(tsdn, arena, usize)) {
43  		prof_idump(tsdn);
44  	}
45  	if (zero) {
46  		assert(is_zeroed);
47  	} else if (config_fill && unlikely(opt_junk_alloc)) {
48  		memset(extent_addr_get(extent), JEMALLOC_ALLOC_JUNK,
49  		    extent_usize_get(extent));
50  	}
51  	arena_decay_tick(tsdn, arena);
52  	return extent_addr_get(extent);
53  }
54  static void
55  large_dalloc_junk_impl(void *ptr, size_t size) {
56  	memset(ptr, JEMALLOC_FREE_JUNK, size);
57  }
58  large_dalloc_junk_t *JET_MUTABLE large_dalloc_junk = large_dalloc_junk_impl;
59  static void
60  large_dalloc_maybe_junk_impl(void *ptr, size_t size) {
61  	if (config_fill && have_dss && unlikely(opt_junk_free)) {
62  		if (opt_retain || (have_dss && extent_in_dss(ptr))) {
63  			large_dalloc_junk(ptr, size);
64  		}
65  	}
66  }
67  large_dalloc_maybe_junk_t *JET_MUTABLE large_dalloc_maybe_junk =
68      large_dalloc_maybe_junk_impl;
69  static bool
70  large_ralloc_no_move_shrink(tsdn_t *tsdn, extent_t *extent, size_t usize) {
71  	arena_t *arena = extent_arena_get(extent);
72  	size_t oldusize = extent_usize_get(extent);
73  	extent_hooks_t *extent_hooks = extent_hooks_get(arena);
74  	size_t diff = extent_size_get(extent) - (usize + sz_large_pad);
75  	assert(oldusize > usize);
76  	if (extent_hooks->split == NULL) {
77  		return true;
78  	}
79  	if (diff != 0) {
80  		extent_t *trail = extent_split_wrapper(tsdn, arena,
81  		    &extent_hooks, extent, usize + sz_large_pad,
82  		    sz_size2index(usize), false, diff, SC_NSIZES, false);
83  		if (trail == NULL) {
84  			return true;
85  		}
86  		if (config_fill && unlikely(opt_junk_free)) {
87  			large_dalloc_maybe_junk(extent_addr_get(trail),
88  			    extent_size_get(trail));
89  		}
90  		arena_extents_dirty_dalloc(tsdn, arena, &extent_hooks, trail);
91  	}
92  	arena_extent_ralloc_large_shrink(tsdn, arena, extent, oldusize);
93  	return false;
94  }
95  static bool
96  large_ralloc_no_move_expand(tsdn_t *tsdn, extent_t *extent, size_t usize,
97      bool zero) {
98  	arena_t *arena = extent_arena_get(extent);
99  	size_t oldusize = extent_usize_get(extent);
100  	extent_hooks_t *extent_hooks = extent_hooks_get(arena);
101  	size_t trailsize = usize - oldusize;
102  	if (extent_hooks->merge == NULL) {
103  		return true;
104  	}
105  	if (config_fill && unlikely(opt_zero)) {
106  		zero = true;
107  	}
108  	bool is_zeroed_trail = zero;
109  	bool commit = true;
110  	extent_t *trail;
111  	bool new_mapping;
112  	if ((trail = extents_alloc(tsdn, arena, &extent_hooks,
113  	    &arena->extents_dirty, extent_past_get(extent), trailsize, 0,
114  	    CACHELINE, false, SC_NSIZES, &is_zeroed_trail, &commit)) != NULL
115  	    || (trail = extents_alloc(tsdn, arena, &extent_hooks,
116  	    &arena->extents_muzzy, extent_past_get(extent), trailsize, 0,
117  	    CACHELINE, false, SC_NSIZES, &is_zeroed_trail, &commit)) != NULL) {
118  		if (config_stats) {
119  			new_mapping = false;
120  		}
121  	} else {
122  		if ((trail = extent_alloc_wrapper(tsdn, arena, &extent_hooks,
123  		    extent_past_get(extent), trailsize, 0, CACHELINE, false,
124  		    SC_NSIZES, &is_zeroed_trail, &commit)) == NULL) {
125  			return true;
126  		}
127  		if (config_stats) {
128  			new_mapping = true;
129  		}
130  	}
131  	if (extent_merge_wrapper(tsdn, arena, &extent_hooks, extent, trail)) {
132  		extent_dalloc_wrapper(tsdn, arena, &extent_hooks, trail);
133  		return true;
134  	}
135  	rtree_ctx_t rtree_ctx_fallback;
136  	rtree_ctx_t *rtree_ctx = tsdn_rtree_ctx(tsdn, &rtree_ctx_fallback);
137  	szind_t szind = sz_size2index(usize);
138  	extent_szind_set(extent, szind);
139  	rtree_szind_slab_update(tsdn, &extents_rtree, rtree_ctx,
140  	    (uintptr_t)extent_addr_get(extent), szind, false);
141  	if (config_stats && new_mapping) {
142  		arena_stats_mapped_add(tsdn, &arena->stats, trailsize);
143  	}
144  	if (zero) {
145  		if (config_cache_oblivious) {
146  			void *zbase = (void *)
147  			    ((uintptr_t)extent_addr_get(extent) + oldusize);
148  			void *zpast = PAGE_ADDR2BASE((void *)((uintptr_t)zbase +
149  			    PAGE));
150  			size_t nzero = (uintptr_t)zpast - (uintptr_t)zbase;
151  			assert(nzero > 0);
152  			memset(zbase, 0, nzero);
153  		}
154  		assert(is_zeroed_trail);
155  	} else if (config_fill && unlikely(opt_junk_alloc)) {
156  		memset((void *)((uintptr_t)extent_addr_get(extent) + oldusize),
157  		    JEMALLOC_ALLOC_JUNK, usize - oldusize);
158  	}
159  	arena_extent_ralloc_large_expand(tsdn, arena, extent, oldusize);
160  	return false;
161  }
162  bool
163  large_ralloc_no_move(tsdn_t *tsdn, extent_t *extent, size_t usize_min,
164      size_t usize_max, bool zero) {
165  	size_t oldusize = extent_usize_get(extent);
166  	assert(usize_min > 0 && usize_max <= SC_LARGE_MAXCLASS);
167  	assert(oldusize >= SC_LARGE_MINCLASS
168  	    && usize_max >= SC_LARGE_MINCLASS);
169  	if (usize_max > oldusize) {
170  		if (!large_ralloc_no_move_expand(tsdn, extent, usize_max,
171  		    zero)) {
172  			arena_decay_tick(tsdn, extent_arena_get(extent));
173  			return false;
174  		}
175  		if (usize_min < usize_max && usize_min > oldusize &&
176  		    large_ralloc_no_move_expand(tsdn, extent, usize_min,
177  		    zero)) {
178  			arena_decay_tick(tsdn, extent_arena_get(extent));
179  			return false;
180  		}
181  	}
182  	if (oldusize >= usize_min && oldusize <= usize_max) {
183  		arena_decay_tick(tsdn, extent_arena_get(extent));
184  		return false;
185  	}
186  	if (oldusize > usize_max) {
187  		if (!large_ralloc_no_move_shrink(tsdn, extent, usize_max)) {
188  			arena_decay_tick(tsdn, extent_arena_get(extent));
189  			return false;
190  		}
191  	}
192  	return true;
193  }
194  static void *
195  large_ralloc_move_helper(tsdn_t *tsdn, arena_t *arena, size_t usize,
196      size_t alignment, bool zero) {
197  	if (alignment <= CACHELINE) {
198  		return large_malloc(tsdn, arena, usize, zero);
199  	}
200  	return large_palloc(tsdn, arena, usize, alignment, zero);
201  }
202  void *
203  large_ralloc(tsdn_t *tsdn, arena_t *arena, void *ptr, size_t usize,
204      size_t alignment, bool zero, tcache_t *tcache,
205      hook_ralloc_args_t *hook_args) {
206  	extent_t *extent = iealloc(tsdn, ptr);
207  	size_t oldusize = extent_usize_get(extent);
208  	assert(usize > 0 && usize <= SC_LARGE_MAXCLASS);
209  	assert(oldusize >= SC_LARGE_MINCLASS
210  	    && usize >= SC_LARGE_MINCLASS);
211  	if (!large_ralloc_no_move(tsdn, extent, usize, usize, zero)) {
212  		hook_invoke_expand(hook_args->is_realloc
213  		    ? hook_expand_realloc : hook_expand_rallocx, ptr, oldusize,
214  		    usize, (uintptr_t)ptr, hook_args->args);
215  		return extent_addr_get(extent);
216  	}
217  	void *ret = large_ralloc_move_helper(tsdn, arena, usize, alignment,
218  	    zero);
219  	if (ret == NULL) {
220  		return NULL;
221  	}
222  	hook_invoke_alloc(hook_args->is_realloc
223  	    ? hook_alloc_realloc : hook_alloc_rallocx, ret, (uintptr_t)ret,
224  	    hook_args->args);
225  	hook_invoke_dalloc(hook_args->is_realloc
226  	    ? hook_dalloc_realloc : hook_dalloc_rallocx, ptr, hook_args->args);
227  	size_t copysize = (usize < oldusize) ? usize : oldusize;
228  	memcpy(ret, extent_addr_get(extent), copysize);
229  	isdalloct(tsdn, extent_addr_get(extent), oldusize, tcache, NULL, true);
230  	return ret;
231  }
232  static void
233  large_dalloc_prep_impl(tsdn_t *tsdn, arena_t *arena, extent_t *extent,
234      bool junked_locked) {
235  	if (!junked_locked) {
236  		if (!arena_is_auto(arena)) {
237  			malloc_mutex_lock(tsdn, &arena->large_mtx);
238  			extent_list_remove(&arena->large, extent);
239  			malloc_mutex_unlock(tsdn, &arena->large_mtx);
240  		}
241  		large_dalloc_maybe_junk(extent_addr_get(extent),
242  		    extent_usize_get(extent));
243  	} else {
244  		if (!arena_is_auto(arena)) {
245  			malloc_mutex_assert_owner(tsdn, &arena->large_mtx);
246  			extent_list_remove(&arena->large, extent);
247  		}
248  	}
249  	arena_extent_dalloc_large_prep(tsdn, arena, extent);
250  }
251  static void
252  large_dalloc_finish_impl(tsdn_t *tsdn, arena_t *arena, extent_t *extent) {
253  	extent_hooks_t *extent_hooks = EXTENT_HOOKS_INITIALIZER;
254  	arena_extents_dirty_dalloc(tsdn, arena, &extent_hooks, extent);
255  }
256  void
257  large_dalloc_prep_junked_locked(tsdn_t *tsdn, extent_t *extent) {
258  	large_dalloc_prep_impl(tsdn, extent_arena_get(extent), extent, true);
259  }
260  void
261  large_dalloc_finish(tsdn_t *tsdn, extent_t *extent) {
<span onclick='openModal()' class='match'>262  	large_dalloc_finish_impl(tsdn, extent_arena_get(extent), extent);
263  }
264  void
265  large_dalloc(tsdn_t *tsdn, extent_t *extent) {
266  	arena_t *arena = extent_arena_get(extent);
</span>267  	large_dalloc_prep_impl(tsdn, arena, extent, false);
268  	large_dalloc_finish_impl(tsdn, arena, extent);
269  	arena_decay_tick(tsdn, arena);
270  }
271  size_t
272  large_salloc(tsdn_t *tsdn, const extent_t *extent) {
273  	return extent_usize_get(extent);
274  }
275  prof_tctx_t *
276  large_prof_tctx_get(tsdn_t *tsdn, const extent_t *extent) {
277  	return extent_prof_tctx_get(extent);
278  }
279  void
280  large_prof_tctx_set(tsdn_t *tsdn, extent_t *extent, prof_tctx_t *tctx) {
281  	extent_prof_tctx_set(extent, tctx);
282  }
283  void
284  large_prof_tctx_reset(tsdn_t *tsdn, extent_t *extent) {
285  	large_prof_tctx_set(tsdn, extent, (prof_tctx_t *)(uintptr_t)1U);
286  }
287  nstime_t
288  large_prof_alloc_time_get(const extent_t *extent) {
289  	return extent_prof_alloc_time_get(extent);
290  }
291  void
292  large_prof_alloc_time_set(extent_t *extent, nstime_t t) {
293  	extent_prof_alloc_time_set(extent, t);
294  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from PINRemoteImage-MDEwOlJlcG9zaXRvcnkzOTUzNzEwMw==-flat-libwebp_go_wrap.c</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from redis-MDEwOlJlcG9zaXRvcnkxMDgxMTA3MDY=-flat-large.c</div>
                </div>
                <div class="column column_space"><pre><code>123    crosscall2(_cgo_panic, &a, (int) sizeof a);
124  }
125  static _gostring_ _swig_makegostring(const char *p, size_t l) {
126    _gostring_ ret;
127    ret.p = (char*)_swig_goallocate(l + 1);
</pre></code></div>
                <div class="column column_space"><pre><code>262  	large_dalloc_finish_impl(tsdn, extent_arena_get(extent), extent);
263  }
264  void
265  large_dalloc(tsdn_t *tsdn, extent_t *extent) {
266  	arena_t *arena = extent_arena_get(extent);
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    