
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 15.617128463476071%, Tokens: 11, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>Adafruit_nRF52_Arduino-MDEwOlJlcG9zaXRvcnk3NDM1NDcyOQ==-flat-nrfx_usbd.h</h3>
            <pre><code>1  #ifndef NRFX_USBD_H__
2  #define NRFX_USBD_H__
3  #include <nrfx.h>
4  #include <hal/nrf_usbd.h>
5  #ifdef __cplusplus
6  extern "C" {
7  #endif
8  #define NRFX_USBD_EPSIZE 64
9  #define NRFX_USBD_ISOSIZE 1024
10  #define NRFX_USBD_FEEDER_BUFFER_SIZE NRFX_USBD_EPSIZE
11  #define NRFX_USBD_EPIN(n)   ((nrfx_usbd_ep_t)NRF_USBD_EPIN(n))
12  #define NRFX_USBD_EPOUT(n)  ((nrfx_usbd_ep_t)NRF_USBD_EPOUT(n))
13  typedef enum
14  {
15      NRFX_USBD_EPOUT0 = NRF_USBD_EPOUT(0), &bsol;**< Endpoint OUT 0 */
16      NRFX_USBD_EPOUT1 = NRF_USBD_EPOUT(1), &bsol;**< Endpoint OUT 1 */
17      NRFX_USBD_EPOUT2 = NRF_USBD_EPOUT(2), &bsol;**< Endpoint OUT 2 */
18      NRFX_USBD_EPOUT3 = NRF_USBD_EPOUT(3), &bsol;**< Endpoint OUT 3 */
19      NRFX_USBD_EPOUT4 = NRF_USBD_EPOUT(4), &bsol;**< Endpoint OUT 4 */
20      NRFX_USBD_EPOUT5 = NRF_USBD_EPOUT(5), &bsol;**< Endpoint OUT 5 */
21      NRFX_USBD_EPOUT6 = NRF_USBD_EPOUT(6), &bsol;**< Endpoint OUT 6 */
22      NRFX_USBD_EPOUT7 = NRF_USBD_EPOUT(7), &bsol;**< Endpoint OUT 7 */
23      NRFX_USBD_EPOUT8 = NRF_USBD_EPOUT(8), &bsol;**< Endpoint OUT 8 */
24      NRFX_USBD_EPIN0  = NRF_USBD_EPIN(0), &bsol;**< Endpoint IN 0 */
25      NRFX_USBD_EPIN1  = NRF_USBD_EPIN(1), &bsol;**< Endpoint IN 1 */
26      NRFX_USBD_EPIN2  = NRF_USBD_EPIN(2), &bsol;**< Endpoint IN 2 */
27      NRFX_USBD_EPIN3  = NRF_USBD_EPIN(3), &bsol;**< Endpoint IN 3 */
28      NRFX_USBD_EPIN4  = NRF_USBD_EPIN(4), &bsol;**< Endpoint IN 4 */
29      NRFX_USBD_EPIN5  = NRF_USBD_EPIN(5), &bsol;**< Endpoint IN 5 */
30      NRFX_USBD_EPIN6  = NRF_USBD_EPIN(6), &bsol;**< Endpoint IN 6 */
31      NRFX_USBD_EPIN7  = NRF_USBD_EPIN(7), &bsol;**< Endpoint IN 7 */
32      NRFX_USBD_EPIN8  = NRF_USBD_EPIN(8), &bsol;**< Endpoint IN 8 */
33  } nrfx_usbd_ep_t;
34  typedef enum
35  {
36      NRFX_USBD_EVT_SOF,        &bsol;**< Start Of Frame event on USB bus detected. */
37      NRFX_USBD_EVT_RESET,      &bsol;**< Reset condition on USB bus detected. */
38      NRFX_USBD_EVT_SUSPEND,    &bsol;**< This device should go to suspend mode now. */
39      NRFX_USBD_EVT_RESUME,     &bsol;**< This device should resume from suspend now. */
40      NRFX_USBD_EVT_WUREQ,      &bsol;**< Wakeup request - the USBD peripheral is ready to generate
41  	                               WAKEUP signal after exiting low power mode. */
42      NRFX_USBD_EVT_SETUP,      &bsol;**< Setup frame received and decoded. */
<span onclick='openModal()' class='match'>43      NRFX_USBD_EVT_EPTRANSFER, &bsol;**< For Rx (OUT: Host->Device):
44                                 *   1. The packet has been received but there is no buffer prepared for transfer already.
</span>45                                 *   2. Whole transfer has been finished.
46                                 *
47                                 *   For Tx (IN: Device->Host):
48                                 *   The last packet from requested transfer has been transfered over USB bus and acknowledged.
49                                 */
50      NRFX_USBD_EVT_CNT         &bsol;**< Number of defined events. */
51  } nrfx_usbd_event_type_t;
52  typedef enum
53  {
54      NRFX_USBD_EP_OK,       &bsol;**< No error occured. */
55      NRFX_USBD_EP_WAITING,  &bsol;**< Data received, no buffer prepared already - waiting for configured transfer. */
56      NRFX_USBD_EP_OVERLOAD, &bsol;**< Received number of bytes cannot fit given buffer.
57                              *   This error would also be returned when next_transfer function has been defined
58                              *   but currently received data cannot fit completely in current buffer.
59                              *   No data split from single endpoint transmission is supported.
60                              *
61                              *   When this error is reported - data is left inside endpoint buffer.
62                              *   Clear endpoint or prepare new buffer and read it.
63                              */
64      NRFX_USBD_EP_ABORTED,  &bsol;**< EP0 transfer can be aborted when new setup comes.
65                              *   Any other transfer can be aborted by USB reset or driver stopping.
66                              */
67      NRFX_USBD_EP_BUSY,     &bsol;**< Transfer is in progress. */
68  } nrfx_usbd_ep_status_t;
69  typedef struct
70  {
71      nrfx_usbd_event_type_t type;          &bsol;**< Event type. */
72      union
73      {
74          struct {
75              uint16_t framecnt;            &bsol;**< Current value of frame counter. */
76          } sof;                            &bsol;**< Data available for @ref NRFX_USBD_EVT_SOF. */
77          struct {
78              nrfx_usbd_ep_t        ep;     &bsol;**< Endpoint number. */
79          } isocrc;                         &bsol;**< Isochronouns channel endpoint number. */
80          struct {
81              nrfx_usbd_ep_t        ep;     &bsol;**< Endpoint number. */
82              nrfx_usbd_ep_status_t status; &bsol;**< Status for the endpoint. */
83          } eptransfer;                     &bsol;**< Endpoint transfer status. */
84      } data;                               &bsol;**< Union to store event data. */
85  } nrfx_usbd_evt_t;
86  typedef void (*nrfx_usbd_event_handler_t)(nrfx_usbd_evt_t const * p_event);
87  typedef union
88  {
89      void const * tx; 
90      void * rx;       
91      uint32_t addr;   
92  } nrfx_usbd_data_ptr_t;
93  typedef struct
94  {
95      nrfx_usbd_data_ptr_t p_data; 
96      size_t size;                 
97  } nrfx_usbd_ep_transfer_t;
98  typedef enum
99  {
100      NRFX_USBD_TRANSFER_ZLP_FLAG = 1U << 0, 
101  } nrfx_usbd_transfer_flags_t;
102  typedef struct
103  {
104      nrfx_usbd_data_ptr_t p_data; 
105      size_t size;                 
106      uint32_t flags;              
107  } nrfx_usbd_transfer_t;
108  #define NRFX_USBD_TRANSFER_IN(name, tx_buff, tx_size, tx_flags) \
109      const nrfx_usbd_transfer_t name = {                         \
110         .p_data = { .tx = (tx_buff)  },                          \
111         .size = (tx_size),                                       \
112         .flags = (tx_flags)                                      \
113      }
114  #define NRFX_USBD_TRANSFER_OUT(name, rx_buff, rx_size) \
115      const nrfx_usbd_transfer_t name = {                \
116         .p_data = { .rx = (rx_buff)  },                 \
117         .size = (rx_size),                              \
118         .flags = 0                                      \
119      }
120  typedef bool (*nrfx_usbd_feeder_t)(nrfx_usbd_ep_transfer_t * p_next,
121                                     void * p_context,
122                                     size_t ep_size);
123  typedef bool (*nrfx_usbd_consumer_t)(nrfx_usbd_ep_transfer_t * p_next,
124                                       void * p_context,
125                                       size_t ep_size,
126                                       size_t data_size);
127  typedef union
128  {
129      nrfx_usbd_feeder_t   feeder;   
130      nrfx_usbd_consumer_t consumer; 
131  } nrfx_usbd_handler_t;
132  typedef struct
133  {
134      nrfx_usbd_handler_t handler;   
135      void *              p_context; 
136  } nrfx_usbd_handler_desc_t;
137  typedef struct
138  {
139      uint8_t  bmRequestType; 
140      uint8_t  bRequest;      
141      uint16_t wValue;        
142      uint16_t wIndex;        
143      uint16_t wLength;       
144  } nrfx_usbd_setup_t;
145  nrfx_err_t nrfx_usbd_init(nrfx_usbd_event_handler_t event_handler);
146  void nrfx_usbd_uninit(void);
147  void nrfx_usbd_enable(void);
148  void nrfx_usbd_disable(void);
149  void nrfx_usbd_start(bool enable_sof);
150  void nrfx_usbd_stop(void);
151  bool nrfx_usbd_is_initialized(void);
152  bool nrfx_usbd_is_enabled(void);
153  bool nrfx_usbd_is_started(void);
154  bool nrfx_usbd_suspend(void);
155  bool nrfx_usbd_wakeup_req(void);
156  bool nrfx_usbd_suspend_check(void);
157  void nrfx_usbd_suspend_irq_config(void);
158  void nrfx_usbd_active_irq_config(void);
159  bool nrfx_usbd_bus_suspend_check(void);
160  void nrfx_usbd_force_bus_wakeup(void);
161  void nrfx_usbd_ep_max_packet_size_set(nrfx_usbd_ep_t ep, uint16_t size);
162  uint16_t nrfx_usbd_ep_max_packet_size_get(nrfx_usbd_ep_t ep);
163  bool nrfx_usbd_ep_enable_check(nrfx_usbd_ep_t ep);
164  void nrfx_usbd_ep_enable(nrfx_usbd_ep_t ep);
165  void nrfx_usbd_ep_disable(nrfx_usbd_ep_t ep);
166  void nrfx_usbd_ep_default_config(void);
167  nrfx_err_t nrfx_usbd_ep_transfer(nrfx_usbd_ep_t ep,
168                                   nrfx_usbd_transfer_t const * p_transfer);
169  nrfx_err_t nrfx_usbd_ep_handled_transfer(nrfx_usbd_ep_t ep,
170                                           nrfx_usbd_handler_desc_t const * p_handler);
171  void * nrfx_usbd_feeder_buffer_get(void);
172  nrfx_usbd_ep_status_t nrfx_usbd_ep_status_get(nrfx_usbd_ep_t ep, size_t * p_size);
173  size_t nrfx_usbd_epout_size_get(nrfx_usbd_ep_t ep);
174  bool nrfx_usbd_ep_is_busy(nrfx_usbd_ep_t ep);
175  void nrfx_usbd_ep_stall(nrfx_usbd_ep_t ep);
176  void nrfx_usbd_ep_stall_clear(nrfx_usbd_ep_t ep);
177  bool nrfx_usbd_ep_stall_check(nrfx_usbd_ep_t ep);
178  void nrfx_usbd_ep_dtoggle_clear(nrfx_usbd_ep_t ep);
179  void nrfx_usbd_setup_get(nrfx_usbd_setup_t * p_setup);
180  void nrfx_usbd_setup_data_clear(void);
181  void nrfx_usbd_setup_clear(void);
182  void nrfx_usbd_setup_stall(void);
183  void nrfx_usbd_ep_abort(nrfx_usbd_ep_t ep);
184  nrfx_usbd_ep_t nrfx_usbd_last_setup_dir_get(void);
185  void nrfx_usbd_transfer_out_drop(nrfx_usbd_ep_t ep);
186  void nrfx_usbd_irq_handler(void);
187  #ifdef __cplusplus
188  }
189  #endif
190  #endif 
</code></pre>
        </div>
        <div class="column">
            <h3>fftw3-MDEwOlJlcG9zaXRvcnk4ODQzMzg4-flat-trigtest.c</h3>
            <pre><code>1  #include <math.h>
2  #include <stdio.h>
3  #include <stdlib.h>
4  #ifndef USE_PARI
5  #define USE_PARI 1
6  #endif
7  typedef double trigreal;
8  #  define COS cos
9  #  define SIN sin
10  #  define TAN tan
11  #  define KTRIG(x) (x)
12  static const trigreal MYK2PI =
13      KTRIG(6.2831853071795864769252867665590057683943388);
14  #ifdef REALLY_ACCURATE
15  extern double fma (double X, double Y, double Z);
16  static void dbmul(double a, double b, double *x, double *dx)
17  {
18       *x = a * b; 
19       *dx = fma(a, b, -*x);
20  }
21  static void dbdiv(double a, double b, double *x, double *dx)
22  {
23       *x = a / b;
24       *dx = fma(-*x, b, a) / b;
25  }
26  static double by2pi(double m, double n)
27  {
28       static const double rpi2 =
29  	  6.28318530717958623199592693708837032318115234375;
30       static const double rpi2r = 
31  	  2.44929359829470635445213186455000211641949889184e-16;
32       double x, y, z, dx, dy, dz;
33       dbmul(rpi2, m, &x, &dx);      &bsol;* x + dx = rpi2 * m, exactly */
34       dbmul(rpi2r, m, &y, &dy);     &bsol;* x + dx = rpi2r * m, exactly */
35       y += dx;
36       dx = y + dy;
37       dbdiv(x, n, &y, &dy);      &bsol;* y + dy = x / n */
38       dbdiv(dx, n, &z, &dz);     &bsol;* z + dz = dx / n */
39       return ((z + dy) + dz) + y;
40  }
41  #else
42  static const trigreal K2PI =
43      KTRIG(6.2831853071795864769252867665590057683943388);
44  #define by2pi(m, n) ((K2PI * (m)) / (n))
45  #endif
46  static trigreal sin2pi0(trigreal m, trigreal n);
47  static trigreal cos2pi0(trigreal m, trigreal n)
48  {
49       if (m < 0) return cos2pi0(-m, n);
50       if (m > n * 0.5) return cos2pi0(n - m, n);
51       if (m > n * 0.25) return -sin2pi0(m - n * 0.25, n);
52       if (m > n * 0.125) return sin2pi0(n * 0.25 - m, n);
53       return COS(by2pi(m, n));
54  }
55  static trigreal sin2pi0(trigreal m, trigreal n)
56  {
57       if (m < 0) return -sin2pi0(-m, n);
58       if (m > n * 0.5) return -sin2pi0(n - m, n);
59       if (m > n * 0.25) return cos2pi0(m - n * 0.25, n);
60       if (m > n * 0.125) return cos2pi0(n * 0.25 - m, n);
61       return SIN(by2pi(m, n));
62  }
63  trigreal cos2pi(int m, int n)
64  {
65       return cos2pi0((trigreal)m, (trigreal)n);
66  }
67  trigreal sin2pi(int m, int n)
68  {
69       return sin2pi0((trigreal)m, (trigreal)n);
70  }
71  trigreal tan2pi(int m, int n)
72  {
73       trigreal dm = m, dn = n;
74       return TAN(by2pi(dm, dn));
75  }
76  trigreal naive_sin2pi(int m, int n)
77  {
78       return SIN(MYK2PI * ((trigreal) m / (trigreal) n));
79  }
80  trigreal naive_cos2pi(int m, int n)
81  {
82       return COS(MYK2PI * ((trigreal) m / (trigreal) n));
83  }
84  #if USE_PARI
85  #include <pari/pari.h>
86  long prec = 25;
<span onclick='openModal()' class='match'>87  double ck(long m, long n, double (*cf) (int, int), GEN(*gf) (GEN, long))
88  {
89       GEN gv, gcval, err, arg;
90       double cerr, cval;
</span>91       long ltop = avma;
92       arg = mulsr(2L * m, divrs(gpi, n));
93       setlg(arg, prec);
94       gv = gf(arg, prec);
95       cval = cf(m, n);
96       gcval = dbltor(cval);
97       err = gsub(gcval, gv);
98       cerr = rtodbl(err);
99       avma = ltop;
100       return cerr;
101  }
102  #else
103  double ck(long m, long n, double (*cf) (int, int), 
104  	  long double(*gf) (long double))
105  {
106       long double l2pi = 6.2831853071795864769252867665590057683943388L;
107       return cf(m, n) - gf(l2pi * (long double)m / (long double)n);
108  }
109  #define gsin sinl
110  #define gcos cosl
111  #endif
112  int main(int argc, char *argv[])
113  {
114       long nmin, nmax;
115       long n, m;
116  #if USE_PARI
117       pari_init(500000, 2);
118       mppi(prec);
119  #endif
120       if (argc > 1)
121  	  nmin = atoi(argv[1]);
122       else
123  	  nmin = 1024;
124       if (argc > 2)
125  	  nmax = atoi(argv[2]);
126       else
127  	  nmax = nmin;
128       for (n = nmin; n <= nmax; ++n) {
129  	  double maxe = 0.0, nmaxe = 0.0;;
130  	  for (m = 0; m < n; ++m) {
131  	       double e;
132  	       e = ck(m, n, sin2pi, gsin); if (e > maxe) maxe = e;
133  	       e = ck(m, n, cos2pi, gcos); if (e > maxe) maxe = e;
134  	       e = ck(m, n, naive_sin2pi, gsin); if (e > nmaxe) nmaxe = e;
135  	       e = ck(m, n, naive_cos2pi, gcos); if (e > nmaxe) nmaxe = e;
136  	  }
137  	  printf("%ld %g %g\n", n, maxe, nmaxe);
138       }
139       return 0;
140  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from Adafruit_nRF52_Arduino-MDEwOlJlcG9zaXRvcnk3NDM1NDcyOQ==-flat-nrfx_usbd.h</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from fftw3-MDEwOlJlcG9zaXRvcnk4ODQzMzg4-flat-trigtest.c</div>
                </div>
                <div class="column column_space"><pre><code>43      NRFX_USBD_EVT_EPTRANSFER, &bsol;**< For Rx (OUT: Host->Device):
44                                 *   1. The packet has been received but there is no buffer prepared for transfer already.
</pre></code></div>
                <div class="column column_space"><pre><code>87  double ck(long m, long n, double (*cf) (int, int), GEN(*gf) (GEN, long))
88  {
89       GEN gv, gcval, err, arg;
90       double cerr, cval;
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    