
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 15.730337078651685%, Tokens: 14, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>xmrig-MDEwOlJlcG9zaXRvcnk4ODMyNzQwNg==-flat-HttpClient.h</h3>
            <pre><code>1  #ifndef XMRIG_HTTPCLIENT_H
2  #define XMRIG_HTTPCLIENT_H
3  #include "base/kernel/interfaces/IDnsListener.h"
4  #include "base/kernel/interfaces/ITimerListener.h"
5  #include "base/net/http/Fetch.h"
6  #include "base/net/http/HttpContext.h"
7  #include "base/tools/Object.h"
8  namespace xmrig {
9  class DnsRequest;
10  class HttpClient : public HttpContext, public IDnsListener, public ITimerListener
11  {
12  public:
13      XMRIG_DISABLE_COPY_MOVE_DEFAULT(HttpClient);
14      HttpClient(const char *tag, FetchRequest &&req, const std::weak_ptr<IHttpListener> &listener);
15      ~HttpClient() override = default;
16      inline bool isQuiet() const                 { return m_req.quiet; }
17      inline const char *host() const override    { return m_req.host; }
18      inline const char *tag() const              { return m_tag; }
19      inline uint16_t port() const override       { return m_req.port; }
<span onclick='openModal()' class='match'>20      bool connect();
21  protected:
22      void onResolved(const DnsRecords &records, int status, const char *error) override;
23      void onTimer(const Timer *timer) override;
24      virtual void handshake();
25      virtual void read(const char *data, size_t size);
</span>26  protected:
27      inline const FetchRequest &req() const  { return m_req; }
28  private:
29      static void onConnect(uv_connect_t *req, int status);
30      const char *m_tag;
31      FetchRequest m_req;
32      std::shared_ptr<DnsRequest> m_dns;
33      std::shared_ptr<Timer> m_timer;
34  };
35  } 
36  #endif 
</code></pre>
        </div>
        <div class="column">
            <h3>libtomcrypt-MDEwOlJlcG9zaXRvcnk3NzcwMTE=-flat-rsa_verify_hash.c</h3>
            <pre><code>1  #include "tomcrypt_private.h"
2  #ifdef LTC_MRSA
<span onclick='openModal()' class='match'>3  int rsa_verify_hash_ex(const unsigned char *sig,            unsigned long  siglen,
4                         const unsigned char *hash,           unsigned long  hashlen,
5                               int            padding,
6                               int            hash_idx,       unsigned long  saltlen,
7                               int           *stat,     const rsa_key       *key)
8  {
9    unsigned long modulus_bitlen, modulus_bytelen, x;
10    int           err;
11    unsigned char *tmpbuf;
</span>12    LTC_ARGCHK(hash  != NULL);
13    LTC_ARGCHK(sig   != NULL);
14    LTC_ARGCHK(stat  != NULL);
15    LTC_ARGCHK(key   != NULL);
16    *stat = 0;
17    if ((padding != LTC_PKCS_1_V1_5) &&
18        (padding != LTC_PKCS_1_PSS) &&
19        (padding != LTC_PKCS_1_V1_5_NA1)) {
20      return CRYPT_PK_INVALID_PADDING;
21    }
22    if (padding != LTC_PKCS_1_V1_5_NA1) {
23      if ((err = hash_is_valid(hash_idx)) != CRYPT_OK) {
24         return err;
25      }
26    }
27    modulus_bitlen = mp_count_bits( (key->N));
28    modulus_bytelen = mp_unsigned_bin_size( (key->N));
29    if (modulus_bytelen != siglen) {
30       return CRYPT_INVALID_PACKET;
31    }
32    tmpbuf = XMALLOC(siglen);
33    if (tmpbuf == NULL) {
34       return CRYPT_MEM;
35    }
36    x = siglen;
37    if ((err = ltc_mp.rsa_me(sig, siglen, tmpbuf, &x, PK_PUBLIC, key)) != CRYPT_OK) {
38       XFREE(tmpbuf);
39       return err;
40    }
41    if (x != siglen) {
42       XFREE(tmpbuf);
43       return CRYPT_INVALID_PACKET;
44    }
45    if (padding == LTC_PKCS_1_PSS) {
46      if(modulus_bitlen%8 == 1){
47        err = pkcs_1_pss_decode(hash, hashlen, tmpbuf+1, x-1, saltlen, hash_idx, modulus_bitlen, stat);
48      }
49      else{
50        err = pkcs_1_pss_decode(hash, hashlen, tmpbuf, x, saltlen, hash_idx, modulus_bitlen, stat);
51      }
52    } else {
53      unsigned char *out;
54      unsigned long outlen;
55      int           decoded;
56      outlen = ((modulus_bitlen >> 3) + (modulus_bitlen & 7 ? 1 : 0)) - 3;
57      out    = XMALLOC(outlen);
58      if (out == NULL) {
59        err = CRYPT_MEM;
60        goto bail_2;
61      }
62      if ((err = pkcs_1_v1_5_decode(tmpbuf, x, LTC_PKCS_1_EMSA, modulus_bitlen, out, &outlen, &decoded)) != CRYPT_OK) {
63        XFREE(out);
64        goto bail_2;
65      }
66      if (padding == LTC_PKCS_1_V1_5) {
67        unsigned long loid[16], reallen;
68        ltc_asn1_list digestinfo[2], siginfo[2];
69        if (hash_descriptor[hash_idx].OIDlen == 0) {
70           err = CRYPT_INVALID_ARG;
71           goto bail_2;
72        }
73        LTC_SET_ASN1(digestinfo, 0, LTC_ASN1_OBJECT_IDENTIFIER, loid, sizeof(loid)/sizeof(loid[0]));
74        LTC_SET_ASN1(digestinfo, 1, LTC_ASN1_NULL,              NULL,                          0);
75        LTC_SET_ASN1(siginfo,    0, LTC_ASN1_SEQUENCE,          digestinfo,                    2);
76        LTC_SET_ASN1(siginfo,    1, LTC_ASN1_OCTET_STRING,      tmpbuf,                        siglen);
77        if ((err = der_decode_sequence_strict(out, outlen, siginfo, 2)) != CRYPT_OK) {
78           LTC_SET_ASN1(siginfo, 0, LTC_ASN1_SEQUENCE,          digestinfo,                    1);
79           if ((err = der_decode_sequence_strict(out, outlen, siginfo, 2)) != CRYPT_OK) {
80             XFREE(out);
81             goto bail_2;
82           }
83        }
84        if ((err = der_length_sequence(siginfo, 2, &reallen)) != CRYPT_OK) {
85           XFREE(out);
86           goto bail_2;
87        }
88        if ((reallen == outlen) &&
89            (digestinfo[0].size == hash_descriptor[hash_idx].OIDlen) &&
90          (XMEMCMP(digestinfo[0].data, hash_descriptor[hash_idx].OID, sizeof(unsigned long) * hash_descriptor[hash_idx].OIDlen) == 0) &&
91            (siginfo[1].size == hashlen) &&
92          (XMEMCMP(siginfo[1].data, hash, hashlen) == 0)) {
93           *stat = 1;
94        }
95      } else {
96        if ((hashlen == outlen) &&
97            (XMEMCMP(out, hash, hashlen) == 0)) {
98          *stat = 1;
99        }
100      }
101  #ifdef LTC_CLEAN_STACK
102      zeromem(out, outlen);
103  #endif
104      XFREE(out);
105    }
106  bail_2:
107  #ifdef LTC_CLEAN_STACK
108    zeromem(tmpbuf, siglen);
109  #endif
110    XFREE(tmpbuf);
111    return err;
112  }
113  #endif &bsol;* LTC_MRSA */
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from xmrig-MDEwOlJlcG9zaXRvcnk4ODMyNzQwNg==-flat-HttpClient.h</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from libtomcrypt-MDEwOlJlcG9zaXRvcnk3NzcwMTE=-flat-rsa_verify_hash.c</div>
                </div>
                <div class="column column_space"><pre><code>20      bool connect();
21  protected:
22      void onResolved(const DnsRecords &records, int status, const char *error) override;
23      void onTimer(const Timer *timer) override;
24      virtual void handshake();
25      virtual void read(const char *data, size_t size);
</pre></code></div>
                <div class="column column_space"><pre><code>3  int rsa_verify_hash_ex(const unsigned char *sig,            unsigned long  siglen,
4                         const unsigned char *hash,           unsigned long  hashlen,
5                               int            padding,
6                               int            hash_idx,       unsigned long  saltlen,
7                               int           *stat,     const rsa_key       *key)
8  {
9    unsigned long modulus_bitlen, modulus_bytelen, x;
10    int           err;
11    unsigned char *tmpbuf;
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    