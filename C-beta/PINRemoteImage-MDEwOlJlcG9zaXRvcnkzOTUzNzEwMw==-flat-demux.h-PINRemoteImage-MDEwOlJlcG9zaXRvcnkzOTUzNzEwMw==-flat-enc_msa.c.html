
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 1.810344827586207%, Tokens: 12, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>PINRemoteImage-MDEwOlJlcG9zaXRvcnkzOTUzNzEwMw==-flat-demux.h</h3>
            <pre><code>1  #ifndef WEBP_WEBP_DEMUX_H_
2  #define WEBP_WEBP_DEMUX_H_
3  #include "./decode.h"     
4  #include "./mux_types.h"
5  #ifdef __cplusplus
6  extern "C" {
7  #endif
8  #define WEBP_DEMUX_ABI_VERSION 0x0107    
9  typedef struct WebPDemuxer WebPDemuxer;
10  typedef struct WebPIterator WebPIterator;
11  typedef struct WebPChunkIterator WebPChunkIterator;
12  typedef struct WebPAnimInfo WebPAnimInfo;
13  typedef struct WebPAnimDecoderOptions WebPAnimDecoderOptions;
14  WEBP_EXTERN int WebPGetDemuxVersion(void);
15  typedef enum WebPDemuxState {
16    WEBP_DEMUX_PARSE_ERROR    = -1,  
17    WEBP_DEMUX_PARSING_HEADER =  0,  
18    WEBP_DEMUX_PARSED_HEADER  =  1,  
19    WEBP_DEMUX_DONE           =  2   
20  } WebPDemuxState;
21  WEBP_EXTERN WebPDemuxer* WebPDemuxInternal(
22      const WebPData*, int, WebPDemuxState*, int);
23  static WEBP_INLINE WebPDemuxer* WebPDemux(const WebPData* data) {
24    return WebPDemuxInternal(data, 0, NULL, WEBP_DEMUX_ABI_VERSION);
25  }
26  static WEBP_INLINE WebPDemuxer* WebPDemuxPartial(
27      const WebPData* data, WebPDemuxState* state) {
28    return WebPDemuxInternal(data, 1, state, WEBP_DEMUX_ABI_VERSION);
29  }
30  WEBP_EXTERN void WebPDemuxDelete(WebPDemuxer* dmux);
31  typedef enum WebPFormatFeature {
32    WEBP_FF_FORMAT_FLAGS,      
33    WEBP_FF_CANVAS_WIDTH,
34    WEBP_FF_CANVAS_HEIGHT,
35    WEBP_FF_LOOP_COUNT,        
36    WEBP_FF_BACKGROUND_COLOR,  
37    WEBP_FF_FRAME_COUNT        
38  } WebPFormatFeature;
39  WEBP_EXTERN uint32_t WebPDemuxGetI(
40      const WebPDemuxer* dmux, WebPFormatFeature feature);
41  struct WebPIterator {
<span onclick='openModal()' class='match'>42    int frame_num;
43    int num_frames;          
44    int x_offset, y_offset;  
45    int width, height;       
46    int duration;            
47    WebPMuxAnimDispose dispose_method;  
48    int complete;   
49    WebPData fragment;  
50    int has_alpha;      
51    WebPMuxAnimBlend blend_method;  
52    uint32_t pad[2];         
53    void* private_;          
</span>54  };
55  WEBP_EXTERN int WebPDemuxGetFrame(
56      const WebPDemuxer* dmux, int frame_number, WebPIterator* iter);
57  WEBP_EXTERN int WebPDemuxNextFrame(WebPIterator* iter);
58  WEBP_EXTERN int WebPDemuxPrevFrame(WebPIterator* iter);
59  WEBP_EXTERN void WebPDemuxReleaseIterator(WebPIterator* iter);
60  struct WebPChunkIterator {
61    int chunk_num;
62    int num_chunks;
63    WebPData chunk;    
64    uint32_t pad[6];   
65    void* private_;
66  };
67  WEBP_EXTERN int WebPDemuxGetChunk(const WebPDemuxer* dmux,
68                                    const char fourcc[4], int chunk_number,
69                                    WebPChunkIterator* iter);
70  WEBP_EXTERN int WebPDemuxNextChunk(WebPChunkIterator* iter);
71  WEBP_EXTERN int WebPDemuxPrevChunk(WebPChunkIterator* iter);
72  WEBP_EXTERN void WebPDemuxReleaseChunkIterator(WebPChunkIterator* iter);
73  typedef struct WebPAnimDecoder WebPAnimDecoder;  
74  struct WebPAnimDecoderOptions {
75    WEBP_CSP_MODE color_mode;
76    int use_threads;           
77    uint32_t padding[7];       
78  };
79  WEBP_EXTERN int WebPAnimDecoderOptionsInitInternal(
80      WebPAnimDecoderOptions*, int);
81  static WEBP_INLINE int WebPAnimDecoderOptionsInit(
82      WebPAnimDecoderOptions* dec_options) {
83    return WebPAnimDecoderOptionsInitInternal(dec_options,
84                                              WEBP_DEMUX_ABI_VERSION);
85  }
86  WEBP_EXTERN WebPAnimDecoder* WebPAnimDecoderNewInternal(
87      const WebPData*, const WebPAnimDecoderOptions*, int);
88  static WEBP_INLINE WebPAnimDecoder* WebPAnimDecoderNew(
89      const WebPData* webp_data, const WebPAnimDecoderOptions* dec_options) {
90    return WebPAnimDecoderNewInternal(webp_data, dec_options,
91                                      WEBP_DEMUX_ABI_VERSION);
92  }
93  struct WebPAnimInfo {
94    uint32_t canvas_width;
95    uint32_t canvas_height;
96    uint32_t loop_count;
97    uint32_t bgcolor;
98    uint32_t frame_count;
99    uint32_t pad[4];   
100  };
101  WEBP_EXTERN int WebPAnimDecoderGetInfo(const WebPAnimDecoder* dec,
102                                         WebPAnimInfo* info);
103  WEBP_EXTERN int WebPAnimDecoderGetNext(WebPAnimDecoder* dec,
104                                         uint8_t** buf, int* timestamp);
105  WEBP_EXTERN int WebPAnimDecoderHasMoreFrames(const WebPAnimDecoder* dec);
106  WEBP_EXTERN void WebPAnimDecoderReset(WebPAnimDecoder* dec);
107  WEBP_EXTERN const WebPDemuxer* WebPAnimDecoderGetDemuxer(
108      const WebPAnimDecoder* dec);
109  WEBP_EXTERN void WebPAnimDecoderDelete(WebPAnimDecoder* dec);
110  #ifdef __cplusplus
111  }    
112  #endif
113  #endif  
</code></pre>
        </div>
        <div class="column">
            <h3>PINRemoteImage-MDEwOlJlcG9zaXRvcnkzOTUzNzEwMw==-flat-enc_msa.c</h3>
            <pre><code>1  #include "src/dsp/dsp.h"
2  #if defined(WEBP_USE_MSA)
3  #include <stdlib.h>
4  #include "src/dsp/msa_macro.h"
5  #include "src/enc/vp8i_enc.h"
6  #define IDCT_1D_W(in0, in1, in2, in3, out0, out1, out2, out3) do {  \
7    v4i32 a1_m, b1_m, c1_m, d1_m;                                     \
8    const v4i32 cospi8sqrt2minus1 = __msa_fill_w(20091);              \
9    const v4i32 sinpi8sqrt2 = __msa_fill_w(35468);                    \
10    v4i32 c_tmp1_m = in1 * sinpi8sqrt2;                               \
11    v4i32 c_tmp2_m = in3 * cospi8sqrt2minus1;                         \
12    v4i32 d_tmp1_m = in1 * cospi8sqrt2minus1;                         \
13    v4i32 d_tmp2_m = in3 * sinpi8sqrt2;                               \
14                                                                      \
15    ADDSUB2(in0, in2, a1_m, b1_m);                                    \
16    SRAI_W2_SW(c_tmp1_m, c_tmp2_m, 16);                               \
17    c_tmp2_m = c_tmp2_m + in3;                                        \
18    c1_m = c_tmp1_m - c_tmp2_m;                                       \
19    SRAI_W2_SW(d_tmp1_m, d_tmp2_m, 16);                               \
20    d_tmp1_m = d_tmp1_m + in1;                                        \
21    d1_m = d_tmp1_m + d_tmp2_m;                                       \
22    BUTTERFLY_4(a1_m, b1_m, c1_m, d1_m, out0, out1, out2, out3);      \
23  } while (0)
24  static WEBP_INLINE void ITransformOne(const uint8_t* ref, const int16_t* in,
25                                        uint8_t* dst) {
26    v8i16 input0, input1;
27    v4i32 in0, in1, in2, in3, hz0, hz1, hz2, hz3, vt0, vt1, vt2, vt3;
28    v4i32 res0, res1, res2, res3;
29    v16i8 dest0, dest1, dest2, dest3;
30    const v16i8 zero = { 0 };
31    LD_SH2(in, 8, input0, input1);
32    UNPCK_SH_SW(input0, in0, in1);
33    UNPCK_SH_SW(input1, in2, in3);
34    IDCT_1D_W(in0, in1, in2, in3, hz0, hz1, hz2, hz3);
35    TRANSPOSE4x4_SW_SW(hz0, hz1, hz2, hz3, hz0, hz1, hz2, hz3);
36    IDCT_1D_W(hz0, hz1, hz2, hz3, vt0, vt1, vt2, vt3);
37    SRARI_W4_SW(vt0, vt1, vt2, vt3, 3);
38    TRANSPOSE4x4_SW_SW(vt0, vt1, vt2, vt3, vt0, vt1, vt2, vt3);
39    LD_SB4(ref, BPS, dest0, dest1, dest2, dest3);
<span onclick='openModal()' class='match'>40    ILVR_B4_SW(zero, dest0, zero, dest1, zero, dest2, zero, dest3,
41               res0, res1, res2, res3);
</span>42    ILVR_H4_SW(zero, res0, zero, res1, zero, res2, zero, res3,
43               res0, res1, res2, res3);
44    ADD4(res0, vt0, res1, vt1, res2, vt2, res3, vt3, res0, res1, res2, res3);
45    CLIP_SW4_0_255(res0, res1, res2, res3);
46    PCKEV_B2_SW(res0, res1, res2, res3, vt0, vt1);
47    res0 = (v4i32)__msa_pckev_b((v16i8)vt0, (v16i8)vt1);
48    ST4x4_UB(res0, res0, 3, 2, 1, 0, dst, BPS);
49  }
50  static void ITransform_MSA(const uint8_t* ref, const int16_t* in, uint8_t* dst,
51                             int do_two) {
52    ITransformOne(ref, in, dst);
53    if (do_two) {
54      ITransformOne(ref + 4, in + 16, dst + 4);
55    }
56  }
57  static void FTransform_MSA(const uint8_t* src, const uint8_t* ref,
58                             int16_t* out) {
59    uint64_t out0, out1, out2, out3;
60    uint32_t in0, in1, in2, in3;
61    v4i32 tmp0, tmp1, tmp2, tmp3, tmp4, tmp5;
62    v8i16 t0, t1, t2, t3;
63    v16u8 srcl0, srcl1, src0 = { 0 }, src1 = { 0 };
64    const v8i16 mask0 = { 0, 4, 8, 12, 1, 5, 9, 13 };
65    const v8i16 mask1 = { 3, 7, 11, 15, 2, 6, 10, 14 };
66    const v8i16 mask2 = { 4, 0, 5, 1, 6, 2, 7, 3 };
67    const v8i16 mask3 = { 0, 4, 1, 5, 2, 6, 3, 7 };
68    const v8i16 cnst0 = { 2217, -5352, 2217, -5352, 2217, -5352, 2217, -5352 };
69    const v8i16 cnst1 = { 5352, 2217, 5352, 2217, 5352, 2217, 5352, 2217 };
70    LW4(src, BPS, in0, in1, in2, in3);
71    INSERT_W4_UB(in0, in1, in2, in3, src0);
72    LW4(ref, BPS, in0, in1, in2, in3);
73    INSERT_W4_UB(in0, in1, in2, in3, src1);
74    ILVRL_B2_UB(src0, src1, srcl0, srcl1);
75    HSUB_UB2_SH(srcl0, srcl1, t0, t1);
76    VSHF_H2_SH(t0, t1, t0, t1, mask0, mask1, t2, t3);
77    ADDSUB2(t2, t3, t0, t1);
78    t0 = SRLI_H(t0, 3);
79    VSHF_H2_SH(t0, t0, t1, t1, mask2, mask3, t3, t2);
80    tmp0 = __msa_hadd_s_w(t3, t3);
81    tmp2 = __msa_hsub_s_w(t3, t3);
82    FILL_W2_SW(1812, 937, tmp1, tmp3);
83    DPADD_SH2_SW(t2, t2, cnst0, cnst1, tmp3, tmp1);
84    SRAI_W2_SW(tmp1, tmp3, 9);
85    PCKEV_H2_SH(tmp1, tmp0, tmp3, tmp2, t0, t1);
86    VSHF_H2_SH(t0, t1, t0, t1, mask0, mask1, t2, t3);
87    ADDSUB2(t2, t3, t0, t1);
88    VSHF_H2_SH(t0, t0, t1, t1, mask2, mask3, t3, t2);
89    tmp0 = __msa_hadd_s_w(t3, t3);
90    tmp2 = __msa_hsub_s_w(t3, t3);
91    ADDVI_W2_SW(tmp0, 7, tmp2, 7, tmp0, tmp2);
92    SRAI_W2_SW(tmp0, tmp2, 4);
93    FILL_W2_SW(12000, 51000, tmp1, tmp3);
94    DPADD_SH2_SW(t2, t2, cnst0, cnst1, tmp3, tmp1);
95    SRAI_W2_SW(tmp1, tmp3, 16);
96    UNPCK_R_SH_SW(t1, tmp4);
97    tmp5 = __msa_ceqi_w(tmp4, 0);
98    tmp4 = (v4i32)__msa_nor_v((v16u8)tmp5, (v16u8)tmp5);
99    tmp5 = __msa_fill_w(1);
100    tmp5 = (v4i32)__msa_and_v((v16u8)tmp5, (v16u8)tmp4);
101    tmp1 += tmp5;
102    PCKEV_H2_SH(tmp1, tmp0, tmp3, tmp2, t0, t1);
103    out0 = __msa_copy_s_d((v2i64)t0, 0);
104    out1 = __msa_copy_s_d((v2i64)t0, 1);
105    out2 = __msa_copy_s_d((v2i64)t1, 0);
106    out3 = __msa_copy_s_d((v2i64)t1, 1);
107    SD4(out0, out1, out2, out3, out, 8);
108  }
109  static void FTransformWHT_MSA(const int16_t* in, int16_t* out) {
110    v8i16 in0 = { 0 };
111    v8i16 in1 = { 0 };
112    v8i16 tmp0, tmp1, tmp2, tmp3;
113    v8i16 out0, out1;
114    const v8i16 mask0 = { 0, 1, 2, 3, 8, 9, 10, 11 };
115    const v8i16 mask1 = { 4, 5, 6, 7, 12, 13, 14, 15 };
116    const v8i16 mask2 = { 0, 4, 8, 12, 1, 5, 9, 13 };
117    const v8i16 mask3 = { 3, 7, 11, 15, 2, 6, 10, 14 };
118    in0 = __msa_insert_h(in0, 0, in[  0]);
119    in0 = __msa_insert_h(in0, 1, in[ 64]);
120    in0 = __msa_insert_h(in0, 2, in[128]);
121    in0 = __msa_insert_h(in0, 3, in[192]);
122    in0 = __msa_insert_h(in0, 4, in[ 16]);
123    in0 = __msa_insert_h(in0, 5, in[ 80]);
124    in0 = __msa_insert_h(in0, 6, in[144]);
125    in0 = __msa_insert_h(in0, 7, in[208]);
126    in1 = __msa_insert_h(in1, 0, in[ 48]);
127    in1 = __msa_insert_h(in1, 1, in[112]);
128    in1 = __msa_insert_h(in1, 2, in[176]);
129    in1 = __msa_insert_h(in1, 3, in[240]);
130    in1 = __msa_insert_h(in1, 4, in[ 32]);
131    in1 = __msa_insert_h(in1, 5, in[ 96]);
132    in1 = __msa_insert_h(in1, 6, in[160]);
133    in1 = __msa_insert_h(in1, 7, in[224]);
134    ADDSUB2(in0, in1, tmp0, tmp1);
135    VSHF_H2_SH(tmp0, tmp1, tmp0, tmp1, mask0, mask1, tmp2, tmp3);
136    ADDSUB2(tmp2, tmp3, tmp0, tmp1);
137    VSHF_H2_SH(tmp0, tmp1, tmp0, tmp1, mask2, mask3, in0, in1);
138    ADDSUB2(in0, in1, tmp0, tmp1);
139    VSHF_H2_SH(tmp0, tmp1, tmp0, tmp1, mask0, mask1, tmp2, tmp3);
140    ADDSUB2(tmp2, tmp3, out0, out1);
141    SRAI_H2_SH(out0, out1, 1);
142    ST_SH2(out0, out1, out, 8);
143  }
144  static int TTransform_MSA(const uint8_t* in, const uint16_t* w) {
145    int sum;
146    uint32_t in0_m, in1_m, in2_m, in3_m;
147    v16i8 src0 = { 0 };
148    v8i16 in0, in1, tmp0, tmp1, tmp2, tmp3;
149    v4i32 dst0, dst1;
150    const v16i8 zero = { 0 };
151    const v8i16 mask0 = { 0, 1, 2, 3, 8, 9, 10, 11 };
152    const v8i16 mask1 = { 4, 5, 6, 7, 12, 13, 14, 15 };
153    const v8i16 mask2 = { 0, 4, 8, 12, 1, 5, 9, 13 };
154    const v8i16 mask3 = { 3, 7, 11, 15, 2, 6, 10, 14 };
155    LW4(in, BPS, in0_m, in1_m, in2_m, in3_m);
156    INSERT_W4_SB(in0_m, in1_m, in2_m, in3_m, src0);
157    ILVRL_B2_SH(zero, src0, tmp0, tmp1);
158    VSHF_H2_SH(tmp0, tmp1, tmp0, tmp1, mask2, mask3, in0, in1);
159    ADDSUB2(in0, in1, tmp0, tmp1);
160    VSHF_H2_SH(tmp0, tmp1, tmp0, tmp1, mask0, mask1, tmp2, tmp3);
161    ADDSUB2(tmp2, tmp3, tmp0, tmp1);
162    VSHF_H2_SH(tmp0, tmp1, tmp0, tmp1, mask2, mask3, in0, in1);
163    ADDSUB2(in0, in1, tmp0, tmp1);
164    VSHF_H2_SH(tmp0, tmp1, tmp0, tmp1, mask0, mask1, tmp2, tmp3);
165    ADDSUB2(tmp2, tmp3, tmp0, tmp1);
166    tmp0 = __msa_add_a_h(tmp0, (v8i16)zero);
167    tmp1 = __msa_add_a_h(tmp1, (v8i16)zero);
168    LD_SH2(w, 8, tmp2, tmp3);
169    DOTP_SH2_SW(tmp0, tmp1, tmp2, tmp3, dst0, dst1);
170    dst0 = dst0 + dst1;
171    sum = HADD_SW_S32(dst0);
172    return sum;
173  }
174  static int Disto4x4_MSA(const uint8_t* const a, const uint8_t* const b,
175                          const uint16_t* const w) {
176    const int sum1 = TTransform_MSA(a, w);
177    const int sum2 = TTransform_MSA(b, w);
178    return abs(sum2 - sum1) >> 5;
179  }
180  static int Disto16x16_MSA(const uint8_t* const a, const uint8_t* const b,
181                            const uint16_t* const w) {
182    int D = 0;
183    int x, y;
184    for (y = 0; y < 16 * BPS; y += 4 * BPS) {
185      for (x = 0; x < 16; x += 4) {
186        D += Disto4x4_MSA(a + x + y, b + x + y, w);
187      }
188    }
189    return D;
190  }
191  static void CollectHistogram_MSA(const uint8_t* ref, const uint8_t* pred,
192                                   int start_block, int end_block,
193                                   VP8Histogram* const histo) {
194    int j;
195    int distribution[MAX_COEFF_THRESH + 1] = { 0 };
196    for (j = start_block; j < end_block; ++j) {
197      int16_t out[16];
198      VP8FTransform(ref + VP8DspScan[j], pred + VP8DspScan[j], out);
199      {
200        int k;
201        v8i16 coeff0, coeff1;
202        const v8i16 zero = { 0 };
203        const v8i16 max_coeff_thr = __msa_ldi_h(MAX_COEFF_THRESH);
204        LD_SH2(&out[0], 8, coeff0, coeff1);
205        coeff0 = __msa_add_a_h(coeff0, zero);
206        coeff1 = __msa_add_a_h(coeff1, zero);
207        SRAI_H2_SH(coeff0, coeff1, 3);
208        coeff0 = __msa_min_s_h(coeff0, max_coeff_thr);
209        coeff1 = __msa_min_s_h(coeff1, max_coeff_thr);
210        ST_SH2(coeff0, coeff1, &out[0], 8);
211        for (k = 0; k < 16; ++k) {
212          ++distribution[out[k]];
213        }
214      }
215    }
216    VP8SetHistogramData(distribution, histo);
217  }
218  #define DST(x, y) dst[(x) + (y) * BPS]
219  #define AVG3(a, b, c) (((a) + 2 * (b) + (c) + 2) >> 2)
220  #define AVG2(a, b) (((a) + (b) + 1) >> 1)
221  static WEBP_INLINE void VE4(uint8_t* dst, const uint8_t* top) {    
222    const v16u8 A1 = { 0 };
223    const uint64_t val_m = LD(top - 1);
224    const v16u8 A = (v16u8)__msa_insert_d((v2i64)A1, 0, val_m);
225    const v16u8 B = SLDI_UB(A, A, 1);
226    const v16u8 C = SLDI_UB(A, A, 2);
227    const v16u8 AC = __msa_ave_u_b(A, C);
228    const v16u8 B2 = __msa_ave_u_b(B, B);
229    const v16u8 R = __msa_aver_u_b(AC, B2);
230    const uint32_t out = __msa_copy_s_w((v4i32)R, 0);
231    SW4(out, out, out, out, dst, BPS);
232  }
233  static WEBP_INLINE void HE4(uint8_t* dst, const uint8_t* top) {    
234    const int X = top[-1];
235    const int I = top[-2];
236    const int J = top[-3];
237    const int K = top[-4];
238    const int L = top[-5];
239    WebPUint32ToMem(dst + 0 * BPS, 0x01010101U * AVG3(X, I, J));
240    WebPUint32ToMem(dst + 1 * BPS, 0x01010101U * AVG3(I, J, K));
241    WebPUint32ToMem(dst + 2 * BPS, 0x01010101U * AVG3(J, K, L));
242    WebPUint32ToMem(dst + 3 * BPS, 0x01010101U * AVG3(K, L, L));
243  }
244  static WEBP_INLINE void DC4(uint8_t* dst, const uint8_t* top) {
245    uint32_t dc = 4;
246    int i;
247    for (i = 0; i < 4; ++i) dc += top[i] + top[-5 + i];
248    dc >>= 3;
249    dc = dc | (dc << 8) | (dc << 16) | (dc << 24);
250    SW4(dc, dc, dc, dc, dst, BPS);
251  }
252  static WEBP_INLINE void RD4(uint8_t* dst, const uint8_t* top) {
253    const v16u8 A2 = { 0 };
254    const uint64_t val_m = LD(top - 5);
255    const v16u8 A1 = (v16u8)__msa_insert_d((v2i64)A2, 0, val_m);
256    const v16u8 A = (v16u8)__msa_insert_b((v16i8)A1, 8, top[3]);
257    const v16u8 B = SLDI_UB(A, A, 1);
258    const v16u8 C = SLDI_UB(A, A, 2);
259    const v16u8 AC = __msa_ave_u_b(A, C);
260    const v16u8 B2 = __msa_ave_u_b(B, B);
261    const v16u8 R0 = __msa_aver_u_b(AC, B2);
262    const v16u8 R1 = SLDI_UB(R0, R0, 1);
263    const v16u8 R2 = SLDI_UB(R1, R1, 1);
264    const v16u8 R3 = SLDI_UB(R2, R2, 1);
265    const uint32_t val0 = __msa_copy_s_w((v4i32)R0, 0);
266    const uint32_t val1 = __msa_copy_s_w((v4i32)R1, 0);
267    const uint32_t val2 = __msa_copy_s_w((v4i32)R2, 0);
268    const uint32_t val3 = __msa_copy_s_w((v4i32)R3, 0);
269    SW4(val3, val2, val1, val0, dst, BPS);
270  }
271  static WEBP_INLINE void LD4(uint8_t* dst, const uint8_t* top) {
272    const v16u8 A1 = { 0 };
273    const uint64_t val_m = LD(top);
274    const v16u8 A = (v16u8)__msa_insert_d((v2i64)A1, 0, val_m);
275    const v16u8 B = SLDI_UB(A, A, 1);
276    const v16u8 C1 = SLDI_UB(A, A, 2);
277    const v16u8 C = (v16u8)__msa_insert_b((v16i8)C1, 6, top[7]);
278    const v16u8 AC = __msa_ave_u_b(A, C);
279    const v16u8 B2 = __msa_ave_u_b(B, B);
280    const v16u8 R0 = __msa_aver_u_b(AC, B2);
281    const v16u8 R1 = SLDI_UB(R0, R0, 1);
282    const v16u8 R2 = SLDI_UB(R1, R1, 1);
283    const v16u8 R3 = SLDI_UB(R2, R2, 1);
284    const uint32_t val0 = __msa_copy_s_w((v4i32)R0, 0);
285    const uint32_t val1 = __msa_copy_s_w((v4i32)R1, 0);
286    const uint32_t val2 = __msa_copy_s_w((v4i32)R2, 0);
287    const uint32_t val3 = __msa_copy_s_w((v4i32)R3, 0);
288    SW4(val0, val1, val2, val3, dst, BPS);
289  }
290  static WEBP_INLINE void VR4(uint8_t* dst, const uint8_t* top) {
291    const int X = top[-1];
292    const int I = top[-2];
293    const int J = top[-3];
294    const int K = top[-4];
295    const int A = top[0];
296    const int B = top[1];
297    const int C = top[2];
298    const int D = top[3];
299    DST(0, 0) = DST(1, 2) = AVG2(X, A);
300    DST(1, 0) = DST(2, 2) = AVG2(A, B);
301    DST(2, 0) = DST(3, 2) = AVG2(B, C);
302    DST(3, 0)             = AVG2(C, D);
303    DST(0, 3) =             AVG3(K, J, I);
304    DST(0, 2) =             AVG3(J, I, X);
305    DST(0, 1) = DST(1, 3) = AVG3(I, X, A);
306    DST(1, 1) = DST(2, 3) = AVG3(X, A, B);
307    DST(2, 1) = DST(3, 3) = AVG3(A, B, C);
308    DST(3, 1) =             AVG3(B, C, D);
309  }
310  static WEBP_INLINE void VL4(uint8_t* dst, const uint8_t* top) {
311    const int A = top[0];
312    const int B = top[1];
313    const int C = top[2];
314    const int D = top[3];
315    const int E = top[4];
316    const int F = top[5];
317    const int G = top[6];
318    const int H = top[7];
319    DST(0, 0) =             AVG2(A, B);
320    DST(1, 0) = DST(0, 2) = AVG2(B, C);
321    DST(2, 0) = DST(1, 2) = AVG2(C, D);
322    DST(3, 0) = DST(2, 2) = AVG2(D, E);
323    DST(0, 1) =             AVG3(A, B, C);
324    DST(1, 1) = DST(0, 3) = AVG3(B, C, D);
325    DST(2, 1) = DST(1, 3) = AVG3(C, D, E);
326    DST(3, 1) = DST(2, 3) = AVG3(D, E, F);
327                DST(3, 2) = AVG3(E, F, G);
328                DST(3, 3) = AVG3(F, G, H);
329  }
330  static WEBP_INLINE void HU4(uint8_t* dst, const uint8_t* top) {
331    const int I = top[-2];
332    const int J = top[-3];
333    const int K = top[-4];
334    const int L = top[-5];
335    DST(0, 0) =             AVG2(I, J);
336    DST(2, 0) = DST(0, 1) = AVG2(J, K);
337    DST(2, 1) = DST(0, 2) = AVG2(K, L);
338    DST(1, 0) =             AVG3(I, J, K);
339    DST(3, 0) = DST(1, 1) = AVG3(J, K, L);
340    DST(3, 1) = DST(1, 2) = AVG3(K, L, L);
341    DST(3, 2) = DST(2, 2) =
342    DST(0, 3) = DST(1, 3) = DST(2, 3) = DST(3, 3) = L;
343  }
344  static WEBP_INLINE void HD4(uint8_t* dst, const uint8_t* top) {
345    const int X = top[-1];
346    const int I = top[-2];
347    const int J = top[-3];
348    const int K = top[-4];
349    const int L = top[-5];
350    const int A = top[0];
351    const int B = top[1];
352    const int C = top[2];
353    DST(0, 0) = DST(2, 1) = AVG2(I, X);
354    DST(0, 1) = DST(2, 2) = AVG2(J, I);
355    DST(0, 2) = DST(2, 3) = AVG2(K, J);
356    DST(0, 3)             = AVG2(L, K);
357    DST(3, 0)             = AVG3(A, B, C);
358    DST(2, 0)             = AVG3(X, A, B);
359    DST(1, 0) = DST(3, 1) = AVG3(I, X, A);
360    DST(1, 1) = DST(3, 2) = AVG3(J, I, X);
361    DST(1, 2) = DST(3, 3) = AVG3(K, J, I);
362    DST(1, 3)             = AVG3(L, K, J);
363  }
364  static WEBP_INLINE void TM4(uint8_t* dst, const uint8_t* top) {
365    const v16i8 zero = { 0 };
366    const v8i16 TL = (v8i16)__msa_fill_h(top[-1]);
367    const v8i16 L0 = (v8i16)__msa_fill_h(top[-2]);
368    const v8i16 L1 = (v8i16)__msa_fill_h(top[-3]);
369    const v8i16 L2 = (v8i16)__msa_fill_h(top[-4]);
370    const v8i16 L3 = (v8i16)__msa_fill_h(top[-5]);
371    const v16u8 T1 = LD_UB(top);
372    const v8i16 T  = (v8i16)__msa_ilvr_b(zero, (v16i8)T1);
373    const v8i16 d = T - TL;
374    v8i16 r0, r1, r2, r3;
375    ADD4(d, L0, d, L1, d, L2, d, L3, r0, r1, r2, r3);
376    CLIP_SH4_0_255(r0, r1, r2, r3);
377    PCKEV_ST4x4_UB(r0, r1, r2, r3, dst, BPS);
378  }
379  #undef DST
380  #undef AVG3
381  #undef AVG2
382  static void Intra4Preds_MSA(uint8_t* dst, const uint8_t* top) {
383    DC4(I4DC4 + dst, top);
384    TM4(I4TM4 + dst, top);
385    VE4(I4VE4 + dst, top);
386    HE4(I4HE4 + dst, top);
387    RD4(I4RD4 + dst, top);
388    VR4(I4VR4 + dst, top);
389    LD4(I4LD4 + dst, top);
390    VL4(I4VL4 + dst, top);
391    HD4(I4HD4 + dst, top);
392    HU4(I4HU4 + dst, top);
393  }
394  #define STORE16x16(out, dst) do {                                        \
395      ST_UB8(out, out, out, out, out, out, out, out, dst + 0 * BPS, BPS);  \
396      ST_UB8(out, out, out, out, out, out, out, out, dst + 8 * BPS, BPS);  \
397  } while (0)
398  static WEBP_INLINE void VerticalPred16x16(uint8_t* dst, const uint8_t* top) {
399    if (top != NULL) {
400      const v16u8 out = LD_UB(top);
401      STORE16x16(out, dst);
402    } else {
403      const v16u8 out = (v16u8)__msa_fill_b(0x7f);
404      STORE16x16(out, dst);
405    }
406  }
407  static WEBP_INLINE void HorizontalPred16x16(uint8_t* dst,
408                                              const uint8_t* left) {
409    if (left != NULL) {
410      int j;
411      for (j = 0; j < 16; j += 4) {
412        const v16u8 L0 = (v16u8)__msa_fill_b(left[0]);
413        const v16u8 L1 = (v16u8)__msa_fill_b(left[1]);
414        const v16u8 L2 = (v16u8)__msa_fill_b(left[2]);
415        const v16u8 L3 = (v16u8)__msa_fill_b(left[3]);
416        ST_UB4(L0, L1, L2, L3, dst, BPS);
417        dst += 4 * BPS;
418        left += 4;
419      }
420    } else {
421      const v16u8 out = (v16u8)__msa_fill_b(0x81);
422      STORE16x16(out, dst);
423    }
424  }
425  static WEBP_INLINE void TrueMotion16x16(uint8_t* dst, const uint8_t* left,
426                                          const uint8_t* top) {
427    if (left != NULL) {
428      if (top != NULL) {
429        int j;
430        v8i16 d1, d2;
431        const v16i8 zero = { 0 };
432        const v8i16 TL = (v8i16)__msa_fill_h(left[-1]);
433        const v16u8 T = LD_UB(top);
434        ILVRL_B2_SH(zero, T, d1, d2);
435        SUB2(d1, TL, d2, TL, d1, d2);
436        for (j = 0; j < 16; j += 4) {
437          v16i8 t0, t1, t2, t3;
438          v8i16 r0, r1, r2, r3, r4, r5, r6, r7;
439          const v8i16 L0 = (v8i16)__msa_fill_h(left[j + 0]);
440          const v8i16 L1 = (v8i16)__msa_fill_h(left[j + 1]);
441          const v8i16 L2 = (v8i16)__msa_fill_h(left[j + 2]);
442          const v8i16 L3 = (v8i16)__msa_fill_h(left[j + 3]);
443          ADD4(d1, L0, d1, L1, d1, L2, d1, L3, r0, r1, r2, r3);
444          ADD4(d2, L0, d2, L1, d2, L2, d2, L3, r4, r5, r6, r7);
445          CLIP_SH4_0_255(r0, r1, r2, r3);
446          CLIP_SH4_0_255(r4, r5, r6, r7);
447          PCKEV_B4_SB(r4, r0, r5, r1, r6, r2, r7, r3, t0, t1, t2, t3);
448          ST_SB4(t0, t1, t2, t3, dst, BPS);
449          dst += 4 * BPS;
450        }
451      } else {
452        HorizontalPred16x16(dst, left);
453      }
454    } else {
455      if (top != NULL) {
456        VerticalPred16x16(dst, top);
457      } else {
458        const v16u8 out = (v16u8)__msa_fill_b(0x81);
459        STORE16x16(out, dst);
460      }
461    }
462  }
463  static WEBP_INLINE void DCMode16x16(uint8_t* dst, const uint8_t* left,
464                                      const uint8_t* top) {
465    int DC;
466    v16u8 out;
467    if (top != NULL && left != NULL) {
468      const v16u8 rtop = LD_UB(top);
469      const v8u16 dctop = __msa_hadd_u_h(rtop, rtop);
470      const v16u8 rleft = LD_UB(left);
471      const v8u16 dcleft = __msa_hadd_u_h(rleft, rleft);
472      const v8u16 dctemp = dctop + dcleft;
473      DC = HADD_UH_U32(dctemp);
474      DC = (DC + 16) >> 5;
475    } else if (left != NULL) {   
476      const v16u8 rleft = LD_UB(left);
477      const v8u16 dcleft = __msa_hadd_u_h(rleft, rleft);
478      DC = HADD_UH_U32(dcleft);
479      DC = (DC + DC + 16) >> 5;
480    } else if (top != NULL) {   
481      const v16u8 rtop = LD_UB(top);
482      const v8u16 dctop = __msa_hadd_u_h(rtop, rtop);
483      DC = HADD_UH_U32(dctop);
484      DC = (DC + DC + 16) >> 5;
485    } else {   
486      DC = 0x80;
487    }
488    out = (v16u8)__msa_fill_b(DC);
489    STORE16x16(out, dst);
490  }
491  static void Intra16Preds_MSA(uint8_t* dst,
492                               const uint8_t* left, const uint8_t* top) {
493    DCMode16x16(I16DC16 + dst, left, top);
494    VerticalPred16x16(I16VE16 + dst, top);
495    HorizontalPred16x16(I16HE16 + dst, left);
496    TrueMotion16x16(I16TM16 + dst, left, top);
497  }
498  #define CALC_DC8(in, out) do {                              \
499    const v8u16 temp0 = __msa_hadd_u_h(in, in);               \
500    const v4u32 temp1 = __msa_hadd_u_w(temp0, temp0);         \
501    const v2i64 temp2 = (v2i64)__msa_hadd_u_d(temp1, temp1);  \
502    const v2i64 temp3 = __msa_splati_d(temp2, 1);             \
503    const v2i64 temp4 = temp3 + temp2;                        \
504    const v16i8 temp5 = (v16i8)__msa_srari_d(temp4, 4);       \
505    const v2i64 temp6 = (v2i64)__msa_splati_b(temp5, 0);      \
506    out = __msa_copy_s_d(temp6, 0);                           \
507  } while (0)
508  #define STORE8x8(out, dst) do {                 \
509    SD4(out, out, out, out, dst + 0 * BPS, BPS);  \
510    SD4(out, out, out, out, dst + 4 * BPS, BPS);  \
511  } while (0)
512  static WEBP_INLINE void VerticalPred8x8(uint8_t* dst, const uint8_t* top) {
513    if (top != NULL) {
514      const uint64_t out = LD(top);
515      STORE8x8(out, dst);
516    } else {
517      const uint64_t out = 0x7f7f7f7f7f7f7f7fULL;
518      STORE8x8(out, dst);
519    }
520  }
521  static WEBP_INLINE void HorizontalPred8x8(uint8_t* dst, const uint8_t* left) {
522    if (left != NULL) {
523      int j;
524      for (j = 0; j < 8; j += 4) {
525        const v16u8 L0 = (v16u8)__msa_fill_b(left[0]);
526        const v16u8 L1 = (v16u8)__msa_fill_b(left[1]);
527        const v16u8 L2 = (v16u8)__msa_fill_b(left[2]);
528        const v16u8 L3 = (v16u8)__msa_fill_b(left[3]);
529        const uint64_t out0 = __msa_copy_s_d((v2i64)L0, 0);
530        const uint64_t out1 = __msa_copy_s_d((v2i64)L1, 0);
531        const uint64_t out2 = __msa_copy_s_d((v2i64)L2, 0);
532        const uint64_t out3 = __msa_copy_s_d((v2i64)L3, 0);
533        SD4(out0, out1, out2, out3, dst, BPS);
534        dst += 4 * BPS;
535        left += 4;
536      }
537    } else {
538      const uint64_t out = 0x8181818181818181ULL;
539      STORE8x8(out, dst);
540    }
541  }
542  static WEBP_INLINE void TrueMotion8x8(uint8_t* dst, const uint8_t* left,
543                                        const uint8_t* top) {
544    if (left != NULL) {
545      if (top != NULL) {
546        int j;
547        const v8i16 TL = (v8i16)__msa_fill_h(left[-1]);
548        const v16u8 T1 = LD_UB(top);
549        const v16i8 zero = { 0 };
550        const v8i16 T  = (v8i16)__msa_ilvr_b(zero, (v16i8)T1);
551        const v8i16 d = T - TL;
552        for (j = 0; j < 8; j += 4) {
553          uint64_t out0, out1, out2, out3;
554          v16i8 t0, t1;
555          v8i16 r0 = (v8i16)__msa_fill_h(left[j + 0]);
556          v8i16 r1 = (v8i16)__msa_fill_h(left[j + 1]);
557          v8i16 r2 = (v8i16)__msa_fill_h(left[j + 2]);
558          v8i16 r3 = (v8i16)__msa_fill_h(left[j + 3]);
559          ADD4(d, r0, d, r1, d, r2, d, r3, r0, r1, r2, r3);
560          CLIP_SH4_0_255(r0, r1, r2, r3);
561          PCKEV_B2_SB(r1, r0, r3, r2, t0, t1);
562          out0 = __msa_copy_s_d((v2i64)t0, 0);
563          out1 = __msa_copy_s_d((v2i64)t0, 1);
564          out2 = __msa_copy_s_d((v2i64)t1, 0);
565          out3 = __msa_copy_s_d((v2i64)t1, 1);
566          SD4(out0, out1, out2, out3, dst, BPS);
567          dst += 4 * BPS;
568        }
569      } else {
570        HorizontalPred8x8(dst, left);
571      }
572    } else {
573      if (top != NULL) {
574        VerticalPred8x8(dst, top);
575      } else {
576        const uint64_t out = 0x8181818181818181ULL;
577        STORE8x8(out, dst);
578      }
579    }
580  }
581  static WEBP_INLINE void DCMode8x8(uint8_t* dst, const uint8_t* left,
582                                    const uint8_t* top) {
583    uint64_t out;
584    v16u8 src = { 0 };
585    if (top != NULL && left != NULL) {
586      const uint64_t left_m = LD(left);
587      const uint64_t top_m = LD(top);
588      INSERT_D2_UB(left_m, top_m, src);
589      CALC_DC8(src, out);
590    } else if (left != NULL) {   
591      const uint64_t left_m = LD(left);
592      INSERT_D2_UB(left_m, left_m, src);
593      CALC_DC8(src, out);
594    } else if (top != NULL) {   
595      const uint64_t top_m = LD(top);
596      INSERT_D2_UB(top_m, top_m, src);
597      CALC_DC8(src, out);
598    } else {   
599      src = (v16u8)__msa_fill_b(0x80);
600      out = __msa_copy_s_d((v2i64)src, 0);
601    }
602    STORE8x8(out, dst);
603  }
604  static void IntraChromaPreds_MSA(uint8_t* dst, const uint8_t* left,
605                                   const uint8_t* top) {
606    DCMode8x8(C8DC8 + dst, left, top);
607    VerticalPred8x8(C8VE8 + dst, top);
608    HorizontalPred8x8(C8HE8 + dst, left);
609    TrueMotion8x8(C8TM8 + dst, left, top);
610    dst += 8;
611    if (top != NULL) top += 8;
612    if (left != NULL) left += 16;
613    DCMode8x8(C8DC8 + dst, left, top);
614    VerticalPred8x8(C8VE8 + dst, top);
615    HorizontalPred8x8(C8HE8 + dst, left);
616    TrueMotion8x8(C8TM8 + dst, left, top);
617  }
618  #define PACK_DOTP_UB4_SW(in0, in1, in2, in3, out0, out1, out2, out3) do {  \
619    v16u8 tmp0, tmp1;                                                        \
620    v8i16 tmp2, tmp3;                                                        \
621    ILVRL_B2_UB(in0, in1, tmp0, tmp1);                                       \
622    HSUB_UB2_SH(tmp0, tmp1, tmp2, tmp3);                                     \
623    DOTP_SH2_SW(tmp2, tmp3, tmp2, tmp3, out0, out1);                         \
624    ILVRL_B2_UB(in2, in3, tmp0, tmp1);                                       \
625    HSUB_UB2_SH(tmp0, tmp1, tmp2, tmp3);                                     \
626    DOTP_SH2_SW(tmp2, tmp3, tmp2, tmp3, out2, out3);                         \
627  } while (0)
628  #define PACK_DPADD_UB4_SW(in0, in1, in2, in3, out0, out1, out2, out3) do {  \
629    v16u8 tmp0, tmp1;                                                         \
630    v8i16 tmp2, tmp3;                                                         \
631    ILVRL_B2_UB(in0, in1, tmp0, tmp1);                                        \
632    HSUB_UB2_SH(tmp0, tmp1, tmp2, tmp3);                                      \
633    DPADD_SH2_SW(tmp2, tmp3, tmp2, tmp3, out0, out1);                         \
634    ILVRL_B2_UB(in2, in3, tmp0, tmp1);                                        \
635    HSUB_UB2_SH(tmp0, tmp1, tmp2, tmp3);                                      \
636    DPADD_SH2_SW(tmp2, tmp3, tmp2, tmp3, out2, out3);                         \
637  } while (0)
638  static int SSE16x16_MSA(const uint8_t* a, const uint8_t* b) {
639    uint32_t sum;
640    v16u8 src0, src1, src2, src3, src4, src5, src6, src7;
641    v16u8 ref0, ref1, ref2, ref3, ref4, ref5, ref6, ref7;
642    v4i32 out0, out1, out2, out3;
643    LD_UB8(a, BPS, src0, src1, src2, src3, src4, src5, src6, src7);
644    LD_UB8(b, BPS, ref0, ref1, ref2, ref3, ref4, ref5, ref6, ref7);
645    PACK_DOTP_UB4_SW(src0, ref0, src1, ref1, out0, out1, out2, out3);
646    PACK_DPADD_UB4_SW(src2, ref2, src3, ref3, out0, out1, out2, out3);
647    PACK_DPADD_UB4_SW(src4, ref4, src5, ref5, out0, out1, out2, out3);
648    PACK_DPADD_UB4_SW(src6, ref6, src7, ref7, out0, out1, out2, out3);
649    a += 8 * BPS;
650    b += 8 * BPS;
651    LD_UB8(a, BPS, src0, src1, src2, src3, src4, src5, src6, src7);
652    LD_UB8(b, BPS, ref0, ref1, ref2, ref3, ref4, ref5, ref6, ref7);
653    PACK_DPADD_UB4_SW(src0, ref0, src1, ref1, out0, out1, out2, out3);
654    PACK_DPADD_UB4_SW(src2, ref2, src3, ref3, out0, out1, out2, out3);
655    PACK_DPADD_UB4_SW(src4, ref4, src5, ref5, out0, out1, out2, out3);
656    PACK_DPADD_UB4_SW(src6, ref6, src7, ref7, out0, out1, out2, out3);
657    out0 += out1;
658    out2 += out3;
659    out0 += out2;
660    sum = HADD_SW_S32(out0);
661    return sum;
662  }
663  static int SSE16x8_MSA(const uint8_t* a, const uint8_t* b) {
664    uint32_t sum;
665    v16u8 src0, src1, src2, src3, src4, src5, src6, src7;
666    v16u8 ref0, ref1, ref2, ref3, ref4, ref5, ref6, ref7;
667    v4i32 out0, out1, out2, out3;
668    LD_UB8(a, BPS, src0, src1, src2, src3, src4, src5, src6, src7);
669    LD_UB8(b, BPS, ref0, ref1, ref2, ref3, ref4, ref5, ref6, ref7);
670    PACK_DOTP_UB4_SW(src0, ref0, src1, ref1, out0, out1, out2, out3);
671    PACK_DPADD_UB4_SW(src2, ref2, src3, ref3, out0, out1, out2, out3);
672    PACK_DPADD_UB4_SW(src4, ref4, src5, ref5, out0, out1, out2, out3);
673    PACK_DPADD_UB4_SW(src6, ref6, src7, ref7, out0, out1, out2, out3);
674    out0 += out1;
675    out2 += out3;
676    out0 += out2;
677    sum = HADD_SW_S32(out0);
678    return sum;
679  }
680  static int SSE8x8_MSA(const uint8_t* a, const uint8_t* b) {
681    uint32_t sum;
682    v16u8 src0, src1, src2, src3, src4, src5, src6, src7;
683    v16u8 ref0, ref1, ref2, ref3, ref4, ref5, ref6, ref7;
684    v16u8 t0, t1, t2, t3;
685    v4i32 out0, out1, out2, out3;
686    LD_UB8(a, BPS, src0, src1, src2, src3, src4, src5, src6, src7);
687    LD_UB8(b, BPS, ref0, ref1, ref2, ref3, ref4, ref5, ref6, ref7);
688    ILVR_B4_UB(src0, src1, src2, src3, ref0, ref1, ref2, ref3, t0, t1, t2, t3);
689    PACK_DOTP_UB4_SW(t0, t2, t1, t3, out0, out1, out2, out3);
690    ILVR_B4_UB(src4, src5, src6, src7, ref4, ref5, ref6, ref7, t0, t1, t2, t3);
691    PACK_DPADD_UB4_SW(t0, t2, t1, t3, out0, out1, out2, out3);
692    out0 += out1;
693    out2 += out3;
694    out0 += out2;
695    sum = HADD_SW_S32(out0);
696    return sum;
697  }
698  static int SSE4x4_MSA(const uint8_t* a, const uint8_t* b) {
699    uint32_t sum = 0;
700    uint32_t src0, src1, src2, src3, ref0, ref1, ref2, ref3;
701    v16u8 src = { 0 }, ref = { 0 }, tmp0, tmp1;
702    v8i16 diff0, diff1;
703    v4i32 out0, out1;
704    LW4(a, BPS, src0, src1, src2, src3);
705    LW4(b, BPS, ref0, ref1, ref2, ref3);
706    INSERT_W4_UB(src0, src1, src2, src3, src);
707    INSERT_W4_UB(ref0, ref1, ref2, ref3, ref);
708    ILVRL_B2_UB(src, ref, tmp0, tmp1);
709    HSUB_UB2_SH(tmp0, tmp1, diff0, diff1);
710    DOTP_SH2_SW(diff0, diff1, diff0, diff1, out0, out1);
711    out0 += out1;
712    sum = HADD_SW_S32(out0);
713    return sum;
714  }
715  static int QuantizeBlock_MSA(int16_t in[16], int16_t out[16],
716                               const VP8Matrix* const mtx) {
717    int sum;
718    v8i16 in0, in1, sh0, sh1, out0, out1;
719    v8i16 tmp0, tmp1, tmp2, tmp3, tmp4, tmp5, sign0, sign1;
720    v4i32 s0, s1, s2, s3, b0, b1, b2, b3, t0, t1, t2, t3;
721    const v8i16 zero = { 0 };
722    const v8i16 zigzag0 = { 0, 1, 4, 8, 5, 2, 3, 6 };
723    const v8i16 zigzag1 = { 9, 12, 13, 10, 7, 11, 14, 15 };
724    const v8i16 maxlevel = __msa_fill_h(MAX_LEVEL);
725    LD_SH2(&in[0], 8, in0, in1);
726    LD_SH2(&mtx->sharpen_[0], 8, sh0, sh1);
727    tmp4 = __msa_add_a_h(in0, zero);
728    tmp5 = __msa_add_a_h(in1, zero);
729    ILVRL_H2_SH(sh0, tmp4, tmp0, tmp1);
730    ILVRL_H2_SH(sh1, tmp5, tmp2, tmp3);
731    HADD_SH4_SW(tmp0, tmp1, tmp2, tmp3, s0, s1, s2, s3);
732    sign0 = (in0 < zero);
733    sign1 = (in1 < zero);                           
734    LD_SH2(&mtx->iq_[0], 8, tmp0, tmp1);            
735    ILVRL_H2_SW(zero, tmp0, t0, t1);
736    ILVRL_H2_SW(zero, tmp1, t2, t3);
737    LD_SW4(&mtx->bias_[0], 4, b0, b1, b2, b3);      
738    MUL4(t0, s0, t1, s1, t2, s2, t3, s3, t0, t1, t2, t3);
739    ADD4(b0, t0, b1, t1, b2, t2, b3, t3, b0, b1, b2, b3);
740    SRAI_W4_SW(b0, b1, b2, b3, 17);
741    PCKEV_H2_SH(b1, b0, b3, b2, tmp2, tmp3);
742    tmp0 = (tmp2 > maxlevel);
743    tmp1 = (tmp3 > maxlevel);
744    tmp2 = (v8i16)__msa_bmnz_v((v16u8)tmp2, (v16u8)maxlevel, (v16u8)tmp0);
745    tmp3 = (v8i16)__msa_bmnz_v((v16u8)tmp3, (v16u8)maxlevel, (v16u8)tmp1);
746    SUB2(zero, tmp2, zero, tmp3, tmp0, tmp1);
747    tmp2 = (v8i16)__msa_bmnz_v((v16u8)tmp2, (v16u8)tmp0, (v16u8)sign0);
748    tmp3 = (v8i16)__msa_bmnz_v((v16u8)tmp3, (v16u8)tmp1, (v16u8)sign1);
749    LD_SW4(&mtx->zthresh_[0], 4, t0, t1, t2, t3);   
750    t0 = (s0 > t0);
751    t1 = (s1 > t1);
752    t2 = (s2 > t2);
753    t3 = (s3 > t3);
754    PCKEV_H2_SH(t1, t0, t3, t2, tmp0, tmp1);
755    tmp4 = (v8i16)__msa_bmnz_v((v16u8)zero, (v16u8)tmp2, (v16u8)tmp0);
756    tmp5 = (v8i16)__msa_bmnz_v((v16u8)zero, (v16u8)tmp3, (v16u8)tmp1);
757    LD_SH2(&mtx->q_[0], 8, tmp0, tmp1);
758    MUL2(tmp4, tmp0, tmp5, tmp1, in0, in1);
759    VSHF_H2_SH(tmp4, tmp5, tmp4, tmp5, zigzag0, zigzag1, out0, out1);
760    ST_SH2(in0, in1, &in[0], 8);
761    ST_SH2(out0, out1, &out[0], 8);
762    out0 = __msa_add_a_h(out0, out1);
763    sum = HADD_SH_S32(out0);
764    return (sum > 0);
765  }
766  static int Quantize2Blocks_MSA(int16_t in[32], int16_t out[32],
767                                 const VP8Matrix* const mtx) {
768    int nz;
769    nz  = VP8EncQuantizeBlock(in + 0 * 16, out + 0 * 16, mtx) << 0;
770    nz |= VP8EncQuantizeBlock(in + 1 * 16, out + 1 * 16, mtx) << 1;
771    return nz;
772  }
773  extern void VP8EncDspInitMSA(void);
774  WEBP_TSAN_IGNORE_FUNCTION void VP8EncDspInitMSA(void) {
775    VP8ITransform = ITransform_MSA;
776    VP8FTransform = FTransform_MSA;
777    VP8FTransformWHT = FTransformWHT_MSA;
778    VP8TDisto4x4 = Disto4x4_MSA;
779    VP8TDisto16x16 = Disto16x16_MSA;
780    VP8CollectHistogram = CollectHistogram_MSA;
781    VP8EncPredLuma4 = Intra4Preds_MSA;
782    VP8EncPredLuma16 = Intra16Preds_MSA;
783    VP8EncPredChroma8 = IntraChromaPreds_MSA;
784    VP8SSE16x16 = SSE16x16_MSA;
785    VP8SSE16x8 = SSE16x8_MSA;
786    VP8SSE8x8 = SSE8x8_MSA;
787    VP8SSE4x4 = SSE4x4_MSA;
788    VP8EncQuantizeBlock = QuantizeBlock_MSA;
789    VP8EncQuantize2Blocks = Quantize2Blocks_MSA;
790    VP8EncQuantizeBlockWHT = QuantizeBlock_MSA;
791  }
792  #else  
793  WEBP_DSP_INIT_STUB(VP8EncDspInitMSA)
794  #endif  
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from PINRemoteImage-MDEwOlJlcG9zaXRvcnkzOTUzNzEwMw==-flat-demux.h</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from PINRemoteImage-MDEwOlJlcG9zaXRvcnkzOTUzNzEwMw==-flat-enc_msa.c</div>
                </div>
                <div class="column column_space"><pre><code>42    int frame_num;
43    int num_frames;          
44    int x_offset, y_offset;  
45    int width, height;       
46    int duration;            
47    WebPMuxAnimDispose dispose_method;  
48    int complete;   
49    WebPData fragment;  
50    int has_alpha;      
51    WebPMuxAnimBlend blend_method;  
52    uint32_t pad[2];         
53    void* private_;          
</pre></code></div>
                <div class="column column_space"><pre><code>40    ILVR_B4_SW(zero, dest0, zero, dest1, zero, dest2, zero, dest3,
41               res0, res1, res2, res3);
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    