
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 19.389587073608617%, Tokens: 10, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>redis-MDEwOlJlcG9zaXRvcnkxMDgxMTA3MDY=-flat-rtree_16.c</h3>
            <pre><code>1  #define JEMALLOC_RTREE_C_
2  #include "jemalloc/internal/jemalloc_preamble.h"
3  #include "jemalloc/internal/jemalloc_internal_includes.h"
4  #include "jemalloc/internal/assert.h"
5  #include "jemalloc/internal/mutex.h"
6  bool
7  rtree_new(rtree_t *rtree, bool zeroed) {
8  #ifdef JEMALLOC_JET
9  	if (!zeroed) {
10  		memset(rtree, 0, sizeof(rtree_t)); &bsol;* Clear root. */
11  	}
12  #else
13  	assert(zeroed);
14  #endif
15  	if (malloc_mutex_init(&rtree->init_lock, "rtree", WITNESS_RANK_RTREE,
16  	    malloc_mutex_rank_exclusive)) {
17  		return true;
18  	}
19  	return false;
20  }
21  static rtree_node_elm_t *
22  rtree_node_alloc_impl(tsdn_t *tsdn, rtree_t *rtree, size_t nelms) {
23  	return (rtree_node_elm_t *)base_alloc(tsdn, b0get(), nelms *
24  	    sizeof(rtree_node_elm_t), CACHELINE);
25  }
26  rtree_node_alloc_t *JET_MUTABLE rtree_node_alloc = rtree_node_alloc_impl;
27  static void
28  rtree_node_dalloc_impl(tsdn_t *tsdn, rtree_t *rtree, rtree_node_elm_t *node) {
29  	not_reached();
30  }
31  rtree_node_dalloc_t *JET_MUTABLE rtree_node_dalloc =
32      rtree_node_dalloc_impl;
33  static rtree_leaf_elm_t *
34  rtree_leaf_alloc_impl(tsdn_t *tsdn, rtree_t *rtree, size_t nelms) {
35  	return (rtree_leaf_elm_t *)base_alloc(tsdn, b0get(), nelms *
36  	    sizeof(rtree_leaf_elm_t), CACHELINE);
37  }
38  rtree_leaf_alloc_t *JET_MUTABLE rtree_leaf_alloc = rtree_leaf_alloc_impl;
39  static void
40  rtree_leaf_dalloc_impl(tsdn_t *tsdn, rtree_t *rtree, rtree_leaf_elm_t *leaf) {
41  	not_reached();
42  }
43  rtree_leaf_dalloc_t *JET_MUTABLE rtree_leaf_dalloc =
44      rtree_leaf_dalloc_impl;
45  #ifdef JEMALLOC_JET
46  #  if RTREE_HEIGHT > 1
47  static void
48  rtree_delete_subtree(tsdn_t *tsdn, rtree_t *rtree, rtree_node_elm_t *subtree,
49      unsigned level) {
50  	size_t nchildren = ZU(1) << rtree_levels[level].bits;
51  	if (level + 2 < RTREE_HEIGHT) {
52  		for (size_t i = 0; i < nchildren; i++) {
53  			rtree_node_elm_t *node =
54  			    (rtree_node_elm_t *)atomic_load_p(&subtree[i].child,
55  			    ATOMIC_RELAXED);
56  			if (node != NULL) {
57  				rtree_delete_subtree(tsdn, rtree, node, level +
58  				    1);
59  			}
60  		}
61  	} else {
62  		for (size_t i = 0; i < nchildren; i++) {
63  			rtree_leaf_elm_t *leaf =
64  			    (rtree_leaf_elm_t *)atomic_load_p(&subtree[i].child,
65  			    ATOMIC_RELAXED);
66  			if (leaf != NULL) {
67  				rtree_leaf_dalloc(tsdn, rtree, leaf);
68  			}
69  		}
70  	}
71  	if (subtree != rtree->root) {
72  		rtree_node_dalloc(tsdn, rtree, subtree);
73  	}
74  }
75  #  endif
76  void
77  rtree_delete(tsdn_t *tsdn, rtree_t *rtree) {
78  #  if RTREE_HEIGHT > 1
79  	rtree_delete_subtree(tsdn, rtree, rtree->root, 0);
80  #  endif
81  }
82  #endif
83  static rtree_node_elm_t *
84  rtree_node_init(tsdn_t *tsdn, rtree_t *rtree, unsigned level,
85      atomic_p_t *elmp) {
86  	malloc_mutex_lock(tsdn, &rtree->init_lock);
87  	rtree_node_elm_t *node = atomic_load_p(elmp, ATOMIC_RELAXED);
88  	if (node == NULL) {
89  		node = rtree_node_alloc(tsdn, rtree, ZU(1) <<
90  		    rtree_levels[level].bits);
91  		if (node == NULL) {
92  			malloc_mutex_unlock(tsdn, &rtree->init_lock);
93  			return NULL;
94  		}
95  		atomic_store_p(elmp, node, ATOMIC_RELEASE);
96  	}
97  	malloc_mutex_unlock(tsdn, &rtree->init_lock);
98  	return node;
99  }
100  static rtree_leaf_elm_t *
101  rtree_leaf_init(tsdn_t *tsdn, rtree_t *rtree, atomic_p_t *elmp) {
102  	malloc_mutex_lock(tsdn, &rtree->init_lock);
103  	rtree_leaf_elm_t *leaf = atomic_load_p(elmp, ATOMIC_RELAXED);
104  	if (leaf == NULL) {
105  		leaf = rtree_leaf_alloc(tsdn, rtree, ZU(1) <<
106  		    rtree_levels[RTREE_HEIGHT-1].bits);
107  		if (leaf == NULL) {
108  			malloc_mutex_unlock(tsdn, &rtree->init_lock);
109  			return NULL;
110  		}
111  		atomic_store_p(elmp, leaf, ATOMIC_RELEASE);
112  	}
113  	malloc_mutex_unlock(tsdn, &rtree->init_lock);
114  	return leaf;
115  }
116  static bool
117  rtree_node_valid(rtree_node_elm_t *node) {
118  	return ((uintptr_t)node != (uintptr_t)0);
119  }
120  static bool
121  rtree_leaf_valid(rtree_leaf_elm_t *leaf) {
122  	return ((uintptr_t)leaf != (uintptr_t)0);
123  }
124  static rtree_node_elm_t *
125  rtree_child_node_tryread(rtree_node_elm_t *elm, bool dependent) {
126  	rtree_node_elm_t *node;
127  	if (dependent) {
128  		node = (rtree_node_elm_t *)atomic_load_p(&elm->child,
129  		    ATOMIC_RELAXED);
130  	} else {
131  		node = (rtree_node_elm_t *)atomic_load_p(&elm->child,
132  		    ATOMIC_ACQUIRE);
133  	}
134  	assert(!dependent || node != NULL);
135  	return node;
136  }
137  static rtree_node_elm_t *
138  rtree_child_node_read(tsdn_t *tsdn, rtree_t *rtree, rtree_node_elm_t *elm,
139      unsigned level, bool dependent) {
140  	rtree_node_elm_t *node;
141  	node = rtree_child_node_tryread(elm, dependent);
142  	if (!dependent && unlikely(!rtree_node_valid(node))) {
143  		node = rtree_node_init(tsdn, rtree, level + 1, &elm->child);
144  	}
145  	assert(!dependent || node != NULL);
146  	return node;
147  }
148  static rtree_leaf_elm_t *
149  rtree_child_leaf_tryread(rtree_node_elm_t *elm, bool dependent) {
150  	rtree_leaf_elm_t *leaf;
151  	if (dependent) {
152  		leaf = (rtree_leaf_elm_t *)atomic_load_p(&elm->child,
153  		    ATOMIC_RELAXED);
154  	} else {
155  		leaf = (rtree_leaf_elm_t *)atomic_load_p(&elm->child,
156  		    ATOMIC_ACQUIRE);
157  	}
158  	assert(!dependent || leaf != NULL);
<span onclick='openModal()' class='match'>159  	return leaf;
160  }
161  static rtree_leaf_elm_t *
162  rtree_child_leaf_read(tsdn_t *tsdn, rtree_t *rtree, rtree_node_elm_t *elm,
163      unsigned level, bool dependent) {
164  	rtree_leaf_elm_t *leaf;
165  	leaf = rtree_child_leaf_tryread(elm, dependent);
</span>166  	if (!dependent && unlikely(!rtree_leaf_valid(leaf))) {
167  		leaf = rtree_leaf_init(tsdn, rtree, &elm->child);
168  	}
169  	assert(!dependent || leaf != NULL);
170  	return leaf;
171  }
172  rtree_leaf_elm_t *
173  rtree_leaf_elm_lookup_hard(tsdn_t *tsdn, rtree_t *rtree, rtree_ctx_t *rtree_ctx,
174      uintptr_t key, bool dependent, bool init_missing) {
175  	rtree_node_elm_t *node;
176  	rtree_leaf_elm_t *leaf;
177  #if RTREE_HEIGHT > 1
178  	node = rtree->root;
179  #else
180  	leaf = rtree->root;
181  #endif
182  	if (config_debug) {
183  		uintptr_t leafkey = rtree_leafkey(key);
184  		for (unsigned i = 0; i < RTREE_CTX_NCACHE; i++) {
185  			assert(rtree_ctx->cache[i].leafkey != leafkey);
186  		}
187  		for (unsigned i = 0; i < RTREE_CTX_NCACHE_L2; i++) {
188  			assert(rtree_ctx->l2_cache[i].leafkey != leafkey);
189  		}
190  	}
191  #define RTREE_GET_CHILD(level) {					\
192  		assert(level < RTREE_HEIGHT-1);				\
193  		if (level != 0 && !dependent &&				\
194  		    unlikely(!rtree_node_valid(node))) {		\
195  			return NULL;					\
196  		}							\
197  		uintptr_t subkey = rtree_subkey(key, level);		\
198  		if (level + 2 < RTREE_HEIGHT) {				\
199  			node = init_missing ?				\
200  			    rtree_child_node_read(tsdn, rtree,		\
201  			    &node[subkey], level, dependent) :		\
202  			    rtree_child_node_tryread(&node[subkey],	\
203  			    dependent);					\
204  		} else {						\
205  			leaf = init_missing ?				\
206  			    rtree_child_leaf_read(tsdn, rtree,		\
207  			    &node[subkey], level, dependent) :		\
208  			    rtree_child_leaf_tryread(&node[subkey],	\
209  			    dependent);					\
210  		}							\
211  	}
212  #define RTREE_GET_LEAF(level) {						\
213  		assert(level == RTREE_HEIGHT-1);			\
214  		if (!dependent && unlikely(!rtree_leaf_valid(leaf))) {	\
215  			return NULL;					\
216  		}							\
217  		if (RTREE_CTX_NCACHE_L2 > 1) {				\
218  			memmove(&rtree_ctx->l2_cache[1],		\
219  			    &rtree_ctx->l2_cache[0],			\
220  			    sizeof(rtree_ctx_cache_elm_t) *		\
221  			    (RTREE_CTX_NCACHE_L2 - 1));			\
222  		}							\
223  		size_t slot = rtree_cache_direct_map(key);		\
224  		rtree_ctx->l2_cache[0].leafkey =			\
225  		    rtree_ctx->cache[slot].leafkey;			\
226  		rtree_ctx->l2_cache[0].leaf =				\
227  		    rtree_ctx->cache[slot].leaf;			\
228  		uintptr_t leafkey = rtree_leafkey(key);			\
229  		rtree_ctx->cache[slot].leafkey = leafkey;		\
230  		rtree_ctx->cache[slot].leaf = leaf;			\
231  		uintptr_t subkey = rtree_subkey(key, level);		\
232  		return &leaf[subkey];					\
233  	}
234  	if (RTREE_HEIGHT > 1) {
235  		RTREE_GET_CHILD(0)
236  	}
237  	if (RTREE_HEIGHT > 2) {
238  		RTREE_GET_CHILD(1)
239  	}
240  	if (RTREE_HEIGHT > 3) {
241  		for (unsigned i = 2; i < RTREE_HEIGHT-1; i++) {
242  			RTREE_GET_CHILD(i)
243  		}
244  	}
245  	RTREE_GET_LEAF(RTREE_HEIGHT-1)
246  #undef RTREE_GET_CHILD
247  #undef RTREE_GET_LEAF
248  	not_reached();
249  }
250  void
251  rtree_ctx_data_init(rtree_ctx_t *ctx) {
252  	for (unsigned i = 0; i < RTREE_CTX_NCACHE; i++) {
253  		rtree_ctx_cache_elm_t *cache = &ctx->cache[i];
254  		cache->leafkey = RTREE_LEAFKEY_INVALID;
255  		cache->leaf = NULL;
256  	}
257  	for (unsigned i = 0; i < RTREE_CTX_NCACHE_L2; i++) {
258  		rtree_ctx_cache_elm_t *cache = &ctx->l2_cache[i];
259  		cache->leafkey = RTREE_LEAFKEY_INVALID;
260  		cache->leaf = NULL;
261  	}
262  }
</code></pre>
        </div>
        <div class="column">
            <h3>fftw3-MDEwOlJlcG9zaXRvcnk4ODQzMzg4-flat-vrank-geq1-rdft2_18.c</h3>
            <pre><code>1  #include "threads/threads.h"
2  typedef struct {
3       solver super;
4       int vecloop_dim;
5       const int *buddies;
6       size_t nbuddies;
7  } S;
8  typedef struct {
9       plan_rdft2 super;
10       plan **cldrn;
11       INT its, ots;
12       int nthr;
13       const S *solver;
14  } P;
15  typedef struct {
16       INT its, ots;
17       R *r0, *r1, *cr, *ci;
18       plan **cldrn;
19  } PD;
20  static void *spawn_apply(spawn_data *d)
21  {
22       PD *ego = (PD *) d->data;
23       INT its = ego->its;
24       INT ots = ego->ots;
25       int thr_num = d->thr_num;
26       plan_rdft2 *cld = (plan_rdft2 *) ego->cldrn[d->thr_num];
27       cld->apply((plan *) cld,
28  		ego->r0 + thr_num * its, ego->r1 + thr_num * its,
29  		ego->cr + thr_num * ots, ego->ci + thr_num * ots);
<span onclick='openModal()' class='match'>30       return 0;
31  }
32  static void apply(const plan *ego_, R *r0, R *r1, R *cr, R *ci)
33  {
34       const P *ego = (const P *) ego_;
</span>35       PD d;
36       d.its = ego->its;
37       d.ots = ego->ots;
38       d.cldrn = ego->cldrn;
39       d.r0 = r0; d.r1 = r1; d.cr = cr; d.ci = ci;
40       X(spawn_loop)(ego->nthr, ego->nthr, spawn_apply, (void*) &d);
41  }
42  static void awake(plan *ego_, enum wakefulness wakefulness)
43  {
44       P *ego = (P *) ego_;
45       int i;
46       for (i = 0; i < ego->nthr; ++i)
47  	  X(plan_awake)(ego->cldrn[i], wakefulness);
48  }
49  static void destroy(plan *ego_)
50  {
51       P *ego = (P *) ego_;
52       int i;
53       for (i = 0; i < ego->nthr; ++i)
54  	  X(plan_destroy_internal)(ego->cldrn[i]);
55       X(ifree)(ego->cldrn);
56  }
57  static void print(const plan *ego_, printer *p)
58  {
59       const P *ego = (const P *) ego_;
60       const S *s = ego->solver;
61       int i;
62       p->print(p, "(rdft2-thr-vrank>=1-x%d/%d)", ego->nthr, s->vecloop_dim);
63       for (i = 0; i < ego->nthr; ++i)
64  	  if (i == 0 || (ego->cldrn[i] != ego->cldrn[i-1] &&
65  			 (i <= 1 || ego->cldrn[i] != ego->cldrn[i-2])))
66  	       p->print(p, "%(%p%)", ego->cldrn[i]);
67       p->putchr(p, ')');
68  }
69  static int pickdim(const S *ego, const tensor *vecsz, int oop, int *dp)
70  {
71       return X(pickdim)(ego->vecloop_dim, ego->buddies, ego->nbuddies,
72  		       vecsz, oop, dp);
73  }
74  static int applicable0(const solver *ego_, const problem *p_,
75  		       const planner *plnr, int *dp)
76  {
77       const S *ego = (const S *) ego_;
78       const problem_rdft2 *p = (const problem_rdft2 *) p_;
79       if (FINITE_RNK(p->vecsz->rnk)
80  	 && p->vecsz->rnk > 0
81  	 && plnr->nthr > 1
82  	 && pickdim(ego, p->vecsz, p->r0 != p->cr, dp)) {
83  	  if (p->r0 != p->cr)
84  	       return 1;  &bsol;* can always operate out-of-place */
85  	  return(X(rdft2_inplace_strides)(p, *dp));
86       }
87       return 0;
88  }
89  static int applicable(const solver *ego_, const problem *p_,
90  		      const planner *plnr, int *dp)
91  {
92       const S *ego = (const S *)ego_;
93       if (!applicable0(ego_, p_, plnr, dp)) return 0;
94       if (NO_VRANK_SPLITSP(plnr) && (ego->vecloop_dim != ego->buddies[0]))
95  	  return 0;
96       return 1;
97  }
98  static plan *mkplan(const solver *ego_, const problem *p_, planner *plnr)
99  {
100       const S *ego = (const S *) ego_;
101       const problem_rdft2 *p;
102       P *pln;
103       problem *cldp;
104       int vdim;
105       iodim *d;
106       plan **cldrn = (plan **) 0;
107       int i, nthr;
108       INT its, ots, block_size;
109       tensor *vecsz;
110       static const plan_adt padt = {
111  	  X(rdft2_solve), awake, print, destroy
112       };
113       if (!applicable(ego_, p_, plnr, &vdim))
114            return (plan *) 0;
115       p = (const problem_rdft2 *) p_;
116       d = p->vecsz->dims + vdim;
117       block_size = (d->n + plnr->nthr - 1) / plnr->nthr;
118       nthr = (int)((d->n + block_size - 1) / block_size);
119       plnr->nthr = (plnr->nthr + nthr - 1) / nthr;
120       X(rdft2_strides)(p->kind, d, &its, &ots);
121       its *= block_size; ots *= block_size;
122       cldrn = (plan **)MALLOC(sizeof(plan *) * nthr, PLANS);
123       for (i = 0; i < nthr; ++i) cldrn[i] = (plan *) 0;
124       vecsz = X(tensor_copy)(p->vecsz);
125       for (i = 0; i < nthr; ++i) {
126  	  vecsz->dims[vdim].n =
127  	       (i == nthr - 1) ? (d->n - i*block_size) : block_size;
128  	  cldp = X(mkproblem_rdft2)(p->sz, vecsz,
129  				    p->r0 + i*its, p->r1 + i*its,
130  				    p->cr + i*ots, p->ci + i*ots, 
131  				    p->kind);
132  	  cldrn[i] = X(mkplan_d)(plnr, cldp);
133  	  if (!cldrn[i]) goto nada;
134       }
135       X(tensor_destroy)(vecsz);
136       pln = MKPLAN_RDFT2(P, &padt, apply);
137       pln->cldrn = cldrn;
138       pln->its = its;
139       pln->ots = ots;
140       pln->nthr = nthr;
141       pln->solver = ego;
142       X(ops_zero)(&pln->super.super.ops);
143       pln->super.super.pcost = 0;
144       for (i = 0; i < nthr; ++i) {
145  	  X(ops_add2)(&cldrn[i]->ops, &pln->super.super.ops);
146  	  pln->super.super.pcost += cldrn[i]->pcost;
147       }
148       return &(pln->super.super);
149   nada:
150       if (cldrn) {
151  	  for (i = 0; i < nthr; ++i)
152  	       X(plan_destroy_internal)(cldrn[i]);
153  	  X(ifree)(cldrn);
154       }
155       X(tensor_destroy)(vecsz);
156       return (plan *) 0;
157  }
158  static solver *mksolver(int vecloop_dim, const int *buddies, size_t nbuddies)
159  {
160       static const solver_adt sadt = { PROBLEM_RDFT2, mkplan, 0 };
161       S *slv = MKSOLVER(S, &sadt);
162       slv->vecloop_dim = vecloop_dim;
163       slv->buddies = buddies;
164       slv->nbuddies = nbuddies;
165       return &(slv->super);
166  }
167  void X(rdft2_thr_vrank_geq1_register)(planner *p)
168  {
169       static const int buddies[] = { 1, -1 };
170       size_t i;
171       for (i = 0; i < NELEM(buddies); ++i)
172            REGISTER_SOLVER(p, mksolver(buddies[i], buddies, NELEM(buddies)));
173  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from redis-MDEwOlJlcG9zaXRvcnkxMDgxMTA3MDY=-flat-rtree_16.c</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from fftw3-MDEwOlJlcG9zaXRvcnk4ODQzMzg4-flat-vrank-geq1-rdft2_18.c</div>
                </div>
                <div class="column column_space"><pre><code>159  	return leaf;
160  }
161  static rtree_leaf_elm_t *
162  rtree_child_leaf_read(tsdn_t *tsdn, rtree_t *rtree, rtree_node_elm_t *elm,
163      unsigned level, bool dependent) {
164  	rtree_leaf_elm_t *leaf;
165  	leaf = rtree_child_leaf_tryread(elm, dependent);
</pre></code></div>
                <div class="column column_space"><pre><code>30       return 0;
31  }
32  static void apply(const plan *ego_, R *r0, R *r1, R *cr, R *ci)
33  {
34       const P *ego = (const P *) ego_;
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    