
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 17.655172413793103%, Tokens: 8, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>libtomcrypt-MDEwOlJlcG9zaXRvcnk3NzcwMTE=-flat-test.c</h3>
            <pre><code>1  #include <tomcrypt_test.h>
2  #ifndef GIT_VERSION
3  #define GIT_VERSION "Undefined version"
4  #endif
5  #define LTC_TEST_FN(f)  { f, #f }
6  typedef struct {
7     int (*fn)(void);
8     const char* name;
9  } test_function;
10  static const test_function test_functions[] =
11  {
12        LTC_TEST_FN(store_test),
13        LTC_TEST_FN(rotate_test),
14        LTC_TEST_FN(misc_test),
15        LTC_TEST_FN(mpi_test),
16        LTC_TEST_FN(cipher_hash_test),
17        LTC_TEST_FN(mac_test),
18        LTC_TEST_FN(modes_test),
19        LTC_TEST_FN(der_test),
20        LTC_TEST_FN(pkcs_1_test),
21        LTC_TEST_FN(pkcs_1_pss_test),
22        LTC_TEST_FN(pkcs_1_oaep_test),
23        LTC_TEST_FN(pkcs_1_emsa_test),
24        LTC_TEST_FN(pkcs_1_eme_test),
25        LTC_TEST_FN(rsa_test),
26        LTC_TEST_FN(dh_test),
27        LTC_TEST_FN(ecc_test),
28        LTC_TEST_FN(dsa_test),
29        LTC_TEST_FN(ed25519_test),
30        LTC_TEST_FN(x25519_test),
31        LTC_TEST_FN(file_test),
32        LTC_TEST_FN(multi_test),
33        LTC_TEST_FN(prng_test),
34  };
35  #if defined(_WIN32)
36    #include <windows.h> &bsol;* GetSystemTimeAsFileTime */
37  #else
38    #include <sys/time.h>
39  #endif
40  static ulong64 epoch_usec(void)
41  {
42  #if defined(LTC_NO_TEST_TIMING)
43    return 0;
44  #elif defined(_WIN32)
45    FILETIME CurrentTime;
46    ulong64 cur_time;
47    ULARGE_INTEGER ul;
48    GetSystemTimeAsFileTime(&CurrentTime);
49    ul.LowPart  = CurrentTime.dwLowDateTime;
50    ul.HighPart = CurrentTime.dwHighDateTime;
51    cur_time = ul.QuadPart; &bsol;* now we have 100ns intervals since 1 January 1601 */
52    cur_time -= CONST64(116444736000000000); &bsol;* subtract 100ns intervals between 1601-1970 */
53    cur_time /= 10; &bsol;* 100ns intervals > microseconds */
54    return cur_time;
55  #elif defined(LTC_CLOCK_GETTIME)
56    struct timespec ts;
57    clock_gettime(CLOCK_MONOTONIC, &ts);
58    return (ulong64)(ts.tv_sec) * 1000000 + (ulong64)(ts.tv_nsec) / 1000; &bsol;* get microseconds */
59  #else
60    struct timeval tv;
61    gettimeofday(&tv, NULL);
62    return (ulong64)(tv.tv_sec) * 1000000 + (ulong64)(tv.tv_usec); &bsol;* get microseconds */
63  #endif
64  }
65  #ifdef LTC_PTHREAD
66  typedef struct
67  {
68     pthread_t thread_id;
69     const test_function* t;
70     int err;
71     ulong64 delta;
72  } thread_info;
73  static void *run(void *arg)
74  {
75     thread_info *tinfo = arg;
76     ulong64 ts;
77     ts = epoch_usec();
78     tinfo->err = tinfo->t->fn();
79     tinfo->delta = epoch_usec() - ts;
80     return arg;
81  }
82  #endif
83  static void s_unregister_all(void)
84  {
85  #ifdef LTC_RIJNDAEL
86  #ifdef ENCRYPT_ONLY
87     unregister_cipher(&aes_enc_desc);
88  #else
89     unregister_cipher(&aes_desc);
90  #endif
91  #endif
92  #ifdef LTC_BLOWFISH
93    unregister_cipher(&blowfish_desc);
94  #endif
95  #ifdef LTC_XTEA
96    unregister_cipher(&xtea_desc);
97  #endif
98  #ifdef LTC_RC5
99    unregister_cipher(&rc5_desc);
100  #endif
101  #ifdef LTC_RC6
102    unregister_cipher(&rc6_desc);
103  #endif
104  #ifdef LTC_SAFERP
105    unregister_cipher(&saferp_desc);
106  #endif
107  #ifdef LTC_TWOFISH
108    unregister_cipher(&twofish_desc);
109  #endif
110  #ifdef LTC_SAFER
111    unregister_cipher(&safer_k64_desc);
112    unregister_cipher(&safer_sk64_desc);
113    unregister_cipher(&safer_k128_desc);
114    unregister_cipher(&safer_sk128_desc);
115  #endif
116  #ifdef LTC_RC2
117    unregister_cipher(&rc2_desc);
118  #endif
119  #ifdef LTC_DES
120    unregister_cipher(&des_desc);
121    unregister_cipher(&des3_desc);
122  #endif
123  #ifdef LTC_CAST5
124    unregister_cipher(&cast5_desc);
125  #endif
126  #ifdef LTC_NOEKEON
127    unregister_cipher(&noekeon_desc);
128  #endif
129  #ifdef LTC_SKIPJACK
130    unregister_cipher(&skipjack_desc);
131  #endif
132  #ifdef LTC_KHAZAD
133    unregister_cipher(&khazad_desc);
134  #endif
135  #ifdef LTC_ANUBIS
136    unregister_cipher(&anubis_desc);
137  #endif
138  #ifdef LTC_KSEED
<span onclick='openModal()' class='match'>139    unregister_cipher(&kseed_desc);
140  #endif
141  #ifdef LTC_KASUMI
142    unregister_cipher(&kasumi_desc);
143  #endif
144  #ifdef LTC_MULTI2
145    unregister_cipher(&multi2_desc);
146  #endif
147  #ifdef LTC_CAMELLIA
148    unregister_cipher(&camellia_desc);
149  #endif
150  #ifdef LTC_IDEA
151    unregister_cipher(&idea_desc);
152  #endif
153  #ifdef LTC_SERPENT
154    unregister_cipher(&serpent_desc);
155  #endif
156  #ifdef LTC_TIGER
157    unregister_hash(&tiger_desc);
158  #endif
159  #ifdef LTC_MD2
160    unregister_hash(&md2_desc);
</span>161  #endif
162  #ifdef LTC_MD4
163    unregister_hash(&md4_desc);
164  #endif
165  #ifdef LTC_MD5
166    unregister_hash(&md5_desc);
167  #endif
168  #ifdef LTC_SHA1
169    unregister_hash(&sha1_desc);
170  #endif
171  #ifdef LTC_SHA224
172    unregister_hash(&sha224_desc);
173  #endif
174  #ifdef LTC_SHA256
175    unregister_hash(&sha256_desc);
176  #endif
177  #ifdef LTC_SHA384
178    unregister_hash(&sha384_desc);
179  #endif
180  #ifdef LTC_SHA512
181    unregister_hash(&sha512_desc);
182  #endif
183  #ifdef LTC_SHA512_224
184    unregister_hash(&sha512_224_desc);
185  #endif
186  #ifdef LTC_SHA512_256
187    unregister_hash(&sha512_256_desc);
188  #endif
189  #ifdef LTC_SHA3
190    unregister_hash(&sha3_224_desc);
191    unregister_hash(&sha3_256_desc);
192    unregister_hash(&sha3_384_desc);
193    unregister_hash(&sha3_512_desc);
194  #endif
195  #ifdef LTC_KECCAK
196    unregister_hash(&keccak_224_desc);
197    unregister_hash(&keccak_256_desc);
198    unregister_hash(&keccak_384_desc);
199    unregister_hash(&keccak_512_desc);
200  #endif
201  #ifdef LTC_RIPEMD128
202    unregister_hash(&rmd128_desc);
203  #endif
204  #ifdef LTC_RIPEMD160
205    unregister_hash(&rmd160_desc);
206  #endif
207  #ifdef LTC_RIPEMD256
208    unregister_hash(&rmd256_desc);
209  #endif
210  #ifdef LTC_RIPEMD320
211    unregister_hash(&rmd320_desc);
212  #endif
213  #ifdef LTC_WHIRLPOOL
214    unregister_hash(&whirlpool_desc);
215  #endif
216  #ifdef LTC_BLAKE2S
217    unregister_hash(&blake2s_128_desc);
218    unregister_hash(&blake2s_160_desc);
219    unregister_hash(&blake2s_224_desc);
220    unregister_hash(&blake2s_256_desc);
221  #endif
222  #ifdef LTC_BLAKE2B
223    unregister_hash(&blake2b_160_desc);
224    unregister_hash(&blake2b_256_desc);
225    unregister_hash(&blake2b_384_desc);
226    unregister_hash(&blake2b_512_desc);
227  #endif
228  #ifdef LTC_CHC_HASH
229    unregister_hash(&chc_desc);
230  #endif
231    unregister_prng(&yarrow_desc);
232  #ifdef LTC_FORTUNA
233    unregister_prng(&fortuna_desc);
234  #endif
235  #ifdef LTC_RC4
236    unregister_prng(&rc4_desc);
237  #endif
238  #ifdef LTC_CHACHA20_PRNG
239    unregister_prng(&chacha20_prng_desc);
240  #endif
241  #ifdef LTC_SOBER128
242    unregister_prng(&sober128_desc);
243  #endif
244  #ifdef LTC_SPRNG
245    unregister_prng(&sprng_desc);
246  #endif
247  } &bsol;* s_cleanup() */
248  static void register_algs(void)
249  {
250    int err;
251    atexit(s_unregister_all);
252  #ifndef LTC_YARROW
253     #error This demo requires Yarrow.
254  #endif
255     if ((err = register_all_ciphers()) != CRYPT_OK) {
256        fprintf(stderr, "register_all_ciphers err=%s\n", error_to_string(err));
257        exit(EXIT_FAILURE);
258     }
259     if ((err = register_all_hashes()) != CRYPT_OK) {
260        fprintf(stderr, "register_all_hashes err=%s\n", error_to_string(err));
261        exit(EXIT_FAILURE);
262     }
263     if ((err = register_all_prngs()) != CRYPT_OK) {
264        fprintf(stderr, "register_all_prngs err=%s\n", error_to_string(err));
265        exit(EXIT_FAILURE);
266     }
267     if ((err = rng_make_prng(128, find_prng("yarrow"), &yarrow_prng, NULL)) != CRYPT_OK) {
268        fprintf(stderr, "rng_make_prng failed: %s\n", error_to_string(err));
269        exit(EXIT_FAILURE);
270     }
271     if (strcmp("CRYPT_OK", error_to_string(err))) {
272         exit(EXIT_FAILURE);
273     }
274  }
275  int main(int argc, char **argv)
276  {
277  #ifdef LTC_PTHREAD
278     thread_info *tinfo, *res;
279  #endif
280     int x, pass = 0, fail = 0, nop = 0;
281     size_t fn_len, i, dots;
282     const char* mpi_provider = NULL;
283     char *single_test = NULL;
284     ulong64 ts;
285     long delta, dur, real = 0;
286     register_algs();
287     printf("LTC_VERSION  = %s\n%s\n\n", GIT_VERSION, crypt_build_settings);
288  #ifdef USE_LTM
289     mpi_provider = "ltm";
290  #elif defined(USE_TFM)
291     mpi_provider = "tfm";
292  #elif defined(USE_GMP)
293     mpi_provider = "gmp";
294  #elif defined(EXT_MATH_LIB)
295     mpi_provider = "ext";
296  #endif
297     if (argc > 2) {
298        mpi_provider = argv[2];
299     }
300     crypt_mp_init(mpi_provider);
301     if (ltc_mp.name != NULL) {
302        printf("MP_PROVIDER  = %s\n", ltc_mp.name);
303        printf("MP_DIGIT_BIT = %d\n", MP_DIGIT_BIT);
304        printf("sizeof(ltc_mp_digit) = %d\n", (int)sizeof(ltc_mp_digit));
305     } else {
306        printf("NO math provider selected, all tests requiring MPI will 'nop'\n");
307     }
308  #ifdef LTC_PTHREAD
309     tinfo = XCALLOC(sizeof(test_functions)/sizeof(test_functions[0]), sizeof(thread_info));
310     if (tinfo == NULL) {
311        printf("\n\nFAILURE: XCALLOC\n");
312        return EXIT_FAILURE;
313     }
314  #endif
315     fn_len = 0;
316     for (i = 0; i < sizeof(test_functions) / sizeof(test_functions[0]); ++i) {
317        size_t len = XSTRLEN(test_functions[i].name);
318        if (fn_len < len) fn_len = len;
319  #ifdef LTC_PTHREAD
320        if(test_functions[i].fn == prng_test) continue;
321        tinfo[i].t = &test_functions[i];
322        x = pthread_create(&tinfo[i].thread_id, NULL, run, &tinfo[i]);
323        if (x != 0)  {
324           printf("\n\nFAILURE: pthread_create\n");
325           return EXIT_FAILURE;
326        }
327  #endif
328     }
329     fn_len = fn_len + (4 - (fn_len % 4));
330     if (argc > 1) single_test = argv[1];
331     dur = epoch_usec();
332     for (i = 0; i < sizeof(test_functions)/sizeof(test_functions[0]); ++i) {
333        if (single_test && strstr(test_functions[i].name, single_test) == NULL) {
334          continue;
335        }
336        dots = fn_len - XSTRLEN(test_functions[i].name);
337        printf("\n%s", test_functions[i].name);
338        while(dots--) printf(".");
339        fflush(stdout);
340  #ifdef LTC_PTHREAD
341        if(test_functions[i].fn != prng_test) {
342           x = pthread_join(tinfo[i].thread_id, (void**)&res);
343           if (x != 0){
344              printf("\n\nFAILURE: pthread_join\n");
345              return EXIT_FAILURE;
346           }
347           x = res->err;
348           delta = res->delta;
349        }
350        else {
351           ts = epoch_usec();
352           x = test_functions[i].fn();
353           delta = (long)(epoch_usec() - ts);
354        }
355  #else
356        ts = epoch_usec();
357        x = test_functions[i].fn();
358        delta = (long)(epoch_usec() - ts);
359  #endif
360        real += delta;
361        if (x == CRYPT_OK) {
362           printf("passed %10.3fms", (double)(delta)/1000);
363           pass++;
364        }
365        else if (x == CRYPT_NOP) {
366           printf("nop");
367           nop++;
368        }
369        else {
370           printf("failed (%s) %10.3fms", error_to_string(x), (double)(delta)/1000);
371           fail++;
372        }
373     }
374     dur = epoch_usec() - dur;
375  #ifdef LTC_PTHREAD
376     XFREE(tinfo);
377  #endif
378     x = (fail > 0 || fail+pass+nop == 0) ? EXIT_FAILURE : EXIT_SUCCESS;
379     printf("\n\n%s: passed=%d failed=%d nop=%d duration=%.1fsec real=%.1fsec\n", x ? "FAILURE" : "SUCCESS", pass, fail, nop, (double)(dur)/(1000*1000), (double)(real)/(1000*1000));
380     return x;
381  }
</code></pre>
        </div>
        <div class="column">
            <h3>fftw3-MDEwOlJlcG9zaXRvcnk4ODQzMzg4-flat-buffered2.c</h3>
            <pre><code>1  #include "rdft/rdft.h"
2  #include "dft/dft.h"
3  typedef struct {
4       solver super;
5       size_t maxnbuf_ndx;
6  } S;
7  static const INT maxnbufs[] = { 8, 256 };
8  typedef struct {
9       plan_rdft2 super;
10       plan *cld, *cldcpy, *cldrest;
11       INT n, vl, nbuf, bufdist;
12       INT ivs_by_nbuf, ovs_by_nbuf;
13       INT ioffset, roffset;
14  } P;
15  static void apply_r2hc(const plan *ego_, R *r0, R *r1, R *cr, R *ci)
16  {
17       const P *ego = (const P *) ego_;
18       plan_rdft2 *cld = (plan_rdft2 *) ego->cld;
19       plan_dft *cldcpy = (plan_dft *) ego->cldcpy;
20       INT i, vl = ego->vl, nbuf = ego->nbuf;
21       INT ivs_by_nbuf = ego->ivs_by_nbuf, ovs_by_nbuf = ego->ovs_by_nbuf;
22       R *bufs = (R *)MALLOC(sizeof(R) * nbuf * ego->bufdist, BUFFERS);
23       R *bufr = bufs + ego->roffset;
24       R *bufi = bufs + ego->ioffset;
25       plan_rdft2 *cldrest;
26       for (i = nbuf; i <= vl; i += nbuf) {
27            cld->apply((plan *) cld, r0, r1, bufr, bufi);
28  	  r0 += ivs_by_nbuf; r1 += ivs_by_nbuf;
29            cldcpy->apply((plan *) cldcpy, bufr, bufi, cr, ci);
30  	  cr += ovs_by_nbuf; ci += ovs_by_nbuf;
31       }
32       X(ifree)(bufs);
33       cldrest = (plan_rdft2 *) ego->cldrest;
34       cldrest->apply((plan *) cldrest, r0, r1, cr, ci);
35  }
36  static void apply_hc2r(const plan *ego_, R *r0, R *r1, R *cr, R *ci)
37  {
38       const P *ego = (const P *) ego_;
39       plan_rdft2 *cld = (plan_rdft2 *) ego->cld;
40       plan_dft *cldcpy = (plan_dft *) ego->cldcpy;
41       INT i, vl = ego->vl, nbuf = ego->nbuf;
42       INT ivs_by_nbuf = ego->ivs_by_nbuf, ovs_by_nbuf = ego->ovs_by_nbuf;
43       R *bufs = (R *)MALLOC(sizeof(R) * nbuf * ego->bufdist, BUFFERS);
44       R *bufr = bufs + ego->roffset;
45       R *bufi = bufs + ego->ioffset;
46       plan_rdft2 *cldrest;
47       for (i = nbuf; i <= vl; i += nbuf) {
48            cldcpy->apply((plan *) cldcpy, cr, ci, bufr, bufi);
49  	  cr += ivs_by_nbuf; ci += ivs_by_nbuf;
50            cld->apply((plan *) cld, r0, r1, bufr, bufi);
51  	  r0 += ovs_by_nbuf; r1 += ovs_by_nbuf;
52       }
53       X(ifree)(bufs);
54       cldrest = (plan_rdft2 *) ego->cldrest;
55       cldrest->apply((plan *) cldrest, r0, r1, cr, ci);
56  }
57  static void awake(plan *ego_, enum wakefulness wakefulness)
58  {
59       P *ego = (P *) ego_;
60       X(plan_awake)(ego->cld, wakefulness);
61       X(plan_awake)(ego->cldcpy, wakefulness);
62       X(plan_awake)(ego->cldrest, wakefulness);
63  }
64  static void destroy(plan *ego_)
65  {
66       P *ego = (P *) ego_;
67       X(plan_destroy_internal)(ego->cldrest);
68       X(plan_destroy_internal)(ego->cldcpy);
69       X(plan_destroy_internal)(ego->cld);
70  }
71  static void print(const plan *ego_, printer *p)
72  {
73       const P *ego = (const P *) ego_;
74       p->print(p, "(rdft2-buffered-%D%v/%D-%D%(%p%)%(%p%)%(%p%))",
75                ego->n, ego->nbuf,
76                ego->vl, ego->bufdist % ego->n,
77                ego->cld, ego->cldcpy, ego->cldrest);
78  }
79  static int applicable0(const S *ego, const problem *p_, const planner *plnr)
80  {
81       const problem_rdft2 *p = (const problem_rdft2 *) p_;
82       iodim *d = p->sz->dims;
83       if (1
84  	 && p->vecsz->rnk <= 1
85  	 && p->sz->rnk == 1
86  	 && (d[0].n % 2) == 0
87  	 && (p->kind == R2HC || p->kind == HC2R)
88  	  ) {
89  	  INT vl, ivs, ovs;
90  	  X(tensor_tornk1)(p->vecsz, &vl, &ivs, &ovs);
91  	  if (X(toobig)(d[0].n) && CONSERVE_MEMORYP(plnr))
92  	       return 0;
93  	  if (X(nbuf_redundant)(d[0].n, vl,
94  				ego->maxnbuf_ndx,
95  				maxnbufs, NELEM(maxnbufs)))
96  	       return 0;
97  	  if (p->r0 != p->cr) {
98  	       if (p->kind == HC2R) {
99  		    return (NO_DESTROY_INPUTP(plnr));
100  	       } else {
101  		    return (d[0].os > 2);
102  	       }
103  	  }
104  	  if (X(rdft2_inplace_strides(p, RNK_MINFTY)))
105  	       return 1;
106  	  if (&bsol;* fits into buffer: */
107  	       ((p->vecsz->rnk == 0)
108  		||
109  		(X(nbuf)(d[0].n, p->vecsz->dims[0].n,
110  			 maxnbufs[ego->maxnbuf_ndx])
111  		 == p->vecsz->dims[0].n)))
112  	       return 1;
113       }
114       return 0;
115  }
116  static int applicable(const S *ego, const problem *p_, const planner *plnr)
117  {
118       const problem_rdft2 *p;
119       if (NO_BUFFERINGP(plnr)) return 0;
120       if (!applicable0(ego, p_, plnr)) return 0;
121       p = (const problem_rdft2 *) p_;
122       if (p->kind == HC2R) {
123  	  if (NO_UGLYP(plnr)) {
124  	       if (p->r0 == p->cr && X(toobig)(p->sz->dims[0].n)) 
125  		    return 0;
126  	  }
127       } else {
128  	  if (NO_UGLYP(plnr)) {
129  	       if (p->r0 != p->cr || X(toobig)(p->sz->dims[0].n))
130  		    return 0;
131  	  }
132       }
133       return 1;
134  }
135  static plan *mkplan(const solver *ego_, const problem *p_, planner *plnr)
136  {
137       P *pln;
138       const S *ego = (const S *)ego_;
139       plan *cld = (plan *) 0;
140       plan *cldcpy = (plan *) 0;
141       plan *cldrest = (plan *) 0;
142       const problem_rdft2 *p = (const problem_rdft2 *) p_;
143       R *bufs = (R *) 0;
144       INT nbuf = 0, bufdist, n, vl;
145       INT ivs, ovs, ioffset, roffset, id, od;
146       static const plan_adt padt = {
147  	  X(rdft2_solve), awake, print, destroy
148       };
149       if (!applicable(ego, p_, plnr))
150            goto nada;
151       n = X(tensor_sz)(p->sz);
152       X(tensor_tornk1)(p->vecsz, &vl, &ivs, &ovs);
153       nbuf = X(nbuf)(n, vl, maxnbufs[ego->maxnbuf_ndx]);
154       bufdist = X(bufdist)(n + 2, vl); &bsol;* complex-side rdft2 stores N+2
155  					 real numbers */
156       A(nbuf > 0);
157       roffset = (p->cr - p->ci > 0) ? (INT)1 : (INT)0;
158       ioffset = 1 - roffset;
159       bufs = (R *) MALLOC(sizeof(R) * nbuf * bufdist, BUFFERS);
160       id = ivs * (nbuf * (vl / nbuf));
161       od = ovs * (nbuf * (vl / nbuf));
162       if (p->kind == R2HC) {
163  	  cld = X(mkplan_f_d)(
164  	       plnr, 
165  	       X(mkproblem_rdft2_d)(
166  		    X(mktensor_1d)(n, p->sz->dims[0].is, 2),
167  		    X(mktensor_1d)(nbuf, ivs, bufdist),
168  		    TAINT(p->r0, ivs * nbuf), TAINT(p->r1, ivs * nbuf),
169  		    bufs + roffset, bufs + ioffset, p->kind),
170  	       0, 0, (p->r0 == p->cr) ? NO_DESTROY_INPUT : 0);
171  	  if (!cld) goto nada;
172  	  cldcpy = X(mkplan_d)(
173  	       plnr, 
174  	       X(mkproblem_dft_d)(
175  		    X(mktensor_0d)(),
176  		    X(mktensor_2d)(nbuf, bufdist, ovs,
177  				   n/2+1, 2, p->sz->dims[0].os),
178  		    bufs + roffset, bufs + ioffset,
179  		    TAINT(p->cr, ovs * nbuf), TAINT(p->ci, ovs * nbuf) ));
180  	  if (!cldcpy) goto nada;
181  	  X(ifree)(bufs); bufs = 0;
<span onclick='openModal()' class='match'>182  	  cldrest = X(mkplan_d)(plnr, 
183  				X(mkproblem_rdft2_d)(
184  				     X(tensor_copy)(p->sz),
185  				     X(mktensor_1d)(vl % nbuf, ivs, ovs),
</span>186  				     p->r0 + id, p->r1 + id, 
187  				     p->cr + od, p->ci + od,
188  				     p->kind));
189  	  if (!cldrest) goto nada;
190  	  pln = MKPLAN_RDFT2(P, &padt, apply_r2hc);
191       } else {
192  	  cld = X(mkplan_f_d)(
193  	       plnr, 
194  	       X(mkproblem_rdft2_d)(
195  		    X(mktensor_1d)(n, 2, p->sz->dims[0].os),
196  		    X(mktensor_1d)(nbuf, bufdist, ovs),
197  		    TAINT(p->r0, ovs * nbuf), TAINT(p->r1, ovs * nbuf),
198  		    bufs + roffset, bufs + ioffset, p->kind),
199  	       0, 0, NO_DESTROY_INPUT);
200  	  if (!cld) goto nada;
201  	  cldcpy = X(mkplan_d)(
202  	       plnr, 
203  	       X(mkproblem_dft_d)(
204  		    X(mktensor_0d)(),
205  		    X(mktensor_2d)(nbuf, ivs, bufdist,
206  				   n/2+1, p->sz->dims[0].is, 2),
207  		    TAINT(p->cr, ivs * nbuf), TAINT(p->ci, ivs * nbuf), 
208  		    bufs + roffset, bufs + ioffset));
209  	  if (!cldcpy) goto nada;
210  	  X(ifree)(bufs); bufs = 0;
211  	  cldrest = X(mkplan_d)(plnr, 
212  				X(mkproblem_rdft2_d)(
213  				     X(tensor_copy)(p->sz),
214  				     X(mktensor_1d)(vl % nbuf, ivs, ovs),
215  				     p->r0 + od, p->r1 + od, 
216  				     p->cr + id, p->ci + id,
217  				     p->kind));
218  	  if (!cldrest) goto nada;
219  	  pln = MKPLAN_RDFT2(P, &padt, apply_hc2r);
220       }
221       pln->cld = cld;
222       pln->cldcpy = cldcpy;
223       pln->cldrest = cldrest;
224       pln->n = n;
225       pln->vl = vl;
226       pln->ivs_by_nbuf = ivs * nbuf;
227       pln->ovs_by_nbuf = ovs * nbuf;
228       pln->roffset = roffset;
229       pln->ioffset = ioffset;
230       pln->nbuf = nbuf;
231       pln->bufdist = bufdist;
232       {
233  	  opcnt t;
234  	  X(ops_add)(&cld->ops, &cldcpy->ops, &t);
235  	  X(ops_madd)(vl / nbuf, &t, &cldrest->ops, &pln->super.super.ops);
236       }
237       return &(pln->super.super);
238   nada:
239       X(ifree0)(bufs);
240       X(plan_destroy_internal)(cldrest);
241       X(plan_destroy_internal)(cldcpy);
242       X(plan_destroy_internal)(cld);
243       return (plan *) 0;
244  }
245  static solver *mksolver(size_t maxnbuf_ndx)
246  {
247       static const solver_adt sadt = { PROBLEM_RDFT2, mkplan, 0 };
248       S *slv = MKSOLVER(S, &sadt);
249       slv->maxnbuf_ndx = maxnbuf_ndx;
250       return &(slv->super);
251  }
252  void X(rdft2_buffered_register)(planner *p)
253  {
254       size_t i;
255       for (i = 0; i < NELEM(maxnbufs); ++i)
256  	  REGISTER_SOLVER(p, mksolver(i));
257  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from libtomcrypt-MDEwOlJlcG9zaXRvcnk3NzcwMTE=-flat-test.c</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from fftw3-MDEwOlJlcG9zaXRvcnk4ODQzMzg4-flat-buffered2.c</div>
                </div>
                <div class="column column_space"><pre><code>139    unregister_cipher(&kseed_desc);
140  #endif
141  #ifdef LTC_KASUMI
142    unregister_cipher(&kasumi_desc);
143  #endif
144  #ifdef LTC_MULTI2
145    unregister_cipher(&multi2_desc);
146  #endif
147  #ifdef LTC_CAMELLIA
148    unregister_cipher(&camellia_desc);
149  #endif
150  #ifdef LTC_IDEA
151    unregister_cipher(&idea_desc);
152  #endif
153  #ifdef LTC_SERPENT
154    unregister_cipher(&serpent_desc);
155  #endif
156  #ifdef LTC_TIGER
157    unregister_hash(&tiger_desc);
158  #endif
159  #ifdef LTC_MD2
160    unregister_hash(&md2_desc);
</pre></code></div>
                <div class="column column_space"><pre><code>182  	  cldrest = X(mkplan_d)(plnr, 
183  				X(mkproblem_rdft2_d)(
184  				     X(tensor_copy)(p->sz),
185  				     X(mktensor_1d)(vl % nbuf, ivs, ovs),
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    