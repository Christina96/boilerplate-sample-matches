
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 2.6490066225165565%, Tokens: 8, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>libtomcrypt-MDEwOlJlcG9zaXRvcnk3NzcwMTE=-flat-ltc_ecc_points.c</h3>
            <pre><code>1  #include "tomcrypt_private.h"
2  #ifdef LTC_MECC
3  ecc_point *ltc_ecc_new_point(void)
4  {
5     ecc_point *p;
6     p = XCALLOC(1, sizeof(*p));
7     if (p == NULL) {
8        return NULL;
9     }
10     if (mp_init_multi(&p->x, &p->y, &p->z, LTC_NULL) != CRYPT_OK) {
11        XFREE(p);
12        return NULL;
13     }
14     return p;
15  }
16  void ltc_ecc_del_point(ecc_point *p)
17  {
18     if (p != NULL) {
19        mp_clear_multi(p->x, p->y, p->z, LTC_NULL); &bsol;* note: p->z may be NULL but that's ok with this function anyways */
20        XFREE(p);
<span onclick='openModal()' class='match'>21     }
22  }
23  int ltc_ecc_set_point_xyz(ltc_mp_digit x, ltc_mp_digit y, ltc_mp_digit z, ecc_point *p)
24  {
25     int err;
</span>26     if ((err = ltc_mp.set_int(p->x, x)) != CRYPT_OK) return err;
27     if ((err = ltc_mp.set_int(p->y, y)) != CRYPT_OK) return err;
28     if ((err = ltc_mp.set_int(p->z, z)) != CRYPT_OK) return err;
29     return CRYPT_OK;
30  }
31  int ltc_ecc_copy_point(const ecc_point *src, ecc_point *dst)
32  {
33     int err;
34     if ((err = ltc_mp.copy(src->x, dst->x)) != CRYPT_OK) return err;
35     if ((err = ltc_mp.copy(src->y, dst->y)) != CRYPT_OK) return err;
36     if ((err = ltc_mp.copy(src->z, dst->z)) != CRYPT_OK) return err;
37     return CRYPT_OK;
38  }
39  #endif
</code></pre>
        </div>
        <div class="column">
            <h3>xmrig-MDEwOlJlcG9zaXRvcnk4ODMyNzQwNg==-flat-sph_luffa.c</h3>
            <pre><code>1  #include <stddef.h>
2  #include <string.h>
3  #include <limits.h>
4  #include "sph_luffa.h"
5  #ifdef __cplusplus
6  extern "C"{
7  #endif
8  #if SPH_64_TRUE && !defined SPH_LUFFA_PARALLEL
9  #define SPH_LUFFA_PARALLEL   1
10  #endif
11  #ifdef _MSC_VER
12  #pragma warning (disable: 4146)
13  #endif
14  static const sph_u32 V_INIT[5][8] = {
15  	{
16  		SPH_C32(0x6d251e69), SPH_C32(0x44b051e0),
17  		SPH_C32(0x4eaa6fb4), SPH_C32(0xdbf78465),
18  		SPH_C32(0x6e292011), SPH_C32(0x90152df4),
19  		SPH_C32(0xee058139), SPH_C32(0xdef610bb)
20  	}, {
21  		SPH_C32(0xc3b44b95), SPH_C32(0xd9d2f256),
22  		SPH_C32(0x70eee9a0), SPH_C32(0xde099fa3),
23  		SPH_C32(0x5d9b0557), SPH_C32(0x8fc944b3),
24  		SPH_C32(0xcf1ccf0e), SPH_C32(0x746cd581)
25  	}, {
26  		SPH_C32(0xf7efc89d), SPH_C32(0x5dba5781),
27  		SPH_C32(0x04016ce5), SPH_C32(0xad659c05),
28  		SPH_C32(0x0306194f), SPH_C32(0x666d1836),
29  		SPH_C32(0x24aa230a), SPH_C32(0x8b264ae7)
30  	}, {
31  		SPH_C32(0x858075d5), SPH_C32(0x36d79cce),
32  		SPH_C32(0xe571f7d7), SPH_C32(0x204b1f67),
33  		SPH_C32(0x35870c6a), SPH_C32(0x57e9e923),
34  		SPH_C32(0x14bcb808), SPH_C32(0x7cde72ce)
35  	}, {
36  		SPH_C32(0x6c68e9be), SPH_C32(0x5ec41e22),
37  		SPH_C32(0xc825b7c7), SPH_C32(0xaffb4363),
38  		SPH_C32(0xf5df3999), SPH_C32(0x0fc688f1),
39  		SPH_C32(0xb07224cc), SPH_C32(0x03e86cea)
40  	}
41  };
42  static const sph_u32 RC00[8] = {
43  	SPH_C32(0x303994a6), SPH_C32(0xc0e65299),
44  	SPH_C32(0x6cc33a12), SPH_C32(0xdc56983e),
45  	SPH_C32(0x1e00108f), SPH_C32(0x7800423d),
46  	SPH_C32(0x8f5b7882), SPH_C32(0x96e1db12)
47  };
48  static const sph_u32 RC04[8] = {
49  	SPH_C32(0xe0337818), SPH_C32(0x441ba90d),
50  	SPH_C32(0x7f34d442), SPH_C32(0x9389217f),
51  	SPH_C32(0xe5a8bce6), SPH_C32(0x5274baf4),
52  	SPH_C32(0x26889ba7), SPH_C32(0x9a226e9d)
53  };
54  static const sph_u32 RC10[8] = {
55  	SPH_C32(0xb6de10ed), SPH_C32(0x70f47aae),
56  	SPH_C32(0x0707a3d4), SPH_C32(0x1c1e8f51),
57  	SPH_C32(0x707a3d45), SPH_C32(0xaeb28562),
58  	SPH_C32(0xbaca1589), SPH_C32(0x40a46f3e)
59  };
60  static const sph_u32 RC14[8] = {
61  	SPH_C32(0x01685f3d), SPH_C32(0x05a17cf4),
62  	SPH_C32(0xbd09caca), SPH_C32(0xf4272b28),
63  	SPH_C32(0x144ae5cc), SPH_C32(0xfaa7ae2b),
64  	SPH_C32(0x2e48f1c1), SPH_C32(0xb923c704)
65  };
66  #if SPH_LUFFA_PARALLEL
67  static const sph_u64 RCW010[8] = {
68  	SPH_C64(0xb6de10ed303994a6), SPH_C64(0x70f47aaec0e65299),
69  	SPH_C64(0x0707a3d46cc33a12), SPH_C64(0x1c1e8f51dc56983e),
70  	SPH_C64(0x707a3d451e00108f), SPH_C64(0xaeb285627800423d),
71  	SPH_C64(0xbaca15898f5b7882), SPH_C64(0x40a46f3e96e1db12)
72  };
73  static const sph_u64 RCW014[8] = {
74  	SPH_C64(0x01685f3de0337818), SPH_C64(0x05a17cf4441ba90d),
75  	SPH_C64(0xbd09caca7f34d442), SPH_C64(0xf4272b289389217f),
76  	SPH_C64(0x144ae5cce5a8bce6), SPH_C64(0xfaa7ae2b5274baf4),
77  	SPH_C64(0x2e48f1c126889ba7), SPH_C64(0xb923c7049a226e9d)
78  };
79  #endif
80  static const sph_u32 RC20[8] = {
81  	SPH_C32(0xfc20d9d2), SPH_C32(0x34552e25),
82  	SPH_C32(0x7ad8818f), SPH_C32(0x8438764a),
83  	SPH_C32(0xbb6de032), SPH_C32(0xedb780c8),
84  	SPH_C32(0xd9847356), SPH_C32(0xa2c78434)
85  };
86  static const sph_u32 RC24[8] = {
87  	SPH_C32(0xe25e72c1), SPH_C32(0xe623bb72),
88  	SPH_C32(0x5c58a4a4), SPH_C32(0x1e38e2e7),
89  	SPH_C32(0x78e38b9d), SPH_C32(0x27586719),
90  	SPH_C32(0x36eda57f), SPH_C32(0x703aace7)
91  };
92  static const sph_u32 RC30[8] = {
93  	SPH_C32(0xb213afa5), SPH_C32(0xc84ebe95),
94  	SPH_C32(0x4e608a22), SPH_C32(0x56d858fe),
95  	SPH_C32(0x343b138f), SPH_C32(0xd0ec4e3d),
96  	SPH_C32(0x2ceb4882), SPH_C32(0xb3ad2208)
97  };
98  static const sph_u32 RC34[8] = {
99  	SPH_C32(0xe028c9bf), SPH_C32(0x44756f91),
100  	SPH_C32(0x7e8fce32), SPH_C32(0x956548be),
101  	SPH_C32(0xfe191be2), SPH_C32(0x3cb226e5),
102  	SPH_C32(0x5944a28e), SPH_C32(0xa1c4c355)
103  };
104  #if SPH_LUFFA_PARALLEL
105  static const sph_u64 RCW230[8] = {
106  	SPH_C64(0xb213afa5fc20d9d2), SPH_C64(0xc84ebe9534552e25),
107  	SPH_C64(0x4e608a227ad8818f), SPH_C64(0x56d858fe8438764a),
108  	SPH_C64(0x343b138fbb6de032), SPH_C64(0xd0ec4e3dedb780c8),
109  	SPH_C64(0x2ceb4882d9847356), SPH_C64(0xb3ad2208a2c78434)
110  };
111  static const sph_u64 RCW234[8] = {
112  	SPH_C64(0xe028c9bfe25e72c1), SPH_C64(0x44756f91e623bb72),
113  	SPH_C64(0x7e8fce325c58a4a4), SPH_C64(0x956548be1e38e2e7),
114  	SPH_C64(0xfe191be278e38b9d), SPH_C64(0x3cb226e527586719),
115  	SPH_C64(0x5944a28e36eda57f), SPH_C64(0xa1c4c355703aace7)
116  };
117  #endif
118  static const sph_u32 RC40[8] = {
119  	SPH_C32(0xf0d2e9e3), SPH_C32(0xac11d7fa),
120  	SPH_C32(0x1bcb66f2), SPH_C32(0x6f2d9bc9),
121  	SPH_C32(0x78602649), SPH_C32(0x8edae952),
122  	SPH_C32(0x3b6ba548), SPH_C32(0xedae9520)
123  };
124  static const sph_u32 RC44[8] = {
125  	SPH_C32(0x5090d577), SPH_C32(0x2d1925ab),
126  	SPH_C32(0xb46496ac), SPH_C32(0xd1925ab0),
127  	SPH_C32(0x29131ab6), SPH_C32(0x0fc053c3),
128  	SPH_C32(0x3f014f0c), SPH_C32(0xfc053c31)
129  };
130  #define DECL_TMP8(w) \
131  	sph_u32 w ## 0, w ## 1, w ## 2, w ## 3, w ## 4, w ## 5, w ## 6, w ## 7;
132  #define M2(d, s)   do { \
133  		sph_u32 tmp = s ## 7; \
134  		d ## 7 = s ## 6; \
135  		d ## 6 = s ## 5; \
136  		d ## 5 = s ## 4; \
137  		d ## 4 = s ## 3 ^ tmp; \
138  		d ## 3 = s ## 2 ^ tmp; \
139  		d ## 2 = s ## 1; \
140  		d ## 1 = s ## 0 ^ tmp; \
141  		d ## 0 = tmp; \
142  	} while (0)
143  #define XOR(d, s1, s2)   do { \
144  		d ## 0 = s1 ## 0 ^ s2 ## 0; \
145  		d ## 1 = s1 ## 1 ^ s2 ## 1; \
146  		d ## 2 = s1 ## 2 ^ s2 ## 2; \
147  		d ## 3 = s1 ## 3 ^ s2 ## 3; \
148  		d ## 4 = s1 ## 4 ^ s2 ## 4; \
149  		d ## 5 = s1 ## 5 ^ s2 ## 5; \
150  		d ## 6 = s1 ## 6 ^ s2 ## 6; \
151  		d ## 7 = s1 ## 7 ^ s2 ## 7; \
152  	} while (0)
153  #if SPH_LUFFA_PARALLEL
154  #define SUB_CRUMB_GEN(a0, a1, a2, a3, width)   do { \
155  		sph_u ## width tmp; \
156  		tmp = (a0); \
157  		(a0) |= (a1); \
158  		(a2) ^= (a3); \
159  		(a1) = SPH_T ## width(~(a1)); \
160  		(a0) ^= (a3); \
161  		(a3) &= tmp; \
162  		(a1) ^= (a3); \
163  		(a3) ^= (a2); \
164  		(a2) &= (a0); \
165  		(a0) = SPH_T ## width(~(a0)); \
166  		(a2) ^= (a1); \
167  		(a1) |= (a3); \
168  		tmp ^= (a1); \
169  		(a3) ^= (a2); \
170  		(a2) &= (a1); \
171  		(a1) ^= (a0); \
172  		(a0) = tmp; \
173  	} while (0)
174  #define SUB_CRUMB(a0, a1, a2, a3)    SUB_CRUMB_GEN(a0, a1, a2, a3, 32)
175  #define SUB_CRUMBW(a0, a1, a2, a3)   SUB_CRUMB_GEN(a0, a1, a2, a3, 64)
176  #if 0
177  #define ROL32W(x, n)   SPH_T64( \
178                         (((x) << (n)) \
179                         & ~((SPH_C64(0xFFFFFFFF) >> (32 - (n))) << 32)) \
180                         | (((x) >> (32 - (n))) \
181                         & ~((SPH_C64(0xFFFFFFFF) >> (n)) << (n))))
182  #define MIX_WORDW(u, v)   do { \
183  		(v) ^= (u); \
184  		(u) = ROL32W((u), 2) ^ (v); \
185  		(v) = ROL32W((v), 14) ^ (u); \
186  		(u) = ROL32W((u), 10) ^ (v); \
187  		(v) = ROL32W((v), 1); \
188  	} while (0)
189  #endif
190  #define MIX_WORDW(u, v)   do { \
191  		sph_u32 ul, uh, vl, vh; \
192  		(v) ^= (u); \
193  		ul = SPH_T32((sph_u32)(u)); \
194  		uh = SPH_T32((sph_u32)((u) >> 32)); \
195  		vl = SPH_T32((sph_u32)(v)); \
196  		vh = SPH_T32((sph_u32)((v) >> 32)); \
197  		ul = SPH_ROTL32(ul, 2) ^ vl; \
198  		vl = SPH_ROTL32(vl, 14) ^ ul; \
199  		ul = SPH_ROTL32(ul, 10) ^ vl; \
200  		vl = SPH_ROTL32(vl, 1); \
201  		uh = SPH_ROTL32(uh, 2) ^ vh; \
202  		vh = SPH_ROTL32(vh, 14) ^ uh; \
203  		uh = SPH_ROTL32(uh, 10) ^ vh; \
204  		vh = SPH_ROTL32(vh, 1); \
205  		(u) = (sph_u64)ul | ((sph_u64)uh << 32); \
206  		(v) = (sph_u64)vl | ((sph_u64)vh << 32); \
207  	} while (0)
208  #else
209  #define SUB_CRUMB(a0, a1, a2, a3)   do { \
210  		sph_u32 tmp; \
211  		tmp = (a0); \
212  		(a0) |= (a1); \
213  		(a2) ^= (a3); \
214  		(a1) = SPH_T32(~(a1)); \
215  		(a0) ^= (a3); \
216  		(a3) &= tmp; \
217  		(a1) ^= (a3); \
218  		(a3) ^= (a2); \
219  		(a2) &= (a0); \
220  		(a0) = SPH_T32(~(a0)); \
221  		(a2) ^= (a1); \
222  		(a1) |= (a3); \
223  		tmp ^= (a1); \
224  		(a3) ^= (a2); \
225  		(a2) &= (a1); \
226  		(a1) ^= (a0); \
227  		(a0) = tmp; \
228  	} while (0)
229  #endif
230  #define MIX_WORD(u, v)   do { \
231  		(v) ^= (u); \
232  		(u) = SPH_ROTL32((u), 2) ^ (v); \
233  		(v) = SPH_ROTL32((v), 14) ^ (u); \
234  		(u) = SPH_ROTL32((u), 10) ^ (v); \
235  		(v) = SPH_ROTL32((v), 1); \
236  	} while (0)
237  #define DECL_STATE3 \
238  	sph_u32 V00, V01, V02, V03, V04, V05, V06, V07; \
239  	sph_u32 V10, V11, V12, V13, V14, V15, V16, V17; \
240  	sph_u32 V20, V21, V22, V23, V24, V25, V26, V27;
241  #define READ_STATE3(state)   do { \
242  		V00 = (state)->V[0][0]; \
243  		V01 = (state)->V[0][1]; \
244  		V02 = (state)->V[0][2]; \
245  		V03 = (state)->V[0][3]; \
246  		V04 = (state)->V[0][4]; \
247  		V05 = (state)->V[0][5]; \
248  		V06 = (state)->V[0][6]; \
249  		V07 = (state)->V[0][7]; \
250  		V10 = (state)->V[1][0]; \
251  		V11 = (state)->V[1][1]; \
252  		V12 = (state)->V[1][2]; \
253  		V13 = (state)->V[1][3]; \
254  		V14 = (state)->V[1][4]; \
255  		V15 = (state)->V[1][5]; \
256  		V16 = (state)->V[1][6]; \
257  		V17 = (state)->V[1][7]; \
258  		V20 = (state)->V[2][0]; \
259  		V21 = (state)->V[2][1]; \
260  		V22 = (state)->V[2][2]; \
261  		V23 = (state)->V[2][3]; \
262  		V24 = (state)->V[2][4]; \
263  		V25 = (state)->V[2][5]; \
264  		V26 = (state)->V[2][6]; \
265  		V27 = (state)->V[2][7]; \
266  	} while (0)
267  #define WRITE_STATE3(state)   do { \
268  		(state)->V[0][0] = V00; \
269  		(state)->V[0][1] = V01; \
270  		(state)->V[0][2] = V02; \
271  		(state)->V[0][3] = V03; \
272  		(state)->V[0][4] = V04; \
273  		(state)->V[0][5] = V05; \
274  		(state)->V[0][6] = V06; \
275  		(state)->V[0][7] = V07; \
276  		(state)->V[1][0] = V10; \
277  		(state)->V[1][1] = V11; \
278  		(state)->V[1][2] = V12; \
279  		(state)->V[1][3] = V13; \
280  		(state)->V[1][4] = V14; \
281  		(state)->V[1][5] = V15; \
282  		(state)->V[1][6] = V16; \
283  		(state)->V[1][7] = V17; \
284  		(state)->V[2][0] = V20; \
285  		(state)->V[2][1] = V21; \
286  		(state)->V[2][2] = V22; \
287  		(state)->V[2][3] = V23; \
288  		(state)->V[2][4] = V24; \
289  		(state)->V[2][5] = V25; \
290  		(state)->V[2][6] = V26; \
291  		(state)->V[2][7] = V27; \
292  	} while (0)
293  #define MI3   do { \
294  		DECL_TMP8(M) \
295  		DECL_TMP8(a) \
296  		M0 = sph_dec32be_aligned(buf +  0); \
297  		M1 = sph_dec32be_aligned(buf +  4); \
298  		M2 = sph_dec32be_aligned(buf +  8); \
299  		M3 = sph_dec32be_aligned(buf + 12); \
300  		M4 = sph_dec32be_aligned(buf + 16); \
301  		M5 = sph_dec32be_aligned(buf + 20); \
302  		M6 = sph_dec32be_aligned(buf + 24); \
303  		M7 = sph_dec32be_aligned(buf + 28); \
304  		XOR(a, V0, V1); \
305  		XOR(a, a, V2); \
306  		M2(a, a); \
307  		XOR(V0, a, V0); \
308  		XOR(V0, M, V0); \
309  		M2(M, M); \
310  		XOR(V1, a, V1); \
311  		XOR(V1, M, V1); \
312  		M2(M, M); \
313  		XOR(V2, a, V2); \
314  		XOR(V2, M, V2); \
315  	} while (0)
316  #define TWEAK3   do { \
317  		V14 = SPH_ROTL32(V14, 1); \
318  		V15 = SPH_ROTL32(V15, 1); \
319  		V16 = SPH_ROTL32(V16, 1); \
320  		V17 = SPH_ROTL32(V17, 1); \
321  		V24 = SPH_ROTL32(V24, 2); \
322  		V25 = SPH_ROTL32(V25, 2); \
323  		V26 = SPH_ROTL32(V26, 2); \
324  		V27 = SPH_ROTL32(V27, 2); \
325  	} while (0)
326  #if SPH_LUFFA_PARALLEL
327  #define P3   do { \
328  		int r; \
329  		sph_u64 W0, W1, W2, W3, W4, W5, W6, W7; \
330  		TWEAK3; \
331  		W0 = (sph_u64)V00 | ((sph_u64)V10 << 32); \
332  		W1 = (sph_u64)V01 | ((sph_u64)V11 << 32); \
333  		W2 = (sph_u64)V02 | ((sph_u64)V12 << 32); \
334  		W3 = (sph_u64)V03 | ((sph_u64)V13 << 32); \
335  		W4 = (sph_u64)V04 | ((sph_u64)V14 << 32); \
336  		W5 = (sph_u64)V05 | ((sph_u64)V15 << 32); \
337  		W6 = (sph_u64)V06 | ((sph_u64)V16 << 32); \
338  		W7 = (sph_u64)V07 | ((sph_u64)V17 << 32); \
339  		for (r = 0; r < 8; r ++) { \
340  			SUB_CRUMBW(W0, W1, W2, W3); \
341  			SUB_CRUMBW(W5, W6, W7, W4); \
342  			MIX_WORDW(W0, W4); \
343  			MIX_WORDW(W1, W5); \
344  			MIX_WORDW(W2, W6); \
345  			MIX_WORDW(W3, W7); \
346  			W0 ^= RCW010[r]; \
347  			W4 ^= RCW014[r]; \
348  		} \
349  		V00 = SPH_T32((sph_u32)W0); \
350  		V10 = SPH_T32((sph_u32)(W0 >> 32)); \
351  		V01 = SPH_T32((sph_u32)W1); \
352  		V11 = SPH_T32((sph_u32)(W1 >> 32)); \
353  		V02 = SPH_T32((sph_u32)W2); \
354  		V12 = SPH_T32((sph_u32)(W2 >> 32)); \
355  		V03 = SPH_T32((sph_u32)W3); \
356  		V13 = SPH_T32((sph_u32)(W3 >> 32)); \
357  		V04 = SPH_T32((sph_u32)W4); \
358  		V14 = SPH_T32((sph_u32)(W4 >> 32)); \
359  		V05 = SPH_T32((sph_u32)W5); \
360  		V15 = SPH_T32((sph_u32)(W5 >> 32)); \
361  		V06 = SPH_T32((sph_u32)W6); \
362  		V16 = SPH_T32((sph_u32)(W6 >> 32)); \
363  		V07 = SPH_T32((sph_u32)W7); \
364  		V17 = SPH_T32((sph_u32)(W7 >> 32)); \
365  		for (r = 0; r < 8; r ++) { \
366  			SUB_CRUMB(V20, V21, V22, V23); \
367  			SUB_CRUMB(V25, V26, V27, V24); \
368  			MIX_WORD(V20, V24); \
369  			MIX_WORD(V21, V25); \
370  			MIX_WORD(V22, V26); \
371  			MIX_WORD(V23, V27); \
372  			V20 ^= RC20[r]; \
373  			V24 ^= RC24[r]; \
374  		} \
375  	} while (0)
376  #else
377  #define P3   do { \
378  		int r; \
379  		TWEAK3; \
380  		for (r = 0; r < 8; r ++) { \
381  			SUB_CRUMB(V00, V01, V02, V03); \
382  			SUB_CRUMB(V05, V06, V07, V04); \
383  			MIX_WORD(V00, V04); \
384  			MIX_WORD(V01, V05); \
385  			MIX_WORD(V02, V06); \
386  			MIX_WORD(V03, V07); \
387  			V00 ^= RC00[r]; \
388  			V04 ^= RC04[r]; \
389  		} \
390  		for (r = 0; r < 8; r ++) { \
391  			SUB_CRUMB(V10, V11, V12, V13); \
392  			SUB_CRUMB(V15, V16, V17, V14); \
393  			MIX_WORD(V10, V14); \
394  			MIX_WORD(V11, V15); \
395  			MIX_WORD(V12, V16); \
396  			MIX_WORD(V13, V17); \
397  			V10 ^= RC10[r]; \
398  			V14 ^= RC14[r]; \
399  		} \
400  		for (r = 0; r < 8; r ++) { \
401  			SUB_CRUMB(V20, V21, V22, V23); \
402  			SUB_CRUMB(V25, V26, V27, V24); \
403  			MIX_WORD(V20, V24); \
404  			MIX_WORD(V21, V25); \
405  			MIX_WORD(V22, V26); \
406  			MIX_WORD(V23, V27); \
407  			V20 ^= RC20[r]; \
408  			V24 ^= RC24[r]; \
409  		} \
410  	} while (0)
411  #endif
412  #define DECL_STATE4 \
413  	sph_u32 V00, V01, V02, V03, V04, V05, V06, V07; \
414  	sph_u32 V10, V11, V12, V13, V14, V15, V16, V17; \
415  	sph_u32 V20, V21, V22, V23, V24, V25, V26, V27; \
416  	sph_u32 V30, V31, V32, V33, V34, V35, V36, V37;
417  #define READ_STATE4(state)   do { \
418  		V00 = (state)->V[0][0]; \
419  		V01 = (state)->V[0][1]; \
420  		V02 = (state)->V[0][2]; \
421  		V03 = (state)->V[0][3]; \
422  		V04 = (state)->V[0][4]; \
423  		V05 = (state)->V[0][5]; \
424  		V06 = (state)->V[0][6]; \
425  		V07 = (state)->V[0][7]; \
426  		V10 = (state)->V[1][0]; \
427  		V11 = (state)->V[1][1]; \
428  		V12 = (state)->V[1][2]; \
429  		V13 = (state)->V[1][3]; \
430  		V14 = (state)->V[1][4]; \
431  		V15 = (state)->V[1][5]; \
432  		V16 = (state)->V[1][6]; \
433  		V17 = (state)->V[1][7]; \
434  		V20 = (state)->V[2][0]; \
435  		V21 = (state)->V[2][1]; \
436  		V22 = (state)->V[2][2]; \
437  		V23 = (state)->V[2][3]; \
438  		V24 = (state)->V[2][4]; \
439  		V25 = (state)->V[2][5]; \
440  		V26 = (state)->V[2][6]; \
441  		V27 = (state)->V[2][7]; \
442  		V30 = (state)->V[3][0]; \
443  		V31 = (state)->V[3][1]; \
444  		V32 = (state)->V[3][2]; \
445  		V33 = (state)->V[3][3]; \
446  		V34 = (state)->V[3][4]; \
447  		V35 = (state)->V[3][5]; \
448  		V36 = (state)->V[3][6]; \
449  		V37 = (state)->V[3][7]; \
450  	} while (0)
451  #define WRITE_STATE4(state)   do { \
452  		(state)->V[0][0] = V00; \
453  		(state)->V[0][1] = V01; \
454  		(state)->V[0][2] = V02; \
455  		(state)->V[0][3] = V03; \
456  		(state)->V[0][4] = V04; \
457  		(state)->V[0][5] = V05; \
458  		(state)->V[0][6] = V06; \
459  		(state)->V[0][7] = V07; \
460  		(state)->V[1][0] = V10; \
461  		(state)->V[1][1] = V11; \
462  		(state)->V[1][2] = V12; \
463  		(state)->V[1][3] = V13; \
464  		(state)->V[1][4] = V14; \
465  		(state)->V[1][5] = V15; \
466  		(state)->V[1][6] = V16; \
467  		(state)->V[1][7] = V17; \
468  		(state)->V[2][0] = V20; \
469  		(state)->V[2][1] = V21; \
470  		(state)->V[2][2] = V22; \
471  		(state)->V[2][3] = V23; \
472  		(state)->V[2][4] = V24; \
473  		(state)->V[2][5] = V25; \
474  		(state)->V[2][6] = V26; \
475  		(state)->V[2][7] = V27; \
476  		(state)->V[3][0] = V30; \
477  		(state)->V[3][1] = V31; \
478  		(state)->V[3][2] = V32; \
479  		(state)->V[3][3] = V33; \
480  		(state)->V[3][4] = V34; \
481  		(state)->V[3][5] = V35; \
482  		(state)->V[3][6] = V36; \
483  		(state)->V[3][7] = V37; \
484  	} while (0)
485  #define MI4   do { \
486  		DECL_TMP8(M) \
487  		DECL_TMP8(a) \
488  		DECL_TMP8(b) \
489  		M0 = sph_dec32be_aligned(buf +  0); \
490  		M1 = sph_dec32be_aligned(buf +  4); \
491  		M2 = sph_dec32be_aligned(buf +  8); \
492  		M3 = sph_dec32be_aligned(buf + 12); \
493  		M4 = sph_dec32be_aligned(buf + 16); \
494  		M5 = sph_dec32be_aligned(buf + 20); \
495  		M6 = sph_dec32be_aligned(buf + 24); \
496  		M7 = sph_dec32be_aligned(buf + 28); \
497  		XOR(a, V0, V1); \
498  		XOR(b, V2, V3); \
499  		XOR(a, a, b); \
500  		M2(a, a); \
501  		XOR(V0, a, V0); \
502  		XOR(V1, a, V1); \
503  		XOR(V2, a, V2); \
504  		XOR(V3, a, V3); \
505  		M2(b, V0); \
506  		XOR(b, b, V3); \
507  		M2(V3, V3); \
508  		XOR(V3, V3, V2); \
509  		M2(V2, V2); \
510  		XOR(V2, V2, V1); \
511  		M2(V1, V1); \
512  		XOR(V1, V1, V0); \
513  		XOR(V0, b, M); \
514  		M2(M, M); \
515  		XOR(V1, V1, M); \
516  		M2(M, M); \
517  		XOR(V2, V2, M); \
518  		M2(M, M); \
519  		XOR(V3, V3, M); \
520  	} while (0)
521  #define TWEAK4   do { \
522  		V14 = SPH_ROTL32(V14, 1); \
523  		V15 = SPH_ROTL32(V15, 1); \
524  		V16 = SPH_ROTL32(V16, 1); \
525  		V17 = SPH_ROTL32(V17, 1); \
526  		V24 = SPH_ROTL32(V24, 2); \
527  		V25 = SPH_ROTL32(V25, 2); \
528  		V26 = SPH_ROTL32(V26, 2); \
529  		V27 = SPH_ROTL32(V27, 2); \
530  		V34 = SPH_ROTL32(V34, 3); \
531  		V35 = SPH_ROTL32(V35, 3); \
532  		V36 = SPH_ROTL32(V36, 3); \
533  		V37 = SPH_ROTL32(V37, 3); \
534  	} while (0)
535  #if SPH_LUFFA_PARALLEL
536  #define P4   do { \
537  		int r; \
538  		sph_u64 W0, W1, W2, W3, W4, W5, W6, W7; \
539  		TWEAK4; \
540  		W0 = (sph_u64)V00 | ((sph_u64)V10 << 32); \
541  		W1 = (sph_u64)V01 | ((sph_u64)V11 << 32); \
542  		W2 = (sph_u64)V02 | ((sph_u64)V12 << 32); \
543  		W3 = (sph_u64)V03 | ((sph_u64)V13 << 32); \
544  		W4 = (sph_u64)V04 | ((sph_u64)V14 << 32); \
545  		W5 = (sph_u64)V05 | ((sph_u64)V15 << 32); \
546  		W6 = (sph_u64)V06 | ((sph_u64)V16 << 32); \
547  		W7 = (sph_u64)V07 | ((sph_u64)V17 << 32); \
548  		for (r = 0; r < 8; r ++) { \
549  			SUB_CRUMBW(W0, W1, W2, W3); \
550  			SUB_CRUMBW(W5, W6, W7, W4); \
551  			MIX_WORDW(W0, W4); \
552  			MIX_WORDW(W1, W5); \
553  			MIX_WORDW(W2, W6); \
554  			MIX_WORDW(W3, W7); \
555  			W0 ^= RCW010[r]; \
556  			W4 ^= RCW014[r]; \
557  		} \
558  		V00 = SPH_T32((sph_u32)W0); \
559  		V10 = SPH_T32((sph_u32)(W0 >> 32)); \
560  		V01 = SPH_T32((sph_u32)W1); \
561  		V11 = SPH_T32((sph_u32)(W1 >> 32)); \
562  		V02 = SPH_T32((sph_u32)W2); \
563  		V12 = SPH_T32((sph_u32)(W2 >> 32)); \
564  		V03 = SPH_T32((sph_u32)W3); \
565  		V13 = SPH_T32((sph_u32)(W3 >> 32)); \
566  		V04 = SPH_T32((sph_u32)W4); \
567  		V14 = SPH_T32((sph_u32)(W4 >> 32)); \
568  		V05 = SPH_T32((sph_u32)W5); \
569  		V15 = SPH_T32((sph_u32)(W5 >> 32)); \
570  		V06 = SPH_T32((sph_u32)W6); \
571  		V16 = SPH_T32((sph_u32)(W6 >> 32)); \
572  		V07 = SPH_T32((sph_u32)W7); \
573  		V17 = SPH_T32((sph_u32)(W7 >> 32)); \
574  		W0 = (sph_u64)V20 | ((sph_u64)V30 << 32); \
575  		W1 = (sph_u64)V21 | ((sph_u64)V31 << 32); \
576  		W2 = (sph_u64)V22 | ((sph_u64)V32 << 32); \
577  		W3 = (sph_u64)V23 | ((sph_u64)V33 << 32); \
578  		W4 = (sph_u64)V24 | ((sph_u64)V34 << 32); \
579  		W5 = (sph_u64)V25 | ((sph_u64)V35 << 32); \
580  		W6 = (sph_u64)V26 | ((sph_u64)V36 << 32); \
581  		W7 = (sph_u64)V27 | ((sph_u64)V37 << 32); \
582  		for (r = 0; r < 8; r ++) { \
583  			SUB_CRUMBW(W0, W1, W2, W3); \
584  			SUB_CRUMBW(W5, W6, W7, W4); \
585  			MIX_WORDW(W0, W4); \
586  			MIX_WORDW(W1, W5); \
587  			MIX_WORDW(W2, W6); \
588  			MIX_WORDW(W3, W7); \
589  			W0 ^= RCW230[r]; \
590  			W4 ^= RCW234[r]; \
591  		} \
592  		V20 = SPH_T32((sph_u32)W0); \
593  		V30 = SPH_T32((sph_u32)(W0 >> 32)); \
594  		V21 = SPH_T32((sph_u32)W1); \
595  		V31 = SPH_T32((sph_u32)(W1 >> 32)); \
596  		V22 = SPH_T32((sph_u32)W2); \
597  		V32 = SPH_T32((sph_u32)(W2 >> 32)); \
598  		V23 = SPH_T32((sph_u32)W3); \
599  		V33 = SPH_T32((sph_u32)(W3 >> 32)); \
600  		V24 = SPH_T32((sph_u32)W4); \
601  		V34 = SPH_T32((sph_u32)(W4 >> 32)); \
602  		V25 = SPH_T32((sph_u32)W5); \
603  		V35 = SPH_T32((sph_u32)(W5 >> 32)); \
604  		V26 = SPH_T32((sph_u32)W6); \
605  		V36 = SPH_T32((sph_u32)(W6 >> 32)); \
606  		V27 = SPH_T32((sph_u32)W7); \
607  		V37 = SPH_T32((sph_u32)(W7 >> 32)); \
608  	} while (0)
609  #else
610  #define P4   do { \
611  		int r; \
612  		TWEAK4; \
613  		for (r = 0; r < 8; r ++) { \
614  			SUB_CRUMB(V00, V01, V02, V03); \
615  			SUB_CRUMB(V05, V06, V07, V04); \
616  			MIX_WORD(V00, V04); \
617  			MIX_WORD(V01, V05); \
618  			MIX_WORD(V02, V06); \
619  			MIX_WORD(V03, V07); \
620  			V00 ^= RC00[r]; \
621  			V04 ^= RC04[r]; \
622  		} \
623  		for (r = 0; r < 8; r ++) { \
624  			SUB_CRUMB(V10, V11, V12, V13); \
625  			SUB_CRUMB(V15, V16, V17, V14); \
626  			MIX_WORD(V10, V14); \
627  			MIX_WORD(V11, V15); \
628  			MIX_WORD(V12, V16); \
629  			MIX_WORD(V13, V17); \
630  			V10 ^= RC10[r]; \
631  			V14 ^= RC14[r]; \
632  		} \
633  		for (r = 0; r < 8; r ++) { \
634  			SUB_CRUMB(V20, V21, V22, V23); \
635  			SUB_CRUMB(V25, V26, V27, V24); \
636  			MIX_WORD(V20, V24); \
637  			MIX_WORD(V21, V25); \
638  			MIX_WORD(V22, V26); \
639  			MIX_WORD(V23, V27); \
640  			V20 ^= RC20[r]; \
641  			V24 ^= RC24[r]; \
642  		} \
643  		for (r = 0; r < 8; r ++) { \
644  			SUB_CRUMB(V30, V31, V32, V33); \
645  			SUB_CRUMB(V35, V36, V37, V34); \
646  			MIX_WORD(V30, V34); \
647  			MIX_WORD(V31, V35); \
648  			MIX_WORD(V32, V36); \
649  			MIX_WORD(V33, V37); \
650  			V30 ^= RC30[r]; \
651  			V34 ^= RC34[r]; \
652  		} \
653  	} while (0)
654  #endif
655  #define DECL_STATE5 \
656  	sph_u32 V00, V01, V02, V03, V04, V05, V06, V07; \
657  	sph_u32 V10, V11, V12, V13, V14, V15, V16, V17; \
658  	sph_u32 V20, V21, V22, V23, V24, V25, V26, V27; \
659  	sph_u32 V30, V31, V32, V33, V34, V35, V36, V37; \
660  	sph_u32 V40, V41, V42, V43, V44, V45, V46, V47;
661  #define READ_STATE5(state)   do { \
662  		V00 = (state)->V[0][0]; \
663  		V01 = (state)->V[0][1]; \
664  		V02 = (state)->V[0][2]; \
665  		V03 = (state)->V[0][3]; \
666  		V04 = (state)->V[0][4]; \
667  		V05 = (state)->V[0][5]; \
668  		V06 = (state)->V[0][6]; \
669  		V07 = (state)->V[0][7]; \
670  		V10 = (state)->V[1][0]; \
671  		V11 = (state)->V[1][1]; \
672  		V12 = (state)->V[1][2]; \
673  		V13 = (state)->V[1][3]; \
674  		V14 = (state)->V[1][4]; \
675  		V15 = (state)->V[1][5]; \
676  		V16 = (state)->V[1][6]; \
677  		V17 = (state)->V[1][7]; \
678  		V20 = (state)->V[2][0]; \
679  		V21 = (state)->V[2][1]; \
680  		V22 = (state)->V[2][2]; \
681  		V23 = (state)->V[2][3]; \
682  		V24 = (state)->V[2][4]; \
683  		V25 = (state)->V[2][5]; \
684  		V26 = (state)->V[2][6]; \
685  		V27 = (state)->V[2][7]; \
686  		V30 = (state)->V[3][0]; \
687  		V31 = (state)->V[3][1]; \
688  		V32 = (state)->V[3][2]; \
689  		V33 = (state)->V[3][3]; \
690  		V34 = (state)->V[3][4]; \
691  		V35 = (state)->V[3][5]; \
692  		V36 = (state)->V[3][6]; \
693  		V37 = (state)->V[3][7]; \
694  		V40 = (state)->V[4][0]; \
695  		V41 = (state)->V[4][1]; \
696  		V42 = (state)->V[4][2]; \
697  		V43 = (state)->V[4][3]; \
698  		V44 = (state)->V[4][4]; \
699  		V45 = (state)->V[4][5]; \
700  		V46 = (state)->V[4][6]; \
701  		V47 = (state)->V[4][7]; \
702  	} while (0)
703  #define WRITE_STATE5(state)   do { \
704  		(state)->V[0][0] = V00; \
705  		(state)->V[0][1] = V01; \
706  		(state)->V[0][2] = V02; \
707  		(state)->V[0][3] = V03; \
708  		(state)->V[0][4] = V04; \
709  		(state)->V[0][5] = V05; \
710  		(state)->V[0][6] = V06; \
711  		(state)->V[0][7] = V07; \
712  		(state)->V[1][0] = V10; \
713  		(state)->V[1][1] = V11; \
714  		(state)->V[1][2] = V12; \
715  		(state)->V[1][3] = V13; \
716  		(state)->V[1][4] = V14; \
717  		(state)->V[1][5] = V15; \
718  		(state)->V[1][6] = V16; \
719  		(state)->V[1][7] = V17; \
720  		(state)->V[2][0] = V20; \
721  		(state)->V[2][1] = V21; \
722  		(state)->V[2][2] = V22; \
723  		(state)->V[2][3] = V23; \
724  		(state)->V[2][4] = V24; \
725  		(state)->V[2][5] = V25; \
726  		(state)->V[2][6] = V26; \
727  		(state)->V[2][7] = V27; \
728  		(state)->V[3][0] = V30; \
729  		(state)->V[3][1] = V31; \
730  		(state)->V[3][2] = V32; \
731  		(state)->V[3][3] = V33; \
732  		(state)->V[3][4] = V34; \
733  		(state)->V[3][5] = V35; \
734  		(state)->V[3][6] = V36; \
735  		(state)->V[3][7] = V37; \
736  		(state)->V[4][0] = V40; \
737  		(state)->V[4][1] = V41; \
738  		(state)->V[4][2] = V42; \
739  		(state)->V[4][3] = V43; \
740  		(state)->V[4][4] = V44; \
741  		(state)->V[4][5] = V45; \
742  		(state)->V[4][6] = V46; \
743  		(state)->V[4][7] = V47; \
744  	} while (0)
745  #define MI5   do { \
746  		DECL_TMP8(M) \
747  		DECL_TMP8(a) \
748  		DECL_TMP8(b) \
749  		M0 = sph_dec32be_aligned(buf +  0); \
750  		M1 = sph_dec32be_aligned(buf +  4); \
751  		M2 = sph_dec32be_aligned(buf +  8); \
752  		M3 = sph_dec32be_aligned(buf + 12); \
753  		M4 = sph_dec32be_aligned(buf + 16); \
754  		M5 = sph_dec32be_aligned(buf + 20); \
755  		M6 = sph_dec32be_aligned(buf + 24); \
756  		M7 = sph_dec32be_aligned(buf + 28); \
757  		XOR(a, V0, V1); \
758  		XOR(b, V2, V3); \
759  		XOR(a, a, b); \
760  		XOR(a, a, V4); \
761  		M2(a, a); \
762  		XOR(V0, a, V0); \
763  		XOR(V1, a, V1); \
764  		XOR(V2, a, V2); \
765  		XOR(V3, a, V3); \
766  		XOR(V4, a, V4); \
767  		M2(b, V0); \
768  		XOR(b, b, V1); \
769  		M2(V1, V1); \
770  		XOR(V1, V1, V2); \
771  		M2(V2, V2); \
772  		XOR(V2, V2, V3); \
773  		M2(V3, V3); \
774  		XOR(V3, V3, V4); \
775  		M2(V4, V4); \
776  		XOR(V4, V4, V0); \
777  		M2(V0, b); \
778  		XOR(V0, V0, V4); \
779  		M2(V4, V4); \
780  		XOR(V4, V4, V3); \
781  		M2(V3, V3); \
782  		XOR(V3, V3, V2); \
783  		M2(V2, V2); \
784  		XOR(V2, V2, V1); \
785  		M2(V1, V1); \
786  		XOR(V1, V1, b); \
787  		XOR(V0, V0, M); \
788  		M2(M, M); \
789  		XOR(V1, V1, M); \
790  		M2(M, M); \
791  		XOR(V2, V2, M); \
792  		M2(M, M); \
793  		XOR(V3, V3, M); \
794  		M2(M, M); \
795  		XOR(V4, V4, M); \
796  	} while (0)
797  #define TWEAK5   do { \
798  		V14 = SPH_ROTL32(V14, 1); \
799  		V15 = SPH_ROTL32(V15, 1); \
800  		V16 = SPH_ROTL32(V16, 1); \
801  		V17 = SPH_ROTL32(V17, 1); \
802  		V24 = SPH_ROTL32(V24, 2); \
803  		V25 = SPH_ROTL32(V25, 2); \
804  		V26 = SPH_ROTL32(V26, 2); \
805  		V27 = SPH_ROTL32(V27, 2); \
806  		V34 = SPH_ROTL32(V34, 3); \
807  		V35 = SPH_ROTL32(V35, 3); \
808  		V36 = SPH_ROTL32(V36, 3); \
809  		V37 = SPH_ROTL32(V37, 3); \
810  		V44 = SPH_ROTL32(V44, 4); \
811  		V45 = SPH_ROTL32(V45, 4); \
812  		V46 = SPH_ROTL32(V46, 4); \
813  		V47 = SPH_ROTL32(V47, 4); \
814  	} while (0)
815  #if SPH_LUFFA_PARALLEL
816  #define P5   do { \
817  		int r; \
818  		sph_u64 W0, W1, W2, W3, W4, W5, W6, W7; \
819  		TWEAK5; \
820  		W0 = (sph_u64)V00 | ((sph_u64)V10 << 32); \
821  		W1 = (sph_u64)V01 | ((sph_u64)V11 << 32); \
822  		W2 = (sph_u64)V02 | ((sph_u64)V12 << 32); \
823  		W3 = (sph_u64)V03 | ((sph_u64)V13 << 32); \
824  		W4 = (sph_u64)V04 | ((sph_u64)V14 << 32); \
825  		W5 = (sph_u64)V05 | ((sph_u64)V15 << 32); \
826  		W6 = (sph_u64)V06 | ((sph_u64)V16 << 32); \
827  		W7 = (sph_u64)V07 | ((sph_u64)V17 << 32); \
828  		for (r = 0; r < 8; r ++) { \
829  			SUB_CRUMBW(W0, W1, W2, W3); \
830  			SUB_CRUMBW(W5, W6, W7, W4); \
831  			MIX_WORDW(W0, W4); \
832  			MIX_WORDW(W1, W5); \
833  			MIX_WORDW(W2, W6); \
834  			MIX_WORDW(W3, W7); \
835  			W0 ^= RCW010[r]; \
836  			W4 ^= RCW014[r]; \
837  		} \
838  		V00 = SPH_T32((sph_u32)W0); \
839  		V10 = SPH_T32((sph_u32)(W0 >> 32)); \
840  		V01 = SPH_T32((sph_u32)W1); \
841  		V11 = SPH_T32((sph_u32)(W1 >> 32)); \
842  		V02 = SPH_T32((sph_u32)W2); \
843  		V12 = SPH_T32((sph_u32)(W2 >> 32)); \
844  		V03 = SPH_T32((sph_u32)W3); \
845  		V13 = SPH_T32((sph_u32)(W3 >> 32)); \
846  		V04 = SPH_T32((sph_u32)W4); \
847  		V14 = SPH_T32((sph_u32)(W4 >> 32)); \
848  		V05 = SPH_T32((sph_u32)W5); \
849  		V15 = SPH_T32((sph_u32)(W5 >> 32)); \
850  		V06 = SPH_T32((sph_u32)W6); \
851  		V16 = SPH_T32((sph_u32)(W6 >> 32)); \
852  		V07 = SPH_T32((sph_u32)W7); \
853  		V17 = SPH_T32((sph_u32)(W7 >> 32)); \
854  		W0 = (sph_u64)V20 | ((sph_u64)V30 << 32); \
855  		W1 = (sph_u64)V21 | ((sph_u64)V31 << 32); \
856  		W2 = (sph_u64)V22 | ((sph_u64)V32 << 32); \
857  		W3 = (sph_u64)V23 | ((sph_u64)V33 << 32); \
858  		W4 = (sph_u64)V24 | ((sph_u64)V34 << 32); \
859  		W5 = (sph_u64)V25 | ((sph_u64)V35 << 32); \
860  		W6 = (sph_u64)V26 | ((sph_u64)V36 << 32); \
861  		W7 = (sph_u64)V27 | ((sph_u64)V37 << 32); \
862  		for (r = 0; r < 8; r ++) { \
863  			SUB_CRUMBW(W0, W1, W2, W3); \
864  			SUB_CRUMBW(W5, W6, W7, W4); \
865  			MIX_WORDW(W0, W4); \
866  			MIX_WORDW(W1, W5); \
867  			MIX_WORDW(W2, W6); \
868  			MIX_WORDW(W3, W7); \
869  			W0 ^= RCW230[r]; \
870  			W4 ^= RCW234[r]; \
871  		} \
872  		V20 = SPH_T32((sph_u32)W0); \
873  		V30 = SPH_T32((sph_u32)(W0 >> 32)); \
874  		V21 = SPH_T32((sph_u32)W1); \
875  		V31 = SPH_T32((sph_u32)(W1 >> 32)); \
876  		V22 = SPH_T32((sph_u32)W2); \
877  		V32 = SPH_T32((sph_u32)(W2 >> 32)); \
878  		V23 = SPH_T32((sph_u32)W3); \
879  		V33 = SPH_T32((sph_u32)(W3 >> 32)); \
880  		V24 = SPH_T32((sph_u32)W4); \
881  		V34 = SPH_T32((sph_u32)(W4 >> 32)); \
882  		V25 = SPH_T32((sph_u32)W5); \
883  		V35 = SPH_T32((sph_u32)(W5 >> 32)); \
884  		V26 = SPH_T32((sph_u32)W6); \
885  		V36 = SPH_T32((sph_u32)(W6 >> 32)); \
886  		V27 = SPH_T32((sph_u32)W7); \
887  		V37 = SPH_T32((sph_u32)(W7 >> 32)); \
888  		for (r = 0; r < 8; r ++) { \
889  			SUB_CRUMB(V40, V41, V42, V43); \
890  			SUB_CRUMB(V45, V46, V47, V44); \
891  			MIX_WORD(V40, V44); \
892  			MIX_WORD(V41, V45); \
893  			MIX_WORD(V42, V46); \
894  			MIX_WORD(V43, V47); \
895  			V40 ^= RC40[r]; \
896  			V44 ^= RC44[r]; \
897  		} \
898  	} while (0)
899  #else
900  #define P5   do { \
901  		int r; \
902  		TWEAK5; \
903  		for (r = 0; r < 8; r ++) { \
904  			SUB_CRUMB(V00, V01, V02, V03); \
905  			SUB_CRUMB(V05, V06, V07, V04); \
906  			MIX_WORD(V00, V04); \
907  			MIX_WORD(V01, V05); \
908  			MIX_WORD(V02, V06); \
909  			MIX_WORD(V03, V07); \
910  			V00 ^= RC00[r]; \
911  			V04 ^= RC04[r]; \
912  		} \
913  		for (r = 0; r < 8; r ++) { \
914  			SUB_CRUMB(V10, V11, V12, V13); \
915  			SUB_CRUMB(V15, V16, V17, V14); \
916  			MIX_WORD(V10, V14); \
917  			MIX_WORD(V11, V15); \
918  			MIX_WORD(V12, V16); \
919  			MIX_WORD(V13, V17); \
920  			V10 ^= RC10[r]; \
921  			V14 ^= RC14[r]; \
922  		} \
923  		for (r = 0; r < 8; r ++) { \
924  			SUB_CRUMB(V20, V21, V22, V23); \
925  			SUB_CRUMB(V25, V26, V27, V24); \
926  			MIX_WORD(V20, V24); \
927  			MIX_WORD(V21, V25); \
928  			MIX_WORD(V22, V26); \
929  			MIX_WORD(V23, V27); \
930  			V20 ^= RC20[r]; \
931  			V24 ^= RC24[r]; \
932  		} \
933  		for (r = 0; r < 8; r ++) { \
934  			SUB_CRUMB(V30, V31, V32, V33); \
935  			SUB_CRUMB(V35, V36, V37, V34); \
936  			MIX_WORD(V30, V34); \
937  			MIX_WORD(V31, V35); \
938  			MIX_WORD(V32, V36); \
939  			MIX_WORD(V33, V37); \
940  			V30 ^= RC30[r]; \
941  			V34 ^= RC34[r]; \
942  		} \
943  		for (r = 0; r < 8; r ++) { \
944  			SUB_CRUMB(V40, V41, V42, V43); \
945  			SUB_CRUMB(V45, V46, V47, V44); \
946  			MIX_WORD(V40, V44); \
947  			MIX_WORD(V41, V45); \
948  			MIX_WORD(V42, V46); \
949  			MIX_WORD(V43, V47); \
950  			V40 ^= RC40[r]; \
951  			V44 ^= RC44[r]; \
952  		} \
953  	} while (0)
954  #endif
955  static void
956  luffa3(sph_luffa224_context *sc, const void *data, size_t len)
957  {
958  	unsigned char *buf;
959  	size_t ptr;
960  	DECL_STATE3
961  	buf = sc->buf;
962  	ptr = sc->ptr;
963  	if (len < (sizeof sc->buf) - ptr) {
964  		memcpy(buf + ptr, data, len);
965  		ptr += len;
966  		sc->ptr = ptr;
967  		return;
968  	}
969  	READ_STATE3(sc);
970  	while (len > 0) {
971  		size_t clen;
972  		clen = (sizeof sc->buf) - ptr;
973  		if (clen > len)
974  			clen = len;
975  		memcpy(buf + ptr, data, clen);
976  		ptr += clen;
977  		data = (const unsigned char *)data + clen;
978  		len -= clen;
979  		if (ptr == sizeof sc->buf) {
980  			MI3;
981  			P3;
982  			ptr = 0;
983  		}
984  	}
985  	WRITE_STATE3(sc);
986  	sc->ptr = ptr;
987  }
988  static void
989  luffa3_close(sph_luffa224_context *sc, unsigned ub, unsigned n,
990  	void *dst, unsigned out_size_w32)
991  {
992  	unsigned char *buf, *out;
993  	size_t ptr;
994  	unsigned z;
995  	int i;
996  	DECL_STATE3
997  	buf = sc->buf;
998  	ptr = sc->ptr;
999  	z = 0x80 >> n;
1000  	buf[ptr ++] = ((ub & -z) | z) & 0xFF;
1001  	memset(buf + ptr, 0, (sizeof sc->buf) - ptr);
1002  	READ_STATE3(sc);
1003  	for (i = 0; i < 2; i ++) {
1004  		MI3;
1005  		P3;
1006  		memset(buf, 0, sizeof sc->buf);
1007  	}
1008  	out = dst;
1009  	sph_enc32be(out +  0, V00 ^ V10 ^ V20);
1010  	sph_enc32be(out +  4, V01 ^ V11 ^ V21);
1011  	sph_enc32be(out +  8, V02 ^ V12 ^ V22);
1012  	sph_enc32be(out + 12, V03 ^ V13 ^ V23);
1013  	sph_enc32be(out + 16, V04 ^ V14 ^ V24);
1014  	sph_enc32be(out + 20, V05 ^ V15 ^ V25);
1015  	sph_enc32be(out + 24, V06 ^ V16 ^ V26);
1016  	if (out_size_w32 > 7)
<span onclick='openModal()' class='match'>1017  		sph_enc32be(out + 28, V07 ^ V17 ^ V27);
1018  }
1019  static void
1020  luffa4(sph_luffa384_context *sc, const void *data, size_t len)
1021  {
1022  	unsigned char *buf;
</span>1023  	size_t ptr;
1024  	DECL_STATE4
1025  	buf = sc->buf;
1026  	ptr = sc->ptr;
1027  	if (len < (sizeof sc->buf) - ptr) {
1028  		memcpy(buf + ptr, data, len);
1029  		ptr += len;
1030  		sc->ptr = ptr;
1031  		return;
1032  	}
1033  	READ_STATE4(sc);
1034  	while (len > 0) {
1035  		size_t clen;
1036  		clen = (sizeof sc->buf) - ptr;
1037  		if (clen > len)
1038  			clen = len;
1039  		memcpy(buf + ptr, data, clen);
1040  		ptr += clen;
1041  		data = (const unsigned char *)data + clen;
1042  		len -= clen;
1043  		if (ptr == sizeof sc->buf) {
1044  			MI4;
1045  			P4;
1046  			ptr = 0;
1047  		}
1048  	}
1049  	WRITE_STATE4(sc);
1050  	sc->ptr = ptr;
1051  }
1052  static void
1053  luffa4_close(sph_luffa384_context *sc, unsigned ub, unsigned n, void *dst)
1054  {
1055  	unsigned char *buf, *out;
1056  	size_t ptr;
1057  	unsigned z;
1058  	int i;
1059  	DECL_STATE4
1060  	buf = sc->buf;
1061  	ptr = sc->ptr;
1062  	out = dst;
1063  	z = 0x80 >> n;
1064  	buf[ptr ++] = ((ub & -z) | z) & 0xFF;
1065  	memset(buf + ptr, 0, (sizeof sc->buf) - ptr);
1066  	READ_STATE4(sc);
1067  	for (i = 0; i < 3; i ++) {
1068  		MI4;
1069  		P4;
1070  		switch (i) {
1071  		case 0:
1072  			memset(buf, 0, sizeof sc->buf);
1073  			break;
1074  		case 1:
1075  			sph_enc32be(out +  0, V00 ^ V10 ^ V20 ^ V30);
1076  			sph_enc32be(out +  4, V01 ^ V11 ^ V21 ^ V31);
1077  			sph_enc32be(out +  8, V02 ^ V12 ^ V22 ^ V32);
1078  			sph_enc32be(out + 12, V03 ^ V13 ^ V23 ^ V33);
1079  			sph_enc32be(out + 16, V04 ^ V14 ^ V24 ^ V34);
1080  			sph_enc32be(out + 20, V05 ^ V15 ^ V25 ^ V35);
1081  			sph_enc32be(out + 24, V06 ^ V16 ^ V26 ^ V36);
1082  			sph_enc32be(out + 28, V07 ^ V17 ^ V27 ^ V37);
1083  			break;
1084  		case 2:
1085  			sph_enc32be(out + 32, V00 ^ V10 ^ V20 ^ V30);
1086  			sph_enc32be(out + 36, V01 ^ V11 ^ V21 ^ V31);
1087  			sph_enc32be(out + 40, V02 ^ V12 ^ V22 ^ V32);
1088  			sph_enc32be(out + 44, V03 ^ V13 ^ V23 ^ V33);
1089  			break;
1090  		}
1091  	}
1092  }
1093  static void
1094  luffa5(sph_luffa512_context *sc, const void *data, size_t len)
1095  {
1096  	unsigned char *buf;
1097  	size_t ptr;
1098  	DECL_STATE5
1099  	buf = sc->buf;
1100  	ptr = sc->ptr;
1101  	if (len < (sizeof sc->buf) - ptr) {
1102  		memcpy(buf + ptr, data, len);
1103  		ptr += len;
1104  		sc->ptr = ptr;
1105  		return;
1106  	}
1107  	READ_STATE5(sc);
1108  	while (len > 0) {
1109  		size_t clen;
1110  		clen = (sizeof sc->buf) - ptr;
1111  		if (clen > len)
1112  			clen = len;
1113  		memcpy(buf + ptr, data, clen);
1114  		ptr += clen;
1115  		data = (const unsigned char *)data + clen;
1116  		len -= clen;
1117  		if (ptr == sizeof sc->buf) {
1118  			MI5;
1119  			P5;
1120  			ptr = 0;
1121  		}
1122  	}
1123  	WRITE_STATE5(sc);
1124  	sc->ptr = ptr;
1125  }
1126  static void
1127  luffa5_close(sph_luffa512_context *sc, unsigned ub, unsigned n, void *dst)
1128  {
1129  	unsigned char *buf, *out;
1130  	size_t ptr;
1131  	unsigned z;
1132  	int i;
1133  	DECL_STATE5
1134  	buf = sc->buf;
1135  	ptr = sc->ptr;
1136  	out = dst;
1137  	z = 0x80 >> n;
1138  	buf[ptr ++] = ((ub & -z) | z) & 0xFF;
1139  	memset(buf + ptr, 0, (sizeof sc->buf) - ptr);
1140  	READ_STATE5(sc);
1141  	for (i = 0; i < 3; i ++) {
1142  		MI5;
1143  		P5;
1144  		switch (i) {
1145  		case 0:
1146  			memset(buf, 0, sizeof sc->buf);
1147  			break;
1148  		case 1:
1149  			sph_enc32be(out +  0, V00 ^ V10 ^ V20 ^ V30 ^ V40);
1150  			sph_enc32be(out +  4, V01 ^ V11 ^ V21 ^ V31 ^ V41);
1151  			sph_enc32be(out +  8, V02 ^ V12 ^ V22 ^ V32 ^ V42);
1152  			sph_enc32be(out + 12, V03 ^ V13 ^ V23 ^ V33 ^ V43);
1153  			sph_enc32be(out + 16, V04 ^ V14 ^ V24 ^ V34 ^ V44);
1154  			sph_enc32be(out + 20, V05 ^ V15 ^ V25 ^ V35 ^ V45);
1155  			sph_enc32be(out + 24, V06 ^ V16 ^ V26 ^ V36 ^ V46);
1156  			sph_enc32be(out + 28, V07 ^ V17 ^ V27 ^ V37 ^ V47);
1157  			break;
1158  		case 2:
1159  			sph_enc32be(out + 32, V00 ^ V10 ^ V20 ^ V30 ^ V40);
1160  			sph_enc32be(out + 36, V01 ^ V11 ^ V21 ^ V31 ^ V41);
1161  			sph_enc32be(out + 40, V02 ^ V12 ^ V22 ^ V32 ^ V42);
1162  			sph_enc32be(out + 44, V03 ^ V13 ^ V23 ^ V33 ^ V43);
1163  			sph_enc32be(out + 48, V04 ^ V14 ^ V24 ^ V34 ^ V44);
1164  			sph_enc32be(out + 52, V05 ^ V15 ^ V25 ^ V35 ^ V45);
1165  			sph_enc32be(out + 56, V06 ^ V16 ^ V26 ^ V36 ^ V46);
1166  			sph_enc32be(out + 60, V07 ^ V17 ^ V27 ^ V37 ^ V47);
1167  			break;
1168  		}
1169  	}
1170  }
1171  void
1172  sph_luffa224_init(void *cc)
1173  {
1174  	sph_luffa224_context *sc;
1175  	sc = cc;
1176  	memcpy(sc->V, V_INIT, sizeof(sc->V));
1177  	sc->ptr = 0;
1178  }
1179  void
1180  sph_luffa224(void *cc, const void *data, size_t len)
1181  {
1182  	luffa3(cc, data, len);
1183  }
1184  void
1185  sph_luffa224_close(void *cc, void *dst)
1186  {
1187  	sph_luffa224_addbits_and_close(cc, 0, 0, dst);
1188  }
1189  void
1190  sph_luffa224_addbits_and_close(void *cc, unsigned ub, unsigned n, void *dst)
1191  {
1192  	luffa3_close(cc, ub, n, dst, 7);
1193  	sph_luffa224_init(cc);
1194  }
1195  void
1196  sph_luffa256_init(void *cc)
1197  {
1198  	sph_luffa256_context *sc;
1199  	sc = cc;
1200  	memcpy(sc->V, V_INIT, sizeof(sc->V));
1201  	sc->ptr = 0;
1202  }
1203  void
1204  sph_luffa256(void *cc, const void *data, size_t len)
1205  {
1206  	luffa3(cc, data, len);
1207  }
1208  void
1209  sph_luffa256_close(void *cc, void *dst)
1210  {
1211  	sph_luffa256_addbits_and_close(cc, 0, 0, dst);
1212  }
1213  void
1214  sph_luffa256_addbits_and_close(void *cc, unsigned ub, unsigned n, void *dst)
1215  {
1216  	luffa3_close(cc, ub, n, dst, 8);
1217  	sph_luffa256_init(cc);
1218  }
1219  void
1220  sph_luffa384_init(void *cc)
1221  {
1222  	sph_luffa384_context *sc;
1223  	sc = cc;
1224  	memcpy(sc->V, V_INIT, sizeof(sc->V));
1225  	sc->ptr = 0;
1226  }
1227  void
1228  sph_luffa384(void *cc, const void *data, size_t len)
1229  {
1230  	luffa4(cc, data, len);
1231  }
1232  void
1233  sph_luffa384_close(void *cc, void *dst)
1234  {
1235  	sph_luffa384_addbits_and_close(cc, 0, 0, dst);
1236  }
1237  void
1238  sph_luffa384_addbits_and_close(void *cc, unsigned ub, unsigned n, void *dst)
1239  {
1240  	luffa4_close(cc, ub, n, dst);
1241  	sph_luffa384_init(cc);
1242  }
1243  void
1244  sph_luffa512_init(void *cc)
1245  {
1246  	sph_luffa512_context *sc;
1247  	sc = cc;
1248  	memcpy(sc->V, V_INIT, sizeof(sc->V));
1249  	sc->ptr = 0;
1250  }
1251  void
1252  sph_luffa512(void *cc, const void *data, size_t len)
1253  {
1254  	luffa5(cc, data, len);
1255  }
1256  void
1257  sph_luffa512_close(void *cc, void *dst)
1258  {
1259  	sph_luffa512_addbits_and_close(cc, 0, 0, dst);
1260  }
1261  void
1262  sph_luffa512_addbits_and_close(void *cc, unsigned ub, unsigned n, void *dst)
1263  {
1264  	luffa5_close(cc, ub, n, dst);
1265  	sph_luffa512_init(cc);
1266  }
1267  #ifdef __cplusplus
1268  }
1269  #endif
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from libtomcrypt-MDEwOlJlcG9zaXRvcnk3NzcwMTE=-flat-ltc_ecc_points.c</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from xmrig-MDEwOlJlcG9zaXRvcnk4ODMyNzQwNg==-flat-sph_luffa.c</div>
                </div>
                <div class="column column_space"><pre><code>21     }
22  }
23  int ltc_ecc_set_point_xyz(ltc_mp_digit x, ltc_mp_digit y, ltc_mp_digit z, ecc_point *p)
24  {
25     int err;
</pre></code></div>
                <div class="column column_space"><pre><code>1017  		sph_enc32be(out + 28, V07 ^ V17 ^ V27);
1018  }
1019  static void
1020  luffa4(sph_luffa384_context *sc, const void *data, size_t len)
1021  {
1022  	unsigned char *buf;
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    