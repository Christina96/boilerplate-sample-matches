
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 6.015037593984962%, Tokens: 8, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>PINRemoteImage-MDEwOlJlcG9zaXRvcnkzOTUzNzEwMw==-flat-ssim.c</h3>
            <pre><code>1  #include <assert.h>
2  #include <stdlib.h>  
3  #include "src/dsp/dsp.h"
4  #if !defined(WEBP_REDUCE_SIZE)
5  static const uint32_t kWeight[2 * VP8_SSIM_KERNEL + 1] = {
6    1, 2, 3, 4, 3, 2, 1
7  };
8  static const uint32_t kWeightSum = 16 * 16;   
9  static WEBP_INLINE double SSIMCalculation(
10      const VP8DistoStats* const stats, uint32_t N  &bsol;*num samples*/) {
<span onclick='openModal()' class='match'>11    const uint32_t w2 =  N * N;
12    const uint32_t C1 = 20 * w2;
13    const uint32_t C2 = 60 * w2;
14    const uint32_t C3 = 8 * 8 * w2;   
</span>15    const uint64_t xmxm = (uint64_t)stats->xm * stats->xm;
16    const uint64_t ymym = (uint64_t)stats->ym * stats->ym;
17    if (xmxm + ymym >= C3) {
18      const int64_t xmym = (int64_t)stats->xm * stats->ym;
19      const int64_t sxy = (int64_t)stats->xym * N - xmym;    
20      const uint64_t sxx = (uint64_t)stats->xxm * N - xmxm;
21      const uint64_t syy = (uint64_t)stats->yym * N - ymym;
22      const uint64_t num_S = (2 * (uint64_t)(sxy < 0 ? 0 : sxy) + C2) >> 8;
23      const uint64_t den_S = (sxx + syy + C2) >> 8;
24      const uint64_t fnum = (2 * xmym + C1) * num_S;
25      const uint64_t fden = (xmxm + ymym + C1) * den_S;
26      const double r = (double)fnum / fden;
27      assert(r >= 0. && r <= 1.0);
28      return r;
29    }
30    return 1.;   
31  }
32  double VP8SSIMFromStats(const VP8DistoStats* const stats) {
33    return SSIMCalculation(stats, kWeightSum);
34  }
35  double VP8SSIMFromStatsClipped(const VP8DistoStats* const stats) {
36    return SSIMCalculation(stats, stats->w);
37  }
38  static double SSIMGetClipped_C(const uint8_t* src1, int stride1,
39                                 const uint8_t* src2, int stride2,
40                                 int xo, int yo, int W, int H) {
41    VP8DistoStats stats = { 0, 0, 0, 0, 0, 0 };
42    const int ymin = (yo - VP8_SSIM_KERNEL < 0) ? 0 : yo - VP8_SSIM_KERNEL;
43    const int ymax = (yo + VP8_SSIM_KERNEL > H - 1) ? H - 1
44                                                    : yo + VP8_SSIM_KERNEL;
45    const int xmin = (xo - VP8_SSIM_KERNEL < 0) ? 0 : xo - VP8_SSIM_KERNEL;
46    const int xmax = (xo + VP8_SSIM_KERNEL > W - 1) ? W - 1
47                                                    : xo + VP8_SSIM_KERNEL;
48    int x, y;
49    src1 += ymin * stride1;
50    src2 += ymin * stride2;
51    for (y = ymin; y <= ymax; ++y, src1 += stride1, src2 += stride2) {
52      for (x = xmin; x <= xmax; ++x) {
53        const uint32_t w = kWeight[VP8_SSIM_KERNEL + x - xo]
54                         * kWeight[VP8_SSIM_KERNEL + y - yo];
55        const uint32_t s1 = src1[x];
56        const uint32_t s2 = src2[x];
57        stats.w   += w;
58        stats.xm  += w * s1;
59        stats.ym  += w * s2;
60        stats.xxm += w * s1 * s1;
61        stats.xym += w * s1 * s2;
62        stats.yym += w * s2 * s2;
63      }
64    }
65    return VP8SSIMFromStatsClipped(&stats);
66  }
67  static double SSIMGet_C(const uint8_t* src1, int stride1,
68                          const uint8_t* src2, int stride2) {
69    VP8DistoStats stats = { 0, 0, 0, 0, 0, 0 };
70    int x, y;
71    for (y = 0; y <= 2 * VP8_SSIM_KERNEL; ++y, src1 += stride1, src2 += stride2) {
72      for (x = 0; x <= 2 * VP8_SSIM_KERNEL; ++x) {
73        const uint32_t w = kWeight[x] * kWeight[y];
74        const uint32_t s1 = src1[x];
75        const uint32_t s2 = src2[x];
76        stats.xm  += w * s1;
77        stats.ym  += w * s2;
78        stats.xxm += w * s1 * s1;
79        stats.xym += w * s1 * s2;
80        stats.yym += w * s2 * s2;
81      }
82    }
83    return VP8SSIMFromStats(&stats);
84  }
85  #endif  
86  #if !defined(WEBP_DISABLE_STATS)
87  static uint32_t AccumulateSSE_C(const uint8_t* src1,
88                                  const uint8_t* src2, int len) {
89    int i;
90    uint32_t sse2 = 0;
91    assert(len <= 65535);  
92    for (i = 0; i < len; ++i) {
93      const int32_t diff = src1[i] - src2[i];
94      sse2 += diff * diff;
95    }
96    return sse2;
97  }
98  #endif
99  #if !defined(WEBP_REDUCE_SIZE)
100  VP8SSIMGetFunc VP8SSIMGet;
101  VP8SSIMGetClippedFunc VP8SSIMGetClipped;
102  #endif
103  #if !defined(WEBP_DISABLE_STATS)
104  VP8AccumulateSSEFunc VP8AccumulateSSE;
105  #endif
106  extern void VP8SSIMDspInitSSE2(void);
107  WEBP_DSP_INIT_FUNC(VP8SSIMDspInit) {
108  #if !defined(WEBP_REDUCE_SIZE)
109    VP8SSIMGetClipped = SSIMGetClipped_C;
110    VP8SSIMGet = SSIMGet_C;
111  #endif
112  #if !defined(WEBP_DISABLE_STATS)
113    VP8AccumulateSSE = AccumulateSSE_C;
114  #endif
115    if (VP8GetCPUInfo != NULL) {
116  #if defined(WEBP_USE_SSE2)
117      if (VP8GetCPUInfo(kSSE2)) {
118        VP8SSIMDspInitSSE2();
119      }
120  #endif
121    }
122  }
</code></pre>
        </div>
        <div class="column">
            <h3>redis-MDEwOlJlcG9zaXRvcnkxMDgxMTA3MDY=-flat-testrdb.c</h3>
            <pre><code>1  #include "redismodule.h"
2  #include <string.h>
3  #include <assert.h>
<span onclick='openModal()' class='match'>4  long long conf_aux_count = 0;
5  RedisModuleType *testrdb_type = NULL;
6  RedisModuleString *before_str = NULL;
7  RedisModuleString *after_str = NULL;
</span>8  void *testrdb_type_load(RedisModuleIO *rdb, int encver) {
9      int count = RedisModule_LoadSigned(rdb);
10      assert(count==1);
11      assert(encver==1);
12      RedisModuleString *str = RedisModule_LoadString(rdb);
13      return str;
14  }
15  void testrdb_type_save(RedisModuleIO *rdb, void *value) {
16      RedisModuleString *str = (RedisModuleString*)value;
17      RedisModule_SaveSigned(rdb, 1);
18      RedisModule_SaveString(rdb, str);
19  }
20  void testrdb_aux_save(RedisModuleIO *rdb, int when) {
21      if (conf_aux_count==1) assert(when == REDISMODULE_AUX_AFTER_RDB);
22      if (conf_aux_count==0) assert(0);
23      if (when == REDISMODULE_AUX_BEFORE_RDB) {
24          if (before_str) {
25              RedisModule_SaveSigned(rdb, 1);
26              RedisModule_SaveString(rdb, before_str);
27          } else {
28              RedisModule_SaveSigned(rdb, 0);
29          }
30      } else {
31          if (after_str) {
32              RedisModule_SaveSigned(rdb, 1);
33              RedisModule_SaveString(rdb, after_str);
34          } else {
35              RedisModule_SaveSigned(rdb, 0);
36          }
37      }
38  }
39  int testrdb_aux_load(RedisModuleIO *rdb, int encver, int when) {
40      assert(encver == 1);
41      if (conf_aux_count==1) assert(when == REDISMODULE_AUX_AFTER_RDB);
42      if (conf_aux_count==0) assert(0);
43      RedisModuleCtx *ctx = RedisModule_GetContextFromIO(rdb);
44      if (when == REDISMODULE_AUX_BEFORE_RDB) {
45          if (before_str)
46              RedisModule_FreeString(ctx, before_str);
47          before_str = NULL;
48          int count = RedisModule_LoadSigned(rdb);
49          if (count)
50              before_str = RedisModule_LoadString(rdb);
51      } else {
52          if (after_str)
53              RedisModule_FreeString(ctx, after_str);
54          after_str = NULL;
55          int count = RedisModule_LoadSigned(rdb);
56          if (count)
57              after_str = RedisModule_LoadString(rdb);
58      }
59      return REDISMODULE_OK;
60  }
61  void testrdb_type_free(void *value) {
62      RedisModule_FreeString(NULL, (RedisModuleString*)value);
63  }
64  int testrdb_set_before(RedisModuleCtx *ctx, RedisModuleString **argv, int argc)
65  {
66      if (argc != 2) {
67          RedisModule_WrongArity(ctx);
68          return REDISMODULE_OK;
69      }
70      if (before_str)
71          RedisModule_FreeString(ctx, before_str);
72      before_str = argv[1];
73      RedisModule_RetainString(ctx, argv[1]);
74      RedisModule_ReplyWithLongLong(ctx, 1);
75      return REDISMODULE_OK;
76  }
77  int testrdb_get_before(RedisModuleCtx *ctx, RedisModuleString **argv, int argc)
78  {
79      REDISMODULE_NOT_USED(argv);
80      if (argc != 1){
81          RedisModule_WrongArity(ctx);
82          return REDISMODULE_OK;
83      }
84      if (before_str)
85          RedisModule_ReplyWithString(ctx, before_str);
86      else
87          RedisModule_ReplyWithStringBuffer(ctx, "", 0);
88      return REDISMODULE_OK;
89  }
90  int testrdb_set_after(RedisModuleCtx *ctx, RedisModuleString **argv, int argc)
91  {
92      if (argc != 2){
93          RedisModule_WrongArity(ctx);
94          return REDISMODULE_OK;
95      }
96      if (after_str)
97          RedisModule_FreeString(ctx, after_str);
98      after_str = argv[1];
99      RedisModule_RetainString(ctx, argv[1]);
100      RedisModule_ReplyWithLongLong(ctx, 1);
101      return REDISMODULE_OK;
102  }
103  int testrdb_get_after(RedisModuleCtx *ctx, RedisModuleString **argv, int argc)
104  {
105      REDISMODULE_NOT_USED(argv);
106      if (argc != 1){
107          RedisModule_WrongArity(ctx);
108          return REDISMODULE_OK;
109      }
110      if (after_str)
111          RedisModule_ReplyWithString(ctx, after_str);
112      else
113          RedisModule_ReplyWithStringBuffer(ctx, "", 0);
114      return REDISMODULE_OK;
115  }
116  int testrdb_set_key(RedisModuleCtx *ctx, RedisModuleString **argv, int argc)
117  {
118      if (argc != 3){
119          RedisModule_WrongArity(ctx);
120          return REDISMODULE_OK;
121      }
122      RedisModuleKey *key = RedisModule_OpenKey(ctx, argv[1], REDISMODULE_WRITE);
123      RedisModuleString *str = RedisModule_ModuleTypeGetValue(key);
124      if (str)
125          RedisModule_FreeString(ctx, str);
126      RedisModule_ModuleTypeSetValue(key, testrdb_type, argv[2]);
127      RedisModule_RetainString(ctx, argv[2]);
128      RedisModule_CloseKey(key);
129      RedisModule_ReplyWithLongLong(ctx, 1);
130      return REDISMODULE_OK;
131  }
132  int testrdb_get_key(RedisModuleCtx *ctx, RedisModuleString **argv, int argc)
133  {
134      if (argc != 2){
135          RedisModule_WrongArity(ctx);
136          return REDISMODULE_OK;
137      }
138      RedisModuleKey *key = RedisModule_OpenKey(ctx, argv[1], REDISMODULE_WRITE);
139      RedisModuleString *str = RedisModule_ModuleTypeGetValue(key);
140      RedisModule_CloseKey(key);
141      RedisModule_ReplyWithString(ctx, str);
142      return REDISMODULE_OK;
143  }
144  int RedisModule_OnLoad(RedisModuleCtx *ctx, RedisModuleString **argv, int argc) {
145      REDISMODULE_NOT_USED(argv);
146      REDISMODULE_NOT_USED(argc);
147      if (RedisModule_Init(ctx,"testrdb",1,REDISMODULE_APIVER_1) == REDISMODULE_ERR)
148          return REDISMODULE_ERR;
149      if (argc > 0)
150          RedisModule_StringToLongLong(argv[0], &conf_aux_count);
151      if (conf_aux_count==0) {
152          RedisModuleTypeMethods datatype_methods = {
153              .version = 1,
154              .rdb_load = testrdb_type_load,
155              .rdb_save = testrdb_type_save,
156              .aof_rewrite = NULL,
157              .digest = NULL,
158              .free = testrdb_type_free,
159          };
160          testrdb_type = RedisModule_CreateDataType(ctx, "test__rdb", 1, &datatype_methods);
161          if (testrdb_type == NULL)
162              return REDISMODULE_ERR;
163      } else {
164          RedisModuleTypeMethods datatype_methods = {
165              .version = REDISMODULE_TYPE_METHOD_VERSION,
166              .rdb_load = testrdb_type_load,
167              .rdb_save = testrdb_type_save,
168              .aof_rewrite = NULL,
169              .digest = NULL,
170              .free = testrdb_type_free,
171              .aux_load = testrdb_aux_load,
172              .aux_save = testrdb_aux_save,
173              .aux_save_triggers = (conf_aux_count == 1 ?
174                                    REDISMODULE_AUX_AFTER_RDB :
175                                    REDISMODULE_AUX_BEFORE_RDB | REDISMODULE_AUX_AFTER_RDB)
176          };
177          testrdb_type = RedisModule_CreateDataType(ctx, "test__rdb", 1, &datatype_methods);
178          if (testrdb_type == NULL)
179              return REDISMODULE_ERR;
180      }
181      if (RedisModule_CreateCommand(ctx,"testrdb.set.before", testrdb_set_before,"deny-oom",0,0,0) == REDISMODULE_ERR)
182          return REDISMODULE_ERR;
183      if (RedisModule_CreateCommand(ctx,"testrdb.get.before", testrdb_get_before,"",0,0,0) == REDISMODULE_ERR)
184          return REDISMODULE_ERR;
185      if (RedisModule_CreateCommand(ctx,"testrdb.set.after", testrdb_set_after,"deny-oom",0,0,0) == REDISMODULE_ERR)
186          return REDISMODULE_ERR;
187      if (RedisModule_CreateCommand(ctx,"testrdb.get.after", testrdb_get_after,"",0,0,0) == REDISMODULE_ERR)
188          return REDISMODULE_ERR;
189      if (RedisModule_CreateCommand(ctx,"testrdb.set.key", testrdb_set_key,"deny-oom",1,1,1) == REDISMODULE_ERR)
190          return REDISMODULE_ERR;
191      if (RedisModule_CreateCommand(ctx,"testrdb.get.key", testrdb_get_key,"",1,1,1) == REDISMODULE_ERR)
192          return REDISMODULE_ERR;
193      return REDISMODULE_OK;
194  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from PINRemoteImage-MDEwOlJlcG9zaXRvcnkzOTUzNzEwMw==-flat-ssim.c</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from redis-MDEwOlJlcG9zaXRvcnkxMDgxMTA3MDY=-flat-testrdb.c</div>
                </div>
                <div class="column column_space"><pre><code>11    const uint32_t w2 =  N * N;
12    const uint32_t C1 = 20 * w2;
13    const uint32_t C2 = 60 * w2;
14    const uint32_t C3 = 8 * 8 * w2;   
</pre></code></div>
                <div class="column column_space"><pre><code>4  long long conf_aux_count = 0;
5  RedisModuleType *testrdb_type = NULL;
6  RedisModuleString *before_str = NULL;
7  RedisModuleString *after_str = NULL;
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    