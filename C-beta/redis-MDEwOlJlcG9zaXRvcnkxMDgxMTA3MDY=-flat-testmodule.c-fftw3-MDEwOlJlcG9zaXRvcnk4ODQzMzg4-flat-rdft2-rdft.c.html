
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 7.710843373493977%, Tokens: 8, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>redis-MDEwOlJlcG9zaXRvcnkxMDgxMTA3MDY=-flat-testmodule.c</h3>
            <pre><code>1  #define REDISMODULE_EXPERIMENTAL_API
2  #include "../redismodule.h"
3  #include <string.h>
4  #ifdef _WIN32
5  #include "../Win32_Interop/win32_types_hiredis.h"
6  #endif
7  int TestMatchReply(RedisModuleCallReply *reply, char *str) {
8      RedisModuleString *mystr;
9      mystr = RedisModule_CreateStringFromCallReply(reply);
10      if (!mystr) return 0;
11      const char *ptr = RedisModule_StringPtrLen(mystr,NULL);
12      return strcmp(ptr,str) == 0;
13  }
14  int TestCall(RedisModuleCtx *ctx, RedisModuleString **argv, int argc) {
15      REDISMODULE_NOT_USED(argv);
16      REDISMODULE_NOT_USED(argc);
17      RedisModule_AutoMemory(ctx);
18      RedisModuleCallReply *reply;
19      RedisModule_Call(ctx,"DEL","c","mylist");
20      RedisModuleString *mystr = RedisModule_CreateString(ctx,"foo",3);
21      RedisModule_Call(ctx,"RPUSH","csl","mylist",mystr,(PORT_LONGLONG)1234);
22      reply = RedisModule_Call(ctx,"LRANGE","ccc","mylist","0","-1");
23      PORT_LONGLONG items = RedisModule_CallReplyLength(reply);
24      if (items != 2) goto fail;
25      RedisModuleCallReply *item0, *item1;
26      item0 = RedisModule_CallReplyArrayElement(reply,0);
27      item1 = RedisModule_CallReplyArrayElement(reply,1);
28      if (!TestMatchReply(item0,"foo")) goto fail;
29      if (!TestMatchReply(item1,"1234")) goto fail;
30      RedisModule_ReplyWithSimpleString(ctx,"OK");
31      return REDISMODULE_OK;
32  fail:
33      RedisModule_ReplyWithSimpleString(ctx,"ERR");
34      return REDISMODULE_OK;
35  }
36  int TestStringAppend(RedisModuleCtx *ctx, RedisModuleString **argv, int argc) {
37      REDISMODULE_NOT_USED(argv);
38      REDISMODULE_NOT_USED(argc);
39      RedisModuleString *s = RedisModule_CreateString(ctx,"foo",3);
40      RedisModule_StringAppendBuffer(ctx,s,"bar",3);
41      RedisModule_ReplyWithString(ctx,s);
42      RedisModule_FreeString(ctx,s);
43      return REDISMODULE_OK;
44  }
45  int TestStringAppendAM(RedisModuleCtx *ctx, RedisModuleString **argv, int argc) {
46      REDISMODULE_NOT_USED(argv);
47      REDISMODULE_NOT_USED(argc);
48      RedisModule_AutoMemory(ctx);
49      RedisModuleString *s = RedisModule_CreateString(ctx,"foo",3);
50      RedisModule_RetainString(ctx,s);
51      RedisModule_StringAppendBuffer(ctx,s,"bar",3);
52      RedisModule_ReplyWithString(ctx,s);
53      RedisModule_FreeString(ctx,s);
54      return REDISMODULE_OK;
55  }
56  int TestStringPrintf(RedisModuleCtx *ctx, RedisModuleString **argv, int argc) {
57      RedisModule_AutoMemory(ctx);
58      if (argc < 3) {
59          return RedisModule_WrongArity(ctx);
60      }
61      RedisModuleString *s = RedisModule_CreateStringPrintf(ctx, 
62          "Got %d args. argv[1]: %s, argv[2]: %s", 
63          argc, 
64          RedisModule_StringPtrLen(argv[1], NULL),
65          RedisModule_StringPtrLen(argv[2], NULL)
66      );
67      RedisModule_ReplyWithString(ctx,s);
68      return REDISMODULE_OK;
69  }
70  int failTest(RedisModuleCtx *ctx, const char *msg) {
71      RedisModule_ReplyWithError(ctx, msg);
72      return REDISMODULE_ERR;
73  }
74  int TestUnlink(RedisModuleCtx *ctx, RedisModuleString **argv, int argc) {
75      RedisModule_AutoMemory(ctx);
76      REDISMODULE_NOT_USED(argv);
77      REDISMODULE_NOT_USED(argc);
78      RedisModuleKey *k = RedisModule_OpenKey(ctx, RedisModule_CreateStringPrintf(ctx, "unlinked"), REDISMODULE_WRITE | REDISMODULE_READ);
79      if (!k) return failTest(ctx, "Could not create key");
80      if (REDISMODULE_ERR == RedisModule_StringSet(k, RedisModule_CreateStringPrintf(ctx, "Foobar"))) {
81          return failTest(ctx, "Could not set string value");
82      }
83      RedisModuleCallReply *rep = RedisModule_Call(ctx, "EXISTS", "c", "unlinked");
84      if (!rep || RedisModule_CallReplyInteger(rep) != 1) {
85          return failTest(ctx, "Key does not exist before unlink");
86      }
87      if (REDISMODULE_ERR == RedisModule_UnlinkKey(k)) {
88          return failTest(ctx, "Could not unlink key");
89      }
90      rep = RedisModule_Call(ctx, "EXISTS", "c", "unlinked");
91      if (!rep || RedisModule_CallReplyInteger(rep) != 0) {
92          return failTest(ctx, "Could not verify key to be unlinked");
93      }
94      return RedisModule_ReplyWithSimpleString(ctx, "OK");
95  }
96  int NotifyCallback(RedisModuleCtx *ctx, int type, const char *event,
97                     RedisModuleString *key) {
98    RedisModule_Log(ctx, "notice", "Got event type %d, event %s, key %s", type,
99                    event, RedisModule_StringPtrLen(key, NULL));
100    RedisModule_Call(ctx, "HINCRBY", "csc", "notifications", key, "1");
101    return REDISMODULE_OK;
102  }
103  int TestNotifications(RedisModuleCtx *ctx, RedisModuleString **argv, int argc) {
104      REDISMODULE_NOT_USED(argv);
105      REDISMODULE_NOT_USED(argc);
106  #define FAIL(msg, ...)                                                                       \
107      {                                                                                        \
108          RedisModule_Log(ctx, "warning", "Failed NOTIFY Test. Reason: " #msg, ##__VA_ARGS__); \
109          goto err;                                                                            \
110      }
111      RedisModule_Call(ctx, "FLUSHDB", "");
112      RedisModule_Call(ctx, "SET", "cc", "foo", "bar");
113      RedisModule_Call(ctx, "SET", "cc", "foo", "baz");
114      RedisModule_Call(ctx, "SADD", "cc", "bar", "x");
115      RedisModule_Call(ctx, "SADD", "cc", "bar", "y");
116      RedisModule_Call(ctx, "HSET", "ccc", "baz", "x", "y");
117      RedisModule_Call(ctx, "LPUSH", "cc", "l", "y");
118      RedisModule_Call(ctx, "LPUSH", "cc", "l", "y");
119      size_t sz;
120      const char *rep;
121      RedisModuleCallReply *r = RedisModule_Call(ctx, "HGET", "cc", "notifications", "foo");
122      if (r == NULL || RedisModule_CallReplyType(r) != REDISMODULE_REPLY_STRING) {
123          FAIL("Wrong or no reply for foo");
124      } else {
125          rep = RedisModule_CallReplyStringPtr(r, &sz);
126          if (sz != 1 || *rep != '2') {
127              FAIL("Got reply '%s'. expected '2'", RedisModule_CallReplyStringPtr(r, NULL));
128          }
129      }
130      r = RedisModule_Call(ctx, "HGET", "cc", "notifications", "bar");
131      if (r == NULL || RedisModule_CallReplyType(r) != REDISMODULE_REPLY_STRING) {
132          FAIL("Wrong or no reply for bar");
133      } else {
134          rep = RedisModule_CallReplyStringPtr(r, &sz);
135          if (sz != 1 || *rep != '2') {
136              FAIL("Got reply '%s'. expected '2'", rep);
137          }
138      }
139      r = RedisModule_Call(ctx, "HGET", "cc", "notifications", "baz");
140      if (r == NULL || RedisModule_CallReplyType(r) != REDISMODULE_REPLY_STRING) {
141          FAIL("Wrong or no reply for baz");
142      } else {
143          rep = RedisModule_CallReplyStringPtr(r, &sz);
144          if (sz != 1 || *rep != '1') {
145              FAIL("Got reply '%.*s'. expected '1'", sz, rep);
146          }
147      }
148      r = RedisModule_Call(ctx, "HGET", "cc", "notifications", "l");
149      if (r == NULL || RedisModule_CallReplyType(r) != REDISMODULE_REPLY_NULL) {
150          FAIL("Wrong reply for l");
151      }
152      RedisModule_Call(ctx, "FLUSHDB", "");
153      return RedisModule_ReplyWithSimpleString(ctx, "OK");
154  err:
155      RedisModule_Call(ctx, "FLUSHDB", "");
156      return RedisModule_ReplyWithSimpleString(ctx, "ERR");
157  }
158  int TestCtxFlags(RedisModuleCtx *ctx, RedisModuleString **argv, int argc) {
159      REDISMODULE_NOT_USED(argc);
160      REDISMODULE_NOT_USED(argv);
161      RedisModule_AutoMemory(ctx);
162      int ok = 1;
163      const char *errString = NULL;
164  #undef FAIL
165  #define FAIL(msg)        \
166      {                    \
167          ok = 0;          \
168          errString = msg; \
169          goto end;        \
170      }
171      int flags = RedisModule_GetContextFlags(ctx);
172      if (flags == 0) {
173          FAIL("Got no flags");
174      }
175      if (flags & REDISMODULE_CTX_FLAGS_LUA) FAIL("Lua flag was set");
176      if (flags & REDISMODULE_CTX_FLAGS_MULTI) FAIL("Multi flag was set");
177      if (flags & REDISMODULE_CTX_FLAGS_AOF) FAIL("AOF Flag was set")
178      RedisModule_Call(ctx, "config", "ccc", "set", "appendonly", "yes");
179      flags = RedisModule_GetContextFlags(ctx);
180      if (!(flags & REDISMODULE_CTX_FLAGS_AOF)) FAIL("AOF Flag not set after config set");
181      if (flags & REDISMODULE_CTX_FLAGS_RDB) FAIL("RDB Flag was set");
182      RedisModule_Call(ctx, "config", "ccc", "set", "save", "900 1");
183      flags = RedisModule_GetContextFlags(ctx);
184      if (!(flags & REDISMODULE_CTX_FLAGS_RDB)) FAIL("RDB Flag was not set after config set");
185      if (!(flags & REDISMODULE_CTX_FLAGS_MASTER)) FAIL("Master flag was not set");
186      if (flags & REDISMODULE_CTX_FLAGS_SLAVE) FAIL("Slave flag was set");
187      if (flags & REDISMODULE_CTX_FLAGS_READONLY) FAIL("Read-only flag was set");
188      if (flags & REDISMODULE_CTX_FLAGS_CLUSTER) FAIL("Cluster flag was set");
189      if (flags & REDISMODULE_CTX_FLAGS_MAXMEMORY) FAIL("Maxmemory flag was set");
190      RedisModule_Call(ctx, "config", "ccc", "set", "maxmemory", "100000000");
191      flags = RedisModule_GetContextFlags(ctx);
192      if (!(flags & REDISMODULE_CTX_FLAGS_MAXMEMORY))
193          FAIL("Maxmemory flag was not set after config set");
194      if (flags & REDISMODULE_CTX_FLAGS_EVICT) FAIL("Eviction flag was set");
195      RedisModule_Call(ctx, "config", "ccc", "set", "maxmemory-policy", "allkeys-lru");
196      flags = RedisModule_GetContextFlags(ctx);
197      if (!(flags & REDISMODULE_CTX_FLAGS_EVICT)) FAIL("Eviction flag was not set after config set");
198  end:
199      RedisModule_Call(ctx, "config", "ccc", "set", "appendonly", "no");
200      RedisModule_Call(ctx, "config", "ccc", "set", "save", "");
201      RedisModule_Call(ctx, "config", "ccc", "set", "maxmemory", "0");
202      RedisModule_Call(ctx, "config", "ccc", "set", "maxmemory-policy", "noeviction");
203      if (!ok) {
204          RedisModule_Log(ctx, "warning", "Failed CTXFLAGS Test. Reason: %s", errString);
205          return RedisModule_ReplyWithSimpleString(ctx, "ERR");
206      }
<span onclick='openModal()' class='match'>207      return RedisModule_ReplyWithSimpleString(ctx, "OK");
208  }
209  int TestAssertStringReply(RedisModuleCtx *ctx, RedisModuleCallReply *reply, char *str, size_t len) {
210      RedisModuleString *mystr, *expected;
</span>211      if (RedisModule_CallReplyType(reply) != REDISMODULE_REPLY_STRING) {
212          RedisModule_Log(ctx,"warning","Unexpected reply type %d",
213              RedisModule_CallReplyType(reply));
214          return 0;
215      }
216      mystr = RedisModule_CreateStringFromCallReply(reply);
217      expected = RedisModule_CreateString(ctx,str,len);
218      if (RedisModule_StringCompare(mystr,expected) != 0) {
219          const char *mystr_ptr = RedisModule_StringPtrLen(mystr,NULL);
220          const char *expected_ptr = RedisModule_StringPtrLen(expected,NULL);
221          RedisModule_Log(ctx,"warning",
222              "Unexpected string reply '%s' (instead of '%s')",
223              mystr_ptr, expected_ptr);
224          return 0;
225      }
226      return 1;
227  }
228  int TestAssertIntegerReply(RedisModuleCtx *ctx, RedisModuleCallReply *reply, PORT_LONGLONG expected) {
229      if (RedisModule_CallReplyType(reply) != REDISMODULE_REPLY_INTEGER) {
230          RedisModule_Log(ctx,"warning","Unexpected reply type %d",
231              RedisModule_CallReplyType(reply));
232          return 0;
233      }
234      PORT_LONGLONG val = RedisModule_CallReplyInteger(reply);
235      if (val != expected) {
236          RedisModule_Log(ctx,"warning",
237              "Unexpected integer reply '%lld' (instead of '%lld')",
238              val, expected);
239          return 0;
240      }
241      return 1;
242  }
243  #define T(name,...) \
244      do { \
245          RedisModule_Log(ctx,"warning","Testing %s", name); \
246          reply = RedisModule_Call(ctx,name,__VA_ARGS__); \
247      } while (0);
248  int TestIt(RedisModuleCtx *ctx, RedisModuleString **argv, int argc) {
249      REDISMODULE_NOT_USED(argv);
250      REDISMODULE_NOT_USED(argc);
251      RedisModule_AutoMemory(ctx);
252      RedisModuleCallReply *reply;
253      T("dbsize","");
254      if (!TestAssertIntegerReply(ctx,reply,0)) goto fail;
255      T("ping","");
256      if (!TestAssertStringReply(ctx,reply,"PONG",4)) goto fail;
257      T("test.call","");
258      if (!TestAssertStringReply(ctx,reply,"OK",2)) goto fail;
259      T("test.ctxflags","");
260      if (!TestAssertStringReply(ctx,reply,"OK",2)) goto fail;
261      T("test.string.append","");
262      if (!TestAssertStringReply(ctx,reply,"foobar",6)) goto fail;
263      T("test.unlink","");
264      if (!TestAssertStringReply(ctx,reply,"OK",2)) goto fail;
265      T("test.string.append.am","");
266      if (!TestAssertStringReply(ctx,reply,"foobar",6)) goto fail;
267      T("test.string.printf", "cc", "foo", "bar");
268      if (!TestAssertStringReply(ctx,reply,"Got 3 args. argv[1]: foo, argv[2]: bar",38)) goto fail;
269      T("test.notify", "");
270      if (!TestAssertStringReply(ctx,reply,"OK",2)) goto fail;
271      RedisModule_ReplyWithSimpleString(ctx,"ALL TESTS PASSED");
272      return REDISMODULE_OK;
273  fail:
274      RedisModule_ReplyWithSimpleString(ctx,
275          "SOME TEST NOT PASSED! Check server logs");
276      return REDISMODULE_OK;
277  }
278  int RedisModule_OnLoad(RedisModuleCtx *ctx, RedisModuleString **argv, int argc) {
279      REDISMODULE_NOT_USED(argv);
280      REDISMODULE_NOT_USED(argc);
281      if (RedisModule_Init(ctx,"test",1,REDISMODULE_APIVER_1)
282          == REDISMODULE_ERR) return REDISMODULE_ERR;
283      if (RedisModule_CreateCommand(ctx,"test.call",
284          TestCall,"write deny-oom",1,1,1) == REDISMODULE_ERR)
285          return REDISMODULE_ERR;
286      if (RedisModule_CreateCommand(ctx,"test.string.append",
287          TestStringAppend,"write deny-oom",1,1,1) == REDISMODULE_ERR)
288          return REDISMODULE_ERR;
289      if (RedisModule_CreateCommand(ctx,"test.string.append.am",
290          TestStringAppendAM,"write deny-oom",1,1,1) == REDISMODULE_ERR)
291          return REDISMODULE_ERR;
292      if (RedisModule_CreateCommand(ctx,"test.string.printf",
293          TestStringPrintf,"write deny-oom",1,1,1) == REDISMODULE_ERR)
294          return REDISMODULE_ERR;
295      if (RedisModule_CreateCommand(ctx,"test.ctxflags",
296          TestCtxFlags,"readonly",1,1,1) == REDISMODULE_ERR)
297          return REDISMODULE_ERR;
298      if (RedisModule_CreateCommand(ctx,"test.unlink",
299          TestUnlink,"write deny-oom",1,1,1) == REDISMODULE_ERR)
300          return REDISMODULE_ERR;
301      if (RedisModule_CreateCommand(ctx,"test.it",
302          TestIt,"readonly",1,1,1) == REDISMODULE_ERR)
303          return REDISMODULE_ERR;
304      RedisModule_SubscribeToKeyspaceEvents(ctx,
305                                              REDISMODULE_NOTIFY_HASH |
306                                              REDISMODULE_NOTIFY_SET |
307                                              REDISMODULE_NOTIFY_STRING,
308                                          NotifyCallback);
309      if (RedisModule_CreateCommand(ctx,"test.notify",
310          TestNotifications,"write deny-oom",1,1,1) == REDISMODULE_ERR)
311          return REDISMODULE_ERR;
312      return REDISMODULE_OK;
313  }
</code></pre>
        </div>
        <div class="column">
            <h3>fftw3-MDEwOlJlcG9zaXRvcnk4ODQzMzg4-flat-rdft2-rdft.c</h3>
            <pre><code>1  #include "rdft/rdft.h"
2  typedef struct {
3       solver super;
4  } S;
5  typedef struct {
6       plan_rdft2 super;
7       plan *cld, *cldrest;
8       INT n, vl, nbuf, bufdist;
9       INT cs, ivs, ovs;
10  } P;
11  static void hc2c(INT n, R *r, R *rio, R *iio, INT os)
12  {
13       INT i;
14       rio[0] = r[0];
15       iio[0] = 0;
16       for (i = 1; i + i < n; ++i) {
17  	  rio[i * os] = r[i];
18  	  iio[i * os] = r[n - i];
19       }
20       if (i + i == n) {	&bsol;* store the Nyquist frequency */
21  	  rio[i * os] = r[i];
22  	  iio[i * os] = K(0.0);
23       }
24  }
25  static void c2hc(INT n, R *rio, R *iio, INT is, R *r)
26  {
27       INT i;
28       r[0] = rio[0];
29       for (i = 1; i + i < n; ++i) {
30  	  r[i] = rio[i * is];
31  	  r[n - i] = iio[i * is];
32       }
33       if (i + i == n)		&bsol;* store the Nyquist frequency */
34  	  r[i] = rio[i * is];
35  }
36  static void apply_r2hc(const plan *ego_, R *r0, R *r1, R *cr, R *ci)
37  {
38       const P *ego = (const P *) ego_;
39       plan_rdft *cld = (plan_rdft *) ego->cld;
40       INT i, j, vl = ego->vl, nbuf = ego->nbuf, bufdist = ego->bufdist;
41       INT n = ego->n;
42       INT ivs = ego->ivs, ovs = ego->ovs, os = ego->cs;
43       R *bufs = (R *)MALLOC(sizeof(R) * nbuf * bufdist, BUFFERS);
44       plan_rdft2 *cldrest;
45       for (i = nbuf; i <= vl; i += nbuf) {
46            cld->apply((plan *) cld, r0, bufs);
47  	  r0 += ivs * nbuf; r1 += ivs * nbuf;
48  	  for (j = 0; j < nbuf; ++j, cr += ovs, ci += ovs)
49  	       hc2c(n, bufs + j*bufdist, cr, ci, os);
50       }
51       X(ifree)(bufs);
52       cldrest = (plan_rdft2 *) ego->cldrest;
<span onclick='openModal()' class='match'>53       cldrest->apply((plan *) cldrest, r0, r1, cr, ci);
54  }
55  static void apply_hc2r(const plan *ego_, R *r0, R *r1, R *cr, R *ci)
</span>56  {
57       const P *ego = (const P *) ego_;
58       plan_rdft *cld = (plan_rdft *) ego->cld;
59       INT i, j, vl = ego->vl, nbuf = ego->nbuf, bufdist = ego->bufdist;
60       INT n = ego->n;
61       INT ivs = ego->ivs, ovs = ego->ovs, is = ego->cs;
62       R *bufs = (R *)MALLOC(sizeof(R) * nbuf * bufdist, BUFFERS);
63       plan_rdft2 *cldrest;
64       for (i = nbuf; i <= vl; i += nbuf) {
65  	  for (j = 0; j < nbuf; ++j, cr += ivs, ci += ivs)
66  	       c2hc(n, cr, ci, is, bufs + j*bufdist);
67            cld->apply((plan *) cld, bufs, r0);
68  	  r0 += ovs * nbuf; r1 += ovs * nbuf;
69       }
70       X(ifree)(bufs);
71       cldrest = (plan_rdft2 *) ego->cldrest;
72       cldrest->apply((plan *) cldrest, r0, r1, cr, ci);
73  }
74  static void awake(plan *ego_, enum wakefulness wakefulness)
75  {
76       P *ego = (P *) ego_;
77       X(plan_awake)(ego->cld, wakefulness);
78       X(plan_awake)(ego->cldrest, wakefulness);
79  }
80  static void destroy(plan *ego_)
81  {
82       P *ego = (P *) ego_;
83       X(plan_destroy_internal)(ego->cldrest);
84       X(plan_destroy_internal)(ego->cld);
85  }
86  static void print(const plan *ego_, printer *p)
87  {
88       const P *ego = (const P *) ego_;
89       p->print(p, "(rdft2-rdft-%s-%D%v/%D-%D%(%p%)%(%p%))",
90  	      ego->super.apply == apply_r2hc ? "r2hc" : "hc2r",
91                ego->n, ego->nbuf,
92                ego->vl, ego->bufdist % ego->n,
93                ego->cld, ego->cldrest);
94  }
95  static INT min_nbuf(const problem_rdft2 *p, INT n, INT vl)
96  {
97       INT is, os, ivs, ovs;
98       if (p->r0 != p->cr)
99  	  return 1;
100       if (X(rdft2_inplace_strides(p, RNK_MINFTY)))
101  	  return 1;
102       A(p->vecsz->rnk == 1); &bsol;*  rank 0 and MINFTY are inplace */
103       X(rdft2_strides)(p->kind, p->sz->dims, &is, &os);
104       X(rdft2_strides)(p->kind, p->vecsz->dims, &ivs, &ovs);
105       if (n * X(iabs)(is) <= X(iabs)(ivs)
106  	 && (n/2 + 1) * X(iabs)(os) <= X(iabs)(ovs)
107  	 && ( ((p->cr - p->ci) <= X(iabs)(os)) || 
108  	      ((p->ci - p->cr) <= X(iabs)(os)) )
109  	 && ivs > 0 && ovs > 0) {
110  	  INT vsmin = X(imin)(ivs, ovs);
111  	  INT vsmax = X(imax)(ivs, ovs);
112  	  return(((vsmax - vsmin) * vl + vsmin - 1) / vsmin);
113       }
114       return vl; &bsol;* punt: just buffer the whole vector */
115  }
116  static int applicable0(const problem *p_, const S *ego, const planner *plnr)
117  {
118       const problem_rdft2 *p = (const problem_rdft2 *) p_;
119       UNUSED(ego);
120       return(1
121  	    && p->vecsz->rnk <= 1
122  	    && p->sz->rnk == 1
123  	    && (p->kind == R2HC || p->kind == HC2R)
124  	    && (2 * (p->r1 - p->r0) ==
125  		(((p->kind == R2HC) ? p->sz->dims[0].is : p->sz->dims[0].os)))
126  	    && !(X(toobig)(p->sz->dims[0].n) && CONSERVE_MEMORYP(plnr))
127  	  );
128  }
129  static int applicable(const problem *p_, const S *ego, const planner *plnr)
130  {
131       const problem_rdft2 *p;
132       if (NO_BUFFERINGP(plnr)) return 0;
133       if (!applicable0(p_, ego, plnr)) return 0;
134       p = (const problem_rdft2 *) p_;
135       if (NO_UGLYP(plnr)) {
136  	  if (p->r0 != p->cr) return 0;
137  	  if (X(toobig)(p->sz->dims[0].n)) return 0;
138       }
139       return 1;
140  }
141  static plan *mkplan(const solver *ego_, const problem *p_, planner *plnr)
142  {
143       const S *ego = (const S *) ego_;
144       P *pln;
145       plan *cld = (plan *) 0;
146       plan *cldrest = (plan *) 0;
147       const problem_rdft2 *p = (const problem_rdft2 *) p_;
148       R *bufs = (R *) 0;
149       INT nbuf = 0, bufdist, n, vl;
150       INT ivs, ovs, rs, id, od;
151       static const plan_adt padt = {
152  	  X(rdft2_solve), awake, print, destroy
153       };
154       if (!applicable(p_, ego, plnr))
155            goto nada;
156       n = p->sz->dims[0].n;
157       X(tensor_tornk1)(p->vecsz, &vl, &ivs, &ovs);
158       nbuf = X(imax)(X(nbuf)(n, vl, 0), min_nbuf(p, n, vl));
159       bufdist = X(bufdist)(n, vl);
160       A(nbuf > 0);
161       bufs = (R *) MALLOC(sizeof(R) * nbuf * bufdist, BUFFERS);
162       id = ivs * (nbuf * (vl / nbuf));
163       od = ovs * (nbuf * (vl / nbuf));
164       if (p->kind == R2HC) {
165  	  cld = X(mkplan_f_d)(
166  	       plnr,
167  	       X(mkproblem_rdft_d)(
168  		    X(mktensor_1d)(n, p->sz->dims[0].is/2, 1),
169  		    X(mktensor_1d)(nbuf, ivs, bufdist),
170  		    TAINT(p->r0, ivs * nbuf), bufs, &p->kind),
171  	       0, 0, (p->r0 == p->cr) ? NO_DESTROY_INPUT : 0);
172  	  if (!cld) goto nada;
173  	  X(ifree)(bufs); bufs = 0;
174  	  cldrest = X(mkplan_d)(plnr, 
175  				X(mkproblem_rdft2_d)(
176  				     X(tensor_copy)(p->sz),
177  				     X(mktensor_1d)(vl % nbuf, ivs, ovs),
178  				     p->r0 + id, p->r1 + id, 
179  				     p->cr + od, p->ci + od,
180  				     p->kind));
181  	  if (!cldrest) goto nada;
182  	  pln = MKPLAN_RDFT2(P, &padt, apply_r2hc);
183       } else {
184  	  A(p->kind == HC2R);
185  	  cld = X(mkplan_f_d)(
186  	       plnr,
187  	       X(mkproblem_rdft_d)(
188  		    X(mktensor_1d)(n, 1, p->sz->dims[0].os/2),
189  		    X(mktensor_1d)(nbuf, bufdist, ovs),
190  		    bufs, TAINT(p->r0, ovs * nbuf), &p->kind),
191  	       0, 0, NO_DESTROY_INPUT); &bsol;* always ok to destroy bufs */
192  	  if (!cld) goto nada;
193  	  X(ifree)(bufs); bufs = 0;
194  	  cldrest = X(mkplan_d)(plnr, 
195  				X(mkproblem_rdft2_d)(
196  				     X(tensor_copy)(p->sz),
197  				     X(mktensor_1d)(vl % nbuf, ivs, ovs),
198  				     p->r0 + od, p->r1 + od, 
199  				     p->cr + id, p->ci + id,
200  				     p->kind));
201  	  if (!cldrest) goto nada;
202  	  pln = MKPLAN_RDFT2(P, &padt, apply_hc2r);
203       }
204       pln->cld = cld;
205       pln->cldrest = cldrest;
206       pln->n = n;
207       pln->vl = vl;
208       pln->ivs = ivs;
209       pln->ovs = ovs;
210       X(rdft2_strides)(p->kind, &p->sz->dims[0], &rs, &pln->cs);
211       pln->nbuf = nbuf;
212       pln->bufdist = bufdist;
213       X(ops_madd)(vl / nbuf, &cld->ops, &cldrest->ops,
214  		 &pln->super.super.ops);
215       pln->super.super.ops.other += (p->kind == R2HC ? (n + 2) : n) * vl;
216       return &(pln->super.super);
217   nada:
218       X(ifree0)(bufs);
219       X(plan_destroy_internal)(cldrest);
220       X(plan_destroy_internal)(cld);
221       return (plan *) 0;
222  }
223  static solver *mksolver(void)
224  {
225       static const solver_adt sadt = { PROBLEM_RDFT2, mkplan, 0 };
226       S *slv = MKSOLVER(S, &sadt);
227       return &(slv->super);
228  }
229  void X(rdft2_rdft_register)(planner *p)
230  {
231       REGISTER_SOLVER(p, mksolver());
232  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from redis-MDEwOlJlcG9zaXRvcnkxMDgxMTA3MDY=-flat-testmodule.c</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from fftw3-MDEwOlJlcG9zaXRvcnk4ODQzMzg4-flat-rdft2-rdft.c</div>
                </div>
                <div class="column column_space"><pre><code>207      return RedisModule_ReplyWithSimpleString(ctx, "OK");
208  }
209  int TestAssertStringReply(RedisModuleCtx *ctx, RedisModuleCallReply *reply, char *str, size_t len) {
210      RedisModuleString *mystr, *expected;
</pre></code></div>
                <div class="column column_space"><pre><code>53       cldrest->apply((plan *) cldrest, r0, r1, cr, ci);
54  }
55  static void apply_hc2r(const plan *ego_, R *r0, R *r1, R *cr, R *ci)
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    