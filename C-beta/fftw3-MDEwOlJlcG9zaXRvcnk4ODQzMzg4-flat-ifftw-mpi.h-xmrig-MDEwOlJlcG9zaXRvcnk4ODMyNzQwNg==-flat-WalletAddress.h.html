
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 14.414414414414415%, Tokens: 16, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>fftw3-MDEwOlJlcG9zaXRvcnk4ODQzMzg4-flat-ifftw-mpi.h</h3>
            <pre><code>1  #ifndef __IFFTW_MPI_H__
2  #define __IFFTW_MPI_H__
3  #include "kernel/ifftw.h"
4  #include "rdft/rdft.h"
5  #include <mpi.h>
6  #define SCRAMBLED_IN (1 << 0)
7  #define SCRAMBLED_OUT (1 << 1)
8  #define TRANSPOSED_IN (1 << 2)
9  #define TRANSPOSED_OUT (1 << 3)
10  #define RANK1_BIGVEC_ONLY (1 << 4) &bsol;* for rank=1, allow only bigvec solver */
11  #define ONLY_SCRAMBLEDP(flags) (!((flags) & ~(SCRAMBLED_IN|SCRAMBLED_OUT)))
12  #define ONLY_TRANSPOSEDP(flags) (!((flags) & ~(TRANSPOSED_IN|TRANSPOSED_OUT)))
13  #if defined(FFTW_SINGLE)
14  #  define FFTW_MPI_TYPE MPI_FLOAT
15  #elif defined(FFTW_LDOUBLE)
16  #  define FFTW_MPI_TYPE MPI_LONG_DOUBLE
17  #elif defined(FFTW_QUAD)
18  #  error MPI quad-precision type is unknown
19  #else
20  #  define FFTW_MPI_TYPE MPI_DOUBLE
21  #endif
22  #define XM(name) X(CONCAT(mpi_, name))
23  typedef enum { IB = 0, OB } block_kind;
24  typedef struct {
25       INT n;
26       INT b[2]; &bsol;* b[IB], b[OB] */
27  } ddim;
28  #define FORALL_BLOCK_KIND(k) for (k = IB; k <= OB; k = (block_kind) (((int) k) + 1))
29  typedef struct {
30       int rnk;
31  #if defined(STRUCT_HACK_KR)
32       ddim dims[1];
33  #elif defined(STRUCT_HACK_C99)
34       ddim dims[];
35  #else
36       ddim *dims;
37  #endif
38  } dtensor;
<span onclick='openModal()' class='match'>39  dtensor *XM(mkdtensor)(int rnk);
40  void XM(dtensor_destroy)(dtensor *sz);
41  dtensor *XM(dtensor_copy)(const dtensor *sz);
42  dtensor *XM(dtensor_canonical)(const dtensor *sz, int compress);
43  int XM(dtensor_validp)(const dtensor *sz);
44  void XM(dtensor_md5)(md5 *p, const dtensor *t);
45  void XM(dtensor_print)(const dtensor *t, printer *p);
</span>46  INT XM(num_blocks)(INT n, INT block);
47  int XM(num_blocks_ok)(INT n, INT block, MPI_Comm comm);
48  INT XM(default_block)(INT n, int n_pes);
49  INT XM(block)(INT n, INT block, int which_block);
50  INT XM(num_blocks_total)(const dtensor *sz, block_kind k);
51  int XM(idle_process)(const dtensor *sz, block_kind k, int which_pe);
52  void XM(block_coords)(const dtensor *sz, block_kind k, int which_pe, 
53  		     INT *coords);
54  INT XM(total_block)(const dtensor *sz, block_kind k, int which_pe);
55  int XM(is_local_after)(int dim, const dtensor *sz, block_kind k);
56  int XM(is_local)(const dtensor *sz, block_kind k);
57  int XM(is_block1d)(const dtensor *sz, block_kind k);
58  INT XM(choose_radix)(ddim d, int n_pes, unsigned flags, int sign,
59                       INT rblock[2], INT mblock[2]);
60  int XM(any_true)(int condition, MPI_Comm comm);
61  int XM(md5_equal)(md5 m, MPI_Comm comm);
62  void XM(conf_standard)(planner *p);
63  typedef enum {
64       CONTIG = 0, &bsol;* vn x 1: make subsequent DFTs contiguous */
65       DISCONTIG, &bsol;* P x (vn/P) for P processes */
66       SQUARE_BEFORE, &bsol;* try to get square transpose at beginning */
67       SQUARE_MIDDLE, &bsol;* try to get square transpose in the middle */
68       SQUARE_AFTER &bsol;* try to get square transpose at end */
69  } rearrangement;
70  #define FORALL_REARRANGE(rearrange) for (rearrange = CONTIG; rearrange <= SQUARE_MIDDLE; rearrange = (rearrangement) (((int) rearrange) + 1))
71  int XM(rearrange_applicable)(rearrangement rearrange, 
72  			     ddim dim0, INT vn, int n_pes);
73  INT XM(rearrange_ny)(rearrangement rearrange, ddim dim0, INT vn, int n_pes);
74  #endif &bsol;* __IFFTW_MPI_H__ */
</code></pre>
        </div>
        <div class="column">
            <h3>xmrig-MDEwOlJlcG9zaXRvcnk4ODMyNzQwNg==-flat-WalletAddress.h</h3>
            <pre><code>1  #ifndef XMRIG_WALLETADDRESS_H
2  #define XMRIG_WALLETADDRESS_H
3  #include "base/tools/String.h"
4  #include "base/crypto/Coin.h"
5  namespace xmrig {
6  class WalletAddress
7  {
8  public:
9      enum Net : uint32_t {
10          MAINNET,
11          TESTNET,
12          STAGENET
13      };
14      enum Type : uint32_t {
15          PUBLIC,
16          INTEGRATED,
17          SUBADDRESS
18      };
19      constexpr static size_t kKeySize        = 32;
20      constexpr static size_t kMaxSize        = 256;
21      constexpr static size_t kMinDataSize    = 69;
22      constexpr static size_t kMinSize        = 95;
23      WalletAddress() = default;
24      inline WalletAddress(const char *address, size_t size)  { decode(address, size); }
25      inline WalletAddress(const char *address)               { decode(address); }
26      inline WalletAddress(const rapidjson::Value &address)   { decode(address); }
27      inline WalletAddress(const String &address)             { decode(address); }
28      inline bool decode(const char *address)                 { return decode(address, strlen(address)); }
29      inline bool decode(const String &address)               { return decode(address, address.size()); }
30      inline bool isValid() const                             { return m_tag > 0 && m_data.size() >= kMinSize; }
31      inline const char *data() const                         { return m_data; }
32      inline const Coin &coin() const                         { return tagInfo(m_tag).coin; }
33      inline const uint8_t *spendKey() const                  { return m_publicSpendKey; }
34      inline const uint8_t *viewKey() const                   { return m_publicViewKey; }
35      inline Net net() const                                  { return tagInfo(m_tag).net; }
36      inline Type type() const                                { return tagInfo(m_tag).type; }
37      inline uint16_t rpcPort() const                         { return tagInfo(m_tag).rpcPort; }
38      inline uint16_t zmqPort() const                         { return tagInfo(m_tag).zmqPort; }
39      inline uint64_t tag() const                             { return m_tag; }
<span onclick='openModal()' class='match'>40      bool decode(const char *address, size_t size);
41      bool decode(const rapidjson::Value &address);
42      const char *netName() const;
43      const char *typeName() const;
44      rapidjson::Value toJSON(rapidjson::Document &doc) const;
45  #   ifdef XMRIG_FEATURE_API
46      rapidjson::Value toAPI(rapidjson::Document &doc) const;
</span>47  #   endif
48  private:
49      struct TagInfo
50      {
51          const Coin coin;
52          const Net net;
53          const Type type;
54          const uint16_t rpcPort;
55          const uint16_t zmqPort;
56      };
57      static const TagInfo &tagInfo(uint64_t tag);
58      String m_data;
59      uint64_t m_tag  = 0;
60      uint8_t m_checksum[4]{};
61      uint8_t m_publicSpendKey[kKeySize]{};
62      uint8_t m_publicViewKey[kKeySize]{};
63  };
64  } &bsol;* namespace xmrig */
65  #endif &bsol;* XMRIG_WALLETADDRESS_H */
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from fftw3-MDEwOlJlcG9zaXRvcnk4ODQzMzg4-flat-ifftw-mpi.h</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from xmrig-MDEwOlJlcG9zaXRvcnk4ODMyNzQwNg==-flat-WalletAddress.h</div>
                </div>
                <div class="column column_space"><pre><code>39  dtensor *XM(mkdtensor)(int rnk);
40  void XM(dtensor_destroy)(dtensor *sz);
41  dtensor *XM(dtensor_copy)(const dtensor *sz);
42  dtensor *XM(dtensor_canonical)(const dtensor *sz, int compress);
43  int XM(dtensor_validp)(const dtensor *sz);
44  void XM(dtensor_md5)(md5 *p, const dtensor *t);
45  void XM(dtensor_print)(const dtensor *t, printer *p);
</pre></code></div>
                <div class="column column_space"><pre><code>40      bool decode(const char *address, size_t size);
41      bool decode(const rapidjson::Value &address);
42      const char *netName() const;
43      const char *typeName() const;
44      rapidjson::Value toJSON(rapidjson::Document &doc) const;
45  #   ifdef XMRIG_FEATURE_API
46      rapidjson::Value toAPI(rapidjson::Document &doc) const;
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    