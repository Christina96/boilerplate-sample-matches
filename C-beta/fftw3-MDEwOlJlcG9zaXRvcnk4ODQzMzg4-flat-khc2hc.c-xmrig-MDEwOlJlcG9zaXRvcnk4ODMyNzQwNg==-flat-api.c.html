
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 5.172413793103448%, Tokens: 9, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>fftw3-MDEwOlJlcG9zaXRvcnk4ODQzMzg4-flat-khc2hc.c</h3>
            <pre><code>1  #include "rdft/hc2hc.h"
<span onclick='openModal()' class='match'>2  void X(khc2hc_register)(planner *p, khc2hc codelet, const hc2hc_desc *desc)
3  {
4       X(regsolver_hc2hc_direct)(p, codelet, desc);
</span>5  }
</code></pre>
        </div>
        <div class="column">
            <h3>xmrig-MDEwOlJlcG9zaXRvcnk4ODMyNzQwNg==-flat-api.c</h3>
            <pre><code>1  #include <stdlib.h>
2  #include <stdio.h>
3  #include <string.h>
4  #include "llhttp.h"
5  #define CALLBACK_MAYBE(PARSER, NAME, ...)                                     \
6    do {                                                                        \
7      const llhttp_settings_t* settings;                                        \
8      settings = (const llhttp_settings_t*) (PARSER)->settings;                 \
9      if (settings == NULL || settings->NAME == NULL) {                         \
10        err = 0;                                                                \
11        break;                                                                  \
12      }                                                                         \
13      err = settings->NAME(__VA_ARGS__);                                        \
14    } while (0)
15  void llhttp_init(llhttp_t* parser, llhttp_type_t type,
16                   const llhttp_settings_t* settings) {
17    llhttp__internal_init(parser);
18    parser->type = type;
19    parser->settings = (void*) settings;
20  }
21  #if defined(__wasm__)
22  extern int wasm_on_message_begin(llhttp_t * p);
23  extern int wasm_on_url(llhttp_t* p, const char* at, size_t length);
24  extern int wasm_on_status(llhttp_t* p, const char* at, size_t length);
25  extern int wasm_on_header_field(llhttp_t* p, const char* at, size_t length);
26  extern int wasm_on_header_value(llhttp_t* p, const char* at, size_t length);
27  extern int wasm_on_headers_complete(llhttp_t * p);
28  extern int wasm_on_body(llhttp_t* p, const char* at, size_t length);
29  extern int wasm_on_message_complete(llhttp_t * p);
30  const llhttp_settings_t wasm_settings = {
31    wasm_on_message_begin,
32    wasm_on_url,
33    wasm_on_status,
34    wasm_on_header_field,
35    wasm_on_header_value,
36    wasm_on_headers_complete,
37    wasm_on_body,
38    wasm_on_message_complete,
39    NULL,
40    NULL,
41  };
42  llhttp_t* llhttp_alloc(llhttp_type_t type) {
43    llhttp_t* parser = malloc(sizeof(llhttp_t));
44    llhttp_init(parser, type, &wasm_settings);
45    return parser;
46  }
47  void llhttp_free(llhttp_t* parser) {
48    free(parser);
49  }
50  uint8_t llhttp_get_type(llhttp_t* parser) {
51    return parser->type;
52  }
53  uint8_t llhttp_get_http_major(llhttp_t* parser) {
54    return parser->http_major;
55  }
56  uint8_t llhttp_get_http_minor(llhttp_t* parser) {
57    return parser->http_minor;
58  }
59  uint8_t llhttp_get_method(llhttp_t* parser) {
60    return parser->method;
61  }
62  int llhttp_get_status_code(llhttp_t* parser) {
63    return parser->status_code;
64  }
65  uint8_t llhttp_get_upgrade(llhttp_t* parser) {
66    return parser->upgrade;
67  }
68  #endif  
69  void llhttp_reset(llhttp_t* parser) {
70    llhttp_type_t type = parser->type;
71    const llhttp_settings_t* settings = parser->settings;
72    void* data = parser->data;
73    uint8_t lenient_flags = parser->lenient_flags;
74    llhttp__internal_init(parser);
75    parser->type = type;
76    parser->settings = (void*) settings;
77    parser->data = data;
78    parser->lenient_flags = lenient_flags;
79  }
80  llhttp_errno_t llhttp_execute(llhttp_t* parser, const char* data, size_t len) {
81    return llhttp__internal_execute(parser, data, data + len);
82  }
83  void llhttp_settings_init(llhttp_settings_t* settings) {
84    memset(settings, 0, sizeof(*settings));
85  }
86  llhttp_errno_t llhttp_finish(llhttp_t* parser) {
87    int err;
88    if (parser->error != 0) {
89      return 0;
90    }
91    switch (parser->finish) {
92      case HTTP_FINISH_SAFE_WITH_CB:
93        CALLBACK_MAYBE(parser, on_message_complete, parser);
94        if (err != HPE_OK) return err;
95      case HTTP_FINISH_SAFE:
96        return HPE_OK;
97      case HTTP_FINISH_UNSAFE:
98        parser->reason = "Invalid EOF state";
99        return HPE_INVALID_EOF_STATE;
100      default:
101        abort();
102    }
103  }
104  void llhttp_pause(llhttp_t* parser) {
105    if (parser->error != HPE_OK) {
106      return;
107    }
108    parser->error = HPE_PAUSED;
109    parser->reason = "Paused";
110  }
111  void llhttp_resume(llhttp_t* parser) {
112    if (parser->error != HPE_PAUSED) {
113      return;
114    }
115    parser->error = 0;
116  }
117  void llhttp_resume_after_upgrade(llhttp_t* parser) {
118    if (parser->error != HPE_PAUSED_UPGRADE) {
119      return;
120    }
121    parser->error = 0;
122  }
123  llhttp_errno_t llhttp_get_errno(const llhttp_t* parser) {
124    return parser->error;
125  }
126  const char* llhttp_get_error_reason(const llhttp_t* parser) {
127    return parser->reason;
128  }
129  void llhttp_set_error_reason(llhttp_t* parser, const char* reason) {
130    parser->reason = reason;
131  }
132  const char* llhttp_get_error_pos(const llhttp_t* parser) {
133    return parser->error_pos;
134  }
135  const char* llhttp_errno_name(llhttp_errno_t err) {
136  #define HTTP_ERRNO_GEN(CODE, NAME, _) case HPE_##NAME: return "HPE_" #NAME;
137    switch (err) {
138      HTTP_ERRNO_MAP(HTTP_ERRNO_GEN)
139      default: abort();
140    }
141  #undef HTTP_ERRNO_GEN
142  }
143  const char* llhttp_method_name(llhttp_method_t method) {
144  #define HTTP_METHOD_GEN(NUM, NAME, STRING) case HTTP_##NAME: return #STRING;
145    switch (method) {
146      HTTP_METHOD_MAP(HTTP_METHOD_GEN)
147      default: abort();
148    }
149  #undef HTTP_METHOD_GEN
150  }
151  void llhttp_set_lenient_headers(llhttp_t* parser, int enabled) {
152    if (enabled) {
153      parser->lenient_flags |= LENIENT_HEADERS;
154    } else {
155      parser->lenient_flags &= ~LENIENT_HEADERS;
156    }
157  }
158  void llhttp_set_lenient_chunked_length(llhttp_t* parser, int enabled) {
159    if (enabled) {
160      parser->lenient_flags |= LENIENT_CHUNKED_LENGTH;
161    } else {
162      parser->lenient_flags &= ~LENIENT_CHUNKED_LENGTH;
163    }
164  }
165  void llhttp_set_lenient_keep_alive(llhttp_t* parser, int enabled) {
166    if (enabled) {
167      parser->lenient_flags |= LENIENT_KEEP_ALIVE;
168    } else {
169      parser->lenient_flags &= ~LENIENT_KEEP_ALIVE;
170    }
171  }
<span onclick='openModal()' class='match'>172  int llhttp__on_message_begin(llhttp_t* s, const char* p, const char* endp) {
173    int err;
174    CALLBACK_MAYBE(s, on_message_begin, s);
</span>175    return err;
176  }
177  int llhttp__on_url(llhttp_t* s, const char* p, const char* endp) {
178    int err;
179    CALLBACK_MAYBE(s, on_url, s, p, endp - p);
180    return err;
181  }
182  int llhttp__on_url_complete(llhttp_t* s, const char* p, const char* endp) {
183    int err;
184    CALLBACK_MAYBE(s, on_url_complete, s);
185    return err;
186  }
187  int llhttp__on_status(llhttp_t* s, const char* p, const char* endp) {
188    int err;
189    CALLBACK_MAYBE(s, on_status, s, p, endp - p);
190    return err;
191  }
192  int llhttp__on_status_complete(llhttp_t* s, const char* p, const char* endp) {
193    int err;
194    CALLBACK_MAYBE(s, on_status_complete, s);
195    return err;
196  }
197  int llhttp__on_header_field(llhttp_t* s, const char* p, const char* endp) {
198    int err;
199    CALLBACK_MAYBE(s, on_header_field, s, p, endp - p);
200    return err;
201  }
202  int llhttp__on_header_field_complete(llhttp_t* s, const char* p, const char* endp) {
203    int err;
204    CALLBACK_MAYBE(s, on_header_field_complete, s);
205    return err;
206  }
207  int llhttp__on_header_value(llhttp_t* s, const char* p, const char* endp) {
208    int err;
209    CALLBACK_MAYBE(s, on_header_value, s, p, endp - p);
210    return err;
211  }
212  int llhttp__on_header_value_complete(llhttp_t* s, const char* p, const char* endp) {
213    int err;
214    CALLBACK_MAYBE(s, on_header_value_complete, s);
215    return err;
216  }
217  int llhttp__on_headers_complete(llhttp_t* s, const char* p, const char* endp) {
218    int err;
219    CALLBACK_MAYBE(s, on_headers_complete, s);
220    return err;
221  }
222  int llhttp__on_message_complete(llhttp_t* s, const char* p, const char* endp) {
223    int err;
224    CALLBACK_MAYBE(s, on_message_complete, s);
225    return err;
226  }
227  int llhttp__on_body(llhttp_t* s, const char* p, const char* endp) {
228    int err;
229    CALLBACK_MAYBE(s, on_body, s, p, endp - p);
230    return err;
231  }
232  int llhttp__on_chunk_header(llhttp_t* s, const char* p, const char* endp) {
233    int err;
234    CALLBACK_MAYBE(s, on_chunk_header, s);
235    return err;
236  }
237  int llhttp__on_chunk_complete(llhttp_t* s, const char* p, const char* endp) {
238    int err;
239    CALLBACK_MAYBE(s, on_chunk_complete, s);
240    return err;
241  }
242  void llhttp__debug(llhttp_t* s, const char* p, const char* endp,
243                     const char* msg) {
244    if (p == endp) {
245      fprintf(stderr, "p=%p type=%d flags=%02x next=null debug=%s\n", s, s->type,
246              s->flags, msg);
247    } else {
248      fprintf(stderr, "p=%p type=%d flags=%02x next=%02x   debug=%s\n", s,
249              s->type, s->flags, *p, msg);
250    }
251  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from fftw3-MDEwOlJlcG9zaXRvcnk4ODQzMzg4-flat-khc2hc.c</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from xmrig-MDEwOlJlcG9zaXRvcnk4ODMyNzQwNg==-flat-api.c</div>
                </div>
                <div class="column column_space"><pre><code>2  void X(khc2hc_register)(planner *p, khc2hc codelet, const hc2hc_desc *desc)
3  {
4       X(regsolver_hc2hc_direct)(p, codelet, desc);
</pre></code></div>
                <div class="column column_space"><pre><code>172  int llhttp__on_message_begin(llhttp_t* s, const char* p, const char* endp) {
173    int err;
174    CALLBACK_MAYBE(s, on_message_begin, s);
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    