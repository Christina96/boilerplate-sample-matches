
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 9.746328437917223%, Tokens: 9, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>PINRemoteImage-MDEwOlJlcG9zaXRvcnkzOTUzNzEwMw==-flat-tiffdec.c</h3>
            <pre><code>1  #include "./tiffdec.h"
2  #ifdef HAVE_CONFIG_H
3  #include "webp/config.h"
4  #endif
5  #include <limits.h>
6  #include <stdio.h>
7  #include <string.h>
8  #ifdef WEBP_HAVE_TIFF
9  #include <tiffio.h>
10  #include "webp/encode.h"
11  #include "./imageio_util.h"
12  #include "./metadata.h"
13  static const struct {
14    ttag_t tag;
15    size_t storage_offset;
16  } kTIFFMetadataMap[] = {
17    { TIFFTAG_ICCPROFILE, METADATA_OFFSET(iccp) },
18    { TIFFTAG_XMLPACKET,  METADATA_OFFSET(xmp) },
19    { 0, 0 },
20  };
21  static int ExtractMetadataFromTIFF(TIFF* const tif, Metadata* const metadata) {
22    int i;
23    toff_t exif_ifd_offset;
24    for (i = 0; kTIFFMetadataMap[i].tag != 0; ++i) {
25      MetadataPayload* const payload =
26          (MetadataPayload*)((uint8_t*)metadata +
27                             kTIFFMetadataMap[i].storage_offset);
28      void* tag_data;
29      uint32 tag_data_len;
30      if (TIFFGetField(tif, kTIFFMetadataMap[i].tag, &tag_data_len, &tag_data) &&
31          !MetadataCopy((const char*)tag_data, tag_data_len, payload)) {
32        return 0;
33      }
34    }
35    if (TIFFGetField(tif, TIFFTAG_EXIFIFD, &exif_ifd_offset)) {
36      fprintf(stderr, "Warning: EXIF extraction from TIFF is unsupported.\n");
37    }
38    return 1;
39  }
40  typedef struct {
41    const uint8_t* data;
42    toff_t size;
43    toff_t pos;
44  } MyData;
45  static int MyClose(thandle_t opaque) {
46    (void)opaque;
47    return 0;
48  }
49  static toff_t MySize(thandle_t opaque) {
<span onclick='openModal()' class='match'>50    const MyData* const my_data = (MyData*)opaque;
51    return my_data->size;
52  }
53  static toff_t MySeek(thandle_t opaque, toff_t offset, int whence) {
54    MyData* const my_data = (MyData*)opaque;
</span>55    offset += (whence == SEEK_CUR) ? my_data->pos
56            : (whence == SEEK_SET) ? 0
57            : my_data->size;
58    if (offset > my_data->size) return (toff_t)-1;
59    my_data->pos = offset;
60    return offset;
61  }
62  static int MyMapFile(thandle_t opaque, void** base, toff_t* size) {
63    (void)opaque;
64    (void)base;
65    (void)size;
66    return 0;
67  }
68  static void MyUnmapFile(thandle_t opaque, void* base, toff_t size) {
69    (void)opaque;
70    (void)base;
71    (void)size;
72  }
73  static tsize_t MyRead(thandle_t opaque, void* dst, tsize_t size) {
74    MyData* const my_data = (MyData*)opaque;
75    if (my_data->pos + size > my_data->size) {
76      size = (tsize_t)(my_data->size - my_data->pos);
77    }
78    if (size > 0) {
79      memcpy(dst, my_data->data + my_data->pos, size);
80      my_data->pos += size;
81    }
82    return size;
83  }
84  #define MFIX 24    
85  #define HALF ((1u << MFIX) >> 1)
86  static uint32_t Unmult(uint8_t x, uint32_t mult) {
87    const uint32_t v = (x * mult + HALF) >> MFIX;
88    return (v > 255u) ? 255u : v;
89  }
90  static WEBP_INLINE uint32_t GetScale(uint32_t a) {
91    return (255u << MFIX) / a;
92  }
93  #undef MFIX
94  #undef HALF
95  static void MultARGBRow(uint8_t* ptr, int width) {
96    int x;
97    for (x = 0; x < width; ++x, ptr += 4) {
98      const uint32_t alpha = ptr[3];
99      if (alpha < 255) {
100        if (alpha == 0) {   
101          ptr[0] = ptr[1] = ptr[2] = 0;
102        } else {
103          const uint32_t scale = GetScale(alpha);
104          ptr[0] = Unmult(ptr[0], scale);
105          ptr[1] = Unmult(ptr[1], scale);
106          ptr[2] = Unmult(ptr[2], scale);
107        }
108      }
109    }
110  }
111  int ReadTIFF(const uint8_t* const data, size_t data_size,
112               WebPPicture* const pic, int keep_alpha,
113               Metadata* const metadata) {
114    MyData my_data = { data, (toff_t)data_size, 0 };
115    TIFF* tif;
116    uint32_t image_width, image_height, tile_width, tile_height;
117    uint16_t samples_per_px = 0;
118    uint16_t extra_samples = 0;
119    uint16_t* extra_samples_ptr = NULL;
120    uint32_t* raster;
121    int64_t alloc_size;
122    int ok = 0;
123    tdir_t dircount;
124    if (data == NULL || data_size == 0 || data_size > INT_MAX || pic == NULL) {
125      return 0;
126    }
127    tif = TIFFClientOpen("Memory", "r", &my_data,
128                         MyRead, MyRead, MySeek, MyClose,
129                         MySize, MyMapFile, MyUnmapFile);
130    if (tif == NULL) {
131      fprintf(stderr, "Error! Cannot parse TIFF file\n");
132      return 0;
133    }
134    dircount = TIFFNumberOfDirectories(tif);
135    if (dircount > 1) {
136      fprintf(stderr, "Warning: multi-directory TIFF files are not supported.\n"
137                      "Only the first will be used, %d will be ignored.\n",
138                      dircount - 1);
139    }
140    if (!TIFFGetFieldDefaulted(tif, TIFFTAG_SAMPLESPERPIXEL, &samples_per_px)) {
141      fprintf(stderr, "Error! Cannot retrieve TIFF samples-per-pixel info.\n");
142      goto End;
143    }
144    if (samples_per_px < 3 || samples_per_px > 4) goto End;  
145    if (!(TIFFGetField(tif, TIFFTAG_IMAGEWIDTH, &image_width) &&
146          TIFFGetField(tif, TIFFTAG_IMAGELENGTH, &image_height))) {
147      fprintf(stderr, "Error! Cannot retrieve TIFF image dimensions.\n");
148      goto End;
149    }
150    if (!ImgIoUtilCheckSizeArgumentsOverflow((uint64_t)image_width * image_height,
151                                             sizeof(*raster))) {
152      goto End;
153    }
154    if ((TIFFGetField(tif, TIFFTAG_TILEWIDTH, &tile_width) &&
155         tile_width > 32 && tile_width / 2 > image_width) ||
156        (TIFFGetField(tif, TIFFTAG_TILELENGTH, &tile_height) &&
157         tile_height > 32 && tile_height / 2 > image_height)) {
158      fprintf(stderr, "Error! TIFF tile dimensions are too big.\n");
159      goto End;
160    }
161    if (samples_per_px > 3 && !TIFFGetField(tif, TIFFTAG_EXTRASAMPLES,
162                                            &extra_samples, &extra_samples_ptr)) {
163      fprintf(stderr, "Error! Cannot retrieve TIFF ExtraSamples info.\n");
164      goto End;
165    }
166    alloc_size =
167        (int64_t)((uint64_t)image_width * image_height * sizeof(*raster));
168    if (alloc_size < 0 || alloc_size != (tsize_t)alloc_size) goto End;
169    raster = (uint32*)_TIFFmalloc((tsize_t)alloc_size);
170    if (raster != NULL) {
171      if (TIFFReadRGBAImageOriented(tif, image_width, image_height, raster,
172                                    ORIENTATION_TOPLEFT, 1)) {
173        const int stride = image_width * sizeof(*raster);
174        pic->width = image_width;
175        pic->height = image_height;
176  #ifdef WORDS_BIGENDIAN
177        TIFFSwabArrayOfLong(raster, image_width * image_height);
178  #endif
179        if (extra_samples == 1 && extra_samples_ptr != NULL &&
180            extra_samples_ptr[0] == EXTRASAMPLE_ASSOCALPHA) {
181          uint32_t y;
182          uint8_t* tmp = (uint8_t*)raster;
183          for (y = 0; y < image_height; ++y) {
184            MultARGBRow(tmp, image_width);
185            tmp += stride;
186          }
187        }
188        ok = keep_alpha
189           ? WebPPictureImportRGBA(pic, (const uint8_t*)raster, stride)
190           : WebPPictureImportRGBX(pic, (const uint8_t*)raster, stride);
191      }
192      _TIFFfree(raster);
193    } else {
194      fprintf(stderr, "Error allocating TIFF RGBA memory!\n");
195    }
196    if (ok) {
197      if (metadata != NULL) {
198        ok = ExtractMetadataFromTIFF(tif, metadata);
199        if (!ok) {
200          fprintf(stderr, "Error extracting TIFF metadata!\n");
201          MetadataFree(metadata);
202          WebPPictureFree(pic);
203        }
204      }
205    }
206   End:
207    TIFFClose(tif);
208    return ok;
209  }
210  #else  
211  int ReadTIFF(const uint8_t* const data, size_t data_size,
212               struct WebPPicture* const pic, int keep_alpha,
213               struct Metadata* const metadata) {
214    (void)data;
215    (void)data_size;
216    (void)pic;
217    (void)keep_alpha;
218    (void)metadata;
219    fprintf(stderr, "TIFF support not compiled. Please install the libtiff "
220            "development package before building.\n");
221    return 0;
222  }
223  #endif  
</code></pre>
        </div>
        <div class="column">
            <h3>redis-MDEwOlJlcG9zaXRvcnkxMDgxMTA3MDY=-flat-bitops.c</h3>
            <pre><code>1  #include "server.h"
2  size_t redisPopcount(void *s, PORT_LONG count) {
3      size_t bits = 0;
4      unsigned char *p = s;
5      uint32_t *p4;
6      static const unsigned char bitsinbyte[256] = {0,1,1,2,1,2,2,3,1,2,2,3,2,3,3,4,1,2,2,3,2,3,3,4,2,3,3,4,3,4,4,5,1,2,2,3,2,3,3,4,2,3,3,4,3,4,4,5,2,3,3,4,3,4,4,5,3,4,4,5,4,5,5,6,1,2,2,3,2,3,3,4,2,3,3,4,3,4,4,5,2,3,3,4,3,4,4,5,3,4,4,5,4,5,5,6,2,3,3,4,3,4,4,5,3,4,4,5,4,5,5,6,3,4,4,5,4,5,5,6,4,5,5,6,5,6,6,7,1,2,2,3,2,3,3,4,2,3,3,4,3,4,4,5,2,3,3,4,3,4,4,5,3,4,4,5,4,5,5,6,2,3,3,4,3,4,4,5,3,4,4,5,4,5,5,6,3,4,4,5,4,5,5,6,4,5,5,6,5,6,6,7,2,3,3,4,3,4,4,5,3,4,4,5,4,5,5,6,3,4,4,5,4,5,5,6,4,5,5,6,5,6,6,7,3,4,4,5,4,5,5,6,4,5,5,6,5,6,6,7,4,5,5,6,5,6,6,7,5,6,6,7,6,7,7,8};
7      while((PORT_ULONG)p & 3 && count) {
8          bits += bitsinbyte[*p++];
9          count--;
10      }
11      p4 = (uint32_t*)p;
12      while(count>=28) {
13          uint32_t aux1, aux2, aux3, aux4, aux5, aux6, aux7;
14          aux1 = *p4++;
15          aux2 = *p4++;
16          aux3 = *p4++;
17          aux4 = *p4++;
18          aux5 = *p4++;
19          aux6 = *p4++;
20          aux7 = *p4++;
21          count -= 28;
22          aux1 = aux1 - ((aux1 >> 1) & 0x55555555);
23          aux1 = (aux1 & 0x33333333) + ((aux1 >> 2) & 0x33333333);
24          aux2 = aux2 - ((aux2 >> 1) & 0x55555555);
25          aux2 = (aux2 & 0x33333333) + ((aux2 >> 2) & 0x33333333);
26          aux3 = aux3 - ((aux3 >> 1) & 0x55555555);
27          aux3 = (aux3 & 0x33333333) + ((aux3 >> 2) & 0x33333333);
28          aux4 = aux4 - ((aux4 >> 1) & 0x55555555);
29          aux4 = (aux4 & 0x33333333) + ((aux4 >> 2) & 0x33333333);
30          aux5 = aux5 - ((aux5 >> 1) & 0x55555555);
31          aux5 = (aux5 & 0x33333333) + ((aux5 >> 2) & 0x33333333);
32          aux6 = aux6 - ((aux6 >> 1) & 0x55555555);
33          aux6 = (aux6 & 0x33333333) + ((aux6 >> 2) & 0x33333333);
34          aux7 = aux7 - ((aux7 >> 1) & 0x55555555);
35          aux7 = (aux7 & 0x33333333) + ((aux7 >> 2) & 0x33333333);
36          bits += ((((aux1 + (aux1 >> 4)) & 0x0F0F0F0F) +
37                      ((aux2 + (aux2 >> 4)) & 0x0F0F0F0F) +
38                      ((aux3 + (aux3 >> 4)) & 0x0F0F0F0F) +
39                      ((aux4 + (aux4 >> 4)) & 0x0F0F0F0F) +
40                      ((aux5 + (aux5 >> 4)) & 0x0F0F0F0F) +
41                      ((aux6 + (aux6 >> 4)) & 0x0F0F0F0F) +
42                      ((aux7 + (aux7 >> 4)) & 0x0F0F0F0F))* 0x01010101) >> 24;
43      }
44      p = (unsigned char*)p4;
45      while(count--) bits += bitsinbyte[*p++];
46      return bits;
47  }
48  PORT_LONG redisBitpos(void *s, PORT_ULONG count, int bit) {
49      PORT_ULONG *l;
50      unsigned char *c;
51      PORT_ULONG skipval, word = 0, one;
52      PORT_LONG pos = 0; &bsol;* Position of bit, to return to the caller. */
53      PORT_ULONG j;
54      int found;
55      skipval = bit ? 0 : UCHAR_MAX;
56      c = (unsigned char*) s;
57      found = 0;
58      while((PORT_ULONG)c & (sizeof(*l)-1) && count) {
59          if (*c != skipval) {
60              found = 1;
61              break;
62          }
63          c++;
64          count--;
65          pos += 8;
66      }
67      l = (PORT_ULONG*) c;
68      if (!found) {
69          skipval = bit ? 0 : PORT_ULONG_MAX;
70          while (count >= sizeof(*l)) {
71              if (*l != skipval) break;
72              l++;
73              count -= sizeof(*l);
74              pos += sizeof(*l)*8;
75          }
76      }
77      c = (unsigned char*)l;
78      for (j = 0; j < sizeof(*l); j++) {
79          word <<= 8;
80          if (count) {
81              word |= *c;
82              c++;
83              count--;
84          }
85      }
86      if (bit == 1 && word == 0) return -1;
87      one = PORT_ULONG_MAX; &bsol;* All bits set to 1.*/
88      one >>= 1;       &bsol;* All bits set to 1 but the MSB. */
89      one = ~one;      &bsol;* All bits set to 0 but the MSB. */
90      while(one) {
91          if (((one & word) != 0) == bit) return pos;
92          pos++;
93          one >>= 1;
94      }
95      serverPanic("End of redisBitpos() reached.");
96      return 0; &bsol;* Just to avoid warnings. */
97  }
98  void setUnsignedBitfield(unsigned char *p, uint64_t offset, uint64_t bits, uint64_t value) {
99      uint64_t byte, bit, byteval, bitval, j;
100      for (j = 0; j < bits; j++) {
101          bitval = (value & ((uint64_t)1<<(bits-1-j))) != 0;
102          byte = offset >> 3;
103          bit = 7 - (offset & 0x7);
104          byteval = p[byte];
105          byteval &= ~(1 << bit);
106          byteval |= bitval << bit;
107          p[byte] = byteval & 0xff;
108          offset++;
109      }
110  }
111  void setSignedBitfield(unsigned char *p, uint64_t offset, uint64_t bits, int64_t value) {
112      uint64_t uv = value; &bsol;* Casting will add UINT64_MAX + 1 if v is negative. */
113      setUnsignedBitfield(p,offset,bits,uv);
114  }
115  uint64_t getUnsignedBitfield(unsigned char *p, uint64_t offset, uint64_t bits) {
116      uint64_t byte, bit, byteval, bitval, j, value = 0;
117      for (j = 0; j < bits; j++) {
118          byte = offset >> 3;
119          bit = 7 - (offset & 0x7);
120          byteval = p[byte];
121          bitval = (byteval >> bit) & 1;
122          value = (value<<1) | bitval;
123          offset++;
124      }
125      return value;
126  }
127  int64_t getSignedBitfield(unsigned char *p, uint64_t offset, uint64_t bits) {
128      int64_t value;
129      union {uint64_t u; int64_t i;} conv;
130      conv.u = getUnsignedBitfield(p,offset,bits);
131      value = conv.i;
132      if (value & ((uint64_t)1 << (bits-1)))
133          value |= ((uint64_t)-1) << bits;
134      return value;
135  }
136  #define BFOVERFLOW_WRAP 0
137  #define BFOVERFLOW_SAT 1
138  #define BFOVERFLOW_FAIL 2 &bsol;* Used by the BITFIELD command implementation. */
139  int checkUnsignedBitfieldOverflow(uint64_t value, int64_t incr, uint64_t bits, int owtype, uint64_t *limit) {
140      uint64_t max = (bits == 64) ? UINT64_MAX : (((uint64_t)1<<bits)-1);
141      int64_t maxincr = max-value;
142      int64_t minincr = -value;
143      if (value > max || (incr > 0 && incr > maxincr)) {
144          if (limit) {
145              if (owtype == BFOVERFLOW_WRAP) {
146                  goto handle_wrap;
147              } else if (owtype == BFOVERFLOW_SAT) {
148                  *limit = max;
149              }
150          }
151          return 1;
152      } else if (incr < 0 && incr < minincr) {
153          if (limit) {
154              if (owtype == BFOVERFLOW_WRAP) {
155                  goto handle_wrap;
156              } else if (owtype == BFOVERFLOW_SAT) {
157                  *limit = 0;
158              }
159          }
160          return -1;
161      }
162      return 0;
163  handle_wrap:
164      {
165          uint64_t mask = ((uint64_t)-1) << bits;
166          uint64_t res = value+incr;
167          res &= ~mask;
168          *limit = res;
169      }
170      return 1;
171  }
172  int checkSignedBitfieldOverflow(int64_t value, int64_t incr, uint64_t bits, int owtype, int64_t *limit) {
173      int64_t max = (bits == 64) ? INT64_MAX : (((int64_t)1<<(bits-1))-1);
174      int64_t min = (-max)-1;
175      int64_t maxincr = max-value;
176      int64_t minincr = min-value;
177      if (value > max || (bits != 64 && incr > maxincr) || (value >= 0 && incr > 0 && incr > maxincr))
178      {
179          if (limit) {
180              if (owtype == BFOVERFLOW_WRAP) {
181                  goto handle_wrap;
182              } else if (owtype == BFOVERFLOW_SAT) {
183                  *limit = max;
184              }
185          }
186          return 1;
187      } else if (value < min || (bits != 64 && incr < minincr) || (value < 0 && incr < 0 && incr < minincr)) {
188          if (limit) {
189              if (owtype == BFOVERFLOW_WRAP) {
190                  goto handle_wrap;
191              } else if (owtype == BFOVERFLOW_SAT) {
192                  *limit = min;
193              }
194          }
195          return -1;
196      }
197      return 0;
198  handle_wrap:
199      {
200          uint64_t mask = ((uint64_t)-1) << bits;
201          uint64_t msb = (uint64_t)1 << (bits-1);
202          uint64_t a = value, b = incr, c;
203          c = a+b; &bsol;* Perform addition as unsigned so that's defined. */
204          if (c & msb) {
205              c |= mask;
206          } else {
207              c &= ~mask;
208          }
209          *limit = c;
210      }
211      return 1;
212  }
213  void printBits(unsigned char *p, PORT_ULONG count) {
214      PORT_ULONG j, i, byte;
215      for (j = 0; j < count; j++) {
216          byte = p[j];
217          for (i = 0x80; i > 0; i /= 2)
218              printf("%c", (byte & i) ? '1' : '0');
219          printf("|");
220      }
221      printf("\n");
222  }
223  #define BITOP_AND   0
224  #define BITOP_OR    1
225  #define BITOP_XOR   2
226  #define BITOP_NOT   3
227  #define BITFIELDOP_GET 0
228  #define BITFIELDOP_SET 1
229  #define BITFIELDOP_INCRBY 2
230  int getBitOffsetFromArgument(client *c, robj *o, size_t *offset, int hash, int bits) {
231      PORT_LONGLONG loffset;
232      char *err = "bit offset is not an integer or out of range";
233      char *p = o->ptr;
234      size_t plen = sdslen(p);
235      int usehash = 0;
236      if (p[0] == '#' && hash && bits > 0) usehash = 1;
237      if (string2ll(p+usehash,plen-usehash,&loffset) == 0) {
238          addReplyError(c,err);
239          return C_ERR;
240      }
241      if (usehash) loffset *= bits;
242      if ((loffset < 0) || ((PORT_ULONGLONG)loffset >> 3) >= (512*1024*1024))
243      {
244          addReplyError(c,err);
245          return C_ERR;
246      }
<span onclick='openModal()' class='match'>247      *offset = (size_t)loffset;
248      return C_OK;
249  }
250  int getBitfieldTypeFromArgument(client *c, robj *o, int *sign, int *bits) {
</span>251      char *p = o->ptr;
252      char *err = "Invalid bitfield type. Use something like i16 u8. Note that u64 is not supported but i64 is.";
253      PORT_LONGLONG llbits;
254      if (p[0] == 'i') {
255          *sign = 1;
256      } else if (p[0] == 'u') {
257          *sign = 0;
258      } else {
259          addReplyError(c,err);
260          return C_ERR;
261      }
262      if ((string2ll(p+1,strlen(p+1),&llbits)) == 0 ||
263          llbits < 1 ||
264          (*sign == 1 && llbits > 64) ||
265          (*sign == 0 && llbits > 63))
266      {
267          addReplyError(c,err);
268          return C_ERR;
269      }
270      *bits = llbits;
271      return C_OK;
272  }
273  robj *lookupStringForBitCommand(client *c, size_t maxbit) {
274      size_t byte = maxbit >> 3;
275      robj *o = lookupKeyWrite(c->db,c->argv[1]);
276      if (o == NULL) {
277          o = createObject(OBJ_STRING,sdsnewlen(NULL, byte+1));
278          dbAdd(c->db,c->argv[1],o);
279      } else {
280          if (checkType(c,o,OBJ_STRING)) return NULL;
281          o = dbUnshareStringValue(c->db,c->argv[1],o);
282          o->ptr = sdsgrowzero(o->ptr,byte+1);
283      }
284      return o;
285  }
286  unsigned char *getObjectReadOnlyString(robj *o, PORT_LONG *len, char *llbuf) {
287      serverAssert(o->type == OBJ_STRING);
288      unsigned char *p = NULL;
289      if (o && o->encoding == OBJ_ENCODING_INT) {
290          p = (unsigned char*) llbuf;
291          if (len) *len = ll2string(llbuf,LONG_STR_SIZE,(PORT_LONG)o->ptr);
292      } else if (o) {
293          p = (unsigned char*) o->ptr;
294          if (len) *len = sdslen(o->ptr);
295      } else {
296          if (len) *len = 0;
297      }
298      return p;
299  }
300  void setbitCommand(client *c) {
301      robj *o;
302      char *err = "bit is not an integer or out of range";
303      size_t bitoffset;
304      ssize_t byte, bit;
305      int byteval, bitval;
306      PORT_LONG on;
307      if (getBitOffsetFromArgument(c,c->argv[2],&bitoffset,0,0) != C_OK)
308          return;
309      if (getLongFromObjectOrReply(c,c->argv[3],&on,err) != C_OK)
310          return;
311      if (on & ~1) {
312          addReplyError(c,err);
313          return;
314      }
315      if ((o = lookupStringForBitCommand(c,bitoffset)) == NULL) return;
316      byte = bitoffset >> 3;
317      byteval = ((uint8_t*)o->ptr)[byte];
318      bit = 7 - (bitoffset & 0x7);
319      bitval = byteval & (1 << bit);
320      byteval &= ~(1 << bit);
321      byteval |= ((on & 0x1) << bit);
322      ((uint8_t*)o->ptr)[byte] = byteval;
323      signalModifiedKey(c->db,c->argv[1]);
324      notifyKeyspaceEvent(NOTIFY_STRING,"setbit",c->argv[1],c->db->id);
325      server.dirty++;
326      addReply(c, bitval ? shared.cone : shared.czero);
327  }
328  void getbitCommand(client *c) {
329      robj *o;
330      char llbuf[32];
331      size_t bitoffset;
332      size_t byte, bit;
333      size_t bitval = 0;
334      if (getBitOffsetFromArgument(c,c->argv[2],&bitoffset,0,0) != C_OK)
335          return;
336      if ((o = lookupKeyReadOrReply(c,c->argv[1],shared.czero)) == NULL ||
337          checkType(c,o,OBJ_STRING)) return;
338      byte = bitoffset >> 3;
339      bit = 7 - (bitoffset & 0x7);
340      if (sdsEncodedObject(o)) {
341          if (byte < sdslen(o->ptr))
342              bitval = ((uint8_t*)o->ptr)[byte] & (1 << bit);
343      } else {
344          if (byte < (size_t)ll2string(llbuf,sizeof(llbuf),(PORT_LONG)o->ptr))
345              bitval = llbuf[byte] & (1 << bit);
346      }
347      addReply(c, bitval ? shared.cone : shared.czero);
348  }
349  void bitopCommand(client *c) {
350      char *opname = c->argv[1]->ptr;
351      robj *o, *targetkey = c->argv[2];
352      PORT_ULONG op, j, numkeys;
353      robj **objects;      &bsol;* Array of source objects. */
354      unsigned char **src; &bsol;* Array of source strings pointers. */
355      PORT_ULONG *len, maxlen = 0; &bsol;* Array of length of src strings,
356                                         and max len. */
357      PORT_ULONG minlen = 0;    &bsol;* Min len among the input keys. */
358      unsigned char *res = NULL; &bsol;* Resulting string. */
359      if ((opname[0] == 'a' || opname[0] == 'A') && !strcasecmp(opname,"and"))
360          op = BITOP_AND;
361      else if((opname[0] == 'o' || opname[0] == 'O') && !strcasecmp(opname,"or"))
362          op = BITOP_OR;
363      else if((opname[0] == 'x' || opname[0] == 'X') && !strcasecmp(opname,"xor"))
364          op = BITOP_XOR;
365      else if((opname[0] == 'n' || opname[0] == 'N') && !strcasecmp(opname,"not"))
366          op = BITOP_NOT;
367      else {
368          addReply(c,shared.syntaxerr);
369          return;
370      }
371      if (op == BITOP_NOT && c->argc != 4) {
372          addReplyError(c,"BITOP NOT must be called with a single source key.");
373          return;
374      }
375      numkeys = c->argc - 3;
376      src = zmalloc(sizeof(unsigned char*) * numkeys);
377      len = zmalloc(sizeof(PORT_LONG) * numkeys);
378      objects = zmalloc(sizeof(robj*) * numkeys);
379      for (j = 0; j < numkeys; j++) {
380          o = lookupKeyRead(c->db,c->argv[j+3]);
381          if (o == NULL) {
382              objects[j] = NULL;
383              src[j] = NULL;
384              len[j] = 0;
385              minlen = 0;
386              continue;
387          }
388          if (checkType(c,o,OBJ_STRING)) {
389              PORT_ULONG i;
390              for (i = 0; i < j; i++) {
391                  if (objects[i])
392                      decrRefCount(objects[i]);
393              }
394              zfree(src);
395              zfree(len);
396              zfree(objects);
397              return;
398          }
399          objects[j] = getDecodedObject(o);
400          src[j] = objects[j]->ptr;
401          len[j] = (PORT_LONG) sdslen(objects[j]->ptr);                           WIN_PORT_FIX &bsol;* cast (PORT_LONG) */
402          if (len[j] > maxlen) maxlen = len[j];
403          if (j == 0 || len[j] < minlen) minlen = len[j];
404      }
405      if (maxlen) {
406          res = (unsigned char*) sdsnewlen(NULL,maxlen);
407          unsigned char output, byte;
408          PORT_ULONG i;
409          j = 0;
410          #ifndef USE_ALIGNED_ACCESS
411          if (minlen >= sizeof(PORT_ULONG)*4 && numkeys <= 16) {
412              PORT_ULONG *lp[16];
413              PORT_ULONG *lres = (PORT_ULONG*) res;
414              memcpy(lp,src,sizeof(PORT_ULONG*)*numkeys);
415              memcpy(res,src[0],minlen);
416              if (op == BITOP_AND) {
417                  while(minlen >= sizeof(PORT_ULONG)*4) {
418                      for (i = 1; i < numkeys; i++) {
419                          lres[0] &= lp[i][0];
420                          lres[1] &= lp[i][1];
421                          lres[2] &= lp[i][2];
422                          lres[3] &= lp[i][3];
423                          lp[i]+=4;
424                      }
425                      lres+=4;
426                      j += sizeof(PORT_ULONG)*4;
427                      minlen -= sizeof(PORT_ULONG)*4;
428                  }
429              } else if (op == BITOP_OR) {
430                  while(minlen >= sizeof(PORT_ULONG)*4) {
431                      for (i = 1; i < numkeys; i++) {
432                          lres[0] |= lp[i][0];
433                          lres[1] |= lp[i][1];
434                          lres[2] |= lp[i][2];
435                          lres[3] |= lp[i][3];
436                          lp[i]+=4;
437                      }
438                      lres+=4;
439                      j += sizeof(PORT_ULONG)*4;
440                      minlen -= sizeof(PORT_ULONG)*4;
441                  }
442              } else if (op == BITOP_XOR) {
443                  while(minlen >= sizeof(PORT_ULONG)*4) {
444                      for (i = 1; i < numkeys; i++) {
445                          lres[0] ^= lp[i][0];
446                          lres[1] ^= lp[i][1];
447                          lres[2] ^= lp[i][2];
448                          lres[3] ^= lp[i][3];
449                          lp[i]+=4;
450                      }
451                      lres+=4;
452                      j += sizeof(PORT_ULONG)*4;
453                      minlen -= sizeof(PORT_ULONG)*4;
454                  }
455              } else if (op == BITOP_NOT) {
456                  while(minlen >= sizeof(PORT_ULONG)*4) {
457                      lres[0] = ~lres[0];
458                      lres[1] = ~lres[1];
459                      lres[2] = ~lres[2];
460                      lres[3] = ~lres[3];
461                      lres+=4;
462                      j += sizeof(PORT_ULONG)*4;
463                      minlen -= sizeof(PORT_ULONG)*4;
464                  }
465              }
466          }
467          #endif
468          for (; j < maxlen; j++) {
469              output = (len[0] <= j) ? 0 : src[0][j];
470              if (op == BITOP_NOT) output = ~output;
471              for (i = 1; i < numkeys; i++) {
472                  byte = (len[i] <= j) ? 0 : src[i][j];
473                  switch(op) {
474                  case BITOP_AND: output &= byte; break;
475                  case BITOP_OR:  output |= byte; break;
476                  case BITOP_XOR: output ^= byte; break;
477                  }
478              }
479              res[j] = output;
480          }
481      }
482      for (j = 0; j < numkeys; j++) {
483          if (objects[j])
484              decrRefCount(objects[j]);
485      }
486      zfree(src);
487      zfree(len);
488      zfree(objects);
489      if (maxlen) {
490          o = createObject(OBJ_STRING,res);
491          setKey(c->db,targetkey,o);
492          notifyKeyspaceEvent(NOTIFY_STRING,"set",targetkey,c->db->id);
493          decrRefCount(o);
494      } else if (dbDelete(c->db,targetkey)) {
495          signalModifiedKey(c->db,targetkey);
496          notifyKeyspaceEvent(NOTIFY_GENERIC,"del",targetkey,c->db->id);
497      }
498      server.dirty++;
499      addReplyLongLong(c,maxlen); &bsol;* Return the output string length in bytes. */
500  }
501  void bitcountCommand(client *c) {
502      robj *o;
503      PORT_LONG start, end, strlen;
504      unsigned char *p;
505      char llbuf[LONG_STR_SIZE];
506      if ((o = lookupKeyReadOrReply(c,c->argv[1],shared.czero)) == NULL ||
507          checkType(c,o,OBJ_STRING)) return;
508      p = getObjectReadOnlyString(o,&strlen,llbuf);
509      if (c->argc == 4) {
510          if (getLongFromObjectOrReply(c,c->argv[2],&start,NULL) != C_OK)
511              return;
512          if (getLongFromObjectOrReply(c,c->argv[3],&end,NULL) != C_OK)
513              return;
514          if (start < 0 && end < 0 && start > end) {
515              addReply(c,shared.czero);
516              return;
517          }
518          if (start < 0) start = strlen+start;
519          if (end < 0) end = strlen+end;
520          if (start < 0) start = 0;
521          if (end < 0) end = 0;
522          if (end >= strlen) end = strlen-1;
523      } else if (c->argc == 2) {
524          start = 0;
525          end = strlen-1;
526      } else {
527          addReply(c,shared.syntaxerr);
528          return;
529      }
530      if (start > end) {
531          addReply(c,shared.czero);
532      } else {
533          PORT_LONG bytes = end-start+1;
534          addReplyLongLong(c,redisPopcount(p+start,bytes));
535      }
536  }
537  void bitposCommand(client *c) {
538      robj *o;
539      PORT_LONG bit, start, end, strlen;
540      unsigned char *p;
541      char llbuf[LONG_STR_SIZE];
542      int end_given = 0;
543      if (getLongFromObjectOrReply(c,c->argv[2],&bit,NULL) != C_OK)
544          return;
545      if (bit != 0 && bit != 1) {
546          addReplyError(c, "The bit argument must be 1 or 0.");
547          return;
548      }
549      if ((o = lookupKeyRead(c->db,c->argv[1])) == NULL) {
550          addReplyLongLong(c, bit ? -1 : 0);
551          return;
552      }
553      if (checkType(c,o,OBJ_STRING)) return;
554      p = getObjectReadOnlyString(o,&strlen,llbuf);
555      if (c->argc == 4 || c->argc == 5) {
556          if (getLongFromObjectOrReply(c,c->argv[3],&start,NULL) != C_OK)
557              return;
558          if (c->argc == 5) {
559              if (getLongFromObjectOrReply(c,c->argv[4],&end,NULL) != C_OK)
560                  return;
561              end_given = 1;
562          } else {
563              end = strlen-1;
564          }
565          if (start < 0) start = strlen+start;
566          if (end < 0) end = strlen+end;
567          if (start < 0) start = 0;
568          if (end < 0) end = 0;
569          if (end >= strlen) end = strlen-1;
570      } else if (c->argc == 3) {
571          start = 0;
572          end = strlen-1;
573      } else {
574          addReply(c,shared.syntaxerr);
575          return;
576      }
577      if (start > end) {
578          addReplyLongLong(c, -1);
579      } else {
580          PORT_LONG bytes = end-start+1;
581          PORT_LONG pos = redisBitpos(p+start,(PORT_ULONG)bytes,(int)bit);        WIN_PORT_FIX &bsol;* cast (PORT_ULONG), cast (int) */
582          if (end_given && bit == 0 && pos == bytes*8) {
583              addReplyLongLong(c,-1);
584              return;
585          }
586          if (pos != -1) pos += start*8; &bsol;* Adjust for the bytes we skipped. */
587          addReplyLongLong(c,pos);
588      }
589  }
590  struct bitfieldOp {
591      uint64_t offset;    &bsol;* Bitfield offset. */
592      int64_t i64;        &bsol;* Increment amount (INCRBY) or SET value */
593      int opcode;         &bsol;* Operation id. */
594      int owtype;         &bsol;* Overflow type to use. */
595      int bits;           &bsol;* Integer bitfield bits width. */
596      int sign;           &bsol;* True if signed, otherwise unsigned op. */
597  };
598  void bitfieldCommand(client *c) {
599      robj *o;
600      size_t bitoffset;
601      int j, numops = 0, changes = 0;
602      struct bitfieldOp *ops = NULL; &bsol;* Array of ops to execute at end. */
603      int owtype = BFOVERFLOW_WRAP; &bsol;* Overflow type. */
604      int readonly = 1;
605      size_t highest_write_offset = 0;
606      for (j = 2; j < c->argc; j++) {
607          int remargs = c->argc-j-1; &bsol;* Remaining args other than current. */
608          char *subcmd = c->argv[j]->ptr; &bsol;* Current command name. */
609          int opcode; &bsol;* Current operation code. */
610          PORT_LONGLONG i64 = 0;  &bsol;* Signed SET value. */
611          int sign = 0; &bsol;* Signed or unsigned type? */
612          int bits = 0; &bsol;* Bitfield width in bits. */
613          if (!strcasecmp(subcmd,"get") && remargs >= 2)
614              opcode = BITFIELDOP_GET;
615          else if (!strcasecmp(subcmd,"set") && remargs >= 3)
616              opcode = BITFIELDOP_SET;
617          else if (!strcasecmp(subcmd,"incrby") && remargs >= 3)
618              opcode = BITFIELDOP_INCRBY;
619          else if (!strcasecmp(subcmd,"overflow") && remargs >= 1) {
620              char *owtypename = c->argv[j+1]->ptr;
621              j++;
622              if (!strcasecmp(owtypename,"wrap"))
623                  owtype = BFOVERFLOW_WRAP;
624              else if (!strcasecmp(owtypename,"sat"))
625                  owtype = BFOVERFLOW_SAT;
626              else if (!strcasecmp(owtypename,"fail"))
627                  owtype = BFOVERFLOW_FAIL;
628              else {
629                  addReplyError(c,"Invalid OVERFLOW type specified");
630                  zfree(ops);
631                  return;
632              }
633              continue;
634          } else {
635              addReply(c,shared.syntaxerr);
636              zfree(ops);
637              return;
638          }
639          if (getBitfieldTypeFromArgument(c,c->argv[j+1],&sign,&bits) != C_OK) {
640              zfree(ops);
641              return;
642          }
643          if (getBitOffsetFromArgument(c,c->argv[j+2],&bitoffset,1,bits) != C_OK){
644              zfree(ops);
645              return;
646          }
647          if (opcode != BITFIELDOP_GET) {
648              readonly = 0;
649              if (highest_write_offset < bitoffset + bits - 1)
650                  highest_write_offset = bitoffset + bits - 1;
651              if (getLongLongFromObjectOrReply(c,c->argv[j+3],&i64,NULL) != C_OK){
652                  zfree(ops);
653                  return;
654              }
655          }
656          ops = zrealloc(ops,sizeof(*ops)*(numops+1));
657          ops[numops].offset = bitoffset;
658          ops[numops].i64 = i64;
659          ops[numops].opcode = opcode;
660          ops[numops].owtype = owtype;
661          ops[numops].bits = bits;
662          ops[numops].sign = sign;
663          numops++;
664          j += 3 - (opcode == BITFIELDOP_GET);
665      }
666      if (readonly) {
667          o = lookupKeyRead(c->db,c->argv[1]);
668          if (o != NULL && checkType(c,o,OBJ_STRING)) {
669              zfree(ops);
670              return;
671          }
672      } else {
673          if ((o = lookupStringForBitCommand(c,
674              highest_write_offset)) == NULL) {
675              zfree(ops);
676              return;
677          }
678      }
679      addReplyMultiBulkLen(c,numops);
680      for (j = 0; j < numops; j++) {
681          struct bitfieldOp *thisop = ops+j;
682          if (thisop->opcode == BITFIELDOP_SET ||
683              thisop->opcode == BITFIELDOP_INCRBY)
684          {
685              if (thisop->sign) {
686                  int64_t oldval, newval, wrapped, retval;
687                  int overflow;
688                  oldval = getSignedBitfield(o->ptr,thisop->offset,
689                          thisop->bits);
690                  if (thisop->opcode == BITFIELDOP_INCRBY) {
691                      newval = oldval + thisop->i64;
692                      overflow = checkSignedBitfieldOverflow(oldval,
693                              thisop->i64,thisop->bits,thisop->owtype,&wrapped);
694                      if (overflow) newval = wrapped;
695                      retval = newval;
696                  } else {
697                      newval = thisop->i64;
698                      overflow = checkSignedBitfieldOverflow(newval,
699                              0,thisop->bits,thisop->owtype,&wrapped);
700                      if (overflow) newval = wrapped;
701                      retval = oldval;
702                  }
703                  if (!(overflow && thisop->owtype == BFOVERFLOW_FAIL)) {
704                      addReplyLongLong(c,retval);
705                      setSignedBitfield(o->ptr,thisop->offset,
706                                        thisop->bits,newval);
707                  } else {
708                      addReply(c,shared.nullbulk);
709                  }
710              } else {
711                  uint64_t oldval, newval, wrapped, retval;
712                  int overflow;
713                  oldval = getUnsignedBitfield(o->ptr,thisop->offset,
714                          thisop->bits);
715                  if (thisop->opcode == BITFIELDOP_INCRBY) {
716                      newval = oldval + thisop->i64;
717                      overflow = checkUnsignedBitfieldOverflow(oldval,
718                              thisop->i64,thisop->bits,thisop->owtype,&wrapped);
719                      if (overflow) newval = wrapped;
720                      retval = newval;
721                  } else {
722                      newval = thisop->i64;
723                      overflow = checkUnsignedBitfieldOverflow(newval,
724                              0,thisop->bits,thisop->owtype,&wrapped);
725                      if (overflow) newval = wrapped;
726                      retval = oldval;
727                  }
728                  if (!(overflow && thisop->owtype == BFOVERFLOW_FAIL)) {
729                      addReplyLongLong(c,retval);
730                      setUnsignedBitfield(o->ptr,thisop->offset,
731                                          thisop->bits,newval);
732                  } else {
733                      addReply(c,shared.nullbulk);
734                  }
735              }
736              changes++;
737          } else {
738              unsigned char buf[9];
739              PORT_LONG strlen = 0;
740              unsigned char *src = NULL;
741              char llbuf[LONG_STR_SIZE];
742              if (o != NULL)
743                  src = getObjectReadOnlyString(o,&strlen,llbuf);
744              memset(buf,0,9);
745              int i;
746              size_t byte = thisop->offset >> 3;
747              for (i = 0; i < 9; i++) {
748                  if (src == NULL || i+byte >= (size_t)strlen) break;
749                  buf[i] = src[i+byte];
750              }
751              if (thisop->sign) {
752                  int64_t val = getSignedBitfield(buf,thisop->offset-(byte*8),
753                                              thisop->bits);
754                  addReplyLongLong(c,val);
755              } else {
756                  uint64_t val = getUnsignedBitfield(buf,thisop->offset-(byte*8),
757                                              thisop->bits);
758                  addReplyLongLong(c,val);
759              }
760          }
761      }
762      if (changes) {
763          signalModifiedKey(c->db,c->argv[1]);
764          notifyKeyspaceEvent(NOTIFY_STRING,"setbit",c->argv[1],c->db->id);
765          server.dirty += changes;
766      }
767      zfree(ops);
768  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from PINRemoteImage-MDEwOlJlcG9zaXRvcnkzOTUzNzEwMw==-flat-tiffdec.c</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from redis-MDEwOlJlcG9zaXRvcnkxMDgxMTA3MDY=-flat-bitops.c</div>
                </div>
                <div class="column column_space"><pre><code>50    const MyData* const my_data = (MyData*)opaque;
51    return my_data->size;
52  }
53  static toff_t MySeek(thandle_t opaque, toff_t offset, int whence) {
54    MyData* const my_data = (MyData*)opaque;
</pre></code></div>
                <div class="column column_space"><pre><code>247      *offset = (size_t)loffset;
248      return C_OK;
249  }
250  int getBitfieldTypeFromArgument(client *c, robj *o, int *sign, int *bits) {
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    