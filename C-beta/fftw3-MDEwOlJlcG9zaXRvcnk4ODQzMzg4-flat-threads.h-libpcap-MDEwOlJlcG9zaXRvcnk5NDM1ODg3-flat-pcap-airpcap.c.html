
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 25.386996904024766%, Tokens: 41, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>fftw3-MDEwOlJlcG9zaXRvcnk4ODQzMzg4-flat-threads.h</h3>
            <pre><code>1  #ifndef __THREADS_H__
2  #define __THREADS_H__
3  #include "kernel/ifftw.h"
4  #include "dft/ct.h"
5  #include "rdft/hc2hc.h"
6  typedef struct {
7       int min, max, thr_num;
8       void *data;
9  } spawn_data;
<span onclick='openModal()' class='match'>10  typedef void *(*spawn_function) (spawn_data *);
11  void X(spawn_loop)(int loopmax, int nthreads,
12  		   spawn_function proc, void *data);
13  int X(ithreads_init)(void);
14  void X(threads_cleanup)(void);
15  typedef void (*spawnloop_function)(spawn_function, spawn_data *, size_t, int, void *);
16  extern spawnloop_function X(spawnloop_callback);
17  extern void *X(spawnloop_callback_data);
18  void X(dft_thr_vrank_geq1_register)(planner *p);
19  void X(rdft_thr_vrank_geq1_register)(planner *p);
20  void X(rdft2_thr_vrank_geq1_register)(planner *p);
21  ct_solver *X(mksolver_ct_threads)(size_t size, INT r, int dec,
22  				  ct_mkinferior mkcldw,
23  				  ct_force_vrecursion force_vrecursionp);
24  hc2hc_solver *X(mksolver_hc2hc_threads)(size_t size, INT r, hc2hc_mkinferior mkcldw);
25  void X(threads_conf_standard)(planner *p);
26  void X(threads_register_hooks)(void);
27  void X(threads_unregister_hooks)(void);
28  void X(threads_register_planner_hooks)(void);
</span>29  #endif &bsol;* __THREADS_H__ */
</code></pre>
        </div>
        <div class="column">
            <h3>libpcap-MDEwOlJlcG9zaXRvcnk5NDM1ODg3-flat-pcap-airpcap.c</h3>
            <pre><code>1  #ifdef HAVE_CONFIG_H
2  #include <config.h>
3  #endif
4  #include "pcap-int.h"
5  #include <airpcap.h>
6  #include "pcap-airpcap.h"
7  #define	AIRPCAP_DEFAULT_USER_BUFFER_SIZE 256000
8  #define	AIRPCAP_DEFAULT_KERNEL_BUFFER_SIZE 1000000
<span onclick='openModal()' class='match'>9  static pcap_code_handle_t airpcap_lib;
10  typedef PCHAR (*AirpcapGetLastErrorHandler)(PAirpcapHandle);
11  typedef BOOL (*AirpcapGetDeviceListHandler)(PAirpcapDeviceDescription *, PCHAR);
12  typedef VOID (*AirpcapFreeDeviceListHandler)(PAirpcapDeviceDescription);
13  typedef PAirpcapHandle (*AirpcapOpenHandler)(PCHAR, PCHAR);
14  typedef VOID (*AirpcapCloseHandler)(PAirpcapHandle);
15  typedef BOOL (*AirpcapSetDeviceMacFlagsHandler)(PAirpcapHandle, UINT);
16  typedef BOOL (*AirpcapSetLinkTypeHandler)(PAirpcapHandle, AirpcapLinkType);
17  typedef BOOL (*AirpcapGetLinkTypeHandler)(PAirpcapHandle, PAirpcapLinkType);
18  typedef BOOL (*AirpcapSetKernelBufferHandler)(PAirpcapHandle, UINT);
19  typedef BOOL (*AirpcapSetFilterHandler)(PAirpcapHandle, PVOID, UINT);
20  typedef BOOL (*AirpcapSetMinToCopyHandler)(PAirpcapHandle, UINT);
21  typedef BOOL (*AirpcapGetReadEventHandler)(PAirpcapHandle, HANDLE *);
22  typedef BOOL (*AirpcapReadHandler)(PAirpcapHandle, PBYTE, UINT, PUINT);
23  typedef BOOL (*AirpcapWriteHandler)(PAirpcapHandle, PCHAR, ULONG);
24  typedef BOOL (*AirpcapGetStatsHandler)(PAirpcapHandle, PAirpcapStats);
25  static AirpcapGetLastErrorHandler p_AirpcapGetLastError;
26  static AirpcapGetDeviceListHandler p_AirpcapGetDeviceList;
27  static AirpcapFreeDeviceListHandler p_AirpcapFreeDeviceList;
28  static AirpcapOpenHandler p_AirpcapOpen;
29  static AirpcapCloseHandler p_AirpcapClose;
30  static AirpcapSetDeviceMacFlagsHandler p_AirpcapSetDeviceMacFlags;
31  static AirpcapSetLinkTypeHandler p_AirpcapSetLinkType;
32  static AirpcapGetLinkTypeHandler p_AirpcapGetLinkType;
33  static AirpcapSetKernelBufferHandler p_AirpcapSetKernelBuffer;
</span>34  static AirpcapSetFilterHandler p_AirpcapSetFilter;
35  static AirpcapSetMinToCopyHandler p_AirpcapSetMinToCopy;
36  static AirpcapGetReadEventHandler p_AirpcapGetReadEvent;
37  static AirpcapReadHandler p_AirpcapRead;
38  static AirpcapWriteHandler p_AirpcapWrite;
39  static AirpcapGetStatsHandler p_AirpcapGetStats;
40  typedef enum LONG
41  {
42  	AIRPCAP_API_UNLOADED = 0,
43  	AIRPCAP_API_LOADED,
44  	AIRPCAP_API_CANNOT_LOAD,
45  	AIRPCAP_API_LOADING
46  } AIRPCAP_API_LOAD_STATUS;
47  static AIRPCAP_API_LOAD_STATUS	airpcap_load_status;
48  static AIRPCAP_API_LOAD_STATUS
49  load_airpcap_functions(void)
50  {
51  	AIRPCAP_API_LOAD_STATUS current_status;
52  	current_status = InterlockedCompareExchange((LONG *)&airpcap_load_status,
53  	    AIRPCAP_API_LOADING, AIRPCAP_API_UNLOADED);
54  	while (current_status == AIRPCAP_API_LOADING) {
55  		current_status = InterlockedCompareExchange((LONG*)&airpcap_load_status,
56  		    AIRPCAP_API_LOADING, AIRPCAP_API_LOADING);
57  		Sleep(10);
58  	}
59  	if (current_status == AIRPCAP_API_LOADED)
60  		return AIRPCAP_API_LOADED;
61  	if (current_status == AIRPCAP_API_CANNOT_LOAD)
62  		return AIRPCAP_API_CANNOT_LOAD;
63  	current_status = AIRPCAP_API_CANNOT_LOAD;
64  	airpcap_lib = pcap_load_code("airpcap.dll");
65  	if (airpcap_lib != NULL) {
66  		p_AirpcapGetLastError = (AirpcapGetLastErrorHandler) pcap_find_function(airpcap_lib, "AirpcapGetLastError");
67  		p_AirpcapGetDeviceList = (AirpcapGetDeviceListHandler) pcap_find_function(airpcap_lib, "AirpcapGetDeviceList");
68  		p_AirpcapFreeDeviceList = (AirpcapFreeDeviceListHandler) pcap_find_function(airpcap_lib, "AirpcapFreeDeviceList");
69  		p_AirpcapOpen = (AirpcapOpenHandler) pcap_find_function(airpcap_lib, "AirpcapOpen");
70  		p_AirpcapClose = (AirpcapCloseHandler) pcap_find_function(airpcap_lib, "AirpcapClose");
71  		p_AirpcapSetDeviceMacFlags = (AirpcapSetDeviceMacFlagsHandler) pcap_find_function(airpcap_lib, "AirpcapSetDeviceMacFlags");
72  		p_AirpcapSetLinkType = (AirpcapSetLinkTypeHandler) pcap_find_function(airpcap_lib, "AirpcapSetLinkType");
73  		p_AirpcapGetLinkType = (AirpcapGetLinkTypeHandler) pcap_find_function(airpcap_lib, "AirpcapGetLinkType");
74  		p_AirpcapSetKernelBuffer = (AirpcapSetKernelBufferHandler) pcap_find_function(airpcap_lib, "AirpcapSetKernelBuffer");
75  		p_AirpcapSetFilter = (AirpcapSetFilterHandler) pcap_find_function(airpcap_lib, "AirpcapSetFilter");
76  		p_AirpcapSetMinToCopy = (AirpcapSetMinToCopyHandler) pcap_find_function(airpcap_lib, "AirpcapSetMinToCopy");
77  		p_AirpcapGetReadEvent = (AirpcapGetReadEventHandler) pcap_find_function(airpcap_lib, "AirpcapGetReadEvent");
78  		p_AirpcapRead = (AirpcapReadHandler) pcap_find_function(airpcap_lib, "AirpcapRead");
79  		p_AirpcapWrite = (AirpcapWriteHandler) pcap_find_function(airpcap_lib, "AirpcapWrite");
80  		p_AirpcapGetStats = (AirpcapGetStatsHandler) pcap_find_function(airpcap_lib, "AirpcapGetStats");
81  		if (p_AirpcapGetLastError != NULL &&
82  		    p_AirpcapGetDeviceList != NULL &&
83  		    p_AirpcapFreeDeviceList != NULL &&
84  		    p_AirpcapOpen != NULL &&
85  		    p_AirpcapClose != NULL &&
86  		    p_AirpcapSetDeviceMacFlags != NULL &&
87  		    p_AirpcapSetLinkType != NULL &&
88  		    p_AirpcapGetLinkType != NULL &&
89  		    p_AirpcapSetKernelBuffer != NULL &&
90  		    p_AirpcapSetFilter != NULL &&
91  		    p_AirpcapSetMinToCopy != NULL &&
92  		    p_AirpcapGetReadEvent != NULL &&
93  		    p_AirpcapRead != NULL &&
94  		    p_AirpcapWrite != NULL &&
95  		    p_AirpcapGetStats != NULL) {
96  			current_status = AIRPCAP_API_LOADED;
97  		}
98  	}
99  	if (current_status != AIRPCAP_API_LOADED) {
100  		if (airpcap_lib != NULL) {
101  			FreeLibrary(airpcap_lib);
102  			airpcap_lib = NULL;
103  		}
104  	}
105  	InterlockedExchange((LONG *)&airpcap_load_status, current_status);
106  	return current_status;
107  }
108  struct pcap_airpcap {
109  	PAirpcapHandle adapter;
110  	int filtering_in_kernel;
111  	int nonblock;
112  	int read_timeout;
113  	HANDLE read_event;
114  	struct pcap_stat stat;
115  };
116  static int
117  airpcap_setfilter(pcap_t *p, struct bpf_program *fp)
118  {
119  	struct pcap_airpcap *pa = p->priv;
120  	if (!p_AirpcapSetFilter(pa->adapter, fp->bf_insns,
121  	    fp->bf_len * sizeof(struct bpf_insn))) {
122  		if (pcap_install_bpf_program(p, fp) < 0)
123  			return (-1);
124  		pa->filtering_in_kernel = 0;	&bsol;* filtering in userland */
125  		return (0);
126  	}
127  	pa->filtering_in_kernel = 1;	&bsol;* filtering in the kernel */
128  	p->cc = 0;
129  	return (0);
130  }
131  static int
132  airpcap_set_datalink(pcap_t *p, int dlt)
133  {
134  	struct pcap_airpcap *pa = p->priv;
135  	AirpcapLinkType type;
136  	switch (dlt) {
137  	case DLT_IEEE802_11_RADIO:
138  		type = AIRPCAP_LT_802_11_PLUS_RADIO;
139  		break;
140  	case DLT_PPI:
141  		type = AIRPCAP_LT_802_11_PLUS_PPI;
142  		break;
143  	case DLT_IEEE802_11:
144  		type = AIRPCAP_LT_802_11;
145  		break;
146  	default:
147  		return (0);
148  	}
149  	if (!p_AirpcapSetLinkType(pa->adapter, type)) {
150  		snprintf(p->errbuf, PCAP_ERRBUF_SIZE,
151  		    "AirpcapSetLinkType() failed: %s",
152  		    p_AirpcapGetLastError(pa->adapter));
153  		return (-1);
154  	}
155  	p->linktype = dlt;
156  	return (0);
157  }
158  static int
159  airpcap_getnonblock(pcap_t *p)
160  {
161  	struct pcap_airpcap *pa = p->priv;
162  	return (pa->nonblock);
163  }
164  static int
165  airpcap_setnonblock(pcap_t *p, int nonblock)
166  {
167  	struct pcap_airpcap *pa = p->priv;
168  	int newtimeout;
169  	if (nonblock) {
170  		newtimeout = -1;
171  	} else {
172  		newtimeout = p->opt.timeout;
173  	}
174  	pa->read_timeout = newtimeout;
175  	pa->nonblock = (newtimeout == -1);
176  	return (0);
177  }
178  static int
179  airpcap_stats(pcap_t *p, struct pcap_stat *ps)
180  {
181  	struct pcap_airpcap *pa = p->priv;
182  	AirpcapStats tas;
183  	if (!p_AirpcapGetStats(pa->adapter, &tas)) {
184  		snprintf(p->errbuf, PCAP_ERRBUF_SIZE,
185  		    "AirpcapGetStats() failed: %s",
186  		    p_AirpcapGetLastError(pa->adapter));
187  		return (-1);
188  	}
189  	ps->ps_drop = tas.Drops;
190  	ps->ps_recv = tas.Recvs;
191  	ps->ps_ifdrop = tas.IfDrops;
192  	return (0);
193  }
194  static struct pcap_stat *
195  airpcap_stats_ex(pcap_t *p, int *pcap_stat_size)
196  {
197  	struct pcap_airpcap *pa = p->priv;
198  	AirpcapStats tas;
199  	*pcap_stat_size = sizeof (p->stat);
200  	if (!p_AirpcapGetStats(pa->adapter, &tas)) {
201  		snprintf(p->errbuf, PCAP_ERRBUF_SIZE,
202  		    "AirpcapGetStats() failed: %s",
203  		    p_AirpcapGetLastError(pa->adapter));
204  		return (NULL);
205  	}
206  	p->stat.ps_recv = tas.Recvs;
207  	p->stat.ps_drop = tas.Drops;
208  	p->stat.ps_ifdrop = tas.IfDrops;
209  #ifdef _WIN32
210  	p->stat.ps_capt = tas.Capt;
211  #endif
212  	return (&p->stat);
213  }
214  static int
215  airpcap_setbuff(pcap_t *p, int dim)
216  {
217  	struct pcap_airpcap *pa = p->priv;
218  	if (!p_AirpcapSetKernelBuffer(pa->adapter, dim)) {
219  		snprintf(p->errbuf, PCAP_ERRBUF_SIZE,
220  		    "AirpcapSetKernelBuffer() failed: %s",
221  		    p_AirpcapGetLastError(pa->adapter));
222  		return (-1);
223  	}
224  	return (0);
225  }
226  static int
227  airpcap_setmode(pcap_t *p, int mode)
228  {
229  	 if (mode != MODE_CAPT) {
230  		snprintf(p->errbuf, PCAP_ERRBUF_SIZE,
231  		    "Only MODE_CAPT is supported on an AirPcap adapter");
232  		return (-1);
233  	 }
234  	 return (0);
235  }
236  static int
237  airpcap_setmintocopy(pcap_t *p, int size)
238  {
239  	struct pcap_airpcap *pa = p->priv;
240  	if (!p_AirpcapSetMinToCopy(pa->adapter, size)) {
241  		snprintf(p->errbuf, PCAP_ERRBUF_SIZE,
242  		    "AirpcapSetMinToCopy() failed: %s",
243  		    p_AirpcapGetLastError(pa->adapter));
244  		return (-1);
245  	}
246  	return (0);
247  }
248  static HANDLE
249  airpcap_getevent(pcap_t *p)
250  {
251  	struct pcap_airpcap *pa = p->priv;
252  	return (pa->read_event);
253  }
254  static int
255  airpcap_oid_get_request(pcap_t *p, bpf_u_int32 oid _U_, void *data _U_,
256      size_t *lenp _U_)
257  {
258  	snprintf(p->errbuf, PCAP_ERRBUF_SIZE,
259  	    "Getting OID values is not supported on an AirPcap adapter");
260  	return (PCAP_ERROR);
261  }
262  static int
263  airpcap_oid_set_request(pcap_t *p, bpf_u_int32 oid _U_, const void *data _U_,
264      size_t *lenp _U_)
265  {
266  	snprintf(p->errbuf, PCAP_ERRBUF_SIZE,
267  	    "Setting OID values is not supported on an AirPcap adapter");
268  	return (PCAP_ERROR);
269  }
270  static u_int
271  airpcap_sendqueue_transmit(pcap_t *p, pcap_send_queue *queue _U_, int sync _U_)
272  {
273  	snprintf(p->errbuf, PCAP_ERRBUF_SIZE,
274  	    "Cannot queue packets for transmission on an AirPcap adapter");
275  	return (0);
276  }
277  static int
278  airpcap_setuserbuffer(pcap_t *p, int size)
279  {
280  	unsigned char *new_buff;
281  	if (size <= 0) {
282  		snprintf(p->errbuf, PCAP_ERRBUF_SIZE,
283  		    "Error: invalid size %d",size);
284  		return (-1);
285  	}
286  	new_buff = (unsigned char *)malloc(sizeof(char)*size);
287  	if (!new_buff) {
288  		snprintf(p->errbuf, PCAP_ERRBUF_SIZE,
289  		    "Error: not enough memory");
290  		return (-1);
291  	}
292  	free(p->buffer);
293  	p->buffer = new_buff;
294  	p->bufsize = size;
295  	return (0);
296  }
297  static int
298  airpcap_live_dump(pcap_t *p, char *filename _U_, int maxsize _U_,
299      int maxpacks _U_)
300  {
301  	snprintf(p->errbuf, PCAP_ERRBUF_SIZE,
302  	    "AirPcap adapters don't support live dump");
303  	return (-1);
304  }
305  static int
306  airpcap_live_dump_ended(pcap_t *p, int sync _U_)
307  {
308  	snprintf(p->errbuf, PCAP_ERRBUF_SIZE,
309  	    "AirPcap adapters don't support live dump");
310  	return (-1);
311  }
312  static PAirpcapHandle
313  airpcap_get_airpcap_handle(pcap_t *p)
314  {
315  	struct pcap_airpcap *pa = p->priv;
316  	return (pa->adapter);
317  }
318  static int
319  airpcap_read(pcap_t *p, int cnt, pcap_handler callback, u_char *user)
320  {
321  	struct pcap_airpcap *pa = p->priv;
322  	int cc;
323  	int n;
324  	register u_char *bp, *ep;
325  	UINT bytes_read;
326  	u_char *datap;
327  	cc = p->cc;
328  	if (cc == 0) {
329  		if (p->break_loop) {
330  			p->break_loop = 0;
331  			return (PCAP_ERROR_BREAK);
332  		}
333  		if (pa->read_timeout != -1) {
334  			WaitForSingleObject(pa->read_event,
335  			    (pa->read_timeout ==0 )? INFINITE: pa->read_timeout);
336  		}
337  		if (!p_AirpcapRead(pa->adapter, (PBYTE)p->buffer,
338  		    p->bufsize, &bytes_read)) {
339  			snprintf(p->errbuf, PCAP_ERRBUF_SIZE,
340  			    "AirpcapRead() failed: %s",
341  			    p_AirpcapGetLastError(pa->adapter));
342  			return (-1);
343  		}
344  		cc = bytes_read;
345  		bp = p->buffer;
346  	} else
347  		bp = p->bp;
348  #define bhp ((AirpcapBpfHeader *)bp)
349  	n = 0;
350  	ep = bp + cc;
351  	for (;;) {
352  		register u_int caplen, hdrlen;
353  		if (p->break_loop) {
354  			if (n == 0) {
355  				p->break_loop = 0;
356  				return (PCAP_ERROR_BREAK);
357  			} else {
358  				p->bp = bp;
359  				p->cc = (int) (ep - bp);
360  				return (n);
361  			}
362  		}
363  		if (bp >= ep)
364  			break;
365  		caplen = bhp->Caplen;
366  		hdrlen = bhp->Hdrlen;
367  		datap = bp + hdrlen;
368  		if (pa->filtering_in_kernel ||
369  		    p->fcode.bf_insns == NULL ||
370  		    pcap_filter(p->fcode.bf_insns, datap, bhp->Originallen, caplen)) {
371  			struct pcap_pkthdr pkthdr;
372  			pkthdr.ts.tv_sec = bhp->TsSec;
373  			pkthdr.ts.tv_usec = bhp->TsUsec;
374  			pkthdr.caplen = caplen;
375  			pkthdr.len = bhp->Originallen;
376  			(*callback)(user, &pkthdr, datap);
377  			bp += AIRPCAP_WORDALIGN(caplen + hdrlen);
378  			if (++n >= cnt && !PACKET_COUNT_IS_UNLIMITED(cnt)) {
379  				p->bp = bp;
380  				p->cc = (int)(ep - bp);
381  				return (n);
382  			}
383  		} else {
384  			bp += AIRPCAP_WORDALIGN(caplen + hdrlen);
385  		}
386  	}
387  #undef bhp
388  	p->cc = 0;
389  	return (n);
390  }
391  static int
392  airpcap_inject(pcap_t *p, const void *buf, int size)
393  {
394  	struct pcap_airpcap *pa = p->priv;
395  	if (!p_AirpcapWrite(pa->adapter, (void *)buf, size)) {
396  		snprintf(p->errbuf, PCAP_ERRBUF_SIZE,
397  		    "AirpcapWrite() failed: %s",
398  		    p_AirpcapGetLastError(pa->adapter));
399  		return (-1);
400  	}
401  	return (size);
402  }
403  static void
404  airpcap_cleanup(pcap_t *p)
405  {
406  	struct pcap_airpcap *pa = p->priv;
407  	if (pa->adapter != NULL) {
408  		p_AirpcapClose(pa->adapter);
409  		pa->adapter = NULL;
410  	}
411  	pcap_cleanup_live_common(p);
412  }
413  static void
414  airpcap_breakloop(pcap_t *p)
415  {
416  	HANDLE read_event;
417  	pcap_breakloop_common(p);
418  	struct pcap_airpcap *pa = p->priv;
419  	if (!p_AirpcapGetReadEvent(pa->adapter, &read_event))
420  		return;
421  	SetEvent(read_event);
422  }
423  static int
424  airpcap_activate(pcap_t *p)
425  {
426  	struct pcap_airpcap *pa = p->priv;
427  	char *device = p->opt.device;
428  	char airpcap_errbuf[AIRPCAP_ERRBUF_SIZE];
429  	BOOL status;
430  	AirpcapLinkType link_type;
431  	pa->adapter = p_AirpcapOpen(device, airpcap_errbuf);
432  	if (pa->adapter == NULL) {
433  		snprintf(p->errbuf, PCAP_ERRBUF_SIZE, "%s", airpcap_errbuf);
434  		return (PCAP_ERROR);
435  	}
436  	if (p->opt.rfmon) {
437  		status = p_AirpcapSetDeviceMacFlags(pa->adapter,
438  		    AIRPCAP_MF_MONITOR_MODE_ON);
439  	} else
440  		status = p_AirpcapSetDeviceMacFlags(pa->adapter,
441  		    AIRPCAP_MF_ACK_FRAMES_ON);
442  	if (!status) {
443  		p_AirpcapClose(pa->adapter);
444  		snprintf(p->errbuf, PCAP_ERRBUF_SIZE,
445  		    "AirpcapSetDeviceMacFlags() failed: %s",
446  		    p_AirpcapGetLastError(pa->adapter));
447  		return (PCAP_ERROR);
448  	}
449  	if (p->snapshot <= 0 || p->snapshot > MAXIMUM_SNAPLEN)
450  		p->snapshot = MAXIMUM_SNAPLEN;
451  	if (p->opt.buffer_size == 0)
452  		p->opt.buffer_size = AIRPCAP_DEFAULT_KERNEL_BUFFER_SIZE;
453  	if (!p_AirpcapSetKernelBuffer(pa->adapter, p->opt.buffer_size)) {
454  		snprintf(p->errbuf, PCAP_ERRBUF_SIZE,
455  		    "AirpcapSetKernelBuffer() failed: %s",
456  		    p_AirpcapGetLastError(pa->adapter));
457  		goto bad;
458  	}
459  	if(!p_AirpcapGetReadEvent(pa->adapter, &pa->read_event)) {
460  		snprintf(p->errbuf, PCAP_ERRBUF_SIZE,
461  		    "AirpcapGetReadEvent() failed: %s",
462  		    p_AirpcapGetLastError(pa->adapter));
463  		goto bad;
464  	}
465  	p->bufsize = AIRPCAP_DEFAULT_USER_BUFFER_SIZE;
466  	p->buffer = malloc(p->bufsize);
467  	if (p->buffer == NULL) {
468  		pcap_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,
469  		    errno, "malloc");
470  		goto bad;
471  	}
472  	if (p->opt.immediate) {
473  		if (!p_AirpcapSetMinToCopy(pa->adapter, 0)) {
474  			snprintf(p->errbuf, PCAP_ERRBUF_SIZE,
475  			    "AirpcapSetMinToCopy() failed: %s",
476  			    p_AirpcapGetLastError(pa->adapter));
477  			goto bad;
478  		}
479  	} else {
480  		if (!p_AirpcapSetMinToCopy(pa->adapter, 16000)) {
481  			snprintf(p->errbuf, PCAP_ERRBUF_SIZE,
482  			    "AirpcapSetMinToCopy() failed: %s",
483  			    p_AirpcapGetLastError(pa->adapter));
484  			goto bad;
485  		}
486  	}
487  	if (!p_AirpcapGetLinkType(pa->adapter, &link_type)) {
488  		snprintf(p->errbuf, PCAP_ERRBUF_SIZE,
489  		    "AirpcapGetLinkType() failed: %s",
490  		    p_AirpcapGetLastError(pa->adapter));
491  		goto bad;
492  	}
493  	switch (link_type) {
494  	case AIRPCAP_LT_802_11_PLUS_RADIO:
495  		p->linktype = DLT_IEEE802_11_RADIO;
496  		break;
497  	case AIRPCAP_LT_802_11_PLUS_PPI:
498  		p->linktype = DLT_PPI;
499  		break;
500  	case AIRPCAP_LT_802_11:
501  		p->linktype = DLT_IEEE802_11;
502  		break;
503  	case AIRPCAP_LT_UNKNOWN:
504  	default:
505  		snprintf(p->errbuf, PCAP_ERRBUF_SIZE,
506  		    "AirpcapGetLinkType() returned unknown link type %u",
507  		    link_type);
508  		goto bad;
509  	}
510  	p->dlt_list = (u_int *) malloc(sizeof(u_int) * 3);
511  	if (p->dlt_list == NULL)
512  		goto bad;
513  	p->dlt_list[0] = DLT_IEEE802_11_RADIO;
514  	p->dlt_list[1] = DLT_PPI;
515  	p->dlt_list[2] = DLT_IEEE802_11;
516  	p->dlt_count = 3;
517  	p->read_op = airpcap_read;
518  	p->inject_op = airpcap_inject;
519  	p->setfilter_op = airpcap_setfilter;
520  	p->setdirection_op = NULL;	&bsol;* Not implemented. */
521  	p->set_datalink_op = airpcap_set_datalink;
522  	p->getnonblock_op = airpcap_getnonblock;
523  	p->setnonblock_op = airpcap_setnonblock;
524  	p->breakloop_op = airpcap_breakloop;
525  	p->stats_op = airpcap_stats;
526  	p->stats_ex_op = airpcap_stats_ex;
527  	p->setbuff_op = airpcap_setbuff;
528  	p->setmode_op = airpcap_setmode;
529  	p->setmintocopy_op = airpcap_setmintocopy;
530  	p->getevent_op = airpcap_getevent;
531  	p->oid_get_request_op = airpcap_oid_get_request;
532  	p->oid_set_request_op = airpcap_oid_set_request;
533  	p->sendqueue_transmit_op = airpcap_sendqueue_transmit;
534  	p->setuserbuffer_op = airpcap_setuserbuffer;
535  	p->live_dump_op = airpcap_live_dump;
536  	p->live_dump_ended_op = airpcap_live_dump_ended;
537  	p->get_airpcap_handle_op = airpcap_get_airpcap_handle;
538  	p->cleanup_op = airpcap_cleanup;
539  	return (0);
540   bad:
541  	airpcap_cleanup(p);
542  	return (PCAP_ERROR);
543  }
544  static int
545  airpcap_can_set_rfmon(pcap_t *p)
546  {
547  	return (1);
548  }
549  int
550  device_is_airpcap(const char *device, char *ebuf)
551  {
552  	static const char airpcap_prefix[] = "\\\\.\\airpcap";
553  	if (strncmp(device, airpcap_prefix, sizeof airpcap_prefix - 1) == 0) {
554  		return (1);
555  	}
556  	return (0);
557  }
558  pcap_t *
559  airpcap_create(const char *device, char *ebuf, int *is_ours)
560  {
561  	int ret;
562  	pcap_t *p;
563  	if (load_airpcap_functions() != AIRPCAP_API_LOADED) {
564  		*is_ours = 0;
565  		return (NULL);
566  	}
567  	ret = device_is_airpcap(device, ebuf);
568  	if (ret == 0) {
569  		*is_ours = 0;
570  		return (NULL);
571  	}
572  	*is_ours = 1;
573  	p = PCAP_CREATE_COMMON(ebuf, struct pcap_airpcap);
574  	if (p == NULL)
575  		return (NULL);
576  	p->activate_op = airpcap_activate;
577  	p->can_set_rfmon_op = airpcap_can_set_rfmon;
578  	return (p);
579  }
580  int
581  airpcap_findalldevs(pcap_if_list_t *devlistp, char *errbuf)
582  {
583  	AirpcapDeviceDescription *airpcap_devices, *airpcap_device;
584  	char airpcap_errbuf[AIRPCAP_ERRBUF_SIZE];
585  	if (load_airpcap_functions() != AIRPCAP_API_LOADED) {
586  		return (0);
587  	}
588  	if (!p_AirpcapGetDeviceList(&airpcap_devices, airpcap_errbuf)) {
589  		snprintf(errbuf, PCAP_ERRBUF_SIZE,
590  		    "AirpcapGetDeviceList() failed: %s", airpcap_errbuf);
591  		return (-1);
592  	}
593  	for (airpcap_device = airpcap_devices; airpcap_device != NULL;
594  	    airpcap_device = airpcap_device->next) {
595  		if (pcap_add_dev(devlistp, airpcap_device->Name, 0,
596  		    airpcap_device->Description, errbuf) == NULL) {
597  			p_AirpcapFreeDeviceList(airpcap_devices);
598  			return (-1);
599  		}
600  	}
601  	p_AirpcapFreeDeviceList(airpcap_devices);
602  	return (0);
603  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from fftw3-MDEwOlJlcG9zaXRvcnk4ODQzMzg4-flat-threads.h</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from libpcap-MDEwOlJlcG9zaXRvcnk5NDM1ODg3-flat-pcap-airpcap.c</div>
                </div>
                <div class="column column_space"><pre><code>10  typedef void *(*spawn_function) (spawn_data *);
11  void X(spawn_loop)(int loopmax, int nthreads,
12  		   spawn_function proc, void *data);
13  int X(ithreads_init)(void);
14  void X(threads_cleanup)(void);
15  typedef void (*spawnloop_function)(spawn_function, spawn_data *, size_t, int, void *);
16  extern spawnloop_function X(spawnloop_callback);
17  extern void *X(spawnloop_callback_data);
18  void X(dft_thr_vrank_geq1_register)(planner *p);
19  void X(rdft_thr_vrank_geq1_register)(planner *p);
20  void X(rdft2_thr_vrank_geq1_register)(planner *p);
21  ct_solver *X(mksolver_ct_threads)(size_t size, INT r, int dec,
22  				  ct_mkinferior mkcldw,
23  				  ct_force_vrecursion force_vrecursionp);
24  hc2hc_solver *X(mksolver_hc2hc_threads)(size_t size, INT r, hc2hc_mkinferior mkcldw);
25  void X(threads_conf_standard)(planner *p);
26  void X(threads_register_hooks)(void);
27  void X(threads_unregister_hooks)(void);
28  void X(threads_register_planner_hooks)(void);
</pre></code></div>
                <div class="column column_space"><pre><code>9  static pcap_code_handle_t airpcap_lib;
10  typedef PCHAR (*AirpcapGetLastErrorHandler)(PAirpcapHandle);
11  typedef BOOL (*AirpcapGetDeviceListHandler)(PAirpcapDeviceDescription *, PCHAR);
12  typedef VOID (*AirpcapFreeDeviceListHandler)(PAirpcapDeviceDescription);
13  typedef PAirpcapHandle (*AirpcapOpenHandler)(PCHAR, PCHAR);
14  typedef VOID (*AirpcapCloseHandler)(PAirpcapHandle);
15  typedef BOOL (*AirpcapSetDeviceMacFlagsHandler)(PAirpcapHandle, UINT);
16  typedef BOOL (*AirpcapSetLinkTypeHandler)(PAirpcapHandle, AirpcapLinkType);
17  typedef BOOL (*AirpcapGetLinkTypeHandler)(PAirpcapHandle, PAirpcapLinkType);
18  typedef BOOL (*AirpcapSetKernelBufferHandler)(PAirpcapHandle, UINT);
19  typedef BOOL (*AirpcapSetFilterHandler)(PAirpcapHandle, PVOID, UINT);
20  typedef BOOL (*AirpcapSetMinToCopyHandler)(PAirpcapHandle, UINT);
21  typedef BOOL (*AirpcapGetReadEventHandler)(PAirpcapHandle, HANDLE *);
22  typedef BOOL (*AirpcapReadHandler)(PAirpcapHandle, PBYTE, UINT, PUINT);
23  typedef BOOL (*AirpcapWriteHandler)(PAirpcapHandle, PCHAR, ULONG);
24  typedef BOOL (*AirpcapGetStatsHandler)(PAirpcapHandle, PAirpcapStats);
25  static AirpcapGetLastErrorHandler p_AirpcapGetLastError;
26  static AirpcapGetDeviceListHandler p_AirpcapGetDeviceList;
27  static AirpcapFreeDeviceListHandler p_AirpcapFreeDeviceList;
28  static AirpcapOpenHandler p_AirpcapOpen;
29  static AirpcapCloseHandler p_AirpcapClose;
30  static AirpcapSetDeviceMacFlagsHandler p_AirpcapSetDeviceMacFlags;
31  static AirpcapSetLinkTypeHandler p_AirpcapSetLinkType;
32  static AirpcapGetLinkTypeHandler p_AirpcapGetLinkType;
33  static AirpcapSetKernelBufferHandler p_AirpcapSetKernelBuffer;
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    