
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 3.6709721278042147%, Tokens: 10, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>Adafruit_nRF52_Arduino-MDEwOlJlcG9zaXRvcnk3NDM1NDcyOQ==-flat-flash_cache.c</h3>
            <pre><code>1  #include <string.h>
2  #include "flash_cache.h"
3  #include "common_func.h"
4  #include "variant.h"
5  #include "wiring_digital.h"
6  static inline uint32_t page_addr_of (uint32_t addr)
7  {
8    return addr & ~(FLASH_CACHE_SIZE - 1);
9  }
10  static inline uint32_t page_offset_of (uint32_t addr)
11  {
<span onclick='openModal()' class='match'>12    return addr & (FLASH_CACHE_SIZE - 1);
13  }
14  int flash_cache_write (flash_cache_t* fc, uint32_t dst, void const * src, uint32_t len)
15  {
16    uint8_t const * src8 = (uint8_t const *) src;
</span>17    uint32_t remain = len;
18    while ( remain )
19    {
20      uint32_t const page_addr = page_addr_of(dst);
21      uint32_t const offset = page_offset_of(dst);
22      uint32_t wr_bytes = FLASH_CACHE_SIZE - offset;
23      wr_bytes = min32(remain, wr_bytes);
24      if ( page_addr != fc->cache_addr )
25      {
26        flash_cache_flush(fc);
27        fc->cache_addr = page_addr;
28        fc->read(fc->cache_buf, page_addr, FLASH_CACHE_SIZE);
29      }
30      memcpy(fc->cache_buf + offset, src8, wr_bytes);
31      src8 += wr_bytes;
32      remain -= wr_bytes;
33      dst += wr_bytes;
34    }
35    return len - remain;
36  }
37  void flash_cache_flush (flash_cache_t* fc)
38  {
39    if ( fc->cache_addr == FLASH_CACHE_INVALID_ADDR ) return;
40    if ( !(fc->verify && fc->verify(fc->cache_addr, fc->cache_buf, FLASH_CACHE_SIZE)) )
41    {
42      ledOn(LED_BUILTIN);
43      fc->erase(fc->cache_addr);
44      fc->program(fc->cache_addr, fc->cache_buf, FLASH_CACHE_SIZE);
45      ledOff(LED_BUILTIN);
46    }
47    fc->cache_addr = FLASH_CACHE_INVALID_ADDR;
48  }
49  int flash_cache_read (flash_cache_t* fc, void* dst, uint32_t addr, uint32_t count)
50  {
51    if ( (fc->cache_addr != FLASH_CACHE_INVALID_ADDR) &&               
52         !(addr < fc->cache_addr && addr + count <= fc->cache_addr) && 
53         !(addr >= fc->cache_addr + FLASH_CACHE_SIZE) )                
54    {
55      uint32_t dst_off = 0;
56      uint32_t src_off = 0;
57      if (addr < fc->cache_addr)
58      {
59        dst_off = fc->cache_addr - addr;
60        fc->read(dst, addr, dst_off);
61      }
62      else
63      {
64        src_off = addr - fc->cache_addr;      
65      }
66      uint32_t cache_bytes = minof(FLASH_CACHE_SIZE-src_off, count - dst_off);
67      memcpy(dst + dst_off, fc->cache_buf + src_off, cache_bytes);
68      uint32_t copied = dst_off + cache_bytes;
69      if ( copied < count )
70      {
71        fc->read(dst + copied, addr + copied, count - copied);
72      }
73    }
74    else
75    {
76      fc->read(dst, addr, count);
77    }
78    return (int) count;
79  }
</code></pre>
        </div>
        <div class="column">
            <h3>PINRemoteImage-MDEwOlJlcG9zaXRvcnkzOTUzNzEwMw==-flat-quant_enc.c</h3>
            <pre><code>1  #include <assert.h>
2  #include <math.h>
3  #include <stdlib.h>  
4  #include "src/dsp/quant.h"
5  #include "src/enc/vp8i_enc.h"
6  #include "src/enc/cost_enc.h"
7  #define DO_TRELLIS_I4  1
8  #define DO_TRELLIS_I16 1   
9  #define DO_TRELLIS_UV  0   
10  #define USE_TDISTO 1
11  #define MID_ALPHA 64      
12  #define MIN_ALPHA 30      
13  #define MAX_ALPHA 100     
14  #define SNS_TO_DQ 0.9     
15  #define FLATNESS_LIMIT_I16 0       
16  #define FLATNESS_LIMIT_I4  3       
17  #define FLATNESS_LIMIT_UV  2       
18  #define FLATNESS_PENALTY   140     
19  #define MULT_8B(a, b) (((a) * (b) + 128) >> 8)
20  #define RD_DISTO_MULT      256  
21  #if defined(DEBUG_BLOCK)
22  #include <stdio.h>
23  #include <stdlib.h>
24  static void PrintBlockInfo(const VP8EncIterator* const it,
25                             const VP8ModeScore* const rd) {
26    int i, j;
27    const int is_i16 = (it->mb_->type_ == 1);
28    const uint8_t* const y_in = it->yuv_in_ + Y_OFF_ENC;
29    const uint8_t* const y_out = it->yuv_out_ + Y_OFF_ENC;
30    const uint8_t* const uv_in = it->yuv_in_ + U_OFF_ENC;
31    const uint8_t* const uv_out = it->yuv_out_ + U_OFF_ENC;
32    printf("SOURCE / OUTPUT / ABS DELTA\n");
33    for (j = 0; j < 16; ++j) {
34      for (i = 0; i < 16; ++i) printf("%3d ", y_in[i + j * BPS]);
35      printf("     ");
36      for (i = 0; i < 16; ++i) printf("%3d ", y_out[i + j * BPS]);
37      printf("     ");
38      for (i = 0; i < 16; ++i) {
39        printf("%1d ", abs(y_in[i + j * BPS] - y_out[i + j * BPS]));
40      }
41      printf("\n");
42    }
43    printf("\n");   
44    for (j = 0; j < 8; ++j) {
45      for (i = 0; i < 8; ++i) printf("%3d ", uv_in[i + j * BPS]);
46      printf(" ");
47      for (i = 8; i < 16; ++i) printf("%3d ", uv_in[i + j * BPS]);
48      printf("    ");
49      for (i = 0; i < 8; ++i) printf("%3d ", uv_out[i + j * BPS]);
50      printf(" ");
51      for (i = 8; i < 16; ++i) printf("%3d ", uv_out[i + j * BPS]);
52      printf("   ");
53      for (i = 0; i < 8; ++i) {
54        printf("%1d ", abs(uv_out[i + j * BPS] - uv_in[i + j * BPS]));
55      }
56      printf(" ");
57      for (i = 8; i < 16; ++i) {
58        printf("%1d ", abs(uv_out[i + j * BPS] - uv_in[i + j * BPS]));
59      }
60      printf("\n");
61    }
62    printf("\nD:%d SD:%d R:%d H:%d nz:0x%x score:%d\n",
63      (int)rd->D, (int)rd->SD, (int)rd->R, (int)rd->H, (int)rd->nz,
64      (int)rd->score);
65    if (is_i16) {
66      printf("Mode: %d\n", rd->mode_i16);
67      printf("y_dc_levels:");
68      for (i = 0; i < 16; ++i) printf("%3d ", rd->y_dc_levels[i]);
69      printf("\n");
70    } else {
71      printf("Modes[16]: ");
72      for (i = 0; i < 16; ++i) printf("%d ", rd->modes_i4[i]);
73      printf("\n");
74    }
75    printf("y_ac_levels:\n");
76    for (j = 0; j < 16; ++j) {
77      for (i = is_i16 ? 1 : 0; i < 16; ++i) {
78        printf("%4d ", rd->y_ac_levels[j][i]);
79      }
80      printf("\n");
81    }
82    printf("\n");
83    printf("uv_levels (mode=%d):\n", rd->mode_uv);
84    for (j = 0; j < 8; ++j) {
85      for (i = 0; i < 16; ++i) {
86        printf("%4d ", rd->uv_levels[j][i]);
87      }
88      printf("\n");
89    }
90  }
91  #endif   
92  static WEBP_INLINE int clip(int v, int m, int M) {
93    return v < m ? m : v > M ? M : v;
94  }
95  static const uint8_t kZigzag[16] = {
96    0, 1, 4, 8, 5, 2, 3, 6, 9, 12, 13, 10, 7, 11, 14, 15
97  };
98  static const uint8_t kDcTable[128] = {
99    4,     5,   6,   7,   8,   9,  10,  10,
100    11,   12,  13,  14,  15,  16,  17,  17,
101    18,   19,  20,  20,  21,  21,  22,  22,
102    23,   23,  24,  25,  25,  26,  27,  28,
103    29,   30,  31,  32,  33,  34,  35,  36,
104    37,   37,  38,  39,  40,  41,  42,  43,
105    44,   45,  46,  46,  47,  48,  49,  50,
106    51,   52,  53,  54,  55,  56,  57,  58,
107    59,   60,  61,  62,  63,  64,  65,  66,
108    67,   68,  69,  70,  71,  72,  73,  74,
109    75,   76,  76,  77,  78,  79,  80,  81,
110    82,   83,  84,  85,  86,  87,  88,  89,
111    91,   93,  95,  96,  98, 100, 101, 102,
112    104, 106, 108, 110, 112, 114, 116, 118,
113    122, 124, 126, 128, 130, 132, 134, 136,
114    138, 140, 143, 145, 148, 151, 154, 157
115  };
116  static const uint16_t kAcTable[128] = {
117    4,     5,   6,   7,   8,   9,  10,  11,
118    12,   13,  14,  15,  16,  17,  18,  19,
119    20,   21,  22,  23,  24,  25,  26,  27,
120    28,   29,  30,  31,  32,  33,  34,  35,
121    36,   37,  38,  39,  40,  41,  42,  43,
122    44,   45,  46,  47,  48,  49,  50,  51,
123    52,   53,  54,  55,  56,  57,  58,  60,
124    62,   64,  66,  68,  70,  72,  74,  76,
125    78,   80,  82,  84,  86,  88,  90,  92,
126    94,   96,  98, 100, 102, 104, 106, 108,
127    110, 112, 114, 116, 119, 122, 125, 128,
128    131, 134, 137, 140, 143, 146, 149, 152,
129    155, 158, 161, 164, 167, 170, 173, 177,
130    181, 185, 189, 193, 197, 201, 205, 209,
131    213, 217, 221, 225, 229, 234, 239, 245,
132    249, 254, 259, 264, 269, 274, 279, 284
133  };
134  static const uint16_t kAcTable2[128] = {
135    8,     8,   9,  10,  12,  13,  15,  17,
136    18,   20,  21,  23,  24,  26,  27,  29,
137    31,   32,  34,  35,  37,  38,  40,  41,
138    43,   44,  46,  48,  49,  51,  52,  54,
139    55,   57,  58,  60,  62,  63,  65,  66,
140    68,   69,  71,  72,  74,  75,  77,  79,
141    80,   82,  83,  85,  86,  88,  89,  93,
142    96,   99, 102, 105, 108, 111, 114, 117,
143    120, 124, 127, 130, 133, 136, 139, 142,
144    145, 148, 151, 155, 158, 161, 164, 167,
145    170, 173, 176, 179, 184, 189, 193, 198,
146    203, 207, 212, 217, 221, 226, 230, 235,
147    240, 244, 249, 254, 258, 263, 268, 274,
148    280, 286, 292, 299, 305, 311, 317, 323,
149    330, 336, 342, 348, 354, 362, 370, 379,
150    385, 393, 401, 409, 416, 424, 432, 440
151  };
152  static const uint8_t kBiasMatrices[3][2] = {  
153    { 96, 110 }, { 96, 108 }, { 110, 115 }
154  };
155  #define SHARPEN_BITS 11  
156  static const uint8_t kFreqSharpening[16] = {
157    0,  30, 60, 90,
158    30, 60, 90, 90,
159    60, 90, 90, 90,
160    90, 90, 90, 90
161  };
162  static int ExpandMatrix(VP8Matrix* const m, int type) {
163    int i, sum;
164    for (i = 0; i < 2; ++i) {
165      const int is_ac_coeff = (i > 0);
166      const int bias = kBiasMatrices[type][is_ac_coeff];
167      m->iq_[i] = (1 << QFIX) / m->q_[i];
168      m->bias_[i] = BIAS(bias);
169      m->zthresh_[i] = ((1 << QFIX) - 1 - m->bias_[i]) / m->iq_[i];
170    }
171    for (i = 2; i < 16; ++i) {
172      m->q_[i] = m->q_[1];
173      m->iq_[i] = m->iq_[1];
174      m->bias_[i] = m->bias_[1];
175      m->zthresh_[i] = m->zthresh_[1];
176    }
177    for (sum = 0, i = 0; i < 16; ++i) {
178      if (type == 0) {  
179        m->sharpen_[i] = (kFreqSharpening[i] * m->q_[i]) >> SHARPEN_BITS;
180      } else {
181        m->sharpen_[i] = 0;
182      }
183      sum += m->q_[i];
184    }
185    return (sum + 8) >> 4;
186  }
187  static void CheckLambdaValue(int* const v) { if (*v < 1) *v = 1; }
188  static void SetupMatrices(VP8Encoder* enc) {
189    int i;
190    const int tlambda_scale =
191      (enc->method_ >= 4) ? enc->config_->sns_strength
192                          : 0;
193    const int num_segments = enc->segment_hdr_.num_segments_;
194    for (i = 0; i < num_segments; ++i) {
195      VP8SegmentInfo* const m = &enc->dqm_[i];
196      const int q = m->quant_;
197      int q_i4, q_i16, q_uv;
198      m->y1_.q_[0] = kDcTable[clip(q + enc->dq_y1_dc_, 0, 127)];
199      m->y1_.q_[1] = kAcTable[clip(q,                  0, 127)];
200      m->y2_.q_[0] = kDcTable[ clip(q + enc->dq_y2_dc_, 0, 127)] * 2;
201      m->y2_.q_[1] = kAcTable2[clip(q + enc->dq_y2_ac_, 0, 127)];
202      m->uv_.q_[0] = kDcTable[clip(q + enc->dq_uv_dc_, 0, 117)];
203      m->uv_.q_[1] = kAcTable[clip(q + enc->dq_uv_ac_, 0, 127)];
204      q_i4  = ExpandMatrix(&m->y1_, 0);
205      q_i16 = ExpandMatrix(&m->y2_, 1);
206      q_uv  = ExpandMatrix(&m->uv_, 2);
207      m->lambda_i4_          = (3 * q_i4 * q_i4) >> 7;
208      m->lambda_i16_         = (3 * q_i16 * q_i16);
209      m->lambda_uv_          = (3 * q_uv * q_uv) >> 6;
210      m->lambda_mode_        = (1 * q_i4 * q_i4) >> 7;
211      m->lambda_trellis_i4_  = (7 * q_i4 * q_i4) >> 3;
212      m->lambda_trellis_i16_ = (q_i16 * q_i16) >> 2;
213      m->lambda_trellis_uv_  = (q_uv * q_uv) << 1;
214      m->tlambda_            = (tlambda_scale * q_i4) >> 5;
215      CheckLambdaValue(&m->lambda_i4_);
216      CheckLambdaValue(&m->lambda_i16_);
217      CheckLambdaValue(&m->lambda_uv_);
218      CheckLambdaValue(&m->lambda_mode_);
219      CheckLambdaValue(&m->lambda_trellis_i4_);
220      CheckLambdaValue(&m->lambda_trellis_i16_);
221      CheckLambdaValue(&m->lambda_trellis_uv_);
222      CheckLambdaValue(&m->tlambda_);
223      m->min_disto_ = 20 * m->y1_.q_[0];   
224      m->max_edge_  = 0;
225      m->i4_penalty_ = 1000 * q_i4 * q_i4;
226    }
227  }
228  #define FSTRENGTH_CUTOFF 2
229  static void SetupFilterStrength(VP8Encoder* const enc) {
230    int i;
231    const int level0 = 5 * enc->config_->filter_strength;
232    for (i = 0; i < NUM_MB_SEGMENTS; ++i) {
233      VP8SegmentInfo* const m = &enc->dqm_[i];
234      const int qstep = kAcTable[clip(m->quant_, 0, 127)] >> 2;
235      const int base_strength =
236          VP8FilterStrengthFromDelta(enc->filter_hdr_.sharpness_, qstep);
237      const int f = base_strength * level0 / (256 + m->beta_);
238      m->fstrength_ = (f < FSTRENGTH_CUTOFF) ? 0 : (f > 63) ? 63 : f;
239    }
240    enc->filter_hdr_.level_ = enc->dqm_[0].fstrength_;
241    enc->filter_hdr_.simple_ = (enc->config_->filter_type == 0);
242    enc->filter_hdr_.sharpness_ = enc->config_->filter_sharpness;
243  }
244  #define MAX_DQ_UV (6)
245  #define MIN_DQ_UV (-4)
246  static double QualityToCompression(double c) {
247    const double linear_c = (c < 0.75) ? c * (2. / 3.) : 2. * c - 1.;
248    const double v = pow(linear_c, 1 / 3.);
249    return v;
250  }
251  static double QualityToJPEGCompression(double c, double alpha) {
252    const double amin = 0.30;
253    const double amax = 0.85;
254    const double exp_min = 0.4;
255    const double exp_max = 0.9;
256    const double slope = (exp_min - exp_max) / (amax - amin);
257    const double expn = (alpha > amax) ? exp_min
258                      : (alpha < amin) ? exp_max
259                      : exp_max + slope * (alpha - amin);
260    const double v = pow(c, expn);
261    return v;
262  }
263  static int SegmentsAreEquivalent(const VP8SegmentInfo* const S1,
264                                   const VP8SegmentInfo* const S2) {
265    return (S1->quant_ == S2->quant_) && (S1->fstrength_ == S2->fstrength_);
266  }
267  static void SimplifySegments(VP8Encoder* const enc) {
268    int map[NUM_MB_SEGMENTS] = { 0, 1, 2, 3 };
269    const int num_segments = (enc->segment_hdr_.num_segments_ < NUM_MB_SEGMENTS)
270                                 ? enc->segment_hdr_.num_segments_
271                                 : NUM_MB_SEGMENTS;
272    int num_final_segments = 1;
273    int s1, s2;
274    for (s1 = 1; s1 < num_segments; ++s1) {    
275      const VP8SegmentInfo* const S1 = &enc->dqm_[s1];
276      int found = 0;
277      for (s2 = 0; s2 < num_final_segments; ++s2) {
278        const VP8SegmentInfo* const S2 = &enc->dqm_[s2];
279        if (SegmentsAreEquivalent(S1, S2)) {
280          found = 1;
281          break;
282        }
283      }
284      map[s1] = s2;
285      if (!found) {
286        if (num_final_segments != s1) {
287          enc->dqm_[num_final_segments] = enc->dqm_[s1];
288        }
289        ++num_final_segments;
290      }
291    }
292    if (num_final_segments < num_segments) {  
293      int i = enc->mb_w_ * enc->mb_h_;
294      while (i-- > 0) enc->mb_info_[i].segment_ = map[enc->mb_info_[i].segment_];
295      enc->segment_hdr_.num_segments_ = num_final_segments;
296      for (i = num_final_segments; i < num_segments; ++i) {
297        enc->dqm_[i] = enc->dqm_[num_final_segments - 1];
298      }
299    }
300  }
301  void VP8SetSegmentParams(VP8Encoder* const enc, float quality) {
302    int i;
303    int dq_uv_ac, dq_uv_dc;
304    const int num_segments = enc->segment_hdr_.num_segments_;
305    const double amp = SNS_TO_DQ * enc->config_->sns_strength / 100. / 128.;
306    const double Q = quality / 100.;
307    const double c_base = enc->config_->emulate_jpeg_size ?
308        QualityToJPEGCompression(Q, enc->alpha_ / 255.) :
309        QualityToCompression(Q);
310    for (i = 0; i < num_segments; ++i) {
311      const double expn = 1. - amp * enc->dqm_[i].alpha_;
312      const double c = pow(c_base, expn);
313      const int q = (int)(127. * (1. - c));
314      assert(expn > 0.);
315      enc->dqm_[i].quant_ = clip(q, 0, 127);
316    }
317    enc->base_quant_ = enc->dqm_[0].quant_;
318    for (i = num_segments; i < NUM_MB_SEGMENTS; ++i) {
319      enc->dqm_[i].quant_ = enc->base_quant_;
320    }
321    dq_uv_ac = (enc->uv_alpha_ - MID_ALPHA) * (MAX_DQ_UV - MIN_DQ_UV)
322                                            / (MAX_ALPHA - MIN_ALPHA);
323    dq_uv_ac = dq_uv_ac * enc->config_->sns_strength / 100;
324    dq_uv_ac = clip(dq_uv_ac, MIN_DQ_UV, MAX_DQ_UV);
325    dq_uv_dc = -4 * enc->config_->sns_strength / 100;
326    dq_uv_dc = clip(dq_uv_dc, -15, 15);   
327    enc->dq_y1_dc_ = 0;       
328    enc->dq_y2_dc_ = 0;
329    enc->dq_y2_ac_ = 0;
330    enc->dq_uv_dc_ = dq_uv_dc;
331    enc->dq_uv_ac_ = dq_uv_ac;
332    SetupFilterStrength(enc);   
333    if (num_segments > 1) SimplifySegments(enc);
334    SetupMatrices(enc);         
335  }
336  const uint16_t VP8I16ModeOffsets[4] = { I16DC16, I16TM16, I16VE16, I16HE16 };
337  const uint16_t VP8UVModeOffsets[4] = { C8DC8, C8TM8, C8VE8, C8HE8 };
338  const uint16_t VP8I4ModeOffsets[NUM_BMODES] = {
339    I4DC4, I4TM4, I4VE4, I4HE4, I4RD4, I4VR4, I4LD4, I4VL4, I4HD4, I4HU4
340  };
341  void VP8MakeLuma16Preds(const VP8EncIterator* const it) {
342    const uint8_t* const left = it->x_ ? it->y_left_ : NULL;
343    const uint8_t* const top = it->y_ ? it->y_top_ : NULL;
344    VP8EncPredLuma16(it->yuv_p_, left, top);
345  }
346  void VP8MakeChroma8Preds(const VP8EncIterator* const it) {
347    const uint8_t* const left = it->x_ ? it->u_left_ : NULL;
348    const uint8_t* const top = it->y_ ? it->uv_top_ : NULL;
349    VP8EncPredChroma8(it->yuv_p_, left, top);
350  }
351  void VP8MakeIntra4Preds(const VP8EncIterator* const it) {
352    VP8EncPredLuma4(it->yuv_p_, it->i4_top_);
353  }
354  const uint16_t VP8Scan[16] = {  
355    0 +  0 * BPS,  4 +  0 * BPS, 8 +  0 * BPS, 12 +  0 * BPS,
356    0 +  4 * BPS,  4 +  4 * BPS, 8 +  4 * BPS, 12 +  4 * BPS,
357    0 +  8 * BPS,  4 +  8 * BPS, 8 +  8 * BPS, 12 +  8 * BPS,
358    0 + 12 * BPS,  4 + 12 * BPS, 8 + 12 * BPS, 12 + 12 * BPS,
359  };
360  static const uint16_t VP8ScanUV[4 + 4] = {
361    0 + 0 * BPS,   4 + 0 * BPS, 0 + 4 * BPS,  4 + 4 * BPS,    
362    8 + 0 * BPS,  12 + 0 * BPS, 8 + 4 * BPS, 12 + 4 * BPS     
363  };
364  static const uint16_t kWeightY[16] = {
365    38, 32, 20, 9, 32, 28, 17, 7, 20, 17, 10, 4, 9, 7, 4, 2
366  };
367  static const uint16_t kWeightTrellis[16] = {
368  #if USE_TDISTO == 0
369    16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16
370  #else
371    30, 27, 19, 11,
372    27, 24, 17, 10,
373    19, 17, 12,  8,
374    11, 10,  8,  6
375  #endif
376  };
377  static void InitScore(VP8ModeScore* const rd) {
378    rd->D  = 0;
379    rd->SD = 0;
380    rd->R  = 0;
381    rd->H  = 0;
382    rd->nz = 0;
383    rd->score = MAX_COST;
384  }
385  static void CopyScore(VP8ModeScore* const dst, const VP8ModeScore* const src) {
386    dst->D  = src->D;
387    dst->SD = src->SD;
388    dst->R  = src->R;
389    dst->H  = src->H;
390    dst->nz = src->nz;      
391    dst->score = src->score;
392  }
393  static void AddScore(VP8ModeScore* const dst, const VP8ModeScore* const src) {
394    dst->D  += src->D;
395    dst->SD += src->SD;
396    dst->R  += src->R;
397    dst->H  += src->H;
398    dst->nz |= src->nz;     
399    dst->score += src->score;
400  }
401  typedef struct {
402    int8_t prev;            
403    int8_t sign;            
404    int16_t level;          
405  } Node;
406  typedef struct {
407    score_t score;          
408    const uint16_t* costs;  
409  } ScoreState;
410  #define MIN_DELTA 0   
411  #define MAX_DELTA 1   
412  #define NUM_NODES (MIN_DELTA + 1 + MAX_DELTA)
413  #define NODE(n, l) (nodes[(n)][(l) + MIN_DELTA])
414  #define SCORE_STATE(n, l) (score_states[n][(l) + MIN_DELTA])
415  static WEBP_INLINE void SetRDScore(int lambda, VP8ModeScore* const rd) {
416    rd->score = (rd->R + rd->H) * lambda + RD_DISTO_MULT * (rd->D + rd->SD);
417  }
418  static WEBP_INLINE score_t RDScoreTrellis(int lambda, score_t rate,
419                                            score_t distortion) {
420    return rate * lambda + RD_DISTO_MULT * distortion;
421  }
422  static int TrellisQuantizeBlock(const VP8Encoder* const enc,
423                                  int16_t in[16], int16_t out[16],
424                                  int ctx0, int coeff_type,
425                                  const VP8Matrix* const mtx,
426                                  int lambda) {
427    const ProbaArray* const probas = enc->proba_.coeffs_[coeff_type];
428    CostArrayPtr const costs =
429        (CostArrayPtr)enc->proba_.remapped_costs_[coeff_type];
430    const int first = (coeff_type == 0) ? 1 : 0;
431    Node nodes[16][NUM_NODES];
432    ScoreState score_states[2][NUM_NODES];
433    ScoreState* ss_cur = &SCORE_STATE(0, MIN_DELTA);
434    ScoreState* ss_prev = &SCORE_STATE(1, MIN_DELTA);
435    int best_path[3] = {-1, -1, -1};   
436    score_t best_score;
437    int n, m, p, last;
438    {
439      score_t cost;
440      const int thresh = mtx->q_[1] * mtx->q_[1] / 4;
441      const int last_proba = probas[VP8EncBands[first]][ctx0][0];
442      last = first - 1;
443      for (n = 15; n >= first; --n) {
444        const int j = kZigzag[n];
445        const int err = in[j] * in[j];
446        if (err > thresh) {
447          last = n;
448          break;
449        }
450      }
451      if (last < 15) ++last;
452      cost = VP8BitCost(0, last_proba);
453      best_score = RDScoreTrellis(lambda, cost, 0);
454      for (m = -MIN_DELTA; m <= MAX_DELTA; ++m) {
455        const score_t rate = (ctx0 == 0) ? VP8BitCost(1, last_proba) : 0;
456        ss_cur[m].score = RDScoreTrellis(lambda, rate, 0);
457        ss_cur[m].costs = costs[first][ctx0];
458      }
459    }
460    for (n = first; n <= last; ++n) {
461      const int j = kZigzag[n];
462      const uint32_t Q  = mtx->q_[j];
463      const uint32_t iQ = mtx->iq_[j];
464      const uint32_t B = BIAS(0x00);     
465      const int sign = (in[j] < 0);
466      const uint32_t coeff0 = (sign ? -in[j] : in[j]) + mtx->sharpen_[j];
467      int level0 = QUANTDIV(coeff0, iQ, B);
468      int thresh_level = QUANTDIV(coeff0, iQ, BIAS(0x80));
469      if (thresh_level > MAX_LEVEL) thresh_level = MAX_LEVEL;
470      if (level0 > MAX_LEVEL) level0 = MAX_LEVEL;
471      {   
472        ScoreState* const tmp = ss_cur;
473        ss_cur = ss_prev;
474        ss_prev = tmp;
475      }
476      for (m = -MIN_DELTA; m <= MAX_DELTA; ++m) {
477        Node* const cur = &NODE(n, m);
478        int level = level0 + m;
479        const int ctx = (level > 2) ? 2 : level;
480        const int band = VP8EncBands[n + 1];
481        score_t base_score;
482        score_t best_cur_score = MAX_COST;
483        int best_prev = 0;   
484        ss_cur[m].score = MAX_COST;
485        ss_cur[m].costs = costs[n + 1][ctx];
486        if (level < 0 || level > thresh_level) {
487          continue;
488        }
489        {
490          const int new_error = coeff0 - level * Q;
491          const int delta_error =
492              kWeightTrellis[j] * (new_error * new_error - coeff0 * coeff0);
493          base_score = RDScoreTrellis(lambda, 0, delta_error);
494        }
495        for (p = -MIN_DELTA; p <= MAX_DELTA; ++p) {
496          const score_t cost = VP8LevelCost(ss_prev[p].costs, level);
497          const score_t score =
498              base_score + ss_prev[p].score + RDScoreTrellis(lambda, cost, 0);
499          if (score < best_cur_score) {
500            best_cur_score = score;
501            best_prev = p;
502          }
503        }
504        cur->sign = sign;
505        cur->level = level;
506        cur->prev = best_prev;
507        ss_cur[m].score = best_cur_score;
508        if (level != 0) {
509          const score_t last_pos_cost =
510              (n < 15) ? VP8BitCost(0, probas[band][ctx][0]) : 0;
511          const score_t last_pos_score = RDScoreTrellis(lambda, last_pos_cost, 0);
512          const score_t score = best_cur_score + last_pos_score;
513          if (score < best_score) {
514            best_score = score;
515            best_path[0] = n;                     
516            best_path[1] = m;                     
517            best_path[2] = best_prev;             
518          }
519        }
520      }
521    }
522    memset(in + first, 0, (16 - first) * sizeof(*in));
523    memset(out + first, 0, (16 - first) * sizeof(*out));
524    if (best_path[0] == -1) {
525      return 0;   
526    }
527    {
528      int nz = 0;
529      int best_node = best_path[1];
530      n = best_path[0];
531      NODE(n, best_node).prev = best_path[2];   
532      for (; n >= first; --n) {
533        const Node* const node = &NODE(n, best_node);
534        const int j = kZigzag[n];
535        out[n] = node->sign ? -node->level : node->level;
536        nz |= node->level;
537        in[j] = out[n] * mtx->q_[j];
538        best_node = node->prev;
539      }
<span onclick='openModal()' class='match'>540      return (nz != 0);
541    }
542  }
543  #undef NODE
544  static int ReconstructIntra16(VP8EncIterator* const it,
545                                VP8ModeScore* const rd,
546                                uint8_t* const yuv_out,
547                                int mode) {
548    const VP8Encoder* const enc = it->enc_;
549    const uint8_t* const ref = it->yuv_p_ + VP8I16ModeOffsets[mode];
</span>550    const uint8_t* const src = it->yuv_in_ + Y_OFF_ENC;
551    const VP8SegmentInfo* const dqm = &enc->dqm_[it->mb_->segment_];
552    int nz = 0;
553    int n;
554    int16_t tmp[16][16], dc_tmp[16];
555    for (n = 0; n < 16; n += 2) {
556      VP8FTransform2(src + VP8Scan[n], ref + VP8Scan[n], tmp[n]);
557    }
558    VP8FTransformWHT(tmp[0], dc_tmp);
559    nz |= VP8EncQuantizeBlockWHT(dc_tmp, rd->y_dc_levels, &dqm->y2_) << 24;
560    if (DO_TRELLIS_I16 && it->do_trellis_) {
561      int x, y;
562      VP8IteratorNzToBytes(it);
563      for (y = 0, n = 0; y < 4; ++y) {
564        for (x = 0; x < 4; ++x, ++n) {
565          const int ctx = it->top_nz_[x] + it->left_nz_[y];
566          const int non_zero =
567              TrellisQuantizeBlock(enc, tmp[n], rd->y_ac_levels[n], ctx, 0,
568                                   &dqm->y1_, dqm->lambda_trellis_i16_);
569          it->top_nz_[x] = it->left_nz_[y] = non_zero;
570          rd->y_ac_levels[n][0] = 0;
571          nz |= non_zero << n;
572        }
573      }
574    } else {
575      for (n = 0; n < 16; n += 2) {
576        tmp[n][0] = tmp[n + 1][0] = 0;
577        nz |= VP8EncQuantize2Blocks(tmp[n], rd->y_ac_levels[n], &dqm->y1_) << n;
578        assert(rd->y_ac_levels[n + 0][0] == 0);
579        assert(rd->y_ac_levels[n + 1][0] == 0);
580      }
581    }
582    VP8TransformWHT(dc_tmp, tmp[0]);
583    for (n = 0; n < 16; n += 2) {
584      VP8ITransform(ref + VP8Scan[n], tmp[n], yuv_out + VP8Scan[n], 1);
585    }
586    return nz;
587  }
588  static int ReconstructIntra4(VP8EncIterator* const it,
589                               int16_t levels[16],
590                               const uint8_t* const src,
591                               uint8_t* const yuv_out,
592                               int mode) {
593    const VP8Encoder* const enc = it->enc_;
594    const uint8_t* const ref = it->yuv_p_ + VP8I4ModeOffsets[mode];
595    const VP8SegmentInfo* const dqm = &enc->dqm_[it->mb_->segment_];
596    int nz = 0;
597    int16_t tmp[16];
598    VP8FTransform(src, ref, tmp);
599    if (DO_TRELLIS_I4 && it->do_trellis_) {
600      const int x = it->i4_ & 3, y = it->i4_ >> 2;
601      const int ctx = it->top_nz_[x] + it->left_nz_[y];
602      nz = TrellisQuantizeBlock(enc, tmp, levels, ctx, 3, &dqm->y1_,
603                                dqm->lambda_trellis_i4_);
604    } else {
605      nz = VP8EncQuantizeBlock(tmp, levels, &dqm->y1_);
606    }
607    VP8ITransform(ref, tmp, yuv_out, 0);
608    return nz;
609  }
610  #define C1 7    
611  #define C2 8    
612  #define DSHIFT 4
613  #define DSCALE 1   
614  static int QuantizeSingle(int16_t* const v, const VP8Matrix* const mtx) {
615    int V = *v;
616    const int sign = (V < 0);
617    if (sign) V = -V;
618    if (V > (int)mtx->zthresh_[0]) {
619      const int qV = QUANTDIV(V, mtx->iq_[0], mtx->bias_[0]) * mtx->q_[0];
620      const int err = (V - qV);
621      *v = sign ? -qV : qV;
622      return (sign ? -err : err) >> DSCALE;
623    }
624    *v = 0;
625    return (sign ? -V : V) >> DSCALE;
626  }
627  static void CorrectDCValues(const VP8EncIterator* const it,
628                              const VP8Matrix* const mtx,
629                              int16_t tmp[][16], VP8ModeScore* const rd) {
630    int ch;
631    for (ch = 0; ch <= 1; ++ch) {
632      const int8_t* const top = it->top_derr_[it->x_][ch];
633      const int8_t* const left = it->left_derr_[ch];
634      int16_t (* const c)[16] = &tmp[ch * 4];
635      int err0, err1, err2, err3;
636      c[0][0] += (C1 * top[0] + C2 * left[0]) >> (DSHIFT - DSCALE);
637      err0 = QuantizeSingle(&c[0][0], mtx);
638      c[1][0] += (C1 * top[1] + C2 * err0) >> (DSHIFT - DSCALE);
639      err1 = QuantizeSingle(&c[1][0], mtx);
640      c[2][0] += (C1 * err0 + C2 * left[1]) >> (DSHIFT - DSCALE);
641      err2 = QuantizeSingle(&c[2][0], mtx);
642      c[3][0] += (C1 * err1 + C2 * err2) >> (DSHIFT - DSCALE);
643      err3 = QuantizeSingle(&c[3][0], mtx);
644      assert(abs(err1) <= 127 && abs(err2) <= 127 && abs(err3) <= 127);
645      rd->derr[ch][0] = (int8_t)err1;
646      rd->derr[ch][1] = (int8_t)err2;
647      rd->derr[ch][2] = (int8_t)err3;
648    }
649  }
650  static void StoreDiffusionErrors(VP8EncIterator* const it,
651                                   const VP8ModeScore* const rd) {
652    int ch;
653    for (ch = 0; ch <= 1; ++ch) {
654      int8_t* const top = it->top_derr_[it->x_][ch];
655      int8_t* const left = it->left_derr_[ch];
656      left[0] = rd->derr[ch][0];            
657      left[1] = 3 * rd->derr[ch][2] >> 2;   
658      top[0]  = rd->derr[ch][1];            
659      top[1]  = rd->derr[ch][2] - left[1];  
660    }
661  }
662  #undef C1
663  #undef C2
664  #undef DSHIFT
665  #undef DSCALE
666  static int ReconstructUV(VP8EncIterator* const it, VP8ModeScore* const rd,
667                           uint8_t* const yuv_out, int mode) {
668    const VP8Encoder* const enc = it->enc_;
669    const uint8_t* const ref = it->yuv_p_ + VP8UVModeOffsets[mode];
670    const uint8_t* const src = it->yuv_in_ + U_OFF_ENC;
671    const VP8SegmentInfo* const dqm = &enc->dqm_[it->mb_->segment_];
672    int nz = 0;
673    int n;
674    int16_t tmp[8][16];
675    for (n = 0; n < 8; n += 2) {
676      VP8FTransform2(src + VP8ScanUV[n], ref + VP8ScanUV[n], tmp[n]);
677    }
678    if (it->top_derr_ != NULL) CorrectDCValues(it, &dqm->uv_, tmp, rd);
679    if (DO_TRELLIS_UV && it->do_trellis_) {
680      int ch, x, y;
681      for (ch = 0, n = 0; ch <= 2; ch += 2) {
682        for (y = 0; y < 2; ++y) {
683          for (x = 0; x < 2; ++x, ++n) {
684            const int ctx = it->top_nz_[4 + ch + x] + it->left_nz_[4 + ch + y];
685            const int non_zero =
686                TrellisQuantizeBlock(enc, tmp[n], rd->uv_levels[n], ctx, 2,
687                                     &dqm->uv_, dqm->lambda_trellis_uv_);
688            it->top_nz_[4 + ch + x] = it->left_nz_[4 + ch + y] = non_zero;
689            nz |= non_zero << n;
690          }
691        }
692      }
693    } else {
694      for (n = 0; n < 8; n += 2) {
695        nz |= VP8EncQuantize2Blocks(tmp[n], rd->uv_levels[n], &dqm->uv_) << n;
696      }
697    }
698    for (n = 0; n < 8; n += 2) {
699      VP8ITransform(ref + VP8ScanUV[n], tmp[n], yuv_out + VP8ScanUV[n], 1);
700    }
701    return (nz << 16);
702  }
703  static void StoreMaxDelta(VP8SegmentInfo* const dqm, const int16_t DCs[16]) {
704    const int v0 = abs(DCs[1]);
705    const int v1 = abs(DCs[2]);
706    const int v2 = abs(DCs[4]);
707    int max_v = (v1 > v0) ? v1 : v0;
708    max_v = (v2 > max_v) ? v2 : max_v;
709    if (max_v > dqm->max_edge_) dqm->max_edge_ = max_v;
710  }
711  static void SwapModeScore(VP8ModeScore** a, VP8ModeScore** b) {
712    VP8ModeScore* const tmp = *a;
713    *a = *b;
714    *b = tmp;
715  }
716  static void SwapPtr(uint8_t** a, uint8_t** b) {
717    uint8_t* const tmp = *a;
718    *a = *b;
719    *b = tmp;
720  }
721  static void SwapOut(VP8EncIterator* const it) {
722    SwapPtr(&it->yuv_out_, &it->yuv_out2_);
723  }
724  static void PickBestIntra16(VP8EncIterator* const it, VP8ModeScore* rd) {
725    const int kNumBlocks = 16;
726    VP8SegmentInfo* const dqm = &it->enc_->dqm_[it->mb_->segment_];
727    const int lambda = dqm->lambda_i16_;
728    const int tlambda = dqm->tlambda_;
729    const uint8_t* const src = it->yuv_in_ + Y_OFF_ENC;
730    VP8ModeScore rd_tmp;
731    VP8ModeScore* rd_cur = &rd_tmp;
732    VP8ModeScore* rd_best = rd;
733    int mode;
734    int is_flat = IsFlatSource16(it->yuv_in_ + Y_OFF_ENC);
735    rd->mode_i16 = -1;
736    for (mode = 0; mode < NUM_PRED_MODES; ++mode) {
737      uint8_t* const tmp_dst = it->yuv_out2_ + Y_OFF_ENC;  
738      rd_cur->mode_i16 = mode;
739      rd_cur->nz = ReconstructIntra16(it, rd_cur, tmp_dst, mode);
740      rd_cur->D = VP8SSE16x16(src, tmp_dst);
741      rd_cur->SD =
742          tlambda ? MULT_8B(tlambda, VP8TDisto16x16(src, tmp_dst, kWeightY)) : 0;
743      rd_cur->H = VP8FixedCostsI16[mode];
744      rd_cur->R = VP8GetCostLuma16(it, rd_cur);
745      if (is_flat) {
746        is_flat = IsFlat(rd_cur->y_ac_levels[0], kNumBlocks, FLATNESS_LIMIT_I16);
747        if (is_flat) {
748          rd_cur->D *= 2;
749          rd_cur->SD *= 2;
750        }
751      }
752      SetRDScore(lambda, rd_cur);
753      if (mode == 0 || rd_cur->score < rd_best->score) {
754        SwapModeScore(&rd_cur, &rd_best);
755        SwapOut(it);
756      }
757    }
758    if (rd_best != rd) {
759      memcpy(rd, rd_best, sizeof(*rd));
760    }
761    SetRDScore(dqm->lambda_mode_, rd);   
762    VP8SetIntra16Mode(it, rd->mode_i16);
763    if ((rd->nz & 0x100ffff) == 0x1000000 && rd->D > dqm->min_disto_) {
764      StoreMaxDelta(dqm, rd->y_dc_levels);
765    }
766  }
767  static const uint16_t* GetCostModeI4(VP8EncIterator* const it,
768                                       const uint8_t modes[16]) {
769    const int preds_w = it->enc_->preds_w_;
770    const int x = (it->i4_ & 3), y = it->i4_ >> 2;
771    const int left = (x == 0) ? it->preds_[y * preds_w - 1] : modes[it->i4_ - 1];
772    const int top = (y == 0) ? it->preds_[-preds_w + x] : modes[it->i4_ - 4];
773    return VP8FixedCostsI4[top][left];
774  }
775  static int PickBestIntra4(VP8EncIterator* const it, VP8ModeScore* const rd) {
776    const VP8Encoder* const enc = it->enc_;
777    const VP8SegmentInfo* const dqm = &enc->dqm_[it->mb_->segment_];
778    const int lambda = dqm->lambda_i4_;
779    const int tlambda = dqm->tlambda_;
780    const uint8_t* const src0 = it->yuv_in_ + Y_OFF_ENC;
781    uint8_t* const best_blocks = it->yuv_out2_ + Y_OFF_ENC;
782    int total_header_bits = 0;
783    VP8ModeScore rd_best;
784    if (enc->max_i4_header_bits_ == 0) {
785      return 0;
786    }
787    InitScore(&rd_best);
788    rd_best.H = 211;  
789    SetRDScore(dqm->lambda_mode_, &rd_best);
790    VP8IteratorStartI4(it);
791    do {
792      const int kNumBlocks = 1;
793      VP8ModeScore rd_i4;
794      int mode;
795      int best_mode = -1;
796      const uint8_t* const src = src0 + VP8Scan[it->i4_];
797      const uint16_t* const mode_costs = GetCostModeI4(it, rd->modes_i4);
798      uint8_t* best_block = best_blocks + VP8Scan[it->i4_];
799      uint8_t* tmp_dst = it->yuv_p_ + I4TMP;    
800      InitScore(&rd_i4);
801      VP8MakeIntra4Preds(it);
802      for (mode = 0; mode < NUM_BMODES; ++mode) {
803        VP8ModeScore rd_tmp;
804        int16_t tmp_levels[16];
805        rd_tmp.nz =
806            ReconstructIntra4(it, tmp_levels, src, tmp_dst, mode) << it->i4_;
807        rd_tmp.D = VP8SSE4x4(src, tmp_dst);
808        rd_tmp.SD =
809            tlambda ? MULT_8B(tlambda, VP8TDisto4x4(src, tmp_dst, kWeightY))
810                    : 0;
811        rd_tmp.H = mode_costs[mode];
812        if (mode > 0 && IsFlat(tmp_levels, kNumBlocks, FLATNESS_LIMIT_I4)) {
813          rd_tmp.R = FLATNESS_PENALTY * kNumBlocks;
814        } else {
815          rd_tmp.R = 0;
816        }
817        SetRDScore(lambda, &rd_tmp);
818        if (best_mode >= 0 && rd_tmp.score >= rd_i4.score) continue;
819        rd_tmp.R += VP8GetCostLuma4(it, tmp_levels);
820        SetRDScore(lambda, &rd_tmp);
821        if (best_mode < 0 || rd_tmp.score < rd_i4.score) {
822          CopyScore(&rd_i4, &rd_tmp);
823          best_mode = mode;
824          SwapPtr(&tmp_dst, &best_block);
825          memcpy(rd_best.y_ac_levels[it->i4_], tmp_levels,
826                 sizeof(rd_best.y_ac_levels[it->i4_]));
827        }
828      }
829      SetRDScore(dqm->lambda_mode_, &rd_i4);
830      AddScore(&rd_best, &rd_i4);
831      if (rd_best.score >= rd->score) {
832        return 0;
833      }
834      total_header_bits += (int)rd_i4.H;   
835      if (total_header_bits > enc->max_i4_header_bits_) {
836        return 0;
837      }
838      if (best_block != best_blocks + VP8Scan[it->i4_]) {
839        VP8Copy4x4(best_block, best_blocks + VP8Scan[it->i4_]);
840      }
841      rd->modes_i4[it->i4_] = best_mode;
842      it->top_nz_[it->i4_ & 3] = it->left_nz_[it->i4_ >> 2] = (rd_i4.nz ? 1 : 0);
843    } while (VP8IteratorRotateI4(it, best_blocks));
844    CopyScore(rd, &rd_best);
845    VP8SetIntra4Mode(it, rd->modes_i4);
846    SwapOut(it);
847    memcpy(rd->y_ac_levels, rd_best.y_ac_levels, sizeof(rd->y_ac_levels));
848    return 1;   
849  }
850  static void PickBestUV(VP8EncIterator* const it, VP8ModeScore* const rd) {
851    const int kNumBlocks = 8;
852    const VP8SegmentInfo* const dqm = &it->enc_->dqm_[it->mb_->segment_];
853    const int lambda = dqm->lambda_uv_;
854    const uint8_t* const src = it->yuv_in_ + U_OFF_ENC;
855    uint8_t* tmp_dst = it->yuv_out2_ + U_OFF_ENC;  
856    uint8_t* dst0 = it->yuv_out_ + U_OFF_ENC;
857    uint8_t* dst = dst0;
858    VP8ModeScore rd_best;
859    int mode;
860    rd->mode_uv = -1;
861    InitScore(&rd_best);
862    for (mode = 0; mode < NUM_PRED_MODES; ++mode) {
863      VP8ModeScore rd_uv;
864      rd_uv.nz = ReconstructUV(it, &rd_uv, tmp_dst, mode);
865      rd_uv.D  = VP8SSE16x8(src, tmp_dst);
866      rd_uv.SD = 0;    
867      rd_uv.H  = VP8FixedCostsUV[mode];
868      rd_uv.R  = VP8GetCostUV(it, &rd_uv);
869      if (mode > 0 && IsFlat(rd_uv.uv_levels[0], kNumBlocks, FLATNESS_LIMIT_UV)) {
870        rd_uv.R += FLATNESS_PENALTY * kNumBlocks;
871      }
872      SetRDScore(lambda, &rd_uv);
873      if (mode == 0 || rd_uv.score < rd_best.score) {
874        CopyScore(&rd_best, &rd_uv);
875        rd->mode_uv = mode;
876        memcpy(rd->uv_levels, rd_uv.uv_levels, sizeof(rd->uv_levels));
877        if (it->top_derr_ != NULL) {
878          memcpy(rd->derr, rd_uv.derr, sizeof(rd_uv.derr));
879        }
880        SwapPtr(&dst, &tmp_dst);
881      }
882    }
883    VP8SetIntraUVMode(it, rd->mode_uv);
884    AddScore(rd, &rd_best);
885    if (dst != dst0) {   
886      VP8Copy16x8(dst, dst0);
887    }
888    if (it->top_derr_ != NULL) {  
889      StoreDiffusionErrors(it, rd);
890    }
891  }
892  static void SimpleQuantize(VP8EncIterator* const it, VP8ModeScore* const rd) {
893    const VP8Encoder* const enc = it->enc_;
894    const int is_i16 = (it->mb_->type_ == 1);
895    int nz = 0;
896    if (is_i16) {
897      nz = ReconstructIntra16(it, rd, it->yuv_out_ + Y_OFF_ENC, it->preds_[0]);
898    } else {
899      VP8IteratorStartI4(it);
900      do {
901        const int mode =
902            it->preds_[(it->i4_ & 3) + (it->i4_ >> 2) * enc->preds_w_];
903        const uint8_t* const src = it->yuv_in_ + Y_OFF_ENC + VP8Scan[it->i4_];
904        uint8_t* const dst = it->yuv_out_ + Y_OFF_ENC + VP8Scan[it->i4_];
905        VP8MakeIntra4Preds(it);
906        nz |= ReconstructIntra4(it, rd->y_ac_levels[it->i4_],
907                                src, dst, mode) << it->i4_;
908      } while (VP8IteratorRotateI4(it, it->yuv_out_ + Y_OFF_ENC));
909    }
910    nz |= ReconstructUV(it, rd, it->yuv_out_ + U_OFF_ENC, it->mb_->uv_mode_);
911    rd->nz = nz;
912  }
913  static void RefineUsingDistortion(VP8EncIterator* const it,
914                                    int try_both_modes, int refine_uv_mode,
915                                    VP8ModeScore* const rd) {
916    score_t best_score = MAX_COST;
917    int nz = 0;
918    int mode;
919    int is_i16 = try_both_modes || (it->mb_->type_ == 1);
920    const VP8SegmentInfo* const dqm = &it->enc_->dqm_[it->mb_->segment_];
921    const int lambda_d_i16 = 106;
922    const int lambda_d_i4 = 11;
923    const int lambda_d_uv = 120;
924    score_t score_i4 = dqm->i4_penalty_;
925    score_t i4_bit_sum = 0;
926    const score_t bit_limit = try_both_modes ? it->enc_->mb_header_limit_
927                                             : MAX_COST;  
928    if (is_i16) {   
929      int best_mode = -1;
930      const uint8_t* const src = it->yuv_in_ + Y_OFF_ENC;
931      for (mode = 0; mode < NUM_PRED_MODES; ++mode) {
932        const uint8_t* const ref = it->yuv_p_ + VP8I16ModeOffsets[mode];
933        const score_t score = (score_t)VP8SSE16x16(src, ref) * RD_DISTO_MULT
934                            + VP8FixedCostsI16[mode] * lambda_d_i16;
935        if (mode > 0 && VP8FixedCostsI16[mode] > bit_limit) {
936          continue;
937        }
938        if (score < best_score) {
939          best_mode = mode;
940          best_score = score;
941        }
942      }
943      if (it->x_ == 0 || it->y_ == 0) {
944        if (IsFlatSource16(src)) {
945          best_mode = (it->x_ == 0) ? 0 : 2;
946          try_both_modes = 0;  
947        }
948      }
949      VP8SetIntra16Mode(it, best_mode);
950    }
951    if (try_both_modes || !is_i16) {
952      is_i16 = 0;
953      VP8IteratorStartI4(it);
954      do {
955        int best_i4_mode = -1;
956        score_t best_i4_score = MAX_COST;
957        const uint8_t* const src = it->yuv_in_ + Y_OFF_ENC + VP8Scan[it->i4_];
958        const uint16_t* const mode_costs = GetCostModeI4(it, rd->modes_i4);
959        VP8MakeIntra4Preds(it);
960        for (mode = 0; mode < NUM_BMODES; ++mode) {
961          const uint8_t* const ref = it->yuv_p_ + VP8I4ModeOffsets[mode];
962          const score_t score = VP8SSE4x4(src, ref) * RD_DISTO_MULT
963                              + mode_costs[mode] * lambda_d_i4;
964          if (score < best_i4_score) {
965            best_i4_mode = mode;
966            best_i4_score = score;
967          }
968        }
969        i4_bit_sum += mode_costs[best_i4_mode];
970        rd->modes_i4[it->i4_] = best_i4_mode;
971        score_i4 += best_i4_score;
972        if (score_i4 >= best_score || i4_bit_sum > bit_limit) {
973          is_i16 = 1;
974          break;
975        } else {  
976          uint8_t* const tmp_dst = it->yuv_out2_ + Y_OFF_ENC + VP8Scan[it->i4_];
977          nz |= ReconstructIntra4(it, rd->y_ac_levels[it->i4_],
978                                  src, tmp_dst, best_i4_mode) << it->i4_;
979        }
980      } while (VP8IteratorRotateI4(it, it->yuv_out2_ + Y_OFF_ENC));
981    }
982    if (!is_i16) {
983      VP8SetIntra4Mode(it, rd->modes_i4);
984      SwapOut(it);
985      best_score = score_i4;
986    } else {
987      nz = ReconstructIntra16(it, rd, it->yuv_out_ + Y_OFF_ENC, it->preds_[0]);
988    }
989    if (refine_uv_mode) {
990      int best_mode = -1;
991      score_t best_uv_score = MAX_COST;
992      const uint8_t* const src = it->yuv_in_ + U_OFF_ENC;
993      for (mode = 0; mode < NUM_PRED_MODES; ++mode) {
994        const uint8_t* const ref = it->yuv_p_ + VP8UVModeOffsets[mode];
995        const score_t score = VP8SSE16x8(src, ref) * RD_DISTO_MULT
996                            + VP8FixedCostsUV[mode] * lambda_d_uv;
997        if (score < best_uv_score) {
998          best_mode = mode;
999          best_uv_score = score;
1000        }
1001      }
1002      VP8SetIntraUVMode(it, best_mode);
1003    }
1004    nz |= ReconstructUV(it, rd, it->yuv_out_ + U_OFF_ENC, it->mb_->uv_mode_);
1005    rd->nz = nz;
1006    rd->score = best_score;
1007  }
1008  int VP8Decimate(VP8EncIterator* const it, VP8ModeScore* const rd,
1009                  VP8RDLevel rd_opt) {
1010    int is_skipped;
1011    const int method = it->enc_->method_;
1012    InitScore(rd);
1013    VP8MakeLuma16Preds(it);
1014    VP8MakeChroma8Preds(it);
1015    if (rd_opt > RD_OPT_NONE) {
1016      it->do_trellis_ = (rd_opt >= RD_OPT_TRELLIS_ALL);
1017      PickBestIntra16(it, rd);
1018      if (method >= 2) {
1019        PickBestIntra4(it, rd);
1020      }
1021      PickBestUV(it, rd);
1022      if (rd_opt == RD_OPT_TRELLIS) {   
1023        it->do_trellis_ = 1;
1024        SimpleQuantize(it, rd);
1025      }
1026    } else {
1027      RefineUsingDistortion(it, (method >= 2), (method >= 1), rd);
1028    }
1029    is_skipped = (rd->nz == 0);
1030    VP8SetSkip(it, is_skipped);
1031    return is_skipped;
1032  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from Adafruit_nRF52_Arduino-MDEwOlJlcG9zaXRvcnk3NDM1NDcyOQ==-flat-flash_cache.c</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from PINRemoteImage-MDEwOlJlcG9zaXRvcnkzOTUzNzEwMw==-flat-quant_enc.c</div>
                </div>
                <div class="column column_space"><pre><code>12    return addr & (FLASH_CACHE_SIZE - 1);
13  }
14  int flash_cache_write (flash_cache_t* fc, uint32_t dst, void const * src, uint32_t len)
15  {
16    uint8_t const * src8 = (uint8_t const *) src;
</pre></code></div>
                <div class="column column_space"><pre><code>540      return (nz != 0);
541    }
542  }
543  #undef NODE
544  static int ReconstructIntra16(VP8EncIterator* const it,
545                                VP8ModeScore* const rd,
546                                uint8_t* const yuv_out,
547                                int mode) {
548    const VP8Encoder* const enc = it->enc_;
549    const uint8_t* const ref = it->yuv_p_ + VP8I16ModeOffsets[mode];
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    