
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 2.359882005899705%, Tokens: 8, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>PINRemoteImage-MDEwOlJlcG9zaXRvcnkzOTUzNzEwMw==-flat-libwebp_go_wrap.c</h3>
            <pre><code>1  #define SWIGMODULE libwebp
2  #ifndef SWIGTEMPLATEDISAMBIGUATOR
3  # if defined(__SUNPRO_CC) && (__SUNPRO_CC <= 0x560)
4  #  define SWIGTEMPLATEDISAMBIGUATOR template
5  # elif defined(__HP_aCC)
6  #  define SWIGTEMPLATEDISAMBIGUATOR template
7  # else
8  #  define SWIGTEMPLATEDISAMBIGUATOR
9  # endif
10  #endif
11  #ifndef SWIGINLINE
12  # if defined(__cplusplus) || (defined(__GNUC__) && !defined(__STRICT_ANSI__))
13  #   define SWIGINLINE inline
14  # else
15  #   define SWIGINLINE
16  # endif
17  #endif
18  #ifndef SWIGUNUSED
19  # if defined(__GNUC__)
20  #   if !(defined(__cplusplus)) || (__GNUC__ > 3 || (__GNUC__ == 3 && __GNUC_MINOR__ >= 4))
21  #     define SWIGUNUSED __attribute__ ((__unused__))
22  #   else
23  #     define SWIGUNUSED
24  #   endif
25  # elif defined(__ICC)
26  #   define SWIGUNUSED __attribute__ ((__unused__))
27  # else
28  #   define SWIGUNUSED
29  # endif
30  #endif
31  #ifndef SWIG_MSC_UNSUPPRESS_4505
32  # if defined(_MSC_VER)
33  #   pragma warning(disable : 4505) &bsol;* unreferenced local function has been removed */
34  # endif
35  #endif
36  #ifndef SWIGUNUSEDPARM
37  # ifdef __cplusplus
38  #   define SWIGUNUSEDPARM(p)
39  # else
40  #   define SWIGUNUSEDPARM(p) p SWIGUNUSED
41  # endif
42  #endif
43  #ifndef SWIGINTERN
44  # define SWIGINTERN static SWIGUNUSED
45  #endif
46  #ifndef SWIGINTERNINLINE
47  # define SWIGINTERNINLINE SWIGINTERN SWIGINLINE
48  #endif
49  #if (__GNUC__ >= 4) || (__GNUC__ == 3 && __GNUC_MINOR__ >= 4)
50  #  ifndef GCC_HASCLASSVISIBILITY
51  #    define GCC_HASCLASSVISIBILITY
52  #  endif
53  #endif
54  #ifndef SWIGEXPORT
55  # if defined(_WIN32) || defined(__WIN32__) || defined(__CYGWIN__)
56  #   if defined(STATIC_LINKED)
57  #     define SWIGEXPORT
58  #   else
59  #     define SWIGEXPORT __declspec(dllexport)
60  #   endif
61  # else
62  #   if defined(__GNUC__) && defined(GCC_HASCLASSVISIBILITY)
63  #     define SWIGEXPORT __attribute__ ((visibility("default")))
64  #   else
65  #     define SWIGEXPORT
66  #   endif
67  # endif
68  #endif
69  #ifndef SWIGSTDCALL
70  # if defined(_WIN32) || defined(__WIN32__) || defined(__CYGWIN__)
71  #   define SWIGSTDCALL __stdcall
72  # else
73  #   define SWIGSTDCALL
74  # endif
75  #endif
76  #if !defined(SWIG_NO_CRT_SECURE_NO_DEPRECATE) && defined(_MSC_VER) && !defined(_CRT_SECURE_NO_DEPRECATE)
77  # define _CRT_SECURE_NO_DEPRECATE
78  #endif
79  #if !defined(SWIG_NO_SCL_SECURE_NO_DEPRECATE) && defined(_MSC_VER) && !defined(_SCL_SECURE_NO_DEPRECATE)
80  # define _SCL_SECURE_NO_DEPRECATE
81  #endif
82  #include <stddef.h>
83  #include <stdio.h>
84  #include <stdlib.h>
85  #include <string.h>
86  #include <sys/types.h>
87  typedef long long intgo;
88  typedef unsigned long long uintgo;
89  typedef struct { char *p; intgo n; } _gostring_;
90  typedef struct { void* array; intgo len; intgo cap; } _goslice_;
91  #define swiggo_size_assert_eq(x, y, name) typedef char name[(x-y)*(x-y)*-2+1];
92  #define swiggo_size_assert(t, n) swiggo_size_assert_eq(sizeof(t), n, swiggo_sizeof_##t##_is_not_##n)
93  swiggo_size_assert(char, 1)
94  swiggo_size_assert(short, 2)
95  swiggo_size_assert(int, 4)
96  typedef long long swiggo_long_long;
97  swiggo_size_assert(swiggo_long_long, 8)
98  swiggo_size_assert(float, 4)
99  swiggo_size_assert(double, 8)
100  #ifdef __cplusplus
101  extern "C" {
102  #endif
103  extern void crosscall2(void (*fn)(void *, int), void *, int);
104  extern void _cgo_allocate(void *, int);
105  extern void _cgo_panic(void *, int);
106  #ifdef __cplusplus
107  }
108  #endif
109  static void *_swig_goallocate(size_t len) {
110    struct {
111      size_t len;
112      void *ret;
113    } a;
114    a.len = len;
115    crosscall2(_cgo_allocate, &a, (int) sizeof a);
116    return a.ret;
117  }
118  static void _swig_gopanic(const char *p) {
119    struct {
120      const char *p;
121    } a;
122    a.p = p;
<span onclick='openModal()' class='match'>123    crosscall2(_cgo_panic, &a, (int) sizeof a);
124  }
125  static _gostring_ _swig_makegostring(const char *p, size_t l) {
126    _gostring_ ret;
127    ret.p = (char*)_swig_goallocate(l + 1);
</span>128    memcpy(ret.p, p, l);
129    ret.n = l;
130    return ret;
131  }
132  #define SWIG_contract_assert(expr, msg) \
133    if (!(expr)) { _swig_gopanic(msg); } else
134  #define SWIG_exception(code, msg) _swig_gopanic(msg)
135  #include "webp/decode.h"
136  #include "webp/encode.h"
137  #ifdef __cplusplus
138  extern "C" {
139  #endif
140  void
141  _wrap_WebPGetDecoderVersion(void *swig_v)
142  {
143    int result;
144    struct swigargs {
145      long : 0;
146      intgo result;
147    } *swig_a = (struct swigargs *) swig_v;
148    result = (int)WebPGetDecoderVersion();
149    swig_a->result = result;
150  }
151  void
152  _wrap_wrapped_WebPGetInfo(void *swig_v)
153  {
154    uint8_t *arg1 = (uint8_t *) 0 ;
155    size_t arg2 ;
156    int *arg3 = (int *) 0 ;
157    int *arg4 = (int *) 0 ;
158    int temp3 ;
159    int temp4 ;
160    int result;
161    struct swigargs {
162      _gostring_ arg1;
163      _goslice_ arg3;
164      _goslice_ arg4;
165      long : 0;
166      intgo result;
167    } *swig_a = (struct swigargs *) swig_v;
168    arg1 = (uint8_t *)swig_a->arg1.p;
169    arg2 = (size_t)swig_a->arg1.n;
170    {
171      if (swig_a->arg3.len == 0) {
172        _swig_gopanic("array must contain at least 1 element");
173      }
174      arg3 = &temp3;
175    }
176    {
177      if (swig_a->arg4.len == 0) {
178        _swig_gopanic("array must contain at least 1 element");
179      }
180      arg4 = &temp4;
181    }
182    result = (int)WebPGetInfo((uint8_t const *)arg1,arg2,arg3,arg4);
183    swig_a->result = result;
184    {
185      int* a = (int *) swig_a->arg3.array;
186      a[0] = temp3;
187    }
188    {
189      int* a = (int *) swig_a->arg4.array;
190      a[0] = temp4;
191    }
192  }
193  #ifdef __cplusplus
194  }
195  #endif
</code></pre>
        </div>
        <div class="column">
            <h3>redis-MDEwOlJlcG9zaXRvcnkxMDgxMTA3MDY=-flat-test_25.c</h3>
            <pre><code>1  #include "fmacros.h"
2  #include <stdio.h>
3  #include <stdlib.h>
4  #include <string.h>
5  #ifndef _WIN32
6  #include <strings.h>
7  #include <sys/time.h>
8  #else
9  #include <WinSock2.h>
10  #include "../../src/Win32_Interop/Win32_Time.h"
11  #endif
12  #include <assert.h>
13  #ifndef _WIN32
14  #include <unistd.h>
15  #endif
16  #include <signal.h>
17  #include <errno.h>
18  #include <limits.h>
19  #include "hiredis.h"
20  #ifdef _WIN32
21  #define strcasecmp _stricmp
22  #define strncasecmp _strnicmp
23  #define SIGPIPE 13
24  #endif
25  enum connection_type {
26      CONN_TCP,
27      CONN_UNIX,
28      CONN_FD
29  };
30  struct config {
31      enum connection_type type;
32      struct {
33          const char *host;
34          int port;
35          struct timeval timeout;
36      } tcp;
37      struct {
38          const char *path;
39      } unix_sock;
40  };
41  static int tests = 0, fails = 0;
42  #define test(_s) { printf("#%02d ", ++tests); printf(_s); }
43  #define test_cond(_c) if(_c) printf("\033[0;32mPASSED\033[0;0m\n"); else {printf("\033[0;31mFAILED\033[0;0m\n"); fails++;}
44  static PORT_LONGLONG usec(void) {
45      struct timeval tv;
46      gettimeofday(&tv,NULL);
47      return (((PORT_LONGLONG)tv.tv_sec)*1000000)+tv.tv_usec;
48  }
49  #ifdef NDEBUG
50  #undef assert
51  #define assert(e) (void)(e)
52  #endif
53  static redisContext *select_database(redisContext *c) {
54      redisReply *reply;
55      reply = redisCommand(c,"SELECT 9");
56      assert(reply != NULL);
57      freeReplyObject(reply);
58      reply = redisCommand(c,"DBSIZE");
59      assert(reply != NULL);
60      if (reply->type == REDIS_REPLY_INTEGER && reply->integer == 0) {
61          freeReplyObject(reply);
62      } else {
63          printf("Database #9 is not empty, test can not continue\n");
64          exit(1);
65      }
66      return c;
67  }
68  static int disconnect(redisContext *c, int keep_fd) {
69      redisReply *reply;
70      reply = redisCommand(c,"SELECT 9");
71      assert(reply != NULL);
72      freeReplyObject(reply);
73      reply = redisCommand(c,"FLUSHDB");
74      assert(reply != NULL);
75      freeReplyObject(reply);
76      if (keep_fd)
77          return redisFreeKeepFd(c);
78      redisFree(c);
79      return -1;
80  }
81  #ifdef _WIN32
82  static redisContext *_connect(struct config config) {
83  #else
84  static redisContext *connect(struct config config) {
85  #endif
86      redisContext *c = NULL;
87      if (config.type == CONN_TCP) {
88          c = redisConnect(config.tcp.host, config.tcp.port);
89      } else if (config.type == CONN_UNIX) {
90          c = redisConnectUnix(config.unix_sock.path);
91      } else if (config.type == CONN_FD) {
92          redisContext *dummy_ctx = redisConnectUnix(config.unix_sock.path);
93          if (dummy_ctx) {
94              int fd = disconnect(dummy_ctx, 1);
95              printf("Connecting to inherited fd %d\n", fd);
96              c = redisConnectFd(fd);
97          }
98      } else {
99          assert(NULL);
100      }
101      if (c == NULL) {
102          printf("Connection error: can't allocate redis context\n");
103          exit(1);
104      } else if (c->err) {
105          printf("Connection error: %s\n", c->errstr);
106          redisFree(c);
107          exit(1);
108      }
109      return select_database(c);
110  }
111  static void test_format_commands(void) {
112      char *cmd;
113      int len;
114      test("Format command without interpolation: ");
115      len = redisFormatCommand(&cmd,"SET foo bar");
116      test_cond(strncmp(cmd,"*3\r\n$3\r\nSET\r\n$3\r\nfoo\r\n$3\r\nbar\r\n",len) == 0 &&
117          len == 4+4+(3+2)+4+(3+2)+4+(3+2));
118      free(cmd);
119      test("Format command with %%s string interpolation: ");
120      len = redisFormatCommand(&cmd,"SET %s %s","foo","bar");
121      test_cond(strncmp(cmd,"*3\r\n$3\r\nSET\r\n$3\r\nfoo\r\n$3\r\nbar\r\n",len) == 0 &&
122          len == 4+4+(3+2)+4+(3+2)+4+(3+2));
123      free(cmd);
124      test("Format command with %%s and an empty string: ");
125      len = redisFormatCommand(&cmd,"SET %s %s","foo","");
126      test_cond(strncmp(cmd,"*3\r\n$3\r\nSET\r\n$3\r\nfoo\r\n$0\r\n\r\n",len) == 0 &&
127          len == 4+4+(3+2)+4+(3+2)+4+(0+2));
128      free(cmd);
129      test("Format command with an empty string in between proper interpolations: ");
130      len = redisFormatCommand(&cmd,"SET %s %s","","foo");
131      test_cond(strncmp(cmd,"*3\r\n$3\r\nSET\r\n$0\r\n\r\n$3\r\nfoo\r\n",len) == 0 &&
132          len == 4+4+(3+2)+4+(0+2)+4+(3+2));
133      free(cmd);
134      test("Format command with %%b string interpolation: ");
135      len = redisFormatCommand(&cmd,"SET %b %b","foo",(size_t)3,"b\0r",(size_t)3);
136      test_cond(strncmp(cmd,"*3\r\n$3\r\nSET\r\n$3\r\nfoo\r\n$3\r\nb\0r\r\n",len) == 0 &&
137          len == 4+4+(3+2)+4+(3+2)+4+(3+2));
138      free(cmd);
139      test("Format command with %%b and an empty string: ");
140      len = redisFormatCommand(&cmd,"SET %b %b","foo",(size_t)3,"",(size_t)0);
141      test_cond(strncmp(cmd,"*3\r\n$3\r\nSET\r\n$3\r\nfoo\r\n$0\r\n\r\n",len) == 0 &&
142          len == 4+4+(3+2)+4+(3+2)+4+(0+2));
143      free(cmd);
144      test("Format command with literal %%: ");
145      len = redisFormatCommand(&cmd,"SET %% %%");
146      test_cond(strncmp(cmd,"*3\r\n$3\r\nSET\r\n$1\r\n%\r\n$1\r\n%\r\n",len) == 0 &&
147          len == 4+4+(3+2)+4+(1+2)+4+(1+2));
148      free(cmd);
149  #define INTEGER_WIDTH_TEST(fmt, type) do {                                                \
150      type value = 123;                                                                     \
151      test("Format command with printf-delegation (" #type "): ");                          \
152      len = redisFormatCommand(&cmd,"key:%08" fmt " str:%s", value, "hello");               \
153      test_cond(strncmp(cmd,"*2\r\n$12\r\nkey:00000123\r\n$9\r\nstr:hello\r\n",len) == 0 && \
154          len == 4+5+(12+2)+4+(9+2));                                                       \
155      free(cmd);                                                                            \
156  } while(0)
157  #define FLOAT_WIDTH_TEST(type) do {                                                       \
158      type value = 123.0;                                                                   \
159      test("Format command with printf-delegation (" #type "): ");                          \
160      len = redisFormatCommand(&cmd,"key:%08.3f str:%s", value, "hello");                   \
161      test_cond(strncmp(cmd,"*2\r\n$12\r\nkey:0123.000\r\n$9\r\nstr:hello\r\n",len) == 0 && \
162          len == 4+5+(12+2)+4+(9+2));                                                       \
163      free(cmd);                                                                            \
164  } while(0)
165      INTEGER_WIDTH_TEST("d", int);
166      INTEGER_WIDTH_TEST("hhd", char);
167      INTEGER_WIDTH_TEST("hd", short);
168      INTEGER_WIDTH_TEST("ld", PORT_LONG);
169      INTEGER_WIDTH_TEST("lld", PORT_LONGLONG);
170      INTEGER_WIDTH_TEST("u", unsigned int);
171      INTEGER_WIDTH_TEST("hhu", unsigned char);
172      INTEGER_WIDTH_TEST("hu", unsigned short);
173      INTEGER_WIDTH_TEST("lu", PORT_ULONG);
174      INTEGER_WIDTH_TEST("llu", PORT_ULONGLONG);
175      FLOAT_WIDTH_TEST(float);
176      FLOAT_WIDTH_TEST(double);
177      test("Format command with invalid printf format: ");
178      len = redisFormatCommand(&cmd,"key:%08p %b",(void*)1234,"foo",(size_t)3);
179      test_cond(len == -1);
180      const char *argv[3];
181      argv[0] = "SET";
182      argv[1] = "foo\0xxx";
183      argv[2] = "bar";
184      size_t lens[3] = { 3, 7, 3 };
185      int argc = 3;
186      test("Format command by passing argc/argv without lengths: ");
187      len = redisFormatCommandArgv(&cmd,argc,argv,NULL);
188      test_cond(strncmp(cmd,"*3\r\n$3\r\nSET\r\n$3\r\nfoo\r\n$3\r\nbar\r\n",len) == 0 &&
189          len == 4+4+(3+2)+4+(3+2)+4+(3+2));
190      free(cmd);
191      test("Format command by passing argc/argv with lengths: ");
192      len = redisFormatCommandArgv(&cmd,argc,argv,lens);
193      test_cond(strncmp(cmd,"*3\r\n$3\r\nSET\r\n$7\r\nfoo\0xxx\r\n$3\r\nbar\r\n",len) == 0 &&
194          len == 4+4+(3+2)+4+(7+2)+4+(3+2));
195      free(cmd);
196      sds sds_cmd;
197      sds_cmd = sdsempty();
198      test("Format command into sds by passing argc/argv without lengths: ");
199      len = redisFormatSdsCommandArgv(&sds_cmd,argc,argv,NULL);
200      test_cond(strncmp(sds_cmd,"*3\r\n$3\r\nSET\r\n$3\r\nfoo\r\n$3\r\nbar\r\n",len) == 0 &&
201          len == 4+4+(3+2)+4+(3+2)+4+(3+2));
202      sdsfree(sds_cmd);
203      sds_cmd = sdsempty();
204      test("Format command into sds by passing argc/argv with lengths: ");
205      len = redisFormatSdsCommandArgv(&sds_cmd,argc,argv,lens);
206      test_cond(strncmp(sds_cmd,"*3\r\n$3\r\nSET\r\n$7\r\nfoo\0xxx\r\n$3\r\nbar\r\n",len) == 0 &&
207          len == 4+4+(3+2)+4+(7+2)+4+(3+2));
208      sdsfree(sds_cmd);
209  }
210  static void test_append_formatted_commands(struct config config) {
211      redisContext *c;
212      redisReply *reply;
213      char *cmd;
214      int len;
215      c = IF_WIN32(_connect,connect)(config);
216      test("Append format command: ");
217      len = redisFormatCommand(&cmd, "SET foo bar");
218      test_cond(redisAppendFormattedCommand(c, cmd, len) == REDIS_OK);
219      assert(redisGetReply(c, (void*)&reply) == REDIS_OK);
220      free(cmd);
221      freeReplyObject(reply);
222      disconnect(c, 0);
223  }
224  static void test_reply_reader(void) {
225      redisReader *reader;
226      void *reply;
227      int ret;
228      int i;
229      test("Error handling in reply parser: ");
230      reader = redisReaderCreate();
231      redisReaderFeed(reader,(char*)"@foo\r\n",6);
232      ret = redisReaderGetReply(reader,NULL);
233      test_cond(ret == REDIS_ERR &&
234                strcasecmp(reader->errstr,"Protocol error, got \"@\" as reply type byte") == 0);
235      redisReaderFree(reader);
236      test("Memory cleanup in reply parser: ");
237      reader = redisReaderCreate();
238      redisReaderFeed(reader,(char*)"*2\r\n",4);
239      redisReaderFeed(reader,(char*)"$5\r\nhello\r\n",11);
240      redisReaderFeed(reader,(char*)"@foo\r\n",6);
241      ret = redisReaderGetReply(reader,NULL);
242      test_cond(ret == REDIS_ERR &&
243                strcasecmp(reader->errstr,"Protocol error, got \"@\" as reply type byte") == 0);
244      redisReaderFree(reader);
245      test("Set error on nested multi bulks with depth > 7: ");
246      reader = redisReaderCreate();
247      for (i = 0; i < 9; i++) {
248          redisReaderFeed(reader,(char*)"*1\r\n",4);
249      }
250      ret = redisReaderGetReply(reader,NULL);
251      test_cond(ret == REDIS_ERR &&
252                strncasecmp(reader->errstr,"No support for",14) == 0);
253      redisReaderFree(reader);
254      test("Works with NULL functions for reply: ");
255      reader = redisReaderCreate();
256      reader->fn = NULL;
257      redisReaderFeed(reader,(char*)"+OK\r\n",5);
258      ret = redisReaderGetReply(reader,&reply);
259      test_cond(ret == REDIS_OK && reply == (void*)REDIS_REPLY_STATUS);
260      redisReaderFree(reader);
261      test("Works when a single newline (\\r\\n) covers two calls to feed: ");
262      reader = redisReaderCreate();
263      reader->fn = NULL;
264      redisReaderFeed(reader,(char*)"+OK\r",4);
265      ret = redisReaderGetReply(reader,&reply);
266      assert(ret == REDIS_OK && reply == NULL);
267      redisReaderFeed(reader,(char*)"\n",1);
268      ret = redisReaderGetReply(reader,&reply);
269      test_cond(ret == REDIS_OK && reply == (void*)REDIS_REPLY_STATUS);
270      redisReaderFree(reader);
271      test("Don't reset state after protocol error: ");
272      reader = redisReaderCreate();
273      reader->fn = NULL;
274      redisReaderFeed(reader,(char*)"x",1);
275      ret = redisReaderGetReply(reader,&reply);
276      assert(ret == REDIS_ERR);
277      ret = redisReaderGetReply(reader,&reply);
278      test_cond(ret == REDIS_ERR && reply == NULL);
279      redisReaderFree(reader);
280      test("Don't do empty allocation for empty multi bulk: ");
281      reader = redisReaderCreate();
282      redisReaderFeed(reader,(char*)"*0\r\n",4);
283      ret = redisReaderGetReply(reader,&reply);
284      test_cond(ret == REDIS_OK &&
285          ((redisReply*)reply)->type == REDIS_REPLY_ARRAY &&
286          ((redisReply*)reply)->elements == 0);
287      freeReplyObject(reply);
288      redisReaderFree(reader);
289  }
290  static void test_free_null(void) {
291      void *redisCtx = NULL;
292      void *reply = NULL;
293      test("Don't fail when redisFree is passed a NULL value: ");
294      redisFree(redisCtx);
295      test_cond(redisCtx == NULL);
296      test("Don't fail when freeReplyObject is passed a NULL value: ");
297      freeReplyObject(reply);
298      test_cond(reply == NULL);
299  }
300  static void test_blocking_connection_errors(void) {
301      redisContext *c;
302      test("Returns error when host cannot be resolved: ");
303      c = redisConnect((char*)"idontexist.test", 6379);
304      test_cond(c->err == REDIS_ERR_OTHER &&
305          (strcmp(c->errstr,"Name or service not known") == 0 ||
306           strcmp(c->errstr,"Can't resolve: idontexist.test") == 0 ||
307           strcmp(c->errstr,"nodename nor servname provided, or not known") == 0 ||
308           strcmp(c->errstr,"No address associated with hostname") == 0 ||
309           strcmp(c->errstr,"Temporary failure in name resolution") == 0 ||
310           strcmp(c->errstr,"hostname nor servname provided, or not known") == 0 ||
311           strcmp(c->errstr,"no address associated with name") == 0));
312      redisFree(c);
313      test("Returns error when the port is not open: ");
314      c = redisConnect((char*)"localhost", 1);
315      test_cond(c->err == REDIS_ERR_IO &&
316          strcmp(c->errstr,"Connection refused") == 0);
317      redisFree(c);
318      test("Returns error when the unix_sock socket path doesn't accept connections: ");
319      c = redisConnectUnix((char*)"/tmp/idontexist.sock");
320      test_cond(c->err == REDIS_ERR_IO); &bsol;* Don't care about the message... */
<span onclick='openModal()' class='match'>321      redisFree(c);
322  }
323  static void test_blocking_connection(struct config config) {
324      redisContext *c;
325      redisReply *reply;
326      c = IF_WIN32(_connect,connect)(config);
</span>327      test("Is able to deliver commands: ");
328      reply = redisCommand(c,"PING");
329      test_cond(reply->type == REDIS_REPLY_STATUS &&
330          strcasecmp(reply->str,"pong") == 0)
331      freeReplyObject(reply);
332      test("Is a able to send commands verbatim: ");
333      reply = redisCommand(c,"SET foo bar");
334      test_cond (reply->type == REDIS_REPLY_STATUS &&
335          strcasecmp(reply->str,"ok") == 0)
336      freeReplyObject(reply);
337      test("%%s String interpolation works: ");
338      reply = redisCommand(c,"SET %s %s","foo","hello world");
339      freeReplyObject(reply);
340      reply = redisCommand(c,"GET foo");
341      test_cond(reply->type == REDIS_REPLY_STRING &&
342          strcmp(reply->str,"hello world") == 0);
343      freeReplyObject(reply);
344      test("%%b String interpolation works: ");
345      reply = redisCommand(c,"SET %b %b","foo",(size_t)3,"hello\x00world",(size_t)11);
346      freeReplyObject(reply);
347      reply = redisCommand(c,"GET foo");
348      test_cond(reply->type == REDIS_REPLY_STRING &&
349          memcmp(reply->str,"hello\x00world",11) == 0)
350      test("Binary reply length is correct: ");
351      test_cond(reply->len == 11)
352      freeReplyObject(reply);
353      test("Can parse nil replies: ");
354      reply = redisCommand(c,"GET nokey");
355      test_cond(reply->type == REDIS_REPLY_NIL)
356      freeReplyObject(reply);
357      test("Can parse integer replies: ");
358      reply = redisCommand(c,"INCR mycounter");
359      test_cond(reply->type == REDIS_REPLY_INTEGER && reply->integer == 1)
360      freeReplyObject(reply);
361      test("Can parse multi bulk replies: ");
362      freeReplyObject(redisCommand(c,"LPUSH mylist foo"));
363      freeReplyObject(redisCommand(c,"LPUSH mylist bar"));
364      reply = redisCommand(c,"LRANGE mylist 0 -1");
365      test_cond(reply->type == REDIS_REPLY_ARRAY &&
366                reply->elements == 2 &&
367                !memcmp(reply->element[0]->str,"bar",3) &&
368                !memcmp(reply->element[1]->str,"foo",3))
369      freeReplyObject(reply);
370      test("Can handle nested multi bulk replies: ");
371      freeReplyObject(redisCommand(c,"MULTI"));
372      freeReplyObject(redisCommand(c,"LRANGE mylist 0 -1"));
373      freeReplyObject(redisCommand(c,"PING"));
374      reply = (redisCommand(c,"EXEC"));
375      test_cond(reply->type == REDIS_REPLY_ARRAY &&
376                reply->elements == 2 &&
377                reply->element[0]->type == REDIS_REPLY_ARRAY &&
378                reply->element[0]->elements == 2 &&
379                !memcmp(reply->element[0]->element[0]->str,"bar",3) &&
380                !memcmp(reply->element[0]->element[1]->str,"foo",3) &&
381                reply->element[1]->type == REDIS_REPLY_STATUS &&
382                strcasecmp(reply->element[1]->str,"pong") == 0);
383      freeReplyObject(reply);
384      disconnect(c, 0);
385  }
386  static void test_blocking_connection_timeouts(struct config config) {
387      redisContext *c;
388      redisReply *reply;
389      ssize_t s;
390      const char *cmd = "DEBUG SLEEP 3\r\n";
391      struct timeval tv;
392      c = IF_WIN32(_connect,connect)(config);
393      test("Successfully completes a command when the timeout is not exceeded: ");
394      reply = redisCommand(c,"SET foo fast");
395      freeReplyObject(reply);
396      tv.tv_sec = 0;
397      tv.tv_usec = 10000;
398      redisSetTimeout(c, tv);
399      reply = redisCommand(c, "GET foo");
400      test_cond(reply != NULL && reply->type == REDIS_REPLY_STRING && memcmp(reply->str, "fast", 4) == 0);
401      freeReplyObject(reply);
402      disconnect(c, 0);
403      c = IF_WIN32(_connect,connect)(config);
404      test("Does not return a reply when the command times out: ");
405      s = write(c->fd, cmd, strlen(cmd));
406      tv.tv_sec = 0;
407      tv.tv_usec = 10000;
408      redisSetTimeout(c, tv);
409      reply = redisCommand(c, "GET foo");
410      test_cond(s > 0 && reply == NULL && c->err == REDIS_ERR_IO && strcmp(c->errstr, "Resource temporarily unavailable") == 0);
411      freeReplyObject(reply);
412      test("Reconnect properly reconnects after a timeout: ");
413      redisReconnect(c);
414      reply = redisCommand(c, "PING");
415      test_cond(reply != NULL && reply->type == REDIS_REPLY_STATUS && strcmp(reply->str, "PONG") == 0);
416      freeReplyObject(reply);
417      test("Reconnect properly uses owned parameters: ");
418      config.tcp.host = "foo";
419      config.unix_sock.path = "foo";
420      redisReconnect(c);
421      reply = redisCommand(c, "PING");
422      test_cond(reply != NULL && reply->type == REDIS_REPLY_STATUS && strcmp(reply->str, "PONG") == 0);
423      freeReplyObject(reply);
424      disconnect(c, 0);
425  }
426  static void test_blocking_io_errors(struct config config) {
427      redisContext *c;
428      redisReply *reply;
429      void *_reply;
430      int major, minor;
431      c = IF_WIN32(_connect,connect)(config);
432      {
433          const char *field = "redis_version:";
434          char *p, *eptr;
435          reply = redisCommand(c,"INFO");
436          p = strstr(reply->str,field);
437          major = strtol(p+strlen(field),&eptr,10);
438          p = eptr+1; &bsol;* char next to the first "." */
439          minor = strtol(p,&eptr,10);
440          freeReplyObject(reply);
441      }
442      test("Returns I/O error when the connection is lost: ");
443      reply = redisCommand(c,"QUIT");
444      if (major > 2 || (major == 2 && minor > 0)) {
445          test_cond(strcasecmp(reply->str,"OK") == 0 &&
446              redisGetReply(c,&_reply) == REDIS_ERR);
447          freeReplyObject(reply);
448      } else {
449          test_cond(reply == NULL);
450      }
451      assert(c->err == REDIS_ERR_EOF &&
452          strcmp(c->errstr,"Server closed the connection") == 0);
453      redisFree(c);
454      c = IF_WIN32(_connect,connect)(config);
455      test("Returns I/O error on socket timeout: ");
456      struct timeval tv = { 0, 1000 };
457      assert(redisSetTimeout(c,tv) == REDIS_OK);
458      test_cond(redisGetReply(c,&_reply) == REDIS_ERR &&
459          c->err == REDIS_ERR_IO && errno == EAGAIN);
460      redisFree(c);
461  }
462  static void test_invalid_timeout_errors(struct config config) {
463      redisContext *c;
464      test("Set error when an invalid timeout usec value is given to redisConnectWithTimeout: ");
465      config.tcp.timeout.tv_sec = 0;
466      config.tcp.timeout.tv_usec = 10000001;
467      c = redisConnectWithTimeout(config.tcp.host, config.tcp.port, config.tcp.timeout);
468      test_cond(c->err == REDIS_ERR_IO && strcmp(c->errstr, "Invalid timeout specified") == 0);
469      redisFree(c);
470      test("Set error when an invalid timeout sec value is given to redisConnectWithTimeout: ");
471      config.tcp.timeout.tv_sec = (((LONG_MAX) - 999) / 1000) + 1;
472      config.tcp.timeout.tv_usec = 0;
473      c = redisConnectWithTimeout(config.tcp.host, config.tcp.port, config.tcp.timeout);
474      test_cond(c->err == REDIS_ERR_IO && strcmp(c->errstr, "Invalid timeout specified") == 0);
475      redisFree(c);
476  }
477  static void test_throughput(struct config config) {
478      redisContext *c = IF_WIN32(_connect,connect)(config);
479      redisReply **replies;
480      int i, num;
481      PORT_LONGLONG t1, t2;
482      test("Throughput:\n");
483      for (i = 0; i < 500; i++)
484          freeReplyObject(redisCommand(c,"LPUSH mylist foo"));
485      num = 1000;
486      replies = malloc(sizeof(redisReply*)*num);
487      t1 = usec();
488      for (i = 0; i < num; i++) {
489          replies[i] = redisCommand(c,"PING");
490          assert(replies[i] != NULL && replies[i]->type == REDIS_REPLY_STATUS);
491      }
492      t2 = usec();
493      for (i = 0; i < num; i++) freeReplyObject(replies[i]);
494      free(replies);
495      printf("\t(%dx PING: %.3fs)\n", num, (t2-t1)/1000000.0);
496      replies = malloc(sizeof(redisReply*)*num);
497      t1 = usec();
498      for (i = 0; i < num; i++) {
499          replies[i] = redisCommand(c,"LRANGE mylist 0 499");
500          assert(replies[i] != NULL && replies[i]->type == REDIS_REPLY_ARRAY);
501          assert(replies[i] != NULL && replies[i]->elements == 500);
502      }
503      t2 = usec();
504      for (i = 0; i < num; i++) freeReplyObject(replies[i]);
505      free(replies);
506      printf("\t(%dx LRANGE with 500 elements: %.3fs)\n", num, (t2-t1)/1000000.0);
507      num = 10000;
508      replies = malloc(sizeof(redisReply*)*num);
509      for (i = 0; i < num; i++)
510          redisAppendCommand(c,"PING");
511      t1 = usec();
512      for (i = 0; i < num; i++) {
513          assert(redisGetReply(c, (void*)&replies[i]) == REDIS_OK);
514          assert(replies[i] != NULL && replies[i]->type == REDIS_REPLY_STATUS);
515      }
516      t2 = usec();
517      for (i = 0; i < num; i++) freeReplyObject(replies[i]);
518      free(replies);
519      printf("\t(%dx PING (pipelined): %.3fs)\n", num, (t2-t1)/1000000.0);
520      replies = malloc(sizeof(redisReply*)*num);
521      for (i = 0; i < num; i++)
522          redisAppendCommand(c,"LRANGE mylist 0 499");
523      t1 = usec();
524      for (i = 0; i < num; i++) {
525          assert(redisGetReply(c, (void*)&replies[i]) == REDIS_OK);
526          assert(replies[i] != NULL && replies[i]->type == REDIS_REPLY_ARRAY);
527          assert(replies[i] != NULL && replies[i]->elements == 500);
528      }
529      t2 = usec();
530      for (i = 0; i < num; i++) freeReplyObject(replies[i]);
531      free(replies);
532      printf("\t(%dx LRANGE with 500 elements (pipelined): %.3fs)\n", num, (t2-t1)/1000000.0);
533      disconnect(c, 0);
534  }
535  int main(int argc, char **argv) {
536      struct config cfg = {
537          .tcp = {
538              .host = "127.0.0.1",
539              .port = 6379
540          },
541          .unix_sock = {
542              .path = "/tmp/redis.sock"
543          }
544      };
545      int throughput = 1;
546      int test_inherit_fd = 1;
547      signal(SIGPIPE, SIG_IGN);
548      argv++; argc--;
549      while (argc) {
550          if (argc >= 2 && !strcmp(argv[0],"-h")) {
551              argv++; argc--;
552              cfg.tcp.host = argv[0];
553          } else if (argc >= 2 && !strcmp(argv[0],"-p")) {
554              argv++; argc--;
555              cfg.tcp.port = atoi(argv[0]);
556          } else if (argc >= 2 && !strcmp(argv[0],"-s")) {
557              argv++; argc--;
558              cfg.unix_sock.path = argv[0];
559          } else if (argc >= 1 && !strcmp(argv[0],"--skip-throughput")) {
560              throughput = 0;
561          } else if (argc >= 1 && !strcmp(argv[0],"--skip-inherit-fd")) {
562              test_inherit_fd = 0;
563          } else {
564              fprintf(stderr, "Invalid argument: %s\n", argv[0]);
565              exit(1);
566          }
567          argv++; argc--;
568      }
569      test_format_commands();
570      test_reply_reader();
571      test_blocking_connection_errors();
572      test_free_null();
573      printf("\nTesting against TCP connection (%s:%d):\n", cfg.tcp.host, cfg.tcp.port);
574      cfg.type = CONN_TCP;
575      test_blocking_connection(cfg);
576      test_blocking_connection_timeouts(cfg);
577      test_blocking_io_errors(cfg);
578      test_invalid_timeout_errors(cfg);
579      test_append_formatted_commands(cfg);
580      if (throughput) test_throughput(cfg);
581      printf("\nTesting against Unix socket connection (%s):\n", cfg.unix_sock.path);
582      cfg.type = CONN_UNIX;
583      test_blocking_connection(cfg);
584      test_blocking_connection_timeouts(cfg);
585      test_blocking_io_errors(cfg);
586      if (throughput) test_throughput(cfg);
587      if (test_inherit_fd) {
588          printf("\nTesting against inherited fd (%s):\n", cfg.unix_sock.path);
589          cfg.type = CONN_FD;
590          test_blocking_connection(cfg);
591      }
592      if (fails) {
593          printf("*** %d TESTS FAILED ***\n", fails);
594          return 1;
595      }
596      printf("ALL TESTS PASSED\n");
597      return 0;
598  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from PINRemoteImage-MDEwOlJlcG9zaXRvcnkzOTUzNzEwMw==-flat-libwebp_go_wrap.c</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from redis-MDEwOlJlcG9zaXRvcnkxMDgxMTA3MDY=-flat-test_25.c</div>
                </div>
                <div class="column column_space"><pre><code>123    crosscall2(_cgo_panic, &a, (int) sizeof a);
124  }
125  static _gostring_ _swig_makegostring(const char *p, size_t l) {
126    _gostring_ ret;
127    ret.p = (char*)_swig_goallocate(l + 1);
</pre></code></div>
                <div class="column column_space"><pre><code>321      redisFree(c);
322  }
323  static void test_blocking_connection(struct config config) {
324      redisContext *c;
325      redisReply *reply;
326      c = IF_WIN32(_connect,connect)(config);
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    