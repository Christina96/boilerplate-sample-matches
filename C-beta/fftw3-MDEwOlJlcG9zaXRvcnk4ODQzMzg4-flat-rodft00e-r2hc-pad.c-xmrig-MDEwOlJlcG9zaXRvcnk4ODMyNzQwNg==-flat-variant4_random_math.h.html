
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 3.65296803652968%, Tokens: 8, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>fftw3-MDEwOlJlcG9zaXRvcnk4ODQzMzg4-flat-rodft00e-r2hc-pad.c</h3>
            <pre><code>1  #include "reodft/reodft.h"
2  typedef struct {
3       solver super;
4  } S;
5  typedef struct {
6       plan_rdft super;
7       plan *cld, *cldcpy;
8       INT is;
9       INT n;
10       INT vl;
11       INT ivs, ovs;
12  } P;
13  static void apply(const plan *ego_, R *I, R *O)
14  {
15       const P *ego = (const P *) ego_;
<span onclick='openModal()' class='match'>16       INT is = ego->is;
17       INT i, n = ego->n;
18       INT iv, vl = ego->vl;
19       INT ivs = ego->ivs, ovs = ego->ovs;
</span>20       R *buf;
21       buf = (R *) MALLOC(sizeof(R) * (2*n), BUFFERS);
22       for (iv = 0; iv < vl; ++iv, I += ivs, O += ovs) {
23  	  buf[0] = K(0.0);
24  	  for (i = 1; i < n; ++i) {
25  	       R a = I[(i-1) * is];
26  	       buf[i] = -a;
27  	       buf[2*n - i] = a;
28  	  }
29  	  buf[i] = K(0.0); &bsol;* i == n, Nyquist */
30  	  {
31  	       plan_rdft *cld = (plan_rdft *) ego->cld;
32  	       cld->apply((plan *) cld, buf, buf);
33  	  }
34  	  {
35  	       plan_rdft *cldcpy = (plan_rdft *) ego->cldcpy;
36  	       cldcpy->apply((plan *) cldcpy, buf+2*n-1, O);
37  	  }
38       }
39       X(ifree)(buf);
40  }
41  static void awake(plan *ego_, enum wakefulness wakefulness)
42  {
43       P *ego = (P *) ego_;
44       X(plan_awake)(ego->cld, wakefulness);
45       X(plan_awake)(ego->cldcpy, wakefulness);
46  }
47  static void destroy(plan *ego_)
48  {
49       P *ego = (P *) ego_;
50       X(plan_destroy_internal)(ego->cldcpy);
51       X(plan_destroy_internal)(ego->cld);
52  }
53  static void print(const plan *ego_, printer *p)
54  {
55       const P *ego = (const P *) ego_;
56       p->print(p, "(rodft00e-r2hc-pad-%D%v%(%p%)%(%p%))", 
57  	      ego->n - 1, ego->vl, ego->cld, ego->cldcpy);
58  }
59  static int applicable0(const solver *ego_, const problem *p_)
60  {
61       const problem_rdft *p = (const problem_rdft *) p_;
62       UNUSED(ego_);
63       return (1
64  	     && p->sz->rnk == 1
65  	     && p->vecsz->rnk <= 1
66  	     && p->kind[0] == RODFT00
67  	  );
68  }
69  static int applicable(const solver *ego, const problem *p, const planner *plnr)
70  {
71       return (!NO_SLOWP(plnr) && applicable0(ego, p));
72  }
73  static plan *mkplan(const solver *ego_, const problem *p_, planner *plnr)
74  {
75       P *pln;
76       const problem_rdft *p;
77       plan *cld = (plan *) 0, *cldcpy;
78       R *buf = (R *) 0;
79       INT n;
80       INT vl, ivs, ovs;
81       opcnt ops;
82       static const plan_adt padt = {
83  	  X(rdft_solve), awake, print, destroy
84       };
85       if (!applicable(ego_, p_, plnr))
86  	  goto nada;
87       p = (const problem_rdft *) p_;
88       n = p->sz->dims[0].n + 1;
89       A(n > 0);
90       buf = (R *) MALLOC(sizeof(R) * (2*n), BUFFERS);
91       cld = X(mkplan_d)(plnr,X(mkproblem_rdft_1_d)(X(mktensor_1d)(2*n,1,1), 
92  						  X(mktensor_0d)(), 
93  						  buf, buf, R2HC));
94       if (!cld)
95  	  goto nada;
96       X(tensor_tornk1)(p->vecsz, &vl, &ivs, &ovs);
97       cldcpy =
98  	  X(mkplan_d)(plnr,
99  		      X(mkproblem_rdft_1_d)(X(mktensor_0d)(),
100  					    X(mktensor_1d)(n-1,-1,
101  							   p->sz->dims[0].os), 
102  					    buf+2*n-1,TAINT(p->O, ovs), R2HC));
103       if (!cldcpy)
104  	  goto nada;
105       X(ifree)(buf);
106       pln = MKPLAN_RDFT(P, &padt, apply);
107       pln->n = n;
108       pln->is = p->sz->dims[0].is;
109       pln->cld = cld;
110       pln->cldcpy = cldcpy;
111       pln->vl = vl;
112       pln->ivs = ivs;
113       pln->ovs = ovs;
114       X(ops_zero)(&ops);
115       ops.other = n-1 + 2*n; &bsol;* loads + stores (input -> buf) */
116       X(ops_zero)(&pln->super.super.ops);
117       X(ops_madd2)(pln->vl, &ops, &pln->super.super.ops);
118       X(ops_madd2)(pln->vl, &cld->ops, &pln->super.super.ops);
119       X(ops_madd2)(pln->vl, &cldcpy->ops, &pln->super.super.ops);
120       return &(pln->super.super);
121   nada:
122       X(ifree0)(buf);
123       if (cld)
124  	  X(plan_destroy_internal)(cld);  
125       return (plan *)0;
126  }
127  static solver *mksolver(void)
128  {
129       static const solver_adt sadt = { PROBLEM_RDFT, mkplan, 0 };
130       S *slv = MKSOLVER(S, &sadt);
131       return &(slv->super);
132  }
133  void X(rodft00e_r2hc_pad_register)(planner *p)
134  {
135       REGISTER_SOLVER(p, mksolver());
136  }
</code></pre>
        </div>
        <div class="column">
            <h3>xmrig-MDEwOlJlcG9zaXRvcnk4ODMyNzQwNg==-flat-variant4_random_math.h</h3>
            <pre><code>1  #ifndef VARIANT4_RANDOM_MATH_H
2  #define VARIANT4_RANDOM_MATH_H
3  #include <cstring>
4  #include "base/crypto/Algorithm.h"
5  extern "C"
6  {
7      #include "crypto/cn/c_blake256.h"
8  }
9  enum V4_Settings
10  {
11  	TOTAL_LATENCY = 15 * 3,
12  	NUM_INSTRUCTIONS_MIN = 60,
13  	NUM_INSTRUCTIONS_MAX = 70,
14  	ALU_COUNT_MUL = 1,
15  	ALU_COUNT = 3,
16  };
17  enum V4_InstructionList
18  {
19  	MUL,	
20  	ADD,	
21  	SUB,	
22  	ROR,	
23  	ROL,	
24  	XOR,	
25  	RET,	
26  	V4_INSTRUCTION_COUNT = RET,
27  };
28  enum V4_InstructionDefinition
29  {
30  	V4_OPCODE_BITS = 3,
31  	V4_DST_INDEX_BITS = 2,
32  	V4_SRC_INDEX_BITS = 3,
33  };
34  struct V4_Instruction
35  {
36  	uint8_t opcode;
37  	uint8_t dst_index;
38  	uint8_t src_index;
39  	uint32_t C;
40  };
41  #ifndef FORCEINLINE
42  #ifdef __GNUC__
43  #define FORCEINLINE __attribute__((always_inline)) inline
44  #elif _MSC_VER
45  #define FORCEINLINE __forceinline
46  #else
47  #define FORCEINLINE inline
48  #endif
49  #endif
50  #ifndef UNREACHABLE_CODE
51  #ifdef __GNUC__
52  #define UNREACHABLE_CODE __builtin_unreachable()
53  #elif _MSC_VER
54  #define UNREACHABLE_CODE __assume(false)
55  #else
56  #define UNREACHABLE_CODE
57  #endif
58  #endif
59  template<typename v4_reg>
60  static void v4_random_math(const struct V4_Instruction* code, v4_reg* r)
61  {
62  	enum
63  	{
64  		REG_BITS = sizeof(v4_reg) * 8,
65  	};
66  #define V4_EXEC(i) \
67  	{ \
68  		const struct V4_Instruction* op = code + i; \
69  		const v4_reg src = r[op->src_index]; \
70  		v4_reg* dst = r + op->dst_index; \
71  		switch (op->opcode) \
72  		{ \
73  		case MUL: \
74  			*dst *= src; \
75  			break; \
76  		case ADD: \
77  			*dst += src + op->C; \
78  			break; \
79  		case SUB: \
80  			*dst -= src; \
81  			break; \
82  		case ROR: \
83  			{ \
84  				const uint32_t shift = src % REG_BITS; \
85  				*dst = (*dst >> shift) | (*dst << ((REG_BITS - shift) % REG_BITS)); \
86  			} \
87  			break; \
88  		case ROL: \
89  			{ \
90  				const uint32_t shift = src % REG_BITS; \
91  				*dst = (*dst << shift) | (*dst >> ((REG_BITS - shift) % REG_BITS)); \
92  			} \
93  			break; \
94  		case XOR: \
95  			*dst ^= src; \
96  			break; \
97  		case RET: \
98  			return; \
99  		default: \
100  			UNREACHABLE_CODE; \
101  			break; \
102  		} \
103  	}
104  #define V4_EXEC_10(j) \
105  	V4_EXEC(j + 0) \
106  	V4_EXEC(j + 1) \
107  	V4_EXEC(j + 2) \
108  	V4_EXEC(j + 3) \
109  	V4_EXEC(j + 4) \
110  	V4_EXEC(j + 5) \
111  	V4_EXEC(j + 6) \
112  	V4_EXEC(j + 7) \
113  	V4_EXEC(j + 8) \
114  	V4_EXEC(j + 9)
115  	V4_EXEC_10(0);		
116  	V4_EXEC_10(10);		
117  	V4_EXEC_10(20);		
118  	V4_EXEC_10(30);		
119  	V4_EXEC_10(40);		
120  	V4_EXEC_10(50);		
121  	V4_EXEC_10(60);		
122  #undef V4_EXEC_10
123  #undef V4_EXEC
124  }
125  static FORCEINLINE void check_data(size_t* data_index, const size_t bytes_needed, int8_t* data, const size_t data_size)
126  {
127  	if (*data_index + bytes_needed > data_size)
128  	{
129  		hash_extra_blake(data, data_size, (char*) data);
130  		*data_index = 0;
131  	}
132  }
133  template<xmrig::Algorithm::Id ALGO>
134  static int v4_random_math_init(struct V4_Instruction* code, const uint64_t height)
135  {
136  	const int op_latency[V4_INSTRUCTION_COUNT] = { 3, 2, 1, 2, 2, 1 };
137  	const int asic_op_latency[V4_INSTRUCTION_COUNT] = { 3, 1, 1, 1, 1, 1 };
138  	const int op_ALUs[V4_INSTRUCTION_COUNT] = { ALU_COUNT_MUL, ALU_COUNT, ALU_COUNT, ALU_COUNT, ALU_COUNT, ALU_COUNT };
139  	int8_t data[32];
140  	memset(data, 0, sizeof(data));
141  	uint64_t tmp = SWAP64LE(height);
142  	memcpy(data, &tmp, sizeof(uint64_t));
143  	if (ALGO == xmrig::Algorithm::CN_R)	{
144  		data[20] = -38;
145  	}
146  	size_t data_index = sizeof(data);
147  	int code_size;
148  	bool r8_used;
149  	do {
150  		int latency[9];
151  		int asic_latency[9];
152  		uint32_t inst_data[9] = { 0, 1, 2, 3, 0xFFFFFF, 0xFFFFFF, 0xFFFFFF, 0xFFFFFF, 0xFFFFFF };
153  		bool alu_busy[TOTAL_LATENCY + 1][ALU_COUNT];
154  		bool is_rotation[V4_INSTRUCTION_COUNT];
155  		bool rotated[4];
156  		int rotate_count = 0;
157  		memset(latency, 0, sizeof(latency));
158  		memset(asic_latency, 0, sizeof(asic_latency));
159  		memset(alu_busy, 0, sizeof(alu_busy));
160  		memset(is_rotation, 0, sizeof(is_rotation));
161  		memset(rotated, 0, sizeof(rotated));
162  		is_rotation[ROR] = true;
163  		is_rotation[ROL] = true;
164  		int num_retries = 0;
165  		code_size = 0;
166  		int total_iterations = 0;
167  		r8_used = false;
168  		while (((latency[0] < TOTAL_LATENCY) || (latency[1] < TOTAL_LATENCY) || (latency[2] < TOTAL_LATENCY) || (latency[3] < TOTAL_LATENCY)) && (num_retries < 64))
169  		{
170  			++total_iterations;
171  			if (total_iterations > 256)
172  				break;
173  			check_data(&data_index, 1, data, sizeof(data));
174  			const uint8_t c = ((uint8_t*)data)[data_index++];
175  			uint8_t opcode = c & ((1 << V4_OPCODE_BITS) - 1);
176  			if (opcode == 5)
177  			{
178  				check_data(&data_index, 1, data, sizeof(data));
179  				opcode = (data[data_index++] >= 0) ? ROR : ROL;
180  			}
181  			else if (opcode >= 6)
182  			{
183  				opcode = XOR;
184  			}
185  			else
186  			{
187  				opcode = (opcode <= 2) ? MUL : (opcode - 2);
188  			}
<span onclick='openModal()' class='match'>189  			uint8_t dst_index = (c >> V4_OPCODE_BITS) & ((1 << V4_DST_INDEX_BITS) - 1);
190  			uint8_t src_index = (c >> (V4_OPCODE_BITS + V4_DST_INDEX_BITS)) & ((1 << V4_SRC_INDEX_BITS) - 1);
191  			const int a = dst_index;
192  			int b = src_index;
</span>193  			if (((opcode == ADD) || (opcode == SUB) || (opcode == XOR)) && (a == b)) {
194  				b = 8;
195  				src_index = b;
196  			}
197  			if (is_rotation[opcode] && rotated[a])
198  			{
199  				continue;
200  			}
201  			if ((opcode != MUL) && ((inst_data[a] & 0xFFFF00) == (opcode << 8) + ((inst_data[b] & 255) << 16)))
202  			{
203  				continue;
204  			}
205  			int next_latency = (latency[a] > latency[b]) ? latency[a] : latency[b];
206  			int alu_index = -1;
207  			while (next_latency < TOTAL_LATENCY)
208  			{
209  				for (int i = op_ALUs[opcode] - 1; i >= 0; --i)
210  				{
211  					if (!alu_busy[next_latency][i])
212  					{
213  						if ((opcode == ADD) && alu_busy[next_latency + 1][i])
214  						{
215  							continue;
216  						}
217  						if (is_rotation[opcode] && (next_latency < rotate_count * op_latency[opcode]))
218  						{
219  							continue;
220  						}
221  						alu_index = i;
222  						break;
223  					}
224  				}
225  				if (alu_index >= 0)
226  				{
227  					break;
228  				}
229  				++next_latency;
230  			}
231  			if (next_latency > latency[a] + 7)
232  			{
233  				continue;
234  			}
235  			next_latency += op_latency[opcode];
236  			if (next_latency <= TOTAL_LATENCY)
237  			{
238  				if (is_rotation[opcode])
239  				{
240  					++rotate_count;
241  				}
242  				alu_busy[next_latency - op_latency[opcode]][alu_index] = true;
243  				latency[a] = next_latency;
244  				asic_latency[a] = ((asic_latency[a] > asic_latency[b]) ? asic_latency[a] : asic_latency[b]) + asic_op_latency[opcode];
245  				rotated[a] = is_rotation[opcode];
246  				inst_data[a] = code_size + (opcode << 8) + ((inst_data[b] & 255) << 16);
247  				code[code_size].opcode = opcode;
248  				code[code_size].dst_index = dst_index;
249  				code[code_size].src_index = src_index;
250  				code[code_size].C = 0;
251  				if (src_index == 8)
252  				{
253  					r8_used = true;
254  				}
255  				if (opcode == ADD)
256  				{
257  					alu_busy[next_latency - op_latency[opcode] + 1][alu_index] = true;
258  					check_data(&data_index, sizeof(uint32_t), data, sizeof(data));
259  					uint32_t t;
260  					memcpy(&t, data + data_index, sizeof(uint32_t));
261  					code[code_size].C = SWAP32LE(t);
262  					data_index += sizeof(uint32_t);
263  				}
264  				++code_size;
265  				if (code_size >= NUM_INSTRUCTIONS_MIN)
266  				{
267  					break;
268  				}
269  			}
270  			else
271  			{
272  				++num_retries;
273  			}
274  		}
275  		const int prev_code_size = code_size;
276  		while ((code_size < NUM_INSTRUCTIONS_MAX) && (asic_latency[0] < TOTAL_LATENCY) && (asic_latency[1] < TOTAL_LATENCY) && (asic_latency[2] < TOTAL_LATENCY) && (asic_latency[3] < TOTAL_LATENCY))
277  		{
278  			int min_idx = 0;
279  			int max_idx = 0;
280  			for (int i = 1; i < 4; ++i)
281  			{
282  				if (asic_latency[i] < asic_latency[min_idx]) min_idx = i;
283  				if (asic_latency[i] > asic_latency[max_idx]) max_idx = i;
284  			}
285  			const uint8_t pattern[3] = { ROR, MUL, MUL };
286  			const uint8_t opcode = pattern[(code_size - prev_code_size) % 3];
287  			latency[min_idx] = latency[max_idx] + op_latency[opcode];
288  			asic_latency[min_idx] = asic_latency[max_idx] + asic_op_latency[opcode];
289  			code[code_size].opcode = opcode;
290  			code[code_size].dst_index = min_idx;
291  			code[code_size].src_index = max_idx;
292  			code[code_size].C = 0;
293  			++code_size;
294  		}
295  	}  while (!r8_used || (code_size < NUM_INSTRUCTIONS_MIN) || (code_size > NUM_INSTRUCTIONS_MAX));
296  	code[code_size].opcode = RET;
297  	code[code_size].dst_index = 0;
298  	code[code_size].src_index = 0;
299  	code[code_size].C = 0;
300  	return code_size;
301  }
302  #endif
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from fftw3-MDEwOlJlcG9zaXRvcnk4ODQzMzg4-flat-rodft00e-r2hc-pad.c</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from xmrig-MDEwOlJlcG9zaXRvcnk4ODMyNzQwNg==-flat-variant4_random_math.h</div>
                </div>
                <div class="column column_space"><pre><code>16       INT is = ego->is;
17       INT i, n = ego->n;
18       INT iv, vl = ego->vl;
19       INT ivs = ego->ivs, ovs = ego->ovs;
</pre></code></div>
                <div class="column column_space"><pre><code>189  			uint8_t dst_index = (c >> V4_OPCODE_BITS) & ((1 << V4_DST_INDEX_BITS) - 1);
190  			uint8_t src_index = (c >> (V4_OPCODE_BITS + V4_DST_INDEX_BITS)) & ((1 << V4_SRC_INDEX_BITS) - 1);
191  			const int a = dst_index;
192  			int b = src_index;
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    