
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 6.168608636052091%, Tokens: 11, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>redis-MDEwOlJlcG9zaXRvcnkxMDgxMTA3MDY=-flat-sha1.c</h3>
            <pre><code>1  #define SHA1HANDSOFF
2  #include <stdio.h>
3  #include <string.h>
4  #include <stdint.h>
5  #include "solarisfixes.h"
6  #ifdef _WIN32
7  #include "Win32_Interop/win32fixes.h"
8  #endif
9  #include "sha1.h"
10  #include "config.h"
11  #define rol(value, bits) (((value) << (bits)) | ((value) >> (32 - (bits))))
12  #if BYTE_ORDER == LITTLE_ENDIAN
13  #define blk0(i) (block->l[i] = (rol(block->l[i],24)&0xFF00FF00) \
14      |(rol(block->l[i],8)&0x00FF00FF))
15  #elif BYTE_ORDER == BIG_ENDIAN
16  #define blk0(i) block->l[i]
17  #else
18  #ifdef _WIN32
19  #pragma error "Endianness not defined!"
20  #else
21  #error "Endianness not defined!"
22  #endif
23  #endif
24  #define blk(i) (block->l[i&15] = rol(block->l[(i+13)&15]^block->l[(i+8)&15] \
25      ^block->l[(i+2)&15]^block->l[i&15],1))
26  #define R0(v,w,x,y,z,i) z+=((w&(x^y))^y)+blk0(i)+0x5A827999+rol(v,5);w=rol(w,30);
27  #define R1(v,w,x,y,z,i) z+=((w&(x^y))^y)+blk(i)+0x5A827999+rol(v,5);w=rol(w,30);
28  #define R2(v,w,x,y,z,i) z+=(w^x^y)+blk(i)+0x6ED9EBA1+rol(v,5);w=rol(w,30);
29  #define R3(v,w,x,y,z,i) z+=(((w|x)&y)|(w&x))+blk(i)+0x8F1BBCDC+rol(v,5);w=rol(w,30);
30  #define R4(v,w,x,y,z,i) z+=(w^x^y)+blk(i)+0xCA62C1D6+rol(v,5);w=rol(w,30);
31  void SHA1Transform(uint32_t state[5], const unsigned char buffer[64])
32  {
33      uint32_t a, b, c, d, e;
34      typedef union {
35          unsigned char c[64];
36          uint32_t l[16];
37      } CHAR64LONG16;
38  #ifdef SHA1HANDSOFF
<span onclick='openModal()' class='match'>39      CHAR64LONG16 block[1];  &bsol;* use array to appear as a pointer */
40      memcpy(block, buffer, 64);
41  #else
42      CHAR64LONG16* block = (const CHAR64LONG16*)buffer;
</span>43  #endif
44      a = state[0];
45      b = state[1];
46      c = state[2];
47      d = state[3];
48      e = state[4];
49      R0(a,b,c,d,e, 0); R0(e,a,b,c,d, 1); R0(d,e,a,b,c, 2); R0(c,d,e,a,b, 3);
50      R0(b,c,d,e,a, 4); R0(a,b,c,d,e, 5); R0(e,a,b,c,d, 6); R0(d,e,a,b,c, 7);
51      R0(c,d,e,a,b, 8); R0(b,c,d,e,a, 9); R0(a,b,c,d,e,10); R0(e,a,b,c,d,11);
52      R0(d,e,a,b,c,12); R0(c,d,e,a,b,13); R0(b,c,d,e,a,14); R0(a,b,c,d,e,15);
53      R1(e,a,b,c,d,16); R1(d,e,a,b,c,17); R1(c,d,e,a,b,18); R1(b,c,d,e,a,19);
54      R2(a,b,c,d,e,20); R2(e,a,b,c,d,21); R2(d,e,a,b,c,22); R2(c,d,e,a,b,23);
55      R2(b,c,d,e,a,24); R2(a,b,c,d,e,25); R2(e,a,b,c,d,26); R2(d,e,a,b,c,27);
56      R2(c,d,e,a,b,28); R2(b,c,d,e,a,29); R2(a,b,c,d,e,30); R2(e,a,b,c,d,31);
57      R2(d,e,a,b,c,32); R2(c,d,e,a,b,33); R2(b,c,d,e,a,34); R2(a,b,c,d,e,35);
58      R2(e,a,b,c,d,36); R2(d,e,a,b,c,37); R2(c,d,e,a,b,38); R2(b,c,d,e,a,39);
59      R3(a,b,c,d,e,40); R3(e,a,b,c,d,41); R3(d,e,a,b,c,42); R3(c,d,e,a,b,43);
60      R3(b,c,d,e,a,44); R3(a,b,c,d,e,45); R3(e,a,b,c,d,46); R3(d,e,a,b,c,47);
61      R3(c,d,e,a,b,48); R3(b,c,d,e,a,49); R3(a,b,c,d,e,50); R3(e,a,b,c,d,51);
62      R3(d,e,a,b,c,52); R3(c,d,e,a,b,53); R3(b,c,d,e,a,54); R3(a,b,c,d,e,55);
63      R3(e,a,b,c,d,56); R3(d,e,a,b,c,57); R3(c,d,e,a,b,58); R3(b,c,d,e,a,59);
64      R4(a,b,c,d,e,60); R4(e,a,b,c,d,61); R4(d,e,a,b,c,62); R4(c,d,e,a,b,63);
65      R4(b,c,d,e,a,64); R4(a,b,c,d,e,65); R4(e,a,b,c,d,66); R4(d,e,a,b,c,67);
66      R4(c,d,e,a,b,68); R4(b,c,d,e,a,69); R4(a,b,c,d,e,70); R4(e,a,b,c,d,71);
67      R4(d,e,a,b,c,72); R4(c,d,e,a,b,73); R4(b,c,d,e,a,74); R4(a,b,c,d,e,75);
68      R4(e,a,b,c,d,76); R4(d,e,a,b,c,77); R4(c,d,e,a,b,78); R4(b,c,d,e,a,79);
69      state[0] += a;
70      state[1] += b;
71      state[2] += c;
72      state[3] += d;
73      state[4] += e;
74      a = b = c = d = e = 0;
75  #ifdef SHA1HANDSOFF
76      memset(block, '\0', sizeof(block));
77  #endif
78  }
79  void SHA1Init(SHA1_CTX* context)
80  {
81      context->state[0] = 0x67452301;
82      context->state[1] = 0xEFCDAB89;
83      context->state[2] = 0x98BADCFE;
84      context->state[3] = 0x10325476;
85      context->state[4] = 0xC3D2E1F0;
86      context->count[0] = context->count[1] = 0;
87  }
88  void SHA1Update(SHA1_CTX* context, const unsigned char* data, uint32_t len)
89  {
90      uint32_t i, j;
91      j = context->count[0];
92      if ((context->count[0] += len << 3) < j)
93          context->count[1]++;
94      context->count[1] += (len>>29);
95      j = (j >> 3) & 63;
96      if ((j + len) > 63) {
97          memcpy(&context->buffer[j], data, (i = 64-j));
98          SHA1Transform(context->state, context->buffer);
99          for ( ; i + 63 < len; i += 64) {
100              SHA1Transform(context->state, &data[i]);
101          }
102          j = 0;
103      }
104      else i = 0;
105      memcpy(&context->buffer[j], &data[i], len - i);
106  }
107  void SHA1Final(unsigned char digest[20], SHA1_CTX* context)
108  {
109      unsigned i;
110      unsigned char finalcount[8];
111      unsigned char c;
112  #if 0	&bsol;* untested "improvement" by DHR */
113      unsigned char *fcp = &finalcount[8];
114      for (i = 0; i < 2; i++)
115         {
116          uint32_t t = context->count[i];
117          int j;
118          for (j = 0; j < 4; t >>= 8, j++)
119  	          *--fcp = (unsigned char) t;
120      }
121  #else
122      for (i = 0; i < 8; i++) {
123          finalcount[i] = (unsigned char)((context->count[(i >= 4 ? 0 : 1)]
124           >> ((3-(i & 3)) * 8) ) & 255);  &bsol;* Endian independent */
125      }
126  #endif
127      c = 0200;
128      SHA1Update(context, &c, 1);
129      while ((context->count[0] & 504) != 448) {
130  	c = 0000;
131          SHA1Update(context, &c, 1);
132      }
133      SHA1Update(context, finalcount, 8);  &bsol;* Should cause a SHA1Transform() */
134      for (i = 0; i < 20; i++) {
135          digest[i] = (unsigned char)
136           ((context->state[i>>2] >> ((3-(i & 3)) * 8) ) & 255);
137      }
138      memset(context, '\0', sizeof(*context));
139      memset(&finalcount, '\0', sizeof(finalcount));
140  }
141  #ifdef REDIS_TEST
142  #define BUFSIZE 4096
143  #define UNUSED(x) (void)(x)
144  int sha1Test(int argc, char **argv)
145  {
146      SHA1_CTX ctx;
147      unsigned char hash[20], buf[BUFSIZE];
148      int i;
149      UNUSED(argc);
150      UNUSED(argv);
151      for(i=0;i<BUFSIZE;i++)
152          buf[i] = i;
153      SHA1Init(&ctx);
154      for(i=0;i<1000;i++)
155          SHA1Update(&ctx, buf, BUFSIZE);
156      SHA1Final(hash, &ctx);
157      printf("SHA1=");
158      for(i=0;i<20;i++)
159          printf("%02x", hash[i]);
160      printf("\n");
161      return 0;
162  }
163  #endif
</code></pre>
        </div>
        <div class="column">
            <h3>redis-MDEwOlJlcG9zaXRvcnkxMDgxMTA3MDY=-flat-linenoise.c</h3>
            <pre><code>1  #ifdef _WIN32
2  #include "../../src/Win32_Interop/Win32_Portability.h"
3  #include "../../src/Win32_Interop/win32fixes.h"
4  #define UNUSED(V) ((void) V)
5  #include "../../src/Win32_Interop/win32_ANSI.h"
6  #else
7  #include <termios.h>
8  #include <unistd.h>
9  #include <sys/ioctl.h>
10  #endif
11  #include <stdlib.h>
12  #include <stdio.h>
13  #include <errno.h>
14  #include <string.h>
15  #include <stdlib.h>
16  #include <ctype.h>
17  #include <sys/stat.h>
18  #include <sys/types.h>
19  #include "linenoise.h"
20  #define LINENOISE_DEFAULT_HISTORY_MAX_LEN 100
21  #define LINENOISE_MAX_LINE 4096
22  static char *unsupported_term[] = {"dumb","cons25","emacs",NULL};
23  static linenoiseCompletionCallback *completionCallback = NULL;
24  static linenoiseHintsCallback *hintsCallback = NULL;
25  static linenoiseFreeHintsCallback *freeHintsCallback = NULL;
26  #ifndef _WIN32
27  static struct termios orig_termios; &bsol;* In order to restore at exit.*/
28  #endif
29  static int rawmode = 0; &bsol;* For atexit() function to check if restore is needed*/
30  static int mlmode = 0;  &bsol;* Multi line mode. Default is single line. */
31  static int atexit_registered = 0; &bsol;* Register atexit just 1 time. */
32  static int history_max_len = LINENOISE_DEFAULT_HISTORY_MAX_LEN;
33  static int history_len = 0;
34  static char **history = NULL;
35  struct linenoiseState {
36      int ifd;            &bsol;* Terminal stdin file descriptor. */
37      int ofd;            &bsol;* Terminal stdout file descriptor. */
38      char *buf;          &bsol;* Edited line buffer. */
39      size_t buflen;      &bsol;* Edited line buffer size. */
40      const char *prompt; &bsol;* Prompt to display. */
41      size_t plen;        &bsol;* Prompt length. */
42      size_t pos;         &bsol;* Current cursor position. */
43      size_t oldpos;      &bsol;* Previous refresh cursor position. */
44      size_t len;         &bsol;* Current edited line length. */
45      size_t cols;        &bsol;* Number of columns in terminal. */
46      size_t maxrows;     &bsol;* Maximum num of rows used so far (multiline mode) */
47      int history_index;  &bsol;* The history index we are currently editing. */
48  };
49  enum KEY_ACTION{
50  	KEY_NULL = 0,	    &bsol;* NULL */
51  	CTRL_A = 1,         &bsol;* Ctrl+a */
52  	CTRL_B = 2,         &bsol;* Ctrl-b */
53  	CTRL_C = 3,         &bsol;* Ctrl-c */
54  	CTRL_D = 4,         &bsol;* Ctrl-d */
55  	CTRL_E = 5,         &bsol;* Ctrl-e */
56  	CTRL_F = 6,         &bsol;* Ctrl-f */
57  	CTRL_H = 8,         &bsol;* Ctrl-h */
58  	TAB = 9,            &bsol;* Tab */
59  	CTRL_K = 11,        &bsol;* Ctrl+k */
60  	CTRL_L = 12,        &bsol;* Ctrl+l */
61  	ENTER = 13,         &bsol;* Enter */
62  	CTRL_N = 14,        &bsol;* Ctrl-n */
63  	CTRL_P = 16,        &bsol;* Ctrl-p */
64  	CTRL_T = 20,        &bsol;* Ctrl-t */
65  	CTRL_U = 21,        &bsol;* Ctrl+u */
66  	CTRL_W = 23,        &bsol;* Ctrl+w */
67  	ESC = 27,           &bsol;* Escape */
68  	BACKSPACE =  127    &bsol;* Backspace */
69  };
70  static void linenoiseAtExit(void);
71  int linenoiseHistoryAdd(const char *line);
72  static void refreshLine(struct linenoiseState *l);
73  #ifdef _WIN32
74  #ifndef STDIN_FILENO
75      #define STDIN_FILENO (_fileno(stdin))
76  #endif
77  HANDLE hOut;
78  HANDLE hIn;
79  DWORD consolemode;
80  static int win32read(char *c) {
81      DWORD foo;
82      INPUT_RECORD b;
83      KEY_EVENT_RECORD e;
84      BOOL altgr;
85      while (1) {
86          if (!ReadConsoleInput(hIn, &b, 1, &foo)) return 0;
87          if (!foo) return 0;
88          if (b.EventType == KEY_EVENT && b.Event.KeyEvent.bKeyDown) {
89              e = b.Event.KeyEvent;
90              *c = b.Event.KeyEvent.uChar.AsciiChar;
91              altgr = e.dwControlKeyState & (LEFT_CTRL_PRESSED | RIGHT_ALT_PRESSED);
92              if (e.dwControlKeyState & (LEFT_CTRL_PRESSED | RIGHT_CTRL_PRESSED) && !altgr) {
93                  switch (*c) {
94                      case 'D':
95                          *c = 4;
96                          return 1;
97                      case 'C':
98                          *c = 3;
99                          return 1;
100                      case 'H':
101                          *c = 8;
102                          return 1;
103                      case 'T':
104                          *c = 20;
105                          return 1;
106                      case 'B': &bsol;* ctrl-b, left_arrow */
107                          *c = 2;
108                          return 1;
109                      case 'F': &bsol;* ctrl-f right_arrow*/
110                          *c = 6;
111                          return 1;
112                      case 'P': &bsol;* ctrl-p up_arrow*/
113                          *c = 16;
114                          return 1;
115                      case 'N': &bsol;* ctrl-n down_arrow*/
116                          *c = 14;
117                          return 1;
118                      case 'U': &bsol;* Ctrl+u, delete the whole line. */
119                          *c = 21;
120                          return 1;
121                      case 'K': &bsol;* Ctrl+k, delete from current to end of line. */
122                          *c = 11;
123                          return 1;
124                      case 'A': &bsol;* Ctrl+a, go to the start of the line */
125                          *c = 1;
126                          return 1;
127                      case 'E': &bsol;* ctrl+e, go to the end of the line */
128                          *c = 5;
129                          return 1;
130                  }
131              } else {
132                  switch (e.wVirtualKeyCode) {
133                      case VK_ESCAPE: &bsol;* ignore - send ctrl-c, will return -1 */
134                          *c = 3;
135                          return 1;
136                      case VK_RETURN:  &bsol;* enter */
137                          *c = 13;
138                          return 1;
139                      case VK_LEFT:   &bsol;* left */
140                          *c = 2;
141                          return 1;
142                      case VK_RIGHT: &bsol;* right */
143                          *c = 6;
144                          return 1;
145                      case VK_UP:   &bsol;* up */
146                          *c = 16;
147                          return 1;
148                      case VK_DOWN:  &bsol;* down */
149                          *c = 14;
150                          return 1;
151                      case VK_HOME:
152                          *c = 1;
153                          return 1;
154                      case VK_END:
155                          *c = 5;
156                          return 1;
157                      case VK_BACK:
158                          *c = 8;
159                          return 1;
160                      case VK_DELETE:
161                          *c = 127;
162                          return 1;
163                      default:
164                          if (*c) return 1;
165                  }
166              }
167          }
168      }
169      return -1; &bsol;* Makes compiler happy */
170  }
171  #endif
172  #if 0
173  FILE *lndebug_fp = NULL;
174  #define lndebug(...) \
175      do { \
176          if (lndebug_fp == NULL) { \
177              lndebug_fp = fopen("/tmp/lndebug.txt","a"); \
178              fprintf(lndebug_fp, \
179              "[%d %d %d] p: %d, rows: %d, rpos: %d, max: %d, oldmax: %d\n", \
180              (int)l->len,(int)l->pos,(int)l->oldpos,plen,rows,rpos, \
181              (int)l->maxrows,old_rows); \
182          } \
183          fprintf(lndebug_fp, ", " __VA_ARGS__); \
184          fflush(lndebug_fp); \
185      } while (0)
186  #else
187  #define lndebug(fmt, ...)
188  #endif
189  void linenoiseSetMultiLine(int ml) {
190      mlmode = ml;
191  }
192  static int isUnsupportedTerm(void) {
193  #ifndef _WIN32
194      char *term = getenv("TERM");
195      int j;
196      if (term == NULL) return 0;
197      for (j = 0; unsupported_term[j]; j++)
198          if (!strcasecmp(term,unsupported_term[j])) return 1;
199  #endif
200      return 0;
201  }
202  static int enableRawMode(int fd) {
203  #ifndef _WIN32
204      struct termios raw;
205      if (!isatty(STDIN_FILENO)) goto fatal;
206      if (!atexit_registered) {
207          atexit(linenoiseAtExit);
208          atexit_registered = 1;
209      }
210      if (tcgetattr(fd,&orig_termios) == -1) goto fatal;
211      raw = orig_termios;  &bsol;* modify the original mode */
212      raw.c_iflag &= ~(BRKINT | ICRNL | INPCK | ISTRIP | IXON);
213      raw.c_oflag &= ~(OPOST);
214      raw.c_cflag |= (CS8);
215      raw.c_lflag &= ~(ECHO | ICANON | IEXTEN | ISIG);
216      raw.c_cc[VMIN] = 1; raw.c_cc[VTIME] = 0; &bsol;* 1 byte, no timer */
217      if (tcsetattr(fd,TCSAFLUSH,&raw) < 0) goto fatal;
218      rawmode = 1;
219  #else
220      UNUSED(fd);
221      if (!atexit_registered) {
222          hOut = GetStdHandle(STD_OUTPUT_HANDLE);
223          if (hOut==INVALID_HANDLE_VALUE) goto fatal;
224          if (!GetConsoleMode(hOut, &consolemode)) {
225              CloseHandle(hOut);
226              errno = ENOTTY;
227              return -1;
228          };
229          hIn = GetStdHandle(STD_INPUT_HANDLE);
230          if (hIn == INVALID_HANDLE_VALUE) {
231              CloseHandle(hOut);
232              errno = ENOTTY;
233              return -1;
234          }
235          GetConsoleMode(hIn, &consolemode);
236          SetConsoleMode(hIn, ENABLE_PROCESSED_INPUT);
237          atexit(linenoiseAtExit);
238          atexit_registered = 1;
239      }
240      rawmode = 1;
241  #endif
242      return 0;
243  fatal:
244      errno = ENOTTY;
245      return -1;
246  }
247  static void disableRawMode(int fd) {
248  #ifdef _WIN32
249      UNUSED(fd);
250      rawmode = 0;
251  #else
252      if (rawmode && tcsetattr(fd,TCSAFLUSH,&orig_termios) != -1)
253          rawmode = 0;
254  #endif
255  }
256  static int getCursorPosition(int ifd, int ofd) {
257      char buf[32];
258      int cols, rows;
259      unsigned int i = 0;
260      if (write(ofd, "\x1b[6n", 4) != 4) return -1;
261      while (i < sizeof(buf)-1) {
262          if (read(ifd,buf+i,1) != 1) break;
263          if (buf[i] == 'R') break;
264          i++;
265      }
266      buf[i] = '\0';
267      if (buf[0] != ESC || buf[1] != '[') return -1;
268      if (sscanf(buf+2,"%d;%d",&rows,&cols) != 2) return -1;
269      return cols;
270  }
271  static int getColumns(int ifd, int ofd) {
272  #ifdef _WIN32
273      CONSOLE_SCREEN_BUFFER_INFO b;
274      if (!GetConsoleScreenBufferInfo(hOut, &b)) return 80;
275      return b.srWindow.Right - b.srWindow.Left;
276  #else
277      struct winsize ws;
278      if (ioctl(1, TIOCGWINSZ, &ws) == -1 || ws.ws_col == 0) {
279          int start, cols;
280          start = getCursorPosition(ifd,ofd);
281          if (start == -1) goto failed;
282          if (write(ofd,"\x1b[999C",6) != 6) goto failed;
283          cols = getCursorPosition(ifd,ofd);
284          if (cols == -1) goto failed;
285          if (cols > start) {
286              char seq[32];
287              snprintf(seq,32,"\x1b[%dD",cols-start);
288              if (write(ofd,seq,strlen(seq)) == -1) {
289              }
290          }
291          return cols;
292      } else {
293          return ws.ws_col;
294      }
295  failed:
296      return 80;
297  #endif
298  }
299  void linenoiseClearScreen(void) {
300      if (write(STDOUT_FILENO,"\x1b[H\x1b[2J",7) <= 0) {
301      }
302  }
303  static void linenoiseBeep(void) {
304      fprintf(stderr, "\x7");
305      fflush(stderr);
306  }
307  static void freeCompletions(linenoiseCompletions *lc) {
308      size_t i;
309      for (i = 0; i < lc->len; i++)
310          free(lc->cvec[i]);
311      if (lc->cvec != NULL)
312          free(lc->cvec);
313  }
314  static int completeLine(struct linenoiseState *ls) {
315      linenoiseCompletions lc = { 0, NULL };
316      int nread, nwritten;
317      char c = 0;
318      completionCallback(ls->buf,&lc);
319      if (lc.len == 0) {
320          linenoiseBeep();
321      } else {
322          size_t stop = 0, i = 0;
323          while(!stop) {
324              if (i < lc.len) {
325                  struct linenoiseState saved = *ls;
326                  ls->len = ls->pos = strlen(lc.cvec[i]);
327                  ls->buf = lc.cvec[i];
328                  refreshLine(ls);
329                  ls->len = saved.len;
330                  ls->pos = saved.pos;
331                  ls->buf = saved.buf;
332              } else {
333                  refreshLine(ls);
334              }
335              nread = (int)read(ls->ifd,&c,1);                                    WIN_PORT_FIX &bsol;* cast (int) */
336              if (nread <= 0) {
337                  freeCompletions(&lc);
338                  return -1;
339              }
340              switch(c) {
341                  case 9: &bsol;* tab */
342                      i = (i+1) % (lc.len+1);
343                      if (i == lc.len) linenoiseBeep();
344                      break;
345                  case 27: &bsol;* escape */
346                      if (i < lc.len) refreshLine(ls);
347                      stop = 1;
348                      break;
349                  default:
350                      if (i < lc.len) {
351                          nwritten = snprintf(ls->buf,ls->buflen,"%s",lc.cvec[i]);
352                          ls->len = ls->pos = nwritten;
353                      }
354                      stop = 1;
355                      break;
356              }
357          }
358      }
359      freeCompletions(&lc);
360      return c; &bsol;* Return last read character */
361  }
362  void linenoiseSetCompletionCallback(linenoiseCompletionCallback *fn) {
363      completionCallback = fn;
364  }
365  void linenoiseSetHintsCallback(linenoiseHintsCallback *fn) {
366      hintsCallback = fn;
367  }
368  void linenoiseSetFreeHintsCallback(linenoiseFreeHintsCallback *fn) {
369      freeHintsCallback = fn;
370  }
371  void linenoiseAddCompletion(linenoiseCompletions *lc, const char *str) {
372      size_t len = strlen(str);
373      char *copy, **cvec;
374      copy = malloc(len+1);
375      if (copy == NULL) return;
376      memcpy(copy,str,len+1);
377      cvec = realloc(lc->cvec,sizeof(char*)*(lc->len+1));
378      if (cvec == NULL) {
379          free(copy);
380          return;
381      }
382      lc->cvec = cvec;
383      lc->cvec[lc->len++] = copy;
384  }
385  struct abuf {
386      char *b;
387      int len;
388  };
389  static void abInit(struct abuf *ab) {
390      ab->b = NULL;
391      ab->len = 0;
392  }
393  static void abAppend(struct abuf *ab, const char *s, int len) {
394      char *new = realloc(ab->b,ab->len+len);
395      if (new == NULL) return;
396      memcpy(new+ab->len,s,len);
397      ab->b = new;
398      ab->len += len;
399  }
400  static void abFree(struct abuf *ab) {
401      free(ab->b);
402  }
403  void refreshShowHints(struct abuf *ab, struct linenoiseState *l, int plen) {
404      char seq[64];
405      if (hintsCallback && plen+l->len < l->cols) {
406          int color = -1, bold = 0;
407          char *hint = hintsCallback(l->buf,&color,&bold);
408          if (hint) {
409              int hintlen = (int)strlen(hint);                                    WIN_PORT_FIX &bsol;* cast int */
410              int hintmaxlen = (int)(l->cols-(plen+l->len));                      WIN_PORT_FIX &bsol;* cast int */
411              if (hintlen > hintmaxlen) hintlen = hintmaxlen;
412              if (bold == 1 && color == -1) color = 37;
413              if (color != -1 || bold != 0)
414                  snprintf(seq,64,"\033[%d;%d;49m",bold,color);
415              abAppend(ab,seq,(int)strlen(seq));                                  WIN_PORT_FIX &bsol;* cast int */
416              abAppend(ab,hint,hintlen);
417              if (color != -1 || bold != 0)
418                  abAppend(ab,"\033[0m",4);
419              if (freeHintsCallback) freeHintsCallback(hint);
420          }
421      }
422  }
423  static void refreshSingleLine(struct linenoiseState *l) {
424      char seq[64];
425      size_t plen = strlen(l->prompt);
426      int fd = l->ofd;
427      char *buf = l->buf;
428      size_t len = l->len;
429      size_t pos = l->pos;
430      struct abuf ab;
431      while((plen+pos) >= l->cols) {
432          buf++;
433          len--;
434          pos--;
435      }
436      while (plen+len > l->cols) {
437          len--;
438      }
439      abInit(&ab);
440      snprintf(seq,64,"\r");
441      abAppend(&ab,seq,(int)strlen(seq));
442      abAppend(&ab,l->prompt,(int)strlen(l->prompt));
443      abAppend(&ab,buf,(int)len);
444      refreshShowHints(&ab,l,(int)plen);                                          WIN_PORT_FIX &bsol;* cast int */
445      snprintf(seq,64,"\x1b[0K");
446      abAppend(&ab,seq,(int)strlen(seq));
447      snprintf(seq,64,"\r\x1b[%dC", (int)(pos+plen));
448      abAppend(&ab,seq,(int)strlen(seq));
449      if (write(fd,ab.b,ab.len) == -1) {} &bsol;* Can't recover from write error. */
450      abFree(&ab);
451  }
452  static void refreshMultiLine(struct linenoiseState *l) {
453      char seq[64];
454      int plen = (int)strlen(l->prompt);
455      int rows = (int)((plen+l->len+l->cols-1)/l->cols); &bsol;* rows used by current buf. */
<span onclick='openModal()' class='match'>456      int rpos = (int)((plen+l->oldpos+l->cols)/l->cols); &bsol;* cursor relative row. */
457      int rpos2; &bsol;* rpos after refresh. */
458      int col; &bsol;* colum position, zero-based. */
459      int old_rows = (int)l->maxrows;
</span>460      int fd = l->ofd, j;
461      struct abuf ab;
462      if (rows > (int)l->maxrows) l->maxrows = rows;
463      abInit(&ab);
464      if (old_rows-rpos > 0) {
465          lndebug("go down %d", old_rows-rpos);
466          snprintf(seq,64,"\x1b[%dB", old_rows-rpos);
467          abAppend(&ab,seq,(int)strlen(seq));
468      }
469      for (j = 0; j < old_rows-1; j++) {
470          lndebug("clear+up");
471          snprintf(seq,64,"\r\x1b[0K\x1b[1A");
472          abAppend(&ab,seq,(int)strlen(seq));
473      }
474      lndebug("clear");
475      snprintf(seq,64,"\r\x1b[0K");
476      abAppend(&ab,seq,(int)strlen(seq));
477      abAppend(&ab,l->prompt,(int)strlen(l->prompt));
478      abAppend(&ab,l->buf,(int)l->len);
479      refreshShowHints(&ab,l,plen);
480      if (l->pos &&
481          l->pos == l->len &&
482          (l->pos+plen) % l->cols == 0)
483      {
484          lndebug("<newline>");
485          abAppend(&ab,"\n",1);
486          snprintf(seq,64,"\r");
487          abAppend(&ab,seq,(int)strlen(seq));
488          rows++;
489          if (rows > (int)l->maxrows) l->maxrows = rows;
490      }
491      rpos2 = (int)((plen+l->pos+l->cols)/l->cols); &bsol;* current cursor relative row. */
492      lndebug("rpos2 %d", rpos2);
493      if (rows-rpos2 > 0) {
494          lndebug("go-up %d", rows-rpos2);
495          snprintf(seq,64,"\x1b[%dA", rows-rpos2);
496          abAppend(&ab,seq,(int)strlen(seq));
497      }
498      col = (plen+(int)l->pos) % (int)l->cols;
499      lndebug("set col %d", 1+col);
500      if (col)
501          snprintf(seq,64,"\r\x1b[%dC", col);
502      else
503          snprintf(seq,64,"\r");
504      abAppend(&ab,seq,(int)strlen(seq));
505      lndebug("\n");
506      l->oldpos = l->pos;
507      if (write(fd,ab.b,ab.len) == -1) {} &bsol;* Can't recover from write error. */
508      abFree(&ab);
509  }
510  static void refreshLine(struct linenoiseState *l) {
511      if (mlmode)
512          refreshMultiLine(l);
513      else
514          refreshSingleLine(l);
515  }
516  int linenoiseEditInsert(struct linenoiseState *l, char c) {
517      if (l->len < l->buflen) {
518          if (l->len == l->pos) {
519              l->buf[l->pos] = c;
520              l->pos++;
521              l->len++;
522              l->buf[l->len] = '\0';
523              if ((!mlmode && l->plen+l->len < l->cols && !hintsCallback)) {
524                  if (write(l->ofd,&c,1) == -1) return -1;
525              } else {
526                  refreshLine(l);
527              }
528          } else {
529              memmove(l->buf+l->pos+1,l->buf+l->pos,l->len-l->pos);
530              l->buf[l->pos] = c;
531              l->len++;
532              l->pos++;
533              l->buf[l->len] = '\0';
534              refreshLine(l);
535          }
536      }
537      return 0;
538  }
539  void linenoiseEditMoveLeft(struct linenoiseState *l) {
540      if (l->pos > 0) {
541          l->pos--;
542          refreshLine(l);
543      }
544  }
545  void linenoiseEditMoveRight(struct linenoiseState *l) {
546      if (l->pos != l->len) {
547          l->pos++;
548          refreshLine(l);
549      }
550  }
551  void linenoiseEditMoveHome(struct linenoiseState *l) {
552      if (l->pos != 0) {
553          l->pos = 0;
554          refreshLine(l);
555      }
556  }
557  void linenoiseEditMoveEnd(struct linenoiseState *l) {
558      if (l->pos != l->len) {
559          l->pos = l->len;
560          refreshLine(l);
561      }
562  }
563  #define LINENOISE_HISTORY_NEXT 0
564  #define LINENOISE_HISTORY_PREV 1
565  void linenoiseEditHistoryNext(struct linenoiseState *l, int dir) {
566      if (history_len > 1) {
567          free(history[history_len - 1 - l->history_index]);
568          history[history_len - 1 - l->history_index] = strdup(l->buf);
569          l->history_index += (dir == LINENOISE_HISTORY_PREV) ? 1 : -1;
570          if (l->history_index < 0) {
571              l->history_index = 0;
572              return;
573          } else if (l->history_index >= history_len) {
574              l->history_index = history_len-1;
575              return;
576          }
577          strncpy(l->buf,history[history_len - 1 - l->history_index],l->buflen);
578          l->buf[l->buflen-1] = '\0';
579          l->len = l->pos = strlen(l->buf);
580          refreshLine(l);
581      }
582  }
583  void linenoiseEditDelete(struct linenoiseState *l) {
584      if (l->len > 0 && l->pos < l->len) {
585          memmove(l->buf+l->pos,l->buf+l->pos+1,l->len-l->pos-1);
586          l->len--;
587          l->buf[l->len] = '\0';
588          refreshLine(l);
589      }
590  }
591  void linenoiseEditBackspace(struct linenoiseState *l) {
592      if (l->pos > 0 && l->len > 0) {
593          memmove(l->buf+l->pos-1,l->buf+l->pos,l->len-l->pos);
594          l->pos--;
595          l->len--;
596          l->buf[l->len] = '\0';
597          refreshLine(l);
598      }
599  }
600  void linenoiseEditDeletePrevWord(struct linenoiseState *l) {
601      size_t old_pos = l->pos;
602      size_t diff;
603      while (l->pos > 0 && l->buf[l->pos-1] == ' ')
604          l->pos--;
605      while (l->pos > 0 && l->buf[l->pos-1] != ' ')
606          l->pos--;
607      diff = old_pos - l->pos;
608      memmove(l->buf+l->pos,l->buf+old_pos,l->len-old_pos+1);
609      l->len -= diff;
610      refreshLine(l);
611  }
612  static int linenoiseEdit(int stdin_fd, int stdout_fd, char *buf, size_t buflen, const char *prompt)
613  {
614      struct linenoiseState l;
615      l.ifd = stdin_fd;
616      l.ofd = stdout_fd;
617      l.buf = buf;
618      l.buflen = buflen;
619      l.prompt = prompt;
620      l.plen = strlen(prompt);
621      l.oldpos = l.pos = 0;
622      l.len = 0;
623      l.cols = getColumns(stdin_fd, stdout_fd);
624      l.maxrows = 0;
625      l.history_index = 0;
626      l.buf[0] = '\0';
627      l.buflen--; &bsol;* Make sure there is always space for the nulterm */
628      linenoiseHistoryAdd("");
629      if (write(l.ofd,prompt,l.plen) == -1) return -1;
630      while(1) {
631          char c;
632          int nread;
633          char seq[3];
634  #ifdef _WIN32
635          nread = win32read(&c);
636  #else
637          nread = read(l.ifd,&c,1);
638  #endif
639          if (nread <= 0) return (int)l.len;
640          if (c == 9 && completionCallback != NULL) {
641              c = completeLine(&l);
642              if (c < 0) return (int)l.len;
643              if (c == 0) continue;
644          }
645          switch(c) {
646          case ENTER:    &bsol;* enter */
647              history_len--;
648              free(history[history_len]);
649              if (mlmode) linenoiseEditMoveEnd(&l);
650              if (hintsCallback) {
651                  linenoiseHintsCallback *hc = hintsCallback;
652                  hintsCallback = NULL;
653                  refreshLine(&l);
654                  hintsCallback = hc;
655              }
656              return (int)l.len;
657          case CTRL_C:     &bsol;* ctrl-c */
658              errno = EAGAIN;
659              return -1;
660          case BACKSPACE:   &bsol;* backspace */
661          case 8:     &bsol;* ctrl-h */
662              linenoiseEditBackspace(&l);
663              break;
664          case CTRL_D:     &bsol;* ctrl-d, remove char at right of cursor, or if the
665                              line is empty, act as end-of-file. */
666              if (l.len > 0) {
667                  linenoiseEditDelete(&l);
668              } else {
669                  history_len--;
670                  free(history[history_len]);
671                  return -1;
672              }
673              break;
674          case CTRL_T:    &bsol;* ctrl-t, swaps current character with previous. */
675              if (l.pos > 0 && l.pos < l.len) {
676                  int aux = buf[l.pos-1];
677                  buf[l.pos-1] = buf[l.pos];
678                  buf[l.pos] = aux;
679                  if (l.pos != l.len-1) l.pos++;
680                  refreshLine(&l);
681              }
682              break;
683          case CTRL_B:     &bsol;* ctrl-b */
684              linenoiseEditMoveLeft(&l);
685              break;
686          case CTRL_F:     &bsol;* ctrl-f */
687              linenoiseEditMoveRight(&l);
688              break;
689          case CTRL_P:    &bsol;* ctrl-p */
690              linenoiseEditHistoryNext(&l, LINENOISE_HISTORY_PREV);
691              break;
692          case CTRL_N:    &bsol;* ctrl-n */
693              linenoiseEditHistoryNext(&l, LINENOISE_HISTORY_NEXT);
694              break;
695          case ESC:    &bsol;* escape sequence */
696              if (read(l.ifd,seq,1) == -1) break;
697              if (read(l.ifd,seq+1,1) == -1) break;
698              if (seq[0] == '[') {
699                  if (seq[1] >= '0' && seq[1] <= '9') {
700                      if (read(l.ifd,seq+2,1) == -1) break;
701                      if (seq[2] == '~') {
702                          switch(seq[1]) {
703                          case '3': &bsol;* Delete key. */
704                              linenoiseEditDelete(&l);
705                              break;
706                          }
707                      }
708                  } else {
709                      switch(seq[1]) {
710                      case 'A': &bsol;* Up */
711                          linenoiseEditHistoryNext(&l, LINENOISE_HISTORY_PREV);
712                          break;
713                      case 'B': &bsol;* Down */
714                          linenoiseEditHistoryNext(&l, LINENOISE_HISTORY_NEXT);
715                          break;
716                      case 'C': &bsol;* Right */
717                          linenoiseEditMoveRight(&l);
718                          break;
719                      case 'D': &bsol;* Left */
720                          linenoiseEditMoveLeft(&l);
721                          break;
722                      case 'H': &bsol;* Home */
723                          linenoiseEditMoveHome(&l);
724                          break;
725                      case 'F': &bsol;* End*/
726                          linenoiseEditMoveEnd(&l);
727                          break;
728                      }
729                  }
730              }
731              else if (seq[0] == 'O') {
732                  switch(seq[1]) {
733                  case 'H': &bsol;* Home */
734                      linenoiseEditMoveHome(&l);
735                      break;
736                  case 'F': &bsol;* End*/
737                      linenoiseEditMoveEnd(&l);
738                      break;
739                  }
740              }
741              break;
742          default:
743              if (linenoiseEditInsert(&l,c)) return -1;
744              break;
745          case CTRL_U: &bsol;* Ctrl+u, delete the whole line. */
746              buf[0] = '\0';
747              l.pos = l.len = 0;
748              refreshLine(&l);
749              break;
750          case CTRL_K: &bsol;* Ctrl+k, delete from current to end of line. */
751              buf[l.pos] = '\0';
752              l.len = l.pos;
753              refreshLine(&l);
754              break;
755          case CTRL_A: &bsol;* Ctrl+a, go to the start of the line */
756              linenoiseEditMoveHome(&l);
757              break;
758          case CTRL_E: &bsol;* ctrl+e, go to the end of the line */
759              linenoiseEditMoveEnd(&l);
760              break;
761          case CTRL_L: &bsol;* ctrl+l, clear screen */
762              linenoiseClearScreen();
763              refreshLine(&l);
764              break;
765          case CTRL_W: &bsol;* ctrl+w, delete previous word */
766              linenoiseEditDeletePrevWord(&l);
767              break;
768          }
769      }
770      return (int)l.len;
771  }
772  void linenoisePrintKeyCodes(void) {
773      char quit[4];
774      printf("Linenoise key codes debugging mode.\n"
775              "Press keys to see scan codes. Type 'quit' at any time to exit.\n");
776      if (enableRawMode(STDIN_FILENO) == -1) return;
777      memset(quit,' ',4);
778      while(1) {
779          char c;
780          int nread;
781          nread = (int)read(STDIN_FILENO,&c,1);                                   WIN_PORT_FIX &bsol;* cast (int) */
782          if (nread <= 0) continue;
783          memmove(quit,quit+1,sizeof(quit)-1); &bsol;* shift string to left. */
784          quit[sizeof(quit)-1] = c; &bsol;* Insert current char on the right. */
785          if (memcmp(quit,"quit",sizeof(quit)) == 0) break;
786          printf("'%c' %02x (%d) (type quit to exit)\n",
787              isprint(c) ? c : '?', (int)c, (int)c);
788          printf("\r"); &bsol;* Go left edge manually, we are in raw mode. */
789          fflush(stdout);
790      }
791      disableRawMode(STDIN_FILENO);
792  }
793  static int linenoiseRaw(char *buf, size_t buflen, const char *prompt) {
794      int count;
795      if (buflen == 0) {
796          errno = EINVAL;
797          return -1;
798      }
799      if (enableRawMode(STDIN_FILENO) == -1) return -1;
800      count = linenoiseEdit(STDIN_FILENO, STDOUT_FILENO, buf, buflen, prompt);
801      disableRawMode(STDIN_FILENO);
802      printf("\n");
803      return count;
804  }
805  static char *linenoiseNoTTY(void) {
806      char *line = NULL;
807      size_t len = 0, maxlen = 0;
808      while(1) {
809          if (len == maxlen) {
810              if (maxlen == 0) maxlen = 16;
811              maxlen *= 2;
812              char *oldval = line;
813              line = realloc(line,maxlen);
814              if (line == NULL) {
815                  if (oldval) free(oldval);
816                  return NULL;
817              }
818          }
819          int c = fgetc(stdin);
820          if (c == EOF || c == '\n') {
821              if (c == EOF && len == 0) {
822                  free(line);
823                  return NULL;
824              } else {
825                  line[len] = '\0';
826                  return line;
827              }
828          } else {
829              line[len] = c;
830              len++;
831          }
832      }
833  }
834  char *linenoise(const char *prompt) {
835      char buf[LINENOISE_MAX_LINE];
836      int count;
837      if (!isatty(STDIN_FILENO)) {
838          return linenoiseNoTTY();
839      } else if (isUnsupportedTerm()) {
840          size_t len;
841          printf("%s",prompt);
842          fflush(stdout);
843          if (fgets(buf,LINENOISE_MAX_LINE,stdin) == NULL) return NULL;
844          len = strlen(buf);
845          while(len && (buf[len-1] == '\n' || buf[len-1] == '\r')) {
846              len--;
847              buf[len] = '\0';
848          }
849          return strdup(buf);
850      } else {
851          count = linenoiseRaw(buf,LINENOISE_MAX_LINE,prompt);
852          if (count == -1) return NULL;
853          return strdup(buf);
854      }
855  }
856  void linenoiseFree(void *ptr) {
857      free(ptr);
858  }
859  static void freeHistory(void) {
860      if (history) {
861          int j;
862          for (j = 0; j < history_len; j++)
863              free(history[j]);
864          free(history);
865      }
866  }
867  static void linenoiseAtExit(void) {
868      disableRawMode(STDIN_FILENO);
869      freeHistory();
870  }
871  int linenoiseHistoryAdd(const char *line) {
872      char *linecopy;
873      if (history_max_len == 0) return 0;
874      if (history == NULL) {
875          history = malloc(sizeof(char*)*history_max_len);
876          if (history == NULL) return 0;
877          memset(history,0,(sizeof(char*)*history_max_len));
878      }
879      if (history_len && !strcmp(history[history_len-1], line)) return 0;
880      linecopy = strdup(line);
881      if (!linecopy) return 0;
882      if (history_len == history_max_len) {
883          free(history[0]);
884          memmove(history,history+1,sizeof(char*)*(history_max_len-1));
885          history_len--;
886      }
887      history[history_len] = linecopy;
888      history_len++;
889      return 1;
890  }
891  int linenoiseHistorySetMaxLen(int len) {
892      char **new;
893      if (len < 1) return 0;
894      if (history) {
895          int tocopy = history_len;
896          new = malloc(sizeof(char*)*len);
897          if (new == NULL) return 0;
898          if (len < tocopy) {
899              int j;
900              for (j = 0; j < tocopy-len; j++) free(history[j]);
901              tocopy = len;
902          }
903          memset(new,0,sizeof(char*)*len);
904          memcpy(new,history+(history_len-tocopy), sizeof(char*)*tocopy);
905          free(history);
906          history = new;
907      }
908      history_max_len = len;
909      if (history_len > history_max_len)
910          history_len = history_max_len;
911      return 1;
912  }
913  int linenoiseHistorySave(const char *filename) {
914  #ifdef _WIN32
915      FILE *fp = fopen(filename,"wb");
916  #else
917      FILE *fp = fopen(filename,"w");
918  #endif
919      int j;
920      if (fp == NULL) return -1;
921      for (j = 0; j < history_len; j++)
922          fprintf(fp,"%s\n",history[j]);
923      fclose(fp);
924      return 0;
925  }
926  int linenoiseHistoryLoad(const char *filename) {
927      FILE *fp = fopen(filename,"r");
928      char buf[LINENOISE_MAX_LINE];
929      if (fp == NULL) return -1;
930      while (fgets(buf,LINENOISE_MAX_LINE,fp) != NULL) {
931          char *p;
932          p = strchr(buf,'\r');
933          if (!p) p = strchr(buf,'\n');
934          if (p) *p = '\0';
935          linenoiseHistoryAdd(buf);
936      }
937      fclose(fp);
938      return 0;
939  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from redis-MDEwOlJlcG9zaXRvcnkxMDgxMTA3MDY=-flat-sha1.c</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from redis-MDEwOlJlcG9zaXRvcnkxMDgxMTA3MDY=-flat-linenoise.c</div>
                </div>
                <div class="column column_space"><pre><code>39      CHAR64LONG16 block[1];  &bsol;* use array to appear as a pointer */
40      memcpy(block, buffer, 64);
41  #else
42      CHAR64LONG16* block = (const CHAR64LONG16*)buffer;
</pre></code></div>
                <div class="column column_space"><pre><code>456      int rpos = (int)((plen+l->oldpos+l->cols)/l->cols); &bsol;* cursor relative row. */
457      int rpos2; &bsol;* rpos after refresh. */
458      int col; &bsol;* colum position, zero-based. */
459      int old_rows = (int)l->maxrows;
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    