
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 4.819277108433735%, Tokens: 8, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>xmrig-MDEwOlJlcG9zaXRvcnk4ODMyNzQwNg==-flat-Network.h</h3>
            <pre><code>1  #ifndef XMRIG_NETWORK_H
2  #define XMRIG_NETWORK_H
3  #include "3rdparty/rapidjson/fwd.h"
4  #include "base/api/interfaces/IApiListener.h"
5  #include "base/kernel/interfaces/IBaseListener.h"
6  #include "base/kernel/interfaces/IStrategyListener.h"
7  #include "base/kernel/interfaces/ITimerListener.h"
8  #include "base/tools/Object.h"
9  #include "interfaces/IJobResultListener.h"
10  #include <vector>
11  namespace xmrig {
12  class Controller;
13  class IStrategy;
14  class NetworkState;
15  class Network : public IJobResultListener, public IStrategyListener, public IBaseListener, public ITimerListener, public IApiListener
16  {
17  public:
18      XMRIG_DISABLE_COPY_MOVE_DEFAULT(Network)
19      Network(Controller *controller);
20      ~Network() override;
21      inline IStrategy *strategy() const { return m_strategy; }
22      void connect();
23      void execCommand(char command);
24  protected:
25      inline void onTimer(const Timer *) override { tick(); }
26      void onActive(IStrategy *strategy, IClient *client) override;
27      void onConfigChanged(Config *config, Config *previousConfig) override;
28      void onJob(IStrategy *strategy, IClient *client, const Job &job, const rapidjson::Value &params) override;
29      void onJobResult(const JobResult &result) override;
30      void onLogin(IStrategy *strategy, IClient *client, rapidjson::Document &doc, rapidjson::Value &params) override;
31      void onPause(IStrategy *strategy) override;
32      void onResultAccepted(IStrategy *strategy, IClient *client, const SubmitResult &result, const char *error) override;
33      void onVerifyAlgorithm(IStrategy *strategy, const  IClient *client, const Algorithm &algorithm, bool *ok) override;
34  #   ifdef XMRIG_FEATURE_API
35      void onRequest(IApiRequest &request) override;
36  #   endif
37  private:
38      constexpr static int kTickInterval = 1 * 1000;
39      void setJob(IClient *client, const Job &job, bool donate);
40      void tick();
41  #   ifdef XMRIG_FEATURE_API
42      void getConnection(rapidjson::Value &reply, rapidjson::Document &doc, int version) const;
<span onclick='openModal()' class='match'>43      void getResults(rapidjson::Value &reply, rapidjson::Document &doc, int version) const;
44  #   endif
45      Controller *m_controller;
46      IStrategy *m_donate     = nullptr;
47      IStrategy *m_strategy   = nullptr;
48      NetworkState *m_state   = nullptr;
</span>49      Timer *m_timer          = nullptr;
50  };
51  } 
52  #endif 
</code></pre>
        </div>
        <div class="column">
            <h3>libpcap-MDEwOlJlcG9zaXRvcnk5NDM1ODg3-flat-pcap-snit.c</h3>
            <pre><code>1  #ifdef HAVE_CONFIG_H
2  #include <config.h>
3  #endif
4  #include <sys/types.h>
5  #include <sys/time.h>
6  #include <sys/timeb.h>
7  #include <sys/dir.h>
8  #include <sys/fcntlcom.h>
9  #include <sys/file.h>
10  #include <sys/ioctl.h>
11  #include <sys/socket.h>
12  #include <sys/stropts.h>
13  #include <net/if.h>
14  #include <net/nit.h>
15  #include <net/nit_if.h>
16  #include <net/nit_pf.h>
17  #include <net/nit_buf.h>
18  #include <netinet/in.h>
19  #include <netinet/in_systm.h>
20  #include <netinet/ip.h>
21  #include <netinet/if_ether.h>
22  #include <netinet/ip_var.h>
23  #include <netinet/udp.h>
24  #include <netinet/udp_var.h>
25  #include <netinet/tcp.h>
26  #include <netinet/tcpip.h>
27  #include <errno.h>
28  #include <stdio.h>
29  #include <string.h>
30  #include <unistd.h>
31  #include "pcap-int.h"
32  #ifdef HAVE_OS_PROTO_H
33  #include "os-proto.h"
34  #endif
35  #define CHUNKSIZE (2*1024)
36  #define BUFSPACE (4*CHUNKSIZE)
37  static int nit_setflags(int, int, int, char *);
38  struct pcap_snit {
39  	struct pcap_stat stat;
40  };
41  static int
42  pcap_stats_snit(pcap_t *p, struct pcap_stat *ps)
43  {
44  	struct pcap_snit *psn = p->priv;
45  	*ps = psn->stat;
46  	return (0);
47  }
48  static int
49  pcap_read_snit(pcap_t *p, int cnt, pcap_handler callback, u_char *user)
50  {
51  	struct pcap_snit *psn = p->priv;
52  	register int cc, n;
53  	register u_char *bp, *cp, *ep;
54  	register struct nit_bufhdr *hdrp;
55  	register struct nit_iftime *ntp;
56  	register struct nit_iflen *nlp;
57  	register struct nit_ifdrops *ndp;
58  	register int caplen;
59  	cc = p->cc;
60  	if (cc == 0) {
61  		cc = read(p->fd, (char *)p->buffer, p->bufsize);
62  		if (cc < 0) {
63  			if (errno == EWOULDBLOCK)
64  				return (0);
65  			pcap_fmt_errmsg_for_errno(p->errbuf, sizeof(p->errbuf),
66  			    errno, "pcap_read");
67  			return (-1);
68  		}
69  		bp = p->buffer;
70  	} else
71  		bp = p->bp;
72  	n = 0;
73  	ep = bp + cc;
74  	while (bp < ep) {
75  		if (p->break_loop) {
76  			if (n == 0) {
77  				p->break_loop = 0;
78  				return (-2);
79  			} else {
80  				p->bp = bp;
81  				p->cc = ep - bp;
82  				return (n);
83  			}
84  		}
85  		++psn->stat.ps_recv;
86  		cp = bp;
87  		hdrp = (struct nit_bufhdr *)cp;
88  		cp += sizeof(*hdrp);
89  		ntp = (struct nit_iftime *)cp;
90  		cp += sizeof(*ntp);
91  		ndp = (struct nit_ifdrops *)cp;
92  		psn->stat.ps_drop = ndp->nh_drops;
93  		cp += sizeof *ndp;
94  		nlp = (struct nit_iflen *)cp;
95  		cp += sizeof(*nlp);
96  		bp += hdrp->nhb_totlen;
97  		caplen = nlp->nh_pktlen;
98  		if (caplen > p->snapshot)
99  			caplen = p->snapshot;
100  		if (pcap_filter(p->fcode.bf_insns, cp, nlp->nh_pktlen, caplen)) {
101  			struct pcap_pkthdr h;
102  			h.ts = ntp->nh_timestamp;
103  			h.len = nlp->nh_pktlen;
104  			h.caplen = caplen;
105  			(*callback)(user, &h, cp);
106  			if (++n >= cnt && !PACKET_COUNT_IS_UNLIMITED(cnt)) {
107  				p->cc = ep - bp;
108  				p->bp = bp;
109  				return (n);
110  			}
111  		}
112  	}
113  	p->cc = 0;
114  	return (n);
115  }
116  static int
117  pcap_inject_snit(pcap_t *p, const void *buf, int size)
118  {
119  	struct strbuf ctl, data;
120  	ctl.len = sizeof(*sa);	&bsol;* XXX - what was this? */
121  	ctl.buf = (char *)sa;
122  	data.buf = buf;
123  	data.len = size;
124  	ret = putmsg(p->fd, &ctl, &data);
125  	if (ret == -1) {
126  		pcap_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,
127  		    errno, "send");
128  		return (-1);
129  	}
130  	return (ret);
131  }
132  static int
133  nit_setflags(pcap_t *p)
134  {
135  	bpf_u_int32 flags;
136  	struct strioctl si;
137  	u_int zero = 0;
138  	struct timeval timeout;
139  	if (p->opt.immediate) {
140  		si.ic_cmd = NIOCSCHUNK;
141  		si.ic_len = sizeof(zero);
142  		si.ic_dp = (char *)&zero;
143  		if (ioctl(p->fd, I_STR, (char *)&si) < 0) {
144  			pcap_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,
145  			    errno, "NIOCSCHUNK");
146  			return (-1);
147  		}
148  	}
149  	si.ic_timout = INFTIM;
150  	if (p->opt.timeout != 0) {
151  		timeout.tv_sec = p->opt.timeout / 1000;
152  		timeout.tv_usec = (p->opt.timeout * 1000) % 1000000;
153  		si.ic_cmd = NIOCSTIME;
154  		si.ic_len = sizeof(timeout);
155  		si.ic_dp = (char *)&timeout;
156  		if (ioctl(p->fd, I_STR, (char *)&si) < 0) {
157  			pcap_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,
158  			    errno, "NIOCSTIME");
159  			return (-1);
160  		}
161  	}
162  	flags = NI_TIMESTAMP | NI_LEN | NI_DROPS;
163  	if (p->opt.promisc)
164  		flags |= NI_PROMISC;
165  	si.ic_cmd = NIOCSFLAGS;
166  	si.ic_len = sizeof(flags);
167  	si.ic_dp = (char *)&flags;
168  	if (ioctl(p->fd, I_STR, (char *)&si) < 0) {
169  		pcap_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,
170  		    errno, "NIOCSFLAGS");
171  		return (-1);
172  	}
173  	return (0);
174  }
175  static int
176  pcap_activate_snit(pcap_t *p)
177  {
178  	struct strioctl si;		&bsol;* struct for ioctl() */
179  	struct ifreq ifr;		&bsol;* interface request struct */
180  	int chunksize = CHUNKSIZE;
181  	int fd;
182  	static const char dev[] = "/dev/nit";
183  	int err;
184  	if (p->opt.rfmon) {
185  		return (PCAP_ERROR_RFMON_NOTSUP);
186  	}
187  	if (p->snapshot <= 0 || p->snapshot > MAXIMUM_SNAPLEN)
188  		p->snapshot = MAXIMUM_SNAPLEN;
189  	if (p->snapshot < 96)
190  		p->snapshot = 96;
191  	p->fd = fd = open(dev, O_RDWR);
192  	if (fd < 0 && errno == EACCES)
193  		p->fd = fd = open(dev, O_RDONLY);
194  	if (fd < 0) {
195  		if (errno == EACCES) {
196  			err = PCAP_ERROR_PERM_DENIED;
197  			snprintf(p->errbuf, PCAP_ERRBUF_SIZE,
198  			    "Attempt to open %s failed with EACCES - root privileges may be required",
199  			    dev);
200  		} else {
201  			err = PCAP_ERROR;
202  			pcap_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,
203  			    errno, "%s", dev);
204  		}
205  		goto bad;
206  	}
207  	if (ioctl(fd, I_SRDOPT, (char *)RMSGD) < 0) {
208  		pcap_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,
209  		    errno, "I_SRDOPT");
210  		err = PCAP_ERROR;
211  		goto bad;
212  	}
213  	if (ioctl(fd, I_PUSH, "nbuf") < 0) {
214  		pcap_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,
215  		    errno, "push nbuf");
216  		err = PCAP_ERROR;
217  		goto bad;
218  	}
219  	si.ic_cmd = NIOCSCHUNK;
220  	si.ic_timout = INFTIM;
221  	si.ic_len = sizeof(chunksize);
222  	si.ic_dp = (char *)&chunksize;
223  	if (ioctl(fd, I_STR, (char *)&si) < 0) {
224  		pcap_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,
225  		    errno, "NIOCSCHUNK");
226  		err = PCAP_ERROR;
227  		goto bad;
228  	}
229  	strncpy(ifr.ifr_name, p->opt.device, sizeof(ifr.ifr_name));
230  	ifr.ifr_name[sizeof(ifr.ifr_name) - 1] = '\0';
231  	si.ic_cmd = NIOCBIND;
232  	si.ic_len = sizeof(ifr);
233  	si.ic_dp = (char *)&ifr;
234  	if (ioctl(fd, I_STR, (char *)&si) < 0) {
235  		pcap_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,
236  		    errno, "NIOCBIND: %s", ifr.ifr_name);
237  		err = PCAP_ERROR;
238  		goto bad;
239  	}
240  	si.ic_cmd = NIOCSSNAP;
241  	si.ic_len = sizeof(p->snapshot);
242  	si.ic_dp = (char *)&p->snapshot;
243  	if (ioctl(fd, I_STR, (char *)&si) < 0) {
244  		pcap_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,
245  		    errno, "NIOCSSNAP");
246  		err = PCAP_ERROR;
247  		goto bad;
248  	}
249  	if (nit_setflags(p) < 0) {
250  		err = PCAP_ERROR;
251  		goto bad;
252  	}
253  	(void)ioctl(fd, I_FLUSH, (char *)FLUSHR);
254  	p->linktype = DLT_EN10MB;
255  	p->bufsize = BUFSPACE;
256  	p->buffer = malloc(p->bufsize);
257  	if (p->buffer == NULL) {
258  		pcap_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,
259  		    errno, "malloc");
260  		err = PCAP_ERROR;
261  		goto bad;
262  	}
263  	p->selectable_fd = p->fd;
264  	p->dlt_list = (u_int *) malloc(sizeof(u_int) * 2);
265  	if (p->dlt_list != NULL) {
266  		p->dlt_list[0] = DLT_EN10MB;
267  		p->dlt_list[1] = DLT_DOCSIS;
268  		p->dlt_count = 2;
269  	}
270  	p->read_op = pcap_read_snit;
271  	p->inject_op = pcap_inject_snit;
<span onclick='openModal()' class='match'>272  	p->setfilter_op = pcap_install_bpf_program;	&bsol;* no kernel filtering */
273  	p->setdirection_op = NULL;	&bsol;* Not implemented. */
274  	p->set_datalink_op = NULL;	&bsol;* can't change data link type */
275  	p->getnonblock_op = pcap_getnonblock_fd;
</span>276  	p->setnonblock_op = pcap_setnonblock_fd;
277  	p->stats_op = pcap_stats_snit;
278  	return (0);
279   bad:
280  	pcap_cleanup_live_common(p);
281  	return (err);
282  }
283  pcap_t *
284  pcap_create_interface(const char *device _U_, char *ebuf)
285  {
286  	pcap_t *p;
287  	p = PCAP_CREATE_COMMON(ebuf, struct pcap_snit);
288  	if (p == NULL)
289  		return (NULL);
290  	p->activate_op = pcap_activate_snit;
291  	return (p);
292  }
293  static int
294  can_be_bound(const char *name _U_)
295  {
296  	return (1);
297  }
298  static int
299  get_if_flags(const char *name _U_, bpf_u_int32 *flags _U_, char *errbuf _U_)
300  {
301  	return (0);
302  }
303  int
304  pcap_platform_finddevs(pcap_if_list_t *devlistp, char *errbuf)
305  {
306  	return (pcap_findalldevs_interfaces(devlistp, errbuf, can_be_bound,
307  	    get_if_flags));
308  }
309  const char *
310  pcap_lib_version(void)
311  {
312  	return (PCAP_VERSION_STRING);
313  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from xmrig-MDEwOlJlcG9zaXRvcnk4ODMyNzQwNg==-flat-Network.h</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from libpcap-MDEwOlJlcG9zaXRvcnk5NDM1ODg3-flat-pcap-snit.c</div>
                </div>
                <div class="column column_space"><pre><code>43      void getResults(rapidjson::Value &reply, rapidjson::Document &doc, int version) const;
44  #   endif
45      Controller *m_controller;
46      IStrategy *m_donate     = nullptr;
47      IStrategy *m_strategy   = nullptr;
48      NetworkState *m_state   = nullptr;
</pre></code></div>
                <div class="column column_space"><pre><code>272  	p->setfilter_op = pcap_install_bpf_program;	&bsol;* no kernel filtering */
273  	p->setdirection_op = NULL;	&bsol;* Not implemented. */
274  	p->set_datalink_op = NULL;	&bsol;* can't change data link type */
275  	p->getnonblock_op = pcap_getnonblock_fd;
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    