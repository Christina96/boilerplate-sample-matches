
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 7.221664994984955%, Tokens: 10, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>libtomcrypt-MDEwOlJlcG9zaXRvcnk3NzcwMTE=-flat-sha256.c</h3>
            <pre><code>1  #include "tomcrypt_private.h"
2  #ifdef LTC_SHA256
3  const struct ltc_hash_descriptor sha256_desc =
4  {
5      "sha256",
6      0,
7      32,
8      64,
9     { 2, 16, 840, 1, 101, 3, 4, 2, 1,  },
10     9,
11      &sha256_init,
12      &sha256_process,
13      &sha256_done,
14      &sha256_test,
15      NULL
16  };
17  #ifdef LTC_SMALL_CODE
18  static const ulong32 K[64] = {
19      0x428a2f98UL, 0x71374491UL, 0xb5c0fbcfUL, 0xe9b5dba5UL, 0x3956c25bUL,
20      0x59f111f1UL, 0x923f82a4UL, 0xab1c5ed5UL, 0xd807aa98UL, 0x12835b01UL,
21      0x243185beUL, 0x550c7dc3UL, 0x72be5d74UL, 0x80deb1feUL, 0x9bdc06a7UL,
22      0xc19bf174UL, 0xe49b69c1UL, 0xefbe4786UL, 0x0fc19dc6UL, 0x240ca1ccUL,
23      0x2de92c6fUL, 0x4a7484aaUL, 0x5cb0a9dcUL, 0x76f988daUL, 0x983e5152UL,
24      0xa831c66dUL, 0xb00327c8UL, 0xbf597fc7UL, 0xc6e00bf3UL, 0xd5a79147UL,
25      0x06ca6351UL, 0x14292967UL, 0x27b70a85UL, 0x2e1b2138UL, 0x4d2c6dfcUL,
26      0x53380d13UL, 0x650a7354UL, 0x766a0abbUL, 0x81c2c92eUL, 0x92722c85UL,
27      0xa2bfe8a1UL, 0xa81a664bUL, 0xc24b8b70UL, 0xc76c51a3UL, 0xd192e819UL,
28      0xd6990624UL, 0xf40e3585UL, 0x106aa070UL, 0x19a4c116UL, 0x1e376c08UL,
29      0x2748774cUL, 0x34b0bcb5UL, 0x391c0cb3UL, 0x4ed8aa4aUL, 0x5b9cca4fUL,
30      0x682e6ff3UL, 0x748f82eeUL, 0x78a5636fUL, 0x84c87814UL, 0x8cc70208UL,
31      0x90befffaUL, 0xa4506cebUL, 0xbef9a3f7UL, 0xc67178f2UL
32  };
33  #endif
34  #define Ch(x,y,z)       (z ^ (x & (y ^ z)))
35  #define Maj(x,y,z)      (((x | y) & z) | (x & y))
36  #define S(x, n)         RORc((x),(n))
37  #define R(x, n)         (((x)&0xFFFFFFFFUL)>>(n))
38  #define Sigma0(x)       (S(x, 2) ^ S(x, 13) ^ S(x, 22))
39  #define Sigma1(x)       (S(x, 6) ^ S(x, 11) ^ S(x, 25))
40  #define Gamma0(x)       (S(x, 7) ^ S(x, 18) ^ R(x, 3))
41  #define Gamma1(x)       (S(x, 17) ^ S(x, 19) ^ R(x, 10))
42  #ifdef LTC_CLEAN_STACK
43  static int ss_sha256_compress(hash_state * md, const unsigned char *buf)
44  #else
45  static int s_sha256_compress(hash_state * md, const unsigned char *buf)
46  #endif
47  {
48      ulong32 S[8], W[64], t0, t1;
49  #ifdef LTC_SMALL_CODE
50      ulong32 t;
51  #endif
52      int i;
53      for (i = 0; i < 8; i++) {
54          S[i] = md->sha256.state[i];
55      }
56      for (i = 0; i < 16; i++) {
57          LOAD32H(W[i], buf + (4*i));
58      }
59      for (i = 16; i < 64; i++) {
60          W[i] = Gamma1(W[i - 2]) + W[i - 7] + Gamma0(W[i - 15]) + W[i - 16];
61      }
62  #ifdef LTC_SMALL_CODE
63  #define RND(a,b,c,d,e,f,g,h,i)                         \
64       t0 = h + Sigma1(e) + Ch(e, f, g) + K[i] + W[i];   \
65       t1 = Sigma0(a) + Maj(a, b, c);                    \
66       d += t0;                                          \
67       h  = t0 + t1;
68       for (i = 0; i < 64; ++i) {
69           RND(S[0],S[1],S[2],S[3],S[4],S[5],S[6],S[7],i);
70           t = S[7]; S[7] = S[6]; S[6] = S[5]; S[5] = S[4];
71           S[4] = S[3]; S[3] = S[2]; S[2] = S[1]; S[1] = S[0]; S[0] = t;
72       }
73  #else
74  #define RND(a,b,c,d,e,f,g,h,i,ki)                    \
75       t0 = h + Sigma1(e) + Ch(e, f, g) + ki + W[i];   \
76       t1 = Sigma0(a) + Maj(a, b, c);                  \
77       d += t0;                                        \
78       h  = t0 + t1;
79      RND(S[0],S[1],S[2],S[3],S[4],S[5],S[6],S[7],0,0x428a2f98);
80      RND(S[7],S[0],S[1],S[2],S[3],S[4],S[5],S[6],1,0x71374491);
81      RND(S[6],S[7],S[0],S[1],S[2],S[3],S[4],S[5],2,0xb5c0fbcf);
82      RND(S[5],S[6],S[7],S[0],S[1],S[2],S[3],S[4],3,0xe9b5dba5);
83      RND(S[4],S[5],S[6],S[7],S[0],S[1],S[2],S[3],4,0x3956c25b);
84      RND(S[3],S[4],S[5],S[6],S[7],S[0],S[1],S[2],5,0x59f111f1);
85      RND(S[2],S[3],S[4],S[5],S[6],S[7],S[0],S[1],6,0x923f82a4);
86      RND(S[1],S[2],S[3],S[4],S[5],S[6],S[7],S[0],7,0xab1c5ed5);
87      RND(S[0],S[1],S[2],S[3],S[4],S[5],S[6],S[7],8,0xd807aa98);
88      RND(S[7],S[0],S[1],S[2],S[3],S[4],S[5],S[6],9,0x12835b01);
89      RND(S[6],S[7],S[0],S[1],S[2],S[3],S[4],S[5],10,0x243185be);
90      RND(S[5],S[6],S[7],S[0],S[1],S[2],S[3],S[4],11,0x550c7dc3);
91      RND(S[4],S[5],S[6],S[7],S[0],S[1],S[2],S[3],12,0x72be5d74);
92      RND(S[3],S[4],S[5],S[6],S[7],S[0],S[1],S[2],13,0x80deb1fe);
93      RND(S[2],S[3],S[4],S[5],S[6],S[7],S[0],S[1],14,0x9bdc06a7);
94      RND(S[1],S[2],S[3],S[4],S[5],S[6],S[7],S[0],15,0xc19bf174);
95      RND(S[0],S[1],S[2],S[3],S[4],S[5],S[6],S[7],16,0xe49b69c1);
96      RND(S[7],S[0],S[1],S[2],S[3],S[4],S[5],S[6],17,0xefbe4786);
97      RND(S[6],S[7],S[0],S[1],S[2],S[3],S[4],S[5],18,0x0fc19dc6);
98      RND(S[5],S[6],S[7],S[0],S[1],S[2],S[3],S[4],19,0x240ca1cc);
99      RND(S[4],S[5],S[6],S[7],S[0],S[1],S[2],S[3],20,0x2de92c6f);
100      RND(S[3],S[4],S[5],S[6],S[7],S[0],S[1],S[2],21,0x4a7484aa);
101      RND(S[2],S[3],S[4],S[5],S[6],S[7],S[0],S[1],22,0x5cb0a9dc);
102      RND(S[1],S[2],S[3],S[4],S[5],S[6],S[7],S[0],23,0x76f988da);
103      RND(S[0],S[1],S[2],S[3],S[4],S[5],S[6],S[7],24,0x983e5152);
104      RND(S[7],S[0],S[1],S[2],S[3],S[4],S[5],S[6],25,0xa831c66d);
105      RND(S[6],S[7],S[0],S[1],S[2],S[3],S[4],S[5],26,0xb00327c8);
106      RND(S[5],S[6],S[7],S[0],S[1],S[2],S[3],S[4],27,0xbf597fc7);
107      RND(S[4],S[5],S[6],S[7],S[0],S[1],S[2],S[3],28,0xc6e00bf3);
108      RND(S[3],S[4],S[5],S[6],S[7],S[0],S[1],S[2],29,0xd5a79147);
109      RND(S[2],S[3],S[4],S[5],S[6],S[7],S[0],S[1],30,0x06ca6351);
110      RND(S[1],S[2],S[3],S[4],S[5],S[6],S[7],S[0],31,0x14292967);
111      RND(S[0],S[1],S[2],S[3],S[4],S[5],S[6],S[7],32,0x27b70a85);
112      RND(S[7],S[0],S[1],S[2],S[3],S[4],S[5],S[6],33,0x2e1b2138);
113      RND(S[6],S[7],S[0],S[1],S[2],S[3],S[4],S[5],34,0x4d2c6dfc);
114      RND(S[5],S[6],S[7],S[0],S[1],S[2],S[3],S[4],35,0x53380d13);
115      RND(S[4],S[5],S[6],S[7],S[0],S[1],S[2],S[3],36,0x650a7354);
116      RND(S[3],S[4],S[5],S[6],S[7],S[0],S[1],S[2],37,0x766a0abb);
117      RND(S[2],S[3],S[4],S[5],S[6],S[7],S[0],S[1],38,0x81c2c92e);
118      RND(S[1],S[2],S[3],S[4],S[5],S[6],S[7],S[0],39,0x92722c85);
119      RND(S[0],S[1],S[2],S[3],S[4],S[5],S[6],S[7],40,0xa2bfe8a1);
120      RND(S[7],S[0],S[1],S[2],S[3],S[4],S[5],S[6],41,0xa81a664b);
121      RND(S[6],S[7],S[0],S[1],S[2],S[3],S[4],S[5],42,0xc24b8b70);
122      RND(S[5],S[6],S[7],S[0],S[1],S[2],S[3],S[4],43,0xc76c51a3);
123      RND(S[4],S[5],S[6],S[7],S[0],S[1],S[2],S[3],44,0xd192e819);
124      RND(S[3],S[4],S[5],S[6],S[7],S[0],S[1],S[2],45,0xd6990624);
125      RND(S[2],S[3],S[4],S[5],S[6],S[7],S[0],S[1],46,0xf40e3585);
126      RND(S[1],S[2],S[3],S[4],S[5],S[6],S[7],S[0],47,0x106aa070);
127      RND(S[0],S[1],S[2],S[3],S[4],S[5],S[6],S[7],48,0x19a4c116);
128      RND(S[7],S[0],S[1],S[2],S[3],S[4],S[5],S[6],49,0x1e376c08);
129      RND(S[6],S[7],S[0],S[1],S[2],S[3],S[4],S[5],50,0x2748774c);
130      RND(S[5],S[6],S[7],S[0],S[1],S[2],S[3],S[4],51,0x34b0bcb5);
131      RND(S[4],S[5],S[6],S[7],S[0],S[1],S[2],S[3],52,0x391c0cb3);
132      RND(S[3],S[4],S[5],S[6],S[7],S[0],S[1],S[2],53,0x4ed8aa4a);
133      RND(S[2],S[3],S[4],S[5],S[6],S[7],S[0],S[1],54,0x5b9cca4f);
134      RND(S[1],S[2],S[3],S[4],S[5],S[6],S[7],S[0],55,0x682e6ff3);
135      RND(S[0],S[1],S[2],S[3],S[4],S[5],S[6],S[7],56,0x748f82ee);
136      RND(S[7],S[0],S[1],S[2],S[3],S[4],S[5],S[6],57,0x78a5636f);
137      RND(S[6],S[7],S[0],S[1],S[2],S[3],S[4],S[5],58,0x84c87814);
138      RND(S[5],S[6],S[7],S[0],S[1],S[2],S[3],S[4],59,0x8cc70208);
139      RND(S[4],S[5],S[6],S[7],S[0],S[1],S[2],S[3],60,0x90befffa);
140      RND(S[3],S[4],S[5],S[6],S[7],S[0],S[1],S[2],61,0xa4506ceb);
141      RND(S[2],S[3],S[4],S[5],S[6],S[7],S[0],S[1],62,0xbef9a3f7);
142      RND(S[1],S[2],S[3],S[4],S[5],S[6],S[7],S[0],63,0xc67178f2);
143  #endif
144  #undef RND
145      for (i = 0; i < 8; i++) {
146          md->sha256.state[i] = md->sha256.state[i] + S[i];
147      }
148      return CRYPT_OK;
149  }
150  #ifdef LTC_CLEAN_STACK
151  static int s_sha256_compress(hash_state * md, const unsigned char *buf)
152  {
153      int err;
154      err = ss_sha256_compress(md, buf);
155      burn_stack(sizeof(ulong32) * 74);
156      return err;
157  }
158  #endif
159  int sha256_init(hash_state * md)
160  {
161      LTC_ARGCHK(md != NULL);
<span onclick='openModal()' class='match'>162      md->sha256.curlen = 0;
163      md->sha256.length = 0;
164      md->sha256.state[0] = 0x6A09E667UL;
165      md->sha256.state[1] = 0xBB67AE85UL;
166      md->sha256.state[2] = 0x3C6EF372UL;
167      md->sha256.state[3] = 0xA54FF53AUL;
168      md->sha256.state[4] = 0x510E527FUL;
169      md->sha256.state[5] = 0x9B05688CUL;
170      md->sha256.state[6] = 0x1F83D9ABUL;
171      md->sha256.state[7] = 0x5BE0CD19UL;
</span>172      return CRYPT_OK;
173  }
174  HASH_PROCESS(sha256_process,s_sha256_compress, sha256, 64)
175  int sha256_done(hash_state * md, unsigned char *out)
176  {
177      int i;
178      LTC_ARGCHK(md  != NULL);
179      LTC_ARGCHK(out != NULL);
180      if (md->sha256.curlen >= sizeof(md->sha256.buf)) {
181         return CRYPT_INVALID_ARG;
182      }
183      md->sha256.length += md->sha256.curlen * 8;
184      md->sha256.buf[md->sha256.curlen++] = (unsigned char)0x80;
185      if (md->sha256.curlen > 56) {
186          while (md->sha256.curlen < 64) {
187              md->sha256.buf[md->sha256.curlen++] = (unsigned char)0;
188          }
189          s_sha256_compress(md, md->sha256.buf);
190          md->sha256.curlen = 0;
191      }
192      while (md->sha256.curlen < 56) {
193          md->sha256.buf[md->sha256.curlen++] = (unsigned char)0;
194      }
195      STORE64H(md->sha256.length, md->sha256.buf+56);
196      s_sha256_compress(md, md->sha256.buf);
197      for (i = 0; i < 8; i++) {
198          STORE32H(md->sha256.state[i], out+(4*i));
199      }
200  #ifdef LTC_CLEAN_STACK
201      zeromem(md, sizeof(hash_state));
202  #endif
203      return CRYPT_OK;
204  }
205  int  sha256_test(void)
206  {
207   #ifndef LTC_TEST
208      return CRYPT_NOP;
209   #else
210    static const struct {
211        const char *msg;
212        unsigned char hash[32];
213    } tests[] = {
214      { "abc",
215        { 0xba, 0x78, 0x16, 0xbf, 0x8f, 0x01, 0xcf, 0xea,
216          0x41, 0x41, 0x40, 0xde, 0x5d, 0xae, 0x22, 0x23,
217          0xb0, 0x03, 0x61, 0xa3, 0x96, 0x17, 0x7a, 0x9c,
218          0xb4, 0x10, 0xff, 0x61, 0xf2, 0x00, 0x15, 0xad }
219      },
220      { "abcdbcdecdefdefgefghfghighijhijkijkljklmklmnlmnomnopnopq",
221        { 0x24, 0x8d, 0x6a, 0x61, 0xd2, 0x06, 0x38, 0xb8,
222          0xe5, 0xc0, 0x26, 0x93, 0x0c, 0x3e, 0x60, 0x39,
223          0xa3, 0x3c, 0xe4, 0x59, 0x64, 0xff, 0x21, 0x67,
224          0xf6, 0xec, 0xed, 0xd4, 0x19, 0xdb, 0x06, 0xc1 }
225      },
226    };
227    int i;
228    unsigned char tmp[32];
229    hash_state md;
230    for (i = 0; i < (int)(sizeof(tests) / sizeof(tests[0])); i++) {
231        sha256_init(&md);
232        sha256_process(&md, (unsigned char*)tests[i].msg, (unsigned long)XSTRLEN(tests[i].msg));
233        sha256_done(&md, tmp);
234        if (compare_testvector(tmp, sizeof(tmp), tests[i].hash, sizeof(tests[i].hash), "SHA256", i)) {
235           return CRYPT_FAIL_TESTVECTOR;
236        }
237    }
238    return CRYPT_OK;
239   #endif
240  }
241  #endif
</code></pre>
        </div>
        <div class="column">
            <h3>libfuse-MDEwOlJlcG9zaXRvcnk0ODI5NjE3Nw==-flat-iconv.c</h3>
            <pre><code>1  #include <fuse_config.h>
2  #include <fuse.h>
3  #include <stdio.h>
4  #include <stdlib.h>
5  #include <stddef.h>
6  #include <string.h>
7  #include <errno.h>
8  #include <iconv.h>
9  #include <pthread.h>
10  #include <locale.h>
11  #include <langinfo.h>
12  struct iconv {
13  	struct fuse_fs *next;
14  	pthread_mutex_t lock;
15  	char *from_code;
16  	char *to_code;
17  	iconv_t tofs;
18  	iconv_t fromfs;
19  };
20  struct iconv_dh {
21  	struct iconv *ic;
22  	void *prev_buf;
23  	fuse_fill_dir_t prev_filler;
24  };
25  static struct iconv *iconv_get(void)
26  {
27  	return fuse_get_context()->private_data;
28  }
29  static int iconv_convpath(struct iconv *ic, const char *path, char **newpathp,
30  			  int fromfs)
31  {
32  	size_t pathlen;
33  	size_t newpathlen;
34  	char *newpath;
35  	size_t plen;
36  	char *p;
37  	size_t res;
38  	int err;
39  	if (path == NULL) {
40  		*newpathp = NULL;
41  		return 0;
42  	}
43  	pathlen = strlen(path);
44  	newpathlen = pathlen * 4;
45  	newpath = malloc(newpathlen + 1);
46  	if (!newpath)
47  		return -ENOMEM;
48  	plen = newpathlen;
49  	p = newpath;
50  	pthread_mutex_lock(&ic->lock);
51  	do {
52  		res = iconv(fromfs ? ic->fromfs : ic->tofs, (char **) &path,
53  			    &pathlen, &p, &plen);
54  		if (res == (size_t) -1) {
55  			char *tmp;
56  			size_t inc;
57  			err = -EILSEQ;
58  			if (errno != E2BIG)
59  				goto err;
60  			inc = (pathlen + 1) * 4;
61  			newpathlen += inc;
62  			int dp = p - newpath;
63  			tmp = realloc(newpath, newpathlen + 1);
64  			err = -ENOMEM;
65  			if (!tmp)
66  				goto err;
67  			p = tmp + dp;
68  			plen += inc;
69  			newpath = tmp;
70  		}
71  	} while (res == (size_t) -1);
72  	pthread_mutex_unlock(&ic->lock);
73  	*p = '\0';
74  	*newpathp = newpath;
75  	return 0;
76  err:
77  	iconv(fromfs ? ic->fromfs : ic->tofs, NULL, NULL, NULL, NULL);
78  	pthread_mutex_unlock(&ic->lock);
79  	free(newpath);
80  	return err;
81  }
82  static int iconv_getattr(const char *path, struct stat *stbuf,
83  			 struct fuse_file_info *fi)
84  {
85  	struct iconv *ic = iconv_get();
86  	char *newpath;
87  	int err = iconv_convpath(ic, path, &newpath, 0);
88  	if (!err) {
89  		err = fuse_fs_getattr(ic->next, newpath, stbuf, fi);
90  		free(newpath);
91  	}
92  	return err;
93  }
94  static int iconv_access(const char *path, int mask)
95  {
96  	struct iconv *ic = iconv_get();
97  	char *newpath;
98  	int err = iconv_convpath(ic, path, &newpath, 0);
99  	if (!err) {
100  		err = fuse_fs_access(ic->next, newpath, mask);
101  		free(newpath);
102  	}
103  	return err;
104  }
105  static int iconv_readlink(const char *path, char *buf, size_t size)
106  {
107  	struct iconv *ic = iconv_get();
108  	char *newpath;
109  	int err = iconv_convpath(ic, path, &newpath, 0);
110  	if (!err) {
111  		err = fuse_fs_readlink(ic->next, newpath, buf, size);
112  		if (!err) {
113  			char *newlink;
114  			err = iconv_convpath(ic, buf, &newlink, 1);
115  			if (!err) {
116  				strncpy(buf, newlink, size - 1);
117  				buf[size - 1] = '\0';
118  				free(newlink);
119  			}
120  		}
121  		free(newpath);
122  	}
123  	return err;
124  }
125  static int iconv_opendir(const char *path, struct fuse_file_info *fi)
126  {
127  	struct iconv *ic = iconv_get();
128  	char *newpath;
129  	int err = iconv_convpath(ic, path, &newpath, 0);
130  	if (!err) {
131  		err = fuse_fs_opendir(ic->next, newpath, fi);
132  		free(newpath);
133  	}
134  	return err;
135  }
136  static int iconv_dir_fill(void *buf, const char *name,
137  			  const struct stat *stbuf, off_t off,
138  			  enum fuse_fill_dir_flags flags)
139  {
140  	struct iconv_dh *dh = buf;
141  	char *newname;
142  	int res = 0;
143  	if (iconv_convpath(dh->ic, name, &newname, 1) == 0) {
144  		res = dh->prev_filler(dh->prev_buf, newname, stbuf, off, flags);
145  		free(newname);
146  	}
147  	return res;
148  }
149  static int iconv_readdir(const char *path, void *buf, fuse_fill_dir_t filler,
150  			 off_t offset, struct fuse_file_info *fi,
151  			 enum fuse_readdir_flags flags)
152  {
153  	struct iconv *ic = iconv_get();
154  	char *newpath;
155  	int err = iconv_convpath(ic, path, &newpath, 0);
156  	if (!err) {
157  		struct iconv_dh dh;
158  		dh.ic = ic;
159  		dh.prev_buf = buf;
160  		dh.prev_filler = filler;
161  		err = fuse_fs_readdir(ic->next, newpath, &dh, iconv_dir_fill,
162  				      offset, fi, flags);
163  		free(newpath);
164  	}
165  	return err;
166  }
167  static int iconv_releasedir(const char *path, struct fuse_file_info *fi)
168  {
169  	struct iconv *ic = iconv_get();
170  	char *newpath;
171  	int err = iconv_convpath(ic, path, &newpath, 0);
172  	if (!err) {
173  		err = fuse_fs_releasedir(ic->next, newpath, fi);
174  		free(newpath);
175  	}
176  	return err;
177  }
178  static int iconv_mknod(const char *path, mode_t mode, dev_t rdev)
179  {
180  	struct iconv *ic = iconv_get();
181  	char *newpath;
182  	int err = iconv_convpath(ic, path, &newpath, 0);
183  	if (!err) {
184  		err = fuse_fs_mknod(ic->next, newpath, mode, rdev);
185  		free(newpath);
186  	}
187  	return err;
188  }
189  static int iconv_mkdir(const char *path, mode_t mode)
190  {
191  	struct iconv *ic = iconv_get();
192  	char *newpath;
193  	int err = iconv_convpath(ic, path, &newpath, 0);
194  	if (!err) {
195  		err = fuse_fs_mkdir(ic->next, newpath, mode);
196  		free(newpath);
197  	}
198  	return err;
199  }
200  static int iconv_unlink(const char *path)
201  {
202  	struct iconv *ic = iconv_get();
203  	char *newpath;
204  	int err = iconv_convpath(ic, path, &newpath, 0);
205  	if (!err) {
206  		err = fuse_fs_unlink(ic->next, newpath);
207  		free(newpath);
208  	}
209  	return err;
210  }
211  static int iconv_rmdir(const char *path)
212  {
213  	struct iconv *ic = iconv_get();
214  	char *newpath;
215  	int err = iconv_convpath(ic, path, &newpath, 0);
216  	if (!err) {
217  		err = fuse_fs_rmdir(ic->next, newpath);
218  		free(newpath);
219  	}
220  	return err;
221  }
222  static int iconv_symlink(const char *from, const char *to)
223  {
224  	struct iconv *ic = iconv_get();
225  	char *newfrom;
226  	char *newto;
227  	int err = iconv_convpath(ic, from, &newfrom, 0);
228  	if (!err) {
229  		err = iconv_convpath(ic, to, &newto, 0);
230  		if (!err) {
231  			err = fuse_fs_symlink(ic->next, newfrom, newto);
232  			free(newto);
233  		}
234  		free(newfrom);
235  	}
236  	return err;
237  }
238  static int iconv_rename(const char *from, const char *to, unsigned int flags)
239  {
240  	struct iconv *ic = iconv_get();
241  	char *newfrom;
242  	char *newto;
243  	int err = iconv_convpath(ic, from, &newfrom, 0);
244  	if (!err) {
245  		err = iconv_convpath(ic, to, &newto, 0);
246  		if (!err) {
247  			err = fuse_fs_rename(ic->next, newfrom, newto, flags);
248  			free(newto);
249  		}
250  		free(newfrom);
251  	}
252  	return err;
253  }
254  static int iconv_link(const char *from, const char *to)
255  {
256  	struct iconv *ic = iconv_get();
257  	char *newfrom;
258  	char *newto;
259  	int err = iconv_convpath(ic, from, &newfrom, 0);
260  	if (!err) {
261  		err = iconv_convpath(ic, to, &newto, 0);
262  		if (!err) {
263  			err = fuse_fs_link(ic->next, newfrom, newto);
264  			free(newto);
265  		}
266  		free(newfrom);
267  	}
268  	return err;
269  }
270  static int iconv_chmod(const char *path, mode_t mode,
271  		       struct fuse_file_info *fi)
272  {
273  	struct iconv *ic = iconv_get();
274  	char *newpath;
275  	int err = iconv_convpath(ic, path, &newpath, 0);
276  	if (!err) {
277  		err = fuse_fs_chmod(ic->next, newpath, mode, fi);
278  		free(newpath);
279  	}
280  	return err;
281  }
282  static int iconv_chown(const char *path, uid_t uid, gid_t gid,
283  		       struct fuse_file_info *fi)
284  {
285  	struct iconv *ic = iconv_get();
286  	char *newpath;
287  	int err = iconv_convpath(ic, path, &newpath, 0);
288  	if (!err) {
289  		err = fuse_fs_chown(ic->next, newpath, uid, gid, fi);
290  		free(newpath);
291  	}
292  	return err;
293  }
294  static int iconv_truncate(const char *path, off_t size,
295  			   struct fuse_file_info *fi)
296  {
297  	struct iconv *ic = iconv_get();
298  	char *newpath;
299  	int err = iconv_convpath(ic, path, &newpath, 0);
300  	if (!err) {
301  		err = fuse_fs_truncate(ic->next, newpath, size, fi);
302  		free(newpath);
303  	}
304  	return err;
305  }
306  static int iconv_utimens(const char *path, const struct timespec ts[2],
307  			 struct fuse_file_info *fi)
308  {
309  	struct iconv *ic = iconv_get();
310  	char *newpath;
311  	int err = iconv_convpath(ic, path, &newpath, 0);
312  	if (!err) {
313  		err = fuse_fs_utimens(ic->next, newpath, ts, fi);
314  		free(newpath);
315  	}
316  	return err;
317  }
318  static int iconv_create(const char *path, mode_t mode,
319  			struct fuse_file_info *fi)
320  {
321  	struct iconv *ic = iconv_get();
322  	char *newpath;
323  	int err = iconv_convpath(ic, path, &newpath, 0);
324  	if (!err) {
325  		err = fuse_fs_create(ic->next, newpath, mode, fi);
326  		free(newpath);
327  	}
328  	return err;
329  }
330  static int iconv_open_file(const char *path, struct fuse_file_info *fi)
331  {
332  	struct iconv *ic = iconv_get();
333  	char *newpath;
334  	int err = iconv_convpath(ic, path, &newpath, 0);
335  	if (!err) {
336  		err = fuse_fs_open(ic->next, newpath, fi);
337  		free(newpath);
338  	}
339  	return err;
340  }
341  static int iconv_read_buf(const char *path, struct fuse_bufvec **bufp,
342  			  size_t size, off_t offset, struct fuse_file_info *fi)
343  {
344  	struct iconv *ic = iconv_get();
345  	char *newpath;
346  	int err = iconv_convpath(ic, path, &newpath, 0);
347  	if (!err) {
348  		err = fuse_fs_read_buf(ic->next, newpath, bufp, size, offset, fi);
349  		free(newpath);
350  	}
351  	return err;
352  }
353  static int iconv_write_buf(const char *path, struct fuse_bufvec *buf,
354  			   off_t offset, struct fuse_file_info *fi)
355  {
356  	struct iconv *ic = iconv_get();
357  	char *newpath;
358  	int err = iconv_convpath(ic, path, &newpath, 0);
359  	if (!err) {
360  		err = fuse_fs_write_buf(ic->next, newpath, buf, offset, fi);
361  		free(newpath);
362  	}
363  	return err;
364  }
365  static int iconv_statfs(const char *path, struct statvfs *stbuf)
366  {
367  	struct iconv *ic = iconv_get();
368  	char *newpath;
369  	int err = iconv_convpath(ic, path, &newpath, 0);
370  	if (!err) {
371  		err = fuse_fs_statfs(ic->next, newpath, stbuf);
372  		free(newpath);
373  	}
374  	return err;
375  }
376  static int iconv_flush(const char *path, struct fuse_file_info *fi)
377  {
378  	struct iconv *ic = iconv_get();
379  	char *newpath;
380  	int err = iconv_convpath(ic, path, &newpath, 0);
381  	if (!err) {
382  		err = fuse_fs_flush(ic->next, newpath, fi);
383  		free(newpath);
384  	}
385  	return err;
386  }
387  static int iconv_release(const char *path, struct fuse_file_info *fi)
388  {
389  	struct iconv *ic = iconv_get();
390  	char *newpath;
391  	int err = iconv_convpath(ic, path, &newpath, 0);
392  	if (!err) {
393  		err = fuse_fs_release(ic->next, newpath, fi);
394  		free(newpath);
395  	}
396  	return err;
397  }
398  static int iconv_fsync(const char *path, int isdatasync,
399  		       struct fuse_file_info *fi)
400  {
401  	struct iconv *ic = iconv_get();
402  	char *newpath;
403  	int err = iconv_convpath(ic, path, &newpath, 0);
404  	if (!err) {
405  		err = fuse_fs_fsync(ic->next, newpath, isdatasync, fi);
406  		free(newpath);
407  	}
408  	return err;
409  }
410  static int iconv_fsyncdir(const char *path, int isdatasync,
411  			  struct fuse_file_info *fi)
412  {
413  	struct iconv *ic = iconv_get();
414  	char *newpath;
415  	int err = iconv_convpath(ic, path, &newpath, 0);
416  	if (!err) {
417  		err = fuse_fs_fsyncdir(ic->next, newpath, isdatasync, fi);
418  		free(newpath);
419  	}
420  	return err;
421  }
422  static int iconv_setxattr(const char *path, const char *name,
423  			  const char *value, size_t size, int flags)
424  {
425  	struct iconv *ic = iconv_get();
426  	char *newpath;
427  	int err = iconv_convpath(ic, path, &newpath, 0);
428  	if (!err) {
429  		err = fuse_fs_setxattr(ic->next, newpath, name, value, size,
430  				       flags);
431  		free(newpath);
432  	}
433  	return err;
434  }
435  static int iconv_getxattr(const char *path, const char *name, char *value,
436  			  size_t size)
437  {
438  	struct iconv *ic = iconv_get();
439  	char *newpath;
440  	int err = iconv_convpath(ic, path, &newpath, 0);
441  	if (!err) {
442  		err = fuse_fs_getxattr(ic->next, newpath, name, value, size);
443  		free(newpath);
444  	}
445  	return err;
446  }
447  static int iconv_listxattr(const char *path, char *list, size_t size)
448  {
449  	struct iconv *ic = iconv_get();
450  	char *newpath;
451  	int err = iconv_convpath(ic, path, &newpath, 0);
452  	if (!err) {
453  		err = fuse_fs_listxattr(ic->next, newpath, list, size);
454  		free(newpath);
455  	}
456  	return err;
457  }
458  static int iconv_removexattr(const char *path, const char *name)
459  {
460  	struct iconv *ic = iconv_get();
461  	char *newpath;
462  	int err = iconv_convpath(ic, path, &newpath, 0);
463  	if (!err) {
464  		err = fuse_fs_removexattr(ic->next, newpath, name);
465  		free(newpath);
466  	}
467  	return err;
468  }
469  static int iconv_lock(const char *path, struct fuse_file_info *fi, int cmd,
470  		      struct flock *lock)
471  {
472  	struct iconv *ic = iconv_get();
473  	char *newpath;
474  	int err = iconv_convpath(ic, path, &newpath, 0);
475  	if (!err) {
476  		err = fuse_fs_lock(ic->next, newpath, fi, cmd, lock);
477  		free(newpath);
478  	}
479  	return err;
480  }
481  static int iconv_flock(const char *path, struct fuse_file_info *fi, int op)
482  {
483  	struct iconv *ic = iconv_get();
484  	char *newpath;
485  	int err = iconv_convpath(ic, path, &newpath, 0);
486  	if (!err) {
487  		err = fuse_fs_flock(ic->next, newpath, fi, op);
488  		free(newpath);
489  	}
490  	return err;
491  }
492  static int iconv_bmap(const char *path, size_t blocksize, uint64_t *idx)
493  {
494  	struct iconv *ic = iconv_get();
495  	char *newpath;
496  	int err = iconv_convpath(ic, path, &newpath, 0);
497  	if (!err) {
498  		err = fuse_fs_bmap(ic->next, newpath, blocksize, idx);
499  		free(newpath);
500  	}
501  	return err;
502  }
503  static off_t iconv_lseek(const char *path, off_t off, int whence,
504  			 struct fuse_file_info *fi)
505  {
506  	struct iconv *ic = iconv_get();
507  	char *newpath;
508  	int res = iconv_convpath(ic, path, &newpath, 0);
509  	if (!res) {
510  		res = fuse_fs_lseek(ic->next, newpath, off, whence, fi);
511  		free(newpath);
512  	}
513  	return res;
514  }
515  static void *iconv_init(struct fuse_conn_info *conn,
516  			struct fuse_config *cfg)
517  {
518  	struct iconv *ic = iconv_get();
519  	fuse_fs_init(ic->next, conn, cfg);
520  	return ic;
521  }
522  static void iconv_destroy(void *data)
523  {
524  	struct iconv *ic = data;
525  	fuse_fs_destroy(ic->next);
526  	iconv_close(ic->tofs);
527  	iconv_close(ic->fromfs);
528  	pthread_mutex_destroy(&ic->lock);
529  	free(ic->from_code);
530  	free(ic->to_code);
531  	free(ic);
532  }
533  static const struct fuse_operations iconv_oper = {
534  	.destroy	= iconv_destroy,
<span onclick='openModal()' class='match'>535  	.init		= iconv_init,
536  	.getattr	= iconv_getattr,
537  	.access		= iconv_access,
538  	.readlink	= iconv_readlink,
539  	.opendir	= iconv_opendir,
540  	.readdir	= iconv_readdir,
541  	.releasedir	= iconv_releasedir,
542  	.mknod		= iconv_mknod,
543  	.mkdir		= iconv_mkdir,
544  	.symlink	= iconv_symlink,
</span>545  	.unlink		= iconv_unlink,
546  	.rmdir		= iconv_rmdir,
547  	.rename		= iconv_rename,
548  	.link		= iconv_link,
549  	.chmod		= iconv_chmod,
550  	.chown		= iconv_chown,
551  	.truncate	= iconv_truncate,
552  	.utimens	= iconv_utimens,
553  	.create		= iconv_create,
554  	.open		= iconv_open_file,
555  	.read_buf	= iconv_read_buf,
556  	.write_buf	= iconv_write_buf,
557  	.statfs		= iconv_statfs,
558  	.flush		= iconv_flush,
559  	.release	= iconv_release,
560  	.fsync		= iconv_fsync,
561  	.fsyncdir	= iconv_fsyncdir,
562  	.setxattr	= iconv_setxattr,
563  	.getxattr	= iconv_getxattr,
564  	.listxattr	= iconv_listxattr,
565  	.removexattr	= iconv_removexattr,
566  	.lock		= iconv_lock,
567  	.flock		= iconv_flock,
568  	.bmap		= iconv_bmap,
569  	.lseek		= iconv_lseek,
570  };
571  static const struct fuse_opt iconv_opts[] = {
572  	FUSE_OPT_KEY("-h", 0),
573  	FUSE_OPT_KEY("--help", 0),
574  	{ "from_code=%s", offsetof(struct iconv, from_code), 0 },
575  	{ "to_code=%s", offsetof(struct iconv, to_code), 1 },
576  	FUSE_OPT_END
577  };
578  static void iconv_help(void)
579  {
580  	char *charmap;
581  	const char *old = setlocale(LC_CTYPE, "");
582  	charmap = strdup(nl_langinfo(CODESET));
583  	if (old)
584  		setlocale(LC_CTYPE, old);
585  	else
586  		perror("setlocale");
587  	printf(
588  "    -o from_code=CHARSET   original encoding of file names (default: UTF-8)\n"
589  "    -o to_code=CHARSET     new encoding of the file names (default: %s)\n",
590  		charmap);
591  	free(charmap);
592  }
593  static int iconv_opt_proc(void *data, const char *arg, int key,
594  			  struct fuse_args *outargs)
595  {
596  	(void) data; (void) arg; (void) outargs;
597  	if (!key) {
598  		iconv_help();
599  		return -1;
600  	}
601  	return 1;
602  }
603  static struct fuse_fs *iconv_new(struct fuse_args *args,
604  				 struct fuse_fs *next[])
605  {
606  	struct fuse_fs *fs;
607  	struct iconv *ic;
608  	const char *old = NULL;
609  	const char *from;
610  	const char *to;
611  	ic = calloc(1, sizeof(struct iconv));
612  	if (ic == NULL) {
613  		fuse_log(FUSE_LOG_ERR, "fuse-iconv: memory allocation failed\n");
614  		return NULL;
615  	}
616  	if (fuse_opt_parse(args, ic, iconv_opts, iconv_opt_proc) == -1)
617  		goto out_free;
618  	if (!next[0] || next[1]) {
619  		fuse_log(FUSE_LOG_ERR, "fuse-iconv: exactly one next filesystem required\n");
620  		goto out_free;
621  	}
622  	from = ic->from_code ? ic->from_code : "UTF-8";
623  	to = ic->to_code ? ic->to_code : "";
624  	if (!to[0])
625  		old = setlocale(LC_CTYPE, "");
626  	ic->tofs = iconv_open(from, to);
627  	if (ic->tofs == (iconv_t) -1) {
628  		fuse_log(FUSE_LOG_ERR, "fuse-iconv: cannot convert from %s to %s\n",
629  			to, from);
630  		goto out_free;
631  	}
632  	ic->fromfs = iconv_open(to, from);
633  	if (ic->tofs == (iconv_t) -1) {
634  		fuse_log(FUSE_LOG_ERR, "fuse-iconv: cannot convert from %s to %s\n",
635  			from, to);
636  		goto out_iconv_close_to;
637  	}
638  	if (old) {
639  		setlocale(LC_CTYPE, old);
640  		old = NULL;
641  	}
642  	ic->next = next[0];
643  	fs = fuse_fs_new(&iconv_oper, sizeof(iconv_oper), ic);
644  	if (!fs)
645  		goto out_iconv_close_from;
646  	return fs;
647  out_iconv_close_from:
648  	iconv_close(ic->fromfs);
649  out_iconv_close_to:
650  	iconv_close(ic->tofs);
651  out_free:
652  	free(ic->from_code);
653  	free(ic->to_code);
654  	free(ic);
655  	if (old) {
656  		setlocale(LC_CTYPE, old);
657  	}
658  	return NULL;
659  }
660  FUSE_REGISTER_MODULE(iconv, iconv_new);
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from libtomcrypt-MDEwOlJlcG9zaXRvcnk3NzcwMTE=-flat-sha256.c</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from libfuse-MDEwOlJlcG9zaXRvcnk0ODI5NjE3Nw==-flat-iconv.c</div>
                </div>
                <div class="column column_space"><pre><code>162      md->sha256.curlen = 0;
163      md->sha256.length = 0;
164      md->sha256.state[0] = 0x6A09E667UL;
165      md->sha256.state[1] = 0xBB67AE85UL;
166      md->sha256.state[2] = 0x3C6EF372UL;
167      md->sha256.state[3] = 0xA54FF53AUL;
168      md->sha256.state[4] = 0x510E527FUL;
169      md->sha256.state[5] = 0x9B05688CUL;
170      md->sha256.state[6] = 0x1F83D9ABUL;
171      md->sha256.state[7] = 0x5BE0CD19UL;
</pre></code></div>
                <div class="column column_space"><pre><code>535  	.init		= iconv_init,
536  	.getattr	= iconv_getattr,
537  	.access		= iconv_access,
538  	.readlink	= iconv_readlink,
539  	.opendir	= iconv_opendir,
540  	.readdir	= iconv_readdir,
541  	.releasedir	= iconv_releasedir,
542  	.mknod		= iconv_mknod,
543  	.mkdir		= iconv_mkdir,
544  	.symlink	= iconv_symlink,
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    