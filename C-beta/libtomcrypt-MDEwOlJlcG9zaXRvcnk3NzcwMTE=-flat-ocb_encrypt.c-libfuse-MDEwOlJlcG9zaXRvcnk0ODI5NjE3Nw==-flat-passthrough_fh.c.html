
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 2.5806451612903225%, Tokens: 8, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>libtomcrypt-MDEwOlJlcG9zaXRvcnk3NzcwMTE=-flat-ocb_encrypt.c</h3>
            <pre><code>1  #include "tomcrypt_private.h"
2  #ifdef LTC_OCB_MODE
<span onclick='openModal()' class='match'>3  int ocb_encrypt(ocb_state *ocb, const unsigned char *pt, unsigned char *ct)
4  {
5     unsigned char Z[MAXBLOCKSIZE], tmp[MAXBLOCKSIZE];
6     int err, x;
7     LTC_ARGCHK(ocb != NULL);
8     LTC_ARGCHK(pt  != NULL);
9     LTC_ARGCHK(ct  != NULL);
10     if ((err = cipher_is_valid(ocb->cipher)) != CRYPT_OK) {
</span>11        return err;
12     }
13     if (ocb->block_len != cipher_descriptor[ocb->cipher].block_length) {
14        return CRYPT_INVALID_ARG;
15     }
16     for (x = 0; x < ocb->block_len; x++) {
17         ocb->checksum[x] ^= pt[x];
18     }
19     ocb_shift_xor(ocb, Z);
20     for (x = 0; x < ocb->block_len; x++) {
21         tmp[x] = pt[x] ^ Z[x];
22     }
23     if ((err = cipher_descriptor[ocb->cipher].ecb_encrypt(tmp, ct, &ocb->key)) != CRYPT_OK) {
24        return err;
25     }
26     for (x = 0; x < ocb->block_len; x++) {
27         ct[x] ^= Z[x];
28     }
29  #ifdef LTC_CLEAN_STACK
30     zeromem(Z, sizeof(Z));
31     zeromem(tmp, sizeof(tmp));
32  #endif
33     return CRYPT_OK;
34  }
35  #endif
</code></pre>
        </div>
        <div class="column">
            <h3>libfuse-MDEwOlJlcG9zaXRvcnk0ODI5NjE3Nw==-flat-passthrough_fh.c</h3>
            <pre><code>1  #define FUSE_USE_VERSION 31
2  #define _GNU_SOURCE
3  #include <fuse.h>
4  #ifdef HAVE_LIBULOCKMGR
5  #include <ulockmgr.h>
6  #endif
7  #include <stdio.h>
8  #include <stdlib.h>
9  #include <string.h>
10  #include <unistd.h>
11  #include <fcntl.h>
12  #include <sys/stat.h>
13  #include <dirent.h>
14  #include <errno.h>
15  #include <sys/time.h>
16  #ifdef HAVE_SETXATTR
17  #include <sys/xattr.h>
18  #endif
19  #include <sys/file.h> &bsol;* flock(2) */
20  static void *xmp_init(struct fuse_conn_info *conn,
21  		      struct fuse_config *cfg)
22  {
23  	(void) conn;
24  	cfg->use_ino = 1;
25  	cfg->nullpath_ok = 1;
26  	cfg->entry_timeout = 0;
27  	cfg->attr_timeout = 0;
28  	cfg->negative_timeout = 0;
29  	return NULL;
30  }
31  static int xmp_getattr(const char *path, struct stat *stbuf,
32  			struct fuse_file_info *fi)
33  {
34  	int res;
35  	(void) path;
36  	if(fi)
37  		res = fstat(fi->fh, stbuf);
38  	else
39  		res = lstat(path, stbuf);
40  	if (res == -1)
41  		return -errno;
42  	return 0;
43  }
44  static int xmp_access(const char *path, int mask)
45  {
46  	int res;
47  	res = access(path, mask);
48  	if (res == -1)
49  		return -errno;
50  	return 0;
51  }
52  static int xmp_readlink(const char *path, char *buf, size_t size)
53  {
54  	int res;
55  	res = readlink(path, buf, size - 1);
56  	if (res == -1)
57  		return -errno;
58  	buf[res] = '\0';
59  	return 0;
60  }
61  struct xmp_dirp {
62  	DIR *dp;
63  	struct dirent *entry;
64  	off_t offset;
65  };
66  static int xmp_opendir(const char *path, struct fuse_file_info *fi)
67  {
68  	int res;
69  	struct xmp_dirp *d = malloc(sizeof(struct xmp_dirp));
70  	if (d == NULL)
71  		return -ENOMEM;
72  	d->dp = opendir(path);
73  	if (d->dp == NULL) {
74  		res = -errno;
75  		free(d);
76  		return res;
77  	}
78  	d->offset = 0;
79  	d->entry = NULL;
80  	fi->fh = (unsigned long) d;
81  	return 0;
82  }
83  static inline struct xmp_dirp *get_dirp(struct fuse_file_info *fi)
84  {
85  	return (struct xmp_dirp *) (uintptr_t) fi->fh;
86  }
87  static int xmp_readdir(const char *path, void *buf, fuse_fill_dir_t filler,
88  		       off_t offset, struct fuse_file_info *fi,
89  		       enum fuse_readdir_flags flags)
90  {
91  	struct xmp_dirp *d = get_dirp(fi);
92  	(void) path;
93  	if (offset != d->offset) {
94  #ifndef __FreeBSD__
95  		seekdir(d->dp, offset);
96  #else
97  		seekdir(d->dp, offset-1);
98  #endif
99  		d->entry = NULL;
100  		d->offset = offset;
101  	}
102  	while (1) {
103  		struct stat st;
104  		off_t nextoff;
105  		enum fuse_fill_dir_flags fill_flags = 0;
106  		if (!d->entry) {
107  			d->entry = readdir(d->dp);
108  			if (!d->entry)
109  				break;
110  		}
111  #ifdef HAVE_FSTATAT
112  		if (flags & FUSE_READDIR_PLUS) {
113  			int res;
114  			res = fstatat(dirfd(d->dp), d->entry->d_name, &st,
115  				      AT_SYMLINK_NOFOLLOW);
116  			if (res != -1)
117  				fill_flags |= FUSE_FILL_DIR_PLUS;
118  		}
119  #endif
120  		if (!(fill_flags & FUSE_FILL_DIR_PLUS)) {
121  			memset(&st, 0, sizeof(st));
122  			st.st_ino = d->entry->d_ino;
123  			st.st_mode = d->entry->d_type << 12;
124  		}
125  		nextoff = telldir(d->dp);
126  #ifdef __FreeBSD__		
127  		nextoff++;
128  #endif
129  		if (filler(buf, d->entry->d_name, &st, nextoff, fill_flags))
130  			break;
131  		d->entry = NULL;
132  		d->offset = nextoff;
133  	}
134  	return 0;
135  }
136  static int xmp_releasedir(const char *path, struct fuse_file_info *fi)
137  {
138  	struct xmp_dirp *d = get_dirp(fi);
139  	(void) path;
140  	closedir(d->dp);
141  	free(d);
142  	return 0;
143  }
144  static int xmp_mknod(const char *path, mode_t mode, dev_t rdev)
145  {
146  	int res;
147  	if (S_ISFIFO(mode))
148  		res = mkfifo(path, mode);
149  	else
150  		res = mknod(path, mode, rdev);
151  	if (res == -1)
152  		return -errno;
153  	return 0;
154  }
155  static int xmp_mkdir(const char *path, mode_t mode)
156  {
157  	int res;
158  	res = mkdir(path, mode);
159  	if (res == -1)
160  		return -errno;
161  	return 0;
162  }
163  static int xmp_unlink(const char *path)
164  {
165  	int res;
166  	res = unlink(path);
167  	if (res == -1)
168  		return -errno;
169  	return 0;
170  }
171  static int xmp_rmdir(const char *path)
172  {
173  	int res;
174  	res = rmdir(path);
175  	if (res == -1)
176  		return -errno;
177  	return 0;
178  }
179  static int xmp_symlink(const char *from, const char *to)
180  {
181  	int res;
182  	res = symlink(from, to);
183  	if (res == -1)
184  		return -errno;
185  	return 0;
186  }
187  static int xmp_rename(const char *from, const char *to, unsigned int flags)
188  {
189  	int res;
190  	if (flags)
191  		return -EINVAL;
192  	res = rename(from, to);
193  	if (res == -1)
194  		return -errno;
195  	return 0;
196  }
197  static int xmp_link(const char *from, const char *to)
198  {
199  	int res;
200  	res = link(from, to);
201  	if (res == -1)
202  		return -errno;
203  	return 0;
204  }
205  static int xmp_chmod(const char *path, mode_t mode,
206  		     struct fuse_file_info *fi)
207  {
208  	int res;
209  	if(fi)
210  		res = fchmod(fi->fh, mode);
211  	else
212  		res = chmod(path, mode);
213  	if (res == -1)
214  		return -errno;
215  	return 0;
216  }
<span onclick='openModal()' class='match'>217  static int xmp_chown(const char *path, uid_t uid, gid_t gid,
218  		     struct fuse_file_info *fi)
219  {
220  	int res;
221  	if (fi)
222  		res = fchown(fi->fh, uid, gid);
</span>223  	else
224  		res = lchown(path, uid, gid);
225  	if (res == -1)
226  		return -errno;
227  	return 0;
228  }
229  static int xmp_truncate(const char *path, off_t size,
230  			 struct fuse_file_info *fi)
231  {
232  	int res;
233  	if(fi)
234  		res = ftruncate(fi->fh, size);
235  	else
236  		res = truncate(path, size);
237  	if (res == -1)
238  		return -errno;
239  	return 0;
240  }
241  #ifdef HAVE_UTIMENSAT
242  static int xmp_utimens(const char *path, const struct timespec ts[2],
243  		       struct fuse_file_info *fi)
244  {
245  	int res;
246  	if (fi)
247  		res = futimens(fi->fh, ts);
248  	else
249  		res = utimensat(0, path, ts, AT_SYMLINK_NOFOLLOW);
250  	if (res == -1)
251  		return -errno;
252  	return 0;
253  }
254  #endif
255  static int xmp_create(const char *path, mode_t mode, struct fuse_file_info *fi)
256  {
257  	int fd;
258  	fd = open(path, fi->flags, mode);
259  	if (fd == -1)
260  		return -errno;
261  	fi->fh = fd;
262  	return 0;
263  }
264  static int xmp_open(const char *path, struct fuse_file_info *fi)
265  {
266  	int fd;
267  	fd = open(path, fi->flags);
268  	if (fd == -1)
269  		return -errno;
270  	fi->fh = fd;
271  	return 0;
272  }
273  static int xmp_read(const char *path, char *buf, size_t size, off_t offset,
274  		    struct fuse_file_info *fi)
275  {
276  	int res;
277  	(void) path;
278  	res = pread(fi->fh, buf, size, offset);
279  	if (res == -1)
280  		res = -errno;
281  	return res;
282  }
283  static int xmp_read_buf(const char *path, struct fuse_bufvec **bufp,
284  			size_t size, off_t offset, struct fuse_file_info *fi)
285  {
286  	struct fuse_bufvec *src;
287  	(void) path;
288  	src = malloc(sizeof(struct fuse_bufvec));
289  	if (src == NULL)
290  		return -ENOMEM;
291  	*src = FUSE_BUFVEC_INIT(size);
292  	src->buf[0].flags = FUSE_BUF_IS_FD | FUSE_BUF_FD_SEEK;
293  	src->buf[0].fd = fi->fh;
294  	src->buf[0].pos = offset;
295  	*bufp = src;
296  	return 0;
297  }
298  static int xmp_write(const char *path, const char *buf, size_t size,
299  		     off_t offset, struct fuse_file_info *fi)
300  {
301  	int res;
302  	(void) path;
303  	res = pwrite(fi->fh, buf, size, offset);
304  	if (res == -1)
305  		res = -errno;
306  	return res;
307  }
308  static int xmp_write_buf(const char *path, struct fuse_bufvec *buf,
309  		     off_t offset, struct fuse_file_info *fi)
310  {
311  	struct fuse_bufvec dst = FUSE_BUFVEC_INIT(fuse_buf_size(buf));
312  	(void) path;
313  	dst.buf[0].flags = FUSE_BUF_IS_FD | FUSE_BUF_FD_SEEK;
314  	dst.buf[0].fd = fi->fh;
315  	dst.buf[0].pos = offset;
316  	return fuse_buf_copy(&dst, buf, FUSE_BUF_SPLICE_NONBLOCK);
317  }
318  static int xmp_statfs(const char *path, struct statvfs *stbuf)
319  {
320  	int res;
321  	res = statvfs(path, stbuf);
322  	if (res == -1)
323  		return -errno;
324  	return 0;
325  }
326  static int xmp_flush(const char *path, struct fuse_file_info *fi)
327  {
328  	int res;
329  	(void) path;
330  	res = close(dup(fi->fh));
331  	if (res == -1)
332  		return -errno;
333  	return 0;
334  }
335  static int xmp_release(const char *path, struct fuse_file_info *fi)
336  {
337  	(void) path;
338  	close(fi->fh);
339  	return 0;
340  }
341  static int xmp_fsync(const char *path, int isdatasync,
342  		     struct fuse_file_info *fi)
343  {
344  	int res;
345  	(void) path;
346  #ifndef HAVE_FDATASYNC
347  	(void) isdatasync;
348  #else
349  	if (isdatasync)
350  		res = fdatasync(fi->fh);
351  	else
352  #endif
353  		res = fsync(fi->fh);
354  	if (res == -1)
355  		return -errno;
356  	return 0;
357  }
358  #ifdef HAVE_POSIX_FALLOCATE
359  static int xmp_fallocate(const char *path, int mode,
360  			off_t offset, off_t length, struct fuse_file_info *fi)
361  {
362  	(void) path;
363  	if (mode)
364  		return -EOPNOTSUPP;
365  	return -posix_fallocate(fi->fh, offset, length);
366  }
367  #endif
368  #ifdef HAVE_SETXATTR
369  static int xmp_setxattr(const char *path, const char *name, const char *value,
370  			size_t size, int flags)
371  {
372  	int res = lsetxattr(path, name, value, size, flags);
373  	if (res == -1)
374  		return -errno;
375  	return 0;
376  }
377  static int xmp_getxattr(const char *path, const char *name, char *value,
378  			size_t size)
379  {
380  	int res = lgetxattr(path, name, value, size);
381  	if (res == -1)
382  		return -errno;
383  	return res;
384  }
385  static int xmp_listxattr(const char *path, char *list, size_t size)
386  {
387  	int res = llistxattr(path, list, size);
388  	if (res == -1)
389  		return -errno;
390  	return res;
391  }
392  static int xmp_removexattr(const char *path, const char *name)
393  {
394  	int res = lremovexattr(path, name);
395  	if (res == -1)
396  		return -errno;
397  	return 0;
398  }
399  #endif &bsol;* HAVE_SETXATTR */
400  #ifdef HAVE_LIBULOCKMGR
401  static int xmp_lock(const char *path, struct fuse_file_info *fi, int cmd,
402  		    struct flock *lock)
403  {
404  	(void) path;
405  	return ulockmgr_op(fi->fh, cmd, lock, &fi->lock_owner,
406  			   sizeof(fi->lock_owner));
407  }
408  #endif
409  static int xmp_flock(const char *path, struct fuse_file_info *fi, int op)
410  {
411  	int res;
412  	(void) path;
413  	res = flock(fi->fh, op);
414  	if (res == -1)
415  		return -errno;
416  	return 0;
417  }
418  #ifdef HAVE_COPY_FILE_RANGE
419  static ssize_t xmp_copy_file_range(const char *path_in,
420  				   struct fuse_file_info *fi_in,
421  				   off_t off_in, const char *path_out,
422  				   struct fuse_file_info *fi_out,
423  				   off_t off_out, size_t len, int flags)
424  {
425  	ssize_t res;
426  	(void) path_in;
427  	(void) path_out;
428  	res = copy_file_range(fi_in->fh, &off_in, fi_out->fh, &off_out, len,
429  			      flags);
430  	if (res == -1)
431  		return -errno;
432  	return res;
433  }
434  #endif
435  static off_t xmp_lseek(const char *path, off_t off, int whence, struct fuse_file_info *fi)
436  {
437  	off_t res;
438  	(void) path;
439  	res = lseek(fi->fh, off, whence);
440  	if (res == -1)
441  		return -errno;
442  	return res;
443  }
444  static const struct fuse_operations xmp_oper = {
445  	.init           = xmp_init,
446  	.getattr	= xmp_getattr,
447  	.access		= xmp_access,
448  	.readlink	= xmp_readlink,
449  	.opendir	= xmp_opendir,
450  	.readdir	= xmp_readdir,
451  	.releasedir	= xmp_releasedir,
452  	.mknod		= xmp_mknod,
453  	.mkdir		= xmp_mkdir,
454  	.symlink	= xmp_symlink,
455  	.unlink		= xmp_unlink,
456  	.rmdir		= xmp_rmdir,
457  	.rename		= xmp_rename,
458  	.link		= xmp_link,
459  	.chmod		= xmp_chmod,
460  	.chown		= xmp_chown,
461  	.truncate	= xmp_truncate,
462  #ifdef HAVE_UTIMENSAT
463  	.utimens	= xmp_utimens,
464  #endif
465  	.create		= xmp_create,
466  	.open		= xmp_open,
467  	.read		= xmp_read,
468  	.read_buf	= xmp_read_buf,
469  	.write		= xmp_write,
470  	.write_buf	= xmp_write_buf,
471  	.statfs		= xmp_statfs,
472  	.flush		= xmp_flush,
473  	.release	= xmp_release,
474  	.fsync		= xmp_fsync,
475  #ifdef HAVE_POSIX_FALLOCATE
476  	.fallocate	= xmp_fallocate,
477  #endif
478  #ifdef HAVE_SETXATTR
479  	.setxattr	= xmp_setxattr,
480  	.getxattr	= xmp_getxattr,
481  	.listxattr	= xmp_listxattr,
482  	.removexattr	= xmp_removexattr,
483  #endif
484  #ifdef HAVE_LIBULOCKMGR
485  	.lock		= xmp_lock,
486  #endif
487  	.flock		= xmp_flock,
488  #ifdef HAVE_COPY_FILE_RANGE
489  	.copy_file_range = xmp_copy_file_range,
490  #endif
491  	.lseek		= xmp_lseek,
492  };
493  int main(int argc, char *argv[])
494  {
495  	umask(0);
496  	return fuse_main(argc, argv, &xmp_oper, NULL);
497  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from libtomcrypt-MDEwOlJlcG9zaXRvcnk3NzcwMTE=-flat-ocb_encrypt.c</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from libfuse-MDEwOlJlcG9zaXRvcnk0ODI5NjE3Nw==-flat-passthrough_fh.c</div>
                </div>
                <div class="column column_space"><pre><code>3  int ocb_encrypt(ocb_state *ocb, const unsigned char *pt, unsigned char *ct)
4  {
5     unsigned char Z[MAXBLOCKSIZE], tmp[MAXBLOCKSIZE];
6     int err, x;
7     LTC_ARGCHK(ocb != NULL);
8     LTC_ARGCHK(pt  != NULL);
9     LTC_ARGCHK(ct  != NULL);
10     if ((err = cipher_is_valid(ocb->cipher)) != CRYPT_OK) {
</pre></code></div>
                <div class="column column_space"><pre><code>217  static int xmp_chown(const char *path, uid_t uid, gid_t gid,
218  		     struct fuse_file_info *fi)
219  {
220  	int res;
221  	if (fi)
222  		res = fchown(fi->fh, uid, gid);
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    