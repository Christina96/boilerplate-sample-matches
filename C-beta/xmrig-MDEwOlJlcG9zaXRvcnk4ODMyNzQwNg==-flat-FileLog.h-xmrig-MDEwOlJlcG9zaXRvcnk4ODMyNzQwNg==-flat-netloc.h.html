
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 9.937888198757763%, Tokens: 16, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>xmrig-MDEwOlJlcG9zaXRvcnk4ODMyNzQwNg==-flat-FileLog.h</h3>
            <pre><code>1  #ifndef XMRIG_FILELOG_H
2  #define XMRIG_FILELOG_H
3  #include "base/io/log/FileLogWriter.h"
4  #include "base/kernel/interfaces/ILogBackend.h"
5  namespace xmrig {
6  class FileLog : public ILogBackend
7  {
8  public:
<span onclick='openModal()' class='match'>9      FileLog(const char *fileName);
10  protected:
11      void print(uint64_t timestamp, int level, const char *line, size_t offset, size_t size, bool colors) override;
12  private:
13      FileLogWriter m_writer;
</span>14  };
15  } &bsol;* namespace xmrig */
16  #endif &bsol;* XMRIG_FILELOG_H */
</code></pre>
        </div>
        <div class="column">
            <h3>xmrig-MDEwOlJlcG9zaXRvcnk4ODMyNzQwNg==-flat-netloc.h</h3>
            <pre><code>1  #ifndef _NETLOC_PRIVATE_H_
2  #define _NETLOC_PRIVATE_H_
3  #include <hwloc.h>
4  #include <netloc.h>
5  #include <netloc/uthash.h>
6  #include <netloc/utarray.h>
7  #include <private/autogen/config.h>
8  #define NETLOCFILE_VERSION 1
9  #ifdef NETLOC_SCOTCH
10  #include <stdint.h>
11  #include <scotch.h>
12  #define NETLOC_int SCOTCH_Num
13  #else
14  #define NETLOC_int int
15  #endif
16  #define __netloc_attribute_unused __hwloc_attribute_unused
17  #define __netloc_attribute_malloc __hwloc_attribute_malloc
18  #define __netloc_attribute_const __hwloc_attribute_const
19  #define __netloc_attribute_pure __hwloc_attribute_pure
20  #define __netloc_attribute_deprecated __hwloc_attribute_deprecated
21  #define __netloc_attribute_may_alias __hwloc_attribute_may_alias
22  #define NETLOC_DECLSPEC HWLOC_DECLSPEC
23  typedef enum {
24      NETLOC_CMP_SAME    =  0,  &bsol;**< Compared as the Same */
25      NETLOC_CMP_SIMILAR = -1,  &bsol;**< Compared as Similar, but not the Same */
26      NETLOC_CMP_DIFF    = -2   &bsol;**< Compared as Different */
27  } netloc_compare_type_t;
28  typedef enum {
29      NETLOC_NETWORK_TYPE_ETHERNET    = 1, &bsol;**< Ethernet network */
30      NETLOC_NETWORK_TYPE_INFINIBAND  = 2, &bsol;**< InfiniBand network */
31      NETLOC_NETWORK_TYPE_INVALID     = 3  &bsol;**< Invalid network */
32  } netloc_network_type_t;
33  typedef enum {
34      NETLOC_TOPOLOGY_TYPE_INVALID = -1, &bsol;**< Invalid */
35      NETLOC_TOPOLOGY_TYPE_TREE    = 1,  &bsol;**< Tree */
36  } netloc_topology_type_t;
37  typedef enum {
38      NETLOC_NODE_TYPE_HOST    = 0, &bsol;**< Host (a.k.a., network addressable endpoint - e.g., MAC Address) node */
39      NETLOC_NODE_TYPE_SWITCH  = 1, &bsol;**< Switch node */
40      NETLOC_NODE_TYPE_INVALID = 2  &bsol;**< Invalid node */
41  } netloc_node_type_t;
42  typedef enum {
43      NETLOC_ARCH_TREE    =  0,  &bsol;* Fat tree */
44  } netloc_arch_type_t;
45  struct netloc_topology_t;
46  typedef struct netloc_topology_t netloc_topology_t;
47  struct netloc_node_t;
48  typedef struct netloc_node_t netloc_node_t;
49  struct netloc_edge_t;
50  typedef struct netloc_edge_t netloc_edge_t;
51  struct netloc_physical_link_t;
52  typedef struct netloc_physical_link_t netloc_physical_link_t;
53  struct netloc_path_t;
54  typedef struct netloc_path_t netloc_path_t;
55  struct netloc_arch_tree_t;
56  typedef struct netloc_arch_tree_t netloc_arch_tree_t;
57  struct netloc_arch_node_t;
58  typedef struct netloc_arch_node_t netloc_arch_node_t;
59  struct netloc_arch_node_slot_t;
60  typedef struct netloc_arch_node_slot_t netloc_arch_node_slot_t;
61  struct netloc_arch_t;
62  typedef struct netloc_arch_t netloc_arch_t;
63  struct netloc_topology_t {
<span onclick='openModal()' class='match'>64      char *topopath;
65      char *subnet_id;
66      netloc_node_t *nodes; &bsol;* Hash table of nodes by physical_id */
67      netloc_node_t *nodesByHostname; &bsol;* Hash table of nodes by hostname */
68      netloc_physical_link_t *physical_links; &bsol;* Hash table with physcial links */
</span>69      UT_array *partitions;
70      char *hwlocpath;
71      UT_array *topos;
72      hwloc_topology_t *hwloc_topos;
73      netloc_topology_type_t type;
74  };
75  struct netloc_node_t {
76      UT_hash_handle hh;       &bsol;* makes this structure hashable with physical_id */
77      UT_hash_handle hh2;      &bsol;* makes this structure hashable with hostname */
78      char physical_id[20];
79      int logical_id;
80      netloc_node_type_t type;
81      UT_array *physical_links;
82      char *description;
83      void * userdata;
84      netloc_edge_t *edges;
85      UT_array *subnodes; &bsol;* the group of nodes for the virtual nodes */
86      netloc_path_t *paths;
87      char *hostname;
88      UT_array *partitions; &bsol;* index in the list from the topology */
89      hwloc_topology_t hwlocTopo;
90      int hwlocTopoIdx;
91  };
92  struct netloc_edge_t {
93      UT_hash_handle hh;       &bsol;* makes this structure hashable */
94      netloc_node_t *dest;
95      int id;
96      netloc_node_t *node;
97      UT_array *physical_links;
98      float total_gbits;
99      UT_array *partitions; &bsol;* index in the list from the topology */
100      UT_array *subnode_edges; &bsol;* for edges going to virtual nodes */
101      struct netloc_edge_t *other_way;
102      void * userdata;
103  };
104  struct netloc_physical_link_t {
105      UT_hash_handle hh;       &bsol;* makes this structure hashable */
106      int id; 
107      netloc_node_t *src;
108      netloc_node_t *dest;
109      int ports[2];
110      char *width;
111      char *speed;
112      netloc_edge_t *edge;
113      int other_way_id;
114      struct netloc_physical_link_t *other_way;
115      UT_array *partitions; &bsol;* index in the list from the topology */
116      float gbits;
117      char *description;
118  };
119  struct netloc_path_t {
120      UT_hash_handle hh;       &bsol;* makes this structure hashable */
121      char dest_id[20];
122      UT_array *links;
123  };
124  struct netloc_arch_tree_t {
125      NETLOC_int num_levels;
126      NETLOC_int *degrees;
127      NETLOC_int *cost;
128  };
129  struct netloc_arch_node_t {
130      UT_hash_handle hh;       &bsol;* makes this structure hashable */
131      char *name; &bsol;* Hash key */
132      netloc_node_t *node; &bsol;* Corresponding node */
133      int idx_in_topo; &bsol;* idx with ghost hosts to have complete topo */
134      int num_slots; &bsol;* it is not the real number of slots but the maximum slot idx */
135      int *slot_idx; &bsol;* corresponding idx in slot_tree */
136      int *slot_os_idx; &bsol;* corresponding os index for each leaf in tree */
137      netloc_arch_tree_t *slot_tree; &bsol;* Tree built from hwloc */
138      int num_current_slots; &bsol;* Number of PUs */
139      NETLOC_int *current_slots; &bsol;* indices in the complete tree */
140      int *slot_ranks; &bsol;* corresponding MPI rank for each leaf in tree */
141  };
142  struct netloc_arch_node_slot_t {
143      netloc_arch_node_t *node;
144      int slot;
145  };
146  struct netloc_arch_t {
147      netloc_topology_t *topology;
148      int has_slots; &bsol;* if slots are included in the architecture */
149      netloc_arch_type_t type;
150      union {
151          netloc_arch_tree_t *node_tree;
152          netloc_arch_tree_t *global_tree;
153      } arch;
154      netloc_arch_node_t *nodes_by_name;
155      netloc_arch_node_slot_t *node_slot_by_idx; &bsol;* node_slot by index in complete topo */
156      NETLOC_int num_current_hosts; &bsol;* if has_slots, host is a slot, else host is a node */
157      NETLOC_int *current_hosts; &bsol;* indices in the complete topology */
158  };
159  netloc_topology_t *netloc_topology_construct(char *path);
160  int netloc_topology_destruct(netloc_topology_t *topology);
161  int netloc_topology_find_partition_idx(netloc_topology_t *topology, char *partition_name);
162  int netloc_topology_read_hwloc(netloc_topology_t *topology, int num_nodes,
163          netloc_node_t **node_list);
164  #define netloc_topology_iter_partitions(topology,partition) \
165      for ((partition) = (char **)utarray_front(topology->partitions); \
166              (partition) != NULL; \
167              (partition) = (char **)utarray_next(topology->partitions, partition))
168  #define netloc_topology_iter_hwloctopos(topology,hwloctopo) \
169      for ((hwloctopo) = (char **)utarray_front(topology->topos); \
170              (hwloctopo) != NULL; \
171              (hwloctopo) = (char **)utarray_next(topology->topos, hwloctopo))
172  #define netloc_topology_find_node(topology,node_id,node) \
173      HASH_FIND_STR(topology->nodes, node_id, node)
174  #define netloc_topology_iter_nodes(topology,node,_tmp) \
175      HASH_ITER(hh, topology->nodes, node, _tmp)
176  #define netloc_topology_num_nodes(topology) \
177      HASH_COUNT(topology->nodes)
178  netloc_node_t *netloc_node_construct(void);
179  int netloc_node_destruct(netloc_node_t *node);
180  char *netloc_node_pretty_print(netloc_node_t* node);
181  #define netloc_node_get_num_subnodes(node) \
182      utarray_len((node)->subnodes)
183  #define netloc_node_get_subnode(node,i) \
184      (*(netloc_node_t **)utarray_eltptr((node)->subnodes, (i)))
185  #define netloc_node_get_num_edges(node) \
186      utarray_len((node)->edges)
187  #define netloc_node_get_edge(node,i) \
188      (*(netloc_edge_t **)utarray_eltptr((node)->edges, (i)))
189  #define netloc_node_iter_edges(node,edge,_tmp) \
190      HASH_ITER(hh, node->edges, edge, _tmp)
191  #define netloc_node_iter_paths(node,path,_tmp) \
192      HASH_ITER(hh, node->paths, path, _tmp)
193  #define netloc_node_is_host(node) \
194      (node->type == NETLOC_NODE_TYPE_HOST)
195  #define netloc_node_is_switch(node) \
196      (node->type == NETLOC_NODE_TYPE_SWITCH)
197  #define netloc_node_iter_paths(node, path,_tmp) \
198      HASH_ITER(hh, node->paths, path, _tmp)
199  int netloc_node_is_in_partition(netloc_node_t *node, int partition);
200  netloc_edge_t *netloc_edge_construct(void);
201  int netloc_edge_destruct(netloc_edge_t *edge);
202  char * netloc_edge_pretty_print(netloc_edge_t* edge);
203  void netloc_edge_reset_uid(void);
204  int netloc_edge_is_in_partition(netloc_edge_t *edge, int partition);
205  #define netloc_edge_get_num_links(edge) \
206      utarray_len((edge)->physical_links)
207  #define netloc_edge_get_link(edge,i) \
208      (*(netloc_physical_link_t **)utarray_eltptr((edge)->physical_links, (i)))
209  #define netloc_edge_get_num_subedges(edge) \
210      utarray_len((edge)->subnode_edges)
211  #define netloc_edge_get_subedge(edge,i) \
212      (*(netloc_edge_t **)utarray_eltptr((edge)->subnode_edges, (i)))
213  netloc_physical_link_t * netloc_physical_link_construct(void);
214  int netloc_physical_link_destruct(netloc_physical_link_t *link);
215  char * netloc_link_pretty_print(netloc_physical_link_t* link);
216  netloc_path_t *netloc_path_construct(void);
217  int netloc_path_destruct(netloc_path_t *path);
218  netloc_arch_t * netloc_arch_construct(void);
219  int netloc_arch_destruct(netloc_arch_t *arch);
220  int netloc_arch_build(netloc_arch_t *arch, int add_slots);
221  int netloc_arch_set_current_resources(netloc_arch_t *arch);
222  int netloc_arch_set_global_resources(netloc_arch_t *arch);
223  int netloc_arch_node_get_hwloc_info(netloc_arch_node_t *arch);
224  void netloc_arch_tree_complete(netloc_arch_tree_t *tree, UT_array **down_degrees_by_level,
225          int num_hosts, int **parch_idx);
226  NETLOC_int netloc_arch_tree_num_leaves(netloc_arch_tree_t *tree);
227  #define netloc_get_num_partitions(object) \
228      utarray_len((object)->partitions)
229  #define netloc_get_partition(object,i) \
230      (*(int *)utarray_eltptr((object)->partitions, (i)))
231  #define netloc_path_iter_links(path,link) \
232      for ((link) = (netloc_physical_link_t **)utarray_front(path->links); \
233              (link) != NULL; \
234              (link) = (netloc_physical_link_t **)utarray_next(path->links, link))
235  static inline const char * netloc_network_type_decode(netloc_network_type_t net_type) {
236      if( NETLOC_NETWORK_TYPE_ETHERNET == net_type ) {
237          return "ETH";
238      }
239      else if( NETLOC_NETWORK_TYPE_INFINIBAND == net_type ) {
240          return "IB";
241      }
242      else {
243          return NULL;
244      }
245  }
246  static inline const char * netloc_node_type_decode(netloc_node_type_t node_type) {
247      if( NETLOC_NODE_TYPE_SWITCH == node_type ) {
248          return "SW";
249      }
250      else if( NETLOC_NODE_TYPE_HOST == node_type ) {
251          return "CA";
252      }
253      else {
254          return NULL;
255      }
256  }
257  ssize_t netloc_line_get(char **lineptr, size_t *n, FILE *stream);
258  char *netloc_line_get_next_token(char **string, char c);
259  int netloc_build_comm_mat(char *filename, int *pn, double ***pmat);
260  #define STRDUP_IF_NOT_NULL(str) (NULL == str ? NULL : strdup(str))
261  #define STR_EMPTY_IF_NULL(str) (NULL == str ? "" : str)
262  #endif 
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from xmrig-MDEwOlJlcG9zaXRvcnk4ODMyNzQwNg==-flat-FileLog.h</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from xmrig-MDEwOlJlcG9zaXRvcnk4ODMyNzQwNg==-flat-netloc.h</div>
                </div>
                <div class="column column_space"><pre><code>9      FileLog(const char *fileName);
10  protected:
11      void print(uint64_t timestamp, int level, const char *line, size_t offset, size_t size, bool colors) override;
12  private:
13      FileLogWriter m_writer;
</pre></code></div>
                <div class="column column_space"><pre><code>64      char *topopath;
65      char *subnet_id;
66      netloc_node_t *nodes; &bsol;* Hash table of nodes by physical_id */
67      netloc_node_t *nodesByHostname; &bsol;* Hash table of nodes by hostname */
68      netloc_physical_link_t *physical_links; &bsol;* Hash table with physcial links */
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    