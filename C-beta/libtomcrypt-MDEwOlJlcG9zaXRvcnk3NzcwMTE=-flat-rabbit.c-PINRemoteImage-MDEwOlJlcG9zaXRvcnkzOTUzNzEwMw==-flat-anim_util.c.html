
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 6.393442622950819%, Tokens: 11, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>libtomcrypt-MDEwOlJlcG9zaXRvcnk3NzcwMTE=-flat-rabbit.c</h3>
            <pre><code>1  #include "tomcrypt_private.h"
2  #ifdef LTC_RABBIT
3  static LTC_INLINE ulong32 ss_rabbit_g_func(ulong32 x);
4  static LTC_INLINE void ss_rabbit_next_state(rabbit_ctx *p_instance);
5  static LTC_INLINE void ss_rabbit_gen_1_block(rabbit_state* st, unsigned char *out);
6  static LTC_INLINE ulong32 ss_rabbit_g_func(ulong32 x)
7  {
8     ulong32 a, b, h, l;
9     a = x &  0xFFFF;
10     b = x >> 16;
11     h = ((((ulong32)(a*a)>>17) + (ulong32)(a*b))>>15) + b*b;
12     l = x * x;
13     return (ulong32)(h^l);
14  }
15  static LTC_INLINE void ss_rabbit_next_state(rabbit_ctx *p_instance)
16  {
17     ulong32 g[8], c_old[8], i;
18     for (i=0; i<8; i++) {
19        c_old[i] = p_instance->c[i];
20     }
21     p_instance->c[0] = (ulong32)(p_instance->c[0] + 0x4D34D34D + p_instance->carry);
22     p_instance->c[1] = (ulong32)(p_instance->c[1] + 0xD34D34D3 + (p_instance->c[0] < c_old[0]));
23     p_instance->c[2] = (ulong32)(p_instance->c[2] + 0x34D34D34 + (p_instance->c[1] < c_old[1]));
24     p_instance->c[3] = (ulong32)(p_instance->c[3] + 0x4D34D34D + (p_instance->c[2] < c_old[2]));
25     p_instance->c[4] = (ulong32)(p_instance->c[4] + 0xD34D34D3 + (p_instance->c[3] < c_old[3]));
26     p_instance->c[5] = (ulong32)(p_instance->c[5] + 0x34D34D34 + (p_instance->c[4] < c_old[4]));
27     p_instance->c[6] = (ulong32)(p_instance->c[6] + 0x4D34D34D + (p_instance->c[5] < c_old[5]));
28     p_instance->c[7] = (ulong32)(p_instance->c[7] + 0xD34D34D3 + (p_instance->c[6] < c_old[6]));
29     p_instance->carry = (p_instance->c[7] < c_old[7]);
30     for (i=0;i<8;i++) {
31        g[i] = ss_rabbit_g_func((ulong32)(p_instance->x[i] + p_instance->c[i]));
32     }
33     p_instance->x[0] = (ulong32)(g[0] + ROLc(g[7],16) + ROLc(g[6], 16));
34     p_instance->x[1] = (ulong32)(g[1] + ROLc(g[0], 8) + g[7]);
35     p_instance->x[2] = (ulong32)(g[2] + ROLc(g[1],16) + ROLc(g[0], 16));
36     p_instance->x[3] = (ulong32)(g[3] + ROLc(g[2], 8) + g[1]);
37     p_instance->x[4] = (ulong32)(g[4] + ROLc(g[3],16) + ROLc(g[2], 16));
38     p_instance->x[5] = (ulong32)(g[5] + ROLc(g[4], 8) + g[3]);
39     p_instance->x[6] = (ulong32)(g[6] + ROLc(g[5],16) + ROLc(g[4], 16));
40     p_instance->x[7] = (ulong32)(g[7] + ROLc(g[6], 8) + g[5]);
41  }
42  static LTC_INLINE void ss_rabbit_gen_1_block(rabbit_state* st, unsigned char *out)
43  {
44      ulong32 *ptr;
45      ss_rabbit_next_state(&(st->work_ctx));
46      ptr = (ulong32*)&(st->work_ctx.x);
47      STORE32L((ptr[0] ^ (ptr[5]>>16) ^ (ulong32)(ptr[3]<<16)), out+ 0);
48      STORE32L((ptr[2] ^ (ptr[7]>>16) ^ (ulong32)(ptr[5]<<16)), out+ 4);
49      STORE32L((ptr[4] ^ (ptr[1]>>16) ^ (ulong32)(ptr[7]<<16)), out+ 8);
50      STORE32L((ptr[6] ^ (ptr[3]>>16) ^ (ulong32)(ptr[1]<<16)), out+12);
51  }
52  int rabbit_setup(rabbit_state* st, const unsigned char *key, unsigned long keylen)
53  {
54     ulong32 k0, k1, k2, k3, i;
55     unsigned char  tmpkey[16] = {0};
56     LTC_ARGCHK(st != NULL);
57     LTC_ARGCHK(key != NULL);
58     LTC_ARGCHK(keylen <= 16);
59     XMEMSET(st, 0, sizeof(rabbit_state));
60     XMEMCPY(tmpkey, key, keylen);
61     LOAD32L(k0, tmpkey+ 0);
62     LOAD32L(k1, tmpkey+ 4);
63     LOAD32L(k2, tmpkey+ 8);
64     LOAD32L(k3, tmpkey+12);
65  #ifdef LTC_CLEAN_STACK
66     zeromem(tmpkey, sizeof(tmpkey));
67  #endif
68     st->master_ctx.x[0] = k0;
69     st->master_ctx.x[2] = k1;
70     st->master_ctx.x[4] = k2;
71     st->master_ctx.x[6] = k3;
72     st->master_ctx.x[1] = (ulong32)(k3<<16) | (k2>>16);
73     st->master_ctx.x[3] = (ulong32)(k0<<16) | (k3>>16);
74     st->master_ctx.x[5] = (ulong32)(k1<<16) | (k0>>16);
75     st->master_ctx.x[7] = (ulong32)(k2<<16) | (k1>>16);
76     st->master_ctx.c[0] = ROLc(k2, 16);
77     st->master_ctx.c[2] = ROLc(k3, 16);
78     st->master_ctx.c[4] = ROLc(k0, 16);
79     st->master_ctx.c[6] = ROLc(k1, 16);
80     st->master_ctx.c[1] = (k0&0xFFFF0000) | (k1&0xFFFF);
81     st->master_ctx.c[3] = (k1&0xFFFF0000) | (k2&0xFFFF);
82     st->master_ctx.c[5] = (k2&0xFFFF0000) | (k3&0xFFFF);
83     st->master_ctx.c[7] = (k3&0xFFFF0000) | (k0&0xFFFF);
84     st->master_ctx.carry = 0;
85     for (i=0; i<4; i++) {
86        ss_rabbit_next_state(&(st->master_ctx));
87     }
88     for (i=0; i<8; i++) {
89        st->master_ctx.c[i] ^= st->master_ctx.x[(i+4)&0x7];
90     }
91     for (i=0; i<8; i++) {
92        st->work_ctx.x[i] = st->master_ctx.x[i];
93        st->work_ctx.c[i] = st->master_ctx.c[i];
94     }
95     st->work_ctx.carry = st->master_ctx.carry;
96     XMEMSET(&(st->block), 0, sizeof(st->block));
97     st->unused = 0;
98     return CRYPT_OK;
99  }
100  int rabbit_setiv(rabbit_state* st, const unsigned char *iv, unsigned long ivlen)
101  {
102     ulong32 i0, i1, i2, i3, i;
103     unsigned char  tmpiv[8] = {0};
104     LTC_ARGCHK(st != NULL);
105     LTC_ARGCHK(iv != NULL || ivlen == 0);
106     LTC_ARGCHK(ivlen <= 8);
107     if (iv && ivlen > 0) XMEMCPY(tmpiv, iv, ivlen);
108     LOAD32L(i0, tmpiv+0);
109     LOAD32L(i2, tmpiv+4);
110     i1 = (i0>>16) | (i2&0xFFFF0000);
111     i3 = (i2<<16) | (i0&0x0000FFFF);
112     st->work_ctx.c[0] = st->master_ctx.c[0] ^ i0;
113     st->work_ctx.c[1] = st->master_ctx.c[1] ^ i1;
114     st->work_ctx.c[2] = st->master_ctx.c[2] ^ i2;
115     st->work_ctx.c[3] = st->master_ctx.c[3] ^ i3;
116     st->work_ctx.c[4] = st->master_ctx.c[4] ^ i0;
117     st->work_ctx.c[5] = st->master_ctx.c[5] ^ i1;
118     st->work_ctx.c[6] = st->master_ctx.c[6] ^ i2;
119     st->work_ctx.c[7] = st->master_ctx.c[7] ^ i3;
120     for (i=0; i<8; i++) {
121        st->work_ctx.x[i] = st->master_ctx.x[i];
122     }
123     st->work_ctx.carry = st->master_ctx.carry;
124     for (i=0; i<4; i++) {
125        ss_rabbit_next_state(&(st->work_ctx));
126     }
127     XMEMSET(&(st->block), 0, sizeof(st->block));
128     st->unused = 0;
<span onclick='openModal()' class='match'>129     return CRYPT_OK;
130  }
131  int rabbit_crypt(rabbit_state* st, const unsigned char *in, unsigned long inlen, unsigned char *out)
132  {
133     unsigned char buf[16];
134     unsigned long i, j;
</span>135     if (inlen == 0) return CRYPT_OK; &bsol;* nothing to do */
136     LTC_ARGCHK(st        != NULL);
137     LTC_ARGCHK(in        != NULL);
138     LTC_ARGCHK(out       != NULL);
139     if (st->unused > 0) {
140        j = MIN(st->unused, inlen);
141        for (i = 0; i < j; ++i, st->unused--) out[i] = in[i] ^ st->block[16 - st->unused];
142        inlen -= j;
143        if (inlen == 0) return CRYPT_OK;
144        out += j;
145        in  += j;
146     }
147     for (;;) {
148       ss_rabbit_gen_1_block(st, buf);
149       if (inlen <= 16) {
150         for (i = 0; i < inlen; ++i) out[i] = in[i] ^ buf[i];
151         st->unused = 16 - inlen;
152         for (i = inlen; i < 16; ++i) st->block[i] = buf[i];
153         return CRYPT_OK;
154       }
155       for (i = 0; i < 16; ++i) out[i] = in[i] ^ buf[i];
156       inlen -= 16;
157       out += 16;
158       in  += 16;
159     }
160  }
161  int rabbit_keystream(rabbit_state *st, unsigned char *out, unsigned long outlen)
162  {
163     if (outlen == 0) return CRYPT_OK; &bsol;* nothing to do */
164     LTC_ARGCHK(out != NULL);
165     XMEMSET(out, 0, outlen);
166     return rabbit_crypt(st, out, outlen, out);
167  }
168  int rabbit_done(rabbit_state *st)
169  {
170     LTC_ARGCHK(st != NULL);
171     zeromem(st, sizeof(rabbit_state));
172     return CRYPT_OK;
173  }
174  int rabbit_test(void)
175  {
176  #ifndef LTC_TEST
177     return CRYPT_NOP;
178  #else
179     rabbit_state st;
180     int err;
181     unsigned char out[1000] = { 0 };
182     {
183        {
184           unsigned char k[]  = { 0x0F, 0x62, 0xB5, 0x08, 0x5B, 0xAE, 0x01, 0x54,
185                                  0xA7, 0xFA, 0x4D, 0xA0, 0xF3, 0x46, 0x99, 0xEC };
186           unsigned char iv[] = { 0x28, 0x8F, 0xF6, 0x5D, 0xC4, 0x2B, 0x92, 0xF9 };
187           char pt[64]        = { 0 };
188           unsigned char ct[] = { 0x61, 0x3C, 0xB0, 0xBA, 0x96, 0xAF, 0xF6, 0xCA,
189                                  0xCF, 0x2A, 0x45, 0x9A, 0x10, 0x2A, 0x7F, 0x78,
190                                  0xCA, 0x98, 0x5C, 0xF8, 0xFD, 0xD1, 0x47, 0x40,
191                                  0x18, 0x75, 0x8E, 0x36, 0xAE, 0x99, 0x23, 0xF5,
192                                  0x19, 0xD1, 0x3D, 0x71, 0x8D, 0xAF, 0x8D, 0x7C,
193                                  0x0C, 0x10, 0x9B, 0x79, 0xD5, 0x74, 0x94, 0x39,
194                                  0xB7, 0xEF, 0xA4, 0xC4, 0xC9, 0xC8, 0xD2, 0x9D,
195                                  0xC5, 0xB3, 0x88, 0x83, 0x14, 0xA6, 0x81, 0x6F };
196           unsigned long ptlen = sizeof(pt);
197           if ((err = rabbit_setup(&st, k, sizeof(k)))                   != CRYPT_OK) return err;
198           if ((err = rabbit_setiv(&st, iv, sizeof(iv)))                 != CRYPT_OK) return err;
199           if ((err = rabbit_crypt(&st, (unsigned char*)pt, ptlen, out)) != CRYPT_OK) return err;
200           if (compare_testvector(out, ptlen, ct, ptlen, "RABBIT-TV1", 1))   return CRYPT_FAIL_TESTVECTOR;
201        }
202        {
203           unsigned char k[]  = { 0x0F, 0x62, 0xB5, 0x08, 0x5B, 0xAE, 0x01, 0x54,
204                                  0xA7, 0xFA, 0x4D, 0xA0, 0xF3, 0x46, 0x99, 0xEC };
205           unsigned char iv[] = { 0x28, 0x8F, 0xF6, 0x5D, 0xC4, 0x2B, 0x92, 0xF9 };
206           char          pt[39] = { 0 };
207           unsigned char ct[] = { 0x61, 0x3C, 0xB0, 0xBA,   0x96, 0xAF, 0xF6, 0xCA,
208                                  0xCF, 0x2A, 0x45, 0x9A,   0x10, 0x2A, 0x7F, 0x78,
209                                  0xCA, 0x98, 0x5C, 0xF8,   0xFD, 0xD1, 0x47, 0x40,
210                                  0x18, 0x75, 0x8E, 0x36,   0xAE, 0x99, 0x23, 0xF5,
211                                  0x19, 0xD1, 0x3D, 0x71,   0x8D, 0xAF, 0x8D };
212           unsigned long ptlen = sizeof(pt);
213           if ((err = rabbit_setup(&st, k, sizeof(k)))                          != CRYPT_OK) return err;
214           if ((err = rabbit_setiv(&st, iv, sizeof(iv)))                        != CRYPT_OK) return err;
215           if ((err = rabbit_crypt(&st, (unsigned char*)pt,       5, out))      != CRYPT_OK) return err;
216           if ((err = rabbit_crypt(&st, (unsigned char*)pt +  5, 11, out +  5)) != CRYPT_OK) return err;
217           if ((err = rabbit_crypt(&st, (unsigned char*)pt + 16, 14, out + 16)) != CRYPT_OK) return err;
218           if ((err = rabbit_crypt(&st, (unsigned char*)pt + 30,  2, out + 30)) != CRYPT_OK) return err;
219           if ((err = rabbit_crypt(&st, (unsigned char*)pt + 32,  7, out + 32)) != CRYPT_OK) return err;
220           if (compare_testvector(out, ptlen, ct, ptlen, "RABBIT-TV2", 1))   return CRYPT_FAIL_TESTVECTOR;
221        }
222        {
223           unsigned char k[]  = { 0x0F, 0x62, 0xB5, 0x08, 0x5B, 0xAE, 0x01, 0x54,
224                                  0xA7, 0xFA, 0x4D, 0xA0, 0xF3, 0x46, 0x99, 0xEC };
225           unsigned char iv[] = { 0x28, 0x8F, 0xF6, 0x5D, 0xC4, 0x2B, 0x92, 0xF9 };
226           char          pt[] = "Kilroy was here, there, and everywhere!";
227           unsigned char ct[] = { 0x2a, 0x55, 0xdc, 0xc8,   0xf9, 0xd6, 0xd6, 0xbd,
228                                  0xae, 0x59, 0x65, 0xf2,   0x75, 0x58, 0x1a, 0x54,
229                                  0xea, 0xec, 0x34, 0x9d,   0x8f, 0xb4, 0x6b, 0x60,
230                                  0x79, 0x1b, 0xea, 0x16,   0xcb, 0xef, 0x46, 0x87,
231                                  0x60, 0xa6, 0x55, 0x14,   0xff, 0xca, 0xac };
232           unsigned long ptlen = XSTRLEN(pt);
233           unsigned char out2[1000] = { 0 };
234           unsigned char nulls[1000] = { 0 };
235           if ((err = rabbit_setup(&st, k, sizeof(k)))                          != CRYPT_OK) return err;
236           if ((err = rabbit_setiv(&st, iv, sizeof(iv)))                        != CRYPT_OK) return err;
237           if ((err = rabbit_crypt(&st, (unsigned char*)pt,       5, out))      != CRYPT_OK) return err;
238           if ((err = rabbit_crypt(&st, (unsigned char*)pt +  5, 29, out +  5)) != CRYPT_OK) return err;
239           if ((err = rabbit_crypt(&st, (unsigned char*)pt + 34,  5, out + 34)) != CRYPT_OK) return err;
240           if (compare_testvector(out, ptlen, ct, ptlen, "RABBIT-TV3", 1))   return CRYPT_FAIL_TESTVECTOR;
241           if ((err = rabbit_memory(k, sizeof(k), iv, sizeof(iv),
242                                     (unsigned char*)pt, sizeof(pt), out))      != CRYPT_OK) return err;
243           if (compare_testvector(out, ptlen, ct, ptlen, "RABBIT-TV4", 1))   return CRYPT_FAIL_TESTVECTOR;
244           if ((err = rabbit_setiv(&st, iv, sizeof(iv)))                        != CRYPT_OK) return err;
245           if ((err = rabbit_crypt(&st, out, ptlen, out2))                      != CRYPT_OK) return err;
246           if (compare_testvector(out2, ptlen, pt, ptlen, "RABBIT-TV5", 1))  return CRYPT_FAIL_TESTVECTOR;
247           if ((err = rabbit_done(&st))                      != CRYPT_OK) return err;
248           if (compare_testvector(&st, sizeof(st), nulls, sizeof(st), "RABBIT-TV6", 1))  return CRYPT_FAIL_TESTVECTOR;
249        }
250        return CRYPT_OK;
251     }
252  #endif
253  }
254  #endif
</code></pre>
        </div>
        <div class="column">
            <h3>PINRemoteImage-MDEwOlJlcG9zaXRvcnkzOTUzNzEwMw==-flat-anim_util.c</h3>
            <pre><code>1  #include "./anim_util.h"
2  #include <assert.h>
3  #include <math.h>
4  #include <stdio.h>
5  #include <string.h>
6  #if defined(WEBP_HAVE_GIF)
7  #include <gif_lib.h>
8  #endif
9  #include "webp/format_constants.h"
10  #include "webp/decode.h"
11  #include "webp/demux.h"
12  #include "../imageio/imageio_util.h"
13  #include "./gifdec.h"
14  #include "./unicode.h"
15  #include "./unicode_gif.h"
16  #if defined(_MSC_VER) && _MSC_VER < 1900
17  #define snprintf _snprintf
18  #endif
19  static const int kNumChannels = 4;
20  #if defined(WEBP_HAVE_GIF)
21  static int IsFullFrame(int width, int height,
22                         int canvas_width, int canvas_height) {
23    return (width == canvas_width && height == canvas_height);
24  }
25  #endif 
26  static int CheckSizeForOverflow(uint64_t size) {
27    return (size == (size_t)size);
28  }
29  static int AllocateFrames(AnimatedImage* const image, uint32_t num_frames) {
30    uint32_t i;
31    uint8_t* mem = NULL;
32    DecodedFrame* frames = NULL;
33    const uint64_t rgba_size =
34        (uint64_t)image->canvas_width * kNumChannels * image->canvas_height;
35    const uint64_t total_size = (uint64_t)num_frames * rgba_size * sizeof(*mem);
36    const uint64_t total_frame_size = (uint64_t)num_frames * sizeof(*frames);
37    if (!CheckSizeForOverflow(total_size) ||
38        !CheckSizeForOverflow(total_frame_size)) {
39      return 0;
40    }
41    mem = (uint8_t*)WebPMalloc((size_t)total_size);
42    frames = (DecodedFrame*)WebPMalloc((size_t)total_frame_size);
43    if (mem == NULL || frames == NULL) {
44      WebPFree(mem);
45      WebPFree(frames);
46      return 0;
47    }
48    WebPFree(image->raw_mem);
49    image->num_frames = num_frames;
50    image->frames = frames;
51    for (i = 0; i < num_frames; ++i) {
52      frames[i].rgba = mem + i * rgba_size;
53      frames[i].duration = 0;
54      frames[i].is_key_frame = 0;
55    }
56    image->raw_mem = mem;
57    return 1;
58  }
59  void ClearAnimatedImage(AnimatedImage* const image) {
60    if (image != NULL) {
61      WebPFree(image->raw_mem);
62      WebPFree(image->frames);
63      image->num_frames = 0;
64      image->frames = NULL;
65      image->raw_mem = NULL;
66    }
67  }
68  #if defined(WEBP_HAVE_GIF)
69  static void ZeroFillCanvas(uint8_t* rgba,
70                             uint32_t canvas_width, uint32_t canvas_height) {
71    memset(rgba, 0, canvas_width * kNumChannels * canvas_height);
72  }
73  static void ZeroFillFrameRect(uint8_t* rgba, int rgba_stride, int x_offset,
74                                int y_offset, int width, int height) {
75    int j;
76    assert(width * kNumChannels <= rgba_stride);
77    rgba += y_offset * rgba_stride + x_offset * kNumChannels;
78    for (j = 0; j < height; ++j) {
79      memset(rgba, 0, width * kNumChannels);
80      rgba += rgba_stride;
81    }
82  }
83  static void CopyCanvas(const uint8_t* src, uint8_t* dst,
84                         uint32_t width, uint32_t height) {
85    assert(src != NULL && dst != NULL);
86    memcpy(dst, src, width * kNumChannels * height);
87  }
88  static void CopyFrameRectangle(const uint8_t* src, uint8_t* dst, int stride,
89                                 int x_offset, int y_offset,
90                                 int width, int height) {
91    int j;
92    const int width_in_bytes = width * kNumChannels;
93    const size_t offset = y_offset * stride + x_offset * kNumChannels;
94    assert(width_in_bytes <= stride);
95    src += offset;
96    dst += offset;
97    for (j = 0; j < height; ++j) {
98      memcpy(dst, src, width_in_bytes);
99      src += stride;
100      dst += stride;
101    }
102  }
103  #endif 
104  static void CleanupTransparentPixels(uint32_t* rgba,
105                                       uint32_t width, uint32_t height) {
106    const uint32_t* const rgba_end = rgba + width * height;
107    while (rgba < rgba_end) {
108      const uint8_t alpha = (*rgba >> 24) & 0xff;
109      if (alpha == 0) {
110        *rgba = 0;
111      }
112      ++rgba;
113    }
114  }
115  static int DumpFrame(const char filename[], const char dump_folder[],
116                       uint32_t frame_num, const uint8_t rgba[],
117                       int canvas_width, int canvas_height) {
118    int ok = 0;
119    size_t max_len;
120    int y;
121    const W_CHAR* base_name = NULL;
122    W_CHAR* file_name = NULL;
123    FILE* f = NULL;
124    const char* row;
125    if (dump_folder == NULL) dump_folder = (const char*)TO_W_CHAR(".");
126    base_name = WSTRRCHR(filename, '/');
127    base_name = (base_name == NULL) ? (const W_CHAR*)filename : base_name + 1;
128    max_len = WSTRLEN(dump_folder) + 1 + WSTRLEN(base_name)
129            + strlen("_frame_") + strlen(".pam") + 8;
130    file_name = (W_CHAR*)WebPMalloc(max_len * sizeof(*file_name));
131    if (file_name == NULL) goto End;
132    if (WSNPRINTF(file_name, max_len, "%s/%s_frame_%d.pam",
133                  (const W_CHAR*)dump_folder, base_name, frame_num) < 0) {
134      fprintf(stderr, "Error while generating file name\n");
135      goto End;
136    }
137    f = WFOPEN(file_name, "wb");
138    if (f == NULL) {
139      WFPRINTF(stderr, "Error opening file for writing: %s\n", file_name);
140      ok = 0;
141      goto End;
142    }
143    if (fprintf(f, "P7\nWIDTH %d\nHEIGHT %d\n"
144                "DEPTH 4\nMAXVAL 255\nTUPLTYPE RGB_ALPHA\nENDHDR\n",
145                canvas_width, canvas_height) < 0) {
146      WFPRINTF(stderr, "Write error for file %s\n", file_name);
147      goto End;
148    }
149    row = (const char*)rgba;
150    for (y = 0; y < canvas_height; ++y) {
151      if (fwrite(row, canvas_width * kNumChannels, 1, f) != 1) {
152        WFPRINTF(stderr, "Error writing to file: %s\n", file_name);
153        goto End;
154      }
155      row += canvas_width * kNumChannels;
156    }
157    ok = 1;
158   End:
159    if (f != NULL) fclose(f);
160    WebPFree(file_name);
161    return ok;
162  }
163  static int IsWebP(const WebPData* const webp_data) {
164    return (WebPGetInfo(webp_data->bytes, webp_data->size, NULL, NULL) != 0);
165  }
166  static int ReadAnimatedWebP(const char filename[],
167                              const WebPData* const webp_data,
168                              AnimatedImage* const image, int dump_frames,
169                              const char dump_folder[]) {
170    int ok = 0;
171    int dump_ok = 1;
172    uint32_t frame_index = 0;
173    int prev_frame_timestamp = 0;
174    WebPAnimDecoder* dec;
175    WebPAnimInfo anim_info;
176    memset(image, 0, sizeof(*image));
177    dec = WebPAnimDecoderNew(webp_data, NULL);
178    if (dec == NULL) {
179      WFPRINTF(stderr, "Error parsing image: %s\n", (const W_CHAR*)filename);
180      goto End;
181    }
182    if (!WebPAnimDecoderGetInfo(dec, &anim_info)) {
183      fprintf(stderr, "Error getting global info about the animation\n");
184      goto End;
185    }
186    image->canvas_width = anim_info.canvas_width;
187    image->canvas_height = anim_info.canvas_height;
188    image->loop_count = anim_info.loop_count;
189    image->bgcolor = anim_info.bgcolor;
190    if (!AllocateFrames(image, anim_info.frame_count)) return 0;
191    while (WebPAnimDecoderHasMoreFrames(dec)) {
192      DecodedFrame* curr_frame;
193      uint8_t* curr_rgba;
194      uint8_t* frame_rgba;
195      int timestamp;
196      if (!WebPAnimDecoderGetNext(dec, &frame_rgba, &timestamp)) {
197        fprintf(stderr, "Error decoding frame #%u\n", frame_index);
198        goto End;
199      }
200      assert(frame_index < anim_info.frame_count);
201      curr_frame = &image->frames[frame_index];
202      curr_rgba = curr_frame->rgba;
203      curr_frame->duration = timestamp - prev_frame_timestamp;
204      curr_frame->is_key_frame = 0;  
205      memcpy(curr_rgba, frame_rgba,
206             image->canvas_width * kNumChannels * image->canvas_height);
207      CleanupTransparentPixels((uint32_t*)curr_rgba,
208                               image->canvas_width, image->canvas_height);
209      if (dump_frames && dump_ok) {
210        dump_ok = DumpFrame(filename, dump_folder, frame_index, curr_rgba,
211                            image->canvas_width, image->canvas_height);
212        if (!dump_ok) {  
213          fprintf(stderr, "Error dumping frames to %s\n", dump_folder);
214        }
215      }
216      ++frame_index;
217      prev_frame_timestamp = timestamp;
218    }
219    ok = dump_ok;
220    if (ok) image->format = ANIM_WEBP;
221   End:
222    WebPAnimDecoderDelete(dec);
223    return ok;
224  }
225  #if defined(WEBP_HAVE_GIF)
226  static int IsGIF(const WebPData* const data) {
227    return data->size > GIF_STAMP_LEN &&
228           (!memcmp(GIF_STAMP, data->bytes, GIF_STAMP_LEN) ||
229            !memcmp(GIF87_STAMP, data->bytes, GIF_STAMP_LEN) ||
230            !memcmp(GIF89_STAMP, data->bytes, GIF_STAMP_LEN));
231  }
232  #if defined(GIFLIB_MAJOR) && defined(GIFLIB_MINOR)
233  # define LOCAL_GIF_VERSION ((GIFLIB_MAJOR << 8) | GIFLIB_MINOR)
234  # define LOCAL_GIF_PREREQ(maj, min) \
235      (LOCAL_GIF_VERSION >= (((maj) << 8) | (min)))
236  #else
237  # define LOCAL_GIF_VERSION 0
238  # define LOCAL_GIF_PREREQ(maj, min) 0
239  #endif
240  #if !LOCAL_GIF_PREREQ(5, 0)
241  typedef struct {
242    int DisposalMode;
243  #define DISPOSAL_UNSPECIFIED      0       
244  #define DISPOSE_DO_NOT            1       
245  #define DISPOSE_BACKGROUND        2       
246  #define DISPOSE_PREVIOUS          3       
247    int UserInputFlag;       
248    int DelayTime;           
249    int TransparentColor;    
250  #define NO_TRANSPARENT_COLOR     -1
251  } GraphicsControlBlock;
252  static int DGifExtensionToGCB(const size_t GifExtensionLength,
253                                const GifByteType* GifExtension,
254                                GraphicsControlBlock* gcb) {
255    if (GifExtensionLength != 4) {
256      return GIF_ERROR;
257    }
258    gcb->DisposalMode = (GifExtension[0] >> 2) & 0x07;
259    gcb->UserInputFlag = (GifExtension[0] & 0x02) != 0;
260    gcb->DelayTime = GifExtension[1] | (GifExtension[2] << 8);
261    if (GifExtension[0] & 0x01) {
262      gcb->TransparentColor = (int)GifExtension[3];
263    } else {
264      gcb->TransparentColor = NO_TRANSPARENT_COLOR;
265    }
266    return GIF_OK;
267  }
268  static int DGifSavedExtensionToGCB(GifFileType* GifFile, int ImageIndex,
269                                     GraphicsControlBlock* gcb) {
270    int i;
271    if (ImageIndex < 0 || ImageIndex > GifFile->ImageCount - 1) {
272      return GIF_ERROR;
273    }
274    gcb->DisposalMode = DISPOSAL_UNSPECIFIED;
275    gcb->UserInputFlag = 0;
276    gcb->DelayTime = 0;
277    gcb->TransparentColor = NO_TRANSPARENT_COLOR;
278    for (i = 0; i < GifFile->SavedImages[ImageIndex].ExtensionBlockCount; i++) {
279      ExtensionBlock* ep = &GifFile->SavedImages[ImageIndex].ExtensionBlocks[i];
280      if (ep->Function == GRAPHICS_EXT_FUNC_CODE) {
281        return DGifExtensionToGCB(
282            ep->ByteCount, (const GifByteType*)ep->Bytes, gcb);
283      }
284    }
285    return GIF_ERROR;
286  }
287  #define CONTINUE_EXT_FUNC_CODE 0x00
288  #define DGifOpenFileName(a, b) DGifOpenFileName(a)
289  #endif  
290  #if !LOCAL_GIF_PREREQ(5, 1)
291  #define DGifCloseFile(a, b) DGifCloseFile(a)
292  #endif
293  static int IsKeyFrameGIF(const GifImageDesc* prev_desc, int prev_dispose,
294                           const DecodedFrame* const prev_frame,
295                           int canvas_width, int canvas_height) {
296    if (prev_frame == NULL) return 1;
297    if (prev_dispose == DISPOSE_BACKGROUND) {
298      if (IsFullFrame(prev_desc->Width, prev_desc->Height,
299                      canvas_width, canvas_height)) {
300        return 1;
301      }
302      if (prev_frame->is_key_frame) return 1;
303    }
304    return 0;
305  }
306  static int GetTransparentIndexGIF(GifFileType* gif) {
307    GraphicsControlBlock first_gcb;
308    memset(&first_gcb, 0, sizeof(first_gcb));
309    DGifSavedExtensionToGCB(gif, 0, &first_gcb);
310    return first_gcb.TransparentColor;
311  }
312  static uint32_t GetBackgroundColorGIF(GifFileType* gif) {
313    const int transparent_index = GetTransparentIndexGIF(gif);
314    const ColorMapObject* const color_map = gif->SColorMap;
315    if (transparent_index != NO_TRANSPARENT_COLOR &&
316        gif->SBackGroundColor == transparent_index) {
317      return 0x00000000;  
318    } else if (color_map == NULL || color_map->Colors == NULL
319               || gif->SBackGroundColor >= color_map->ColorCount) {
320      return 0xffffffff;  
321    } else {
322      const GifColorType color = color_map->Colors[gif->SBackGroundColor];
323      return (0xff << 24) |
324             (color.Red << 16) |
325             (color.Green << 8) |
326             (color.Blue << 0);
327    }
328  }
329  static uint32_t GetLoopCountGIF(const GifFileType* const gif) {
330    int i;
331    for (i = 0; i < gif->ImageCount; ++i) {
332      const SavedImage* const image = &gif->SavedImages[i];
333      int j;
334      for (j = 0; (j + 1) < image->ExtensionBlockCount; ++j) {
335        const ExtensionBlock* const eb1 = image->ExtensionBlocks + j;
336        const ExtensionBlock* const eb2 = image->ExtensionBlocks + j + 1;
337        const char* const signature = (const char*)eb1->Bytes;
338        const int signature_is_ok =
339            (eb1->Function == APPLICATION_EXT_FUNC_CODE) &&
340            (eb1->ByteCount == 11) &&
341            (!memcmp(signature, "NETSCAPE2.0", 11) ||
342             !memcmp(signature, "ANIMEXTS1.0", 11));
343        if (signature_is_ok &&
344            eb2->Function == CONTINUE_EXT_FUNC_CODE && eb2->ByteCount >= 3 &&
345            eb2->Bytes[0] == 1) {
346          const uint32_t extra_loop = ((uint32_t)(eb2->Bytes[2]) << 8) +
347                                      ((uint32_t)(eb2->Bytes[1]) << 0);
348          return (extra_loop > 0) ? extra_loop + 1 : 0;
349        }
350      }
351    }
352    return 1;  
353  }
354  static int GetFrameDurationGIF(GifFileType* gif, int n) {
355    GraphicsControlBlock gcb;
356    memset(&gcb, 0, sizeof(gcb));
357    DGifSavedExtensionToGCB(gif, n, &gcb);
358    return gcb.DelayTime * 10;
359  }
360  static int CoversFrameGIF(const GifImageDesc* const target,
361                            const GifImageDesc* const covered) {
362    return target->Left <= covered->Left &&
363           covered->Left + covered->Width <= target->Left + target->Width &&
364           target->Top <= covered->Top &&
365           covered->Top + covered->Height <= target->Top + target->Height;
366  }
367  static void RemapPixelsGIF(const uint8_t* const src,
368                             const ColorMapObject* const cmap,
369                             int transparent_color, int len, uint8_t* dst) {
370    int i;
371    for (i = 0; i < len; ++i) {
372      if (src[i] != transparent_color) {
373        const GifColorType c = cmap->Colors[src[i]];
374        dst[4 * i + 0] = c.Red;
375        dst[4 * i + 1] = c.Green;
376        dst[4 * i + 2] = c.Blue;
377        dst[4 * i + 3] = 0xff;
378      }
379    }
380  }
381  static int ReadFrameGIF(const SavedImage* const gif_image,
382                          const ColorMapObject* cmap, int transparent_color,
383                          int out_stride, uint8_t* const dst) {
384    const GifImageDesc* image_desc = &gif_image->ImageDesc;
385    const uint8_t* in;
386    uint8_t* out;
387    int j;
388    if (image_desc->ColorMap) cmap = image_desc->ColorMap;
389    if (cmap == NULL || cmap->ColorCount != (1 << cmap->BitsPerPixel)) {
390      fprintf(stderr, "Potentially corrupt color map.\n");
391      return 0;
392    }
393    in = (const uint8_t*)gif_image->RasterBits;
394    out = dst + image_desc->Top * out_stride + image_desc->Left * kNumChannels;
395    for (j = 0; j < image_desc->Height; ++j) {
396      RemapPixelsGIF(in, cmap, transparent_color, image_desc->Width, out);
397      in += image_desc->Width;
398      out += out_stride;
399    }
<span onclick='openModal()' class='match'>400    return 1;
401  }
402  static int ReadAnimatedGIF(const char filename[], AnimatedImage* const image,
403                             int dump_frames, const char dump_folder[]) {
404    uint32_t frame_count;
405    uint32_t canvas_width, canvas_height;
406    uint32_t i;
407    int gif_error;
</span>408    GifFileType* gif;
409    gif = DGifOpenFileUnicode((const W_CHAR*)filename, NULL);
410    if (gif == NULL) {
411      WFPRINTF(stderr, "Could not read file: %s.\n", (const W_CHAR*)filename);
412      return 0;
413    }
414    gif_error = DGifSlurp(gif);
415    if (gif_error != GIF_OK) {
416      WFPRINTF(stderr, "Could not parse image: %s.\n", (const W_CHAR*)filename);
417      GIFDisplayError(gif, gif_error);
418      DGifCloseFile(gif, NULL);
419      return 0;
420    }
421    image->canvas_width = (uint32_t)gif->SWidth;
422    image->canvas_height = (uint32_t)gif->SHeight;
423    if (image->canvas_width > MAX_CANVAS_SIZE ||
424        image->canvas_height > MAX_CANVAS_SIZE) {
425      fprintf(stderr, "Invalid canvas dimension: %d x %d\n",
426              image->canvas_width, image->canvas_height);
427      DGifCloseFile(gif, NULL);
428      return 0;
429    }
430    image->loop_count = GetLoopCountGIF(gif);
431    image->bgcolor = GetBackgroundColorGIF(gif);
432    frame_count = (uint32_t)gif->ImageCount;
433    if (frame_count == 0) {
434      DGifCloseFile(gif, NULL);
435      return 0;
436    }
437    if (image->canvas_width == 0 || image->canvas_height == 0) {
438      image->canvas_width = gif->SavedImages[0].ImageDesc.Width;
439      image->canvas_height = gif->SavedImages[0].ImageDesc.Height;
440      gif->SavedImages[0].ImageDesc.Left = 0;
441      gif->SavedImages[0].ImageDesc.Top = 0;
442      if (image->canvas_width == 0 || image->canvas_height == 0) {
443        fprintf(stderr, "Invalid canvas size in GIF.\n");
444        DGifCloseFile(gif, NULL);
445        return 0;
446      }
447    }
448    AllocateFrames(image, frame_count);
449    canvas_width = image->canvas_width;
450    canvas_height = image->canvas_height;
451    for (i = 0; i < frame_count; ++i) {
452      const int canvas_width_in_bytes = canvas_width * kNumChannels;
453      const SavedImage* const curr_gif_image = &gif->SavedImages[i];
454      GraphicsControlBlock curr_gcb;
455      DecodedFrame* curr_frame;
456      uint8_t* curr_rgba;
457      memset(&curr_gcb, 0, sizeof(curr_gcb));
458      DGifSavedExtensionToGCB(gif, i, &curr_gcb);
459      curr_frame = &image->frames[i];
460      curr_rgba = curr_frame->rgba;
461      curr_frame->duration = GetFrameDurationGIF(gif, i);
462      if (curr_frame->duration <= 10) curr_frame->duration = 100;
463      if (i == 0) {  
464        curr_frame->is_key_frame = 1;
465        ZeroFillCanvas(curr_rgba, canvas_width, canvas_height);
466      } else {
467        DecodedFrame* const prev_frame = &image->frames[i - 1];
468        const GifImageDesc* const prev_desc = &gif->SavedImages[i - 1].ImageDesc;
469        GraphicsControlBlock prev_gcb;
470        memset(&prev_gcb, 0, sizeof(prev_gcb));
471        DGifSavedExtensionToGCB(gif, i - 1, &prev_gcb);
472        curr_frame->is_key_frame =
473            IsKeyFrameGIF(prev_desc, prev_gcb.DisposalMode, prev_frame,
474                          canvas_width, canvas_height);
475        if (curr_frame->is_key_frame) {  
476          ZeroFillCanvas(curr_rgba, canvas_width, canvas_height);
477        } else {
478          int prev_frame_disposed, curr_frame_opaque;
479          int prev_frame_completely_covered;
480          uint8_t* const prev_rgba = image->frames[i - 1].rgba;
481          CopyCanvas(prev_rgba, curr_rgba, canvas_width, canvas_height);
482          prev_frame_disposed =
483              (prev_gcb.DisposalMode == DISPOSE_BACKGROUND ||
484               prev_gcb.DisposalMode == DISPOSE_PREVIOUS);
485          curr_frame_opaque =
486              (curr_gcb.TransparentColor == NO_TRANSPARENT_COLOR);
487          prev_frame_completely_covered =
488              curr_frame_opaque &&
489              CoversFrameGIF(&curr_gif_image->ImageDesc, prev_desc);
490          if (prev_frame_disposed && !prev_frame_completely_covered) {
491            switch (prev_gcb.DisposalMode) {
492              case DISPOSE_BACKGROUND: {
493                ZeroFillFrameRect(curr_rgba, canvas_width_in_bytes,
494                                  prev_desc->Left, prev_desc->Top,
495                                  prev_desc->Width, prev_desc->Height);
496                break;
497              }
498              case DISPOSE_PREVIOUS: {
499                int src_frame_num = i - 2;
500                while (src_frame_num >= 0) {
501                  GraphicsControlBlock src_frame_gcb;
502                  memset(&src_frame_gcb, 0, sizeof(src_frame_gcb));
503                  DGifSavedExtensionToGCB(gif, src_frame_num, &src_frame_gcb);
504                  if (src_frame_gcb.DisposalMode != DISPOSE_PREVIOUS) break;
505                  --src_frame_num;
506                }
507                if (src_frame_num >= 0) {
508                  uint8_t* const src_frame_rgba =
509                      image->frames[src_frame_num].rgba;
510                  CopyFrameRectangle(src_frame_rgba, curr_rgba,
511                                     canvas_width_in_bytes,
512                                     prev_desc->Left, prev_desc->Top,
513                                     prev_desc->Width, prev_desc->Height);
514                } else {
515                  ZeroFillFrameRect(curr_rgba, canvas_width_in_bytes,
516                                    prev_desc->Left, prev_desc->Top,
517                                    prev_desc->Width, prev_desc->Height);
518                }
519                break;
520              }
521              default:
522                break;  
523            }
524          }
525        }
526      }
527      if (!ReadFrameGIF(curr_gif_image, gif->SColorMap, curr_gcb.TransparentColor,
528                        canvas_width_in_bytes, curr_rgba)) {
529        DGifCloseFile(gif, NULL);
530        return 0;
531      }
532      if (dump_frames) {
533        if (!DumpFrame(filename, dump_folder, i, curr_rgba,
534                       canvas_width, canvas_height)) {
535          DGifCloseFile(gif, NULL);
536          return 0;
537        }
538      }
539    }
540    image->format = ANIM_GIF;
541    DGifCloseFile(gif, NULL);
542    return 1;
543  }
544  #else
545  static int IsGIF(const WebPData* const data) {
546    (void)data;
547    return 0;
548  }
549  static int ReadAnimatedGIF(const char filename[], AnimatedImage* const image,
550                             int dump_frames, const char dump_folder[]) {
551    (void)filename;
552    (void)image;
553    (void)dump_frames;
554    (void)dump_folder;
555    fprintf(stderr, "GIF support not compiled. Please install the libgif-dev "
556            "package before building.\n");
557    return 0;
558  }
559  #endif  
560  int ReadAnimatedImage(const char filename[], AnimatedImage* const image,
561                        int dump_frames, const char dump_folder[]) {
562    int ok = 0;
563    WebPData webp_data;
564    WebPDataInit(&webp_data);
565    memset(image, 0, sizeof(*image));
566    if (!ImgIoUtilReadFile(filename, &webp_data.bytes, &webp_data.size)) {
567      WFPRINTF(stderr, "Error reading file: %s\n", (const W_CHAR*)filename);
568      return 0;
569    }
570    if (IsWebP(&webp_data)) {
571      ok = ReadAnimatedWebP(filename, &webp_data, image, dump_frames,
572                            dump_folder);
573    } else if (IsGIF(&webp_data)) {
574      ok = ReadAnimatedGIF(filename, image, dump_frames, dump_folder);
575    } else {
576      WFPRINTF(stderr,
577               "Unknown file type: %s. Supported file types are WebP and GIF\n",
578               (const W_CHAR*)filename);
579      ok = 0;
580    }
581    if (!ok) ClearAnimatedImage(image);
582    WebPDataClear(&webp_data);
583    return ok;
584  }
585  static void Accumulate(double v1, double v2, double* const max_diff,
586                         double* const sse) {
587    const double diff = fabs(v1 - v2);
588    if (diff > *max_diff) *max_diff = diff;
589    *sse += diff * diff;
590  }
591  void GetDiffAndPSNR(const uint8_t rgba1[], const uint8_t rgba2[],
592                      uint32_t width, uint32_t height, int premultiply,
593                      int* const max_diff, double* const psnr) {
594    const uint32_t stride = width * kNumChannels;
595    const int kAlphaChannel = kNumChannels - 1;
596    double f_max_diff = 0.;
597    double sse = 0.;
598    uint32_t x, y;
599    for (y = 0; y < height; ++y) {
600      for (x = 0; x < stride; x += kNumChannels) {
601        int k;
602        const size_t offset = (size_t)y * stride + x;
603        const int alpha1 = rgba1[offset + kAlphaChannel];
604        const int alpha2 = rgba2[offset + kAlphaChannel];
605        Accumulate(alpha1, alpha2, &f_max_diff, &sse);
606        if (!premultiply) {
607          for (k = 0; k < kAlphaChannel; ++k) {
608            Accumulate(rgba1[offset + k], rgba2[offset + k], &f_max_diff, &sse);
609          }
610        } else {
611          for (k = 0; k < kAlphaChannel; ++k) {
612            Accumulate(rgba1[offset + k] * alpha1 / 255.,
613                       rgba2[offset + k] * alpha2 / 255.,
614                       &f_max_diff, &sse);
615          }
616        }
617      }
618    }
619    *max_diff = (int)f_max_diff;
620    if (*max_diff == 0) {
621      *psnr = 99.;  
622    } else {
623      sse /= stride * height;
624      *psnr = 4.3429448 * log(255. * 255. / sse);
625    }
626  }
627  void GetAnimatedImageVersions(int* const decoder_version,
628                                int* const demux_version) {
629    *decoder_version = WebPGetDecoderVersion();
630    *demux_version = WebPGetDemuxVersion();
631  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from libtomcrypt-MDEwOlJlcG9zaXRvcnk3NzcwMTE=-flat-rabbit.c</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from PINRemoteImage-MDEwOlJlcG9zaXRvcnkzOTUzNzEwMw==-flat-anim_util.c</div>
                </div>
                <div class="column column_space"><pre><code>129     return CRYPT_OK;
130  }
131  int rabbit_crypt(rabbit_state* st, const unsigned char *in, unsigned long inlen, unsigned char *out)
132  {
133     unsigned char buf[16];
134     unsigned long i, j;
</pre></code></div>
                <div class="column column_space"><pre><code>400    return 1;
401  }
402  static int ReadAnimatedGIF(const char filename[], AnimatedImage* const image,
403                             int dump_frames, const char dump_folder[]) {
404    uint32_t frame_count;
405    uint32_t canvas_width, canvas_height;
406    uint32_t i;
407    int gif_error;
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    