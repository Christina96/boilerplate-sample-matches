
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 6.21301775147929%, Tokens: 21, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>xmrig-MDEwOlJlcG9zaXRvcnk4ODMyNzQwNg==-flat-xml.h</h3>
            <pre><code>1  #ifndef PRIVATE_XML_H
2  #define PRIVATE_XML_H 1
3  #include "hwloc.h"
4  #include <sys/types.h>
5  HWLOC_DECLSPEC int hwloc__xml_verbose(void);
6  typedef struct hwloc__xml_import_state_s {
7    struct hwloc__xml_import_state_s *parent;
8    struct hwloc_xml_backend_data_s *global;
9    char data[32];
10  } * hwloc__xml_import_state_t;
11  struct hwloc__xml_imported_v1distances_s {
12    unsigned long kind;
13    unsigned nbobjs;
14    float *floats;
15    struct hwloc__xml_imported_v1distances_s *prev, *next;
16  };
17  HWLOC_DECLSPEC int hwloc__xml_import_diff(hwloc__xml_import_state_t state, hwloc_topology_diff_t *firstdiffp);
18  struct hwloc_xml_backend_data_s {
19    int (*look_init)(struct hwloc_xml_backend_data_s *bdata, struct hwloc__xml_import_state_s *state);
20    void (*look_done)(struct hwloc_xml_backend_data_s *bdata, int result);
21    void (*backend_exit)(struct hwloc_xml_backend_data_s *bdata);
22    int (*next_attr)(struct hwloc__xml_import_state_s * state, char **namep, char **valuep);
23    int (*find_child)(struct hwloc__xml_import_state_s * state, struct hwloc__xml_import_state_s * childstate, char **tagp);
24    int (*close_tag)(struct hwloc__xml_import_state_s * state); &bsol;* look for an explicit closing tag </name> */
25    void (*close_child)(struct hwloc__xml_import_state_s * state);
<span onclick='openModal()' class='match'>26    int (*get_content)(struct hwloc__xml_import_state_s * state, const char **beginp, size_t expected_length); &bsol;* return 0 on empty content (and sets beginp to empty string), 1 on actual content, -1 on error or unexpected content length */
27    void (*close_content)(struct hwloc__xml_import_state_s * state);
28    char * msgprefix;
29    void *data; &bsol;* libxml2 doc, or nolibxml buffer */
30    unsigned version_major, version_minor;
31    unsigned nbnumanodes;
32    hwloc_obj_t first_numanode, last_numanode; &bsol;* temporary cousin-list for handling v1distances */
</span>33    struct hwloc__xml_imported_v1distances_s *first_v1dist, *last_v1dist;
34  };
35  typedef struct hwloc__xml_export_state_s {
36    struct hwloc__xml_export_state_s *parent;
37    void (*new_child)(struct hwloc__xml_export_state_s *parentstate, struct hwloc__xml_export_state_s *state, const char *name);
38    void (*new_prop)(struct hwloc__xml_export_state_s *state, const char *name, const char *value);
39    void (*add_content)(struct hwloc__xml_export_state_s *state, const char *buffer, size_t length);
40    void (*end_object)(struct hwloc__xml_export_state_s *state, const char *name);
41    struct hwloc__xml_export_data_s {
42      hwloc_obj_t v1_memory_group; &bsol;* if we need to insert intermediate group above memory children when exporting to v1 */
43    } *global;
44    char data[40];
45  } * hwloc__xml_export_state_t;
46  HWLOC_DECLSPEC void hwloc__xml_export_topology(hwloc__xml_export_state_t parentstate, hwloc_topology_t topology, unsigned long flags);
47  HWLOC_DECLSPEC void hwloc__xml_export_diff(hwloc__xml_export_state_t parentstate, hwloc_topology_diff_t diff);
48  struct hwloc_xml_callbacks {
49    int (*backend_init)(struct hwloc_xml_backend_data_s *bdata, const char *xmlpath, const char *xmlbuffer, int xmlbuflen);
50    int (*export_file)(struct hwloc_topology *topology, struct hwloc__xml_export_data_s *edata, const char *filename, unsigned long flags);
51    int (*export_buffer)(struct hwloc_topology *topology, struct hwloc__xml_export_data_s *edata, char **xmlbuffer, int *buflen, unsigned long flags);
52    void (*free_buffer)(void *xmlbuffer);
53    int (*import_diff)(struct hwloc__xml_import_state_s *state, const char *xmlpath, const char *xmlbuffer, int xmlbuflen, hwloc_topology_diff_t *diff, char **refnamep);
54    int (*export_diff_file)(union hwloc_topology_diff_u *diff, const char *refname, const char *filename);
55    int (*export_diff_buffer)(union hwloc_topology_diff_u *diff, const char *refname, char **xmlbuffer, int *buflen);
56  };
57  struct hwloc_xml_component {
58    struct hwloc_xml_callbacks *nolibxml_callbacks;
59    struct hwloc_xml_callbacks *libxml_callbacks;
60  };
61  HWLOC_DECLSPEC void hwloc_xml_callbacks_register(struct hwloc_xml_component *component);
62  HWLOC_DECLSPEC void hwloc_xml_callbacks_reset(void);
63  #endif &bsol;* PRIVATE_XML_H */
</code></pre>
        </div>
        <div class="column">
            <h3>xmrig-MDEwOlJlcG9zaXRvcnk4ODMyNzQwNg==-flat-sph_echo.c</h3>
            <pre><code>1  #include <stddef.h>
2  #include <string.h>
3  #include <limits.h>
4  #include "sph_echo.h"
5  #ifdef __cplusplus
6  extern "C"{
7  #endif
8  #if SPH_SMALL_FOOTPRINT && !defined SPH_SMALL_FOOTPRINT_ECHO
9  #define SPH_SMALL_FOOTPRINT_ECHO   1
10  #endif
11  #if !defined SPH_ECHO_64 && SPH_64_TRUE
12  #define SPH_ECHO_64   1
13  #endif
14  #if !SPH_64
15  #undef SPH_ECHO_64
16  #endif
17  #ifdef _MSC_VER
18  #pragma warning (disable: 4146)
19  #endif
20  #define T32   SPH_T32
21  #define C32   SPH_C32
22  #if SPH_64
23  #define C64   SPH_C64
24  #endif
25  #define AES_BIG_ENDIAN   0
26  #include "aes_helper.c"
27  #if SPH_ECHO_64
28  #define DECL_STATE_SMALL   \
29  	sph_u64 W[16][2];
30  #define DECL_STATE_BIG   \
31  	sph_u64 W[16][2];
32  #define INPUT_BLOCK_SMALL(sc)   do { \
33  		unsigned u; \
34  		memcpy(W, sc->u.Vb, 8 * sizeof(sph_u64)); \
35  		for (u = 0; u < 12; u ++) { \
36  			W[u + 4][0] = sph_dec64le_aligned( \
37  				sc->buf + 16 * u); \
38  			W[u + 4][1] = sph_dec64le_aligned( \
39  				sc->buf + 16 * u + 8); \
40  		} \
41  	} while (0)
42  #define INPUT_BLOCK_BIG(sc)   do { \
43  		unsigned u; \
44  		memcpy(W, sc->u.Vb, 16 * sizeof(sph_u64)); \
45  		for (u = 0; u < 8; u ++) { \
46  			W[u + 8][0] = sph_dec64le_aligned( \
47  				sc->buf + 16 * u); \
48  			W[u + 8][1] = sph_dec64le_aligned( \
49  				sc->buf + 16 * u + 8); \
50  		} \
51  	} while (0)
52  #if SPH_SMALL_FOOTPRINT_ECHO
53  static void
54  aes_2rounds_all(sph_u64 W[16][2],
55  	sph_u32 *pK0, sph_u32 *pK1, sph_u32 *pK2, sph_u32 *pK3)
56  {
57  	int n;
58  	sph_u32 K0 = *pK0;
59  	sph_u32 K1 = *pK1;
60  	sph_u32 K2 = *pK2;
61  	sph_u32 K3 = *pK3;
62  	for (n = 0; n < 16; n ++) {
63  		sph_u64 Wl = W[n][0];
64  		sph_u64 Wh = W[n][1];
65  		sph_u32 X0 = (sph_u32)Wl;
66  		sph_u32 X1 = (sph_u32)(Wl >> 32);
67  		sph_u32 X2 = (sph_u32)Wh;
68  		sph_u32 X3 = (sph_u32)(Wh >> 32);
69  		sph_u32 Y0, Y1, Y2, Y3; \
<span onclick='openModal()' class='match'>70  		AES_ROUND_LE(X0, X1, X2, X3, K0, K1, K2, K3, Y0, Y1, Y2, Y3);
71  		AES_ROUND_NOKEY_LE(Y0, Y1, Y2, Y3, X0, X1, X2, X3);
</span>72  		W[n][0] = (sph_u64)X0 | ((sph_u64)X1 << 32);
73  		W[n][1] = (sph_u64)X2 | ((sph_u64)X3 << 32);
74  		if ((K0 = T32(K0 + 1)) == 0) {
75  			if ((K1 = T32(K1 + 1)) == 0)
76  				if ((K2 = T32(K2 + 1)) == 0)
77  					K3 = T32(K3 + 1);
78  		}
79  	}
80  	*pK0 = K0;
81  	*pK1 = K1;
82  	*pK2 = K2;
83  	*pK3 = K3;
84  }
85  #define BIG_SUB_WORDS   do { \
86  		aes_2rounds_all(W, &K0, &K1, &K2, &K3); \
87  	} while (0)
88  #else
89  #define AES_2ROUNDS(X)   do { \
90  		sph_u32 X0 = (sph_u32)(X[0]); \
91  		sph_u32 X1 = (sph_u32)(X[0] >> 32); \
92  		sph_u32 X2 = (sph_u32)(X[1]); \
93  		sph_u32 X3 = (sph_u32)(X[1] >> 32); \
94  		sph_u32 Y0, Y1, Y2, Y3; \
95  		AES_ROUND_LE(X0, X1, X2, X3, K0, K1, K2, K3, Y0, Y1, Y2, Y3); \
96  		AES_ROUND_NOKEY_LE(Y0, Y1, Y2, Y3, X0, X1, X2, X3); \
97  		X[0] = (sph_u64)X0 | ((sph_u64)X1 << 32); \
98  		X[1] = (sph_u64)X2 | ((sph_u64)X3 << 32); \
99  		if ((K0 = T32(K0 + 1)) == 0) { \
100  			if ((K1 = T32(K1 + 1)) == 0) \
101  				if ((K2 = T32(K2 + 1)) == 0) \
102  					K3 = T32(K3 + 1); \
103  		} \
104  	} while (0)
105  #define BIG_SUB_WORDS   do { \
106  		AES_2ROUNDS(W[ 0]); \
107  		AES_2ROUNDS(W[ 1]); \
108  		AES_2ROUNDS(W[ 2]); \
109  		AES_2ROUNDS(W[ 3]); \
110  		AES_2ROUNDS(W[ 4]); \
111  		AES_2ROUNDS(W[ 5]); \
112  		AES_2ROUNDS(W[ 6]); \
113  		AES_2ROUNDS(W[ 7]); \
114  		AES_2ROUNDS(W[ 8]); \
115  		AES_2ROUNDS(W[ 9]); \
116  		AES_2ROUNDS(W[10]); \
117  		AES_2ROUNDS(W[11]); \
118  		AES_2ROUNDS(W[12]); \
119  		AES_2ROUNDS(W[13]); \
120  		AES_2ROUNDS(W[14]); \
121  		AES_2ROUNDS(W[15]); \
122  	} while (0)
123  #endif
124  #define SHIFT_ROW1(a, b, c, d)   do { \
125  		sph_u64 tmp; \
126  		tmp = W[a][0]; \
127  		W[a][0] = W[b][0]; \
128  		W[b][0] = W[c][0]; \
129  		W[c][0] = W[d][0]; \
130  		W[d][0] = tmp; \
131  		tmp = W[a][1]; \
132  		W[a][1] = W[b][1]; \
133  		W[b][1] = W[c][1]; \
134  		W[c][1] = W[d][1]; \
135  		W[d][1] = tmp; \
136  	} while (0)
137  #define SHIFT_ROW2(a, b, c, d)   do { \
138  		sph_u64 tmp; \
139  		tmp = W[a][0]; \
140  		W[a][0] = W[c][0]; \
141  		W[c][0] = tmp; \
142  		tmp = W[b][0]; \
143  		W[b][0] = W[d][0]; \
144  		W[d][0] = tmp; \
145  		tmp = W[a][1]; \
146  		W[a][1] = W[c][1]; \
147  		W[c][1] = tmp; \
148  		tmp = W[b][1]; \
149  		W[b][1] = W[d][1]; \
150  		W[d][1] = tmp; \
151  	} while (0)
152  #define SHIFT_ROW3(a, b, c, d)   SHIFT_ROW1(d, c, b, a)
153  #define BIG_SHIFT_ROWS   do { \
154  		SHIFT_ROW1(1, 5, 9, 13); \
155  		SHIFT_ROW2(2, 6, 10, 14); \
156  		SHIFT_ROW3(3, 7, 11, 15); \
157  	} while (0)
158  #if SPH_SMALL_FOOTPRINT_ECHO
159  static void
160  mix_column(sph_u64 W[16][2], int ia, int ib, int ic, int id)
161  {
162  	int n;
163  	for (n = 0; n < 2; n ++) {
164  		sph_u64 a = W[ia][n];
165  		sph_u64 b = W[ib][n];
166  		sph_u64 c = W[ic][n];
167  		sph_u64 d = W[id][n];
168  		sph_u64 ab = a ^ b;
169  		sph_u64 bc = b ^ c;
170  		sph_u64 cd = c ^ d;
171  		sph_u64 abx = ((ab & C64(0x8080808080808080)) >> 7) * 27U
172  			^ ((ab & C64(0x7F7F7F7F7F7F7F7F)) << 1);
173  		sph_u64 bcx = ((bc & C64(0x8080808080808080)) >> 7) * 27U
174  			^ ((bc & C64(0x7F7F7F7F7F7F7F7F)) << 1);
175  		sph_u64 cdx = ((cd & C64(0x8080808080808080)) >> 7) * 27U
176  			^ ((cd & C64(0x7F7F7F7F7F7F7F7F)) << 1);
177  		W[ia][n] = abx ^ bc ^ d;
178  		W[ib][n] = bcx ^ a ^ cd;
179  		W[ic][n] = cdx ^ ab ^ d;
180  		W[id][n] = abx ^ bcx ^ cdx ^ ab ^ c;
181  	}
182  }
183  #define MIX_COLUMN(a, b, c, d)   mix_column(W, a, b, c, d)
184  #else
185  #define MIX_COLUMN1(ia, ib, ic, id, n)   do { \
186  		sph_u64 a = W[ia][n]; \
187  		sph_u64 b = W[ib][n]; \
188  		sph_u64 c = W[ic][n]; \
189  		sph_u64 d = W[id][n]; \
190  		sph_u64 ab = a ^ b; \
191  		sph_u64 bc = b ^ c; \
192  		sph_u64 cd = c ^ d; \
193  		sph_u64 abx = ((ab & C64(0x8080808080808080)) >> 7) * 27U \
194  			^ ((ab & C64(0x7F7F7F7F7F7F7F7F)) << 1); \
195  		sph_u64 bcx = ((bc & C64(0x8080808080808080)) >> 7) * 27U \
196  			^ ((bc & C64(0x7F7F7F7F7F7F7F7F)) << 1); \
197  		sph_u64 cdx = ((cd & C64(0x8080808080808080)) >> 7) * 27U \
198  			^ ((cd & C64(0x7F7F7F7F7F7F7F7F)) << 1); \
199  		W[ia][n] = abx ^ bc ^ d; \
200  		W[ib][n] = bcx ^ a ^ cd; \
201  		W[ic][n] = cdx ^ ab ^ d; \
202  		W[id][n] = abx ^ bcx ^ cdx ^ ab ^ c; \
203  	} while (0)
204  #define MIX_COLUMN(a, b, c, d)   do { \
205  		MIX_COLUMN1(a, b, c, d, 0); \
206  		MIX_COLUMN1(a, b, c, d, 1); \
207  	} while (0)
208  #endif
209  #define BIG_MIX_COLUMNS   do { \
210  		MIX_COLUMN(0, 1, 2, 3); \
211  		MIX_COLUMN(4, 5, 6, 7); \
212  		MIX_COLUMN(8, 9, 10, 11); \
213  		MIX_COLUMN(12, 13, 14, 15); \
214  	} while (0)
215  #define BIG_ROUND   do { \
216  		BIG_SUB_WORDS; \
217  		BIG_SHIFT_ROWS; \
218  		BIG_MIX_COLUMNS; \
219  	} while (0)
220  #define FINAL_SMALL   do { \
221  		unsigned u; \
222  		sph_u64 *VV = &sc->u.Vb[0][0]; \
223  		sph_u64 *WW = &W[0][0]; \
224  		for (u = 0; u < 8; u ++) { \
225  			VV[u] ^= sph_dec64le_aligned(sc->buf + (u * 8)) \
226  				^ sph_dec64le_aligned(sc->buf + (u * 8) + 64) \
227  				^ sph_dec64le_aligned(sc->buf + (u * 8) + 128) \
228  				^ WW[u] ^ WW[u + 8] \
229  				^ WW[u + 16] ^ WW[u + 24]; \
230  		} \
231  	} while (0)
232  #define FINAL_BIG   do { \
233  		unsigned u; \
234  		sph_u64 *VV = &sc->u.Vb[0][0]; \
235  		sph_u64 *WW = &W[0][0]; \
236  		for (u = 0; u < 16; u ++) { \
237  			VV[u] ^= sph_dec64le_aligned(sc->buf + (u * 8)) \
238  				^ WW[u] ^ WW[u + 16]; \
239  		} \
240  	} while (0)
241  #define COMPRESS_SMALL(sc)   do { \
242  		sph_u32 K0 = sc->C0; \
243  		sph_u32 K1 = sc->C1; \
244  		sph_u32 K2 = sc->C2; \
245  		sph_u32 K3 = sc->C3; \
246  		unsigned u; \
247  		INPUT_BLOCK_SMALL(sc); \
248  		for (u = 0; u < 8; u ++) { \
249  			BIG_ROUND; \
250  		} \
251  		FINAL_SMALL; \
252  	} while (0)
253  #define COMPRESS_BIG(sc)   do { \
254  		sph_u32 K0 = sc->C0; \
255  		sph_u32 K1 = sc->C1; \
256  		sph_u32 K2 = sc->C2; \
257  		sph_u32 K3 = sc->C3; \
258  		unsigned u; \
259  		INPUT_BLOCK_BIG(sc); \
260  		for (u = 0; u < 10; u ++) { \
261  			BIG_ROUND; \
262  		} \
263  		FINAL_BIG; \
264  	} while (0)
265  #else
266  #define DECL_STATE_SMALL   \
267  	sph_u32 W[16][4];
268  #define DECL_STATE_BIG   \
269  	sph_u32 W[16][4];
270  #define INPUT_BLOCK_SMALL(sc)   do { \
271  		unsigned u; \
272  		memcpy(W, sc->u.Vs, 16 * sizeof(sph_u32)); \
273  		for (u = 0; u < 12; u ++) { \
274  			W[u + 4][0] = sph_dec32le_aligned( \
275  				sc->buf + 16 * u); \
276  			W[u + 4][1] = sph_dec32le_aligned( \
277  				sc->buf + 16 * u + 4); \
278  			W[u + 4][2] = sph_dec32le_aligned( \
279  				sc->buf + 16 * u + 8); \
280  			W[u + 4][3] = sph_dec32le_aligned( \
281  				sc->buf + 16 * u + 12); \
282  		} \
283  	} while (0)
284  #define INPUT_BLOCK_BIG(sc)   do { \
285  		unsigned u; \
286  		memcpy(W, sc->u.Vs, 32 * sizeof(sph_u32)); \
287  		for (u = 0; u < 8; u ++) { \
288  			W[u + 8][0] = sph_dec32le_aligned( \
289  				sc->buf + 16 * u); \
290  			W[u + 8][1] = sph_dec32le_aligned( \
291  				sc->buf + 16 * u + 4); \
292  			W[u + 8][2] = sph_dec32le_aligned( \
293  				sc->buf + 16 * u + 8); \
294  			W[u + 8][3] = sph_dec32le_aligned( \
295  				sc->buf + 16 * u + 12); \
296  		} \
297  	} while (0)
298  #if SPH_SMALL_FOOTPRINT_ECHO
299  static void
300  aes_2rounds_all(sph_u32 W[16][4],
301  	sph_u32 *pK0, sph_u32 *pK1, sph_u32 *pK2, sph_u32 *pK3)
302  {
303  	int n;
304  	sph_u32 K0 = *pK0;
305  	sph_u32 K1 = *pK1;
306  	sph_u32 K2 = *pK2;
307  	sph_u32 K3 = *pK3;
308  	for (n = 0; n < 16; n ++) {
309  		sph_u32 *X = W[n];
310  		sph_u32 Y0, Y1, Y2, Y3;
311  		AES_ROUND_LE(X[0], X[1], X[2], X[3],
312  			K0, K1, K2, K3, Y0, Y1, Y2, Y3);
313  		AES_ROUND_NOKEY_LE(Y0, Y1, Y2, Y3, X[0], X[1], X[2], X[3]);
314  		if ((K0 = T32(K0 + 1)) == 0) {
315  			if ((K1 = T32(K1 + 1)) == 0)
316  				if ((K2 = T32(K2 + 1)) == 0)
317  					K3 = T32(K3 + 1);
318  		}
319  	}
320  	*pK0 = K0;
321  	*pK1 = K1;
322  	*pK2 = K2;
323  	*pK3 = K3;
324  }
325  #define BIG_SUB_WORDS   do { \
326  		aes_2rounds_all(W, &K0, &K1, &K2, &K3); \
327  	} while (0)
328  #else
329  #define AES_2ROUNDS(X)   do { \
330  		sph_u32 Y0, Y1, Y2, Y3; \
331  		AES_ROUND_LE(X[0], X[1], X[2], X[3], \
332  			K0, K1, K2, K3, Y0, Y1, Y2, Y3); \
333  		AES_ROUND_NOKEY_LE(Y0, Y1, Y2, Y3, X[0], X[1], X[2], X[3]); \
334  		if ((K0 = T32(K0 + 1)) == 0) { \
335  			if ((K1 = T32(K1 + 1)) == 0) \
336  				if ((K2 = T32(K2 + 1)) == 0) \
337  					K3 = T32(K3 + 1); \
338  		} \
339  	} while (0)
340  #define BIG_SUB_WORDS   do { \
341  		AES_2ROUNDS(W[ 0]); \
342  		AES_2ROUNDS(W[ 1]); \
343  		AES_2ROUNDS(W[ 2]); \
344  		AES_2ROUNDS(W[ 3]); \
345  		AES_2ROUNDS(W[ 4]); \
346  		AES_2ROUNDS(W[ 5]); \
347  		AES_2ROUNDS(W[ 6]); \
348  		AES_2ROUNDS(W[ 7]); \
349  		AES_2ROUNDS(W[ 8]); \
350  		AES_2ROUNDS(W[ 9]); \
351  		AES_2ROUNDS(W[10]); \
352  		AES_2ROUNDS(W[11]); \
353  		AES_2ROUNDS(W[12]); \
354  		AES_2ROUNDS(W[13]); \
355  		AES_2ROUNDS(W[14]); \
356  		AES_2ROUNDS(W[15]); \
357  	} while (0)
358  #endif
359  #define SHIFT_ROW1(a, b, c, d)   do { \
360  		sph_u32 tmp; \
361  		tmp = W[a][0]; \
362  		W[a][0] = W[b][0]; \
363  		W[b][0] = W[c][0]; \
364  		W[c][0] = W[d][0]; \
365  		W[d][0] = tmp; \
366  		tmp = W[a][1]; \
367  		W[a][1] = W[b][1]; \
368  		W[b][1] = W[c][1]; \
369  		W[c][1] = W[d][1]; \
370  		W[d][1] = tmp; \
371  		tmp = W[a][2]; \
372  		W[a][2] = W[b][2]; \
373  		W[b][2] = W[c][2]; \
374  		W[c][2] = W[d][2]; \
375  		W[d][2] = tmp; \
376  		tmp = W[a][3]; \
377  		W[a][3] = W[b][3]; \
378  		W[b][3] = W[c][3]; \
379  		W[c][3] = W[d][3]; \
380  		W[d][3] = tmp; \
381  	} while (0)
382  #define SHIFT_ROW2(a, b, c, d)   do { \
383  		sph_u32 tmp; \
384  		tmp = W[a][0]; \
385  		W[a][0] = W[c][0]; \
386  		W[c][0] = tmp; \
387  		tmp = W[b][0]; \
388  		W[b][0] = W[d][0]; \
389  		W[d][0] = tmp; \
390  		tmp = W[a][1]; \
391  		W[a][1] = W[c][1]; \
392  		W[c][1] = tmp; \
393  		tmp = W[b][1]; \
394  		W[b][1] = W[d][1]; \
395  		W[d][1] = tmp; \
396  		tmp = W[a][2]; \
397  		W[a][2] = W[c][2]; \
398  		W[c][2] = tmp; \
399  		tmp = W[b][2]; \
400  		W[b][2] = W[d][2]; \
401  		W[d][2] = tmp; \
402  		tmp = W[a][3]; \
403  		W[a][3] = W[c][3]; \
404  		W[c][3] = tmp; \
405  		tmp = W[b][3]; \
406  		W[b][3] = W[d][3]; \
407  		W[d][3] = tmp; \
408  	} while (0)
409  #define SHIFT_ROW3(a, b, c, d)   SHIFT_ROW1(d, c, b, a)
410  #define BIG_SHIFT_ROWS   do { \
411  		SHIFT_ROW1(1, 5, 9, 13); \
412  		SHIFT_ROW2(2, 6, 10, 14); \
413  		SHIFT_ROW3(3, 7, 11, 15); \
414  	} while (0)
415  #if SPH_SMALL_FOOTPRINT_ECHO
416  static void
417  mix_column(sph_u32 W[16][4], int ia, int ib, int ic, int id)
418  {
419  	int n;
420  	for (n = 0; n < 4; n ++) {
421  		sph_u32 a = W[ia][n];
422  		sph_u32 b = W[ib][n];
423  		sph_u32 c = W[ic][n];
424  		sph_u32 d = W[id][n];
425  		sph_u32 ab = a ^ b;
426  		sph_u32 bc = b ^ c;
427  		sph_u32 cd = c ^ d;
428  		sph_u32 abx = ((ab & C32(0x80808080)) >> 7) * 27U
429  			^ ((ab & C32(0x7F7F7F7F)) << 1);
430  		sph_u32 bcx = ((bc & C32(0x80808080)) >> 7) * 27U
431  			^ ((bc & C32(0x7F7F7F7F)) << 1);
432  		sph_u32 cdx = ((cd & C32(0x80808080)) >> 7) * 27U
433  			^ ((cd & C32(0x7F7F7F7F)) << 1);
434  		W[ia][n] = abx ^ bc ^ d;
435  		W[ib][n] = bcx ^ a ^ cd;
436  		W[ic][n] = cdx ^ ab ^ d;
437  		W[id][n] = abx ^ bcx ^ cdx ^ ab ^ c;
438  	}
439  }
440  #define MIX_COLUMN(a, b, c, d)   mix_column(W, a, b, c, d)
441  #else
442  #define MIX_COLUMN1(ia, ib, ic, id, n)   do { \
443  		sph_u32 a = W[ia][n]; \
444  		sph_u32 b = W[ib][n]; \
445  		sph_u32 c = W[ic][n]; \
446  		sph_u32 d = W[id][n]; \
447  		sph_u32 ab = a ^ b; \
448  		sph_u32 bc = b ^ c; \
449  		sph_u32 cd = c ^ d; \
450  		sph_u32 abx = ((ab & C32(0x80808080)) >> 7) * 27U \
451  			^ ((ab & C32(0x7F7F7F7F)) << 1); \
452  		sph_u32 bcx = ((bc & C32(0x80808080)) >> 7) * 27U \
453  			^ ((bc & C32(0x7F7F7F7F)) << 1); \
454  		sph_u32 cdx = ((cd & C32(0x80808080)) >> 7) * 27U \
455  			^ ((cd & C32(0x7F7F7F7F)) << 1); \
456  		W[ia][n] = abx ^ bc ^ d; \
457  		W[ib][n] = bcx ^ a ^ cd; \
458  		W[ic][n] = cdx ^ ab ^ d; \
459  		W[id][n] = abx ^ bcx ^ cdx ^ ab ^ c; \
460  	} while (0)
461  #define MIX_COLUMN(a, b, c, d)   do { \
462  		MIX_COLUMN1(a, b, c, d, 0); \
463  		MIX_COLUMN1(a, b, c, d, 1); \
464  		MIX_COLUMN1(a, b, c, d, 2); \
465  		MIX_COLUMN1(a, b, c, d, 3); \
466  	} while (0)
467  #endif
468  #define BIG_MIX_COLUMNS   do { \
469  		MIX_COLUMN(0, 1, 2, 3); \
470  		MIX_COLUMN(4, 5, 6, 7); \
471  		MIX_COLUMN(8, 9, 10, 11); \
472  		MIX_COLUMN(12, 13, 14, 15); \
473  	} while (0)
474  #define BIG_ROUND   do { \
475  		BIG_SUB_WORDS; \
476  		BIG_SHIFT_ROWS; \
477  		BIG_MIX_COLUMNS; \
478  	} while (0)
479  #define FINAL_SMALL   do { \
480  		unsigned u; \
481  		sph_u32 *VV = &sc->u.Vs[0][0]; \
482  		sph_u32 *WW = &W[0][0]; \
483  		for (u = 0; u < 16; u ++) { \
484  			VV[u] ^= sph_dec32le_aligned(sc->buf + (u * 4)) \
485  				^ sph_dec32le_aligned(sc->buf + (u * 4) + 64) \
486  				^ sph_dec32le_aligned(sc->buf + (u * 4) + 128) \
487  				^ WW[u] ^ WW[u + 16] \
488  				^ WW[u + 32] ^ WW[u + 48]; \
489  		} \
490  	} while (0)
491  #define FINAL_BIG   do { \
492  		unsigned u; \
493  		sph_u32 *VV = &sc->u.Vs[0][0]; \
494  		sph_u32 *WW = &W[0][0]; \
495  		for (u = 0; u < 32; u ++) { \
496  			VV[u] ^= sph_dec32le_aligned(sc->buf + (u * 4)) \
497  				^ WW[u] ^ WW[u + 32]; \
498  		} \
499  	} while (0)
500  #define COMPRESS_SMALL(sc)   do { \
501  		sph_u32 K0 = sc->C0; \
502  		sph_u32 K1 = sc->C1; \
503  		sph_u32 K2 = sc->C2; \
504  		sph_u32 K3 = sc->C3; \
505  		unsigned u; \
506  		INPUT_BLOCK_SMALL(sc); \
507  		for (u = 0; u < 8; u ++) { \
508  			BIG_ROUND; \
509  		} \
510  		FINAL_SMALL; \
511  	} while (0)
512  #define COMPRESS_BIG(sc)   do { \
513  		sph_u32 K0 = sc->C0; \
514  		sph_u32 K1 = sc->C1; \
515  		sph_u32 K2 = sc->C2; \
516  		sph_u32 K3 = sc->C3; \
517  		unsigned u; \
518  		INPUT_BLOCK_BIG(sc); \
519  		for (u = 0; u < 10; u ++) { \
520  			BIG_ROUND; \
521  		} \
522  		FINAL_BIG; \
523  	} while (0)
524  #endif
525  #define INCR_COUNTER(sc, val)   do { \
526  		sc->C0 = T32(sc->C0 + (sph_u32)(val)); \
527  		if (sc->C0 < (sph_u32)(val)) { \
528  			if ((sc->C1 = T32(sc->C1 + 1)) == 0) \
529  				if ((sc->C2 = T32(sc->C2 + 1)) == 0) \
530  					sc->C3 = T32(sc->C3 + 1); \
531  		} \
532  	} while (0)
533  static void
534  echo_small_init(sph_echo_small_context *sc, unsigned out_len)
535  {
536  #if SPH_ECHO_64
537  	sc->u.Vb[0][0] = (sph_u64)out_len;
538  	sc->u.Vb[0][1] = 0;
539  	sc->u.Vb[1][0] = (sph_u64)out_len;
540  	sc->u.Vb[1][1] = 0;
541  	sc->u.Vb[2][0] = (sph_u64)out_len;
542  	sc->u.Vb[2][1] = 0;
543  	sc->u.Vb[3][0] = (sph_u64)out_len;
544  	sc->u.Vb[3][1] = 0;
545  #else
546  	sc->u.Vs[0][0] = (sph_u32)out_len;
547  	sc->u.Vs[0][1] = sc->u.Vs[0][2] = sc->u.Vs[0][3] = 0;
548  	sc->u.Vs[1][0] = (sph_u32)out_len;
549  	sc->u.Vs[1][1] = sc->u.Vs[1][2] = sc->u.Vs[1][3] = 0;
550  	sc->u.Vs[2][0] = (sph_u32)out_len;
551  	sc->u.Vs[2][1] = sc->u.Vs[2][2] = sc->u.Vs[2][3] = 0;
552  	sc->u.Vs[3][0] = (sph_u32)out_len;
553  	sc->u.Vs[3][1] = sc->u.Vs[3][2] = sc->u.Vs[3][3] = 0;
554  #endif
555  	sc->ptr = 0;
556  	sc->C0 = sc->C1 = sc->C2 = sc->C3 = 0;
557  }
558  static void
559  echo_big_init(sph_echo_big_context *sc, unsigned out_len)
560  {
561  #if SPH_ECHO_64
562  	sc->u.Vb[0][0] = (sph_u64)out_len;
563  	sc->u.Vb[0][1] = 0;
564  	sc->u.Vb[1][0] = (sph_u64)out_len;
565  	sc->u.Vb[1][1] = 0;
566  	sc->u.Vb[2][0] = (sph_u64)out_len;
567  	sc->u.Vb[2][1] = 0;
568  	sc->u.Vb[3][0] = (sph_u64)out_len;
569  	sc->u.Vb[3][1] = 0;
570  	sc->u.Vb[4][0] = (sph_u64)out_len;
571  	sc->u.Vb[4][1] = 0;
572  	sc->u.Vb[5][0] = (sph_u64)out_len;
573  	sc->u.Vb[5][1] = 0;
574  	sc->u.Vb[6][0] = (sph_u64)out_len;
575  	sc->u.Vb[6][1] = 0;
576  	sc->u.Vb[7][0] = (sph_u64)out_len;
577  	sc->u.Vb[7][1] = 0;
578  #else
579  	sc->u.Vs[0][0] = (sph_u32)out_len;
580  	sc->u.Vs[0][1] = sc->u.Vs[0][2] = sc->u.Vs[0][3] = 0;
581  	sc->u.Vs[1][0] = (sph_u32)out_len;
582  	sc->u.Vs[1][1] = sc->u.Vs[1][2] = sc->u.Vs[1][3] = 0;
583  	sc->u.Vs[2][0] = (sph_u32)out_len;
584  	sc->u.Vs[2][1] = sc->u.Vs[2][2] = sc->u.Vs[2][3] = 0;
585  	sc->u.Vs[3][0] = (sph_u32)out_len;
586  	sc->u.Vs[3][1] = sc->u.Vs[3][2] = sc->u.Vs[3][3] = 0;
587  	sc->u.Vs[4][0] = (sph_u32)out_len;
588  	sc->u.Vs[4][1] = sc->u.Vs[4][2] = sc->u.Vs[4][3] = 0;
589  	sc->u.Vs[5][0] = (sph_u32)out_len;
590  	sc->u.Vs[5][1] = sc->u.Vs[5][2] = sc->u.Vs[5][3] = 0;
591  	sc->u.Vs[6][0] = (sph_u32)out_len;
592  	sc->u.Vs[6][1] = sc->u.Vs[6][2] = sc->u.Vs[6][3] = 0;
593  	sc->u.Vs[7][0] = (sph_u32)out_len;
594  	sc->u.Vs[7][1] = sc->u.Vs[7][2] = sc->u.Vs[7][3] = 0;
595  #endif
596  	sc->ptr = 0;
597  	sc->C0 = sc->C1 = sc->C2 = sc->C3 = 0;
598  }
599  static void
600  echo_small_compress(sph_echo_small_context *sc)
601  {
602  	DECL_STATE_SMALL
603  	COMPRESS_SMALL(sc);
604  }
605  static void
606  echo_big_compress(sph_echo_big_context *sc)
607  {
608  	DECL_STATE_BIG
609  	COMPRESS_BIG(sc);
610  }
611  static void
612  echo_small_core(sph_echo_small_context *sc,
613  	const unsigned char *data, size_t len)
614  {
615  	unsigned char *buf;
616  	size_t ptr;
617  	buf = sc->buf;
618  	ptr = sc->ptr;
619  	if (len < (sizeof sc->buf) - ptr) {
620  		memcpy(buf + ptr, data, len);
621  		ptr += len;
622  		sc->ptr = ptr;
623  		return;
624  	}
625  	while (len > 0) {
626  		size_t clen;
627  		clen = (sizeof sc->buf) - ptr;
628  		if (clen > len)
629  			clen = len;
630  		memcpy(buf + ptr, data, clen);
631  		ptr += clen;
632  		data += clen;
633  		len -= clen;
634  		if (ptr == sizeof sc->buf) {
635  			INCR_COUNTER(sc, 1536);
636  			echo_small_compress(sc);
637  			ptr = 0;
638  		}
639  	}
640  	sc->ptr = ptr;
641  }
642  static void
643  echo_big_core(sph_echo_big_context *sc,
644  	const unsigned char *data, size_t len)
645  {
646  	unsigned char *buf;
647  	size_t ptr;
648  	buf = sc->buf;
649  	ptr = sc->ptr;
650  	if (len < (sizeof sc->buf) - ptr) {
651  		memcpy(buf + ptr, data, len);
652  		ptr += len;
653  		sc->ptr = ptr;
654  		return;
655  	}
656  	while (len > 0) {
657  		size_t clen;
658  		clen = (sizeof sc->buf) - ptr;
659  		if (clen > len)
660  			clen = len;
661  		memcpy(buf + ptr, data, clen);
662  		ptr += clen;
663  		data += clen;
664  		len -= clen;
665  		if (ptr == sizeof sc->buf) {
666  			INCR_COUNTER(sc, 1024);
667  			echo_big_compress(sc);
668  			ptr = 0;
669  		}
670  	}
671  	sc->ptr = ptr;
672  }
673  static void
674  echo_small_close(sph_echo_small_context *sc, unsigned ub, unsigned n,
675  	void *dst, unsigned out_size_w32)
676  {
677  	unsigned char *buf;
678  	size_t ptr;
679  	unsigned z;
680  	unsigned elen;
681  	union {
682  		unsigned char tmp[32];
683  		sph_u32 dummy;
684  #if SPH_ECHO_64
685  		sph_u64 dummy2;
686  #endif
687  	} u;
688  #if SPH_ECHO_64
689  	sph_u64 *VV;
690  #else
691  	sph_u32 *VV;
692  #endif
693  	unsigned k;
694  	buf = sc->buf;
695  	ptr = sc->ptr;
696  	elen = ((unsigned)ptr << 3) + n;
697  	INCR_COUNTER(sc, elen);
698  	sph_enc32le_aligned(u.tmp, sc->C0);
699  	sph_enc32le_aligned(u.tmp + 4, sc->C1);
700  	sph_enc32le_aligned(u.tmp + 8, sc->C2);
701  	sph_enc32le_aligned(u.tmp + 12, sc->C3);
702  	if (elen == 0) {
703  		sc->C0 = sc->C1 = sc->C2 = sc->C3 = 0;
704  	}
705  	z = 0x80 >> n;
706  	buf[ptr ++] = ((ub & -z) | z) & 0xFF;
707  	memset(buf + ptr, 0, (sizeof sc->buf) - ptr);
708  	if (ptr > ((sizeof sc->buf) - 18)) {
709  		echo_small_compress(sc);
710  		sc->C0 = sc->C1 = sc->C2 = sc->C3 = 0;
711  		memset(buf, 0, sizeof sc->buf);
712  	}
713  	sph_enc16le(buf + (sizeof sc->buf) - 18, out_size_w32 << 5);
714  	memcpy(buf + (sizeof sc->buf) - 16, u.tmp, 16);
715  	echo_small_compress(sc);
716  #if SPH_ECHO_64
717  	for (VV = &sc->u.Vb[0][0], k = 0; k < ((out_size_w32 + 1) >> 1); k ++)
718  		sph_enc64le_aligned(u.tmp + (k << 3), VV[k]);
719  #else
720  	for (VV = &sc->u.Vs[0][0], k = 0; k < out_size_w32; k ++)
721  		sph_enc32le_aligned(u.tmp + (k << 2), VV[k]);
722  #endif
723  	memcpy(dst, u.tmp, out_size_w32 << 2);
724  	echo_small_init(sc, out_size_w32 << 5);
725  }
726  static void
727  echo_big_close(sph_echo_big_context *sc, unsigned ub, unsigned n,
728  	void *dst, unsigned out_size_w32)
729  {
730  	unsigned char *buf;
731  	size_t ptr;
732  	unsigned z;
733  	unsigned elen;
734  	union {
735  		unsigned char tmp[64];
736  		sph_u32 dummy;
737  #if SPH_ECHO_64
738  		sph_u64 dummy2;
739  #endif
740  	} u;
741  #if SPH_ECHO_64
742  	sph_u64 *VV;
743  #else
744  	sph_u32 *VV;
745  #endif
746  	unsigned k;
747  	buf = sc->buf;
748  	ptr = sc->ptr;
749  	elen = ((unsigned)ptr << 3) + n;
750  	INCR_COUNTER(sc, elen);
751  	sph_enc32le_aligned(u.tmp, sc->C0);
752  	sph_enc32le_aligned(u.tmp + 4, sc->C1);
753  	sph_enc32le_aligned(u.tmp + 8, sc->C2);
754  	sph_enc32le_aligned(u.tmp + 12, sc->C3);
755  	if (elen == 0) {
756  		sc->C0 = sc->C1 = sc->C2 = sc->C3 = 0;
757  	}
758  	z = 0x80 >> n;
759  	buf[ptr ++] = ((ub & -z) | z) & 0xFF;
760  	memset(buf + ptr, 0, (sizeof sc->buf) - ptr);
761  	if (ptr > ((sizeof sc->buf) - 18)) {
762  		echo_big_compress(sc);
763  		sc->C0 = sc->C1 = sc->C2 = sc->C3 = 0;
764  		memset(buf, 0, sizeof sc->buf);
765  	}
766  	sph_enc16le(buf + (sizeof sc->buf) - 18, out_size_w32 << 5);
767  	memcpy(buf + (sizeof sc->buf) - 16, u.tmp, 16);
768  	echo_big_compress(sc);
769  #if SPH_ECHO_64
770  	for (VV = &sc->u.Vb[0][0], k = 0; k < ((out_size_w32 + 1) >> 1); k ++)
771  		sph_enc64le_aligned(u.tmp + (k << 3), VV[k]);
772  #else
773  	for (VV = &sc->u.Vs[0][0], k = 0; k < out_size_w32; k ++)
774  		sph_enc32le_aligned(u.tmp + (k << 2), VV[k]);
775  #endif
776  	memcpy(dst, u.tmp, out_size_w32 << 2);
777  	echo_big_init(sc, out_size_w32 << 5);
778  }
779  void
780  sph_echo224_init(void *cc)
781  {
782  	echo_small_init(cc, 224);
783  }
784  void
785  sph_echo224(void *cc, const void *data, size_t len)
786  {
787  	echo_small_core(cc, data, len);
788  }
789  void
790  sph_echo224_close(void *cc, void *dst)
791  {
792  	echo_small_close(cc, 0, 0, dst, 7);
793  }
794  void
795  sph_echo224_addbits_and_close(void *cc, unsigned ub, unsigned n, void *dst)
796  {
797  	echo_small_close(cc, ub, n, dst, 7);
798  }
799  void
800  sph_echo256_init(void *cc)
801  {
802  	echo_small_init(cc, 256);
803  }
804  void
805  sph_echo256(void *cc, const void *data, size_t len)
806  {
807  	echo_small_core(cc, data, len);
808  }
809  void
810  sph_echo256_close(void *cc, void *dst)
811  {
812  	echo_small_close(cc, 0, 0, dst, 8);
813  }
814  void
815  sph_echo256_addbits_and_close(void *cc, unsigned ub, unsigned n, void *dst)
816  {
817  	echo_small_close(cc, ub, n, dst, 8);
818  }
819  void
820  sph_echo384_init(void *cc)
821  {
822  	echo_big_init(cc, 384);
823  }
824  void
825  sph_echo384(void *cc, const void *data, size_t len)
826  {
827  	echo_big_core(cc, data, len);
828  }
829  void
830  sph_echo384_close(void *cc, void *dst)
831  {
832  	echo_big_close(cc, 0, 0, dst, 12);
833  }
834  void
835  sph_echo384_addbits_and_close(void *cc, unsigned ub, unsigned n, void *dst)
836  {
837  	echo_big_close(cc, ub, n, dst, 12);
838  }
839  void
840  sph_echo512_init(void *cc)
841  {
842  	echo_big_init(cc, 512);
843  }
844  void
845  sph_echo512(void *cc, const void *data, size_t len)
846  {
847  	echo_big_core(cc, data, len);
848  }
849  void
850  sph_echo512_close(void *cc, void *dst)
851  {
852  	echo_big_close(cc, 0, 0, dst, 16);
853  }
854  void
855  sph_echo512_addbits_and_close(void *cc, unsigned ub, unsigned n, void *dst)
856  {
857  	echo_big_close(cc, ub, n, dst, 16);
858  }
859  #ifdef __cplusplus
860  }
861  #endif
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from xmrig-MDEwOlJlcG9zaXRvcnk4ODMyNzQwNg==-flat-xml.h</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from xmrig-MDEwOlJlcG9zaXRvcnk4ODMyNzQwNg==-flat-sph_echo.c</div>
                </div>
                <div class="column column_space"><pre><code>26    int (*get_content)(struct hwloc__xml_import_state_s * state, const char **beginp, size_t expected_length); &bsol;* return 0 on empty content (and sets beginp to empty string), 1 on actual content, -1 on error or unexpected content length */
27    void (*close_content)(struct hwloc__xml_import_state_s * state);
28    char * msgprefix;
29    void *data; &bsol;* libxml2 doc, or nolibxml buffer */
30    unsigned version_major, version_minor;
31    unsigned nbnumanodes;
32    hwloc_obj_t first_numanode, last_numanode; &bsol;* temporary cousin-list for handling v1distances */
</pre></code></div>
                <div class="column column_space"><pre><code>70  		AES_ROUND_LE(X0, X1, X2, X3, K0, K1, K2, K3, Y0, Y1, Y2, Y3);
71  		AES_ROUND_NOKEY_LE(Y0, Y1, Y2, Y3, X0, X1, X2, X3);
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    