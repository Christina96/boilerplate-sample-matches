
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 45.885885885885884%, Tokens: 9, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>libtomcrypt-MDEwOlJlcG9zaXRvcnk3NzcwMTE=-flat-tomcrypt_hash.h</h3>
            <pre><code>1  #if defined(LTC_SHA3) || defined(LTC_KECCAK)
2  struct sha3_state {
3      ulong64 saved;                  &bsol;* the portion of the input message that we didn't consume yet */
4      ulong64 s[25];
5      unsigned char sb[25 * 8];       &bsol;* used for storing `ulong64 s[25]` as little-endian bytes */
6      unsigned short byte_index;      &bsol;* 0..7--the next byte after the set one (starts from 0; 0--none are buffered) */
7      unsigned short word_index;      &bsol;* 0..24--the next word to integrate input (starts from 0) */
8      unsigned short capacity_words;  &bsol;* the double size of the hash output in words (e.g. 16 for Keccak 512) */
9      unsigned short xof_flag;
10  };
11  #endif
12  #ifdef LTC_SHA512
13  struct sha512_state {
14      ulong64  length, state[8];
15      unsigned long curlen;
16      unsigned char buf[128];
17  };
18  #endif
19  #ifdef LTC_SHA256
20  struct sha256_state {
21      ulong64 length;
22      ulong32 state[8], curlen;
23      unsigned char buf[64];
24  };
25  #endif
26  #ifdef LTC_SHA1
27  struct sha1_state {
28      ulong64 length;
29      ulong32 state[5], curlen;
30      unsigned char buf[64];
31  };
32  #endif
33  #ifdef LTC_MD5
34  struct md5_state {
35      ulong64 length;
36      ulong32 state[4], curlen;
37      unsigned char buf[64];
38  };
39  #endif
40  #ifdef LTC_MD4
41  struct md4_state {
42      ulong64 length;
43      ulong32 state[4], curlen;
44      unsigned char buf[64];
45  };
46  #endif
47  #ifdef LTC_TIGER
48  struct tiger_state {
49      ulong64 state[3], length;
50      unsigned long curlen;
51      unsigned char buf[64];
52  };
53  #endif
54  #ifdef LTC_MD2
55  struct md2_state {
56      unsigned char chksum[16], X[48], buf[16];
57      unsigned long curlen;
58  };
59  #endif
60  #ifdef LTC_RIPEMD128
61  struct rmd128_state {
62      ulong64 length;
63      unsigned char buf[64];
64      ulong32 curlen, state[4];
65  };
66  #endif
67  #ifdef LTC_RIPEMD160
68  struct rmd160_state {
69      ulong64 length;
70      unsigned char buf[64];
71      ulong32 curlen, state[5];
72  };
73  #endif
74  #ifdef LTC_RIPEMD256
75  struct rmd256_state {
76      ulong64 length;
77      unsigned char buf[64];
78      ulong32 curlen, state[8];
79  };
80  #endif
81  #ifdef LTC_RIPEMD320
82  struct rmd320_state {
83      ulong64 length;
84      unsigned char buf[64];
85      ulong32 curlen, state[10];
86  };
87  #endif
88  #ifdef LTC_WHIRLPOOL
89  struct whirlpool_state {
90      ulong64 length, state[8];
91      unsigned char buf[64];
92      ulong32 curlen;
93  };
94  #endif
95  #ifdef LTC_CHC_HASH
96  struct chc_state {
97      ulong64 length;
98      unsigned char state[MAXBLOCKSIZE], buf[MAXBLOCKSIZE];
99      ulong32 curlen;
100  };
101  #endif
102  #ifdef LTC_BLAKE2S
103  struct blake2s_state {
104      ulong32 h[8];
105      ulong32 t[2];
106      ulong32 f[2];
107      unsigned char buf[64];
108      unsigned long curlen;
109      unsigned long outlen;
110      unsigned char last_node;
111  };
112  #endif
113  #ifdef LTC_BLAKE2B
114  struct blake2b_state {
115      ulong64 h[8];
116      ulong64 t[2];
117      ulong64 f[2];
118      unsigned char buf[128];
119      unsigned long curlen;
120      unsigned long outlen;
121      unsigned char last_node;
122  };
123  #endif
124  typedef union Hash_state {
125      char dummy[1];
126  #ifdef LTC_CHC_HASH
127      struct chc_state chc;
128  #endif
129  #ifdef LTC_WHIRLPOOL
130      struct whirlpool_state whirlpool;
131  #endif
132  #if defined(LTC_SHA3) || defined(LTC_KECCAK)
133      struct sha3_state sha3;
134  #endif
135  #ifdef LTC_SHA512
136      struct sha512_state sha512;
137  #endif
138  #ifdef LTC_SHA256
139      struct sha256_state sha256;
140  #endif
141  #ifdef LTC_SHA1
142      struct sha1_state   sha1;
143  #endif
144  #ifdef LTC_MD5
145      struct md5_state    md5;
146  #endif
147  #ifdef LTC_MD4
148      struct md4_state    md4;
149  #endif
150  #ifdef LTC_MD2
151      struct md2_state    md2;
152  #endif
153  #ifdef LTC_TIGER
154      struct tiger_state  tiger;
155  #endif
156  #ifdef LTC_RIPEMD128
157      struct rmd128_state rmd128;
158  #endif
159  #ifdef LTC_RIPEMD160
160      struct rmd160_state rmd160;
161  #endif
162  #ifdef LTC_RIPEMD256
163      struct rmd256_state rmd256;
164  #endif
165  #ifdef LTC_RIPEMD320
166      struct rmd320_state rmd320;
167  #endif
168  #ifdef LTC_BLAKE2S
169      struct blake2s_state blake2s;
170  #endif
171  #ifdef LTC_BLAKE2B
172      struct blake2b_state blake2b;
173  #endif
174      void *data;
175  } hash_state;
176  extern  struct ltc_hash_descriptor {
177      const char *name;
178      unsigned char ID;
179      unsigned long hashsize;
180      unsigned long blocksize;
181      unsigned long OID[16];
182      unsigned long OIDlen;
183      int (*init)(hash_state *hash);
184      int (*process)(hash_state *hash, const unsigned char *in, unsigned long inlen);
185      int (*done)(hash_state *hash, unsigned char *out);
186      int (*test)(void);
187      int  (*hmac_block)(const unsigned char *key, unsigned long  keylen,
188                         const unsigned char *in,  unsigned long  inlen,
189                               unsigned char *out, unsigned long *outlen);
190  } hash_descriptor[];
191  #ifdef LTC_CHC_HASH
192  int chc_register(int cipher);
193  int chc_init(hash_state * md);
194  int chc_process(hash_state * md, const unsigned char *in, unsigned long inlen);
195  int chc_done(hash_state * md, unsigned char *out);
196  int chc_test(void);
197  extern const struct ltc_hash_descriptor chc_desc;
198  #endif
199  #ifdef LTC_WHIRLPOOL
200  int whirlpool_init(hash_state * md);
201  int whirlpool_process(hash_state * md, const unsigned char *in, unsigned long inlen);
202  int whirlpool_done(hash_state * md, unsigned char *out);
203  int whirlpool_test(void);
204  extern const struct ltc_hash_descriptor whirlpool_desc;
205  #endif
206  #if defined(LTC_SHA3) || defined(LTC_KECCAK)
207  int sha3_512_init(hash_state * md);
208  int sha3_384_init(hash_state * md);
209  int sha3_256_init(hash_state * md);
210  int sha3_224_init(hash_state * md);
211  int sha3_process(hash_state * md, const unsigned char *in, unsigned long inlen);
212  #endif
213  #ifdef LTC_SHA3
214  int sha3_512_test(void);
215  extern const struct ltc_hash_descriptor sha3_512_desc;
216  int sha3_384_test(void);
217  extern const struct ltc_hash_descriptor sha3_384_desc;
218  int sha3_256_test(void);
219  extern const struct ltc_hash_descriptor sha3_256_desc;
220  int sha3_224_test(void);
221  extern const struct ltc_hash_descriptor sha3_224_desc;
222  int sha3_done(hash_state *md, unsigned char *out);
223  int sha3_shake_init(hash_state *md, int num);
224  #define sha3_shake_process(a,b,c) sha3_process(a,b,c)
225  int sha3_shake_done(hash_state *md, unsigned char *out, unsigned long outlen);
226  int sha3_shake_test(void);
227  int sha3_shake_memory(int num, const unsigned char *in, unsigned long inlen, unsigned char *out, const unsigned long *outlen);
228  #endif
229  #ifdef LTC_KECCAK
230  #define keccak_512_init(a)    sha3_512_init(a)
231  #define keccak_384_init(a)    sha3_384_init(a)
232  #define keccak_256_init(a)    sha3_256_init(a)
233  #define keccak_224_init(a)    sha3_224_init(a)
234  #define keccak_process(a,b,c) sha3_process(a,b,c)
235  extern const struct ltc_hash_descriptor keccak_512_desc;
236  int keccak_512_test(void);
237  extern const struct ltc_hash_descriptor keccak_384_desc;
238  int keccak_384_test(void);
239  extern const struct ltc_hash_descriptor keccak_256_desc;
240  int keccak_256_test(void);
241  extern const struct ltc_hash_descriptor keccak_224_desc;
242  int keccak_224_test(void);
243  int keccak_done(hash_state *md, unsigned char *out);
244  #endif
245  #ifdef LTC_SHA512
246  int sha512_init(hash_state * md);
247  int sha512_process(hash_state * md, const unsigned char *in, unsigned long inlen);
248  int sha512_done(hash_state * md, unsigned char *out);
249  int sha512_test(void);
250  extern const struct ltc_hash_descriptor sha512_desc;
251  #endif
252  #ifdef LTC_SHA384
253  #ifndef LTC_SHA512
254     #error LTC_SHA512 is required for LTC_SHA384
255  #endif
256  int sha384_init(hash_state * md);
257  #define sha384_process sha512_process
258  int sha384_done(hash_state * md, unsigned char *out);
259  int sha384_test(void);
260  extern const struct ltc_hash_descriptor sha384_desc;
261  #endif
262  #ifdef LTC_SHA512_256
263  #ifndef LTC_SHA512
264     #error LTC_SHA512 is required for LTC_SHA512_256
265  #endif
266  int sha512_256_init(hash_state * md);
267  #define sha512_256_process sha512_process
268  int sha512_256_done(hash_state * md, unsigned char *out);
269  int sha512_256_test(void);
270  extern const struct ltc_hash_descriptor sha512_256_desc;
271  #endif
272  #ifdef LTC_SHA512_224
273  #ifndef LTC_SHA512
274     #error LTC_SHA512 is required for LTC_SHA512_224
275  #endif
276  int sha512_224_init(hash_state * md);
277  #define sha512_224_process sha512_process
278  int sha512_224_done(hash_state * md, unsigned char *out);
279  int sha512_224_test(void);
280  extern const struct ltc_hash_descriptor sha512_224_desc;
281  #endif
282  #ifdef LTC_SHA256
283  int sha256_init(hash_state * md);
284  int sha256_process(hash_state * md, const unsigned char *in, unsigned long inlen);
285  int sha256_done(hash_state * md, unsigned char *out);
286  int sha256_test(void);
287  extern const struct ltc_hash_descriptor sha256_desc;
288  #ifdef LTC_SHA224
289  #ifndef LTC_SHA256
290     #error LTC_SHA256 is required for LTC_SHA224
291  #endif
292  int sha224_init(hash_state * md);
293  #define sha224_process sha256_process
294  int sha224_done(hash_state * md, unsigned char *out);
295  int sha224_test(void);
296  extern const struct ltc_hash_descriptor sha224_desc;
297  #endif
298  #endif
299  #ifdef LTC_SHA1
300  int sha1_init(hash_state * md);
301  int sha1_process(hash_state * md, const unsigned char *in, unsigned long inlen);
302  int sha1_done(hash_state * md, unsigned char *out);
303  int sha1_test(void);
304  extern const struct ltc_hash_descriptor sha1_desc;
305  #endif
306  #ifdef LTC_BLAKE2S
307  extern const struct ltc_hash_descriptor blake2s_256_desc;
308  int blake2s_256_init(hash_state * md);
309  int blake2s_256_test(void);
310  extern const struct ltc_hash_descriptor blake2s_224_desc;
311  int blake2s_224_init(hash_state * md);
312  int blake2s_224_test(void);
313  extern const struct ltc_hash_descriptor blake2s_160_desc;
314  int blake2s_160_init(hash_state * md);
315  int blake2s_160_test(void);
316  extern const struct ltc_hash_descriptor blake2s_128_desc;
317  int blake2s_128_init(hash_state * md);
318  int blake2s_128_test(void);
319  int blake2s_init(hash_state * md, unsigned long outlen, const unsigned char *key, unsigned long keylen);
320  int blake2s_process(hash_state * md, const unsigned char *in, unsigned long inlen);
321  int blake2s_done(hash_state * md, unsigned char *out);
322  #endif
323  #ifdef LTC_BLAKE2B
324  extern const struct ltc_hash_descriptor blake2b_512_desc;
325  int blake2b_512_init(hash_state * md);
326  int blake2b_512_test(void);
327  extern const struct ltc_hash_descriptor blake2b_384_desc;
328  int blake2b_384_init(hash_state * md);
329  int blake2b_384_test(void);
330  extern const struct ltc_hash_descriptor blake2b_256_desc;
331  int blake2b_256_init(hash_state * md);
332  int blake2b_256_test(void);
333  extern const struct ltc_hash_descriptor blake2b_160_desc;
334  int blake2b_160_init(hash_state * md);
335  int blake2b_160_test(void);
336  int blake2b_init(hash_state * md, unsigned long outlen, const unsigned char *key, unsigned long keylen);
<span onclick='openModal()' class='match'>337  int blake2b_process(hash_state * md, const unsigned char *in, unsigned long inlen);
338  int blake2b_done(hash_state * md, unsigned char *out);
339  #endif
340  #ifdef LTC_MD5
341  int md5_init(hash_state * md);
342  int md5_process(hash_state * md, const unsigned char *in, unsigned long inlen);
343  int md5_done(hash_state * md, unsigned char *out);
</span>344  int md5_test(void);
345  extern const struct ltc_hash_descriptor md5_desc;
346  #endif
347  #ifdef LTC_MD4
348  int md4_init(hash_state * md);
349  int md4_process(hash_state * md, const unsigned char *in, unsigned long inlen);
350  int md4_done(hash_state * md, unsigned char *out);
351  int md4_test(void);
352  extern const struct ltc_hash_descriptor md4_desc;
353  #endif
354  #ifdef LTC_MD2
355  int md2_init(hash_state * md);
356  int md2_process(hash_state * md, const unsigned char *in, unsigned long inlen);
357  int md2_done(hash_state * md, unsigned char *out);
358  int md2_test(void);
359  extern const struct ltc_hash_descriptor md2_desc;
360  #endif
361  #ifdef LTC_TIGER
362  int tiger_init(hash_state * md);
363  int tiger_process(hash_state * md, const unsigned char *in, unsigned long inlen);
364  int tiger_done(hash_state * md, unsigned char *out);
365  int tiger_test(void);
366  extern const struct ltc_hash_descriptor tiger_desc;
367  #endif
368  #ifdef LTC_RIPEMD128
369  int rmd128_init(hash_state * md);
370  int rmd128_process(hash_state * md, const unsigned char *in, unsigned long inlen);
371  int rmd128_done(hash_state * md, unsigned char *out);
372  int rmd128_test(void);
373  extern const struct ltc_hash_descriptor rmd128_desc;
374  #endif
375  #ifdef LTC_RIPEMD160
376  int rmd160_init(hash_state * md);
377  int rmd160_process(hash_state * md, const unsigned char *in, unsigned long inlen);
378  int rmd160_done(hash_state * md, unsigned char *out);
379  int rmd160_test(void);
380  extern const struct ltc_hash_descriptor rmd160_desc;
381  #endif
382  #ifdef LTC_RIPEMD256
383  int rmd256_init(hash_state * md);
384  int rmd256_process(hash_state * md, const unsigned char *in, unsigned long inlen);
385  int rmd256_done(hash_state * md, unsigned char *out);
386  int rmd256_test(void);
387  extern const struct ltc_hash_descriptor rmd256_desc;
388  #endif
389  #ifdef LTC_RIPEMD320
390  int rmd320_init(hash_state * md);
391  int rmd320_process(hash_state * md, const unsigned char *in, unsigned long inlen);
392  int rmd320_done(hash_state * md, unsigned char *out);
393  int rmd320_test(void);
394  extern const struct ltc_hash_descriptor rmd320_desc;
395  #endif
396  int find_hash(const char *name);
397  int find_hash_id(unsigned char ID);
398  int find_hash_oid(const unsigned long *ID, unsigned long IDlen);
399  int find_hash_any(const char *name, int digestlen);
400  int register_hash(const struct ltc_hash_descriptor *hash);
401  int unregister_hash(const struct ltc_hash_descriptor *hash);
402  int register_all_hashes(void);
403  int hash_is_valid(int idx);
404  LTC_MUTEX_PROTO(ltc_hash_mutex)
405  int hash_memory(int hash,
406                  const unsigned char *in,  unsigned long inlen,
407                        unsigned char *out, unsigned long *outlen);
408  int hash_memory_multi(int hash, unsigned char *out, unsigned long *outlen,
409                        const unsigned char *in, unsigned long inlen, ...)
410                        LTC_NULL_TERMINATED;
411  #ifndef LTC_NO_FILE
412  int hash_filehandle(int hash, FILE *in, unsigned char *out, unsigned long *outlen);
413  int hash_file(int hash, const char *fname, unsigned char *out, unsigned long *outlen);
414  #endif
</code></pre>
        </div>
        <div class="column">
            <h3>xmrig-MDEwOlJlcG9zaXRvcnk4ODMyNzQwNg==-flat-adl_structures.h</h3>
            <pre><code>1  #ifndef ADL_STRUCTURES_H_
2  #define ADL_STRUCTURES_H_
3  #include "adl_defines.h"
4  typedef struct AdapterInfo
5  {
6      int iSize;
7      int iAdapterIndex;
8      char strUDID[ADL_MAX_PATH];
9      int iBusNumber;
10      int iDeviceNumber;
11      int iFunctionNumber;
12      int iVendorID;
13      char strAdapterName[ADL_MAX_PATH];
14      char strDisplayName[ADL_MAX_PATH];
15      int iPresent;
16  #if defined (_WIN32) || defined (_WIN64)
17      int iExist;
18      char strDriverPath[ADL_MAX_PATH];
19      char strDriverPathExt[ADL_MAX_PATH];
20      char strPNPString[ADL_MAX_PATH];
21      int iOSDisplayIndex;
22  #endif &bsol;* (_WIN32) || (_WIN64) */
23  #if defined (LINUX)
24      int iXScreenNum;
25      int iDrvIndex;
26      char strXScreenConfigName[ADL_MAX_PATH];
27  #endif &bsol;* (LINUX) */
28  } AdapterInfo, *LPAdapterInfo;
29  #if defined (LINUX)
30  typedef struct XScreenInfo
31  {
32      int iXScreenNum;
33      char strXScreenConfigName[ADL_MAX_PATH];
34  } XScreenInfo, *LPXScreenInfo;
35  #endif &bsol;* (LINUX) */
36  typedef struct ADLMemoryInfo
37  {
38      long long iMemorySize;
39      char strMemoryType[ADL_MAX_PATH];
40      long long iMemoryBandwidth;
41  } ADLMemoryInfo, *LPADLMemoryInfo;
42  typedef struct ADLMemoryRequired
43  {
44      long long iMemoryReq;        
45      int iType;                    
46      int iDisplayFeatureValue;   
47  } ADLMemoryRequired, *LPADLMemoryRequired;
48  typedef struct ADLMemoryDisplayFeatures
49  {
50      int iDisplayIndex;            
51      int iDisplayFeatureValue;    
52  } ADLMemoryDisplayFeatures, *LPADLMemoryDisplayFeatures;
53  typedef struct ADLDDCInfo
54  {
55      int  ulSize;
56      int  ulSupportsDDC;
57      int  ulManufacturerID;
58      int  ulProductID;
59      char cDisplayName[ADL_MAX_DISPLAY_NAME];
60      int  ulMaxHResolution;
61      int  ulMaxVResolution;
62      int  ulMaxRefresh;
63      int  ulPTMCx;
64      int  ulPTMCy;
65      int  ulPTMRefreshRate;
66      int  ulDDCInfoFlag;
67  } ADLDDCInfo, *LPADLDDCInfo;
68  typedef struct ADLDDCInfo2
69  {
70      int  ulSize;
71      int  ulSupportsDDC;
72      int  ulManufacturerID;
73      int  ulProductID;
74      char cDisplayName[ADL_MAX_DISPLAY_NAME];
75      int  ulMaxHResolution;
76      int  ulMaxVResolution;
77      int  ulMaxRefresh;
78      int  ulPTMCx;
79      int  ulPTMCy;
80      int  ulPTMRefreshRate;
81      int  ulDDCInfoFlag;
82      int bPackedPixelSupported;
83      int iPanelPixelFormat;
84      int  ulSerialID;
85      int ulMinLuminanceData;
86      int ulAvgLuminanceData;
87      int ulMaxLuminanceData;
88      int iSupportedTransferFunction;
89      int iSupportedColorSpace;
90      int iNativeDisplayChromaticityRedX;
91      int iNativeDisplayChromaticityRedY;
92      int iNativeDisplayChromaticityGreenX;
93      int iNativeDisplayChromaticityGreenY;
94      int iNativeDisplayChromaticityBlueX;
95      int iNativeDisplayChromaticityBlueY;
96      int iNativeDisplayChromaticityWhitePointX;
97      int iNativeDisplayChromaticityWhitePointY;
98      int iDiffuseScreenReflectance;
99      int iSpecularScreenReflectance;
100      int iSupportedHDR;
101      int iFreesyncFlags;
102      int ulMinLuminanceNoDimmingData;
103      int ulMaxBacklightMaxLuminanceData;
104      int ulMinBacklightMaxLuminanceData;
105      int ulMaxBacklightMinLuminanceData;
106      int ulMinBacklightMinLuminanceData;
107      int iReserved[4];
108  } ADLDDCInfo2, *LPADLDDCInfo2;
109  typedef struct ADLGamma
110  {
111      float fRed;
112      float fGreen;
113      float fBlue;
114  } ADLGamma, *LPADLGamma;
115  typedef struct ADLCustomMode
116  {
117      int iFlags;
118      int iModeWidth;
119      int iModeHeight;
120      int iBaseModeWidth;
121      int iBaseModeHeight;
122      int iRefreshRate;
123  } ADLCustomMode, *LPADLCustomMode;
124  typedef struct ADLGetClocksOUT
125  {
126      long ulHighCoreClock;
127      long ulHighMemoryClock;
128      long ulHighVddc;
129      long ulCoreMin;
130      long ulCoreMax;
131      long ulMemoryMin;
132      long ulMemoryMax;
133      long ulActivityPercent;
134      long ulCurrentCoreClock;
135      long ulCurrentMemoryClock;
136      long ulReserved;
137  } ADLGetClocksOUT;
138  typedef struct ADLDisplayConfig
139  {
140    long ulSize;
141    long ulConnectorType;
142    long ulDeviceData;
143    long ulOverridedDeviceData;
144    long ulReserved;
145  } ADLDisplayConfig;
146  typedef struct ADLDisplayID
147  {
148      int iDisplayLogicalIndex;
149      int iDisplayPhysicalIndex;
150      int iDisplayLogicalAdapterIndex;
151      int iDisplayPhysicalAdapterIndex;
152  } ADLDisplayID, *LPADLDisplayID;
153  typedef struct ADLDisplayInfo
154  {
155      ADLDisplayID displayID;
156      int  iDisplayControllerIndex;
157      char strDisplayName[ADL_MAX_PATH];
158      char strDisplayManufacturerName[ADL_MAX_PATH];
159      int  iDisplayType;
160      int  iDisplayOutputType;
161      int  iDisplayConnector;
162      int  iDisplayInfoMask;
163      int  iDisplayInfoValue;
164  } ADLDisplayInfo, *LPADLDisplayInfo;
165  typedef struct ADLDisplayDPMSTInfo
166  {
167      ADLDisplayID displayID;
168      int    iTotalAvailableBandwidthInMpbs;
169      int    iAllocatedBandwidthInMbps;
170      char    strGlobalUniqueIdentifier[ADL_MAX_PATH];
171      int        radLinkCount;
172      int        iPhysicalConnectorID;
173      char    rad[ADL_MAX_RAD_LINK_COUNT];
174  } ADLDisplayDPMSTInfo, *LPADLDisplayDPMSTInfo;
175  typedef struct ADLDisplayMode
176  {
177     int  iPelsHeight;
178     int  iPelsWidth;
179     int  iBitsPerPel;
180     int  iDisplayFrequency;
181  } ADLDisplayMode;
182  typedef struct ADLDetailedTiming
183  {
184       int   iSize;
185       short sTimingFlags;
186       short sHTotal;
187       short sHDisplay;
188       short sHSyncStart;
189       short sHSyncWidth;
190       short sVTotal;
191       short sVDisplay;
192       short sVSyncStart;
193       short sVSyncWidth;
194       short sPixelClock;
195       short sHOverscanRight;
196       short sHOverscanLeft;
197       short sVOverscanBottom;
198       short sVOverscanTop;
199       short sOverscan8B;
200       short sOverscanGR;
201  } ADLDetailedTiming;
202  typedef struct ADLDisplayModeInfo
203  {
204    int  iTimingStandard;
205    int  iPossibleStandard;
206    int  iRefreshRate;
207    int  iPelsWidth;
208    int  iPelsHeight;
209    ADLDetailedTiming  sDetailedTiming;
210  } ADLDisplayModeInfo;
211  typedef struct ADLDisplayProperty
212  {
213    int iSize;
214    int iPropertyType;
215    int iExpansionMode;
216    int iSupport;
217    int iCurrent;
218    int iDefault;
219  } ADLDisplayProperty;
220  typedef struct ADLClockInfo
221  {
222      int iCoreClock;
223      int iMemoryClock;
224  } ADLClockInfo, *LPADLClockInfo;
225  typedef struct ADLI2C
226  {
227      int iSize;
228      int iLine;
229      int iAddress;
230      int iOffset;
231      int iAction;
232      int iSpeed;
233      int iDataSize;
234      char *pcData;
235  } ADLI2C;
236  typedef struct ADLDisplayEDIDData
237  {
238    int iSize;
239    int iFlag;
240    int iEDIDSize;
241    int iBlockIndex;
242    char cEDIDData[ADL_MAX_EDIDDATA_SIZE];
243    int iReserved[4];
244  }ADLDisplayEDIDData;
245  typedef struct ADLControllerOverlayInput
246  {
247    int  iSize;
248    int  iOverlayAdjust;
249    int  iValue;
250    int  iReserved;
251  } ADLControllerOverlayInput;
252  typedef struct ADLAdjustmentinfo
253  {
254    int iDefault;
255    int iMin;
256    int iMax;
257    int iStep;
258  } ADLAdjustmentinfo;
259  typedef struct ADLControllerOverlayInfo
260  {
261    int                    iSize;
262    ADLAdjustmentinfo        sOverlayInfo;
263    int                    iReserved[3];
264  } ADLControllerOverlayInfo;
265  typedef struct ADLGLSyncModuleID
266  {
267      int        iModuleID;
268      int        iGlSyncGPUPort;
269      int        iFWBootSectorVersion;
270      int        iFWUserSectorVersion;
271  } ADLGLSyncModuleID , *LPADLGLSyncModuleID;
272  typedef struct ADLGLSyncPortCaps
273  {
274      int        iPortType;
275      int        iNumOfLEDs;
276  }ADLGLSyncPortCaps, *LPADLGLSyncPortCaps;
277  typedef struct ADLGLSyncGenlockConfig
278  {
279      int        iValidMask;
280      int        iSyncDelay;
281      int        iFramelockCntlVector;
282      int        iSignalSource;
283      int        iSampleRate;
284      int        iSyncField;
285      int        iTriggerEdge;
286      int        iScanRateCoeff;
287  }ADLGLSyncGenlockConfig, *LPADLGLSyncGenlockConfig;
288  typedef struct ADLGlSyncPortInfo
289  {
290      int        iPortType;
291      int        iNumOfLEDs;
292      int        iPortState;
293      int        iFrequency;
294      int        iSignalType;
295      int        iSignalSource;
296  } ADLGlSyncPortInfo, *LPADLGlSyncPortInfo;
297  typedef struct ADLGlSyncPortControl
298  {
299      int        iPortType;
300      int        iControlVector;
301      int        iSignalSource;
302  } ADLGlSyncPortControl;
303  typedef struct ADLGlSyncMode
304  {
305      int        iControlVector;
306      int        iStatusVector;
307      int        iGLSyncConnectorIndex;
308  } ADLGlSyncMode, *LPADLGlSyncMode;
309  typedef struct ADLGlSyncMode2
310  {
311      int        iControlVector;
312      int        iStatusVector;
313      int        iGLSyncConnectorIndex;
314      int        iDisplayIndex;
315  } ADLGlSyncMode2, *LPADLGlSyncMode2;
316  typedef struct  ADLInfoPacket
317  {
318      char hb0;
319      char hb1;
320      char hb2;
321      char sb[28];
322  }ADLInfoPacket;
323  typedef struct ADLAVIInfoPacket  
324  {
325     char bPB3_ITC;
326     char bPB5;
327  }ADLAVIInfoPacket;
328  typedef struct ADLODClockSetting
329  {
330      int iDefaultClock;
331      int iCurrentClock;
332      int iMaxClock;
333      int iMinClock;
334      int iRequestedClock;
335      int iStepClock;
336  } ADLODClockSetting;
337  typedef struct ADLAdapterODClockInfo
338  {
339      int iSize;
340      int iFlags;
341      ADLODClockSetting sMemoryClock;
342      ADLODClockSetting sEngineClock;
343  } ADLAdapterODClockInfo;
344  typedef struct ADLAdapterODClockConfig
345  {
346    int iSize;
347    int iFlags;
348    int iMemoryClock;
349    int iEngineClock;
350  } ADLAdapterODClockConfig;
351  typedef struct ADLPMActivity
352  {
353      int iSize;
354      int iEngineClock;
355      int iMemoryClock;
356      int iVddc;
357      int iActivityPercent;
358      int iCurrentPerformanceLevel;
359      int iCurrentBusSpeed;
360      int iCurrentBusLanes;
361      int iMaximumBusLanes;
362      int iReserved;
363  } ADLPMActivity;
364  typedef struct ADLThermalControllerInfo
365  {
366    int iSize;
367    int iThermalDomain;
368    int iDomainIndex;
369    int iFlags;
370  } ADLThermalControllerInfo;
371  typedef struct ADLTemperature
372  {
373    int iSize;
374    int iTemperature;
375  } ADLTemperature;
376  typedef struct ADLFanSpeedInfo
377  {
378    int iSize;
379    int iFlags;
380    int iMinPercent;
381    int iMaxPercent;
382    int iMinRPM;
383    int iMaxRPM;
384  } ADLFanSpeedInfo;
385  typedef struct ADLFanSpeedValue
386  {
387    int iSize;
388    int iSpeedType;
389    int iFanSpeed;
390    int iFlags;
391  } ADLFanSpeedValue;
392  typedef struct ADLODParameterRange
393  {
394    int iMin;
395    int iMax;
396    int iStep;
397  } ADLODParameterRange;
398  typedef struct ADLODParameters
399  {
400    int iSize;
401    int iNumberOfPerformanceLevels;
402    int iActivityReportingSupported;
403    int iDiscretePerformanceLevels;
404    int iReserved;
405    ADLODParameterRange sEngineClock;
406    ADLODParameterRange sMemoryClock;
407    ADLODParameterRange sVddc;
408  } ADLODParameters;
409  typedef struct ADLODPerformanceLevel
410  {
411    int iEngineClock;
412    int iMemoryClock;
413    int iVddc;
414  } ADLODPerformanceLevel;
415  typedef struct ADLODPerformanceLevels
416  {
417    int iSize;
418    int iReserved;
419    ADLODPerformanceLevel aLevels [1];
420  } ADLODPerformanceLevels;
421  typedef struct ADLCrossfireComb
422  {
423    int iNumLinkAdapter;
424    int iAdaptLink[3];
425  } ADLCrossfireComb;
426  typedef struct ADLCrossfireInfo
427  {
428    int iErrorCode;
429    int iState;
430    int iSupported;
431  } ADLCrossfireInfo;
432  typedef struct ADLBiosInfo
433  {
434      char strPartNumber[ADL_MAX_PATH];    
435      char strVersion[ADL_MAX_PATH];        
436      char strDate[ADL_MAX_PATH];        
437  } ADLBiosInfo, *LPADLBiosInfo;
438  typedef struct ADLAdapterLocation
439  {
440      int iBus;
441      int iDevice;
442      int iFunction;
443  } ADLAdapterLocation,ADLBdf;
444  typedef struct ADLVersionsInfo
445  {
446      char strDriverVer[ADL_MAX_PATH];
447      char strCatalystVersion[ADL_MAX_PATH];
448      char strCatalystWebLink[ADL_MAX_PATH];
449  } ADLVersionsInfo, *LPADLVersionsInfo;
450  typedef struct ADLVersionsInfoX2
451  {
452      char strDriverVer[ADL_MAX_PATH];
453      char strCatalystVersion[ADL_MAX_PATH];
454      char strCrimsonVersion[ADL_MAX_PATH];
455      char strCatalystWebLink[ADL_MAX_PATH];
456  } ADLVersionsInfoX2, *LPADLVersionsInfoX2;
457  typedef struct ADLMVPUCaps
458  {
459    int iSize;
460    int iAdapterCount;
461    int iPossibleMVPUMasters;
462    int iPossibleMVPUSlaves;
463    char cAdapterPath[ADL_DL_MAX_MVPU_ADAPTERS][ADL_DL_MAX_REGISTRY_PATH];
464  } ADLMVPUCaps;
465  typedef struct ADLMVPUStatus
466  {
467    int iSize;
468    int iActiveAdapterCount;
469    int iStatus;
470    ADLAdapterLocation aAdapterLocation[ADL_DL_MAX_MVPU_ADAPTERS];
471  } ADLMVPUStatus;
472  typedef struct ADLActivatableSource
473  {
474      int iAdapterIndex;
475      int iNumActivatableSources;
476      int iActivatableSourceMask;
477      int iActivatableSourceValue;
478  } ADLActivatableSource, *LPADLActivatableSource;
479  typedef struct ADLMode
480  {
481      int iAdapterIndex;
482      ADLDisplayID displayID;
483      int iXPos;
484      int iYPos;
485      int iXRes;
486      int iYRes;
487      int iColourDepth;
488      float fRefreshRate;
489      int iOrientation;
490      int iModeFlag;
491      int iModeMask;
492      int iModeValue;
493  } ADLMode, *LPADLMode;
494  typedef struct ADLDisplayTarget
495  {
496      ADLDisplayID displayID;
497      int iDisplayMapIndex;
498      int  iDisplayTargetMask;
499      int  iDisplayTargetValue;
500  } ADLDisplayTarget, *LPADLDisplayTarget;
501  typedef struct tagADLBezelTransientMode
502  {
503      int iAdapterIndex;
504      int iSLSMapIndex;
505      int iSLSModeIndex;
506      ADLMode displayMode;
507      int  iNumBezelOffset;
508      int  iFirstBezelOffsetArrayIndex;
509      int  iSLSBezelTransientModeMask;
510      int  iSLSBezelTransientModeValue;
511  } ADLBezelTransientMode, *LPADLBezelTransientMode;
512  typedef struct ADLAdapterDisplayCap
513  {
514      int iAdapterIndex;
515      int  iAdapterDisplayCapMask;
516      int  iAdapterDisplayCapValue;
517  } ADLAdapterDisplayCap, *LPADLAdapterDisplayCap;
518  typedef struct ADLDisplayMap
519  {
520      int iDisplayMapIndex;
521      ADLMode displayMode;
522      int iNumDisplayTarget;
523      int iFirstDisplayTargetArrayIndex;
524       int  iDisplayMapMask;
525      int  iDisplayMapValue;
526  } ADLDisplayMap, *LPADLDisplayMap;
527  typedef struct ADLPossibleMap
528  {
529      int iIndex;
530      int iAdapterIndex;
531      int iNumDisplayMap;
532      ADLDisplayMap* displayMap;
533      int iNumDisplayTarget;
534      ADLDisplayTarget* displayTarget;
535  } ADLPossibleMap, *LPADLPossibleMap;
536  typedef struct ADLPossibleMapping
537  {
538      int iDisplayIndex;                
539      int iDisplayControllerIndex;    
540      int iDisplayMannerSupported;    
541  } ADLPossibleMapping, *LPADLPossibleMapping;
542  typedef struct ADLPossibleMapResult
543  {
544      int iIndex;
545      int iPossibleMapResultMask;
546      int iPossibleMapResultValue;
547  } ADLPossibleMapResult, *LPADLPossibleMapResult;
548  typedef struct ADLSLSGrid
549  {
550      int iAdapterIndex;
551      int  iSLSGridIndex;
552      int  iSLSGridRow;
553      int  iSLSGridColumn;
554      int  iSLSGridMask;
555      int  iSLSGridValue;
556  } ADLSLSGrid, *LPADLSLSGrid;
557  typedef struct    ADLSLSMap
558  {
559      int iAdapterIndex;
560      int iSLSMapIndex;
561      ADLSLSGrid grid;
562      int  iSurfaceMapIndex;
563       int iOrientation;
564      int  iNumSLSTarget;
565      int  iFirstSLSTargetArrayIndex;
566      int  iNumNativeMode;
567      int  iFirstNativeModeArrayIndex;
568      int  iNumBezelMode;
569      int  iFirstBezelModeArrayIndex;
570      int  iNumBezelOffset;
571      int  iFirstBezelOffsetArrayIndex;
572      int  iSLSMapMask;
573      int  iSLSMapValue;
574  } ADLSLSMap, *LPADLSLSMap;
575  typedef struct ADLSLSOffset
576  {
577      int iAdapterIndex;
578      int iSLSMapIndex;
579      ADLDisplayID displayID;
580      int iBezelModeIndex;
581      int iBezelOffsetX;
582      int iBezelOffsetY;
583      int iDisplayWidth;
584      int iDisplayHeight;
585      int iBezelOffsetMask;
586      int  iBezelffsetValue;
587  } ADLSLSOffset, *LPADLSLSOffset;
588  typedef struct ADLSLSMode
589  {
590      int iAdapterIndex;
591      int iSLSMapIndex;
592      int iSLSModeIndex;
593      ADLMode displayMode;
594      int iSLSNativeModeMask;
595      int iSLSNativeModeValue;
596  } ADLSLSMode, *LPADLSLSMode;
597  typedef struct ADLPossibleSLSMap
598  {
599      int iSLSMapIndex;
600      int iNumSLSMap;
601      ADLSLSMap* lpSLSMap;
602      int iNumSLSTarget;
603      ADLDisplayTarget* lpDisplayTarget;
604  } ADLPossibleSLSMap, *LPADLPossibleSLSMap;
605  typedef struct ADLSLSTarget
606  {
607      int iAdapterIndex;
608      int iSLSMapIndex;
609      ADLDisplayTarget displayTarget;
610      int iSLSGridPositionX;
611      int iSLSGridPositionY;
612      ADLMode viewSize;
613      int iSLSTargetMask;
614      int iSLSTargetValue;
615  } ADLSLSTarget, *LPADLSLSTarget;
616  typedef struct ADLBezelOffsetSteppingSize
617  {
618      int iAdapterIndex;
619      int iSLSMapIndex;
620      int iBezelOffsetSteppingSizeX;
621      int iBezelOffsetSteppingSizeY;
622      int iBezelOffsetSteppingSizeMask;
623      int iBezelOffsetSteppingSizeValue;
624  } ADLBezelOffsetSteppingSize, *LPADLBezelOffsetSteppingSize;
625  typedef struct ADLSLSOverlappedMode
626  {
627      ADLMode SLSMode;
628      int iNumSLSTarget;
629      int iFirstTargetArrayIndex;
630  }ADLSLSTargetOverlap, *LPADLSLSTargetOverlap;
631  typedef struct ADLPXConfigCaps
632  {
633      int iAdapterIndex;
634      int  iPXConfigCapMask;
635      int  iPXConfigCapValue;
636  } ADLPXConfigCaps, *LPADLPXConfigCaps;
637  enum ADLPxType
638  {
639  	ADL_PX_NONE = 0,
640  	ADL_SWITCHABLE_AMDAMD = 1,
641  	ADL_HG_AMDAMD = 2,
642  	ADL_SWITCHABLE_AMDOTHER = 3,
643  	ADL_HG_AMDOTHER = 4,
644  };
645  typedef struct _ADLApplicationData
646  {
647      char strPathName[ADL_MAX_PATH];
648      char strFileName[ADL_APP_PROFILE_FILENAME_LENGTH];
649      char strTimeStamp[ADL_APP_PROFILE_TIMESTAMP_LENGTH];
650      char strVersion[ADL_APP_PROFILE_VERSION_LENGTH];
651  }ADLApplicationData;
652  typedef struct _ADLApplicationDataX2
653  {
654      wchar_t strPathName[ADL_MAX_PATH];
655      wchar_t strFileName[ADL_APP_PROFILE_FILENAME_LENGTH];
656      wchar_t strTimeStamp[ADL_APP_PROFILE_TIMESTAMP_LENGTH];
657      wchar_t strVersion[ADL_APP_PROFILE_VERSION_LENGTH];
658  }ADLApplicationDataX2;
659  typedef struct _ADLApplicationDataX3
660  {
661      wchar_t strPathName[ADL_MAX_PATH];
662      wchar_t strFileName[ADL_APP_PROFILE_FILENAME_LENGTH];
663      wchar_t strTimeStamp[ADL_APP_PROFILE_TIMESTAMP_LENGTH];
664      wchar_t strVersion[ADL_APP_PROFILE_VERSION_LENGTH];
665      unsigned int iProcessId;
666  }ADLApplicationDataX3;
667  typedef struct _PropertyRecord
668  {
669      char strName [ADL_APP_PROFILE_PROPERTY_LENGTH];
670      ADLProfilePropertyType eType;
671      int iDataSize;
672      unsigned char uData[1];
673  }PropertyRecord;
674  typedef struct _ADLApplicationProfile
675  {
676      int iCount;
677      PropertyRecord record[1];
678  }ADLApplicationProfile;
679  typedef struct ADLPowerControlInfo
680  {
681  int iMinValue;
682  int iMaxValue;
683  int iStepValue;
684   } ADLPowerControlInfo;
685  typedef struct _ADLControllerMode
686  {
<span onclick='openModal()' class='match'>687      int iModifiers;
688      int iViewPositionCx;
689      int iViewPositionCy;
690      int iViewPanLockLeft;
691      int iViewPanLockRight;
692      int iViewPanLockTop;
693      int iViewPanLockBottom;
694      int iViewResolutionCx;
695      int iViewResolutionCy;
</span>696  }ADLControllerMode;
697  typedef struct ADLDisplayIdentifier
698  {
699      long ulDisplayIndex;
700      long ulManufacturerId;
701      long ulProductId;
702      long ulSerialNo;
703  } ADLDisplayIdentifier;
704  typedef struct _ADLOD6ParameterRange
705  {
706      int     iMin;
707      int     iMax;
708      int     iStep;
709  } ADLOD6ParameterRange;
710  typedef struct _ADLOD6Capabilities
711  {
712      int     iCapabilities;
713      int     iSupportedStates;
714      int     iNumberOfPerformanceLevels;
715      ADLOD6ParameterRange     sEngineClockRange;
716      ADLOD6ParameterRange     sMemoryClockRange;
717      int     iExtValue;
718      int     iExtMask;
719  } ADLOD6Capabilities;
720  typedef struct _ADLOD6PerformanceLevel
721  {
722      int iEngineClock;
723      int iMemoryClock;
724  } ADLOD6PerformanceLevel;
725  typedef struct _ADLOD6StateInfo
726  {
727      int     iNumberOfPerformanceLevels;
728      int     iExtValue;
729      int     iExtMask;
730      ADLOD6PerformanceLevel aLevels [1];
731  } ADLOD6StateInfo;
732  typedef struct _ADLOD6CurrentStatus
733  {
734      int     iEngineClock;
735      int     iMemoryClock;
736      int     iActivityPercent;
737      int     iCurrentPerformanceLevel;
738      int     iCurrentBusSpeed;
739      int     iCurrentBusLanes;
740      int     iMaximumBusLanes;
741      int     iExtValue;
742      int     iExtMask;
743  } ADLOD6CurrentStatus;
744  typedef struct _ADLOD6ThermalControllerCaps
745  {
746      int     iCapabilities;
747      int     iFanMinPercent;
748      int     iFanMaxPercent;
749      int     iFanMinRPM;
750      int     iFanMaxRPM;
751      int     iExtValue;
752      int     iExtMask;
753  } ADLOD6ThermalControllerCaps;
754  typedef struct _ADLOD6FanSpeedInfo
755  {
756      int     iSpeedType;
757      int     iFanSpeedPercent;
758      int        iFanSpeedRPM;
759      int     iExtValue;
760      int     iExtMask;
761  } ADLOD6FanSpeedInfo;
762  typedef struct _ADLOD6FanSpeedValue
763  {
764      int     iSpeedType;
765      int     iFanSpeed;
766      int     iExtValue;
767      int     iExtMask;
768  } ADLOD6FanSpeedValue;
769  typedef struct _ADLOD6PowerControlInfo
770  {
771      int     iMinValue;
772      int     iMaxValue;
773      int     iStepValue;
774      int     iExtValue;
775      int     iExtMask;
776  } ADLOD6PowerControlInfo;
777  typedef struct _ADLOD6VoltageControlInfo
778  {
779      int     iMinValue;
780      int     iMaxValue;
781      int     iStepValue;
782      int     iExtValue;
783      int     iExtMask;
784  } ADLOD6VoltageControlInfo;
785  typedef struct _ADLECCData
786  {
787      int iSec;
788      int iDed;
789  } ADLECCData;
790  typedef void *ADL_CONTEXT_HANDLE;
791  typedef struct ADLDisplayModeX2
792  {
793     int  iWidth;
794     int  iHeight;
795     int  iScanType;
796     int  iRefreshRate;
797     int  iTimingStandard;
798  } ADLDisplayModeX2;
799  typedef struct _ADLOD6CapabilitiesEx
800  {
801      int iCapabilities;
802      int iSupportedStates;
803      ADLOD6ParameterRange sEngineClockPercent;
804      ADLOD6ParameterRange sMemoryClockPercent;
805      ADLOD6ParameterRange sPowerControlPercent;
806      int iExtValue;
807      int iExtMask;
808  } ADLOD6CapabilitiesEx;
809  typedef struct _ADLOD6StateEx
810  {
811      int iEngineClockPercent;
812      int iMemoryClockPercent;
813      int iPowerControlPercent;
814      int iExtValue;
815      int iExtMask;
816  } ADLOD6StateEx;
817  typedef struct _ADLOD6MaxClockAdjust
818  {
819      int iEngineClockMax;
820      int iMemoryClockMax;
821      int iExtValue;
822      int iExtMask;
823  } ADLOD6MaxClockAdjust;
824  typedef struct ADLConnectorInfo
825  {
826      int iConnectorIndex;
827      int iConnectorId;
828      int iSlotIndex;
829      int iType;
830      int iOffset;
831      int iLength;
832  } ADLConnectorInfo;
833  typedef struct ADLBracketSlotInfo
834  {
835      int iSlotIndex;
836      int iLength;
837      int iWidth;
838  } ADLBracketSlotInfo;
839  typedef struct ADLMSTRad
840  {
841      int iLinkNumber;
842      char rad[ADL_MAX_RAD_LINK_COUNT];
843  } ADLMSTRad;
844  typedef struct ADLDevicePort
845  {
846      int iConnectorIndex;
847      ADLMSTRad aMSTRad;
848  } ADLDevicePort;
849  typedef struct ADLSupportedConnections
850  {
851      int iSupportedConnections;
852      int iSupportedProperties[ADL_MAX_CONNECTION_TYPES];
853  } ADLSupportedConnections;
854  typedef struct ADLConnectionState
855  {
856      int iEmulationStatus;
857      int iEmulationMode;
858      int iDisplayIndex;
859  } ADLConnectionState;
860  typedef struct ADLConnectionProperties
861  {
862      int iValidProperties;
863      int iBitrate;
864      int iNumberOfLanes;
865      int iColorDepth;
866      int iStereo3DCaps;
867      int iOutputBandwidth;
868  } ADLConnectionProperties;
869  typedef struct ADLConnectionData
870  {
871      int iConnectionType;
872      ADLConnectionProperties aConnectionProperties;
873      int iNumberofPorts;
874      int iActiveConnections;
875      int iDataSize;
876      char EdidData[ADL_MAX_DISPLAY_EDID_DATA_SIZE];
877  } ADLConnectionData;
878  typedef struct ADLAdapterCapsX2
879  {
880      int iAdapterID;
881      int iNumControllers;
882      int iNumDisplays;
883      int iNumOverlays;
884      int iNumOfGLSyncConnectors;
885      int iCapsMask;
886      int iCapsValue;
887      int iNumConnectors;
888  }ADLAdapterCapsX2;
889  typedef enum _ADL_ERROR_RECORD_SEVERITY
890  {
891      ADL_GLOBALLY_UNCORRECTED  = 1,
892      ADL_LOCALLY_UNCORRECTED   = 2,
893      ADL_DEFFERRED             = 3,
894      ADL_CORRECTED             = 4
895  }ADL_ERROR_RECORD_SEVERITY;
896  typedef union _ADL_ECC_EDC_FLAG
897  {
898      struct
899      {
900          unsigned int isEccAccessing        : 1;
901          unsigned int reserved              : 31;
902      }bits;
903      unsigned int u32All;
904  }ADL_ECC_EDC_FLAG;
905  typedef struct ADLErrorRecord
906  {
907      ADL_ERROR_RECORD_SEVERITY Severity;
908      int  countValid;
909      unsigned int count;
910      int locationValid;
911      unsigned int CU; 
912      char StructureName[32]; 
913      char tiestamp[32];
914      unsigned int padding[3];
915  }ADLErrorRecord;
916  typedef enum _ADL_EDC_BLOCK_ID
917  {
918      ADL_EDC_BLOCK_ID_SQCIS = 1,
919      ADL_EDC_BLOCK_ID_SQCDS = 2,
920      ADL_EDC_BLOCK_ID_SGPR  = 3,
921      ADL_EDC_BLOCK_ID_VGPR  = 4,
922      ADL_EDC_BLOCK_ID_LDS   = 5,
923      ADL_EDC_BLOCK_ID_GDS   = 6,
924      ADL_EDC_BLOCK_ID_TCL1  = 7,
925      ADL_EDC_BLOCK_ID_TCL2  = 8
926  }ADL_EDC_BLOCK_ID;
927  typedef enum _ADL_ERROR_INJECTION_MODE
928  {
929      ADL_ERROR_INJECTION_MODE_SINGLE      = 1,
930      ADL_ERROR_INJECTION_MODE_MULTIPLE    = 2,
931      ADL_ERROR_INJECTION_MODE_ADDRESS     = 3
932  }ADL_ERROR_INJECTION_MODE;
933  typedef union _ADL_ERROR_PATTERN
934  {
935      struct
936      {
937          unsigned long  EccInjVector         :  16;
938          unsigned long  EccInjEn             :  9;
939          unsigned long  EccBeatEn            :  4;
940          unsigned long  EccChEn              :  4;
941          unsigned long  reserved             :  31;
942      } bits;
943      unsigned long long u64Value;
944  } ADL_ERROR_PATTERN;
945  typedef struct _ADL_ERROR_INJECTION_DATA
946  {
947      unsigned long long errorAddress;
948      ADL_ERROR_PATTERN errorPattern;
949  }ADL_ERROR_INJECTION_DATA;
950  typedef struct ADLErrorInjection
951  {
952      ADL_EDC_BLOCK_ID blockId;
953      ADL_ERROR_INJECTION_MODE errorInjectionMode;
954  }ADLErrorInjection;
955  typedef struct ADLErrorInjectionX2
956  {
957      ADL_EDC_BLOCK_ID blockId;
958      ADL_ERROR_INJECTION_MODE errorInjectionMode;
959      ADL_ERROR_INJECTION_DATA errorInjectionData;
960  }ADLErrorInjectionX2;
961  typedef struct ADLFreeSyncCap
962  {
963      int iCaps;
964      int iMinRefreshRateInMicroHz;
965      int iMaxRefreshRateInMicroHz;
966      int iReserved[5];
967  } ADLFreeSyncCap;
968  typedef struct _ADLDceSettings
969  {
970      DceSettingsType type;                       
971      union
972      {
973          struct
974          {
975              bool qualityDetectionEnabled;
976          } HdmiLq;
977          struct
978          {
979              DpLinkRate linkRate;                
980              unsigned int numberOfActiveLanes;   
981              unsigned int numberofTotalLanes;    
982              int relativePreEmphasis;            
983              int relativeVoltageSwing;           
984              int persistFlag;
985          } DpLink;
986          struct
987          {
988              bool linkProtectionEnabled;         
989          } Protection;
990      } Settings;
991      int iReserved[15];
992  } ADLDceSettings;
993  typedef struct ADLGraphicCoreInfo
994  {
995      int iGCGen;
996      union
997      {
998          int iNumCUs;
999          int iNumWGPs;
1000      };
1001      union
1002      {
1003          int iNumPEsPerCU;
1004          int iNumPEsPerWGP;
1005      };
1006      int iNumSIMDs;
1007      int iNumROPs;
1008      int iReserved[11];
1009  }ADLGraphicCoreInfo;
1010  typedef struct _ADLODNParameterRange
1011  {
1012      int     iMode;
1013      int     iMin;
1014      int     iMax;
1015      int     iStep;
1016      int     iDefault;
1017  } ADLODNParameterRange;
1018  typedef struct _ADLODNCapabilities
1019  {
1020      int     iMaximumNumberOfPerformanceLevels;
1021      ADLODNParameterRange     sEngineClockRange;
1022      ADLODNParameterRange     sMemoryClockRange;
1023      ADLODNParameterRange     svddcRange;
1024      ADLODNParameterRange     power;
1025      ADLODNParameterRange     powerTuneTemperature;
1026      ADLODNParameterRange     fanTemperature;
1027      ADLODNParameterRange     fanSpeed;
1028      ADLODNParameterRange     minimumPerformanceClock;
1029  } ADLODNCapabilities;
1030  typedef struct _ADLODNCapabilitiesX2
1031  {
1032      int     iMaximumNumberOfPerformanceLevels;
1033      int iFlags;
1034      ADLODNParameterRange     sEngineClockRange;
1035      ADLODNParameterRange     sMemoryClockRange;
1036      ADLODNParameterRange     svddcRange;
1037      ADLODNParameterRange     power;
1038      ADLODNParameterRange     powerTuneTemperature;
1039      ADLODNParameterRange     fanTemperature;
1040      ADLODNParameterRange     fanSpeed;
1041      ADLODNParameterRange     minimumPerformanceClock;
1042      ADLODNParameterRange throttleNotificaion;
1043      ADLODNParameterRange autoSystemClock;
1044  } ADLODNCapabilitiesX2;
1045  typedef struct ADLODNPerformanceLevel
1046  {
1047      int iClock;
1048      int iVddc;
1049      int iEnabled;
1050  } ADLODNPerformanceLevel;
1051  typedef struct ADLODNPerformanceLevels
1052  {
1053      int iSize;
1054      int iMode;
1055      int iNumberOfPerformanceLevels;
1056      ADLODNPerformanceLevel aLevels[1];
1057  } ADLODNPerformanceLevels;
1058  typedef struct ADLODNFanControl
1059  {
1060      int iMode;
1061      int iFanControlMode;
1062      int iCurrentFanSpeedMode;
1063      int iCurrentFanSpeed;
1064      int iTargetFanSpeed;
1065      int iTargetTemperature;
1066      int iMinPerformanceClock;
1067      int iMinFanLimit;
1068  } ADLODNFanControl;
1069  typedef struct ADLODNPowerLimitSetting
1070  {
1071      int iMode;
1072      int iTDPLimit;
1073      int iMaxOperatingTemperature;
1074  } ADLODNPowerLimitSetting;
1075  typedef struct ADLODNPerformanceStatus
1076  {
1077      int iCoreClock;
1078      int iMemoryClock;
1079      int iDCEFClock;
1080      int iGFXClock;
1081      int iUVDClock;
1082      int iVCEClock;
1083      int iGPUActivityPercent;
1084      int iCurrentCorePerformanceLevel;
1085      int iCurrentMemoryPerformanceLevel;
1086      int iCurrentDCEFPerformanceLevel;
1087      int iCurrentGFXPerformanceLevel;
1088      int iUVDPerformanceLevel;
1089      int iVCEPerformanceLevel;
1090      int iCurrentBusSpeed;
1091      int iCurrentBusLanes;
1092      int iMaximumBusLanes;
1093      int iVDDC;
1094      int iVDDCI;
1095  } ADLODNPerformanceStatus;
1096  typedef struct ADLODNPerformanceLevelX2
1097  {
1098      int iClock;
1099      int iVddc;
1100      int iEnabled;
1101      int iControl;
1102  } ADLODNPerformanceLevelX2;
1103  typedef struct ADLODNPerformanceLevelsX2
1104  {
1105      int iSize;
1106      int iMode;
1107      int iNumberOfPerformanceLevels;
1108      ADLODNPerformanceLevelX2 aLevels[1];
1109  } ADLODNPerformanceLevelsX2;
1110  typedef enum _ADLODNCurrentPowerType
1111  {
1112      ODN_GPU_TOTAL_POWER = 0,
1113      ODN_GPU_PPT_POWER,
1114      ODN_GPU_SOCKET_POWER,
1115      ODN_GPU_CHIP_POWER
1116  } ADLODNCurrentPowerType;
1117  typedef struct _ADLODNCurrentPowerParameters
1118  {
1119      int   size;
1120      ADLODNCurrentPowerType   powerType;
1121      int  currentPower;
1122  } ADLODNCurrentPowerParameters;
1123  typedef struct _ADLODNExtSingleInitSetting
1124  {
1125  	int mode;
1126  	int minValue;
1127  	int maxValue;
1128  	int step;
1129  	int defaultValue;
1130  } ADLODNExtSingleInitSetting;
1131  typedef struct _ADLOD8SingleInitSetting
1132  {
1133      int featureID;
1134      int minValue;
1135      int maxValue;
1136      int defaultValue;
1137  } ADLOD8SingleInitSetting;
1138  typedef struct _ADLOD8InitSetting
1139  {
1140      int count;
1141      int overdrive8Capabilities;
1142      ADLOD8SingleInitSetting  od8SettingTable[OD8_COUNT];
1143  } ADLOD8InitSetting;
1144  typedef struct _ADLOD8CurrentSetting
1145  {
1146      int count;
1147      int Od8SettingTable[OD8_COUNT];
1148  } ADLOD8CurrentSetting;
1149  typedef struct _ADLOD8SingleSetSetting
1150  {
1151      int value;
1152      int requested;      
1153      int reset;          
1154  } ADLOD8SingleSetSetting;
1155  typedef struct _ADLOD8SetSetting
1156  {
1157      int count;
1158      ADLOD8SingleSetSetting  od8SettingTable[OD8_COUNT];
1159  } ADLOD8SetSetting;
1160  typedef struct _ADLSingleSensorData
1161  {
1162      int supported;
1163      int  value;
1164  } ADLSingleSensorData;
1165  typedef struct _ADLPMLogDataOutput
1166  {
1167      int size;
1168      ADLSingleSensorData sensors[ADL_PMLOG_MAX_SENSORS];
1169  }ADLPMLogDataOutput;
1170  typedef struct ADLPPLogSettings
1171  {
1172      int BreakOnAssert;
1173      int BreakOnWarn;
1174      int LogEnabled;
1175      int LogFieldMask;
1176      int LogDestinations;
1177      int LogSeverityEnabled;
1178      int LogSourceMask;
1179      int PowerProfilingEnabled;
1180      int PowerProfilingTimeInterval;
1181  }ADLPPLogSettings;
1182  typedef struct _ADLFPSSettingsOutput
1183  {
1184      int ulSize;
1185      int bACFPSEnabled;
1186      int bDCFPSEnabled;
1187      int ulACFPSCurrent;
1188      int ulDCFPSCurrent;
1189      int ulACFPSMaximum;
1190      int ulACFPSMinimum;
1191      int ulDCFPSMaximum;
1192      int ulDCFPSMinimum;
1193  } ADLFPSSettingsOutput;
1194  typedef struct _ADLFPSSettingsInput
1195  {
1196      int ulSize;
1197      int bGlobalSettings;
1198      int ulACFPSCurrent;
1199      int ulDCFPSCurrent;
1200      int ulReserved[6];
1201  } ADLFPSSettingsInput;
1202  enum { ADL_PMLOG_MAX_SUPPORTED_SENSORS = 256 };
1203  typedef struct _ADLPMLogSupportInfo
1204  {
1205      unsigned short usSensors[ADL_PMLOG_MAX_SUPPORTED_SENSORS];
1206      int ulReserved[16];
1207  } ADLPMLogSupportInfo;
1208  typedef struct _ADLPMLogStartInput
1209  {
1210      unsigned short usSensors[ADL_PMLOG_MAX_SUPPORTED_SENSORS];
1211      unsigned long ulSampleRate;
1212      int ulReserved[15];
1213  } ADLPMLogStartInput;
1214  typedef struct _ADLPMLogData
1215  {
1216      unsigned int ulVersion;
1217      unsigned int ulActiveSampleRate;
1218      unsigned long long ulLastUpdated;
1219      unsigned int ulValues[ADL_PMLOG_MAX_SUPPORTED_SENSORS][2];
1220      unsigned int ulReserved[256];
1221  } ADLPMLogData;
1222  typedef struct _ADLPMLogStartOutput
1223  {
1224      union
1225      {
1226          void* pLoggingAddress;
1227          unsigned long long ptr_LoggingAddress;
1228      };
1229      int ulReserved[14];
1230  } ADLPMLogStartOutput;
1231  typedef struct _ADLRASGetErrorCountsInput
1232  {
1233      unsigned int                Reserved[16];
1234  } ADLRASGetErrorCountsInput;
1235  typedef struct _ADLRASGetErrorCountsOutput
1236  {
1237      unsigned int                CorrectedErrors;    
1238      unsigned int                UnCorrectedErrors;  
1239      unsigned int                Reserved[14];
1240  } ADLRASGetErrorCountsOutput;
1241  typedef struct _ADLRASGetErrorCounts
1242  {
1243      unsigned int                InputSize;
1244      ADLRASGetErrorCountsInput   Input;
1245      unsigned int                OutputSize;
1246      ADLRASGetErrorCountsOutput  Output;
1247  } ADLRASGetErrorCounts;
1248  typedef struct _ADLRASResetErrorCountsInput
1249  {
1250      unsigned int                Reserved[8];
1251  } ADLRASResetErrorCountsInput;
1252  typedef struct _ADLRASResetErrorCountsOutput
1253  {
1254      unsigned int                Reserved[8];
1255  } ADLRASResetErrorCountsOutput;
1256  typedef struct _ADLRASResetErrorCounts
1257  {
1258      unsigned int                    InputSize;
1259      ADLRASResetErrorCountsInput     Input;
1260      unsigned int                    OutputSize;
1261      ADLRASResetErrorCountsOutput    Output;
1262  } ADLRASResetErrorCounts;
1263  typedef struct _ADLRASErrorInjectonInput
1264  {
1265      unsigned long long Address;
1266      ADL_RAS_INJECTION_METHOD Value;
1267      ADL_RAS_BLOCK_ID BlockId;
1268      ADL_RAS_ERROR_TYPE InjectErrorType;
1269      ADL_MEM_SUB_BLOCK_ID SubBlockIndex;
1270      unsigned int padding[9];
1271  } ADLRASErrorInjectonInput;
1272  typedef struct _ADLRASErrorInjectionOutput
1273  {
1274      unsigned int ErrorInjectionStatus;
1275      unsigned int padding[15];
1276  } ADLRASErrorInjectionOutput;
1277  typedef struct _ADLRASErrorInjection
1278  {
1279      unsigned int                           InputSize;
1280      ADLRASErrorInjectonInput               Input;
1281      unsigned int                           OutputSize;
1282      ADLRASErrorInjectionOutput             Output;
1283  } ADLRASErrorInjection;
1284  typedef struct _ADLSGApplicationInfo
1285  {
1286      wchar_t strFileName[ADL_MAX_PATH];
1287      wchar_t strFilePath[ADL_MAX_PATH];
1288      wchar_t strVersion[ADL_MAX_PATH];
1289      long long int timeStamp;
1290      unsigned int iProfileExists;
1291      unsigned int iGPUAffinity;
1292      ADLBdf GPUBdf;
1293  } ADLSGApplicationInfo;
1294  enum { ADLPreFlipPostProcessingInfoInvalidLUTIndex = 0xFFFFFFFF };
1295  enum ADLPreFlipPostProcessingLUTAlgorithm
1296  {
1297      ADLPreFlipPostProcessingLUTAlgorithm_Default = 0,
1298      ADLPreFlipPostProcessingLUTAlgorithm_Full,
1299      ADLPreFlipPostProcessingLUTAlgorithm_Approximation
1300  };
1301  typedef struct _ADLPreFlipPostProcessingInfo
1302  {
1303      int ulSize;
1304      int bEnabled;
1305      int ulSelectedLUTIndex;
1306      int ulSelectedLUTAlgorithm;
1307      int ulReserved[12];
1308  } ADLPreFlipPostProcessingInfo;
1309  typedef struct _ADL_ERROR_REASON
1310  {
1311  	int boost; 
1312  	int delag; 
1313  	int chill; 
1314  }ADL_ERROR_REASON;
1315  typedef struct _ADL_DELAG_NOTFICATION_REASON
1316  {
1317  	int HotkeyChanged; 
1318  	int GlobalEnableChanged; 
1319  	int GlobalLimitFPSChanged; 
1320  }ADL_DELAG_NOTFICATION_REASON;
1321  typedef struct _ADL_DELAG_SETTINGS
1322  {
1323  	int Hotkey; 
1324  	int GlobalEnable; 
1325  	int GlobalLimitFPS; 
1326  	int GlobalLimitFPS_MinLimit; 
1327  	int GlobalLimitFPS_MaxLimit; 
1328  	int GlobalLimitFPS_Step; 
1329  }ADL_DELAG_SETTINGS;
1330  typedef struct _ADL_BOOST_NOTFICATION_REASON
1331  {
1332  	int HotkeyChanged; 
1333  	int GlobalEnableChanged; 
1334  	int GlobalMinResChanged; 
1335  }ADL_BOOST_NOTFICATION_REASON;
1336  typedef struct _ADL_BOOST_SETTINGS
1337  {
1338  	int Hotkey; 
1339  	int GlobalEnable; 
1340  	int GlobalMinRes; 
1341  	int GlobalMinRes_MinLimit; 
1342  	int GlobalMinRes_MaxLimit; 
1343  	int GlobalMinRes_Step; 
1344  }ADL_BOOST_SETTINGS;
1345  typedef struct _ADL_RIS_NOTFICATION_REASON
1346  {
1347  	unsigned int GlobalEnableChanged; 
1348  	unsigned int GlobalSharpeningDegreeChanged; 
1349  }ADL_RIS_NOTFICATION_REASON;
1350  typedef struct _ADL_RIS_SETTINGS
1351  {
1352  	int GlobalEnable; 
1353  	int GlobalSharpeningDegree; 
1354  	int GlobalSharpeningDegree_MinLimit; 
1355  	int GlobalSharpeningDegree_MaxLimit; 
1356  	int GlobalSharpeningDegree_Step; 
1357  }ADL_RIS_SETTINGS;
1358  typedef struct _ADL_CHILL_NOTFICATION_REASON
1359  {
1360  	int HotkeyChanged; 
1361  	int GlobalEnableChanged; 
1362  	int GlobalMinFPSChanged; 
1363  	int GlobalMaxFPSChanged; 
1364  }ADL_CHILL_NOTFICATION_REASON;
1365  typedef struct _ADL_CHILL_SETTINGS
1366  {
1367  	int Hotkey; 
1368  	int GlobalEnable; 
1369  	int GlobalMinFPS; 
1370  	int GlobalMaxFPS; 
1371  	int GlobalFPS_MinLimit; 
1372  	int GlobalFPS_MaxLimit; 
1373  	int GlobalFPS_Step; 
1374  }ADL_CHILL_SETTINGS;
1375  #endif &bsol;* ADL_STRUCTURES_H_ */
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from libtomcrypt-MDEwOlJlcG9zaXRvcnk3NzcwMTE=-flat-tomcrypt_hash.h</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from xmrig-MDEwOlJlcG9zaXRvcnk4ODMyNzQwNg==-flat-adl_structures.h</div>
                </div>
                <div class="column column_space"><pre><code>337  int blake2b_process(hash_state * md, const unsigned char *in, unsigned long inlen);
338  int blake2b_done(hash_state * md, unsigned char *out);
339  #endif
340  #ifdef LTC_MD5
341  int md5_init(hash_state * md);
342  int md5_process(hash_state * md, const unsigned char *in, unsigned long inlen);
343  int md5_done(hash_state * md, unsigned char *out);
</pre></code></div>
                <div class="column column_space"><pre><code>687      int iModifiers;
688      int iViewPositionCx;
689      int iViewPositionCy;
690      int iViewPanLockLeft;
691      int iViewPanLockRight;
692      int iViewPanLockTop;
693      int iViewPanLockBottom;
694      int iViewResolutionCx;
695      int iViewResolutionCy;
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    