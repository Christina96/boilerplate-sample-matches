
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 49.71098265895954%, Tokens: 11, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>xmrig-MDEwOlJlcG9zaXRvcnk4ODMyNzQwNg==-flat-blake2.h</h3>
            <pre><code>1  #ifndef PORTABLE_BLAKE2_H
2  #define PORTABLE_BLAKE2_H
3  #include <stdint.h>
4  #include <limits.h>
5  #if defined(__cplusplus)
6  extern "C" {
7  #endif
8  	enum blake2b_constant {
9  		BLAKE2B_BLOCKBYTES = 128,
10  		BLAKE2B_OUTBYTES = 64,
11  		BLAKE2B_KEYBYTES = 64,
12  		BLAKE2B_SALTBYTES = 16,
13  		BLAKE2B_PERSONALBYTES = 16
14  	};
15  #pragma pack(push, 1)
16  	typedef struct __blake2b_param {
<span onclick='openModal()' class='match'>17  		uint8_t digest_length;                   &bsol;* 1 */
18  		uint8_t key_length;                      &bsol;* 2 */
19  		uint8_t fanout;                          &bsol;* 3 */
20  		uint8_t depth;                           &bsol;* 4 */
21  		uint32_t leaf_length;                    &bsol;* 8 */
22  		uint64_t node_offset;                    &bsol;* 16 */
23  		uint8_t node_depth;                      &bsol;* 17 */
24  		uint8_t inner_length;                    &bsol;* 18 */
25  		uint8_t reserved[14];                    &bsol;* 32 */
26  		uint8_t salt[BLAKE2B_SALTBYTES];         &bsol;* 48 */
27  		uint8_t personal[BLAKE2B_PERSONALBYTES]; &bsol;* 64 */
</span>28  	} blake2b_param;
29  #pragma pack(pop)
30  	typedef struct __blake2b_state {
31  		uint64_t h[8];
32  		uint64_t t[2];
33  		uint64_t f[2];
34  		uint8_t buf[BLAKE2B_BLOCKBYTES];
35  		unsigned buflen;
36  		unsigned outlen;
37  		uint8_t last_node;
38  	} blake2b_state;
39  	enum {
40  		blake2_size_check_0 = 1 / !!(CHAR_BIT == 8),
41  		blake2_size_check_2 =
42  		1 / !!(sizeof(blake2b_param) == sizeof(uint64_t) * CHAR_BIT)
43  	};
44      int rx_blake2b_init(blake2b_state *S, size_t outlen);
45      int rx_blake2b_init_key(blake2b_state *S, size_t outlen, const void *key, size_t keylen);
46      int rx_blake2b_init_param(blake2b_state *S, const blake2b_param *P);
47      int rx_blake2b_update(blake2b_state *S, const void *in, size_t inlen);
48      int rx_blake2b_final(blake2b_state *S, void *out, size_t outlen);
49      void rx_blake2b_compress_integer(blake2b_state * S, const uint8_t * block);
50      void rx_blake2b_compress_sse41(blake2b_state * S, const uint8_t * block);
51      int rx_blake2b_default(void* out, size_t outlen, const void* in, size_t inlen);
52      extern void (*rx_blake2b_compress)(blake2b_state * S, const uint8_t * block);
53      extern int (*rx_blake2b)(void* out, size_t outlen, const void* in, size_t inlen);
54  	int rxa2_blake2b_long(void *out, size_t outlen, const void *in, size_t inlen);
55  #if defined(__cplusplus)
56  }
57  #endif
58  #endif
</code></pre>
        </div>
        <div class="column">
            <h3>Adafruit_nRF52_Arduino-MDEwOlJlcG9zaXRvcnk3NDM1NDcyOQ==-flat-SEGGER_RTT.h</h3>
            <pre><code>1  #ifndef SEGGER_RTT_H
2  #define SEGGER_RTT_H
3  #include "SEGGER_RTT_Conf.h"
4  #ifndef RTT_USE_ASM
5    #if (defined __SES_ARM)                       
6      #define _CC_HAS_RTT_ASM_SUPPORT 1
7    #elif (defined __CROSSWORKS_ARM)              
8      #define _CC_HAS_RTT_ASM_SUPPORT 1
9    #elif (defined __GNUC__)                      
10      #define _CC_HAS_RTT_ASM_SUPPORT 1
11    #elif (defined __clang__)                     
12      #define _CC_HAS_RTT_ASM_SUPPORT 1
13    #elif (defined __IASMARM__)                   
14      #define _CC_HAS_RTT_ASM_SUPPORT 1
15    #elif (defined __ICCARM__)                    
16      #define _CC_HAS_RTT_ASM_SUPPORT 1
17    #else
18      #define _CC_HAS_RTT_ASM_SUPPORT 0
19    #endif
20    #if (defined __ARM_ARCH_7M__)                 
21      #define _CORE_HAS_RTT_ASM_SUPPORT 1
22    #elif (defined __ARM_ARCH_7EM__)              
23      #define _CORE_HAS_RTT_ASM_SUPPORT 1
24    #elif (defined __ARM_ARCH_8M_MAIN__)          
25      #define _CORE_HAS_RTT_ASM_SUPPORT 1
26    #elif (defined __ARM7M__)                     
27      #if (__CORE__ == __ARM7M__)
28        #define _CORE_HAS_RTT_ASM_SUPPORT 1
29      #else
30        #define _CORE_HAS_RTT_ASM_SUPPORT 0
31      #endif
32    #elif (defined __ARM7EM__)                    
33      #if (__CORE__ == __ARM7EM__)
34        #define _CORE_HAS_RTT_ASM_SUPPORT 1
35      #else
36        #define _CORE_HAS_RTT_ASM_SUPPORT 0
37      #endif
38    #else
39      #define _CORE_HAS_RTT_ASM_SUPPORT 0
40    #endif
41    #if (_CC_HAS_RTT_ASM_SUPPORT && _CORE_HAS_RTT_ASM_SUPPORT)
42      #define RTT_USE_ASM                           (1)
43    #else
44      #define RTT_USE_ASM                           (0)
45    #endif
46  #endif
47  #ifndef SEGGER_RTT_ASM  
48  #include <stdlib.h>
49  #include <stdarg.h>
50  typedef struct {
51    const     char*    sName;         
52              char*    pBuffer;       
53              unsigned SizeOfBuffer;  
54              unsigned WrOff;         
55    volatile  unsigned RdOff;         
56              unsigned Flags;         
57  } SEGGER_RTT_BUFFER_UP;
58  typedef struct {
59    const     char*    sName;         
60              char*    pBuffer;       
61              unsigned SizeOfBuffer;  
62    volatile  unsigned WrOff;         
63              unsigned RdOff;         
64              unsigned Flags;         
65  } SEGGER_RTT_BUFFER_DOWN;
66  typedef struct {
67    char                    acID[16];                                 
68    int                     MaxNumUpBuffers;                          
69    int                     MaxNumDownBuffers;                        
70    SEGGER_RTT_BUFFER_UP    aUp[SEGGER_RTT_MAX_NUM_UP_BUFFERS];       
71    SEGGER_RTT_BUFFER_DOWN  aDown[SEGGER_RTT_MAX_NUM_DOWN_BUFFERS];   
72  } SEGGER_RTT_CB;
73  extern SEGGER_RTT_CB _SEGGER_RTT;
74  #ifdef __cplusplus
75    extern "C" {
76  #endif
77  int          SEGGER_RTT_AllocDownBuffer         (const char* sName, void* pBuffer, unsigned BufferSize, unsigned Flags);
78  int          SEGGER_RTT_AllocUpBuffer           (const char* sName, void* pBuffer, unsigned BufferSize, unsigned Flags);
79  int          SEGGER_RTT_ConfigUpBuffer          (unsigned BufferIndex, const char* sName, void* pBuffer, unsigned BufferSize, unsigned Flags);
80  int          SEGGER_RTT_ConfigDownBuffer        (unsigned BufferIndex, const char* sName, void* pBuffer, unsigned BufferSize, unsigned Flags);
81  int          SEGGER_RTT_GetKey                  (void);
82  unsigned     SEGGER_RTT_HasData                 (unsigned BufferIndex);
83  int          SEGGER_RTT_HasKey                  (void);
84  unsigned     SEGGER_RTT_HasDataUp               (unsigned BufferIndex);
85  void         SEGGER_RTT_Init                    (void);
86  unsigned     SEGGER_RTT_Read                    (unsigned BufferIndex,       void* pBuffer, unsigned BufferSize);
87  unsigned     SEGGER_RTT_ReadNoLock              (unsigned BufferIndex,       void* pData,   unsigned BufferSize);
88  int          SEGGER_RTT_SetNameDownBuffer       (unsigned BufferIndex, const char* sName);
<span onclick='openModal()' class='match'>89  int          SEGGER_RTT_SetNameUpBuffer         (unsigned BufferIndex, const char* sName);
90  int          SEGGER_RTT_SetFlagsDownBuffer      (unsigned BufferIndex, unsigned Flags);
91  int          SEGGER_RTT_SetFlagsUpBuffer        (unsigned BufferIndex, unsigned Flags);
92  int          SEGGER_RTT_WaitKey                 (void);
93  unsigned     SEGGER_RTT_Write                   (unsigned BufferIndex, const void* pBuffer, unsigned NumBytes);
94  unsigned     SEGGER_RTT_WriteNoLock             (unsigned BufferIndex, const void* pBuffer, unsigned NumBytes);
</span>95  unsigned     SEGGER_RTT_WriteSkipNoLock         (unsigned BufferIndex, const void* pBuffer, unsigned NumBytes);
96  unsigned     SEGGER_RTT_ASM_WriteSkipNoLock     (unsigned BufferIndex, const void* pBuffer, unsigned NumBytes);
97  unsigned     SEGGER_RTT_WriteString             (unsigned BufferIndex, const char* s);
98  void         SEGGER_RTT_WriteWithOverwriteNoLock(unsigned BufferIndex, const void* pBuffer, unsigned NumBytes);
99  unsigned     SEGGER_RTT_PutChar                 (unsigned BufferIndex, char c);
100  unsigned     SEGGER_RTT_PutCharSkip             (unsigned BufferIndex, char c);
101  unsigned     SEGGER_RTT_PutCharSkipNoLock       (unsigned BufferIndex, char c);
102  unsigned     SEGGER_RTT_GetAvailWriteSpace      (unsigned BufferIndex);
103  unsigned     SEGGER_RTT_GetBytesInBuffer        (unsigned BufferIndex);
104  #define      SEGGER_RTT_HASDATA(n)       (_SEGGER_RTT.aDown[n].WrOff - _SEGGER_RTT.aDown[n].RdOff)
105  #if RTT_USE_ASM
106    #define SEGGER_RTT_WriteSkipNoLock  SEGGER_RTT_ASM_WriteSkipNoLock
107  #endif
108  unsigned     SEGGER_RTT_ReadUpBuffer            (unsigned BufferIndex, void* pBuffer, unsigned BufferSize);
109  unsigned     SEGGER_RTT_ReadUpBufferNoLock      (unsigned BufferIndex, void* pData, unsigned BufferSize);
110  unsigned     SEGGER_RTT_WriteDownBuffer         (unsigned BufferIndex, const void* pBuffer, unsigned NumBytes);
111  unsigned     SEGGER_RTT_WriteDownBufferNoLock   (unsigned BufferIndex, const void* pBuffer, unsigned NumBytes);
112  #define      SEGGER_RTT_HASDATA_UP(n)    (_SEGGER_RTT.aUp[n].WrOff - _SEGGER_RTT.aUp[n].RdOff)
113  int     SEGGER_RTT_SetTerminal        (unsigned char TerminalId);
114  int     SEGGER_RTT_TerminalOut        (unsigned char TerminalId, const char* s);
115  int SEGGER_RTT_printf(unsigned BufferIndex, const char * sFormat, ...);
116  int SEGGER_RTT_vprintf(unsigned BufferIndex, const char * sFormat, va_list * pParamList);
117  #ifdef __cplusplus
118    }
119  #endif
120  #endif 
121  #define SEGGER_RTT_MODE_NO_BLOCK_SKIP         (0)     
122  #define SEGGER_RTT_MODE_NO_BLOCK_TRIM         (1)     
123  #define SEGGER_RTT_MODE_BLOCK_IF_FIFO_FULL    (2)     
124  #define SEGGER_RTT_MODE_MASK                  (3)
125  #define RTT_CTRL_RESET                "\x1B[0m"         
126  #define RTT_CTRL_CLEAR                "\x1B[2J"         
127  #define RTT_CTRL_TEXT_BLACK           "\x1B[2;30m"
128  #define RTT_CTRL_TEXT_RED             "\x1B[2;31m"
129  #define RTT_CTRL_TEXT_GREEN           "\x1B[2;32m"
130  #define RTT_CTRL_TEXT_YELLOW          "\x1B[2;33m"
131  #define RTT_CTRL_TEXT_BLUE            "\x1B[2;34m"
132  #define RTT_CTRL_TEXT_MAGENTA         "\x1B[2;35m"
133  #define RTT_CTRL_TEXT_CYAN            "\x1B[2;36m"
134  #define RTT_CTRL_TEXT_WHITE           "\x1B[2;37m"
135  #define RTT_CTRL_TEXT_BRIGHT_BLACK    "\x1B[1;30m"
136  #define RTT_CTRL_TEXT_BRIGHT_RED      "\x1B[1;31m"
137  #define RTT_CTRL_TEXT_BRIGHT_GREEN    "\x1B[1;32m"
138  #define RTT_CTRL_TEXT_BRIGHT_YELLOW   "\x1B[1;33m"
139  #define RTT_CTRL_TEXT_BRIGHT_BLUE     "\x1B[1;34m"
140  #define RTT_CTRL_TEXT_BRIGHT_MAGENTA  "\x1B[1;35m"
141  #define RTT_CTRL_TEXT_BRIGHT_CYAN     "\x1B[1;36m"
142  #define RTT_CTRL_TEXT_BRIGHT_WHITE    "\x1B[1;37m"
143  #define RTT_CTRL_BG_BLACK             "\x1B[24;40m"
144  #define RTT_CTRL_BG_RED               "\x1B[24;41m"
145  #define RTT_CTRL_BG_GREEN             "\x1B[24;42m"
146  #define RTT_CTRL_BG_YELLOW            "\x1B[24;43m"
147  #define RTT_CTRL_BG_BLUE              "\x1B[24;44m"
148  #define RTT_CTRL_BG_MAGENTA           "\x1B[24;45m"
149  #define RTT_CTRL_BG_CYAN              "\x1B[24;46m"
150  #define RTT_CTRL_BG_WHITE             "\x1B[24;47m"
151  #define RTT_CTRL_BG_BRIGHT_BLACK      "\x1B[4;40m"
152  #define RTT_CTRL_BG_BRIGHT_RED        "\x1B[4;41m"
153  #define RTT_CTRL_BG_BRIGHT_GREEN      "\x1B[4;42m"
154  #define RTT_CTRL_BG_BRIGHT_YELLOW     "\x1B[4;43m"
155  #define RTT_CTRL_BG_BRIGHT_BLUE       "\x1B[4;44m"
156  #define RTT_CTRL_BG_BRIGHT_MAGENTA    "\x1B[4;45m"
157  #define RTT_CTRL_BG_BRIGHT_CYAN       "\x1B[4;46m"
158  #define RTT_CTRL_BG_BRIGHT_WHITE      "\x1B[4;47m"
159  #endif
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from xmrig-MDEwOlJlcG9zaXRvcnk4ODMyNzQwNg==-flat-blake2.h</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from Adafruit_nRF52_Arduino-MDEwOlJlcG9zaXRvcnk3NDM1NDcyOQ==-flat-SEGGER_RTT.h</div>
                </div>
                <div class="column column_space"><pre><code>17  		uint8_t digest_length;                   &bsol;* 1 */
18  		uint8_t key_length;                      &bsol;* 2 */
19  		uint8_t fanout;                          &bsol;* 3 */
20  		uint8_t depth;                           &bsol;* 4 */
21  		uint32_t leaf_length;                    &bsol;* 8 */
22  		uint64_t node_offset;                    &bsol;* 16 */
23  		uint8_t node_depth;                      &bsol;* 17 */
24  		uint8_t inner_length;                    &bsol;* 18 */
25  		uint8_t reserved[14];                    &bsol;* 32 */
26  		uint8_t salt[BLAKE2B_SALTBYTES];         &bsol;* 48 */
27  		uint8_t personal[BLAKE2B_PERSONALBYTES]; &bsol;* 64 */
</pre></code></div>
                <div class="column column_space"><pre><code>89  int          SEGGER_RTT_SetNameUpBuffer         (unsigned BufferIndex, const char* sName);
90  int          SEGGER_RTT_SetFlagsDownBuffer      (unsigned BufferIndex, unsigned Flags);
91  int          SEGGER_RTT_SetFlagsUpBuffer        (unsigned BufferIndex, unsigned Flags);
92  int          SEGGER_RTT_WaitKey                 (void);
93  unsigned     SEGGER_RTT_Write                   (unsigned BufferIndex, const void* pBuffer, unsigned NumBytes);
94  unsigned     SEGGER_RTT_WriteNoLock             (unsigned BufferIndex, const void* pBuffer, unsigned NumBytes);
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    