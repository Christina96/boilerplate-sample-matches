
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 3.902439024390244%, Tokens: 12, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>redis-MDEwOlJlcG9zaXRvcnkxMDgxMTA3MDY=-flat-WS2tcpip.h</h3>
            <pre><code>1  #ifndef _WS2TCPIP_H_
2  #define _WS2TCPIP_H_
3  #if _MSC_VER > 1000
4  #pragma once
5  #endif
6  #if WINVER <= _WIN32_WINNT_WS03
7  #include "win32_winapifamily.h"
8  #else
9  #include <winapifamily.h>
10  #endif
11  #pragma region Desktop Family
12  #if WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP)
13  #include <winsock2.h>
14  #include <ws2ipdef.h>
15  #include <limits.h>
16  #define UDP_NOCHECKSUM  1
17  #define UDP_CHECKSUM_COVERAGE   20  &bsol;* Set/get UDP-Lite checksum coverage */
18  #ifdef _MSC_VER
19  #define WS2TCPIP_INLINE __inline
20  #else
21  #define WS2TCPIP_INLINE extern inline &bsol;* GNU style */
22  #endif
23  #define EAI_AGAIN           WSATRY_AGAIN
24  #define EAI_BADFLAGS        WSAEINVAL
25  #define EAI_FAIL            WSANO_RECOVERY
26  #define EAI_FAMILY          WSAEAFNOSUPPORT
27  #define EAI_MEMORY          WSA_NOT_ENOUGH_MEMORY
28  #define EAI_NOSECURENAME    WSA_SECURE_HOST_NOT_FOUND
29  #define EAI_NONAME          WSAHOST_NOT_FOUND
30  #define EAI_SERVICE         WSATYPE_NOT_FOUND
31  #define EAI_SOCKTYPE        WSAESOCKTNOSUPPORT
32  #define EAI_IPSECPOLICY     WSA_IPSEC_NAME_POLICY_ERROR
33  #define EAI_NODATA      EAI_NONAME
34  #ifdef UNICODE
<span onclick='openModal()' class='match'>35  typedef ADDRINFOW       ADDRINFOT, *PADDRINFOT;
36  #else
37  typedef ADDRINFOA       ADDRINFOT, *PADDRINFOT;
38  #endif
39  typedef ADDRINFOA       ADDRINFO, FAR * LPADDRINFO;
40  #if (_WIN32_WINNT >= 0x0600)
41  #ifdef UNICODE
42  typedef ADDRINFOEXW     ADDRINFOEX, *PADDRINFOEX;
43  #else
44  typedef ADDRINFOEXA     ADDRINFOEX, *PADDRINFOEX;
45  #endif
46  #endif
47  #ifdef __cplusplus
48  extern "C" {
49  #endif
50  #if INCL_WINSOCK_API_TYPEDEFS
51  WINSOCK_API_LINKAGE
52  INT
53  WSAAPI
54  getaddrinfo(
55      _In_opt_        PCSTR               pNodeName,
56      _In_opt_        PCSTR               pServiceName,
57      _In_opt_        const ADDRINFOA *   pHints,
58      _Outptr_     PADDRINFOA *        ppResult
59      );
60  #if (NTDDI_VERSION >= NTDDI_WINXPSP2) || (_WIN32_WINNT >= 0x0502)
61  WINSOCK_API_LINKAGE
62  INT
63  WSAAPI
64  GetAddrInfoW(
65      _In_opt_        PCWSTR              pNodeName,
66      _In_opt_        PCWSTR              pServiceName,
67      _In_opt_        const ADDRINFOW *   pHints,
</span>68      _Outptr_     PADDRINFOW *        ppResult
69      );
70  #define GetAddrInfoA    getaddrinfo
71  #ifdef UNICODE
72  #define GetAddrInfo     GetAddrInfoW
73  #else
74  #define GetAddrInfo     GetAddrInfoA
75  #endif
76  #endif
77  #endif
78  #if INCL_WINSOCK_API_TYPEDEFS
79  typedef
80  INT
81  (WSAAPI * LPFN_GETADDRINFO)(
82      _In_opt_        PCSTR               pNodeName,
83      _In_opt_        PCSTR               pServiceName,
84      _In_opt_        const ADDRINFOA *   pHints,
85      _Outptr_     PADDRINFOA *        ppResult
86      );
87  typedef
88  INT
89  (WSAAPI * LPFN_GETADDRINFOW)(
90      _In_opt_        PCWSTR              pNodeName,
91      _In_opt_        PCWSTR              pServiceName,
92      _In_opt_        const ADDRINFOW *   pHints,
93      _Outptr_     PADDRINFOW *        ppResult
94      );
95  #define LPFN_GETADDRINFOA      LPFN_GETADDRINFO
96  #ifdef UNICODE
97  #define LPFN_GETADDRINFOT      LPFN_GETADDRINFOW
98  #else
99  #define LPFN_GETADDRINFOT      LPFN_GETADDRINFOA
100  #endif
101  #endif
102  #if (_WIN32_WINNT >= 0x0600)
103  typedef
104  void
105  (CALLBACK * LPLOOKUPSERVICE_COMPLETION_ROUTINE)(
106      _In_      DWORD    dwError,
107      _In_      DWORD    dwBytes,
108      _In_      LPWSAOVERLAPPED lpOverlapped
109      );
110  WINSOCK_API_LINKAGE
111  INT
112  WSAAPI
113  GetAddrInfoExA(
114      _In_opt_    PCSTR           pName,
115      _In_opt_    PCSTR           pServiceName,
116      _In_        DWORD           dwNameSpace,
117      _In_opt_    LPGUID          lpNspId,
118      _In_opt_    const ADDRINFOEXA *hints,
119      _Outptr_ PADDRINFOEXA *  ppResult,
120      _In_opt_    struct timeval *timeout,
121      _In_opt_    LPOVERLAPPED    lpOverlapped,
122      _In_opt_    LPLOOKUPSERVICE_COMPLETION_ROUTINE  lpCompletionRoutine,
123      _Out_opt_   LPHANDLE        lpNameHandle
124      );
125  WINSOCK_API_LINKAGE
126  INT
127  WSAAPI
128  GetAddrInfoExW(
129      _In_opt_    PCWSTR          pName,
130      _In_opt_    PCWSTR          pServiceName,
131      _In_        DWORD           dwNameSpace,
132      _In_opt_    LPGUID          lpNspId,
133      _In_opt_    const ADDRINFOEXW *hints,
134      _Outptr_ PADDRINFOEXW *  ppResult,
135      _In_opt_    struct timeval *timeout,
136      _In_opt_    LPOVERLAPPED    lpOverlapped,
137      _In_opt_    LPLOOKUPSERVICE_COMPLETION_ROUTINE  lpCompletionRoutine,
138      _Out_opt_   LPHANDLE        lpHandle
139      );
140  WINSOCK_API_LINKAGE
141  INT
142  WSAAPI
143  GetAddrInfoExCancel(
144      _In_        LPHANDLE        lpHandle
145      );
146  WINSOCK_API_LINKAGE
147  INT
148  WSAAPI
149  GetAddrInfoExOverlappedResult(
150      _In_        LPOVERLAPPED    lpOverlapped
151      );
152  #ifdef UNICODE
153  #define GetAddrInfoEx       GetAddrInfoExW
154  #else
155  #define GetAddrInfoEx       GetAddrInfoExA
156  #endif
157  #if INCL_WINSOCK_API_TYPEDEFS
158  typedef
159  INT
160  (WSAAPI *LPFN_GETADDRINFOEXA)(
161      _In_        PCSTR           pName,
162      _In_opt_    PCSTR           pServiceName,
163      _In_        DWORD           dwNameSpace,
164      _In_opt_    LPGUID          lpNspId,
165      _In_opt_    const ADDRINFOEXA *hints,
166      _Outptr_ PADDRINFOEXA   *ppResult,
167      _In_opt_    struct timeval *timeout,
168      _In_opt_    LPOVERLAPPED    lpOverlapped,
169      _In_opt_    LPLOOKUPSERVICE_COMPLETION_ROUTINE  lpCompletionRoutine,
170      _Out_opt_   LPHANDLE        lpNameHandle
171      );
172  typedef
173  INT
174  (WSAAPI *LPFN_GETADDRINFOEXW)(
175      _In_        PCWSTR          pName,
176      _In_opt_    PCWSTR          pServiceName,
177      _In_        DWORD           dwNameSpace,
178      _In_opt_    LPGUID          lpNspId,
179      _In_opt_    const ADDRINFOEXW *hints,
180      _Outptr_ PADDRINFOEXW   *ppResult,
181      _In_opt_    struct timeval *timeout,
182      _In_opt_    LPOVERLAPPED    lpOverlapped,
183      _In_opt_    LPLOOKUPSERVICE_COMPLETION_ROUTINE  lpCompletionRoutine,
184      _Out_opt_   LPHANDLE        lpHandle
185      );
186  typedef
187  INT
188  (WSAAPI *LPFN_GETADDRINFOEXCANCEL)(
189      _In_        LPHANDLE        lpHandle
190      );
191  typedef
192  INT
193  (WSAAPI *LPFN_GETADDRINFOEXOVERLAPPEDRESULT)(
194      _In_        LPOVERLAPPED    lpOverlapped
195      );
196  #ifdef UNICODE
197  #define LPFN_GETADDRINFOEX      LPFN_GETADDRINFOEXW
198  #else
199  #define LPFN_GETADDRINFOEX      LPFN_GETADDRINFOEXA
200  #endif
201  #endif
202  #endif
203  #if (_WIN32_WINNT >= 0x0600)
204  WINSOCK_API_LINKAGE
205  INT
206  WSAAPI
207  SetAddrInfoExA(
208      _In_        PCSTR           pName,
209      _In_opt_    PCSTR           pServiceName,
210      _In_opt_    SOCKET_ADDRESS *pAddresses,
211      _In_        DWORD           dwAddressCount,
212      _In_opt_    LPBLOB          lpBlob,
213      _In_        DWORD           dwFlags,
214      _In_        DWORD           dwNameSpace,
215      _In_opt_    LPGUID          lpNspId,
216      _In_opt_    struct timeval *timeout,
217      _In_opt_    LPOVERLAPPED    lpOverlapped,
218      _In_opt_    LPLOOKUPSERVICE_COMPLETION_ROUTINE  lpCompletionRoutine,
219      _Out_opt_   LPHANDLE        lpNameHandle
220      );
221  WINSOCK_API_LINKAGE
222  INT
223  WSAAPI
224  SetAddrInfoExW(
225      _In_        PCWSTR          pName,
226      _In_opt_    PCWSTR          pServiceName,
227      _In_opt_    SOCKET_ADDRESS *pAddresses,
228      _In_        DWORD           dwAddressCount,
229      _In_opt_    LPBLOB          lpBlob,
230      _In_        DWORD           dwFlags,
231      _In_        DWORD           dwNameSpace,
232      _In_opt_    LPGUID          lpNspId,
233      _In_opt_    struct timeval *timeout,
234      _In_opt_    LPOVERLAPPED    lpOverlapped,
235      _In_opt_    LPLOOKUPSERVICE_COMPLETION_ROUTINE  lpCompletionRoutine,
236      _Out_opt_   LPHANDLE        lpNameHandle
237      );
238  #ifdef UNICODE
239  #define SetAddrInfoEx       SetAddrInfoExW
240  #else
241  #define SetAddrInfoEx       SetAddrInfoExA
242  #endif
243  #if INCL_WINSOCK_API_TYPEDEFS
244  typedef
245  INT
246  (WSAAPI *LPFN_SETADDRINFOEXA)(
247      _In_        PCSTR           pName,
248      _In_opt_    PCSTR           pServiceName,
249      _In_opt_    SOCKET_ADDRESS *pAddresses,
250      _In_        DWORD           dwAddressCount,
251      _In_opt_    LPBLOB          lpBlob,
252      _In_        DWORD           dwFlags,
253      _In_        DWORD           dwNameSpace,
254      _In_opt_    LPGUID          lpNspId,
255      _In_opt_    struct timeval *timeout,
256      _In_opt_    LPOVERLAPPED    lpOverlapped,
257      _In_opt_    LPLOOKUPSERVICE_COMPLETION_ROUTINE  lpCompletionRoutine,
258      _Out_opt_   LPHANDLE        lpNameHandle
259      );
260  typedef
261  INT
262  (WSAAPI *LPFN_SETADDRINFOEXW)(
263      _In_        PCWSTR          pName,
264      _In_opt_    PCWSTR          pServiceName,
265      _In_opt_    SOCKET_ADDRESS *pAddresses,
266      _In_        DWORD           dwAddressCount,
267      _In_opt_    LPBLOB          lpBlob,
268      _In_        DWORD           dwFlags,
269      _In_        DWORD           dwNameSpace,
270      _In_opt_    LPGUID          lpNspId,
271      _In_opt_    struct timeval *timeout,
272      _In_opt_    LPOVERLAPPED    lpOverlapped,
273      _In_opt_    LPLOOKUPSERVICE_COMPLETION_ROUTINE  lpCompletionRoutine,
274      _Out_opt_   LPHANDLE        lpNameHandle
275      );
276  #ifdef UNICODE
277  #define LPFN_SETADDRINFOEX      LPFN_SETADDRINFOEXW
278  #else
279  #define LPFN_SETADDRINFOEX      LPFN_SETADDRINFOEXA
280  #endif
281  #endif
282  #endif
283  #if INCL_WINSOCK_API_TYPEDEFS
284  WINSOCK_API_LINKAGE
285  VOID
286  WSAAPI
287  freeaddrinfo(
288      _In_opt_        PADDRINFOA      pAddrInfo
289      );
290  #if (NTDDI_VERSION >= NTDDI_WINXPSP2) || (_WIN32_WINNT >= 0x0502)
291  WINSOCK_API_LINKAGE
292  VOID
293  WSAAPI
294  FreeAddrInfoW(
295      _In_opt_        PADDRINFOW      pAddrInfo
296      );
297  #endif
298  #define FreeAddrInfoA   freeaddrinfo
299  #ifdef UNICODE
300  #define FreeAddrInfo    FreeAddrInfoW
301  #else
302  #define FreeAddrInfo    FreeAddrInfoA
303  #endif
304  #endif
305  #if INCL_WINSOCK_API_TYPEDEFS
306  typedef
307  VOID
308  (WSAAPI * LPFN_FREEADDRINFO)(
309      _In_opt_        PADDRINFOA      pAddrInfo
310      );
311  typedef
312  VOID
313  (WSAAPI * LPFN_FREEADDRINFOW)(
314      _In_opt_        PADDRINFOW      pAddrInfo
315      );
316  #define LPFN_FREEADDRINFOA      LPFN_FREEADDRINFO
317  #ifdef UNICODE
318  #define LPFN_FREEADDRINFOT      LPFN_FREEADDRINFOW
319  #else
320  #define LPFN_FREEADDRINFOT      LPFN_FREEADDRINFOA
321  #endif
322  #endif
323  #if (_WIN32_WINNT >= 0x0600)
324  WINSOCK_API_LINKAGE
325  void
326  WSAAPI
327  FreeAddrInfoEx(
328      _In_opt_  PADDRINFOEXA    pAddrInfoEx
329      );
330  WINSOCK_API_LINKAGE
331  void
332  WSAAPI
333  FreeAddrInfoExW(
334      _In_opt_  PADDRINFOEXW    pAddrInfoEx
335      );
336  #define FreeAddrInfoExA     FreeAddrInfoEx
337  #ifdef UNICODE
338  #define FreeAddrInfoEx      FreeAddrInfoExW
339  #endif
340  #ifdef INCL_WINSOCK_API_TYPEDEFS
341  typedef
342  void
343  (WSAAPI *LPFN_FREEADDRINFOEXA)(
344      _In_    PADDRINFOEXA    pAddrInfoEx
345      );
346  typedef
347  void
348  (WSAAPI *LPFN_FREEADDRINFOEXW)(
349      _In_    PADDRINFOEXW    pAddrInfoEx
350      );
351  #ifdef UNICODE
352  #define LPFN_FREEADDRINFOEX     LPFN_FREEADDRINFOEXW
353  #else
354  #define LPFN_FREEADDRINFOEX     LPFN_FREEADDRINFOEXA
355  #endif
356  #endif
357  #endif
358  typedef int socklen_t;
359  WINSOCK_API_LINKAGE
360  INT
361  WSAAPI
362  getnameinfo(
363      _In_reads_bytes_(SockaddrLength)         const SOCKADDR *    pSockaddr,
364      _In_                                socklen_t           SockaddrLength,
365      _Out_writes_opt_(NodeBufferSize)    PCHAR               pNodeBuffer,
366      _In_                                DWORD               NodeBufferSize,
367      _Out_writes_opt_(ServiceBufferSize) PCHAR               pServiceBuffer,
368      _In_                                DWORD               ServiceBufferSize,
369      _In_                                INT                 Flags
370      );
371  #if (NTDDI_VERSION >= NTDDI_WINXPSP2) || (_WIN32_WINNT >= 0x0502)
372  WINSOCK_API_LINKAGE
373  INT
374  WSAAPI
375  GetNameInfoW(
376      _In_reads_bytes_(SockaddrLength)         const SOCKADDR *    pSockaddr,
377      _In_                                socklen_t           SockaddrLength,
378      _Out_writes_opt_(NodeBufferSize)    PWCHAR              pNodeBuffer,
379      _In_                                DWORD               NodeBufferSize,
380      _Out_writes_opt_(ServiceBufferSize) PWCHAR              pServiceBuffer,
381      _In_                                DWORD               ServiceBufferSize,
382      _In_                                INT                 Flags
383      );
384  #define GetNameInfoA    getnameinfo
385  #ifdef UNICODE
386  #define GetNameInfo     GetNameInfoW
387  #else
388  #define GetNameInfo     GetNameInfoA
389  #endif
390  #endif
391  #if INCL_WINSOCK_API_TYPEDEFS
392  typedef
393  int
394  (WSAAPI * LPFN_GETNAMEINFO)(
395      _In_reads_bytes_(SockaddrLength)         const SOCKADDR *    pSockaddr,
396      _In_                                socklen_t           SockaddrLength,
397      _Out_writes_opt_(NodeBufferSize)    PCHAR               pNodeBuffer,
398      _In_                                DWORD               NodeBufferSize,
399      _Out_writes_opt_(ServiceBufferSize) PCHAR               pServiceBuffer,
400      _In_                                DWORD               ServiceBufferSize,
401      _In_                                INT                 Flags
402      );
403  typedef
404  INT
405  (WSAAPI * LPFN_GETNAMEINFOW)(
406      _In_reads_bytes_(SockaddrLength)         const SOCKADDR *    pSockaddr,
407      _In_                                socklen_t           SockaddrLength,
408      _Out_writes_opt_(NodeBufferSize)    PWCHAR              pNodeBuffer,
409      _In_                                DWORD               NodeBufferSize,
410      _Out_writes_opt_(ServiceBufferSize) PWCHAR              pServiceBuffer,
411      _In_                                DWORD               ServiceBufferSize,
412      _In_                                INT                 Flags
413      );
414  #define LPFN_GETNAMEINFOA      LPFN_GETNAMEINFO
415  #ifdef UNICODE
416  #define LPFN_GETNAMEINFOT      LPFN_GETNAMEINFOW
417  #else
418  #define LPFN_GETNAMEINFOT      LPFN_GETNAMEINFOA
419  #endif
420  #endif
421  #if (NTDDI_VERSION >= NTDDI_VISTA)
422  #if INCL_WINSOCK_API_TYPEDEFS
423  WINSOCK_API_LINKAGE
424  INT
425  WSAAPI
426  inet_pton(
427      _In_                                INT             Family,
428      _In_                                PCSTR           pszAddrString,
429      _Out_writes_bytes_(sizeof(IN6_ADDR))      PVOID           pAddrBuf
430      );
431  INT
432  WSAAPI
433  InetPtonW(
434      _In_                                INT             Family,
435      _In_                                PCWSTR          pszAddrString,
436      _Out_writes_bytes_(sizeof(IN6_ADDR))      PVOID           pAddrBuf
437      );
438  PCSTR
439  WSAAPI
440  inet_ntop(
441      _In_                                INT             Family,
442      _In_                                PVOID           pAddr,
443      _Out_writes_(StringBufSize)         PSTR            pStringBuf,
444      _In_                                size_t          StringBufSize
445      );
446  PCWSTR
447  WSAAPI
448  InetNtopW(
449      _In_                                INT             Family,
450      _In_                                PVOID           pAddr,
451      _Out_writes_(StringBufSize)         PWSTR           pStringBuf,
452      _In_                                size_t          StringBufSize
453      );
454  #define InetPtonA       inet_pton
455  #define InetNtopA       inet_ntop
456  #ifdef UNICODE
457  #define InetPton        InetPtonW
458  #define InetNtop        InetNtopW
459  #else
460  #define InetPton        InetPtonA
461  #define InetNtop        InetNtopA
462  #endif
463  #endif
464  #if INCL_WINSOCK_API_TYPEDEFS
465  typedef
466  INT
467  (WSAAPI * LPFN_INET_PTONA)(
468      _In_                                INT             Family,
469      _In_                                PCSTR           pszAddrString,
470      _Out_writes_bytes_(sizeof(IN6_ADDR))      PVOID           pAddrBuf
471      );
472  typedef
473  INT
474  (WSAAPI * LPFN_INET_PTONW)(
475      _In_                                INT             Family,
476      _In_                                PCWSTR          pszAddrString,
477      _Out_writes_bytes_(sizeof(IN6_ADDR))      PVOID           pAddrBuf
478      );
479  typedef
480  PCSTR
481  (WSAAPI * LPFN_INET_NTOPA)(
482      _In_                                INT             Family,
483      _In_                                PVOID           pAddr,
484      _Out_writes_(StringBufSize)         PSTR            pStringBuf,
485      _In_                                size_t          StringBufSize
486      );
487  typedef
488  PCWSTR
489  (WSAAPI * LPFN_INET_NTOPW)(
490      _In_                                INT             Family,
491      _In_                                PVOID           pAddr,
492      _Out_writes_(StringBufSize)         PWSTR           pStringBuf,
493      _In_                                size_t          StringBufSize
494      );
495  #ifdef UNICODE
496  #define LPFN_INET_PTON          LPFN_INET_PTONW
497  #define LPFN_INET_NTOP          LPFN_INET_NTOPW
498  #else
499  #define LPFN_INET_PTON          LPFN_INET_PTONA
500  #define LPFN_INET_NTOP          LPFN_INET_NTOPA
501  #endif
502  #endif  
503  #endif  
504  #if INCL_WINSOCK_API_PROTOTYPES
505  #ifdef UNICODE
506  #define gai_strerror   gai_strerrorW
507  #else
508  #define gai_strerror   gai_strerrorA
509  #endif  &bsol;* UNICODE */
510  #define GAI_STRERROR_BUFFER_SIZE 1024
511  WS2TCPIP_INLINE
512  char *
513  gai_strerrorA(
514      _In_ int ecode)
515  {
516      DWORD dwMsgLen;
517      static char buff[GAI_STRERROR_BUFFER_SIZE + 1];
518      dwMsgLen = FormatMessageA(FORMAT_MESSAGE_FROM_SYSTEM
519                               |FORMAT_MESSAGE_IGNORE_INSERTS
520                               |FORMAT_MESSAGE_MAX_WIDTH_MASK,
521                                NULL,
522                                ecode,
523                                MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
524                                (LPSTR)buff,
525                                GAI_STRERROR_BUFFER_SIZE,
526                                NULL);
527      return buff;
528  }
529  WS2TCPIP_INLINE
530  WCHAR *
531  gai_strerrorW(
532      _In_ int ecode
533      )
534  {
535      DWORD dwMsgLen;
536      static WCHAR buff[GAI_STRERROR_BUFFER_SIZE + 1];
537      dwMsgLen = FormatMessageW(FORMAT_MESSAGE_FROM_SYSTEM
538                               |FORMAT_MESSAGE_IGNORE_INSERTS
539                               |FORMAT_MESSAGE_MAX_WIDTH_MASK,
540                                NULL,
541                                ecode,
542                                MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
543                                (LPWSTR)buff,
544                                GAI_STRERROR_BUFFER_SIZE,
545                                NULL);
546      return buff;
547  }
548  #endif &bsol;* INCL_WINSOCK_API_PROTOTYPES */
549  #if INCL_WINSOCK_API_PROTOTYPES
550  WS2TCPIP_INLINE
551  int
552  setipv4sourcefilter(
553      _In_ SOCKET Socket,
554      _In_ IN_ADDR Interface,
555      _In_ IN_ADDR Group,
556      _In_ MULTICAST_MODE_TYPE FilterMode,
557      _In_ ULONG SourceCount,
558      _In_reads_(SourceCount) CONST IN_ADDR *SourceList
559      )
560  {
561      int Error;
562      DWORD Size, Returned;
563      PIP_MSFILTER Filter;
564      if (SourceCount >
565          (((ULONG) (ULONG_MAX - sizeof(*Filter))) / sizeof(*SourceList))) {
566          WSASetLastError(WSAENOBUFS);
567          return SOCKET_ERROR;
568      }
569      Size = IP_MSFILTER_SIZE(SourceCount);
570      Filter = (PIP_MSFILTER) HeapAlloc(GetProcessHeap(), 0, Size);
571      if (Filter == NULL) {
572          WSASetLastError(WSAENOBUFS);
573          return SOCKET_ERROR;
574      }
575      Filter->imsf_multiaddr = Group;
576      Filter->imsf_interface = Interface;
577      Filter->imsf_fmode = FilterMode;
578      Filter->imsf_numsrc = SourceCount;
579      if (SourceCount > 0) {
580          CopyMemory(Filter->imsf_slist, SourceList,
581                     SourceCount * sizeof(*SourceList));
582      }
583      Error = WSAIoctl(Socket, SIOCSIPMSFILTER, Filter, Size, NULL, 0,
584                       &Returned, NULL, NULL);
585      HeapFree(GetProcessHeap(), 0, Filter);
586      return Error;
587  }
588  _Success_(return == 0)
589  WS2TCPIP_INLINE
590  int
591  getipv4sourcefilter(
592      _In_ SOCKET Socket,
593      _In_ IN_ADDR Interface,
594      _In_ IN_ADDR Group,
595      _Out_ MULTICAST_MODE_TYPE *FilterMode,
596      _Inout_ ULONG *SourceCount,
597      _Out_writes_(*SourceCount) IN_ADDR *SourceList
598      )
599  {
600      int Error;
601      DWORD Size, Returned;
602      PIP_MSFILTER Filter;
603      if (*SourceCount >
604          (((ULONG) (ULONG_MAX - sizeof(*Filter))) / sizeof(*SourceList))) {
605          WSASetLastError(WSAENOBUFS);
606          return SOCKET_ERROR;
607      }
608      Size = IP_MSFILTER_SIZE(*SourceCount);
609      Filter = (PIP_MSFILTER) HeapAlloc(GetProcessHeap(), 0, Size);
610      if (Filter == NULL) {
611          WSASetLastError(WSAENOBUFS);
612          return SOCKET_ERROR;
613      }
614      Filter->imsf_multiaddr = Group;
615      Filter->imsf_interface = Interface;
616      Filter->imsf_numsrc = *SourceCount;
617      Error = WSAIoctl(Socket, SIOCGIPMSFILTER, Filter, Size, Filter, Size,
618                       &Returned, NULL, NULL);
619      if (Error == 0) {
620          if (*SourceCount > 0) {
621              CopyMemory(SourceList, Filter->imsf_slist,
622                         *SourceCount * sizeof(*SourceList));
623              *SourceCount = Filter->imsf_numsrc;
624          }
625          *FilterMode = Filter->imsf_fmode;
626      }
627      HeapFree(GetProcessHeap(), 0, Filter);
628      return Error;
629  }
630  #endif &bsol;* INCL_WINSOCK_API_PROTOTYPES */
631  #if (NTDDI_VERSION >= NTDDI_WINXP)
632  #if INCL_WINSOCK_API_PROTOTYPES
633  WS2TCPIP_INLINE
634  int
635  setsourcefilter(
636      _In_ SOCKET Socket,
637      _In_ ULONG Interface,
638      _In_ CONST SOCKADDR *Group,
639      _In_ int GroupLength,
640      _In_ MULTICAST_MODE_TYPE FilterMode,
641      _In_ ULONG SourceCount,
642      _In_reads_(SourceCount) CONST SOCKADDR_STORAGE *SourceList
643      )
644  {
645      int Error;
646      DWORD Size, Returned;
647      PGROUP_FILTER Filter;
648      if (SourceCount >=
649          (((ULONG) (ULONG_MAX - sizeof(*Filter))) / sizeof(*SourceList))) {
650          WSASetLastError(WSAENOBUFS);
651          return SOCKET_ERROR;
652      }
653      Size = GROUP_FILTER_SIZE(SourceCount);
654      Filter = (PGROUP_FILTER) HeapAlloc(GetProcessHeap(), 0, Size);
655      if (Filter == NULL) {
656          WSASetLastError(WSAENOBUFS);
657          return SOCKET_ERROR;
658      }
659      Filter->gf_interface = Interface;
660      ZeroMemory(&Filter->gf_group, sizeof(Filter->gf_group));
661      CopyMemory(&Filter->gf_group, Group, GroupLength);
662      Filter->gf_fmode = FilterMode;
663      Filter->gf_numsrc = SourceCount;
664      if (SourceCount > 0) {
665          CopyMemory(Filter->gf_slist, SourceList,
666                     SourceCount * sizeof(*SourceList));
667      }
668      Error = WSAIoctl(Socket, SIOCSMSFILTER, Filter, Size, NULL, 0,
669                       &Returned, NULL, NULL);
670      HeapFree(GetProcessHeap(), 0, Filter);
671      return Error;
672  }
673  _Success_(return == 0)
674  WS2TCPIP_INLINE
675  int
676  getsourcefilter(
677      _In_ SOCKET Socket,
678      _In_ ULONG Interface,
679      _In_ CONST SOCKADDR *Group,
680      _In_ int GroupLength,
681      _Out_ MULTICAST_MODE_TYPE *FilterMode,
682      _Inout_ ULONG *SourceCount,
683      _Out_writes_(*SourceCount) SOCKADDR_STORAGE *SourceList
684      )
685  {
686      int Error;
687      DWORD Size, Returned;
688      PGROUP_FILTER Filter;
689      if (*SourceCount >
690          (((ULONG) (ULONG_MAX - sizeof(*Filter))) / sizeof(*SourceList))) {
691          WSASetLastError(WSAENOBUFS);
692          return SOCKET_ERROR;
693      }
694      Size = GROUP_FILTER_SIZE(*SourceCount);
695      Filter = (PGROUP_FILTER) HeapAlloc(GetProcessHeap(), 0, Size);
696      if (Filter == NULL) {
697          WSASetLastError(WSAENOBUFS);
698          return SOCKET_ERROR;
699      }
700      Filter->gf_interface = Interface;
701      ZeroMemory(&Filter->gf_group, sizeof(Filter->gf_group));
702      CopyMemory(&Filter->gf_group, Group, GroupLength);
703      Filter->gf_numsrc = *SourceCount;
704      Error = WSAIoctl(Socket, SIOCGMSFILTER, Filter, Size, Filter, Size,
705                       &Returned, NULL, NULL);
706      if (Error == 0) {
707          if (*SourceCount > 0) {
708              CopyMemory(SourceList, Filter->gf_slist,
709                         *SourceCount * sizeof(*SourceList));
710              *SourceCount = Filter->gf_numsrc;
711          }
712          *FilterMode = Filter->gf_fmode;
713      }
714      HeapFree(GetProcessHeap(), 0, Filter);
715      return Error;
716  }
717  #endif &bsol;* INCL_WINSOCK_API_PROTOTYPES */
718  #endif
719  #ifdef IDEAL_SEND_BACKLOG_IOCTLS
720  #if INCL_WINSOCK_API_PROTOTYPES
721  WS2TCPIP_INLINE 
722  int  
723  idealsendbacklogquery(
724      _In_ SOCKET s,
725      _Out_ ULONG *pISB
726      )
727  {
728      DWORD bytes;
729      return WSAIoctl(s, SIO_IDEAL_SEND_BACKLOG_QUERY, 
730                      NULL, 0, pISB, sizeof(*pISB), &bytes, NULL, NULL);
731  }
732  WS2TCPIP_INLINE 
733  int  
734  idealsendbacklognotify(
735      _In_ SOCKET s,
736      _In_opt_ LPWSAOVERLAPPED lpOverlapped,
737      _In_opt_ LPWSAOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine
738      )
739  {
740      DWORD bytes;
741      return WSAIoctl(s, SIO_IDEAL_SEND_BACKLOG_CHANGE, 
742                      NULL, 0, NULL, 0, &bytes, 
743                      lpOverlapped, lpCompletionRoutine);
744  }
745  #endif &bsol;* INCL_WINSOCK_API_PROTOTYPES */
746  #endif
747  #if (_WIN32_WINNT >= 0x0600)
748  #ifdef _SECURE_SOCKET_TYPES_DEFINED_
749  WINSOCK_API_LINKAGE
750  INT
751  WSAAPI
752  WSASetSocketSecurity (
753     _In_ SOCKET Socket,
754     _In_reads_bytes_opt_(SecuritySettingsLen) const SOCKET_SECURITY_SETTINGS* SecuritySettings,
755     _In_ ULONG SecuritySettingsLen,
756     _In_opt_ LPWSAOVERLAPPED Overlapped,
757     _In_opt_ LPWSAOVERLAPPED_COMPLETION_ROUTINE CompletionRoutine
758  );
759  WINSOCK_API_LINKAGE
760  INT
761  WSAAPI
762  WSAQuerySocketSecurity (
763     _In_ SOCKET Socket,
764     _In_reads_bytes_opt_(SecurityQueryTemplateLen) const SOCKET_SECURITY_QUERY_TEMPLATE* SecurityQueryTemplate,
765     _In_ ULONG SecurityQueryTemplateLen,
766     _Out_writes_bytes_to_opt_(*SecurityQueryInfoLen, *SecurityQueryInfoLen) SOCKET_SECURITY_QUERY_INFO* SecurityQueryInfo,
767     _Inout_ ULONG* SecurityQueryInfoLen,
768     _In_opt_ LPWSAOVERLAPPED Overlapped,
769     _In_opt_ LPWSAOVERLAPPED_COMPLETION_ROUTINE CompletionRoutine
770  );
771  WINSOCK_API_LINKAGE
772  INT
773  WSAAPI
774  WSASetSocketPeerTargetName (
775     _In_ SOCKET Socket,
776     _In_reads_bytes_(PeerTargetNameLen) const SOCKET_PEER_TARGET_NAME* PeerTargetName,
777     _In_ ULONG PeerTargetNameLen,
778     _In_opt_ LPWSAOVERLAPPED Overlapped,
779     _In_opt_ LPWSAOVERLAPPED_COMPLETION_ROUTINE CompletionRoutine
780  );
781  WINSOCK_API_LINKAGE
782  INT
783  WSAAPI
784  WSADeleteSocketPeerTargetName (
785     _In_ SOCKET Socket,
786     _In_reads_bytes_(PeerAddrLen) const struct sockaddr* PeerAddr,
787     _In_ ULONG PeerAddrLen,
788     _In_opt_ LPWSAOVERLAPPED Overlapped,
789     _In_opt_ LPWSAOVERLAPPED_COMPLETION_ROUTINE CompletionRoutine
790  );
791  WINSOCK_API_LINKAGE
792  INT
793  WSAAPI
794  WSAImpersonateSocketPeer (
795     _In_ SOCKET Socket,
796     _In_reads_bytes_opt_(PeerAddrLen) const struct sockaddr* PeerAddr,
797     _In_ ULONG PeerAddrLen
798  );
799  WINSOCK_API_LINKAGE
800  INT
801  WSAAPI
802  WSARevertImpersonation ();
803  #endif 
804  #endif 
805  #ifdef __cplusplus
806  }
807  #endif
808  #if !defined(_WIN32_WINNT) || (_WIN32_WINNT <= 0x0500)
809  #include <wspiapi.h>
810  #endif
811  #endif &bsol;* WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP) */
812  #pragma endregion
813  #endif  &bsol;* _WS2TCPIP_H_ */
</code></pre>
        </div>
        <div class="column">
            <h3>Adafruit_nRF52_Arduino-MDEwOlJlcG9zaXRvcnk3NDM1NDcyOQ==-flat-nrfx_spim.c</h3>
            <pre><code>1  #include <nrfx.h>
2  #if NRFX_CHECK(NRFX_SPIM_ENABLED)
3  #if !(NRFX_CHECK(NRFX_SPIM0_ENABLED) || NRFX_CHECK(NRFX_SPIM1_ENABLED) || \
4        NRFX_CHECK(NRFX_SPIM2_ENABLED) || NRFX_CHECK(NRFX_SPIM3_ENABLED) || \
5        NRFX_CHECK(NRFX_SPIM4_ENABLED))
6  #error "No enabled SPIM instances. Check <nrfx_config.h>."
7  #endif
8  #include <nrfx_spim.h>
9  #include "prs/nrfx_prs.h"
10  #include <hal/nrf_gpio.h>
11  #define NRFX_LOG_MODULE SPIM
12  #include <nrfx_log.h>
13  #if NRFX_CHECK(NRFX_SPIM_EXTENDED_ENABLED) && \
14      ((!NRF_SPIM_HW_CSN_PRESENT) || !(NRF_SPIM_DCX_PRESENT) || !(NRF_SPIM_RXDELAY_PRESENT))
15  #error "Extended options are not available in the SoC currently in use."
16  #endif
17  #define SPIMX_LENGTH_VALIDATE(peripheral, drv_inst_idx, rx_len, tx_len) \
18      (((drv_inst_idx) == NRFX_CONCAT_3(NRFX_, peripheral, _INST_IDX)) && \
19       NRFX_EASYDMA_LENGTH_VALIDATE(peripheral, rx_len, tx_len))
20  #define SPIMX_HW_CSN_PRESENT_VALIDATE(peripheral, drv_inst_idx)         \
21      (((drv_inst_idx) == NRFX_CONCAT_3(NRFX_, peripheral, _INST_IDX)) && \
22       NRFX_CONCAT_2(peripheral, _FEATURE_HARDWARE_CSN_PRESENT))
23  #define SPIMX_DCX_PRESENT_VALIDATE(peripheral, drv_inst_idx)            \
24      (((drv_inst_idx) == NRFX_CONCAT_3(NRFX_, peripheral, _INST_IDX)) && \
25      NRFX_CONCAT_2(peripheral, _FEATURE_DCX_PRESENT))
26  #define SPIMX_SUPPORTED_FREQ_VALIDATE(peripheral, drv_inst_idx, freq)                            \
27      (                                                                                            \
28      ((drv_inst_idx) == NRFX_CONCAT_3(NRFX_, peripheral, _INST_IDX)) &&                           \
29      (                                                                                            \
30          (((freq) != NRF_SPIM_FREQ_16M) && ((freq) != NRF_SPIM_FREQ_32M)) ||                      \
31          (((freq) == NRF_SPIM_FREQ_16M) && ((NRFX_CONCAT_2(peripheral, _MAX_DATARATE) >= 16))) || \
32          (((freq) == NRF_SPIM_FREQ_32M) && ((NRFX_CONCAT_2(peripheral, _MAX_DATARATE) >= 32)))    \
33      )                                                                                            \
34      )
35  #if NRFX_CHECK(NRFX_SPIM0_ENABLED)
36  #define SPIM0_LENGTH_VALIDATE(...)          SPIMX_LENGTH_VALIDATE(SPIM0, __VA_ARGS__)
37  #define SPIM0_HW_CSN_PRESENT_VALIDATE(...)  SPIMX_HW_CSN_PRESENT_VALIDATE(SPIM0, __VA_ARGS__)
38  #define SPIM0_DCX_PRESENT_VALIDATE(...)     SPIMX_DCX_PRESENT_VALIDATE(SPIM0, __VA_ARGS__)
39  #define SPIM0_SUPPORTED_FREQ_VALIDATE(...)  SPIMX_SUPPORTED_FREQ_VALIDATE(SPIM0, __VA_ARGS__)
40  #else
41  #define SPIM0_LENGTH_VALIDATE(...)          0
42  #define SPIM0_HW_CSN_PRESENT_VALIDATE(...)  0
43  #define SPIM0_DCX_PRESENT_VALIDATE(...)     0
44  #define SPIM0_SUPPORTED_FREQ_VALIDATE(...)  0
45  #endif
46  #if NRFX_CHECK(NRFX_SPIM1_ENABLED)
47  #define SPIM1_LENGTH_VALIDATE(...)          SPIMX_LENGTH_VALIDATE(SPIM1, __VA_ARGS__)
48  #define SPIM1_HW_CSN_PRESENT_VALIDATE(...)  SPIMX_HW_CSN_PRESENT_VALIDATE(SPIM1, __VA_ARGS__)
49  #define SPIM1_DCX_PRESENT_VALIDATE(...)     SPIMX_DCX_PRESENT_VALIDATE(SPIM1, __VA_ARGS__)
50  #define SPIM1_SUPPORTED_FREQ_VALIDATE(...)  SPIMX_SUPPORTED_FREQ_VALIDATE(SPIM1, __VA_ARGS__)
51  #else
52  #define SPIM1_LENGTH_VALIDATE(...)          0
53  #define SPIM1_HW_CSN_PRESENT_VALIDATE(...)  0
54  #define SPIM1_DCX_PRESENT_VALIDATE(...)     0
55  #define SPIM1_SUPPORTED_FREQ_VALIDATE(...)  0
56  #endif
57  #if NRFX_CHECK(NRFX_SPIM2_ENABLED)
58  #define SPIM2_LENGTH_VALIDATE(...)          SPIMX_LENGTH_VALIDATE(SPIM2, __VA_ARGS__)
59  #define SPIM2_HW_CSN_PRESENT_VALIDATE(...)  SPIMX_HW_CSN_PRESENT_VALIDATE(SPIM2, __VA_ARGS__)
60  #define SPIM2_DCX_PRESENT_VALIDATE(...)     SPIMX_DCX_PRESENT_VALIDATE(SPIM2, __VA_ARGS__)
61  #define SPIM2_SUPPORTED_FREQ_VALIDATE(...)  SPIMX_SUPPORTED_FREQ_VALIDATE(SPIM2, __VA_ARGS__)
62  #else
63  #define SPIM2_LENGTH_VALIDATE(...)          0
64  #define SPIM2_HW_CSN_PRESENT_VALIDATE(...)  0
65  #define SPIM2_DCX_PRESENT_VALIDATE(...)     0
66  #define SPIM2_SUPPORTED_FREQ_VALIDATE(...)  0
67  #endif
68  #if NRFX_CHECK(NRFX_SPIM3_ENABLED)
69  #define SPIM3_LENGTH_VALIDATE(...)          SPIMX_LENGTH_VALIDATE(SPIM3, __VA_ARGS__)
70  #define SPIM3_HW_CSN_PRESENT_VALIDATE(...)  SPIMX_HW_CSN_PRESENT_VALIDATE(SPIM3, __VA_ARGS__)
71  #define SPIM3_DCX_PRESENT_VALIDATE(...)     SPIMX_DCX_PRESENT_VALIDATE(SPIM3, __VA_ARGS__)
72  #define SPIM3_SUPPORTED_FREQ_VALIDATE(...)  SPIMX_SUPPORTED_FREQ_VALIDATE(SPIM3, __VA_ARGS__)
73  #else
74  #define SPIM3_LENGTH_VALIDATE(...)          0
75  #define SPIM3_HW_CSN_PRESENT_VALIDATE(...)  0
76  #define SPIM3_DCX_PRESENT_VALIDATE(...)     0
77  #define SPIM3_SUPPORTED_FREQ_VALIDATE(...)  0
78  #endif
79  #if NRFX_CHECK(NRFX_SPIM4_ENABLED)
80  #define SPIM4_LENGTH_VALIDATE(...)          SPIMX_LENGTH_VALIDATE(SPIM4, __VA_ARGS__)
81  #define SPIM4_HW_CSN_PRESENT_VALIDATE(...)  SPIMX_HW_CSN_PRESENT_VALIDATE(SPIM4, __VA_ARGS__)
82  #define SPIM4_DCX_PRESENT_VALIDATE(...)     SPIMX_DCX_PRESENT_VALIDATE(SPIM4, __VA_ARGS__)
83  #define SPIM4_SUPPORTED_FREQ_VALIDATE(...)  SPIMX_SUPPORTED_FREQ_VALIDATE(SPIM4, __VA_ARGS__)
84  #else
85  #define SPIM4_LENGTH_VALIDATE(...)          0
86  #define SPIM4_HW_CSN_PRESENT_VALIDATE(...)  0
87  #define SPIM4_DCX_PRESENT_VALIDATE(...)     0
88  #define SPIM4_SUPPORTED_FREQ_VALIDATE(...)  0
89  #endif
90  #define SPIM_LENGTH_VALIDATE(drv_inst_idx, rx_len, tx_len)  \
91      (SPIM0_LENGTH_VALIDATE(drv_inst_idx, rx_len, tx_len) || \
92       SPIM1_LENGTH_VALIDATE(drv_inst_idx, rx_len, tx_len) || \
93       SPIM2_LENGTH_VALIDATE(drv_inst_idx, rx_len, tx_len) || \
94       SPIM3_LENGTH_VALIDATE(drv_inst_idx, rx_len, tx_len) || \
95       SPIM4_LENGTH_VALIDATE(drv_inst_idx, rx_len, tx_len))
96  #define SPIM_HW_CSN_PRESENT_VALIDATE(drv_inst_idx)  \
97      (SPIM0_HW_CSN_PRESENT_VALIDATE(drv_inst_idx) || \
98       SPIM1_HW_CSN_PRESENT_VALIDATE(drv_inst_idx) || \
99       SPIM2_HW_CSN_PRESENT_VALIDATE(drv_inst_idx) || \
100       SPIM3_HW_CSN_PRESENT_VALIDATE(drv_inst_idx) || \
101       SPIM4_HW_CSN_PRESENT_VALIDATE(drv_inst_idx))
102  #define SPIM_DCX_PRESENT_VALIDATE(drv_inst_idx)  \
103      (SPIM0_DCX_PRESENT_VALIDATE(drv_inst_idx) || \
104       SPIM1_DCX_PRESENT_VALIDATE(drv_inst_idx) || \
105       SPIM2_DCX_PRESENT_VALIDATE(drv_inst_idx) || \
106       SPIM3_DCX_PRESENT_VALIDATE(drv_inst_idx) || \
107       SPIM4_DCX_PRESENT_VALIDATE(drv_inst_idx))
108  #define SPIM_SUPPORTED_FREQ_VALIDATE(drv_inst_idx, freq)  \
109      (SPIM0_SUPPORTED_FREQ_VALIDATE(drv_inst_idx, freq) || \
110       SPIM1_SUPPORTED_FREQ_VALIDATE(drv_inst_idx, freq) || \
111       SPIM2_SUPPORTED_FREQ_VALIDATE(drv_inst_idx, freq) || \
112       SPIM3_SUPPORTED_FREQ_VALIDATE(drv_inst_idx, freq) || \
113       SPIM4_SUPPORTED_FREQ_VALIDATE(drv_inst_idx, freq))
114  #if defined(NRF52840_XXAA) && (NRFX_CHECK(NRFX_SPIM3_ENABLED))
115  #define USE_WORKAROUND_FOR_ANOMALY_195
116  #endif
117  typedef struct
118  {
<span onclick='openModal()' class='match'>119      nrfx_spim_evt_handler_t handler;
120      void *                  p_context;
121      nrfx_spim_evt_t         evt;  
122      nrfx_drv_state_t        state;
123      volatile bool           transfer_in_progress;
124  #if NRFX_CHECK(NRFX_SPIM_EXTENDED_ENABLED)
125      bool                    use_hw_ss;
126  #endif
127      bool            ss_active_high;
128      uint8_t         ss_pin;
129      uint8_t         miso_pin;
130      uint8_t         orc;
131  #if NRFX_CHECK(NRFX_SPIM_NRF52_ANOMALY_109_WORKAROUND_ENABLED)
132      size_t          tx_length;
133      size_t          rx_length;
</span>134  #endif
135  } spim_control_block_t;
136  static spim_control_block_t m_cb[NRFX_SPIM_ENABLED_COUNT];
137  #if NRFX_CHECK(NRFX_SPIM3_NRF52840_ANOMALY_198_WORKAROUND_ENABLED)
138  static uint32_t m_anomaly_198_preserved_value;
139  static void anomaly_198_enable(uint8_t const * p_buffer, size_t buf_len)
140  {
141      m_anomaly_198_preserved_value = *((volatile uint32_t *)0x40000E00);
142      if (buf_len == 0)
143      {
144          return;
145      }
146      uint32_t buffer_end_addr = ((uint32_t)p_buffer) + buf_len;
147      uint32_t block_addr      = ((uint32_t)p_buffer) & ~0x1FFF;
148      uint32_t block_flag      = (1UL << ((block_addr >> 13) & 0xFFFF));
149      uint32_t occupied_blocks = 0;
150      if (block_addr >= 0x20010000)
151      {
152          occupied_blocks = (1UL << 8);
153      }
154      else
155      {
156          do {
157              occupied_blocks |= block_flag;
158              block_flag <<= 1;
159              block_addr  += 0x2000;
160          } while ((block_addr < buffer_end_addr) && (block_addr < 0x20012000));
161      }
162      *((volatile uint32_t *)0x40000E00) = occupied_blocks;
163  }
164  static void anomaly_198_disable(void)
165  {
166      *((volatile uint32_t *)0x40000E00) = m_anomaly_198_preserved_value;
167  }
168  #endif 
169  nrfx_err_t nrfx_spim_init(nrfx_spim_t const *        p_instance,
170                            nrfx_spim_config_t const * p_config,
171                            nrfx_spim_evt_handler_t    handler,
172                            void *                     p_context)
173  {
174      NRFX_ASSERT(p_config);
175      spim_control_block_t * p_cb = &m_cb[p_instance->drv_inst_idx];
176      nrfx_err_t err_code;
177      if (p_cb->state != NRFX_DRV_STATE_UNINITIALIZED)
178      {
179          err_code = NRFX_ERROR_INVALID_STATE;
180          NRFX_LOG_WARNING("Function: %s, error code: %s.",
181                           __func__,
182                           NRFX_LOG_ERROR_STRING_GET(err_code));
183          return err_code;
184      }
185  #if NRFX_CHECK(NRFX_SPIM_EXTENDED_ENABLED)
186      if (
187          (!SPIM_SUPPORTED_FREQ_VALIDATE(p_instance->drv_inst_idx, p_config->frequency)) ||
188          ((p_config->use_hw_ss) &&
189           !SPIM_HW_CSN_PRESENT_VALIDATE(p_instance->drv_inst_idx)) ||
190          ((p_config->dcx_pin != NRFX_SPIM_PIN_NOT_USED) &&
191           !SPIM_DCX_PRESENT_VALIDATE(p_instance->drv_inst_idx))
192          )
193      {
194          err_code = NRFX_ERROR_NOT_SUPPORTED;
195          NRFX_LOG_WARNING("Function: %s, error code: %s.",
196                           __func__,
197                           NRFX_LOG_ERROR_STRING_GET(err_code));
198          return err_code;
199      }
200  #endif
201      NRF_SPIM_Type * p_spim = (NRF_SPIM_Type *)p_instance->p_reg;
202  #if NRFX_CHECK(NRFX_PRS_ENABLED)
203      static nrfx_irq_handler_t const irq_handlers[NRFX_SPIM_ENABLED_COUNT] = {
204          #if NRFX_CHECK(NRFX_SPIM0_ENABLED)
205          nrfx_spim_0_irq_handler,
206          #endif
207          #if NRFX_CHECK(NRFX_SPIM1_ENABLED)
208          nrfx_spim_1_irq_handler,
209          #endif
210          #if NRFX_CHECK(NRFX_SPIM2_ENABLED)
211          nrfx_spim_2_irq_handler,
212          #endif
213          #if NRFX_CHECK(NRFX_SPIM3_ENABLED)
214          nrfx_spim_3_irq_handler,
215          #endif
216          #if NRFX_CHECK(NRFX_SPIM4_ENABLED)
217          nrfx_spim_4_irq_handler,
218          #endif
219      };
220      if (nrfx_prs_acquire(p_instance->p_reg,
221              irq_handlers[p_instance->drv_inst_idx]) != NRFX_SUCCESS)
222      {
223          err_code = NRFX_ERROR_BUSY;
224          NRFX_LOG_WARNING("Function: %s, error code: %s.",
225                           __func__,
226                           NRFX_LOG_ERROR_STRING_GET(err_code));
227          return err_code;
228      }
229  #endif 
230      p_cb->handler = handler;
231      p_cb->p_context = p_context;
232      uint32_t mosi_pin;
233      uint32_t miso_pin;
234      if (p_config->mode <= NRF_SPIM_MODE_1)
235      {
236          nrf_gpio_pin_clear(p_config->sck_pin);
237      }
238      else
239      {
240          nrf_gpio_pin_set(p_config->sck_pin);
241      }
242      nrf_gpio_cfg(p_config->sck_pin,
243                   NRF_GPIO_PIN_DIR_OUTPUT,
244                   NRF_GPIO_PIN_INPUT_CONNECT,
245                   NRF_GPIO_PIN_NOPULL,
246                   NRF_GPIO_PIN_S0S1,
247                   NRF_GPIO_PIN_NOSENSE);
248      if (p_config->mosi_pin != NRFX_SPIM_PIN_NOT_USED)
249      {
250          mosi_pin = p_config->mosi_pin;
251          nrf_gpio_pin_clear(mosi_pin);
252          nrf_gpio_cfg_output(mosi_pin);
253      }
254      else
255      {
256          mosi_pin = NRF_SPIM_PIN_NOT_CONNECTED;
257      }
258      if (p_config->miso_pin != NRFX_SPIM_PIN_NOT_USED)
259      {
260          miso_pin = p_config->miso_pin;
261          nrf_gpio_cfg_input(miso_pin, p_config->miso_pull);
262      }
263      else
264      {
265          miso_pin = NRF_SPIM_PIN_NOT_CONNECTED;
266      }
267      p_cb->miso_pin = p_config->miso_pin;
268      p_cb->ss_pin = p_config->ss_pin;
269      if (p_config->ss_pin != NRFX_SPIM_PIN_NOT_USED)
270      {
271          if (p_config->ss_active_high)
272          {
273              nrf_gpio_pin_clear(p_config->ss_pin);
274          }
275          else
276          {
277              nrf_gpio_pin_set(p_config->ss_pin);
278          }
279          nrf_gpio_cfg_output(p_config->ss_pin);
280  #if NRFX_CHECK(NRFX_SPIM_EXTENDED_ENABLED)
281          if (p_config->use_hw_ss)
282          {
283              p_cb->use_hw_ss = p_config->use_hw_ss;
284              nrf_spim_csn_configure(p_spim,
285                                     p_config->ss_pin,
286                                     (p_config->ss_active_high == true ?
287                                          NRF_SPIM_CSN_POL_HIGH : NRF_SPIM_CSN_POL_LOW),
288                                     p_config->ss_duration);
289          }
290  #endif
291          p_cb->ss_active_high = p_config->ss_active_high;
292      }
293  #if NRFX_CHECK(NRFX_SPIM_EXTENDED_ENABLED)
294      if (p_config->dcx_pin != NRFX_SPIM_PIN_NOT_USED)
295      {
296          nrf_gpio_pin_set(p_config->dcx_pin);
297          nrf_gpio_cfg_output(p_config->dcx_pin);
298          nrf_spim_dcx_pin_set(p_spim, p_config->dcx_pin);
299      }
300      nrf_spim_iftiming_set(p_spim, p_config->rx_delay);
301  #endif
302      nrf_spim_pins_set(p_spim, p_config->sck_pin, mosi_pin, miso_pin);
303      nrf_spim_frequency_set(p_spim, p_config->frequency);
304      nrf_spim_configure(p_spim, p_config->mode, p_config->bit_order);
305      nrf_spim_orc_set(p_spim, p_config->orc);
306      if (p_cb->handler)
307      {
308          nrf_spim_int_enable(p_spim, NRF_SPIM_INT_END_MASK);
309      }
310      nrf_spim_enable(p_spim);
311      if (p_cb->handler)
312      {
313          NRFX_IRQ_PRIORITY_SET(nrfx_get_irq_number(p_instance->p_reg),
314              p_config->irq_priority);
315          NRFX_IRQ_ENABLE(nrfx_get_irq_number(p_instance->p_reg));
316      }
317      p_cb->transfer_in_progress = false;
318      p_cb->state = NRFX_DRV_STATE_INITIALIZED;
319      err_code = NRFX_SUCCESS;
320      NRFX_LOG_INFO("Function: %s, error code: %s.", __func__, NRFX_LOG_ERROR_STRING_GET(err_code));
321      return err_code;
322  }
323  void nrfx_spim_uninit(nrfx_spim_t const * p_instance)
324  {
325      spim_control_block_t * p_cb = &m_cb[p_instance->drv_inst_idx];
326      NRFX_ASSERT(p_cb->state != NRFX_DRV_STATE_UNINITIALIZED);
327      if (p_cb->handler)
328      {
329          NRFX_IRQ_DISABLE(nrfx_get_irq_number(p_instance->p_reg));
330      }
331      NRF_SPIM_Type * p_spim = (NRF_SPIM_Type *)p_instance->p_reg;
332      if (p_cb->handler)
333      {
334          nrf_spim_int_disable(p_spim, NRF_SPIM_ALL_INTS_MASK);
335          if (p_cb->transfer_in_progress)
336          {
337              nrf_spim_task_trigger(p_spim, NRF_SPIM_TASK_STOP);
338              while (!nrf_spim_event_check(p_spim, NRF_SPIM_EVENT_STOPPED))
339              {}
340              p_cb->transfer_in_progress = false;
341          }
342      }
343      if (p_cb->miso_pin != NRFX_SPIM_PIN_NOT_USED)
344      {
345          nrf_gpio_cfg_default(p_cb->miso_pin);
346      }
347      nrf_spim_disable(p_spim);
348  #ifdef USE_WORKAROUND_FOR_ANOMALY_195
349      if (p_spim == NRF_SPIM3)
350      {
351          *(volatile uint32_t *)0x4002F004 = 1;
352      }
353  #endif
354  #if NRFX_CHECK(NRFX_PRS_ENABLED)
355      nrfx_prs_release(p_instance->p_reg);
356  #endif
357      p_cb->state = NRFX_DRV_STATE_UNINITIALIZED;
358  }
359  #if NRFX_CHECK(NRFX_SPIM_EXTENDED_ENABLED)
360  nrfx_err_t nrfx_spim_xfer_dcx(nrfx_spim_t const *           p_instance,
361                                nrfx_spim_xfer_desc_t const * p_xfer_desc,
362                                uint32_t                      flags,
363                                uint8_t                       cmd_length)
364  {
365      NRFX_ASSERT(cmd_length <= NRF_SPIM_DCX_CNT_ALL_CMD);
366      nrf_spim_dcx_cnt_set((NRF_SPIM_Type *)p_instance->p_reg, cmd_length);
367      return nrfx_spim_xfer(p_instance, p_xfer_desc, 0);
368  }
369  #endif
370  static void finish_transfer(spim_control_block_t * p_cb)
371  {
372      if (p_cb->ss_pin != NRFX_SPIM_PIN_NOT_USED)
373      {
374  #if NRFX_CHECK(NRFX_SPIM_EXTENDED_ENABLED)
375          if (!p_cb->use_hw_ss)
376  #endif
377          {
378              if (p_cb->ss_active_high)
379              {
380                  nrf_gpio_pin_clear(p_cb->ss_pin);
381              }
382              else
383              {
384                  nrf_gpio_pin_set(p_cb->ss_pin);
385              }
386          }
387      }
388      p_cb->transfer_in_progress = false;
389      p_cb->evt.type = NRFX_SPIM_EVENT_DONE;
390      p_cb->handler(&p_cb->evt, p_cb->p_context);
391  }
392  static void spim_int_enable(NRF_SPIM_Type * p_spim, bool enable)
393  {
394      if (!enable)
395      {
396          nrf_spim_int_disable(p_spim, NRF_SPIM_INT_END_MASK);
397      }
398      else
399      {
400          nrf_spim_int_enable(p_spim, NRF_SPIM_INT_END_MASK);
401      }
402  }
403  static void spim_list_enable_handle(NRF_SPIM_Type * p_spim, uint32_t flags)
404  {
405      if (NRFX_SPIM_FLAG_TX_POSTINC & flags)
406      {
407          nrf_spim_tx_list_enable(p_spim);
408      }
409      else
410      {
411          nrf_spim_tx_list_disable(p_spim);
412      }
413      if (NRFX_SPIM_FLAG_RX_POSTINC & flags)
414      {
415          nrf_spim_rx_list_enable(p_spim);
416      }
417      else
418      {
419          nrf_spim_rx_list_disable(p_spim);
420      }
421  }
422  static nrfx_err_t spim_xfer(NRF_SPIM_Type               * p_spim,
423                              spim_control_block_t        * p_cb,
424                              nrfx_spim_xfer_desc_t const * p_xfer_desc,
425                              uint32_t                      flags)
426  {
427      nrfx_err_t err_code;
428      if ((p_xfer_desc->p_tx_buffer != NULL && !nrfx_is_in_ram(p_xfer_desc->p_tx_buffer)) ||
429          (p_xfer_desc->p_rx_buffer != NULL && !nrfx_is_in_ram(p_xfer_desc->p_rx_buffer)))
430      {
431          p_cb->transfer_in_progress = false;
432          err_code = NRFX_ERROR_INVALID_ADDR;
433          NRFX_LOG_WARNING("Function: %s, error code: %s.",
434                           __func__,
435                           NRFX_LOG_ERROR_STRING_GET(err_code));
436          return err_code;
437      }
438  #if NRFX_CHECK(NRFX_SPIM_NRF52_ANOMALY_109_WORKAROUND_ENABLED)
439      p_cb->tx_length = 0;
440      p_cb->rx_length = 0;
441  #endif
442      nrf_spim_tx_buffer_set(p_spim, p_xfer_desc->p_tx_buffer, p_xfer_desc->tx_length);
443      nrf_spim_rx_buffer_set(p_spim, p_xfer_desc->p_rx_buffer, p_xfer_desc->rx_length);
444  #if NRFX_CHECK(NRFX_SPIM3_NRF52840_ANOMALY_198_WORKAROUND_ENABLED)
445      if (p_spim == NRF_SPIM3)
446      {
447          anomaly_198_enable(p_xfer_desc->p_tx_buffer, p_xfer_desc->tx_length);
448      }
449  #endif
450      nrf_spim_event_clear(p_spim, NRF_SPIM_EVENT_END);
451      spim_list_enable_handle(p_spim, flags);
452      if (!(flags & NRFX_SPIM_FLAG_HOLD_XFER))
453      {
454          nrf_spim_task_trigger(p_spim, NRF_SPIM_TASK_START);
455      }
456  #if NRFX_CHECK(NRFX_SPIM_NRF52_ANOMALY_109_WORKAROUND_ENABLED)
457      if (flags & NRFX_SPIM_FLAG_HOLD_XFER)
458      {
459          nrf_spim_event_clear(p_spim, NRF_SPIM_EVENT_STARTED);
460          p_cb->tx_length = p_xfer_desc->tx_length;
461          p_cb->rx_length = p_xfer_desc->rx_length;
462          nrf_spim_tx_buffer_set(p_spim, p_xfer_desc->p_tx_buffer, 0);
463          nrf_spim_rx_buffer_set(p_spim, p_xfer_desc->p_rx_buffer, 0);
464          nrf_spim_int_enable(p_spim, NRF_SPIM_INT_STARTED_MASK);
465      }
466  #endif
467      if (!p_cb->handler)
468      {
469          while (!nrf_spim_event_check(p_spim, NRF_SPIM_EVENT_END)){}
470  #if NRFX_CHECK(NRFX_SPIM3_NRF52840_ANOMALY_198_WORKAROUND_ENABLED)
471          if (p_spim == NRF_SPIM3)
472          {
473              anomaly_198_disable();
474          }
475  #endif
476          if (p_cb->ss_pin != NRFX_SPIM_PIN_NOT_USED)
477          {
478  #if NRFX_CHECK(NRFX_SPIM_EXTENDED_ENABLED)
479              if (!p_cb->use_hw_ss)
480  #endif
481              {
482                  if (p_cb->ss_active_high)
483                  {
484                      nrf_gpio_pin_clear(p_cb->ss_pin);
485                  }
486                  else
487                  {
488                      nrf_gpio_pin_set(p_cb->ss_pin);
489                  }
490              }
491          }
492      }
493      else
494      {
495          spim_int_enable(p_spim, !(flags & NRFX_SPIM_FLAG_NO_XFER_EVT_HANDLER));
496      }
497      err_code = NRFX_SUCCESS;
498      NRFX_LOG_INFO("Function: %s, error code: %s.", __func__, NRFX_LOG_ERROR_STRING_GET(err_code));
499      return err_code;
500  }
501  nrfx_err_t nrfx_spim_xfer(nrfx_spim_t const *           p_instance,
502                            nrfx_spim_xfer_desc_t const * p_xfer_desc,
503                            uint32_t                      flags)
504  {
505      spim_control_block_t * p_cb = &m_cb[p_instance->drv_inst_idx];
506      NRFX_ASSERT(p_cb->state != NRFX_DRV_STATE_UNINITIALIZED);
507      NRFX_ASSERT(p_xfer_desc->p_tx_buffer != NULL || p_xfer_desc->tx_length == 0);
508      NRFX_ASSERT(p_xfer_desc->p_rx_buffer != NULL || p_xfer_desc->rx_length == 0);
509      NRFX_ASSERT(SPIM_LENGTH_VALIDATE(p_instance->drv_inst_idx,
510                                       p_xfer_desc->rx_length,
511                                       p_xfer_desc->tx_length));
512      nrfx_err_t err_code = NRFX_SUCCESS;
513      if (p_cb->transfer_in_progress)
514      {
515          err_code = NRFX_ERROR_BUSY;
516          NRFX_LOG_WARNING("Function: %s, error code: %s.",
517                           __func__,
518                           NRFX_LOG_ERROR_STRING_GET(err_code));
519          return err_code;
520      }
521      else
522      {
523          if (p_cb->handler && !(flags & (NRFX_SPIM_FLAG_REPEATED_XFER |
524                                          NRFX_SPIM_FLAG_NO_XFER_EVT_HANDLER)))
525          {
526              p_cb->transfer_in_progress = true;
527          }
528      }
529      p_cb->evt.xfer_desc = *p_xfer_desc;
530      if (p_cb->ss_pin != NRFX_SPIM_PIN_NOT_USED)
531      {
532  #if NRFX_CHECK(NRFX_SPIM_EXTENDED_ENABLED)
533          if (!p_cb->use_hw_ss)
534  #endif
535          {
536              if (p_cb->ss_active_high)
537              {
538                  nrf_gpio_pin_set(p_cb->ss_pin);
539              }
540              else
541              {
542                  nrf_gpio_pin_clear(p_cb->ss_pin);
543              }
544          }
545      }
546      return spim_xfer(p_instance->p_reg, p_cb,  p_xfer_desc, flags);
547  }
548  void nrfx_spim_abort(nrfx_spim_t const * p_instance)
549  {
550      spim_control_block_t * p_cb = &m_cb[p_instance->drv_inst_idx];
551      NRFX_ASSERT(p_cb->state != NRFX_DRV_STATE_UNINITIALIZED);
552      nrf_spim_task_trigger(p_instance->p_reg, NRF_SPIM_TASK_STOP);
553      while (!nrf_spim_event_check(p_instance->p_reg, NRF_SPIM_EVENT_STOPPED))
554      {}
555      p_cb->transfer_in_progress = false;
556  }
557  uint32_t nrfx_spim_start_task_get(nrfx_spim_t const * p_instance)
558  {
559      NRF_SPIM_Type * p_spim = (NRF_SPIM_Type *)p_instance->p_reg;
560      return nrf_spim_task_address_get(p_spim, NRF_SPIM_TASK_START);
561  }
562  uint32_t nrfx_spim_end_event_get(nrfx_spim_t const * p_instance)
563  {
564      NRF_SPIM_Type * p_spim = (NRF_SPIM_Type *)p_instance->p_reg;
565      return nrf_spim_event_address_get(p_spim, NRF_SPIM_EVENT_END);
566  }
567  static void irq_handler(NRF_SPIM_Type * p_spim, spim_control_block_t * p_cb)
568  {
569  #if NRFX_CHECK(NRFX_SPIM_NRF52_ANOMALY_109_WORKAROUND_ENABLED)
570      if ((nrf_spim_int_enable_check(p_spim, NRF_SPIM_INT_STARTED_MASK)) &&
571          (nrf_spim_event_check(p_spim, NRF_SPIM_EVENT_STARTED)) )
572      {
573          nrf_spim_event_clear(p_spim, NRF_SPIM_EVENT_STARTED);
574          nrf_spim_event_clear(p_spim, NRF_SPIM_EVENT_END);
575          NRFX_ASSERT(p_spim->TXD.MAXCNT == 0);
576          p_spim->TXD.MAXCNT = p_cb->tx_length;
577          NRFX_ASSERT(p_spim->RXD.MAXCNT == 0);
578          p_spim->RXD.MAXCNT = p_cb->rx_length;
579          nrf_spim_int_disable(p_spim, NRF_SPIM_INT_STARTED_MASK);
580          nrf_spim_task_trigger(p_spim, NRF_SPIM_TASK_START);
581          return;
582      }
583  #endif
584      if (nrf_spim_event_check(p_spim, NRF_SPIM_EVENT_END))
585      {
586  #if NRFX_CHECK(NRFX_SPIM3_NRF52840_ANOMALY_198_WORKAROUND_ENABLED)
587          if (p_spim == NRF_SPIM3)
588          {
589              anomaly_198_disable();
590          }
591  #endif
592          nrf_spim_event_clear(p_spim, NRF_SPIM_EVENT_END);
593          NRFX_ASSERT(p_cb->handler);
594          NRFX_LOG_DEBUG("Event: NRF_SPIM_EVENT_END.");
595          finish_transfer(p_cb);
596      }
597  }
598  #if NRFX_CHECK(NRFX_SPIM0_ENABLED)
599  void nrfx_spim_0_irq_handler(void)
600  {
601      irq_handler(NRF_SPIM0, &m_cb[NRFX_SPIM0_INST_IDX]);
602  }
603  #endif
604  #if NRFX_CHECK(NRFX_SPIM1_ENABLED)
605  void nrfx_spim_1_irq_handler(void)
606  {
607      irq_handler(NRF_SPIM1, &m_cb[NRFX_SPIM1_INST_IDX]);
608  }
609  #endif
610  #if NRFX_CHECK(NRFX_SPIM2_ENABLED)
611  void nrfx_spim_2_irq_handler(void)
612  {
613      irq_handler(NRF_SPIM2, &m_cb[NRFX_SPIM2_INST_IDX]);
614  }
615  #endif
616  #if NRFX_CHECK(NRFX_SPIM3_ENABLED)
617  void nrfx_spim_3_irq_handler(void)
618  {
619      irq_handler(NRF_SPIM3, &m_cb[NRFX_SPIM3_INST_IDX]);
620  }
621  #endif
622  #if NRFX_CHECK(NRFX_SPIM4_ENABLED)
623  void nrfx_spim_4_irq_handler(void)
624  {
625      irq_handler(NRF_SPIM4, &m_cb[NRFX_SPIM4_INST_IDX]);
626  }
627  #endif
628  #endif 
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from redis-MDEwOlJlcG9zaXRvcnkxMDgxMTA3MDY=-flat-WS2tcpip.h</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from Adafruit_nRF52_Arduino-MDEwOlJlcG9zaXRvcnk3NDM1NDcyOQ==-flat-nrfx_spim.c</div>
                </div>
                <div class="column column_space"><pre><code>35  typedef ADDRINFOW       ADDRINFOT, *PADDRINFOT;
36  #else
37  typedef ADDRINFOA       ADDRINFOT, *PADDRINFOT;
38  #endif
39  typedef ADDRINFOA       ADDRINFO, FAR * LPADDRINFO;
40  #if (_WIN32_WINNT >= 0x0600)
41  #ifdef UNICODE
42  typedef ADDRINFOEXW     ADDRINFOEX, *PADDRINFOEX;
43  #else
44  typedef ADDRINFOEXA     ADDRINFOEX, *PADDRINFOEX;
45  #endif
46  #endif
47  #ifdef __cplusplus
48  extern "C" {
49  #endif
50  #if INCL_WINSOCK_API_TYPEDEFS
51  WINSOCK_API_LINKAGE
52  INT
53  WSAAPI
54  getaddrinfo(
55      _In_opt_        PCSTR               pNodeName,
56      _In_opt_        PCSTR               pServiceName,
57      _In_opt_        const ADDRINFOA *   pHints,
58      _Outptr_     PADDRINFOA *        ppResult
59      );
60  #if (NTDDI_VERSION >= NTDDI_WINXPSP2) || (_WIN32_WINNT >= 0x0502)
61  WINSOCK_API_LINKAGE
62  INT
63  WSAAPI
64  GetAddrInfoW(
65      _In_opt_        PCWSTR              pNodeName,
66      _In_opt_        PCWSTR              pServiceName,
67      _In_opt_        const ADDRINFOW *   pHints,
</pre></code></div>
                <div class="column column_space"><pre><code>119      nrfx_spim_evt_handler_t handler;
120      void *                  p_context;
121      nrfx_spim_evt_t         evt;  
122      nrfx_drv_state_t        state;
123      volatile bool           transfer_in_progress;
124  #if NRFX_CHECK(NRFX_SPIM_EXTENDED_ENABLED)
125      bool                    use_hw_ss;
126  #endif
127      bool            ss_active_high;
128      uint8_t         ss_pin;
129      uint8_t         miso_pin;
130      uint8_t         orc;
131  #if NRFX_CHECK(NRFX_SPIM_NRF52_ANOMALY_109_WORKAROUND_ENABLED)
132      size_t          tx_length;
133      size_t          rx_length;
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    