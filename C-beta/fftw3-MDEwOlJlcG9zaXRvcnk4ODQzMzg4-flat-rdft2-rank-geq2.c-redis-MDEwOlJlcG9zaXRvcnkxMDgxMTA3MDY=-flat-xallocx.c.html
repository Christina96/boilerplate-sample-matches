
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 16.417910447761194%, Tokens: 8, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>fftw3-MDEwOlJlcG9zaXRvcnk4ODQzMzg4-flat-rdft2-rank-geq2.c</h3>
            <pre><code>1  #include "mpi-dft.h"
2  #include "mpi-rdft2.h"
3  #include "rdft/rdft.h"
4  typedef struct {
5       solver super;
6       int preserve_input; &bsol;* preserve input even if DESTROY_INPUT was passed */
7  } S;
8  typedef struct {
9       plan_mpi_rdft2 super;
10       plan *cld1, *cld2;
11       INT vn;
12       int preserve_input;
13  } P;
14  static void apply_r2c(const plan *ego_, R *I, R *O)
15  {
16       const P *ego = (const P *) ego_;
17       plan_rdft2 *cld1;
18       plan_rdft *cld2;
19       cld1 = (plan_rdft2 *) ego->cld1;
20       if (ego->preserve_input) {
21  	  cld1->apply(ego->cld1, I, I+ego->vn, O, O+1);
22  	  I = O;
23       }
24       else
25  	  cld1->apply(ego->cld1, I, I+ego->vn, I, I+1);
26       cld2 = (plan_rdft *) ego->cld2;
27       cld2->apply(ego->cld2, I, O);
28  }
29  static void apply_c2r(const plan *ego_, R *I, R *O)
30  {
31       const P *ego = (const P *) ego_;
32       plan_rdft2 *cld1;
33       plan_rdft *cld2;
34       cld2 = (plan_rdft *) ego->cld2;
35       cld2->apply(ego->cld2, I, O);
36       cld1 = (plan_rdft2 *) ego->cld1;
37       cld1->apply(ego->cld1, O, O+ego->vn, O, O+1);
38  }
39  static int applicable(const S *ego, const problem *p_,
40  		      const planner *plnr)
41  {
42       const problem_mpi_rdft2 *p = (const problem_mpi_rdft2 *) p_;
43       return (1
44  	     && p->sz->rnk > 1
45  	     && p->flags == 0 &bsol;* TRANSPOSED/SCRAMBLED_IN/OUT not supported */
46  	     && (!ego->preserve_input || (!NO_DESTROY_INPUTP(plnr)
47  					  && p->I != p->O
48  					  && p->kind == R2HC))
49  	     && XM(is_local_after)(1, p->sz, IB)
50  	     && XM(is_local_after)(1, p->sz, OB)
51  	     && (!NO_SLOWP(plnr) &bsol;* slow if rdft2-serial is applicable */
52  		 || !XM(rdft2_serial_applicable)(p))
53  	  );
54  }
55  static void awake(plan *ego_, enum wakefulness wakefulness)
56  {
57       P *ego = (P *) ego_;
58       X(plan_awake)(ego->cld1, wakefulness);
59       X(plan_awake)(ego->cld2, wakefulness);
60  }
61  static void destroy(plan *ego_)
62  {
63       P *ego = (P *) ego_;
64       X(plan_destroy_internal)(ego->cld2);
65       X(plan_destroy_internal)(ego->cld1);
66  }
67  static void print(const plan *ego_, printer *p)
68  {
69       const P *ego = (const P *) ego_;
70       p->print(p, "(mpi-rdft2-rank-geq2%s%(%p%)%(%p%))", 
71  	      ego->preserve_input==2 ?"/p":"", ego->cld1, ego->cld2);
72  }
73  static plan *mkplan(const solver *ego_, const problem *p_, planner *plnr)
74  {
75       const S *ego = (const S *) ego_;
76       const problem_mpi_rdft2 *p;
77       P *pln;
78       plan *cld1 = 0, *cld2 = 0;
79       R *r0, *r1, *cr, *ci, *I, *O;
80       tensor *sz;
81       dtensor *sz2;
82       int i, my_pe, n_pes;
83       INT nrest;
84       static const plan_adt padt = {
85            XM(rdft2_solve), awake, print, destroy
86       };
87       UNUSED(ego);
88       if (!applicable(ego, p_, plnr))
89            return (plan *) 0;
90       p = (const problem_mpi_rdft2 *) p_;
91       I = p->I; O = p->O;
92       if (p->kind == R2HC) {
93            r1 = (r0 = p->I) + p->vn;
94  	  if (ego->preserve_input || NO_DESTROY_INPUTP(plnr)) {
95  	       ci = (cr = p->O) + 1;
96  	       I = O; 
97  	  }
98  	  else 
99  	       ci = (cr = p->I) + 1;
100       }
101       else {
102            r1 = (r0 = p->O) + p->vn;
103            ci = (cr = p->O) + 1;
104       }
105       MPI_Comm_rank(p->comm, &my_pe);
106       MPI_Comm_size(p->comm, &n_pes);
107       sz = X(mktensor)(p->sz->rnk - 1); &bsol;* tensor of last rnk-1 dimensions */
108       i = p->sz->rnk - 2; A(i >= 0);
109       sz->dims[i].is = sz->dims[i].os = 2 * p->vn;
110       sz->dims[i].n = p->sz->dims[i+1].n / 2 + 1;
111       for (--i; i >= 0; --i) {
112  	  sz->dims[i].n = p->sz->dims[i+1].n;
113  	  sz->dims[i].is = sz->dims[i].os = sz->dims[i+1].n * sz->dims[i+1].is;
114       }
115       nrest = X(tensor_sz)(sz);
116       {
117  	  INT ivs = 1 + (p->kind == HC2R), ovs = 1 + (p->kind == R2HC);
118            INT is = sz->dims[0].n * sz->dims[0].is;
119            INT b = XM(block)(p->sz->dims[0].n, p->sz->dims[0].b[IB], my_pe);
120  	  sz->dims[p->sz->rnk - 2].n = p->sz->dims[p->sz->rnk - 1].n;
<span onclick='openModal()' class='match'>121  	  cld1 = X(mkplan_d)(plnr,
122                               X(mkproblem_rdft2_d)(sz,
123  						  X(mktensor_2d)(b, is, is,
124  							        p->vn,ivs,ovs),
125  						  r0, r1, cr, ci, p->kind));
126  	  if (XM(any_true)(!cld1, p->comm)) goto nada;
</span>127       }
128       sz2 = XM(mkdtensor)(1); &bsol;* tensor for first (distributed) dimension */
129       sz2->dims[0] = p->sz->dims[0];
130       cld2 = X(mkplan_d)(plnr, XM(mkproblem_dft_d)(sz2, nrest * p->vn,
131  						  I, O, p->comm, 
132  						  p->kind == R2HC ?
133  						  FFT_SIGN : -FFT_SIGN,
134  						  RANK1_BIGVEC_ONLY));
135       if (XM(any_true)(!cld2, p->comm)) goto nada;
136       pln = MKPLAN_MPI_RDFT2(P, &padt, p->kind == R2HC ? apply_r2c : apply_c2r);
137       pln->cld1 = cld1;
138       pln->cld2 = cld2;
139       pln->preserve_input = ego->preserve_input ? 2 : NO_DESTROY_INPUTP(plnr);
140       pln->vn = p->vn;
141       X(ops_add)(&cld1->ops, &cld2->ops, &pln->super.super.ops);
142       return &(pln->super.super);
143   nada:
144       X(plan_destroy_internal)(cld2);
145       X(plan_destroy_internal)(cld1);
146       return (plan *) 0;
147  }
148  static solver *mksolver(int preserve_input)
149  {
150       static const solver_adt sadt = { PROBLEM_MPI_RDFT2, mkplan, 0 };
151       S *slv = MKSOLVER(S, &sadt);
152       slv->preserve_input = preserve_input;
153       return &(slv->super);
154  }
155  void XM(rdft2_rank_geq2_register)(planner *p)
156  {
157       int preserve_input;
158       for (preserve_input = 0; preserve_input <= 1; ++preserve_input)
159  	  REGISTER_SOLVER(p, mksolver(preserve_input));
160  }
</code></pre>
        </div>
        <div class="column">
            <h3>redis-MDEwOlJlcG9zaXRvcnkxMDgxMTA3MDY=-flat-xallocx.c</h3>
            <pre><code>1  #include "test/jemalloc_test.h"
2  static unsigned
3  arena_ind(void) {
4  	static unsigned ind = 0;
5  	if (ind == 0) {
6  		size_t sz = sizeof(ind);
7  		assert_d_eq(mallctl("arenas.create", (void *)&ind, &sz, NULL,
8  		    0), 0, "Unexpected mallctl failure creating arena");
9  	}
10  	return ind;
11  }
12  TEST_BEGIN(test_same_size) {
13  	void *p;
14  	size_t sz, tsz;
15  	p = mallocx(42, 0);
16  	assert_ptr_not_null(p, "Unexpected mallocx() error");
17  	sz = sallocx(p, 0);
18  	tsz = xallocx(p, sz, 0, 0);
19  	assert_zu_eq(tsz, sz, "Unexpected size change: %zu --> %zu", sz, tsz);
20  	dallocx(p, 0);
21  }
22  TEST_END
23  TEST_BEGIN(test_extra_no_move) {
24  	void *p;
25  	size_t sz, tsz;
26  	p = mallocx(42, 0);
27  	assert_ptr_not_null(p, "Unexpected mallocx() error");
28  	sz = sallocx(p, 0);
29  	tsz = xallocx(p, sz, sz-42, 0);
30  	assert_zu_eq(tsz, sz, "Unexpected size change: %zu --> %zu", sz, tsz);
31  	dallocx(p, 0);
32  }
33  TEST_END
34  TEST_BEGIN(test_no_move_fail) {
35  	void *p;
36  	size_t sz, tsz;
37  	p = mallocx(42, 0);
38  	assert_ptr_not_null(p, "Unexpected mallocx() error");
39  	sz = sallocx(p, 0);
40  	tsz = xallocx(p, sz + 5, 0, 0);
41  	assert_zu_eq(tsz, sz, "Unexpected size change: %zu --> %zu", sz, tsz);
42  	dallocx(p, 0);
43  }
44  TEST_END
45  static unsigned
46  get_nsizes_impl(const char *cmd) {
47  	unsigned ret;
48  	size_t z;
49  	z = sizeof(unsigned);
50  	assert_d_eq(mallctl(cmd, (void *)&ret, &z, NULL, 0), 0,
51  	    "Unexpected mallctl(\"%s\", ...) failure", cmd);
52  	return ret;
53  }
54  static unsigned
55  get_nsmall(void) {
56  	return get_nsizes_impl("arenas.nbins");
57  }
58  static unsigned
59  get_nlarge(void) {
60  	return get_nsizes_impl("arenas.nlextents");
61  }
62  static size_t
63  get_size_impl(const char *cmd, size_t ind) {
64  	size_t ret;
65  	size_t z;
66  	size_t mib[4];
67  	size_t miblen = 4;
68  	z = sizeof(size_t);
69  	assert_d_eq(mallctlnametomib(cmd, mib, &miblen),
70  	    0, "Unexpected mallctlnametomib(\"%s\", ...) failure", cmd);
71  	mib[2] = ind;
72  	z = sizeof(size_t);
73  	assert_d_eq(mallctlbymib(mib, miblen, (void *)&ret, &z, NULL, 0),
74  	    0, "Unexpected mallctlbymib([\"%s\", %zu], ...) failure", cmd, ind);
75  	return ret;
76  }
77  static size_t
78  get_small_size(size_t ind) {
79  	return get_size_impl("arenas.bin.0.size", ind);
80  }
81  static size_t
82  get_large_size(size_t ind) {
83  	return get_size_impl("arenas.lextent.0.size", ind);
84  }
85  TEST_BEGIN(test_size) {
86  	size_t small0, largemax;
87  	void *p;
88  	small0 = get_small_size(0);
89  	largemax = get_large_size(get_nlarge()-1);
90  	p = mallocx(small0, 0);
91  	assert_ptr_not_null(p, "Unexpected mallocx() error");
92  	assert_zu_eq(xallocx(p, 1, 0, 0), small0,
93  	    "Unexpected xallocx() behavior");
94  	assert_zu_le(xallocx(p, largemax, 0, 0), largemax,
95  	    "Unexpected xallocx() behavior");
96  	assert_zu_le(xallocx(p, largemax+1, 0, 0), largemax,
97  	    "Unexpected xallocx() behavior");
98  	assert_zu_le(xallocx(p, SIZE_T_MAX, 0, 0), largemax,
99  	    "Unexpected xallocx() behavior");
100  	dallocx(p, 0);
101  }
102  TEST_END
103  TEST_BEGIN(test_size_extra_overflow) {
104  	size_t small0, largemax;
105  	void *p;
106  	small0 = get_small_size(0);
107  	largemax = get_large_size(get_nlarge()-1);
108  	p = mallocx(small0, 0);
109  	assert_ptr_not_null(p, "Unexpected mallocx() error");
110  	assert_zu_le(xallocx(p, largemax-1, 2, 0), largemax,
111  	    "Unexpected xallocx() behavior");
112  	assert_zu_le(xallocx(p, largemax, 1, 0), largemax,
113  	    "Unexpected xallocx() behavior");
114  	assert_zu_le(xallocx(p, largemax+1, 2, 0), largemax,
115  	    "Unexpected xallocx() behavior");
116  	assert_zu_le(xallocx(p, largemax+2, 3, 0), largemax,
117  	    "Unexpected xallocx() behavior");
118  	assert_zu_le(xallocx(p, SIZE_T_MAX-2, 2, 0), largemax,
119  	    "Unexpected xallocx() behavior");
120  	assert_zu_le(xallocx(p, SIZE_T_MAX-1, 1, 0), largemax,
121  	    "Unexpected xallocx() behavior");
122  	dallocx(p, 0);
123  }
124  TEST_END
125  TEST_BEGIN(test_extra_small) {
126  	size_t small0, small1, largemax;
127  	void *p;
128  	small0 = get_small_size(0);
129  	small1 = get_small_size(1);
130  	largemax = get_large_size(get_nlarge()-1);
131  	p = mallocx(small0, 0);
132  	assert_ptr_not_null(p, "Unexpected mallocx() error");
133  	assert_zu_eq(xallocx(p, small1, 0, 0), small0,
134  	    "Unexpected xallocx() behavior");
135  	assert_zu_eq(xallocx(p, small1, 0, 0), small0,
136  	    "Unexpected xallocx() behavior");
137  	assert_zu_eq(xallocx(p, small0, small1 - small0, 0), small0,
138  	    "Unexpected xallocx() behavior");
139  	assert_zu_eq(xallocx(p, small0, largemax - small0 + 1, 0), small0,
140  	    "Unexpected xallocx() behavior");
141  	assert_zu_eq(xallocx(p, small0, SIZE_T_MAX - small0, 0), small0,
142  	    "Unexpected xallocx() behavior");
143  	dallocx(p, 0);
144  }
145  TEST_END
146  TEST_BEGIN(test_extra_large) {
147  	int flags = MALLOCX_ARENA(arena_ind());
148  	size_t smallmax, large1, large2, large3, largemax;
149  	void *p;
150  	smallmax = get_small_size(get_nsmall()-1);
151  	large1 = get_large_size(1);
152  	large2 = get_large_size(2);
153  	large3 = get_large_size(3);
154  	largemax = get_large_size(get_nlarge()-1);
155  	p = mallocx(large3, flags);
156  	assert_ptr_not_null(p, "Unexpected mallocx() error");
157  	assert_zu_eq(xallocx(p, large3, 0, flags), large3,
158  	    "Unexpected xallocx() behavior");
159  	assert_zu_ge(xallocx(p, large1, 0, flags), large1,
160  	    "Unexpected xallocx() behavior");
161  	assert_zu_ge(xallocx(p, smallmax, 0, flags), large1,
162  	    "Unexpected xallocx() behavior");
163  	if (xallocx(p, large3, 0, flags) != large3) {
164  		p = rallocx(p, large3, flags);
165  		assert_ptr_not_null(p, "Unexpected rallocx() failure");
166  	}
167  	assert_zu_eq(xallocx(p, large1, large3 - large1, flags), large3,
168  	    "Unexpected xallocx() behavior");
169  	assert_zu_eq(xallocx(p, large2, large3 - large2, flags), large3,
170  	    "Unexpected xallocx() behavior");
171  	assert_zu_ge(xallocx(p, large1, large2 - large1, flags), large2,
172  	    "Unexpected xallocx() behavior");
173  	assert_zu_ge(xallocx(p, smallmax, large1 - smallmax, flags), large1,
174  	    "Unexpected xallocx() behavior");
175  	assert_zu_ge(xallocx(p, large1, 0, flags), large1,
176  	    "Unexpected xallocx() behavior");
<span onclick='openModal()' class='match'>177  	assert_zu_le(xallocx(p, large3, 0, flags), large3,
178  	    "Unexpected xallocx() behavior");
179  	assert_zu_le(xallocx(p, largemax+1, 0, flags), large3,
180  	    "Unexpected xallocx() behavior");
181  	assert_zu_ge(xallocx(p, large1, 0, flags), large1,
182  	    "Unexpected xallocx() behavior");
183  	assert_zu_le(xallocx(p, large1, SIZE_T_MAX - large1, flags), largemax,
184  	    "Unexpected xallocx() behavior");
185  	assert_zu_ge(xallocx(p, large1, 0, flags), large1,
186  	    "Unexpected xallocx() behavior");
187  	assert_zu_le(xallocx(p, large1, large3 - large1, flags), large3,
188  	    "Unexpected xallocx() behavior");
189  	if (xallocx(p, large3, 0, flags) != large3) {
</span>190  		p = rallocx(p, large3, flags);
191  		assert_ptr_not_null(p, "Unexpected rallocx() failure");
192  	}
193  	assert_zu_le(xallocx(p, large3, largemax - large3 + 1, flags), largemax,
194  	    "Unexpected xallocx() behavior");
195  	dallocx(p, flags);
196  }
197  TEST_END
198  static void
199  print_filled_extents(const void *p, uint8_t c, size_t len) {
200  	const uint8_t *pc = (const uint8_t *)p;
201  	size_t i, range0;
202  	uint8_t c0;
203  	malloc_printf("  p=%p, c=%#x, len=%zu:", p, c, len);
204  	range0 = 0;
205  	c0 = pc[0];
206  	for (i = 0; i < len; i++) {
207  		if (pc[i] != c0) {
208  			malloc_printf(" %#x[%zu..%zu)", c0, range0, i);
209  			range0 = i;
210  			c0 = pc[i];
211  		}
212  	}
213  	malloc_printf(" %#x[%zu..%zu)\n", c0, range0, i);
214  }
215  static bool
216  validate_fill(const void *p, uint8_t c, size_t offset, size_t len) {
217  	const uint8_t *pc = (const uint8_t *)p;
218  	bool err;
219  	size_t i;
220  	for (i = offset, err = false; i < offset+len; i++) {
221  		if (pc[i] != c) {
222  			err = true;
223  		}
224  	}
225  	if (err) {
226  		print_filled_extents(p, c, offset + len);
227  	}
228  	return err;
229  }
230  static void
231  test_zero(size_t szmin, size_t szmax) {
232  	int flags = MALLOCX_ARENA(arena_ind()) | MALLOCX_ZERO;
233  	size_t sz, nsz;
234  	void *p;
235  #define FILL_BYTE 0x7aU
236  	sz = szmax;
237  	p = mallocx(sz, flags);
238  	assert_ptr_not_null(p, "Unexpected mallocx() error");
239  	assert_false(validate_fill(p, 0x00, 0, sz), "Memory not filled: sz=%zu",
240  	    sz);
241  	memset(p, FILL_BYTE, sz);
242  	assert_false(validate_fill(p, FILL_BYTE, 0, sz),
243  	    "Memory not filled: sz=%zu", sz);
244  	sz = szmin;
245  	if (xallocx(p, sz, 0, flags) != sz) {
246  		p = rallocx(p, sz, flags);
247  		assert_ptr_not_null(p, "Unexpected rallocx() failure");
248  	}
249  	assert_false(validate_fill(p, FILL_BYTE, 0, sz),
250  	    "Memory not filled: sz=%zu", sz);
251  	for (sz = szmin; sz < szmax; sz = nsz) {
252  		nsz = nallocx(sz+1, flags);
253  		if (xallocx(p, sz+1, 0, flags) != nsz) {
254  			p = rallocx(p, sz+1, flags);
255  			assert_ptr_not_null(p, "Unexpected rallocx() failure");
256  		}
257  		assert_false(validate_fill(p, FILL_BYTE, 0, sz),
258  		    "Memory not filled: sz=%zu", sz);
259  		assert_false(validate_fill(p, 0x00, sz, nsz-sz),
260  		    "Memory not filled: sz=%zu, nsz-sz=%zu", sz, nsz-sz);
261  		memset((void *)((uintptr_t)p + sz), FILL_BYTE, nsz-sz);
262  		assert_false(validate_fill(p, FILL_BYTE, 0, nsz),
263  		    "Memory not filled: nsz=%zu", nsz);
264  	}
265  	dallocx(p, flags);
266  }
267  TEST_BEGIN(test_zero_large) {
268  	size_t large0, large1;
269  	large0 = get_large_size(0);
270  	large1 = get_large_size(1);
271  	test_zero(large1, large0 * 2);
272  }
273  TEST_END
274  int
275  main(void) {
276  	return test(
277  	    test_same_size,
278  	    test_extra_no_move,
279  	    test_no_move_fail,
280  	    test_size,
281  	    test_size_extra_overflow,
282  	    test_extra_small,
283  	    test_extra_large,
284  	    test_zero_large);
285  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from fftw3-MDEwOlJlcG9zaXRvcnk4ODQzMzg4-flat-rdft2-rank-geq2.c</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from redis-MDEwOlJlcG9zaXRvcnkxMDgxMTA3MDY=-flat-xallocx.c</div>
                </div>
                <div class="column column_space"><pre><code>121  	  cld1 = X(mkplan_d)(plnr,
122                               X(mkproblem_rdft2_d)(sz,
123  						  X(mktensor_2d)(b, is, is,
124  							        p->vn,ivs,ovs),
125  						  r0, r1, cr, ci, p->kind));
126  	  if (XM(any_true)(!cld1, p->comm)) goto nada;
</pre></code></div>
                <div class="column column_space"><pre><code>177  	assert_zu_le(xallocx(p, large3, 0, flags), large3,
178  	    "Unexpected xallocx() behavior");
179  	assert_zu_le(xallocx(p, largemax+1, 0, flags), large3,
180  	    "Unexpected xallocx() behavior");
181  	assert_zu_ge(xallocx(p, large1, 0, flags), large1,
182  	    "Unexpected xallocx() behavior");
183  	assert_zu_le(xallocx(p, large1, SIZE_T_MAX - large1, flags), largemax,
184  	    "Unexpected xallocx() behavior");
185  	assert_zu_ge(xallocx(p, large1, 0, flags), large1,
186  	    "Unexpected xallocx() behavior");
187  	assert_zu_le(xallocx(p, large1, large3 - large1, flags), large3,
188  	    "Unexpected xallocx() behavior");
189  	if (xallocx(p, large3, 0, flags) != large3) {
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    