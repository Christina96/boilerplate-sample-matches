
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 12.173913043478262%, Tokens: 21, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>xmrig-MDEwOlJlcG9zaXRvcnk4ODMyNzQwNg==-flat-CudaDevice.h</h3>
            <pre><code>1  #ifndef XMRIG_CUDADEVICE_H
2  #define XMRIG_CUDADEVICE_H
3  #include "backend/common/misc/PciTopology.h"
4  #include "base/tools/String.h"
5  using nvid_ctx      = struct nvid_ctx;
6  using nvmlDevice_t  = struct nvmlDevice_st *;
7  namespace xmrig {
8  class Algorithm;
9  class CudaThreads;
10  class CudaDevice
11  {
12  public:
13      CudaDevice() = delete;
14      CudaDevice(const CudaDevice &other) = delete;
<span onclick='openModal()' class='match'>15      CudaDevice(CudaDevice &&other) noexcept;
16      CudaDevice(uint32_t index, int32_t bfactor, int32_t bsleep);
17      ~CudaDevice();
18      size_t freeMemSize() const;
19      size_t globalMemSize() const;
20      uint32_t clock() const;
21      uint32_t computeCapability(bool major = true) const;
22      uint32_t memoryClock() const;
23      uint32_t smx() const;
24      void generate(const Algorithm &algorithm, CudaThreads &threads) const;
</span>25      inline bool isValid() const                     { return m_ctx != nullptr; }
26      inline const PciTopology &topology() const      { return m_topology; }
27      inline const String &name() const               { return m_name; }
28      inline uint32_t arch() const                    { return (computeCapability(true) * 10) + computeCapability(false); }
29      inline uint32_t index() const                   { return m_index; }
30  #   ifdef XMRIG_FEATURE_NVML
31      inline nvmlDevice_t nvmlDevice() const          { return m_nvmlDevice; }
32      inline void setNvmlDevice(nvmlDevice_t device)  { m_nvmlDevice = device; }
33  #   endif
34  #   ifdef XMRIG_FEATURE_API
35      void toJSON(rapidjson::Value &out, rapidjson::Document &doc) const;
36  #   endif
37      CudaDevice &operator=(const CudaDevice &other)  = delete;
38      CudaDevice &operator=(CudaDevice &&other)       = delete;
39  private:
40      const uint32_t m_index          = 0;
41      nvid_ctx *m_ctx                 = nullptr;
42      PciTopology m_topology;
43      String m_name;
44  #   ifdef XMRIG_FEATURE_NVML
45      nvmlDevice_t m_nvmlDevice       = nullptr;
46  #   endif
47  };
48  } 
49  #endif &bsol;* XMRIG_CUDADEVICE_H */
</code></pre>
        </div>
        <div class="column">
            <h3>PINRemoteImage-MDEwOlJlcG9zaXRvcnkzOTUzNzEwMw==-flat-vp8i_enc.h</h3>
            <pre><code>1  #ifndef WEBP_ENC_VP8I_ENC_H_
2  #define WEBP_ENC_VP8I_ENC_H_
3  #include <string.h>     
4  #include "src/dec/common_dec.h"
5  #include "src/dsp/dsp.h"
6  #include "src/utils/bit_writer_utils.h"
7  #include "src/utils/thread_utils.h"
8  #include "src/utils/utils.h"
9  #include "src/webp/encode.h"
10  #ifdef __cplusplus
11  extern "C" {
12  #endif
13  #define ENC_MAJ_VERSION 1
14  #define ENC_MIN_VERSION 1
15  #define ENC_REV_VERSION 0
16  enum { MAX_LF_LEVELS = 64,       
17         MAX_VARIABLE_LEVEL = 67,  
18         MAX_LEVEL = 2047          
19       };
20  typedef enum {   
21    RD_OPT_NONE        = 0,  
22    RD_OPT_BASIC       = 1,  
23    RD_OPT_TRELLIS     = 2,  
24    RD_OPT_TRELLIS_ALL = 3   
25  } VP8RDLevel;
26  #define YUV_SIZE_ENC (BPS * 16)
27  #define PRED_SIZE_ENC (32 * BPS + 16 * BPS + 8 * BPS)   
28  #define Y_OFF_ENC    (0)
29  #define U_OFF_ENC    (16)
30  #define V_OFF_ENC    (16 + 8)
31  extern const uint16_t VP8Scan[16];
32  extern const uint16_t VP8UVModeOffsets[4];
33  extern const uint16_t VP8I16ModeOffsets[4];
34  extern const uint16_t VP8I4ModeOffsets[NUM_BMODES];
35  #define I16DC16 (0 * 16 * BPS)
36  #define I16TM16 (I16DC16 + 16)
37  #define I16VE16 (1 * 16 * BPS)
38  #define I16HE16 (I16VE16 + 16)
39  #define C8DC8 (2 * 16 * BPS)
40  #define C8TM8 (C8DC8 + 1 * 16)
41  #define C8VE8 (2 * 16 * BPS + 8 * BPS)
42  #define C8HE8 (C8VE8 + 1 * 16)
43  #define I4DC4 (3 * 16 * BPS +  0)
44  #define I4TM4 (I4DC4 +  4)
45  #define I4VE4 (I4DC4 +  8)
46  #define I4HE4 (I4DC4 + 12)
47  #define I4RD4 (I4DC4 + 16)
48  #define I4VR4 (I4DC4 + 20)
49  #define I4LD4 (I4DC4 + 24)
50  #define I4VL4 (I4DC4 + 28)
51  #define I4HD4 (3 * 16 * BPS + 4 * BPS)
52  #define I4HU4 (I4HD4 + 4)
53  #define I4TMP (I4HD4 + 8)
54  typedef int64_t score_t;     
55  #define MAX_COST ((score_t)0x7fffffffffffffLL)
56  #define QFIX 17
57  #define BIAS(b)  ((b) << (QFIX - 8))
58  static WEBP_INLINE int QUANTDIV(uint32_t n, uint32_t iQ, uint32_t B) {
59    return (int)((n * iQ + B) >> QFIX);
60  }
61  #define ERROR_DIFFUSION_QUALITY 98
62  typedef uint32_t proba_t;   
63  typedef uint8_t ProbaArray[NUM_CTX][NUM_PROBAS];
64  typedef proba_t StatsArray[NUM_CTX][NUM_PROBAS];
65  typedef uint16_t CostArray[NUM_CTX][MAX_VARIABLE_LEVEL + 1];
66  typedef const uint16_t* (*CostArrayPtr)[NUM_CTX];   
67  typedef const uint16_t* CostArrayMap[16][NUM_CTX];
68  typedef double LFStats[NUM_MB_SEGMENTS][MAX_LF_LEVELS];  
69  typedef struct VP8Encoder VP8Encoder;
70  typedef struct {
71    int num_segments_;      
72    int update_map_;        
73    int size_;              
74  } VP8EncSegmentHeader;
75  typedef struct {
76    uint8_t segments_[3];     
77    uint8_t skip_proba_;      
78    ProbaArray coeffs_[NUM_TYPES][NUM_BANDS];      
79    StatsArray stats_[NUM_TYPES][NUM_BANDS];       
80    CostArray level_cost_[NUM_TYPES][NUM_BANDS];   
81    CostArrayMap remapped_costs_[NUM_TYPES];       
82    int dirty_;               
83    int use_skip_proba_;      
84    int nb_skip_;             
85  } VP8EncProba;
86  typedef struct {
87    int simple_;             
88    int level_;              
89    int sharpness_;          
90    int i4x4_lf_delta_;      
91  } VP8EncFilterHeader;
92  typedef struct {
93    unsigned int type_:2;     
94    unsigned int uv_mode_:2;
95    unsigned int skip_:1;
96    unsigned int segment_:2;
97    uint8_t alpha_;      
98  } VP8MBInfo;
99  typedef struct VP8Matrix {
100    uint16_t q_[16];        
101    uint16_t iq_[16];       
102    uint32_t bias_[16];     
103    uint32_t zthresh_[16];  
104    uint16_t sharpen_[16];  
105  } VP8Matrix;
106  typedef struct {
107    VP8Matrix y1_, y2_, uv_;  
108    int alpha_;      
109    int beta_;       
110    int quant_;      
111    int fstrength_;  
112    int max_edge_;   
113    int min_disto_;  
114    int lambda_i16_, lambda_i4_, lambda_uv_;
115    int lambda_mode_, lambda_trellis_, tlambda_;
116    int lambda_trellis_i16_, lambda_trellis_i4_, lambda_trellis_uv_;
117    score_t i4_penalty_;   
118  } VP8SegmentInfo;
119  typedef int8_t DError[2 &bsol;* u/v */][2 &bsol;* top or left */];
120  typedef struct {
121    score_t D, SD;              
122    score_t H, R, score;        
123    int16_t y_dc_levels[16];    
124    int16_t y_ac_levels[16][16];
125    int16_t uv_levels[4 + 4][16];
126    int mode_i16;               
127    uint8_t modes_i4[16];       
128    int mode_uv;                
129    uint32_t nz;                
130    int8_t derr[2][3];          
131  } VP8ModeScore;
132  typedef struct {
<span onclick='openModal()' class='match'>133    int x_, y_;                      
134    uint8_t*      yuv_in_;           
135    uint8_t*      yuv_out_;          
136    uint8_t*      yuv_out2_;         
137    uint8_t*      yuv_p_;            
138    VP8Encoder*   enc_;              
139    VP8MBInfo*    mb_;               
140    VP8BitWriter* bw_;               
141    uint8_t*      preds_;            
142    uint32_t*     nz_;               
143    uint8_t       i4_boundary_[37];  
144    uint8_t*      i4_top_;           
145    int           i4_;               
146    int           top_nz_[9];        
147    int           left_nz_[9];       
148    uint64_t      bit_count_[4][3];  
149    uint64_t      luma_bits_;        
150    uint64_t      uv_bits_;          
151    LFStats*      lf_stats_;         
152    int           do_trellis_;       
153    int           count_down_;       
</span>154    int           count_down0_;      
155    int           percent0_;         
156    DError        left_derr_;        
157    DError*       top_derr_;         
158    uint8_t* y_left_;    
159    uint8_t* u_left_;    
160    uint8_t* v_left_;    
161    uint8_t* y_top_;     
162    uint8_t* uv_top_;    
163    uint8_t yuv_left_mem_[17 + 16 + 16 + 8 + WEBP_ALIGN_CST];
164    uint8_t yuv_mem_[3 * YUV_SIZE_ENC + PRED_SIZE_ENC + WEBP_ALIGN_CST];
165  } VP8EncIterator;
166  void VP8IteratorInit(VP8Encoder* const enc, VP8EncIterator* const it);
167  void VP8IteratorReset(VP8EncIterator* const it);
168  void VP8IteratorSetRow(VP8EncIterator* const it, int y);
169  void VP8IteratorSetCountDown(VP8EncIterator* const it, int count_down);
170  int VP8IteratorIsDone(const VP8EncIterator* const it);
171  void VP8IteratorImport(VP8EncIterator* const it, uint8_t* const tmp_32);
172  void VP8IteratorExport(const VP8EncIterator* const it);
173  int VP8IteratorNext(VP8EncIterator* const it);
174  void VP8IteratorSaveBoundary(VP8EncIterator* const it);
175  int VP8IteratorProgress(const VP8EncIterator* const it,
176                          int final_delta_percent);
177  void VP8IteratorStartI4(VP8EncIterator* const it);
178  int VP8IteratorRotateI4(VP8EncIterator* const it,
179                          const uint8_t* const yuv_out);
180  void VP8IteratorNzToBytes(VP8EncIterator* const it);
181  void VP8IteratorBytesToNz(VP8EncIterator* const it);
182  void VP8SetIntra16Mode(const VP8EncIterator* const it, int mode);
183  void VP8SetIntra4Mode(const VP8EncIterator* const it, const uint8_t* modes);
184  void VP8SetIntraUVMode(const VP8EncIterator* const it, int mode);
185  void VP8SetSkip(const VP8EncIterator* const it, int skip);
186  void VP8SetSegment(const VP8EncIterator* const it, int segment);
187  typedef struct VP8Tokens VP8Tokens;  
188  typedef struct {
189  #if !defined(DISABLE_TOKEN_BUFFER)
190    VP8Tokens* pages_;        
191    VP8Tokens** last_page_;   
192    uint16_t* tokens_;        
193    int left_;                
194    int page_size_;           
195  #endif
196    int error_;         
197  } VP8TBuffer;
198  void VP8TBufferInit(VP8TBuffer* const b, int page_size);
199  void VP8TBufferClear(VP8TBuffer* const b);   
200  #if !defined(DISABLE_TOKEN_BUFFER)
201  int VP8EmitTokens(VP8TBuffer* const b, VP8BitWriter* const bw,
202                    const uint8_t* const probas, int final_pass);
203  int VP8RecordCoeffTokens(int ctx, const struct VP8Residual* const res,
204                           VP8TBuffer* const tokens);
205  size_t VP8EstimateTokenSize(VP8TBuffer* const b, const uint8_t* const probas);
206  #endif  
207  struct VP8Encoder {
208    const WebPConfig* config_;    
209    WebPPicture* pic_;            
210    VP8EncFilterHeader   filter_hdr_;     
211    VP8EncSegmentHeader  segment_hdr_;    
212    int profile_;                      
213    int mb_w_, mb_h_;
214    int preds_w_;   
215    int num_parts_;
216    VP8BitWriter bw_;                         
217    VP8BitWriter parts_[MAX_NUM_PARTITIONS];  
218    VP8TBuffer tokens_;                       
219    int percent_;                             
220    int has_alpha_;
221    uint8_t* alpha_data_;       
222    uint32_t alpha_data_size_;
223    WebPWorker alpha_worker_;
224    VP8SegmentInfo dqm_[NUM_MB_SEGMENTS];
225    int base_quant_;                 
226    int alpha_;                      
227    int uv_alpha_;                   
228    int dq_y1_dc_;
229    int dq_y2_dc_, dq_y2_ac_;
230    int dq_uv_dc_, dq_uv_ac_;
231    VP8EncProba proba_;
232    uint64_t    sse_[4];      
233    uint64_t    sse_count_;   
234    int         coded_size_;
235    int         residual_bytes_[3][4];
236    int         block_count_[3];
237    int method_;               
238    VP8RDLevel rd_opt_level_;  
239    int max_i4_header_bits_;   
240    int mb_header_limit_;      
241    int thread_level_;         
242    int do_search_;            
243    int use_tokens_;           
244    VP8MBInfo* mb_info_;   
245    uint8_t*   preds_;     
246    uint32_t*  nz_;        
247    uint8_t*   y_top_;     
248    uint8_t*   uv_top_;    
249    LFStats*   lf_stats_;  
250    DError*    top_derr_;  
251  };
252  extern const uint8_t VP8CoeffsProba0[NUM_TYPES][NUM_BANDS][NUM_CTX][NUM_PROBAS];
253  extern const uint8_t
254      VP8CoeffsUpdateProba[NUM_TYPES][NUM_BANDS][NUM_CTX][NUM_PROBAS];
255  void VP8DefaultProbas(VP8Encoder* const enc);
256  void VP8WriteProbas(VP8BitWriter* const bw, const VP8EncProba* const probas);
257  void VP8CodeIntraModes(VP8Encoder* const enc);
258  int VP8EncWrite(VP8Encoder* const enc);
259  void VP8EncFreeBitWriters(VP8Encoder* const enc);
260  extern const uint8_t VP8Cat3[];
261  extern const uint8_t VP8Cat4[];
262  extern const uint8_t VP8Cat5[];
263  extern const uint8_t VP8Cat6[];
264  void VP8MakeLuma16Preds(const VP8EncIterator* const it);
265  void VP8MakeChroma8Preds(const VP8EncIterator* const it);
266  void VP8MakeIntra4Preds(const VP8EncIterator* const it);
267  int VP8GetCostLuma16(VP8EncIterator* const it, const VP8ModeScore* const rd);
268  int VP8GetCostLuma4(VP8EncIterator* const it, const int16_t levels[16]);
269  int VP8GetCostUV(VP8EncIterator* const it, const VP8ModeScore* const rd);
270  int VP8EncLoop(VP8Encoder* const enc);
271  int VP8EncTokenLoop(VP8Encoder* const enc);
272  int WebPEncodingSetError(const WebPPicture* const pic, WebPEncodingError error);
273  int WebPReportProgress(const WebPPicture* const pic,
274                         int percent, int* const percent_store);
275  int VP8EncAnalyze(VP8Encoder* const enc);
276  void VP8SetSegmentParams(VP8Encoder* const enc, float quality);
277  int VP8Decimate(VP8EncIterator* const it, VP8ModeScore* const rd,
278                  VP8RDLevel rd_opt);
279  void VP8EncInitAlpha(VP8Encoder* const enc);    
280  int VP8EncStartAlpha(VP8Encoder* const enc);    
281  int VP8EncFinishAlpha(VP8Encoder* const enc);   
282  int VP8EncDeleteAlpha(VP8Encoder* const enc);   
283  void VP8InitFilter(VP8EncIterator* const it);
284  void VP8StoreFilterStats(VP8EncIterator* const it);
285  void VP8AdjustFilterStrength(VP8EncIterator* const it);
286  int VP8FilterStrengthFromDelta(int sharpness, int delta);
287  void WebPPictureResetBuffers(WebPPicture* const picture);
288  int WebPPictureAllocARGB(WebPPicture* const picture, int width, int height);
289  int WebPPictureAllocYUVA(WebPPicture* const picture, int width, int height);
290  void WebPCleanupTransparentAreaLossless(WebPPicture* const pic);
291  #ifdef __cplusplus
292  }    
293  #endif
294  #endif  
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from xmrig-MDEwOlJlcG9zaXRvcnk4ODMyNzQwNg==-flat-CudaDevice.h</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from PINRemoteImage-MDEwOlJlcG9zaXRvcnkzOTUzNzEwMw==-flat-vp8i_enc.h</div>
                </div>
                <div class="column column_space"><pre><code>15      CudaDevice(CudaDevice &&other) noexcept;
16      CudaDevice(uint32_t index, int32_t bfactor, int32_t bsleep);
17      ~CudaDevice();
18      size_t freeMemSize() const;
19      size_t globalMemSize() const;
20      uint32_t clock() const;
21      uint32_t computeCapability(bool major = true) const;
22      uint32_t memoryClock() const;
23      uint32_t smx() const;
24      void generate(const Algorithm &algorithm, CudaThreads &threads) const;
</pre></code></div>
                <div class="column column_space"><pre><code>133    int x_, y_;                      
134    uint8_t*      yuv_in_;           
135    uint8_t*      yuv_out_;          
136    uint8_t*      yuv_out2_;         
137    uint8_t*      yuv_p_;            
138    VP8Encoder*   enc_;              
139    VP8MBInfo*    mb_;               
140    VP8BitWriter* bw_;               
141    uint8_t*      preds_;            
142    uint32_t*     nz_;               
143    uint8_t       i4_boundary_[37];  
144    uint8_t*      i4_top_;           
145    int           i4_;               
146    int           top_nz_[9];        
147    int           left_nz_[9];       
148    uint64_t      bit_count_[4][3];  
149    uint64_t      luma_bits_;        
150    uint64_t      uv_bits_;          
151    LFStats*      lf_stats_;         
152    int           do_trellis_;       
153    int           count_down_;       
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    