
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 2.4746906636670416%, Tokens: 11, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>fftw3-MDEwOlJlcG9zaXRvcnk4ODQzMzg4-flat-mktensor-rowmajor.c</h3>
            <pre><code>1  #include "api/api.h"
<span onclick='openModal()' class='match'>2  tensor *X(mktensor_rowmajor)(int rnk, const int *n,
3  			     const int *niphys, const int *nophys,
4  			     int is, int os)
5  {
6       tensor *x = X(mktensor)(rnk);
</span>7       if (FINITE_RNK(rnk) && rnk > 0) {
8            int i;
9            A(n && niphys && nophys);
10            x->dims[rnk - 1].is = is;
11            x->dims[rnk - 1].os = os;
12            x->dims[rnk - 1].n = n[rnk - 1];
13            for (i = rnk - 1; i > 0; --i) {
14                 x->dims[i - 1].is = x->dims[i].is * niphys[i];
15                 x->dims[i - 1].os = x->dims[i].os * nophys[i];
16                 x->dims[i - 1].n = n[i - 1];
17            }
18       }
19       return x;
20  }
21  static int rowmajor_kosherp(int rnk, const int *n)
22  {
23       int i;
24       if (!FINITE_RNK(rnk)) return 0;
25       if (rnk < 0) return 0;
26       for (i = 0; i < rnk; ++i)
27  	  if (n[i] <= 0) return 0;
28       return 1;
29  }
30  int X(many_kosherp)(int rnk, const int *n, int howmany)
31  {
32       return (howmany >= 0) && rowmajor_kosherp(rnk, n);
33  }
</code></pre>
        </div>
        <div class="column">
            <h3>libtomcrypt-MDEwOlJlcG9zaXRvcnk3NzcwMTE=-flat-tv_gen.c</h3>
            <pre><code>1  #include "tomcrypt_private.h"
2  static void hash_gen(void)
3  {
4     unsigned char md[MAXBLOCKSIZE], *buf;
5     unsigned long outlen, x, y, z;
6     FILE *out;
7     int   err;
8     out = fopen("hash_tv.txt", "w");
9     if (out == NULL) {
10        perror("can't open hash_tv");
11     }
12     fprintf(out, "Hash Test Vectors:\n\nThese are the hashes of nn bytes '00 01 02 03 .. (nn-1)'\n\n");
13     for (x = 0; hash_descriptor[x].name != NULL; x++) {
14        buf = XMALLOC(2 * hash_descriptor[x].blocksize + 1);
15        if (buf == NULL) {
16           perror("can't alloc mem");
17           exit(EXIT_FAILURE);
18        }
19        fprintf(out, "Hash: %s\n", hash_descriptor[x].name);
20        for (y = 0; y <= (hash_descriptor[x].blocksize * 2); y++) {
21           for (z = 0; z < y; z++) {
22              buf[z] = (unsigned char)(z & 255);
23           }
24           outlen = sizeof(md);
25           if ((err = hash_memory(x, buf, y, md, &outlen)) != CRYPT_OK) {
26              printf("hash_memory error: %s\n", error_to_string(err));
27              exit(EXIT_FAILURE);
28           }
29           fprintf(out, "%3lu: ", y);
30           for (z = 0; z < outlen; z++) {
31              fprintf(out, "%02X", md[z]);
32           }
33           fprintf(out, "\n");
34        }
35        fprintf(out, "\n");
36        XFREE(buf);
37     }
38     fclose(out);
39  }
<span onclick='openModal()' class='match'>40  static void cipher_gen(void)
41  {
42     unsigned char *key, pt[MAXBLOCKSIZE];
43     unsigned long x, y, z, w;
44     int err, kl, lastkl;
45     FILE *out;
46     symmetric_key skey;
47     out = fopen("cipher_tv.txt", "w");
</span>48     fprintf(out,
49  "Cipher Test Vectors\n\nThese are test encryptions with key of nn bytes '00 01 02 03 .. (nn-1)' and original PT of the same style.\n"
50  "The output of step N is used as the key and plaintext for step N+1 (key bytes repeated as required to fill the key)\n\n");
51     for (x = 0; cipher_descriptor[x].name != NULL; x++) {
52        fprintf(out, "Cipher: %s\n", cipher_descriptor[x].name);
53        lastkl = 10000;
54        for (y = 0; y < 3; y++) {
55           switch (y) {
56              case 0: kl = cipher_descriptor[x].min_key_length; break;
57              case 1: kl = (cipher_descriptor[x].min_key_length + cipher_descriptor[x].max_key_length)/2; break;
58              case 2: kl = cipher_descriptor[x].max_key_length; break;
59           }
60           if ((err = cipher_descriptor[x].keysize(&kl)) != CRYPT_OK) {
61              printf("keysize error: %s\n", error_to_string(err));
62              exit(EXIT_FAILURE);
63           }
64           if (kl == lastkl) continue;
65           lastkl = kl;
66           fprintf(out, "Key Size: %d bytes\n", kl);
67           key = XMALLOC(kl);
68           if (key == NULL) {
69              perror("can't malloc memory");
70              exit(EXIT_FAILURE);
71           }
72           for (z = 0; (int)z < kl; z++) {
73               key[z] = (unsigned char)z;
74           }
75           if ((err = cipher_descriptor[x].setup(key, kl, 0, &skey)) != CRYPT_OK) {
76              printf("setup error: %s\n", error_to_string(err));
77              exit(EXIT_FAILURE);
78           }
79           for (z = 0; (int)z < cipher_descriptor[x].block_length; z++) {
80              pt[z] = (unsigned char)z;
81           }
82           for (w = 0; w < 50; w++) {
83               cipher_descriptor[x].ecb_encrypt(pt, pt, &skey);
84               fprintf(out, "%2lu: ", w);
85               for (z = 0; (int)z < cipher_descriptor[x].block_length; z++) {
86                  fprintf(out, "%02X", pt[z]);
87               }
88               fprintf(out, "\n");
89               for (z = 0; z < (unsigned long)kl; z++) {
90                   key[z] = pt[z % cipher_descriptor[x].block_length];
91               }
92               if ((err = cipher_descriptor[x].setup(key, kl, 0, &skey)) != CRYPT_OK) {
93                  printf("cipher setup2 error: %s\n", error_to_string(err));
94                  exit(EXIT_FAILURE);
95               }
96           }
97           fprintf(out, "\n");
98           XFREE(key);
99       }
100       fprintf(out, "\n");
101    }
102    fclose(out);
103  }
104  static void hmac_gen(void)
105  {
106     unsigned char key[MAXBLOCKSIZE], output[MAXBLOCKSIZE], *input;
107     int x, y, z, err;
108     FILE *out;
109     unsigned long len;
110     out = fopen("hmac_tv.txt", "w");
111     fprintf(out,
112  "HMAC Tests.  In these tests messages of N bytes long (00,01,02,...,NN-1) are HMACed.  The initial key is\n"
113  "of the same format (the same length as the HASH output size).  The HMAC key in step N+1 is the HMAC output of\n"
114  "step N.\n\n");
115     for (x = 0; hash_descriptor[x].name != NULL; x++) {
116        fprintf(out, "HMAC-%s\n", hash_descriptor[x].name);
117        for (y = 0; y < (int)hash_descriptor[x].hashsize; y++) {
118            key[y] = (y&255);
119        }
120        input = XMALLOC(hash_descriptor[x].blocksize * 2 + 1);
121        if (input == NULL) {
122           perror("Can't malloc memory");
123           exit(EXIT_FAILURE);
124        }
125        for (y = 0; y <= (int)(hash_descriptor[x].blocksize * 2); y++) {
126           for (z = 0; z < y; z++) {
127              input[z] = (unsigned char)(z & 255);
128           }
129           len = sizeof(output);
130           if ((err = hmac_memory(x, key, hash_descriptor[x].hashsize, input, y, output, &len)) != CRYPT_OK) {
131              printf("Error hmacing: %s\n", error_to_string(err));
132              exit(EXIT_FAILURE);
133           }
134           fprintf(out, "%3d: ", y);
135           for (z = 0; z <(int) len; z++) {
136              fprintf(out, "%02X", output[z]);
137           }
138           fprintf(out, "\n");
139           memcpy(key, output, hash_descriptor[x].hashsize);
140        }
141        XFREE(input);
142        fprintf(out, "\n");
143     }
144     fclose(out);
145  }
146  #ifdef LTC_OMAC
147  static void omac_gen(void)
148  {
149     unsigned char key[MAXBLOCKSIZE], output[MAXBLOCKSIZE], input[MAXBLOCKSIZE*2+2];
150     int err, x, y, z, kl;
151     FILE *out;
152     unsigned long len;
153     out = fopen("omac_tv.txt", "w");
154     fprintf(out,
155  "OMAC Tests.  In these tests messages of N bytes long (00,01,02,...,NN-1) are OMAC'ed.  The initial key is\n"
156  "of the same format (length specified per cipher).  The OMAC key in step N+1 is the OMAC output of\n"
157  "step N (repeated as required to fill the array).\n\n");
158     for (x = 0; cipher_descriptor[x].name != NULL; x++) {
159        kl = cipher_descriptor[x].block_length;
160        if (kl != 8 && kl != 16) continue;
161        if (cipher_descriptor[x].keysize(&kl) != CRYPT_OK) {
162           kl = cipher_descriptor[x].max_key_length;
163        }
164        fprintf(out, "OMAC-%s (%d byte key)\n", cipher_descriptor[x].name, kl);
165        for (y = 0; y < kl; y++) {
166            key[y] = (y & 255);
167        }
168        for (y = 0; y <= (int)(cipher_descriptor[x].block_length*2); y++) {
169           for (z = 0; z < y; z++) {
170              input[z] = (unsigned char)(z & 255);
171           }
172           len = sizeof(output);
173           if ((err = omac_memory(x, key, kl, input, y, output, &len)) != CRYPT_OK) {
174              printf("Error OMAC'ing: %s\n", error_to_string(err));
175              exit(EXIT_FAILURE);
176           }
177           if (len == 0) {
178              printf("Error OMAC'ing: zero length\n");
179              exit(EXIT_FAILURE);
180           }
181           fprintf(out, "%3d: ", y);
182           for (z = 0; z <(int)len; z++) {
183              fprintf(out, "%02X", output[z]);
184           }
185           fprintf(out, "\n");
186           for (z = 0; z < kl; z++) {
187               key[z] = output[z % len];
188           }
189        }
190        fprintf(out, "\n");
191     }
192     fclose(out);
193  }
194  #endif
195  #ifdef LTC_PMAC
196  static void pmac_gen(void)
197  {
198     unsigned char key[MAXBLOCKSIZE], output[MAXBLOCKSIZE], input[MAXBLOCKSIZE*2+2];
199     int err, x, y, z, kl;
200     FILE *out;
201     unsigned long len;
202     out = fopen("pmac_tv.txt", "w");
203     fprintf(out,
204  "PMAC Tests.  In these tests messages of N bytes long (00,01,02,...,NN-1) are PMAC'ed.  The initial key is\n"
205  "of the same format (length specified per cipher).  The PMAC key in step N+1 is the PMAC output of\n"
206  "step N (repeated as required to fill the array).\n\n");
207     for (x = 0; cipher_descriptor[x].name != NULL; x++) {
208        kl = cipher_descriptor[x].block_length;
209        if (kl != 8 && kl != 16) continue;
210        if (cipher_descriptor[x].keysize(&kl) != CRYPT_OK) {
211           kl = cipher_descriptor[x].max_key_length;
212        }
213        fprintf(out, "PMAC-%s (%d byte key)\n", cipher_descriptor[x].name, kl);
214        for (y = 0; y < kl; y++) {
215            key[y] = (y & 255);
216        }
217        for (y = 0; y <= (int)(cipher_descriptor[x].block_length*2); y++) {
218           for (z = 0; z < y; z++) {
219              input[z] = (unsigned char)(z & 255);
220           }
221           len = sizeof(output);
222           if ((err = pmac_memory(x, key, kl, input, y, output, &len)) != CRYPT_OK) {
223              printf("Error PMACing: %s\n", error_to_string(err));
224              exit(EXIT_FAILURE);
225           }
226           if (len == 0) {
227              printf("Error PMAC'ing: zero length\n");
228              exit(EXIT_FAILURE);
229           }
230           fprintf(out, "%3d: ", y);
231           for (z = 0; z <(int)len; z++) {
232              fprintf(out, "%02X", output[z]);
233           }
234           fprintf(out, "\n");
235           for (z = 0; z < kl; z++) {
236               key[z] = output[z % len];
237           }
238        }
239        fprintf(out, "\n");
240     }
241     fclose(out);
242  }
243  #endif
244  #ifdef LTC_EAX_MODE
245  static void eax_gen(void)
246  {
247     int err, kl, x, y1, z;
248     FILE *out;
249     unsigned char key[MAXBLOCKSIZE], nonce[MAXBLOCKSIZE*2], header[MAXBLOCKSIZE*2],
250                   plaintext[MAXBLOCKSIZE*2], tag[MAXBLOCKSIZE];
251     unsigned long len;
252     out = fopen("eax_tv.txt", "w");
253     fprintf(out, "EAX Test Vectors.  Uses the 00010203...NN-1 pattern for header/nonce/plaintext/key.  The outputs\n"
254                  "are of the form ciphertext,tag for a given NN.  The key for step N>1 is the tag of the previous\n"
255                  "step repeated sufficiently.\n\n");
256     for (x = 0; cipher_descriptor[x].name != NULL; x++) {
257        kl = cipher_descriptor[x].block_length;
258        if (kl != 8 && kl != 16) continue;
259        if (cipher_descriptor[x].keysize(&kl) != CRYPT_OK) {
260           kl = cipher_descriptor[x].max_key_length;
261        }
262        fprintf(out, "EAX-%s (%d byte key)\n", cipher_descriptor[x].name, kl);
263        for (z = 0; z < kl; z++) {
264            key[z] = (z & 255);
265        }
266        for (y1 = 0; y1 <= (int)(cipher_descriptor[x].block_length*2); y1++){
267           for (z = 0; z < y1; z++) {
268              plaintext[z] = (unsigned char)(z & 255);
269              nonce[z]     = (unsigned char)(z & 255);
270              header[z]    = (unsigned char)(z & 255);
271           }
272           len = sizeof(tag);
273           if ((err = eax_encrypt_authenticate_memory(x, key, kl, nonce, y1, header, y1, plaintext, y1, plaintext, tag, &len)) != CRYPT_OK) {
274              printf("Error EAX'ing: %s\n", error_to_string(err));
275              exit(EXIT_FAILURE);
276           }
277           if (len == 0) {
278              printf("Error EAX'ing: zero length\n");
279              exit(EXIT_FAILURE);
280           }
281           fprintf(out, "%3d: ", y1);
282           for (z = 0; z < y1; z++) {
283              fprintf(out, "%02X", plaintext[z]);
284           }
285           fprintf(out, ", ");
286           for (z = 0; z <(int)len; z++) {
287              fprintf(out, "%02X", tag[z]);
288           }
289           fprintf(out, "\n");
290           for (z = 0; z < kl; z++) {
291               key[z] = tag[z % len];
292           }
293        }
294        fprintf(out, "\n");
295     }
296     fclose(out);
297  }
298  #endif
299  #ifdef LTC_OCB_MODE
300  static void ocb_gen(void)
301  {
302     int err, kl, x, y1, z;
303     FILE *out;
304     unsigned char key[MAXBLOCKSIZE], nonce[MAXBLOCKSIZE*2],
305                   plaintext[MAXBLOCKSIZE*2], tag[MAXBLOCKSIZE];
306     unsigned long len;
307     out = fopen("ocb_tv.txt", "w");
308     fprintf(out, "OCB Test Vectors.  Uses the 00010203...NN-1 pattern for nonce/plaintext/key.  The outputs\n"
309                  "are of the form ciphertext,tag for a given NN.  The key for step N>1 is the tag of the previous\n"
310                  "step repeated sufficiently.  The nonce is fixed throughout.\n\n");
311     for (x = 0; cipher_descriptor[x].name != NULL; x++) {
312        kl = cipher_descriptor[x].block_length;
313        if (kl != 8 && kl != 16) continue;
314        if (cipher_descriptor[x].keysize(&kl) != CRYPT_OK) {
315           kl = cipher_descriptor[x].max_key_length;
316        }
317        fprintf(out, "OCB-%s (%d byte key)\n", cipher_descriptor[x].name, kl);
318        for (z = 0; z < kl; z++) {
319            key[z] = (z & 255);
320        }
321        for (z = 0; z < cipher_descriptor[x].block_length; z++) {
322            nonce[z] = z;
323        }
324        for (y1 = 0; y1 <= (int)(cipher_descriptor[x].block_length*2); y1++){
325           for (z = 0; z < y1; z++) {
326              plaintext[z] = (unsigned char)(z & 255);
327           }
328           len = sizeof(tag);
329           if ((err = ocb_encrypt_authenticate_memory(x, key, kl, nonce, plaintext, y1, plaintext, tag, &len)) != CRYPT_OK) {
330              printf("Error OCB'ing: %s\n", error_to_string(err));
331              exit(EXIT_FAILURE);
332           }
333           if (len == 0) {
334              printf("Error OCB'ing: zero length\n");
335              exit(EXIT_FAILURE);
336           }
337           fprintf(out, "%3d: ", y1);
338           for (z = 0; z < y1; z++) {
339              fprintf(out, "%02X", plaintext[z]);
340           }
341           fprintf(out, ", ");
342           for (z = 0; z <(int)len; z++) {
343              fprintf(out, "%02X", tag[z]);
344           }
345           fprintf(out, "\n");
346           for (z = 0; z < kl; z++) {
347               key[z] = tag[z % len];
348           }
349        }
350        fprintf(out, "\n");
351     }
352     fclose(out);
353  }
354  #endif
355  #ifdef LTC_OCB3_MODE
356  static void ocb3_gen(void)
357  {
358     int err, kl, x, y1, z, noncelen;
359     FILE *out;
360     unsigned char key[MAXBLOCKSIZE], nonce[MAXBLOCKSIZE*2],
361                   plaintext[MAXBLOCKSIZE*2], tag[MAXBLOCKSIZE];
362     unsigned long len;
363     out = fopen("ocb3_tv.txt", "w");
364     fprintf(out, "OCB3 Test Vectors.  Uses the 00010203...NN-1 pattern for nonce/plaintext/key.  The outputs\n"
365                  "are of the form ciphertext,tag for a given NN.  The key for step N>1 is the tag of the previous\n"
366                  "step repeated sufficiently.  The nonce is fixed throughout. AAD is fixed to 3 bytes (ASCII) 'AAD'.\n\n");
367     for (x = 0; cipher_descriptor[x].name != NULL; x++) {
368        kl = cipher_descriptor[x].block_length;
369        if (kl != 16) continue;
370        if (cipher_descriptor[x].keysize(&kl) != CRYPT_OK) {
371           kl = cipher_descriptor[x].max_key_length;
372        }
373        fprintf(out, "OCB3-%s (%d byte key)\n", cipher_descriptor[x].name, kl);
374        for (z = 0; z < kl; z++) {
375            key[z] = (z & 255);
376        }
377        noncelen = MIN(15, cipher_descriptor[x].block_length);
378        for (z = 0; z < noncelen; z++) {
379            nonce[z] = z;
380        }
381        for (y1 = 0; y1 <= (int)(cipher_descriptor[x].block_length*2); y1++){
382           for (z = 0; z < y1; z++) {
383              plaintext[z] = (unsigned char)(z & 255);
384           }
385           len = 16;
386           if ((err = ocb3_encrypt_authenticate_memory(x, key, kl, nonce, noncelen, (unsigned char*)"AAD", 3, plaintext, y1, plaintext, tag, &len)) != CRYPT_OK) {
387              printf("Error OCB3'ing: %s\n", error_to_string(err));
388              exit(EXIT_FAILURE);
389           }
390           if (len == 0) {
391              printf("Error OCB3'ing: zero length\n");
392              exit(EXIT_FAILURE);
393           }
394           fprintf(out, "%3d: ", y1);
395           for (z = 0; z < y1; z++) {
396              fprintf(out, "%02X", plaintext[z]);
397           }
398           fprintf(out, ", ");
399           for (z = 0; z <(int)len; z++) {
400              fprintf(out, "%02X", tag[z]);
401           }
402           fprintf(out, "\n");
403           for (z = 0; z < kl; z++) {
404               key[z] = tag[z % len];
405           }
406        }
407        fprintf(out, "\n");
408     }
409     fclose(out);
410  }
411  #endif
412  #ifdef LTC_CCM_MODE
413  static void ccm_gen(void)
414  {
415     int err, kl, x, y1, z;
416     unsigned int t;
417     FILE *out;
418     unsigned char key[MAXBLOCKSIZE], nonce[MAXBLOCKSIZE*2],
419                   plaintext[MAXBLOCKSIZE*2], tag[16];
420     unsigned long len;
421     const unsigned int taglen[] = {4, 6, 8, 10, 12, 14, 16};
422     out = fopen("ccm_tv.txt", "w");
423     fprintf(out, "CCM Test Vectors.  Uses the 00010203...NN-1 pattern for nonce/header/plaintext/key.  The outputs\n"
424                  "are of the form ciphertext,tag for a given NN.  The key for step N>1 is the tag of the previous\n"
425                  "step repeated sufficiently.  The nonce is fixed throughout at 13 bytes 000102...\n\n");
426     for (x = 0; cipher_descriptor[x].name != NULL; x++) {
427        kl = cipher_descriptor[x].block_length;
428        if (kl != 16) continue;
429        if (cipher_descriptor[x].keysize(&kl) != CRYPT_OK) {
430           kl = cipher_descriptor[x].max_key_length;
431        }
432        fprintf(out, "CCM-%s (%d byte key)\n", cipher_descriptor[x].name, kl);
433        for (z = 0; z < kl; z++) {
434            key[z] = (z & 255);
435        }
436        for (z = 0; z < cipher_descriptor[x].block_length; z++) {
437            nonce[z] = z;
438        }
439        for (t = 0; t < sizeof(taglen)/sizeof(taglen[0]); ++t) {
440           for (y1 = 0; y1 <= (int)(cipher_descriptor[x].block_length*2); y1++){
441              for (z = 0; z < y1; z++) {
442                 plaintext[z] = (unsigned char)(z & 255);
443              }
444              len = taglen[t];
445              if ((err = ccm_memory(x, key, kl, NULL, nonce, 13, plaintext, y1, plaintext, y1, plaintext, tag, &len, CCM_ENCRYPT)) != CRYPT_OK) {
446                 printf("Error CCM'ing: %s\n", error_to_string(err));
447                 exit(EXIT_FAILURE);
448              }
449              if (len == 0) {
450                 printf("Error CCM'ing: zero length\n");
451                 exit(EXIT_FAILURE);
452              }
453              fprintf(out, "%3d: ", y1);
454              for (z = 0; z < y1; z++) {
455                 fprintf(out, "%02X", plaintext[z]);
456              }
457              fprintf(out, ", ");
458              for (z = 0; z <(int)len; z++) {
459                 fprintf(out, "%02X", tag[z]);
460              }
461              fprintf(out, "\n");
462              for (z = 0; z < kl; z++) {
463                  key[z] = tag[z % len];
464              }
465           }
466        }
467        fprintf(out, "\n");
468     }
469     fclose(out);
470  }
471  #endif
472  #ifdef LTC_GCM_MODE
473  static void gcm_gen(void)
474  {
475     int err, kl, x, y1, z;
476     FILE *out;
477     unsigned char key[MAXBLOCKSIZE], plaintext[MAXBLOCKSIZE*2], tag[MAXBLOCKSIZE];
478     unsigned long len;
479     out = fopen("gcm_tv.txt", "w");
480     fprintf(out, "GCM Test Vectors.  Uses the 00010203...NN-1 pattern for nonce/header/plaintext/key.  The outputs\n"
481                  "are of the form ciphertext,tag for a given NN.  The key for step N>1 is the tag of the previous\n"
482                  "step repeated sufficiently.  The nonce is fixed throughout at 13 bytes 000102...\n\n");
483     for (x = 0; cipher_descriptor[x].name != NULL; x++) {
484        kl = cipher_descriptor[x].block_length;
485        if (kl != 16) continue;
486        if (cipher_descriptor[x].keysize(&kl) != CRYPT_OK) {
487           kl = cipher_descriptor[x].max_key_length;
488        }
489        fprintf(out, "GCM-%s (%d byte key)\n", cipher_descriptor[x].name, kl);
490        for (z = 0; z < kl; z++) {
491            key[z] = (z & 255);
492        }
493        for (y1 = 1; y1 <= (int)(cipher_descriptor[x].block_length*2); y1++){
494           for (z = 0; z < y1; z++) {
495              plaintext[z] = (unsigned char)(z & 255);
496           }
497           len = sizeof(tag);
498           if ((err = gcm_memory(x, key, kl, plaintext, y1, plaintext, y1, plaintext, y1, plaintext, tag, &len, GCM_ENCRYPT)) != CRYPT_OK) {
499              printf("Error GCM'ing: %s\n", error_to_string(err));
500              exit(EXIT_FAILURE);
501           }
502           if (len == 0) {
503              printf("Error GCM'ing: zero length\n");
504              exit(EXIT_FAILURE);
505           }
506           fprintf(out, "%3d: ", y1);
507           for (z = 0; z < y1; z++) {
508              fprintf(out, "%02X", plaintext[z]);
509           }
510           fprintf(out, ", ");
511           for (z = 0; z <(int)len; z++) {
512              fprintf(out, "%02X", tag[z]);
513           }
514           fprintf(out, "\n");
515           for (z = 0; z < kl; z++) {
516               key[z] = tag[z % len];
517           }
518        }
519        fprintf(out, "\n");
520     }
521     fclose(out);
522  }
523  #endif
524  static void base64_gen(void)
525  {
526     FILE *out;
527     unsigned char src[32], ch;
528     char dst[256];
529     unsigned long x, len;
530     out = fopen("base64_tv.txt", "w");
531     fprintf(out, "Base64 vectors.  These are the base64 encodings of the strings 00,01,02...NN-1\n\n");
532     for (x = 0; x <= 32; x++) {
533         for (ch = 0; ch < x; ch++) {
534             src[ch] = ch;
535         }
536         len = sizeof(dst);
537         base64_encode(src, x, dst, &len);
538         fprintf(out, "%2lu: %s\n", x, dst);
539     }
540     fclose(out);
541  }
542  static void math_gen(void)
543  {
544  }
545  static void ecc_gen(void)
546  {
547     FILE         *out;
548     unsigned char str[512];
549     void          *k, *order, *modulus, *a;
550     ecc_point    *G, *R;
551     int           x;
552     out = fopen("ecc_tv.txt", "w");
553     fprintf(out, "ecc vectors.  These are for kG for k=1,3,9,27,...,3**n until k > order of the curve outputs are <k,x,y> triplets\n\n");
554     G = ltc_ecc_new_point();
555     R = ltc_ecc_new_point();
556     mp_init(&k);
557     mp_init(&order);
558     mp_init(&modulus);
559     mp_init(&a);
560     for (x = 0; ltc_ecc_curves[x].prime != NULL; x++) {
561          fprintf(out, "%s\n", ltc_ecc_curves[x].OID);
562          mp_set(k, 1);
563          mp_read_radix(order,   (char *)ltc_ecc_curves[x].order, 16);
564          mp_read_radix(modulus, (char *)ltc_ecc_curves[x].prime, 16);
565          mp_read_radix(a,       (char *)ltc_ecc_curves[x].A,     16);
566          mp_read_radix(G->x,    (char *)ltc_ecc_curves[x].Gx,    16);
567          mp_read_radix(G->y,    (char *)ltc_ecc_curves[x].Gy,    16);
568          mp_set(G->z, 1);
569          while (mp_cmp(k, order) == LTC_MP_LT) {
570              ltc_mp.ecc_ptmul(k, G, R, a, modulus, 1);
571              mp_tohex(k,    (char*)str); fprintf(out, "%s, ", (char*)str);
572              mp_tohex(R->x, (char*)str); fprintf(out, "%s, ", (char*)str);
573              mp_tohex(R->y, (char*)str); fprintf(out, "%s\n", (char*)str);
574              mp_mul_d(k, 3, k);
575          }
576     }
577     mp_clear_multi(k, order, modulus, a, LTC_NULL);
578     ltc_ecc_del_point(G);
579     ltc_ecc_del_point(R);
580     fclose(out);
581  }
582  #ifdef LTC_LRW_MODE
583  static void lrw_gen(void)
584  {
585     FILE *out;
586     unsigned char tweak[16], key[16], iv[16], buf[1024];
587     int x, y, err;
588     symmetric_LRW lrw;
589     for (x = 0; x < 16; x++) {
590        tweak[x] = key[x] = iv[x] = x;
591     }
592     out = fopen("lrw_tv.txt", "w");
593     for (x = 16; x < (int)(sizeof(buf)); x += 16) {
594         if ((err = lrw_start(find_cipher("aes"), iv, key, 16, tweak, 0, &lrw)) != CRYPT_OK) {
595            fprintf(stderr, "Error starting LRW-AES: %s\n", error_to_string(err));
596            exit(EXIT_FAILURE);
597         }
598         for (y = 0; y < x; y++) {
599             buf[y] = y & 255;
600         }
601         if ((err = lrw_encrypt(buf, buf, x, &lrw)) != CRYPT_OK) {
602            fprintf(stderr, "Error encrypting with LRW-AES: %s\n", error_to_string(err));
603            exit(EXIT_FAILURE);
604         }
605         fprintf(out, "%d:", x);
606         for (y = 0; y < x; y++) {
607            fprintf(out, "%02x", buf[y]);
608         }
609         fprintf(out, "\n");
610         if ((err = lrw_setiv(iv, 16, &lrw)) != CRYPT_OK) {
611            fprintf(stderr, "Error setting IV: %s\n", error_to_string(err));
612            exit(EXIT_FAILURE);
613         }
614         for (y = 0; y < 16; y++) {
615            key[y]   = buf[y];
616            iv[y]    = buf[(y+16)%x];
617            tweak[y] = buf[(y+32)%x];
618         }
619         if ((err = lrw_decrypt(buf, buf, x, &lrw)) != CRYPT_OK) {
620            fprintf(stderr, "Error decrypting with LRW-AES: %s\n", error_to_string(err));
621            exit(EXIT_FAILURE);
622         }
623         fprintf(out, "%d:", x);
624         for (y = 0; y < x; y++) {
625            fprintf(out, "%02x", buf[y]);
626         }
627         fprintf(out, "\n");
628         lrw_done(&lrw);
629     }
630     fclose(out);
631  }
632  #endif
633  int main(void)
634  {
635     register_all_ciphers();
636     register_all_hashes();
637     register_all_prngs();
638  #ifdef USE_LTM
639     ltc_mp = ltm_desc;
640  #elif defined(USE_TFM)
641     ltc_mp = tfm_desc;
642  #elif defined(USE_GMP)
643     ltc_mp = gmp_desc;
644  #elif defined(EXT_MATH_LIB)
645     extern ltc_math_descriptor EXT_MATH_LIB;
646     ltc_mp = EXT_MATH_LIB;
647  #endif
648     printf("Generating hash   vectors..."); fflush(stdout); hash_gen();   printf("done\n");
649     printf("Generating cipher vectors..."); fflush(stdout); cipher_gen(); printf("done\n");
650     printf("Generating HMAC   vectors..."); fflush(stdout); hmac_gen();   printf("done\n");
651  #ifdef LTC_OMAC
652     printf("Generating OMAC   vectors..."); fflush(stdout); omac_gen();   printf("done\n");
653  #endif
654  #ifdef LTC_PMAC
655     printf("Generating PMAC   vectors..."); fflush(stdout); pmac_gen();   printf("done\n");
656  #endif
657  #ifdef LTC_EAX_MODE
658     printf("Generating EAX    vectors..."); fflush(stdout); eax_gen();    printf("done\n");
659  #endif
660  #ifdef LTC_OCB_MODE
661     printf("Generating OCB    vectors..."); fflush(stdout); ocb_gen();    printf("done\n");
662  #endif
663  #ifdef LTC_OCB3_MODE
664     printf("Generating OCB3   vectors..."); fflush(stdout); ocb3_gen();   printf("done\n");
665  #endif
666  #ifdef LTC_CCM_MODE
667     printf("Generating CCM    vectors..."); fflush(stdout); ccm_gen();    printf("done\n");
668  #endif
669  #ifdef LTC_GCM_MODE
670     printf("Generating GCM    vectors..."); fflush(stdout); gcm_gen();    printf("done\n");
671  #endif
672     printf("Generating BASE64 vectors..."); fflush(stdout); base64_gen(); printf("done\n");
673     if (ltc_mp.name != NULL) {
674        printf("Generating MATH   vectors..."); fflush(stdout); math_gen();   printf("done\n");
675        printf("Generating ECC    vectors..."); fflush(stdout); ecc_gen();    printf("done\n");
676     }
677  #ifdef LTC_LRW_MODE
678     printf("Generating LRW    vectors..."); fflush(stdout); lrw_gen();    printf("done\n");
679  #endif
680     return 0;
681  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from fftw3-MDEwOlJlcG9zaXRvcnk4ODQzMzg4-flat-mktensor-rowmajor.c</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from libtomcrypt-MDEwOlJlcG9zaXRvcnk3NzcwMTE=-flat-tv_gen.c</div>
                </div>
                <div class="column column_space"><pre><code>2  tensor *X(mktensor_rowmajor)(int rnk, const int *n,
3  			     const int *niphys, const int *nophys,
4  			     int is, int os)
5  {
6       tensor *x = X(mktensor)(rnk);
</pre></code></div>
                <div class="column column_space"><pre><code>40  static void cipher_gen(void)
41  {
42     unsigned char *key, pt[MAXBLOCKSIZE];
43     unsigned long x, y, z, w;
44     int err, kl, lastkl;
45     FILE *out;
46     symmetric_key skey;
47     out = fopen("cipher_tv.txt", "w");
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    