
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 8.37696335078534%, Tokens: 16, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>xmrig-MDEwOlJlcG9zaXRvcnk4ODMyNzQwNg==-flat-DnsRecords.h</h3>
            <pre><code>1  #ifndef XMRIG_DNSRECORDS_H
2  #define XMRIG_DNSRECORDS_H
3  #include "base/net/dns/DnsRecord.h"
4  namespace xmrig {
5  class DnsRecords
6  {
7  public:
<span onclick='openModal()' class='match'>8      inline bool isEmpty() const       { return m_ipv4.empty() && m_ipv6.empty(); }
9      const DnsRecord &get(DnsRecord::Type prefered = DnsRecord::Unknown) const;
10      size_t count(DnsRecord::Type type = DnsRecord::Unknown) const;
11      void clear();
12      void parse(addrinfo *res);
13  private:
14      std::vector<DnsRecord> m_ipv4;
15      std::vector<DnsRecord> m_ipv6;
</span>16  };
17  } &bsol;* namespace xmrig */
18  #endif &bsol;* XMRIG_DNSRECORDS_H */
</code></pre>
        </div>
        <div class="column">
            <h3>android-gpuimage-plus-MDEwOlJlcG9zaXRvcnk0NjU0NzQxNw==-flat-avio.h</h3>
            <pre><code>1  #ifndef AVFORMAT_AVIO_H
2  #define AVFORMAT_AVIO_H
3  #include <stdint.h>
4  #include "libavutil/common.h"
5  #include "libavutil/dict.h"
6  #include "libavutil/log.h"
7  #include "libavformat/version.h"
8  #define AVIO_SEEKABLE_NORMAL (1 << 0)
9  #define AVIO_SEEKABLE_TIME   (1 << 1)
10  typedef struct AVIOInterruptCB {
11      int (*callback)(void*);
12      void *opaque;
13  } AVIOInterruptCB;
14  enum AVIODirEntryType {
15      AVIO_ENTRY_UNKNOWN,
16      AVIO_ENTRY_BLOCK_DEVICE,
17      AVIO_ENTRY_CHARACTER_DEVICE,
18      AVIO_ENTRY_DIRECTORY,
19      AVIO_ENTRY_NAMED_PIPE,
20      AVIO_ENTRY_SYMBOLIC_LINK,
21      AVIO_ENTRY_SOCKET,
22      AVIO_ENTRY_FILE,
23      AVIO_ENTRY_SERVER,
24      AVIO_ENTRY_SHARE,
25      AVIO_ENTRY_WORKGROUP,
26  };
27  typedef struct AVIODirEntry {
28      char *name;                           &bsol;**< Filename */
29      int type;                             &bsol;**< Type of the entry */
30      int utf8;                             &bsol;**< Set to 1 when name is encoded with UTF-8, 0 otherwise.
31                                                 Name can be encoded with UTF-8 even though 0 is set. */
32      int64_t size;                         &bsol;**< File size in bytes, -1 if unknown. */
33      int64_t modification_timestamp;       &bsol;**< Time of last modification in microseconds since unix
34                                                 epoch, -1 if unknown. */
35      int64_t access_timestamp;             &bsol;**< Time of last access in microseconds since unix epoch,
36                                                 -1 if unknown. */
37      int64_t status_change_timestamp;      &bsol;**< Time of last status change in microseconds since unix
38                                                 epoch, -1 if unknown. */
39      int64_t user_id;                      &bsol;**< User ID of owner, -1 if unknown. */
40      int64_t group_id;                     &bsol;**< Group ID of owner, -1 if unknown. */
41      int64_t filemode;                     &bsol;**< Unix file mode, -1 if unknown. */
42  } AVIODirEntry;
43  typedef struct AVIODirContext {
44      struct URLContext *url_context;
45  } AVIODirContext;
46  enum AVIODataMarkerType {
47      AVIO_DATA_MARKER_HEADER,
48      AVIO_DATA_MARKER_SYNC_POINT,
49      AVIO_DATA_MARKER_BOUNDARY_POINT,
50      AVIO_DATA_MARKER_UNKNOWN,
51      AVIO_DATA_MARKER_TRAILER,
52      AVIO_DATA_MARKER_FLUSH_POINT,
53  };
54  typedef struct AVIOContext {
55      const AVClass *av_class;
56      unsigned char *buffer;  &bsol;**< Start of the buffer. */
57      int buffer_size;        &bsol;**< Maximum buffer size */
58      unsigned char *buf_ptr; &bsol;**< Current position in the buffer */
59      unsigned char *buf_end; &bsol;**< End of the data, may be less than
60                                   buffer+buffer_size if the read function returned
61                                   less data than requested, e.g. for streams where
62                                   no more data has been received yet. */
63      void *opaque;           &bsol;**< A private pointer, passed to the read/write/seek/...
64                                   functions. */
65      int (*read_packet)(void *opaque, uint8_t *buf, int buf_size);
66      int (*write_packet)(void *opaque, uint8_t *buf, int buf_size);
67      int64_t (*seek)(void *opaque, int64_t offset, int whence);
68      int64_t pos;            &bsol;**< position in the file of the current buffer */
69      int must_flush;         &bsol;**< unused */
70      int eof_reached;        &bsol;**< true if eof reached */
71      int write_flag;         &bsol;**< true if open for writing */
72      int max_packet_size;
73      unsigned long checksum;
74      unsigned char *checksum_ptr;
75      unsigned long (*update_checksum)(unsigned long checksum, const uint8_t *buf, unsigned int size);
76      int error;              &bsol;**< contains the error code or 0 if no error happened */
77      int (*read_pause)(void *opaque, int pause);
78      int64_t (*read_seek)(void *opaque, int stream_index,
79                           int64_t timestamp, int flags);
80      int seekable;
81      int64_t maxsize;
82      int direct;
83      int64_t bytes_read;
84      int seek_count;
85      int writeout_count;
86      int orig_buffer_size;
87      int short_seek_threshold;
88      const char *protocol_whitelist;
89      const char *protocol_blacklist;
90      int (*write_data_type)(void *opaque, uint8_t *buf, int buf_size,
91                             enum AVIODataMarkerType type, int64_t time);
92      int ignore_boundary_point;
93      enum AVIODataMarkerType current_type;
94      int64_t last_time;
95      int (*short_seek_get)(void *opaque);
96      int64_t written;
97      unsigned char *buf_ptr_max;
98      int min_packet_size;
99  } AVIOContext;
100  const char *avio_find_protocol_name(const char *url);
101  int avio_check(const char *url, int flags);
102  int avpriv_io_move(const char *url_src, const char *url_dst);
103  int avpriv_io_delete(const char *url);
104  int avio_open_dir(AVIODirContext **s, const char *url, AVDictionary **options);
105  int avio_read_dir(AVIODirContext *s, AVIODirEntry **next);
106  int avio_close_dir(AVIODirContext **s);
107  void avio_free_directory_entry(AVIODirEntry **entry);
108  AVIOContext *avio_alloc_context(
109                    unsigned char *buffer,
110                    int buffer_size,
111                    int write_flag,
112                    void *opaque,
113                    int (*read_packet)(void *opaque, uint8_t *buf, int buf_size),
114                    int (*write_packet)(void *opaque, uint8_t *buf, int buf_size),
115                    int64_t (*seek)(void *opaque, int64_t offset, int whence));
116  void avio_context_free(AVIOContext **s);
117  void avio_w8(AVIOContext *s, int b);
118  void avio_write(AVIOContext *s, const unsigned char *buf, int size);
119  void avio_wl64(AVIOContext *s, uint64_t val);
120  void avio_wb64(AVIOContext *s, uint64_t val);
121  void avio_wl32(AVIOContext *s, unsigned int val);
122  void avio_wb32(AVIOContext *s, unsigned int val);
123  void avio_wl24(AVIOContext *s, unsigned int val);
124  void avio_wb24(AVIOContext *s, unsigned int val);
125  void avio_wl16(AVIOContext *s, unsigned int val);
126  void avio_wb16(AVIOContext *s, unsigned int val);
127  int avio_put_str(AVIOContext *s, const char *str);
128  int avio_put_str16le(AVIOContext *s, const char *str);
129  int avio_put_str16be(AVIOContext *s, const char *str);
130  void avio_write_marker(AVIOContext *s, int64_t time, enum AVIODataMarkerType type);
131  #define AVSEEK_SIZE 0x10000
132  #define AVSEEK_FORCE 0x20000
133  int64_t avio_seek(AVIOContext *s, int64_t offset, int whence);
134  int64_t avio_skip(AVIOContext *s, int64_t offset);
135  static av_always_inline int64_t avio_tell(AVIOContext *s)
136  {
<span onclick='openModal()' class='match'>137      return avio_seek(s, 0, SEEK_CUR);
138  }
139  int64_t avio_size(AVIOContext *s);
140  int avio_feof(AVIOContext *s);
141  #if FF_API_URL_FEOF
142  attribute_deprecated
143  int url_feof(AVIOContext *s);
144  #endif
145  int avio_printf(AVIOContext *s, const char *fmt, ...) av_printf_format(2, 3);
146  void avio_flush(AVIOContext *s);
147  int avio_read(AVIOContext *s, unsigned char *buf, int size);
148  int avio_read_partial(AVIOContext *s, unsigned char *buf, int size);
149  int          avio_r8  (AVIOContext *s);
150  unsigned int avio_rl16(AVIOContext *s);
</span>151  unsigned int avio_rl24(AVIOContext *s);
152  unsigned int avio_rl32(AVIOContext *s);
153  uint64_t     avio_rl64(AVIOContext *s);
154  unsigned int avio_rb16(AVIOContext *s);
155  unsigned int avio_rb24(AVIOContext *s);
156  unsigned int avio_rb32(AVIOContext *s);
157  uint64_t     avio_rb64(AVIOContext *s);
158  int avio_get_str(AVIOContext *pb, int maxlen, char *buf, int buflen);
159  int avio_get_str16le(AVIOContext *pb, int maxlen, char *buf, int buflen);
160  int avio_get_str16be(AVIOContext *pb, int maxlen, char *buf, int buflen);
161  #define AVIO_FLAG_READ  1                                      &bsol;**< read-only */
162  #define AVIO_FLAG_WRITE 2                                      &bsol;**< write-only */
163  #define AVIO_FLAG_READ_WRITE (AVIO_FLAG_READ|AVIO_FLAG_WRITE)  &bsol;**< read-write pseudo flag */
164  #define AVIO_FLAG_NONBLOCK 8
165  #define AVIO_FLAG_DIRECT 0x8000
166  int avio_open(AVIOContext **s, const char *url, int flags);
167  int avio_open2(AVIOContext **s, const char *url, int flags,
168                 const AVIOInterruptCB *int_cb, AVDictionary **options);
169  int avio_close(AVIOContext *s);
170  int avio_closep(AVIOContext **s);
171  int avio_open_dyn_buf(AVIOContext **s);
172  int avio_get_dyn_buf(AVIOContext *s, uint8_t **pbuffer);
173  int avio_close_dyn_buf(AVIOContext *s, uint8_t **pbuffer);
174  const char *avio_enum_protocols(void **opaque, int output);
175  int     avio_pause(AVIOContext *h, int pause);
176  int64_t avio_seek_time(AVIOContext *h, int stream_index,
177                         int64_t timestamp, int flags);
178  struct AVBPrint;
179  int avio_read_to_bprint(AVIOContext *h, struct AVBPrint *pb, size_t max_size);
180  int avio_accept(AVIOContext *s, AVIOContext **c);
181  int avio_handshake(AVIOContext *c);
182  #endif &bsol;* AVFORMAT_AVIO_H */
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from xmrig-MDEwOlJlcG9zaXRvcnk4ODMyNzQwNg==-flat-DnsRecords.h</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from android-gpuimage-plus-MDEwOlJlcG9zaXRvcnk0NjU0NzQxNw==-flat-avio.h</div>
                </div>
                <div class="column column_space"><pre><code>8      inline bool isEmpty() const       { return m_ipv4.empty() && m_ipv6.empty(); }
9      const DnsRecord &get(DnsRecord::Type prefered = DnsRecord::Unknown) const;
10      size_t count(DnsRecord::Type type = DnsRecord::Unknown) const;
11      void clear();
12      void parse(addrinfo *res);
13  private:
14      std::vector<DnsRecord> m_ipv4;
15      std::vector<DnsRecord> m_ipv6;
</pre></code></div>
                <div class="column column_space"><pre><code>137      return avio_seek(s, 0, SEEK_CUR);
138  }
139  int64_t avio_size(AVIOContext *s);
140  int avio_feof(AVIOContext *s);
141  #if FF_API_URL_FEOF
142  attribute_deprecated
143  int url_feof(AVIOContext *s);
144  #endif
145  int avio_printf(AVIOContext *s, const char *fmt, ...) av_printf_format(2, 3);
146  void avio_flush(AVIOContext *s);
147  int avio_read(AVIOContext *s, unsigned char *buf, int size);
148  int avio_read_partial(AVIOContext *s, unsigned char *buf, int size);
149  int          avio_r8  (AVIOContext *s);
150  unsigned int avio_rl16(AVIOContext *s);
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    