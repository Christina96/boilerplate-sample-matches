
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 11.12781954887218%, Tokens: 10, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>Adafruit_nRF52_Arduino-MDEwOlJlcG9zaXRvcnk3NDM1NDcyOQ==-flat-crypto.c</h3>
            <pre><code>1  #include <stdint.h>
2  #include <string.h>
3  #include <nrf_soc.h>
4  #include <Adafruit_LittleFS.h>
5  #include <InternalFileSystem.h>
6  #include "utility/debug.h"
7  #include "rtos.h"
8  #include "utility/AdaCallback.h"
9  #include "crypto.h"
10  using namespace Adafruit_LittleFS_Namespace;
11  #define CRYPTO_INSTANCE  2   
12  crypto_keys_t crypto_keys;
13  static const uint8_t zeros64[64];
14  static uint8_t crypto_loadKeys(void);
15  #define CRYPTO_KEYDIR    "/adafruit/homekit"
16  #define CRYPTO_KEYFILE   CRYPTO_KEYDIR "/key"
17  typedef struct
18  {
19    uint8_t valid0;
20    uint8_t instance;
21    uint8_t srp_b[32];
22    uint8_t srp_salt[16];
23    uint8_t srp_v[384];
24    uint8_t srp_B[384];
25    uint8_t sign_secret[64];
26    uint8_t clientname[36];
27    uint8_t ltpk[32];
28    uint8_t valid1;
29    uint8_t __padding__[1];
30  } crypto_persistent_keys_t;
31  void crypto_printkey(void)
32  {
33    crypto_persistent_keys_t keys = {};
34    uint32_t keylen = sizeof(keys);
35    fsutil_read_file(CRYPTO_KEYFILE, 0, keylen, &keys, &keylen);
36    if (keys.valid0 == 0x55 && keys.valid1 == 0xAA && keys.instance == CRYPTO_INSTANCE)
37    {
38        dbgDumpMemoryCFormat("uint8_t keys[] = ", &keys, sizeof(keys));
39    }
40  }
41  void crypto_init(void)
42  {
43    if (!crypto_loadKeys())
44    {
45      srp_init();
46      crypto_sign_keypair(crypto_keys.sign.pub, crypto_keys.sign.secret);
47      crypto_storeKeys();
48    }
49  }
50  static uint8_t crypto_loadKeys(void)
51  {
52    crypto_persistent_keys_t keys = {};
53    uint32_t keylen = sizeof(keys);
54    File file(CRYPTO_KEYFILE, FILE_O_READ, InternalFS);
55    VERIFY(file, 0);
56    keylen = file.read(&keys, keylen);
57    file.close();
58    if (keys.valid0 == 0x55 && keys.valid1 == 0xAA && keys.instance == CRYPTO_INSTANCE)
59    {
60      memcpy(srp.b, keys.srp_b, 32);
61      memcpy(srp.salt, keys.srp_salt, 16);
62      memcpy(srp.v, keys.srp_v, 384);
63      memcpy(srp.B, keys.srp_B, 384);
64      memcpy(crypto_keys.sign.secret, keys.sign_secret, 64);
65      memcpy(crypto_keys.client.name, keys.clientname, 36);
66      memcpy(crypto_keys.client.ltpk, keys.ltpk, 32);
67      return 1;
68    }
69    else
70    {
71      return 0;
72    }
73  }
74  void crypto_scheduleStoreKeys(void)
75  {
76    ada_callback(NULL, 0, crypto_storeKeys);
77  }
78  void crypto_storeKeys(void)
79  {
80    {
81      crypto_persistent_keys_t keys = {};
82      memcpy(keys.srp_b, srp.b, 32);
83      memcpy(keys.srp_salt, srp.salt, 16);
84      memcpy(keys.srp_v, srp.v, 384);
85      memcpy(keys.srp_B, srp.B, 384);
86      memcpy(keys.sign_secret, crypto_keys.sign.secret, 64);
87      memcpy(keys.clientname, crypto_keys.client.name, 36);
88      memcpy(keys.ltpk, crypto_keys.client.ltpk, 32);
89      keys.instance = CRYPTO_INSTANCE;
90      keys.valid0 = 0x55;
91      keys.valid1 = 0xAA;
92      File file(CRYPTO_KEYFILE, FILE_O_WRITE, InternalFS);
93      VERIFY(file,);
94      file.write(&keys, sizeof(keys));
95      file.close();
96    }
97  }
98  uint8_t crypto_advertise(void)
99  {
100    if (crypto_keys.client.name[0])
101    {
102      return 0;
103    }
104    else
105    {
106      return 1;
<span onclick='openModal()' class='match'>107    }
108  }
109  uint8_t crypto_verifyAndDecrypt(const uint8_t* key, uint8_t* nonce, uint8_t* encrypted, uint8_t length, uint8_t* output_buf, uint8_t* mac)
110  {
111    uint8_t polykey[sizeof(zeros64)];
</span>112    crypto_stream_chacha20_xor(polykey, zeros64, sizeof(zeros64), nonce, key, 0);
113    uint8_t padding = (16 - length % 16) % 16;
114    uint8_t message[length + padding + 16];
115    memcpy(message, encrypted, length);
116    memset(message + length, 0, padding + 16);
117    message[length + padding + 8] = (uint8_t)length;
118    message[length + padding + 9] = (uint8_t)(length >> 8);
119    if (crypto_onetimeauth_poly1305_verify(mac, message, sizeof(message), polykey) != 0)
120    {
121      return 0;
122    }
123    else
124    {
125      crypto_stream_chacha20_xor(output_buf, message, length, nonce, key, 1);
126      return 1;
127    }
128  }
129  void crypto_encryptAndSeal(const uint8_t* key, uint8_t* nonce, uint8_t* plain, uint16_t length, uint8_t* output_buf, uint8_t* output_mac)
130  {
131    uint8_t polykey[sizeof(zeros64)];
132    crypto_stream_chacha20_xor(polykey, zeros64, sizeof(zeros64), nonce, key, 0);
133    uint8_t padding = (16 - length % 16) % 16;
134    uint8_t message[length + padding + 16];
135    crypto_stream_chacha20_xor(message, plain, length, nonce, key, 1);
136    memset(message + length, 0, padding + 16);
137    message[length + padding + 8] = (uint8_t)length;
138    message[length + padding + 9] = (uint8_t)(length >> 8);
139    crypto_onetimeauth_poly1305(output_mac, message, sizeof(message), polykey);
140    memcpy(output_buf, message, length);
141  }
142  void crypto_sha512hmac(uint8_t* hash, uint8_t* salt, uint8_t salt_length, uint8_t* data, uint8_t data_length)
143  {
144    uint8_t message1[128 + data_length];
145    uint8_t message2[128 + 64];
146    memset(message1, 0x36, 128);
147    memset(message2, 0x5C, 128);
148    for (unsigned i = salt_length; i--; )
149    {
150      message1[i] = 0x36 ^ salt[i];
151      message2[i] = 0x5C ^ salt[i];
152    }
153    memcpy(message1 + 128, data, data_length);
154    crypto_hash_sha512(message2 + 128, message1, sizeof(message1));
155    crypto_hash_sha512(hash, message2, sizeof(message2));
156  }
157  void crypto_hkdf(uint8_t* target, uint8_t* salt, uint8_t salt_length, uint8_t* info, uint8_t info_length, uint8_t* ikm, uint8_t ikm_length)
158  {
159    crypto_sha512hmac(target, salt, salt_length, ikm, ikm_length);
160    crypto_sha512hmac(target, target, 64, info, info_length);
161  }
162  void crypto_transportEncrypt(uint8_t* key, uint8_t* nonce, uint8_t* plaintext, uint16_t plength, uint8_t* ciphertext, uint16_t* clength)
163  {
164    crypto_encryptAndSeal(key, nonce, plaintext, plength, ciphertext, ciphertext + plength);
165    for (unsigned i = 0; i < 8 && !++nonce[i]; i++)
166      ;
167    *clength = plength + 16;
168  }
169  uint8_t crypto_transportDecrypt(uint8_t* key, uint8_t* nonce, uint8_t* ciphertext, uint16_t clength, uint8_t* plaintext, uint16_t* plength)
170  {
171    uint8_t r = crypto_verifyAndDecrypt(key, nonce, ciphertext, clength - 16, plaintext, ciphertext + clength - 16);
172    for (unsigned i = 0; i < 8 && !++nonce[i]; i++)
173      ;
174    *plength = clength - 16;
175    return r;
176  }
</code></pre>
        </div>
        <div class="column">
            <h3>redis-MDEwOlJlcG9zaXRvcnkxMDgxMTA3MDY=-flat-arena_inlines_b.h</h3>
            <pre><code>1  #ifndef JEMALLOC_INTERNAL_ARENA_INLINES_B_H
2  #define JEMALLOC_INTERNAL_ARENA_INLINES_B_H
3  #include "jemalloc/internal/jemalloc_internal_types.h"
4  #include "jemalloc/internal/mutex.h"
5  #include "jemalloc/internal/rtree.h"
6  #include "jemalloc/internal/sc.h"
7  #include "jemalloc/internal/sz.h"
8  #include "jemalloc/internal/ticker.h"
9  JEMALLOC_ALWAYS_INLINE bool
10  arena_has_default_hooks(arena_t *arena) {
11  	return (extent_hooks_get(arena) == &extent_hooks_default);
12  }
13  JEMALLOC_ALWAYS_INLINE arena_t *
14  arena_choose_maybe_huge(tsd_t *tsd, arena_t *arena, size_t size) {
15  	if (arena != NULL) {
16  		return arena;
17  	}
18  	if (unlikely(size >= oversize_threshold)) {
19  		arena_t *tsd_arena = tsd_arena_get(tsd);
20  		if (tsd_arena == NULL || arena_is_auto(tsd_arena)) {
21  			return arena_choose_huge(tsd);
22  		}
23  	}
24  	return arena_choose(tsd, NULL);
25  }
26  JEMALLOC_ALWAYS_INLINE prof_tctx_t *
27  arena_prof_tctx_get(tsdn_t *tsdn, const void *ptr, alloc_ctx_t *alloc_ctx) {
28  	cassert(config_prof);
29  	assert(ptr != NULL);
30  	if (alloc_ctx == NULL) {
31  		const extent_t *extent = iealloc(tsdn, ptr);
32  		if (unlikely(!extent_slab_get(extent))) {
33  			return large_prof_tctx_get(tsdn, extent);
34  		}
35  	} else {
36  		if (unlikely(!alloc_ctx->slab)) {
37  			return large_prof_tctx_get(tsdn, iealloc(tsdn, ptr));
38  		}
39  	}
40  	return (prof_tctx_t *)(uintptr_t)1U;
41  }
42  JEMALLOC_ALWAYS_INLINE void
43  arena_prof_tctx_set(tsdn_t *tsdn, const void *ptr, size_t usize,
44      alloc_ctx_t *alloc_ctx, prof_tctx_t *tctx) {
45  	cassert(config_prof);
46  	assert(ptr != NULL);
47  	if (alloc_ctx == NULL) {
48  		extent_t *extent = iealloc(tsdn, ptr);
49  		if (unlikely(!extent_slab_get(extent))) {
50  			large_prof_tctx_set(tsdn, extent, tctx);
51  		}
52  	} else {
53  		if (unlikely(!alloc_ctx->slab)) {
54  			large_prof_tctx_set(tsdn, iealloc(tsdn, ptr), tctx);
55  		}
56  	}
57  }
58  static inline void
59  arena_prof_tctx_reset(tsdn_t *tsdn, const void *ptr, prof_tctx_t *tctx) {
60  	cassert(config_prof);
61  	assert(ptr != NULL);
62  	extent_t *extent = iealloc(tsdn, ptr);
63  	assert(!extent_slab_get(extent));
64  	large_prof_tctx_reset(tsdn, extent);
65  }
66  JEMALLOC_ALWAYS_INLINE nstime_t
67  arena_prof_alloc_time_get(tsdn_t *tsdn, const void *ptr,
68      alloc_ctx_t *alloc_ctx) {
69  	cassert(config_prof);
70  	assert(ptr != NULL);
71  	extent_t *extent = iealloc(tsdn, ptr);
72  	assert(!extent_slab_get(extent));
73  	return large_prof_alloc_time_get(extent);
74  }
75  JEMALLOC_ALWAYS_INLINE void
76  arena_prof_alloc_time_set(tsdn_t *tsdn, const void *ptr, alloc_ctx_t *alloc_ctx,
77      nstime_t t) {
78  	cassert(config_prof);
79  	assert(ptr != NULL);
80  	extent_t *extent = iealloc(tsdn, ptr);
81  	assert(!extent_slab_get(extent));
82  	large_prof_alloc_time_set(extent, t);
83  }
84  JEMALLOC_ALWAYS_INLINE void
85  arena_decay_ticks(tsdn_t *tsdn, arena_t *arena, unsigned nticks) {
86  	tsd_t *tsd;
87  	ticker_t *decay_ticker;
88  	if (unlikely(tsdn_null(tsdn))) {
89  		return;
90  	}
91  	tsd = tsdn_tsd(tsdn);
92  	decay_ticker = decay_ticker_get(tsd, arena_ind_get(arena));
93  	if (unlikely(decay_ticker == NULL)) {
94  		return;
95  	}
96  	if (unlikely(ticker_ticks(decay_ticker, nticks))) {
97  		arena_decay(tsdn, arena, false, false);
98  	}
99  }
100  JEMALLOC_ALWAYS_INLINE void
101  arena_decay_tick(tsdn_t *tsdn, arena_t *arena) {
102  	malloc_mutex_assert_not_owner(tsdn, &arena->decay_dirty.mtx);
103  	malloc_mutex_assert_not_owner(tsdn, &arena->decay_muzzy.mtx);
104  	arena_decay_ticks(tsdn, arena, 1);
105  }
106  JEMALLOC_ALWAYS_INLINE void
107  arena_decay_extent(tsdn_t *tsdn,arena_t *arena, extent_hooks_t **r_extent_hooks,
108      extent_t *extent) {
109  	size_t extent_size = extent_size_get(extent);
110  	extent_dalloc_wrapper(tsdn, arena,
111  	    r_extent_hooks, extent);
112  	if (config_stats) {
113  		arena_stats_lock(tsdn, &arena->stats);
114  		arena_stats_add_u64(tsdn, &arena->stats,
115  		    &arena->decay_dirty.stats->nmadvise, 1);
116  		arena_stats_add_u64(tsdn, &arena->stats,
117  		    &arena->decay_dirty.stats->purged, extent_size >> LG_PAGE);
118  		arena_stats_sub_zu(tsdn, &arena->stats, &arena->stats.mapped,
119  		    extent_size);
120  		arena_stats_unlock(tsdn, &arena->stats);
<span onclick='openModal()' class='match'>121  	}
122  }
123  JEMALLOC_ALWAYS_INLINE void *
124  arena_malloc(tsdn_t *tsdn, arena_t *arena, size_t size, szind_t ind, bool zero,
125      tcache_t *tcache, bool slow_path) {
</span>126  	assert(!tsdn_null(tsdn) || tcache == NULL);
127  	if (likely(tcache != NULL)) {
128  		if (likely(size <= SC_SMALL_MAXCLASS)) {
129  			return tcache_alloc_small(tsdn_tsd(tsdn), arena,
130  			    tcache, size, ind, zero, slow_path);
131  		}
132  		if (likely(size <= tcache_maxclass)) {
133  			return tcache_alloc_large(tsdn_tsd(tsdn), arena,
134  			    tcache, size, ind, zero, slow_path);
135  		}
136  		assert(size > tcache_maxclass);
137  	}
138  	return arena_malloc_hard(tsdn, arena, size, ind, zero);
139  }
140  JEMALLOC_ALWAYS_INLINE arena_t *
141  arena_aalloc(tsdn_t *tsdn, const void *ptr) {
142  	return extent_arena_get(iealloc(tsdn, ptr));
143  }
144  JEMALLOC_ALWAYS_INLINE size_t
145  arena_salloc(tsdn_t *tsdn, const void *ptr) {
146  	assert(ptr != NULL);
147  	rtree_ctx_t rtree_ctx_fallback;
148  	rtree_ctx_t *rtree_ctx = tsdn_rtree_ctx(tsdn, &rtree_ctx_fallback);
149  	szind_t szind = rtree_szind_read(tsdn, &extents_rtree, rtree_ctx,
150  	    (uintptr_t)ptr, true);
151  	assert(szind != SC_NSIZES);
152  	return sz_index2size(szind);
153  }
154  JEMALLOC_ALWAYS_INLINE size_t
155  arena_vsalloc(tsdn_t *tsdn, const void *ptr) {
156  	rtree_ctx_t rtree_ctx_fallback;
157  	rtree_ctx_t *rtree_ctx = tsdn_rtree_ctx(tsdn, &rtree_ctx_fallback);
158  	extent_t *extent;
159  	szind_t szind;
160  	if (rtree_extent_szind_read(tsdn, &extents_rtree, rtree_ctx,
161  	    (uintptr_t)ptr, false, &extent, &szind)) {
162  		return 0;
163  	}
164  	if (extent == NULL) {
165  		return 0;
166  	}
167  	assert(extent_state_get(extent) == extent_state_active);
168  	assert(extent_addr_get(extent) == ptr || extent_slab_get(extent));
169  	assert(szind != SC_NSIZES);
170  	return sz_index2size(szind);
171  }
172  static inline void
173  arena_dalloc_large_no_tcache(tsdn_t *tsdn, void *ptr, szind_t szind) {
174  	if (config_prof && unlikely(szind < SC_NBINS)) {
175  		arena_dalloc_promoted(tsdn, ptr, NULL, true);
176  	} else {
177  		extent_t *extent = iealloc(tsdn, ptr);
178  		large_dalloc(tsdn, extent);
179  	}
180  }
181  static inline void
182  arena_dalloc_no_tcache(tsdn_t *tsdn, void *ptr) {
183  	assert(ptr != NULL);
184  	rtree_ctx_t rtree_ctx_fallback;
185  	rtree_ctx_t *rtree_ctx = tsdn_rtree_ctx(tsdn, &rtree_ctx_fallback);
186  	szind_t szind;
187  	bool slab;
188  	rtree_szind_slab_read(tsdn, &extents_rtree, rtree_ctx, (uintptr_t)ptr,
189  	    true, &szind, &slab);
190  	if (config_debug) {
191  		extent_t *extent = rtree_extent_read(tsdn, &extents_rtree,
192  		    rtree_ctx, (uintptr_t)ptr, true);
193  		assert(szind == extent_szind_get(extent));
194  		assert(szind < SC_NSIZES);
195  		assert(slab == extent_slab_get(extent));
196  	}
197  	if (likely(slab)) {
198  		arena_dalloc_small(tsdn, ptr);
199  	} else {
200  		arena_dalloc_large_no_tcache(tsdn, ptr, szind);
201  	}
202  }
203  JEMALLOC_ALWAYS_INLINE void
204  arena_dalloc_large(tsdn_t *tsdn, void *ptr, tcache_t *tcache, szind_t szind,
205      bool slow_path) {
206  	if (szind < nhbins) {
207  		if (config_prof && unlikely(szind < SC_NBINS)) {
208  			arena_dalloc_promoted(tsdn, ptr, tcache, slow_path);
209  		} else {
210  			tcache_dalloc_large(tsdn_tsd(tsdn), tcache, ptr, szind,
211  			    slow_path);
212  		}
213  	} else {
214  		extent_t *extent = iealloc(tsdn, ptr);
215  		large_dalloc(tsdn, extent);
216  	}
217  }
218  JEMALLOC_ALWAYS_INLINE void
219  arena_dalloc(tsdn_t *tsdn, void *ptr, tcache_t *tcache,
220      alloc_ctx_t *alloc_ctx, bool slow_path) {
221  	assert(!tsdn_null(tsdn) || tcache == NULL);
222  	assert(ptr != NULL);
223  	if (unlikely(tcache == NULL)) {
224  		arena_dalloc_no_tcache(tsdn, ptr);
225  		return;
226  	}
227  	szind_t szind;
228  	bool slab;
229  	rtree_ctx_t *rtree_ctx;
230  	if (alloc_ctx != NULL) {
231  		szind = alloc_ctx->szind;
232  		slab = alloc_ctx->slab;
233  		assert(szind != SC_NSIZES);
234  	} else {
235  		rtree_ctx = tsd_rtree_ctx(tsdn_tsd(tsdn));
236  		rtree_szind_slab_read(tsdn, &extents_rtree, rtree_ctx,
237  		    (uintptr_t)ptr, true, &szind, &slab);
238  	}
239  	if (config_debug) {
240  		rtree_ctx = tsd_rtree_ctx(tsdn_tsd(tsdn));
241  		extent_t *extent = rtree_extent_read(tsdn, &extents_rtree,
242  		    rtree_ctx, (uintptr_t)ptr, true);
243  		assert(szind == extent_szind_get(extent));
244  		assert(szind < SC_NSIZES);
245  		assert(slab == extent_slab_get(extent));
246  	}
247  	if (likely(slab)) {
248  		tcache_dalloc_small(tsdn_tsd(tsdn), tcache, ptr, szind,
249  		    slow_path);
250  	} else {
251  		arena_dalloc_large(tsdn, ptr, tcache, szind, slow_path);
252  	}
253  }
254  static inline void
255  arena_sdalloc_no_tcache(tsdn_t *tsdn, void *ptr, size_t size) {
256  	assert(ptr != NULL);
257  	assert(size <= SC_LARGE_MAXCLASS);
258  	szind_t szind;
259  	bool slab;
260  	if (!config_prof || !opt_prof) {
261  		szind = sz_size2index(size);
262  		slab = (szind < SC_NBINS);
263  	}
264  	if ((config_prof && opt_prof) || config_debug) {
265  		rtree_ctx_t rtree_ctx_fallback;
266  		rtree_ctx_t *rtree_ctx = tsdn_rtree_ctx(tsdn,
267  		    &rtree_ctx_fallback);
268  		rtree_szind_slab_read(tsdn, &extents_rtree, rtree_ctx,
269  		    (uintptr_t)ptr, true, &szind, &slab);
270  		assert(szind == sz_size2index(size));
271  		assert((config_prof && opt_prof) || slab == (szind < SC_NBINS));
272  		if (config_debug) {
273  			extent_t *extent = rtree_extent_read(tsdn,
274  			    &extents_rtree, rtree_ctx, (uintptr_t)ptr, true);
275  			assert(szind == extent_szind_get(extent));
276  			assert(slab == extent_slab_get(extent));
277  		}
278  	}
279  	if (likely(slab)) {
280  		arena_dalloc_small(tsdn, ptr);
281  	} else {
282  		arena_dalloc_large_no_tcache(tsdn, ptr, szind);
283  	}
284  }
285  JEMALLOC_ALWAYS_INLINE void
286  arena_sdalloc(tsdn_t *tsdn, void *ptr, size_t size, tcache_t *tcache,
287      alloc_ctx_t *alloc_ctx, bool slow_path) {
288  	assert(!tsdn_null(tsdn) || tcache == NULL);
289  	assert(ptr != NULL);
290  	assert(size <= SC_LARGE_MAXCLASS);
291  	if (unlikely(tcache == NULL)) {
292  		arena_sdalloc_no_tcache(tsdn, ptr, size);
293  		return;
294  	}
295  	szind_t szind;
296  	bool slab;
297  	alloc_ctx_t local_ctx;
298  	if (config_prof && opt_prof) {
299  		if (alloc_ctx == NULL) {
300  			rtree_ctx_t rtree_ctx_fallback;
301  			rtree_ctx_t *rtree_ctx = tsdn_rtree_ctx(tsdn,
302  			    &rtree_ctx_fallback);
303  			rtree_szind_slab_read(tsdn, &extents_rtree, rtree_ctx,
304  			    (uintptr_t)ptr, true, &local_ctx.szind,
305  			    &local_ctx.slab);
306  			assert(local_ctx.szind == sz_size2index(size));
307  			alloc_ctx = &local_ctx;
308  		}
309  		slab = alloc_ctx->slab;
310  		szind = alloc_ctx->szind;
311  	} else {
312  		szind = sz_size2index(size);
313  		slab = (szind < SC_NBINS);
314  	}
315  	if (config_debug) {
316  		rtree_ctx_t *rtree_ctx = tsd_rtree_ctx(tsdn_tsd(tsdn));
317  		rtree_szind_slab_read(tsdn, &extents_rtree, rtree_ctx,
318  		    (uintptr_t)ptr, true, &szind, &slab);
319  		extent_t *extent = rtree_extent_read(tsdn,
320  		    &extents_rtree, rtree_ctx, (uintptr_t)ptr, true);
321  		assert(szind == extent_szind_get(extent));
322  		assert(slab == extent_slab_get(extent));
323  	}
324  	if (likely(slab)) {
325  		tcache_dalloc_small(tsdn_tsd(tsdn), tcache, ptr, szind,
326  		    slow_path);
327  	} else {
328  		arena_dalloc_large(tsdn, ptr, tcache, szind, slow_path);
329  	}
330  }
331  #endif &bsol;* JEMALLOC_INTERNAL_ARENA_INLINES_B_H */
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from Adafruit_nRF52_Arduino-MDEwOlJlcG9zaXRvcnk3NDM1NDcyOQ==-flat-crypto.c</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from redis-MDEwOlJlcG9zaXRvcnkxMDgxMTA3MDY=-flat-arena_inlines_b.h</div>
                </div>
                <div class="column column_space"><pre><code>107    }
108  }
109  uint8_t crypto_verifyAndDecrypt(const uint8_t* key, uint8_t* nonce, uint8_t* encrypted, uint8_t length, uint8_t* output_buf, uint8_t* mac)
110  {
111    uint8_t polykey[sizeof(zeros64)];
</pre></code></div>
                <div class="column column_space"><pre><code>121  	}
122  }
123  JEMALLOC_ALWAYS_INLINE void *
124  arena_malloc(tsdn_t *tsdn, arena_t *arena, size_t size, szind_t ind, bool zero,
125      tcache_t *tcache, bool slow_path) {
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    