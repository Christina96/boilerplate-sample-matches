
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 14.991482112436117%, Tokens: 10, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>PINRemoteImage-MDEwOlJlcG9zaXRvcnkzOTUzNzEwMw==-flat-picture_rescale_enc.c</h3>
            <pre><code>1  #include "src/webp/encode.h"
2  #if !defined(WEBP_REDUCE_SIZE)
3  #include <assert.h>
4  #include <stdlib.h>
5  #include "src/enc/vp8i_enc.h"
6  #include "src/utils/rescaler_utils.h"
7  #include "src/utils/utils.h"
8  #define HALVE(x) (((x) + 1) >> 1)
9  static void PictureGrabSpecs(const WebPPicture* const src,
10                               WebPPicture* const dst) {
11    assert(src != NULL && dst != NULL);
12    *dst = *src;
13    WebPPictureResetBuffers(dst);
14  }
15  static void SnapTopLeftPosition(const WebPPicture* const pic,
16                                  int* const left, int* const top) {
17    if (!pic->use_argb) {
18      *left &= ~1;
19      *top &= ~1;
20    }
21  }
22  static int AdjustAndCheckRectangle(const WebPPicture* const pic,
23                                     int* const left, int* const top,
24                                     int width, int height) {
25    SnapTopLeftPosition(pic, left, top);
26    if ((*left) < 0 || (*top) < 0) return 0;
27    if (width <= 0 || height <= 0) return 0;
28    if ((*left) + width > pic->width) return 0;
29    if ((*top) + height > pic->height) return 0;
30    return 1;
31  }
32  int WebPPictureCopy(const WebPPicture* src, WebPPicture* dst) {
33    if (src == NULL || dst == NULL) return 0;
34    if (src == dst) return 1;
35    PictureGrabSpecs(src, dst);
36    if (!WebPPictureAlloc(dst)) return 0;
37    if (!src->use_argb) {
38      WebPCopyPlane(src->y, src->y_stride,
39                    dst->y, dst->y_stride, dst->width, dst->height);
40      WebPCopyPlane(src->u, src->uv_stride, dst->u, dst->uv_stride,
41                    HALVE(dst->width), HALVE(dst->height));
42      WebPCopyPlane(src->v, src->uv_stride, dst->v, dst->uv_stride,
43                    HALVE(dst->width), HALVE(dst->height));
44      if (dst->a != NULL)  {
45        WebPCopyPlane(src->a, src->a_stride,
46                      dst->a, dst->a_stride, dst->width, dst->height);
47      }
48    } else {
49      WebPCopyPlane((const uint8_t*)src->argb, 4 * src->argb_stride,
50                    (uint8_t*)dst->argb, 4 * dst->argb_stride,
51                    4 * dst->width, dst->height);
52    }
53    return 1;
54  }
55  int WebPPictureIsView(const WebPPicture* picture) {
56    if (picture == NULL) return 0;
57    if (picture->use_argb) {
<span onclick='openModal()' class='match'>58      return (picture->memory_argb_ == NULL);
59    }
60    return (picture->memory_ == NULL);
61  }
62  int WebPPictureView(const WebPPicture* src,
63                      int left, int top, int width, int height,
</span>64                      WebPPicture* dst) {
65    if (src == NULL || dst == NULL) return 0;
66    if (!AdjustAndCheckRectangle(src, &left, &top, width, height)) return 0;
67    if (src != dst) {  
68      PictureGrabSpecs(src, dst);
69    }
70    dst->width = width;
71    dst->height = height;
72    if (!src->use_argb) {
73      dst->y = src->y + top * src->y_stride + left;
74      dst->u = src->u + (top >> 1) * src->uv_stride + (left >> 1);
75      dst->v = src->v + (top >> 1) * src->uv_stride + (left >> 1);
76      dst->y_stride = src->y_stride;
77      dst->uv_stride = src->uv_stride;
78      if (src->a != NULL) {
79        dst->a = src->a + top * src->a_stride + left;
80        dst->a_stride = src->a_stride;
81      }
82    } else {
83      dst->argb = src->argb + top * src->argb_stride + left;
84      dst->argb_stride = src->argb_stride;
85    }
86    return 1;
87  }
88  int WebPPictureCrop(WebPPicture* pic,
89                      int left, int top, int width, int height) {
90    WebPPicture tmp;
91    if (pic == NULL) return 0;
92    if (!AdjustAndCheckRectangle(pic, &left, &top, width, height)) return 0;
93    PictureGrabSpecs(pic, &tmp);
94    tmp.width = width;
95    tmp.height = height;
96    if (!WebPPictureAlloc(&tmp)) return 0;
97    if (!pic->use_argb) {
98      const int y_offset = top * pic->y_stride + left;
99      const int uv_offset = (top / 2) * pic->uv_stride + left / 2;
100      WebPCopyPlane(pic->y + y_offset, pic->y_stride,
101                    tmp.y, tmp.y_stride, width, height);
102      WebPCopyPlane(pic->u + uv_offset, pic->uv_stride,
103                    tmp.u, tmp.uv_stride, HALVE(width), HALVE(height));
104      WebPCopyPlane(pic->v + uv_offset, pic->uv_stride,
105                    tmp.v, tmp.uv_stride, HALVE(width), HALVE(height));
106      if (tmp.a != NULL) {
107        const int a_offset = top * pic->a_stride + left;
108        WebPCopyPlane(pic->a + a_offset, pic->a_stride,
109                      tmp.a, tmp.a_stride, width, height);
110      }
111    } else {
112      const uint8_t* const src =
113          (const uint8_t*)(pic->argb + top * pic->argb_stride + left);
114      WebPCopyPlane(src, pic->argb_stride * 4, (uint8_t*)tmp.argb,
115                    tmp.argb_stride * 4, width * 4, height);
116    }
117    WebPPictureFree(pic);
118    *pic = tmp;
119    return 1;
120  }
121  static void RescalePlane(const uint8_t* src,
122                           int src_width, int src_height, int src_stride,
123                           uint8_t* dst,
124                           int dst_width, int dst_height, int dst_stride,
125                           rescaler_t* const work,
126                           int num_channels) {
127    WebPRescaler rescaler;
128    int y = 0;
129    WebPRescalerInit(&rescaler, src_width, src_height,
130                     dst, dst_width, dst_height, dst_stride,
131                     num_channels, work);
132    while (y < src_height) {
133      y += WebPRescalerImport(&rescaler, src_height - y,
134                              src + y * src_stride, src_stride);
135      WebPRescalerExport(&rescaler);
136    }
137  }
138  static void AlphaMultiplyARGB(WebPPicture* const pic, int inverse) {
139    assert(pic->argb != NULL);
140    WebPMultARGBRows((uint8_t*)pic->argb, pic->argb_stride * sizeof(*pic->argb),
141                     pic->width, pic->height, inverse);
142  }
143  static void AlphaMultiplyY(WebPPicture* const pic, int inverse) {
144    if (pic->a != NULL) {
145      WebPMultRows(pic->y, pic->y_stride, pic->a, pic->a_stride,
146                   pic->width, pic->height, inverse);
147    }
148  }
149  int WebPPictureRescale(WebPPicture* pic, int width, int height) {
150    WebPPicture tmp;
151    int prev_width, prev_height;
152    rescaler_t* work;
153    if (pic == NULL) return 0;
154    prev_width = pic->width;
155    prev_height = pic->height;
156    if (!WebPRescalerGetScaledDimensions(
157            prev_width, prev_height, &width, &height)) {
158      return 0;
159    }
160    PictureGrabSpecs(pic, &tmp);
161    tmp.width = width;
162    tmp.height = height;
163    if (!WebPPictureAlloc(&tmp)) return 0;
164    if (!pic->use_argb) {
165      work = (rescaler_t*)WebPSafeMalloc(2ULL * width, sizeof(*work));
166      if (work == NULL) {
167        WebPPictureFree(&tmp);
168        return 0;
169      }
170      if (pic->a != NULL) {
171        WebPInitAlphaProcessing();
172        RescalePlane(pic->a, prev_width, prev_height, pic->a_stride,
173                     tmp.a, width, height, tmp.a_stride, work, 1);
174      }
175      AlphaMultiplyY(pic, 0);
176      RescalePlane(pic->y, prev_width, prev_height, pic->y_stride,
177                   tmp.y, width, height, tmp.y_stride, work, 1);
178      AlphaMultiplyY(&tmp, 1);
179      RescalePlane(pic->u,
180                   HALVE(prev_width), HALVE(prev_height), pic->uv_stride,
181                   tmp.u,
182                   HALVE(width), HALVE(height), tmp.uv_stride, work, 1);
183      RescalePlane(pic->v,
184                   HALVE(prev_width), HALVE(prev_height), pic->uv_stride,
185                   tmp.v,
186                   HALVE(width), HALVE(height), tmp.uv_stride, work, 1);
187    } else {
188      work = (rescaler_t*)WebPSafeMalloc(2ULL * width * 4, sizeof(*work));
189      if (work == NULL) {
190        WebPPictureFree(&tmp);
191        return 0;
192      }
193      WebPInitAlphaProcessing();
194      AlphaMultiplyARGB(pic, 0);
195      RescalePlane((const uint8_t*)pic->argb, prev_width, prev_height,
196                   pic->argb_stride * 4,
197                   (uint8_t*)tmp.argb, width, height,
198                   tmp.argb_stride * 4,
199                   work, 4);
200      AlphaMultiplyARGB(&tmp, 1);
201    }
202    WebPPictureFree(pic);
203    WebPSafeFree(work);
204    *pic = tmp;
205    return 1;
206  }
207  #else  
208  int WebPPictureCopy(const WebPPicture* src, WebPPicture* dst) {
209    (void)src;
210    (void)dst;
211    return 0;
212  }
213  int WebPPictureIsView(const WebPPicture* picture) {
214    (void)picture;
215    return 0;
216  }
217  int WebPPictureView(const WebPPicture* src,
218                      int left, int top, int width, int height,
219                      WebPPicture* dst) {
220    (void)src;
221    (void)left;
222    (void)top;
223    (void)width;
224    (void)height;
225    (void)dst;
226    return 0;
227  }
228  int WebPPictureCrop(WebPPicture* pic,
229                      int left, int top, int width, int height) {
230    (void)pic;
231    (void)left;
232    (void)top;
233    (void)width;
234    (void)height;
235    return 0;
236  }
237  int WebPPictureRescale(WebPPicture* pic, int width, int height) {
238    (void)pic;
239    (void)width;
240    (void)height;
241    return 0;
242  }
243  #endif  
</code></pre>
        </div>
        <div class="column">
            <h3>redis-MDEwOlJlcG9zaXRvcnkxMDgxMTA3MDY=-flat-rio.c</h3>
            <pre><code>1  #ifdef _WIN32
2  #include "Win32_Interop/Win32_Portability.h"
3  #include "win32_interop/win32_types.h"
4  #include "Win32_Interop/Win32_FDAPI.h"
5  #endif
6  #include "fmacros.h"
7  #include <string.h>
8  #include <stdio.h>
9  POSIX_ONLY(#include <unistd.h>)
10  #include "rio.h"
11  #include "util.h"
12  #include "crc64.h"
13  #include "config.h"
14  #include "server.h"
15  static size_t rioBufferWrite(rio *r, const void *buf, size_t len) {
16      r->io.buffer.ptr = sdscatlen(r->io.buffer.ptr,(char*)buf,len);
17      r->io.buffer.pos += (off_t)len;                                             WIN_PORT_FIX &bsol;* cast (off_t) */
18      return 1;
19  }
20  static size_t rioBufferRead(rio *r, void *buf, size_t len) {
21      if (sdslen(r->io.buffer.ptr)-r->io.buffer.pos < len)
22          return 0; &bsol;* not enough buffer to return len bytes. */
23      memcpy(buf,r->io.buffer.ptr+r->io.buffer.pos,len);
24      r->io.buffer.pos += (off_t)len;                                             WIN_PORT_FIX &bsol;* cast (off_t) */
25      return 1;
26  }
27  static off_t rioBufferTell(rio *r) {
28      return r->io.buffer.pos;
29  }
30  static int rioBufferFlush(rio *r) {
31      UNUSED(r);
32      return 1; &bsol;* Nothing to do, our write just appends to the buffer. */
33  }
34  static const rio rioBufferIO = {
35      rioBufferRead,
36      rioBufferWrite,
37      rioBufferTell,
38      rioBufferFlush,
39      NULL,           &bsol;* update_checksum */
40      0,              &bsol;* current checksum */
41      0,              &bsol;* bytes read or written */
42      0,              &bsol;* read/write chunk size */
43      { { NULL, 0 } } &bsol;* union for io-specific vars */
44  };
45  void rioInitWithBuffer(rio *r, sds s) {
46      *r = rioBufferIO;
47      r->io.buffer.ptr = s;
48      r->io.buffer.pos = 0;
49  }
50  static size_t rioFileWrite(rio *r, const void *buf, size_t len) {
51      size_t retval;
52      retval = fwrite(buf,len,1,r->io.file.fp);
53      r->io.file.buffered += (off_t)len;                                          WIN_PORT_FIX &bsol;* cast (off_t) */
54      if (r->io.file.autosync &&
55          r->io.file.buffered >= r->io.file.autosync)
56      {
57          fflush(r->io.file.fp);
58          redis_fsync(fileno(r->io.file.fp));
59          r->io.file.buffered = 0;
60      }
61      return retval;
62  }
63  static size_t rioFileRead(rio *r, void *buf, size_t len) {
64      return fread(buf,len,1,r->io.file.fp);
65  }
66  static off_t rioFileTell(rio *r) {
67      return (off_t)ftello(r->io.file.fp);                                        WIN_PORT_FIX &bsol;* cast (int) */
68  }
69  static int rioFileFlush(rio *r) {
70      return (fflush(r->io.file.fp) == 0) ? 1 : 0;
71  }
72  static const rio rioFileIO = {
73      rioFileRead,
74      rioFileWrite,
75      rioFileTell,
76      rioFileFlush,
77      NULL,           &bsol;* update_checksum */
78      0,              &bsol;* current checksum */
79      0,              &bsol;* bytes read or written */
80      0,              &bsol;* read/write chunk size */
81      { { NULL, 0 } } &bsol;* union for io-specific vars */
82  };
83  void rioInitWithFile(rio *r, FILE *fp) {
84      *r = rioFileIO;
85      r->io.file.fp = fp;
86      r->io.file.buffered = 0;
87      r->io.file.autosync = 0;
88  }
89  static size_t rioFdsetWrite(rio *r, const void *buf, size_t len) {
90      ssize_t retval;
91      int j;
92      unsigned char *p = (unsigned char*) buf;
93      int doflush = (buf == NULL && len == 0);
94      if (len) {
95          r->io.fdset.buf = sdscatlen(r->io.fdset.buf,buf,len);
96          len = 0; &bsol;* Prevent entering the while below if we don't flush. */
97          if (sdslen(r->io.fdset.buf) > PROTO_IOBUF_LEN) doflush = 1;
98      }
99      if (doflush) {
100          p = (unsigned char*) r->io.fdset.buf;
101          len = sdslen(r->io.fdset.buf);
102      }
103      while(len) {
104          size_t count = len < 1024 ? len : 1024;
105          int broken = 0;
106          for (j = 0; j < r->io.fdset.numfds; j++) {
107              if (r->io.fdset.state[j] != 0) {
108                  broken++;
109                  continue;
110              }
111              size_t nwritten = 0;
112              while(nwritten != count) {
113                  retval = write(r->io.fdset.fds[j],p+nwritten,count-nwritten);
114                  if (retval <= 0) {
115                      if (retval == -1 && errno == EWOULDBLOCK) errno = ETIMEDOUT;
116                      break;
117                  }
118                  nwritten += retval;
119              }
120              if (nwritten != count) {
121                  r->io.fdset.state[j] = errno;
122                  if (r->io.fdset.state[j] == 0) r->io.fdset.state[j] = EIO;
123              }
124          }
125          if (broken == r->io.fdset.numfds) return 0; &bsol;* All the FDs in error. */
126          p += count;
127          len -= count;
128          r->io.fdset.pos += count;
129      }
130      if (doflush) sdsclear(r->io.fdset.buf);
131      return 1;
132  }
133  static size_t rioFdsetRead(rio *r, void *buf, size_t len) {
134      UNUSED(r);
135      UNUSED(buf);
136      UNUSED(len);
137      return 0; &bsol;* Error, this target does not support reading. */
138  }
139  static off_t rioFdsetTell(rio *r) {
140      return r->io.fdset.pos;
141  }
142  static int rioFdsetFlush(rio *r) {
143      return (int)rioFdsetWrite(r,NULL,0);                                        WIN_PORT_FIX &bsol;* cast (int) */
144  }
145  static const rio rioFdsetIO = {
146      rioFdsetRead,
147      rioFdsetWrite,
148      rioFdsetTell,
149      rioFdsetFlush,
150      NULL,           &bsol;* update_checksum */
151      0,              &bsol;* current checksum */
152      0,              &bsol;* bytes read or written */
153      0,              &bsol;* read/write chunk size */
154      { { NULL, 0 } } &bsol;* union for io-specific vars */
155  };
156  void rioInitWithFdset(rio *r, int *fds, int numfds) {
157      int j;
158      *r = rioFdsetIO;
159      r->io.fdset.fds = zmalloc(sizeof(int)*numfds);
160      r->io.fdset.state = zmalloc(sizeof(int)*numfds);
161      memcpy(r->io.fdset.fds,fds,sizeof(int)*numfds);
162      for (j = 0; j < numfds; j++) r->io.fdset.state[j] = 0;
163      r->io.fdset.numfds = numfds;
164      r->io.fdset.pos = 0;
165      r->io.fdset.buf = sdsempty();
166  }
167  void rioFreeFdset(rio *r) {
168      zfree(r->io.fdset.fds);
169      zfree(r->io.fdset.state);
170      sdsfree(r->io.fdset.buf);
171  }
172  void rioGenericUpdateChecksum(rio *r, const void *buf, size_t len) {
173      r->cksum = crc64(r->cksum,buf,len);
174  }
175  void rioSetAutoSync(rio *r, off_t bytes) {
176      serverAssert(r->read == rioFileIO.read);
177      r->io.file.autosync = bytes;
178  }
179  size_t rioWriteBulkCount(rio *r, char prefix, PORT_LONG count) {
180      char cbuf[128];
181      int clen;
182      cbuf[0] = prefix;
183      clen = 1+ll2string(cbuf+1,sizeof(cbuf)-1,count);
184      cbuf[clen++] = '\r';
185      cbuf[clen++] = '\n';
186      if (rioWrite(r,cbuf,clen) == 0) return 0;
187      return clen;
188  }
189  size_t rioWriteBulkString(rio *r, const char *buf, size_t len) {
190      size_t nwritten;
191      if ((nwritten = rioWriteBulkCount(r,'$',(PORT_LONG)len)) == 0) return 0;          WIN_PORT_FIX &bsol;* cast (PORT_LONG) */
192      if (len > 0 && rioWrite(r,buf,len) == 0) return 0;
<span onclick='openModal()' class='match'>193      if (rioWrite(r,"\r\n",2) == 0) return 0;
194      return nwritten+len+2;
195  }
196  size_t rioWriteBulkLongLong(rio *r, PORT_LONGLONG l) {
197      char lbuf[32];
198      unsigned int llen;
</span>199      llen = ll2string(lbuf,sizeof(lbuf),l);
200      return rioWriteBulkString(r,lbuf,llen);
201  }
202  size_t rioWriteBulkDouble(rio *r, double d) {
203      char dbuf[128];
204      unsigned int dlen;
205      dlen = snprintf(dbuf,sizeof(dbuf),"%.17g",d);
206      return rioWriteBulkString(r,dbuf,dlen);
207  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from PINRemoteImage-MDEwOlJlcG9zaXRvcnkzOTUzNzEwMw==-flat-picture_rescale_enc.c</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from redis-MDEwOlJlcG9zaXRvcnkxMDgxMTA3MDY=-flat-rio.c</div>
                </div>
                <div class="column column_space"><pre><code>58      return (picture->memory_argb_ == NULL);
59    }
60    return (picture->memory_ == NULL);
61  }
62  int WebPPictureView(const WebPPicture* src,
63                      int left, int top, int width, int height,
</pre></code></div>
                <div class="column column_space"><pre><code>193      if (rioWrite(r,"\r\n",2) == 0) return 0;
194      return nwritten+len+2;
195  }
196  size_t rioWriteBulkLongLong(rio *r, PORT_LONGLONG l) {
197      char lbuf[32];
198      unsigned int llen;
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    