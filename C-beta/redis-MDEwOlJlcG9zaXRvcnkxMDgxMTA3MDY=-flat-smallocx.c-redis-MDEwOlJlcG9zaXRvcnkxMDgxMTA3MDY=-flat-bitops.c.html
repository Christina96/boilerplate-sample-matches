
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 2.4759284731774414%, Tokens: 9, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>redis-MDEwOlJlcG9zaXRvcnkxMDgxMTA3MDY=-flat-smallocx.c</h3>
            <pre><code>1  #include "test/jemalloc_test.h"
2  #include "jemalloc/jemalloc_macros.h"
3  #define STR_HELPER(x) #x
4  #define STR(x) STR_HELPER(x)
5  #ifndef JEMALLOC_VERSION_GID_IDENT
6    #error "JEMALLOC_VERSION_GID_IDENT not defined"
7  #endif
8  #define JOIN(x, y) x ## y
9  #define JOIN2(x, y) JOIN(x, y)
10  #define smallocx JOIN2(smallocx_, JEMALLOC_VERSION_GID_IDENT)
11  typedef struct {
12  	void *ptr;
13  	size_t size;
14  } smallocx_return_t;
15  extern smallocx_return_t
16  smallocx(size_t size, int flags);
17  static unsigned
18  get_nsizes_impl(const char *cmd) {
19  	unsigned ret;
20  	size_t z;
21  	z = sizeof(unsigned);
22  	assert_d_eq(mallctl(cmd, (void *)&ret, &z, NULL, 0), 0,
23  	    "Unexpected mallctl(\"%s\", ...) failure", cmd);
24  	return ret;
25  }
26  static unsigned
27  get_nlarge(void) {
28  	return get_nsizes_impl("arenas.nlextents");
<span onclick='openModal()' class='match'>29  }
30  static size_t
31  get_size_impl(const char *cmd, size_t ind) {
32  	size_t ret;
33  	size_t z;
34  	size_t mib[4];
35  	size_t miblen = 4;
</span>36  	z = sizeof(size_t);
37  	assert_d_eq(mallctlnametomib(cmd, mib, &miblen),
38  	    0, "Unexpected mallctlnametomib(\"%s\", ...) failure", cmd);
39  	mib[2] = ind;
40  	z = sizeof(size_t);
41  	assert_d_eq(mallctlbymib(mib, miblen, (void *)&ret, &z, NULL, 0),
42  	    0, "Unexpected mallctlbymib([\"%s\", %zu], ...) failure", cmd, ind);
43  	return ret;
44  }
45  static size_t
46  get_large_size(size_t ind) {
47  	return get_size_impl("arenas.lextent.0.size", ind);
48  }
49  static void
50  purge(void) {
51  	assert_d_eq(mallctl("arena.0.purge", NULL, NULL, NULL, 0), 0,
52  	    "Unexpected mallctl error");
53  }
54  JEMALLOC_DIAGNOSTIC_PUSH
55  JEMALLOC_DIAGNOSTIC_IGNORE_ALLOC_SIZE_LARGER_THAN
56  TEST_BEGIN(test_overflow) {
57  	size_t largemax;
58  	largemax = get_large_size(get_nlarge()-1);
59  	assert_ptr_null(smallocx(largemax+1, 0).ptr,
60  	    "Expected OOM for smallocx(size=%#zx, 0)", largemax+1);
61  	assert_ptr_null(smallocx(ZU(PTRDIFF_MAX)+1, 0).ptr,
62  	    "Expected OOM for smallocx(size=%#zx, 0)", ZU(PTRDIFF_MAX)+1);
63  	assert_ptr_null(smallocx(SIZE_T_MAX, 0).ptr,
64  	    "Expected OOM for smallocx(size=%#zx, 0)", SIZE_T_MAX);
65  	assert_ptr_null(smallocx(1, MALLOCX_ALIGN(ZU(PTRDIFF_MAX)+1)).ptr,
66  	    "Expected OOM for smallocx(size=1, MALLOCX_ALIGN(%#zx))",
67  	    ZU(PTRDIFF_MAX)+1);
68  }
69  TEST_END
70  static void *
71  remote_alloc(void *arg) {
72  	unsigned arena;
73  	size_t sz = sizeof(unsigned);
74  	assert_d_eq(mallctl("arenas.create", (void *)&arena, &sz, NULL, 0), 0,
75  	    "Unexpected mallctl() failure");
76  	size_t large_sz;
77  	sz = sizeof(size_t);
78  	assert_d_eq(mallctl("arenas.lextent.0.size", (void *)&large_sz, &sz,
79  	    NULL, 0), 0, "Unexpected mallctl failure");
80  	smallocx_return_t r
81  	    = smallocx(large_sz, MALLOCX_ARENA(arena) | MALLOCX_TCACHE_NONE);
82  	void *ptr = r.ptr;
83  	assert_zu_eq(r.size,
84  	    nallocx(large_sz, MALLOCX_ARENA(arena) | MALLOCX_TCACHE_NONE),
85  	    "Expected smalloc(size,flags).size == nallocx(size,flags)");
86  	void **ret = (void **)arg;
87  	*ret = ptr;
88  	return NULL;
89  }
90  TEST_BEGIN(test_remote_free) {
91  	thd_t thd;
92  	void *ret;
93  	thd_create(&thd, remote_alloc, (void *)&ret);
94  	thd_join(thd, NULL);
95  	assert_ptr_not_null(ret, "Unexpected smallocx failure");
96  	dallocx(ret, 0);
97  	mallctl("thread.tcache.flush", NULL, NULL, NULL, 0);
98  }
99  TEST_END
100  TEST_BEGIN(test_oom) {
101  	size_t largemax;
102  	bool oom;
103  	void *ptrs[3];
104  	unsigned i;
105  	largemax = get_large_size(get_nlarge()-1);
106  	oom = false;
107  	for (i = 0; i < sizeof(ptrs) / sizeof(void *); i++) {
108  		ptrs[i] = smallocx(largemax, 0).ptr;
109  		if (ptrs[i] == NULL) {
110  			oom = true;
111  		}
112  	}
113  	assert_true(oom,
114  	    "Expected OOM during series of calls to smallocx(size=%zu, 0)",
115  	    largemax);
116  	for (i = 0; i < sizeof(ptrs) / sizeof(void *); i++) {
117  		if (ptrs[i] != NULL) {
118  			dallocx(ptrs[i], 0);
119  		}
120  	}
121  	purge();
122  #if LG_SIZEOF_PTR == 3
123  	assert_ptr_null(smallocx(0x8000000000000000ULL,
124  	    MALLOCX_ALIGN(0x8000000000000000ULL)).ptr,
125  	    "Expected OOM for smallocx()");
126  	assert_ptr_null(smallocx(0x8000000000000000ULL,
127  	    MALLOCX_ALIGN(0x80000000)).ptr,
128  	    "Expected OOM for smallocx()");
129  #else
130  	assert_ptr_null(smallocx(0x80000000UL, MALLOCX_ALIGN(0x80000000UL)).ptr,
131  	    "Expected OOM for smallocx()");
132  #endif
133  }
134  TEST_END
135  JEMALLOC_DIAGNOSTIC_POP
136  TEST_BEGIN(test_basic) {
137  #define MAXSZ (((size_t)1) << 23)
138  	size_t sz;
139  	for (sz = 1; sz < MAXSZ; sz = nallocx(sz, 0) + 1) {
140  		smallocx_return_t ret;
141  		size_t nsz, rsz, smz;
142  		void *p;
143  		nsz = nallocx(sz, 0);
144  		assert_zu_ne(nsz, 0, "Unexpected nallocx() error");
145  		ret = smallocx(sz, 0);
146  		p = ret.ptr;
147  		smz = ret.size;
148  		assert_ptr_not_null(p,
149  		    "Unexpected smallocx(size=%zx, flags=0) error", sz);
150  		rsz = sallocx(p, 0);
151  		assert_zu_ge(rsz, sz, "Real size smaller than expected");
152  		assert_zu_eq(nsz, rsz, "nallocx()/sallocx() size mismatch");
153  		assert_zu_eq(nsz, smz, "nallocx()/smallocx() size mismatch");
154  		dallocx(p, 0);
155  		ret = smallocx(sz, 0);
156  		p = ret.ptr;
157  		smz = ret.size;
158  		assert_ptr_not_null(p,
159  		    "Unexpected smallocx(size=%zx, flags=0) error", sz);
160  		dallocx(p, 0);
161  		nsz = nallocx(sz, MALLOCX_ZERO);
162  		assert_zu_ne(nsz, 0, "Unexpected nallocx() error");
163  		assert_zu_ne(smz, 0, "Unexpected smallocx() error");
164  		ret = smallocx(sz, MALLOCX_ZERO);
165  		p = ret.ptr;
166  		assert_ptr_not_null(p,
167  		    "Unexpected smallocx(size=%zx, flags=MALLOCX_ZERO) error",
168  		    nsz);
169  		rsz = sallocx(p, 0);
170  		assert_zu_eq(nsz, rsz, "nallocx()/sallocx() rsize mismatch");
171  		assert_zu_eq(nsz, smz, "nallocx()/smallocx() size mismatch");
172  		dallocx(p, 0);
173  		purge();
174  	}
175  #undef MAXSZ
176  }
177  TEST_END
178  TEST_BEGIN(test_alignment_and_size) {
179  	const char *percpu_arena;
180  	size_t sz = sizeof(percpu_arena);
181  	if(mallctl("opt.percpu_arena", (void *)&percpu_arena, &sz, NULL, 0) ||
182  	    strcmp(percpu_arena, "disabled") != 0) {
183  		test_skip("test_alignment_and_size skipped: "
184  		    "not working with percpu arena.");
185  	};
186  #define MAXALIGN (((size_t)1) << 23)
187  #define NITER 4
188  	size_t nsz, rsz, smz, alignment, total;
189  	unsigned i;
190  	void *ps[NITER];
191  	for (i = 0; i < NITER; i++) {
192  		ps[i] = NULL;
193  	}
194  	for (alignment = 8;
195  	    alignment <= MAXALIGN;
196  	    alignment <<= 1) {
197  		total = 0;
198  		for (sz = 1;
199  		    sz < 3 * alignment && sz < (1U << 31);
200  		    sz += (alignment >> (LG_SIZEOF_PTR-1)) - 1) {
201  			for (i = 0; i < NITER; i++) {
202  				nsz = nallocx(sz, MALLOCX_ALIGN(alignment) |
203  				    MALLOCX_ZERO);
204  				assert_zu_ne(nsz, 0,
205  				    "nallocx() error for alignment=%zu, "
206  				    "size=%zu (%#zx)", alignment, sz, sz);
207  				smallocx_return_t ret
208  				    = smallocx(sz, MALLOCX_ALIGN(alignment) | MALLOCX_ZERO);
209  				ps[i] = ret.ptr;
210  				assert_ptr_not_null(ps[i],
211  				    "smallocx() error for alignment=%zu, "
212  				    "size=%zu (%#zx)", alignment, sz, sz);
213  				rsz = sallocx(ps[i], 0);
214  				smz = ret.size;
215  				assert_zu_ge(rsz, sz,
216  				    "Real size smaller than expected for "
217  				    "alignment=%zu, size=%zu", alignment, sz);
218  				assert_zu_eq(nsz, rsz,
219  				    "nallocx()/sallocx() size mismatch for "
220  				    "alignment=%zu, size=%zu", alignment, sz);
221  				assert_zu_eq(nsz, smz,
222  				    "nallocx()/smallocx() size mismatch for "
223  				    "alignment=%zu, size=%zu", alignment, sz);
224  				assert_ptr_null(
225  				    (void *)((uintptr_t)ps[i] & (alignment-1)),
226  				    "%p inadequately aligned for"
227  				    " alignment=%zu, size=%zu", ps[i],
228  				    alignment, sz);
229  				total += rsz;
230  				if (total >= (MAXALIGN << 1)) {
231  					break;
232  				}
233  			}
234  			for (i = 0; i < NITER; i++) {
235  				if (ps[i] != NULL) {
236  					dallocx(ps[i], 0);
237  					ps[i] = NULL;
238  				}
239  			}
240  		}
241  		purge();
242  	}
243  #undef MAXALIGN
244  #undef NITER
245  }
246  TEST_END
247  int
248  main(void) {
249  	return test(
250  	    test_overflow,
251  	    test_oom,
252  	    test_remote_free,
253  	    test_basic,
254  	    test_alignment_and_size);
255  }
</code></pre>
        </div>
        <div class="column">
            <h3>redis-MDEwOlJlcG9zaXRvcnkxMDgxMTA3MDY=-flat-bitops.c</h3>
            <pre><code>1  #include "server.h"
2  size_t redisPopcount(void *s, PORT_LONG count) {
3      size_t bits = 0;
4      unsigned char *p = s;
5      uint32_t *p4;
6      static const unsigned char bitsinbyte[256] = {0,1,1,2,1,2,2,3,1,2,2,3,2,3,3,4,1,2,2,3,2,3,3,4,2,3,3,4,3,4,4,5,1,2,2,3,2,3,3,4,2,3,3,4,3,4,4,5,2,3,3,4,3,4,4,5,3,4,4,5,4,5,5,6,1,2,2,3,2,3,3,4,2,3,3,4,3,4,4,5,2,3,3,4,3,4,4,5,3,4,4,5,4,5,5,6,2,3,3,4,3,4,4,5,3,4,4,5,4,5,5,6,3,4,4,5,4,5,5,6,4,5,5,6,5,6,6,7,1,2,2,3,2,3,3,4,2,3,3,4,3,4,4,5,2,3,3,4,3,4,4,5,3,4,4,5,4,5,5,6,2,3,3,4,3,4,4,5,3,4,4,5,4,5,5,6,3,4,4,5,4,5,5,6,4,5,5,6,5,6,6,7,2,3,3,4,3,4,4,5,3,4,4,5,4,5,5,6,3,4,4,5,4,5,5,6,4,5,5,6,5,6,6,7,3,4,4,5,4,5,5,6,4,5,5,6,5,6,6,7,4,5,5,6,5,6,6,7,5,6,6,7,6,7,7,8};
7      while((PORT_ULONG)p & 3 && count) {
8          bits += bitsinbyte[*p++];
9          count--;
10      }
11      p4 = (uint32_t*)p;
12      while(count>=28) {
13          uint32_t aux1, aux2, aux3, aux4, aux5, aux6, aux7;
14          aux1 = *p4++;
15          aux2 = *p4++;
16          aux3 = *p4++;
17          aux4 = *p4++;
18          aux5 = *p4++;
19          aux6 = *p4++;
20          aux7 = *p4++;
21          count -= 28;
22          aux1 = aux1 - ((aux1 >> 1) & 0x55555555);
23          aux1 = (aux1 & 0x33333333) + ((aux1 >> 2) & 0x33333333);
24          aux2 = aux2 - ((aux2 >> 1) & 0x55555555);
25          aux2 = (aux2 & 0x33333333) + ((aux2 >> 2) & 0x33333333);
26          aux3 = aux3 - ((aux3 >> 1) & 0x55555555);
27          aux3 = (aux3 & 0x33333333) + ((aux3 >> 2) & 0x33333333);
28          aux4 = aux4 - ((aux4 >> 1) & 0x55555555);
29          aux4 = (aux4 & 0x33333333) + ((aux4 >> 2) & 0x33333333);
30          aux5 = aux5 - ((aux5 >> 1) & 0x55555555);
31          aux5 = (aux5 & 0x33333333) + ((aux5 >> 2) & 0x33333333);
32          aux6 = aux6 - ((aux6 >> 1) & 0x55555555);
33          aux6 = (aux6 & 0x33333333) + ((aux6 >> 2) & 0x33333333);
34          aux7 = aux7 - ((aux7 >> 1) & 0x55555555);
35          aux7 = (aux7 & 0x33333333) + ((aux7 >> 2) & 0x33333333);
36          bits += ((((aux1 + (aux1 >> 4)) & 0x0F0F0F0F) +
37                      ((aux2 + (aux2 >> 4)) & 0x0F0F0F0F) +
38                      ((aux3 + (aux3 >> 4)) & 0x0F0F0F0F) +
39                      ((aux4 + (aux4 >> 4)) & 0x0F0F0F0F) +
40                      ((aux5 + (aux5 >> 4)) & 0x0F0F0F0F) +
41                      ((aux6 + (aux6 >> 4)) & 0x0F0F0F0F) +
42                      ((aux7 + (aux7 >> 4)) & 0x0F0F0F0F))* 0x01010101) >> 24;
43      }
44      p = (unsigned char*)p4;
45      while(count--) bits += bitsinbyte[*p++];
46      return bits;
47  }
48  PORT_LONG redisBitpos(void *s, PORT_ULONG count, int bit) {
49      PORT_ULONG *l;
50      unsigned char *c;
51      PORT_ULONG skipval, word = 0, one;
52      PORT_LONG pos = 0; &bsol;* Position of bit, to return to the caller. */
53      PORT_ULONG j;
54      int found;
55      skipval = bit ? 0 : UCHAR_MAX;
56      c = (unsigned char*) s;
57      found = 0;
58      while((PORT_ULONG)c & (sizeof(*l)-1) && count) {
59          if (*c != skipval) {
60              found = 1;
61              break;
62          }
63          c++;
64          count--;
65          pos += 8;
66      }
67      l = (PORT_ULONG*) c;
68      if (!found) {
69          skipval = bit ? 0 : PORT_ULONG_MAX;
70          while (count >= sizeof(*l)) {
71              if (*l != skipval) break;
72              l++;
73              count -= sizeof(*l);
74              pos += sizeof(*l)*8;
75          }
76      }
77      c = (unsigned char*)l;
78      for (j = 0; j < sizeof(*l); j++) {
79          word <<= 8;
80          if (count) {
81              word |= *c;
82              c++;
83              count--;
84          }
85      }
86      if (bit == 1 && word == 0) return -1;
87      one = PORT_ULONG_MAX; &bsol;* All bits set to 1.*/
88      one >>= 1;       &bsol;* All bits set to 1 but the MSB. */
89      one = ~one;      &bsol;* All bits set to 0 but the MSB. */
90      while(one) {
91          if (((one & word) != 0) == bit) return pos;
92          pos++;
93          one >>= 1;
94      }
95      serverPanic("End of redisBitpos() reached.");
96      return 0; &bsol;* Just to avoid warnings. */
97  }
98  void setUnsignedBitfield(unsigned char *p, uint64_t offset, uint64_t bits, uint64_t value) {
99      uint64_t byte, bit, byteval, bitval, j;
100      for (j = 0; j < bits; j++) {
101          bitval = (value & ((uint64_t)1<<(bits-1-j))) != 0;
102          byte = offset >> 3;
103          bit = 7 - (offset & 0x7);
104          byteval = p[byte];
105          byteval &= ~(1 << bit);
106          byteval |= bitval << bit;
107          p[byte] = byteval & 0xff;
108          offset++;
109      }
110  }
111  void setSignedBitfield(unsigned char *p, uint64_t offset, uint64_t bits, int64_t value) {
112      uint64_t uv = value; &bsol;* Casting will add UINT64_MAX + 1 if v is negative. */
113      setUnsignedBitfield(p,offset,bits,uv);
114  }
115  uint64_t getUnsignedBitfield(unsigned char *p, uint64_t offset, uint64_t bits) {
116      uint64_t byte, bit, byteval, bitval, j, value = 0;
117      for (j = 0; j < bits; j++) {
118          byte = offset >> 3;
119          bit = 7 - (offset & 0x7);
120          byteval = p[byte];
121          bitval = (byteval >> bit) & 1;
122          value = (value<<1) | bitval;
123          offset++;
124      }
125      return value;
126  }
127  int64_t getSignedBitfield(unsigned char *p, uint64_t offset, uint64_t bits) {
128      int64_t value;
129      union {uint64_t u; int64_t i;} conv;
130      conv.u = getUnsignedBitfield(p,offset,bits);
131      value = conv.i;
132      if (value & ((uint64_t)1 << (bits-1)))
133          value |= ((uint64_t)-1) << bits;
134      return value;
<span onclick='openModal()' class='match'>135  }
136  #define BFOVERFLOW_WRAP 0
137  #define BFOVERFLOW_SAT 1
138  #define BFOVERFLOW_FAIL 2 &bsol;* Used by the BITFIELD command implementation. */
139  int checkUnsignedBitfieldOverflow(uint64_t value, int64_t incr, uint64_t bits, int owtype, uint64_t *limit) {
140      uint64_t max = (bits == 64) ? UINT64_MAX : (((uint64_t)1<<bits)-1);
</span>141      int64_t maxincr = max-value;
142      int64_t minincr = -value;
143      if (value > max || (incr > 0 && incr > maxincr)) {
144          if (limit) {
145              if (owtype == BFOVERFLOW_WRAP) {
146                  goto handle_wrap;
147              } else if (owtype == BFOVERFLOW_SAT) {
148                  *limit = max;
149              }
150          }
151          return 1;
152      } else if (incr < 0 && incr < minincr) {
153          if (limit) {
154              if (owtype == BFOVERFLOW_WRAP) {
155                  goto handle_wrap;
156              } else if (owtype == BFOVERFLOW_SAT) {
157                  *limit = 0;
158              }
159          }
160          return -1;
161      }
162      return 0;
163  handle_wrap:
164      {
165          uint64_t mask = ((uint64_t)-1) << bits;
166          uint64_t res = value+incr;
167          res &= ~mask;
168          *limit = res;
169      }
170      return 1;
171  }
172  int checkSignedBitfieldOverflow(int64_t value, int64_t incr, uint64_t bits, int owtype, int64_t *limit) {
173      int64_t max = (bits == 64) ? INT64_MAX : (((int64_t)1<<(bits-1))-1);
174      int64_t min = (-max)-1;
175      int64_t maxincr = max-value;
176      int64_t minincr = min-value;
177      if (value > max || (bits != 64 && incr > maxincr) || (value >= 0 && incr > 0 && incr > maxincr))
178      {
179          if (limit) {
180              if (owtype == BFOVERFLOW_WRAP) {
181                  goto handle_wrap;
182              } else if (owtype == BFOVERFLOW_SAT) {
183                  *limit = max;
184              }
185          }
186          return 1;
187      } else if (value < min || (bits != 64 && incr < minincr) || (value < 0 && incr < 0 && incr < minincr)) {
188          if (limit) {
189              if (owtype == BFOVERFLOW_WRAP) {
190                  goto handle_wrap;
191              } else if (owtype == BFOVERFLOW_SAT) {
192                  *limit = min;
193              }
194          }
195          return -1;
196      }
197      return 0;
198  handle_wrap:
199      {
200          uint64_t mask = ((uint64_t)-1) << bits;
201          uint64_t msb = (uint64_t)1 << (bits-1);
202          uint64_t a = value, b = incr, c;
203          c = a+b; &bsol;* Perform addition as unsigned so that's defined. */
204          if (c & msb) {
205              c |= mask;
206          } else {
207              c &= ~mask;
208          }
209          *limit = c;
210      }
211      return 1;
212  }
213  void printBits(unsigned char *p, PORT_ULONG count) {
214      PORT_ULONG j, i, byte;
215      for (j = 0; j < count; j++) {
216          byte = p[j];
217          for (i = 0x80; i > 0; i /= 2)
218              printf("%c", (byte & i) ? '1' : '0');
219          printf("|");
220      }
221      printf("\n");
222  }
223  #define BITOP_AND   0
224  #define BITOP_OR    1
225  #define BITOP_XOR   2
226  #define BITOP_NOT   3
227  #define BITFIELDOP_GET 0
228  #define BITFIELDOP_SET 1
229  #define BITFIELDOP_INCRBY 2
230  int getBitOffsetFromArgument(client *c, robj *o, size_t *offset, int hash, int bits) {
231      PORT_LONGLONG loffset;
232      char *err = "bit offset is not an integer or out of range";
233      char *p = o->ptr;
234      size_t plen = sdslen(p);
235      int usehash = 0;
236      if (p[0] == '#' && hash && bits > 0) usehash = 1;
237      if (string2ll(p+usehash,plen-usehash,&loffset) == 0) {
238          addReplyError(c,err);
239          return C_ERR;
240      }
241      if (usehash) loffset *= bits;
242      if ((loffset < 0) || ((PORT_ULONGLONG)loffset >> 3) >= (512*1024*1024))
243      {
244          addReplyError(c,err);
245          return C_ERR;
246      }
247      *offset = (size_t)loffset;
248      return C_OK;
249  }
250  int getBitfieldTypeFromArgument(client *c, robj *o, int *sign, int *bits) {
251      char *p = o->ptr;
252      char *err = "Invalid bitfield type. Use something like i16 u8. Note that u64 is not supported but i64 is.";
253      PORT_LONGLONG llbits;
254      if (p[0] == 'i') {
255          *sign = 1;
256      } else if (p[0] == 'u') {
257          *sign = 0;
258      } else {
259          addReplyError(c,err);
260          return C_ERR;
261      }
262      if ((string2ll(p+1,strlen(p+1),&llbits)) == 0 ||
263          llbits < 1 ||
264          (*sign == 1 && llbits > 64) ||
265          (*sign == 0 && llbits > 63))
266      {
267          addReplyError(c,err);
268          return C_ERR;
269      }
270      *bits = llbits;
271      return C_OK;
272  }
273  robj *lookupStringForBitCommand(client *c, size_t maxbit) {
274      size_t byte = maxbit >> 3;
275      robj *o = lookupKeyWrite(c->db,c->argv[1]);
276      if (o == NULL) {
277          o = createObject(OBJ_STRING,sdsnewlen(NULL, byte+1));
278          dbAdd(c->db,c->argv[1],o);
279      } else {
280          if (checkType(c,o,OBJ_STRING)) return NULL;
281          o = dbUnshareStringValue(c->db,c->argv[1],o);
282          o->ptr = sdsgrowzero(o->ptr,byte+1);
283      }
284      return o;
285  }
286  unsigned char *getObjectReadOnlyString(robj *o, PORT_LONG *len, char *llbuf) {
287      serverAssert(o->type == OBJ_STRING);
288      unsigned char *p = NULL;
289      if (o && o->encoding == OBJ_ENCODING_INT) {
290          p = (unsigned char*) llbuf;
291          if (len) *len = ll2string(llbuf,LONG_STR_SIZE,(PORT_LONG)o->ptr);
292      } else if (o) {
293          p = (unsigned char*) o->ptr;
294          if (len) *len = sdslen(o->ptr);
295      } else {
296          if (len) *len = 0;
297      }
298      return p;
299  }
300  void setbitCommand(client *c) {
301      robj *o;
302      char *err = "bit is not an integer or out of range";
303      size_t bitoffset;
304      ssize_t byte, bit;
305      int byteval, bitval;
306      PORT_LONG on;
307      if (getBitOffsetFromArgument(c,c->argv[2],&bitoffset,0,0) != C_OK)
308          return;
309      if (getLongFromObjectOrReply(c,c->argv[3],&on,err) != C_OK)
310          return;
311      if (on & ~1) {
312          addReplyError(c,err);
313          return;
314      }
315      if ((o = lookupStringForBitCommand(c,bitoffset)) == NULL) return;
316      byte = bitoffset >> 3;
317      byteval = ((uint8_t*)o->ptr)[byte];
318      bit = 7 - (bitoffset & 0x7);
319      bitval = byteval & (1 << bit);
320      byteval &= ~(1 << bit);
321      byteval |= ((on & 0x1) << bit);
322      ((uint8_t*)o->ptr)[byte] = byteval;
323      signalModifiedKey(c->db,c->argv[1]);
324      notifyKeyspaceEvent(NOTIFY_STRING,"setbit",c->argv[1],c->db->id);
325      server.dirty++;
326      addReply(c, bitval ? shared.cone : shared.czero);
327  }
328  void getbitCommand(client *c) {
329      robj *o;
330      char llbuf[32];
331      size_t bitoffset;
332      size_t byte, bit;
333      size_t bitval = 0;
334      if (getBitOffsetFromArgument(c,c->argv[2],&bitoffset,0,0) != C_OK)
335          return;
336      if ((o = lookupKeyReadOrReply(c,c->argv[1],shared.czero)) == NULL ||
337          checkType(c,o,OBJ_STRING)) return;
338      byte = bitoffset >> 3;
339      bit = 7 - (bitoffset & 0x7);
340      if (sdsEncodedObject(o)) {
341          if (byte < sdslen(o->ptr))
342              bitval = ((uint8_t*)o->ptr)[byte] & (1 << bit);
343      } else {
344          if (byte < (size_t)ll2string(llbuf,sizeof(llbuf),(PORT_LONG)o->ptr))
345              bitval = llbuf[byte] & (1 << bit);
346      }
347      addReply(c, bitval ? shared.cone : shared.czero);
348  }
349  void bitopCommand(client *c) {
350      char *opname = c->argv[1]->ptr;
351      robj *o, *targetkey = c->argv[2];
352      PORT_ULONG op, j, numkeys;
353      robj **objects;      &bsol;* Array of source objects. */
354      unsigned char **src; &bsol;* Array of source strings pointers. */
355      PORT_ULONG *len, maxlen = 0; &bsol;* Array of length of src strings,
356                                         and max len. */
357      PORT_ULONG minlen = 0;    &bsol;* Min len among the input keys. */
358      unsigned char *res = NULL; &bsol;* Resulting string. */
359      if ((opname[0] == 'a' || opname[0] == 'A') && !strcasecmp(opname,"and"))
360          op = BITOP_AND;
361      else if((opname[0] == 'o' || opname[0] == 'O') && !strcasecmp(opname,"or"))
362          op = BITOP_OR;
363      else if((opname[0] == 'x' || opname[0] == 'X') && !strcasecmp(opname,"xor"))
364          op = BITOP_XOR;
365      else if((opname[0] == 'n' || opname[0] == 'N') && !strcasecmp(opname,"not"))
366          op = BITOP_NOT;
367      else {
368          addReply(c,shared.syntaxerr);
369          return;
370      }
371      if (op == BITOP_NOT && c->argc != 4) {
372          addReplyError(c,"BITOP NOT must be called with a single source key.");
373          return;
374      }
375      numkeys = c->argc - 3;
376      src = zmalloc(sizeof(unsigned char*) * numkeys);
377      len = zmalloc(sizeof(PORT_LONG) * numkeys);
378      objects = zmalloc(sizeof(robj*) * numkeys);
379      for (j = 0; j < numkeys; j++) {
380          o = lookupKeyRead(c->db,c->argv[j+3]);
381          if (o == NULL) {
382              objects[j] = NULL;
383              src[j] = NULL;
384              len[j] = 0;
385              minlen = 0;
386              continue;
387          }
388          if (checkType(c,o,OBJ_STRING)) {
389              PORT_ULONG i;
390              for (i = 0; i < j; i++) {
391                  if (objects[i])
392                      decrRefCount(objects[i]);
393              }
394              zfree(src);
395              zfree(len);
396              zfree(objects);
397              return;
398          }
399          objects[j] = getDecodedObject(o);
400          src[j] = objects[j]->ptr;
401          len[j] = (PORT_LONG) sdslen(objects[j]->ptr);                           WIN_PORT_FIX &bsol;* cast (PORT_LONG) */
402          if (len[j] > maxlen) maxlen = len[j];
403          if (j == 0 || len[j] < minlen) minlen = len[j];
404      }
405      if (maxlen) {
406          res = (unsigned char*) sdsnewlen(NULL,maxlen);
407          unsigned char output, byte;
408          PORT_ULONG i;
409          j = 0;
410          #ifndef USE_ALIGNED_ACCESS
411          if (minlen >= sizeof(PORT_ULONG)*4 && numkeys <= 16) {
412              PORT_ULONG *lp[16];
413              PORT_ULONG *lres = (PORT_ULONG*) res;
414              memcpy(lp,src,sizeof(PORT_ULONG*)*numkeys);
415              memcpy(res,src[0],minlen);
416              if (op == BITOP_AND) {
417                  while(minlen >= sizeof(PORT_ULONG)*4) {
418                      for (i = 1; i < numkeys; i++) {
419                          lres[0] &= lp[i][0];
420                          lres[1] &= lp[i][1];
421                          lres[2] &= lp[i][2];
422                          lres[3] &= lp[i][3];
423                          lp[i]+=4;
424                      }
425                      lres+=4;
426                      j += sizeof(PORT_ULONG)*4;
427                      minlen -= sizeof(PORT_ULONG)*4;
428                  }
429              } else if (op == BITOP_OR) {
430                  while(minlen >= sizeof(PORT_ULONG)*4) {
431                      for (i = 1; i < numkeys; i++) {
432                          lres[0] |= lp[i][0];
433                          lres[1] |= lp[i][1];
434                          lres[2] |= lp[i][2];
435                          lres[3] |= lp[i][3];
436                          lp[i]+=4;
437                      }
438                      lres+=4;
439                      j += sizeof(PORT_ULONG)*4;
440                      minlen -= sizeof(PORT_ULONG)*4;
441                  }
442              } else if (op == BITOP_XOR) {
443                  while(minlen >= sizeof(PORT_ULONG)*4) {
444                      for (i = 1; i < numkeys; i++) {
445                          lres[0] ^= lp[i][0];
446                          lres[1] ^= lp[i][1];
447                          lres[2] ^= lp[i][2];
448                          lres[3] ^= lp[i][3];
449                          lp[i]+=4;
450                      }
451                      lres+=4;
452                      j += sizeof(PORT_ULONG)*4;
453                      minlen -= sizeof(PORT_ULONG)*4;
454                  }
455              } else if (op == BITOP_NOT) {
456                  while(minlen >= sizeof(PORT_ULONG)*4) {
457                      lres[0] = ~lres[0];
458                      lres[1] = ~lres[1];
459                      lres[2] = ~lres[2];
460                      lres[3] = ~lres[3];
461                      lres+=4;
462                      j += sizeof(PORT_ULONG)*4;
463                      minlen -= sizeof(PORT_ULONG)*4;
464                  }
465              }
466          }
467          #endif
468          for (; j < maxlen; j++) {
469              output = (len[0] <= j) ? 0 : src[0][j];
470              if (op == BITOP_NOT) output = ~output;
471              for (i = 1; i < numkeys; i++) {
472                  byte = (len[i] <= j) ? 0 : src[i][j];
473                  switch(op) {
474                  case BITOP_AND: output &= byte; break;
475                  case BITOP_OR:  output |= byte; break;
476                  case BITOP_XOR: output ^= byte; break;
477                  }
478              }
479              res[j] = output;
480          }
481      }
482      for (j = 0; j < numkeys; j++) {
483          if (objects[j])
484              decrRefCount(objects[j]);
485      }
486      zfree(src);
487      zfree(len);
488      zfree(objects);
489      if (maxlen) {
490          o = createObject(OBJ_STRING,res);
491          setKey(c->db,targetkey,o);
492          notifyKeyspaceEvent(NOTIFY_STRING,"set",targetkey,c->db->id);
493          decrRefCount(o);
494      } else if (dbDelete(c->db,targetkey)) {
495          signalModifiedKey(c->db,targetkey);
496          notifyKeyspaceEvent(NOTIFY_GENERIC,"del",targetkey,c->db->id);
497      }
498      server.dirty++;
499      addReplyLongLong(c,maxlen); &bsol;* Return the output string length in bytes. */
500  }
501  void bitcountCommand(client *c) {
502      robj *o;
503      PORT_LONG start, end, strlen;
504      unsigned char *p;
505      char llbuf[LONG_STR_SIZE];
506      if ((o = lookupKeyReadOrReply(c,c->argv[1],shared.czero)) == NULL ||
507          checkType(c,o,OBJ_STRING)) return;
508      p = getObjectReadOnlyString(o,&strlen,llbuf);
509      if (c->argc == 4) {
510          if (getLongFromObjectOrReply(c,c->argv[2],&start,NULL) != C_OK)
511              return;
512          if (getLongFromObjectOrReply(c,c->argv[3],&end,NULL) != C_OK)
513              return;
514          if (start < 0 && end < 0 && start > end) {
515              addReply(c,shared.czero);
516              return;
517          }
518          if (start < 0) start = strlen+start;
519          if (end < 0) end = strlen+end;
520          if (start < 0) start = 0;
521          if (end < 0) end = 0;
522          if (end >= strlen) end = strlen-1;
523      } else if (c->argc == 2) {
524          start = 0;
525          end = strlen-1;
526      } else {
527          addReply(c,shared.syntaxerr);
528          return;
529      }
530      if (start > end) {
531          addReply(c,shared.czero);
532      } else {
533          PORT_LONG bytes = end-start+1;
534          addReplyLongLong(c,redisPopcount(p+start,bytes));
535      }
536  }
537  void bitposCommand(client *c) {
538      robj *o;
539      PORT_LONG bit, start, end, strlen;
540      unsigned char *p;
541      char llbuf[LONG_STR_SIZE];
542      int end_given = 0;
543      if (getLongFromObjectOrReply(c,c->argv[2],&bit,NULL) != C_OK)
544          return;
545      if (bit != 0 && bit != 1) {
546          addReplyError(c, "The bit argument must be 1 or 0.");
547          return;
548      }
549      if ((o = lookupKeyRead(c->db,c->argv[1])) == NULL) {
550          addReplyLongLong(c, bit ? -1 : 0);
551          return;
552      }
553      if (checkType(c,o,OBJ_STRING)) return;
554      p = getObjectReadOnlyString(o,&strlen,llbuf);
555      if (c->argc == 4 || c->argc == 5) {
556          if (getLongFromObjectOrReply(c,c->argv[3],&start,NULL) != C_OK)
557              return;
558          if (c->argc == 5) {
559              if (getLongFromObjectOrReply(c,c->argv[4],&end,NULL) != C_OK)
560                  return;
561              end_given = 1;
562          } else {
563              end = strlen-1;
564          }
565          if (start < 0) start = strlen+start;
566          if (end < 0) end = strlen+end;
567          if (start < 0) start = 0;
568          if (end < 0) end = 0;
569          if (end >= strlen) end = strlen-1;
570      } else if (c->argc == 3) {
571          start = 0;
572          end = strlen-1;
573      } else {
574          addReply(c,shared.syntaxerr);
575          return;
576      }
577      if (start > end) {
578          addReplyLongLong(c, -1);
579      } else {
580          PORT_LONG bytes = end-start+1;
581          PORT_LONG pos = redisBitpos(p+start,(PORT_ULONG)bytes,(int)bit);        WIN_PORT_FIX &bsol;* cast (PORT_ULONG), cast (int) */
582          if (end_given && bit == 0 && pos == bytes*8) {
583              addReplyLongLong(c,-1);
584              return;
585          }
586          if (pos != -1) pos += start*8; &bsol;* Adjust for the bytes we skipped. */
587          addReplyLongLong(c,pos);
588      }
589  }
590  struct bitfieldOp {
591      uint64_t offset;    &bsol;* Bitfield offset. */
592      int64_t i64;        &bsol;* Increment amount (INCRBY) or SET value */
593      int opcode;         &bsol;* Operation id. */
594      int owtype;         &bsol;* Overflow type to use. */
595      int bits;           &bsol;* Integer bitfield bits width. */
596      int sign;           &bsol;* True if signed, otherwise unsigned op. */
597  };
598  void bitfieldCommand(client *c) {
599      robj *o;
600      size_t bitoffset;
601      int j, numops = 0, changes = 0;
602      struct bitfieldOp *ops = NULL; &bsol;* Array of ops to execute at end. */
603      int owtype = BFOVERFLOW_WRAP; &bsol;* Overflow type. */
604      int readonly = 1;
605      size_t highest_write_offset = 0;
606      for (j = 2; j < c->argc; j++) {
607          int remargs = c->argc-j-1; &bsol;* Remaining args other than current. */
608          char *subcmd = c->argv[j]->ptr; &bsol;* Current command name. */
609          int opcode; &bsol;* Current operation code. */
610          PORT_LONGLONG i64 = 0;  &bsol;* Signed SET value. */
611          int sign = 0; &bsol;* Signed or unsigned type? */
612          int bits = 0; &bsol;* Bitfield width in bits. */
613          if (!strcasecmp(subcmd,"get") && remargs >= 2)
614              opcode = BITFIELDOP_GET;
615          else if (!strcasecmp(subcmd,"set") && remargs >= 3)
616              opcode = BITFIELDOP_SET;
617          else if (!strcasecmp(subcmd,"incrby") && remargs >= 3)
618              opcode = BITFIELDOP_INCRBY;
619          else if (!strcasecmp(subcmd,"overflow") && remargs >= 1) {
620              char *owtypename = c->argv[j+1]->ptr;
621              j++;
622              if (!strcasecmp(owtypename,"wrap"))
623                  owtype = BFOVERFLOW_WRAP;
624              else if (!strcasecmp(owtypename,"sat"))
625                  owtype = BFOVERFLOW_SAT;
626              else if (!strcasecmp(owtypename,"fail"))
627                  owtype = BFOVERFLOW_FAIL;
628              else {
629                  addReplyError(c,"Invalid OVERFLOW type specified");
630                  zfree(ops);
631                  return;
632              }
633              continue;
634          } else {
635              addReply(c,shared.syntaxerr);
636              zfree(ops);
637              return;
638          }
639          if (getBitfieldTypeFromArgument(c,c->argv[j+1],&sign,&bits) != C_OK) {
640              zfree(ops);
641              return;
642          }
643          if (getBitOffsetFromArgument(c,c->argv[j+2],&bitoffset,1,bits) != C_OK){
644              zfree(ops);
645              return;
646          }
647          if (opcode != BITFIELDOP_GET) {
648              readonly = 0;
649              if (highest_write_offset < bitoffset + bits - 1)
650                  highest_write_offset = bitoffset + bits - 1;
651              if (getLongLongFromObjectOrReply(c,c->argv[j+3],&i64,NULL) != C_OK){
652                  zfree(ops);
653                  return;
654              }
655          }
656          ops = zrealloc(ops,sizeof(*ops)*(numops+1));
657          ops[numops].offset = bitoffset;
658          ops[numops].i64 = i64;
659          ops[numops].opcode = opcode;
660          ops[numops].owtype = owtype;
661          ops[numops].bits = bits;
662          ops[numops].sign = sign;
663          numops++;
664          j += 3 - (opcode == BITFIELDOP_GET);
665      }
666      if (readonly) {
667          o = lookupKeyRead(c->db,c->argv[1]);
668          if (o != NULL && checkType(c,o,OBJ_STRING)) {
669              zfree(ops);
670              return;
671          }
672      } else {
673          if ((o = lookupStringForBitCommand(c,
674              highest_write_offset)) == NULL) {
675              zfree(ops);
676              return;
677          }
678      }
679      addReplyMultiBulkLen(c,numops);
680      for (j = 0; j < numops; j++) {
681          struct bitfieldOp *thisop = ops+j;
682          if (thisop->opcode == BITFIELDOP_SET ||
683              thisop->opcode == BITFIELDOP_INCRBY)
684          {
685              if (thisop->sign) {
686                  int64_t oldval, newval, wrapped, retval;
687                  int overflow;
688                  oldval = getSignedBitfield(o->ptr,thisop->offset,
689                          thisop->bits);
690                  if (thisop->opcode == BITFIELDOP_INCRBY) {
691                      newval = oldval + thisop->i64;
692                      overflow = checkSignedBitfieldOverflow(oldval,
693                              thisop->i64,thisop->bits,thisop->owtype,&wrapped);
694                      if (overflow) newval = wrapped;
695                      retval = newval;
696                  } else {
697                      newval = thisop->i64;
698                      overflow = checkSignedBitfieldOverflow(newval,
699                              0,thisop->bits,thisop->owtype,&wrapped);
700                      if (overflow) newval = wrapped;
701                      retval = oldval;
702                  }
703                  if (!(overflow && thisop->owtype == BFOVERFLOW_FAIL)) {
704                      addReplyLongLong(c,retval);
705                      setSignedBitfield(o->ptr,thisop->offset,
706                                        thisop->bits,newval);
707                  } else {
708                      addReply(c,shared.nullbulk);
709                  }
710              } else {
711                  uint64_t oldval, newval, wrapped, retval;
712                  int overflow;
713                  oldval = getUnsignedBitfield(o->ptr,thisop->offset,
714                          thisop->bits);
715                  if (thisop->opcode == BITFIELDOP_INCRBY) {
716                      newval = oldval + thisop->i64;
717                      overflow = checkUnsignedBitfieldOverflow(oldval,
718                              thisop->i64,thisop->bits,thisop->owtype,&wrapped);
719                      if (overflow) newval = wrapped;
720                      retval = newval;
721                  } else {
722                      newval = thisop->i64;
723                      overflow = checkUnsignedBitfieldOverflow(newval,
724                              0,thisop->bits,thisop->owtype,&wrapped);
725                      if (overflow) newval = wrapped;
726                      retval = oldval;
727                  }
728                  if (!(overflow && thisop->owtype == BFOVERFLOW_FAIL)) {
729                      addReplyLongLong(c,retval);
730                      setUnsignedBitfield(o->ptr,thisop->offset,
731                                          thisop->bits,newval);
732                  } else {
733                      addReply(c,shared.nullbulk);
734                  }
735              }
736              changes++;
737          } else {
738              unsigned char buf[9];
739              PORT_LONG strlen = 0;
740              unsigned char *src = NULL;
741              char llbuf[LONG_STR_SIZE];
742              if (o != NULL)
743                  src = getObjectReadOnlyString(o,&strlen,llbuf);
744              memset(buf,0,9);
745              int i;
746              size_t byte = thisop->offset >> 3;
747              for (i = 0; i < 9; i++) {
748                  if (src == NULL || i+byte >= (size_t)strlen) break;
749                  buf[i] = src[i+byte];
750              }
751              if (thisop->sign) {
752                  int64_t val = getSignedBitfield(buf,thisop->offset-(byte*8),
753                                              thisop->bits);
754                  addReplyLongLong(c,val);
755              } else {
756                  uint64_t val = getUnsignedBitfield(buf,thisop->offset-(byte*8),
757                                              thisop->bits);
758                  addReplyLongLong(c,val);
759              }
760          }
761      }
762      if (changes) {
763          signalModifiedKey(c->db,c->argv[1]);
764          notifyKeyspaceEvent(NOTIFY_STRING,"setbit",c->argv[1],c->db->id);
765          server.dirty += changes;
766      }
767      zfree(ops);
768  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from redis-MDEwOlJlcG9zaXRvcnkxMDgxMTA3MDY=-flat-smallocx.c</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from redis-MDEwOlJlcG9zaXRvcnkxMDgxMTA3MDY=-flat-bitops.c</div>
                </div>
                <div class="column column_space"><pre><code>29  }
30  static size_t
31  get_size_impl(const char *cmd, size_t ind) {
32  	size_t ret;
33  	size_t z;
34  	size_t mib[4];
35  	size_t miblen = 4;
</pre></code></div>
                <div class="column column_space"><pre><code>135  }
136  #define BFOVERFLOW_WRAP 0
137  #define BFOVERFLOW_SAT 1
138  #define BFOVERFLOW_FAIL 2 &bsol;* Used by the BITFIELD command implementation. */
139  int checkUnsignedBitfieldOverflow(uint64_t value, int64_t incr, uint64_t bits, int owtype, uint64_t *limit) {
140      uint64_t max = (bits == 64) ? UINT64_MAX : (((uint64_t)1<<bits)-1);
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    