
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 3.6809815950920246%, Tokens: 9, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>Adafruit_nRF52_Arduino-MDEwOlJlcG9zaXRvcnk3NDM1NDcyOQ==-flat-HAPProcedure.h</h3>
            <pre><code>1  #ifndef HAPPROCEDURE_H_
2  #define HAPPROCEDURE_H_
3  enum HAPOpcode_t
4  {
5    HAP_OPCODE_CHR_SIGNATURE_READ = 0x01 ,
6    HAP_OPCODE_CHR_WRITE                 ,
7    HAP_OPCODE_CHR_READ                  ,
8    HAP_OPCODE_CHR_TIMED_WRITE           ,
9    HAP_OPCODE_CHR_EXECUTE_WRITE         ,
10    HAP_OPCODE_SVC_SIGNATURE_READ
11  };
12  enum HAPParamType_t
13  {
<span onclick='openModal()' class='match'>14    HAP_PARAM_VALUE = 1                     , 
15    HAP_PARAM_ADDITIONAL_AUTHORIZATION_DATA , 
16    HAP_PARAM_ORIGIN                        , 
17    HAP_PARAM_CHR_TYPE                      , 
18    HAP_PARAM_CHR_ID                        , 
19    HAP_PARAM_SVC_TYPE                      , 
20    HAP_PARAM_SVC_ID                        , 
21    HAP_PARAM_TTL                           , 
22    HAP_PARAM_RETURN_RESP                   , 
</span>23    HAP_PARAM_HAP_CHR_PROPERTIES_DESC       , 
24    HAP_PARAM_GATT_USR_DESC                 , 
25    HAP_PARAM_GATT_FORMAT_DESC              , 
26    HAP_PARAM_GATT_VALID_RANGE              , 
27    HAP_PARAM_HAP_STEP_VALUE_DESC           , 
28    HAP_PARAM_HAP_SVC_PROPERTIES            , 
29    HAP_PARAM_HAP_LINKED_SVC                , 
30    HAP_PARAM_HAP_VALID_VALUES_DESC         , 
31    HAP_PARAM_HAP_VALID_VALUES_RANGE_DESC     
32  };
33  enum HAPStatusCode_t
34  {
35    HAP_STATUS_SUCCESS = 0                 ,
36    HAP_STATUS_UNSUPPORTED_PDU             ,
37    HAP_STATUS_MAX_PROCEDURES              ,
38    HAP_STATUS_INSUFFICIENT_AUTHORIZATION  ,
39    HAP_STATUS_INVALID_INSTANCE_ID         ,
40    HAP_STATUS_INSUFFICIENT_AUTHENTICATION ,
41    HAP_STATUS_INVALID_REQUEST
42  };
43  enum HAPPduType_t
44  {
45    HAP_PDU_REQUEST = 0,
46    HAP_PDU_RESPONSE,
47  };
48  typedef struct
49  {
50    uint8_t  type;
51    uint16_t len;
52    const void* value;
53  }TLV8_t;
54  typedef struct ATTR_PACKED
55  {
56    uint8_t lenext   : 1; 
57    uint8_t type     : 3; 
58    uint8_t          : 3; 
59    uint8_t fragment : 1; 
60  } HAPControl_t;
61  VERIFY_STATIC(sizeof (HAPControl_t) == 1);
62  typedef struct ATTR_PACKED
63  {
64    HAPControl_t control ;
65    uint8_t  opcode      ;
66    uint8_t  tid         ; 
67    uint16_t instance_id ; 
68  } HAPRequestHeader_t;
69  VERIFY_STATIC(sizeof (HAPRequestHeader_t) == 5);
70  typedef struct ATTR_PACKED
71  {
72    HAPRequestHeader_t header;
73    uint16_t body_len;
74    uint8_t  body_data[1];
75  } HAPRequest_t;
76  typedef struct ATTR_PACKED
77  {
78    HAPControl_t control;
79    uint8_t tid;
80    uint8_t status;
81  }HAPResponseHeader_t;
82  VERIFY_STATIC(sizeof (HAPResponseHeader_t) == 3);
83  typedef struct ATTR_PACKED
84  {
85    HAPResponseHeader_t header;
86    uint16_t body_len;
87    uint8_t  body_data[1];
88  } HAPResponse_t;
89  TLV8_t   tlv8_decode_next(uint8_t const** pp_data, uint16_t* p_len);
90  void     tlv8_decode_cleanup(TLV8_t tlv);
91  uint8_t  tlv8_decode_n(uint8_t const* buf, uint16_t bufsize, TLV8_t tlv[], uint8_t count);
92  bool     tlv8_encode_next(uint8_t** pp_buf, uint16_t* p_buflen, TLV8_t tlv);
93  uint16_t tlv8_encode_n(uint8_t* buf, uint16_t bufsize, TLV8_t tlv[], uint8_t count);
94  uint16_t tlv8_encode_calculate_len(TLV8_t tlv_para[], uint8_t count);
95  #endif &bsol;* HAPPROCEDURE_H_ */
</code></pre>
        </div>
        <div class="column">
            <h3>PINRemoteImage-MDEwOlJlcG9zaXRvcnkzOTUzNzEwMw==-flat-wicdec.c</h3>
            <pre><code>1  #include "./wicdec.h"
2  #ifdef HAVE_CONFIG_H
3  #include "webp/config.h"
4  #endif
5  #include <assert.h>
6  #include <stdio.h>
7  #include <string.h>
8  #ifdef HAVE_WINCODEC_H
9  #ifdef __MINGW32__
10  #define INITGUID  
11  #endif
12  #define CINTERFACE
13  #define COBJMACROS
14  #define _WIN32_IE 0x500  
15  #include <ole2.h>  
16  #include <shlwapi.h>
17  #include <tchar.h>
18  #include <windows.h>
19  #include <wincodec.h>
20  #include "../examples/unicode.h"
21  #include "./imageio_util.h"
22  #include "./metadata.h"
23  #include "webp/encode.h"
24  #define IFS(fn)                                                     \
25    do {                                                              \
26      if (SUCCEEDED(hr)) {                                            \
27        hr = (fn);                                                    \
28        if (FAILED(hr)) fprintf(stderr, #fn " failed %08lx\n", hr);   \
29      }                                                               \
30    } while (0)
31  #define WEBP_DEFINE_GUID(name, l, w1, w2, b1, b2, b3, b4, b5, b6, b7, b8) \
32    static const GUID name = \
33        { l, w1, w2, { b1, b2,  b3,  b4,  b5,  b6,  b7,  b8 } }
34  #ifdef __cplusplus
35  #define MAKE_REFGUID(x) (x)
36  #else
37  #define MAKE_REFGUID(x) &(x)
38  #endif
39  typedef struct WICFormatImporter {
<span onclick='openModal()' class='match'>40    const GUID* pixel_format;
41    int bytes_per_pixel;
42    int (*import)(WebPPicture* const, const uint8_t* const, int);
</span>43  } WICFormatImporter;
44  WEBP_DEFINE_GUID(GUID_WICPixelFormat24bppBGR_,
45                   0x6fddc324, 0x4e03, 0x4bfe,
46                   0xb1, 0x85, 0x3d, 0x77, 0x76, 0x8d, 0xc9, 0x0c);
47  WEBP_DEFINE_GUID(GUID_WICPixelFormat24bppRGB_,
48                   0x6fddc324, 0x4e03, 0x4bfe,
49                   0xb1, 0x85, 0x3d, 0x77, 0x76, 0x8d, 0xc9, 0x0d);
50  WEBP_DEFINE_GUID(GUID_WICPixelFormat32bppBGRA_,
51                   0x6fddc324, 0x4e03, 0x4bfe,
52                   0xb1, 0x85, 0x3d, 0x77, 0x76, 0x8d, 0xc9, 0x0f);
53  WEBP_DEFINE_GUID(GUID_WICPixelFormat32bppRGBA_,
54                   0xf5c7ad2d, 0x6a8d, 0x43dd,
55                   0xa7, 0xa8, 0xa2, 0x99, 0x35, 0x26, 0x1a, 0xe9);
56  WEBP_DEFINE_GUID(GUID_WICPixelFormat64bppBGRA_,
57                   0x1562ff7c, 0xd352, 0x46f9,
58                   0x97, 0x9e, 0x42, 0x97, 0x6b, 0x79, 0x22, 0x46);
59  WEBP_DEFINE_GUID(GUID_WICPixelFormat64bppRGBA_,
60                   0x6fddc324, 0x4e03, 0x4bfe,
61                   0xb1, 0x85, 0x3d, 0x77, 0x76, 0x8d, 0xc9, 0x16);
62  static HRESULT OpenInputStream(const char* filename, IStream** stream) {
63    HRESULT hr = S_OK;
64    if (!WSTRCMP(filename, "-")) {
65      const uint8_t* data = NULL;
66      size_t data_size = 0;
67      const int ok = ImgIoUtilReadFile(filename, &data, &data_size);
68      if (ok) {
69        HGLOBAL image = GlobalAlloc(GMEM_MOVEABLE, data_size);
70        if (image != NULL) {
71          void* const image_mem = GlobalLock(image);
72          if (image_mem != NULL) {
73            memcpy(image_mem, data, data_size);
74            GlobalUnlock(image);
75            IFS(CreateStreamOnHGlobal(image, TRUE, stream));
76          } else {
77            hr = E_FAIL;
78          }
79        } else {
80          hr = E_OUTOFMEMORY;
81        }
82        free((void*)data);
83      } else {
84        hr = E_FAIL;
85      }
86    } else {
87      IFS(SHCreateStreamOnFile((const LPTSTR)filename, STGM_READ, stream));
88    }
89    if (FAILED(hr)) {
90      _ftprintf(stderr, _T("Error opening input file %s (%08lx)\n"),
91                (const LPTSTR)filename, hr);
92    }
93    return hr;
94  }
95  static HRESULT ExtractICCP(IWICImagingFactory* const factory,
96                             IWICBitmapFrameDecode* const frame,
97                             MetadataPayload* const iccp) {
98    HRESULT hr = S_OK;
99    UINT i, count;
100    IWICColorContext** color_contexts;
101    IFS(IWICBitmapFrameDecode_GetColorContexts(frame, 0, NULL, &count));
102    if (FAILED(hr) || count == 0) return hr;
103    color_contexts = (IWICColorContext**)calloc(count, sizeof(*color_contexts));
104    if (color_contexts == NULL) return E_OUTOFMEMORY;
105    for (i = 0; SUCCEEDED(hr) && i < count; ++i) {
106      IFS(IWICImagingFactory_CreateColorContext(factory, &color_contexts[i]));
107    }
108    if (SUCCEEDED(hr)) {
109      UINT num_color_contexts;
110      IFS(IWICBitmapFrameDecode_GetColorContexts(frame,
111                                                 count, color_contexts,
112                                                 &num_color_contexts));
113      assert(FAILED(hr) || num_color_contexts <= count);
114      for (i = 0; SUCCEEDED(hr) && i < num_color_contexts; ++i) {
115        WICColorContextType type;
116        IFS(IWICColorContext_GetType(color_contexts[i], &type));
117        if (SUCCEEDED(hr) && type == WICColorContextProfile) {
118          UINT size;
119          IFS(IWICColorContext_GetProfileBytes(color_contexts[i],
120                                               0, NULL, &size));
121          if (SUCCEEDED(hr) && size > 0) {
122            iccp->bytes = (uint8_t*)malloc(size);
123            if (iccp->bytes == NULL) {
124              hr = E_OUTOFMEMORY;
125              break;
126            }
127            iccp->size = size;
128            IFS(IWICColorContext_GetProfileBytes(color_contexts[i],
129                                                 (UINT)iccp->size, iccp->bytes,
130                                                 &size));
131            if (SUCCEEDED(hr) && size != iccp->size) {
132              fprintf(stderr, "Warning! ICC profile size (%u) != expected (%u)\n",
133                      size, (uint32_t)iccp->size);
134              iccp->size = size;
135            }
136            break;
137          }
138        }
139      }
140    }
141    for (i = 0; i < count; ++i) {
142      if (color_contexts[i] != NULL) IUnknown_Release(color_contexts[i]);
143    }
144    free(color_contexts);
145    return hr;
146  }
147  static HRESULT ExtractMetadata(IWICImagingFactory* const factory,
148                                 IWICBitmapFrameDecode* const frame,
149                                 Metadata* const metadata) {
150    const HRESULT hr = ExtractICCP(factory, frame, &metadata->iccp);
151    if (FAILED(hr)) MetadataFree(metadata);
152    return hr;
153  }
154  static int HasPalette(GUID pixel_format) {
155    return (IsEqualGUID(MAKE_REFGUID(pixel_format),
156                        MAKE_REFGUID(GUID_WICPixelFormat1bppIndexed)) ||
157            IsEqualGUID(MAKE_REFGUID(pixel_format),
158                        MAKE_REFGUID(GUID_WICPixelFormat2bppIndexed)) ||
159            IsEqualGUID(MAKE_REFGUID(pixel_format),
160                        MAKE_REFGUID(GUID_WICPixelFormat4bppIndexed)) ||
161            IsEqualGUID(MAKE_REFGUID(pixel_format),
162                        MAKE_REFGUID(GUID_WICPixelFormat8bppIndexed)));
163  }
164  static int HasAlpha(IWICImagingFactory* const factory,
165                      IWICBitmapDecoder* const decoder,
166                      IWICBitmapFrameDecode* const frame,
167                      GUID pixel_format) {
168    int has_alpha;
169    if (HasPalette(pixel_format)) {
170      IWICPalette* frame_palette = NULL;
171      IWICPalette* global_palette = NULL;
172      BOOL frame_palette_has_alpha = FALSE;
173      BOOL global_palette_has_alpha = FALSE;
174      if (SUCCEEDED(IWICImagingFactory_CreatePalette(factory, &frame_palette)) &&
175          SUCCEEDED(IWICBitmapFrameDecode_CopyPalette(frame, frame_palette))) {
176        IWICPalette_HasAlpha(frame_palette, &frame_palette_has_alpha);
177      }
178      if (SUCCEEDED(IWICImagingFactory_CreatePalette(factory, &global_palette)) &&
179          SUCCEEDED(IWICBitmapDecoder_CopyPalette(decoder, global_palette))) {
180        IWICPalette_HasAlpha(global_palette, &global_palette_has_alpha);
181      }
182      has_alpha = frame_palette_has_alpha || global_palette_has_alpha;
183      if (frame_palette != NULL) IUnknown_Release(frame_palette);
184      if (global_palette != NULL) IUnknown_Release(global_palette);
185    } else {
186      has_alpha = IsEqualGUID(MAKE_REFGUID(pixel_format),
187                              MAKE_REFGUID(GUID_WICPixelFormat32bppRGBA_)) ||
188                  IsEqualGUID(MAKE_REFGUID(pixel_format),
189                              MAKE_REFGUID(GUID_WICPixelFormat32bppBGRA_)) ||
190                  IsEqualGUID(MAKE_REFGUID(pixel_format),
191                              MAKE_REFGUID(GUID_WICPixelFormat64bppRGBA_)) ||
192                  IsEqualGUID(MAKE_REFGUID(pixel_format),
193                              MAKE_REFGUID(GUID_WICPixelFormat64bppBGRA_));
194    }
195    return has_alpha;
196  }
197  int ReadPictureWithWIC(const char* const filename,
198                         WebPPicture* const pic, int keep_alpha,
199                         Metadata* const metadata) {
200    WEBP_DEFINE_GUID(GUID_NULL_, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
201    static const WICFormatImporter kAlphaFormatImporters[] = {
202      { &GUID_WICPixelFormat32bppBGRA_, 4, WebPPictureImportBGRA },
203      { &GUID_WICPixelFormat32bppRGBA_, 4, WebPPictureImportRGBA },
204      { NULL, 0, NULL },
205    };
206    static const WICFormatImporter kNonAlphaFormatImporters[] = {
207      { &GUID_WICPixelFormat24bppBGR_, 3, WebPPictureImportBGR },
208      { &GUID_WICPixelFormat24bppRGB_, 3, WebPPictureImportRGB },
209      { NULL, 0, NULL },
210    };
211    HRESULT hr = S_OK;
212    IWICBitmapFrameDecode* frame = NULL;
213    IWICFormatConverter* converter = NULL;
214    IWICImagingFactory* factory = NULL;
215    IWICBitmapDecoder* decoder = NULL;
216    IStream* stream = NULL;
217    UINT frame_count = 0;
218    UINT width = 0, height = 0;
219    BYTE* rgb = NULL;
220    WICPixelFormatGUID src_pixel_format = GUID_WICPixelFormatUndefined;
221    const WICFormatImporter* importer = NULL;
222    GUID src_container_format = GUID_NULL_;
223    static const GUID* kAlphaContainers[] = {
224      &GUID_ContainerFormatBmp,
225      &GUID_ContainerFormatPng,
226      &GUID_ContainerFormatTiff,
227      NULL
228    };
229    int has_alpha = 0;
230    int64_t stride;
231    if (filename == NULL || pic == NULL) return 0;
232    IFS(CoInitialize(NULL));
233    IFS(CoCreateInstance(MAKE_REFGUID(CLSID_WICImagingFactory), NULL,
234                         CLSCTX_INPROC_SERVER,
235                         MAKE_REFGUID(IID_IWICImagingFactory),
236                         (LPVOID*)&factory));
237    if (hr == REGDB_E_CLASSNOTREG) {
238      fprintf(stderr,
239              "Couldn't access Windows Imaging Component (are you running "
240              "Windows XP SP3 or newer?). Most formats not available. "
241              "Use -s for the available YUV input.\n");
242    }
243    IFS(OpenInputStream(filename, &stream));
244    IFS(IWICImagingFactory_CreateDecoderFromStream(
245            factory, stream, NULL,
246            WICDecodeMetadataCacheOnDemand, &decoder));
247    IFS(IWICBitmapDecoder_GetFrameCount(decoder, &frame_count));
248    if (SUCCEEDED(hr) && frame_count == 0) {
249      fprintf(stderr, "No frame found in input file.\n");
250      hr = E_FAIL;
251    }
252    IFS(IWICBitmapDecoder_GetFrame(decoder, 0, &frame));
253    IFS(IWICBitmapFrameDecode_GetPixelFormat(frame, &src_pixel_format));
254    IFS(IWICBitmapDecoder_GetContainerFormat(decoder, &src_container_format));
255    if (SUCCEEDED(hr) && keep_alpha) {
256      const GUID** guid;
257      for (guid = kAlphaContainers; *guid != NULL; ++guid) {
258        if (IsEqualGUID(MAKE_REFGUID(src_container_format),
259                        MAKE_REFGUID(**guid))) {
260          has_alpha = HasAlpha(factory, decoder, frame, src_pixel_format);
261          break;
262        }
263      }
264    }
265    IFS(IWICImagingFactory_CreateFormatConverter(factory, &converter));
266    for (importer = has_alpha ? kAlphaFormatImporters : kNonAlphaFormatImporters;
267         hr == S_OK && importer->import != NULL; ++importer) {
268      BOOL can_convert;
269      const HRESULT cchr = IWICFormatConverter_CanConvert(
270          converter,
271          MAKE_REFGUID(src_pixel_format),
272          MAKE_REFGUID(*importer->pixel_format),
273          &can_convert);
274      if (SUCCEEDED(cchr) && can_convert) break;
275    }
276    if (importer->import == NULL) hr = E_FAIL;
277    IFS(IWICFormatConverter_Initialize(converter, (IWICBitmapSource*)frame,
278                                       importer->pixel_format,
279                                       WICBitmapDitherTypeNone,
280                                       NULL, 0.0, WICBitmapPaletteTypeCustom));
281    IFS(IWICFormatConverter_GetSize(converter, &width, &height));
282    stride = (int64_t)importer->bytes_per_pixel * width * sizeof(*rgb);
283    if (stride != (int)stride ||
284        !ImgIoUtilCheckSizeArgumentsOverflow(stride, height)) {
285      hr = E_FAIL;
286    }
287    if (SUCCEEDED(hr)) {
288      rgb = (BYTE*)malloc((size_t)stride * height);
289      if (rgb == NULL)
290        hr = E_OUTOFMEMORY;
291    }
292    IFS(IWICFormatConverter_CopyPixels(converter, NULL,
293                                       (UINT)stride, (UINT)stride * height, rgb));
294    if (SUCCEEDED(hr)) {
295      int ok;
296      pic->width = width;
297      pic->height = height;
298      pic->use_argb = 1;    
299      ok = importer->import(pic, rgb, (int)stride);
300      if (!ok) hr = E_FAIL;
301    }
302    if (SUCCEEDED(hr)) {
303      if (metadata != NULL) {
304        hr = ExtractMetadata(factory, frame, metadata);
305        if (FAILED(hr)) {
306          fprintf(stderr, "Error extracting image metadata using WIC!\n");
307        }
308      }
309    }
310    if (converter != NULL) IUnknown_Release(converter);
311    if (frame != NULL) IUnknown_Release(frame);
312    if (decoder != NULL) IUnknown_Release(decoder);
313    if (factory != NULL) IUnknown_Release(factory);
314    if (stream != NULL) IUnknown_Release(stream);
315    free(rgb);
316    return SUCCEEDED(hr);
317  }
318  #else  
319  int ReadPictureWithWIC(const char* const filename,
320                         struct WebPPicture* const pic, int keep_alpha,
321                         struct Metadata* const metadata) {
322    (void)filename;
323    (void)pic;
324    (void)keep_alpha;
325    (void)metadata;
326    fprintf(stderr, "Windows Imaging Component (WIC) support not compiled. "
327                    "Visual Studio and mingw-w64 builds support WIC. Make sure "
328                    "wincodec.h detection is working correctly if using autoconf "
329                    "and HAVE_WINCODEC_H is defined before building.\n");
330    return 0;
331  }
332  #endif  
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from Adafruit_nRF52_Arduino-MDEwOlJlcG9zaXRvcnk3NDM1NDcyOQ==-flat-HAPProcedure.h</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from PINRemoteImage-MDEwOlJlcG9zaXRvcnkzOTUzNzEwMw==-flat-wicdec.c</div>
                </div>
                <div class="column column_space"><pre><code>14    HAP_PARAM_VALUE = 1                     , 
15    HAP_PARAM_ADDITIONAL_AUTHORIZATION_DATA , 
16    HAP_PARAM_ORIGIN                        , 
17    HAP_PARAM_CHR_TYPE                      , 
18    HAP_PARAM_CHR_ID                        , 
19    HAP_PARAM_SVC_TYPE                      , 
20    HAP_PARAM_SVC_ID                        , 
21    HAP_PARAM_TTL                           , 
22    HAP_PARAM_RETURN_RESP                   , 
</pre></code></div>
                <div class="column column_space"><pre><code>40    const GUID* pixel_format;
41    int bytes_per_pixel;
42    int (*import)(WebPPicture* const, const uint8_t* const, int);
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    