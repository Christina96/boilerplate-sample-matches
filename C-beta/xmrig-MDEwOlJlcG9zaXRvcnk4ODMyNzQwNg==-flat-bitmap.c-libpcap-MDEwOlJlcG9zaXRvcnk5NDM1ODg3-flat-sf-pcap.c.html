
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 11.624834874504623%, Tokens: 8, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>xmrig-MDEwOlJlcG9zaXRvcnk4ODMyNzQwNg==-flat-bitmap.c</h3>
            <pre><code>1  #include "private/autogen/config.h"
2  #include "hwloc/autogen/config.h"
3  #include "hwloc.h"
4  #include "private/misc.h"
5  #include "private/private.h"
6  #include "private/debug.h"
7  #include "hwloc/bitmap.h"
8  #include <stdarg.h>
9  #include <stdio.h>
10  #include <assert.h>
11  #include <errno.h>
12  #include <ctype.h>
13  #define HWLOC_BITMAP_MAGIC 0x20091007
14  #define HWLOC_BITMAP_PREALLOC_BITS 512
15  #define HWLOC_BITMAP_PREALLOC_ULONGS (HWLOC_BITMAP_PREALLOC_BITS/HWLOC_BITS_PER_LONG)
16  struct hwloc_bitmap_s {
17    unsigned ulongs_count; &bsol;* how many ulong bitmasks are valid, >= 1 */
18    unsigned ulongs_allocated; &bsol;* how many ulong bitmasks are allocated, >= ulongs_count */
19    unsigned long *ulongs;
20    int infinite; &bsol;* set to 1 if all bits beyond ulongs are set */
21  #ifdef HWLOC_DEBUG
22    int magic;
23  #endif
24  };
25  #ifdef HWLOC_DEBUG
26  #define HWLOC__BITMAP_CHECK(set) do {				\
27    assert((set)->magic == HWLOC_BITMAP_MAGIC);			\
28    assert((set)->ulongs_count >= 1);				\
29    assert((set)->ulongs_allocated >= (set)->ulongs_count);	\
30  } while (0)
31  #else
32  #define HWLOC__BITMAP_CHECK(set)
33  #endif
34  #define HWLOC_SUBBITMAP_INDEX(cpu)		((cpu)/(HWLOC_BITS_PER_LONG))
35  #define HWLOC_SUBBITMAP_CPU_ULBIT(cpu)		((cpu)%(HWLOC_BITS_PER_LONG))
36  #define HWLOC_SUBBITMAP_READULONG(set,x)	((x) < (set)->ulongs_count ? (set)->ulongs[x] : (set)->infinite ? HWLOC_SUBBITMAP_FULL : HWLOC_SUBBITMAP_ZERO)
37  #define HWLOC_SUBBITMAP_ZERO			0UL
38  #define HWLOC_SUBBITMAP_FULL			(~0UL)
39  #define HWLOC_SUBBITMAP_ULBIT(bit)		(1UL<<(bit))
40  #define HWLOC_SUBBITMAP_CPU(cpu)		HWLOC_SUBBITMAP_ULBIT(HWLOC_SUBBITMAP_CPU_ULBIT(cpu))
41  #define HWLOC_SUBBITMAP_ULBIT_TO(bit)		(HWLOC_SUBBITMAP_FULL>>(HWLOC_BITS_PER_LONG-1-(bit)))
42  #define HWLOC_SUBBITMAP_ULBIT_FROM(bit)		(HWLOC_SUBBITMAP_FULL<<(bit))
43  #define HWLOC_SUBBITMAP_ULBIT_FROMTO(begin,end)	(HWLOC_SUBBITMAP_ULBIT_TO(end) & HWLOC_SUBBITMAP_ULBIT_FROM(begin))
44  struct hwloc_bitmap_s * hwloc_bitmap_alloc(void)
45  {
46    struct hwloc_bitmap_s * set;
47    set = malloc(sizeof(struct hwloc_bitmap_s));
48    if (!set)
49      return NULL;
50    set->ulongs_count = 1;
51    set->ulongs_allocated = HWLOC_BITMAP_PREALLOC_ULONGS;
52    set->ulongs = malloc(HWLOC_BITMAP_PREALLOC_ULONGS * sizeof(unsigned long));
53    if (!set->ulongs) {
54      free(set);
55      return NULL;
56    }
57    set->ulongs[0] = HWLOC_SUBBITMAP_ZERO;
58    set->infinite = 0;
59  #ifdef HWLOC_DEBUG
60    set->magic = HWLOC_BITMAP_MAGIC;
61  #endif
62    return set;
63  }
64  struct hwloc_bitmap_s * hwloc_bitmap_alloc_full(void)
65  {
66    struct hwloc_bitmap_s * set = hwloc_bitmap_alloc();
67    if (set) {
68      set->infinite = 1;
69      set->ulongs[0] = HWLOC_SUBBITMAP_FULL;
70    }
71    return set;
72  }
73  void hwloc_bitmap_free(struct hwloc_bitmap_s * set)
74  {
75    if (!set)
76      return;
77    HWLOC__BITMAP_CHECK(set);
78  #ifdef HWLOC_DEBUG
79    set->magic = 0;
80  #endif
81    free(set->ulongs);
82    free(set);
83  }
84  static int
85  hwloc_bitmap_enlarge_by_ulongs(struct hwloc_bitmap_s * set, unsigned needed_count) __hwloc_attribute_warn_unused_result;
86  static int
87  hwloc_bitmap_enlarge_by_ulongs(struct hwloc_bitmap_s * set, unsigned needed_count)
88  {
89    unsigned tmp = 1U << hwloc_flsl((unsigned long) needed_count - 1);
90    if (tmp > set->ulongs_allocated) {
91      unsigned long *tmpulongs;
92      tmpulongs = realloc(set->ulongs, tmp * sizeof(unsigned long));
93      if (!tmpulongs)
94        return -1;
95      set->ulongs = tmpulongs;
96      set->ulongs_allocated = tmp;
97    }
98    return 0;
99  }
100  static int
101  hwloc_bitmap_realloc_by_ulongs(struct hwloc_bitmap_s * set, unsigned needed_count) __hwloc_attribute_warn_unused_result;
102  static int
103  hwloc_bitmap_realloc_by_ulongs(struct hwloc_bitmap_s * set, unsigned needed_count)
104  {
105    unsigned i;
106    HWLOC__BITMAP_CHECK(set);
107    if (needed_count <= set->ulongs_count)
108      return 0;
109    if (hwloc_bitmap_enlarge_by_ulongs(set, needed_count) < 0)
110      return -1;
111    for(i=set->ulongs_count; i<needed_count; i++)
112      set->ulongs[i] = set->infinite ? HWLOC_SUBBITMAP_FULL : HWLOC_SUBBITMAP_ZERO;
113    set->ulongs_count = needed_count;
114    return 0;
115  }
116  #define hwloc_bitmap_realloc_by_cpu_index(set, cpu) hwloc_bitmap_realloc_by_ulongs(set, ((cpu)/HWLOC_BITS_PER_LONG)+1)
117  static int
118  hwloc_bitmap_reset_by_ulongs(struct hwloc_bitmap_s * set, unsigned needed_count) __hwloc_attribute_warn_unused_result;
119  static int
120  hwloc_bitmap_reset_by_ulongs(struct hwloc_bitmap_s * set, unsigned needed_count)
121  {
122    if (hwloc_bitmap_enlarge_by_ulongs(set, needed_count))
<span onclick='openModal()' class='match'>123      return -1;
124    set->ulongs_count = needed_count;
125    return 0;
126  }
127  #define hwloc_bitmap_reset_by_cpu_index(set, cpu) hwloc_bitmap_reset_by_ulongs(set, ((cpu)/HWLOC_BITS_PER_LONG)+1)
128  struct hwloc_bitmap_s * hwloc_bitmap_tma_dup(struct hwloc_tma *tma, const struct hwloc_bitmap_s * old)
</span>129  {
130    struct hwloc_bitmap_s * new;
131    if (!old)
132      return NULL;
133    HWLOC__BITMAP_CHECK(old);
134    new = hwloc_tma_malloc(tma, sizeof(struct hwloc_bitmap_s));
135    if (!new)
136      return NULL;
137    new->ulongs = hwloc_tma_malloc(tma, old->ulongs_allocated * sizeof(unsigned long));
138    if (!new->ulongs) {
139      free(new);
140      return NULL;
141    }
142    new->ulongs_allocated = old->ulongs_allocated;
143    new->ulongs_count = old->ulongs_count;
144    memcpy(new->ulongs, old->ulongs, new->ulongs_count * sizeof(unsigned long));
145    new->infinite = old->infinite;
146  #ifdef HWLOC_DEBUG
147    new->magic = HWLOC_BITMAP_MAGIC;
148  #endif
149    return new;
150  }
151  struct hwloc_bitmap_s * hwloc_bitmap_dup(const struct hwloc_bitmap_s * old)
152  {
153    return hwloc_bitmap_tma_dup(NULL, old);
154  }
155  int hwloc_bitmap_copy(struct hwloc_bitmap_s * dst, const struct hwloc_bitmap_s * src)
156  {
157    HWLOC__BITMAP_CHECK(dst);
158    HWLOC__BITMAP_CHECK(src);
159    if (hwloc_bitmap_reset_by_ulongs(dst, src->ulongs_count) < 0)
160      return -1;
161    memcpy(dst->ulongs, src->ulongs, src->ulongs_count * sizeof(unsigned long));
162    dst->infinite = src->infinite;
163    return 0;
164  }
165  #define HWLOC_PRIxSUBBITMAP		"%08lx"
166  #define HWLOC_BITMAP_SUBSTRING_SIZE	32
167  #define HWLOC_BITMAP_SUBSTRING_LENGTH	(HWLOC_BITMAP_SUBSTRING_SIZE/4)
168  #define HWLOC_BITMAP_STRING_PER_LONG	(HWLOC_BITS_PER_LONG/HWLOC_BITMAP_SUBSTRING_SIZE)
169  int hwloc_bitmap_snprintf(char * __hwloc_restrict buf, size_t buflen, const struct hwloc_bitmap_s * __hwloc_restrict set)
170  {
171    ssize_t size = buflen;
172    char *tmp = buf;
173    int res, ret = 0;
174    int needcomma = 0;
175    int i;
176    unsigned long accum = 0;
177    int accumed = 0;
178  #if HWLOC_BITS_PER_LONG == HWLOC_BITMAP_SUBSTRING_SIZE
179    const unsigned long accum_mask = ~0UL;
180  #else &bsol;* HWLOC_BITS_PER_LONG != HWLOC_BITMAP_SUBSTRING_SIZE */
181    const unsigned long accum_mask = ((1UL << HWLOC_BITMAP_SUBSTRING_SIZE) - 1) << (HWLOC_BITS_PER_LONG - HWLOC_BITMAP_SUBSTRING_SIZE);
182  #endif &bsol;* HWLOC_BITS_PER_LONG != HWLOC_BITMAP_SUBSTRING_SIZE */
183    HWLOC__BITMAP_CHECK(set);
184    if (buflen > 0)
185      tmp[0] = '\0';
186    if (set->infinite) {
187      res = hwloc_snprintf(tmp, size, "0xf...f");
188      needcomma = 1;
189      if (res < 0)
190        return -1;
191      ret += res;
192      if (res >= size)
193        res = size>0 ? (int)size - 1 : 0;
194      tmp += res;
195      size -= res;
196    }
197    i=(int) set->ulongs_count-1;
198    if (set->infinite) {
199      while (i>=0 && set->ulongs[i] == HWLOC_SUBBITMAP_FULL)
200        i--;
201    } else {
202      while (i>=0 && set->ulongs[i] == HWLOC_SUBBITMAP_ZERO)
203        i--;
204    }
205    while (i>=0 || accumed) {
206      if (!accumed) {
207        accum = set->ulongs[i--];
208        accumed = HWLOC_BITS_PER_LONG;
209      }
210      if (accum & accum_mask) {
211          res = hwloc_snprintf(tmp, size, needcomma ? ",0x" HWLOC_PRIxSUBBITMAP : "0x" HWLOC_PRIxSUBBITMAP,
212  		     (accum & accum_mask) >> (HWLOC_BITS_PER_LONG - HWLOC_BITMAP_SUBSTRING_SIZE));
213        needcomma = 1;
214      } else if (i == -1 && accumed == HWLOC_BITMAP_SUBSTRING_SIZE) {
215        res = hwloc_snprintf(tmp, size, needcomma ? ",0x0" : "0x0");
216      } else if (needcomma) {
217        res = hwloc_snprintf(tmp, size, ",");
218      } else {
219        res = 0;
220      }
221      if (res < 0)
222        return -1;
223      ret += res;
224  #if HWLOC_BITS_PER_LONG == HWLOC_BITMAP_SUBSTRING_SIZE
225      accum = 0;
226      accumed = 0;
227  #else
228      accum <<= HWLOC_BITMAP_SUBSTRING_SIZE;
229      accumed -= HWLOC_BITMAP_SUBSTRING_SIZE;
230  #endif
231      if (res >= size)
232        res = size>0 ? (int)size - 1 : 0;
233      tmp += res;
234      size -= res;
235    }
236    if (!ret) {
237      res = hwloc_snprintf(tmp, size, "0x0");
238      if (res < 0)
239        return -1;
240      ret += res;
241    }
242    return ret;
243  }
244  int hwloc_bitmap_asprintf(char ** strp, const struct hwloc_bitmap_s * __hwloc_restrict set)
245  {
246    int len;
247    char *buf;
248    HWLOC__BITMAP_CHECK(set);
249    len = hwloc_bitmap_snprintf(NULL, 0, set);
250    buf = malloc(len+1);
251    if (!buf)
252      return -1;
253    *strp = buf;
254    return hwloc_bitmap_snprintf(buf, len+1, set);
255  }
256  int hwloc_bitmap_sscanf(struct hwloc_bitmap_s *set, const char * __hwloc_restrict string)
257  {
258    const char * current = string;
259    unsigned long accum = 0;
260    int count=0;
261    int infinite = 0;
262    count++;
263    while ((current = strchr(current+1, ',')) != NULL)
264      count++;
265    current = string;
266    if (!strncmp("0xf...f", current, 7)) {
267      current += 7;
268      if (*current != ',') {
269        hwloc_bitmap_fill(set);
270        return 0;
271      }
272      current++;
273      infinite = 1;
274      count--;
275    }
276    if (hwloc_bitmap_reset_by_ulongs(set, (count + HWLOC_BITMAP_STRING_PER_LONG - 1) / HWLOC_BITMAP_STRING_PER_LONG) < 0)
277      return -1;
278    set->infinite = 0;
279    while (*current != '\0') {
280      unsigned long val;
281      char *next;
282      val = strtoul(current, &next, 16);
283      assert(count > 0);
284      count--;
285      accum |= (val << ((count * HWLOC_BITMAP_SUBSTRING_SIZE) % HWLOC_BITS_PER_LONG));
286      if (!(count % HWLOC_BITMAP_STRING_PER_LONG)) {
287        set->ulongs[count / HWLOC_BITMAP_STRING_PER_LONG] = accum;
288        accum = 0;
289      }
290      if (*next != ',') {
291        if (*next || count > 0)
292  	goto failed;
293        else
294  	break;
295      }
296      current = (const char*) next+1;
297    }
298    set->infinite = infinite; &bsol;* set at the end, to avoid spurious realloc with filled new ulongs */
299    return 0;
300   failed:
301    hwloc_bitmap_zero(set);
302    return -1;
303  }
304  int hwloc_bitmap_list_snprintf(char * __hwloc_restrict buf, size_t buflen, const struct hwloc_bitmap_s * __hwloc_restrict set)
305  {
306    int prev = -1;
307    ssize_t size = buflen;
308    char *tmp = buf;
309    int res, ret = 0;
310    int needcomma = 0;
311    HWLOC__BITMAP_CHECK(set);
312    if (buflen > 0)
313      tmp[0] = '\0';
314    while (1) {
315      int begin, end;
316      begin = hwloc_bitmap_next(set, prev);
317      if (begin == -1)
318        break;
319      end = hwloc_bitmap_next_unset(set, begin);
320      if (end == begin+1) {
321        res = hwloc_snprintf(tmp, size, needcomma ? ",%d" : "%d", begin);
322      } else if (end == -1) {
323        res = hwloc_snprintf(tmp, size, needcomma ? ",%d-" : "%d-", begin);
324      } else {
325        res = hwloc_snprintf(tmp, size, needcomma ? ",%d-%d" : "%d-%d", begin, end-1);
326      }
327      if (res < 0)
328        return -1;
329      ret += res;
330      if (res >= size)
331        res = size>0 ? (int)size - 1 : 0;
332      tmp += res;
333      size -= res;
334      needcomma = 1;
335      if (end == -1)
336        break;
337      else
338        prev = end - 1;
339    }
340    return ret;
341  }
342  int hwloc_bitmap_list_asprintf(char ** strp, const struct hwloc_bitmap_s * __hwloc_restrict set)
343  {
344    int len;
345    char *buf;
346    HWLOC__BITMAP_CHECK(set);
347    len = hwloc_bitmap_list_snprintf(NULL, 0, set);
348    buf = malloc(len+1);
349    if (!buf)
350      return -1;
351    *strp = buf;
352    return hwloc_bitmap_list_snprintf(buf, len+1, set);
353  }
354  int hwloc_bitmap_list_sscanf(struct hwloc_bitmap_s *set, const char * __hwloc_restrict string)
355  {
356    const char * current = string;
357    char *next;
358    long begin = -1, val;
359    hwloc_bitmap_zero(set);
360    while (*current != '\0') {
361      while (*current == ',' || *current == ' ')
362        current++;
363      val = strtoul(current, &next, 0);
364      if (next == current)
365        goto failed;
366      if (begin != -1) {
367        if (hwloc_bitmap_set_range(set, begin, val) < 0)
368          goto failed;
369        begin = -1;
370      } else if (*next == '-') {
371        if (*(next+1) == '\0') {
372  	if (hwloc_bitmap_set_range(set, val, -1) < 0)
373  	  goto failed;
374          break;
375        } else {
376  	begin = val;
377        }
378      } else if (*next == ',' || *next == ' ' || *next == '\0') {
379        hwloc_bitmap_set(set, val);
380      }
381      if (*next == '\0')
382        break;
383      current = next+1;
384    }
385    return 0;
386   failed:
387    hwloc_bitmap_zero(set);
388    return -1;
389  }
390  int hwloc_bitmap_taskset_snprintf(char * __hwloc_restrict buf, size_t buflen, const struct hwloc_bitmap_s * __hwloc_restrict set)
391  {
392    ssize_t size = buflen;
393    char *tmp = buf;
394    int res, ret = 0;
395    int started = 0;
396    int i;
397    HWLOC__BITMAP_CHECK(set);
398    if (buflen > 0)
399      tmp[0] = '\0';
400    if (set->infinite) {
401      res = hwloc_snprintf(tmp, size, "0xf...f");
402      started = 1;
403      if (res < 0)
404        return -1;
405      ret += res;
406      if (res >= size)
407        res = size>0 ? (int)size - 1 : 0;
408      tmp += res;
409      size -= res;
410    }
411    i=set->ulongs_count-1;
412    if (set->infinite) {
413      while (i>=0 && set->ulongs[i] == HWLOC_SUBBITMAP_FULL)
414        i--;
415    } else {
416      while (i>=1 && set->ulongs[i] == HWLOC_SUBBITMAP_ZERO)
417        i--;
418    }
419    while (i>=0) {
420      unsigned long val = set->ulongs[i--];
421      if (started) {
422  #if HWLOC_BITS_PER_LONG == 64
423        res = hwloc_snprintf(tmp, size, "%016lx", val);
424  #else
425        res = hwloc_snprintf(tmp, size, "%08lx", val);
426  #endif
427      } else if (val || i == -1) {
428        res = hwloc_snprintf(tmp, size, "0x%lx", val);
429        started = 1;
430      } else {
431        res = 0;
432      }
433      if (res < 0)
434        return -1;
435      ret += res;
436      if (res >= size)
437        res = size>0 ? (int)size - 1 : 0;
438      tmp += res;
439      size -= res;
440    }
441    if (!ret) {
442      res = hwloc_snprintf(tmp, size, "0x0");
443      if (res < 0)
444        return -1;
445      ret += res;
446    }
447    return ret;
448  }
449  int hwloc_bitmap_taskset_asprintf(char ** strp, const struct hwloc_bitmap_s * __hwloc_restrict set)
450  {
451    int len;
452    char *buf;
453    HWLOC__BITMAP_CHECK(set);
454    len = hwloc_bitmap_taskset_snprintf(NULL, 0, set);
455    buf = malloc(len+1);
456    if (!buf)
457      return -1;
458    *strp = buf;
459    return hwloc_bitmap_taskset_snprintf(buf, len+1, set);
460  }
461  int hwloc_bitmap_taskset_sscanf(struct hwloc_bitmap_s *set, const char * __hwloc_restrict string)
462  {
463    const char * current = string;
464    int chars;
465    int count;
466    int infinite = 0;
467    if (!strncmp("0xf...f", current, 7)) {
468      infinite = 1;
469      current += 7;
470      if (*current == '\0') {
471        hwloc_bitmap_fill(set);
472        return 0;
473      }
474    } else {
475      if (!strncmp("0x", current, 2))
476        current += 2;
477      if (*current == '\0') {
478        hwloc_bitmap_zero(set);
479        return 0;
480      }
481    }
482    chars = (int)strlen(current);
483    count = (chars * 4 + HWLOC_BITS_PER_LONG - 1) / HWLOC_BITS_PER_LONG;
484    if (hwloc_bitmap_reset_by_ulongs(set, count) < 0)
485      return -1;
486    set->infinite = 0;
487    while (*current != '\0') {
488      int tmpchars;
489      char ustr[17];
490      unsigned long val;
491      char *next;
492      tmpchars = chars % (HWLOC_BITS_PER_LONG/4);
493      if (!tmpchars)
494        tmpchars = (HWLOC_BITS_PER_LONG/4);
495      memcpy(ustr, current, tmpchars);
496      ustr[tmpchars] = '\0';
497      val = strtoul(ustr, &next, 16);
498      if (*next != '\0')
499        goto failed;
500      set->ulongs[count-1] = val;
501      current += tmpchars;
502      chars -= tmpchars;
503      count--;
504    }
505    set->infinite = infinite; &bsol;* set at the end, to avoid spurious realloc with filled new ulongs */
506    return 0;
507   failed:
508    hwloc_bitmap_zero(set);
509    return -1;
510  }
511  static void hwloc_bitmap__zero(struct hwloc_bitmap_s *set)
512  {
513  	unsigned i;
514  	for(i=0; i<set->ulongs_count; i++)
515  		set->ulongs[i] = HWLOC_SUBBITMAP_ZERO;
516  	set->infinite = 0;
517  }
518  void hwloc_bitmap_zero(struct hwloc_bitmap_s * set)
519  {
520  	HWLOC__BITMAP_CHECK(set);
521  	HWLOC_BUILD_ASSERT(HWLOC_BITMAP_PREALLOC_ULONGS >= 1);
522  	if (hwloc_bitmap_reset_by_ulongs(set, 1) < 0) {
523  	}
524  	hwloc_bitmap__zero(set);
525  }
526  static void hwloc_bitmap__fill(struct hwloc_bitmap_s * set)
527  {
528  	unsigned i;
529  	for(i=0; i<set->ulongs_count; i++)
530  		set->ulongs[i] = HWLOC_SUBBITMAP_FULL;
531  	set->infinite = 1;
532  }
533  void hwloc_bitmap_fill(struct hwloc_bitmap_s * set)
534  {
535  	HWLOC__BITMAP_CHECK(set);
536  	HWLOC_BUILD_ASSERT(HWLOC_BITMAP_PREALLOC_ULONGS >= 1);
537  	if (hwloc_bitmap_reset_by_ulongs(set, 1) < 0) {
538  	}
539  	hwloc_bitmap__fill(set);
540  }
541  int hwloc_bitmap_from_ulong(struct hwloc_bitmap_s *set, unsigned long mask)
542  {
543  	HWLOC__BITMAP_CHECK(set);
544  	HWLOC_BUILD_ASSERT(HWLOC_BITMAP_PREALLOC_ULONGS >= 1);
545  	if (hwloc_bitmap_reset_by_ulongs(set, 1) < 0) {
546  	}
547  	set->ulongs[0] = mask; &bsol;* there's always at least one ulong allocated */
548  	set->infinite = 0;
549  	return 0;
550  }
551  int hwloc_bitmap_from_ith_ulong(struct hwloc_bitmap_s *set, unsigned i, unsigned long mask)
552  {
553  	unsigned j;
554  	HWLOC__BITMAP_CHECK(set);
555  	if (hwloc_bitmap_reset_by_ulongs(set, i+1) < 0)
556  		return -1;
557  	set->ulongs[i] = mask;
558  	for(j=0; j<i; j++)
559  		set->ulongs[j] = HWLOC_SUBBITMAP_ZERO;
560  	set->infinite = 0;
561  	return 0;
562  }
563  int hwloc_bitmap_from_ulongs(struct hwloc_bitmap_s *set, unsigned nr, const unsigned long *masks)
564  {
565  	unsigned j;
566  	HWLOC__BITMAP_CHECK(set);
567  	if (hwloc_bitmap_reset_by_ulongs(set, nr) < 0)
568  		return -1;
569  	for(j=0; j<nr; j++)
570  		set->ulongs[j] = masks[j];
571  	set->infinite = 0;
572  	return 0;
573  }
574  unsigned long hwloc_bitmap_to_ulong(const struct hwloc_bitmap_s *set)
575  {
576  	HWLOC__BITMAP_CHECK(set);
577  	return set->ulongs[0]; &bsol;* there's always at least one ulong allocated */
578  }
579  unsigned long hwloc_bitmap_to_ith_ulong(const struct hwloc_bitmap_s *set, unsigned i)
580  {
581  	HWLOC__BITMAP_CHECK(set);
582  	return HWLOC_SUBBITMAP_READULONG(set, i);
583  }
584  int hwloc_bitmap_to_ulongs(const struct hwloc_bitmap_s *set, unsigned nr, unsigned long *masks)
585  {
586  	unsigned j;
587  	HWLOC__BITMAP_CHECK(set);
588  	for(j=0; j<nr; j++)
589  		masks[j] = HWLOC_SUBBITMAP_READULONG(set, j);
590  	return 0;
591  }
592  int hwloc_bitmap_nr_ulongs(const struct hwloc_bitmap_s *set)
593  {
594  	unsigned last;
595  	HWLOC__BITMAP_CHECK(set);
596  	if (set->infinite)
597  		return -1;
598  	last = hwloc_bitmap_last(set);
599  	return (last + HWLOC_BITS_PER_LONG)/HWLOC_BITS_PER_LONG;
600  }
601  int hwloc_bitmap_only(struct hwloc_bitmap_s * set, unsigned cpu)
602  {
603  	unsigned index_ = HWLOC_SUBBITMAP_INDEX(cpu);
604  	HWLOC__BITMAP_CHECK(set);
605  	if (hwloc_bitmap_reset_by_cpu_index(set, cpu) < 0)
606  		return -1;
607  	hwloc_bitmap__zero(set);
608  	set->ulongs[index_] |= HWLOC_SUBBITMAP_CPU(cpu);
609  	return 0;
610  }
611  int hwloc_bitmap_allbut(struct hwloc_bitmap_s * set, unsigned cpu)
612  {
613  	unsigned index_ = HWLOC_SUBBITMAP_INDEX(cpu);
614  	HWLOC__BITMAP_CHECK(set);
615  	if (hwloc_bitmap_reset_by_cpu_index(set, cpu) < 0)
616  		return -1;
617  	hwloc_bitmap__fill(set);
618  	set->ulongs[index_] &= ~HWLOC_SUBBITMAP_CPU(cpu);
619  	return 0;
620  }
621  int hwloc_bitmap_set(struct hwloc_bitmap_s * set, unsigned cpu)
622  {
623  	unsigned index_ = HWLOC_SUBBITMAP_INDEX(cpu);
624  	HWLOC__BITMAP_CHECK(set);
625  	if (set->infinite && cpu >= set->ulongs_count * HWLOC_BITS_PER_LONG)
626  		return 0;
627  	if (hwloc_bitmap_realloc_by_cpu_index(set, cpu) < 0)
628  		return -1;
629  	set->ulongs[index_] |= HWLOC_SUBBITMAP_CPU(cpu);
630  	return 0;
631  }
632  int hwloc_bitmap_set_range(struct hwloc_bitmap_s * set, unsigned begincpu, int _endcpu)
633  {
634  	unsigned i;
635  	unsigned beginset,endset;
636  	unsigned endcpu = (unsigned) _endcpu;
637  	HWLOC__BITMAP_CHECK(set);
638  	if (endcpu < begincpu)
639  		return 0;
640  	if (set->infinite && begincpu >= set->ulongs_count * HWLOC_BITS_PER_LONG)
641  		return 0;
642  	if (_endcpu == -1) {
643  		if (hwloc_bitmap_realloc_by_cpu_index(set, begincpu) < 0)
644  			return -1;
645  		beginset = HWLOC_SUBBITMAP_INDEX(begincpu);
646  		set->ulongs[beginset] |= HWLOC_SUBBITMAP_ULBIT_FROM(HWLOC_SUBBITMAP_CPU_ULBIT(begincpu));
647  		for(i=beginset+1; i<set->ulongs_count; i++)
648  			set->ulongs[i] = HWLOC_SUBBITMAP_FULL;
649  		set->infinite = 1;
650  	} else {
651  		if (set->infinite && endcpu >= set->ulongs_count * HWLOC_BITS_PER_LONG)
652  			endcpu = set->ulongs_count * HWLOC_BITS_PER_LONG - 1;
653  		if (hwloc_bitmap_realloc_by_cpu_index(set, endcpu) < 0)
654  			return -1;
655  		beginset = HWLOC_SUBBITMAP_INDEX(begincpu);
656  		endset = HWLOC_SUBBITMAP_INDEX(endcpu);
657  		if (beginset == endset) {
658  			set->ulongs[beginset] |= HWLOC_SUBBITMAP_ULBIT_FROMTO(HWLOC_SUBBITMAP_CPU_ULBIT(begincpu), HWLOC_SUBBITMAP_CPU_ULBIT(endcpu));
659  		} else {
660  			set->ulongs[beginset] |= HWLOC_SUBBITMAP_ULBIT_FROM(HWLOC_SUBBITMAP_CPU_ULBIT(begincpu));
661  			set->ulongs[endset] |= HWLOC_SUBBITMAP_ULBIT_TO(HWLOC_SUBBITMAP_CPU_ULBIT(endcpu));
662  		}
663  		for(i=beginset+1; i<endset; i++)
664  			set->ulongs[i] = HWLOC_SUBBITMAP_FULL;
665  	}
666  	return 0;
667  }
668  int hwloc_bitmap_set_ith_ulong(struct hwloc_bitmap_s *set, unsigned i, unsigned long mask)
669  {
670  	HWLOC__BITMAP_CHECK(set);
671  	if (hwloc_bitmap_realloc_by_ulongs(set, i+1) < 0)
672  		return -1;
673  	set->ulongs[i] = mask;
674  	return 0;
675  }
676  int hwloc_bitmap_clr(struct hwloc_bitmap_s * set, unsigned cpu)
677  {
678  	unsigned index_ = HWLOC_SUBBITMAP_INDEX(cpu);
679  	HWLOC__BITMAP_CHECK(set);
680  	if (!set->infinite && cpu >= set->ulongs_count * HWLOC_BITS_PER_LONG)
681  		return 0;
682  	if (hwloc_bitmap_realloc_by_cpu_index(set, cpu) < 0)
683  		return -1;
684  	set->ulongs[index_] &= ~HWLOC_SUBBITMAP_CPU(cpu);
685  	return 0;
686  }
687  int hwloc_bitmap_clr_range(struct hwloc_bitmap_s * set, unsigned begincpu, int _endcpu)
688  {
689  	unsigned i;
690  	unsigned beginset,endset;
691  	unsigned endcpu = (unsigned) _endcpu;
692  	HWLOC__BITMAP_CHECK(set);
693  	if (endcpu < begincpu)
694  		return 0;
695  	if (!set->infinite && begincpu >= set->ulongs_count * HWLOC_BITS_PER_LONG)
696  		return 0;
697  	if (_endcpu == -1) {
698  		if (hwloc_bitmap_realloc_by_cpu_index(set, begincpu) < 0)
699  			return -1;
700  		beginset = HWLOC_SUBBITMAP_INDEX(begincpu);
701  		set->ulongs[beginset] &= ~HWLOC_SUBBITMAP_ULBIT_FROM(HWLOC_SUBBITMAP_CPU_ULBIT(begincpu));
702  		for(i=beginset+1; i<set->ulongs_count; i++)
703  			set->ulongs[i] = HWLOC_SUBBITMAP_ZERO;
704  		set->infinite = 0;
705  	} else {
706  		if (!set->infinite && endcpu >= set->ulongs_count * HWLOC_BITS_PER_LONG)
707  			endcpu = set->ulongs_count * HWLOC_BITS_PER_LONG - 1;
708  		if (hwloc_bitmap_realloc_by_cpu_index(set, endcpu) < 0)
709  			return -1;
710  		beginset = HWLOC_SUBBITMAP_INDEX(begincpu);
711  		endset = HWLOC_SUBBITMAP_INDEX(endcpu);
712  		if (beginset == endset) {
713  			set->ulongs[beginset] &= ~HWLOC_SUBBITMAP_ULBIT_FROMTO(HWLOC_SUBBITMAP_CPU_ULBIT(begincpu), HWLOC_SUBBITMAP_CPU_ULBIT(endcpu));
714  		} else {
715  			set->ulongs[beginset] &= ~HWLOC_SUBBITMAP_ULBIT_FROM(HWLOC_SUBBITMAP_CPU_ULBIT(begincpu));
716  			set->ulongs[endset] &= ~HWLOC_SUBBITMAP_ULBIT_TO(HWLOC_SUBBITMAP_CPU_ULBIT(endcpu));
717  		}
718  		for(i=beginset+1; i<endset; i++)
719  			set->ulongs[i] = HWLOC_SUBBITMAP_ZERO;
720  	}
721  	return 0;
722  }
723  int hwloc_bitmap_isset(const struct hwloc_bitmap_s * set, unsigned cpu)
724  {
725  	unsigned index_ = HWLOC_SUBBITMAP_INDEX(cpu);
726  	HWLOC__BITMAP_CHECK(set);
727  	return (HWLOC_SUBBITMAP_READULONG(set, index_) & HWLOC_SUBBITMAP_CPU(cpu)) != 0;
728  }
729  int hwloc_bitmap_iszero(const struct hwloc_bitmap_s *set)
730  {
731  	unsigned i;
732  	HWLOC__BITMAP_CHECK(set);
733  	if (set->infinite)
734  		return 0;
735  	for(i=0; i<set->ulongs_count; i++)
736  		if (set->ulongs[i] != HWLOC_SUBBITMAP_ZERO)
737  			return 0;
738  	return 1;
739  }
740  int hwloc_bitmap_isfull(const struct hwloc_bitmap_s *set)
741  {
742  	unsigned i;
743  	HWLOC__BITMAP_CHECK(set);
744  	if (!set->infinite)
745  		return 0;
746  	for(i=0; i<set->ulongs_count; i++)
747  		if (set->ulongs[i] != HWLOC_SUBBITMAP_FULL)
748  			return 0;
749  	return 1;
750  }
751  int hwloc_bitmap_isequal (const struct hwloc_bitmap_s *set1, const struct hwloc_bitmap_s *set2)
752  {
753  	unsigned count1 = set1->ulongs_count;
754  	unsigned count2 = set2->ulongs_count;
755  	unsigned min_count = count1 < count2 ? count1 : count2;
756  	unsigned i;
757  	HWLOC__BITMAP_CHECK(set1);
758  	HWLOC__BITMAP_CHECK(set2);
759  	for(i=0; i<min_count; i++)
760  		if (set1->ulongs[i] != set2->ulongs[i])
761  			return 0;
762  	if (count1 != count2) {
763  		unsigned long w1 = set1->infinite ? HWLOC_SUBBITMAP_FULL : HWLOC_SUBBITMAP_ZERO;
764  		unsigned long w2 = set2->infinite ? HWLOC_SUBBITMAP_FULL : HWLOC_SUBBITMAP_ZERO;
765  		for(i=min_count; i<count1; i++) {
766  			if (set1->ulongs[i] != w2)
767  				return 0;
768  		}
769  		for(i=min_count; i<count2; i++) {
770  			if (set2->ulongs[i] != w1)
771  				return 0;
772  		}
773  	}
774  	if (set1->infinite != set2->infinite)
775  		return 0;
776  	return 1;
777  }
778  int hwloc_bitmap_intersects (const struct hwloc_bitmap_s *set1, const struct hwloc_bitmap_s *set2)
779  {
780  	unsigned count1 = set1->ulongs_count;
781  	unsigned count2 = set2->ulongs_count;
782  	unsigned min_count = count1 < count2 ? count1 : count2;
783  	unsigned i;
784  	HWLOC__BITMAP_CHECK(set1);
785  	HWLOC__BITMAP_CHECK(set2);
786  	for(i=0; i<min_count; i++)
787  		if (set1->ulongs[i] & set2->ulongs[i])
788  			return 1;
789  	if (count1 != count2) {
790  		if (set2->infinite) {
791  			for(i=min_count; i<set1->ulongs_count; i++)
792  				if (set1->ulongs[i])
793  					return 1;
794  		}
795  		if (set1->infinite) {
796  			for(i=min_count; i<set2->ulongs_count; i++)
797  				if (set2->ulongs[i])
798  					return 1;
799  		}
800  	}
801  	if (set1->infinite && set2->infinite)
802  		return 1;
803  	return 0;
804  }
805  int hwloc_bitmap_isincluded (const struct hwloc_bitmap_s *sub_set, const struct hwloc_bitmap_s *super_set)
806  {
807  	unsigned super_count = super_set->ulongs_count;
808  	unsigned sub_count = sub_set->ulongs_count;
809  	unsigned min_count = super_count < sub_count ? super_count : sub_count;
810  	unsigned i;
811  	HWLOC__BITMAP_CHECK(sub_set);
812  	HWLOC__BITMAP_CHECK(super_set);
813  	for(i=0; i<min_count; i++)
814  		if (super_set->ulongs[i] != (super_set->ulongs[i] | sub_set->ulongs[i]))
815  			return 0;
816  	if (super_count != sub_count) {
817  		if (!super_set->infinite)
818  			for(i=min_count; i<sub_count; i++)
819  				if (sub_set->ulongs[i])
820  					return 0;
821  		if (sub_set->infinite)
822  			for(i=min_count; i<super_count; i++)
823  				if (super_set->ulongs[i] != HWLOC_SUBBITMAP_FULL)
824  					return 0;
825  	}
826  	if (sub_set->infinite && !super_set->infinite)
827  		return 0;
828  	return 1;
829  }
830  int hwloc_bitmap_or (struct hwloc_bitmap_s *res, const struct hwloc_bitmap_s *set1, const struct hwloc_bitmap_s *set2)
831  {
832  	unsigned count1 = set1->ulongs_count;
833  	unsigned count2 = set2->ulongs_count;
834  	unsigned max_count = count1 > count2 ? count1 : count2;
835  	unsigned min_count = count1 + count2 - max_count;
836  	unsigned i;
837  	HWLOC__BITMAP_CHECK(res);
838  	HWLOC__BITMAP_CHECK(set1);
839  	HWLOC__BITMAP_CHECK(set2);
840  	if (hwloc_bitmap_reset_by_ulongs(res, max_count) < 0)
841  		return -1;
842  	for(i=0; i<min_count; i++)
843  		res->ulongs[i] = set1->ulongs[i] | set2->ulongs[i];
844  	if (count1 != count2) {
845  		if (min_count < count1) {
846  			if (set2->infinite) {
847  				res->ulongs_count = min_count;
848  			} else {
849  				for(i=min_count; i<max_count; i++)
850  					res->ulongs[i] = set1->ulongs[i];
851  			}
852  		} else {
853  			if (set1->infinite) {
854  				res->ulongs_count = min_count;
855  			} else {
856  				for(i=min_count; i<max_count; i++)
857  					res->ulongs[i] = set2->ulongs[i];
858  			}
859  		}
860  	}
861  	res->infinite = set1->infinite || set2->infinite;
862  	return 0;
863  }
864  int hwloc_bitmap_and (struct hwloc_bitmap_s *res, const struct hwloc_bitmap_s *set1, const struct hwloc_bitmap_s *set2)
865  {
866  	unsigned count1 = set1->ulongs_count;
867  	unsigned count2 = set2->ulongs_count;
868  	unsigned max_count = count1 > count2 ? count1 : count2;
869  	unsigned min_count = count1 + count2 - max_count;
870  	unsigned i;
871  	HWLOC__BITMAP_CHECK(res);
872  	HWLOC__BITMAP_CHECK(set1);
873  	HWLOC__BITMAP_CHECK(set2);
874  	if (hwloc_bitmap_reset_by_ulongs(res, max_count) < 0)
875  		return -1;
876  	for(i=0; i<min_count; i++)
877  		res->ulongs[i] = set1->ulongs[i] & set2->ulongs[i];
878  	if (count1 != count2) {
879  		if (min_count < count1) {
880  			if (set2->infinite) {
881  				for(i=min_count; i<max_count; i++)
882  					res->ulongs[i] = set1->ulongs[i];
883  			} else {
884  				res->ulongs_count = min_count;
885  			}
886  		} else {
887  			if (set1->infinite) {
888  				for(i=min_count; i<max_count; i++)
889  					res->ulongs[i] = set2->ulongs[i];
890  			} else {
891  				res->ulongs_count = min_count;
892  			}
893  		}
894  	}
895  	res->infinite = set1->infinite && set2->infinite;
896  	return 0;
897  }
898  int hwloc_bitmap_andnot (struct hwloc_bitmap_s *res, const struct hwloc_bitmap_s *set1, const struct hwloc_bitmap_s *set2)
899  {
900  	unsigned count1 = set1->ulongs_count;
901  	unsigned count2 = set2->ulongs_count;
902  	unsigned max_count = count1 > count2 ? count1 : count2;
903  	unsigned min_count = count1 + count2 - max_count;
904  	unsigned i;
905  	HWLOC__BITMAP_CHECK(res);
906  	HWLOC__BITMAP_CHECK(set1);
907  	HWLOC__BITMAP_CHECK(set2);
908  	if (hwloc_bitmap_reset_by_ulongs(res, max_count) < 0)
909  		return -1;
910  	for(i=0; i<min_count; i++)
911  		res->ulongs[i] = set1->ulongs[i] & ~set2->ulongs[i];
912  	if (count1 != count2) {
913  		if (min_count < count1) {
914  			if (!set2->infinite) {
915  				for(i=min_count; i<max_count; i++)
916  					res->ulongs[i] = set1->ulongs[i];
917  			} else {
918  				res->ulongs_count = min_count;
919  			}
920  		} else {
921  			if (set1->infinite) {
922  				for(i=min_count; i<max_count; i++)
923  					res->ulongs[i] = ~set2->ulongs[i];
924  			} else {
925  				res->ulongs_count = min_count;
926  			}
927  		}
928  	}
929  	res->infinite = set1->infinite && !set2->infinite;
930  	return 0;
931  }
932  int hwloc_bitmap_xor (struct hwloc_bitmap_s *res, const struct hwloc_bitmap_s *set1, const struct hwloc_bitmap_s *set2)
933  {
934  	unsigned count1 = set1->ulongs_count;
935  	unsigned count2 = set2->ulongs_count;
936  	unsigned max_count = count1 > count2 ? count1 : count2;
937  	unsigned min_count = count1 + count2 - max_count;
938  	unsigned i;
939  	HWLOC__BITMAP_CHECK(res);
940  	HWLOC__BITMAP_CHECK(set1);
941  	HWLOC__BITMAP_CHECK(set2);
942  	if (hwloc_bitmap_reset_by_ulongs(res, max_count) < 0)
943  		return -1;
944  	for(i=0; i<min_count; i++)
945  		res->ulongs[i] = set1->ulongs[i] ^ set2->ulongs[i];
946  	if (count1 != count2) {
947  		if (min_count < count1) {
948  			unsigned long w2 = set2->infinite ? HWLOC_SUBBITMAP_FULL : HWLOC_SUBBITMAP_ZERO;
949  			for(i=min_count; i<max_count; i++)
950  				res->ulongs[i] = set1->ulongs[i] ^ w2;
951  		} else {
952  			unsigned long w1 = set1->infinite ? HWLOC_SUBBITMAP_FULL : HWLOC_SUBBITMAP_ZERO;
953  			for(i=min_count; i<max_count; i++)
954  				res->ulongs[i] = set2->ulongs[i] ^ w1;
955  		}
956  	}
957  	res->infinite = (!set1->infinite) != (!set2->infinite);
958  	return 0;
959  }
960  int hwloc_bitmap_not (struct hwloc_bitmap_s *res, const struct hwloc_bitmap_s *set)
961  {
962  	unsigned count = set->ulongs_count;
963  	unsigned i;
964  	HWLOC__BITMAP_CHECK(res);
965  	HWLOC__BITMAP_CHECK(set);
966  	if (hwloc_bitmap_reset_by_ulongs(res, count) < 0)
967  		return -1;
968  	for(i=0; i<count; i++)
969  		res->ulongs[i] = ~set->ulongs[i];
970  	res->infinite = !set->infinite;
971  	return 0;
972  }
973  int hwloc_bitmap_first(const struct hwloc_bitmap_s * set)
974  {
975  	unsigned i;
976  	HWLOC__BITMAP_CHECK(set);
977  	for(i=0; i<set->ulongs_count; i++) {
978  		unsigned long w = set->ulongs[i];
979  		if (w)
980  			return hwloc_ffsl(w) - 1 + HWLOC_BITS_PER_LONG*i;
981  	}
982  	if (set->infinite)
983  		return set->ulongs_count * HWLOC_BITS_PER_LONG;
984  	return -1;
985  }
986  int hwloc_bitmap_first_unset(const struct hwloc_bitmap_s * set)
987  {
988  	unsigned i;
989  	HWLOC__BITMAP_CHECK(set);
990  	for(i=0; i<set->ulongs_count; i++) {
991  		unsigned long w = ~set->ulongs[i];
992  		if (w)
993  			return hwloc_ffsl(w) - 1 + HWLOC_BITS_PER_LONG*i;
994  	}
995  	if (!set->infinite)
996  		return set->ulongs_count * HWLOC_BITS_PER_LONG;
997  	return -1;
998  }
999  int hwloc_bitmap_last(const struct hwloc_bitmap_s * set)
1000  {
1001  	int i;
1002  	HWLOC__BITMAP_CHECK(set);
1003  	if (set->infinite)
1004  		return -1;
1005  	for(i=(int)set->ulongs_count-1; i>=0; i--) {
1006  		unsigned long w = set->ulongs[i];
1007  		if (w)
1008  			return hwloc_flsl(w) - 1 + HWLOC_BITS_PER_LONG*i;
1009  	}
1010  	return -1;
1011  }
1012  int hwloc_bitmap_last_unset(const struct hwloc_bitmap_s * set)
1013  {
1014  	int i;
1015  	HWLOC__BITMAP_CHECK(set);
1016  	if (!set->infinite)
1017  		return -1;
1018  	for(i=(int)set->ulongs_count-1; i>=0; i--) {
1019  		unsigned long w = ~set->ulongs[i];
1020  		if (w)
1021  			return hwloc_flsl(w) - 1 + HWLOC_BITS_PER_LONG*i;
1022  	}
1023  	return -1;
1024  }
1025  int hwloc_bitmap_next(const struct hwloc_bitmap_s * set, int prev_cpu)
1026  {
1027  	unsigned i = HWLOC_SUBBITMAP_INDEX(prev_cpu + 1);
1028  	HWLOC__BITMAP_CHECK(set);
1029  	if (i >= set->ulongs_count) {
1030  		if (set->infinite)
1031  			return prev_cpu + 1;
1032  		else
1033  			return -1;
1034  	}
1035  	for(; i<set->ulongs_count; i++) {
1036  		unsigned long w = set->ulongs[i];
1037  		if (prev_cpu >= 0 && HWLOC_SUBBITMAP_INDEX((unsigned) prev_cpu) == i)
1038  			w &= ~HWLOC_SUBBITMAP_ULBIT_TO(HWLOC_SUBBITMAP_CPU_ULBIT(prev_cpu));
1039  		if (w)
1040  			return hwloc_ffsl(w) - 1 + HWLOC_BITS_PER_LONG*i;
1041  	}
1042  	if (set->infinite)
1043  		return set->ulongs_count * HWLOC_BITS_PER_LONG;
1044  	return -1;
1045  }
1046  int hwloc_bitmap_next_unset(const struct hwloc_bitmap_s * set, int prev_cpu)
1047  {
1048  	unsigned i = HWLOC_SUBBITMAP_INDEX(prev_cpu + 1);
1049  	HWLOC__BITMAP_CHECK(set);
1050  	if (i >= set->ulongs_count) {
1051  		if (!set->infinite)
1052  			return prev_cpu + 1;
1053  		else
1054  			return -1;
1055  	}
1056  	for(; i<set->ulongs_count; i++) {
1057  		unsigned long w = ~set->ulongs[i];
1058  		if (prev_cpu >= 0 && HWLOC_SUBBITMAP_INDEX((unsigned) prev_cpu) == i)
1059  			w &= ~HWLOC_SUBBITMAP_ULBIT_TO(HWLOC_SUBBITMAP_CPU_ULBIT(prev_cpu));
1060  		if (w)
1061  			return hwloc_ffsl(w) - 1 + HWLOC_BITS_PER_LONG*i;
1062  	}
1063  	if (!set->infinite)
1064  		return set->ulongs_count * HWLOC_BITS_PER_LONG;
1065  	return -1;
1066  }
1067  int hwloc_bitmap_singlify(struct hwloc_bitmap_s * set)
1068  {
1069  	unsigned i;
1070  	int found = 0;
1071  	HWLOC__BITMAP_CHECK(set);
1072  	for(i=0; i<set->ulongs_count; i++) {
1073  		if (found) {
1074  			set->ulongs[i] = HWLOC_SUBBITMAP_ZERO;
1075  			continue;
1076  		} else {
1077  			unsigned long w = set->ulongs[i];
1078  			if (w) {
1079  				int _ffs = hwloc_ffsl(w);
1080  				set->ulongs[i] = HWLOC_SUBBITMAP_CPU(_ffs-1);
1081  				found = 1;
1082  			}
1083  		}
1084  	}
1085  	if (set->infinite) {
1086  		if (found) {
1087  			set->infinite = 0;
1088  		} else {
1089  			unsigned first = set->ulongs_count * HWLOC_BITS_PER_LONG;
1090  			set->infinite = 0; &bsol;* do not let realloc fill the newly allocated sets */
1091  			return hwloc_bitmap_set(set, first);
1092  		}
1093  	}
1094  	return 0;
1095  }
1096  int hwloc_bitmap_compare_first(const struct hwloc_bitmap_s * set1, const struct hwloc_bitmap_s * set2)
1097  {
1098  	unsigned count1 = set1->ulongs_count;
1099  	unsigned count2 = set2->ulongs_count;
1100  	unsigned max_count = count1 > count2 ? count1 : count2;
1101  	unsigned min_count = count1 + count2 - max_count;
1102  	unsigned i;
1103  	HWLOC__BITMAP_CHECK(set1);
1104  	HWLOC__BITMAP_CHECK(set2);
1105  	for(i=0; i<min_count; i++) {
1106  		unsigned long w1 = set1->ulongs[i];
1107  		unsigned long w2 = set2->ulongs[i];
1108  		if (w1 || w2) {
1109  			int _ffs1 = hwloc_ffsl(w1);
1110  			int _ffs2 = hwloc_ffsl(w2);
1111  			if (_ffs1 && _ffs2)
1112  				return _ffs1-_ffs2;
1113  			return _ffs2-_ffs1;
1114  		}
1115  	}
1116  	if (count1 != count2) {
1117  		if (min_count < count2) {
1118  			for(i=min_count; i<count2; i++) {
1119  				unsigned long w2 = set2->ulongs[i];
1120  				if (set1->infinite)
1121  					return -!(w2 & 1);
1122  				else if (w2)
1123  					return 1;
1124  			}
1125  		} else {
1126  			for(i=min_count; i<count1; i++) {
1127  				unsigned long w1 = set1->ulongs[i];
1128  				if (set2->infinite)
1129  					return !(w1 & 1);
1130  				else if (w1)
1131  					return -1;
1132  			}
1133  		}
1134  	}
1135  	return !!set1->infinite - !!set2->infinite;
1136  }
1137  int hwloc_bitmap_compare(const struct hwloc_bitmap_s * set1, const struct hwloc_bitmap_s * set2)
1138  {
1139  	unsigned count1 = set1->ulongs_count;
1140  	unsigned count2 = set2->ulongs_count;
1141  	unsigned max_count = count1 > count2 ? count1 : count2;
1142  	unsigned min_count = count1 + count2 - max_count;
1143  	int i;
1144  	HWLOC__BITMAP_CHECK(set1);
1145  	HWLOC__BITMAP_CHECK(set2);
1146  	if ((!set1->infinite) != (!set2->infinite))
1147  		return !!set1->infinite - !!set2->infinite;
1148  	if (count1 != count2) {
1149  		if (min_count < count2) {
1150  			unsigned long val1 = set1->infinite ? HWLOC_SUBBITMAP_FULL :  HWLOC_SUBBITMAP_ZERO;
1151  			for(i=(int)max_count-1; i>=(int) min_count; i--) {
1152  				unsigned long val2 = set2->ulongs[i];
1153  				if (val1 == val2)
1154  					continue;
1155  				return val1 < val2 ? -1 : 1;
1156  			}
1157  		} else {
1158  			unsigned long val2 = set2->infinite ? HWLOC_SUBBITMAP_FULL :  HWLOC_SUBBITMAP_ZERO;
1159  			for(i=(int)max_count-1; i>=(int) min_count; i--) {
1160  				unsigned long val1 = set1->ulongs[i];
1161  				if (val1 == val2)
1162  					continue;
1163  				return val1 < val2 ? -1 : 1;
1164  			}
1165  		}
1166  	}
1167  	for(i=(int)min_count-1; i>=0; i--) {
1168  		unsigned long val1 = set1->ulongs[i];
1169  		unsigned long val2 = set2->ulongs[i];
1170  		if (val1 == val2)
1171  			continue;
1172  		return val1 < val2 ? -1 : 1;
1173  	}
1174  	return 0;
1175  }
1176  int hwloc_bitmap_weight(const struct hwloc_bitmap_s * set)
1177  {
1178  	int weight = 0;
1179  	unsigned i;
1180  	HWLOC__BITMAP_CHECK(set);
1181  	if (set->infinite)
1182  		return -1;
1183  	for(i=0; i<set->ulongs_count; i++)
1184  		weight += hwloc_weight_long(set->ulongs[i]);
1185  	return weight;
1186  }
1187  int hwloc_bitmap_compare_inclusion(const struct hwloc_bitmap_s * set1, const struct hwloc_bitmap_s * set2)
1188  {
1189  	unsigned max_count = set1->ulongs_count > set2->ulongs_count ? set1->ulongs_count : set2->ulongs_count;
1190  	int result = HWLOC_BITMAP_EQUAL; &bsol;* means empty sets return equal */
1191  	int empty1 = 1;
1192  	int empty2 = 1;
1193  	unsigned i;
1194  	HWLOC__BITMAP_CHECK(set1);
1195  	HWLOC__BITMAP_CHECK(set2);
1196  	for(i=0; i<max_count; i++) {
1197  	  unsigned long val1 = HWLOC_SUBBITMAP_READULONG(set1, (unsigned) i);
1198  	  unsigned long val2 = HWLOC_SUBBITMAP_READULONG(set2, (unsigned) i);
1199  	  if (!val1) {
1200  	    if (!val2)
1201  	      continue;
1202  	    if (result == HWLOC_BITMAP_CONTAINS) {
1203  	      if (!empty2)
1204  		return HWLOC_BITMAP_INTERSECTS;
1205  	      result = HWLOC_BITMAP_DIFFERENT;
1206  	    } else if (result == HWLOC_BITMAP_EQUAL) {
1207  	      result = HWLOC_BITMAP_INCLUDED;
1208  	    }
1209  	  } else if (!val2) {
1210  	    if (result == HWLOC_BITMAP_INCLUDED) {
1211  	      if (!empty1)
1212  		return HWLOC_BITMAP_INTERSECTS;
1213  	      result = HWLOC_BITMAP_DIFFERENT;
1214  	    } else if (result == HWLOC_BITMAP_EQUAL) {
1215  	      result = HWLOC_BITMAP_CONTAINS;
1216  	    }
1217  	  } else if (val1 == val2) {
1218  	    if (result == HWLOC_BITMAP_DIFFERENT)
1219  	      return HWLOC_BITMAP_INTERSECTS;
1220  	  } else if ((val1 & val2) == val1) {
1221  	    if (result == HWLOC_BITMAP_CONTAINS || result == HWLOC_BITMAP_DIFFERENT)
1222  	      return HWLOC_BITMAP_INTERSECTS;
1223  	    result = HWLOC_BITMAP_INCLUDED;
1224  	  } else if ((val1 & val2) == val2) {
1225  	    if (result == HWLOC_BITMAP_INCLUDED || result == HWLOC_BITMAP_DIFFERENT)
1226  	      return HWLOC_BITMAP_INTERSECTS;
1227  	    result = HWLOC_BITMAP_CONTAINS;
1228  	  } else if ((val1 & val2) != 0) {
1229  	    return HWLOC_BITMAP_INTERSECTS;
1230  	  } else {
1231  	    if (result == HWLOC_BITMAP_EQUAL && !empty1 &bsol;* implies !empty2 */)
1232  	      return HWLOC_BITMAP_INTERSECTS;
1233  	    if (result == HWLOC_BITMAP_INCLUDED && !empty1)
1234  	      return HWLOC_BITMAP_INTERSECTS;
1235  	    if (result == HWLOC_BITMAP_CONTAINS && !empty2)
1236  	      return HWLOC_BITMAP_INTERSECTS;
1237  	    result = HWLOC_BITMAP_DIFFERENT;
1238  	  }
1239  	  empty1 &= !val1;
1240  	  empty2 &= !val2;
1241  	}
1242  	if (!set1->infinite) {
1243  	  if (set2->infinite) {
1244  	    if (result == HWLOC_BITMAP_CONTAINS) {
1245  	      if (!empty2)
1246  		return HWLOC_BITMAP_INTERSECTS;
1247  	      result = HWLOC_BITMAP_DIFFERENT;
1248  	    } else if (result == HWLOC_BITMAP_EQUAL) {
1249  	      result = HWLOC_BITMAP_INCLUDED;
1250  	    }
1251  	  }
1252  	} else if (!set2->infinite) {
1253  	  if (result == HWLOC_BITMAP_INCLUDED) {
1254  	    if (!empty1)
1255  	      return HWLOC_BITMAP_INTERSECTS;
1256  	    result = HWLOC_BITMAP_DIFFERENT;
1257  	  } else if (result == HWLOC_BITMAP_EQUAL) {
1258  	    result = HWLOC_BITMAP_CONTAINS;
1259  	  }
1260  	} else {
1261  	  if (result == HWLOC_BITMAP_DIFFERENT)
1262  	    return HWLOC_BITMAP_INTERSECTS;
1263  	}
1264  	return result;
1265  }
</code></pre>
        </div>
        <div class="column">
            <h3>libpcap-MDEwOlJlcG9zaXRvcnk5NDM1ODg3-flat-sf-pcap.c</h3>
            <pre><code>1  #ifdef HAVE_CONFIG_H
2  #include <config.h>
3  #endif
4  #include <pcap-types.h>
5  #ifdef _WIN32
6  #include <io.h>
7  #include <fcntl.h>
8  #endif &bsol;* _WIN32 */
9  #include <errno.h>
10  #include <memory.h>
11  #include <stdio.h>
12  #include <stdlib.h>
13  #include <string.h>
14  #include <limits.h> &bsol;* for INT_MAX */
15  #include "pcap-int.h"
16  #include "pcap-util.h"
17  #include "pcap-common.h"
18  #ifdef HAVE_OS_PROTO_H
19  #include "os-proto.h"
20  #endif
21  #include "sf-pcap.h"
22  #if defined(_WIN32)
23    #define SET_BINMODE(f)  _setmode(_fileno(f), _O_BINARY)
24  #elif defined(MSDOS)
25    #if defined(__HIGHC__)
26    #define SET_BINMODE(f)  setmode(f, O_BINARY)
27    #else
28    #define SET_BINMODE(f)  setmode(fileno(f), O_BINARY)
29    #endif
30  #endif
31  #define TCPDUMP_MAGIC		0xa1b2c3d4
32  #define KUZNETZOV_TCPDUMP_MAGIC	0xa1b2cd34
33  #define FMESQUITA_TCPDUMP_MAGIC	0xa1b234cd
34  #define NAVTEL_TCPDUMP_MAGIC	0xa12b3c4d
35  #define NSEC_TCPDUMP_MAGIC	0xa1b23c4d
36  #define CBPF_SAVEFILE_MAGIC	0xa1b2c3cb
37  static int pcap_next_packet(pcap_t *p, struct pcap_pkthdr *hdr, u_char **datap);
38  #ifdef _WIN32
39  static pcap_dumper_t *pcap_dump_fopen(pcap_t *p, FILE *f);
40  #endif &bsol;* _WIN32 */
41  typedef enum {
42  	NOT_SWAPPED,
43  	SWAPPED,
44  	MAYBE_SWAPPED
45  } swapped_type_t;
46  typedef enum {
47  	PASS_THROUGH,
48  	SCALE_UP,
49  	SCALE_DOWN
50  } tstamp_scale_type_t;
51  struct pcap_sf {
52  	size_t hdrsize;
53  	swapped_type_t lengths_swapped;
54  	tstamp_scale_type_t scale_type;
55  };
56  pcap_t *
57  pcap_check_header(const uint8_t *magic, FILE *fp, u_int precision, char *errbuf,
58  		  int *err)
59  {
60  	bpf_u_int32 magic_int;
61  	struct pcap_file_header hdr;
62  	size_t amt_read;
63  	pcap_t *p;
64  	int swapped = 0;
65  	struct pcap_sf *ps;
66  	*err = 0;
67  	memcpy(&magic_int, magic, sizeof(magic_int));
68  	if (magic_int != TCPDUMP_MAGIC &&
69  	    magic_int != KUZNETZOV_TCPDUMP_MAGIC &&
70  	    magic_int != NSEC_TCPDUMP_MAGIC) {
71  		magic_int = SWAPLONG(magic_int);
72  		if (magic_int != TCPDUMP_MAGIC &&
73  		    magic_int != KUZNETZOV_TCPDUMP_MAGIC &&
74  		    magic_int != NSEC_TCPDUMP_MAGIC)
75  			return (NULL);	&bsol;* nope */
76  		swapped = 1;
77  	}
78  	hdr.magic = magic_int;
79  	amt_read = fread(((char *)&hdr) + sizeof hdr.magic, 1,
80  	    sizeof(hdr) - sizeof(hdr.magic), fp);
81  	if (amt_read != sizeof(hdr) - sizeof(hdr.magic)) {
82  		if (ferror(fp)) {
83  			pcap_fmt_errmsg_for_errno(errbuf, PCAP_ERRBUF_SIZE,
84  			    errno, "error reading dump file");
85  		} else {
86  			snprintf(errbuf, PCAP_ERRBUF_SIZE,
87  			    "truncated dump file; tried to read %zu file header bytes, only got %zu",
88  			    sizeof(hdr), amt_read);
89  		}
90  		*err = 1;
91  		return (NULL);
92  	}
93  	if (swapped) {
94  		hdr.version_major = SWAPSHORT(hdr.version_major);
95  		hdr.version_minor = SWAPSHORT(hdr.version_minor);
96  		hdr.thiszone = SWAPLONG(hdr.thiszone);
97  		hdr.sigfigs = SWAPLONG(hdr.sigfigs);
98  		hdr.snaplen = SWAPLONG(hdr.snaplen);
99  		hdr.linktype = SWAPLONG(hdr.linktype);
100  	}
101  	if (hdr.version_major < PCAP_VERSION_MAJOR) {
102  		snprintf(errbuf, PCAP_ERRBUF_SIZE,
103  		    "archaic pcap savefile format");
104  		*err = 1;
105  		return (NULL);
106  	}
107  	if (! ((hdr.version_major == PCAP_VERSION_MAJOR &&
108  		hdr.version_minor <= PCAP_VERSION_MINOR) ||
109  	       (hdr.version_major == 543 &&
110  		hdr.version_minor == 0))) {
111  		snprintf(errbuf, PCAP_ERRBUF_SIZE,
112  			 "unsupported pcap savefile version %u.%u",
113  			 hdr.version_major, hdr.version_minor);
114  		*err = 1;
115  		return NULL;
116  	}
117  	if (LT_RESERVED1(hdr.linktype) != 0) {
118  		snprintf(errbuf, PCAP_ERRBUF_SIZE,
119  			 "savefile linktype reserved field not zero (0x%08x)",
120  			 LT_RESERVED1(hdr.linktype));
121  		*err = 1;
122  		return NULL;
123  	}
124  	p = PCAP_OPEN_OFFLINE_COMMON(errbuf, struct pcap_sf);
125  	if (p == NULL) {
126  		*err = 1;
127  		return (NULL);
128  	}
129  	p->swapped = swapped;
130  	p->version_major = hdr.version_major;
131  	p->version_minor = hdr.version_minor;
132  	p->linktype = linktype_to_dlt(LT_LINKTYPE(hdr.linktype));
133  	p->linktype_ext = LT_LINKTYPE_EXT(hdr.linktype);
134  	p->snapshot = pcap_adjust_snapshot(p->linktype, hdr.snaplen);
135  	p->next_packet_op = pcap_next_packet;
136  	ps = p->priv;
137  	p->opt.tstamp_precision = precision;
138  	switch (precision) {
139  	case PCAP_TSTAMP_PRECISION_MICRO:
140  		if (magic_int == NSEC_TCPDUMP_MAGIC) {
141  			ps->scale_type = SCALE_DOWN;
142  		} else {
143  			ps->scale_type = PASS_THROUGH;
144  		}
145  		break;
146  	case PCAP_TSTAMP_PRECISION_NANO:
147  		if (magic_int == NSEC_TCPDUMP_MAGIC) {
148  			ps->scale_type = PASS_THROUGH;
149  		} else {
150  			ps->scale_type = SCALE_UP;
151  		}
152  		break;
153  	default:
154  		snprintf(errbuf, PCAP_ERRBUF_SIZE,
155  		    "unknown time stamp resolution %u", precision);
156  		free(p);
157  		*err = 1;
158  		return (NULL);
159  	}
160  	switch (hdr.version_major) {
161  	case 2:
162  		if (hdr.version_minor < 3)
163  			ps->lengths_swapped = SWAPPED;
164  		else if (hdr.version_minor == 3)
165  			ps->lengths_swapped = MAYBE_SWAPPED;
166  		else
167  			ps->lengths_swapped = NOT_SWAPPED;
168  		break;
169  	case 543:
170  		ps->lengths_swapped = SWAPPED;
171  		break;
172  	default:
173  		ps->lengths_swapped = NOT_SWAPPED;
174  		break;
175  	}
176  	if (magic_int == KUZNETZOV_TCPDUMP_MAGIC) {
177  		ps->hdrsize = sizeof(struct pcap_sf_patched_pkthdr);
178  		if (p->linktype == DLT_EN10MB) {
179  			if (p->snapshot <= INT_MAX - 14)
180  				p->snapshot += 14;
181  			else
182  				p->snapshot = INT_MAX;
183  		}
184  	} else
185  		ps->hdrsize = sizeof(struct pcap_sf_pkthdr);
186  	p->bufsize = p->snapshot;
187  	if (p->bufsize > 2048)
188  		p->bufsize = 2048;
189  	p->buffer = malloc(p->bufsize);
190  	if (p->buffer == NULL) {
191  		snprintf(errbuf, PCAP_ERRBUF_SIZE, "out of memory");
192  		free(p);
193  		*err = 1;
<span onclick='openModal()' class='match'>194  		return (NULL);
195  	}
196  	p->cleanup_op = pcap_sf_cleanup;
197  	return (p);
198  }
199  static int
200  grow_buffer(pcap_t *p, u_int bufsize)
</span>201  {
202  	void *bigger_buffer;
203  	bigger_buffer = realloc(p->buffer, bufsize);
204  	if (bigger_buffer == NULL) {
205  		snprintf(p->errbuf, PCAP_ERRBUF_SIZE, "out of memory");
206  		return (0);
207  	}
208  	p->buffer = bigger_buffer;
209  	p->bufsize = bufsize;
210  	return (1);
211  }
212  static int
213  pcap_next_packet(pcap_t *p, struct pcap_pkthdr *hdr, u_char **data)
214  {
215  	struct pcap_sf *ps = p->priv;
216  	struct pcap_sf_patched_pkthdr sf_hdr;
217  	FILE *fp = p->rfile;
218  	size_t amt_read;
219  	bpf_u_int32 t;
220  	amt_read = fread(&sf_hdr, 1, ps->hdrsize, fp);
221  	if (amt_read != ps->hdrsize) {
222  		if (ferror(fp)) {
223  			pcap_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,
224  			    errno, "error reading dump file");
225  			return (-1);
226  		} else {
227  			if (amt_read != 0) {
228  				snprintf(p->errbuf, PCAP_ERRBUF_SIZE,
229  				    "truncated dump file; tried to read %zu header bytes, only got %zu",
230  				    ps->hdrsize, amt_read);
231  				return (-1);
232  			}
233  			return (0);
234  		}
235  	}
236  	if (p->swapped) {
237  		hdr->caplen = SWAPLONG(sf_hdr.caplen);
238  		hdr->len = SWAPLONG(sf_hdr.len);
239  		hdr->ts.tv_sec = SWAPLONG(sf_hdr.ts.tv_sec);
240  		hdr->ts.tv_usec = SWAPLONG(sf_hdr.ts.tv_usec);
241  	} else {
242  		hdr->caplen = sf_hdr.caplen;
243  		hdr->len = sf_hdr.len;
244  		hdr->ts.tv_sec = sf_hdr.ts.tv_sec;
245  		hdr->ts.tv_usec = sf_hdr.ts.tv_usec;
246  	}
247  	switch (ps->scale_type) {
248  	case PASS_THROUGH:
249  		break;
250  	case SCALE_UP:
251  		hdr->ts.tv_usec = hdr->ts.tv_usec * 1000;
252  		break;
253  	case SCALE_DOWN:
254  		hdr->ts.tv_usec = hdr->ts.tv_usec / 1000;
255  		break;
256  	}
257  	switch (ps->lengths_swapped) {
258  	case NOT_SWAPPED:
259  		break;
260  	case MAYBE_SWAPPED:
261  		if (hdr->caplen <= hdr->len) {
262  			break;
263  		}
264  	case SWAPPED:
265  		t = hdr->caplen;
266  		hdr->caplen = hdr->len;
267  		hdr->len = t;
268  		break;
269  	}
270  	if (hdr->caplen > max_snaplen_for_dlt(p->linktype)) {
271  		if (hdr->caplen > (bpf_u_int32)p->snapshot) {
272  			snprintf(p->errbuf, PCAP_ERRBUF_SIZE,
273  			    "invalid packet capture length %u, bigger than "
274  			    "snaplen of %d", hdr->caplen, p->snapshot);
275  		} else {
276  			snprintf(p->errbuf, PCAP_ERRBUF_SIZE,
277  			    "invalid packet capture length %u, bigger than "
278  			    "maximum of %u", hdr->caplen,
279  			    max_snaplen_for_dlt(p->linktype));
280  		}
281  		return (-1);
282  	}
283  	if (hdr->caplen > (bpf_u_int32)p->snapshot) {
284  		size_t bytes_to_discard;
285  		size_t bytes_to_read, bytes_read;
286  		char discard_buf[4096];
287  		if (hdr->caplen > p->bufsize) {
288  			if (!grow_buffer(p, p->snapshot))
289  				return (-1);
290  		}
291  		amt_read = fread(p->buffer, 1, p->snapshot, fp);
292  		if (amt_read != (bpf_u_int32)p->snapshot) {
293  			if (ferror(fp)) {
294  				pcap_fmt_errmsg_for_errno(p->errbuf,
295  				     PCAP_ERRBUF_SIZE, errno,
296  				    "error reading dump file");
297  			} else {
298  				snprintf(p->errbuf, PCAP_ERRBUF_SIZE,
299  				    "truncated dump file; tried to read %d captured bytes, only got %zu",
300  				    p->snapshot, amt_read);
301  			}
302  			return (-1);
303  		}
304  		bytes_to_discard = hdr->caplen - p->snapshot;
305  		bytes_read = amt_read;
306  		while (bytes_to_discard != 0) {
307  			bytes_to_read = bytes_to_discard;
308  			if (bytes_to_read > sizeof (discard_buf))
309  				bytes_to_read = sizeof (discard_buf);
310  			amt_read = fread(discard_buf, 1, bytes_to_read, fp);
311  			bytes_read += amt_read;
312  			if (amt_read != bytes_to_read) {
313  				if (ferror(fp)) {
314  					pcap_fmt_errmsg_for_errno(p->errbuf,
315  					    PCAP_ERRBUF_SIZE, errno,
316  					    "error reading dump file");
317  				} else {
318  					snprintf(p->errbuf, PCAP_ERRBUF_SIZE,
319  					    "truncated dump file; tried to read %u captured bytes, only got %zu",
320  					    hdr->caplen, bytes_read);
321  				}
322  				return (-1);
323  			}
324  			bytes_to_discard -= amt_read;
325  		}
326  		hdr->caplen = p->snapshot;
327  	} else {
328  		if (hdr->caplen > p->bufsize) {
329  			u_int new_bufsize;
330  			new_bufsize = hdr->caplen;
331  			new_bufsize--;
332  			new_bufsize |= new_bufsize >> 1;
333  			new_bufsize |= new_bufsize >> 2;
334  			new_bufsize |= new_bufsize >> 4;
335  			new_bufsize |= new_bufsize >> 8;
336  			new_bufsize |= new_bufsize >> 16;
337  			new_bufsize++;
338  			if (new_bufsize > (u_int)p->snapshot)
339  				new_bufsize = p->snapshot;
340  			if (!grow_buffer(p, new_bufsize))
341  				return (-1);
342  		}
343  		amt_read = fread(p->buffer, 1, hdr->caplen, fp);
344  		if (amt_read != hdr->caplen) {
345  			if (ferror(fp)) {
346  				pcap_fmt_errmsg_for_errno(p->errbuf,
347  				    PCAP_ERRBUF_SIZE, errno,
348  				    "error reading dump file");
349  			} else {
350  				snprintf(p->errbuf, PCAP_ERRBUF_SIZE,
351  				    "truncated dump file; tried to read %u captured bytes, only got %zu",
352  				    hdr->caplen, amt_read);
353  			}
354  			return (-1);
355  		}
356  	}
357  	*data = p->buffer;
358  	pcap_post_process(p->linktype, p->swapped, hdr, *data);
359  	return (1);
360  }
361  static int
362  sf_write_header(pcap_t *p, FILE *fp, int linktype, int snaplen)
363  {
364  	struct pcap_file_header hdr;
365  	hdr.magic = p->opt.tstamp_precision == PCAP_TSTAMP_PRECISION_NANO ? NSEC_TCPDUMP_MAGIC : TCPDUMP_MAGIC;
366  	hdr.version_major = PCAP_VERSION_MAJOR;
367  	hdr.version_minor = PCAP_VERSION_MINOR;
368  	hdr.thiszone = 0;
369  	hdr.sigfigs = 0;
370  	hdr.snaplen = snaplen;
371  	hdr.linktype = linktype;
372  	if (fwrite((char *)&hdr, sizeof(hdr), 1, fp) != 1)
373  		return (-1);
374  	return (0);
375  }
376  void
377  pcap_dump(u_char *user, const struct pcap_pkthdr *h, const u_char *sp)
378  {
379  	register FILE *f;
380  	struct pcap_sf_pkthdr sf_hdr;
381  	f = (FILE *)user;
382  	if (ferror(f))
383  		return;
384  	sf_hdr.ts.tv_sec  = (bpf_int32)h->ts.tv_sec;
385  	sf_hdr.ts.tv_usec = (bpf_int32)h->ts.tv_usec;
386  	sf_hdr.caplen     = h->caplen;
387  	sf_hdr.len        = h->len;
388  	if (fwrite(&sf_hdr, sizeof(sf_hdr), 1, f) == 1) {
389  		(void)fwrite(sp, h->caplen, 1, f);
390  	}
391  }
392  static pcap_dumper_t *
393  pcap_setup_dump(pcap_t *p, int linktype, FILE *f, const char *fname)
394  {
395  #if defined(_WIN32) || defined(MSDOS)
396  	if (f == stdout)
397  		SET_BINMODE(f);
398  	else
399  		setvbuf(f, NULL, _IONBF, 0);
400  #endif
401  	if (sf_write_header(p, f, linktype, p->snapshot) == -1) {
402  		pcap_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,
403  		    errno, "Can't write to %s", fname);
404  		if (f != stdout)
405  			(void)fclose(f);
406  		return (NULL);
407  	}
408  	return ((pcap_dumper_t *)f);
409  }
410  pcap_dumper_t *
411  pcap_dump_open(pcap_t *p, const char *fname)
412  {
413  	FILE *f;
414  	int linktype;
415  	if (!p->activated) {
416  		snprintf(p->errbuf, PCAP_ERRBUF_SIZE,
417  		    "%s: not-yet-activated pcap_t passed to pcap_dump_open",
418  		    fname);
419  		return (NULL);
420  	}
421  	linktype = dlt_to_linktype(p->linktype);
422  	if (linktype == -1) {
423  		snprintf(p->errbuf, PCAP_ERRBUF_SIZE,
424  		    "%s: link-layer type %d isn't supported in savefiles",
425  		    fname, p->linktype);
426  		return (NULL);
427  	}
428  	linktype |= p->linktype_ext;
429  	if (fname == NULL) {
430  		snprintf(p->errbuf, PCAP_ERRBUF_SIZE,
431  		    "A null pointer was supplied as the file name");
432  		return NULL;
433  	}
434  	if (fname[0] == '-' && fname[1] == '\0') {
435  		f = stdout;
436  		fname = "standard output";
437  	} else {
438  		f = pcap_charset_fopen(fname, "wb");
439  		if (f == NULL) {
440  			pcap_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,
441  			    errno, "%s", fname);
442  			return (NULL);
443  		}
444  	}
445  	return (pcap_setup_dump(p, linktype, f, fname));
446  }
447  #ifdef _WIN32
448  pcap_dumper_t *
449  pcap_dump_hopen(pcap_t *p, intptr_t osfd)
450  {
451  	int fd;
452  	FILE *file;
453  	fd = _open_osfhandle(osfd, _O_APPEND);
454  	if (fd < 0) {
455  		pcap_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,
456  		    errno, "_open_osfhandle");
457  		return NULL;
458  	}
459  	file = _fdopen(fd, "wb");
460  	if (file == NULL) {
461  		pcap_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,
462  		    errno, "_fdopen");
463  		_close(fd);
464  		return NULL;
465  	}
466  	return pcap_dump_fopen(p, file);
467  }
468  #endif &bsol;* _WIN32 */
469  #ifdef _WIN32
470  static
471  #endif &bsol;* _WIN32 */
472  pcap_dumper_t *
473  pcap_dump_fopen(pcap_t *p, FILE *f)
474  {
475  	int linktype;
476  	linktype = dlt_to_linktype(p->linktype);
477  	if (linktype == -1) {
478  		snprintf(p->errbuf, PCAP_ERRBUF_SIZE,
479  		    "stream: link-layer type %d isn't supported in savefiles",
480  		    p->linktype);
481  		return (NULL);
482  	}
483  	linktype |= p->linktype_ext;
484  	return (pcap_setup_dump(p, linktype, f, "stream"));
485  }
486  pcap_dumper_t *
487  pcap_dump_open_append(pcap_t *p, const char *fname)
488  {
489  	FILE *f;
490  	int linktype;
491  	size_t amt_read;
492  	struct pcap_file_header ph;
493  	linktype = dlt_to_linktype(p->linktype);
494  	if (linktype == -1) {
495  		snprintf(p->errbuf, PCAP_ERRBUF_SIZE,
496  		    "%s: link-layer type %d isn't supported in savefiles",
497  		    fname, linktype);
498  		return (NULL);
499  	}
500  	if (fname == NULL) {
501  		snprintf(p->errbuf, PCAP_ERRBUF_SIZE,
502  		    "A null pointer was supplied as the file name");
503  		return NULL;
504  	}
505  	if (fname[0] == '-' && fname[1] == '\0')
506  		return (pcap_setup_dump(p, linktype, stdout, "standard output"));
507  	f = pcap_charset_fopen(fname, "ab+");
508  	if (f == NULL) {
509  		pcap_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,
510  		    errno, "%s", fname);
511  		return (NULL);
512  	}
513  	if (fseek(f, 0, SEEK_SET) == -1) {
514  		pcap_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,
515  		    errno, "Can't seek to the beginning of %s", fname);
516  		(void)fclose(f);
517  		return (NULL);
518  	}
519  	amt_read = fread(&ph, 1, sizeof (ph), f);
520  	if (amt_read != sizeof (ph)) {
521  		if (ferror(f)) {
522  			pcap_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,
523  			    errno, "%s", fname);
524  			(void)fclose(f);
525  			return (NULL);
526  		} else if (feof(f) && amt_read > 0) {
527  			snprintf(p->errbuf, PCAP_ERRBUF_SIZE,
528  			    "%s: truncated pcap file header", fname);
529  			(void)fclose(f);
530  			return (NULL);
531  		}
532  	}
533  #if defined(_WIN32) || defined(MSDOS)
534  	setvbuf(f, NULL, _IONBF, 0);
535  #endif
536  	if (amt_read > 0) {
537  		switch (ph.magic) {
538  		case TCPDUMP_MAGIC:
539  			if (p->opt.tstamp_precision != PCAP_TSTAMP_PRECISION_MICRO) {
540  				snprintf(p->errbuf, PCAP_ERRBUF_SIZE,
541  				    "%s: different time stamp precision, cannot append to file", fname);
542  				(void)fclose(f);
543  				return (NULL);
544  			}
545  			break;
546  		case NSEC_TCPDUMP_MAGIC:
547  			if (p->opt.tstamp_precision != PCAP_TSTAMP_PRECISION_NANO) {
548  				snprintf(p->errbuf, PCAP_ERRBUF_SIZE,
549  				    "%s: different time stamp precision, cannot append to file", fname);
550  				(void)fclose(f);
551  				return (NULL);
552  			}
553  			break;
554  		case SWAPLONG(TCPDUMP_MAGIC):
555  		case SWAPLONG(NSEC_TCPDUMP_MAGIC):
556  			snprintf(p->errbuf, PCAP_ERRBUF_SIZE,
557  			    "%s: different byte order, cannot append to file", fname);
558  			(void)fclose(f);
559  			return (NULL);
560  		case KUZNETZOV_TCPDUMP_MAGIC:
561  		case SWAPLONG(KUZNETZOV_TCPDUMP_MAGIC):
562  		case NAVTEL_TCPDUMP_MAGIC:
563  		case SWAPLONG(NAVTEL_TCPDUMP_MAGIC):
564  			snprintf(p->errbuf, PCAP_ERRBUF_SIZE,
565  			    "%s: not a pcap file to which we can append", fname);
566  			(void)fclose(f);
567  			return (NULL);
568  		default:
569  			snprintf(p->errbuf, PCAP_ERRBUF_SIZE,
570  			    "%s: not a pcap file", fname);
571  			(void)fclose(f);
572  			return (NULL);
573  		}
574  		if (ph.version_major != PCAP_VERSION_MAJOR ||
575  		    ph.version_minor != PCAP_VERSION_MINOR) {
576  			snprintf(p->errbuf, PCAP_ERRBUF_SIZE,
577  			    "%s: version is %u.%u, cannot append to file", fname,
578  			    ph.version_major, ph.version_minor);
579  			(void)fclose(f);
580  			return (NULL);
581  		}
582  		if ((bpf_u_int32)linktype != ph.linktype) {
583  			snprintf(p->errbuf, PCAP_ERRBUF_SIZE,
584  			    "%s: different linktype, cannot append to file", fname);
585  			(void)fclose(f);
586  			return (NULL);
587  		}
588  		if ((bpf_u_int32)p->snapshot != ph.snaplen) {
589  			snprintf(p->errbuf, PCAP_ERRBUF_SIZE,
590  			    "%s: different snaplen, cannot append to file", fname);
591  			(void)fclose(f);
592  			return (NULL);
593  		}
594  	} else {
595  		if (sf_write_header(p, f, linktype, p->snapshot) == -1) {
596  			pcap_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,
597  			    errno, "Can't write to %s", fname);
598  			(void)fclose(f);
599  			return (NULL);
600  		}
601  	}
602  	if (fseek(f, 0, SEEK_END) == -1) {
603  		pcap_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,
604  		    errno, "Can't seek to the end of %s", fname);
605  		(void)fclose(f);
606  		return (NULL);
607  	}
608  	return ((pcap_dumper_t *)f);
609  }
610  FILE *
611  pcap_dump_file(pcap_dumper_t *p)
612  {
613  	return ((FILE *)p);
614  }
615  long
616  pcap_dump_ftell(pcap_dumper_t *p)
617  {
618  	return (ftell((FILE *)p));
619  }
620  #if defined(HAVE_FSEEKO)
621  int64_t
622  pcap_dump_ftell64(pcap_dumper_t *p)
623  {
624  	return (ftello((FILE *)p));
625  }
626  #elif defined(_MSC_VER)
627  int64_t
628  pcap_dump_ftell64(pcap_dumper_t *p)
629  {
630  	return (_ftelli64((FILE *)p));
631  }
632  #else
633  int64_t
634  pcap_dump_ftell64(pcap_dumper_t *p)
635  {
636  	return (ftell((FILE *)p));
637  }
638  #endif
639  int
640  pcap_dump_flush(pcap_dumper_t *p)
641  {
642  	if (fflush((FILE *)p) == EOF)
643  		return (-1);
644  	else
645  		return (0);
646  }
647  void
648  pcap_dump_close(pcap_dumper_t *p)
649  {
650  #ifdef notyet
651  	if (ferror((FILE *)p))
652  		return-an-error;
653  #endif
654  	(void)fclose((FILE *)p);
655  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from xmrig-MDEwOlJlcG9zaXRvcnk4ODMyNzQwNg==-flat-bitmap.c</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from libpcap-MDEwOlJlcG9zaXRvcnk5NDM1ODg3-flat-sf-pcap.c</div>
                </div>
                <div class="column column_space"><pre><code>123      return -1;
124    set->ulongs_count = needed_count;
125    return 0;
126  }
127  #define hwloc_bitmap_reset_by_cpu_index(set, cpu) hwloc_bitmap_reset_by_ulongs(set, ((cpu)/HWLOC_BITS_PER_LONG)+1)
128  struct hwloc_bitmap_s * hwloc_bitmap_tma_dup(struct hwloc_tma *tma, const struct hwloc_bitmap_s * old)
</pre></code></div>
                <div class="column column_space"><pre><code>194  		return (NULL);
195  	}
196  	p->cleanup_op = pcap_sf_cleanup;
197  	return (p);
198  }
199  static int
200  grow_buffer(pcap_t *p, u_int bufsize)
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    