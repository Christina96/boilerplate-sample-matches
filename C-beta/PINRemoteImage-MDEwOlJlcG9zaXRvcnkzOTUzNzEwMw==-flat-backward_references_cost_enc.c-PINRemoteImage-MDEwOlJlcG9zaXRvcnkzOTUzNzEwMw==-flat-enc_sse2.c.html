
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 9.318028359216745%, Tokens: 9, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>PINRemoteImage-MDEwOlJlcG9zaXRvcnkzOTUzNzEwMw==-flat-backward_references_cost_enc.c</h3>
            <pre><code>1  #include <assert.h>
2  #include "src/enc/backward_references_enc.h"
3  #include "src/enc/histogram_enc.h"
4  #include "src/dsp/lossless_common.h"
5  #include "src/utils/color_cache_utils.h"
6  #include "src/utils/utils.h"
7  #define VALUES_IN_BYTE 256
8  extern void VP8LClearBackwardRefs(VP8LBackwardRefs* const refs);
9  extern int VP8LDistanceToPlaneCode(int xsize, int dist);
10  extern void VP8LBackwardRefsCursorAdd(VP8LBackwardRefs* const refs,
11                                        const PixOrCopy v);
12  typedef struct {
13    double alpha_[VALUES_IN_BYTE];
14    double red_[VALUES_IN_BYTE];
15    double blue_[VALUES_IN_BYTE];
16    double distance_[NUM_DISTANCE_CODES];
17    double* literal_;
18  } CostModel;
19  static void ConvertPopulationCountTableToBitEstimates(
20      int num_symbols, const uint32_t population_counts[], double output[]) {
21    uint32_t sum = 0;
22    int nonzeros = 0;
23    int i;
24    for (i = 0; i < num_symbols; ++i) {
25      sum += population_counts[i];
26      if (population_counts[i] > 0) {
27        ++nonzeros;
28      }
29    }
30    if (nonzeros <= 1) {
31      memset(output, 0, num_symbols * sizeof(*output));
32    } else {
33      const double logsum = VP8LFastLog2(sum);
34      for (i = 0; i < num_symbols; ++i) {
35        output[i] = logsum - VP8LFastLog2(population_counts[i]);
36      }
<span onclick='openModal()' class='match'>37    }
38  }
39  static int CostModelBuild(CostModel* const m, int xsize, int cache_bits,
40                            const VP8LBackwardRefs* const refs) {
41    int ok = 0;
</span>42    VP8LRefsCursor c = VP8LRefsCursorInit(refs);
43    VP8LHistogram* const histo = VP8LAllocateHistogram(cache_bits);
44    if (histo == NULL) goto Error;
45    VP8LHistogramInit(histo, cache_bits, &bsol;*init_arrays=*/ 1);
46    while (VP8LRefsCursorOk(&c)) {
47      VP8LHistogramAddSinglePixOrCopy(histo, c.cur_pos, VP8LDistanceToPlaneCode,
48                                      xsize);
49      VP8LRefsCursorNext(&c);
50    }
51    ConvertPopulationCountTableToBitEstimates(
52        VP8LHistogramNumCodes(histo->palette_code_bits_),
53        histo->literal_, m->literal_);
54    ConvertPopulationCountTableToBitEstimates(
55        VALUES_IN_BYTE, histo->red_, m->red_);
56    ConvertPopulationCountTableToBitEstimates(
57        VALUES_IN_BYTE, histo->blue_, m->blue_);
58    ConvertPopulationCountTableToBitEstimates(
59        VALUES_IN_BYTE, histo->alpha_, m->alpha_);
60    ConvertPopulationCountTableToBitEstimates(
61        NUM_DISTANCE_CODES, histo->distance_, m->distance_);
62    ok = 1;
63   Error:
64    VP8LFreeHistogram(histo);
65    return ok;
66  }
67  static WEBP_INLINE double GetLiteralCost(const CostModel* const m, uint32_t v) {
68    return m->alpha_[v >> 24] +
69           m->red_[(v >> 16) & 0xff] +
70           m->literal_[(v >> 8) & 0xff] +
71           m->blue_[v & 0xff];
72  }
73  static WEBP_INLINE double GetCacheCost(const CostModel* const m, uint32_t idx) {
74    const int literal_idx = VALUES_IN_BYTE + NUM_LENGTH_CODES + idx;
75    return m->literal_[literal_idx];
76  }
77  static WEBP_INLINE double GetLengthCost(const CostModel* const m,
78                                          uint32_t length) {
79    int code, extra_bits;
80    VP8LPrefixEncodeBits(length, &code, &extra_bits);
81    return m->literal_[VALUES_IN_BYTE + code] + extra_bits;
82  }
83  static WEBP_INLINE double GetDistanceCost(const CostModel* const m,
84                                            uint32_t distance) {
85    int code, extra_bits;
86    VP8LPrefixEncodeBits(distance, &code, &extra_bits);
87    return m->distance_[code] + extra_bits;
88  }
89  static WEBP_INLINE void AddSingleLiteralWithCostModel(
90      const uint32_t* const argb, VP8LColorCache* const hashers,
91      const CostModel* const cost_model, int idx, int use_color_cache,
92      float prev_cost, float* const cost, uint16_t* const dist_array) {
93    double cost_val = prev_cost;
94    const uint32_t color = argb[idx];
95    const int ix = use_color_cache ? VP8LColorCacheContains(hashers, color) : -1;
96    if (ix >= 0) {
97      const double mul0 = 0.68;
98      cost_val += GetCacheCost(cost_model, ix) * mul0;
99    } else {
100      const double mul1 = 0.82;
101      if (use_color_cache) VP8LColorCacheInsert(hashers, color);
102      cost_val += GetLiteralCost(cost_model, color) * mul1;
103    }
104    if (cost[idx] > cost_val) {
105      cost[idx] = (float)cost_val;
106      dist_array[idx] = 1;  
107    }
108  }
109  #define COST_CACHE_INTERVAL_SIZE_MAX 500
110  typedef struct CostInterval CostInterval;
111  struct CostInterval {
112    float cost_;
113    int start_;
114    int end_;
115    int index_;
116    CostInterval* previous_;
117    CostInterval* next_;
118  };
119  typedef struct {
120    double cost_;
121    int start_;
122    int end_;       
123  } CostCacheInterval;
124  #define COST_MANAGER_MAX_FREE_LIST 10
125  typedef struct {
126    CostInterval* head_;
127    int count_;  
128    CostCacheInterval* cache_intervals_;
129    size_t cache_intervals_size_;
130    double cost_cache_[MAX_LENGTH];  
131    float* costs_;
132    uint16_t* dist_array_;
133    CostInterval intervals_[COST_MANAGER_MAX_FREE_LIST];
134    CostInterval* free_intervals_;
135    CostInterval* recycled_intervals_;
136  } CostManager;
137  static void CostIntervalAddToFreeList(CostManager* const manager,
138                                        CostInterval* const interval) {
139    interval->next_ = manager->free_intervals_;
140    manager->free_intervals_ = interval;
141  }
142  static int CostIntervalIsInFreeList(const CostManager* const manager,
143                                      const CostInterval* const interval) {
144    return (interval >= &manager->intervals_[0] &&
145            interval <= &manager->intervals_[COST_MANAGER_MAX_FREE_LIST - 1]);
146  }
147  static void CostManagerInitFreeList(CostManager* const manager) {
148    int i;
149    manager->free_intervals_ = NULL;
150    for (i = 0; i < COST_MANAGER_MAX_FREE_LIST; ++i) {
151      CostIntervalAddToFreeList(manager, &manager->intervals_[i]);
152    }
153  }
154  static void DeleteIntervalList(CostManager* const manager,
155                                 const CostInterval* interval) {
156    while (interval != NULL) {
157      const CostInterval* const next = interval->next_;
158      if (!CostIntervalIsInFreeList(manager, interval)) {
159        WebPSafeFree((void*)interval);
160      }  
161      interval = next;
162    }
163  }
164  static void CostManagerClear(CostManager* const manager) {
165    if (manager == NULL) return;
166    WebPSafeFree(manager->costs_);
167    WebPSafeFree(manager->cache_intervals_);
168    DeleteIntervalList(manager, manager->head_);
169    manager->head_ = NULL;
170    DeleteIntervalList(manager, manager->recycled_intervals_);
171    manager->recycled_intervals_ = NULL;
172    memset(manager, 0, sizeof(*manager));
173    CostManagerInitFreeList(manager);
174  }
175  static int CostManagerInit(CostManager* const manager,
176                             uint16_t* const dist_array, int pix_count,
177                             const CostModel* const cost_model) {
178    int i;
179    const int cost_cache_size = (pix_count > MAX_LENGTH) ? MAX_LENGTH : pix_count;
180    manager->costs_ = NULL;
181    manager->cache_intervals_ = NULL;
182    manager->head_ = NULL;
183    manager->recycled_intervals_ = NULL;
184    manager->count_ = 0;
185    manager->dist_array_ = dist_array;
186    CostManagerInitFreeList(manager);
187    manager->cache_intervals_size_ = 1;
188    manager->cost_cache_[0] = GetLengthCost(cost_model, 0);
189    for (i = 1; i < cost_cache_size; ++i) {
190      manager->cost_cache_[i] = GetLengthCost(cost_model, i);
191      if (manager->cost_cache_[i] != manager->cost_cache_[i - 1]) {
192        ++manager->cache_intervals_size_;
193      }
194    }
195    assert(manager->cache_intervals_size_ <= MAX_LENGTH);
196    manager->cache_intervals_ = (CostCacheInterval*)WebPSafeMalloc(
197        manager->cache_intervals_size_, sizeof(*manager->cache_intervals_));
198    if (manager->cache_intervals_ == NULL) {
199      CostManagerClear(manager);
200      return 0;
201    }
202    {
203      CostCacheInterval* cur = manager->cache_intervals_;
204      cur->start_ = 0;
205      cur->end_ = 1;
206      cur->cost_ = manager->cost_cache_[0];
207      for (i = 1; i < cost_cache_size; ++i) {
208        const double cost_val = manager->cost_cache_[i];
209        if (cost_val != cur->cost_) {
210          ++cur;
211          cur->start_ = i;
212          cur->cost_ = cost_val;
213        }
214        cur->end_ = i + 1;
215      }
216    }
217    manager->costs_ = (float*)WebPSafeMalloc(pix_count, sizeof(*manager->costs_));
218    if (manager->costs_ == NULL) {
219      CostManagerClear(manager);
220      return 0;
221    }
222    for (i = 0; i < pix_count; ++i) manager->costs_[i] = 1e38f;
223    return 1;
224  }
225  static WEBP_INLINE void UpdateCost(CostManager* const manager, int i,
226                                     int position, float cost) {
227    const int k = i - position;
228    assert(k >= 0 && k < MAX_LENGTH);
229    if (manager->costs_[i] > cost) {
230      manager->costs_[i] = cost;
231      manager->dist_array_[i] = k + 1;
232    }
233  }
234  static WEBP_INLINE void UpdateCostPerInterval(CostManager* const manager,
235                                                int start, int end, int position,
236                                                float cost) {
237    int i;
238    for (i = start; i < end; ++i) UpdateCost(manager, i, position, cost);
239  }
240  static WEBP_INLINE void ConnectIntervals(CostManager* const manager,
241                                           CostInterval* const prev,
242                                           CostInterval* const next) {
243    if (prev != NULL) {
244      prev->next_ = next;
245    } else {
246      manager->head_ = next;
247    }
248    if (next != NULL) next->previous_ = prev;
249  }
250  static WEBP_INLINE void PopInterval(CostManager* const manager,
251                                      CostInterval* const interval) {
252    if (interval == NULL) return;
253    ConnectIntervals(manager, interval->previous_, interval->next_);
254    if (CostIntervalIsInFreeList(manager, interval)) {
255      CostIntervalAddToFreeList(manager, interval);
256    } else {  
257      interval->next_ = manager->recycled_intervals_;
258      manager->recycled_intervals_ = interval;
259    }
260    --manager->count_;
261    assert(manager->count_ >= 0);
262  }
263  static WEBP_INLINE void UpdateCostAtIndex(CostManager* const manager, int i,
264                                            int do_clean_intervals) {
265    CostInterval* current = manager->head_;
266    while (current != NULL && current->start_ <= i) {
267      CostInterval* const next = current->next_;
268      if (current->end_ <= i) {
269        if (do_clean_intervals) {
270          PopInterval(manager, current);
271        }
272      } else {
273        UpdateCost(manager, i, current->index_, current->cost_);
274      }
275      current = next;
276    }
277  }
278  static WEBP_INLINE void PositionOrphanInterval(CostManager* const manager,
279                                                 CostInterval* const current,
280                                                 CostInterval* previous) {
281    assert(current != NULL);
282    if (previous == NULL) previous = manager->head_;
283    while (previous != NULL && current->start_ < previous->start_) {
284      previous = previous->previous_;
285    }
286    while (previous != NULL && previous->next_ != NULL &&
287           previous->next_->start_ < current->start_) {
288      previous = previous->next_;
289    }
290    if (previous != NULL) {
291      ConnectIntervals(manager, current, previous->next_);
292    } else {
293      ConnectIntervals(manager, current, manager->head_);
294    }
295    ConnectIntervals(manager, previous, current);
296  }
297  static WEBP_INLINE void InsertInterval(CostManager* const manager,
298                                         CostInterval* const interval_in,
299                                         float cost, int position, int start,
300                                         int end) {
301    CostInterval* interval_new;
302    if (start >= end) return;
303    if (manager->count_ >= COST_CACHE_INTERVAL_SIZE_MAX) {
304      UpdateCostPerInterval(manager, start, end, position, cost);
305      return;
306    }
307    if (manager->free_intervals_ != NULL) {
308      interval_new = manager->free_intervals_;
309      manager->free_intervals_ = interval_new->next_;
310    } else if (manager->recycled_intervals_ != NULL) {
311      interval_new = manager->recycled_intervals_;
312      manager->recycled_intervals_ = interval_new->next_;
313    } else {  
314      interval_new = (CostInterval*)WebPSafeMalloc(1, sizeof(*interval_new));
315      if (interval_new == NULL) {
316        UpdateCostPerInterval(manager, start, end, position, cost);
317        return;
318      }
319    }
320    interval_new->cost_ = cost;
321    interval_new->index_ = position;
322    interval_new->start_ = start;
323    interval_new->end_ = end;
324    PositionOrphanInterval(manager, interval_new, interval_in);
325    ++manager->count_;
326  }
327  static WEBP_INLINE void PushInterval(CostManager* const manager,
328                                       double distance_cost, int position,
329                                       int len) {
330    size_t i;
331    CostInterval* interval = manager->head_;
332    CostInterval* interval_next;
333    const CostCacheInterval* const cost_cache_intervals =
334        manager->cache_intervals_;
335    const int kSkipDistance = 10;
336    if (len < kSkipDistance) {
337      int j;
338      for (j = position; j < position + len; ++j) {
339        const int k = j - position;
340        float cost_tmp;
341        assert(k >= 0 && k < MAX_LENGTH);
342        cost_tmp = (float)(distance_cost + manager->cost_cache_[k]);
343        if (manager->costs_[j] > cost_tmp) {
344          manager->costs_[j] = cost_tmp;
345          manager->dist_array_[j] = k + 1;
346        }
347      }
348      return;
349    }
350    for (i = 0; i < manager->cache_intervals_size_ &&
351                cost_cache_intervals[i].start_ < len;
352         ++i) {
353      int start = position + cost_cache_intervals[i].start_;
354      const int end = position + (cost_cache_intervals[i].end_ > len
355                                   ? len
356                                   : cost_cache_intervals[i].end_);
357      const float cost = (float)(distance_cost + cost_cache_intervals[i].cost_);
358      for (; interval != NULL && interval->start_ < end;
359           interval = interval_next) {
360        interval_next = interval->next_;
361        if (start >= interval->end_) continue;
362        if (cost >= interval->cost_) {
363          const int start_new = interval->end_;
364          InsertInterval(manager, interval, cost, position, start,
365                         interval->start_);
366          start = start_new;
367          if (start >= end) break;
368          continue;
369        }
370        if (start <= interval->start_) {
371          if (interval->end_ <= end) {
372            PopInterval(manager, interval);
373          } else {
374            interval->start_ = end;
375            break;
376          }
377        } else {
378          if (end < interval->end_) {
379            const int end_original = interval->end_;
380            interval->end_ = start;
381            InsertInterval(manager, interval, interval->cost_, interval->index_,
382                           end, end_original);
383            interval = interval->next_;
384            break;
385          } else {
386            interval->end_ = start;
387          }
388        }
389      }
390      InsertInterval(manager, interval, cost, position, start, end);
391    }
392  }
393  static int BackwardReferencesHashChainDistanceOnly(
394      int xsize, int ysize, const uint32_t* const argb, int cache_bits,
395      const VP8LHashChain* const hash_chain, const VP8LBackwardRefs* const refs,
396      uint16_t* const dist_array) {
397    int i;
398    int ok = 0;
399    int cc_init = 0;
400    const int pix_count = xsize * ysize;
401    const int use_color_cache = (cache_bits > 0);
402    const size_t literal_array_size =
403        sizeof(double) * (NUM_LITERAL_CODES + NUM_LENGTH_CODES +
404                          ((cache_bits > 0) ? (1 << cache_bits) : 0));
405    const size_t cost_model_size = sizeof(CostModel) + literal_array_size;
406    CostModel* const cost_model =
407        (CostModel*)WebPSafeCalloc(1ULL, cost_model_size);
408    VP8LColorCache hashers;
409    CostManager* cost_manager =
410        (CostManager*)WebPSafeMalloc(1ULL, sizeof(*cost_manager));
411    int offset_prev = -1, len_prev = -1;
412    double offset_cost = -1;
413    int first_offset_is_constant = -1;  
414    int reach = 0;
415    if (cost_model == NULL || cost_manager == NULL) goto Error;
416    cost_model->literal_ = (double*)(cost_model + 1);
417    if (use_color_cache) {
418      cc_init = VP8LColorCacheInit(&hashers, cache_bits);
419      if (!cc_init) goto Error;
420    }
421    if (!CostModelBuild(cost_model, xsize, cache_bits, refs)) {
422      goto Error;
423    }
424    if (!CostManagerInit(cost_manager, dist_array, pix_count, cost_model)) {
425      goto Error;
426    }
427    dist_array[0] = 0;
428    AddSingleLiteralWithCostModel(argb, &hashers, cost_model, 0, use_color_cache,
429                                  0.f, cost_manager->costs_, dist_array);
430    for (i = 1; i < pix_count; ++i) {
431      const float prev_cost = cost_manager->costs_[i - 1];
432      int offset, len;
433      VP8LHashChainFindCopy(hash_chain, i, &offset, &len);
434      AddSingleLiteralWithCostModel(argb, &hashers, cost_model, i,
435                                    use_color_cache, prev_cost,
436                                    cost_manager->costs_, dist_array);
437      if (len >= 2) {
438        if (offset != offset_prev) {
439          const int code = VP8LDistanceToPlaneCode(xsize, offset);
440          offset_cost = GetDistanceCost(cost_model, code);
441          first_offset_is_constant = 1;
442          PushInterval(cost_manager, prev_cost + offset_cost, i, len);
443        } else {
444          assert(offset_cost >= 0);
445          assert(len_prev >= 0);
446          assert(first_offset_is_constant == 0 || first_offset_is_constant == 1);
447          if (first_offset_is_constant) {
448            reach = i - 1 + len_prev - 1;
449            first_offset_is_constant = 0;
450          }
451          if (i + len - 1 > reach) {
452            int offset_j, len_j = 0;
453            int j;
454            assert(len == MAX_LENGTH || len == pix_count - i);
455            for (j = i; j <= reach; ++j) {
456              VP8LHashChainFindCopy(hash_chain, j + 1, &offset_j, &len_j);
457              if (offset_j != offset) {
458                VP8LHashChainFindCopy(hash_chain, j, &offset_j, &len_j);
459                break;
460              }
461            }
462            UpdateCostAtIndex(cost_manager, j - 1, 0);
463            UpdateCostAtIndex(cost_manager, j, 0);
464            PushInterval(cost_manager, cost_manager->costs_[j - 1] + offset_cost,
465                         j, len_j);
466            reach = j + len_j - 1;
467          }
468        }
469      }
470      UpdateCostAtIndex(cost_manager, i, 1);
471      offset_prev = offset;
472      len_prev = len;
473    }
474    ok = !refs->error_;
475  Error:
476    if (cc_init) VP8LColorCacheClear(&hashers);
477    CostManagerClear(cost_manager);
478    WebPSafeFree(cost_model);
479    WebPSafeFree(cost_manager);
480    return ok;
481  }
482  static void TraceBackwards(uint16_t* const dist_array,
483                             int dist_array_size,
484                             uint16_t** const chosen_path,
485                             int* const chosen_path_size) {
486    uint16_t* path = dist_array + dist_array_size;
487    uint16_t* cur = dist_array + dist_array_size - 1;
488    while (cur >= dist_array) {
489      const int k = *cur;
490      --path;
491      *path = k;
492      cur -= k;
493    }
494    *chosen_path = path;
495    *chosen_path_size = (int)(dist_array + dist_array_size - path);
496  }
497  static int BackwardReferencesHashChainFollowChosenPath(
498      const uint32_t* const argb, int cache_bits,
499      const uint16_t* const chosen_path, int chosen_path_size,
500      const VP8LHashChain* const hash_chain, VP8LBackwardRefs* const refs) {
501    const int use_color_cache = (cache_bits > 0);
502    int ix;
503    int i = 0;
504    int ok = 0;
505    int cc_init = 0;
506    VP8LColorCache hashers;
507    if (use_color_cache) {
508      cc_init = VP8LColorCacheInit(&hashers, cache_bits);
509      if (!cc_init) goto Error;
510    }
511    VP8LClearBackwardRefs(refs);
512    for (ix = 0; ix < chosen_path_size; ++ix) {
513      const int len = chosen_path[ix];
514      if (len != 1) {
515        int k;
516        const int offset = VP8LHashChainFindOffset(hash_chain, i);
517        VP8LBackwardRefsCursorAdd(refs, PixOrCopyCreateCopy(offset, len));
518        if (use_color_cache) {
519          for (k = 0; k < len; ++k) {
520            VP8LColorCacheInsert(&hashers, argb[i + k]);
521          }
522        }
523        i += len;
524      } else {
525        PixOrCopy v;
526        const int idx =
527            use_color_cache ? VP8LColorCacheContains(&hashers, argb[i]) : -1;
528        if (idx >= 0) {
529          v = PixOrCopyCreateCacheIdx(idx);
530        } else {
531          if (use_color_cache) VP8LColorCacheInsert(&hashers, argb[i]);
532          v = PixOrCopyCreateLiteral(argb[i]);
533        }
534        VP8LBackwardRefsCursorAdd(refs, v);
535        ++i;
536      }
537    }
538    ok = !refs->error_;
539   Error:
540    if (cc_init) VP8LColorCacheClear(&hashers);
541    return ok;
542  }
543  extern int VP8LBackwardReferencesTraceBackwards(
544      int xsize, int ysize, const uint32_t* const argb, int cache_bits,
545      const VP8LHashChain* const hash_chain,
546      const VP8LBackwardRefs* const refs_src, VP8LBackwardRefs* const refs_dst);
547  int VP8LBackwardReferencesTraceBackwards(int xsize, int ysize,
548                                           const uint32_t* const argb,
549                                           int cache_bits,
550                                           const VP8LHashChain* const hash_chain,
551                                           const VP8LBackwardRefs* const refs_src,
552                                           VP8LBackwardRefs* const refs_dst) {
553    int ok = 0;
554    const int dist_array_size = xsize * ysize;
555    uint16_t* chosen_path = NULL;
556    int chosen_path_size = 0;
557    uint16_t* dist_array =
558        (uint16_t*)WebPSafeMalloc(dist_array_size, sizeof(*dist_array));
559    if (dist_array == NULL) goto Error;
560    if (!BackwardReferencesHashChainDistanceOnly(
561            xsize, ysize, argb, cache_bits, hash_chain, refs_src, dist_array)) {
562      goto Error;
563    }
564    TraceBackwards(dist_array, dist_array_size, &chosen_path, &chosen_path_size);
565    if (!BackwardReferencesHashChainFollowChosenPath(
566            argb, cache_bits, chosen_path, chosen_path_size, hash_chain,
567            refs_dst)) {
568      goto Error;
569    }
570    ok = 1;
571   Error:
572    WebPSafeFree(dist_array);
573    return ok;
574  }
</code></pre>
        </div>
        <div class="column">
            <h3>PINRemoteImage-MDEwOlJlcG9zaXRvcnkzOTUzNzEwMw==-flat-enc_sse2.c</h3>
            <pre><code>1  #include "src/dsp/dsp.h"
2  #if defined(WEBP_USE_SSE2)
3  #include <assert.h>
4  #include <stdlib.h>  
5  #include <emmintrin.h>
6  #include "src/dsp/common_sse2.h"
7  #include "src/enc/cost_enc.h"
8  #include "src/enc/vp8i_enc.h"
9  static void ITransform_SSE2(const uint8_t* ref, const int16_t* in, uint8_t* dst,
10                              int do_two) {
11    const __m128i k1 = _mm_set1_epi16(20091);
12    const __m128i k2 = _mm_set1_epi16(-30068);
13    __m128i T0, T1, T2, T3;
14    __m128i in0, in1, in2, in3;
15    {
16      in0 = _mm_loadl_epi64((const __m128i*)&in[0]);
17      in1 = _mm_loadl_epi64((const __m128i*)&in[4]);
18      in2 = _mm_loadl_epi64((const __m128i*)&in[8]);
19      in3 = _mm_loadl_epi64((const __m128i*)&in[12]);
20      if (do_two) {
21        const __m128i inB0 = _mm_loadl_epi64((const __m128i*)&in[16]);
22        const __m128i inB1 = _mm_loadl_epi64((const __m128i*)&in[20]);
23        const __m128i inB2 = _mm_loadl_epi64((const __m128i*)&in[24]);
24        const __m128i inB3 = _mm_loadl_epi64((const __m128i*)&in[28]);
25        in0 = _mm_unpacklo_epi64(in0, inB0);
26        in1 = _mm_unpacklo_epi64(in1, inB1);
27        in2 = _mm_unpacklo_epi64(in2, inB2);
28        in3 = _mm_unpacklo_epi64(in3, inB3);
29      }
30    }
31    {
32      const __m128i a = _mm_add_epi16(in0, in2);
33      const __m128i b = _mm_sub_epi16(in0, in2);
34      const __m128i c1 = _mm_mulhi_epi16(in1, k2);
35      const __m128i c2 = _mm_mulhi_epi16(in3, k1);
36      const __m128i c3 = _mm_sub_epi16(in1, in3);
37      const __m128i c4 = _mm_sub_epi16(c1, c2);
38      const __m128i c = _mm_add_epi16(c3, c4);
39      const __m128i d1 = _mm_mulhi_epi16(in1, k1);
40      const __m128i d2 = _mm_mulhi_epi16(in3, k2);
41      const __m128i d3 = _mm_add_epi16(in1, in3);
42      const __m128i d4 = _mm_add_epi16(d1, d2);
43      const __m128i d = _mm_add_epi16(d3, d4);
44      const __m128i tmp0 = _mm_add_epi16(a, d);
45      const __m128i tmp1 = _mm_add_epi16(b, c);
46      const __m128i tmp2 = _mm_sub_epi16(b, c);
47      const __m128i tmp3 = _mm_sub_epi16(a, d);
48      VP8Transpose_2_4x4_16b(&tmp0, &tmp1, &tmp2, &tmp3, &T0, &T1, &T2, &T3);
49    }
50    {
51      const __m128i four = _mm_set1_epi16(4);
52      const __m128i dc = _mm_add_epi16(T0, four);
53      const __m128i a =  _mm_add_epi16(dc, T2);
54      const __m128i b =  _mm_sub_epi16(dc, T2);
55      const __m128i c1 = _mm_mulhi_epi16(T1, k2);
56      const __m128i c2 = _mm_mulhi_epi16(T3, k1);
57      const __m128i c3 = _mm_sub_epi16(T1, T3);
58      const __m128i c4 = _mm_sub_epi16(c1, c2);
59      const __m128i c = _mm_add_epi16(c3, c4);
60      const __m128i d1 = _mm_mulhi_epi16(T1, k1);
61      const __m128i d2 = _mm_mulhi_epi16(T3, k2);
62      const __m128i d3 = _mm_add_epi16(T1, T3);
63      const __m128i d4 = _mm_add_epi16(d1, d2);
64      const __m128i d = _mm_add_epi16(d3, d4);
65      const __m128i tmp0 = _mm_add_epi16(a, d);
66      const __m128i tmp1 = _mm_add_epi16(b, c);
67      const __m128i tmp2 = _mm_sub_epi16(b, c);
68      const __m128i tmp3 = _mm_sub_epi16(a, d);
69      const __m128i shifted0 = _mm_srai_epi16(tmp0, 3);
70      const __m128i shifted1 = _mm_srai_epi16(tmp1, 3);
71      const __m128i shifted2 = _mm_srai_epi16(tmp2, 3);
72      const __m128i shifted3 = _mm_srai_epi16(tmp3, 3);
73      VP8Transpose_2_4x4_16b(&shifted0, &shifted1, &shifted2, &shifted3, &T0, &T1,
74                             &T2, &T3);
75    }
76    {
77      const __m128i zero = _mm_setzero_si128();
78      __m128i ref0, ref1, ref2, ref3;
79      if (do_two) {
80        ref0 = _mm_loadl_epi64((const __m128i*)&ref[0 * BPS]);
81        ref1 = _mm_loadl_epi64((const __m128i*)&ref[1 * BPS]);
82        ref2 = _mm_loadl_epi64((const __m128i*)&ref[2 * BPS]);
83        ref3 = _mm_loadl_epi64((const __m128i*)&ref[3 * BPS]);
84      } else {
85        ref0 = _mm_cvtsi32_si128(WebPMemToUint32(&ref[0 * BPS]));
86        ref1 = _mm_cvtsi32_si128(WebPMemToUint32(&ref[1 * BPS]));
87        ref2 = _mm_cvtsi32_si128(WebPMemToUint32(&ref[2 * BPS]));
88        ref3 = _mm_cvtsi32_si128(WebPMemToUint32(&ref[3 * BPS]));
89      }
90      ref0 = _mm_unpacklo_epi8(ref0, zero);
91      ref1 = _mm_unpacklo_epi8(ref1, zero);
92      ref2 = _mm_unpacklo_epi8(ref2, zero);
93      ref3 = _mm_unpacklo_epi8(ref3, zero);
94      ref0 = _mm_add_epi16(ref0, T0);
95      ref1 = _mm_add_epi16(ref1, T1);
96      ref2 = _mm_add_epi16(ref2, T2);
97      ref3 = _mm_add_epi16(ref3, T3);
98      ref0 = _mm_packus_epi16(ref0, ref0);
99      ref1 = _mm_packus_epi16(ref1, ref1);
100      ref2 = _mm_packus_epi16(ref2, ref2);
101      ref3 = _mm_packus_epi16(ref3, ref3);
102      if (do_two) {
103        _mm_storel_epi64((__m128i*)&dst[0 * BPS], ref0);
104        _mm_storel_epi64((__m128i*)&dst[1 * BPS], ref1);
105        _mm_storel_epi64((__m128i*)&dst[2 * BPS], ref2);
106        _mm_storel_epi64((__m128i*)&dst[3 * BPS], ref3);
107      } else {
108        WebPUint32ToMem(&dst[0 * BPS], _mm_cvtsi128_si32(ref0));
109        WebPUint32ToMem(&dst[1 * BPS], _mm_cvtsi128_si32(ref1));
110        WebPUint32ToMem(&dst[2 * BPS], _mm_cvtsi128_si32(ref2));
111        WebPUint32ToMem(&dst[3 * BPS], _mm_cvtsi128_si32(ref3));
<span onclick='openModal()' class='match'>112      }
113    }
114  }
115  static void FTransformPass1_SSE2(const __m128i* const in01,
116                                   const __m128i* const in23,
117                                   __m128i* const out01,
118                                   __m128i* const out32) {
119    const __m128i k937 = _mm_set1_epi32(937);
</span>120    const __m128i k1812 = _mm_set1_epi32(1812);
121    const __m128i k88p = _mm_set_epi16(8, 8, 8, 8, 8, 8, 8, 8);
122    const __m128i k88m = _mm_set_epi16(-8, 8, -8, 8, -8, 8, -8, 8);
123    const __m128i k5352_2217p = _mm_set_epi16(2217, 5352, 2217, 5352,
124                                              2217, 5352, 2217, 5352);
125    const __m128i k5352_2217m = _mm_set_epi16(-5352, 2217, -5352, 2217,
126                                              -5352, 2217, -5352, 2217);
127    const __m128i shuf01_p = _mm_shufflehi_epi16(*in01, _MM_SHUFFLE(2, 3, 0, 1));
128    const __m128i shuf23_p = _mm_shufflehi_epi16(*in23, _MM_SHUFFLE(2, 3, 0, 1));
129    const __m128i s01 = _mm_unpacklo_epi64(shuf01_p, shuf23_p);
130    const __m128i s32 = _mm_unpackhi_epi64(shuf01_p, shuf23_p);
131    const __m128i a01 = _mm_add_epi16(s01, s32);
132    const __m128i a32 = _mm_sub_epi16(s01, s32);
133    const __m128i tmp0   = _mm_madd_epi16(a01, k88p);  
134    const __m128i tmp2   = _mm_madd_epi16(a01, k88m);  
135    const __m128i tmp1_1 = _mm_madd_epi16(a32, k5352_2217p);
136    const __m128i tmp3_1 = _mm_madd_epi16(a32, k5352_2217m);
137    const __m128i tmp1_2 = _mm_add_epi32(tmp1_1, k1812);
138    const __m128i tmp3_2 = _mm_add_epi32(tmp3_1, k937);
139    const __m128i tmp1   = _mm_srai_epi32(tmp1_2, 9);
140    const __m128i tmp3   = _mm_srai_epi32(tmp3_2, 9);
141    const __m128i s03    = _mm_packs_epi32(tmp0, tmp2);
142    const __m128i s12    = _mm_packs_epi32(tmp1, tmp3);
143    const __m128i s_lo   = _mm_unpacklo_epi16(s03, s12);   
144    const __m128i s_hi   = _mm_unpackhi_epi16(s03, s12);   
145    const __m128i v23    = _mm_unpackhi_epi32(s_lo, s_hi);
146    *out01 = _mm_unpacklo_epi32(s_lo, s_hi);
147    *out32 = _mm_shuffle_epi32(v23, _MM_SHUFFLE(1, 0, 3, 2));  
148  }
149  static void FTransformPass2_SSE2(const __m128i* const v01,
150                                   const __m128i* const v32,
151                                   int16_t* out) {
152    const __m128i zero = _mm_setzero_si128();
153    const __m128i seven = _mm_set1_epi16(7);
154    const __m128i k5352_2217 = _mm_set_epi16(5352,  2217, 5352,  2217,
155                                             5352,  2217, 5352,  2217);
156    const __m128i k2217_5352 = _mm_set_epi16(2217, -5352, 2217, -5352,
157                                             2217, -5352, 2217, -5352);
158    const __m128i k12000_plus_one = _mm_set1_epi32(12000 + (1 << 16));
159    const __m128i k51000 = _mm_set1_epi32(51000);
160    const __m128i a32 = _mm_sub_epi16(*v01, *v32);
161    const __m128i a22 = _mm_unpackhi_epi64(a32, a32);
162    const __m128i b23 = _mm_unpacklo_epi16(a22, a32);
163    const __m128i c1 = _mm_madd_epi16(b23, k5352_2217);
164    const __m128i c3 = _mm_madd_epi16(b23, k2217_5352);
165    const __m128i d1 = _mm_add_epi32(c1, k12000_plus_one);
166    const __m128i d3 = _mm_add_epi32(c3, k51000);
167    const __m128i e1 = _mm_srai_epi32(d1, 16);
168    const __m128i e3 = _mm_srai_epi32(d3, 16);
169    const __m128i f1 = _mm_packs_epi32(e1, e1);
170    const __m128i f3 = _mm_packs_epi32(e3, e3);
171    const __m128i g1 = _mm_add_epi16(f1, _mm_cmpeq_epi16(a32, zero));
172    const __m128i a01 = _mm_add_epi16(*v01, *v32);
173    const __m128i a01_plus_7 = _mm_add_epi16(a01, seven);
174    const __m128i a11 = _mm_unpackhi_epi64(a01, a01);
175    const __m128i c0 = _mm_add_epi16(a01_plus_7, a11);
176    const __m128i c2 = _mm_sub_epi16(a01_plus_7, a11);
177    const __m128i d0 = _mm_srai_epi16(c0, 4);
178    const __m128i d2 = _mm_srai_epi16(c2, 4);
179    const __m128i d0_g1 = _mm_unpacklo_epi64(d0, g1);
180    const __m128i d2_f3 = _mm_unpacklo_epi64(d2, f3);
181    _mm_storeu_si128((__m128i*)&out[0], d0_g1);
182    _mm_storeu_si128((__m128i*)&out[8], d2_f3);
183  }
184  static void FTransform_SSE2(const uint8_t* src, const uint8_t* ref,
185                              int16_t* out) {
186    const __m128i zero = _mm_setzero_si128();
187    const __m128i src0 = _mm_loadl_epi64((const __m128i*)&src[0 * BPS]);
188    const __m128i src1 = _mm_loadl_epi64((const __m128i*)&src[1 * BPS]);
189    const __m128i src2 = _mm_loadl_epi64((const __m128i*)&src[2 * BPS]);
190    const __m128i src3 = _mm_loadl_epi64((const __m128i*)&src[3 * BPS]);
191    const __m128i src_0 = _mm_unpacklo_epi16(src0, src1);
192    const __m128i src_1 = _mm_unpacklo_epi16(src2, src3);
193    const __m128i ref0 = _mm_loadl_epi64((const __m128i*)&ref[0 * BPS]);
194    const __m128i ref1 = _mm_loadl_epi64((const __m128i*)&ref[1 * BPS]);
195    const __m128i ref2 = _mm_loadl_epi64((const __m128i*)&ref[2 * BPS]);
196    const __m128i ref3 = _mm_loadl_epi64((const __m128i*)&ref[3 * BPS]);
197    const __m128i ref_0 = _mm_unpacklo_epi16(ref0, ref1);
198    const __m128i ref_1 = _mm_unpacklo_epi16(ref2, ref3);
199    const __m128i src_0_16b = _mm_unpacklo_epi8(src_0, zero);
200    const __m128i src_1_16b = _mm_unpacklo_epi8(src_1, zero);
201    const __m128i ref_0_16b = _mm_unpacklo_epi8(ref_0, zero);
202    const __m128i ref_1_16b = _mm_unpacklo_epi8(ref_1, zero);
203    const __m128i row01 = _mm_sub_epi16(src_0_16b, ref_0_16b);
204    const __m128i row23 = _mm_sub_epi16(src_1_16b, ref_1_16b);
205    __m128i v01, v32;
206    FTransformPass1_SSE2(&row01, &row23, &v01, &v32);
207    FTransformPass2_SSE2(&v01, &v32, out);
208  }
209  static void FTransform2_SSE2(const uint8_t* src, const uint8_t* ref,
210                               int16_t* out) {
211    const __m128i zero = _mm_setzero_si128();
212    const __m128i src0 = _mm_loadl_epi64((const __m128i*)&src[0 * BPS]);
213    const __m128i src1 = _mm_loadl_epi64((const __m128i*)&src[1 * BPS]);
214    const __m128i src2 = _mm_loadl_epi64((const __m128i*)&src[2 * BPS]);
215    const __m128i src3 = _mm_loadl_epi64((const __m128i*)&src[3 * BPS]);
216    const __m128i src_0 = _mm_unpacklo_epi8(src0, zero);
217    const __m128i src_1 = _mm_unpacklo_epi8(src1, zero);
218    const __m128i src_2 = _mm_unpacklo_epi8(src2, zero);
219    const __m128i src_3 = _mm_unpacklo_epi8(src3, zero);
220    const __m128i ref0 = _mm_loadl_epi64((const __m128i*)&ref[0 * BPS]);
221    const __m128i ref1 = _mm_loadl_epi64((const __m128i*)&ref[1 * BPS]);
222    const __m128i ref2 = _mm_loadl_epi64((const __m128i*)&ref[2 * BPS]);
223    const __m128i ref3 = _mm_loadl_epi64((const __m128i*)&ref[3 * BPS]);
224    const __m128i ref_0 = _mm_unpacklo_epi8(ref0, zero);
225    const __m128i ref_1 = _mm_unpacklo_epi8(ref1, zero);
226    const __m128i ref_2 = _mm_unpacklo_epi8(ref2, zero);
227    const __m128i ref_3 = _mm_unpacklo_epi8(ref3, zero);
228    const __m128i diff0 = _mm_sub_epi16(src_0, ref_0);
229    const __m128i diff1 = _mm_sub_epi16(src_1, ref_1);
230    const __m128i diff2 = _mm_sub_epi16(src_2, ref_2);
231    const __m128i diff3 = _mm_sub_epi16(src_3, ref_3);
232    const __m128i shuf01l = _mm_unpacklo_epi32(diff0, diff1);
233    const __m128i shuf23l = _mm_unpacklo_epi32(diff2, diff3);
234    const __m128i shuf01h = _mm_unpackhi_epi32(diff0, diff1);
235    const __m128i shuf23h = _mm_unpackhi_epi32(diff2, diff3);
236    __m128i v01l, v32l;
237    __m128i v01h, v32h;
238    FTransformPass1_SSE2(&shuf01l, &shuf23l, &v01l, &v32l);
239    FTransformPass1_SSE2(&shuf01h, &shuf23h, &v01h, &v32h);
240    FTransformPass2_SSE2(&v01l, &v32l, out + 0);
241    FTransformPass2_SSE2(&v01h, &v32h, out + 16);
242  }
243  static void FTransformWHTRow_SSE2(const int16_t* const in, __m128i* const out) {
244    const __m128i kMult = _mm_set_epi16(-1, 1, -1, 1, 1, 1, 1, 1);
245    const __m128i src0 = _mm_loadl_epi64((__m128i*)&in[0 * 16]);
246    const __m128i src1 = _mm_loadl_epi64((__m128i*)&in[1 * 16]);
247    const __m128i src2 = _mm_loadl_epi64((__m128i*)&in[2 * 16]);
248    const __m128i src3 = _mm_loadl_epi64((__m128i*)&in[3 * 16]);
249    const __m128i A01 = _mm_unpacklo_epi16(src0, src1);  
250    const __m128i A23 = _mm_unpacklo_epi16(src2, src3);  
251    const __m128i B0 = _mm_adds_epi16(A01, A23);    
252    const __m128i B1 = _mm_subs_epi16(A01, A23);    
253    const __m128i C0 = _mm_unpacklo_epi32(B0, B1);  
254    const __m128i C1 = _mm_unpacklo_epi32(B1, B0);  
255    const __m128i D = _mm_unpacklo_epi64(C0, C1);   
256    *out = _mm_madd_epi16(D, kMult);
257  }
258  static void FTransformWHT_SSE2(const int16_t* in, int16_t* out) {
259    __m128i row0, row1, row2, row3;
260    FTransformWHTRow_SSE2(in + 0 * 64, &row0);
261    FTransformWHTRow_SSE2(in + 1 * 64, &row1);
262    FTransformWHTRow_SSE2(in + 2 * 64, &row2);
263    FTransformWHTRow_SSE2(in + 3 * 64, &row3);
264    {
265      const __m128i a0 = _mm_add_epi32(row0, row2);
266      const __m128i a1 = _mm_add_epi32(row1, row3);
267      const __m128i a2 = _mm_sub_epi32(row1, row3);
268      const __m128i a3 = _mm_sub_epi32(row0, row2);
269      const __m128i a0a3 = _mm_packs_epi32(a0, a3);
270      const __m128i a1a2 = _mm_packs_epi32(a1, a2);
271      const __m128i b0b1 = _mm_add_epi16(a0a3, a1a2);
272      const __m128i b3b2 = _mm_sub_epi16(a0a3, a1a2);
273      const __m128i tmp_b2b3 = _mm_unpackhi_epi64(b3b2, b3b2);
274      const __m128i b2b3 = _mm_unpacklo_epi64(tmp_b2b3, b3b2);
275      _mm_storeu_si128((__m128i*)&out[0], _mm_srai_epi16(b0b1, 1));
276      _mm_storeu_si128((__m128i*)&out[8], _mm_srai_epi16(b2b3, 1));
277    }
278  }
279  static void CollectHistogram_SSE2(const uint8_t* ref, const uint8_t* pred,
280                                    int start_block, int end_block,
281                                    VP8Histogram* const histo) {
282    const __m128i zero = _mm_setzero_si128();
283    const __m128i max_coeff_thresh = _mm_set1_epi16(MAX_COEFF_THRESH);
284    int j;
285    int distribution[MAX_COEFF_THRESH + 1] = { 0 };
286    for (j = start_block; j < end_block; ++j) {
287      int16_t out[16];
288      int k;
289      FTransform_SSE2(ref + VP8DspScan[j], pred + VP8DspScan[j], out);
290      {
291        const __m128i out0 = _mm_loadu_si128((__m128i*)&out[0]);
292        const __m128i out1 = _mm_loadu_si128((__m128i*)&out[8]);
293        const __m128i d0 = _mm_sub_epi16(zero, out0);
294        const __m128i d1 = _mm_sub_epi16(zero, out1);
295        const __m128i abs0 = _mm_max_epi16(out0, d0);   
296        const __m128i abs1 = _mm_max_epi16(out1, d1);
297        const __m128i v0 = _mm_srai_epi16(abs0, 3);
298        const __m128i v1 = _mm_srai_epi16(abs1, 3);
299        const __m128i bin0 = _mm_min_epi16(v0, max_coeff_thresh);
300        const __m128i bin1 = _mm_min_epi16(v1, max_coeff_thresh);
301        _mm_storeu_si128((__m128i*)&out[0], bin0);
302        _mm_storeu_si128((__m128i*)&out[8], bin1);
303      }
304      for (k = 0; k < 16; ++k) {
305        ++distribution[out[k]];
306      }
307    }
308    VP8SetHistogramData(distribution, histo);
309  }
310  static WEBP_INLINE void Put8x8uv_SSE2(uint8_t v, uint8_t* dst) {
311    int j;
312    const __m128i values = _mm_set1_epi8(v);
313    for (j = 0; j < 8; ++j) {
314      _mm_storel_epi64((__m128i*)(dst + j * BPS), values);
315    }
316  }
317  static WEBP_INLINE void Put16_SSE2(uint8_t v, uint8_t* dst) {
318    int j;
319    const __m128i values = _mm_set1_epi8(v);
320    for (j = 0; j < 16; ++j) {
321      _mm_store_si128((__m128i*)(dst + j * BPS), values);
322    }
323  }
324  static WEBP_INLINE void Fill_SSE2(uint8_t* dst, int value, int size) {
325    if (size == 4) {
326      int j;
327      for (j = 0; j < 4; ++j) {
328        memset(dst + j * BPS, value, 4);
329      }
330    } else if (size == 8) {
331      Put8x8uv_SSE2(value, dst);
332    } else {
333      Put16_SSE2(value, dst);
334    }
335  }
336  static WEBP_INLINE void VE8uv_SSE2(uint8_t* dst, const uint8_t* top) {
337    int j;
338    const __m128i top_values = _mm_loadl_epi64((const __m128i*)top);
339    for (j = 0; j < 8; ++j) {
340      _mm_storel_epi64((__m128i*)(dst + j * BPS), top_values);
341    }
342  }
343  static WEBP_INLINE void VE16_SSE2(uint8_t* dst, const uint8_t* top) {
344    const __m128i top_values = _mm_load_si128((const __m128i*)top);
345    int j;
346    for (j = 0; j < 16; ++j) {
347      _mm_store_si128((__m128i*)(dst + j * BPS), top_values);
348    }
349  }
350  static WEBP_INLINE void VerticalPred_SSE2(uint8_t* dst,
351                                            const uint8_t* top, int size) {
352    if (top != NULL) {
353      if (size == 8) {
354        VE8uv_SSE2(dst, top);
355      } else {
356        VE16_SSE2(dst, top);
357      }
358    } else {
359      Fill_SSE2(dst, 127, size);
360    }
361  }
362  static WEBP_INLINE void HE8uv_SSE2(uint8_t* dst, const uint8_t* left) {
363    int j;
364    for (j = 0; j < 8; ++j) {
365      const __m128i values = _mm_set1_epi8(left[j]);
366      _mm_storel_epi64((__m128i*)dst, values);
367      dst += BPS;
368    }
369  }
370  static WEBP_INLINE void HE16_SSE2(uint8_t* dst, const uint8_t* left) {
371    int j;
372    for (j = 0; j < 16; ++j) {
373      const __m128i values = _mm_set1_epi8(left[j]);
374      _mm_store_si128((__m128i*)dst, values);
375      dst += BPS;
376    }
377  }
378  static WEBP_INLINE void HorizontalPred_SSE2(uint8_t* dst,
379                                              const uint8_t* left, int size) {
380    if (left != NULL) {
381      if (size == 8) {
382        HE8uv_SSE2(dst, left);
383      } else {
384        HE16_SSE2(dst, left);
385      }
386    } else {
387      Fill_SSE2(dst, 129, size);
388    }
389  }
390  static WEBP_INLINE void TM_SSE2(uint8_t* dst, const uint8_t* left,
391                                  const uint8_t* top, int size) {
392    const __m128i zero = _mm_setzero_si128();
393    int y;
394    if (size == 8) {
395      const __m128i top_values = _mm_loadl_epi64((const __m128i*)top);
396      const __m128i top_base = _mm_unpacklo_epi8(top_values, zero);
397      for (y = 0; y < 8; ++y, dst += BPS) {
398        const int val = left[y] - left[-1];
399        const __m128i base = _mm_set1_epi16(val);
400        const __m128i out = _mm_packus_epi16(_mm_add_epi16(base, top_base), zero);
401        _mm_storel_epi64((__m128i*)dst, out);
402      }
403    } else {
404      const __m128i top_values = _mm_load_si128((const __m128i*)top);
405      const __m128i top_base_0 = _mm_unpacklo_epi8(top_values, zero);
406      const __m128i top_base_1 = _mm_unpackhi_epi8(top_values, zero);
407      for (y = 0; y < 16; ++y, dst += BPS) {
408        const int val = left[y] - left[-1];
409        const __m128i base = _mm_set1_epi16(val);
410        const __m128i out_0 = _mm_add_epi16(base, top_base_0);
411        const __m128i out_1 = _mm_add_epi16(base, top_base_1);
412        const __m128i out = _mm_packus_epi16(out_0, out_1);
413        _mm_store_si128((__m128i*)dst, out);
414      }
415    }
416  }
417  static WEBP_INLINE void TrueMotion_SSE2(uint8_t* dst, const uint8_t* left,
418                                          const uint8_t* top, int size) {
419    if (left != NULL) {
420      if (top != NULL) {
421        TM_SSE2(dst, left, top, size);
422      } else {
423        HorizontalPred_SSE2(dst, left, size);
424      }
425    } else {
426      if (top != NULL) {
427        VerticalPred_SSE2(dst, top, size);
428      } else {
429        Fill_SSE2(dst, 129, size);
430      }
431    }
432  }
433  static WEBP_INLINE void DC8uv_SSE2(uint8_t* dst, const uint8_t* left,
434                                     const uint8_t* top) {
435    const __m128i top_values = _mm_loadl_epi64((const __m128i*)top);
436    const __m128i left_values = _mm_loadl_epi64((const __m128i*)left);
437    const __m128i combined = _mm_unpacklo_epi64(top_values, left_values);
438    const int DC = VP8HorizontalAdd8b(&combined) + 8;
439    Put8x8uv_SSE2(DC >> 4, dst);
440  }
441  static WEBP_INLINE void DC8uvNoLeft_SSE2(uint8_t* dst, const uint8_t* top) {
442    const __m128i zero = _mm_setzero_si128();
443    const __m128i top_values = _mm_loadl_epi64((const __m128i*)top);
444    const __m128i sum = _mm_sad_epu8(top_values, zero);
445    const int DC = _mm_cvtsi128_si32(sum) + 4;
446    Put8x8uv_SSE2(DC >> 3, dst);
447  }
448  static WEBP_INLINE void DC8uvNoTop_SSE2(uint8_t* dst, const uint8_t* left) {
449    DC8uvNoLeft_SSE2(dst, left);
450  }
451  static WEBP_INLINE void DC8uvNoTopLeft_SSE2(uint8_t* dst) {
452    Put8x8uv_SSE2(0x80, dst);
453  }
454  static WEBP_INLINE void DC8uvMode_SSE2(uint8_t* dst, const uint8_t* left,
455                                         const uint8_t* top) {
456    if (top != NULL) {
457      if (left != NULL) {  
458        DC8uv_SSE2(dst, left, top);
459      } else {  
460        DC8uvNoLeft_SSE2(dst, top);
461      }
462    } else if (left != NULL) {  
463      DC8uvNoTop_SSE2(dst, left);
464    } else {  
465      DC8uvNoTopLeft_SSE2(dst);
466    }
467  }
468  static WEBP_INLINE void DC16_SSE2(uint8_t* dst, const uint8_t* left,
469                                    const uint8_t* top) {
470    const __m128i top_row = _mm_load_si128((const __m128i*)top);
471    const __m128i left_row = _mm_load_si128((const __m128i*)left);
472    const int DC =
473        VP8HorizontalAdd8b(&top_row) + VP8HorizontalAdd8b(&left_row) + 16;
474    Put16_SSE2(DC >> 5, dst);
475  }
476  static WEBP_INLINE void DC16NoLeft_SSE2(uint8_t* dst, const uint8_t* top) {
477    const __m128i top_row = _mm_load_si128((const __m128i*)top);
478    const int DC = VP8HorizontalAdd8b(&top_row) + 8;
479    Put16_SSE2(DC >> 4, dst);
480  }
481  static WEBP_INLINE void DC16NoTop_SSE2(uint8_t* dst, const uint8_t* left) {
482    DC16NoLeft_SSE2(dst, left);
483  }
484  static WEBP_INLINE void DC16NoTopLeft_SSE2(uint8_t* dst) {
485    Put16_SSE2(0x80, dst);
486  }
487  static WEBP_INLINE void DC16Mode_SSE2(uint8_t* dst, const uint8_t* left,
488                                        const uint8_t* top) {
489    if (top != NULL) {
490      if (left != NULL) {  
491        DC16_SSE2(dst, left, top);
492      } else {  
493        DC16NoLeft_SSE2(dst, top);
494      }
495    } else if (left != NULL) {  
496      DC16NoTop_SSE2(dst, left);
497    } else {  
498      DC16NoTopLeft_SSE2(dst);
499    }
500  }
501  #define DST(x, y) dst[(x) + (y) * BPS]
502  #define AVG3(a, b, c) (((a) + 2 * (b) + (c) + 2) >> 2)
503  #define AVG2(a, b) (((a) + (b) + 1) >> 1)
504  static WEBP_INLINE void VE4_SSE2(uint8_t* dst,
505                                   const uint8_t* top) {  
506    const __m128i one = _mm_set1_epi8(1);
507    const __m128i ABCDEFGH = _mm_loadl_epi64((__m128i*)(top - 1));
508    const __m128i BCDEFGH0 = _mm_srli_si128(ABCDEFGH, 1);
509    const __m128i CDEFGH00 = _mm_srli_si128(ABCDEFGH, 2);
510    const __m128i a = _mm_avg_epu8(ABCDEFGH, CDEFGH00);
511    const __m128i lsb = _mm_and_si128(_mm_xor_si128(ABCDEFGH, CDEFGH00), one);
512    const __m128i b = _mm_subs_epu8(a, lsb);
513    const __m128i avg = _mm_avg_epu8(b, BCDEFGH0);
514    const uint32_t vals = _mm_cvtsi128_si32(avg);
515    int i;
516    for (i = 0; i < 4; ++i) {
517      WebPUint32ToMem(dst + i * BPS, vals);
518    }
519  }
520  static WEBP_INLINE void HE4_SSE2(uint8_t* dst,
521                                   const uint8_t* top) {  
522    const int X = top[-1];
523    const int I = top[-2];
524    const int J = top[-3];
525    const int K = top[-4];
526    const int L = top[-5];
527    WebPUint32ToMem(dst + 0 * BPS, 0x01010101U * AVG3(X, I, J));
528    WebPUint32ToMem(dst + 1 * BPS, 0x01010101U * AVG3(I, J, K));
529    WebPUint32ToMem(dst + 2 * BPS, 0x01010101U * AVG3(J, K, L));
530    WebPUint32ToMem(dst + 3 * BPS, 0x01010101U * AVG3(K, L, L));
531  }
532  static WEBP_INLINE void DC4_SSE2(uint8_t* dst, const uint8_t* top) {
533    uint32_t dc = 4;
534    int i;
535    for (i = 0; i < 4; ++i) dc += top[i] + top[-5 + i];
536    Fill_SSE2(dst, dc >> 3, 4);
537  }
538  static WEBP_INLINE void LD4_SSE2(uint8_t* dst,
539                                   const uint8_t* top) {  
540    const __m128i one = _mm_set1_epi8(1);
541    const __m128i ABCDEFGH = _mm_loadl_epi64((const __m128i*)top);
542    const __m128i BCDEFGH0 = _mm_srli_si128(ABCDEFGH, 1);
543    const __m128i CDEFGH00 = _mm_srli_si128(ABCDEFGH, 2);
544    const __m128i CDEFGHH0 = _mm_insert_epi16(CDEFGH00, top[7], 3);
545    const __m128i avg1 = _mm_avg_epu8(ABCDEFGH, CDEFGHH0);
546    const __m128i lsb = _mm_and_si128(_mm_xor_si128(ABCDEFGH, CDEFGHH0), one);
547    const __m128i avg2 = _mm_subs_epu8(avg1, lsb);
548    const __m128i abcdefg = _mm_avg_epu8(avg2, BCDEFGH0);
549    WebPUint32ToMem(dst + 0 * BPS, _mm_cvtsi128_si32(               abcdefg    ));
550    WebPUint32ToMem(dst + 1 * BPS, _mm_cvtsi128_si32(_mm_srli_si128(abcdefg, 1)));
551    WebPUint32ToMem(dst + 2 * BPS, _mm_cvtsi128_si32(_mm_srli_si128(abcdefg, 2)));
552    WebPUint32ToMem(dst + 3 * BPS, _mm_cvtsi128_si32(_mm_srli_si128(abcdefg, 3)));
553  }
554  static WEBP_INLINE void VR4_SSE2(uint8_t* dst,
555                                   const uint8_t* top) {  
556    const __m128i one = _mm_set1_epi8(1);
557    const int I = top[-2];
558    const int J = top[-3];
559    const int K = top[-4];
560    const int X = top[-1];
561    const __m128i XABCD = _mm_loadl_epi64((const __m128i*)(top - 1));
562    const __m128i ABCD0 = _mm_srli_si128(XABCD, 1);
563    const __m128i abcd = _mm_avg_epu8(XABCD, ABCD0);
564    const __m128i _XABCD = _mm_slli_si128(XABCD, 1);
565    const __m128i IXABCD = _mm_insert_epi16(_XABCD, (short)(I | (X << 8)), 0);
566    const __m128i avg1 = _mm_avg_epu8(IXABCD, ABCD0);
567    const __m128i lsb = _mm_and_si128(_mm_xor_si128(IXABCD, ABCD0), one);
568    const __m128i avg2 = _mm_subs_epu8(avg1, lsb);
569    const __m128i efgh = _mm_avg_epu8(avg2, XABCD);
570    WebPUint32ToMem(dst + 0 * BPS, _mm_cvtsi128_si32(               abcd    ));
571    WebPUint32ToMem(dst + 1 * BPS, _mm_cvtsi128_si32(               efgh    ));
572    WebPUint32ToMem(dst + 2 * BPS, _mm_cvtsi128_si32(_mm_slli_si128(abcd, 1)));
573    WebPUint32ToMem(dst + 3 * BPS, _mm_cvtsi128_si32(_mm_slli_si128(efgh, 1)));
574    DST(0, 2) = AVG3(J, I, X);
575    DST(0, 3) = AVG3(K, J, I);
576  }
577  static WEBP_INLINE void VL4_SSE2(uint8_t* dst,
578                                   const uint8_t* top) {  
579    const __m128i one = _mm_set1_epi8(1);
580    const __m128i ABCDEFGH = _mm_loadl_epi64((const __m128i*)top);
581    const __m128i BCDEFGH_ = _mm_srli_si128(ABCDEFGH, 1);
582    const __m128i CDEFGH__ = _mm_srli_si128(ABCDEFGH, 2);
583    const __m128i avg1 = _mm_avg_epu8(ABCDEFGH, BCDEFGH_);
584    const __m128i avg2 = _mm_avg_epu8(CDEFGH__, BCDEFGH_);
585    const __m128i avg3 = _mm_avg_epu8(avg1, avg2);
586    const __m128i lsb1 = _mm_and_si128(_mm_xor_si128(avg1, avg2), one);
587    const __m128i ab = _mm_xor_si128(ABCDEFGH, BCDEFGH_);
588    const __m128i bc = _mm_xor_si128(CDEFGH__, BCDEFGH_);
589    const __m128i abbc = _mm_or_si128(ab, bc);
590    const __m128i lsb2 = _mm_and_si128(abbc, lsb1);
591    const __m128i avg4 = _mm_subs_epu8(avg3, lsb2);
592    const uint32_t extra_out = _mm_cvtsi128_si32(_mm_srli_si128(avg4, 4));
593    WebPUint32ToMem(dst + 0 * BPS, _mm_cvtsi128_si32(               avg1    ));
594    WebPUint32ToMem(dst + 1 * BPS, _mm_cvtsi128_si32(               avg4    ));
595    WebPUint32ToMem(dst + 2 * BPS, _mm_cvtsi128_si32(_mm_srli_si128(avg1, 1)));
596    WebPUint32ToMem(dst + 3 * BPS, _mm_cvtsi128_si32(_mm_srli_si128(avg4, 1)));
597    DST(3, 2) = (extra_out >> 0) & 0xff;
598    DST(3, 3) = (extra_out >> 8) & 0xff;
599  }
600  static WEBP_INLINE void RD4_SSE2(uint8_t* dst,
601                                   const uint8_t* top) {  
602    const __m128i one = _mm_set1_epi8(1);
603    const __m128i LKJIXABC = _mm_loadl_epi64((const __m128i*)(top - 5));
604    const __m128i LKJIXABCD = _mm_insert_epi16(LKJIXABC, top[3], 4);
605    const __m128i KJIXABCD_ = _mm_srli_si128(LKJIXABCD, 1);
606    const __m128i JIXABCD__ = _mm_srli_si128(LKJIXABCD, 2);
607    const __m128i avg1 = _mm_avg_epu8(JIXABCD__, LKJIXABCD);
608    const __m128i lsb = _mm_and_si128(_mm_xor_si128(JIXABCD__, LKJIXABCD), one);
609    const __m128i avg2 = _mm_subs_epu8(avg1, lsb);
610    const __m128i abcdefg = _mm_avg_epu8(avg2, KJIXABCD_);
611    WebPUint32ToMem(dst + 3 * BPS, _mm_cvtsi128_si32(               abcdefg    ));
612    WebPUint32ToMem(dst + 2 * BPS, _mm_cvtsi128_si32(_mm_srli_si128(abcdefg, 1)));
613    WebPUint32ToMem(dst + 1 * BPS, _mm_cvtsi128_si32(_mm_srli_si128(abcdefg, 2)));
614    WebPUint32ToMem(dst + 0 * BPS, _mm_cvtsi128_si32(_mm_srli_si128(abcdefg, 3)));
615  }
616  static WEBP_INLINE void HU4_SSE2(uint8_t* dst, const uint8_t* top) {
617    const int I = top[-2];
618    const int J = top[-3];
619    const int K = top[-4];
620    const int L = top[-5];
621    DST(0, 0) =             AVG2(I, J);
622    DST(2, 0) = DST(0, 1) = AVG2(J, K);
623    DST(2, 1) = DST(0, 2) = AVG2(K, L);
624    DST(1, 0) =             AVG3(I, J, K);
625    DST(3, 0) = DST(1, 1) = AVG3(J, K, L);
626    DST(3, 1) = DST(1, 2) = AVG3(K, L, L);
627    DST(3, 2) = DST(2, 2) =
628    DST(0, 3) = DST(1, 3) = DST(2, 3) = DST(3, 3) = L;
629  }
630  static WEBP_INLINE void HD4_SSE2(uint8_t* dst, const uint8_t* top) {
631    const int X = top[-1];
632    const int I = top[-2];
633    const int J = top[-3];
634    const int K = top[-4];
635    const int L = top[-5];
636    const int A = top[0];
637    const int B = top[1];
638    const int C = top[2];
639    DST(0, 0) = DST(2, 1) = AVG2(I, X);
640    DST(0, 1) = DST(2, 2) = AVG2(J, I);
641    DST(0, 2) = DST(2, 3) = AVG2(K, J);
642    DST(0, 3)             = AVG2(L, K);
643    DST(3, 0)             = AVG3(A, B, C);
644    DST(2, 0)             = AVG3(X, A, B);
645    DST(1, 0) = DST(3, 1) = AVG3(I, X, A);
646    DST(1, 1) = DST(3, 2) = AVG3(J, I, X);
647    DST(1, 2) = DST(3, 3) = AVG3(K, J, I);
648    DST(1, 3)             = AVG3(L, K, J);
649  }
650  static WEBP_INLINE void TM4_SSE2(uint8_t* dst, const uint8_t* top) {
651    const __m128i zero = _mm_setzero_si128();
652    const __m128i top_values = _mm_cvtsi32_si128(WebPMemToUint32(top));
653    const __m128i top_base = _mm_unpacklo_epi8(top_values, zero);
654    int y;
655    for (y = 0; y < 4; ++y, dst += BPS) {
656      const int val = top[-2 - y] - top[-1];
657      const __m128i base = _mm_set1_epi16(val);
658      const __m128i out = _mm_packus_epi16(_mm_add_epi16(base, top_base), zero);
659      WebPUint32ToMem(dst, _mm_cvtsi128_si32(out));
660    }
661  }
662  #undef DST
663  #undef AVG3
664  #undef AVG2
665  static void Intra4Preds_SSE2(uint8_t* dst, const uint8_t* top) {
666    DC4_SSE2(I4DC4 + dst, top);
667    TM4_SSE2(I4TM4 + dst, top);
668    VE4_SSE2(I4VE4 + dst, top);
669    HE4_SSE2(I4HE4 + dst, top);
670    RD4_SSE2(I4RD4 + dst, top);
671    VR4_SSE2(I4VR4 + dst, top);
672    LD4_SSE2(I4LD4 + dst, top);
673    VL4_SSE2(I4VL4 + dst, top);
674    HD4_SSE2(I4HD4 + dst, top);
675    HU4_SSE2(I4HU4 + dst, top);
676  }
677  static void IntraChromaPreds_SSE2(uint8_t* dst, const uint8_t* left,
678                                    const uint8_t* top) {
679    DC8uvMode_SSE2(C8DC8 + dst, left, top);
680    VerticalPred_SSE2(C8VE8 + dst, top, 8);
681    HorizontalPred_SSE2(C8HE8 + dst, left, 8);
682    TrueMotion_SSE2(C8TM8 + dst, left, top, 8);
683    dst += 8;
684    if (top != NULL) top += 8;
685    if (left != NULL) left += 16;
686    DC8uvMode_SSE2(C8DC8 + dst, left, top);
687    VerticalPred_SSE2(C8VE8 + dst, top, 8);
688    HorizontalPred_SSE2(C8HE8 + dst, left, 8);
689    TrueMotion_SSE2(C8TM8 + dst, left, top, 8);
690  }
691  static void Intra16Preds_SSE2(uint8_t* dst,
692                                const uint8_t* left, const uint8_t* top) {
693    DC16Mode_SSE2(I16DC16 + dst, left, top);
694    VerticalPred_SSE2(I16VE16 + dst, top, 16);
695    HorizontalPred_SSE2(I16HE16 + dst, left, 16);
696    TrueMotion_SSE2(I16TM16 + dst, left, top, 16);
697  }
698  static WEBP_INLINE void SubtractAndAccumulate_SSE2(const __m128i a,
699                                                     const __m128i b,
700                                                     __m128i* const sum) {
701    const __m128i a_b = _mm_subs_epu8(a, b);
702    const __m128i b_a = _mm_subs_epu8(b, a);
703    const __m128i abs_a_b = _mm_or_si128(a_b, b_a);
704    const __m128i zero = _mm_setzero_si128();
705    const __m128i C0 = _mm_unpacklo_epi8(abs_a_b, zero);
706    const __m128i C1 = _mm_unpackhi_epi8(abs_a_b, zero);
707    const __m128i sum1 = _mm_madd_epi16(C0, C0);
708    const __m128i sum2 = _mm_madd_epi16(C1, C1);
709    *sum = _mm_add_epi32(sum1, sum2);
710  }
711  static WEBP_INLINE int SSE_16xN_SSE2(const uint8_t* a, const uint8_t* b,
712                                       int num_pairs) {
713    __m128i sum = _mm_setzero_si128();
714    int32_t tmp[4];
715    int i;
716    for (i = 0; i < num_pairs; ++i) {
717      const __m128i a0 = _mm_loadu_si128((const __m128i*)&a[BPS * 0]);
718      const __m128i b0 = _mm_loadu_si128((const __m128i*)&b[BPS * 0]);
719      const __m128i a1 = _mm_loadu_si128((const __m128i*)&a[BPS * 1]);
720      const __m128i b1 = _mm_loadu_si128((const __m128i*)&b[BPS * 1]);
721      __m128i sum1, sum2;
722      SubtractAndAccumulate_SSE2(a0, b0, &sum1);
723      SubtractAndAccumulate_SSE2(a1, b1, &sum2);
724      sum = _mm_add_epi32(sum, _mm_add_epi32(sum1, sum2));
725      a += 2 * BPS;
726      b += 2 * BPS;
727    }
728    _mm_storeu_si128((__m128i*)tmp, sum);
729    return (tmp[3] + tmp[2] + tmp[1] + tmp[0]);
730  }
731  static int SSE16x16_SSE2(const uint8_t* a, const uint8_t* b) {
732    return SSE_16xN_SSE2(a, b, 8);
733  }
734  static int SSE16x8_SSE2(const uint8_t* a, const uint8_t* b) {
735    return SSE_16xN_SSE2(a, b, 4);
736  }
737  #define LOAD_8x16b(ptr) \
738    _mm_unpacklo_epi8(_mm_loadl_epi64((const __m128i*)(ptr)), zero)
739  static int SSE8x8_SSE2(const uint8_t* a, const uint8_t* b) {
740    const __m128i zero = _mm_setzero_si128();
741    int num_pairs = 4;
742    __m128i sum = zero;
743    int32_t tmp[4];
744    while (num_pairs-- > 0) {
745      const __m128i a0 = LOAD_8x16b(&a[BPS * 0]);
746      const __m128i a1 = LOAD_8x16b(&a[BPS * 1]);
747      const __m128i b0 = LOAD_8x16b(&b[BPS * 0]);
748      const __m128i b1 = LOAD_8x16b(&b[BPS * 1]);
749      const __m128i c0 = _mm_subs_epi16(a0, b0);
750      const __m128i c1 = _mm_subs_epi16(a1, b1);
751      const __m128i d0 = _mm_madd_epi16(c0, c0);
752      const __m128i d1 = _mm_madd_epi16(c1, c1);
753      const __m128i sum01 = _mm_add_epi32(d0, d1);
754      sum = _mm_add_epi32(sum, sum01);
755      a += 2 * BPS;
756      b += 2 * BPS;
757    }
758    _mm_storeu_si128((__m128i*)tmp, sum);
759    return (tmp[3] + tmp[2] + tmp[1] + tmp[0]);
760  }
761  #undef LOAD_8x16b
762  static int SSE4x4_SSE2(const uint8_t* a, const uint8_t* b) {
763    const __m128i zero = _mm_setzero_si128();
764    const __m128i a0 = _mm_loadl_epi64((const __m128i*)&a[BPS * 0]);
765    const __m128i a1 = _mm_loadl_epi64((const __m128i*)&a[BPS * 1]);
766    const __m128i a2 = _mm_loadl_epi64((const __m128i*)&a[BPS * 2]);
767    const __m128i a3 = _mm_loadl_epi64((const __m128i*)&a[BPS * 3]);
768    const __m128i b0 = _mm_loadl_epi64((const __m128i*)&b[BPS * 0]);
769    const __m128i b1 = _mm_loadl_epi64((const __m128i*)&b[BPS * 1]);
770    const __m128i b2 = _mm_loadl_epi64((const __m128i*)&b[BPS * 2]);
771    const __m128i b3 = _mm_loadl_epi64((const __m128i*)&b[BPS * 3]);
772    const __m128i a01 = _mm_unpacklo_epi32(a0, a1);
773    const __m128i a23 = _mm_unpacklo_epi32(a2, a3);
774    const __m128i b01 = _mm_unpacklo_epi32(b0, b1);
775    const __m128i b23 = _mm_unpacklo_epi32(b2, b3);
776    const __m128i a01s = _mm_unpacklo_epi8(a01, zero);
777    const __m128i a23s = _mm_unpacklo_epi8(a23, zero);
778    const __m128i b01s = _mm_unpacklo_epi8(b01, zero);
779    const __m128i b23s = _mm_unpacklo_epi8(b23, zero);
780    const __m128i d0 = _mm_subs_epi16(a01s, b01s);
781    const __m128i d1 = _mm_subs_epi16(a23s, b23s);
782    const __m128i e0 = _mm_madd_epi16(d0, d0);
783    const __m128i e1 = _mm_madd_epi16(d1, d1);
784    const __m128i sum = _mm_add_epi32(e0, e1);
785    int32_t tmp[4];
786    _mm_storeu_si128((__m128i*)tmp, sum);
787    return (tmp[3] + tmp[2] + tmp[1] + tmp[0]);
788  }
789  static void Mean16x4_SSE2(const uint8_t* ref, uint32_t dc[4]) {
790    const __m128i mask = _mm_set1_epi16(0x00ff);
791    const __m128i a0 = _mm_loadu_si128((const __m128i*)&ref[BPS * 0]);
792    const __m128i a1 = _mm_loadu_si128((const __m128i*)&ref[BPS * 1]);
793    const __m128i a2 = _mm_loadu_si128((const __m128i*)&ref[BPS * 2]);
794    const __m128i a3 = _mm_loadu_si128((const __m128i*)&ref[BPS * 3]);
795    const __m128i b0 = _mm_srli_epi16(a0, 8);     
796    const __m128i b1 = _mm_srli_epi16(a1, 8);
797    const __m128i b2 = _mm_srli_epi16(a2, 8);
798    const __m128i b3 = _mm_srli_epi16(a3, 8);
799    const __m128i c0 = _mm_and_si128(a0, mask);   
800    const __m128i c1 = _mm_and_si128(a1, mask);
801    const __m128i c2 = _mm_and_si128(a2, mask);
802    const __m128i c3 = _mm_and_si128(a3, mask);
803    const __m128i d0 = _mm_add_epi32(b0, c0);
804    const __m128i d1 = _mm_add_epi32(b1, c1);
805    const __m128i d2 = _mm_add_epi32(b2, c2);
806    const __m128i d3 = _mm_add_epi32(b3, c3);
807    const __m128i e0 = _mm_add_epi32(d0, d1);
808    const __m128i e1 = _mm_add_epi32(d2, d3);
809    const __m128i f0 = _mm_add_epi32(e0, e1);
810    uint16_t tmp[8];
811    _mm_storeu_si128((__m128i*)tmp, f0);
812    dc[0] = tmp[0] + tmp[1];
813    dc[1] = tmp[2] + tmp[3];
814    dc[2] = tmp[4] + tmp[5];
815    dc[3] = tmp[6] + tmp[7];
816  }
817  static int TTransform_SSE2(const uint8_t* inA, const uint8_t* inB,
818                             const uint16_t* const w) {
819    int32_t sum[4];
820    __m128i tmp_0, tmp_1, tmp_2, tmp_3;
821    const __m128i zero = _mm_setzero_si128();
822    {
823      const __m128i inA_0 = _mm_loadl_epi64((const __m128i*)&inA[BPS * 0]);
824      const __m128i inA_1 = _mm_loadl_epi64((const __m128i*)&inA[BPS * 1]);
825      const __m128i inA_2 = _mm_loadl_epi64((const __m128i*)&inA[BPS * 2]);
826      const __m128i inA_3 = _mm_loadl_epi64((const __m128i*)&inA[BPS * 3]);
827      const __m128i inB_0 = _mm_loadl_epi64((const __m128i*)&inB[BPS * 0]);
828      const __m128i inB_1 = _mm_loadl_epi64((const __m128i*)&inB[BPS * 1]);
829      const __m128i inB_2 = _mm_loadl_epi64((const __m128i*)&inB[BPS * 2]);
830      const __m128i inB_3 = _mm_loadl_epi64((const __m128i*)&inB[BPS * 3]);
831      const __m128i inAB_0 = _mm_unpacklo_epi32(inA_0, inB_0);
832      const __m128i inAB_1 = _mm_unpacklo_epi32(inA_1, inB_1);
833      const __m128i inAB_2 = _mm_unpacklo_epi32(inA_2, inB_2);
834      const __m128i inAB_3 = _mm_unpacklo_epi32(inA_3, inB_3);
835      tmp_0 = _mm_unpacklo_epi8(inAB_0, zero);
836      tmp_1 = _mm_unpacklo_epi8(inAB_1, zero);
837      tmp_2 = _mm_unpacklo_epi8(inAB_2, zero);
838      tmp_3 = _mm_unpacklo_epi8(inAB_3, zero);
839    }
840    {
841      const __m128i a0 = _mm_add_epi16(tmp_0, tmp_2);
842      const __m128i a1 = _mm_add_epi16(tmp_1, tmp_3);
843      const __m128i a2 = _mm_sub_epi16(tmp_1, tmp_3);
844      const __m128i a3 = _mm_sub_epi16(tmp_0, tmp_2);
845      const __m128i b0 = _mm_add_epi16(a0, a1);
846      const __m128i b1 = _mm_add_epi16(a3, a2);
847      const __m128i b2 = _mm_sub_epi16(a3, a2);
848      const __m128i b3 = _mm_sub_epi16(a0, a1);
849      VP8Transpose_2_4x4_16b(&b0, &b1, &b2, &b3, &tmp_0, &tmp_1, &tmp_2, &tmp_3);
850    }
851    {
852      const __m128i w_0 = _mm_loadu_si128((const __m128i*)&w[0]);
853      const __m128i w_8 = _mm_loadu_si128((const __m128i*)&w[8]);
854      const __m128i a0 = _mm_add_epi16(tmp_0, tmp_2);
855      const __m128i a1 = _mm_add_epi16(tmp_1, tmp_3);
856      const __m128i a2 = _mm_sub_epi16(tmp_1, tmp_3);
857      const __m128i a3 = _mm_sub_epi16(tmp_0, tmp_2);
858      const __m128i b0 = _mm_add_epi16(a0, a1);
859      const __m128i b1 = _mm_add_epi16(a3, a2);
860      const __m128i b2 = _mm_sub_epi16(a3, a2);
861      const __m128i b3 = _mm_sub_epi16(a0, a1);
862      __m128i A_b0 = _mm_unpacklo_epi64(b0, b1);
863      __m128i A_b2 = _mm_unpacklo_epi64(b2, b3);
864      __m128i B_b0 = _mm_unpackhi_epi64(b0, b1);
865      __m128i B_b2 = _mm_unpackhi_epi64(b2, b3);
866      {
867        const __m128i d0 = _mm_sub_epi16(zero, A_b0);
868        const __m128i d1 = _mm_sub_epi16(zero, A_b2);
869        const __m128i d2 = _mm_sub_epi16(zero, B_b0);
870        const __m128i d3 = _mm_sub_epi16(zero, B_b2);
871        A_b0 = _mm_max_epi16(A_b0, d0);   
872        A_b2 = _mm_max_epi16(A_b2, d1);
873        B_b0 = _mm_max_epi16(B_b0, d2);
874        B_b2 = _mm_max_epi16(B_b2, d3);
875      }
876      A_b0 = _mm_madd_epi16(A_b0, w_0);
877      A_b2 = _mm_madd_epi16(A_b2, w_8);
878      B_b0 = _mm_madd_epi16(B_b0, w_0);
879      B_b2 = _mm_madd_epi16(B_b2, w_8);
880      A_b0 = _mm_add_epi32(A_b0, A_b2);
881      B_b0 = _mm_add_epi32(B_b0, B_b2);
882      A_b0 = _mm_sub_epi32(A_b0, B_b0);
883      _mm_storeu_si128((__m128i*)&sum[0], A_b0);
884    }
885    return sum[0] + sum[1] + sum[2] + sum[3];
886  }
887  static int Disto4x4_SSE2(const uint8_t* const a, const uint8_t* const b,
888                           const uint16_t* const w) {
889    const int diff_sum = TTransform_SSE2(a, b, w);
890    return abs(diff_sum) >> 5;
891  }
892  static int Disto16x16_SSE2(const uint8_t* const a, const uint8_t* const b,
893                             const uint16_t* const w) {
894    int D = 0;
895    int x, y;
896    for (y = 0; y < 16 * BPS; y += 4 * BPS) {
897      for (x = 0; x < 16; x += 4) {
898        D += Disto4x4_SSE2(a + x + y, b + x + y, w);
899      }
900    }
901    return D;
902  }
903  static WEBP_INLINE int DoQuantizeBlock_SSE2(int16_t in[16], int16_t out[16],
904                                              const uint16_t* const sharpen,
905                                              const VP8Matrix* const mtx) {
906    const __m128i max_coeff_2047 = _mm_set1_epi16(MAX_LEVEL);
907    const __m128i zero = _mm_setzero_si128();
908    __m128i coeff0, coeff8;
909    __m128i out0, out8;
910    __m128i packed_out;
911    __m128i in0 = _mm_loadu_si128((__m128i*)&in[0]);
912    __m128i in8 = _mm_loadu_si128((__m128i*)&in[8]);
913    const __m128i iq0 = _mm_loadu_si128((const __m128i*)&mtx->iq_[0]);
914    const __m128i iq8 = _mm_loadu_si128((const __m128i*)&mtx->iq_[8]);
915    const __m128i q0 = _mm_loadu_si128((const __m128i*)&mtx->q_[0]);
916    const __m128i q8 = _mm_loadu_si128((const __m128i*)&mtx->q_[8]);
917    const __m128i sign0 = _mm_cmpgt_epi16(zero, in0);
918    const __m128i sign8 = _mm_cmpgt_epi16(zero, in8);
919    coeff0 = _mm_xor_si128(in0, sign0);
920    coeff8 = _mm_xor_si128(in8, sign8);
921    coeff0 = _mm_sub_epi16(coeff0, sign0);
922    coeff8 = _mm_sub_epi16(coeff8, sign8);
923    if (sharpen != NULL) {
924      const __m128i sharpen0 = _mm_loadu_si128((const __m128i*)&sharpen[0]);
925      const __m128i sharpen8 = _mm_loadu_si128((const __m128i*)&sharpen[8]);
926      coeff0 = _mm_add_epi16(coeff0, sharpen0);
927      coeff8 = _mm_add_epi16(coeff8, sharpen8);
928    }
929    {
930      const __m128i coeff_iQ0H = _mm_mulhi_epu16(coeff0, iq0);
931      const __m128i coeff_iQ0L = _mm_mullo_epi16(coeff0, iq0);
932      const __m128i coeff_iQ8H = _mm_mulhi_epu16(coeff8, iq8);
933      const __m128i coeff_iQ8L = _mm_mullo_epi16(coeff8, iq8);
934      __m128i out_00 = _mm_unpacklo_epi16(coeff_iQ0L, coeff_iQ0H);
935      __m128i out_04 = _mm_unpackhi_epi16(coeff_iQ0L, coeff_iQ0H);
936      __m128i out_08 = _mm_unpacklo_epi16(coeff_iQ8L, coeff_iQ8H);
937      __m128i out_12 = _mm_unpackhi_epi16(coeff_iQ8L, coeff_iQ8H);
938      const __m128i bias_00 = _mm_loadu_si128((const __m128i*)&mtx->bias_[0]);
939      const __m128i bias_04 = _mm_loadu_si128((const __m128i*)&mtx->bias_[4]);
940      const __m128i bias_08 = _mm_loadu_si128((const __m128i*)&mtx->bias_[8]);
941      const __m128i bias_12 = _mm_loadu_si128((const __m128i*)&mtx->bias_[12]);
942      out_00 = _mm_add_epi32(out_00, bias_00);
943      out_04 = _mm_add_epi32(out_04, bias_04);
944      out_08 = _mm_add_epi32(out_08, bias_08);
945      out_12 = _mm_add_epi32(out_12, bias_12);
946      out_00 = _mm_srai_epi32(out_00, QFIX);
947      out_04 = _mm_srai_epi32(out_04, QFIX);
948      out_08 = _mm_srai_epi32(out_08, QFIX);
949      out_12 = _mm_srai_epi32(out_12, QFIX);
950      out0 = _mm_packs_epi32(out_00, out_04);
951      out8 = _mm_packs_epi32(out_08, out_12);
952      out0 = _mm_min_epi16(out0, max_coeff_2047);
953      out8 = _mm_min_epi16(out8, max_coeff_2047);
954    }
955    out0 = _mm_xor_si128(out0, sign0);
956    out8 = _mm_xor_si128(out8, sign8);
957    out0 = _mm_sub_epi16(out0, sign0);
958    out8 = _mm_sub_epi16(out8, sign8);
959    in0 = _mm_mullo_epi16(out0, q0);
960    in8 = _mm_mullo_epi16(out8, q8);
961    _mm_storeu_si128((__m128i*)&in[0], in0);
962    _mm_storeu_si128((__m128i*)&in[8], in8);
963    {
964      __m128i outZ0, outZ8;
965      outZ0 = _mm_shufflehi_epi16(out0,  _MM_SHUFFLE(2, 1, 3, 0));
966      outZ0 = _mm_shuffle_epi32  (outZ0, _MM_SHUFFLE(3, 1, 2, 0));
967      outZ0 = _mm_shufflehi_epi16(outZ0, _MM_SHUFFLE(3, 1, 0, 2));
968      outZ8 = _mm_shufflelo_epi16(out8,  _MM_SHUFFLE(3, 0, 2, 1));
969      outZ8 = _mm_shuffle_epi32  (outZ8, _MM_SHUFFLE(3, 1, 2, 0));
970      outZ8 = _mm_shufflelo_epi16(outZ8, _MM_SHUFFLE(1, 3, 2, 0));
971      _mm_storeu_si128((__m128i*)&out[0], outZ0);
972      _mm_storeu_si128((__m128i*)&out[8], outZ8);
973      packed_out = _mm_packs_epi16(outZ0, outZ8);
974    }
975    {
976      const int16_t outZ_12 = out[12];
977      const int16_t outZ_3 = out[3];
978      out[3] = outZ_12;
979      out[12] = outZ_3;
980    }
981    return (_mm_movemask_epi8(_mm_cmpeq_epi8(packed_out, zero)) != 0xffff);
982  }
983  static int QuantizeBlock_SSE2(int16_t in[16], int16_t out[16],
984                                const VP8Matrix* const mtx) {
985    return DoQuantizeBlock_SSE2(in, out, &mtx->sharpen_[0], mtx);
986  }
987  static int QuantizeBlockWHT_SSE2(int16_t in[16], int16_t out[16],
988                                   const VP8Matrix* const mtx) {
989    return DoQuantizeBlock_SSE2(in, out, NULL, mtx);
990  }
991  static int Quantize2Blocks_SSE2(int16_t in[32], int16_t out[32],
992                                  const VP8Matrix* const mtx) {
993    int nz;
994    const uint16_t* const sharpen = &mtx->sharpen_[0];
995    nz  = DoQuantizeBlock_SSE2(in + 0 * 16, out + 0 * 16, sharpen, mtx) << 0;
996    nz |= DoQuantizeBlock_SSE2(in + 1 * 16, out + 1 * 16, sharpen, mtx) << 1;
997    return nz;
998  }
999  extern void VP8EncDspInitSSE2(void);
1000  WEBP_TSAN_IGNORE_FUNCTION void VP8EncDspInitSSE2(void) {
1001    VP8CollectHistogram = CollectHistogram_SSE2;
1002    VP8EncPredLuma16 = Intra16Preds_SSE2;
1003    VP8EncPredChroma8 = IntraChromaPreds_SSE2;
1004    VP8EncPredLuma4 = Intra4Preds_SSE2;
1005    VP8EncQuantizeBlock = QuantizeBlock_SSE2;
1006    VP8EncQuantize2Blocks = Quantize2Blocks_SSE2;
1007    VP8EncQuantizeBlockWHT = QuantizeBlockWHT_SSE2;
1008    VP8ITransform = ITransform_SSE2;
1009    VP8FTransform = FTransform_SSE2;
1010    VP8FTransform2 = FTransform2_SSE2;
1011    VP8FTransformWHT = FTransformWHT_SSE2;
1012    VP8SSE16x16 = SSE16x16_SSE2;
1013    VP8SSE16x8 = SSE16x8_SSE2;
1014    VP8SSE8x8 = SSE8x8_SSE2;
1015    VP8SSE4x4 = SSE4x4_SSE2;
1016    VP8TDisto4x4 = Disto4x4_SSE2;
1017    VP8TDisto16x16 = Disto16x16_SSE2;
1018    VP8Mean16x4 = Mean16x4_SSE2;
1019  }
1020  #else  
1021  WEBP_DSP_INIT_STUB(VP8EncDspInitSSE2)
1022  #endif  
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from PINRemoteImage-MDEwOlJlcG9zaXRvcnkzOTUzNzEwMw==-flat-backward_references_cost_enc.c</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from PINRemoteImage-MDEwOlJlcG9zaXRvcnkzOTUzNzEwMw==-flat-enc_sse2.c</div>
                </div>
                <div class="column column_space"><pre><code>37    }
38  }
39  static int CostModelBuild(CostModel* const m, int xsize, int cache_bits,
40                            const VP8LBackwardRefs* const refs) {
41    int ok = 0;
</pre></code></div>
                <div class="column column_space"><pre><code>112      }
113    }
114  }
115  static void FTransformPass1_SSE2(const __m128i* const in01,
116                                   const __m128i* const in23,
117                                   __m128i* const out01,
118                                   __m128i* const out32) {
119    const __m128i k937 = _mm_set1_epi32(937);
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    