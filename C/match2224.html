<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML><HEAD><TITLE>Matches for nsd_gtls.c & action.c</TITLE>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
</HEAD>
<body>
  <div style="align-items: center; display: flex; justify-content: space-around;">
    <div>
      <h3 align="center">
Matches for nsd_gtls.c & action.c
      </h3>
      <h1 align="center">
        5.1%
      </h1>
      <center>
        <a href="index.html" target="_top">
          INDEX
        </a>
        <span>-</span>
        <a href="help-en.html" target="_top">
          HELP
        </a>
      </center>
    </div>
    <div>
<TABLE BORDER="1" CELLSPACING="0" BGCOLOR="#d0d0d0">
<TR><TH><TH>nsd_gtls.c (5.688623%)<TH>action.c (4.7529707%)<TH>Tokens
<TR><TD BGCOLOR="#0000ff"><FONT COLOR="#0000ff">-</FONT><TD><A HREF="javascript:ZweiFrames('match2224-0.html#0',2,'match2224-1.html#0',3)" NAME="0">(2291-2372)<TD><A HREF="javascript:ZweiFrames('match2224-0.html#0',2,'match2224-1.html#0',3)" NAME="0">(289-314)</A><TD ALIGN=center><FONT COLOR="#ff0000">24</FONT>
<TR><TD BGCOLOR="#f63526"><FONT COLOR="#f63526">-</FONT><TD><A HREF="javascript:ZweiFrames('match2224-0.html#1',2,'match2224-1.html#1',3)" NAME="1">(1437-1445)<TD><A HREF="javascript:ZweiFrames('match2224-0.html#1',2,'match2224-1.html#1',3)" NAME="1">(1792-1804)</A><TD ALIGN=center><FONT COLOR="#ff0000">24</FONT>
<TR><TD BGCOLOR="#980517"><FONT COLOR="#980517">-</FONT><TD><A HREF="javascript:ZweiFrames('match2224-0.html#2',2,'match2224-1.html#2',3)" NAME="2">(1214-1223)<TD><A HREF="javascript:ZweiFrames('match2224-0.html#2',2,'match2224-1.html#2',3)" NAME="2">(2192-2199)</A><TD ALIGN=center><FONT COLOR="#aa0000">16</FONT>
<TR><TD BGCOLOR="#53858b"><FONT COLOR="#53858b">-</FONT><TD><A HREF="javascript:ZweiFrames('match2224-0.html#3',2,'match2224-1.html#3',3)" NAME="3">(1855-1868)<TD><A HREF="javascript:ZweiFrames('match2224-0.html#3',2,'match2224-1.html#3',3)" NAME="3">(398-409)</A><TD ALIGN=center><FONT COLOR="#7f0000">12</FONT>
</TABLE>
    </div>
  </div>
  <hr>
  <div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>nsd_gtls.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
/* nsd_gtls.c
 *
 * An implementation of the nsd interface for GnuTLS.
 *
 * Copyright (C) 2007-2021 Rainer Gerhards and Adiscon GmbH.
 *
 * This file is part of the rsyslog runtime library.
 *
 * The rsyslog runtime library is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * The rsyslog runtime library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with the rsyslog runtime library.  If not, see &lt;http://www.gnu.org/licenses/&gt;.
 *
 * A copy of the GPL can be found in the file &quot;COPYING&quot; in this distribution.
 * A copy of the LGPL can be found in the file &quot;COPYING.LESSER&quot; in this distribution.
 */
#include &quot;config.h&quot;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;assert.h&gt;
#include &lt;string.h&gt;
#include &lt;gnutls/gnutls.h&gt;
#include &lt;gnutls/x509.h&gt;
#if GNUTLS_VERSION_NUMBER &lt;= 0x020b00
#	include &lt;gcrypt.h&gt;
#endif
#include &lt;errno.h&gt;
#include &lt;sys/stat.h&gt;
#include &lt;unistd.h&gt;
#include &lt;fcntl.h&gt;
#include &lt;pthread.h&gt;

#include &quot;rsyslog.h&quot;
#include &quot;syslogd-types.h&quot;
#include &quot;module-template.h&quot;
#include &quot;cfsysline.h&quot;
#include &quot;obj.h&quot;
#include &quot;stringbuf.h&quot;
#include &quot;errmsg.h&quot;
#include &quot;net.h&quot;
#include &quot;datetime.h&quot;
#include &quot;netstrm.h&quot;
#include &quot;netstrms.h&quot;
#include &quot;nsd_ptcp.h&quot;
#include &quot;nsdsel_gtls.h&quot;
#include &quot;nsd_gtls.h&quot;
#include &quot;unicode-helper.h&quot;
#include &quot;rsconf.h&quot;

/* things to move to some better place/functionality - TODO */
#define CRLFILE &quot;crl.pem&quot;


#if GNUTLS_VERSION_NUMBER &lt;= 0x020b00
GCRY_THREAD_OPTION_PTHREAD_IMPL;
#endif
MODULE_TYPE_LIB
MODULE_TYPE_KEEP

/* static data */
DEFobjStaticHelpers
DEFobjCurrIf(glbl)
DEFobjCurrIf(net)
DEFobjCurrIf(datetime)
DEFobjCurrIf(nsd_ptcp)

/* Static Helper variables for certless communication */
static gnutls_anon_client_credentials_t anoncred;	/**&lt; client anon credentials */
static gnutls_anon_server_credentials_t anoncredSrv;	/**&lt; server anon credentials */
static int dhBits = 2048;	/**&lt; number of bits for Diffie-Hellman key */
static int dhMinBits = 512;	/**&lt; minimum number of bits for Diffie-Hellman key */

static pthread_mutex_t mutGtlsStrerror;
/*&lt; a mutex protecting the potentially non-reentrant gtlStrerror() function */

static gnutls_dh_params_t dh_params; /**&lt; server DH parameters for anon mode */

/* a macro to abort if GnuTLS error is not acceptable. We split this off from
 * CHKgnutls() to avoid some Coverity report in cases where we know GnuTLS
 * failed. Note: gnuRet must already be set accordingly!
 */
#define ABORTgnutls { \
		uchar *pErr = gtlsStrerror(gnuRet); \
		LogError(0, RS_RET_GNUTLS_ERR, &quot;unexpected GnuTLS error %d in %s:%d: %s\n&quot;, \
	gnuRet, __FILE__, __LINE__, pErr); \
		free(pErr); \
		ABORT_FINALIZE(RS_RET_GNUTLS_ERR); \
}
/* a macro to check GnuTLS calls against unexpected errors */
#define CHKgnutls(x) { \
	gnuRet = (x); \
	if(gnuRet == GNUTLS_E_FILE_ERROR) { \
		LogError(0, RS_RET_GNUTLS_ERR, &quot;error reading file - a common cause is that the &quot; \
			&quot;file  does not exist&quot;); \
		ABORT_FINALIZE(RS_RET_GNUTLS_ERR); \
	} else if(gnuRet != 0) { \
		ABORTgnutls; \
	} \
}


/* ------------------------------ GnuTLS specifics ------------------------------ */

/* This defines a log function to be provided to GnuTLS. It hopefully
 * helps us track down hard to find problems.
 * rgerhards, 2008-06-20
 */
static void logFunction(int level, const char *msg)
{
	dbgprintf(&quot;GnuTLS log msg, level %d: %s\n&quot;, level, msg);
}

/* read in the whole content of a file. The caller is responsible for
 * freeing the buffer. To prevent DOS, this function can NOT read
 * files larger than 1MB (which still is *very* large).
 * rgerhards, 2008-05-26
 */
static rsRetVal
readFile(const uchar *const pszFile, gnutls_datum_t *const pBuf)
{
	int fd;
	struct stat stat_st;
	DEFiRet;

	assert(pszFile != NULL);
	assert(pBuf != NULL);

	pBuf-&gt;data = NULL;

	if((fd = open((char*)pszFile, O_RDONLY)) == -1) {
		LogError(errno, RS_RET_FILE_NOT_FOUND, &quot;can not read file '%s'&quot;, pszFile);
		ABORT_FINALIZE(RS_RET_FILE_NOT_FOUND);
	}

	if(fstat(fd, &amp;stat_st) == -1) {
		LogError(errno, RS_RET_FILE_NO_STAT, &quot;can not stat file '%s'&quot;, pszFile);
		ABORT_FINALIZE(RS_RET_FILE_NO_STAT);
	}

	/* 1MB limit */
	if(stat_st.st_size &gt; 1024 * 1024) {
		LogError(0, RS_RET_FILE_TOO_LARGE, &quot;file '%s' too large, max 1MB&quot;, pszFile);
		ABORT_FINALIZE(RS_RET_FILE_TOO_LARGE);
	}

	CHKmalloc(pBuf-&gt;data = malloc(stat_st.st_size));
	pBuf-&gt;size = stat_st.st_size;
	if(read(fd,  pBuf-&gt;data, stat_st.st_size) != stat_st.st_size) {
		LogError(0, RS_RET_IO_ERROR, &quot;error or incomplete read of file '%s'&quot;, pszFile);
		ABORT_FINALIZE(RS_RET_IO_ERROR);
	}

finalize_it:
	if(fd != -1)
		close(fd);
	if(iRet != RS_RET_OK) {
		if(pBuf-&gt;data != NULL) {
			free(pBuf-&gt;data);
			pBuf-&gt;data = NULL;
			pBuf-&gt;size = 0;
			}
	}
	RETiRet;
}


/* Load the certificate and the private key into our own store. We need to do
 * this in the client case, to support fingerprint authentication. In that case,
 * we may be presented no matching root certificate, but we must provide ours.
 * The only way to do that is via the cert callback interface, but for it we
 * need to load certificates into our private store.
 * rgerhards, 2008-05-26
 */
static rsRetVal
gtlsLoadOurCertKey(nsd_gtls_t *pThis)
{
	DEFiRet;
	int gnuRet;
	gnutls_datum_t data = { NULL, 0 };
	const uchar *keyFile;
	const uchar *certFile;

	ISOBJ_TYPE_assert(pThis, nsd_gtls);

	certFile = (pThis-&gt;pszCertFile == NULL) ? glbl.GetDfltNetstrmDrvrCertFile(runConf) : pThis-&gt;pszCertFile;
	keyFile = (pThis-&gt;pszKeyFile == NULL) ? glbl.GetDfltNetstrmDrvrKeyFile(runConf) : pThis-&gt;pszKeyFile;

	if(certFile == NULL || keyFile == NULL) {
		/* in this case, we can not set our certificate. If we are
		 * a client and the server is running in &quot;anon&quot; auth mode, this
		 * may be well acceptable. In other cases, we will see some
		 * more error messages down the road. -- rgerhards, 2008-07-02
		 */
		dbgprintf(&quot;gtlsLoadOurCertKey our certificate is not set, file name values are cert: '%s', key: '%s'\n&quot;,
			  certFile, keyFile);
		ABORT_FINALIZE(RS_RET_CERTLESS);
	}

	/* try load certificate */
	CHKiRet(readFile(certFile, &amp;data));
	pThis-&gt;nOurCerts = sizeof(pThis-&gt;pOurCerts) / sizeof(gnutls_x509_crt_t);
	gnuRet = gnutls_x509_crt_list_import(pThis-&gt;pOurCerts, &amp;pThis-&gt;nOurCerts,
		&amp;data, GNUTLS_X509_FMT_PEM,  GNUTLS_X509_CRT_LIST_IMPORT_FAIL_IF_EXCEED);
	if(gnuRet &lt; 0) {
		ABORTgnutls;
	}
	pThis-&gt;bOurCertIsInit = 1;
	free(data.data);
	data.data = NULL;

	/* try load private key */
	CHKiRet(readFile(keyFile, &amp;data));
	CHKgnutls(gnutls_x509_privkey_init(&amp;pThis-&gt;ourKey));
	pThis-&gt;bOurKeyIsInit = 1;
	CHKgnutls(gnutls_x509_privkey_import(pThis-&gt;ourKey, &amp;data, GNUTLS_X509_FMT_PEM));
	free(data.data);


finalize_it:
	if(iRet == RS_RET_CERTLESS) {
		dbgprintf(&quot;gtlsLoadOurCertKey certless exit\n&quot;);
		pThis-&gt;bOurCertIsInit = 0;
		pThis-&gt;bOurKeyIsInit = 0;
	} else if(iRet != RS_RET_OK) {
		dbgprintf(&quot;gtlsLoadOurCertKey error exit\n&quot;);
		if(data.data != NULL)
			free(data.data);
		if(pThis-&gt;bOurCertIsInit) {
			for(unsigned i=0; i&lt;pThis-&gt;nOurCerts; ++i) {
				gnutls_x509_crt_deinit(pThis-&gt;pOurCerts[i]);
			}
			pThis-&gt;bOurCertIsInit = 0;
		}
		if(pThis-&gt;bOurKeyIsInit) {
			gnutls_x509_privkey_deinit(pThis-&gt;ourKey);
			pThis-&gt;bOurKeyIsInit = 0;
		}
	} else {
		dbgprintf(&quot;gtlsLoadOurCertKey Successfully Loaded cert '%s' and key: '%s'\n&quot;, certFile, keyFile);
	}
	RETiRet;
}


/* This callback must be associated with a session by calling
 * gnutls_certificate_client_set_retrieve_function(session, cert_callback),
 * before a handshake. We will always return the configured certificate,
 * even if it does not match the peer's trusted CAs. This is necessary
 * to use self-signed certs in fingerprint mode. And, yes, this usage
 * of the callback is quite a hack. But it seems the only way to
 * obey to the IETF -transport-tls I-D.
 * Note: GnuTLS requires the function to return 0 on success and
 * -1 on failure.
 * rgerhards, 2008-05-27
 */
static int
gtlsClientCertCallback(gnutls_session_t session,
	__attribute__((unused)) const gnutls_datum_t* req_ca_rdn,
	int __attribute__((unused)) nreqs,
	__attribute__((unused)) const gnutls_pk_algorithm_t* sign_algos,
	int __attribute__((unused)) sign_algos_length,
#if HAVE_GNUTLS_CERTIFICATE_SET_RETRIEVE_FUNCTION
	gnutls_retr2_st* st
#else
	gnutls_retr_st *st
#endif
	)
{
	nsd_gtls_t *pThis;

	pThis = (nsd_gtls_t*) gnutls_session_get_ptr(session);

#if HAVE_GNUTLS_CERTIFICATE_SET_RETRIEVE_FUNCTION
	st-&gt;cert_type = GNUTLS_CRT_X509;
#else
	st-&gt;type = GNUTLS_CRT_X509;
#endif
	st-&gt;ncerts = pThis-&gt;nOurCerts;
	st-&gt;cert.x509 = pThis-&gt;pOurCerts;
	st-&gt;key.x509 = pThis-&gt;ourKey;
	st-&gt;deinit_all = 0;

	return 0;
}


/* This function extracts some information about this session's peer
 * certificate. Works for X.509 certificates only. Adds all
 * of the info to a cstr_t, which is handed over to the caller.
 * Caller must destruct it when no longer needed.
 * rgerhards, 2008-05-21
 */
static rsRetVal
gtlsGetCertInfo(nsd_gtls_t *const pThis, cstr_t **ppStr)
{
	uchar szBufA[1024];
	uchar *szBuf = szBufA;
	size_t szBufLen = sizeof(szBufA), tmp;
	unsigned int algo, bits;
	time_t expiration_time, activation_time;
	const gnutls_datum_t *cert_list;
	unsigned cert_list_size = 0;
	gnutls_x509_crt_t cert;
	cstr_t *pStr = NULL;
	int gnuRet;
	DEFiRet;
	unsigned iAltName;

	assert(ppStr != NULL);
	ISOBJ_TYPE_assert(pThis, nsd_gtls);

	if(gnutls_certificate_type_get(pThis-&gt;sess) != GNUTLS_CRT_X509)
		return RS_RET_TLS_CERT_ERR;

	cert_list = gnutls_certificate_get_peers(pThis-&gt;sess, &amp;cert_list_size);
	CHKiRet(rsCStrConstructFromszStrf(&amp;pStr, &quot;peer provided %d certificate(s). &quot;, cert_list_size));

	if(cert_list_size &gt; 0) {
		/* we only print information about the first certificate */
		CHKgnutls(gnutls_x509_crt_init(&amp;cert));
		CHKgnutls(gnutls_x509_crt_import(cert, &amp;cert_list[0], GNUTLS_X509_FMT_DER));

		expiration_time = gnutls_x509_crt_get_expiration_time(cert);
		activation_time = gnutls_x509_crt_get_activation_time(cert);
		ctime_r(&amp;activation_time, (char*)szBuf);
		szBuf[ustrlen(szBuf) - 1] = '\0'; /* strip linefeed */
		CHKiRet(rsCStrAppendStrf(pStr, &quot;Certificate 1 info: &quot;
			&quot;certificate valid from %s &quot;, szBuf));
		ctime_r(&amp;expiration_time, (char*)szBuf);
		szBuf[ustrlen(szBuf) - 1] = '\0'; /* strip linefeed */
		CHKiRet(rsCStrAppendStrf(pStr, &quot;to %s; &quot;, szBuf));

		/* Extract some of the public key algorithm's parameters */
		algo = gnutls_x509_crt_get_pk_algorithm(cert, &amp;bits);
		CHKiRet(rsCStrAppendStrf(pStr, &quot;Certificate public key: %s; &quot;,
			gnutls_pk_algorithm_get_name(algo)));

		/* names */
		tmp = szBufLen;
		if(gnutls_x509_crt_get_dn(cert, (char*)szBuf, &amp;tmp)
		    == GNUTLS_E_SHORT_MEMORY_BUFFER) {
			szBufLen = tmp;
			szBuf = malloc(tmp);
			gnutls_x509_crt_get_dn(cert, (char*)szBuf, &amp;tmp);
		}
		CHKiRet(rsCStrAppendStrf(pStr, &quot;DN: %s; &quot;, szBuf));

		tmp = szBufLen;
		if(gnutls_x509_crt_get_issuer_dn(cert, (char*)szBuf, &amp;tmp)
		    == GNUTLS_E_SHORT_MEMORY_BUFFER) {
			szBufLen = tmp;
			szBuf = realloc((szBuf == szBufA) ? NULL : szBuf, tmp);
			gnutls_x509_crt_get_issuer_dn(cert, (char*)szBuf, &amp;tmp);
		}
		CHKiRet(rsCStrAppendStrf(pStr, &quot;Issuer DN: %s; &quot;, szBuf));

		/* dNSName alt name */
		iAltName = 0;
		while(1) { /* loop broken below */
			tmp = szBufLen;
			gnuRet = gnutls_x509_crt_get_subject_alt_name(cert, iAltName,
					szBuf, &amp;tmp, NULL);
			if(gnuRet == GNUTLS_E_SHORT_MEMORY_BUFFER) {
				szBufLen = tmp;
				szBuf = realloc((szBuf == szBufA) ? NULL : szBuf, tmp);
				continue;
			} else if(gnuRet &lt; 0)
				break;
			else if(gnuRet == GNUTLS_SAN_DNSNAME) {
				/* we found it! */
				CHKiRet(rsCStrAppendStrf(pStr, &quot;SAN:DNSname: %s; &quot;, szBuf));
				/* do NOT break, because there may be multiple dNSName's! */
			}
			++iAltName;
		}

		gnutls_x509_crt_deinit(cert);
	}

	cstrFinalize(pStr);
	*ppStr = pStr;

finalize_it:
	if(iRet != RS_RET_OK) {
		if(pStr != NULL)
			rsCStrDestruct(&amp;pStr);
	}
	if(szBuf != szBufA)
		free(szBuf);

	RETiRet;
}



#if 0 /* we may need this in the future - code needs to be looked at then! */
/* This function will print some details of the
 * given pThis-&gt;sess.
 */
static rsRetVal
print_info(nsd_gtls_t *pThis)
{
	const char *tmp;
	gnutls_credentials_type cred;
	gnutls_kx_algorithm kx;
	DEFiRet;

	ISOBJ_TYPE_assert(pThis, nsd_gtls);
	/* print the key exchange's algorithm name
	*/
	kx = gnutls_kx_get(pThis-&gt;sess);
	tmp = gnutls_kx_get_name(kx);
	dbgprintf(&quot;- Key Exchange: %s\n&quot;, tmp);

	/* Check the authentication type used and switch
	* to the appropriate.
	*/
	cred = gnutls_auth_get_type(pThis-&gt;sess);
	switch (cred) {
	case GNUTLS_CRD_ANON:       /* anonymous authentication */
		dbgprintf(&quot;- Anonymous DH using prime of %d bits\n&quot;,
		gnutls_dh_get_prime_bits(pThis-&gt;sess));
		break;
	case GNUTLS_CRD_CERTIFICATE:        /* certificate authentication */
		/* Check if we have been using ephemeral Diffie Hellman.
		*/
		if (kx == GNUTLS_KX_DHE_RSA || kx == GNUTLS_KX_DHE_DSS) {
		 dbgprintf(&quot;\n- Ephemeral DH using prime of %d bits\n&quot;,
			gnutls_dh_get_prime_bits(pThis-&gt;sess));
		}

		/* if the certificate list is available, then
		* print some information about it.
		*/
		gtlsPrintCert(pThis);
		break;
	case GNUTLS_CRD_SRP:        /* certificate authentication */
		dbgprintf(&quot;GNUTLS_CRD_SRP/IA&quot;);
		break;
	case GNUTLS_CRD_PSK:        /* certificate authentication */
		dbgprintf(&quot;GNUTLS_CRD_PSK&quot;);
		break;
	case GNUTLS_CRD_IA:        /* certificate authentication */
		dbgprintf(&quot;GNUTLS_CRD_IA&quot;);
		break;
	} /* switch */

	/* print the protocol's name (ie TLS 1.0) */
	tmp = gnutls_protocol_get_name(gnutls_protocol_get_version(pThis-&gt;sess));
	dbgprintf(&quot;- Protocol: %s\n&quot;, tmp);

	/* print the certificate type of the peer.
	* ie X.509
	*/
	tmp = gnutls_certificate_type_get_name(
	gnutls_certificate_type_get(pThis-&gt;sess));

	dbgprintf(&quot;- Certificate Type: %s\n&quot;, tmp);

	/* print the compression algorithm (if any)
	*/
	tmp = gnutls_compression_get_name( gnutls_compression_get(pThis-&gt;sess));
	dbgprintf(&quot;- Compression: %s\n&quot;, tmp);

	/* print the name of the cipher used.
	* ie 3DES.
	*/
	tmp = gnutls_cipher_get_name(gnutls_cipher_get(pThis-&gt;sess));
	dbgprintf(&quot;- Cipher: %s\n&quot;, tmp);

	/* Print the MAC algorithms name.
	* ie SHA1
	*/
	tmp = gnutls_mac_get_name(gnutls_mac_get(pThis-&gt;sess));
	dbgprintf(&quot;- MAC: %s\n&quot;, tmp);

	RETiRet;
}
#endif


/* Convert a fingerprint to printable data. The  conversion is carried out
 * according IETF I-D syslog-transport-tls-12. The fingerprint string is
 * returned in a new cstr object. It is the caller's responsibility to
 * destruct that object.
 * rgerhards, 2008-05-08
 */
static rsRetVal
GenFingerprintStr(uchar *pFingerprint, size_t sizeFingerprint, cstr_t **ppStr)
{
	cstr_t *pStr = NULL;
	uchar buf[4];
	size_t i;
	DEFiRet;

	CHKiRet(rsCStrConstruct(&amp;pStr));
	CHKiRet(rsCStrAppendStrWithLen(pStr, (uchar*)&quot;SHA1&quot;, 4));
	for(i = 0 ; i &lt; sizeFingerprint ; ++i) {
		snprintf((char*)buf, sizeof(buf), &quot;:%2.2X&quot;, pFingerprint[i]);
		CHKiRet(rsCStrAppendStrWithLen(pStr, buf, 3));
	}
	cstrFinalize(pStr);

	*ppStr = pStr;

finalize_it:
	if(iRet != RS_RET_OK) {
		if(pStr != NULL)
			rsCStrDestruct(&amp;pStr);
	}
	RETiRet;
}


/* a thread-safe variant of gnutls_strerror
 * The caller must free the returned string.
 * rgerhards, 2008-04-30
 */
uchar *gtlsStrerror(int error)
{
	uchar *pErr;

	pthread_mutex_lock(&amp;mutGtlsStrerror);
	pErr = (uchar*) strdup(gnutls_strerror(error));
	pthread_mutex_unlock(&amp;mutGtlsStrerror);

	return pErr;
}


/* try to receive a record from the remote peer. This works with
 * our own abstraction and handles local buffering and EAGAIN.
 * See details on local buffering in Rcv(9 header-comment.
 * This function MUST only be called when the local buffer is
 * empty. Calling it otherwise will cause losss of current buffer
 * data.
 * rgerhards, 2008-06-24
 */
rsRetVal
gtlsRecordRecv(nsd_gtls_t *pThis)
{
	ssize_t lenRcvd;
	DEFiRet;

	ISOBJ_TYPE_assert(pThis, nsd_gtls);
	DBGPRINTF(&quot;gtlsRecordRecv: start (Pending Data: %zd | Wanted Direction: %s)\n&quot;,
		gnutls_record_check_pending(pThis-&gt;sess),
		(gnutls_record_get_direction(pThis-&gt;sess) == gtlsDir_READ ? &quot;READ&quot; : &quot;WRITE&quot;) );
	lenRcvd = gnutls_record_recv(pThis-&gt;sess, pThis-&gt;pszRcvBuf, NSD_GTLS_MAX_RCVBUF);
	if(lenRcvd &gt;= 0) {
		DBGPRINTF(&quot;gtlsRecordRecv: gnutls_record_recv received %zd bytes\n&quot;, lenRcvd);
		pThis-&gt;lenRcvBuf = lenRcvd;
		pThis-&gt;ptrRcvBuf = 0;

		/* Check for additional data in SSL buffer */
		size_t stBytesLeft = gnutls_record_check_pending(pThis-&gt;sess);
		if (stBytesLeft &gt; 0 ){
			DBGPRINTF(&quot;gtlsRecordRecv: %zd Bytes pending after gnutls_record_recv, expand buffer.\n&quot;,
				stBytesLeft);
			/* realloc buffer size and preserve char content */
			char *const newbuf = realloc(pThis-&gt;pszRcvBuf, NSD_GTLS_MAX_RCVBUF+stBytesLeft);
			CHKmalloc(newbuf);
			pThis-&gt;pszRcvBuf = newbuf;

			/* 2nd read will read missing bytes from the current SSL Packet */
			lenRcvd = gnutls_record_recv(pThis-&gt;sess, pThis-&gt;pszRcvBuf+NSD_GTLS_MAX_RCVBUF, stBytesLeft);
			if(lenRcvd &gt; 0) {
				DBGPRINTF(&quot;gtlsRecordRecv: 2nd SSL_read received %zd bytes\n&quot;,
					(NSD_GTLS_MAX_RCVBUF+lenRcvd));
				pThis-&gt;lenRcvBuf = NSD_GTLS_MAX_RCVBUF+lenRcvd;
			} else {
				if (lenRcvd == GNUTLS_E_AGAIN || lenRcvd == GNUTLS_E_INTERRUPTED) {
					goto sslerragain;	/* Go to ERR AGAIN handling */
				} else {
					/* Do all other error handling */
					int gnuRet = lenRcvd;
					ABORTgnutls;
				}
			}
		}
	} else if(lenRcvd == GNUTLS_E_AGAIN || lenRcvd == GNUTLS_E_INTERRUPTED) {
sslerragain:
		/* Check if the underlaying file descriptor needs to read or write data!*/
		if (gnutls_record_get_direction(pThis-&gt;sess) == gtlsDir_READ) {
			pThis-&gt;rtryCall = gtlsRtry_recv;
			dbgprintf(&quot;GnuTLS receive requires a retry, this most probably is OK and no error condition\n&quot;);
			ABORT_FINALIZE(RS_RET_RETRY);
		} else {
			uchar *pErr = gtlsStrerror(lenRcvd);
			LogError(0, RS_RET_GNUTLS_ERR, &quot;GnuTLS receive error %zd has wrong read direction(wants write) &quot;
				&quot;- this could be caused by a broken connection. GnuTLS reports: %s\n&quot;,
				lenRcvd, pErr);
			free(pErr);
			ABORT_FINALIZE(RS_RET_GNUTLS_ERR);
		}
	} else {
		int gnuRet = lenRcvd;
		ABORTgnutls;
	}

finalize_it:
	dbgprintf(&quot;gtlsRecordRecv return. nsd %p, iRet %d, lenRcvd %d, lenRcvBuf %d, ptrRcvBuf %d\n&quot;,
	pThis, iRet, (int) lenRcvd, pThis-&gt;lenRcvBuf, pThis-&gt;ptrRcvBuf);
	RETiRet;
}


/* add our own certificate to the certificate set, so that the peer
 * can identify us. Please note that we try to use mutual authentication,
 * so we always add a cert, even if we are in the client role (later,
 * this may be controlled by a config setting).
 * rgerhards, 2008-05-15
 */
static rsRetVal
gtlsAddOurCert(nsd_gtls_t *const pThis)
{
	int gnuRet = 0;
	const uchar *keyFile;
	const uchar *certFile;
	uchar *pGnuErr; /* for GnuTLS error reporting */
	DEFiRet;

	certFile = (pThis-&gt;pszCertFile == NULL) ? glbl.GetDfltNetstrmDrvrCertFile(runConf) : pThis-&gt;pszCertFile;
	keyFile = (pThis-&gt;pszKeyFile == NULL) ? glbl.GetDfltNetstrmDrvrKeyFile(runConf) : pThis-&gt;pszKeyFile;
	dbgprintf(&quot;GTLS certificate file: '%s'\n&quot;, certFile);
	dbgprintf(&quot;GTLS key file: '%s'\n&quot;, keyFile);
	if(certFile == NULL) {
		LogMsg(0, RS_RET_CERT_MISSING, LOG_WARNING, &quot;warning: certificate file is not set&quot;);
	}
	if(keyFile == NULL) {
		LogMsg(0, RS_RET_CERTKEY_MISSING, LOG_WARNING, &quot;warning: key file is not set&quot;);
	}

	/* set certificate in gnutls */
	if(certFile != NULL &amp;&amp; keyFile != NULL) {
		CHKgnutls(gnutls_certificate_set_x509_key_file(pThis-&gt;xcred, (char*)certFile, (char*)keyFile,
			GNUTLS_X509_FMT_PEM));
	}

finalize_it:
	if(iRet != RS_RET_OK &amp;&amp; iRet != RS_RET_CERT_MISSING &amp;&amp; iRet != RS_RET_CERTKEY_MISSING) {
		pGnuErr = gtlsStrerror(gnuRet);
		errno = 0;
		LogError(0, iRet, &quot;error adding our certificate. GnuTLS error %d, message: '%s', &quot;
				&quot;key: '%s', cert: '%s'&quot;, gnuRet, pGnuErr, keyFile, certFile);
		free(pGnuErr);
	}
	RETiRet;
}

/*
* removecomment ifdef out if needed
*/
#ifdef false

static void print_cipher_suite_list(const char *priorities)
{
	size_t i;
	int ret;
	unsigned int idx;
	const char *name;
	const char *err;
	unsigned char id[2];
	gnutls_protocol_t version;
	gnutls_priority_t pcache;

	if (priorities != NULL) {
		printf(&quot;print_cipher_suite_list: Cipher suites for %s\n&quot;, priorities);

		ret = gnutls_priority_init(&amp;pcache, priorities, &amp;err);
		if (ret &lt; 0) {
			fprintf(stderr, &quot;print_cipher_suite_list: Syntax error at: %s\n&quot;, err);
			exit(1);
		}

		for (i = 0;; i++) {
			ret = gnutls_priority_get_cipher_suite_index(pcache, i, &amp;idx);
			if (ret == GNUTLS_E_REQUESTED_DATA_NOT_AVAILABLE)
				break;
			if (ret == GNUTLS_E_UNKNOWN_CIPHER_SUITE)
				continue;

			name = gnutls_cipher_suite_info(idx, id, NULL, NULL, NULL, &amp;version);

			if (name != NULL)
				dbgprintf(&quot;print_cipher_suite_list: %-50s\t0x%02x, 0x%02x\t%s\n&quot;,
				name, (unsigned char) id[0],
				(unsigned char) id[1],
				gnutls_protocol_get_name(version));
		}

		return;
	}
}
#endif

/* initialize GnuTLS credential structure (certs etc) */
static rsRetVal
gtlsInitCred(nsd_gtls_t *const pThis )
{
	int gnuRet;
	const uchar *cafile;
	DEFiRet;

	/* X509 stuff */
	CHKgnutls(gnutls_certificate_allocate_credentials(&amp;pThis-&gt;xcred));

	/* sets the trusted cas file */
	cafile = (pThis-&gt;pszCAFile == NULL) ? glbl.GetDfltNetstrmDrvrCAF(runConf) : pThis-&gt;pszCAFile;
	if(cafile == NULL) {
		LogMsg(0, RS_RET_CA_CERT_MISSING, LOG_WARNING,
			&quot;Warning: CA certificate is not set&quot;);
	} else {
		dbgprintf(&quot;GTLS CA file: '%s'\n&quot;, cafile);
		gnuRet = gnutls_certificate_set_x509_trust_file(pThis-&gt;xcred, (char*)cafile, GNUTLS_X509_FMT_PEM);
		if(gnuRet == GNUTLS_E_FILE_ERROR) {
			LogError(0, RS_RET_GNUTLS_ERR,
				&quot;error reading certificate file '%s' - a common cause is that the &quot;
				&quot;file  does not exist&quot;, cafile);
			ABORT_FINALIZE(RS_RET_GNUTLS_ERR);
		} else if(gnuRet &lt; 0) {
			/* TODO; a more generic error-tracking function (this one based on CHKgnutls()) */
			uchar *pErr = gtlsStrerror(gnuRet);
			LogError(0, RS_RET_GNUTLS_ERR, &quot;unexpected GnuTLS error %d in %s:%d: %s\n&quot;,
			gnuRet, __FILE__, __LINE__, pErr);
			free(pErr);
			ABORT_FINALIZE(RS_RET_GNUTLS_ERR);
		}
	}


finalize_it:
	RETiRet;
}


/* globally initialize GnuTLS */
static rsRetVal
gtlsGlblInit(void)
{
	int gnuRet;
	DEFiRet;

	dbgprintf(&quot;gtlsGlblInit: Running Version: '%#010x'\n&quot;, GNUTLS_VERSION_NUMBER);

	/* gcry_control must be called first, so that the thread system is correctly set up */
	#if GNUTLS_VERSION_NUMBER &lt;= 0x020b00
	gcry_control (GCRYCTL_SET_THREAD_CBS, &amp;gcry_threads_pthread);
	#endif
	CHKgnutls(gnutls_global_init());

	if(GetGnuTLSLoglevel(runConf) &gt; 0){
		gnutls_global_set_log_function(logFunction);
		gnutls_global_set_log_level(GetGnuTLSLoglevel(runConf));
		/* 0 (no) to 9 (most), 10 everything */
	}

	/* Init Anon cipher helpers */
	CHKgnutls(gnutls_dh_params_init(&amp;dh_params));
	CHKgnutls(gnutls_dh_params_generate2(dh_params, dhBits));

	/* Allocate ANON Client Cred */
	CHKgnutls(gnutls_anon_allocate_client_credentials(&amp;anoncred));

	/* Allocate ANON Server Cred */
	CHKgnutls(gnutls_anon_allocate_server_credentials(&amp;anoncredSrv));
	gnutls_anon_set_server_dh_params(anoncredSrv, dh_params);

finalize_it:
	RETiRet;
}

static rsRetVal
gtlsInitSession(nsd_gtls_t *pThis)
{
	DEFiRet;
	int gnuRet = 0;
	gnutls_session_t session;

	gnutls_init(&amp;session, GNUTLS_SERVER);
	pThis-&gt;bHaveSess = 1;
	pThis-&gt;bIsInitiator = 0;
	pThis-&gt;sess = session;

	/* Moved CertKey Loading to top */
#	if HAVE_GNUTLS_CERTIFICATE_SET_RETRIEVE_FUNCTION
	/* store a pointer to ourselfs (needed by callback) */
	gnutls_session_set_ptr(pThis-&gt;sess, (void*)pThis);
	iRet = gtlsLoadOurCertKey(pThis); /* first load .pem files */
	if(iRet == RS_RET_OK) {
		dbgprintf(&quot;gtlsInitSession: enable certificate checking (VerifyDepth=%d)\n&quot;, pThis-&gt;DrvrVerifyDepth);
		gnutls_certificate_set_retrieve_function(pThis-&gt;xcred, gtlsClientCertCallback);
		if (pThis-&gt;DrvrVerifyDepth != 0){
			gnutls_certificate_set_verify_limits(pThis-&gt;xcred, 8200, pThis-&gt;DrvrVerifyDepth);
		}
	} else if(iRet == RS_RET_CERTLESS) {
		dbgprintf(&quot;gtlsInitSession: certificates not configured, not loaded.\n&quot;);
	} else {
		ABORT_FINALIZE(iRet); /* we have an error case! */
	}
#	endif

	/* avoid calling all the priority functions, since the defaults are adequate. */
	CHKgnutls(gnutls_credentials_set(pThis-&gt;sess, GNUTLS_CRD_CERTIFICATE, pThis-&gt;xcred));

	/* check for anon authmode */
	if (pThis-&gt;authMode == GTLS_AUTH_CERTANON) {
		dbgprintf(&quot;gtlsInitSession: anon authmode, gnutls_credentials_set GNUTLS_CRD_ANON\n&quot;);
		CHKgnutls(gnutls_credentials_set(pThis-&gt;sess, GNUTLS_CRD_ANON, anoncredSrv));
		gnutls_dh_set_prime_bits(pThis-&gt;sess, dhMinBits);
	}

	/* request client certificate if any.  */
	gnutls_certificate_server_set_request( pThis-&gt;sess, GNUTLS_CERT_REQUEST);


finalize_it:
	if(iRet != RS_RET_OK &amp;&amp; iRet != RS_RET_CERTLESS) {
		LogError(0, iRet, &quot;gtlsInitSession failed to INIT Session %d&quot;, gnuRet);
	}

	RETiRet;
}


/* Obtain the CN from the DN field and hand it back to the caller
 * (which is responsible for destructing it). We try to follow
 * RFC2253 as far as it makes sense for our use-case. This function
 * is considered a compromise providing good-enough correctness while
 * limiting code size and complexity. If a problem occurs, we may enhance
 * this function. A (pointer to a) certificate must be caller-provided.
 * If no CN is contained in the cert, no string is returned
 * (*ppstrCN remains NULL). *ppstrCN MUST be NULL on entry!
 * rgerhards, 2008-05-22
 */
static rsRetVal
gtlsGetCN(gnutls_x509_crt_t *pCert, cstr_t **ppstrCN)
{
	DEFiRet;
	int gnuRet;
	int i;
	int bFound;
	cstr_t *pstrCN = NULL;
	size_t size;
	/* big var the last, so we hope to have all we usually neeed within one mem cache line */
	uchar szDN[1024]; /* this should really be large enough for any non-malicious case... */

	assert(pCert != NULL);
	assert(ppstrCN != NULL);
	assert(*ppstrCN == NULL);

	size = sizeof(szDN);
	CHKgnutls(gnutls_x509_crt_get_dn(*pCert, (char*)szDN, &amp;size));

	/* now search for the CN part */
	i = 0;
	bFound = 0;
	while(!bFound &amp;&amp; szDN[i] != '\0') {
		/* note that we do not overrun our string due to boolean shortcut
		 * operations. If we have '\0', the if does not match and evaluation
		 * stops. Order of checks is obviously important!
		 */
		if(szDN[i] == 'C' &amp;&amp; szDN[i+1] == 'N' &amp;&amp; szDN[i+2] == '=') {
			bFound = 1;
			i += 2;
		}
		i++;

	}

	if(!bFound) {
		FINALIZE; /* we are done */
	}

	/* we found a common name, now extract it */
	CHKiRet(cstrConstruct(&amp;pstrCN));
	while(szDN[i] != '\0' &amp;&amp; szDN[i] != ',') {
		if(szDN[i] == '\\') {
			/* hex escapes are not implemented */
			++i; /* escape char processed */
			if(szDN[i] == '\0')
				ABORT_FINALIZE(RS_RET_CERT_INVALID_DN);
			CHKiRet(cstrAppendChar(pstrCN, szDN[i]));
		} else {
			CHKiRet(cstrAppendChar(pstrCN, szDN[i]));
		}
		++i; /* char processed */
	}
	cstrFinalize(pstrCN);

	/* we got it - we ignore the rest of the DN string (if any). So we may
	 * not detect if it contains more than one CN
	 */

	*ppstrCN = pstrCN;

finalize_it:
	if(iRet != RS_RET_OK) {
		if(pstrCN != NULL)
			cstrDestruct(&amp;pstrCN);
	}

	RETiRet;
}


/* Check the peer's ID in fingerprint auth mode.
 * rgerhards, 2008-05-22
 */
static rsRetVal
gtlsChkPeerFingerprint(nsd_gtls_t *pThis, gnutls_x509_crt_t *pCert)
{
	uchar fingerprint[20];
	size_t size;
	cstr_t *pstrFingerprint = NULL;
	int bFoundPositiveMatch;
	permittedPeers_t *pPeer;
	int gnuRet;
	DEFiRet;

	ISOBJ_TYPE_assert(pThis, nsd_gtls);

	/* obtain the SHA1 fingerprint */
	size = sizeof(fingerprint);
	CHKgnutls(gnutls_x509_crt_get_fingerprint(*pCert, GNUTLS_DIG_SHA1, fingerprint, &amp;size));
	CHKiRet(GenFingerprintStr(fingerprint, size, &amp;pstrFingerprint));
	dbgprintf(&quot;peer's certificate SHA1 fingerprint: %s\n&quot;, cstrGetSzStrNoNULL(pstrFingerprint));

	/* now search through the permitted peers to see if we can find a permitted one */
	bFoundPositiveMatch = 0;
	pPeer = pThis-&gt;pPermPeers;
	while(pPeer != NULL &amp;&amp; !bFoundPositiveMatch) {
		if(!rsCStrSzStrCmp(pstrFingerprint, pPeer-&gt;pszID, strlen((char*) pPeer-&gt;pszID))) {
			bFoundPositiveMatch = 1;
		} else {
			pPeer = pPeer-&gt;pNext;
		}
	}

	if(!bFoundPositiveMatch) {
		dbgprintf(&quot;invalid peer fingerprint, not permitted to talk to it\n&quot;);
		if(pThis-&gt;bReportAuthErr == 1) {
			errno = 0;
			LogError(0, RS_RET_INVALID_FINGERPRINT, &quot;error: peer fingerprint '%s' unknown - we are &quot;
					&quot;not permitted to talk to it&quot;, cstrGetSzStrNoNULL(pstrFingerprint));
			pThis-&gt;bReportAuthErr = 0;
		}
		ABORT_FINALIZE(RS_RET_INVALID_FINGERPRINT);
	}

finalize_it:
	if(pstrFingerprint != NULL)
		cstrDestruct(&amp;pstrFingerprint);
	RETiRet;
}


/* Perform a match on ONE peer name obtained from the certificate. This name
 * is checked against the set of configured credentials. *pbFoundPositiveMatch is
 * set to 1 if the ID matches. *pbFoundPositiveMatch must have been initialized
 * to 0 by the caller (this is a performance enhancement as we expect to be
 * called multiple times).
 * TODO: implemet wildcards?
 * rgerhards, 2008-05-26
 */
static rsRetVal
gtlsChkOnePeerName(nsd_gtls_t *pThis, uchar *pszPeerID, int *pbFoundPositiveMatch)
{
	permittedPeers_t *pPeer;
	DEFiRet;

	ISOBJ_TYPE_assert(pThis, nsd_gtls);
	assert(pszPeerID != NULL);
	assert(pbFoundPositiveMatch != NULL);

	if(pThis-&gt;pPermPeers) { /* do we have configured peer IDs? */
		pPeer = pThis-&gt;pPermPeers;
		while(pPeer != NULL) {
			CHKiRet(net.PermittedPeerWildcardMatch(pPeer, pszPeerID, pbFoundPositiveMatch));
			if(*pbFoundPositiveMatch)
				break;
			pPeer = pPeer-&gt;pNext;
		}
	} else {
		/* we do not have configured peer IDs, so we use defaults */
		if(   pThis-&gt;pszConnectHost
		   &amp;&amp; !strcmp((char*)pszPeerID, (char*)pThis-&gt;pszConnectHost)) {
			*pbFoundPositiveMatch = 1;
		}
	}

finalize_it:
	RETiRet;
}


/* Check the peer's ID in name auth mode.
 * rgerhards, 2008-05-22
 */
static rsRetVal
gtlsChkPeerName(nsd_gtls_t *pThis, gnutls_x509_crt_t *pCert)
{
	uchar lnBuf[256];
	char szAltName[1024]; /* this is sufficient for the DNSNAME... */
	int iAltName;
	size_t szAltNameLen;
	int bFoundPositiveMatch;
	int bHaveSAN = 0;
	cstr_t *pStr = NULL;
	cstr_t *pstrCN = NULL;
	int gnuRet;
	DEFiRet;

	ISOBJ_TYPE_assert(pThis, nsd_gtls);

	bFoundPositiveMatch = 0;
	CHKiRet(rsCStrConstruct(&amp;pStr));

	/* first search through the dNSName subject alt names */
	iAltName = 0;
	while(!bFoundPositiveMatch) { /* loop broken below */
		szAltNameLen = sizeof(szAltName);
		gnuRet = gnutls_x509_crt_get_subject_alt_name(*pCert, iAltName,
				szAltName, &amp;szAltNameLen, NULL);
		if(gnuRet &lt; 0)
			break;
		else if(gnuRet == GNUTLS_SAN_DNSNAME) {
			bHaveSAN = 1;
			dbgprintf(&quot;subject alt dnsName: '%s'\n&quot;, szAltName);
			snprintf((char*)lnBuf, sizeof(lnBuf), &quot;DNSname: %s; &quot;, szAltName);
			CHKiRet(rsCStrAppendStr(pStr, lnBuf));
			CHKiRet(gtlsChkOnePeerName(pThis, (uchar*)szAltName, &amp;bFoundPositiveMatch));
			/* do NOT break, because there may be multiple dNSName's! */
		}
		++iAltName;
	}

	/* Check also CN only if not configured per stricter RFC 6125 or no SAN present*/
	if(!bFoundPositiveMatch &amp;&amp; (!pThis-&gt;bSANpriority || !bHaveSAN)) {
		CHKiRet(gtlsGetCN(pCert, &amp;pstrCN));
		if(pstrCN != NULL) { /* NULL if there was no CN present */
			dbgprintf(&quot;gtls now checking auth for CN '%s'\n&quot;, cstrGetSzStrNoNULL(pstrCN));
			snprintf((char*)lnBuf, sizeof(lnBuf), &quot;CN: %s; &quot;, cstrGetSzStrNoNULL(pstrCN));
			CHKiRet(rsCStrAppendStr(pStr, lnBuf));
			CHKiRet(gtlsChkOnePeerName(pThis, cstrGetSzStrNoNULL(pstrCN), &amp;bFoundPositiveMatch));
		}
	}

	if(!bFoundPositiveMatch) {
		dbgprintf(&quot;invalid peer name, not permitted to talk to it\n&quot;);
		if(pThis-&gt;bReportAuthErr == 1) {
			cstrFinalize(pStr);
			errno = 0;
			LogError(0, RS_RET_INVALID_FINGERPRINT, &quot;error: peer name not authorized -  &quot;
					&quot;not permitted to talk to it. Names: %s&quot;,
					cstrGetSzStrNoNULL(pStr));
			pThis-&gt;bReportAuthErr = 0;
		}
		ABORT_FINALIZE(RS_RET_INVALID_FINGERPRINT);
	}

finalize_it:
	if(pStr != NULL)
		rsCStrDestruct(&amp;pStr);
	if(pstrCN != NULL)
		rsCStrDestruct(&amp;pstrCN);
	RETiRet;
}


/* check the ID of the remote peer - used for both fingerprint and
 * name authentication. This is common code. Will call into specific
 * drivers once the certificate has been obtained.
 * rgerhards, 2008-05-08
 */
static rsRetVal
gtlsChkPeerID(nsd_gtls_t *pThis)
{
	const gnutls_datum_t *cert_list;
	unsigned int list_size = 0;
	gnutls_x509_crt_t cert;
	int bMustDeinitCert = 0;
	int gnuRet;
	DEFiRet;

	ISOBJ_TYPE_assert(pThis, nsd_gtls);

	/* This function only works for X.509 certificates.  */
	if(gnutls_certificate_type_get(pThis-&gt;sess) != GNUTLS_CRT_X509)
		return RS_RET_TLS_CERT_ERR;

	cert_list = gnutls_certificate_get_peers(pThis-&gt;sess, &amp;list_size);

	if(list_size &lt; 1) {
		if(pThis-&gt;bReportAuthErr == 1) {
			errno = 0;
			LogError(0, RS_RET_TLS_NO_CERT, &quot;error: peer did not provide a certificate, &quot;
					&quot;not permitted to talk to it&quot;);
			pThis-&gt;bReportAuthErr = 0;
		}
		ABORT_FINALIZE(RS_RET_TLS_NO_CERT);
	}

	/* If we reach this point, we have at least one valid certificate.
	 * We always use only the first certificate. As of GnuTLS documentation, the
	 * first certificate always contains the remote peer's own certificate. All other
	 * certificates are issuer's certificates (up the chain). We are only interested
	 * in the first certificate, which is our peer. -- rgerhards, 2008-05-08
	 */
	CHKgnutls(gnutls_x509_crt_init(&amp;cert));
	bMustDeinitCert = 1; /* indicate cert is initialized and must be freed on exit */
	CHKgnutls(gnutls_x509_crt_import(cert, &amp;cert_list[0], GNUTLS_X509_FMT_DER));

	/* Now we see which actual authentication code we must call.  */
	if(pThis-&gt;authMode == GTLS_AUTH_CERTFINGERPRINT) {
		CHKiRet(gtlsChkPeerFingerprint(pThis, &amp;cert));
	} else {
		assert(pThis-&gt;authMode == GTLS_AUTH_CERTNAME);
		CHKiRet(gtlsChkPeerName(pThis, &amp;cert));
	}

finalize_it:
	if(bMustDeinitCert)
		gnutls_x509_crt_deinit(cert);

	RETiRet;
}


/* Verify the validity of the remote peer's certificate.
 * rgerhards, 2008-05-21
 */
static rsRetVal
gtlsChkPeerCertValidity(nsd_gtls_t *pThis)
{
	DEFiRet;
	const char *pszErrCause;
	int gnuRet;
	cstr_t *pStr = NULL;
	unsigned stateCert;
	const gnutls_datum_t *cert_list;
	unsigned cert_list_size = 0;
	gnutls_x509_crt_t cert;
	unsigned i;
	time_t ttCert;
	time_t ttNow;
	sbool bAbort = RSFALSE;
	int iAbortCode = RS_RET_OK;

	ISOBJ_TYPE_assert(pThis, nsd_gtls);

	/* check if we have at least one cert */
	cert_list = gnutls_certificate_get_peers(pThis-&gt;sess, &amp;cert_list_size);
	if(cert_list_size &lt; 1) {
		errno = 0;
		LogError(0, RS_RET_TLS_NO_CERT,
			&quot;peer did not provide a certificate, not permitted to talk to it&quot;);
		ABORT_FINALIZE(RS_RET_TLS_NO_CERT);
	}
#ifdef EXTENDED_CERT_CHECK_AVAILABLE
	if (pThis-&gt;dataTypeCheck == GTLS_NONE) {
#endif
		CHKgnutls(gnutls_certificate_verify_peers2(pThis-&gt;sess, &amp;stateCert));
#ifdef EXTENDED_CERT_CHECK_AVAILABLE
	} else { /* we have configured data to check in addition to cert */
		gnutls_typed_vdata_st data;
		data.type = GNUTLS_DT_KEY_PURPOSE_OID;
		if (pThis-&gt;bIsInitiator) { /* client mode */
			data.data = (uchar *)GNUTLS_KP_TLS_WWW_SERVER;
		} else { /* server mode */
			data.data = (uchar *)GNUTLS_KP_TLS_WWW_CLIENT;
		}
		data.size = ustrlen(data.data);
		CHKgnutls(gnutls_certificate_verify_peers(pThis-&gt;sess, &amp;data, 1, &amp;stateCert));
	}
#endif

	if(stateCert &amp; GNUTLS_CERT_INVALID) {
		/* Default abort code */
		iAbortCode = RS_RET_CERT_INVALID;

		/* provide error details if we have them */
		if (stateCert &amp; GNUTLS_CERT_EXPIRED ) {
			dbgprintf(&quot;GnuTLS returned GNUTLS_CERT_EXPIRED, handling mode %d ...\n&quot;,
				pThis-&gt;permitExpiredCerts);
			/* Handle expired certs */
			if (pThis-&gt;permitExpiredCerts == GTLS_EXPIRED_DENY) {
				bAbort = RSTRUE;
				iAbortCode = RS_RET_CERT_EXPIRED;
			} else if (pThis-&gt;permitExpiredCerts == GTLS_EXPIRED_WARN) {
				LogMsg(0, RS_RET_NO_ERRCODE, LOG_WARNING,
					&quot;Warning, certificate expired but expired certs are permitted&quot;);
			} else {
				dbgprintf(&quot;GnuTLS returned GNUTLS_CERT_EXPIRED, but expired certs are permitted.\n&quot;);
			}
			pszErrCause = &quot;certificate expired&quot;;
		} else if(stateCert &amp; GNUTLS_CERT_SIGNER_NOT_FOUND) {
			pszErrCause = &quot;signer not found&quot;;
			bAbort = RSTRUE;
		} else if(stateCert &amp; GNUTLS_CERT_SIGNER_NOT_CA) {
			pszErrCause = &quot;signer is not a CA&quot;;
			bAbort = RSTRUE;
<A NAME="2"></A>		} else if(stateCert &amp; GNUTLS_CERT_INSECURE_ALGORITHM) {
			pszErrCause = &quot;insecure algorithm&quot;;
			bAbort = RSTRUE;
<FONT color="#980517"><A HREF="javascript:ZweiFrames('match2224-1.html#2',3,'match2224-top.html#2',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>		} else if(stateCert &amp; GNUTLS_CERT_REVOKED) {
			pszErrCause = &quot;certificate revoked&quot;;
			bAbort = RSTRUE;
#ifdef EXTENDED_CERT_CHECK_AVAILABLE
		} else if(stateCert &amp; GNUTLS_CERT_PURPOSE_MISMATCH) {
			pszErrCause = &quot;key purpose OID does not match&quot;;
			bAbort = RSTRUE;
#endif
		} else {
			pszErrCause = &quot;GnuTLS returned no specific reason&quot;;</B></FONT>
			dbgprintf(&quot;GnuTLS returned no specific reason for GNUTLS_CERT_INVALID, certificate &quot;
				 &quot;status is %d\n&quot;, stateCert);
			bAbort = RSTRUE;
		}
	}

	if (bAbort == RSTRUE) {
		LogError(0, NO_ERRCODE, &quot;not permitted to talk to peer, certificate invalid: %s&quot;,
				pszErrCause);
		gtlsGetCertInfo(pThis, &amp;pStr);
		LogError(0, NO_ERRCODE, &quot;invalid cert info: %s&quot;, cstrGetSzStrNoNULL(pStr));
		cstrDestruct(&amp;pStr);
		ABORT_FINALIZE(iAbortCode);
	}

	/* get current time for certificate validation */
	if(datetime.GetTime(&amp;ttNow) == -1)
		ABORT_FINALIZE(RS_RET_SYS_ERR);

	/* as it looks, we need to validate the expiration dates ourselves...
	 * We need to loop through all certificates as we need to make sure the
	 * interim certificates are also not expired.
	 */
	for(i = 0 ; i &lt; cert_list_size ; ++i) {
		CHKgnutls(gnutls_x509_crt_init(&amp;cert));
		CHKgnutls(gnutls_x509_crt_import(cert, &amp;cert_list[i], GNUTLS_X509_FMT_DER));
		ttCert = gnutls_x509_crt_get_activation_time(cert);
		if(ttCert == -1)
			ABORT_FINALIZE(RS_RET_TLS_CERT_ERR);
		else if(ttCert &gt; ttNow) {
			LogError(0, RS_RET_CERT_NOT_YET_ACTIVE, &quot;not permitted to talk to peer: &quot;
					&quot;certificate %d not yet active&quot;, i);
			gtlsGetCertInfo(pThis, &amp;pStr);
			LogError(0, RS_RET_CERT_NOT_YET_ACTIVE,
				&quot;invalid cert info: %s&quot;, cstrGetSzStrNoNULL(pStr));
			cstrDestruct(&amp;pStr);
			ABORT_FINALIZE(RS_RET_CERT_NOT_YET_ACTIVE);
		}

		gnutls_x509_crt_deinit(cert);

	}

finalize_it:
	RETiRet;
}


/* check if it is OK to talk to the remote peer
 * rgerhards, 2008-05-21
 */
rsRetVal
gtlsChkPeerAuth(nsd_gtls_t *pThis)
{
	DEFiRet;

	ISOBJ_TYPE_assert(pThis, nsd_gtls);

	/* call the actual function based on current auth mode */
	switch(pThis-&gt;authMode) {
		case GTLS_AUTH_CERTNAME:
			/* if we check the name, we must ensure the cert is valid */
			CHKiRet(gtlsChkPeerCertValidity(pThis));
			CHKiRet(gtlsChkPeerID(pThis));
			break;
		case GTLS_AUTH_CERTFINGERPRINT:
			CHKiRet(gtlsChkPeerID(pThis));
			break;
		case GTLS_AUTH_CERTVALID:
			CHKiRet(gtlsChkPeerCertValidity(pThis));
			break;
		case GTLS_AUTH_CERTANON:
			FINALIZE;
			break;
	}

finalize_it:
	RETiRet;
}


/* globally de-initialize GnuTLS */
static rsRetVal
gtlsGlblExit(void)
{
	DEFiRet;
	gnutls_global_deinit();
	RETiRet;
}


/* end a GnuTLS session
 * The function checks if we have a session and ends it only if so. So it can
 * always be called, even if there currently is no session.
 */
static rsRetVal
gtlsEndSess(nsd_gtls_t *pThis)
{
	int gnuRet;
	DEFiRet;

	if(pThis-&gt;bHaveSess) {
		if(pThis-&gt;bIsInitiator) {
			gnuRet = gnutls_bye(pThis-&gt;sess, GNUTLS_SHUT_WR);
			while(gnuRet == GNUTLS_E_INTERRUPTED || gnuRet == GNUTLS_E_AGAIN) {
				gnuRet = gnutls_bye(pThis-&gt;sess, GNUTLS_SHUT_WR);
			}
		}
		gnutls_deinit(pThis-&gt;sess);
		pThis-&gt;bHaveSess = 0;
	}
	RETiRet;
}


/* a small wrapper for gnutls_transport_set_ptr(). The main intension for
 * creating this wrapper is to get the annoying &quot;cast to pointer from different
 * size&quot; compiler warning just once. There seems to be no way around it, see:
 * http://lists.gnu.org/archive/html/help-gnutls/2008-05/msg00000.html
 * rgerhards, 2008.05-07
 */
#pragma GCC diagnostic ignored &quot;-Wint-to-pointer-cast&quot;
static inline void
gtlsSetTransportPtr(nsd_gtls_t *pThis, int sock)
{
	/* Note: the compiler warning for the next line is OK - see header comment! */
	gnutls_transport_set_ptr(pThis-&gt;sess, (gnutls_transport_ptr_t) sock);
}
#pragma GCC diagnostic warning &quot;-Wint-to-pointer-cast&quot;

/* ---------------------------- end GnuTLS specifics ---------------------------- */


/* Standard-Constructor */
BEGINobjConstruct(nsd_gtls) /* be sure to specify the object type also in END macro! */
	iRet = nsd_ptcp.Construct(&amp;pThis-&gt;pTcp);
	pThis-&gt;bReportAuthErr = 1;
ENDobjConstruct(nsd_gtls)


/* destructor for the nsd_gtls object */
PROTOTYPEobjDestruct(nsd_gtls);
BEGINobjDestruct(nsd_gtls) /* be sure to specify the object type also in END and CODESTART macros! */
CODESTARTobjDestruct(nsd_gtls)
	if(pThis-&gt;iMode == 1) {
		gtlsEndSess(pThis);
	}

	if(pThis-&gt;pTcp != NULL) {
		nsd_ptcp.Destruct(&amp;pThis-&gt;pTcp);
	}

	free(pThis-&gt;pszConnectHost);
	free(pThis-&gt;pszRcvBuf);
	free((void*) pThis-&gt;pszCAFile);

	if(pThis-&gt;bOurCertIsInit)
		for(unsigned i=0; i&lt;pThis-&gt;nOurCerts; ++i) {
			gnutls_x509_crt_deinit(pThis-&gt;pOurCerts[i]);
		}
	if(pThis-&gt;bOurKeyIsInit)
		gnutls_x509_privkey_deinit(pThis-&gt;ourKey);
	if(pThis-&gt;bHaveSess)
		gnutls_deinit(pThis-&gt;sess);
	if(pThis-&gt;xcred != NULL
	   &amp;&amp; (pThis-&gt;bIsInitiator || (!pThis-&gt;xcred_is_copy &amp;&amp; (!pThis-&gt;bIsInitiator || pThis-&gt;bHaveSess)))
	  ) {
		gnutls_certificate_free_credentials(pThis-&gt;xcred);
		free((void*) pThis-&gt;pszKeyFile);
		free((void*) pThis-&gt;pszCertFile);
	}
ENDobjDestruct(nsd_gtls)


/* Set the driver mode. For us, this has the following meaning:
 * 0 - work in plain tcp mode, without tls (e.g. before a STARTTLS)
 * 1 - work in TLS mode
 * rgerhards, 2008-04-28
 */
static rsRetVal
SetMode(nsd_t *pNsd, int mode)
{
	DEFiRet;
	nsd_gtls_t *pThis = (nsd_gtls_t*) pNsd;

	ISOBJ_TYPE_assert((pThis), nsd_gtls);
	if(mode != 0 &amp;&amp; mode != 1) {
		LogError(0, RS_RET_INVALID_DRVR_MODE, &quot;error: driver mode %d not supported by &quot;
				&quot;gtls netstream driver&quot;, mode);
		ABORT_FINALIZE(RS_RET_INVALID_DRVR_MODE);
	}

	pThis-&gt;iMode = mode;

finalize_it:
	RETiRet;
}

/* Set the authentication mode. For us, the following is supported:
 * anon - no certificate checks whatsoever (discouraged, but supported)
 * x509/certvalid - (just) check certificate validity
 * x509/fingerprint - certificate fingerprint
 * x509/name - cerfificate name check
 * mode == NULL is valid and defaults to x509/name
 * rgerhards, 2008-05-16
 */
static rsRetVal
SetAuthMode(nsd_t *pNsd, uchar *mode)
{
	DEFiRet;
<A NAME="1"></A>	nsd_gtls_t *pThis = (nsd_gtls_t*) pNsd;

	ISOBJ_TYPE_assert((pThis), nsd_gtls);
<FONT color="#f63526"><A HREF="javascript:ZweiFrames('match2224-1.html#1',3,'match2224-top.html#1',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>	if(mode == NULL || !strcasecmp((char*)mode, &quot;x509/name&quot;)) {
		pThis-&gt;authMode = GTLS_AUTH_CERTNAME;
	} else if(!strcasecmp((char*) mode, &quot;x509/fingerprint&quot;)) {
		pThis-&gt;authMode = GTLS_AUTH_CERTFINGERPRINT;
	} else if(!strcasecmp((char*) mode, &quot;x509/certvalid&quot;)) {
		pThis-&gt;authMode = GTLS_AUTH_CERTVALID;
	} else if(!strcasecmp((char*) mode, &quot;anon&quot;)) {
		pThis-&gt;authMode = GTLS_AUTH_CERTANON;
	} else {</B></FONT>
		LogError(0, RS_RET_VALUE_NOT_SUPPORTED, &quot;error: authentication mode '%s' not supported by &quot;
				&quot;gtls netstream driver&quot;, mode);
		ABORT_FINALIZE(RS_RET_VALUE_NOT_SUPPORTED);
	}

	dbgprintf(&quot;SetAuthMode to %s\n&quot;, (mode != NULL ? (char*)mode : &quot;NULL&quot;));
/* TODO: clear stored IDs! */

finalize_it:
	RETiRet;
}


/* Set the PermitExpiredCerts mode. For us, the following is supported:
 * on - fail if certificate is expired
 * off - ignore expired certificates
 * warn - warn if certificate is expired
 * alorbach, 2018-12-20
 */
static rsRetVal
SetPermitExpiredCerts(nsd_t *pNsd, uchar *mode)
{
	DEFiRet;
	nsd_gtls_t *pThis = (nsd_gtls_t*) pNsd;

	ISOBJ_TYPE_assert((pThis), nsd_gtls);
	/* default is set to off! */
	if(mode == NULL || !strcasecmp((char*)mode, &quot;off&quot;)) {
		pThis-&gt;permitExpiredCerts = GTLS_EXPIRED_DENY;
	} else if(!strcasecmp((char*) mode, &quot;warn&quot;)) {
		pThis-&gt;permitExpiredCerts = GTLS_EXPIRED_WARN;
	} else if(!strcasecmp((char*) mode, &quot;on&quot;)) {
		pThis-&gt;permitExpiredCerts = GTLS_EXPIRED_PERMIT;
	} else {
		LogError(0, RS_RET_VALUE_NOT_SUPPORTED, &quot;error: permitexpiredcerts mode '%s' not supported by &quot;
				&quot;gtls netstream driver&quot;, mode);
		ABORT_FINALIZE(RS_RET_VALUE_NOT_SUPPORTED);
	}

	dbgprintf(&quot;SetPermitExpiredCerts: Set Mode %s/%d\n&quot;,
		(mode != NULL ? (char*)mode : &quot;NULL&quot;), pThis-&gt;permitExpiredCerts);

/* TODO: clear stored IDs! */

finalize_it:
	RETiRet;
}


/* Set permitted peers. It is depending on the auth mode if this are
 * fingerprints or names. -- rgerhards, 2008-05-19
 */
static rsRetVal
SetPermPeers(nsd_t *pNsd, permittedPeers_t *pPermPeers)
{
	DEFiRet;
	nsd_gtls_t *pThis = (nsd_gtls_t*) pNsd;

	ISOBJ_TYPE_assert((pThis), nsd_gtls);
	if(pPermPeers == NULL)
		FINALIZE;

	if(pThis-&gt;authMode != GTLS_AUTH_CERTFINGERPRINT &amp;&amp; pThis-&gt;authMode != GTLS_AUTH_CERTNAME) {
		LogError(0, RS_RET_VALUE_NOT_IN_THIS_MODE, &quot;authentication not supported by &quot;
			&quot;gtls netstream driver in the configured authentication mode - ignored&quot;);
		ABORT_FINALIZE(RS_RET_VALUE_NOT_IN_THIS_MODE);
	}

	pThis-&gt;pPermPeers = pPermPeers;

finalize_it:
	RETiRet;
}

/* gnutls priority string
 * PascalWithopf 2017-08-16
 */
static rsRetVal
SetGnutlsPriorityString(nsd_t *pNsd, uchar *gnutlsPriorityString)
{
	DEFiRet;
	nsd_gtls_t *pThis = (nsd_gtls_t*) pNsd;

	ISOBJ_TYPE_assert((pThis), nsd_gtls);
	pThis-&gt;gnutlsPriorityString = gnutlsPriorityString;
	dbgprintf(&quot;gnutlsPriorityString: set to '%s'\n&quot;,
		(gnutlsPriorityString != NULL ? (char*)gnutlsPriorityString : &quot;NULL&quot;));
	RETiRet;
}

/* Set the driver cert extended key usage check setting
 * 0 - ignore contents of extended key usage
 * 1 - verify that cert contents is compatible with appropriate OID
 * jvymazal, 2019-08-16
 */
static rsRetVal
SetCheckExtendedKeyUsage(nsd_t *pNsd, int ChkExtendedKeyUsage)
{
	DEFiRet;
	nsd_gtls_t *pThis = (nsd_gtls_t*) pNsd;

	ISOBJ_TYPE_assert((pThis), nsd_gtls);
	if(ChkExtendedKeyUsage != 0 &amp;&amp; ChkExtendedKeyUsage != 1) {
		LogError(0, RS_RET_VALUE_NOT_SUPPORTED, &quot;error: driver ChkExtendedKeyUsage %d &quot;
				&quot;not supported by gtls netstream driver&quot;, ChkExtendedKeyUsage);
		ABORT_FINALIZE(RS_RET_VALUE_NOT_SUPPORTED);
	}

	pThis-&gt;dataTypeCheck = ChkExtendedKeyUsage;

finalize_it:
	RETiRet;
}

/* Set the driver name checking strictness
 * 0 - less strict per RFC 5280, section 4.1.2.6 - either SAN or CN match is good
 * 1 - more strict per RFC 6125 - if any SAN present it must match (CN is ignored)
 * jvymazal, 2019-08-16
 */
static rsRetVal
SetPrioritizeSAN(nsd_t *pNsd, int prioritizeSan)
{
	DEFiRet;
	nsd_gtls_t *pThis = (nsd_gtls_t*) pNsd;

	ISOBJ_TYPE_assert((pThis), nsd_gtls);
	if(prioritizeSan != 0 &amp;&amp; prioritizeSan != 1) {
		LogError(0, RS_RET_VALUE_NOT_SUPPORTED, &quot;error: driver prioritizeSan %d &quot;
				&quot;not supported by gtls netstream driver&quot;, prioritizeSan);
		ABORT_FINALIZE(RS_RET_VALUE_NOT_SUPPORTED);
	}

	pThis-&gt;bSANpriority = prioritizeSan;

finalize_it:
	RETiRet;
}

/* Set the driver tls  verifyDepth
 * alorbach, 2019-12-20
 */
static rsRetVal
SetTlsVerifyDepth(nsd_t *pNsd, int verifyDepth)
{
	DEFiRet;
	nsd_gtls_t *pThis = (nsd_gtls_t*) pNsd;

	ISOBJ_TYPE_assert((pThis), nsd_gtls);
	if (verifyDepth == 0) {
		FINALIZE;
	}
	assert(verifyDepth &gt;= 2);
	pThis-&gt;DrvrVerifyDepth = verifyDepth;

finalize_it:
	RETiRet;
}

static rsRetVal
SetTlsCAFile(nsd_t *pNsd, const uchar *const caFile)
{
	DEFiRet;
	nsd_gtls_t *const pThis = (nsd_gtls_t*) pNsd;

	ISOBJ_TYPE_assert((pThis), nsd_gtls);
	if(caFile == NULL) {
		pThis-&gt;pszCAFile = NULL;
	} else {
		CHKmalloc(pThis-&gt;pszCAFile = (const uchar*) strdup((const char*) caFile));
	}

finalize_it:
	RETiRet;
}

static rsRetVal
SetTlsKeyFile(nsd_t *pNsd, const uchar *const pszFile)
{
	DEFiRet;
	nsd_gtls_t *const pThis = (nsd_gtls_t*) pNsd;

	ISOBJ_TYPE_assert((pThis), nsd_gtls);
	if(pszFile == NULL) {
		pThis-&gt;pszKeyFile = NULL;
	} else {
		CHKmalloc(pThis-&gt;pszKeyFile = (const uchar*) strdup((const char*) pszFile));
	}

finalize_it:
	RETiRet;
}

static rsRetVal
SetTlsCertFile(nsd_t *pNsd, const uchar *const pszFile)
{
	DEFiRet;
	nsd_gtls_t *const pThis = (nsd_gtls_t*) pNsd;

	ISOBJ_TYPE_assert((pThis), nsd_gtls);
	if(pszFile == NULL) {
		pThis-&gt;pszCertFile = NULL;
	} else {
		CHKmalloc(pThis-&gt;pszCertFile = (const uchar*) strdup((const char*) pszFile));
	}

finalize_it:
	RETiRet;
}

/* Provide access to the underlying OS socket. This is primarily
 * useful for other drivers (like nsd_gtls) who utilize ourselfs
 * for some of their functionality. -- rgerhards, 2008-04-18
 */
static rsRetVal
SetSock(nsd_t *pNsd, int sock)
{
	DEFiRet;
	nsd_gtls_t *pThis = (nsd_gtls_t*) pNsd;

	ISOBJ_TYPE_assert((pThis), nsd_gtls);
	assert(sock &gt;= 0);

	nsd_ptcp.SetSock(pThis-&gt;pTcp, sock);

	RETiRet;
}


/* Keep Alive Options
 */
static rsRetVal
SetKeepAliveIntvl(nsd_t *pNsd, int keepAliveIntvl)
{
	DEFiRet;
	nsd_gtls_t *pThis = (nsd_gtls_t*) pNsd;

	ISOBJ_TYPE_assert((pThis), nsd_gtls);
	assert(keepAliveIntvl &gt;= 0);

	nsd_ptcp.SetKeepAliveIntvl(pThis-&gt;pTcp, keepAliveIntvl);

	RETiRet;
}


/* Keep Alive Options
 */
static rsRetVal
SetKeepAliveProbes(nsd_t *pNsd, int keepAliveProbes)
{
	DEFiRet;
	nsd_gtls_t *pThis = (nsd_gtls_t*) pNsd;

	ISOBJ_TYPE_assert((pThis), nsd_gtls);
	assert(keepAliveProbes &gt;= 0);

	nsd_ptcp.SetKeepAliveProbes(pThis-&gt;pTcp, keepAliveProbes);

	RETiRet;
}


/* Keep Alive Options
 */
static rsRetVal
SetKeepAliveTime(nsd_t *pNsd, int keepAliveTime)
{
	DEFiRet;
	nsd_gtls_t *pThis = (nsd_gtls_t*) pNsd;

	ISOBJ_TYPE_assert((pThis), nsd_gtls);
	assert(keepAliveTime &gt;= 0);

	nsd_ptcp.SetKeepAliveTime(pThis-&gt;pTcp, keepAliveTime);

	RETiRet;
}


/* abort a connection. This is meant to be called immediately
 * before the Destruct call. -- rgerhards, 2008-03-24
 */
static rsRetVal
Abort(nsd_t *pNsd)
{
	nsd_gtls_t *pThis = (nsd_gtls_t*) pNsd;
	DEFiRet;

	ISOBJ_TYPE_assert((pThis), nsd_gtls);

	if(pThis-&gt;iMode == 0) {
		nsd_ptcp.Abort(pThis-&gt;pTcp);
	}

	RETiRet;
}


/* Callback after netstrm obj init in nsd_ptcp - permits us to add some data */
static rsRetVal
LstnInitDrvr(netstrm_t *const pThis)
{
	DEFiRet;
	CHKiRet(gtlsInitCred((nsd_gtls_t*) pThis-&gt;pDrvrData));
	CHKiRet(gtlsAddOurCert((nsd_gtls_t*) pThis-&gt;pDrvrData));
finalize_it:
	RETiRet;
}



/* initialize the tcp socket for a listner
 * Here, we use the ptcp driver - because there is nothing special
 * at this point with GnuTLS. Things become special once we accept
 * a session, but not during listener setup.
 * gerhards, 2008-04-25
 */
static rsRetVal ATTR_NONNULL(1,3,5)
LstnInit(netstrms_t *pNS, void *pUsr, rsRetVal(*fAddLstn)(void*,netstrm_t*),
	 const int iSessMax, const tcpLstnParams_t *const cnf_params)
{
	DEFiRet;
	pNS-&gt;fLstnInitDrvr = LstnInitDrvr;
	iRet = nsd_ptcp.LstnInit(pNS, pUsr, fAddLstn, iSessMax, cnf_params);
//finalize_it:
	RETiRet;
}


/* This function checks if the connection is still alive - well, kind of...
 * This is a dummy here. For details, check function common in ptcp driver.
 * rgerhards, 2008-06-09
 */
static rsRetVal
CheckConnection(nsd_t __attribute__((unused)) *pNsd)
{
	nsd_gtls_t *pThis = (nsd_gtls_t*) pNsd;
	ISOBJ_TYPE_assert(pThis, nsd_gtls);

	dbgprintf(&quot;CheckConnection for %p\n&quot;, pNsd);
	return nsd_ptcp.CheckConnection(pThis-&gt;pTcp);
}


/* get the remote hostname. The returned hostname must be freed by the caller.
 * rgerhards, 2008-04-25
 */
static rsRetVal
GetRemoteHName(nsd_t *pNsd, uchar **ppszHName)
{
	DEFiRet;
	nsd_gtls_t *pThis = (nsd_gtls_t*) pNsd;
	ISOBJ_TYPE_assert(pThis, nsd_gtls);
	iRet = nsd_ptcp.GetRemoteHName(pThis-&gt;pTcp, ppszHName);
	RETiRet;
}


/* Provide access to the sockaddr_storage of the remote peer. This
 * is needed by the legacy ACL system. --- gerhards, 2008-12-01
 */
static rsRetVal
GetRemAddr(nsd_t *pNsd, struct sockaddr_storage **ppAddr)
{
	DEFiRet;
	nsd_gtls_t *pThis = (nsd_gtls_t*) pNsd;
	ISOBJ_TYPE_assert(pThis, nsd_gtls);
	iRet = nsd_ptcp.GetRemAddr(pThis-&gt;pTcp, ppAddr);
	RETiRet;
}


/* get the remote host's IP address. Caller must Destruct the object. */
static rsRetVal
GetRemoteIP(nsd_t *pNsd, prop_t **ip)
{
	DEFiRet;
	nsd_gtls_t *pThis = (nsd_gtls_t*) pNsd;
	ISOBJ_TYPE_assert(pThis, nsd_gtls);
	iRet = nsd_ptcp.GetRemoteIP(pThis-&gt;pTcp, ip);
	RETiRet;
}


/* accept an incoming connection request - here, we do the usual accept
 * handling. TLS specific handling is done thereafter (and if we run in TLS
 * mode at this time).
 * rgerhards, 2008-04-25
 */
static rsRetVal
AcceptConnReq(nsd_t *pNsd, nsd_t **ppNew)
{
	DEFiRet;
	int gnuRet;
	nsd_gtls_t *pNew = NULL;
	nsd_gtls_t *pThis = (nsd_gtls_t*) pNsd;
	const char *error_position = NULL;

	ISOBJ_TYPE_assert((pThis), nsd_gtls);
	CHKiRet(nsd_gtlsConstruct(&amp;pNew)); // TODO: prevent construct/destruct!
	CHKiRet(nsd_ptcp.Destruct(&amp;pNew-&gt;pTcp));
	CHKiRet(nsd_ptcp.AcceptConnReq(pThis-&gt;pTcp, &amp;pNew-&gt;pTcp));

	if(pThis-&gt;iMode == 0) {
		/* we are in non-TLS mode, so we are done */
		*ppNew = (nsd_t*) pNew;
<A NAME="3"></A>		FINALIZE;
	}
	/* copy Properties to pnew first */
<FONT color="#53858b"><A HREF="javascript:ZweiFrames('match2224-1.html#3',3,'match2224-top.html#3',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>	pNew-&gt;authMode = pThis-&gt;authMode;
	pNew-&gt;permitExpiredCerts = pThis-&gt;permitExpiredCerts;
	pNew-&gt;pPermPeers = pThis-&gt;pPermPeers;
	pNew-&gt;gnutlsPriorityString = pThis-&gt;gnutlsPriorityString;
	pNew-&gt;DrvrVerifyDepth = pThis-&gt;DrvrVerifyDepth;
	pNew-&gt;dataTypeCheck = pThis-&gt;dataTypeCheck;
	pNew-&gt;bSANpriority = pThis-&gt;bSANpriority;
	pNew-&gt;pszCertFile = pThis-&gt;pszCertFile;
	pNew-&gt;pszKeyFile = pThis-&gt;pszKeyFile;
	pNew-&gt;xcred = pThis-&gt;xcred; // TODO: verify once again; xcred is read only at this stage
	pNew-&gt;xcred_is_copy = 1; // do not free on pNew Destruction

	/* if we reach this point, we are in TLS mode */
	iRet = gtlsInitSession(pNew);</B></FONT>
	if (iRet != RS_RET_OK) {
		if (iRet == RS_RET_CERTLESS) {
			dbgprintf(&quot;AcceptConnReq certless mode\n&quot;);
			/* Set status to OK */
			iRet = RS_RET_OK;
		} else {
			goto finalize_it;
		}
	}
	gtlsSetTransportPtr(pNew, ((nsd_ptcp_t*) (pNew-&gt;pTcp))-&gt;sock);

	dbgprintf(&quot;AcceptConnReq bOurCertIsInit=%hu bOurKeyIsInit=%hu \n&quot;,
		pNew-&gt;bOurCertIsInit, pNew-&gt;bOurKeyIsInit);

	/* here is the priorityString set */
	if(pNew-&gt;gnutlsPriorityString != NULL) {
		dbgprintf(&quot;AcceptConnReq setting configured priority string (ciphers)\n&quot;);
		if(gnutls_priority_set_direct(pNew-&gt;sess,
					(const char*) pNew-&gt;gnutlsPriorityString,
					&amp;error_position)==GNUTLS_E_INVALID_REQUEST) {
			LogError(0, RS_RET_GNUTLS_ERR, &quot;Syntax Error in&quot;
					&quot; Priority String: \&quot;%s\&quot;\n&quot;, error_position);
		}
	} else {
		if(pThis-&gt;authMode == GTLS_AUTH_CERTANON) {
			/* Allow ANON Ciphers */
			dbgprintf(&quot;AcceptConnReq setting anon ciphers Try1: %s\n&quot;, GTLS_ANON_PRIO_NOTLSV13);
			if(gnutls_priority_set_direct(pNew-&gt;sess,(const char*) GTLS_ANON_PRIO_NOTLSV13,
				&amp;error_position)==GNUTLS_E_INVALID_REQUEST) {
				dbgprintf(&quot;AcceptConnReq setting anon ciphers Try2 (TLS1.3 unknown): %s\n&quot;,
					GTLS_ANON_PRIO);
				CHKgnutls(gnutls_priority_set_direct(pNew-&gt;sess, GTLS_ANON_PRIO, &amp;error_position));
			}
			/* Uncomment for DEBUG
			print_cipher_suite_list(&quot;NORMAL:+ANON-DH:+ANON-ECDH:+COMP-ALL&quot;); */
		} else {
			/* Use default priorities */
			dbgprintf(&quot;AcceptConnReq setting default ciphers\n&quot;);
			CHKgnutls(gnutls_set_default_priority(pNew-&gt;sess));
		}
	}

	/* we now do the handshake. This is a bit complicated, because we are
	 * on non-blocking sockets. Usually, the handshake will not complete
	 * immediately, so that we need to retry it some time later.
	 */
	gnuRet = gnutls_handshake(pNew-&gt;sess);
	if(gnuRet == GNUTLS_E_AGAIN || gnuRet == GNUTLS_E_INTERRUPTED) {
		pNew-&gt;rtryCall = gtlsRtry_handshake;
		dbgprintf(&quot;GnuTLS handshake does not complete immediately - &quot;
			&quot;setting to retry (this is OK and normal)\n&quot;);
	} else if(gnuRet == 0) {
		/* we got a handshake, now check authorization */
		CHKiRet(gtlsChkPeerAuth(pNew));
	} else {
		uchar *pGnuErr = gtlsStrerror(gnuRet);
		LogError(0, RS_RET_TLS_HANDSHAKE_ERR,
			&quot;gnutls returned error on handshake: %s\n&quot;, pGnuErr);
		free(pGnuErr);
		ABORT_FINALIZE(RS_RET_TLS_HANDSHAKE_ERR);
	}

	pNew-&gt;iMode = 1; /* this session is now in TLS mode! */

	*ppNew = (nsd_t*) pNew;

finalize_it:
	if(iRet != RS_RET_OK) {
if (error_position != NULL) {
	dbgprintf(&quot;AcceptConnReq error_position=%s\n&quot;, error_position);
}

		if(pNew != NULL)
			nsd_gtlsDestruct(&amp;pNew);
	}
	RETiRet;
}


/* receive data from a tcp socket
 * The lenBuf parameter must contain the max buffer size on entry and contains
 * the number of octets read on exit. This function
 * never blocks, not even when called on a blocking socket. That is important
 * for client sockets, which are set to block during send, but should not
 * block when trying to read data. -- rgerhards, 2008-03-17
 * The function now follows the usual iRet calling sequence.
 * With GnuTLS, we may need to restart a recv() system call. If so, we need
 * to supply the SAME buffer on the retry. We can not assure this, as the
 * caller is free to call us with any buffer location (and in current
 * implementation, it is on the stack and extremely likely to change). To
 * work-around this problem, we allocate a buffer ourselfs and always receive
 * into that buffer. We pass data on to the caller only after we have received it.
 * To save some space, we allocate that internal buffer only when it is actually
 * needed, which means when we reach this function for the first time. To keep
 * the algorithm simple, we always supply data only from the internal buffer,
 * even if it is a single byte. As we have a stream, the caller must be prepared
 * to accept messages in any order, so we do not need to take care about this.
 * Please note that the logic also forces us to do some &quot;faking&quot; in select(), as
 * we must provide a fake &quot;is ready for readign&quot; status if we have data inside our
 * buffer. -- rgerhards, 2008-06-23
 */
static rsRetVal
Rcv(nsd_t *pNsd, uchar *pBuf, ssize_t *pLenBuf, int *const oserr)
{
	DEFiRet;
	ssize_t iBytesCopy; /* how many bytes are to be copied to the client buffer? */
	nsd_gtls_t *pThis = (nsd_gtls_t*) pNsd;
	ISOBJ_TYPE_assert(pThis, nsd_gtls);

	if(pThis-&gt;bAbortConn)
		ABORT_FINALIZE(RS_RET_CONNECTION_ABORTREQ);

	if(pThis-&gt;iMode == 0) {
		CHKiRet(nsd_ptcp.Rcv(pThis-&gt;pTcp, pBuf, pLenBuf, oserr));
		FINALIZE;
	}

	/* --- in TLS mode now --- */

	/* Buffer logic applies only if we are in TLS mode. Here we
	 * assume that we will switch from plain to TLS, but never back. This
	 * assumption may be unsafe, but it is the model for the time being and I
	 * do not see any valid reason why we should switch back to plain TCP after
	 * we were in TLS mode. However, in that case we may lose something that
	 * is already in the receive buffer ... risk accepted. -- rgerhards, 2008-06-23
	 */

	if(pThis-&gt;pszRcvBuf == NULL) {
		/* we have no buffer, so we need to malloc one */
		CHKmalloc(pThis-&gt;pszRcvBuf = malloc(NSD_GTLS_MAX_RCVBUF));
		pThis-&gt;lenRcvBuf = -1;
	}

	/* now check if we have something in our buffer. If so, we satisfy
	 * the request from buffer contents.
	 */
	if(pThis-&gt;lenRcvBuf == -1) { /* no data present, must read */
		CHKiRet(gtlsRecordRecv(pThis));
	}

	if(pThis-&gt;lenRcvBuf == 0) { /* EOS */
		*oserr = errno;
		ABORT_FINALIZE(RS_RET_CLOSED);
	}

	/* if we reach this point, data is present in the buffer and must be copied */
	iBytesCopy = pThis-&gt;lenRcvBuf - pThis-&gt;ptrRcvBuf;
	if(iBytesCopy &gt; *pLenBuf) {
		iBytesCopy = *pLenBuf;
	} else {
		pThis-&gt;lenRcvBuf = -1; /* buffer will be emptied below */
	}

	memcpy(pBuf, pThis-&gt;pszRcvBuf + pThis-&gt;ptrRcvBuf, iBytesCopy);
	pThis-&gt;ptrRcvBuf += iBytesCopy;
	*pLenBuf = iBytesCopy;

finalize_it:
	if (iRet != RS_RET_OK &amp;&amp;
		iRet != RS_RET_RETRY) {
		/* We need to free the receive buffer in error error case unless a retry is wanted. , if we
		 * allocated one. -- rgerhards, 2008-12-03 -- moved here by alorbach, 2015-12-01
		 */
		*pLenBuf = 0;
		free(pThis-&gt;pszRcvBuf);
		pThis-&gt;pszRcvBuf = NULL;
	}
	dbgprintf(&quot;gtlsRcv return. nsd %p, iRet %d, lenRcvBuf %d, ptrRcvBuf %d\n&quot;, pThis,
	iRet, pThis-&gt;lenRcvBuf, pThis-&gt;ptrRcvBuf);
	RETiRet;
}


/* send a buffer. On entry, pLenBuf contains the number of octets to
 * write. On exit, it contains the number of octets actually written.
 * If this number is lower than on entry, only a partial buffer has
 * been written.
 * rgerhards, 2008-03-19
 */
static rsRetVal
Send(nsd_t *pNsd, uchar *pBuf, ssize_t *pLenBuf)
{
	int iSent;
	int wantsWriteData = 0;
	nsd_gtls_t *pThis = (nsd_gtls_t*) pNsd;
	DEFiRet;
	ISOBJ_TYPE_assert(pThis, nsd_gtls);

	if(pThis-&gt;bAbortConn)
		ABORT_FINALIZE(RS_RET_CONNECTION_ABORTREQ);

	if(pThis-&gt;iMode == 0) {
		CHKiRet(nsd_ptcp.Send(pThis-&gt;pTcp, pBuf, pLenBuf));
		FINALIZE;
	}

	/* in TLS mode now */
	while(1) { /* loop broken inside */
		iSent = gnutls_record_send(pThis-&gt;sess, pBuf, *pLenBuf);
		if(iSent &gt;= 0) {
			*pLenBuf = iSent;
			break;
		}
		if(iSent != GNUTLS_E_INTERRUPTED &amp;&amp; iSent != GNUTLS_E_AGAIN) {
			/* Check if the underlaying file descriptor needs to read or write data!*/
			wantsWriteData = gnutls_record_get_direction(pThis-&gt;sess);
			uchar *pErr = gtlsStrerror(iSent);
			LogError(0, RS_RET_GNUTLS_ERR, &quot;unexpected GnuTLS error %d, wantsWriteData=%d - this &quot;
				&quot;could be caused by a broken connection. GnuTLS reports: %s\n&quot;,
				iSent, wantsWriteData, pErr);
			free(pErr);
			gnutls_perror(iSent);
			ABORT_FINALIZE(RS_RET_GNUTLS_ERR);
		}
	}

finalize_it:
	RETiRet;
}

/* Enable KEEPALIVE handling on the socket.
 * rgerhards, 2009-06-02
 */
static rsRetVal
EnableKeepAlive(nsd_t *pNsd)
{
	nsd_gtls_t *pThis = (nsd_gtls_t*) pNsd;
	ISOBJ_TYPE_assert(pThis, nsd_gtls);
	return nsd_ptcp.EnableKeepAlive(pThis-&gt;pTcp);
}


/*
 * SNI should not be used if the hostname is a bare IP address
 */
static int
SetServerNameIfPresent(nsd_gtls_t *pThis, uchar *host) {
	struct sockaddr_in sa;
	struct sockaddr_in6 sa6;

	int inet_pton_ret = inet_pton(AF_INET, CHAR_CONVERT(host), &amp;(sa.sin_addr));

	if (inet_pton_ret == 0) { // host wasn't a bare IPv4 address: try IPv6
		inet_pton_ret = inet_pton(AF_INET6, CHAR_CONVERT(host), &amp;(sa6.sin6_addr));
	}

	switch(inet_pton_ret) {
		case 1: // host is a valid IP address: don't use SNI
			return 0;
		case 0: // host isn't a valid IP address: assume it's a domain name, use SNI
			return gnutls_server_name_set(pThis-&gt;sess, GNUTLS_NAME_DNS, host, ustrlen(host));
		default: // unexpected error
			return -1;
	}

}

/* open a connection to a remote host (server). With GnuTLS, we always
 * open a plain tcp socket and then, if in TLS mode, do a handshake on it.
 * rgerhards, 2008-03-19
 */
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored &quot;-Wdeprecated-declarations&quot; /* TODO: FIX Warnings! */
static rsRetVal
Connect(nsd_t *pNsd, int family, uchar *port, uchar *host, char *device)
{
	nsd_gtls_t *pThis = (nsd_gtls_t*) pNsd;
	int sock;
	int gnuRet;
	const char *error_position;
#	ifdef HAVE_GNUTLS_CERTIFICATE_TYPE_SET_PRIORITY
	static const int cert_type_priority[2] = { GNUTLS_CRT_X509, 0 };
#	endif
	DEFiRet;
	dbgprintf(&quot;Connect to %s:%s\n&quot;, host, port);

	ISOBJ_TYPE_assert(pThis, nsd_gtls);
	assert(port != NULL);
	assert(host != NULL);

	CHKiRet(gtlsInitCred(pThis));
	CHKiRet(gtlsAddOurCert(pThis));
	CHKiRet(nsd_ptcp.Connect(pThis-&gt;pTcp, family, port, host, device));

	if(pThis-&gt;iMode == 0)
		FINALIZE;

	/* we reach this point if in TLS mode */
	CHKgnutls(gnutls_init(&amp;pThis-&gt;sess, GNUTLS_CLIENT));
	pThis-&gt;bHaveSess = 1;
	pThis-&gt;bIsInitiator = 1;

	CHKgnutls(SetServerNameIfPresent(pThis, host));

	/* in the client case, we need to set a callback that ensures our certificate
	 * will be presented to the server even if it is not signed by one of the server's
	 * trusted roots. This is necessary to support fingerprint authentication.
	 */
	/* store a pointer to ourselfs (needed by callback) */
	gnutls_session_set_ptr(pThis-&gt;sess, (void*)pThis);
	iRet = gtlsLoadOurCertKey(pThis); /* first load .pem files */
	if(iRet == RS_RET_OK) {
#		if HAVE_GNUTLS_CERTIFICATE_SET_RETRIEVE_FUNCTION
		gnutls_certificate_set_retrieve_function(pThis-&gt;xcred, gtlsClientCertCallback);
#		else
		gnutls_certificate_client_set_retrieve_function(pThis-&gt;xcred, gtlsClientCertCallback);
#		endif
		dbgprintf(&quot;Connect: enable certificate checking (VerifyDepth=%d)\n&quot;, pThis-&gt;DrvrVerifyDepth);
		if (pThis-&gt;DrvrVerifyDepth != 0) {
			gnutls_certificate_set_verify_limits(pThis-&gt;xcred, 8200, pThis-&gt;DrvrVerifyDepth);
		}
	} else if(iRet == RS_RET_CERTLESS) {
		dbgprintf(&quot;Connect: certificates not configured, not loaded.\n&quot;);
	} else {
		LogError(0, iRet, &quot;Connect failed to INIT Session %d&quot;, gnuRet);
		ABORT_FINALIZE(iRet);; /* we have an error case! */
	}

	/*priority string setzen*/
	if(pThis-&gt;gnutlsPriorityString != NULL) {
		dbgprintf(&quot;Connect: setting configured priority string (ciphers)\n&quot;);
		if(gnutls_priority_set_direct(pThis-&gt;sess,
					(const char*) pThis-&gt;gnutlsPriorityString,
					&amp;error_position)==GNUTLS_E_INVALID_REQUEST) {
			LogError(0, RS_RET_GNUTLS_ERR, &quot;Syntax Error in&quot;
					&quot; Priority String: \&quot;%s\&quot;\n&quot;, error_position);
		}
	} else {
		if(pThis-&gt;authMode == GTLS_AUTH_CERTANON || pThis-&gt;bOurCertIsInit == 0) {
			/* Allow ANON Ciphers */
			dbgprintf(&quot;Connect: setting anon ciphers Try1: %s\n&quot;, GTLS_ANON_PRIO_NOTLSV13);
			if(gnutls_priority_set_direct(pThis-&gt;sess,(const char*) GTLS_ANON_PRIO_NOTLSV13,
				&amp;error_position)==GNUTLS_E_INVALID_REQUEST) {
				dbgprintf(&quot;Connect: setting anon ciphers Try2 (TLS1.3 unknown): %s\n&quot;, GTLS_ANON_PRIO);
				CHKgnutls(gnutls_priority_set_direct(pThis-&gt;sess, GTLS_ANON_PRIO, &amp;error_position));
			}
			/* Uncomment for DEBUG
			print_cipher_suite_list(&quot;NORMAL:+ANON-DH:+ANON-ECDH:+COMP-ALL&quot;); */
		} else {
			/* Use default priorities */
			dbgprintf(&quot;Connect: setting default ciphers\n&quot;);
			CHKgnutls(gnutls_set_default_priority(pThis-&gt;sess));
		}
	}

#	ifdef HAVE_GNUTLS_CERTIFICATE_TYPE_SET_PRIORITY
	/* The gnutls_certificate_type_set_priority function is deprecated
	 * and not available in recent GnuTLS versions. However, there is no
	 * doc how to properly replace it with gnutls_priority_set_direct.
	 * A lot of folks have simply removed it, when they also called
	 * gnutls_set_default_priority. This is what we now also do. If
	 * this causes problems or someone has an idea of how to replace
	 * the deprecated function in a better way, please let us know!
	 * In any case, we use it as long as it is available and let
	 * not insult us by the deprecation warnings.
	 * 2015-05-18 rgerhards
	 */
	CHKgnutls(gnutls_certificate_type_set_priority(pThis-&gt;sess, cert_type_priority));
#	endif

	/* put the x509 credentials to the current session */
	CHKgnutls(gnutls_credentials_set(pThis-&gt;sess, GNUTLS_CRD_CERTIFICATE, pThis-&gt;xcred));

	/* check for anon authmode */
	if (pThis-&gt;authMode == GTLS_AUTH_CERTANON) {
		dbgprintf(&quot;Connect: anon authmode, gnutls_credentials_set GNUTLS_CRD_ANON\n&quot;);
		CHKgnutls(gnutls_credentials_set(pThis-&gt;sess, GNUTLS_CRD_ANON, anoncred));
		gnutls_dh_set_prime_bits(pThis-&gt;sess, dhMinBits);
	}

	/* assign the socket to GnuTls */
	CHKiRet(nsd_ptcp.GetSock(pThis-&gt;pTcp, &amp;sock));
	gtlsSetTransportPtr(pThis, sock);

	/* we need to store the hostname as an alternate mean of authentication if no
	 * permitted peer names are given. Using the hostname is quite useful. It permits
	 * auto-configuration of security if a commen root cert is present. -- rgerhards, 2008-05-26
	 */
	CHKmalloc(pThis-&gt;pszConnectHost = (uchar*)strdup((char*)host));

	/* and perform the handshake */
	CHKgnutls(gnutls_handshake(pThis-&gt;sess));
	dbgprintf(&quot;GnuTLS handshake succeeded\n&quot;);

	/* now check if the remote peer is permitted to talk to us - ideally, we
	 * should do this during the handshake, but GnuTLS does not yet provide
	 * the necessary callbacks -- rgerhards, 2008-05-26
	 */
	CHKiRet(gtlsChkPeerAuth(pThis));

finalize_it:
	if(iRet != RS_RET_OK) {
		if(pThis-&gt;bHaveSess) {
			gnutls_deinit(pThis-&gt;sess);
			pThis-&gt;bHaveSess = 0;
			pThis-&gt;xcred = NULL;
		}
	}

	RETiRet;
}
#pragma GCC diagnostic pop


/* queryInterface function */
BEGINobjQueryInterface(nsd_gtls)
CODESTARTobjQueryInterface(nsd_gtls)
	if(pIf-&gt;ifVersion != nsdCURR_IF_VERSION) {/* check for current version, increment on each change */
		ABORT_FINALIZE(RS_RET_INTERFACE_NOT_SUPPORTED);
	}

	/* ok, we have the right interface, so let's fill it
	 * Please note that we may also do some backwards-compatibility
	 * work here (if we can support an older interface version - that,
	 * of course, also affects the &quot;if&quot; above).
	 */
	pIf-&gt;Construct = (rsRetVal(*)(nsd_t**)) nsd_gtlsConstruct;
	pIf-&gt;Destruct = (rsRetVal(*)(nsd_t**)) nsd_gtlsDestruct;
	pIf-&gt;Abort = Abort;
<A NAME="0"></A>	pIf-&gt;LstnInit = LstnInit;
	pIf-&gt;AcceptConnReq = AcceptConnReq;
	pIf-&gt;Rcv = Rcv;
<FONT color="#0000ff"><A HREF="javascript:ZweiFrames('match2224-1.html#0',3,'match2224-top.html#0',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>	pIf-&gt;Send = Send;
	pIf-&gt;Connect = Connect;
	pIf-&gt;SetSock = SetSock;
	pIf-&gt;SetMode = SetMode;
	pIf-&gt;SetAuthMode = SetAuthMode;
	pIf-&gt;SetPermitExpiredCerts = SetPermitExpiredCerts;
	pIf-&gt;SetPermPeers =SetPermPeers;
	pIf-&gt;CheckConnection = CheckConnection;
	pIf-&gt;GetRemoteHName = GetRemoteHName;
	pIf-&gt;GetRemoteIP = GetRemoteIP;
	pIf-&gt;GetRemAddr = GetRemAddr;
	pIf-&gt;EnableKeepAlive = EnableKeepAlive;
	pIf-&gt;SetKeepAliveIntvl = SetKeepAliveIntvl;
	pIf-&gt;SetKeepAliveProbes = SetKeepAliveProbes;
	pIf-&gt;SetKeepAliveTime = SetKeepAliveTime;
	pIf-&gt;SetGnutlsPriorityString = SetGnutlsPriorityString;
	pIf-&gt;SetCheckExtendedKeyUsage = SetCheckExtendedKeyUsage;
	pIf-&gt;SetPrioritizeSAN = SetPrioritizeSAN;
	pIf-&gt;SetTlsVerifyDepth = SetTlsVerifyDepth;
	pIf-&gt;SetTlsCAFile = SetTlsCAFile;
	pIf-&gt;SetTlsKeyFile = SetTlsKeyFile;
	pIf-&gt;SetTlsCertFile = SetTlsCertFile;
finalize_it:
ENDobjQueryInterface(nsd_gtls)


/* exit our class
 */
BEGINObjClassExit(nsd_gtls, OBJ_IS_LOADABLE_MODULE) /* CHANGE class also in END MACRO! */
CODESTARTObjClassExit(nsd_gtls)
	gtlsGlblExit();	/* shut down GnuTLS */

	/* release objects we no longer need */
	objRelease(nsd_ptcp, LM_NSD_PTCP_FILENAME);
	objRelease(net, LM_NET_FILENAME);
	objRelease(glbl, CORE_COMPONENT);
	objRelease(datetime, CORE_COMPONENT);
ENDObjClassExit(nsd_gtls)


/* Initialize the nsd_gtls class. Must be called as the very first method
 * before anything else is called inside this class.
 * rgerhards, 2008-02-19
 */
BEGINObjClassInit(nsd_gtls, 1, OBJ_IS_LOADABLE_MODULE) /* class, version */
	/* request objects we use */
	CHKiRet(objUse(datetime, CORE_COMPONENT));
	CHKiRet(objUse(glbl, CORE_COMPONENT));
	CHKiRet(objUse(net, LM_NET_FILENAME));
	CHKiRet(objUse(nsd_ptcp, LM_NSD_PTCP_FILENAME));

	/* now do global TLS init stuff */
	CHKiRet(gtlsGlblInit());
ENDObjClassInit(nsd_gtls)


/* --------------- here now comes the plumbing that makes as a library module --------------- */


BEGINmodExit
CODESTARTmodExit
	nsdsel_gtlsClassExit();
	nsd_gtlsClassExit();
	pthread_mutex_destroy(&amp;mutGtlsStrerror);
ENDmodExit


BEGINqueryEtryPt
CODESTARTqueryEtryPt
CODEqueryEtryPt_STD_LIB_QUERIES
ENDqueryEtryPt


BEGINmodInit()
CODESTARTmodInit
	*ipIFVersProvided = CURR_MOD_IF_VERSION; /* we only support the current interface specification */

	/* Initialize all classes that are in our module - this includes ourselfs */
	CHKiRet(nsd_gtlsClassInit(pModInfo)); /* must be done after tcps_sess, as we use it */
	CHKiRet(nsdsel_gtlsClassInit(pModInfo)); /* must be done after tcps_sess, as we use it */

	pthread_mutex_init(&amp;mutGtlsStrerror, NULL);</B></FONT>
ENDmodInit
/* vi:set ai:
 */
</PRE>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>action.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
/* action.c
 *
 * Implementation of the action object.
 *
 * File begun on 2007-08-06 by RGerhards (extracted from syslogd.c)
 *
 * Some notes on processing (this hopefully makes it easier to find
 * the right code in question): For performance reasons, this module
 * uses different methods of message submission based on the user-selected
 * configuration. This code is similar, but can not be abstracted because
 * of the performance-affecting differences in it. As such, it is often
 * necessary to triple-check that everything works well in *all* modes.
 * The different modes (and calling sequence) are:
 *
 * if set iExecEveryNthOccur &gt; 1 || iSecsExecOnceInterval
 * - doSubmitToActionQComplex
 *   handles mark message reduction, but in essence calls
 * - actionWriteToAction
 * - doSubmitToActionQ
 *   (now queue engine processing)
 * if(pThis-&gt;bWriteAllMarkMsgs == RSFALSE)
 * - doSubmitToActionQNotAllMark
 * - doSubmitToActionQ (and from here like in the else case below!)
 * else
 * - doSubmitToActionQ
 * - qqueueEnqObj
 *   (now queue engine processing)
 *
 * Note that bWriteAllMakrMsgs on or off creates almost the same processing.
 * The difference ist that if WriteAllMarkMsgs is not set, we need to
 * preprocess the batch and drop mark messages which are not yet due for
 * writing.
 *
 * After dequeue, processing is as follows:
 * - processBatchMain
 * - processMsgMain (direct entry for DIRECT queue!)
 * - ...
 *
 * MORE ON PROCESSING, QUEUES and FILTERING
 * All filtering needs to be done BEFORE messages are enqueued to an
 * action. In previous code, part of the filtering was done at the
 * &quot;remote end&quot; of the action queue, which lead to problems in
 * non-direct mode (because then things run asynchronously). In order
 * to solve this problem once and for all, I have changed the code so
 * that all filtering is done before enq, and processing on the
 * dequeue side of action processing now always executes whatever is
 * enqueued. This is the only way to handle things consistently and
 * (as much as possible) in a queue-type agnostic way. However, it is
 * a rather radical change, which I unfortunately needed to make from
 * stable version 5.8.1 to 5.8.2. If new problems pop up, you now know
 * what may be their cause. In any case, the way it is done now is the
 * only correct one.
 * A problem is that, under fortunate conditions, we use the current
 * batch for the output system as well. This is very good from a performance
 * point of view, but makes the distinction between enq and deq side of
 * the queue a bit hard. The current idea is that the filter condition
 * alone is checked at the deq side of the queue (seems to be unavoidable
 * to do it that way), but all other complex conditons (like failover
 * handling) go into the computation of the filter condition. For
 * non-direct queues, we still enqueue only what is acutally necessary.
 * Note that in this case the rest of the code must ensure that the filter
 * is set to &quot;true&quot;. While this is not perfect and not as simple as
 * we would like to see it, it looks like the best way to tackle that
 * beast.
 * rgerhards, 2011-06-15
 *
 * Copyright 2007-2019 Rainer Gerhards and Adiscon GmbH.
 *
 * This file is part of rsyslog.
 *
 * Rsyslog is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * Rsyslog is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with Rsyslog.  If not, see &lt;http://www.gnu.org/licenses/&gt;.
 *
 * A copy of the GPL can be found in the file &quot;COPYING&quot; in this distribution.
 */
#include &quot;config.h&quot;
#include &lt;stdio.h&gt;
#include &lt;assert.h&gt;
#include &lt;stdarg.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;strings.h&gt;
#include &lt;time.h&gt;
#include &lt;errno.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;sys/stat.h&gt;
#include &lt;fcntl.h&gt;
#include &lt;unistd.h&gt;
#include &lt;json.h&gt;

#include &quot;rsyslog.h&quot;
#include &quot;dirty.h&quot;
#include &quot;template.h&quot;
#include &quot;action.h&quot;
#include &quot;modules.h&quot;
#include &quot;cfsysline.h&quot;
#include &quot;srUtils.h&quot;
#include &quot;errmsg.h&quot;
#include &quot;batch.h&quot;
#include &quot;wti.h&quot;
#include &quot;rsconf.h&quot;
#include &quot;datetime.h&quot;
#include &quot;unicode-helper.h&quot;
#include &quot;atomic.h&quot;
#include &quot;ruleset.h&quot;
#include &quot;parserif.h&quot;
#include &quot;statsobj.h&quot;

/* AIXPORT : cs renamed to legacy_cs as clashes with libpthreads variable in complete file*/
#ifdef _AIX
#define cs legacy_cs
#endif

PRAGMA_INGORE_Wswitch_enum

#ifndef O_LARGEFILE
#define O_LARGEFILE 0
#endif

#define NO_TIME_PROVIDED 0 /* indicate we do not provide any cached time */

/* forward definitions */
static rsRetVal ATTR_NONNULL() processBatchMain(void *pVoid, batch_t *pBatch, wti_t * const pWti);
static rsRetVal doSubmitToActionQ(action_t * const pAction, wti_t * const pWti, smsg_t*);
static rsRetVal doSubmitToActionQComplex(action_t * const pAction, wti_t * const pWti, smsg_t*);
static rsRetVal doSubmitToActionQNotAllMark(action_t * const pAction, wti_t * const pWti, smsg_t*);
static void ATTR_NONNULL() actionSuspend(action_t * const pThis, wti_t * const pWti);
static void ATTR_NONNULL() actionRetry(action_t * const pThis, wti_t * const pWti);

/* object static data (once for all instances) */
DEFobjCurrIf(obj)
DEFobjCurrIf(datetime)
DEFobjCurrIf(module)
DEFobjCurrIf(statsobj)
DEFobjCurrIf(ruleset)


typedef struct configSettings_s {
	int bActExecWhenPrevSusp;			/* execute action only when previous one was suspended? */
	int bActionWriteAllMarkMsgs;			/* should all mark messages be unconditionally written? */
	int iActExecOnceInterval;			/* execute action once every nn seconds */
	int iActExecEveryNthOccur;			/* execute action every n-th occurrence (0,1=always) */
	time_t iActExecEveryNthOccurTO;			/* timeout for n-occurrence setting (in seconds, 0=never) */
	int glbliActionResumeInterval;
	int glbliActionResumeRetryCount;		/* how often should suspended actions be retried? */
	int bActionRepMsgHasMsg;			/* last messsage repeated... has msg fragment in it */
	uchar *pszActionName;				/* short name for the action */
	/* action queue and its configuration parameters */
	queueType_t ActionQueType;			/* type of the main message queue above */
	int iActionQueueSize;				/* size of the main message queue above */
	int iActionQueueDeqBatchSize;			/* batch size for action queues */
	int iActionQHighWtrMark;			/* high water mark for disk-assisted queues */
	int iActionQLowWtrMark;				/* low water mark for disk-assisted queues */
	int iActionQDiscardMark;			/* begin to discard messages */
	int iActionQDiscardSeverity;
	/* by default, discard nothing to prevent unintentional loss */
	int iActionQueueNumWorkers;			/* number of worker threads for the mm queue above */
	uchar *pszActionQFName;				/* prefix for the main message queue file */
	int64 iActionQueMaxFileSize;
	int iActionQPersistUpdCnt;			/* persist queue info every n updates */
	int bActionQSyncQeueFiles;			/* sync queue files */
	int iActionQtoQShutdown;			/* queue shutdown */
	int iActionQtoActShutdown;			/* action shutdown (in phase 2) */
	int iActionQtoEnq;				/* timeout for queue enque */
	int iActionQtoWrkShutdown;			/* timeout for worker thread shutdown */
	int iActionQWrkMinMsgs;				/* minimum messages per worker needed to start a new one */
	int bActionQSaveOnShutdown;			/* save queue on shutdown (when DA enabled)? */
	int64 iActionQueMaxDiskSpace;			/* max disk space allocated 0 ==&gt; unlimited */
	int iActionQueueDeqSlowdown;			/* dequeue slowdown (simple rate limiting) */
	int iActionQueueDeqtWinFromHr;			/* hour begin of time frame when queue is to be dequeued */
	int iActionQueueDeqtWinToHr;			/* hour begin of time frame when queue is to be dequeued */
} configSettings_t;


static configSettings_t cs;					/* our current config settings */

/* tables for interfacing with the v6 config system */
static struct cnfparamdescr cnfparamdescr[] = {
	{ &quot;name&quot;, eCmdHdlrGetWord, 0 }, /* legacy: actionname */
	{ &quot;type&quot;, eCmdHdlrString, CNFPARAM_REQUIRED }, /* legacy: actionname */
	{ &quot;action.errorfile&quot;, eCmdHdlrString, 0 },
	{ &quot;action.errorfile.maxsize&quot;, eCmdHdlrInt, 0 },
	{ &quot;action.writeallmarkmessages&quot;, eCmdHdlrBinary, 0 }, /* legacy: actionwriteallmarkmessages */
	{ &quot;action.execonlyeverynthtime&quot;, eCmdHdlrInt, 0 }, /* legacy: actionexeconlyeverynthtime */
	{ &quot;action.execonlyeverynthtimetimeout&quot;, eCmdHdlrInt, 0 }, /* legacy: actionexeconlyeverynthtimetimeout */
	{ &quot;action.execonlyonceeveryinterval&quot;, eCmdHdlrInt, 0 }, /* legacy: actionexeconlyonceeveryinterval */
	{ &quot;action.execonlywhenpreviousissuspended&quot;, eCmdHdlrBinary, 0 },
	/* legacy: actionexeconlywhenpreviousissuspended */
	{ &quot;action.repeatedmsgcontainsoriginalmsg&quot;, eCmdHdlrBinary, 0 }, /* legacy: repeatedmsgcontainsoriginalmsg */
	{ &quot;action.resumeretrycount&quot;, eCmdHdlrInt, 0 }, /* legacy: actionresumeretrycount */
	{ &quot;action.reportsuspension&quot;, eCmdHdlrBinary, 0 },
	{ &quot;action.reportsuspensioncontinuation&quot;, eCmdHdlrBinary, 0 },
	{ &quot;action.resumeintervalmax&quot;, eCmdHdlrPositiveInt, 0 },
	{ &quot;action.resumeinterval&quot;, eCmdHdlrInt, 0 },
	{ &quot;action.externalstate.file&quot;, eCmdHdlrString, 0 },
	{ &quot;action.copymsg&quot;, eCmdHdlrBinary, 0 }
};
static struct cnfparamblk pblk =
	{ CNFPARAMBLK_VERSION,
	  sizeof(cnfparamdescr)/sizeof(struct cnfparamdescr),
	  cnfparamdescr
	};


/* primarily a helper for debug purposes, get human-readble name of state */
/* currently not needed, but may be useful in the future! */
#if 0
static const char *
batchState2String(const batch_state_t state)
{
	switch(state) {
	case BATCH_STATE_RDY:
		return &quot;BATCH_STATE_RDY&quot;;
	case BATCH_STATE_BAD:
		return &quot;BATCH_STATE_BAD&quot;;
	case BATCH_STATE_SUB:
		return &quot;BATCH_STATE_SUB&quot;;
	case BATCH_STATE_COMM:
		return &quot;BATCH_STATE_COMM&quot;;
	case BATCH_STATE_DISC:
		return &quot;BATCH_STATE_DISC&quot;;
	default:
		return &quot;ERROR, batch state not known!&quot;;
	}
}
#endif // #if 0

/* ------------------------------ methods ------------------------------ */

/* This function returns the &quot;current&quot; time for this action. Current time
 * is not necessarily real-time. In order to enhance performance, current
 * system time is obtained the first time an action needs to know the time
 * and then kept cached inside the action structure. Later requests will
 * always return that very same time. Wile not totally accurate, it is far
 * accurate in most cases and considered &quot;acurate enough&quot; for all cases.
 * When changing the threading model, please keep in mind that this
 * logic needs to be changed should we once allow more than one parallel
 * call into the same action (object). As this is currently not supported,
 * we simply cache the time inside the action object itself, after it
 * is under mutex protection.
 * Side-note: the value -1 is used as tActNow, because it also is the
 * error return value of time(). So we would do a retry with the next
 * invocation if time() failed. Then, of course, we would probably already
 * be in trouble, but for the sake of performance we accept this very,
 * very slight risk.
 * This logic has been added as part of an overall performance improvment
 * effort inspired by David Lang. -- rgerhards, 2008-09-16
 * Note: this function does not use the usual iRet call conventions
 * because that would provide little to no benefit but complicate things
 * a lot. So we simply return the system time.
 */
static time_t
getActNow(action_t * const pThis)
{
	assert(pThis != NULL);
	if(pThis-&gt;tActNow == -1) {
		pThis-&gt;tActNow = datetime.GetTime(NULL); /* good time call - the only one done */
		if(pThis-&gt;tLastExec &gt; pThis-&gt;tActNow) {
			/* if we are traveling back in time, reset tLastExec */
			pThis-&gt;tLastExec = (time_t) 0;
		}
	}

	return pThis-&gt;tActNow;
}


/* resets action queue parameters to their default values. This happens
 * after each action has been created in order to prevent any wild defaults
 * to be used. It is somewhat against the original spirit of the config file
 * reader, but I think it is a good thing to do.
 * rgerhards, 2008-01-29
 */
static rsRetVal
actionResetQueueParams(void)
<A NAME="0"></A>{
	DEFiRet;

<FONT color="#0000ff"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match2224-0.html#0',2,'match2224-top.html#0',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>	cs.ActionQueType = QUEUETYPE_DIRECT;		/* type of the main message queue above */
	cs.iActionQueueSize = 1000;			/* size of the main message queue above */
	cs.iActionQueueDeqBatchSize = 16;		/* default batch size */
	cs.iActionQHighWtrMark = -1;			/* high water mark for disk-assisted queues */
	cs.iActionQLowWtrMark = -1;			/* low water mark for disk-assisted queues */
	cs.iActionQDiscardMark = 980;			/* begin to discard messages */
	cs.iActionQDiscardSeverity = 8;			/* discard warning and above */
	cs.iActionQueueNumWorkers = 1;			/* number of worker threads for the mm queue above */
	cs.iActionQueMaxFileSize = 1024*1024;
	cs.iActionQPersistUpdCnt = 0;			/* persist queue info every n updates */
	cs.bActionQSyncQeueFiles = 0;
	cs.iActionQtoQShutdown = 0;			/* queue shutdown */
	cs.iActionQtoActShutdown = 1000;		/* action shutdown (in phase 2) */
	cs.iActionQtoEnq = 50;				/* timeout for queue enque */
	cs.iActionQtoWrkShutdown = 60000;		/* timeout for worker thread shutdown */
	cs.iActionQWrkMinMsgs = -1;			/* minimum messages per worker needed to start a new one */
	cs.bActionQSaveOnShutdown = 1;			/* save queue on shutdown (when DA enabled)? */
	cs.iActionQueMaxDiskSpace = 0;
	cs.iActionQueueDeqSlowdown = 0;
	cs.iActionQueueDeqtWinFromHr = 0;
	cs.iActionQueueDeqtWinToHr = 25;		/* 25 disables time windowed dequeuing */

	cs.glbliActionResumeRetryCount = 0;		/* I guess it is smart to reset this one, too */

	free(cs.pszActionQFName);
	cs.pszActionQFName = NULL;			/* prefix for the main message queue file */</B></FONT>

	RETiRet;
}


/* destructs an action descriptor object
 * rgerhards, 2007-08-01
 */
rsRetVal actionDestruct(action_t * const pThis)
{
	DEFiRet;
	assert(pThis != NULL);

	if(!strcmp((char*)modGetName(pThis-&gt;pMod), &quot;builtin:omdiscard&quot;)) {
		/* discard actions will be optimized out */
		FINALIZE;
	}

	if(pThis-&gt;pQueue != NULL) {
		qqueueDestruct(&amp;pThis-&gt;pQueue);
	}

	/* destroy stats object, if we have one (may not always be
	 * be the case, e.g. if turned off)
	 */
	if(pThis-&gt;statsobj != NULL)
		statsobj.Destruct(&amp;pThis-&gt;statsobj);

	if(pThis-&gt;pModData != NULL)
		pThis-&gt;pMod-&gt;freeInstance(pThis-&gt;pModData);

	if(pThis-&gt;fdErrFile != -1)
		close(pThis-&gt;fdErrFile);
	pthread_mutex_destroy(&amp;pThis-&gt;mutErrFile);
	pthread_mutex_destroy(&amp;pThis-&gt;mutAction);
	pthread_mutex_destroy(&amp;pThis-&gt;mutWrkrDataTable);
	free((void*)pThis-&gt;pszErrFile);
	free((void*)pThis-&gt;pszExternalStateFile);
	free(pThis-&gt;pszName);
	free(pThis-&gt;ppTpl);
	free(pThis-&gt;peParamPassing);
	free(pThis-&gt;wrkrDataTable);

finalize_it:
	free(pThis);
	RETiRet;
}


/* Disable action, this means it will never again be usable
 * until rsyslog is reloaded. Use only as a last resort, but
 * depends on output module.
 * rgerhards, 2007-08-02
 */
static inline void
actionDisable(action_t *__restrict__ const pThis)
{
	pThis-&gt;bDisabled = 1;
}



/* create a new action descriptor object
 * rgerhards, 2007-08-01
 * Note that it is vital to set proper initial values as the v6 config
 * system depends on these!
 */
rsRetVal actionConstruct(action_t **ppThis)
{
	DEFiRet;
	action_t *pThis;

	assert(ppThis != NULL);

	CHKmalloc(pThis = (action_t*) calloc(1, sizeof(action_t)));
	pThis-&gt;iResumeInterval = 30;
	pThis-&gt;iResumeIntervalMax = 1800; /* max interval default is half an hour */
	pThis-&gt;iResumeRetryCount = 0;
	pThis-&gt;pszName = NULL;
	pThis-&gt;pszErrFile = NULL;
<A NAME="3"></A>	pThis-&gt;maxErrFileSize = 0;
	pThis-&gt;currentErrFileSize = 0;
	pThis-&gt;pszExternalStateFile = NULL;
<FONT color="#53858b"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match2224-0.html#3',2,'match2224-top.html#3',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>	pThis-&gt;fdErrFile = -1;
	pThis-&gt;bWriteAllMarkMsgs = 1;
	pThis-&gt;iExecEveryNthOccur = 0;
	pThis-&gt;iExecEveryNthOccurTO = 0;
	pThis-&gt;iSecsExecOnceInterval = 0;
	pThis-&gt;bExecWhenPrevSusp = 0;
	pThis-&gt;bRepMsgHasMsg = 0;
	pThis-&gt;bDisabled = 0;
	pThis-&gt;isTransactional = 0;
	pThis-&gt;bReportSuspension = -1; /* indicate &quot;not yet set&quot; */
	pThis-&gt;bReportSuspensionCont = -1; /* indicate &quot;not yet set&quot; */
	pThis-&gt;bCopyMsg = 0;</B></FONT>
	pThis-&gt;tLastOccur = datetime.GetTime(NULL);	/* done once per action on startup only */
	pThis-&gt;iActionNbr = loadConf-&gt;actions.iActionNbr;
	pthread_mutex_init(&amp;pThis-&gt;mutErrFile, NULL);
	pthread_mutex_init(&amp;pThis-&gt;mutAction, NULL);
	pthread_mutex_init(&amp;pThis-&gt;mutWrkrDataTable, NULL);
	INIT_ATOMIC_HELPER_MUT(pThis-&gt;mutCAS);

	/* indicate we have a new action */
	loadConf-&gt;actions.iActionNbr++;

finalize_it:
	*ppThis = pThis;
	RETiRet;
}


/* action construction finalizer
 */
rsRetVal
actionConstructFinalize(action_t *__restrict__ const pThis, struct nvlst *lst)
{
	DEFiRet;
	uchar pszAName[64]; /* friendly name of our action */

	if(!strcmp((char*)modGetName(pThis-&gt;pMod), &quot;builtin:omdiscard&quot;)) {
		/* discard actions will be optimized out */
		FINALIZE;
	}
	/* generate a friendly name for us action stats */
	if(pThis-&gt;pszName == NULL) {
		snprintf((char*) pszAName, sizeof(pszAName), &quot;action-%d-%s&quot;,
			pThis-&gt;iActionNbr, pThis-&gt;pMod-&gt;pszName);
		pThis-&gt;pszName = ustrdup(pszAName);
	}

	/* cache transactional attribute */
	pThis-&gt;isTransactional = pThis-&gt;pMod-&gt;mod.om.supportsTX;
	if(pThis-&gt;isTransactional) {
		int i;
		for(i = 0 ; i &lt; pThis-&gt;iNumTpls ; ++i) {
			if(pThis-&gt;peParamPassing[i] != ACT_STRING_PASSING) {
				LogError(0, RS_RET_INVLD_OMOD, &quot;action '%s'(%d) is transactional but &quot;
						&quot;parameter %d &quot;
						&quot;uses invalid parameter passing mode -- disabling &quot;
						&quot;action. This is probably caused by a pre-v7 &quot;
						&quot;output module that needs upgrade.&quot;,
						pThis-&gt;pszName, pThis-&gt;iActionNbr, i);
				actionDisable(pThis);
				ABORT_FINALIZE(RS_RET_INVLD_OMOD);

			}
		}
	}


	/* support statistics gathering */
	CHKiRet(statsobj.Construct(&amp;pThis-&gt;statsobj));
	CHKiRet(statsobj.SetName(pThis-&gt;statsobj, pThis-&gt;pszName));
	CHKiRet(statsobj.SetOrigin(pThis-&gt;statsobj, (uchar*)&quot;core.action&quot;));

	STATSCOUNTER_INIT(pThis-&gt;ctrProcessed, pThis-&gt;mutCtrProcessed);
	CHKiRet(statsobj.AddCounter(pThis-&gt;statsobj, UCHAR_CONSTANT(&quot;processed&quot;),
		ctrType_IntCtr, CTR_FLAG_RESETTABLE, &amp;pThis-&gt;ctrProcessed));

	STATSCOUNTER_INIT(pThis-&gt;ctrFail, pThis-&gt;mutCtrFail);
	CHKiRet(statsobj.AddCounter(pThis-&gt;statsobj, UCHAR_CONSTANT(&quot;failed&quot;),
		ctrType_IntCtr, CTR_FLAG_RESETTABLE, &amp;pThis-&gt;ctrFail));

	STATSCOUNTER_INIT(pThis-&gt;ctrSuspend, pThis-&gt;mutCtrSuspend);
	CHKiRet(statsobj.AddCounter(pThis-&gt;statsobj, UCHAR_CONSTANT(&quot;suspended&quot;),
		ctrType_IntCtr, CTR_FLAG_RESETTABLE, &amp;pThis-&gt;ctrSuspend));
	STATSCOUNTER_INIT(pThis-&gt;ctrSuspendDuration, pThis-&gt;mutCtrSuspendDuration);
	CHKiRet(statsobj.AddCounter(pThis-&gt;statsobj, UCHAR_CONSTANT(&quot;suspended.duration&quot;),
		ctrType_IntCtr, 0, &amp;pThis-&gt;ctrSuspendDuration));

	STATSCOUNTER_INIT(pThis-&gt;ctrResume, pThis-&gt;mutCtrResume);
	CHKiRet(statsobj.AddCounter(pThis-&gt;statsobj, UCHAR_CONSTANT(&quot;resumed&quot;),
		ctrType_IntCtr, CTR_FLAG_RESETTABLE, &amp;pThis-&gt;ctrResume));

	CHKiRet(statsobj.ConstructFinalize(pThis-&gt;statsobj));

	/* create our queue */

	/* generate a friendly name for the queue */
	snprintf((char*) pszAName, sizeof(pszAName), &quot;%s queue&quot;,
		 pThis-&gt;pszName);

	/* now check if we can run the action in &quot;firehose mode&quot; during stage one of
	 * its processing (that is before messages are enqueued into the action q).
	 * This is only possible if some features, which require strict sequence, are
	 * not used. Thankfully, that is usually the case. The benefit of firehose
	 * mode is much faster processing (and simpler code) -- rgerhards, 2010-06-08
	 */
	if(   pThis-&gt;iExecEveryNthOccur &gt; 1
	   || pThis-&gt;iSecsExecOnceInterval
	  ) {
		DBGPRINTF(&quot;info: firehose mode disabled for action because &quot;
		          &quot;iExecEveryNthOccur=%d, iSecsExecOnceInterval=%d\n&quot;,
			  pThis-&gt;iExecEveryNthOccur, pThis-&gt;iSecsExecOnceInterval);
		pThis-&gt;submitToActQ = doSubmitToActionQComplex;
	} else if(pThis-&gt;bWriteAllMarkMsgs) {
		/* full firehose submission mode, default case*/
		pThis-&gt;submitToActQ = doSubmitToActionQ;
	} else {
		/* nearly full-speed submission mode */
		pThis-&gt;submitToActQ = doSubmitToActionQNotAllMark;
	}

	/* create queue */
	/* action queues always (for now) have just one worker. This may change when
	 * we begin to implement an interface the enable output modules to request
	 * to be run on multiple threads. So far, this is forbidden by the interface
	 * spec. -- rgerhards, 2008-01-30
	 */
	CHKiRet(qqueueConstruct(&amp;pThis-&gt;pQueue, cs.ActionQueType, 1, cs.iActionQueueSize,
					processBatchMain));
	obj.SetName((obj_t*) pThis-&gt;pQueue, pszAName);
	qqueueSetpAction(pThis-&gt;pQueue, pThis);

	if(lst == NULL) { /* use legacy params? */
		/* ... set some properties ... */
#		define setQPROP(func, directive, data) \
		CHKiRet_Hdlr(func(pThis-&gt;pQueue, data)) { \
			LogError(0, NO_ERRCODE, &quot;Invalid &quot; #directive &quot;, \
				error %d. Ignored, running with default setting&quot;, iRet); \
		}
#		define setQPROPstr(func, directive, data) \
		CHKiRet_Hdlr(func(pThis-&gt;pQueue, data, (data == NULL)? 0 : strlen((char*) data))) { \
			LogError(0, NO_ERRCODE, &quot;Invalid &quot; #directive &quot;, \
				error %d. Ignored, running with default setting&quot;, iRet); \
		}
		setQPROP(qqueueSetsizeOnDiskMax, &quot;$ActionQueueMaxDiskSpace&quot;, cs.iActionQueMaxDiskSpace);
		setQPROP(qqueueSetiDeqBatchSize, &quot;$ActionQueueDequeueBatchSize&quot;, cs.iActionQueueDeqBatchSize);
		setQPROP(qqueueSetMaxFileSize, &quot;$ActionQueueFileSize&quot;, cs.iActionQueMaxFileSize);
		setQPROPstr(qqueueSetFilePrefix, &quot;$ActionQueueFileName&quot;, cs.pszActionQFName);
		setQPROP(qqueueSetiPersistUpdCnt, &quot;$ActionQueueCheckpointInterval&quot;, cs.iActionQPersistUpdCnt);
		setQPROP(qqueueSetbSyncQueueFiles, &quot;$ActionQueueSyncQueueFiles&quot;, cs.bActionQSyncQeueFiles);
		setQPROP(qqueueSettoQShutdown, &quot;$ActionQueueTimeoutShutdown&quot;, cs.iActionQtoQShutdown );
		setQPROP(qqueueSettoActShutdown, &quot;$ActionQueueTimeoutActionCompletion&quot;, cs.iActionQtoActShutdown);
		setQPROP(qqueueSettoWrkShutdown, &quot;$ActionQueueWorkerTimeoutThreadShutdown&quot;, cs.iActionQtoWrkShutdown);
		setQPROP(qqueueSettoEnq, &quot;$ActionQueueTimeoutEnqueue&quot;, cs.iActionQtoEnq);
		setQPROP(qqueueSetiHighWtrMrk, &quot;$ActionQueueHighWaterMark&quot;, cs.iActionQHighWtrMark);
		setQPROP(qqueueSetiLowWtrMrk, &quot;$ActionQueueLowWaterMark&quot;, cs.iActionQLowWtrMark);
		setQPROP(qqueueSetiDiscardMrk, &quot;$ActionQueueDiscardMark&quot;, cs.iActionQDiscardMark);
		setQPROP(qqueueSetiDiscardSeverity, &quot;$ActionQueueDiscardSeverity&quot;, cs.iActionQDiscardSeverity);
		setQPROP(qqueueSetiMinMsgsPerWrkr, &quot;$ActionQueueWorkerThreadMinimumMessages&quot;, cs.iActionQWrkMinMsgs);
		setQPROP(qqueueSetiNumWorkerThreads, &quot;$ActionQueueWorkerThreads&quot;, cs.iActionQueueNumWorkers);
		setQPROP(qqueueSetbSaveOnShutdown, &quot;$ActionQueueSaveOnShutdown&quot;, cs.bActionQSaveOnShutdown);
		setQPROP(qqueueSetiDeqSlowdown,    &quot;$ActionQueueDequeueSlowdown&quot;, cs.iActionQueueDeqSlowdown);
		setQPROP(qqueueSetiDeqtWinFromHr,  &quot;$ActionQueueDequeueTimeBegin&quot;, cs.iActionQueueDeqtWinFromHr);
		setQPROP(qqueueSetiDeqtWinToHr,    &quot;$ActionQueueDequeueTimeEnd&quot;, cs.iActionQueueDeqtWinToHr);
	} else {
		/* we have v6-style config params */
		qqueueSetDefaultsActionQueue(pThis-&gt;pQueue);
		qqueueApplyCnfParam(pThis-&gt;pQueue, lst);
	}
	qqueueCorrectParams(pThis-&gt;pQueue);

#	undef setQPROP
#	undef setQPROPstr

	qqueueDbgPrint(pThis-&gt;pQueue);

	DBGPRINTF(&quot;Action %p: queue %p created\n&quot;, pThis, pThis-&gt;pQueue);

	if(pThis-&gt;bUsesMsgPassingMode &amp;&amp; pThis-&gt;pQueue-&gt;qType != QUEUETYPE_DIRECT) {
		parser_warnmsg(&quot;module %s with message passing mode uses &quot;
			&quot;non-direct queue. This most probably leads to undesired &quot;
			&quot;results. For message modificaton modules (mm*), this means &quot;
			&quot;that they will have no effect - &quot;
			&quot;see https://www.rsyslog.com/mm-no-queue/&quot;, (char*)modGetName(pThis-&gt;pMod));
	}

	/* and now reset the queue params (see comment in its function header!) */
	actionResetQueueParams();

finalize_it:
	RETiRet;
}



/* set the global resume interval
 */
rsRetVal actionSetGlobalResumeInterval(int iNewVal)
{
	cs.glbliActionResumeInterval = iNewVal;
	return RS_RET_OK;
}


/* returns the action state name in human-readable form
 * returned string must not be modified.
 * rgerhards, 2009-05-07
 */
static uchar *getActStateName(action_t * const pThis, wti_t * const pWti)
{
	switch(getActionState(pWti, pThis)) {
		case ACT_STATE_RDY:
			return (uchar*) &quot;rdy&quot;;
		case ACT_STATE_ITX:
			return (uchar*) &quot;itx&quot;;
		case ACT_STATE_RTRY:
			return (uchar*) &quot;rtry&quot;;
		case ACT_STATE_SUSP:
			return (uchar*) &quot;susp&quot;;
		case ACT_STATE_DATAFAIL:
			return (uchar*) &quot;datafail&quot;;
		default:
			return (uchar*) &quot;ERROR/UNKNWON&quot;;
	}
}


/* returns a suitable return code based on action state
 * rgerhards, 2009-05-07
 */
static rsRetVal getReturnCode(action_t * const pThis, wti_t * const pWti)
{
	DEFiRet;

	switch(getActionState(pWti, pThis)) {
		case ACT_STATE_RDY:
			iRet = RS_RET_OK;
			break;
		case ACT_STATE_ITX:
			if(pWti-&gt;actWrkrInfo[pThis-&gt;iActionNbr].bHadAutoCommit) {
				pWti-&gt;actWrkrInfo[pThis-&gt;iActionNbr].bHadAutoCommit = 0; /* auto-reset */
				iRet = RS_RET_PREVIOUS_COMMITTED;
			} else {
				iRet = RS_RET_DEFER_COMMIT;
			}
			break;
		case ACT_STATE_RTRY:
			iRet = RS_RET_SUSPENDED;
			break;
		case ACT_STATE_SUSP:
			iRet = RS_RET_ACTION_FAILED;
			break;
		case ACT_STATE_DATAFAIL:
			iRet = RS_RET_DATAFAIL;
			break;
		default:
			DBGPRINTF(&quot;Invalid action engine state %u, program error\n&quot;,
				  getActionState(pWti, pThis));
			iRet = RS_RET_ERR;
			break;
	}

	RETiRet;
}


/* set the action to a new state
 * rgerhards, 2007-08-02
 */
static void
actionSetState(action_t * const pThis, wti_t * const pWti, uint8_t newState)
{
	setActionState(pWti, pThis, newState);
	DBGPRINTF(&quot;action[%s] transitioned to state: %s\n&quot;,
		  pThis-&gt;pszName, getActStateName(pThis, pWti));
}

/* Handles the transient commit state. So far, this is
 * mostly a dummy...
 * rgerhards, 2007-08-02
 */
static void actionCommitted(action_t * const pThis, wti_t * const pWti)
{
	actionSetState(pThis, pWti, ACT_STATE_RDY);
}


/* set action state according to external state file (if configured)
*/
static rsRetVal ATTR_NONNULL()
checkExternalStateFile(action_t *const pThis, wti_t *const pWti)
{
	char filebuf[1024];
	int fd = -1;
	int r;
	DEFiRet;

	DBGPRINTF(&quot;checking external state file\n&quot;);

	if(pThis-&gt;pszExternalStateFile == NULL) {
		FINALIZE;
	}

	fd = open(pThis-&gt;pszExternalStateFile, O_RDONLY|O_CLOEXEC);
	if(fd == -1) {
		dbgprintf(&quot;could not read external state file\n&quot;);
		FINALIZE;
	}

	r = read(fd, filebuf, sizeof(filebuf) - 1);
	if(r &lt; 1) {
		dbgprintf(&quot;checkExternalStateFile read() returned %d\n&quot;, r);
		FINALIZE;
	}

	filebuf[r] = '\0';
	dbgprintf(&quot;external state file content: '%s'\n&quot;, filebuf);
	/* trim trailing whitespace */
	for(int j = r-1 ; j &gt; 0 ; --j) {
		if(filebuf[j] == '\n' || filebuf[j] == '\t' || filebuf[j] == ' ') {
			filebuf[j] = '\0';
		} else {
			break;
		}
	}
	if(!strcmp(filebuf, &quot;SUSPENDED&quot;)) {
		LogMsg(0, RS_RET_SUSPENDED, LOG_WARNING,
		      &quot;action '%s' suspended (module '%s') by external state file&quot;,
		      pThis-&gt;pszName, pThis-&gt;pMod-&gt;pszName);
		actionRetry(pThis, pWti);
		ABORT_FINALIZE(RS_RET_SUSPENDED);
	}

finalize_it:
	if(fd != -1) {
		close(fd);
	}
	DBGPRINTF(&quot;done checking external state file, iRet=%d\n&quot;, iRet);
	RETiRet;
}


/* we need to defer setting the action's own bReportSuspension state until
 * after the full config has been processed. So the most simple case to do
 * that is here. It's not a performance problem, as it happens infrequently.
 * it's not a threading race problem, as always the same value will be written.
 * As we need to do this in several places, we have moved the code to its own
 * helper function.
 */
static void
setSuspendMessageConfVars(action_t *__restrict__ const pThis)
{
	if(pThis-&gt;bReportSuspension == -1)
		pThis-&gt;bReportSuspension = runConf-&gt;globals.bActionReportSuspension;
	if(pThis-&gt;bReportSuspensionCont == -1) {
		pThis-&gt;bReportSuspensionCont = runConf-&gt;globals.bActionReportSuspensionCont;
		if(pThis-&gt;bReportSuspensionCont == -1)
			pThis-&gt;bReportSuspensionCont = 1;
	}
}


/* set action to &quot;rtry&quot; state.
 * rgerhards, 2007-08-02
 */
static void ATTR_NONNULL() actionRetry(action_t * const pThis, wti_t * const pWti)
{
	setSuspendMessageConfVars(pThis);
	actionSetState(pThis, pWti, ACT_STATE_RTRY);
	if(pThis-&gt;bReportSuspension) {
		LogMsg(0, RS_RET_SUSPENDED, LOG_WARNING,
		      &quot;action '%s' suspended (module '%s'), retry %d. There should &quot;
		      &quot;be messages before this one giving the reason for suspension.&quot;,
		      pThis-&gt;pszName, pThis-&gt;pMod-&gt;pszName,
		      getActionNbrResRtry(pWti, pThis));
	}
	incActionResumeInRow(pWti, pThis);
}

/* Suspend action, this involves changing the action state as well
 * as setting the next retry time.
 * if we have more than 10 retries, we prolong the
 * retry interval. If something is really stalled, it will
 * get re-tried only very, very seldom - but that saves
 * CPU time. TODO: maybe a config option for that?
 * rgerhards, 2007-08-02
 */
static void ATTR_NONNULL()
actionSuspend(action_t * const pThis, wti_t * const pWti)
{
	time_t ttNow;
	int suspendDuration;
	char timebuf[32];

	setSuspendMessageConfVars(pThis);

	/* note: we can NOT use a cached timestamp, as time may have evolved
	 * since caching, and this would break logic (and it actually did so!)
	 */
	datetime.GetTime(&amp;ttNow);
	suspendDuration = pThis-&gt;iResumeInterval * (getActionNbrResRtry(pWti, pThis) / 10 + 1);
	if(pThis-&gt;iResumeIntervalMax &gt; 0 &amp;&amp; suspendDuration &gt; pThis-&gt;iResumeIntervalMax) {
		suspendDuration = pThis-&gt;iResumeIntervalMax;
	}
	pThis-&gt;ttResumeRtry = ttNow + suspendDuration;
	actionSetState(pThis, pWti, ACT_STATE_SUSP);
	pThis-&gt;ctrSuspendDuration += suspendDuration;
	if(getActionNbrResRtry(pWti, pThis) == 0) {
		STATSCOUNTER_INC(pThis-&gt;ctrSuspend, pThis-&gt;mutCtrSuspend);
	}

	if(   pThis-&gt;bReportSuspensionCont
	   || (pThis-&gt;bReportSuspension &amp;&amp; getActionNbrResRtry(pWti, pThis) == 0) ) {
		ctime_r(&amp;pThis-&gt;ttResumeRtry, timebuf);
		timebuf[strlen(timebuf)-1] = '\0'; /* strip LF */
		LogMsg(0, RS_RET_SUSPENDED, LOG_WARNING,
			      &quot;action '%s' suspended (module '%s'), next retry is %s, retry nbr %d. &quot;
			      &quot;There should be messages before this one giving the reason for suspension.&quot;,
			      pThis-&gt;pszName, pThis-&gt;pMod-&gt;pszName, timebuf,
			      getActionNbrResRtry(pWti, pThis));
	}
	DBGPRINTF(&quot;action '%s' suspended, earliest retry=%lld (now %lld), iNbrResRtry %d, &quot;
		  &quot;duration %d\n&quot;,
		  pThis-&gt;pszName, (long long) pThis-&gt;ttResumeRtry, (long long) ttNow,
		  getActionNbrResRtry(pWti, pThis), suspendDuration);
}


/* actually do retry processing. Note that the function receives a timestamp so
 * that we do not need to call the (expensive) time() API.
 * Note that we do the full retry processing here, doing the configured number of
 * iterations. -- rgerhards, 2009-05-07
 * We need to guard against module which always return RS_RET_OK from their tryResume()
 * entry point. This is invalid, but has harsh consequences: it will cause the rsyslog
 * engine to go into a tight loop. That obviously is not acceptable. As such, we track the
 * count of iterations that a tryResume returning RS_RET_OK is immediately followed by
 * an unsuccessful call to doAction(). If that happens more than 10 times, we assume
 * the return acutally is a RS_RET_SUSPENDED. In order to go through the various
 * resumption stages, we do this for every 10 requests. This magic number 10 may
 * not be the most appropriate, but it should be thought of a &quot;if nothing else helps&quot;
 * kind of facility: in the first place, the module should return a proper indication
 * of its inability to recover. -- rgerhards, 2010-04-26.
 */
static rsRetVal ATTR_NONNULL()
actionDoRetry(action_t * const pThis, wti_t * const pWti)
{
	int iRetries;
	int iSleepPeriod;
	int bTreatOKasSusp;
	DEFiRet;

	assert(pThis != NULL);

	iRetries = 0;
	while((*pWti-&gt;pbShutdownImmediate == 0) &amp;&amp; getActionState(pWti, pThis) == ACT_STATE_RTRY) {
		DBGPRINTF(&quot;actionDoRetry: %s enter loop, iRetries=%d, ResumeInRow %d\n&quot;,
			pThis-&gt;pszName, iRetries, getActionResumeInRow(pWti, pThis));
			iRet = pThis-&gt;pMod-&gt;tryResume(pWti-&gt;actWrkrInfo[pThis-&gt;iActionNbr].actWrkrData);
		DBGPRINTF(&quot;actionDoRetry: %s action-&gt;tryResume returned %d\n&quot;, pThis-&gt;pszName, iRet);
		if((getActionResumeInRow(pWti, pThis) &gt; 9) &amp;&amp; (getActionResumeInRow(pWti, pThis) % 10 == 0)) {
			bTreatOKasSusp = 1;
			setActionResumeInRow(pWti, pThis, 0);
			iRet = RS_RET_SUSPENDED;
		} else {
			bTreatOKasSusp = 0;
		}
		if((iRet == RS_RET_OK) &amp;&amp; (!bTreatOKasSusp)) {
			DBGPRINTF(&quot;actionDoRetry: %s had success RDY again (iRet=%d)\n&quot;,
				  pThis-&gt;pszName, iRet);
			STATSCOUNTER_INC(pThis-&gt;ctrResume, pThis-&gt;mutCtrResume);
			if(pThis-&gt;bReportSuspension) {
				LogMsg(0, RS_RET_RESUMED, LOG_INFO, &quot;action '%s' &quot;
					      &quot;resumed (module '%s')&quot;,
					      pThis-&gt;pszName, pThis-&gt;pMod-&gt;pszName);
			}
			actionSetState(pThis, pWti, ACT_STATE_RDY);
		} else if(iRet == RS_RET_SUSPENDED || bTreatOKasSusp) {
			/* max retries reached? */
			DBGPRINTF(&quot;actionDoRetry: %s check for max retries, iResumeRetryCount &quot;
				  &quot;%d, iRetries %d\n&quot;,
				  pThis-&gt;pszName, pThis-&gt;iResumeRetryCount, iRetries);
			if((pThis-&gt;iResumeRetryCount != -1 &amp;&amp; iRetries &gt;= pThis-&gt;iResumeRetryCount)) {
				actionSuspend(pThis, pWti);
				if(getActionNbrResRtry(pWti, pThis) &lt; 20)
					incActionNbrResRtry(pWti, pThis);
			} else {
				++iRetries;
				iSleepPeriod = pThis-&gt;iResumeInterval;
				srSleep(iSleepPeriod, 0);
				if(*pWti-&gt;pbShutdownImmediate) {
					ABORT_FINALIZE(RS_RET_FORCE_TERM);
				}
			}
		} else if(iRet == RS_RET_DISABLE_ACTION) {
			actionDisable(pThis);
		}
	}

	if(getActionState(pWti, pThis) == ACT_STATE_RDY) {
		setActionNbrResRtry(pWti, pThis, 0);
	}

finalize_it:
	RETiRet;
}


/* special retry handling if disabled via file: simply wait for the file
 * to indicate whether or not it is ready again
 */
static rsRetVal ATTR_NONNULL()
actionDoRetry_extFile(action_t *const pThis, wti_t *const pWti)
{
	int iRetries;
	int iSleepPeriod;
	DEFiRet;

	assert(pThis != NULL);

	DBGPRINTF(&quot;actionDoRetry_extFile: enter, actionState: %d\n&quot;,getActionState(pWti, pThis));
	iRetries = 0;
	while((*pWti-&gt;pbShutdownImmediate == 0) &amp;&amp; getActionState(pWti, pThis) == ACT_STATE_RTRY) {
		DBGPRINTF(&quot;actionDoRetry_extFile: %s enter loop, iRetries=%d, ResumeInRow %d\n&quot;,
			pThis-&gt;pszName, iRetries, getActionResumeInRow(pWti, pThis));
			iRet = checkExternalStateFile(pThis, pWti);
		DBGPRINTF(&quot;actionDoRetry_extFile: %s checkExternalStateFile returned %d\n&quot;, pThis-&gt;pszName, iRet);
		if(iRet == RS_RET_OK) {
			DBGPRINTF(&quot;actionDoRetry_extFile: %s had success RDY again (iRet=%d)\n&quot;,
				  pThis-&gt;pszName, iRet);
			if(pThis-&gt;bReportSuspension) {
				LogMsg(0, RS_RET_RESUMED, LOG_INFO, &quot;action '%s' &quot;
				      &quot;resumed (module '%s') via external state file&quot;,
				      pThis-&gt;pszName, pThis-&gt;pMod-&gt;pszName);
			}
			actionSetState(pThis, pWti, ACT_STATE_RDY);
		} else if(iRet == RS_RET_SUSPENDED) {
			/* max retries reached? */
			DBGPRINTF(&quot;actionDoRetry_extFile: %s check for max retries, iResumeRetryCount &quot;
				  &quot;%d, iRetries %d\n&quot;,
				  pThis-&gt;pszName, pThis-&gt;iResumeRetryCount, iRetries);
			if((pThis-&gt;iResumeRetryCount != -1 &amp;&amp; iRetries &gt;= pThis-&gt;iResumeRetryCount)) {
				DBGPRINTF(&quot;actionDoRetry_extFile: did not work out, suspending\n&quot;);
				actionSuspend(pThis, pWti);
				pWti-&gt;execState.bPrevWasSuspended = 1;
				if(getActionNbrResRtry(pWti, pThis) &lt; 20)
					incActionNbrResRtry(pWti, pThis);
			} else {
				++iRetries;
				iSleepPeriod = pThis-&gt;iResumeInterval;
				srSleep(iSleepPeriod, 0);
				if(*pWti-&gt;pbShutdownImmediate) {
					ABORT_FINALIZE(RS_RET_FORCE_TERM);
				}
			}
		} else if(iRet == RS_RET_DISABLE_ACTION) {
			actionDisable(pThis);
		}
	}

	if(getActionState(pWti, pThis) == ACT_STATE_RDY) {
		setActionNbrResRtry(pWti, pThis, 0);
	}

finalize_it:
	RETiRet;
}

static rsRetVal
actionCheckAndCreateWrkrInstance(action_t * const pThis, const wti_t *const pWti)
{
	int locked = 0;
	DEFiRet;
	if(pWti-&gt;actWrkrInfo[pThis-&gt;iActionNbr].actWrkrData == NULL) {
		DBGPRINTF(&quot;wti %p: we need to create a new action worker instance for &quot;
			  &quot;action %d\n&quot;, pWti, pThis-&gt;iActionNbr);
		CHKiRet(pThis-&gt;pMod-&gt;mod.om.createWrkrInstance(&amp;(pWti-&gt;actWrkrInfo[pThis-&gt;iActionNbr].actWrkrData),
						               pThis-&gt;pModData));
		pWti-&gt;actWrkrInfo[pThis-&gt;iActionNbr].pAction = pThis;
		setActionState(pWti, pThis, ACT_STATE_RDY); /* action is enabled */

		/* maintain worker data table -- only needed if wrkrHUP is requested! */

		pthread_mutex_lock(&amp;pThis-&gt;mutWrkrDataTable);
		locked = 1;
		int freeSpot;
		for(freeSpot = 0 ; freeSpot &lt; pThis-&gt;wrkrDataTableSize ; ++freeSpot)
			if(pThis-&gt;wrkrDataTable[freeSpot] == NULL)
				break;
		if(pThis-&gt;nWrkr == pThis-&gt;wrkrDataTableSize) {
			void *const newTable = realloc(pThis-&gt;wrkrDataTable,
				(pThis-&gt;wrkrDataTableSize + 1) * sizeof(void*));
			if(newTable == NULL) {
				DBGPRINTF(&quot;actionCheckAndCreateWrkrInstance: out of &quot;
					&quot;memory realloc wrkrDataTable\n&quot;)
				ABORT_FINALIZE(RS_RET_OUT_OF_MEMORY);
			}
			pThis-&gt;wrkrDataTable = newTable;
			pThis-&gt;wrkrDataTableSize++;
		}
		pThis-&gt;wrkrDataTable[freeSpot] = pWti-&gt;actWrkrInfo[pThis-&gt;iActionNbr].actWrkrData;
		pThis-&gt;nWrkr++;
		DBGPRINTF(&quot;wti %p: created action worker instance %d for &quot;
			  &quot;action %d\n&quot;, pWti, pThis-&gt;nWrkr, pThis-&gt;iActionNbr);
	}
finalize_it:
	if(locked) {
		pthread_mutex_unlock(&amp;pThis-&gt;mutWrkrDataTable);
	}
	RETiRet;
}

/* try to resume an action -- rgerhards, 2007-08-02
 * changed to new action state engine -- rgerhards, 2009-05-07
 */
static rsRetVal
actionTryResume(action_t * const pThis, wti_t * const pWti)
{
	DEFiRet;
	time_t ttNow = NO_TIME_PROVIDED;

	if(getActionState(pWti, pThis) == ACT_STATE_SUSP) {
		/* if we are suspended, we need to check if the timeout expired.
		 * for this handling, we must always obtain a fresh timestamp. We used
		 * to use the action timestamp, but in this case we will never reach a
		 * point where a resumption is actually tried, because the action timestamp
		 * is always in the past. So we can not avoid doing a fresh time() call
		 * here. -- rgerhards, 2009-03-18
		 */
		datetime.GetTime(&amp;ttNow); /* cache &quot;now&quot; */
		if(ttNow &gt;= pThis-&gt;ttResumeRtry) {
			actionSetState(pThis, pWti, ACT_STATE_RTRY); /* back to retries */
		}
	}

	if(getActionState(pWti, pThis) == ACT_STATE_RTRY) {
		CHKiRet(actionDoRetry(pThis, pWti));
	}

	if(Debug &amp;&amp; (getActionState(pWti, pThis) == ACT_STATE_RTRY ||
		getActionState(pWti, pThis) == ACT_STATE_SUSP)) {
		if(ttNow == NO_TIME_PROVIDED) /* use cached result if we have it */
			datetime.GetTime(&amp;ttNow);
		dbgprintf(&quot;actionTryResume: action[%s] state: %s, next retry (if applicable): %u [now %u]\n&quot;,
			pThis-&gt;pszName, getActStateName(pThis, pWti),
			(unsigned) pThis-&gt;ttResumeRtry, (unsigned) ttNow);
	}

finalize_it:
	RETiRet;
}


/* prepare an action for performing work. This involves trying to recover it,
 * depending on its current state.
 * rgerhards, 2009-05-07
 */
static rsRetVal ATTR_NONNULL()
actionPrepare(action_t *__restrict__ const pThis, wti_t *__restrict__ const pWti)
{
	DEFiRet;

DBGPRINTF(&quot;actionPrepare[%s]: enter\n&quot;, pThis-&gt;pszName);
	CHKiRet(actionCheckAndCreateWrkrInstance(pThis, pWti));
	CHKiRet(actionTryResume(pThis, pWti));

	/* if we are now ready, we initialize the transaction and advance
	 * action state accordingly
	 */
	if(getActionState(pWti, pThis) == ACT_STATE_RDY) {
		iRet = checkExternalStateFile(pThis, pWti);
		if(iRet == RS_RET_SUSPENDED) {
			DBGPRINTF(&quot;actionPrepare[%s]: SUSPENDED via external state file, &quot;
				&quot;doing retry processing\n&quot;, pThis-&gt;pszName);
			CHKiRet(actionDoRetry_extFile(pThis, pWti));
		}
		iRet = pThis-&gt;pMod-&gt;mod.om.beginTransaction(pWti-&gt;actWrkrInfo[pThis-&gt;iActionNbr].actWrkrData);
		switch(iRet) {
			case RS_RET_OK:
				actionSetState(pThis, pWti, ACT_STATE_ITX);
				break;
			case RS_RET_SUSPENDED:
				actionRetry(pThis, pWti);
				break;
			case RS_RET_DISABLE_ACTION:
				actionDisable(pThis);
				break;
			default:FINALIZE;
		}
	}

finalize_it:
	RETiRet;
}


/* prepare the calling parameters for doAction()
 * rgerhards, 2009-05-07
 */
static rsRetVal
prepareDoActionParams(action_t * __restrict__ const pAction,
		      wti_t * __restrict__ const pWti,
		      smsg_t *__restrict__ const pMsg,
		      struct syslogTime *ttNow)
{
	int i;
	struct json_object *json;
	actWrkrIParams_t *iparams;
	actWrkrInfo_t *__restrict__ pWrkrInfo;
	DEFiRet;

	pWrkrInfo = &amp;(pWti-&gt;actWrkrInfo[pAction-&gt;iActionNbr]);
	if(pAction-&gt;isTransactional) {
		CHKiRet(wtiNewIParam(pWti, pAction, &amp;iparams));
		for(i = 0 ; i &lt; pAction-&gt;iNumTpls ; ++i) {
			CHKiRet(tplToString(pAction-&gt;ppTpl[i], pMsg,
					    &amp;actParam(iparams, pAction-&gt;iNumTpls, 0, i),
				            ttNow));
		}
	} else {
		for(i = 0 ; i &lt; pAction-&gt;iNumTpls ; ++i) {
			switch(pAction-&gt;peParamPassing[i]) {
			case ACT_STRING_PASSING:
				CHKiRet(tplToString(pAction-&gt;ppTpl[i], pMsg,
					   &amp;(pWrkrInfo-&gt;p.nontx.actParams[i]),
					   ttNow));
				break;
			/* note: ARRAY_PASSING mode has been removed in 8.26.0; if it
			 * is ever needed again, it can be found in 8.25.0.
			 * rgerhards 2017-03-06
			 */
			case ACT_MSG_PASSING:
				pWrkrInfo-&gt;p.nontx.actParams[i].param = (void*) pMsg;
				break;
			case ACT_JSON_PASSING:
				CHKiRet(tplToJSON(pAction-&gt;ppTpl[i], pMsg, &amp;json, ttNow));
				pWrkrInfo-&gt;p.nontx.actParams[i].param = (void*) json;
				break;
			default:dbgprintf(&quot;software bug/error: unknown &quot;
				&quot;pAction-&gt;peParamPassing[%d] %d in prepareDoActionParams\n&quot;,
					  i, (int) pAction-&gt;peParamPassing[i]);
				break;
			}
		}
	}

finalize_it:
	RETiRet;
}


void
releaseDoActionParams(action_t *__restrict__ const pAction, wti_t *__restrict__ const pWti, int action_destruct)
{
	int j;
	actWrkrInfo_t *__restrict__ pWrkrInfo;

	pWrkrInfo = &amp;(pWti-&gt;actWrkrInfo[pAction-&gt;iActionNbr]);
	for(j = 0 ; j &lt; pAction-&gt;iNumTpls ; ++j) {
		if (action_destruct) {
			if (ACT_STRING_PASSING == pAction-&gt;peParamPassing[j]) {
				free(pWrkrInfo-&gt;p.nontx.actParams[j].param);
				pWrkrInfo-&gt;p.nontx.actParams[j].param = NULL;
				pWrkrInfo-&gt;p.nontx.actParams[j].lenBuf = 0;
				pWrkrInfo-&gt;p.nontx.actParams[j].lenStr = 0;
			}
		} else {
			switch(pAction-&gt;peParamPassing[j]) {
			case ACT_ARRAY_PASSING:
				LogError(0, RS_RET_ERR, &quot;plugin error: no longer supported &quot;
					&quot;ARRAY_PASSING mode is used (see action.c)&quot;);
				return;
			case ACT_JSON_PASSING:
				json_object_put((struct json_object*)
								pWrkrInfo-&gt;p.nontx.actParams[j].param);
				pWrkrInfo-&gt;p.nontx.actParams[j].param = NULL;
				pWrkrInfo-&gt;p.nontx.actParams[j].lenBuf = 0;
				pWrkrInfo-&gt;p.nontx.actParams[j].lenStr = 0;
				break;
			case ACT_STRING_PASSING:
			case ACT_MSG_PASSING:
				/* no need to do anything with these */
				break;
			}
		}
	}

	return;
}


/* This is used in resume processing. We only finally know that a resume
 * worked when we have been able to actually process a messages. As such,
 * we need to do some cleanup and status tracking in that case.
 */
static void
actionSetActionWorked(action_t *__restrict__ const pThis, wti_t *__restrict__ const pWti)
{
	setActionResumeInRow(pWti, pThis, 0);
}

static rsRetVal
handleActionExecResult(action_t *__restrict__ const pThis,
	wti_t *__restrict__ const pWti,
	const rsRetVal ret)
{
	DEFiRet;
	switch(ret) {
		case RS_RET_OK:
			actionCommitted(pThis, pWti);
			actionSetActionWorked(pThis, pWti); /* we had a successful call! */
			break;
		case RS_RET_DEFER_COMMIT:
			actionSetActionWorked(pThis, pWti); /* we had a successful call! */
			/* we are done, action state remains the same */
			break;
		case RS_RET_PREVIOUS_COMMITTED:
			/* action state remains the same, but we had a commit. */
			pWti-&gt;actWrkrInfo[pThis-&gt;iActionNbr].bHadAutoCommit = 1;
			actionSetActionWorked(pThis, pWti); /* we had a successful call! */
			break;
		case RS_RET_DISABLE_ACTION:
			actionDisable(pThis);
			break;
		case RS_RET_SUSPENDED:
			actionRetry(pThis, pWti);
			break;
		default:/* error happened - if it hits us here, we assume the message cannot
			 * be processed but an retry makes no sense. Usually, this should be
			 * return code RS_RET_DATAFAIL. -- rgerhards, 2017-10-06
			 */
			LogError(0, ret, &quot;action '%s' (module '%s') &quot;
				&quot;message lost, could not be processed. Check for &quot;
				&quot;additional error messages before this one.&quot;,
				pThis-&gt;pszName, pThis-&gt;pMod-&gt;pszName);
			actionSetState(pThis, pWti, ACT_STATE_DATAFAIL);
			break;
	}
	iRet = getReturnCode(pThis, pWti);

	RETiRet;
}

/* call the DoAction output plugin entry point
 * rgerhards, 2008-01-28
 */
static rsRetVal
actionCallDoAction(action_t *__restrict__ const pThis,
	actWrkrIParams_t *__restrict__ const iparams,
	wti_t *__restrict__ const pWti)
{
	void *param[CONF_OMOD_NUMSTRINGS_MAXSIZE];
	int i;
	DEFiRet;

	DBGPRINTF(&quot;entering actionCalldoAction(), state: %s, actionNbr %d\n&quot;,
		  getActStateName(pThis, pWti), pThis-&gt;iActionNbr);

	pWti-&gt;actWrkrInfo[pThis-&gt;iActionNbr].bHadAutoCommit = 0;
	/* for this interface, we need to emulate the old style way
	 * of parameter passing.
	 */
	for(i = 0 ; i &lt; pThis-&gt;iNumTpls ; ++i) {
		param[i] = actParam(iparams, pThis-&gt;iNumTpls, 0, i).param;
	}

	iRet = pThis-&gt;pMod-&gt;mod.om.doAction(param,
				            pWti-&gt;actWrkrInfo[pThis-&gt;iActionNbr].actWrkrData);
	iRet = handleActionExecResult(pThis, pWti, iRet);
	RETiRet;
}


/* call the commitTransaction output plugin entry point */
static rsRetVal ATTR_NONNULL()
actionCallCommitTransaction(action_t * const pThis,
	wti_t *const pWti,
	actWrkrIParams_t *__restrict__ const iparams, const int nparams)
{
	DEFiRet;

	DBGPRINTF(&quot;entering actionCallCommitTransaction[%s], state: %s, nMsgs %u\n&quot;,
		  pThis-&gt;pszName, getActStateName(pThis, pWti), nparams);

	iRet = pThis-&gt;pMod-&gt;mod.om.commitTransaction(
		    pWti-&gt;actWrkrInfo[pThis-&gt;iActionNbr].actWrkrData,
		    iparams, nparams);
	DBGPRINTF(&quot;actionCallCommitTransaction[%s] state: %s &quot;
		&quot;mod commitTransaction returned %d\n&quot;,
		pThis-&gt;pszName, getActStateName(pThis, pWti), iRet);
	iRet = handleActionExecResult(pThis, pWti, iRet);
	RETiRet;
}


/* process a message
 * this readies the action and then calls doAction()
 * rgerhards, 2008-01-28
 */
static rsRetVal
actionProcessMessage(action_t * const pThis, void *actParams, wti_t * const pWti)
{
	DEFiRet;

	CHKiRet(actionPrepare(pThis, pWti));
	if(pThis-&gt;pMod-&gt;mod.om.SetShutdownImmdtPtr != NULL)
		pThis-&gt;pMod-&gt;mod.om.SetShutdownImmdtPtr(pThis-&gt;pModData, pWti-&gt;pbShutdownImmediate);
	if(getActionState(pWti, pThis) == ACT_STATE_ITX)
		CHKiRet(actionCallDoAction(pThis, actParams, pWti));

	iRet = getReturnCode(pThis, pWti);
finalize_it:
	RETiRet;
}


/* the following function uses the new-style transactional interface */
static rsRetVal
doTransaction(action_t *__restrict__ const pThis, wti_t *__restrict__ const pWti,
	actWrkrIParams_t *__restrict__ const iparams, const int nparams)
{
	actWrkrInfo_t *wrkrInfo;
	int i;
	DEFiRet;

	wrkrInfo = &amp;(pWti-&gt;actWrkrInfo[pThis-&gt;iActionNbr]);
	if(pThis-&gt;pMod-&gt;mod.om.commitTransaction != NULL) {
		DBGPRINTF(&quot;doTransaction: have commitTransaction IF, using that, pWrkrInfo %p\n&quot;, wrkrInfo);
		CHKiRet(actionCallCommitTransaction(pThis, pWti, iparams, nparams));
	} else { /* note: this branch is for compatibility with old TX modules */
		DBGPRINTF(&quot;doTransaction: action '%s', currIParam %d\n&quot;,
			   pThis-&gt;pszName, wrkrInfo-&gt;p.tx.currIParam);
		for(i = 0 ; i &lt; nparams ; ++i) {
			/* Note: we provide the message's base iparam - actionProcessMessage()
			 * uses this as *base* address.
			 */
			iRet = actionProcessMessage(pThis,
				&amp;actParam(iparams, pThis-&gt;iNumTpls, i, 0), pWti);
			DBGPRINTF(&quot;doTransaction: action %d, processing msg %d, result %d\n&quot;,
			   pThis-&gt;iActionNbr, i,iRet);
			if(iRet == RS_RET_SUSPENDED) {
				--i; /* we need to re-submit */
				/* note: we are suspended and need to retry. In order not to
				 * hammer the CPU, we now do a voluntarly wait of 1 second.
				 * The rest will be handled by the standard retry handler.
				 */
				srSleep(1, 0);
			} else if(iRet != RS_RET_DEFER_COMMIT &amp;&amp; iRet != RS_RET_PREVIOUS_COMMITTED &amp;&amp;
			   iRet != RS_RET_OK) {
				FINALIZE; /* let upper peer handle the error condition! */
			}
		}
	}
finalize_it:
	if(iRet == RS_RET_DEFER_COMMIT || iRet == RS_RET_PREVIOUS_COMMITTED)
		iRet = RS_RET_OK; /* this is expected for transactional action! */
	RETiRet;
}


/* Commit try committing (do not handle retry processing and such) */
static rsRetVal ATTR_NONNULL()
actionTryCommit(action_t *__restrict__ const pThis, wti_t *__restrict__ const pWti,
	actWrkrIParams_t *__restrict__ const iparams, const int nparams)
{
	DEFiRet;

	DBGPRINTF(&quot;actionTryCommit[%s] enter\n&quot;, pThis-&gt;pszName);
	CHKiRet(actionPrepare(pThis, pWti));

	CHKiRet(doTransaction(pThis, pWti, iparams, nparams));

	if(getActionState(pWti, pThis) == ACT_STATE_ITX) {
		iRet = pThis-&gt;pMod-&gt;mod.om.endTransaction(pWti-&gt;actWrkrInfo[pThis-&gt;iActionNbr].actWrkrData);
		switch(iRet) {
			case RS_RET_OK:
				actionCommitted(pThis, pWti);
				break;
			case RS_RET_SUSPENDED:
				actionRetry(pThis, pWti);
				break;
			case RS_RET_DISABLE_ACTION:
				actionDisable(pThis);
				break;
			case RS_RET_DEFER_COMMIT:
				DBGPRINTF(&quot;output plugin error: endTransaction() returns RS_RET_DEFER_COMMIT &quot;
					  &quot;- ignored\n&quot;);
				actionCommitted(pThis, pWti);
				break;
			case RS_RET_PREVIOUS_COMMITTED:
				DBGPRINTF(&quot;output plugin error: endTransaction() returns RS_RET_PREVIOUS_COMMITTED &quot;
					  &quot;- ignored\n&quot;);
				actionCommitted(pThis, pWti);
				break;
			default:/* permanent failure of this message - no sense in retrying. This is
				 * not yet handled (but easy TODO)
				 */
				DBGPRINTF(&quot;action[%s]: actionTryCommit receveived iRet %d\n&quot;,
					pThis-&gt;pszName, iRet);
				FINALIZE;
		}
	}
	iRet = getReturnCode(pThis, pWti);

finalize_it:
	RETiRet;
}

/* If a transcation failed, we write the error file (if configured).
 */
static void ATTR_NONNULL()
actionWriteErrorFile(action_t *__restrict__ const pThis, const rsRetVal ret,
	actWrkrIParams_t *__restrict__ const iparams, const int nparams)
{
	fjson_object *etry=NULL;
	int bNeedUnlock = 0;

	STATSCOUNTER_INC(pThis-&gt;ctrFail, pThis-&gt;mutCtrFail);

	if(pThis-&gt;pszErrFile == NULL) {
		DBGPRINTF(&quot;action %s: commit failed, no error file set, silently &quot;
			&quot;discarding %d messages\n&quot;, pThis-&gt;pszName, nparams);
		goto done;
	}

	DBGPRINTF(&quot;action %d commit failed, writing %u messages (%d tpls) to error file\n&quot;,
		pThis-&gt;iActionNbr, nparams, pThis-&gt;iNumTpls);

	pthread_mutex_lock(&amp;pThis-&gt;mutErrFile);
	bNeedUnlock = 1;

	if(pThis-&gt;fdErrFile == -1) {
		pThis-&gt;fdErrFile = open(pThis-&gt;pszErrFile,
					O_WRONLY|O_CREAT|O_APPEND|O_LARGEFILE|O_CLOEXEC,
					S_IRUSR|S_IWUSR|S_IRGRP|S_IWGRP);
		if(pThis-&gt;fdErrFile == -1) {
			LogError(errno, RS_RET_ERR, &quot;action %s: error opening error file %s&quot;,
				pThis-&gt;pszName, pThis-&gt;pszErrFile);
			goto done;
		}
		if (pThis-&gt;maxErrFileSize &gt; 0) {
			struct stat statbuf;
			if (fstat(pThis-&gt;fdErrFile, &amp;statbuf) == -1) {
				LogError(errno, RS_RET_ERR, &quot;failed to fstat %s&quot;, pThis-&gt;pszErrFile);
				goto done;
			}
			pThis-&gt;currentErrFileSize = statbuf.st_size;
		}
	}

	for(int i = 0 ; i &lt; nparams ; ++i) {
		if((etry = fjson_object_new_object()) == NULL)
			goto done;
		fjson_object_object_add(etry, &quot;action&quot;, fjson_object_new_string((char*)pThis-&gt;pszName));
		fjson_object_object_add(etry, &quot;status&quot;, fjson_object_new_int(ret));
		for(int j = 0 ; j &lt; pThis-&gt;iNumTpls ; ++j) {
			char tplname[20];
			snprintf(tplname, sizeof(tplname), &quot;template%d&quot;, j);
			tplname[sizeof(tplname)-1] = '\0';
			fjson_object_object_add(etry, tplname,
				fjson_object_new_string((char*)actParam(iparams, 1, i, j).param));
		}

		char *const rendered = strdup((char*)fjson_object_to_json_string(etry));
		if(rendered == NULL)
			goto done;

		size_t toWrite = strlen(rendered) + 1;
		// Check if need to truncate the amount of bytes to write
		if (pThis-&gt;maxErrFileSize &gt; 0) {
			if (pThis-&gt;currentErrFileSize + toWrite &gt; pThis-&gt;maxErrFileSize) {
				// Truncate to the pending available
				toWrite = pThis-&gt;maxErrFileSize - pThis-&gt;currentErrFileSize;
			}
			pThis-&gt;currentErrFileSize += toWrite;
		}
		if(toWrite &gt; 0) {
			/* note: we use the '\0' inside the string to store a LF - we do not
			 * otherwise need it and it safes us a copy/realloc.
			 */
			rendered[toWrite-1] = '\n'; /* NO LONGER A STRING! */
			const ssize_t wrRet = write(pThis-&gt;fdErrFile, rendered, toWrite);
			if(wrRet != (ssize_t) toWrite) {
				LogError(errno, RS_RET_IO_ERROR,
					&quot;action %s: error writing errorFile %s, write returned %lld&quot;,
					pThis-&gt;pszName, pThis-&gt;pszErrFile, (long long) wrRet);
			}
		}
		free(rendered);

		fjson_object_put(etry);
		etry = NULL;
	}
done:
	if(bNeedUnlock) {
		pthread_mutex_unlock(&amp;pThis-&gt;mutErrFile);
	}
	fjson_object_put(etry);
	return;
}


static rsRetVal
actionTryRemoveHardErrorsFromBatch(action_t *__restrict__ const pThis, wti_t *__restrict__ const pWti,
	actWrkrIParams_t *const new_iparams, unsigned *new_nMsgs)
{
	actWrkrInfo_t *const wrkrInfo = &amp;(pWti-&gt;actWrkrInfo[pThis-&gt;iActionNbr]);
	const unsigned nMsgs = wrkrInfo-&gt;p.tx.currIParam;
	actWrkrIParams_t oneParamSet[CONF_OMOD_NUMSTRINGS_MAXSIZE];
	rsRetVal ret;
	DEFiRet;

	*new_nMsgs = 0;
	for(unsigned i = 0 ; i &lt; nMsgs ; ++i) {
		setActionResumeInRow(pWti, pThis, 0); // make sure we do not trigger OK-as-SUSPEND handling
		memcpy(&amp;oneParamSet, &amp;actParam(wrkrInfo-&gt;p.tx.iparams, pThis-&gt;iNumTpls, i, 0),
			sizeof(actWrkrIParams_t) * pThis-&gt;iNumTpls);
		ret = actionTryCommit(pThis, pWti, oneParamSet, 1);
		if(ret == RS_RET_SUSPENDED) {
			memcpy(new_iparams + (*new_nMsgs * pThis-&gt;iNumTpls), &amp;oneParamSet,
				sizeof(actWrkrIParams_t) * pThis-&gt;iNumTpls);
			++(*new_nMsgs);
		} else if(ret != RS_RET_OK) {
			actionWriteErrorFile(pThis, ret, oneParamSet, 1);
		}
	}
	RETiRet;
}

/* Note: we currently need to return an iRet, as this is used in
 * direct mode. TODO: However, it may be worth further investigating this,
 * as it looks like there is no ultimate consumer of this code.
 * rgerhards, 2013-11-06
 */
static rsRetVal ATTR_NONNULL()
actionCommit(action_t *__restrict__ const pThis, wti_t *__restrict__ const pWti)
{
	actWrkrInfo_t *const wrkrInfo = &amp;(pWti-&gt;actWrkrInfo[pThis-&gt;iActionNbr]);
	/* Variables that permit us to override the batch of messages */
	unsigned nMsgs = 0;
	actWrkrIParams_t *iparams = NULL;
	int needfree_iparams = 0; // work-around for clang static analyzer false positive
	DEFiRet;

	DBGPRINTF(&quot;actionCommit[%s]: enter, %d msgs\n&quot;, pThis-&gt;pszName, wrkrInfo-&gt;p.tx.currIParam);
	if(!pThis-&gt;isTransactional || pWti-&gt;actWrkrInfo[pThis-&gt;iActionNbr].p.tx.currIParam == 0) {
		FINALIZE;
	} else if(getActionState(pWti, pThis) == ACT_STATE_SUSP) {
		/* if we are suspended, we already tried everything to recover the
		 * action - and failed. So all we can do here is write the error file.
		 */
		actionWriteErrorFile(pThis, iRet, wrkrInfo-&gt;p.tx.iparams, wrkrInfo-&gt;p.tx.currIParam);
		FINALIZE;
	}
	DBGPRINTF(&quot;actionCommit[%s]: processing...\n&quot;, pThis-&gt;pszName);

	/* we now do one try at commiting the whole batch. Usually, this will
	 * succeed. If so, we are happy and done. If not, we dig into the details
	 * of finding out if we have a non-temporary error and try to handle this
	 * as well as retry processing. Due to this logic we do a bit more retries
	 * than configured (if temporary failure), but this unavoidable and should
	 * do no real harm. - rgerhards, 2017-10-06
	 */
	iRet = actionTryCommit(pThis, pWti, wrkrInfo-&gt;p.tx.iparams, wrkrInfo-&gt;p.tx.currIParam);
DBGPRINTF(&quot;actionCommit[%s]: return actionTryCommit %d\n&quot;, pThis-&gt;pszName, iRet);
	if(iRet == RS_RET_OK) {
		FINALIZE;
	}

	/* check if this was a single-message batch. If it had a datafail error, we
	 * are done. If it is a multi-message batch, we need to sort out the individual
	 * message states.
	 */
	if(wrkrInfo-&gt;p.tx.currIParam == 1) {
		needfree_iparams = 0;
		iparams = wrkrInfo-&gt;p.tx.iparams;
		nMsgs = wrkrInfo-&gt;p.tx.currIParam;
		if(iRet == RS_RET_DATAFAIL) {
			FINALIZE;
		}
	} else {
		DBGPRINTF(&quot;actionCommit[%s]: somewhat unhappy, full batch of %d msgs returned &quot;
			&quot;status %d. Trying messages as individual actions.\n&quot;,
			pThis-&gt;pszName, wrkrInfo-&gt;p.tx.currIParam, iRet);
		CHKmalloc(iparams = malloc(sizeof(actWrkrIParams_t) * pThis-&gt;iNumTpls
			* wrkrInfo-&gt;p.tx.currIParam));
		needfree_iparams = 1;
		actionTryRemoveHardErrorsFromBatch(pThis, pWti, iparams, &amp;nMsgs);
	}

	if(nMsgs == 0) {
		ABORT_FINALIZE(RS_RET_OK); // here, we consider everyting OK
	}

	/* We still have some messages with suspend error. So now let's do our
	 * &quot;regular&quot; retry and suspend processing.
	 */
	DBGPRINTF(&quot;actionCommit[%s]: unhappy, we still have %d uncommitted messages.\n&quot;,
		pThis-&gt;pszName, nMsgs);
	int bDone = 0;
	do {
		iRet = actionTryCommit(pThis, pWti, iparams, nMsgs);
		DBGPRINTF(&quot;actionCommit[%s]: in retry loop, iRet %d\n&quot;,
			pThis-&gt;pszName, iRet);
		if(iRet == RS_RET_FORCE_TERM) {
			ABORT_FINALIZE(RS_RET_FORCE_TERM);
		} else if(iRet == RS_RET_SUSPENDED) {
			iRet = actionDoRetry(pThis, pWti);
			DBGPRINTF(&quot;actionCommit[%s]: actionDoRetry returned %d\n&quot;,
				pThis-&gt;pszName, iRet);
			if(iRet == RS_RET_FORCE_TERM) {
				ABORT_FINALIZE(RS_RET_FORCE_TERM);
			} else if(iRet != RS_RET_OK) {
				actionWriteErrorFile(pThis, iRet, iparams, nMsgs);
				bDone = 1;
			}
			continue;
		} else if(iRet == RS_RET_OK ||
		          iRet == RS_RET_SUSPENDED ||
			  iRet == RS_RET_ACTION_FAILED) {
			bDone = 1;
		}
		if(getActionState(pWti, pThis) == ACT_STATE_RDY  ||
		   getActionState(pWti, pThis) == ACT_STATE_SUSP) {
			bDone = 1;
		}
	} while(!bDone);
finalize_it:
	DBGPRINTF(&quot;actionCommit[%s]: done, iRet %d\n&quot;, pThis-&gt;pszName, iRet);
	if(needfree_iparams) {
		free(iparams);
	}
	wrkrInfo-&gt;p.tx.currIParam = 0; /* reset to beginning */
	RETiRet;
}

/* Commit all active transactions in *DIRECT mode* */
void ATTR_NONNULL()
actionCommitAllDirect(wti_t *__restrict__ const pWti)
{
	int i;
	action_t *pAction;

	for(i = 0 ; i &lt; runConf-&gt;actions.iActionNbr ; ++i) {
		pAction = pWti-&gt;actWrkrInfo[i].pAction;
		if(pAction == NULL)
			continue;
		DBGPRINTF(&quot;actionCommitAllDirect: action %d, state %u, nbr to commit %d &quot;
			  &quot;isTransactional %d\n&quot;,
			  i, getActionStateByNbr(pWti, i), pWti-&gt;actWrkrInfo-&gt;p.tx.currIParam,
			  pAction-&gt;isTransactional);
		if(pAction-&gt;pQueue-&gt;qType == QUEUETYPE_DIRECT)
			actionCommit(pAction, pWti);
	}
}

/* process a single message. This is both called if we run from the
 * consumer side of an action queue as well as directly from the main
 * queue thread if the action queue is set to &quot;direct&quot;.
 */
static rsRetVal
processMsgMain(action_t *__restrict__ const pAction,
	wti_t *__restrict__ const pWti,
	smsg_t *__restrict__ const pMsg,
	struct syslogTime *ttNow)
{
	DEFiRet;

	CHKiRet(prepareDoActionParams(pAction, pWti, pMsg, ttNow));

	if(pAction-&gt;isTransactional) {
		pWti-&gt;actWrkrInfo[pAction-&gt;iActionNbr].pAction = pAction;
		DBGPRINTF(&quot;action '%s': is transactional - executing in commit phase\n&quot;, pAction-&gt;pszName);
		actionPrepare(pAction, pWti);
		iRet = getReturnCode(pAction, pWti);
		FINALIZE;
	}

	iRet = actionProcessMessage(pAction,
				    pWti-&gt;actWrkrInfo[pAction-&gt;iActionNbr].p.nontx.actParams,
				    pWti);
	if(pAction-&gt;bNeedReleaseBatch)
		releaseDoActionParams(pAction, pWti, 0);
finalize_it:
	if(iRet == RS_RET_OK) {
		if(pWti-&gt;execState.bDoAutoCommit)
			iRet = actionCommit(pAction, pWti);
	}
	RETiRet;
}

/* This entry point is called by the ACTION queue (not main queue!)
 */
static rsRetVal ATTR_NONNULL()
processBatchMain(void *__restrict__ const pVoid,
	batch_t *__restrict__ const pBatch,
	wti_t *__restrict__ const pWti)
{
	action_t *__restrict__ const pAction = (action_t*__restrict__ const) pVoid;
	int i;
	struct syslogTime ttNow;
	DEFiRet;

	wtiResetExecState(pWti, pBatch);
	/* indicate we have not yet read the date */
	ttNow.year = 0;

	for(i = 0 ; i &lt; batchNumMsgs(pBatch) &amp;&amp; !*pWti-&gt;pbShutdownImmediate ; ++i) {
		if(batchIsValidElem(pBatch, i)) {
			/* we do not check error state below, because aborting would be
			 * more harmful than continuing.
			 */
			rsRetVal localRet = processMsgMain(pAction, pWti, pBatch-&gt;pElem[i].pMsg, &amp;ttNow);
			DBGPRINTF(&quot;processBatchMain: i %d, processMsgMain iRet %d\n&quot;, i, localRet);
			if(   localRet == RS_RET_OK
			   || localRet == RS_RET_DEFER_COMMIT
			   || localRet == RS_RET_ACTION_FAILED
			   || localRet == RS_RET_PREVIOUS_COMMITTED ) {
				batchSetElemState(pBatch, i, BATCH_STATE_COMM);
				DBGPRINTF(&quot;processBatchMain: i %d, COMM state set\n&quot;, i);
			}
		}
	}

	iRet = actionCommit(pAction, pWti);
	RETiRet;
}


/* remove an action worker instance from our table of
 * workers. To be called from worker handler (wti).
 */
void
actionRemoveWorker(action_t *const __restrict__ pAction,
	void *const __restrict__ actWrkrData)
{
	pthread_mutex_lock(&amp;pAction-&gt;mutWrkrDataTable);
	pAction-&gt;nWrkr--;
	for(int w = 0 ; w &lt; pAction-&gt;wrkrDataTableSize ; ++w) {
		if(pAction-&gt;wrkrDataTable[w] == actWrkrData) {
			pAction-&gt;wrkrDataTable[w] = NULL;
			break; /* done */
		}
	}
	pthread_mutex_unlock(&amp;pAction-&gt;mutWrkrDataTable);
}


/* call the HUP handler for a given action, if such a handler is defined.
 * Note that the action must be able to service HUP requests concurrently
 * to any current doAction() processing.
 */
rsRetVal
actionCallHUPHdlr(action_t * const pAction)
{
	DEFiRet;

	assert(pAction != NULL);
	DBGPRINTF(&quot;Action %p checks HUP hdlr, act level: %p, wrkr level %p\n&quot;,
		pAction, pAction-&gt;pMod-&gt;doHUP, pAction-&gt;pMod-&gt;doHUPWrkr);

	if(pAction-&gt;pMod-&gt;doHUP != NULL) {
		CHKiRet(pAction-&gt;pMod-&gt;doHUP(pAction-&gt;pModData));
	}

	if(pAction-&gt;pMod-&gt;doHUPWrkr != NULL) {
		pthread_mutex_lock(&amp;pAction-&gt;mutWrkrDataTable);
		for(int i = 0 ; i &lt; pAction-&gt;wrkrDataTableSize ; ++i) {
			dbgprintf(&quot;HUP: table entry %d: %p %s\n&quot;, i,
				pAction-&gt;wrkrDataTable[i],
				pAction-&gt;wrkrDataTable[i] == NULL ? &quot;[unused]&quot; : &quot;&quot;);
			if(pAction-&gt;wrkrDataTable[i] != NULL) {
				const rsRetVal localRet
					= pAction-&gt;pMod-&gt;doHUPWrkr(pAction-&gt;wrkrDataTable[i]);
				if(localRet != RS_RET_OK) {
					DBGPRINTF(&quot;HUP handler returned error state %d - &quot;
						  &quot;ignored\n&quot;, localRet);
				}
			}
		}
		pthread_mutex_unlock(&amp;pAction-&gt;mutWrkrDataTable);
	}

finalize_it:
	RETiRet;
}


/* set the action message queue mode
 * TODO: probably move this into queue object, merge with MainMsgQueue!
 * rgerhards, 2008-01-28
 */
static rsRetVal setActionQueType(void __attribute__((unused)) *pVal, uchar *pszType)
<A NAME="1"></A>{
	DEFiRet;

<FONT color="#f63526"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match2224-0.html#1',2,'match2224-top.html#1',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>	if (!strcasecmp((char *) pszType, &quot;fixedarray&quot;)) {
		cs.ActionQueType = QUEUETYPE_FIXED_ARRAY;
		DBGPRINTF(&quot;action queue type set to FIXED_ARRAY\n&quot;);
	} else if (!strcasecmp((char *) pszType, &quot;linkedlist&quot;)) {
		cs.ActionQueType = QUEUETYPE_LINKEDLIST;
		DBGPRINTF(&quot;action queue type set to LINKEDLIST\n&quot;);
	} else if (!strcasecmp((char *) pszType, &quot;disk&quot;)) {
		cs.ActionQueType = QUEUETYPE_DISK;
		DBGPRINTF(&quot;action queue type set to DISK\n&quot;);
	} else if (!strcasecmp((char *) pszType, &quot;direct&quot;)) {
		cs.ActionQueType = QUEUETYPE_DIRECT;
		DBGPRINTF(&quot;action queue type set to DIRECT (no queueing at all)\n&quot;);
	} else {</B></FONT>
		LogError(0, RS_RET_INVALID_PARAMS, &quot;unknown actionqueue parameter: %s&quot;, (char *) pszType);
		iRet = RS_RET_INVALID_PARAMS;
	}
	free(pszType); /* no longer needed */

	RETiRet;
}


/* This submits the message to the action queue in case we do NOT need to handle repeat
 * message processing. That case permits us to gain lots of freedom during processing
 * and thus speed. This is also utilized to submit messages in more complex cases once
 * the complex logic has been applied ;)
 * rgerhards, 2010-06-08
 */
static rsRetVal ATTR_NONNULL()
doSubmitToActionQ(action_t * const pAction, wti_t * const pWti, smsg_t *pMsg)
{
	struct syslogTime ttNow; // TODO: think if we can buffer this in pWti
	DEFiRet;

	DBGPRINTF(&quot;action '%s': called, logging to %s (susp %d/%d, direct q %d)\n&quot;,
		pAction-&gt;pszName, module.GetStateName(pAction-&gt;pMod),
		pAction-&gt;bExecWhenPrevSusp, pWti-&gt;execState.bPrevWasSuspended,
		pAction-&gt;pQueue-&gt;qType == QUEUETYPE_DIRECT);

	if(   pAction-&gt;bExecWhenPrevSusp
	   &amp;&amp; !pWti-&gt;execState.bPrevWasSuspended) {
		DBGPRINTF(&quot;action '%s': NOT executing, as previous action was &quot;
			  &quot;not suspended\n&quot;, pAction-&gt;pszName);
		FINALIZE;
	}

	STATSCOUNTER_INC(pAction-&gt;ctrProcessed, pAction-&gt;mutCtrProcessed);
	if(pAction-&gt;pQueue-&gt;qType == QUEUETYPE_DIRECT) {
		ttNow.year = 0;
		iRet = processMsgMain(pAction, pWti, pMsg, &amp;ttNow);
	} else {/* in this case, we do single submits to the queue.
		 * TODO: optimize this, we may do at least a multi-submit!
		 */
		iRet = qqueueEnqMsg(pAction-&gt;pQueue, eFLOWCTL_NO_DELAY,
			pAction-&gt;bCopyMsg ? MsgDup(pMsg) : MsgAddRef(pMsg));
	}
	pWti-&gt;execState.bPrevWasSuspended =
		(iRet == RS_RET_SUSPENDED || iRet == RS_RET_ACTION_FAILED);

	if (iRet == RS_RET_ACTION_FAILED)	/* Increment failed counter */
		STATSCOUNTER_INC(pAction-&gt;ctrFail, pAction-&gt;mutCtrFail);

	DBGPRINTF(&quot;action '%s': set suspended state to %d\n&quot;,
		pAction-&gt;pszName, pWti-&gt;execState.bPrevWasSuspended);

finalize_it:
	RETiRet;
}


/* This function builds up a batch of messages to be (later)
 * submitted to the action queue.
 * Important: this function MUST not be called with messages that are to
 * be discarded due to their &quot;prevWasSuspended&quot; state. It will not check for
 * this and submit all messages to the queue for execution. So these must
 * be filtered out before calling us (what is done currently!).
 */
rsRetVal
actionWriteToAction(action_t * const pAction, smsg_t *pMsg, wti_t * const pWti)
{
	DEFiRet;

	/* first, we check if the action should actually be called. The action-specific
	 * $ActionExecOnlyEveryNthTime permits us to execute an action only every Nth
	 * time. So we need to check if we need to drop the (otherwise perfectly executable)
	 * action for this reason. Note that in case we need to drop it, we return RS_RET_OK
	 * as the action was properly &quot;passed to execution&quot; from the upper layer's point
	 * of view. -- rgerhards, 2008-08-07.
	 */
	if(pAction-&gt;iExecEveryNthOccur &gt; 1) {
		/* we need to care about multiple occurrences */
		if(   pAction-&gt;iExecEveryNthOccurTO &gt; 0
		   &amp;&amp; (getActNow(pAction) - pAction-&gt;tLastOccur) &gt; pAction-&gt;iExecEveryNthOccurTO) {
		  	DBGPRINTF(&quot;n-th occurrence handling timed out (%d sec), restarting from 0\n&quot;,
				  (int) (getActNow(pAction) - pAction-&gt;tLastOccur));
			pAction-&gt;iNbrNoExec = 0;
			pAction-&gt;tLastOccur = getActNow(pAction);
		   }
		if(pAction-&gt;iNbrNoExec &lt; pAction-&gt;iExecEveryNthOccur - 1) {
			++pAction-&gt;iNbrNoExec;
			DBGPRINTF(&quot;action %p passed %d times to execution - less than configured - discarding\n&quot;,
			  pAction, pAction-&gt;iNbrNoExec);
			FINALIZE;
		} else {
			pAction-&gt;iNbrNoExec = 0; /* we execute the action now, so the number of no execs is down to */
		}
	}

	DBGPRINTF(&quot;Called action(complex case), logging to %s\n&quot;, module.GetStateName(pAction-&gt;pMod));

	/* now check if we need to drop the message because otherwise the action would be too
	 * frequently called. -- rgerhards, 2008-04-08
	 * Note that the check for &quot;pAction-&gt;iSecsExecOnceInterval &gt; 0&quot; is not necessary from
	 * a purely logical point of view. However, if safes us to check the system time in
	 * (those common) cases where ExecOnceInterval is not used. -- rgerhards, 2008-09-16
	 */
	if(pAction-&gt;iSecsExecOnceInterval &gt; 0 &amp;&amp;
	   pAction-&gt;iSecsExecOnceInterval + pAction-&gt;tLastExec &gt; getActNow(pAction)) {
		/* in this case we need to discard the message - its not yet time to exec the action */
		DBGPRINTF(&quot;action not yet ready again to be executed, onceInterval %d, tCurr %d, tNext %d\n&quot;,
			  (int) pAction-&gt;iSecsExecOnceInterval, (int) getActNow(pAction),
			  (int) (pAction-&gt;iSecsExecOnceInterval + pAction-&gt;tLastExec));
		FINALIZE;
	}

	/* we use reception time, not dequeue time - this is considered more appropriate and also faster ;)
	 * rgerhards, 2008-09-17 */
	pAction-&gt;tLastExec = getActNow(pAction); /* re-init time flags */
	pAction-&gt;f_time = pMsg-&gt;ttGenTime;

	/* When we reach this point, we have a valid, non-disabled action.
	 * So let's enqueue our message for execution. -- rgerhards, 2007-07-24
	 */
	iRet = doSubmitToActionQ(pAction, pWti, pMsg);

finalize_it:
	RETiRet;
}


/* Call configured action, most complex case with all features supported (and thus slow).
 * rgerhards, 2010-06-08
 */

PRAGMA_DIAGNOSTIC_PUSH;
PRAGMA_IGNORE_Wempty_body;
static rsRetVal
doSubmitToActionQComplex(action_t * const pAction, wti_t * const pWti, smsg_t *pMsg)
{
	DEFiRet;

	d_pthread_mutex_lock(&amp;pAction-&gt;mutAction);
	pthread_cleanup_push(mutexCancelCleanup, &amp;pAction-&gt;mutAction);
	DBGPRINTF(&quot;Called action %p (complex case), logging to %s\n&quot;,
		  pAction, module.GetStateName(pAction-&gt;pMod));

	pAction-&gt;tActNow = -1; /* we do not yet know our current time (clear prev. value) */
	// TODO: can we optimize the &quot;now&quot; handling again (was batch, I guess...)?

	/* don't output marks to recently written outputs */
	if(pAction-&gt;bWriteAllMarkMsgs == 0
	   &amp;&amp; (pMsg-&gt;msgFlags &amp; MARK) &amp;&amp; (getActNow(pAction) - pAction-&gt;f_time) &lt; MarkInterval / 2) {
		ABORT_FINALIZE(RS_RET_OK);
	}

	/* call the output driver */
	iRet = actionWriteToAction(pAction, pMsg, pWti);

finalize_it:
	d_pthread_mutex_unlock(&amp;pAction-&gt;mutAction);
	pthread_cleanup_pop(0); /* remove mutex cleanup handler */

	RETiRet;
}
PRAGMA_DIAGNOSTIC_POP


/* helper to activateActions, it activates a specific action.
 */
DEFFUNC_llExecFunc(doActivateActions)
{
	rsRetVal localRet;
	action_t * const pThis = (action_t*) pData;
	localRet = qqueueStart(runConf, pThis-&gt;pQueue);
	if(localRet != RS_RET_OK) {
		LogError(0, localRet, &quot;error starting up action queue&quot;);
		if(localRet == RS_RET_FILE_PREFIX_MISSING) {
			LogError(0, localRet, &quot;file prefix (work directory?) &quot;
					&quot;is missing&quot;);
		}
		actionDisable(pThis);
	}
	DBGPRINTF(&quot;Action %s[%p]: queue %p started\n&quot;, modGetName(pThis-&gt;pMod),
		  pThis, pThis-&gt;pQueue);
	return RS_RET_OK; /* we ignore errors, we can not do anything either way */
}


/* This function &quot;activates&quot; the action after privileges have been dropped. Currently,
 * this means that the queues are started.
 * rgerhards, 2011-05-02
 */
rsRetVal
activateActions(void)
{
	DEFiRet;
	iRet = ruleset.IterateAllActions(runConf, doActivateActions, NULL);
	RETiRet;
}



/* This submits the message to the action queue in case where we need to handle
 * bWriteAllMarkMessage == RSFALSE only. Note that we use a non-blocking CAS loop
 * for the synchronization. Here, we just modify the filter condition to be false when
 * a mark message must not be written. However, in this case we must save the previous
 * filter as we may need it in the next action (potential future optimization: check if this is
 * the last action TODO).
 * rgerhards, 2010-06-08
 */
static rsRetVal
doSubmitToActionQNotAllMark(action_t * const pAction, wti_t * const pWti, smsg_t * const pMsg)
{
	int doProcess = 1;
	time_t lastAct;
	DEFiRet;

	/* TODO: think about the whole logic. If messages come in out of order, things
	 * tend to become a bit unreliable. On the other hand, this only happens if we have
	 * very high traffic, in which this use case here is not really affected (as the
	 * MarkInterval is pretty corase).
	 */
	/* CAS loop, we write back a bit early, but that's OK... */
	/* we use reception time, not dequeue time - this is considered more appropriate and
	 * also faster ;) -- rgerhards, 2008-09-17 */
	do {
		lastAct = pAction-&gt;f_time;
		if(pMsg-&gt;msgFlags &amp; MARK) {
			if((pMsg-&gt;ttGenTime - lastAct) &lt; MarkInterval / 2) {
				doProcess = 0;
				DBGPRINTF(&quot;action was recently called, ignoring mark message\n&quot;);
				break; /* do not update timestamp for non-written mark messages */
			}
		}
	} while(ATOMIC_CAS_time_t(&amp;pAction-&gt;f_time, lastAct,
		pMsg-&gt;ttGenTime, &amp;pAction-&gt;mutCAS) == 0);

	if(doProcess) {
		DBGPRINTF(&quot;Called action(NotAllMark), processing via '%s'\n&quot;,
			  module.GetStateName(pAction-&gt;pMod));
		iRet = doSubmitToActionQ(pAction, pWti, pMsg);
	}

	RETiRet;
}


/* apply all params from param block to action. This supports the v6 config system.
 * Defaults must have been set appropriately during action construct!
 * rgerhards, 2011-08-01
 */
static rsRetVal
actionApplyCnfParam(action_t * const pAction, struct cnfparamvals * const pvals)
{
	int i;

	for(i = 0 ; i &lt; pblk.nParams ; ++i) {
		if(!pvals[i].bUsed)
			continue;
		if(!strcmp(pblk.descr[i].name, &quot;name&quot;)) {
			pAction-&gt;pszName = (uchar*) es_str2cstr(pvals[i].val.d.estr, NULL);
		} else if(!strcmp(pblk.descr[i].name, &quot;type&quot;)) {
			continue; /* this is handled seperately during module select! */
		} else if(!strcmp(pblk.descr[i].name, &quot;action.errorfile&quot;)) {
			pAction-&gt;pszErrFile = es_str2cstr(pvals[i].val.d.estr, NULL);
		} else if(!strcmp(pblk.descr[i].name, &quot;action.errorfile.maxsize&quot;)) {
			pAction-&gt;maxErrFileSize = pvals[i].val.d.n;
		} else if(!strcmp(pblk.descr[i].name, &quot;action.externalstate.file&quot;)) {
			pAction-&gt;pszExternalStateFile = es_str2cstr(pvals[i].val.d.estr, NULL);
		} else if(!strcmp(pblk.descr[i].name, &quot;action.writeallmarkmessages&quot;)) {
			pAction-&gt;bWriteAllMarkMsgs = pvals[i].val.d.n;
		} else if(!strcmp(pblk.descr[i].name, &quot;action.execonlyeverynthtime&quot;)) {
			pAction-&gt;iExecEveryNthOccur = pvals[i].val.d.n;
		} else if(!strcmp(pblk.descr[i].name, &quot;action.execonlyeverynthtimetimeout&quot;)) {
			pAction-&gt;iExecEveryNthOccurTO = pvals[i].val.d.n;
		} else if(!strcmp(pblk.descr[i].name, &quot;action.execonlyonceeveryinterval&quot;)) {
			pAction-&gt;iSecsExecOnceInterval = pvals[i].val.d.n;
		} else if(!strcmp(pblk.descr[i].name, &quot;action.execonlywhenpreviousissuspended&quot;)) {
			pAction-&gt;bExecWhenPrevSusp = pvals[i].val.d.n;
		} else if(!strcmp(pblk.descr[i].name, &quot;action.repeatedmsgcontainsoriginalmsg&quot;)) {
			pAction-&gt;bRepMsgHasMsg = pvals[i].val.d.n;
		} else if(!strcmp(pblk.descr[i].name, &quot;action.resumeretrycount&quot;)) {
			pAction-&gt;iResumeRetryCount = pvals[i].val.d.n;
		} else if(!strcmp(pblk.descr[i].name, &quot;action.reportsuspension&quot;)) {
			pAction-&gt;bReportSuspension = (int) pvals[i].val.d.n;
		} else if(!strcmp(pblk.descr[i].name, &quot;action.reportsuspensioncontinuation&quot;)) {
			pAction-&gt;bReportSuspensionCont = (int) pvals[i].val.d.n;
		} else if(!strcmp(pblk.descr[i].name, &quot;action.copymsg&quot;)) {
			pAction-&gt;bCopyMsg = (int) pvals[i].val.d.n;
		} else if(!strcmp(pblk.descr[i].name, &quot;action.resumeinterval&quot;)) {
			pAction-&gt;iResumeInterval = pvals[i].val.d.n;
		} else if(!strcmp(pblk.descr[i].name, &quot;action.resumeintervalMax&quot;)) {
			pAction-&gt;iResumeIntervalMax = pvals[i].val.d.n;
		} else {
			dbgprintf(&quot;action: program error, non-handled &quot;
			  &quot;param '%s'\n&quot;, pblk.descr[i].name);
		}
	}
	return RS_RET_OK;
}


/* add an Action to the current selector
 * The pOMSR is freed, as it is not needed after this function.
 * Note: this function pulls global data that specifies action config state.
 * rgerhards, 2007-07-27
 */
rsRetVal
addAction(action_t **ppAction, modInfo_t *pMod, void *pModData,
	  omodStringRequest_t *pOMSR, struct cnfparamvals *actParams,
	  struct nvlst * const lst)
{
	DEFiRet;
	int i;
	int iTplOpts;
	uchar *pTplName;
	action_t *pAction;
	char errMsg[512];

	assert(ppAction != NULL);
	assert(pMod != NULL);
	assert(pOMSR != NULL);
	DBGPRINTF(&quot;Module %s processes this action.\n&quot;, module.GetName(pMod));

	CHKiRet(actionConstruct(&amp;pAction)); /* create action object first */
	pAction-&gt;pMod = pMod;
	pAction-&gt;pModData = pModData;
	if(actParams == NULL) { /* use legacy systemn */
		pAction-&gt;pszName = cs.pszActionName;
		pAction-&gt;iResumeInterval = cs.glbliActionResumeInterval;
		pAction-&gt;iResumeRetryCount = cs.glbliActionResumeRetryCount;
		pAction-&gt;bWriteAllMarkMsgs = cs.bActionWriteAllMarkMsgs;
		pAction-&gt;bExecWhenPrevSusp = cs.bActExecWhenPrevSusp;
		pAction-&gt;iSecsExecOnceInterval = cs.iActExecOnceInterval;
		pAction-&gt;iExecEveryNthOccur = cs.iActExecEveryNthOccur;
		pAction-&gt;iExecEveryNthOccurTO = cs.iActExecEveryNthOccurTO;
		pAction-&gt;bRepMsgHasMsg = cs.bActionRepMsgHasMsg;
		cs.iActExecEveryNthOccur = 0; /* auto-reset */
		cs.iActExecEveryNthOccurTO = 0; /* auto-reset */
		cs.bActionWriteAllMarkMsgs = 1; /* auto-reset */
		cs.pszActionName = NULL;	/* free again! */
	} else {
		actionApplyCnfParam(pAction, actParams);
	}

	/* check if we can obtain the template pointers - TODO: move to separate function? */
	pAction-&gt;iNumTpls = OMSRgetEntryCount(pOMSR);
	assert(pAction-&gt;iNumTpls &gt;= 0); /* only debug check because this &quot;can not happen&quot; */
	/* please note: iNumTpls may validly be zero. This is the case if the module
	 * does not request any templates. This sounds unlikely, but an actual example is
	 * the discard action, which does not require a string. -- rgerhards, 2007-07-30
	 */
	if(pAction-&gt;iNumTpls &gt; 0) {
		/* we first need to create the template arrays */
		CHKmalloc(pAction-&gt;ppTpl = (struct template **)calloc(pAction-&gt;iNumTpls, sizeof(struct template *)));
		CHKmalloc(pAction-&gt;peParamPassing = (paramPassing_t*)calloc(pAction-&gt;iNumTpls,
			sizeof(paramPassing_t)));
	}

	pAction-&gt;bUsesMsgPassingMode = 0;
	pAction-&gt;bNeedReleaseBatch = 0;
	for(i = 0 ; i &lt; pAction-&gt;iNumTpls ; ++i) {
		CHKiRet(OMSRgetEntry(pOMSR, i, &amp;pTplName, &amp;iTplOpts));
		/* Ok, we got everything, so it now is time to look up the template
		 * (Hint: templates MUST be defined before they are used!)
		 */
		if(!(iTplOpts &amp; OMSR_TPL_AS_MSG)) {
		   	if((pAction-&gt;ppTpl[i] =
				tplFind(loadConf, (char*)pTplName, strlen((char*)pTplName))) == NULL) {
				snprintf(errMsg, sizeof(errMsg),
					 &quot; Could not find template %d '%s' - action disabled&quot;,
					 i, pTplName);
				errno = 0;
				LogError(0, RS_RET_NOT_FOUND, &quot;%s&quot;, errMsg);
				ABORT_FINALIZE(RS_RET_NOT_FOUND);
			}
			/* check required template options */
			if(   (iTplOpts &amp; OMSR_RQD_TPL_OPT_SQL)
			   &amp;&amp; (pAction-&gt;ppTpl[i]-&gt;optFormatEscape == 0)) {
				errno = 0;
				LogError(0, RS_RET_RQD_TPLOPT_MISSING, &quot;Action disabled.&quot;
						&quot; To use this action, you have to specify &quot;
						&quot;the SQL or stdSQL option in your template!\n&quot;);
				ABORT_FINALIZE(RS_RET_RQD_TPLOPT_MISSING);
			}
		}

<A NAME="2"></A>		/* set parameter-passing mode */
		if(iTplOpts &amp; OMSR_TPL_AS_ARRAY) {
			ABORT_FINALIZE(RS_RET_ERR);
<FONT color="#980517"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match2224-0.html#2',2,'match2224-top.html#2',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>		} else if(iTplOpts &amp; OMSR_TPL_AS_MSG) {
			pAction-&gt;peParamPassing[i] = ACT_MSG_PASSING;
			pAction-&gt;bUsesMsgPassingMode = 1;
		} else if(iTplOpts &amp; OMSR_TPL_AS_JSON) {
			pAction-&gt;peParamPassing[i] = ACT_JSON_PASSING;
			pAction-&gt;bNeedReleaseBatch = 1;
		} else {
			pAction-&gt;peParamPassing[i] = ACT_STRING_PASSING;</B></FONT>
		}

		DBGPRINTF(&quot;template: '%s' assigned\n&quot;, pTplName);
	}

	pAction-&gt;pMod = pMod;
	pAction-&gt;pModData = pModData;

	CHKiRet(actionConstructFinalize(pAction, lst));

	*ppAction = pAction; /* finally store the action pointer */

finalize_it:
	if(iRet == RS_RET_OK)
		iRet = OMSRdestruct(pOMSR);
	else {
		/* do not overwrite error state! */
		OMSRdestruct(pOMSR);
		if(pAction != NULL)
			actionDestruct(pAction);
	}

	RETiRet;
}


/* Reset config variables to default values.
 * rgerhards, 2009-11-12
 */
static rsRetVal
resetConfigVariables(uchar __attribute__((unused)) *pp, void __attribute__((unused)) *pVal)
{
	cs.iActExecOnceInterval = 0;
	cs.bActExecWhenPrevSusp = 0;
	return RS_RET_OK;
}


/* initialize (current) config variables.
 * Used at program start and when a new scope is created.
 */
static void
initConfigVariables(void)
{
	cs.bActionWriteAllMarkMsgs = 1;
	cs.glbliActionResumeRetryCount = 0;
	cs.bActExecWhenPrevSusp = 0;
	cs.iActExecOnceInterval = 0;
	cs.iActExecEveryNthOccur = 0;
	cs.iActExecEveryNthOccurTO = 0;
	cs.glbliActionResumeInterval = 30;
	cs.glbliActionResumeRetryCount = 0;
	cs.bActionRepMsgHasMsg = 0;
	if(cs.pszActionName != NULL) {
		free(cs.pszActionName);
		cs.pszActionName = NULL;
	}
	actionResetQueueParams();
}


rsRetVal
actionNewInst(struct nvlst *lst, action_t **ppAction)
{
	struct cnfparamvals *paramvals;
	modInfo_t *pMod;
	uchar *cnfModName = NULL;
	omodStringRequest_t *pOMSR;
	void *pModData;
	action_t *pAction;
	DEFiRet;

	paramvals = nvlstGetParams(lst, &amp;pblk, NULL);
	if(paramvals == NULL) {
		ABORT_FINALIZE(RS_RET_PARAM_ERROR);
	}
	dbgprintf(&quot;action param blk after actionNewInst:\n&quot;);
	cnfparamsPrint(&amp;pblk, paramvals);
	cnfModName = (uchar*)es_str2cstr(paramvals[cnfparamGetIdx(&amp;pblk, (&quot;type&quot;))].val.d.estr, NULL);
	if((pMod = module.FindWithCnfName(loadConf, cnfModName, eMOD_OUT)) == NULL) {
		LogError(0, RS_RET_MOD_UNKNOWN, &quot;module name '%s' is unknown&quot;, cnfModName);
		ABORT_FINALIZE(RS_RET_MOD_UNKNOWN);
	}
	CHKiRet(pMod-&gt;mod.om.newActInst(cnfModName, lst, &amp;pModData, &amp;pOMSR));

	if((iRet = addAction(&amp;pAction, pMod, pModData, pOMSR, paramvals, lst)) == RS_RET_OK) {
		/* check if the module is compatible with select features
		 * (currently no such features exist) */
		loadConf-&gt;actions.nbrActions++;	/* one more active action! */
		*ppAction = pAction;
	} else {
		// TODO: cleanup
	}

finalize_it:
	free(cnfModName);
	cnfparamvalsDestruct(paramvals, &amp;pblk);
	RETiRet;
}

rsRetVal actionClassInit(void)
{
	DEFiRet;
	/* request objects we use */
	CHKiRet(objGetObjInterface(&amp;obj)); /* this provides the root pointer for all other queries */
	CHKiRet(objUse(datetime, CORE_COMPONENT));
	CHKiRet(objUse(module, CORE_COMPONENT));
	CHKiRet(objUse(statsobj, CORE_COMPONENT));
	CHKiRet(objUse(ruleset, CORE_COMPONENT));

	CHKiRet(regCfSysLineHdlr((uchar *)&quot;actionname&quot;, 0, eCmdHdlrGetWord, NULL, &amp;cs.pszActionName, NULL));
	CHKiRet(regCfSysLineHdlr((uchar *)&quot;actionqueuefilename&quot;, 0, eCmdHdlrGetWord, NULL,
		&amp;cs.pszActionQFName, NULL));
	CHKiRet(regCfSysLineHdlr((uchar *)&quot;actionqueuesize&quot;, 0, eCmdHdlrInt, NULL, &amp;cs.iActionQueueSize,
		NULL));
	CHKiRet(regCfSysLineHdlr((uchar *)&quot;actionwriteallmarkmessages&quot;, 0, eCmdHdlrBinary, NULL,
		&amp;cs.bActionWriteAllMarkMsgs, NULL));
	CHKiRet(regCfSysLineHdlr((uchar *)&quot;actionqueuedequeuebatchsize&quot;, 0, eCmdHdlrInt, NULL,
		&amp;cs.iActionQueueDeqBatchSize, NULL));
	CHKiRet(regCfSysLineHdlr((uchar *)&quot;actionqueuemaxdiskspace&quot;, 0, eCmdHdlrSize, NULL,
		&amp;cs.iActionQueMaxDiskSpace, NULL));
	CHKiRet(regCfSysLineHdlr((uchar *)&quot;actionqueuehighwatermark&quot;, 0, eCmdHdlrInt, NULL,
		&amp;cs.iActionQHighWtrMark, NULL));
	CHKiRet(regCfSysLineHdlr((uchar *)&quot;actionqueuelowwatermark&quot;, 0, eCmdHdlrInt, NULL,
		&amp;cs.iActionQLowWtrMark, NULL));
	CHKiRet(regCfSysLineHdlr((uchar *)&quot;actionqueuediscardmark&quot;, 0, eCmdHdlrInt, NULL,
		&amp;cs.iActionQDiscardMark, NULL));
	CHKiRet(regCfSysLineHdlr((uchar *)&quot;actionqueuediscardseverity&quot;, 0, eCmdHdlrInt, NULL,
		&amp;cs.iActionQDiscardSeverity, NULL));
	CHKiRet(regCfSysLineHdlr((uchar *)&quot;actionqueuecheckpointinterval&quot;, 0, eCmdHdlrInt, NULL,
		&amp;cs.iActionQPersistUpdCnt, NULL));
	CHKiRet(regCfSysLineHdlr((uchar *)&quot;actionqueuesyncqueuefiles&quot;, 0, eCmdHdlrBinary, NULL,
		&amp;cs.bActionQSyncQeueFiles, NULL));
	CHKiRet(regCfSysLineHdlr((uchar *)&quot;actionqueuetype&quot;, 0, eCmdHdlrGetWord, setActionQueType, NULL, NULL));
	CHKiRet(regCfSysLineHdlr((uchar *)&quot;actionqueueworkerthreads&quot;, 0, eCmdHdlrInt, NULL,
		&amp;cs.iActionQueueNumWorkers, NULL));
	CHKiRet(regCfSysLineHdlr((uchar *)&quot;actionqueuetimeoutshutdown&quot;, 0, eCmdHdlrInt, NULL,
		&amp;cs.iActionQtoQShutdown, NULL));
	CHKiRet(regCfSysLineHdlr((uchar *)&quot;actionqueuetimeoutactioncompletion&quot;, 0, eCmdHdlrInt, NULL,
		&amp;cs.iActionQtoActShutdown, NULL));
	CHKiRet(regCfSysLineHdlr((uchar *)&quot;actionqueuetimeoutenqueue&quot;, 0, eCmdHdlrInt, NULL,
		&amp;cs.iActionQtoEnq, NULL));
	CHKiRet(regCfSysLineHdlr((uchar *)&quot;actionqueueworkertimeoutthreadshutdown&quot;, 0, eCmdHdlrInt, NULL,
		&amp;cs.iActionQtoWrkShutdown, NULL));
	CHKiRet(regCfSysLineHdlr((uchar *)&quot;actionqueueworkerthreadminimummessages&quot;, 0, eCmdHdlrInt, NULL,
		&amp;cs.iActionQWrkMinMsgs, NULL));
	CHKiRet(regCfSysLineHdlr((uchar *)&quot;actionqueuemaxfilesize&quot;, 0, eCmdHdlrSize, NULL,
		&amp;cs.iActionQueMaxFileSize, NULL));
	CHKiRet(regCfSysLineHdlr((uchar *)&quot;actionqueuesaveonshutdown&quot;, 0, eCmdHdlrBinary, NULL,
		&amp;cs.bActionQSaveOnShutdown, NULL));
	CHKiRet(regCfSysLineHdlr((uchar *)&quot;actionqueuedequeueslowdown&quot;, 0, eCmdHdlrInt, NULL,
		&amp;cs.iActionQueueDeqSlowdown, NULL));
	CHKiRet(regCfSysLineHdlr((uchar *)&quot;actionqueuedequeuetimebegin&quot;, 0, eCmdHdlrInt, NULL,
		&amp;cs.iActionQueueDeqtWinFromHr, NULL));
	CHKiRet(regCfSysLineHdlr((uchar *)&quot;actionqueuedequeuetimeend&quot;, 0, eCmdHdlrInt, NULL,
		&amp;cs.iActionQueueDeqtWinToHr, NULL));
	CHKiRet(regCfSysLineHdlr((uchar *)&quot;actionexeconlyeverynthtime&quot;, 0, eCmdHdlrInt, NULL,
		&amp;cs.iActExecEveryNthOccur, NULL));
	CHKiRet(regCfSysLineHdlr((uchar *)&quot;actionexeconlyeverynthtimetimeout&quot;, 0, eCmdHdlrInt, NULL,
		&amp;cs.iActExecEveryNthOccurTO, NULL));
	CHKiRet(regCfSysLineHdlr((uchar *)&quot;actionexeconlyonceeveryinterval&quot;, 0, eCmdHdlrInt, NULL,
		&amp;cs.iActExecOnceInterval, NULL));
	CHKiRet(regCfSysLineHdlr((uchar *)&quot;repeatedmsgcontainsoriginalmsg&quot;, 0, eCmdHdlrBinary, NULL,
		&amp;cs.bActionRepMsgHasMsg, NULL));
	CHKiRet(regCfSysLineHdlr((uchar *)&quot;actionexeconlywhenpreviousissuspended&quot;, 0, eCmdHdlrBinary, NULL,
		&amp;cs.bActExecWhenPrevSusp, NULL));
	CHKiRet(regCfSysLineHdlr((uchar *)&quot;actionresumeretrycount&quot;, 0, eCmdHdlrInt, NULL,
		&amp;cs.glbliActionResumeRetryCount, NULL));
	CHKiRet(regCfSysLineHdlr((uchar *)&quot;resetconfigvariables&quot;, 1, eCmdHdlrCustomHandler,
		resetConfigVariables, NULL, NULL));

	initConfigVariables(); /* first-time init of config setings */

finalize_it:
	RETiRet;
}

/* vi:set ai:
 */
</PRE>
</div>
  </div>
</body>
</html>
