<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for nsd_gtls.c &amp; action.c</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for nsd_gtls.c &amp; action.c
      </h3>
<h1 align="center">
        5.1%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>nsd_gtls.c (5.688623%)<th>action.c (4.7529707%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(2291-2372)<td><a href="#" name="0">(289-314)</a><td align="center"><font color="#ff0000">24</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(1437-1445)<td><a href="#" name="1">(1792-1804)</a><td align="center"><font color="#ff0000">24</font>
<tr onclick='openModal("#980517")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#980517"><font color="#980517">-</font><td><a href="#" name="2">(1214-1223)<td><a href="#" name="2">(2192-2199)</a><td align="center"><font color="#aa0000">16</font>
<tr onclick='openModal("#53858b")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#53858b"><font color="#53858b">-</font><td><a href="#" name="3">(1855-1868)<td><a href="#" name="3">(398-409)</a><td align="center"><font color="#7f0000">12</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>nsd_gtls.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
#include "config.h"
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;assert.h&gt;
#include &lt;string.h&gt;
#include &lt;gnutls/gnutls.h&gt;
#include &lt;gnutls/x509.h&gt;
#if GNUTLS_VERSION_NUMBER &lt;= 0x020b00
#	include &lt;gcrypt.h&gt;
#endif
#include &lt;errno.h&gt;
#include &lt;sys/stat.h&gt;
#include &lt;unistd.h&gt;
#include &lt;fcntl.h&gt;
#include &lt;pthread.h&gt;
#include "rsyslog.h"
#include "syslogd-types.h"
#include "module-template.h"
#include "cfsysline.h"
#include "obj.h"
#include "stringbuf.h"
#include "errmsg.h"
#include "net.h"
#include "datetime.h"
#include "netstrm.h"
#include "netstrms.h"
#include "nsd_ptcp.h"
#include "nsdsel_gtls.h"
#include "nsd_gtls.h"
#include "unicode-helper.h"
#include "rsconf.h"
#define CRLFILE "crl.pem"
#if GNUTLS_VERSION_NUMBER &lt;= 0x020b00
GCRY_THREAD_OPTION_PTHREAD_IMPL;
#endif
MODULE_TYPE_LIB
MODULE_TYPE_KEEP
DEFobjStaticHelpers
DEFobjCurrIf(glbl)
DEFobjCurrIf(net)
DEFobjCurrIf(datetime)
DEFobjCurrIf(nsd_ptcp)
static pthread_mutex_t mutGtlsStrerror;
#define ABORTgnutls { \
		uchar *pErr = gtlsStrerror(gnuRet); \
		LogError(0, RS_RET_GNUTLS_ERR, "unexpected GnuTLS error %d in %s:%d: %s\n", \
	gnuRet, __FILE__, __LINE__, pErr); \
		free(pErr); \
		ABORT_FINALIZE(RS_RET_GNUTLS_ERR); \
}
#define CHKgnutls(x) { \
	gnuRet = (x); \
	if(gnuRet == GNUTLS_E_FILE_ERROR) { \
		LogError(0, RS_RET_GNUTLS_ERR, "error reading file - a common cause is that the " \
			"file  does not exist"); \
		ABORT_FINALIZE(RS_RET_GNUTLS_ERR); \
	} else if(gnuRet != 0) { \
		ABORTgnutls; \
	} \
}
static void logFunction(int level, const char *msg)
{
	dbgprintf("GnuTLS log msg, level %d: %s\n", level, msg);
}
static rsRetVal
readFile(const uchar *const pszFile, gnutls_datum_t *const pBuf)
{
	int fd;
	struct stat stat_st;
	DEFiRet;
	assert(pszFile != NULL);
	assert(pBuf != NULL);
	pBuf-&gt;data = NULL;
	if((fd = open((char*)pszFile, O_RDONLY)) == -1) {
		LogError(errno, RS_RET_FILE_NOT_FOUND, "can not read file '%s'", pszFile);
		ABORT_FINALIZE(RS_RET_FILE_NOT_FOUND);
	}
	if(fstat(fd, &amp;stat_st) == -1) {
		LogError(errno, RS_RET_FILE_NO_STAT, "can not stat file '%s'", pszFile);
		ABORT_FINALIZE(RS_RET_FILE_NO_STAT);
	}
	if(stat_st.st_size &gt; 1024 * 1024) {
		LogError(0, RS_RET_FILE_TOO_LARGE, "file '%s' too large, max 1MB", pszFile);
		ABORT_FINALIZE(RS_RET_FILE_TOO_LARGE);
	}
	CHKmalloc(pBuf-&gt;data = malloc(stat_st.st_size));
	pBuf-&gt;size = stat_st.st_size;
	if(read(fd,  pBuf-&gt;data, stat_st.st_size) != stat_st.st_size) {
		LogError(0, RS_RET_IO_ERROR, "error or incomplete read of file '%s'", pszFile);
		ABORT_FINALIZE(RS_RET_IO_ERROR);
	}
finalize_it:
	if(fd != -1)
		close(fd);
	if(iRet != RS_RET_OK) {
		if(pBuf-&gt;data != NULL) {
			free(pBuf-&gt;data);
			pBuf-&gt;data = NULL;
			pBuf-&gt;size = 0;
			}
	}
	RETiRet;
}
static rsRetVal
gtlsLoadOurCertKey(nsd_gtls_t *pThis)
{
	DEFiRet;
	int gnuRet;
	gnutls_datum_t data = { NULL, 0 };
	const uchar *keyFile;
	const uchar *certFile;
	ISOBJ_TYPE_assert(pThis, nsd_gtls);
	certFile = (pThis-&gt;pszCertFile == NULL) ? glbl.GetDfltNetstrmDrvrCertFile(runConf) : pThis-&gt;pszCertFile;
	keyFile = (pThis-&gt;pszKeyFile == NULL) ? glbl.GetDfltNetstrmDrvrKeyFile(runConf) : pThis-&gt;pszKeyFile;
	if(certFile == NULL || keyFile == NULL) {
		dbgprintf("gtlsLoadOurCertKey our certificate is not set, file name values are cert: '%s', key: '%s'\n",
			  certFile, keyFile);
		ABORT_FINALIZE(RS_RET_CERTLESS);
	}
	CHKiRet(readFile(certFile, &amp;data));
	pThis-&gt;nOurCerts = sizeof(pThis-&gt;pOurCerts) / sizeof(gnutls_x509_crt_t);
	gnuRet = gnutls_x509_crt_list_import(pThis-&gt;pOurCerts, &amp;pThis-&gt;nOurCerts,
		&amp;data, GNUTLS_X509_FMT_PEM,  GNUTLS_X509_CRT_LIST_IMPORT_FAIL_IF_EXCEED);
	if(gnuRet &lt; 0) {
		ABORTgnutls;
	}
	pThis-&gt;bOurCertIsInit = 1;
	free(data.data);
	data.data = NULL;
	CHKiRet(readFile(keyFile, &amp;data));
	CHKgnutls(gnutls_x509_privkey_init(&amp;pThis-&gt;ourKey));
	pThis-&gt;bOurKeyIsInit = 1;
	CHKgnutls(gnutls_x509_privkey_import(pThis-&gt;ourKey, &amp;data, GNUTLS_X509_FMT_PEM));
	free(data.data);
finalize_it:
	if(iRet == RS_RET_CERTLESS) {
		dbgprintf("gtlsLoadOurCertKey certless exit\n");
		pThis-&gt;bOurCertIsInit = 0;
		pThis-&gt;bOurKeyIsInit = 0;
	} else if(iRet != RS_RET_OK) {
		dbgprintf("gtlsLoadOurCertKey error exit\n");
		if(data.data != NULL)
			free(data.data);
		if(pThis-&gt;bOurCertIsInit) {
			for(unsigned i=0; i&lt;pThis-&gt;nOurCerts; ++i) {
				gnutls_x509_crt_deinit(pThis-&gt;pOurCerts[i]);
			}
			pThis-&gt;bOurCertIsInit = 0;
		}
		if(pThis-&gt;bOurKeyIsInit) {
			gnutls_x509_privkey_deinit(pThis-&gt;ourKey);
			pThis-&gt;bOurKeyIsInit = 0;
		}
	} else {
		dbgprintf("gtlsLoadOurCertKey Successfully Loaded cert '%s' and key: '%s'\n", certFile, keyFile);
	}
	RETiRet;
}
static int
gtlsClientCertCallback(gnutls_session_t session,
	__attribute__((unused)) const gnutls_datum_t* req_ca_rdn,
	int __attribute__((unused)) nreqs,
	__attribute__((unused)) const gnutls_pk_algorithm_t* sign_algos,
	int __attribute__((unused)) sign_algos_length,
#if HAVE_GNUTLS_CERTIFICATE_SET_RETRIEVE_FUNCTION
	gnutls_retr2_st* st
#else
	gnutls_retr_st *st
#endif
	)
{
	nsd_gtls_t *pThis;
	pThis = (nsd_gtls_t*) gnutls_session_get_ptr(session);
#if HAVE_GNUTLS_CERTIFICATE_SET_RETRIEVE_FUNCTION
	st-&gt;cert_type = GNUTLS_CRT_X509;
#else
	st-&gt;type = GNUTLS_CRT_X509;
#endif
	st-&gt;ncerts = pThis-&gt;nOurCerts;
	st-&gt;cert.x509 = pThis-&gt;pOurCerts;
	st-&gt;key.x509 = pThis-&gt;ourKey;
	st-&gt;deinit_all = 0;
	return 0;
}
static rsRetVal
gtlsGetCertInfo(nsd_gtls_t *const pThis, cstr_t **ppStr)
{
	uchar szBufA[1024];
	uchar *szBuf = szBufA;
	size_t szBufLen = sizeof(szBufA), tmp;
	unsigned int algo, bits;
	time_t expiration_time, activation_time;
	const gnutls_datum_t *cert_list;
	unsigned cert_list_size = 0;
	gnutls_x509_crt_t cert;
	cstr_t *pStr = NULL;
	int gnuRet;
	DEFiRet;
	unsigned iAltName;
	assert(ppStr != NULL);
	ISOBJ_TYPE_assert(pThis, nsd_gtls);
	if(gnutls_certificate_type_get(pThis-&gt;sess) != GNUTLS_CRT_X509)
		return RS_RET_TLS_CERT_ERR;
	cert_list = gnutls_certificate_get_peers(pThis-&gt;sess, &amp;cert_list_size);
	CHKiRet(rsCStrConstructFromszStrf(&amp;pStr, "peer provided %d certificate(s). ", cert_list_size));
	if(cert_list_size &gt; 0) {
		CHKgnutls(gnutls_x509_crt_init(&amp;cert));
		CHKgnutls(gnutls_x509_crt_import(cert, &amp;cert_list[0], GNUTLS_X509_FMT_DER));
		expiration_time = gnutls_x509_crt_get_expiration_time(cert);
		activation_time = gnutls_x509_crt_get_activation_time(cert);
		ctime_r(&amp;activation_time, (char*)szBuf);
		szBuf[ustrlen(szBuf) - 1] = '\0'; 		CHKiRet(rsCStrAppendStrf(pStr, "Certificate 1 info: "
			"certificate valid from %s ", szBuf));
		ctime_r(&amp;expiration_time, (char*)szBuf);
		szBuf[ustrlen(szBuf) - 1] = '\0'; 		CHKiRet(rsCStrAppendStrf(pStr, "to %s; ", szBuf));
		algo = gnutls_x509_crt_get_pk_algorithm(cert, &amp;bits);
		CHKiRet(rsCStrAppendStrf(pStr, "Certificate public key: %s; ",
			gnutls_pk_algorithm_get_name(algo)));
		tmp = szBufLen;
		if(gnutls_x509_crt_get_dn(cert, (char*)szBuf, &amp;tmp)
		    == GNUTLS_E_SHORT_MEMORY_BUFFER) {
			szBufLen = tmp;
			szBuf = malloc(tmp);
			gnutls_x509_crt_get_dn(cert, (char*)szBuf, &amp;tmp);
		}
		CHKiRet(rsCStrAppendStrf(pStr, "DN: %s; ", szBuf));
		tmp = szBufLen;
		if(gnutls_x509_crt_get_issuer_dn(cert, (char*)szBuf, &amp;tmp)
		    == GNUTLS_E_SHORT_MEMORY_BUFFER) {
			szBufLen = tmp;
			szBuf = realloc((szBuf == szBufA) ? NULL : szBuf, tmp);
			gnutls_x509_crt_get_issuer_dn(cert, (char*)szBuf, &amp;tmp);
		}
		CHKiRet(rsCStrAppendStrf(pStr, "Issuer DN: %s; ", szBuf));
		iAltName = 0;
		while(1) { 			tmp = szBufLen;
			gnuRet = gnutls_x509_crt_get_subject_alt_name(cert, iAltName,
					szBuf, &amp;tmp, NULL);
			if(gnuRet == GNUTLS_E_SHORT_MEMORY_BUFFER) {
				szBufLen = tmp;
				szBuf = realloc((szBuf == szBufA) ? NULL : szBuf, tmp);
				continue;
			} else if(gnuRet &lt; 0)
				break;
			else if(gnuRet == GNUTLS_SAN_DNSNAME) {
				CHKiRet(rsCStrAppendStrf(pStr, "SAN:DNSname: %s; ", szBuf));
			}
			++iAltName;
		}
		gnutls_x509_crt_deinit(cert);
	}
	cstrFinalize(pStr);
	*ppStr = pStr;
finalize_it:
	if(iRet != RS_RET_OK) {
		if(pStr != NULL)
			rsCStrDestruct(&amp;pStr);
	}
	if(szBuf != szBufA)
		free(szBuf);
	RETiRet;
}
static rsRetVal
print_info(nsd_gtls_t *pThis)
{
	const char *tmp;
	gnutls_credentials_type cred;
	gnutls_kx_algorithm kx;
	DEFiRet;
	ISOBJ_TYPE_assert(pThis, nsd_gtls);
	kx = gnutls_kx_get(pThis-&gt;sess);
	tmp = gnutls_kx_get_name(kx);
	dbgprintf("- Key Exchange: %s\n", tmp);
	cred = gnutls_auth_get_type(pThis-&gt;sess);
	switch (cred) {
	case GNUTLS_CRD_ANON:       		dbgprintf("- Anonymous DH using prime of %d bits\n",
		gnutls_dh_get_prime_bits(pThis-&gt;sess));
		break;
		if (kx == GNUTLS_KX_DHE_RSA || kx == GNUTLS_KX_DHE_DSS) {
		 dbgprintf("\n- Ephemeral DH using prime of %d bits\n",
			gnutls_dh_get_prime_bits(pThis-&gt;sess));
		}
		gtlsPrintCert(pThis);
		break;
	case GNUTLS_CRD_SRP:        		dbgprintf("GNUTLS_CRD_SRP/IA");
		break;
	case GNUTLS_CRD_PSK:        		dbgprintf("GNUTLS_CRD_PSK");
		break;
	case GNUTLS_CRD_IA:        		dbgprintf("GNUTLS_CRD_IA");
		break;
	} 
	tmp = gnutls_protocol_get_name(gnutls_protocol_get_version(pThis-&gt;sess));
	dbgprintf("- Protocol: %s\n", tmp);
	tmp = gnutls_certificate_type_get_name(
	gnutls_certificate_type_get(pThis-&gt;sess));
	dbgprintf("- Certificate Type: %s\n", tmp);
	tmp = gnutls_compression_get_name( gnutls_compression_get(pThis-&gt;sess));
	dbgprintf("- Compression: %s\n", tmp);
	tmp = gnutls_cipher_get_name(gnutls_cipher_get(pThis-&gt;sess));
	dbgprintf("- Cipher: %s\n", tmp);
	tmp = gnutls_mac_get_name(gnutls_mac_get(pThis-&gt;sess));
	dbgprintf("- MAC: %s\n", tmp);
	RETiRet;
}
#endif
static rsRetVal
GenFingerprintStr(uchar *pFingerprint, size_t sizeFingerprint, cstr_t **ppStr)
{
	cstr_t *pStr = NULL;
	uchar buf[4];
	size_t i;
	DEFiRet;
	CHKiRet(rsCStrConstruct(&amp;pStr));
	CHKiRet(rsCStrAppendStrWithLen(pStr, (uchar*)"SHA1", 4));
	for(i = 0 ; i &lt; sizeFingerprint ; ++i) {
		snprintf((char*)buf, sizeof(buf), ":%2.2X", pFingerprint[i]);
		CHKiRet(rsCStrAppendStrWithLen(pStr, buf, 3));
	}
	cstrFinalize(pStr);
	*ppStr = pStr;
finalize_it:
	if(iRet != RS_RET_OK) {
		if(pStr != NULL)
			rsCStrDestruct(&amp;pStr);
	}
	RETiRet;
}
uchar *gtlsStrerror(int error)
{
	uchar *pErr;
	pthread_mutex_lock(&amp;mutGtlsStrerror);
	pErr = (uchar*) strdup(gnutls_strerror(error));
	pthread_mutex_unlock(&amp;mutGtlsStrerror);
	return pErr;
}
rsRetVal
gtlsRecordRecv(nsd_gtls_t *pThis)
{
	ssize_t lenRcvd;
	DEFiRet;
	ISOBJ_TYPE_assert(pThis, nsd_gtls);
	DBGPRINTF("gtlsRecordRecv: start (Pending Data: %zd | Wanted Direction: %s)\n",
		gnutls_record_check_pending(pThis-&gt;sess),
		(gnutls_record_get_direction(pThis-&gt;sess) == gtlsDir_READ ? "READ" : "WRITE") );
	lenRcvd = gnutls_record_recv(pThis-&gt;sess, pThis-&gt;pszRcvBuf, NSD_GTLS_MAX_RCVBUF);
	if(lenRcvd &gt;= 0) {
		DBGPRINTF("gtlsRecordRecv: gnutls_record_recv received %zd bytes\n", lenRcvd);
		pThis-&gt;lenRcvBuf = lenRcvd;
		pThis-&gt;ptrRcvBuf = 0;
		size_t stBytesLeft = gnutls_record_check_pending(pThis-&gt;sess);
		if (stBytesLeft &gt; 0 ){
			DBGPRINTF("gtlsRecordRecv: %zd Bytes pending after gnutls_record_recv, expand buffer.\n",
				stBytesLeft);
			char *const newbuf = realloc(pThis-&gt;pszRcvBuf, NSD_GTLS_MAX_RCVBUF+stBytesLeft);
			CHKmalloc(newbuf);
			pThis-&gt;pszRcvBuf = newbuf;
			lenRcvd = gnutls_record_recv(pThis-&gt;sess, pThis-&gt;pszRcvBuf+NSD_GTLS_MAX_RCVBUF, stBytesLeft);
			if(lenRcvd &gt; 0) {
				DBGPRINTF("gtlsRecordRecv: 2nd SSL_read received %zd bytes\n",
					(NSD_GTLS_MAX_RCVBUF+lenRcvd));
				pThis-&gt;lenRcvBuf = NSD_GTLS_MAX_RCVBUF+lenRcvd;
			} else {
				if (lenRcvd == GNUTLS_E_AGAIN || lenRcvd == GNUTLS_E_INTERRUPTED) {
					goto sslerragain;					} else {
					int gnuRet = lenRcvd;
					ABORTgnutls;
				}
			}
		}
	} else if(lenRcvd == GNUTLS_E_AGAIN || lenRcvd == GNUTLS_E_INTERRUPTED) {
sslerragain:
		if (gnutls_record_get_direction(pThis-&gt;sess) == gtlsDir_READ) {
			pThis-&gt;rtryCall = gtlsRtry_recv;
			dbgprintf("GnuTLS receive requires a retry, this most probably is OK and no error condition\n");
			ABORT_FINALIZE(RS_RET_RETRY);
		} else {
			uchar *pErr = gtlsStrerror(lenRcvd);
			LogError(0, RS_RET_GNUTLS_ERR, "GnuTLS receive error %zd has wrong read direction(wants write) "
				"- this could be caused by a broken connection. GnuTLS reports: %s\n",
				lenRcvd, pErr);
			free(pErr);
			ABORT_FINALIZE(RS_RET_GNUTLS_ERR);
		}
	} else {
		int gnuRet = lenRcvd;
		ABORTgnutls;
	}
finalize_it:
	dbgprintf("gtlsRecordRecv return. nsd %p, iRet %d, lenRcvd %d, lenRcvBuf %d, ptrRcvBuf %d\n",
	pThis, iRet, (int) lenRcvd, pThis-&gt;lenRcvBuf, pThis-&gt;ptrRcvBuf);
	RETiRet;
}
static rsRetVal
gtlsAddOurCert(nsd_gtls_t *const pThis)
{
	int gnuRet = 0;
	const uchar *keyFile;
	const uchar *certFile;
	uchar *pGnuErr; 	DEFiRet;
	certFile = (pThis-&gt;pszCertFile == NULL) ? glbl.GetDfltNetstrmDrvrCertFile(runConf) : pThis-&gt;pszCertFile;
	keyFile = (pThis-&gt;pszKeyFile == NULL) ? glbl.GetDfltNetstrmDrvrKeyFile(runConf) : pThis-&gt;pszKeyFile;
	dbgprintf("GTLS certificate file: '%s'\n", certFile);
	dbgprintf("GTLS key file: '%s'\n", keyFile);
	if(certFile == NULL) {
		LogMsg(0, RS_RET_CERT_MISSING, LOG_WARNING, "warning: certificate file is not set");
	}
	if(keyFile == NULL) {
		LogMsg(0, RS_RET_CERTKEY_MISSING, LOG_WARNING, "warning: key file is not set");
	}
	if(certFile != NULL &amp;&amp; keyFile != NULL) {
		CHKgnutls(gnutls_certificate_set_x509_key_file(pThis-&gt;xcred, (char*)certFile, (char*)keyFile,
			GNUTLS_X509_FMT_PEM));
	}
finalize_it:
	if(iRet != RS_RET_OK &amp;&amp; iRet != RS_RET_CERT_MISSING &amp;&amp; iRet != RS_RET_CERTKEY_MISSING) {
		pGnuErr = gtlsStrerror(gnuRet);
		errno = 0;
		LogError(0, iRet, "error adding our certificate. GnuTLS error %d, message: '%s', "
				"key: '%s', cert: '%s'", gnuRet, pGnuErr, keyFile, certFile);
		free(pGnuErr);
	}
	RETiRet;
}
#ifdef false
static void print_cipher_suite_list(const char *priorities)
{
	size_t i;
	int ret;
	unsigned int idx;
	const char *name;
	const char *err;
	unsigned char id[2];
	gnutls_protocol_t version;
	gnutls_priority_t pcache;
	if (priorities != NULL) {
		printf("print_cipher_suite_list: Cipher suites for %s\n", priorities);
		ret = gnutls_priority_init(&amp;pcache, priorities, &amp;err);
		if (ret &lt; 0) {
			fprintf(stderr, "print_cipher_suite_list: Syntax error at: %s\n", err);
			exit(1);
		}
		for (i = 0;; i++) {
			ret = gnutls_priority_get_cipher_suite_index(pcache, i, &amp;idx);
			if (ret == GNUTLS_E_REQUESTED_DATA_NOT_AVAILABLE)
				break;
			if (ret == GNUTLS_E_UNKNOWN_CIPHER_SUITE)
				continue;
			name = gnutls_cipher_suite_info(idx, id, NULL, NULL, NULL, &amp;version);
			if (name != NULL)
				dbgprintf("print_cipher_suite_list: %-50s\t0x%02x, 0x%02x\t%s\n",
				name, (unsigned char) id[0],
				(unsigned char) id[1],
				gnutls_protocol_get_name(version));
		}
		return;
	}
}
#endif
static rsRetVal
gtlsInitCred(nsd_gtls_t *const pThis )
{
	int gnuRet;
	const uchar *cafile;
	DEFiRet;
	CHKgnutls(gnutls_certificate_allocate_credentials(&amp;pThis-&gt;xcred));
	cafile = (pThis-&gt;pszCAFile == NULL) ? glbl.GetDfltNetstrmDrvrCAF(runConf) : pThis-&gt;pszCAFile;
	if(cafile == NULL) {
		LogMsg(0, RS_RET_CA_CERT_MISSING, LOG_WARNING,
			"Warning: CA certificate is not set");
	} else {
		dbgprintf("GTLS CA file: '%s'\n", cafile);
		gnuRet = gnutls_certificate_set_x509_trust_file(pThis-&gt;xcred, (char*)cafile, GNUTLS_X509_FMT_PEM);
		if(gnuRet == GNUTLS_E_FILE_ERROR) {
			LogError(0, RS_RET_GNUTLS_ERR,
				"error reading certificate file '%s' - a common cause is that the "
				"file  does not exist", cafile);
			ABORT_FINALIZE(RS_RET_GNUTLS_ERR);
		} else if(gnuRet &lt; 0) {
			uchar *pErr = gtlsStrerror(gnuRet);
			LogError(0, RS_RET_GNUTLS_ERR, "unexpected GnuTLS error %d in %s:%d: %s\n",
			gnuRet, __FILE__, __LINE__, pErr);
			free(pErr);
			ABORT_FINALIZE(RS_RET_GNUTLS_ERR);
		}
	}
finalize_it:
	RETiRet;
}
static rsRetVal
gtlsGlblInit(void)
{
	int gnuRet;
	DEFiRet;
	dbgprintf("gtlsGlblInit: Running Version: '%#010x'\n", GNUTLS_VERSION_NUMBER);
	#if GNUTLS_VERSION_NUMBER &lt;= 0x020b00
	gcry_control (GCRYCTL_SET_THREAD_CBS, &amp;gcry_threads_pthread);
	#endif
	CHKgnutls(gnutls_global_init());
	if(GetGnuTLSLoglevel(runConf) &gt; 0){
		gnutls_global_set_log_function(logFunction);
		gnutls_global_set_log_level(GetGnuTLSLoglevel(runConf));
	}
	CHKgnutls(gnutls_dh_params_init(&amp;dh_params));
	CHKgnutls(gnutls_dh_params_generate2(dh_params, dhBits));
	CHKgnutls(gnutls_anon_allocate_client_credentials(&amp;anoncred));
	CHKgnutls(gnutls_anon_allocate_server_credentials(&amp;anoncredSrv));
	gnutls_anon_set_server_dh_params(anoncredSrv, dh_params);
finalize_it:
	RETiRet;
}
static rsRetVal
gtlsInitSession(nsd_gtls_t *pThis)
{
	DEFiRet;
	int gnuRet = 0;
	gnutls_session_t session;
	gnutls_init(&amp;session, GNUTLS_SERVER);
	pThis-&gt;bHaveSess = 1;
	pThis-&gt;bIsInitiator = 0;
	pThis-&gt;sess = session;
#	if HAVE_GNUTLS_CERTIFICATE_SET_RETRIEVE_FUNCTION
	gnutls_session_set_ptr(pThis-&gt;sess, (void*)pThis);
	iRet = gtlsLoadOurCertKey(pThis); 	if(iRet == RS_RET_OK) {
		dbgprintf("gtlsInitSession: enable certificate checking (VerifyDepth=%d)\n", pThis-&gt;DrvrVerifyDepth);
		gnutls_certificate_set_retrieve_function(pThis-&gt;xcred, gtlsClientCertCallback);
		if (pThis-&gt;DrvrVerifyDepth != 0){
			gnutls_certificate_set_verify_limits(pThis-&gt;xcred, 8200, pThis-&gt;DrvrVerifyDepth);
		}
	} else if(iRet == RS_RET_CERTLESS) {
		dbgprintf("gtlsInitSession: certificates not configured, not loaded.\n");
	} else {
		ABORT_FINALIZE(iRet); 	}
#	endif
	CHKgnutls(gnutls_credentials_set(pThis-&gt;sess, GNUTLS_CRD_CERTIFICATE, pThis-&gt;xcred));
	if (pThis-&gt;authMode == GTLS_AUTH_CERTANON) {
		dbgprintf("gtlsInitSession: anon authmode, gnutls_credentials_set GNUTLS_CRD_ANON\n");
		CHKgnutls(gnutls_credentials_set(pThis-&gt;sess, GNUTLS_CRD_ANON, anoncredSrv));
		gnutls_dh_set_prime_bits(pThis-&gt;sess, dhMinBits);
	}
	gnutls_certificate_server_set_request( pThis-&gt;sess, GNUTLS_CERT_REQUEST);
finalize_it:
	if(iRet != RS_RET_OK &amp;&amp; iRet != RS_RET_CERTLESS) {
		LogError(0, iRet, "gtlsInitSession failed to INIT Session %d", gnuRet);
	}
	RETiRet;
}
static rsRetVal
gtlsGetCN(gnutls_x509_crt_t *pCert, cstr_t **ppstrCN)
{
	DEFiRet;
	int gnuRet;
	int i;
	int bFound;
	cstr_t *pstrCN = NULL;
	size_t size;
	uchar szDN[1024]; 
	assert(pCert != NULL);
	assert(ppstrCN != NULL);
	assert(*ppstrCN == NULL);
	size = sizeof(szDN);
	CHKgnutls(gnutls_x509_crt_get_dn(*pCert, (char*)szDN, &amp;size));
	i = 0;
	bFound = 0;
	while(!bFound &amp;&amp; szDN[i] != '\0') {
		if(szDN[i] == 'C' &amp;&amp; szDN[i+1] == 'N' &amp;&amp; szDN[i+2] == '=') {
			bFound = 1;
			i += 2;
		}
		i++;
	}
	if(!bFound) {
		FINALIZE; 	}
	CHKiRet(cstrConstruct(&amp;pstrCN));
	while(szDN[i] != '\0' &amp;&amp; szDN[i] != ',') {
		if(szDN[i] == '\\') {
			++i; 			if(szDN[i] == '\0')
				ABORT_FINALIZE(RS_RET_CERT_INVALID_DN);
			CHKiRet(cstrAppendChar(pstrCN, szDN[i]));
		} else {
			CHKiRet(cstrAppendChar(pstrCN, szDN[i]));
		}
		++i; 	}
	cstrFinalize(pstrCN);
	*ppstrCN = pstrCN;
finalize_it:
	if(iRet != RS_RET_OK) {
		if(pstrCN != NULL)
			cstrDestruct(&amp;pstrCN);
	}
	RETiRet;
}
static rsRetVal
gtlsChkPeerFingerprint(nsd_gtls_t *pThis, gnutls_x509_crt_t *pCert)
{
	uchar fingerprint[20];
	size_t size;
	cstr_t *pstrFingerprint = NULL;
	int bFoundPositiveMatch;
	permittedPeers_t *pPeer;
	int gnuRet;
	DEFiRet;
	ISOBJ_TYPE_assert(pThis, nsd_gtls);
	size = sizeof(fingerprint);
	CHKgnutls(gnutls_x509_crt_get_fingerprint(*pCert, GNUTLS_DIG_SHA1, fingerprint, &amp;size));
	CHKiRet(GenFingerprintStr(fingerprint, size, &amp;pstrFingerprint));
	dbgprintf("peer's certificate SHA1 fingerprint: %s\n", cstrGetSzStrNoNULL(pstrFingerprint));
	bFoundPositiveMatch = 0;
	pPeer = pThis-&gt;pPermPeers;
	while(pPeer != NULL &amp;&amp; !bFoundPositiveMatch) {
		if(!rsCStrSzStrCmp(pstrFingerprint, pPeer-&gt;pszID, strlen((char*) pPeer-&gt;pszID))) {
			bFoundPositiveMatch = 1;
		} else {
			pPeer = pPeer-&gt;pNext;
		}
	}
	if(!bFoundPositiveMatch) {
		dbgprintf("invalid peer fingerprint, not permitted to talk to it\n");
		if(pThis-&gt;bReportAuthErr == 1) {
			errno = 0;
			LogError(0, RS_RET_INVALID_FINGERPRINT, "error: peer fingerprint '%s' unknown - we are "
					"not permitted to talk to it", cstrGetSzStrNoNULL(pstrFingerprint));
			pThis-&gt;bReportAuthErr = 0;
		}
		ABORT_FINALIZE(RS_RET_INVALID_FINGERPRINT);
	}
finalize_it:
	if(pstrFingerprint != NULL)
		cstrDestruct(&amp;pstrFingerprint);
	RETiRet;
}
static rsRetVal
gtlsChkOnePeerName(nsd_gtls_t *pThis, uchar *pszPeerID, int *pbFoundPositiveMatch)
{
	permittedPeers_t *pPeer;
	DEFiRet;
	ISOBJ_TYPE_assert(pThis, nsd_gtls);
	assert(pszPeerID != NULL);
	assert(pbFoundPositiveMatch != NULL);
	if(pThis-&gt;pPermPeers) { 		pPeer = pThis-&gt;pPermPeers;
		while(pPeer != NULL) {
			CHKiRet(net.PermittedPeerWildcardMatch(pPeer, pszPeerID, pbFoundPositiveMatch));
			if(*pbFoundPositiveMatch)
				break;
			pPeer = pPeer-&gt;pNext;
		}
	} else {
		if(   pThis-&gt;pszConnectHost
		   &amp;&amp; !strcmp((char*)pszPeerID, (char*)pThis-&gt;pszConnectHost)) {
			*pbFoundPositiveMatch = 1;
		}
	}
finalize_it:
	RETiRet;
}
static rsRetVal
gtlsChkPeerName(nsd_gtls_t *pThis, gnutls_x509_crt_t *pCert)
{
	uchar lnBuf[256];
	char szAltName[1024]; 	int iAltName;
	size_t szAltNameLen;
	int bFoundPositiveMatch;
	int bHaveSAN = 0;
	cstr_t *pStr = NULL;
	cstr_t *pstrCN = NULL;
	int gnuRet;
	DEFiRet;
	ISOBJ_TYPE_assert(pThis, nsd_gtls);
	bFoundPositiveMatch = 0;
	CHKiRet(rsCStrConstruct(&amp;pStr));
	iAltName = 0;
	while(!bFoundPositiveMatch) { 		szAltNameLen = sizeof(szAltName);
		gnuRet = gnutls_x509_crt_get_subject_alt_name(*pCert, iAltName,
				szAltName, &amp;szAltNameLen, NULL);
		if(gnuRet &lt; 0)
			break;
		else if(gnuRet == GNUTLS_SAN_DNSNAME) {
			bHaveSAN = 1;
			dbgprintf("subject alt dnsName: '%s'\n", szAltName);
			snprintf((char*)lnBuf, sizeof(lnBuf), "DNSname: %s; ", szAltName);
			CHKiRet(rsCStrAppendStr(pStr, lnBuf));
			CHKiRet(gtlsChkOnePeerName(pThis, (uchar*)szAltName, &amp;bFoundPositiveMatch));
		}
		++iAltName;
	}
	if(!bFoundPositiveMatch &amp;&amp; (!pThis-&gt;bSANpriority || !bHaveSAN)) {
		CHKiRet(gtlsGetCN(pCert, &amp;pstrCN));
		if(pstrCN != NULL) { 			dbgprintf("gtls now checking auth for CN '%s'\n", cstrGetSzStrNoNULL(pstrCN));
			snprintf((char*)lnBuf, sizeof(lnBuf), "CN: %s; ", cstrGetSzStrNoNULL(pstrCN));
			CHKiRet(rsCStrAppendStr(pStr, lnBuf));
			CHKiRet(gtlsChkOnePeerName(pThis, cstrGetSzStrNoNULL(pstrCN), &amp;bFoundPositiveMatch));
		}
	}
	if(!bFoundPositiveMatch) {
		dbgprintf("invalid peer name, not permitted to talk to it\n");
		if(pThis-&gt;bReportAuthErr == 1) {
			cstrFinalize(pStr);
			errno = 0;
			LogError(0, RS_RET_INVALID_FINGERPRINT, "error: peer name not authorized -  "
					"not permitted to talk to it. Names: %s",
					cstrGetSzStrNoNULL(pStr));
			pThis-&gt;bReportAuthErr = 0;
		}
		ABORT_FINALIZE(RS_RET_INVALID_FINGERPRINT);
	}
finalize_it:
	if(pStr != NULL)
		rsCStrDestruct(&amp;pStr);
	if(pstrCN != NULL)
		rsCStrDestruct(&amp;pstrCN);
	RETiRet;
}
static rsRetVal
gtlsChkPeerID(nsd_gtls_t *pThis)
{
	const gnutls_datum_t *cert_list;
	unsigned int list_size = 0;
	gnutls_x509_crt_t cert;
	int bMustDeinitCert = 0;
	int gnuRet;
	DEFiRet;
	ISOBJ_TYPE_assert(pThis, nsd_gtls);
	if(gnutls_certificate_type_get(pThis-&gt;sess) != GNUTLS_CRT_X509)
		return RS_RET_TLS_CERT_ERR;
	cert_list = gnutls_certificate_get_peers(pThis-&gt;sess, &amp;list_size);
	if(list_size &lt; 1) {
		if(pThis-&gt;bReportAuthErr == 1) {
			errno = 0;
			LogError(0, RS_RET_TLS_NO_CERT, "error: peer did not provide a certificate, "
					"not permitted to talk to it");
			pThis-&gt;bReportAuthErr = 0;
		}
		ABORT_FINALIZE(RS_RET_TLS_NO_CERT);
	}
	CHKgnutls(gnutls_x509_crt_init(&amp;cert));
	bMustDeinitCert = 1; 	CHKgnutls(gnutls_x509_crt_import(cert, &amp;cert_list[0], GNUTLS_X509_FMT_DER));
	if(pThis-&gt;authMode == GTLS_AUTH_CERTFINGERPRINT) {
		CHKiRet(gtlsChkPeerFingerprint(pThis, &amp;cert));
	} else {
		assert(pThis-&gt;authMode == GTLS_AUTH_CERTNAME);
		CHKiRet(gtlsChkPeerName(pThis, &amp;cert));
	}
finalize_it:
	if(bMustDeinitCert)
		gnutls_x509_crt_deinit(cert);
	RETiRet;
}
static rsRetVal
gtlsChkPeerCertValidity(nsd_gtls_t *pThis)
{
	DEFiRet;
	const char *pszErrCause;
	int gnuRet;
	cstr_t *pStr = NULL;
	unsigned stateCert;
	const gnutls_datum_t *cert_list;
	unsigned cert_list_size = 0;
	gnutls_x509_crt_t cert;
	unsigned i;
	time_t ttCert;
	time_t ttNow;
	sbool bAbort = RSFALSE;
	int iAbortCode = RS_RET_OK;
	ISOBJ_TYPE_assert(pThis, nsd_gtls);
	cert_list = gnutls_certificate_get_peers(pThis-&gt;sess, &amp;cert_list_size);
	if(cert_list_size &lt; 1) {
		errno = 0;
		LogError(0, RS_RET_TLS_NO_CERT,
			"peer did not provide a certificate, not permitted to talk to it");
		ABORT_FINALIZE(RS_RET_TLS_NO_CERT);
	}
#ifdef EXTENDED_CERT_CHECK_AVAILABLE
	if (pThis-&gt;dataTypeCheck == GTLS_NONE) {
#endif
		CHKgnutls(gnutls_certificate_verify_peers2(pThis-&gt;sess, &amp;stateCert));
#ifdef EXTENDED_CERT_CHECK_AVAILABLE
	} else { 		gnutls_typed_vdata_st data;
		data.type = GNUTLS_DT_KEY_PURPOSE_OID;
		if (pThis-&gt;bIsInitiator) { 			data.data = (uchar *)GNUTLS_KP_TLS_WWW_SERVER;
		} else { 			data.data = (uchar *)GNUTLS_KP_TLS_WWW_CLIENT;
		}
		data.size = ustrlen(data.data);
		CHKgnutls(gnutls_certificate_verify_peers(pThis-&gt;sess, &amp;data, 1, &amp;stateCert));
	}
#endif
	if(stateCert &amp; GNUTLS_CERT_INVALID) {
		iAbortCode = RS_RET_CERT_INVALID;
		if (stateCert &amp; GNUTLS_CERT_EXPIRED ) {
			dbgprintf("GnuTLS returned GNUTLS_CERT_EXPIRED, handling mode %d ...\n",
				pThis-&gt;permitExpiredCerts);
			if (pThis-&gt;permitExpiredCerts == GTLS_EXPIRED_DENY) {
				bAbort = RSTRUE;
				iAbortCode = RS_RET_CERT_EXPIRED;
			} else if (pThis-&gt;permitExpiredCerts == GTLS_EXPIRED_WARN) {
				LogMsg(0, RS_RET_NO_ERRCODE, LOG_WARNING,
					"Warning, certificate expired but expired certs are permitted");
			} else {
				dbgprintf("GnuTLS returned GNUTLS_CERT_EXPIRED, but expired certs are permitted.\n");
			}
			pszErrCause = "certificate expired";
		} else if(stateCert &amp; GNUTLS_CERT_SIGNER_NOT_FOUND) {
			pszErrCause = "signer not found";
			bAbort = RSTRUE;
		} else if(stateCert &amp; GNUTLS_CERT_SIGNER_NOT_CA) {
			pszErrCause = "signer is not a CA";
			bAbort = RSTRUE;
<a name="2"></a>		} else if(stateCert &amp; GNUTLS_CERT_INSECURE_ALGORITHM) {
			pszErrCause = "insecure algorithm";
			bAbort = RSTRUE;
<font color="#980517"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>		} else if(stateCert &amp; GNUTLS_CERT_REVOKED) {
			pszErrCause = "certificate revoked";
			bAbort = RSTRUE;
#ifdef EXTENDED_CERT_CHECK_AVAILABLE
		} else if(stateCert &amp; GNUTLS_CERT_PURPOSE_MISMATCH) {
			pszErrCause = "key purpose OID does not match";
			bAbort = RSTRUE;
#endif
		} else {
			pszErrCause = "GnuTLS returned no specific reason";</b></font>
			dbgprintf("GnuTLS returned no specific reason for GNUTLS_CERT_INVALID, certificate "
				 "status is %d\n", stateCert);
			bAbort = RSTRUE;
		}
	}
	if (bAbort == RSTRUE) {
		LogError(0, NO_ERRCODE, "not permitted to talk to peer, certificate invalid: %s",
				pszErrCause);
		gtlsGetCertInfo(pThis, &amp;pStr);
		LogError(0, NO_ERRCODE, "invalid cert info: %s", cstrGetSzStrNoNULL(pStr));
		cstrDestruct(&amp;pStr);
		ABORT_FINALIZE(iAbortCode);
	}
	if(datetime.GetTime(&amp;ttNow) == -1)
		ABORT_FINALIZE(RS_RET_SYS_ERR);
	for(i = 0 ; i &lt; cert_list_size ; ++i) {
		CHKgnutls(gnutls_x509_crt_init(&amp;cert));
		CHKgnutls(gnutls_x509_crt_import(cert, &amp;cert_list[i], GNUTLS_X509_FMT_DER));
		ttCert = gnutls_x509_crt_get_activation_time(cert);
		if(ttCert == -1)
			ABORT_FINALIZE(RS_RET_TLS_CERT_ERR);
		else if(ttCert &gt; ttNow) {
			LogError(0, RS_RET_CERT_NOT_YET_ACTIVE, "not permitted to talk to peer: "
					"certificate %d not yet active", i);
			gtlsGetCertInfo(pThis, &amp;pStr);
			LogError(0, RS_RET_CERT_NOT_YET_ACTIVE,
				"invalid cert info: %s", cstrGetSzStrNoNULL(pStr));
			cstrDestruct(&amp;pStr);
			ABORT_FINALIZE(RS_RET_CERT_NOT_YET_ACTIVE);
		}
		gnutls_x509_crt_deinit(cert);
	}
finalize_it:
	RETiRet;
}
rsRetVal
gtlsChkPeerAuth(nsd_gtls_t *pThis)
{
	DEFiRet;
	ISOBJ_TYPE_assert(pThis, nsd_gtls);
	switch(pThis-&gt;authMode) {
		case GTLS_AUTH_CERTNAME:
			CHKiRet(gtlsChkPeerCertValidity(pThis));
			CHKiRet(gtlsChkPeerID(pThis));
			break;
		case GTLS_AUTH_CERTFINGERPRINT:
			CHKiRet(gtlsChkPeerID(pThis));
			break;
		case GTLS_AUTH_CERTVALID:
			CHKiRet(gtlsChkPeerCertValidity(pThis));
			break;
		case GTLS_AUTH_CERTANON:
			FINALIZE;
			break;
	}
finalize_it:
	RETiRet;
}
static rsRetVal
gtlsGlblExit(void)
{
	DEFiRet;
	gnutls_global_deinit();
	RETiRet;
}
static rsRetVal
gtlsEndSess(nsd_gtls_t *pThis)
{
	int gnuRet;
	DEFiRet;
	if(pThis-&gt;bHaveSess) {
		if(pThis-&gt;bIsInitiator) {
			gnuRet = gnutls_bye(pThis-&gt;sess, GNUTLS_SHUT_WR);
			while(gnuRet == GNUTLS_E_INTERRUPTED || gnuRet == GNUTLS_E_AGAIN) {
				gnuRet = gnutls_bye(pThis-&gt;sess, GNUTLS_SHUT_WR);
			}
		}
		gnutls_deinit(pThis-&gt;sess);
		pThis-&gt;bHaveSess = 0;
	}
	RETiRet;
}
#pragma GCC diagnostic ignored "-Wint-to-pointer-cast"
static inline void
gtlsSetTransportPtr(nsd_gtls_t *pThis, int sock)
{
	gnutls_transport_set_ptr(pThis-&gt;sess, (gnutls_transport_ptr_t) sock);
}
#pragma GCC diagnostic warning "-Wint-to-pointer-cast"
BEGINobjConstruct(nsd_gtls) 	iRet = nsd_ptcp.Construct(&amp;pThis-&gt;pTcp);
	pThis-&gt;bReportAuthErr = 1;
ENDobjConstruct(nsd_gtls)
PROTOTYPEobjDestruct(nsd_gtls);
BEGINobjDestruct(nsd_gtls) CODESTARTobjDestruct(nsd_gtls)
	if(pThis-&gt;iMode == 1) {
		gtlsEndSess(pThis);
	}
	if(pThis-&gt;pTcp != NULL) {
		nsd_ptcp.Destruct(&amp;pThis-&gt;pTcp);
	}
	free(pThis-&gt;pszConnectHost);
	free(pThis-&gt;pszRcvBuf);
	free((void*) pThis-&gt;pszCAFile);
	if(pThis-&gt;bOurCertIsInit)
		for(unsigned i=0; i&lt;pThis-&gt;nOurCerts; ++i) {
			gnutls_x509_crt_deinit(pThis-&gt;pOurCerts[i]);
		}
	if(pThis-&gt;bOurKeyIsInit)
		gnutls_x509_privkey_deinit(pThis-&gt;ourKey);
	if(pThis-&gt;bHaveSess)
		gnutls_deinit(pThis-&gt;sess);
	if(pThis-&gt;xcred != NULL
	   &amp;&amp; (pThis-&gt;bIsInitiator || (!pThis-&gt;xcred_is_copy &amp;&amp; (!pThis-&gt;bIsInitiator || pThis-&gt;bHaveSess)))
	  ) {
		gnutls_certificate_free_credentials(pThis-&gt;xcred);
		free((void*) pThis-&gt;pszKeyFile);
		free((void*) pThis-&gt;pszCertFile);
	}
ENDobjDestruct(nsd_gtls)
static rsRetVal
SetMode(nsd_t *pNsd, int mode)
{
	DEFiRet;
	nsd_gtls_t *pThis = (nsd_gtls_t*) pNsd;
	ISOBJ_TYPE_assert((pThis), nsd_gtls);
	if(mode != 0 &amp;&amp; mode != 1) {
		LogError(0, RS_RET_INVALID_DRVR_MODE, "error: driver mode %d not supported by "
				"gtls netstream driver", mode);
		ABORT_FINALIZE(RS_RET_INVALID_DRVR_MODE);
	}
	pThis-&gt;iMode = mode;
finalize_it:
	RETiRet;
}
static rsRetVal
SetAuthMode(nsd_t *pNsd, uchar *mode)
{
	DEFiRet;
<a name="1"></a>	nsd_gtls_t *pThis = (nsd_gtls_t*) pNsd;
	ISOBJ_TYPE_assert((pThis), nsd_gtls);
<font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>	if(mode == NULL || !strcasecmp((char*)mode, "x509/name")) {
		pThis-&gt;authMode = GTLS_AUTH_CERTNAME;
	} else if(!strcasecmp((char*) mode, "x509/fingerprint")) {
		pThis-&gt;authMode = GTLS_AUTH_CERTFINGERPRINT;
	} else if(!strcasecmp((char*) mode, "x509/certvalid")) {
		pThis-&gt;authMode = GTLS_AUTH_CERTVALID;
	} else if(!strcasecmp((char*) mode, "anon")) {
		pThis-&gt;authMode = GTLS_AUTH_CERTANON;
	} else {</b></font>
		LogError(0, RS_RET_VALUE_NOT_SUPPORTED, "error: authentication mode '%s' not supported by "
				"gtls netstream driver", mode);
		ABORT_FINALIZE(RS_RET_VALUE_NOT_SUPPORTED);
	}
	dbgprintf("SetAuthMode to %s\n", (mode != NULL ? (char*)mode : "NULL"));
finalize_it:
	RETiRet;
}
static rsRetVal
SetPermitExpiredCerts(nsd_t *pNsd, uchar *mode)
{
	DEFiRet;
	nsd_gtls_t *pThis = (nsd_gtls_t*) pNsd;
	ISOBJ_TYPE_assert((pThis), nsd_gtls);
	if(mode == NULL || !strcasecmp((char*)mode, "off")) {
		pThis-&gt;permitExpiredCerts = GTLS_EXPIRED_DENY;
	} else if(!strcasecmp((char*) mode, "warn")) {
		pThis-&gt;permitExpiredCerts = GTLS_EXPIRED_WARN;
	} else if(!strcasecmp((char*) mode, "on")) {
		pThis-&gt;permitExpiredCerts = GTLS_EXPIRED_PERMIT;
	} else {
		LogError(0, RS_RET_VALUE_NOT_SUPPORTED, "error: permitexpiredcerts mode '%s' not supported by "
				"gtls netstream driver", mode);
		ABORT_FINALIZE(RS_RET_VALUE_NOT_SUPPORTED);
	}
	dbgprintf("SetPermitExpiredCerts: Set Mode %s/%d\n",
		(mode != NULL ? (char*)mode : "NULL"), pThis-&gt;permitExpiredCerts);
finalize_it:
	RETiRet;
}
static rsRetVal
SetPermPeers(nsd_t *pNsd, permittedPeers_t *pPermPeers)
{
	DEFiRet;
	nsd_gtls_t *pThis = (nsd_gtls_t*) pNsd;
	ISOBJ_TYPE_assert((pThis), nsd_gtls);
	if(pPermPeers == NULL)
		FINALIZE;
	if(pThis-&gt;authMode != GTLS_AUTH_CERTFINGERPRINT &amp;&amp; pThis-&gt;authMode != GTLS_AUTH_CERTNAME) {
		LogError(0, RS_RET_VALUE_NOT_IN_THIS_MODE, "authentication not supported by "
			"gtls netstream driver in the configured authentication mode - ignored");
		ABORT_FINALIZE(RS_RET_VALUE_NOT_IN_THIS_MODE);
	}
	pThis-&gt;pPermPeers = pPermPeers;
finalize_it:
	RETiRet;
}
static rsRetVal
SetGnutlsPriorityString(nsd_t *pNsd, uchar *gnutlsPriorityString)
{
	DEFiRet;
	nsd_gtls_t *pThis = (nsd_gtls_t*) pNsd;
	ISOBJ_TYPE_assert((pThis), nsd_gtls);
	pThis-&gt;gnutlsPriorityString = gnutlsPriorityString;
	dbgprintf("gnutlsPriorityString: set to '%s'\n",
		(gnutlsPriorityString != NULL ? (char*)gnutlsPriorityString : "NULL"));
	RETiRet;
}
static rsRetVal
SetCheckExtendedKeyUsage(nsd_t *pNsd, int ChkExtendedKeyUsage)
{
	DEFiRet;
	nsd_gtls_t *pThis = (nsd_gtls_t*) pNsd;
	ISOBJ_TYPE_assert((pThis), nsd_gtls);
	if(ChkExtendedKeyUsage != 0 &amp;&amp; ChkExtendedKeyUsage != 1) {
		LogError(0, RS_RET_VALUE_NOT_SUPPORTED, "error: driver ChkExtendedKeyUsage %d "
				"not supported by gtls netstream driver", ChkExtendedKeyUsage);
		ABORT_FINALIZE(RS_RET_VALUE_NOT_SUPPORTED);
	}
	pThis-&gt;dataTypeCheck = ChkExtendedKeyUsage;
finalize_it:
	RETiRet;
}
static rsRetVal
SetPrioritizeSAN(nsd_t *pNsd, int prioritizeSan)
{
	DEFiRet;
	nsd_gtls_t *pThis = (nsd_gtls_t*) pNsd;
	ISOBJ_TYPE_assert((pThis), nsd_gtls);
	if(prioritizeSan != 0 &amp;&amp; prioritizeSan != 1) {
		LogError(0, RS_RET_VALUE_NOT_SUPPORTED, "error: driver prioritizeSan %d "
				"not supported by gtls netstream driver", prioritizeSan);
		ABORT_FINALIZE(RS_RET_VALUE_NOT_SUPPORTED);
	}
	pThis-&gt;bSANpriority = prioritizeSan;
finalize_it:
	RETiRet;
}
static rsRetVal
SetTlsVerifyDepth(nsd_t *pNsd, int verifyDepth)
{
	DEFiRet;
	nsd_gtls_t *pThis = (nsd_gtls_t*) pNsd;
	ISOBJ_TYPE_assert((pThis), nsd_gtls);
	if (verifyDepth == 0) {
		FINALIZE;
	}
	assert(verifyDepth &gt;= 2);
	pThis-&gt;DrvrVerifyDepth = verifyDepth;
finalize_it:
	RETiRet;
}
static rsRetVal
SetTlsCAFile(nsd_t *pNsd, const uchar *const caFile)
{
	DEFiRet;
	nsd_gtls_t *const pThis = (nsd_gtls_t*) pNsd;
	ISOBJ_TYPE_assert((pThis), nsd_gtls);
	if(caFile == NULL) {
		pThis-&gt;pszCAFile = NULL;
	} else {
		CHKmalloc(pThis-&gt;pszCAFile = (const uchar*) strdup((const char*) caFile));
	}
finalize_it:
	RETiRet;
}
static rsRetVal
SetTlsKeyFile(nsd_t *pNsd, const uchar *const pszFile)
{
	DEFiRet;
	nsd_gtls_t *const pThis = (nsd_gtls_t*) pNsd;
	ISOBJ_TYPE_assert((pThis), nsd_gtls);
	if(pszFile == NULL) {
		pThis-&gt;pszKeyFile = NULL;
	} else {
		CHKmalloc(pThis-&gt;pszKeyFile = (const uchar*) strdup((const char*) pszFile));
	}
finalize_it:
	RETiRet;
}
static rsRetVal
SetTlsCertFile(nsd_t *pNsd, const uchar *const pszFile)
{
	DEFiRet;
	nsd_gtls_t *const pThis = (nsd_gtls_t*) pNsd;
	ISOBJ_TYPE_assert((pThis), nsd_gtls);
	if(pszFile == NULL) {
		pThis-&gt;pszCertFile = NULL;
	} else {
		CHKmalloc(pThis-&gt;pszCertFile = (const uchar*) strdup((const char*) pszFile));
	}
finalize_it:
	RETiRet;
}
static rsRetVal
SetSock(nsd_t *pNsd, int sock)
{
	DEFiRet;
	nsd_gtls_t *pThis = (nsd_gtls_t*) pNsd;
	ISOBJ_TYPE_assert((pThis), nsd_gtls);
	assert(sock &gt;= 0);
	nsd_ptcp.SetSock(pThis-&gt;pTcp, sock);
	RETiRet;
}
static rsRetVal
SetKeepAliveIntvl(nsd_t *pNsd, int keepAliveIntvl)
{
	DEFiRet;
	nsd_gtls_t *pThis = (nsd_gtls_t*) pNsd;
	ISOBJ_TYPE_assert((pThis), nsd_gtls);
	assert(keepAliveIntvl &gt;= 0);
	nsd_ptcp.SetKeepAliveIntvl(pThis-&gt;pTcp, keepAliveIntvl);
	RETiRet;
}
static rsRetVal
SetKeepAliveProbes(nsd_t *pNsd, int keepAliveProbes)
{
	DEFiRet;
	nsd_gtls_t *pThis = (nsd_gtls_t*) pNsd;
	ISOBJ_TYPE_assert((pThis), nsd_gtls);
	assert(keepAliveProbes &gt;= 0);
	nsd_ptcp.SetKeepAliveProbes(pThis-&gt;pTcp, keepAliveProbes);
	RETiRet;
}
static rsRetVal
SetKeepAliveTime(nsd_t *pNsd, int keepAliveTime)
{
	DEFiRet;
	nsd_gtls_t *pThis = (nsd_gtls_t*) pNsd;
	ISOBJ_TYPE_assert((pThis), nsd_gtls);
	assert(keepAliveTime &gt;= 0);
	nsd_ptcp.SetKeepAliveTime(pThis-&gt;pTcp, keepAliveTime);
	RETiRet;
}
static rsRetVal
Abort(nsd_t *pNsd)
{
	nsd_gtls_t *pThis = (nsd_gtls_t*) pNsd;
	DEFiRet;
	ISOBJ_TYPE_assert((pThis), nsd_gtls);
	if(pThis-&gt;iMode == 0) {
		nsd_ptcp.Abort(pThis-&gt;pTcp);
	}
	RETiRet;
}
static rsRetVal
LstnInitDrvr(netstrm_t *const pThis)
{
	DEFiRet;
	CHKiRet(gtlsInitCred((nsd_gtls_t*) pThis-&gt;pDrvrData));
	CHKiRet(gtlsAddOurCert((nsd_gtls_t*) pThis-&gt;pDrvrData));
finalize_it:
	RETiRet;
}
static rsRetVal ATTR_NONNULL(1,3,5)
LstnInit(netstrms_t *pNS, void *pUsr, rsRetVal(*fAddLstn)(void*,netstrm_t*),
	 const int iSessMax, const tcpLstnParams_t *const cnf_params)
{
	DEFiRet;
	pNS-&gt;fLstnInitDrvr = LstnInitDrvr;
	iRet = nsd_ptcp.LstnInit(pNS, pUsr, fAddLstn, iSessMax, cnf_params);
	RETiRet;
}
static rsRetVal
CheckConnection(nsd_t __attribute__((unused)) *pNsd)
{
	nsd_gtls_t *pThis = (nsd_gtls_t*) pNsd;
	ISOBJ_TYPE_assert(pThis, nsd_gtls);
	dbgprintf("CheckConnection for %p\n", pNsd);
	return nsd_ptcp.CheckConnection(pThis-&gt;pTcp);
}
static rsRetVal
GetRemoteHName(nsd_t *pNsd, uchar **ppszHName)
{
	DEFiRet;
	nsd_gtls_t *pThis = (nsd_gtls_t*) pNsd;
	ISOBJ_TYPE_assert(pThis, nsd_gtls);
	iRet = nsd_ptcp.GetRemoteHName(pThis-&gt;pTcp, ppszHName);
	RETiRet;
}
static rsRetVal
GetRemAddr(nsd_t *pNsd, struct sockaddr_storage **ppAddr)
{
	DEFiRet;
	nsd_gtls_t *pThis = (nsd_gtls_t*) pNsd;
	ISOBJ_TYPE_assert(pThis, nsd_gtls);
	iRet = nsd_ptcp.GetRemAddr(pThis-&gt;pTcp, ppAddr);
	RETiRet;
}
static rsRetVal
GetRemoteIP(nsd_t *pNsd, prop_t **ip)
{
	DEFiRet;
	nsd_gtls_t *pThis = (nsd_gtls_t*) pNsd;
	ISOBJ_TYPE_assert(pThis, nsd_gtls);
	iRet = nsd_ptcp.GetRemoteIP(pThis-&gt;pTcp, ip);
	RETiRet;
}
static rsRetVal
AcceptConnReq(nsd_t *pNsd, nsd_t **ppNew)
{
	DEFiRet;
	int gnuRet;
	nsd_gtls_t *pNew = NULL;
	nsd_gtls_t *pThis = (nsd_gtls_t*) pNsd;
	const char *error_position = NULL;
	ISOBJ_TYPE_assert((pThis), nsd_gtls);
	CHKiRet(nsd_gtlsConstruct(&amp;pNew)); 	CHKiRet(nsd_ptcp.Destruct(&amp;pNew-&gt;pTcp));
	CHKiRet(nsd_ptcp.AcceptConnReq(pThis-&gt;pTcp, &amp;pNew-&gt;pTcp));
	if(pThis-&gt;iMode == 0) {
		*ppNew = (nsd_t*) pNew;
<a name="3"></a>		FINALIZE;
	}
<font color="#53858b"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>	pNew-&gt;authMode = pThis-&gt;authMode;
	pNew-&gt;permitExpiredCerts = pThis-&gt;permitExpiredCerts;
	pNew-&gt;pPermPeers = pThis-&gt;pPermPeers;
	pNew-&gt;gnutlsPriorityString = pThis-&gt;gnutlsPriorityString;
	pNew-&gt;DrvrVerifyDepth = pThis-&gt;DrvrVerifyDepth;
	pNew-&gt;dataTypeCheck = pThis-&gt;dataTypeCheck;
	pNew-&gt;bSANpriority = pThis-&gt;bSANpriority;
	pNew-&gt;pszCertFile = pThis-&gt;pszCertFile;
	pNew-&gt;pszKeyFile = pThis-&gt;pszKeyFile;
	pNew-&gt;xcred = pThis-&gt;xcred; 	pNew-&gt;xcred_is_copy = 1; 
	iRet = gtlsInitSession(pNew);</b></font>
	if (iRet != RS_RET_OK) {
		if (iRet == RS_RET_CERTLESS) {
			dbgprintf("AcceptConnReq certless mode\n");
			iRet = RS_RET_OK;
		} else {
			goto finalize_it;
		}
	}
	gtlsSetTransportPtr(pNew, ((nsd_ptcp_t*) (pNew-&gt;pTcp))-&gt;sock);
	dbgprintf("AcceptConnReq bOurCertIsInit=%hu bOurKeyIsInit=%hu \n",
		pNew-&gt;bOurCertIsInit, pNew-&gt;bOurKeyIsInit);
	if(pNew-&gt;gnutlsPriorityString != NULL) {
		dbgprintf("AcceptConnReq setting configured priority string (ciphers)\n");
		if(gnutls_priority_set_direct(pNew-&gt;sess,
					(const char*) pNew-&gt;gnutlsPriorityString,
					&amp;error_position)==GNUTLS_E_INVALID_REQUEST) {
			LogError(0, RS_RET_GNUTLS_ERR, "Syntax Error in"
					" Priority String: \"%s\"\n", error_position);
		}
	} else {
		if(pThis-&gt;authMode == GTLS_AUTH_CERTANON) {
			dbgprintf("AcceptConnReq setting anon ciphers Try1: %s\n", GTLS_ANON_PRIO_NOTLSV13);
			if(gnutls_priority_set_direct(pNew-&gt;sess,(const char*) GTLS_ANON_PRIO_NOTLSV13,
				&amp;error_position)==GNUTLS_E_INVALID_REQUEST) {
				dbgprintf("AcceptConnReq setting anon ciphers Try2 (TLS1.3 unknown): %s\n",
					GTLS_ANON_PRIO);
				CHKgnutls(gnutls_priority_set_direct(pNew-&gt;sess, GTLS_ANON_PRIO, &amp;error_position));
			}
		} else {
			dbgprintf("AcceptConnReq setting default ciphers\n");
			CHKgnutls(gnutls_set_default_priority(pNew-&gt;sess));
		}
	}
	gnuRet = gnutls_handshake(pNew-&gt;sess);
	if(gnuRet == GNUTLS_E_AGAIN || gnuRet == GNUTLS_E_INTERRUPTED) {
		pNew-&gt;rtryCall = gtlsRtry_handshake;
		dbgprintf("GnuTLS handshake does not complete immediately - "
			"setting to retry (this is OK and normal)\n");
	} else if(gnuRet == 0) {
		CHKiRet(gtlsChkPeerAuth(pNew));
	} else {
		uchar *pGnuErr = gtlsStrerror(gnuRet);
		LogError(0, RS_RET_TLS_HANDSHAKE_ERR,
			"gnutls returned error on handshake: %s\n", pGnuErr);
		free(pGnuErr);
		ABORT_FINALIZE(RS_RET_TLS_HANDSHAKE_ERR);
	}
	pNew-&gt;iMode = 1; 
	*ppNew = (nsd_t*) pNew;
finalize_it:
	if(iRet != RS_RET_OK) {
if (error_position != NULL) {
	dbgprintf("AcceptConnReq error_position=%s\n", error_position);
}
		if(pNew != NULL)
			nsd_gtlsDestruct(&amp;pNew);
	}
	RETiRet;
}
static rsRetVal
Rcv(nsd_t *pNsd, uchar *pBuf, ssize_t *pLenBuf, int *const oserr)
{
	DEFiRet;
	ssize_t iBytesCopy; 	nsd_gtls_t *pThis = (nsd_gtls_t*) pNsd;
	ISOBJ_TYPE_assert(pThis, nsd_gtls);
	if(pThis-&gt;bAbortConn)
		ABORT_FINALIZE(RS_RET_CONNECTION_ABORTREQ);
	if(pThis-&gt;iMode == 0) {
		CHKiRet(nsd_ptcp.Rcv(pThis-&gt;pTcp, pBuf, pLenBuf, oserr));
		FINALIZE;
	}
	if(pThis-&gt;pszRcvBuf == NULL) {
		CHKmalloc(pThis-&gt;pszRcvBuf = malloc(NSD_GTLS_MAX_RCVBUF));
		pThis-&gt;lenRcvBuf = -1;
	}
	if(pThis-&gt;lenRcvBuf == -1) { 		CHKiRet(gtlsRecordRecv(pThis));
	}
	if(pThis-&gt;lenRcvBuf == 0) { 		*oserr = errno;
		ABORT_FINALIZE(RS_RET_CLOSED);
	}
	iBytesCopy = pThis-&gt;lenRcvBuf - pThis-&gt;ptrRcvBuf;
	if(iBytesCopy &gt; *pLenBuf) {
		iBytesCopy = *pLenBuf;
	} else {
		pThis-&gt;lenRcvBuf = -1; 	}
	memcpy(pBuf, pThis-&gt;pszRcvBuf + pThis-&gt;ptrRcvBuf, iBytesCopy);
	pThis-&gt;ptrRcvBuf += iBytesCopy;
	*pLenBuf = iBytesCopy;
finalize_it:
	if (iRet != RS_RET_OK &amp;&amp;
		iRet != RS_RET_RETRY) {
		*pLenBuf = 0;
		free(pThis-&gt;pszRcvBuf);
		pThis-&gt;pszRcvBuf = NULL;
	}
	dbgprintf("gtlsRcv return. nsd %p, iRet %d, lenRcvBuf %d, ptrRcvBuf %d\n", pThis,
	iRet, pThis-&gt;lenRcvBuf, pThis-&gt;ptrRcvBuf);
	RETiRet;
}
static rsRetVal
Send(nsd_t *pNsd, uchar *pBuf, ssize_t *pLenBuf)
{
	int iSent;
	int wantsWriteData = 0;
	nsd_gtls_t *pThis = (nsd_gtls_t*) pNsd;
	DEFiRet;
	ISOBJ_TYPE_assert(pThis, nsd_gtls);
	if(pThis-&gt;bAbortConn)
		ABORT_FINALIZE(RS_RET_CONNECTION_ABORTREQ);
	if(pThis-&gt;iMode == 0) {
		CHKiRet(nsd_ptcp.Send(pThis-&gt;pTcp, pBuf, pLenBuf));
		FINALIZE;
	}
	while(1) { 		iSent = gnutls_record_send(pThis-&gt;sess, pBuf, *pLenBuf);
		if(iSent &gt;= 0) {
			*pLenBuf = iSent;
			break;
		}
		if(iSent != GNUTLS_E_INTERRUPTED &amp;&amp; iSent != GNUTLS_E_AGAIN) {
			wantsWriteData = gnutls_record_get_direction(pThis-&gt;sess);
			uchar *pErr = gtlsStrerror(iSent);
			LogError(0, RS_RET_GNUTLS_ERR, "unexpected GnuTLS error %d, wantsWriteData=%d - this "
				"could be caused by a broken connection. GnuTLS reports: %s\n",
				iSent, wantsWriteData, pErr);
			free(pErr);
			gnutls_perror(iSent);
			ABORT_FINALIZE(RS_RET_GNUTLS_ERR);
		}
	}
finalize_it:
	RETiRet;
}
static rsRetVal
EnableKeepAlive(nsd_t *pNsd)
{
	nsd_gtls_t *pThis = (nsd_gtls_t*) pNsd;
	ISOBJ_TYPE_assert(pThis, nsd_gtls);
	return nsd_ptcp.EnableKeepAlive(pThis-&gt;pTcp);
}
static int
SetServerNameIfPresent(nsd_gtls_t *pThis, uchar *host) {
	struct sockaddr_in sa;
	struct sockaddr_in6 sa6;
	int inet_pton_ret = inet_pton(AF_INET, CHAR_CONVERT(host), &amp;(sa.sin_addr));
	if (inet_pton_ret == 0) { 		inet_pton_ret = inet_pton(AF_INET6, CHAR_CONVERT(host), &amp;(sa6.sin6_addr));
	}
	switch(inet_pton_ret) {
		case 1: 			return 0;
		case 0: 			return gnutls_server_name_set(pThis-&gt;sess, GNUTLS_NAME_DNS, host, ustrlen(host));
		default: 			return -1;
	}
}
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations" static rsRetVal
Connect(nsd_t *pNsd, int family, uchar *port, uchar *host, char *device)
{
	nsd_gtls_t *pThis = (nsd_gtls_t*) pNsd;
	int sock;
	int gnuRet;
	const char *error_position;
#	ifdef HAVE_GNUTLS_CERTIFICATE_TYPE_SET_PRIORITY
	static const int cert_type_priority[2] = { GNUTLS_CRT_X509, 0 };
#	endif
	DEFiRet;
	dbgprintf("Connect to %s:%s\n", host, port);
	ISOBJ_TYPE_assert(pThis, nsd_gtls);
	assert(port != NULL);
	assert(host != NULL);
	CHKiRet(gtlsInitCred(pThis));
	CHKiRet(gtlsAddOurCert(pThis));
	CHKiRet(nsd_ptcp.Connect(pThis-&gt;pTcp, family, port, host, device));
	if(pThis-&gt;iMode == 0)
		FINALIZE;
	CHKgnutls(gnutls_init(&amp;pThis-&gt;sess, GNUTLS_CLIENT));
	pThis-&gt;bHaveSess = 1;
	pThis-&gt;bIsInitiator = 1;
	CHKgnutls(SetServerNameIfPresent(pThis, host));
	gnutls_session_set_ptr(pThis-&gt;sess, (void*)pThis);
	iRet = gtlsLoadOurCertKey(pThis); 	if(iRet == RS_RET_OK) {
#		if HAVE_GNUTLS_CERTIFICATE_SET_RETRIEVE_FUNCTION
		gnutls_certificate_set_retrieve_function(pThis-&gt;xcred, gtlsClientCertCallback);
#		else
		gnutls_certificate_client_set_retrieve_function(pThis-&gt;xcred, gtlsClientCertCallback);
#		endif
		dbgprintf("Connect: enable certificate checking (VerifyDepth=%d)\n", pThis-&gt;DrvrVerifyDepth);
		if (pThis-&gt;DrvrVerifyDepth != 0) {
			gnutls_certificate_set_verify_limits(pThis-&gt;xcred, 8200, pThis-&gt;DrvrVerifyDepth);
		}
	} else if(iRet == RS_RET_CERTLESS) {
		dbgprintf("Connect: certificates not configured, not loaded.\n");
	} else {
		LogError(0, iRet, "Connect failed to INIT Session %d", gnuRet);
		ABORT_FINALIZE(iRet);; 	}
	if(pThis-&gt;gnutlsPriorityString != NULL) {
		dbgprintf("Connect: setting configured priority string (ciphers)\n");
		if(gnutls_priority_set_direct(pThis-&gt;sess,
					(const char*) pThis-&gt;gnutlsPriorityString,
					&amp;error_position)==GNUTLS_E_INVALID_REQUEST) {
			LogError(0, RS_RET_GNUTLS_ERR, "Syntax Error in"
					" Priority String: \"%s\"\n", error_position);
		}
	} else {
		if(pThis-&gt;authMode == GTLS_AUTH_CERTANON || pThis-&gt;bOurCertIsInit == 0) {
			dbgprintf("Connect: setting anon ciphers Try1: %s\n", GTLS_ANON_PRIO_NOTLSV13);
			if(gnutls_priority_set_direct(pThis-&gt;sess,(const char*) GTLS_ANON_PRIO_NOTLSV13,
				&amp;error_position)==GNUTLS_E_INVALID_REQUEST) {
				dbgprintf("Connect: setting anon ciphers Try2 (TLS1.3 unknown): %s\n", GTLS_ANON_PRIO);
				CHKgnutls(gnutls_priority_set_direct(pThis-&gt;sess, GTLS_ANON_PRIO, &amp;error_position));
			}
		} else {
			dbgprintf("Connect: setting default ciphers\n");
			CHKgnutls(gnutls_set_default_priority(pThis-&gt;sess));
		}
	}
#	ifdef HAVE_GNUTLS_CERTIFICATE_TYPE_SET_PRIORITY
	CHKgnutls(gnutls_certificate_type_set_priority(pThis-&gt;sess, cert_type_priority));
#	endif
	CHKgnutls(gnutls_credentials_set(pThis-&gt;sess, GNUTLS_CRD_CERTIFICATE, pThis-&gt;xcred));
	if (pThis-&gt;authMode == GTLS_AUTH_CERTANON) {
		dbgprintf("Connect: anon authmode, gnutls_credentials_set GNUTLS_CRD_ANON\n");
		CHKgnutls(gnutls_credentials_set(pThis-&gt;sess, GNUTLS_CRD_ANON, anoncred));
		gnutls_dh_set_prime_bits(pThis-&gt;sess, dhMinBits);
	}
	CHKiRet(nsd_ptcp.GetSock(pThis-&gt;pTcp, &amp;sock));
	gtlsSetTransportPtr(pThis, sock);
	CHKmalloc(pThis-&gt;pszConnectHost = (uchar*)strdup((char*)host));
	CHKgnutls(gnutls_handshake(pThis-&gt;sess));
	dbgprintf("GnuTLS handshake succeeded\n");
	CHKiRet(gtlsChkPeerAuth(pThis));
finalize_it:
	if(iRet != RS_RET_OK) {
		if(pThis-&gt;bHaveSess) {
			gnutls_deinit(pThis-&gt;sess);
			pThis-&gt;bHaveSess = 0;
			pThis-&gt;xcred = NULL;
		}
	}
	RETiRet;
}
#pragma GCC diagnostic pop
BEGINobjQueryInterface(nsd_gtls)
CODESTARTobjQueryInterface(nsd_gtls)
	if(pIf-&gt;ifVersion != nsdCURR_IF_VERSION) {		ABORT_FINALIZE(RS_RET_INTERFACE_NOT_SUPPORTED);
	}
	pIf-&gt;Construct = (rsRetVal(*)(nsd_t**)) nsd_gtlsConstruct;
	pIf-&gt;Destruct = (rsRetVal(*)(nsd_t**)) nsd_gtlsDestruct;
	pIf-&gt;Abort = Abort;
<a name="0"></a>	pIf-&gt;LstnInit = LstnInit;
	pIf-&gt;AcceptConnReq = AcceptConnReq;
	pIf-&gt;Rcv = Rcv;
<font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>	pIf-&gt;Send = Send;
	pIf-&gt;Connect = Connect;
	pIf-&gt;SetSock = SetSock;
	pIf-&gt;SetMode = SetMode;
	pIf-&gt;SetAuthMode = SetAuthMode;
	pIf-&gt;SetPermitExpiredCerts = SetPermitExpiredCerts;
	pIf-&gt;SetPermPeers =SetPermPeers;
	pIf-&gt;CheckConnection = CheckConnection;
	pIf-&gt;GetRemoteHName = GetRemoteHName;
	pIf-&gt;GetRemoteIP = GetRemoteIP;
	pIf-&gt;GetRemAddr = GetRemAddr;
	pIf-&gt;EnableKeepAlive = EnableKeepAlive;
	pIf-&gt;SetKeepAliveIntvl = SetKeepAliveIntvl;
	pIf-&gt;SetKeepAliveProbes = SetKeepAliveProbes;
	pIf-&gt;SetKeepAliveTime = SetKeepAliveTime;
	pIf-&gt;SetGnutlsPriorityString = SetGnutlsPriorityString;
	pIf-&gt;SetCheckExtendedKeyUsage = SetCheckExtendedKeyUsage;
	pIf-&gt;SetPrioritizeSAN = SetPrioritizeSAN;
	pIf-&gt;SetTlsVerifyDepth = SetTlsVerifyDepth;
	pIf-&gt;SetTlsCAFile = SetTlsCAFile;
	pIf-&gt;SetTlsKeyFile = SetTlsKeyFile;
	pIf-&gt;SetTlsCertFile = SetTlsCertFile;
finalize_it:
ENDobjQueryInterface(nsd_gtls)
BEGINObjClassExit(nsd_gtls, OBJ_IS_LOADABLE_MODULE) CODESTARTObjClassExit(nsd_gtls)
	gtlsGlblExit();	
	objRelease(nsd_ptcp, LM_NSD_PTCP_FILENAME);
	objRelease(net, LM_NET_FILENAME);
	objRelease(glbl, CORE_COMPONENT);
	objRelease(datetime, CORE_COMPONENT);
ENDObjClassExit(nsd_gtls)
BEGINObjClassInit(nsd_gtls, 1, OBJ_IS_LOADABLE_MODULE) 	CHKiRet(objUse(datetime, CORE_COMPONENT));
	CHKiRet(objUse(glbl, CORE_COMPONENT));
	CHKiRet(objUse(net, LM_NET_FILENAME));
	CHKiRet(objUse(nsd_ptcp, LM_NSD_PTCP_FILENAME));
	CHKiRet(gtlsGlblInit());
ENDObjClassInit(nsd_gtls)
BEGINmodExit
CODESTARTmodExit
	nsdsel_gtlsClassExit();
	nsd_gtlsClassExit();
	pthread_mutex_destroy(&amp;mutGtlsStrerror);
ENDmodExit
BEGINqueryEtryPt
CODESTARTqueryEtryPt
CODEqueryEtryPt_STD_LIB_QUERIES
ENDqueryEtryPt
BEGINmodInit()
CODESTARTmodInit
	*ipIFVersProvided = CURR_MOD_IF_VERSION; 
	CHKiRet(nsd_gtlsClassInit(pModInfo)); 	CHKiRet(nsdsel_gtlsClassInit(pModInfo)); 
	pthread_mutex_init(&amp;mutGtlsStrerror, NULL);</b></font>
ENDmodInit
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>action.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
#include "config.h"
#include &lt;stdio.h&gt;
#include &lt;assert.h&gt;
#include &lt;stdarg.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;strings.h&gt;
#include &lt;time.h&gt;
#include &lt;errno.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;sys/stat.h&gt;
#include &lt;fcntl.h&gt;
#include &lt;unistd.h&gt;
#include &lt;json.h&gt;
#include "rsyslog.h"
#include "dirty.h"
#include "template.h"
#include "action.h"
#include "modules.h"
#include "cfsysline.h"
#include "srUtils.h"
#include "errmsg.h"
#include "batch.h"
#include "wti.h"
#include "rsconf.h"
#include "datetime.h"
#include "unicode-helper.h"
#include "atomic.h"
#include "ruleset.h"
#include "parserif.h"
#include "statsobj.h"
#ifdef _AIX
#define cs legacy_cs
#endif
PRAGMA_INGORE_Wswitch_enum
#ifndef O_LARGEFILE
#define O_LARGEFILE 0
#endif
#define NO_TIME_PROVIDED 0 
static rsRetVal ATTR_NONNULL() processBatchMain(void *pVoid, batch_t *pBatch, wti_t * const pWti);
static rsRetVal doSubmitToActionQ(action_t * const pAction, wti_t * const pWti, smsg_t*);
static rsRetVal doSubmitToActionQComplex(action_t * const pAction, wti_t * const pWti, smsg_t*);
static rsRetVal doSubmitToActionQNotAllMark(action_t * const pAction, wti_t * const pWti, smsg_t*);
static void ATTR_NONNULL() actionSuspend(action_t * const pThis, wti_t * const pWti);
static void ATTR_NONNULL() actionRetry(action_t * const pThis, wti_t * const pWti);
DEFobjCurrIf(obj)
DEFobjCurrIf(datetime)
DEFobjCurrIf(module)
DEFobjCurrIf(statsobj)
DEFobjCurrIf(ruleset)
typedef struct configSettings_s {
	int bActExecWhenPrevSusp;				int bActionWriteAllMarkMsgs;				int iActExecOnceInterval;				int iActExecEveryNthOccur;				time_t iActExecEveryNthOccurTO;				int glbliActionResumeInterval;
	int glbliActionResumeRetryCount;			int bActionRepMsgHasMsg;				uchar *pszActionName;					queueType_t ActionQueType;				int iActionQueueSize;					int iActionQueueDeqBatchSize;				int iActionQHighWtrMark;				int iActionQLowWtrMark;					int iActionQDiscardMark;				int iActionQDiscardSeverity;
	int iActionQueueNumWorkers;				uchar *pszActionQFName;					int64 iActionQueMaxFileSize;
	int iActionQPersistUpdCnt;				int bActionQSyncQeueFiles;				int iActionQtoQShutdown;				int iActionQtoActShutdown;				int iActionQtoEnq;					int iActionQtoWrkShutdown;				int iActionQWrkMinMsgs;					int bActionQSaveOnShutdown;				int64 iActionQueMaxDiskSpace;				int iActionQueueDeqSlowdown;				int iActionQueueDeqtWinFromHr;				int iActionQueueDeqtWinToHr;			} configSettings_t;
static configSettings_t cs;					
static struct cnfparamdescr cnfparamdescr[] = {
	{ "name", eCmdHdlrGetWord, 0 }, 	{ "type", eCmdHdlrString, CNFPARAM_REQUIRED }, 	{ "action.errorfile", eCmdHdlrString, 0 },
	{ "action.errorfile.maxsize", eCmdHdlrInt, 0 },
	{ "action.writeallmarkmessages", eCmdHdlrBinary, 0 }, 	{ "action.execonlyeverynthtime", eCmdHdlrInt, 0 }, 	{ "action.execonlyeverynthtimetimeout", eCmdHdlrInt, 0 }, 	{ "action.execonlyonceeveryinterval", eCmdHdlrInt, 0 }, 	{ "action.execonlywhenpreviousissuspended", eCmdHdlrBinary, 0 },
	{ "action.repeatedmsgcontainsoriginalmsg", eCmdHdlrBinary, 0 }, 	{ "action.resumeretrycount", eCmdHdlrInt, 0 }, 	{ "action.reportsuspension", eCmdHdlrBinary, 0 },
	{ "action.reportsuspensioncontinuation", eCmdHdlrBinary, 0 },
	{ "action.resumeintervalmax", eCmdHdlrPositiveInt, 0 },
	{ "action.resumeinterval", eCmdHdlrInt, 0 },
	{ "action.externalstate.file", eCmdHdlrString, 0 },
	{ "action.copymsg", eCmdHdlrBinary, 0 }
};
static struct cnfparamblk pblk =
	{ CNFPARAMBLK_VERSION,
	  sizeof(cnfparamdescr)/sizeof(struct cnfparamdescr),
	  cnfparamdescr
	};
#if 0
static const char *
batchState2String(const batch_state_t state)
{
	switch(state) {
	case BATCH_STATE_RDY:
		return "BATCH_STATE_RDY";
	case BATCH_STATE_BAD:
		return "BATCH_STATE_BAD";
	case BATCH_STATE_SUB:
		return "BATCH_STATE_SUB";
	case BATCH_STATE_COMM:
		return "BATCH_STATE_COMM";
	case BATCH_STATE_DISC:
		return "BATCH_STATE_DISC";
	default:
		return "ERROR, batch state not known!";
	}
}
#endif 
static time_t
getActNow(action_t * const pThis)
{
	assert(pThis != NULL);
	if(pThis-&gt;tActNow == -1) {
		pThis-&gt;tActNow = datetime.GetTime(NULL); 		if(pThis-&gt;tLastExec &gt; pThis-&gt;tActNow) {
			pThis-&gt;tLastExec = (time_t) 0;
		}
	}
	return pThis-&gt;tActNow;
}
static rsRetVal
actionResetQueueParams(void)
<a name="0"></a>{
	DEFiRet;
<font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>	cs.ActionQueType = QUEUETYPE_DIRECT;			cs.iActionQueueSize = 1000;				cs.iActionQueueDeqBatchSize = 16;			cs.iActionQHighWtrMark = -1;				cs.iActionQLowWtrMark = -1;				cs.iActionQDiscardMark = 980;				cs.iActionQDiscardSeverity = 8;				cs.iActionQueueNumWorkers = 1;				cs.iActionQueMaxFileSize = 1024*1024;
	cs.iActionQPersistUpdCnt = 0;				cs.bActionQSyncQeueFiles = 0;
	cs.iActionQtoQShutdown = 0;				cs.iActionQtoActShutdown = 1000;			cs.iActionQtoEnq = 50;					cs.iActionQtoWrkShutdown = 60000;			cs.iActionQWrkMinMsgs = -1;				cs.bActionQSaveOnShutdown = 1;				cs.iActionQueMaxDiskSpace = 0;
	cs.iActionQueueDeqSlowdown = 0;
	cs.iActionQueueDeqtWinFromHr = 0;
	cs.iActionQueueDeqtWinToHr = 25;		
	cs.glbliActionResumeRetryCount = 0;		
	free(cs.pszActionQFName);
	cs.pszActionQFName = NULL;			
	RETiRet;
}
rsRetVal actionDestruct(action_t * const pThis)
{
	DEFiRet;
	assert(pThis != NULL);
	if(!strcmp((char*)modGetName(pThis-&gt;pMod), "builtin:omdiscard")) {
		FINALIZE;
	}
	if(pThis-&gt;pQueue != NULL) {
		qqueueDestruct(&amp;pThis-&gt;pQueue);
	}
	if(pThis-&gt;statsobj != NULL)
		statsobj.Destruct(&amp;pThis-&gt;statsobj);
	if(pThis-&gt;pModData != NULL)
		pThis-&gt;pMod-&gt;freeInstance(pThis-&gt;pModData);
	if(pThis-&gt;fdErrFile != -1)
		close(pThis-&gt;fdErrFile);
	pthread_mutex_destroy(&amp;pThis-&gt;mutErrFile);
	pthread_mutex_destroy(&amp;pThis-&gt;mutAction);
	pthread_mutex_destroy(&amp;pThis-&gt;mutWrkrDataTable);
	free((void*)pThis-&gt;pszErrFile);
	free((void*)pThis-&gt;pszExternalStateFile);
	free(pThis-&gt;pszName);
	free(pThis-&gt;ppTpl);
	free(pThis-&gt;peParamPassing);
	free(pThis-&gt;wrkrDataTable);
finalize_it:
	free(pThis);
	RETiRet;
}
static inline void
actionDisable(action_t *__restrict__ const pThis)
{
	pThis-&gt;bDisabled = 1;
}
rsRetVal actionConstruct(action_t **ppThis)
{
	DEFiRet;
	action_t *pThis;
	assert(ppThis != NULL);
	CHKmalloc(pThis = (action_t*) calloc(1, sizeof(action_t)));
	pThis-&gt;iResumeInterval = 30;
	pThis-&gt;iResumeIntervalMax = 1800; 	pThis-&gt;iResumeRetryCount = 0;
	pThis-&gt;pszName = NULL;
	pThis-&gt;pszErrFile = NULL;
<a name="3"></a>	pThis-&gt;maxErrFileSize = 0;
	pThis-&gt;currentErrFileSize = 0;
	pThis-&gt;pszExternalStateFile = NULL;
<font color="#53858b"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>	pThis-&gt;fdErrFile = -1;
	pThis-&gt;bWriteAllMarkMsgs = 1;
	pThis-&gt;iExecEveryNthOccur = 0;
	pThis-&gt;iExecEveryNthOccurTO = 0;
	pThis-&gt;iSecsExecOnceInterval = 0;
	pThis-&gt;bExecWhenPrevSusp = 0;
	pThis-&gt;bRepMsgHasMsg = 0;
	pThis-&gt;bDisabled = 0;
	pThis-&gt;isTransactional = 0;
	pThis-&gt;bReportSuspension = -1; 	pThis-&gt;bReportSuspensionCont = -1; 	pThis-&gt;bCopyMsg = 0;</b></font>
	pThis-&gt;tLastOccur = datetime.GetTime(NULL);		pThis-&gt;iActionNbr = loadConf-&gt;actions.iActionNbr;
	pthread_mutex_init(&amp;pThis-&gt;mutErrFile, NULL);
	pthread_mutex_init(&amp;pThis-&gt;mutAction, NULL);
	pthread_mutex_init(&amp;pThis-&gt;mutWrkrDataTable, NULL);
	INIT_ATOMIC_HELPER_MUT(pThis-&gt;mutCAS);
	loadConf-&gt;actions.iActionNbr++;
finalize_it:
	*ppThis = pThis;
	RETiRet;
}
rsRetVal
actionConstructFinalize(action_t *__restrict__ const pThis, struct nvlst *lst)
{
	DEFiRet;
	uchar pszAName[64]; 
	if(!strcmp((char*)modGetName(pThis-&gt;pMod), "builtin:omdiscard")) {
		FINALIZE;
	}
	if(pThis-&gt;pszName == NULL) {
		snprintf((char*) pszAName, sizeof(pszAName), "action-%d-%s",
			pThis-&gt;iActionNbr, pThis-&gt;pMod-&gt;pszName);
		pThis-&gt;pszName = ustrdup(pszAName);
	}
	pThis-&gt;isTransactional = pThis-&gt;pMod-&gt;mod.om.supportsTX;
	if(pThis-&gt;isTransactional) {
		int i;
		for(i = 0 ; i &lt; pThis-&gt;iNumTpls ; ++i) {
			if(pThis-&gt;peParamPassing[i] != ACT_STRING_PASSING) {
				LogError(0, RS_RET_INVLD_OMOD, "action '%s'(%d) is transactional but "
						"parameter %d "
						"uses invalid parameter passing mode -- disabling "
						"action. This is probably caused by a pre-v7 "
						"output module that needs upgrade.",
						pThis-&gt;pszName, pThis-&gt;iActionNbr, i);
				actionDisable(pThis);
				ABORT_FINALIZE(RS_RET_INVLD_OMOD);
			}
		}
	}
	CHKiRet(statsobj.Construct(&amp;pThis-&gt;statsobj));
	CHKiRet(statsobj.SetName(pThis-&gt;statsobj, pThis-&gt;pszName));
	CHKiRet(statsobj.SetOrigin(pThis-&gt;statsobj, (uchar*)"core.action"));
	STATSCOUNTER_INIT(pThis-&gt;ctrProcessed, pThis-&gt;mutCtrProcessed);
	CHKiRet(statsobj.AddCounter(pThis-&gt;statsobj, UCHAR_CONSTANT("processed"),
		ctrType_IntCtr, CTR_FLAG_RESETTABLE, &amp;pThis-&gt;ctrProcessed));
	STATSCOUNTER_INIT(pThis-&gt;ctrFail, pThis-&gt;mutCtrFail);
	CHKiRet(statsobj.AddCounter(pThis-&gt;statsobj, UCHAR_CONSTANT("failed"),
		ctrType_IntCtr, CTR_FLAG_RESETTABLE, &amp;pThis-&gt;ctrFail));
	STATSCOUNTER_INIT(pThis-&gt;ctrSuspend, pThis-&gt;mutCtrSuspend);
	CHKiRet(statsobj.AddCounter(pThis-&gt;statsobj, UCHAR_CONSTANT("suspended"),
		ctrType_IntCtr, CTR_FLAG_RESETTABLE, &amp;pThis-&gt;ctrSuspend));
	STATSCOUNTER_INIT(pThis-&gt;ctrSuspendDuration, pThis-&gt;mutCtrSuspendDuration);
	CHKiRet(statsobj.AddCounter(pThis-&gt;statsobj, UCHAR_CONSTANT("suspended.duration"),
		ctrType_IntCtr, 0, &amp;pThis-&gt;ctrSuspendDuration));
	STATSCOUNTER_INIT(pThis-&gt;ctrResume, pThis-&gt;mutCtrResume);
	CHKiRet(statsobj.AddCounter(pThis-&gt;statsobj, UCHAR_CONSTANT("resumed"),
		ctrType_IntCtr, CTR_FLAG_RESETTABLE, &amp;pThis-&gt;ctrResume));
	CHKiRet(statsobj.ConstructFinalize(pThis-&gt;statsobj));
	snprintf((char*) pszAName, sizeof(pszAName), "%s queue",
		 pThis-&gt;pszName);
	if(   pThis-&gt;iExecEveryNthOccur &gt; 1
	   || pThis-&gt;iSecsExecOnceInterval
	  ) {
		DBGPRINTF("info: firehose mode disabled for action because "
		          "iExecEveryNthOccur=%d, iSecsExecOnceInterval=%d\n",
			  pThis-&gt;iExecEveryNthOccur, pThis-&gt;iSecsExecOnceInterval);
		pThis-&gt;submitToActQ = doSubmitToActionQComplex;
	} else if(pThis-&gt;bWriteAllMarkMsgs) {
		pThis-&gt;submitToActQ = doSubmitToActionQ;
	} else {
		pThis-&gt;submitToActQ = doSubmitToActionQNotAllMark;
	}
	CHKiRet(qqueueConstruct(&amp;pThis-&gt;pQueue, cs.ActionQueType, 1, cs.iActionQueueSize,
					processBatchMain));
	obj.SetName((obj_t*) pThis-&gt;pQueue, pszAName);
	qqueueSetpAction(pThis-&gt;pQueue, pThis);
	if(lst == NULL) { #		define setQPROP(func, directive, data) \
		CHKiRet_Hdlr(func(pThis-&gt;pQueue, data)) { \
			LogError(0, NO_ERRCODE, "Invalid " #directive ", \
				error %d. Ignored, running with default setting", iRet); \
		}
#		define setQPROPstr(func, directive, data) \
		CHKiRet_Hdlr(func(pThis-&gt;pQueue, data, (data == NULL)? 0 : strlen((char*) data))) { \
			LogError(0, NO_ERRCODE, "Invalid " #directive ", \
				error %d. Ignored, running with default setting", iRet); \
		}
		setQPROP(qqueueSetsizeOnDiskMax, "$ActionQueueMaxDiskSpace", cs.iActionQueMaxDiskSpace);
		setQPROP(qqueueSetiDeqBatchSize, "$ActionQueueDequeueBatchSize", cs.iActionQueueDeqBatchSize);
		setQPROP(qqueueSetMaxFileSize, "$ActionQueueFileSize", cs.iActionQueMaxFileSize);
		setQPROPstr(qqueueSetFilePrefix, "$ActionQueueFileName", cs.pszActionQFName);
		setQPROP(qqueueSetiPersistUpdCnt, "$ActionQueueCheckpointInterval", cs.iActionQPersistUpdCnt);
		setQPROP(qqueueSetbSyncQueueFiles, "$ActionQueueSyncQueueFiles", cs.bActionQSyncQeueFiles);
		setQPROP(qqueueSettoQShutdown, "$ActionQueueTimeoutShutdown", cs.iActionQtoQShutdown );
		setQPROP(qqueueSettoActShutdown, "$ActionQueueTimeoutActionCompletion", cs.iActionQtoActShutdown);
		setQPROP(qqueueSettoWrkShutdown, "$ActionQueueWorkerTimeoutThreadShutdown", cs.iActionQtoWrkShutdown);
		setQPROP(qqueueSettoEnq, "$ActionQueueTimeoutEnqueue", cs.iActionQtoEnq);
		setQPROP(qqueueSetiHighWtrMrk, "$ActionQueueHighWaterMark", cs.iActionQHighWtrMark);
		setQPROP(qqueueSetiLowWtrMrk, "$ActionQueueLowWaterMark", cs.iActionQLowWtrMark);
		setQPROP(qqueueSetiDiscardMrk, "$ActionQueueDiscardMark", cs.iActionQDiscardMark);
		setQPROP(qqueueSetiDiscardSeverity, "$ActionQueueDiscardSeverity", cs.iActionQDiscardSeverity);
		setQPROP(qqueueSetiMinMsgsPerWrkr, "$ActionQueueWorkerThreadMinimumMessages", cs.iActionQWrkMinMsgs);
		setQPROP(qqueueSetiNumWorkerThreads, "$ActionQueueWorkerThreads", cs.iActionQueueNumWorkers);
		setQPROP(qqueueSetbSaveOnShutdown, "$ActionQueueSaveOnShutdown", cs.bActionQSaveOnShutdown);
		setQPROP(qqueueSetiDeqSlowdown,    "$ActionQueueDequeueSlowdown", cs.iActionQueueDeqSlowdown);
		setQPROP(qqueueSetiDeqtWinFromHr,  "$ActionQueueDequeueTimeBegin", cs.iActionQueueDeqtWinFromHr);
		setQPROP(qqueueSetiDeqtWinToHr,    "$ActionQueueDequeueTimeEnd", cs.iActionQueueDeqtWinToHr);
	} else {
		qqueueSetDefaultsActionQueue(pThis-&gt;pQueue);
		qqueueApplyCnfParam(pThis-&gt;pQueue, lst);
	}
	qqueueCorrectParams(pThis-&gt;pQueue);
#	undef setQPROP
#	undef setQPROPstr
	qqueueDbgPrint(pThis-&gt;pQueue);
	DBGPRINTF("Action %p: queue %p created\n", pThis, pThis-&gt;pQueue);
	if(pThis-&gt;bUsesMsgPassingMode &amp;&amp; pThis-&gt;pQueue-&gt;qType != QUEUETYPE_DIRECT) {
		parser_warnmsg("module %s with message passing mode uses "
			"non-direct queue. This most probably leads to undesired "
			"results. For message modificaton modules (mm*), this means "
			"that they will have no effect - "
			"see https://www.rsyslog.com/mm-no-queue/", (char*)modGetName(pThis-&gt;pMod));
	}
	actionResetQueueParams();
finalize_it:
	RETiRet;
}
rsRetVal actionSetGlobalResumeInterval(int iNewVal)
{
	cs.glbliActionResumeInterval = iNewVal;
	return RS_RET_OK;
}
static uchar *getActStateName(action_t * const pThis, wti_t * const pWti)
{
	switch(getActionState(pWti, pThis)) {
		case ACT_STATE_RDY:
			return (uchar*) "rdy";
		case ACT_STATE_ITX:
			return (uchar*) "itx";
		case ACT_STATE_RTRY:
			return (uchar*) "rtry";
		case ACT_STATE_SUSP:
			return (uchar*) "susp";
		case ACT_STATE_DATAFAIL:
			return (uchar*) "datafail";
		default:
			return (uchar*) "ERROR/UNKNWON";
	}
}
static rsRetVal getReturnCode(action_t * const pThis, wti_t * const pWti)
{
	DEFiRet;
	switch(getActionState(pWti, pThis)) {
		case ACT_STATE_RDY:
			iRet = RS_RET_OK;
			break;
		case ACT_STATE_ITX:
			if(pWti-&gt;actWrkrInfo[pThis-&gt;iActionNbr].bHadAutoCommit) {
				pWti-&gt;actWrkrInfo[pThis-&gt;iActionNbr].bHadAutoCommit = 0; 				iRet = RS_RET_PREVIOUS_COMMITTED;
			} else {
				iRet = RS_RET_DEFER_COMMIT;
			}
			break;
		case ACT_STATE_RTRY:
			iRet = RS_RET_SUSPENDED;
			break;
		case ACT_STATE_SUSP:
			iRet = RS_RET_ACTION_FAILED;
			break;
		case ACT_STATE_DATAFAIL:
			iRet = RS_RET_DATAFAIL;
			break;
		default:
			DBGPRINTF("Invalid action engine state %u, program error\n",
				  getActionState(pWti, pThis));
			iRet = RS_RET_ERR;
			break;
	}
	RETiRet;
}
static void
actionSetState(action_t * const pThis, wti_t * const pWti, uint8_t newState)
{
	setActionState(pWti, pThis, newState);
	DBGPRINTF("action[%s] transitioned to state: %s\n",
		  pThis-&gt;pszName, getActStateName(pThis, pWti));
}
static void actionCommitted(action_t * const pThis, wti_t * const pWti)
{
	actionSetState(pThis, pWti, ACT_STATE_RDY);
}
static rsRetVal ATTR_NONNULL()
checkExternalStateFile(action_t *const pThis, wti_t *const pWti)
{
	char filebuf[1024];
	int fd = -1;
	int r;
	DEFiRet;
	DBGPRINTF("checking external state file\n");
	if(pThis-&gt;pszExternalStateFile == NULL) {
		FINALIZE;
	}
	fd = open(pThis-&gt;pszExternalStateFile, O_RDONLY|O_CLOEXEC);
	if(fd == -1) {
		dbgprintf("could not read external state file\n");
		FINALIZE;
	}
	r = read(fd, filebuf, sizeof(filebuf) - 1);
	if(r &lt; 1) {
		dbgprintf("checkExternalStateFile read() returned %d\n", r);
		FINALIZE;
	}
	filebuf[r] = '\0';
	dbgprintf("external state file content: '%s'\n", filebuf);
	for(int j = r-1 ; j &gt; 0 ; --j) {
		if(filebuf[j] == '\n' || filebuf[j] == '\t' || filebuf[j] == ' ') {
			filebuf[j] = '\0';
		} else {
			break;
		}
	}
	if(!strcmp(filebuf, "SUSPENDED")) {
		LogMsg(0, RS_RET_SUSPENDED, LOG_WARNING,
		      "action '%s' suspended (module '%s') by external state file",
		      pThis-&gt;pszName, pThis-&gt;pMod-&gt;pszName);
		actionRetry(pThis, pWti);
		ABORT_FINALIZE(RS_RET_SUSPENDED);
	}
finalize_it:
	if(fd != -1) {
		close(fd);
	}
	DBGPRINTF("done checking external state file, iRet=%d\n", iRet);
	RETiRet;
}
static void
setSuspendMessageConfVars(action_t *__restrict__ const pThis)
{
	if(pThis-&gt;bReportSuspension == -1)
		pThis-&gt;bReportSuspension = runConf-&gt;globals.bActionReportSuspension;
	if(pThis-&gt;bReportSuspensionCont == -1) {
		pThis-&gt;bReportSuspensionCont = runConf-&gt;globals.bActionReportSuspensionCont;
		if(pThis-&gt;bReportSuspensionCont == -1)
			pThis-&gt;bReportSuspensionCont = 1;
	}
}
static void ATTR_NONNULL() actionRetry(action_t * const pThis, wti_t * const pWti)
{
	setSuspendMessageConfVars(pThis);
	actionSetState(pThis, pWti, ACT_STATE_RTRY);
	if(pThis-&gt;bReportSuspension) {
		LogMsg(0, RS_RET_SUSPENDED, LOG_WARNING,
		      "action '%s' suspended (module '%s'), retry %d. There should "
		      "be messages before this one giving the reason for suspension.",
		      pThis-&gt;pszName, pThis-&gt;pMod-&gt;pszName,
		      getActionNbrResRtry(pWti, pThis));
	}
	incActionResumeInRow(pWti, pThis);
}
static void ATTR_NONNULL()
actionSuspend(action_t * const pThis, wti_t * const pWti)
{
	time_t ttNow;
	int suspendDuration;
	char timebuf[32];
	setSuspendMessageConfVars(pThis);
	datetime.GetTime(&amp;ttNow);
	suspendDuration = pThis-&gt;iResumeInterval * (getActionNbrResRtry(pWti, pThis) / 10 + 1);
	if(pThis-&gt;iResumeIntervalMax &gt; 0 &amp;&amp; suspendDuration &gt; pThis-&gt;iResumeIntervalMax) {
		suspendDuration = pThis-&gt;iResumeIntervalMax;
	}
	pThis-&gt;ttResumeRtry = ttNow + suspendDuration;
	actionSetState(pThis, pWti, ACT_STATE_SUSP);
	pThis-&gt;ctrSuspendDuration += suspendDuration;
	if(getActionNbrResRtry(pWti, pThis) == 0) {
		STATSCOUNTER_INC(pThis-&gt;ctrSuspend, pThis-&gt;mutCtrSuspend);
	}
	if(   pThis-&gt;bReportSuspensionCont
	   || (pThis-&gt;bReportSuspension &amp;&amp; getActionNbrResRtry(pWti, pThis) == 0) ) {
		ctime_r(&amp;pThis-&gt;ttResumeRtry, timebuf);
		timebuf[strlen(timebuf)-1] = '\0'; 		LogMsg(0, RS_RET_SUSPENDED, LOG_WARNING,
			      "action '%s' suspended (module '%s'), next retry is %s, retry nbr %d. "
			      "There should be messages before this one giving the reason for suspension.",
			      pThis-&gt;pszName, pThis-&gt;pMod-&gt;pszName, timebuf,
			      getActionNbrResRtry(pWti, pThis));
	}
	DBGPRINTF("action '%s' suspended, earliest retry=%lld (now %lld), iNbrResRtry %d, "
		  "duration %d\n",
		  pThis-&gt;pszName, (long long) pThis-&gt;ttResumeRtry, (long long) ttNow,
		  getActionNbrResRtry(pWti, pThis), suspendDuration);
}
static rsRetVal ATTR_NONNULL()
actionDoRetry(action_t * const pThis, wti_t * const pWti)
{
	int iRetries;
	int iSleepPeriod;
	int bTreatOKasSusp;
	DEFiRet;
	assert(pThis != NULL);
	iRetries = 0;
	while((*pWti-&gt;pbShutdownImmediate == 0) &amp;&amp; getActionState(pWti, pThis) == ACT_STATE_RTRY) {
		DBGPRINTF("actionDoRetry: %s enter loop, iRetries=%d, ResumeInRow %d\n",
			pThis-&gt;pszName, iRetries, getActionResumeInRow(pWti, pThis));
			iRet = pThis-&gt;pMod-&gt;tryResume(pWti-&gt;actWrkrInfo[pThis-&gt;iActionNbr].actWrkrData);
		DBGPRINTF("actionDoRetry: %s action-&gt;tryResume returned %d\n", pThis-&gt;pszName, iRet);
		if((getActionResumeInRow(pWti, pThis) &gt; 9) &amp;&amp; (getActionResumeInRow(pWti, pThis) % 10 == 0)) {
			bTreatOKasSusp = 1;
			setActionResumeInRow(pWti, pThis, 0);
			iRet = RS_RET_SUSPENDED;
		} else {
			bTreatOKasSusp = 0;
		}
		if((iRet == RS_RET_OK) &amp;&amp; (!bTreatOKasSusp)) {
			DBGPRINTF("actionDoRetry: %s had success RDY again (iRet=%d)\n",
				  pThis-&gt;pszName, iRet);
			STATSCOUNTER_INC(pThis-&gt;ctrResume, pThis-&gt;mutCtrResume);
			if(pThis-&gt;bReportSuspension) {
				LogMsg(0, RS_RET_RESUMED, LOG_INFO, "action '%s' "
					      "resumed (module '%s')",
					      pThis-&gt;pszName, pThis-&gt;pMod-&gt;pszName);
			}
			actionSetState(pThis, pWti, ACT_STATE_RDY);
		} else if(iRet == RS_RET_SUSPENDED || bTreatOKasSusp) {
			DBGPRINTF("actionDoRetry: %s check for max retries, iResumeRetryCount "
				  "%d, iRetries %d\n",
				  pThis-&gt;pszName, pThis-&gt;iResumeRetryCount, iRetries);
			if((pThis-&gt;iResumeRetryCount != -1 &amp;&amp; iRetries &gt;= pThis-&gt;iResumeRetryCount)) {
				actionSuspend(pThis, pWti);
				if(getActionNbrResRtry(pWti, pThis) &lt; 20)
					incActionNbrResRtry(pWti, pThis);
			} else {
				++iRetries;
				iSleepPeriod = pThis-&gt;iResumeInterval;
				srSleep(iSleepPeriod, 0);
				if(*pWti-&gt;pbShutdownImmediate) {
					ABORT_FINALIZE(RS_RET_FORCE_TERM);
				}
			}
		} else if(iRet == RS_RET_DISABLE_ACTION) {
			actionDisable(pThis);
		}
	}
	if(getActionState(pWti, pThis) == ACT_STATE_RDY) {
		setActionNbrResRtry(pWti, pThis, 0);
	}
finalize_it:
	RETiRet;
}
static rsRetVal ATTR_NONNULL()
actionDoRetry_extFile(action_t *const pThis, wti_t *const pWti)
{
	int iRetries;
	int iSleepPeriod;
	DEFiRet;
	assert(pThis != NULL);
	DBGPRINTF("actionDoRetry_extFile: enter, actionState: %d\n",getActionState(pWti, pThis));
	iRetries = 0;
	while((*pWti-&gt;pbShutdownImmediate == 0) &amp;&amp; getActionState(pWti, pThis) == ACT_STATE_RTRY) {
		DBGPRINTF("actionDoRetry_extFile: %s enter loop, iRetries=%d, ResumeInRow %d\n",
			pThis-&gt;pszName, iRetries, getActionResumeInRow(pWti, pThis));
			iRet = checkExternalStateFile(pThis, pWti);
		DBGPRINTF("actionDoRetry_extFile: %s checkExternalStateFile returned %d\n", pThis-&gt;pszName, iRet);
		if(iRet == RS_RET_OK) {
			DBGPRINTF("actionDoRetry_extFile: %s had success RDY again (iRet=%d)\n",
				  pThis-&gt;pszName, iRet);
			if(pThis-&gt;bReportSuspension) {
				LogMsg(0, RS_RET_RESUMED, LOG_INFO, "action '%s' "
				      "resumed (module '%s') via external state file",
				      pThis-&gt;pszName, pThis-&gt;pMod-&gt;pszName);
			}
			actionSetState(pThis, pWti, ACT_STATE_RDY);
		} else if(iRet == RS_RET_SUSPENDED) {
			DBGPRINTF("actionDoRetry_extFile: %s check for max retries, iResumeRetryCount "
				  "%d, iRetries %d\n",
				  pThis-&gt;pszName, pThis-&gt;iResumeRetryCount, iRetries);
			if((pThis-&gt;iResumeRetryCount != -1 &amp;&amp; iRetries &gt;= pThis-&gt;iResumeRetryCount)) {
				DBGPRINTF("actionDoRetry_extFile: did not work out, suspending\n");
				actionSuspend(pThis, pWti);
				pWti-&gt;execState.bPrevWasSuspended = 1;
				if(getActionNbrResRtry(pWti, pThis) &lt; 20)
					incActionNbrResRtry(pWti, pThis);
			} else {
				++iRetries;
				iSleepPeriod = pThis-&gt;iResumeInterval;
				srSleep(iSleepPeriod, 0);
				if(*pWti-&gt;pbShutdownImmediate) {
					ABORT_FINALIZE(RS_RET_FORCE_TERM);
				}
			}
		} else if(iRet == RS_RET_DISABLE_ACTION) {
			actionDisable(pThis);
		}
	}
	if(getActionState(pWti, pThis) == ACT_STATE_RDY) {
		setActionNbrResRtry(pWti, pThis, 0);
	}
finalize_it:
	RETiRet;
}
static rsRetVal
actionCheckAndCreateWrkrInstance(action_t * const pThis, const wti_t *const pWti)
{
	int locked = 0;
	DEFiRet;
	if(pWti-&gt;actWrkrInfo[pThis-&gt;iActionNbr].actWrkrData == NULL) {
		DBGPRINTF("wti %p: we need to create a new action worker instance for "
			  "action %d\n", pWti, pThis-&gt;iActionNbr);
		CHKiRet(pThis-&gt;pMod-&gt;mod.om.createWrkrInstance(&amp;(pWti-&gt;actWrkrInfo[pThis-&gt;iActionNbr].actWrkrData),
						               pThis-&gt;pModData));
		pWti-&gt;actWrkrInfo[pThis-&gt;iActionNbr].pAction = pThis;
		setActionState(pWti, pThis, ACT_STATE_RDY); 
		pthread_mutex_lock(&amp;pThis-&gt;mutWrkrDataTable);
		locked = 1;
		int freeSpot;
		for(freeSpot = 0 ; freeSpot &lt; pThis-&gt;wrkrDataTableSize ; ++freeSpot)
			if(pThis-&gt;wrkrDataTable[freeSpot] == NULL)
				break;
		if(pThis-&gt;nWrkr == pThis-&gt;wrkrDataTableSize) {
			void *const newTable = realloc(pThis-&gt;wrkrDataTable,
				(pThis-&gt;wrkrDataTableSize + 1) * sizeof(void*));
			if(newTable == NULL) {
				DBGPRINTF("actionCheckAndCreateWrkrInstance: out of "
					"memory realloc wrkrDataTable\n")
				ABORT_FINALIZE(RS_RET_OUT_OF_MEMORY);
			}
			pThis-&gt;wrkrDataTable = newTable;
			pThis-&gt;wrkrDataTableSize++;
		}
		pThis-&gt;wrkrDataTable[freeSpot] = pWti-&gt;actWrkrInfo[pThis-&gt;iActionNbr].actWrkrData;
		pThis-&gt;nWrkr++;
		DBGPRINTF("wti %p: created action worker instance %d for "
			  "action %d\n", pWti, pThis-&gt;nWrkr, pThis-&gt;iActionNbr);
	}
finalize_it:
	if(locked) {
		pthread_mutex_unlock(&amp;pThis-&gt;mutWrkrDataTable);
	}
	RETiRet;
}
static rsRetVal
actionTryResume(action_t * const pThis, wti_t * const pWti)
{
	DEFiRet;
	time_t ttNow = NO_TIME_PROVIDED;
	if(getActionState(pWti, pThis) == ACT_STATE_SUSP) {
		datetime.GetTime(&amp;ttNow); 		if(ttNow &gt;= pThis-&gt;ttResumeRtry) {
			actionSetState(pThis, pWti, ACT_STATE_RTRY); 		}
	}
	if(getActionState(pWti, pThis) == ACT_STATE_RTRY) {
		CHKiRet(actionDoRetry(pThis, pWti));
	}
	if(Debug &amp;&amp; (getActionState(pWti, pThis) == ACT_STATE_RTRY ||
		getActionState(pWti, pThis) == ACT_STATE_SUSP)) {
		if(ttNow == NO_TIME_PROVIDED) 			datetime.GetTime(&amp;ttNow);
		dbgprintf("actionTryResume: action[%s] state: %s, next retry (if applicable): %u [now %u]\n",
			pThis-&gt;pszName, getActStateName(pThis, pWti),
			(unsigned) pThis-&gt;ttResumeRtry, (unsigned) ttNow);
	}
finalize_it:
	RETiRet;
}
static rsRetVal ATTR_NONNULL()
actionPrepare(action_t *__restrict__ const pThis, wti_t *__restrict__ const pWti)
{
	DEFiRet;
DBGPRINTF("actionPrepare[%s]: enter\n", pThis-&gt;pszName);
	CHKiRet(actionCheckAndCreateWrkrInstance(pThis, pWti));
	CHKiRet(actionTryResume(pThis, pWti));
	if(getActionState(pWti, pThis) == ACT_STATE_RDY) {
		iRet = checkExternalStateFile(pThis, pWti);
		if(iRet == RS_RET_SUSPENDED) {
			DBGPRINTF("actionPrepare[%s]: SUSPENDED via external state file, "
				"doing retry processing\n", pThis-&gt;pszName);
			CHKiRet(actionDoRetry_extFile(pThis, pWti));
		}
		iRet = pThis-&gt;pMod-&gt;mod.om.beginTransaction(pWti-&gt;actWrkrInfo[pThis-&gt;iActionNbr].actWrkrData);
		switch(iRet) {
			case RS_RET_OK:
				actionSetState(pThis, pWti, ACT_STATE_ITX);
				break;
			case RS_RET_SUSPENDED:
				actionRetry(pThis, pWti);
				break;
			case RS_RET_DISABLE_ACTION:
				actionDisable(pThis);
				break;
			default:FINALIZE;
		}
	}
finalize_it:
	RETiRet;
}
static rsRetVal
prepareDoActionParams(action_t * __restrict__ const pAction,
		      wti_t * __restrict__ const pWti,
		      smsg_t *__restrict__ const pMsg,
		      struct syslogTime *ttNow)
{
	int i;
	struct json_object *json;
	actWrkrIParams_t *iparams;
	actWrkrInfo_t *__restrict__ pWrkrInfo;
	DEFiRet;
	pWrkrInfo = &amp;(pWti-&gt;actWrkrInfo[pAction-&gt;iActionNbr]);
	if(pAction-&gt;isTransactional) {
		CHKiRet(wtiNewIParam(pWti, pAction, &amp;iparams));
		for(i = 0 ; i &lt; pAction-&gt;iNumTpls ; ++i) {
			CHKiRet(tplToString(pAction-&gt;ppTpl[i], pMsg,
					    &amp;actParam(iparams, pAction-&gt;iNumTpls, 0, i),
				            ttNow));
		}
	} else {
		for(i = 0 ; i &lt; pAction-&gt;iNumTpls ; ++i) {
			switch(pAction-&gt;peParamPassing[i]) {
			case ACT_STRING_PASSING:
				CHKiRet(tplToString(pAction-&gt;ppTpl[i], pMsg,
					   &amp;(pWrkrInfo-&gt;p.nontx.actParams[i]),
					   ttNow));
				break;
			case ACT_MSG_PASSING:
				pWrkrInfo-&gt;p.nontx.actParams[i].param = (void*) pMsg;
				break;
			case ACT_JSON_PASSING:
				CHKiRet(tplToJSON(pAction-&gt;ppTpl[i], pMsg, &amp;json, ttNow));
				pWrkrInfo-&gt;p.nontx.actParams[i].param = (void*) json;
				break;
			default:dbgprintf("software bug/error: unknown "
				"pAction-&gt;peParamPassing[%d] %d in prepareDoActionParams\n",
					  i, (int) pAction-&gt;peParamPassing[i]);
				break;
			}
		}
	}
finalize_it:
	RETiRet;
}
void
releaseDoActionParams(action_t *__restrict__ const pAction, wti_t *__restrict__ const pWti, int action_destruct)
{
	int j;
	actWrkrInfo_t *__restrict__ pWrkrInfo;
	pWrkrInfo = &amp;(pWti-&gt;actWrkrInfo[pAction-&gt;iActionNbr]);
	for(j = 0 ; j &lt; pAction-&gt;iNumTpls ; ++j) {
		if (action_destruct) {
			if (ACT_STRING_PASSING == pAction-&gt;peParamPassing[j]) {
				free(pWrkrInfo-&gt;p.nontx.actParams[j].param);
				pWrkrInfo-&gt;p.nontx.actParams[j].param = NULL;
				pWrkrInfo-&gt;p.nontx.actParams[j].lenBuf = 0;
				pWrkrInfo-&gt;p.nontx.actParams[j].lenStr = 0;
			}
		} else {
			switch(pAction-&gt;peParamPassing[j]) {
			case ACT_ARRAY_PASSING:
				LogError(0, RS_RET_ERR, "plugin error: no longer supported "
					"ARRAY_PASSING mode is used (see action.c)");
				return;
			case ACT_JSON_PASSING:
				json_object_put((struct json_object*)
								pWrkrInfo-&gt;p.nontx.actParams[j].param);
				pWrkrInfo-&gt;p.nontx.actParams[j].param = NULL;
				pWrkrInfo-&gt;p.nontx.actParams[j].lenBuf = 0;
				pWrkrInfo-&gt;p.nontx.actParams[j].lenStr = 0;
				break;
			case ACT_STRING_PASSING:
			case ACT_MSG_PASSING:
				break;
			}
		}
	}
	return;
}
static void
actionSetActionWorked(action_t *__restrict__ const pThis, wti_t *__restrict__ const pWti)
{
	setActionResumeInRow(pWti, pThis, 0);
}
static rsRetVal
handleActionExecResult(action_t *__restrict__ const pThis,
	wti_t *__restrict__ const pWti,
	const rsRetVal ret)
{
	DEFiRet;
	switch(ret) {
		case RS_RET_OK:
			actionCommitted(pThis, pWti);
			actionSetActionWorked(pThis, pWti); 			break;
		case RS_RET_DEFER_COMMIT:
			actionSetActionWorked(pThis, pWti); 			break;
		case RS_RET_PREVIOUS_COMMITTED:
			pWti-&gt;actWrkrInfo[pThis-&gt;iActionNbr].bHadAutoCommit = 1;
			actionSetActionWorked(pThis, pWti); 			break;
		case RS_RET_DISABLE_ACTION:
			actionDisable(pThis);
			break;
		case RS_RET_SUSPENDED:
			actionRetry(pThis, pWti);
			break;
			LogError(0, ret, "action '%s' (module '%s') "
				"message lost, could not be processed. Check for "
				"additional error messages before this one.",
				pThis-&gt;pszName, pThis-&gt;pMod-&gt;pszName);
			actionSetState(pThis, pWti, ACT_STATE_DATAFAIL);
			break;
	}
	iRet = getReturnCode(pThis, pWti);
	RETiRet;
}
static rsRetVal
actionCallDoAction(action_t *__restrict__ const pThis,
	actWrkrIParams_t *__restrict__ const iparams,
	wti_t *__restrict__ const pWti)
{
	void *param[CONF_OMOD_NUMSTRINGS_MAXSIZE];
	int i;
	DEFiRet;
	DBGPRINTF("entering actionCalldoAction(), state: %s, actionNbr %d\n",
		  getActStateName(pThis, pWti), pThis-&gt;iActionNbr);
	pWti-&gt;actWrkrInfo[pThis-&gt;iActionNbr].bHadAutoCommit = 0;
	for(i = 0 ; i &lt; pThis-&gt;iNumTpls ; ++i) {
		param[i] = actParam(iparams, pThis-&gt;iNumTpls, 0, i).param;
	}
	iRet = pThis-&gt;pMod-&gt;mod.om.doAction(param,
				            pWti-&gt;actWrkrInfo[pThis-&gt;iActionNbr].actWrkrData);
	iRet = handleActionExecResult(pThis, pWti, iRet);
	RETiRet;
}
static rsRetVal ATTR_NONNULL()
actionCallCommitTransaction(action_t * const pThis,
	wti_t *const pWti,
	actWrkrIParams_t *__restrict__ const iparams, const int nparams)
{
	DEFiRet;
	DBGPRINTF("entering actionCallCommitTransaction[%s], state: %s, nMsgs %u\n",
		  pThis-&gt;pszName, getActStateName(pThis, pWti), nparams);
	iRet = pThis-&gt;pMod-&gt;mod.om.commitTransaction(
		    pWti-&gt;actWrkrInfo[pThis-&gt;iActionNbr].actWrkrData,
		    iparams, nparams);
	DBGPRINTF("actionCallCommitTransaction[%s] state: %s "
		"mod commitTransaction returned %d\n",
		pThis-&gt;pszName, getActStateName(pThis, pWti), iRet);
	iRet = handleActionExecResult(pThis, pWti, iRet);
	RETiRet;
}
static rsRetVal
actionProcessMessage(action_t * const pThis, void *actParams, wti_t * const pWti)
{
	DEFiRet;
	CHKiRet(actionPrepare(pThis, pWti));
	if(pThis-&gt;pMod-&gt;mod.om.SetShutdownImmdtPtr != NULL)
		pThis-&gt;pMod-&gt;mod.om.SetShutdownImmdtPtr(pThis-&gt;pModData, pWti-&gt;pbShutdownImmediate);
	if(getActionState(pWti, pThis) == ACT_STATE_ITX)
		CHKiRet(actionCallDoAction(pThis, actParams, pWti));
	iRet = getReturnCode(pThis, pWti);
finalize_it:
	RETiRet;
}
static rsRetVal
doTransaction(action_t *__restrict__ const pThis, wti_t *__restrict__ const pWti,
	actWrkrIParams_t *__restrict__ const iparams, const int nparams)
{
	actWrkrInfo_t *wrkrInfo;
	int i;
	DEFiRet;
	wrkrInfo = &amp;(pWti-&gt;actWrkrInfo[pThis-&gt;iActionNbr]);
	if(pThis-&gt;pMod-&gt;mod.om.commitTransaction != NULL) {
		DBGPRINTF("doTransaction: have commitTransaction IF, using that, pWrkrInfo %p\n", wrkrInfo);
		CHKiRet(actionCallCommitTransaction(pThis, pWti, iparams, nparams));
	} else { 		DBGPRINTF("doTransaction: action '%s', currIParam %d\n",
			   pThis-&gt;pszName, wrkrInfo-&gt;p.tx.currIParam);
		for(i = 0 ; i &lt; nparams ; ++i) {
			iRet = actionProcessMessage(pThis,
				&amp;actParam(iparams, pThis-&gt;iNumTpls, i, 0), pWti);
			DBGPRINTF("doTransaction: action %d, processing msg %d, result %d\n",
			   pThis-&gt;iActionNbr, i,iRet);
			if(iRet == RS_RET_SUSPENDED) {
				srSleep(1, 0);
			} else if(iRet != RS_RET_DEFER_COMMIT &amp;&amp; iRet != RS_RET_PREVIOUS_COMMITTED &amp;&amp;
			   iRet != RS_RET_OK) {
				FINALIZE; 			}
		}
	}
finalize_it:
	if(iRet == RS_RET_DEFER_COMMIT || iRet == RS_RET_PREVIOUS_COMMITTED)
		iRet = RS_RET_OK; 	RETiRet;
}
static rsRetVal ATTR_NONNULL()
actionTryCommit(action_t *__restrict__ const pThis, wti_t *__restrict__ const pWti,
	actWrkrIParams_t *__restrict__ const iparams, const int nparams)
{
	DEFiRet;
	DBGPRINTF("actionTryCommit[%s] enter\n", pThis-&gt;pszName);
	CHKiRet(actionPrepare(pThis, pWti));
	CHKiRet(doTransaction(pThis, pWti, iparams, nparams));
	if(getActionState(pWti, pThis) == ACT_STATE_ITX) {
		iRet = pThis-&gt;pMod-&gt;mod.om.endTransaction(pWti-&gt;actWrkrInfo[pThis-&gt;iActionNbr].actWrkrData);
		switch(iRet) {
			case RS_RET_OK:
				actionCommitted(pThis, pWti);
				break;
			case RS_RET_SUSPENDED:
				actionRetry(pThis, pWti);
				break;
			case RS_RET_DISABLE_ACTION:
				actionDisable(pThis);
				break;
			case RS_RET_DEFER_COMMIT:
				DBGPRINTF("output plugin error: endTransaction() returns RS_RET_DEFER_COMMIT "
					  "- ignored\n");
				actionCommitted(pThis, pWti);
				break;
			case RS_RET_PREVIOUS_COMMITTED:
				DBGPRINTF("output plugin error: endTransaction() returns RS_RET_PREVIOUS_COMMITTED "
					  "- ignored\n");
				actionCommitted(pThis, pWti);
				break;
				DBGPRINTF("action[%s]: actionTryCommit receveived iRet %d\n",
					pThis-&gt;pszName, iRet);
				FINALIZE;
		}
	}
	iRet = getReturnCode(pThis, pWti);
finalize_it:
	RETiRet;
}
static void ATTR_NONNULL()
actionWriteErrorFile(action_t *__restrict__ const pThis, const rsRetVal ret,
	actWrkrIParams_t *__restrict__ const iparams, const int nparams)
{
	fjson_object *etry=NULL;
	int bNeedUnlock = 0;
	STATSCOUNTER_INC(pThis-&gt;ctrFail, pThis-&gt;mutCtrFail);
	if(pThis-&gt;pszErrFile == NULL) {
		DBGPRINTF("action %s: commit failed, no error file set, silently "
			"discarding %d messages\n", pThis-&gt;pszName, nparams);
		goto done;
	}
	DBGPRINTF("action %d commit failed, writing %u messages (%d tpls) to error file\n",
		pThis-&gt;iActionNbr, nparams, pThis-&gt;iNumTpls);
	pthread_mutex_lock(&amp;pThis-&gt;mutErrFile);
	bNeedUnlock = 1;
	if(pThis-&gt;fdErrFile == -1) {
		pThis-&gt;fdErrFile = open(pThis-&gt;pszErrFile,
					O_WRONLY|O_CREAT|O_APPEND|O_LARGEFILE|O_CLOEXEC,
					S_IRUSR|S_IWUSR|S_IRGRP|S_IWGRP);
		if(pThis-&gt;fdErrFile == -1) {
			LogError(errno, RS_RET_ERR, "action %s: error opening error file %s",
				pThis-&gt;pszName, pThis-&gt;pszErrFile);
			goto done;
		}
		if (pThis-&gt;maxErrFileSize &gt; 0) {
			struct stat statbuf;
			if (fstat(pThis-&gt;fdErrFile, &amp;statbuf) == -1) {
				LogError(errno, RS_RET_ERR, "failed to fstat %s", pThis-&gt;pszErrFile);
				goto done;
			}
			pThis-&gt;currentErrFileSize = statbuf.st_size;
		}
	}
	for(int i = 0 ; i &lt; nparams ; ++i) {
		if((etry = fjson_object_new_object()) == NULL)
			goto done;
		fjson_object_object_add(etry, "action", fjson_object_new_string((char*)pThis-&gt;pszName));
		fjson_object_object_add(etry, "status", fjson_object_new_int(ret));
		for(int j = 0 ; j &lt; pThis-&gt;iNumTpls ; ++j) {
			char tplname[20];
			snprintf(tplname, sizeof(tplname), "template%d", j);
			tplname[sizeof(tplname)-1] = '\0';
			fjson_object_object_add(etry, tplname,
				fjson_object_new_string((char*)actParam(iparams, 1, i, j).param));
		}
		char *const rendered = strdup((char*)fjson_object_to_json_string(etry));
		if(rendered == NULL)
			goto done;
		size_t toWrite = strlen(rendered) + 1;
		if (pThis-&gt;maxErrFileSize &gt; 0) {
			if (pThis-&gt;currentErrFileSize + toWrite &gt; pThis-&gt;maxErrFileSize) {
				toWrite = pThis-&gt;maxErrFileSize - pThis-&gt;currentErrFileSize;
			}
			pThis-&gt;currentErrFileSize += toWrite;
		}
		if(toWrite &gt; 0) {
			rendered[toWrite-1] = '\n'; 			const ssize_t wrRet = write(pThis-&gt;fdErrFile, rendered, toWrite);
			if(wrRet != (ssize_t) toWrite) {
				LogError(errno, RS_RET_IO_ERROR,
					"action %s: error writing errorFile %s, write returned %lld",
					pThis-&gt;pszName, pThis-&gt;pszErrFile, (long long) wrRet);
			}
		}
		free(rendered);
		fjson_object_put(etry);
		etry = NULL;
	}
done:
	if(bNeedUnlock) {
		pthread_mutex_unlock(&amp;pThis-&gt;mutErrFile);
	}
	fjson_object_put(etry);
	return;
}
static rsRetVal
actionTryRemoveHardErrorsFromBatch(action_t *__restrict__ const pThis, wti_t *__restrict__ const pWti,
	actWrkrIParams_t *const new_iparams, unsigned *new_nMsgs)
{
	actWrkrInfo_t *const wrkrInfo = &amp;(pWti-&gt;actWrkrInfo[pThis-&gt;iActionNbr]);
	const unsigned nMsgs = wrkrInfo-&gt;p.tx.currIParam;
	actWrkrIParams_t oneParamSet[CONF_OMOD_NUMSTRINGS_MAXSIZE];
	rsRetVal ret;
	DEFiRet;
	*new_nMsgs = 0;
	for(unsigned i = 0 ; i &lt; nMsgs ; ++i) {
		setActionResumeInRow(pWti, pThis, 0); 		memcpy(&amp;oneParamSet, &amp;actParam(wrkrInfo-&gt;p.tx.iparams, pThis-&gt;iNumTpls, i, 0),
			sizeof(actWrkrIParams_t) * pThis-&gt;iNumTpls);
		ret = actionTryCommit(pThis, pWti, oneParamSet, 1);
		if(ret == RS_RET_SUSPENDED) {
			memcpy(new_iparams + (*new_nMsgs * pThis-&gt;iNumTpls), &amp;oneParamSet,
				sizeof(actWrkrIParams_t) * pThis-&gt;iNumTpls);
			++(*new_nMsgs);
		} else if(ret != RS_RET_OK) {
			actionWriteErrorFile(pThis, ret, oneParamSet, 1);
		}
	}
	RETiRet;
}
static rsRetVal ATTR_NONNULL()
actionCommit(action_t *__restrict__ const pThis, wti_t *__restrict__ const pWti)
{
	actWrkrInfo_t *const wrkrInfo = &amp;(pWti-&gt;actWrkrInfo[pThis-&gt;iActionNbr]);
	unsigned nMsgs = 0;
	actWrkrIParams_t *iparams = NULL;
	int needfree_iparams = 0; 	DEFiRet;
	DBGPRINTF("actionCommit[%s]: enter, %d msgs\n", pThis-&gt;pszName, wrkrInfo-&gt;p.tx.currIParam);
	if(!pThis-&gt;isTransactional || pWti-&gt;actWrkrInfo[pThis-&gt;iActionNbr].p.tx.currIParam == 0) {
		FINALIZE;
	} else if(getActionState(pWti, pThis) == ACT_STATE_SUSP) {
		actionWriteErrorFile(pThis, iRet, wrkrInfo-&gt;p.tx.iparams, wrkrInfo-&gt;p.tx.currIParam);
		FINALIZE;
	}
	DBGPRINTF("actionCommit[%s]: processing...\n", pThis-&gt;pszName);
	iRet = actionTryCommit(pThis, pWti, wrkrInfo-&gt;p.tx.iparams, wrkrInfo-&gt;p.tx.currIParam);
DBGPRINTF("actionCommit[%s]: return actionTryCommit %d\n", pThis-&gt;pszName, iRet);
	if(iRet == RS_RET_OK) {
		FINALIZE;
	}
	if(wrkrInfo-&gt;p.tx.currIParam == 1) {
		needfree_iparams = 0;
		iparams = wrkrInfo-&gt;p.tx.iparams;
		nMsgs = wrkrInfo-&gt;p.tx.currIParam;
		if(iRet == RS_RET_DATAFAIL) {
			FINALIZE;
		}
	} else {
		DBGPRINTF("actionCommit[%s]: somewhat unhappy, full batch of %d msgs returned "
			"status %d. Trying messages as individual actions.\n",
			pThis-&gt;pszName, wrkrInfo-&gt;p.tx.currIParam, iRet);
		CHKmalloc(iparams = malloc(sizeof(actWrkrIParams_t) * pThis-&gt;iNumTpls
			* wrkrInfo-&gt;p.tx.currIParam));
		needfree_iparams = 1;
		actionTryRemoveHardErrorsFromBatch(pThis, pWti, iparams, &amp;nMsgs);
	}
	if(nMsgs == 0) {
		ABORT_FINALIZE(RS_RET_OK); 	}
	DBGPRINTF("actionCommit[%s]: unhappy, we still have %d uncommitted messages.\n",
		pThis-&gt;pszName, nMsgs);
	int bDone = 0;
	do {
		iRet = actionTryCommit(pThis, pWti, iparams, nMsgs);
		DBGPRINTF("actionCommit[%s]: in retry loop, iRet %d\n",
			pThis-&gt;pszName, iRet);
		if(iRet == RS_RET_FORCE_TERM) {
			ABORT_FINALIZE(RS_RET_FORCE_TERM);
		} else if(iRet == RS_RET_SUSPENDED) {
			iRet = actionDoRetry(pThis, pWti);
			DBGPRINTF("actionCommit[%s]: actionDoRetry returned %d\n",
				pThis-&gt;pszName, iRet);
			if(iRet == RS_RET_FORCE_TERM) {
				ABORT_FINALIZE(RS_RET_FORCE_TERM);
			} else if(iRet != RS_RET_OK) {
				actionWriteErrorFile(pThis, iRet, iparams, nMsgs);
				bDone = 1;
			}
			continue;
		} else if(iRet == RS_RET_OK ||
		          iRet == RS_RET_SUSPENDED ||
			  iRet == RS_RET_ACTION_FAILED) {
			bDone = 1;
		}
		if(getActionState(pWti, pThis) == ACT_STATE_RDY  ||
		   getActionState(pWti, pThis) == ACT_STATE_SUSP) {
			bDone = 1;
		}
	} while(!bDone);
finalize_it:
	DBGPRINTF("actionCommit[%s]: done, iRet %d\n", pThis-&gt;pszName, iRet);
	if(needfree_iparams) {
		free(iparams);
	}
	wrkrInfo-&gt;p.tx.currIParam = 0; 	RETiRet;
}
void ATTR_NONNULL()
actionCommitAllDirect(wti_t *__restrict__ const pWti)
{
	int i;
	action_t *pAction;
	for(i = 0 ; i &lt; runConf-&gt;actions.iActionNbr ; ++i) {
		pAction = pWti-&gt;actWrkrInfo[i].pAction;
		if(pAction == NULL)
			continue;
		DBGPRINTF("actionCommitAllDirect: action %d, state %u, nbr to commit %d "
			  "isTransactional %d\n",
			  i, getActionStateByNbr(pWti, i), pWti-&gt;actWrkrInfo-&gt;p.tx.currIParam,
			  pAction-&gt;isTransactional);
		if(pAction-&gt;pQueue-&gt;qType == QUEUETYPE_DIRECT)
			actionCommit(pAction, pWti);
	}
}
static rsRetVal
processMsgMain(action_t *__restrict__ const pAction,
	wti_t *__restrict__ const pWti,
	smsg_t *__restrict__ const pMsg,
	struct syslogTime *ttNow)
{
	DEFiRet;
	CHKiRet(prepareDoActionParams(pAction, pWti, pMsg, ttNow));
	if(pAction-&gt;isTransactional) {
		pWti-&gt;actWrkrInfo[pAction-&gt;iActionNbr].pAction = pAction;
		DBGPRINTF("action '%s': is transactional - executing in commit phase\n", pAction-&gt;pszName);
		actionPrepare(pAction, pWti);
		iRet = getReturnCode(pAction, pWti);
		FINALIZE;
	}
	iRet = actionProcessMessage(pAction,
				    pWti-&gt;actWrkrInfo[pAction-&gt;iActionNbr].p.nontx.actParams,
				    pWti);
	if(pAction-&gt;bNeedReleaseBatch)
		releaseDoActionParams(pAction, pWti, 0);
finalize_it:
	if(iRet == RS_RET_OK) {
		if(pWti-&gt;execState.bDoAutoCommit)
			iRet = actionCommit(pAction, pWti);
	}
	RETiRet;
}
static rsRetVal ATTR_NONNULL()
processBatchMain(void *__restrict__ const pVoid,
	batch_t *__restrict__ const pBatch,
	wti_t *__restrict__ const pWti)
{
	action_t *__restrict__ const pAction = (action_t*__restrict__ const) pVoid;
	int i;
	struct syslogTime ttNow;
	DEFiRet;
	wtiResetExecState(pWti, pBatch);
	ttNow.year = 0;
	for(i = 0 ; i &lt; batchNumMsgs(pBatch) &amp;&amp; !*pWti-&gt;pbShutdownImmediate ; ++i) {
		if(batchIsValidElem(pBatch, i)) {
			rsRetVal localRet = processMsgMain(pAction, pWti, pBatch-&gt;pElem[i].pMsg, &amp;ttNow);
			DBGPRINTF("processBatchMain: i %d, processMsgMain iRet %d\n", i, localRet);
			if(   localRet == RS_RET_OK
			   || localRet == RS_RET_DEFER_COMMIT
			   || localRet == RS_RET_ACTION_FAILED
			   || localRet == RS_RET_PREVIOUS_COMMITTED ) {
				batchSetElemState(pBatch, i, BATCH_STATE_COMM);
				DBGPRINTF("processBatchMain: i %d, COMM state set\n", i);
			}
		}
	}
	iRet = actionCommit(pAction, pWti);
	RETiRet;
}
void
actionRemoveWorker(action_t *const __restrict__ pAction,
	void *const __restrict__ actWrkrData)
{
	pthread_mutex_lock(&amp;pAction-&gt;mutWrkrDataTable);
	pAction-&gt;nWrkr--;
	for(int w = 0 ; w &lt; pAction-&gt;wrkrDataTableSize ; ++w) {
		if(pAction-&gt;wrkrDataTable[w] == actWrkrData) {
			pAction-&gt;wrkrDataTable[w] = NULL;
			break; 		}
	}
	pthread_mutex_unlock(&amp;pAction-&gt;mutWrkrDataTable);
}
rsRetVal
actionCallHUPHdlr(action_t * const pAction)
{
	DEFiRet;
	assert(pAction != NULL);
	DBGPRINTF("Action %p checks HUP hdlr, act level: %p, wrkr level %p\n",
		pAction, pAction-&gt;pMod-&gt;doHUP, pAction-&gt;pMod-&gt;doHUPWrkr);
	if(pAction-&gt;pMod-&gt;doHUP != NULL) {
		CHKiRet(pAction-&gt;pMod-&gt;doHUP(pAction-&gt;pModData));
	}
	if(pAction-&gt;pMod-&gt;doHUPWrkr != NULL) {
		pthread_mutex_lock(&amp;pAction-&gt;mutWrkrDataTable);
		for(int i = 0 ; i &lt; pAction-&gt;wrkrDataTableSize ; ++i) {
			dbgprintf("HUP: table entry %d: %p %s\n", i,
				pAction-&gt;wrkrDataTable[i],
				pAction-&gt;wrkrDataTable[i] == NULL ? "[unused]" : "");
			if(pAction-&gt;wrkrDataTable[i] != NULL) {
				const rsRetVal localRet
					= pAction-&gt;pMod-&gt;doHUPWrkr(pAction-&gt;wrkrDataTable[i]);
				if(localRet != RS_RET_OK) {
					DBGPRINTF("HUP handler returned error state %d - "
						  "ignored\n", localRet);
				}
			}
		}
		pthread_mutex_unlock(&amp;pAction-&gt;mutWrkrDataTable);
	}
finalize_it:
	RETiRet;
}
static rsRetVal setActionQueType(void __attribute__((unused)) *pVal, uchar *pszType)
<a name="1"></a>{
	DEFiRet;
<font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>	if (!strcasecmp((char *) pszType, "fixedarray")) {
		cs.ActionQueType = QUEUETYPE_FIXED_ARRAY;
		DBGPRINTF("action queue type set to FIXED_ARRAY\n");
	} else if (!strcasecmp((char *) pszType, "linkedlist")) {
		cs.ActionQueType = QUEUETYPE_LINKEDLIST;
		DBGPRINTF("action queue type set to LINKEDLIST\n");
	} else if (!strcasecmp((char *) pszType, "disk")) {
		cs.ActionQueType = QUEUETYPE_DISK;
		DBGPRINTF("action queue type set to DISK\n");
	} else if (!strcasecmp((char *) pszType, "direct")) {
		cs.ActionQueType = QUEUETYPE_DIRECT;
		DBGPRINTF("action queue type set to DIRECT (no queueing at all)\n");
	} else {</b></font>
		LogError(0, RS_RET_INVALID_PARAMS, "unknown actionqueue parameter: %s", (char *) pszType);
		iRet = RS_RET_INVALID_PARAMS;
	}
	free(pszType); 
	RETiRet;
}
static rsRetVal ATTR_NONNULL()
doSubmitToActionQ(action_t * const pAction, wti_t * const pWti, smsg_t *pMsg)
{
	struct syslogTime ttNow; 	DEFiRet;
	DBGPRINTF("action '%s': called, logging to %s (susp %d/%d, direct q %d)\n",
		pAction-&gt;pszName, module.GetStateName(pAction-&gt;pMod),
		pAction-&gt;bExecWhenPrevSusp, pWti-&gt;execState.bPrevWasSuspended,
		pAction-&gt;pQueue-&gt;qType == QUEUETYPE_DIRECT);
	if(   pAction-&gt;bExecWhenPrevSusp
	   &amp;&amp; !pWti-&gt;execState.bPrevWasSuspended) {
		DBGPRINTF("action '%s': NOT executing, as previous action was "
			  "not suspended\n", pAction-&gt;pszName);
		FINALIZE;
	}
	STATSCOUNTER_INC(pAction-&gt;ctrProcessed, pAction-&gt;mutCtrProcessed);
	if(pAction-&gt;pQueue-&gt;qType == QUEUETYPE_DIRECT) {
		ttNow.year = 0;
		iRet = processMsgMain(pAction, pWti, pMsg, &amp;ttNow);
		iRet = qqueueEnqMsg(pAction-&gt;pQueue, eFLOWCTL_NO_DELAY,
			pAction-&gt;bCopyMsg ? MsgDup(pMsg) : MsgAddRef(pMsg));
	}
	pWti-&gt;execState.bPrevWasSuspended =
		(iRet == RS_RET_SUSPENDED || iRet == RS_RET_ACTION_FAILED);
	if (iRet == RS_RET_ACTION_FAILED)			STATSCOUNTER_INC(pAction-&gt;ctrFail, pAction-&gt;mutCtrFail);
	DBGPRINTF("action '%s': set suspended state to %d\n",
		pAction-&gt;pszName, pWti-&gt;execState.bPrevWasSuspended);
finalize_it:
	RETiRet;
}
rsRetVal
actionWriteToAction(action_t * const pAction, smsg_t *pMsg, wti_t * const pWti)
{
	DEFiRet;
	if(pAction-&gt;iExecEveryNthOccur &gt; 1) {
		if(   pAction-&gt;iExecEveryNthOccurTO &gt; 0
		   &amp;&amp; (getActNow(pAction) - pAction-&gt;tLastOccur) &gt; pAction-&gt;iExecEveryNthOccurTO) {
		  	DBGPRINTF("n-th occurrence handling timed out (%d sec), restarting from 0\n",
				  (int) (getActNow(pAction) - pAction-&gt;tLastOccur));
			pAction-&gt;iNbrNoExec = 0;
			pAction-&gt;tLastOccur = getActNow(pAction);
		   }
		if(pAction-&gt;iNbrNoExec &lt; pAction-&gt;iExecEveryNthOccur - 1) {
			++pAction-&gt;iNbrNoExec;
			DBGPRINTF("action %p passed %d times to execution - less than configured - discarding\n",
			  pAction, pAction-&gt;iNbrNoExec);
			FINALIZE;
		} else {
			pAction-&gt;iNbrNoExec = 0; 		}
	}
	DBGPRINTF("Called action(complex case), logging to %s\n", module.GetStateName(pAction-&gt;pMod));
	if(pAction-&gt;iSecsExecOnceInterval &gt; 0 &amp;&amp;
	   pAction-&gt;iSecsExecOnceInterval + pAction-&gt;tLastExec &gt; getActNow(pAction)) {
		DBGPRINTF("action not yet ready again to be executed, onceInterval %d, tCurr %d, tNext %d\n",
			  (int) pAction-&gt;iSecsExecOnceInterval, (int) getActNow(pAction),
			  (int) (pAction-&gt;iSecsExecOnceInterval + pAction-&gt;tLastExec));
		FINALIZE;
	}
	pAction-&gt;tLastExec = getActNow(pAction); 	pAction-&gt;f_time = pMsg-&gt;ttGenTime;
	iRet = doSubmitToActionQ(pAction, pWti, pMsg);
finalize_it:
	RETiRet;
}
PRAGMA_DIAGNOSTIC_PUSH;
PRAGMA_IGNORE_Wempty_body;
static rsRetVal
doSubmitToActionQComplex(action_t * const pAction, wti_t * const pWti, smsg_t *pMsg)
{
	DEFiRet;
	d_pthread_mutex_lock(&amp;pAction-&gt;mutAction);
	pthread_cleanup_push(mutexCancelCleanup, &amp;pAction-&gt;mutAction);
	DBGPRINTF("Called action %p (complex case), logging to %s\n",
		  pAction, module.GetStateName(pAction-&gt;pMod));
	pAction-&gt;tActNow = -1; 
	if(pAction-&gt;bWriteAllMarkMsgs == 0
	   &amp;&amp; (pMsg-&gt;msgFlags &amp; MARK) &amp;&amp; (getActNow(pAction) - pAction-&gt;f_time) &lt; MarkInterval / 2) {
		ABORT_FINALIZE(RS_RET_OK);
	}
	iRet = actionWriteToAction(pAction, pMsg, pWti);
finalize_it:
	d_pthread_mutex_unlock(&amp;pAction-&gt;mutAction);
	pthread_cleanup_pop(0); 
	RETiRet;
}
PRAGMA_DIAGNOSTIC_POP
DEFFUNC_llExecFunc(doActivateActions)
{
	rsRetVal localRet;
	action_t * const pThis = (action_t*) pData;
	localRet = qqueueStart(runConf, pThis-&gt;pQueue);
	if(localRet != RS_RET_OK) {
		LogError(0, localRet, "error starting up action queue");
		if(localRet == RS_RET_FILE_PREFIX_MISSING) {
			LogError(0, localRet, "file prefix (work directory?) "
					"is missing");
		}
		actionDisable(pThis);
	}
	DBGPRINTF("Action %s[%p]: queue %p started\n", modGetName(pThis-&gt;pMod),
		  pThis, pThis-&gt;pQueue);
	return RS_RET_OK; }
rsRetVal
activateActions(void)
{
	DEFiRet;
	iRet = ruleset.IterateAllActions(runConf, doActivateActions, NULL);
	RETiRet;
}
static rsRetVal
doSubmitToActionQNotAllMark(action_t * const pAction, wti_t * const pWti, smsg_t * const pMsg)
{
	int doProcess = 1;
	time_t lastAct;
	DEFiRet;
	do {
		lastAct = pAction-&gt;f_time;
		if(pMsg-&gt;msgFlags &amp; MARK) {
			if((pMsg-&gt;ttGenTime - lastAct) &lt; MarkInterval / 2) {
				doProcess = 0;
				DBGPRINTF("action was recently called, ignoring mark message\n");
				break; 			}
		}
	} while(ATOMIC_CAS_time_t(&amp;pAction-&gt;f_time, lastAct,
		pMsg-&gt;ttGenTime, &amp;pAction-&gt;mutCAS) == 0);
	if(doProcess) {
		DBGPRINTF("Called action(NotAllMark), processing via '%s'\n",
			  module.GetStateName(pAction-&gt;pMod));
		iRet = doSubmitToActionQ(pAction, pWti, pMsg);
	}
	RETiRet;
}
static rsRetVal
actionApplyCnfParam(action_t * const pAction, struct cnfparamvals * const pvals)
{
	int i;
	for(i = 0 ; i &lt; pblk.nParams ; ++i) {
		if(!pvals[i].bUsed)
			continue;
		if(!strcmp(pblk.descr[i].name, "name")) {
			pAction-&gt;pszName = (uchar*) es_str2cstr(pvals[i].val.d.estr, NULL);
		} else if(!strcmp(pblk.descr[i].name, "type")) {
			continue; 		} else if(!strcmp(pblk.descr[i].name, "action.errorfile")) {
			pAction-&gt;pszErrFile = es_str2cstr(pvals[i].val.d.estr, NULL);
		} else if(!strcmp(pblk.descr[i].name, "action.errorfile.maxsize")) {
			pAction-&gt;maxErrFileSize = pvals[i].val.d.n;
		} else if(!strcmp(pblk.descr[i].name, "action.externalstate.file")) {
			pAction-&gt;pszExternalStateFile = es_str2cstr(pvals[i].val.d.estr, NULL);
		} else if(!strcmp(pblk.descr[i].name, "action.writeallmarkmessages")) {
			pAction-&gt;bWriteAllMarkMsgs = pvals[i].val.d.n;
		} else if(!strcmp(pblk.descr[i].name, "action.execonlyeverynthtime")) {
			pAction-&gt;iExecEveryNthOccur = pvals[i].val.d.n;
		} else if(!strcmp(pblk.descr[i].name, "action.execonlyeverynthtimetimeout")) {
			pAction-&gt;iExecEveryNthOccurTO = pvals[i].val.d.n;
		} else if(!strcmp(pblk.descr[i].name, "action.execonlyonceeveryinterval")) {
			pAction-&gt;iSecsExecOnceInterval = pvals[i].val.d.n;
		} else if(!strcmp(pblk.descr[i].name, "action.execonlywhenpreviousissuspended")) {
			pAction-&gt;bExecWhenPrevSusp = pvals[i].val.d.n;
		} else if(!strcmp(pblk.descr[i].name, "action.repeatedmsgcontainsoriginalmsg")) {
			pAction-&gt;bRepMsgHasMsg = pvals[i].val.d.n;
		} else if(!strcmp(pblk.descr[i].name, "action.resumeretrycount")) {
			pAction-&gt;iResumeRetryCount = pvals[i].val.d.n;
		} else if(!strcmp(pblk.descr[i].name, "action.reportsuspension")) {
			pAction-&gt;bReportSuspension = (int) pvals[i].val.d.n;
		} else if(!strcmp(pblk.descr[i].name, "action.reportsuspensioncontinuation")) {
			pAction-&gt;bReportSuspensionCont = (int) pvals[i].val.d.n;
		} else if(!strcmp(pblk.descr[i].name, "action.copymsg")) {
			pAction-&gt;bCopyMsg = (int) pvals[i].val.d.n;
		} else if(!strcmp(pblk.descr[i].name, "action.resumeinterval")) {
			pAction-&gt;iResumeInterval = pvals[i].val.d.n;
		} else if(!strcmp(pblk.descr[i].name, "action.resumeintervalMax")) {
			pAction-&gt;iResumeIntervalMax = pvals[i].val.d.n;
		} else {
			dbgprintf("action: program error, non-handled "
			  "param '%s'\n", pblk.descr[i].name);
		}
	}
	return RS_RET_OK;
}
rsRetVal
addAction(action_t **ppAction, modInfo_t *pMod, void *pModData,
	  omodStringRequest_t *pOMSR, struct cnfparamvals *actParams,
	  struct nvlst * const lst)
{
	DEFiRet;
	int i;
	int iTplOpts;
	uchar *pTplName;
	action_t *pAction;
	char errMsg[512];
	assert(ppAction != NULL);
	assert(pMod != NULL);
	assert(pOMSR != NULL);
	DBGPRINTF("Module %s processes this action.\n", module.GetName(pMod));
	CHKiRet(actionConstruct(&amp;pAction)); 	pAction-&gt;pMod = pMod;
	pAction-&gt;pModData = pModData;
	if(actParams == NULL) { 		pAction-&gt;pszName = cs.pszActionName;
		pAction-&gt;iResumeInterval = cs.glbliActionResumeInterval;
		pAction-&gt;iResumeRetryCount = cs.glbliActionResumeRetryCount;
		pAction-&gt;bWriteAllMarkMsgs = cs.bActionWriteAllMarkMsgs;
		pAction-&gt;bExecWhenPrevSusp = cs.bActExecWhenPrevSusp;
		pAction-&gt;iSecsExecOnceInterval = cs.iActExecOnceInterval;
		pAction-&gt;iExecEveryNthOccur = cs.iActExecEveryNthOccur;
		pAction-&gt;iExecEveryNthOccurTO = cs.iActExecEveryNthOccurTO;
		pAction-&gt;bRepMsgHasMsg = cs.bActionRepMsgHasMsg;
		cs.iActExecEveryNthOccur = 0; 		cs.iActExecEveryNthOccurTO = 0; 		cs.bActionWriteAllMarkMsgs = 1; 		cs.pszActionName = NULL;		} else {
		actionApplyCnfParam(pAction, actParams);
	}
	pAction-&gt;iNumTpls = OMSRgetEntryCount(pOMSR);
	if(pAction-&gt;iNumTpls &gt; 0) {
		CHKmalloc(pAction-&gt;ppTpl = (struct template **)calloc(pAction-&gt;iNumTpls, sizeof(struct template *)));
		CHKmalloc(pAction-&gt;peParamPassing = (paramPassing_t*)calloc(pAction-&gt;iNumTpls,
			sizeof(paramPassing_t)));
	}
	pAction-&gt;bUsesMsgPassingMode = 0;
	pAction-&gt;bNeedReleaseBatch = 0;
	for(i = 0 ; i &lt; pAction-&gt;iNumTpls ; ++i) {
		CHKiRet(OMSRgetEntry(pOMSR, i, &amp;pTplName, &amp;iTplOpts));
		if(!(iTplOpts &amp; OMSR_TPL_AS_MSG)) {
		   	if((pAction-&gt;ppTpl[i] =
				tplFind(loadConf, (char*)pTplName, strlen((char*)pTplName))) == NULL) {
				snprintf(errMsg, sizeof(errMsg),
					 " Could not find template %d '%s' - action disabled",
					 i, pTplName);
				errno = 0;
				LogError(0, RS_RET_NOT_FOUND, "%s", errMsg);
				ABORT_FINALIZE(RS_RET_NOT_FOUND);
			}
			if(   (iTplOpts &amp; OMSR_RQD_TPL_OPT_SQL)
			   &amp;&amp; (pAction-&gt;ppTpl[i]-&gt;optFormatEscape == 0)) {
				errno = 0;
				LogError(0, RS_RET_RQD_TPLOPT_MISSING, "Action disabled."
						" To use this action, you have to specify "
						"the SQL or stdSQL option in your template!\n");
				ABORT_FINALIZE(RS_RET_RQD_TPLOPT_MISSING);
			}
		}
<a name="2"></a>				if(iTplOpts &amp; OMSR_TPL_AS_ARRAY) {
			ABORT_FINALIZE(RS_RET_ERR);
<font color="#980517"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>		} else if(iTplOpts &amp; OMSR_TPL_AS_MSG) {
			pAction-&gt;peParamPassing[i] = ACT_MSG_PASSING;
			pAction-&gt;bUsesMsgPassingMode = 1;
		} else if(iTplOpts &amp; OMSR_TPL_AS_JSON) {
			pAction-&gt;peParamPassing[i] = ACT_JSON_PASSING;
			pAction-&gt;bNeedReleaseBatch = 1;
		} else {
			pAction-&gt;peParamPassing[i] = ACT_STRING_PASSING;</b></font>
		}
		DBGPRINTF("template: '%s' assigned\n", pTplName);
	}
	pAction-&gt;pMod = pMod;
	pAction-&gt;pModData = pModData;
	CHKiRet(actionConstructFinalize(pAction, lst));
	*ppAction = pAction; 
finalize_it:
	if(iRet == RS_RET_OK)
		iRet = OMSRdestruct(pOMSR);
	else {
		OMSRdestruct(pOMSR);
		if(pAction != NULL)
			actionDestruct(pAction);
	}
	RETiRet;
}
static rsRetVal
resetConfigVariables(uchar __attribute__((unused)) *pp, void __attribute__((unused)) *pVal)
{
	cs.iActExecOnceInterval = 0;
	cs.bActExecWhenPrevSusp = 0;
	return RS_RET_OK;
}
static void
initConfigVariables(void)
{
	cs.bActionWriteAllMarkMsgs = 1;
	cs.glbliActionResumeRetryCount = 0;
	cs.bActExecWhenPrevSusp = 0;
	cs.iActExecOnceInterval = 0;
	cs.iActExecEveryNthOccur = 0;
	cs.iActExecEveryNthOccurTO = 0;
	cs.glbliActionResumeInterval = 30;
	cs.glbliActionResumeRetryCount = 0;
	cs.bActionRepMsgHasMsg = 0;
	if(cs.pszActionName != NULL) {
		free(cs.pszActionName);
		cs.pszActionName = NULL;
	}
	actionResetQueueParams();
}
rsRetVal
actionNewInst(struct nvlst *lst, action_t **ppAction)
{
	struct cnfparamvals *paramvals;
	modInfo_t *pMod;
	uchar *cnfModName = NULL;
	omodStringRequest_t *pOMSR;
	void *pModData;
	action_t *pAction;
	DEFiRet;
	paramvals = nvlstGetParams(lst, &amp;pblk, NULL);
	if(paramvals == NULL) {
		ABORT_FINALIZE(RS_RET_PARAM_ERROR);
	}
	dbgprintf("action param blk after actionNewInst:\n");
	cnfparamsPrint(&amp;pblk, paramvals);
	cnfModName = (uchar*)es_str2cstr(paramvals[cnfparamGetIdx(&amp;pblk, ("type"))].val.d.estr, NULL);
	if((pMod = module.FindWithCnfName(loadConf, cnfModName, eMOD_OUT)) == NULL) {
		LogError(0, RS_RET_MOD_UNKNOWN, "module name '%s' is unknown", cnfModName);
		ABORT_FINALIZE(RS_RET_MOD_UNKNOWN);
	}
	CHKiRet(pMod-&gt;mod.om.newActInst(cnfModName, lst, &amp;pModData, &amp;pOMSR));
	if((iRet = addAction(&amp;pAction, pMod, pModData, pOMSR, paramvals, lst)) == RS_RET_OK) {
		loadConf-&gt;actions.nbrActions++;			*ppAction = pAction;
	} else {
	}
finalize_it:
	free(cnfModName);
	cnfparamvalsDestruct(paramvals, &amp;pblk);
	RETiRet;
}
rsRetVal actionClassInit(void)
{
	DEFiRet;
	CHKiRet(objGetObjInterface(&amp;obj)); 	CHKiRet(objUse(datetime, CORE_COMPONENT));
	CHKiRet(objUse(module, CORE_COMPONENT));
	CHKiRet(objUse(statsobj, CORE_COMPONENT));
	CHKiRet(objUse(ruleset, CORE_COMPONENT));
	CHKiRet(regCfSysLineHdlr((uchar *)"actionname", 0, eCmdHdlrGetWord, NULL, &amp;cs.pszActionName, NULL));
	CHKiRet(regCfSysLineHdlr((uchar *)"actionqueuefilename", 0, eCmdHdlrGetWord, NULL,
		&amp;cs.pszActionQFName, NULL));
	CHKiRet(regCfSysLineHdlr((uchar *)"actionqueuesize", 0, eCmdHdlrInt, NULL, &amp;cs.iActionQueueSize,
		NULL));
	CHKiRet(regCfSysLineHdlr((uchar *)"actionwriteallmarkmessages", 0, eCmdHdlrBinary, NULL,
		&amp;cs.bActionWriteAllMarkMsgs, NULL));
	CHKiRet(regCfSysLineHdlr((uchar *)"actionqueuedequeuebatchsize", 0, eCmdHdlrInt, NULL,
		&amp;cs.iActionQueueDeqBatchSize, NULL));
	CHKiRet(regCfSysLineHdlr((uchar *)"actionqueuemaxdiskspace", 0, eCmdHdlrSize, NULL,
		&amp;cs.iActionQueMaxDiskSpace, NULL));
	CHKiRet(regCfSysLineHdlr((uchar *)"actionqueuehighwatermark", 0, eCmdHdlrInt, NULL,
		&amp;cs.iActionQHighWtrMark, NULL));
	CHKiRet(regCfSysLineHdlr((uchar *)"actionqueuelowwatermark", 0, eCmdHdlrInt, NULL,
		&amp;cs.iActionQLowWtrMark, NULL));
	CHKiRet(regCfSysLineHdlr((uchar *)"actionqueuediscardmark", 0, eCmdHdlrInt, NULL,
		&amp;cs.iActionQDiscardMark, NULL));
	CHKiRet(regCfSysLineHdlr((uchar *)"actionqueuediscardseverity", 0, eCmdHdlrInt, NULL,
		&amp;cs.iActionQDiscardSeverity, NULL));
	CHKiRet(regCfSysLineHdlr((uchar *)"actionqueuecheckpointinterval", 0, eCmdHdlrInt, NULL,
		&amp;cs.iActionQPersistUpdCnt, NULL));
	CHKiRet(regCfSysLineHdlr((uchar *)"actionqueuesyncqueuefiles", 0, eCmdHdlrBinary, NULL,
		&amp;cs.bActionQSyncQeueFiles, NULL));
	CHKiRet(regCfSysLineHdlr((uchar *)"actionqueuetype", 0, eCmdHdlrGetWord, setActionQueType, NULL, NULL));
	CHKiRet(regCfSysLineHdlr((uchar *)"actionqueueworkerthreads", 0, eCmdHdlrInt, NULL,
		&amp;cs.iActionQueueNumWorkers, NULL));
	CHKiRet(regCfSysLineHdlr((uchar *)"actionqueuetimeoutshutdown", 0, eCmdHdlrInt, NULL,
		&amp;cs.iActionQtoQShutdown, NULL));
	CHKiRet(regCfSysLineHdlr((uchar *)"actionqueuetimeoutactioncompletion", 0, eCmdHdlrInt, NULL,
		&amp;cs.iActionQtoActShutdown, NULL));
	CHKiRet(regCfSysLineHdlr((uchar *)"actionqueuetimeoutenqueue", 0, eCmdHdlrInt, NULL,
		&amp;cs.iActionQtoEnq, NULL));
	CHKiRet(regCfSysLineHdlr((uchar *)"actionqueueworkertimeoutthreadshutdown", 0, eCmdHdlrInt, NULL,
		&amp;cs.iActionQtoWrkShutdown, NULL));
	CHKiRet(regCfSysLineHdlr((uchar *)"actionqueueworkerthreadminimummessages", 0, eCmdHdlrInt, NULL,
		&amp;cs.iActionQWrkMinMsgs, NULL));
	CHKiRet(regCfSysLineHdlr((uchar *)"actionqueuemaxfilesize", 0, eCmdHdlrSize, NULL,
		&amp;cs.iActionQueMaxFileSize, NULL));
	CHKiRet(regCfSysLineHdlr((uchar *)"actionqueuesaveonshutdown", 0, eCmdHdlrBinary, NULL,
		&amp;cs.bActionQSaveOnShutdown, NULL));
	CHKiRet(regCfSysLineHdlr((uchar *)"actionqueuedequeueslowdown", 0, eCmdHdlrInt, NULL,
		&amp;cs.iActionQueueDeqSlowdown, NULL));
	CHKiRet(regCfSysLineHdlr((uchar *)"actionqueuedequeuetimebegin", 0, eCmdHdlrInt, NULL,
		&amp;cs.iActionQueueDeqtWinFromHr, NULL));
	CHKiRet(regCfSysLineHdlr((uchar *)"actionqueuedequeuetimeend", 0, eCmdHdlrInt, NULL,
		&amp;cs.iActionQueueDeqtWinToHr, NULL));
	CHKiRet(regCfSysLineHdlr((uchar *)"actionexeconlyeverynthtime", 0, eCmdHdlrInt, NULL,
		&amp;cs.iActExecEveryNthOccur, NULL));
	CHKiRet(regCfSysLineHdlr((uchar *)"actionexeconlyeverynthtimetimeout", 0, eCmdHdlrInt, NULL,
		&amp;cs.iActExecEveryNthOccurTO, NULL));
	CHKiRet(regCfSysLineHdlr((uchar *)"actionexeconlyonceeveryinterval", 0, eCmdHdlrInt, NULL,
		&amp;cs.iActExecOnceInterval, NULL));
	CHKiRet(regCfSysLineHdlr((uchar *)"repeatedmsgcontainsoriginalmsg", 0, eCmdHdlrBinary, NULL,
		&amp;cs.bActionRepMsgHasMsg, NULL));
	CHKiRet(regCfSysLineHdlr((uchar *)"actionexeconlywhenpreviousissuspended", 0, eCmdHdlrBinary, NULL,
		&amp;cs.bActExecWhenPrevSusp, NULL));
	CHKiRet(regCfSysLineHdlr((uchar *)"actionresumeretrycount", 0, eCmdHdlrInt, NULL,
		&amp;cs.glbliActionResumeRetryCount, NULL));
	CHKiRet(regCfSysLineHdlr((uchar *)"resetconfigvariables", 1, eCmdHdlrCustomHandler,
		resetConfigVariables, NULL, NULL));
	initConfigVariables(); 
finalize_it:
	RETiRet;
}
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
