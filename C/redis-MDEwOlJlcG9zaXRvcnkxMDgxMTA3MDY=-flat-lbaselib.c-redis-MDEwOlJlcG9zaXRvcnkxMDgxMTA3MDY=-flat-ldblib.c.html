
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 23, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>redis-MDEwOlJlcG9zaXRvcnkxMDgxMTA3MDY=-flat-lbaselib.c</h3>
            <pre><code>1  #include <ctype.h>
2  #include <stdio.h>
3  #include <stdlib.h>
4  #include <string.h>
5  #define lbaselib_c
6  #define LUA_LIB
7  #include "lua.h"
8  #include "lauxlib.h"
9  #include "lualib.h"
10  static int luaB_print (lua_State *L) {
11    int n = lua_gettop(L);  &bsol;* number of arguments */
12    int i;
13    lua_getglobal(L, "tostring");
14    for (i=1; i<=n; i++) {
15      const char *s;
16      lua_pushvalue(L, -1);  &bsol;* function to be called */
17      lua_pushvalue(L, i);   &bsol;* value to print */
18      lua_call(L, 1, 1);
19      s = lua_tostring(L, -1);  &bsol;* get result */
20      if (s == NULL)
21        return luaL_error(L, LUA_QL("tostring") " must return a string to "
22                             LUA_QL("print"));
23      if (i>1) fputs("\t", stdout);
24      fputs(s, stdout);
25      lua_pop(L, 1);  &bsol;* pop result */
26    }
27    fputs("\n", stdout);
28    return 0;
29  }
30  static int luaB_tonumber (lua_State *L) {
31    int base = luaL_optint(L, 2, 10);
32    if (base == 10) {  &bsol;* standard conversion */
33      luaL_checkany(L, 1);
34      if (lua_isnumber(L, 1)) {
35        lua_pushnumber(L, lua_tonumber(L, 1));
36        return 1;
37      }
38    }
39    else {
40      const char *s1 = luaL_checkstring(L, 1);
41      char *s2;
42      unsigned long n;
43      luaL_argcheck(L, 2 <= base && base <= 36, 2, "base out of range");
44      n = strtoul(s1, &s2, base);
45      if (s1 != s2) {  &bsol;* at least one valid digit? */
46        while (isspace((unsigned char)(*s2))) s2++;  &bsol;* skip trailing spaces */
47        if (*s2 == '\0') {  &bsol;* no invalid trailing characters? */
48          lua_pushnumber(L, (lua_Number)n);
49          return 1;
50        }
51      }
52    }
53    lua_pushnil(L);  &bsol;* else not a number */
54    return 1;
55  }
56  static int luaB_error (lua_State *L) {
57    int level = luaL_optint(L, 2, 1);
58    lua_settop(L, 1);
59    if (lua_isstring(L, 1) && level > 0) {  &bsol;* add extra information? */
60      luaL_where(L, level);
61      lua_pushvalue(L, 1);
62      lua_concat(L, 2);
63    }
64    return lua_error(L);
65  }
66  static int luaB_getmetatable (lua_State *L) {
<span onclick='openModal()' class='match'>67    luaL_checkany(L, 1);
68    if (!lua_getmetatable(L, 1)) {
69      lua_pushnil(L);
70      return 1;  &bsol;* no metatable */
</span>71    }
72    luaL_getmetafield(L, 1, "__metatable");
73    return 1;  &bsol;* returns either __metatable field (if present) or metatable */
74  }
75  static int luaB_setmetatable (lua_State *L) {
76    int t = lua_type(L, 2);
77    luaL_checktype(L, 1, LUA_TTABLE);
78    luaL_argcheck(L, t == LUA_TNIL || t == LUA_TTABLE, 2,
79                      "nil or table expected");
80    if (luaL_getmetafield(L, 1, "__metatable"))
81      luaL_error(L, "cannot change a protected metatable");
82    lua_settop(L, 2);
83    lua_setmetatable(L, 1);
84    return 1;
85  }
86  static void getfunc (lua_State *L, int opt) {
87    if (lua_isfunction(L, 1)) lua_pushvalue(L, 1);
88    else {
89      lua_Debug ar;
90      int level = opt ? luaL_optint(L, 1, 1) : luaL_checkint(L, 1);
91      luaL_argcheck(L, level >= 0, 1, "level must be non-negative");
92      if (lua_getstack(L, level, &ar) == 0)
93        luaL_argerror(L, 1, "invalid level");
94      lua_getinfo(L, "f", &ar);
95      if (lua_isnil(L, -1))
96        luaL_error(L, "no function environment for tail call at level %d",
97                      level);
98    }
99  }
100  static int luaB_getfenv (lua_State *L) {
101    getfunc(L, 1);
102    if (lua_iscfunction(L, -1))  &bsol;* is a C function? */
103      lua_pushvalue(L, LUA_GLOBALSINDEX);  &bsol;* return the thread's global env. */
104    else
105      lua_getfenv(L, -1);
106    return 1;
107  }
108  static int luaB_setfenv (lua_State *L) {
109    luaL_checktype(L, 2, LUA_TTABLE);
110    getfunc(L, 0);
111    lua_pushvalue(L, 2);
112    if (lua_isnumber(L, 1) && lua_tonumber(L, 1) == 0) {
113      lua_pushthread(L);
114      lua_insert(L, -2);
115      lua_setfenv(L, -2);
116      return 0;
117    }
118    else if (lua_iscfunction(L, -2) || lua_setfenv(L, -2) == 0)
119      luaL_error(L,
120            LUA_QL("setfenv") " cannot change environment of given object");
121    return 1;
122  }
123  static int luaB_rawequal (lua_State *L) {
124    luaL_checkany(L, 1);
125    luaL_checkany(L, 2);
126    lua_pushboolean(L, lua_rawequal(L, 1, 2));
127    return 1;
128  }
129  static int luaB_rawget (lua_State *L) {
130    luaL_checktype(L, 1, LUA_TTABLE);
131    luaL_checkany(L, 2);
132    lua_settop(L, 2);
133    lua_rawget(L, 1);
134    return 1;
135  }
136  static int luaB_rawset (lua_State *L) {
137    luaL_checktype(L, 1, LUA_TTABLE);
138    luaL_checkany(L, 2);
139    luaL_checkany(L, 3);
140    lua_settop(L, 3);
141    lua_rawset(L, 1);
142    return 1;
143  }
144  static int luaB_gcinfo (lua_State *L) {
145    lua_pushinteger(L, lua_getgccount(L));
146    return 1;
147  }
148  static int luaB_collectgarbage (lua_State *L) {
149    static const char *const opts[] = {"stop", "restart", "collect",
150      "count", "step", "setpause", "setstepmul", NULL};
151    static const int optsnum[] = {LUA_GCSTOP, LUA_GCRESTART, LUA_GCCOLLECT,
152      LUA_GCCOUNT, LUA_GCSTEP, LUA_GCSETPAUSE, LUA_GCSETSTEPMUL};
153    int o = luaL_checkoption(L, 1, "collect", opts);
154    int ex = luaL_optint(L, 2, 0);
155    int res = lua_gc(L, optsnum[o], ex);
156    switch (optsnum[o]) {
157      case LUA_GCCOUNT: {
158        int b = lua_gc(L, LUA_GCCOUNTB, 0);
159        lua_pushnumber(L, res + ((lua_Number)b/1024));
160        return 1;
161      }
162      case LUA_GCSTEP: {
163        lua_pushboolean(L, res);
164        return 1;
165      }
166      default: {
167        lua_pushnumber(L, res);
168        return 1;
169      }
170    }
171  }
172  static int luaB_type (lua_State *L) {
173    luaL_checkany(L, 1);
174    lua_pushstring(L, luaL_typename(L, 1));
175    return 1;
176  }
177  static int luaB_next (lua_State *L) {
178    luaL_checktype(L, 1, LUA_TTABLE);
179    lua_settop(L, 2);  &bsol;* create a 2nd argument if there isn't one */
180    if (lua_next(L, 1))
181      return 2;
182    else {
183      lua_pushnil(L);
184      return 1;
185    }
186  }
187  static int luaB_pairs (lua_State *L) {
188    luaL_checktype(L, 1, LUA_TTABLE);
189    lua_pushvalue(L, lua_upvalueindex(1));  &bsol;* return generator, */
190    lua_pushvalue(L, 1);  &bsol;* state, */
191    lua_pushnil(L);  &bsol;* and initial value */
192    return 3;
193  }
194  static int ipairsaux (lua_State *L) {
195    int i = luaL_checkint(L, 2);
196    luaL_checktype(L, 1, LUA_TTABLE);
197    i++;  &bsol;* next value */
198    lua_pushinteger(L, i);
199    lua_rawgeti(L, 1, i);
200    return (lua_isnil(L, -1)) ? 0 : 2;
201  }
202  static int luaB_ipairs (lua_State *L) {
203    luaL_checktype(L, 1, LUA_TTABLE);
204    lua_pushvalue(L, lua_upvalueindex(1));  &bsol;* return generator, */
205    lua_pushvalue(L, 1);  &bsol;* state, */
206    lua_pushinteger(L, 0);  &bsol;* and initial value */
207    return 3;
208  }
209  static int load_aux (lua_State *L, int status) {
210    if (status == 0)  &bsol;* OK? */
211      return 1;
212    else {
213      lua_pushnil(L);
214      lua_insert(L, -2);  &bsol;* put before error message */
215      return 2;  &bsol;* return nil plus error message */
216    }
217  }
218  static int luaB_loadstring (lua_State *L) {
219    size_t l;
220    const char *s = luaL_checklstring(L, 1, &l);
221    const char *chunkname = luaL_optstring(L, 2, s);
222    return load_aux(L, luaL_loadbuffer(L, s, l, chunkname));
223  }
224  static int luaB_loadfile (lua_State *L) {
225    const char *fname = luaL_optstring(L, 1, NULL);
226    return load_aux(L, luaL_loadfile(L, fname));
227  }
228  static const char *generic_reader (lua_State *L, void *ud, size_t *size) {
229    (void)ud;  &bsol;* to avoid warnings */
230    luaL_checkstack(L, 2, "too many nested functions");
231    lua_pushvalue(L, 1);  &bsol;* get function */
232    lua_call(L, 0, 1);  &bsol;* call it */
233    if (lua_isnil(L, -1)) {
234      *size = 0;
235      return NULL;
236    }
237    else if (lua_isstring(L, -1)) {
238      lua_replace(L, 3);  &bsol;* save string in a reserved stack slot */
239      return lua_tolstring(L, 3, size);
240    }
241    else luaL_error(L, "reader function must return a string");
242    return NULL;  &bsol;* to avoid warnings */
243  }
244  static int luaB_load (lua_State *L) {
245    int status;
246    const char *cname = luaL_optstring(L, 2, "=(load)");
247    luaL_checktype(L, 1, LUA_TFUNCTION);
248    lua_settop(L, 3);  &bsol;* function, eventual name, plus one reserved slot */
249    status = lua_load(L, generic_reader, NULL, cname);
250    return load_aux(L, status);
251  }
252  static int luaB_dofile (lua_State *L) {
253    const char *fname = luaL_optstring(L, 1, NULL);
254    int n = lua_gettop(L);
255    if (luaL_loadfile(L, fname) != 0) lua_error(L);
256    lua_call(L, 0, LUA_MULTRET);
257    return lua_gettop(L) - n;
258  }
259  static int luaB_assert (lua_State *L) {
260    luaL_checkany(L, 1);
261    if (!lua_toboolean(L, 1))
262      return luaL_error(L, "%s", luaL_optstring(L, 2, "assertion failed!"));
263    return lua_gettop(L);
264  }
265  static int luaB_unpack (lua_State *L) {
266    int i, e, n;
267    luaL_checktype(L, 1, LUA_TTABLE);
268    i = luaL_optint(L, 2, 1);
269    e = luaL_opt(L, luaL_checkint, 3, luaL_getn(L, 1));
270    if (i > e) return 0;  &bsol;* empty range */
271    n = e - i + 1;  &bsol;* number of elements */
272    if (n <= 0 || !lua_checkstack(L, n))  &bsol;* n <= 0 means arith. overflow */
273      return luaL_error(L, "too many results to unpack");
274    lua_rawgeti(L, 1, i);  &bsol;* push arg[i] (avoiding overflow problems) */
275    while (i++ < e)  &bsol;* push arg[i + 1...e] */
276      lua_rawgeti(L, 1, i);
277    return n;
278  }
279  static int luaB_select (lua_State *L) {
280    int n = lua_gettop(L);
281    if (lua_type(L, 1) == LUA_TSTRING && *lua_tostring(L, 1) == '#') {
282      lua_pushinteger(L, n-1);
283      return 1;
284    }
285    else {
286      int i = luaL_checkint(L, 1);
287      if (i < 0) i = n + i;
288      else if (i > n) i = n;
289      luaL_argcheck(L, 1 <= i, 1, "index out of range");
290      return n - i;
291    }
292  }
293  static int luaB_pcall (lua_State *L) {
294    int status;
295    luaL_checkany(L, 1);
296    status = lua_pcall(L, lua_gettop(L) - 1, LUA_MULTRET, 0);
297    lua_pushboolean(L, (status == 0));
298    lua_insert(L, 1);
299    return lua_gettop(L);  &bsol;* return status + all results */
300  }
301  static int luaB_xpcall (lua_State *L) {
302    int status;
303    luaL_checkany(L, 2);
304    lua_settop(L, 2);
305    lua_insert(L, 1);  &bsol;* put error function under function to be called */
306    status = lua_pcall(L, 0, LUA_MULTRET, 1);
307    lua_pushboolean(L, (status == 0));
308    lua_replace(L, 1);
309    return lua_gettop(L);  &bsol;* return status + all results */
310  }
311  static int luaB_tostring (lua_State *L) {
312    luaL_checkany(L, 1);
313    if (luaL_callmeta(L, 1, "__tostring"))  &bsol;* is there a metafield? */
314      return 1;  &bsol;* use its value */
315    switch (lua_type(L, 1)) {
316      case LUA_TNUMBER:
317        lua_pushstring(L, lua_tostring(L, 1));
318        break;
319      case LUA_TSTRING:
320        lua_pushvalue(L, 1);
321        break;
322      case LUA_TBOOLEAN:
323        lua_pushstring(L, (lua_toboolean(L, 1) ? "true" : "false"));
324        break;
325      case LUA_TNIL:
326        lua_pushliteral(L, "nil");
327        break;
328      default:
329        lua_pushfstring(L, "%s: %p", luaL_typename(L, 1), lua_topointer(L, 1));
330        break;
331    }
332    return 1;
333  }
334  static int luaB_newproxy (lua_State *L) {
335    lua_settop(L, 1);
336    lua_newuserdata(L, 0);  &bsol;* create proxy */
337    if (lua_toboolean(L, 1) == 0)
338      return 1;  &bsol;* no metatable */
339    else if (lua_isboolean(L, 1)) {
340      lua_newtable(L);  &bsol;* create a new metatable `m' ... */
341      lua_pushvalue(L, -1);  &bsol;* ... and mark `m' as a valid metatable */
342      lua_pushboolean(L, 1);
343      lua_rawset(L, lua_upvalueindex(1));  &bsol;* weaktable[m] = true */
344    }
345    else {
346      int validproxy = 0;  &bsol;* to check if weaktable[metatable(u)] == true */
347      if (lua_getmetatable(L, 1)) {
348        lua_rawget(L, lua_upvalueindex(1));
349        validproxy = lua_toboolean(L, -1);
350        lua_pop(L, 1);  &bsol;* remove value */
351      }
352      luaL_argcheck(L, validproxy, 1, "boolean or proxy expected");
353      lua_getmetatable(L, 1);  &bsol;* metatable is valid; get it */
354    }
355    lua_setmetatable(L, 2);
356    return 1;
357  }
358  static const luaL_Reg base_funcs[] = {
359    {"assert", luaB_assert},
360    {"collectgarbage", luaB_collectgarbage},
361    {"dofile", luaB_dofile},
362    {"error", luaB_error},
363    {"gcinfo", luaB_gcinfo},
364    {"getfenv", luaB_getfenv},
365    {"getmetatable", luaB_getmetatable},
366    {"loadfile", luaB_loadfile},
367    {"load", luaB_load},
368    {"loadstring", luaB_loadstring},
369    {"next", luaB_next},
370    {"pcall", luaB_pcall},
371    {"print", luaB_print},
372    {"rawequal", luaB_rawequal},
373    {"rawget", luaB_rawget},
374    {"rawset", luaB_rawset},
375    {"select", luaB_select},
376    {"setfenv", luaB_setfenv},
377    {"setmetatable", luaB_setmetatable},
378    {"tonumber", luaB_tonumber},
379    {"tostring", luaB_tostring},
380    {"type", luaB_type},
381    {"unpack", luaB_unpack},
382    {"xpcall", luaB_xpcall},
383    {NULL, NULL}
384  };
385  #define CO_RUN	0	&bsol;* running */
386  #define CO_SUS	1	&bsol;* suspended */
387  #define CO_NOR	2	&bsol;* 'normal' (it resumed another coroutine) */
388  #define CO_DEAD	3
389  static const char *const statnames[] =
390      {"running", "suspended", "normal", "dead"};
391  static int costatus (lua_State *L, lua_State *co) {
392    if (L == co) return CO_RUN;
393    switch (lua_status(co)) {
394      case LUA_YIELD:
395        return CO_SUS;
396      case 0: {
397        lua_Debug ar;
398        if (lua_getstack(co, 0, &ar) > 0)  &bsol;* does it have frames? */
399          return CO_NOR;  &bsol;* it is running */
400        else if (lua_gettop(co) == 0)
401            return CO_DEAD;
402        else
403          return CO_SUS;  &bsol;* initial state */
404      }
405      default:  &bsol;* some error occured */
406        return CO_DEAD;
407    }
408  }
409  static int luaB_costatus (lua_State *L) {
410    lua_State *co = lua_tothread(L, 1);
411    luaL_argcheck(L, co, 1, "coroutine expected");
412    lua_pushstring(L, statnames[costatus(L, co)]);
413    return 1;
414  }
415  static int auxresume (lua_State *L, lua_State *co, int narg) {
416    int status = costatus(L, co);
417    if (!lua_checkstack(co, narg))
418      luaL_error(L, "too many arguments to resume");
419    if (status != CO_SUS) {
420      lua_pushfstring(L, "cannot resume %s coroutine", statnames[status]);
421      return -1;  &bsol;* error flag */
422    }
423    lua_xmove(L, co, narg);
424    lua_setlevel(L, co);
425    status = lua_resume(co, narg);
426    if (status == 0 || status == LUA_YIELD) {
427      int nres = lua_gettop(co);
428      if (!lua_checkstack(L, nres + 1))
429        luaL_error(L, "too many results to resume");
430      lua_xmove(co, L, nres);  &bsol;* move yielded values */
431      return nres;
432    }
433    else {
434      lua_xmove(co, L, 1);  &bsol;* move error message */
435      return -1;  &bsol;* error flag */
436    }
437  }
438  static int luaB_coresume (lua_State *L) {
439    lua_State *co = lua_tothread(L, 1);
440    int r;
441    luaL_argcheck(L, co, 1, "coroutine expected");
442    r = auxresume(L, co, lua_gettop(L) - 1);
443    if (r < 0) {
444      lua_pushboolean(L, 0);
445      lua_insert(L, -2);
446      return 2;  &bsol;* return false + error message */
447    }
448    else {
449      lua_pushboolean(L, 1);
450      lua_insert(L, -(r + 1));
451      return r + 1;  &bsol;* return true + `resume' returns */
452    }
453  }
454  static int luaB_auxwrap (lua_State *L) {
455    lua_State *co = lua_tothread(L, lua_upvalueindex(1));
456    int r = auxresume(L, co, lua_gettop(L));
457    if (r < 0) {
458      if (lua_isstring(L, -1)) {  &bsol;* error object is a string? */
459        luaL_where(L, 1);  &bsol;* add extra info */
460        lua_insert(L, -2);
461        lua_concat(L, 2);
462      }
463      lua_error(L);  &bsol;* propagate error */
464    }
465    return r;
466  }
467  static int luaB_cocreate (lua_State *L) {
468    lua_State *NL = lua_newthread(L);
469    luaL_argcheck(L, lua_isfunction(L, 1) && !lua_iscfunction(L, 1), 1,
470      "Lua function expected");
471    lua_pushvalue(L, 1);  &bsol;* move function to top */
472    lua_xmove(L, NL, 1);  &bsol;* move function from L to NL */
473    return 1;
474  }
475  static int luaB_cowrap (lua_State *L) {
476    luaB_cocreate(L);
477    lua_pushcclosure(L, luaB_auxwrap, 1);
478    return 1;
479  }
480  static int luaB_yield (lua_State *L) {
481    return lua_yield(L, lua_gettop(L));
482  }
483  static int luaB_corunning (lua_State *L) {
484    if (lua_pushthread(L))
485      lua_pushnil(L);  &bsol;* main thread is not a coroutine */
486    return 1;
487  }
488  static const luaL_Reg co_funcs[] = {
489    {"create", luaB_cocreate},
490    {"resume", luaB_coresume},
491    {"running", luaB_corunning},
492    {"status", luaB_costatus},
493    {"wrap", luaB_cowrap},
494    {"yield", luaB_yield},
495    {NULL, NULL}
496  };
497  static void auxopen (lua_State *L, const char *name,
498                       lua_CFunction f, lua_CFunction u) {
499    lua_pushcfunction(L, u);
500    lua_pushcclosure(L, f, 1);
501    lua_setfield(L, -2, name);
502  }
503  static void base_open (lua_State *L) {
504    lua_pushvalue(L, LUA_GLOBALSINDEX);
505    lua_setglobal(L, "_G");
506    luaL_register(L, "_G", base_funcs);
507    lua_pushliteral(L, LUA_VERSION);
508    lua_setglobal(L, "_VERSION");  &bsol;* set global _VERSION */
509    auxopen(L, "ipairs", luaB_ipairs, ipairsaux);
510    auxopen(L, "pairs", luaB_pairs, luaB_next);
511    lua_createtable(L, 0, 1);  &bsol;* new table `w' */
512    lua_pushvalue(L, -1);  &bsol;* `w' will be its own metatable */
513    lua_setmetatable(L, -2);
514    lua_pushliteral(L, "kv");
515    lua_setfield(L, -2, "__mode");  &bsol;* metatable(w).__mode = "kv" */
516    lua_pushcclosure(L, luaB_newproxy, 1);
517    lua_setglobal(L, "newproxy");  &bsol;* set global `newproxy' */
518  }
519  LUALIB_API int luaopen_base (lua_State *L) {
520    base_open(L);
521    luaL_register(L, LUA_COLIBNAME, co_funcs);
522    return 2;
523  }
</code></pre>
        </div>
        <div class="column">
            <h3>redis-MDEwOlJlcG9zaXRvcnkxMDgxMTA3MDY=-flat-ldblib.c</h3>
            <pre><code>1  #include <stdio.h>
2  #include <stdlib.h>
3  #include <string.h>
4  #define ldblib_c
5  #define LUA_LIB
6  #include "lua.h"
7  #include "lauxlib.h"
8  #include "lualib.h"
9  static int db_getregistry (lua_State *L) {
10    lua_pushvalue(L, LUA_REGISTRYINDEX);
11    return 1;
12  }
13  static int db_getmetatable (lua_State *L) {
<span onclick='openModal()' class='match'>14    luaL_checkany(L, 1);
15    if (!lua_getmetatable(L, 1)) {
16      lua_pushnil(L);  &bsol;* no metatable */
</span>17    }
18    return 1;
19  }
20  static int db_setmetatable (lua_State *L) {
21    int t = lua_type(L, 2);
22    luaL_argcheck(L, t == LUA_TNIL || t == LUA_TTABLE, 2,
23                      "nil or table expected");
24    lua_settop(L, 2);
25    lua_pushboolean(L, lua_setmetatable(L, 1));
26    return 1;
27  }
28  static int db_getfenv (lua_State *L) {
29    luaL_checkany(L, 1);
30    lua_getfenv(L, 1);
31    return 1;
32  }
33  static int db_setfenv (lua_State *L) {
34    luaL_checktype(L, 2, LUA_TTABLE);
35    lua_settop(L, 2);
36    if (lua_setfenv(L, 1) == 0)
37      luaL_error(L, LUA_QL("setfenv")
38                    " cannot change environment of given object");
39    return 1;
40  }
41  static void settabss (lua_State *L, const char *i, const char *v) {
42    lua_pushstring(L, v);
43    lua_setfield(L, -2, i);
44  }
45  static void settabsi (lua_State *L, const char *i, int v) {
46    lua_pushinteger(L, v);
47    lua_setfield(L, -2, i);
48  }
49  static lua_State *getthread (lua_State *L, int *arg) {
50    if (lua_isthread(L, 1)) {
51      *arg = 1;
52      return lua_tothread(L, 1);
53    }
54    else {
55      *arg = 0;
56      return L;
57    }
58  }
59  static void treatstackoption (lua_State *L, lua_State *L1, const char *fname) {
60    if (L == L1) {
61      lua_pushvalue(L, -2);
62      lua_remove(L, -3);
63    }
64    else
65      lua_xmove(L1, L, 1);
66    lua_setfield(L, -2, fname);
67  }
68  static int db_getinfo (lua_State *L) {
69    lua_Debug ar;
70    int arg;
71    lua_State *L1 = getthread(L, &arg);
72    const char *options = luaL_optstring(L, arg+2, "flnSu");
73    if (lua_isnumber(L, arg+1)) {
74      if (!lua_getstack(L1, (int)lua_tointeger(L, arg+1), &ar)) {
75        lua_pushnil(L);  &bsol;* level out of range */
76        return 1;
77      }
78    }
79    else if (lua_isfunction(L, arg+1)) {
80      lua_pushfstring(L, ">%s", options);
81      options = lua_tostring(L, -1);
82      lua_pushvalue(L, arg+1);
83      lua_xmove(L, L1, 1);
84    }
85    else
86      return luaL_argerror(L, arg+1, "function or level expected");
87    if (!lua_getinfo(L1, options, &ar))
88      return luaL_argerror(L, arg+2, "invalid option");
89    lua_createtable(L, 0, 2);
90    if (strchr(options, 'S')) {
91      settabss(L, "source", ar.source);
92      settabss(L, "short_src", ar.short_src);
93      settabsi(L, "linedefined", ar.linedefined);
94      settabsi(L, "lastlinedefined", ar.lastlinedefined);
95      settabss(L, "what", ar.what);
96    }
97    if (strchr(options, 'l'))
98      settabsi(L, "currentline", ar.currentline);
99    if (strchr(options, 'u'))
100      settabsi(L, "nups", ar.nups);
101    if (strchr(options, 'n')) {
102      settabss(L, "name", ar.name);
103      settabss(L, "namewhat", ar.namewhat);
104    }
105    if (strchr(options, 'L'))
106      treatstackoption(L, L1, "activelines");
107    if (strchr(options, 'f'))
108      treatstackoption(L, L1, "func");
109    return 1;  &bsol;* return table */
110  }
111  static int db_getlocal (lua_State *L) {
112    int arg;
113    lua_State *L1 = getthread(L, &arg);
114    lua_Debug ar;
115    const char *name;
116    if (!lua_getstack(L1, luaL_checkint(L, arg+1), &ar))  &bsol;* out of range? */
117      return luaL_argerror(L, arg+1, "level out of range");
118    name = lua_getlocal(L1, &ar, luaL_checkint(L, arg+2));
119    if (name) {
120      lua_xmove(L1, L, 1);
121      lua_pushstring(L, name);
122      lua_pushvalue(L, -2);
123      return 2;
124    }
125    else {
126      lua_pushnil(L);
127      return 1;
128    }
129  }
130  static int db_setlocal (lua_State *L) {
131    int arg;
132    lua_State *L1 = getthread(L, &arg);
133    lua_Debug ar;
134    if (!lua_getstack(L1, luaL_checkint(L, arg+1), &ar))  &bsol;* out of range? */
135      return luaL_argerror(L, arg+1, "level out of range");
136    luaL_checkany(L, arg+3);
137    lua_settop(L, arg+3);
138    lua_xmove(L, L1, 1);
139    lua_pushstring(L, lua_setlocal(L1, &ar, luaL_checkint(L, arg+2)));
140    return 1;
141  }
142  static int auxupvalue (lua_State *L, int get) {
143    const char *name;
144    int n = luaL_checkint(L, 2);
145    luaL_checktype(L, 1, LUA_TFUNCTION);
146    if (lua_iscfunction(L, 1)) return 0;  &bsol;* cannot touch C upvalues from Lua */
147    name = get ? lua_getupvalue(L, 1, n) : lua_setupvalue(L, 1, n);
148    if (name == NULL) return 0;
149    lua_pushstring(L, name);
150    lua_insert(L, -(get+1));
151    return get + 1;
152  }
153  static int db_getupvalue (lua_State *L) {
154    return auxupvalue(L, 1);
155  }
156  static int db_setupvalue (lua_State *L) {
157    luaL_checkany(L, 3);
158    return auxupvalue(L, 0);
159  }
160  static const char KEY_HOOK = 'h';
161  static void hookf (lua_State *L, lua_Debug *ar) {
162    static const char *const hooknames[] =
163      {"call", "return", "line", "count", "tail return"};
164    lua_pushlightuserdata(L, (void *)&KEY_HOOK);
165    lua_rawget(L, LUA_REGISTRYINDEX);
166    lua_pushlightuserdata(L, L);
167    lua_rawget(L, -2);
168    if (lua_isfunction(L, -1)) {
169      lua_pushstring(L, hooknames[(int)ar->event]);
170      if (ar->currentline >= 0)
171        lua_pushinteger(L, ar->currentline);
172      else lua_pushnil(L);
173      lua_assert(lua_getinfo(L, "lS", ar));
174      lua_call(L, 2, 0);
175    }
176  }
177  static int makemask (const char *smask, int count) {
178    int mask = 0;
179    if (strchr(smask, 'c')) mask |= LUA_MASKCALL;
180    if (strchr(smask, 'r')) mask |= LUA_MASKRET;
181    if (strchr(smask, 'l')) mask |= LUA_MASKLINE;
182    if (count > 0) mask |= LUA_MASKCOUNT;
183    return mask;
184  }
185  static char *unmakemask (int mask, char *smask) {
186    int i = 0;
187    if (mask & LUA_MASKCALL) smask[i++] = 'c';
188    if (mask & LUA_MASKRET) smask[i++] = 'r';
189    if (mask & LUA_MASKLINE) smask[i++] = 'l';
190    smask[i] = '\0';
191    return smask;
192  }
193  static void gethooktable (lua_State *L) {
194    lua_pushlightuserdata(L, (void *)&KEY_HOOK);
195    lua_rawget(L, LUA_REGISTRYINDEX);
196    if (!lua_istable(L, -1)) {
197      lua_pop(L, 1);
198      lua_createtable(L, 0, 1);
199      lua_pushlightuserdata(L, (void *)&KEY_HOOK);
200      lua_pushvalue(L, -2);
201      lua_rawset(L, LUA_REGISTRYINDEX);
202    }
203  }
204  static int db_sethook (lua_State *L) {
205    int arg, mask, count;
206    lua_Hook func;
207    lua_State *L1 = getthread(L, &arg);
208    if (lua_isnoneornil(L, arg+1)) {
209      lua_settop(L, arg+1);
210      func = NULL; mask = 0; count = 0;  &bsol;* turn off hooks */
211    }
212    else {
213      const char *smask = luaL_checkstring(L, arg+2);
214      luaL_checktype(L, arg+1, LUA_TFUNCTION);
215      count = luaL_optint(L, arg+3, 0);
216      func = hookf; mask = makemask(smask, count);
217    }
218    gethooktable(L);
219    lua_pushlightuserdata(L, L1);
220    lua_pushvalue(L, arg+1);
221    lua_rawset(L, -3);  &bsol;* set new hook */
222    lua_pop(L, 1);  &bsol;* remove hook table */
223    lua_sethook(L1, func, mask, count);  &bsol;* set hooks */
224    return 0;
225  }
226  static int db_gethook (lua_State *L) {
227    int arg;
228    lua_State *L1 = getthread(L, &arg);
229    char buff[5];
230    int mask = lua_gethookmask(L1);
231    lua_Hook hook = lua_gethook(L1);
232    if (hook != NULL && hook != hookf)  &bsol;* external hook? */
233      lua_pushliteral(L, "external hook");
234    else {
235      gethooktable(L);
236      lua_pushlightuserdata(L, L1);
237      lua_rawget(L, -2);   &bsol;* get hook */
238      lua_remove(L, -2);  &bsol;* remove hook table */
239    }
240    lua_pushstring(L, unmakemask(mask, buff));
241    lua_pushinteger(L, lua_gethookcount(L1));
242    return 3;
243  }
244  static int db_debug (lua_State *L) {
245    for (;;) {
246      char buffer[250];
247      fputs("lua_debug> ", stderr);
248      if (fgets(buffer, sizeof(buffer), stdin) == 0 ||
249          strcmp(buffer, "cont\n") == 0)
250        return 0;
251      if (luaL_loadbuffer(L, buffer, strlen(buffer), "=(debug command)") ||
252          lua_pcall(L, 0, 0, 0)) {
253        fputs(lua_tostring(L, -1), stderr);
254        fputs("\n", stderr);
255      }
256      lua_settop(L, 0);  &bsol;* remove eventual returns */
257    }
258  }
259  #define LEVELS1	12	&bsol;* size of the first part of the stack */
260  #define LEVELS2	10	&bsol;* size of the second part of the stack */
261  static int db_errorfb (lua_State *L) {
262    int level;
263    int firstpart = 1;  &bsol;* still before eventual `...' */
264    int arg;
265    lua_State *L1 = getthread(L, &arg);
266    lua_Debug ar;
267    if (lua_isnumber(L, arg+2)) {
268      level = (int)lua_tointeger(L, arg+2);
269      lua_pop(L, 1);
270    }
271    else
272      level = (L == L1) ? 1 : 0;  &bsol;* level 0 may be this own function */
273    if (lua_gettop(L) == arg)
274      lua_pushliteral(L, "");
275    else if (!lua_isstring(L, arg+1)) return 1;  &bsol;* message is not a string */
276    else lua_pushliteral(L, "\n");
277    lua_pushliteral(L, "stack traceback:");
278    while (lua_getstack(L1, level++, &ar)) {
279      if (level > LEVELS1 && firstpart) {
280        if (!lua_getstack(L1, level+LEVELS2, &ar))
281          level--;  &bsol;* keep going */
282        else {
283          lua_pushliteral(L, "\n\t...");  &bsol;* too many levels */
284          while (lua_getstack(L1, level+LEVELS2, &ar))  &bsol;* find last levels */
285            level++;
286        }
287        firstpart = 0;
288        continue;
289      }
290      lua_pushliteral(L, "\n\t");
291      lua_getinfo(L1, "Snl", &ar);
292      lua_pushfstring(L, "%s:", ar.short_src);
293      if (ar.currentline > 0)
294        lua_pushfstring(L, "%d:", ar.currentline);
295      if (*ar.namewhat != '\0')  &bsol;* is there a name? */
296          lua_pushfstring(L, " in function " LUA_QS, ar.name);
297      else {
298        if (*ar.what == 'm')  &bsol;* main? */
299          lua_pushfstring(L, " in main chunk");
300        else if (*ar.what == 'C' || *ar.what == 't')
301          lua_pushliteral(L, " ?");  &bsol;* C function or tail call */
302        else
303          lua_pushfstring(L, " in function <%s:%d>",
304                             ar.short_src, ar.linedefined);
305      }
306      lua_concat(L, lua_gettop(L) - arg);
307    }
308    lua_concat(L, lua_gettop(L) - arg);
309    return 1;
310  }
311  static const luaL_Reg dblib[] = {
312    {"debug", db_debug},
313    {"getfenv", db_getfenv},
314    {"gethook", db_gethook},
315    {"getinfo", db_getinfo},
316    {"getlocal", db_getlocal},
317    {"getregistry", db_getregistry},
318    {"getmetatable", db_getmetatable},
319    {"getupvalue", db_getupvalue},
320    {"setfenv", db_setfenv},
321    {"sethook", db_sethook},
322    {"setlocal", db_setlocal},
323    {"setmetatable", db_setmetatable},
324    {"setupvalue", db_setupvalue},
325    {"traceback", db_errorfb},
326    {NULL, NULL}
327  };
328  LUALIB_API int luaopen_debug (lua_State *L) {
329    luaL_register(L, LUA_DBLIBNAME, dblib);
330    return 1;
331  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from redis-MDEwOlJlcG9zaXRvcnkxMDgxMTA3MDY=-flat-lbaselib.c</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from redis-MDEwOlJlcG9zaXRvcnkxMDgxMTA3MDY=-flat-ldblib.c</div>
                </div>
                <div class="column column_space"><pre><code>67    luaL_checkany(L, 1);
68    if (!lua_getmetatable(L, 1)) {
69      lua_pushnil(L);
70      return 1;  &bsol;* no metatable */
</pre></code></div>
                <div class="column column_space"><pre><code>14    luaL_checkany(L, 1);
15    if (!lua_getmetatable(L, 1)) {
16      lua_pushnil(L);  &bsol;* no metatable */
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    