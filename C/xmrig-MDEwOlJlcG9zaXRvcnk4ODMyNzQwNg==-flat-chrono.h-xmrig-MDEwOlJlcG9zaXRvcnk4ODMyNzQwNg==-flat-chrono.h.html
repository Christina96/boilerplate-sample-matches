
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 28, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>xmrig-MDEwOlJlcG9zaXRvcnk4ODMyNzQwNg==-flat-chrono.h</h3>
            <pre><code>1  #ifndef FMT_CHRONO_H_
2  #define FMT_CHRONO_H_
3  #include <chrono>
4  #include <ctime>
5  #include <locale>
6  #include <sstream>
7  #include "format.h"
8  #include "locale.h"
9  FMT_BEGIN_NAMESPACE
10  #ifndef FMT_SAFE_DURATION_CAST
11  #  define FMT_SAFE_DURATION_CAST 1
12  #endif
13  #if FMT_SAFE_DURATION_CAST
14  namespace safe_duration_cast {
15  template <typename To, typename From,
16            FMT_ENABLE_IF(!std::is_same<From, To>::value &&
17                          std::numeric_limits<From>::is_signed ==
18                              std::numeric_limits<To>::is_signed)>
19  FMT_CONSTEXPR To lossless_integral_conversion(const From from, int& ec) {
20    ec = 0;
21    using F = std::numeric_limits<From>;
22    using T = std::numeric_limits<To>;
23    static_assert(F::is_integer, "From must be integral");
24    static_assert(T::is_integer, "To must be integral");
25    if (F::digits <= T::digits) {
26    } else {
27      if (from < (T::min)() || from > (T::max)()) {
28        ec = 1;
29        return {};
30      }
31    }
32    return static_cast<To>(from);
33  }
34  template <typename To, typename From,
35            FMT_ENABLE_IF(!std::is_same<From, To>::value &&
36                          std::numeric_limits<From>::is_signed !=
37                              std::numeric_limits<To>::is_signed)>
38  FMT_CONSTEXPR To lossless_integral_conversion(const From from, int& ec) {
39    ec = 0;
40    using F = std::numeric_limits<From>;
41    using T = std::numeric_limits<To>;
42    static_assert(F::is_integer, "From must be integral");
43    static_assert(T::is_integer, "To must be integral");
44    if (detail::const_check(F::is_signed && !T::is_signed)) {
45      if (fmt::detail::is_negative(from)) {
46        ec = 1;
47        return {};
48      }
49      if (F::digits > T::digits &&
50          from > static_cast<From>(detail::max_value<To>())) {
51        ec = 1;
52        return {};
53      }
54    }
55    if (!F::is_signed && T::is_signed && F::digits >= T::digits &&
<span onclick='openModal()' class='match'>56        from > static_cast<From>(detail::max_value<To>())) {
57      ec = 1;
58      return {};
59    }
60    return static_cast<To>(from);  
</span>61  }
62  template <typename To, typename From,
63            FMT_ENABLE_IF(std::is_same<From, To>::value)>
64  FMT_CONSTEXPR To lossless_integral_conversion(const From from, int& ec) {
65    ec = 0;
66    return from;
67  }  
68  template <typename To, typename From,
69            FMT_ENABLE_IF(!std::is_same<From, To>::value)>
70  FMT_CONSTEXPR To safe_float_conversion(const From from, int& ec) {
71    ec = 0;
72    using T = std::numeric_limits<To>;
73    static_assert(std::is_floating_point<From>::value, "From must be floating");
74    static_assert(std::is_floating_point<To>::value, "To must be floating");
75    if (std::isfinite(from)) {
76      if (from >= T::lowest() && from <= (T::max)()) {
77        return static_cast<To>(from);
78      }
79      ec = 1;
80      return {};
81    }
82    return static_cast<To>(from);
83  }  
84  template <typename To, typename From,
85            FMT_ENABLE_IF(std::is_same<From, To>::value)>
86  FMT_CONSTEXPR To safe_float_conversion(const From from, int& ec) {
87    ec = 0;
88    static_assert(std::is_floating_point<From>::value, "From must be floating");
89    return from;
90  }
91  template <typename To, typename FromRep, typename FromPeriod,
92            FMT_ENABLE_IF(std::is_integral<FromRep>::value),
93            FMT_ENABLE_IF(std::is_integral<typename To::rep>::value)>
94  To safe_duration_cast(std::chrono::duration<FromRep, FromPeriod> from,
95                        int& ec) {
96    using From = std::chrono::duration<FromRep, FromPeriod>;
97    ec = 0;
98    struct Factor
99        : std::ratio_divide<typename From::period, typename To::period> {};
100    static_assert(Factor::num > 0, "num must be positive");
101    static_assert(Factor::den > 0, "den must be positive");
102    using IntermediateRep =
103        typename std::common_type<typename From::rep, typename To::rep,
104                                  decltype(Factor::num)>::type;
105    IntermediateRep count =
106        lossless_integral_conversion<IntermediateRep>(from.count(), ec);
107    if (ec) return {};
108    if (detail::const_check(Factor::num != 1)) {
109      const auto max1 = detail::max_value<IntermediateRep>() / Factor::num;
110      if (count > max1) {
111        ec = 1;
112        return {};
113      }
114      const auto min1 =
115          (std::numeric_limits<IntermediateRep>::min)() / Factor::num;
116      if (count < min1) {
117        ec = 1;
118        return {};
119      }
120      count *= Factor::num;
121    }
122    if (detail::const_check(Factor::den != 1)) count /= Factor::den;
123    auto tocount = lossless_integral_conversion<typename To::rep>(count, ec);
124    return ec ? To() : To(tocount);
125  }
126  template <typename To, typename FromRep, typename FromPeriod,
127            FMT_ENABLE_IF(std::is_floating_point<FromRep>::value),
128            FMT_ENABLE_IF(std::is_floating_point<typename To::rep>::value)>
129  To safe_duration_cast(std::chrono::duration<FromRep, FromPeriod> from,
130                        int& ec) {
131    using From = std::chrono::duration<FromRep, FromPeriod>;
132    ec = 0;
133    if (std::isnan(from.count())) {
134      return To{std::numeric_limits<typename To::rep>::quiet_NaN()};
135    }
136    if (std::isinf(from.count())) {
137      return To{from.count()};
138    }
139    struct Factor
140        : std::ratio_divide<typename From::period, typename To::period> {};
141    static_assert(Factor::num > 0, "num must be positive");
142    static_assert(Factor::den > 0, "den must be positive");
143    using IntermediateRep =
144        typename std::common_type<typename From::rep, typename To::rep,
145                                  decltype(Factor::num)>::type;
146    IntermediateRep count =
147        safe_float_conversion<IntermediateRep>(from.count(), ec);
148    if (ec) {
149      return {};
150    }
151    if (Factor::num != 1) {
152      constexpr auto max1 = detail::max_value<IntermediateRep>() /
153                            static_cast<IntermediateRep>(Factor::num);
154      if (count > max1) {
155        ec = 1;
156        return {};
157      }
158      constexpr auto min1 = std::numeric_limits<IntermediateRep>::lowest() /
159                            static_cast<IntermediateRep>(Factor::num);
160      if (count < min1) {
161        ec = 1;
162        return {};
163      }
164      count *= static_cast<IntermediateRep>(Factor::num);
165    }
166    if (Factor::den != 1) {
167      using common_t = typename std::common_type<IntermediateRep, intmax_t>::type;
168      count /= static_cast<common_t>(Factor::den);
169    }
170    using ToRep = typename To::rep;
171    const ToRep tocount = safe_float_conversion<ToRep>(count, ec);
172    if (ec) {
173      return {};
174    }
175    return To{tocount};
176  }
177  }  
178  #endif
179  #define FMT_NOMACRO
180  namespace detail {
181  inline null<> localtime_r FMT_NOMACRO(...) { return null<>(); }
182  inline null<> localtime_s(...) { return null<>(); }
183  inline null<> gmtime_r(...) { return null<>(); }
184  inline null<> gmtime_s(...) { return null<>(); }
185  }  
186  inline std::tm localtime(std::time_t time) {
187    struct dispatcher {
188      std::time_t time_;
189      std::tm tm_;
190      dispatcher(std::time_t t) : time_(t) {}
191      bool run() {
192        using namespace fmt::detail;
193        return handle(localtime_r(&time_, &tm_));
194      }
195      bool handle(std::tm* tm) { return tm != nullptr; }
196      bool handle(detail::null<>) {
197        using namespace fmt::detail;
198        return fallback(localtime_s(&tm_, &time_));
199      }
200      bool fallback(int res) { return res == 0; }
201  #if !FMT_MSC_VER
202      bool fallback(detail::null<>) {
203        using namespace fmt::detail;
204        std::tm* tm = std::localtime(&time_);
205        if (tm) tm_ = *tm;
206        return tm != nullptr;
207      }
208  #endif
209    };
210    dispatcher lt(time);
211    if (!lt.run()) FMT_THROW(format_error("time_t value out of range"));
212    return lt.tm_;
213  }
214  inline std::tm localtime(
215      std::chrono::time_point<std::chrono::system_clock> time_point) {
216    return localtime(std::chrono::system_clock::to_time_t(time_point));
217  }
218  inline std::tm gmtime(std::time_t time) {
219    struct dispatcher {
220      std::time_t time_;
221      std::tm tm_;
222      dispatcher(std::time_t t) : time_(t) {}
223      bool run() {
224        using namespace fmt::detail;
225        return handle(gmtime_r(&time_, &tm_));
226      }
227      bool handle(std::tm* tm) { return tm != nullptr; }
228      bool handle(detail::null<>) {
229        using namespace fmt::detail;
230        return fallback(gmtime_s(&tm_, &time_));
231      }
232      bool fallback(int res) { return res == 0; }
233  #if !FMT_MSC_VER
234      bool fallback(detail::null<>) {
235        std::tm* tm = std::gmtime(&time_);
236        if (tm) tm_ = *tm;
237        return tm != nullptr;
238      }
239  #endif
240    };
241    dispatcher gt(time);
242    if (!gt.run()) FMT_THROW(format_error("time_t value out of range"));
243    return gt.tm_;
244  }
245  inline std::tm gmtime(
246      std::chrono::time_point<std::chrono::system_clock> time_point) {
247    return gmtime(std::chrono::system_clock::to_time_t(time_point));
248  }
249  namespace detail {
250  inline size_t strftime(char* str, size_t count, const char* format,
251                         const std::tm* time) {
252    return std::strftime(str, count, format, time);
253  }
254  inline size_t strftime(wchar_t* str, size_t count, const wchar_t* format,
255                         const std::tm* time) {
256    return std::wcsftime(str, count, format, time);
257  }
258  }  
259  template <typename Char>
260  struct formatter<std::chrono::time_point<std::chrono::system_clock>, Char>
261      : formatter<std::tm, Char> {
262    template <typename FormatContext>
263    auto format(std::chrono::time_point<std::chrono::system_clock> val,
264                FormatContext& ctx) -> decltype(ctx.out()) {
265      std::tm time = localtime(val);
266      return formatter<std::tm, Char>::format(time, ctx);
267    }
268  };
269  template <typename Char> struct formatter<std::tm, Char> {
270    template <typename ParseContext>
271    auto parse(ParseContext& ctx) -> decltype(ctx.begin()) {
272      auto it = ctx.begin();
273      if (it != ctx.end() && *it == ':') ++it;
274      auto end = it;
275      while (end != ctx.end() && *end != '}') ++end;
276      tm_format.reserve(detail::to_unsigned(end - it + 1));
277      tm_format.append(it, end);
278      tm_format.push_back('\0');
279      return end;
280    }
281    template <typename FormatContext>
282    auto format(const std::tm& tm, FormatContext& ctx) -> decltype(ctx.out()) {
283      basic_memory_buffer<Char> buf;
284      size_t start = buf.size();
285      for (;;) {
286        size_t size = buf.capacity() - start;
287        size_t count = detail::strftime(&buf[start], size, &tm_format[0], &tm);
288        if (count != 0) {
289          buf.resize(start + count);
290          break;
291        }
292        if (size >= tm_format.size() * 256) {
293          break;
294        }
295        const size_t MIN_GROWTH = 10;
296        buf.reserve(buf.capacity() + (size > MIN_GROWTH ? size : MIN_GROWTH));
297      }
298      return std::copy(buf.begin(), buf.end(), ctx.out());
299    }
300    basic_memory_buffer<Char> tm_format;
301  };
302  namespace detail {
303  template <typename Period> FMT_CONSTEXPR const char* get_units() {
304    return nullptr;
305  }
306  template <> FMT_CONSTEXPR const char* get_units<std::atto>() { return "as"; }
307  template <> FMT_CONSTEXPR const char* get_units<std::femto>() { return "fs"; }
308  template <> FMT_CONSTEXPR const char* get_units<std::pico>() { return "ps"; }
309  template <> FMT_CONSTEXPR const char* get_units<std::nano>() { return "ns"; }
310  template <> FMT_CONSTEXPR const char* get_units<std::micro>() { return "µs"; }
311  template <> FMT_CONSTEXPR const char* get_units<std::milli>() { return "ms"; }
312  template <> FMT_CONSTEXPR const char* get_units<std::centi>() { return "cs"; }
313  template <> FMT_CONSTEXPR const char* get_units<std::deci>() { return "ds"; }
314  template <> FMT_CONSTEXPR const char* get_units<std::ratio<1>>() { return "s"; }
315  template <> FMT_CONSTEXPR const char* get_units<std::deca>() { return "das"; }
316  template <> FMT_CONSTEXPR const char* get_units<std::hecto>() { return "hs"; }
317  template <> FMT_CONSTEXPR const char* get_units<std::kilo>() { return "ks"; }
318  template <> FMT_CONSTEXPR const char* get_units<std::mega>() { return "Ms"; }
319  template <> FMT_CONSTEXPR const char* get_units<std::giga>() { return "Gs"; }
320  template <> FMT_CONSTEXPR const char* get_units<std::tera>() { return "Ts"; }
321  template <> FMT_CONSTEXPR const char* get_units<std::peta>() { return "Ps"; }
322  template <> FMT_CONSTEXPR const char* get_units<std::exa>() { return "Es"; }
323  template <> FMT_CONSTEXPR const char* get_units<std::ratio<60>>() {
324    return "m";
325  }
326  template <> FMT_CONSTEXPR const char* get_units<std::ratio<3600>>() {
327    return "h";
328  }
329  enum class numeric_system {
330    standard,
331    alternative
332  };
333  template <typename Char, typename Handler>
334  FMT_CONSTEXPR const Char* parse_chrono_format(const Char* begin,
335                                                const Char* end,
336                                                Handler&& handler) {
337    auto ptr = begin;
338    while (ptr != end) {
339      auto c = *ptr;
340      if (c == '}') break;
341      if (c != '%') {
342        ++ptr;
343        continue;
344      }
345      if (begin != ptr) handler.on_text(begin, ptr);
346      ++ptr;  
347      if (ptr == end) FMT_THROW(format_error("invalid format"));
348      c = *ptr++;
349      switch (c) {
350      case '%':
351        handler.on_text(ptr - 1, ptr);
352        break;
353      case 'n': {
354        const Char newline[] = {'\n'};
355        handler.on_text(newline, newline + 1);
356        break;
357      }
358      case 't': {
359        const Char tab[] = {'\t'};
360        handler.on_text(tab, tab + 1);
361        break;
362      }
363      case 'a':
364        handler.on_abbr_weekday();
365        break;
366      case 'A':
367        handler.on_full_weekday();
368        break;
369      case 'w':
370        handler.on_dec0_weekday(numeric_system::standard);
371        break;
372      case 'u':
373        handler.on_dec1_weekday(numeric_system::standard);
374        break;
375      case 'b':
376        handler.on_abbr_month();
377        break;
378      case 'B':
379        handler.on_full_month();
380        break;
381      case 'H':
382        handler.on_24_hour(numeric_system::standard);
383        break;
384      case 'I':
385        handler.on_12_hour(numeric_system::standard);
386        break;
387      case 'M':
388        handler.on_minute(numeric_system::standard);
389        break;
390      case 'S':
391        handler.on_second(numeric_system::standard);
392        break;
393      case 'c':
394        handler.on_datetime(numeric_system::standard);
395        break;
396      case 'x':
397        handler.on_loc_date(numeric_system::standard);
398        break;
399      case 'X':
400        handler.on_loc_time(numeric_system::standard);
401        break;
402      case 'D':
403        handler.on_us_date();
404        break;
405      case 'F':
406        handler.on_iso_date();
407        break;
408      case 'r':
409        handler.on_12_hour_time();
410        break;
411      case 'R':
412        handler.on_24_hour_time();
413        break;
414      case 'T':
415        handler.on_iso_time();
416        break;
417      case 'p':
418        handler.on_am_pm();
419        break;
420      case 'Q':
421        handler.on_duration_value();
422        break;
423      case 'q':
424        handler.on_duration_unit();
425        break;
426      case 'z':
427        handler.on_utc_offset();
428        break;
429      case 'Z':
430        handler.on_tz_name();
431        break;
432      case 'E': {
433        if (ptr == end) FMT_THROW(format_error("invalid format"));
434        c = *ptr++;
435        switch (c) {
436        case 'c':
437          handler.on_datetime(numeric_system::alternative);
438          break;
439        case 'x':
440          handler.on_loc_date(numeric_system::alternative);
441          break;
442        case 'X':
443          handler.on_loc_time(numeric_system::alternative);
444          break;
445        default:
446          FMT_THROW(format_error("invalid format"));
447        }
448        break;
449      }
450      case 'O':
451        if (ptr == end) FMT_THROW(format_error("invalid format"));
452        c = *ptr++;
453        switch (c) {
454        case 'w':
455          handler.on_dec0_weekday(numeric_system::alternative);
456          break;
457        case 'u':
458          handler.on_dec1_weekday(numeric_system::alternative);
459          break;
460        case 'H':
461          handler.on_24_hour(numeric_system::alternative);
462          break;
463        case 'I':
464          handler.on_12_hour(numeric_system::alternative);
465          break;
466        case 'M':
467          handler.on_minute(numeric_system::alternative);
468          break;
469        case 'S':
470          handler.on_second(numeric_system::alternative);
471          break;
472        default:
473          FMT_THROW(format_error("invalid format"));
474        }
475        break;
476      default:
477        FMT_THROW(format_error("invalid format"));
478      }
479      begin = ptr;
480    }
481    if (begin != ptr) handler.on_text(begin, ptr);
482    return ptr;
483  }
484  struct chrono_format_checker {
485    FMT_NORETURN void report_no_date() { FMT_THROW(format_error("no date")); }
486    template <typename Char> void on_text(const Char*, const Char*) {}
487    FMT_NORETURN void on_abbr_weekday() { report_no_date(); }
488    FMT_NORETURN void on_full_weekday() { report_no_date(); }
489    FMT_NORETURN void on_dec0_weekday(numeric_system) { report_no_date(); }
490    FMT_NORETURN void on_dec1_weekday(numeric_system) { report_no_date(); }
491    FMT_NORETURN void on_abbr_month() { report_no_date(); }
492    FMT_NORETURN void on_full_month() { report_no_date(); }
493    void on_24_hour(numeric_system) {}
494    void on_12_hour(numeric_system) {}
495    void on_minute(numeric_system) {}
496    void on_second(numeric_system) {}
497    FMT_NORETURN void on_datetime(numeric_system) { report_no_date(); }
498    FMT_NORETURN void on_loc_date(numeric_system) { report_no_date(); }
499    FMT_NORETURN void on_loc_time(numeric_system) { report_no_date(); }
500    FMT_NORETURN void on_us_date() { report_no_date(); }
501    FMT_NORETURN void on_iso_date() { report_no_date(); }
502    void on_12_hour_time() {}
503    void on_24_hour_time() {}
504    void on_iso_time() {}
505    void on_am_pm() {}
506    void on_duration_value() {}
507    void on_duration_unit() {}
508    FMT_NORETURN void on_utc_offset() { report_no_date(); }
509    FMT_NORETURN void on_tz_name() { report_no_date(); }
510  };
511  template <typename T, FMT_ENABLE_IF(std::is_integral<T>::value)>
512  inline bool isnan(T) {
513    return false;
514  }
515  template <typename T, FMT_ENABLE_IF(std::is_floating_point<T>::value)>
516  inline bool isnan(T value) {
517    return std::isnan(value);
518  }
519  template <typename T, FMT_ENABLE_IF(std::is_integral<T>::value)>
520  inline bool isfinite(T) {
521    return true;
522  }
523  template <typename T, FMT_ENABLE_IF(std::is_floating_point<T>::value)>
524  inline bool isfinite(T value) {
525    return std::isfinite(value);
526  }
527  template <typename T, FMT_ENABLE_IF(std::is_integral<T>::value)>
528  inline int to_nonnegative_int(T value, int upper) {
529    FMT_ASSERT(value >= 0 && value <= upper, "invalid value");
530    (void)upper;
531    return static_cast<int>(value);
532  }
533  template <typename T, FMT_ENABLE_IF(!std::is_integral<T>::value)>
534  inline int to_nonnegative_int(T value, int upper) {
535    FMT_ASSERT(
536        std::isnan(value) || (value >= 0 && value <= static_cast<T>(upper)),
537        "invalid value");
538    (void)upper;
539    return static_cast<int>(value);
540  }
541  template <typename T, FMT_ENABLE_IF(std::is_integral<T>::value)>
542  inline T mod(T x, int y) {
543    return x % static_cast<T>(y);
544  }
545  template <typename T, FMT_ENABLE_IF(std::is_floating_point<T>::value)>
546  inline T mod(T x, int y) {
547    return std::fmod(x, static_cast<T>(y));
548  }
549  template <typename T, bool INTEGRAL = std::is_integral<T>::value>
550  struct make_unsigned_or_unchanged {
551    using type = T;
552  };
553  template <typename T> struct make_unsigned_or_unchanged<T, true> {
554    using type = typename std::make_unsigned<T>::type;
555  };
556  #if FMT_SAFE_DURATION_CAST
557  template <typename To, typename FromRep, typename FromPeriod>
558  To fmt_safe_duration_cast(std::chrono::duration<FromRep, FromPeriod> from) {
559    int ec;
560    To to = safe_duration_cast::safe_duration_cast<To>(from, ec);
561    if (ec) FMT_THROW(format_error("cannot format duration"));
562    return to;
563  }
564  #endif
565  template <typename Rep, typename Period,
566            FMT_ENABLE_IF(std::is_integral<Rep>::value)>
567  inline std::chrono::duration<Rep, std::milli> get_milliseconds(
568      std::chrono::duration<Rep, Period> d) {
569  #if FMT_SAFE_DURATION_CAST
570    using CommonSecondsType =
571        typename std::common_type<decltype(d), std::chrono::seconds>::type;
572    const auto d_as_common = fmt_safe_duration_cast<CommonSecondsType>(d);
573    const auto d_as_whole_seconds =
574        fmt_safe_duration_cast<std::chrono::seconds>(d_as_common);
575    const auto diff = d_as_common - d_as_whole_seconds;
576    const auto ms =
577        fmt_safe_duration_cast<std::chrono::duration<Rep, std::milli>>(diff);
578    return ms;
579  #else
580    auto s = std::chrono::duration_cast<std::chrono::seconds>(d);
581    return std::chrono::duration_cast<std::chrono::milliseconds>(d - s);
582  #endif
583  }
584  template <typename Rep, typename Period,
585            FMT_ENABLE_IF(std::is_floating_point<Rep>::value)>
586  inline std::chrono::duration<Rep, std::milli> get_milliseconds(
587      std::chrono::duration<Rep, Period> d) {
588    using common_type = typename std::common_type<Rep, std::intmax_t>::type;
589    auto ms = mod(d.count() * static_cast<common_type>(Period::num) /
590                      static_cast<common_type>(Period::den) * 1000,
591                  1000);
592    return std::chrono::duration<Rep, std::milli>(static_cast<Rep>(ms));
593  }
594  template <typename Char, typename Rep, typename OutputIt>
595  OutputIt format_duration_value(OutputIt out, Rep val, int precision) {
596    const Char pr_f[] = {'{', ':', '.', '{', '}', 'f', '}', 0};
597    if (precision >= 0) return format_to(out, pr_f, val, precision);
598    const Char fp_f[] = {'{', ':', 'g', '}', 0};
599    const Char format[] = {'{', '}', 0};
600    return format_to(out, std::is_floating_point<Rep>::value ? fp_f : format,
601                     val);
602  }
603  template <typename Char, typename OutputIt>
604  OutputIt copy_unit(string_view unit, OutputIt out, Char) {
605    return std::copy(unit.begin(), unit.end(), out);
606  }
607  template <typename OutputIt>
608  OutputIt copy_unit(string_view unit, OutputIt out, wchar_t) {
609    utf8_to_utf16 u(unit);
610    return std::copy(u.c_str(), u.c_str() + u.size(), out);
611  }
612  template <typename Char, typename Period, typename OutputIt>
613  OutputIt format_duration_unit(OutputIt out) {
614    if (const char* unit = get_units<Period>())
615      return copy_unit(string_view(unit), out, Char());
616    const Char num_f[] = {'[', '{', '}', ']', 's', 0};
617    if (const_check(Period::den == 1)) return format_to(out, num_f, Period::num);
618    const Char num_def_f[] = {'[', '{', '}', '/', '{', '}', ']', 's', 0};
619    return format_to(out, num_def_f, Period::num, Period::den);
620  }
621  template <typename FormatContext, typename OutputIt, typename Rep,
622            typename Period>
623  struct chrono_formatter {
624    FormatContext& context;
625    OutputIt out;
626    int precision;
627    using rep =
628        conditional_t<std::is_integral<Rep>::value && sizeof(Rep) < sizeof(int),
629                      unsigned, typename make_unsigned_or_unchanged<Rep>::type>;
630    rep val;
631    using seconds = std::chrono::duration<rep>;
632    seconds s;
633    using milliseconds = std::chrono::duration<rep, std::milli>;
634    bool negative;
635    using char_type = typename FormatContext::char_type;
636    explicit chrono_formatter(FormatContext& ctx, OutputIt o,
637                              std::chrono::duration<Rep, Period> d)
638        : context(ctx),
639          out(o),
640          val(static_cast<rep>(d.count())),
641          negative(false) {
642      if (d.count() < 0) {
643        val = 0 - val;
644        negative = true;
645      }
646  #if FMT_SAFE_DURATION_CAST
647      auto tmpval = std::chrono::duration<rep, Period>(val);
648      s = fmt_safe_duration_cast<seconds>(tmpval);
649  #else
650      s = std::chrono::duration_cast<seconds>(
651          std::chrono::duration<rep, Period>(val));
652  #endif
653    }
654    bool handle_nan_inf() {
655      if (isfinite(val)) {
656        return false;
657      }
658      if (isnan(val)) {
659        write_nan();
660        return true;
661      }
662      if (val > 0) {
663        write_pinf();
664      } else {
665        write_ninf();
666      }
667      return true;
668    }
669    Rep hour() const { return static_cast<Rep>(mod((s.count() / 3600), 24)); }
670    Rep hour12() const {
671      Rep hour = static_cast<Rep>(mod((s.count() / 3600), 12));
672      return hour <= 0 ? 12 : hour;
673    }
674    Rep minute() const { return static_cast<Rep>(mod((s.count() / 60), 60)); }
675    Rep second() const { return static_cast<Rep>(mod(s.count(), 60)); }
676    std::tm time() const {
677      auto time = std::tm();
678      time.tm_hour = to_nonnegative_int(hour(), 24);
679      time.tm_min = to_nonnegative_int(minute(), 60);
680      time.tm_sec = to_nonnegative_int(second(), 60);
681      return time;
682    }
683    void write_sign() {
684      if (negative) {
685        *out++ = '-';
686        negative = false;
687      }
688    }
689    void write(Rep value, int width) {
690      write_sign();
691      if (isnan(value)) return write_nan();
692      uint32_or_64_or_128_t<int> n =
693          to_unsigned(to_nonnegative_int(value, max_value<int>()));
694      int num_digits = detail::count_digits(n);
695      if (width > num_digits) out = std::fill_n(out, width - num_digits, '0');
696      out = format_decimal<char_type>(out, n, num_digits).end;
697    }
698    void write_nan() { std::copy_n("nan", 3, out); }
699    void write_pinf() { std::copy_n("inf", 3, out); }
700    void write_ninf() { std::copy_n("-inf", 4, out); }
701    void format_localized(const tm& time, char format, char modifier = 0) {
702      if (isnan(val)) return write_nan();
703      auto locale = context.locale().template get<std::locale>();
704      auto& facet = std::use_facet<std::time_put<char_type>>(locale);
705      std::basic_ostringstream<char_type> os;
706      os.imbue(locale);
707      facet.put(os, os, ' ', &time, format, modifier);
708      auto str = os.str();
709      std::copy(str.begin(), str.end(), out);
710    }
711    void on_text(const char_type* begin, const char_type* end) {
712      std::copy(begin, end, out);
713    }
714    void on_abbr_weekday() {}
715    void on_full_weekday() {}
716    void on_dec0_weekday(numeric_system) {}
717    void on_dec1_weekday(numeric_system) {}
718    void on_abbr_month() {}
719    void on_full_month() {}
720    void on_datetime(numeric_system) {}
721    void on_loc_date(numeric_system) {}
722    void on_loc_time(numeric_system) {}
723    void on_us_date() {}
724    void on_iso_date() {}
725    void on_utc_offset() {}
726    void on_tz_name() {}
727    void on_24_hour(numeric_system ns) {
728      if (handle_nan_inf()) return;
729      if (ns == numeric_system::standard) return write(hour(), 2);
730      auto time = tm();
731      time.tm_hour = to_nonnegative_int(hour(), 24);
732      format_localized(time, 'H', 'O');
733    }
734    void on_12_hour(numeric_system ns) {
735      if (handle_nan_inf()) return;
736      if (ns == numeric_system::standard) return write(hour12(), 2);
737      auto time = tm();
738      time.tm_hour = to_nonnegative_int(hour12(), 12);
739      format_localized(time, 'I', 'O');
740    }
741    void on_minute(numeric_system ns) {
742      if (handle_nan_inf()) return;
743      if (ns == numeric_system::standard) return write(minute(), 2);
744      auto time = tm();
745      time.tm_min = to_nonnegative_int(minute(), 60);
746      format_localized(time, 'M', 'O');
747    }
748    void on_second(numeric_system ns) {
749      if (handle_nan_inf()) return;
750      if (ns == numeric_system::standard) {
751        write(second(), 2);
752  #if FMT_SAFE_DURATION_CAST
753        using duration_rep = std::chrono::duration<rep, Period>;
754        using duration_Rep = std::chrono::duration<Rep, Period>;
755        auto tmpval = fmt_safe_duration_cast<duration_Rep>(duration_rep{val});
756  #else
757        auto tmpval = std::chrono::duration<Rep, Period>(val);
758  #endif
759        auto ms = get_milliseconds(tmpval);
760        if (ms != std::chrono::milliseconds(0)) {
761          *out++ = '.';
762          write(ms.count(), 3);
763        }
764        return;
765      }
766      auto time = tm();
767      time.tm_sec = to_nonnegative_int(second(), 60);
768      format_localized(time, 'S', 'O');
769    }
770    void on_12_hour_time() {
771      if (handle_nan_inf()) return;
772      format_localized(time(), 'r');
773    }
774    void on_24_hour_time() {
775      if (handle_nan_inf()) {
776        *out++ = ':';
777        handle_nan_inf();
778        return;
779      }
780      write(hour(), 2);
781      *out++ = ':';
782      write(minute(), 2);
783    }
784    void on_iso_time() {
785      on_24_hour_time();
786      *out++ = ':';
787      if (handle_nan_inf()) return;
788      write(second(), 2);
789    }
790    void on_am_pm() {
791      if (handle_nan_inf()) return;
792      format_localized(time(), 'p');
793    }
794    void on_duration_value() {
795      if (handle_nan_inf()) return;
796      write_sign();
797      out = format_duration_value<char_type>(out, val, precision);
798    }
799    void on_duration_unit() {
800      out = format_duration_unit<char_type, Period>(out);
801    }
802  };
803  }  
804  template <typename Rep, typename Period, typename Char>
805  struct formatter<std::chrono::duration<Rep, Period>, Char> {
806   private:
807    basic_format_specs<Char> specs;
808    int precision;
809    using arg_ref_type = detail::arg_ref<Char>;
810    arg_ref_type width_ref;
811    arg_ref_type precision_ref;
812    mutable basic_string_view<Char> format_str;
813    using duration = std::chrono::duration<Rep, Period>;
814    struct spec_handler {
815      formatter& f;
816      basic_format_parse_context<Char>& context;
817      basic_string_view<Char> format_str;
818      template <typename Id> FMT_CONSTEXPR arg_ref_type make_arg_ref(Id arg_id) {
819        context.check_arg_id(arg_id);
820        return arg_ref_type(arg_id);
821      }
822      FMT_CONSTEXPR arg_ref_type make_arg_ref(basic_string_view<Char> arg_id) {
823        context.check_arg_id(arg_id);
824        return arg_ref_type(arg_id);
825      }
826      FMT_CONSTEXPR arg_ref_type make_arg_ref(detail::auto_id) {
827        return arg_ref_type(context.next_arg_id());
828      }
829      void on_error(const char* msg) { FMT_THROW(format_error(msg)); }
830      void on_fill(basic_string_view<Char> fill) { f.specs.fill = fill; }
831      void on_align(align_t align) { f.specs.align = align; }
832      void on_width(int width) { f.specs.width = width; }
833      void on_precision(int _precision) { f.precision = _precision; }
834      void end_precision() {}
835      template <typename Id> void on_dynamic_width(Id arg_id) {
836        f.width_ref = make_arg_ref(arg_id);
837      }
838      template <typename Id> void on_dynamic_precision(Id arg_id) {
839        f.precision_ref = make_arg_ref(arg_id);
840      }
841    };
842    using iterator = typename basic_format_parse_context<Char>::iterator;
843    struct parse_range {
844      iterator begin;
845      iterator end;
846    };
847    FMT_CONSTEXPR parse_range do_parse(basic_format_parse_context<Char>& ctx) {
848      auto begin = ctx.begin(), end = ctx.end();
849      if (begin == end || *begin == '}') return {begin, begin};
850      spec_handler handler{*this, ctx, format_str};
851      begin = detail::parse_align(begin, end, handler);
852      if (begin == end) return {begin, begin};
853      begin = detail::parse_width(begin, end, handler);
854      if (begin == end) return {begin, begin};
855      if (*begin == '.') {
856        if (std::is_floating_point<Rep>::value)
857          begin = detail::parse_precision(begin, end, handler);
858        else
859          handler.on_error("precision not allowed for this argument type");
860      }
861      end = parse_chrono_format(begin, end, detail::chrono_format_checker());
862      return {begin, end};
863    }
864   public:
865    formatter() : precision(-1) {}
866    FMT_CONSTEXPR auto parse(basic_format_parse_context<Char>& ctx)
867        -> decltype(ctx.begin()) {
868      auto range = do_parse(ctx);
869      format_str = basic_string_view<Char>(
870          &*range.begin, detail::to_unsigned(range.end - range.begin));
871      return range.end;
872    }
873    template <typename FormatContext>
874    auto format(const duration& d, FormatContext& ctx) -> decltype(ctx.out()) {
875      auto begin = format_str.begin(), end = format_str.end();
876      basic_memory_buffer<Char> buf;
877      auto out = std::back_inserter(buf);
878      detail::handle_dynamic_spec<detail::width_checker>(specs.width, width_ref,
879                                                         ctx);
880      detail::handle_dynamic_spec<detail::precision_checker>(precision,
881                                                             precision_ref, ctx);
882      if (begin == end || *begin == '}') {
883        out = detail::format_duration_value<Char>(out, d.count(), precision);
884        detail::format_duration_unit<Char, Period>(out);
885      } else {
886        detail::chrono_formatter<FormatContext, decltype(out), Rep, Period> f(
887            ctx, out, d);
888        f.precision = precision;
889        parse_chrono_format(begin, end, f);
890      }
891      return detail::write(
892          ctx.out(), basic_string_view<Char>(buf.data(), buf.size()), specs);
893    }
894  };
895  FMT_END_NAMESPACE
896  #endif  
</code></pre>
        </div>
        <div class="column">
            <h3>xmrig-MDEwOlJlcG9zaXRvcnk4ODMyNzQwNg==-flat-chrono.h</h3>
            <pre><code>1  #ifndef FMT_CHRONO_H_
2  #define FMT_CHRONO_H_
3  #include <chrono>
4  #include <ctime>
5  #include <locale>
6  #include <sstream>
7  #include "format.h"
8  #include "locale.h"
9  FMT_BEGIN_NAMESPACE
10  #ifndef FMT_SAFE_DURATION_CAST
11  #  define FMT_SAFE_DURATION_CAST 1
12  #endif
13  #if FMT_SAFE_DURATION_CAST
14  namespace safe_duration_cast {
15  template <typename To, typename From,
16            FMT_ENABLE_IF(!std::is_same<From, To>::value &&
17                          std::numeric_limits<From>::is_signed ==
18                              std::numeric_limits<To>::is_signed)>
19  FMT_CONSTEXPR To lossless_integral_conversion(const From from, int& ec) {
20    ec = 0;
21    using F = std::numeric_limits<From>;
22    using T = std::numeric_limits<To>;
23    static_assert(F::is_integer, "From must be integral");
24    static_assert(T::is_integer, "To must be integral");
25    if (F::digits <= T::digits) {
26    } else {
27      if (from < (T::min)() || from > (T::max)()) {
28        ec = 1;
29        return {};
30      }
31    }
32    return static_cast<To>(from);
33  }
34  template <typename To, typename From,
35            FMT_ENABLE_IF(!std::is_same<From, To>::value &&
36                          std::numeric_limits<From>::is_signed !=
37                              std::numeric_limits<To>::is_signed)>
38  FMT_CONSTEXPR To lossless_integral_conversion(const From from, int& ec) {
39    ec = 0;
40    using F = std::numeric_limits<From>;
41    using T = std::numeric_limits<To>;
42    static_assert(F::is_integer, "From must be integral");
43    static_assert(T::is_integer, "To must be integral");
44    if (detail::const_check(F::is_signed && !T::is_signed)) {
45      if (fmt::detail::is_negative(from)) {
46        ec = 1;
47        return {};
48      }
49      if (F::digits > T::digits &&
50          from > static_cast<From>(detail::max_value<To>())) {
51        ec = 1;
52        return {};
53      }
54    }
55    if (!F::is_signed && T::is_signed && F::digits >= T::digits &&
<span onclick='openModal()' class='match'>56        from > static_cast<From>(detail::max_value<To>())) {
57      ec = 1;
58      return {};
59    }
60    return static_cast<To>(from);  
</span>61  }
62  template <typename To, typename From,
63            FMT_ENABLE_IF(std::is_same<From, To>::value)>
64  FMT_CONSTEXPR To lossless_integral_conversion(const From from, int& ec) {
65    ec = 0;
66    return from;
67  }  
68  template <typename To, typename From,
69            FMT_ENABLE_IF(!std::is_same<From, To>::value)>
70  FMT_CONSTEXPR To safe_float_conversion(const From from, int& ec) {
71    ec = 0;
72    using T = std::numeric_limits<To>;
73    static_assert(std::is_floating_point<From>::value, "From must be floating");
74    static_assert(std::is_floating_point<To>::value, "To must be floating");
75    if (std::isfinite(from)) {
76      if (from >= T::lowest() && from <= (T::max)()) {
77        return static_cast<To>(from);
78      }
79      ec = 1;
80      return {};
81    }
82    return static_cast<To>(from);
83  }  
84  template <typename To, typename From,
85            FMT_ENABLE_IF(std::is_same<From, To>::value)>
86  FMT_CONSTEXPR To safe_float_conversion(const From from, int& ec) {
87    ec = 0;
88    static_assert(std::is_floating_point<From>::value, "From must be floating");
89    return from;
90  }
91  template <typename To, typename FromRep, typename FromPeriod,
92            FMT_ENABLE_IF(std::is_integral<FromRep>::value),
93            FMT_ENABLE_IF(std::is_integral<typename To::rep>::value)>
94  To safe_duration_cast(std::chrono::duration<FromRep, FromPeriod> from,
95                        int& ec) {
96    using From = std::chrono::duration<FromRep, FromPeriod>;
97    ec = 0;
98    struct Factor
99        : std::ratio_divide<typename From::period, typename To::period> {};
100    static_assert(Factor::num > 0, "num must be positive");
101    static_assert(Factor::den > 0, "den must be positive");
102    using IntermediateRep =
103        typename std::common_type<typename From::rep, typename To::rep,
104                                  decltype(Factor::num)>::type;
105    IntermediateRep count =
106        lossless_integral_conversion<IntermediateRep>(from.count(), ec);
107    if (ec) return {};
108    if (detail::const_check(Factor::num != 1)) {
109      const auto max1 = detail::max_value<IntermediateRep>() / Factor::num;
110      if (count > max1) {
111        ec = 1;
112        return {};
113      }
114      const auto min1 =
115          (std::numeric_limits<IntermediateRep>::min)() / Factor::num;
116      if (count < min1) {
117        ec = 1;
118        return {};
119      }
120      count *= Factor::num;
121    }
122    if (detail::const_check(Factor::den != 1)) count /= Factor::den;
123    auto tocount = lossless_integral_conversion<typename To::rep>(count, ec);
124    return ec ? To() : To(tocount);
125  }
126  template <typename To, typename FromRep, typename FromPeriod,
127            FMT_ENABLE_IF(std::is_floating_point<FromRep>::value),
128            FMT_ENABLE_IF(std::is_floating_point<typename To::rep>::value)>
129  To safe_duration_cast(std::chrono::duration<FromRep, FromPeriod> from,
130                        int& ec) {
131    using From = std::chrono::duration<FromRep, FromPeriod>;
132    ec = 0;
133    if (std::isnan(from.count())) {
134      return To{std::numeric_limits<typename To::rep>::quiet_NaN()};
135    }
136    if (std::isinf(from.count())) {
137      return To{from.count()};
138    }
139    struct Factor
140        : std::ratio_divide<typename From::period, typename To::period> {};
141    static_assert(Factor::num > 0, "num must be positive");
142    static_assert(Factor::den > 0, "den must be positive");
143    using IntermediateRep =
144        typename std::common_type<typename From::rep, typename To::rep,
145                                  decltype(Factor::num)>::type;
146    IntermediateRep count =
147        safe_float_conversion<IntermediateRep>(from.count(), ec);
148    if (ec) {
149      return {};
150    }
151    if (Factor::num != 1) {
152      constexpr auto max1 = detail::max_value<IntermediateRep>() /
153                            static_cast<IntermediateRep>(Factor::num);
154      if (count > max1) {
155        ec = 1;
156        return {};
157      }
158      constexpr auto min1 = std::numeric_limits<IntermediateRep>::lowest() /
159                            static_cast<IntermediateRep>(Factor::num);
160      if (count < min1) {
161        ec = 1;
162        return {};
163      }
164      count *= static_cast<IntermediateRep>(Factor::num);
165    }
166    if (Factor::den != 1) {
167      using common_t = typename std::common_type<IntermediateRep, intmax_t>::type;
168      count /= static_cast<common_t>(Factor::den);
169    }
170    using ToRep = typename To::rep;
171    const ToRep tocount = safe_float_conversion<ToRep>(count, ec);
172    if (ec) {
173      return {};
174    }
175    return To{tocount};
176  }
177  }  
178  #endif
179  #define FMT_NOMACRO
180  namespace detail {
181  inline null<> localtime_r FMT_NOMACRO(...) { return null<>(); }
182  inline null<> localtime_s(...) { return null<>(); }
183  inline null<> gmtime_r(...) { return null<>(); }
184  inline null<> gmtime_s(...) { return null<>(); }
185  }  
186  inline std::tm localtime(std::time_t time) {
187    struct dispatcher {
188      std::time_t time_;
189      std::tm tm_;
190      dispatcher(std::time_t t) : time_(t) {}
191      bool run() {
192        using namespace fmt::detail;
193        return handle(localtime_r(&time_, &tm_));
194      }
195      bool handle(std::tm* tm) { return tm != nullptr; }
196      bool handle(detail::null<>) {
197        using namespace fmt::detail;
198        return fallback(localtime_s(&tm_, &time_));
199      }
200      bool fallback(int res) { return res == 0; }
201  #if !FMT_MSC_VER
202      bool fallback(detail::null<>) {
203        using namespace fmt::detail;
204        std::tm* tm = std::localtime(&time_);
205        if (tm) tm_ = *tm;
206        return tm != nullptr;
207      }
208  #endif
209    };
210    dispatcher lt(time);
211    if (!lt.run()) FMT_THROW(format_error("time_t value out of range"));
212    return lt.tm_;
213  }
214  inline std::tm localtime(
215      std::chrono::time_point<std::chrono::system_clock> time_point) {
216    return localtime(std::chrono::system_clock::to_time_t(time_point));
217  }
218  inline std::tm gmtime(std::time_t time) {
219    struct dispatcher {
220      std::time_t time_;
221      std::tm tm_;
222      dispatcher(std::time_t t) : time_(t) {}
223      bool run() {
224        using namespace fmt::detail;
225        return handle(gmtime_r(&time_, &tm_));
226      }
227      bool handle(std::tm* tm) { return tm != nullptr; }
228      bool handle(detail::null<>) {
229        using namespace fmt::detail;
230        return fallback(gmtime_s(&tm_, &time_));
231      }
232      bool fallback(int res) { return res == 0; }
233  #if !FMT_MSC_VER
234      bool fallback(detail::null<>) {
235        std::tm* tm = std::gmtime(&time_);
236        if (tm) tm_ = *tm;
237        return tm != nullptr;
238      }
239  #endif
240    };
241    dispatcher gt(time);
242    if (!gt.run()) FMT_THROW(format_error("time_t value out of range"));
243    return gt.tm_;
244  }
245  inline std::tm gmtime(
246      std::chrono::time_point<std::chrono::system_clock> time_point) {
247    return gmtime(std::chrono::system_clock::to_time_t(time_point));
248  }
249  namespace detail {
250  inline size_t strftime(char* str, size_t count, const char* format,
251                         const std::tm* time) {
252    return std::strftime(str, count, format, time);
253  }
254  inline size_t strftime(wchar_t* str, size_t count, const wchar_t* format,
255                         const std::tm* time) {
256    return std::wcsftime(str, count, format, time);
257  }
258  }  
259  template <typename Char>
260  struct formatter<std::chrono::time_point<std::chrono::system_clock>, Char>
261      : formatter<std::tm, Char> {
262    template <typename FormatContext>
263    auto format(std::chrono::time_point<std::chrono::system_clock> val,
264                FormatContext& ctx) -> decltype(ctx.out()) {
265      std::tm time = localtime(val);
266      return formatter<std::tm, Char>::format(time, ctx);
267    }
268  };
269  template <typename Char> struct formatter<std::tm, Char> {
270    template <typename ParseContext>
271    auto parse(ParseContext& ctx) -> decltype(ctx.begin()) {
272      auto it = ctx.begin();
273      if (it != ctx.end() && *it == ':') ++it;
274      auto end = it;
275      while (end != ctx.end() && *end != '}') ++end;
276      tm_format.reserve(detail::to_unsigned(end - it + 1));
277      tm_format.append(it, end);
278      tm_format.push_back('\0');
279      return end;
280    }
281    template <typename FormatContext>
282    auto format(const std::tm& tm, FormatContext& ctx) -> decltype(ctx.out()) {
283      basic_memory_buffer<Char> buf;
284      size_t start = buf.size();
285      for (;;) {
286        size_t size = buf.capacity() - start;
287        size_t count = detail::strftime(&buf[start], size, &tm_format[0], &tm);
288        if (count != 0) {
289          buf.resize(start + count);
290          break;
291        }
292        if (size >= tm_format.size() * 256) {
293          break;
294        }
295        const size_t MIN_GROWTH = 10;
296        buf.reserve(buf.capacity() + (size > MIN_GROWTH ? size : MIN_GROWTH));
297      }
298      return std::copy(buf.begin(), buf.end(), ctx.out());
299    }
300    basic_memory_buffer<Char> tm_format;
301  };
302  namespace detail {
303  template <typename Period> FMT_CONSTEXPR const char* get_units() {
304    return nullptr;
305  }
306  template <> FMT_CONSTEXPR const char* get_units<std::atto>() { return "as"; }
307  template <> FMT_CONSTEXPR const char* get_units<std::femto>() { return "fs"; }
308  template <> FMT_CONSTEXPR const char* get_units<std::pico>() { return "ps"; }
309  template <> FMT_CONSTEXPR const char* get_units<std::nano>() { return "ns"; }
310  template <> FMT_CONSTEXPR const char* get_units<std::micro>() { return "µs"; }
311  template <> FMT_CONSTEXPR const char* get_units<std::milli>() { return "ms"; }
312  template <> FMT_CONSTEXPR const char* get_units<std::centi>() { return "cs"; }
313  template <> FMT_CONSTEXPR const char* get_units<std::deci>() { return "ds"; }
314  template <> FMT_CONSTEXPR const char* get_units<std::ratio<1>>() { return "s"; }
315  template <> FMT_CONSTEXPR const char* get_units<std::deca>() { return "das"; }
316  template <> FMT_CONSTEXPR const char* get_units<std::hecto>() { return "hs"; }
317  template <> FMT_CONSTEXPR const char* get_units<std::kilo>() { return "ks"; }
318  template <> FMT_CONSTEXPR const char* get_units<std::mega>() { return "Ms"; }
319  template <> FMT_CONSTEXPR const char* get_units<std::giga>() { return "Gs"; }
320  template <> FMT_CONSTEXPR const char* get_units<std::tera>() { return "Ts"; }
321  template <> FMT_CONSTEXPR const char* get_units<std::peta>() { return "Ps"; }
322  template <> FMT_CONSTEXPR const char* get_units<std::exa>() { return "Es"; }
323  template <> FMT_CONSTEXPR const char* get_units<std::ratio<60>>() {
324    return "m";
325  }
326  template <> FMT_CONSTEXPR const char* get_units<std::ratio<3600>>() {
327    return "h";
328  }
329  enum class numeric_system {
330    standard,
331    alternative
332  };
333  template <typename Char, typename Handler>
334  FMT_CONSTEXPR const Char* parse_chrono_format(const Char* begin,
335                                                const Char* end,
336                                                Handler&& handler) {
337    auto ptr = begin;
338    while (ptr != end) {
339      auto c = *ptr;
340      if (c == '}') break;
341      if (c != '%') {
342        ++ptr;
343        continue;
344      }
345      if (begin != ptr) handler.on_text(begin, ptr);
346      ++ptr;  
347      if (ptr == end) FMT_THROW(format_error("invalid format"));
348      c = *ptr++;
349      switch (c) {
350      case '%':
351        handler.on_text(ptr - 1, ptr);
352        break;
353      case 'n': {
354        const Char newline[] = {'\n'};
355        handler.on_text(newline, newline + 1);
356        break;
357      }
358      case 't': {
359        const Char tab[] = {'\t'};
360        handler.on_text(tab, tab + 1);
361        break;
362      }
363      case 'a':
364        handler.on_abbr_weekday();
365        break;
366      case 'A':
367        handler.on_full_weekday();
368        break;
369      case 'w':
370        handler.on_dec0_weekday(numeric_system::standard);
371        break;
372      case 'u':
373        handler.on_dec1_weekday(numeric_system::standard);
374        break;
375      case 'b':
376        handler.on_abbr_month();
377        break;
378      case 'B':
379        handler.on_full_month();
380        break;
381      case 'H':
382        handler.on_24_hour(numeric_system::standard);
383        break;
384      case 'I':
385        handler.on_12_hour(numeric_system::standard);
386        break;
387      case 'M':
388        handler.on_minute(numeric_system::standard);
389        break;
390      case 'S':
391        handler.on_second(numeric_system::standard);
392        break;
393      case 'c':
394        handler.on_datetime(numeric_system::standard);
395        break;
396      case 'x':
397        handler.on_loc_date(numeric_system::standard);
398        break;
399      case 'X':
400        handler.on_loc_time(numeric_system::standard);
401        break;
402      case 'D':
403        handler.on_us_date();
404        break;
405      case 'F':
406        handler.on_iso_date();
407        break;
408      case 'r':
409        handler.on_12_hour_time();
410        break;
411      case 'R':
412        handler.on_24_hour_time();
413        break;
414      case 'T':
415        handler.on_iso_time();
416        break;
417      case 'p':
418        handler.on_am_pm();
419        break;
420      case 'Q':
421        handler.on_duration_value();
422        break;
423      case 'q':
424        handler.on_duration_unit();
425        break;
426      case 'z':
427        handler.on_utc_offset();
428        break;
429      case 'Z':
430        handler.on_tz_name();
431        break;
432      case 'E': {
433        if (ptr == end) FMT_THROW(format_error("invalid format"));
434        c = *ptr++;
435        switch (c) {
436        case 'c':
437          handler.on_datetime(numeric_system::alternative);
438          break;
439        case 'x':
440          handler.on_loc_date(numeric_system::alternative);
441          break;
442        case 'X':
443          handler.on_loc_time(numeric_system::alternative);
444          break;
445        default:
446          FMT_THROW(format_error("invalid format"));
447        }
448        break;
449      }
450      case 'O':
451        if (ptr == end) FMT_THROW(format_error("invalid format"));
452        c = *ptr++;
453        switch (c) {
454        case 'w':
455          handler.on_dec0_weekday(numeric_system::alternative);
456          break;
457        case 'u':
458          handler.on_dec1_weekday(numeric_system::alternative);
459          break;
460        case 'H':
461          handler.on_24_hour(numeric_system::alternative);
462          break;
463        case 'I':
464          handler.on_12_hour(numeric_system::alternative);
465          break;
466        case 'M':
467          handler.on_minute(numeric_system::alternative);
468          break;
469        case 'S':
470          handler.on_second(numeric_system::alternative);
471          break;
472        default:
473          FMT_THROW(format_error("invalid format"));
474        }
475        break;
476      default:
477        FMT_THROW(format_error("invalid format"));
478      }
479      begin = ptr;
480    }
481    if (begin != ptr) handler.on_text(begin, ptr);
482    return ptr;
483  }
484  struct chrono_format_checker {
485    FMT_NORETURN void report_no_date() { FMT_THROW(format_error("no date")); }
486    template <typename Char> void on_text(const Char*, const Char*) {}
487    FMT_NORETURN void on_abbr_weekday() { report_no_date(); }
488    FMT_NORETURN void on_full_weekday() { report_no_date(); }
489    FMT_NORETURN void on_dec0_weekday(numeric_system) { report_no_date(); }
490    FMT_NORETURN void on_dec1_weekday(numeric_system) { report_no_date(); }
491    FMT_NORETURN void on_abbr_month() { report_no_date(); }
492    FMT_NORETURN void on_full_month() { report_no_date(); }
493    void on_24_hour(numeric_system) {}
494    void on_12_hour(numeric_system) {}
495    void on_minute(numeric_system) {}
496    void on_second(numeric_system) {}
497    FMT_NORETURN void on_datetime(numeric_system) { report_no_date(); }
498    FMT_NORETURN void on_loc_date(numeric_system) { report_no_date(); }
499    FMT_NORETURN void on_loc_time(numeric_system) { report_no_date(); }
500    FMT_NORETURN void on_us_date() { report_no_date(); }
501    FMT_NORETURN void on_iso_date() { report_no_date(); }
502    void on_12_hour_time() {}
503    void on_24_hour_time() {}
504    void on_iso_time() {}
505    void on_am_pm() {}
506    void on_duration_value() {}
507    void on_duration_unit() {}
508    FMT_NORETURN void on_utc_offset() { report_no_date(); }
509    FMT_NORETURN void on_tz_name() { report_no_date(); }
510  };
511  template <typename T, FMT_ENABLE_IF(std::is_integral<T>::value)>
512  inline bool isnan(T) {
513    return false;
514  }
515  template <typename T, FMT_ENABLE_IF(std::is_floating_point<T>::value)>
516  inline bool isnan(T value) {
517    return std::isnan(value);
518  }
519  template <typename T, FMT_ENABLE_IF(std::is_integral<T>::value)>
520  inline bool isfinite(T) {
521    return true;
522  }
523  template <typename T, FMT_ENABLE_IF(std::is_floating_point<T>::value)>
524  inline bool isfinite(T value) {
525    return std::isfinite(value);
526  }
527  template <typename T, FMT_ENABLE_IF(std::is_integral<T>::value)>
528  inline int to_nonnegative_int(T value, int upper) {
529    FMT_ASSERT(value >= 0 && value <= upper, "invalid value");
530    (void)upper;
531    return static_cast<int>(value);
532  }
533  template <typename T, FMT_ENABLE_IF(!std::is_integral<T>::value)>
534  inline int to_nonnegative_int(T value, int upper) {
535    FMT_ASSERT(
536        std::isnan(value) || (value >= 0 && value <= static_cast<T>(upper)),
537        "invalid value");
538    (void)upper;
539    return static_cast<int>(value);
540  }
541  template <typename T, FMT_ENABLE_IF(std::is_integral<T>::value)>
542  inline T mod(T x, int y) {
543    return x % static_cast<T>(y);
544  }
545  template <typename T, FMT_ENABLE_IF(std::is_floating_point<T>::value)>
546  inline T mod(T x, int y) {
547    return std::fmod(x, static_cast<T>(y));
548  }
549  template <typename T, bool INTEGRAL = std::is_integral<T>::value>
550  struct make_unsigned_or_unchanged {
551    using type = T;
552  };
553  template <typename T> struct make_unsigned_or_unchanged<T, true> {
554    using type = typename std::make_unsigned<T>::type;
555  };
556  #if FMT_SAFE_DURATION_CAST
557  template <typename To, typename FromRep, typename FromPeriod>
558  To fmt_safe_duration_cast(std::chrono::duration<FromRep, FromPeriod> from) {
559    int ec;
560    To to = safe_duration_cast::safe_duration_cast<To>(from, ec);
561    if (ec) FMT_THROW(format_error("cannot format duration"));
562    return to;
563  }
564  #endif
565  template <typename Rep, typename Period,
566            FMT_ENABLE_IF(std::is_integral<Rep>::value)>
567  inline std::chrono::duration<Rep, std::milli> get_milliseconds(
568      std::chrono::duration<Rep, Period> d) {
569  #if FMT_SAFE_DURATION_CAST
570    using CommonSecondsType =
571        typename std::common_type<decltype(d), std::chrono::seconds>::type;
572    const auto d_as_common = fmt_safe_duration_cast<CommonSecondsType>(d);
573    const auto d_as_whole_seconds =
574        fmt_safe_duration_cast<std::chrono::seconds>(d_as_common);
575    const auto diff = d_as_common - d_as_whole_seconds;
576    const auto ms =
577        fmt_safe_duration_cast<std::chrono::duration<Rep, std::milli>>(diff);
578    return ms;
579  #else
580    auto s = std::chrono::duration_cast<std::chrono::seconds>(d);
581    return std::chrono::duration_cast<std::chrono::milliseconds>(d - s);
582  #endif
583  }
584  template <typename Rep, typename Period,
585            FMT_ENABLE_IF(std::is_floating_point<Rep>::value)>
586  inline std::chrono::duration<Rep, std::milli> get_milliseconds(
587      std::chrono::duration<Rep, Period> d) {
588    using common_type = typename std::common_type<Rep, std::intmax_t>::type;
589    auto ms = mod(d.count() * static_cast<common_type>(Period::num) /
590                      static_cast<common_type>(Period::den) * 1000,
591                  1000);
592    return std::chrono::duration<Rep, std::milli>(static_cast<Rep>(ms));
593  }
594  template <typename Char, typename Rep, typename OutputIt>
595  OutputIt format_duration_value(OutputIt out, Rep val, int precision) {
596    const Char pr_f[] = {'{', ':', '.', '{', '}', 'f', '}', 0};
597    if (precision >= 0) return format_to(out, pr_f, val, precision);
598    const Char fp_f[] = {'{', ':', 'g', '}', 0};
599    const Char format[] = {'{', '}', 0};
600    return format_to(out, std::is_floating_point<Rep>::value ? fp_f : format,
601                     val);
602  }
603  template <typename Char, typename OutputIt>
604  OutputIt copy_unit(string_view unit, OutputIt out, Char) {
605    return std::copy(unit.begin(), unit.end(), out);
606  }
607  template <typename OutputIt>
608  OutputIt copy_unit(string_view unit, OutputIt out, wchar_t) {
609    utf8_to_utf16 u(unit);
610    return std::copy(u.c_str(), u.c_str() + u.size(), out);
611  }
612  template <typename Char, typename Period, typename OutputIt>
613  OutputIt format_duration_unit(OutputIt out) {
614    if (const char* unit = get_units<Period>())
615      return copy_unit(string_view(unit), out, Char());
616    const Char num_f[] = {'[', '{', '}', ']', 's', 0};
617    if (const_check(Period::den == 1)) return format_to(out, num_f, Period::num);
618    const Char num_def_f[] = {'[', '{', '}', '/', '{', '}', ']', 's', 0};
619    return format_to(out, num_def_f, Period::num, Period::den);
620  }
621  template <typename FormatContext, typename OutputIt, typename Rep,
622            typename Period>
623  struct chrono_formatter {
624    FormatContext& context;
625    OutputIt out;
626    int precision;
627    using rep =
628        conditional_t<std::is_integral<Rep>::value && sizeof(Rep) < sizeof(int),
629                      unsigned, typename make_unsigned_or_unchanged<Rep>::type>;
630    rep val;
631    using seconds = std::chrono::duration<rep>;
632    seconds s;
633    using milliseconds = std::chrono::duration<rep, std::milli>;
634    bool negative;
635    using char_type = typename FormatContext::char_type;
636    explicit chrono_formatter(FormatContext& ctx, OutputIt o,
637                              std::chrono::duration<Rep, Period> d)
638        : context(ctx),
639          out(o),
640          val(static_cast<rep>(d.count())),
641          negative(false) {
642      if (d.count() < 0) {
643        val = 0 - val;
644        negative = true;
645      }
646  #if FMT_SAFE_DURATION_CAST
647      auto tmpval = std::chrono::duration<rep, Period>(val);
648      s = fmt_safe_duration_cast<seconds>(tmpval);
649  #else
650      s = std::chrono::duration_cast<seconds>(
651          std::chrono::duration<rep, Period>(val));
652  #endif
653    }
654    bool handle_nan_inf() {
655      if (isfinite(val)) {
656        return false;
657      }
658      if (isnan(val)) {
659        write_nan();
660        return true;
661      }
662      if (val > 0) {
663        write_pinf();
664      } else {
665        write_ninf();
666      }
667      return true;
668    }
669    Rep hour() const { return static_cast<Rep>(mod((s.count() / 3600), 24)); }
670    Rep hour12() const {
671      Rep hour = static_cast<Rep>(mod((s.count() / 3600), 12));
672      return hour <= 0 ? 12 : hour;
673    }
674    Rep minute() const { return static_cast<Rep>(mod((s.count() / 60), 60)); }
675    Rep second() const { return static_cast<Rep>(mod(s.count(), 60)); }
676    std::tm time() const {
677      auto time = std::tm();
678      time.tm_hour = to_nonnegative_int(hour(), 24);
679      time.tm_min = to_nonnegative_int(minute(), 60);
680      time.tm_sec = to_nonnegative_int(second(), 60);
681      return time;
682    }
683    void write_sign() {
684      if (negative) {
685        *out++ = '-';
686        negative = false;
687      }
688    }
689    void write(Rep value, int width) {
690      write_sign();
691      if (isnan(value)) return write_nan();
692      uint32_or_64_or_128_t<int> n =
693          to_unsigned(to_nonnegative_int(value, max_value<int>()));
694      int num_digits = detail::count_digits(n);
695      if (width > num_digits) out = std::fill_n(out, width - num_digits, '0');
696      out = format_decimal<char_type>(out, n, num_digits).end;
697    }
698    void write_nan() { std::copy_n("nan", 3, out); }
699    void write_pinf() { std::copy_n("inf", 3, out); }
700    void write_ninf() { std::copy_n("-inf", 4, out); }
701    void format_localized(const tm& time, char format, char modifier = 0) {
702      if (isnan(val)) return write_nan();
703      auto locale = context.locale().template get<std::locale>();
704      auto& facet = std::use_facet<std::time_put<char_type>>(locale);
705      std::basic_ostringstream<char_type> os;
706      os.imbue(locale);
707      facet.put(os, os, ' ', &time, format, modifier);
708      auto str = os.str();
709      std::copy(str.begin(), str.end(), out);
710    }
711    void on_text(const char_type* begin, const char_type* end) {
712      std::copy(begin, end, out);
713    }
714    void on_abbr_weekday() {}
715    void on_full_weekday() {}
716    void on_dec0_weekday(numeric_system) {}
717    void on_dec1_weekday(numeric_system) {}
718    void on_abbr_month() {}
719    void on_full_month() {}
720    void on_datetime(numeric_system) {}
721    void on_loc_date(numeric_system) {}
722    void on_loc_time(numeric_system) {}
723    void on_us_date() {}
724    void on_iso_date() {}
725    void on_utc_offset() {}
726    void on_tz_name() {}
727    void on_24_hour(numeric_system ns) {
728      if (handle_nan_inf()) return;
729      if (ns == numeric_system::standard) return write(hour(), 2);
730      auto time = tm();
731      time.tm_hour = to_nonnegative_int(hour(), 24);
732      format_localized(time, 'H', 'O');
733    }
734    void on_12_hour(numeric_system ns) {
735      if (handle_nan_inf()) return;
736      if (ns == numeric_system::standard) return write(hour12(), 2);
737      auto time = tm();
738      time.tm_hour = to_nonnegative_int(hour12(), 12);
739      format_localized(time, 'I', 'O');
740    }
741    void on_minute(numeric_system ns) {
742      if (handle_nan_inf()) return;
743      if (ns == numeric_system::standard) return write(minute(), 2);
744      auto time = tm();
745      time.tm_min = to_nonnegative_int(minute(), 60);
746      format_localized(time, 'M', 'O');
747    }
748    void on_second(numeric_system ns) {
749      if (handle_nan_inf()) return;
750      if (ns == numeric_system::standard) {
751        write(second(), 2);
752  #if FMT_SAFE_DURATION_CAST
753        using duration_rep = std::chrono::duration<rep, Period>;
754        using duration_Rep = std::chrono::duration<Rep, Period>;
755        auto tmpval = fmt_safe_duration_cast<duration_Rep>(duration_rep{val});
756  #else
757        auto tmpval = std::chrono::duration<Rep, Period>(val);
758  #endif
759        auto ms = get_milliseconds(tmpval);
760        if (ms != std::chrono::milliseconds(0)) {
761          *out++ = '.';
762          write(ms.count(), 3);
763        }
764        return;
765      }
766      auto time = tm();
767      time.tm_sec = to_nonnegative_int(second(), 60);
768      format_localized(time, 'S', 'O');
769    }
770    void on_12_hour_time() {
771      if (handle_nan_inf()) return;
772      format_localized(time(), 'r');
773    }
774    void on_24_hour_time() {
775      if (handle_nan_inf()) {
776        *out++ = ':';
777        handle_nan_inf();
778        return;
779      }
780      write(hour(), 2);
781      *out++ = ':';
782      write(minute(), 2);
783    }
784    void on_iso_time() {
785      on_24_hour_time();
786      *out++ = ':';
787      if (handle_nan_inf()) return;
788      write(second(), 2);
789    }
790    void on_am_pm() {
791      if (handle_nan_inf()) return;
792      format_localized(time(), 'p');
793    }
794    void on_duration_value() {
795      if (handle_nan_inf()) return;
796      write_sign();
797      out = format_duration_value<char_type>(out, val, precision);
798    }
799    void on_duration_unit() {
800      out = format_duration_unit<char_type, Period>(out);
801    }
802  };
803  }  
804  template <typename Rep, typename Period, typename Char>
805  struct formatter<std::chrono::duration<Rep, Period>, Char> {
806   private:
807    basic_format_specs<Char> specs;
808    int precision;
809    using arg_ref_type = detail::arg_ref<Char>;
810    arg_ref_type width_ref;
811    arg_ref_type precision_ref;
812    mutable basic_string_view<Char> format_str;
813    using duration = std::chrono::duration<Rep, Period>;
814    struct spec_handler {
815      formatter& f;
816      basic_format_parse_context<Char>& context;
817      basic_string_view<Char> format_str;
818      template <typename Id> FMT_CONSTEXPR arg_ref_type make_arg_ref(Id arg_id) {
819        context.check_arg_id(arg_id);
820        return arg_ref_type(arg_id);
821      }
822      FMT_CONSTEXPR arg_ref_type make_arg_ref(basic_string_view<Char> arg_id) {
823        context.check_arg_id(arg_id);
824        return arg_ref_type(arg_id);
825      }
826      FMT_CONSTEXPR arg_ref_type make_arg_ref(detail::auto_id) {
827        return arg_ref_type(context.next_arg_id());
828      }
829      void on_error(const char* msg) { FMT_THROW(format_error(msg)); }
830      void on_fill(basic_string_view<Char> fill) { f.specs.fill = fill; }
831      void on_align(align_t align) { f.specs.align = align; }
832      void on_width(int width) { f.specs.width = width; }
833      void on_precision(int _precision) { f.precision = _precision; }
834      void end_precision() {}
835      template <typename Id> void on_dynamic_width(Id arg_id) {
836        f.width_ref = make_arg_ref(arg_id);
837      }
838      template <typename Id> void on_dynamic_precision(Id arg_id) {
839        f.precision_ref = make_arg_ref(arg_id);
840      }
841    };
842    using iterator = typename basic_format_parse_context<Char>::iterator;
843    struct parse_range {
844      iterator begin;
845      iterator end;
846    };
847    FMT_CONSTEXPR parse_range do_parse(basic_format_parse_context<Char>& ctx) {
848      auto begin = ctx.begin(), end = ctx.end();
849      if (begin == end || *begin == '}') return {begin, begin};
850      spec_handler handler{*this, ctx, format_str};
851      begin = detail::parse_align(begin, end, handler);
852      if (begin == end) return {begin, begin};
853      begin = detail::parse_width(begin, end, handler);
854      if (begin == end) return {begin, begin};
855      if (*begin == '.') {
856        if (std::is_floating_point<Rep>::value)
857          begin = detail::parse_precision(begin, end, handler);
858        else
859          handler.on_error("precision not allowed for this argument type");
860      }
861      end = parse_chrono_format(begin, end, detail::chrono_format_checker());
862      return {begin, end};
863    }
864   public:
865    formatter() : precision(-1) {}
866    FMT_CONSTEXPR auto parse(basic_format_parse_context<Char>& ctx)
867        -> decltype(ctx.begin()) {
868      auto range = do_parse(ctx);
869      format_str = basic_string_view<Char>(
870          &*range.begin, detail::to_unsigned(range.end - range.begin));
871      return range.end;
872    }
873    template <typename FormatContext>
874    auto format(const duration& d, FormatContext& ctx) -> decltype(ctx.out()) {
875      auto begin = format_str.begin(), end = format_str.end();
876      basic_memory_buffer<Char> buf;
877      auto out = std::back_inserter(buf);
878      detail::handle_dynamic_spec<detail::width_checker>(specs.width, width_ref,
879                                                         ctx);
880      detail::handle_dynamic_spec<detail::precision_checker>(precision,
881                                                             precision_ref, ctx);
882      if (begin == end || *begin == '}') {
883        out = detail::format_duration_value<Char>(out, d.count(), precision);
884        detail::format_duration_unit<Char, Period>(out);
885      } else {
886        detail::chrono_formatter<FormatContext, decltype(out), Rep, Period> f(
887            ctx, out, d);
888        f.precision = precision;
889        parse_chrono_format(begin, end, f);
890      }
891      return detail::write(
892          ctx.out(), basic_string_view<Char>(buf.data(), buf.size()), specs);
893    }
894  };
895  FMT_END_NAMESPACE
896  #endif  
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from xmrig-MDEwOlJlcG9zaXRvcnk4ODMyNzQwNg==-flat-chrono.h</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from xmrig-MDEwOlJlcG9zaXRvcnk4ODMyNzQwNg==-flat-chrono.h</div>
                </div>
                <div class="column column_space"><pre><code>56        from > static_cast<From>(detail::max_value<To>())) {
57      ec = 1;
58      return {};
59    }
60    return static_cast<To>(from);  
</pre></code></div>
                <div class="column column_space"><pre><code>56        from > static_cast<From>(detail::max_value<To>())) {
57      ec = 1;
58      return {};
59    }
60    return static_cast<To>(from);  
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    