
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 1.392515230635335%, Tokens: 8</h2>
        <div class="column">
            <h3>PINRemoteImage-MDEwOlJlcG9zaXRvcnkzOTUzNzEwMw==-flat-tiffdec.c</h3>
            <pre><code>1  #include "./tiffdec.h"
2  #ifdef HAVE_CONFIG_H
3  #include "webp/config.h"
4  #endif
5  #include <limits.h>
6  #include <stdio.h>
7  #include <string.h>
8  #ifdef WEBP_HAVE_TIFF
9  #include <tiffio.h>
10  #include "webp/encode.h"
11  #include "./imageio_util.h"
12  #include "./metadata.h"
13  static const struct {
14    ttag_t tag;
15    size_t storage_offset;
16  } kTIFFMetadataMap[] = {
17    { TIFFTAG_ICCPROFILE, METADATA_OFFSET(iccp) },
18    { TIFFTAG_XMLPACKET,  METADATA_OFFSET(xmp) },
19    { 0, 0 },
20  };
21  static int ExtractMetadataFromTIFF(TIFF* const tif, Metadata* const metadata) {
22    int i;
23    toff_t exif_ifd_offset;
24    for (i = 0; kTIFFMetadataMap[i].tag != 0; ++i) {
25      MetadataPayload* const payload =
26          (MetadataPayload*)((uint8_t*)metadata +
27                             kTIFFMetadataMap[i].storage_offset);
28      void* tag_data;
29      uint32 tag_data_len;
30      if (TIFFGetField(tif, kTIFFMetadataMap[i].tag, &tag_data_len, &tag_data) &&
31          !MetadataCopy((const char*)tag_data, tag_data_len, payload)) {
32        return 0;
33      }
34    }
35    if (TIFFGetField(tif, TIFFTAG_EXIFIFD, &exif_ifd_offset)) {
36      fprintf(stderr, "Warning: EXIF extraction from TIFF is unsupported.\n");
37    }
38    return 1;
39  }
40  typedef struct {
41    const uint8_t* data;
42    toff_t size;
43    toff_t pos;
44  } MyData;
45  static int MyClose(thandle_t opaque) {
46    (void)opaque;
47    return 0;
48  }
49  static toff_t MySize(thandle_t opaque) {
50    const MyData* const my_data = (MyData*)opaque;
51    return my_data->size;
52  }
53  static toff_t MySeek(thandle_t opaque, toff_t offset, int whence) {
54    MyData* const my_data = (MyData*)opaque;
55    offset += (whence == SEEK_CUR) ? my_data->pos
56            : (whence == SEEK_SET) ? 0
57            : my_data->size;
58    if (offset > my_data->size) return (toff_t)-1;
59    my_data->pos = offset;
<span onclick='openModal()' class='match'>60    return offset;
61  }
62  static int MyMapFile(thandle_t opaque, void** base, toff_t* size) {
63    (void)opaque;
64    (void)base;
65    (void)size;
66    return 0;
67  }
68  static void MyUnmapFile(thandle_t opaque, void* base, toff_t size) {
</span>69    (void)opaque;
70    (void)base;
71    (void)size;
72  }
73  static tsize_t MyRead(thandle_t opaque, void* dst, tsize_t size) {
74    MyData* const my_data = (MyData*)opaque;
75    if (my_data->pos + size > my_data->size) {
76      size = (tsize_t)(my_data->size - my_data->pos);
77    }
78    if (size > 0) {
79      memcpy(dst, my_data->data + my_data->pos, size);
80      my_data->pos += size;
81    }
82    return size;
83  }
84  #define MFIX 24    
85  #define HALF ((1u << MFIX) >> 1)
86  static uint32_t Unmult(uint8_t x, uint32_t mult) {
87    const uint32_t v = (x * mult + HALF) >> MFIX;
88    return (v > 255u) ? 255u : v;
89  }
90  static WEBP_INLINE uint32_t GetScale(uint32_t a) {
91    return (255u << MFIX) / a;
92  }
93  #undef MFIX
94  #undef HALF
95  static void MultARGBRow(uint8_t* ptr, int width) {
96    int x;
97    for (x = 0; x < width; ++x, ptr += 4) {
98      const uint32_t alpha = ptr[3];
99      if (alpha < 255) {
100        if (alpha == 0) {   
101          ptr[0] = ptr[1] = ptr[2] = 0;
102        } else {
103          const uint32_t scale = GetScale(alpha);
104          ptr[0] = Unmult(ptr[0], scale);
105          ptr[1] = Unmult(ptr[1], scale);
106          ptr[2] = Unmult(ptr[2], scale);
107        }
108      }
109    }
110  }
111  int ReadTIFF(const uint8_t* const data, size_t data_size,
112               WebPPicture* const pic, int keep_alpha,
113               Metadata* const metadata) {
114    MyData my_data = { data, (toff_t)data_size, 0 };
115    TIFF* tif;
116    uint32_t image_width, image_height, tile_width, tile_height;
117    uint16_t samples_per_px = 0;
118    uint16_t extra_samples = 0;
119    uint16_t* extra_samples_ptr = NULL;
120    uint32_t* raster;
121    int64_t alloc_size;
122    int ok = 0;
123    tdir_t dircount;
124    if (data == NULL || data_size == 0 || data_size > INT_MAX || pic == NULL) {
125      return 0;
126    }
127    tif = TIFFClientOpen("Memory", "r", &my_data,
128                         MyRead, MyRead, MySeek, MyClose,
129                         MySize, MyMapFile, MyUnmapFile);
130    if (tif == NULL) {
131      fprintf(stderr, "Error! Cannot parse TIFF file\n");
132      return 0;
133    }
134    dircount = TIFFNumberOfDirectories(tif);
135    if (dircount > 1) {
136      fprintf(stderr, "Warning: multi-directory TIFF files are not supported.\n"
137                      "Only the first will be used, %d will be ignored.\n",
138                      dircount - 1);
139    }
140    if (!TIFFGetFieldDefaulted(tif, TIFFTAG_SAMPLESPERPIXEL, &samples_per_px)) {
141      fprintf(stderr, "Error! Cannot retrieve TIFF samples-per-pixel info.\n");
142      goto End;
143    }
144    if (samples_per_px < 3 || samples_per_px > 4) goto End;  
145    if (!(TIFFGetField(tif, TIFFTAG_IMAGEWIDTH, &image_width) &&
146          TIFFGetField(tif, TIFFTAG_IMAGELENGTH, &image_height))) {
147      fprintf(stderr, "Error! Cannot retrieve TIFF image dimensions.\n");
148      goto End;
149    }
150    if (!ImgIoUtilCheckSizeArgumentsOverflow((uint64_t)image_width * image_height,
151                                             sizeof(*raster))) {
152      goto End;
153    }
154    if ((TIFFGetField(tif, TIFFTAG_TILEWIDTH, &tile_width) &&
155         tile_width > 32 && tile_width / 2 > image_width) ||
156        (TIFFGetField(tif, TIFFTAG_TILELENGTH, &tile_height) &&
157         tile_height > 32 && tile_height / 2 > image_height)) {
158      fprintf(stderr, "Error! TIFF tile dimensions are too big.\n");
159      goto End;
160    }
161    if (samples_per_px > 3 && !TIFFGetField(tif, TIFFTAG_EXTRASAMPLES,
162                                            &extra_samples, &extra_samples_ptr)) {
163      fprintf(stderr, "Error! Cannot retrieve TIFF ExtraSamples info.\n");
164      goto End;
165    }
166    alloc_size =
167        (int64_t)((uint64_t)image_width * image_height * sizeof(*raster));
168    if (alloc_size < 0 || alloc_size != (tsize_t)alloc_size) goto End;
169    raster = (uint32*)_TIFFmalloc((tsize_t)alloc_size);
170    if (raster != NULL) {
171      if (TIFFReadRGBAImageOriented(tif, image_width, image_height, raster,
172                                    ORIENTATION_TOPLEFT, 1)) {
173        const int stride = image_width * sizeof(*raster);
174        pic->width = image_width;
175        pic->height = image_height;
176  #ifdef WORDS_BIGENDIAN
177        TIFFSwabArrayOfLong(raster, image_width * image_height);
178  #endif
179        if (extra_samples == 1 && extra_samples_ptr != NULL &&
180            extra_samples_ptr[0] == EXTRASAMPLE_ASSOCALPHA) {
181          uint32_t y;
182          uint8_t* tmp = (uint8_t*)raster;
183          for (y = 0; y < image_height; ++y) {
184            MultARGBRow(tmp, image_width);
185            tmp += stride;
186          }
187        }
188        ok = keep_alpha
189           ? WebPPictureImportRGBA(pic, (const uint8_t*)raster, stride)
190           : WebPPictureImportRGBX(pic, (const uint8_t*)raster, stride);
191      }
192      _TIFFfree(raster);
193    } else {
194      fprintf(stderr, "Error allocating TIFF RGBA memory!\n");
195    }
196    if (ok) {
197      if (metadata != NULL) {
198        ok = ExtractMetadataFromTIFF(tif, metadata);
199        if (!ok) {
200          fprintf(stderr, "Error extracting TIFF metadata!\n");
201          MetadataFree(metadata);
202          WebPPictureFree(pic);
203        }
204      }
205    }
206   End:
207    TIFFClose(tif);
208    return ok;
209  }
210  #else  
211  int ReadTIFF(const uint8_t* const data, size_t data_size,
212               struct WebPPicture* const pic, int keep_alpha,
213               struct Metadata* const metadata) {
214    (void)data;
215    (void)data_size;
216    (void)pic;
217    (void)keep_alpha;
218    (void)metadata;
219    fprintf(stderr, "TIFF support not compiled. Please install the libtiff "
220            "development package before building.\n");
221    return 0;
222  }
223  #endif  
</code></pre>
        </div>
        <div class="column">
            <h3>libfuse-MDEwOlJlcG9zaXRvcnk0ODI5NjE3Nw==-flat-test_syscalls.c</h3>
            <pre><code>1  #define _GNU_SOURCE
2  #include "fuse_config.h"
3  #include <stdio.h>
4  #include <stdlib.h>
5  #include <stdarg.h>
6  #include <string.h>
7  #include <unistd.h>
8  #include <fcntl.h>
9  #include <dirent.h>
10  #include <utime.h>
11  #include <errno.h>
12  #include <assert.h>
13  #include <sys/socket.h>
14  #include <sys/types.h>
15  #include <sys/stat.h>
16  #include <sys/un.h>
17  #ifndef ALLPERMS
18  # define ALLPERMS (S_ISUID|S_ISGID|S_ISVTX|S_IRWXU|S_IRWXG|S_IRWXO)&bsol;* 07777 */
19  #endif
20  static const char *basepath;
21  static const char *basepath_r;
22  static char testfile[1024];
23  static char testfile2[1024];
24  static char testdir[1024];
25  static char testdir2[1024];
26  static char testsock[1024];
27  static char subfile[1280];
28  static char testfile_r[1024];
29  static char testfile2_r[1024];
30  static char testdir_r[1024];
31  static char testdir2_r[1024];
32  static char subfile_r[1280];
33  static char testname[256];
34  static char testdata[] = "abcdefghijklmnopqrstuvwxyz";
35  static char testdata2[] = "1234567890-=qwertyuiop[]\asdfghjkl;'zxcvbnm,./";
36  static const char *testdir_files[] = { "f1", "f2", NULL};
37  static long seekdir_offsets[4];
38  static char zerodata[4096];
39  static int testdatalen = sizeof(testdata) - 1;
40  static int testdata2len = sizeof(testdata2) - 1;
41  static unsigned int testnum = 0;
42  static unsigned int select_test = 0;
43  static unsigned int skip_test = 0;
44  static unsigned int unlinked_test = 0;
45  #define MAX_ENTRIES 1024
46  #define MAX_TESTS 100
47  static struct test {
48  	int fd;
49  	struct stat stat;
50  } tests[MAX_TESTS];
51  static void test_perror(const char *func, const char *msg)
52  {
53  	fprintf(stderr, "%s %s() - %s: %s\n", testname, func, msg,
54  		strerror(errno));
55  }
56  static void test_error(const char *func, const char *msg, ...)
57  	__attribute__ ((format (printf, 2, 3)));
58  static void __start_test(const char *fmt, ...)
59  	__attribute__ ((format (printf, 1, 2)));
60  static void test_error(const char *func, const char *msg, ...)
61  {
62  	va_list ap;
63  	fprintf(stderr, "%s %s() - ", testname, func);
64  	va_start(ap, msg);
65  	vfprintf(stderr, msg, ap);
66  	va_end(ap);
67  	fprintf(stderr, "\n");
68  }
69  static int is_dot_or_dotdot(const char *name) {
70      return name[0] == '.' &&
71             (name[1] == '\0' || (name[1] == '.' && name[2] == '\0'));
72  }
73  static void success(void)
74  {
75  	fprintf(stderr, "%s OK\n", testname);
76  }
77  #define this_test (&tests[testnum-1])
78  #define next_test (&tests[testnum])
79  static void __start_test(const char *fmt, ...)
80  {
81  	unsigned int n;
82  	va_list ap;
83  	n = sprintf(testname, "%3i [", testnum);
84  	va_start(ap, fmt);
85  	n += vsprintf(testname + n, fmt, ap);
86  	va_end(ap);
87  	sprintf(testname + n, "]");
88  	sprintf(testfile, "%s/testfile.%d", basepath, testnum);
89  	sprintf(testfile_r, "%s/testfile.%d", basepath_r, testnum);
90  	if (testnum > MAX_TESTS) {
91  		fprintf(stderr, "%s - too many tests\n", testname);
92  		exit(1);
93  	}
94  	this_test->fd = -1;
95  }
96  #define start_test(msg, args...) { \
97  	testnum++; \
98  	if ((select_test && testnum != select_test) || \
99  	    (testnum == skip_test)) { \
100  		return 0; \
101  	} \
102  	__start_test(msg, ##args);		\
103  }
104  #define PERROR(msg) test_perror(__FUNCTION__, msg)
105  #define ERROR(msg, args...) test_error(__FUNCTION__, msg, ##args)
106  #define ARRAY_SIZE(arr) (sizeof(arr) / sizeof((arr)[0]))
107  static int st_check_size(struct stat *st, int len)
108  {
109  	if (st->st_size != len) {
110  		ERROR("length %u instead of %u", (int) st->st_size,
111  		      (int) len);
112  		return -1;
113  	}
114  	return 0;
115  }
116  static int check_size(const char *path, int len)
117  {
118  	struct stat stbuf;
119  	int res = stat(path, &stbuf);
120  	if (res == -1) {
121  		PERROR("stat");
122  		return -1;
123  	}
124  	return st_check_size(&stbuf, len);
125  }
126  static int check_testfile_size(const char *path, int len)
127  {
128  	this_test->stat.st_size = len;
129  	return check_size(path, len);
130  }
131  static int st_check_type(struct stat *st, mode_t type)
132  {
133  	if ((st->st_mode & S_IFMT) != type) {
134  		ERROR("type 0%o instead of 0%o", st->st_mode & S_IFMT, type);
135  		return -1;
136  	}
137  	return 0;
138  }
139  static int check_type(const char *path, mode_t type)
140  {
141  	struct stat stbuf;
142  	int res = lstat(path, &stbuf);
143  	if (res == -1) {
144  		PERROR("lstat");
145  		return -1;
146  	}
147  	return st_check_type(&stbuf, type);
148  }
149  static int st_check_mode(struct stat *st, mode_t mode)
150  {
151  	if ((st->st_mode & ALLPERMS) != mode) {
152  		ERROR("mode 0%o instead of 0%o", st->st_mode & ALLPERMS,
153  		      mode);
154  		return -1;
155  	}
156  	return 0;
157  }
158  static int check_mode(const char *path, mode_t mode)
159  {
160  	struct stat stbuf;
161  	int res = lstat(path, &stbuf);
162  	if (res == -1) {
163  		PERROR("lstat");
164  		return -1;
165  	}
166  	return st_check_mode(&stbuf, mode);
167  }
168  static int check_testfile_mode(const char *path, mode_t mode)
169  {
170  	this_test->stat.st_mode &= ~ALLPERMS;
171  	this_test->stat.st_mode |= mode;
172  	return check_mode(path, mode);
173  }
174  static int check_times(const char *path, time_t atime, time_t mtime)
175  {
176  	int err = 0;
177  	struct stat stbuf;
178  	int res = lstat(path, &stbuf);
179  	if (res == -1) {
180  		PERROR("lstat");
181  		return -1;
182  	}
183  	if (stbuf.st_atime != atime) {
184  		ERROR("atime %li instead of %li", stbuf.st_atime, atime);
185  		err--;
186  	}
187  	if (stbuf.st_mtime != mtime) {
188  		ERROR("mtime %li instead of %li", stbuf.st_mtime, mtime);
189  		err--;
190  	}
191  	if (err)
192  		return -1;
193  	return 0;
194  }
195  #if 0
196  static int fcheck_times(int fd, time_t atime, time_t mtime)
197  {
198  	int err = 0;
199  	struct stat stbuf;
200  	int res = fstat(fd, &stbuf);
201  	if (res == -1) {
202  		PERROR("fstat");
203  		return -1;
204  	}
205  	if (stbuf.st_atime != atime) {
206  		ERROR("atime %li instead of %li", stbuf.st_atime, atime);
207  		err--;
208  	}
209  	if (stbuf.st_mtime != mtime) {
210  		ERROR("mtime %li instead of %li", stbuf.st_mtime, mtime);
211  		err--;
212  	}
213  	if (err)
214  		return -1;
215  	return 0;
216  }
217  #endif
218  static int st_check_nlink(struct stat *st, nlink_t nlink)
219  {
220  	if (st->st_nlink != nlink) {
221  		ERROR("nlink %li instead of %li", (long) st->st_nlink,
222  		      (long) nlink);
223  		return -1;
224  	}
225  	return 0;
226  }
227  static int check_nlink(const char *path, nlink_t nlink)
228  {
229  	struct stat stbuf;
230  	int res = lstat(path, &stbuf);
231  	if (res == -1) {
232  		PERROR("lstat");
233  		return -1;
234  	}
235  	return st_check_nlink(&stbuf, nlink);
236  }
237  static int fcheck_stat(int fd, int flags, struct stat *st)
238  {
239  	struct stat stbuf;
240  	int res = fstat(fd, &stbuf);
241  	if (res == -1) {
242  		if (flags & O_PATH) {
243  			if (errno == ESTALE || errno == EIO ||
244  			    errno == ENOENT || errno == EBADF)
245  				return 0;
246  		}
247  		PERROR("fstat");
248  		return -1;
249  	}
250  	int err = 0;
251  	err += st_check_type(&stbuf, st->st_mode & S_IFMT);
252  	err += st_check_mode(&stbuf, st->st_mode & ALLPERMS);
253  	err += st_check_size(&stbuf, st->st_size);
254  	err += st_check_nlink(&stbuf, st->st_nlink);
255  	return err;
256  }
257  static int check_nonexist(const char *path)
258  {
259  	struct stat stbuf;
260  	int res = lstat(path, &stbuf);
261  	if (res == 0) {
262  		ERROR("file should not exist");
263  		return -1;
264  	}
265  	if (errno != ENOENT) {
266  		ERROR("file should not exist: %s", strerror(errno));
267  		return -1;
268  	}
269  	return 0;
270  }
271  static int check_buffer(const char *buf, const char *data, unsigned len)
272  {
273  	if (memcmp(buf, data, len) != 0) {
274  		ERROR("data mismatch");
275  		return -1;
276  	}
277  	return 0;
278  }
279  static int check_data(const char *path, const char *data, int offset,
280  		      unsigned len)
281  {
282  	char buf[4096];
283  	int res;
284  	int fd = open(path, O_RDONLY);
285  	if (fd == -1) {
286  		PERROR("open");
287  		return -1;
288  	}
289  	if (lseek(fd, offset, SEEK_SET) == (off_t) -1) {
290  		PERROR("lseek");
291  		close(fd);
292  		return -1;
293  	}
294  	while (len) {
295  		int rdlen = len < sizeof(buf) ? len : sizeof(buf);
296  		res = read(fd, buf, rdlen);
297  		if (res == -1) {
298  			PERROR("read");
299  			close(fd);
300  			return -1;
301  		}
302  		if (res != rdlen) {
303  			ERROR("short read: %u instead of %u", res, rdlen);
304  			close(fd);
305  			return -1;
306  		}
307  		if (check_buffer(buf, data, rdlen) != 0) {
308  			close(fd);
309  			return -1;
310  		}
311  		data += rdlen;
312  		len -= rdlen;
313  	}
314  	res = close(fd);
315  	if (res == -1) {
316  		PERROR("close");
317  		return -1;
318  	}
319  	return 0;
320  }
321  static int fcheck_data(int fd, const char *data, int offset,
322  		       unsigned len)
323  {
324  	char buf[4096];
325  	int res;
326  	if (lseek(fd, offset, SEEK_SET) == (off_t) -1) {
327  		PERROR("lseek");
328  		return -1;
329  	}
330  	while (len) {
331  		int rdlen = len < sizeof(buf) ? len : sizeof(buf);
332  		res = read(fd, buf, rdlen);
333  		if (res == -1) {
334  			PERROR("read");
335  			return -1;
336  		}
337  		if (res != rdlen) {
338  			ERROR("short read: %u instead of %u", res, rdlen);
339  			return -1;
340  		}
341  		if (check_buffer(buf, data, rdlen) != 0) {
342  			return -1;
343  		}
344  		data += rdlen;
345  		len -= rdlen;
346  	}
347  	return 0;
348  }
349  static int check_dir_contents(const char *path, const char **contents)
350  {
351  	int i;
352  	int res;
353  	int err = 0;
354  	int found[MAX_ENTRIES];
355  	const char *cont[MAX_ENTRIES];
356  	DIR *dp;
357  	for (i = 0; contents[i]; i++) {
358  		assert(i < MAX_ENTRIES - 3);
359  		found[i] = 0;
360  		cont[i] = contents[i];
361  	}
362  	cont[i] = NULL;
363  	dp = opendir(path);
364  	if (dp == NULL) {
365  		PERROR("opendir");
366  		return -1;
367  	}
368  	memset(found, 0, sizeof(found));
369  	while(1) {
370  		struct dirent *de;
371  		errno = 0;
372  		de = readdir(dp);
373  		if (de == NULL) {
374  			if (errno) {
375  				PERROR("readdir");
376  				closedir(dp);
377  				return -1;
378  			}
379  			break;
380  		}
381  		if (is_dot_or_dotdot(de->d_name))
382  			continue;
383  		for (i = 0; cont[i] != NULL; i++) {
384  			assert(i < MAX_ENTRIES);
385  			if (strcmp(cont[i], de->d_name) == 0) {
386  				if (found[i]) {
387  					ERROR("duplicate entry <%s>",
388  					      de->d_name);
389  					err--;
390  				} else
391  					found[i] = 1;
392  				break;
393  			}
394  		}
395  		if (!cont[i]) {
396  			ERROR("unexpected entry <%s>", de->d_name);
397  			err --;
398  		}
399  	}
400  	for (i = 0; cont[i] != NULL; i++) {
401  		if (!found[i]) {
402  			ERROR("missing entry <%s>", cont[i]);
403  			err--;
404  		}
405  	}
406  	res = closedir(dp);
407  	if (res == -1) {
408  		PERROR("closedir");
409  		return -1;
410  	}
411  	if (err)
412  		return -1;
413  	return 0;
414  }
415  static int create_file(const char *path, const char *data, int len)
416  {
417  	int res;
418  	int fd;
419  	unlink(path);
420  	fd = creat(path, 0644);
421  	if (fd == -1) {
422  		PERROR("creat");
423  		return -1;
424  	}
425  	if (len) {
426  		res = write(fd, data, len);
427  		if (res == -1) {
428  			PERROR("write");
429  			close(fd);
430  			return -1;
431  		}
432  		if (res != len) {
433  			ERROR("write is short: %u instead of %u", res, len);
434  			close(fd);
435  			return -1;
436  		}
437  	}
438  	res = close(fd);
439  	if (res == -1) {
440  		PERROR("close");
441  		return -1;
442  	}
443  	res = check_type(path, S_IFREG);
444  	if (res == -1)
445  		return -1;
446  	res = check_mode(path, 0644);
447  	if (res == -1)
448  		return -1;
449  	res = check_nlink(path, 1);
450  	if (res == -1)
451  		return -1;
452  	res = check_size(path, len);
453  	if (res == -1)
454  		return -1;
455  	if (len) {
456  		res = check_data(path, data, 0, len);
457  		if (res == -1)
458  			return -1;
459  	}
460  	return 0;
461  }
462  static int create_path_fd(const char *path, const char *data, int len)
463  {
464  	int path_fd;
465  	int res;
466  	res = create_file(path, data, len);
467  	if (res == -1)
468  		return -1;
469  	path_fd = open(path, O_PATH);
470  	if (path_fd == -1)
471  		PERROR("open(O_PATH)");
472  	return path_fd;
473  }
474  static int create_testfile(const char *path, const char *data, int len)
475  {
476  	struct test *t = this_test;
477  	struct stat *st = &t->stat;
478  	int res, fd;
479  	if (t->fd > 0) {
480  		ERROR("testfile already created");
481  		return -1;
482  	}
483  	fd = create_path_fd(path, data, len);
484  	if (fd == -1)
485  		return -1;
486  	t->fd = fd;
487  	res = fstat(fd, st);
488  	if (res == -1) {
489  		PERROR("fstat");
490  		return -1;
491  	}
492  	return 0;
493  }
494  static int check_unlinked_testfile(int fd)
495  {
496  	struct stat *st = &this_test->stat;
497  	st->st_nlink = 0;
498  	return fcheck_stat(fd, O_PATH, st);
499  }
500  static int check_unlinked_testfiles(void)
501  {
502  	int fd;
503  	int res, err = 0;
504  	int num = testnum;
505  	if (!unlinked_test)
506  		return 0;
507  	testnum = 0;
508  	while (testnum < num) {
509  		fd = next_test->fd;
510  		start_test("check_unlinked_testfile");
511  		if (fd == -1)
512  			continue;
513  		err += check_unlinked_testfile(fd);
514  		res = close(fd);
515  		if (res == -1) {
516  			PERROR("close(test_fd)");
517  			err--;
518  		}
519  	}
520  	if (err) {
521  		fprintf(stderr, "%i unlinked testfile checks failed\n", -err);
522  		return 1;
523  	}
524  	return err;
525  }
526  static int cleanup_dir(const char *path, const char **dir_files, int quiet)
527  {
528  	int i;
529  	int err = 0;
530  	for (i = 0; dir_files[i]; i++) {
531  		int res;
532  		char fpath[1280];
533  		sprintf(fpath, "%s/%s", path, dir_files[i]);
534  		res = unlink(fpath);
535  		if (res == -1 && !quiet) {
536  			PERROR("unlink");
537  			err --;
538  		}
539  	}
540  	if (err)
541  		return -1;
542  	return 0;
543  }
544  static int create_dir(const char *path, const char **dir_files)
545  {
546  	int res;
547  	int i;
548  	rmdir(path);
549  	res = mkdir(path, 0755);
550  	if (res == -1) {
551  		PERROR("mkdir");
552  		return -1;
553  	}
554  	res = check_type(path, S_IFDIR);
555  	if (res == -1)
556  		return -1;
557  	res = check_mode(path, 0755);
558  	if (res == -1)
559  		return -1;
560  	for (i = 0; dir_files[i]; i++) {
561  		char fpath[1280];
562  		sprintf(fpath, "%s/%s", path, dir_files[i]);
563  		res = create_file(fpath, "", 0);
564  		if (res == -1) {
565  			cleanup_dir(path, dir_files, 1);
566  			return -1;
567  		}
568  	}
569  	res = check_dir_contents(path, dir_files);
570  	if (res == -1) {
571  		cleanup_dir(path, dir_files, 1);
572  		return -1;
573  	}
574  	return 0;
575  }
576  static int test_truncate(int len)
577  {
578  	const char *data = testdata;
579  	int datalen = testdatalen;
580  	int res;
581  	start_test("truncate(%u)", (int) len);
582  	res = create_testfile(testfile, data, datalen);
583  	if (res == -1)
584  		return -1;
585  	res = truncate(testfile, len);
586  	if (res == -1) {
587  		PERROR("truncate");
588  		return -1;
589  	}
590  	res = check_testfile_size(testfile, len);
591  	if (res == -1)
592  		return -1;
593  	if (len > 0) {
594  		if (len <= datalen) {
595  			res = check_data(testfile, data, 0, len);
596  			if (res == -1)
597  				return -1;
598  		} else {
599  			res = check_data(testfile, data, 0, datalen);
600  			if (res == -1)
601  				return -1;
602  			res = check_data(testfile, zerodata, datalen,
603  					 len - datalen);
604  			if (res == -1)
605  				return -1;
606  		}
607  	}
608  	res = unlink(testfile);
609  	if (res == -1) {
610  		PERROR("unlink");
611  		return -1;
612  	}
613  	res = check_nonexist(testfile);
614  	if (res == -1)
615  		return -1;
616  	success();
617  	return 0;
618  }
619  static int test_ftruncate(int len, int mode)
620  {
621  	const char *data = testdata;
622  	int datalen = testdatalen;
623  	int res;
624  	int fd;
625  	start_test("ftruncate(%u) mode: 0%03o", len, mode);
626  	res = create_testfile(testfile, data, datalen);
627  	if (res == -1)
628  		return -1;
629  	fd = open(testfile, O_WRONLY);
630  	if (fd == -1) {
631  		PERROR("open");
632  		return -1;
633  	}
634  	res = fchmod(fd, mode);
635  	if (res == -1) {
636  		PERROR("fchmod");
637  		close(fd);
638  		return -1;
639  	}
640  	res = check_testfile_mode(testfile, mode);
641  	if (res == -1) {
642  		close(fd);
643  		return -1;
644  	}
645  	res = ftruncate(fd, len);
646  	if (res == -1) {
647  		PERROR("ftruncate");
648  		close(fd);
649  		return -1;
650  	}
651  	close(fd);
652  	res = check_testfile_size(testfile, len);
653  	if (res == -1)
654  		return -1;
655  	if (len > 0) {
656  		if (len <= datalen) {
657  			res = check_data(testfile, data, 0, len);
658  			if (res == -1)
659  				return -1;
660  		} else {
661  			res = check_data(testfile, data, 0, datalen);
662  			if (res == -1)
663  				return -1;
664  			res = check_data(testfile, zerodata, datalen,
665  					 len - datalen);
666  			if (res == -1)
667  				return -1;
668  		}
669  	}
670  	res = unlink(testfile);
671  	if (res == -1) {
672  		PERROR("unlink");
673  		return -1;
674  	}
675  	res = check_nonexist(testfile);
676  	if (res == -1)
677  		return -1;
678  	success();
679  	return 0;
680  }
681  static int test_seekdir(void)
682  {
683  	int i;
684  	int res;
685  	DIR *dp;
686  	struct dirent *de;
687  	start_test("seekdir");
688  	res = create_dir(testdir, testdir_files);
689  	if (res == -1)
690  		return res;
691  	dp = opendir(testdir);
692  	if (dp == NULL) {
693  		PERROR("opendir");
694  		return -1;
695  	}
696  	for (i = 0; i < ARRAY_SIZE(seekdir_offsets); i++) {
697  		seekdir_offsets[i] = telldir(dp);
698  		errno = 0;
699  		de = readdir(dp);
700  		if (de == NULL) {
701  			if (errno) {
702  				PERROR("readdir");
703  				goto fail;
704  			}
705  			break;
706  		}
707  	}
708  	while (de)
709  		de = readdir(dp);
710  	for (i--; i >= 0; i--) {
711  		seekdir(dp, seekdir_offsets[i]);
712  		de = readdir(dp);
713  		if (de == NULL) {
714  			ERROR("Unexpected end of directory after seekdir()");
715  			goto fail;
716  		}
717  	}
718  	closedir(dp);
719  	res = cleanup_dir(testdir, testdir_files, 0);
720  	if (!res)
721  		success();
722  	return res;
723  fail:
724  	closedir(dp);
725  	cleanup_dir(testdir, testdir_files, 1);
726  	return -1;
727  }
728  #ifdef HAVE_COPY_FILE_RANGE
729  static int test_copy_file_range(void)
730  {
731  	const char *data = testdata;
732  	int datalen = testdatalen;
733  	int err = 0;
734  	int res;
735  	int fd_in, fd_out;
736  	off_t pos_in = 0, pos_out = 0;
737  	start_test("copy_file_range");
738  	unlink(testfile);
739  	fd_in = open(testfile, O_CREAT | O_RDWR, 0644);
740  	if (fd_in == -1) {
741  		PERROR("creat");
742  		return -1;
743  	}
744  	res = write(fd_in, data, datalen);
745  	if (res == -1) {
746  		PERROR("write");
747  		close(fd_in);
748  		return -1;
749  	}
750  	if (res != datalen) {
751  		ERROR("write is short: %u instead of %u", res, datalen);
752  		close(fd_in);
753  		return -1;
754  	}
755  	unlink(testfile2);
756  	fd_out = creat(testfile2, 0644);
757  	if (fd_out == -1) {
758  		PERROR("creat");
759  		close(fd_in);
760  		return -1;
761  	}
762  	res = copy_file_range(fd_in, &pos_in, fd_out, &pos_out, datalen, 0);
763  	if (res == -1) {
764  		PERROR("copy_file_range");
765  		close(fd_in);
766  		close(fd_out);
767  		return -1;
768  	}
769  	if (res != datalen) {
770  		ERROR("copy is short: %u instead of %u", res, datalen);
771  		close(fd_in);
772  		close(fd_out);
773  		return -1;
774  	}
775  	res = close(fd_in);
776  	if (res == -1) {
777  		PERROR("close");
778  		close(fd_out);
779  		return -1;
780  	}
781  	res = close(fd_out);
782  	if (res == -1) {
783  		PERROR("close");
784  		return -1;
785  	}
786  	err = check_data(testfile2, data, 0, datalen);
787  	res = unlink(testfile);
788  	if (res == -1) {
789  		PERROR("unlink");
790  		return -1;
791  	}
792  	res = check_nonexist(testfile);
793  	if (res == -1)
794  		return -1;
795  	if (err)
796  		return -1;
797  	res = unlink(testfile2);
798  	if (res == -1) {
799  		PERROR("unlink");
800  		return -1;
801  	}
802  	res = check_nonexist(testfile2);
803  	if (res == -1)
804  		return -1;
805  	if (err)
806  		return -1;
807  	success();
<span onclick='openModal()' class='match'>808  	return 0;
809  }
810  #else
811  static int test_copy_file_range(void)
812  {
813  	return 0;
814  }
815  #endif
816  static int test_utime(void)
</span>817  {
818  	struct utimbuf utm;
819  	time_t atime = 987631200;
820  	time_t mtime = 123116400;
821  	int res;
822  	start_test("utime");
823  	res = create_testfile(testfile, NULL, 0);
824  	if (res == -1)
825  		return -1;
826  	utm.actime = atime;
827  	utm.modtime = mtime;
828  	res = utime(testfile, &utm);
829  	if (res == -1) {
830  		PERROR("utime");
831  		return -1;
832  	}
833  	res = check_times(testfile, atime, mtime);
834  	if (res == -1) {
835  		return -1;
836  	}
837  	res = unlink(testfile);
838  	if (res == -1) {
839  		PERROR("unlink");
840  		return -1;
841  	}
842  	res = check_nonexist(testfile);
843  	if (res == -1)
844  		return -1;
845  	success();
846  	return 0;
847  }
848  static int test_create(void)
849  {
850  	const char *data = testdata;
851  	int datalen = testdatalen;
852  	int err = 0;
853  	int res;
854  	int fd;
855  	start_test("create");
856  	unlink(testfile);
857  	fd = creat(testfile, 0644);
858  	if (fd == -1) {
859  		PERROR("creat");
860  		return -1;
861  	}
862  	res = write(fd, data, datalen);
863  	if (res == -1) {
864  		PERROR("write");
865  		close(fd);
866  		return -1;
867  	}
868  	if (res != datalen) {
869  		ERROR("write is short: %u instead of %u", res, datalen);
870  		close(fd);
871  		return -1;
872  	}
873  	res = close(fd);
874  	if (res == -1) {
875  		PERROR("close");
876  		return -1;
877  	}
878  	res = check_type(testfile, S_IFREG);
879  	if (res == -1)
880  		return -1;
881  	err += check_mode(testfile, 0644);
882  	err += check_nlink(testfile, 1);
883  	err += check_size(testfile, datalen);
884  	err += check_data(testfile, data, 0, datalen);
885  	res = unlink(testfile);
886  	if (res == -1) {
887  		PERROR("unlink");
888  		return -1;
889  	}
890  	res = check_nonexist(testfile);
891  	if (res == -1)
892  		return -1;
893  	if (err)
894  		return -1;
895  	success();
896  	return 0;
897  }
898  static int test_create_unlink(void)
899  {
900  	const char *data = testdata;
901  	int datalen = testdatalen;
902  	int err = 0;
903  	int res;
904  	int fd;
905  	start_test("create+unlink");
906  	unlink(testfile);
907  	fd = open(testfile, O_CREAT | O_RDWR | O_TRUNC, 0644);
908  	if (fd == -1) {
909  		PERROR("creat");
910  		return -1;
911  	}
912  	res = unlink(testfile);
913  	if (res == -1) {
914  		PERROR("unlink");
915  		close(fd);
916  		return -1;
917  	}
918  	res = check_nonexist(testfile);
919  	if (res == -1) {
920  		close(fd);
921  		return -1;
922  	}
923  	res = write(fd, data, datalen);
924  	if (res == -1) {
925  		PERROR("write");
926  		close(fd);
927  		return -1;
928  	}
929  	if (res != datalen) {
930  		ERROR("write is short: %u instead of %u", res, datalen);
931  		close(fd);
932  		return -1;
933  	}
934  	struct stat st = {
935  		.st_mode = S_IFREG | 0644,
936  		.st_size = datalen,
937  	};
938  	err = fcheck_stat(fd, O_RDWR, &st);
939  	err += fcheck_data(fd, data, 0, datalen);
940  	res = close(fd);
941  	if (res == -1) {
942  		PERROR("close");
943  		err--;
944  	}
945  	if (err)
946  		return -1;
947  	success();
948  	return 0;
949  }
950  #ifndef __FreeBSD__
951  static int test_mknod(void)
952  {
953  	int err = 0;
954  	int res;
955  	start_test("mknod");
956  	unlink(testfile);
957  	res = mknod(testfile, 0644, 0);
958  	if (res == -1) {
959  		PERROR("mknod");
960  		return -1;
961  	}
962  	res = check_type(testfile, S_IFREG);
963  	if (res == -1)
964  		return -1;
965  	err += check_mode(testfile, 0644);
966  	err += check_nlink(testfile, 1);
967  	err += check_size(testfile, 0);
968  	res = unlink(testfile);
969  	if (res == -1) {
970  		PERROR("unlink");
971  		return -1;
972  	}
973  	res = check_nonexist(testfile);
974  	if (res == -1)
975  		return -1;
976  	if (err)
977  		return -1;
978  	success();
979  	return 0;
980  }
981  #endif
982  #define test_open(exist, flags, mode)  do_test_open(exist, flags, #flags, mode)
983  static int do_test_open(int exist, int flags, const char *flags_str, int mode)
984  {
985  	char buf[4096];
986  	const char *data = testdata;
987  	int datalen = testdatalen;
988  	unsigned currlen = 0;
989  	int err = 0;
990  	int res;
991  	int fd;
992  	off_t off;
993  	start_test("open(%s, %s, 0%03o)", exist ? "+" : "-", flags_str, mode);
994  	unlink(testfile);
995  	if (exist) {
996  		res = create_file(testfile_r, testdata2, testdata2len);
997  		if (res == -1)
998  			return -1;
999  		currlen = testdata2len;
1000  	}
1001  	fd = open(testfile, flags, mode);
1002  	if ((flags & O_CREAT) && (flags & O_EXCL) && exist) {
1003  		if (fd != -1) {
1004  			ERROR("open should have failed");
1005  			close(fd);
1006  			return -1;
1007  		} else if (errno == EEXIST)
1008  			goto succ;
1009  	}
1010  	if (!(flags & O_CREAT) && !exist) {
1011  		if (fd != -1) {
1012  			ERROR("open should have failed");
1013  			close(fd);
1014  			return -1;
1015  		} else if (errno == ENOENT)
1016  			goto succ;
1017  	}
1018  	if (fd == -1) {
1019  		PERROR("open");
1020  		return -1;
1021  	}
1022  	if (flags & O_TRUNC)
1023  		currlen = 0;
1024  	err += check_type(testfile, S_IFREG);
1025  	if (exist)
1026  		err += check_mode(testfile, 0644);
1027  	else
1028  		err += check_mode(testfile, mode);
1029  	err += check_nlink(testfile, 1);
1030  	err += check_size(testfile, currlen);
1031  	if (exist && !(flags & O_TRUNC) && (mode & S_IRUSR))
1032  		err += check_data(testfile, testdata2, 0, testdata2len);
1033  	res = write(fd, data, datalen);
1034  	if ((flags & O_ACCMODE) != O_RDONLY) {
1035  		if (res == -1) {
1036  			PERROR("write");
1037  			err --;
1038  		} else if (res != datalen) {
1039  			ERROR("write is short: %u instead of %u", res, datalen);
1040  			err --;
1041  		} else {
1042  			if (datalen > (int) currlen)
1043  				currlen = datalen;
1044  			err += check_size(testfile, currlen);
1045  			if (mode & S_IRUSR) {
1046  				err += check_data(testfile, data, 0, datalen);
1047  				if (exist && !(flags & O_TRUNC) &&
1048  				    testdata2len > datalen)
1049  					err += check_data(testfile,
1050  							  testdata2 + datalen,
1051  							  datalen,
1052  							  testdata2len - datalen);
1053  			}
1054  		}
1055  	} else {
1056  		if (res != -1) {
1057  			ERROR("write should have failed");
1058  			err --;
1059  		} else if (errno != EBADF) {
1060  			PERROR("write");
1061  			err --;
1062  		}
1063  	}
1064  	off = lseek(fd, SEEK_SET, 0);
1065  	if (off == (off_t) -1) {
1066  		PERROR("lseek");
1067  		err--;
1068  	} else if (off != 0) {
1069  		ERROR("offset should have returned 0");
1070  		err --;
1071  	}
1072  	res = read(fd, buf, sizeof(buf));
1073  	if ((flags & O_ACCMODE) != O_WRONLY) {
1074  		if (res == -1) {
1075  			PERROR("read");
1076  			err--;
1077  		} else {
1078  			int readsize =
1079  				currlen < sizeof(buf) ? currlen : sizeof(buf);
1080  			if (res != readsize) {
1081  				ERROR("read is short: %i instead of %u",
1082  				      res, readsize);
1083  				err--;
1084  			} else {
1085  				if ((flags & O_ACCMODE) != O_RDONLY) {
1086  					err += check_buffer(buf, data, datalen);
1087  					if (exist && !(flags & O_TRUNC) &&
1088  					    testdata2len > datalen)
1089  						err += check_buffer(buf + datalen,
1090  								    testdata2 + datalen,
1091  								    testdata2len - datalen);
1092  				} else if (exist)
1093  					err += check_buffer(buf, testdata2,
1094  							    testdata2len);
1095  			}
1096  		}
1097  	} else {
1098  		if (res != -1) {
1099  			ERROR("read should have failed");
1100  			err --;
1101  		} else if (errno != EBADF) {
1102  			PERROR("read");
1103  			err --;
1104  		}
1105  	}
1106  	res = close(fd);
1107  	if (res == -1) {
1108  		PERROR("close");
1109  		return -1;
1110  	}
1111  	res = unlink(testfile);
1112  	if (res == -1) {
1113  		PERROR("unlink");
1114  		return -1;
1115  	}
1116  	res = check_nonexist(testfile);
1117  	if (res == -1)
1118  		return -1;
1119  	res = check_nonexist(testfile_r);
1120  	if (res == -1)
1121  		return -1;
1122  	if (err)
1123  		return -1;
1124  succ:
1125  	success();
1126  	return 0;
1127  }
1128  #define test_open_acc(flags, mode, err)	 \
1129  	do_test_open_acc(flags, #flags, mode, err)
1130  static int do_test_open_acc(int flags, const char *flags_str, int mode, int err)
1131  {
1132  	const char *data = testdata;
1133  	int datalen = testdatalen;
1134  	int res;
1135  	int fd;
1136  	start_test("open_acc(%s) mode: 0%03o message: '%s'", flags_str, mode,
1137  		   strerror(err));
1138  	unlink(testfile);
1139  	res = create_testfile(testfile, data, datalen);
1140  	if (res == -1)
1141  		return -1;
1142  	res = chmod(testfile, mode);
1143  	if (res == -1) {
1144  		PERROR("chmod");
1145  		return -1;
1146  	}
1147  	res = check_testfile_mode(testfile, mode);
1148  	if (res == -1)
1149  		return -1;
1150  	fd = open(testfile, flags);
1151  	if (fd == -1) {
1152  		if (err != errno) {
1153  			PERROR("open");
1154  			return -1;
1155  		}
1156  	} else {
1157  		if (err) {
1158  			ERROR("open should have failed");
1159  			close(fd);
1160  			return -1;
1161  		}
1162  		close(fd);
1163  	}
1164  	res = unlink(testfile);
1165  	if (res == -1) {
1166  		PERROR("unlink");
1167  		return -1;
1168  	}
1169  	res = check_nonexist(testfile);
1170  	if (res == -1)
1171  		return -1;
1172  	res = check_nonexist(testfile_r);
1173  	if (res == -1)
1174  		return -1;
1175  	success();
1176  	return 0;
1177  }
1178  static int test_symlink(void)
1179  {
1180  	char buf[1024];
1181  	const char *data = testdata;
1182  	int datalen = testdatalen;
1183  	int linklen = strlen(testfile);
1184  	int err = 0;
1185  	int res;
1186  	start_test("symlink");
1187  	res = create_testfile(testfile, data, datalen);
1188  	if (res == -1)
1189  		return -1;
1190  	unlink(testfile2);
1191  	res = symlink(testfile, testfile2);
1192  	if (res == -1) {
1193  		PERROR("symlink");
1194  		return -1;
1195  	}
1196  	res = check_type(testfile2, S_IFLNK);
1197  	if (res == -1)
1198  		return -1;
1199  	err += check_mode(testfile2, 0777);
1200  	err += check_nlink(testfile2, 1);
1201  	res = readlink(testfile2, buf, sizeof(buf));
1202  	if (res == -1) {
1203  		PERROR("readlink");
1204  		err--;
1205  	}
1206  	if (res != linklen) {
1207  		ERROR("short readlink: %u instead of %u", res, linklen);
1208  		err--;
1209  	}
1210  	if (memcmp(buf, testfile, linklen) != 0) {
1211  		ERROR("link mismatch");
1212  		err--;
1213  	}
1214  	err += check_size(testfile2, datalen);
1215  	err += check_data(testfile2, data, 0, datalen);
1216  	res = unlink(testfile2);
1217  	if (res == -1) {
1218  		PERROR("unlink");
1219  		return -1;
1220  	}
1221  	res = check_nonexist(testfile2);
1222  	if (res == -1)
1223  		return -1;
1224  	if (err)
1225  		return -1;
1226  	res = unlink(testfile);
1227  	if (res == -1) {
1228  		PERROR("unlink");
1229  		return -1;
1230  	}
1231  	res = check_nonexist(testfile);
1232  	if (res == -1)
1233  		return -1;
1234  	success();
1235  	return 0;
1236  }
1237  static int test_link(void)
1238  {
1239  	const char *data = testdata;
1240  	int datalen = testdatalen;
1241  	int err = 0;
1242  	int res;
1243  	start_test("link");
1244  	res = create_testfile(testfile, data, datalen);
1245  	if (res == -1)
1246  		return -1;
1247  	unlink(testfile2);
1248  	res = link(testfile, testfile2);
1249  	if (res == -1) {
1250  		PERROR("link");
1251  		return -1;
1252  	}
1253  	res = check_type(testfile2, S_IFREG);
1254  	if (res == -1)
1255  		return -1;
1256  	err += check_mode(testfile2, 0644);
1257  	err += check_nlink(testfile2, 2);
1258  	err += check_size(testfile2, datalen);
1259  	err += check_data(testfile2, data, 0, datalen);
1260  	res = unlink(testfile);
1261  	if (res == -1) {
1262  		PERROR("unlink");
1263  		return -1;
1264  	}
1265  	res = check_nonexist(testfile);
1266  	if (res == -1)
1267  		return -1;
1268  	err += check_nlink(testfile2, 1);
1269  	res = unlink(testfile2);
1270  	if (res == -1) {
1271  		PERROR("unlink");
1272  		return -1;
1273  	}
1274  	res = check_nonexist(testfile2);
1275  	if (res == -1)
1276  		return -1;
1277  	if (err)
1278  		return -1;
1279  	success();
1280  	return 0;
1281  }
1282  static int test_link2(void)
1283  {
1284  	const char *data = testdata;
1285  	int datalen = testdatalen;
1286  	int err = 0;
1287  	int res;
1288  	start_test("link-unlink-link");
1289  	res = create_testfile(testfile, data, datalen);
1290  	if (res == -1)
1291  		return -1;
1292  	unlink(testfile2);
1293  	res = link(testfile, testfile2);
1294  	if (res == -1) {
1295  		PERROR("link");
1296  		return -1;
1297  	}
1298  	res = unlink(testfile);
1299  	if (res == -1) {
1300  		PERROR("unlink");
1301  		return -1;
1302  	}
1303  	res = check_nonexist(testfile);
1304  	if (res == -1)
1305  		return -1;
1306  	res = link(testfile2, testfile);
1307  	if (res == -1) {
1308  		PERROR("link");
1309  	}
1310  	res = check_type(testfile, S_IFREG);
1311  	if (res == -1)
1312  		return -1;
1313  	err += check_mode(testfile, 0644);
1314  	err += check_nlink(testfile, 2);
1315  	err += check_size(testfile, datalen);
1316  	err += check_data(testfile, data, 0, datalen);
1317  	res = unlink(testfile2);
1318  	if (res == -1) {
1319  		PERROR("unlink");
1320  		return -1;
1321  	}
1322  	err += check_nlink(testfile, 1);
1323  	res = unlink(testfile);
1324  	if (res == -1) {
1325  		PERROR("unlink");
1326  		return -1;
1327  	}
1328  	res = check_nonexist(testfile);
1329  	if (res == -1)
1330  		return -1;
1331  	if (err)
1332  		return -1;
1333  	success();
1334  	return 0;
1335  }
1336  static int test_rename_file(void)
1337  {
1338  	const char *data = testdata;
1339  	int datalen = testdatalen;
1340  	int err = 0;
1341  	int res;
1342  	start_test("rename file");
1343  	res = create_testfile(testfile, data, datalen);
1344  	if (res == -1)
1345  		return -1;
1346  	unlink(testfile2);
1347  	res = rename(testfile, testfile2);
1348  	if (res == -1) {
1349  		PERROR("rename");
1350  		return -1;
1351  	}
1352  	res = check_nonexist(testfile);
1353  	if (res == -1)
1354  		return -1;
1355  	res = check_type(testfile2, S_IFREG);
1356  	if (res == -1)
1357  		return -1;
1358  	err += check_mode(testfile2, 0644);
1359  	err += check_nlink(testfile2, 1);
1360  	err += check_size(testfile2, datalen);
1361  	err += check_data(testfile2, data, 0, datalen);
1362  	res = unlink(testfile2);
1363  	if (res == -1) {
1364  		PERROR("unlink");
1365  		return -1;
1366  	}
1367  	res = check_nonexist(testfile2);
1368  	if (res == -1)
1369  		return -1;
1370  	if (err)
1371  		return -1;
1372  	success();
1373  	return 0;
1374  }
1375  static int test_rename_dir(void)
1376  {
1377  	int err = 0;
1378  	int res;
1379  	start_test("rename dir");
1380  	res = create_dir(testdir, testdir_files);
1381  	if (res == -1)
1382  		return -1;
1383  	rmdir(testdir2);
1384  	res = rename(testdir, testdir2);
1385  	if (res == -1) {
1386  		PERROR("rename");
1387  		cleanup_dir(testdir, testdir_files, 1);
1388  		return -1;
1389  	}
1390  	res = check_nonexist(testdir);
1391  	if (res == -1) {
1392  		cleanup_dir(testdir, testdir_files, 1);
1393  		return -1;
1394  	}
1395  	res = check_type(testdir2, S_IFDIR);
1396  	if (res == -1) {
1397  		cleanup_dir(testdir2, testdir_files, 1);
1398  		return -1;
1399  	}
1400  	err += check_mode(testdir2, 0755);
1401  	err += check_dir_contents(testdir2, testdir_files);
1402  	err += cleanup_dir(testdir2, testdir_files, 0);
1403  	res = rmdir(testdir2);
1404  	if (res == -1) {
1405  		PERROR("rmdir");
1406  		return -1;
1407  	}
1408  	res = check_nonexist(testdir2);
1409  	if (res == -1)
1410  		return -1;
1411  	if (err)
1412  		return -1;
1413  	success();
1414  	return 0;
1415  }
1416  static int test_rename_dir_loop(void)
1417  {
1418  #define PATH(p)		(snprintf(path, sizeof path, "%s/%s", testdir, p), path)
1419  #define PATH2(p)	(snprintf(path2, sizeof path2, "%s/%s", testdir, p), path2)
1420  	char path[1280], path2[1280];
1421  	int err = 0;
1422  	int res;
1423  	start_test("rename dir loop");
1424  	res = create_dir(testdir, testdir_files);
1425  	if (res == -1)
1426  		return -1;
1427  	res = mkdir(PATH("a"), 0755);
1428  	if (res == -1) {
1429  		PERROR("mkdir");
1430  		goto fail;
1431  	}
1432  	res = rename(PATH("a"), PATH2("a"));
1433  	if (res == -1) {
1434  		PERROR("rename");
1435  		goto fail;
1436  	}
1437  	errno = 0;
1438  	res = rename(PATH("a"), PATH2("a/b"));
1439  	if (res == 0 || errno != EINVAL) {
1440  		PERROR("rename");
1441  		goto fail;
1442  	}
1443  	res = mkdir(PATH("a/b"), 0755);
1444  	if (res == -1) {
1445  		PERROR("mkdir");
1446  		goto fail;
1447  	}
1448  	res = mkdir(PATH("a/b/c"), 0755);
1449  	if (res == -1) {
1450  		PERROR("mkdir");
1451  		goto fail;
1452  	}
1453  	errno = 0;
1454  	res = rename(PATH("a"), PATH2("a/b/c"));
1455  	if (res == 0 || errno != EINVAL) {
1456  		PERROR("rename");
1457  		goto fail;
1458  	}
1459  	errno = 0;
1460  	res = rename(PATH("a"), PATH2("a/b/c/a"));
1461  	if (res == 0 || errno != EINVAL) {
1462  		PERROR("rename");
1463  		goto fail;
1464  	}
1465  	errno = 0;
1466  	res = rename(PATH("a/b/c"), PATH2("a"));
1467  	if (res == 0 || errno != ENOTEMPTY) {
1468  		PERROR("rename");
1469  		goto fail;
1470  	}
1471  	res = open(PATH("a/foo"), O_CREAT, 0644);
1472  	if (res == -1) {
1473  		PERROR("open");
1474  		goto fail;
1475  	}
1476  	close(res);
1477  	res = rename(PATH("a/foo"), PATH2("a/bar"));
1478  	if (res == -1) {
1479  		PERROR("rename");
1480  		goto fail;
1481  	}
1482  	res = rename(PATH("a/bar"), PATH2("a/foo"));
1483  	if (res == -1) {
1484  		PERROR("rename");
1485  		goto fail;
1486  	}
1487  	res = rename(PATH("a/foo"), PATH2("a/b/bar"));
1488  	if (res == -1) {
1489  		PERROR("rename");
1490  		goto fail;
1491  	}
1492  	res = rename(PATH("a/b/bar"), PATH2("a/foo"));
1493  	if (res == -1) {
1494  		PERROR("rename");
1495  		goto fail;
1496  	}
1497  	res = rename(PATH("a/foo"), PATH2("a/b/c/bar"));
1498  	if (res == -1) {
1499  		PERROR("rename");
1500  		goto fail;
1501  	}
1502  	res = rename(PATH("a/b/c/bar"), PATH2("a/foo"));
1503  	if (res == -1) {
1504  		PERROR("rename");
1505  		goto fail;
1506  	}
1507  	res = open(PATH("a/bar"), O_CREAT, 0644);
1508  	if (res == -1) {
1509  		PERROR("open");
1510  		goto fail;
1511  	}
1512  	close(res);
1513  	res = rename(PATH("a/foo"), PATH2("a/bar"));
1514  	if (res == -1) {
1515  		PERROR("rename");
1516  		goto fail;
1517  	}
1518  	unlink(PATH("a/bar"));
1519  	res = rename(PATH("a/b"), PATH2("a/d"));
1520  	if (res == -1) {
1521  		PERROR("rename");
1522  		goto fail;
1523  	}
1524  	res = rename(PATH("a/d"), PATH2("a/b"));
1525  	if (res == -1) {
1526  		PERROR("rename");
1527  		goto fail;
1528  	}
1529  	res = mkdir(PATH("a/d"), 0755);
1530  	if (res == -1) {
1531  		PERROR("mkdir");
1532  		goto fail;
1533  	}
1534  	res = rename(PATH("a/b"), PATH2("a/d"));
1535  	if (res == -1) {
1536  		PERROR("rename");
1537  		goto fail;
1538  	}
1539  	res = rename(PATH("a/d"), PATH2("a/b"));
1540  	if (res == -1) {
1541  		PERROR("rename");
1542  		goto fail;
1543  	}
1544  	res = mkdir(PATH("a/d"), 0755);
1545  	if (res == -1) {
1546  		PERROR("mkdir");
1547  		goto fail;
1548  	}
1549  	res = mkdir(PATH("a/d/e"), 0755);
1550  	if (res == -1) {
1551  		PERROR("mkdir");
1552  		goto fail;
1553  	}
1554  	errno = 0;
1555  	res = rename(PATH("a/b"), PATH2("a/d"));
1556  	if (res == 0 || (errno != ENOTEMPTY && errno != EEXIST)) {
1557  		PERROR("rename");
1558  		goto fail;
1559  	}
1560  	rmdir(PATH("a/d/e"));
1561  	rmdir(PATH("a/d"));
1562   	rmdir(PATH("a/b/c"));
1563  	rmdir(PATH("a/b"));
1564  	rmdir(PATH("a"));
1565  	err += cleanup_dir(testdir, testdir_files, 0);
1566  	res = rmdir(testdir);
1567  	if (res == -1) {
1568  		PERROR("rmdir");
1569  		goto fail;
1570  	}
1571  	res = check_nonexist(testdir);
1572  	if (res == -1)
1573  		return -1;
1574  	if (err)
1575  		return -1;
1576  	success();
1577  	return 0;
1578  fail:
1579  	unlink(PATH("a/bar"));
1580  	rmdir(PATH("a/d/e"));
1581  	rmdir(PATH("a/d"));
1582   	rmdir(PATH("a/b/c"));
1583  	rmdir(PATH("a/b"));
1584  	rmdir(PATH("a"));
1585  	cleanup_dir(testdir, testdir_files, 1);
1586  	rmdir(testdir);
1587  	return -1;
1588  #undef PATH2
1589  #undef PATH
1590  }
1591  #ifndef __FreeBSD__
1592  static int test_mkfifo(void)
1593  {
1594  	int res;
1595  	int err = 0;
1596  	start_test("mkfifo");
1597  	unlink(testfile);
1598  	res = mkfifo(testfile, 0644);
1599  	if (res == -1) {
1600  		PERROR("mkfifo");
1601  		return -1;
1602  	}
1603  	res = check_type(testfile, S_IFIFO);
1604  	if (res == -1)
1605  		return -1;
1606  	err += check_mode(testfile, 0644);
1607  	err += check_nlink(testfile, 1);
1608  	res = unlink(testfile);
1609  	if (res == -1) {
1610  		PERROR("unlink");
1611  		return -1;
1612  	}
1613  	res = check_nonexist(testfile);
1614  	if (res == -1)
1615  		return -1;
1616  	if (err)
1617  		return -1;
1618  	success();
1619  	return 0;
1620  }
1621  #endif
1622  static int test_mkdir(void)
1623  {
1624  	int res;
1625  	int err = 0;
1626  	const char *dir_contents[] = {NULL};
1627  	start_test("mkdir");
1628  	rmdir(testdir);
1629  	res = mkdir(testdir, 0755);
1630  	if (res == -1) {
1631  		PERROR("mkdir");
1632  		return -1;
1633  	}
1634  	res = check_type(testdir, S_IFDIR);
1635  	if (res == -1)
1636  		return -1;
1637  	err += check_mode(testdir, 0755);
1638  	err += check_dir_contents(testdir, dir_contents);
1639  	res = rmdir(testdir);
1640  	if (res == -1) {
1641  		PERROR("rmdir");
1642  		return -1;
1643  	}
1644  	res = check_nonexist(testdir);
1645  	if (res == -1)
1646  		return -1;
1647  	if (err)
1648  		return -1;
1649  	success();
1650  	return 0;
1651  }
1652  static int test_socket(void)
1653  {
1654  	struct sockaddr_un su;
1655  	int fd;
1656  	int res;
1657  	int err = 0;
1658      const size_t test_sock_len = strlen(testsock) + 1;
1659  	start_test("socket");
1660  	if (test_sock_len > sizeof(su.sun_path)) {
1661  		fprintf(stderr, "Need to shorten mount point by %zu chars\n",
1662  			strlen(testsock) + 1 - sizeof(su.sun_path));
1663  		return -1;
1664  	}
1665  	unlink(testsock);
1666  	fd = socket(AF_UNIX, SOCK_STREAM, 0);
1667  	if (fd < 0) {
1668  		PERROR("socket");
1669  		return -1;
1670  	}
1671  	su.sun_family = AF_UNIX;
1672  	strncpy(su.sun_path, testsock, test_sock_len);
1673  	su.sun_path[sizeof(su.sun_path) - 1] = '\0';
1674  	res = bind(fd, (struct sockaddr*)&su, sizeof(su));
1675  	if (res == -1) {
1676  		PERROR("bind");
1677  		return -1;
1678  	}
1679  	res = check_type(testsock, S_IFSOCK);
1680  	if (res == -1) {
1681  		close(fd);
1682  		return -1;
1683  	}
1684  	err += check_nlink(testsock, 1);
1685  	close(fd);
1686  	res = unlink(testsock);
1687  	if (res == -1) {
1688  		PERROR("unlink");
1689  		return -1;
1690  	}
1691  	res = check_nonexist(testsock);
1692  	if (res == -1)
1693  		return -1;
1694  	if (err)
1695  		return -1;
1696  	success();
1697  	return 0;
1698  }
1699  #define test_create_ro_dir(flags)	 \
1700  	do_test_create_ro_dir(flags, #flags)
1701  static int do_test_create_ro_dir(int flags, const char *flags_str)
1702  {
1703  	int res;
1704  	int err = 0;
1705  	int fd;
1706  	start_test("open(%s) in read-only directory", flags_str);
1707  	rmdir(testdir);
1708  	res = mkdir(testdir, 0555);
1709  	if (res == -1) {
1710  		PERROR("mkdir");
1711  		return -1;
1712  	}
1713  	fd = open(subfile, flags, 0644);
1714  	if (fd != -1) {
1715  		close(fd);
1716  		unlink(subfile);
1717  		ERROR("open should have failed");
1718  		err--;
1719  	} else {
1720  		res = check_nonexist(subfile);
1721  		if (res == -1)
1722  			err--;
1723  	}
1724  	unlink(subfile);
1725  	res = rmdir(testdir);
1726  	if (res == -1) {
1727  		PERROR("rmdir");
1728  		return -1;
1729  	}
1730  	res = check_nonexist(testdir);
1731  	if (res == -1)
1732  		return -1;
1733  	if (err)
1734  		return -1;
1735  	success();
1736  	return 0;
1737  }
1738  int main(int argc, char *argv[])
1739  {
1740  	int err = 0;
1741  	int a;
1742  	int is_root;
1743  	umask(0);
1744  	if (argc < 2 || argc > 4) {
1745  		fprintf(stderr, "usage: %s testdir [:realdir] [[-]test#] [-u]\n", argv[0]);
1746  		return 1;
1747  	}
1748  	basepath = argv[1];
1749  	basepath_r = basepath;
1750  	for (a = 2; a < argc; a++) {
1751  		char *endptr;
1752  		char *arg = argv[a];
1753  		if (arg[0] == ':') {
1754  			basepath_r = arg + 1;
1755  		} else {
1756  			if (arg[0] == '-') {
1757  				arg++;
1758  				if (arg[0] == 'u') {
1759  					unlinked_test = 1;
1760  					endptr = arg + 1;
1761  				} else {
1762  					skip_test = strtoul(arg, &endptr, 10);
1763  				}
1764  			} else {
1765  				select_test = strtoul(arg, &endptr, 10);
1766  			}
1767  			if (arg[0] == '\0' || *endptr != '\0') {
1768  				fprintf(stderr, "invalid option: '%s'\n", argv[a]);
1769  				return 1;
1770  			}
1771  		}
1772  	}
1773  	assert(strlen(basepath) < 512);
1774  	assert(strlen(basepath_r) < 512);
1775  	if (basepath[0] != '/') {
1776  		fprintf(stderr, "testdir must be an absolute path\n");
1777  		return 1;
1778  	}
1779  	sprintf(testfile, "%s/testfile", basepath);
1780  	sprintf(testfile2, "%s/testfile2", basepath);
1781  	sprintf(testdir, "%s/testdir", basepath);
1782  	sprintf(testdir2, "%s/testdir2", basepath);
1783  	sprintf(subfile, "%s/subfile", testdir2);
1784  	sprintf(testsock, "%s/testsock", basepath);
1785  	sprintf(testfile_r, "%s/testfile", basepath_r);
1786  	sprintf(testfile2_r, "%s/testfile2", basepath_r);
1787  	sprintf(testdir_r, "%s/testdir", basepath_r);
1788  	sprintf(testdir2_r, "%s/testdir2", basepath_r);
1789  	sprintf(subfile_r, "%s/subfile", testdir2_r);
1790  	is_root = (geteuid() == 0);
1791  	err += test_create();
1792  	err += test_create_unlink();
1793  	err += test_symlink();
1794  	err += test_link();
1795  	err += test_link2();
1796  #ifndef __FreeBSD__	
1797  	err += test_mknod();
1798  	err += test_mkfifo();
1799  #endif
1800  	err += test_mkdir();
1801  	err += test_rename_file();
1802  	err += test_rename_dir();
1803  	err += test_rename_dir_loop();
1804  	err += test_seekdir();
1805  	err += test_socket();
1806  	err += test_utime();
1807  	err += test_truncate(0);
1808  	err += test_truncate(testdatalen / 2);
1809  	err += test_truncate(testdatalen);
1810  	err += test_truncate(testdatalen + 100);
1811  	err += test_ftruncate(0, 0600);
1812  	err += test_ftruncate(testdatalen / 2, 0600);
1813  	err += test_ftruncate(testdatalen, 0600);
1814  	err += test_ftruncate(testdatalen + 100, 0600);
1815  	err += test_ftruncate(0, 0400);
1816  	err += test_ftruncate(0, 0200);
1817  	err += test_ftruncate(0, 0000);
1818  	err += test_open(0, O_RDONLY, 0);
1819  	err += test_open(1, O_RDONLY, 0);
1820  	err += test_open(1, O_RDWR, 0);
1821  	err += test_open(1, O_WRONLY, 0);
1822  	err += test_open(0, O_RDWR | O_CREAT, 0600);
1823  	err += test_open(1, O_RDWR | O_CREAT, 0600);
1824  	err += test_open(0, O_RDWR | O_CREAT | O_TRUNC, 0600);
1825  	err += test_open(1, O_RDWR | O_CREAT | O_TRUNC, 0600);
1826  	err += test_open(0, O_RDONLY | O_CREAT, 0600);
1827  	err += test_open(0, O_RDONLY | O_CREAT, 0400);
1828  	err += test_open(0, O_RDONLY | O_CREAT, 0200);
1829  	err += test_open(0, O_RDONLY | O_CREAT, 0000);
1830  	err += test_open(0, O_WRONLY | O_CREAT, 0600);
1831  	err += test_open(0, O_WRONLY | O_CREAT, 0400);
1832  	err += test_open(0, O_WRONLY | O_CREAT, 0200);
1833  	err += test_open(0, O_WRONLY | O_CREAT, 0000);
1834  	err += test_open(0, O_RDWR | O_CREAT, 0400);
1835  	err += test_open(0, O_RDWR | O_CREAT, 0200);
1836  	err += test_open(0, O_RDWR | O_CREAT, 0000);
1837  	err += test_open(0, O_RDWR | O_CREAT | O_EXCL, 0600);
1838  	err += test_open(1, O_RDWR | O_CREAT | O_EXCL, 0600);
1839  	err += test_open(0, O_RDWR | O_CREAT | O_EXCL, 0000);
1840  	err += test_open(1, O_RDWR | O_CREAT | O_EXCL, 0000);
1841  	err += test_open_acc(O_RDONLY, 0600, 0);
1842  	err += test_open_acc(O_WRONLY, 0600, 0);
1843  	err += test_open_acc(O_RDWR,   0600, 0);
1844  	err += test_open_acc(O_RDONLY, 0400, 0);
1845  	err += test_open_acc(O_WRONLY, 0200, 0);
1846  	if(!is_root) {
1847  		err += test_open_acc(O_RDONLY | O_TRUNC, 0400, EACCES);
1848  		err += test_open_acc(O_WRONLY, 0400, EACCES);
1849  		err += test_open_acc(O_RDWR,   0400, EACCES);
1850  		err += test_open_acc(O_RDONLY, 0200, EACCES);
1851  		err += test_open_acc(O_RDWR,   0200, EACCES);
1852  		err += test_open_acc(O_RDONLY, 0000, EACCES);
1853  		err += test_open_acc(O_WRONLY, 0000, EACCES);
1854  		err += test_open_acc(O_RDWR,   0000, EACCES);
1855  	}
1856  	err += test_create_ro_dir(O_CREAT);
1857  	err += test_create_ro_dir(O_CREAT | O_EXCL);
1858  	err += test_create_ro_dir(O_CREAT | O_WRONLY);
1859  	err += test_create_ro_dir(O_CREAT | O_TRUNC);
1860  	err += test_copy_file_range();
1861  	unlink(testfile2);
1862  	unlink(testsock);
1863  	rmdir(testdir);
1864  	rmdir(testdir2);
1865  	if (err) {
1866  		fprintf(stderr, "%i tests failed\n", -err);
1867  		return 1;
1868  	}
1869  	return check_unlinked_testfiles();
1870  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from PINRemoteImage-MDEwOlJlcG9zaXRvcnkzOTUzNzEwMw==-flat-tiffdec.c</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from libfuse-MDEwOlJlcG9zaXRvcnk0ODI5NjE3Nw==-flat-test_syscalls.c</div>
                </div>
                <div class="column column_space"><pre><code>60    return offset;
61  }
62  static int MyMapFile(thandle_t opaque, void** base, toff_t* size) {
63    (void)opaque;
64    (void)base;
65    (void)size;
66    return 0;
67  }
68  static void MyUnmapFile(thandle_t opaque, void* base, toff_t size) {
</pre></code></div>
                <div class="column column_space"><pre><code>808  	return 0;
809  }
810  #else
811  static int test_copy_file_range(void)
812  {
813  	return 0;
814  }
815  #endif
816  static int test_utime(void)
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    