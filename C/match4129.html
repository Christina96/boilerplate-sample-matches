<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for imdiag.c &amp; omfwd.c</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for imdiag.c &amp; omfwd.c
      </h3>
<h1 align="center">
        1.3%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>imdiag.c (2.4344568%)<th>omfwd.c (0.9393064%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(867-905)<td><a href="#" name="0">(1747-1759)</a><td align="center"><font color="#ff0000">13</font>
</td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>imdiag.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
#include "config.h"
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;assert.h&gt;
#include &lt;string.h&gt;
#include &lt;errno.h&gt;
#include &lt;unistd.h&gt;
#include &lt;stdarg.h&gt;
#include &lt;ctype.h&gt;
#include &lt;signal.h&gt;
#include &lt;netinet/in.h&gt;
#include &lt;netdb.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;sys/socket.h&gt;
#include &lt;pthread.h&gt;
#include &lt;semaphore.h&gt;
#if HAVE_FCNTL_H
#include &lt;fcntl.h&gt;
#endif
#include "rsyslog.h"
#include "dirty.h"
#include "cfsysline.h"
#include "module-template.h"
#include "unicode-helper.h"
#include "net.h"
#include "netstrm.h"
#include "errmsg.h"
#include "tcpsrv.h"
#include "srUtils.h"
#include "msg.h"
#include "datetime.h"
#include "ratelimit.h"
#include "queue.h"
#include "lookup.h"
#include "net.h" #include "statsobj.h"
MODULE_TYPE_INPUT
MODULE_TYPE_NOKEEP
DEF_IMOD_STATIC_DATA
DEFobjCurrIf(tcpsrv)
DEFobjCurrIf(tcps_sess)
DEFobjCurrIf(net)
DEFobjCurrIf(netstrm)
DEFobjCurrIf(datetime)
DEFobjCurrIf(prop)
DEFobjCurrIf(statsobj)
static tcpsrv_t *pOurTcpsrv = NULL;  static permittedPeers_t *pPermPeersRoot = NULL;
static prop_t *pInputName = NULL;
static prop_t *pRcvDummy = NULL;
static prop_t *pRcvIPDummy = NULL;
static int max_empty_checks = 3; 
statsobj_t *diagStats;
STATSCOUNTER_DEF(potentialArtificialDelayMs, mutPotentialArtificialDelayMs)
STATSCOUNTER_DEF(actualArtificialDelayMs, mutActualArtificialDelayMs)
STATSCOUNTER_DEF(delayInvocationCount, mutDelayInvocationCount)
static sem_t statsReportingBlocker;
static long long statsReportingBlockStartTimeMs = 0;
static int allowOnlyOnce = 0;
DEF_ATOMIC_HELPER_MUT(mutAllowOnlyOnce);
pthread_mutex_t mutStatsReporterWatch;
pthread_cond_t statsReporterWatch;
int statsReported = 0;
static int abortTimeout = -1;		static pthread_t timeoutGuard_thrd;	
struct modConfData_s {
	EMPTY_STRUCT;
};
static flowControl_t injectmsgDelayMode = eFLOWCTL_NO_DELAY;
static int iTCPSessMax = 20; static int iStrmDrvrMode = 0; static uchar *pszLstnPortFileName = NULL;
static uchar *pszStrmDrvrAuthMode = NULL; static uchar *pszInputName = NULL; 
static int
isPermittedHost(struct sockaddr __attribute__((unused)) *addr, char __attribute__((unused)) *fromHostFQDN,
		void __attribute__((unused)) *pUsrSrv, void __attribute__((unused)) *pUsrSess)
{
	return 1;	}
static rsRetVal
doOpenLstnSocks(tcpsrv_t *pSrv)
{
	ISOBJ_TYPE_assert(pSrv, tcpsrv);
	dbgprintf("in imdiag doOpenLstnSocks\n");
	return tcpsrv.create_tcp_socket(pSrv);
}
static rsRetVal
doRcvData(tcps_sess_t *pSess, char *buf, size_t lenBuf, ssize_t *piLenRcvd, int *oserr)
{
	assert(pSess != NULL);
	assert(piLenRcvd != NULL);
	*piLenRcvd = lenBuf;
	return netstrm.Rcv(pSess-&gt;pStrm, (uchar*) buf, piLenRcvd, oserr);
}
static rsRetVal
onRegularClose(tcps_sess_t *pSess)
{
	DEFiRet;
	assert(pSess != NULL);
	tcps_sess.PrepareClose(pSess);
	tcps_sess.Close(pSess);
	RETiRet;
}
static rsRetVal
onErrClose(tcps_sess_t *pSess)
{
	DEFiRet;
	assert(pSess != NULL);
	tcps_sess.Close(pSess);
	RETiRet;
}
#define TO_LOWERCASE	1
#define NO_MODIFY	0
static void
getFirstWord(uchar **ppszSrc, uchar *pszBuf, size_t lenBuf, int options)
{
	uchar c;
	uchar *pszSrc = *ppszSrc;
	while(*pszSrc &amp;&amp; *pszSrc == ' ')
		++pszSrc; 
	while(*pszSrc &amp;&amp; *pszSrc != ' ' &amp;&amp; lenBuf &gt; 1) {
		c = *pszSrc++;
		if(options &amp; TO_LOWERCASE)
			c = tolower(c);
		*pszBuf++ = c;
		lenBuf--;
	}
	*pszBuf = '\0';
	*ppszSrc = pszSrc;
}
static rsRetVal __attribute__((format(printf, 2, 3)))
sendResponse(tcps_sess_t *pSess, const char *const __restrict__ fmt, ...)
{
	va_list ap;
	ssize_t len;
	uchar buf[1024];
	DEFiRet;
	va_start(ap, fmt);
	len = vsnprintf((char*)buf, sizeof(buf), fmt, ap);
	va_end(ap);
	CHKiRet(netstrm.Send(pSess-&gt;pStrm, buf, &amp;len));
finalize_it:
	RETiRet;
}
static rsRetVal
doInjectMsg(uchar *szMsg, ratelimit_t *ratelimiter)
{
	smsg_t *pMsg;
	struct syslogTime stTime;
	time_t ttGenTime;
	DEFiRet;
	datetime.getCurrTime(&amp;stTime, &amp;ttGenTime, TIME_IN_LOCALTIME);
	CHKiRet(msgConstructWithTime(&amp;pMsg, &amp;stTime, ttGenTime));
	MsgSetRawMsg(pMsg, (char*) szMsg, ustrlen(szMsg));
	MsgSetInputName(pMsg, pInputName);
	MsgSetFlowControlType(pMsg, injectmsgDelayMode);
	pMsg-&gt;msgFlags  = NEEDS_PARSING | PARSE_HOSTNAME;
	MsgSetRcvFrom(pMsg, pRcvDummy);
	CHKiRet(MsgSetRcvFromIP(pMsg, pRcvIPDummy));
	CHKiRet(ratelimitAddMsg(ratelimiter, NULL, pMsg));
finalize_it:
	RETiRet;
}
static rsRetVal
doInjectNumericSuffixMsg(int iNum, ratelimit_t *ratelimiter)
{
	uchar szMsg[1024];
	DEFiRet;
	snprintf((char*)szMsg, sizeof(szMsg)/sizeof(uchar),
		"&lt;167&gt;Mar  1 01:00:00 172.20.245.8 tag msgnum:%8.8d:", iNum);
	iRet = doInjectMsg(szMsg, ratelimiter);
	RETiRet;
}
static rsRetVal
injectMsg(uchar *pszCmd, tcps_sess_t *pSess)
{
	uchar wordBuf[1024];
	int iFrom, nMsgs;
	uchar *literalMsg;
	int i;
	ratelimit_t *ratelimit = NULL;
	DEFiRet;
	literalMsg = NULL;
	memset(wordBuf, 0, sizeof(wordBuf));
	CHKiRet(ratelimitNew(&amp;ratelimit, "imdiag", "injectmsg"));
	getFirstWord(&amp;pszCmd, wordBuf, sizeof(wordBuf), TO_LOWERCASE);
	if (ustrcmp(UCHAR_CONSTANT("literal"), wordBuf) == 0) {
		++pszCmd; 		CHKiRet(doInjectMsg(pszCmd, ratelimit));
		nMsgs = 1;
	} else { 		iFrom = atoi((char*)wordBuf);
		getFirstWord(&amp;pszCmd, wordBuf, sizeof(wordBuf), TO_LOWERCASE);
		nMsgs = atoi((char*)wordBuf);
		for(i = 0 ; i &lt; nMsgs ; ++i) {
			CHKiRet(doInjectNumericSuffixMsg(i + iFrom, ratelimit));
		}
	}
	CHKiRet(sendResponse(pSess, "%d messages injected\n", nMsgs));
	DBGPRINTF("imdiag: %d messages injected\n", nMsgs);
finalize_it:
	if(ratelimit != NULL)
		ratelimitDestruct(ratelimit);
	free(literalMsg);
	RETiRet;
}
static rsRetVal
waitMainQEmpty(tcps_sess_t *pSess)
{
	int iPrint = 0;
	int iPrintVerbosity = 500; 	int nempty = 0;
	static unsigned lastOverallQueueSize = 1;
	DEFiRet;
	while(1) {
		processImInternal();
		const unsigned OverallQueueSize = PREFER_FETCH_32BIT(iOverallQueueSize);
		if(OverallQueueSize == 0) {
			++nempty;
		} else {
			if(OverallQueueSize &gt; 500) {
				srSleep(0, (OverallQueueSize &gt; 2000) ? 900000 : 100000);
			}
			nempty = 0;
		}
		if(dbgTimeoutToStderr) { 			if(OverallQueueSize != lastOverallQueueSize) {
				fprintf(stderr, "imdiag: wait q_empty: qsize %d nempty %d\n",
					OverallQueueSize, nempty);
				lastOverallQueueSize = OverallQueueSize;
			}
		}
		if(nempty &gt; max_empty_checks)
			break;
		if(iPrint++ % iPrintVerbosity == 0)
			DBGPRINTF("imdiag sleeping, wait queues drain, "
				"curr size %d, nempty %d\n",
				OverallQueueSize, nempty);
		srSleep(0,100000);	}
	CHKiRet(sendResponse(pSess, "mainqueue empty\n"));
	DBGPRINTF("imdiag: mainqueue empty\n");
finalize_it:
	RETiRet;
}
static rsRetVal
awaitLookupTableReload(tcps_sess_t *pSess)
{
	DEFiRet;
	while(1) {
		if(lookupPendingReloadCount() == 0) {
			break;
		}
		srSleep(0,500000);
	}
	CHKiRet(sendResponse(pSess, "no pending lookup-table reloads found\n"));
	DBGPRINTF("imdiag: no pending lookup-table reloads found\n");
finalize_it:
	RETiRet;
}
static rsRetVal
enableDebug(tcps_sess_t *pSess)
{
	DEFiRet;
	Debug = DEBUG_FULL;
	debugging_on = 1;
	dbgprintf("Note: debug turned on via imdiag\n");
	CHKiRet(sendResponse(pSess, "debug enabled\n"));
finalize_it:
	RETiRet;
}
static void
imdiag_statsReadCallback(statsobj_t __attribute__((unused)) *const ignore_stats,
	void __attribute__((unused)) *const ignore_ctx)
{
	long long waitStartTimeMs = currentTimeMills();
	sem_wait(&amp;statsReportingBlocker);
	long delta = currentTimeMills() - waitStartTimeMs;
	if ((int)ATOMIC_DEC_AND_FETCH(&amp;allowOnlyOnce, &amp;mutAllowOnlyOnce) &lt; 0) {
		sem_post(&amp;statsReportingBlocker);
	} else {
		LogError(0, RS_RET_OK, "imdiag(stats-read-callback): current stats-reporting "
						"cycle will proceed now, next reporting cycle will again be blocked");
	}
	if (pthread_mutex_lock(&amp;mutStatsReporterWatch) == 0) {
		statsReported = 1;
		pthread_cond_signal(&amp;statsReporterWatch);
		pthread_mutex_unlock(&amp;mutStatsReporterWatch);
	}
	if (delta &gt; 0) {
		STATSCOUNTER_ADD(actualArtificialDelayMs, mutActualArtificialDelayMs, delta);
	}
}
static rsRetVal
blockStatsReporting(tcps_sess_t *pSess) {
	DEFiRet;
	sem_wait(&amp;statsReportingBlocker);
	CHKiConcCtrl(pthread_mutex_lock(&amp;mutStatsReporterWatch));
	statsReported = 0;
	CHKiConcCtrl(pthread_mutex_unlock(&amp;mutStatsReporterWatch));
	ATOMIC_STORE_0_TO_INT(&amp;allowOnlyOnce, &amp;mutAllowOnlyOnce);
	statsReportingBlockStartTimeMs = currentTimeMills();
	LogError(0, RS_RET_OK, "imdiag: blocked stats reporting");
	CHKiRet(sendResponse(pSess, "next stats reporting call will be blocked\n"));
finalize_it:
	if (iRet != RS_RET_OK) {
		LogError(0, iRet, "imdiag: block-stats-reporting wasn't successful");
		CHKiRet(sendResponse(pSess, "imdiag::error something went wrong\n"));
	}
	RETiRet;
}
static rsRetVal
awaitStatsReport(uchar *pszCmd, tcps_sess_t *pSess) {
	uchar subCmd[1024];
	int blockAgain = 0;
	DEFiRet;
	memset(subCmd, 0, sizeof(subCmd));
	getFirstWord(&amp;pszCmd, subCmd, sizeof(subCmd), TO_LOWERCASE);
	blockAgain = (ustrcmp(UCHAR_CONSTANT("block_again"), subCmd) == 0);
	if (statsReportingBlockStartTimeMs &gt; 0) {
		long delta = currentTimeMills() - statsReportingBlockStartTimeMs;
		if (blockAgain) {
			ATOMIC_STORE_1_TO_INT(&amp;allowOnlyOnce, &amp;mutAllowOnlyOnce);
			LogError(0, RS_RET_OK, "imdiag: un-blocking ONLY the next cycle of stats reporting");
		} else {
			statsReportingBlockStartTimeMs = 0;
			LogError(0, RS_RET_OK, "imdiag: un-blocking stats reporting");
		}
		sem_post(&amp;statsReportingBlocker);
		LogError(0, RS_RET_OK, "imdiag: stats reporting unblocked");
		STATSCOUNTER_ADD(potentialArtificialDelayMs, mutPotentialArtificialDelayMs, delta);
		STATSCOUNTER_INC(delayInvocationCount, mutDelayInvocationCount);
		LogError(0, RS_RET_OK, "imdiag: will now await next reporting cycle");
		CHKiConcCtrl(pthread_mutex_lock(&amp;mutStatsReporterWatch));
		while (! statsReported) {
			CHKiConcCtrl(pthread_cond_wait(&amp;statsReporterWatch, &amp;mutStatsReporterWatch));
		}
		statsReported = 0;
		CHKiConcCtrl(pthread_mutex_unlock(&amp;mutStatsReporterWatch));
		if (blockAgain) {
			statsReportingBlockStartTimeMs = currentTimeMills();
		}
		LogError(0, RS_RET_OK, "imdiag: stats were reported, wait complete, returning");
		CHKiRet(sendResponse(pSess, "stats reporting was unblocked\n"));
	} else {
		CHKiRet(sendResponse(pSess, "imdiag::error : stats reporting was not blocked, bug?\n"));
	}
finalize_it:
	if (iRet != RS_RET_OK) {
		LogError(0, iRet, "imdiag: stats-reporting unblock + await-run wasn't successfully completed");
		CHKiRet(sendResponse(pSess, "imdiag::error something went wrong\n"));
	}
	RETiRet;
}
static rsRetVal ATTR_NONNULL()
OnMsgReceived(tcps_sess_t *const pSess, uchar *const pRcv, const int iLenMsg)
{
	uchar *pszMsg;
	uchar *pToFree = NULL;
	uchar cmdBuf[1024];
	DEFiRet;
	assert(pSess != NULL);
	assert(pRcv != NULL);
	CHKmalloc(pszMsg = calloc(1, iLenMsg + 1));
	pToFree = pszMsg;
	memcpy(pszMsg, pRcv, iLenMsg);
	pszMsg[iLenMsg] = '\0';
	memset(cmdBuf, 0, sizeof(cmdBuf)); 	getFirstWord(&amp;pszMsg, cmdBuf, sizeof(cmdBuf), TO_LOWERCASE);
	dbgprintf("imdiag received command '%s'\n", cmdBuf);
	if(!ustrcmp(cmdBuf, UCHAR_CONSTANT("getmainmsgqueuesize"))) {
		CHKiRet(sendResponse(pSess, "%d\n", iOverallQueueSize));
		DBGPRINTF("imdiag: %d messages in main queue\n", iOverallQueueSize);
	} else if(!ustrcmp(cmdBuf, UCHAR_CONSTANT("waitmainqueueempty"))) {
		CHKiRet(waitMainQEmpty(pSess));
	} else if(!ustrcmp(cmdBuf, UCHAR_CONSTANT("awaitlookuptablereload"))) {
		CHKiRet(awaitLookupTableReload(pSess));
	} else if(!ustrcmp(cmdBuf, UCHAR_CONSTANT("injectmsg"))) {
		CHKiRet(injectMsg(pszMsg, pSess));
	} else if(!ustrcmp(cmdBuf, UCHAR_CONSTANT("blockstatsreporting"))) {
		CHKiRet(blockStatsReporting(pSess));
	} else if(!ustrcmp(cmdBuf, UCHAR_CONSTANT("awaitstatsreport"))) {
		CHKiRet(awaitStatsReport(pszMsg, pSess));
	} else if(!ustrcmp(cmdBuf, UCHAR_CONSTANT("enabledebug"))) {
		CHKiRet(enableDebug(pSess));
	} else {
		dbgprintf("imdiag unkown command '%s'\n", cmdBuf);
		CHKiRet(sendResponse(pSess, "unkown command '%s'\n", cmdBuf));
	}
finalize_it:
	free(pToFree);
	RETiRet;
}
static rsRetVal
setPermittedPeer(void __attribute__((unused)) *pVal, uchar *pszID)
{
	DEFiRet;
	CHKiRet(net.AddPermittedPeer(&amp;pPermPeersRoot, pszID));
	free(pszID); finalize_it:
	RETiRet;
}
static rsRetVal
setInjectDelayMode(void __attribute__((unused)) *pVal, uchar *const pszMode)
{
	DEFiRet;
	if(!strcasecmp((char*)pszMode, "no")) {
		injectmsgDelayMode = eFLOWCTL_NO_DELAY;
	} else if(!strcasecmp((char*)pszMode, "light")) {
		injectmsgDelayMode = eFLOWCTL_LIGHT_DELAY;
	} else if(!strcasecmp((char*)pszMode, "full")) {
		injectmsgDelayMode = eFLOWCTL_FULL_DELAY;
	} else {
		LogError(0, RS_RET_PARAM_ERROR,
			"imdiag: invalid imdiagInjectDelayMode '%s' - ignored", pszMode);
	}
	free(pszMode);
	RETiRet;
}
static rsRetVal
addTCPListener(void __attribute__((unused)) *pVal, uchar *pNewVal)
{
	tcpLstnParams_t *cnf_params = NULL;
	DEFiRet;
	if(pOurTcpsrv != NULL) {
		LogError(0, NO_ERRCODE, "imdiag: only a single listener is supported, "
			"trying to add a second");
		ABORT_FINALIZE(RS_RET_ERR);
	}
	CHKmalloc(cnf_params = (tcpLstnParams_t*) calloc(1, sizeof(tcpLstnParams_t)));
	CHKiRet(tcpsrv.Construct(&amp;pOurTcpsrv));
	CHKiRet(tcpsrv.SetSessMax(pOurTcpsrv, iTCPSessMax));
	CHKiRet(tcpsrv.SetCBIsPermittedHost(pOurTcpsrv, isPermittedHost));
	CHKiRet(tcpsrv.SetCBRcvData(pOurTcpsrv, doRcvData));
	CHKiRet(tcpsrv.SetCBOpenLstnSocks(pOurTcpsrv, doOpenLstnSocks));
	CHKiRet(tcpsrv.SetCBOnRegularClose(pOurTcpsrv, onRegularClose));
	CHKiRet(tcpsrv.SetCBOnErrClose(pOurTcpsrv, onErrClose));
	CHKiRet(tcpsrv.SetDrvrMode(pOurTcpsrv, iStrmDrvrMode));
	CHKiRet(tcpsrv.SetOnMsgReceive(pOurTcpsrv, OnMsgReceived));
	if(pszStrmDrvrAuthMode != NULL) {
		CHKiRet(tcpsrv.SetDrvrAuthMode(pOurTcpsrv, pszStrmDrvrAuthMode));
	}
	if(pPermPeersRoot != NULL) {
		CHKiRet(tcpsrv.SetDrvrPermPeers(pOurTcpsrv, pPermPeersRoot));
	}
	CHKiRet(tcpsrv.SetInputName(pOurTcpsrv, cnf_params, pszInputName == NULL ?
						UCHAR_CONSTANT("imdiag") : pszInputName));
	CHKiRet(tcpsrv.SetOrigin(pOurTcpsrv, (uchar*)"imdiag"));
	cnf_params-&gt;pszPort = pNewVal;
	cnf_params-&gt;bSuppOctetFram = 1;
	CHKmalloc(cnf_params-&gt;pszLstnPortFileName = (const uchar*) strdup((const char*)pszLstnPortFileName));
	tcpsrv.configureTCPListen(pOurTcpsrv, cnf_params);
	cnf_params = NULL;
finalize_it:
	if(iRet != RS_RET_OK) {
		LogError(0, NO_ERRCODE, "error %d trying to add listener", iRet);
		if(pOurTcpsrv != NULL)
			tcpsrv.Destruct(&amp;pOurTcpsrv);
	}
	free(cnf_params);
	RETiRet;
}
static void *
timeoutGuard(ATTR_UNUSED void *arg)
{
	assert(abortTimeout != -1);
	sigset_t sigSet;
	time_t strtTO;
	time_t endTO;
	sigfillset(&amp;sigSet);
	sigdelset(&amp;sigSet, SIGSEGV);
	pthread_sigmask(SIG_BLOCK, &amp;sigSet, NULL);
	dbgprintf("timeoutGuard: timeout %d seconds, time %lld\n", abortTimeout, (long long) time(NULL));
	time(&amp;strtTO);
	endTO = strtTO + abortTimeout;
	while(1) {
		int to = endTO - time(NULL);
		dbgprintf("timeoutGuard: sleep timeout %d seconds\n", to);
		if(to &gt; 0) {
			srSleep(to, 0);
		}
		if(time(NULL) &lt; endTO) {
			dbgprintf("timeoutGuard: spurios wakeup, going back to sleep, time: %lld\n",
				(long long) time(NULL));
		} else {
			break;
		}
	}
	dbgprintf("timeoutGuard: sleep expired, aborting\n");
	fprintf(stderr, "timeoutGuard: rsyslog still active after expiry of guard "
		"period (strtTO %lld, endTO %lld, time now %lld, diff %lld), pid %d - initiating abort()\n",
	(long long) strtTO, (long long) endTO, (long long) time(NULL), (long long) (time(NULL) - strtTO),
	(int) glblGetOurPid());
	fflush(stderr);
	abort();
}
static rsRetVal
setAbortTimeout(void __attribute__((unused)) *pVal, int timeout)
{
	DEFiRet;
	if(abortTimeout != -1) {
		LogError(0, NO_ERRCODE, "imdiag: abort timeout already set -"
			"ignoring 2nd+ request");
		ABORT_FINALIZE(RS_RET_ERR);
	}
	if(timeout &lt;= 0) {
		LogError(0, NO_ERRCODE, "imdiag: $IMDiagAbortTimeout must be greater "
			"than 0 - ignored");
		ABORT_FINALIZE(RS_RET_ERR);
	}
	abortTimeout = timeout;
	const int iState = pthread_create(&amp;timeoutGuard_thrd, NULL, timeoutGuard, NULL);
	if(iState != 0) {
		LogError(iState, NO_ERRCODE, "imdiag: error enabling timeoutGuard thread -"
			"not guarding against system hang");
		ABORT_FINALIZE(RS_RET_ERR);
	}
finalize_it:
	RETiRet;
}
#if 0 BEGINbeginCnfLoad
CODESTARTbeginCnfLoad
ENDbeginCnfLoad
BEGINendCnfLoad
CODESTARTendCnfLoad
ENDendCnfLoad
BEGINcheckCnf
CODESTARTcheckCnf
ENDcheckCnf
BEGINactivateCnf
CODESTARTactivateCnf
ENDactivateCnf
BEGINfreeCnf
CODESTARTfreeCnf
ENDfreeCnf
#endif
BEGINrunInput
CODESTARTrunInput
	CHKiRet(tcpsrv.ConstructFinalize(pOurTcpsrv));
	iRet = tcpsrv.Run(pOurTcpsrv);
finalize_it:
ENDrunInput
BEGINwillRun
CODESTARTwillRun
	if(pOurTcpsrv == NULL)
		ABORT_FINALIZE(RS_RET_NO_RUN);
	CHKiRet(prop.Construct(&amp;pInputName));
	CHKiRet(prop.SetString(pInputName, UCHAR_CONSTANT("imdiag"), sizeof("imdiag") - 1));
	CHKiRet(prop.ConstructFinalize(pInputName));
	CHKiRet(prop.Construct(&amp;pRcvDummy));
	CHKiRet(prop.SetString(pRcvDummy, UCHAR_CONSTANT("127.0.0.1"), sizeof("127.0.0.1") - 1));
	CHKiRet(prop.ConstructFinalize(pRcvDummy));
	CHKiRet(prop.Construct(&amp;pRcvIPDummy));
	CHKiRet(prop.SetString(pRcvIPDummy, UCHAR_CONSTANT("127.0.0.1"), sizeof("127.0.0.1") - 1));
	CHKiRet(prop.ConstructFinalize(pRcvIPDummy));
finalize_it:
ENDwillRun
BEGINafterRun
CODESTARTafterRun
	if(pInputName != NULL)
		prop.Destruct(&amp;pInputName);
	if(pRcvDummy != NULL)
		prop.Destruct(&amp;pRcvDummy);
	if(pRcvIPDummy != NULL)
		prop.Destruct(&amp;pRcvIPDummy);
ENDafterRun
BEGINmodExit
CODESTARTmodExit
	if(pOurTcpsrv != NULL)
		iRet = tcpsrv.Destruct(&amp;pOurTcpsrv);
	if(pPermPeersRoot != NULL) {
		net.DestructPermittedPeers(&amp;pPermPeersRoot);
	}
	free(pszInputName);
	free(pszLstnPortFileName);
	free(pszStrmDrvrAuthMode);
	statsobj.Destruct(&amp;diagStats);
	sem_destroy(&amp;statsReportingBlocker);
	DESTROY_ATOMIC_HELPER_MUT(mutAllowOnlyOnce);
	pthread_cond_destroy(&amp;statsReporterWatch);
	pthread_mutex_destroy(&amp;mutStatsReporterWatch);
	objRelease(net, LM_NET_FILENAME);
	objRelease(netstrm, LM_NETSTRMS_FILENAME);
	objRelease(tcps_sess, LM_TCPSRV_FILENAME);
	objRelease(tcpsrv, LM_TCPSRV_FILENAME);
	objRelease(datetime, CORE_COMPONENT);
	objRelease(prop, CORE_COMPONENT);
	objRelease(statsobj, CORE_COMPONENT);
	if(abortTimeout != -1) {
		int r = pthread_cancel(timeoutGuard_thrd);
		if(r == 0) {
			void *dummy;
			pthread_join(timeoutGuard_thrd, &amp;dummy);
		}
	}
ENDmodExit
static rsRetVal
resetConfigVariables(uchar __attribute__((unused)) *pp, void __attribute__((unused)) *pVal)
{
	iTCPSessMax = 200;
	iStrmDrvrMode = 0;
	free(pszInputName);
	free(pszLstnPortFileName);
	pszLstnPortFileName = NULL;
	if(pszStrmDrvrAuthMode != NULL) {
		free(pszStrmDrvrAuthMode);
		pszStrmDrvrAuthMode = NULL;
	}
	return RS_RET_OK;
}
BEGINisCompatibleWithFeature
CODESTARTisCompatibleWithFeature
	if(eFeat == sFEATURENonCancelInputTermination)
		iRet = RS_RET_OK;
ENDisCompatibleWithFeature
BEGINqueryEtryPt
CODESTARTqueryEtryPt
CODEqueryEtryPt_STD_IMOD_QUERIES
CODEqueryEtryPt_IsCompatibleWithFeature_IF_OMOD_QUERIES
ENDqueryEtryPt
BEGINmodInit()
CODESTARTmodInit
	*ipIFVersProvided = CURR_MOD_IF_VERSION; CODEmodInit_QueryRegCFSLineHdlr
	pOurTcpsrv = NULL;
	CHKiRet(objUse(net, LM_NET_FILENAME));
	CHKiRet(objUse(netstrm, LM_NETSTRMS_FILENAME));
	CHKiRet(objUse(tcps_sess, LM_TCPSRV_FILENAME));
	CHKiRet(objUse(tcpsrv, LM_TCPSRV_FILENAME));
	CHKiRet(objUse(datetime, CORE_COMPONENT));
	CHKiRet(objUse(prop, CORE_COMPONENT));
	CHKiRet(objUse(statsobj, CORE_COMPONENT));
	const char *ci_max_empty_checks = getenv("CI_SHUTDOWN_QUEUE_EMPTY_CHECKS");
	if(ci_max_empty_checks != NULL) {
		int n = atoi(ci_max_empty_checks);
		if(n &gt; 200) {
			LogError(0, RS_RET_PARAM_ERROR, "env var CI_SHUTDOWN_QUEUE_EMPTY_CHECKS has "
				"value over 200, which is the maximum - capped to 200");
			n = 200;
		}
		if(n &gt; 0) {
			max_empty_checks = n;
		} else {
			LogError(0, RS_RET_PARAM_ERROR, "env var CI_SHUTDOWN_QUEUE_EMPTY_CHECKS has "
				"value below 1, ignored; using default instead");
		}
		fprintf(stderr, "rsyslogd: info: imdiag does %d empty checks due to "
			"CI_SHUTDOWN_QUEUE_EMPTY_CHECKS\n", max_empty_checks);
	}
<a name="0"></a>
	CHKiRet(omsdRegCFSLineHdlr(UCHAR_CONSTANT("imdiagaborttimeout"), 0, eCmdHdlrInt,
<font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>				   setAbortTimeout, NULL, STD_LOADABLE_MODULE_ID));
	CHKiRet(omsdRegCFSLineHdlr(UCHAR_CONSTANT("imdiagserverrun"), 0, eCmdHdlrGetWord,
				   addTCPListener, NULL, STD_LOADABLE_MODULE_ID));
	CHKiRet(omsdRegCFSLineHdlr(UCHAR_CONSTANT("imdiaginjectdelaymode"), 0, eCmdHdlrGetWord,
				   setInjectDelayMode, NULL, STD_LOADABLE_MODULE_ID));
	CHKiRet(omsdRegCFSLineHdlr(UCHAR_CONSTANT("imdiagmaxsessions"), 0, eCmdHdlrInt,
				   NULL, &amp;iTCPSessMax, STD_LOADABLE_MODULE_ID));
	CHKiRet(omsdRegCFSLineHdlr(UCHAR_CONSTANT("imdiagserverstreamdrivermode"), 0,
				   eCmdHdlrInt, NULL, &amp;iStrmDrvrMode, STD_LOADABLE_MODULE_ID));
	CHKiRet(omsdRegCFSLineHdlr(UCHAR_CONSTANT("imdiaglistenportfilename"), 0,
				   eCmdHdlrGetWord, NULL, &amp;pszLstnPortFileName, STD_LOADABLE_MODULE_ID));
	CHKiRet(omsdRegCFSLineHdlr(UCHAR_CONSTANT("imdiagserverstreamdriverauthmode"), 0,
				   eCmdHdlrGetWord, NULL, &amp;pszStrmDrvrAuthMode, STD_LOADABLE_MODULE_ID));
	CHKiRet(omsdRegCFSLineHdlr(UCHAR_CONSTANT("imdiagserverstreamdriverpermittedpeer"), 0,
				   eCmdHdlrGetWord, setPermittedPeer, NULL, STD_LOADABLE_MODULE_ID));
	CHKiRet(omsdRegCFSLineHdlr(UCHAR_CONSTANT("imdiagserverinputname"), 0,
				   eCmdHdlrGetWord, NULL, &amp;pszInputName, STD_LOADABLE_MODULE_ID));
	CHKiRet(omsdRegCFSLineHdlr(UCHAR_CONSTANT("resetconfigvariables"), 1, eCmdHdlrCustomHandler,
							   resetConfigVariables, NULL, STD_LOADABLE_MODULE_ID));
	sem_init(&amp;statsReportingBlocker, 0, 1);
	INIT_ATOMIC_HELPER_MUT(mutAllowOnlyOnce);
	CHKiConcCtrl(pthread_mutex_init(&amp;mutStatsReporterWatch, NULL));
	CHKiConcCtrl(pthread_cond_init(&amp;statsReporterWatch, NULL));
	CHKiRet(statsobj.Construct(&amp;diagStats));
	CHKiRet(statsobj.SetName(diagStats, UCHAR_CONSTANT("imdiag-stats-reporting-controller")));
	CHKiRet(statsobj.SetOrigin(diagStats, UCHAR_CONSTANT("imdiag")));
	statsobj.SetStatsObjFlags(diagStats, STATSOBJ_FLAG_DO_PREPEND);
	STATSCOUNTER_INIT(potentialArtificialDelayMs, mutPotentialArtificialDelayMs);
	CHKiRet(statsobj.AddCounter(diagStats, UCHAR_CONSTANT("potentialTotalArtificialDelayInMs"),
						ctrType_IntCtr, CTR_FLAG_NONE, &amp;potentialArtificialDelayMs));
	STATSCOUNTER_INIT(actualArtificialDelayMs, mutActualArtificialDelayMs);
	CHKiRet(statsobj.AddCounter(diagStats, UCHAR_CONSTANT("actualTotalArtificialDelayInMs"),
							ctrType_IntCtr, CTR_FLAG_NONE, &amp;actualArtificialDelayMs));
	STATSCOUNTER_INIT(delayInvocationCount, mutDelayInvocationCount);
	CHKiRet(statsobj.AddCounter(diagStats, UCHAR_CONSTANT("delayInvocationCount"),
			ctrType_IntCtr, CTR_FLAG_NONE, &amp;delayInvocationCount));
	CHKiRet(statsobj.SetReadNotifier(diagStats, imdiag_statsReadCallback, NULL));</b></font>
	CHKiRet(statsobj.ConstructFinalize(diagStats));
ENDmodInit
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>omfwd.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
#include "config.h"
#include &lt;stdio.h&gt;
#include &lt;stdarg.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;time.h&gt;
#include &lt;netinet/in.h&gt;
#include &lt;netdb.h&gt;
#include &lt;fnmatch.h&gt;
#include &lt;assert.h&gt;
#include &lt;errno.h&gt;
#include &lt;ctype.h&gt;
#include &lt;unistd.h&gt;
#include &lt;stdint.h&gt;
#include &lt;fcntl.h&gt;
#include &lt;zlib.h&gt;
#include &lt;pthread.h&gt;
#include "rsyslog.h"
#include "syslogd.h"
#include "conf.h"
#include "syslogd-types.h"
#include "srUtils.h"
#include "net.h"
#include "netstrms.h"
#include "netstrm.h"
#include "omfwd.h"
#include "template.h"
#include "msg.h"
#include "tcpclt.h"
#include "cfsysline.h"
#include "module-template.h"
#include "glbl.h"
#include "errmsg.h"
#include "unicode-helper.h"
#include "parserif.h"
#include "ratelimit.h"
#include "statsobj.h"
MODULE_TYPE_OUTPUT
MODULE_TYPE_NOKEEP
MODULE_CNFNAME("omfwd")
DEF_OMOD_STATIC_DATA
DEFobjCurrIf(glbl)
DEFobjCurrIf(net)
DEFobjCurrIf(netstrms)
DEFobjCurrIf(netstrm)
DEFobjCurrIf(tcpclt)
DEFobjCurrIf(statsobj)
#define IS_FLUSH 1
#define NO_FLUSH 0
typedef struct _instanceData {
	uchar 	*tplName;		uchar *pszStrmDrvr;
	uchar *pszStrmDrvrAuthMode;
	uchar *pszStrmDrvrPermitExpiredCerts;
	permittedPeers_t *pPermPeers;
	int iStrmDrvrMode;
	const uchar *pszStrmDrvrCAFile;
	const uchar *pszStrmDrvrKeyFile;
	const uchar *pszStrmDrvrCertFile;
	char	*target;
	char	*address;
	char	*device;
	int compressionLevel;		char *port;
	int protocol;
	char *networkNamespace;
	int originalNamespace;
	int iRebindInterval;		sbool bKeepAlive;
	int iKeepAliveIntvl;
	int iKeepAliveProbes;
	int iKeepAliveTime;
	int iConErrSkip;    	uchar *gnutlsPriorityString;
	int ipfreebind;
#	define	FORW_UDP 0
#	define	FORW_TCP 1
	int bSendToAll;
	int iUDPSendDelay;
	int UDPSendBuf;
	TCPFRAMINGMODE tcp_framing;
	uchar tcp_framingDelimiter;
	int bResendLastOnRecon; #	define COMPRESS_NEVER 0
#	define COMPRESS_SINGLE_MSG 1	#	define COMPRESS_STREAM_ALWAYS 2
	uint8_t compressionMode;
	int errsToReport;		sbool strmCompFlushOnTxEnd; 	unsigned int ratelimitInterval;
	unsigned int ratelimitBurst;
	ratelimit_t *ratelimiter;
	statsobj_t *stats;			intctr_t sentBytes;
	DEF_ATOMIC_HELPER_MUT64(mut_sentBytes)
} instanceData;
typedef struct wrkrInstanceData {
	instanceData *pData;
	netstrms_t *pNS; 	netstrm_t *pNetstrm; 	struct addrinfo *f_addr;
	int *pSockArray;		int bIsConnected;  	int nXmit;			tcpclt_t *pTCPClt;		sbool bzInitDone; 	z_stream zstrm;		uchar sndBuf[16*1024];		unsigned offsSndBuf;		int errsToReport;	} wrkrInstanceData_t;
typedef struct configSettings_s {
	uchar *pszTplName; 	uchar *pszStrmDrvr; 	int iStrmDrvrMode; 	int bResendLastOnRecon; 	uchar *pszStrmDrvrAuthMode;			uchar *pszStrmDrvrPermitExpiredCerts;		int iTCPRebindInterval;		int iUDPRebindInterval;		int bKeepAlive;
	int iKeepAliveIntvl;
	int iKeepAliveProbes;
	int iKeepAliveTime;
	int iConErrSkip;
	uchar *gnutlsPriorityString;
	permittedPeers_t *pPermPeers;
} configSettings_t;
static configSettings_t cs;
static struct cnfparamdescr modpdescr[] = {
	{ "template", eCmdHdlrGetWord, 0 },
};
static struct cnfparamblk modpblk =
	{ CNFPARAMBLK_VERSION,
	  sizeof(modpdescr)/sizeof(struct cnfparamdescr),
	  modpdescr
	};
static struct cnfparamdescr actpdescr[] = {
	{ "target", eCmdHdlrGetWord, 0 },
	{ "address", eCmdHdlrGetWord, 0 },
	{ "device", eCmdHdlrGetWord, 0 },
	{ "port", eCmdHdlrGetWord, 0 },
	{ "protocol", eCmdHdlrGetWord, 0 },
	{ "networknamespace", eCmdHdlrGetWord, 0 },
	{ "tcp_framing", eCmdHdlrGetWord, 0 },
	{ "tcp_framedelimiter", eCmdHdlrInt, 0 },
	{ "ziplevel", eCmdHdlrInt, 0 },
	{ "compression.mode", eCmdHdlrGetWord, 0 },
	{ "compression.stream.flushontxend", eCmdHdlrBinary, 0 },
	{ "ipfreebind", eCmdHdlrInt, 0 },
	{ "maxerrormessages", eCmdHdlrInt, CNFPARAM_DEPRECATED },
	{ "rebindinterval", eCmdHdlrInt, 0 },
	{ "keepalive", eCmdHdlrBinary, 0 },
	{ "keepalive.probes", eCmdHdlrNonNegInt, 0 },
	{ "keepalive.time", eCmdHdlrNonNegInt, 0 },
	{ "keepalive.interval", eCmdHdlrNonNegInt, 0 },
	{ "conerrskip", eCmdHdlrNonNegInt, 0 },
	{ "gnutlsprioritystring", eCmdHdlrString, 0 },
	{ "streamdriver", eCmdHdlrGetWord, 0 },
	{ "streamdrivermode", eCmdHdlrInt, 0 },
	{ "streamdriverauthmode", eCmdHdlrGetWord, 0 },
	{ "streamdriverpermittedpeers", eCmdHdlrGetWord, 0 },
	{ "streamdriver.permitexpiredcerts", eCmdHdlrGetWord, 0 },
	{ "streamdriver.CheckExtendedKeyPurpose", eCmdHdlrBinary, 0 },
	{ "streamdriver.PrioritizeSAN", eCmdHdlrBinary, 0 },
	{ "streamdriver.TlsVerifyDepth", eCmdHdlrPositiveInt, 0 },
	{ "streamdriver.cafile", eCmdHdlrString, 0 },
	{ "streamdriver.keyfile", eCmdHdlrString, 0 },
	{ "streamdriver.certfile", eCmdHdlrString, 0 },
	{ "resendlastmsgonreconnect", eCmdHdlrBinary, 0 },
	{ "udp.sendtoall", eCmdHdlrBinary, 0 },
	{ "udp.senddelay", eCmdHdlrInt, 0 },
	{ "udp.sendbuf", eCmdHdlrSize, 0 },
	{ "template", eCmdHdlrGetWord, 0 },
	{ "ratelimit.interval", eCmdHdlrInt, 0 },
	{ "ratelimit.burst", eCmdHdlrInt, 0 }
};
static struct cnfparamblk actpblk =
	{ CNFPARAMBLK_VERSION,
	  sizeof(actpdescr)/sizeof(struct cnfparamdescr),
	  actpdescr
	};
struct modConfData_s {
	rsconf_t *pConf;		uchar 	*tplName;	};
static modConfData_t *loadModConf = NULL;static modConfData_t *runModConf = NULL;
static rsRetVal initTCP(wrkrInstanceData_t *pWrkrData);
BEGINinitConfVars		CODESTARTinitConfVars
	cs.pszTplName = NULL; 	cs.pszStrmDrvr = NULL; 	cs.iStrmDrvrMode = 0; 	cs.bResendLastOnRecon = 0; 	cs.pszStrmDrvrAuthMode = NULL; 	cs.iUDPRebindInterval = 0;		cs.iTCPRebindInterval = 0;		cs.pPermPeers = NULL;
ENDinitConfVars
static rsRetVal doTryResume(wrkrInstanceData_t *);
static rsRetVal doZipFinish(wrkrInstanceData_t *);
static uchar*
getDfltTpl(void)
{
	if(loadModConf != NULL &amp;&amp; loadModConf-&gt;tplName != NULL)
		return loadModConf-&gt;tplName;
	else if(cs.pszTplName == NULL)
		return (uchar*)"RSYSLOG_TraditionalForwardFormat";
	else
		return cs.pszTplName;
}
static rsRetVal
setLegacyDfltTpl(void __attribute__((unused)) *pVal, uchar* newVal)
{
	DEFiRet;
	if(loadModConf != NULL &amp;&amp; loadModConf-&gt;tplName != NULL) {
		free(newVal);
		LogError(0, RS_RET_ERR, "omfwd default template already set via module "
			"global parameter - can no longer be changed");
		ABORT_FINALIZE(RS_RET_ERR);
	}
	free(cs.pszTplName);
	cs.pszTplName = newVal;
finalize_it:
	RETiRet;
}
static rsRetVal
closeUDPSockets(wrkrInstanceData_t *pWrkrData)
{
	DEFiRet;
	if(pWrkrData-&gt;pSockArray != NULL) {
		net.closeUDPListenSockets(pWrkrData-&gt;pSockArray);
		pWrkrData-&gt;pSockArray = NULL;
		freeaddrinfo(pWrkrData-&gt;f_addr);
		pWrkrData-&gt;f_addr = NULL;
	}
pWrkrData-&gt;bIsConnected = 0; 	RETiRet;
}
static void
DestructTCPInstanceData(wrkrInstanceData_t *pWrkrData)
{
	doZipFinish(pWrkrData);
	if(pWrkrData-&gt;pNetstrm != NULL)
		netstrm.Destruct(&amp;pWrkrData-&gt;pNetstrm);
	if(pWrkrData-&gt;pNS != NULL)
		netstrms.Destruct(&amp;pWrkrData-&gt;pNS);
}
BEGINbeginCnfLoad
CODESTARTbeginCnfLoad
	loadModConf = pModConf;
	pModConf-&gt;pConf = pConf;
	pModConf-&gt;tplName = NULL;
ENDbeginCnfLoad
BEGINsetModCnf
	int i;
CODESTARTsetModCnf
	const struct cnfparamvals *const __restrict__ pvals = nvlstGetParams(lst, &amp;modpblk, NULL);
	if(pvals == NULL) {
		ABORT_FINALIZE(RS_RET_MISSING_CNFPARAMS);
	}
	if(Debug) {
		dbgprintf("module (global) param blk for omfwd:\n");
		cnfparamsPrint(&amp;modpblk, pvals);
	}
	for(i = 0 ; i &lt; modpblk.nParams ; ++i) {
		if(!pvals[i].bUsed)
			continue;
		if(!strcmp(modpblk.descr[i].name, "template")) {
			loadModConf-&gt;tplName = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
			if(cs.pszTplName != NULL) {
				LogError(0, RS_RET_DUP_PARAM, "omfwd: warning: default template "
						"was already set via legacy directive - may lead to inconsistent "
						"results.");
			}
		} else {
			dbgprintf("omfwd: program error, non-handled "
			  "param '%s' in beginCnfLoad\n", modpblk.descr[i].name);
		}
	}
finalize_it:
	if(pvals != NULL)
		cnfparamvalsDestruct(pvals, &amp;modpblk);
ENDsetModCnf
BEGINendCnfLoad
CODESTARTendCnfLoad
	loadModConf = NULL; 	free(cs.pszTplName);
	cs.pszTplName = NULL;
ENDendCnfLoad
BEGINcheckCnf
CODESTARTcheckCnf
ENDcheckCnf
BEGINactivateCnf
CODESTARTactivateCnf
	runModConf = pModConf;
ENDactivateCnf
BEGINfreeCnf
CODESTARTfreeCnf
	free(pModConf-&gt;tplName);
ENDfreeCnf
BEGINcreateInstance
CODESTARTcreateInstance
	if(cs.pszStrmDrvr != NULL)
		CHKmalloc(pData-&gt;pszStrmDrvr = (uchar*)strdup((char*)cs.pszStrmDrvr));
	if(cs.pszStrmDrvrAuthMode != NULL)
		CHKmalloc(pData-&gt;pszStrmDrvrAuthMode =
				     (uchar*)strdup((char*)cs.pszStrmDrvrAuthMode));
finalize_it:
ENDcreateInstance
BEGINcreateWrkrInstance
CODESTARTcreateWrkrInstance
	dbgprintf("DDDD: createWrkrInstance: pWrkrData %p\n", pWrkrData);
	pWrkrData-&gt;offsSndBuf = 0;
	iRet = initTCP(pWrkrData);
ENDcreateWrkrInstance
BEGINisCompatibleWithFeature
CODESTARTisCompatibleWithFeature
	if(eFeat == sFEATURERepeatedMsgReduction)
		iRet = RS_RET_OK;
ENDisCompatibleWithFeature
BEGINfreeInstance
CODESTARTfreeInstance
	if(pData-&gt;stats != NULL)
		statsobj.Destruct(&amp;(pData-&gt;stats));
	free(pData-&gt;pszStrmDrvr);
	free(pData-&gt;pszStrmDrvrAuthMode);
	free(pData-&gt;pszStrmDrvrPermitExpiredCerts);
	free(pData-&gt;gnutlsPriorityString);
	free(pData-&gt;port);
	free(pData-&gt;networkNamespace);
	free(pData-&gt;target);
	free(pData-&gt;address);
	free(pData-&gt;device);
	free((void*)pData-&gt;pszStrmDrvrCAFile);
	free((void*)pData-&gt;pszStrmDrvrKeyFile);
	free((void*)pData-&gt;pszStrmDrvrCertFile);
	net.DestructPermittedPeers(&amp;pData-&gt;pPermPeers);
	if (pData-&gt;ratelimiter != NULL){
		ratelimitDestruct(pData-&gt;ratelimiter);
		pData-&gt;ratelimiter = NULL;
	}
ENDfreeInstance
BEGINfreeWrkrInstance
CODESTARTfreeWrkrInstance
	DestructTCPInstanceData(pWrkrData);
	closeUDPSockets(pWrkrData);
	if(pWrkrData-&gt;pData-&gt;protocol == FORW_TCP) {
		tcpclt.Destruct(&amp;pWrkrData-&gt;pTCPClt);
	}
ENDfreeWrkrInstance
BEGINdbgPrintInstInfo
CODESTARTdbgPrintInstInfo
	dbgprintf("omfwd\n");
	dbgprintf("\ttarget='%s'\n", pData-&gt;target);
	dbgprintf("\tratelimit.interval='%u'\n", pData-&gt;ratelimitInterval);
	dbgprintf("\tratelimit.burst='%u'\n", pData-&gt;ratelimitBurst);
ENDdbgPrintInstInfo
#define UDP_MAX_MSGSIZE 65507 static rsRetVal UDPSend(wrkrInstanceData_t *__restrict__ const pWrkrData,
	uchar *__restrict__ const msg,
	size_t len)
{
	DEFiRet;
	struct addrinfo *r;
	int i;
	ssize_t lsent = 0;
	sbool bSendSuccess;
	sbool reInit = RSFALSE;
	int lasterrno = ENOENT;
	int lasterr_sock = -1;
	if(pWrkrData-&gt;pData-&gt;iRebindInterval &amp;&amp; (pWrkrData-&gt;nXmit++ % pWrkrData-&gt;pData-&gt;iRebindInterval == 0)) {
		dbgprintf("omfwd dropping UDP 'connection' (as configured)\n");
		pWrkrData-&gt;nXmit = 1;			CHKiRet(closeUDPSockets(pWrkrData));
	}
	if(pWrkrData-&gt;pSockArray == NULL) {
		CHKiRet(doTryResume(pWrkrData));
	}
	if(pWrkrData-&gt;pSockArray == NULL) {
		FINALIZE;
	}
	if(len &gt; UDP_MAX_MSGSIZE) {
		LogError(0, RS_RET_UDP_MSGSIZE_TOO_LARGE, "omfwd/udp: message is %u "
			"bytes long, but UDP can send at most %d bytes (by RFC limit) "
			"- truncating message", (unsigned) len, UDP_MAX_MSGSIZE);
		len = UDP_MAX_MSGSIZE;
	}
	bSendSuccess = RSFALSE;
	for (r = pWrkrData-&gt;f_addr; r; r = r-&gt;ai_next) {
		int runSockArrayLoop = 1;
		for (i = 0; runSockArrayLoop &amp;&amp; (i &lt; *pWrkrData-&gt;pSockArray) ; i++) {
			int try_send = 1;
			size_t lenThisTry = len;
			while(try_send) {
				lsent = sendto(pWrkrData-&gt;pSockArray[i+1], msg, lenThisTry, 0,
						r-&gt;ai_addr, r-&gt;ai_addrlen);
				if (lsent == (ssize_t) lenThisTry) {
					bSendSuccess = RSTRUE;
					ATOMIC_ADD_uint64(&amp;pWrkrData-&gt;pData-&gt;sentBytes,
						&amp;pWrkrData-&gt;pData-&gt;mut_sentBytes, lenThisTry);
					try_send = 0;
					runSockArrayLoop = 0;
				} else if(errno == EMSGSIZE) {
					const size_t newlen = (lenThisTry &gt; 1024) ? lenThisTry - 1024 : 512;
					LogError(0, RS_RET_UDP_MSGSIZE_TOO_LARGE,
						"omfwd/udp: send failed due to message being too "
						"large for this system. Message size was %u bytes. "
						"Truncating to %u bytes and retrying.",
						(unsigned) lenThisTry, (unsigned) newlen);
					lenThisTry = newlen;
				} else {
					reInit = RSTRUE;
					lasterrno = errno;
					lasterr_sock = pWrkrData-&gt;pSockArray[i+1];
					LogError(lasterrno, RS_RET_ERR_UDPSEND,
						"omfwd/udp: socket %d: sendto() error",
						lasterr_sock);
					try_send = 0;
				}
			}
		}
		if (lsent == (ssize_t) len &amp;&amp; !pWrkrData-&gt;pData-&gt;bSendToAll)
		       break;
	}
	if (reInit == RSTRUE) {
		CHKiRet(closeUDPSockets(pWrkrData));
	}
	if(bSendSuccess == RSTRUE) {
		if(pWrkrData-&gt;pData-&gt;iUDPSendDelay &gt; 0) {
			srSleep(pWrkrData-&gt;pData-&gt;iUDPSendDelay / 1000000,
				pWrkrData-&gt;pData-&gt;iUDPSendDelay % 1000000);
		}
	} else {
		LogError(lasterrno, RS_RET_ERR_UDPSEND,
			"omfwd: socket %d: error %d sending via udp", lasterr_sock, lasterrno);
		iRet = RS_RET_SUSPENDED;
	}
finalize_it:
	RETiRet;
}
static rsRetVal
setPermittedPeer(void __attribute__((unused)) *pVal, uchar *pszID)
{
	DEFiRet;
	CHKiRet(net.AddPermittedPeer(&amp;cs.pPermPeers, pszID));
	free(pszID); finalize_it:
	RETiRet;
}
static rsRetVal
TCPSendBufUncompressed(wrkrInstanceData_t *pWrkrData, uchar *const buf, const unsigned len)
{
	DEFiRet;
	unsigned alreadySent;
	ssize_t lenSend;
	alreadySent = 0;
	CHKiRet(netstrm.CheckConnection(pWrkrData-&gt;pNetstrm));
	while(alreadySent != len) {
		lenSend = len - alreadySent;
		CHKiRet(netstrm.Send(pWrkrData-&gt;pNetstrm, buf+alreadySent, &amp;lenSend));
		DBGPRINTF("omfwd: TCP sent %ld bytes, requested %u\n", (long) lenSend, len - alreadySent);
		alreadySent += lenSend;
	}
	ATOMIC_ADD_uint64(&amp;pWrkrData-&gt;pData-&gt;sentBytes, &amp;pWrkrData-&gt;pData-&gt;mut_sentBytes, len);
finalize_it:
	if(iRet != RS_RET_OK) {
		if(iRet == RS_RET_IO_ERROR) {
			static unsigned int conErrCnt = 0;
			const int skipFactor = pWrkrData-&gt;pData-&gt;iConErrSkip;
			if (skipFactor &lt;= 1)  {
				LogError(0, iRet, "omfwd: remote server at %s:%s seems to have closed connection. "
					"This often happens when the remote peer (or an interim system like a load "
					"balancer or firewall) shuts down or aborts a connection. Rsyslog will "
					"re-open the connection if configured to do so (we saw a generic IO Error, "
					"which usually goes along with that behaviour).",
					pWrkrData-&gt;pData-&gt;target, pWrkrData-&gt;pData-&gt;port);
			} else if ((conErrCnt++ % skipFactor) == 0) {
				LogError(0, iRet, "omfwd: remote server at %s:%s seems to have closed connection. "
					"This often happens when the remote peer (or an interim system like a load "
					"balancer or firewall) shuts down or aborts a connection. Rsyslog will "
					"re-open the connection if configured to do so (we saw a generic IO Error, "
					"which usually goes along with that behaviour). Note that the next %d "
					"connection error messages will be skipped.",
					pWrkrData-&gt;pData-&gt;target, pWrkrData-&gt;pData-&gt;port, skipFactor-1);
			}
		} else {
			LogError(0, iRet, "omfwd: TCPSendBuf error %d, destruct TCP Connection to %s:%s",
				iRet, pWrkrData-&gt;pData-&gt;target, pWrkrData-&gt;pData-&gt;port);
		}
		DestructTCPInstanceData(pWrkrData);
		iRet = RS_RET_SUSPENDED;
	}
	RETiRet;
}
static rsRetVal
TCPSendBufCompressed(wrkrInstanceData_t *pWrkrData, uchar *buf, unsigned len, sbool bIsFlush)
{
	int zRet;		unsigned outavail;
	uchar zipBuf[32*1024];
	int op;
	DEFiRet;
	if(!pWrkrData-&gt;bzInitDone) {
		pWrkrData-&gt;zstrm.zalloc = Z_NULL;
		pWrkrData-&gt;zstrm.zfree = Z_NULL;
		pWrkrData-&gt;zstrm.opaque = Z_NULL;
		zRet = deflateInit(&amp;pWrkrData-&gt;zstrm, pWrkrData-&gt;pData-&gt;compressionLevel);
		if(zRet != Z_OK) {
			DBGPRINTF("error %d returned from zlib/deflateInit()\n", zRet);
			ABORT_FINALIZE(RS_RET_ZLIB_ERR);
		}
		pWrkrData-&gt;bzInitDone = RSTRUE;
	}
	pWrkrData-&gt;zstrm.next_in = (Bytef*) buf;
	pWrkrData-&gt;zstrm.avail_in = len;
	if(pWrkrData-&gt;pData-&gt;strmCompFlushOnTxEnd &amp;&amp; bIsFlush)
		op = Z_SYNC_FLUSH;
	else
		op = Z_NO_FLUSH;
	do {
		DBGPRINTF("omfwd: in deflate() loop, avail_in %d, total_in %ld, isFlush %d\n",
			pWrkrData-&gt;zstrm.avail_in, pWrkrData-&gt;zstrm.total_in, bIsFlush);
		pWrkrData-&gt;zstrm.avail_out = sizeof(zipBuf);
		pWrkrData-&gt;zstrm.next_out = zipBuf;
		zRet = deflate(&amp;pWrkrData-&gt;zstrm, op);    		DBGPRINTF("after deflate, ret %d, avail_out %d\n", zRet, pWrkrData-&gt;zstrm.avail_out);
		outavail = sizeof(zipBuf) - pWrkrData-&gt;zstrm.avail_out;
		if(outavail != 0) {
			CHKiRet(TCPSendBufUncompressed(pWrkrData, zipBuf, outavail));
		}
	} while (pWrkrData-&gt;zstrm.avail_out == 0);
finalize_it:
	RETiRet;
}
static rsRetVal
TCPSendBuf(wrkrInstanceData_t *pWrkrData, uchar *buf, unsigned len, sbool bIsFlush)
{
	DEFiRet;
	if(pWrkrData-&gt;pData-&gt;compressionMode &gt;= COMPRESS_STREAM_ALWAYS)
		iRet = TCPSendBufCompressed(pWrkrData, buf, len, bIsFlush);
	else
		iRet = TCPSendBufUncompressed(pWrkrData, buf, len);
	RETiRet;
}
static rsRetVal
doZipFinish(wrkrInstanceData_t *pWrkrData)
{
	int zRet;		DEFiRet;
	unsigned outavail;
	uchar zipBuf[32*1024];
	if(!pWrkrData-&gt;bzInitDone)
		goto done;
	pWrkrData-&gt;zstrm.avail_in = 0;
	do {
		DBGPRINTF("in deflate() loop, avail_in %d, total_in %ld\n", pWrkrData-&gt;zstrm.avail_in,
			pWrkrData-&gt;zstrm.total_in);
		pWrkrData-&gt;zstrm.avail_out = sizeof(zipBuf);
		pWrkrData-&gt;zstrm.next_out = zipBuf;
		zRet = deflate(&amp;pWrkrData-&gt;zstrm, Z_FINISH);    		DBGPRINTF("after deflate, ret %d, avail_out %d\n", zRet, pWrkrData-&gt;zstrm.avail_out);
		outavail = sizeof(zipBuf) - pWrkrData-&gt;zstrm.avail_out;
		if(outavail != 0) {
			CHKiRet(TCPSendBufUncompressed(pWrkrData, zipBuf, outavail));
		}
	} while (pWrkrData-&gt;zstrm.avail_out == 0);
finalize_it:
	zRet = deflateEnd(&amp;pWrkrData-&gt;zstrm);
	if(zRet != Z_OK) {
		DBGPRINTF("error %d returned from zlib/deflateEnd()\n", zRet);
	}
	pWrkrData-&gt;bzInitDone = 0;
done:	RETiRet;
}
static rsRetVal TCPSendFrame(void *pvData, char *msg, size_t len)
{
	DEFiRet;
	wrkrInstanceData_t *pWrkrData = (wrkrInstanceData_t *) pvData;
	DBGPRINTF("omfwd: add %u bytes to send buffer (curr offs %u)\n",
		(unsigned) len, pWrkrData-&gt;offsSndBuf);
	if(pWrkrData-&gt;offsSndBuf != 0 &amp;&amp; pWrkrData-&gt;offsSndBuf + len &gt;= sizeof(pWrkrData-&gt;sndBuf)) {
		DBGPRINTF("omfwd: we need to do a tcp send due to buffer "
			  "out of space. If the transaction fails, this will "
			  "lead to duplication of messages");
		CHKiRet(TCPSendBuf(pWrkrData, pWrkrData-&gt;sndBuf, pWrkrData-&gt;offsSndBuf, NO_FLUSH));
		pWrkrData-&gt;offsSndBuf = 0;
	}
	if(len &gt; sizeof(pWrkrData-&gt;sndBuf)) {
		CHKiRet(TCPSendBuf(pWrkrData, (uchar*)msg, len, NO_FLUSH));
		ABORT_FINALIZE(RS_RET_OK);		}
	memcpy(pWrkrData-&gt;sndBuf + pWrkrData-&gt;offsSndBuf, msg, len);
	pWrkrData-&gt;offsSndBuf += len;
	iRet = RS_RET_DEFER_COMMIT;
finalize_it:
	RETiRet;
}
static rsRetVal TCPSendPrepRetry(void *pvData)
{
	DEFiRet;
	wrkrInstanceData_t *pWrkrData = (wrkrInstanceData_t *) pvData;
	assert(pWrkrData != NULL);
	DestructTCPInstanceData(pWrkrData);
	RETiRet;
}
static rsRetVal TCPSendInit(void *pvData)
{
	DEFiRet;
	wrkrInstanceData_t *pWrkrData = (wrkrInstanceData_t *) pvData;
	instanceData *pData;
	assert(pWrkrData != NULL);
	pData = pWrkrData-&gt;pData;
	if(pWrkrData-&gt;pNetstrm == NULL) {
		dbgprintf("TCPSendInit CREATE\n");
		CHKiRet(netstrms.Construct(&amp;pWrkrData-&gt;pNS));
		CHKiRet(netstrms.SetDrvrName(pWrkrData-&gt;pNS, pData-&gt;pszStrmDrvr));
		CHKiRet(netstrms.ConstructFinalize(pWrkrData-&gt;pNS));
		CHKiRet(netstrms.CreateStrm(pWrkrData-&gt;pNS, &amp;pWrkrData-&gt;pNetstrm));
		CHKiRet(netstrm.ConstructFinalize(pWrkrData-&gt;pNetstrm));
		CHKiRet(netstrm.SetDrvrMode(pWrkrData-&gt;pNetstrm, pData-&gt;iStrmDrvrMode));
		CHKiRet(netstrm.SetDrvrCheckExtendedKeyUsage(pWrkrData-&gt;pNetstrm, pData-&gt;iStrmDrvrExtendedCertCheck));
		CHKiRet(netstrm.SetDrvrPrioritizeSAN(pWrkrData-&gt;pNetstrm, pData-&gt;iStrmDrvrSANPreference));
		CHKiRet(netstrm.SetDrvrTlsVerifyDepth(pWrkrData-&gt;pNetstrm, pData-&gt;iStrmTlsVerifyDepth));
		if(pData-&gt;pszStrmDrvrAuthMode != NULL) {
			CHKiRet(netstrm.SetDrvrAuthMode(pWrkrData-&gt;pNetstrm, pData-&gt;pszStrmDrvrAuthMode));
		}
		CHKiRet(netstrm.SetDrvrPermitExpiredCerts(pWrkrData-&gt;pNetstrm,
			pData-&gt;pszStrmDrvrPermitExpiredCerts));
		CHKiRet(netstrm.SetDrvrTlsCAFile(pWrkrData-&gt;pNetstrm, pData-&gt;pszStrmDrvrCAFile));
		CHKiRet(netstrm.SetDrvrTlsKeyFile(pWrkrData-&gt;pNetstrm, pData-&gt;pszStrmDrvrKeyFile));
		CHKiRet(netstrm.SetDrvrTlsCertFile(pWrkrData-&gt;pNetstrm, pData-&gt;pszStrmDrvrCertFile));
		if(pData-&gt;pPermPeers != NULL) {
			CHKiRet(netstrm.SetDrvrPermPeers(pWrkrData-&gt;pNetstrm, pData-&gt;pPermPeers));
		}
		if(pData-&gt;gnutlsPriorityString != NULL) {
			CHKiRet(netstrm.SetGnutlsPriorityString(pWrkrData-&gt;pNetstrm, pData-&gt;gnutlsPriorityString));
		}
		CHKiRet(netstrm.Connect(pWrkrData-&gt;pNetstrm, glbl.GetDefPFFamily(runModConf-&gt;pConf),
			(uchar*)pData-&gt;port, (uchar*)pData-&gt;target, pData-&gt;device));
		if(pData-&gt;bKeepAlive) {
			CHKiRet(netstrm.SetKeepAliveProbes(pWrkrData-&gt;pNetstrm, pData-&gt;iKeepAliveProbes));
			CHKiRet(netstrm.SetKeepAliveIntvl(pWrkrData-&gt;pNetstrm, pData-&gt;iKeepAliveIntvl));
			CHKiRet(netstrm.SetKeepAliveTime(pWrkrData-&gt;pNetstrm, pData-&gt;iKeepAliveTime));
			CHKiRet(netstrm.EnableKeepAlive(pWrkrData-&gt;pNetstrm));
		}
	}
finalize_it:
	if(iRet != RS_RET_OK) {
		dbgprintf("TCPSendInit FAILED with %d.\n", iRet);
		DestructTCPInstanceData(pWrkrData);
	}
	RETiRet;
}
static rsRetVal changeToNs(instanceData *const pData __attribute__((unused)))
{
	DEFiRet;
#ifdef HAVE_SETNS
	int iErr;
	int destinationNs = -1;
	char *nsPath = NULL;
	if(pData-&gt;networkNamespace) {
		pData-&gt;originalNamespace = open("/proc/self/ns/net", O_RDONLY);
		if (pData-&gt;originalNamespace &lt; 0) {
			LogError(0, RS_RET_IO_ERROR, "omfwd: could not read /proc/self/ns/net");
			ABORT_FINALIZE(RS_RET_IO_ERROR);
		}
		if (asprintf(&amp;nsPath, "/var/run/netns/%s", pData-&gt;networkNamespace) == -1) {
			LogError(0, RS_RET_OUT_OF_MEMORY, "omfwd: asprintf failed");
			ABORT_FINALIZE(RS_RET_OUT_OF_MEMORY);
		}
		destinationNs = open(nsPath, 0);
		if (destinationNs &lt; 0) {
			LogError(0, RS_RET_IO_ERROR, "omfwd: could not change to namespace '%s'",
					pData-&gt;networkNamespace);
			ABORT_FINALIZE(RS_RET_IO_ERROR);
		}
		if((iErr = (setns(destinationNs, CLONE_NEWNET))) != 0) {
			LogError(0, RS_RET_IO_ERROR, "could not change to namespace '%s': %s",
				  pData-&gt;networkNamespace, gai_strerror(iErr));
			ABORT_FINALIZE(RS_RET_IO_ERROR);
		}
		dbgprintf("omfwd: changed to network namespace '%s'\n", pData-&gt;networkNamespace);
	}
finalize_it:
	free(nsPath);
	if(destinationNs &gt;= 0) {
		close(destinationNs);
	}
#else 		dbgprintf("omfwd: OS does not support network namespaces\n");
#endif 	RETiRet;
}
static rsRetVal returnToOriginalNs(instanceData *const pData __attribute__((unused)))
{
	DEFiRet;
#ifdef HAVE_SETNS
	int iErr;
	if(pData-&gt;networkNamespace &amp;&amp; pData-&gt;originalNamespace &gt;= 0) {
		if((iErr = (setns(pData-&gt;originalNamespace, CLONE_NEWNET))) != 0) {
			LogError(0, RS_RET_IO_ERROR, "could not return to original namespace: %s",
				  gai_strerror(iErr));
			ABORT_FINALIZE(RS_RET_IO_ERROR);
		}
		close(pData-&gt;originalNamespace);
		dbgprintf("omfwd: returned to original network namespace\n");
	}
finalize_it:
#endif 	RETiRet;
}
static rsRetVal doTryResume(wrkrInstanceData_t *pWrkrData)
{
	int iErr;
	struct addrinfo *res = NULL;
	struct addrinfo hints;
	instanceData *pData;
	int bBindRequired = 0;
	const char *address;
	DEFiRet;
	if(pWrkrData-&gt;bIsConnected)
		FINALIZE;
	pData = pWrkrData-&gt;pData;
	if(pData-&gt;protocol == FORW_UDP) {
		memset(&amp;hints, 0, sizeof(hints));
		hints.ai_flags = AI_NUMERICSERV;
		hints.ai_family = glbl.GetDefPFFamily(runModConf-&gt;pConf);
		hints.ai_socktype = SOCK_DGRAM;
		if((iErr = (getaddrinfo(pData-&gt;target, pData-&gt;port, &amp;hints, &amp;res))) != 0) {
			LogError(0, RS_RET_SUSPENDED,
				"omfwd: could not get addrinfo for hostname '%s':'%s': %s",
				pData-&gt;target, pData-&gt;port, gai_strerror(iErr));
			ABORT_FINALIZE(RS_RET_SUSPENDED);
		}
		address = pData-&gt;target;
		if(pData-&gt;address) {
			struct addrinfo *addr;
			hints.ai_family = res-&gt;ai_family;
			hints.ai_flags |= AI_PASSIVE;
			iErr = getaddrinfo(pData-&gt;address, pData-&gt;port, &amp;hints, &amp;addr);
			freeaddrinfo(addr);
			if(iErr != 0) {
				LogError(0, RS_RET_SUSPENDED,
					 "omfwd: cannot use bind address '%s' for host '%s': %s",
					 pData-&gt;address, pData-&gt;target, gai_strerror(iErr));
				ABORT_FINALIZE(RS_RET_SUSPENDED);
			}
			bBindRequired = 1;
			address = pData-&gt;address;
		}
		DBGPRINTF("%s found, resuming.\n", pData-&gt;target);
		pWrkrData-&gt;f_addr = res;
		res = NULL;
		if(pWrkrData-&gt;pSockArray == NULL) {
			CHKiRet(changeToNs(pData));
			pWrkrData-&gt;pSockArray = net.create_udp_socket((uchar*)address,
				NULL, bBindRequired, 0, pData-&gt;UDPSendBuf, pData-&gt;ipfreebind, pData-&gt;device);
			CHKiRet(returnToOriginalNs(pData));
		}
		if(pWrkrData-&gt;pSockArray != NULL) {
			pWrkrData-&gt;bIsConnected = 1;
		}
	} else {
		CHKiRet(changeToNs(pData));
		CHKiRet(TCPSendInit((void*)pWrkrData));
		CHKiRet(returnToOriginalNs(pData));
	}
finalize_it:
	DBGPRINTF("omfwd: doTryResume %s iRet %d\n", pWrkrData-&gt;pData-&gt;target, iRet);
	if(res != NULL) {
		freeaddrinfo(res);
	}
	if(iRet != RS_RET_OK) {
		returnToOriginalNs(pData);
		if(pWrkrData-&gt;f_addr != NULL) {
			freeaddrinfo(pWrkrData-&gt;f_addr);
			pWrkrData-&gt;f_addr = NULL;
		}
		iRet = RS_RET_SUSPENDED;
	}
	RETiRet;
}
BEGINtryResume
CODESTARTtryResume
	dbgprintf("omfwd: tryResume: pWrkrData %p\n", pWrkrData);
	iRet = doTryResume(pWrkrData);
ENDtryResume
BEGINbeginTransaction
CODESTARTbeginTransaction
	dbgprintf("omfwd: beginTransaction\n");
	iRet = doTryResume(pWrkrData);
ENDbeginTransaction
static rsRetVal
processMsg(wrkrInstanceData_t *__restrict__ const pWrkrData,
	actWrkrIParams_t *__restrict__ const iparam)
{
	uchar *psz; 	register unsigned l;
	int iMaxLine;
	Bytef *out = NULL; 	instanceData *__restrict__ const pData = pWrkrData-&gt;pData;
	DEFiRet;
	iMaxLine = glbl.GetMaxLine(runModConf-&gt;pConf);
	psz = iparam-&gt;param;
	l = iparam-&gt;lenStr;
	if((int) l &gt; iMaxLine)
		l = iMaxLine;
	if(pData-&gt;compressionMode == COMPRESS_SINGLE_MSG &amp;&amp; (l &gt; CONF_MIN_SIZE_FOR_COMPRESS)) {
		uLongf destLen = iMaxLine + iMaxLine/100 +12; 		uLong srcLen = l;
		int ret;
		CHKmalloc(out = (Bytef*) malloc(destLen));
		out[0] = 'z';
		out[1] = '\0';
		ret = compress2((Bytef*) out+1, &amp;destLen, (Bytef*) psz,
				srcLen, pData-&gt;compressionLevel);
		dbgprintf("Compressing message, length was %d now %d, return state  %d.\n",
			l, (int) destLen, ret);
		if(ret != Z_OK) {
			dbgprintf("Compression failed, sending uncompressed message\n");
		} else if(destLen+1 &lt; l) {
			dbgprintf("there is gain in compression, so we do it\n");
			psz = out;
			l = destLen + 1; 		}
		++destLen;
	}
	if(pData-&gt;protocol == FORW_UDP) {
		CHKiRet(UDPSend(pWrkrData, psz, l));
	} else {
		iRet = tcpclt.Send(pWrkrData-&gt;pTCPClt, pWrkrData, (char *)psz, l);
		if(iRet != RS_RET_OK &amp;&amp; iRet != RS_RET_DEFER_COMMIT &amp;&amp; iRet != RS_RET_PREVIOUS_COMMITTED) {
			LogError(0, iRet, "omfwd: error forwarding via tcp to %s:%s, suspending action",
				pWrkrData-&gt;pData-&gt;target, pWrkrData-&gt;pData-&gt;port);
			DestructTCPInstanceData(pWrkrData);
			iRet = RS_RET_SUSPENDED;
		}
	}
finalize_it:
	free(out); 	RETiRet;
}
BEGINcommitTransaction
	unsigned i;
	char namebuf[264]; CODESTARTcommitTransaction
	CHKiRet(doTryResume(pWrkrData));
	DBGPRINTF(" %s:%s/%s\n", pWrkrData-&gt;pData-&gt;target, pWrkrData-&gt;pData-&gt;port,
		 pWrkrData-&gt;pData-&gt;protocol == FORW_UDP ? "udp" : "tcp");
	if(pWrkrData-&gt;pData-&gt;ratelimiter) {
		snprintf(namebuf, sizeof namebuf, "%s:[%s]:%s",
			pWrkrData-&gt;pData-&gt;protocol == FORW_UDP ? "udp" : "tcp",
			pWrkrData-&gt;pData-&gt;target,
			pWrkrData-&gt;pData-&gt;port);
	}
	for(i = 0 ; i &lt; nParams ; ++i) {
		if(pWrkrData-&gt;pData-&gt;ratelimiter) {
			iRet = ratelimitMsgCount(pWrkrData-&gt;pData-&gt;ratelimiter, 0, namebuf);
			if (iRet == RS_RET_DISCARDMSG) {
				iRet = RS_RET_OK;
				continue;
			} else if (iRet != RS_RET_OK) {
				LogError(0, RS_RET_ERR, "omfwd: error during rate limit : %d.\n",iRet);
			}
		}
		iRet = processMsg(pWrkrData, &amp;actParam(pParams, 1, i, 0));
		if(iRet != RS_RET_OK &amp;&amp; iRet != RS_RET_DEFER_COMMIT &amp;&amp; iRet != RS_RET_PREVIOUS_COMMITTED)
			FINALIZE;
	}
	if(pWrkrData-&gt;offsSndBuf != 0) {
		iRet = TCPSendBuf(pWrkrData, pWrkrData-&gt;sndBuf, pWrkrData-&gt;offsSndBuf, IS_FLUSH);
		pWrkrData-&gt;offsSndBuf = 0;
	}
finalize_it:
ENDcommitTransaction
static rsRetVal
loadTCPSupport(void)
{
	DEFiRet;
	CHKiRet(objUse(netstrms, LM_NETSTRMS_FILENAME));
	CHKiRet(objUse(netstrm, LM_NETSTRMS_FILENAME));
	CHKiRet(objUse(tcpclt, LM_TCPCLT_FILENAME));
finalize_it:
	RETiRet;
}
static rsRetVal
initTCP(wrkrInstanceData_t *pWrkrData)
{
	instanceData *pData;
	DEFiRet;
	pData = pWrkrData-&gt;pData;
	if(pData-&gt;protocol == FORW_TCP) {
		CHKiRet(tcpclt.Construct(&amp;pWrkrData-&gt;pTCPClt));
		CHKiRet(tcpclt.SetResendLastOnRecon(pWrkrData-&gt;pTCPClt, pData-&gt;bResendLastOnRecon));
		CHKiRet(tcpclt.SetSendInit(pWrkrData-&gt;pTCPClt, TCPSendInit));
		CHKiRet(tcpclt.SetSendFrame(pWrkrData-&gt;pTCPClt, TCPSendFrame));
		CHKiRet(tcpclt.SetSendPrepRetry(pWrkrData-&gt;pTCPClt, TCPSendPrepRetry));
		CHKiRet(tcpclt.SetFraming(pWrkrData-&gt;pTCPClt, pData-&gt;tcp_framing));
		CHKiRet(tcpclt.SetFramingDelimiter(pWrkrData-&gt;pTCPClt, pData-&gt;tcp_framingDelimiter));
		CHKiRet(tcpclt.SetRebindInterval(pWrkrData-&gt;pTCPClt, pData-&gt;iRebindInterval));
	}
finalize_it:
	RETiRet;
}
static void
setInstParamDefaults(instanceData *pData)
{
	pData-&gt;tplName = NULL;
	pData-&gt;protocol = FORW_UDP;
	pData-&gt;networkNamespace = NULL;
	pData-&gt;originalNamespace = -1;
	pData-&gt;tcp_framing = TCP_FRAMING_OCTET_STUFFING;
	pData-&gt;tcp_framingDelimiter = '\n';
	pData-&gt;pszStrmDrvr = NULL;
	pData-&gt;pszStrmDrvrAuthMode = NULL;
	pData-&gt;pszStrmDrvrPermitExpiredCerts = NULL;
	pData-&gt;iStrmDrvrMode = 0;
	pData-&gt;iStrmDrvrExtendedCertCheck = 0;
	pData-&gt;iStrmDrvrSANPreference = 0;
	pData-&gt;iStrmTlsVerifyDepth = 0;
	pData-&gt;pszStrmDrvrCAFile = NULL;
	pData-&gt;pszStrmDrvrKeyFile = NULL;
	pData-&gt;pszStrmDrvrCertFile = NULL;
	pData-&gt;iRebindInterval = 0;
	pData-&gt;bKeepAlive = 0;
	pData-&gt;iKeepAliveProbes = 0;
	pData-&gt;iKeepAliveIntvl = 0;
	pData-&gt;iKeepAliveTime = 0;
	pData-&gt;iConErrSkip = 0;
	pData-&gt;gnutlsPriorityString = NULL;
	pData-&gt;bResendLastOnRecon = 0;
	pData-&gt;bSendToAll = -1;  	pData-&gt;iUDPSendDelay = 0;
	pData-&gt;UDPSendBuf = 0;
	pData-&gt;pPermPeers = NULL;
	pData-&gt;compressionLevel = 9;
	pData-&gt;strmCompFlushOnTxEnd = 1;
	pData-&gt;compressionMode = COMPRESS_NEVER;
	pData-&gt;ipfreebind = IPFREEBIND_ENABLED_WITH_LOG;
	pData-&gt;ratelimiter = NULL;
	pData-&gt;ratelimitInterval = 0;
	pData-&gt;ratelimitBurst = 200;
}
static rsRetVal
setupInstStatsCtrs(instanceData *__restrict__ const pData)
{
	uchar ctrName[512];
	DEFiRet;
	snprintf((char*)ctrName, sizeof(ctrName), "%s-%s-%s",
		(pData-&gt;protocol == FORW_TCP) ? "TCP" : "UDP",
		pData-&gt;target, pData-&gt;port);
	ctrName[sizeof(ctrName)-1] = '\0'; 	CHKiRet(statsobj.Construct(&amp;(pData-&gt;stats)));
	CHKiRet(statsobj.SetName(pData-&gt;stats, ctrName));
	CHKiRet(statsobj.SetOrigin(pData-&gt;stats, (uchar*)"omfwd"));
	pData-&gt;sentBytes = 0;
	INIT_ATOMIC_HELPER_MUT64(pData-&gt;mut_sentBytes);
	CHKiRet(statsobj.AddCounter(pData-&gt;stats, UCHAR_CONSTANT("bytes.sent"),
		ctrType_IntCtr, CTR_FLAG_RESETTABLE, &amp;(pData-&gt;sentBytes)));
	CHKiRet(statsobj.ConstructFinalize(pData-&gt;stats));
finalize_it:
	RETiRet;
}
BEGINnewActInst
	struct cnfparamvals *pvals;
	uchar *tplToUse;
	char *cstr;
	int i;
	rsRetVal localRet;
	int complevel = -1;
CODESTARTnewActInst
	DBGPRINTF("newActInst (omfwd)\n");
	pvals = nvlstGetParams(lst, &amp;actpblk, NULL);
	if(pvals == NULL) {
		ABORT_FINALIZE(RS_RET_MISSING_CNFPARAMS);
	}
	if(Debug) {
		dbgprintf("action param blk in omfwd:\n");
		cnfparamsPrint(&amp;actpblk, pvals);
	}
	CHKiRet(createInstance(&amp;pData));
	setInstParamDefaults(pData);
	for(i = 0 ; i &lt; actpblk.nParams ; ++i) {
		if(!pvals[i].bUsed)
			continue;
		if(!strcmp(actpblk.descr[i].name, "target")) {
			pData-&gt;target = es_str2cstr(pvals[i].val.d.estr, NULL);
		} else if(!strcmp(actpblk.descr[i].name, "address")) {
			pData-&gt;address = es_str2cstr(pvals[i].val.d.estr, NULL);
		} else if(!strcmp(actpblk.descr[i].name, "device")) {
			pData-&gt;device = es_str2cstr(pvals[i].val.d.estr, NULL);
		} else if(!strcmp(actpblk.descr[i].name, "port")) {
			pData-&gt;port = es_str2cstr(pvals[i].val.d.estr, NULL);
		} else if(!strcmp(actpblk.descr[i].name, "protocol")) {
			if(!es_strcasebufcmp(pvals[i].val.d.estr, (uchar*)"udp", 3)) {
				pData-&gt;protocol = FORW_UDP;
			} else if(!es_strcasebufcmp(pvals[i].val.d.estr, (uchar*)"tcp", 3)) {
				localRet = loadTCPSupport();
				if(localRet != RS_RET_OK) {
					LogError(0, localRet, "could not activate network stream modules for TCP "
							"(internal error %d) - are modules missing?", localRet);
					ABORT_FINALIZE(localRet);
				}
				pData-&gt;protocol = FORW_TCP;
			} else {
				uchar *str;
				str = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
				LogError(0, RS_RET_INVLD_PROTOCOL,
						"omfwd: invalid protocol \"%s\"", str);
				free(str);
				ABORT_FINALIZE(RS_RET_INVLD_PROTOCOL);
			}
		} else if(!strcmp(actpblk.descr[i].name, "networknamespace")) {
			pData-&gt;networkNamespace = es_str2cstr(pvals[i].val.d.estr, NULL);
		} else if(!strcmp(actpblk.descr[i].name, "tcp_framing")) {
			if(!es_strcasebufcmp(pvals[i].val.d.estr, (uchar*)"traditional", 11)) {
				pData-&gt;tcp_framing = TCP_FRAMING_OCTET_STUFFING;
			} else if(!es_strcasebufcmp(pvals[i].val.d.estr, (uchar*)"octet-counted", 13)) {
				pData-&gt;tcp_framing = TCP_FRAMING_OCTET_COUNTING;
			} else {
				uchar *str;
				str = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
				LogError(0, RS_RET_CNF_INVLD_FRAMING,
						"omfwd: invalid framing \"%s\"", str);
				free(str);
				ABORT_FINALIZE(RS_RET_CNF_INVLD_FRAMING );
			}
		} else if(!strcmp(actpblk.descr[i].name, "rebindinterval")) {
			pData-&gt;iRebindInterval = (int) pvals[i].val.d.n;
		} else if(!strcmp(actpblk.descr[i].name, "keepalive")) {
			pData-&gt;bKeepAlive = (int) pvals[i].val.d.n;
		} else if(!strcmp(actpblk.descr[i].name, "keepalive.probes")) {
			pData-&gt;iKeepAliveProbes = (int) pvals[i].val.d.n;
		} else if(!strcmp(actpblk.descr[i].name, "keepalive.interval")) {
			pData-&gt;iKeepAliveIntvl = (int) pvals[i].val.d.n;
		} else if(!strcmp(actpblk.descr[i].name, "keepalive.time")) {
			pData-&gt;iKeepAliveTime = (int) pvals[i].val.d.n;
		} else if(!strcmp(actpblk.descr[i].name, "conerrskip")) {
			pData-&gt;iConErrSkip = (int) pvals[i].val.d.n;
		} else if(!strcmp(actpblk.descr[i].name, "gnutlsprioritystring")) {
			pData-&gt;gnutlsPriorityString = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
		} else if(!strcmp(actpblk.descr[i].name, "streamdriver")) {
			pData-&gt;pszStrmDrvr = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
		} else if(!strcmp(actpblk.descr[i].name, "streamdrivermode")) {
			pData-&gt;iStrmDrvrMode = pvals[i].val.d.n;
		} else if(!strcmp(actpblk.descr[i].name, "streamdriver.CheckExtendedKeyPurpose")) {
			pData-&gt;iStrmDrvrExtendedCertCheck = pvals[i].val.d.n;
		} else if(!strcmp(actpblk.descr[i].name, "streamdriver.PrioritizeSAN")) {
			pData-&gt;iStrmDrvrSANPreference = pvals[i].val.d.n;
		} else if(!strcmp(actpblk.descr[i].name, "streamdriver.TlsVerifyDepth")) {
			if (pvals[i].val.d.n &gt;= 2) {
				pData-&gt;iStrmTlsVerifyDepth = pvals[i].val.d.n;
			} else {
				parser_errmsg("streamdriver.TlsVerifyDepth must be 2 or higher but is %d",
									(int) pvals[i].val.d.n);
			}
		} else if(!strcmp(actpblk.descr[i].name, "streamdriverauthmode")) {
			pData-&gt;pszStrmDrvrAuthMode = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
		} else if(!strcmp(actpblk.descr[i].name, "streamdriver.permitexpiredcerts")) {
			uchar *val = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
			if(   es_strcasebufcmp(pvals[i].val.d.estr, (uchar*)"off", 3)
			   &amp;&amp; es_strcasebufcmp(pvals[i].val.d.estr, (uchar*)"on", 2)
			   &amp;&amp; es_strcasebufcmp(pvals[i].val.d.estr, (uchar*)"warn", 4)
			  ) {
				parser_errmsg("streamdriver.permitExpiredCerts must be 'warn', 'off' or 'on' "
					"but is '%s' - ignoring parameter, using 'off' instead.", val);
				free(val);
			} else {
				pData-&gt;pszStrmDrvrPermitExpiredCerts = val;
			}
		} else if(!strcmp(actpblk.descr[i].name, "streamdriver.cafile")) {
			pData-&gt;pszStrmDrvrCAFile = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
		} else if(!strcmp(actpblk.descr[i].name, "streamdriver.keyfile")) {
			pData-&gt;pszStrmDrvrKeyFile = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
		} else if(!strcmp(actpblk.descr[i].name, "streamdriver.certfile")) {
			pData-&gt;pszStrmDrvrCertFile = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
		} else if(!strcmp(actpblk.descr[i].name, "streamdriverpermittedpeers")) {
			uchar *start, *str;
			uchar *p;
			int lenStr;
			str = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
			start = str;
			lenStr = ustrlen(start); 			while(lenStr &gt; 0) {
				p = start;
				while(*p &amp;&amp; *p != ',' &amp;&amp; lenStr--)
					p++;
				if(*p == ',') {
					*p = '\0';
				}
				if(*start == '\0') {
					DBGPRINTF("omfwd: ignoring empty permitted peer\n");
				} else {
					dbgprintf("omfwd: adding permitted peer: '%s'\n", start);
					CHKiRet(net.AddPermittedPeer(&amp;(pData-&gt;pPermPeers), start));
				}
				start = p+1;
				if(lenStr)
					--lenStr;
			}
			free(str);
		} else if(!strcmp(actpblk.descr[i].name, "ziplevel")) {
			complevel = pvals[i].val.d.n;
			if(complevel &gt;= 0 &amp;&amp; complevel &lt;= 10) {
				pData-&gt;compressionLevel = complevel;
				pData-&gt;compressionMode = COMPRESS_SINGLE_MSG;
			} else {
				LogError(0, NO_ERRCODE, "Invalid ziplevel %d specified in "
					 "forwarding action - NOT turning on compression.",
					 complevel);
			}
		} else if(!strcmp(actpblk.descr[i].name, "tcp_framedelimiter")) {
			if(pvals[i].val.d.n &gt; 255) {
				parser_errmsg("tcp_frameDelimiter must be below 255 but is %d",
					(int) pvals[i].val.d.n);
				ABORT_FINALIZE(RS_RET_PARAM_ERROR);
			}
			pData-&gt;tcp_framingDelimiter = (uchar) pvals[i].val.d.n;
		} else if(!strcmp(actpblk.descr[i].name, "resendlastmsgonreconnect")) {
			pData-&gt;bResendLastOnRecon = (int) pvals[i].val.d.n;
		} else if(!strcmp(actpblk.descr[i].name, "udp.sendtoall")) {
			pData-&gt;bSendToAll = (int) pvals[i].val.d.n;
		} else if(!strcmp(actpblk.descr[i].name, "udp.senddelay")) {
			pData-&gt;iUDPSendDelay = (int) pvals[i].val.d.n;
		} else if(!strcmp(actpblk.descr[i].name, "udp.sendbuf")) {
			pData-&gt;UDPSendBuf = (int) pvals[i].val.d.n;
		} else if(!strcmp(actpblk.descr[i].name, "template")) {
			pData-&gt;tplName = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
		} else if(!strcmp(actpblk.descr[i].name, "compression.stream.flushontxend")) {
			pData-&gt;strmCompFlushOnTxEnd = (sbool) pvals[i].val.d.n;
		} else if(!strcmp(actpblk.descr[i].name, "compression.mode")) {
			cstr = es_str2cstr(pvals[i].val.d.estr, NULL);
			if(!strcasecmp(cstr, "stream:always")) {
				pData-&gt;compressionMode = COMPRESS_STREAM_ALWAYS;
			} else if(!strcasecmp(cstr, "none")) {
				pData-&gt;compressionMode = COMPRESS_NEVER;
			} else if(!strcasecmp(cstr, "single")) {
				pData-&gt;compressionMode = COMPRESS_SINGLE_MSG;
			} else {
				LogError(0, RS_RET_PARAM_ERROR, "omfwd: invalid value for 'compression.mode' "
					 "parameter (given is '%s')", cstr);
				free(cstr);
				ABORT_FINALIZE(RS_RET_PARAM_ERROR);
			}
			free(cstr);
		} else if(!strcmp(actpblk.descr[i].name, "ipfreebind")) {
			pData-&gt;ipfreebind = (int) pvals[i].val.d.n;
		} else if(!strcmp(actpblk.descr[i].name, "ratelimit.burst")) {
			pData-&gt;ratelimitBurst = (unsigned int) pvals[i].val.d.n;
		} else if(!strcmp(actpblk.descr[i].name, "ratelimit.interval")) {
			pData-&gt;ratelimitInterval = (unsigned int) pvals[i].val.d.n;
		} else {
			LogError(0, RS_RET_INTERNAL_ERROR,
				"omfwd: program error, non-handled parameter '%s'",
				actpblk.descr[i].name);
		}
	}
	if(pData-&gt;port == NULL) {
		CHKmalloc(pData-&gt;port = strdup("514"));
	}
	if(complevel != -1) {
		pData-&gt;compressionLevel = complevel;
		if(pData-&gt;compressionMode == COMPRESS_NEVER) {
			pData-&gt;compressionMode = COMPRESS_SINGLE_MSG;
		}
	}
	CODE_STD_STRING_REQUESTnewActInst(1)
	tplToUse = ustrdup((pData-&gt;tplName == NULL) ? getDfltTpl() : pData-&gt;tplName);
	CHKiRet(OMSRsetEntry(*ppOMSR, 0, tplToUse, OMSR_NO_RQD_TPL_OPTS));
	if(pData-&gt;bSendToAll == -1) {
		pData-&gt;bSendToAll = send_to_all;
	} else {
		if(pData-&gt;protocol == FORW_TCP) {
			LogError(0, RS_RET_PARAM_ERROR, "omfwd: parameter udp.sendToAll "
					"cannot be used with tcp transport -- ignored");
		}
	}
	if(pData-&gt;address &amp;&amp; (pData-&gt;protocol == FORW_TCP)) {
		LogError(0, RS_RET_PARAM_ERROR,
			 "omfwd: parameter \"address\" not supported for tcp -- ignored");
	}
	if( pData-&gt;ratelimitInterval &gt; 0) {
		CHKiRet(ratelimitNew(&amp;pData-&gt;ratelimiter, "omfwd", NULL));
		ratelimitSetLinuxLike(pData-&gt;ratelimiter, pData-&gt;ratelimitInterval, pData-&gt;ratelimitBurst);
		ratelimitSetNoTimeCache(pData-&gt;ratelimiter);
	}
	setupInstStatsCtrs(pData);
CODE_STD_FINALIZERnewActInst
	cnfparamvalsDestruct(pvals, &amp;actpblk);
ENDnewActInst
BEGINparseSelectorAct
	uchar *q;
	int i;
	rsRetVal localRet;
	struct addrinfo;
	TCPFRAMINGMODE tcp_framing = TCP_FRAMING_OCTET_STUFFING;
CODESTARTparseSelectorAct
CODE_STD_STRING_REQUESTparseSelectorAct(1)
	if(*p != '@')
		ABORT_FINALIZE(RS_RET_CONFLINE_UNPROCESSED);
	CHKiRet(createInstance(&amp;pData));
	pData-&gt;tcp_framingDelimiter = '\n';
	++p; 	if(*p == '@') { 		localRet = loadTCPSupport();
		if(localRet != RS_RET_OK) {
			LogError(0, localRet, "could not activate network stream modules for TCP "
					"(internal error %d) - are modules missing?", localRet);
			ABORT_FINALIZE(localRet);
		}
		pData-&gt;protocol = FORW_TCP;
		++p; 	} else {
		pData-&gt;protocol = FORW_UDP;
	}
	if(*p == '(') {
		do {
			++p; 			if(*p == 'z') { 				++p; 				if(isdigit((int) *p)) {
					int iLevel;
					iLevel = *p - '0';
					++p; 					pData-&gt;compressionLevel = iLevel;
					pData-&gt;compressionMode = COMPRESS_SINGLE_MSG;
				} else {
					LogError(0, NO_ERRCODE, "Invalid compression level '%c' specified in "
						 "forwarding action - NOT turning on compression.",
						 *p);
				}
			} else if(*p == 'o') { 				++p; 				tcp_framing = TCP_FRAMING_OCTET_COUNTING;
			} else { 				LogError(0, NO_ERRCODE, "Invalid option %c in forwarding action - ignoring.", *p);
				++p; 			}
			while(*p &amp;&amp; *p != ')' &amp;&amp; *p != ',')
				++p;			} while(*p &amp;&amp; *p == ','); 		if(*p == ')')
			++p; 		else
			LogError(0, NO_ERRCODE, "Option block not terminated in forwarding action.");
	}
	if(*p == '[') { 		++p; 		for(q = p ; *p &amp;&amp; *p != ']' ; ++p)
		if(*p == ']') {
			*p = '\0'; 			++p; 		}
	} else { 		for(q = p ; *p &amp;&amp; *p != ';' &amp;&amp; *p != ':' &amp;&amp; *p != '#' ; ++p)
	}
	pData-&gt;tcp_framing = tcp_framing;
	pData-&gt;port = NULL;
	pData-&gt;networkNamespace = NULL;
	if(*p == ':') { 		uchar * tmp;
		*p = '\0'; 		tmp = ++p;
		for(i=0 ; *p &amp;&amp; isdigit((int) *p) ; ++p, ++i)
		pData-&gt;port = malloc(i + 1);
		if(pData-&gt;port == NULL) {
			LogError(0, NO_ERRCODE, "Could not get memory to store syslog forwarding port, "
				 "using default port, results may not be what you intend");
		} else {
			memcpy(pData-&gt;port, tmp, i);
			*(pData-&gt;port + i) = '\0';
		}
	}
	if(pData-&gt;port == NULL) {
		CHKmalloc(pData-&gt;port = strdup("514"));
	}
	while(*p &amp;&amp; *p != ';'  &amp;&amp; *p != '#' &amp;&amp; !isspace((int) *p))
	if(*p == ';' || *p == '#' || isspace(*p)) {
		uchar cTmp = *p;
		*p = '\0'; 		CHKmalloc(pData-&gt;target = strdup((char*) q));
		*p = cTmp;
	} else {
		CHKmalloc(pData-&gt;target = strdup((char*) q));
	}
	pData-&gt;iRebindInterval = (pData-&gt;protocol == FORW_TCP) ?
				 cs.iTCPRebindInterval : cs.iUDPRebindInterval;
	pData-&gt;bKeepAlive = cs.bKeepAlive;
	pData-&gt;iKeepAliveProbes = cs.iKeepAliveProbes;
	pData-&gt;iKeepAliveIntvl = cs.iKeepAliveIntvl;
	pData-&gt;iKeepAliveTime = cs.iKeepAliveTime;
	pData-&gt;iConErrSkip = cs.iConErrSkip;
	CHKiRet(cflineParseTemplateName(&amp;p, *ppOMSR, 0, OMSR_NO_RQD_TPL_OPTS, getDfltTpl()));
	if(pData-&gt;protocol == FORW_TCP) {
		pData-&gt;bResendLastOnRecon = cs.bResendLastOnRecon;
		pData-&gt;iStrmDrvrMode = cs.iStrmDrvrMode;
		if(cs.pPermPeers != NULL) {
			pData-&gt;pPermPeers = cs.pPermPeers;
			cs.pPermPeers = NULL;
		}
	}
CODE_STD_FINALIZERparseSelectorAct
ENDparseSelectorAct
static void
freeConfigVars(void)
{
	free(cs.pszStrmDrvr);
	cs.pszStrmDrvr = NULL;
	free(cs.pszStrmDrvrAuthMode);
	cs.pszStrmDrvrAuthMode = NULL;
	free(cs.pPermPeers);
	cs.pPermPeers = NULL; }
BEGINmodExit
CODESTARTmodExit
	objRelease(glbl, CORE_COMPONENT);
	objRelease(net, LM_NET_FILENAME);
	objRelease(netstrm, LM_NETSTRMS_FILENAME);
	objRelease(netstrms, LM_NETSTRMS_FILENAME);
	objRelease(tcpclt, LM_TCPCLT_FILENAME);
	objRelease(statsobj, CORE_COMPONENT);
	freeConfigVars();
ENDmodExit
BEGINqueryEtryPt
CODESTARTqueryEtryPt
CODEqueryEtryPt_STD_OMODTX_QUERIES
CODEqueryEtryPt_STD_OMOD8_QUERIES
CODEqueryEtryPt_STD_CONF2_QUERIES
CODEqueryEtryPt_STD_CONF2_setModCnf_QUERIES
CODEqueryEtryPt_STD_CONF2_OMOD_QUERIES
ENDqueryEtryPt
static rsRetVal resetConfigVariables(uchar __attribute__((unused)) *pp, void __attribute__((unused)) *pVal)
{
	freeConfigVars();
	cs.iStrmDrvrMode = 0;
	cs.bResendLastOnRecon = 0;
	cs.iUDPRebindInterval = 0;
	cs.iTCPRebindInterval = 0;
	cs.bKeepAlive = 0;
	cs.iKeepAliveProbes = 0;
	cs.iKeepAliveIntvl = 0;
	cs.iKeepAliveTime = 0;
	cs.iConErrSkip = 0;
	return RS_RET_OK;
}
BEGINmodInit(Fwd)
CODESTARTmodInit
INITLegCnfVars
	*ipIFVersProvided = CURR_MOD_IF_VERSION; CODEmodInit_QueryRegCFSLineHdlr
	CHKiRet(objUse(glbl, CORE_COMPONENT));
	CHKiRet(objUse(net,LM_NET_FILENAME));
<a name="0"></a>	CHKiRet(objUse(statsobj, CORE_COMPONENT));
	CHKiRet(regCfSysLineHdlr((uchar *)"actionforwarddefaulttemplate", 0, eCmdHdlrGetWord,
<font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>		setLegacyDfltTpl, NULL, NULL));
	CHKiRet(regCfSysLineHdlr((uchar *)"actionsendtcprebindinterval", 0, eCmdHdlrInt,
		NULL, &amp;cs.iTCPRebindInterval, NULL));
	CHKiRet(regCfSysLineHdlr((uchar *)"actionsendudprebindinterval", 0, eCmdHdlrInt,
		NULL, &amp;cs.iUDPRebindInterval, NULL));
	CHKiRet(regCfSysLineHdlr((uchar *)"actionsendtcpkeepalive", 0, eCmdHdlrBinary,
		NULL, &amp;cs.bKeepAlive, NULL));
	CHKiRet(regCfSysLineHdlr((uchar *)"actionsendtcpkeepalive_probes", 0, eCmdHdlrInt,
		NULL, &amp;cs.iKeepAliveProbes, NULL));
	CHKiRet(regCfSysLineHdlr((uchar *)"actionsendtcpkeepalive_intvl", 0, eCmdHdlrInt,
		NULL, &amp;cs.iKeepAliveIntvl, NULL));
	CHKiRet(regCfSysLineHdlr((uchar *)"actionsendtcpkeepalive_time", 0, eCmdHdlrInt,
		NULL, &amp;cs.iKeepAliveTime, NULL));</b></font>
	CHKiRet(regCfSysLineHdlr((uchar *)"actionsendstreamdriver", 0, eCmdHdlrGetWord,
		NULL, &amp;cs.pszStrmDrvr, NULL));
	CHKiRet(regCfSysLineHdlr((uchar *)"actionsendstreamdrivermode", 0, eCmdHdlrInt,
		NULL, &amp;cs.iStrmDrvrMode, NULL));
	CHKiRet(regCfSysLineHdlr((uchar *)"actionsendstreamdriverauthmode", 0, eCmdHdlrGetWord,
		NULL, &amp;cs.pszStrmDrvrAuthMode, NULL));
	CHKiRet(regCfSysLineHdlr((uchar *)"actionsendstreamdriverpermittedpeer", 0, eCmdHdlrGetWord,
		setPermittedPeer, NULL, NULL));
	CHKiRet(regCfSysLineHdlr((uchar *)"actionsendresendlastmsgonreconnect", 0, eCmdHdlrBinary,
		NULL, &amp;cs.bResendLastOnRecon, NULL));
	CHKiRet(omsdRegCFSLineHdlr((uchar *)"resetconfigvariables", 1, eCmdHdlrCustomHandler,
		resetConfigVariables, NULL, STD_LOADABLE_MODULE_ID));
ENDmodInit
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
