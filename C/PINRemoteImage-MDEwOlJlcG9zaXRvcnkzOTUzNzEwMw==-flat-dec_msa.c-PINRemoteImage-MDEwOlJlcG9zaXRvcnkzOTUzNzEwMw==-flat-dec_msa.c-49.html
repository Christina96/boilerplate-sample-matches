
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 25, <button onclick='openModal()' class='match'>CODE CLONE</button></h2>
        <div class="column">
            <h3>PINRemoteImage-MDEwOlJlcG9zaXRvcnkzOTUzNzEwMw==-flat-dec_msa.c</h3>
            <pre><code>1  #include &quot;src/dsp/dsp.h&quot;
2  #if defined(WEBP_USE_MSA)
3  #include &quot;src/dsp/msa_macro.h&quot;
4  #define IDCT_1D_W(in0, in1, in2, in3, out0, out1, out2, out3) {  \
5    v4i32 a1_m, b1_m, c1_m, d1_m;                                  \
6    v4i32 c_tmp1_m, c_tmp2_m, d_tmp1_m, d_tmp2_m;                  \
7    const v4i32 cospi8sqrt2minus1 = __msa_fill_w(20091);           \
8    const v4i32 sinpi8sqrt2 = __msa_fill_w(35468);                 \
9                                                                   \
10    a1_m = in0 + in2;                                              \
11    b1_m = in0 - in2;                                              \
12    c_tmp1_m = (in1 * sinpi8sqrt2) &gt;&gt; 16;                          \
13    c_tmp2_m = in3 + ((in3 * cospi8sqrt2minus1) &gt;&gt; 16);            \
14    c1_m = c_tmp1_m - c_tmp2_m;                                    \
15    d_tmp1_m = in1 + ((in1 * cospi8sqrt2minus1) &gt;&gt; 16);            \
16    d_tmp2_m = (in3 * sinpi8sqrt2) &gt;&gt; 16;                          \
17    d1_m = d_tmp1_m + d_tmp2_m;                                    \
18    BUTTERFLY_4(a1_m, b1_m, c1_m, d1_m, out0, out1, out2, out3);   \
19  }
20  #define MULT1(a) ((((a) * 20091) &gt;&gt; 16) + (a))
21  #define MULT2(a) (((a) * 35468) &gt;&gt; 16)
22  static void TransformOne(const int16_t* in, uint8_t* dst) {
23    v8i16 input0, input1;
24    v4i32 in0, in1, in2, in3, hz0, hz1, hz2, hz3, vt0, vt1, vt2, vt3;
25    v4i32 res0, res1, res2, res3;
26    const v16i8 zero = { 0 };
27    v16i8 dest0, dest1, dest2, dest3;
28    LD_SH2(in, 8, input0, input1);
29    UNPCK_SH_SW(input0, in0, in1);
30    UNPCK_SH_SW(input1, in2, in3);
31    IDCT_1D_W(in0, in1, in2, in3, hz0, hz1, hz2, hz3);
32    TRANSPOSE4x4_SW_SW(hz0, hz1, hz2, hz3, hz0, hz1, hz2, hz3);
33    IDCT_1D_W(hz0, hz1, hz2, hz3, vt0, vt1, vt2, vt3);
34    SRARI_W4_SW(vt0, vt1, vt2, vt3, 3);
35    TRANSPOSE4x4_SW_SW(vt0, vt1, vt2, vt3, vt0, vt1, vt2, vt3);
36    LD_SB4(dst, BPS, dest0, dest1, dest2, dest3);
37    ILVR_B4_SW(zero, dest0, zero, dest1, zero, dest2, zero, dest3,
38               res0, res1, res2, res3);
39    ILVR_H4_SW(zero, res0, zero, res1, zero, res2, zero, res3,
40               res0, res1, res2, res3);
41    ADD4(res0, vt0, res1, vt1, res2, vt2, res3, vt3, res0, res1, res2, res3);
42    CLIP_SW4_0_255(res0, res1, res2, res3);
43    PCKEV_B2_SW(res0, res1, res2, res3, vt0, vt1);
44    res0 = (v4i32)__msa_pckev_b((v16i8)vt0, (v16i8)vt1);
45    ST4x4_UB(res0, res0, 3, 2, 1, 0, dst, BPS);
46  }
47  static void TransformTwo(const int16_t* in, uint8_t* dst, int do_two) {
48    TransformOne(in, dst);
49    if (do_two) {
50      TransformOne(in + 16, dst + 4);
51    }
52  }
53  static void TransformWHT(const int16_t* in, int16_t* out) {
54    v8i16 input0, input1;
55    const v8i16 mask0 = { 0, 1, 2, 3, 8, 9, 10, 11 };
56    const v8i16 mask1 = { 4, 5, 6, 7, 12, 13, 14, 15 };
57    const v8i16 mask2 = { 0, 4, 8, 12, 1, 5, 9, 13 };
58    const v8i16 mask3 = { 3, 7, 11, 15, 2, 6, 10, 14 };
59    v8i16 tmp0, tmp1, tmp2, tmp3;
60    v8i16 out0, out1;
61    LD_SH2(in, 8, input0, input1);
62    input1 = SLDI_SH(input1, input1, 8);
63    tmp0 = input0 + input1;
64    tmp1 = input0 - input1;
65    VSHF_H2_SH(tmp0, tmp1, tmp0, tmp1, mask0, mask1, tmp2, tmp3);
66    out0 = tmp2 + tmp3;
67    out1 = tmp2 - tmp3;
68    VSHF_H2_SH(out0, out1, out0, out1, mask2, mask3, input0, input1);
69    tmp0 = input0 + input1;
70    tmp1 = input0 - input1;
71    VSHF_H2_SH(tmp0, tmp1, tmp0, tmp1, mask0, mask1, tmp2, tmp3);
72    tmp0 = tmp2 + tmp3;
73    tmp1 = tmp2 - tmp3;
74    ADDVI_H2_SH(tmp0, 3, tmp1, 3, out0, out1);
75    SRAI_H2_SH(out0, out1, 3);
76    out[0] = __msa_copy_s_h(out0, 0);
77    out[16] = __msa_copy_s_h(out0, 4);
78    out[32] = __msa_copy_s_h(out1, 0);
79    out[48] = __msa_copy_s_h(out1, 4);
80    out[64] = __msa_copy_s_h(out0, 1);
81    out[80] = __msa_copy_s_h(out0, 5);
82    out[96] = __msa_copy_s_h(out1, 1);
83    out[112] = __msa_copy_s_h(out1, 5);
84    out[128] = __msa_copy_s_h(out0, 2);
85    out[144] = __msa_copy_s_h(out0, 6);
86    out[160] = __msa_copy_s_h(out1, 2);
87    out[176] = __msa_copy_s_h(out1, 6);
88    out[192] = __msa_copy_s_h(out0, 3);
89    out[208] = __msa_copy_s_h(out0, 7);
90    out[224] = __msa_copy_s_h(out1, 3);
91    out[240] = __msa_copy_s_h(out1, 7);
92  }
93  static void TransformDC(const int16_t* in, uint8_t* dst) {
94    const int DC = (in[0] + 4) &gt;&gt; 3;
95    const v8i16 tmp0 = __msa_fill_h(DC);
96    ADDBLK_ST4x4_UB(tmp0, tmp0, tmp0, tmp0, dst, BPS);
97  }
98  static void TransformAC3(const int16_t* in, uint8_t* dst) {
99    const int a = in[0] + 4;
100    const int c4 = MULT2(in[4]);
101    const int d4 = MULT1(in[4]);
102    const int in2 = MULT2(in[1]);
103    const int in3 = MULT1(in[1]);
104    v4i32 tmp0 = { 0 };
105    v4i32 out0 = __msa_fill_w(a + d4);
106    v4i32 out1 = __msa_fill_w(a + c4);
107    v4i32 out2 = __msa_fill_w(a - c4);
108    v4i32 out3 = __msa_fill_w(a - d4);
109    v4i32 res0, res1, res2, res3;
110    const v4i32 zero = { 0 };
111    v16u8 dest0, dest1, dest2, dest3;
112    INSERT_W4_SW(in3, in2, -in2, -in3, tmp0);
113    ADD4(out0, tmp0, out1, tmp0, out2, tmp0, out3, tmp0,
114         out0, out1, out2, out3);
115    SRAI_W4_SW(out0, out1, out2, out3, 3);
116    LD_UB4(dst, BPS, dest0, dest1, dest2, dest3);
117    ILVR_B4_SW(zero, dest0, zero, dest1, zero, dest2, zero, dest3,
118               res0, res1, res2, res3);
119    ILVR_H4_SW(zero, res0, zero, res1, zero, res2, zero, res3,
120               res0, res1, res2, res3);
121    ADD4(res0, out0, res1, out1, res2, out2, res3, out3, res0, res1, res2, res3);
122    CLIP_SW4_0_255(res0, res1, res2, res3);
123    PCKEV_B2_SW(res0, res1, res2, res3, out0, out1);
124    res0 = (v4i32)__msa_pckev_b((v16i8)out0, (v16i8)out1);
125    ST4x4_UB(res0, res0, 3, 2, 1, 0, dst, BPS);
126  }
127  #define FLIP_SIGN2(in0, in1, out0, out1) {  \
128    out0 = (v16i8)__msa_xori_b(in0, 0x80);    \
129    out1 = (v16i8)__msa_xori_b(in1, 0x80);    \
130  }
131  #define FLIP_SIGN4(in0, in1, in2, in3, out0, out1, out2, out3) {  \
132    FLIP_SIGN2(in0, in1, out0, out1);                               \
133    FLIP_SIGN2(in2, in3, out2, out3);                               \
134  }
135  #define FILT_VAL(q0_m, p0_m, mask, filt) do {  \
136    v16i8 q0_sub_p0;                             \
137    q0_sub_p0 = __msa_subs_s_b(q0_m, p0_m);      \
138    filt = __msa_adds_s_b(filt, q0_sub_p0);      \
139    filt = __msa_adds_s_b(filt, q0_sub_p0);      \
140    filt = __msa_adds_s_b(filt, q0_sub_p0);      \
141    filt = filt &amp; mask;                          \
142  } while (0)
143  #define FILT2(q_m, p_m, q, p) do {            \
144    u_r = SRAI_H(temp1, 7);                     \
145    u_r = __msa_sat_s_h(u_r, 7);                \
146    u_l = SRAI_H(temp3, 7);                     \
147    u_l = __msa_sat_s_h(u_l, 7);                \
148    u = __msa_pckev_b((v16i8)u_l, (v16i8)u_r);  \
149    q_m = __msa_subs_s_b(q_m, u);               \
150    p_m = __msa_adds_s_b(p_m, u);               \
151    q = __msa_xori_b((v16u8)q_m, 0x80);         \
152    p = __msa_xori_b((v16u8)p_m, 0x80);         \
153  } while (0)
154  #define LPF_FILTER4_4W(p1, p0, q0, q1, mask, hev) do {  \
155    v16i8 p1_m, p0_m, q0_m, q1_m;                         \
156    v16i8 filt, t1, t2;                                   \
157    const v16i8 cnst4b = __msa_ldi_b(4);                  \
158    const v16i8 cnst3b = __msa_ldi_b(3);                  \
159                                                          \
160    FLIP_SIGN4(p1, p0, q0, q1, p1_m, p0_m, q0_m, q1_m);   \
161    filt = __msa_subs_s_b(p1_m, q1_m);                    \
162    filt = filt &amp; hev;                                    \
163    FILT_VAL(q0_m, p0_m, mask, filt);                     \
164    t1 = __msa_adds_s_b(filt, cnst4b);                    \
165    t1 = SRAI_B(t1, 3);                                   \
166    t2 = __msa_adds_s_b(filt, cnst3b);                    \
167    t2 = SRAI_B(t2, 3);                                   \
168    q0_m = __msa_subs_s_b(q0_m, t1);                      \
169    q0 = __msa_xori_b((v16u8)q0_m, 0x80);                 \
170    p0_m = __msa_adds_s_b(p0_m, t2);                      \
171    p0 = __msa_xori_b((v16u8)p0_m, 0x80);                 \
172    filt = __msa_srari_b(t1, 1);                          \
173    hev = __msa_xori_b(hev, 0xff);                        \
174    filt = filt &amp; hev;                                    \
175    q1_m = __msa_subs_s_b(q1_m, filt);                    \
176    q1 = __msa_xori_b((v16u8)q1_m, 0x80);                 \
177    p1_m = __msa_adds_s_b(p1_m, filt);                    \
178    p1 = __msa_xori_b((v16u8)p1_m, 0x80);                 \
179  } while (0)
180  #define LPF_MBFILTER(p2, p1, p0, q0, q1, q2, mask, hev) do {  \
181    v16i8 p2_m, p1_m, p0_m, q2_m, q1_m, q0_m;                   \
182    v16i8 u, filt, t1, t2, filt_sign;                           \
183    v8i16 filt_r, filt_l, u_r, u_l;                             \
184    v8i16 temp0, temp1, temp2, temp3;                           \
185    const v16i8 cnst4b = __msa_ldi_b(4);                        \
186    const v16i8 cnst3b = __msa_ldi_b(3);                        \
187    const v8i16 cnst9h = __msa_ldi_h(9);                        \
188    const v8i16 cnst63h = __msa_ldi_h(63);                      \
189                                                                \
190    FLIP_SIGN4(p1, p0, q0, q1, p1_m, p0_m, q0_m, q1_m);         \
191    filt = __msa_subs_s_b(p1_m, q1_m);                          \
192    FILT_VAL(q0_m, p0_m, mask, filt);                           \
193    FLIP_SIGN2(p2, q2, p2_m, q2_m);                             \
194    t2 = filt &amp; hev;                                            \
195                                          \
196    hev = __msa_xori_b(hev, 0xff);                              \
197    filt = filt &amp; hev;                                          \
198    t1 = __msa_adds_s_b(t2, cnst4b);                            \
199    t1 = SRAI_B(t1, 3);                                         \
200    t2 = __msa_adds_s_b(t2, cnst3b);                            \
201    t2 = SRAI_B(t2, 3);                                         \
202    q0_m = __msa_subs_s_b(q0_m, t1);                            \
203    p0_m = __msa_adds_s_b(p0_m, t2);                            \
204    filt_sign = __msa_clti_s_b(filt, 0);                        \
205    ILVRL_B2_SH(filt_sign, filt, filt_r, filt_l);               \
206                                              \
207    temp0 = filt_r * cnst9h;                                    \
208    temp1 = temp0 + cnst63h;                                    \
209    temp2 = filt_l * cnst9h;                                    \
210    temp3 = temp2 + cnst63h;                                    \
211    FILT2(q2_m, p2_m, q2, p2);                                  \
212                                              \
213    temp1 = temp1 + temp0;                                      \
214    temp3 = temp3 + temp2;                                      \
215    FILT2(q1_m, p1_m, q1, p1);                                  \
216                                              \
217    temp1 = temp1 + temp0;                                      \
218    temp3 = temp3 + temp2;                                      \
219    FILT2(q0_m, p0_m, q0, p0);                                  \
220  } while (0)
221  #define LPF_MASK_HEV(p3_in, p2_in, p1_in, p0_in,                 \
222                       q0_in, q1_in, q2_in, q3_in,                 \
223                       limit_in, b_limit_in, thresh_in,            \
224                       hev_out, mask_out) do {                     \
225    v16u8 p3_asub_p2_m, p2_asub_p1_m, p1_asub_p0_m, q1_asub_q0_m;  \
226    v16u8 p1_asub_q1_m, p0_asub_q0_m, q3_asub_q2_m, q2_asub_q1_m;  \
227    v16u8 flat_out;                                                \
228                                                                   \
229                         \
230    p3_asub_p2_m = __msa_asub_u_b(p3_in, p2_in);                   \
231    p2_asub_p1_m = __msa_asub_u_b(p2_in, p1_in);                   \
232    p1_asub_p0_m = __msa_asub_u_b(p1_in, p0_in);                   \
233    q1_asub_q0_m = __msa_asub_u_b(q1_in, q0_in);                   \
234    q2_asub_q1_m = __msa_asub_u_b(q2_in, q1_in);                   \
235    q3_asub_q2_m = __msa_asub_u_b(q3_in, q2_in);                   \
236    p0_asub_q0_m = __msa_asub_u_b(p0_in, q0_in);                   \
237    p1_asub_q1_m = __msa_asub_u_b(p1_in, q1_in);                   \
238                                           \
239    flat_out = __msa_max_u_b(p1_asub_p0_m, q1_asub_q0_m);          \
240    hev_out = (thresh_in &lt; flat_out);                              \
241                                          \
242    p0_asub_q0_m = __msa_adds_u_b(p0_asub_q0_m, p0_asub_q0_m);     \
243    p1_asub_q1_m = SRAI_B(p1_asub_q1_m, 1);                        \
244    p0_asub_q0_m = __msa_adds_u_b(p0_asub_q0_m, p1_asub_q1_m);     \
245    mask_out = (b_limit_in &lt; p0_asub_q0_m);                        \
246    mask_out = __msa_max_u_b(flat_out, mask_out);                  \
247    p3_asub_p2_m = __msa_max_u_b(p3_asub_p2_m, p2_asub_p1_m);      \
248    mask_out = __msa_max_u_b(p3_asub_p2_m, mask_out);              \
249    q2_asub_q1_m = __msa_max_u_b(q2_asub_q1_m, q3_asub_q2_m);      \
250    mask_out = __msa_max_u_b(q2_asub_q1_m, mask_out);              \
251    mask_out = (limit_in &lt; mask_out);                              \
252    mask_out = __msa_xori_b(mask_out, 0xff);                       \
253  } while (0)
254  #define ST6x1_UB(in0, in0_idx, in1, in1_idx, pdst, stride) do { \
255    const uint16_t tmp0_h = __msa_copy_s_h((v8i16)in1, in1_idx);  \
256    const uint32_t tmp0_w = __msa_copy_s_w((v4i32)in0, in0_idx);  \
257    SW(tmp0_w, pdst);                                             \
258    SH(tmp0_h, pdst + stride);                                    \
259  } while (0)
260  #define ST6x4_UB(in0, start_in0_idx, in1, start_in1_idx, pdst, stride) do { \
261    uint8_t* ptmp1 = (uint8_t*)pdst;                                          \
262    ST6x1_UB(in0, start_in0_idx, in1, start_in1_idx, ptmp1, 4);               \
263    ptmp1 += stride;                                                          \
264    ST6x1_UB(in0, start_in0_idx + 1, in1, start_in1_idx + 1, ptmp1, 4);       \
<span onclick='openModal()' class='match'>265    ptmp1 += stride;                                                          \
266    ST6x1_UB(in0, start_in0_idx + 2, in1, start_in1_idx + 2, ptmp1, 4);       \
267    ptmp1 += stride;                                                          \
</span>268    ST6x1_UB(in0, start_in0_idx + 3, in1, start_in1_idx + 3, ptmp1, 4);       \
269  } while (0)
270  #define LPF_SIMPLE_FILT(p1_in, p0_in, q0_in, q1_in, mask) do {       \
271      v16i8 p1_m, p0_m, q0_m, q1_m, filt, filt1, filt2;                \
272      const v16i8 cnst4b = __msa_ldi_b(4);                             \
273      const v16i8 cnst3b =  __msa_ldi_b(3);                            \
274                                                                       \
275      FLIP_SIGN4(p1_in, p0_in, q0_in, q1_in, p1_m, p0_m, q0_m, q1_m);  \
276      filt = __msa_subs_s_b(p1_m, q1_m);                               \
277      FILT_VAL(q0_m, p0_m, mask, filt);                                \
278      filt1 = __msa_adds_s_b(filt, cnst4b);                            \
279      filt1 = SRAI_B(filt1, 3);                                        \
280      filt2 = __msa_adds_s_b(filt, cnst3b);                            \
281      filt2 = SRAI_B(filt2, 3);                                        \
282      q0_m = __msa_subs_s_b(q0_m, filt1);                              \
283      p0_m = __msa_adds_s_b(p0_m, filt2);                              \
284      q0_in = __msa_xori_b((v16u8)q0_m, 0x80);                         \
285      p0_in = __msa_xori_b((v16u8)p0_m, 0x80);                         \
286  } while (0)
287  #define LPF_SIMPLE_MASK(p1, p0, q0, q1, b_limit, mask) do {    \
288      v16u8 p1_a_sub_q1, p0_a_sub_q0;                            \
289                                                                 \
290      p0_a_sub_q0 = __msa_asub_u_b(p0, q0);                      \
291      p1_a_sub_q1 = __msa_asub_u_b(p1, q1);                      \
292      p1_a_sub_q1 = (v16u8)__msa_srli_b((v16i8)p1_a_sub_q1, 1);  \
293      p0_a_sub_q0 = __msa_adds_u_b(p0_a_sub_q0, p0_a_sub_q0);    \
294      mask = __msa_adds_u_b(p0_a_sub_q0, p1_a_sub_q1);           \
295      mask = (mask &lt;= b_limit);                                  \
296  } while (0)
297  static void VFilter16(uint8_t* src, int stride,
298                        int b_limit_in, int limit_in, int thresh_in) {
299    uint8_t* ptemp = src - 4 * stride;
300    v16u8 p3, p2, p1, p0, q3, q2, q1, q0;
301    v16u8 mask, hev;
302    const v16u8 thresh = (v16u8)__msa_fill_b(thresh_in);
303    const v16u8 limit = (v16u8)__msa_fill_b(limit_in);
304    const v16u8 b_limit = (v16u8)__msa_fill_b(b_limit_in);
305    LD_UB8(ptemp, stride, p3, p2, p1, p0, q0, q1, q2, q3);
306    LPF_MASK_HEV(p3, p2, p1, p0, q0, q1, q2, q3, limit, b_limit, thresh,
307                 hev, mask);
308    LPF_MBFILTER(p2, p1, p0, q0, q1, q2, mask, hev);
309    ptemp = src - 3 * stride;
310    ST_UB4(p2, p1, p0, q0, ptemp, stride);
311    ptemp += (4 * stride);
312    ST_UB2(q1, q2, ptemp, stride);
313  }
314  static void HFilter16(uint8_t* src, int stride,
315                        int b_limit_in, int limit_in, int thresh_in) {
316    uint8_t* ptmp  = src - 4;
317    v16u8 p3, p2, p1, p0, q3, q2, q1, q0;
318    v16u8 mask, hev;
319    v16u8 row0, row1, row2, row3, row4, row5, row6, row7, row8;
320    v16u8 row9, row10, row11, row12, row13, row14, row15;
321    v8i16 tmp0, tmp1, tmp2, tmp3, tmp4, tmp5, tmp6, tmp7;
322    const v16u8 b_limit = (v16u8)__msa_fill_b(b_limit_in);
323    const v16u8 limit = (v16u8)__msa_fill_b(limit_in);
324    const v16u8 thresh = (v16u8)__msa_fill_b(thresh_in);
325    LD_UB8(ptmp, stride, row0, row1, row2, row3, row4, row5, row6, row7);
326    ptmp += (8 * stride);
327    LD_UB8(ptmp, stride, row8, row9, row10, row11, row12, row13, row14, row15);
328    TRANSPOSE16x8_UB_UB(row0, row1, row2, row3, row4, row5, row6, row7,
329                        row8, row9, row10, row11, row12, row13, row14, row15,
330                        p3, p2, p1, p0, q0, q1, q2, q3);
331    LPF_MASK_HEV(p3, p2, p1, p0, q0, q1, q2, q3, limit, b_limit, thresh,
332                 hev, mask);
333    LPF_MBFILTER(p2, p1, p0, q0, q1, q2, mask, hev);
334    ILVR_B2_SH(p1, p2, q0, p0, tmp0, tmp1);
335    ILVRL_H2_SH(tmp1, tmp0, tmp3, tmp4);
336    ILVL_B2_SH(p1, p2, q0, p0, tmp0, tmp1);
337    ILVRL_H2_SH(tmp1, tmp0, tmp6, tmp7);
338    ILVRL_B2_SH(q2, q1, tmp2, tmp5);
339    ptmp = src - 3;
340    ST6x1_UB(tmp3, 0, tmp2, 0, ptmp, 4);
341    ptmp += stride;
342    ST6x1_UB(tmp3, 1, tmp2, 1, ptmp, 4);
343    ptmp += stride;
344    ST6x1_UB(tmp3, 2, tmp2, 2, ptmp, 4);
345    ptmp += stride;
346    ST6x1_UB(tmp3, 3, tmp2, 3, ptmp, 4);
347    ptmp += stride;
348    ST6x1_UB(tmp4, 0, tmp2, 4, ptmp, 4);
349    ptmp += stride;
350    ST6x1_UB(tmp4, 1, tmp2, 5, ptmp, 4);
351    ptmp += stride;
352    ST6x1_UB(tmp4, 2, tmp2, 6, ptmp, 4);
353    ptmp += stride;
354    ST6x1_UB(tmp4, 3, tmp2, 7, ptmp, 4);
355    ptmp += stride;
356    ST6x1_UB(tmp6, 0, tmp5, 0, ptmp, 4);
357    ptmp += stride;
358    ST6x1_UB(tmp6, 1, tmp5, 1, ptmp, 4);
359    ptmp += stride;
360    ST6x1_UB(tmp6, 2, tmp5, 2, ptmp, 4);
361    ptmp += stride;
362    ST6x1_UB(tmp6, 3, tmp5, 3, ptmp, 4);
363    ptmp += stride;
364    ST6x1_UB(tmp7, 0, tmp5, 4, ptmp, 4);
365    ptmp += stride;
366    ST6x1_UB(tmp7, 1, tmp5, 5, ptmp, 4);
367    ptmp += stride;
368    ST6x1_UB(tmp7, 2, tmp5, 6, ptmp, 4);
369    ptmp += stride;
370    ST6x1_UB(tmp7, 3, tmp5, 7, ptmp, 4);
371  }
372  static void VFilterHorEdge16i(uint8_t* src, int stride,
373                                int b_limit, int limit, int thresh) {
374    v16u8 mask, hev;
375    v16u8 p3, p2, p1, p0, q3, q2, q1, q0;
376    const v16u8 thresh0 = (v16u8)__msa_fill_b(thresh);
377    const v16u8 b_limit0 = (v16u8)__msa_fill_b(b_limit);
378    const v16u8 limit0 = (v16u8)__msa_fill_b(limit);
379    LD_UB8((src - 4 * stride), stride, p3, p2, p1, p0, q0, q1, q2, q3);
380    LPF_MASK_HEV(p3, p2, p1, p0, q0, q1, q2, q3, limit0, b_limit0, thresh0,
381                 hev, mask);
382    LPF_FILTER4_4W(p1, p0, q0, q1, mask, hev);
383    ST_UB4(p1, p0, q0, q1, (src - 2 * stride), stride);
384  }
385  static void VFilter16i(uint8_t* src_y, int stride,
386                         int b_limit, int limit, int thresh) {
387    VFilterHorEdge16i(src_y +  4 * stride, stride, b_limit, limit, thresh);
388    VFilterHorEdge16i(src_y +  8 * stride, stride, b_limit, limit, thresh);
389    VFilterHorEdge16i(src_y + 12 * stride, stride, b_limit, limit, thresh);
390  }
391  static void HFilterVertEdge16i(uint8_t* src, int stride,
392                                 int b_limit, int limit, int thresh) {
393    v16u8 mask, hev;
394    v16u8 p3, p2, p1, p0, q3, q2, q1, q0;
395    v16u8 row0, row1, row2, row3, row4, row5, row6, row7;
396    v16u8 row8, row9, row10, row11, row12, row13, row14, row15;
397    v8i16 tmp0, tmp1, tmp2, tmp3, tmp4, tmp5;
398    const v16u8 thresh0 = (v16u8)__msa_fill_b(thresh);
399    const v16u8 b_limit0 = (v16u8)__msa_fill_b(b_limit);
400    const v16u8 limit0 = (v16u8)__msa_fill_b(limit);
401    LD_UB8(src - 4, stride, row0, row1, row2, row3, row4, row5, row6, row7);
402    LD_UB8(src - 4 + (8 * stride), stride,
403           row8, row9, row10, row11, row12, row13, row14, row15);
404    TRANSPOSE16x8_UB_UB(row0, row1, row2, row3, row4, row5, row6, row7,
405                        row8, row9, row10, row11, row12, row13, row14, row15,
406                        p3, p2, p1, p0, q0, q1, q2, q3);
407    LPF_MASK_HEV(p3, p2, p1, p0, q0, q1, q2, q3, limit0, b_limit0, thresh0,
408                 hev, mask);
409    LPF_FILTER4_4W(p1, p0, q0, q1, mask, hev);
410    ILVR_B2_SH(p0, p1, q1, q0, tmp0, tmp1);
411    ILVRL_H2_SH(tmp1, tmp0, tmp2, tmp3);
412    ILVL_B2_SH(p0, p1, q1, q0, tmp0, tmp1);
413    ILVRL_H2_SH(tmp1, tmp0, tmp4, tmp5);
414    src -= 2;
415    ST4x8_UB(tmp2, tmp3, src, stride);
416    src += (8 * stride);
417    ST4x8_UB(tmp4, tmp5, src, stride);
418  }
419  static void HFilter16i(uint8_t* src_y, int stride,
420                         int b_limit, int limit, int thresh) {
421    HFilterVertEdge16i(src_y +  4, stride, b_limit, limit, thresh);
422    HFilterVertEdge16i(src_y +  8, stride, b_limit, limit, thresh);
423    HFilterVertEdge16i(src_y + 12, stride, b_limit, limit, thresh);
424  }
425  static void VFilter8(uint8_t* src_u, uint8_t* src_v, int stride,
426                       int b_limit_in, int limit_in, int thresh_in) {
427    uint8_t* ptmp_src_u = src_u - 4 * stride;
428    uint8_t* ptmp_src_v = src_v - 4 * stride;
429    uint64_t p2_d, p1_d, p0_d, q0_d, q1_d, q2_d;
430    v16u8 p3, p2, p1, p0, q3, q2, q1, q0, mask, hev;
431    v16u8 p3_u, p2_u, p1_u, p0_u, q3_u, q2_u, q1_u, q0_u;
432    v16u8 p3_v, p2_v, p1_v, p0_v, q3_v, q2_v, q1_v, q0_v;
433    const v16u8 b_limit = (v16u8)__msa_fill_b(b_limit_in);
434    const v16u8 limit = (v16u8)__msa_fill_b(limit_in);
435    const v16u8 thresh = (v16u8)__msa_fill_b(thresh_in);
436    LD_UB8(ptmp_src_u, stride, p3_u, p2_u, p1_u, p0_u, q0_u, q1_u, q2_u, q3_u);
437    LD_UB8(ptmp_src_v, stride, p3_v, p2_v, p1_v, p0_v, q0_v, q1_v, q2_v, q3_v);
438    ILVR_D4_UB(p3_v, p3_u, p2_v, p2_u, p1_v, p1_u, p0_v, p0_u, p3, p2, p1, p0);
439    ILVR_D4_UB(q0_v, q0_u, q1_v, q1_u, q2_v, q2_u, q3_v, q3_u, q0, q1, q2, q3);
440    LPF_MASK_HEV(p3, p2, p1, p0, q0, q1, q2, q3, limit, b_limit, thresh,
441                 hev, mask);
442    LPF_MBFILTER(p2, p1, p0, q0, q1, q2, mask, hev);
443    p2_d = __msa_copy_s_d((v2i64)p2, 0);
444    p1_d = __msa_copy_s_d((v2i64)p1, 0);
445    p0_d = __msa_copy_s_d((v2i64)p0, 0);
446    q0_d = __msa_copy_s_d((v2i64)q0, 0);
447    q1_d = __msa_copy_s_d((v2i64)q1, 0);
448    q2_d = __msa_copy_s_d((v2i64)q2, 0);
449    ptmp_src_u += stride;
450    SD4(p2_d, p1_d, p0_d, q0_d, ptmp_src_u, stride);
451    ptmp_src_u += (4 * stride);
452    SD(q1_d, ptmp_src_u);
453    ptmp_src_u += stride;
454    SD(q2_d, ptmp_src_u);
455    p2_d = __msa_copy_s_d((v2i64)p2, 1);
456    p1_d = __msa_copy_s_d((v2i64)p1, 1);
457    p0_d = __msa_copy_s_d((v2i64)p0, 1);
458    q0_d = __msa_copy_s_d((v2i64)q0, 1);
459    q1_d = __msa_copy_s_d((v2i64)q1, 1);
460    q2_d = __msa_copy_s_d((v2i64)q2, 1);
461    ptmp_src_v += stride;
462    SD4(p2_d, p1_d, p0_d, q0_d, ptmp_src_v, stride);
463    ptmp_src_v += (4 * stride);
464    SD(q1_d, ptmp_src_v);
465    ptmp_src_v += stride;
466    SD(q2_d, ptmp_src_v);
467  }
468  static void HFilter8(uint8_t* src_u, uint8_t* src_v, int stride,
469                       int b_limit_in, int limit_in, int thresh_in) {
470    uint8_t* ptmp_src_u = src_u - 4;
471    uint8_t* ptmp_src_v = src_v - 4;
472    v16u8 p3, p2, p1, p0, q3, q2, q1, q0, mask, hev;
473    v16u8 row0, row1, row2, row3, row4, row5, row6, row7, row8;
474    v16u8 row9, row10, row11, row12, row13, row14, row15;
475    v8i16 tmp0, tmp1, tmp2, tmp3, tmp4, tmp5, tmp6, tmp7;
476    const v16u8 b_limit = (v16u8)__msa_fill_b(b_limit_in);
477    const v16u8 limit = (v16u8)__msa_fill_b(limit_in);
478    const v16u8 thresh = (v16u8)__msa_fill_b(thresh_in);
479    LD_UB8(ptmp_src_u, stride, row0, row1, row2, row3, row4, row5, row6, row7);
480    LD_UB8(ptmp_src_v, stride,
481           row8, row9, row10, row11, row12, row13, row14, row15);
482    TRANSPOSE16x8_UB_UB(row0, row1, row2, row3, row4, row5, row6, row7,
483                        row8, row9, row10, row11, row12, row13, row14, row15,
484                        p3, p2, p1, p0, q0, q1, q2, q3);
485    LPF_MASK_HEV(p3, p2, p1, p0, q0, q1, q2, q3, limit, b_limit, thresh,
486                 hev, mask);
487    LPF_MBFILTER(p2, p1, p0, q0, q1, q2, mask, hev);
488    ILVR_B2_SH(p1, p2, q0, p0, tmp0, tmp1);
489    ILVRL_H2_SH(tmp1, tmp0, tmp3, tmp4);
490    ILVL_B2_SH(p1, p2, q0, p0, tmp0, tmp1);
491    ILVRL_H2_SH(tmp1, tmp0, tmp6, tmp7);
492    ILVRL_B2_SH(q2, q1, tmp2, tmp5);
493    ptmp_src_u += 1;
494    ST6x4_UB(tmp3, 0, tmp2, 0, ptmp_src_u, stride);
495    ptmp_src_u += 4 * stride;
496    ST6x4_UB(tmp4, 0, tmp2, 4, ptmp_src_u, stride);
497    ptmp_src_v += 1;
498    ST6x4_UB(tmp6, 0, tmp5, 0, ptmp_src_v, stride);
499    ptmp_src_v += 4 * stride;
500    ST6x4_UB(tmp7, 0, tmp5, 4, ptmp_src_v, stride);
501  }
502  static void VFilter8i(uint8_t* src_u, uint8_t* src_v, int stride,
503                        int b_limit_in, int limit_in, int thresh_in) {
504    uint64_t p1_d, p0_d, q0_d, q1_d;
505    v16u8 p3, p2, p1, p0, q3, q2, q1, q0, mask, hev;
506    v16u8 p3_u, p2_u, p1_u, p0_u, q3_u, q2_u, q1_u, q0_u;
507    v16u8 p3_v, p2_v, p1_v, p0_v, q3_v, q2_v, q1_v, q0_v;
508    const v16u8 thresh = (v16u8)__msa_fill_b(thresh_in);
509    const v16u8 limit = (v16u8)__msa_fill_b(limit_in);
510    const v16u8 b_limit = (v16u8)__msa_fill_b(b_limit_in);
511    LD_UB8(src_u, stride, p3_u, p2_u, p1_u, p0_u, q0_u, q1_u, q2_u, q3_u);
512    src_u += (5 * stride);
513    LD_UB8(src_v, stride, p3_v, p2_v, p1_v, p0_v, q0_v, q1_v, q2_v, q3_v);
514    src_v += (5 * stride);
515    ILVR_D4_UB(p3_v, p3_u, p2_v, p2_u, p1_v, p1_u, p0_v, p0_u, p3, p2, p1, p0);
516    ILVR_D4_UB(q0_v, q0_u, q1_v, q1_u, q2_v, q2_u, q3_v, q3_u, q0, q1, q2, q3);
517    LPF_MASK_HEV(p3, p2, p1, p0, q0, q1, q2, q3, limit, b_limit, thresh,
518                 hev, mask);
519    LPF_FILTER4_4W(p1, p0, q0, q1, mask, hev);
520    p1_d = __msa_copy_s_d((v2i64)p1, 0);
521    p0_d = __msa_copy_s_d((v2i64)p0, 0);
522    q0_d = __msa_copy_s_d((v2i64)q0, 0);
523    q1_d = __msa_copy_s_d((v2i64)q1, 0);
524    SD4(q1_d, q0_d, p0_d, p1_d, src_u, -stride);
525    p1_d = __msa_copy_s_d((v2i64)p1, 1);
526    p0_d = __msa_copy_s_d((v2i64)p0, 1);
527    q0_d = __msa_copy_s_d((v2i64)q0, 1);
528    q1_d = __msa_copy_s_d((v2i64)q1, 1);
529    SD4(q1_d, q0_d, p0_d, p1_d, src_v, -stride);
530  }
531  static void HFilter8i(uint8_t* src_u, uint8_t* src_v, int stride,
532                        int b_limit_in, int limit_in, int thresh_in) {
533    v16u8 p3, p2, p1, p0, q3, q2, q1, q0, mask, hev;
534    v16u8 row0, row1, row2, row3, row4, row5, row6, row7, row8;
535    v16u8 row9, row10, row11, row12, row13, row14, row15;
536    v4i32 tmp0, tmp1, tmp2, tmp3, tmp4, tmp5;
537    const v16u8 thresh = (v16u8)__msa_fill_b(thresh_in);
538    const v16u8 limit = (v16u8)__msa_fill_b(limit_in);
539    const v16u8 b_limit = (v16u8)__msa_fill_b(b_limit_in);
540    LD_UB8(src_u, stride, row0, row1, row2, row3, row4, row5, row6, row7);
541    LD_UB8(src_v, stride,
542           row8, row9, row10, row11, row12, row13, row14, row15);
543    TRANSPOSE16x8_UB_UB(row0, row1, row2, row3, row4, row5, row6, row7,
544                        row8, row9, row10, row11, row12, row13, row14, row15,
545                        p3, p2, p1, p0, q0, q1, q2, q3);
546    LPF_MASK_HEV(p3, p2, p1, p0, q0, q1, q2, q3, limit, b_limit, thresh,
547                 hev, mask);
548    LPF_FILTER4_4W(p1, p0, q0, q1, mask, hev);
549    ILVR_B2_SW(p0, p1, q1, q0, tmp0, tmp1);
550    ILVRL_H2_SW(tmp1, tmp0, tmp2, tmp3);
551    ILVL_B2_SW(p0, p1, q1, q0, tmp0, tmp1);
552    ILVRL_H2_SW(tmp1, tmp0, tmp4, tmp5);
553    src_u += 2;
554    ST4x4_UB(tmp2, tmp2, 0, 1, 2, 3, src_u, stride);
555    src_u += 4 * stride;
556    ST4x4_UB(tmp3, tmp3, 0, 1, 2, 3, src_u, stride);
557    src_v += 2;
558    ST4x4_UB(tmp4, tmp4, 0, 1, 2, 3, src_v, stride);
559    src_v += 4 * stride;
560    ST4x4_UB(tmp5, tmp5, 0, 1, 2, 3, src_v, stride);
561  }
562  static void SimpleVFilter16(uint8_t* src, int stride, int b_limit_in) {
563    v16u8 p1, p0, q1, q0, mask;
564    const v16u8 b_limit = (v16u8)__msa_fill_b(b_limit_in);
565    LD_UB4(src - 2 * stride, stride, p1, p0, q0, q1);
566    LPF_SIMPLE_MASK(p1, p0, q0, q1, b_limit, mask);
567    LPF_SIMPLE_FILT(p1, p0, q0, q1, mask);
568    ST_UB2(p0, q0, src - stride, stride);
569  }
570  static void SimpleHFilter16(uint8_t* src, int stride, int b_limit_in) {
571    v16u8 p1, p0, q1, q0, mask, row0, row1, row2, row3, row4, row5, row6, row7;
572    v16u8 row8, row9, row10, row11, row12, row13, row14, row15;
573    v8i16 tmp0, tmp1;
574    const v16u8 b_limit = (v16u8)__msa_fill_b(b_limit_in);
575    uint8_t* ptemp_src = src - 2;
576    LD_UB8(ptemp_src, stride, row0, row1, row2, row3, row4, row5, row6, row7);
577    LD_UB8(ptemp_src + 8 * stride, stride,
578           row8, row9, row10, row11, row12, row13, row14, row15);
579    TRANSPOSE16x4_UB_UB(row0, row1, row2, row3, row4, row5, row6, row7,
580                        row8, row9, row10, row11, row12, row13, row14, row15,
581                        p1, p0, q0, q1);
582    LPF_SIMPLE_MASK(p1, p0, q0, q1, b_limit, mask);
583    LPF_SIMPLE_FILT(p1, p0, q0, q1, mask);
584    ILVRL_B2_SH(q0, p0, tmp1, tmp0);
585    ptemp_src += 1;
586    ST2x4_UB(tmp1, 0, ptemp_src, stride);
587    ptemp_src += 4 * stride;
588    ST2x4_UB(tmp1, 4, ptemp_src, stride);
589    ptemp_src += 4 * stride;
590    ST2x4_UB(tmp0, 0, ptemp_src, stride);
591    ptemp_src += 4 * stride;
592    ST2x4_UB(tmp0, 4, ptemp_src, stride);
593    ptemp_src += 4 * stride;
594  }
595  static void SimpleVFilter16i(uint8_t* src_y, int stride, int b_limit_in) {
596    SimpleVFilter16(src_y +  4 * stride, stride, b_limit_in);
597    SimpleVFilter16(src_y +  8 * stride, stride, b_limit_in);
598    SimpleVFilter16(src_y + 12 * stride, stride, b_limit_in);
599  }
600  static void SimpleHFilter16i(uint8_t* src_y, int stride, int b_limit_in) {
601    SimpleHFilter16(src_y +  4, stride, b_limit_in);
602    SimpleHFilter16(src_y +  8, stride, b_limit_in);
603    SimpleHFilter16(src_y + 12, stride, b_limit_in);
604  }
605  static void DC4(uint8_t* dst) {   
606    uint32_t dc = 4;
607    int i;
608    for (i = 0; i &lt; 4; ++i) dc += dst[i - BPS] + dst[-1 + i * BPS];
609    dc &gt;&gt;= 3;
610    dc = dc | (dc &lt;&lt; 8) | (dc &lt;&lt; 16) | (dc &lt;&lt; 24);
611    SW4(dc, dc, dc, dc, dst, BPS);
612  }
613  static void TM4(uint8_t* dst) {
614    const uint8_t* const ptemp = dst - BPS - 1;
615    v8i16 T, d, r0, r1, r2, r3;
616    const v16i8 zero = { 0 };
617    const v8i16 TL = (v8i16)__msa_fill_h(ptemp[0 * BPS]);
618    const v8i16 L0 = (v8i16)__msa_fill_h(ptemp[1 * BPS]);
619    const v8i16 L1 = (v8i16)__msa_fill_h(ptemp[2 * BPS]);
620    const v8i16 L2 = (v8i16)__msa_fill_h(ptemp[3 * BPS]);
621    const v8i16 L3 = (v8i16)__msa_fill_h(ptemp[4 * BPS]);
622    const v16u8 T1 = LD_UB(ptemp + 1);
623    T  = (v8i16)__msa_ilvr_b(zero, (v16i8)T1);
624    d = T - TL;
625    ADD4(d, L0, d, L1, d, L2, d, L3, r0, r1, r2, r3);
626    CLIP_SH4_0_255(r0, r1, r2, r3);
627    PCKEV_ST4x4_UB(r0, r1, r2, r3, dst, BPS);
628  }
629  static void VE4(uint8_t* dst) {    
630    const uint8_t* const ptop = dst - BPS - 1;
631    const uint32_t val0 = LW(ptop + 0);
632    const uint32_t val1 = LW(ptop + 4);
633    uint32_t out;
634    v16u8 A = { 0 }, B, C, AC, B2, R;
635    INSERT_W2_UB(val0, val1, A);
636    B = SLDI_UB(A, A, 1);
637    C = SLDI_UB(A, A, 2);
638    AC = __msa_ave_u_b(A, C);
639    B2 = __msa_ave_u_b(B, B);
640    R = __msa_aver_u_b(AC, B2);
641    out = __msa_copy_s_w((v4i32)R, 0);
642    SW4(out, out, out, out, dst, BPS);
643  }
644  static void RD4(uint8_t* dst) {   
645    const uint8_t* const ptop = dst - 1 - BPS;
646    uint32_t val0 = LW(ptop + 0);
647    uint32_t val1 = LW(ptop + 4);
648    uint32_t val2, val3;
649    v16u8 A, B, C, AC, B2, R, A1 = { 0 };
650    INSERT_W2_UB(val0, val1, A1);
651    A = SLDI_UB(A1, A1, 12);
652    A = (v16u8)__msa_insert_b((v16i8)A, 3, ptop[1 * BPS]);
653    A = (v16u8)__msa_insert_b((v16i8)A, 2, ptop[2 * BPS]);
654    A = (v16u8)__msa_insert_b((v16i8)A, 1, ptop[3 * BPS]);
655    A = (v16u8)__msa_insert_b((v16i8)A, 0, ptop[4 * BPS]);
656    B = SLDI_UB(A, A, 1);
657    C = SLDI_UB(A, A, 2);
658    AC = __msa_ave_u_b(A, C);
659    B2 = __msa_ave_u_b(B, B);
660    R = __msa_aver_u_b(AC, B2);
661    val3 = __msa_copy_s_w((v4i32)R, 0);
662    R = SLDI_UB(R, R, 1);
663    val2 = __msa_copy_s_w((v4i32)R, 0);
664    R = SLDI_UB(R, R, 1);
665    val1 = __msa_copy_s_w((v4i32)R, 0);
666    R = SLDI_UB(R, R, 1);
667    val0 = __msa_copy_s_w((v4i32)R, 0);
668    SW4(val0, val1, val2, val3, dst, BPS);
669  }
670  static void LD4(uint8_t* dst) {   
671    const uint8_t* const ptop = dst - BPS;
672    uint32_t val0 = LW(ptop + 0);
673    uint32_t val1 = LW(ptop + 4);
674    uint32_t val2, val3;
675    v16u8 A = { 0 }, B, C, AC, B2, R;
676    INSERT_W2_UB(val0, val1, A);
677    B = SLDI_UB(A, A, 1);
678    C = SLDI_UB(A, A, 2);
679    C = (v16u8)__msa_insert_b((v16i8)C, 6, ptop[7]);
680    AC = __msa_ave_u_b(A, C);
681    B2 = __msa_ave_u_b(B, B);
682    R = __msa_aver_u_b(AC, B2);
683    val0 = __msa_copy_s_w((v4i32)R, 0);
684    R = SLDI_UB(R, R, 1);
685    val1 = __msa_copy_s_w((v4i32)R, 0);
686    R = SLDI_UB(R, R, 1);
687    val2 = __msa_copy_s_w((v4i32)R, 0);
688    R = SLDI_UB(R, R, 1);
689    val3 = __msa_copy_s_w((v4i32)R, 0);
690    SW4(val0, val1, val2, val3, dst, BPS);
691  }
692  static void DC16(uint8_t* dst) {   
693    uint32_t dc = 16;
694    int i;
695    const v16u8 rtop = LD_UB(dst - BPS);
696    const v8u16 dctop = __msa_hadd_u_h(rtop, rtop);
697    v16u8 out;
698    for (i = 0; i &lt; 16; ++i) {
699      dc += dst[-1 + i * BPS];
700    }
701    dc += HADD_UH_U32(dctop);
702    out = (v16u8)__msa_fill_b(dc &gt;&gt; 5);
703    ST_UB8(out, out, out, out, out, out, out, out, dst, BPS);
704    ST_UB8(out, out, out, out, out, out, out, out, dst + 8 * BPS, BPS);
705  }
706  static void TM16(uint8_t* dst) {
707    int j;
708    v8i16 d1, d2;
709    const v16i8 zero = { 0 };
710    const v8i16 TL = (v8i16)__msa_fill_h(dst[-1 - BPS]);
711    const v16i8 T = LD_SB(dst - BPS);
712    ILVRL_B2_SH(zero, T, d1, d2);
713    SUB2(d1, TL, d2, TL, d1, d2);
714    for (j = 0; j &lt; 16; j += 4) {
715      v16i8 t0, t1, t2, t3;
716      v8i16 r0, r1, r2, r3, r4, r5, r6, r7;
717      const v8i16 L0 = (v8i16)__msa_fill_h(dst[-1 + 0 * BPS]);
718      const v8i16 L1 = (v8i16)__msa_fill_h(dst[-1 + 1 * BPS]);
719      const v8i16 L2 = (v8i16)__msa_fill_h(dst[-1 + 2 * BPS]);
720      const v8i16 L3 = (v8i16)__msa_fill_h(dst[-1 + 3 * BPS]);
721      ADD4(d1, L0, d1, L1, d1, L2, d1, L3, r0, r1, r2, r3);
722      ADD4(d2, L0, d2, L1, d2, L2, d2, L3, r4, r5, r6, r7);
723      CLIP_SH4_0_255(r0, r1, r2, r3);
724      CLIP_SH4_0_255(r4, r5, r6, r7);
725      PCKEV_B4_SB(r4, r0, r5, r1, r6, r2, r7, r3, t0, t1, t2, t3);
726      ST_SB4(t0, t1, t2, t3, dst, BPS);
727      dst += 4 * BPS;
728    }
729  }
730  static void VE16(uint8_t* dst) {   
731    const v16u8 rtop = LD_UB(dst - BPS);
732    ST_UB8(rtop, rtop, rtop, rtop, rtop, rtop, rtop, rtop, dst, BPS);
733    ST_UB8(rtop, rtop, rtop, rtop, rtop, rtop, rtop, rtop, dst + 8 * BPS, BPS);
734  }
735  static void HE16(uint8_t* dst) {   
736    int j;
737    for (j = 16; j &gt; 0; j -= 4) {
738      const v16u8 L0 = (v16u8)__msa_fill_b(dst[-1 + 0 * BPS]);
739      const v16u8 L1 = (v16u8)__msa_fill_b(dst[-1 + 1 * BPS]);
740      const v16u8 L2 = (v16u8)__msa_fill_b(dst[-1 + 2 * BPS]);
741      const v16u8 L3 = (v16u8)__msa_fill_b(dst[-1 + 3 * BPS]);
742      ST_UB4(L0, L1, L2, L3, dst, BPS);
743      dst += 4 * BPS;
744    }
745  }
746  static void DC16NoTop(uint8_t* dst) {   
747    int j;
748    uint32_t dc = 8;
749    v16u8 out;
750    for (j = 0; j &lt; 16; ++j) {
751      dc += dst[-1 + j * BPS];
752    }
753    out = (v16u8)__msa_fill_b(dc &gt;&gt; 4);
754    ST_UB8(out, out, out, out, out, out, out, out, dst, BPS);
755    ST_UB8(out, out, out, out, out, out, out, out, dst + 8 * BPS, BPS);
756  }
757  static void DC16NoLeft(uint8_t* dst) {   
758    uint32_t dc = 8;
759    const v16u8 rtop = LD_UB(dst - BPS);
760    const v8u16 dctop = __msa_hadd_u_h(rtop, rtop);
761    v16u8 out;
762    dc += HADD_UH_U32(dctop);
763    out = (v16u8)__msa_fill_b(dc &gt;&gt; 4);
764    ST_UB8(out, out, out, out, out, out, out, out, dst, BPS);
765    ST_UB8(out, out, out, out, out, out, out, out, dst + 8 * BPS, BPS);
766  }
767  static void DC16NoTopLeft(uint8_t* dst) {   
768    const v16u8 out = (v16u8)__msa_fill_b(0x80);
769    ST_UB8(out, out, out, out, out, out, out, out, dst, BPS);
770    ST_UB8(out, out, out, out, out, out, out, out, dst + 8 * BPS, BPS);
771  }
772  #define STORE8x8(out, dst) do {                 \
773    SD4(out, out, out, out, dst + 0 * BPS, BPS);  \
774    SD4(out, out, out, out, dst + 4 * BPS, BPS);  \
775  } while (0)
776  static void DC8uv(uint8_t* dst) {   
777    uint32_t dc = 8;
778    int i;
779    uint64_t out;
780    const v16u8 rtop = LD_UB(dst - BPS);
781    const v8u16 temp0 = __msa_hadd_u_h(rtop, rtop);
782    const v4u32 temp1 = __msa_hadd_u_w(temp0, temp0);
783    const v2u64 temp2 = __msa_hadd_u_d(temp1, temp1);
784    v16u8 dctemp;
785    for (i = 0; i &lt; 8; ++i) {
786      dc += dst[-1 + i * BPS];
787    }
788    dc += __msa_copy_s_w((v4i32)temp2, 0);
789    dctemp = (v16u8)__msa_fill_b(dc &gt;&gt; 4);
790    out = __msa_copy_s_d((v2i64)dctemp, 0);
791    STORE8x8(out, dst);
792  }
793  static void TM8uv(uint8_t* dst) {
794    int j;
795    const v16i8 T1 = LD_SB(dst - BPS);
796    const v16i8 zero = { 0 };
797    const v8i16 T  = (v8i16)__msa_ilvr_b(zero, T1);
798    const v8i16 TL = (v8i16)__msa_fill_h(dst[-1 - BPS]);
799    const v8i16 d = T - TL;
800    for (j = 0; j &lt; 8; j += 4) {
801      v16i8 t0, t1;
802      v8i16 r0 = (v8i16)__msa_fill_h(dst[-1 + 0 * BPS]);
803      v8i16 r1 = (v8i16)__msa_fill_h(dst[-1 + 1 * BPS]);
804      v8i16 r2 = (v8i16)__msa_fill_h(dst[-1 + 2 * BPS]);
805      v8i16 r3 = (v8i16)__msa_fill_h(dst[-1 + 3 * BPS]);
806      ADD4(d, r0, d, r1, d, r2, d, r3, r0, r1, r2, r3);
807      CLIP_SH4_0_255(r0, r1, r2, r3);
808      PCKEV_B2_SB(r1, r0, r3, r2, t0, t1);
809      ST4x4_UB(t0, t1, 0, 2, 0, 2, dst, BPS);
810      ST4x4_UB(t0, t1, 1, 3, 1, 3, dst + 4, BPS);
811      dst += 4 * BPS;
812    }
813  }
814  static void VE8uv(uint8_t* dst) {   
815    const v16u8 rtop = LD_UB(dst - BPS);
816    const uint64_t out = __msa_copy_s_d((v2i64)rtop, 0);
817    STORE8x8(out, dst);
818  }
819  static void HE8uv(uint8_t* dst) {   
820    int j;
821    for (j = 0; j &lt; 8; j += 4) {
822      const v16u8 L0 = (v16u8)__msa_fill_b(dst[-1 + 0 * BPS]);
823      const v16u8 L1 = (v16u8)__msa_fill_b(dst[-1 + 1 * BPS]);
824      const v16u8 L2 = (v16u8)__msa_fill_b(dst[-1 + 2 * BPS]);
825      const v16u8 L3 = (v16u8)__msa_fill_b(dst[-1 + 3 * BPS]);
826      const uint64_t out0 = __msa_copy_s_d((v2i64)L0, 0);
827      const uint64_t out1 = __msa_copy_s_d((v2i64)L1, 0);
828      const uint64_t out2 = __msa_copy_s_d((v2i64)L2, 0);
829      const uint64_t out3 = __msa_copy_s_d((v2i64)L3, 0);
830      SD4(out0, out1, out2, out3, dst, BPS);
831      dst += 4 * BPS;
832    }
833  }
834  static void DC8uvNoLeft(uint8_t* dst) {   
835    const uint32_t dc = 4;
836    const v16u8 rtop = LD_UB(dst - BPS);
837    const v8u16 temp0 = __msa_hadd_u_h(rtop, rtop);
838    const v4u32 temp1 = __msa_hadd_u_w(temp0, temp0);
839    const v2u64 temp2 = __msa_hadd_u_d(temp1, temp1);
840    const uint32_t sum_m = __msa_copy_s_w((v4i32)temp2, 0);
841    const v16u8 dcval = (v16u8)__msa_fill_b((dc + sum_m) &gt;&gt; 3);
842    const uint64_t out = __msa_copy_s_d((v2i64)dcval, 0);
843    STORE8x8(out, dst);
844  }
845  static void DC8uvNoTop(uint8_t* dst) {   
846    uint32_t dc = 4;
847    int i;
848    uint64_t out;
849    v16u8 dctemp;
850    for (i = 0; i &lt; 8; ++i) {
851      dc += dst[-1 + i * BPS];
852    }
853    dctemp = (v16u8)__msa_fill_b(dc &gt;&gt; 3);
854    out = __msa_copy_s_d((v2i64)dctemp, 0);
855    STORE8x8(out, dst);
856  }
857  static void DC8uvNoTopLeft(uint8_t* dst) {   
858    const uint64_t out = 0x8080808080808080ULL;
859    STORE8x8(out, dst);
860  }
861  extern void VP8DspInitMSA(void);
862  WEBP_TSAN_IGNORE_FUNCTION void VP8DspInitMSA(void) {
863    VP8TransformWHT = TransformWHT;
864    VP8Transform = TransformTwo;
865    VP8TransformDC = TransformDC;
866    VP8TransformAC3 = TransformAC3;
867    VP8VFilter16  = VFilter16;
868    VP8HFilter16  = HFilter16;
869    VP8VFilter16i = VFilter16i;
870    VP8HFilter16i = HFilter16i;
871    VP8VFilter8  = VFilter8;
872    VP8HFilter8  = HFilter8;
873    VP8VFilter8i = VFilter8i;
874    VP8HFilter8i = HFilter8i;
875    VP8SimpleVFilter16  = SimpleVFilter16;
876    VP8SimpleHFilter16  = SimpleHFilter16;
877    VP8SimpleVFilter16i = SimpleVFilter16i;
878    VP8SimpleHFilter16i = SimpleHFilter16i;
879    VP8PredLuma4[0] = DC4;
880    VP8PredLuma4[1] = TM4;
881    VP8PredLuma4[2] = VE4;
882    VP8PredLuma4[4] = RD4;
883    VP8PredLuma4[6] = LD4;
884    VP8PredLuma16[0] = DC16;
885    VP8PredLuma16[1] = TM16;
886    VP8PredLuma16[2] = VE16;
887    VP8PredLuma16[3] = HE16;
888    VP8PredLuma16[4] = DC16NoTop;
889    VP8PredLuma16[5] = DC16NoLeft;
890    VP8PredLuma16[6] = DC16NoTopLeft;
891    VP8PredChroma8[0] = DC8uv;
892    VP8PredChroma8[1] = TM8uv;
893    VP8PredChroma8[2] = VE8uv;
894    VP8PredChroma8[3] = HE8uv;
895    VP8PredChroma8[4] = DC8uvNoTop;
896    VP8PredChroma8[5] = DC8uvNoLeft;
897    VP8PredChroma8[6] = DC8uvNoTopLeft;
898  }
899  #else  
900  WEBP_DSP_INIT_STUB(VP8DspInitMSA)
901  #endif  
</code></pre>
        </div>
        <div class="column">
            <h3>PINRemoteImage-MDEwOlJlcG9zaXRvcnkzOTUzNzEwMw==-flat-dec_msa.c</h3>
            <pre><code>1  #include &quot;src/dsp/dsp.h&quot;
2  #if defined(WEBP_USE_MSA)
3  #include &quot;src/dsp/msa_macro.h&quot;
4  #define IDCT_1D_W(in0, in1, in2, in3, out0, out1, out2, out3) {  \
5    v4i32 a1_m, b1_m, c1_m, d1_m;                                  \
6    v4i32 c_tmp1_m, c_tmp2_m, d_tmp1_m, d_tmp2_m;                  \
7    const v4i32 cospi8sqrt2minus1 = __msa_fill_w(20091);           \
8    const v4i32 sinpi8sqrt2 = __msa_fill_w(35468);                 \
9                                                                   \
10    a1_m = in0 + in2;                                              \
11    b1_m = in0 - in2;                                              \
12    c_tmp1_m = (in1 * sinpi8sqrt2) &gt;&gt; 16;                          \
13    c_tmp2_m = in3 + ((in3 * cospi8sqrt2minus1) &gt;&gt; 16);            \
14    c1_m = c_tmp1_m - c_tmp2_m;                                    \
15    d_tmp1_m = in1 + ((in1 * cospi8sqrt2minus1) &gt;&gt; 16);            \
16    d_tmp2_m = (in3 * sinpi8sqrt2) &gt;&gt; 16;                          \
17    d1_m = d_tmp1_m + d_tmp2_m;                                    \
18    BUTTERFLY_4(a1_m, b1_m, c1_m, d1_m, out0, out1, out2, out3);   \
19  }
20  #define MULT1(a) ((((a) * 20091) &gt;&gt; 16) + (a))
21  #define MULT2(a) (((a) * 35468) &gt;&gt; 16)
22  static void TransformOne(const int16_t* in, uint8_t* dst) {
23    v8i16 input0, input1;
24    v4i32 in0, in1, in2, in3, hz0, hz1, hz2, hz3, vt0, vt1, vt2, vt3;
25    v4i32 res0, res1, res2, res3;
26    const v16i8 zero = { 0 };
27    v16i8 dest0, dest1, dest2, dest3;
28    LD_SH2(in, 8, input0, input1);
29    UNPCK_SH_SW(input0, in0, in1);
30    UNPCK_SH_SW(input1, in2, in3);
31    IDCT_1D_W(in0, in1, in2, in3, hz0, hz1, hz2, hz3);
32    TRANSPOSE4x4_SW_SW(hz0, hz1, hz2, hz3, hz0, hz1, hz2, hz3);
33    IDCT_1D_W(hz0, hz1, hz2, hz3, vt0, vt1, vt2, vt3);
34    SRARI_W4_SW(vt0, vt1, vt2, vt3, 3);
35    TRANSPOSE4x4_SW_SW(vt0, vt1, vt2, vt3, vt0, vt1, vt2, vt3);
36    LD_SB4(dst, BPS, dest0, dest1, dest2, dest3);
37    ILVR_B4_SW(zero, dest0, zero, dest1, zero, dest2, zero, dest3,
38               res0, res1, res2, res3);
39    ILVR_H4_SW(zero, res0, zero, res1, zero, res2, zero, res3,
40               res0, res1, res2, res3);
41    ADD4(res0, vt0, res1, vt1, res2, vt2, res3, vt3, res0, res1, res2, res3);
42    CLIP_SW4_0_255(res0, res1, res2, res3);
43    PCKEV_B2_SW(res0, res1, res2, res3, vt0, vt1);
44    res0 = (v4i32)__msa_pckev_b((v16i8)vt0, (v16i8)vt1);
45    ST4x4_UB(res0, res0, 3, 2, 1, 0, dst, BPS);
46  }
47  static void TransformTwo(const int16_t* in, uint8_t* dst, int do_two) {
48    TransformOne(in, dst);
49    if (do_two) {
50      TransformOne(in + 16, dst + 4);
51    }
52  }
53  static void TransformWHT(const int16_t* in, int16_t* out) {
54    v8i16 input0, input1;
55    const v8i16 mask0 = { 0, 1, 2, 3, 8, 9, 10, 11 };
56    const v8i16 mask1 = { 4, 5, 6, 7, 12, 13, 14, 15 };
57    const v8i16 mask2 = { 0, 4, 8, 12, 1, 5, 9, 13 };
58    const v8i16 mask3 = { 3, 7, 11, 15, 2, 6, 10, 14 };
59    v8i16 tmp0, tmp1, tmp2, tmp3;
60    v8i16 out0, out1;
61    LD_SH2(in, 8, input0, input1);
62    input1 = SLDI_SH(input1, input1, 8);
63    tmp0 = input0 + input1;
64    tmp1 = input0 - input1;
65    VSHF_H2_SH(tmp0, tmp1, tmp0, tmp1, mask0, mask1, tmp2, tmp3);
66    out0 = tmp2 + tmp3;
67    out1 = tmp2 - tmp3;
68    VSHF_H2_SH(out0, out1, out0, out1, mask2, mask3, input0, input1);
69    tmp0 = input0 + input1;
70    tmp1 = input0 - input1;
71    VSHF_H2_SH(tmp0, tmp1, tmp0, tmp1, mask0, mask1, tmp2, tmp3);
72    tmp0 = tmp2 + tmp3;
73    tmp1 = tmp2 - tmp3;
74    ADDVI_H2_SH(tmp0, 3, tmp1, 3, out0, out1);
75    SRAI_H2_SH(out0, out1, 3);
76    out[0] = __msa_copy_s_h(out0, 0);
77    out[16] = __msa_copy_s_h(out0, 4);
78    out[32] = __msa_copy_s_h(out1, 0);
79    out[48] = __msa_copy_s_h(out1, 4);
80    out[64] = __msa_copy_s_h(out0, 1);
81    out[80] = __msa_copy_s_h(out0, 5);
82    out[96] = __msa_copy_s_h(out1, 1);
83    out[112] = __msa_copy_s_h(out1, 5);
84    out[128] = __msa_copy_s_h(out0, 2);
85    out[144] = __msa_copy_s_h(out0, 6);
86    out[160] = __msa_copy_s_h(out1, 2);
87    out[176] = __msa_copy_s_h(out1, 6);
88    out[192] = __msa_copy_s_h(out0, 3);
89    out[208] = __msa_copy_s_h(out0, 7);
90    out[224] = __msa_copy_s_h(out1, 3);
91    out[240] = __msa_copy_s_h(out1, 7);
92  }
93  static void TransformDC(const int16_t* in, uint8_t* dst) {
94    const int DC = (in[0] + 4) &gt;&gt; 3;
95    const v8i16 tmp0 = __msa_fill_h(DC);
96    ADDBLK_ST4x4_UB(tmp0, tmp0, tmp0, tmp0, dst, BPS);
97  }
98  static void TransformAC3(const int16_t* in, uint8_t* dst) {
99    const int a = in[0] + 4;
100    const int c4 = MULT2(in[4]);
101    const int d4 = MULT1(in[4]);
102    const int in2 = MULT2(in[1]);
103    const int in3 = MULT1(in[1]);
104    v4i32 tmp0 = { 0 };
105    v4i32 out0 = __msa_fill_w(a + d4);
106    v4i32 out1 = __msa_fill_w(a + c4);
107    v4i32 out2 = __msa_fill_w(a - c4);
108    v4i32 out3 = __msa_fill_w(a - d4);
109    v4i32 res0, res1, res2, res3;
110    const v4i32 zero = { 0 };
111    v16u8 dest0, dest1, dest2, dest3;
112    INSERT_W4_SW(in3, in2, -in2, -in3, tmp0);
113    ADD4(out0, tmp0, out1, tmp0, out2, tmp0, out3, tmp0,
114         out0, out1, out2, out3);
115    SRAI_W4_SW(out0, out1, out2, out3, 3);
116    LD_UB4(dst, BPS, dest0, dest1, dest2, dest3);
117    ILVR_B4_SW(zero, dest0, zero, dest1, zero, dest2, zero, dest3,
118               res0, res1, res2, res3);
119    ILVR_H4_SW(zero, res0, zero, res1, zero, res2, zero, res3,
120               res0, res1, res2, res3);
121    ADD4(res0, out0, res1, out1, res2, out2, res3, out3, res0, res1, res2, res3);
122    CLIP_SW4_0_255(res0, res1, res2, res3);
123    PCKEV_B2_SW(res0, res1, res2, res3, out0, out1);
124    res0 = (v4i32)__msa_pckev_b((v16i8)out0, (v16i8)out1);
125    ST4x4_UB(res0, res0, 3, 2, 1, 0, dst, BPS);
126  }
127  #define FLIP_SIGN2(in0, in1, out0, out1) {  \
128    out0 = (v16i8)__msa_xori_b(in0, 0x80);    \
129    out1 = (v16i8)__msa_xori_b(in1, 0x80);    \
130  }
131  #define FLIP_SIGN4(in0, in1, in2, in3, out0, out1, out2, out3) {  \
132    FLIP_SIGN2(in0, in1, out0, out1);                               \
133    FLIP_SIGN2(in2, in3, out2, out3);                               \
134  }
135  #define FILT_VAL(q0_m, p0_m, mask, filt) do {  \
136    v16i8 q0_sub_p0;                             \
137    q0_sub_p0 = __msa_subs_s_b(q0_m, p0_m);      \
138    filt = __msa_adds_s_b(filt, q0_sub_p0);      \
139    filt = __msa_adds_s_b(filt, q0_sub_p0);      \
140    filt = __msa_adds_s_b(filt, q0_sub_p0);      \
141    filt = filt &amp; mask;                          \
142  } while (0)
143  #define FILT2(q_m, p_m, q, p) do {            \
144    u_r = SRAI_H(temp1, 7);                     \
145    u_r = __msa_sat_s_h(u_r, 7);                \
146    u_l = SRAI_H(temp3, 7);                     \
147    u_l = __msa_sat_s_h(u_l, 7);                \
148    u = __msa_pckev_b((v16i8)u_l, (v16i8)u_r);  \
149    q_m = __msa_subs_s_b(q_m, u);               \
150    p_m = __msa_adds_s_b(p_m, u);               \
151    q = __msa_xori_b((v16u8)q_m, 0x80);         \
152    p = __msa_xori_b((v16u8)p_m, 0x80);         \
153  } while (0)
154  #define LPF_FILTER4_4W(p1, p0, q0, q1, mask, hev) do {  \
155    v16i8 p1_m, p0_m, q0_m, q1_m;                         \
156    v16i8 filt, t1, t2;                                   \
157    const v16i8 cnst4b = __msa_ldi_b(4);                  \
158    const v16i8 cnst3b = __msa_ldi_b(3);                  \
159                                                          \
160    FLIP_SIGN4(p1, p0, q0, q1, p1_m, p0_m, q0_m, q1_m);   \
161    filt = __msa_subs_s_b(p1_m, q1_m);                    \
162    filt = filt &amp; hev;                                    \
163    FILT_VAL(q0_m, p0_m, mask, filt);                     \
164    t1 = __msa_adds_s_b(filt, cnst4b);                    \
165    t1 = SRAI_B(t1, 3);                                   \
166    t2 = __msa_adds_s_b(filt, cnst3b);                    \
167    t2 = SRAI_B(t2, 3);                                   \
168    q0_m = __msa_subs_s_b(q0_m, t1);                      \
169    q0 = __msa_xori_b((v16u8)q0_m, 0x80);                 \
170    p0_m = __msa_adds_s_b(p0_m, t2);                      \
171    p0 = __msa_xori_b((v16u8)p0_m, 0x80);                 \
172    filt = __msa_srari_b(t1, 1);                          \
173    hev = __msa_xori_b(hev, 0xff);                        \
174    filt = filt &amp; hev;                                    \
175    q1_m = __msa_subs_s_b(q1_m, filt);                    \
176    q1 = __msa_xori_b((v16u8)q1_m, 0x80);                 \
177    p1_m = __msa_adds_s_b(p1_m, filt);                    \
178    p1 = __msa_xori_b((v16u8)p1_m, 0x80);                 \
179  } while (0)
180  #define LPF_MBFILTER(p2, p1, p0, q0, q1, q2, mask, hev) do {  \
181    v16i8 p2_m, p1_m, p0_m, q2_m, q1_m, q0_m;                   \
182    v16i8 u, filt, t1, t2, filt_sign;                           \
183    v8i16 filt_r, filt_l, u_r, u_l;                             \
184    v8i16 temp0, temp1, temp2, temp3;                           \
185    const v16i8 cnst4b = __msa_ldi_b(4);                        \
186    const v16i8 cnst3b = __msa_ldi_b(3);                        \
187    const v8i16 cnst9h = __msa_ldi_h(9);                        \
188    const v8i16 cnst63h = __msa_ldi_h(63);                      \
189                                                                \
190    FLIP_SIGN4(p1, p0, q0, q1, p1_m, p0_m, q0_m, q1_m);         \
191    filt = __msa_subs_s_b(p1_m, q1_m);                          \
192    FILT_VAL(q0_m, p0_m, mask, filt);                           \
193    FLIP_SIGN2(p2, q2, p2_m, q2_m);                             \
194    t2 = filt &amp; hev;                                            \
195                                          \
196    hev = __msa_xori_b(hev, 0xff);                              \
197    filt = filt &amp; hev;                                          \
198    t1 = __msa_adds_s_b(t2, cnst4b);                            \
199    t1 = SRAI_B(t1, 3);                                         \
200    t2 = __msa_adds_s_b(t2, cnst3b);                            \
201    t2 = SRAI_B(t2, 3);                                         \
202    q0_m = __msa_subs_s_b(q0_m, t1);                            \
203    p0_m = __msa_adds_s_b(p0_m, t2);                            \
204    filt_sign = __msa_clti_s_b(filt, 0);                        \
205    ILVRL_B2_SH(filt_sign, filt, filt_r, filt_l);               \
206                                              \
207    temp0 = filt_r * cnst9h;                                    \
208    temp1 = temp0 + cnst63h;                                    \
209    temp2 = filt_l * cnst9h;                                    \
210    temp3 = temp2 + cnst63h;                                    \
211    FILT2(q2_m, p2_m, q2, p2);                                  \
212                                              \
213    temp1 = temp1 + temp0;                                      \
214    temp3 = temp3 + temp2;                                      \
215    FILT2(q1_m, p1_m, q1, p1);                                  \
216                                              \
217    temp1 = temp1 + temp0;                                      \
218    temp3 = temp3 + temp2;                                      \
219    FILT2(q0_m, p0_m, q0, p0);                                  \
220  } while (0)
221  #define LPF_MASK_HEV(p3_in, p2_in, p1_in, p0_in,                 \
222                       q0_in, q1_in, q2_in, q3_in,                 \
223                       limit_in, b_limit_in, thresh_in,            \
224                       hev_out, mask_out) do {                     \
225    v16u8 p3_asub_p2_m, p2_asub_p1_m, p1_asub_p0_m, q1_asub_q0_m;  \
226    v16u8 p1_asub_q1_m, p0_asub_q0_m, q3_asub_q2_m, q2_asub_q1_m;  \
227    v16u8 flat_out;                                                \
228                                                                   \
229                         \
230    p3_asub_p2_m = __msa_asub_u_b(p3_in, p2_in);                   \
231    p2_asub_p1_m = __msa_asub_u_b(p2_in, p1_in);                   \
232    p1_asub_p0_m = __msa_asub_u_b(p1_in, p0_in);                   \
233    q1_asub_q0_m = __msa_asub_u_b(q1_in, q0_in);                   \
234    q2_asub_q1_m = __msa_asub_u_b(q2_in, q1_in);                   \
235    q3_asub_q2_m = __msa_asub_u_b(q3_in, q2_in);                   \
236    p0_asub_q0_m = __msa_asub_u_b(p0_in, q0_in);                   \
237    p1_asub_q1_m = __msa_asub_u_b(p1_in, q1_in);                   \
238                                           \
239    flat_out = __msa_max_u_b(p1_asub_p0_m, q1_asub_q0_m);          \
240    hev_out = (thresh_in &lt; flat_out);                              \
241                                          \
242    p0_asub_q0_m = __msa_adds_u_b(p0_asub_q0_m, p0_asub_q0_m);     \
243    p1_asub_q1_m = SRAI_B(p1_asub_q1_m, 1);                        \
244    p0_asub_q0_m = __msa_adds_u_b(p0_asub_q0_m, p1_asub_q1_m);     \
245    mask_out = (b_limit_in &lt; p0_asub_q0_m);                        \
246    mask_out = __msa_max_u_b(flat_out, mask_out);                  \
247    p3_asub_p2_m = __msa_max_u_b(p3_asub_p2_m, p2_asub_p1_m);      \
248    mask_out = __msa_max_u_b(p3_asub_p2_m, mask_out);              \
249    q2_asub_q1_m = __msa_max_u_b(q2_asub_q1_m, q3_asub_q2_m);      \
250    mask_out = __msa_max_u_b(q2_asub_q1_m, mask_out);              \
251    mask_out = (limit_in &lt; mask_out);                              \
252    mask_out = __msa_xori_b(mask_out, 0xff);                       \
253  } while (0)
254  #define ST6x1_UB(in0, in0_idx, in1, in1_idx, pdst, stride) do { \
255    const uint16_t tmp0_h = __msa_copy_s_h((v8i16)in1, in1_idx);  \
256    const uint32_t tmp0_w = __msa_copy_s_w((v4i32)in0, in0_idx);  \
257    SW(tmp0_w, pdst);                                             \
258    SH(tmp0_h, pdst + stride);                                    \
259  } while (0)
260  #define ST6x4_UB(in0, start_in0_idx, in1, start_in1_idx, pdst, stride) do { \
261    uint8_t* ptmp1 = (uint8_t*)pdst;                                          \
262    ST6x1_UB(in0, start_in0_idx, in1, start_in1_idx, ptmp1, 4);               \
263    ptmp1 += stride;                                                          \
264    ST6x1_UB(in0, start_in0_idx + 1, in1, start_in1_idx + 1, ptmp1, 4);       \
265    ptmp1 += stride;                                                          \
266    ST6x1_UB(in0, start_in0_idx + 2, in1, start_in1_idx + 2, ptmp1, 4);       \
<span onclick='openModal()' class='match'>267    ptmp1 += stride;                                                          \
268    ST6x1_UB(in0, start_in0_idx + 3, in1, start_in1_idx + 3, ptmp1, 4);       \
269  } while (0)
</span>270  #define LPF_SIMPLE_FILT(p1_in, p0_in, q0_in, q1_in, mask) do {       \
271      v16i8 p1_m, p0_m, q0_m, q1_m, filt, filt1, filt2;                \
272      const v16i8 cnst4b = __msa_ldi_b(4);                             \
273      const v16i8 cnst3b =  __msa_ldi_b(3);                            \
274                                                                       \
275      FLIP_SIGN4(p1_in, p0_in, q0_in, q1_in, p1_m, p0_m, q0_m, q1_m);  \
276      filt = __msa_subs_s_b(p1_m, q1_m);                               \
277      FILT_VAL(q0_m, p0_m, mask, filt);                                \
278      filt1 = __msa_adds_s_b(filt, cnst4b);                            \
279      filt1 = SRAI_B(filt1, 3);                                        \
280      filt2 = __msa_adds_s_b(filt, cnst3b);                            \
281      filt2 = SRAI_B(filt2, 3);                                        \
282      q0_m = __msa_subs_s_b(q0_m, filt1);                              \
283      p0_m = __msa_adds_s_b(p0_m, filt2);                              \
284      q0_in = __msa_xori_b((v16u8)q0_m, 0x80);                         \
285      p0_in = __msa_xori_b((v16u8)p0_m, 0x80);                         \
286  } while (0)
287  #define LPF_SIMPLE_MASK(p1, p0, q0, q1, b_limit, mask) do {    \
288      v16u8 p1_a_sub_q1, p0_a_sub_q0;                            \
289                                                                 \
290      p0_a_sub_q0 = __msa_asub_u_b(p0, q0);                      \
291      p1_a_sub_q1 = __msa_asub_u_b(p1, q1);                      \
292      p1_a_sub_q1 = (v16u8)__msa_srli_b((v16i8)p1_a_sub_q1, 1);  \
293      p0_a_sub_q0 = __msa_adds_u_b(p0_a_sub_q0, p0_a_sub_q0);    \
294      mask = __msa_adds_u_b(p0_a_sub_q0, p1_a_sub_q1);           \
295      mask = (mask &lt;= b_limit);                                  \
296  } while (0)
297  static void VFilter16(uint8_t* src, int stride,
298                        int b_limit_in, int limit_in, int thresh_in) {
299    uint8_t* ptemp = src - 4 * stride;
300    v16u8 p3, p2, p1, p0, q3, q2, q1, q0;
301    v16u8 mask, hev;
302    const v16u8 thresh = (v16u8)__msa_fill_b(thresh_in);
303    const v16u8 limit = (v16u8)__msa_fill_b(limit_in);
304    const v16u8 b_limit = (v16u8)__msa_fill_b(b_limit_in);
305    LD_UB8(ptemp, stride, p3, p2, p1, p0, q0, q1, q2, q3);
306    LPF_MASK_HEV(p3, p2, p1, p0, q0, q1, q2, q3, limit, b_limit, thresh,
307                 hev, mask);
308    LPF_MBFILTER(p2, p1, p0, q0, q1, q2, mask, hev);
309    ptemp = src - 3 * stride;
310    ST_UB4(p2, p1, p0, q0, ptemp, stride);
311    ptemp += (4 * stride);
312    ST_UB2(q1, q2, ptemp, stride);
313  }
314  static void HFilter16(uint8_t* src, int stride,
315                        int b_limit_in, int limit_in, int thresh_in) {
316    uint8_t* ptmp  = src - 4;
317    v16u8 p3, p2, p1, p0, q3, q2, q1, q0;
318    v16u8 mask, hev;
319    v16u8 row0, row1, row2, row3, row4, row5, row6, row7, row8;
320    v16u8 row9, row10, row11, row12, row13, row14, row15;
321    v8i16 tmp0, tmp1, tmp2, tmp3, tmp4, tmp5, tmp6, tmp7;
322    const v16u8 b_limit = (v16u8)__msa_fill_b(b_limit_in);
323    const v16u8 limit = (v16u8)__msa_fill_b(limit_in);
324    const v16u8 thresh = (v16u8)__msa_fill_b(thresh_in);
325    LD_UB8(ptmp, stride, row0, row1, row2, row3, row4, row5, row6, row7);
326    ptmp += (8 * stride);
327    LD_UB8(ptmp, stride, row8, row9, row10, row11, row12, row13, row14, row15);
328    TRANSPOSE16x8_UB_UB(row0, row1, row2, row3, row4, row5, row6, row7,
329                        row8, row9, row10, row11, row12, row13, row14, row15,
330                        p3, p2, p1, p0, q0, q1, q2, q3);
331    LPF_MASK_HEV(p3, p2, p1, p0, q0, q1, q2, q3, limit, b_limit, thresh,
332                 hev, mask);
333    LPF_MBFILTER(p2, p1, p0, q0, q1, q2, mask, hev);
334    ILVR_B2_SH(p1, p2, q0, p0, tmp0, tmp1);
335    ILVRL_H2_SH(tmp1, tmp0, tmp3, tmp4);
336    ILVL_B2_SH(p1, p2, q0, p0, tmp0, tmp1);
337    ILVRL_H2_SH(tmp1, tmp0, tmp6, tmp7);
338    ILVRL_B2_SH(q2, q1, tmp2, tmp5);
339    ptmp = src - 3;
340    ST6x1_UB(tmp3, 0, tmp2, 0, ptmp, 4);
341    ptmp += stride;
342    ST6x1_UB(tmp3, 1, tmp2, 1, ptmp, 4);
343    ptmp += stride;
344    ST6x1_UB(tmp3, 2, tmp2, 2, ptmp, 4);
345    ptmp += stride;
346    ST6x1_UB(tmp3, 3, tmp2, 3, ptmp, 4);
347    ptmp += stride;
348    ST6x1_UB(tmp4, 0, tmp2, 4, ptmp, 4);
349    ptmp += stride;
350    ST6x1_UB(tmp4, 1, tmp2, 5, ptmp, 4);
351    ptmp += stride;
352    ST6x1_UB(tmp4, 2, tmp2, 6, ptmp, 4);
353    ptmp += stride;
354    ST6x1_UB(tmp4, 3, tmp2, 7, ptmp, 4);
355    ptmp += stride;
356    ST6x1_UB(tmp6, 0, tmp5, 0, ptmp, 4);
357    ptmp += stride;
358    ST6x1_UB(tmp6, 1, tmp5, 1, ptmp, 4);
359    ptmp += stride;
360    ST6x1_UB(tmp6, 2, tmp5, 2, ptmp, 4);
361    ptmp += stride;
362    ST6x1_UB(tmp6, 3, tmp5, 3, ptmp, 4);
363    ptmp += stride;
364    ST6x1_UB(tmp7, 0, tmp5, 4, ptmp, 4);
365    ptmp += stride;
366    ST6x1_UB(tmp7, 1, tmp5, 5, ptmp, 4);
367    ptmp += stride;
368    ST6x1_UB(tmp7, 2, tmp5, 6, ptmp, 4);
369    ptmp += stride;
370    ST6x1_UB(tmp7, 3, tmp5, 7, ptmp, 4);
371  }
372  static void VFilterHorEdge16i(uint8_t* src, int stride,
373                                int b_limit, int limit, int thresh) {
374    v16u8 mask, hev;
375    v16u8 p3, p2, p1, p0, q3, q2, q1, q0;
376    const v16u8 thresh0 = (v16u8)__msa_fill_b(thresh);
377    const v16u8 b_limit0 = (v16u8)__msa_fill_b(b_limit);
378    const v16u8 limit0 = (v16u8)__msa_fill_b(limit);
379    LD_UB8((src - 4 * stride), stride, p3, p2, p1, p0, q0, q1, q2, q3);
380    LPF_MASK_HEV(p3, p2, p1, p0, q0, q1, q2, q3, limit0, b_limit0, thresh0,
381                 hev, mask);
382    LPF_FILTER4_4W(p1, p0, q0, q1, mask, hev);
383    ST_UB4(p1, p0, q0, q1, (src - 2 * stride), stride);
384  }
385  static void VFilter16i(uint8_t* src_y, int stride,
386                         int b_limit, int limit, int thresh) {
387    VFilterHorEdge16i(src_y +  4 * stride, stride, b_limit, limit, thresh);
388    VFilterHorEdge16i(src_y +  8 * stride, stride, b_limit, limit, thresh);
389    VFilterHorEdge16i(src_y + 12 * stride, stride, b_limit, limit, thresh);
390  }
391  static void HFilterVertEdge16i(uint8_t* src, int stride,
392                                 int b_limit, int limit, int thresh) {
393    v16u8 mask, hev;
394    v16u8 p3, p2, p1, p0, q3, q2, q1, q0;
395    v16u8 row0, row1, row2, row3, row4, row5, row6, row7;
396    v16u8 row8, row9, row10, row11, row12, row13, row14, row15;
397    v8i16 tmp0, tmp1, tmp2, tmp3, tmp4, tmp5;
398    const v16u8 thresh0 = (v16u8)__msa_fill_b(thresh);
399    const v16u8 b_limit0 = (v16u8)__msa_fill_b(b_limit);
400    const v16u8 limit0 = (v16u8)__msa_fill_b(limit);
401    LD_UB8(src - 4, stride, row0, row1, row2, row3, row4, row5, row6, row7);
402    LD_UB8(src - 4 + (8 * stride), stride,
403           row8, row9, row10, row11, row12, row13, row14, row15);
404    TRANSPOSE16x8_UB_UB(row0, row1, row2, row3, row4, row5, row6, row7,
405                        row8, row9, row10, row11, row12, row13, row14, row15,
406                        p3, p2, p1, p0, q0, q1, q2, q3);
407    LPF_MASK_HEV(p3, p2, p1, p0, q0, q1, q2, q3, limit0, b_limit0, thresh0,
408                 hev, mask);
409    LPF_FILTER4_4W(p1, p0, q0, q1, mask, hev);
410    ILVR_B2_SH(p0, p1, q1, q0, tmp0, tmp1);
411    ILVRL_H2_SH(tmp1, tmp0, tmp2, tmp3);
412    ILVL_B2_SH(p0, p1, q1, q0, tmp0, tmp1);
413    ILVRL_H2_SH(tmp1, tmp0, tmp4, tmp5);
414    src -= 2;
415    ST4x8_UB(tmp2, tmp3, src, stride);
416    src += (8 * stride);
417    ST4x8_UB(tmp4, tmp5, src, stride);
418  }
419  static void HFilter16i(uint8_t* src_y, int stride,
420                         int b_limit, int limit, int thresh) {
421    HFilterVertEdge16i(src_y +  4, stride, b_limit, limit, thresh);
422    HFilterVertEdge16i(src_y +  8, stride, b_limit, limit, thresh);
423    HFilterVertEdge16i(src_y + 12, stride, b_limit, limit, thresh);
424  }
425  static void VFilter8(uint8_t* src_u, uint8_t* src_v, int stride,
426                       int b_limit_in, int limit_in, int thresh_in) {
427    uint8_t* ptmp_src_u = src_u - 4 * stride;
428    uint8_t* ptmp_src_v = src_v - 4 * stride;
429    uint64_t p2_d, p1_d, p0_d, q0_d, q1_d, q2_d;
430    v16u8 p3, p2, p1, p0, q3, q2, q1, q0, mask, hev;
431    v16u8 p3_u, p2_u, p1_u, p0_u, q3_u, q2_u, q1_u, q0_u;
432    v16u8 p3_v, p2_v, p1_v, p0_v, q3_v, q2_v, q1_v, q0_v;
433    const v16u8 b_limit = (v16u8)__msa_fill_b(b_limit_in);
434    const v16u8 limit = (v16u8)__msa_fill_b(limit_in);
435    const v16u8 thresh = (v16u8)__msa_fill_b(thresh_in);
436    LD_UB8(ptmp_src_u, stride, p3_u, p2_u, p1_u, p0_u, q0_u, q1_u, q2_u, q3_u);
437    LD_UB8(ptmp_src_v, stride, p3_v, p2_v, p1_v, p0_v, q0_v, q1_v, q2_v, q3_v);
438    ILVR_D4_UB(p3_v, p3_u, p2_v, p2_u, p1_v, p1_u, p0_v, p0_u, p3, p2, p1, p0);
439    ILVR_D4_UB(q0_v, q0_u, q1_v, q1_u, q2_v, q2_u, q3_v, q3_u, q0, q1, q2, q3);
440    LPF_MASK_HEV(p3, p2, p1, p0, q0, q1, q2, q3, limit, b_limit, thresh,
441                 hev, mask);
442    LPF_MBFILTER(p2, p1, p0, q0, q1, q2, mask, hev);
443    p2_d = __msa_copy_s_d((v2i64)p2, 0);
444    p1_d = __msa_copy_s_d((v2i64)p1, 0);
445    p0_d = __msa_copy_s_d((v2i64)p0, 0);
446    q0_d = __msa_copy_s_d((v2i64)q0, 0);
447    q1_d = __msa_copy_s_d((v2i64)q1, 0);
448    q2_d = __msa_copy_s_d((v2i64)q2, 0);
449    ptmp_src_u += stride;
450    SD4(p2_d, p1_d, p0_d, q0_d, ptmp_src_u, stride);
451    ptmp_src_u += (4 * stride);
452    SD(q1_d, ptmp_src_u);
453    ptmp_src_u += stride;
454    SD(q2_d, ptmp_src_u);
455    p2_d = __msa_copy_s_d((v2i64)p2, 1);
456    p1_d = __msa_copy_s_d((v2i64)p1, 1);
457    p0_d = __msa_copy_s_d((v2i64)p0, 1);
458    q0_d = __msa_copy_s_d((v2i64)q0, 1);
459    q1_d = __msa_copy_s_d((v2i64)q1, 1);
460    q2_d = __msa_copy_s_d((v2i64)q2, 1);
461    ptmp_src_v += stride;
462    SD4(p2_d, p1_d, p0_d, q0_d, ptmp_src_v, stride);
463    ptmp_src_v += (4 * stride);
464    SD(q1_d, ptmp_src_v);
465    ptmp_src_v += stride;
466    SD(q2_d, ptmp_src_v);
467  }
468  static void HFilter8(uint8_t* src_u, uint8_t* src_v, int stride,
469                       int b_limit_in, int limit_in, int thresh_in) {
470    uint8_t* ptmp_src_u = src_u - 4;
471    uint8_t* ptmp_src_v = src_v - 4;
472    v16u8 p3, p2, p1, p0, q3, q2, q1, q0, mask, hev;
473    v16u8 row0, row1, row2, row3, row4, row5, row6, row7, row8;
474    v16u8 row9, row10, row11, row12, row13, row14, row15;
475    v8i16 tmp0, tmp1, tmp2, tmp3, tmp4, tmp5, tmp6, tmp7;
476    const v16u8 b_limit = (v16u8)__msa_fill_b(b_limit_in);
477    const v16u8 limit = (v16u8)__msa_fill_b(limit_in);
478    const v16u8 thresh = (v16u8)__msa_fill_b(thresh_in);
479    LD_UB8(ptmp_src_u, stride, row0, row1, row2, row3, row4, row5, row6, row7);
480    LD_UB8(ptmp_src_v, stride,
481           row8, row9, row10, row11, row12, row13, row14, row15);
482    TRANSPOSE16x8_UB_UB(row0, row1, row2, row3, row4, row5, row6, row7,
483                        row8, row9, row10, row11, row12, row13, row14, row15,
484                        p3, p2, p1, p0, q0, q1, q2, q3);
485    LPF_MASK_HEV(p3, p2, p1, p0, q0, q1, q2, q3, limit, b_limit, thresh,
486                 hev, mask);
487    LPF_MBFILTER(p2, p1, p0, q0, q1, q2, mask, hev);
488    ILVR_B2_SH(p1, p2, q0, p0, tmp0, tmp1);
489    ILVRL_H2_SH(tmp1, tmp0, tmp3, tmp4);
490    ILVL_B2_SH(p1, p2, q0, p0, tmp0, tmp1);
491    ILVRL_H2_SH(tmp1, tmp0, tmp6, tmp7);
492    ILVRL_B2_SH(q2, q1, tmp2, tmp5);
493    ptmp_src_u += 1;
494    ST6x4_UB(tmp3, 0, tmp2, 0, ptmp_src_u, stride);
495    ptmp_src_u += 4 * stride;
496    ST6x4_UB(tmp4, 0, tmp2, 4, ptmp_src_u, stride);
497    ptmp_src_v += 1;
498    ST6x4_UB(tmp6, 0, tmp5, 0, ptmp_src_v, stride);
499    ptmp_src_v += 4 * stride;
500    ST6x4_UB(tmp7, 0, tmp5, 4, ptmp_src_v, stride);
501  }
502  static void VFilter8i(uint8_t* src_u, uint8_t* src_v, int stride,
503                        int b_limit_in, int limit_in, int thresh_in) {
504    uint64_t p1_d, p0_d, q0_d, q1_d;
505    v16u8 p3, p2, p1, p0, q3, q2, q1, q0, mask, hev;
506    v16u8 p3_u, p2_u, p1_u, p0_u, q3_u, q2_u, q1_u, q0_u;
507    v16u8 p3_v, p2_v, p1_v, p0_v, q3_v, q2_v, q1_v, q0_v;
508    const v16u8 thresh = (v16u8)__msa_fill_b(thresh_in);
509    const v16u8 limit = (v16u8)__msa_fill_b(limit_in);
510    const v16u8 b_limit = (v16u8)__msa_fill_b(b_limit_in);
511    LD_UB8(src_u, stride, p3_u, p2_u, p1_u, p0_u, q0_u, q1_u, q2_u, q3_u);
512    src_u += (5 * stride);
513    LD_UB8(src_v, stride, p3_v, p2_v, p1_v, p0_v, q0_v, q1_v, q2_v, q3_v);
514    src_v += (5 * stride);
515    ILVR_D4_UB(p3_v, p3_u, p2_v, p2_u, p1_v, p1_u, p0_v, p0_u, p3, p2, p1, p0);
516    ILVR_D4_UB(q0_v, q0_u, q1_v, q1_u, q2_v, q2_u, q3_v, q3_u, q0, q1, q2, q3);
517    LPF_MASK_HEV(p3, p2, p1, p0, q0, q1, q2, q3, limit, b_limit, thresh,
518                 hev, mask);
519    LPF_FILTER4_4W(p1, p0, q0, q1, mask, hev);
520    p1_d = __msa_copy_s_d((v2i64)p1, 0);
521    p0_d = __msa_copy_s_d((v2i64)p0, 0);
522    q0_d = __msa_copy_s_d((v2i64)q0, 0);
523    q1_d = __msa_copy_s_d((v2i64)q1, 0);
524    SD4(q1_d, q0_d, p0_d, p1_d, src_u, -stride);
525    p1_d = __msa_copy_s_d((v2i64)p1, 1);
526    p0_d = __msa_copy_s_d((v2i64)p0, 1);
527    q0_d = __msa_copy_s_d((v2i64)q0, 1);
528    q1_d = __msa_copy_s_d((v2i64)q1, 1);
529    SD4(q1_d, q0_d, p0_d, p1_d, src_v, -stride);
530  }
531  static void HFilter8i(uint8_t* src_u, uint8_t* src_v, int stride,
532                        int b_limit_in, int limit_in, int thresh_in) {
533    v16u8 p3, p2, p1, p0, q3, q2, q1, q0, mask, hev;
534    v16u8 row0, row1, row2, row3, row4, row5, row6, row7, row8;
535    v16u8 row9, row10, row11, row12, row13, row14, row15;
536    v4i32 tmp0, tmp1, tmp2, tmp3, tmp4, tmp5;
537    const v16u8 thresh = (v16u8)__msa_fill_b(thresh_in);
538    const v16u8 limit = (v16u8)__msa_fill_b(limit_in);
539    const v16u8 b_limit = (v16u8)__msa_fill_b(b_limit_in);
540    LD_UB8(src_u, stride, row0, row1, row2, row3, row4, row5, row6, row7);
541    LD_UB8(src_v, stride,
542           row8, row9, row10, row11, row12, row13, row14, row15);
543    TRANSPOSE16x8_UB_UB(row0, row1, row2, row3, row4, row5, row6, row7,
544                        row8, row9, row10, row11, row12, row13, row14, row15,
545                        p3, p2, p1, p0, q0, q1, q2, q3);
546    LPF_MASK_HEV(p3, p2, p1, p0, q0, q1, q2, q3, limit, b_limit, thresh,
547                 hev, mask);
548    LPF_FILTER4_4W(p1, p0, q0, q1, mask, hev);
549    ILVR_B2_SW(p0, p1, q1, q0, tmp0, tmp1);
550    ILVRL_H2_SW(tmp1, tmp0, tmp2, tmp3);
551    ILVL_B2_SW(p0, p1, q1, q0, tmp0, tmp1);
552    ILVRL_H2_SW(tmp1, tmp0, tmp4, tmp5);
553    src_u += 2;
554    ST4x4_UB(tmp2, tmp2, 0, 1, 2, 3, src_u, stride);
555    src_u += 4 * stride;
556    ST4x4_UB(tmp3, tmp3, 0, 1, 2, 3, src_u, stride);
557    src_v += 2;
558    ST4x4_UB(tmp4, tmp4, 0, 1, 2, 3, src_v, stride);
559    src_v += 4 * stride;
560    ST4x4_UB(tmp5, tmp5, 0, 1, 2, 3, src_v, stride);
561  }
562  static void SimpleVFilter16(uint8_t* src, int stride, int b_limit_in) {
563    v16u8 p1, p0, q1, q0, mask;
564    const v16u8 b_limit = (v16u8)__msa_fill_b(b_limit_in);
565    LD_UB4(src - 2 * stride, stride, p1, p0, q0, q1);
566    LPF_SIMPLE_MASK(p1, p0, q0, q1, b_limit, mask);
567    LPF_SIMPLE_FILT(p1, p0, q0, q1, mask);
568    ST_UB2(p0, q0, src - stride, stride);
569  }
570  static void SimpleHFilter16(uint8_t* src, int stride, int b_limit_in) {
571    v16u8 p1, p0, q1, q0, mask, row0, row1, row2, row3, row4, row5, row6, row7;
572    v16u8 row8, row9, row10, row11, row12, row13, row14, row15;
573    v8i16 tmp0, tmp1;
574    const v16u8 b_limit = (v16u8)__msa_fill_b(b_limit_in);
575    uint8_t* ptemp_src = src - 2;
576    LD_UB8(ptemp_src, stride, row0, row1, row2, row3, row4, row5, row6, row7);
577    LD_UB8(ptemp_src + 8 * stride, stride,
578           row8, row9, row10, row11, row12, row13, row14, row15);
579    TRANSPOSE16x4_UB_UB(row0, row1, row2, row3, row4, row5, row6, row7,
580                        row8, row9, row10, row11, row12, row13, row14, row15,
581                        p1, p0, q0, q1);
582    LPF_SIMPLE_MASK(p1, p0, q0, q1, b_limit, mask);
583    LPF_SIMPLE_FILT(p1, p0, q0, q1, mask);
584    ILVRL_B2_SH(q0, p0, tmp1, tmp0);
585    ptemp_src += 1;
586    ST2x4_UB(tmp1, 0, ptemp_src, stride);
587    ptemp_src += 4 * stride;
588    ST2x4_UB(tmp1, 4, ptemp_src, stride);
589    ptemp_src += 4 * stride;
590    ST2x4_UB(tmp0, 0, ptemp_src, stride);
591    ptemp_src += 4 * stride;
592    ST2x4_UB(tmp0, 4, ptemp_src, stride);
593    ptemp_src += 4 * stride;
594  }
595  static void SimpleVFilter16i(uint8_t* src_y, int stride, int b_limit_in) {
596    SimpleVFilter16(src_y +  4 * stride, stride, b_limit_in);
597    SimpleVFilter16(src_y +  8 * stride, stride, b_limit_in);
598    SimpleVFilter16(src_y + 12 * stride, stride, b_limit_in);
599  }
600  static void SimpleHFilter16i(uint8_t* src_y, int stride, int b_limit_in) {
601    SimpleHFilter16(src_y +  4, stride, b_limit_in);
602    SimpleHFilter16(src_y +  8, stride, b_limit_in);
603    SimpleHFilter16(src_y + 12, stride, b_limit_in);
604  }
605  static void DC4(uint8_t* dst) {   
606    uint32_t dc = 4;
607    int i;
608    for (i = 0; i &lt; 4; ++i) dc += dst[i - BPS] + dst[-1 + i * BPS];
609    dc &gt;&gt;= 3;
610    dc = dc | (dc &lt;&lt; 8) | (dc &lt;&lt; 16) | (dc &lt;&lt; 24);
611    SW4(dc, dc, dc, dc, dst, BPS);
612  }
613  static void TM4(uint8_t* dst) {
614    const uint8_t* const ptemp = dst - BPS - 1;
615    v8i16 T, d, r0, r1, r2, r3;
616    const v16i8 zero = { 0 };
617    const v8i16 TL = (v8i16)__msa_fill_h(ptemp[0 * BPS]);
618    const v8i16 L0 = (v8i16)__msa_fill_h(ptemp[1 * BPS]);
619    const v8i16 L1 = (v8i16)__msa_fill_h(ptemp[2 * BPS]);
620    const v8i16 L2 = (v8i16)__msa_fill_h(ptemp[3 * BPS]);
621    const v8i16 L3 = (v8i16)__msa_fill_h(ptemp[4 * BPS]);
622    const v16u8 T1 = LD_UB(ptemp + 1);
623    T  = (v8i16)__msa_ilvr_b(zero, (v16i8)T1);
624    d = T - TL;
625    ADD4(d, L0, d, L1, d, L2, d, L3, r0, r1, r2, r3);
626    CLIP_SH4_0_255(r0, r1, r2, r3);
627    PCKEV_ST4x4_UB(r0, r1, r2, r3, dst, BPS);
628  }
629  static void VE4(uint8_t* dst) {    
630    const uint8_t* const ptop = dst - BPS - 1;
631    const uint32_t val0 = LW(ptop + 0);
632    const uint32_t val1 = LW(ptop + 4);
633    uint32_t out;
634    v16u8 A = { 0 }, B, C, AC, B2, R;
635    INSERT_W2_UB(val0, val1, A);
636    B = SLDI_UB(A, A, 1);
637    C = SLDI_UB(A, A, 2);
638    AC = __msa_ave_u_b(A, C);
639    B2 = __msa_ave_u_b(B, B);
640    R = __msa_aver_u_b(AC, B2);
641    out = __msa_copy_s_w((v4i32)R, 0);
642    SW4(out, out, out, out, dst, BPS);
643  }
644  static void RD4(uint8_t* dst) {   
645    const uint8_t* const ptop = dst - 1 - BPS;
646    uint32_t val0 = LW(ptop + 0);
647    uint32_t val1 = LW(ptop + 4);
648    uint32_t val2, val3;
649    v16u8 A, B, C, AC, B2, R, A1 = { 0 };
650    INSERT_W2_UB(val0, val1, A1);
651    A = SLDI_UB(A1, A1, 12);
652    A = (v16u8)__msa_insert_b((v16i8)A, 3, ptop[1 * BPS]);
653    A = (v16u8)__msa_insert_b((v16i8)A, 2, ptop[2 * BPS]);
654    A = (v16u8)__msa_insert_b((v16i8)A, 1, ptop[3 * BPS]);
655    A = (v16u8)__msa_insert_b((v16i8)A, 0, ptop[4 * BPS]);
656    B = SLDI_UB(A, A, 1);
657    C = SLDI_UB(A, A, 2);
658    AC = __msa_ave_u_b(A, C);
659    B2 = __msa_ave_u_b(B, B);
660    R = __msa_aver_u_b(AC, B2);
661    val3 = __msa_copy_s_w((v4i32)R, 0);
662    R = SLDI_UB(R, R, 1);
663    val2 = __msa_copy_s_w((v4i32)R, 0);
664    R = SLDI_UB(R, R, 1);
665    val1 = __msa_copy_s_w((v4i32)R, 0);
666    R = SLDI_UB(R, R, 1);
667    val0 = __msa_copy_s_w((v4i32)R, 0);
668    SW4(val0, val1, val2, val3, dst, BPS);
669  }
670  static void LD4(uint8_t* dst) {   
671    const uint8_t* const ptop = dst - BPS;
672    uint32_t val0 = LW(ptop + 0);
673    uint32_t val1 = LW(ptop + 4);
674    uint32_t val2, val3;
675    v16u8 A = { 0 }, B, C, AC, B2, R;
676    INSERT_W2_UB(val0, val1, A);
677    B = SLDI_UB(A, A, 1);
678    C = SLDI_UB(A, A, 2);
679    C = (v16u8)__msa_insert_b((v16i8)C, 6, ptop[7]);
680    AC = __msa_ave_u_b(A, C);
681    B2 = __msa_ave_u_b(B, B);
682    R = __msa_aver_u_b(AC, B2);
683    val0 = __msa_copy_s_w((v4i32)R, 0);
684    R = SLDI_UB(R, R, 1);
685    val1 = __msa_copy_s_w((v4i32)R, 0);
686    R = SLDI_UB(R, R, 1);
687    val2 = __msa_copy_s_w((v4i32)R, 0);
688    R = SLDI_UB(R, R, 1);
689    val3 = __msa_copy_s_w((v4i32)R, 0);
690    SW4(val0, val1, val2, val3, dst, BPS);
691  }
692  static void DC16(uint8_t* dst) {   
693    uint32_t dc = 16;
694    int i;
695    const v16u8 rtop = LD_UB(dst - BPS);
696    const v8u16 dctop = __msa_hadd_u_h(rtop, rtop);
697    v16u8 out;
698    for (i = 0; i &lt; 16; ++i) {
699      dc += dst[-1 + i * BPS];
700    }
701    dc += HADD_UH_U32(dctop);
702    out = (v16u8)__msa_fill_b(dc &gt;&gt; 5);
703    ST_UB8(out, out, out, out, out, out, out, out, dst, BPS);
704    ST_UB8(out, out, out, out, out, out, out, out, dst + 8 * BPS, BPS);
705  }
706  static void TM16(uint8_t* dst) {
707    int j;
708    v8i16 d1, d2;
709    const v16i8 zero = { 0 };
710    const v8i16 TL = (v8i16)__msa_fill_h(dst[-1 - BPS]);
711    const v16i8 T = LD_SB(dst - BPS);
712    ILVRL_B2_SH(zero, T, d1, d2);
713    SUB2(d1, TL, d2, TL, d1, d2);
714    for (j = 0; j &lt; 16; j += 4) {
715      v16i8 t0, t1, t2, t3;
716      v8i16 r0, r1, r2, r3, r4, r5, r6, r7;
717      const v8i16 L0 = (v8i16)__msa_fill_h(dst[-1 + 0 * BPS]);
718      const v8i16 L1 = (v8i16)__msa_fill_h(dst[-1 + 1 * BPS]);
719      const v8i16 L2 = (v8i16)__msa_fill_h(dst[-1 + 2 * BPS]);
720      const v8i16 L3 = (v8i16)__msa_fill_h(dst[-1 + 3 * BPS]);
721      ADD4(d1, L0, d1, L1, d1, L2, d1, L3, r0, r1, r2, r3);
722      ADD4(d2, L0, d2, L1, d2, L2, d2, L3, r4, r5, r6, r7);
723      CLIP_SH4_0_255(r0, r1, r2, r3);
724      CLIP_SH4_0_255(r4, r5, r6, r7);
725      PCKEV_B4_SB(r4, r0, r5, r1, r6, r2, r7, r3, t0, t1, t2, t3);
726      ST_SB4(t0, t1, t2, t3, dst, BPS);
727      dst += 4 * BPS;
728    }
729  }
730  static void VE16(uint8_t* dst) {   
731    const v16u8 rtop = LD_UB(dst - BPS);
732    ST_UB8(rtop, rtop, rtop, rtop, rtop, rtop, rtop, rtop, dst, BPS);
733    ST_UB8(rtop, rtop, rtop, rtop, rtop, rtop, rtop, rtop, dst + 8 * BPS, BPS);
734  }
735  static void HE16(uint8_t* dst) {   
736    int j;
737    for (j = 16; j &gt; 0; j -= 4) {
738      const v16u8 L0 = (v16u8)__msa_fill_b(dst[-1 + 0 * BPS]);
739      const v16u8 L1 = (v16u8)__msa_fill_b(dst[-1 + 1 * BPS]);
740      const v16u8 L2 = (v16u8)__msa_fill_b(dst[-1 + 2 * BPS]);
741      const v16u8 L3 = (v16u8)__msa_fill_b(dst[-1 + 3 * BPS]);
742      ST_UB4(L0, L1, L2, L3, dst, BPS);
743      dst += 4 * BPS;
744    }
745  }
746  static void DC16NoTop(uint8_t* dst) {   
747    int j;
748    uint32_t dc = 8;
749    v16u8 out;
750    for (j = 0; j &lt; 16; ++j) {
751      dc += dst[-1 + j * BPS];
752    }
753    out = (v16u8)__msa_fill_b(dc &gt;&gt; 4);
754    ST_UB8(out, out, out, out, out, out, out, out, dst, BPS);
755    ST_UB8(out, out, out, out, out, out, out, out, dst + 8 * BPS, BPS);
756  }
757  static void DC16NoLeft(uint8_t* dst) {   
758    uint32_t dc = 8;
759    const v16u8 rtop = LD_UB(dst - BPS);
760    const v8u16 dctop = __msa_hadd_u_h(rtop, rtop);
761    v16u8 out;
762    dc += HADD_UH_U32(dctop);
763    out = (v16u8)__msa_fill_b(dc &gt;&gt; 4);
764    ST_UB8(out, out, out, out, out, out, out, out, dst, BPS);
765    ST_UB8(out, out, out, out, out, out, out, out, dst + 8 * BPS, BPS);
766  }
767  static void DC16NoTopLeft(uint8_t* dst) {   
768    const v16u8 out = (v16u8)__msa_fill_b(0x80);
769    ST_UB8(out, out, out, out, out, out, out, out, dst, BPS);
770    ST_UB8(out, out, out, out, out, out, out, out, dst + 8 * BPS, BPS);
771  }
772  #define STORE8x8(out, dst) do {                 \
773    SD4(out, out, out, out, dst + 0 * BPS, BPS);  \
774    SD4(out, out, out, out, dst + 4 * BPS, BPS);  \
775  } while (0)
776  static void DC8uv(uint8_t* dst) {   
777    uint32_t dc = 8;
778    int i;
779    uint64_t out;
780    const v16u8 rtop = LD_UB(dst - BPS);
781    const v8u16 temp0 = __msa_hadd_u_h(rtop, rtop);
782    const v4u32 temp1 = __msa_hadd_u_w(temp0, temp0);
783    const v2u64 temp2 = __msa_hadd_u_d(temp1, temp1);
784    v16u8 dctemp;
785    for (i = 0; i &lt; 8; ++i) {
786      dc += dst[-1 + i * BPS];
787    }
788    dc += __msa_copy_s_w((v4i32)temp2, 0);
789    dctemp = (v16u8)__msa_fill_b(dc &gt;&gt; 4);
790    out = __msa_copy_s_d((v2i64)dctemp, 0);
791    STORE8x8(out, dst);
792  }
793  static void TM8uv(uint8_t* dst) {
794    int j;
795    const v16i8 T1 = LD_SB(dst - BPS);
796    const v16i8 zero = { 0 };
797    const v8i16 T  = (v8i16)__msa_ilvr_b(zero, T1);
798    const v8i16 TL = (v8i16)__msa_fill_h(dst[-1 - BPS]);
799    const v8i16 d = T - TL;
800    for (j = 0; j &lt; 8; j += 4) {
801      v16i8 t0, t1;
802      v8i16 r0 = (v8i16)__msa_fill_h(dst[-1 + 0 * BPS]);
803      v8i16 r1 = (v8i16)__msa_fill_h(dst[-1 + 1 * BPS]);
804      v8i16 r2 = (v8i16)__msa_fill_h(dst[-1 + 2 * BPS]);
805      v8i16 r3 = (v8i16)__msa_fill_h(dst[-1 + 3 * BPS]);
806      ADD4(d, r0, d, r1, d, r2, d, r3, r0, r1, r2, r3);
807      CLIP_SH4_0_255(r0, r1, r2, r3);
808      PCKEV_B2_SB(r1, r0, r3, r2, t0, t1);
809      ST4x4_UB(t0, t1, 0, 2, 0, 2, dst, BPS);
810      ST4x4_UB(t0, t1, 1, 3, 1, 3, dst + 4, BPS);
811      dst += 4 * BPS;
812    }
813  }
814  static void VE8uv(uint8_t* dst) {   
815    const v16u8 rtop = LD_UB(dst - BPS);
816    const uint64_t out = __msa_copy_s_d((v2i64)rtop, 0);
817    STORE8x8(out, dst);
818  }
819  static void HE8uv(uint8_t* dst) {   
820    int j;
821    for (j = 0; j &lt; 8; j += 4) {
822      const v16u8 L0 = (v16u8)__msa_fill_b(dst[-1 + 0 * BPS]);
823      const v16u8 L1 = (v16u8)__msa_fill_b(dst[-1 + 1 * BPS]);
824      const v16u8 L2 = (v16u8)__msa_fill_b(dst[-1 + 2 * BPS]);
825      const v16u8 L3 = (v16u8)__msa_fill_b(dst[-1 + 3 * BPS]);
826      const uint64_t out0 = __msa_copy_s_d((v2i64)L0, 0);
827      const uint64_t out1 = __msa_copy_s_d((v2i64)L1, 0);
828      const uint64_t out2 = __msa_copy_s_d((v2i64)L2, 0);
829      const uint64_t out3 = __msa_copy_s_d((v2i64)L3, 0);
830      SD4(out0, out1, out2, out3, dst, BPS);
831      dst += 4 * BPS;
832    }
833  }
834  static void DC8uvNoLeft(uint8_t* dst) {   
835    const uint32_t dc = 4;
836    const v16u8 rtop = LD_UB(dst - BPS);
837    const v8u16 temp0 = __msa_hadd_u_h(rtop, rtop);
838    const v4u32 temp1 = __msa_hadd_u_w(temp0, temp0);
839    const v2u64 temp2 = __msa_hadd_u_d(temp1, temp1);
840    const uint32_t sum_m = __msa_copy_s_w((v4i32)temp2, 0);
841    const v16u8 dcval = (v16u8)__msa_fill_b((dc + sum_m) &gt;&gt; 3);
842    const uint64_t out = __msa_copy_s_d((v2i64)dcval, 0);
843    STORE8x8(out, dst);
844  }
845  static void DC8uvNoTop(uint8_t* dst) {   
846    uint32_t dc = 4;
847    int i;
848    uint64_t out;
849    v16u8 dctemp;
850    for (i = 0; i &lt; 8; ++i) {
851      dc += dst[-1 + i * BPS];
852    }
853    dctemp = (v16u8)__msa_fill_b(dc &gt;&gt; 3);
854    out = __msa_copy_s_d((v2i64)dctemp, 0);
855    STORE8x8(out, dst);
856  }
857  static void DC8uvNoTopLeft(uint8_t* dst) {   
858    const uint64_t out = 0x8080808080808080ULL;
859    STORE8x8(out, dst);
860  }
861  extern void VP8DspInitMSA(void);
862  WEBP_TSAN_IGNORE_FUNCTION void VP8DspInitMSA(void) {
863    VP8TransformWHT = TransformWHT;
864    VP8Transform = TransformTwo;
865    VP8TransformDC = TransformDC;
866    VP8TransformAC3 = TransformAC3;
867    VP8VFilter16  = VFilter16;
868    VP8HFilter16  = HFilter16;
869    VP8VFilter16i = VFilter16i;
870    VP8HFilter16i = HFilter16i;
871    VP8VFilter8  = VFilter8;
872    VP8HFilter8  = HFilter8;
873    VP8VFilter8i = VFilter8i;
874    VP8HFilter8i = HFilter8i;
875    VP8SimpleVFilter16  = SimpleVFilter16;
876    VP8SimpleHFilter16  = SimpleHFilter16;
877    VP8SimpleVFilter16i = SimpleVFilter16i;
878    VP8SimpleHFilter16i = SimpleHFilter16i;
879    VP8PredLuma4[0] = DC4;
880    VP8PredLuma4[1] = TM4;
881    VP8PredLuma4[2] = VE4;
882    VP8PredLuma4[4] = RD4;
883    VP8PredLuma4[6] = LD4;
884    VP8PredLuma16[0] = DC16;
885    VP8PredLuma16[1] = TM16;
886    VP8PredLuma16[2] = VE16;
887    VP8PredLuma16[3] = HE16;
888    VP8PredLuma16[4] = DC16NoTop;
889    VP8PredLuma16[5] = DC16NoLeft;
890    VP8PredLuma16[6] = DC16NoTopLeft;
891    VP8PredChroma8[0] = DC8uv;
892    VP8PredChroma8[1] = TM8uv;
893    VP8PredChroma8[2] = VE8uv;
894    VP8PredChroma8[3] = HE8uv;
895    VP8PredChroma8[4] = DC8uvNoTop;
896    VP8PredChroma8[5] = DC8uvNoLeft;
897    VP8PredChroma8[6] = DC8uvNoTopLeft;
898  }
899  #else  
900  WEBP_DSP_INIT_STUB(VP8DspInitMSA)
901  #endif  
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from PINRemoteImage-MDEwOlJlcG9zaXRvcnkzOTUzNzEwMw==-flat-dec_msa.c</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from PINRemoteImage-MDEwOlJlcG9zaXRvcnkzOTUzNzEwMw==-flat-dec_msa.c</div>
                </div>
                <div class="column column_space"><pre><code>265    ptmp1 += stride;                                                          \
266    ST6x1_UB(in0, start_in0_idx + 2, in1, start_in1_idx + 2, ptmp1, 4);       \
267    ptmp1 += stride;                                                          \
</pre></code></div>
                <div class="column column_space"><pre><code>267    ptmp1 += stride;                                                          \
268    ST6x1_UB(in0, start_in0_idx + 3, in1, start_in1_idx + 3, ptmp1, 4);       \
269  } while (0)
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    