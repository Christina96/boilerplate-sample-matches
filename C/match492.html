<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for imczmq.c &amp; imtcp.c</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for imczmq.c &amp; imtcp.c
      </h3>
<h1 align="center">
        13.0%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>imczmq.c (22.958057%)<th>imtcp.c (9.130816%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(557-566)<td><a href="#" name="0">(604-610)</a><td align="center"><font color="#ff0000">20</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(448-458)<td><a href="#" name="1">(581-587)</a><td align="center"><font color="#ff0000">20</font>
<tr onclick='openModal("#980517")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#980517"><font color="#980517">-</font><td><a href="#" name="2">(89-96)<td><a href="#" name="2">(192-200)</a><td align="center"><font color="#e50000">18</font>
<tr onclick='openModal("#53858b")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#53858b"><font color="#53858b">-</font><td><a href="#" name="3">(526-553)<td><a href="#" name="3">(552-577)</a><td align="center"><font color="#d80000">17</font>
<tr onclick='openModal("#6cc417")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#6cc417"><font color="#6cc417">-</font><td><a href="#" name="4">(51-61)<td><a href="#" name="4">(217-226)</a><td align="center"><font color="#d80000">17</font>
<tr onclick='openModal("#151b8d")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#151b8d"><font color="#151b8d">-</font><td><a href="#" name="5">(108-114)<td><a href="#" name="5">(361-368)</a><td align="center"><font color="#990000">12</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>imczmq.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 #include "config.h"
2 #include "rsyslog.h"
3 #include &lt;assert.h&gt;
4 #include &lt;errno.h&gt;
5 #include &lt;stdlib.h&gt;
6 #include &lt;string.h&gt;
7 #include &lt;unistd.h&gt;
8 #include "cfsysline.h"
9 #include "dirty.h"
10 #include "errmsg.h"
11 #include "glbl.h"
12 #include "module-template.h"
13 #include "msg.h"
14 #include "net.h"
15 #include "parser.h"
16 #include "prop.h"
17 #include "ruleset.h"
18 #include "srUtils.h"
19 #include "unicode-helper.h"
20 #include &lt;czmq.h&gt;
21 MODULE_TYPE_INPUT
22 MODULE_TYPE_NOKEEP
23 MODULE_CNFNAME("imczmq");
24 DEF_IMOD_STATIC_DATA
25 DEFobjCurrIf(glbl)
26 DEFobjCurrIf(prop)
27 <a name="4"></a>DEFobjCurrIf(ruleset)
28 static struct cnfparamdescr modpdescr[] = {
29 <font color="#6cc417"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>	{ "authenticator", eCmdHdlrBinary, 0 },
30 	{ "authtype", eCmdHdlrString, 0 },
31 	{ "servercertpath", eCmdHdlrString, 0 },
32 	{ "clientcertpath", eCmdHdlrString, 0 },
33 };
34 static struct cnfparamblk modpblk = {
35 	CNFPARAMBLK_VERSION,
36 	sizeof(modpdescr)/sizeof(struct cnfparamdescr),
37 	modpdescr
38 };</b></font>
39 struct modConfData_s {
40 	rsconf_t *pConf;
41 	instanceConf_t *root;
42 	instanceConf_t *tail;
43 	int authenticator;
44 	char *authType;
45 	char *serverCertPath;
46 	char *clientCertPath;
47 };
48 struct instanceConf_s {
49 	bool serverish;
50 	int sockType;
51 	char *sockEndpoints;
52 	char *topics;
53 	uchar *pszBindRuleset;
54 	ruleset_t *pBindRuleset;
55 	struct instanceConf_s *next;
56 };
57 struct listener_t {
58 	zsock_t *sock;
59 	ruleset_t *ruleset;
60 <a name="2"></a>};
61 static zlist_t *listenerList;
62 <font color="#980517"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>static modConfData_t *runModConf = NULL;
63 static prop_t *s_namep = NULL;
64 static struct cnfparamdescr inppdescr[] = {
65 	{ "endpoints", eCmdHdlrGetWord, 1 },
66 	{ "socktype", eCmdHdlrGetWord, 1 },
67 	{ "ruleset", eCmdHdlrGetWord, 0 },
68 	{ "topics", eCmdHdlrGetWord, 0 },</b></font>
69 };
70 #include "im-helper.h"
71 static struct cnfparamblk inppblk = {
72 	CNFPARAMBLK_VERSION,
73 	sizeof(inppdescr) / sizeof(struct cnfparamdescr),
74 	inppdescr
75 <a name="5"></a>};
76 static void setDefaults(instanceConf_t* iconf) {
77 <font color="#151b8d"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>	iconf-&gt;serverish = true;
78 	iconf-&gt;sockType = -1;
79 	iconf-&gt;sockEndpoints = NULL;
80 	iconf-&gt;topics = NULL;
81 	iconf-&gt;pszBindRuleset = NULL;
82 	iconf-&gt;pBindRuleset = NULL;
83 	iconf-&gt;next = NULL;</b></font>
84 };
85 static rsRetVal createInstance(instanceConf_t** pinst) {
86 	DEFiRet;
87 	instanceConf_t* inst;
88 	CHKmalloc(inst = malloc(sizeof(instanceConf_t)));
89 	setDefaults(inst);
90 	if(runModConf-&gt;root == NULL || runModConf-&gt;tail == NULL) {
91 		runModConf-&gt;tail = runModConf-&gt;root = inst;
92 	}
93 	else {
94 		runModConf-&gt;tail-&gt;next = inst;
95 		runModConf-&gt;tail = inst;
96 	}
97 	*pinst = inst;
98 finalize_it:
99 	RETiRet;
100 }
101 static rsRetVal addListener(instanceConf_t* iconf){
102 	DEFiRet;
103 	DBGPRINTF("imczmq: addListener called..\n");
104 	struct listener_t* pData = NULL;
105 	CHKmalloc(pData=(struct listener_t*)malloc(sizeof(struct listener_t)));
106 	pData-&gt;ruleset = iconf-&gt;pBindRuleset;
107 	pData-&gt;sock = zsock_new(iconf-&gt;sockType);
108 	if(!pData-&gt;sock) {
109 		LogError(0, RS_RET_NO_ERRCODE,
110 				"imczmq: new socket failed for endpoints: %s",
111 				iconf-&gt;sockEndpoints);
112 		ABORT_FINALIZE(RS_RET_NO_ERRCODE);
113 	}
114 	DBGPRINTF("imczmq: created socket of type %d..\n", iconf-&gt;sockType);
115 	if(runModConf-&gt;authType) {
116 		if(!strcmp(runModConf-&gt;authType, "CURVESERVER")) {
117 			DBGPRINTF("imczmq: we are a CURVESERVER\n");
118 			zcert_t *serverCert = zcert_load(runModConf-&gt;serverCertPath);
119 			if(!serverCert) {
120 				LogError(0, NO_ERRCODE, "could not load cert %s",
121 					runModConf-&gt;serverCertPath);
122 				ABORT_FINALIZE(RS_RET_ERR);
123 			}
124 			zsock_set_zap_domain(pData-&gt;sock, "global");
125 			zsock_set_curve_server(pData-&gt;sock, 1);
126 			zcert_apply(serverCert, pData-&gt;sock);
127 			zcert_destroy(&amp;serverCert);
128 		}
129 		else if(!strcmp(runModConf-&gt;authType, "CURVECLIENT")) {
130 			DBGPRINTF("imczmq: we are a CURVECLIENT\n");
131 			zcert_t *serverCert = zcert_load(runModConf-&gt;serverCertPath);
132 			if(!serverCert) {
133 				LogError(0, NO_ERRCODE, "could not load cert %s",
134 					runModConf-&gt;serverCertPath);
135 				ABORT_FINALIZE(RS_RET_ERR);
136 			}
137 			const char *server_key = zcert_public_txt(serverCert);
138 			zcert_destroy(&amp;serverCert);
139 			zsock_set_curve_serverkey(pData-&gt;sock, server_key);
140 			zcert_t *clientCert = zcert_load(runModConf-&gt;clientCertPath);
141 			if(!clientCert) {
142 				LogError(0, NO_ERRCODE, "could not load cert %s",
143 					runModConf-&gt;clientCertPath);
144 				ABORT_FINALIZE(RS_RET_ERR);
145 			}
146 			zcert_apply(clientCert, pData-&gt;sock);
147 			zcert_destroy(&amp;clientCert);
148 		}
149 	}
150 	switch(iconf-&gt;sockType) {
151 		case ZMQ_SUB:
152 #if defined(ZMQ_DISH)
153 		case ZMQ_DISH:
154 #endif
155 			iconf-&gt;serverish = false;
156 			break;
157 		case ZMQ_PULL:
158 #if defined(ZMQ_GATHER)
159 		case ZMQ_GATHER:
160 #endif
161 		case ZMQ_ROUTER:
162 #if defined(ZMQ_SERVER)
163 		case ZMQ_SERVER:
164 #endif
165 			iconf-&gt;serverish = true;
166 			break;
167 	}
168 	if(iconf-&gt;topics) {
169 		if(!*iconf-&gt;topics &amp;&amp; iconf-&gt;sockType == ZMQ_SUB) {
170 			DBGPRINTF("imczmq: subscribing to all topics\n");
171 			zsock_set_subscribe(pData-&gt;sock, "");
172 		}
173 		char topic[256];
174 		while(*iconf-&gt;topics) {
175 			char *delimiter = strchr(iconf-&gt;topics, ',');
176 			if(!delimiter) {
177 				delimiter = iconf-&gt;topics + strlen(iconf-&gt;topics);
178 			}
179 			memcpy (topic, iconf-&gt;topics, delimiter - iconf-&gt;topics);
180 			topic[delimiter-iconf-&gt;topics] = 0;
181 			DBGPRINTF("imczmq: subscribing to %s\n", topic);
182 			if(iconf-&gt;sockType == ZMQ_SUB) {
183 				zsock_set_subscribe (pData-&gt;sock, topic);
184 			}
185 #if defined(ZMQ_DISH)
186 			else if(iconf-&gt;sockType == ZMQ_DISH) {
187 				int rc = zsock_join (pData-&gt;sock, topic);
188 				if(rc != 0) {
189 					LogError(0, NO_ERRCODE, "could not join group %s", topic);
190 					ABORT_FINALIZE(RS_RET_ERR);
191 				}
192 			}
193 #endif
194 			if(*delimiter == 0) {
195 				break;
196 			}
197 			iconf-&gt;topics = delimiter + 1;
198 		}
199 	}
200 	int rc = zsock_attach(pData-&gt;sock, (const char*)iconf-&gt;sockEndpoints,
201 			iconf-&gt;serverish);
202 	if (rc == -1) {
203 		LogError(0, NO_ERRCODE, "zsock_attach to %s failed",
204 				iconf-&gt;sockEndpoints);
205 		ABORT_FINALIZE(RS_RET_ERR);
206 	}
207 	DBGPRINTF("imczmq: attached socket to %s\n", iconf-&gt;sockEndpoints);
208 	rc = zlist_append(listenerList, (void *)pData);
209 	if(rc != 0) {
210 		LogError(0, NO_ERRCODE, "could not append listener");
211 		ABORT_FINALIZE(RS_RET_ERR);
212 	}
213 finalize_it:
214 	if(iRet != RS_RET_OK) {
215 		free(pData);
216 	}
217 	RETiRet;
218 }
219 static rsRetVal rcvData(void){
220 	DEFiRet;
221 	if(!listenerList) {
222 		listenerList = zlist_new();
223 		if(!listenerList) {
224 			LogError(0, NO_ERRCODE, "could not allocate list");
225 			ABORT_FINALIZE(RS_RET_ERR);
226 		}
227 	}
228 	zactor_t *authActor = NULL;
229 	if(runModConf-&gt;authenticator == 1) {
230 		authActor = zactor_new(zauth, NULL);
231 		zstr_sendx(authActor, "CURVE", runModConf-&gt;clientCertPath, NULL);
232 		zsock_wait(authActor);
233 	}
234 	instanceConf_t *inst;
235 	for(inst = runModConf-&gt;root; inst != NULL; inst=inst-&gt;next) {
236 		CHKiRet(addListener(inst));
237 	}
238 	zpoller_t *poller = zpoller_new(NULL);
239 	if(!poller) {
240 		LogError(0, NO_ERRCODE, "could not create poller");
241 			ABORT_FINALIZE(RS_RET_ERR);
242 	}
243 	DBGPRINTF("imczmq: created poller\n");
244 	struct listener_t *pData;
245 	pData = zlist_first(listenerList);
246 	if(!pData) {
247 		LogError(0, NO_ERRCODE, "imczmq: no listeners were "
248 						"started, input not activated.\n");
249 		ABORT_FINALIZE(RS_RET_NO_RUN);
250 	}
251 	while(pData) {
252 		int rc = zpoller_add(poller, pData-&gt;sock);
253 		if(rc != 0) {
254 			LogError(0, NO_ERRCODE, "imczmq: could not add "
255 						"socket to poller, input not activated.\n");
256 			ABORT_FINALIZE(RS_RET_NO_RUN);
257 		}
258 		pData = zlist_next(listenerList);
259 	}
260 	zsock_t *which = (zsock_t *)zpoller_wait(poller, -1);
261 	while(which) {
262 		if (zpoller_terminated(poller)) {
263 				break;
264 		}
265 		pData = zlist_first(listenerList);
266 		while(pData-&gt;sock != which) {
267 			pData = zlist_next(listenerList);
268 		}
269 		if(which == pData-&gt;sock) {
270 			DBGPRINTF("imczmq: found matching socket\n");
271 		}
272 		zframe_t *frame = zframe_recv(which);
273 		char *buf = NULL;
274 		if (frame != NULL)
275 			buf = zframe_strdup(frame);
276 		zframe_destroy(&amp;frame);
277 		if(buf == NULL) {
278 			DBGPRINTF("imczmq: null buffer\n");
279 			continue;
280 		}
281 		smsg_t *pMsg;
282 		if(msgConstruct(&amp;pMsg) == RS_RET_OK) {
283 			MsgSetRawMsg(pMsg, buf, strlen(buf));
284 			MsgSetInputName(pMsg, s_namep);
285 			MsgSetHOSTNAME(pMsg, glbl.GetLocalHostName(), ustrlen(glbl.GetLocalHostName()));
286 			MsgSetRcvFrom(pMsg, glbl.GetLocalHostNameProp());
287 			MsgSetRcvFromIP(pMsg, glbl.GetLocalHostIP());
288 			MsgSetMSGoffs(pMsg, 0);
289 			MsgSetFlowControlType(pMsg, eFLOWCTL_NO_DELAY);
290 			MsgSetRuleset(pMsg, pData-&gt;ruleset);
291 			pMsg-&gt;msgFlags = NEEDS_PARSING | PARSE_HOSTNAME;
292 			submitMsg2(pMsg);
293 		}
294 		free(buf);
295 		which = (zsock_t *)zpoller_wait(poller, -1);
296 	}
297 finalize_it:
298 	zpoller_destroy(&amp;poller);
299 	pData = zlist_first(listenerList);
300 	while(pData) {
301 		zsock_destroy(&amp;pData-&gt;sock);
302 		free(pData-&gt;ruleset);
303 		pData = zlist_next(listenerList);
304 	}
305 	zlist_destroy(&amp;listenerList);
306 	zactor_destroy(&amp;authActor);
307 	RETiRet;
308 }
309 BEGINrunInput
310 CODESTARTrunInput
311 	iRet = rcvData();
312 ENDrunInput
313 BEGINwillRun
314 CODESTARTwillRun
315 	CHKiRet(prop.Construct(&amp;s_namep));
316 	CHKiRet(prop.SetString(s_namep,
317 		UCHAR_CONSTANT("imczmq"),
318 		sizeof("imczmq") - 1));
319 	CHKiRet(prop.ConstructFinalize(s_namep));
320 finalize_it:
321 ENDwillRun
322 BEGINafterRun
323 CODESTARTafterRun
324 	if(s_namep != NULL) {
325 		prop.Destruct(&amp;s_namep);
326 	}
327 ENDafterRun
328 BEGINmodExit
329 CODESTARTmodExit
330 	objRelease(glbl, CORE_COMPONENT);
331 	objRelease(prop, CORE_COMPONENT);
332 	objRelease(ruleset, CORE_COMPONENT);
333 ENDmodExit
334 BEGINisCompatibleWithFeature
335 CODESTARTisCompatibleWithFeature
336 	if(eFeat == sFEATURENonCancelInputTermination) {
337 		iRet = RS_RET_OK;
338 	}
339 ENDisCompatibleWithFeature
340 BEGINbeginCnfLoad
341 CODESTARTbeginCnfLoad
342 	runModConf = pModConf;
343 	runModConf-&gt;pConf = pConf;
344 	runModConf-&gt;authenticator = 0;
345 	runModConf-&gt;authType = NULL;
346 	runModConf-&gt;serverCertPath = NULL;
347 	runModConf-&gt;clientCertPath = NULL;
348 ENDbeginCnfLoad
349 BEGINsetModCnf
350 	struct cnfparamvals* pvals = NULL;
351 	int i;
352 CODESTARTsetModCnf
353 	pvals = nvlstGetParams(lst, &amp;modpblk, NULL);
354 	if(NULL == pvals) {
355 		LogError(0, RS_RET_MISSING_CNFPARAMS,
356 				"imczmq: error processing module "
357 				"config parameters ['module(...)']");
358 		ABORT_FINALIZE(RS_RET_MISSING_CNFPARAMS);
359 	}
360 	for(i=0; i &lt; modpblk.nParams; ++i) {
361 		if(!pvals[i].bUsed) {
362 			continue;
363 <a name="1"></a>		}
364 		if(!strcmp(modpblk.descr[i].name, "authenticator")) {
365 			runModConf-&gt;authenticator = (int)pvals[i].val.d.n;
366 <font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>		}
367 		else if(!strcmp(modpblk.descr[i].name, "authtype")) {
368 			runModConf-&gt;authType = es_str2cstr(pvals[i].val.d.estr, NULL);
369 		}
370 		else if(!strcmp(modpblk.descr[i].name, "servercertpath")) {
371 			runModConf-&gt;serverCertPath = es_str2cstr(pvals[i].val.d.estr, NULL);
372 		}
373 		else if(!strcmp(modpblk.descr[i].name, "clientcertpath")) {
374 			runModConf-&gt;clientCertPath = es_str2cstr(pvals[i].val.d.estr, NULL);
375 		}
376 		else {</b></font>
377 			LogError(0, RS_RET_INVALID_PARAMS,
378 						"imczmq: config error, unknown "
379 						"param %s in setModCnf\n",
380 						modpblk.descr[i].name);
381 		}
382 	}
383 	DBGPRINTF("imczmq: authenticator set to %d\n", runModConf-&gt;authenticator);
384 	DBGPRINTF("imczmq: authType set to %s\n", runModConf-&gt;authType);
385 	DBGPRINTF("imczmq: serverCertPath set to %s\n", runModConf-&gt;serverCertPath);
386 	DBGPRINTF("imczmq: clientCertPath set to %s\n", runModConf-&gt;clientCertPath);
387 finalize_it:
388 	if(pvals != NULL) {
389 		cnfparamvalsDestruct(pvals, &amp;modpblk);
390 	}
391 ENDsetModCnf
392 BEGINendCnfLoad
393 CODESTARTendCnfLoad
394 ENDendCnfLoad
395 static inline void
396 std_checkRuleset_genErrMsg(__attribute__((unused)) modConfData_t *modConf, instanceConf_t *inst)
397 {
398 	LogError(0, NO_ERRCODE,
399 			"imczmq: ruleset '%s' for socket %s not found - "
400 			"using default ruleset instead", inst-&gt;pszBindRuleset,
401 			inst-&gt;sockEndpoints);
402 }
403 BEGINcheckCnf
404 instanceConf_t* inst;
405 CODESTARTcheckCnf
406 	for(inst = pModConf-&gt;root; inst!=NULL; inst=inst-&gt;next) {
407 		std_checkRuleset(pModConf, inst);
408 	}
409 ENDcheckCnf
410 BEGINactivateCnfPrePrivDrop
411 CODESTARTactivateCnfPrePrivDrop
412 	runModConf = pModConf;
413 	putenv((char*)"ZSYS_SIGHANDLER=false");
414 ENDactivateCnfPrePrivDrop
415 BEGINactivateCnf
416 CODESTARTactivateCnf
417 ENDactivateCnf
418 BEGINfreeCnf
419 	instanceConf_t *inst, *inst_r;
420 CODESTARTfreeCnf
421 	free(pModConf-&gt;authType);
422 	free(pModConf-&gt;serverCertPath);
423 	free(pModConf-&gt;clientCertPath);
424 	for (inst = pModConf-&gt;root ; inst != NULL ; ) {
425 		free(inst-&gt;pszBindRuleset);
426 		free(inst-&gt;sockEndpoints);
427 <a name="3"></a>		inst_r = inst;
428 		inst = inst-&gt;next;
429 		free(inst_r);
430 <font color="#53858b"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>	}
431 ENDfreeCnf
432 BEGINnewInpInst
433 	struct cnfparamvals* pvals;
434 	instanceConf_t* inst;
435 	int i;
436 CODESTARTnewInpInst
437 	DBGPRINTF("newInpInst (imczmq)\n");
438 	pvals = nvlstGetParams(lst, &amp;inppblk, NULL);
439 	if(NULL==pvals) {
440 		LogError(0, RS_RET_MISSING_CNFPARAMS,
441 						"imczmq: required parameters are missing\n");
442 		ABORT_FINALIZE(RS_RET_MISSING_CNFPARAMS);
443 	}
444 	if(Debug) {
445 		DBGPRINTF("imczmq: input param blk:\n");
446 		cnfparamsPrint(&amp;inppblk, pvals);
447 	}
448 	CHKiRet(createInstance(&amp;inst));
449 	for(i = 0 ; i &lt; inppblk.nParams ; ++i) {
450 		if(!pvals[i].bUsed) {</b></font>
451 <a name="0"></a>			continue;
452 		}
453 <font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>		if(!strcmp(inppblk.descr[i].name, "ruleset")) {
454 			inst-&gt;pszBindRuleset = (uchar *)es_str2cstr(pvals[i].val.d.estr, NULL);
455 		}
456 		else if(!strcmp(inppblk.descr[i].name, "endpoints")) {
457 			inst-&gt;sockEndpoints = es_str2cstr(pvals[i].val.d.estr, NULL);
458 		}
459 		else if(!strcmp(inppblk.descr[i].name, "topics")) {
460 			inst-&gt;topics = es_str2cstr(pvals[i].val.d.estr, NULL);
461 		}
462 		else if(!strcmp(inppblk.descr[i].name, "socktype")){</b></font>
463 			char *stringType = es_str2cstr(pvals[i].val.d.estr, NULL);
464 			if( NULL == stringType ){
465 				LogError(0, RS_RET_CONFIG_ERROR,
466 					"imczmq: out of memory error copying sockType param");
467 				ABORT_FINALIZE(RS_RET_OUT_OF_MEMORY);
468 			}
469 			if(!strcmp("PULL", stringType)) {
470 				inst-&gt;sockType = ZMQ_PULL;
471 			}
472 #if defined(ZMQ_GATHER)
473 			else if(!strcmp("GATHER", stringType)) {
474 				inst-&gt;sockType = ZMQ_GATHER;
475 			}
476 #endif
477 			else if(!strcmp("SUB", stringType)) {
478 				inst-&gt;sockType = ZMQ_SUB;
479 			}
480 #if defined(ZMQ_DISH)
481 			else if(!strcmp("DISH", stringType)) {
482 				inst-&gt;sockType = ZMQ_DISH;
483 			}
484 #endif
485 			else if(!strcmp("ROUTER", stringType)) {
486 				inst-&gt;sockType = ZMQ_ROUTER;
487 			}
488 #if defined(ZMQ_SERVER)
489 			else if(!strcmp("SERVER", stringType)) {
490 				inst-&gt;sockType = ZMQ_SERVER;
491 			}
492 #endif
493 			free(stringType);
494 		}
495 		else {
496 			LogError(0, NO_ERRCODE,
497 					"imczmq: program error, non-handled "
498 					"param '%s'\n", inppblk.descr[i].name);
499 		}
500 	}
501 finalize_it:
502 CODE_STD_FINALIZERnewInpInst
503 	cnfparamvalsDestruct(pvals, &amp;inppblk);
504 ENDnewInpInst
505 BEGINqueryEtryPt
506 CODESTARTqueryEtryPt
507 CODEqueryEtryPt_STD_IMOD_QUERIES
508 CODEqueryEtryPt_STD_CONF2_QUERIES
509 CODEqueryEtryPt_STD_CONF2_setModCnf_QUERIES
510 CODEqueryEtryPt_STD_CONF2_PREPRIVDROP_QUERIES
511 CODEqueryEtryPt_STD_CONF2_IMOD_QUERIES
512 CODEqueryEtryPt_IsCompatibleWithFeature_IF_OMOD_QUERIES
513 ENDqueryEtryPt
514 BEGINmodInit()
515 CODESTARTmodInit
516 	*ipIFVersProvided = CURR_MOD_IF_VERSION;
517 CODEmodInit_QueryRegCFSLineHdlr
518 	CHKiRet(objUse(glbl, CORE_COMPONENT));
519 	CHKiRet(objUse(prop, CORE_COMPONENT));
520 	CHKiRet(objUse(ruleset, CORE_COMPONENT));
521 ENDmodInit
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>imtcp.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 #include "config.h"
2 #include &lt;stdlib.h&gt;
3 #include &lt;assert.h&gt;
4 #include &lt;string.h&gt;
5 #include &lt;errno.h&gt;
6 #include &lt;unistd.h&gt;
7 #include &lt;stdarg.h&gt;
8 #include &lt;ctype.h&gt;
9 #include &lt;netinet/in.h&gt;
10 #include &lt;netdb.h&gt;
11 #include &lt;signal.h&gt;
12 #include &lt;sys/types.h&gt;
13 #include &lt;sys/socket.h&gt;
14 #if HAVE_FCNTL_H
15 #include &lt;fcntl.h&gt;
16 #endif
17 #include "rsyslog.h"
18 #include "dirty.h"
19 #include "cfsysline.h"
20 #include "module-template.h"
21 #include "unicode-helper.h"
22 #include "net.h"
23 #include "netstrm.h"
24 #include "errmsg.h"
25 #include "tcpsrv.h"
26 #include "ruleset.h"
27 #include "rainerscript.h"
28 #include "net.h"
29 #include "parserif.h"
30 MODULE_TYPE_INPUT
31 MODULE_TYPE_NOKEEP
32 MODULE_CNFNAME("imtcp")
33 DEF_IMOD_STATIC_DATA
34 DEFobjCurrIf(tcpsrv)
35 DEFobjCurrIf(tcps_sess)
36 DEFobjCurrIf(net)
37 DEFobjCurrIf(netstrm)
38 DEFobjCurrIf(ruleset)
39 static rsRetVal resetConfigVariables(uchar __attribute__((unused)) *pp, void __attribute__((unused)) *pVal);
40 typedef struct tcpsrv_etry_s {
41 	tcpsrv_t *tcpsrv;
42 	pthread_t tid;		struct tcpsrv_etry_s *next;
43 } tcpsrv_etry_t;
44 static tcpsrv_etry_t *tcpsrv_root = NULL;
45 static int n_tcpsrv = 0;
46 static permittedPeers_t *pPermPeersRoot = NULL;
47 #define FRAMING_UNSET -1
48 static struct configSettings_s {
49 	int iTCPSessMax;
50 	int iTCPLstnMax;
51 	int bSuppOctetFram;
52 	int iStrmDrvrMode;
53 	int bKeepAlive;
54 	int iKeepAliveIntvl;
55 	int iKeepAliveProbes;
56 	int iKeepAliveTime;
57 	int bEmitMsgOnClose;
58 	int iAddtlFrameDelim;
59 	int maxFrameSize;
60 	int bDisableLFDelim;
61 	int discardTruncatedMsg;
62 	int bUseFlowControl;
63 	int bPreserveCase;
64 	uchar *gnutlsPriorityString;
65 	uchar *pszStrmDrvrAuthMode;
66 	uchar *pszStrmDrvrPermitExpiredCerts;
67 	uchar *pszInputName;
68 	uchar *pszBindRuleset;
69 	uchar *lstnIP;				uchar *lstnPortFile;
70 } cs;
71 struct instanceConf_s {
72 	int iTCPSessMax;
73 	int iTCPLstnMax;
74 	uchar *pszBindRuleset;			ruleset_t *pBindRuleset;		uchar *pszInputName;			uchar *dfltTZ;
75 	sbool bSPFramingFix;
76 	unsigned int ratelimitInterval;
77 	unsigned int ratelimitBurst;
78 	int iAddtlFrameDelim; 	int maxFrameSize;
79 	int bUseFlowControl;
80 	int bDisableLFDelim;
81 	int discardTruncatedMsg;
82 	int bEmitMsgOnClose;
83 	int bPreserveCase;
84 	uchar *pszStrmDrvrName; 	int iStrmDrvrMode;
85 	uchar *pszStrmDrvrAuthMode;
86 	uchar *pszStrmDrvrPermitExpiredCerts;
87 	uchar *pszStrmDrvrCAFile;
88 	uchar *pszStrmDrvrKeyFile;
89 	uchar *pszStrmDrvrCertFile;
90 	permittedPeers_t *pPermPeersRoot;
91 	uchar *gnutlsPriorityString;
92 	int iStrmDrvrExtendedCertCheck;
93 	int iStrmDrvrSANPreference;
94 	int iStrmTlsVerifyDepth;
95 	int bKeepAlive;
96 	int iKeepAliveIntvl;
97 	int iKeepAliveProbes;
98 	int iKeepAliveTime;
99 	struct instanceConf_s *next;
100 };
101 struct modConfData_s {
102 	rsconf_t *pConf;			instanceConf_t *root, *tail;
103 	int iAddtlFrameDelim; 	int maxFrameSize;
104 	int bSuppOctetFram;
105 	sbool bDisableLFDelim; 	sbool discardTruncatedMsg;
106 	sbool bUseFlowControl; 	sbool bKeepAlive;
107 	int iKeepAliveIntvl;
108 	int iKeepAliveProbes;
109 	int iKeepAliveTime;
110 	sbool bEmitMsgOnClose; 	uchar *gnutlsPriorityString;
111 	uchar *pszStrmDrvrName; 	uchar *pszStrmDrvrAuthMode; 	uchar *pszStrmDrvrPermitExpiredCerts; 	uchar *pszStrmDrvrCAFile;
112 	uchar *pszStrmDrvrKeyFile;
113 	uchar *pszStrmDrvrCertFile;
114 	permittedPeers_t *pPermPeersRoot;
115 	sbool configSetViaV2Method;
116 <a name="2"></a>	sbool bPreserveCase; };
117 <font color="#980517"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>static modConfData_t *loadModConf = NULL;static modConfData_t *runModConf = NULL;
118 static struct cnfparamdescr modpdescr[] = {
119 	{ "flowcontrol", eCmdHdlrBinary, 0 },
120 	{ "disablelfdelimiter", eCmdHdlrBinary, 0 },
121 	{ "discardtruncatedmsg", eCmdHdlrBinary, 0 },
122 	{ "octetcountedframing", eCmdHdlrBinary, 0 },</b></font>
123 	{ "notifyonconnectionclose", eCmdHdlrBinary, 0 },
124 	{ "addtlframedelimiter", eCmdHdlrNonNegInt, 0 },
125 	{ "maxframesize", eCmdHdlrInt, 0 },
126 	{ "maxsessions", eCmdHdlrPositiveInt, 0 },
127 	{ "maxlistners", eCmdHdlrPositiveInt, 0 },
128 	{ "maxlisteners", eCmdHdlrPositiveInt, 0 },
129 	{ "streamdriver.mode", eCmdHdlrNonNegInt, 0 },
130 	{ "streamdriver.authmode", eCmdHdlrString, 0 },
131 	{ "streamdriver.permitexpiredcerts", eCmdHdlrString, 0 },
132 	{ "streamdriver.name", eCmdHdlrString, 0 },
133 	{ "streamdriver.CheckExtendedKeyPurpose", eCmdHdlrBinary, 0 },
134 	{ "streamdriver.PrioritizeSAN", eCmdHdlrBinary, 0 },
135 	{ "streamdriver.TlsVerifyDepth", eCmdHdlrPositiveInt, 0 },
136 <a name="4"></a>	{ "permittedpeer", eCmdHdlrArray, 0 },
137 	{ "keepalive", eCmdHdlrBinary, 0 },
138 	{ "keepalive.probes", eCmdHdlrNonNegInt, 0 },
139 <font color="#6cc417"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>	{ "keepalive.time", eCmdHdlrNonNegInt, 0 },
140 	{ "keepalive.interval", eCmdHdlrNonNegInt, 0 },
141 	{ "gnutlsprioritystring", eCmdHdlrString, 0 },
142 	{ "preservecase", eCmdHdlrBinary, 0 }
143 };
144 static struct cnfparamblk modpblk =
145 	{ CNFPARAMBLK_VERSION,
146 	  sizeof(modpdescr)/sizeof(struct cnfparamdescr),
147 	  modpdescr
148 	};</b></font>
149 static struct cnfparamdescr inppdescr[] = {
150 	{ "port", eCmdHdlrString, CNFPARAM_REQUIRED }, 	{ "maxsessions", eCmdHdlrPositiveInt, 0 },
151 	{ "maxlisteners", eCmdHdlrPositiveInt, 0 },
152 	{ "flowcontrol", eCmdHdlrBinary, 0 },
153 	{ "disablelfdelimiter", eCmdHdlrBinary, 0 },
154 	{ "discardtruncatedmsg", eCmdHdlrBinary, 0 },
155 	{ "notifyonconnectionclose", eCmdHdlrBinary, 0 },
156 	{ "addtlframedelimiter", eCmdHdlrNonNegInt, 0 },
157 	{ "maxframesize", eCmdHdlrInt, 0 },
158 	{ "preservecase", eCmdHdlrBinary, 0 },
159 	{ "listenportfilename", eCmdHdlrString, 0 },
160 	{ "address", eCmdHdlrString, 0 },
161 	{ "name", eCmdHdlrString, 0 },
162 	{ "defaulttz", eCmdHdlrString, 0 },
163 	{ "ruleset", eCmdHdlrString, 0 },
164 	{ "streamdriver.mode", eCmdHdlrNonNegInt, 0 },
165 	{ "streamdriver.authmode", eCmdHdlrString, 0 },
166 	{ "streamdriver.permitexpiredcerts", eCmdHdlrString, 0 },
167 	{ "streamdriver.name", eCmdHdlrString, 0 },
168 	{ "streamdriver.CheckExtendedKeyPurpose", eCmdHdlrBinary, 0 },
169 	{ "streamdriver.PrioritizeSAN", eCmdHdlrBinary, 0 },
170 	{ "streamdriver.TlsVerifyDepth", eCmdHdlrPositiveInt, 0 },
171 	{ "streamdriver.cafile", eCmdHdlrString, 0 },
172 	{ "streamdriver.keyfile", eCmdHdlrString, 0 },
173 	{ "streamdriver.certfile", eCmdHdlrString, 0 },
174 	{ "permittedpeer", eCmdHdlrArray, 0 },
175 	{ "gnutlsprioritystring", eCmdHdlrString, 0 },
176 	{ "keepalive", eCmdHdlrBinary, 0 },
177 	{ "keepalive.probes", eCmdHdlrNonNegInt, 0 },
178 	{ "keepalive.time", eCmdHdlrNonNegInt, 0 },
179 	{ "keepalive.interval", eCmdHdlrNonNegInt, 0 },
180 	{ "supportoctetcountedframing", eCmdHdlrBinary, 0 },
181 	{ "ratelimit.interval", eCmdHdlrInt, 0 },
182 	{ "framingfix.cisco.asa", eCmdHdlrBinary, 0 },
183 	{ "ratelimit.burst", eCmdHdlrInt, 0 }
184 };
185 static struct cnfparamblk inppblk =
186 	{ CNFPARAMBLK_VERSION,
187 	  sizeof(inppdescr)/sizeof(struct cnfparamdescr),
188 	  inppdescr
189 	};
190 #include "im-helper.h" 
191 static int bLegacyCnfModGlobalsPermitted;
192 static int
193 isPermittedHost(struct sockaddr *addr, char *fromHostFQDN, void __attribute__((unused)) *pUsrSrv,
194 	        void __attribute__((unused)) *pUsrSess)
195 {
196 	return net.isAllowedSender2(UCHAR_CONSTANT("TCP"), addr, fromHostFQDN, 1);
197 }
198 static rsRetVal
199 doOpenLstnSocks(tcpsrv_t *pSrv)
200 {
201 	ISOBJ_TYPE_assert(pSrv, tcpsrv);
202 	dbgprintf("in imtcp doOpenLstnSocks\n");
203 	return tcpsrv.create_tcp_socket(pSrv);
204 }
205 static rsRetVal
206 doRcvData(tcps_sess_t *pSess, char *buf, size_t lenBuf, ssize_t *piLenRcvd, int *const oserr)
207 {
208 	assert(pSess != NULL);
209 	assert(piLenRcvd != NULL);
210 	*piLenRcvd = lenBuf;
211 	return netstrm.Rcv(pSess-&gt;pStrm, (uchar*) buf, piLenRcvd, oserr);
212 }
213 static rsRetVal
214 onRegularClose(tcps_sess_t *pSess)
215 {
216 	DEFiRet;
217 	assert(pSess != NULL);
218 	tcps_sess.PrepareClose(pSess);
219 	tcps_sess.Close(pSess);
220 	RETiRet;
221 }
222 static rsRetVal
223 onErrClose(tcps_sess_t *pSess)
224 {
225 	DEFiRet;
226 	assert(pSess != NULL);
227 	tcps_sess.Close(pSess);
228 	RETiRet;
229 }
230 static rsRetVal
231 setPermittedPeer(void __attribute__((unused)) *pVal, uchar *pszID)
232 {
233 	DEFiRet;
234 	CHKiRet(net.AddPermittedPeer(&amp;pPermPeersRoot, pszID));
235 	free(pszID); finalize_it:
236 	RETiRet;
237 }
238 static rsRetVal
239 createInstance(instanceConf_t **pinst)
240 {
241 	instanceConf_t *inst = NULL;
242 	DEFiRet;
243 	CHKmalloc(inst = (instanceConf_t*) calloc(1, sizeof(instanceConf_t)));
244 	CHKmalloc(inst-&gt;cnf_params = (tcpLstnParams_t*) calloc(1, sizeof(tcpLstnParams_t)));
245 	inst-&gt;next = NULL;
246 	inst-&gt;pszBindRuleset = NULL;
247 	inst-&gt;pszInputName = NULL;
248 <a name="5"></a>	inst-&gt;dfltTZ = NULL;
249 	inst-&gt;cnf_params-&gt;bSuppOctetFram = -1; 	inst-&gt;bSPFramingFix = 0;
250 <font color="#151b8d"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>	inst-&gt;ratelimitInterval = 0;
251 	inst-&gt;ratelimitBurst = 10000;
252 	inst-&gt;pszStrmDrvrName = NULL;
253 	inst-&gt;pszStrmDrvrAuthMode = NULL;
254 	inst-&gt;pszStrmDrvrPermitExpiredCerts = NULL;
255 	inst-&gt;pszStrmDrvrCAFile = NULL;
256 	inst-&gt;pszStrmDrvrKeyFile = NULL;</b></font>
257 	inst-&gt;pszStrmDrvrCertFile = NULL;
258 	inst-&gt;pPermPeersRoot = NULL;
259 	inst-&gt;gnutlsPriorityString = NULL;
260 	inst-&gt;iStrmDrvrMode = loadModConf-&gt;iStrmDrvrMode;
261 	inst-&gt;iStrmDrvrExtendedCertCheck = loadModConf-&gt;iStrmDrvrExtendedCertCheck;
262 	inst-&gt;iStrmDrvrSANPreference = loadModConf-&gt;iStrmDrvrSANPreference;
263 	inst-&gt;iStrmTlsVerifyDepth = loadModConf-&gt;iStrmTlsVerifyDepth;
264 	inst-&gt;bKeepAlive = loadModConf-&gt;bKeepAlive;
265 	inst-&gt;iKeepAliveIntvl = loadModConf-&gt;iKeepAliveIntvl;
266 	inst-&gt;iKeepAliveProbes = loadModConf-&gt;iKeepAliveProbes;
267 	inst-&gt;iKeepAliveTime = loadModConf-&gt;iKeepAliveTime;
268 	inst-&gt;iAddtlFrameDelim = loadModConf-&gt;iAddtlFrameDelim;
269 	inst-&gt;maxFrameSize = loadModConf-&gt;maxFrameSize;
270 	inst-&gt;bUseFlowControl = loadModConf-&gt;bUseFlowControl;
271 	inst-&gt;bDisableLFDelim = loadModConf-&gt;bDisableLFDelim;
272 	inst-&gt;discardTruncatedMsg = loadModConf-&gt;discardTruncatedMsg;
273 	inst-&gt;bEmitMsgOnClose = loadModConf-&gt;bEmitMsgOnClose;
274 	inst-&gt;bPreserveCase = loadModConf-&gt;bPreserveCase;
275 	inst-&gt;iTCPLstnMax = loadModConf-&gt;iTCPLstnMax;
276 	inst-&gt;iTCPSessMax = loadModConf-&gt;iTCPSessMax;
277 	inst-&gt;cnf_params-&gt;pszLstnPortFileName = NULL;
278 	if(loadModConf-&gt;tail == NULL) {
279 		loadModConf-&gt;tail = loadModConf-&gt;root = inst;
280 	} else {
281 		loadModConf-&gt;tail-&gt;next = inst;
282 		loadModConf-&gt;tail = inst;
283 	}
284 	*pinst = inst;
285 finalize_it:
286 	if(iRet != RS_RET_OK) {
287 		free(inst-&gt;cnf_params);
288 		free(inst);
289 	}
290 	RETiRet;
291 }
292 static rsRetVal addInstance(void __attribute__((unused)) *pVal, uchar *pNewVal)
293 {
294 	instanceConf_t *inst;
295 	DEFiRet;
296 	CHKiRet(createInstance(&amp;inst));
297 	CHKmalloc(inst-&gt;cnf_params-&gt;pszPort = ustrdup((pNewVal == NULL || *pNewVal == '\0')
298 				 	       ? (uchar*) "10514" : pNewVal));
299 	if((cs.pszBindRuleset == NULL) || (cs.pszBindRuleset[0] == '\0')) {
300 		inst-&gt;pszBindRuleset = NULL;
301 	} else {
302 		CHKmalloc(inst-&gt;pszBindRuleset = ustrdup(cs.pszBindRuleset));
303 	}
304 	if((cs.lstnIP == NULL) || (cs.lstnIP[0] == '\0')) {
305 		inst-&gt;cnf_params-&gt;pszAddr = NULL;
306 	} else {
307 		CHKmalloc(inst-&gt;cnf_params-&gt;pszAddr = ustrdup(cs.lstnIP));
308 	}
309 	if((cs.lstnPortFile == NULL) || (cs.lstnPortFile[0] == '\0')) {
310 		inst-&gt;cnf_params-&gt;pszLstnPortFileName = NULL;
311 	} else {
312 		CHKmalloc(inst-&gt;cnf_params-&gt;pszLstnPortFileName = ustrdup(cs.lstnPortFile));
313 	}
314 	if((cs.pszInputName == NULL) || (cs.pszInputName[0] == '\0')) {
315 		inst-&gt;pszInputName = NULL;
316 	} else {
317 		CHKmalloc(inst-&gt;pszInputName = ustrdup(cs.pszInputName));
318 	}
319 	inst-&gt;cnf_params-&gt;bSuppOctetFram = cs.bSuppOctetFram;
320 finalize_it:
321 	free(pNewVal);
322 	RETiRet;
323 }
324 static rsRetVal
325 addListner(modConfData_t *modConf, instanceConf_t *inst)
326 {
327 	DEFiRet;
328 	uchar *psz;		permittedPeers_t *peers;
329 	tcpsrv_t *pOurTcpsrv;
330 	CHKiRet(tcpsrv.Construct(&amp;pOurTcpsrv));
331 	CHKiRet(tcpsrv.SetCBIsPermittedHost(pOurTcpsrv, isPermittedHost));
332 	CHKiRet(tcpsrv.SetCBRcvData(pOurTcpsrv, doRcvData));
333 	CHKiRet(tcpsrv.SetCBOpenLstnSocks(pOurTcpsrv, doOpenLstnSocks));
334 	CHKiRet(tcpsrv.SetCBOnRegularClose(pOurTcpsrv, onRegularClose));
335 	CHKiRet(tcpsrv.SetCBOnErrClose(pOurTcpsrv, onErrClose));
336 	CHKiRet(tcpsrv.SetKeepAlive(pOurTcpsrv, inst-&gt;bKeepAlive));
337 	CHKiRet(tcpsrv.SetKeepAliveIntvl(pOurTcpsrv, inst-&gt;iKeepAliveIntvl));
338 	CHKiRet(tcpsrv.SetKeepAliveProbes(pOurTcpsrv, inst-&gt;iKeepAliveProbes));
339 	CHKiRet(tcpsrv.SetKeepAliveTime(pOurTcpsrv, inst-&gt;iKeepAliveTime));
340 	CHKiRet(tcpsrv.SetSessMax(pOurTcpsrv, inst-&gt;iTCPSessMax));
341 	CHKiRet(tcpsrv.SetLstnMax(pOurTcpsrv, inst-&gt;iTCPLstnMax));
342 	CHKiRet(tcpsrv.SetDrvrMode(pOurTcpsrv, inst-&gt;iStrmDrvrMode));
343 	CHKiRet(tcpsrv.SetDrvrCheckExtendedKeyUsage(pOurTcpsrv, inst-&gt;iStrmDrvrExtendedCertCheck));
344 	CHKiRet(tcpsrv.SetDrvrPrioritizeSAN(pOurTcpsrv, inst-&gt;iStrmDrvrSANPreference));
345 	CHKiRet(tcpsrv.SetDrvrTlsVerifyDepth(pOurTcpsrv, inst-&gt;iStrmTlsVerifyDepth));
346 	CHKiRet(tcpsrv.SetUseFlowControl(pOurTcpsrv, inst-&gt;bUseFlowControl));
347 	CHKiRet(tcpsrv.SetAddtlFrameDelim(pOurTcpsrv, inst-&gt;iAddtlFrameDelim));
348 	CHKiRet(tcpsrv.SetMaxFrameSize(pOurTcpsrv, inst-&gt;maxFrameSize));
349 	CHKiRet(tcpsrv.SetbDisableLFDelim(pOurTcpsrv, inst-&gt;bDisableLFDelim));
350 	CHKiRet(tcpsrv.SetDiscardTruncatedMsg(pOurTcpsrv, inst-&gt;discardTruncatedMsg));
351 	CHKiRet(tcpsrv.SetNotificationOnRemoteClose(pOurTcpsrv, inst-&gt;bEmitMsgOnClose));
352 	CHKiRet(tcpsrv.SetPreserveCase(pOurTcpsrv, inst-&gt;bPreserveCase));
353 	psz = (inst-&gt;pszStrmDrvrName == NULL) ? modConf-&gt;pszStrmDrvrName : inst-&gt;pszStrmDrvrName;
354 	if(psz != NULL) {
355 		CHKiRet(tcpsrv.SetDrvrName(pOurTcpsrv, psz));
356 	}
357 	psz = (inst-&gt;pszStrmDrvrAuthMode == NULL) ? modConf-&gt;pszStrmDrvrAuthMode : inst-&gt;pszStrmDrvrAuthMode;
358 	if(psz != NULL) {
359 		CHKiRet(tcpsrv.SetDrvrAuthMode(pOurTcpsrv, psz));
360 	}
361 	psz = (inst-&gt;gnutlsPriorityString == NULL)
362 			? modConf-&gt;gnutlsPriorityString : inst-&gt;gnutlsPriorityString;
363 	CHKiRet(tcpsrv.SetGnutlsPriorityString(pOurTcpsrv, psz));
364 	psz = (inst-&gt;pszStrmDrvrPermitExpiredCerts == NULL)
365 			? modConf-&gt;pszStrmDrvrPermitExpiredCerts : inst-&gt;pszStrmDrvrPermitExpiredCerts;
366 	CHKiRet(tcpsrv.SetDrvrPermitExpiredCerts(pOurTcpsrv, psz));
367 	psz = (inst-&gt;pszStrmDrvrCAFile == NULL)
368 			? modConf-&gt;pszStrmDrvrCAFile : inst-&gt;pszStrmDrvrCAFile;
369 	CHKiRet(tcpsrv.SetDrvrCAFile(pOurTcpsrv, psz));
370 	psz = (inst-&gt;pszStrmDrvrKeyFile == NULL)
371 			? modConf-&gt;pszStrmDrvrKeyFile : inst-&gt;pszStrmDrvrKeyFile;
372 	CHKiRet(tcpsrv.SetDrvrKeyFile(pOurTcpsrv, psz));
373 	psz = (inst-&gt;pszStrmDrvrCertFile == NULL)
374 			? modConf-&gt;pszStrmDrvrCertFile : inst-&gt;pszStrmDrvrCertFile;
375 	CHKiRet(tcpsrv.SetDrvrCertFile(pOurTcpsrv, psz));
376 	peers = (inst-&gt;pPermPeersRoot == NULL)
377 			? modConf-&gt;pPermPeersRoot : inst-&gt;pPermPeersRoot;
378 	if(peers != NULL) {
379 			CHKiRet(tcpsrv.SetDrvrPermPeers(pOurTcpsrv, peers));
380 	}
381 	DBGPRINTF("imtcp: trying to add port *:%s\n", inst-&gt;cnf_params-&gt;pszPort);
382 	inst-&gt;cnf_params-&gt;pRuleset = inst-&gt;pBindRuleset;
383 	CHKiRet(tcpsrv.SetInputName(pOurTcpsrv, inst-&gt;cnf_params, inst-&gt;pszInputName == NULL ?
384 						UCHAR_CONSTANT("imtcp") : inst-&gt;pszInputName));
385 	CHKiRet(tcpsrv.SetOrigin(pOurTcpsrv, (uchar*)"imtcp"));
386 	CHKiRet(tcpsrv.SetDfltTZ(pOurTcpsrv, (inst-&gt;dfltTZ == NULL) ? (uchar*)"" : inst-&gt;dfltTZ));
387 	CHKiRet(tcpsrv.SetbSPFramingFix(pOurTcpsrv, inst-&gt;bSPFramingFix));
388 	CHKiRet(tcpsrv.SetLinuxLikeRatelimiters(pOurTcpsrv, inst-&gt;ratelimitInterval, inst-&gt;ratelimitBurst));
389 	if((ustrcmp(inst-&gt;cnf_params-&gt;pszPort, UCHAR_CONSTANT("0")) == 0
390 		&amp;&amp; inst-&gt;cnf_params-&gt;pszLstnPortFileName == NULL)
391 			|| ustrcmp(inst-&gt;cnf_params-&gt;pszPort, UCHAR_CONSTANT("0")) &lt; 0) {
392 		LogMsg(0, RS_RET_OK, LOG_WARNING, "imtcp: port 0 and no port file set -&gt; using port 514 instead");
393 		CHKmalloc(inst-&gt;cnf_params-&gt;pszPort = (uchar*)strdup("514"));
394 	}
395 	tcpsrv.configureTCPListen(pOurTcpsrv, inst-&gt;cnf_params);
396 	tcpsrv_etry_t *etry;
397 	CHKmalloc(etry = (tcpsrv_etry_t*) calloc(1, sizeof(tcpsrv_etry_t)));
398 	etry-&gt;tcpsrv = pOurTcpsrv;
399 	etry-&gt;next = tcpsrv_root;
400 	tcpsrv_root = etry;
401 	++n_tcpsrv;
402 finalize_it:
403 	if(iRet != RS_RET_OK) {
404 <a name="3"></a>		LogError(0, NO_ERRCODE, "imtcp: error %d trying to add listener", iRet);
405 	}
406 	RETiRet;
407 <font color="#53858b"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>}
408 BEGINnewInpInst
409 	struct cnfparamvals *pvals;
410 	instanceConf_t *inst;
411 	int i;
412 CODESTARTnewInpInst
413 	DBGPRINTF("newInpInst (imtcp)\n");
414 	pvals = nvlstGetParams(lst, &amp;inppblk, NULL);
415 	if(pvals == NULL) {
416 		LogError(0, RS_RET_MISSING_CNFPARAMS,
417 			        "imtcp: required parameter are missing\n");
418 		ABORT_FINALIZE(RS_RET_MISSING_CNFPARAMS);
419 	}
420 	if(Debug) {
421 		dbgprintf("input param blk in imtcp:\n");
422 		cnfparamsPrint(&amp;inppblk, pvals);
423 	}
424 	CHKiRet(createInstance(&amp;inst));
425 	for(i = 0 ; i &lt; inppblk.nParams ; ++i) {
426 		if(!pvals[i].bUsed)</b></font>
427 <a name="1"></a>			continue;
428 		if(!strcmp(inppblk.descr[i].name, "port")) {
429 			inst-&gt;cnf_params-&gt;pszPort = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
430 <font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>		} else if(!strcmp(inppblk.descr[i].name, "address")) {
431 			inst-&gt;cnf_params-&gt;pszAddr = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
432 		} else if(!strcmp(inppblk.descr[i].name, "name")) {
433 			inst-&gt;pszInputName = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
434 		} else if(!strcmp(inppblk.descr[i].name, "defaulttz")) {
435 			inst-&gt;dfltTZ = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
436 		} else if(!strcmp(inppblk.descr[i].name, "framingfix.cisco.asa")) {</b></font>
437 			inst-&gt;bSPFramingFix = (int) pvals[i].val.d.n;
438 		} else if(!strcmp(inppblk.descr[i].name, "ruleset")) {
439 			inst-&gt;pszBindRuleset = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
440 		} else if(!strcmp(inppblk.descr[i].name, "streamdriver.mode")) {
441 			inst-&gt;iStrmDrvrMode = (int) pvals[i].val.d.n;
442 		} else if(!strcmp(inppblk.descr[i].name, "streamdriver.CheckExtendedKeyPurpose")) {
443 			inst-&gt;iStrmDrvrExtendedCertCheck = (int) pvals[i].val.d.n;
444 		} else if(!strcmp(inppblk.descr[i].name, "streamdriver.PrioritizeSAN")) {
445 			inst-&gt;iStrmDrvrSANPreference = (int) pvals[i].val.d.n;
446 		} else if(!strcmp(inppblk.descr[i].name, "streamdriver.TlsVerifyDepth")) {
447 			if (pvals[i].val.d.n &gt;= 2) {
448 				inst-&gt;iStrmTlsVerifyDepth = (int) pvals[i].val.d.n;
449 			} else {
450 <a name="0"></a>				parser_errmsg("streamdriver.TlsVerifyDepth must be 2 or higher but is %d",
451 									(int) pvals[i].val.d.n);
452 			}
453 <font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>		} else if(!strcmp(inppblk.descr[i].name, "streamdriver.authmode")) {
454 			inst-&gt;pszStrmDrvrAuthMode = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
455 		} else if(!strcmp(inppblk.descr[i].name, "streamdriver.permitexpiredcerts")) {
456 			inst-&gt;pszStrmDrvrPermitExpiredCerts = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
457 		} else if(!strcmp(inppblk.descr[i].name, "streamdriver.cafile")) {
458 			inst-&gt;pszStrmDrvrCAFile = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
459 		} else if(!strcmp(inppblk.descr[i].name, "streamdriver.keyfile")) {</b></font>
460 			inst-&gt;pszStrmDrvrKeyFile = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
461 		} else if(!strcmp(inppblk.descr[i].name, "streamdriver.certfile")) {
462 			inst-&gt;pszStrmDrvrCertFile = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
463 		} else if(!strcmp(inppblk.descr[i].name, "streamdriver.name")) {
464 			inst-&gt;pszStrmDrvrName = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
465 		} else if(!strcmp(inppblk.descr[i].name, "gnutlsprioritystring")) {
466 			inst-&gt;gnutlsPriorityString = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
467 		} else if(!strcmp(inppblk.descr[i].name, "permittedpeer")) {
468 			for(int j = 0 ; j &lt;  pvals[i].val.d.ar-&gt;nmemb ; ++j) {
469 				uchar *const peer = (uchar*) es_str2cstr(pvals[i].val.d.ar-&gt;arr[j], NULL);
470 				CHKiRet(net.AddPermittedPeer(&amp;inst-&gt;pPermPeersRoot, peer));
471 				free(peer);
472 			}
473 		} else if(!strcmp(inppblk.descr[i].name, "flowcontrol")) {
474 			inst-&gt;bUseFlowControl = (int) pvals[i].val.d.n;
475 		} else if(!strcmp(inppblk.descr[i].name, "disablelfdelimiter")) {
476 			inst-&gt;bDisableLFDelim = (int) pvals[i].val.d.n;
477 		} else if(!strcmp(inppblk.descr[i].name, "discardtruncatedmsg")) {
478 			inst-&gt;discardTruncatedMsg = (int) pvals[i].val.d.n;
479 		} else if(!strcmp(inppblk.descr[i].name, "notifyonconnectionclose")) {
480 			inst-&gt;bEmitMsgOnClose = (int) pvals[i].val.d.n;
481 		} else if(!strcmp(inppblk.descr[i].name, "addtlframedelimiter")) {
482 			inst-&gt;iAddtlFrameDelim = (int) pvals[i].val.d.n;
483 		} else if(!strcmp(inppblk.descr[i].name, "maxframesize")) {
484 			const int max = (int) pvals[i].val.d.n;
485 			if(max &lt;= 200000000) {
486 				inst-&gt;maxFrameSize = max;
487 			} else {
488 				LogError(0, RS_RET_PARAM_ERROR, "imtcp: invalid value for 'maxFrameSize' "
489 						"parameter given is %d, max is 200000000", max);
490 				ABORT_FINALIZE(RS_RET_PARAM_ERROR);
491 			}
492 		} else if(!strcmp(inppblk.descr[i].name, "maxsessions")) {
493 			inst-&gt;iTCPSessMax = (int) pvals[i].val.d.n;
494 		} else if(!strcmp(inppblk.descr[i].name, "maxlisteners")) {
495 			inst-&gt;iTCPLstnMax = (int) pvals[i].val.d.n;
496 		} else if(!strcmp(inppblk.descr[i].name, "supportoctetcountedframing")) {
497 			inst-&gt;cnf_params-&gt;bSuppOctetFram = (int) pvals[i].val.d.n;
498 		} else if(!strcmp(inppblk.descr[i].name, "keepalive")) {
499 			inst-&gt;bKeepAlive = (int) pvals[i].val.d.n;
500 		} else if(!strcmp(inppblk.descr[i].name, "keepalive.probes")) {
501 			inst-&gt;iKeepAliveProbes = (int) pvals[i].val.d.n;
502 		} else if(!strcmp(inppblk.descr[i].name, "keepalive.time")) {
503 			inst-&gt;iKeepAliveTime = (int) pvals[i].val.d.n;
504 		} else if(!strcmp(inppblk.descr[i].name, "keepalive.interval")) {
505 			inst-&gt;iKeepAliveIntvl = (int) pvals[i].val.d.n;
506 		} else if(!strcmp(inppblk.descr[i].name, "ratelimit.burst")) {
507 			inst-&gt;ratelimitBurst = (unsigned int) pvals[i].val.d.n;
508 		} else if(!strcmp(inppblk.descr[i].name, "ratelimit.interval")) {
509 			inst-&gt;ratelimitInterval = (unsigned int) pvals[i].val.d.n;
510 		} else if(!strcmp(inppblk.descr[i].name, "preservecase")) {
511 			inst-&gt;bPreserveCase = (int) pvals[i].val.d.n;
512 		} else if(!strcmp(inppblk.descr[i].name, "listenportfilename")) {
513 			inst-&gt;cnf_params-&gt;pszLstnPortFileName = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
514 		} else {
515 			dbgprintf("imtcp: program error, non-handled "
516 			  "param '%s'\n", inppblk.descr[i].name);
517 		}
518 	}
519 finalize_it:
520 CODE_STD_FINALIZERnewInpInst
521 	cnfparamvalsDestruct(pvals, &amp;inppblk);
522 ENDnewInpInst
523 BEGINbeginCnfLoad
524 CODESTARTbeginCnfLoad
525 	loadModConf = pModConf;
526 	pModConf-&gt;pConf = pConf;
527 	loadModConf-&gt;iTCPSessMax = 200;
528 	loadModConf-&gt;iTCPLstnMax = 20;
529 	loadModConf-&gt;bSuppOctetFram = 1;
530 	loadModConf-&gt;iStrmDrvrMode = 0;
531 	loadModConf-&gt;iStrmDrvrExtendedCertCheck = 0;
532 	loadModConf-&gt;iStrmDrvrSANPreference = 0;
533 	loadModConf-&gt;iStrmTlsVerifyDepth = 0;
534 	loadModConf-&gt;bUseFlowControl = 1;
535 	loadModConf-&gt;bKeepAlive = 0;
536 	loadModConf-&gt;iKeepAliveIntvl = 0;
537 	loadModConf-&gt;iKeepAliveProbes = 0;
538 	loadModConf-&gt;iKeepAliveTime = 0;
539 	loadModConf-&gt;bEmitMsgOnClose = 0;
540 	loadModConf-&gt;iAddtlFrameDelim = TCPSRV_NO_ADDTL_DELIMITER;
541 	loadModConf-&gt;maxFrameSize = 200000;
542 	loadModConf-&gt;bDisableLFDelim = 0;
543 	loadModConf-&gt;discardTruncatedMsg = 0;
544 	loadModConf-&gt;gnutlsPriorityString = NULL;
545 	loadModConf-&gt;pszStrmDrvrName = NULL;
546 	loadModConf-&gt;pszStrmDrvrAuthMode = NULL;
547 	loadModConf-&gt;pszStrmDrvrPermitExpiredCerts = NULL;
548 	loadModConf-&gt;pszStrmDrvrCAFile = NULL;
549 	loadModConf-&gt;pszStrmDrvrKeyFile = NULL;
550 	loadModConf-&gt;pszStrmDrvrCertFile = NULL;
551 	loadModConf-&gt;pPermPeersRoot = NULL;
552 	loadModConf-&gt;configSetViaV2Method = 0;
553 	loadModConf-&gt;bPreserveCase = 1; 	bLegacyCnfModGlobalsPermitted = 1;
554 	resetConfigVariables(NULL, NULL); ENDbeginCnfLoad
555 BEGINsetModCnf
556 	struct cnfparamvals *pvals = NULL;
557 	int i;
558 CODESTARTsetModCnf
559 	pvals = nvlstGetParams(lst, &amp;modpblk, NULL);
560 	if(pvals == NULL) {
561 		LogError(0, RS_RET_MISSING_CNFPARAMS, "imtcp: error processing module "
562 				"config parameters [module(...)]");
563 		ABORT_FINALIZE(RS_RET_MISSING_CNFPARAMS);
564 	}
565 	if(Debug) {
566 		dbgprintf("module (global) param blk for imtcp:\n");
567 		cnfparamsPrint(&amp;modpblk, pvals);
568 	}
569 	for(i = 0 ; i &lt; modpblk.nParams ; ++i) {
570 		if(!pvals[i].bUsed)
571 			continue;
572 		if(!strcmp(modpblk.descr[i].name, "flowcontrol")) {
573 			loadModConf-&gt;bUseFlowControl = (int) pvals[i].val.d.n;
574 		} else if(!strcmp(modpblk.descr[i].name, "disablelfdelimiter")) {
575 			loadModConf-&gt;bDisableLFDelim = (int) pvals[i].val.d.n;
576 		} else if(!strcmp(modpblk.descr[i].name, "discardtruncatedmsg")) {
577 			loadModConf-&gt;discardTruncatedMsg = (int) pvals[i].val.d.n;
578 		} else if(!strcmp(modpblk.descr[i].name, "octetcountedframing")) {
579 			loadModConf-&gt;bSuppOctetFram = (int) pvals[i].val.d.n;
580 		} else if(!strcmp(modpblk.descr[i].name, "notifyonconnectionclose")) {
581 			loadModConf-&gt;bEmitMsgOnClose = (int) pvals[i].val.d.n;
582 		} else if(!strcmp(modpblk.descr[i].name, "addtlframedelimiter")) {
583 			loadModConf-&gt;iAddtlFrameDelim = (int) pvals[i].val.d.n;
584 		} else if(!strcmp(modpblk.descr[i].name, "maxframesize")) {
585 			const int max = (int) pvals[i].val.d.n;
586 			if(max &lt;= 200000000) {
587 				loadModConf-&gt;maxFrameSize = max;
588 			} else {
589 				LogError(0, RS_RET_PARAM_ERROR, "imtcp: invalid value for 'maxFrameSize' "
590 						"parameter given is %d, max is 200000000", max);
591 				ABORT_FINALIZE(RS_RET_PARAM_ERROR);
592 			}
593 		} else if(!strcmp(modpblk.descr[i].name, "maxsessions")) {
594 			loadModConf-&gt;iTCPSessMax = (int) pvals[i].val.d.n;
595 		} else if(!strcmp(modpblk.descr[i].name, "maxlisteners") ||
596 			  !strcmp(modpblk.descr[i].name, "maxlistners")) { 			loadModConf-&gt;iTCPLstnMax = (int) pvals[i].val.d.n;
597 		} else if(!strcmp(modpblk.descr[i].name, "keepalive")) {
598 			loadModConf-&gt;bKeepAlive = (int) pvals[i].val.d.n;
599 		} else if(!strcmp(modpblk.descr[i].name, "keepalive.probes")) {
600 			loadModConf-&gt;iKeepAliveProbes = (int) pvals[i].val.d.n;
601 		} else if(!strcmp(modpblk.descr[i].name, "keepalive.time")) {
602 			loadModConf-&gt;iKeepAliveTime = (int) pvals[i].val.d.n;
603 		} else if(!strcmp(modpblk.descr[i].name, "keepalive.interval")) {
604 			loadModConf-&gt;iKeepAliveIntvl = (int) pvals[i].val.d.n;
605 		} else if(!strcmp(modpblk.descr[i].name, "gnutlsprioritystring")) {
606 			loadModConf-&gt;gnutlsPriorityString = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
607 		} else if(!strcmp(modpblk.descr[i].name, "streamdriver.mode")) {
608 			loadModConf-&gt;iStrmDrvrMode = (int) pvals[i].val.d.n;
609 		} else if(!strcmp(modpblk.descr[i].name, "streamdriver.CheckExtendedKeyPurpose")) {
610 			loadModConf-&gt;iStrmDrvrExtendedCertCheck = (int) pvals[i].val.d.n;
611 		} else if(!strcmp(modpblk.descr[i].name, "streamdriver.PrioritizeSAN")) {
612 			loadModConf-&gt;iStrmDrvrSANPreference = (int) pvals[i].val.d.n;
613 		} else if(!strcmp(modpblk.descr[i].name, "streamdriver.TlsVerifyDepth")) {
614 			if (pvals[i].val.d.n &gt;= 2) {
615 				loadModConf-&gt;iStrmTlsVerifyDepth = (int) pvals[i].val.d.n;
616 			} else {
617 				parser_errmsg("streamdriver.TlsVerifyDepth must be 2 or higher but is %d",
618 									(int) pvals[i].val.d.n);
619 			}
620 		} else if(!strcmp(modpblk.descr[i].name, "streamdriver.authmode")) {
621 			loadModConf-&gt;pszStrmDrvrAuthMode = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
622 		} else if(!strcmp(modpblk.descr[i].name, "streamdriver.permitexpiredcerts")) {
623 			loadModConf-&gt;pszStrmDrvrPermitExpiredCerts = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
624 		} else if(!strcmp(modpblk.descr[i].name, "streamdriver.cafile")) {
625 			loadModConf-&gt;pszStrmDrvrCAFile = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
626 		} else if(!strcmp(modpblk.descr[i].name, "streamdriver.keyfile")) {
627 			loadModConf-&gt;pszStrmDrvrKeyFile = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
628 		} else if(!strcmp(modpblk.descr[i].name, "streamdriver.certfile")) {
629 			loadModConf-&gt;pszStrmDrvrCertFile = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
630 		} else if(!strcmp(modpblk.descr[i].name, "streamdriver.name")) {
631 			loadModConf-&gt;pszStrmDrvrName = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
632 		} else if(!strcmp(modpblk.descr[i].name, "permittedpeer")) {
633 			for(int j = 0 ; j &lt;  pvals[i].val.d.ar-&gt;nmemb ; ++j) {
634 				uchar *const peer = (uchar*) es_str2cstr(pvals[i].val.d.ar-&gt;arr[j], NULL);
635 				CHKiRet(net.AddPermittedPeer(&amp;loadModConf-&gt;pPermPeersRoot, peer));
636 				free(peer);
637 			}
638 		} else if(!strcmp(modpblk.descr[i].name, "preservecase")) {
639 			loadModConf-&gt;bPreserveCase = (int) pvals[i].val.d.n;
640 		} else {
641 			dbgprintf("imtcp: program error, non-handled "
642 			  "param '%s' in beginCnfLoad\n", modpblk.descr[i].name);
643 		}
644 	}
645 	bLegacyCnfModGlobalsPermitted = 0;
646 	loadModConf-&gt;configSetViaV2Method = 1;
647 finalize_it:
648 	if(pvals != NULL)
649 		cnfparamvalsDestruct(pvals, &amp;modpblk);
650 ENDsetModCnf
651 BEGINendCnfLoad
652 CODESTARTendCnfLoad
653 	if(!loadModConf-&gt;configSetViaV2Method) {
654 		pModConf-&gt;iTCPSessMax = cs.iTCPSessMax;
655 		pModConf-&gt;iTCPLstnMax = cs.iTCPLstnMax;
656 		pModConf-&gt;iStrmDrvrMode = cs.iStrmDrvrMode;
657 		pModConf-&gt;bEmitMsgOnClose = cs.bEmitMsgOnClose;
658 		pModConf-&gt;bSuppOctetFram = cs.bSuppOctetFram;
659 		pModConf-&gt;iAddtlFrameDelim = cs.iAddtlFrameDelim;
660 		pModConf-&gt;maxFrameSize = cs.maxFrameSize;
661 		pModConf-&gt;bDisableLFDelim = cs.bDisableLFDelim;
662 		pModConf-&gt;bUseFlowControl = cs.bUseFlowControl;
663 		pModConf-&gt;bKeepAlive = cs.bKeepAlive;
664 		pModConf-&gt;iKeepAliveProbes = cs.iKeepAliveProbes;
665 		pModConf-&gt;iKeepAliveIntvl = cs.iKeepAliveIntvl;
666 		pModConf-&gt;iKeepAliveTime = cs.iKeepAliveTime;
667 		if(pPermPeersRoot != NULL) {
668 			assert(pModConf-&gt;pPermPeersRoot == NULL);
669 			pModConf-&gt;pPermPeersRoot = pPermPeersRoot;
670 			pPermPeersRoot = NULL; 		}
671 		if((cs.pszStrmDrvrAuthMode == NULL) || (cs.pszStrmDrvrAuthMode[0] == '\0')) {
672 			loadModConf-&gt;pszStrmDrvrAuthMode = NULL;
673 		} else {
674 			loadModConf-&gt;pszStrmDrvrAuthMode = cs.pszStrmDrvrAuthMode;
675 			cs.pszStrmDrvrAuthMode = NULL;
676 		}
677 		pModConf-&gt;bPreserveCase = cs.bPreserveCase;
678 	}
679 	free(cs.pszStrmDrvrAuthMode);
680 	cs.pszStrmDrvrAuthMode = NULL;
681 	loadModConf = NULL; ENDendCnfLoad
682 static inline void
683 std_checkRuleset_genErrMsg(__attribute__((unused)) modConfData_t *modConf, instanceConf_t *inst)
684 {
685 	LogError(0, NO_ERRCODE, "imtcp: ruleset '%s' for port %s not found - "
686 			"using default ruleset instead", inst-&gt;pszBindRuleset,
687 			inst-&gt;cnf_params-&gt;pszPort);
688 }
689 BEGINcheckCnf
690 	instanceConf_t *inst;
691 CODESTARTcheckCnf
692 	for(inst = pModConf-&gt;root ; inst != NULL ; inst = inst-&gt;next) {
693 		std_checkRuleset(pModConf, inst);
694 		if(inst-&gt;cnf_params-&gt;bSuppOctetFram == FRAMING_UNSET)
695 			inst-&gt;cnf_params-&gt;bSuppOctetFram = pModConf-&gt;bSuppOctetFram;
696 	}
697 	if(pModConf-&gt;root == NULL) {
698 		LogError(0, RS_RET_NO_LISTNERS , "imtcp: module loaded, but "
699 				"no listeners defined - no input will be gathered");
700 		iRet = RS_RET_NO_LISTNERS;
701 	}
702 ENDcheckCnf
703 BEGINactivateCnfPrePrivDrop
704 	instanceConf_t *inst;
705 CODESTARTactivateCnfPrePrivDrop
706 	runModConf = pModConf;
707 	for(inst = runModConf-&gt;root ; inst != NULL ; inst = inst-&gt;next) {
708 		addListner(runModConf, inst);
709 	}
710 	if(tcpsrv_root == NULL)
711 		ABORT_FINALIZE(RS_RET_NO_RUN);
712 	tcpsrv_etry_t *etry = tcpsrv_root;
713 	while(etry != NULL) {
714 		CHKiRet(tcpsrv.ConstructFinalize(etry-&gt;tcpsrv));
715 		etry = etry-&gt;next;
716 	}
717 finalize_it:
718 ENDactivateCnfPrePrivDrop
719 BEGINactivateCnf
720 CODESTARTactivateCnf
721 ENDactivateCnf
722 BEGINfreeCnf
723 	instanceConf_t *inst, *del;
724 CODESTARTfreeCnf
725 	free(pModConf-&gt;gnutlsPriorityString);
726 	free(pModConf-&gt;pszStrmDrvrName);
727 	free(pModConf-&gt;pszStrmDrvrAuthMode);
728 	free(pModConf-&gt;pszStrmDrvrPermitExpiredCerts);
729 	free(pModConf-&gt;pszStrmDrvrCAFile);
730 	free(pModConf-&gt;pszStrmDrvrKeyFile);
731 	free(pModConf-&gt;pszStrmDrvrCertFile);
732 	if(pModConf-&gt;pPermPeersRoot != NULL) {
733 		net.DestructPermittedPeers(&amp;pModConf-&gt;pPermPeersRoot);
734 	}
735 	for(inst = pModConf-&gt;root ; inst != NULL ; ) {
736 		free((void*)inst-&gt;pszBindRuleset);
737 		free((void*)inst-&gt;pszStrmDrvrAuthMode);
738 		free((void*)inst-&gt;pszStrmDrvrName);
739 		free((void*)inst-&gt;pszStrmDrvrPermitExpiredCerts);
740 		free((void*)inst-&gt;pszStrmDrvrCAFile);
741 		free((void*)inst-&gt;pszStrmDrvrKeyFile);
742 		free((void*)inst-&gt;pszStrmDrvrCertFile);
743 		free((void*)inst-&gt;gnutlsPriorityString);
744 		free((void*)inst-&gt;pszInputName);
745 		free((void*)inst-&gt;dfltTZ);
746 		if(inst-&gt;pPermPeersRoot != NULL) {
747 			net.DestructPermittedPeers(&amp;inst-&gt;pPermPeersRoot);
748 		}
749 		del = inst;
750 		inst = inst-&gt;next;
751 		free(del);
752 	}
753 ENDfreeCnf
754 static void *
755 RunServerThread(void *myself)
756 {
757 	tcpsrv_etry_t *const etry = (tcpsrv_etry_t*) myself;
758 	rsRetVal iRet;
759 	dbgprintf("RGER: running ety %p\n", etry);
760 	iRet = tcpsrv.Run(etry-&gt;tcpsrv);
761 	if(iRet != RS_RET_OK) {
762 		LogError(0, iRet, "imtcp: error while terminating server; rsyslog may hang on shutdown");
763 	}
764 	return NULL;
765 }
766 static void
767 startSrvWrkr(tcpsrv_etry_t *const etry)
768 {
769 	int r;
770 	pthread_attr_t sessThrdAttr;
771 	sigset_t sigSet, sigSetSave;
772 	sigfillset(&amp;sigSet);
773 	sigdelset(&amp;sigSet, SIGTTIN);
774 	sigdelset(&amp;sigSet, SIGSEGV);
775 	pthread_sigmask(SIG_SETMASK, &amp;sigSet, &amp;sigSetSave);
776 	pthread_attr_init(&amp;sessThrdAttr);
777 	pthread_attr_setstacksize(&amp;sessThrdAttr, 4096*1024);
778 	r = pthread_create(&amp;etry-&gt;tid, &amp;sessThrdAttr, RunServerThread, etry);
779 	if(r != 0) {
780 		LogError(r, NO_ERRCODE, "imtcp error creating server thread");
781 	}
782 	pthread_attr_destroy(&amp;sessThrdAttr);
783 	pthread_sigmask(SIG_SETMASK, &amp;sigSetSave, NULL);
784 }
785 static void
786 stopSrvWrkr(tcpsrv_etry_t *const etry)
787 {
788 	DBGPRINTF("Wait for thread shutdown etry %p\n", etry);
789 	pthread_kill(etry-&gt;tid, SIGTTIN);
790 	pthread_join(etry-&gt;tid, NULL);
791 	DBGPRINTF("input %p terminated\n", etry);
792 }
793 BEGINrunInput
794 CODESTARTrunInput
795 	tcpsrv_etry_t *etry = tcpsrv_root-&gt;next;
796 	while(etry != NULL) {
797 		startSrvWrkr(etry);
798 		etry = etry-&gt;next;
799 	}
800 	iRet = tcpsrv.Run(tcpsrv_root-&gt;tcpsrv);
801 	etry = tcpsrv_root-&gt;next;
802 	while(etry != NULL) {
803 		stopSrvWrkr(etry);
804 		etry = etry-&gt;next;
805 	}
806 ENDrunInput
807 BEGINwillRun
808 CODESTARTwillRun
809 	net.PrintAllowedSenders(2); ENDwillRun
810 BEGINafterRun
811 CODESTARTafterRun
812 	tcpsrv_etry_t *etry = tcpsrv_root;
813 	tcpsrv_etry_t *del;
814 	while(etry != NULL) {
815 		iRet = tcpsrv.Destruct(&amp;etry-&gt;tcpsrv);
816 		del = etry;
817 		etry = etry-&gt;next;
818 		free(del);
819 	}
820 	net.clearAllowedSenders(UCHAR_CONSTANT("TCP"));
821 ENDafterRun
822 BEGINisCompatibleWithFeature
823 CODESTARTisCompatibleWithFeature
824 	if(eFeat == sFEATURENonCancelInputTermination)
825 		iRet = RS_RET_OK;
826 ENDisCompatibleWithFeature
827 BEGINmodExit
828 CODESTARTmodExit
829 	objRelease(net, LM_NET_FILENAME);
830 	objRelease(netstrm, LM_NETSTRMS_FILENAME);
831 	objRelease(tcps_sess, LM_TCPSRV_FILENAME);
832 	objRelease(tcpsrv, LM_TCPSRV_FILENAME);
833 	objRelease(ruleset, CORE_COMPONENT);
834 ENDmodExit
835 static rsRetVal
836 resetConfigVariables(uchar __attribute__((unused)) *pp, void __attribute__((unused)) *pVal)
837 {
838 	cs.iTCPSessMax = 200;
839 	cs.iTCPLstnMax = 20;
840 	cs.bSuppOctetFram = 1;
841 	cs.iStrmDrvrMode = 0;
842 	cs.bUseFlowControl = 1;
843 	cs.bKeepAlive = 0;
844 	cs.iKeepAliveProbes = 0;
845 	cs.iKeepAliveTime = 0;
846 	cs.iKeepAliveIntvl = 0;
847 	cs.bEmitMsgOnClose = 0;
848 	cs.iAddtlFrameDelim = TCPSRV_NO_ADDTL_DELIMITER;
849 	cs.maxFrameSize = 200000;
850 	cs.bDisableLFDelim = 0;
851 	cs.bPreserveCase = 1;
852 	free(cs.pszStrmDrvrAuthMode);
853 	cs.pszStrmDrvrAuthMode = NULL;
854 	free(cs.pszInputName);
855 	cs.pszInputName = NULL;
856 	free(cs.lstnPortFile);
857 	cs.lstnPortFile = NULL;
858 	return RS_RET_OK;
859 }
860 BEGINqueryEtryPt
861 CODESTARTqueryEtryPt
862 CODEqueryEtryPt_STD_IMOD_QUERIES
863 CODEqueryEtryPt_STD_CONF2_QUERIES
864 CODEqueryEtryPt_STD_CONF2_setModCnf_QUERIES
865 CODEqueryEtryPt_STD_CONF2_PREPRIVDROP_QUERIES
866 CODEqueryEtryPt_STD_CONF2_IMOD_QUERIES
867 CODEqueryEtryPt_IsCompatibleWithFeature_IF_OMOD_QUERIES
868 ENDqueryEtryPt
869 BEGINmodInit()
870 CODESTARTmodInit
871 	*ipIFVersProvided = CURR_MOD_IF_VERSION; CODEmodInit_QueryRegCFSLineHdlr
872 	tcpsrv_root = NULL;
873 	CHKiRet(objUse(net, LM_NET_FILENAME));
874 	CHKiRet(objUse(netstrm, LM_NETSTRMS_FILENAME));
875 	CHKiRet(objUse(tcps_sess, LM_TCPSRV_FILENAME));
876 	CHKiRet(objUse(tcpsrv, LM_TCPSRV_FILENAME));
877 	CHKiRet(objUse(ruleset, CORE_COMPONENT));
878 	CHKiRet(omsdRegCFSLineHdlr(UCHAR_CONSTANT("inputtcpserverrun"), 0, eCmdHdlrGetWord,
879 				   addInstance, NULL, STD_LOADABLE_MODULE_ID));
880 	CHKiRet(omsdRegCFSLineHdlr(UCHAR_CONSTANT("inputtcpserverinputname"), 0, eCmdHdlrGetWord,
881 				   NULL, &amp;cs.pszInputName, STD_LOADABLE_MODULE_ID));
882 	CHKiRet(omsdRegCFSLineHdlr(UCHAR_CONSTANT("inputtcpserverbindruleset"), 0, eCmdHdlrGetWord,
883 				   NULL, &amp;cs.pszBindRuleset, STD_LOADABLE_MODULE_ID));
884 	CHKiRet(regCfSysLineHdlr2(UCHAR_CONSTANT("inputtcpserverstreamdriverpermittedpeer"), 0, eCmdHdlrGetWord,
885 			   setPermittedPeer, NULL, STD_LOADABLE_MODULE_ID, &amp;bLegacyCnfModGlobalsPermitted));
886 	CHKiRet(regCfSysLineHdlr2(UCHAR_CONSTANT("inputtcpserverstreamdriverauthmode"), 0, eCmdHdlrGetWord,
887 			   NULL, &amp;cs.pszStrmDrvrAuthMode, STD_LOADABLE_MODULE_ID, &amp;bLegacyCnfModGlobalsPermitted));
888 	CHKiRet(regCfSysLineHdlr2(UCHAR_CONSTANT("inputtcpserverkeepalive"), 0, eCmdHdlrBinary,
889 			   NULL, &amp;cs.bKeepAlive, STD_LOADABLE_MODULE_ID, &amp;bLegacyCnfModGlobalsPermitted));
890 	CHKiRet(regCfSysLineHdlr2(UCHAR_CONSTANT("inputtcpserverkeepalive_probes"), 0, eCmdHdlrInt,
891 			   NULL, &amp;cs.iKeepAliveProbes, STD_LOADABLE_MODULE_ID, &amp;bLegacyCnfModGlobalsPermitted));
892 	CHKiRet(regCfSysLineHdlr2(UCHAR_CONSTANT("inputtcpserverkeepalive_intvl"), 0, eCmdHdlrInt,
893 			   NULL, &amp;cs.iKeepAliveIntvl, STD_LOADABLE_MODULE_ID, &amp;bLegacyCnfModGlobalsPermitted));
894 	CHKiRet(regCfSysLineHdlr2(UCHAR_CONSTANT("inputtcpserverkeepalive_time"), 0, eCmdHdlrInt,
895 			   NULL, &amp;cs.iKeepAliveTime, STD_LOADABLE_MODULE_ID, &amp;bLegacyCnfModGlobalsPermitted));
896 	CHKiRet(regCfSysLineHdlr2(UCHAR_CONSTANT("inputtcpflowcontrol"), 0, eCmdHdlrBinary,
897 			   NULL, &amp;cs.bUseFlowControl, STD_LOADABLE_MODULE_ID, &amp;bLegacyCnfModGlobalsPermitted));
898 	CHKiRet(regCfSysLineHdlr2(UCHAR_CONSTANT("inputtcpserverdisablelfdelimiter"), 0, eCmdHdlrBinary,
899 			   NULL, &amp;cs.bDisableLFDelim, STD_LOADABLE_MODULE_ID, &amp;bLegacyCnfModGlobalsPermitted));
900 	CHKiRet(regCfSysLineHdlr2(UCHAR_CONSTANT("inputtcpserveraddtlframedelimiter"), 0, eCmdHdlrInt,
901 			   NULL, &amp;cs.iAddtlFrameDelim, STD_LOADABLE_MODULE_ID, &amp;bLegacyCnfModGlobalsPermitted));
902 	CHKiRet(regCfSysLineHdlr2(UCHAR_CONSTANT("inputtcpserversupportoctetcountedframing"), 0, eCmdHdlrBinary,
903 			   NULL, &amp;cs.bSuppOctetFram, STD_LOADABLE_MODULE_ID, &amp;bLegacyCnfModGlobalsPermitted));
904 	CHKiRet(regCfSysLineHdlr2(UCHAR_CONSTANT("inputtcpmaxsessions"), 0, eCmdHdlrInt,
905 			   NULL, &amp;cs.iTCPSessMax, STD_LOADABLE_MODULE_ID, &amp;bLegacyCnfModGlobalsPermitted));
906 	CHKiRet(regCfSysLineHdlr2(UCHAR_CONSTANT("inputtcpmaxlisteners"), 0, eCmdHdlrInt,
907 			   NULL, &amp;cs.iTCPLstnMax, STD_LOADABLE_MODULE_ID, &amp;bLegacyCnfModGlobalsPermitted));
908 	CHKiRet(regCfSysLineHdlr2(UCHAR_CONSTANT("inputtcpservernotifyonconnectionclose"), 0, eCmdHdlrBinary,
909 			   NULL, &amp;cs.bEmitMsgOnClose, STD_LOADABLE_MODULE_ID, &amp;bLegacyCnfModGlobalsPermitted));
910 	CHKiRet(regCfSysLineHdlr2(UCHAR_CONSTANT("inputtcpserverstreamdrivermode"), 0, eCmdHdlrInt,
911 			   NULL, &amp;cs.iStrmDrvrMode, STD_LOADABLE_MODULE_ID, &amp;bLegacyCnfModGlobalsPermitted));
912 	CHKiRet(regCfSysLineHdlr2(UCHAR_CONSTANT("inputtcpserverpreservecase"), 1, eCmdHdlrBinary,
913 			   NULL, &amp;cs.bPreserveCase, STD_LOADABLE_MODULE_ID, &amp;bLegacyCnfModGlobalsPermitted));
914 	CHKiRet(regCfSysLineHdlr2(UCHAR_CONSTANT("inputtcpserverlistenportfile"), 1, eCmdHdlrGetWord,
915 			   NULL, &amp;cs.lstnPortFile, STD_LOADABLE_MODULE_ID, &amp;bLegacyCnfModGlobalsPermitted));
916 	CHKiRet(omsdRegCFSLineHdlr(UCHAR_CONSTANT("resetconfigvariables"), 1, eCmdHdlrCustomHandler,
917 				   resetConfigVariables, NULL, STD_LOADABLE_MODULE_ID));
918 ENDmodInit
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
