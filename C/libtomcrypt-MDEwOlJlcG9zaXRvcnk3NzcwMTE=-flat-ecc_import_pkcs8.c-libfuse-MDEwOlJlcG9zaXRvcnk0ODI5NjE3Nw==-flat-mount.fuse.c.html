
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 2.957486136783734%, Tokens: 8, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>libtomcrypt-MDEwOlJlcG9zaXRvcnk3NzcwMTE=-flat-ecc_import_pkcs8.c</h3>
            <pre><code>1  #include "tomcrypt_private.h"
2  #ifdef LTC_MECC
3  typedef struct {
4     ltc_asn1_type t;
5     ltc_asn1_list **pp;
6  } der_flexi_check;
7  #define LTC_SET_DER_FLEXI_CHECK(list, index, Type, P)    \
8     do {                                         \
9        int LTC_SDFC_temp##__LINE__ = (index);   \
10        list[LTC_SDFC_temp##__LINE__].t = Type;  \
11        list[LTC_SDFC_temp##__LINE__].pp = P;    \
12     } while (0)
13  static int s_der_flexi_sequence_cmp(const ltc_asn1_list *flexi, der_flexi_check *check)
14  {
15     const ltc_asn1_list *cur;
16     if (flexi->type != LTC_ASN1_SEQUENCE) {
17        return CRYPT_INVALID_PACKET;
18     }
19     cur = flexi->child;
20     while(check->t != LTC_ASN1_EOL) {
21        if (!LTC_ASN1_IS_TYPE(cur, check->t)) {
22           return CRYPT_INVALID_PACKET;
23        }
24        if (check->pp != NULL) *check->pp = (ltc_asn1_list*)cur;
25        cur = cur->next;
26        check++;
27     }
28     return CRYPT_OK;
29  }
30  int ecc_import_pkcs8(const unsigned char *in, unsigned long inlen,
31                       const void *pwd, unsigned long pwdlen,
32                       ecc_key *key)
33  {
34     void          *a, *b, *gx, *gy;
35     unsigned long len, cofactor, n;
36     const char    *pka_ec_oid;
37     int           err;
38     char          OID[256];
39     const ltc_ecc_curve *curve;
40     ltc_asn1_list *p = NULL, *l = NULL;
41     der_flexi_check flexi_should[7];
42     ltc_asn1_list *seq, *priv_key;
43     LTC_ARGCHK(in          != NULL);
44     LTC_ARGCHK(key         != NULL);
45     LTC_ARGCHK(ltc_mp.name != NULL);
46     err = pk_get_oid(LTC_OID_EC, &pka_ec_oid);
47     if (err != CRYPT_OK) return err;
48     err = mp_init_multi(&a, &b, &gx, &gy, LTC_NULL);
49     if (err != CRYPT_OK) return err;
50     if ((err = pkcs8_decode_flexi(in, inlen, pwd, pwdlen, &l)) == CRYPT_OK) {
51        n=0;
52        LTC_SET_DER_FLEXI_CHECK(flexi_should, n++, LTC_ASN1_INTEGER, NULL);
53        LTC_SET_DER_FLEXI_CHECK(flexi_should, n++, LTC_ASN1_SEQUENCE, &seq);
54        LTC_SET_DER_FLEXI_CHECK(flexi_should, n++, LTC_ASN1_OCTET_STRING, &priv_key);
55        LTC_SET_DER_FLEXI_CHECK(flexi_should, n, LTC_ASN1_EOL, NULL);
56        if (((err = s_der_flexi_sequence_cmp(l, flexi_should)) == CRYPT_OK) &&
<span onclick='openModal()' class='match'>57              (pk_oid_cmp_with_asn1(pka_ec_oid, seq->child) == CRYPT_OK)) {
58           ltc_asn1_list *version, *field, *point, *point_g, *order, *p_cofactor;
59           n=0;
60           LTC_SET_DER_FLEXI_CHECK(flexi_should, n++, LTC_ASN1_INTEGER, &version);
61           LTC_SET_DER_FLEXI_CHECK(flexi_should, n++, LTC_ASN1_SEQUENCE, &field);
62           LTC_SET_DER_FLEXI_CHECK(flexi_should, n++, LTC_ASN1_SEQUENCE, &point);
63           LTC_SET_DER_FLEXI_CHECK(flexi_should, n++, LTC_ASN1_OCTET_STRING, &point_g);
64           LTC_SET_DER_FLEXI_CHECK(flexi_should, n++, LTC_ASN1_INTEGER, &order);
65           LTC_SET_DER_FLEXI_CHECK(flexi_should, n++, LTC_ASN1_INTEGER, &p_cofactor);
</span>66           LTC_SET_DER_FLEXI_CHECK(flexi_should, n, LTC_ASN1_EOL, NULL);
67           if (LTC_ASN1_IS_TYPE(seq->child->next, LTC_ASN1_OBJECT_IDENTIFIER)) {
68              ltc_asn1_list *curve_oid = seq->child->next;
69              len = sizeof(OID);
70              if ((err = pk_oid_num_to_str(curve_oid->data, curve_oid->size, OID, &len)) != CRYPT_OK) { goto LBL_DONE; }
71              if ((err = ecc_find_curve(OID, &curve)) != CRYPT_OK)                          { goto LBL_DONE; }
72              if ((err = ecc_set_curve(curve, key)) != CRYPT_OK)                            { goto LBL_DONE; }
73           }
74           else if ((err = s_der_flexi_sequence_cmp(seq->child->next, flexi_should)) == CRYPT_OK) {
75              if (mp_get_int(version->data) != 1) {
76                 goto LBL_DONE;
77              }
78              cofactor = mp_get_int(p_cofactor->data);
79              if (LTC_ASN1_IS_TYPE(field->child, LTC_ASN1_OBJECT_IDENTIFIER) &&
80                  LTC_ASN1_IS_TYPE(field->child->next, LTC_ASN1_INTEGER) &&
81                  LTC_ASN1_IS_TYPE(point->child, LTC_ASN1_OCTET_STRING) &&
82                  LTC_ASN1_IS_TYPE(point->child->next, LTC_ASN1_OCTET_STRING)) {
83                 ltc_asn1_list *prime = field->child->next;
84                 if ((err = mp_read_unsigned_bin(a, point->child->data, point->child->size)) != CRYPT_OK) {
85                    goto LBL_DONE;
86                 }
87                 if ((err = mp_read_unsigned_bin(b, point->child->next->data, point->child->next->size)) != CRYPT_OK) {
88                    goto LBL_DONE;
89                 }
90                 if ((err = ltc_ecc_import_point(point_g->data, point_g->size, prime->data, a, b, gx, gy)) != CRYPT_OK) {
91                    goto LBL_DONE;
92                 }
93                 if ((err = ecc_set_curve_from_mpis(a, b, prime->data, order->data, gx, gy, cofactor, key)) != CRYPT_OK) {
94                    goto LBL_DONE;
95                 }
96              }
97           }
98           else {
99              err = CRYPT_INVALID_PACKET;
100              goto LBL_DONE;
101           }
102           len = priv_key->size;
103           if ((err = der_decode_sequence_flexi(priv_key->data, &len, &p)) == CRYPT_OK) {
104              if (p->type == LTC_ASN1_SEQUENCE &&
105                  LTC_ASN1_IS_TYPE(p->child, LTC_ASN1_INTEGER) &&
106                  LTC_ASN1_IS_TYPE(p->child->next, LTC_ASN1_OCTET_STRING)) {
107                 ltc_asn1_list *lk = p->child->next;
108                 if (mp_cmp_d(p->child->data, 1) != LTC_MP_EQ) {
109                    err = CRYPT_INVALID_PACKET;
110                    goto LBL_ECCFREE;
111                 }
112                 if ((err = ecc_set_key(lk->data, lk->size, PK_PRIVATE, key)) != CRYPT_OK) {
113                    goto LBL_ECCFREE;
114                 }
115                 goto LBL_DONE; &bsol;* success */
116              }
117           }
118        }
119     }
120     err = CRYPT_INVALID_PACKET;
121     goto LBL_DONE;
122  LBL_ECCFREE:
123     ecc_free(key);
124  LBL_DONE:
125     mp_clear_multi(a, b, gx, gy, LTC_NULL);
126     if (l) der_free_sequence_flexi(l);
127     if (p) der_free_sequence_flexi(p);
128     return err;
129  }
130  #endif
</code></pre>
        </div>
        <div class="column">
            <h3>libfuse-MDEwOlJlcG9zaXRvcnk0ODI5NjE3Nw==-flat-mount.fuse.c</h3>
            <pre><code>1  #include "fuse_config.h"
2  #include <stdio.h>
3  #include <stdlib.h>
4  #include <string.h>
5  #include <unistd.h>
6  #include <errno.h>
7  #include <stdint.h>
8  #include <fcntl.h>
9  #include <pwd.h>
10  #include <sys/wait.h>
11  #ifdef linux
12  #include <sys/prctl.h>
13  #include <sys/syscall.h>
14  #include <linux/capability.h>
15  #include <linux/securebits.h>
16  #if !defined(SECBIT_KEEP_CAPS) && defined(SECURE_KEEP_CAPS)
17  #define SECBIT_KEEP_CAPS (issecure_mask(SECURE_KEEP_CAPS))
18  #endif
19  #if !defined(SECBIT_KEEP_CAPS_LOCKED) && defined(SECURE_KEEP_CAPS_LOCKED)
20  #define SECBIT_KEEP_CAPS_LOCKED (issecure_mask(SECURE_KEEP_CAPS_LOCKED))
21  #endif
22  #if !defined(SECBIT_NO_SETUID_FIXUP) && defined(SECURE_NO_SETUID_FIXUP)
23  #define SECBIT_NO_SETUID_FIXUP (issecure_mask(SECURE_NO_SETUID_FIXUP))
24  #endif
25  #if !defined(SECBIT_NO_SETUID_FIXUP_LOCKED) && defined(SECURE_NO_SETUID_FIXUP_LOCKED)
26  #define SECBIT_NO_SETUID_FIXUP_LOCKED (issecure_mask(SECURE_NO_SETUID_FIXUP_LOCKED))
27  #endif
28  #if !defined(SECBIT_NOROOT) && defined(SECURE_NOROOT)
29  #define SECBIT_NOROOT (issecure_mask(SECURE_NOROOT))
30  #endif
31  #if !defined(SECBIT_NOROOT_LOCKED) && defined(SECURE_NOROOT_LOCKED)
32  #define SECBIT_NOROOT_LOCKED (issecure_mask(SECURE_NOROOT_LOCKED))
33  #endif
34  #endif
35  #include "fuse.h"
36  static char *progname;
37  static char *xstrdup(const char *s)
38  {
39  	char *t = strdup(s);
40  	if (!t) {
41  		fprintf(stderr, "%s: failed to allocate memory\n", progname);
42  		exit(1);
43  	}
44  	return t;
45  }
46  static void *xrealloc(void *oldptr, size_t size)
47  {
48  	void *ptr = realloc(oldptr, size);
49  	if (!ptr) {
50  		fprintf(stderr, "%s: failed to allocate memory\n", progname);
51  		exit(1);
52  	}
53  	return ptr;
54  }
55  static void add_arg(char **cmdp, const char *opt)
56  {
57  	size_t optlen = strlen(opt);
58  	size_t cmdlen = *cmdp ? strlen(*cmdp) : 0;
59  	if (optlen >= (SIZE_MAX - cmdlen - 4)/4) {
60  		fprintf(stderr, "%s: argument too long\n", progname);
61  		exit(1);
62  	}
63  	char *cmd = xrealloc(*cmdp, cmdlen + optlen * 4 + 4);
64  	char *s;
65  	s = cmd + cmdlen;
66  	if (*cmdp)
67  		*s++ = ' ';
68  	*s++ = '\'';
69  	for (; *opt; opt++) {
<span onclick='openModal()' class='match'>70  		if (*opt == '\'') {
71  			*s++ = '\'';
72  			*s++ = '\\';
73  			*s++ = '\'';
74  			*s++ = '\'';
</span>75  		} else
76  			*s++ = *opt;
77  	}
78  	*s++ = '\'';
79  	*s = '\0';
80  	*cmdp = cmd;
81  }
82  static char *add_option(const char *opt, char *options)
83  {
84  	int oldlen = options ? strlen(options) : 0;
85  	options = xrealloc(options, oldlen + 1 + strlen(opt) + 1);
86  	if (!oldlen)
87  		strcpy(options, opt);
88  	else {
89  		strcat(options, ",");
90  		strcat(options, opt);
91  	}
92  	return options;
93  }
94  static int prepare_fuse_fd(const char *mountpoint, const char* subtype,
95  			   const char *options)
96  {
97  	int fuse_fd = -1;
98  	int flags = -1;
99  	int subtype_len = strlen(subtype) + 9;
100  	char* options_copy = xrealloc(NULL, subtype_len);
101  	snprintf(options_copy, subtype_len, "subtype=%s", subtype);
102  	options_copy = add_option(options, options_copy);
103  	fuse_fd = fuse_open_channel(mountpoint, options_copy);
104  	if (fuse_fd == -1) {
105  		exit(1);
106  	}
107  	flags = fcntl(fuse_fd, F_GETFD);
108  	if (flags == -1 || fcntl(fuse_fd, F_SETFD, flags & ~FD_CLOEXEC) == 1) {
109  		fprintf(stderr, "%s: Failed to clear CLOEXEC: %s\n",
110  			progname, strerror(errno));
111  		exit(1);
112  	}
113  	return fuse_fd;
114  }
115  #ifdef linux
116  static uint64_t get_capabilities(void)
117  {
118  	struct __user_cap_header_struct header = {
119  		.version = _LINUX_CAPABILITY_VERSION_3,
120  		.pid = 0,
121  	};
122  	struct __user_cap_data_struct data[2];
123  	memset(data, 0, sizeof(data));
124  	if (syscall(SYS_capget, &header, data) == -1) {
125  		fprintf(stderr, "%s: Failed to get capabilities: %s\n",
126  			progname, strerror(errno));
127  		exit(1);
128  	}
129  	return data[0].effective | ((uint64_t) data[1].effective << 32);
130  }
131  static void set_capabilities(uint64_t caps)
132  {
133  	struct __user_cap_header_struct header = {
134  		.version = _LINUX_CAPABILITY_VERSION_3,
135  		.pid = 0,
136  	};
137  	struct __user_cap_data_struct data[2];
138  	memset(data, 0, sizeof(data));
139  	data[0].effective = data[0].permitted = caps;
140  	data[1].effective = data[1].permitted = caps >> 32;
141  	if (syscall(SYS_capset, &header, data) == -1) {
142  		fprintf(stderr, "%s: Failed to set capabilities: %s\n",
143  			progname, strerror(errno));
144  		exit(1);
145  	}
146  }
147  static void drop_and_lock_capabilities(void)
148  {
149  	if (prctl(PR_SET_SECUREBITS,
150  		  SECBIT_KEEP_CAPS_LOCKED |
151  		  SECBIT_NO_SETUID_FIXUP |
152  		  SECBIT_NO_SETUID_FIXUP_LOCKED |
153  		  SECBIT_NOROOT |
154  		  SECBIT_NOROOT_LOCKED) == -1) {
155  		fprintf(stderr, "%s: Failed to set securebits %s\n",
156  			progname, strerror(errno));
157  		exit(1);
158  	}
159  	int cap;
160  	for (cap = 0; ; cap++) {
161  		int cap_status = prctl(PR_CAPBSET_READ, cap);
162  		if (cap_status == 0) {
163  			continue;
164  		}
165  		if (cap_status == -1 && errno == EINVAL) {
166  			break;
167  		}
168  		if (cap_status != 1) {
169  			fprintf(stderr,
170  				"%s: Failed to get capability %u: %s\n",
171  				progname, cap, strerror(errno));
172  			exit(1);
173  		}
174  		if (prctl(PR_CAPBSET_DROP, cap) == -1) {
175  			fprintf(stderr,
176  				"%s: Failed to drop capability %u: %s\n",
177  				progname, cap, strerror(errno));
178  		}
179  	}
180  	set_capabilities(0);
181  	if (prctl(PR_SET_NO_NEW_PRIVS, 1, 0, 0, 0) == -1) {
182  		fprintf(stderr, "%s: Failed to set no_new_privs: %s\n",
183  			progname, strerror(errno));
184  		exit(1);
185  	}
186  }
187  #endif
188  int main(int argc, char *argv[])
189  {
190  	char *type = NULL;
191  	char *source;
192  	char *dup_source = NULL;
193  	const char *mountpoint;
194  	char *basename;
195  	char *options = NULL;
196  	char *command = NULL;
197  	char *setuid_name = NULL;
198  	int i;
199  	int dev = 1;
200  	int suid = 1;
201  	int pass_fuse_fd = 0;
202  	int fuse_fd = 0;
203  	int drop_privileges = 0;
204  	char *dev_fd_mountpoint = NULL;
205  	progname = argv[0];
206  	basename = strrchr(argv[0], '/');
207  	if (basename)
208  		basename++;
209  	else
210  		basename = argv[0];
211  	if (strncmp(basename, "mount.fuse.", 11) == 0)
212  		type = basename + 11;
213  	if (strncmp(basename, "mount.fuseblk.", 14) == 0)
214  		type = basename + 14;
215  	if (type && !type[0])
216  		type = NULL;
217  	if (argc < 3) {
218  		fprintf(stderr,
219  			"usage: %s %s destination [-t type] [-o opt[,opts...]]\n",
220  			progname, type ? "source" : "type#[source]");
221  		exit(1);
222  	}
223  	source = argv[1];
224  	if (!source[0])
225  		source = NULL;
226  	mountpoint = argv[2];
227  	for (i = 3; i < argc; i++) {
228  		if (strcmp(argv[i], "-v") == 0) {
229  			continue;
230  		} else if (strcmp(argv[i], "-t") == 0) {
231  			i++;
232  			if (i == argc) {
233  				fprintf(stderr,
234  					"%s: missing argument to option '-t'\n",
235  					progname);
236  				exit(1);
237  			}
238  			type = argv[i];
239  			if (strncmp(type, "fuse.", 5) == 0)
240  				type += 5;
241  			else if (strncmp(type, "fuseblk.", 8) == 0)
242  				type += 8;
243  			if (!type[0]) {
244  				fprintf(stderr,
245  					"%s: empty type given as argument to option '-t'\n",
246  					progname);
247  				exit(1);
248  			}
249  		} else	if (strcmp(argv[i], "-o") == 0) {
250  			char *opts;
251  			char *opt;
252  			i++;
253  			if (i == argc)
254  				break;
255  			opts = xstrdup(argv[i]);
256  			opt = strtok(opts, ",");
257  			while (opt) {
258  				int j;
259  				int ignore = 0;
260  				const char *ignore_opts[] = { "",
261  							      "user",
262  							      "nofail",
263  							      "nouser",
264  							      "users",
265  							      "auto",
266  							      "noauto",
267  							      "_netdev",
268  							      NULL};
269  				if (strncmp(opt, "setuid=", 7) == 0) {
270  					setuid_name = xstrdup(opt + 7);
271  					ignore = 1;
272  				} else if (strcmp(opt,
273  						  "drop_privileges") == 0) {
274  					pass_fuse_fd = 1;
275  					drop_privileges = 1;
276  					ignore = 1;
277  				}
278  				for (j = 0; ignore_opts[j]; j++)
279  					if (strcmp(opt, ignore_opts[j]) == 0)
280  						ignore = 1;
281  				if (!ignore) {
282  					if (strcmp(opt, "nodev") == 0)
283  						dev = 0;
284  					else if (strcmp(opt, "nosuid") == 0)
285  						suid = 0;
286  					options = add_option(opt, options);
287  				}
288  				opt = strtok(NULL, ",");
289  			}
290  			free(opts);
291  		}
292  	}
293  	if (drop_privileges) {
294  		uint64_t required_caps = CAP_TO_MASK(CAP_SETPCAP) |
295  				CAP_TO_MASK(CAP_SYS_ADMIN);
296  		if ((get_capabilities() & required_caps) != required_caps) {
297  			fprintf(stderr, "%s: drop_privileges was requested, which launches the FUSE file system fully unprivileged. In order to do so %s must be run with privileges, please invoke with CAP_SYS_ADMIN and CAP_SETPCAP (e.g. as root).\n",
298  			progname, progname);
299  			exit(1);
300  		}
301  	}
302  	if (dev)
303  		options = add_option("dev", options);
304  	if (suid)
305  		options = add_option("suid", options);
306  	if (!type) {
307  		if (source) {
308  			dup_source = xstrdup(source);
309  			type = dup_source;
310  			source = strchr(type, '#');
311  			if (source)
312  				*source++ = '\0';
313  			if (!type[0]) {
314  				fprintf(stderr, "%s: empty filesystem type\n",
315  					progname);
316  				exit(1);
317  			}
318  		} else {
319  			fprintf(stderr, "%s: empty source\n", progname);
320  			exit(1);
321  		}
322  	}
323  	if (setuid_name && setuid_name[0]) {
324  #ifdef linux
325  		if (drop_privileges) {
326  			if (prctl(PR_SET_SECUREBITS,
327  				  SECBIT_KEEP_CAPS |
328  				  SECBIT_NO_SETUID_FIXUP) == -1) {
329  				fprintf(stderr,
330  					"%s: Failed to set securebits %s\n",
331  					progname, strerror(errno));
332  				exit(1);
333  			}
334  		}
335  #endif
336  		struct passwd *pwd = getpwnam(setuid_name);
337  		if (!pwd || setgid(pwd->pw_gid) == -1 || setuid(pwd->pw_uid) == -1) {
338  			fprintf(stderr, "%s: Failed to setuid to %s: %s\n",
339  				progname, setuid_name, strerror(errno));
340  			exit(1);
341  		}
342  	} else if (!getenv("HOME")) {
343  		setenv("HOME", "/root", 0);
344  	}
345  	if (pass_fuse_fd)  {
346  		fuse_fd = prepare_fuse_fd(mountpoint, type, options);
347  		dev_fd_mountpoint = xrealloc(NULL, 20);
348  		snprintf(dev_fd_mountpoint, 20, "/dev/fd/%u", fuse_fd);
349  		mountpoint = dev_fd_mountpoint;
350  	}
351  #ifdef linux
352  	if (drop_privileges) {
353  		drop_and_lock_capabilities();
354  	}
355  #endif
356  	add_arg(&command, type);
357  	if (source)
358  		add_arg(&command, source);
359  	add_arg(&command, mountpoint);
360  	if (options) {
361  		add_arg(&command, "-o");
362  		add_arg(&command, options);
363  	}
364  	free(options);
365  	free(dev_fd_mountpoint);
366  	free(dup_source);
367  	free(setuid_name);
368  	execl("/bin/sh", "/bin/sh", "-c", command, NULL);
369  	fprintf(stderr, "%s: failed to execute /bin/sh: %s\n", progname,
370  		strerror(errno));
371  	if (pass_fuse_fd)
372  		close(fuse_fd);
373  	free(command);
374  	return 1;
375  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from libtomcrypt-MDEwOlJlcG9zaXRvcnk3NzcwMTE=-flat-ecc_import_pkcs8.c</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from libfuse-MDEwOlJlcG9zaXRvcnk0ODI5NjE3Nw==-flat-mount.fuse.c</div>
                </div>
                <div class="column column_space"><pre><code>57              (pk_oid_cmp_with_asn1(pka_ec_oid, seq->child) == CRYPT_OK)) {
58           ltc_asn1_list *version, *field, *point, *point_g, *order, *p_cofactor;
59           n=0;
60           LTC_SET_DER_FLEXI_CHECK(flexi_should, n++, LTC_ASN1_INTEGER, &version);
61           LTC_SET_DER_FLEXI_CHECK(flexi_should, n++, LTC_ASN1_SEQUENCE, &field);
62           LTC_SET_DER_FLEXI_CHECK(flexi_should, n++, LTC_ASN1_SEQUENCE, &point);
63           LTC_SET_DER_FLEXI_CHECK(flexi_should, n++, LTC_ASN1_OCTET_STRING, &point_g);
64           LTC_SET_DER_FLEXI_CHECK(flexi_should, n++, LTC_ASN1_INTEGER, &order);
65           LTC_SET_DER_FLEXI_CHECK(flexi_should, n++, LTC_ASN1_INTEGER, &p_cofactor);
</pre></code></div>
                <div class="column column_space"><pre><code>70  		if (*opt == '\'') {
71  			*s++ = '\'';
72  			*s++ = '\\';
73  			*s++ = '\'';
74  			*s++ = '\'';
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    