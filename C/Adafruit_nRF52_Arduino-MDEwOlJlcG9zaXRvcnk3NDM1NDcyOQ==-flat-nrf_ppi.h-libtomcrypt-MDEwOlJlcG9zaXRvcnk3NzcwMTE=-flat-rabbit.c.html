
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 9.0%, Tokens: 17</h2>
        <div class="column">
            <h3>Adafruit_nRF52_Arduino-MDEwOlJlcG9zaXRvcnk3NDM1NDcyOQ==-flat-nrf_ppi.h</h3>
            <pre><code>1  #ifndef NRF_PPI_H__
2  #define NRF_PPI_H__
3  #include <nrfx.h>
4  #ifdef __cplusplus
5  extern "C" {
6  #endif
7  typedef enum
8  {
<span onclick='openModal()' class='match'>9      NRF_PPI_CHANNEL0  = PPI_CHEN_CH0_Pos,  &bsol;**< Channel 0. */
10      NRF_PPI_CHANNEL1  = PPI_CHEN_CH1_Pos,  &bsol;**< Channel 1. */
11      NRF_PPI_CHANNEL2  = PPI_CHEN_CH2_Pos,  &bsol;**< Channel 2. */
12      NRF_PPI_CHANNEL3  = PPI_CHEN_CH3_Pos,  &bsol;**< Channel 3. */
13      NRF_PPI_CHANNEL4  = PPI_CHEN_CH4_Pos,  &bsol;**< Channel 4. */
14      NRF_PPI_CHANNEL5  = PPI_CHEN_CH5_Pos,  &bsol;**< Channel 5. */
15      NRF_PPI_CHANNEL6  = PPI_CHEN_CH6_Pos,  &bsol;**< Channel 6. */
16      NRF_PPI_CHANNEL7  = PPI_CHEN_CH7_Pos,  &bsol;**< Channel 7. */
17      NRF_PPI_CHANNEL8  = PPI_CHEN_CH8_Pos,  &bsol;**< Channel 8. */
18      NRF_PPI_CHANNEL9  = PPI_CHEN_CH9_Pos,  &bsol;**< Channel 9. */
19      NRF_PPI_CHANNEL10 = PPI_CHEN_CH10_Pos, &bsol;**< Channel 10. */
20      NRF_PPI_CHANNEL11 = PPI_CHEN_CH11_Pos, &bsol;**< Channel 11. */
21      NRF_PPI_CHANNEL12 = PPI_CHEN_CH12_Pos, &bsol;**< Channel 12. */
22      NRF_PPI_CHANNEL13 = PPI_CHEN_CH13_Pos, &bsol;**< Channel 13. */
23      NRF_PPI_CHANNEL14 = PPI_CHEN_CH14_Pos, &bsol;**< Channel 14. */
24      NRF_PPI_CHANNEL15 = PPI_CHEN_CH15_Pos, &bsol;**< Channel 15. */
25  #if (PPI_CH_NUM > 16) || defined(__NRFX_DOXYGEN__)
26      NRF_PPI_CHANNEL16 = PPI_CHEN_CH16_Pos, &bsol;**< Channel 16. */
</span>27      NRF_PPI_CHANNEL17 = PPI_CHEN_CH17_Pos, &bsol;**< Channel 17. */
28      NRF_PPI_CHANNEL18 = PPI_CHEN_CH18_Pos, &bsol;**< Channel 18. */
29      NRF_PPI_CHANNEL19 = PPI_CHEN_CH19_Pos, &bsol;**< Channel 19. */
30  #endif
31      NRF_PPI_CHANNEL20 = PPI_CHEN_CH20_Pos, &bsol;**< Channel 20. */
32      NRF_PPI_CHANNEL21 = PPI_CHEN_CH21_Pos, &bsol;**< Channel 21. */
33      NRF_PPI_CHANNEL22 = PPI_CHEN_CH22_Pos, &bsol;**< Channel 22. */
34      NRF_PPI_CHANNEL23 = PPI_CHEN_CH23_Pos, &bsol;**< Channel 23. */
35      NRF_PPI_CHANNEL24 = PPI_CHEN_CH24_Pos, &bsol;**< Channel 24. */
36      NRF_PPI_CHANNEL25 = PPI_CHEN_CH25_Pos, &bsol;**< Channel 25. */
37      NRF_PPI_CHANNEL26 = PPI_CHEN_CH26_Pos, &bsol;**< Channel 26. */
38      NRF_PPI_CHANNEL27 = PPI_CHEN_CH27_Pos, &bsol;**< Channel 27. */
39      NRF_PPI_CHANNEL28 = PPI_CHEN_CH28_Pos, &bsol;**< Channel 28. */
40      NRF_PPI_CHANNEL29 = PPI_CHEN_CH29_Pos, &bsol;**< Channel 29. */
41      NRF_PPI_CHANNEL30 = PPI_CHEN_CH30_Pos, &bsol;**< Channel 30. */
42      NRF_PPI_CHANNEL31 = PPI_CHEN_CH31_Pos  &bsol;**< Channel 31. */
43  } nrf_ppi_channel_t;
44  typedef enum
45  {
46      NRF_PPI_CHANNEL_GROUP0 = 0, &bsol;**< Channel group 0. */
47      NRF_PPI_CHANNEL_GROUP1 = 1, &bsol;**< Channel group 1. */
48      NRF_PPI_CHANNEL_GROUP2 = 2, &bsol;**< Channel group 2. */
49      NRF_PPI_CHANNEL_GROUP3 = 3, &bsol;**< Channel group 3. */
50  #if (PPI_GROUP_NUM > 4) || defined(__NRFX_DOXYGEN__)
51      NRF_PPI_CHANNEL_GROUP4 = 4, &bsol;**< Channel group 4. */
52      NRF_PPI_CHANNEL_GROUP5 = 5  &bsol;**< Channel group 5. */
53  #endif
54  } nrf_ppi_channel_group_t;
55  typedef enum
56  {
57      NRF_PPI_CHANNEL_EXCLUDE = PPI_CHG_CH0_Excluded, &bsol;**< Channel excluded from a group. */
58      NRF_PPI_CHANNEL_INCLUDE = PPI_CHG_CH0_Included  &bsol;**< Channel included in a group. */
59  } nrf_ppi_channel_include_t;
60  typedef enum
61  {
62      NRF_PPI_CHANNEL_DISABLED = PPI_CHEN_CH0_Disabled, &bsol;**< Channel disabled. */
63      NRF_PPI_CHANNEL_ENABLED  = PPI_CHEN_CH0_Enabled   &bsol;**< Channel enabled. */
64  } nrf_ppi_channel_enable_t;
65  typedef enum
66  {
67      NRF_PPI_TASK_CHG0_EN  = offsetof(NRF_PPI_Type, TASKS_CHG[0].EN),  &bsol;**< Task for enabling channel group 0. */
68      NRF_PPI_TASK_CHG0_DIS = offsetof(NRF_PPI_Type, TASKS_CHG[0].DIS), &bsol;**< Task for disabling channel group 0. */
69      NRF_PPI_TASK_CHG1_EN  = offsetof(NRF_PPI_Type, TASKS_CHG[1].EN),  &bsol;**< Task for enabling channel group 1. */
70      NRF_PPI_TASK_CHG1_DIS = offsetof(NRF_PPI_Type, TASKS_CHG[1].DIS), &bsol;**< Task for disabling channel group 1. */
71      NRF_PPI_TASK_CHG2_EN  = offsetof(NRF_PPI_Type, TASKS_CHG[2].EN),  &bsol;**< Task for enabling channel group 2. */
72      NRF_PPI_TASK_CHG2_DIS = offsetof(NRF_PPI_Type, TASKS_CHG[2].DIS), &bsol;**< Task for disabling channel group 2. */
73      NRF_PPI_TASK_CHG3_EN  = offsetof(NRF_PPI_Type, TASKS_CHG[3].EN),  &bsol;**< Task for enabling channel group 3. */
74      NRF_PPI_TASK_CHG3_DIS = offsetof(NRF_PPI_Type, TASKS_CHG[3].DIS), &bsol;**< Task for disabling channel group 3. */
75  #if (PPI_GROUP_NUM > 4) || defined(__NRFX_DOXYGEN__)
76      NRF_PPI_TASK_CHG4_EN  = offsetof(NRF_PPI_Type, TASKS_CHG[4].EN),  &bsol;**< Task for enabling channel group 4. */
77      NRF_PPI_TASK_CHG4_DIS = offsetof(NRF_PPI_Type, TASKS_CHG[4].DIS), &bsol;**< Task for disabling channel group 4. */
78      NRF_PPI_TASK_CHG5_EN  = offsetof(NRF_PPI_Type, TASKS_CHG[5].EN),  &bsol;**< Task for enabling channel group 5. */
79      NRF_PPI_TASK_CHG5_DIS = offsetof(NRF_PPI_Type, TASKS_CHG[5].DIS)  &bsol;**< Task for disabling channel group 5. */
80  #endif
81  } nrf_ppi_task_t;
82  NRF_STATIC_INLINE void nrf_ppi_channel_enable(NRF_PPI_Type * p_reg, nrf_ppi_channel_t channel);
83  NRF_STATIC_INLINE void nrf_ppi_channel_disable(NRF_PPI_Type * p_reg, nrf_ppi_channel_t channel);
84  NRF_STATIC_INLINE nrf_ppi_channel_enable_t nrf_ppi_channel_enable_get(NRF_PPI_Type const * p_reg,
85                                                                        nrf_ppi_channel_t    channel);
86  NRF_STATIC_INLINE void nrf_ppi_channels_disable_all(NRF_PPI_Type * p_reg);
87  NRF_STATIC_INLINE void nrf_ppi_channels_enable(NRF_PPI_Type * p_reg, uint32_t mask);
88  NRF_STATIC_INLINE void nrf_ppi_channels_disable(NRF_PPI_Type * p_reg, uint32_t mask);
89  NRF_STATIC_INLINE void nrf_ppi_channel_endpoint_setup(NRF_PPI_Type *    p_reg,
90                                                        nrf_ppi_channel_t channel,
91                                                        uint32_t          eep,
92                                                        uint32_t          tep);
93  NRF_STATIC_INLINE void nrf_ppi_event_endpoint_setup(NRF_PPI_Type *    p_reg,
94                                                      nrf_ppi_channel_t channel,
95                                                      uint32_t          eep);
96  NRF_STATIC_INLINE void nrf_ppi_task_endpoint_setup(NRF_PPI_Type *    p_reg,
97                                                     nrf_ppi_channel_t channel,
98                                                     uint32_t          tep);
99  #if defined(PPI_FEATURE_FORKS_PRESENT) || defined(__NRFX_DOXYGEN__)
100  NRF_STATIC_INLINE void nrf_ppi_fork_endpoint_setup(NRF_PPI_Type *    p_reg,
101                                                     nrf_ppi_channel_t channel,
102                                                     uint32_t          fork_tep);
103  NRF_STATIC_INLINE void nrf_ppi_channel_and_fork_endpoint_setup(NRF_PPI_Type *    p_reg,
104                                                                 nrf_ppi_channel_t channel,
105                                                                 uint32_t          eep,
106                                                                 uint32_t          tep,
107                                                                 uint32_t          fork_tep);
108  #endif
109  NRF_STATIC_INLINE void nrf_ppi_channel_include_in_group(NRF_PPI_Type *          p_reg,
110                                                          nrf_ppi_channel_t       channel,
111                                                          nrf_ppi_channel_group_t channel_group);
112  NRF_STATIC_INLINE void nrf_ppi_channels_include_in_group(NRF_PPI_Type *          p_reg,
113                                                           uint32_t                channel_mask,
114                                                           nrf_ppi_channel_group_t channel_group);
115  NRF_STATIC_INLINE void nrf_ppi_channel_remove_from_group(NRF_PPI_Type *          p_reg,
116                                                           nrf_ppi_channel_t       channel,
117                                                           nrf_ppi_channel_group_t channel_group);
118  NRF_STATIC_INLINE void nrf_ppi_channels_remove_from_group(NRF_PPI_Type *          p_reg,
119                                                            uint32_t                channel_mask,
120                                                            nrf_ppi_channel_group_t channel_group);
121  NRF_STATIC_INLINE void nrf_ppi_group_clear(NRF_PPI_Type * p_reg, nrf_ppi_channel_group_t group);
122  NRF_STATIC_INLINE void nrf_ppi_group_enable(NRF_PPI_Type * p_reg, nrf_ppi_channel_group_t group);
123  NRF_STATIC_INLINE void nrf_ppi_group_disable(NRF_PPI_Type * p_reg, nrf_ppi_channel_group_t group);
124  NRF_STATIC_INLINE void nrf_ppi_task_trigger(NRF_PPI_Type * p_reg, nrf_ppi_task_t ppi_task);
125  NRF_STATIC_INLINE uint32_t nrf_ppi_task_address_get(NRF_PPI_Type const * p_reg,
126                                                      nrf_ppi_task_t       ppi_task);
127  NRF_STATIC_INLINE uint32_t nrf_ppi_task_group_enable_address_get(NRF_PPI_Type const *    p_reg,
128                                                                   nrf_ppi_channel_group_t group);
129  NRF_STATIC_INLINE uint32_t nrf_ppi_task_group_disable_address_get(NRF_PPI_Type const *    p_reg,
130                                                                    nrf_ppi_channel_group_t group);
131  NRF_STATIC_INLINE nrf_ppi_task_t nrf_ppi_group_enable_task_get(NRF_PPI_Type const * p_reg,
132                                                                 uint8_t              index);
133  NRF_STATIC_INLINE nrf_ppi_task_t nrf_ppi_group_disable_task_get(NRF_PPI_Type const * p_reg,
134                                                                  uint8_t              index);
135  #ifndef NRF_DECLARE_ONLY
136  NRF_STATIC_INLINE void nrf_ppi_channel_enable(NRF_PPI_Type * p_reg, nrf_ppi_channel_t channel)
137  {
138      p_reg->CHENSET = PPI_CHENSET_CH0_Set << ((uint32_t) channel);
139  }
140  NRF_STATIC_INLINE void nrf_ppi_channel_disable(NRF_PPI_Type * p_reg, nrf_ppi_channel_t channel)
141  {
142      p_reg->CHENCLR = PPI_CHENCLR_CH0_Clear << ((uint32_t) channel);
143  }
144  NRF_STATIC_INLINE nrf_ppi_channel_enable_t nrf_ppi_channel_enable_get(NRF_PPI_Type const * p_reg,
145                                                                        nrf_ppi_channel_t    channel)
146  {
147      if (p_reg->CHEN & (PPI_CHEN_CH0_Msk << ((uint32_t) channel)))
148      {
149          return NRF_PPI_CHANNEL_ENABLED;
150      }
151      else
152      {
153          return NRF_PPI_CHANNEL_DISABLED;
154      }
155  }
156  NRF_STATIC_INLINE void nrf_ppi_channels_disable_all(NRF_PPI_Type * p_reg)
157  {
158      p_reg->CHENCLR = ((uint32_t)0xFFFFFFFFuL);
159  }
160  NRF_STATIC_INLINE void nrf_ppi_channels_enable(NRF_PPI_Type * p_reg, uint32_t mask)
161  {
162      p_reg->CHENSET = mask;
163  }
164  NRF_STATIC_INLINE void nrf_ppi_channels_disable(NRF_PPI_Type * p_reg, uint32_t mask)
165  {
166      p_reg->CHENCLR = mask;
167  }
168  NRF_STATIC_INLINE void nrf_ppi_channel_endpoint_setup(NRF_PPI_Type *    p_reg,
169                                                        nrf_ppi_channel_t channel,
170                                                        uint32_t          eep,
171                                                        uint32_t          tep)
172  {
173      p_reg->CH[(uint32_t) channel].EEP = eep;
174      p_reg->CH[(uint32_t) channel].TEP = tep;
175  }
176  NRF_STATIC_INLINE void nrf_ppi_event_endpoint_setup(NRF_PPI_Type *    p_reg,
177                                                      nrf_ppi_channel_t channel,
178                                                      uint32_t          eep)
179  {
180      p_reg->CH[(uint32_t) channel].EEP = eep;
181  }
182  NRF_STATIC_INLINE void nrf_ppi_task_endpoint_setup(NRF_PPI_Type *    p_reg,
183                                                     nrf_ppi_channel_t channel,
184                                                     uint32_t          tep)
185  {
186      p_reg->CH[(uint32_t) channel].TEP = tep;
187  }
188  #if defined(PPI_FEATURE_FORKS_PRESENT)
189  NRF_STATIC_INLINE void nrf_ppi_fork_endpoint_setup(NRF_PPI_Type *    p_reg,
190                                                     nrf_ppi_channel_t channel,
191                                                     uint32_t          fork_tep)
192  {
193      p_reg->FORK[(uint32_t) channel].TEP = fork_tep;
194  }
195  NRF_STATIC_INLINE void nrf_ppi_channel_and_fork_endpoint_setup(NRF_PPI_Type *    p_reg,
196                                                                 nrf_ppi_channel_t channel,
197                                                                 uint32_t          eep,
198                                                                 uint32_t          tep,
199                                                                 uint32_t          fork_tep)
200  {
201      nrf_ppi_channel_endpoint_setup(p_reg, channel, eep, tep);
202      nrf_ppi_fork_endpoint_setup(p_reg, channel, fork_tep);
203  }
204  #endif
205  NRF_STATIC_INLINE void nrf_ppi_channel_include_in_group(NRF_PPI_Type *          p_reg,
206                                                          nrf_ppi_channel_t       channel,
207                                                          nrf_ppi_channel_group_t channel_group)
208  {
209      p_reg->CHG[(uint32_t) channel_group] |= (PPI_CHG_CH0_Included << ((uint32_t) channel));
210  }
211  NRF_STATIC_INLINE void nrf_ppi_channels_include_in_group(NRF_PPI_Type *          p_reg,
212                                                           uint32_t                channel_mask,
213                                                           nrf_ppi_channel_group_t channel_group)
214  {
215      p_reg->CHG[(uint32_t) channel_group] |= channel_mask;
216  }
217  NRF_STATIC_INLINE void nrf_ppi_channel_remove_from_group(NRF_PPI_Type *          p_reg,
218                                                           nrf_ppi_channel_t       channel,
219                                                           nrf_ppi_channel_group_t channel_group)
220  {
221      p_reg->CHG[(uint32_t) channel_group] &= ~(PPI_CHG_CH0_Included << ((uint32_t) channel));
222  }
223  NRF_STATIC_INLINE void nrf_ppi_channels_remove_from_group(NRF_PPI_Type *          p_reg,
224                                                            uint32_t                channel_mask,
225                                                            nrf_ppi_channel_group_t channel_group)
226  {
227      p_reg->CHG[(uint32_t) channel_group] &= ~(channel_mask);
228  }
229  NRF_STATIC_INLINE void nrf_ppi_group_clear(NRF_PPI_Type * p_reg, nrf_ppi_channel_group_t group)
230  {
231      p_reg->CHG[(uint32_t) group] = 0;
232  }
233  NRF_STATIC_INLINE void nrf_ppi_group_enable(NRF_PPI_Type * p_reg, nrf_ppi_channel_group_t group)
234  {
235      p_reg->TASKS_CHG[(uint32_t) group].EN = 1UL;
236  }
237  NRF_STATIC_INLINE void nrf_ppi_group_disable(NRF_PPI_Type * p_reg, nrf_ppi_channel_group_t group)
238  {
239      p_reg->TASKS_CHG[(uint32_t) group].DIS = 1UL;
240  }
241  NRF_STATIC_INLINE void nrf_ppi_task_trigger(NRF_PPI_Type * p_reg, nrf_ppi_task_t ppi_task)
242  {
243      *((volatile uint32_t *) ((uint8_t *) p_reg + (uint32_t) ppi_task)) = 1UL;
244  }
245  NRF_STATIC_INLINE uint32_t nrf_ppi_task_address_get(NRF_PPI_Type const * p_reg,
246                                                      nrf_ppi_task_t       ppi_task)
247  {
248      return (uint32_t) ((uint8_t *) p_reg + (uint32_t) ppi_task);
249  }
250  NRF_STATIC_INLINE uint32_t nrf_ppi_task_group_enable_address_get(NRF_PPI_Type const *    p_reg,
251                                                                   nrf_ppi_channel_group_t group)
252  {
253      return (uint32_t) &p_reg->TASKS_CHG[(uint32_t) group].EN;
254  }
255  NRF_STATIC_INLINE uint32_t nrf_ppi_task_group_disable_address_get(NRF_PPI_Type const *    p_reg,
256                                                                    nrf_ppi_channel_group_t group)
257  {
258      return (uint32_t) &p_reg->TASKS_CHG[(uint32_t) group].DIS;
259  }
260  NRF_STATIC_INLINE nrf_ppi_task_t nrf_ppi_group_enable_task_get(NRF_PPI_Type const * p_reg,
261                                                                 uint8_t              index)
262  {
263      NRFX_ASSERT(index < PPI_GROUP_NUM);
264      return (nrf_ppi_task_t)NRFX_OFFSETOF(NRF_PPI_Type, TASKS_CHG[index].EN);
265  }
266  NRF_STATIC_INLINE nrf_ppi_task_t nrf_ppi_group_disable_task_get(NRF_PPI_Type const * p_reg,
267                                                                  uint8_t              index)
268  {
269      NRFX_ASSERT(index < PPI_GROUP_NUM);
270      return (nrf_ppi_task_t)NRFX_OFFSETOF(NRF_PPI_Type, TASKS_CHG[index].DIS);
271  }
272  #endif 
273  #ifdef __cplusplus
274  }
275  #endif
276  #endif 
</code></pre>
        </div>
        <div class="column">
            <h3>libtomcrypt-MDEwOlJlcG9zaXRvcnk3NzcwMTE=-flat-rabbit.c</h3>
            <pre><code>1  #include "tomcrypt_private.h"
2  #ifdef LTC_RABBIT
3  static LTC_INLINE ulong32 ss_rabbit_g_func(ulong32 x);
4  static LTC_INLINE void ss_rabbit_next_state(rabbit_ctx *p_instance);
5  static LTC_INLINE void ss_rabbit_gen_1_block(rabbit_state* st, unsigned char *out);
6  static LTC_INLINE ulong32 ss_rabbit_g_func(ulong32 x)
7  {
8     ulong32 a, b, h, l;
9     a = x &  0xFFFF;
10     b = x >> 16;
11     h = ((((ulong32)(a*a)>>17) + (ulong32)(a*b))>>15) + b*b;
12     l = x * x;
13     return (ulong32)(h^l);
14  }
15  static LTC_INLINE void ss_rabbit_next_state(rabbit_ctx *p_instance)
16  {
17     ulong32 g[8], c_old[8], i;
18     for (i=0; i<8; i++) {
19        c_old[i] = p_instance->c[i];
20     }
21     p_instance->c[0] = (ulong32)(p_instance->c[0] + 0x4D34D34D + p_instance->carry);
22     p_instance->c[1] = (ulong32)(p_instance->c[1] + 0xD34D34D3 + (p_instance->c[0] < c_old[0]));
23     p_instance->c[2] = (ulong32)(p_instance->c[2] + 0x34D34D34 + (p_instance->c[1] < c_old[1]));
24     p_instance->c[3] = (ulong32)(p_instance->c[3] + 0x4D34D34D + (p_instance->c[2] < c_old[2]));
25     p_instance->c[4] = (ulong32)(p_instance->c[4] + 0xD34D34D3 + (p_instance->c[3] < c_old[3]));
26     p_instance->c[5] = (ulong32)(p_instance->c[5] + 0x34D34D34 + (p_instance->c[4] < c_old[4]));
27     p_instance->c[6] = (ulong32)(p_instance->c[6] + 0x4D34D34D + (p_instance->c[5] < c_old[5]));
28     p_instance->c[7] = (ulong32)(p_instance->c[7] + 0xD34D34D3 + (p_instance->c[6] < c_old[6]));
29     p_instance->carry = (p_instance->c[7] < c_old[7]);
30     for (i=0;i<8;i++) {
31        g[i] = ss_rabbit_g_func((ulong32)(p_instance->x[i] + p_instance->c[i]));
32     }
33     p_instance->x[0] = (ulong32)(g[0] + ROLc(g[7],16) + ROLc(g[6], 16));
34     p_instance->x[1] = (ulong32)(g[1] + ROLc(g[0], 8) + g[7]);
35     p_instance->x[2] = (ulong32)(g[2] + ROLc(g[1],16) + ROLc(g[0], 16));
36     p_instance->x[3] = (ulong32)(g[3] + ROLc(g[2], 8) + g[1]);
37     p_instance->x[4] = (ulong32)(g[4] + ROLc(g[3],16) + ROLc(g[2], 16));
38     p_instance->x[5] = (ulong32)(g[5] + ROLc(g[4], 8) + g[3]);
39     p_instance->x[6] = (ulong32)(g[6] + ROLc(g[5],16) + ROLc(g[4], 16));
40     p_instance->x[7] = (ulong32)(g[7] + ROLc(g[6], 8) + g[5]);
41  }
42  static LTC_INLINE void ss_rabbit_gen_1_block(rabbit_state* st, unsigned char *out)
43  {
44      ulong32 *ptr;
45      ss_rabbit_next_state(&(st->work_ctx));
46      ptr = (ulong32*)&(st->work_ctx.x);
47      STORE32L((ptr[0] ^ (ptr[5]>>16) ^ (ulong32)(ptr[3]<<16)), out+ 0);
48      STORE32L((ptr[2] ^ (ptr[7]>>16) ^ (ulong32)(ptr[5]<<16)), out+ 4);
49      STORE32L((ptr[4] ^ (ptr[1]>>16) ^ (ulong32)(ptr[7]<<16)), out+ 8);
50      STORE32L((ptr[6] ^ (ptr[3]>>16) ^ (ulong32)(ptr[1]<<16)), out+12);
51  }
52  int rabbit_setup(rabbit_state* st, const unsigned char *key, unsigned long keylen)
53  {
54     ulong32 k0, k1, k2, k3, i;
55     unsigned char  tmpkey[16] = {0};
56     LTC_ARGCHK(st != NULL);
57     LTC_ARGCHK(key != NULL);
58     LTC_ARGCHK(keylen <= 16);
59     XMEMSET(st, 0, sizeof(rabbit_state));
60     XMEMCPY(tmpkey, key, keylen);
61     LOAD32L(k0, tmpkey+ 0);
62     LOAD32L(k1, tmpkey+ 4);
63     LOAD32L(k2, tmpkey+ 8);
64     LOAD32L(k3, tmpkey+12);
65  #ifdef LTC_CLEAN_STACK
66     zeromem(tmpkey, sizeof(tmpkey));
67  #endif
<span onclick='openModal()' class='match'>68     st->master_ctx.x[0] = k0;
69     st->master_ctx.x[2] = k1;
70     st->master_ctx.x[4] = k2;
71     st->master_ctx.x[6] = k3;
72     st->master_ctx.x[1] = (ulong32)(k3<<16) | (k2>>16);
73     st->master_ctx.x[3] = (ulong32)(k0<<16) | (k3>>16);
74     st->master_ctx.x[5] = (ulong32)(k1<<16) | (k0>>16);
75     st->master_ctx.x[7] = (ulong32)(k2<<16) | (k1>>16);
76     st->master_ctx.c[0] = ROLc(k2, 16);
77     st->master_ctx.c[2] = ROLc(k3, 16);
78     st->master_ctx.c[4] = ROLc(k0, 16);
79     st->master_ctx.c[6] = ROLc(k1, 16);
80     st->master_ctx.c[1] = (k0&0xFFFF0000) | (k1&0xFFFF);
81     st->master_ctx.c[3] = (k1&0xFFFF0000) | (k2&0xFFFF);
82     st->master_ctx.c[5] = (k2&0xFFFF0000) | (k3&0xFFFF);
83     st->master_ctx.c[7] = (k3&0xFFFF0000) | (k0&0xFFFF);
84     st->master_ctx.carry = 0;
</span>85     for (i=0; i<4; i++) {
86        ss_rabbit_next_state(&(st->master_ctx));
87     }
88     for (i=0; i<8; i++) {
89        st->master_ctx.c[i] ^= st->master_ctx.x[(i+4)&0x7];
90     }
91     for (i=0; i<8; i++) {
92        st->work_ctx.x[i] = st->master_ctx.x[i];
93        st->work_ctx.c[i] = st->master_ctx.c[i];
94     }
95     st->work_ctx.carry = st->master_ctx.carry;
96     XMEMSET(&(st->block), 0, sizeof(st->block));
97     st->unused = 0;
98     return CRYPT_OK;
99  }
100  int rabbit_setiv(rabbit_state* st, const unsigned char *iv, unsigned long ivlen)
101  {
102     ulong32 i0, i1, i2, i3, i;
103     unsigned char  tmpiv[8] = {0};
104     LTC_ARGCHK(st != NULL);
105     LTC_ARGCHK(iv != NULL || ivlen == 0);
106     LTC_ARGCHK(ivlen <= 8);
107     if (iv && ivlen > 0) XMEMCPY(tmpiv, iv, ivlen);
108     LOAD32L(i0, tmpiv+0);
109     LOAD32L(i2, tmpiv+4);
110     i1 = (i0>>16) | (i2&0xFFFF0000);
111     i3 = (i2<<16) | (i0&0x0000FFFF);
112     st->work_ctx.c[0] = st->master_ctx.c[0] ^ i0;
113     st->work_ctx.c[1] = st->master_ctx.c[1] ^ i1;
114     st->work_ctx.c[2] = st->master_ctx.c[2] ^ i2;
115     st->work_ctx.c[3] = st->master_ctx.c[3] ^ i3;
116     st->work_ctx.c[4] = st->master_ctx.c[4] ^ i0;
117     st->work_ctx.c[5] = st->master_ctx.c[5] ^ i1;
118     st->work_ctx.c[6] = st->master_ctx.c[6] ^ i2;
119     st->work_ctx.c[7] = st->master_ctx.c[7] ^ i3;
120     for (i=0; i<8; i++) {
121        st->work_ctx.x[i] = st->master_ctx.x[i];
122     }
123     st->work_ctx.carry = st->master_ctx.carry;
124     for (i=0; i<4; i++) {
125        ss_rabbit_next_state(&(st->work_ctx));
126     }
127     XMEMSET(&(st->block), 0, sizeof(st->block));
128     st->unused = 0;
129     return CRYPT_OK;
130  }
131  int rabbit_crypt(rabbit_state* st, const unsigned char *in, unsigned long inlen, unsigned char *out)
132  {
133     unsigned char buf[16];
134     unsigned long i, j;
135     if (inlen == 0) return CRYPT_OK; &bsol;* nothing to do */
136     LTC_ARGCHK(st        != NULL);
137     LTC_ARGCHK(in        != NULL);
138     LTC_ARGCHK(out       != NULL);
139     if (st->unused > 0) {
140        j = MIN(st->unused, inlen);
141        for (i = 0; i < j; ++i, st->unused--) out[i] = in[i] ^ st->block[16 - st->unused];
142        inlen -= j;
143        if (inlen == 0) return CRYPT_OK;
144        out += j;
145        in  += j;
146     }
147     for (;;) {
148       ss_rabbit_gen_1_block(st, buf);
149       if (inlen <= 16) {
150         for (i = 0; i < inlen; ++i) out[i] = in[i] ^ buf[i];
151         st->unused = 16 - inlen;
152         for (i = inlen; i < 16; ++i) st->block[i] = buf[i];
153         return CRYPT_OK;
154       }
155       for (i = 0; i < 16; ++i) out[i] = in[i] ^ buf[i];
156       inlen -= 16;
157       out += 16;
158       in  += 16;
159     }
160  }
161  int rabbit_keystream(rabbit_state *st, unsigned char *out, unsigned long outlen)
162  {
163     if (outlen == 0) return CRYPT_OK; &bsol;* nothing to do */
164     LTC_ARGCHK(out != NULL);
165     XMEMSET(out, 0, outlen);
166     return rabbit_crypt(st, out, outlen, out);
167  }
168  int rabbit_done(rabbit_state *st)
169  {
170     LTC_ARGCHK(st != NULL);
171     zeromem(st, sizeof(rabbit_state));
172     return CRYPT_OK;
173  }
174  int rabbit_test(void)
175  {
176  #ifndef LTC_TEST
177     return CRYPT_NOP;
178  #else
179     rabbit_state st;
180     int err;
181     unsigned char out[1000] = { 0 };
182     {
183        {
184           unsigned char k[]  = { 0x0F, 0x62, 0xB5, 0x08, 0x5B, 0xAE, 0x01, 0x54,
185                                  0xA7, 0xFA, 0x4D, 0xA0, 0xF3, 0x46, 0x99, 0xEC };
186           unsigned char iv[] = { 0x28, 0x8F, 0xF6, 0x5D, 0xC4, 0x2B, 0x92, 0xF9 };
187           char pt[64]        = { 0 };
188           unsigned char ct[] = { 0x61, 0x3C, 0xB0, 0xBA, 0x96, 0xAF, 0xF6, 0xCA,
189                                  0xCF, 0x2A, 0x45, 0x9A, 0x10, 0x2A, 0x7F, 0x78,
190                                  0xCA, 0x98, 0x5C, 0xF8, 0xFD, 0xD1, 0x47, 0x40,
191                                  0x18, 0x75, 0x8E, 0x36, 0xAE, 0x99, 0x23, 0xF5,
192                                  0x19, 0xD1, 0x3D, 0x71, 0x8D, 0xAF, 0x8D, 0x7C,
193                                  0x0C, 0x10, 0x9B, 0x79, 0xD5, 0x74, 0x94, 0x39,
194                                  0xB7, 0xEF, 0xA4, 0xC4, 0xC9, 0xC8, 0xD2, 0x9D,
195                                  0xC5, 0xB3, 0x88, 0x83, 0x14, 0xA6, 0x81, 0x6F };
196           unsigned long ptlen = sizeof(pt);
197           if ((err = rabbit_setup(&st, k, sizeof(k)))                   != CRYPT_OK) return err;
198           if ((err = rabbit_setiv(&st, iv, sizeof(iv)))                 != CRYPT_OK) return err;
199           if ((err = rabbit_crypt(&st, (unsigned char*)pt, ptlen, out)) != CRYPT_OK) return err;
200           if (compare_testvector(out, ptlen, ct, ptlen, "RABBIT-TV1", 1))   return CRYPT_FAIL_TESTVECTOR;
201        }
202        {
203           unsigned char k[]  = { 0x0F, 0x62, 0xB5, 0x08, 0x5B, 0xAE, 0x01, 0x54,
204                                  0xA7, 0xFA, 0x4D, 0xA0, 0xF3, 0x46, 0x99, 0xEC };
205           unsigned char iv[] = { 0x28, 0x8F, 0xF6, 0x5D, 0xC4, 0x2B, 0x92, 0xF9 };
206           char          pt[39] = { 0 };
207           unsigned char ct[] = { 0x61, 0x3C, 0xB0, 0xBA,   0x96, 0xAF, 0xF6, 0xCA,
208                                  0xCF, 0x2A, 0x45, 0x9A,   0x10, 0x2A, 0x7F, 0x78,
209                                  0xCA, 0x98, 0x5C, 0xF8,   0xFD, 0xD1, 0x47, 0x40,
210                                  0x18, 0x75, 0x8E, 0x36,   0xAE, 0x99, 0x23, 0xF5,
211                                  0x19, 0xD1, 0x3D, 0x71,   0x8D, 0xAF, 0x8D };
212           unsigned long ptlen = sizeof(pt);
213           if ((err = rabbit_setup(&st, k, sizeof(k)))                          != CRYPT_OK) return err;
214           if ((err = rabbit_setiv(&st, iv, sizeof(iv)))                        != CRYPT_OK) return err;
215           if ((err = rabbit_crypt(&st, (unsigned char*)pt,       5, out))      != CRYPT_OK) return err;
216           if ((err = rabbit_crypt(&st, (unsigned char*)pt +  5, 11, out +  5)) != CRYPT_OK) return err;
217           if ((err = rabbit_crypt(&st, (unsigned char*)pt + 16, 14, out + 16)) != CRYPT_OK) return err;
218           if ((err = rabbit_crypt(&st, (unsigned char*)pt + 30,  2, out + 30)) != CRYPT_OK) return err;
219           if ((err = rabbit_crypt(&st, (unsigned char*)pt + 32,  7, out + 32)) != CRYPT_OK) return err;
220           if (compare_testvector(out, ptlen, ct, ptlen, "RABBIT-TV2", 1))   return CRYPT_FAIL_TESTVECTOR;
221        }
222        {
223           unsigned char k[]  = { 0x0F, 0x62, 0xB5, 0x08, 0x5B, 0xAE, 0x01, 0x54,
224                                  0xA7, 0xFA, 0x4D, 0xA0, 0xF3, 0x46, 0x99, 0xEC };
225           unsigned char iv[] = { 0x28, 0x8F, 0xF6, 0x5D, 0xC4, 0x2B, 0x92, 0xF9 };
226           char          pt[] = "Kilroy was here, there, and everywhere!";
227           unsigned char ct[] = { 0x2a, 0x55, 0xdc, 0xc8,   0xf9, 0xd6, 0xd6, 0xbd,
228                                  0xae, 0x59, 0x65, 0xf2,   0x75, 0x58, 0x1a, 0x54,
229                                  0xea, 0xec, 0x34, 0x9d,   0x8f, 0xb4, 0x6b, 0x60,
230                                  0x79, 0x1b, 0xea, 0x16,   0xcb, 0xef, 0x46, 0x87,
231                                  0x60, 0xa6, 0x55, 0x14,   0xff, 0xca, 0xac };
232           unsigned long ptlen = XSTRLEN(pt);
233           unsigned char out2[1000] = { 0 };
234           unsigned char nulls[1000] = { 0 };
235           if ((err = rabbit_setup(&st, k, sizeof(k)))                          != CRYPT_OK) return err;
236           if ((err = rabbit_setiv(&st, iv, sizeof(iv)))                        != CRYPT_OK) return err;
237           if ((err = rabbit_crypt(&st, (unsigned char*)pt,       5, out))      != CRYPT_OK) return err;
238           if ((err = rabbit_crypt(&st, (unsigned char*)pt +  5, 29, out +  5)) != CRYPT_OK) return err;
239           if ((err = rabbit_crypt(&st, (unsigned char*)pt + 34,  5, out + 34)) != CRYPT_OK) return err;
240           if (compare_testvector(out, ptlen, ct, ptlen, "RABBIT-TV3", 1))   return CRYPT_FAIL_TESTVECTOR;
241           if ((err = rabbit_memory(k, sizeof(k), iv, sizeof(iv),
242                                     (unsigned char*)pt, sizeof(pt), out))      != CRYPT_OK) return err;
243           if (compare_testvector(out, ptlen, ct, ptlen, "RABBIT-TV4", 1))   return CRYPT_FAIL_TESTVECTOR;
244           if ((err = rabbit_setiv(&st, iv, sizeof(iv)))                        != CRYPT_OK) return err;
245           if ((err = rabbit_crypt(&st, out, ptlen, out2))                      != CRYPT_OK) return err;
246           if (compare_testvector(out2, ptlen, pt, ptlen, "RABBIT-TV5", 1))  return CRYPT_FAIL_TESTVECTOR;
247           if ((err = rabbit_done(&st))                      != CRYPT_OK) return err;
248           if (compare_testvector(&st, sizeof(st), nulls, sizeof(st), "RABBIT-TV6", 1))  return CRYPT_FAIL_TESTVECTOR;
249        }
250        return CRYPT_OK;
251     }
252  #endif
253  }
254  #endif
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from Adafruit_nRF52_Arduino-MDEwOlJlcG9zaXRvcnk3NDM1NDcyOQ==-flat-nrf_ppi.h</div>
                <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from libtomcrypt-MDEwOlJlcG9zaXRvcnk3NzcwMTE=-flat-rabbit.c</div>
                <div class="column column_space"><pre><code>9      NRF_PPI_CHANNEL0  = PPI_CHEN_CH0_Pos,  &bsol;**< Channel 0. */
10      NRF_PPI_CHANNEL1  = PPI_CHEN_CH1_Pos,  &bsol;**< Channel 1. */
11      NRF_PPI_CHANNEL2  = PPI_CHEN_CH2_Pos,  &bsol;**< Channel 2. */
12      NRF_PPI_CHANNEL3  = PPI_CHEN_CH3_Pos,  &bsol;**< Channel 3. */
13      NRF_PPI_CHANNEL4  = PPI_CHEN_CH4_Pos,  &bsol;**< Channel 4. */
14      NRF_PPI_CHANNEL5  = PPI_CHEN_CH5_Pos,  &bsol;**< Channel 5. */
15      NRF_PPI_CHANNEL6  = PPI_CHEN_CH6_Pos,  &bsol;**< Channel 6. */
16      NRF_PPI_CHANNEL7  = PPI_CHEN_CH7_Pos,  &bsol;**< Channel 7. */
17      NRF_PPI_CHANNEL8  = PPI_CHEN_CH8_Pos,  &bsol;**< Channel 8. */
18      NRF_PPI_CHANNEL9  = PPI_CHEN_CH9_Pos,  &bsol;**< Channel 9. */
19      NRF_PPI_CHANNEL10 = PPI_CHEN_CH10_Pos, &bsol;**< Channel 10. */
20      NRF_PPI_CHANNEL11 = PPI_CHEN_CH11_Pos, &bsol;**< Channel 11. */
21      NRF_PPI_CHANNEL12 = PPI_CHEN_CH12_Pos, &bsol;**< Channel 12. */
22      NRF_PPI_CHANNEL13 = PPI_CHEN_CH13_Pos, &bsol;**< Channel 13. */
23      NRF_PPI_CHANNEL14 = PPI_CHEN_CH14_Pos, &bsol;**< Channel 14. */
24      NRF_PPI_CHANNEL15 = PPI_CHEN_CH15_Pos, &bsol;**< Channel 15. */
25  #if (PPI_CH_NUM > 16) || defined(__NRFX_DOXYGEN__)
26      NRF_PPI_CHANNEL16 = PPI_CHEN_CH16_Pos, &bsol;**< Channel 16. */
</pre></code></div>
                <div class="column column_space"><pre><code>68     st->master_ctx.x[0] = k0;
69     st->master_ctx.x[2] = k1;
70     st->master_ctx.x[4] = k2;
71     st->master_ctx.x[6] = k3;
72     st->master_ctx.x[1] = (ulong32)(k3<<16) | (k2>>16);
73     st->master_ctx.x[3] = (ulong32)(k0<<16) | (k3>>16);
74     st->master_ctx.x[5] = (ulong32)(k1<<16) | (k0>>16);
75     st->master_ctx.x[7] = (ulong32)(k2<<16) | (k1>>16);
76     st->master_ctx.c[0] = ROLc(k2, 16);
77     st->master_ctx.c[2] = ROLc(k3, 16);
78     st->master_ctx.c[4] = ROLc(k0, 16);
79     st->master_ctx.c[6] = ROLc(k1, 16);
80     st->master_ctx.c[1] = (k0&0xFFFF0000) | (k1&0xFFFF);
81     st->master_ctx.c[3] = (k1&0xFFFF0000) | (k2&0xFFFF);
82     st->master_ctx.c[5] = (k2&0xFFFF0000) | (k3&0xFFFF);
83     st->master_ctx.c[7] = (k3&0xFFFF0000) | (k0&0xFFFF);
84     st->master_ctx.carry = 0;
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    