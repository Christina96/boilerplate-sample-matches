
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 58, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>redis-MDEwOlJlcG9zaXRvcnkxMDgxMTA3MDY=-flat-lvm.c</h3>
            <pre><code>1  #include <stdio.h>
2  #include <stdlib.h>
3  #include <string.h>
4  #define lvm_c
5  #define LUA_CORE
6  #include "lua.h"
7  #include "ldebug.h"
8  #include "ldo.h"
9  #include "lfunc.h"
10  #include "lgc.h"
11  #include "lobject.h"
12  #include "lopcodes.h"
13  #include "lstate.h"
14  #include "lstring.h"
15  #include "ltable.h"
16  #include "ltm.h"
17  #include "lvm.h"
18  #define MAXTAGLOOP	100
19  const TValue *luaV_tonumber (const TValue *obj, TValue *n) {
20    lua_Number num;
21    if (ttisnumber(obj)) return obj;
22    if (ttisstring(obj) && luaO_str2d(svalue(obj), &num)) {
23      setnvalue(n, num);
24      return n;
25    }
26    else
27      return NULL;
28  }
29  int luaV_tostring (lua_State *L, StkId obj) {
30    if (!ttisnumber(obj))
31      return 0;
32    else {
33      char s[LUAI_MAXNUMBER2STR];
34      lua_Number n = nvalue(obj);
35      lua_number2str(s, n);
36      setsvalue2s(L, obj, luaS_new(L, s));
37      return 1;
38    }
39  }
40  static void traceexec (lua_State *L, const Instruction *pc) {
41    lu_byte mask = L->hookmask;
42    const Instruction *oldpc = L->savedpc;
43    L->savedpc = pc;
44    if ((mask & LUA_MASKCOUNT) && L->hookcount == 0) {
45      resethookcount(L);
46      luaD_callhook(L, LUA_HOOKCOUNT, -1);
47    }
48    if (mask & LUA_MASKLINE) {
49      Proto *p = ci_func(L->ci)->l.p;
50      int npc = pcRel(pc, p);
51      int newline = getline(p, npc);
52      if (npc == 0 || pc <= oldpc || newline != getline(p, pcRel(oldpc, p)))
53        luaD_callhook(L, LUA_HOOKLINE, newline);
54    }
55  }
56  static void callTMres (lua_State *L, StkId res, const TValue *f,
57                          const TValue *p1, const TValue *p2) {
58    ptrdiff_t result = savestack(L, res);
59    setobj2s(L, L->top, f);  &bsol;* push function */
60    setobj2s(L, L->top+1, p1);  &bsol;* 1st argument */
61    setobj2s(L, L->top+2, p2);  &bsol;* 2nd argument */
62    luaD_checkstack(L, 3);
63    L->top += 3;
64    luaD_call(L, L->top - 3, 1);
65    res = restorestack(L, result);
66    L->top--;
67    setobjs2s(L, res, L->top);
68  }
69  static void callTM (lua_State *L, const TValue *f, const TValue *p1,
70                      const TValue *p2, const TValue *p3) {
71    setobj2s(L, L->top, f);  &bsol;* push function */
72    setobj2s(L, L->top+1, p1);  &bsol;* 1st argument */
73    setobj2s(L, L->top+2, p2);  &bsol;* 2nd argument */
74    setobj2s(L, L->top+3, p3);  &bsol;* 3th argument */
75    luaD_checkstack(L, 4);
76    L->top += 4;
77    luaD_call(L, L->top - 4, 0);
78  }
79  void luaV_gettable (lua_State *L, const TValue *t, TValue *key, StkId val) {
80    int loop;
81    for (loop = 0; loop < MAXTAGLOOP; loop++) {
82      const TValue *tm;
83      if (ttistable(t)) {  &bsol;* `t' is a table? */
84        Table *h = hvalue(t);
85        const TValue *res = luaH_get(h, key); &bsol;* do a primitive get */
86        if (!ttisnil(res) ||  &bsol;* result is no nil? */
87            (tm = fasttm(L, h->metatable, TM_INDEX)) == NULL) { &bsol;* or no TM? */
88          setobj2s(L, val, res);
89          return;
90        }
91      }
92      else if (ttisnil(tm = luaT_gettmbyobj(L, t, TM_INDEX)))
93        luaG_typeerror(L, t, "index");
94      if (ttisfunction(tm)) {
95        callTMres(L, val, tm, t, key);
96        return;
97      }
98      t = tm;  &bsol;* else repeat with `tm' */ 
99    }
100    luaG_runerror(L, "loop in gettable");
101  }
102  void luaV_settable (lua_State *L, const TValue *t, TValue *key, StkId val) {
103    int loop;
104    TValue temp;
105    for (loop = 0; loop < MAXTAGLOOP; loop++) {
106      const TValue *tm;
107      if (ttistable(t)) {  &bsol;* `t' is a table? */
108        Table *h = hvalue(t);
109        TValue *oldval = luaH_set(L, h, key); &bsol;* do a primitive set */
110        if (!ttisnil(oldval) ||  &bsol;* result is no nil? */
111            (tm = fasttm(L, h->metatable, TM_NEWINDEX)) == NULL) { &bsol;* or no TM? */
112          setobj2t(L, oldval, val);
113          h->flags = 0;
114          luaC_barriert(L, h, val);
115          return;
116        }
117      }
118      else if (ttisnil(tm = luaT_gettmbyobj(L, t, TM_NEWINDEX)))
119        luaG_typeerror(L, t, "index");
120      if (ttisfunction(tm)) {
121        callTM(L, tm, t, key, val);
122        return;
123      }
124      setobj(L, &temp, tm);  &bsol;* avoid pointing inside table (may rehash) */
125      t = &temp;
126    }
127    luaG_runerror(L, "loop in settable");
128  }
129  static int call_binTM (lua_State *L, const TValue *p1, const TValue *p2,
130                         StkId res, TMS event) {
131    const TValue *tm = luaT_gettmbyobj(L, p1, event);  &bsol;* try first operand */
132    if (ttisnil(tm))
133      tm = luaT_gettmbyobj(L, p2, event);  &bsol;* try second operand */
134    if (ttisnil(tm)) return 0;
135    callTMres(L, res, tm, p1, p2);
136    return 1;
137  }
138  static const TValue *get_compTM (lua_State *L, Table *mt1, Table *mt2,
139                                    TMS event) {
140    const TValue *tm1 = fasttm(L, mt1, event);
141    const TValue *tm2;
142    if (tm1 == NULL) return NULL;  &bsol;* no metamethod */
143    if (mt1 == mt2) return tm1;  &bsol;* same metatables => same metamethods */
144    tm2 = fasttm(L, mt2, event);
145    if (tm2 == NULL) return NULL;  &bsol;* no metamethod */
146    if (luaO_rawequalObj(tm1, tm2))  &bsol;* same metamethods? */
147      return tm1;
148    return NULL;
149  }
150  static int call_orderTM (lua_State *L, const TValue *p1, const TValue *p2,
151                           TMS event) {
152    const TValue *tm1 = luaT_gettmbyobj(L, p1, event);
153    const TValue *tm2;
154    if (ttisnil(tm1)) return -1;  &bsol;* no metamethod? */
155    tm2 = luaT_gettmbyobj(L, p2, event);
156    if (!luaO_rawequalObj(tm1, tm2))  &bsol;* different metamethods? */
157      return -1;
158    callTMres(L, L->top, tm1, p1, p2);
159    return !l_isfalse(L->top);
160  }
161  static int l_strcmp (const TString *ls, const TString *rs) {
162    const char *l = getstr(ls);
163    size_t ll = ls->tsv.len;
164    const char *r = getstr(rs);
165    size_t lr = rs->tsv.len;
166    for (;;) {
167      int temp = strcoll(l, r);
168      if (temp != 0) return temp;
169      else {  &bsol;* strings are equal up to a `\0' */
170        size_t len = strlen(l);  &bsol;* index of first `\0' in both strings */
171        if (len == lr)  &bsol;* r is finished? */
172          return (len == ll) ? 0 : 1;
173        else if (len == ll)  &bsol;* l is finished? */
174          return -1;  &bsol;* l is smaller than r (because r is not finished) */
175        len++;
176        l += len; ll -= len; r += len; lr -= len;
177      }
178    }
179  }
180  int luaV_lessthan (lua_State *L, const TValue *l, const TValue *r) {
181    int res;
182    if (ttype(l) != ttype(r))
183      return luaG_ordererror(L, l, r);
184    else if (ttisnumber(l))
185      return luai_numlt(nvalue(l), nvalue(r));
186    else if (ttisstring(l))
187      return l_strcmp(rawtsvalue(l), rawtsvalue(r)) < 0;
188    else if ((res = call_orderTM(L, l, r, TM_LT)) != -1)
189      return res;
190    return luaG_ordererror(L, l, r);
191  }
192  static int lessequal (lua_State *L, const TValue *l, const TValue *r) {
193    int res;
194    if (ttype(l) != ttype(r))
195      return luaG_ordererror(L, l, r);
196    else if (ttisnumber(l))
197      return luai_numle(nvalue(l), nvalue(r));
198    else if (ttisstring(l))
199      return l_strcmp(rawtsvalue(l), rawtsvalue(r)) <= 0;
200    else if ((res = call_orderTM(L, l, r, TM_LE)) != -1)  &bsol;* first try `le' */
201      return res;
202    else if ((res = call_orderTM(L, r, l, TM_LT)) != -1)  &bsol;* else try `lt' */
203      return !res;
204    return luaG_ordererror(L, l, r);
205  }
206  int luaV_equalval (lua_State *L, const TValue *t1, const TValue *t2) {
207    const TValue *tm;
208    lua_assert(ttype(t1) == ttype(t2));
209    switch (ttype(t1)) {
210      case LUA_TNIL: return 1;
211      case LUA_TNUMBER: return luai_numeq(nvalue(t1), nvalue(t2));
212      case LUA_TBOOLEAN: return bvalue(t1) == bvalue(t2);  &bsol;* true must be 1 !! */
213      case LUA_TLIGHTUSERDATA: return pvalue(t1) == pvalue(t2);
214      case LUA_TUSERDATA: {
215        if (uvalue(t1) == uvalue(t2)) return 1;
216        tm = get_compTM(L, uvalue(t1)->metatable, uvalue(t2)->metatable,
217                           TM_EQ);
218        break;  &bsol;* will try TM */
219      }
220      case LUA_TTABLE: {
221        if (hvalue(t1) == hvalue(t2)) return 1;
222        tm = get_compTM(L, hvalue(t1)->metatable, hvalue(t2)->metatable, TM_EQ);
223        break;  &bsol;* will try TM */
224      }
225      default: return gcvalue(t1) == gcvalue(t2);
226    }
227    if (tm == NULL) return 0;  &bsol;* no TM? */
228    callTMres(L, L->top, tm, t1, t2);  &bsol;* call TM */
229    return !l_isfalse(L->top);
230  }
231  void luaV_concat (lua_State *L, int total, int last) {
232    do {
233      StkId top = L->base + last + 1;
234      int n = 2;  &bsol;* number of elements handled in this pass (at least 2) */
235      if (!(ttisstring(top-2) || ttisnumber(top-2)) || !tostring(L, top-1)) {
236        if (!call_binTM(L, top-2, top-1, top-2, TM_CONCAT))
237          luaG_concaterror(L, top-2, top-1);
238      } else if (tsvalue(top-1)->len == 0)  &bsol;* second op is empty? */
239        (void)tostring(L, top - 2);  &bsol;* result is first op (as string) */
240      else {
241        size_t tl = tsvalue(top-1)->len;
242        char *buffer;
243        int i;
244        for (n = 1; n < total && tostring(L, top-n-1); n++) {
245          size_t l = tsvalue(top-n-1)->len;
246          if (l >= MAX_SIZET - tl) luaG_runerror(L, "string length overflow");
247          tl += l;
248        }
249        buffer = luaZ_openspace(L, &G(L)->buff, tl);
250        tl = 0;
251        for (i=n; i>0; i--) {  &bsol;* concat all strings */
252          size_t l = tsvalue(top-i)->len;
253          memcpy(buffer+tl, svalue(top-i), l);
254          tl += l;
255        }
256        setsvalue2s(L, top-n, luaS_newlstr(L, buffer, tl));
257      }
258      total -= n-1;  &bsol;* got `n' strings to create 1 new */
259      last -= n-1;
260    } while (total > 1);  &bsol;* repeat until only 1 result left */
261  }
262  static void Arith (lua_State *L, StkId ra, const TValue *rb,
263                     const TValue *rc, TMS op) {
264    TValue tempb, tempc;
265    const TValue *b, *c;
266    if ((b = luaV_tonumber(rb, &tempb)) != NULL &&
267        (c = luaV_tonumber(rc, &tempc)) != NULL) {
268      lua_Number nb = nvalue(b), nc = nvalue(c);
269      switch (op) {
270        case TM_ADD: setnvalue(ra, luai_numadd(nb, nc)); break;
271        case TM_SUB: setnvalue(ra, luai_numsub(nb, nc)); break;
272        case TM_MUL: setnvalue(ra, luai_nummul(nb, nc)); break;
273        case TM_DIV: setnvalue(ra, luai_numdiv(nb, nc)); break;
274        case TM_MOD: setnvalue(ra, luai_nummod(nb, nc)); break;
275        case TM_POW: setnvalue(ra, luai_numpow(nb, nc)); break;
276        case TM_UNM: setnvalue(ra, luai_numunm(nb)); break;
277        default: lua_assert(0); break;
278      }
279    }
280    else if (!call_binTM(L, rb, rc, ra, op))
281      luaG_aritherror(L, rb, rc);
282  }
283  #define runtime_check(L, c)	{ if (!(c)) break; }
284  #define RA(i)	(base+GETARG_A(i))
285  #define RB(i)	check_exp(getBMode(GET_OPCODE(i)) == OpArgR, base+GETARG_B(i))
286  #define RC(i)	check_exp(getCMode(GET_OPCODE(i)) == OpArgR, base+GETARG_C(i))
287  #define RKB(i)	check_exp(getBMode(GET_OPCODE(i)) == OpArgK, \
288  	ISK(GETARG_B(i)) ? k+INDEXK(GETARG_B(i)) : base+GETARG_B(i))
289  #define RKC(i)	check_exp(getCMode(GET_OPCODE(i)) == OpArgK, \
290  	ISK(GETARG_C(i)) ? k+INDEXK(GETARG_C(i)) : base+GETARG_C(i))
291  #define KBx(i)	check_exp(getBMode(GET_OPCODE(i)) == OpArgK, k+GETARG_Bx(i))
292  #define dojump(L,pc,i)	{(pc) += (i); luai_threadyield(L);}
293  #define Protect(x)	{ L->savedpc = pc; {x;}; base = L->base; }
294  #define arith_op(op,tm) { \
295          TValue *rb = RKB(i); \
296          TValue *rc = RKC(i); \
297          if (ttisnumber(rb) && ttisnumber(rc)) { \
298            lua_Number nb = nvalue(rb), nc = nvalue(rc); \
299            setnvalue(ra, op(nb, nc)); \
300          } \
301          else \
302            Protect(Arith(L, ra, rb, rc, tm)); \
303        }
304  void luaV_execute (lua_State *L, int nexeccalls) {
305    LClosure *cl;
306    StkId base;
307    TValue *k;
308    const Instruction *pc;
309   reentry:  &bsol;* entry point */
310    lua_assert(isLua(L->ci));
311    pc = L->savedpc;
312    cl = &clvalue(L->ci->func)->l;
313    base = L->base;
314    k = cl->p->k;
315    for (;;) {
316      const Instruction i = *pc++;
317      StkId ra;
318      if ((L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT)) &&
319          (--L->hookcount == 0 || L->hookmask & LUA_MASKLINE)) {
320        traceexec(L, pc);
321        if (L->status == LUA_YIELD) {  &bsol;* did hook yield? */
322          L->savedpc = pc - 1;
323          return;
324        }
325        base = L->base;
326      }
327      ra = RA(i);
328      lua_assert(base == L->base && L->base == L->ci->base);
329      lua_assert(base <= L->top && L->top <= L->stack + L->stacksize);
330      lua_assert(L->top == L->ci->top || luaG_checkopenop(i));
331      switch (GET_OPCODE(i)) {
332        case OP_MOVE: {
333          setobjs2s(L, ra, RB(i));
334          continue;
335        }
336        case OP_LOADK: {
337          setobj2s(L, ra, KBx(i));
338          continue;
339        }
340        case OP_LOADBOOL: {
341          setbvalue(ra, GETARG_B(i));
342          if (GETARG_C(i)) pc++;  &bsol;* skip next instruction (if C) */
343          continue;
344        }
345        case OP_LOADNIL: {
346          TValue *rb = RB(i);
347          do {
348            setnilvalue(rb--);
349          } while (rb >= ra);
350          continue;
351        }
352        case OP_GETUPVAL: {
353          int b = GETARG_B(i);
354          setobj2s(L, ra, cl->upvals[b]->v);
355          continue;
356        }
357        case OP_GETGLOBAL: {
358          TValue g;
359          TValue *rb = KBx(i);
360          sethvalue(L, &g, cl->env);
361          lua_assert(ttisstring(rb));
362          Protect(luaV_gettable(L, &g, rb, ra));
363          continue;
364        }
365        case OP_GETTABLE: {
366          Protect(luaV_gettable(L, RB(i), RKC(i), ra));
367          continue;
368        }
369        case OP_SETGLOBAL: {
370          TValue g;
371          sethvalue(L, &g, cl->env);
372          lua_assert(ttisstring(KBx(i)));
373          Protect(luaV_settable(L, &g, KBx(i), ra));
374          continue;
375        }
376        case OP_SETUPVAL: {
377          UpVal *uv = cl->upvals[GETARG_B(i)];
378          setobj(L, uv->v, ra);
379          luaC_barrier(L, uv, ra);
380          continue;
381        }
382        case OP_SETTABLE: {
383          Protect(luaV_settable(L, ra, RKB(i), RKC(i)));
384          continue;
385        }
386        case OP_NEWTABLE: {
387          int b = GETARG_B(i);
388          int c = GETARG_C(i);
389          sethvalue(L, ra, luaH_new(L, luaO_fb2int(b), luaO_fb2int(c)));
390          Protect(luaC_checkGC(L));
391          continue;
392        }
393        case OP_SELF: {
394          StkId rb = RB(i);
395          setobjs2s(L, ra+1, rb);
396          Protect(luaV_gettable(L, rb, RKC(i), ra));
397          continue;
398        }
399        case OP_ADD: {
400          arith_op(luai_numadd, TM_ADD);
401          continue;
402        }
403        case OP_SUB: {
404          arith_op(luai_numsub, TM_SUB);
405          continue;
406        }
407        case OP_MUL: {
408          arith_op(luai_nummul, TM_MUL);
409          continue;
410        }
411        case OP_DIV: {
412          arith_op(luai_numdiv, TM_DIV);
413          continue;
414        }
415        case OP_MOD: {
416          arith_op(luai_nummod, TM_MOD);
417          continue;
418        }
419        case OP_POW: {
420          arith_op(luai_numpow, TM_POW);
421          continue;
422        }
423        case OP_UNM: {
424          TValue *rb = RB(i);
425          if (ttisnumber(rb)) {
426            lua_Number nb = nvalue(rb);
427            setnvalue(ra, luai_numunm(nb));
428          }
429          else {
430            Protect(Arith(L, ra, rb, rb, TM_UNM));
431          }
432          continue;
433        }
434        case OP_NOT: {
435          int res = l_isfalse(RB(i));  &bsol;* next assignment may change this value */
436          setbvalue(ra, res);
437          continue;
438        }
439        case OP_LEN: {
440          const TValue *rb = RB(i);
441          switch (ttype(rb)) {
442            case LUA_TTABLE: {
443              setnvalue(ra, cast_num(luaH_getn(hvalue(rb))));
444              break;
445            }
446            case LUA_TSTRING: {
447              setnvalue(ra, cast_num(tsvalue(rb)->len));
448              break;
449            }
450            default: {  &bsol;* try metamethod */
451              Protect(
452                if (!call_binTM(L, rb, luaO_nilobject, ra, TM_LEN))
453                  luaG_typeerror(L, rb, "get length of");
454              )
455            }
456          }
457          continue;
458        }
459        case OP_CONCAT: {
460          int b = GETARG_B(i);
461          int c = GETARG_C(i);
462          Protect(luaV_concat(L, c-b+1, c); luaC_checkGC(L));
463          setobjs2s(L, RA(i), base+b);
464          continue;
465        }
466        case OP_JMP: {
467          dojump(L, pc, GETARG_sBx(i));
468          continue;
469        }
470        case OP_EQ: {
471          TValue *rb = RKB(i);
472          TValue *rc = RKC(i);
473          Protect(
474            if (equalobj(L, rb, rc) == GETARG_A(i))
475              dojump(L, pc, GETARG_sBx(*pc));
476          )
477          pc++;
478          continue;
479        }
480        case OP_LT: {
481          Protect(
482            if (luaV_lessthan(L, RKB(i), RKC(i)) == GETARG_A(i))
483              dojump(L, pc, GETARG_sBx(*pc));
484          )
<span onclick='openModal()' class='match'>485          pc++;
486          continue;
487        }
488        case OP_LE: {
489          Protect(
490            if (lessequal(L, RKB(i), RKC(i)) == GETARG_A(i))
491              dojump(L, pc, GETARG_sBx(*pc));
492          )
493          pc++;
494          continue;
495        }
496        case OP_TEST: {
497          if (l_isfalse(ra) != GETARG_C(i))
</span>498            dojump(L, pc, GETARG_sBx(*pc));
499          pc++;
500          continue;
501        }
502        case OP_TESTSET: {
503          TValue *rb = RB(i);
504          if (l_isfalse(rb) != GETARG_C(i)) {
505            setobjs2s(L, ra, rb);
506            dojump(L, pc, GETARG_sBx(*pc));
507          }
508          pc++;
509          continue;
510        }
511        case OP_CALL: {
512          int b = GETARG_B(i);
513          int nresults = GETARG_C(i) - 1;
514          if (b != 0) L->top = ra+b;  &bsol;* else previous instruction set top */
515          L->savedpc = pc;
516          switch (luaD_precall(L, ra, nresults)) {
517            case PCRLUA: {
518              nexeccalls++;
519              goto reentry;  &bsol;* restart luaV_execute over new Lua function */
520            }
521            case PCRC: {
522              if (nresults >= 0) L->top = L->ci->top;
523              base = L->base;
524              continue;
525            }
526            default: {
527              return;  &bsol;* yield */
528            }
529          }
530        }
531        case OP_TAILCALL: {
532          int b = GETARG_B(i);
533          if (b != 0) L->top = ra+b;  &bsol;* else previous instruction set top */
534          L->savedpc = pc;
535          lua_assert(GETARG_C(i) - 1 == LUA_MULTRET);
536          switch (luaD_precall(L, ra, LUA_MULTRET)) {
537            case PCRLUA: {
538              CallInfo *ci = L->ci - 1;  &bsol;* previous frame */
539              int aux;
540              StkId func = ci->func;
541              StkId pfunc = (ci+1)->func;  &bsol;* previous function index */
542              if (L->openupval) luaF_close(L, ci->base);
543              L->base = ci->base = ci->func + ((ci+1)->base - pfunc);
544              for (aux = 0; pfunc+aux < L->top; aux++)  &bsol;* move frame down */
545                setobjs2s(L, func+aux, pfunc+aux);
546              ci->top = L->top = func+aux;  &bsol;* correct top */
547              lua_assert(L->top == L->base + clvalue(func)->l.p->maxstacksize);
548              ci->savedpc = L->savedpc;
549              ci->tailcalls++;  &bsol;* one more call lost */
550              L->ci--;  &bsol;* remove new frame */
551              goto reentry;
552            }
553            case PCRC: {  &bsol;* it was a C function (`precall' called it) */
554              base = L->base;
555              continue;
556            }
557            default: {
558              return;  &bsol;* yield */
559            }
560          }
561        }
562        case OP_RETURN: {
563          int b = GETARG_B(i);
564          if (b != 0) L->top = ra+b-1;
565          if (L->openupval) luaF_close(L, base);
566          L->savedpc = pc;
567          b = luaD_poscall(L, ra);
568          if (--nexeccalls == 0)  &bsol;* was previous function running `here'? */
569            return;  &bsol;* no: return */
570          else {  &bsol;* yes: continue its execution */
571            if (b) L->top = L->ci->top;
572            lua_assert(isLua(L->ci));
573            lua_assert(GET_OPCODE(*((L->ci)->savedpc - 1)) == OP_CALL);
574            goto reentry;
575          }
576        }
577        case OP_FORLOOP: {
578          lua_Number step = nvalue(ra+2);
579          lua_Number idx = luai_numadd(nvalue(ra), step); &bsol;* increment index */
580          lua_Number limit = nvalue(ra+1);
581          if (luai_numlt(0, step) ? luai_numle(idx, limit)
582                                  : luai_numle(limit, idx)) {
583            dojump(L, pc, GETARG_sBx(i));  &bsol;* jump back */
584            setnvalue(ra, idx);  &bsol;* update internal index... */
585            setnvalue(ra+3, idx);  &bsol;* ...and external index */
586          }
587          continue;
588        }
589        case OP_FORPREP: {
590          const TValue *init = ra;
591          const TValue *plimit = ra+1;
592          const TValue *pstep = ra+2;
593          L->savedpc = pc;  &bsol;* next steps may throw errors */
594          if (!tonumber(init, ra))
595            luaG_runerror(L, LUA_QL("for") " initial value must be a number");
596          else if (!tonumber(plimit, ra+1))
597            luaG_runerror(L, LUA_QL("for") " limit must be a number");
598          else if (!tonumber(pstep, ra+2))
599            luaG_runerror(L, LUA_QL("for") " step must be a number");
600          setnvalue(ra, luai_numsub(nvalue(ra), nvalue(pstep)));
601          dojump(L, pc, GETARG_sBx(i));
602          continue;
603        }
604        case OP_TFORLOOP: {
605          StkId cb = ra + 3;  &bsol;* call base */
606          setobjs2s(L, cb+2, ra+2);
607          setobjs2s(L, cb+1, ra+1);
608          setobjs2s(L, cb, ra);
609          L->top = cb+3;  &bsol;* func. + 2 args (state and index) */
610          Protect(luaD_call(L, cb, GETARG_C(i)));
611          L->top = L->ci->top;
612          cb = RA(i) + 3;  &bsol;* previous call may change the stack */
613          if (!ttisnil(cb)) {  &bsol;* continue loop? */
614            setobjs2s(L, cb-1, cb);  &bsol;* save control variable */
615            dojump(L, pc, GETARG_sBx(*pc));  &bsol;* jump back */
616          }
617          pc++;
618          continue;
619        }
620        case OP_SETLIST: {
621          int n = GETARG_B(i);
622          int c = GETARG_C(i);
623          int last;
624          Table *h;
625          if (n == 0) {
626            n = cast_int(L->top - ra) - 1;
627            L->top = L->ci->top;
628          }
629          if (c == 0) c = cast_int(*pc++);
630          runtime_check(L, ttistable(ra));
631          h = hvalue(ra);
632          last = ((c-1)*LFIELDS_PER_FLUSH) + n;
633          if (last > h->sizearray)  &bsol;* needs more space? */
634            luaH_resizearray(L, h, last);  &bsol;* pre-alloc it at once */
635          for (; n > 0; n--) {
636            TValue *val = ra+n;
637            setobj2t(L, luaH_setnum(L, h, last--), val);
638            luaC_barriert(L, h, val);
639          }
640          continue;
641        }
642        case OP_CLOSE: {
643          luaF_close(L, ra);
644          continue;
645        }
646        case OP_CLOSURE: {
647          Proto *p;
648          Closure *ncl;
649          int nup, j;
650          p = cl->p->p[GETARG_Bx(i)];
651          nup = p->nups;
652          ncl = luaF_newLclosure(L, nup, cl->env);
653          ncl->l.p = p;
654          for (j=0; j<nup; j++, pc++) {
655            if (GET_OPCODE(*pc) == OP_GETUPVAL)
656              ncl->l.upvals[j] = cl->upvals[GETARG_B(*pc)];
657            else {
658              lua_assert(GET_OPCODE(*pc) == OP_MOVE);
659              ncl->l.upvals[j] = luaF_findupval(L, base + GETARG_B(*pc));
660            }
661          }
662          setclvalue(L, ra, ncl);
663          Protect(luaC_checkGC(L));
664          continue;
665        }
666        case OP_VARARG: {
667          int b = GETARG_B(i) - 1;
668          int j;
669          CallInfo *ci = L->ci;
670          int n = cast_int(ci->base - ci->func) - cl->p->numparams - 1;
671          if (b == LUA_MULTRET) {
672            Protect(luaD_checkstack(L, n));
673            ra = RA(i);  &bsol;* previous call may change the stack */
674            b = n;
675            L->top = ra + n;
676          }
677          for (j = 0; j < b; j++) {
678            if (j < n) {
679              setobjs2s(L, ra + j, ci->base - n + j);
680            }
681            else {
682              setnilvalue(ra + j);
683            }
684          }
685          continue;
686        }
687      }
688    }
689  }
</code></pre>
        </div>
        <div class="column">
            <h3>redis-MDEwOlJlcG9zaXRvcnkxMDgxMTA3MDY=-flat-lvm.c</h3>
            <pre><code>1  #include <stdio.h>
2  #include <stdlib.h>
3  #include <string.h>
4  #define lvm_c
5  #define LUA_CORE
6  #include "lua.h"
7  #include "ldebug.h"
8  #include "ldo.h"
9  #include "lfunc.h"
10  #include "lgc.h"
11  #include "lobject.h"
12  #include "lopcodes.h"
13  #include "lstate.h"
14  #include "lstring.h"
15  #include "ltable.h"
16  #include "ltm.h"
17  #include "lvm.h"
18  #define MAXTAGLOOP	100
19  const TValue *luaV_tonumber (const TValue *obj, TValue *n) {
20    lua_Number num;
21    if (ttisnumber(obj)) return obj;
22    if (ttisstring(obj) && luaO_str2d(svalue(obj), &num)) {
23      setnvalue(n, num);
24      return n;
25    }
26    else
27      return NULL;
28  }
29  int luaV_tostring (lua_State *L, StkId obj) {
30    if (!ttisnumber(obj))
31      return 0;
32    else {
33      char s[LUAI_MAXNUMBER2STR];
34      lua_Number n = nvalue(obj);
35      lua_number2str(s, n);
36      setsvalue2s(L, obj, luaS_new(L, s));
37      return 1;
38    }
39  }
40  static void traceexec (lua_State *L, const Instruction *pc) {
41    lu_byte mask = L->hookmask;
42    const Instruction *oldpc = L->savedpc;
43    L->savedpc = pc;
44    if ((mask & LUA_MASKCOUNT) && L->hookcount == 0) {
45      resethookcount(L);
46      luaD_callhook(L, LUA_HOOKCOUNT, -1);
47    }
48    if (mask & LUA_MASKLINE) {
49      Proto *p = ci_func(L->ci)->l.p;
50      int npc = pcRel(pc, p);
51      int newline = getline(p, npc);
52      if (npc == 0 || pc <= oldpc || newline != getline(p, pcRel(oldpc, p)))
53        luaD_callhook(L, LUA_HOOKLINE, newline);
54    }
55  }
56  static void callTMres (lua_State *L, StkId res, const TValue *f,
57                          const TValue *p1, const TValue *p2) {
58    ptrdiff_t result = savestack(L, res);
59    setobj2s(L, L->top, f);  &bsol;* push function */
60    setobj2s(L, L->top+1, p1);  &bsol;* 1st argument */
61    setobj2s(L, L->top+2, p2);  &bsol;* 2nd argument */
62    luaD_checkstack(L, 3);
63    L->top += 3;
64    luaD_call(L, L->top - 3, 1);
65    res = restorestack(L, result);
66    L->top--;
67    setobjs2s(L, res, L->top);
68  }
69  static void callTM (lua_State *L, const TValue *f, const TValue *p1,
70                      const TValue *p2, const TValue *p3) {
71    setobj2s(L, L->top, f);  &bsol;* push function */
72    setobj2s(L, L->top+1, p1);  &bsol;* 1st argument */
73    setobj2s(L, L->top+2, p2);  &bsol;* 2nd argument */
74    setobj2s(L, L->top+3, p3);  &bsol;* 3th argument */
75    luaD_checkstack(L, 4);
76    L->top += 4;
77    luaD_call(L, L->top - 4, 0);
78  }
79  void luaV_gettable (lua_State *L, const TValue *t, TValue *key, StkId val) {
80    int loop;
81    for (loop = 0; loop < MAXTAGLOOP; loop++) {
82      const TValue *tm;
83      if (ttistable(t)) {  &bsol;* `t' is a table? */
84        Table *h = hvalue(t);
85        const TValue *res = luaH_get(h, key); &bsol;* do a primitive get */
86        if (!ttisnil(res) ||  &bsol;* result is no nil? */
87            (tm = fasttm(L, h->metatable, TM_INDEX)) == NULL) { &bsol;* or no TM? */
88          setobj2s(L, val, res);
89          return;
90        }
91      }
92      else if (ttisnil(tm = luaT_gettmbyobj(L, t, TM_INDEX)))
93        luaG_typeerror(L, t, "index");
94      if (ttisfunction(tm)) {
95        callTMres(L, val, tm, t, key);
96        return;
97      }
98      t = tm;  &bsol;* else repeat with `tm' */ 
99    }
100    luaG_runerror(L, "loop in gettable");
101  }
102  void luaV_settable (lua_State *L, const TValue *t, TValue *key, StkId val) {
103    int loop;
104    TValue temp;
105    for (loop = 0; loop < MAXTAGLOOP; loop++) {
106      const TValue *tm;
107      if (ttistable(t)) {  &bsol;* `t' is a table? */
108        Table *h = hvalue(t);
109        TValue *oldval = luaH_set(L, h, key); &bsol;* do a primitive set */
110        if (!ttisnil(oldval) ||  &bsol;* result is no nil? */
111            (tm = fasttm(L, h->metatable, TM_NEWINDEX)) == NULL) { &bsol;* or no TM? */
112          setobj2t(L, oldval, val);
113          h->flags = 0;
114          luaC_barriert(L, h, val);
115          return;
116        }
117      }
118      else if (ttisnil(tm = luaT_gettmbyobj(L, t, TM_NEWINDEX)))
119        luaG_typeerror(L, t, "index");
120      if (ttisfunction(tm)) {
121        callTM(L, tm, t, key, val);
122        return;
123      }
124      setobj(L, &temp, tm);  &bsol;* avoid pointing inside table (may rehash) */
125      t = &temp;
126    }
127    luaG_runerror(L, "loop in settable");
128  }
129  static int call_binTM (lua_State *L, const TValue *p1, const TValue *p2,
130                         StkId res, TMS event) {
131    const TValue *tm = luaT_gettmbyobj(L, p1, event);  &bsol;* try first operand */
132    if (ttisnil(tm))
133      tm = luaT_gettmbyobj(L, p2, event);  &bsol;* try second operand */
134    if (ttisnil(tm)) return 0;
135    callTMres(L, res, tm, p1, p2);
136    return 1;
137  }
138  static const TValue *get_compTM (lua_State *L, Table *mt1, Table *mt2,
139                                    TMS event) {
140    const TValue *tm1 = fasttm(L, mt1, event);
141    const TValue *tm2;
142    if (tm1 == NULL) return NULL;  &bsol;* no metamethod */
143    if (mt1 == mt2) return tm1;  &bsol;* same metatables => same metamethods */
144    tm2 = fasttm(L, mt2, event);
145    if (tm2 == NULL) return NULL;  &bsol;* no metamethod */
146    if (luaO_rawequalObj(tm1, tm2))  &bsol;* same metamethods? */
147      return tm1;
148    return NULL;
149  }
150  static int call_orderTM (lua_State *L, const TValue *p1, const TValue *p2,
151                           TMS event) {
152    const TValue *tm1 = luaT_gettmbyobj(L, p1, event);
153    const TValue *tm2;
154    if (ttisnil(tm1)) return -1;  &bsol;* no metamethod? */
155    tm2 = luaT_gettmbyobj(L, p2, event);
156    if (!luaO_rawequalObj(tm1, tm2))  &bsol;* different metamethods? */
157      return -1;
158    callTMres(L, L->top, tm1, p1, p2);
159    return !l_isfalse(L->top);
160  }
161  static int l_strcmp (const TString *ls, const TString *rs) {
162    const char *l = getstr(ls);
163    size_t ll = ls->tsv.len;
164    const char *r = getstr(rs);
165    size_t lr = rs->tsv.len;
166    for (;;) {
167      int temp = strcoll(l, r);
168      if (temp != 0) return temp;
169      else {  &bsol;* strings are equal up to a `\0' */
170        size_t len = strlen(l);  &bsol;* index of first `\0' in both strings */
171        if (len == lr)  &bsol;* r is finished? */
172          return (len == ll) ? 0 : 1;
173        else if (len == ll)  &bsol;* l is finished? */
174          return -1;  &bsol;* l is smaller than r (because r is not finished) */
175        len++;
176        l += len; ll -= len; r += len; lr -= len;
177      }
178    }
179  }
180  int luaV_lessthan (lua_State *L, const TValue *l, const TValue *r) {
181    int res;
182    if (ttype(l) != ttype(r))
183      return luaG_ordererror(L, l, r);
184    else if (ttisnumber(l))
185      return luai_numlt(nvalue(l), nvalue(r));
186    else if (ttisstring(l))
187      return l_strcmp(rawtsvalue(l), rawtsvalue(r)) < 0;
188    else if ((res = call_orderTM(L, l, r, TM_LT)) != -1)
189      return res;
190    return luaG_ordererror(L, l, r);
191  }
192  static int lessequal (lua_State *L, const TValue *l, const TValue *r) {
193    int res;
194    if (ttype(l) != ttype(r))
195      return luaG_ordererror(L, l, r);
196    else if (ttisnumber(l))
197      return luai_numle(nvalue(l), nvalue(r));
198    else if (ttisstring(l))
199      return l_strcmp(rawtsvalue(l), rawtsvalue(r)) <= 0;
200    else if ((res = call_orderTM(L, l, r, TM_LE)) != -1)  &bsol;* first try `le' */
201      return res;
202    else if ((res = call_orderTM(L, r, l, TM_LT)) != -1)  &bsol;* else try `lt' */
203      return !res;
204    return luaG_ordererror(L, l, r);
205  }
206  int luaV_equalval (lua_State *L, const TValue *t1, const TValue *t2) {
207    const TValue *tm;
208    lua_assert(ttype(t1) == ttype(t2));
209    switch (ttype(t1)) {
210      case LUA_TNIL: return 1;
211      case LUA_TNUMBER: return luai_numeq(nvalue(t1), nvalue(t2));
212      case LUA_TBOOLEAN: return bvalue(t1) == bvalue(t2);  &bsol;* true must be 1 !! */
213      case LUA_TLIGHTUSERDATA: return pvalue(t1) == pvalue(t2);
214      case LUA_TUSERDATA: {
215        if (uvalue(t1) == uvalue(t2)) return 1;
216        tm = get_compTM(L, uvalue(t1)->metatable, uvalue(t2)->metatable,
217                           TM_EQ);
218        break;  &bsol;* will try TM */
219      }
220      case LUA_TTABLE: {
221        if (hvalue(t1) == hvalue(t2)) return 1;
222        tm = get_compTM(L, hvalue(t1)->metatable, hvalue(t2)->metatable, TM_EQ);
223        break;  &bsol;* will try TM */
224      }
225      default: return gcvalue(t1) == gcvalue(t2);
226    }
227    if (tm == NULL) return 0;  &bsol;* no TM? */
228    callTMres(L, L->top, tm, t1, t2);  &bsol;* call TM */
229    return !l_isfalse(L->top);
230  }
231  void luaV_concat (lua_State *L, int total, int last) {
232    do {
233      StkId top = L->base + last + 1;
234      int n = 2;  &bsol;* number of elements handled in this pass (at least 2) */
235      if (!(ttisstring(top-2) || ttisnumber(top-2)) || !tostring(L, top-1)) {
236        if (!call_binTM(L, top-2, top-1, top-2, TM_CONCAT))
237          luaG_concaterror(L, top-2, top-1);
238      } else if (tsvalue(top-1)->len == 0)  &bsol;* second op is empty? */
239        (void)tostring(L, top - 2);  &bsol;* result is first op (as string) */
240      else {
241        size_t tl = tsvalue(top-1)->len;
242        char *buffer;
243        int i;
244        for (n = 1; n < total && tostring(L, top-n-1); n++) {
245          size_t l = tsvalue(top-n-1)->len;
246          if (l >= MAX_SIZET - tl) luaG_runerror(L, "string length overflow");
247          tl += l;
248        }
249        buffer = luaZ_openspace(L, &G(L)->buff, tl);
250        tl = 0;
251        for (i=n; i>0; i--) {  &bsol;* concat all strings */
252          size_t l = tsvalue(top-i)->len;
253          memcpy(buffer+tl, svalue(top-i), l);
254          tl += l;
255        }
256        setsvalue2s(L, top-n, luaS_newlstr(L, buffer, tl));
257      }
258      total -= n-1;  &bsol;* got `n' strings to create 1 new */
259      last -= n-1;
260    } while (total > 1);  &bsol;* repeat until only 1 result left */
261  }
262  static void Arith (lua_State *L, StkId ra, const TValue *rb,
263                     const TValue *rc, TMS op) {
264    TValue tempb, tempc;
265    const TValue *b, *c;
266    if ((b = luaV_tonumber(rb, &tempb)) != NULL &&
267        (c = luaV_tonumber(rc, &tempc)) != NULL) {
268      lua_Number nb = nvalue(b), nc = nvalue(c);
269      switch (op) {
270        case TM_ADD: setnvalue(ra, luai_numadd(nb, nc)); break;
271        case TM_SUB: setnvalue(ra, luai_numsub(nb, nc)); break;
272        case TM_MUL: setnvalue(ra, luai_nummul(nb, nc)); break;
273        case TM_DIV: setnvalue(ra, luai_numdiv(nb, nc)); break;
274        case TM_MOD: setnvalue(ra, luai_nummod(nb, nc)); break;
275        case TM_POW: setnvalue(ra, luai_numpow(nb, nc)); break;
276        case TM_UNM: setnvalue(ra, luai_numunm(nb)); break;
277        default: lua_assert(0); break;
278      }
279    }
280    else if (!call_binTM(L, rb, rc, ra, op))
281      luaG_aritherror(L, rb, rc);
282  }
283  #define runtime_check(L, c)	{ if (!(c)) break; }
284  #define RA(i)	(base+GETARG_A(i))
285  #define RB(i)	check_exp(getBMode(GET_OPCODE(i)) == OpArgR, base+GETARG_B(i))
286  #define RC(i)	check_exp(getCMode(GET_OPCODE(i)) == OpArgR, base+GETARG_C(i))
287  #define RKB(i)	check_exp(getBMode(GET_OPCODE(i)) == OpArgK, \
288  	ISK(GETARG_B(i)) ? k+INDEXK(GETARG_B(i)) : base+GETARG_B(i))
289  #define RKC(i)	check_exp(getCMode(GET_OPCODE(i)) == OpArgK, \
290  	ISK(GETARG_C(i)) ? k+INDEXK(GETARG_C(i)) : base+GETARG_C(i))
291  #define KBx(i)	check_exp(getBMode(GET_OPCODE(i)) == OpArgK, k+GETARG_Bx(i))
292  #define dojump(L,pc,i)	{(pc) += (i); luai_threadyield(L);}
293  #define Protect(x)	{ L->savedpc = pc; {x;}; base = L->base; }
294  #define arith_op(op,tm) { \
295          TValue *rb = RKB(i); \
296          TValue *rc = RKC(i); \
297          if (ttisnumber(rb) && ttisnumber(rc)) { \
298            lua_Number nb = nvalue(rb), nc = nvalue(rc); \
299            setnvalue(ra, op(nb, nc)); \
300          } \
301          else \
302            Protect(Arith(L, ra, rb, rc, tm)); \
303        }
304  void luaV_execute (lua_State *L, int nexeccalls) {
305    LClosure *cl;
306    StkId base;
307    TValue *k;
308    const Instruction *pc;
309   reentry:  &bsol;* entry point */
310    lua_assert(isLua(L->ci));
311    pc = L->savedpc;
312    cl = &clvalue(L->ci->func)->l;
313    base = L->base;
314    k = cl->p->k;
315    for (;;) {
316      const Instruction i = *pc++;
317      StkId ra;
318      if ((L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT)) &&
319          (--L->hookcount == 0 || L->hookmask & LUA_MASKLINE)) {
320        traceexec(L, pc);
321        if (L->status == LUA_YIELD) {  &bsol;* did hook yield? */
322          L->savedpc = pc - 1;
323          return;
324        }
325        base = L->base;
326      }
327      ra = RA(i);
328      lua_assert(base == L->base && L->base == L->ci->base);
329      lua_assert(base <= L->top && L->top <= L->stack + L->stacksize);
330      lua_assert(L->top == L->ci->top || luaG_checkopenop(i));
331      switch (GET_OPCODE(i)) {
332        case OP_MOVE: {
333          setobjs2s(L, ra, RB(i));
334          continue;
335        }
336        case OP_LOADK: {
337          setobj2s(L, ra, KBx(i));
338          continue;
339        }
340        case OP_LOADBOOL: {
341          setbvalue(ra, GETARG_B(i));
342          if (GETARG_C(i)) pc++;  &bsol;* skip next instruction (if C) */
343          continue;
344        }
345        case OP_LOADNIL: {
346          TValue *rb = RB(i);
347          do {
348            setnilvalue(rb--);
349          } while (rb >= ra);
350          continue;
351        }
352        case OP_GETUPVAL: {
353          int b = GETARG_B(i);
354          setobj2s(L, ra, cl->upvals[b]->v);
355          continue;
356        }
357        case OP_GETGLOBAL: {
358          TValue g;
359          TValue *rb = KBx(i);
360          sethvalue(L, &g, cl->env);
361          lua_assert(ttisstring(rb));
362          Protect(luaV_gettable(L, &g, rb, ra));
363          continue;
364        }
365        case OP_GETTABLE: {
366          Protect(luaV_gettable(L, RB(i), RKC(i), ra));
367          continue;
368        }
369        case OP_SETGLOBAL: {
370          TValue g;
371          sethvalue(L, &g, cl->env);
372          lua_assert(ttisstring(KBx(i)));
373          Protect(luaV_settable(L, &g, KBx(i), ra));
374          continue;
375        }
376        case OP_SETUPVAL: {
377          UpVal *uv = cl->upvals[GETARG_B(i)];
378          setobj(L, uv->v, ra);
379          luaC_barrier(L, uv, ra);
380          continue;
381        }
382        case OP_SETTABLE: {
383          Protect(luaV_settable(L, ra, RKB(i), RKC(i)));
384          continue;
385        }
386        case OP_NEWTABLE: {
387          int b = GETARG_B(i);
388          int c = GETARG_C(i);
389          sethvalue(L, ra, luaH_new(L, luaO_fb2int(b), luaO_fb2int(c)));
390          Protect(luaC_checkGC(L));
391          continue;
392        }
393        case OP_SELF: {
394          StkId rb = RB(i);
395          setobjs2s(L, ra+1, rb);
396          Protect(luaV_gettable(L, rb, RKC(i), ra));
397          continue;
398        }
399        case OP_ADD: {
400          arith_op(luai_numadd, TM_ADD);
401          continue;
402        }
403        case OP_SUB: {
404          arith_op(luai_numsub, TM_SUB);
405          continue;
406        }
407        case OP_MUL: {
408          arith_op(luai_nummul, TM_MUL);
409          continue;
410        }
411        case OP_DIV: {
412          arith_op(luai_numdiv, TM_DIV);
413          continue;
414        }
415        case OP_MOD: {
416          arith_op(luai_nummod, TM_MOD);
417          continue;
418        }
419        case OP_POW: {
420          arith_op(luai_numpow, TM_POW);
421          continue;
422        }
423        case OP_UNM: {
424          TValue *rb = RB(i);
425          if (ttisnumber(rb)) {
426            lua_Number nb = nvalue(rb);
427            setnvalue(ra, luai_numunm(nb));
428          }
429          else {
430            Protect(Arith(L, ra, rb, rb, TM_UNM));
431          }
432          continue;
433        }
434        case OP_NOT: {
435          int res = l_isfalse(RB(i));  &bsol;* next assignment may change this value */
436          setbvalue(ra, res);
437          continue;
438        }
439        case OP_LEN: {
440          const TValue *rb = RB(i);
441          switch (ttype(rb)) {
442            case LUA_TTABLE: {
443              setnvalue(ra, cast_num(luaH_getn(hvalue(rb))));
444              break;
445            }
446            case LUA_TSTRING: {
447              setnvalue(ra, cast_num(tsvalue(rb)->len));
448              break;
449            }
450            default: {  &bsol;* try metamethod */
451              Protect(
452                if (!call_binTM(L, rb, luaO_nilobject, ra, TM_LEN))
453                  luaG_typeerror(L, rb, "get length of");
454              )
455            }
456          }
457          continue;
458        }
459        case OP_CONCAT: {
460          int b = GETARG_B(i);
461          int c = GETARG_C(i);
462          Protect(luaV_concat(L, c-b+1, c); luaC_checkGC(L));
463          setobjs2s(L, RA(i), base+b);
464          continue;
465        }
466        case OP_JMP: {
467          dojump(L, pc, GETARG_sBx(i));
468          continue;
469        }
470        case OP_EQ: {
471          TValue *rb = RKB(i);
472          TValue *rc = RKC(i);
473          Protect(
474            if (equalobj(L, rb, rc) == GETARG_A(i))
475              dojump(L, pc, GETARG_sBx(*pc));
476          )
<span onclick='openModal()' class='match'>477          pc++;
478          continue;
479        }
480        case OP_LT: {
481          Protect(
482            if (luaV_lessthan(L, RKB(i), RKC(i)) == GETARG_A(i))
483              dojump(L, pc, GETARG_sBx(*pc));
484          )
485          pc++;
486          continue;
487        }
488        case OP_LE: {
489          Protect(
</span>490            if (lessequal(L, RKB(i), RKC(i)) == GETARG_A(i))
491              dojump(L, pc, GETARG_sBx(*pc));
492          )
493          pc++;
494          continue;
495        }
496        case OP_TEST: {
497          if (l_isfalse(ra) != GETARG_C(i))
498            dojump(L, pc, GETARG_sBx(*pc));
499          pc++;
500          continue;
501        }
502        case OP_TESTSET: {
503          TValue *rb = RB(i);
504          if (l_isfalse(rb) != GETARG_C(i)) {
505            setobjs2s(L, ra, rb);
506            dojump(L, pc, GETARG_sBx(*pc));
507          }
508          pc++;
509          continue;
510        }
511        case OP_CALL: {
512          int b = GETARG_B(i);
513          int nresults = GETARG_C(i) - 1;
514          if (b != 0) L->top = ra+b;  &bsol;* else previous instruction set top */
515          L->savedpc = pc;
516          switch (luaD_precall(L, ra, nresults)) {
517            case PCRLUA: {
518              nexeccalls++;
519              goto reentry;  &bsol;* restart luaV_execute over new Lua function */
520            }
521            case PCRC: {
522              if (nresults >= 0) L->top = L->ci->top;
523              base = L->base;
524              continue;
525            }
526            default: {
527              return;  &bsol;* yield */
528            }
529          }
530        }
531        case OP_TAILCALL: {
532          int b = GETARG_B(i);
533          if (b != 0) L->top = ra+b;  &bsol;* else previous instruction set top */
534          L->savedpc = pc;
535          lua_assert(GETARG_C(i) - 1 == LUA_MULTRET);
536          switch (luaD_precall(L, ra, LUA_MULTRET)) {
537            case PCRLUA: {
538              CallInfo *ci = L->ci - 1;  &bsol;* previous frame */
539              int aux;
540              StkId func = ci->func;
541              StkId pfunc = (ci+1)->func;  &bsol;* previous function index */
542              if (L->openupval) luaF_close(L, ci->base);
543              L->base = ci->base = ci->func + ((ci+1)->base - pfunc);
544              for (aux = 0; pfunc+aux < L->top; aux++)  &bsol;* move frame down */
545                setobjs2s(L, func+aux, pfunc+aux);
546              ci->top = L->top = func+aux;  &bsol;* correct top */
547              lua_assert(L->top == L->base + clvalue(func)->l.p->maxstacksize);
548              ci->savedpc = L->savedpc;
549              ci->tailcalls++;  &bsol;* one more call lost */
550              L->ci--;  &bsol;* remove new frame */
551              goto reentry;
552            }
553            case PCRC: {  &bsol;* it was a C function (`precall' called it) */
554              base = L->base;
555              continue;
556            }
557            default: {
558              return;  &bsol;* yield */
559            }
560          }
561        }
562        case OP_RETURN: {
563          int b = GETARG_B(i);
564          if (b != 0) L->top = ra+b-1;
565          if (L->openupval) luaF_close(L, base);
566          L->savedpc = pc;
567          b = luaD_poscall(L, ra);
568          if (--nexeccalls == 0)  &bsol;* was previous function running `here'? */
569            return;  &bsol;* no: return */
570          else {  &bsol;* yes: continue its execution */
571            if (b) L->top = L->ci->top;
572            lua_assert(isLua(L->ci));
573            lua_assert(GET_OPCODE(*((L->ci)->savedpc - 1)) == OP_CALL);
574            goto reentry;
575          }
576        }
577        case OP_FORLOOP: {
578          lua_Number step = nvalue(ra+2);
579          lua_Number idx = luai_numadd(nvalue(ra), step); &bsol;* increment index */
580          lua_Number limit = nvalue(ra+1);
581          if (luai_numlt(0, step) ? luai_numle(idx, limit)
582                                  : luai_numle(limit, idx)) {
583            dojump(L, pc, GETARG_sBx(i));  &bsol;* jump back */
584            setnvalue(ra, idx);  &bsol;* update internal index... */
585            setnvalue(ra+3, idx);  &bsol;* ...and external index */
586          }
587          continue;
588        }
589        case OP_FORPREP: {
590          const TValue *init = ra;
591          const TValue *plimit = ra+1;
592          const TValue *pstep = ra+2;
593          L->savedpc = pc;  &bsol;* next steps may throw errors */
594          if (!tonumber(init, ra))
595            luaG_runerror(L, LUA_QL("for") " initial value must be a number");
596          else if (!tonumber(plimit, ra+1))
597            luaG_runerror(L, LUA_QL("for") " limit must be a number");
598          else if (!tonumber(pstep, ra+2))
599            luaG_runerror(L, LUA_QL("for") " step must be a number");
600          setnvalue(ra, luai_numsub(nvalue(ra), nvalue(pstep)));
601          dojump(L, pc, GETARG_sBx(i));
602          continue;
603        }
604        case OP_TFORLOOP: {
605          StkId cb = ra + 3;  &bsol;* call base */
606          setobjs2s(L, cb+2, ra+2);
607          setobjs2s(L, cb+1, ra+1);
608          setobjs2s(L, cb, ra);
609          L->top = cb+3;  &bsol;* func. + 2 args (state and index) */
610          Protect(luaD_call(L, cb, GETARG_C(i)));
611          L->top = L->ci->top;
612          cb = RA(i) + 3;  &bsol;* previous call may change the stack */
613          if (!ttisnil(cb)) {  &bsol;* continue loop? */
614            setobjs2s(L, cb-1, cb);  &bsol;* save control variable */
615            dojump(L, pc, GETARG_sBx(*pc));  &bsol;* jump back */
616          }
617          pc++;
618          continue;
619        }
620        case OP_SETLIST: {
621          int n = GETARG_B(i);
622          int c = GETARG_C(i);
623          int last;
624          Table *h;
625          if (n == 0) {
626            n = cast_int(L->top - ra) - 1;
627            L->top = L->ci->top;
628          }
629          if (c == 0) c = cast_int(*pc++);
630          runtime_check(L, ttistable(ra));
631          h = hvalue(ra);
632          last = ((c-1)*LFIELDS_PER_FLUSH) + n;
633          if (last > h->sizearray)  &bsol;* needs more space? */
634            luaH_resizearray(L, h, last);  &bsol;* pre-alloc it at once */
635          for (; n > 0; n--) {
636            TValue *val = ra+n;
637            setobj2t(L, luaH_setnum(L, h, last--), val);
638            luaC_barriert(L, h, val);
639          }
640          continue;
641        }
642        case OP_CLOSE: {
643          luaF_close(L, ra);
644          continue;
645        }
646        case OP_CLOSURE: {
647          Proto *p;
648          Closure *ncl;
649          int nup, j;
650          p = cl->p->p[GETARG_Bx(i)];
651          nup = p->nups;
652          ncl = luaF_newLclosure(L, nup, cl->env);
653          ncl->l.p = p;
654          for (j=0; j<nup; j++, pc++) {
655            if (GET_OPCODE(*pc) == OP_GETUPVAL)
656              ncl->l.upvals[j] = cl->upvals[GETARG_B(*pc)];
657            else {
658              lua_assert(GET_OPCODE(*pc) == OP_MOVE);
659              ncl->l.upvals[j] = luaF_findupval(L, base + GETARG_B(*pc));
660            }
661          }
662          setclvalue(L, ra, ncl);
663          Protect(luaC_checkGC(L));
664          continue;
665        }
666        case OP_VARARG: {
667          int b = GETARG_B(i) - 1;
668          int j;
669          CallInfo *ci = L->ci;
670          int n = cast_int(ci->base - ci->func) - cl->p->numparams - 1;
671          if (b == LUA_MULTRET) {
672            Protect(luaD_checkstack(L, n));
673            ra = RA(i);  &bsol;* previous call may change the stack */
674            b = n;
675            L->top = ra + n;
676          }
677          for (j = 0; j < b; j++) {
678            if (j < n) {
679              setobjs2s(L, ra + j, ci->base - n + j);
680            }
681            else {
682              setnilvalue(ra + j);
683            }
684          }
685          continue;
686        }
687      }
688    }
689  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from redis-MDEwOlJlcG9zaXRvcnkxMDgxMTA3MDY=-flat-lvm.c</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from redis-MDEwOlJlcG9zaXRvcnkxMDgxMTA3MDY=-flat-lvm.c</div>
                </div>
                <div class="column column_space"><pre><code>485          pc++;
486          continue;
487        }
488        case OP_LE: {
489          Protect(
490            if (lessequal(L, RKB(i), RKC(i)) == GETARG_A(i))
491              dojump(L, pc, GETARG_sBx(*pc));
492          )
493          pc++;
494          continue;
495        }
496        case OP_TEST: {
497          if (l_isfalse(ra) != GETARG_C(i))
</pre></code></div>
                <div class="column column_space"><pre><code>477          pc++;
478          continue;
479        }
480        case OP_LT: {
481          Protect(
482            if (luaV_lessthan(L, RKB(i), RKC(i)) == GETARG_A(i))
483              dojump(L, pc, GETARG_sBx(*pc));
484          )
485          pc++;
486          continue;
487        }
488        case OP_LE: {
489          Protect(
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    