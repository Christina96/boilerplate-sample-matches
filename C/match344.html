<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML><HEAD><TITLE>Matches for impstats.c & omrelp.c</TITLE>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
</HEAD>
<body>
  <div style="align-items: center; display: flex; justify-content: space-around;">
    <div>
      <h3 align="center">
Matches for impstats.c & omrelp.c
      </h3>
      <h1 align="center">
        14.9%
      </h1>
      <center>
        <a href="index.html" target="_top">
          INDEX
        </a>
        <span>-</span>
        <a href="help-en.html" target="_top">
          HELP
        </a>
      </center>
    </div>
    <div>
<TABLE BORDER="1" CELLSPACING="0" BGCOLOR="#d0d0d0">
<TR><TH><TH>impstats.c (19.362745%)<TH>omrelp.c (12.116565%)<TH>Tokens
<TR><TD BGCOLOR="#0000ff"><FONT COLOR="#0000ff">-</FONT><TD><A HREF="javascript:ZweiFrames('match344-0.html#0',2,'match344-1.html#0',3)" NAME="0">(104-123)<TD><A HREF="javascript:ZweiFrames('match344-0.html#0',2,'match344-1.html#0',3)" NAME="0">(146-173)</A><TD ALIGN=center><FONT COLOR="#ff0000">28</FONT>
<TR><TD BGCOLOR="#f63526"><FONT COLOR="#f63526">-</FONT><TD><A HREF="javascript:ZweiFrames('match344-0.html#1',2,'match344-1.html#1',3)" NAME="1">(357-372)<TD><A HREF="javascript:ZweiFrames('match344-0.html#1',2,'match344-1.html#1',3)" NAME="1">(407-421)</A><TD ALIGN=center><FONT COLOR="#880000">15</FONT>
<TR><TD BGCOLOR="#980517"><FONT COLOR="#980517">-</FONT><TD><A HREF="javascript:ZweiFrames('match344-0.html#2',2,'match344-1.html#2',3)" NAME="2">(398-405)<TD><A HREF="javascript:ZweiFrames('match344-0.html#2',2,'match344-1.html#2',3)" NAME="2">(518-529)</A><TD ALIGN=center><FONT COLOR="#6d0000">12</FONT>
<TR><TD BGCOLOR="#53858b"><FONT COLOR="#53858b">-</FONT><TD><A HREF="javascript:ZweiFrames('match344-0.html#3',2,'match344-1.html#3',3)" NAME="3">(386-389)<TD><A HREF="javascript:ZweiFrames('match344-0.html#3',2,'match344-1.html#3',3)" NAME="3">(465-468)</A><TD ALIGN=center><FONT COLOR="#6d0000">12</FONT>
<TR><TD BGCOLOR="#6cc417"><FONT COLOR="#6cc417">-</FONT><TD><A HREF="javascript:ZweiFrames('match344-0.html#4',2,'match344-1.html#4',3)" NAME="4">(335-345)<TD><A HREF="javascript:ZweiFrames('match344-0.html#4',2,'match344-1.html#4',3)" NAME="4">(305-314)</A><TD ALIGN=center><FONT COLOR="#6d0000">12</FONT>
</TABLE>
    </div>
  </div>
  <hr>
  <div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>impstats.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
/* impstats.c
 * A module to periodically output statistics gathered by rsyslog.
 *
 * Copyright 2010-2018 Adiscon GmbH.
 *
 * This file is part of rsyslog.
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *       -or-
 *       see COPYING.ASL20 in the source distribution
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#include &quot;config.h&quot;
#include &quot;rsyslog.h&quot;
#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;
#include &lt;assert.h&gt;
#include &lt;signal.h&gt;
#include &lt;string.h&gt;
#include &lt;pthread.h&gt;
#include &lt;fcntl.h&gt;
#include &lt;unistd.h&gt;
#include &lt;sys/uio.h&gt;
#include &lt;sys/stat.h&gt;
#include &lt;errno.h&gt;
#include &lt;sys/time.h&gt;
#include &lt;sys/resource.h&gt;
#ifdef OS_LINUX
#include &lt;sys/types.h&gt;
#include &lt;dirent.h&gt;
#endif

#include &quot;dirty.h&quot;
#include &quot;cfsysline.h&quot;
#include &quot;module-template.h&quot;
#include &quot;errmsg.h&quot;
#include &quot;msg.h&quot;
#include &quot;srUtils.h&quot;
#include &quot;unicode-helper.h&quot;
#include &quot;glbl.h&quot;
#include &quot;statsobj.h&quot;
#include &quot;prop.h&quot;
#include &quot;ruleset.h&quot;
#include &quot;parserif.h&quot;


MODULE_TYPE_INPUT
MODULE_TYPE_NOKEEP
MODULE_CNFNAME(&quot;impstats&quot;)

/* defines */
#define DEFAULT_STATS_PERIOD (5 * 60)
#define DEFAULT_FACILITY 5 /* syslog */
#define DEFAULT_SEVERITY 6 /* info */

/* Module static data */
DEF_IMOD_STATIC_DATA
DEFobjCurrIf(glbl)
DEFobjCurrIf(prop)
DEFobjCurrIf(statsobj)
DEFobjCurrIf(ruleset)

typedef struct configSettings_s {
	int iStatsInterval;
	int iFacility;
	int iSeverity;
	int bJSON;
	int bCEE;
} configSettings_t;

struct modConfData_s {
	rsconf_t *pConf; /* our overall config object */
	int iStatsInterval;
	int iFacility;
	int iSeverity;
	int logfd; /* fd if logging to file, or -1 if closed */
	ruleset_t *pBindRuleset;	/* ruleset to bind listener to (use system default if unspecified) */
	statsFmtType_t statsFmt;
	sbool bLogToSyslog;
	sbool bResetCtrs;
	sbool bBracketing;
	char *logfile;
	sbool configSetViaV2Method;
	uchar *pszBindRuleset;		/* name of ruleset to bind to */
};
static modConfData_t *loadModConf = NULL;/* modConf ptr to use for the current load process */
static modConfData_t *runModConf = NULL;/* modConf ptr to use for the current load process */

static configSettings_t cs;
static int bLegacyCnfModGlobalsPermitted;/* are legacy module-global config parameters permitted? */
static prop_t *pInputName = NULL;
<A NAME="0"></A>
/* module-global parameters */
static struct cnfparamdescr modpdescr[] = {
<FONT color="#0000ff"><A HREF="javascript:ZweiFrames('match344-1.html#0',3,'match344-top.html#0',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>	{ &quot;interval&quot;, eCmdHdlrInt, 0 },
	{ &quot;facility&quot;, eCmdHdlrInt, 0 },
	{ &quot;severity&quot;, eCmdHdlrInt, 0 },
	{ &quot;bracketing&quot;, eCmdHdlrBinary, 0 },
	{ &quot;log.syslog&quot;, eCmdHdlrBinary, 0 },
	{ &quot;resetcounters&quot;, eCmdHdlrBinary, 0 },
	{ &quot;log.file&quot;, eCmdHdlrGetWord, 0 },
	{ &quot;format&quot;, eCmdHdlrGetWord, 0 },
	{ &quot;ruleset&quot;, eCmdHdlrString, 0 }
};
static struct cnfparamblk modpblk =
	{ CNFPARAMBLK_VERSION,
	  sizeof(modpdescr)/sizeof(struct cnfparamdescr),
	  modpdescr
	};


/* resource use stats counters */
#ifdef OS_LINUX
static int st_openfiles;</B></FONT>
#endif
static intctr_t st_ru_utime;
static intctr_t st_ru_stime;
static intctr_t st_ru_maxrss;
static intctr_t st_ru_minflt;
static intctr_t st_ru_majflt;
static intctr_t st_ru_inblock;
static intctr_t st_ru_oublock;
static intctr_t st_ru_nvcsw;
static intctr_t st_ru_nivcsw;
static statsobj_t *statsobj_resources;

static pthread_mutex_t hup_mutex = PTHREAD_MUTEX_INITIALIZER;

BEGINmodExit
CODESTARTmodExit
	prop.Destruct(&amp;pInputName);
	/* release objects we used */
	objRelease(glbl, CORE_COMPONENT);
	objRelease(prop, CORE_COMPONENT);
	objRelease(statsobj, CORE_COMPONENT);
	objRelease(ruleset, CORE_COMPONENT);
ENDmodExit


BEGINisCompatibleWithFeature
CODESTARTisCompatibleWithFeature
	if(eFeat == sFEATURENonCancelInputTermination)
		iRet = RS_RET_OK;
ENDisCompatibleWithFeature


#ifdef OS_LINUX
/* count number of open files (linux specific) */
static void
countOpenFiles(void)
{
	char proc_path[MAXFNAME];
	DIR *dp;
	struct dirent *files;

	st_openfiles = 0;
	snprintf(proc_path, sizeof(proc_path), &quot;/proc/%d/fd&quot;, glblGetOurPid());
	if((dp = opendir(proc_path)) == NULL) {
		LogError(errno, RS_RET_ERR, &quot;impstats: error reading %s\n&quot;, proc_path);
		goto done;
	}
	while((files=readdir(dp)) != NULL) {
		if(!strcmp(files-&gt;d_name, &quot;.&quot;) || !strcmp(files-&gt;d_name, &quot;..&quot;))
			continue;
		st_openfiles++;
	}
	closedir(dp);

done:
	return;
}
#endif


static void
initConfigSettings(void)
{
	cs.iStatsInterval = DEFAULT_STATS_PERIOD;
	cs.iFacility = DEFAULT_FACILITY;
	cs.iSeverity = DEFAULT_SEVERITY;
	cs.bJSON = 0;
	cs.bCEE = 0;
}


/* actually submit a message to the rsyslog core
 */
static void
doSubmitMsg(uchar *line)
{
	smsg_t *pMsg;

	if(msgConstruct(&amp;pMsg) != RS_RET_OK)
		goto finalize_it;
	MsgSetInputName(pMsg, pInputName);
	MsgSetRawMsgWOSize(pMsg, (char*)line);
	MsgSetHOSTNAME(pMsg, glbl.GetLocalHostName(), ustrlen(glbl.GetLocalHostName()));
	MsgSetRcvFrom(pMsg, glbl.GetLocalHostNameProp());
	MsgSetRcvFromIP(pMsg, glbl.GetLocalHostIP());
	MsgSetMSGoffs(pMsg, 0);
	MsgSetRuleset(pMsg, runModConf-&gt;pBindRuleset);
	MsgSetTAG(pMsg, UCHAR_CONSTANT(&quot;rsyslogd-pstats:&quot;), sizeof(&quot;rsyslogd-pstats:&quot;) - 1);
	pMsg-&gt;iFacility = runModConf-&gt;iFacility;
	pMsg-&gt;iSeverity = runModConf-&gt;iSeverity;
	pMsg-&gt;msgFlags  = 0;

	/* we do not use rate-limiting, as the stats message always need to be emitted */
	submitMsg2(pMsg);
	DBGPRINTF(&quot;impstats: submit [%d,%d] msg '%s'\n&quot;, runModConf-&gt;iFacility,
	          runModConf-&gt;iSeverity, line);

finalize_it:
	return;
}


/* log stats message to file; limited error handling done */
static void
doLogToFile(const char *ln, const size_t lenLn)
{
	struct iovec iov[4];
	ssize_t nwritten;
	ssize_t nexpect;
	time_t t;
	char timebuf[32];

	pthread_mutex_lock(&amp;hup_mutex);

	if(lenLn == 0)
		goto done;

	if(runModConf-&gt;logfd == -1) {
		runModConf-&gt;logfd = open(runModConf-&gt;logfile, O_WRONLY|O_CREAT|O_APPEND|O_CLOEXEC, S_IRUSR|S_IWUSR);
		if(runModConf-&gt;logfd == -1) {
			DBGPRINTF(&quot;impstats: error opening stats file %s\n&quot;,
				runModConf-&gt;logfile);
			goto done;
		} else {
			DBGPRINTF(&quot;impstats: opened stats file %s\n&quot;,
				runModConf-&gt;logfile);
		}
	}

	time(&amp;t);
	iov[0].iov_base = ctime_r(&amp;t, timebuf);
	iov[0].iov_len = nexpect = strlen(iov[0].iov_base) - 1; /* -1: strip \n */
	iov[1].iov_base = (void*)&quot;: &quot;;
	iov[1].iov_len = 2;
	nexpect += 2;
	iov[2].iov_base = (void*)ln;
	iov[2].iov_len = lenLn;
	nexpect += lenLn;
	iov[3].iov_base = (void*)&quot;\n&quot;;
	iov[3].iov_len = 1;
	nexpect++;
	nwritten = writev(runModConf-&gt;logfd, iov, 4);

	if(nwritten != nexpect) {
			dbgprintf(&quot;error writing stats file %s, nwritten %lld, expected %lld\n&quot;,
				  runModConf-&gt;logfile, (long long) nwritten, (long long) nexpect);
	}
done:
	pthread_mutex_unlock(&amp;hup_mutex);
	return;
}


/* submit a line to our log destinations. Line must be fully formatted as
 * required (but may be a simple verb like &quot;BEGIN&quot; and &quot;END&quot;.
 */
static rsRetVal
submitLine(const char *const ln, const size_t lenLn)
{
	DEFiRet;
	if(runModConf-&gt;bLogToSyslog)
		doSubmitMsg((uchar*)ln);
	if(runModConf-&gt;logfile != NULL)
		doLogToFile(ln, lenLn);
	RETiRet;
}

/* callback for statsobj
 * Note: usrptr exists only to satisfy requirements of statsobj callback interface!
 */
static rsRetVal
doStatsLine(void __attribute__((unused)) *usrptr, const char *const str)
{
	DEFiRet;
	iRet = submitLine(str, strlen(str));
	RETiRet;
}


/* the function to generate the actual statistics messages
 * rgerhards, 2010-09-09
 */
static void
generateStatsMsgs(void)
{
	struct rusage ru;
	int r;
	r = getrusage(RUSAGE_SELF, &amp;ru);
	if(r != 0) {
		dbgprintf(&quot;impstats: getrusage() failed with error %d, zeroing out\n&quot;, errno);
		memset(&amp;ru, 0, sizeof(ru));
	}
#	ifdef OS_LINUX
	countOpenFiles();
#	endif
	st_ru_utime = ru.ru_utime.tv_sec * 1000000 + ru.ru_utime.tv_usec;
	st_ru_stime = ru.ru_stime.tv_sec * 1000000 + ru.ru_stime.tv_usec;
	st_ru_maxrss = ru.ru_maxrss;
	st_ru_minflt = ru.ru_minflt;
	st_ru_majflt = ru.ru_majflt;
	st_ru_inblock = ru.ru_inblock;
	st_ru_oublock = ru.ru_oublock;
	st_ru_nvcsw = ru.ru_nvcsw;
	st_ru_nivcsw = ru.ru_nivcsw;
	statsobj.GetAllStatsLines(doStatsLine, NULL, runModConf-&gt;statsFmt, runModConf-&gt;bResetCtrs);
}


<A NAME="4"></A>BEGINbeginCnfLoad
CODESTARTbeginCnfLoad
	loadModConf = pModConf;
<FONT color="#6cc417"><A HREF="javascript:ZweiFrames('match344-1.html#4',3,'match344-top.html#4',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>	pModConf-&gt;pConf = pConf;
	/* init our settings */
	loadModConf-&gt;configSetViaV2Method = 0;
	loadModConf-&gt;iStatsInterval = DEFAULT_STATS_PERIOD;
	loadModConf-&gt;iFacility = DEFAULT_FACILITY;
	loadModConf-&gt;iSeverity = DEFAULT_SEVERITY;
	loadModConf-&gt;statsFmt = statsFmt_Legacy;
	loadModConf-&gt;logfd = -1;
	loadModConf-&gt;logfile = NULL;
	loadModConf-&gt;pszBindRuleset = NULL;
	loadModConf-&gt;bLogToSyslog = 1;</B></FONT>
	loadModConf-&gt;bBracketing = 0;
	loadModConf-&gt;bResetCtrs = 0;
	bLegacyCnfModGlobalsPermitted = 1;
	/* init legacy config vars */
	initConfigSettings();
ENDbeginCnfLoad


<A NAME="1"></A>BEGINsetModCnf
	struct cnfparamvals *pvals = NULL;
	char *mode;
<FONT color="#f63526"><A HREF="javascript:ZweiFrames('match344-1.html#1',3,'match344-top.html#1',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>	int i;
CODESTARTsetModCnf
	pvals = nvlstGetParams(lst, &amp;modpblk, NULL);
	if(pvals == NULL) {
		LogError(0, RS_RET_MISSING_CNFPARAMS, &quot;error processing module &quot;
				&quot;config parameters [module(...)]&quot;);
		ABORT_FINALIZE(RS_RET_MISSING_CNFPARAMS);
	}

	if(Debug) {
		dbgprintf(&quot;module (global) param blk for impstats:\n&quot;);
		cnfparamsPrint(&amp;modpblk, pvals);
	}

	for(i = 0 ; i &lt; modpblk.nParams ; ++i) {
		if(!pvals[i].bUsed)</B></FONT>
			continue;
		if(!strcmp(modpblk.descr[i].name, &quot;interval&quot;)) {
			loadModConf-&gt;iStatsInterval = (int) pvals[i].val.d.n;
		} else if(!strcmp(modpblk.descr[i].name, &quot;facility&quot;)) {
			loadModConf-&gt;iFacility = (int) pvals[i].val.d.n;
		} else if(!strcmp(modpblk.descr[i].name, &quot;severity&quot;)) {
			loadModConf-&gt;iSeverity = (int) pvals[i].val.d.n;
		} else if(!strcmp(modpblk.descr[i].name, &quot;bracketing&quot;)) {
			loadModConf-&gt;bBracketing = (sbool) pvals[i].val.d.n;
		} else if(!strcmp(modpblk.descr[i].name, &quot;log.syslog&quot;)) {
<A NAME="3"></A>			loadModConf-&gt;bLogToSyslog = (sbool) pvals[i].val.d.n;
		} else if(!strcmp(modpblk.descr[i].name, &quot;resetcounters&quot;)) {
			loadModConf-&gt;bResetCtrs = (sbool) pvals[i].val.d.n;
<FONT color="#53858b"><A HREF="javascript:ZweiFrames('match344-1.html#3',3,'match344-top.html#3',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>		} else if(!strcmp(modpblk.descr[i].name, &quot;log.file&quot;)) {
			loadModConf-&gt;logfile = es_str2cstr(pvals[i].val.d.estr, NULL);
		} else if(!strcmp(modpblk.descr[i].name, &quot;format&quot;)) {
			mode = es_str2cstr(pvals[i].val.d.estr, NULL);</B></FONT>
			if(!strcasecmp(mode, &quot;json&quot;)) {
				loadModConf-&gt;statsFmt = statsFmt_JSON;
			} else if(!strcasecmp(mode, &quot;json-elasticsearch&quot;)) {
				loadModConf-&gt;statsFmt = statsFmt_JSON_ES;
			} else if(!strcasecmp(mode, &quot;cee&quot;)) {
<A NAME="2"></A>				loadModConf-&gt;statsFmt = statsFmt_CEE;
			} else if(!strcasecmp(mode, &quot;legacy&quot;)) {
				loadModConf-&gt;statsFmt = statsFmt_Legacy;
<FONT color="#980517"><A HREF="javascript:ZweiFrames('match344-1.html#2',3,'match344-top.html#2',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>			} else {
				LogError(0, RS_RET_ERR, &quot;impstats: invalid format %s&quot;,
						mode);
			}
			free(mode);
		} else if(!strcmp(modpblk.descr[i].name, &quot;ruleset&quot;)) {
			loadModConf-&gt;pszBindRuleset = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
		} else {</B></FONT>
			dbgprintf(&quot;impstats: program error, non-handled &quot;
			  &quot;param '%s' in beginCnfLoad\n&quot;, modpblk.descr[i].name);
		}
	}

	if(loadModConf-&gt;pszBindRuleset != NULL &amp;&amp; loadModConf-&gt;bLogToSyslog == 0) {
		parser_warnmsg(&quot;impstats: log.syslog set to \&quot;off\&quot; but ruleset specified - with &quot;
			&quot;these settings, the ruleset will never be used, because regular syslog &quot;
			&quot;processing is turned off - ruleset parameter is ignored&quot;);
		free(loadModConf-&gt;pszBindRuleset);
		loadModConf-&gt;pszBindRuleset = NULL;
	}

	loadModConf-&gt;configSetViaV2Method = 1;
	bLegacyCnfModGlobalsPermitted = 0;

finalize_it:
	if(pvals != NULL)
		cnfparamvalsDestruct(pvals, &amp;modpblk);
ENDsetModCnf


BEGINendCnfLoad
CODESTARTendCnfLoad
	if(!loadModConf-&gt;configSetViaV2Method) {
		/* persist module-specific settings from legacy config system */
		loadModConf-&gt;iStatsInterval = cs.iStatsInterval;
		loadModConf-&gt;iFacility = cs.iFacility;
		loadModConf-&gt;iSeverity = cs.iSeverity;
		if (cs.bCEE == 1) {
			loadModConf-&gt;statsFmt = statsFmt_CEE;
		} else if (cs.bJSON == 1) {
			loadModConf-&gt;statsFmt = statsFmt_JSON;
		} else {
			loadModConf-&gt;statsFmt = statsFmt_Legacy;
		}
	}
ENDendCnfLoad


/* we need our special version of checkRuleset(), as we do not have any instances */
static rsRetVal
checkRuleset(modConfData_t *modConf)
{
	ruleset_t *pRuleset;
	rsRetVal localRet;
	DEFiRet;

	modConf-&gt;pBindRuleset = NULL;	/* assume default ruleset */

	if(modConf-&gt;pszBindRuleset == NULL)
		FINALIZE;

	localRet = ruleset.GetRuleset(modConf-&gt;pConf, &amp;pRuleset, modConf-&gt;pszBindRuleset);
	if(localRet == RS_RET_NOT_FOUND) {
		LogError(0, NO_ERRCODE, &quot;impstats: ruleset '%s' not found - &quot;
				&quot;using default ruleset instead&quot;, modConf-&gt;pszBindRuleset);
	}
	CHKiRet(localRet);
	modConf-&gt;pBindRuleset = pRuleset;
finalize_it:
	RETiRet;
}


/* to use HUP, we need to have an instanceData type, as this was
 * originally designed for actions. However, we do not, and cannot,
 * use the content. The core will always provide a NULL pointer.
 */
typedef struct _instanceData {
	int dummy;
} instanceData;
BEGINdoHUP
CODESTARTdoHUP
	DBGPRINTF(&quot;impstats: received HUP\n&quot;)
	pthread_mutex_lock(&amp;hup_mutex);
	if(runModConf-&gt;logfd != -1) {
		DBGPRINTF(&quot;impstats: closing log file due to HUP\n&quot;);
		close(runModConf-&gt;logfd);
		runModConf-&gt;logfd = -1;
	}
	pthread_mutex_unlock(&amp;hup_mutex);
ENDdoHUP


BEGINcheckCnf
CODESTARTcheckCnf
	if(pModConf-&gt;iStatsInterval == 0) {
		LogError(0, NO_ERRCODE, &quot;impstats: stats interval zero not permitted, using &quot;
				&quot;default of %d seconds&quot;, DEFAULT_STATS_PERIOD);
		pModConf-&gt;iStatsInterval = DEFAULT_STATS_PERIOD;
	}
	checkRuleset(pModConf);
ENDcheckCnf


BEGINactivateCnf
	rsRetVal localRet;
CODESTARTactivateCnf
	runModConf = pModConf;
	DBGPRINTF(&quot;impstats: stats interval %d seconds, reset %d, logToSyslog %d, logFile %s\n&quot;,
		  runModConf-&gt;iStatsInterval, runModConf-&gt;bResetCtrs, runModConf-&gt;bLogToSyslog,
		  runModConf-&gt;logfile == NULL ? &quot;deactivated&quot; : (char*)runModConf-&gt;logfile);
	localRet = statsobj.EnableStats();
	if(localRet != RS_RET_OK) {
		LogError(0, localRet, &quot;impstats: error enabling statistics gathering&quot;);
		ABORT_FINALIZE(RS_RET_NO_RUN);
	}
	/* initialize our own counters */
	CHKiRet(statsobj.Construct(&amp;statsobj_resources));
	CHKiRet(statsobj.SetName(statsobj_resources, (uchar*)&quot;resource-usage&quot;));
	CHKiRet(statsobj.SetOrigin(statsobj_resources, (uchar*)&quot;impstats&quot;));
	CHKiRet(statsobj.AddCounter(statsobj_resources, UCHAR_CONSTANT(&quot;utime&quot;),
		ctrType_IntCtr, CTR_FLAG_NONE, &amp;st_ru_utime));
	CHKiRet(statsobj.AddCounter(statsobj_resources, UCHAR_CONSTANT(&quot;stime&quot;),
		ctrType_IntCtr, CTR_FLAG_NONE, &amp;st_ru_stime));
	CHKiRet(statsobj.AddCounter(statsobj_resources, UCHAR_CONSTANT(&quot;maxrss&quot;),
		ctrType_IntCtr, CTR_FLAG_NONE, &amp;st_ru_maxrss));
	CHKiRet(statsobj.AddCounter(statsobj_resources, UCHAR_CONSTANT(&quot;minflt&quot;),
		ctrType_IntCtr, CTR_FLAG_NONE, &amp;st_ru_minflt));
	CHKiRet(statsobj.AddCounter(statsobj_resources, UCHAR_CONSTANT(&quot;majflt&quot;),
		ctrType_IntCtr, CTR_FLAG_NONE, &amp;st_ru_majflt));
	CHKiRet(statsobj.AddCounter(statsobj_resources, UCHAR_CONSTANT(&quot;inblock&quot;),
		ctrType_IntCtr, CTR_FLAG_NONE, &amp;st_ru_inblock));
	CHKiRet(statsobj.AddCounter(statsobj_resources, UCHAR_CONSTANT(&quot;oublock&quot;),
		ctrType_IntCtr, CTR_FLAG_NONE, &amp;st_ru_oublock));
	CHKiRet(statsobj.AddCounter(statsobj_resources, UCHAR_CONSTANT(&quot;nvcsw&quot;),
		ctrType_IntCtr, CTR_FLAG_NONE, &amp;st_ru_nvcsw));
	CHKiRet(statsobj.AddCounter(statsobj_resources, UCHAR_CONSTANT(&quot;nivcsw&quot;),
		ctrType_IntCtr, CTR_FLAG_NONE, &amp;st_ru_nivcsw));
#	ifdef OS_LINUX
	CHKiRet(statsobj.AddCounter(statsobj_resources, UCHAR_CONSTANT(&quot;openfiles&quot;),
		ctrType_Int, CTR_FLAG_NONE, &amp;st_openfiles));
#	endif
	CHKiRet(statsobj.ConstructFinalize(statsobj_resources));
finalize_it:
	if(iRet != RS_RET_OK) {
		LogError(0, iRet, &quot;impstats: error activating module&quot;);
		iRet = RS_RET_NO_RUN;
	}
ENDactivateCnf


BEGINfreeCnf
CODESTARTfreeCnf
	if(runModConf-&gt;logfd != -1)
		close(runModConf-&gt;logfd);
	free(runModConf-&gt;logfile);
	free(runModConf-&gt;pszBindRuleset);
ENDfreeCnf


BEGINrunInput
CODESTARTrunInput
	/* this is an endless loop - it is terminated when the thread is
	 * signalled to do so. This, however, is handled by the framework,
	 * right into the sleep below. Note that we DELIBERATLY output
	 * final set of stats counters on termination request. Depending
	 * on configuration, they may not make it to the final destination...
	 */
	while(glbl.GetGlobalInputTermState() == 0) {
		srSleep(runModConf-&gt;iStatsInterval, 0); /* seconds, micro seconds */
		DBGPRINTF(&quot;impstats: woke up, generating messages\n&quot;);
		if(runModConf-&gt;bBracketing)
			submitLine(&quot;BEGIN&quot;, sizeof(&quot;BEGIN&quot;)-1);
		generateStatsMsgs();
		if(runModConf-&gt;bBracketing)
			submitLine(&quot;END&quot;, sizeof(&quot;END&quot;)-1);
	}
ENDrunInput


BEGINwillRun
CODESTARTwillRun
ENDwillRun


BEGINafterRun
CODESTARTafterRun
ENDafterRun


BEGINqueryEtryPt
CODESTARTqueryEtryPt
CODEqueryEtryPt_STD_IMOD_QUERIES
CODEqueryEtryPt_STD_CONF2_QUERIES
CODEqueryEtryPt_STD_CONF2_setModCnf_QUERIES
CODEqueryEtryPt_IsCompatibleWithFeature_IF_OMOD_QUERIES
CODEqueryEtryPt_doHUP
ENDqueryEtryPt

static rsRetVal resetConfigVariables(uchar __attribute__((unused)) *pp, void __attribute__((unused)) *pVal)
{
	initConfigSettings();
	return RS_RET_OK;
}


BEGINmodInit()
CODESTARTmodInit
	*ipIFVersProvided = CURR_MOD_IF_VERSION; /* we only support the current interface specification */
CODEmodInit_QueryRegCFSLineHdlr
	DBGPRINTF(&quot;impstats version %s loading\n&quot;, VERSION);
	initConfigSettings();
	CHKiRet(objUse(glbl, CORE_COMPONENT));
	CHKiRet(objUse(prop, CORE_COMPONENT));
	CHKiRet(objUse(statsobj, CORE_COMPONENT));
	CHKiRet(objUse(ruleset, CORE_COMPONENT));
	/* the pstatsinverval is an alias to support a previous screwed-up syntax... */
	CHKiRet(regCfSysLineHdlr2((uchar *)&quot;pstatsinterval&quot;, 0, eCmdHdlrInt, NULL, &amp;cs.iStatsInterval,
	STD_LOADABLE_MODULE_ID, &amp;bLegacyCnfModGlobalsPermitted));
	CHKiRet(regCfSysLineHdlr2((uchar *)&quot;pstatinterval&quot;, 0, eCmdHdlrInt, NULL, &amp;cs.iStatsInterval,
	STD_LOADABLE_MODULE_ID, &amp;bLegacyCnfModGlobalsPermitted));
	CHKiRet(regCfSysLineHdlr2((uchar *)&quot;pstatfacility&quot;, 0, eCmdHdlrInt, NULL, &amp;cs.iFacility,
	STD_LOADABLE_MODULE_ID, &amp;bLegacyCnfModGlobalsPermitted));
	CHKiRet(regCfSysLineHdlr2((uchar *)&quot;pstatseverity&quot;, 0, eCmdHdlrInt, NULL, &amp;cs.iSeverity,
	STD_LOADABLE_MODULE_ID, &amp;bLegacyCnfModGlobalsPermitted));
	CHKiRet(regCfSysLineHdlr2((uchar *)&quot;pstatjson&quot;, 0, eCmdHdlrBinary, NULL, &amp;cs.bJSON,
	STD_LOADABLE_MODULE_ID, &amp;bLegacyCnfModGlobalsPermitted));
	CHKiRet(regCfSysLineHdlr2((uchar *)&quot;pstatcee&quot;, 0, eCmdHdlrBinary, NULL, &amp;cs.bCEE,
	STD_LOADABLE_MODULE_ID, &amp;bLegacyCnfModGlobalsPermitted));
	CHKiRet(omsdRegCFSLineHdlr((uchar *)&quot;resetconfigvariables&quot;, 1, eCmdHdlrCustomHandler, resetConfigVariables,
	NULL, STD_LOADABLE_MODULE_ID));

	CHKiRet(prop.Construct(&amp;pInputName));
	CHKiRet(prop.SetString(pInputName, UCHAR_CONSTANT(&quot;impstats&quot;), sizeof(&quot;impstats&quot;) - 1));
	CHKiRet(prop.ConstructFinalize(pInputName));
ENDmodInit
/* vi:set ai:
 */
</PRE>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>omrelp.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
/* omrelp.c
 *
 * This is the implementation of the RELP output module.
 *
 * Note that when multiple action workers are activated, we currently
 * also create multiple actions. This may be the source of some mild
 * message loss (!) if the worker instance is shut down while the
 * connection to the remote system is in retry state.
 * TODO: think if we should implement a mode where we do NOT
 *       support multiple action worker instances. This would be
 *       slower, but not have this loss opportunity. But it should
 *       definitely be optional and by default off due to the
 *       performance implications (and given the fact that message
 *       loss is pretty unlikely in usual cases).
 *
 *
 * File begun on 2008-03-13 by RGerhards
 *
 * Copyright 2008-2019 Adiscon GmbH.
 *
 * This file is part of rsyslog.
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *       -or-
 *       see COPYING.ASL20 in the source distribution
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#include &quot;config.h&quot;
#include &quot;rsyslog.h&quot;
#include &lt;stdio.h&gt;
#include &lt;stdarg.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;assert.h&gt;
#include &lt;errno.h&gt;
#include &lt;ctype.h&gt;
#include &lt;librelp.h&gt;
#include &quot;conf.h&quot;
#include &quot;syslogd-types.h&quot;
#include &quot;srUtils.h&quot;
#include &quot;cfsysline.h&quot;
#include &quot;module-template.h&quot;
#include &quot;glbl.h&quot;
#include &quot;errmsg.h&quot;
#include &quot;debug.h&quot;
#include &quot;parserif.h&quot;
#include &quot;unicode-helper.h&quot;

#ifndef RELP_DFLT_PT
#	define RELP_DFLT_PT &quot;514&quot;
#endif

MODULE_TYPE_OUTPUT
MODULE_TYPE_NOKEEP
MODULE_CNFNAME(&quot;omrelp&quot;)

/* internal structures
 */
DEF_OMOD_STATIC_DATA
DEFobjCurrIf(glbl)

#define DFLT_ENABLE_TLS 0
#define DFLT_ENABLE_TLSZIP 0

static relpEngine_t *pRelpEngine;	/* our relp engine */

typedef struct _instanceData {
	uchar *target;
	uchar *port;
	int sizeWindow;		/**&lt; the RELP window size - 0=use default */
	unsigned timeout;
	int connTimeout;
	unsigned rebindInterval;
	sbool bEnableTLS;
	sbool bEnableTLSZip;
	sbool bHadAuthFail;	/**&lt; set on auth failure, will cause retry to disable action */
	uchar *pristring;		/* GnuTLS priority string (NULL if not to be provided) */
	uchar *authmode;
	uchar *caCertFile;
	uchar *myCertFile;
	uchar *myPrivKeyFile;
#if defined(HAVE_RELPENGINESETTLSCFGCMD)
	uchar *tlscfgcmd;
#endif
	uchar *tplName;
	uchar *localClientIP;
	struct {
		int nmemb;
		uchar **name;
	} permittedPeers;
} instanceData;

typedef struct wrkrInstanceData {
	instanceData *pData;
	int bInitialConnect; /* is this the initial connection request of our module? (0-no, 1-yes) */
	int bIsConnected; /* currently connected to server? 0 - no, 1 - yes */
	int bIsSuspended; /* currently suspended (than no more error messages) */
	relpClt_t *pRelpClt; /* relp client for this instance */
	unsigned nSent; /* number msgs sent - for rebind support */
} wrkrInstanceData_t;

typedef struct configSettings_s {
	EMPTY_STRUCT
} configSettings_t;
static configSettings_t __attribute__((unused)) cs;

static rsRetVal doCreateRelpClient(instanceData *pData, relpClt_t **pRelpClt);

struct modConfData_s {
	rsconf_t *pConf;	/* our overall config object */
	const char  *tlslib;
};

static modConfData_t *loadModConf = NULL;/* modConf ptr to use for the current load process */
static modConfData_t *runModConf = NULL;/* modConf ptr to use for the current exec process */

/* tables for interfacing with the v6 config system */
/* module-global parameters */
static struct cnfparamdescr modpdescr[] = {
	{ &quot;tls.tlslib&quot;, eCmdHdlrString, 0 }
};
static struct cnfparamblk modpblk =
	{ CNFPARAMBLK_VERSION,
	  sizeof(modpdescr)/sizeof(struct cnfparamdescr),
	  modpdescr
	};
/* action (instance) parameters */
static struct cnfparamdescr actpdescr[] = {
	{ &quot;target&quot;, eCmdHdlrGetWord, 1 },
	{ &quot;tls&quot;, eCmdHdlrBinary, 0 },
	{ &quot;tls.compression&quot;, eCmdHdlrBinary, 0 },
	{ &quot;tls.prioritystring&quot;, eCmdHdlrString, 0 },
	{ &quot;tls.cacert&quot;, eCmdHdlrString, 0 },
<A NAME="0"></A>	{ &quot;tls.mycert&quot;, eCmdHdlrString, 0 },
	{ &quot;tls.myprivkey&quot;, eCmdHdlrString, 0 },
	{ &quot;tls.authmode&quot;, eCmdHdlrString, 0 },
<FONT color="#0000ff"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match344-0.html#0',2,'match344-top.html#0',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>	{ &quot;tls.tlscfgcmd&quot;, eCmdHdlrString, 0 },
	{ &quot;tls.permittedpeer&quot;, eCmdHdlrArray, 0 },
	{ &quot;port&quot;, eCmdHdlrGetWord, 0 },
	{ &quot;rebindinterval&quot;, eCmdHdlrInt, 0 },
	{ &quot;windowsize&quot;, eCmdHdlrInt, 0 },
	{ &quot;timeout&quot;, eCmdHdlrInt, 0 },
	{ &quot;conn.timeout&quot;, eCmdHdlrInt, 0 },
	{ &quot;localclientip&quot;, eCmdHdlrGetWord, 0 },
	{ &quot;template&quot;, eCmdHdlrGetWord, 0 }
};
static struct cnfparamblk actpblk =
	{ CNFPARAMBLK_VERSION,
	  sizeof(actpdescr)/sizeof(struct cnfparamdescr),
	  actpdescr
	};

BEGINinitConfVars		/* (re)set config variables to default values */
CODESTARTinitConfVars
ENDinitConfVars

/* We may change the implementation to try to lookup the port
 * if it is unspecified. So far, we use 514 as default (what probably
 * is not a really bright idea, but kept for backward compatibility).
 */

PRAGMA_DIAGNOSTIC_PUSH
PRAGMA_IGNORE_Wformat_nonliteral
static void __attribute__((format(printf, 1, 2)))</B></FONT>
omrelp_dbgprintf(const char *fmt, ...)
{
	va_list ap;
	char pszWriteBuf[32*1024+1]; //this function has to be able to
					/*generate a buffer longer than that of r_dbgprintf, so
					r_dbgprintf can properly truncate*/
	if(!(Debug &amp;&amp; debugging_on)) {
		return;
	}

	va_start(ap, fmt);
	vsnprintf(pszWriteBuf, sizeof(pszWriteBuf), fmt, ap);
	va_end(ap);
	r_dbgprintf(&quot;omrelp.c&quot;, &quot;%s&quot;, pszWriteBuf);
}
PRAGMA_DIAGNOSTIC_POP


static uchar *getRelpPt(instanceData *pData)
{
	assert(pData != NULL);
	if(pData-&gt;port == NULL)
		return((uchar*)RELP_DFLT_PT);
	else
		return(pData-&gt;port);
}

static void
onErr(void *pUsr, char *objinfo, char* errmesg, __attribute__((unused)) relpRetVal errcode)
{
	wrkrInstanceData_t *pWrkrData = (wrkrInstanceData_t*) pUsr;
	LogError(0, RS_RET_RELP_AUTH_FAIL, &quot;omrelp[%s:%s]: error '%s', object &quot;
			&quot; '%s' - action may not work as intended&quot;,
			pWrkrData-&gt;pData-&gt;target, pWrkrData-&gt;pData-&gt;port, errmesg, objinfo);
}

static void
onGenericErr(char *objinfo, char* errmesg, __attribute__((unused)) relpRetVal errcode)
{
	LogError(0, RS_RET_RELP_ERR, &quot;omrelp: librelp error '%s', object &quot;
			&quot;'%s' - action may not work as intended&quot;,
			errmesg, objinfo);
}

static void
onAuthErr(void *pUsr, char *authinfo, char* errmesg, __attribute__((unused)) relpRetVal errcode)
{
	instanceData *pData = ((wrkrInstanceData_t*) pUsr)-&gt;pData;
	LogError(0, RS_RET_RELP_AUTH_FAIL, &quot;omrelp[%s:%s]: authentication error '%s', peer &quot;
			&quot;is '%s' - DISABLING action&quot;, pData-&gt;target, pData-&gt;port, errmesg, authinfo);
	pData-&gt;bHadAuthFail = 1;
}

static rsRetVal
doCreateRelpClient(instanceData *pData, relpClt_t **pRelpClt)
{
	int i;
	DEFiRet;

	if(relpEngineCltConstruct(pRelpEngine, pRelpClt) != RELP_RET_OK)
		ABORT_FINALIZE(RS_RET_RELP_ERR);
	if(relpCltSetTimeout(*pRelpClt, pData-&gt;timeout) != RELP_RET_OK)
		ABORT_FINALIZE(RS_RET_RELP_ERR);
	if(relpCltSetConnTimeout(*pRelpClt, pData-&gt;connTimeout) != RELP_RET_OK) {
		ABORT_FINALIZE(RS_RET_RELP_ERR);
	}
	if(relpCltSetWindowSize(*pRelpClt, pData-&gt;sizeWindow) != RELP_RET_OK)
		ABORT_FINALIZE(RS_RET_RELP_ERR);
	if(pData-&gt;bEnableTLS) {
		if(relpCltEnableTLS(*pRelpClt) != RELP_RET_OK)
			ABORT_FINALIZE(RS_RET_RELP_ERR);
		if(pData-&gt;bEnableTLSZip) {
			if(relpCltEnableTLSZip(*pRelpClt) != RELP_RET_OK)
				ABORT_FINALIZE(RS_RET_RELP_ERR);
		}
		if(relpCltSetGnuTLSPriString(*pRelpClt, (char*) pData-&gt;pristring) != RELP_RET_OK)
			ABORT_FINALIZE(RS_RET_RELP_ERR);


		if(relpCltSetAuthMode(*pRelpClt, (char*) pData-&gt;authmode) != RELP_RET_OK) {
			LogError(0, RS_RET_RELP_ERR,
					&quot;omrelp: invalid auth mode '%s'\n&quot;, pData-&gt;authmode);
			ABORT_FINALIZE(RS_RET_RELP_ERR);
		}

		if(relpCltSetCACert(*pRelpClt, (char*) pData-&gt;caCertFile) != RELP_RET_OK)
			ABORT_FINALIZE(RS_RET_RELP_ERR);
		if(relpCltSetOwnCert(*pRelpClt, (char*) pData-&gt;myCertFile) != RELP_RET_OK)
			ABORT_FINALIZE(RS_RET_RELP_ERR);
		if(relpCltSetPrivKey(*pRelpClt, (char*) pData-&gt;myPrivKeyFile) != RELP_RET_OK)
			ABORT_FINALIZE(RS_RET_RELP_ERR);
#if defined(HAVE_RELPENGINESETTLSCFGCMD)
		if (pData-&gt;tlscfgcmd != NULL) {
			if(relpCltSetTlsConfigCmd(*pRelpClt, (char*) pData-&gt;tlscfgcmd) != RELP_RET_OK)
				ABORT_FINALIZE(RS_RET_RELP_ERR);
		}
#endif
		for(i = 0 ; i &lt;  pData-&gt;permittedPeers.nmemb ; ++i) {
			relpCltAddPermittedPeer(*pRelpClt, (char*)pData-&gt;permittedPeers.name[i]);
		}
	}
	if(pData-&gt;localClientIP != NULL) {
		if(relpCltSetClientIP(*pRelpClt, pData-&gt;localClientIP) != RELP_RET_OK)
			ABORT_FINALIZE(RS_RET_RELP_ERR);
	}
finalize_it:

	RETiRet;
}

BEGINendCnfLoad
CODESTARTendCnfLoad
	loadModConf = NULL;
	runModConf = pModConf;
ENDendCnfLoad

BEGINcheckCnf
CODESTARTcheckCnf
ENDcheckCnf

BEGINactivateCnf
CODESTARTactivateCnf
ENDactivateCnf

BEGINfreeCnf
CODESTARTfreeCnf
	free((void*)pModConf-&gt;tlslib);
ENDfreeCnf
<A NAME="4"></A>
BEGINcreateInstance
CODESTARTcreateInstance
<FONT color="#6cc417"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match344-0.html#4',2,'match344-top.html#4',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>	pData-&gt;sizeWindow = 0;
	pData-&gt;timeout = 90;
	pData-&gt;connTimeout = 10;
	pData-&gt;rebindInterval = 0;
	pData-&gt;bEnableTLS = DFLT_ENABLE_TLS;
	pData-&gt;bEnableTLSZip = DFLT_ENABLE_TLSZIP;
	pData-&gt;bHadAuthFail = 0;
	pData-&gt;pristring = NULL;
	pData-&gt;authmode = NULL;
	pData-&gt;localClientIP = NULL;</B></FONT>
	pData-&gt;caCertFile = NULL;
	pData-&gt;myCertFile = NULL;
	pData-&gt;myPrivKeyFile = NULL;
#if defined(HAVE_RELPENGINESETTLSCFGCMD)
	pData-&gt;tlscfgcmd = NULL;
#endif
	pData-&gt;permittedPeers.nmemb = 0;
ENDcreateInstance

BEGINcreateWrkrInstance
CODESTARTcreateWrkrInstance
	pWrkrData-&gt;pRelpClt = NULL;
	iRet = doCreateRelpClient(pWrkrData-&gt;pData, &amp;pWrkrData-&gt;pRelpClt);
	if(relpCltSetUsrPtr(pWrkrData-&gt;pRelpClt, pWrkrData) != RELP_RET_OK)
		LogError(0, RS_RET_NO_ERRCODE, &quot;omrelp: error when creating relp client&quot;);
	pWrkrData-&gt;bInitialConnect = 1;
	pWrkrData-&gt;nSent = 0;
ENDcreateWrkrInstance

BEGINfreeInstance
	int i;
CODESTARTfreeInstance
	free(pData-&gt;target);
	free(pData-&gt;port);
	free(pData-&gt;tplName);
	free(pData-&gt;pristring);
	free(pData-&gt;authmode);
	free(pData-&gt;localClientIP);
	free(pData-&gt;caCertFile);
	free(pData-&gt;myCertFile);
	free(pData-&gt;myPrivKeyFile);
#if defined(HAVE_RELPENGINESETTLSCFGCMD)
	free(pData-&gt;tlscfgcmd);
#endif
	if(pData-&gt;permittedPeers.name != NULL) {
		for(i = 0 ; i &lt;  pData-&gt;permittedPeers.nmemb ; ++i) {
			free(pData-&gt;permittedPeers.name[i]);
		}
	}
ENDfreeInstance

BEGINfreeWrkrInstance
CODESTARTfreeWrkrInstance
	if(pWrkrData-&gt;pRelpClt != NULL)
		relpEngineCltDestruct(pRelpEngine, &amp;pWrkrData-&gt;pRelpClt);
ENDfreeWrkrInstance

static void
setInstParamDefaults(instanceData *pData)
{
	pData-&gt;target = NULL;
	pData-&gt;port = NULL;
	pData-&gt;tplName = NULL;
	pData-&gt;timeout = 90;
	pData-&gt;connTimeout = 10;
	pData-&gt;sizeWindow = 0;
	pData-&gt;rebindInterval = 0;
	pData-&gt;bEnableTLS = DFLT_ENABLE_TLS;
	pData-&gt;bEnableTLSZip = DFLT_ENABLE_TLSZIP;
	pData-&gt;pristring = NULL;
	pData-&gt;authmode = NULL;
	if(glbl.GetSourceIPofLocalClient() == NULL)
		pData-&gt;localClientIP = NULL;
	else
		pData-&gt;localClientIP = (uchar*)strdup((char*)glbl.GetSourceIPofLocalClient());
	pData-&gt;caCertFile = NULL;
	pData-&gt;myCertFile = NULL;
	pData-&gt;myPrivKeyFile = NULL;
#if defined(HAVE_RELPENGINESETTLSCFGCMD)
	pData-&gt;tlscfgcmd = NULL;
#endif
	pData-&gt;permittedPeers.name = NULL;
	pData-&gt;permittedPeers.nmemb = 0;
}

BEGINbeginCnfLoad
CODESTARTbeginCnfLoad
	loadModConf = pModConf;
	pModConf-&gt;pConf = pConf;
	pModConf-&gt;tlslib = NULL;
	/* create our relp engine */
	CHKiRet(relpEngineConstruct(&amp;pRelpEngine));
	CHKiRet(relpEngineSetDbgprint(pRelpEngine, (void (*)(char *, ...))omrelp_dbgprintf));
	CHKiRet(relpEngineSetOnAuthErr(pRelpEngine, onAuthErr));
	CHKiRet(relpEngineSetOnGenericErr(pRelpEngine, onGenericErr));
	CHKiRet(relpEngineSetOnErr(pRelpEngine, onErr));
	CHKiRet(relpEngineSetEnableCmd(pRelpEngine, (uchar*) &quot;syslog&quot;, eRelpCmdState_Required));
finalize_it:
ENDbeginCnfLoad
<A NAME="1"></A>
BEGINsetModCnf
	struct cnfparamvals *pvals = NULL;
<FONT color="#f63526"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match344-0.html#1',2,'match344-top.html#1',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>	int i;
CODESTARTsetModCnf
	pvals = nvlstGetParams(lst, &amp;modpblk, NULL);
	if(pvals == NULL) {
		parser_errmsg(&quot;imrelp: error processing module config parameters [module(...)]&quot;);
		ABORT_FINALIZE(RS_RET_MISSING_CNFPARAMS);
	}

	if(Debug) {
		dbgprintf(&quot;module (global) param blk for omrelp:\n&quot;);
		cnfparamsPrint(&amp;modpblk, pvals);
	}

	for(i = 0 ; i &lt; modpblk.nParams ; ++i) {
		if(!pvals[i].bUsed) {</B></FONT>
			continue;
		}
		if(!strcmp(modpblk.descr[i].name, &quot;tls.tlslib&quot;)) {
			#if defined(HAVE_RELPENGINESETTLSLIBBYNAME)
				loadModConf-&gt;tlslib = es_str2cstr(pvals[i].val.d.estr, NULL);
				if(relpEngineSetTLSLibByName(pRelpEngine, loadModConf-&gt;tlslib) != RELP_RET_OK) {
					LogMsg(0, RS_RET_CONF_PARAM_INVLD, LOG_WARNING,
						&quot;omrelp: tlslib '%s' not accepted as valid by librelp - using default&quot;,
						loadModConf-&gt;tlslib);
				}
			#else
				LogError(0, RS_RET_NOT_IMPLEMENTED,
					&quot;omrelp warning: parameter tls.tlslib ignored - librelp does not support &quot;
					&quot;this API call. Using whatever librelp was compiled with.&quot;);
			#endif
		} else {
			dbgprintf(&quot;imfile: program error, non-handled &quot;
			  &quot;param '%s' in beginCnfLoad\n&quot;, modpblk.descr[i].name);
		}
	}
finalize_it:
	if(pvals != NULL)
		cnfparamvalsDestruct(pvals, &amp;modpblk);
ENDsetModCnf

BEGINnewActInst
	struct cnfparamvals *pvals;
	int i,j;
	FILE *fp;
	relpClt_t *pRelpClt = NULL;
CODESTARTnewActInst
	if((pvals = nvlstGetParams(lst, &amp;actpblk, NULL)) == NULL) {
		ABORT_FINALIZE(RS_RET_MISSING_CNFPARAMS);
	}

	CHKiRet(createInstance(&amp;pData));
	setInstParamDefaults(pData);

	for(i = 0 ; i &lt; actpblk.nParams ; ++i) {
		if(!pvals[i].bUsed)
<A NAME="3"></A>			continue;
		if(!strcmp(actpblk.descr[i].name, &quot;target&quot;)) {
			pData-&gt;target = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
<FONT color="#53858b"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match344-0.html#3',2,'match344-top.html#3',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>		} else if(!strcmp(actpblk.descr[i].name, &quot;port&quot;)) {
			pData-&gt;port = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
		} else if(!strcmp(actpblk.descr[i].name, &quot;template&quot;)) {
			pData-&gt;tplName = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);</B></FONT>
		} else if(!strcmp(actpblk.descr[i].name, &quot;localclientip&quot;)) {
			pData-&gt;localClientIP = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
		} else if(!strcmp(actpblk.descr[i].name, &quot;timeout&quot;)) {
			pData-&gt;timeout = (unsigned) pvals[i].val.d.n;
		} else if(!strcmp(actpblk.descr[i].name, &quot;conn.timeout&quot;)) {
			pData-&gt;connTimeout = (int) pvals[i].val.d.n;
		} else if(!strcmp(actpblk.descr[i].name, &quot;rebindinterval&quot;)) {
			pData-&gt;rebindInterval = (unsigned) pvals[i].val.d.n;
		} else if(!strcmp(actpblk.descr[i].name, &quot;windowsize&quot;)) {
			pData-&gt;sizeWindow = (int) pvals[i].val.d.n;
		} else if(!strcmp(actpblk.descr[i].name, &quot;tls&quot;)) {
			pData-&gt;bEnableTLS = (unsigned) pvals[i].val.d.n;
		} else if(!strcmp(actpblk.descr[i].name, &quot;tls.compression&quot;)) {
			pData-&gt;bEnableTLSZip = (unsigned) pvals[i].val.d.n;
		} else if(!strcmp(actpblk.descr[i].name, &quot;tls.prioritystring&quot;)) {
			pData-&gt;pristring = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
		} else if(!strcmp(actpblk.descr[i].name, &quot;tls.cacert&quot;)) {
			pData-&gt;caCertFile = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
			fp = fopen((const char*)pData-&gt;caCertFile, &quot;r&quot;);
			if(fp == NULL) {
				char errStr[1024];
				rs_strerror_r(errno, errStr, sizeof(errStr));
				LogError(0, RS_RET_NO_FILE_ACCESS,
				&quot;error: certificate file %s couldn't be accessed: %s\n&quot;,
				pData-&gt;caCertFile, errStr);
			} else {
				fclose(fp);
			}
		} else if(!strcmp(actpblk.descr[i].name, &quot;tls.mycert&quot;)) {
			pData-&gt;myCertFile = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
			fp = fopen((const char*)pData-&gt;myCertFile, &quot;r&quot;);
			if(fp == NULL) {
				char errStr[1024];
				rs_strerror_r(errno, errStr, sizeof(errStr));
				LogError(0, RS_RET_NO_FILE_ACCESS,
				&quot;error: certificate file %s couldn't be accessed: %s\n&quot;,
				pData-&gt;myCertFile, errStr);
			} else {
				fclose(fp);
			}
		} else if(!strcmp(actpblk.descr[i].name, &quot;tls.myprivkey&quot;)) {
			pData-&gt;myPrivKeyFile = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
			fp = fopen((const char*)pData-&gt;myPrivKeyFile, &quot;r&quot;);
			if(fp == NULL) {
				char errStr[1024];
				rs_strerror_r(errno, errStr, sizeof(errStr));
<A NAME="2"></A>				LogError(0, RS_RET_NO_FILE_ACCESS,
				&quot;error: certificate file %s couldn't be accessed: %s\n&quot;,
				pData-&gt;myPrivKeyFile, errStr);
<FONT color="#980517"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match344-0.html#2',2,'match344-top.html#2',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>			} else {
				fclose(fp);
			}
		} else if(!strcmp(actpblk.descr[i].name, &quot;tls.tlscfgcmd&quot;)) {
#if defined(HAVE_RELPENGINESETTLSCFGCMD)
			pData-&gt;tlscfgcmd = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
#else
			LogError(0, RS_RET_NOT_IMPLEMENTED, &quot;omrelp: librelp does not support input parameter &quot;
				&quot;'tls.tlscfgcmd'; it probably is too old (1.5.0 or higher should be fine); &quot;
				&quot;ignoring setting now.&quot;);
#endif
		} else if(!strcmp(actpblk.descr[i].name, &quot;tls.authmode&quot;)) {</B></FONT>
			pData-&gt;authmode = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
		} else if(!strcmp(actpblk.descr[i].name, &quot;tls.permittedpeer&quot;)) {
			pData-&gt;permittedPeers.nmemb = pvals[i].val.d.ar-&gt;nmemb;
			CHKmalloc(pData-&gt;permittedPeers.name =
				malloc(sizeof(uchar*) * pData-&gt;permittedPeers.nmemb));
			for(j = 0 ; j &lt;  pData-&gt;permittedPeers.nmemb ; ++j) {
				pData-&gt;permittedPeers.name[j] = (uchar*)es_str2cstr(pvals[i].val.d.ar-&gt;arr[j], NULL);
			}
		} else {
			dbgprintf(&quot;omrelp: program error, non-handled &quot;
			  &quot;param '%s'\n&quot;, actpblk.descr[i].name);
		}
	}

	CODE_STD_STRING_REQUESTnewActInst(1)

	CHKiRet(OMSRsetEntry(*ppOMSR, 0, (uchar*)strdup((pData-&gt;tplName == NULL) ?
			    &quot;RSYSLOG_ForwardFormat&quot; : (char*)pData-&gt;tplName),
	   		    OMSR_NO_RQD_TPL_OPTS));

	iRet = doCreateRelpClient(pData, &amp;pRelpClt);
	if(pRelpClt != NULL)
		relpEngineCltDestruct(pRelpEngine, &amp;pRelpClt);

CODE_STD_FINALIZERnewActInst
	if(pvals != NULL)
		cnfparamvalsDestruct(pvals, &amp;actpblk);
ENDnewActInst

BEGINisCompatibleWithFeature
CODESTARTisCompatibleWithFeature
	if(eFeat == sFEATURERepeatedMsgReduction)
		iRet = RS_RET_OK;
ENDisCompatibleWithFeature

BEGINSetShutdownImmdtPtr
CODESTARTSetShutdownImmdtPtr
	relpEngineSetShutdownImmdtPtr(pRelpEngine, pPtr);
	DBGPRINTF(&quot;omrelp: shutdownImmediate ptr now is %p\n&quot;, pPtr);
ENDSetShutdownImmdtPtr


BEGINdbgPrintInstInfo
CODESTARTdbgPrintInstInfo
	dbgprintf(&quot;RELP/%s&quot;, pData-&gt;target);
ENDdbgPrintInstInfo


/* try to connect to server
 * rgerhards, 2008-03-21
 */
static rsRetVal ATTR_NONNULL()
doConnect(wrkrInstanceData_t *const pWrkrData)
{
	DEFiRet;

	if(pWrkrData-&gt;bInitialConnect) {
		iRet = relpCltConnect(pWrkrData-&gt;pRelpClt, glbl.GetDefPFFamily(runModConf-&gt;pConf),
				      getRelpPt(pWrkrData-&gt;pData), pWrkrData-&gt;pData-&gt;target);
		if(iRet == RELP_RET_OK)
			pWrkrData-&gt;bInitialConnect = 0;
	} else {
		iRet = relpCltReconnect(pWrkrData-&gt;pRelpClt);
	}

	if(iRet == RELP_RET_OK) {
		pWrkrData-&gt;bIsConnected = 1;
	} else if(iRet == RELP_RET_ERR_NO_TLS) {
		LogError(0, iRet, &quot;omrelp: Could not connect, librelp does NOT &quot;
				&quot;support TLS (most probably GnuTLS lib &quot;
				&quot;is too old)!&quot;);
		FINALIZE;
	} else if(iRet == RELP_RET_ERR_NO_TLS_AUTH) {
		LogError(0, iRet, &quot;omrelp: could not activate relp TLS with &quot;
				&quot;authentication, librelp does not support it &quot;
				&quot;(most probably GnuTLS lib is too old)! &quot;
				&quot;Note: anonymous TLS is probably supported.&quot;);
		FINALIZE;
	} else {
		if(pWrkrData-&gt;bIsSuspended == 0) {
			LogError(0, RS_RET_RELP_ERR, &quot;omrelp: could not connect to &quot;
				&quot;remote server, librelp error %d&quot;, iRet);
		}
		pWrkrData-&gt;bIsConnected = 0;
		pWrkrData-&gt;bIsSuspended = 1;
		iRet = RS_RET_SUSPENDED;
	}

finalize_it:
	RETiRet;
}


BEGINtryResume
CODESTARTtryResume
	if(pWrkrData-&gt;pData-&gt;bHadAuthFail) {
		ABORT_FINALIZE(RS_RET_DISABLE_ACTION);
	}
	iRet = doConnect(pWrkrData);
finalize_it:
ENDtryResume

static rsRetVal
doRebind(wrkrInstanceData_t *pWrkrData)
{
	DEFiRet;
	DBGPRINTF(&quot;omrelp: destructing relp client due to rebindInterval\n&quot;);
	CHKiRet(relpEngineCltDestruct(pRelpEngine, &amp;pWrkrData-&gt;pRelpClt));
	pWrkrData-&gt;bIsConnected = 0;
	CHKiRet(doCreateRelpClient(pWrkrData-&gt;pData, &amp;pWrkrData-&gt;pRelpClt));
	if(relpCltSetUsrPtr(pWrkrData-&gt;pRelpClt, pWrkrData) != RELP_RET_OK)
		LogError(0, RS_RET_NO_ERRCODE, &quot;omrelp: error when creating relp client&quot;);
	pWrkrData-&gt;bInitialConnect = 1;
	pWrkrData-&gt;nSent = 0;
finalize_it:
	RETiRet;
}

BEGINbeginTransaction
CODESTARTbeginTransaction
	DBGPRINTF(&quot;omrelp: beginTransaction\n&quot;);
	if(!pWrkrData-&gt;bIsConnected) {
		CHKiRet(doConnect(pWrkrData));
	}
	relpCltHintBurstBegin(pWrkrData-&gt;pRelpClt);
finalize_it:
ENDbeginTransaction

BEGINdoAction
	uchar *pMsg; /* temporary buffering */
	size_t lenMsg;
	relpRetVal ret;
	instanceData *pData;
CODESTARTdoAction
	pData = pWrkrData-&gt;pData;
	dbgprintf(&quot; %s:%s/RELP\n&quot;, pData-&gt;target, getRelpPt(pData));

	if(!pWrkrData-&gt;bIsConnected) {
		CHKiRet(doConnect(pWrkrData));
	}

	pMsg = ppString[0];
	lenMsg = strlen((char*) pMsg); /* TODO: don't we get this? */

	/* we need to truncate oversize msgs - no way around that... */
	if((int) lenMsg &gt; glbl.GetMaxLine(runModConf-&gt;pConf))
		lenMsg = glbl.GetMaxLine(runModConf-&gt;pConf);

	/* forward */
	ret = relpCltSendSyslog(pWrkrData-&gt;pRelpClt, (uchar*) pMsg, lenMsg);
	if(ret != RELP_RET_OK) {
		LogError(0, RS_RET_RELP_ERR, &quot;librelp error %d%s forwarding &quot;
				&quot;to server %s:%s - suspending\n&quot;, ret,
				(ret == RELP_RET_SESSION_BROKEN) ?
					&quot;[connection broken]&quot; : &quot;&quot;,
				pData-&gt;target, getRelpPt(pData));
		ABORT_FINALIZE(RS_RET_SUSPENDED);
	}

	if(pData-&gt;rebindInterval != 0 &amp;&amp;
	   (++pWrkrData-&gt;nSent &gt;= pData-&gt;rebindInterval)) {
	   	doRebind(pWrkrData);
	}
finalize_it:
	if(pData-&gt;bHadAuthFail)
		iRet = RS_RET_DISABLE_ACTION;
	if(iRet == RS_RET_OK) {
		/* we mimic non-commit, as otherwise our endTransaction handler
		 * will not get called. While this is not 100% correct, the worst
		 * that can happen is some message duplication, something that
		 * rsyslog generally accepts and prefers over message loss.
		 */
		iRet = RS_RET_PREVIOUS_COMMITTED;
	} else if(iRet == RS_RET_SUSPENDED) {
		pWrkrData-&gt;bIsSuspended = 1;
	}
ENDdoAction


BEGINendTransaction
CODESTARTendTransaction
	DBGPRINTF(&quot;omrelp: endTransaction, connected %d\n&quot;, pWrkrData-&gt;bIsConnected);
	if(pWrkrData-&gt;bIsConnected) {
		relpCltHintBurstEnd(pWrkrData-&gt;pRelpClt);
	}
ENDendTransaction

BEGINparseSelectorAct
	uchar *q;
	int i;
	int bErr;
CODESTARTparseSelectorAct
CODE_STD_STRING_REQUESTparseSelectorAct(1)
	if(!strncmp((char*) p, &quot;:omrelp:&quot;, sizeof(&quot;:omrelp:&quot;) - 1)) {
		p += sizeof(&quot;:omrelp:&quot;) - 1; /* eat indicator sequence (-1 because of '\0'!) */
	} else {
		ABORT_FINALIZE(RS_RET_CONFLINE_UNPROCESSED);
	}

	/* ok, if we reach this point, we have something for us */
	if((iRet = createInstance(&amp;pData)) != RS_RET_OK)
		FINALIZE;

	/* extract the host first (we do a trick - we replace the ';' or ':' with a '\0')
	 * now skip to port and then template name. rgerhards 2005-07-06
	 */
	if(*p == '[') { /* everything is hostname upto ']' */
		++p; /* skip '[' */
		for(q = p ; *p &amp;&amp; *p != ']' ; ++p)
			/* JUST SKIP */;
		if(*p == ']') {
			*p = '\0'; /* trick to obtain hostname (later)! */
			++p; /* eat it */
		}
	} else { /* traditional view of hostname */
		for(q = p ; *p &amp;&amp; *p != ';' &amp;&amp; *p != ':' &amp;&amp; *p != '#' ; ++p)
			/* JUST SKIP */;
	}

	pData-&gt;port = NULL;
	if(*p == ':') { /* process port */
		uchar * tmp;

		*p = '\0'; /* trick to obtain hostname (later)! */
		tmp = ++p;
		for(i=0 ; *p &amp;&amp; isdigit((int) *p) ; ++p, ++i)
			/* SKIP AND COUNT */;
		pData-&gt;port = malloc(i + 1);
		if(pData-&gt;port == NULL) {
			LogError(0, NO_ERRCODE, &quot;Could not get memory to store relp port, &quot;
				 &quot;using default port, results may not be what you intend\n&quot;);
			/* we leave f_forw.port set to NULL, this is then handled by getRelpPt() */
		} else {
			memcpy(pData-&gt;port, tmp, i);
			*(pData-&gt;port + i) = '\0';
		}
	}

	/* now skip to template */
	bErr = 0;
	while(*p &amp;&amp; *p != ';') {
		if(*p &amp;&amp; *p != ';' &amp;&amp; !isspace((int) *p)) {
			if(bErr == 0) { /* only 1 error msg! */
				bErr = 1;
				errno = 0;
				LogError(0, NO_ERRCODE, &quot;invalid selector line (port), probably not doing &quot;
					 &quot;what was intended&quot;);
			}
		}
		++p;
	}

	if(*p == ';') {
		*p = '\0'; /* trick to obtain hostname (later)! */
		CHKmalloc(pData-&gt;target = ustrdup(q));
		*p = ';';
	} else {
		CHKmalloc(pData-&gt;target = ustrdup(q));
	}

	/* process template */
	CHKiRet(cflineParseTemplateName(&amp;p, *ppOMSR, 0, OMSR_NO_RQD_TPL_OPTS, (uchar*) &quot;RSYSLOG_ForwardFormat&quot;));

CODE_STD_FINALIZERparseSelectorAct
ENDparseSelectorAct


BEGINmodExit
CODESTARTmodExit
	relpEngineDestruct(&amp;pRelpEngine);

	/* release what we no longer need */
	objRelease(glbl, CORE_COMPONENT);
ENDmodExit


BEGINqueryEtryPt
CODESTARTqueryEtryPt
CODEqueryEtryPt_STD_OMOD_QUERIES
CODEqueryEtryPt_STD_OMOD8_QUERIES
CODEqueryEtryPt_STD_CONF2_QUERIES
CODEqueryEtryPt_STD_CONF2_CNFNAME_QUERIES
CODEqueryEtryPt_STD_CONF2_OMOD_QUERIES
CODEqueryEtryPt_STD_CONF2_setModCnf_QUERIES
CODEqueryEtryPt_TXIF_OMOD_QUERIES
CODEqueryEtryPt_SetShutdownImmdtPtr
ENDqueryEtryPt


BEGINmodInit()
CODESTARTmodInit
INITLegCnfVars
	*ipIFVersProvided = CURR_MOD_IF_VERSION; /* we only support the current interface specification */
CODEmodInit_QueryRegCFSLineHdlr
	/* tell which objects we need */
	CHKiRet(objUse(glbl, CORE_COMPONENT));
ENDmodInit
</PRE>
</div>
  </div>
</body>
</html>
