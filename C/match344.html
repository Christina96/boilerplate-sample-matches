<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html><head><title>Matches for impstats.c &amp; omrelp.c</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for impstats.c &amp; omrelp.c
      </h3>
<h1 align="center">
        14.9%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>impstats.c (19.362745%)<th>omrelp.c (12.116565%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(104-123)<td><a href="#" name="0">(146-173)</a><td align="center"><font color="#ff0000">28</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(357-372)<td><a href="#" name="1">(407-421)</a><td align="center"><font color="#880000">15</font>
<tr onclick='openModal("#980517")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#980517"><font color="#980517">-</font><td><a href="#" name="2">(398-405)<td><a href="#" name="2">(518-529)</a><td align="center"><font color="#6d0000">12</font>
<tr onclick='openModal("#53858b")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#53858b"><font color="#53858b">-</font><td><a href="#" name="3">(386-389)<td><a href="#" name="3">(465-468)</a><td align="center"><font color="#6d0000">12</font>
<tr onclick='openModal("#6cc417")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#6cc417"><font color="#6cc417">-</font><td><a href="#" name="4">(335-345)<td><a href="#" name="4">(305-314)</a><td align="center"><font color="#6d0000">12</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>impstats.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
/* impstats.c
 * A module to periodically output statistics gathered by rsyslog.
 *
 * Copyright 2010-2018 Adiscon GmbH.
 *
 * This file is part of rsyslog.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *       -or-
 *       see COPYING.ASL20 in the source distribution
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#include "config.h"
#include "rsyslog.h"
#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;
#include &lt;assert.h&gt;
#include &lt;signal.h&gt;
#include &lt;string.h&gt;
#include &lt;pthread.h&gt;
#include &lt;fcntl.h&gt;
#include &lt;unistd.h&gt;
#include &lt;sys/uio.h&gt;
#include &lt;sys/stat.h&gt;
#include &lt;errno.h&gt;
#include &lt;sys/time.h&gt;
#include &lt;sys/resource.h&gt;
#ifdef OS_LINUX
#include &lt;sys/types.h&gt;
#include &lt;dirent.h&gt;
#endif

#include "dirty.h"
#include "cfsysline.h"
#include "module-template.h"
#include "errmsg.h"
#include "msg.h"
#include "srUtils.h"
#include "unicode-helper.h"
#include "glbl.h"
#include "statsobj.h"
#include "prop.h"
#include "ruleset.h"
#include "parserif.h"


MODULE_TYPE_INPUT
MODULE_TYPE_NOKEEP
MODULE_CNFNAME("impstats")

/* defines */
#define DEFAULT_STATS_PERIOD (5 * 60)
#define DEFAULT_FACILITY 5 /* syslog */
#define DEFAULT_SEVERITY 6 /* info */

/* Module static data */
DEF_IMOD_STATIC_DATA
DEFobjCurrIf(glbl)
DEFobjCurrIf(prop)
DEFobjCurrIf(statsobj)
DEFobjCurrIf(ruleset)

typedef struct configSettings_s {
	int iStatsInterval;
	int iFacility;
	int iSeverity;
	int bJSON;
	int bCEE;
} configSettings_t;

struct modConfData_s {
	rsconf_t *pConf; /* our overall config object */
	int iStatsInterval;
	int iFacility;
	int iSeverity;
	int logfd; /* fd if logging to file, or -1 if closed */
	ruleset_t *pBindRuleset;	/* ruleset to bind listener to (use system default if unspecified) */
	statsFmtType_t statsFmt;
	sbool bLogToSyslog;
	sbool bResetCtrs;
	sbool bBracketing;
	char *logfile;
	sbool configSetViaV2Method;
	uchar *pszBindRuleset;		/* name of ruleset to bind to */
};
static modConfData_t *loadModConf = NULL;/* modConf ptr to use for the current load process */
static modConfData_t *runModConf = NULL;/* modConf ptr to use for the current load process */

static configSettings_t cs;
static int bLegacyCnfModGlobalsPermitted;/* are legacy module-global config parameters permitted? */
static prop_t *pInputName = NULL;
<a name="0"></a>
/* module-global parameters */
static struct cnfparamdescr modpdescr[] = {
<font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>	{ "interval", eCmdHdlrInt, 0 },
	{ "facility", eCmdHdlrInt, 0 },
	{ "severity", eCmdHdlrInt, 0 },
	{ "bracketing", eCmdHdlrBinary, 0 },
	{ "log.syslog", eCmdHdlrBinary, 0 },
	{ "resetcounters", eCmdHdlrBinary, 0 },
	{ "log.file", eCmdHdlrGetWord, 0 },
	{ "format", eCmdHdlrGetWord, 0 },
	{ "ruleset", eCmdHdlrString, 0 }
};
static struct cnfparamblk modpblk =
	{ CNFPARAMBLK_VERSION,
	  sizeof(modpdescr)/sizeof(struct cnfparamdescr),
	  modpdescr
	};


/* resource use stats counters */
#ifdef OS_LINUX
static int st_openfiles;</b></font>
#endif
static intctr_t st_ru_utime;
static intctr_t st_ru_stime;
static intctr_t st_ru_maxrss;
static intctr_t st_ru_minflt;
static intctr_t st_ru_majflt;
static intctr_t st_ru_inblock;
static intctr_t st_ru_oublock;
static intctr_t st_ru_nvcsw;
static intctr_t st_ru_nivcsw;
static statsobj_t *statsobj_resources;

static pthread_mutex_t hup_mutex = PTHREAD_MUTEX_INITIALIZER;

BEGINmodExit
CODESTARTmodExit
	prop.Destruct(&amp;pInputName);
	/* release objects we used */
	objRelease(glbl, CORE_COMPONENT);
	objRelease(prop, CORE_COMPONENT);
	objRelease(statsobj, CORE_COMPONENT);
	objRelease(ruleset, CORE_COMPONENT);
ENDmodExit


BEGINisCompatibleWithFeature
CODESTARTisCompatibleWithFeature
	if(eFeat == sFEATURENonCancelInputTermination)
		iRet = RS_RET_OK;
ENDisCompatibleWithFeature


#ifdef OS_LINUX
/* count number of open files (linux specific) */
static void
countOpenFiles(void)
{
	char proc_path[MAXFNAME];
	DIR *dp;
	struct dirent *files;

	st_openfiles = 0;
	snprintf(proc_path, sizeof(proc_path), "/proc/%d/fd", glblGetOurPid());
	if((dp = opendir(proc_path)) == NULL) {
		LogError(errno, RS_RET_ERR, "impstats: error reading %s\n", proc_path);
		goto done;
	}
	while((files=readdir(dp)) != NULL) {
		if(!strcmp(files-&gt;d_name, ".") || !strcmp(files-&gt;d_name, ".."))
			continue;
		st_openfiles++;
	}
	closedir(dp);

done:
	return;
}
#endif


static void
initConfigSettings(void)
{
	cs.iStatsInterval = DEFAULT_STATS_PERIOD;
	cs.iFacility = DEFAULT_FACILITY;
	cs.iSeverity = DEFAULT_SEVERITY;
	cs.bJSON = 0;
	cs.bCEE = 0;
}


/* actually submit a message to the rsyslog core
 */
static void
doSubmitMsg(uchar *line)
{
	smsg_t *pMsg;

	if(msgConstruct(&amp;pMsg) != RS_RET_OK)
		goto finalize_it;
	MsgSetInputName(pMsg, pInputName);
	MsgSetRawMsgWOSize(pMsg, (char*)line);
	MsgSetHOSTNAME(pMsg, glbl.GetLocalHostName(), ustrlen(glbl.GetLocalHostName()));
	MsgSetRcvFrom(pMsg, glbl.GetLocalHostNameProp());
	MsgSetRcvFromIP(pMsg, glbl.GetLocalHostIP());
	MsgSetMSGoffs(pMsg, 0);
	MsgSetRuleset(pMsg, runModConf-&gt;pBindRuleset);
	MsgSetTAG(pMsg, UCHAR_CONSTANT("rsyslogd-pstats:"), sizeof("rsyslogd-pstats:") - 1);
	pMsg-&gt;iFacility = runModConf-&gt;iFacility;
	pMsg-&gt;iSeverity = runModConf-&gt;iSeverity;
	pMsg-&gt;msgFlags  = 0;

	/* we do not use rate-limiting, as the stats message always need to be emitted */
	submitMsg2(pMsg);
	DBGPRINTF("impstats: submit [%d,%d] msg '%s'\n", runModConf-&gt;iFacility,
	          runModConf-&gt;iSeverity, line);

finalize_it:
	return;
}


/* log stats message to file; limited error handling done */
static void
doLogToFile(const char *ln, const size_t lenLn)
{
	struct iovec iov[4];
	ssize_t nwritten;
	ssize_t nexpect;
	time_t t;
	char timebuf[32];

	pthread_mutex_lock(&amp;hup_mutex);

	if(lenLn == 0)
		goto done;

	if(runModConf-&gt;logfd == -1) {
		runModConf-&gt;logfd = open(runModConf-&gt;logfile, O_WRONLY|O_CREAT|O_APPEND|O_CLOEXEC, S_IRUSR|S_IWUSR);
		if(runModConf-&gt;logfd == -1) {
			DBGPRINTF("impstats: error opening stats file %s\n",
				runModConf-&gt;logfile);
			goto done;
		} else {
			DBGPRINTF("impstats: opened stats file %s\n",
				runModConf-&gt;logfile);
		}
	}

	time(&amp;t);
	iov[0].iov_base = ctime_r(&amp;t, timebuf);
	iov[0].iov_len = nexpect = strlen(iov[0].iov_base) - 1; /* -1: strip \n */
	iov[1].iov_base = (void*)": ";
	iov[1].iov_len = 2;
	nexpect += 2;
	iov[2].iov_base = (void*)ln;
	iov[2].iov_len = lenLn;
	nexpect += lenLn;
	iov[3].iov_base = (void*)"\n";
	iov[3].iov_len = 1;
	nexpect++;
	nwritten = writev(runModConf-&gt;logfd, iov, 4);

	if(nwritten != nexpect) {
			dbgprintf("error writing stats file %s, nwritten %lld, expected %lld\n",
				  runModConf-&gt;logfile, (long long) nwritten, (long long) nexpect);
	}
done:
	pthread_mutex_unlock(&amp;hup_mutex);
	return;
}


/* submit a line to our log destinations. Line must be fully formatted as
 * required (but may be a simple verb like "BEGIN" and "END".
 */
static rsRetVal
submitLine(const char *const ln, const size_t lenLn)
{
	DEFiRet;
	if(runModConf-&gt;bLogToSyslog)
		doSubmitMsg((uchar*)ln);
	if(runModConf-&gt;logfile != NULL)
		doLogToFile(ln, lenLn);
	RETiRet;
}

/* callback for statsobj
 * Note: usrptr exists only to satisfy requirements of statsobj callback interface!
 */
static rsRetVal
doStatsLine(void __attribute__((unused)) *usrptr, const char *const str)
{
	DEFiRet;
	iRet = submitLine(str, strlen(str));
	RETiRet;
}


/* the function to generate the actual statistics messages
 * rgerhards, 2010-09-09
 */
static void
generateStatsMsgs(void)
{
	struct rusage ru;
	int r;
	r = getrusage(RUSAGE_SELF, &amp;ru);
	if(r != 0) {
		dbgprintf("impstats: getrusage() failed with error %d, zeroing out\n", errno);
		memset(&amp;ru, 0, sizeof(ru));
	}
#	ifdef OS_LINUX
	countOpenFiles();
#	endif
	st_ru_utime = ru.ru_utime.tv_sec * 1000000 + ru.ru_utime.tv_usec;
	st_ru_stime = ru.ru_stime.tv_sec * 1000000 + ru.ru_stime.tv_usec;
	st_ru_maxrss = ru.ru_maxrss;
	st_ru_minflt = ru.ru_minflt;
	st_ru_majflt = ru.ru_majflt;
	st_ru_inblock = ru.ru_inblock;
	st_ru_oublock = ru.ru_oublock;
	st_ru_nvcsw = ru.ru_nvcsw;
	st_ru_nivcsw = ru.ru_nivcsw;
	statsobj.GetAllStatsLines(doStatsLine, NULL, runModConf-&gt;statsFmt, runModConf-&gt;bResetCtrs);
}


<a name="4"></a>BEGINbeginCnfLoad
CODESTARTbeginCnfLoad
	loadModConf = pModConf;
<font color="#6cc417"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>	pModConf-&gt;pConf = pConf;
	/* init our settings */
	loadModConf-&gt;configSetViaV2Method = 0;
	loadModConf-&gt;iStatsInterval = DEFAULT_STATS_PERIOD;
	loadModConf-&gt;iFacility = DEFAULT_FACILITY;
	loadModConf-&gt;iSeverity = DEFAULT_SEVERITY;
	loadModConf-&gt;statsFmt = statsFmt_Legacy;
	loadModConf-&gt;logfd = -1;
	loadModConf-&gt;logfile = NULL;
	loadModConf-&gt;pszBindRuleset = NULL;
	loadModConf-&gt;bLogToSyslog = 1;</b></font>
	loadModConf-&gt;bBracketing = 0;
	loadModConf-&gt;bResetCtrs = 0;
	bLegacyCnfModGlobalsPermitted = 1;
	/* init legacy config vars */
	initConfigSettings();
ENDbeginCnfLoad


<a name="1"></a>BEGINsetModCnf
	struct cnfparamvals *pvals = NULL;
	char *mode;
<font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>	int i;
CODESTARTsetModCnf
	pvals = nvlstGetParams(lst, &amp;modpblk, NULL);
	if(pvals == NULL) {
		LogError(0, RS_RET_MISSING_CNFPARAMS, "error processing module "
				"config parameters [module(...)]");
		ABORT_FINALIZE(RS_RET_MISSING_CNFPARAMS);
	}

	if(Debug) {
		dbgprintf("module (global) param blk for impstats:\n");
		cnfparamsPrint(&amp;modpblk, pvals);
	}

	for(i = 0 ; i &lt; modpblk.nParams ; ++i) {
		if(!pvals[i].bUsed)</b></font>
			continue;
		if(!strcmp(modpblk.descr[i].name, "interval")) {
			loadModConf-&gt;iStatsInterval = (int) pvals[i].val.d.n;
		} else if(!strcmp(modpblk.descr[i].name, "facility")) {
			loadModConf-&gt;iFacility = (int) pvals[i].val.d.n;
		} else if(!strcmp(modpblk.descr[i].name, "severity")) {
			loadModConf-&gt;iSeverity = (int) pvals[i].val.d.n;
		} else if(!strcmp(modpblk.descr[i].name, "bracketing")) {
			loadModConf-&gt;bBracketing = (sbool) pvals[i].val.d.n;
		} else if(!strcmp(modpblk.descr[i].name, "log.syslog")) {
<a name="3"></a>			loadModConf-&gt;bLogToSyslog = (sbool) pvals[i].val.d.n;
		} else if(!strcmp(modpblk.descr[i].name, "resetcounters")) {
			loadModConf-&gt;bResetCtrs = (sbool) pvals[i].val.d.n;
<font color="#53858b"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>		} else if(!strcmp(modpblk.descr[i].name, "log.file")) {
			loadModConf-&gt;logfile = es_str2cstr(pvals[i].val.d.estr, NULL);
		} else if(!strcmp(modpblk.descr[i].name, "format")) {
			mode = es_str2cstr(pvals[i].val.d.estr, NULL);</b></font>
			if(!strcasecmp(mode, "json")) {
				loadModConf-&gt;statsFmt = statsFmt_JSON;
			} else if(!strcasecmp(mode, "json-elasticsearch")) {
				loadModConf-&gt;statsFmt = statsFmt_JSON_ES;
			} else if(!strcasecmp(mode, "cee")) {
<a name="2"></a>				loadModConf-&gt;statsFmt = statsFmt_CEE;
			} else if(!strcasecmp(mode, "legacy")) {
				loadModConf-&gt;statsFmt = statsFmt_Legacy;
<font color="#980517"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>			} else {
				LogError(0, RS_RET_ERR, "impstats: invalid format %s",
						mode);
			}
			free(mode);
		} else if(!strcmp(modpblk.descr[i].name, "ruleset")) {
			loadModConf-&gt;pszBindRuleset = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
		} else {</b></font>
			dbgprintf("impstats: program error, non-handled "
			  "param '%s' in beginCnfLoad\n", modpblk.descr[i].name);
		}
	}

	if(loadModConf-&gt;pszBindRuleset != NULL &amp;&amp; loadModConf-&gt;bLogToSyslog == 0) {
		parser_warnmsg("impstats: log.syslog set to \"off\" but ruleset specified - with "
			"these settings, the ruleset will never be used, because regular syslog "
			"processing is turned off - ruleset parameter is ignored");
		free(loadModConf-&gt;pszBindRuleset);
		loadModConf-&gt;pszBindRuleset = NULL;
	}

	loadModConf-&gt;configSetViaV2Method = 1;
	bLegacyCnfModGlobalsPermitted = 0;

finalize_it:
	if(pvals != NULL)
		cnfparamvalsDestruct(pvals, &amp;modpblk);
ENDsetModCnf


BEGINendCnfLoad
CODESTARTendCnfLoad
	if(!loadModConf-&gt;configSetViaV2Method) {
		/* persist module-specific settings from legacy config system */
		loadModConf-&gt;iStatsInterval = cs.iStatsInterval;
		loadModConf-&gt;iFacility = cs.iFacility;
		loadModConf-&gt;iSeverity = cs.iSeverity;
		if (cs.bCEE == 1) {
			loadModConf-&gt;statsFmt = statsFmt_CEE;
		} else if (cs.bJSON == 1) {
			loadModConf-&gt;statsFmt = statsFmt_JSON;
		} else {
			loadModConf-&gt;statsFmt = statsFmt_Legacy;
		}
	}
ENDendCnfLoad


/* we need our special version of checkRuleset(), as we do not have any instances */
static rsRetVal
checkRuleset(modConfData_t *modConf)
{
	ruleset_t *pRuleset;
	rsRetVal localRet;
	DEFiRet;

	modConf-&gt;pBindRuleset = NULL;	/* assume default ruleset */

	if(modConf-&gt;pszBindRuleset == NULL)
		FINALIZE;

	localRet = ruleset.GetRuleset(modConf-&gt;pConf, &amp;pRuleset, modConf-&gt;pszBindRuleset);
	if(localRet == RS_RET_NOT_FOUND) {
		LogError(0, NO_ERRCODE, "impstats: ruleset '%s' not found - "
				"using default ruleset instead", modConf-&gt;pszBindRuleset);
	}
	CHKiRet(localRet);
	modConf-&gt;pBindRuleset = pRuleset;
finalize_it:
	RETiRet;
}


/* to use HUP, we need to have an instanceData type, as this was
 * originally designed for actions. However, we do not, and cannot,
 * use the content. The core will always provide a NULL pointer.
 */
typedef struct _instanceData {
	int dummy;
} instanceData;
BEGINdoHUP
CODESTARTdoHUP
	DBGPRINTF("impstats: received HUP\n")
	pthread_mutex_lock(&amp;hup_mutex);
	if(runModConf-&gt;logfd != -1) {
		DBGPRINTF("impstats: closing log file due to HUP\n");
		close(runModConf-&gt;logfd);
		runModConf-&gt;logfd = -1;
	}
	pthread_mutex_unlock(&amp;hup_mutex);
ENDdoHUP


BEGINcheckCnf
CODESTARTcheckCnf
	if(pModConf-&gt;iStatsInterval == 0) {
		LogError(0, NO_ERRCODE, "impstats: stats interval zero not permitted, using "
				"default of %d seconds", DEFAULT_STATS_PERIOD);
		pModConf-&gt;iStatsInterval = DEFAULT_STATS_PERIOD;
	}
	checkRuleset(pModConf);
ENDcheckCnf


BEGINactivateCnf
	rsRetVal localRet;
CODESTARTactivateCnf
	runModConf = pModConf;
	DBGPRINTF("impstats: stats interval %d seconds, reset %d, logToSyslog %d, logFile %s\n",
		  runModConf-&gt;iStatsInterval, runModConf-&gt;bResetCtrs, runModConf-&gt;bLogToSyslog,
		  runModConf-&gt;logfile == NULL ? "deactivated" : (char*)runModConf-&gt;logfile);
	localRet = statsobj.EnableStats();
	if(localRet != RS_RET_OK) {
		LogError(0, localRet, "impstats: error enabling statistics gathering");
		ABORT_FINALIZE(RS_RET_NO_RUN);
	}
	/* initialize our own counters */
	CHKiRet(statsobj.Construct(&amp;statsobj_resources));
	CHKiRet(statsobj.SetName(statsobj_resources, (uchar*)"resource-usage"));
	CHKiRet(statsobj.SetOrigin(statsobj_resources, (uchar*)"impstats"));
	CHKiRet(statsobj.AddCounter(statsobj_resources, UCHAR_CONSTANT("utime"),
		ctrType_IntCtr, CTR_FLAG_NONE, &amp;st_ru_utime));
	CHKiRet(statsobj.AddCounter(statsobj_resources, UCHAR_CONSTANT("stime"),
		ctrType_IntCtr, CTR_FLAG_NONE, &amp;st_ru_stime));
	CHKiRet(statsobj.AddCounter(statsobj_resources, UCHAR_CONSTANT("maxrss"),
		ctrType_IntCtr, CTR_FLAG_NONE, &amp;st_ru_maxrss));
	CHKiRet(statsobj.AddCounter(statsobj_resources, UCHAR_CONSTANT("minflt"),
		ctrType_IntCtr, CTR_FLAG_NONE, &amp;st_ru_minflt));
	CHKiRet(statsobj.AddCounter(statsobj_resources, UCHAR_CONSTANT("majflt"),
		ctrType_IntCtr, CTR_FLAG_NONE, &amp;st_ru_majflt));
	CHKiRet(statsobj.AddCounter(statsobj_resources, UCHAR_CONSTANT("inblock"),
		ctrType_IntCtr, CTR_FLAG_NONE, &amp;st_ru_inblock));
	CHKiRet(statsobj.AddCounter(statsobj_resources, UCHAR_CONSTANT("oublock"),
		ctrType_IntCtr, CTR_FLAG_NONE, &amp;st_ru_oublock));
	CHKiRet(statsobj.AddCounter(statsobj_resources, UCHAR_CONSTANT("nvcsw"),
		ctrType_IntCtr, CTR_FLAG_NONE, &amp;st_ru_nvcsw));
	CHKiRet(statsobj.AddCounter(statsobj_resources, UCHAR_CONSTANT("nivcsw"),
		ctrType_IntCtr, CTR_FLAG_NONE, &amp;st_ru_nivcsw));
#	ifdef OS_LINUX
	CHKiRet(statsobj.AddCounter(statsobj_resources, UCHAR_CONSTANT("openfiles"),
		ctrType_Int, CTR_FLAG_NONE, &amp;st_openfiles));
#	endif
	CHKiRet(statsobj.ConstructFinalize(statsobj_resources));
finalize_it:
	if(iRet != RS_RET_OK) {
		LogError(0, iRet, "impstats: error activating module");
		iRet = RS_RET_NO_RUN;
	}
ENDactivateCnf


BEGINfreeCnf
CODESTARTfreeCnf
	if(runModConf-&gt;logfd != -1)
		close(runModConf-&gt;logfd);
	free(runModConf-&gt;logfile);
	free(runModConf-&gt;pszBindRuleset);
ENDfreeCnf


BEGINrunInput
CODESTARTrunInput
	/* this is an endless loop - it is terminated when the thread is
	 * signalled to do so. This, however, is handled by the framework,
	 * right into the sleep below. Note that we DELIBERATLY output
	 * final set of stats counters on termination request. Depending
	 * on configuration, they may not make it to the final destination...
	 */
	while(glbl.GetGlobalInputTermState() == 0) {
		srSleep(runModConf-&gt;iStatsInterval, 0); /* seconds, micro seconds */
		DBGPRINTF("impstats: woke up, generating messages\n");
		if(runModConf-&gt;bBracketing)
			submitLine("BEGIN", sizeof("BEGIN")-1);
		generateStatsMsgs();
		if(runModConf-&gt;bBracketing)
			submitLine("END", sizeof("END")-1);
	}
ENDrunInput


BEGINwillRun
CODESTARTwillRun
ENDwillRun


BEGINafterRun
CODESTARTafterRun
ENDafterRun


BEGINqueryEtryPt
CODESTARTqueryEtryPt
CODEqueryEtryPt_STD_IMOD_QUERIES
CODEqueryEtryPt_STD_CONF2_QUERIES
CODEqueryEtryPt_STD_CONF2_setModCnf_QUERIES
CODEqueryEtryPt_IsCompatibleWithFeature_IF_OMOD_QUERIES
CODEqueryEtryPt_doHUP
ENDqueryEtryPt

static rsRetVal resetConfigVariables(uchar __attribute__((unused)) *pp, void __attribute__((unused)) *pVal)
{
	initConfigSettings();
	return RS_RET_OK;
}


BEGINmodInit()
CODESTARTmodInit
	*ipIFVersProvided = CURR_MOD_IF_VERSION; /* we only support the current interface specification */
CODEmodInit_QueryRegCFSLineHdlr
	DBGPRINTF("impstats version %s loading\n", VERSION);
	initConfigSettings();
	CHKiRet(objUse(glbl, CORE_COMPONENT));
	CHKiRet(objUse(prop, CORE_COMPONENT));
	CHKiRet(objUse(statsobj, CORE_COMPONENT));
	CHKiRet(objUse(ruleset, CORE_COMPONENT));
	/* the pstatsinverval is an alias to support a previous screwed-up syntax... */
	CHKiRet(regCfSysLineHdlr2((uchar *)"pstatsinterval", 0, eCmdHdlrInt, NULL, &amp;cs.iStatsInterval,
	STD_LOADABLE_MODULE_ID, &amp;bLegacyCnfModGlobalsPermitted));
	CHKiRet(regCfSysLineHdlr2((uchar *)"pstatinterval", 0, eCmdHdlrInt, NULL, &amp;cs.iStatsInterval,
	STD_LOADABLE_MODULE_ID, &amp;bLegacyCnfModGlobalsPermitted));
	CHKiRet(regCfSysLineHdlr2((uchar *)"pstatfacility", 0, eCmdHdlrInt, NULL, &amp;cs.iFacility,
	STD_LOADABLE_MODULE_ID, &amp;bLegacyCnfModGlobalsPermitted));
	CHKiRet(regCfSysLineHdlr2((uchar *)"pstatseverity", 0, eCmdHdlrInt, NULL, &amp;cs.iSeverity,
	STD_LOADABLE_MODULE_ID, &amp;bLegacyCnfModGlobalsPermitted));
	CHKiRet(regCfSysLineHdlr2((uchar *)"pstatjson", 0, eCmdHdlrBinary, NULL, &amp;cs.bJSON,
	STD_LOADABLE_MODULE_ID, &amp;bLegacyCnfModGlobalsPermitted));
	CHKiRet(regCfSysLineHdlr2((uchar *)"pstatcee", 0, eCmdHdlrBinary, NULL, &amp;cs.bCEE,
	STD_LOADABLE_MODULE_ID, &amp;bLegacyCnfModGlobalsPermitted));
	CHKiRet(omsdRegCFSLineHdlr((uchar *)"resetconfigvariables", 1, eCmdHdlrCustomHandler, resetConfigVariables,
	NULL, STD_LOADABLE_MODULE_ID));

	CHKiRet(prop.Construct(&amp;pInputName));
	CHKiRet(prop.SetString(pInputName, UCHAR_CONSTANT("impstats"), sizeof("impstats") - 1));
	CHKiRet(prop.ConstructFinalize(pInputName));
ENDmodInit
/* vi:set ai:
 */
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>omrelp.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
/* omrelp.c
 *
 * This is the implementation of the RELP output module.
 *
 * Note that when multiple action workers are activated, we currently
 * also create multiple actions. This may be the source of some mild
 * message loss (!) if the worker instance is shut down while the
 * connection to the remote system is in retry state.
 * TODO: think if we should implement a mode where we do NOT
 *       support multiple action worker instances. This would be
 *       slower, but not have this loss opportunity. But it should
 *       definitely be optional and by default off due to the
 *       performance implications (and given the fact that message
 *       loss is pretty unlikely in usual cases).
 *
 *
 * File begun on 2008-03-13 by RGerhards
 *
 * Copyright 2008-2019 Adiscon GmbH.
 *
 * This file is part of rsyslog.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *       -or-
 *       see COPYING.ASL20 in the source distribution
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#include "config.h"
#include "rsyslog.h"
#include &lt;stdio.h&gt;
#include &lt;stdarg.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;assert.h&gt;
#include &lt;errno.h&gt;
#include &lt;ctype.h&gt;
#include &lt;librelp.h&gt;
#include "conf.h"
#include "syslogd-types.h"
#include "srUtils.h"
#include "cfsysline.h"
#include "module-template.h"
#include "glbl.h"
#include "errmsg.h"
#include "debug.h"
#include "parserif.h"
#include "unicode-helper.h"

#ifndef RELP_DFLT_PT
#	define RELP_DFLT_PT "514"
#endif

MODULE_TYPE_OUTPUT
MODULE_TYPE_NOKEEP
MODULE_CNFNAME("omrelp")

/* internal structures
 */
DEF_OMOD_STATIC_DATA
DEFobjCurrIf(glbl)

#define DFLT_ENABLE_TLS 0
#define DFLT_ENABLE_TLSZIP 0

static relpEngine_t *pRelpEngine;	/* our relp engine */

typedef struct _instanceData {
	uchar *target;
	uchar *port;
	int sizeWindow;		/**&lt; the RELP window size - 0=use default */
	unsigned timeout;
	int connTimeout;
	unsigned rebindInterval;
	sbool bEnableTLS;
	sbool bEnableTLSZip;
	sbool bHadAuthFail;	/**&lt; set on auth failure, will cause retry to disable action */
	uchar *pristring;		/* GnuTLS priority string (NULL if not to be provided) */
	uchar *authmode;
	uchar *caCertFile;
	uchar *myCertFile;
	uchar *myPrivKeyFile;
#if defined(HAVE_RELPENGINESETTLSCFGCMD)
	uchar *tlscfgcmd;
#endif
	uchar *tplName;
	uchar *localClientIP;
	struct {
		int nmemb;
		uchar **name;
	} permittedPeers;
} instanceData;

typedef struct wrkrInstanceData {
	instanceData *pData;
	int bInitialConnect; /* is this the initial connection request of our module? (0-no, 1-yes) */
	int bIsConnected; /* currently connected to server? 0 - no, 1 - yes */
	int bIsSuspended; /* currently suspended (than no more error messages) */
	relpClt_t *pRelpClt; /* relp client for this instance */
	unsigned nSent; /* number msgs sent - for rebind support */
} wrkrInstanceData_t;

typedef struct configSettings_s {
	EMPTY_STRUCT
} configSettings_t;
static configSettings_t __attribute__((unused)) cs;

static rsRetVal doCreateRelpClient(instanceData *pData, relpClt_t **pRelpClt);

struct modConfData_s {
	rsconf_t *pConf;	/* our overall config object */
	const char  *tlslib;
};

static modConfData_t *loadModConf = NULL;/* modConf ptr to use for the current load process */
static modConfData_t *runModConf = NULL;/* modConf ptr to use for the current exec process */

/* tables for interfacing with the v6 config system */
/* module-global parameters */
static struct cnfparamdescr modpdescr[] = {
	{ "tls.tlslib", eCmdHdlrString, 0 }
};
static struct cnfparamblk modpblk =
	{ CNFPARAMBLK_VERSION,
	  sizeof(modpdescr)/sizeof(struct cnfparamdescr),
	  modpdescr
	};
/* action (instance) parameters */
static struct cnfparamdescr actpdescr[] = {
	{ "target", eCmdHdlrGetWord, 1 },
	{ "tls", eCmdHdlrBinary, 0 },
	{ "tls.compression", eCmdHdlrBinary, 0 },
	{ "tls.prioritystring", eCmdHdlrString, 0 },
	{ "tls.cacert", eCmdHdlrString, 0 },
<a name="0"></a>	{ "tls.mycert", eCmdHdlrString, 0 },
	{ "tls.myprivkey", eCmdHdlrString, 0 },
	{ "tls.authmode", eCmdHdlrString, 0 },
<font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>	{ "tls.tlscfgcmd", eCmdHdlrString, 0 },
	{ "tls.permittedpeer", eCmdHdlrArray, 0 },
	{ "port", eCmdHdlrGetWord, 0 },
	{ "rebindinterval", eCmdHdlrInt, 0 },
	{ "windowsize", eCmdHdlrInt, 0 },
	{ "timeout", eCmdHdlrInt, 0 },
	{ "conn.timeout", eCmdHdlrInt, 0 },
	{ "localclientip", eCmdHdlrGetWord, 0 },
	{ "template", eCmdHdlrGetWord, 0 }
};
static struct cnfparamblk actpblk =
	{ CNFPARAMBLK_VERSION,
	  sizeof(actpdescr)/sizeof(struct cnfparamdescr),
	  actpdescr
	};

BEGINinitConfVars		/* (re)set config variables to default values */
CODESTARTinitConfVars
ENDinitConfVars

/* We may change the implementation to try to lookup the port
 * if it is unspecified. So far, we use 514 as default (what probably
 * is not a really bright idea, but kept for backward compatibility).
 */

PRAGMA_DIAGNOSTIC_PUSH
PRAGMA_IGNORE_Wformat_nonliteral
static void __attribute__((format(printf, 1, 2)))</b></font>
omrelp_dbgprintf(const char *fmt, ...)
{
	va_list ap;
	char pszWriteBuf[32*1024+1]; //this function has to be able to
					/*generate a buffer longer than that of r_dbgprintf, so
					r_dbgprintf can properly truncate*/
	if(!(Debug &amp;&amp; debugging_on)) {
		return;
	}

	va_start(ap, fmt);
	vsnprintf(pszWriteBuf, sizeof(pszWriteBuf), fmt, ap);
	va_end(ap);
	r_dbgprintf("omrelp.c", "%s", pszWriteBuf);
}
PRAGMA_DIAGNOSTIC_POP


static uchar *getRelpPt(instanceData *pData)
{
	assert(pData != NULL);
	if(pData-&gt;port == NULL)
		return((uchar*)RELP_DFLT_PT);
	else
		return(pData-&gt;port);
}

static void
onErr(void *pUsr, char *objinfo, char* errmesg, __attribute__((unused)) relpRetVal errcode)
{
	wrkrInstanceData_t *pWrkrData = (wrkrInstanceData_t*) pUsr;
	LogError(0, RS_RET_RELP_AUTH_FAIL, "omrelp[%s:%s]: error '%s', object "
			" '%s' - action may not work as intended",
			pWrkrData-&gt;pData-&gt;target, pWrkrData-&gt;pData-&gt;port, errmesg, objinfo);
}

static void
onGenericErr(char *objinfo, char* errmesg, __attribute__((unused)) relpRetVal errcode)
{
	LogError(0, RS_RET_RELP_ERR, "omrelp: librelp error '%s', object "
			"'%s' - action may not work as intended",
			errmesg, objinfo);
}

static void
onAuthErr(void *pUsr, char *authinfo, char* errmesg, __attribute__((unused)) relpRetVal errcode)
{
	instanceData *pData = ((wrkrInstanceData_t*) pUsr)-&gt;pData;
	LogError(0, RS_RET_RELP_AUTH_FAIL, "omrelp[%s:%s]: authentication error '%s', peer "
			"is '%s' - DISABLING action", pData-&gt;target, pData-&gt;port, errmesg, authinfo);
	pData-&gt;bHadAuthFail = 1;
}

static rsRetVal
doCreateRelpClient(instanceData *pData, relpClt_t **pRelpClt)
{
	int i;
	DEFiRet;

	if(relpEngineCltConstruct(pRelpEngine, pRelpClt) != RELP_RET_OK)
		ABORT_FINALIZE(RS_RET_RELP_ERR);
	if(relpCltSetTimeout(*pRelpClt, pData-&gt;timeout) != RELP_RET_OK)
		ABORT_FINALIZE(RS_RET_RELP_ERR);
	if(relpCltSetConnTimeout(*pRelpClt, pData-&gt;connTimeout) != RELP_RET_OK) {
		ABORT_FINALIZE(RS_RET_RELP_ERR);
	}
	if(relpCltSetWindowSize(*pRelpClt, pData-&gt;sizeWindow) != RELP_RET_OK)
		ABORT_FINALIZE(RS_RET_RELP_ERR);
	if(pData-&gt;bEnableTLS) {
		if(relpCltEnableTLS(*pRelpClt) != RELP_RET_OK)
			ABORT_FINALIZE(RS_RET_RELP_ERR);
		if(pData-&gt;bEnableTLSZip) {
			if(relpCltEnableTLSZip(*pRelpClt) != RELP_RET_OK)
				ABORT_FINALIZE(RS_RET_RELP_ERR);
		}
		if(relpCltSetGnuTLSPriString(*pRelpClt, (char*) pData-&gt;pristring) != RELP_RET_OK)
			ABORT_FINALIZE(RS_RET_RELP_ERR);


		if(relpCltSetAuthMode(*pRelpClt, (char*) pData-&gt;authmode) != RELP_RET_OK) {
			LogError(0, RS_RET_RELP_ERR,
					"omrelp: invalid auth mode '%s'\n", pData-&gt;authmode);
			ABORT_FINALIZE(RS_RET_RELP_ERR);
		}

		if(relpCltSetCACert(*pRelpClt, (char*) pData-&gt;caCertFile) != RELP_RET_OK)
			ABORT_FINALIZE(RS_RET_RELP_ERR);
		if(relpCltSetOwnCert(*pRelpClt, (char*) pData-&gt;myCertFile) != RELP_RET_OK)
			ABORT_FINALIZE(RS_RET_RELP_ERR);
		if(relpCltSetPrivKey(*pRelpClt, (char*) pData-&gt;myPrivKeyFile) != RELP_RET_OK)
			ABORT_FINALIZE(RS_RET_RELP_ERR);
#if defined(HAVE_RELPENGINESETTLSCFGCMD)
		if (pData-&gt;tlscfgcmd != NULL) {
			if(relpCltSetTlsConfigCmd(*pRelpClt, (char*) pData-&gt;tlscfgcmd) != RELP_RET_OK)
				ABORT_FINALIZE(RS_RET_RELP_ERR);
		}
#endif
		for(i = 0 ; i &lt;  pData-&gt;permittedPeers.nmemb ; ++i) {
			relpCltAddPermittedPeer(*pRelpClt, (char*)pData-&gt;permittedPeers.name[i]);
		}
	}
	if(pData-&gt;localClientIP != NULL) {
		if(relpCltSetClientIP(*pRelpClt, pData-&gt;localClientIP) != RELP_RET_OK)
			ABORT_FINALIZE(RS_RET_RELP_ERR);
	}
finalize_it:

	RETiRet;
}

BEGINendCnfLoad
CODESTARTendCnfLoad
	loadModConf = NULL;
	runModConf = pModConf;
ENDendCnfLoad

BEGINcheckCnf
CODESTARTcheckCnf
ENDcheckCnf

BEGINactivateCnf
CODESTARTactivateCnf
ENDactivateCnf

BEGINfreeCnf
CODESTARTfreeCnf
	free((void*)pModConf-&gt;tlslib);
ENDfreeCnf
<a name="4"></a>
BEGINcreateInstance
CODESTARTcreateInstance
<font color="#6cc417"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>	pData-&gt;sizeWindow = 0;
	pData-&gt;timeout = 90;
	pData-&gt;connTimeout = 10;
	pData-&gt;rebindInterval = 0;
	pData-&gt;bEnableTLS = DFLT_ENABLE_TLS;
	pData-&gt;bEnableTLSZip = DFLT_ENABLE_TLSZIP;
	pData-&gt;bHadAuthFail = 0;
	pData-&gt;pristring = NULL;
	pData-&gt;authmode = NULL;
	pData-&gt;localClientIP = NULL;</b></font>
	pData-&gt;caCertFile = NULL;
	pData-&gt;myCertFile = NULL;
	pData-&gt;myPrivKeyFile = NULL;
#if defined(HAVE_RELPENGINESETTLSCFGCMD)
	pData-&gt;tlscfgcmd = NULL;
#endif
	pData-&gt;permittedPeers.nmemb = 0;
ENDcreateInstance

BEGINcreateWrkrInstance
CODESTARTcreateWrkrInstance
	pWrkrData-&gt;pRelpClt = NULL;
	iRet = doCreateRelpClient(pWrkrData-&gt;pData, &amp;pWrkrData-&gt;pRelpClt);
	if(relpCltSetUsrPtr(pWrkrData-&gt;pRelpClt, pWrkrData) != RELP_RET_OK)
		LogError(0, RS_RET_NO_ERRCODE, "omrelp: error when creating relp client");
	pWrkrData-&gt;bInitialConnect = 1;
	pWrkrData-&gt;nSent = 0;
ENDcreateWrkrInstance

BEGINfreeInstance
	int i;
CODESTARTfreeInstance
	free(pData-&gt;target);
	free(pData-&gt;port);
	free(pData-&gt;tplName);
	free(pData-&gt;pristring);
	free(pData-&gt;authmode);
	free(pData-&gt;localClientIP);
	free(pData-&gt;caCertFile);
	free(pData-&gt;myCertFile);
	free(pData-&gt;myPrivKeyFile);
#if defined(HAVE_RELPENGINESETTLSCFGCMD)
	free(pData-&gt;tlscfgcmd);
#endif
	if(pData-&gt;permittedPeers.name != NULL) {
		for(i = 0 ; i &lt;  pData-&gt;permittedPeers.nmemb ; ++i) {
			free(pData-&gt;permittedPeers.name[i]);
		}
	}
ENDfreeInstance

BEGINfreeWrkrInstance
CODESTARTfreeWrkrInstance
	if(pWrkrData-&gt;pRelpClt != NULL)
		relpEngineCltDestruct(pRelpEngine, &amp;pWrkrData-&gt;pRelpClt);
ENDfreeWrkrInstance

static void
setInstParamDefaults(instanceData *pData)
{
	pData-&gt;target = NULL;
	pData-&gt;port = NULL;
	pData-&gt;tplName = NULL;
	pData-&gt;timeout = 90;
	pData-&gt;connTimeout = 10;
	pData-&gt;sizeWindow = 0;
	pData-&gt;rebindInterval = 0;
	pData-&gt;bEnableTLS = DFLT_ENABLE_TLS;
	pData-&gt;bEnableTLSZip = DFLT_ENABLE_TLSZIP;
	pData-&gt;pristring = NULL;
	pData-&gt;authmode = NULL;
	if(glbl.GetSourceIPofLocalClient() == NULL)
		pData-&gt;localClientIP = NULL;
	else
		pData-&gt;localClientIP = (uchar*)strdup((char*)glbl.GetSourceIPofLocalClient());
	pData-&gt;caCertFile = NULL;
	pData-&gt;myCertFile = NULL;
	pData-&gt;myPrivKeyFile = NULL;
#if defined(HAVE_RELPENGINESETTLSCFGCMD)
	pData-&gt;tlscfgcmd = NULL;
#endif
	pData-&gt;permittedPeers.name = NULL;
	pData-&gt;permittedPeers.nmemb = 0;
}

BEGINbeginCnfLoad
CODESTARTbeginCnfLoad
	loadModConf = pModConf;
	pModConf-&gt;pConf = pConf;
	pModConf-&gt;tlslib = NULL;
	/* create our relp engine */
	CHKiRet(relpEngineConstruct(&amp;pRelpEngine));
	CHKiRet(relpEngineSetDbgprint(pRelpEngine, (void (*)(char *, ...))omrelp_dbgprintf));
	CHKiRet(relpEngineSetOnAuthErr(pRelpEngine, onAuthErr));
	CHKiRet(relpEngineSetOnGenericErr(pRelpEngine, onGenericErr));
	CHKiRet(relpEngineSetOnErr(pRelpEngine, onErr));
	CHKiRet(relpEngineSetEnableCmd(pRelpEngine, (uchar*) "syslog", eRelpCmdState_Required));
finalize_it:
ENDbeginCnfLoad
<a name="1"></a>
BEGINsetModCnf
	struct cnfparamvals *pvals = NULL;
<font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>	int i;
CODESTARTsetModCnf
	pvals = nvlstGetParams(lst, &amp;modpblk, NULL);
	if(pvals == NULL) {
		parser_errmsg("imrelp: error processing module config parameters [module(...)]");
		ABORT_FINALIZE(RS_RET_MISSING_CNFPARAMS);
	}

	if(Debug) {
		dbgprintf("module (global) param blk for omrelp:\n");
		cnfparamsPrint(&amp;modpblk, pvals);
	}

	for(i = 0 ; i &lt; modpblk.nParams ; ++i) {
		if(!pvals[i].bUsed) {</b></font>
			continue;
		}
		if(!strcmp(modpblk.descr[i].name, "tls.tlslib")) {
			#if defined(HAVE_RELPENGINESETTLSLIBBYNAME)
				loadModConf-&gt;tlslib = es_str2cstr(pvals[i].val.d.estr, NULL);
				if(relpEngineSetTLSLibByName(pRelpEngine, loadModConf-&gt;tlslib) != RELP_RET_OK) {
					LogMsg(0, RS_RET_CONF_PARAM_INVLD, LOG_WARNING,
						"omrelp: tlslib '%s' not accepted as valid by librelp - using default",
						loadModConf-&gt;tlslib);
				}
			#else
				LogError(0, RS_RET_NOT_IMPLEMENTED,
					"omrelp warning: parameter tls.tlslib ignored - librelp does not support "
					"this API call. Using whatever librelp was compiled with.");
			#endif
		} else {
			dbgprintf("imfile: program error, non-handled "
			  "param '%s' in beginCnfLoad\n", modpblk.descr[i].name);
		}
	}
finalize_it:
	if(pvals != NULL)
		cnfparamvalsDestruct(pvals, &amp;modpblk);
ENDsetModCnf

BEGINnewActInst
	struct cnfparamvals *pvals;
	int i,j;
	FILE *fp;
	relpClt_t *pRelpClt = NULL;
CODESTARTnewActInst
	if((pvals = nvlstGetParams(lst, &amp;actpblk, NULL)) == NULL) {
		ABORT_FINALIZE(RS_RET_MISSING_CNFPARAMS);
	}

	CHKiRet(createInstance(&amp;pData));
	setInstParamDefaults(pData);

	for(i = 0 ; i &lt; actpblk.nParams ; ++i) {
		if(!pvals[i].bUsed)
<a name="3"></a>			continue;
		if(!strcmp(actpblk.descr[i].name, "target")) {
			pData-&gt;target = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
<font color="#53858b"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>		} else if(!strcmp(actpblk.descr[i].name, "port")) {
			pData-&gt;port = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
		} else if(!strcmp(actpblk.descr[i].name, "template")) {
			pData-&gt;tplName = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);</b></font>
		} else if(!strcmp(actpblk.descr[i].name, "localclientip")) {
			pData-&gt;localClientIP = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
		} else if(!strcmp(actpblk.descr[i].name, "timeout")) {
			pData-&gt;timeout = (unsigned) pvals[i].val.d.n;
		} else if(!strcmp(actpblk.descr[i].name, "conn.timeout")) {
			pData-&gt;connTimeout = (int) pvals[i].val.d.n;
		} else if(!strcmp(actpblk.descr[i].name, "rebindinterval")) {
			pData-&gt;rebindInterval = (unsigned) pvals[i].val.d.n;
		} else if(!strcmp(actpblk.descr[i].name, "windowsize")) {
			pData-&gt;sizeWindow = (int) pvals[i].val.d.n;
		} else if(!strcmp(actpblk.descr[i].name, "tls")) {
			pData-&gt;bEnableTLS = (unsigned) pvals[i].val.d.n;
		} else if(!strcmp(actpblk.descr[i].name, "tls.compression")) {
			pData-&gt;bEnableTLSZip = (unsigned) pvals[i].val.d.n;
		} else if(!strcmp(actpblk.descr[i].name, "tls.prioritystring")) {
			pData-&gt;pristring = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
		} else if(!strcmp(actpblk.descr[i].name, "tls.cacert")) {
			pData-&gt;caCertFile = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
			fp = fopen((const char*)pData-&gt;caCertFile, "r");
			if(fp == NULL) {
				char errStr[1024];
				rs_strerror_r(errno, errStr, sizeof(errStr));
				LogError(0, RS_RET_NO_FILE_ACCESS,
				"error: certificate file %s couldn't be accessed: %s\n",
				pData-&gt;caCertFile, errStr);
			} else {
				fclose(fp);
			}
		} else if(!strcmp(actpblk.descr[i].name, "tls.mycert")) {
			pData-&gt;myCertFile = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
			fp = fopen((const char*)pData-&gt;myCertFile, "r");
			if(fp == NULL) {
				char errStr[1024];
				rs_strerror_r(errno, errStr, sizeof(errStr));
				LogError(0, RS_RET_NO_FILE_ACCESS,
				"error: certificate file %s couldn't be accessed: %s\n",
				pData-&gt;myCertFile, errStr);
			} else {
				fclose(fp);
			}
		} else if(!strcmp(actpblk.descr[i].name, "tls.myprivkey")) {
			pData-&gt;myPrivKeyFile = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
			fp = fopen((const char*)pData-&gt;myPrivKeyFile, "r");
			if(fp == NULL) {
				char errStr[1024];
				rs_strerror_r(errno, errStr, sizeof(errStr));
<a name="2"></a>				LogError(0, RS_RET_NO_FILE_ACCESS,
				"error: certificate file %s couldn't be accessed: %s\n",
				pData-&gt;myPrivKeyFile, errStr);
<font color="#980517"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>			} else {
				fclose(fp);
			}
		} else if(!strcmp(actpblk.descr[i].name, "tls.tlscfgcmd")) {
#if defined(HAVE_RELPENGINESETTLSCFGCMD)
			pData-&gt;tlscfgcmd = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
#else
			LogError(0, RS_RET_NOT_IMPLEMENTED, "omrelp: librelp does not support input parameter "
				"'tls.tlscfgcmd'; it probably is too old (1.5.0 or higher should be fine); "
				"ignoring setting now.");
#endif
		} else if(!strcmp(actpblk.descr[i].name, "tls.authmode")) {</b></font>
			pData-&gt;authmode = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
		} else if(!strcmp(actpblk.descr[i].name, "tls.permittedpeer")) {
			pData-&gt;permittedPeers.nmemb = pvals[i].val.d.ar-&gt;nmemb;
			CHKmalloc(pData-&gt;permittedPeers.name =
				malloc(sizeof(uchar*) * pData-&gt;permittedPeers.nmemb));
			for(j = 0 ; j &lt;  pData-&gt;permittedPeers.nmemb ; ++j) {
				pData-&gt;permittedPeers.name[j] = (uchar*)es_str2cstr(pvals[i].val.d.ar-&gt;arr[j], NULL);
			}
		} else {
			dbgprintf("omrelp: program error, non-handled "
			  "param '%s'\n", actpblk.descr[i].name);
		}
	}

	CODE_STD_STRING_REQUESTnewActInst(1)

	CHKiRet(OMSRsetEntry(*ppOMSR, 0, (uchar*)strdup((pData-&gt;tplName == NULL) ?
			    "RSYSLOG_ForwardFormat" : (char*)pData-&gt;tplName),
	   		    OMSR_NO_RQD_TPL_OPTS));

	iRet = doCreateRelpClient(pData, &amp;pRelpClt);
	if(pRelpClt != NULL)
		relpEngineCltDestruct(pRelpEngine, &amp;pRelpClt);

CODE_STD_FINALIZERnewActInst
	if(pvals != NULL)
		cnfparamvalsDestruct(pvals, &amp;actpblk);
ENDnewActInst

BEGINisCompatibleWithFeature
CODESTARTisCompatibleWithFeature
	if(eFeat == sFEATURERepeatedMsgReduction)
		iRet = RS_RET_OK;
ENDisCompatibleWithFeature

BEGINSetShutdownImmdtPtr
CODESTARTSetShutdownImmdtPtr
	relpEngineSetShutdownImmdtPtr(pRelpEngine, pPtr);
	DBGPRINTF("omrelp: shutdownImmediate ptr now is %p\n", pPtr);
ENDSetShutdownImmdtPtr


BEGINdbgPrintInstInfo
CODESTARTdbgPrintInstInfo
	dbgprintf("RELP/%s", pData-&gt;target);
ENDdbgPrintInstInfo


/* try to connect to server
 * rgerhards, 2008-03-21
 */
static rsRetVal ATTR_NONNULL()
doConnect(wrkrInstanceData_t *const pWrkrData)
{
	DEFiRet;

	if(pWrkrData-&gt;bInitialConnect) {
		iRet = relpCltConnect(pWrkrData-&gt;pRelpClt, glbl.GetDefPFFamily(runModConf-&gt;pConf),
				      getRelpPt(pWrkrData-&gt;pData), pWrkrData-&gt;pData-&gt;target);
		if(iRet == RELP_RET_OK)
			pWrkrData-&gt;bInitialConnect = 0;
	} else {
		iRet = relpCltReconnect(pWrkrData-&gt;pRelpClt);
	}

	if(iRet == RELP_RET_OK) {
		pWrkrData-&gt;bIsConnected = 1;
	} else if(iRet == RELP_RET_ERR_NO_TLS) {
		LogError(0, iRet, "omrelp: Could not connect, librelp does NOT "
				"support TLS (most probably GnuTLS lib "
				"is too old)!");
		FINALIZE;
	} else if(iRet == RELP_RET_ERR_NO_TLS_AUTH) {
		LogError(0, iRet, "omrelp: could not activate relp TLS with "
				"authentication, librelp does not support it "
				"(most probably GnuTLS lib is too old)! "
				"Note: anonymous TLS is probably supported.");
		FINALIZE;
	} else {
		if(pWrkrData-&gt;bIsSuspended == 0) {
			LogError(0, RS_RET_RELP_ERR, "omrelp: could not connect to "
				"remote server, librelp error %d", iRet);
		}
		pWrkrData-&gt;bIsConnected = 0;
		pWrkrData-&gt;bIsSuspended = 1;
		iRet = RS_RET_SUSPENDED;
	}

finalize_it:
	RETiRet;
}


BEGINtryResume
CODESTARTtryResume
	if(pWrkrData-&gt;pData-&gt;bHadAuthFail) {
		ABORT_FINALIZE(RS_RET_DISABLE_ACTION);
	}
	iRet = doConnect(pWrkrData);
finalize_it:
ENDtryResume

static rsRetVal
doRebind(wrkrInstanceData_t *pWrkrData)
{
	DEFiRet;
	DBGPRINTF("omrelp: destructing relp client due to rebindInterval\n");
	CHKiRet(relpEngineCltDestruct(pRelpEngine, &amp;pWrkrData-&gt;pRelpClt));
	pWrkrData-&gt;bIsConnected = 0;
	CHKiRet(doCreateRelpClient(pWrkrData-&gt;pData, &amp;pWrkrData-&gt;pRelpClt));
	if(relpCltSetUsrPtr(pWrkrData-&gt;pRelpClt, pWrkrData) != RELP_RET_OK)
		LogError(0, RS_RET_NO_ERRCODE, "omrelp: error when creating relp client");
	pWrkrData-&gt;bInitialConnect = 1;
	pWrkrData-&gt;nSent = 0;
finalize_it:
	RETiRet;
}

BEGINbeginTransaction
CODESTARTbeginTransaction
	DBGPRINTF("omrelp: beginTransaction\n");
	if(!pWrkrData-&gt;bIsConnected) {
		CHKiRet(doConnect(pWrkrData));
	}
	relpCltHintBurstBegin(pWrkrData-&gt;pRelpClt);
finalize_it:
ENDbeginTransaction

BEGINdoAction
	uchar *pMsg; /* temporary buffering */
	size_t lenMsg;
	relpRetVal ret;
	instanceData *pData;
CODESTARTdoAction
	pData = pWrkrData-&gt;pData;
	dbgprintf(" %s:%s/RELP\n", pData-&gt;target, getRelpPt(pData));

	if(!pWrkrData-&gt;bIsConnected) {
		CHKiRet(doConnect(pWrkrData));
	}

	pMsg = ppString[0];
	lenMsg = strlen((char*) pMsg); /* TODO: don't we get this? */

	/* we need to truncate oversize msgs - no way around that... */
	if((int) lenMsg &gt; glbl.GetMaxLine(runModConf-&gt;pConf))
		lenMsg = glbl.GetMaxLine(runModConf-&gt;pConf);

	/* forward */
	ret = relpCltSendSyslog(pWrkrData-&gt;pRelpClt, (uchar*) pMsg, lenMsg);
	if(ret != RELP_RET_OK) {
		LogError(0, RS_RET_RELP_ERR, "librelp error %d%s forwarding "
				"to server %s:%s - suspending\n", ret,
				(ret == RELP_RET_SESSION_BROKEN) ?
					"[connection broken]" : "",
				pData-&gt;target, getRelpPt(pData));
		ABORT_FINALIZE(RS_RET_SUSPENDED);
	}

	if(pData-&gt;rebindInterval != 0 &amp;&amp;
	   (++pWrkrData-&gt;nSent &gt;= pData-&gt;rebindInterval)) {
	   	doRebind(pWrkrData);
	}
finalize_it:
	if(pData-&gt;bHadAuthFail)
		iRet = RS_RET_DISABLE_ACTION;
	if(iRet == RS_RET_OK) {
		/* we mimic non-commit, as otherwise our endTransaction handler
		 * will not get called. While this is not 100% correct, the worst
		 * that can happen is some message duplication, something that
		 * rsyslog generally accepts and prefers over message loss.
		 */
		iRet = RS_RET_PREVIOUS_COMMITTED;
	} else if(iRet == RS_RET_SUSPENDED) {
		pWrkrData-&gt;bIsSuspended = 1;
	}
ENDdoAction


BEGINendTransaction
CODESTARTendTransaction
	DBGPRINTF("omrelp: endTransaction, connected %d\n", pWrkrData-&gt;bIsConnected);
	if(pWrkrData-&gt;bIsConnected) {
		relpCltHintBurstEnd(pWrkrData-&gt;pRelpClt);
	}
ENDendTransaction

BEGINparseSelectorAct
	uchar *q;
	int i;
	int bErr;
CODESTARTparseSelectorAct
CODE_STD_STRING_REQUESTparseSelectorAct(1)
	if(!strncmp((char*) p, ":omrelp:", sizeof(":omrelp:") - 1)) {
		p += sizeof(":omrelp:") - 1; /* eat indicator sequence (-1 because of '\0'!) */
	} else {
		ABORT_FINALIZE(RS_RET_CONFLINE_UNPROCESSED);
	}

	/* ok, if we reach this point, we have something for us */
	if((iRet = createInstance(&amp;pData)) != RS_RET_OK)
		FINALIZE;

	/* extract the host first (we do a trick - we replace the ';' or ':' with a '\0')
	 * now skip to port and then template name. rgerhards 2005-07-06
	 */
	if(*p == '[') { /* everything is hostname upto ']' */
		++p; /* skip '[' */
		for(q = p ; *p &amp;&amp; *p != ']' ; ++p)
			/* JUST SKIP */;
		if(*p == ']') {
			*p = '\0'; /* trick to obtain hostname (later)! */
			++p; /* eat it */
		}
	} else { /* traditional view of hostname */
		for(q = p ; *p &amp;&amp; *p != ';' &amp;&amp; *p != ':' &amp;&amp; *p != '#' ; ++p)
			/* JUST SKIP */;
	}

	pData-&gt;port = NULL;
	if(*p == ':') { /* process port */
		uchar * tmp;

		*p = '\0'; /* trick to obtain hostname (later)! */
		tmp = ++p;
		for(i=0 ; *p &amp;&amp; isdigit((int) *p) ; ++p, ++i)
			/* SKIP AND COUNT */;
		pData-&gt;port = malloc(i + 1);
		if(pData-&gt;port == NULL) {
			LogError(0, NO_ERRCODE, "Could not get memory to store relp port, "
				 "using default port, results may not be what you intend\n");
			/* we leave f_forw.port set to NULL, this is then handled by getRelpPt() */
		} else {
			memcpy(pData-&gt;port, tmp, i);
			*(pData-&gt;port + i) = '\0';
		}
	}

	/* now skip to template */
	bErr = 0;
	while(*p &amp;&amp; *p != ';') {
		if(*p &amp;&amp; *p != ';' &amp;&amp; !isspace((int) *p)) {
			if(bErr == 0) { /* only 1 error msg! */
				bErr = 1;
				errno = 0;
				LogError(0, NO_ERRCODE, "invalid selector line (port), probably not doing "
					 "what was intended");
			}
		}
		++p;
	}

	if(*p == ';') {
		*p = '\0'; /* trick to obtain hostname (later)! */
		CHKmalloc(pData-&gt;target = ustrdup(q));
		*p = ';';
	} else {
		CHKmalloc(pData-&gt;target = ustrdup(q));
	}

	/* process template */
	CHKiRet(cflineParseTemplateName(&amp;p, *ppOMSR, 0, OMSR_NO_RQD_TPL_OPTS, (uchar*) "RSYSLOG_ForwardFormat"));

CODE_STD_FINALIZERparseSelectorAct
ENDparseSelectorAct


BEGINmodExit
CODESTARTmodExit
	relpEngineDestruct(&amp;pRelpEngine);

	/* release what we no longer need */
	objRelease(glbl, CORE_COMPONENT);
ENDmodExit


BEGINqueryEtryPt
CODESTARTqueryEtryPt
CODEqueryEtryPt_STD_OMOD_QUERIES
CODEqueryEtryPt_STD_OMOD8_QUERIES
CODEqueryEtryPt_STD_CONF2_QUERIES
CODEqueryEtryPt_STD_CONF2_CNFNAME_QUERIES
CODEqueryEtryPt_STD_CONF2_OMOD_QUERIES
CODEqueryEtryPt_STD_CONF2_setModCnf_QUERIES
CODEqueryEtryPt_TXIF_OMOD_QUERIES
CODEqueryEtryPt_SetShutdownImmdtPtr
ENDqueryEtryPt


BEGINmodInit()
CODESTARTmodInit
INITLegCnfVars
	*ipIFVersProvided = CURR_MOD_IF_VERSION; /* we only support the current interface specification */
CODEmodInit_QueryRegCFSLineHdlr
	/* tell which objects we need */
	CHKiRet(objUse(glbl, CORE_COMPONENT));
ENDmodInit
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
