
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 4.801477377654663%, Tokens: 8, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>redis-MDEwOlJlcG9zaXRvcnkxMDgxMTA3MDY=-flat-rb.c</h3>
            <pre><code>1  #include "test/jemalloc_test.h"
2  #include "jemalloc/internal/rb.h"
3  #define rbtn_black_height(a_type, a_field, a_rbt, r_height) do {	\
4  	a_type *rbp_bh_t;						\
5  	for (rbp_bh_t = (a_rbt)->rbt_root, (r_height) = 0; rbp_bh_t !=	\
6  	    NULL; rbp_bh_t = rbtn_left_get(a_type, a_field,		\
7  	    rbp_bh_t)) {						\
8  		if (!rbtn_red_get(a_type, a_field, rbp_bh_t)) {		\
9  		(r_height)++;						\
10  		}							\
11  	}								\
12  } while (0)
13  typedef struct node_s node_t;
14  struct node_s {
15  #define NODE_MAGIC 0x9823af7e
16  	uint32_t magic;
17  	rb_node(node_t) link;
18  	uint64_t key;
19  };
20  static int
21  node_cmp(const node_t *a, const node_t *b) {
22  	int ret;
23  	assert_u32_eq(a->magic, NODE_MAGIC, "Bad magic");
24  	assert_u32_eq(b->magic, NODE_MAGIC, "Bad magic");
25  	ret = (a->key > b->key) - (a->key < b->key);
26  	if (ret == 0) {
27  		ret = (((uintptr_t)a) > ((uintptr_t)b))
28  		    - (((uintptr_t)a) < ((uintptr_t)b));
29  	}
30  	return ret;
31  }
32  typedef rb_tree(node_t) tree_t;
33  rb_gen(static, tree_, tree_t, node_t, link, node_cmp);
34  TEST_BEGIN(test_rb_empty) {
35  	tree_t tree;
36  	node_t key;
37  	tree_new(&tree);
38  	assert_true(tree_empty(&tree), "Tree should be empty");
39  	assert_ptr_null(tree_first(&tree), "Unexpected node");
40  	assert_ptr_null(tree_last(&tree), "Unexpected node");
41  	key.key = 0;
42  	key.magic = NODE_MAGIC;
43  	assert_ptr_null(tree_search(&tree, &key), "Unexpected node");
44  	key.key = 0;
45  	key.magic = NODE_MAGIC;
46  	assert_ptr_null(tree_nsearch(&tree, &key), "Unexpected node");
47  	key.key = 0;
48  	key.magic = NODE_MAGIC;
49  	assert_ptr_null(tree_psearch(&tree, &key), "Unexpected node");
50  }
51  TEST_END
52  static unsigned
53  tree_recurse(node_t *node, unsigned black_height, unsigned black_depth) {
54  	unsigned ret = 0;
55  	node_t *left_node;
56  	node_t *right_node;
57  	if (node == NULL) {
58  		return ret;
59  	}
60  	left_node = rbtn_left_get(node_t, link, node);
61  	right_node = rbtn_right_get(node_t, link, node);
62  	if (!rbtn_red_get(node_t, link, node)) {
63  		black_depth++;
64  	}
65  	if (rbtn_red_get(node_t, link, node)) {
66  		if (left_node != NULL) {
67  			assert_false(rbtn_red_get(node_t, link, left_node),
68  				"Node should be black");
69  		}
70  		if (right_node != NULL) {
71  			assert_false(rbtn_red_get(node_t, link, right_node),
72  			    "Node should be black");
73  		}
74  	}
75  	assert_u32_eq(node->magic, NODE_MAGIC, "Bad magic");
76  	if (left_node != NULL) {
77  		ret += tree_recurse(left_node, black_height, black_depth);
78  	} else {
79  		ret += (black_depth != black_height);
80  	}
81  	if (right_node != NULL) {
82  		ret += tree_recurse(right_node, black_height, black_depth);
83  	} else {
84  		ret += (black_depth != black_height);
85  	}
86  	return ret;
87  }
88  static node_t *
89  tree_iterate_cb(tree_t *tree, node_t *node, void *data) {
90  	unsigned *i = (unsigned *)data;
91  	node_t *search_node;
92  	assert_u32_eq(node->magic, NODE_MAGIC, "Bad magic");
93  	search_node = tree_search(tree, node);
94  	assert_ptr_eq(search_node, node,
95  	    "tree_search() returned unexpected node");
96  	search_node = tree_nsearch(tree, node);
97  	assert_ptr_eq(search_node, node,
98  	    "tree_nsearch() returned unexpected node");
99  	search_node = tree_psearch(tree, node);
100  	assert_ptr_eq(search_node, node,
101  	    "tree_psearch() returned unexpected node");
102  	(*i)++;
103  	return NULL;
104  }
105  static unsigned
106  tree_iterate(tree_t *tree) {
107  	unsigned i;
108  	i = 0;
109  	tree_iter(tree, NULL, tree_iterate_cb, (void *)&i);
110  	return i;
111  }
112  static unsigned
113  tree_iterate_reverse(tree_t *tree) {
114  	unsigned i;
115  	i = 0;
116  	tree_reverse_iter(tree, NULL, tree_iterate_cb, (void *)&i);
117  	return i;
118  }
119  static void
120  node_remove(tree_t *tree, node_t *node, unsigned nnodes) {
121  	node_t *search_node;
122  	unsigned black_height, imbalances;
123  	tree_remove(tree, node);
124  	search_node = tree_nsearch(tree, node);
125  	if (search_node != NULL) {
126  		assert_u64_ge(search_node->key, node->key,
127  		    "Key ordering error");
128  	}
129  	search_node = tree_psearch(tree, node);
130  	if (search_node != NULL) {
131  		assert_u64_le(search_node->key, node->key,
132  		    "Key ordering error");
133  	}
134  	node->magic = 0;
135  	rbtn_black_height(node_t, link, tree, black_height);
136  	imbalances = tree_recurse(tree->rbt_root, black_height, 0);
137  	assert_u_eq(imbalances, 0, "Tree is unbalanced");
138  	assert_u_eq(tree_iterate(tree), nnodes-1,
139  	    "Unexpected node iteration count");
140  	assert_u_eq(tree_iterate_reverse(tree), nnodes-1,
141  	    "Unexpected node iteration count");
142  }
143  static node_t *
144  remove_iterate_cb(tree_t *tree, node_t *node, void *data) {
145  	unsigned *nnodes = (unsigned *)data;
146  	node_t *ret = tree_next(tree, node);
147  	node_remove(tree, node, *nnodes);
148  	return ret;
149  }
150  static node_t *
151  remove_reverse_iterate_cb(tree_t *tree, node_t *node, void *data) {
152  	unsigned *nnodes = (unsigned *)data;
153  	node_t *ret = tree_prev(tree, node);
154  	node_remove(tree, node, *nnodes);
155  	return ret;
156  }
157  static void
158  destroy_cb(node_t *node, void *data) {
159  	unsigned *nnodes = (unsigned *)data;
160  	assert_u_gt(*nnodes, 0, "Destruction removed too many nodes");
161  	(*nnodes)--;
162  }
163  TEST_BEGIN(test_rb_random) {
164  #define NNODES 25
165  #define NBAGS 250
166  #define SEED 42
167  	sfmt_t *sfmt;
168  	uint64_t bag[NNODES];
169  	tree_t tree;
170  	node_t nodes[NNODES];
171  	unsigned i, j, k, black_height, imbalances;
<span onclick='openModal()' class='match'>172  	sfmt = init_gen_rand(SEED);
173  	for (i = 0; i < NBAGS; i++) {
174  		switch (i) {
175  		case 0:
</span>176  			for (j = 0; j < NNODES; j++) {
177  				bag[j] = j;
178  			}
179  			break;
180  		case 1:
181  			for (j = 0; j < NNODES; j++) {
182  				bag[j] = NNODES - j - 1;
183  			}
184  			break;
185  		default:
186  			for (j = 0; j < NNODES; j++) {
187  				bag[j] = gen_rand64_range(sfmt, NNODES);
188  			}
189  		}
190  		for (j = 1; j <= NNODES; j++) {
191  			tree_new(&tree);
192  			for (k = 0; k < j; k++) {
193  				nodes[k].magic = NODE_MAGIC;
194  				nodes[k].key = bag[k];
195  			}
196  			for (k = 0; k < j; k++) {
197  				tree_insert(&tree, &nodes[k]);
198  				rbtn_black_height(node_t, link, &tree,
199  				    black_height);
200  				imbalances = tree_recurse(tree.rbt_root,
201  				    black_height, 0);
202  				assert_u_eq(imbalances, 0,
203  				    "Tree is unbalanced");
204  				assert_u_eq(tree_iterate(&tree), k+1,
205  				    "Unexpected node iteration count");
206  				assert_u_eq(tree_iterate_reverse(&tree), k+1,
207  				    "Unexpected node iteration count");
208  				assert_false(tree_empty(&tree),
209  				    "Tree should not be empty");
210  				assert_ptr_not_null(tree_first(&tree),
211  				    "Tree should not be empty");
212  				assert_ptr_not_null(tree_last(&tree),
213  				    "Tree should not be empty");
214  				tree_next(&tree, &nodes[k]);
215  				tree_prev(&tree, &nodes[k]);
216  			}
217  			switch (i % 5) {
218  			case 0:
219  				for (k = 0; k < j; k++) {
220  					node_remove(&tree, &nodes[k], j - k);
221  				}
222  				break;
223  			case 1:
224  				for (k = j; k > 0; k--) {
225  					node_remove(&tree, &nodes[k-1], k);
226  				}
227  				break;
228  			case 2: {
229  				node_t *start;
230  				unsigned nnodes = j;
231  				start = NULL;
232  				do {
233  					start = tree_iter(&tree, start,
234  					    remove_iterate_cb, (void *)&nnodes);
235  					nnodes--;
236  				} while (start != NULL);
237  				assert_u_eq(nnodes, 0,
238  				    "Removal terminated early");
239  				break;
240  			} case 3: {
241  				node_t *start;
242  				unsigned nnodes = j;
243  				start = NULL;
244  				do {
245  					start = tree_reverse_iter(&tree, start,
246  					    remove_reverse_iterate_cb,
247  					    (void *)&nnodes);
248  					nnodes--;
249  				} while (start != NULL);
250  				assert_u_eq(nnodes, 0,
251  				    "Removal terminated early");
252  				break;
253  			} case 4: {
254  				unsigned nnodes = j;
255  				tree_destroy(&tree, destroy_cb, &nnodes);
256  				assert_u_eq(nnodes, 0,
257  				    "Destruction terminated early");
258  				break;
259  			} default:
260  				not_reached();
261  			}
262  		}
263  	}
264  	fini_gen_rand(sfmt);
265  #undef NNODES
266  #undef NBAGS
267  #undef SEED
268  }
269  TEST_END
270  int
271  main(void) {
272  	return test(
273  	    test_rb_empty,
274  	    test_rb_random);
275  }
</code></pre>
        </div>
        <div class="column">
            <h3>libtomcrypt-MDEwOlJlcG9zaXRvcnk3NzcwMTE=-flat-tv_gen.c</h3>
            <pre><code>1  #include "tomcrypt_private.h"
2  static void hash_gen(void)
3  {
4     unsigned char md[MAXBLOCKSIZE], *buf;
5     unsigned long outlen, x, y, z;
6     FILE *out;
7     int   err;
8     out = fopen("hash_tv.txt", "w");
9     if (out == NULL) {
10        perror("can't open hash_tv");
11     }
12     fprintf(out, "Hash Test Vectors:\n\nThese are the hashes of nn bytes '00 01 02 03 .. (nn-1)'\n\n");
13     for (x = 0; hash_descriptor[x].name != NULL; x++) {
14        buf = XMALLOC(2 * hash_descriptor[x].blocksize + 1);
15        if (buf == NULL) {
16           perror("can't alloc mem");
17           exit(EXIT_FAILURE);
18        }
19        fprintf(out, "Hash: %s\n", hash_descriptor[x].name);
20        for (y = 0; y <= (hash_descriptor[x].blocksize * 2); y++) {
21           for (z = 0; z < y; z++) {
22              buf[z] = (unsigned char)(z & 255);
23           }
24           outlen = sizeof(md);
25           if ((err = hash_memory(x, buf, y, md, &outlen)) != CRYPT_OK) {
26              printf("hash_memory error: %s\n", error_to_string(err));
27              exit(EXIT_FAILURE);
28           }
29           fprintf(out, "%3lu: ", y);
30           for (z = 0; z < outlen; z++) {
31              fprintf(out, "%02X", md[z]);
32           }
33           fprintf(out, "\n");
34        }
35        fprintf(out, "\n");
36        XFREE(buf);
37     }
38     fclose(out);
39  }
40  static void cipher_gen(void)
41  {
42     unsigned char *key, pt[MAXBLOCKSIZE];
43     unsigned long x, y, z, w;
44     int err, kl, lastkl;
45     FILE *out;
46     symmetric_key skey;
47     out = fopen("cipher_tv.txt", "w");
48     fprintf(out,
49  "Cipher Test Vectors\n\nThese are test encryptions with key of nn bytes '00 01 02 03 .. (nn-1)' and original PT of the same style.\n"
50  "The output of step N is used as the key and plaintext for step N+1 (key bytes repeated as required to fill the key)\n\n");
51     for (x = 0; cipher_descriptor[x].name != NULL; x++) {
52        fprintf(out, "Cipher: %s\n", cipher_descriptor[x].name);
<span onclick='openModal()' class='match'>53        lastkl = 10000;
54        for (y = 0; y < 3; y++) {
55           switch (y) {
56              case 0: kl = cipher_descriptor[x].min_key_length; break;
</span>57              case 1: kl = (cipher_descriptor[x].min_key_length + cipher_descriptor[x].max_key_length)/2; break;
58              case 2: kl = cipher_descriptor[x].max_key_length; break;
59           }
60           if ((err = cipher_descriptor[x].keysize(&kl)) != CRYPT_OK) {
61              printf("keysize error: %s\n", error_to_string(err));
62              exit(EXIT_FAILURE);
63           }
64           if (kl == lastkl) continue;
65           lastkl = kl;
66           fprintf(out, "Key Size: %d bytes\n", kl);
67           key = XMALLOC(kl);
68           if (key == NULL) {
69              perror("can't malloc memory");
70              exit(EXIT_FAILURE);
71           }
72           for (z = 0; (int)z < kl; z++) {
73               key[z] = (unsigned char)z;
74           }
75           if ((err = cipher_descriptor[x].setup(key, kl, 0, &skey)) != CRYPT_OK) {
76              printf("setup error: %s\n", error_to_string(err));
77              exit(EXIT_FAILURE);
78           }
79           for (z = 0; (int)z < cipher_descriptor[x].block_length; z++) {
80              pt[z] = (unsigned char)z;
81           }
82           for (w = 0; w < 50; w++) {
83               cipher_descriptor[x].ecb_encrypt(pt, pt, &skey);
84               fprintf(out, "%2lu: ", w);
85               for (z = 0; (int)z < cipher_descriptor[x].block_length; z++) {
86                  fprintf(out, "%02X", pt[z]);
87               }
88               fprintf(out, "\n");
89               for (z = 0; z < (unsigned long)kl; z++) {
90                   key[z] = pt[z % cipher_descriptor[x].block_length];
91               }
92               if ((err = cipher_descriptor[x].setup(key, kl, 0, &skey)) != CRYPT_OK) {
93                  printf("cipher setup2 error: %s\n", error_to_string(err));
94                  exit(EXIT_FAILURE);
95               }
96           }
97           fprintf(out, "\n");
98           XFREE(key);
99       }
100       fprintf(out, "\n");
101    }
102    fclose(out);
103  }
104  static void hmac_gen(void)
105  {
106     unsigned char key[MAXBLOCKSIZE], output[MAXBLOCKSIZE], *input;
107     int x, y, z, err;
108     FILE *out;
109     unsigned long len;
110     out = fopen("hmac_tv.txt", "w");
111     fprintf(out,
112  "HMAC Tests.  In these tests messages of N bytes long (00,01,02,...,NN-1) are HMACed.  The initial key is\n"
113  "of the same format (the same length as the HASH output size).  The HMAC key in step N+1 is the HMAC output of\n"
114  "step N.\n\n");
115     for (x = 0; hash_descriptor[x].name != NULL; x++) {
116        fprintf(out, "HMAC-%s\n", hash_descriptor[x].name);
117        for (y = 0; y < (int)hash_descriptor[x].hashsize; y++) {
118            key[y] = (y&255);
119        }
120        input = XMALLOC(hash_descriptor[x].blocksize * 2 + 1);
121        if (input == NULL) {
122           perror("Can't malloc memory");
123           exit(EXIT_FAILURE);
124        }
125        for (y = 0; y <= (int)(hash_descriptor[x].blocksize * 2); y++) {
126           for (z = 0; z < y; z++) {
127              input[z] = (unsigned char)(z & 255);
128           }
129           len = sizeof(output);
130           if ((err = hmac_memory(x, key, hash_descriptor[x].hashsize, input, y, output, &len)) != CRYPT_OK) {
131              printf("Error hmacing: %s\n", error_to_string(err));
132              exit(EXIT_FAILURE);
133           }
134           fprintf(out, "%3d: ", y);
135           for (z = 0; z <(int) len; z++) {
136              fprintf(out, "%02X", output[z]);
137           }
138           fprintf(out, "\n");
139           memcpy(key, output, hash_descriptor[x].hashsize);
140        }
141        XFREE(input);
142        fprintf(out, "\n");
143     }
144     fclose(out);
145  }
146  #ifdef LTC_OMAC
147  static void omac_gen(void)
148  {
149     unsigned char key[MAXBLOCKSIZE], output[MAXBLOCKSIZE], input[MAXBLOCKSIZE*2+2];
150     int err, x, y, z, kl;
151     FILE *out;
152     unsigned long len;
153     out = fopen("omac_tv.txt", "w");
154     fprintf(out,
155  "OMAC Tests.  In these tests messages of N bytes long (00,01,02,...,NN-1) are OMAC'ed.  The initial key is\n"
156  "of the same format (length specified per cipher).  The OMAC key in step N+1 is the OMAC output of\n"
157  "step N (repeated as required to fill the array).\n\n");
158     for (x = 0; cipher_descriptor[x].name != NULL; x++) {
159        kl = cipher_descriptor[x].block_length;
160        if (kl != 8 && kl != 16) continue;
161        if (cipher_descriptor[x].keysize(&kl) != CRYPT_OK) {
162           kl = cipher_descriptor[x].max_key_length;
163        }
164        fprintf(out, "OMAC-%s (%d byte key)\n", cipher_descriptor[x].name, kl);
165        for (y = 0; y < kl; y++) {
166            key[y] = (y & 255);
167        }
168        for (y = 0; y <= (int)(cipher_descriptor[x].block_length*2); y++) {
169           for (z = 0; z < y; z++) {
170              input[z] = (unsigned char)(z & 255);
171           }
172           len = sizeof(output);
173           if ((err = omac_memory(x, key, kl, input, y, output, &len)) != CRYPT_OK) {
174              printf("Error OMAC'ing: %s\n", error_to_string(err));
175              exit(EXIT_FAILURE);
176           }
177           if (len == 0) {
178              printf("Error OMAC'ing: zero length\n");
179              exit(EXIT_FAILURE);
180           }
181           fprintf(out, "%3d: ", y);
182           for (z = 0; z <(int)len; z++) {
183              fprintf(out, "%02X", output[z]);
184           }
185           fprintf(out, "\n");
186           for (z = 0; z < kl; z++) {
187               key[z] = output[z % len];
188           }
189        }
190        fprintf(out, "\n");
191     }
192     fclose(out);
193  }
194  #endif
195  #ifdef LTC_PMAC
196  static void pmac_gen(void)
197  {
198     unsigned char key[MAXBLOCKSIZE], output[MAXBLOCKSIZE], input[MAXBLOCKSIZE*2+2];
199     int err, x, y, z, kl;
200     FILE *out;
201     unsigned long len;
202     out = fopen("pmac_tv.txt", "w");
203     fprintf(out,
204  "PMAC Tests.  In these tests messages of N bytes long (00,01,02,...,NN-1) are PMAC'ed.  The initial key is\n"
205  "of the same format (length specified per cipher).  The PMAC key in step N+1 is the PMAC output of\n"
206  "step N (repeated as required to fill the array).\n\n");
207     for (x = 0; cipher_descriptor[x].name != NULL; x++) {
208        kl = cipher_descriptor[x].block_length;
209        if (kl != 8 && kl != 16) continue;
210        if (cipher_descriptor[x].keysize(&kl) != CRYPT_OK) {
211           kl = cipher_descriptor[x].max_key_length;
212        }
213        fprintf(out, "PMAC-%s (%d byte key)\n", cipher_descriptor[x].name, kl);
214        for (y = 0; y < kl; y++) {
215            key[y] = (y & 255);
216        }
217        for (y = 0; y <= (int)(cipher_descriptor[x].block_length*2); y++) {
218           for (z = 0; z < y; z++) {
219              input[z] = (unsigned char)(z & 255);
220           }
221           len = sizeof(output);
222           if ((err = pmac_memory(x, key, kl, input, y, output, &len)) != CRYPT_OK) {
223              printf("Error PMACing: %s\n", error_to_string(err));
224              exit(EXIT_FAILURE);
225           }
226           if (len == 0) {
227              printf("Error PMAC'ing: zero length\n");
228              exit(EXIT_FAILURE);
229           }
230           fprintf(out, "%3d: ", y);
231           for (z = 0; z <(int)len; z++) {
232              fprintf(out, "%02X", output[z]);
233           }
234           fprintf(out, "\n");
235           for (z = 0; z < kl; z++) {
236               key[z] = output[z % len];
237           }
238        }
239        fprintf(out, "\n");
240     }
241     fclose(out);
242  }
243  #endif
244  #ifdef LTC_EAX_MODE
245  static void eax_gen(void)
246  {
247     int err, kl, x, y1, z;
248     FILE *out;
249     unsigned char key[MAXBLOCKSIZE], nonce[MAXBLOCKSIZE*2], header[MAXBLOCKSIZE*2],
250                   plaintext[MAXBLOCKSIZE*2], tag[MAXBLOCKSIZE];
251     unsigned long len;
252     out = fopen("eax_tv.txt", "w");
253     fprintf(out, "EAX Test Vectors.  Uses the 00010203...NN-1 pattern for header/nonce/plaintext/key.  The outputs\n"
254                  "are of the form ciphertext,tag for a given NN.  The key for step N>1 is the tag of the previous\n"
255                  "step repeated sufficiently.\n\n");
256     for (x = 0; cipher_descriptor[x].name != NULL; x++) {
257        kl = cipher_descriptor[x].block_length;
258        if (kl != 8 && kl != 16) continue;
259        if (cipher_descriptor[x].keysize(&kl) != CRYPT_OK) {
260           kl = cipher_descriptor[x].max_key_length;
261        }
262        fprintf(out, "EAX-%s (%d byte key)\n", cipher_descriptor[x].name, kl);
263        for (z = 0; z < kl; z++) {
264            key[z] = (z & 255);
265        }
266        for (y1 = 0; y1 <= (int)(cipher_descriptor[x].block_length*2); y1++){
267           for (z = 0; z < y1; z++) {
268              plaintext[z] = (unsigned char)(z & 255);
269              nonce[z]     = (unsigned char)(z & 255);
270              header[z]    = (unsigned char)(z & 255);
271           }
272           len = sizeof(tag);
273           if ((err = eax_encrypt_authenticate_memory(x, key, kl, nonce, y1, header, y1, plaintext, y1, plaintext, tag, &len)) != CRYPT_OK) {
274              printf("Error EAX'ing: %s\n", error_to_string(err));
275              exit(EXIT_FAILURE);
276           }
277           if (len == 0) {
278              printf("Error EAX'ing: zero length\n");
279              exit(EXIT_FAILURE);
280           }
281           fprintf(out, "%3d: ", y1);
282           for (z = 0; z < y1; z++) {
283              fprintf(out, "%02X", plaintext[z]);
284           }
285           fprintf(out, ", ");
286           for (z = 0; z <(int)len; z++) {
287              fprintf(out, "%02X", tag[z]);
288           }
289           fprintf(out, "\n");
290           for (z = 0; z < kl; z++) {
291               key[z] = tag[z % len];
292           }
293        }
294        fprintf(out, "\n");
295     }
296     fclose(out);
297  }
298  #endif
299  #ifdef LTC_OCB_MODE
300  static void ocb_gen(void)
301  {
302     int err, kl, x, y1, z;
303     FILE *out;
304     unsigned char key[MAXBLOCKSIZE], nonce[MAXBLOCKSIZE*2],
305                   plaintext[MAXBLOCKSIZE*2], tag[MAXBLOCKSIZE];
306     unsigned long len;
307     out = fopen("ocb_tv.txt", "w");
308     fprintf(out, "OCB Test Vectors.  Uses the 00010203...NN-1 pattern for nonce/plaintext/key.  The outputs\n"
309                  "are of the form ciphertext,tag for a given NN.  The key for step N>1 is the tag of the previous\n"
310                  "step repeated sufficiently.  The nonce is fixed throughout.\n\n");
311     for (x = 0; cipher_descriptor[x].name != NULL; x++) {
312        kl = cipher_descriptor[x].block_length;
313        if (kl != 8 && kl != 16) continue;
314        if (cipher_descriptor[x].keysize(&kl) != CRYPT_OK) {
315           kl = cipher_descriptor[x].max_key_length;
316        }
317        fprintf(out, "OCB-%s (%d byte key)\n", cipher_descriptor[x].name, kl);
318        for (z = 0; z < kl; z++) {
319            key[z] = (z & 255);
320        }
321        for (z = 0; z < cipher_descriptor[x].block_length; z++) {
322            nonce[z] = z;
323        }
324        for (y1 = 0; y1 <= (int)(cipher_descriptor[x].block_length*2); y1++){
325           for (z = 0; z < y1; z++) {
326              plaintext[z] = (unsigned char)(z & 255);
327           }
328           len = sizeof(tag);
329           if ((err = ocb_encrypt_authenticate_memory(x, key, kl, nonce, plaintext, y1, plaintext, tag, &len)) != CRYPT_OK) {
330              printf("Error OCB'ing: %s\n", error_to_string(err));
331              exit(EXIT_FAILURE);
332           }
333           if (len == 0) {
334              printf("Error OCB'ing: zero length\n");
335              exit(EXIT_FAILURE);
336           }
337           fprintf(out, "%3d: ", y1);
338           for (z = 0; z < y1; z++) {
339              fprintf(out, "%02X", plaintext[z]);
340           }
341           fprintf(out, ", ");
342           for (z = 0; z <(int)len; z++) {
343              fprintf(out, "%02X", tag[z]);
344           }
345           fprintf(out, "\n");
346           for (z = 0; z < kl; z++) {
347               key[z] = tag[z % len];
348           }
349        }
350        fprintf(out, "\n");
351     }
352     fclose(out);
353  }
354  #endif
355  #ifdef LTC_OCB3_MODE
356  static void ocb3_gen(void)
357  {
358     int err, kl, x, y1, z, noncelen;
359     FILE *out;
360     unsigned char key[MAXBLOCKSIZE], nonce[MAXBLOCKSIZE*2],
361                   plaintext[MAXBLOCKSIZE*2], tag[MAXBLOCKSIZE];
362     unsigned long len;
363     out = fopen("ocb3_tv.txt", "w");
364     fprintf(out, "OCB3 Test Vectors.  Uses the 00010203...NN-1 pattern for nonce/plaintext/key.  The outputs\n"
365                  "are of the form ciphertext,tag for a given NN.  The key for step N>1 is the tag of the previous\n"
366                  "step repeated sufficiently.  The nonce is fixed throughout. AAD is fixed to 3 bytes (ASCII) 'AAD'.\n\n");
367     for (x = 0; cipher_descriptor[x].name != NULL; x++) {
368        kl = cipher_descriptor[x].block_length;
369        if (kl != 16) continue;
370        if (cipher_descriptor[x].keysize(&kl) != CRYPT_OK) {
371           kl = cipher_descriptor[x].max_key_length;
372        }
373        fprintf(out, "OCB3-%s (%d byte key)\n", cipher_descriptor[x].name, kl);
374        for (z = 0; z < kl; z++) {
375            key[z] = (z & 255);
376        }
377        noncelen = MIN(15, cipher_descriptor[x].block_length);
378        for (z = 0; z < noncelen; z++) {
379            nonce[z] = z;
380        }
381        for (y1 = 0; y1 <= (int)(cipher_descriptor[x].block_length*2); y1++){
382           for (z = 0; z < y1; z++) {
383              plaintext[z] = (unsigned char)(z & 255);
384           }
385           len = 16;
386           if ((err = ocb3_encrypt_authenticate_memory(x, key, kl, nonce, noncelen, (unsigned char*)"AAD", 3, plaintext, y1, plaintext, tag, &len)) != CRYPT_OK) {
387              printf("Error OCB3'ing: %s\n", error_to_string(err));
388              exit(EXIT_FAILURE);
389           }
390           if (len == 0) {
391              printf("Error OCB3'ing: zero length\n");
392              exit(EXIT_FAILURE);
393           }
394           fprintf(out, "%3d: ", y1);
395           for (z = 0; z < y1; z++) {
396              fprintf(out, "%02X", plaintext[z]);
397           }
398           fprintf(out, ", ");
399           for (z = 0; z <(int)len; z++) {
400              fprintf(out, "%02X", tag[z]);
401           }
402           fprintf(out, "\n");
403           for (z = 0; z < kl; z++) {
404               key[z] = tag[z % len];
405           }
406        }
407        fprintf(out, "\n");
408     }
409     fclose(out);
410  }
411  #endif
412  #ifdef LTC_CCM_MODE
413  static void ccm_gen(void)
414  {
415     int err, kl, x, y1, z;
416     unsigned int t;
417     FILE *out;
418     unsigned char key[MAXBLOCKSIZE], nonce[MAXBLOCKSIZE*2],
419                   plaintext[MAXBLOCKSIZE*2], tag[16];
420     unsigned long len;
421     const unsigned int taglen[] = {4, 6, 8, 10, 12, 14, 16};
422     out = fopen("ccm_tv.txt", "w");
423     fprintf(out, "CCM Test Vectors.  Uses the 00010203...NN-1 pattern for nonce/header/plaintext/key.  The outputs\n"
424                  "are of the form ciphertext,tag for a given NN.  The key for step N>1 is the tag of the previous\n"
425                  "step repeated sufficiently.  The nonce is fixed throughout at 13 bytes 000102...\n\n");
426     for (x = 0; cipher_descriptor[x].name != NULL; x++) {
427        kl = cipher_descriptor[x].block_length;
428        if (kl != 16) continue;
429        if (cipher_descriptor[x].keysize(&kl) != CRYPT_OK) {
430           kl = cipher_descriptor[x].max_key_length;
431        }
432        fprintf(out, "CCM-%s (%d byte key)\n", cipher_descriptor[x].name, kl);
433        for (z = 0; z < kl; z++) {
434            key[z] = (z & 255);
435        }
436        for (z = 0; z < cipher_descriptor[x].block_length; z++) {
437            nonce[z] = z;
438        }
439        for (t = 0; t < sizeof(taglen)/sizeof(taglen[0]); ++t) {
440           for (y1 = 0; y1 <= (int)(cipher_descriptor[x].block_length*2); y1++){
441              for (z = 0; z < y1; z++) {
442                 plaintext[z] = (unsigned char)(z & 255);
443              }
444              len = taglen[t];
445              if ((err = ccm_memory(x, key, kl, NULL, nonce, 13, plaintext, y1, plaintext, y1, plaintext, tag, &len, CCM_ENCRYPT)) != CRYPT_OK) {
446                 printf("Error CCM'ing: %s\n", error_to_string(err));
447                 exit(EXIT_FAILURE);
448              }
449              if (len == 0) {
450                 printf("Error CCM'ing: zero length\n");
451                 exit(EXIT_FAILURE);
452              }
453              fprintf(out, "%3d: ", y1);
454              for (z = 0; z < y1; z++) {
455                 fprintf(out, "%02X", plaintext[z]);
456              }
457              fprintf(out, ", ");
458              for (z = 0; z <(int)len; z++) {
459                 fprintf(out, "%02X", tag[z]);
460              }
461              fprintf(out, "\n");
462              for (z = 0; z < kl; z++) {
463                  key[z] = tag[z % len];
464              }
465           }
466        }
467        fprintf(out, "\n");
468     }
469     fclose(out);
470  }
471  #endif
472  #ifdef LTC_GCM_MODE
473  static void gcm_gen(void)
474  {
475     int err, kl, x, y1, z;
476     FILE *out;
477     unsigned char key[MAXBLOCKSIZE], plaintext[MAXBLOCKSIZE*2], tag[MAXBLOCKSIZE];
478     unsigned long len;
479     out = fopen("gcm_tv.txt", "w");
480     fprintf(out, "GCM Test Vectors.  Uses the 00010203...NN-1 pattern for nonce/header/plaintext/key.  The outputs\n"
481                  "are of the form ciphertext,tag for a given NN.  The key for step N>1 is the tag of the previous\n"
482                  "step repeated sufficiently.  The nonce is fixed throughout at 13 bytes 000102...\n\n");
483     for (x = 0; cipher_descriptor[x].name != NULL; x++) {
484        kl = cipher_descriptor[x].block_length;
485        if (kl != 16) continue;
486        if (cipher_descriptor[x].keysize(&kl) != CRYPT_OK) {
487           kl = cipher_descriptor[x].max_key_length;
488        }
489        fprintf(out, "GCM-%s (%d byte key)\n", cipher_descriptor[x].name, kl);
490        for (z = 0; z < kl; z++) {
491            key[z] = (z & 255);
492        }
493        for (y1 = 1; y1 <= (int)(cipher_descriptor[x].block_length*2); y1++){
494           for (z = 0; z < y1; z++) {
495              plaintext[z] = (unsigned char)(z & 255);
496           }
497           len = sizeof(tag);
498           if ((err = gcm_memory(x, key, kl, plaintext, y1, plaintext, y1, plaintext, y1, plaintext, tag, &len, GCM_ENCRYPT)) != CRYPT_OK) {
499              printf("Error GCM'ing: %s\n", error_to_string(err));
500              exit(EXIT_FAILURE);
501           }
502           if (len == 0) {
503              printf("Error GCM'ing: zero length\n");
504              exit(EXIT_FAILURE);
505           }
506           fprintf(out, "%3d: ", y1);
507           for (z = 0; z < y1; z++) {
508              fprintf(out, "%02X", plaintext[z]);
509           }
510           fprintf(out, ", ");
511           for (z = 0; z <(int)len; z++) {
512              fprintf(out, "%02X", tag[z]);
513           }
514           fprintf(out, "\n");
515           for (z = 0; z < kl; z++) {
516               key[z] = tag[z % len];
517           }
518        }
519        fprintf(out, "\n");
520     }
521     fclose(out);
522  }
523  #endif
524  static void base64_gen(void)
525  {
526     FILE *out;
527     unsigned char src[32], ch;
528     char dst[256];
529     unsigned long x, len;
530     out = fopen("base64_tv.txt", "w");
531     fprintf(out, "Base64 vectors.  These are the base64 encodings of the strings 00,01,02...NN-1\n\n");
532     for (x = 0; x <= 32; x++) {
533         for (ch = 0; ch < x; ch++) {
534             src[ch] = ch;
535         }
536         len = sizeof(dst);
537         base64_encode(src, x, dst, &len);
538         fprintf(out, "%2lu: %s\n", x, dst);
539     }
540     fclose(out);
541  }
542  static void math_gen(void)
543  {
544  }
545  static void ecc_gen(void)
546  {
547     FILE         *out;
548     unsigned char str[512];
549     void          *k, *order, *modulus, *a;
550     ecc_point    *G, *R;
551     int           x;
552     out = fopen("ecc_tv.txt", "w");
553     fprintf(out, "ecc vectors.  These are for kG for k=1,3,9,27,...,3**n until k > order of the curve outputs are <k,x,y> triplets\n\n");
554     G = ltc_ecc_new_point();
555     R = ltc_ecc_new_point();
556     mp_init(&k);
557     mp_init(&order);
558     mp_init(&modulus);
559     mp_init(&a);
560     for (x = 0; ltc_ecc_curves[x].prime != NULL; x++) {
561          fprintf(out, "%s\n", ltc_ecc_curves[x].OID);
562          mp_set(k, 1);
563          mp_read_radix(order,   (char *)ltc_ecc_curves[x].order, 16);
564          mp_read_radix(modulus, (char *)ltc_ecc_curves[x].prime, 16);
565          mp_read_radix(a,       (char *)ltc_ecc_curves[x].A,     16);
566          mp_read_radix(G->x,    (char *)ltc_ecc_curves[x].Gx,    16);
567          mp_read_radix(G->y,    (char *)ltc_ecc_curves[x].Gy,    16);
568          mp_set(G->z, 1);
569          while (mp_cmp(k, order) == LTC_MP_LT) {
570              ltc_mp.ecc_ptmul(k, G, R, a, modulus, 1);
571              mp_tohex(k,    (char*)str); fprintf(out, "%s, ", (char*)str);
572              mp_tohex(R->x, (char*)str); fprintf(out, "%s, ", (char*)str);
573              mp_tohex(R->y, (char*)str); fprintf(out, "%s\n", (char*)str);
574              mp_mul_d(k, 3, k);
575          }
576     }
577     mp_clear_multi(k, order, modulus, a, LTC_NULL);
578     ltc_ecc_del_point(G);
579     ltc_ecc_del_point(R);
580     fclose(out);
581  }
582  #ifdef LTC_LRW_MODE
583  static void lrw_gen(void)
584  {
585     FILE *out;
586     unsigned char tweak[16], key[16], iv[16], buf[1024];
587     int x, y, err;
588     symmetric_LRW lrw;
589     for (x = 0; x < 16; x++) {
590        tweak[x] = key[x] = iv[x] = x;
591     }
592     out = fopen("lrw_tv.txt", "w");
593     for (x = 16; x < (int)(sizeof(buf)); x += 16) {
594         if ((err = lrw_start(find_cipher("aes"), iv, key, 16, tweak, 0, &lrw)) != CRYPT_OK) {
595            fprintf(stderr, "Error starting LRW-AES: %s\n", error_to_string(err));
596            exit(EXIT_FAILURE);
597         }
598         for (y = 0; y < x; y++) {
599             buf[y] = y & 255;
600         }
601         if ((err = lrw_encrypt(buf, buf, x, &lrw)) != CRYPT_OK) {
602            fprintf(stderr, "Error encrypting with LRW-AES: %s\n", error_to_string(err));
603            exit(EXIT_FAILURE);
604         }
605         fprintf(out, "%d:", x);
606         for (y = 0; y < x; y++) {
607            fprintf(out, "%02x", buf[y]);
608         }
609         fprintf(out, "\n");
610         if ((err = lrw_setiv(iv, 16, &lrw)) != CRYPT_OK) {
611            fprintf(stderr, "Error setting IV: %s\n", error_to_string(err));
612            exit(EXIT_FAILURE);
613         }
614         for (y = 0; y < 16; y++) {
615            key[y]   = buf[y];
616            iv[y]    = buf[(y+16)%x];
617            tweak[y] = buf[(y+32)%x];
618         }
619         if ((err = lrw_decrypt(buf, buf, x, &lrw)) != CRYPT_OK) {
620            fprintf(stderr, "Error decrypting with LRW-AES: %s\n", error_to_string(err));
621            exit(EXIT_FAILURE);
622         }
623         fprintf(out, "%d:", x);
624         for (y = 0; y < x; y++) {
625            fprintf(out, "%02x", buf[y]);
626         }
627         fprintf(out, "\n");
628         lrw_done(&lrw);
629     }
630     fclose(out);
631  }
632  #endif
633  int main(void)
634  {
635     register_all_ciphers();
636     register_all_hashes();
637     register_all_prngs();
638  #ifdef USE_LTM
639     ltc_mp = ltm_desc;
640  #elif defined(USE_TFM)
641     ltc_mp = tfm_desc;
642  #elif defined(USE_GMP)
643     ltc_mp = gmp_desc;
644  #elif defined(EXT_MATH_LIB)
645     extern ltc_math_descriptor EXT_MATH_LIB;
646     ltc_mp = EXT_MATH_LIB;
647  #endif
648     printf("Generating hash   vectors..."); fflush(stdout); hash_gen();   printf("done\n");
649     printf("Generating cipher vectors..."); fflush(stdout); cipher_gen(); printf("done\n");
650     printf("Generating HMAC   vectors..."); fflush(stdout); hmac_gen();   printf("done\n");
651  #ifdef LTC_OMAC
652     printf("Generating OMAC   vectors..."); fflush(stdout); omac_gen();   printf("done\n");
653  #endif
654  #ifdef LTC_PMAC
655     printf("Generating PMAC   vectors..."); fflush(stdout); pmac_gen();   printf("done\n");
656  #endif
657  #ifdef LTC_EAX_MODE
658     printf("Generating EAX    vectors..."); fflush(stdout); eax_gen();    printf("done\n");
659  #endif
660  #ifdef LTC_OCB_MODE
661     printf("Generating OCB    vectors..."); fflush(stdout); ocb_gen();    printf("done\n");
662  #endif
663  #ifdef LTC_OCB3_MODE
664     printf("Generating OCB3   vectors..."); fflush(stdout); ocb3_gen();   printf("done\n");
665  #endif
666  #ifdef LTC_CCM_MODE
667     printf("Generating CCM    vectors..."); fflush(stdout); ccm_gen();    printf("done\n");
668  #endif
669  #ifdef LTC_GCM_MODE
670     printf("Generating GCM    vectors..."); fflush(stdout); gcm_gen();    printf("done\n");
671  #endif
672     printf("Generating BASE64 vectors..."); fflush(stdout); base64_gen(); printf("done\n");
673     if (ltc_mp.name != NULL) {
674        printf("Generating MATH   vectors..."); fflush(stdout); math_gen();   printf("done\n");
675        printf("Generating ECC    vectors..."); fflush(stdout); ecc_gen();    printf("done\n");
676     }
677  #ifdef LTC_LRW_MODE
678     printf("Generating LRW    vectors..."); fflush(stdout); lrw_gen();    printf("done\n");
679  #endif
680     return 0;
681  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from redis-MDEwOlJlcG9zaXRvcnkxMDgxMTA3MDY=-flat-rb.c</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from libtomcrypt-MDEwOlJlcG9zaXRvcnk3NzcwMTE=-flat-tv_gen.c</div>
                </div>
                <div class="column column_space"><pre><code>172  	sfmt = init_gen_rand(SEED);
173  	for (i = 0; i < NBAGS; i++) {
174  		switch (i) {
175  		case 0:
</pre></code></div>
                <div class="column column_space"><pre><code>53        lastkl = 10000;
54        for (y = 0; y < 3; y++) {
55           switch (y) {
56              case 0: kl = cipher_descriptor[x].min_key_length; break;
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    