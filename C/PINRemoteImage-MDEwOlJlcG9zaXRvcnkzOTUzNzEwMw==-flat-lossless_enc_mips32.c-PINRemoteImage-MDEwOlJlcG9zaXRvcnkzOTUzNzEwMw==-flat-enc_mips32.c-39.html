
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 15, <button onclick='openModal()' class='match'>CODE CLONE</button></h2>
        <div class="column">
            <h3>PINRemoteImage-MDEwOlJlcG9zaXRvcnkzOTUzNzEwMw==-flat-lossless_enc_mips32.c</h3>
            <pre><code>1  #include &quot;src/dsp/dsp.h&quot;
2  #include &quot;src/dsp/lossless.h&quot;
3  #include &quot;src/dsp/lossless_common.h&quot;
4  #if defined(WEBP_USE_MIPS32)
5  #include &lt;assert.h&gt;
6  #include &lt;math.h&gt;
7  #include &lt;stdlib.h&gt;
8  #include &lt;string.h&gt;
9  static float FastSLog2Slow_MIPS32(uint32_t v) {
10    assert(v &gt;= LOG_LOOKUP_IDX_MAX);
11    if (v &lt; APPROX_LOG_WITH_CORRECTION_MAX) {
12      uint32_t log_cnt, y, correction;
13      const int c24 = 24;
14      const float v_f = (float)v;
15      uint32_t temp;
16      __asm__ volatile(
17        &quot;clz      %[log_cnt], %[v]                      \n\t&quot;
18        &quot;addiu    %[y],       $zero,        1           \n\t&quot;
19        &quot;subu     %[log_cnt], %[c24],       %[log_cnt]  \n\t&quot;
20        &quot;sllv     %[y],       %[y],         %[log_cnt]  \n\t&quot;
21        &quot;srlv     %[temp],    %[v],         %[log_cnt]  \n\t&quot;
22        : [log_cnt]&quot;=&amp;r&quot;(log_cnt), [y]&quot;=&amp;r&quot;(y),
23          [temp]&quot;=r&quot;(temp)
24        : [c24]&quot;r&quot;(c24), [v]&quot;r&quot;(v)
25      );
26      correction = (23 * (v &amp; (y - 1))) &gt;&gt; 4;
27      return v_f * (kLog2Table[temp] + log_cnt) + correction;
28    } else {
29      return (float)(LOG_2_RECIPROCAL * v * log((double)v));
30    }
31  }
32  static float FastLog2Slow_MIPS32(uint32_t v) {
33    assert(v &gt;= LOG_LOOKUP_IDX_MAX);
34    if (v &lt; APPROX_LOG_WITH_CORRECTION_MAX) {
35      uint32_t log_cnt, y;
36      const int c24 = 24;
37      double log_2;
38      uint32_t temp;
39      __asm__ volatile(
40        &quot;clz      %[log_cnt], %[v]                      \n\t&quot;
41        &quot;addiu    %[y],       $zero,        1           \n\t&quot;
42        &quot;subu     %[log_cnt], %[c24],       %[log_cnt]  \n\t&quot;
43        &quot;sllv     %[y],       %[y],         %[log_cnt]  \n\t&quot;
44        &quot;srlv     %[temp],    %[v],         %[log_cnt]  \n\t&quot;
45        : [log_cnt]&quot;=&amp;r&quot;(log_cnt), [y]&quot;=&amp;r&quot;(y),
46          [temp]&quot;=r&quot;(temp)
47        : [c24]&quot;r&quot;(c24), [v]&quot;r&quot;(v)
48      );
49      log_2 = kLog2Table[temp] + log_cnt;
50      if (v &gt;= APPROX_LOG_MAX) {
51        const uint32_t correction = (23 * (v &amp; (y - 1))) &gt;&gt; 4;
52        log_2 += (double)correction / v;
53      }
54      return (float)log_2;
55    } else {
56      return (float)(LOG_2_RECIPROCAL * log((double)v));
57    }
58  }
59  static double ExtraCost_MIPS32(const uint32_t* const population, int length) {
60    int i, temp0, temp1;
61    const uint32_t* pop = &amp;population[4];
62    const uint32_t* const LoopEnd = &amp;population[length];
63    __asm__ volatile(
64      &quot;mult   $zero,    $zero                  \n\t&quot;
65      &quot;xor    %[i],     %[i],       %[i]       \n\t&quot;
66      &quot;beq    %[pop],   %[LoopEnd], 2f         \n\t&quot;
67    &quot;1:                                        \n\t&quot;
68      &quot;lw     %[temp0], 0(%[pop])              \n\t&quot;
69      &quot;lw     %[temp1], 4(%[pop])              \n\t&quot;
70      &quot;addiu  %[i],     %[i],       1          \n\t&quot;
71      &quot;addiu  %[pop],   %[pop],     8          \n\t&quot;
72      &quot;madd   %[i],     %[temp0]               \n\t&quot;
73      &quot;madd   %[i],     %[temp1]               \n\t&quot;
74      &quot;bne    %[pop],   %[LoopEnd], 1b         \n\t&quot;
75    &quot;2:                                        \n\t&quot;
76      &quot;mfhi   %[temp0]                         \n\t&quot;
77      &quot;mflo   %[temp1]                         \n\t&quot;
78      : [temp0]&quot;=&amp;r&quot;(temp0), [temp1]&quot;=&amp;r&quot;(temp1),
79        [i]&quot;=&amp;r&quot;(i), [pop]&quot;+r&quot;(pop)
80      : [LoopEnd]&quot;r&quot;(LoopEnd)
81      : &quot;memory&quot;, &quot;hi&quot;, &quot;lo&quot;
82    );
83    return (double)((int64_t)temp0 &lt;&lt; 32 | temp1);
84  }
85  static double ExtraCostCombined_MIPS32(const uint32_t* const X,
86                                         const uint32_t* const Y, int length) {
87    int i, temp0, temp1, temp2, temp3;
88    const uint32_t* pX = &amp;X[4];
89    const uint32_t* pY = &amp;Y[4];
90    const uint32_t* const LoopEnd = &amp;X[length];
91    __asm__ volatile(
92      &quot;mult   $zero,    $zero                  \n\t&quot;
93      &quot;xor    %[i],     %[i],       %[i]       \n\t&quot;
94      &quot;beq    %[pX],    %[LoopEnd], 2f         \n\t&quot;
95    &quot;1:                                        \n\t&quot;
96      &quot;lw     %[temp0], 0(%[pX])               \n\t&quot;
97      &quot;lw     %[temp1], 0(%[pY])               \n\t&quot;
98      &quot;lw     %[temp2], 4(%[pX])               \n\t&quot;
99      &quot;lw     %[temp3], 4(%[pY])               \n\t&quot;
100      &quot;addiu  %[i],     %[i],       1          \n\t&quot;
101      &quot;addu   %[temp0], %[temp0],   %[temp1]   \n\t&quot;
102      &quot;addu   %[temp2], %[temp2],   %[temp3]   \n\t&quot;
103      &quot;addiu  %[pX],    %[pX],      8          \n\t&quot;
104      &quot;addiu  %[pY],    %[pY],      8          \n\t&quot;
105      &quot;madd   %[i],     %[temp0]               \n\t&quot;
106      &quot;madd   %[i],     %[temp2]               \n\t&quot;
107      &quot;bne    %[pX],    %[LoopEnd], 1b         \n\t&quot;
108    &quot;2:                                        \n\t&quot;
109      &quot;mfhi   %[temp0]                         \n\t&quot;
110      &quot;mflo   %[temp1]                         \n\t&quot;
111      : [temp0]&quot;=&amp;r&quot;(temp0), [temp1]&quot;=&amp;r&quot;(temp1),
112        [temp2]&quot;=&amp;r&quot;(temp2), [temp3]&quot;=&amp;r&quot;(temp3),
113        [i]&quot;=&amp;r&quot;(i), [pX]&quot;+r&quot;(pX), [pY]&quot;+r&quot;(pY)
114      : [LoopEnd]&quot;r&quot;(LoopEnd)
115      : &quot;memory&quot;, &quot;hi&quot;, &quot;lo&quot;
116    );
117    return (double)((int64_t)temp0 &lt;&lt; 32 | temp1);
118  }
119  #define HUFFMAN_COST_PASS                                 \
120    __asm__ volatile(                                       \
121      &quot;sll   %[temp1],  %[temp0],    3           \n\t&quot;      \
122      &quot;addiu %[temp3],  %[streak],   -3          \n\t&quot;      \
123      &quot;addu  %[temp2],  %[pstreaks], %[temp1]    \n\t&quot;      \
124      &quot;blez  %[temp3],  1f                       \n\t&quot;      \
125      &quot;srl   %[temp1],  %[temp1],    1           \n\t&quot;      \
126      &quot;addu  %[temp3],  %[pcnts],    %[temp1]    \n\t&quot;      \
127      &quot;lw    %[temp0],  4(%[temp2])              \n\t&quot;      \
128      &quot;lw    %[temp1],  0(%[temp3])              \n\t&quot;      \
129      &quot;addu  %[temp0],  %[temp0],    %[streak]   \n\t&quot;      \
130      &quot;addiu %[temp1],  %[temp1],    1           \n\t&quot;      \
131      &quot;sw    %[temp0],  4(%[temp2])              \n\t&quot;      \
132      &quot;sw    %[temp1],  0(%[temp3])              \n\t&quot;      \
133      &quot;b     2f                                  \n\t&quot;      \
134    &quot;1:                                          \n\t&quot;      \
135      &quot;lw    %[temp0],  0(%[temp2])              \n\t&quot;      \
136      &quot;addu  %[temp0],  %[temp0],    %[streak]   \n\t&quot;      \
137      &quot;sw    %[temp0],  0(%[temp2])              \n\t&quot;      \
138    &quot;2:                                          \n\t&quot;      \
139      : [temp1]&quot;=&amp;r&quot;(temp1), [temp2]&quot;=&amp;r&quot;(temp2),           \
140        [temp3]&quot;=&amp;r&quot;(temp3), [temp0]&quot;+r&quot;(temp0)             \
141      : [pstreaks]&quot;r&quot;(pstreaks), [pcnts]&quot;r&quot;(pcnts),         \
142        [streak]&quot;r&quot;(streak)                                 \
143      : &quot;memory&quot;                                            \
144    );
145  static WEBP_INLINE void GetEntropyUnrefinedHelper(
146      uint32_t val, int i, uint32_t* const val_prev, int* const i_prev,
147      VP8LBitEntropy* const bit_entropy, VP8LStreaks* const stats) {
148    int* const pstreaks = &amp;stats-&gt;streaks[0][0];
149    int* const pcnts = &amp;stats-&gt;counts[0];
150    int temp0, temp1, temp2, temp3;
151    const int streak = i - *i_prev;
152    if (*val_prev != 0) {
153      bit_entropy-&gt;sum += (*val_prev) * streak;
154      bit_entropy-&gt;nonzeros += streak;
155      bit_entropy-&gt;nonzero_code = *i_prev;
156      bit_entropy-&gt;entropy -= VP8LFastSLog2(*val_prev) * streak;
157      if (bit_entropy-&gt;max_val &lt; *val_prev) {
158        bit_entropy-&gt;max_val = *val_prev;
159      }
160    }
161    temp0 = (*val_prev != 0);
162    HUFFMAN_COST_PASS
163    *val_prev = val;
164    *i_prev = i;
165  }
166  static void GetEntropyUnrefined_MIPS32(const uint32_t X[], int length,
167                                         VP8LBitEntropy* const bit_entropy,
168                                         VP8LStreaks* const stats) {
169    int i;
170    int i_prev = 0;
171    uint32_t x_prev = X[0];
172    memset(stats, 0, sizeof(*stats));
173    VP8LBitEntropyInit(bit_entropy);
174    for (i = 1; i &lt; length; ++i) {
175      const uint32_t x = X[i];
176      if (x != x_prev) {
177        GetEntropyUnrefinedHelper(x, i, &amp;x_prev, &amp;i_prev, bit_entropy, stats);
178      }
179    }
180    GetEntropyUnrefinedHelper(0, i, &amp;x_prev, &amp;i_prev, bit_entropy, stats);
181    bit_entropy-&gt;entropy += VP8LFastSLog2(bit_entropy-&gt;sum);
182  }
183  static void GetCombinedEntropyUnrefined_MIPS32(const uint32_t X[],
184                                                 const uint32_t Y[],
185                                                 int length,
186                                                 VP8LBitEntropy* const entropy,
187                                                 VP8LStreaks* const stats) {
188    int i = 1;
189    int i_prev = 0;
190    uint32_t xy_prev = X[0] + Y[0];
191    memset(stats, 0, sizeof(*stats));
192    VP8LBitEntropyInit(entropy);
193    for (i = 1; i &lt; length; ++i) {
194      const uint32_t xy = X[i] + Y[i];
195      if (xy != xy_prev) {
196        GetEntropyUnrefinedHelper(xy, i, &amp;xy_prev, &amp;i_prev, entropy, stats);
197      }
198    }
199    GetEntropyUnrefinedHelper(0, i, &amp;xy_prev, &amp;i_prev, entropy, stats);
200    entropy-&gt;entropy += VP8LFastSLog2(entropy-&gt;sum);
201  }
202  #define ASM_START                                       \
203    __asm__ volatile(                                     \
204      &quot;.set   push                            \n\t&quot;       \
205      &quot;.set   at                              \n\t&quot;       \
206      &quot;.set   macro                           \n\t&quot;       \
207    &quot;1:                                       \n\t&quot;
208  #define ADD_TO_OUT(A, B, C, D, E, P0, P1, P2)           \
209      &quot;ulw    %[temp0], &quot; #A &quot;(%[&quot; #P0 &quot;])    \n\t&quot;       \
210      &quot;ulw    %[temp1], &quot; #B &quot;(%[&quot; #P0 &quot;])    \n\t&quot;       \
211      &quot;ulw    %[temp2], &quot; #C &quot;(%[&quot; #P0 &quot;])    \n\t&quot;       \
212      &quot;ulw    %[temp3], &quot; #D &quot;(%[&quot; #P0 &quot;])    \n\t&quot;       \
213      &quot;ulw    %[temp4], &quot; #A &quot;(%[&quot; #P1 &quot;])    \n\t&quot;       \
214      &quot;ulw    %[temp5], &quot; #B &quot;(%[&quot; #P1 &quot;])    \n\t&quot;       \
215      &quot;ulw    %[temp6], &quot; #C &quot;(%[&quot; #P1 &quot;])    \n\t&quot;       \
216      &quot;ulw    %[temp7], &quot; #D &quot;(%[&quot; #P1 &quot;])    \n\t&quot;       \
217      &quot;addu   %[temp4], %[temp4],   %[temp0]  \n\t&quot;       \
218      &quot;addu   %[temp5], %[temp5],   %[temp1]  \n\t&quot;       \
219      &quot;addu   %[temp6], %[temp6],   %[temp2]  \n\t&quot;       \
220      &quot;addu   %[temp7], %[temp7],   %[temp3]  \n\t&quot;       \
221      &quot;addiu  %[&quot; #P0 &quot;],  %[&quot; #P0 &quot;],  16    \n\t&quot;       \
222    &quot;.if &quot; #E &quot; == 1                          \n\t&quot;       \
223      &quot;addiu  %[&quot; #P1 &quot;],  %[&quot; #P1 &quot;],  16    \n\t&quot;       \
224    &quot;.endif                                   \n\t&quot;       \
225      &quot;usw    %[temp4], &quot; #A &quot;(%[&quot; #P2 &quot;])    \n\t&quot;       \
226      &quot;usw    %[temp5], &quot; #B &quot;(%[&quot; #P2 &quot;])    \n\t&quot;       \
227      &quot;usw    %[temp6], &quot; #C &quot;(%[&quot; #P2 &quot;])    \n\t&quot;       \
228      &quot;usw    %[temp7], &quot; #D &quot;(%[&quot; #P2 &quot;])    \n\t&quot;       \
<span onclick='openModal()' class='match'>229      &quot;addiu  %[&quot; #P2 &quot;], %[&quot; #P2 &quot;],   16    \n\t&quot;       \
230      &quot;bne    %[&quot; #P0 &quot;], %[LoopEnd], 1b      \n\t&quot;       \
231      &quot;.set   pop                             \n\t&quot;       \
232  
233  #define ASM_END_COMMON_0                                \
</span>234      : [temp0]&quot;=&amp;r&quot;(temp0), [temp1]&quot;=&amp;r&quot;(temp1),         \
235        [temp2]&quot;=&amp;r&quot;(temp2), [temp3]&quot;=&amp;r&quot;(temp3),         \
236        [temp4]&quot;=&amp;r&quot;(temp4), [temp5]&quot;=&amp;r&quot;(temp5),         \
237        [temp6]&quot;=&amp;r&quot;(temp6), [temp7]&quot;=&amp;r&quot;(temp7),         \
238        [pa]&quot;+r&quot;(pa), [pout]&quot;+r&quot;(pout)
239  #define ASM_END_COMMON_1                                \
240      : [LoopEnd]&quot;r&quot;(LoopEnd)                             \
241      : &quot;memory&quot;, &quot;at&quot;                                    \
242    );
243  #define ASM_END_0                                       \
244      ASM_END_COMMON_0                                    \
245        , [pb]&quot;+r&quot;(pb)                                    \
246      ASM_END_COMMON_1
247  #define ASM_END_1                                       \
248      ASM_END_COMMON_0                                    \
249      ASM_END_COMMON_1
250  static void AddVector_MIPS32(const uint32_t* pa, const uint32_t* pb,
251                               uint32_t* pout, int size) {
252    uint32_t temp0, temp1, temp2, temp3, temp4, temp5, temp6, temp7;
253    const uint32_t end = ((size) / 4) * 4;
254    const uint32_t* const LoopEnd = pa + end;
255    int i;
256    ASM_START
257    ADD_TO_OUT(0, 4, 8, 12, 1, pa, pb, pout)
258    ASM_END_0
259    for (i = end; i &lt; size; ++i) pout[i] = pa[i] + pb[i];
260  }
261  static void AddVectorEq_MIPS32(const uint32_t* pa, uint32_t* pout, int size) {
262    uint32_t temp0, temp1, temp2, temp3, temp4, temp5, temp6, temp7;
263    const uint32_t end = ((size) / 4) * 4;
264    const uint32_t* const LoopEnd = pa + end;
265    int i;
266    ASM_START
267    ADD_TO_OUT(0, 4, 8, 12, 0, pa, pout, pout)
268    ASM_END_1
269    for (i = end; i &lt; size; ++i) pout[i] += pa[i];
270  }
271  #undef ASM_END_1
272  #undef ASM_END_0
273  #undef ASM_END_COMMON_1
274  #undef ASM_END_COMMON_0
275  #undef ADD_TO_OUT
276  #undef ASM_START
277  extern void VP8LEncDspInitMIPS32(void);
278  WEBP_TSAN_IGNORE_FUNCTION void VP8LEncDspInitMIPS32(void) {
279    VP8LFastSLog2Slow = FastSLog2Slow_MIPS32;
280    VP8LFastLog2Slow = FastLog2Slow_MIPS32;
281    VP8LExtraCost = ExtraCost_MIPS32;
282    VP8LExtraCostCombined = ExtraCostCombined_MIPS32;
283    VP8LGetEntropyUnrefined = GetEntropyUnrefined_MIPS32;
284    VP8LGetCombinedEntropyUnrefined = GetCombinedEntropyUnrefined_MIPS32;
285    VP8LAddVector = AddVector_MIPS32;
286    VP8LAddVectorEq = AddVectorEq_MIPS32;
287  }
288  #else  
289  WEBP_DSP_INIT_STUB(VP8LEncDspInitMIPS32)
290  #endif  
</code></pre>
        </div>
        <div class="column">
            <h3>PINRemoteImage-MDEwOlJlcG9zaXRvcnkzOTUzNzEwMw==-flat-enc_mips32.c</h3>
            <pre><code>1  #include &quot;src/dsp/dsp.h&quot;
2  #if defined(WEBP_USE_MIPS32)
3  #include &quot;src/dsp/mips_macro.h&quot;
4  #include &quot;src/enc/vp8i_enc.h&quot;
5  #include &quot;src/enc/cost_enc.h&quot;
6  static const int kC1 = 20091 + (1 &lt;&lt; 16);
7  static const int kC2 = 35468;
8  #define VERTICAL_PASS(A, B, C, D, TEMP4, TEMP0, TEMP1, TEMP2, TEMP3)        \
9    &quot;lh      %[temp16],      &quot; #A &quot;(%[temp20])                 \n\t&quot;          \
10    &quot;lh      %[temp18],      &quot; #B &quot;(%[temp20])                 \n\t&quot;          \
11    &quot;lh      %[temp17],      &quot; #C &quot;(%[temp20])                 \n\t&quot;          \
12    &quot;lh      %[temp19],      &quot; #D &quot;(%[temp20])                 \n\t&quot;          \
13    &quot;addu    %[&quot; #TEMP4 &quot;],    %[temp16],      %[temp18]       \n\t&quot;          \
14    &quot;subu    %[temp16],      %[temp16],      %[temp18]         \n\t&quot;          \
15    &quot;mul     %[&quot; #TEMP0 &quot;],    %[temp17],      %[kC2]          \n\t&quot;          \
16    &quot;mul     %[temp18],      %[temp19],      %[kC1]            \n\t&quot;          \
17    &quot;mul     %[temp17],      %[temp17],      %[kC1]            \n\t&quot;          \
18    &quot;mul     %[temp19],      %[temp19],      %[kC2]            \n\t&quot;          \
19    &quot;sra     %[&quot; #TEMP0 &quot;],    %[&quot; #TEMP0 &quot;],    16            \n\n&quot;          \
20    &quot;sra     %[temp18],      %[temp18],      16                \n\n&quot;          \
21    &quot;sra     %[temp17],      %[temp17],      16                \n\n&quot;          \
22    &quot;sra     %[temp19],      %[temp19],      16                \n\n&quot;          \
23    &quot;subu    %[&quot; #TEMP2 &quot;],    %[&quot; #TEMP0 &quot;],    %[temp18]     \n\t&quot;          \
24    &quot;addu    %[&quot; #TEMP3 &quot;],    %[temp17],      %[temp19]       \n\t&quot;          \
25    &quot;addu    %[&quot; #TEMP0 &quot;],    %[&quot; #TEMP4 &quot;],    %[&quot; #TEMP3 &quot;] \n\t&quot;          \
26    &quot;addu    %[&quot; #TEMP1 &quot;],    %[temp16],      %[&quot; #TEMP2 &quot;]   \n\t&quot;          \
27    &quot;subu    %[&quot; #TEMP2 &quot;],    %[temp16],      %[&quot; #TEMP2 &quot;]   \n\t&quot;          \
28    &quot;subu    %[&quot; #TEMP3 &quot;],    %[&quot; #TEMP4 &quot;],    %[&quot; #TEMP3 &quot;] \n\t&quot;
29  #define HORIZONTAL_PASS(A, TEMP0, TEMP4, TEMP8, TEMP12)                       \
30    &quot;addiu   %[&quot; #TEMP0 &quot;],    %[&quot; #TEMP0 &quot;],    4               \n\t&quot;          \
31    &quot;addu    %[temp16],      %[&quot; #TEMP0 &quot;],    %[&quot; #TEMP8 &quot;]     \n\t&quot;          \
32    &quot;subu    %[temp17],      %[&quot; #TEMP0 &quot;],    %[&quot; #TEMP8 &quot;]     \n\t&quot;          \
33    &quot;mul     %[&quot; #TEMP0 &quot;],    %[&quot; #TEMP4 &quot;],    %[kC2]          \n\t&quot;          \
34    &quot;mul     %[&quot; #TEMP8 &quot;],    %[&quot; #TEMP12 &quot;],   %[kC1]          \n\t&quot;          \
35    &quot;mul     %[&quot; #TEMP4 &quot;],    %[&quot; #TEMP4 &quot;],    %[kC1]          \n\t&quot;          \
36    &quot;mul     %[&quot; #TEMP12 &quot;],   %[&quot; #TEMP12 &quot;],   %[kC2]          \n\t&quot;          \
37    &quot;sra     %[&quot; #TEMP0 &quot;],    %[&quot; #TEMP0 &quot;],    16              \n\t&quot;          \
38    &quot;sra     %[&quot; #TEMP8 &quot;],    %[&quot; #TEMP8 &quot;],    16              \n\t&quot;          \
39    &quot;sra     %[&quot; #TEMP4 &quot;],    %[&quot; #TEMP4 &quot;],    16              \n\t&quot;          \
40    &quot;sra     %[&quot; #TEMP12 &quot;],   %[&quot; #TEMP12 &quot;],   16              \n\t&quot;          \
41    &quot;subu    %[temp18],      %[&quot; #TEMP0 &quot;],    %[&quot; #TEMP8 &quot;]     \n\t&quot;          \
42    &quot;addu    %[temp19],      %[&quot; #TEMP4 &quot;],    %[&quot; #TEMP12 &quot;]    \n\t&quot;          \
43    &quot;addu    %[&quot; #TEMP0 &quot;],    %[temp16],      %[temp19]         \n\t&quot;          \
44    &quot;addu    %[&quot; #TEMP4 &quot;],    %[temp17],      %[temp18]         \n\t&quot;          \
45    &quot;subu    %[&quot; #TEMP8 &quot;],    %[temp17],      %[temp18]         \n\t&quot;          \
46    &quot;subu    %[&quot; #TEMP12 &quot;],   %[temp16],      %[temp19]         \n\t&quot;          \
47    &quot;lw      %[temp20],      0(%[args])                          \n\t&quot;          \
48    &quot;sra     %[&quot; #TEMP0 &quot;],    %[&quot; #TEMP0 &quot;],    3               \n\t&quot;          \
49    &quot;sra     %[&quot; #TEMP4 &quot;],    %[&quot; #TEMP4 &quot;],    3               \n\t&quot;          \
50    &quot;sra     %[&quot; #TEMP8 &quot;],    %[&quot; #TEMP8 &quot;],    3               \n\t&quot;          \
51    &quot;sra     %[&quot; #TEMP12 &quot;],   %[&quot; #TEMP12 &quot;],   3               \n\t&quot;          \
52    &quot;lbu     %[temp16],      0+&quot; XSTR(BPS) &quot;*&quot; #A &quot;(%[temp20])   \n\t&quot;          \
53    &quot;lbu     %[temp17],      1+&quot; XSTR(BPS) &quot;*&quot; #A &quot;(%[temp20])   \n\t&quot;          \
54    &quot;lbu     %[temp18],      2+&quot; XSTR(BPS) &quot;*&quot; #A &quot;(%[temp20])   \n\t&quot;          \
55    &quot;lbu     %[temp19],      3+&quot; XSTR(BPS) &quot;*&quot; #A &quot;(%[temp20])   \n\t&quot;          \
56    &quot;addu    %[&quot; #TEMP0 &quot;],    %[temp16],      %[&quot; #TEMP0 &quot;]     \n\t&quot;          \
57    &quot;addu    %[&quot; #TEMP4 &quot;],    %[temp17],      %[&quot; #TEMP4 &quot;]     \n\t&quot;          \
58    &quot;addu    %[&quot; #TEMP8 &quot;],    %[temp18],      %[&quot; #TEMP8 &quot;]     \n\t&quot;          \
59    &quot;addu    %[&quot; #TEMP12 &quot;],   %[temp19],      %[&quot; #TEMP12 &quot;]    \n\t&quot;          \
60    &quot;slt     %[temp16],      %[&quot; #TEMP0 &quot;],    $zero             \n\t&quot;          \
61    &quot;slt     %[temp17],      %[&quot; #TEMP4 &quot;],    $zero             \n\t&quot;          \
62    &quot;slt     %[temp18],      %[&quot; #TEMP8 &quot;],    $zero             \n\t&quot;          \
63    &quot;slt     %[temp19],      %[&quot; #TEMP12 &quot;],   $zero             \n\t&quot;          \
64    &quot;movn    %[&quot; #TEMP0 &quot;],    $zero,          %[temp16]         \n\t&quot;          \
65    &quot;movn    %[&quot; #TEMP4 &quot;],    $zero,          %[temp17]         \n\t&quot;          \
66    &quot;movn    %[&quot; #TEMP8 &quot;],    $zero,          %[temp18]         \n\t&quot;          \
67    &quot;movn    %[&quot; #TEMP12 &quot;],   $zero,          %[temp19]         \n\t&quot;          \
68    &quot;addiu   %[temp20],      $zero,          255                 \n\t&quot;          \
69    &quot;slt     %[temp16],      %[&quot; #TEMP0 &quot;],    %[temp20]         \n\t&quot;          \
70    &quot;slt     %[temp17],      %[&quot; #TEMP4 &quot;],    %[temp20]         \n\t&quot;          \
71    &quot;slt     %[temp18],      %[&quot; #TEMP8 &quot;],    %[temp20]         \n\t&quot;          \
72    &quot;slt     %[temp19],      %[&quot; #TEMP12 &quot;],   %[temp20]         \n\t&quot;          \
73    &quot;movz    %[&quot; #TEMP0 &quot;],    %[temp20],      %[temp16]         \n\t&quot;          \
74    &quot;movz    %[&quot; #TEMP4 &quot;],    %[temp20],      %[temp17]         \n\t&quot;          \
75    &quot;lw      %[temp16],      8(%[args])                          \n\t&quot;          \
76    &quot;movz    %[&quot; #TEMP8 &quot;],    %[temp20],      %[temp18]         \n\t&quot;          \
77    &quot;movz    %[&quot; #TEMP12 &quot;],   %[temp20],      %[temp19]         \n\t&quot;          \
78    &quot;sb      %[&quot; #TEMP0 &quot;],    0+&quot; XSTR(BPS) &quot;*&quot; #A &quot;(%[temp16]) \n\t&quot;          \
79    &quot;sb      %[&quot; #TEMP4 &quot;],    1+&quot; XSTR(BPS) &quot;*&quot; #A &quot;(%[temp16]) \n\t&quot;          \
80    &quot;sb      %[&quot; #TEMP8 &quot;],    2+&quot; XSTR(BPS) &quot;*&quot; #A &quot;(%[temp16]) \n\t&quot;          \
81    &quot;sb      %[&quot; #TEMP12 &quot;],   3+&quot; XSTR(BPS) &quot;*&quot; #A &quot;(%[temp16]) \n\t&quot;
82  static WEBP_INLINE void ITransformOne_MIPS32(const uint8_t* ref,
83                                               const int16_t* in,
84                                               uint8_t* dst) {
85    int temp0, temp1, temp2, temp3, temp4, temp5, temp6;
86    int temp7, temp8, temp9, temp10, temp11, temp12, temp13;
87    int temp14, temp15, temp16, temp17, temp18, temp19, temp20;
88    const int* args[3] = {(const int*)ref, (const int*)in, (const int*)dst};
89    __asm__ volatile(
90      &quot;lw      %[temp20],      4(%[args])                      \n\t&quot;
91      VERTICAL_PASS(0, 16,  8, 24, temp4,  temp0,  temp1,  temp2,  temp3)
92      VERTICAL_PASS(2, 18, 10, 26, temp8,  temp4,  temp5,  temp6,  temp7)
93      VERTICAL_PASS(4, 20, 12, 28, temp12, temp8,  temp9,  temp10, temp11)
94      VERTICAL_PASS(6, 22, 14, 30, temp20, temp12, temp13, temp14, temp15)
95      HORIZONTAL_PASS(0, temp0, temp4, temp8,  temp12)
96      HORIZONTAL_PASS(1, temp1, temp5, temp9,  temp13)
97      HORIZONTAL_PASS(2, temp2, temp6, temp10, temp14)
98      HORIZONTAL_PASS(3, temp3, temp7, temp11, temp15)
99      : [temp0]&quot;=&amp;r&quot;(temp0), [temp1]&quot;=&amp;r&quot;(temp1), [temp2]&quot;=&amp;r&quot;(temp2),
100        [temp3]&quot;=&amp;r&quot;(temp3), [temp4]&quot;=&amp;r&quot;(temp4), [temp5]&quot;=&amp;r&quot;(temp5),
101        [temp6]&quot;=&amp;r&quot;(temp6), [temp7]&quot;=&amp;r&quot;(temp7), [temp8]&quot;=&amp;r&quot;(temp8),
102        [temp9]&quot;=&amp;r&quot;(temp9), [temp10]&quot;=&amp;r&quot;(temp10), [temp11]&quot;=&amp;r&quot;(temp11),
103        [temp12]&quot;=&amp;r&quot;(temp12), [temp13]&quot;=&amp;r&quot;(temp13), [temp14]&quot;=&amp;r&quot;(temp14),
104        [temp15]&quot;=&amp;r&quot;(temp15), [temp16]&quot;=&amp;r&quot;(temp16), [temp17]&quot;=&amp;r&quot;(temp17),
105        [temp18]&quot;=&amp;r&quot;(temp18), [temp19]&quot;=&amp;r&quot;(temp19), [temp20]&quot;=&amp;r&quot;(temp20)
106      : [args]&quot;r&quot;(args), [kC1]&quot;r&quot;(kC1), [kC2]&quot;r&quot;(kC2)
107      : &quot;memory&quot;, &quot;hi&quot;, &quot;lo&quot;
108    );
109  }
110  static void ITransform_MIPS32(const uint8_t* ref, const int16_t* in,
111                                uint8_t* dst, int do_two) {
112    ITransformOne_MIPS32(ref, in, dst);
113    if (do_two) {
114      ITransformOne_MIPS32(ref + 4, in + 16, dst + 4);
115    }
116  }
117  #undef VERTICAL_PASS
118  #undef HORIZONTAL_PASS
119  #define QUANTIZE_ONE(J, K, N)                                               \
120    &quot;lh           %[temp0],       &quot; #J &quot;(%[ppin])                     \n\t&quot;   \
121    &quot;lhu          %[temp1],       &quot; #J &quot;(%[ppsharpen])                \n\t&quot;   \
122    &quot;lw           %[temp2],       &quot; #K &quot;(%[ppzthresh])                \n\t&quot;   \
123    &quot;sra          %[sign],        %[temp0],           15              \n\t&quot;   \
124    &quot;xor          %[coeff],       %[temp0],           %[sign]         \n\t&quot;   \
125    &quot;subu         %[coeff],       %[coeff],           %[sign]         \n\t&quot;   \
126    &quot;addu         %[coeff],       %[coeff],           %[temp1]        \n\t&quot;   \
127    &quot;slt          %[temp4],       %[temp2],           %[coeff]        \n\t&quot;   \
128    &quot;addiu        %[temp5],       $zero,              0               \n\t&quot;   \
129    &quot;addiu        %[level],       $zero,              0               \n\t&quot;   \
130    &quot;beqz         %[temp4],       2f                                  \n\t&quot;   \
131    &quot;lhu          %[temp1],       &quot; #J &quot;(%[ppiq])                     \n\t&quot;   \
132    &quot;lw           %[temp2],       &quot; #K &quot;(%[ppbias])                   \n\t&quot;   \
133    &quot;lhu          %[temp3],       &quot; #J &quot;(%[ppq])                      \n\t&quot;   \
134    &quot;mul          %[level],       %[coeff],           %[temp1]        \n\t&quot;   \
135    &quot;addu         %[level],       %[level],           %[temp2]        \n\t&quot;   \
136    &quot;sra          %[level],       %[level],           17              \n\t&quot;   \
137    &quot;slt          %[temp4],       %[max_level],       %[level]        \n\t&quot;   \
138    &quot;movn         %[level],       %[max_level],       %[temp4]        \n\t&quot;   \
139    &quot;xor          %[level],       %[level],           %[sign]         \n\t&quot;   \
140    &quot;subu         %[level],       %[level],           %[sign]         \n\t&quot;   \
141    &quot;mul          %[temp5],       %[level],           %[temp3]        \n\t&quot;   \
142  &quot;2:                                                                 \n\t&quot;   \
143    &quot;sh           %[temp5],       &quot; #J &quot;(%[ppin])                     \n\t&quot;   \
144    &quot;sh           %[level],       &quot; #N &quot;(%[pout])                     \n\t&quot;
145  static int QuantizeBlock_MIPS32(int16_t in[16], int16_t out[16],
146                                  const VP8Matrix* const mtx) {
147    int temp0, temp1, temp2, temp3, temp4, temp5;
148    int sign, coeff, level, i;
149    int max_level = MAX_LEVEL;
150    int16_t* ppin             = &amp;in[0];
151    int16_t* pout             = &amp;out[0];
152    const uint16_t* ppsharpen = &amp;mtx-&gt;sharpen_[0];
153    const uint32_t* ppzthresh = &amp;mtx-&gt;zthresh_[0];
154    const uint16_t* ppq       = &amp;mtx-&gt;q_[0];
155    const uint16_t* ppiq      = &amp;mtx-&gt;iq_[0];
156    const uint32_t* ppbias    = &amp;mtx-&gt;bias_[0];
157    __asm__ volatile(
158      QUANTIZE_ONE( 0,  0,  0)
159      QUANTIZE_ONE( 2,  4,  2)
160      QUANTIZE_ONE( 8, 16,  4)
161      QUANTIZE_ONE(16, 32,  6)
162      QUANTIZE_ONE(10, 20,  8)
163      QUANTIZE_ONE( 4,  8, 10)
164      QUANTIZE_ONE( 6, 12, 12)
165      QUANTIZE_ONE(12, 24, 14)
166      QUANTIZE_ONE(18, 36, 16)
167      QUANTIZE_ONE(24, 48, 18)
168      QUANTIZE_ONE(26, 52, 20)
169      QUANTIZE_ONE(20, 40, 22)
170      QUANTIZE_ONE(14, 28, 24)
171      QUANTIZE_ONE(22, 44, 26)
172      QUANTIZE_ONE(28, 56, 28)
173      QUANTIZE_ONE(30, 60, 30)
174      : [temp0]&quot;=&amp;r&quot;(temp0), [temp1]&quot;=&amp;r&quot;(temp1),
175        [temp2]&quot;=&amp;r&quot;(temp2), [temp3]&quot;=&amp;r&quot;(temp3),
176        [temp4]&quot;=&amp;r&quot;(temp4), [temp5]&quot;=&amp;r&quot;(temp5),
177        [sign]&quot;=&amp;r&quot;(sign), [coeff]&quot;=&amp;r&quot;(coeff),
178        [level]&quot;=&amp;r&quot;(level)
179      : [pout]&quot;r&quot;(pout), [ppin]&quot;r&quot;(ppin),
180        [ppiq]&quot;r&quot;(ppiq), [max_level]&quot;r&quot;(max_level),
181        [ppbias]&quot;r&quot;(ppbias), [ppzthresh]&quot;r&quot;(ppzthresh),
182        [ppsharpen]&quot;r&quot;(ppsharpen), [ppq]&quot;r&quot;(ppq)
183      : &quot;memory&quot;, &quot;hi&quot;, &quot;lo&quot;
184    );
185    for (i = 15; i &gt;= 0; i--) {
186      if (out[i]) return 1;
187    }
188    return 0;
189  }
190  static int Quantize2Blocks_MIPS32(int16_t in[32], int16_t out[32],
191                                    const VP8Matrix* const mtx) {
192    int nz;
193    nz  = QuantizeBlock_MIPS32(in + 0 * 16, out + 0 * 16, mtx) &lt;&lt; 0;
194    nz |= QuantizeBlock_MIPS32(in + 1 * 16, out + 1 * 16, mtx) &lt;&lt; 1;
195    return nz;
196  }
197  #undef QUANTIZE_ONE
198  #define HORIZONTAL_PASS(A, E, F, G, H, E1, F1, G1, H1)                  \
199    &quot;lbu    %[temp0],  0+&quot; XSTR(BPS) &quot;*&quot; #A &quot;(%[a])  \n\t&quot;                \
200    &quot;lbu    %[temp1],  1+&quot; XSTR(BPS) &quot;*&quot; #A &quot;(%[a])  \n\t&quot;                \
201    &quot;lbu    %[temp2],  2+&quot; XSTR(BPS) &quot;*&quot; #A &quot;(%[a])  \n\t&quot;                \
202    &quot;lbu    %[temp3],  3+&quot; XSTR(BPS) &quot;*&quot; #A &quot;(%[a])  \n\t&quot;                \
203    &quot;lbu    %[temp4],  0+&quot; XSTR(BPS) &quot;*&quot; #A &quot;(%[b])  \n\t&quot;                \
204    &quot;lbu    %[temp5],  1+&quot; XSTR(BPS) &quot;*&quot; #A &quot;(%[b])  \n\t&quot;                \
205    &quot;lbu    %[temp6],  2+&quot; XSTR(BPS) &quot;*&quot; #A &quot;(%[b])  \n\t&quot;                \
206    &quot;lbu    %[temp7],  3+&quot; XSTR(BPS) &quot;*&quot; #A &quot;(%[b])  \n\t&quot;                \
207    &quot;addu   %[temp8],  %[temp0],    %[temp2]         \n\t&quot;                \
208    &quot;subu   %[temp0],  %[temp0],    %[temp2]         \n\t&quot;                \
209    &quot;addu   %[temp2],  %[temp1],    %[temp3]         \n\t&quot;                \
210    &quot;subu   %[temp1],  %[temp1],    %[temp3]         \n\t&quot;                \
211    &quot;addu   %[temp3],  %[temp4],    %[temp6]         \n\t&quot;                \
212    &quot;subu   %[temp4],  %[temp4],    %[temp6]         \n\t&quot;                \
213    &quot;addu   %[temp6],  %[temp5],    %[temp7]         \n\t&quot;                \
214    &quot;subu   %[temp5],  %[temp5],    %[temp7]         \n\t&quot;                \
215    &quot;addu   %[temp7],  %[temp8],    %[temp2]         \n\t&quot;                \
216    &quot;subu   %[temp2],  %[temp8],    %[temp2]         \n\t&quot;                \
217    &quot;addu   %[temp8],  %[temp0],    %[temp1]         \n\t&quot;                \
218    &quot;subu   %[temp0],  %[temp0],    %[temp1]         \n\t&quot;                \
219    &quot;addu   %[temp1],  %[temp3],    %[temp6]         \n\t&quot;                \
220    &quot;subu   %[temp3],  %[temp3],    %[temp6]         \n\t&quot;                \
221    &quot;addu   %[temp6],  %[temp4],    %[temp5]         \n\t&quot;                \
222    &quot;subu   %[temp4],  %[temp4],    %[temp5]         \n\t&quot;                \
223    &quot;sw     %[temp7],  &quot; #E &quot;(%[tmp])                \n\t&quot;                \
224    &quot;sw     %[temp2],  &quot; #H &quot;(%[tmp])                \n\t&quot;                \
225    &quot;sw     %[temp8],  &quot; #F &quot;(%[tmp])                \n\t&quot;                \
226    &quot;sw     %[temp0],  &quot; #G &quot;(%[tmp])                \n\t&quot;                \
227    &quot;sw     %[temp1],  &quot; #E1 &quot;(%[tmp])               \n\t&quot;                \
228    &quot;sw     %[temp3],  &quot; #H1 &quot;(%[tmp])               \n\t&quot;                \
229    &quot;sw     %[temp6],  &quot; #F1 &quot;(%[tmp])               \n\t&quot;                \
230    &quot;sw     %[temp4],  &quot; #G1 &quot;(%[tmp])               \n\t&quot;
231  #define VERTICAL_PASS(A, B, C, D, A1, B1, C1, D1, E, F, G, H)     \
232    &quot;lw     %[temp0],  &quot; #A1 &quot;(%[tmp])         \n\t&quot;                \
233    &quot;lw     %[temp1],  &quot; #C1 &quot;(%[tmp])         \n\t&quot;                \
234    &quot;lw     %[temp2],  &quot; #B1 &quot;(%[tmp])         \n\t&quot;                \
235    &quot;lw     %[temp3],  &quot; #D1 &quot;(%[tmp])         \n\t&quot;                \
236    &quot;addu   %[temp8],  %[temp0],    %[temp1]   \n\t&quot;                \
237    &quot;subu   %[temp0],  %[temp0],    %[temp1]   \n\t&quot;                \
238    &quot;addu   %[temp1],  %[temp2],    %[temp3]   \n\t&quot;                \
239    &quot;subu   %[temp2],  %[temp2],    %[temp3]   \n\t&quot;                \
240    &quot;addu   %[temp3],  %[temp8],    %[temp1]   \n\t&quot;                \
241    &quot;subu   %[temp8],  %[temp8],    %[temp1]   \n\t&quot;                \
242    &quot;addu   %[temp1],  %[temp0],    %[temp2]   \n\t&quot;                \
243    &quot;subu   %[temp0],  %[temp0],    %[temp2]   \n\t&quot;                \
244    &quot;sra    %[temp4],  %[temp3],    31         \n\t&quot;                \
245    &quot;sra    %[temp5],  %[temp1],    31         \n\t&quot;                \
246    &quot;sra    %[temp6],  %[temp0],    31         \n\t&quot;                \
247    &quot;sra    %[temp7],  %[temp8],    31         \n\t&quot;                \
248    &quot;xor    %[temp3],  %[temp3],    %[temp4]   \n\t&quot;                \
249    &quot;xor    %[temp1],  %[temp1],    %[temp5]   \n\t&quot;                \
250    &quot;xor    %[temp0],  %[temp0],    %[temp6]   \n\t&quot;                \
251    &quot;xor    %[temp8],  %[temp8],    %[temp7]   \n\t&quot;                \
252    &quot;subu   %[temp3],  %[temp3],    %[temp4]   \n\t&quot;                \
253    &quot;subu   %[temp1],  %[temp1],    %[temp5]   \n\t&quot;                \
254    &quot;subu   %[temp0],  %[temp0],    %[temp6]   \n\t&quot;                \
255    &quot;subu   %[temp8],  %[temp8],    %[temp7]   \n\t&quot;                \
256    &quot;lhu    %[temp4],  &quot; #E &quot;(%[w])            \n\t&quot;                \
257    &quot;lhu    %[temp5],  &quot; #F &quot;(%[w])            \n\t&quot;                \
258    &quot;lhu    %[temp6],  &quot; #G &quot;(%[w])            \n\t&quot;                \
259    &quot;lhu    %[temp7],  &quot; #H &quot;(%[w])            \n\t&quot;                \
260    &quot;madd   %[temp4],  %[temp3]                \n\t&quot;                \
261    &quot;madd   %[temp5],  %[temp1]                \n\t&quot;                \
262    &quot;madd   %[temp6],  %[temp0]                \n\t&quot;                \
263    &quot;madd   %[temp7],  %[temp8]                \n\t&quot;                \
264    &quot;lw     %[temp0],  &quot; #A &quot;(%[tmp])          \n\t&quot;                \
265    &quot;lw     %[temp1],  &quot; #C &quot;(%[tmp])          \n\t&quot;                \
266    &quot;lw     %[temp2],  &quot; #B &quot;(%[tmp])          \n\t&quot;                \
267    &quot;lw     %[temp3],  &quot; #D &quot;(%[tmp])          \n\t&quot;                \
268    &quot;addu   %[temp8],  %[temp0],    %[temp1]   \n\t&quot;                \
269    &quot;subu   %[temp0],  %[temp0],    %[temp1]   \n\t&quot;                \
270    &quot;addu   %[temp1],  %[temp2],    %[temp3]   \n\t&quot;                \
271    &quot;subu   %[temp2],  %[temp2],    %[temp3]   \n\t&quot;                \
272    &quot;addu   %[temp3],  %[temp8],    %[temp1]   \n\t&quot;                \
273    &quot;subu   %[temp1],  %[temp8],    %[temp1]   \n\t&quot;                \
274    &quot;addu   %[temp8],  %[temp0],    %[temp2]   \n\t&quot;                \
275    &quot;subu   %[temp0],  %[temp0],    %[temp2]   \n\t&quot;                \
276    &quot;sra    %[temp2],  %[temp3],    31         \n\t&quot;                \
277    &quot;xor    %[temp3],  %[temp3],    %[temp2]   \n\t&quot;                \
278    &quot;subu   %[temp3],  %[temp3],    %[temp2]   \n\t&quot;                \
279    &quot;msub   %[temp4],  %[temp3]                \n\t&quot;                \
280    &quot;sra    %[temp2],  %[temp8],    31         \n\t&quot;                \
281    &quot;sra    %[temp3],  %[temp0],    31         \n\t&quot;                \
282    &quot;sra    %[temp4],  %[temp1],    31         \n\t&quot;                \
283    &quot;xor    %[temp8],  %[temp8],    %[temp2]   \n\t&quot;                \
284    &quot;xor    %[temp0],  %[temp0],    %[temp3]   \n\t&quot;                \
285    &quot;xor    %[temp1],  %[temp1],    %[temp4]   \n\t&quot;                \
286    &quot;subu   %[temp8],  %[temp8],    %[temp2]   \n\t&quot;                \
287    &quot;subu   %[temp0],  %[temp0],    %[temp3]   \n\t&quot;                \
288    &quot;subu   %[temp1],  %[temp1],    %[temp4]   \n\t&quot;                \
289    &quot;msub   %[temp5],  %[temp8]                \n\t&quot;                \
290    &quot;msub   %[temp6],  %[temp0]                \n\t&quot;                \
291    &quot;msub   %[temp7],  %[temp1]                \n\t&quot;
292  static int Disto4x4_MIPS32(const uint8_t* const a, const uint8_t* const b,
293                             const uint16_t* const w) {
294    int tmp[32];
295    int temp0, temp1, temp2, temp3, temp4, temp5, temp6, temp7, temp8;
296    __asm__ volatile(
297      HORIZONTAL_PASS(0,   0,  4,  8, 12,    64,  68,  72,  76)
298      HORIZONTAL_PASS(1,  16, 20, 24, 28,    80,  84,  88,  92)
299      HORIZONTAL_PASS(2,  32, 36, 40, 44,    96, 100, 104, 108)
300      HORIZONTAL_PASS(3,  48, 52, 56, 60,   112, 116, 120, 124)
301      &quot;mthi   $zero                             \n\t&quot;
302      &quot;mtlo   $zero                             \n\t&quot;
303      VERTICAL_PASS( 0, 16, 32, 48,     64, 80,  96, 112,   0,  8, 16, 24)
304      VERTICAL_PASS( 4, 20, 36, 52,     68, 84, 100, 116,   2, 10, 18, 26)
305      VERTICAL_PASS( 8, 24, 40, 56,     72, 88, 104, 120,   4, 12, 20, 28)
306      VERTICAL_PASS(12, 28, 44, 60,     76, 92, 108, 124,   6, 14, 22, 30)
307      &quot;mflo   %[temp0]                          \n\t&quot;
308      &quot;sra    %[temp1],  %[temp0],  31          \n\t&quot;
309      &quot;xor    %[temp0],  %[temp0],  %[temp1]    \n\t&quot;
310      &quot;subu   %[temp0],  %[temp0],  %[temp1]    \n\t&quot;
311      &quot;sra    %[temp0],  %[temp0],  5           \n\t&quot;
312      : [temp0]&quot;=&amp;r&quot;(temp0), [temp1]&quot;=&amp;r&quot;(temp1), [temp2]&quot;=&amp;r&quot;(temp2),
313        [temp3]&quot;=&amp;r&quot;(temp3), [temp4]&quot;=&amp;r&quot;(temp4), [temp5]&quot;=&amp;r&quot;(temp5),
314        [temp6]&quot;=&amp;r&quot;(temp6), [temp7]&quot;=&amp;r&quot;(temp7), [temp8]&quot;=&amp;r&quot;(temp8)
315      : [a]&quot;r&quot;(a), [b]&quot;r&quot;(b), [w]&quot;r&quot;(w), [tmp]&quot;r&quot;(tmp)
316      : &quot;memory&quot;, &quot;hi&quot;, &quot;lo&quot;
317    );
318    return temp0;
319  }
320  #undef VERTICAL_PASS
321  #undef HORIZONTAL_PASS
322  static int Disto16x16_MIPS32(const uint8_t* const a, const uint8_t* const b,
323                               const uint16_t* const w) {
324    int D = 0;
325    int x, y;
326    for (y = 0; y &lt; 16 * BPS; y += 4 * BPS) {
327      for (x = 0; x &lt; 16; x += 4) {
328        D += Disto4x4_MIPS32(a + x + y, b + x + y, w);
329      }
330    }
331    return D;
332  }
333  #define HORIZONTAL_PASS(A, TEMP0, TEMP1, TEMP2, TEMP3)                  \
334    &quot;lw     %[&quot; #TEMP1 &quot;],  0(%[args])                           \n\t&quot;    \
335    &quot;lw     %[&quot; #TEMP2 &quot;],  4(%[args])                           \n\t&quot;    \
336    &quot;lbu    %[temp16],    0+&quot; XSTR(BPS) &quot;*&quot; #A &quot;(%[&quot; #TEMP1 &quot;])  \n\t&quot;    \
337    &quot;lbu    %[temp17],    0+&quot; XSTR(BPS) &quot;*&quot; #A &quot;(%[&quot; #TEMP2 &quot;])  \n\t&quot;    \
338    &quot;lbu    %[temp18],    1+&quot; XSTR(BPS) &quot;*&quot; #A &quot;(%[&quot; #TEMP1 &quot;])  \n\t&quot;    \
339    &quot;lbu    %[temp19],    1+&quot; XSTR(BPS) &quot;*&quot; #A &quot;(%[&quot; #TEMP2 &quot;])  \n\t&quot;    \
340    &quot;subu   %[temp20],    %[temp16],    %[temp17]                \n\t&quot;    \
341    &quot;lbu    %[temp16],    2+&quot; XSTR(BPS) &quot;*&quot; #A &quot;(%[&quot; #TEMP1 &quot;])  \n\t&quot;    \
342    &quot;lbu    %[temp17],    2+&quot; XSTR(BPS) &quot;*&quot; #A &quot;(%[&quot; #TEMP2 &quot;])  \n\t&quot;    \
343    &quot;subu   %[&quot; #TEMP0 &quot;],  %[temp18],    %[temp19]              \n\t&quot;    \
344    &quot;lbu    %[temp18],    3+&quot; XSTR(BPS) &quot;*&quot; #A &quot;(%[&quot; #TEMP1 &quot;])  \n\t&quot;    \
345    &quot;lbu    %[temp19],    3+&quot; XSTR(BPS) &quot;*&quot; #A &quot;(%[&quot; #TEMP2 &quot;])  \n\t&quot;    \
346    &quot;subu   %[&quot; #TEMP1 &quot;],  %[temp16],    %[temp17]              \n\t&quot;    \
347    &quot;subu   %[&quot; #TEMP2 &quot;],  %[temp18],    %[temp19]              \n\t&quot;    \
348    &quot;addu   %[&quot; #TEMP3 &quot;],  %[temp20],    %[&quot; #TEMP2 &quot;]          \n\t&quot;    \
349    &quot;subu   %[&quot; #TEMP2 &quot;],  %[temp20],    %[&quot; #TEMP2 &quot;]          \n\t&quot;    \
350    &quot;addu   %[temp20],    %[&quot; #TEMP0 &quot;],  %[&quot; #TEMP1 &quot;]          \n\t&quot;    \
351    &quot;subu   %[&quot; #TEMP0 &quot;],  %[&quot; #TEMP0 &quot;],  %[&quot; #TEMP1 &quot;]        \n\t&quot;    \
352    &quot;mul    %[temp16],    %[&quot; #TEMP2 &quot;],  %[c5352]               \n\t&quot;    \
353    &quot;mul    %[temp17],    %[&quot; #TEMP2 &quot;],  %[c2217]               \n\t&quot;    \
354    &quot;mul    %[temp18],    %[&quot; #TEMP0 &quot;],  %[c5352]               \n\t&quot;    \
355    &quot;mul    %[temp19],    %[&quot; #TEMP0 &quot;],  %[c2217]               \n\t&quot;    \
356    &quot;addu   %[&quot; #TEMP1 &quot;],  %[&quot; #TEMP3 &quot;],  %[temp20]            \n\t&quot;    \
357    &quot;subu   %[temp20],    %[&quot; #TEMP3 &quot;],  %[temp20]              \n\t&quot;    \
<span onclick='openModal()' class='match'>358    &quot;sll    %[&quot; #TEMP0 &quot;],  %[&quot; #TEMP1 &quot;],  3                    \n\t&quot;    \
359    &quot;sll    %[&quot; #TEMP2 &quot;],  %[temp20],    3                      \n\t&quot;    \
360    &quot;addiu  %[temp16],    %[temp16],    1812                     \n\t&quot;    \
361    &quot;addiu  %[temp17],    %[temp17],    937                      \n\t&quot;    \
</span>362    &quot;addu   %[temp16],    %[temp16],    %[temp19]                \n\t&quot;    \
363    &quot;subu   %[temp17],    %[temp17],    %[temp18]                \n\t&quot;    \
364    &quot;sra    %[&quot; #TEMP1 &quot;],  %[temp16],    9                      \n\t&quot;    \
365    &quot;sra    %[&quot; #TEMP3 &quot;],  %[temp17],    9                      \n\t&quot;
366  #define VERTICAL_PASS(A, B, C, D, TEMP0, TEMP4, TEMP8, TEMP12)    \
367    &quot;addu   %[temp16],    %[&quot; #TEMP0 &quot;],  %[&quot; #TEMP12 &quot;]   \n\t&quot;    \
368    &quot;subu   %[temp19],    %[&quot; #TEMP0 &quot;],  %[&quot; #TEMP12 &quot;]   \n\t&quot;    \
369    &quot;addu   %[temp17],    %[&quot; #TEMP4 &quot;],  %[&quot; #TEMP8 &quot;]    \n\t&quot;    \
370    &quot;subu   %[temp18],    %[&quot; #TEMP4 &quot;],  %[&quot; #TEMP8 &quot;]    \n\t&quot;    \
371    &quot;mul    %[&quot; #TEMP8 &quot;],  %[temp19],    %[c2217]         \n\t&quot;    \
372    &quot;mul    %[&quot; #TEMP12 &quot;], %[temp18],    %[c2217]         \n\t&quot;    \
373    &quot;mul    %[&quot; #TEMP4 &quot;],  %[temp19],    %[c5352]         \n\t&quot;    \
374    &quot;mul    %[temp18],    %[temp18],    %[c5352]           \n\t&quot;    \
375    &quot;addiu  %[temp16],    %[temp16],    7                  \n\t&quot;    \
376    &quot;addu   %[&quot; #TEMP0 &quot;],  %[temp16],    %[temp17]        \n\t&quot;    \
377    &quot;sra    %[&quot; #TEMP0 &quot;],  %[&quot; #TEMP0 &quot;],  4              \n\t&quot;    \
378    &quot;addu   %[&quot; #TEMP12 &quot;], %[&quot; #TEMP12 &quot;], %[&quot; #TEMP4 &quot;]  \n\t&quot;    \
379    &quot;subu   %[&quot; #TEMP4 &quot;],  %[temp16],    %[temp17]        \n\t&quot;    \
380    &quot;sra    %[&quot; #TEMP4 &quot;],  %[&quot; #TEMP4 &quot;],  4              \n\t&quot;    \
381    &quot;addiu  %[&quot; #TEMP8 &quot;],  %[&quot; #TEMP8 &quot;],  30000          \n\t&quot;    \
382    &quot;addiu  %[&quot; #TEMP12 &quot;], %[&quot; #TEMP12 &quot;], 12000          \n\t&quot;    \
383    &quot;addiu  %[&quot; #TEMP8 &quot;],  %[&quot; #TEMP8 &quot;],  21000          \n\t&quot;    \
384    &quot;subu   %[&quot; #TEMP8 &quot;],  %[&quot; #TEMP8 &quot;],  %[temp18]      \n\t&quot;    \
385    &quot;sra    %[&quot; #TEMP12 &quot;], %[&quot; #TEMP12 &quot;], 16             \n\t&quot;    \
386    &quot;sra    %[&quot; #TEMP8 &quot;],  %[&quot; #TEMP8 &quot;],  16             \n\t&quot;    \
387    &quot;addiu  %[temp16],    %[&quot; #TEMP12 &quot;], 1                \n\t&quot;    \
388    &quot;movn   %[&quot; #TEMP12 &quot;], %[temp16],    %[temp19]        \n\t&quot;    \
389    &quot;sh     %[&quot; #TEMP0 &quot;],  &quot; #A &quot;(%[temp20])              \n\t&quot;    \
390    &quot;sh     %[&quot; #TEMP4 &quot;],  &quot; #C &quot;(%[temp20])              \n\t&quot;    \
391    &quot;sh     %[&quot; #TEMP8 &quot;],  &quot; #D &quot;(%[temp20])              \n\t&quot;    \
392    &quot;sh     %[&quot; #TEMP12 &quot;], &quot; #B &quot;(%[temp20])              \n\t&quot;
393  static void FTransform_MIPS32(const uint8_t* src, const uint8_t* ref,
394                                int16_t* out) {
395    int temp0, temp1, temp2, temp3, temp4, temp5, temp6, temp7, temp8;
396    int temp9, temp10, temp11, temp12, temp13, temp14, temp15, temp16;
397    int temp17, temp18, temp19, temp20;
398    const int c2217 = 2217;
399    const int c5352 = 5352;
400    const int* const args[3] =
401        { (const int*)src, (const int*)ref, (const int*)out };
402    __asm__ volatile(
403      HORIZONTAL_PASS(0, temp0,  temp1,  temp2,  temp3)
404      HORIZONTAL_PASS(1, temp4,  temp5,  temp6,  temp7)
405      HORIZONTAL_PASS(2, temp8,  temp9,  temp10, temp11)
406      HORIZONTAL_PASS(3, temp12, temp13, temp14, temp15)
407      &quot;lw   %[temp20],    8(%[args])                     \n\t&quot;
408      VERTICAL_PASS(0,  8, 16, 24, temp0, temp4, temp8,  temp12)
409      VERTICAL_PASS(2, 10, 18, 26, temp1, temp5, temp9,  temp13)
410      VERTICAL_PASS(4, 12, 20, 28, temp2, temp6, temp10, temp14)
411      VERTICAL_PASS(6, 14, 22, 30, temp3, temp7, temp11, temp15)
412      : [temp0]&quot;=&amp;r&quot;(temp0), [temp1]&quot;=&amp;r&quot;(temp1), [temp2]&quot;=&amp;r&quot;(temp2),
413        [temp3]&quot;=&amp;r&quot;(temp3), [temp4]&quot;=&amp;r&quot;(temp4), [temp5]&quot;=&amp;r&quot;(temp5),
414        [temp6]&quot;=&amp;r&quot;(temp6), [temp7]&quot;=&amp;r&quot;(temp7), [temp8]&quot;=&amp;r&quot;(temp8),
415        [temp9]&quot;=&amp;r&quot;(temp9), [temp10]&quot;=&amp;r&quot;(temp10), [temp11]&quot;=&amp;r&quot;(temp11),
416        [temp12]&quot;=&amp;r&quot;(temp12), [temp13]&quot;=&amp;r&quot;(temp13), [temp14]&quot;=&amp;r&quot;(temp14),
417        [temp15]&quot;=&amp;r&quot;(temp15), [temp16]&quot;=&amp;r&quot;(temp16), [temp17]&quot;=&amp;r&quot;(temp17),
418        [temp18]&quot;=&amp;r&quot;(temp18), [temp19]&quot;=&amp;r&quot;(temp19), [temp20]&quot;=&amp;r&quot;(temp20)
419      : [args]&quot;r&quot;(args), [c2217]&quot;r&quot;(c2217), [c5352]&quot;r&quot;(c5352)
420      : &quot;memory&quot;, &quot;hi&quot;, &quot;lo&quot;
421    );
422  }
423  #undef VERTICAL_PASS
424  #undef HORIZONTAL_PASS
425  #if !defined(WORK_AROUND_GCC)
426  #define GET_SSE_INNER(A, B, C, D)                               \
427    &quot;lbu     %[temp0],    &quot; #A &quot;(%[a])                 \n\t&quot;      \
428    &quot;lbu     %[temp1],    &quot; #A &quot;(%[b])                 \n\t&quot;      \
429    &quot;lbu     %[temp2],    &quot; #B &quot;(%[a])                 \n\t&quot;      \
430    &quot;lbu     %[temp3],    &quot; #B &quot;(%[b])                 \n\t&quot;      \
431    &quot;lbu     %[temp4],    &quot; #C &quot;(%[a])                 \n\t&quot;      \
432    &quot;lbu     %[temp5],    &quot; #C &quot;(%[b])                 \n\t&quot;      \
433    &quot;lbu     %[temp6],    &quot; #D &quot;(%[a])                 \n\t&quot;      \
434    &quot;lbu     %[temp7],    &quot; #D &quot;(%[b])                 \n\t&quot;      \
435    &quot;subu    %[temp0],    %[temp0],     %[temp1]       \n\t&quot;      \
436    &quot;subu    %[temp2],    %[temp2],     %[temp3]       \n\t&quot;      \
437    &quot;subu    %[temp4],    %[temp4],     %[temp5]       \n\t&quot;      \
438    &quot;subu    %[temp6],    %[temp6],     %[temp7]       \n\t&quot;      \
439    &quot;madd    %[temp0],    %[temp0]                     \n\t&quot;      \
440    &quot;madd    %[temp2],    %[temp2]                     \n\t&quot;      \
441    &quot;madd    %[temp4],    %[temp4]                     \n\t&quot;      \
442    &quot;madd    %[temp6],    %[temp6]                     \n\t&quot;
443  #define GET_SSE(A, B, C, D)               \
444    GET_SSE_INNER(A, A + 1, A + 2, A + 3)   \
445    GET_SSE_INNER(B, B + 1, B + 2, B + 3)   \
446    GET_SSE_INNER(C, C + 1, C + 2, C + 3)   \
447    GET_SSE_INNER(D, D + 1, D + 2, D + 3)
448  static int SSE16x16_MIPS32(const uint8_t* a, const uint8_t* b) {
449    int count;
450    int temp0, temp1, temp2, temp3, temp4, temp5, temp6, temp7;
451    __asm__ volatile(
452       &quot;mult   $zero,    $zero                            \n\t&quot;
453       GET_SSE( 0 * BPS, 4 +  0 * BPS, 8 +  0 * BPS, 12 +  0 * BPS)
454       GET_SSE( 1 * BPS, 4 +  1 * BPS, 8 +  1 * BPS, 12 +  1 * BPS)
455       GET_SSE( 2 * BPS, 4 +  2 * BPS, 8 +  2 * BPS, 12 +  2 * BPS)
456       GET_SSE( 3 * BPS, 4 +  3 * BPS, 8 +  3 * BPS, 12 +  3 * BPS)
457       GET_SSE( 4 * BPS, 4 +  4 * BPS, 8 +  4 * BPS, 12 +  4 * BPS)
458       GET_SSE( 5 * BPS, 4 +  5 * BPS, 8 +  5 * BPS, 12 +  5 * BPS)
459       GET_SSE( 6 * BPS, 4 +  6 * BPS, 8 +  6 * BPS, 12 +  6 * BPS)
460       GET_SSE( 7 * BPS, 4 +  7 * BPS, 8 +  7 * BPS, 12 +  7 * BPS)
461       GET_SSE( 8 * BPS, 4 +  8 * BPS, 8 +  8 * BPS, 12 +  8 * BPS)
462       GET_SSE( 9 * BPS, 4 +  9 * BPS, 8 +  9 * BPS, 12 +  9 * BPS)
463       GET_SSE(10 * BPS, 4 + 10 * BPS, 8 + 10 * BPS, 12 + 10 * BPS)
464       GET_SSE(11 * BPS, 4 + 11 * BPS, 8 + 11 * BPS, 12 + 11 * BPS)
465       GET_SSE(12 * BPS, 4 + 12 * BPS, 8 + 12 * BPS, 12 + 12 * BPS)
466       GET_SSE(13 * BPS, 4 + 13 * BPS, 8 + 13 * BPS, 12 + 13 * BPS)
467       GET_SSE(14 * BPS, 4 + 14 * BPS, 8 + 14 * BPS, 12 + 14 * BPS)
468       GET_SSE(15 * BPS, 4 + 15 * BPS, 8 + 15 * BPS, 12 + 15 * BPS)
469      &quot;mflo    %[count]                                   \n\t&quot;
470      : [temp0]&quot;=&amp;r&quot;(temp0), [temp1]&quot;=&amp;r&quot;(temp1), [temp2]&quot;=&amp;r&quot;(temp2),
471        [temp3]&quot;=&amp;r&quot;(temp3), [temp4]&quot;=&amp;r&quot;(temp4), [temp5]&quot;=&amp;r&quot;(temp5),
472        [temp6]&quot;=&amp;r&quot;(temp6), [temp7]&quot;=&amp;r&quot;(temp7), [count]&quot;=&amp;r&quot;(count)
473      : [a]&quot;r&quot;(a), [b]&quot;r&quot;(b)
474      : &quot;memory&quot;, &quot;hi&quot;, &quot;lo&quot;
475    );
476    return count;
477  }
478  static int SSE16x8_MIPS32(const uint8_t* a, const uint8_t* b) {
479    int count;
480    int temp0, temp1, temp2, temp3, temp4, temp5, temp6, temp7;
481    __asm__ volatile(
482       &quot;mult   $zero,    $zero                            \n\t&quot;
483       GET_SSE( 0 * BPS, 4 +  0 * BPS, 8 +  0 * BPS, 12 +  0 * BPS)
484       GET_SSE( 1 * BPS, 4 +  1 * BPS, 8 +  1 * BPS, 12 +  1 * BPS)
485       GET_SSE( 2 * BPS, 4 +  2 * BPS, 8 +  2 * BPS, 12 +  2 * BPS)
486       GET_SSE( 3 * BPS, 4 +  3 * BPS, 8 +  3 * BPS, 12 +  3 * BPS)
487       GET_SSE( 4 * BPS, 4 +  4 * BPS, 8 +  4 * BPS, 12 +  4 * BPS)
488       GET_SSE( 5 * BPS, 4 +  5 * BPS, 8 +  5 * BPS, 12 +  5 * BPS)
489       GET_SSE( 6 * BPS, 4 +  6 * BPS, 8 +  6 * BPS, 12 +  6 * BPS)
490       GET_SSE( 7 * BPS, 4 +  7 * BPS, 8 +  7 * BPS, 12 +  7 * BPS)
491      &quot;mflo    %[count]                                   \n\t&quot;
492      : [temp0]&quot;=&amp;r&quot;(temp0), [temp1]&quot;=&amp;r&quot;(temp1), [temp2]&quot;=&amp;r&quot;(temp2),
493        [temp3]&quot;=&amp;r&quot;(temp3), [temp4]&quot;=&amp;r&quot;(temp4), [temp5]&quot;=&amp;r&quot;(temp5),
494        [temp6]&quot;=&amp;r&quot;(temp6), [temp7]&quot;=&amp;r&quot;(temp7), [count]&quot;=&amp;r&quot;(count)
495      : [a]&quot;r&quot;(a), [b]&quot;r&quot;(b)
496      : &quot;memory&quot;, &quot;hi&quot;, &quot;lo&quot;
497    );
498    return count;
499  }
500  static int SSE8x8_MIPS32(const uint8_t* a, const uint8_t* b) {
501    int count;
502    int temp0, temp1, temp2, temp3, temp4, temp5, temp6, temp7;
503    __asm__ volatile(
504       &quot;mult   $zero,    $zero                            \n\t&quot;
505       GET_SSE(0 * BPS, 4 + 0 * BPS, 1 * BPS, 4 + 1 * BPS)
506       GET_SSE(2 * BPS, 4 + 2 * BPS, 3 * BPS, 4 + 3 * BPS)
507       GET_SSE(4 * BPS, 4 + 4 * BPS, 5 * BPS, 4 + 5 * BPS)
508       GET_SSE(6 * BPS, 4 + 6 * BPS, 7 * BPS, 4 + 7 * BPS)
509      &quot;mflo    %[count]                                   \n\t&quot;
510      : [temp0]&quot;=&amp;r&quot;(temp0), [temp1]&quot;=&amp;r&quot;(temp1), [temp2]&quot;=&amp;r&quot;(temp2),
511        [temp3]&quot;=&amp;r&quot;(temp3), [temp4]&quot;=&amp;r&quot;(temp4), [temp5]&quot;=&amp;r&quot;(temp5),
512        [temp6]&quot;=&amp;r&quot;(temp6), [temp7]&quot;=&amp;r&quot;(temp7), [count]&quot;=&amp;r&quot;(count)
513      : [a]&quot;r&quot;(a), [b]&quot;r&quot;(b)
514      : &quot;memory&quot;, &quot;hi&quot;, &quot;lo&quot;
515    );
516    return count;
517  }
518  static int SSE4x4_MIPS32(const uint8_t* a, const uint8_t* b) {
519    int count;
520    int temp0, temp1, temp2, temp3, temp4, temp5, temp6, temp7;
521    __asm__ volatile(
522       &quot;mult   $zero,    $zero                            \n\t&quot;
523       GET_SSE(0 * BPS, 1 * BPS, 2 * BPS, 3 * BPS)
524      &quot;mflo    %[count]                                   \n\t&quot;
525      : [temp0]&quot;=&amp;r&quot;(temp0), [temp1]&quot;=&amp;r&quot;(temp1), [temp2]&quot;=&amp;r&quot;(temp2),
526        [temp3]&quot;=&amp;r&quot;(temp3), [temp4]&quot;=&amp;r&quot;(temp4), [temp5]&quot;=&amp;r&quot;(temp5),
527        [temp6]&quot;=&amp;r&quot;(temp6), [temp7]&quot;=&amp;r&quot;(temp7), [count]&quot;=&amp;r&quot;(count)
528      : [a]&quot;r&quot;(a), [b]&quot;r&quot;(b)
529      : &quot;memory&quot;, &quot;hi&quot;, &quot;lo&quot;
530    );
531    return count;
532  }
533  #undef GET_SSE
534  #undef GET_SSE_INNER
535  #endif  
536  extern void VP8EncDspInitMIPS32(void);
537  WEBP_TSAN_IGNORE_FUNCTION void VP8EncDspInitMIPS32(void) {
538    VP8ITransform = ITransform_MIPS32;
539    VP8FTransform = FTransform_MIPS32;
540    VP8EncQuantizeBlock = QuantizeBlock_MIPS32;
541    VP8EncQuantize2Blocks = Quantize2Blocks_MIPS32;
542    VP8TDisto4x4 = Disto4x4_MIPS32;
543    VP8TDisto16x16 = Disto16x16_MIPS32;
544  #if !defined(WORK_AROUND_GCC)
545    VP8SSE16x16 = SSE16x16_MIPS32;
546    VP8SSE8x8 = SSE8x8_MIPS32;
547    VP8SSE16x8 = SSE16x8_MIPS32;
548    VP8SSE4x4 = SSE4x4_MIPS32;
549  #endif
550  }
551  #else  
552  WEBP_DSP_INIT_STUB(VP8EncDspInitMIPS32)
553  #endif  
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from PINRemoteImage-MDEwOlJlcG9zaXRvcnkzOTUzNzEwMw==-flat-lossless_enc_mips32.c</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from PINRemoteImage-MDEwOlJlcG9zaXRvcnkzOTUzNzEwMw==-flat-enc_mips32.c</div>
                </div>
                <div class="column column_space"><pre><code>229      &quot;addiu  %[&quot; #P2 &quot;], %[&quot; #P2 &quot;],   16    \n\t&quot;       \
230      &quot;bne    %[&quot; #P0 &quot;], %[LoopEnd], 1b      \n\t&quot;       \
231      &quot;.set   pop                             \n\t&quot;       \
232  
233  #define ASM_END_COMMON_0                                \
</pre></code></div>
                <div class="column column_space"><pre><code>358    &quot;sll    %[&quot; #TEMP0 &quot;],  %[&quot; #TEMP1 &quot;],  3                    \n\t&quot;    \
359    &quot;sll    %[&quot; #TEMP2 &quot;],  %[temp20],    3                      \n\t&quot;    \
360    &quot;addiu  %[temp16],    %[temp16],    1812                     \n\t&quot;    \
361    &quot;addiu  %[temp17],    %[temp17],    937                      \n\t&quot;    \
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    