<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for ppmsave.c &amp; relational.c</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for ppmsave.c &amp; relational.c
      </h3>
<h1 align="center">
        7.8%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>ppmsave.c (8.51735%)<th>relational.c (7.2580647%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(384-395)<td><a href="#" name="0">(200-212)</a><td align="center"><font color="#ff0000">14</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(577-612)<td><a href="#" name="1">(281-317)</a><td align="center"><font color="#ec0000">13</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>ppmsave.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 #ifdef HAVE_CONFIG_H
2 #include &lt;config.h&gt;
3 #include &lt;vips/intl.h&gt;
4 #include &lt;stdio.h&gt;
5 #include &lt;stdlib.h&gt;
6 #include &lt;string.h&gt;
7 #include &lt;vips/vips.h&gt;
8 #include &lt;vips/internal.h&gt;
9 #include "pforeign.h"
10 #ifdef HAVE_PPM
11 typedef struct _VipsForeignSavePpm VipsForeignSavePpm;
12 typedef int (*VipsSavePpmFn)( VipsForeignSavePpm *, VipsImage *, VipsPel * );
13 struct _VipsForeignSavePpm {
14 	VipsForeignSave parent_object;
15 	VipsTarget *target;
16 	gboolean ascii;
17 	int bitdepth;
18 	VipsSavePpmFn fn;
19 	gboolean squash;
20 };
21 typedef VipsForeignSaveClass VipsForeignSavePpmClass;
22 G_DEFINE_ABSTRACT_TYPE( VipsForeignSavePpm, vips_foreign_save_ppm, 
23 	VIPS_TYPE_FOREIGN_SAVE );
24 static void
25 vips_foreign_save_ppm_dispose( GObject *gobject )
26 {
27 	VipsForeignSavePpm *ppm = (VipsForeignSavePpm *) gobject;
28 	if( ppm-&gt;target ) 
29 		vips_target_finish( ppm-&gt;target );
30 	VIPS_UNREF( ppm-&gt;target );
31 	G_OBJECT_CLASS( vips_foreign_save_ppm_parent_class )-&gt;
32 		dispose( gobject );
33 }
34 static int
35 vips_foreign_save_ppm_line_ascii( VipsForeignSavePpm *ppm, 
36         VipsImage *image, VipsPel *p )
37 {
38 	const int n_elements = image-&gt;Xsize * image-&gt;Bands;
39 	int i;
40 	for( i = 0; i &lt; n_elements; i++ ) {
41 		switch( image-&gt;BandFmt ) {
42 		case VIPS_FORMAT_UCHAR:
43 			vips_target_writef( ppm-&gt;target, 
44 				"%d ", p[i] );
45 			break;
46 		case VIPS_FORMAT_USHORT:
47 			vips_target_writef( ppm-&gt;target, 
48 				"%d ", ((unsigned short *) p)[i] );
49 			break;
50 		case VIPS_FORMAT_UINT:
51 			vips_target_writef( ppm-&gt;target, 
52 				"%d ", ((unsigned int *) p)[i] );
53 			break;
54 		default:
55 			g_assert_not_reached();
56 		}
57 	}
58 	if( vips_target_writes( ppm-&gt;target, "\n" ) ) 
59 		return( -1 );
60 	return( 0 );
61 }
62 static int
63 vips_foreign_save_ppm_line_ascii_1bit( VipsForeignSavePpm *ppm, 
64         VipsImage *image, VipsPel *p )
65 {
66 	int x;
67 	for( x = 0; x &lt; image-&gt;Xsize; x++ ) 
68 		vips_target_writef( ppm-&gt;target, "%d ", p[x] ? 0 : 1 );
69 	if( vips_target_writes( ppm-&gt;target, "\n" ) ) 
70 		return( -1 );
71 	return( 0 );
72 }
73 static int
74 vips_foreign_save_ppm_line_binary( VipsForeignSavePpm *ppm, 
75         VipsImage *image, VipsPel *p )
76 {
77 	if( vips_target_write( ppm-&gt;target, 
78 		p, VIPS_IMAGE_SIZEOF_LINE( image ) ) ) 
79 		return( -1 );
80 	return( 0 );
81 }
82 static int
83 vips_foreign_save_ppm_line_binary_1bit( VipsForeignSavePpm *ppm, 
84 	VipsImage *image, VipsPel *p )
85 {
86 	int x;
87 	int bits;
88 	int n_bits;
89 	bits = 0;
90 	n_bits = 0;
91 	for( x = 0; x &lt; image-&gt;Xsize; x++ ) {
92 		bits = VIPS_LSHIFT_INT( bits, 1 );
93 		n_bits += 1;
94 		bits |= p[x] &gt; 128 ? 0 : 1;
95 		if( n_bits == 8 ) {
96 			if( VIPS_TARGET_PUTC( ppm-&gt;target, bits ) ) 
97 				return( -1 );
98 			bits = 0;
99 			n_bits = 0;
100 		}
101 	}
102 	if( n_bits &amp;&amp;
103 		VIPS_TARGET_PUTC( ppm-&gt;target, bits ) ) 
104 		return( -1 );
105 	return( 0 );
106 }
107 static int
108 vips_foreign_save_ppm_block( VipsRegion *region, VipsRect *area, void *a )
109 {
110 	VipsForeignSavePpm *ppm = (VipsForeignSavePpm *) a;
111 	VipsImage *image = region-&gt;im;
112 	int y;
113 	for( y = 0; y &lt; area-&gt;height; y++ ) {
114 		VipsPel *p = VIPS_REGION_ADDR( region, 0, area-&gt;top + y );
115 		if( ppm-&gt;fn( ppm, image, p ) )
116 			return( -1 );
117 	}
118 	return( 0 );
119 }
120 static int
121 vips_foreign_save_ppm_build( VipsObject *object )
122 {
123 	VipsForeignSave *save = (VipsForeignSave *) object;
124 	VipsForeignSavePpm *ppm = (VipsForeignSavePpm *) object;
125 	VipsImage *image;
126 	char *magic;
127 	char *date;
128 	if( VIPS_OBJECT_CLASS( vips_foreign_save_ppm_parent_class )-&gt;
129 		build( object ) )
130 		return( -1 );
131 	image = save-&gt;ready;
132         if( vips_object_argument_isset( object, "squash" ) ) 
133 		ppm-&gt;bitdepth = 1;
134 	if( vips_check_uintorf( "vips2ppm", image ) || 
135 		vips_check_bands_1or3( "vips2ppm", image ) || 
136 		vips_check_uncoded( "vips2ppm", image ) || 
137 		vips_image_pio_input( image ) )
138 		return( -1 );
139 	if( ppm-&gt;ascii &amp;&amp; 
140 		image-&gt;BandFmt == VIPS_FORMAT_FLOAT ) {
141 		g_warning( "%s", 
142 			_( "float images must be binary -- disabling ascii" ) );
143 		ppm-&gt;ascii = FALSE;
144 	}
145 	if( ppm-&gt;bitdepth &amp;&amp; 
146 		(image-&gt;Bands != 1 || 
147 		 image-&gt;BandFmt != VIPS_FORMAT_UCHAR) ) {
148 		g_warning( "%s", 
149 			_( "can only save 1 band uchar images as 1 bit -- " 
150 				"disabling 1 bit save" ) );
151 		ppm-&gt;bitdepth = 0; 
152 	}
153 	magic = "unset";
154 	if( image-&gt;BandFmt == VIPS_FORMAT_FLOAT &amp;&amp; 
155 		image-&gt;Bands == 3 ) 
156 		magic = "PF";
157 	else if( image-&gt;BandFmt == VIPS_FORMAT_FLOAT &amp;&amp; 
158 		image-&gt;Bands == 1 ) 
159 		magic = "Pf";
160 	else if( image-&gt;Bands == 1 &amp;&amp; 
161 		ppm-&gt;ascii &amp;&amp; 
162 		ppm-&gt;bitdepth )
163 		magic = "P1";
164 	else if( image-&gt;Bands == 1 &amp;&amp; 
165 		ppm-&gt;ascii )
166 		magic = "P2";
167 	else if( image-&gt;Bands == 1 &amp;&amp; 
168 		!ppm-&gt;ascii &amp;&amp; 
169 		ppm-&gt;bitdepth )
170 		magic = "P4";
171 	else if( image-&gt;Bands == 1 &amp;&amp; 
172 		!ppm-&gt;ascii )
173 		magic = "P5";
174 	else if( image-&gt;Bands == 3 &amp;&amp; 
175 		ppm-&gt;ascii )
176 		magic = "P3";
177 	else if( image-&gt;Bands == 3 &amp;&amp; 
178 		!ppm-&gt;ascii )
179 		magic = "P6";
180 	else
181 		g_assert_not_reached();
182 	vips_target_writef( ppm-&gt;target, "%s\n", magic );
183 	if( !save-&gt;strip ) {
184 		date = vips__get_iso8601();
185 		vips_target_writef( ppm-&gt;target, 
186 			"#vips2ppm - %s\n", date );
187 		g_free( date );
188 	}
189 	vips_target_writef( ppm-&gt;target, 
190 		"%d %d\n", image-&gt;Xsize, image-&gt;Ysize );
191 	if( !ppm-&gt;bitdepth ) 
192 		switch( image-&gt;BandFmt ) {
193 		case VIPS_FORMAT_UCHAR:
194 			vips_target_writef( ppm-&gt;target, 
195 				"%d\n", UCHAR_MAX );
196 			break;
197 		case VIPS_FORMAT_USHORT:
198 			vips_target_writef( ppm-&gt;target, 
199 				"%d\n", USHRT_MAX );
200 			break;
201 		case VIPS_FORMAT_UINT:
202 			vips_target_writef( ppm-&gt;target, 
203 				"%d\n", UINT_MAX );
204 			break;
205 		case VIPS_FORMAT_FLOAT:
206 {
207 			double scale;
208 			char buf[G_ASCII_DTOSTR_BUF_SIZE];
209 			if( vips_image_get_double( image, 
210 				"pfm-scale", &amp;scale ) )
211 				scale = 1;
212 			if( !vips_amiMSBfirst() )
213 				scale *= -1;
214 			g_ascii_dtostr( buf, G_ASCII_DTOSTR_BUF_SIZE, scale );
215 			vips_target_writes( ppm-&gt;target, buf );
216 			vips_target_writes( ppm-&gt;target, "\n" );
217 }
218 			break;
219 		default:
220 			g_assert_not_reached();
221 		}
222 	if( ppm-&gt;bitdepth )
223 		ppm-&gt;fn = ppm-&gt;ascii ? 
224 			vips_foreign_save_ppm_line_ascii_1bit : 
225 			vips_foreign_save_ppm_line_binary_1bit;
226 	else
227 		ppm-&gt;fn = ppm-&gt;ascii ? 
228 			vips_foreign_save_ppm_line_ascii : 
229 			vips_foreign_save_ppm_line_binary;
230 	if( !ppm-&gt;ascii &amp;&amp;
231 		(image-&gt;BandFmt == VIPS_FORMAT_USHORT ||
232 		 image-&gt;BandFmt == VIPS_FORMAT_UINT) ) {
233 		VipsImage *x;
234 		if( vips__byteswap_bool( image, &amp;x, !vips_amiMSBfirst() ) )
235 			return( -1 );
236 		image = x;
237 		vips_object_local( VIPS_OBJECT( ppm-&gt;target ), image );
238 	}
239 	if( vips_sink_disc( image, vips_foreign_save_ppm_block, ppm ) )
240 		return( -1 );
241 	vips_target_finish( ppm-&gt;target );
242 	return( 0 );
243 }
244 #define UC VIPS_FORMAT_UCHAR
245 #define C VIPS_FORMAT_CHAR
246 #define US VIPS_FORMAT_USHORT
247 #define S VIPS_FORMAT_SHORT
248 #define UI VIPS_FORMAT_UINT
249 #define I VIPS_FORMAT_INT
250 #define F VIPS_FORMAT_FLOAT
251 #define X VIPS_FORMAT_COMPLEX
252 <a name="0"></a>#define D VIPS_FORMAT_DOUBLE
253 #define DX VIPS_FORMAT_DPCOMPLEX
254 <font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>static int bandfmt_ppm[10] = {
255    UC, UC, US, US, UI, UI, F,  F,  F,  F
256 };
257 static void
258 vips_foreign_save_ppm_class_init( VipsForeignSavePpmClass *class )
259 {
260 	GObjectClass *gobject_class = G_OBJECT_CLASS( class );
261 	VipsObjectClass *object_class = (VipsObjectClass *) class;
262 	VipsForeignClass *foreign_class = (VipsForeignClass *) class;
263 	VipsForeignSaveClass *save_class = (VipsForeignSaveClass *) class;</b></font>
264 	gobject_class-&gt;dispose = vips_foreign_save_ppm_dispose;
265 	gobject_class-&gt;set_property = vips_object_set_property;
266 	gobject_class-&gt;get_property = vips_object_get_property;
267 	object_class-&gt;nickname = "ppmsave_base";
268 	object_class-&gt;description = _( "save to ppm" );
269 	object_class-&gt;build = vips_foreign_save_ppm_build;
270 	foreign_class-&gt;suffs = vips__ppm_suffs;
271 	save_class-&gt;saveable = VIPS_SAVEABLE_RGB;
272 	save_class-&gt;format_table = bandfmt_ppm;
273 	VIPS_ARG_BOOL( class, "ascii", 10, 
274 		_( "ASCII" ), 
275 		_( "save as ascii" ),
276 		VIPS_ARGUMENT_OPTIONAL_INPUT,
277 		G_STRUCT_OFFSET( VipsForeignSavePpm, ascii ),
278 		FALSE );
279 	VIPS_ARG_INT( class, "bitdepth", 15,
280 		_( "bitdepth" ),
281 		_( "set to 1 to write as a 1 bit image" ),
282 		VIPS_ARGUMENT_OPTIONAL_INPUT,
283 		G_STRUCT_OFFSET( VipsForeignSavePpm, bitdepth ),
284 		0, 1, 0 );
285 	VIPS_ARG_BOOL( class, "squash", 11, 
286 		_( "Squash" ), 
287 		_( "save as one bit" ),
288 		VIPS_ARGUMENT_OPTIONAL_INPUT | VIPS_ARGUMENT_DEPRECATED,
289 		G_STRUCT_OFFSET( VipsForeignSavePpm, squash ),
290 		FALSE );
291 }
292 static void
293 vips_foreign_save_ppm_init( VipsForeignSavePpm *ppm )
294 {
295 }
296 typedef struct _VipsForeignSavePpmFile {
297 	VipsForeignSavePpm parent_object;
298 	char *filename; 
299 } VipsForeignSavePpmFile;
300 typedef VipsForeignSavePpmClass VipsForeignSavePpmFileClass;
301 G_DEFINE_TYPE( VipsForeignSavePpmFile, vips_foreign_save_ppm_file, 
302 	vips_foreign_save_ppm_get_type() );
303 static int
304 vips_foreign_save_ppm_file_build( VipsObject *object )
305 {
306 	VipsForeignSavePpm *ppm = (VipsForeignSavePpm *) object;
307 	VipsForeignSavePpmFile *file = (VipsForeignSavePpmFile *) object;
308 	if( file-&gt;filename &amp;&amp;
309 		!(ppm-&gt;target = vips_target_new_to_file( file-&gt;filename )) )
310 		return( -1 );
311 	return( VIPS_OBJECT_CLASS( vips_foreign_save_ppm_file_parent_class )-&gt;
312 		build( object ) );
313 }
314 static void
315 vips_foreign_save_ppm_file_class_init( VipsForeignSavePpmFileClass *class )
316 {
317 	GObjectClass *gobject_class = G_OBJECT_CLASS( class );
318 	VipsObjectClass *object_class = (VipsObjectClass *) class;
319 	gobject_class-&gt;set_property = vips_object_set_property;
320 	gobject_class-&gt;get_property = vips_object_get_property;
321 	object_class-&gt;nickname = "ppmsave";
322 	object_class-&gt;description = _( "save image to ppm file" );
323 	object_class-&gt;build = vips_foreign_save_ppm_file_build;
324 	VIPS_ARG_STRING( class, "filename", 1, 
325 		_( "Filename" ),
326 		_( "Filename to save to" ),
327 		VIPS_ARGUMENT_REQUIRED_INPUT, 
328 		G_STRUCT_OFFSET( VipsForeignSavePpmFile, filename ),
329 		NULL );
330 }
331 static void
332 vips_foreign_save_ppm_file_init( VipsForeignSavePpmFile *file )
333 {
334 }
335 typedef struct _VipsForeignSavePpmTarget {
336 	VipsForeignSavePpm parent_object;
337 	VipsTarget *target;
338 } VipsForeignSavePpmTarget;
339 typedef VipsForeignSavePpmClass VipsForeignSavePpmTargetClass;
340 G_DEFINE_TYPE( VipsForeignSavePpmTarget, vips_foreign_save_ppm_target, 
341 	vips_foreign_save_ppm_get_type() );
342 static int
343 vips_foreign_save_ppm_target_build( VipsObject *object )
344 {
345 	VipsForeignSavePpm *ppm = (VipsForeignSavePpm *) object;
346 	VipsForeignSavePpmTarget *target = 
347 		(VipsForeignSavePpmTarget *) object;
348 	if( target-&gt;target ) {
349 		ppm-&gt;target = target-&gt;target; 
350 		g_object_ref( ppm-&gt;target );
351 	}
352 	return( VIPS_OBJECT_CLASS( 
353 		vips_foreign_save_ppm_target_parent_class )-&gt;
354 			build( object ) );
355 }
356 static void
357 vips_foreign_save_ppm_target_class_init( 
358 	VipsForeignSavePpmTargetClass *class )
359 {
360 	GObjectClass *gobject_class = G_OBJECT_CLASS( class );
361 	VipsObjectClass *object_class = (VipsObjectClass *) class;
362 	gobject_class-&gt;set_property = vips_object_set_property;
363 	gobject_class-&gt;get_property = vips_object_get_property;
364 	object_class-&gt;nickname = "ppmsave_target";
365 	object_class-&gt;build = vips_foreign_save_ppm_target_build;
366 	VIPS_ARG_OBJECT( class, "target", 1,
367 		_( "Target" ),
368 		_( "Target to save to" ),
369 		VIPS_ARGUMENT_REQUIRED_INPUT, 
370 		G_STRUCT_OFFSET( VipsForeignSavePpmTarget, target ),
371 		VIPS_TYPE_TARGET );
372 }
373 static void
374 vips_foreign_save_ppm_target_init( VipsForeignSavePpmTarget *target )
375 {
376 }
377 int
378 <font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>vips_ppmsave( VipsImage *in, const char *filename, ... )
379 {
380 	va_list ap;
381 	int result;
382 	va_start( ap, filename );
383 	result = vips_call_split( "ppmsave", ap, in, filename );
384 	va_end( ap );
385 	return( result );
386 }
387 int
388 vips_ppmsave_target( VipsImage *in, VipsTarget *target, ... )
389 {
390 	va_list ap;
391 	int result;
392 	va_start( ap, target );
393 	result = vips_call_split( "ppmsave_target", ap, in, target );
394 	va_end( ap );
395 	return( result );
396 }</b></font>
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>relational.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 #ifdef HAVE_CONFIG_H
2 #include &lt;config.h&gt;
3 #include &lt;vips/intl.h&gt;
4 #include &lt;stdio.h&gt;
5 #include &lt;stdlib.h&gt;
6 #include &lt;vips/vips.h&gt;
7 #include "binary.h"
8 #include "unaryconst.h"
9 typedef struct _VipsRelational {
10 	VipsBinary parent_instance;
11 	VipsOperationRelational relational;
12 } VipsRelational;
13 typedef VipsBinaryClass VipsRelationalClass;
14 G_DEFINE_TYPE( VipsRelational, vips_relational, VIPS_TYPE_BINARY );
15 #define RLOOP( TYPE, ROP ) { \
16 	TYPE * restrict left = (TYPE *) in0; \
17 	TYPE * restrict right = (TYPE *) in1; \
18 	VipsPel * restrict q = (VipsPel *) out; \
19 	\
20 	for( x = 0; x &lt; sz; x++ ) \
21 		q[x] = (left[x] ROP right[x]) ? 255 : 0; \
22 }
23 #define CLOOP( TYPE, COP ) { \
24 	TYPE * restrict left = (TYPE *) in0; \
25 	TYPE * restrict right = (TYPE *) in1; \
26 	VipsPel * restrict q = (VipsPel *) out; \
27 	\
28 	for( x = 0; x &lt; sz; x++ ) { \
29 		q[x] = COP( left[0], left[1], right[0], right[1]) ? 255 : 0; \
30 		\
31 		left += 2; \
32 		right += 2; \
33 	} \
34 }
35 #define SWITCH( R, C, ROP, COP ) \
36 	switch( vips_image_get_format( im ) ) { \
37 	case VIPS_FORMAT_UCHAR:		R( unsigned char, ROP ); break; \
38 	case VIPS_FORMAT_CHAR:		R( signed char, ROP ); break; \
39 	case VIPS_FORMAT_USHORT: 	R( unsigned short, ROP ); break; \
40 	case VIPS_FORMAT_SHORT: 	R( signed short, ROP ); break; \
41 	case VIPS_FORMAT_UINT: 		R( unsigned int, ROP ); break; \
42 	case VIPS_FORMAT_INT: 		R( signed int, ROP ); break; \
43 	case VIPS_FORMAT_FLOAT: 	R( float, ROP ); break; \
44 	case VIPS_FORMAT_DOUBLE: 	R( double, ROP ); break;\
45 	case VIPS_FORMAT_COMPLEX: 	C( float, COP ); break; \
46 	case VIPS_FORMAT_DPCOMPLEX: 	C( double, COP ); break;\
47  	\
48 	default: \
49 		g_assert_not_reached(); \
50 	} 
51 #define CEQUAL( x1, y1, x2, y2 ) (x1 == x2 &amp;&amp; y1 == y2)
52 #define CNOTEQ( x1, y1, x2, y2 ) (x1 != x2 || y1 != y2)
53 #define CLESS( x1, y1, x2, y2 ) (x1 * x1 + y1 * y1 &lt; x2 * x2 + y2 * y2)
54 #define CLESSEQ( x1, y1, x2, y2 ) (x1 * x1 + y1 * y1 &lt;= x2 * x2 + y2 * y2)
55 #define CMORE( x1, y1, x2, y2 ) (x1 * x1 + y1 * y1 &gt; x2 * x2 + y2 * y2)
56 #define CMOREEQ( x1, y1, x2, y2 ) (x1 * x1 + y1 * y1 &gt;= x2 * x2 + y2 * y2)
57 static void
58 vips_relational_buffer( VipsArithmetic *arithmetic, 
59 	VipsPel *out, VipsPel **in, int width )
60 {
61 	VipsRelational *relational = (VipsRelational *) arithmetic;
62 	VipsImage *im = arithmetic-&gt;ready[0];
63 	const int sz = width * vips_image_get_bands( im );
64 	VipsOperationRelational op;
65 	VipsPel *in0;
66 	VipsPel *in1;
67 	int x;
68 	in0 = in[0];
69 	in1 = in[1];
70 	op = relational-&gt;relational;
71 	if( op == VIPS_OPERATION_RELATIONAL_MORE ) {
72 		op = VIPS_OPERATION_RELATIONAL_LESS;
73 		VIPS_SWAP( VipsPel *, in0, in1 );
74 	}
75 	if( op == VIPS_OPERATION_RELATIONAL_MOREEQ ) {
76 		op = VIPS_OPERATION_RELATIONAL_LESSEQ;
77 		VIPS_SWAP( VipsPel *, in0, in1 );
78 	}
79 	switch( op ) {
80 	case VIPS_OPERATION_RELATIONAL_EQUAL: 	
81 		SWITCH( RLOOP, CLOOP, ==, CEQUAL ); 
82 		break;
83 	case VIPS_OPERATION_RELATIONAL_NOTEQ:
84 		SWITCH( RLOOP, CLOOP, !=, CNOTEQ ); 
85 		break;
86 	case VIPS_OPERATION_RELATIONAL_LESS: 	
87 		SWITCH( RLOOP, CLOOP, &lt;, CLESS ); 
88 		break;
89 	case VIPS_OPERATION_RELATIONAL_LESSEQ: 	
90 		SWITCH( RLOOP, CLOOP, &lt;=, CLESSEQ ); 
91 		break;
92 	default:
93 		g_assert_not_reached();
94 	}
95 }
96 #define UC VIPS_FORMAT_UCHAR
97 #define C VIPS_FORMAT_CHAR
98 #define US VIPS_FORMAT_USHORT
99 #define S VIPS_FORMAT_SHORT
100 #define UI VIPS_FORMAT_UINT
101 #define I VIPS_FORMAT_INT
102 #define F VIPS_FORMAT_FLOAT
103 #define X VIPS_FORMAT_COMPLEX
104 <a name="0"></a>#define D VIPS_FORMAT_DOUBLE
105 #define DX VIPS_FORMAT_DPCOMPLEX
106 <font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>static const VipsBandFormat vips_relational_format_table[10] = {
107    UC, UC, UC, UC, UC, UC, UC, UC, UC, UC
108 };
109 static void
110 vips_relational_class_init( VipsRelationalClass *class )
111 {
112 	GObjectClass *gobject_class = G_OBJECT_CLASS( class );
113 	VipsObjectClass *object_class = (VipsObjectClass *) class;
114 	VipsArithmeticClass *aclass = VIPS_ARITHMETIC_CLASS( class );
115 	gobject_class-&gt;set_property = vips_object_set_property;</b></font>
116 	gobject_class-&gt;get_property = vips_object_get_property;
117 	object_class-&gt;nickname = "relational";
118 	object_class-&gt;description = _( "relational operation on two images" );
119 	aclass-&gt;process_line = vips_relational_buffer;
120 	vips_arithmetic_set_format_table( aclass, 
121 		vips_relational_format_table ); 
122 	VIPS_ARG_ENUM( class, "relational", 200, 
123 		_( "Operation" ), 
124 		_( "relational to perform" ),
125 		VIPS_ARGUMENT_REQUIRED_INPUT,
126 		G_STRUCT_OFFSET( VipsRelational, relational ),
127 		VIPS_TYPE_OPERATION_RELATIONAL, 
128 			VIPS_OPERATION_RELATIONAL_EQUAL ); 
129 }
130 static void
131 vips_relational_init( VipsRelational *relational )
132 {
133 }
134 static int
135 vips_relationalv( VipsImage *left, VipsImage *right, VipsImage **out, 
136 	VipsOperationRelational relational, va_list ap )
137 {
138 	return(  vips_call_split( "relational", ap, left, right, out, 
139 		relational ) );
140 }
141 int
142 vips_relational( VipsImage *left, VipsImage *right, VipsImage **out, 
143 <font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>	VipsOperationRelational relational, ... )
144 {
145 	va_list ap;
146 	int result;
147 	va_start( ap, relational );
148 	result = vips_relationalv( left, right, out, relational, ap );
149 	va_end( ap );
150 	return( result );
151 }
152 int
153 vips_equal( VipsImage *left, VipsImage *right, VipsImage **out, ... )
154 {
155 	va_list ap;
156 	int result;
157 	va_start( ap, out );
158 	result = vips_relationalv( left, right, out, 
159 		VIPS_OPERATION_RELATIONAL_EQUAL, ap );
160 	va_end( ap );
161 	return( result );
162 }</b></font>
163 int
164 vips_notequal( VipsImage *left, VipsImage *right, VipsImage **out, ... )
165 {
166 	va_list ap;
167 	int result;
168 	va_start( ap, out );
169 	result = vips_relationalv( left, right, out, 
170 		VIPS_OPERATION_RELATIONAL_NOTEQ, ap );
171 	va_end( ap );
172 	return( result );
173 }
174 int
175 vips_more( VipsImage *left, VipsImage *right, VipsImage **out, ... )
176 {
177 	va_list ap;
178 	int result;
179 	va_start( ap, out );
180 	result = vips_relationalv( left, right, out, 
181 		VIPS_OPERATION_RELATIONAL_MORE, ap );
182 	va_end( ap );
183 	return( result );
184 }
185 int
186 vips_moreeq( VipsImage *left, VipsImage *right, VipsImage **out, ... )
187 {
188 	va_list ap;
189 	int result;
190 	va_start( ap, out );
191 	result = vips_relationalv( left, right, out, 
192 		VIPS_OPERATION_RELATIONAL_MOREEQ, ap );
193 	va_end( ap );
194 	return( result );
195 }
196 int
197 vips_less( VipsImage *left, VipsImage *right, VipsImage **out, ... )
198 {
199 	va_list ap;
200 	int result;
201 	va_start( ap, out );
202 	result = vips_relationalv( left, right, out, 
203 		VIPS_OPERATION_RELATIONAL_LESS, ap );
204 	va_end( ap );
205 	return( result );
206 }
207 int
208 vips_lesseq( VipsImage *left, VipsImage *right, VipsImage **out, ... )
209 {
210 	va_list ap;
211 	int result;
212 	va_start( ap, out );
213 	result = vips_relationalv( left, right, out, 
214 		VIPS_OPERATION_RELATIONAL_LESSEQ, ap );
215 	va_end( ap );
216 	return( result );
217 }
218 typedef struct _VipsRelationalConst {
219 	VipsUnaryConst parent_instance;
220 	VipsOperationRelational relational;
221 } VipsRelationalConst;
222 typedef VipsUnaryConstClass VipsRelationalConstClass;
223 G_DEFINE_TYPE( VipsRelationalConst, 
224 	vips_relational_const, VIPS_TYPE_UNARY_CONST );
225 #define RLOOPCI( TYPE, OP ) { \
226 	TYPE * restrict p = (TYPE *) in[0]; \
227 	int * restrict c = uconst-&gt;c_int; \
228  	\
229 	for( i = 0, x = 0; x &lt; width; x++ ) \
230 		for( b = 0; b &lt; bands; b++, i++ ) \
231 			out[i] = (p[i] OP c[b]) ? 255 : 0; \
232 }
233 #define RLOOPCF( TYPE, OP ) { \
234 	TYPE * restrict p = (TYPE *) in[0]; \
235 	double * restrict c = uconst-&gt;c_double; \
236  	\
237 	for( i = 0, x = 0; x &lt; width; x++ ) \
238 		for( b = 0; b &lt; bands; b++, i++ ) \
239 			out[i] = (p[i] OP c[b]) ? 255 : 0; \
240 }
241 #define CLOOPC( TYPE, OP ) { \
242 	TYPE * restrict p = (TYPE *) in[0]; \
243  	\
244 	for( i = 0, x = 0; x &lt; width; x++ ) { \
245 		double * restrict c = uconst-&gt;c_double; \
246 		\
247 		for( b = 0; b &lt; bands; b++, i++ ) { \
248 			out[i] = OP( p[0], p[1], c[0], c[1]) ? 255 : 0; \
249 			\
250 			p += 2; \
251 			c += 2; \
252 		} \
253 	} \
254 }
255 static void
256 vips_relational_const_buffer( VipsArithmetic *arithmetic, 
257 	VipsPel *out, VipsPel **in, int width )
258 {
259 	VipsUnaryConst *uconst = (VipsUnaryConst *) arithmetic;
260 	VipsRelationalConst *rconst = (VipsRelationalConst *) arithmetic;
261 	VipsImage *im = arithmetic-&gt;ready[0];
262 	int bands = im-&gt;Bands;
263 	gboolean is_int = uconst-&gt;is_int &amp;&amp;
264 		vips_band_format_isint( im-&gt;BandFmt );
265 	int i, x, b;
266 	switch( rconst-&gt;relational ) {
267 	case VIPS_OPERATION_RELATIONAL_EQUAL:
268 		if( is_int ) {
269 			SWITCH( RLOOPCI, CLOOPC, ==, CEQUAL ); 
270 		}
271 		else {
272 			SWITCH( RLOOPCF, CLOOPC, ==, CEQUAL ); 
273 		}
274 		break;
275 	case VIPS_OPERATION_RELATIONAL_NOTEQ:
276 		if( is_int ) {
277 			SWITCH( RLOOPCI, CLOOPC, !=, CNOTEQ ); 
278 		}
279 		else {
280 			SWITCH( RLOOPCF, CLOOPC, !=, CNOTEQ ); 
281 		}
282 		break;
283 	case VIPS_OPERATION_RELATIONAL_LESS:
284 		if( is_int ) {
285 			SWITCH( RLOOPCI, CLOOPC, &lt;, CLESS ); 
286 		}
287 		else {
288 			SWITCH( RLOOPCF, CLOOPC, &lt;, CLESS ); 
289 		}
290 		break;
291 	case VIPS_OPERATION_RELATIONAL_LESSEQ:
292 		if( is_int ) {
293 			SWITCH( RLOOPCI, CLOOPC, &lt;=, CLESSEQ ); 
294 		}
295 		else {
296 			SWITCH( RLOOPCF, CLOOPC, &lt;=, CLESSEQ ); 
297 		}
298 		break;
299 	case VIPS_OPERATION_RELATIONAL_MORE:
300 		if( is_int ) {
301 			SWITCH( RLOOPCI, CLOOPC, &gt;, CMORE ); 
302 		}
303 		else {
304 			SWITCH( RLOOPCF, CLOOPC, &gt;, CMORE ); 
305 		}
306 		break;
307 	case VIPS_OPERATION_RELATIONAL_MOREEQ:
308 		if( is_int ) {
309 			SWITCH( RLOOPCI, CLOOPC, &gt;=, CMOREEQ ); 
310 		}
311 		else {
312 			SWITCH( RLOOPCF, CLOOPC, &gt;=, CMOREEQ ); 
313 		}
314 		break;
315 	default:
316 		g_assert_not_reached();
317 	}
318 }
319 static void
320 vips_relational_const_class_init( VipsRelationalConstClass *class )
321 {
322 	GObjectClass *gobject_class = G_OBJECT_CLASS( class );
323 	VipsObjectClass *object_class = (VipsObjectClass *) class;
324 	VipsArithmeticClass *aclass = VIPS_ARITHMETIC_CLASS( class );
325 	gobject_class-&gt;set_property = vips_object_set_property;
326 	gobject_class-&gt;get_property = vips_object_get_property;
327 	object_class-&gt;nickname = "relational_const";
328 	object_class-&gt;description = 
329 		_( "relational operations against a constant" );
330 	aclass-&gt;process_line = vips_relational_const_buffer;
331 	vips_arithmetic_set_format_table( aclass, 
332 		vips_relational_format_table ); 
333 	VIPS_ARG_ENUM( class, "relational", 200, 
334 		_( "Operation" ), 
335 		_( "relational to perform" ),
336 		VIPS_ARGUMENT_REQUIRED_INPUT,
337 		G_STRUCT_OFFSET( VipsRelationalConst, relational ),
338 		VIPS_TYPE_OPERATION_RELATIONAL, 
339 			VIPS_OPERATION_RELATIONAL_EQUAL ); 
340 }
341 static void
342 vips_relational_const_init( VipsRelationalConst *relational_const )
343 {
344 }
345 static int
346 vips_relational_constv( VipsImage *in, VipsImage **out, 
347 	VipsOperationRelational relational, const double *c, int n, va_list ap )
348 {
349 	VipsArea *area_c;
350 	double *array; 
351 	int result;
352 	int i;
353 	area_c = vips_area_new_array( G_TYPE_DOUBLE, sizeof( double ), n ); 
354 	array = (double *) area_c-&gt;data;
355 	for( i = 0; i &lt; n; i++ ) 
356 		array[i] = c[i];
357 	result = vips_call_split( "relational_const", ap, 
358 		in, out, relational, area_c );
359 	vips_area_unref( area_c );
360 	return( result );
361 }
362 int
363 vips_relational_const( VipsImage *in, VipsImage **out, 
364 	VipsOperationRelational relational, const double *c, int n, ... )
365 {
366 	va_list ap;
367 	int result;
368 	va_start( ap, n );
369 	result = vips_relational_constv( in, out, relational, c, n, ap );
370 	va_end( ap );
371 	return( result );
372 }
373 int
374 vips_equal_const( VipsImage *in, VipsImage **out, const double *c, int n, ... )
375 {
376 	va_list ap;
377 	int result;
378 	va_start( ap, n );
379 	result = vips_relational_constv( in, out, 
380 		VIPS_OPERATION_RELATIONAL_EQUAL, c, n, ap );
381 	va_end( ap );
382 	return( result );
383 }
384 int
385 vips_notequal_const( VipsImage *in, VipsImage **out, 
386 	const double *c, int n, ... )
387 {
388 	va_list ap;
389 	int result;
390 	va_start( ap, n );
391 	result = vips_relational_constv( in, out, 
392 		VIPS_OPERATION_RELATIONAL_NOTEQ, c, n, ap );
393 	va_end( ap );
394 	return( result );
395 }
396 int
397 vips_less_const( VipsImage *in, VipsImage **out, const double *c, int n, ... )
398 {
399 	va_list ap;
400 	int result;
401 	va_start( ap, n );
402 	result = vips_relational_constv( in, out, 
403 		VIPS_OPERATION_RELATIONAL_LESS, c, n, ap );
404 	va_end( ap );
405 	return( result );
406 }
407 int
408 vips_lesseq_const( VipsImage *in, VipsImage **out, const double *c, int n, ... )
409 {
410 	va_list ap;
411 	int result;
412 	va_start( ap, n );
413 	result = vips_relational_constv( in, out, 
414 		VIPS_OPERATION_RELATIONAL_LESSEQ, c, n, ap );
415 	va_end( ap );
416 	return( result );
417 }
418 int
419 vips_more_const( VipsImage *in, VipsImage **out, const double *c, int n, ... )
420 {
421 	va_list ap;
422 	int result;
423 	va_start( ap, n );
424 	result = vips_relational_constv( in, out, 
425 		VIPS_OPERATION_RELATIONAL_MORE, c, n, ap );
426 	va_end( ap );
427 	return( result );
428 }
429 int
430 vips_moreeq_const( VipsImage *in, VipsImage **out, const double *c, int n, ... )
431 {
432 	va_list ap;
433 	int result;
434 	va_start( ap, n );
435 	result = vips_relational_constv( in, out, 
436 		VIPS_OPERATION_RELATIONAL_MOREEQ, c, n, ap );
437 	va_end( ap );
438 	return( result );
439 }
440 int
441 vips_relational_const1( VipsImage *in, VipsImage **out, 
442 	VipsOperationRelational relational, double c, ... )
443 {
444 	va_list ap;
445 	int result;
446 	va_start( ap, c );
447 	result = vips_relational_constv( in, out, relational, &amp;c, 1, ap );
448 	va_end( ap );
449 	return( result );
450 }
451 int
452 vips_equal_const1( VipsImage *in, VipsImage **out, double c, ... )
453 {
454 	va_list ap;
455 	int result;
456 	va_start( ap, c );
457 	result = vips_relational_constv( in, out, 
458 		VIPS_OPERATION_RELATIONAL_EQUAL, &amp;c, 1, ap );
459 	va_end( ap );
460 	return( result );
461 }
462 int
463 vips_notequal_const1( VipsImage *in, VipsImage **out, double c, ... )
464 {
465 	va_list ap;
466 	int result;
467 	va_start( ap, c );
468 	result = vips_relational_constv( in, out, 
469 		VIPS_OPERATION_RELATIONAL_NOTEQ, &amp;c, 1, ap );
470 	va_end( ap );
471 	return( result );
472 }
473 int
474 vips_less_const1( VipsImage *in, VipsImage **out, double c, ... )
475 {
476 	va_list ap;
477 	int result;
478 	va_start( ap, c );
479 	result = vips_relational_constv( in, out, 
480 		VIPS_OPERATION_RELATIONAL_LESS, &amp;c, 1, ap );
481 	va_end( ap );
482 	return( result );
483 }
484 int
485 vips_lesseq_const1( VipsImage *in, VipsImage **out, double c, ... )
486 {
487 	va_list ap;
488 	int result;
489 	va_start( ap, c );
490 	result = vips_relational_constv( in, out, 
491 		VIPS_OPERATION_RELATIONAL_LESSEQ, &amp;c, 1, ap );
492 	va_end( ap );
493 	return( result );
494 }
495 int
496 vips_more_const1( VipsImage *in, VipsImage **out, double c, ... )
497 {
498 	va_list ap;
499 	int result;
500 	va_start( ap, c );
501 	result = vips_relational_constv( in, out, 
502 		VIPS_OPERATION_RELATIONAL_MORE, &amp;c, 1, ap );
503 	va_end( ap );
504 	return( result );
505 }
506 int
507 vips_moreeq_const1( VipsImage *in, VipsImage **out, double c, ... )
508 {
509 	va_list ap;
510 	int result;
511 	va_start( ap, c );
512 	result = vips_relational_constv( in, out, 
513 		VIPS_OPERATION_RELATIONAL_MOREEQ, &amp;c, 1, ap );
514 	va_end( ap );
515 	return( result );
516 }
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
