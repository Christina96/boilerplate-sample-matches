
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 5.263157894736842%, Tokens: 9</h2>
        <div class="column">
            <h3>libtomcrypt-MDEwOlJlcG9zaXRvcnk3NzcwMTE=-flat-eax_test.c</h3>
            <pre><code>1  #include "tomcrypt_private.h"
2  #ifdef LTC_EAX_MODE
3  int eax_test(void)
4  {
5  #ifndef LTC_TEST
6     return CRYPT_NOP;
7  #else
8     static const struct {
<span onclick='openModal()' class='match'>9         int               keylen,
10                         noncelen,
11                        headerlen,
12                           msglen;
13         unsigned char        key[MAXBLOCKSIZE],
14                            nonce[MAXBLOCKSIZE],
15                           header[MAXBLOCKSIZE],
16                        plaintext[MAXBLOCKSIZE],
17                       ciphertext[MAXBLOCKSIZE],
18                              tag[MAXBLOCKSIZE];
19     } tests[] = {
20  {
21     16, 0, 0, 0,
22     { 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
23       0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f },
</span>24     { 0 },
25     { 0 },
26     { 0 },
27     { 0 },
28     { 0x9a, 0xd0, 0x7e, 0x7d, 0xbf, 0xf3, 0x01, 0xf5,
29       0x05, 0xde, 0x59, 0x6b, 0x96, 0x15, 0xdf, 0xff }
30  },
31  {
32     16, 16, 0, 0,
33     { 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
34       0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f },
35     { 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
36       0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f },
37     { 0 },
38     { 0 },
39     { 0 },
40     { 0x1c, 0xe1, 0x0d, 0x3e, 0xff, 0xd4, 0xca, 0xdb,
41       0xe2, 0xe4, 0x4b, 0x58, 0xd6, 0x0a, 0xb9, 0xec }
42  },
43  {
44     16, 0, 16, 0,
45     { 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
46       0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f },
47     { 0 },
48     { 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
49       0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f },
50     { 0 },
51     { 0 },
52     { 0x3a, 0x69, 0x8f, 0x7a, 0x27, 0x0e, 0x51, 0xb0,
53       0xf6, 0x5b, 0x3d, 0x3e, 0x47, 0x19, 0x3c, 0xff }
54  },
55  {
56     16, 16, 16, 32,
57     { 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
58       0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f },
59     { 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
60       0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f },
61     { 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
62       0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f },
63     { 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
64       0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,
65       0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17,
66       0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f },
67     { 0x29, 0xd8, 0x78, 0xd1, 0xa3, 0xbe, 0x85, 0x7b,
68       0x6f, 0xb8, 0xc8, 0xea, 0x59, 0x50, 0xa7, 0x78,
69       0x33, 0x1f, 0xbf, 0x2c, 0xcf, 0x33, 0x98, 0x6f,
70       0x35, 0xe8, 0xcf, 0x12, 0x1d, 0xcb, 0x30, 0xbc },
71     { 0x4f, 0xbe, 0x03, 0x38, 0xbe, 0x1c, 0x8c, 0x7e,
72       0x1d, 0x7a, 0xe7, 0xe4, 0x5b, 0x92, 0xc5, 0x87 }
73  },
74  {
75     16, 15, 14, 29,
76     { 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
77       0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f },
78     { 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
79       0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e },
80     { 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
81       0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d },
82     { 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
83       0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,
84       0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17,
85       0x18, 0x19, 0x1a, 0x1b, 0x1c },
86     { 0xdd, 0x25, 0xc7, 0x54, 0xc5, 0xb1, 0x7c, 0x59,
87       0x28, 0xb6, 0x9b, 0x73, 0x15, 0x5f, 0x7b, 0xb8,
88       0x88, 0x8f, 0xaf, 0x37, 0x09, 0x1a, 0xd9, 0x2c,
89       0x8a, 0x24, 0xdb, 0x86, 0x8b },
90     { 0x0d, 0x1a, 0x14, 0xe5, 0x22, 0x24, 0xff, 0xd2,
91       0x3a, 0x05, 0xfa, 0x02, 0xcd, 0xef, 0x52, 0xda }
92  },
93  {
94     16, 16, 8, 0,
95     { 0x23, 0x39, 0x52, 0xde, 0xe4, 0xd5, 0xed, 0x5f,
96       0x9b, 0x9c, 0x6d, 0x6f, 0xf8, 0x0f, 0xf4, 0x78 },
97     { 0x62, 0xec, 0x67, 0xf9, 0xc3, 0xa4, 0xa4, 0x07,
98       0xfc, 0xb2, 0xa8, 0xc4, 0x90, 0x31, 0xa8, 0xb3 },
99     { 0x6b, 0xfb, 0x91, 0x4f, 0xd0, 0x7e, 0xae, 0x6b },
100     { 0x00 },
101     { 0x00 },
102     { 0xe0, 0x37, 0x83, 0x0e, 0x83, 0x89, 0xf2, 0x7b,
103       0x02, 0x5a, 0x2d, 0x65, 0x27, 0xe7, 0x9d, 0x01 }
104  },
105  {
106     16, 16, 8, 2,
107     { 0x91, 0x94, 0x5d, 0x3f, 0x4d, 0xcb, 0xee, 0x0b,
108       0xf4, 0x5e, 0xf5, 0x22, 0x55, 0xf0, 0x95, 0xa4 },
109     { 0xbe, 0xca, 0xf0, 0x43, 0xb0, 0xa2, 0x3d, 0x84,
110       0x31, 0x94, 0xba, 0x97, 0x2c, 0x66, 0xde, 0xbd },
111     { 0xfa, 0x3b, 0xfd, 0x48, 0x06, 0xeb, 0x53, 0xfa },
112     { 0xf7, 0xfb },
113     { 0x19, 0xdd },
114     { 0x5c, 0x4c, 0x93, 0x31, 0x04, 0x9d, 0x0b, 0xda,
115       0xb0, 0x27, 0x74, 0x08, 0xf6, 0x79, 0x67, 0xe5 }
116  },
117  {
118     16, 16, 8, 5,
119     { 0x01, 0xf7, 0x4a, 0xd6, 0x40, 0x77, 0xf2, 0xe7,
120       0x04, 0xc0, 0xf6, 0x0a, 0xda, 0x3d, 0xd5, 0x23 },
121     { 0x70, 0xc3, 0xdb, 0x4f, 0x0d, 0x26, 0x36, 0x84,
122       0x00, 0xa1, 0x0e, 0xd0, 0x5d, 0x2b, 0xff, 0x5e },
123     { 0x23, 0x4a, 0x34, 0x63, 0xc1, 0x26, 0x4a, 0xc6 },
124     { 0x1a, 0x47, 0xcb, 0x49, 0x33 },
125     { 0xd8, 0x51, 0xd5, 0xba, 0xe0 },
126     { 0x3a, 0x59, 0xf2, 0x38, 0xa2, 0x3e, 0x39, 0x19,
127       0x9d, 0xc9, 0x26, 0x66, 0x26, 0xc4, 0x0f, 0x80 }
128  }
129  };
130     int err, x, idx, res;
131     unsigned long len;
132     unsigned char outct[MAXBLOCKSIZE], outtag[MAXBLOCKSIZE];
133      if ((idx = find_cipher("aes")) == -1) {
134         if ((idx = find_cipher("rijndael")) == -1) {
135            return CRYPT_NOP;
136         }
137      }
138      for (x = 0; x < (int)(sizeof(tests)/sizeof(tests[0])); x++) {
139          len = sizeof(outtag);
140          if ((err = eax_encrypt_authenticate_memory(idx, tests[x].key, tests[x].keylen,
141              tests[x].nonce, tests[x].noncelen, tests[x].header, tests[x].headerlen,
142              tests[x].plaintext, tests[x].msglen, outct, outtag, &len)) != CRYPT_OK) {
143             return err;
144          }
145          if (compare_testvector(outtag, len, tests[x].tag, len, "EAX Tag", x) ||
146                compare_testvector(outct, tests[x].msglen, tests[x].ciphertext, tests[x].msglen, "EAX CT", x)) {
147             return CRYPT_FAIL_TESTVECTOR;
148          }
149          if ((err = eax_decrypt_verify_memory(idx, tests[x].key, tests[x].keylen,
150               tests[x].nonce, tests[x].noncelen, tests[x].header, tests[x].headerlen,
151               outct, tests[x].msglen, outct, outtag, len, &res)) != CRYPT_OK) {
152              return err;
153          }
154          if ((res != 1) || compare_testvector(outct, tests[x].msglen, tests[x].plaintext, tests[x].msglen, "EAX", x)) {
155  #ifdef LTC_TEST_DBG
156             printf("\n\nEAX: Failure-decrypt - res = %d\n", res);
157  #endif
158             return CRYPT_FAIL_TESTVECTOR;
159          }
160      }
161      return CRYPT_OK;
162  #endif &bsol;* LTC_TEST */
163  }
164  #endif &bsol;* LTC_EAX_MODE */
</code></pre>
        </div>
        <div class="column">
            <h3>libtomcrypt-MDEwOlJlcG9zaXRvcnk3NzcwMTE=-flat-rmd160.c</h3>
            <pre><code>1  #include "tomcrypt_private.h"
2  #ifdef LTC_RIPEMD160
3  const struct ltc_hash_descriptor rmd160_desc =
4  {
5      "rmd160",
6      9,
7      20,
8      64,
9     { 1, 3, 36, 3, 2, 1,  },
10     6,
11      &rmd160_init,
12      &rmd160_process,
13      &rmd160_done,
14      &rmd160_test,
15      NULL
16  };
17  #define F(x, y, z)        ((x) ^ (y) ^ (z))
18  #define G(x, y, z)        (((x) & (y)) | (~(x) & (z)))
19  #define H(x, y, z)        (((x) | ~(y)) ^ (z))
20  #define I(x, y, z)        (((x) & (z)) | ((y) & ~(z)))
21  #define J(x, y, z)        ((x) ^ ((y) | ~(z)))
22  #define FF(a, b, c, d, e, x, s)        \
23        (a) += F((b), (c), (d)) + (x);\
24        (a) = ROLc((a), (s)) + (e);\
25        (c) = ROLc((c), 10);
26  #define GG(a, b, c, d, e, x, s)        \
27        (a) += G((b), (c), (d)) + (x) + 0x5a827999UL;\
28        (a) = ROLc((a), (s)) + (e);\
29        (c) = ROLc((c), 10);
30  #define HH(a, b, c, d, e, x, s)        \
31        (a) += H((b), (c), (d)) + (x) + 0x6ed9eba1UL;\
32        (a) = ROLc((a), (s)) + (e);\
33        (c) = ROLc((c), 10);
34  #define II(a, b, c, d, e, x, s)        \
35        (a) += I((b), (c), (d)) + (x) + 0x8f1bbcdcUL;\
36        (a) = ROLc((a), (s)) + (e);\
37        (c) = ROLc((c), 10);
38  #define JJ(a, b, c, d, e, x, s)        \
39        (a) += J((b), (c), (d)) + (x) + 0xa953fd4eUL;\
40        (a) = ROLc((a), (s)) + (e);\
41        (c) = ROLc((c), 10);
42  #define FFF(a, b, c, d, e, x, s)        \
43        (a) += F((b), (c), (d)) + (x);\
44        (a) = ROLc((a), (s)) + (e);\
45        (c) = ROLc((c), 10);
46  #define GGG(a, b, c, d, e, x, s)        \
47        (a) += G((b), (c), (d)) + (x) + 0x7a6d76e9UL;\
48        (a) = ROLc((a), (s)) + (e);\
49        (c) = ROLc((c), 10);
50  #define HHH(a, b, c, d, e, x, s)        \
51        (a) += H((b), (c), (d)) + (x) + 0x6d703ef3UL;\
52        (a) = ROLc((a), (s)) + (e);\
53        (c) = ROLc((c), 10);
54  #define III(a, b, c, d, e, x, s)        \
55        (a) += I((b), (c), (d)) + (x) + 0x5c4dd124UL;\
56        (a) = ROLc((a), (s)) + (e);\
57        (c) = ROLc((c), 10);
58  #define JJJ(a, b, c, d, e, x, s)        \
59        (a) += J((b), (c), (d)) + (x) + 0x50a28be6UL;\
60        (a) = ROLc((a), (s)) + (e);\
61        (c) = ROLc((c), 10);
62  #ifdef LTC_CLEAN_STACK
63  static int ss_rmd160_compress(hash_state *md, const unsigned char *buf)
64  #else
65  static int  s_rmd160_compress(hash_state *md, const unsigned char *buf)
66  #endif
67  {
68     ulong32 aa,bb,cc,dd,ee,aaa,bbb,ccc,ddd,eee,X[16];
69     int i;
70     for (i = 0; i < 16; i++){
71        LOAD32L(X[i], buf + (4 * i));
72     }
73     aa = aaa = md->rmd160.state[0];
74     bb = bbb = md->rmd160.state[1];
75     cc = ccc = md->rmd160.state[2];
76     dd = ddd = md->rmd160.state[3];
77     ee = eee = md->rmd160.state[4];
78     FF(aa, bb, cc, dd, ee, X[ 0], 11);
79     FF(ee, aa, bb, cc, dd, X[ 1], 14);
80     FF(dd, ee, aa, bb, cc, X[ 2], 15);
81     FF(cc, dd, ee, aa, bb, X[ 3], 12);
82     FF(bb, cc, dd, ee, aa, X[ 4],  5);
83     FF(aa, bb, cc, dd, ee, X[ 5],  8);
84     FF(ee, aa, bb, cc, dd, X[ 6],  7);
85     FF(dd, ee, aa, bb, cc, X[ 7],  9);
86     FF(cc, dd, ee, aa, bb, X[ 8], 11);
87     FF(bb, cc, dd, ee, aa, X[ 9], 13);
88     FF(aa, bb, cc, dd, ee, X[10], 14);
89     FF(ee, aa, bb, cc, dd, X[11], 15);
90     FF(dd, ee, aa, bb, cc, X[12],  6);
91     FF(cc, dd, ee, aa, bb, X[13],  7);
92     FF(bb, cc, dd, ee, aa, X[14],  9);
93     FF(aa, bb, cc, dd, ee, X[15],  8);
94     GG(ee, aa, bb, cc, dd, X[ 7],  7);
95     GG(dd, ee, aa, bb, cc, X[ 4],  6);
96     GG(cc, dd, ee, aa, bb, X[13],  8);
97     GG(bb, cc, dd, ee, aa, X[ 1], 13);
98     GG(aa, bb, cc, dd, ee, X[10], 11);
99     GG(ee, aa, bb, cc, dd, X[ 6],  9);
100     GG(dd, ee, aa, bb, cc, X[15],  7);
101     GG(cc, dd, ee, aa, bb, X[ 3], 15);
102     GG(bb, cc, dd, ee, aa, X[12],  7);
103     GG(aa, bb, cc, dd, ee, X[ 0], 12);
104     GG(ee, aa, bb, cc, dd, X[ 9], 15);
105     GG(dd, ee, aa, bb, cc, X[ 5],  9);
106     GG(cc, dd, ee, aa, bb, X[ 2], 11);
107     GG(bb, cc, dd, ee, aa, X[14],  7);
108     GG(aa, bb, cc, dd, ee, X[11], 13);
109     GG(ee, aa, bb, cc, dd, X[ 8], 12);
110     HH(dd, ee, aa, bb, cc, X[ 3], 11);
111     HH(cc, dd, ee, aa, bb, X[10], 13);
112     HH(bb, cc, dd, ee, aa, X[14],  6);
113     HH(aa, bb, cc, dd, ee, X[ 4],  7);
114     HH(ee, aa, bb, cc, dd, X[ 9], 14);
115     HH(dd, ee, aa, bb, cc, X[15],  9);
116     HH(cc, dd, ee, aa, bb, X[ 8], 13);
117     HH(bb, cc, dd, ee, aa, X[ 1], 15);
118     HH(aa, bb, cc, dd, ee, X[ 2], 14);
119     HH(ee, aa, bb, cc, dd, X[ 7],  8);
120     HH(dd, ee, aa, bb, cc, X[ 0], 13);
121     HH(cc, dd, ee, aa, bb, X[ 6],  6);
122     HH(bb, cc, dd, ee, aa, X[13],  5);
123     HH(aa, bb, cc, dd, ee, X[11], 12);
124     HH(ee, aa, bb, cc, dd, X[ 5],  7);
125     HH(dd, ee, aa, bb, cc, X[12],  5);
126     II(cc, dd, ee, aa, bb, X[ 1], 11);
127     II(bb, cc, dd, ee, aa, X[ 9], 12);
128     II(aa, bb, cc, dd, ee, X[11], 14);
129     II(ee, aa, bb, cc, dd, X[10], 15);
130     II(dd, ee, aa, bb, cc, X[ 0], 14);
131     II(cc, dd, ee, aa, bb, X[ 8], 15);
132     II(bb, cc, dd, ee, aa, X[12],  9);
133     II(aa, bb, cc, dd, ee, X[ 4],  8);
134     II(ee, aa, bb, cc, dd, X[13],  9);
135     II(dd, ee, aa, bb, cc, X[ 3], 14);
136     II(cc, dd, ee, aa, bb, X[ 7],  5);
137     II(bb, cc, dd, ee, aa, X[15],  6);
138     II(aa, bb, cc, dd, ee, X[14],  8);
139     II(ee, aa, bb, cc, dd, X[ 5],  6);
140     II(dd, ee, aa, bb, cc, X[ 6],  5);
141     II(cc, dd, ee, aa, bb, X[ 2], 12);
142     JJ(bb, cc, dd, ee, aa, X[ 4],  9);
143     JJ(aa, bb, cc, dd, ee, X[ 0], 15);
144     JJ(ee, aa, bb, cc, dd, X[ 5],  5);
145     JJ(dd, ee, aa, bb, cc, X[ 9], 11);
146     JJ(cc, dd, ee, aa, bb, X[ 7],  6);
147     JJ(bb, cc, dd, ee, aa, X[12],  8);
148     JJ(aa, bb, cc, dd, ee, X[ 2], 13);
149     JJ(ee, aa, bb, cc, dd, X[10], 12);
150     JJ(dd, ee, aa, bb, cc, X[14],  5);
151     JJ(cc, dd, ee, aa, bb, X[ 1], 12);
152     JJ(bb, cc, dd, ee, aa, X[ 3], 13);
153     JJ(aa, bb, cc, dd, ee, X[ 8], 14);
154     JJ(ee, aa, bb, cc, dd, X[11], 11);
155     JJ(dd, ee, aa, bb, cc, X[ 6],  8);
156     JJ(cc, dd, ee, aa, bb, X[15],  5);
157     JJ(bb, cc, dd, ee, aa, X[13],  6);
158     JJJ(aaa, bbb, ccc, ddd, eee, X[ 5],  8);
159     JJJ(eee, aaa, bbb, ccc, ddd, X[14],  9);
160     JJJ(ddd, eee, aaa, bbb, ccc, X[ 7],  9);
161     JJJ(ccc, ddd, eee, aaa, bbb, X[ 0], 11);
162     JJJ(bbb, ccc, ddd, eee, aaa, X[ 9], 13);
163     JJJ(aaa, bbb, ccc, ddd, eee, X[ 2], 15);
164     JJJ(eee, aaa, bbb, ccc, ddd, X[11], 15);
165     JJJ(ddd, eee, aaa, bbb, ccc, X[ 4],  5);
166     JJJ(ccc, ddd, eee, aaa, bbb, X[13],  7);
167     JJJ(bbb, ccc, ddd, eee, aaa, X[ 6],  7);
168     JJJ(aaa, bbb, ccc, ddd, eee, X[15],  8);
169     JJJ(eee, aaa, bbb, ccc, ddd, X[ 8], 11);
170     JJJ(ddd, eee, aaa, bbb, ccc, X[ 1], 14);
171     JJJ(ccc, ddd, eee, aaa, bbb, X[10], 14);
172     JJJ(bbb, ccc, ddd, eee, aaa, X[ 3], 12);
173     JJJ(aaa, bbb, ccc, ddd, eee, X[12],  6);
174     III(eee, aaa, bbb, ccc, ddd, X[ 6],  9);
175     III(ddd, eee, aaa, bbb, ccc, X[11], 13);
176     III(ccc, ddd, eee, aaa, bbb, X[ 3], 15);
177     III(bbb, ccc, ddd, eee, aaa, X[ 7],  7);
178     III(aaa, bbb, ccc, ddd, eee, X[ 0], 12);
179     III(eee, aaa, bbb, ccc, ddd, X[13],  8);
180     III(ddd, eee, aaa, bbb, ccc, X[ 5],  9);
181     III(ccc, ddd, eee, aaa, bbb, X[10], 11);
182     III(bbb, ccc, ddd, eee, aaa, X[14],  7);
183     III(aaa, bbb, ccc, ddd, eee, X[15],  7);
184     III(eee, aaa, bbb, ccc, ddd, X[ 8], 12);
185     III(ddd, eee, aaa, bbb, ccc, X[12],  7);
186     III(ccc, ddd, eee, aaa, bbb, X[ 4],  6);
187     III(bbb, ccc, ddd, eee, aaa, X[ 9], 15);
188     III(aaa, bbb, ccc, ddd, eee, X[ 1], 13);
189     III(eee, aaa, bbb, ccc, ddd, X[ 2], 11);
190     HHH(ddd, eee, aaa, bbb, ccc, X[15],  9);
191     HHH(ccc, ddd, eee, aaa, bbb, X[ 5],  7);
192     HHH(bbb, ccc, ddd, eee, aaa, X[ 1], 15);
193     HHH(aaa, bbb, ccc, ddd, eee, X[ 3], 11);
194     HHH(eee, aaa, bbb, ccc, ddd, X[ 7],  8);
195     HHH(ddd, eee, aaa, bbb, ccc, X[14],  6);
196     HHH(ccc, ddd, eee, aaa, bbb, X[ 6],  6);
197     HHH(bbb, ccc, ddd, eee, aaa, X[ 9], 14);
198     HHH(aaa, bbb, ccc, ddd, eee, X[11], 12);
199     HHH(eee, aaa, bbb, ccc, ddd, X[ 8], 13);
200     HHH(ddd, eee, aaa, bbb, ccc, X[12],  5);
201     HHH(ccc, ddd, eee, aaa, bbb, X[ 2], 14);
202     HHH(bbb, ccc, ddd, eee, aaa, X[10], 13);
203     HHH(aaa, bbb, ccc, ddd, eee, X[ 0], 13);
204     HHH(eee, aaa, bbb, ccc, ddd, X[ 4],  7);
205     HHH(ddd, eee, aaa, bbb, ccc, X[13],  5);
206     GGG(ccc, ddd, eee, aaa, bbb, X[ 8], 15);
207     GGG(bbb, ccc, ddd, eee, aaa, X[ 6],  5);
208     GGG(aaa, bbb, ccc, ddd, eee, X[ 4],  8);
209     GGG(eee, aaa, bbb, ccc, ddd, X[ 1], 11);
210     GGG(ddd, eee, aaa, bbb, ccc, X[ 3], 14);
211     GGG(ccc, ddd, eee, aaa, bbb, X[11], 14);
212     GGG(bbb, ccc, ddd, eee, aaa, X[15],  6);
213     GGG(aaa, bbb, ccc, ddd, eee, X[ 0], 14);
214     GGG(eee, aaa, bbb, ccc, ddd, X[ 5],  6);
215     GGG(ddd, eee, aaa, bbb, ccc, X[12],  9);
216     GGG(ccc, ddd, eee, aaa, bbb, X[ 2], 12);
217     GGG(bbb, ccc, ddd, eee, aaa, X[13],  9);
218     GGG(aaa, bbb, ccc, ddd, eee, X[ 9], 12);
219     GGG(eee, aaa, bbb, ccc, ddd, X[ 7],  5);
220     GGG(ddd, eee, aaa, bbb, ccc, X[10], 15);
221     GGG(ccc, ddd, eee, aaa, bbb, X[14],  8);
222     FFF(bbb, ccc, ddd, eee, aaa, X[12] ,  8);
223     FFF(aaa, bbb, ccc, ddd, eee, X[15] ,  5);
224     FFF(eee, aaa, bbb, ccc, ddd, X[10] , 12);
225     FFF(ddd, eee, aaa, bbb, ccc, X[ 4] ,  9);
226     FFF(ccc, ddd, eee, aaa, bbb, X[ 1] , 12);
227     FFF(bbb, ccc, ddd, eee, aaa, X[ 5] ,  5);
228     FFF(aaa, bbb, ccc, ddd, eee, X[ 8] , 14);
229     FFF(eee, aaa, bbb, ccc, ddd, X[ 7] ,  6);
230     FFF(ddd, eee, aaa, bbb, ccc, X[ 6] ,  8);
231     FFF(ccc, ddd, eee, aaa, bbb, X[ 2] , 13);
232     FFF(bbb, ccc, ddd, eee, aaa, X[13] ,  6);
233     FFF(aaa, bbb, ccc, ddd, eee, X[14] ,  5);
234     FFF(eee, aaa, bbb, ccc, ddd, X[ 0] , 15);
235     FFF(ddd, eee, aaa, bbb, ccc, X[ 3] , 13);
236     FFF(ccc, ddd, eee, aaa, bbb, X[ 9] , 11);
237     FFF(bbb, ccc, ddd, eee, aaa, X[11] , 11);
238     ddd += cc + md->rmd160.state[1];               &bsol;* final result for md->rmd160.state[0] */
239     md->rmd160.state[1] = md->rmd160.state[2] + dd + eee;
240     md->rmd160.state[2] = md->rmd160.state[3] + ee + aaa;
241     md->rmd160.state[3] = md->rmd160.state[4] + aa + bbb;
242     md->rmd160.state[4] = md->rmd160.state[0] + bb + ccc;
243     md->rmd160.state[0] = ddd;
244     return CRYPT_OK;
245  }
246  #ifdef LTC_CLEAN_STACK
247  static int s_rmd160_compress(hash_state *md, const unsigned char *buf)
248  {
249     int err;
250     err = ss_rmd160_compress(md, buf);
251     burn_stack(sizeof(ulong32) * 26 + sizeof(int));
252     return err;
253  }
254  #endif
255  int rmd160_init(hash_state * md)
256  {
257     LTC_ARGCHK(md != NULL);
258     md->rmd160.state[0] = 0x67452301UL;
259     md->rmd160.state[1] = 0xefcdab89UL;
260     md->rmd160.state[2] = 0x98badcfeUL;
261     md->rmd160.state[3] = 0x10325476UL;
262     md->rmd160.state[4] = 0xc3d2e1f0UL;
263     md->rmd160.curlen   = 0;
264     md->rmd160.length   = 0;
265     return CRYPT_OK;
266  }
267  HASH_PROCESS(rmd160_process, s_rmd160_compress, rmd160, 64)
268  int rmd160_done(hash_state * md, unsigned char *out)
269  {
270      int i;
271      LTC_ARGCHK(md  != NULL);
272      LTC_ARGCHK(out != NULL);
273      if (md->rmd160.curlen >= sizeof(md->rmd160.buf)) {
274         return CRYPT_INVALID_ARG;
275      }
276      md->rmd160.length += md->rmd160.curlen * 8;
277      md->rmd160.buf[md->rmd160.curlen++] = (unsigned char)0x80;
278      if (md->rmd160.curlen > 56) {
279          while (md->rmd160.curlen < 64) {
280              md->rmd160.buf[md->rmd160.curlen++] = (unsigned char)0;
281          }
282          s_rmd160_compress(md, md->rmd160.buf);
283          md->rmd160.curlen = 0;
284      }
285      while (md->rmd160.curlen < 56) {
286          md->rmd160.buf[md->rmd160.curlen++] = (unsigned char)0;
287      }
288      STORE64L(md->rmd160.length, md->rmd160.buf+56);
289      s_rmd160_compress(md, md->rmd160.buf);
290      for (i = 0; i < 5; i++) {
291          STORE32L(md->rmd160.state[i], out+(4*i));
292      }
293  #ifdef LTC_CLEAN_STACK
294      zeromem(md, sizeof(hash_state));
295  #endif
296      return CRYPT_OK;
297  }
298  int rmd160_test(void)
299  {
300  #ifndef LTC_TEST
301     return CRYPT_NOP;
302  #else
303     static const struct {
<span onclick='openModal()' class='match'>304          const char *msg;
305          unsigned char hash[20];
306     } tests[] = {
307     { "",
308       { 0x9c, 0x11, 0x85, 0xa5, 0xc5, 0xe9, 0xfc, 0x54, 0x61, 0x28,
309         0x08, 0x97, 0x7e, 0xe8, 0xf5, 0x48, 0xb2, 0x25, 0x8d, 0x31 }
</span>310     },
311     { "a",
312       { 0x0b, 0xdc, 0x9d, 0x2d, 0x25, 0x6b, 0x3e, 0xe9, 0xda, 0xae,
313         0x34, 0x7b, 0xe6, 0xf4, 0xdc, 0x83, 0x5a, 0x46, 0x7f, 0xfe }
314     },
315     { "abc",
316       { 0x8e, 0xb2, 0x08, 0xf7, 0xe0, 0x5d, 0x98, 0x7a, 0x9b, 0x04,
317         0x4a, 0x8e, 0x98, 0xc6, 0xb0, 0x87, 0xf1, 0x5a, 0x0b, 0xfc }
318     },
319     { "message digest",
320       { 0x5d, 0x06, 0x89, 0xef, 0x49, 0xd2, 0xfa, 0xe5, 0x72, 0xb8,
321         0x81, 0xb1, 0x23, 0xa8, 0x5f, 0xfa, 0x21, 0x59, 0x5f, 0x36 }
322     },
323     { "abcdefghijklmnopqrstuvwxyz",
324       { 0xf7, 0x1c, 0x27, 0x10, 0x9c, 0x69, 0x2c, 0x1b, 0x56, 0xbb,
325         0xdc, 0xeb, 0x5b, 0x9d, 0x28, 0x65, 0xb3, 0x70, 0x8d, 0xbc }
326     },
327     { "abcdbcdecdefdefgefghfghighijhijkijkljklmklmnlmnomnopnopq",
328       { 0x12, 0xa0, 0x53, 0x38, 0x4a, 0x9c, 0x0c, 0x88, 0xe4, 0x05,
329         0xa0, 0x6c, 0x27, 0xdc, 0xf4, 0x9a, 0xda, 0x62, 0xeb, 0x2b }
330     }
331     };
332     int i;
333     unsigned char tmp[20];
334     hash_state md;
335     for (i = 0; i < (int)(sizeof(tests)/sizeof(tests[0])); i++) {
336         rmd160_init(&md);
337         rmd160_process(&md, (unsigned char *)tests[i].msg, XSTRLEN(tests[i].msg));
338         rmd160_done(&md, tmp);
339         if (compare_testvector(tmp, sizeof(tmp), tests[i].hash, sizeof(tests[i].hash), "RIPEMD160", i)) {
340            return CRYPT_FAIL_TESTVECTOR;
341         }
342     }
343     return CRYPT_OK;
344  #endif
345  }
346  #endif
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from libtomcrypt-MDEwOlJlcG9zaXRvcnk3NzcwMTE=-flat-eax_test.c</div>
                <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from libtomcrypt-MDEwOlJlcG9zaXRvcnk3NzcwMTE=-flat-rmd160.c</div>
                <div class="column column_space"><pre><code>9         int               keylen,
10                         noncelen,
11                        headerlen,
12                           msglen;
13         unsigned char        key[MAXBLOCKSIZE],
14                            nonce[MAXBLOCKSIZE],
15                           header[MAXBLOCKSIZE],
16                        plaintext[MAXBLOCKSIZE],
17                       ciphertext[MAXBLOCKSIZE],
18                              tag[MAXBLOCKSIZE];
19     } tests[] = {
20  {
21     16, 0, 0, 0,
22     { 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
23       0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f },
</pre></code></div>
                <div class="column column_space"><pre><code>304          const char *msg;
305          unsigned char hash[20];
306     } tests[] = {
307     { "",
308       { 0x9c, 0x11, 0x85, 0xa5, 0xc5, 0xe9, 0xfc, 0x54, 0x61, 0x28,
309         0x08, 0x97, 0x7e, 0xe8, 0xf5, 0x48, 0xb2, 0x25, 0x8d, 0x31 }
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    