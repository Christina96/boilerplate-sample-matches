
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 4.054054054054054%, Tokens: 9</h2>
        <div class="column">
            <h3>libtomcrypt-MDEwOlJlcG9zaXRvcnk3NzcwMTE=-flat-pkcs_1_oaep_encode.c</h3>
            <pre><code>1  #include "tomcrypt_private.h"
2  #ifdef LTC_PKCS_1
3  int pkcs_1_oaep_encode(const unsigned char *msg,    unsigned long msglen,
4                         const unsigned char *lparam, unsigned long lparamlen,
5                               unsigned long modulus_bitlen, prng_state *prng,
6                               int           prng_idx,         int  hash_idx,
7                               unsigned char *out,    unsigned long *outlen)
8  {
9     unsigned char *DB, *seed, *mask;
10     unsigned long hLen, x, y, modulus_len;
11     int           err;
12     LTC_ARGCHK((msglen == 0) || (msg != NULL));
13     LTC_ARGCHK(out    != NULL);
14     LTC_ARGCHK(outlen != NULL);
15     if ((err = hash_is_valid(hash_idx)) != CRYPT_OK) {
16        return err;
17     }
18     if ((err = prng_is_valid(prng_idx)) != CRYPT_OK) {
19        return err;
20     }
21     hLen        = hash_descriptor[hash_idx].hashsize;
22     modulus_len = (modulus_bitlen >> 3) + (modulus_bitlen & 7 ? 1 : 0);
23     if ((2*hLen >= (modulus_len - 2)) || (msglen > (modulus_len - 2*hLen - 2))) {
24        return CRYPT_PK_INVALID_SIZE;
25     }
26     DB   = XMALLOC(modulus_len);
27     mask = XMALLOC(modulus_len);
28     seed = XMALLOC(hLen);
29     if (DB == NULL || mask == NULL || seed == NULL) {
30        if (DB != NULL) {
31           XFREE(DB);
32        }
33        if (mask != NULL) {
34           XFREE(mask);
35        }
36        if (seed != NULL) {
37           XFREE(seed);
38        }
39        return CRYPT_MEM;
40     }
41     x = modulus_len;
42     if (lparam != NULL) {
43        if ((err = hash_memory(hash_idx, lparam, lparamlen, DB, &x)) != CRYPT_OK) {
44           goto LBL_ERR;
45        }
46     } else {
47        if ((err = hash_memory(hash_idx, DB, 0, DB, &x)) != CRYPT_OK) {
48           goto LBL_ERR;
49        }
50     }
51     x = hLen;
52     y = modulus_len - msglen - 2*hLen - 2;
53     XMEMSET(DB+x, 0, y);
54     x += y;
55     DB[x++] = 0x01;
56     if (msglen != 0) {
57        XMEMCPY(DB+x, msg, msglen);
58        x += msglen;
59     }
60     if (prng_descriptor[prng_idx].read(seed, hLen, prng) != hLen) {
61        err = CRYPT_ERROR_READPRNG;
62        goto LBL_ERR;
63     }
<span onclick='openModal()' class='match'>64     if ((err = pkcs_1_mgf1(hash_idx, seed, hLen, mask, modulus_len - hLen - 1)) != CRYPT_OK) {
65        goto LBL_ERR;
66     }
67     for (y = 0; y < (modulus_len - hLen - 1); y++) {
68         DB[y] ^= mask[y];
69     }
</span>70     if ((err = pkcs_1_mgf1(hash_idx, DB, modulus_len - hLen - 1, mask, hLen)) != CRYPT_OK) {
71        goto LBL_ERR;
72     }
73     for (y = 0; y < hLen; y++) {
74        seed[y] ^= mask[y];
75     }
76     if (*outlen < modulus_len) {
77        *outlen = modulus_len;
78        err = CRYPT_BUFFER_OVERFLOW;
79        goto LBL_ERR;
80     }
81     x = 0;
82     out[x++] = 0x00;
83     XMEMCPY(out+x, seed, hLen);
84     x += hLen;
85     XMEMCPY(out+x, DB, modulus_len - hLen - 1);
86     x += modulus_len - hLen - 1;
87     *outlen = x;
88     err = CRYPT_OK;
89  LBL_ERR:
90  #ifdef LTC_CLEAN_STACK
91     zeromem(DB,   modulus_len);
92     zeromem(seed, hLen);
93     zeromem(mask, modulus_len);
94  #endif
95     XFREE(seed);
96     XFREE(mask);
97     XFREE(DB);
98     return err;
99  }
100  #endif &bsol;* LTC_PKCS_1 */
</code></pre>
        </div>
        <div class="column">
            <h3>libtomcrypt-MDEwOlJlcG9zaXRvcnk3NzcwMTE=-flat-hashsum.c</h3>
            <pre><code>1  #include <tomcrypt.h>
2  #if defined(_POSIX_C_SOURCE) && _POSIX_C_SOURCE >= 200112L
3  #include <libgen.h>
4  #else
5  #define basename(x) x
6  #endif
7  #if !defined(PATH_MAX) && defined(_MSC_VER)
8  #include <windows.h>
9  #define PATH_MAX MAX_PATH
10  #endif
11  #define s_base(x) ((x >= '0' && x <= '9') ? '0' : \
12           (x >= 'a' && x <= 'f') ? 'a' - 10 : \
13           (x >= 'A' && x <= 'F') ? 'A' - 10 : \
14              '\255')
15  #define HEXOF(x) (x - s_base(x))
16  static char* hashsum;
17  static void cleanup(void)
18  {
19     free(hashsum);
20  }
21  static void die(int status)
22  {
23     unsigned long w, x;
24     FILE* o = status == EXIT_SUCCESS ? stdout : stderr;
25     fprintf(o, "usage: %s -a algorithm [-c] [file...]\n\n", hashsum);
26     fprintf(o, "\t-c\tCheck the hash(es) of the file(s) written in [file].\n");
27     fprintf(o, "\t\t(-a not required)\n");
28     fprintf(o, "\nAlgorithms:\n\t");
29     w = 0;
30     for (x = 0; hash_descriptor[x].name != NULL; x++) {
31        w += fprintf(o, "%-14s", hash_descriptor[x].name);
32        if (w >= 70) {
33           fprintf(o, "\n\t");
34           w = 0;
35        }
36     }
37     if (w != 0) fprintf(o, "\n");
38     exit(status);
39  }
40  static void printf_hex(unsigned char* hash_buffer, unsigned long w)
41  {
42     unsigned long x;
43     for (x = 0; x < w; x++) {
44         printf("%02x",hash_buffer[x]);
45     }
46  }
47  static void check_file(int argn, int argc, char **argv)
48  {
49     int err, failed, invalid;
50     unsigned char is_buffer[MAXBLOCKSIZE], should_buffer[MAXBLOCKSIZE];
51     char buf[PATH_MAX + (MAXBLOCKSIZE * 3)];
52     while(argn < argc) {
53        char* s;
54        FILE* f = fopen(argv[argn], "rb");
55        if(f == NULL) {
56           int n = snprintf(buf, sizeof(buf), "%s: %s", hashsum, argv[argn]);
57           if (n > 0 && n < (int)sizeof(buf))
58              perror(buf);
59           else
60              perror(argv[argn]);
61           exit(EXIT_FAILURE);
62        }
63        failed = 0;
64        invalid = 0;
65        while((s = fgets(buf, sizeof(buf), f)) != NULL)
66        {
67           int tries, n;
68           unsigned long hash_len, w, x;
69           char* space = strstr(s, " ");
70           if (buf[0] == '#') continue;
71           if (space == NULL) {
72              fprintf(stderr, "%s: no properly formatted checksum lines found\n", hashsum);
73              goto ERR;
74           }
75           hash_len = space - s;
76           hash_len /= 2;
<span onclick='openModal()' class='match'>77           if (hash_len > sizeof(should_buffer)) {
78              fprintf(stderr, "%s: hash too long\n", hashsum);
79              goto ERR;
80           }
81           for (x = 0; x < hash_len; ++x) {
82              should_buffer[x] = HEXOF(s[x*2]) << 4 | HEXOF(s[x*2 + 1]);
83           }
</span>84           space++;
85           if (*space != '*') {
86              fprintf(stderr, "%s: unsupported input mode '%c'\n", hashsum, *space);
87              goto ERR;
88           }
89           space++;
90           for (n = 0; n < (buf + sizeof(buf)) - space; ++n) {
91              if(iscntrl((int)space[n])) {
92                 space[n] = '\0';
93                 break;
94              }
95           }
96           tries = 0;
97           for (x = 0; hash_descriptor[x].name != NULL; ++x) {
98              if (hash_descriptor[x].hashsize == hash_len) {
99                 tries++;
100                 w = sizeof(is_buffer);
101                 if ((err = hash_file(x, space, is_buffer, &w)) != CRYPT_OK) {
102                    fprintf(stderr, "%s: File hash error: %s: %s\n", hashsum, space, error_to_string(err));
103  ERR:
104                    fclose(f);
105                    exit(EXIT_FAILURE);
106                 }
107                 if(XMEMCMP(should_buffer, is_buffer, w) == 0) {
108                    printf("%s: OK\n", space);
109                    break;
110                 }
111              }
112           } &bsol;* for */
113           if (hash_descriptor[x].name == NULL) {
114              if(tries > 0) {
115                 printf("%s: FAILED\n", space);
116                 failed++;
117              }
118              else {
119                 invalid++;
120              }
121           }
122        } &bsol;* while */
123        fclose(f);
124        if(invalid) {
125           fprintf(stderr, "%s: WARNING: %d %s is improperly formatted\n", hashsum, invalid, invalid > 1?"lines":"line");
126        }
127        if(failed) {
128           fprintf(stderr, "%s: WARNING: %d computed %s did NOT match\n", hashsum, failed, failed > 1?"checksums":"checksum");
129        }
130        argn++;
131     }
132     exit(EXIT_SUCCESS);
133  }
134  int main(int argc, char **argv)
135  {
136     int idxs[TAB_SIZE], idx, check, y, z, err, argn;
137     unsigned long w, x;
138     unsigned char hash_buffer[MAXBLOCKSIZE];
139     hashsum = strdup(basename(argv[0]));
140     atexit(cleanup);
141     register_all_ciphers();
142     register_all_hashes();
143     if (argc > 1 && (strcmp("-h", argv[1]) == 0 || strcmp("--help", argv[1]) == 0)) {
144        die(EXIT_SUCCESS);
145     }
146     if (argc < 3) {
147        die(EXIT_FAILURE);
148     }
149     for (x = 0; x < sizeof(idxs)/sizeof(idxs[0]); ++x) {
150        idxs[x] = -2;
151     }
152     argn = 1;
153     check = 0;
154     idx = 0;
155     while(argn < argc){
156        if(strcmp("-a", argv[argn]) == 0) {
157           argn++;
158           if(argn < argc) {
159              idxs[idx] = find_hash(argv[argn]);
160              if (idxs[idx] == -1) {
161                 struct {
162                    const char* is;
163                    const char* should;
164                 } shasum_compat[] =
165                       {
166  #ifdef LTC_SHA1
167                             { "1",        sha1_desc.name },
168  #endif
169  #ifdef LTC_SHA224
170                             { "224",      sha224_desc.name  },
171  #endif
172  #ifdef LTC_SHA256
173                             { "256",      sha256_desc.name  },
174  #endif
175  #ifdef LTC_SHA384
176                             { "384",      sha384_desc.name  },
177  #endif
178  #ifdef LTC_SHA512
179                             { "512",      sha512_desc.name  },
180  #endif
181  #ifdef LTC_SHA512_224
182                             { "512224",   sha512_224_desc.name  },
183  #endif
184  #ifdef LTC_SHA512_256
185                             { "512256",   sha512_256_desc.name  },
186  #endif
187                             { NULL, NULL }
188                       };
189                 for (x = 0; shasum_compat[x].is != NULL; ++x) {
190                    if(XSTRCMP(shasum_compat[x].is, argv[argn]) == 0) {
191                       idxs[idx] = find_hash(shasum_compat[x].should);
192                       break;
193                    }
194                 }
195              }
196              if (idxs[idx] == -1) {
197                 fprintf(stderr, "%s: Unrecognized algorithm\n", hashsum);
198                 die(EXIT_FAILURE);
199              }
200              idx++;
201              if ((size_t)idx >= sizeof(idxs)/sizeof(idxs[0])) {
202                 fprintf(stderr, "%s: Too many '-a' options chosen\n", hashsum);
203                 die(EXIT_FAILURE);
204              }
205              argn++;
206              continue;
207           }
208           else {
209              die(EXIT_FAILURE);
210           }
211        }
212        if(strcmp("-c", argv[argn]) == 0) {
213           check = 1;
214           argn++;
215           continue;
216        }
217        break;
218     }
219     if (check == 1) {
220        check_file(argn, argc, argv);
221     }
222     if (argc == argn) {
223        w = sizeof(hash_buffer);
224        if ((err = hash_filehandle(idxs[0], stdin, hash_buffer, &w)) != CRYPT_OK) {
225           fprintf(stderr, "%s: File hash error: %s\n", hashsum, error_to_string(err));
226           return EXIT_FAILURE;
227        } else {
228            for (x = 0; x < w; x++) {
229                printf("%02x",hash_buffer[x]);
230            }
231            printf(" *-\n");
232        }
233     } else {
234        for (z = argn; z < argc; z++) {
235           for (y = 0; y < idx; ++y) {
236              w = sizeof(hash_buffer);
237              if ((err = hash_file(idxs[y],argv[z],hash_buffer,&w)) != CRYPT_OK) {
238                 fprintf(stderr, "%s: File hash error: %s\n", hashsum, error_to_string(err));
239                 return EXIT_FAILURE;
240              } else {
241                  printf_hex(hash_buffer, w);
242                  printf(" *%s\n", argv[z]);
243              }
244           }
245        }
246     }
247     return EXIT_SUCCESS;
248  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from libtomcrypt-MDEwOlJlcG9zaXRvcnk3NzcwMTE=-flat-pkcs_1_oaep_encode.c</div>
                <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from libtomcrypt-MDEwOlJlcG9zaXRvcnk3NzcwMTE=-flat-hashsum.c</div>
                <div class="column column_space"><pre><code>64     if ((err = pkcs_1_mgf1(hash_idx, seed, hLen, mask, modulus_len - hLen - 1)) != CRYPT_OK) {
65        goto LBL_ERR;
66     }
67     for (y = 0; y < (modulus_len - hLen - 1); y++) {
68         DB[y] ^= mask[y];
69     }
</pre></code></div>
                <div class="column column_space"><pre><code>77           if (hash_len > sizeof(should_buffer)) {
78              fprintf(stderr, "%s: hash too long\n", hashsum);
79              goto ERR;
80           }
81           for (x = 0; x < hash_len; ++x) {
82              should_buffer[x] = HEXOF(s[x*2]) << 4 | HEXOF(s[x*2 + 1]);
83           }
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    