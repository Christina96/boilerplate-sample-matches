<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for countlines.c &amp; source.c</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for countlines.c &amp; source.c
      </h3>
<h1 align="center">
        5.2%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>countlines.c (21.428572%)<th>source.c (3.006012%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(120-136)<td><a href="#" name="0">(364-378)</a><td align="center"><font color="#ff0000">15</font>
</td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>countlines.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
#ifdef HAVE_CONFIG_H
#include &lt;config.h&gt;
#include &lt;vips/intl.h&gt;
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;vips/vips.h&gt;
#include &lt;vips/internal.h&gt;
#include &lt;vips/debug.h&gt;
#include "pmorphology.h"
typedef struct _VipsCountlines {
	VipsMorphology parent_instance;
	double nolines;
	VipsDirection direction;
} VipsCountlines;
typedef VipsMorphologyClass VipsCountlinesClass;
G_DEFINE_TYPE( VipsCountlines, vips_countlines, VIPS_TYPE_MORPHOLOGY );
static int
vips_countlines_build( VipsObject *object )
{
	VipsMorphology *morphology = VIPS_MORPHOLOGY( object );
	VipsCountlines *countlines = (VipsCountlines *) object;
	VipsImage *in = morphology-&gt;in;
	VipsImage **t = (VipsImage **) vips_object_local_array( object, 7 );
	double nolines;
	if( VIPS_OBJECT_CLASS( vips_countlines_parent_class )-&gt;build( object ) )
		return( -1 );
	nolines = 1;
	switch( countlines-&gt;direction ) {
	case VIPS_DIRECTION_HORIZONTAL:
		if( !(t[0] = vips_image_new_matrixv( 1, 2, -1.0, 1.0 )) ||
			vips_moreeq_const1( in, &amp;t[1], 128, NULL ) ||
			vips_conv( t[1], &amp;t[2], t[0], 
				"precision", VIPS_PRECISION_INTEGER,
				NULL ) ||
			vips_project( t[2], &amp;t[3], &amp;t[4], NULL ) ||
			vips_avg( t[3], &amp;nolines, NULL ) )
			return( -1 ); 
		break;
	case VIPS_DIRECTION_VERTICAL:
		if( !(t[0] = vips_image_new_matrixv( 2, 1, -1.0, 1.0 )) ||
			vips_moreeq_const1( in, &amp;t[1], 128, NULL ) ||
			vips_conv( t[1], &amp;t[2], t[0], 
				"precision", VIPS_PRECISION_INTEGER,
				NULL ) ||
			vips_project( t[2], &amp;t[3], &amp;t[4], NULL ) ||
			vips_avg( t[4], &amp;nolines, NULL ) )
			return( -1 ); 
		break;
	default:
		g_assert_not_reached();
	}
<a name="0"></a>
	g_object_set( object, "nolines", nolines / 255.0, NULL );
<font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>	return( 0 );
}
static void
vips_countlines_class_init( VipsCountlinesClass *class )
{
	GObjectClass *gobject_class = G_OBJECT_CLASS( class );
	VipsObjectClass *vobject_class = VIPS_OBJECT_CLASS( class );
	VIPS_DEBUG_MSG( "vips_countlines_class_init\n" );
	gobject_class-&gt;set_property = vips_object_set_property;
	gobject_class-&gt;get_property = vips_object_get_property;
	vobject_class-&gt;nickname = "countlines";
	vobject_class-&gt;description = _( "count lines in an image" ); 
	vobject_class-&gt;build = vips_countlines_build;</b></font>
	VIPS_ARG_DOUBLE( class, "nolines", 2, 
		_( "Nolines" ), 
		_( "Number of lines" ),
		VIPS_ARGUMENT_REQUIRED_OUTPUT,
		G_STRUCT_OFFSET( VipsCountlines, nolines ),
		0, 10000000, 0.0 );
	VIPS_ARG_ENUM( class, "direction", 3, 
		_( "direction" ), 
		_( "Countlines left-right or up-down" ),
		VIPS_ARGUMENT_REQUIRED_INPUT,
		G_STRUCT_OFFSET( VipsCountlines, direction ),
		VIPS_TYPE_DIRECTION, VIPS_DIRECTION_HORIZONTAL ); 
}
static void
vips_countlines_init( VipsCountlines *countlines )
{
}
int
vips_countlines( VipsImage *in, double *nolines, 
	VipsDirection direction, ... )
{
	va_list ap;
	int result;
	va_start( ap, direction );
	result = vips_call_split( "countlines", ap, in, nolines, direction );
	va_end( ap );
	return( result );
}
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>source.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
#ifdef HAVE_CONFIG_H
#include &lt;config.h&gt;
#include &lt;vips/intl.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#ifdef HAVE_UNISTD_H
#include &lt;unistd.h&gt;
#include &lt;string.h&gt;
#include &lt;errno.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;sys/stat.h&gt;
#include &lt;fcntl.h&gt;
#include &lt;unistd.h&gt;
#include &lt;vips/vips.h&gt;
#include &lt;vips/internal.h&gt;
#include &lt;vips/debug.h&gt;
#ifdef G_OS_WIN32
#include &lt;io.h&gt;
#if defined(G_PLATFORM_WIN32) || defined(G_WITH_CYGWIN)
#ifndef O_BINARY
#ifdef _O_BINARY
#define O_BINARY _O_BINARY
#ifdef O_BINARY
#define BINARYIZE(M) ((M) | O_BINARY)
#define BINARYIZE(M) (M)
#define MODE_READ BINARYIZE (O_RDONLY)
#define MODE_READWRITE BINARYIZE (O_RDWR)
#define MODE_WRITE BINARYIZE (O_WRONLY | O_CREAT | O_TRUNC)
static gint64 vips__pipe_read_limit = 1024 * 1024 * 1024;
void
vips_pipe_read_limit_set( gint64 limit )
{
	vips__pipe_read_limit = limit;
}
G_DEFINE_TYPE( VipsSource, vips_source, VIPS_TYPE_CONNECTION );
static int
vips_source_test_features( VipsSource *source )
{
	VipsSourceClass *class = VIPS_SOURCE_GET_CLASS( source );
	if( source-&gt;have_tested_seek ) 
		return( 0 );
	source-&gt;have_tested_seek = TRUE;
	VIPS_DEBUG_MSG( "vips_source_test_features: testing seek ..\n" );
	if( vips_source_unminimise( source ) ) 
		return( -1 );
	if( source-&gt;data ||
		class-&gt;seek( source, 0, SEEK_CUR ) != -1 ) { 
		gint64 length;
		VIPS_DEBUG_MSG( "    seekable source\n" );
		if( (length = vips_source_length( source )) == -1 ) 
			return( -1 );
		source-&gt;length = length;
		VIPS_FREEF( g_byte_array_unref, source-&gt;header_bytes ); 
	}
	else {
		VIPS_DEBUG_MSG( "    not seekable\n" );
		source-&gt;is_pipe = TRUE;
	}
	return( 0 );
}
#ifdef TEST_SANITY
static void
vips_source_sanity( VipsSource *source )
{
	if( source-&gt;data ) {
		g_assert( !source-&gt;is_pipe );
		g_assert( source-&gt;read_position &gt;= 0 );
		g_assert( source-&gt;read_position &lt;= source-&gt;length );
		g_assert( !source-&gt;decode || 
			!source-&gt;sniff );
		g_assert( source-&gt;length != -1 );
	}
	else if( source-&gt;is_pipe ) {
		if( source-&gt;decode ) {
			g_assert( !source-&gt;header_bytes );
			g_assert( !source-&gt;sniff );
		}
		else {
			g_assert( source-&gt;header_bytes );
			g_assert( source-&gt;read_position &gt;= 0 );
			g_assert( source-&gt;read_position &lt;= 
			 	source-&gt;header_bytes-&gt;len );
		}
		g_assert( source-&gt;length == -1 );
	}
	else {
		if( source-&gt;decode ) {
			g_assert( !source-&gt;sniff );
		}
		if( source-&gt;have_tested_seek ) { 
			g_assert( source-&gt;length != -1 );
			g_assert( source-&gt;read_position &gt;= 0 );
			g_assert( source-&gt;read_position &lt;= source-&gt;length );
		}
		g_assert( VIPS_CONNECTION( source )-&gt;descriptor != -1 ||
			(VIPS_CONNECTION( source )-&gt;filename &amp;&amp; 
			 VIPS_CONNECTION( source )-&gt;descriptor) );
	}
}
#ifdef TEST_SANITY
#define SANITY( S ) vips_source_sanity( S )
#warning "sanity tests on in source.c"
#define SANITY( S )
static void
vips_source_finalize( GObject *gobject )
{
	VipsSource *source = VIPS_SOURCE( gobject );
#ifdef DEBUG_MINIMISE
	printf( "vips_source_finalize: %p\n", source );
	VIPS_FREEF( g_byte_array_unref, source-&gt;header_bytes ); 
	VIPS_FREEF( g_byte_array_unref, source-&gt;sniff ); 
	if( source-&gt;mmap_baseaddr ) {
		vips__munmap( source-&gt;mmap_baseaddr, source-&gt;mmap_length );
		source-&gt;mmap_baseaddr = NULL;
	}
	G_OBJECT_CLASS( vips_source_parent_class )-&gt;finalize( gobject );
}
static int
vips_source_build( VipsObject *object )
{
	VipsConnection *connection = VIPS_CONNECTION( object );
	VipsSource *source = VIPS_SOURCE( object );
	VIPS_DEBUG_MSG( "vips_source_build: %p\n", source );
	if( VIPS_OBJECT_CLASS( vips_source_parent_class )-&gt;
		build( object ) )
		return( -1 );
	if( vips_object_argument_isset( object, "filename" ) &amp;&amp;
		vips_object_argument_isset( object, "descriptor" ) ) { 
		vips_error( vips_connection_nick( connection ), 
			"%s", _( "don't set 'filename' and 'descriptor'" ) ); 
		return( -1 ); 
	}
	if( vips_object_argument_isset( object, "filename" ) &amp;&amp;
		vips_source_unminimise( source ) )
		return( -1 );
	if( vips_object_argument_isset( object, "descriptor" ) ) {
		connection-&gt;descriptor = dup( connection-&gt;descriptor );
		connection-&gt;close_descriptor = connection-&gt;descriptor;
#ifdef G_OS_WIN32
		_setmode( connection-&gt;descriptor, _O_BINARY );
	}
	if( vips_object_argument_isset( object, "blob" ) ) {
		size_t length;
		if( !(source-&gt;data = vips_blob_get( source-&gt;blob, &amp;length )) )
			return( -1 );
		source-&gt;length = VIPS_MIN( length, G_MAXSSIZE );
	}
	return( 0 );
}
static gint64
vips_source_read_real( VipsSource *source, void *data, size_t length )
{
	VipsConnection *connection = VIPS_CONNECTION( source );
	gint64 bytes_read;
	VIPS_DEBUG_MSG( "vips_source_read_real:\n" );
	do { 
		bytes_read = read( connection-&gt;descriptor, data, length );
	} while( bytes_read &lt; 0 &amp;&amp; errno == EINTR );
	return( bytes_read );
}
static gint64
vips_source_seek_real( VipsSource *source, gint64 offset, int whence )
{
	VipsConnection *connection = VIPS_CONNECTION( source );
	VIPS_DEBUG_MSG( "vips_source_seek_real:\n" );
	if( connection-&gt;descriptor != -1 )
<a name="0"></a>		return( vips__seek_no_error( connection-&gt;descriptor, 
			offset, whence ) );
<font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>	return( -1 );
}
static void
vips_source_class_init( VipsSourceClass *class )
{
	GObjectClass *gobject_class = G_OBJECT_CLASS( class );
	VipsObjectClass *object_class = VIPS_OBJECT_CLASS( class );
	gobject_class-&gt;finalize = vips_source_finalize;
	gobject_class-&gt;set_property = vips_object_set_property;
	gobject_class-&gt;get_property = vips_object_get_property;
	object_class-&gt;nickname = "source";
	object_class-&gt;description = _( "input source" );</b></font>
	object_class-&gt;build = vips_source_build;
	class-&gt;read = vips_source_read_real;
	class-&gt;seek = vips_source_seek_real;
	VIPS_ARG_BOXED( class, "blob", 3, 
		_( "Blob" ),
		_( "Blob to load from" ),
		VIPS_ARGUMENT_OPTIONAL_INPUT, 
		G_STRUCT_OFFSET( VipsSource, blob ),
		VIPS_TYPE_BLOB );
}
static void
vips_source_init( VipsSource *source )
{
	source-&gt;length = -1;
	source-&gt;sniff = g_byte_array_new();
	source-&gt;header_bytes = g_byte_array_new();
}
VipsSource *
vips_source_new_from_descriptor( int descriptor )
{
	VipsSource *source;
	VIPS_DEBUG_MSG( "vips_source_new_from_descriptor: %d\n", 
		descriptor );
	source = VIPS_SOURCE( g_object_new( VIPS_TYPE_SOURCE, 
		"descriptor", descriptor,
		NULL ) );
	if( vips_object_build( VIPS_OBJECT( source ) ) ) {
		VIPS_UNREF( source );
		return( NULL );
	}
	SANITY( source );
	return( source ); 
}
VipsSource *
vips_source_new_from_file( const char *filename )
{
	VipsSource *source;
	VIPS_DEBUG_MSG( "vips_source_new_from_file: %s\n", 
		filename );
	source = VIPS_SOURCE( g_object_new( VIPS_TYPE_SOURCE, 
		"filename", filename,
		NULL ) );
	if( vips_object_build( VIPS_OBJECT( source ) ) ) {
		VIPS_UNREF( source );
		return( NULL );
	}
	SANITY( source );
	return( source ); 
}
VipsSource *
vips_source_new_from_blob( VipsBlob *blob )
{
	VipsSource *source;
	VIPS_DEBUG_MSG( "vips_source_new_from_blob: %p\n", blob ); 
	source = VIPS_SOURCE( g_object_new( VIPS_TYPE_SOURCE, 
		"blob", blob,
		NULL ) );
	if( vips_object_build( VIPS_OBJECT( source ) ) ) {
		VIPS_UNREF( source );
		return( NULL );
	}
	SANITY( source );
	return( source ); 
}
VipsSource *
vips_source_new_from_memory( const void *data, size_t length )
{
	VipsSource *source;
	VipsBlob *blob;
	VIPS_DEBUG_MSG( "vips_source_new_from_buffer: "
		"%p, length = %zd\n", data, length ); 
	blob = vips_blob_new( NULL, data, length );
	source = vips_source_new_from_blob( blob ); 
	vips_area_unref( VIPS_AREA( blob ) );
	SANITY( source );
	return( source ); 
}
VipsSource *
vips_source_new_from_options( const char *options )
{
	VipsSource *source;
	VIPS_DEBUG_MSG( "vips_source_new_from_options: %s\n", options ); 
	source = VIPS_SOURCE( g_object_new( VIPS_TYPE_SOURCE, NULL ) );
	if( vips_object_set_from_string( VIPS_OBJECT( source ), options ) ||
		vips_object_build( VIPS_OBJECT( source ) ) ) {
		VIPS_UNREF( source );
		return( NULL );
	}
	SANITY( source );
	return( source ); 
}
void
vips_source_minimise( VipsSource *source )
{
	VipsConnection *connection = VIPS_CONNECTION( source );
	SANITY( source );
	(void) vips_source_test_features( source );
	if( connection-&gt;filename &amp;&amp;
		connection-&gt;descriptor != -1 &amp;&amp;
		connection-&gt;tracked_descriptor == connection-&gt;descriptor &amp;&amp;
		!source-&gt;is_pipe ) {
#ifdef DEBUG_MINIMISE
		printf( "vips_source_minimise: %p %s\n", 
			source,
			vips_connection_nick( VIPS_CONNECTION( source ) ) );
		vips_tracked_close( connection-&gt;tracked_descriptor );
		connection-&gt;tracked_descriptor = -1;
		connection-&gt;descriptor = -1;
	}
	SANITY( source );
}
int
vips_source_unminimise( VipsSource *source )
{
	VipsConnection *connection = VIPS_CONNECTION( source );
	if( connection-&gt;descriptor == -1 &amp;&amp;
		connection-&gt;tracked_descriptor == -1 &amp;&amp;
		connection-&gt;filename ) {
		int fd;
#ifdef DEBUG_MINIMISE
		printf( "vips_source_unminimise: %p %s\n",
			source,
			vips_connection_nick( VIPS_CONNECTION( source ) ) );
		if( (fd = vips_tracked_open( connection-&gt;filename, 
			MODE_READ, 0 )) == -1 ) {
			vips_error_system( errno, 
				vips_connection_nick( connection ),
				"%s", _( "unable to open for read" ) );
			return( -1 ); 
		}
		connection-&gt;tracked_descriptor = fd;
		connection-&gt;descriptor = fd;
		VIPS_DEBUG_MSG( "vips_source_unminimise: "
			"restoring read position %" G_GINT64_FORMAT "\n", 
			source-&gt;read_position );
		if( vips__seek( connection-&gt;descriptor, 
			source-&gt;read_position, SEEK_SET ) == -1 )
			return( -1 );
	}
	return( 0 );
}
int
vips_source_decode( VipsSource *source )
{
	VIPS_DEBUG_MSG( "vips_source_decode:\n" );
	SANITY( source );
	if( !source-&gt;decode ) {
		source-&gt;decode = TRUE;
		VIPS_FREEF( g_byte_array_unref, source-&gt;sniff ); 
		if( source-&gt;is_pipe ) 
			VIPS_FREEF( g_byte_array_unref, source-&gt;header_bytes ); 
	}
	vips_source_minimise( source );
	SANITY( source );
	return( 0 );
}
#ifdef VIPS_DEBUG
static void
vips_source_print( VipsSource *source )
{
	printf( "vips_source_print: %p\n", source );
	printf( "  source-&gt;read_position = %zd\n", source-&gt;read_position );
	printf( "  source-&gt;is_pipe = %d\n", source-&gt;is_pipe );
	printf( "  source-&gt;length = %zd\n", source-&gt;length );
	printf( "  source-&gt;data = %p\n", source-&gt;data );
	printf( "  source-&gt;header_bytes = %p\n", source-&gt;header_bytes );
	if( source-&gt;header_bytes ) 
		printf( "  source-&gt;header_bytes-&gt;len = %d\n", 
			source-&gt;header_bytes-&gt;len );
	printf( "  source-&gt;sniff = %p\n", source-&gt;sniff );
	if( source-&gt;sniff )
		printf( "  source-&gt;sniff-&gt;len = %d\n", source-&gt;sniff-&gt;len );
}
gint64
vips_source_read( VipsSource *source, void *buffer, size_t length )
{
	VipsSourceClass *class = VIPS_SOURCE_GET_CLASS( source );
	gint64 total_read;
	VIPS_DEBUG_MSG( "vips_source_read:\n" );
	SANITY( source );
	if( vips_source_unminimise( source ) ||
		vips_source_test_features( source ) )
		return( -1 );
	total_read = 0;
	if( source-&gt;data ) {
		gint64 available = VIPS_MIN( length,
			source-&gt;length - source-&gt;read_position );
		VIPS_DEBUG_MSG( "    %zd bytes from memory\n", available );
		memcpy( buffer, 
			source-&gt;data + source-&gt;read_position, available );
		source-&gt;read_position += available;
		total_read += available;
	}
	else {
		if( source-&gt;header_bytes &amp;&amp;
			source-&gt;read_position &lt; source-&gt;header_bytes-&gt;len ) {
			gint64 available = VIPS_MIN( length, 
				source-&gt;header_bytes-&gt;len - 
					source-&gt;read_position );
			VIPS_DEBUG_MSG( "    %zd bytes from cache\n", 
				available );
			memcpy( buffer, 
				source-&gt;header_bytes-&gt;data + 
					source-&gt;read_position, 
				available );
			source-&gt;read_position += available;
			buffer += available;
			length -= available;
			total_read += available;
		}
		if( length &gt; 0 ) {
			gint64 bytes_read;
			VIPS_DEBUG_MSG( "    calling class-&gt;read()\n" );
			bytes_read = class-&gt;read( source, buffer, length );
			VIPS_DEBUG_MSG( "    %zd bytes from read()\n", 
				bytes_read );
			if( bytes_read == -1 ) {
				vips_error_system( errno, 
					vips_connection_nick( 
						VIPS_CONNECTION( source ) ), 
					"%s", _( "read error" ) ); 
				return( -1 );
			}
			if( source-&gt;header_bytes &amp;&amp;
				source-&gt;is_pipe &amp;&amp;
				!source-&gt;decode &amp;&amp;
				bytes_read &gt; 0 ) 
				g_byte_array_append( source-&gt;header_bytes, 
					buffer, bytes_read );
			source-&gt;read_position += bytes_read;
			total_read += bytes_read;
		}
	}
	VIPS_DEBUG_MSG( "    %zd bytes total\n", total_read );
	SANITY( source );
	return( total_read );
}
static int
vips_source_pipe_read_to_position( VipsSource *source, gint64 target )
{
	const char *nick = vips_connection_nick( VIPS_CONNECTION( source ) );
	unsigned char buffer[4096];
	g_assert( source-&gt;length == -1 );
	g_assert( source-&gt;is_pipe );
	while( target == -1 ||
		source-&gt;read_position &lt; target ) {
		gint64 bytes_read;
		bytes_read = vips_source_read( source, buffer, 4096 );
		if( bytes_read == -1 )
			return( -1 );
		if( bytes_read == 0 ) {
			source-&gt;length = source-&gt;read_position;
			if( source-&gt;header_bytes ) {
				source-&gt;data = source-&gt;header_bytes-&gt;data;
				source-&gt;is_pipe = FALSE;
				vips_source_minimise( source );
			}
			break;
		}
		if( target == -1 &amp;&amp;
			vips__pipe_read_limit != -1 &amp;&amp;
			source-&gt;read_position &gt; vips__pipe_read_limit ) {
			vips_error( nick, "%s", _( "pipe too long" ) );
			return( -1 );
		}
	}
	return( 0 );
}
static int
vips_source_read_to_memory( VipsSource *source )
{
	GByteArray *byte_array;
	gint64 read_position;
	unsigned char *q;
	VIPS_DEBUG_MSG( "vips_source_read_to_memory:\n" );
	g_assert( !source-&gt;is_pipe );
	g_assert( !source-&gt;blob );
	g_assert( !source-&gt;header_bytes );
	g_assert( source-&gt;length &gt;= 0 );
	if( vips_source_rewind( source ) )
		return( -1 );
	byte_array = g_byte_array_new();
	g_byte_array_set_size( byte_array, source-&gt;length );
	read_position = 0;
	q = byte_array-&gt;data;
	while( read_position &lt; source-&gt;length ) {
		gint64 bytes_read;
		bytes_read = vips_source_read( source, q, 
			VIPS_MAX( 4096, source-&gt;length - read_position ) );
		if( bytes_read == -1 ) {
			VIPS_FREEF( g_byte_array_unref, byte_array ); 
			return( -1 );
		}
		if( bytes_read == 0 )
			break;
		read_position += bytes_read;
		q += bytes_read;
	}
	source-&gt;data = byte_array-&gt;data;
	source-&gt;is_pipe = FALSE;
	source-&gt;header_bytes = byte_array;
	vips_source_minimise( source );
	return( 0 );
}
static int
vips_source_descriptor_to_memory( VipsSource *source )
{
	VipsConnection *connection = VIPS_CONNECTION( source );
	VIPS_DEBUG_MSG( "vips_source_descriptor_to_memory:\n" );
	g_assert( !source-&gt;blob );
	g_assert( !source-&gt;mmap_baseaddr );
	if( !(source-&gt;mmap_baseaddr = vips__mmap( connection-&gt;descriptor, 
		FALSE, source-&gt;length, 0 )) )
		return( -1 );
	source-&gt;data = source-&gt;mmap_baseaddr;
	source-&gt;mmap_length = source-&gt;length;
	return( 0 );
}
gboolean 
vips_source_is_mappable( VipsSource *source )
{
	if( vips_source_unminimise( source ) ||
		vips_source_test_features( source ) )
		return( -1 );
	return( source-&gt;data ||
		VIPS_CONNECTION( source )-&gt;filename ||
		(!source-&gt;is_pipe &amp;&amp; 
		 VIPS_CONNECTION( source )-&gt;descriptor != -1) );
}
const void *
vips_source_map( VipsSource *source, size_t *length_out )
{
	VIPS_DEBUG_MSG( "vips_source_map:\n" );
	SANITY( source );
	if( vips_source_unminimise( source ) ||
		vips_source_test_features( source ) )
		return( NULL );
	if( !source-&gt;data &amp;&amp;
		vips_source_is_mappable( source ) ) 
		(void) vips_source_descriptor_to_memory( source );
	if( !source-&gt;data &amp;&amp;
		!source-&gt;is_pipe &amp;&amp;
		vips_source_read_to_memory( source ) )
		return( NULL );
	if( !source-&gt;data &amp;&amp;
		vips_source_pipe_read_to_position( source, -1 ) )
		return( NULL );
	if( length_out )
		*length_out = source-&gt;length;
	SANITY( source );
	return( source-&gt;data );
}
static int
vips_source_map_cb( void *a, VipsArea *area )
{
	GObject *gobject = G_OBJECT( area-&gt;client );
	VIPS_UNREF( gobject );
	return( 0 );
}
VipsBlob *
vips_source_map_blob( VipsSource *source )
{
	const void *buf;
	size_t len;
	VipsBlob *blob;
	if( !(buf = vips_source_map( source, &amp;len )) ||
		!(blob = vips_blob_new( (VipsCallbackFn) vips_source_map_cb, 
			buf, len )) ) 
		return( NULL );
	g_object_ref( source );
	VIPS_AREA( blob )-&gt;client = source;
	return( blob );
}
gint64
vips_source_seek( VipsSource *source, gint64 offset, int whence )
{
	const char *nick = vips_connection_nick( VIPS_CONNECTION( source ) );
	VipsSourceClass *class = VIPS_SOURCE_GET_CLASS( source );
	gint64 new_pos;
	VIPS_DEBUG_MSG( "vips_source_seek: offset = %" G_GINT64_FORMAT 
		", whence = %d\n", offset, whence );
	if( vips_source_unminimise( source ) ||
		vips_source_test_features( source ) )
		return( -1 );
	if( source-&gt;data ) {
		switch( whence ) {
		case SEEK_SET:
			new_pos = offset;
			break;
		case SEEK_CUR:
			new_pos = source-&gt;read_position + offset;
			break;
		case SEEK_END:
			new_pos = source-&gt;length + offset;
			break;
		default:
			vips_error( nick, "%s", _( "bad 'whence'" ) );
			return( -1 );
		}
	}
	else if( source-&gt;is_pipe ) {
		switch( whence ) {
		case SEEK_SET:
			new_pos = offset;
			break;
		case SEEK_CUR:
			new_pos = source-&gt;read_position + offset;
			break;
		case SEEK_END:
			if( vips_source_pipe_read_to_position( source, -1 ) )
				return( -1 );
			new_pos = source-&gt;length + offset;
			break;
		default:
			vips_error( nick, "%s", _( "bad 'whence'" ) );
			return( -1 );
		}
	}
	else {
		if( (new_pos = class-&gt;seek( source, offset, whence )) == -1 )
			return( -1 );
	}
	if( source-&gt;is_pipe &amp;&amp;
		vips_source_pipe_read_to_position( source, new_pos ) )
		return( -1 );
	if( new_pos &lt; 0 ||
		(source-&gt;length != -1 &amp;&amp; 
		 new_pos &gt; source-&gt;length) ) {
		vips_error( nick, 
			_( "bad seek to %" G_GINT64_FORMAT ), new_pos );
                return( -1 );
	}
	source-&gt;read_position = new_pos;
	VIPS_DEBUG_MSG( "    new_pos = %" G_GINT64_FORMAT "\n", new_pos );
	return( new_pos );
}
int
vips_source_rewind( VipsSource *source )
{
	VIPS_DEBUG_MSG( "vips_source_rewind:\n" );
	SANITY( source );
	if( vips_source_test_features( source ) ||
		vips_source_seek( source, 0, SEEK_SET ) != 0 )
		return( -1 );
	source-&gt;decode = FALSE;
	if( !source-&gt;sniff )
		source-&gt;sniff = g_byte_array_new();
	SANITY( source );
	return( 0 );
}
gint64
vips_source_length( VipsSource *source )
{
	gint64 length;
	gint64 read_position;
	VIPS_DEBUG_MSG( "vips_source_length:\n" );
	if( vips_source_test_features( source ) )
		return( -1 );
	read_position = vips_source_seek( source, 0, SEEK_CUR );
	length = vips_source_seek( source, 0, SEEK_END );
	vips_source_seek( source, read_position, SEEK_SET );
	return( length );
}
gint64
vips_source_sniff_at_most( VipsSource *source, 
	unsigned char **data, size_t length )
{
	unsigned char *q;
	gint64 read_position;
	VIPS_DEBUG_MSG( "vips_source_sniff_at_most: %zd bytes\n", length );
	SANITY( source );
	if( vips_source_test_features( source ) ||
		vips_source_rewind( source ) )
		return( -1 );
	g_byte_array_set_size( source-&gt;sniff, length );
	read_position = 0; 
	q = source-&gt;sniff-&gt;data;
	while( read_position &lt; length ) {
		gint64 bytes_read;
		bytes_read = vips_source_read( source, q, 
			length - read_position );
		if( bytes_read == -1 )
			return( -1 );
		if( bytes_read == 0 )
			break;
		read_position += bytes_read;
		q += bytes_read;
	}
	SANITY( source );
	*data = source-&gt;sniff-&gt;data;
	return( read_position );
}
unsigned char *
vips_source_sniff( VipsSource *source, size_t length )
{
	unsigned char *data;
	gint64 bytes_read;
	if( vips_source_test_features( source ) )
		return( NULL );
	bytes_read = vips_source_sniff_at_most( source, &amp;data, length );
	if( bytes_read == -1 )
		return( NULL );
	if( bytes_read &lt; length )
		return( NULL );
	return( data );
}
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
