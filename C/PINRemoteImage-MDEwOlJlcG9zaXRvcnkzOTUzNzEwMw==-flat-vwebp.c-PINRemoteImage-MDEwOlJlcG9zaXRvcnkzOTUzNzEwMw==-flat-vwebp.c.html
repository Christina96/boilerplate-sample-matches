
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 16, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>PINRemoteImage-MDEwOlJlcG9zaXRvcnkzOTUzNzEwMw==-flat-vwebp.c</h3>
            <pre><code>1  #ifdef HAVE_CONFIG_H
2  #include "webp/config.h"
3  #endif
4  #if defined(__unix__) || defined(__CYGWIN__)
5  #define _POSIX_C_SOURCE 200112L  
6  #endif
7  #include <stdio.h>
8  #include <stdlib.h>
9  #include <string.h>
10  #if defined(WEBP_HAVE_GL)
11  #if defined(HAVE_GLUT_GLUT_H)
12  #include <GLUT/glut.h>
13  #else
14  #include <GL/glut.h>
15  #ifdef FREEGLUT
16  #include <GL/freeglut.h>
17  #endif
18  #endif
19  #ifdef WEBP_HAVE_QCMS
20  #include <qcms.h>
21  #endif
22  #include "webp/decode.h"
23  #include "webp/demux.h"
24  #include "../examples/example_util.h"
25  #include "../imageio/imageio_util.h"
26  #include "./unicode.h"
27  #if defined(_MSC_VER) && _MSC_VER < 1900
28  #define snprintf _snprintf
29  #endif
30  static struct {
31    int has_animation;
32    int has_color_profile;
33    int done;
34    int decoding_error;
35    int print_info;
36    int only_deltas;
37    int use_color_profile;
38    int draw_anim_background_color;
39    int canvas_width, canvas_height;
40    int loop_count;
41    uint32_t bg_color;
42    const char* file_name;
43    WebPData data;
44    WebPDecoderConfig config;
45    const WebPDecBuffer* pic;
46    WebPDemuxer* dmux;
47    WebPIterator curr_frame;
48    WebPIterator prev_frame;
49    WebPChunkIterator iccp;
50    int viewport_width, viewport_height;
51  } kParams;
52  static void ClearPreviousPic(void) {
53    WebPFreeDecBuffer((WebPDecBuffer*)kParams.pic);
54    kParams.pic = NULL;
55  }
56  static void ClearParams(void) {
57    ClearPreviousPic();
<span onclick='openModal()' class='match'>58    WebPDataClear(&kParams.data);
59    WebPDemuxReleaseIterator(&kParams.curr_frame);
60    WebPDemuxReleaseIterator(&kParams.prev_frame);
</span>61    WebPDemuxReleaseChunkIterator(&kParams.iccp);
62    WebPDemuxDelete(kParams.dmux);
63    kParams.dmux = NULL;
64  }
65  static void ClearPreviousFrame(void) {
66    WebPIterator* const prev = &kParams.prev_frame;
67    prev->width = kParams.canvas_width;
68    prev->height = kParams.canvas_height;
69    prev->x_offset = prev->y_offset = 0;
70    prev->dispose_method = WEBP_MUX_DISPOSE_BACKGROUND;
71  }
72  static int ApplyColorProfile(const WebPData* const profile,
73                               WebPDecBuffer* const rgba) {
74  #ifdef WEBP_HAVE_QCMS
75    int i, ok = 0;
76    uint8_t* line;
77    uint8_t major_revision;
78    qcms_profile* input_profile = NULL;
79    qcms_profile* output_profile = NULL;
80    qcms_transform* transform = NULL;
81    const qcms_data_type input_type = QCMS_DATA_RGBA_8;
82    const qcms_data_type output_type = QCMS_DATA_RGBA_8;
83    const qcms_intent intent = QCMS_INTENT_DEFAULT;
84    if (profile == NULL || rgba == NULL) return 0;
85    if (profile->bytes == NULL || profile->size < 10) return 1;
86    major_revision = profile->bytes[8];
87    qcms_enable_iccv4();
88    input_profile = qcms_profile_from_memory(profile->bytes, profile->size);
89    if (input_profile == NULL ||
90        (major_revision < 4 && qcms_profile_is_bogus(input_profile))) {
91      fprintf(stderr, "Color profile is bogus!\n");
92      goto Error;
93    }
94    output_profile = qcms_profile_sRGB();
95    if (output_profile == NULL) {
96      fprintf(stderr, "Error creating output color profile!\n");
97      goto Error;
98    }
99    qcms_profile_precache_output_transform(output_profile);
100    transform = qcms_transform_create(input_profile, input_type,
101                                      output_profile, output_type,
102                                      intent);
103    if (transform == NULL) {
104      fprintf(stderr, "Error creating color transform!\n");
105      goto Error;
106    }
107    line = rgba->u.RGBA.rgba;
108    for (i = 0; i < rgba->height; ++i, line += rgba->u.RGBA.stride) {
109      qcms_transform_data(transform, line, line, rgba->width);
110    }
111    ok = 1;
112   Error:
113    if (input_profile != NULL) qcms_profile_release(input_profile);
114    if (output_profile != NULL) qcms_profile_release(output_profile);
115    if (transform != NULL) qcms_transform_release(transform);
116    return ok;
117  #else
118    (void)profile;
119    (void)rgba;
120    return 1;
121  #endif  
122  }
123  static int Decode(void) {   
124    const WebPIterator* const curr = &kParams.curr_frame;
125    WebPDecoderConfig* const config = &kParams.config;
126    WebPDecBuffer* const output_buffer = &config->output;
127    int ok = 0;
128    ClearPreviousPic();
129    output_buffer->colorspace = MODE_RGBA;
130    ok = (WebPDecode(curr->fragment.bytes, curr->fragment.size,
131                     config) == VP8_STATUS_OK);
132    if (!ok) {
133      fprintf(stderr, "Decoding of frame #%d failed!\n", curr->frame_num);
134    } else {
135      kParams.pic = output_buffer;
136      if (kParams.use_color_profile) {
137        ok = ApplyColorProfile(&kParams.iccp.chunk, output_buffer);
138        if (!ok) {
139          fprintf(stderr, "Applying color profile to frame #%d failed!\n",
140                  curr->frame_num);
141        }
142      }
143    }
144    return ok;
145  }
146  static void decode_callback(int what) {
147    if (what == 0 && !kParams.done) {
148      int duration = 0;
149      if (kParams.dmux != NULL) {
150        WebPIterator* const curr = &kParams.curr_frame;
151        if (!WebPDemuxNextFrame(curr)) {
152          WebPDemuxReleaseIterator(curr);
153          if (WebPDemuxGetFrame(kParams.dmux, 1, curr)) {
154            --kParams.loop_count;
155            kParams.done = (kParams.loop_count == 0);
156            if (kParams.done) return;
157            ClearPreviousFrame();
158          } else {
159            kParams.decoding_error = 1;
160            kParams.done = 1;
161            return;
162          }
163        }
164        duration = curr->duration;
165        if (duration <= 10) duration = 100;
166      }
167      if (!Decode()) {
168        kParams.decoding_error = 1;
169        kParams.done = 1;
170      } else {
171        glutPostRedisplay();
172        glutTimerFunc(duration, decode_callback, what);
173      }
174    }
175  }
176  static void HandleKey(unsigned char key, int pos_x, int pos_y) {
177    (void)pos_x;
178    (void)pos_y;
179    if (key == 'q' || key == 'Q' || key == 27 &bsol;* Esc */) {
180  #ifdef FREEGLUT
181      glutLeaveMainLoop();
182  #else
183      ClearParams();
184      exit(0);
185  #endif
186    } else if (key == 'c') {
187      if (kParams.has_color_profile && !kParams.decoding_error) {
188        kParams.use_color_profile = 1 - kParams.use_color_profile;
189        if (kParams.has_animation) {
190          if (kParams.done && kParams.loop_count == 0) {
191            kParams.loop_count =
192                (int)WebPDemuxGetI(kParams.dmux, WEBP_FF_LOOP_COUNT) + 1;
193            kParams.done = 0;
194            glutTimerFunc(0, decode_callback, 0);
195          }
196        } else {
197          Decode();
198          glutPostRedisplay();
199        }
200      }
201    } else if (key == 'b') {
202      kParams.draw_anim_background_color = 1 - kParams.draw_anim_background_color;
203      if (!kParams.has_animation) ClearPreviousFrame();
204      glutPostRedisplay();
205    } else if (key == 'i') {
206      kParams.print_info = 1 - kParams.print_info;
207      if (!kParams.has_animation) ClearPreviousFrame();
208      glutPostRedisplay();
209    } else if (key == 'd') {
210      kParams.only_deltas = 1 - kParams.only_deltas;
211      glutPostRedisplay();
212    }
213  }
214  static void HandleReshape(int width, int height) {
215    glViewport(0, 0, width, height);
216    glMatrixMode(GL_PROJECTION);
217    glLoadIdentity();
218    glMatrixMode(GL_MODELVIEW);
219    glLoadIdentity();
220    kParams.viewport_width = width;
221    kParams.viewport_height = height;
222    if (!kParams.has_animation) ClearPreviousFrame();
223  }
224  static void PrintString(const char* const text) {
225    void* const font = GLUT_BITMAP_9_BY_15;
226    int i;
227    for (i = 0; text[i]; ++i) {
228      glutBitmapCharacter(font, text[i]);
229    }
230  }
231  static float GetColorf(uint32_t color, int shift) {
232    return ((color >> shift) & 0xff) / 255.f;
233  }
234  static void DrawCheckerBoard(void) {
235    const int square_size = 8;  
236    int x, y;
237    GLint viewport[4];  
238    glPushMatrix();
239    glGetIntegerv(GL_VIEWPORT, viewport);
240    glOrtho(0, viewport[2], viewport[3], 0, -1, 1);
241    for (y = 0; y < viewport[3]; y += square_size) {
242      for (x = 0; x < viewport[2]; x += square_size) {
243        const GLubyte color = 128 + 64 * (!((x + y) & square_size));
244        glColor3ub(color, color, color);
245        glRecti(x, y, x + square_size, y + square_size);
246      }
247    }
248    glPopMatrix();
249  }
250  static void DrawBackground(void) {
251    glClear(GL_COLOR_BUFFER_BIT);
252    DrawCheckerBoard();
253    if (kParams.draw_anim_background_color) {
254      glPushMatrix();
255      glLoadIdentity();
256      glColor4f(GetColorf(kParams.bg_color, 16),  
257                GetColorf(kParams.bg_color, 8),
258                GetColorf(kParams.bg_color, 0),
259                GetColorf(kParams.bg_color, 24));
260      glRecti(-1, -1, +1, +1);
261      glPopMatrix();
262    }
263  }
264  static void DrawBackgroundScissored(int window_x, int window_y, int frame_w,
265                                      int frame_h) {
266    window_x = window_x * kParams.viewport_width / kParams.canvas_width;
267    window_y = window_y * kParams.viewport_height / kParams.canvas_height;
268    frame_w = frame_w * kParams.viewport_width / kParams.canvas_width;
269    frame_h = frame_h * kParams.viewport_height / kParams.canvas_height;
270    window_y = kParams.viewport_height - window_y - frame_h;
271    glEnable(GL_SCISSOR_TEST);
272    glScissor(window_x, window_y, frame_w, frame_h);
273    DrawBackground();
274    glDisable(GL_SCISSOR_TEST);
275  }
276  static void HandleDisplay(void) {
277    const WebPDecBuffer* const pic = kParams.pic;
278    const WebPIterator* const curr = &kParams.curr_frame;
279    WebPIterator* const prev = &kParams.prev_frame;
280    GLfloat xoff, yoff;
281    if (pic == NULL) return;
282    glPushMatrix();
283    glPixelZoom((GLfloat)(+1. / kParams.canvas_width * kParams.viewport_width),
284                (GLfloat)(-1. / kParams.canvas_height * kParams.viewport_height));
285    xoff = (GLfloat)(2. * curr->x_offset / kParams.canvas_width);
286    yoff = (GLfloat)(2. * curr->y_offset / kParams.canvas_height);
287    glRasterPos2f(-1.f + xoff, 1.f - yoff);
288    glPixelStorei(GL_UNPACK_ALIGNMENT, 1);
289    glPixelStorei(GL_UNPACK_ROW_LENGTH, pic->u.RGBA.stride / 4);
290    if (kParams.only_deltas) {
291      DrawBackground();
292    } else {
293      if (prev->dispose_method == WEBP_MUX_DISPOSE_BACKGROUND) {
294        DrawBackgroundScissored(prev->x_offset, prev->y_offset, prev->width,
295                                prev->height);
296      }
297      if (curr->blend_method == WEBP_MUX_NO_BLEND) {
298        DrawBackgroundScissored(curr->x_offset, curr->y_offset, curr->width,
299                                curr->height);
300      }
301    }
302    *prev = *curr;
303    glDrawPixels(pic->width, pic->height,
304                 GL_RGBA, GL_UNSIGNED_BYTE,
305                 (GLvoid*)pic->u.RGBA.rgba);
306    if (kParams.print_info) {
307      char tmp[32];
308      glColor4f(0.90f, 0.0f, 0.90f, 1.0f);
309      glRasterPos2f(-0.95f, 0.90f);
310      PrintString(kParams.file_name);
311      snprintf(tmp, sizeof(tmp), "Dimension:%d x %d", pic->width, pic->height);
312      glColor4f(0.90f, 0.0f, 0.90f, 1.0f);
313      glRasterPos2f(-0.95f, 0.80f);
314      PrintString(tmp);
315      if (curr->x_offset != 0 || curr->y_offset != 0) {
316        snprintf(tmp, sizeof(tmp), " (offset:%d,%d)",
317                 curr->x_offset, curr->y_offset);
318        glRasterPos2f(-0.95f, 0.70f);
319        PrintString(tmp);
320      }
321    }
322    glPopMatrix();
323  #if defined(__APPLE__) || defined(_WIN32)
324    glFlush();
325  #else
326    glutSwapBuffers();
327  #endif
328  }
329  static void StartDisplay(void) {
330    int width = kParams.canvas_width;
331    int height = kParams.canvas_height;
332    int screen_width, screen_height;
333  #if defined(__APPLE__) || defined(_WIN32)
334    glutInitDisplayMode(GLUT_RGBA);
335  #else
336    glutInitDisplayMode(GLUT_DOUBLE | GLUT_RGBA);
337  #endif
338    screen_width = glutGet(GLUT_SCREEN_WIDTH);
339    screen_height = glutGet(GLUT_SCREEN_HEIGHT);
340    if (width > screen_width || height > screen_height) {
341      if (width > screen_width) {
342        height = (height * screen_width + width - 1) / width;
343        width = screen_width;
344      }
345      if (height > screen_height) {
346        width = (width * screen_height + height - 1) / height;
347        height = screen_height;
348      }
349    }
350    glutInitWindowSize(width, height);
351    glutCreateWindow("WebP viewer");
352    glutDisplayFunc(HandleDisplay);
353    glutReshapeFunc(HandleReshape);
354    glutIdleFunc(NULL);
355    glutKeyboardFunc(HandleKey);
356    glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
357    glEnable(GL_BLEND);
358    glClearColor(0, 0, 0, 0);  
359    DrawBackground();
360  }
361  static void Help(void) {
362    printf(
363        "Usage: vwebp in_file [options]\n\n"
364        "Decodes the WebP image file and visualize it using OpenGL\n"
365        "Options are:\n"
366        "  -version ..... print version number and exit\n"
367        "  -noicc ....... don't use the icc profile if present\n"
368        "  -nofancy ..... don't use the fancy YUV420 upscaler\n"
369        "  -nofilter .... disable in-loop filtering\n"
370        "  -dither <int>  dithering strength (0..100), default=50\n"
371        "  -noalphadither disable alpha plane dithering\n"
372        "  -usebgcolor .. display background color\n"
373        "  -mt .......... use multi-threading\n"
374        "  -info ........ print info\n"
375        "  -h ........... this help message\n"
376        "\n"
377        "Keyboard shortcuts:\n"
378        "  'c' ................ toggle use of color profile\n"
379        "  'b' ................ toggle background color display\n"
380        "  'i' ................ overlay file information\n"
381        "  'd' ................ disable blending & disposal (debug)\n"
382        "  'q' / 'Q' / ESC .... quit\n");
383  }
384  int main(int argc, char* argv[]) {
385    int c;
386    WebPDecoderConfig* const config = &kParams.config;
387    WebPIterator* const curr = &kParams.curr_frame;
388    INIT_WARGV(argc, argv);
389    if (!WebPInitDecoderConfig(config)) {
390      fprintf(stderr, "Library version mismatch!\n");
391      FREE_WARGV_AND_RETURN(-1);
392    }
393    config->options.dithering_strength = 50;
394    config->options.alpha_dithering_strength = 100;
395    kParams.use_color_profile = 1;
396    kParams.draw_anim_background_color = 0;
397    for (c = 1; c < argc; ++c) {
398      int parse_error = 0;
399      if (!strcmp(argv[c], "-h") || !strcmp(argv[c], "-help")) {
400        Help();
401        FREE_WARGV_AND_RETURN(0);
402      } else if (!strcmp(argv[c], "-noicc")) {
403        kParams.use_color_profile = 0;
404      } else if (!strcmp(argv[c], "-nofancy")) {
405        config->options.no_fancy_upsampling = 1;
406      } else if (!strcmp(argv[c], "-nofilter")) {
407        config->options.bypass_filtering = 1;
408      } else if (!strcmp(argv[c], "-noalphadither")) {
409        config->options.alpha_dithering_strength = 0;
410      } else if (!strcmp(argv[c], "-usebgcolor")) {
411        kParams.draw_anim_background_color = 1;
412      } else if (!strcmp(argv[c], "-dither") && c + 1 < argc) {
413        config->options.dithering_strength =
414            ExUtilGetInt(argv[++c], 0, &parse_error);
415      } else if (!strcmp(argv[c], "-info")) {
416        kParams.print_info = 1;
417      } else if (!strcmp(argv[c], "-version")) {
418        const int dec_version = WebPGetDecoderVersion();
419        const int dmux_version = WebPGetDemuxVersion();
420        printf("WebP Decoder version: %d.%d.%d\nWebP Demux version: %d.%d.%d\n",
421               (dec_version >> 16) & 0xff, (dec_version >> 8) & 0xff,
422               dec_version & 0xff, (dmux_version >> 16) & 0xff,
423               (dmux_version >> 8) & 0xff, dmux_version & 0xff);
424        FREE_WARGV_AND_RETURN(0);
425      } else if (!strcmp(argv[c], "-mt")) {
426        config->options.use_threads = 1;
427      } else if (!strcmp(argv[c], "--")) {
428        if (c < argc - 1) kParams.file_name = (const char*)GET_WARGV(argv, ++c);
429        break;
430      } else if (argv[c][0] == '-') {
431        printf("Unknown option '%s'\n", argv[c]);
432        Help();
433        FREE_WARGV_AND_RETURN(-1);
434      } else {
435        kParams.file_name = (const char*)GET_WARGV(argv, c);
436      }
437      if (parse_error) {
438        Help();
439        FREE_WARGV_AND_RETURN(-1);
440      }
441    }
442    if (kParams.file_name == NULL) {
443      printf("missing input file!!\n");
444      Help();
445      FREE_WARGV_AND_RETURN(0);
446    }
447    if (!ImgIoUtilReadFile(kParams.file_name,
448                           &kParams.data.bytes, &kParams.data.size)) {
449      goto Error;
450    }
451    if (!WebPGetInfo(kParams.data.bytes, kParams.data.size, NULL, NULL)) {
452      fprintf(stderr, "Input file doesn't appear to be WebP format.\n");
453      goto Error;
454    }
455    kParams.dmux = WebPDemux(&kParams.data);
456    if (kParams.dmux == NULL) {
457      fprintf(stderr, "Could not create demuxing object!\n");
458      goto Error;
459    }
460    kParams.canvas_width = WebPDemuxGetI(kParams.dmux, WEBP_FF_CANVAS_WIDTH);
461    kParams.canvas_height = WebPDemuxGetI(kParams.dmux, WEBP_FF_CANVAS_HEIGHT);
462    if (kParams.print_info) {
463      printf("Canvas: %d x %d\n", kParams.canvas_width, kParams.canvas_height);
464    }
465    ClearPreviousFrame();
466    memset(&kParams.iccp, 0, sizeof(kParams.iccp));
467    kParams.has_color_profile =
468        !!(WebPDemuxGetI(kParams.dmux, WEBP_FF_FORMAT_FLAGS) & ICCP_FLAG);
469    if (kParams.has_color_profile) {
470  #ifdef WEBP_HAVE_QCMS
471      if (!WebPDemuxGetChunk(kParams.dmux, "ICCP", 1, &kParams.iccp)) goto Error;
472      printf("VP8X: Found color profile\n");
473  #else
474      fprintf(stderr, "Warning: color profile present, but qcms is unavailable!\n"
475              "Build libqcms from Mozilla or Chromium and define WEBP_HAVE_QCMS "
476              "before building.\n");
477  #endif
478    }
479    if (!WebPDemuxGetFrame(kParams.dmux, 1, curr)) goto Error;
480    kParams.has_animation = (curr->num_frames > 1);
481    kParams.loop_count = (int)WebPDemuxGetI(kParams.dmux, WEBP_FF_LOOP_COUNT);
482    kParams.bg_color = WebPDemuxGetI(kParams.dmux, WEBP_FF_BACKGROUND_COLOR);
483    printf("VP8X: Found %d images in file (loop count = %d)\n",
484           curr->num_frames, kParams.loop_count);
485    if (!Decode()) goto Error;
486    WebPDemuxGetFrame(kParams.dmux, 0, curr);
487    if (kParams.loop_count) ++kParams.loop_count;
488  #if defined(__unix__) || defined(__CYGWIN__)
489    setenv("XLIB_SKIP_ARGB_VISUALS", "1", 1);
490  #endif
491    glutInit(&argc, argv);
492  #ifdef FREEGLUT
493    glutSetOption(GLUT_ACTION_ON_WINDOW_CLOSE, GLUT_ACTION_CONTINUE_EXECUTION);
494  #endif
495    StartDisplay();
496    if (kParams.has_animation) glutTimerFunc(0, decode_callback, 0);
497    glutMainLoop();
498    ClearParams();
499    FREE_WARGV_AND_RETURN(0);
500   Error:
501    ClearParams();
502    FREE_WARGV_AND_RETURN(-1);
503  }
504  #else   
505  int main(int argc, const char* argv[]) {
506    fprintf(stderr, "OpenGL support not enabled in %s.\n", argv[0]);
507    (void)argc;
508    return 0;
509  }
510  #endif
</code></pre>
        </div>
        <div class="column">
            <h3>PINRemoteImage-MDEwOlJlcG9zaXRvcnkzOTUzNzEwMw==-flat-vwebp.c</h3>
            <pre><code>1  #ifdef HAVE_CONFIG_H
2  #include "webp/config.h"
3  #endif
4  #if defined(__unix__) || defined(__CYGWIN__)
5  #define _POSIX_C_SOURCE 200112L  
6  #endif
7  #include <stdio.h>
8  #include <stdlib.h>
9  #include <string.h>
10  #if defined(WEBP_HAVE_GL)
11  #if defined(HAVE_GLUT_GLUT_H)
12  #include <GLUT/glut.h>
13  #else
14  #include <GL/glut.h>
15  #ifdef FREEGLUT
16  #include <GL/freeglut.h>
17  #endif
18  #endif
19  #ifdef WEBP_HAVE_QCMS
20  #include <qcms.h>
21  #endif
22  #include "webp/decode.h"
23  #include "webp/demux.h"
24  #include "../examples/example_util.h"
25  #include "../imageio/imageio_util.h"
26  #include "./unicode.h"
27  #if defined(_MSC_VER) && _MSC_VER < 1900
28  #define snprintf _snprintf
29  #endif
30  static struct {
31    int has_animation;
32    int has_color_profile;
33    int done;
34    int decoding_error;
35    int print_info;
36    int only_deltas;
37    int use_color_profile;
38    int draw_anim_background_color;
39    int canvas_width, canvas_height;
40    int loop_count;
41    uint32_t bg_color;
42    const char* file_name;
43    WebPData data;
44    WebPDecoderConfig config;
45    const WebPDecBuffer* pic;
46    WebPDemuxer* dmux;
47    WebPIterator curr_frame;
48    WebPIterator prev_frame;
49    WebPChunkIterator iccp;
50    int viewport_width, viewport_height;
51  } kParams;
52  static void ClearPreviousPic(void) {
53    WebPFreeDecBuffer((WebPDecBuffer*)kParams.pic);
54    kParams.pic = NULL;
55  }
56  static void ClearParams(void) {
57    ClearPreviousPic();
58    WebPDataClear(&kParams.data);
59    WebPDemuxReleaseIterator(&kParams.curr_frame);
<span onclick='openModal()' class='match'>60    WebPDemuxReleaseIterator(&kParams.prev_frame);
61    WebPDemuxReleaseChunkIterator(&kParams.iccp);
62    WebPDemuxDelete(kParams.dmux);
</span>63    kParams.dmux = NULL;
64  }
65  static void ClearPreviousFrame(void) {
66    WebPIterator* const prev = &kParams.prev_frame;
67    prev->width = kParams.canvas_width;
68    prev->height = kParams.canvas_height;
69    prev->x_offset = prev->y_offset = 0;
70    prev->dispose_method = WEBP_MUX_DISPOSE_BACKGROUND;
71  }
72  static int ApplyColorProfile(const WebPData* const profile,
73                               WebPDecBuffer* const rgba) {
74  #ifdef WEBP_HAVE_QCMS
75    int i, ok = 0;
76    uint8_t* line;
77    uint8_t major_revision;
78    qcms_profile* input_profile = NULL;
79    qcms_profile* output_profile = NULL;
80    qcms_transform* transform = NULL;
81    const qcms_data_type input_type = QCMS_DATA_RGBA_8;
82    const qcms_data_type output_type = QCMS_DATA_RGBA_8;
83    const qcms_intent intent = QCMS_INTENT_DEFAULT;
84    if (profile == NULL || rgba == NULL) return 0;
85    if (profile->bytes == NULL || profile->size < 10) return 1;
86    major_revision = profile->bytes[8];
87    qcms_enable_iccv4();
88    input_profile = qcms_profile_from_memory(profile->bytes, profile->size);
89    if (input_profile == NULL ||
90        (major_revision < 4 && qcms_profile_is_bogus(input_profile))) {
91      fprintf(stderr, "Color profile is bogus!\n");
92      goto Error;
93    }
94    output_profile = qcms_profile_sRGB();
95    if (output_profile == NULL) {
96      fprintf(stderr, "Error creating output color profile!\n");
97      goto Error;
98    }
99    qcms_profile_precache_output_transform(output_profile);
100    transform = qcms_transform_create(input_profile, input_type,
101                                      output_profile, output_type,
102                                      intent);
103    if (transform == NULL) {
104      fprintf(stderr, "Error creating color transform!\n");
105      goto Error;
106    }
107    line = rgba->u.RGBA.rgba;
108    for (i = 0; i < rgba->height; ++i, line += rgba->u.RGBA.stride) {
109      qcms_transform_data(transform, line, line, rgba->width);
110    }
111    ok = 1;
112   Error:
113    if (input_profile != NULL) qcms_profile_release(input_profile);
114    if (output_profile != NULL) qcms_profile_release(output_profile);
115    if (transform != NULL) qcms_transform_release(transform);
116    return ok;
117  #else
118    (void)profile;
119    (void)rgba;
120    return 1;
121  #endif  
122  }
123  static int Decode(void) {   
124    const WebPIterator* const curr = &kParams.curr_frame;
125    WebPDecoderConfig* const config = &kParams.config;
126    WebPDecBuffer* const output_buffer = &config->output;
127    int ok = 0;
128    ClearPreviousPic();
129    output_buffer->colorspace = MODE_RGBA;
130    ok = (WebPDecode(curr->fragment.bytes, curr->fragment.size,
131                     config) == VP8_STATUS_OK);
132    if (!ok) {
133      fprintf(stderr, "Decoding of frame #%d failed!\n", curr->frame_num);
134    } else {
135      kParams.pic = output_buffer;
136      if (kParams.use_color_profile) {
137        ok = ApplyColorProfile(&kParams.iccp.chunk, output_buffer);
138        if (!ok) {
139          fprintf(stderr, "Applying color profile to frame #%d failed!\n",
140                  curr->frame_num);
141        }
142      }
143    }
144    return ok;
145  }
146  static void decode_callback(int what) {
147    if (what == 0 && !kParams.done) {
148      int duration = 0;
149      if (kParams.dmux != NULL) {
150        WebPIterator* const curr = &kParams.curr_frame;
151        if (!WebPDemuxNextFrame(curr)) {
152          WebPDemuxReleaseIterator(curr);
153          if (WebPDemuxGetFrame(kParams.dmux, 1, curr)) {
154            --kParams.loop_count;
155            kParams.done = (kParams.loop_count == 0);
156            if (kParams.done) return;
157            ClearPreviousFrame();
158          } else {
159            kParams.decoding_error = 1;
160            kParams.done = 1;
161            return;
162          }
163        }
164        duration = curr->duration;
165        if (duration <= 10) duration = 100;
166      }
167      if (!Decode()) {
168        kParams.decoding_error = 1;
169        kParams.done = 1;
170      } else {
171        glutPostRedisplay();
172        glutTimerFunc(duration, decode_callback, what);
173      }
174    }
175  }
176  static void HandleKey(unsigned char key, int pos_x, int pos_y) {
177    (void)pos_x;
178    (void)pos_y;
179    if (key == 'q' || key == 'Q' || key == 27 &bsol;* Esc */) {
180  #ifdef FREEGLUT
181      glutLeaveMainLoop();
182  #else
183      ClearParams();
184      exit(0);
185  #endif
186    } else if (key == 'c') {
187      if (kParams.has_color_profile && !kParams.decoding_error) {
188        kParams.use_color_profile = 1 - kParams.use_color_profile;
189        if (kParams.has_animation) {
190          if (kParams.done && kParams.loop_count == 0) {
191            kParams.loop_count =
192                (int)WebPDemuxGetI(kParams.dmux, WEBP_FF_LOOP_COUNT) + 1;
193            kParams.done = 0;
194            glutTimerFunc(0, decode_callback, 0);
195          }
196        } else {
197          Decode();
198          glutPostRedisplay();
199        }
200      }
201    } else if (key == 'b') {
202      kParams.draw_anim_background_color = 1 - kParams.draw_anim_background_color;
203      if (!kParams.has_animation) ClearPreviousFrame();
204      glutPostRedisplay();
205    } else if (key == 'i') {
206      kParams.print_info = 1 - kParams.print_info;
207      if (!kParams.has_animation) ClearPreviousFrame();
208      glutPostRedisplay();
209    } else if (key == 'd') {
210      kParams.only_deltas = 1 - kParams.only_deltas;
211      glutPostRedisplay();
212    }
213  }
214  static void HandleReshape(int width, int height) {
215    glViewport(0, 0, width, height);
216    glMatrixMode(GL_PROJECTION);
217    glLoadIdentity();
218    glMatrixMode(GL_MODELVIEW);
219    glLoadIdentity();
220    kParams.viewport_width = width;
221    kParams.viewport_height = height;
222    if (!kParams.has_animation) ClearPreviousFrame();
223  }
224  static void PrintString(const char* const text) {
225    void* const font = GLUT_BITMAP_9_BY_15;
226    int i;
227    for (i = 0; text[i]; ++i) {
228      glutBitmapCharacter(font, text[i]);
229    }
230  }
231  static float GetColorf(uint32_t color, int shift) {
232    return ((color >> shift) & 0xff) / 255.f;
233  }
234  static void DrawCheckerBoard(void) {
235    const int square_size = 8;  
236    int x, y;
237    GLint viewport[4];  
238    glPushMatrix();
239    glGetIntegerv(GL_VIEWPORT, viewport);
240    glOrtho(0, viewport[2], viewport[3], 0, -1, 1);
241    for (y = 0; y < viewport[3]; y += square_size) {
242      for (x = 0; x < viewport[2]; x += square_size) {
243        const GLubyte color = 128 + 64 * (!((x + y) & square_size));
244        glColor3ub(color, color, color);
245        glRecti(x, y, x + square_size, y + square_size);
246      }
247    }
248    glPopMatrix();
249  }
250  static void DrawBackground(void) {
251    glClear(GL_COLOR_BUFFER_BIT);
252    DrawCheckerBoard();
253    if (kParams.draw_anim_background_color) {
254      glPushMatrix();
255      glLoadIdentity();
256      glColor4f(GetColorf(kParams.bg_color, 16),  
257                GetColorf(kParams.bg_color, 8),
258                GetColorf(kParams.bg_color, 0),
259                GetColorf(kParams.bg_color, 24));
260      glRecti(-1, -1, +1, +1);
261      glPopMatrix();
262    }
263  }
264  static void DrawBackgroundScissored(int window_x, int window_y, int frame_w,
265                                      int frame_h) {
266    window_x = window_x * kParams.viewport_width / kParams.canvas_width;
267    window_y = window_y * kParams.viewport_height / kParams.canvas_height;
268    frame_w = frame_w * kParams.viewport_width / kParams.canvas_width;
269    frame_h = frame_h * kParams.viewport_height / kParams.canvas_height;
270    window_y = kParams.viewport_height - window_y - frame_h;
271    glEnable(GL_SCISSOR_TEST);
272    glScissor(window_x, window_y, frame_w, frame_h);
273    DrawBackground();
274    glDisable(GL_SCISSOR_TEST);
275  }
276  static void HandleDisplay(void) {
277    const WebPDecBuffer* const pic = kParams.pic;
278    const WebPIterator* const curr = &kParams.curr_frame;
279    WebPIterator* const prev = &kParams.prev_frame;
280    GLfloat xoff, yoff;
281    if (pic == NULL) return;
282    glPushMatrix();
283    glPixelZoom((GLfloat)(+1. / kParams.canvas_width * kParams.viewport_width),
284                (GLfloat)(-1. / kParams.canvas_height * kParams.viewport_height));
285    xoff = (GLfloat)(2. * curr->x_offset / kParams.canvas_width);
286    yoff = (GLfloat)(2. * curr->y_offset / kParams.canvas_height);
287    glRasterPos2f(-1.f + xoff, 1.f - yoff);
288    glPixelStorei(GL_UNPACK_ALIGNMENT, 1);
289    glPixelStorei(GL_UNPACK_ROW_LENGTH, pic->u.RGBA.stride / 4);
290    if (kParams.only_deltas) {
291      DrawBackground();
292    } else {
293      if (prev->dispose_method == WEBP_MUX_DISPOSE_BACKGROUND) {
294        DrawBackgroundScissored(prev->x_offset, prev->y_offset, prev->width,
295                                prev->height);
296      }
297      if (curr->blend_method == WEBP_MUX_NO_BLEND) {
298        DrawBackgroundScissored(curr->x_offset, curr->y_offset, curr->width,
299                                curr->height);
300      }
301    }
302    *prev = *curr;
303    glDrawPixels(pic->width, pic->height,
304                 GL_RGBA, GL_UNSIGNED_BYTE,
305                 (GLvoid*)pic->u.RGBA.rgba);
306    if (kParams.print_info) {
307      char tmp[32];
308      glColor4f(0.90f, 0.0f, 0.90f, 1.0f);
309      glRasterPos2f(-0.95f, 0.90f);
310      PrintString(kParams.file_name);
311      snprintf(tmp, sizeof(tmp), "Dimension:%d x %d", pic->width, pic->height);
312      glColor4f(0.90f, 0.0f, 0.90f, 1.0f);
313      glRasterPos2f(-0.95f, 0.80f);
314      PrintString(tmp);
315      if (curr->x_offset != 0 || curr->y_offset != 0) {
316        snprintf(tmp, sizeof(tmp), " (offset:%d,%d)",
317                 curr->x_offset, curr->y_offset);
318        glRasterPos2f(-0.95f, 0.70f);
319        PrintString(tmp);
320      }
321    }
322    glPopMatrix();
323  #if defined(__APPLE__) || defined(_WIN32)
324    glFlush();
325  #else
326    glutSwapBuffers();
327  #endif
328  }
329  static void StartDisplay(void) {
330    int width = kParams.canvas_width;
331    int height = kParams.canvas_height;
332    int screen_width, screen_height;
333  #if defined(__APPLE__) || defined(_WIN32)
334    glutInitDisplayMode(GLUT_RGBA);
335  #else
336    glutInitDisplayMode(GLUT_DOUBLE | GLUT_RGBA);
337  #endif
338    screen_width = glutGet(GLUT_SCREEN_WIDTH);
339    screen_height = glutGet(GLUT_SCREEN_HEIGHT);
340    if (width > screen_width || height > screen_height) {
341      if (width > screen_width) {
342        height = (height * screen_width + width - 1) / width;
343        width = screen_width;
344      }
345      if (height > screen_height) {
346        width = (width * screen_height + height - 1) / height;
347        height = screen_height;
348      }
349    }
350    glutInitWindowSize(width, height);
351    glutCreateWindow("WebP viewer");
352    glutDisplayFunc(HandleDisplay);
353    glutReshapeFunc(HandleReshape);
354    glutIdleFunc(NULL);
355    glutKeyboardFunc(HandleKey);
356    glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
357    glEnable(GL_BLEND);
358    glClearColor(0, 0, 0, 0);  
359    DrawBackground();
360  }
361  static void Help(void) {
362    printf(
363        "Usage: vwebp in_file [options]\n\n"
364        "Decodes the WebP image file and visualize it using OpenGL\n"
365        "Options are:\n"
366        "  -version ..... print version number and exit\n"
367        "  -noicc ....... don't use the icc profile if present\n"
368        "  -nofancy ..... don't use the fancy YUV420 upscaler\n"
369        "  -nofilter .... disable in-loop filtering\n"
370        "  -dither <int>  dithering strength (0..100), default=50\n"
371        "  -noalphadither disable alpha plane dithering\n"
372        "  -usebgcolor .. display background color\n"
373        "  -mt .......... use multi-threading\n"
374        "  -info ........ print info\n"
375        "  -h ........... this help message\n"
376        "\n"
377        "Keyboard shortcuts:\n"
378        "  'c' ................ toggle use of color profile\n"
379        "  'b' ................ toggle background color display\n"
380        "  'i' ................ overlay file information\n"
381        "  'd' ................ disable blending & disposal (debug)\n"
382        "  'q' / 'Q' / ESC .... quit\n");
383  }
384  int main(int argc, char* argv[]) {
385    int c;
386    WebPDecoderConfig* const config = &kParams.config;
387    WebPIterator* const curr = &kParams.curr_frame;
388    INIT_WARGV(argc, argv);
389    if (!WebPInitDecoderConfig(config)) {
390      fprintf(stderr, "Library version mismatch!\n");
391      FREE_WARGV_AND_RETURN(-1);
392    }
393    config->options.dithering_strength = 50;
394    config->options.alpha_dithering_strength = 100;
395    kParams.use_color_profile = 1;
396    kParams.draw_anim_background_color = 0;
397    for (c = 1; c < argc; ++c) {
398      int parse_error = 0;
399      if (!strcmp(argv[c], "-h") || !strcmp(argv[c], "-help")) {
400        Help();
401        FREE_WARGV_AND_RETURN(0);
402      } else if (!strcmp(argv[c], "-noicc")) {
403        kParams.use_color_profile = 0;
404      } else if (!strcmp(argv[c], "-nofancy")) {
405        config->options.no_fancy_upsampling = 1;
406      } else if (!strcmp(argv[c], "-nofilter")) {
407        config->options.bypass_filtering = 1;
408      } else if (!strcmp(argv[c], "-noalphadither")) {
409        config->options.alpha_dithering_strength = 0;
410      } else if (!strcmp(argv[c], "-usebgcolor")) {
411        kParams.draw_anim_background_color = 1;
412      } else if (!strcmp(argv[c], "-dither") && c + 1 < argc) {
413        config->options.dithering_strength =
414            ExUtilGetInt(argv[++c], 0, &parse_error);
415      } else if (!strcmp(argv[c], "-info")) {
416        kParams.print_info = 1;
417      } else if (!strcmp(argv[c], "-version")) {
418        const int dec_version = WebPGetDecoderVersion();
419        const int dmux_version = WebPGetDemuxVersion();
420        printf("WebP Decoder version: %d.%d.%d\nWebP Demux version: %d.%d.%d\n",
421               (dec_version >> 16) & 0xff, (dec_version >> 8) & 0xff,
422               dec_version & 0xff, (dmux_version >> 16) & 0xff,
423               (dmux_version >> 8) & 0xff, dmux_version & 0xff);
424        FREE_WARGV_AND_RETURN(0);
425      } else if (!strcmp(argv[c], "-mt")) {
426        config->options.use_threads = 1;
427      } else if (!strcmp(argv[c], "--")) {
428        if (c < argc - 1) kParams.file_name = (const char*)GET_WARGV(argv, ++c);
429        break;
430      } else if (argv[c][0] == '-') {
431        printf("Unknown option '%s'\n", argv[c]);
432        Help();
433        FREE_WARGV_AND_RETURN(-1);
434      } else {
435        kParams.file_name = (const char*)GET_WARGV(argv, c);
436      }
437      if (parse_error) {
438        Help();
439        FREE_WARGV_AND_RETURN(-1);
440      }
441    }
442    if (kParams.file_name == NULL) {
443      printf("missing input file!!\n");
444      Help();
445      FREE_WARGV_AND_RETURN(0);
446    }
447    if (!ImgIoUtilReadFile(kParams.file_name,
448                           &kParams.data.bytes, &kParams.data.size)) {
449      goto Error;
450    }
451    if (!WebPGetInfo(kParams.data.bytes, kParams.data.size, NULL, NULL)) {
452      fprintf(stderr, "Input file doesn't appear to be WebP format.\n");
453      goto Error;
454    }
455    kParams.dmux = WebPDemux(&kParams.data);
456    if (kParams.dmux == NULL) {
457      fprintf(stderr, "Could not create demuxing object!\n");
458      goto Error;
459    }
460    kParams.canvas_width = WebPDemuxGetI(kParams.dmux, WEBP_FF_CANVAS_WIDTH);
461    kParams.canvas_height = WebPDemuxGetI(kParams.dmux, WEBP_FF_CANVAS_HEIGHT);
462    if (kParams.print_info) {
463      printf("Canvas: %d x %d\n", kParams.canvas_width, kParams.canvas_height);
464    }
465    ClearPreviousFrame();
466    memset(&kParams.iccp, 0, sizeof(kParams.iccp));
467    kParams.has_color_profile =
468        !!(WebPDemuxGetI(kParams.dmux, WEBP_FF_FORMAT_FLAGS) & ICCP_FLAG);
469    if (kParams.has_color_profile) {
470  #ifdef WEBP_HAVE_QCMS
471      if (!WebPDemuxGetChunk(kParams.dmux, "ICCP", 1, &kParams.iccp)) goto Error;
472      printf("VP8X: Found color profile\n");
473  #else
474      fprintf(stderr, "Warning: color profile present, but qcms is unavailable!\n"
475              "Build libqcms from Mozilla or Chromium and define WEBP_HAVE_QCMS "
476              "before building.\n");
477  #endif
478    }
479    if (!WebPDemuxGetFrame(kParams.dmux, 1, curr)) goto Error;
480    kParams.has_animation = (curr->num_frames > 1);
481    kParams.loop_count = (int)WebPDemuxGetI(kParams.dmux, WEBP_FF_LOOP_COUNT);
482    kParams.bg_color = WebPDemuxGetI(kParams.dmux, WEBP_FF_BACKGROUND_COLOR);
483    printf("VP8X: Found %d images in file (loop count = %d)\n",
484           curr->num_frames, kParams.loop_count);
485    if (!Decode()) goto Error;
486    WebPDemuxGetFrame(kParams.dmux, 0, curr);
487    if (kParams.loop_count) ++kParams.loop_count;
488  #if defined(__unix__) || defined(__CYGWIN__)
489    setenv("XLIB_SKIP_ARGB_VISUALS", "1", 1);
490  #endif
491    glutInit(&argc, argv);
492  #ifdef FREEGLUT
493    glutSetOption(GLUT_ACTION_ON_WINDOW_CLOSE, GLUT_ACTION_CONTINUE_EXECUTION);
494  #endif
495    StartDisplay();
496    if (kParams.has_animation) glutTimerFunc(0, decode_callback, 0);
497    glutMainLoop();
498    ClearParams();
499    FREE_WARGV_AND_RETURN(0);
500   Error:
501    ClearParams();
502    FREE_WARGV_AND_RETURN(-1);
503  }
504  #else   
505  int main(int argc, const char* argv[]) {
506    fprintf(stderr, "OpenGL support not enabled in %s.\n", argv[0]);
507    (void)argc;
508    return 0;
509  }
510  #endif
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from PINRemoteImage-MDEwOlJlcG9zaXRvcnkzOTUzNzEwMw==-flat-vwebp.c</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from PINRemoteImage-MDEwOlJlcG9zaXRvcnkzOTUzNzEwMw==-flat-vwebp.c</div>
                </div>
                <div class="column column_space"><pre><code>58    WebPDataClear(&kParams.data);
59    WebPDemuxReleaseIterator(&kParams.curr_frame);
60    WebPDemuxReleaseIterator(&kParams.prev_frame);
</pre></code></div>
                <div class="column column_space"><pre><code>60    WebPDemuxReleaseIterator(&kParams.prev_frame);
61    WebPDemuxReleaseChunkIterator(&kParams.iccp);
62    WebPDemuxDelete(kParams.dmux);
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    