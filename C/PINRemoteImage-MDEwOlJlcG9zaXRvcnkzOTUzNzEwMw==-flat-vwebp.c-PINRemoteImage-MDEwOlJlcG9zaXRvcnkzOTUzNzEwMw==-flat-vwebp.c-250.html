
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 16, <button onclick='openModal()' class='match'>CODE CLONE</button></h2>
        <div class="column">
            <h3>PINRemoteImage-MDEwOlJlcG9zaXRvcnkzOTUzNzEwMw==-flat-vwebp.c</h3>
            <pre><code>1  #ifdef HAVE_CONFIG_H
2  #include &quot;webp/config.h&quot;
3  #endif
4  #if defined(__unix__) || defined(__CYGWIN__)
5  #define _POSIX_C_SOURCE 200112L  
6  #endif
7  #include &lt;stdio.h&gt;
8  #include &lt;stdlib.h&gt;
9  #include &lt;string.h&gt;
10  #if defined(WEBP_HAVE_GL)
11  #if defined(HAVE_GLUT_GLUT_H)
12  #include &lt;GLUT/glut.h&gt;
13  #else
14  #include &lt;GL/glut.h&gt;
15  #ifdef FREEGLUT
16  #include &lt;GL/freeglut.h&gt;
17  #endif
18  #endif
19  #ifdef WEBP_HAVE_QCMS
20  #include &lt;qcms.h&gt;
21  #endif
22  #include &quot;webp/decode.h&quot;
23  #include &quot;webp/demux.h&quot;
24  #include &quot;../examples/example_util.h&quot;
25  #include &quot;../imageio/imageio_util.h&quot;
26  #include &quot;./unicode.h&quot;
27  #if defined(_MSC_VER) &amp;&amp; _MSC_VER &lt; 1900
28  #define snprintf _snprintf
29  #endif
30  static struct {
31    int has_animation;
32    int has_color_profile;
33    int done;
34    int decoding_error;
35    int print_info;
36    int only_deltas;
37    int use_color_profile;
38    int draw_anim_background_color;
39    int canvas_width, canvas_height;
40    int loop_count;
41    uint32_t bg_color;
42    const char* file_name;
43    WebPData data;
44    WebPDecoderConfig config;
45    const WebPDecBuffer* pic;
46    WebPDemuxer* dmux;
47    WebPIterator curr_frame;
48    WebPIterator prev_frame;
49    WebPChunkIterator iccp;
50    int viewport_width, viewport_height;
51  } kParams;
52  static void ClearPreviousPic(void) {
53    WebPFreeDecBuffer((WebPDecBuffer*)kParams.pic);
54    kParams.pic = NULL;
55  }
56  static void ClearParams(void) {
57    ClearPreviousPic();
<span onclick='openModal()' class='match'>58    WebPDataClear(&amp;kParams.data);
59    WebPDemuxReleaseIterator(&amp;kParams.curr_frame);
60    WebPDemuxReleaseIterator(&amp;kParams.prev_frame);
</span>61    WebPDemuxReleaseChunkIterator(&amp;kParams.iccp);
62    WebPDemuxDelete(kParams.dmux);
63    kParams.dmux = NULL;
64  }
65  static void ClearPreviousFrame(void) {
66    WebPIterator* const prev = &amp;kParams.prev_frame;
67    prev-&gt;width = kParams.canvas_width;
68    prev-&gt;height = kParams.canvas_height;
69    prev-&gt;x_offset = prev-&gt;y_offset = 0;
70    prev-&gt;dispose_method = WEBP_MUX_DISPOSE_BACKGROUND;
71  }
72  static int ApplyColorProfile(const WebPData* const profile,
73                               WebPDecBuffer* const rgba) {
74  #ifdef WEBP_HAVE_QCMS
75    int i, ok = 0;
76    uint8_t* line;
77    uint8_t major_revision;
78    qcms_profile* input_profile = NULL;
79    qcms_profile* output_profile = NULL;
80    qcms_transform* transform = NULL;
81    const qcms_data_type input_type = QCMS_DATA_RGBA_8;
82    const qcms_data_type output_type = QCMS_DATA_RGBA_8;
83    const qcms_intent intent = QCMS_INTENT_DEFAULT;
84    if (profile == NULL || rgba == NULL) return 0;
85    if (profile-&gt;bytes == NULL || profile-&gt;size &lt; 10) return 1;
86    major_revision = profile-&gt;bytes[8];
87    qcms_enable_iccv4();
88    input_profile = qcms_profile_from_memory(profile-&gt;bytes, profile-&gt;size);
89    if (input_profile == NULL ||
90        (major_revision &lt; 4 &amp;&amp; qcms_profile_is_bogus(input_profile))) {
91      fprintf(stderr, &quot;Color profile is bogus!\n&quot;);
92      goto Error;
93    }
94    output_profile = qcms_profile_sRGB();
95    if (output_profile == NULL) {
96      fprintf(stderr, &quot;Error creating output color profile!\n&quot;);
97      goto Error;
98    }
99    qcms_profile_precache_output_transform(output_profile);
100    transform = qcms_transform_create(input_profile, input_type,
101                                      output_profile, output_type,
102                                      intent);
103    if (transform == NULL) {
104      fprintf(stderr, &quot;Error creating color transform!\n&quot;);
105      goto Error;
106    }
107    line = rgba-&gt;u.RGBA.rgba;
108    for (i = 0; i &lt; rgba-&gt;height; ++i, line += rgba-&gt;u.RGBA.stride) {
109      qcms_transform_data(transform, line, line, rgba-&gt;width);
110    }
111    ok = 1;
112   Error:
113    if (input_profile != NULL) qcms_profile_release(input_profile);
114    if (output_profile != NULL) qcms_profile_release(output_profile);
115    if (transform != NULL) qcms_transform_release(transform);
116    return ok;
117  #else
118    (void)profile;
119    (void)rgba;
120    return 1;
121  #endif  
122  }
123  static int Decode(void) {   
124    const WebPIterator* const curr = &amp;kParams.curr_frame;
125    WebPDecoderConfig* const config = &amp;kParams.config;
126    WebPDecBuffer* const output_buffer = &amp;config-&gt;output;
127    int ok = 0;
128    ClearPreviousPic();
129    output_buffer-&gt;colorspace = MODE_RGBA;
130    ok = (WebPDecode(curr-&gt;fragment.bytes, curr-&gt;fragment.size,
131                     config) == VP8_STATUS_OK);
132    if (!ok) {
133      fprintf(stderr, &quot;Decoding of frame #%d failed!\n&quot;, curr-&gt;frame_num);
134    } else {
135      kParams.pic = output_buffer;
136      if (kParams.use_color_profile) {
137        ok = ApplyColorProfile(&amp;kParams.iccp.chunk, output_buffer);
138        if (!ok) {
139          fprintf(stderr, &quot;Applying color profile to frame #%d failed!\n&quot;,
140                  curr-&gt;frame_num);
141        }
142      }
143    }
144    return ok;
145  }
146  static void decode_callback(int what) {
147    if (what == 0 &amp;&amp; !kParams.done) {
148      int duration = 0;
149      if (kParams.dmux != NULL) {
150        WebPIterator* const curr = &amp;kParams.curr_frame;
151        if (!WebPDemuxNextFrame(curr)) {
152          WebPDemuxReleaseIterator(curr);
153          if (WebPDemuxGetFrame(kParams.dmux, 1, curr)) {
154            --kParams.loop_count;
155            kParams.done = (kParams.loop_count == 0);
156            if (kParams.done) return;
157            ClearPreviousFrame();
158          } else {
159            kParams.decoding_error = 1;
160            kParams.done = 1;
161            return;
162          }
163        }
164        duration = curr-&gt;duration;
165        if (duration &lt;= 10) duration = 100;
166      }
167      if (!Decode()) {
168        kParams.decoding_error = 1;
169        kParams.done = 1;
170      } else {
171        glutPostRedisplay();
172        glutTimerFunc(duration, decode_callback, what);
173      }
174    }
175  }
176  static void HandleKey(unsigned char key, int pos_x, int pos_y) {
177    (void)pos_x;
178    (void)pos_y;
179    if (key == &#x27;q&#x27; || key == &#x27;Q&#x27; || key == 27 &amp;bsol;* Esc */) {
180  #ifdef FREEGLUT
181      glutLeaveMainLoop();
182  #else
183      ClearParams();
184      exit(0);
185  #endif
186    } else if (key == &#x27;c&#x27;) {
187      if (kParams.has_color_profile &amp;&amp; !kParams.decoding_error) {
188        kParams.use_color_profile = 1 - kParams.use_color_profile;
189        if (kParams.has_animation) {
190          if (kParams.done &amp;&amp; kParams.loop_count == 0) {
191            kParams.loop_count =
192                (int)WebPDemuxGetI(kParams.dmux, WEBP_FF_LOOP_COUNT) + 1;
193            kParams.done = 0;
194            glutTimerFunc(0, decode_callback, 0);
195          }
196        } else {
197          Decode();
198          glutPostRedisplay();
199        }
200      }
201    } else if (key == &#x27;b&#x27;) {
202      kParams.draw_anim_background_color = 1 - kParams.draw_anim_background_color;
203      if (!kParams.has_animation) ClearPreviousFrame();
204      glutPostRedisplay();
205    } else if (key == &#x27;i&#x27;) {
206      kParams.print_info = 1 - kParams.print_info;
207      if (!kParams.has_animation) ClearPreviousFrame();
208      glutPostRedisplay();
209    } else if (key == &#x27;d&#x27;) {
210      kParams.only_deltas = 1 - kParams.only_deltas;
211      glutPostRedisplay();
212    }
213  }
214  static void HandleReshape(int width, int height) {
215    glViewport(0, 0, width, height);
216    glMatrixMode(GL_PROJECTION);
217    glLoadIdentity();
218    glMatrixMode(GL_MODELVIEW);
219    glLoadIdentity();
220    kParams.viewport_width = width;
221    kParams.viewport_height = height;
222    if (!kParams.has_animation) ClearPreviousFrame();
223  }
224  static void PrintString(const char* const text) {
225    void* const font = GLUT_BITMAP_9_BY_15;
226    int i;
227    for (i = 0; text[i]; ++i) {
228      glutBitmapCharacter(font, text[i]);
229    }
230  }
231  static float GetColorf(uint32_t color, int shift) {
232    return ((color &gt;&gt; shift) &amp; 0xff) / 255.f;
233  }
234  static void DrawCheckerBoard(void) {
235    const int square_size = 8;  
236    int x, y;
237    GLint viewport[4];  
238    glPushMatrix();
239    glGetIntegerv(GL_VIEWPORT, viewport);
240    glOrtho(0, viewport[2], viewport[3], 0, -1, 1);
241    for (y = 0; y &lt; viewport[3]; y += square_size) {
242      for (x = 0; x &lt; viewport[2]; x += square_size) {
243        const GLubyte color = 128 + 64 * (!((x + y) &amp; square_size));
244        glColor3ub(color, color, color);
245        glRecti(x, y, x + square_size, y + square_size);
246      }
247    }
248    glPopMatrix();
249  }
250  static void DrawBackground(void) {
251    glClear(GL_COLOR_BUFFER_BIT);
252    DrawCheckerBoard();
253    if (kParams.draw_anim_background_color) {
254      glPushMatrix();
255      glLoadIdentity();
256      glColor4f(GetColorf(kParams.bg_color, 16),  
257                GetColorf(kParams.bg_color, 8),
258                GetColorf(kParams.bg_color, 0),
259                GetColorf(kParams.bg_color, 24));
260      glRecti(-1, -1, +1, +1);
261      glPopMatrix();
262    }
263  }
264  static void DrawBackgroundScissored(int window_x, int window_y, int frame_w,
265                                      int frame_h) {
266    window_x = window_x * kParams.viewport_width / kParams.canvas_width;
267    window_y = window_y * kParams.viewport_height / kParams.canvas_height;
268    frame_w = frame_w * kParams.viewport_width / kParams.canvas_width;
269    frame_h = frame_h * kParams.viewport_height / kParams.canvas_height;
270    window_y = kParams.viewport_height - window_y - frame_h;
271    glEnable(GL_SCISSOR_TEST);
272    glScissor(window_x, window_y, frame_w, frame_h);
273    DrawBackground();
274    glDisable(GL_SCISSOR_TEST);
275  }
276  static void HandleDisplay(void) {
277    const WebPDecBuffer* const pic = kParams.pic;
278    const WebPIterator* const curr = &amp;kParams.curr_frame;
279    WebPIterator* const prev = &amp;kParams.prev_frame;
280    GLfloat xoff, yoff;
281    if (pic == NULL) return;
282    glPushMatrix();
283    glPixelZoom((GLfloat)(+1. / kParams.canvas_width * kParams.viewport_width),
284                (GLfloat)(-1. / kParams.canvas_height * kParams.viewport_height));
285    xoff = (GLfloat)(2. * curr-&gt;x_offset / kParams.canvas_width);
286    yoff = (GLfloat)(2. * curr-&gt;y_offset / kParams.canvas_height);
287    glRasterPos2f(-1.f + xoff, 1.f - yoff);
288    glPixelStorei(GL_UNPACK_ALIGNMENT, 1);
289    glPixelStorei(GL_UNPACK_ROW_LENGTH, pic-&gt;u.RGBA.stride / 4);
290    if (kParams.only_deltas) {
291      DrawBackground();
292    } else {
293      if (prev-&gt;dispose_method == WEBP_MUX_DISPOSE_BACKGROUND) {
294        DrawBackgroundScissored(prev-&gt;x_offset, prev-&gt;y_offset, prev-&gt;width,
295                                prev-&gt;height);
296      }
297      if (curr-&gt;blend_method == WEBP_MUX_NO_BLEND) {
298        DrawBackgroundScissored(curr-&gt;x_offset, curr-&gt;y_offset, curr-&gt;width,
299                                curr-&gt;height);
300      }
301    }
302    *prev = *curr;
303    glDrawPixels(pic-&gt;width, pic-&gt;height,
304                 GL_RGBA, GL_UNSIGNED_BYTE,
305                 (GLvoid*)pic-&gt;u.RGBA.rgba);
306    if (kParams.print_info) {
307      char tmp[32];
308      glColor4f(0.90f, 0.0f, 0.90f, 1.0f);
309      glRasterPos2f(-0.95f, 0.90f);
310      PrintString(kParams.file_name);
311      snprintf(tmp, sizeof(tmp), &quot;Dimension:%d x %d&quot;, pic-&gt;width, pic-&gt;height);
312      glColor4f(0.90f, 0.0f, 0.90f, 1.0f);
313      glRasterPos2f(-0.95f, 0.80f);
314      PrintString(tmp);
315      if (curr-&gt;x_offset != 0 || curr-&gt;y_offset != 0) {
316        snprintf(tmp, sizeof(tmp), &quot; (offset:%d,%d)&quot;,
317                 curr-&gt;x_offset, curr-&gt;y_offset);
318        glRasterPos2f(-0.95f, 0.70f);
319        PrintString(tmp);
320      }
321    }
322    glPopMatrix();
323  #if defined(__APPLE__) || defined(_WIN32)
324    glFlush();
325  #else
326    glutSwapBuffers();
327  #endif
328  }
329  static void StartDisplay(void) {
330    int width = kParams.canvas_width;
331    int height = kParams.canvas_height;
332    int screen_width, screen_height;
333  #if defined(__APPLE__) || defined(_WIN32)
334    glutInitDisplayMode(GLUT_RGBA);
335  #else
336    glutInitDisplayMode(GLUT_DOUBLE | GLUT_RGBA);
337  #endif
338    screen_width = glutGet(GLUT_SCREEN_WIDTH);
339    screen_height = glutGet(GLUT_SCREEN_HEIGHT);
340    if (width &gt; screen_width || height &gt; screen_height) {
341      if (width &gt; screen_width) {
342        height = (height * screen_width + width - 1) / width;
343        width = screen_width;
344      }
345      if (height &gt; screen_height) {
346        width = (width * screen_height + height - 1) / height;
347        height = screen_height;
348      }
349    }
350    glutInitWindowSize(width, height);
351    glutCreateWindow(&quot;WebP viewer&quot;);
352    glutDisplayFunc(HandleDisplay);
353    glutReshapeFunc(HandleReshape);
354    glutIdleFunc(NULL);
355    glutKeyboardFunc(HandleKey);
356    glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
357    glEnable(GL_BLEND);
358    glClearColor(0, 0, 0, 0);  
359    DrawBackground();
360  }
361  static void Help(void) {
362    printf(
363        &quot;Usage: vwebp in_file [options]\n\n&quot;
364        &quot;Decodes the WebP image file and visualize it using OpenGL\n&quot;
365        &quot;Options are:\n&quot;
366        &quot;  -version ..... print version number and exit\n&quot;
367        &quot;  -noicc ....... don&#x27;t use the icc profile if present\n&quot;
368        &quot;  -nofancy ..... don&#x27;t use the fancy YUV420 upscaler\n&quot;
369        &quot;  -nofilter .... disable in-loop filtering\n&quot;
370        &quot;  -dither &lt;int&gt;  dithering strength (0..100), default=50\n&quot;
371        &quot;  -noalphadither disable alpha plane dithering\n&quot;
372        &quot;  -usebgcolor .. display background color\n&quot;
373        &quot;  -mt .......... use multi-threading\n&quot;
374        &quot;  -info ........ print info\n&quot;
375        &quot;  -h ........... this help message\n&quot;
376        &quot;\n&quot;
377        &quot;Keyboard shortcuts:\n&quot;
378        &quot;  &#x27;c&#x27; ................ toggle use of color profile\n&quot;
379        &quot;  &#x27;b&#x27; ................ toggle background color display\n&quot;
380        &quot;  &#x27;i&#x27; ................ overlay file information\n&quot;
381        &quot;  &#x27;d&#x27; ................ disable blending &amp; disposal (debug)\n&quot;
382        &quot;  &#x27;q&#x27; / &#x27;Q&#x27; / ESC .... quit\n&quot;);
383  }
384  int main(int argc, char* argv[]) {
385    int c;
386    WebPDecoderConfig* const config = &amp;kParams.config;
387    WebPIterator* const curr = &amp;kParams.curr_frame;
388    INIT_WARGV(argc, argv);
389    if (!WebPInitDecoderConfig(config)) {
390      fprintf(stderr, &quot;Library version mismatch!\n&quot;);
391      FREE_WARGV_AND_RETURN(-1);
392    }
393    config-&gt;options.dithering_strength = 50;
394    config-&gt;options.alpha_dithering_strength = 100;
395    kParams.use_color_profile = 1;
396    kParams.draw_anim_background_color = 0;
397    for (c = 1; c &lt; argc; ++c) {
398      int parse_error = 0;
399      if (!strcmp(argv[c], &quot;-h&quot;) || !strcmp(argv[c], &quot;-help&quot;)) {
400        Help();
401        FREE_WARGV_AND_RETURN(0);
402      } else if (!strcmp(argv[c], &quot;-noicc&quot;)) {
403        kParams.use_color_profile = 0;
404      } else if (!strcmp(argv[c], &quot;-nofancy&quot;)) {
405        config-&gt;options.no_fancy_upsampling = 1;
406      } else if (!strcmp(argv[c], &quot;-nofilter&quot;)) {
407        config-&gt;options.bypass_filtering = 1;
408      } else if (!strcmp(argv[c], &quot;-noalphadither&quot;)) {
409        config-&gt;options.alpha_dithering_strength = 0;
410      } else if (!strcmp(argv[c], &quot;-usebgcolor&quot;)) {
411        kParams.draw_anim_background_color = 1;
412      } else if (!strcmp(argv[c], &quot;-dither&quot;) &amp;&amp; c + 1 &lt; argc) {
413        config-&gt;options.dithering_strength =
414            ExUtilGetInt(argv[++c], 0, &amp;parse_error);
415      } else if (!strcmp(argv[c], &quot;-info&quot;)) {
416        kParams.print_info = 1;
417      } else if (!strcmp(argv[c], &quot;-version&quot;)) {
418        const int dec_version = WebPGetDecoderVersion();
419        const int dmux_version = WebPGetDemuxVersion();
420        printf(&quot;WebP Decoder version: %d.%d.%d\nWebP Demux version: %d.%d.%d\n&quot;,
421               (dec_version &gt;&gt; 16) &amp; 0xff, (dec_version &gt;&gt; 8) &amp; 0xff,
422               dec_version &amp; 0xff, (dmux_version &gt;&gt; 16) &amp; 0xff,
423               (dmux_version &gt;&gt; 8) &amp; 0xff, dmux_version &amp; 0xff);
424        FREE_WARGV_AND_RETURN(0);
425      } else if (!strcmp(argv[c], &quot;-mt&quot;)) {
426        config-&gt;options.use_threads = 1;
427      } else if (!strcmp(argv[c], &quot;--&quot;)) {
428        if (c &lt; argc - 1) kParams.file_name = (const char*)GET_WARGV(argv, ++c);
429        break;
430      } else if (argv[c][0] == &#x27;-&#x27;) {
431        printf(&quot;Unknown option &#x27;%s&#x27;\n&quot;, argv[c]);
432        Help();
433        FREE_WARGV_AND_RETURN(-1);
434      } else {
435        kParams.file_name = (const char*)GET_WARGV(argv, c);
436      }
437      if (parse_error) {
438        Help();
439        FREE_WARGV_AND_RETURN(-1);
440      }
441    }
442    if (kParams.file_name == NULL) {
443      printf(&quot;missing input file!!\n&quot;);
444      Help();
445      FREE_WARGV_AND_RETURN(0);
446    }
447    if (!ImgIoUtilReadFile(kParams.file_name,
448                           &amp;kParams.data.bytes, &amp;kParams.data.size)) {
449      goto Error;
450    }
451    if (!WebPGetInfo(kParams.data.bytes, kParams.data.size, NULL, NULL)) {
452      fprintf(stderr, &quot;Input file doesn&#x27;t appear to be WebP format.\n&quot;);
453      goto Error;
454    }
455    kParams.dmux = WebPDemux(&amp;kParams.data);
456    if (kParams.dmux == NULL) {
457      fprintf(stderr, &quot;Could not create demuxing object!\n&quot;);
458      goto Error;
459    }
460    kParams.canvas_width = WebPDemuxGetI(kParams.dmux, WEBP_FF_CANVAS_WIDTH);
461    kParams.canvas_height = WebPDemuxGetI(kParams.dmux, WEBP_FF_CANVAS_HEIGHT);
462    if (kParams.print_info) {
463      printf(&quot;Canvas: %d x %d\n&quot;, kParams.canvas_width, kParams.canvas_height);
464    }
465    ClearPreviousFrame();
466    memset(&amp;kParams.iccp, 0, sizeof(kParams.iccp));
467    kParams.has_color_profile =
468        !!(WebPDemuxGetI(kParams.dmux, WEBP_FF_FORMAT_FLAGS) &amp; ICCP_FLAG);
469    if (kParams.has_color_profile) {
470  #ifdef WEBP_HAVE_QCMS
471      if (!WebPDemuxGetChunk(kParams.dmux, &quot;ICCP&quot;, 1, &amp;kParams.iccp)) goto Error;
472      printf(&quot;VP8X: Found color profile\n&quot;);
473  #else
474      fprintf(stderr, &quot;Warning: color profile present, but qcms is unavailable!\n&quot;
475              &quot;Build libqcms from Mozilla or Chromium and define WEBP_HAVE_QCMS &quot;
476              &quot;before building.\n&quot;);
477  #endif
478    }
479    if (!WebPDemuxGetFrame(kParams.dmux, 1, curr)) goto Error;
480    kParams.has_animation = (curr-&gt;num_frames &gt; 1);
481    kParams.loop_count = (int)WebPDemuxGetI(kParams.dmux, WEBP_FF_LOOP_COUNT);
482    kParams.bg_color = WebPDemuxGetI(kParams.dmux, WEBP_FF_BACKGROUND_COLOR);
483    printf(&quot;VP8X: Found %d images in file (loop count = %d)\n&quot;,
484           curr-&gt;num_frames, kParams.loop_count);
485    if (!Decode()) goto Error;
486    WebPDemuxGetFrame(kParams.dmux, 0, curr);
487    if (kParams.loop_count) ++kParams.loop_count;
488  #if defined(__unix__) || defined(__CYGWIN__)
489    setenv(&quot;XLIB_SKIP_ARGB_VISUALS&quot;, &quot;1&quot;, 1);
490  #endif
491    glutInit(&amp;argc, argv);
492  #ifdef FREEGLUT
493    glutSetOption(GLUT_ACTION_ON_WINDOW_CLOSE, GLUT_ACTION_CONTINUE_EXECUTION);
494  #endif
495    StartDisplay();
496    if (kParams.has_animation) glutTimerFunc(0, decode_callback, 0);
497    glutMainLoop();
498    ClearParams();
499    FREE_WARGV_AND_RETURN(0);
500   Error:
501    ClearParams();
502    FREE_WARGV_AND_RETURN(-1);
503  }
504  #else   
505  int main(int argc, const char* argv[]) {
506    fprintf(stderr, &quot;OpenGL support not enabled in %s.\n&quot;, argv[0]);
507    (void)argc;
508    return 0;
509  }
510  #endif
</code></pre>
        </div>
        <div class="column">
            <h3>PINRemoteImage-MDEwOlJlcG9zaXRvcnkzOTUzNzEwMw==-flat-vwebp.c</h3>
            <pre><code>1  #ifdef HAVE_CONFIG_H
2  #include &quot;webp/config.h&quot;
3  #endif
4  #if defined(__unix__) || defined(__CYGWIN__)
5  #define _POSIX_C_SOURCE 200112L  
6  #endif
7  #include &lt;stdio.h&gt;
8  #include &lt;stdlib.h&gt;
9  #include &lt;string.h&gt;
10  #if defined(WEBP_HAVE_GL)
11  #if defined(HAVE_GLUT_GLUT_H)
12  #include &lt;GLUT/glut.h&gt;
13  #else
14  #include &lt;GL/glut.h&gt;
15  #ifdef FREEGLUT
16  #include &lt;GL/freeglut.h&gt;
17  #endif
18  #endif
19  #ifdef WEBP_HAVE_QCMS
20  #include &lt;qcms.h&gt;
21  #endif
22  #include &quot;webp/decode.h&quot;
23  #include &quot;webp/demux.h&quot;
24  #include &quot;../examples/example_util.h&quot;
25  #include &quot;../imageio/imageio_util.h&quot;
26  #include &quot;./unicode.h&quot;
27  #if defined(_MSC_VER) &amp;&amp; _MSC_VER &lt; 1900
28  #define snprintf _snprintf
29  #endif
30  static struct {
31    int has_animation;
32    int has_color_profile;
33    int done;
34    int decoding_error;
35    int print_info;
36    int only_deltas;
37    int use_color_profile;
38    int draw_anim_background_color;
39    int canvas_width, canvas_height;
40    int loop_count;
41    uint32_t bg_color;
42    const char* file_name;
43    WebPData data;
44    WebPDecoderConfig config;
45    const WebPDecBuffer* pic;
46    WebPDemuxer* dmux;
47    WebPIterator curr_frame;
48    WebPIterator prev_frame;
49    WebPChunkIterator iccp;
50    int viewport_width, viewport_height;
51  } kParams;
52  static void ClearPreviousPic(void) {
53    WebPFreeDecBuffer((WebPDecBuffer*)kParams.pic);
54    kParams.pic = NULL;
55  }
56  static void ClearParams(void) {
57    ClearPreviousPic();
58    WebPDataClear(&amp;kParams.data);
59    WebPDemuxReleaseIterator(&amp;kParams.curr_frame);
<span onclick='openModal()' class='match'>60    WebPDemuxReleaseIterator(&amp;kParams.prev_frame);
61    WebPDemuxReleaseChunkIterator(&amp;kParams.iccp);
62    WebPDemuxDelete(kParams.dmux);
</span>63    kParams.dmux = NULL;
64  }
65  static void ClearPreviousFrame(void) {
66    WebPIterator* const prev = &amp;kParams.prev_frame;
67    prev-&gt;width = kParams.canvas_width;
68    prev-&gt;height = kParams.canvas_height;
69    prev-&gt;x_offset = prev-&gt;y_offset = 0;
70    prev-&gt;dispose_method = WEBP_MUX_DISPOSE_BACKGROUND;
71  }
72  static int ApplyColorProfile(const WebPData* const profile,
73                               WebPDecBuffer* const rgba) {
74  #ifdef WEBP_HAVE_QCMS
75    int i, ok = 0;
76    uint8_t* line;
77    uint8_t major_revision;
78    qcms_profile* input_profile = NULL;
79    qcms_profile* output_profile = NULL;
80    qcms_transform* transform = NULL;
81    const qcms_data_type input_type = QCMS_DATA_RGBA_8;
82    const qcms_data_type output_type = QCMS_DATA_RGBA_8;
83    const qcms_intent intent = QCMS_INTENT_DEFAULT;
84    if (profile == NULL || rgba == NULL) return 0;
85    if (profile-&gt;bytes == NULL || profile-&gt;size &lt; 10) return 1;
86    major_revision = profile-&gt;bytes[8];
87    qcms_enable_iccv4();
88    input_profile = qcms_profile_from_memory(profile-&gt;bytes, profile-&gt;size);
89    if (input_profile == NULL ||
90        (major_revision &lt; 4 &amp;&amp; qcms_profile_is_bogus(input_profile))) {
91      fprintf(stderr, &quot;Color profile is bogus!\n&quot;);
92      goto Error;
93    }
94    output_profile = qcms_profile_sRGB();
95    if (output_profile == NULL) {
96      fprintf(stderr, &quot;Error creating output color profile!\n&quot;);
97      goto Error;
98    }
99    qcms_profile_precache_output_transform(output_profile);
100    transform = qcms_transform_create(input_profile, input_type,
101                                      output_profile, output_type,
102                                      intent);
103    if (transform == NULL) {
104      fprintf(stderr, &quot;Error creating color transform!\n&quot;);
105      goto Error;
106    }
107    line = rgba-&gt;u.RGBA.rgba;
108    for (i = 0; i &lt; rgba-&gt;height; ++i, line += rgba-&gt;u.RGBA.stride) {
109      qcms_transform_data(transform, line, line, rgba-&gt;width);
110    }
111    ok = 1;
112   Error:
113    if (input_profile != NULL) qcms_profile_release(input_profile);
114    if (output_profile != NULL) qcms_profile_release(output_profile);
115    if (transform != NULL) qcms_transform_release(transform);
116    return ok;
117  #else
118    (void)profile;
119    (void)rgba;
120    return 1;
121  #endif  
122  }
123  static int Decode(void) {   
124    const WebPIterator* const curr = &amp;kParams.curr_frame;
125    WebPDecoderConfig* const config = &amp;kParams.config;
126    WebPDecBuffer* const output_buffer = &amp;config-&gt;output;
127    int ok = 0;
128    ClearPreviousPic();
129    output_buffer-&gt;colorspace = MODE_RGBA;
130    ok = (WebPDecode(curr-&gt;fragment.bytes, curr-&gt;fragment.size,
131                     config) == VP8_STATUS_OK);
132    if (!ok) {
133      fprintf(stderr, &quot;Decoding of frame #%d failed!\n&quot;, curr-&gt;frame_num);
134    } else {
135      kParams.pic = output_buffer;
136      if (kParams.use_color_profile) {
137        ok = ApplyColorProfile(&amp;kParams.iccp.chunk, output_buffer);
138        if (!ok) {
139          fprintf(stderr, &quot;Applying color profile to frame #%d failed!\n&quot;,
140                  curr-&gt;frame_num);
141        }
142      }
143    }
144    return ok;
145  }
146  static void decode_callback(int what) {
147    if (what == 0 &amp;&amp; !kParams.done) {
148      int duration = 0;
149      if (kParams.dmux != NULL) {
150        WebPIterator* const curr = &amp;kParams.curr_frame;
151        if (!WebPDemuxNextFrame(curr)) {
152          WebPDemuxReleaseIterator(curr);
153          if (WebPDemuxGetFrame(kParams.dmux, 1, curr)) {
154            --kParams.loop_count;
155            kParams.done = (kParams.loop_count == 0);
156            if (kParams.done) return;
157            ClearPreviousFrame();
158          } else {
159            kParams.decoding_error = 1;
160            kParams.done = 1;
161            return;
162          }
163        }
164        duration = curr-&gt;duration;
165        if (duration &lt;= 10) duration = 100;
166      }
167      if (!Decode()) {
168        kParams.decoding_error = 1;
169        kParams.done = 1;
170      } else {
171        glutPostRedisplay();
172        glutTimerFunc(duration, decode_callback, what);
173      }
174    }
175  }
176  static void HandleKey(unsigned char key, int pos_x, int pos_y) {
177    (void)pos_x;
178    (void)pos_y;
179    if (key == &#x27;q&#x27; || key == &#x27;Q&#x27; || key == 27 &amp;bsol;* Esc */) {
180  #ifdef FREEGLUT
181      glutLeaveMainLoop();
182  #else
183      ClearParams();
184      exit(0);
185  #endif
186    } else if (key == &#x27;c&#x27;) {
187      if (kParams.has_color_profile &amp;&amp; !kParams.decoding_error) {
188        kParams.use_color_profile = 1 - kParams.use_color_profile;
189        if (kParams.has_animation) {
190          if (kParams.done &amp;&amp; kParams.loop_count == 0) {
191            kParams.loop_count =
192                (int)WebPDemuxGetI(kParams.dmux, WEBP_FF_LOOP_COUNT) + 1;
193            kParams.done = 0;
194            glutTimerFunc(0, decode_callback, 0);
195          }
196        } else {
197          Decode();
198          glutPostRedisplay();
199        }
200      }
201    } else if (key == &#x27;b&#x27;) {
202      kParams.draw_anim_background_color = 1 - kParams.draw_anim_background_color;
203      if (!kParams.has_animation) ClearPreviousFrame();
204      glutPostRedisplay();
205    } else if (key == &#x27;i&#x27;) {
206      kParams.print_info = 1 - kParams.print_info;
207      if (!kParams.has_animation) ClearPreviousFrame();
208      glutPostRedisplay();
209    } else if (key == &#x27;d&#x27;) {
210      kParams.only_deltas = 1 - kParams.only_deltas;
211      glutPostRedisplay();
212    }
213  }
214  static void HandleReshape(int width, int height) {
215    glViewport(0, 0, width, height);
216    glMatrixMode(GL_PROJECTION);
217    glLoadIdentity();
218    glMatrixMode(GL_MODELVIEW);
219    glLoadIdentity();
220    kParams.viewport_width = width;
221    kParams.viewport_height = height;
222    if (!kParams.has_animation) ClearPreviousFrame();
223  }
224  static void PrintString(const char* const text) {
225    void* const font = GLUT_BITMAP_9_BY_15;
226    int i;
227    for (i = 0; text[i]; ++i) {
228      glutBitmapCharacter(font, text[i]);
229    }
230  }
231  static float GetColorf(uint32_t color, int shift) {
232    return ((color &gt;&gt; shift) &amp; 0xff) / 255.f;
233  }
234  static void DrawCheckerBoard(void) {
235    const int square_size = 8;  
236    int x, y;
237    GLint viewport[4];  
238    glPushMatrix();
239    glGetIntegerv(GL_VIEWPORT, viewport);
240    glOrtho(0, viewport[2], viewport[3], 0, -1, 1);
241    for (y = 0; y &lt; viewport[3]; y += square_size) {
242      for (x = 0; x &lt; viewport[2]; x += square_size) {
243        const GLubyte color = 128 + 64 * (!((x + y) &amp; square_size));
244        glColor3ub(color, color, color);
245        glRecti(x, y, x + square_size, y + square_size);
246      }
247    }
248    glPopMatrix();
249  }
250  static void DrawBackground(void) {
251    glClear(GL_COLOR_BUFFER_BIT);
252    DrawCheckerBoard();
253    if (kParams.draw_anim_background_color) {
254      glPushMatrix();
255      glLoadIdentity();
256      glColor4f(GetColorf(kParams.bg_color, 16),  
257                GetColorf(kParams.bg_color, 8),
258                GetColorf(kParams.bg_color, 0),
259                GetColorf(kParams.bg_color, 24));
260      glRecti(-1, -1, +1, +1);
261      glPopMatrix();
262    }
263  }
264  static void DrawBackgroundScissored(int window_x, int window_y, int frame_w,
265                                      int frame_h) {
266    window_x = window_x * kParams.viewport_width / kParams.canvas_width;
267    window_y = window_y * kParams.viewport_height / kParams.canvas_height;
268    frame_w = frame_w * kParams.viewport_width / kParams.canvas_width;
269    frame_h = frame_h * kParams.viewport_height / kParams.canvas_height;
270    window_y = kParams.viewport_height - window_y - frame_h;
271    glEnable(GL_SCISSOR_TEST);
272    glScissor(window_x, window_y, frame_w, frame_h);
273    DrawBackground();
274    glDisable(GL_SCISSOR_TEST);
275  }
276  static void HandleDisplay(void) {
277    const WebPDecBuffer* const pic = kParams.pic;
278    const WebPIterator* const curr = &amp;kParams.curr_frame;
279    WebPIterator* const prev = &amp;kParams.prev_frame;
280    GLfloat xoff, yoff;
281    if (pic == NULL) return;
282    glPushMatrix();
283    glPixelZoom((GLfloat)(+1. / kParams.canvas_width * kParams.viewport_width),
284                (GLfloat)(-1. / kParams.canvas_height * kParams.viewport_height));
285    xoff = (GLfloat)(2. * curr-&gt;x_offset / kParams.canvas_width);
286    yoff = (GLfloat)(2. * curr-&gt;y_offset / kParams.canvas_height);
287    glRasterPos2f(-1.f + xoff, 1.f - yoff);
288    glPixelStorei(GL_UNPACK_ALIGNMENT, 1);
289    glPixelStorei(GL_UNPACK_ROW_LENGTH, pic-&gt;u.RGBA.stride / 4);
290    if (kParams.only_deltas) {
291      DrawBackground();
292    } else {
293      if (prev-&gt;dispose_method == WEBP_MUX_DISPOSE_BACKGROUND) {
294        DrawBackgroundScissored(prev-&gt;x_offset, prev-&gt;y_offset, prev-&gt;width,
295                                prev-&gt;height);
296      }
297      if (curr-&gt;blend_method == WEBP_MUX_NO_BLEND) {
298        DrawBackgroundScissored(curr-&gt;x_offset, curr-&gt;y_offset, curr-&gt;width,
299                                curr-&gt;height);
300      }
301    }
302    *prev = *curr;
303    glDrawPixels(pic-&gt;width, pic-&gt;height,
304                 GL_RGBA, GL_UNSIGNED_BYTE,
305                 (GLvoid*)pic-&gt;u.RGBA.rgba);
306    if (kParams.print_info) {
307      char tmp[32];
308      glColor4f(0.90f, 0.0f, 0.90f, 1.0f);
309      glRasterPos2f(-0.95f, 0.90f);
310      PrintString(kParams.file_name);
311      snprintf(tmp, sizeof(tmp), &quot;Dimension:%d x %d&quot;, pic-&gt;width, pic-&gt;height);
312      glColor4f(0.90f, 0.0f, 0.90f, 1.0f);
313      glRasterPos2f(-0.95f, 0.80f);
314      PrintString(tmp);
315      if (curr-&gt;x_offset != 0 || curr-&gt;y_offset != 0) {
316        snprintf(tmp, sizeof(tmp), &quot; (offset:%d,%d)&quot;,
317                 curr-&gt;x_offset, curr-&gt;y_offset);
318        glRasterPos2f(-0.95f, 0.70f);
319        PrintString(tmp);
320      }
321    }
322    glPopMatrix();
323  #if defined(__APPLE__) || defined(_WIN32)
324    glFlush();
325  #else
326    glutSwapBuffers();
327  #endif
328  }
329  static void StartDisplay(void) {
330    int width = kParams.canvas_width;
331    int height = kParams.canvas_height;
332    int screen_width, screen_height;
333  #if defined(__APPLE__) || defined(_WIN32)
334    glutInitDisplayMode(GLUT_RGBA);
335  #else
336    glutInitDisplayMode(GLUT_DOUBLE | GLUT_RGBA);
337  #endif
338    screen_width = glutGet(GLUT_SCREEN_WIDTH);
339    screen_height = glutGet(GLUT_SCREEN_HEIGHT);
340    if (width &gt; screen_width || height &gt; screen_height) {
341      if (width &gt; screen_width) {
342        height = (height * screen_width + width - 1) / width;
343        width = screen_width;
344      }
345      if (height &gt; screen_height) {
346        width = (width * screen_height + height - 1) / height;
347        height = screen_height;
348      }
349    }
350    glutInitWindowSize(width, height);
351    glutCreateWindow(&quot;WebP viewer&quot;);
352    glutDisplayFunc(HandleDisplay);
353    glutReshapeFunc(HandleReshape);
354    glutIdleFunc(NULL);
355    glutKeyboardFunc(HandleKey);
356    glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
357    glEnable(GL_BLEND);
358    glClearColor(0, 0, 0, 0);  
359    DrawBackground();
360  }
361  static void Help(void) {
362    printf(
363        &quot;Usage: vwebp in_file [options]\n\n&quot;
364        &quot;Decodes the WebP image file and visualize it using OpenGL\n&quot;
365        &quot;Options are:\n&quot;
366        &quot;  -version ..... print version number and exit\n&quot;
367        &quot;  -noicc ....... don&#x27;t use the icc profile if present\n&quot;
368        &quot;  -nofancy ..... don&#x27;t use the fancy YUV420 upscaler\n&quot;
369        &quot;  -nofilter .... disable in-loop filtering\n&quot;
370        &quot;  -dither &lt;int&gt;  dithering strength (0..100), default=50\n&quot;
371        &quot;  -noalphadither disable alpha plane dithering\n&quot;
372        &quot;  -usebgcolor .. display background color\n&quot;
373        &quot;  -mt .......... use multi-threading\n&quot;
374        &quot;  -info ........ print info\n&quot;
375        &quot;  -h ........... this help message\n&quot;
376        &quot;\n&quot;
377        &quot;Keyboard shortcuts:\n&quot;
378        &quot;  &#x27;c&#x27; ................ toggle use of color profile\n&quot;
379        &quot;  &#x27;b&#x27; ................ toggle background color display\n&quot;
380        &quot;  &#x27;i&#x27; ................ overlay file information\n&quot;
381        &quot;  &#x27;d&#x27; ................ disable blending &amp; disposal (debug)\n&quot;
382        &quot;  &#x27;q&#x27; / &#x27;Q&#x27; / ESC .... quit\n&quot;);
383  }
384  int main(int argc, char* argv[]) {
385    int c;
386    WebPDecoderConfig* const config = &amp;kParams.config;
387    WebPIterator* const curr = &amp;kParams.curr_frame;
388    INIT_WARGV(argc, argv);
389    if (!WebPInitDecoderConfig(config)) {
390      fprintf(stderr, &quot;Library version mismatch!\n&quot;);
391      FREE_WARGV_AND_RETURN(-1);
392    }
393    config-&gt;options.dithering_strength = 50;
394    config-&gt;options.alpha_dithering_strength = 100;
395    kParams.use_color_profile = 1;
396    kParams.draw_anim_background_color = 0;
397    for (c = 1; c &lt; argc; ++c) {
398      int parse_error = 0;
399      if (!strcmp(argv[c], &quot;-h&quot;) || !strcmp(argv[c], &quot;-help&quot;)) {
400        Help();
401        FREE_WARGV_AND_RETURN(0);
402      } else if (!strcmp(argv[c], &quot;-noicc&quot;)) {
403        kParams.use_color_profile = 0;
404      } else if (!strcmp(argv[c], &quot;-nofancy&quot;)) {
405        config-&gt;options.no_fancy_upsampling = 1;
406      } else if (!strcmp(argv[c], &quot;-nofilter&quot;)) {
407        config-&gt;options.bypass_filtering = 1;
408      } else if (!strcmp(argv[c], &quot;-noalphadither&quot;)) {
409        config-&gt;options.alpha_dithering_strength = 0;
410      } else if (!strcmp(argv[c], &quot;-usebgcolor&quot;)) {
411        kParams.draw_anim_background_color = 1;
412      } else if (!strcmp(argv[c], &quot;-dither&quot;) &amp;&amp; c + 1 &lt; argc) {
413        config-&gt;options.dithering_strength =
414            ExUtilGetInt(argv[++c], 0, &amp;parse_error);
415      } else if (!strcmp(argv[c], &quot;-info&quot;)) {
416        kParams.print_info = 1;
417      } else if (!strcmp(argv[c], &quot;-version&quot;)) {
418        const int dec_version = WebPGetDecoderVersion();
419        const int dmux_version = WebPGetDemuxVersion();
420        printf(&quot;WebP Decoder version: %d.%d.%d\nWebP Demux version: %d.%d.%d\n&quot;,
421               (dec_version &gt;&gt; 16) &amp; 0xff, (dec_version &gt;&gt; 8) &amp; 0xff,
422               dec_version &amp; 0xff, (dmux_version &gt;&gt; 16) &amp; 0xff,
423               (dmux_version &gt;&gt; 8) &amp; 0xff, dmux_version &amp; 0xff);
424        FREE_WARGV_AND_RETURN(0);
425      } else if (!strcmp(argv[c], &quot;-mt&quot;)) {
426        config-&gt;options.use_threads = 1;
427      } else if (!strcmp(argv[c], &quot;--&quot;)) {
428        if (c &lt; argc - 1) kParams.file_name = (const char*)GET_WARGV(argv, ++c);
429        break;
430      } else if (argv[c][0] == &#x27;-&#x27;) {
431        printf(&quot;Unknown option &#x27;%s&#x27;\n&quot;, argv[c]);
432        Help();
433        FREE_WARGV_AND_RETURN(-1);
434      } else {
435        kParams.file_name = (const char*)GET_WARGV(argv, c);
436      }
437      if (parse_error) {
438        Help();
439        FREE_WARGV_AND_RETURN(-1);
440      }
441    }
442    if (kParams.file_name == NULL) {
443      printf(&quot;missing input file!!\n&quot;);
444      Help();
445      FREE_WARGV_AND_RETURN(0);
446    }
447    if (!ImgIoUtilReadFile(kParams.file_name,
448                           &amp;kParams.data.bytes, &amp;kParams.data.size)) {
449      goto Error;
450    }
451    if (!WebPGetInfo(kParams.data.bytes, kParams.data.size, NULL, NULL)) {
452      fprintf(stderr, &quot;Input file doesn&#x27;t appear to be WebP format.\n&quot;);
453      goto Error;
454    }
455    kParams.dmux = WebPDemux(&amp;kParams.data);
456    if (kParams.dmux == NULL) {
457      fprintf(stderr, &quot;Could not create demuxing object!\n&quot;);
458      goto Error;
459    }
460    kParams.canvas_width = WebPDemuxGetI(kParams.dmux, WEBP_FF_CANVAS_WIDTH);
461    kParams.canvas_height = WebPDemuxGetI(kParams.dmux, WEBP_FF_CANVAS_HEIGHT);
462    if (kParams.print_info) {
463      printf(&quot;Canvas: %d x %d\n&quot;, kParams.canvas_width, kParams.canvas_height);
464    }
465    ClearPreviousFrame();
466    memset(&amp;kParams.iccp, 0, sizeof(kParams.iccp));
467    kParams.has_color_profile =
468        !!(WebPDemuxGetI(kParams.dmux, WEBP_FF_FORMAT_FLAGS) &amp; ICCP_FLAG);
469    if (kParams.has_color_profile) {
470  #ifdef WEBP_HAVE_QCMS
471      if (!WebPDemuxGetChunk(kParams.dmux, &quot;ICCP&quot;, 1, &amp;kParams.iccp)) goto Error;
472      printf(&quot;VP8X: Found color profile\n&quot;);
473  #else
474      fprintf(stderr, &quot;Warning: color profile present, but qcms is unavailable!\n&quot;
475              &quot;Build libqcms from Mozilla or Chromium and define WEBP_HAVE_QCMS &quot;
476              &quot;before building.\n&quot;);
477  #endif
478    }
479    if (!WebPDemuxGetFrame(kParams.dmux, 1, curr)) goto Error;
480    kParams.has_animation = (curr-&gt;num_frames &gt; 1);
481    kParams.loop_count = (int)WebPDemuxGetI(kParams.dmux, WEBP_FF_LOOP_COUNT);
482    kParams.bg_color = WebPDemuxGetI(kParams.dmux, WEBP_FF_BACKGROUND_COLOR);
483    printf(&quot;VP8X: Found %d images in file (loop count = %d)\n&quot;,
484           curr-&gt;num_frames, kParams.loop_count);
485    if (!Decode()) goto Error;
486    WebPDemuxGetFrame(kParams.dmux, 0, curr);
487    if (kParams.loop_count) ++kParams.loop_count;
488  #if defined(__unix__) || defined(__CYGWIN__)
489    setenv(&quot;XLIB_SKIP_ARGB_VISUALS&quot;, &quot;1&quot;, 1);
490  #endif
491    glutInit(&amp;argc, argv);
492  #ifdef FREEGLUT
493    glutSetOption(GLUT_ACTION_ON_WINDOW_CLOSE, GLUT_ACTION_CONTINUE_EXECUTION);
494  #endif
495    StartDisplay();
496    if (kParams.has_animation) glutTimerFunc(0, decode_callback, 0);
497    glutMainLoop();
498    ClearParams();
499    FREE_WARGV_AND_RETURN(0);
500   Error:
501    ClearParams();
502    FREE_WARGV_AND_RETURN(-1);
503  }
504  #else   
505  int main(int argc, const char* argv[]) {
506    fprintf(stderr, &quot;OpenGL support not enabled in %s.\n&quot;, argv[0]);
507    (void)argc;
508    return 0;
509  }
510  #endif
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from PINRemoteImage-MDEwOlJlcG9zaXRvcnkzOTUzNzEwMw==-flat-vwebp.c</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from PINRemoteImage-MDEwOlJlcG9zaXRvcnkzOTUzNzEwMw==-flat-vwebp.c</div>
                </div>
                <div class="column column_space"><pre><code>58    WebPDataClear(&amp;kParams.data);
59    WebPDemuxReleaseIterator(&amp;kParams.curr_frame);
60    WebPDemuxReleaseIterator(&amp;kParams.prev_frame);
</pre></code></div>
                <div class="column column_space"><pre><code>60    WebPDemuxReleaseIterator(&amp;kParams.prev_frame);
61    WebPDemuxReleaseChunkIterator(&amp;kParams.iccp);
62    WebPDemuxDelete(kParams.dmux);
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    