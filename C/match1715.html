<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for inf-text-gtk-view.c &amp; inf-tcp-connection.c</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for inf-text-gtk-view.c &amp; inf-tcp-connection.c
      </h3>
<h1 align="center">
        6.3%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>inf-text-gtk-view.c (6.3492064%)<th>inf-tcp-connection.c (6.3414636%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(1575-1647)<td><a href="#" name="0">(858-901)</a><td align="center"><font color="#ff0000">23</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(1760-1783)<td><a href="#" name="1">(1069-1092)</a><td align="center"><font color="#bc0000">17</font>
<tr onclick='openModal("#980517")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#980517"><font color="#980517">-</font><td><a href="#" name="2">(1314-1330)<td><a href="#" name="2">(1190-1204)</a><td align="center"><font color="#850000">12</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>inf-text-gtk-view.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 #include &lt;libinftextgtk/inf-text-gtk-view.h&gt;
2 #include &lt;libinfinity/inf-signals.h&gt;
3 #include &lt;gdk/gdk.h&gt;
4 typedef struct _InfTextGtkViewUser InfTextGtkViewUser;
5 struct _InfTextGtkViewUser {
6   InfTextGtkView* view;
7   InfTextUser* user;
8   gboolean cursor_visible;
9   InfIoTimeout* timeout;   guint revalidate_idle;
10   GdkRectangle cursor_rect;
11   GdkRectangle selection_bound_rect;
12   gint line_y;
13   gint line_height;
14 };
15 typedef struct _InfTextGtkViewUserToggle InfTextGtkViewUserToggle;
16 struct _InfTextGtkViewUserToggle {
17   InfTextGtkViewUser* user;
18   guint pos;
19   InfTextGtkViewUserToggle* on_toggle;
20   gint x;
21   gint y;
22 };
23 typedef struct _InfTextGtkViewPrivate InfTextGtkViewPrivate;
24 struct _InfTextGtkViewPrivate {
25   InfIo* io;
26   GtkTextView* textview;
27   InfUserTable* user_table;
28   InfTextUser* active_user;
29   GSList* users;
30   gboolean show_remote_cursors;
31   gboolean show_remote_selections;
32   gboolean show_remote_current_lines;
33 };
34 enum {
35   PROP_0,
36   PROP_IO,
37   PROP_VIEW,
38   PROP_USER_TABLE,
39   PROP_ACTIVE_USER,
40   PROP_SHOW_REMOTE_CURSORS,
41   PROP_SHOW_REMOTE_SELECTIONS,
42   PROP_SHOW_REMOTE_CURRENT_LINES
43 };
44 #define INF_TEXT_GTK_VIEW_PRIVATE(obj) (G_TYPE_INSTANCE_GET_PRIVATE((obj), INF_TEXT_GTK_TYPE_VIEW, InfTextGtkViewPrivate))
45 G_DEFINE_TYPE_WITH_CODE(InfTextGtkView, inf_text_gtk_view, G_TYPE_OBJECT,
46   G_ADD_PRIVATE(InfTextGtkView))
47 static InfTextGtkViewUser*
48 inf_text_gtk_view_find_user(InfTextGtkView* view,
49                             InfTextUser* user)
50 {
51   InfTextGtkViewPrivate* priv;
52   GSList* item;
53   priv = INF_TEXT_GTK_VIEW_PRIVATE(view);
54   for(item = priv-&gt;users; item != NULL; item = item-&gt;next)
55     if( ((InfTextGtkViewUser*)item-&gt;data)-&gt;user == user)
56       return (InfTextGtkViewUser*)item-&gt;data;
57   return NULL;
58 }
59 static void
60 inf_text_gtk_view_user_compute_user_area(InfTextGtkViewUser* view_user)
61 {
62   InfTextGtkViewPrivate* priv;
63   GtkTextIter iter;
64   gfloat cursor_aspect_ratio;
65   priv = INF_TEXT_GTK_VIEW_PRIVATE(view_user-&gt;view);
66   gtk_widget_style_get(
67     GTK_WIDGET(priv-&gt;textview),
68     "cursor-aspect-ratio", &amp;cursor_aspect_ratio,
69     NULL
70   );
71   gtk_text_buffer_get_iter_at_offset(
72     gtk_text_view_get_buffer(priv-&gt;textview),
73     &amp;iter,
74     inf_text_user_get_caret_position(view_user-&gt;user)
75   );
76   gtk_text_view_get_line_yrange(
77     priv-&gt;textview,
78     &amp;iter,
79     &amp;view_user-&gt;line_y,
80     &amp;view_user-&gt;line_height
81   );
82   gtk_text_view_get_iter_location(
83     priv-&gt;textview,
84     &amp;iter,
85     &amp;view_user-&gt;cursor_rect
86   );
87   view_user-&gt;cursor_rect.width = MAX(
88     (int)(view_user-&gt;cursor_rect.height * cursor_aspect_ratio),
89     1
90   );
91   gtk_text_iter_forward_chars(
92     &amp;iter,
93     inf_text_user_get_selection_length(view_user-&gt;user)
94   );
95   gtk_text_view_get_iter_location(
96     priv-&gt;textview,
97     &amp;iter,
98     &amp;view_user-&gt;selection_bound_rect
99   );
100   view_user-&gt;selection_bound_rect.width = MAX(
101     (int)(view_user-&gt;selection_bound_rect.height * cursor_aspect_ratio),
102     1
103   );
104 }
105 static guint
106 inf_text_gtk_view_get_left_margin(GtkTextView* view)
107 {
108   GtkAdjustment* hadjustment;
109   gint margin;
110   gint hadj;
111   hadjustment = gtk_scrollable_get_hadjustment(GTK_SCROLLABLE(view));
112   margin = gtk_text_view_get_left_margin(view);
113   if(!hadjustment) return margin;
114   hadj = gtk_adjustment_get_value(hadjustment);
115   if(hadj &lt; margin) return margin - hadj;
116   return 0;
117 }
118 static guint
119 inf_text_gtk_view_get_right_margin(GtkTextView* view)
120 {
121   GtkAdjustment* hadjustment;
122   gint margin;
123   gdouble hadj;
124   gdouble hupper;
125   gdouble hpage;
126   hadjustment = gtk_scrollable_get_hadjustment(GTK_SCROLLABLE(view));
127   margin = gtk_text_view_get_right_margin(view);
128   if(!hadjustment) return margin;
129   hadj = gtk_adjustment_get_value(hadjustment) + 1;
130   g_object_get(
131     G_OBJECT(hadjustment),
132     "upper", &amp;hupper,
133     "page-size", &amp;hpage,
134     NULL
135   );
136   if(hadj &gt; hupper - hpage - margin)
137     return margin - (gint)(hupper - hpage - hadj);
138   return 0;
139 }
140 static void
141 inf_text_gtk_view_user_invalidate_user_area(InfTextGtkViewUser* view_user)
142 {
143   InfTextGtkViewPrivate* priv;
144   GdkWindow* window;
145   GdkRectangle invalidate_rect;
146   gint selection_bound_x;
147   gint selection_bound_y;
148   gint window_width;
149   priv = INF_TEXT_GTK_VIEW_PRIVATE(view_user-&gt;view);
150   if(gtk_widget_get_realized(GTK_WIDGET(priv-&gt;textview)))
151   {
152     if(priv-&gt;show_remote_cursors || priv-&gt;show_remote_selections ||
153        priv-&gt;show_remote_current_lines)
154     {
155       window = gtk_text_view_get_window(priv-&gt;textview, GTK_TEXT_WINDOW_TEXT);
156       window_width = gdk_window_get_width(window);
157       gtk_text_view_buffer_to_window_coords(
158         priv-&gt;textview,
159         GTK_TEXT_WINDOW_TEXT,
160         view_user-&gt;cursor_rect.x, view_user-&gt;cursor_rect.y,
161         &amp;invalidate_rect.x, &amp;invalidate_rect.y
162       );
163       invalidate_rect.width = view_user-&gt;cursor_rect.width;
164       invalidate_rect.height = view_user-&gt;cursor_rect.height;
165       if(priv-&gt;show_remote_selections &amp;&amp;
166          (view_user-&gt;selection_bound_rect.x != view_user-&gt;cursor_rect.x ||
167           view_user-&gt;selection_bound_rect.y != view_user-&gt;cursor_rect.y))
168       {
169         gtk_text_view_buffer_to_window_coords(
170           priv-&gt;textview,
171           GTK_TEXT_WINDOW_TEXT,
172           view_user-&gt;selection_bound_rect.x,
173           view_user-&gt;selection_bound_rect.y,
174           &amp;selection_bound_x, &amp;selection_bound_y
175         );
176         if(selection_bound_y == invalidate_rect.y)
177         {
178           if(selection_bound_x &gt; invalidate_rect.x)
179           {
180             invalidate_rect.width = MAX(
181               selection_bound_x - invalidate_rect.x,
182               invalidate_rect.width
183             );
184           }
185           else
186           {
187             invalidate_rect.width += (invalidate_rect.x - selection_bound_x);
188             invalidate_rect.x = selection_bound_x;
189           }
190         }
191         else
192         {
193           invalidate_rect.width = window_width;
194           invalidate_rect.height = MAX(
195             invalidate_rect.y + invalidate_rect.height,
196             selection_bound_y + view_user-&gt;selection_bound_rect.height
197           ) - MIN(invalidate_rect.y, selection_bound_y);
198           invalidate_rect.x =
199             inf_text_gtk_view_get_left_margin(priv-&gt;textview);
200           invalidate_rect.y = MIN(invalidate_rect.y, selection_bound_y);
201           invalidate_rect.width -=
202             inf_text_gtk_view_get_left_margin(priv-&gt;textview) +
203             inf_text_gtk_view_get_right_margin(priv-&gt;textview);
204         }
205         gdk_window_invalidate_rect(window, &amp;invalidate_rect, FALSE);
206       }
207       if(priv-&gt;show_remote_current_lines)
208       {
209         gtk_text_view_buffer_to_window_coords(
210           priv-&gt;textview,
211           GTK_TEXT_WINDOW_TEXT,
212           0, view_user-&gt;line_y,
213           NULL, &amp;invalidate_rect.y
214         );
215         invalidate_rect.x =
216           inf_text_gtk_view_get_left_margin(priv-&gt;textview) - 1;
217         invalidate_rect.width = window_width - invalidate_rect.x;
218         invalidate_rect.height = view_user-&gt;line_height;
219       }
220       gdk_window_invalidate_rect(window, &amp;invalidate_rect, FALSE);
221     }
222   }
223 }
224 static gint
225 inf_text_gtk_view_user_line_position_cmp(gconstpointer first,
226                                          gconstpointer second)
227 {
228   const InfTextGtkViewUser* first_user;
229   const InfTextGtkViewUser* second_user;
230   first_user = (const InfTextGtkViewUser*)first;
231   second_user = (const InfTextGtkViewUser*)second;
232   if(second_user-&gt;line_y &lt; first_user-&gt;line_y)
233     return 1;
234   else if(second_user-&gt;line_y &gt; first_user-&gt;line_y)
235     return -1;
236   return 0;
237 }
238 static gint
239 inf_text_gtk_view_user_toggle_position_cmp(gconstpointer first,
240                                            gconstpointer second,
241                                            gpointer user_data)
242 {
243   const InfTextGtkViewUserToggle* first_toggle;
244   const InfTextGtkViewUserToggle* second_toggle;
245   first_toggle = (const InfTextGtkViewUserToggle*)first;
246   second_toggle = (const InfTextGtkViewUserToggle*)second;
247   if(second_toggle-&gt;pos &lt; first_toggle-&gt;pos)
248     return 1;
249   else if(second_toggle-&gt;pos &gt; first_toggle-&gt;pos)
250     return -1;
251   return 0;
252 }
253 static gint
254 inf_text_gtk_view_user_toggle_user_cmp(gconstpointer first,
255                                        gconstpointer second)
256 {
257   const InfTextGtkViewUserToggle* first_toggle;
258   const InfTextGtkViewUserToggle* second_toggle;
259   guint first_id;
260   guint second_id;
261   first_toggle = (const InfTextGtkViewUserToggle*)first;
262   second_toggle = (const InfTextGtkViewUserToggle*)second;
263   first_id = inf_user_get_id(INF_USER(first_toggle-&gt;user-&gt;user));
264   second_id = inf_user_get_id(INF_USER(second_toggle-&gt;user-&gt;user));
265   if(second_id &lt; first_id)
266     return 1;
267   else if(second_id &gt; first_id)
268     return -1;
269   return 0;
270 }
271 static void
272 inf_text_gtk_view_user_toggle_free(gpointer data)
273 {
274   g_slice_free(InfTextGtkViewUserToggle, data);
275 }
276 static InfTextGtkViewUserToggle*
277 inf_text_gtk_view_add_user_toggle(GSequence* sequence,
278                                   guint position,
279                                   InfTextGtkViewUser* user,
280                                   InfTextGtkViewUserToggle* on_toggle,
281                                   gint x,
282                                   gint y)
283 {
284   InfTextGtkViewUserToggle* toggle;
285   toggle = g_slice_new(InfTextGtkViewUserToggle);
286   toggle-&gt;user = user;
287   toggle-&gt;pos = position;
288   toggle-&gt;on_toggle = on_toggle;
289   toggle-&gt;x = x;
290   toggle-&gt;y = y;
291   g_sequence_insert_sorted(
292     sequence,
293     toggle,
294     inf_text_gtk_view_user_toggle_position_cmp,
295     NULL
296   );
297   return toggle;
298 }
299 static void
300 inf_text_gtk_view_add_user_toggle_pair(GSequence* sequence,
301                                        guint begin,
302                                        guint end,
303                                        InfTextGtkViewUser* user,
304                                        gint begin_x,
305                                        gint begin_y,
306                                        gint end_x,
307                                        gint end_y)
308 {
309   InfTextGtkViewUserToggle* begin_toggle;
310   g_assert(end &gt; begin);
311   begin_toggle = inf_text_gtk_view_add_user_toggle(
312     sequence,
313     begin,
314     user,
315     NULL,
316     begin_x,
317     begin_y
318   );
319   inf_text_gtk_view_add_user_toggle(
320     sequence,
321     end,
322     user,
323     begin_toggle,
324     end_x,
325     end_y
326   );
327 }
328 static gboolean
329 inf_text_gtk_view_draw_before_cb(GtkWidget* widget,
330                                  cairo_t* cr,
331                                  gpointer user_data)
332 {
333   InfTextGtkView* view;
334   InfTextGtkViewPrivate* priv;
335   GSList* item;
336   GSList* prev_item;
337   InfTextGtkViewUser* prev_user;
338   InfTextGtkViewUser* view_user;
339   GtkAdjustment* hadjustment;
340   GtkAdjustment* vadjustment;
341   GdkWindow *text_window;
342   GtkStyleContext* style;
343   GdkRGBA bg;
344   double h, s, v;
345   double r, g, b;
346   GSList* sort_users;
347   GdkRectangle rect;
348   gint window_width;
349   gint rx, ry;
350   GdkRectangle clip_area;
351   cairo_pattern_t* pattern;
352   double n, n_users;
353   cairo_matrix_t matrix;
354   view = INF_TEXT_GTK_VIEW(user_data);
355   priv = INF_TEXT_GTK_VIEW_PRIVATE(view);
356   text_window = gtk_text_view_get_window(priv-&gt;textview, GTK_TEXT_WINDOW_TEXT);
357   if(!gtk_cairo_should_draw_window(cr, text_window))
358   {
359     return FALSE;
360   }
361   if(priv-&gt;show_remote_current_lines)
362   {
363     gtk_cairo_transform_to_window(cr, GTK_WIDGET(priv-&gt;textview), text_window);
364     gdk_cairo_get_clip_rectangle(cr, &amp;clip_area);
365     window_width = gdk_window_get_width(text_window);
366     style = gtk_widget_get_style_context(GTK_WIDGET(priv-&gt;textview));
367     gtk_style_context_save(style);
368     gtk_style_context_add_class(style, GTK_STYLE_CLASS_VIEW);
369     gtk_style_context_get_background_color(style, GTK_STATE_FLAG_NORMAL, &amp;bg);
370     gtk_style_context_restore(style);
371     gtk_rgb_to_hsv(bg.red, bg.green, bg.blue, &amp;h, &amp;s, &amp;v);
372     v = MAX(v, 0.3);
373     s = MAX(s, 0.1 + 0.3*(1 - v));
374     sort_users = g_slist_copy(priv-&gt;users);
375     sort_users =
376       g_slist_sort(sort_users, inf_text_gtk_view_user_line_position_cmp);
377     prev_item = sort_users;
378     if(prev_item) prev_user = (InfTextGtkViewUser*)prev_item-&gt;data;
379     n_users = 1.0;
380     for(item = sort_users; item != NULL; item = item-&gt;next, n_users += 1.0)
381     {
382       if(item-&gt;next == NULL ||
383          ((InfTextGtkViewUser*)item-&gt;next-&gt;data)-&gt;line_y != prev_user-&gt;line_y)
384       {
385         gtk_text_view_buffer_to_window_coords(
386           priv-&gt;textview,
387           GTK_TEXT_WINDOW_TEXT,
388           0, prev_user-&gt;line_y,
389           NULL, &amp;rect.y
390         );
391         rect.x = inf_text_gtk_view_get_left_margin(priv-&gt;textview) - 1;
392         rect.width = window_width - rect.x;
393         rect.height = prev_user-&gt;line_height;
394         if(gdk_rectangle_intersect(&amp;clip_area, &amp;rect, NULL))
395         {
396           hadjustment =
397             gtk_scrollable_get_hadjustment(GTK_SCROLLABLE(priv-&gt;textview));
398           vadjustment =
399             gtk_scrollable_get_vadjustment(GTK_SCROLLABLE(priv-&gt;textview));
400           rx = gtk_adjustment_get_value(vadjustment);
401           ry = gtk_adjustment_get_value(hadjustment);
402           pattern =
403             cairo_pattern_create_linear(0, 0, 3.5*n_users, 3.5*n_users);
404           cairo_matrix_init_translate(&amp;matrix, rx, ry);
405           cairo_pattern_set_matrix(pattern, &amp;matrix);
406           cairo_pattern_set_extend(pattern, CAIRO_EXTEND_REPEAT);
407           for(n = 0.0;
408               prev_item != item-&gt;next;
409               prev_item = prev_item-&gt;next, n += 1.0)
410           {
411             view_user = (InfTextGtkViewUser*)prev_item-&gt;data;
412             h = inf_text_user_get_hue(view_user-&gt;user);
413             gtk_hsv_to_rgb(h, s, v, &amp;r, &amp;g, &amp;b);
414             cairo_pattern_add_color_stop_rgb(
415               pattern,
416               n/n_users,
417               r, g, b
418             );
419             cairo_pattern_add_color_stop_rgb(
420               pattern,
421               (n+1.0)/n_users,
422               r, g, b
423             );
424           }
425           cairo_set_source(cr, pattern);
426           gdk_cairo_rectangle(cr, &amp;rect);
427           cairo_fill(cr);
428           cairo_pattern_destroy(pattern);
429         }
430         prev_item = item-&gt;next;
431         if(prev_item) prev_user = (InfTextGtkViewUser*)prev_item-&gt;data;
432         n_users = 0.0;
433       }
434     }
435     g_slist_free(sort_users);
436   }
437   return FALSE;
438 }
439 static gboolean
440 inf_text_gtk_view_draw_after_cb(GtkWidget* widget,
441                                 cairo_t* cr,
442                                 gpointer user_data)
443 {
444   InfTextGtkView* view;
445   InfTextGtkViewPrivate* priv;
446   gint window_width;
447   GtkStyleContext* style;
448   GdkColor* cursor_color;
449   GdkRGBA fg;
450   double hc,sc,vc;
451   double hs,ss,vs;
452   GSList* item;
453   InfTextGtkViewUser* view_user;
454   double rc,gc,bc;
455   double rs,gs,bs;
456   GdkRectangle clip_area;
457   gint ax, ay;
458   GtkTextIter begin_iter;
459   GtkTextIter end_iter;
460   guint area_begin;
461   guint area_end;
462   guint own_sel_begin;
463   guint own_sel_end;
464   gint osbx, osby;
465   gint osex, osey;
466   gint sel;
467   guint begin;
468   guint end;
469   GSequence* toggles;
470   GSequenceIter* tog_iter;
471   InfTextGtkViewUserToggle* cur_toggle;
472   InfTextGtkViewUserToggle* prev_toggle;
473   guint n_users;
474   GSList* users;
475   cairo_pattern_t* pattern;
476   GtkAdjustment* hadjustment;
477   GtkAdjustment* vadjustment;
478   double n;
479   cairo_matrix_t matrix;
480   GdkRectangle rct;
481   gint rx, ry;
482   GdkWindow *text_window;
483   view = INF_TEXT_GTK_VIEW(user_data);
484   priv = INF_TEXT_GTK_VIEW_PRIVATE(view);
485   text_window = gtk_text_view_get_window(priv-&gt;textview, GTK_TEXT_WINDOW_TEXT);
486   if(!gtk_cairo_should_draw_window(cr, text_window))
487   {
488     return FALSE;
489   }
490   gtk_cairo_transform_to_window(cr, GTK_WIDGET(priv-&gt;textview), text_window);
491   gdk_cairo_get_clip_rectangle(cr, &amp;clip_area);
492   style = gtk_widget_get_style_context(GTK_WIDGET(priv-&gt;textview));
493   gtk_style_context_save(style);
494   gtk_style_context_add_class(style, GTK_STYLE_CLASS_VIEW);
495   gtk_style_context_get_color(style, GTK_STATE_FLAG_NORMAL, &amp;fg);
496   gtk_style_context_restore(style);
497   if(priv-&gt;show_remote_selections)
498   {
499     window_width = gdk_window_get_width(text_window);
500     gtk_rgb_to_hsv(fg.red, fg.green, fg.blue, &amp;hs, &amp;ss, &amp;vs);
501     vs = MAX(vs, 0.5);
502     ss = 1.0 - 0.4*(vs);
503     gtk_text_view_window_to_buffer_coords(
504       priv-&gt;textview,
505       GTK_TEXT_WINDOW_TEXT,
506       clip_area.x, clip_area.y,
507       &amp;ax, &amp;ay
508     );
509     gtk_text_view_get_iter_at_location(
510       priv-&gt;textview,
511       &amp;begin_iter,
512       ax,
513       ay
514     );
515     gtk_text_view_get_iter_at_location(
516       priv-&gt;textview,
517       &amp;end_iter,
518       ax + clip_area.width,
519       ay + clip_area.height
520     );
521     area_begin = gtk_text_iter_get_offset(&amp;begin_iter);
522     area_end = gtk_text_iter_get_offset(&amp;end_iter);
523     g_assert(area_end &gt;= area_begin);
524     gtk_text_buffer_get_selection_bounds(
525       gtk_text_view_get_buffer(priv-&gt;textview),
526       &amp;begin_iter,
527       &amp;end_iter
528     );
529     own_sel_begin = gtk_text_iter_get_offset(&amp;begin_iter);
530     own_sel_end = gtk_text_iter_get_offset(&amp;end_iter);
531     if(own_sel_begin != own_sel_end)
532     {
533       gtk_text_view_get_iter_location(priv-&gt;textview, &amp;begin_iter, &amp;rct);
534       gtk_text_view_buffer_to_window_coords(
535         priv-&gt;textview,
536         GTK_TEXT_WINDOW_TEXT,
537         rct.x, rct.y,
538         &amp;osbx, &amp;osby
539       );
540       gtk_text_view_get_iter_location(priv-&gt;textview, &amp;end_iter, &amp;rct);
541       gtk_text_view_buffer_to_window_coords(
542         priv-&gt;textview,
543         GTK_TEXT_WINDOW_TEXT,
544         rct.x, rct.y,
545         &amp;osex, &amp;osey
546       );
547     }
548     toggles = g_sequence_new(inf_text_gtk_view_user_toggle_free);
549     for(item = priv-&gt;users; item != NULL; item = item-&gt;next)
550     {
551       view_user = (InfTextGtkViewUser*)item-&gt;data;
552       if(inf_text_user_get_selection_length(view_user-&gt;user) != 0)
553       {
554         begin = inf_text_user_get_caret_position(view_user-&gt;user);
555         sel = inf_text_user_get_selection_length(view_user-&gt;user);
556         if(sel &gt; 0)
557         {
558           end = begin + sel;
559         }
560         else
561         {
562           g_assert(begin &gt;= (unsigned int)-sel);
563           end = begin;
564           begin += sel;
565         }
566         if(begin &gt; gtk_text_buffer_get_char_count(gtk_text_view_get_buffer(priv-&gt;textview)))
567           begin = gtk_text_buffer_get_char_count(gtk_text_view_get_buffer(priv-&gt;textview));
568         if(end &gt; gtk_text_buffer_get_char_count(gtk_text_view_get_buffer(priv-&gt;textview)))
569           end = gtk_text_buffer_get_char_count(gtk_text_view_get_buffer(priv-&gt;textview));
570         begin = MIN(MAX(begin, area_begin), area_end);
571         end = MIN(MAX(end, area_begin), area_end);
572         g_assert(end &gt;= begin);
573         if(begin != end)
574         {
575           if(sel &gt; 0)
576           {
577             gtk_text_view_buffer_to_window_coords(
578               priv-&gt;textview,
579               GTK_TEXT_WINDOW_TEXT,
580               view_user-&gt;cursor_rect.x,
581               view_user-&gt;cursor_rect.y,
582               &amp;rx, &amp;ry
583             );
584             gtk_text_view_buffer_to_window_coords(
585               priv-&gt;textview,
586               GTK_TEXT_WINDOW_TEXT,
587               view_user-&gt;selection_bound_rect.x,
588               view_user-&gt;selection_bound_rect.y,
589               &amp;ax, &amp;ay
590             );
591           }
592           else
593           {
594             gtk_text_view_buffer_to_window_coords(
595               priv-&gt;textview,
596               GTK_TEXT_WINDOW_TEXT,
597               view_user-&gt;selection_bound_rect.x,
598               view_user-&gt;selection_bound_rect.y,
599               &amp;rx, &amp;ry
600             );
601             gtk_text_view_buffer_to_window_coords(
602               priv-&gt;textview,
603               GTK_TEXT_WINDOW_TEXT,
604               view_user-&gt;cursor_rect.x,
605               view_user-&gt;cursor_rect.y,
606               &amp;ax, &amp;ay
607             );
608           }
609           if(own_sel_begin == own_sel_end ||
610              own_sel_end &lt;= begin || own_sel_begin &gt;= end)
611           {
612             inf_text_gtk_view_add_user_toggle_pair(
613               toggles,
614               begin, end,
615               view_user,
616               rx, ry,
617               ax, ay
618             );
619           }
620           else if(own_sel_begin &lt;= begin &amp;&amp; own_sel_end &gt;= end)
621           {
622           }
623           else if(own_sel_begin &gt; begin &amp;&amp; own_sel_end &gt;= end)
624           {
625             inf_text_gtk_view_add_user_toggle_pair(
626               toggles,
627               begin, own_sel_begin,
628               view_user,
629               rx, ry,
630               osbx, osby
631             );
632           }
633           else if(own_sel_begin &lt;= begin &amp;&amp; own_sel_end &lt; end)
634           {
635             inf_text_gtk_view_add_user_toggle_pair(
636               toggles,
637               own_sel_end, end,
638               view_user,
639               osex, osey,
640               ax, ay
641             );
642           }
643           else if(own_sel_begin &gt; begin &amp;&amp; own_sel_end &lt; end)
644           {
645             inf_text_gtk_view_add_user_toggle_pair(
646               toggles,
647               begin, own_sel_begin,
648               view_user,
649               rx, ry,
650               osbx, osby
651             );
652             inf_text_gtk_view_add_user_toggle_pair(
653               toggles,
654               own_sel_end, end,
655               view_user,
656               osex, osey,
657               ax, ay
658             );
659           }
660           else
661           {
662             g_assert_not_reached();
663           }
664         }
665       }
666     }
667     tog_iter = g_sequence_get_begin_iter(toggles);
668     cur_toggle = NULL;
669     prev_toggle = NULL;
670     users = NULL;
671     n_users = 0;
672     tog_iter = g_sequence_get_begin_iter(toggles);
673     while(!g_sequence_iter_is_end(tog_iter))
674     {
675       cur_toggle = (InfTextGtkViewUserToggle*)g_sequence_get(tog_iter);
676       if(users != NULL)
677       {
678         g_assert(prev_toggle != NULL);
679         g_assert(n_users &gt; 0);
680         hadjustment =
681           gtk_scrollable_get_hadjustment(GTK_SCROLLABLE(priv-&gt;textview));
682         vadjustment =
683           gtk_scrollable_get_vadjustment(GTK_SCROLLABLE(priv-&gt;textview));
684         rx = gtk_adjustment_get_value(hadjustment);
685         ry = gtk_adjustment_get_value(vadjustment);
686         pattern =
687           cairo_pattern_create_linear(0, 0, 3.5*n_users, 3.5*n_users);
688         cairo_matrix_init_translate(&amp;matrix, rx, ry);
689         cairo_pattern_set_matrix(pattern, &amp;matrix);
690         cairo_pattern_set_extend(pattern, CAIRO_EXTEND_REPEAT);
691         for(item = users, n = 0.0; item != NULL; item = item-&gt;next, n += 1.0)
692         {
693           view_user = ((InfTextGtkViewUserToggle*)item-&gt;data)-&gt;user;
694           hs = inf_text_user_get_hue(view_user-&gt;user);
695           gtk_hsv_to_rgb(hs, ss, vs, &amp;rs, &amp;gs, &amp;bs);
696           cairo_pattern_add_color_stop_rgba(
697             pattern,
698             n/n_users,
699             rs, gs, bs, 0.5
700           );
701           cairo_pattern_add_color_stop_rgba(
702             pattern,
703             (n+1.0)/n_users,
704             rs, gs, bs, 0.5
705           );
706         }
707         cairo_set_source(cr, pattern);
708         if(prev_toggle-&gt;y == cur_toggle-&gt;y)
709         {
710           g_assert(prev_toggle-&gt;x &lt; cur_toggle-&gt;x);
711           rct.x = prev_toggle-&gt;x;
712           rct.y = prev_toggle-&gt;y;
713           rct.width = cur_toggle-&gt;x - prev_toggle-&gt;x;
714           rct.height = cur_toggle-&gt;user-&gt;selection_bound_rect.height;
715           gdk_cairo_rectangle(cr, &amp;rct);
716         }
717         else
718         {
719           g_assert(
720             cur_toggle-&gt;y - prev_toggle-&gt;y &gt;=
721             cur_toggle-&gt;user-&gt;selection_bound_rect.height
722           );
723           if(window_width &gt; prev_toggle-&gt;x)
724           {
725             rct.x = prev_toggle-&gt;x;
726             rct.y = prev_toggle-&gt;y;
727             rct.width = window_width - prev_toggle-&gt;x -
728               inf_text_gtk_view_get_right_margin(priv-&gt;textview);
729             rct.height = prev_toggle-&gt;user-&gt;selection_bound_rect.height;
730             gdk_cairo_rectangle(cr, &amp;rct);
731           }
732           if(cur_toggle-&gt;x &gt; 0)
733           {
734             rct.x = inf_text_gtk_view_get_left_margin(priv-&gt;textview);
735             rct.y = cur_toggle-&gt;y;
736             rct.width = cur_toggle-&gt;x - rct.x;
737             rct.height = cur_toggle-&gt;user-&gt;selection_bound_rect.height;
738             gdk_cairo_rectangle(cr, &amp;rct);
739           }
740           if(cur_toggle-&gt;y - prev_toggle-&gt;y &gt;
741              cur_toggle-&gt;user-&gt;selection_bound_rect.height)
742           {
743             rct.x = inf_text_gtk_view_get_left_margin(priv-&gt;textview);
744             rct.y = prev_toggle-&gt;y +
745               prev_toggle-&gt;user-&gt;selection_bound_rect.height;
746             rct.width = window_width - rct.x -
747               inf_text_gtk_view_get_right_margin(priv-&gt;textview);
748             rct.height = cur_toggle-&gt;y - prev_toggle-&gt;y -
749               cur_toggle-&gt;user-&gt;selection_bound_rect.height;
750             gdk_cairo_rectangle(cr, &amp;rct);
751           }
752         }
753         cairo_fill(cr);
754         cairo_pattern_destroy(pattern);
755       }
756       prev_toggle = cur_toggle;
757       do
758       {
759         if(cur_toggle-&gt;on_toggle == NULL)
760         {
761           users = g_slist_insert_sorted(
762             users,
763             cur_toggle,
764             inf_text_gtk_view_user_toggle_user_cmp
765           );
766           ++n_users;
767         }
768         else
769         {
770           g_assert(n_users &gt; 0);
771           users = g_slist_remove(users, cur_toggle-&gt;on_toggle);
772           --n_users;
773         }
774         tog_iter = g_sequence_iter_next(tog_iter);
775         if(g_sequence_iter_is_end(tog_iter))
776           break;
777         cur_toggle = (InfTextGtkViewUserToggle*)g_sequence_get(tog_iter);
778       } while(cur_toggle-&gt;pos == prev_toggle-&gt;pos);
779     }
780     g_assert(n_users == 0);
781     g_assert(users == NULL);
782     g_sequence_free(toggles);
783   }
784   if(priv-&gt;show_remote_cursors)
785   {
786     gtk_widget_style_get (widget, "cursor-color", &amp;cursor_color, NULL);
787     if(cursor_color != NULL)
788     {
789       rc = cursor_color-&gt;red / 65535.0;
790       bc = cursor_color-&gt;green / 65535.0;
791       gc = cursor_color-&gt;blue / 65535.0;
792       gdk_color_free(cursor_color);
793     }
794     else
795     {
796       rc = fg.red;
797       bc = fg.green;
798       gc = fg.blue;
799     }
800     gtk_rgb_to_hsv(rc, bc, gc, &amp;hc, &amp;sc, &amp;vc);
801     sc = MIN(MAX(sc, 0.3), 0.8);
802     vc = MAX(vc, 0.7);
803     for(item = priv-&gt;users; item != NULL; item = item-&gt;next)
804     {
805       view_user = (InfTextGtkViewUser*)item-&gt;data;
806       if(view_user-&gt;cursor_visible)
807       {
808         gtk_text_view_buffer_to_window_coords(
809           priv-&gt;textview,
810           GTK_TEXT_WINDOW_TEXT,
811           view_user-&gt;cursor_rect.x, view_user-&gt;cursor_rect.y,
812           &amp;rct.x, &amp;rct.y
813         );
814         rct.width = view_user-&gt;cursor_rect.width;
815         rct.height = view_user-&gt;cursor_rect.height;
816         if(gdk_rectangle_intersect(&amp;clip_area, &amp;rct, NULL))
817         {
818           hc = inf_text_user_get_hue(view_user-&gt;user);
819           gtk_hsv_to_rgb(hc, sc, vc, &amp;rc, &amp;gc, &amp;bc);
820           cairo_set_source_rgb(cr, rc, gc, bc);
821           gdk_cairo_rectangle(cr, &amp;rct);
822           cairo_fill(cr);
823         }
824       }
825     }
826   }
827   return FALSE;
828 }
829 static void
830 inf_text_gtk_view_style_updated_cb(GtkWidget* widget,
831                                    gpointer user_data)
832 {
833   InfTextGtkView* view;
834   InfTextGtkViewPrivate* priv;
835   GSList* item;
836   InfTextGtkViewUser* view_user;
837   view = INF_TEXT_GTK_VIEW(user_data);
838   priv = INF_TEXT_GTK_VIEW_PRIVATE(view);
839   for(item = priv-&gt;users; item != NULL; item = item-&gt;next)
840   {
841     view_user = (InfTextGtkViewUser*)item-&gt;data;
842     inf_text_gtk_view_user_compute_user_area(view_user);
843   }
844 }
845 static void
846 inf_text_gtk_view_size_allocate_cb(GtkWidget* widget,
847                                    GtkAllocation* allocation,
848                                    gpointer user_data)
849 {
850   InfTextGtkView* view;
851   InfTextGtkViewPrivate* priv;
852   GSList* item;
853   InfTextGtkViewUser* view_user;
854   view = INF_TEXT_GTK_VIEW(user_data);
855   priv = INF_TEXT_GTK_VIEW_PRIVATE(view);
856   for(item = priv-&gt;users; item != NULL; item = item-&gt;next)
857   {
858     view_user = (InfTextGtkViewUser*)item-&gt;data;
859     inf_text_gtk_view_user_compute_user_area(view_user);
860   }
861 }
862 static void
863 inf_text_gtk_view_user_cursor_blink_timeout_func(gpointer user_data)
864 {
865   InfTextGtkViewUser* view_user;
866   InfTextGtkViewPrivate* priv;
867   GtkSettings* settings;
868   gboolean cursor_blink;
869   gint cursor_blink_time;
870   view_user = (InfTextGtkViewUser*)user_data;
871   priv = INF_TEXT_GTK_VIEW_PRIVATE(view_user-&gt;view);
872   view_user-&gt;cursor_visible = !view_user-&gt;cursor_visible;
873   inf_text_gtk_view_user_invalidate_user_area(view_user);
874   settings = gtk_widget_get_settings(GTK_WIDGET(priv-&gt;textview));
875   g_object_get(
876     G_OBJECT(settings),
877     "gtk-cursor-blink", &amp;cursor_blink,
878     "gtk-cursor-blink-time", &amp;cursor_blink_time,
879     NULL
880   );
881   if(cursor_blink)
882   {
883     if(!view_user-&gt;cursor_visible)
884       cursor_blink_time = cursor_blink_time * 1 / 3;
885     else
886       cursor_blink_time = cursor_blink_time * 2 / 3;
887     view_user-&gt;timeout = inf_io_add_timeout(
888       priv-&gt;io,
889       cursor_blink_time,
890       inf_text_gtk_view_user_cursor_blink_timeout_func,
891       view_user,
892       NULL
893     );
894   }
895   else
896   {
897     view_user-&gt;timeout = NULL;
898   }
899 }
900 static void
901 inf_text_gtk_view_user_reset_timeout(InfTextGtkViewUser* view_user)
902 {
903   InfTextGtkViewPrivate* priv;
904   GtkSettings* settings;
905   gboolean cursor_blink;
906   gint cursor_blink_time;
907   priv = INF_TEXT_GTK_VIEW_PRIVATE(view_user-&gt;view);
908   if(view_user-&gt;timeout)
909   {
910     inf_io_remove_timeout(priv-&gt;io, view_user-&gt;timeout);
911     view_user-&gt;timeout = NULL;
912   }
913   if(!view_user-&gt;cursor_visible)
914   {
915     view_user-&gt;cursor_visible = TRUE;
916     inf_text_gtk_view_user_invalidate_user_area(view_user);
917   }
918   settings = gtk_widget_get_settings(GTK_WIDGET(priv-&gt;textview));
919   g_object_get(
920     G_OBJECT(settings),
921     "gtk-cursor-blink", &amp;cursor_blink,
922     "gtk-cursor-blink-time", &amp;cursor_blink_time,
923     NULL
924   );
925   if(cursor_blink)
926   {
927     view_user-&gt;timeout = inf_io_add_timeout(
928       priv-&gt;io,
929       cursor_blink_time,
930       inf_text_gtk_view_user_cursor_blink_timeout_func,
931       view_user,
932       NULL
933     );
934   }
935 }
936 static gboolean
937 inf_text_gtk_view_user_selection_changed_cb_idle_func(gpointer user_data)
938 {
939   InfTextGtkViewUser* view_user;
940   view_user = (InfTextGtkViewUser*)user_data;
941   g_assert(view_user-&gt;revalidate_idle != 0);
942   view_user-&gt;revalidate_idle = 0;
943   inf_text_gtk_view_user_invalidate_user_area(view_user);
944   return FALSE;
945 }
946 static void
947 inf_text_gtk_view_user_selection_changed_cb(InfTextUser* user,
948                                             guint position,
949                                             gint length,
950                                             gboolean by_request,
951                                             gpointer user_data)
952 {
953   InfTextGtkViewUser* view_user;
954   InfTextGtkViewPrivate* priv;
955   view_user = (InfTextGtkViewUser*)user_data;
956   priv = INF_TEXT_GTK_VIEW_PRIVATE(view_user-&gt;view);
957   if(by_request)
958   {
959     inf_text_gtk_view_user_invalidate_user_area(view_user);
960   }
961   inf_text_gtk_view_user_compute_user_area(view_user);
962   if(by_request)
963   {
964     inf_text_gtk_view_user_reset_timeout(view_user);
965     if(view_user-&gt;revalidate_idle == 0)
966     {
967       view_user-&gt;revalidate_idle = g_idle_add_full(
968         GTK_TEXT_VIEW_PRIORITY_VALIDATE + 1,
969         inf_text_gtk_view_user_selection_changed_cb_idle_func,
970         view_user,
971         NULL
972       );
973     }
974   }
975 }
976 static void
977 inf_text_gtk_view_user_notify_hue_cb(GObject* object,
978                                      GParamSpec* pspec,
979                                      gpointer user_data)
980 {
981   InfTextGtkViewUser* view_user;
982   InfTextGtkViewPrivate* priv;
983   view_user = (InfTextGtkViewUser*)user_data;
984   priv = INF_TEXT_GTK_VIEW_PRIVATE(view_user-&gt;view);
985   gtk_widget_queue_draw(GTK_WIDGET(priv-&gt;textview));
986 <font color="#980517"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>}
987 static void
988 inf_text_gtk_view_add_user(InfTextGtkView* view,
989                            InfTextUser* user)
990 {
991   InfTextGtkViewPrivate* priv;
992   InfTextGtkViewUser* view_user;
993   priv = INF_TEXT_GTK_VIEW_PRIVATE(view);
994   view_user = g_slice_new(InfTextGtkViewUser);
995   view_user-&gt;view = view;
996   view_user-&gt;user = INF_TEXT_USER(user);
997   view_user-&gt;cursor_visible = TRUE;
998   view_user-&gt;timeout = NULL;
999   view_user-&gt;revalidate_idle = 0;</b></font>
1000   inf_text_gtk_view_user_compute_user_area(view_user);
1001   inf_text_gtk_view_user_reset_timeout(view_user);
1002   priv-&gt;users = g_slist_prepend(priv-&gt;users, view_user);
1003   g_signal_connect_after(
1004     user,
1005     "selection-changed",
1006     G_CALLBACK(inf_text_gtk_view_user_selection_changed_cb),
1007     view_user
1008   );
1009   g_signal_connect(
1010     user,
1011     "notify::hue",
1012     G_CALLBACK(inf_text_gtk_view_user_notify_hue_cb),
1013     view_user
1014   );
1015   inf_text_gtk_view_user_invalidate_user_area(view_user);
1016 }
1017 static void
1018 inf_text_gtk_view_remove_user(InfTextGtkViewUser* view_user)
1019 {
1020   InfTextGtkViewPrivate* priv;
1021   priv = INF_TEXT_GTK_VIEW_PRIVATE(view_user-&gt;view);
1022   inf_signal_handlers_disconnect_by_func(
1023     view_user-&gt;user,
1024     G_CALLBACK(inf_text_gtk_view_user_selection_changed_cb),
1025     view_user
1026   );
1027   inf_signal_handlers_disconnect_by_func(
1028     view_user-&gt;user,
1029     G_CALLBACK(inf_text_gtk_view_user_notify_hue_cb),
1030     view_user
1031   );
1032   if(view_user-&gt;timeout != NULL)
1033     inf_io_remove_timeout(priv-&gt;io, view_user-&gt;timeout);
1034   if(view_user-&gt;revalidate_idle != 0)
1035     g_source_remove(view_user-&gt;revalidate_idle);
1036   inf_text_gtk_view_user_invalidate_user_area(view_user);
1037   priv-&gt;users = g_slist_remove(priv-&gt;users, view_user);
1038   g_slice_free(InfTextGtkViewUser, view_user);
1039 }
1040 static void
1041 inf_text_gtk_view_user_notify_status_cb(GObject* object,
1042                                         GParamSpec* pspec,
1043                                         gpointer user_data)
1044 {
1045   InfTextGtkView* view;
1046   InfTextGtkViewPrivate* priv;
1047   InfTextUser* user;
1048   InfTextGtkViewUser* view_user;
1049   view = INF_TEXT_GTK_VIEW(user_data);
1050   priv = INF_TEXT_GTK_VIEW_PRIVATE(view);
1051   user = INF_TEXT_USER(object);
1052   g_assert(user != priv-&gt;active_user);
1053   view_user = inf_text_gtk_view_find_user(view, user);
1054   if(inf_user_get_status(INF_USER(user)) == INF_USER_ACTIVE)
1055   {
1056     if(!view_user)
1057       inf_text_gtk_view_add_user(view, user);
1058   }
1059   else
1060   {
1061     if(view_user)
1062       inf_text_gtk_view_remove_user(view_user);
1063   }
1064 }
1065 static void
1066 inf_text_gtk_view_user_removed(InfTextGtkView* view,
1067                                InfTextUser* user)
1068 {
1069   InfTextGtkViewPrivate* priv;
1070   InfTextGtkViewUser* view_user;
1071   priv = INF_TEXT_GTK_VIEW_PRIVATE(view);
1072   if(user == priv-&gt;active_user)
1073   {
1074     priv-&gt;active_user = NULL;
1075     g_object_notify(G_OBJECT(view), "active-user");
1076   }
1077   else
1078   {
1079     inf_signal_handlers_disconnect_by_func(
1080       user,
1081       G_CALLBACK(inf_text_gtk_view_user_notify_status_cb),
1082       view
1083     );
1084     if(inf_user_get_status(INF_USER(user)) == INF_USER_ACTIVE)
1085     {
1086       view_user = inf_text_gtk_view_find_user(view, user);
1087       g_assert(view_user != NULL);
1088       inf_text_gtk_view_remove_user(view_user);
1089     }
1090   }
1091 }
1092 static void
1093 inf_text_gtk_view_user_added(InfTextGtkView* view,
1094                              InfTextUser* user)
1095 {
1096   InfTextGtkViewPrivate* priv;
1097   priv = INF_TEXT_GTK_VIEW_PRIVATE(view);
1098   g_assert(user != priv-&gt;active_user);
1099   g_signal_connect(
1100     user,
1101     "notify::status",
1102     G_CALLBACK(inf_text_gtk_view_user_notify_status_cb),
1103     view
1104   );
1105   if(inf_user_get_status(INF_USER(user)) == INF_USER_ACTIVE)
1106     inf_text_gtk_view_add_user(view, user);
1107 }
1108 static void
1109 inf_text_gtk_view_add_user_cb(InfUserTable* user_table,
1110                               InfUser* user,
1111                               gpointer user_data)
1112 {
1113   InfTextGtkView* view = INF_TEXT_GTK_VIEW(user_data);
1114   g_assert(INF_TEXT_IS_USER(user));
1115   inf_text_gtk_view_user_added(view, INF_TEXT_USER(user));
1116 }
1117 static void
1118 inf_text_gtk_view_remove_user_cb(InfUserTable* user_table,
1119                                  InfUser* user,
1120                                  gpointer user_data)
1121 {
1122   InfTextGtkView* view = INF_TEXT_GTK_VIEW(user_data);
1123   g_assert(INF_TEXT_IS_USER(user));
1124   inf_text_gtk_view_user_removed(view, INF_TEXT_USER(user));
1125 }
1126 static void
1127 inf_text_gtk_view_set_user_table_foreach_new_user_func(InfUser* user,
1128                                                        gpointer user_data)
1129 {
1130   InfTextGtkView* view = INF_TEXT_GTK_VIEW(user_data);
1131   g_assert(INF_TEXT_IS_USER(user));
1132   inf_text_gtk_view_user_added(view, INF_TEXT_USER(user));
1133 }
1134 static void
1135 inf_text_gtk_view_set_user_table_foreach_old_user_func(InfUser* user,
1136                                                        gpointer user_data)
1137 {
1138   InfTextGtkView* view = INF_TEXT_GTK_VIEW(user_data);
1139   g_assert(INF_TEXT_IS_USER(user));
1140   inf_text_gtk_view_user_removed(view, INF_TEXT_USER(user));
1141 }
1142 static void
1143 inf_text_gtk_view_set_view(InfTextGtkView* view,
1144                            GtkTextView* gtk_view)
1145 {
1146   InfTextGtkViewPrivate* priv;
1147   priv = INF_TEXT_GTK_VIEW_PRIVATE(view);
1148   if(priv-&gt;textview != NULL)
1149   {
1150     inf_signal_handlers_disconnect_by_func(
1151       G_OBJECT(priv-&gt;textview),
1152       G_CALLBACK(inf_text_gtk_view_draw_before_cb),
1153       view
1154     );
1155     inf_signal_handlers_disconnect_by_func(
1156       G_OBJECT(priv-&gt;textview),
1157       G_CALLBACK(inf_text_gtk_view_draw_after_cb),
1158       view
1159     );
1160     inf_signal_handlers_disconnect_by_func(
1161       G_OBJECT(priv-&gt;textview),
1162       G_CALLBACK(inf_text_gtk_view_style_updated_cb),
1163       view
1164     );
1165     inf_signal_handlers_disconnect_by_func(
1166       G_OBJECT(priv-&gt;textview),
1167       G_CALLBACK(inf_text_gtk_view_size_allocate_cb),
1168       view
1169     );
1170     g_object_unref(priv-&gt;textview);
1171   }
1172   priv-&gt;textview = gtk_view;
1173   if(gtk_view != NULL)
1174   {
1175     g_object_ref(gtk_view);
1176     g_signal_connect(
1177       G_OBJECT(gtk_view),
1178       "draw",
1179       G_CALLBACK(inf_text_gtk_view_draw_before_cb),
1180       view
1181     );
1182     g_signal_connect_after(
1183       G_OBJECT(gtk_view),
1184       "draw",
1185       G_CALLBACK(inf_text_gtk_view_draw_after_cb),
1186       view
1187     );
1188     g_signal_connect_after(
1189       G_OBJECT(gtk_view),
1190       "style-updated",
1191       G_CALLBACK(inf_text_gtk_view_style_updated_cb),
1192       view
1193     );
1194     g_signal_connect_after(
1195       G_OBJECT(gtk_view),
1196       "size-allocate",
1197 <a name="0"></a>      G_CALLBACK(inf_text_gtk_view_size_allocate_cb),
1198       view
1199     );
1200 <font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>  }
1201   g_object_notify(G_OBJECT(view), "view");
1202 }
1203 static void
1204 inf_text_gtk_view_set_user_table(InfTextGtkView* view,
1205                                  InfUserTable* user_table)
1206 {
1207   InfTextGtkViewPrivate* priv;
1208   priv = INF_TEXT_GTK_VIEW_PRIVATE(view);
1209   if(priv-&gt;user_table != NULL)
1210   {
1211     inf_signal_handlers_disconnect_by_func(
1212       G_OBJECT(priv-&gt;user_table),
1213       G_CALLBACK(inf_text_gtk_view_add_user_cb),
1214       view
1215     );
1216     inf_signal_handlers_disconnect_by_func(
1217       G_OBJECT(priv-&gt;user_table),
1218       G_CALLBACK(inf_text_gtk_view_remove_user_cb),
1219       view
1220     );
1221     inf_user_table_foreach_user(
1222       priv-&gt;user_table,
1223       inf_text_gtk_view_set_user_table_foreach_old_user_func,
1224       view
1225     );
1226     g_object_unref(priv-&gt;user_table);
1227   }
1228   priv-&gt;user_table = user_table;
1229   if(user_table != NULL)
1230   {
1231     g_object_ref(user_table);
1232     g_signal_connect(
1233       G_OBJECT(user_table),
1234       "add-user",
1235       G_CALLBACK(inf_text_gtk_view_add_user_cb),
1236       view
1237     );
1238     g_signal_connect(
1239       G_OBJECT(user_table),
1240       "remove-user",
1241       G_CALLBACK(inf_text_gtk_view_remove_user_cb),
1242       view
1243     );
1244     inf_user_table_foreach_user(
1245       user_table,
1246       inf_text_gtk_view_set_user_table_foreach_new_user_func,
1247       view
1248     );
1249   }
1250   g_object_notify(G_OBJECT(view), "user-table");
1251 }
1252 static void
1253 inf_text_gtk_view_init(InfTextGtkView* view)
1254 {
1255   InfTextGtkViewPrivate* priv;
1256   priv = INF_TEXT_GTK_VIEW_PRIVATE(view);
1257   priv-&gt;io = NULL;
1258   priv-&gt;textview = NULL;</b></font>
1259   priv-&gt;user_table = NULL;
1260   priv-&gt;active_user = NULL;
1261   priv-&gt;users = NULL;
1262   priv-&gt;show_remote_cursors = TRUE;
1263   priv-&gt;show_remote_selections = TRUE;
1264   priv-&gt;show_remote_current_lines = TRUE;
1265 }
1266 static void
1267 inf_text_gtk_view_dispose(GObject* object)
1268 {
1269   InfTextGtkView* view;
1270   InfTextGtkViewPrivate* priv;
1271   view = INF_TEXT_GTK_VIEW(object);
1272   priv = INF_TEXT_GTK_VIEW_PRIVATE(view);
1273   inf_text_gtk_view_set_user_table(view, NULL);
1274   inf_text_gtk_view_set_view(view, NULL);
1275   g_assert(priv-&gt;active_user == NULL);
1276   g_assert(priv-&gt;users == NULL);
1277   if(priv-&gt;io != NULL)
1278   {
1279     g_object_unref(priv-&gt;io);
1280     priv-&gt;io = NULL;
1281   }
1282   G_OBJECT_CLASS(inf_text_gtk_view_parent_class)-&gt;dispose(object);
1283 }
1284 static void
1285 inf_text_gtk_view_set_property(GObject* object,
1286                                  guint prop_id,
1287                                  const GValue* value,
1288                                  GParamSpec* pspec)
1289 {
1290   InfTextGtkView* view;
1291   InfTextGtkViewPrivate* priv;
1292   view = INF_TEXT_GTK_VIEW(object);
1293   priv = INF_TEXT_GTK_VIEW_PRIVATE(view);
1294   switch(prop_id)
1295   {
1296   case PROP_IO:
1297     g_assert(priv-&gt;io == NULL);     priv-&gt;io = INF_IO(g_value_dup_object(value));
1298     break;
1299   case PROP_VIEW:
1300     g_assert(priv-&gt;textview == NULL); 
1301     inf_text_gtk_view_set_view(
1302       view,
1303       GTK_TEXT_VIEW(g_value_get_object(value))
1304     );
1305     break;
1306   case PROP_USER_TABLE:
1307     g_assert(priv-&gt;user_table == NULL); 
1308     inf_text_gtk_view_set_user_table(
1309       view,
1310       INF_USER_TABLE(g_value_get_object(value))
1311     );
1312     break;
1313   case PROP_ACTIVE_USER:
1314     inf_text_gtk_view_set_active_user(
1315       view,
1316       INF_TEXT_USER(g_value_get_object(value))
1317     );
1318     break;
1319   case PROP_SHOW_REMOTE_CURSORS:
1320     inf_text_gtk_view_set_show_remote_cursors(
1321       view,
1322       g_value_get_boolean(value)
1323     );
1324     break;
1325   case PROP_SHOW_REMOTE_SELECTIONS:
1326     inf_text_gtk_view_set_show_remote_selections(
1327       view,
1328       g_value_get_boolean(value)
1329     );
1330     break;
1331   case PROP_SHOW_REMOTE_CURRENT_LINES:
1332     inf_text_gtk_view_set_show_remote_current_lines(
1333       view,
1334       g_value_get_boolean(value)
1335     );
1336     break;
1337   default:
1338     G_OBJECT_WARN_INVALID_PROPERTY_ID(value, prop_id, pspec);
1339     break;
1340   }
1341 }
1342 static void
1343 inf_text_gtk_view_get_property(GObject* object,
1344                                  guint prop_id,
1345                                  GValue* value,
1346                                  GParamSpec* pspec)
1347 {
1348 <a name="1"></a>  InfTextGtkView* view;
1349   InfTextGtkViewPrivate* priv;
1350 <font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>  view = INF_TEXT_GTK_VIEW(object);
1351   priv = INF_TEXT_GTK_VIEW_PRIVATE(view);
1352   switch(prop_id)
1353   {
1354   case PROP_IO:
1355     g_value_set_object(value, G_OBJECT(priv-&gt;io));
1356     break;
1357   case PROP_VIEW:
1358     g_value_set_object(value, G_OBJECT(priv-&gt;textview));
1359     break;
1360   case PROP_USER_TABLE:
1361     g_value_set_object(value, G_OBJECT(priv-&gt;user_table));
1362     break;
1363   case PROP_ACTIVE_USER:
1364     g_value_set_object(value, G_OBJECT(priv-&gt;active_user));
1365     break;
1366   case PROP_SHOW_REMOTE_CURSORS:
1367     g_value_set_boolean(value, priv-&gt;show_remote_cursors);
1368     break;
1369   case PROP_SHOW_REMOTE_SELECTIONS:
1370     g_value_set_boolean(value, priv-&gt;show_remote_selections);
1371     break;
1372   case PROP_SHOW_REMOTE_CURRENT_LINES:</b></font>
1373     g_value_set_boolean(value, priv-&gt;show_remote_current_lines);
1374     break;
1375   default:
1376     G_OBJECT_WARN_INVALID_PROPERTY_ID(object, prop_id, pspec);
1377     break;
1378   }
1379 }
1380 static void
1381 inf_text_gtk_view_class_init(InfTextGtkViewClass* view_class)
1382 {
1383   GObjectClass* object_class;
1384   object_class = G_OBJECT_CLASS(view_class);
1385   object_class-&gt;dispose = inf_text_gtk_view_dispose;
1386   object_class-&gt;set_property = inf_text_gtk_view_set_property;
1387   object_class-&gt;get_property = inf_text_gtk_view_get_property;
1388   g_object_class_install_property(
1389     object_class,
1390     PROP_IO,
1391     g_param_spec_object(
1392       "io",
1393       "IO",
1394       "The IO object to schedule timeouts",
1395       INF_TYPE_IO,
1396       G_PARAM_READWRITE | G_PARAM_CONSTRUCT_ONLY
1397     )
1398   );
1399   g_object_class_install_property(
1400     object_class,
1401     PROP_VIEW,
1402     g_param_spec_object(
1403       "view",
1404       "View",
1405       "The underlying GtkTextView",
1406       GTK_TYPE_TEXT_VIEW,
1407       G_PARAM_READWRITE | G_PARAM_CONSTRUCT_ONLY
1408     )
1409   );
1410   g_object_class_install_property(
1411     object_class,
1412     PROP_USER_TABLE,
1413     g_param_spec_object(
1414       "user-table",
1415       "User table",
1416       "The user table containing the users of the session shown in the view",
1417       INF_TYPE_USER_TABLE,
1418       G_PARAM_READWRITE | G_PARAM_CONSTRUCT_ONLY
1419     )
1420   );
1421   g_object_class_install_property(
1422     object_class,
1423     PROP_ACTIVE_USER,
1424     g_param_spec_object(
1425       "active-user",
1426       "Active user",
1427       "The user for which to show the view",
1428       INF_TEXT_TYPE_USER,
1429       G_PARAM_READWRITE
1430     )
1431   );
1432   g_object_class_install_property(
1433     object_class,
1434     PROP_SHOW_REMOTE_CURSORS,
1435     g_param_spec_boolean(
1436       "show-remote-cursors",
1437       "Show remote cursors",
1438       "Whether to show cursors of non-local users",
1439       TRUE,
1440       G_PARAM_READWRITE
1441     )
1442   );
1443   g_object_class_install_property(
1444     object_class,
1445     PROP_SHOW_REMOTE_SELECTIONS,
1446     g_param_spec_boolean(
1447       "show-remote-selections",
1448       "Show remote selections",
1449       "Whether to highlight text selected by non-local users",
1450       TRUE,
1451       G_PARAM_READWRITE
1452     )
1453   );
1454   g_object_class_install_property(
1455     object_class,
1456     PROP_SHOW_REMOTE_CURRENT_LINES,
1457     g_param_spec_boolean(
1458       "show-remote-current-lines",
1459       "Show remote current lines",
1460       "Whether to highlight the line in which the cursor of non-local users is",
1461       TRUE,
1462       G_PARAM_READWRITE
1463     )
1464   );
1465 }
1466 InfTextGtkView*
1467 inf_text_gtk_view_new(InfIo* io,
1468                       GtkTextView* view,
1469                       InfUserTable* user_table)
1470 {
1471   GObject* object;
1472   g_return_val_if_fail(INF_IS_IO(io), NULL);
1473   g_return_val_if_fail(GTK_IS_TEXT_VIEW(view), NULL);
1474   g_return_val_if_fail(INF_IS_USER_TABLE(user_table), NULL);
1475   object = g_object_new(
1476     INF_TEXT_GTK_TYPE_VIEW,
1477     "io", io,
1478     "view", view,
1479     "user-table", user_table,
1480     NULL
1481   );
1482   return INF_TEXT_GTK_VIEW(object);
1483 }
1484 GtkTextView*
1485 inf_text_gtk_view_get_text_view(InfTextGtkView* view)
1486 {
1487   g_return_val_if_fail(INF_TEXT_GTK_IS_VIEW(view), NULL);
1488   return INF_TEXT_GTK_VIEW_PRIVATE(view)-&gt;textview;
1489 }
1490 InfUserTable*
1491 inf_text_gtk_view_get_user_table(InfTextGtkView* view)
1492 {
1493   g_return_val_if_fail(INF_TEXT_GTK_IS_VIEW(view), NULL);
1494   return INF_TEXT_GTK_VIEW_PRIVATE(view)-&gt;user_table;
1495 }
1496 void
1497 inf_text_gtk_view_set_active_user(InfTextGtkView* view,
1498                                   InfTextUser* user)
1499 {
1500   InfTextGtkViewPrivate* priv;
1501   InfTextUser* active_user;
1502   g_return_if_fail(INF_TEXT_GTK_IS_VIEW(view));
1503   g_return_if_fail(user == NULL || INF_TEXT_IS_USER(user));
1504   priv = INF_TEXT_GTK_VIEW_PRIVATE(view);
1505   g_return_if_fail(
1506     user == NULL ||
1507     inf_user_table_lookup_user_by_id(
1508       priv-&gt;user_table,
1509       inf_user_get_id(INF_USER(user))
1510     ) == INF_USER(user)
1511   );
1512   if(priv-&gt;active_user != NULL)
1513   {
1514     active_user = priv-&gt;active_user;
1515     priv-&gt;active_user = NULL;
1516     inf_text_gtk_view_user_added(view, active_user);
1517   }
1518   if(user != NULL)
1519   {
1520     inf_text_gtk_view_user_removed(view, user);
1521   }
1522   priv-&gt;active_user = user;
1523   g_object_notify(G_OBJECT(view), "active-user");
1524 }
1525 InfTextUser*
1526 inf_text_gtk_view_get_active_user(InfTextGtkView* view)
1527 {
1528   g_return_val_if_fail(INF_TEXT_GTK_IS_VIEW(view), NULL);
1529   return INF_TEXT_GTK_VIEW_PRIVATE(view)-&gt;active_user;
1530 }
1531 void
1532 inf_text_gtk_view_set_show_remote_cursors(InfTextGtkView* view,
1533                                           gboolean show)
1534 {
1535   InfTextGtkViewPrivate* priv;
1536   g_return_if_fail(INF_TEXT_GTK_IS_VIEW(view));
1537   priv = INF_TEXT_GTK_VIEW_PRIVATE(view);
1538   if(priv-&gt;show_remote_cursors != show)
1539   {
1540     gtk_widget_queue_draw(GTK_WIDGET(priv-&gt;textview));
1541     priv-&gt;show_remote_cursors = show;
1542     g_object_notify(G_OBJECT(view), "show-remote-cursors");
1543   }
1544 }
1545 void
1546 inf_text_gtk_view_set_show_remote_selections(InfTextGtkView* view,
1547                                              gboolean show)
1548 {
1549   InfTextGtkViewPrivate* priv;
1550   g_return_if_fail(INF_TEXT_GTK_IS_VIEW(view));
1551   priv = INF_TEXT_GTK_VIEW_PRIVATE(view);
1552   if(priv-&gt;show_remote_selections != show)
1553   {
1554     gtk_widget_queue_draw(GTK_WIDGET(priv-&gt;textview));
1555     priv-&gt;show_remote_selections = show;
1556     g_object_notify(G_OBJECT(view), "show-remote-selections");
1557   }
1558 }
1559 void
1560 inf_text_gtk_view_set_show_remote_current_lines(InfTextGtkView* view,
1561                                                 gboolean show)
1562 {
1563   InfTextGtkViewPrivate* priv;
1564   g_return_if_fail(INF_TEXT_GTK_IS_VIEW(view));
1565   priv = INF_TEXT_GTK_VIEW_PRIVATE(view);
1566   if(priv-&gt;show_remote_current_lines != show)
1567   {
1568     gtk_widget_queue_draw(GTK_WIDGET(priv-&gt;textview));
1569     priv-&gt;show_remote_current_lines = show;
1570     g_object_notify(G_OBJECT(view), "show-remote-current-lines");
1571   }
1572 }
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>inf-tcp-connection.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 #include &lt;libinfinity/common/inf-tcp-connection.h&gt;
2 #include &lt;libinfinity/common/inf-tcp-connection-private.h&gt;
3 #include &lt;libinfinity/common/inf-name-resolver.h&gt;
4 #include &lt;libinfinity/common/inf-ip-address.h&gt;
5 #include &lt;libinfinity/common/inf-io.h&gt;
6 #include &lt;libinfinity/common/inf-native-socket.h&gt;
7 #include &lt;libinfinity/inf-signals.h&gt;
8 #include &lt;libinfinity/inf-i18n.h&gt;
9 #include &lt;libinfinity/inf-define-enum.h&gt;
10 #include &lt;unistd.h&gt; 
11 #include "config.h"
12 #ifndef G_OS_WIN32
13 # include &lt;sys/types.h&gt;
14 # include &lt;sys/socket.h&gt;
15 # include &lt;netinet/in.h&gt;
16 # include &lt;net/if.h&gt;
17 # include &lt;arpa/inet.h&gt;
18 # include &lt;unistd.h&gt;
19 # include &lt;fcntl.h&gt;
20 # include &lt;errno.h&gt;
21 # include &lt;string.h&gt;
22 #else
23 # include &lt;ws2tcpip.h&gt;
24 #endif
25 static const GEnumValue inf_tcp_connection_status_values[] = {
26   {
27     INF_TCP_CONNECTION_CONNECTING,
28     "INF_TCP_CONNECTION_CONNECTING",
29     "connecting"
30   }, {
31     INF_TCP_CONNECTION_CONNECTED,
32     "INF_TCP_CONNECTION_CONNECTED",
33     "connected"
34   }, {
35     INF_TCP_CONNECTION_CLOSED,
36     "INF_TCP_CONNECTION_CLOSED",
37     "closed"
38   }, {
39     0,
40     NULL,
41     NULL
42   }
43 };
44 typedef struct _InfTcpConnectionPrivate InfTcpConnectionPrivate;
45 struct _InfTcpConnectionPrivate {
46   InfIo* io;
47   InfIoEvent events;
48   InfIoWatch* watch;
49   InfNameResolver* resolver;
50   guint resolver_index;
51   InfTcpConnectionStatus status;
52   InfNativeSocket socket;
53   InfKeepalive keepalive;
54   InfIpAddress* remote_address;
55   guint remote_port;
56   unsigned int device_index;
57   guint8* queue;
58   gsize front_pos;
59   gsize back_pos;
60   gsize alloc;
61 };
62 enum {
63   PROP_0,
64   PROP_IO,
65   PROP_RESOLVER,
66   PROP_STATUS,
67   PROP_KEEPALIVE,
68   PROP_REMOTE_ADDRESS,
69   PROP_REMOTE_PORT,
70   PROP_LOCAL_ADDRESS,
71   PROP_LOCAL_PORT,
72   PROP_DEVICE_INDEX,
73   PROP_DEVICE_NAME
74 };
75 enum {
76   SENT,
77   RECEIVED,
78   ERROR_, 
79   LAST_SIGNAL
80 };
81 #define INF_TCP_CONNECTION_PRIVATE(obj) (G_TYPE_INSTANCE_GET_PRIVATE((obj), INF_TYPE_TCP_CONNECTION, InfTcpConnectionPrivate))
82 static guint tcp_connection_signals[LAST_SIGNAL];
83 INF_DEFINE_ENUM_TYPE(InfTcpConnectionStatus, inf_tcp_connection_status, inf_tcp_connection_status_values)
84 G_DEFINE_TYPE_WITH_CODE(InfTcpConnection, inf_tcp_connection, G_TYPE_OBJECT,
85   G_ADD_PRIVATE(InfTcpConnection))
86 static gboolean
87 inf_tcp_connection_addr_info(InfNativeSocket socket,
88                              gboolean local,
89                              InfIpAddress** address,
90                              guint* port,
91                              GError** error)
92 {
93   union {
94     struct sockaddr in_generic;
95     struct sockaddr_in in;
96     struct sockaddr_in6 in6;
97   } native_addr;
98   socklen_t len;
99   int res;
100   int code;
101   len = sizeof(native_addr);
102   if(local == TRUE)
103     res = getsockname(socket, &amp;native_addr.in_generic, &amp;len);
104   else
105     res = getpeername(socket, &amp;native_addr.in_generic, &amp;len);
106   if(res == -1)
107   {
108     code = INF_NATIVE_SOCKET_LAST_ERROR;
109     inf_native_socket_make_error(code, error);
110     return FALSE;
111   }
112   switch(native_addr.in_generic.sa_family)
113   {
114   case AF_INET:
115     if(address != NULL)
116       *address = inf_ip_address_new_raw4(native_addr.in.sin_addr.s_addr);
117     if(port != NULL)
118       *port = ntohs(native_addr.in.sin_port);
119     break;
120   case AF_INET6:
121     if(address != NULL)
122       *address = inf_ip_address_new_raw6(native_addr.in6.sin6_addr.s6_addr);
123     if(port != NULL)
124       *port = ntohs(native_addr.in6.sin6_port);
125     break;
126   default:
127     g_assert_not_reached();
128     break;
129   }
130   return TRUE;
131 }
132 static gboolean
133 inf_tcp_connection_configure_socket(InfNativeSocket socket,
134                                     const InfKeepalive* keepalive,
135                                     GError** error)
136 {
137 #ifdef G_OS_WIN32
138   u_long argp;
139 #else
140   int result;
141 #endif
142   int errcode;
143   GError* local_error;
144 #ifndef G_OS_WIN32
145   result = fcntl(socket, F_GETFL);
146   if(result == INVALID_SOCKET)
147   {
148     errcode = INF_NATIVE_SOCKET_LAST_ERROR;
149     inf_native_socket_make_error(errcode, error);
150     return FALSE;
151   }
152   if(fcntl(socket, F_SETFL, result | O_NONBLOCK) == -1)
153   {
154     errcode = INF_NATIVE_SOCKET_LAST_ERROR;
155     inf_native_socket_make_error(errcode, error);
156     return FALSE;
157   }
158 #else
159   argp = 1;
160   if(ioctlsocket(socket, FIONBIO, &amp;argp) != 0)
161   {
162     errcode = INF_NATIVE_SOCKET_LAST_ERROR;
163     inf_native_socket_make_error(errcode, error);
164     return FALSE;
165   }
166 #endif
167   local_error = NULL;
168   if(inf_keepalive_apply(keepalive, &amp;socket, 0, &amp;local_error) == FALSE)
169   {
170     g_warning("Failed to set keepalive on socket: %s", local_error-&gt;message);
171     g_error_free(local_error);
172   }
173   return TRUE;
174 }
175 static void
176 inf_tcp_connection_system_error(InfTcpConnection* connection,
177                                 int code)
178 {
179   GError* error;
180   error = NULL;
181   inf_native_socket_make_error(code, &amp;error);
182   g_signal_emit(
183     G_OBJECT(connection),
184     tcp_connection_signals[ERROR_],
185     0,
186     error
187   );
188   g_error_free(error);
189 }
190 static void
191 inf_tcp_connection_io(InfNativeSocket* socket,
192                       InfIoEvent events,
193                       gpointer user_data);
194 static void
195 inf_tcp_connection_connected(InfTcpConnection* connection)
196 {
197   InfTcpConnectionPrivate* priv;
198   priv = INF_TCP_CONNECTION_PRIVATE(connection);
199   priv-&gt;status = INF_TCP_CONNECTION_CONNECTED;
200   priv-&gt;front_pos = 0;
201   priv-&gt;back_pos = 0;
202   priv-&gt;events = INF_IO_INCOMING | INF_IO_ERROR;
203   if(priv-&gt;watch == NULL)
204   {
205     priv-&gt;watch = inf_io_add_watch(
206       priv-&gt;io,
207       &amp;priv-&gt;socket,
208       priv-&gt;events,
209       inf_tcp_connection_io,
210       connection,
211       NULL
212     );
213   }
214   else
215   {
216     inf_io_update_watch(priv-&gt;io, priv-&gt;watch, priv-&gt;events);
217   }
218   g_object_freeze_notify(G_OBJECT(connection));
219   if(priv-&gt;resolver != NULL)
220   {
221     if(priv-&gt;remote_address != NULL)
222       inf_ip_address_free(priv-&gt;remote_address);
223     priv-&gt;remote_address = inf_ip_address_copy(
224       inf_name_resolver_get_address(priv-&gt;resolver, priv-&gt;resolver_index)
225     );
226     priv-&gt;remote_port =
227       inf_name_resolver_get_port(priv-&gt;resolver, priv-&gt;resolver_index);
228     g_object_notify(G_OBJECT(connection), "remote-address");
229     g_object_notify(G_OBJECT(connection), "remote-port");
230     priv-&gt;resolver_index = 0;
231   }
232   g_object_notify(G_OBJECT(connection), "status");
233   g_object_notify(G_OBJECT(connection), "local-address");
234   g_object_notify(G_OBJECT(connection), "local-port");
235   g_object_thaw_notify(G_OBJECT(connection));
236 }
237 static gboolean
238 inf_tcp_connection_open_with_resolver(InfTcpConnection* connection,
239                                       GError** error);
240 static gboolean
241 inf_tcp_connection_connection_error(InfTcpConnection* connection,
242                                     const GError* error)
243 {
244   InfTcpConnectionPrivate* priv;
245   priv = INF_TCP_CONNECTION_PRIVATE(connection);
246   if(priv-&gt;socket != INVALID_SOCKET)
247   {
248     closesocket(priv-&gt;socket);
249     priv-&gt;socket = INVALID_SOCKET;
250   }
251   if(priv-&gt;watch != NULL)
252   {
253     priv-&gt;events = 0;
254     inf_io_remove_watch(priv-&gt;io, priv-&gt;watch);
255     priv-&gt;watch = NULL;
256   }
257   if(priv-&gt;resolver != NULL)
258   {
259     if(priv-&gt;resolver_index &lt;
260        inf_name_resolver_get_n_addresses(priv-&gt;resolver))
261     {
262       ++priv-&gt;resolver_index;
263       if(inf_tcp_connection_open_with_resolver(connection, NULL) == TRUE)
264         return TRUE;
265     }
266     priv-&gt;resolver_index = 0;
267   }
268   g_signal_emit(
269     G_OBJECT(connection),
270     tcp_connection_signals[ERROR_],
271     0,
272     error
273   );
274   return FALSE;
275 }
276 static gboolean
277 inf_tcp_connection_open_real(InfTcpConnection* connection,
278                              const InfIpAddress* address,
279                              guint port,
280                              GError** error)
281 {
282   InfTcpConnectionPrivate* priv;
283   union {
284     struct sockaddr_in in;
285     struct sockaddr_in6 in6;
286   } native_address;
287   struct sockaddr* addr;
288   socklen_t addrlen;
289   int result;
290   int errcode;
291   const InfKeepalive* keepalive;
292   GError* local_error;
293   priv = INF_TCP_CONNECTION_PRIVATE(connection);
294   g_assert(priv-&gt;status == INF_TCP_CONNECTION_CLOSED ||
295            priv-&gt;status == INF_TCP_CONNECTION_CONNECTING);
296   if(priv-&gt;socket != INVALID_SOCKET)
297     closesocket(priv-&gt;socket);
298   switch(inf_ip_address_get_family(address))
299   {
300   case INF_IP_ADDRESS_IPV4:
301     priv-&gt;socket = socket(PF_INET, SOCK_STREAM, IPPROTO_TCP);
302     addr = (struct sockaddr*)&amp;native_address.in;
303     addrlen = sizeof(struct sockaddr_in);
304     memcpy(
305       &amp;native_address.in.sin_addr,
306       inf_ip_address_get_raw(address),
307       sizeof(struct in_addr)
308     );
309     native_address.in.sin_family = AF_INET;
310     native_address.in.sin_port = htons(port);
311     break;
312   case INF_IP_ADDRESS_IPV6:
313     priv-&gt;socket = socket(PF_INET6, SOCK_STREAM, IPPROTO_TCP);
314     addr = (struct sockaddr*)&amp;native_address.in6;
315     addrlen = sizeof(struct sockaddr_in6);
316     memcpy(
317       &amp;native_address.in6.sin6_addr,
318       inf_ip_address_get_raw(address),
319       sizeof(struct in6_addr)
320     );
321     native_address.in6.sin6_family = AF_INET6;
322     native_address.in6.sin6_port = htons(port);
323     native_address.in6.sin6_flowinfo = 0;
324     native_address.in6.sin6_scope_id = priv-&gt;device_index;
325     break;
326   default:
327     g_assert_not_reached();
328     break;
329   }
330   if(priv-&gt;socket == INVALID_SOCKET)
331   {
332     inf_native_socket_make_error(INF_NATIVE_SOCKET_LAST_ERROR, error);
333     return FALSE;
334   }
335   keepalive = &amp;priv-&gt;keepalive;
336   if(!inf_tcp_connection_configure_socket(priv-&gt;socket, keepalive, error))
337   {
338     closesocket(priv-&gt;socket);
339     priv-&gt;socket = INVALID_SOCKET;
340     return FALSE;
341   }
342   do
343   {
344     result = connect(priv-&gt;socket, addr, addrlen);
345     errcode = INF_NATIVE_SOCKET_LAST_ERROR;
346     if(result == -1 &amp;&amp;
347        errcode != INF_NATIVE_SOCKET_EINTR &amp;&amp;
348        errcode != INF_NATIVE_SOCKET_EINPROGRESS)
349     {
350       local_error = NULL;
351       inf_native_socket_make_error(errcode, &amp;local_error);
352       if(inf_tcp_connection_connection_error(connection, local_error) == TRUE)
353       {
354         g_error_free(local_error);
355         return TRUE;
356       }
357       g_propagate_error(error, local_error);
358       return FALSE;
359     }
360   } while(result == -1 &amp;&amp; errcode != INF_NATIVE_SOCKET_EINPROGRESS);
361   if(result == 0)
362   {
363     inf_tcp_connection_connected(connection);
364   }
365   else
366   {
367     g_assert(priv-&gt;watch == NULL);
368     priv-&gt;events = INF_IO_OUTGOING | INF_IO_ERROR;
369     priv-&gt;watch = inf_io_add_watch(
370       priv-&gt;io,
371       &amp;priv-&gt;socket,
372       priv-&gt;events,
373       inf_tcp_connection_io,
374       connection,
375       NULL
376     );
377     if(priv-&gt;status != INF_TCP_CONNECTION_CONNECTING)
378     {
379       priv-&gt;status = INF_TCP_CONNECTION_CONNECTING;
380       g_object_notify(G_OBJECT(connection), "status");
381     }
382   }
383   return TRUE;
384 }
385 static gboolean
386 inf_tcp_connection_open_with_resolver(InfTcpConnection* connection,
387                                       GError** error)
388 {
389   InfTcpConnectionPrivate* priv;
390   GError* local_error;
391   gboolean success;
392   priv = INF_TCP_CONNECTION_PRIVATE(connection);
393   g_assert(priv-&gt;status == INF_TCP_CONNECTION_CLOSED ||
394            priv-&gt;status == INF_TCP_CONNECTION_CONNECTING);
395   if(inf_name_resolver_finished(priv-&gt;resolver))
396   {
397     if(priv-&gt;resolver_index &lt; 
398        inf_name_resolver_get_n_addresses(priv-&gt;resolver))
399     {
400       return inf_tcp_connection_open_real(
401         connection,
402         inf_name_resolver_get_address(priv-&gt;resolver, priv-&gt;resolver_index),
403         inf_name_resolver_get_port(priv-&gt;resolver, priv-&gt;resolver_index),
404         error
405       );
406     }
407     g_object_freeze_notify(G_OBJECT(connection));
408     if(priv-&gt;status != INF_TCP_CONNECTION_CONNECTING)
409     {
410       priv-&gt;status = INF_TCP_CONNECTION_CONNECTING;
411       g_object_notify(G_OBJECT(connection), "status");
412     }
413     local_error = NULL;
414     if(priv-&gt;resolver_index == 0)
415       success = inf_name_resolver_start(priv-&gt;resolver, &amp;local_error);
416     else
417       success = inf_name_resolver_lookup_backup(priv-&gt;resolver, &amp;local_error);
418     if(local_error != NULL)
419     {
420       inf_tcp_connection_connection_error(connection, local_error);
421       g_propagate_error(error, local_error);
422     }
423     g_object_thaw_notify(G_OBJECT(connection));
424     return success;
425   }
426   return TRUE;
427 }
428 static gboolean
429 inf_tcp_connection_send_real(InfTcpConnection* connection,
430                              gconstpointer data,
431                              guint* len)
432 {
433   InfTcpConnectionPrivate* priv;
434   gconstpointer send_data;
435   guint send_len;
436   int errcode;
437   ssize_t result;
438   priv = INF_TCP_CONNECTION_PRIVATE(connection);
439   g_assert(priv-&gt;status == INF_TCP_CONNECTION_CONNECTED);
440   g_assert(data != NULL);
441   g_assert(len != NULL);
442   send_data = data;
443   send_len = *len;
444   do
445   {
446     result = send(
447       priv-&gt;socket,
448       send_data,
449       send_len,
450       INF_NATIVE_SOCKET_SENDRECV_FLAGS
451     );
452     errcode = INF_NATIVE_SOCKET_LAST_ERROR;
453     if(result &lt; 0 &amp;&amp;
454        errcode != INF_NATIVE_SOCKET_EINTR &amp;&amp;
455        errcode != INF_NATIVE_SOCKET_EAGAIN)
456     {
457       inf_tcp_connection_system_error(connection, errcode);
458       return FALSE;
459     }
460     else if(result == 0)
461     {
462       inf_tcp_connection_close(connection);
463       return FALSE;
464     }
465     else if(result &gt; 0)
466     {
467       send_data = (const char*)send_data + result;
468       send_len -= result;
469     }
470   } while( (send_len &gt; 0) &amp;&amp;
471            (result &gt; 0 || errcode == INF_NATIVE_SOCKET_EINTR) &amp;&amp;
472            (priv-&gt;socket != INVALID_SOCKET) );
473   *len -= send_len;
474   return TRUE;
475 }
476 static void
477 inf_tcp_connection_io_incoming(InfTcpConnection* connection)
478 {
479   InfTcpConnectionPrivate* priv;
480   gchar buf[2048];
481   int errcode;
482   ssize_t result;
483   priv = INF_TCP_CONNECTION_PRIVATE(connection);
484   g_assert(priv-&gt;status == INF_TCP_CONNECTION_CONNECTED);
485   do
486   {
487     result = recv(priv-&gt;socket, buf, 2048, INF_NATIVE_SOCKET_SENDRECV_FLAGS);
488     errcode = INF_NATIVE_SOCKET_LAST_ERROR;
489     if(result &lt; 0 &amp;&amp;
490        errcode != INF_NATIVE_SOCKET_EINTR &amp;&amp;
491        errcode != INF_NATIVE_SOCKET_EAGAIN)
492     {
493       inf_tcp_connection_system_error(connection, errcode);
494     }
495     else if(result == 0)
496     {
497       inf_tcp_connection_close(connection);
498     }
499     else if(result &gt; 0)
500     {
501       g_signal_emit(
502         G_OBJECT(connection),
503         tcp_connection_signals[RECEIVED],
504         0,
505         buf,
506         (guint)result
507       );
508     }
509   } while( ((result &gt; 0) ||
510             (result &lt; 0 &amp;&amp; errcode == INF_NATIVE_SOCKET_EINTR)) &amp;&amp;
511            (priv-&gt;status != INF_TCP_CONNECTION_CLOSED));
512 }
513 static void
514 inf_tcp_connection_io_outgoing(InfTcpConnection* connection)
515 {
516   InfTcpConnectionPrivate* priv;
517   socklen_t len;
518   int errcode;
519   gconstpointer data;
520   guint data_len;
521   priv = INF_TCP_CONNECTION_PRIVATE(connection);
522   switch(priv-&gt;status)
523   {
524   case INF_TCP_CONNECTION_CONNECTING:
525     len = sizeof(int);
526 #ifdef G_OS_WIN32
527     getsockopt(priv-&gt;socket, SOL_SOCKET, SO_ERROR, (char*)&amp;errcode, &amp;len);
528 #else
529     getsockopt(priv-&gt;socket, SOL_SOCKET, SO_ERROR, &amp;errcode, &amp;len);
530 #endif
531     if(errcode == 0)
532     {
533       inf_tcp_connection_connected(connection);
534     }
535     else
536     {
537       inf_tcp_connection_system_error(connection, errcode);
538     }
539     break;
540   case INF_TCP_CONNECTION_CONNECTED:
541     g_assert(priv-&gt;back_pos &lt; priv-&gt;front_pos);
542     g_assert(priv-&gt;events &amp; INF_IO_OUTGOING);
543     data = priv-&gt;queue + priv-&gt;back_pos;
544     data_len = priv-&gt;front_pos - priv-&gt;back_pos;
545     if(inf_tcp_connection_send_real(connection, data, &amp;data_len) == TRUE)
546     {
547       priv-&gt;back_pos += data_len;
548       if(priv-&gt;front_pos == priv-&gt;back_pos)
549       {
550         priv-&gt;front_pos = 0;
551         priv-&gt;back_pos = 0;
552         priv-&gt;events &amp;= ~INF_IO_OUTGOING;
553         inf_io_update_watch(priv-&gt;io, priv-&gt;watch, priv-&gt;events);
554       }
555       g_signal_emit(
556         G_OBJECT(connection),
557         tcp_connection_signals[SENT],
558         0,
559         data,
560         data_len
561       );
562     }
563     break;
564   case INF_TCP_CONNECTION_CLOSED:
565   default:
566     g_assert_not_reached();
567     break;
568   }
569 }
570 static void
571 inf_tcp_connection_io(InfNativeSocket* socket,
572                       InfIoEvent events,
573                       gpointer user_data)
574 {
575   InfTcpConnection* connection;
576   InfTcpConnectionPrivate* priv;
577   socklen_t len;
578   int errcode;
579   GError* error;
580   connection = INF_TCP_CONNECTION(user_data);
581   priv = INF_TCP_CONNECTION_PRIVATE(connection);
582   g_object_ref(G_OBJECT(connection));
583   g_assert(priv-&gt;status != INF_TCP_CONNECTION_CLOSED);
584   if(events &amp; INF_IO_ERROR)
585   {
586     len = sizeof(int);
587 #ifdef G_OS_WIN32
588     getsockopt(priv-&gt;socket, SOL_SOCKET, SO_ERROR, (char*)&amp;errcode, &amp;len);
589 #else
590     getsockopt(priv-&gt;socket, SOL_SOCKET, SO_ERROR, &amp;errcode, &amp;len);
591 #endif
592     if(errcode != 0)
593     {
594       error = NULL;
595       inf_native_socket_make_error(errcode, &amp;error);
596       if(priv-&gt;status == INF_TCP_CONNECTION_CONNECTING)
597       {
598         inf_tcp_connection_connection_error(connection, error);
599       }
600       else
601       {
602         g_signal_emit(
603           G_OBJECT(connection),
604           tcp_connection_signals[ERROR_],
605           0,
606           error
607         );
608       }
609       g_error_free(error);
610     }
611     else
612     {
613       inf_tcp_connection_close(connection);
614     }
615   }
616   else
617   {
618     if(events &amp; INF_IO_INCOMING)
619     {
620       inf_tcp_connection_io_incoming(connection);
621     }
622     if((priv-&gt;status != INF_TCP_CONNECTION_CLOSED) &amp;&amp;
623        (events &amp; INF_IO_OUTGOING))
624     {
625       inf_tcp_connection_io_outgoing(connection);
626     }
627   }
628   g_object_unref(G_OBJECT(connection));
629 }
630 static void
631 inf_tcp_connection_resolved_cb(InfNameResolver* resolver,
632                                const GError* error,
633                                gpointer user_data)
634 {
635   InfTcpConnection* connection;
636   InfTcpConnectionPrivate* priv;
637   connection = INF_TCP_CONNECTION(user_data);
638   priv = INF_TCP_CONNECTION_PRIVATE(connection);
639   if(priv-&gt;status == INF_TCP_CONNECTION_CONNECTING)
640   {
641     if(error != NULL)
642     {
643       g_assert(
644         priv-&gt;resolver_index == inf_name_resolver_get_n_addresses(resolver)
645       );
646       inf_tcp_connection_connection_error(connection, error);
647     }
648     else
649     {
650       inf_tcp_connection_open_with_resolver(connection, NULL);
651     }
652 <font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>  }
653 }
654 static void
655 inf_tcp_connection_set_resolver(InfTcpConnection* connection,
656                                 InfNameResolver* resolver)
657 {
658   InfTcpConnectionPrivate* priv;
659   priv = INF_TCP_CONNECTION_PRIVATE(connection);
660   if(priv-&gt;resolver != NULL)
661   {
662     inf_signal_handlers_disconnect_by_func(
663       G_OBJECT(priv-&gt;resolver),
664       G_CALLBACK(inf_tcp_connection_resolved_cb),
665       connection
666     );
667     g_object_unref(priv-&gt;resolver);
668   }
669   priv-&gt;resolver = resolver;
670   if(resolver != NULL)
671   {
672     g_object_ref(resolver);
673     g_signal_connect(
674       G_OBJECT(resolver),
675       "resolved",
676       G_CALLBACK(inf_tcp_connection_resolved_cb),
677       connection
678     );
679   }
680 }
681 static void
682 inf_tcp_connection_init(InfTcpConnection* connection)
683 {
684   InfTcpConnectionPrivate* priv;
685   priv = INF_TCP_CONNECTION_PRIVATE(connection);
686   priv-&gt;io = NULL;
687   priv-&gt;events = 0;</b></font>
688   priv-&gt;watch = NULL;
689   priv-&gt;resolver = NULL;
690   priv-&gt;resolver_index = 0;
691   priv-&gt;status = INF_TCP_CONNECTION_CLOSED;
692   priv-&gt;socket = INVALID_SOCKET;
693   priv-&gt;keepalive.mask = 0;
694   priv-&gt;remote_address = NULL;
695   priv-&gt;remote_port = 0;
696   priv-&gt;device_index = 0;
697   priv-&gt;queue = g_malloc(1024);
698   priv-&gt;front_pos = 0;
699   priv-&gt;back_pos = 0;
700   priv-&gt;alloc = 1024;
701 }
702 static void
703 inf_tcp_connection_dispose(GObject* object)
704 {
705   InfTcpConnection* connection;
706   InfTcpConnectionPrivate* priv;
707   connection = INF_TCP_CONNECTION(object);
708   priv = INF_TCP_CONNECTION_PRIVATE(connection);
709   if(priv-&gt;status != INF_TCP_CONNECTION_CLOSED)
710     inf_tcp_connection_close(connection);
711   inf_tcp_connection_set_resolver(connection, NULL);
712   if(priv-&gt;io != NULL)
713   {
714     g_object_unref(priv-&gt;io);
715     priv-&gt;io = NULL;
716   }
717   G_OBJECT_CLASS(inf_tcp_connection_parent_class)-&gt;dispose(object);
718 }
719 static void
720 inf_tcp_connection_finalize(GObject* object)
721 {
722   InfTcpConnection* connection;
723   InfTcpConnectionPrivate* priv;
724   connection = INF_TCP_CONNECTION(object);
725   priv = INF_TCP_CONNECTION_PRIVATE(connection);
726   if(priv-&gt;remote_address != NULL)
727     inf_ip_address_free(priv-&gt;remote_address);
728   if(priv-&gt;socket != INVALID_SOCKET)
729     closesocket(priv-&gt;socket);
730   g_free(priv-&gt;queue);
731   G_OBJECT_CLASS(inf_tcp_connection_parent_class)-&gt;finalize(object);
732 }
733 static void
734 inf_tcp_connection_set_property(GObject* object,
735                                 guint prop_id,
736                                 const GValue* value,
737                                 GParamSpec* pspec)
738 {
739   InfTcpConnection* connection;
740   InfTcpConnectionPrivate* priv;
741 #ifndef G_OS_WIN32
742   const gchar* device_string;
743   unsigned int new_index;
744 #endif
745   GError* error;
746   connection = INF_TCP_CONNECTION(object);
747   priv = INF_TCP_CONNECTION_PRIVATE(connection);
748   switch(prop_id)
749   {
750   case PROP_IO:
751     g_assert(priv-&gt;status == INF_TCP_CONNECTION_CLOSED);
752     if(priv-&gt;io != NULL) g_object_unref(G_OBJECT(priv-&gt;io));
753     priv-&gt;io = INF_IO(g_value_dup_object(value));
754     break;
755   case PROP_RESOLVER:
756     g_assert(priv-&gt;status == INF_TCP_CONNECTION_CLOSED);
757     inf_tcp_connection_set_resolver(
758       connection,
759       INF_NAME_RESOLVER(g_value_get_object(value))
760     );
761     break;
762   case PROP_KEEPALIVE:
763     error = NULL;
764     inf_tcp_connection_set_keepalive(
765       connection,
766       (InfKeepalive*)g_value_get_boxed(value),
767       &amp;error
768     );
769     if(error != NULL)
770     {
771       g_warning("Failed to set keepalive settings: %s\n", error-&gt;message);
772       g_error_free(error);
773     }
774     break;
775   case PROP_REMOTE_ADDRESS:
776     g_assert(priv-&gt;status == INF_TCP_CONNECTION_CLOSED);
777     if(priv-&gt;remote_address != NULL)
778       inf_ip_address_free(priv-&gt;remote_address);
779     priv-&gt;remote_address = (InfIpAddress*)g_value_dup_boxed(value);
780     break;
781   case PROP_REMOTE_PORT:
782     g_assert(priv-&gt;status == INF_TCP_CONNECTION_CLOSED);
783     priv-&gt;remote_port = g_value_get_uint(value);
784     break;
785   case PROP_DEVICE_INDEX:
786     g_assert(priv-&gt;status == INF_TCP_CONNECTION_CLOSED);
787     priv-&gt;device_index = g_value_get_uint(value);
788     g_object_notify(G_OBJECT(object), "device-name");
789     break;
790   case PROP_DEVICE_NAME:
791 #ifdef G_OS_WIN32
792     g_warning("The device-name property is not implemented on Win32");
793 #else
794     g_assert(priv-&gt;status == INF_TCP_CONNECTION_CLOSED);
795     device_string = g_value_get_string(value);
796     if(device_string == NULL) priv-&gt;device_index = 0;
797     new_index = if_nametoindex(device_string);
798     if(new_index == 0)
799     {
800       g_warning(_("Interface `%s' does not exist"), device_string);
801     }
802     else
803     {
804       priv-&gt;device_index = new_index;
805       g_object_notify(G_OBJECT(object), "device-index");
806     }
807 #endif
808     break;
809   default:
810     G_OBJECT_WARN_INVALID_PROPERTY_ID(object, prop_id, pspec);
811     break;
812   }
813 }
814 static void
815 inf_tcp_connection_get_property(GObject* object,
816                                 guint prop_id,
817                                 GValue* value,
818                                 GParamSpec* pspec)
819 {
820   InfTcpConnection* connection;
821   InfTcpConnectionPrivate* priv;
822   InfIpAddress* address;
823   guint port;
824   GError* error;
825 #ifndef G_OS_WIN32
826 <a name="1"></a>  char device_name[IF_NAMESIZE];
827 #endif
828 <font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>  connection = INF_TCP_CONNECTION(object);
829   priv = INF_TCP_CONNECTION_PRIVATE(connection);
830   switch(prop_id)
831   {
832   case PROP_IO:
833     g_value_set_object(value, G_OBJECT(priv-&gt;io));
834     break;
835   case PROP_RESOLVER:
836     g_value_set_object(value, G_OBJECT(priv-&gt;resolver));
837     break;
838   case PROP_KEEPALIVE:
839     g_value_set_boxed(value, &amp;priv-&gt;keepalive);
840     break;
841   case PROP_STATUS:
842     g_value_set_enum(value, priv-&gt;status);
843     break;
844   case PROP_REMOTE_ADDRESS:
845     g_value_set_static_boxed(value, priv-&gt;remote_address);
846     break;
847   case PROP_REMOTE_PORT:
848     g_value_set_uint(value, priv-&gt;remote_port);
849     break;
850   case PROP_LOCAL_ADDRESS:</b></font>
851     g_assert(priv-&gt;socket != INVALID_SOCKET);
852     error = NULL;
853     inf_tcp_connection_addr_info(priv-&gt;socket, TRUE, &amp;address, NULL, &amp;error);
854     if(error != NULL)
855     {
856       g_warning(_("Failed to retrieve local address: %s"), error-&gt;message);
857       g_error_free(error);
858       g_value_set_boxed(value, NULL);
859     }
860     else
861     {
862       g_value_take_boxed(value, address);
863     }
864     break;
865   case PROP_LOCAL_PORT:
866     g_assert(priv-&gt;socket != INVALID_SOCKET);
867     error = NULL;
868     inf_tcp_connection_addr_info(priv-&gt;socket, TRUE, NULL, &amp;port, &amp;error);
869     if(error != NULL)
870     {
871       g_warning(_("Failed to retrieve local port: %s"), error-&gt;message);
872       g_error_free(error);
873       g_value_set_uint(value, 0);
874     }
875     else
876     {
877       g_value_set_uint(value, port);
878     }
879     break;
880   case PROP_DEVICE_INDEX:
881     g_value_set_uint(value, priv-&gt;device_index);
882     break;
883   case PROP_DEVICE_NAME:
884 #ifdef G_OS_WIN32
885     g_warning(_("The device-name property is not implemented on Win32"));
886     g_value_set_string(value, NULL);
887 #else
888     if(priv-&gt;device_index == 0)
889     {
890       g_value_set_string(value, NULL);
891     }
892     else
893     {
894       if(if_indextoname(priv-&gt;device_index, device_name) == NULL)
895       {
896         g_warning(
897           _("Failed to get name for device %u: %s"),
898           priv-&gt;device_index,
899           strerror(errno)
900         );
901         g_value_set_string(value, NULL);
902       }
903       else
904       {
905         g_value_set_string(value, device_name);
906       }
907     }
908 #endif
909     break;
910   default:
911     G_OBJECT_WARN_INVALID_PROPERTY_ID(object, prop_id, pspec);
912     break;
913   }
914 }
915 static void
916 inf_tcp_connection_error(InfTcpConnection* connection,
917                          GError* error)
918 {
919   InfTcpConnectionPrivate* priv;
920   priv = INF_TCP_CONNECTION_PRIVATE(connection);
921   if(priv-&gt;watch != NULL)
922   {
923     priv-&gt;events = 0;
924     inf_io_remove_watch(priv-&gt;io, priv-&gt;watch);
925     priv-&gt;watch = NULL;
926   }
927   if(priv-&gt;status != INF_TCP_CONNECTION_CLOSED)
928   {
929 <a name="2"></a>    priv-&gt;status = INF_TCP_CONNECTION_CLOSED;
930     g_object_notify(G_OBJECT(connection), "status");
931   }
932 <font color="#980517"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>}
933 static void
934 inf_tcp_connection_class_init(InfTcpConnectionClass* tcp_connection_class)
935 {
936   GObjectClass* object_class;
937   object_class = G_OBJECT_CLASS(tcp_connection_class);
938   object_class-&gt;dispose = inf_tcp_connection_dispose;
939   object_class-&gt;finalize = inf_tcp_connection_finalize;
940   object_class-&gt;set_property = inf_tcp_connection_set_property;
941   object_class-&gt;get_property = inf_tcp_connection_get_property;
942   tcp_connection_class-&gt;sent = NULL;
943   tcp_connection_class-&gt;received = NULL;</b></font>
944   tcp_connection_class-&gt;error = inf_tcp_connection_error;
945   g_object_class_install_property(
946     object_class,
947     PROP_IO,
948     g_param_spec_object(
949       "io",
950       "IO",
951       "I/O handler",
952       INF_TYPE_IO,
953       G_PARAM_READWRITE | G_PARAM_CONSTRUCT_ONLY
954     )
955   );
956   g_object_class_install_property(
957     object_class,
958     PROP_RESOLVER,
959     g_param_spec_object(
960       "resolver",
961       "Resolver",
962       "The hostname resolver",
963       INF_TYPE_NAME_RESOLVER,
964       G_PARAM_READWRITE | G_PARAM_CONSTRUCT
965     )
966   );
967   g_object_class_install_property(
968     object_class,
969     PROP_STATUS,
970     g_param_spec_enum(
971       "status",
972       "Status",
973       "Status of the TCP connection",
974       INF_TYPE_TCP_CONNECTION_STATUS,
975       INF_TCP_CONNECTION_CLOSED,
976       G_PARAM_READABLE
977     )
978   );
979   g_object_class_install_property(
980     object_class,
981     PROP_KEEPALIVE,
982     g_param_spec_boxed(
983       "keepalive",
984       "Keepalive",
985       "The keepalive settings for the connection",
986       INF_TYPE_KEEPALIVE,
987       G_PARAM_READWRITE
988     )
989   );
990   g_object_class_install_property(
991     object_class,
992     PROP_REMOTE_ADDRESS,
993     g_param_spec_boxed(
994       "remote-address",
995       "Remote address",
996       "Address to connect to",
997       INF_TYPE_IP_ADDRESS,
998       G_PARAM_READWRITE
999     )
1000   );
1001   g_object_class_install_property(
1002     object_class,
1003     PROP_REMOTE_PORT,
1004     g_param_spec_uint(
1005       "remote-port",
1006       "Remote port",
1007       "Port to connect to",
1008       0,
1009       65535,
1010       0,
1011       G_PARAM_READWRITE
1012     )
1013   );
1014   g_object_class_install_property(
1015     object_class,
1016     PROP_LOCAL_ADDRESS,
1017     g_param_spec_boxed(
1018       "local-address",
1019       "Local address",
1020       "The local address of the connection",
1021       INF_TYPE_IP_ADDRESS,
1022       G_PARAM_READABLE
1023     )
1024   );
1025   g_object_class_install_property(
1026     object_class,
1027     PROP_LOCAL_PORT,
1028     g_param_spec_uint(
1029       "local-port",
1030       "Local port",
1031       "The local port of the connection",
1032       0,
1033       65535,
1034       0,
1035       G_PARAM_READABLE
1036     )
1037   );
1038   g_object_class_install_property(
1039     object_class,
1040     PROP_DEVICE_INDEX,
1041     g_param_spec_uint(
1042       "device-index",
1043       "Device index",
1044       "The index of the device to use for the connection",
1045       0,
1046       G_MAXUINT,
1047       0,
1048       G_PARAM_READWRITE
1049     )
1050   );
1051   g_object_class_install_property(
1052     object_class,
1053     PROP_DEVICE_NAME,
1054     g_param_spec_string(
1055       "device-name",
1056       "Device name",
1057       "The name of the device to use for the connection, such as `eth0'",
1058       NULL,
1059       G_PARAM_READWRITE
1060     )
1061   );
1062   tcp_connection_signals[SENT] = g_signal_new(
1063     "sent",
1064     G_OBJECT_CLASS_TYPE(object_class),
1065     G_SIGNAL_RUN_LAST,
1066     G_STRUCT_OFFSET(InfTcpConnectionClass, sent),
1067     NULL, NULL,
1068     NULL,
1069     G_TYPE_NONE,
1070     2,
1071     G_TYPE_POINTER,
1072     G_TYPE_UINT
1073   );
1074   tcp_connection_signals[RECEIVED] = g_signal_new(
1075     "received",
1076     G_OBJECT_CLASS_TYPE(object_class),
1077     G_SIGNAL_RUN_LAST,
1078     G_STRUCT_OFFSET(InfTcpConnectionClass, received),
1079     NULL, NULL,
1080     NULL,
1081     G_TYPE_NONE,
1082     2,
1083     G_TYPE_POINTER,
1084     G_TYPE_UINT
1085   );
1086   tcp_connection_signals[ERROR_] = g_signal_new(
1087     "error",
1088     G_OBJECT_CLASS_TYPE(object_class),
1089     G_SIGNAL_RUN_LAST,
1090     G_STRUCT_OFFSET(InfTcpConnectionClass, error),
1091     NULL, NULL,
1092     g_cclosure_marshal_VOID__POINTER,
1093     G_TYPE_NONE,
1094     1,
1095     G_TYPE_ERROR
1096   );
1097 }
1098 InfTcpConnection*
1099 inf_tcp_connection_new(InfIo* io,
1100                        const InfIpAddress* remote_addr,
1101                        guint remote_port)
1102 {
1103   InfTcpConnection* tcp;
1104   g_return_val_if_fail(INF_IS_IO(io), NULL);
1105   g_return_val_if_fail(remote_addr != NULL, NULL);
1106   g_return_val_if_fail(remote_port &lt;= 65535, NULL);
1107   tcp = INF_TCP_CONNECTION(
1108     g_object_new(
1109       INF_TYPE_TCP_CONNECTION,
1110       "io", io,
1111       "remote-address", remote_addr,
1112       "remote-port", remote_port,
1113       NULL
1114     )
1115   );
1116   return tcp;
1117 }
1118 InfTcpConnection*
1119 inf_tcp_connection_new_and_open(InfIo* io,
1120                                 const InfIpAddress* remote_addr,
1121                                 guint remote_port,
1122                                 GError** error)
1123 {
1124   InfTcpConnection* tcp;
1125   g_return_val_if_fail(INF_IS_IO(io), NULL);
1126   g_return_val_if_fail(remote_addr != NULL, NULL);
1127   g_return_val_if_fail(remote_port &lt;= 65535, NULL);
1128   g_return_val_if_fail(error == NULL || *error == NULL, NULL);
1129   tcp = inf_tcp_connection_new(io, remote_addr, remote_port);
1130   if(inf_tcp_connection_open(tcp, error) == FALSE)
1131   {
1132     g_object_unref(tcp);
1133     return NULL;
1134   }
1135   return tcp;
1136 }
1137 InfTcpConnection*
1138 inf_tcp_connection_new_resolve(InfIo* io,
1139                                InfNameResolver* resolver)
1140 {
1141   InfTcpConnection* tcp;
1142   g_return_val_if_fail(INF_IS_IO(io), NULL);
1143   g_return_val_if_fail(INF_IS_NAME_RESOLVER(resolver), NULL);
1144   tcp = INF_TCP_CONNECTION(
1145     g_object_new(
1146       INF_TYPE_TCP_CONNECTION,
1147       "io", io,
1148       "resolver", resolver,
1149       NULL
1150     )
1151   );
1152   return tcp;
1153 }
1154 gboolean
1155 inf_tcp_connection_open(InfTcpConnection* connection,
1156                         GError** error)
1157 {
1158   InfTcpConnectionPrivate* priv;
1159   g_return_val_if_fail(INF_IS_TCP_CONNECTION(connection), FALSE);
1160   priv = INF_TCP_CONNECTION_PRIVATE(connection);
1161   g_return_val_if_fail(priv-&gt;io != NULL, FALSE);
1162   g_return_val_if_fail(priv-&gt;status == INF_TCP_CONNECTION_CLOSED, FALSE);
1163   g_return_val_if_fail(
1164     priv-&gt;remote_address != NULL || priv-&gt;resolver != NULL,
1165     FALSE
1166   );
1167   g_return_val_if_fail(
1168     priv-&gt;remote_port != 0 ||
1169     priv-&gt;resolver != NULL,
1170     FALSE
1171   );
1172   if(priv-&gt;resolver != NULL)
1173   {
1174     g_assert(priv-&gt;resolver_index == 0);
1175     return inf_tcp_connection_open_with_resolver(connection, error);
1176   }
1177   else
1178   {
1179     return inf_tcp_connection_open_real(
1180       connection,
1181       priv-&gt;remote_address,
1182       priv-&gt;remote_port,
1183       error
1184     );
1185   }
1186 }
1187 void
1188 inf_tcp_connection_close(InfTcpConnection* connection)
1189 {
1190   InfTcpConnectionPrivate* priv;
1191   g_return_if_fail(INF_IS_TCP_CONNECTION(connection));
1192   priv = INF_TCP_CONNECTION_PRIVATE(connection);
1193   g_return_if_fail(priv-&gt;status != INF_TCP_CONNECTION_CLOSED);
1194   priv-&gt;events = 0;
1195   if(priv-&gt;watch != NULL)
1196   {
1197     inf_io_remove_watch(priv-&gt;io, priv-&gt;watch);
1198     priv-&gt;watch = NULL;
1199   }
1200   priv-&gt;front_pos = 0;
1201   priv-&gt;back_pos = 0;
1202   priv-&gt;status = INF_TCP_CONNECTION_CLOSED;
1203   g_object_notify(G_OBJECT(connection), "status");
1204 }
1205 void
1206 inf_tcp_connection_send(InfTcpConnection* connection,
1207                         gconstpointer data,
1208                         guint len)
1209 {
1210   InfTcpConnectionPrivate* priv;
1211   gconstpointer sent_data;
1212   guint sent_len;
1213   g_return_if_fail(INF_IS_TCP_CONNECTION(connection));
1214   g_return_if_fail(len == 0 || data != NULL);
1215   priv = INF_TCP_CONNECTION_PRIVATE(connection);
1216   g_return_if_fail(priv-&gt;status == INF_TCP_CONNECTION_CONNECTED);
1217   g_object_ref(connection);
1218   if(priv-&gt;front_pos == priv-&gt;back_pos)
1219   {
1220     g_assert(~priv-&gt;events &amp; INF_IO_OUTGOING);
1221     sent_len = len;
1222     sent_data = data;
1223     if(inf_tcp_connection_send_real(connection, data, &amp;sent_len) == TRUE)
1224     {
1225       data = (const char*)data + sent_len;
1226       len -= sent_len;
1227     }
1228     else
1229     {
1230       len = 0;
1231       sent_len = 0;
1232     }
1233   }
1234   else
1235   {
1236     sent_len = 0;
1237   }
1238   if(len &gt; 0)
1239   {
1240     if(priv-&gt;alloc - priv-&gt;front_pos &lt; len &amp;&amp; priv-&gt;back_pos &gt; 0)
1241     {
1242       memmove(
1243         priv-&gt;queue,
1244         priv-&gt;queue + priv-&gt;back_pos,
1245         priv-&gt;front_pos - priv-&gt;back_pos
1246       );
1247       priv-&gt;front_pos -= priv-&gt;back_pos;
1248       priv-&gt;back_pos = 0;
1249     }
1250     if(priv-&gt;alloc - priv-&gt;front_pos &lt; len)
1251     {
1252       priv-&gt;alloc = priv-&gt;front_pos + len;
1253       if(priv-&gt;alloc % 1024 != 0)
1254         priv-&gt;alloc = priv-&gt;alloc + (1024 - priv-&gt;alloc % 1024);
1255       priv-&gt;queue = g_realloc(priv-&gt;queue, priv-&gt;alloc);
1256     }
1257     memcpy(priv-&gt;queue + priv-&gt;front_pos, data, len);
1258     priv-&gt;front_pos += len;
1259     if(~priv-&gt;events &amp; INF_IO_OUTGOING)
1260     {
1261       priv-&gt;events |= INF_IO_OUTGOING;
1262       inf_io_update_watch(priv-&gt;io, priv-&gt;watch, priv-&gt;events);
1263     }
1264   }
1265   if(sent_len &gt; 0)
1266   {
1267     g_signal_emit(
1268       G_OBJECT(connection),
1269       tcp_connection_signals[SENT],
1270       0,
1271       sent_data,
1272       sent_len
1273     );
1274   }
1275   g_object_unref(connection);
1276 }
1277 InfIpAddress*
1278 inf_tcp_connection_get_remote_address(InfTcpConnection* connection)
1279 {
1280   g_return_val_if_fail(INF_IS_TCP_CONNECTION(connection), NULL);
1281   return INF_TCP_CONNECTION_PRIVATE(connection)-&gt;remote_address;
1282 }
1283 guint
1284 inf_tcp_connection_get_remote_port(InfTcpConnection* connection)
1285 {
1286   g_return_val_if_fail(INF_IS_TCP_CONNECTION(connection), 0);
1287   return INF_TCP_CONNECTION_PRIVATE(connection)-&gt;remote_port;
1288 }
1289 gboolean
1290 inf_tcp_connection_set_keepalive(InfTcpConnection* connection,
1291                                  const InfKeepalive* keepalive,
1292                                  GError** error)
1293 {
1294   InfTcpConnectionPrivate* priv;
1295   InfKeepaliveMask mask;
1296   g_return_val_if_fail(INF_IS_TCP_CONNECTION(connection), FALSE);
1297   g_return_val_if_fail(keepalive != NULL, FALSE);
1298   g_return_val_if_fail(error == NULL || *error == NULL, FALSE);
1299   priv = INF_TCP_CONNECTION_PRIVATE(connection);
1300   if(priv-&gt;socket != INVALID_SOCKET)
1301   {
1302     mask = priv-&gt;keepalive.mask;
1303     if(inf_keepalive_apply(keepalive, &amp;priv-&gt;socket, mask, error) != TRUE)
1304       return FALSE;
1305   }
1306   priv-&gt;keepalive = *keepalive;
1307   return TRUE;
1308 }
1309 const InfKeepalive*
1310 inf_tcp_connection_get_keepalive(InfTcpConnection* connection)
1311 {
1312   g_return_val_if_fail(INF_IS_TCP_CONNECTION(connection), NULL);
1313   return &amp;INF_TCP_CONNECTION_PRIVATE(connection)-&gt;keepalive;
1314 }
1315 InfTcpConnection*
1316 _inf_tcp_connection_accepted(InfIo* io,
1317                              InfNativeSocket socket,
1318                              InfIpAddress* address,
1319                              guint port,
1320                              const InfKeepalive* keepalive,
1321                              GError** error)
1322 {
1323   InfTcpConnection* connection;
1324   InfTcpConnectionPrivate* priv;
1325   int errcode;
1326   g_return_val_if_fail(INF_IS_IO(io), NULL);
1327   g_return_val_if_fail(socket != INVALID_SOCKET, NULL);
1328   g_return_val_if_fail(address != NULL, NULL);
1329   g_return_val_if_fail(keepalive != NULL, NULL);
1330   if(inf_tcp_connection_configure_socket(socket, keepalive, error) != TRUE)
1331     return NULL;
1332   g_return_val_if_fail(address != NULL, NULL);
1333   g_return_val_if_fail(port != 0, NULL);
1334   connection = inf_tcp_connection_new(io, address, port);
1335   inf_ip_address_free(address);
1336   priv = INF_TCP_CONNECTION_PRIVATE(connection);
1337   priv-&gt;socket = socket;
1338   priv-&gt;keepalive = *keepalive;
1339   inf_tcp_connection_connected(connection);
1340   return connection;
1341 }
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
