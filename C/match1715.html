<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html><head><title>Matches for inf-text-gtk-view.c &amp; inf-tcp-connection.c</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for inf-text-gtk-view.c &amp; inf-tcp-connection.c
      </h3>
<h1 align="center">
        6.3%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>inf-text-gtk-view.c (6.3492064%)<th>inf-tcp-connection.c (6.3414636%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(1575-1647)<td><a href="#" name="0">(858-901)</a><td align="center"><font color="#ff0000">23</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(1760-1783)<td><a href="#" name="1">(1069-1092)</a><td align="center"><font color="#bc0000">17</font>
<tr onclick='openModal("#980517")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#980517"><font color="#980517">-</font><td><a href="#" name="2">(1314-1330)<td><a href="#" name="2">(1190-1204)</a><td align="center"><font color="#850000">12</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>inf-text-gtk-view.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
/* infinote - Collaborative notetaking application
 * Copyright (C) 2007-2015 Armin Burgmeier &lt;armin@arbur.net&gt;
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free
 * Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
 */

/**
 * SECTION:inf-text-gtk-view
 * @title: InfTextGtkView
 * @short_description: Drawing remote cursors and selections in a #GtkTextView
 * @include: libinftextgtk/inf-text-gtk-view.h
 * @see_also: #InfTextGtkBuffer, #InfTextGtkViewport
 * @stability: Unstable
 *
 * #InfTextGtkView is a helper object which, as long as it is alive, draws
 * the cursor position, selected text of remote users into a #GtkTextView
 * widget. It can also highlight the current line of a remote user in a
 * similar way the #GtkSourceView widget can highlight the current line of
 * the local user.
 *
 * This functionality was not implemented by subclassing #GtkTextView such
 * that it can also be used with existing subclasses, such as #GtkSourceView.
 *
 * With the function inf_text_gtk_view_set_active_user() the local
 * #InfTextUser who is editing the text can be set, if there is any. The
 * insertion position, seleceted text or current line are not drawn for this
 * user, since the normal #GtkTextView takes care of that already. This
 * assumes the local user cursor position and selection is synchronized to the
 * corresponding #InfTextUser properties, which is automatically the case when
 * a #InfTextGtkBuffer is used for the buffer the #GtkTextView is displaying.
 *
 * See #InfTextGtkViewport for drawing a marker at remote users' location into
 * the scrollbar.
 */	

#include &lt;libinftextgtk/inf-text-gtk-view.h&gt;
#include &lt;libinfinity/inf-signals.h&gt;
#include &lt;gdk/gdk.h&gt;

typedef struct _InfTextGtkViewUser InfTextGtkViewUser;
struct _InfTextGtkViewUser {
  InfTextGtkView* view;
  InfTextUser* user;
  gboolean cursor_visible;
  InfIoTimeout* timeout; /* TODO: Use glib for that; remove InfIo property */
  guint revalidate_idle;

  /* All in buffer coordinates: */

  /* The rectangular area occupied by the cursor */
  GdkRectangle cursor_rect;
  /* The position and height of the selection bound. width is ignored. */
  GdkRectangle selection_bound_rect;

  /* Current line */
  gint line_y;
  gint line_height;
};

/* Helper struct for redrawing selection area */
typedef struct _InfTextGtkViewUserToggle InfTextGtkViewUserToggle;
struct _InfTextGtkViewUserToggle {
  /* User toggled on or off at this point */
  InfTextGtkViewUser* user;
  /* Position of the toggle */
  guint pos;
  /* NULL if this toggles on, or the corresponding on
   * toggle if it toggles off. */
  InfTextGtkViewUserToggle* on_toggle;
  /* Position in textview, in window coordinates */
  gint x;
  gint y;
};

typedef struct _InfTextGtkViewPrivate InfTextGtkViewPrivate;
struct _InfTextGtkViewPrivate {
  InfIo* io;
  GtkTextView* textview;
  InfUserTable* user_table;
  InfTextUser* active_user;
  GSList* users;
  
  gboolean show_remote_cursors;
  gboolean show_remote_selections;
  gboolean show_remote_current_lines;
};

enum {
  PROP_0,

  /* construct only */
  PROP_IO,
  PROP_VIEW,
  PROP_USER_TABLE,

  /* read/write */
  PROP_ACTIVE_USER,
  
  PROP_SHOW_REMOTE_CURSORS,
  PROP_SHOW_REMOTE_SELECTIONS,
  PROP_SHOW_REMOTE_CURRENT_LINES
};

#define INF_TEXT_GTK_VIEW_PRIVATE(obj) (G_TYPE_INSTANCE_GET_PRIVATE((obj), INF_TEXT_GTK_TYPE_VIEW, InfTextGtkViewPrivate))

G_DEFINE_TYPE_WITH_CODE(InfTextGtkView, inf_text_gtk_view, G_TYPE_OBJECT,
  G_ADD_PRIVATE(InfTextGtkView))

static InfTextGtkViewUser*
inf_text_gtk_view_find_user(InfTextGtkView* view,
                            InfTextUser* user)
{
  InfTextGtkViewPrivate* priv;
  GSList* item;

  priv = INF_TEXT_GTK_VIEW_PRIVATE(view);

  for(item = priv-&gt;users; item != NULL; item = item-&gt;next)
    if( ((InfTextGtkViewUser*)item-&gt;data)-&gt;user == user)
      return (InfTextGtkViewUser*)item-&gt;data;

  return NULL;
}

/* Compute cursor_rect, selection_bound_rect */
static void
inf_text_gtk_view_user_compute_user_area(InfTextGtkViewUser* view_user)
{
  InfTextGtkViewPrivate* priv;
  GtkTextIter iter;
  gfloat cursor_aspect_ratio;

  priv = INF_TEXT_GTK_VIEW_PRIVATE(view_user-&gt;view);

  gtk_widget_style_get(
    GTK_WIDGET(priv-&gt;textview),
    "cursor-aspect-ratio", &amp;cursor_aspect_ratio,
    NULL
  );

  gtk_text_buffer_get_iter_at_offset(
    gtk_text_view_get_buffer(priv-&gt;textview),
    &amp;iter,
    inf_text_user_get_caret_position(view_user-&gt;user)
  );

  /* Find current line */
  gtk_text_view_get_line_yrange(
    priv-&gt;textview,
    &amp;iter,
    &amp;view_user-&gt;line_y,
    &amp;view_user-&gt;line_height
  );

  /* TODO: We don't need the cursor rect for show-remote-current-lines, and
   * we don't need the selection rect for show-remote-cursors and
   * show-remote-current-lines. So we might not even want to compute them in
   * if those are disabled. */

  /* Find cursor position */
  gtk_text_view_get_iter_location(
    priv-&gt;textview,
    &amp;iter,
    &amp;view_user-&gt;cursor_rect
  );

  view_user-&gt;cursor_rect.width = MAX(
    (int)(view_user-&gt;cursor_rect.height * cursor_aspect_ratio),
    1
  );

  /* Find selection bound */
  gtk_text_iter_forward_chars(
    &amp;iter,
    inf_text_user_get_selection_length(view_user-&gt;user)
  );

  gtk_text_view_get_iter_location(
    priv-&gt;textview,
    &amp;iter,
    &amp;view_user-&gt;selection_bound_rect
  );

  view_user-&gt;selection_bound_rect.width = MAX(
    (int)(view_user-&gt;selection_bound_rect.height * cursor_aspect_ratio),
    1
  );
}

static guint
inf_text_gtk_view_get_left_margin(GtkTextView* view)
{
  GtkAdjustment* hadjustment;
  gint margin;
  gint hadj;

  hadjustment = gtk_scrollable_get_hadjustment(GTK_SCROLLABLE(view));

  margin = gtk_text_view_get_left_margin(view);
  if(!hadjustment) return margin;

  hadj = gtk_adjustment_get_value(hadjustment);
  if(hadj &lt; margin) return margin - hadj;

  return 0;
}

static guint
inf_text_gtk_view_get_right_margin(GtkTextView* view)
{
  GtkAdjustment* hadjustment;
  gint margin;
  gdouble hadj;
  gdouble hupper;
  gdouble hpage;

  hadjustment = gtk_scrollable_get_hadjustment(GTK_SCROLLABLE(view));

  margin = gtk_text_view_get_right_margin(view);
  if(!hadjustment) return margin;

  /* TODO: I am not exactly sure where this +1 comes from, but it is required
   * so that the selection is aligned with the local selection at the right
   * margin. */
  hadj = gtk_adjustment_get_value(hadjustment) + 1;

  g_object_get(
    G_OBJECT(hadjustment),
    "upper", &amp;hupper,
    "page-size", &amp;hpage,
    NULL
  );

  if(hadj &gt; hupper - hpage - margin)
    return margin - (gint)(hupper - hpage - hadj);

  return 0;
}

/* Invalidate the whole area of the textview covered by the given user:
 * cursor, selection, current line */
static void
inf_text_gtk_view_user_invalidate_user_area(InfTextGtkViewUser* view_user)
{
  InfTextGtkViewPrivate* priv;
  GdkWindow* window;
  GdkRectangle invalidate_rect;
  gint selection_bound_x;
  gint selection_bound_y;
  gint window_width;

  priv = INF_TEXT_GTK_VIEW_PRIVATE(view_user-&gt;view);

  if(gtk_widget_get_realized(GTK_WIDGET(priv-&gt;textview)))
  {
    /* Invalidate cursors/selections */
    if(priv-&gt;show_remote_cursors || priv-&gt;show_remote_selections ||
       priv-&gt;show_remote_current_lines)
    {
      window = gtk_text_view_get_window(priv-&gt;textview, GTK_TEXT_WINDOW_TEXT);
      window_width = gdk_window_get_width(window);

      gtk_text_view_buffer_to_window_coords(
        priv-&gt;textview,
        GTK_TEXT_WINDOW_TEXT,
        view_user-&gt;cursor_rect.x, view_user-&gt;cursor_rect.y,
        &amp;invalidate_rect.x, &amp;invalidate_rect.y
      );

      invalidate_rect.width = view_user-&gt;cursor_rect.width;
      invalidate_rect.height = view_user-&gt;cursor_rect.height;

      /* Don't check for InfTextUser's selection length here so that clearing
       * a previous selection works. */
      if(priv-&gt;show_remote_selections &amp;&amp;
         (view_user-&gt;selection_bound_rect.x != view_user-&gt;cursor_rect.x ||
          view_user-&gt;selection_bound_rect.y != view_user-&gt;cursor_rect.y))
      {
        gtk_text_view_buffer_to_window_coords(
          priv-&gt;textview,
          GTK_TEXT_WINDOW_TEXT,
          view_user-&gt;selection_bound_rect.x,
          view_user-&gt;selection_bound_rect.y,
          &amp;selection_bound_x, &amp;selection_bound_y
        );

        /* Invalidate the whole area between cursor and selection bound */
        if(selection_bound_y == invalidate_rect.y)
        {
          /* Cursor and selection bound are on the same line */
          if(selection_bound_x &gt; invalidate_rect.x)
          {
            /* Selection bound is to the right of cursor */
            invalidate_rect.width = MAX(
              selection_bound_x - invalidate_rect.x,
              invalidate_rect.width
            );
          }
          else
          {
            /* Selection bound is to the left of cursor */
            invalidate_rect.width += (invalidate_rect.x - selection_bound_x);
            invalidate_rect.x = selection_bound_x;
          }
        }
        else
        {
          /* Cursor and selection bound are on different lines. Could split
           * the actual area to be invalidated into three rectangles here,
           * but let's just do the union for simplicity reasons. */
          invalidate_rect.width = window_width;
          invalidate_rect.height = MAX(
            invalidate_rect.y + invalidate_rect.height,
            selection_bound_y + view_user-&gt;selection_bound_rect.height
          ) - MIN(invalidate_rect.y, selection_bound_y);

          invalidate_rect.x =
            inf_text_gtk_view_get_left_margin(priv-&gt;textview);
          invalidate_rect.y = MIN(invalidate_rect.y, selection_bound_y);

          invalidate_rect.width -=
            inf_text_gtk_view_get_left_margin(priv-&gt;textview) +
            inf_text_gtk_view_get_right_margin(priv-&gt;textview);
        }

        gdk_window_invalidate_rect(window, &amp;invalidate_rect, FALSE);
      }

      /* Invalidate current lines */
      if(priv-&gt;show_remote_current_lines)
      {
        gtk_text_view_buffer_to_window_coords(
          priv-&gt;textview,
          GTK_TEXT_WINDOW_TEXT,
          0, view_user-&gt;line_y,
          NULL, &amp;invalidate_rect.y
        );

        /* -1 to stay consistent with GtkSourceView */
        invalidate_rect.x =
          inf_text_gtk_view_get_left_margin(priv-&gt;textview) - 1;
        invalidate_rect.width = window_width - invalidate_rect.x;
        invalidate_rect.height = view_user-&gt;line_height;
      }

      gdk_window_invalidate_rect(window, &amp;invalidate_rect, FALSE);
    }
  }
}

static gint
inf_text_gtk_view_user_line_position_cmp(gconstpointer first,
                                         gconstpointer second)
{
  const InfTextGtkViewUser* first_user;
  const InfTextGtkViewUser* second_user;

  first_user = (const InfTextGtkViewUser*)first;
  second_user = (const InfTextGtkViewUser*)second;

  if(second_user-&gt;line_y &lt; first_user-&gt;line_y)
    return 1;
  else if(second_user-&gt;line_y &gt; first_user-&gt;line_y)
    return -1;

  return 0;

}

static gint
inf_text_gtk_view_user_toggle_position_cmp(gconstpointer first,
                                           gconstpointer second,
                                           gpointer user_data)
{
  const InfTextGtkViewUserToggle* first_toggle;
  const InfTextGtkViewUserToggle* second_toggle;

  first_toggle = (const InfTextGtkViewUserToggle*)first;
  second_toggle = (const InfTextGtkViewUserToggle*)second;

  if(second_toggle-&gt;pos &lt; first_toggle-&gt;pos)
    return 1;
  else if(second_toggle-&gt;pos &gt; first_toggle-&gt;pos)
    return -1;

  return 0;
}

static gint
inf_text_gtk_view_user_toggle_user_cmp(gconstpointer first,
                                       gconstpointer second)
{
  const InfTextGtkViewUserToggle* first_toggle;
  const InfTextGtkViewUserToggle* second_toggle;
  guint first_id;
  guint second_id;

  first_toggle = (const InfTextGtkViewUserToggle*)first;
  second_toggle = (const InfTextGtkViewUserToggle*)second;
  first_id = inf_user_get_id(INF_USER(first_toggle-&gt;user-&gt;user));
  second_id = inf_user_get_id(INF_USER(second_toggle-&gt;user-&gt;user));

  if(second_id &lt; first_id)
    return 1;
  else if(second_id &gt; first_id)
    return -1;

  return 0;
}

static void
inf_text_gtk_view_user_toggle_free(gpointer data)
{
  g_slice_free(InfTextGtkViewUserToggle, data);
}

static InfTextGtkViewUserToggle*
inf_text_gtk_view_add_user_toggle(GSequence* sequence,
                                  guint position,
                                  InfTextGtkViewUser* user,
                                  InfTextGtkViewUserToggle* on_toggle,
                                  gint x,
                                  gint y)
{
  InfTextGtkViewUserToggle* toggle;
  toggle = g_slice_new(InfTextGtkViewUserToggle);
  toggle-&gt;user = user;
  toggle-&gt;pos = position;
  toggle-&gt;on_toggle = on_toggle;
  toggle-&gt;x = x;
  toggle-&gt;y = y;

  g_sequence_insert_sorted(
    sequence,
    toggle,
    inf_text_gtk_view_user_toggle_position_cmp,
    NULL
  );

  return toggle;
}

static void
inf_text_gtk_view_add_user_toggle_pair(GSequence* sequence,
                                       guint begin,
                                       guint end,
                                       InfTextGtkViewUser* user,
                                       gint begin_x,
                                       gint begin_y,
                                       gint end_x,
                                       gint end_y)
{
  InfTextGtkViewUserToggle* begin_toggle;

  g_assert(end &gt; begin);

  begin_toggle = inf_text_gtk_view_add_user_toggle(
    sequence,
    begin,
    user,
    NULL,
    begin_x,
    begin_y
  );

  inf_text_gtk_view_add_user_toggle(
    sequence,
    end,
    user,
    begin_toggle,
    end_x,
    end_y
  );
}

static gboolean
inf_text_gtk_view_draw_before_cb(GtkWidget* widget,
                                 cairo_t* cr,
                                 gpointer user_data)
{
  InfTextGtkView* view;
  InfTextGtkViewPrivate* priv;
  GSList* item;
  GSList* prev_item;
  InfTextGtkViewUser* prev_user;
  InfTextGtkViewUser* view_user;
  GtkAdjustment* hadjustment;
  GtkAdjustment* vadjustment;
  GdkWindow *text_window;

  GtkStyleContext* style;
  GdkRGBA bg;
  double h, s, v;
  double r, g, b;

  GSList* sort_users;
  GdkRectangle rect;
  gint window_width;
  gint rx, ry;
  GdkRectangle clip_area;
  cairo_pattern_t* pattern;
  double n, n_users;
  cairo_matrix_t matrix;

  view = INF_TEXT_GTK_VIEW(user_data);
  priv = INF_TEXT_GTK_VIEW_PRIVATE(view);

  text_window = gtk_text_view_get_window(priv-&gt;textview, GTK_TEXT_WINDOW_TEXT);

  if(!gtk_cairo_should_draw_window(cr, text_window))
  {
    return FALSE;
  }

  if(priv-&gt;show_remote_current_lines)
  {
    gtk_cairo_transform_to_window(cr, GTK_WIDGET(priv-&gt;textview), text_window);

    gdk_cairo_get_clip_rectangle(cr, &amp;clip_area);

    window_width = gdk_window_get_width(text_window);

    /* Make current line color depend on background. */
    style = gtk_widget_get_style_context(GTK_WIDGET(priv-&gt;textview));
    gtk_style_context_save(style);
    gtk_style_context_add_class(style, GTK_STYLE_CLASS_VIEW);
    gtk_style_context_get_background_color(style, GTK_STATE_FLAG_NORMAL, &amp;bg);
    gtk_style_context_restore(style);

    gtk_rgb_to_hsv(bg.red, bg.green, bg.blue, &amp;h, &amp;s, &amp;v);
    v = MAX(v, 0.3);
    s = MAX(s, 0.1 + 0.3*(1 - v));

    sort_users = g_slist_copy(priv-&gt;users);
    sort_users =
      g_slist_sort(sort_users, inf_text_gtk_view_user_line_position_cmp);

    prev_item = sort_users;
    if(prev_item) prev_user = (InfTextGtkViewUser*)prev_item-&gt;data;
    n_users = 1.0;

    for(item = sort_users; item != NULL; item = item-&gt;next, n_users += 1.0)
    {
      if(item-&gt;next == NULL ||
         ((InfTextGtkViewUser*)item-&gt;next-&gt;data)-&gt;line_y != prev_user-&gt;line_y)
      {
        gtk_text_view_buffer_to_window_coords(
          priv-&gt;textview,
          GTK_TEXT_WINDOW_TEXT,
          0, prev_user-&gt;line_y,
          NULL, &amp;rect.y
        );

        /* -1 to stay consistent with GtkSourceView */
        rect.x = inf_text_gtk_view_get_left_margin(priv-&gt;textview) - 1;
        rect.width = window_width - rect.x;
        rect.height = prev_user-&gt;line_height;

        if(gdk_rectangle_intersect(&amp;clip_area, &amp;rect, NULL))
        {
          hadjustment =
            gtk_scrollable_get_hadjustment(GTK_SCROLLABLE(priv-&gt;textview));
          vadjustment =
            gtk_scrollable_get_vadjustment(GTK_SCROLLABLE(priv-&gt;textview));

          /* Construct pattern */
          rx = gtk_adjustment_get_value(vadjustment);
          ry = gtk_adjustment_get_value(hadjustment);
          pattern =
            cairo_pattern_create_linear(0, 0, 3.5*n_users, 3.5*n_users);
          cairo_matrix_init_translate(&amp;matrix, rx, ry);
          cairo_pattern_set_matrix(pattern, &amp;matrix);
          cairo_pattern_set_extend(pattern, CAIRO_EXTEND_REPEAT);

          for(n = 0.0;
              prev_item != item-&gt;next;
              prev_item = prev_item-&gt;next, n += 1.0)
          {
            view_user = (InfTextGtkViewUser*)prev_item-&gt;data;
            h = inf_text_user_get_hue(view_user-&gt;user);
            gtk_hsv_to_rgb(h, s, v, &amp;r, &amp;g, &amp;b);

            cairo_pattern_add_color_stop_rgb(
              pattern,
              n/n_users,
              r, g, b
            );

            cairo_pattern_add_color_stop_rgb(
              pattern,
              (n+1.0)/n_users,
              r, g, b
            );
          }

          cairo_set_source(cr, pattern);
          gdk_cairo_rectangle(cr, &amp;rect);
          cairo_fill(cr);
          cairo_pattern_destroy(pattern);
        }

        prev_item = item-&gt;next;
        if(prev_item) prev_user = (InfTextGtkViewUser*)prev_item-&gt;data;
        n_users = 0.0;
      }
    }

    g_slist_free(sort_users);
  }

  return FALSE;
}

static gboolean
inf_text_gtk_view_draw_after_cb(GtkWidget* widget,
                                cairo_t* cr,
                                gpointer user_data)
{
  InfTextGtkView* view;
  InfTextGtkViewPrivate* priv;
  gint window_width;
  GtkStyleContext* style;
  GdkColor* cursor_color;
  GdkRGBA fg;
  double hc,sc,vc;
  double hs,ss,vs;
  GSList* item;
  InfTextGtkViewUser* view_user;
  double rc,gc,bc;
  double rs,gs,bs;

  GdkRectangle clip_area;

  gint ax, ay;
  GtkTextIter begin_iter;
  GtkTextIter end_iter;
  guint area_begin;
  guint area_end;

  guint own_sel_begin;
  guint own_sel_end;
  gint osbx, osby;
  gint osex, osey;

  gint sel;
  guint begin;
  guint end;
  GSequence* toggles;

  GSequenceIter* tog_iter;
  InfTextGtkViewUserToggle* cur_toggle;
  InfTextGtkViewUserToggle* prev_toggle;
  guint n_users;
  GSList* users;
  cairo_pattern_t* pattern;
  GtkAdjustment* hadjustment;
  GtkAdjustment* vadjustment;
  double n;
  cairo_matrix_t matrix;

  GdkRectangle rct;
  gint rx, ry;
  GdkWindow *text_window;

  view = INF_TEXT_GTK_VIEW(user_data);
  priv = INF_TEXT_GTK_VIEW_PRIVATE(view);

  text_window = gtk_text_view_get_window(priv-&gt;textview, GTK_TEXT_WINDOW_TEXT);

  if(!gtk_cairo_should_draw_window(cr, text_window))
  {
    return FALSE;
  }

  gtk_cairo_transform_to_window(cr, GTK_WIDGET(priv-&gt;textview), text_window);
  gdk_cairo_get_clip_rectangle(cr, &amp;clip_area);

  style = gtk_widget_get_style_context(GTK_WIDGET(priv-&gt;textview));
  gtk_style_context_save(style);
  gtk_style_context_add_class(style, GTK_STYLE_CLASS_VIEW);
  gtk_style_context_get_color(style, GTK_STATE_FLAG_NORMAL, &amp;fg);
  gtk_style_context_restore(style);

  if(priv-&gt;show_remote_selections)
  {
    window_width = gdk_window_get_width(text_window);

    /* Make selection color based on text color: If text is dark, selection
     * is dark, if text is bright selection is bright. Note that we draw with
     * 50% alpha only, so text remains readable. */
    gtk_rgb_to_hsv(fg.red, fg.green, fg.blue, &amp;hs, &amp;ss, &amp;vs);
    vs = MAX(vs, 0.5);
    ss = 1.0 - 0.4*(vs);

    /* Find range of text to be updated */
    gtk_text_view_window_to_buffer_coords(
      priv-&gt;textview,
      GTK_TEXT_WINDOW_TEXT,
      clip_area.x, clip_area.y,
      &amp;ax, &amp;ay
    );

    gtk_text_view_get_iter_at_location(
      priv-&gt;textview,
      &amp;begin_iter,
      ax,
      ay
    );

    gtk_text_view_get_iter_at_location(
      priv-&gt;textview,
      &amp;end_iter,
      ax + clip_area.width,
      ay + clip_area.height
    );

    area_begin = gtk_text_iter_get_offset(&amp;begin_iter);
    area_end = gtk_text_iter_get_offset(&amp;end_iter);
    g_assert(area_end &gt;= area_begin);

    /* Find own selection (we don't draw remote
     * selections over own selection). */
    gtk_text_buffer_get_selection_bounds(
      gtk_text_view_get_buffer(priv-&gt;textview),
      &amp;begin_iter,
      &amp;end_iter
    );

    own_sel_begin = gtk_text_iter_get_offset(&amp;begin_iter);
    own_sel_end = gtk_text_iter_get_offset(&amp;end_iter);
    if(own_sel_begin != own_sel_end)
    {
      gtk_text_view_get_iter_location(priv-&gt;textview, &amp;begin_iter, &amp;rct);
      gtk_text_view_buffer_to_window_coords(
        priv-&gt;textview,
        GTK_TEXT_WINDOW_TEXT,
        rct.x, rct.y,
        &amp;osbx, &amp;osby
      );

      gtk_text_view_get_iter_location(priv-&gt;textview, &amp;end_iter, &amp;rct);
      gtk_text_view_buffer_to_window_coords(
        priv-&gt;textview,
        GTK_TEXT_WINDOW_TEXT,
        rct.x, rct.y,
        &amp;osex, &amp;osey
      );
    }

    /* Build toggle list */
    toggles = g_sequence_new(inf_text_gtk_view_user_toggle_free);
    for(item = priv-&gt;users; item != NULL; item = item-&gt;next)
    {
      view_user = (InfTextGtkViewUser*)item-&gt;data;
      if(inf_text_user_get_selection_length(view_user-&gt;user) != 0)
      {
        begin = inf_text_user_get_caret_position(view_user-&gt;user);
        sel = inf_text_user_get_selection_length(view_user-&gt;user);

        if(sel &gt; 0)
        {
          end = begin + sel;
        }
        else
        {
          g_assert(begin &gt;= (unsigned int)-sel);

          end = begin;
          begin += sel;
        }

        /* This can happen if the document is not yet fully loaded, i.e. synchronization
         * is still in progress. */
        if(begin &gt; gtk_text_buffer_get_char_count(gtk_text_view_get_buffer(priv-&gt;textview)))
          begin = gtk_text_buffer_get_char_count(gtk_text_view_get_buffer(priv-&gt;textview));
        if(end &gt; gtk_text_buffer_get_char_count(gtk_text_view_get_buffer(priv-&gt;textview)))
          end = gtk_text_buffer_get_char_count(gtk_text_view_get_buffer(priv-&gt;textview));

        begin = MIN(MAX(begin, area_begin), area_end);
        end = MIN(MAX(end, area_begin), area_end);
        g_assert(end &gt;= begin);

        if(begin != end)
        {
          if(sel &gt; 0)
          {
            gtk_text_view_buffer_to_window_coords(
              priv-&gt;textview,
              GTK_TEXT_WINDOW_TEXT,
              view_user-&gt;cursor_rect.x,
              view_user-&gt;cursor_rect.y,
              &amp;rx, &amp;ry
            );

            gtk_text_view_buffer_to_window_coords(
              priv-&gt;textview,
              GTK_TEXT_WINDOW_TEXT,
              view_user-&gt;selection_bound_rect.x,
              view_user-&gt;selection_bound_rect.y,
              &amp;ax, &amp;ay
            );
          }
          else
          {
            gtk_text_view_buffer_to_window_coords(
              priv-&gt;textview,
              GTK_TEXT_WINDOW_TEXT,
              view_user-&gt;selection_bound_rect.x,
              view_user-&gt;selection_bound_rect.y,
              &amp;rx, &amp;ry
            );

            gtk_text_view_buffer_to_window_coords(
              priv-&gt;textview,
              GTK_TEXT_WINDOW_TEXT,
              view_user-&gt;cursor_rect.x,
              view_user-&gt;cursor_rect.y,
              &amp;ax, &amp;ay
            );
          }

          if(own_sel_begin == own_sel_end ||
             own_sel_end &lt;= begin || own_sel_begin &gt;= end)
          {
            /* Local selection and remote selection do not overlap */
            inf_text_gtk_view_add_user_toggle_pair(
              toggles,
              begin, end,
              view_user,
              rx, ry,
              ax, ay
            );
          }
          else if(own_sel_begin &lt;= begin &amp;&amp; own_sel_end &gt;= end)
          {
            /* Whole remote selection is covered by local selection */
          }
          else if(own_sel_begin &gt; begin &amp;&amp; own_sel_end &gt;= end)
          {
            /* Last part of remote selection is covered by local selection */
            inf_text_gtk_view_add_user_toggle_pair(
              toggles,
              begin, own_sel_begin,
              view_user,
              rx, ry,
              osbx, osby
            );
          }
          else if(own_sel_begin &lt;= begin &amp;&amp; own_sel_end &lt; end)
          {
            /* First part of remote selection is covered by local selection */
            inf_text_gtk_view_add_user_toggle_pair(
              toggles,
              own_sel_end, end,
              view_user,
              osex, osey,
              ax, ay
            );
          }
          else if(own_sel_begin &gt; begin &amp;&amp; own_sel_end &lt; end)
          {
            /* Local selection is in middle of remote selection */
            inf_text_gtk_view_add_user_toggle_pair(
              toggles,
              begin, own_sel_begin,
              view_user,
              rx, ry,
              osbx, osby
            );

            inf_text_gtk_view_add_user_toggle_pair(
              toggles,
              own_sel_end, end,
              view_user,
              osex, osey,
              ax, ay
            );
          }
          else
          {
            g_assert_not_reached();
          }
        }
      }
    }

    /* Walk toggle list, draw selections */
    tog_iter = g_sequence_get_begin_iter(toggles);
    cur_toggle = NULL;
    prev_toggle = NULL;
    users = NULL;
    n_users = 0;

    tog_iter = g_sequence_get_begin_iter(toggles);
    while(!g_sequence_iter_is_end(tog_iter))
    {
      cur_toggle = (InfTextGtkViewUserToggle*)g_sequence_get(tog_iter);

      /* Draw users from prev_toggle to cur_toggle */
      if(users != NULL)
      {
        g_assert(prev_toggle != NULL);
        g_assert(n_users &gt; 0);

        hadjustment =
          gtk_scrollable_get_hadjustment(GTK_SCROLLABLE(priv-&gt;textview));
        vadjustment =
          gtk_scrollable_get_vadjustment(GTK_SCROLLABLE(priv-&gt;textview));

        /* Construct pattern */
        rx = gtk_adjustment_get_value(hadjustment);
        ry = gtk_adjustment_get_value(vadjustment);
        pattern =
          cairo_pattern_create_linear(0, 0, 3.5*n_users, 3.5*n_users);
        cairo_matrix_init_translate(&amp;matrix, rx, ry);
        cairo_pattern_set_matrix(pattern, &amp;matrix);
        cairo_pattern_set_extend(pattern, CAIRO_EXTEND_REPEAT);
        for(item = users, n = 0.0; item != NULL; item = item-&gt;next, n += 1.0)
        {
          view_user = ((InfTextGtkViewUserToggle*)item-&gt;data)-&gt;user;
          hs = inf_text_user_get_hue(view_user-&gt;user);
          gtk_hsv_to_rgb(hs, ss, vs, &amp;rs, &amp;gs, &amp;bs);

          cairo_pattern_add_color_stop_rgba(
            pattern,
            n/n_users,
            rs, gs, bs, 0.5
          );

          cairo_pattern_add_color_stop_rgba(
            pattern,
            (n+1.0)/n_users,
            rs, gs, bs, 0.5
          );
        }

        cairo_set_source(cr, pattern);
        if(prev_toggle-&gt;y == cur_toggle-&gt;y)
        {
          /* same line */
          g_assert(prev_toggle-&gt;x &lt; cur_toggle-&gt;x);

          rct.x = prev_toggle-&gt;x;
          rct.y = prev_toggle-&gt;y;
          rct.width = cur_toggle-&gt;x - prev_toggle-&gt;x;
          rct.height = cur_toggle-&gt;user-&gt;selection_bound_rect.height;
          gdk_cairo_rectangle(cr, &amp;rct);
        }
        else
        {
          g_assert(
            cur_toggle-&gt;y - prev_toggle-&gt;y &gt;=
            cur_toggle-&gt;user-&gt;selection_bound_rect.height
          );

          /* multiple lines */
          if(window_width &gt; prev_toggle-&gt;x)
          {
            /* first line */
            rct.x = prev_toggle-&gt;x;
            rct.y = prev_toggle-&gt;y;
            rct.width = window_width - prev_toggle-&gt;x -
              inf_text_gtk_view_get_right_margin(priv-&gt;textview);
            rct.height = prev_toggle-&gt;user-&gt;selection_bound_rect.height;
            gdk_cairo_rectangle(cr, &amp;rct);
          }

          if(cur_toggle-&gt;x &gt; 0)
          {
            /* last line */
            rct.x = inf_text_gtk_view_get_left_margin(priv-&gt;textview);
            rct.y = cur_toggle-&gt;y;
            rct.width = cur_toggle-&gt;x - rct.x;
            rct.height = cur_toggle-&gt;user-&gt;selection_bound_rect.height;
            gdk_cairo_rectangle(cr, &amp;rct);
          }

          if(cur_toggle-&gt;y - prev_toggle-&gt;y &gt;
             cur_toggle-&gt;user-&gt;selection_bound_rect.height)
          {
            /* intermediate */
            rct.x = inf_text_gtk_view_get_left_margin(priv-&gt;textview);
            rct.y = prev_toggle-&gt;y +
              prev_toggle-&gt;user-&gt;selection_bound_rect.height;
            rct.width = window_width - rct.x -
              inf_text_gtk_view_get_right_margin(priv-&gt;textview);
            rct.height = cur_toggle-&gt;y - prev_toggle-&gt;y -
              cur_toggle-&gt;user-&gt;selection_bound_rect.height;
            gdk_cairo_rectangle(cr, &amp;rct);
          }
        }

        cairo_fill(cr);
        cairo_pattern_destroy(pattern);
      }

      prev_toggle = cur_toggle;

      /* advance to next position, toggle users on/off while doing so */
      do
      {
        if(cur_toggle-&gt;on_toggle == NULL)
        {
          /* Keep toggles in user list sorted by user ID, so that the same
           * users generate the same pattern */
          users = g_slist_insert_sorted(
            users,
            cur_toggle,
            inf_text_gtk_view_user_toggle_user_cmp
          );

          ++n_users;
        }
        else
        {
          g_assert(n_users &gt; 0);
          users = g_slist_remove(users, cur_toggle-&gt;on_toggle);
          --n_users;
        }

        tog_iter = g_sequence_iter_next(tog_iter);
        if(g_sequence_iter_is_end(tog_iter))
          break;

        cur_toggle = (InfTextGtkViewUserToggle*)g_sequence_get(tog_iter);
      } while(cur_toggle-&gt;pos == prev_toggle-&gt;pos);
    }

    g_assert(n_users == 0);
    g_assert(users == NULL);
    g_sequence_free(toggles);
  }

  if(priv-&gt;show_remote_cursors)
  {
    gtk_widget_style_get (widget, "cursor-color", &amp;cursor_color, NULL);
    if(cursor_color != NULL)
    {
      rc = cursor_color-&gt;red / 65535.0;
      bc = cursor_color-&gt;green / 65535.0;
      gc = cursor_color-&gt;blue / 65535.0;
      gdk_color_free(cursor_color);
    }
    else
    {
      rc = fg.red;
      bc = fg.green;
      gc = fg.blue;
    }

    gtk_rgb_to_hsv(rc, bc, gc, &amp;hc, &amp;sc, &amp;vc);
    sc = MIN(MAX(sc, 0.3), 0.8);
    vc = MAX(vc, 0.7);

    for(item = priv-&gt;users; item != NULL; item = item-&gt;next)
    {
      view_user = (InfTextGtkViewUser*)item-&gt;data;
      if(view_user-&gt;cursor_visible)
      {
        gtk_text_view_buffer_to_window_coords(
          priv-&gt;textview,
          GTK_TEXT_WINDOW_TEXT,
          view_user-&gt;cursor_rect.x, view_user-&gt;cursor_rect.y,
          &amp;rct.x, &amp;rct.y
        );

        rct.width = view_user-&gt;cursor_rect.width;
        rct.height = view_user-&gt;cursor_rect.height;

        if(gdk_rectangle_intersect(&amp;clip_area, &amp;rct, NULL))
        {
          hc = inf_text_user_get_hue(view_user-&gt;user);
          gtk_hsv_to_rgb(hc, sc, vc, &amp;rc, &amp;gc, &amp;bc);

          cairo_set_source_rgb(cr, rc, gc, bc);
          gdk_cairo_rectangle(cr, &amp;rct);
          cairo_fill(cr);
        }
      }
    }
  }

  return FALSE;
}

static void
inf_text_gtk_view_style_updated_cb(GtkWidget* widget,
                                   gpointer user_data)
{
  InfTextGtkView* view;
  InfTextGtkViewPrivate* priv;
  GSList* item;
  InfTextGtkViewUser* view_user;

  view = INF_TEXT_GTK_VIEW(user_data);
  priv = INF_TEXT_GTK_VIEW_PRIVATE(view);

  for(item = priv-&gt;users; item != NULL; item = item-&gt;next)
  {
    view_user = (InfTextGtkViewUser*)item-&gt;data;
    inf_text_gtk_view_user_compute_user_area(view_user);
  }
}

static void
inf_text_gtk_view_size_allocate_cb(GtkWidget* widget,
                                   GtkAllocation* allocation,
                                   gpointer user_data)
{
  InfTextGtkView* view;
  InfTextGtkViewPrivate* priv;
  GSList* item;
  InfTextGtkViewUser* view_user;

  view = INF_TEXT_GTK_VIEW(user_data);
  priv = INF_TEXT_GTK_VIEW_PRIVATE(view);

  for(item = priv-&gt;users; item != NULL; item = item-&gt;next)
  {
    view_user = (InfTextGtkViewUser*)item-&gt;data;
    inf_text_gtk_view_user_compute_user_area(view_user);
  }
}

static void
inf_text_gtk_view_user_cursor_blink_timeout_func(gpointer user_data)
{
  InfTextGtkViewUser* view_user;
  InfTextGtkViewPrivate* priv;
  GtkSettings* settings;
  gboolean cursor_blink;
  gint cursor_blink_time;

  view_user = (InfTextGtkViewUser*)user_data;
  priv = INF_TEXT_GTK_VIEW_PRIVATE(view_user-&gt;view);

  view_user-&gt;cursor_visible = !view_user-&gt;cursor_visible;
  inf_text_gtk_view_user_invalidate_user_area(view_user);

  /* Schedule next cursor blink */
  settings = gtk_widget_get_settings(GTK_WIDGET(priv-&gt;textview));

  /* TODO: Handle gtk-cursor-blink-timeout */
  g_object_get(
    G_OBJECT(settings),
    "gtk-cursor-blink", &amp;cursor_blink,
    "gtk-cursor-blink-time", &amp;cursor_blink_time,
    NULL
  );

  if(cursor_blink)
  {
    if(!view_user-&gt;cursor_visible)
      cursor_blink_time = cursor_blink_time * 1 / 3;
    else
      cursor_blink_time = cursor_blink_time * 2 / 3;

    view_user-&gt;timeout = inf_io_add_timeout(
      priv-&gt;io,
      cursor_blink_time,
      inf_text_gtk_view_user_cursor_blink_timeout_func,
      view_user,
      NULL
    );
  }
  else
  {
    view_user-&gt;timeout = NULL;
  }
}

static void
inf_text_gtk_view_user_reset_timeout(InfTextGtkViewUser* view_user)
{
  InfTextGtkViewPrivate* priv;
  GtkSettings* settings;
  gboolean cursor_blink;
  gint cursor_blink_time;

  priv = INF_TEXT_GTK_VIEW_PRIVATE(view_user-&gt;view);

  if(view_user-&gt;timeout)
  {
    inf_io_remove_timeout(priv-&gt;io, view_user-&gt;timeout);
    view_user-&gt;timeout = NULL;
  }

  if(!view_user-&gt;cursor_visible)
  {
    view_user-&gt;cursor_visible = TRUE;

    /* TODO: Only need to invalidate cursor rect, not whole user area */
    inf_text_gtk_view_user_invalidate_user_area(view_user);
  }

  settings = gtk_widget_get_settings(GTK_WIDGET(priv-&gt;textview));

  /* TODO: Reschedule timeout if these settings change */
  g_object_get(
    G_OBJECT(settings),
    "gtk-cursor-blink", &amp;cursor_blink,
    "gtk-cursor-blink-time", &amp;cursor_blink_time,
    NULL
  );

  if(cursor_blink)
  {
    view_user-&gt;timeout = inf_io_add_timeout(
      priv-&gt;io,
      cursor_blink_time,
      inf_text_gtk_view_user_cursor_blink_timeout_func,
      view_user,
      NULL
    );
  }
}

static gboolean
inf_text_gtk_view_user_selection_changed_cb_idle_func(gpointer user_data)
{
  InfTextGtkViewUser* view_user;
  view_user = (InfTextGtkViewUser*)user_data;

  g_assert(view_user-&gt;revalidate_idle != 0);
  view_user-&gt;revalidate_idle = 0;

  /* Revalidate */
  inf_text_gtk_view_user_invalidate_user_area(view_user);

  return FALSE;
}

static void
inf_text_gtk_view_user_selection_changed_cb(InfTextUser* user,
                                            guint position,
                                            gint length,
                                            gboolean by_request,
                                            gpointer user_data)
{
  InfTextGtkViewUser* view_user;
  InfTextGtkViewPrivate* priv;

  view_user = (InfTextGtkViewUser*)user_data;
  priv = INF_TEXT_GTK_VIEW_PRIVATE(view_user-&gt;view);

  /* We don't need to invalidate areas if the change was not made by a user
   * request. So for example if someone's cursor moved because another user
   * has inserted text somewhere before it, then we don't need to redraw that
   * cursor since it either:
   * a) was shifted to the right, in which case the underlying text was also
   * shifted and is therefore invalidated anyway.
   * b) Both text and cursor have not been shifted, no redraw necessary.
   * Note that we need to recompute the user area though because it might
   * have moved. */
  if(by_request)
  {
    /* Invalidate current user area, e.g. to get rid of cursor at previous
     * location if it moved, or if the selection area was shrinked. */
    /* TODO: Not sure whether this also needs to go to the idle handler...
     * if so make sure it is executed even if the viewuser is deleted in the
     * meanwhile. */
    inf_text_gtk_view_user_invalidate_user_area(view_user);
  }

  inf_text_gtk_view_user_compute_user_area(view_user);

  if(by_request)
  {
    inf_text_gtk_view_user_reset_timeout(view_user);

    /* We can't invalidate here because
     * gtk_text_view_buffer_to_window_coords() does not give correct
     * coordinates at this point. We need to wait for the textview to
     * revalidate onscreen lines first (which it does in an idle handler,
     * note higher numbers indicate less priority). */
    if(view_user-&gt;revalidate_idle == 0)
    {
      view_user-&gt;revalidate_idle = g_idle_add_full(
        GTK_TEXT_VIEW_PRIORITY_VALIDATE + 1,
        inf_text_gtk_view_user_selection_changed_cb_idle_func,
        view_user,
        NULL
      );
    }
  }
}

static void
inf_text_gtk_view_user_notify_hue_cb(GObject* object,
                                     GParamSpec* pspec,
                                     gpointer user_data)
{
  InfTextGtkViewUser* view_user;
  InfTextGtkViewPrivate* priv;

  view_user = (InfTextGtkViewUser*)user_data;
  priv = INF_TEXT_GTK_VIEW_PRIVATE(view_user-&gt;view);

<a name="2"></a>  /* TODO: Might restrict this on current lines,
   * cursor rects and selection rects */
  gtk_widget_queue_draw(GTK_WIDGET(priv-&gt;textview));
<font color="#980517"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>}

static void
inf_text_gtk_view_add_user(InfTextGtkView* view,
                           InfTextUser* user)
{
  InfTextGtkViewPrivate* priv;
  InfTextGtkViewUser* view_user;

  priv = INF_TEXT_GTK_VIEW_PRIVATE(view);
  view_user = g_slice_new(InfTextGtkViewUser);

  view_user-&gt;view = view;
  view_user-&gt;user = INF_TEXT_USER(user);
  view_user-&gt;cursor_visible = TRUE;
  view_user-&gt;timeout = NULL;
  view_user-&gt;revalidate_idle = 0;</b></font>
  inf_text_gtk_view_user_compute_user_area(view_user);
  inf_text_gtk_view_user_reset_timeout(view_user);
  priv-&gt;users = g_slist_prepend(priv-&gt;users, view_user);

  g_signal_connect_after(
    user,
    "selection-changed",
    G_CALLBACK(inf_text_gtk_view_user_selection_changed_cb),
    view_user
  );

  g_signal_connect(
    user,
    "notify::hue",
    G_CALLBACK(inf_text_gtk_view_user_notify_hue_cb),
    view_user
  );

  inf_text_gtk_view_user_invalidate_user_area(view_user);
}

static void
inf_text_gtk_view_remove_user(InfTextGtkViewUser* view_user)
{
  InfTextGtkViewPrivate* priv;
  priv = INF_TEXT_GTK_VIEW_PRIVATE(view_user-&gt;view);

  inf_signal_handlers_disconnect_by_func(
    view_user-&gt;user,
    G_CALLBACK(inf_text_gtk_view_user_selection_changed_cb),
    view_user
  );

  inf_signal_handlers_disconnect_by_func(
    view_user-&gt;user,
    G_CALLBACK(inf_text_gtk_view_user_notify_hue_cb),
    view_user
  );

  if(view_user-&gt;timeout != NULL)
    inf_io_remove_timeout(priv-&gt;io, view_user-&gt;timeout);

  if(view_user-&gt;revalidate_idle != 0)
    g_source_remove(view_user-&gt;revalidate_idle);

  inf_text_gtk_view_user_invalidate_user_area(view_user);

  priv-&gt;users = g_slist_remove(priv-&gt;users, view_user);
  g_slice_free(InfTextGtkViewUser, view_user);
}

static void
inf_text_gtk_view_user_notify_status_cb(GObject* object,
                                        GParamSpec* pspec,
                                        gpointer user_data)
{
  InfTextGtkView* view;
  InfTextGtkViewPrivate* priv;
  InfTextUser* user;
  InfTextGtkViewUser* view_user;

  view = INF_TEXT_GTK_VIEW(user_data);
  priv = INF_TEXT_GTK_VIEW_PRIVATE(view);
  user = INF_TEXT_USER(object);

  g_assert(user != priv-&gt;active_user);
  view_user = inf_text_gtk_view_find_user(view, user);

  if(inf_user_get_status(INF_USER(user)) == INF_USER_ACTIVE)
  {
    if(!view_user)
      inf_text_gtk_view_add_user(view, user);
  }
  else
  {
    if(view_user)
      inf_text_gtk_view_remove_user(view_user);
  }
}

static void
inf_text_gtk_view_user_removed(InfTextGtkView* view,
                               InfTextUser* user)
{
  InfTextGtkViewPrivate* priv;
  InfTextGtkViewUser* view_user;

  priv = INF_TEXT_GTK_VIEW_PRIVATE(view);

  if(user == priv-&gt;active_user)
  {
    priv-&gt;active_user = NULL;
    g_object_notify(G_OBJECT(view), "active-user");
  }
  else
  {
    inf_signal_handlers_disconnect_by_func(
      user,
      G_CALLBACK(inf_text_gtk_view_user_notify_status_cb),
      view
    );

    if(inf_user_get_status(INF_USER(user)) == INF_USER_ACTIVE)
    {
      view_user = inf_text_gtk_view_find_user(view, user);
      g_assert(view_user != NULL);

      inf_text_gtk_view_remove_user(view_user);
    }
  }
}

static void
inf_text_gtk_view_user_added(InfTextGtkView* view,
                             InfTextUser* user)
{
  InfTextGtkViewPrivate* priv;
  priv = INF_TEXT_GTK_VIEW_PRIVATE(view);

  /* Active user is guaranteed to be contained in user table, so if user was
   * just added then it can't be set as active user already. */
  g_assert(user != priv-&gt;active_user);

  g_signal_connect(
    user,
    "notify::status",
    G_CALLBACK(inf_text_gtk_view_user_notify_status_cb),
    view
  );

  if(inf_user_get_status(INF_USER(user)) == INF_USER_ACTIVE)
    inf_text_gtk_view_add_user(view, user);
}

static void
inf_text_gtk_view_add_user_cb(InfUserTable* user_table,
                              InfUser* user,
                              gpointer user_data)
{
  InfTextGtkView* view = INF_TEXT_GTK_VIEW(user_data);
  g_assert(INF_TEXT_IS_USER(user));
  inf_text_gtk_view_user_added(view, INF_TEXT_USER(user));
}

static void
inf_text_gtk_view_remove_user_cb(InfUserTable* user_table,
                                 InfUser* user,
                                 gpointer user_data)
{
  InfTextGtkView* view = INF_TEXT_GTK_VIEW(user_data);
  g_assert(INF_TEXT_IS_USER(user));
  inf_text_gtk_view_user_removed(view, INF_TEXT_USER(user));
}

static void
inf_text_gtk_view_set_user_table_foreach_new_user_func(InfUser* user,
                                                       gpointer user_data)
{
  InfTextGtkView* view = INF_TEXT_GTK_VIEW(user_data);
  g_assert(INF_TEXT_IS_USER(user));
  inf_text_gtk_view_user_added(view, INF_TEXT_USER(user));
}

static void
inf_text_gtk_view_set_user_table_foreach_old_user_func(InfUser* user,
                                                       gpointer user_data)
{
  InfTextGtkView* view = INF_TEXT_GTK_VIEW(user_data);
  g_assert(INF_TEXT_IS_USER(user));
  inf_text_gtk_view_user_removed(view, INF_TEXT_USER(user));
}

static void
inf_text_gtk_view_set_view(InfTextGtkView* view,
                           GtkTextView* gtk_view)
{
  InfTextGtkViewPrivate* priv;
  priv = INF_TEXT_GTK_VIEW_PRIVATE(view);

  if(priv-&gt;textview != NULL)
  {
    inf_signal_handlers_disconnect_by_func(
      G_OBJECT(priv-&gt;textview),
      G_CALLBACK(inf_text_gtk_view_draw_before_cb),
      view
    );

    inf_signal_handlers_disconnect_by_func(
      G_OBJECT(priv-&gt;textview),
      G_CALLBACK(inf_text_gtk_view_draw_after_cb),
      view
    );

    inf_signal_handlers_disconnect_by_func(
      G_OBJECT(priv-&gt;textview),
      G_CALLBACK(inf_text_gtk_view_style_updated_cb),
      view
    );

    inf_signal_handlers_disconnect_by_func(
      G_OBJECT(priv-&gt;textview),
      G_CALLBACK(inf_text_gtk_view_size_allocate_cb),
      view
    );

    g_object_unref(priv-&gt;textview);
  }

  priv-&gt;textview = gtk_view;

  if(gtk_view != NULL)
  {
    g_object_ref(gtk_view);

    g_signal_connect(
      G_OBJECT(gtk_view),
      "draw",
      G_CALLBACK(inf_text_gtk_view_draw_before_cb),
      view
    );

    g_signal_connect_after(
      G_OBJECT(gtk_view),
      "draw",
      G_CALLBACK(inf_text_gtk_view_draw_after_cb),
      view
    );

    g_signal_connect_after(
      G_OBJECT(gtk_view),
      "style-updated",
      G_CALLBACK(inf_text_gtk_view_style_updated_cb),
      view
    );

    /* This is required for the remote cursors showing up at the correct
     * position initially. Maybe gtk_text_view_get_iter_location() seems to
     * return junk before. Note that also style-updated is not enough. */
    g_signal_connect_after(
      G_OBJECT(gtk_view),
      "size-allocate",
<a name="0"></a>      G_CALLBACK(inf_text_gtk_view_size_allocate_cb),
      view
    );
<font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>  }

  g_object_notify(G_OBJECT(view), "view");
}

static void
inf_text_gtk_view_set_user_table(InfTextGtkView* view,
                                 InfUserTable* user_table)
{
  InfTextGtkViewPrivate* priv;
  priv = INF_TEXT_GTK_VIEW_PRIVATE(view);

  if(priv-&gt;user_table != NULL)
  {
    inf_signal_handlers_disconnect_by_func(
      G_OBJECT(priv-&gt;user_table),
      G_CALLBACK(inf_text_gtk_view_add_user_cb),
      view
    );

    inf_signal_handlers_disconnect_by_func(
      G_OBJECT(priv-&gt;user_table),
      G_CALLBACK(inf_text_gtk_view_remove_user_cb),
      view
    );

    inf_user_table_foreach_user(
      priv-&gt;user_table,
      inf_text_gtk_view_set_user_table_foreach_old_user_func,
      view
    );

    g_object_unref(priv-&gt;user_table);
  }

  priv-&gt;user_table = user_table;

  if(user_table != NULL)
  {
    g_object_ref(user_table);

    g_signal_connect(
      G_OBJECT(user_table),
      "add-user",
      G_CALLBACK(inf_text_gtk_view_add_user_cb),
      view
    );

    g_signal_connect(
      G_OBJECT(user_table),
      "remove-user",
      G_CALLBACK(inf_text_gtk_view_remove_user_cb),
      view
    );

    inf_user_table_foreach_user(
      user_table,
      inf_text_gtk_view_set_user_table_foreach_new_user_func,
      view
    );
  }

  g_object_notify(G_OBJECT(view), "user-table");
}

static void
inf_text_gtk_view_init(InfTextGtkView* view)
{
  InfTextGtkViewPrivate* priv;
  priv = INF_TEXT_GTK_VIEW_PRIVATE(view);

  priv-&gt;io = NULL;
  priv-&gt;textview = NULL;</b></font>
  priv-&gt;user_table = NULL;
  priv-&gt;active_user = NULL;
  priv-&gt;users = NULL;

  priv-&gt;show_remote_cursors = TRUE;
  priv-&gt;show_remote_selections = TRUE;
  priv-&gt;show_remote_current_lines = TRUE;
}

static void
inf_text_gtk_view_dispose(GObject* object)
{
  InfTextGtkView* view;
  InfTextGtkViewPrivate* priv;

  view = INF_TEXT_GTK_VIEW(object);
  priv = INF_TEXT_GTK_VIEW_PRIVATE(view);

  inf_text_gtk_view_set_user_table(view, NULL);
  inf_text_gtk_view_set_view(view, NULL);

  g_assert(priv-&gt;active_user == NULL);
  g_assert(priv-&gt;users == NULL);

  if(priv-&gt;io != NULL)
  {
    g_object_unref(priv-&gt;io);
    priv-&gt;io = NULL;
  }

  G_OBJECT_CLASS(inf_text_gtk_view_parent_class)-&gt;dispose(object);
}

static void
inf_text_gtk_view_set_property(GObject* object,
                                 guint prop_id,
                                 const GValue* value,
                                 GParamSpec* pspec)
{
  InfTextGtkView* view;
  InfTextGtkViewPrivate* priv;

  view = INF_TEXT_GTK_VIEW(object);
  priv = INF_TEXT_GTK_VIEW_PRIVATE(view);

  switch(prop_id)
  {
  case PROP_IO:
    g_assert(priv-&gt;io == NULL); /* construct only */
    priv-&gt;io = INF_IO(g_value_dup_object(value));
    break;
  case PROP_VIEW:
    g_assert(priv-&gt;textview == NULL); /* construct only */

    inf_text_gtk_view_set_view(
      view,
      GTK_TEXT_VIEW(g_value_get_object(value))
    );

    break;
  case PROP_USER_TABLE:
    g_assert(priv-&gt;user_table == NULL); /* construct/only */

    inf_text_gtk_view_set_user_table(
      view,
      INF_USER_TABLE(g_value_get_object(value))
    );

    break;
  case PROP_ACTIVE_USER:
    inf_text_gtk_view_set_active_user(
      view,
      INF_TEXT_USER(g_value_get_object(value))
    );

    break;
  case PROP_SHOW_REMOTE_CURSORS:
    inf_text_gtk_view_set_show_remote_cursors(
      view,
      g_value_get_boolean(value)
    );

    break;
  case PROP_SHOW_REMOTE_SELECTIONS:
    inf_text_gtk_view_set_show_remote_selections(
      view,
      g_value_get_boolean(value)
    );

    break;
  case PROP_SHOW_REMOTE_CURRENT_LINES:
    inf_text_gtk_view_set_show_remote_current_lines(
      view,
      g_value_get_boolean(value)
    );

    break;
  default:
    G_OBJECT_WARN_INVALID_PROPERTY_ID(value, prop_id, pspec);
    break;
  }
}

static void
inf_text_gtk_view_get_property(GObject* object,
                                 guint prop_id,
                                 GValue* value,
                                 GParamSpec* pspec)
{
<a name="1"></a>  InfTextGtkView* view;
  InfTextGtkViewPrivate* priv;

<font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>  view = INF_TEXT_GTK_VIEW(object);
  priv = INF_TEXT_GTK_VIEW_PRIVATE(view);

  switch(prop_id)
  {
  case PROP_IO:
    g_value_set_object(value, G_OBJECT(priv-&gt;io));
    break;
  case PROP_VIEW:
    g_value_set_object(value, G_OBJECT(priv-&gt;textview));
    break;
  case PROP_USER_TABLE:
    g_value_set_object(value, G_OBJECT(priv-&gt;user_table));
    break;
  case PROP_ACTIVE_USER:
    g_value_set_object(value, G_OBJECT(priv-&gt;active_user));
    break;
  case PROP_SHOW_REMOTE_CURSORS:
    g_value_set_boolean(value, priv-&gt;show_remote_cursors);
    break;
  case PROP_SHOW_REMOTE_SELECTIONS:
    g_value_set_boolean(value, priv-&gt;show_remote_selections);
    break;
  case PROP_SHOW_REMOTE_CURRENT_LINES:</b></font>
    g_value_set_boolean(value, priv-&gt;show_remote_current_lines);
    break;
  default:
    G_OBJECT_WARN_INVALID_PROPERTY_ID(object, prop_id, pspec);
    break;
  }
}

static void
inf_text_gtk_view_class_init(InfTextGtkViewClass* view_class)
{
  GObjectClass* object_class;
  object_class = G_OBJECT_CLASS(view_class);

  object_class-&gt;dispose = inf_text_gtk_view_dispose;
  object_class-&gt;set_property = inf_text_gtk_view_set_property;
  object_class-&gt;get_property = inf_text_gtk_view_get_property;

  g_object_class_install_property(
    object_class,
    PROP_IO,
    g_param_spec_object(
      "io",
      "IO",
      "The IO object to schedule timeouts",
      INF_TYPE_IO,
      G_PARAM_READWRITE | G_PARAM_CONSTRUCT_ONLY
    )
  );

  g_object_class_install_property(
    object_class,
    PROP_VIEW,
    g_param_spec_object(
      "view",
      "View",
      "The underlying GtkTextView",
      GTK_TYPE_TEXT_VIEW,
      G_PARAM_READWRITE | G_PARAM_CONSTRUCT_ONLY
    )
  );

  g_object_class_install_property(
    object_class,
    PROP_USER_TABLE,
    g_param_spec_object(
      "user-table",
      "User table",
      "The user table containing the users of the session shown in the view",
      INF_TYPE_USER_TABLE,
      G_PARAM_READWRITE | G_PARAM_CONSTRUCT_ONLY
    )
  );

  g_object_class_install_property(
    object_class,
    PROP_ACTIVE_USER,
    g_param_spec_object(
      "active-user",
      "Active user",
      "The user for which to show the view",
      INF_TEXT_TYPE_USER,
      G_PARAM_READWRITE
    )
  );

  g_object_class_install_property(
    object_class,
    PROP_SHOW_REMOTE_CURSORS,
    g_param_spec_boolean(
      "show-remote-cursors",
      "Show remote cursors",
      "Whether to show cursors of non-local users",
      TRUE,
      G_PARAM_READWRITE
    )
  );

  g_object_class_install_property(
    object_class,
    PROP_SHOW_REMOTE_SELECTIONS,
    g_param_spec_boolean(
      "show-remote-selections",
      "Show remote selections",
      "Whether to highlight text selected by non-local users",
      TRUE,
      G_PARAM_READWRITE
    )
  );

  g_object_class_install_property(
    object_class,
    PROP_SHOW_REMOTE_CURRENT_LINES,
    g_param_spec_boolean(
      "show-remote-current-lines",
      "Show remote current lines",
      "Whether to highlight the line in which the cursor of non-local users is",
      TRUE,
      G_PARAM_READWRITE
    )
  );
}

/**
 * inf_text_gtk_view_new: (constructor)
 * @io: A #InfIo.
 * @view: A #GtkTextView.
 * @user_table: The #InfUserTable for the text session displayed in @view.
 *
 * Creates a new #InfTextGtkView for @view. This draws remote user's cursors
 * and selections into the text view.
 *
 * Returns: (transfer full): A new #InfTextGtkView.
 */
InfTextGtkView*
inf_text_gtk_view_new(InfIo* io,
                      GtkTextView* view,
                      InfUserTable* user_table)
{
  GObject* object;

  g_return_val_if_fail(INF_IS_IO(io), NULL);
  g_return_val_if_fail(GTK_IS_TEXT_VIEW(view), NULL);
  g_return_val_if_fail(INF_IS_USER_TABLE(user_table), NULL);

  object = g_object_new(
    INF_TEXT_GTK_TYPE_VIEW,
    "io", io,
    "view", view,
    "user-table", user_table,
    NULL
  );

  return INF_TEXT_GTK_VIEW(object);
}

/**
 * inf_text_gtk_view_get_text_view:
 * @view: A #InfTextGtkView.
 *
 * Returns the underlying #GtkTextView.
 *
 * Returns: (transfer none): The #InfTextGtkView's #GtkTextView.
 **/
GtkTextView*
inf_text_gtk_view_get_text_view(InfTextGtkView* view)
{
  g_return_val_if_fail(INF_TEXT_GTK_IS_VIEW(view), NULL);
  return INF_TEXT_GTK_VIEW_PRIVATE(view)-&gt;textview;
}

/**
 * inf_text_gtk_view_get_user_table:
 * @view: A #InfTextGtkView.
 *
 * Returns the #InfUserTable containing the users of the session the
 * #InfTextGtkView's #GtkTextView is displaying.
 *
 * Returns: (transfer none): The #InfTextGtkView's #InfUserTable.
 */
InfUserTable*
inf_text_gtk_view_get_user_table(InfTextGtkView* view)
{
  g_return_val_if_fail(INF_TEXT_GTK_IS_VIEW(view), NULL);
  return INF_TEXT_GTK_VIEW_PRIVATE(view)-&gt;user_table;
}

/**
 * inf_text_gtk_view_set_active_user:
 * @view: A #InfTextGtkView.
 * @user: (allow-none): A user from @view's user table, or %NULL.
 *
 * Sets the user for which perspective to draw the view. The selection and
 * cursor position is not drawn for this user since it is assumed that the
 * view's buffer cursor position and selection match the active user ones
 * (which is automatically the case if the buffer is managed by a
 * #InfTextGtkBuffer).
 */
void
inf_text_gtk_view_set_active_user(InfTextGtkView* view,
                                  InfTextUser* user)
{
  InfTextGtkViewPrivate* priv;
  InfTextUser* active_user;

  g_return_if_fail(INF_TEXT_GTK_IS_VIEW(view));
  g_return_if_fail(user == NULL || INF_TEXT_IS_USER(user));

  priv = INF_TEXT_GTK_VIEW_PRIVATE(view);
  g_return_if_fail(
    user == NULL ||
    inf_user_table_lookup_user_by_id(
      priv-&gt;user_table,
      inf_user_get_id(INF_USER(user))
    ) == INF_USER(user)
  );

  if(priv-&gt;active_user != NULL)
  {
    active_user = priv-&gt;active_user;
    priv-&gt;active_user = NULL;

    inf_text_gtk_view_user_added(view, active_user);
  }

  if(user != NULL)
  {
    inf_text_gtk_view_user_removed(view, user);
  }

  priv-&gt;active_user = user;
  g_object_notify(G_OBJECT(view), "active-user");
}

/**
 * inf_text_gtk_view_get_active_user:
 * @view: A #InfTextGtkView.
 *
 * Returns the active user of @view. See inf_text_gtk_view_set_active_user().
 *
 * Returns: (transfer none) (allow-none): The active user of @view.
 */
InfTextUser*
inf_text_gtk_view_get_active_user(InfTextGtkView* view)
{
  g_return_val_if_fail(INF_TEXT_GTK_IS_VIEW(view), NULL);
  return INF_TEXT_GTK_VIEW_PRIVATE(view)-&gt;active_user;
}

/**
 * inf_text_gtk_view_set_show_remote_cursors:
 * @view: A #InfTextGtkView.
 * @show: Whether to show cursors of non-local users.
 *
 * If @show is %TRUE then @view draws a cursor for each non-local user in
 * %INF_USER_ACTIVE status in that user's color into its underlying
 * #GtkTextView. If it is %FALSE then remote cursors are not drawn.
 */
void
inf_text_gtk_view_set_show_remote_cursors(InfTextGtkView* view,
                                          gboolean show)
{
  InfTextGtkViewPrivate* priv;
  
  g_return_if_fail(INF_TEXT_GTK_IS_VIEW(view));
  priv = INF_TEXT_GTK_VIEW_PRIVATE(view);

  if(priv-&gt;show_remote_cursors != show)
  {
    gtk_widget_queue_draw(GTK_WIDGET(priv-&gt;textview));

    priv-&gt;show_remote_cursors = show;
    g_object_notify(G_OBJECT(view), "show-remote-cursors");
  }
}

/**
 * inf_text_gtk_view_set_show_remote_selections:
 * @view: A #InfTextGtkView.
 * @show: Whether to show selections of non-local users.
 *
 * If @show is %TRUE then @view draws the selection ranges for each non-local
 * user in %INF_USER_ACTIVE status. The selection range is drawn shaded in
 * that user's color on top of the author color which indicates who wrote the
 * selected text. If more than one user has a given piece of text selected
 * then an alternating stripe pattern with each of the user's colors is drawn.
 * If @show is %FALSE then selection ranges of remote users are not drawn.
 */
void
inf_text_gtk_view_set_show_remote_selections(InfTextGtkView* view,
                                             gboolean show)
{
  InfTextGtkViewPrivate* priv;
  
  g_return_if_fail(INF_TEXT_GTK_IS_VIEW(view));
  priv = INF_TEXT_GTK_VIEW_PRIVATE(view);

  if(priv-&gt;show_remote_selections != show)
  {
    gtk_widget_queue_draw(GTK_WIDGET(priv-&gt;textview));

    priv-&gt;show_remote_selections = show;
    g_object_notify(G_OBJECT(view), "show-remote-selections");
  }
}

/**
 * inf_text_gtk_view_set_show_remote_current_lines:
 * @view: A #InfTextGtkView.
 * @show: Whether to highlight the current line of non-local users.
 *
 * If @show is %TRUE then all lines in which the cursor of a non-local user
 * in %INF_USER_ACTIVE status is is highlighted with that user's color, similar
 * to GtkSourceView's "highlight current line" functionality. If it is %FALSE
 * then the current line of non-local users is not highlighted.
 */
void
inf_text_gtk_view_set_show_remote_current_lines(InfTextGtkView* view,
                                                gboolean show)
{
  InfTextGtkViewPrivate* priv;

  g_return_if_fail(INF_TEXT_GTK_IS_VIEW(view));
  priv = INF_TEXT_GTK_VIEW_PRIVATE(view);

  if(priv-&gt;show_remote_current_lines != show)
  {
    gtk_widget_queue_draw(GTK_WIDGET(priv-&gt;textview));

    priv-&gt;show_remote_current_lines = show;
    g_object_notify(G_OBJECT(view), "show-remote-current-lines");
  }
}

/* vim:set et sw=2 ts=2: */
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>inf-tcp-connection.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
/* libinfinity - a GObject-based infinote implementation
 * Copyright (C) 2007-2015 Armin Burgmeier &lt;armin@arbur.net&gt;
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston,
 * MA 02110-1301, USA.
 */

/**
 * SECTION:inf-tcp-connection
 * @title: InfTcpConnection
 * @short_description: Represents a TCP-based connection to a remote host
 * @include: libinfinity/common/inf-tcp-connection.h
 * @stability: Unstable
 *
 * #InfTcpConnection represents a TCP connection to a remove host. It is a
 * wrapper around a native socket object and integrates into the main loop
 * provided by #InfIo. An arbitrary amount of data can be sent with the
 * object, extra data will be buffered and automatically transmitted once
 * kernel space becomes available.
 *
 * The TCP connection properties should be set and then
 * inf_tcp_connection_open() be called to open a connection. If the
 * #InfTcpConnection:resolver property is set, then
 * #InfTcpConnection:remote-address and #InfTcpConnection:remote-port are
 * ignored, and the hostname as configured in the resolver will be resolved.
 * When the hostname has been resolved and a connection has been made, the
 * #InfTcpConnection:remote-address and #InfTcpConnection:remote-port
 * properties are updated to reflect the address actually connected to.
 **/

#include &lt;libinfinity/common/inf-tcp-connection.h&gt;
#include &lt;libinfinity/common/inf-tcp-connection-private.h&gt;
#include &lt;libinfinity/common/inf-name-resolver.h&gt;
#include &lt;libinfinity/common/inf-ip-address.h&gt;
#include &lt;libinfinity/common/inf-io.h&gt;
#include &lt;libinfinity/common/inf-native-socket.h&gt;
#include &lt;libinfinity/inf-signals.h&gt;
#include &lt;libinfinity/inf-i18n.h&gt;
#include &lt;libinfinity/inf-define-enum.h&gt;

#include &lt;unistd.h&gt; /* For ssize_t */

#include "config.h"

#ifndef G_OS_WIN32
# include &lt;sys/types.h&gt;
# include &lt;sys/socket.h&gt;
# include &lt;netinet/in.h&gt;
# include &lt;net/if.h&gt;
# include &lt;arpa/inet.h&gt;
# include &lt;unistd.h&gt;
# include &lt;fcntl.h&gt;

# include &lt;errno.h&gt;
# include &lt;string.h&gt;
#else
# include &lt;ws2tcpip.h&gt;
#endif

static const GEnumValue inf_tcp_connection_status_values[] = {
  {
    INF_TCP_CONNECTION_CONNECTING,
    "INF_TCP_CONNECTION_CONNECTING",
    "connecting"
  }, {
    INF_TCP_CONNECTION_CONNECTED,
    "INF_TCP_CONNECTION_CONNECTED",
    "connected"
  }, {
    INF_TCP_CONNECTION_CLOSED,
    "INF_TCP_CONNECTION_CLOSED",
    "closed"
  }, {
    0,
    NULL,
    NULL
  }
};

typedef struct _InfTcpConnectionPrivate InfTcpConnectionPrivate;
struct _InfTcpConnectionPrivate {
  InfIo* io;
  InfIoEvent events;
  InfIoWatch* watch;

  InfNameResolver* resolver;
  guint resolver_index;

  InfTcpConnectionStatus status;
  InfNativeSocket socket;
  InfKeepalive keepalive;

  InfIpAddress* remote_address;
  guint remote_port;
  unsigned int device_index;

  guint8* queue;
  gsize front_pos;
  gsize back_pos;
  gsize alloc;
};

enum {
  PROP_0,

  PROP_IO,
  PROP_RESOLVER,

  PROP_STATUS,
  PROP_KEEPALIVE,

  PROP_REMOTE_ADDRESS,
  PROP_REMOTE_PORT,
  PROP_LOCAL_ADDRESS,
  PROP_LOCAL_PORT,

  PROP_DEVICE_INDEX,
  PROP_DEVICE_NAME
};

enum {
  SENT,
  RECEIVED,
  ERROR_, /* ERROR is a #define on Win32 */

  LAST_SIGNAL
};

#define INF_TCP_CONNECTION_PRIVATE(obj) (G_TYPE_INSTANCE_GET_PRIVATE((obj), INF_TYPE_TCP_CONNECTION, InfTcpConnectionPrivate))

static guint tcp_connection_signals[LAST_SIGNAL];

INF_DEFINE_ENUM_TYPE(InfTcpConnectionStatus, inf_tcp_connection_status, inf_tcp_connection_status_values)
G_DEFINE_TYPE_WITH_CODE(InfTcpConnection, inf_tcp_connection, G_TYPE_OBJECT,
  G_ADD_PRIVATE(InfTcpConnection))

static gboolean
inf_tcp_connection_addr_info(InfNativeSocket socket,
                             gboolean local,
                             InfIpAddress** address,
                             guint* port,
                             GError** error)
{
  union {
    struct sockaddr in_generic;
    struct sockaddr_in in;
    struct sockaddr_in6 in6;
  } native_addr;
  socklen_t len;
  int res;
  int code;

  len = sizeof(native_addr);

  if(local == TRUE)
    res = getsockname(socket, &amp;native_addr.in_generic, &amp;len);
  else
    res = getpeername(socket, &amp;native_addr.in_generic, &amp;len);

  if(res == -1)
  {
    code = INF_NATIVE_SOCKET_LAST_ERROR;
    inf_native_socket_make_error(code, error);
    return FALSE;
  }

  switch(native_addr.in_generic.sa_family)
  {
  case AF_INET:
    if(address != NULL)
      *address = inf_ip_address_new_raw4(native_addr.in.sin_addr.s_addr);
    if(port != NULL)
      *port = ntohs(native_addr.in.sin_port);
    break;
  case AF_INET6:
    if(address != NULL)
      *address = inf_ip_address_new_raw6(native_addr.in6.sin6_addr.s6_addr);
    if(port != NULL)
      *port = ntohs(native_addr.in6.sin6_port);
    break;
  default:
    g_assert_not_reached();
    break;
  }

  return TRUE;
}

static gboolean
inf_tcp_connection_configure_socket(InfNativeSocket socket,
                                    const InfKeepalive* keepalive,
                                    GError** error)
{

#ifdef G_OS_WIN32
  u_long argp;
#else
  int result;
#endif
  int errcode;
  GError* local_error;

  /* Configure the connection's underlying socket, by setting keepalive and
   * and nonblocking. */
#ifndef G_OS_WIN32
  result = fcntl(socket, F_GETFL);
  if(result == INVALID_SOCKET)
  {
    errcode = INF_NATIVE_SOCKET_LAST_ERROR;
    inf_native_socket_make_error(errcode, error);
    return FALSE;
  }

  if(fcntl(socket, F_SETFL, result | O_NONBLOCK) == -1)
  {
    errcode = INF_NATIVE_SOCKET_LAST_ERROR;
    inf_native_socket_make_error(errcode, error);
    return FALSE;
  }
#else
  argp = 1;
  if(ioctlsocket(socket, FIONBIO, &amp;argp) != 0)
  {
    errcode = INF_NATIVE_SOCKET_LAST_ERROR;
    inf_native_socket_make_error(errcode, error);
    return FALSE;
  }
#endif

  /* Error setting keepalives is not fatal */
  local_error = NULL;
  if(inf_keepalive_apply(keepalive, &amp;socket, 0, &amp;local_error) == FALSE)
  {
    g_warning("Failed to set keepalive on socket: %s", local_error-&gt;message);
    g_error_free(local_error);
  }

  return TRUE;
}

static void
inf_tcp_connection_system_error(InfTcpConnection* connection,
                                int code)
{
  GError* error;
  error = NULL;

  inf_native_socket_make_error(code, &amp;error);

  g_signal_emit(
    G_OBJECT(connection),
    tcp_connection_signals[ERROR_],
    0,
    error
  );

  g_error_free(error);
}

static void
inf_tcp_connection_io(InfNativeSocket* socket,
                      InfIoEvent events,
                      gpointer user_data);


static void
inf_tcp_connection_connected(InfTcpConnection* connection)
{
  InfTcpConnectionPrivate* priv;
  priv = INF_TCP_CONNECTION_PRIVATE(connection);

  priv-&gt;status = INF_TCP_CONNECTION_CONNECTED;
  priv-&gt;front_pos = 0;
  priv-&gt;back_pos = 0;

  priv-&gt;events = INF_IO_INCOMING | INF_IO_ERROR;

  if(priv-&gt;watch == NULL)
  {
    priv-&gt;watch = inf_io_add_watch(
      priv-&gt;io,
      &amp;priv-&gt;socket,
      priv-&gt;events,
      inf_tcp_connection_io,
      connection,
      NULL
    );
  }
  else
  {
    inf_io_update_watch(priv-&gt;io, priv-&gt;watch, priv-&gt;events);
  }

  g_object_freeze_notify(G_OBJECT(connection));

  /* Update adresses from resolver */
  if(priv-&gt;resolver != NULL)
  {
    if(priv-&gt;remote_address != NULL)
      inf_ip_address_free(priv-&gt;remote_address);

    priv-&gt;remote_address = inf_ip_address_copy(
      inf_name_resolver_get_address(priv-&gt;resolver, priv-&gt;resolver_index)
    );

    priv-&gt;remote_port =
      inf_name_resolver_get_port(priv-&gt;resolver, priv-&gt;resolver_index);

    g_object_notify(G_OBJECT(connection), "remote-address");
    g_object_notify(G_OBJECT(connection), "remote-port");

    priv-&gt;resolver_index = 0;
  }

  g_object_notify(G_OBJECT(connection), "status");
  g_object_notify(G_OBJECT(connection), "local-address");
  g_object_notify(G_OBJECT(connection), "local-port");
  g_object_thaw_notify(G_OBJECT(connection));
}

static gboolean
inf_tcp_connection_open_with_resolver(InfTcpConnection* connection,
                                      GError** error);

/* Handles when an error occurred during connection. Returns FALSE when the
 * error was fatal. In this case, it has already emitted the "error" signal.
 * Returns TRUE, if another connection attempt is made. */
static gboolean
inf_tcp_connection_connection_error(InfTcpConnection* connection,
                                    const GError* error)
{
  InfTcpConnectionPrivate* priv;

  priv = INF_TCP_CONNECTION_PRIVATE(connection);

  if(priv-&gt;socket != INVALID_SOCKET)
  {
    closesocket(priv-&gt;socket);
    priv-&gt;socket = INVALID_SOCKET;
  }

  if(priv-&gt;watch != NULL)
  {
    priv-&gt;events = 0;

    inf_io_remove_watch(priv-&gt;io, priv-&gt;watch);
    priv-&gt;watch = NULL;
  }

  if(priv-&gt;resolver != NULL)
  {
    /* Try next address, if there is one */
    if(priv-&gt;resolver_index &lt;
       inf_name_resolver_get_n_addresses(priv-&gt;resolver))
    {
      ++priv-&gt;resolver_index;
      if(inf_tcp_connection_open_with_resolver(connection, NULL) == TRUE)
        return TRUE;
    }

    /* No new addresses available */
    priv-&gt;resolver_index = 0;
  }

  g_signal_emit(
    G_OBJECT(connection),
    tcp_connection_signals[ERROR_],
    0,
    error
  );

  return FALSE;
}

static gboolean
inf_tcp_connection_open_real(InfTcpConnection* connection,
                             const InfIpAddress* address,
                             guint port,
                             GError** error)
{
  InfTcpConnectionPrivate* priv;

  union {
    struct sockaddr_in in;
    struct sockaddr_in6 in6;
  } native_address;

  struct sockaddr* addr;
  socklen_t addrlen;
  int result;
  int errcode;
  const InfKeepalive* keepalive;
  GError* local_error;

  priv = INF_TCP_CONNECTION_PRIVATE(connection);

  g_assert(priv-&gt;status == INF_TCP_CONNECTION_CLOSED ||
           priv-&gt;status == INF_TCP_CONNECTION_CONNECTING);

  /* Close previous socket */
  if(priv-&gt;socket != INVALID_SOCKET)
    closesocket(priv-&gt;socket);

  switch(inf_ip_address_get_family(address))
  {
  case INF_IP_ADDRESS_IPV4:
    priv-&gt;socket = socket(PF_INET, SOCK_STREAM, IPPROTO_TCP);
    addr = (struct sockaddr*)&amp;native_address.in;
    addrlen = sizeof(struct sockaddr_in);

    memcpy(
      &amp;native_address.in.sin_addr,
      inf_ip_address_get_raw(address),
      sizeof(struct in_addr)
    );

    native_address.in.sin_family = AF_INET;
    native_address.in.sin_port = htons(port);

    break;
  case INF_IP_ADDRESS_IPV6:
    priv-&gt;socket = socket(PF_INET6, SOCK_STREAM, IPPROTO_TCP);
    addr = (struct sockaddr*)&amp;native_address.in6;
    addrlen = sizeof(struct sockaddr_in6);

    memcpy(
      &amp;native_address.in6.sin6_addr,
      inf_ip_address_get_raw(address),
      sizeof(struct in6_addr)
    );

    native_address.in6.sin6_family = AF_INET6;
    native_address.in6.sin6_port = htons(port);
    native_address.in6.sin6_flowinfo = 0;
    native_address.in6.sin6_scope_id = priv-&gt;device_index;

    break;
  default:
    g_assert_not_reached();
    break;
  }

  if(priv-&gt;socket == INVALID_SOCKET)
  {
    inf_native_socket_make_error(INF_NATIVE_SOCKET_LAST_ERROR, error);
    return FALSE;
  }

  /* Set socket non-blocking and keepalive */
  keepalive = &amp;priv-&gt;keepalive;
  if(!inf_tcp_connection_configure_socket(priv-&gt;socket, keepalive, error))
  {
    closesocket(priv-&gt;socket);
    priv-&gt;socket = INVALID_SOCKET;
    return FALSE;
  }

  /* Connect */
  do
  {
    result = connect(priv-&gt;socket, addr, addrlen);
    errcode = INF_NATIVE_SOCKET_LAST_ERROR;
    if(result == -1 &amp;&amp;
       errcode != INF_NATIVE_SOCKET_EINTR &amp;&amp;
       errcode != INF_NATIVE_SOCKET_EINPROGRESS)
    {
      local_error = NULL;
      inf_native_socket_make_error(errcode, &amp;local_error);
      if(inf_tcp_connection_connection_error(connection, local_error) == TRUE)
      {
        /* In this case, we could recover from the error by connecting to a
         * different address. */
        g_error_free(local_error);
        return TRUE;
      }

      g_propagate_error(error, local_error);
      return FALSE;
    }
  } while(result == -1 &amp;&amp; errcode != INF_NATIVE_SOCKET_EINPROGRESS);

  if(result == 0)
  {
    /* Connection fully established */
    inf_tcp_connection_connected(connection);
  }
  else
  {
    g_assert(priv-&gt;watch == NULL);

    /* Connection establishment in progress */
    priv-&gt;events = INF_IO_OUTGOING | INF_IO_ERROR;

    priv-&gt;watch = inf_io_add_watch(
      priv-&gt;io,
      &amp;priv-&gt;socket,
      priv-&gt;events,
      inf_tcp_connection_io,
      connection,
      NULL
    );

    if(priv-&gt;status != INF_TCP_CONNECTION_CONNECTING)
    {
      priv-&gt;status = INF_TCP_CONNECTION_CONNECTING;
      g_object_notify(G_OBJECT(connection), "status");
    }
  }

  return TRUE;
}

static gboolean
inf_tcp_connection_open_with_resolver(InfTcpConnection* connection,
                                      GError** error)
{
  InfTcpConnectionPrivate* priv;
  GError* local_error;
  gboolean success;

  priv = INF_TCP_CONNECTION_PRIVATE(connection);

  g_assert(priv-&gt;status == INF_TCP_CONNECTION_CLOSED ||
           priv-&gt;status == INF_TCP_CONNECTION_CONNECTING);

  if(inf_name_resolver_finished(priv-&gt;resolver))
  {
    if(priv-&gt;resolver_index &lt; 
       inf_name_resolver_get_n_addresses(priv-&gt;resolver))
    {
      return inf_tcp_connection_open_real(
        connection,
        inf_name_resolver_get_address(priv-&gt;resolver, priv-&gt;resolver_index),
        inf_name_resolver_get_port(priv-&gt;resolver, priv-&gt;resolver_index),
        error
      );
    }

    /* We need to look up more addresses */
    g_object_freeze_notify(G_OBJECT(connection));
    if(priv-&gt;status != INF_TCP_CONNECTION_CONNECTING)
    {
      priv-&gt;status = INF_TCP_CONNECTION_CONNECTING;
      g_object_notify(G_OBJECT(connection), "status");
    }

    local_error = NULL;
    if(priv-&gt;resolver_index == 0)
      success = inf_name_resolver_start(priv-&gt;resolver, &amp;local_error);
    else
      success = inf_name_resolver_lookup_backup(priv-&gt;resolver, &amp;local_error);

    if(local_error != NULL)
    {
      inf_tcp_connection_connection_error(connection, local_error);
      g_propagate_error(error, local_error);
    }

    g_object_thaw_notify(G_OBJECT(connection));
    return success;
  }

  /* The resolver is currently doing something. Wait until it finishes, and
   * then try again. */
  return TRUE;
}

static gboolean
inf_tcp_connection_send_real(InfTcpConnection* connection,
                             gconstpointer data,
                             guint* len)
{
  InfTcpConnectionPrivate* priv;
  gconstpointer send_data;
  guint send_len;
  int errcode;
  ssize_t result;

  priv = INF_TCP_CONNECTION_PRIVATE(connection);
  g_assert(priv-&gt;status == INF_TCP_CONNECTION_CONNECTED);

  g_assert(data != NULL);
  g_assert(len != NULL);

  send_data = data;
  send_len = *len;

  do
  {
    result = send(
      priv-&gt;socket,
      send_data,
      send_len,
      INF_NATIVE_SOCKET_SENDRECV_FLAGS
    );

    /* Preserve error code so that it is not modified by future calls */
    errcode = INF_NATIVE_SOCKET_LAST_ERROR;

    if(result &lt; 0 &amp;&amp;
       errcode != INF_NATIVE_SOCKET_EINTR &amp;&amp;
       errcode != INF_NATIVE_SOCKET_EAGAIN)
    {
      inf_tcp_connection_system_error(connection, errcode);
      return FALSE;
    }
    else if(result == 0)
    {
      inf_tcp_connection_close(connection);
      return FALSE;
    }
    else if(result &gt; 0)
    {
      send_data = (const char*)send_data + result;
      send_len -= result;
    }
  } while( (send_len &gt; 0) &amp;&amp;
           (result &gt; 0 || errcode == INF_NATIVE_SOCKET_EINTR) &amp;&amp;
           (priv-&gt;socket != INVALID_SOCKET) );

  *len -= send_len;
  return TRUE;
}

static void
inf_tcp_connection_io_incoming(InfTcpConnection* connection)
{
  InfTcpConnectionPrivate* priv;
  gchar buf[2048];
  int errcode;
  ssize_t result;

  priv = INF_TCP_CONNECTION_PRIVATE(connection);

  g_assert(priv-&gt;status == INF_TCP_CONNECTION_CONNECTED);

  do
  {
    result = recv(priv-&gt;socket, buf, 2048, INF_NATIVE_SOCKET_SENDRECV_FLAGS);
    errcode = INF_NATIVE_SOCKET_LAST_ERROR;

    if(result &lt; 0 &amp;&amp;
       errcode != INF_NATIVE_SOCKET_EINTR &amp;&amp;
       errcode != INF_NATIVE_SOCKET_EAGAIN)
    {
      inf_tcp_connection_system_error(connection, errcode);
    }
    else if(result == 0)
    {
      inf_tcp_connection_close(connection);
    }
    else if(result &gt; 0)
    {
      g_signal_emit(
        G_OBJECT(connection),
        tcp_connection_signals[RECEIVED],
        0,
        buf,
        (guint)result
      );
    }
  } while( ((result &gt; 0) ||
            (result &lt; 0 &amp;&amp; errcode == INF_NATIVE_SOCKET_EINTR)) &amp;&amp;
           (priv-&gt;status != INF_TCP_CONNECTION_CLOSED));
}

static void
inf_tcp_connection_io_outgoing(InfTcpConnection* connection)
{
  InfTcpConnectionPrivate* priv;

  socklen_t len;
  int errcode;

  gconstpointer data;
  guint data_len;

  priv = INF_TCP_CONNECTION_PRIVATE(connection);
  switch(priv-&gt;status)
  {
  case INF_TCP_CONNECTION_CONNECTING:
    len = sizeof(int);
#ifdef G_OS_WIN32
    getsockopt(priv-&gt;socket, SOL_SOCKET, SO_ERROR, (char*)&amp;errcode, &amp;len);
#else
    getsockopt(priv-&gt;socket, SOL_SOCKET, SO_ERROR, &amp;errcode, &amp;len);
#endif

    if(errcode == 0)
    {
      inf_tcp_connection_connected(connection);
    }
    else
    {
      inf_tcp_connection_system_error(connection, errcode);
    }

    break;
  case INF_TCP_CONNECTION_CONNECTED:
    g_assert(priv-&gt;back_pos &lt; priv-&gt;front_pos);
    g_assert(priv-&gt;events &amp; INF_IO_OUTGOING);

    data = priv-&gt;queue + priv-&gt;back_pos;
    data_len = priv-&gt;front_pos - priv-&gt;back_pos;
    if(inf_tcp_connection_send_real(connection, data, &amp;data_len) == TRUE)
    {
      priv-&gt;back_pos += data_len;

      if(priv-&gt;front_pos == priv-&gt;back_pos)
      {
        /* sent everything */
        priv-&gt;front_pos = 0;
        priv-&gt;back_pos = 0;

        priv-&gt;events &amp;= ~INF_IO_OUTGOING;

        inf_io_update_watch(priv-&gt;io, priv-&gt;watch, priv-&gt;events);
      }

      g_signal_emit(
        G_OBJECT(connection),
        tcp_connection_signals[SENT],
        0,
        data,
        data_len
      );
    }

    break;
  case INF_TCP_CONNECTION_CLOSED:
  default:
    g_assert_not_reached();
    break;
  }
}

static void
inf_tcp_connection_io(InfNativeSocket* socket,
                      InfIoEvent events,
                      gpointer user_data)
{
  InfTcpConnection* connection;
  InfTcpConnectionPrivate* priv;
  socklen_t len;
  int errcode;
  GError* error;

  connection = INF_TCP_CONNECTION(user_data);
  priv = INF_TCP_CONNECTION_PRIVATE(connection);
  g_object_ref(G_OBJECT(connection));

  g_assert(priv-&gt;status != INF_TCP_CONNECTION_CLOSED);

  if(events &amp; INF_IO_ERROR)
  {
    len = sizeof(int);
#ifdef G_OS_WIN32
    getsockopt(priv-&gt;socket, SOL_SOCKET, SO_ERROR, (char*)&amp;errcode, &amp;len);
#else
    getsockopt(priv-&gt;socket, SOL_SOCKET, SO_ERROR, &amp;errcode, &amp;len);
#endif

    /* On Windows, we get INF_IO_ERROR on disconnection (at least with the
     * InfGtkIo, because FD_CLOSE is mapped to G_IO_HUP) with errcode
     * being 0. */
    /* TODO: Maybe we should change this by mapping G_IO_HUP to
     * INF_IO_INCOMING, hoping recv() does the right thing then. */
    if(errcode != 0)
    {
      error = NULL;
      inf_native_socket_make_error(errcode, &amp;error);

      if(priv-&gt;status == INF_TCP_CONNECTION_CONNECTING)
      {
        inf_tcp_connection_connection_error(connection, error);
      }
      else
      {
        g_signal_emit(
          G_OBJECT(connection),
          tcp_connection_signals[ERROR_],
          0,
          error
        );
      }

      /* Error has been reported via signal emission, and there is nothing
       * else to do with it. */
      g_error_free(error);
    }
    else
    {
      inf_tcp_connection_close(connection);
    }
  }
  else
  {
    if(events &amp; INF_IO_INCOMING)
    {
      inf_tcp_connection_io_incoming(connection);
    }

    /* It may happen that the above closes the connection and we received
     * events for both INCOMING &amp; OUTGOING here. */
    if((priv-&gt;status != INF_TCP_CONNECTION_CLOSED) &amp;&amp;
       (events &amp; INF_IO_OUTGOING))
    {
      inf_tcp_connection_io_outgoing(connection);
    }
  }

  g_object_unref(G_OBJECT(connection));
}

static void
inf_tcp_connection_resolved_cb(InfNameResolver* resolver,
                               const GError* error,
                               gpointer user_data)
{
  InfTcpConnection* connection;
  InfTcpConnectionPrivate* priv;

  connection = INF_TCP_CONNECTION(user_data);
  priv = INF_TCP_CONNECTION_PRIVATE(connection);

  /* Note that the connection could even be closed here, namely if
   * tcp_connection_close() was called while we are still resolving. */

  if(priv-&gt;status == INF_TCP_CONNECTION_CONNECTING)
  {
    if(error != NULL)
    {
      /* If there was an error, no additional addresses are available */
      g_assert(
        priv-&gt;resolver_index == inf_name_resolver_get_n_addresses(resolver)
      );

      inf_tcp_connection_connection_error(connection, error);
    }
    else
    {
      /* If there was no error, try opening a connection to the resolved
<a name="0"></a>       * address(es). */
      inf_tcp_connection_open_with_resolver(connection, NULL);
    }
<font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>  }
}

static void
inf_tcp_connection_set_resolver(InfTcpConnection* connection,
                                InfNameResolver* resolver)
{
  InfTcpConnectionPrivate* priv;
  priv = INF_TCP_CONNECTION_PRIVATE(connection);

  if(priv-&gt;resolver != NULL)
  {
    inf_signal_handlers_disconnect_by_func(
      G_OBJECT(priv-&gt;resolver),
      G_CALLBACK(inf_tcp_connection_resolved_cb),
      connection
    );

    g_object_unref(priv-&gt;resolver);
  }

  priv-&gt;resolver = resolver;

  if(resolver != NULL)
  {
    g_object_ref(resolver);

    g_signal_connect(
      G_OBJECT(resolver),
      "resolved",
      G_CALLBACK(inf_tcp_connection_resolved_cb),
      connection
    );
  }
}

static void
inf_tcp_connection_init(InfTcpConnection* connection)
{
  InfTcpConnectionPrivate* priv;
  priv = INF_TCP_CONNECTION_PRIVATE(connection);

  priv-&gt;io = NULL;
  priv-&gt;events = 0;</b></font>
  priv-&gt;watch = NULL;
  priv-&gt;resolver = NULL;
  priv-&gt;resolver_index = 0;
  priv-&gt;status = INF_TCP_CONNECTION_CLOSED;
  priv-&gt;socket = INVALID_SOCKET;
  priv-&gt;keepalive.mask = 0;

  priv-&gt;remote_address = NULL;
  priv-&gt;remote_port = 0;
  priv-&gt;device_index = 0;

  priv-&gt;queue = g_malloc(1024);
  priv-&gt;front_pos = 0;
  priv-&gt;back_pos = 0;
  priv-&gt;alloc = 1024;
}

static void
inf_tcp_connection_dispose(GObject* object)
{
  InfTcpConnection* connection;
  InfTcpConnectionPrivate* priv;

  connection = INF_TCP_CONNECTION(object);
  priv = INF_TCP_CONNECTION_PRIVATE(connection);

  if(priv-&gt;status != INF_TCP_CONNECTION_CLOSED)
    inf_tcp_connection_close(connection);

  inf_tcp_connection_set_resolver(connection, NULL);

  if(priv-&gt;io != NULL)
  {
    g_object_unref(priv-&gt;io);
    priv-&gt;io = NULL;
  }

  G_OBJECT_CLASS(inf_tcp_connection_parent_class)-&gt;dispose(object);
}

static void
inf_tcp_connection_finalize(GObject* object)
{
  InfTcpConnection* connection;
  InfTcpConnectionPrivate* priv;

  connection = INF_TCP_CONNECTION(object);
  priv = INF_TCP_CONNECTION_PRIVATE(connection);

  if(priv-&gt;remote_address != NULL)
    inf_ip_address_free(priv-&gt;remote_address);

  if(priv-&gt;socket != INVALID_SOCKET)
    closesocket(priv-&gt;socket);

  g_free(priv-&gt;queue);

  G_OBJECT_CLASS(inf_tcp_connection_parent_class)-&gt;finalize(object);
}

static void
inf_tcp_connection_set_property(GObject* object,
                                guint prop_id,
                                const GValue* value,
                                GParamSpec* pspec)
{
  InfTcpConnection* connection;
  InfTcpConnectionPrivate* priv;
#ifndef G_OS_WIN32
  const gchar* device_string;
  unsigned int new_index;
#endif
  GError* error;

  connection = INF_TCP_CONNECTION(object);
  priv = INF_TCP_CONNECTION_PRIVATE(connection);

  switch(prop_id)
  {
  case PROP_IO:
    g_assert(priv-&gt;status == INF_TCP_CONNECTION_CLOSED);
    if(priv-&gt;io != NULL) g_object_unref(G_OBJECT(priv-&gt;io));
    priv-&gt;io = INF_IO(g_value_dup_object(value));
    break;
  case PROP_RESOLVER:
    g_assert(priv-&gt;status == INF_TCP_CONNECTION_CLOSED);

    inf_tcp_connection_set_resolver(
      connection,
      INF_NAME_RESOLVER(g_value_get_object(value))
    );

    break;
  case PROP_KEEPALIVE:
    error = NULL;

    inf_tcp_connection_set_keepalive(
      connection,
      (InfKeepalive*)g_value_get_boxed(value),
      &amp;error
    );
    
    if(error != NULL)
    {
      g_warning("Failed to set keepalive settings: %s\n", error-&gt;message);
      g_error_free(error);
    }

    break;
  case PROP_REMOTE_ADDRESS:
    g_assert(priv-&gt;status == INF_TCP_CONNECTION_CLOSED);
    if(priv-&gt;remote_address != NULL)
      inf_ip_address_free(priv-&gt;remote_address);
    priv-&gt;remote_address = (InfIpAddress*)g_value_dup_boxed(value);
    break;
  case PROP_REMOTE_PORT:
    g_assert(priv-&gt;status == INF_TCP_CONNECTION_CLOSED);
    priv-&gt;remote_port = g_value_get_uint(value);
    break;
  case PROP_DEVICE_INDEX:
    g_assert(priv-&gt;status == INF_TCP_CONNECTION_CLOSED);
    /* TODO: Verify that such a device exists */
    priv-&gt;device_index = g_value_get_uint(value);
    g_object_notify(G_OBJECT(object), "device-name");
    break;
  case PROP_DEVICE_NAME:
#ifdef G_OS_WIN32
    /* TODO: We can probably implement this using GetInterfaceInfo() */
    g_warning("The device-name property is not implemented on Win32");
#else
    g_assert(priv-&gt;status == INF_TCP_CONNECTION_CLOSED);
    device_string = g_value_get_string(value);
    if(device_string == NULL) priv-&gt;device_index = 0;

    new_index = if_nametoindex(device_string);
    if(new_index == 0)
    {
      g_warning(_("Interface `%s' does not exist"), device_string);
    }
    else
    {
      priv-&gt;device_index = new_index;
      g_object_notify(G_OBJECT(object), "device-index");
    }
#endif
    break;
  default:
    G_OBJECT_WARN_INVALID_PROPERTY_ID(object, prop_id, pspec);
    break;
  }
}

static void
inf_tcp_connection_get_property(GObject* object,
                                guint prop_id,
                                GValue* value,
                                GParamSpec* pspec)
{
  InfTcpConnection* connection;
  InfTcpConnectionPrivate* priv;
  InfIpAddress* address;
  guint port;
  GError* error;
#ifndef G_OS_WIN32
<a name="1"></a>  char device_name[IF_NAMESIZE];
#endif

<font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>  connection = INF_TCP_CONNECTION(object);
  priv = INF_TCP_CONNECTION_PRIVATE(connection);

  switch(prop_id)
  {
  case PROP_IO:
    g_value_set_object(value, G_OBJECT(priv-&gt;io));
    break;
  case PROP_RESOLVER:
    g_value_set_object(value, G_OBJECT(priv-&gt;resolver));
    break;
  case PROP_KEEPALIVE:
    g_value_set_boxed(value, &amp;priv-&gt;keepalive);
    break;
  case PROP_STATUS:
    g_value_set_enum(value, priv-&gt;status);
    break;
  case PROP_REMOTE_ADDRESS:
    g_value_set_static_boxed(value, priv-&gt;remote_address);
    break;
  case PROP_REMOTE_PORT:
    g_value_set_uint(value, priv-&gt;remote_port);
    break;
  case PROP_LOCAL_ADDRESS:</b></font>
    g_assert(priv-&gt;socket != INVALID_SOCKET);

    error = NULL;
    inf_tcp_connection_addr_info(priv-&gt;socket, TRUE, &amp;address, NULL, &amp;error);

    if(error != NULL)
    {
      g_warning(_("Failed to retrieve local address: %s"), error-&gt;message);
      g_error_free(error);
      g_value_set_boxed(value, NULL);
    }
    else
    {
      g_value_take_boxed(value, address);
    }

    break;
  case PROP_LOCAL_PORT:
    g_assert(priv-&gt;socket != INVALID_SOCKET);

    error = NULL;
    inf_tcp_connection_addr_info(priv-&gt;socket, TRUE, NULL, &amp;port, &amp;error);

    if(error != NULL)
    {
      g_warning(_("Failed to retrieve local port: %s"), error-&gt;message);
      g_error_free(error);
      g_value_set_uint(value, 0);
    }
    else
    {
      g_value_set_uint(value, port);
    }

    break;
  case PROP_DEVICE_INDEX:
    g_value_set_uint(value, priv-&gt;device_index);
    break;
  case PROP_DEVICE_NAME:
#ifdef G_OS_WIN32
    /* TODO: We can probably implement this using GetInterfaceInfo() */
    g_warning(_("The device-name property is not implemented on Win32"));
    g_value_set_string(value, NULL);
#else
    if(priv-&gt;device_index == 0)
    {
      g_value_set_string(value, NULL);
    }
    else
    {
      if(if_indextoname(priv-&gt;device_index, device_name) == NULL)
      {
        g_warning(
          /* Failed to get name for device &lt;Index&gt;: &lt;Reason&gt; */
          _("Failed to get name for device %u: %s"),
          priv-&gt;device_index,
          strerror(errno)
        );

        g_value_set_string(value, NULL);
      }
      else
      {
        g_value_set_string(value, device_name);
      }
    }
#endif
    break;
  default:
    G_OBJECT_WARN_INVALID_PROPERTY_ID(object, prop_id, pspec);
    break;
  }
}

static void
inf_tcp_connection_error(InfTcpConnection* connection,
                         GError* error)
{
  InfTcpConnectionPrivate* priv;
  priv = INF_TCP_CONNECTION_PRIVATE(connection);

  /* Normally, it would be enough to check one of both conditions, but socket
   * may be already set with status still being CLOSED during
   * inf_tcp_connection_open(). */
  if(priv-&gt;watch != NULL)
  {
    priv-&gt;events = 0;

    inf_io_remove_watch(priv-&gt;io, priv-&gt;watch);
    priv-&gt;watch = NULL;
  }

  if(priv-&gt;status != INF_TCP_CONNECTION_CLOSED)
  {
<a name="2"></a>    priv-&gt;status = INF_TCP_CONNECTION_CLOSED;
    g_object_notify(G_OBJECT(connection), "status");
  }
<font color="#980517"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>}

static void
inf_tcp_connection_class_init(InfTcpConnectionClass* tcp_connection_class)
{
  GObjectClass* object_class;
  object_class = G_OBJECT_CLASS(tcp_connection_class);

  object_class-&gt;dispose = inf_tcp_connection_dispose;
  object_class-&gt;finalize = inf_tcp_connection_finalize;
  object_class-&gt;set_property = inf_tcp_connection_set_property;
  object_class-&gt;get_property = inf_tcp_connection_get_property;

  tcp_connection_class-&gt;sent = NULL;
  tcp_connection_class-&gt;received = NULL;</b></font>
  tcp_connection_class-&gt;error = inf_tcp_connection_error;

  g_object_class_install_property(
    object_class,
    PROP_IO,
    g_param_spec_object(
      "io",
      "IO",
      "I/O handler",
      INF_TYPE_IO,
      G_PARAM_READWRITE | G_PARAM_CONSTRUCT_ONLY
    )
  );

  g_object_class_install_property(
    object_class,
    PROP_RESOLVER,
    g_param_spec_object(
      "resolver",
      "Resolver",
      "The hostname resolver",
      INF_TYPE_NAME_RESOLVER,
      G_PARAM_READWRITE | G_PARAM_CONSTRUCT
    )
  );

  g_object_class_install_property(
    object_class,
    PROP_STATUS,
    g_param_spec_enum(
      "status",
      "Status",
      "Status of the TCP connection",
      INF_TYPE_TCP_CONNECTION_STATUS,
      INF_TCP_CONNECTION_CLOSED,
      G_PARAM_READABLE
    )
  );

  g_object_class_install_property(
    object_class,
    PROP_KEEPALIVE,
    g_param_spec_boxed(
      "keepalive",
      "Keepalive",
      "The keepalive settings for the connection",
      INF_TYPE_KEEPALIVE,
      G_PARAM_READWRITE
    )
  );

  g_object_class_install_property(
    object_class,
    PROP_REMOTE_ADDRESS,
    g_param_spec_boxed(
      "remote-address",
      "Remote address",
      "Address to connect to",
      INF_TYPE_IP_ADDRESS,
      G_PARAM_READWRITE
    )
  );

  g_object_class_install_property(
    object_class,
    PROP_REMOTE_PORT,
    g_param_spec_uint(
      "remote-port",
      "Remote port",
      "Port to connect to",
      0,
      65535,
      0,
      G_PARAM_READWRITE
    )
  );

  g_object_class_install_property(
    object_class,
    PROP_LOCAL_ADDRESS,
    g_param_spec_boxed(
      "local-address",
      "Local address",
      "The local address of the connection",
      INF_TYPE_IP_ADDRESS,
      G_PARAM_READABLE
    )
  );

  g_object_class_install_property(
    object_class,
    PROP_LOCAL_PORT,
    g_param_spec_uint(
      "local-port",
      "Local port",
      "The local port of the connection",
      0,
      65535,
      0,
      G_PARAM_READABLE
    )
  );

  g_object_class_install_property(
    object_class,
    PROP_DEVICE_INDEX,
    g_param_spec_uint(
      "device-index",
      "Device index",
      "The index of the device to use for the connection",
      0,
      G_MAXUINT,
      0,
      G_PARAM_READWRITE
    )
  );

  g_object_class_install_property(
    object_class,
    PROP_DEVICE_NAME,
    g_param_spec_string(
      "device-name",
      "Device name",
      "The name of the device to use for the connection, such as `eth0'",
      NULL,
      G_PARAM_READWRITE
    )
  );

  /**
   * InfTcpConnection::sent:
   * @connection: The #InfTcpConnection through which the data has been sent.
   * @data: A #gpointer referring to the data that has been sent.
   * @length: A #guint holding the number of bytes that has been sent.
   *
   * This signal is emitted whenever data has been sent over the connection.
   */
  tcp_connection_signals[SENT] = g_signal_new(
    "sent",
    G_OBJECT_CLASS_TYPE(object_class),
    G_SIGNAL_RUN_LAST,
    G_STRUCT_OFFSET(InfTcpConnectionClass, sent),
    NULL, NULL,
    NULL,
    G_TYPE_NONE,
    2,
    G_TYPE_POINTER,
    G_TYPE_UINT
  );

  /**
   * InfTcpConnection::received:
   * @connection: The #InfTcpConnection through which the data has been
   * received.
   * @data: A #gpointer referring to the data that has been received.
   * @length: A #guint holding the number of bytes that has been received.
   *
   * This signal is emitted whenever data has been received from the
   * connection.
   */
  tcp_connection_signals[RECEIVED] = g_signal_new(
    "received",
    G_OBJECT_CLASS_TYPE(object_class),
    G_SIGNAL_RUN_LAST,
    G_STRUCT_OFFSET(InfTcpConnectionClass, received),
    NULL, NULL,
    NULL,
    G_TYPE_NONE,
    2,
    G_TYPE_POINTER,
    G_TYPE_UINT
  );

  /**
   * InfTcpConnection::error:
   * @connection: The erroneous #InfTcpConnection.
   * @error: A pointer to a #GError object with details on the error.
   *
   * This signal is emitted when an error occurred with the connection. If the
   * error is fatal, the connection will change its status to
   * %INF_TCP_CONNECTION_CLOSED.
   */
  tcp_connection_signals[ERROR_] = g_signal_new(
    "error",
    G_OBJECT_CLASS_TYPE(object_class),
    G_SIGNAL_RUN_LAST,
    G_STRUCT_OFFSET(InfTcpConnectionClass, error),
    NULL, NULL,
    g_cclosure_marshal_VOID__POINTER,
    G_TYPE_NONE,
    1,
    G_TYPE_ERROR
  );
}

/**
 * inf_tcp_connection_new: (constructor)
 * @io: A #InfIo object used to watch for activity.
 * @remote_addr: The address to eventually connect to.
 * @remote_port: The port to eventually connect to.
 *
 * Creates a new #InfTcpConnection. The arguments are stored as properties for
 * an eventual inf_tcp_connection_open() call, this function itself does not
 * establish a connection.
 *
 * Returns: (transfer full): A new #InfTcpConnection. Free with
 * g_object_unref().
 **/
InfTcpConnection*
inf_tcp_connection_new(InfIo* io,
                       const InfIpAddress* remote_addr,
                       guint remote_port)
{
  InfTcpConnection* tcp;

  g_return_val_if_fail(INF_IS_IO(io), NULL);
  g_return_val_if_fail(remote_addr != NULL, NULL);
  g_return_val_if_fail(remote_port &lt;= 65535, NULL);

  tcp = INF_TCP_CONNECTION(
    g_object_new(
      INF_TYPE_TCP_CONNECTION,
      "io", io,
      "remote-address", remote_addr,
      "remote-port", remote_port,
      NULL
    )
  );

  return tcp;
}

/**
 * inf_tcp_connection_new_and_open: (constructor)
 * @io: A #InfIo object used to watch for activity.
 * @remote_addr: The address to connect to.
 * @remote_port: The port to connect to.
 * @error: Location to store error information.
 *
 * Creates a new #InfTcpConnection and connects it to the given TCP endpoint.
 * Like inf_tcp_connection_new(), but calls inf_tcp_connection_open().
 *
 * Returns: (transfer full): A new #InfTcpConnection, or %NULL on error.
 * Free with g_object_unref().
 **/
InfTcpConnection*
inf_tcp_connection_new_and_open(InfIo* io,
                                const InfIpAddress* remote_addr,
                                guint remote_port,
                                GError** error)
{
  InfTcpConnection* tcp;

  g_return_val_if_fail(INF_IS_IO(io), NULL);
  g_return_val_if_fail(remote_addr != NULL, NULL);
  g_return_val_if_fail(remote_port &lt;= 65535, NULL);
  g_return_val_if_fail(error == NULL || *error == NULL, NULL);

  tcp = inf_tcp_connection_new(io, remote_addr, remote_port);

  if(inf_tcp_connection_open(tcp, error) == FALSE)
  {
    g_object_unref(tcp);
    return NULL;
  }

  return tcp;
}

/**
 * inf_tcp_connection_new_resolve: (constructor)
 * @io: A #InfIo object used to watch for activity.
 * @resolver: The hostname resolver object used to look up the remote
 * hostname.
 *
 * Creates a new #InfTcpConnection and instead of setting the remote IP
 * address and port number directly, a hostname resolver is used to look up
 * the remote hostname before connecting. This has the advantage that all
 * available addresses for that hostname are tried before giving up.
 *
 * The argument is stored as a property for an eventual
 * inf_tcp_connection_open() call, this function itself does not
 * establish a connection.
 *
 * Returns: (transfer full): A new #InfTcpConnection. Free with
 * g_object_unref().
 */
InfTcpConnection*
inf_tcp_connection_new_resolve(InfIo* io,
                               InfNameResolver* resolver)
{
  InfTcpConnection* tcp;

  g_return_val_if_fail(INF_IS_IO(io), NULL);
  g_return_val_if_fail(INF_IS_NAME_RESOLVER(resolver), NULL);

  tcp = INF_TCP_CONNECTION(
    g_object_new(
      INF_TYPE_TCP_CONNECTION,
      "io", io,
      "resolver", resolver,
      NULL
    )
  );

  return tcp;
}

/**
 * inf_tcp_connection_open:
 * @connection: A #InfTcpConnection.
 * @error: Location to store error information.
 *
 * Attempts to open @connection. Make sure to have set the "remote-address"
 * and "remote-port" property before calling this function. If an error
 * occurs, the function returns %FALSE and @error is set. Note however that
 * the connection might not be fully open when the function returns
 * (check the "status" property if you need to know). If an asynchronous
 * error occurs while the connection is being opened, the "error" signal
 * is emitted.
 *
 * Returns: %FALSE if an error occurred and %TRUE otherwise.
 **/
gboolean
inf_tcp_connection_open(InfTcpConnection* connection,
                        GError** error)
{
  InfTcpConnectionPrivate* priv;

  g_return_val_if_fail(INF_IS_TCP_CONNECTION(connection), FALSE);
  priv = INF_TCP_CONNECTION_PRIVATE(connection);

  g_return_val_if_fail(priv-&gt;io != NULL, FALSE);
  g_return_val_if_fail(priv-&gt;status == INF_TCP_CONNECTION_CLOSED, FALSE);

  g_return_val_if_fail(
    priv-&gt;remote_address != NULL || priv-&gt;resolver != NULL,
    FALSE
  );

  g_return_val_if_fail(
    priv-&gt;remote_port != 0 ||
    priv-&gt;resolver != NULL,
    FALSE
  );

  if(priv-&gt;resolver != NULL)
  {
    g_assert(priv-&gt;resolver_index == 0);
    return inf_tcp_connection_open_with_resolver(connection, error);
  }
  else
  {
    return inf_tcp_connection_open_real(
      connection,
      priv-&gt;remote_address,
      priv-&gt;remote_port,
      error
    );
  }
}

/**
 * inf_tcp_connection_close:
 * @connection: A #InfTcpConnection.
 *
 * Closes a TCP connection that is either open or currently connecting.
 **/
void
inf_tcp_connection_close(InfTcpConnection* connection)
{
  InfTcpConnectionPrivate* priv;

  g_return_if_fail(INF_IS_TCP_CONNECTION(connection));

  priv = INF_TCP_CONNECTION_PRIVATE(connection);
  g_return_if_fail(priv-&gt;status != INF_TCP_CONNECTION_CLOSED);

  priv-&gt;events = 0;

  if(priv-&gt;watch != NULL)
  {
    inf_io_remove_watch(priv-&gt;io, priv-&gt;watch);
    priv-&gt;watch = NULL;
  }

  priv-&gt;front_pos = 0;
  priv-&gt;back_pos = 0;

  priv-&gt;status = INF_TCP_CONNECTION_CLOSED;
  g_object_notify(G_OBJECT(connection), "status");
}

/**
 * inf_tcp_connection_send:
 * @connection: A #InfTcpConnection with status %INF_TCP_CONNECTION_CONNECTED.
 * @data: (type guint8*) (array length=len): The data to send.
 * @len: Number of bytes to send.
 *
 * Sends data through the TCP connection. The data is not sent immediately,
 * but enqueued to a buffer and will be sent as soon as kernel space
 * becomes available. The "sent" signal will be emitted when data has
 * really been sent.
 **/
void
inf_tcp_connection_send(InfTcpConnection* connection,
                        gconstpointer data,
                        guint len)
{
  InfTcpConnectionPrivate* priv;
  gconstpointer sent_data;
  guint sent_len;

  g_return_if_fail(INF_IS_TCP_CONNECTION(connection));
  g_return_if_fail(len == 0 || data != NULL);

  priv = INF_TCP_CONNECTION_PRIVATE(connection);
  g_return_if_fail(priv-&gt;status == INF_TCP_CONNECTION_CONNECTED);

  g_object_ref(connection);

  /* Check whether we have data currently queued. If we have, then we need
   * to wait until that data has been sent before sending the new data. */
  if(priv-&gt;front_pos == priv-&gt;back_pos)
  {
    /* Must not be set, because otherwise we would need something to send,
     * but there is nothing in the queue. */
    g_assert(~priv-&gt;events &amp; INF_IO_OUTGOING);

    /* Nothing in queue, send data directly. */
    sent_len = len;
    sent_data = data;

    if(inf_tcp_connection_send_real(connection, data, &amp;sent_len) == TRUE)
    {
      data = (const char*)data + sent_len;
      len -= sent_len;
    }
    else
    {
      /* Sending failed. The error signal has been emitted. */
      /* Set len to zero so that we don't enqueue data. */
      len = 0;
      sent_len = 0;
    }
  }
  else
  {
    /* Nothing sent */
    sent_len = 0;
  }

  /* If we couldn't send all the data... */
  if(len &gt; 0)
  {
    /* If we have not enough space for the new data, move queue data back
     * onto the beginning of the queue, if not already */
    if(priv-&gt;alloc - priv-&gt;front_pos &lt; len &amp;&amp; priv-&gt;back_pos &gt; 0)
    {
      memmove(
        priv-&gt;queue,
        priv-&gt;queue + priv-&gt;back_pos,
        priv-&gt;front_pos - priv-&gt;back_pos
      );

      priv-&gt;front_pos -= priv-&gt;back_pos;
      priv-&gt;back_pos = 0;
    }

    /* Allocate more memory if there is still not enough space */
    if(priv-&gt;alloc - priv-&gt;front_pos &lt; len)
    {
      /* Make sure we allocate enough */
      priv-&gt;alloc = priv-&gt;front_pos + len;

      /* Always allocate a multiple of 1024 */
      if(priv-&gt;alloc % 1024 != 0)
        priv-&gt;alloc = priv-&gt;alloc + (1024 - priv-&gt;alloc % 1024);

      priv-&gt;queue = g_realloc(priv-&gt;queue, priv-&gt;alloc);
    }

    memcpy(priv-&gt;queue + priv-&gt;front_pos, data, len);
    priv-&gt;front_pos += len;

    if(~priv-&gt;events &amp; INF_IO_OUTGOING)
    {
      priv-&gt;events |= INF_IO_OUTGOING;
      inf_io_update_watch(priv-&gt;io, priv-&gt;watch, priv-&gt;events);
    }
  }

  if(sent_len &gt; 0)
  {
    g_signal_emit(
      G_OBJECT(connection),
      tcp_connection_signals[SENT],
      0,
      sent_data,
      sent_len
    );
  }

  g_object_unref(connection);
}

/**
 * inf_tcp_connection_get_remote_address:
 * @connection: A #InfTcpConnection.
 *
 * Returns the IP address of the remote site.
 *
 * Returns: (transfer none): A #InfIpAddress owned by @connection. You do not
 * need to free it, but need to make your own copy if you want to keep it
 * longer than @connection's lifetime.
 **/
InfIpAddress*
inf_tcp_connection_get_remote_address(InfTcpConnection* connection)
{
  g_return_val_if_fail(INF_IS_TCP_CONNECTION(connection), NULL);
  return INF_TCP_CONNECTION_PRIVATE(connection)-&gt;remote_address;
}

/**
 * inf_tcp_connection_get_remote_port:
 * @connection: A #InfTcpConnection.
 *
 * Returns the port of the remote site to which @connection is (or was)
 * connected or connecting.
 *
 * Returns: The port of the remote site.
 **/
guint
inf_tcp_connection_get_remote_port(InfTcpConnection* connection)
{
  g_return_val_if_fail(INF_IS_TCP_CONNECTION(connection), 0);
  return INF_TCP_CONNECTION_PRIVATE(connection)-&gt;remote_port;
}

/**
 * inf_tcp_connection_set_keepalive:
 * @connection: A #InfTcpConnection.
 * @keepalive: New keepalive settings for the connection.
 * @error: Location to store error information, if any, or %NULL.
 *
 * Sets the keepalive settings for @connection. When this function is not
 * called, the system defaults are used. If the connection is closed, then
 * the function always succeeds and stores the keepalive values internally.
 * The values are actually set on the underlying socket when the connection
 * is opened. If the connection is already open, the function might fail if
 * the system call fails.
 *
 * Returns: %TRUE if the new keeplalive values were set, or %FALSE on error.
 */
gboolean
inf_tcp_connection_set_keepalive(InfTcpConnection* connection,
                                 const InfKeepalive* keepalive,
                                 GError** error)
{
  InfTcpConnectionPrivate* priv;
  InfKeepaliveMask mask;

  g_return_val_if_fail(INF_IS_TCP_CONNECTION(connection), FALSE);
  g_return_val_if_fail(keepalive != NULL, FALSE);
  g_return_val_if_fail(error == NULL || *error == NULL, FALSE);

  priv = INF_TCP_CONNECTION_PRIVATE(connection);

  if(priv-&gt;socket != INVALID_SOCKET)
  {
    mask = priv-&gt;keepalive.mask;
    if(inf_keepalive_apply(keepalive, &amp;priv-&gt;socket, mask, error) != TRUE)
      return FALSE;
  }

  priv-&gt;keepalive = *keepalive;
  return TRUE;
}

/**
 * inf_tcp_connection_get_keepalive:
 * @connection: A #InfTcpConnection.
 *
 * Returns the current keepalive settings for @connection.
 *
 * Returns: The current keepalive configuration for @connection, owned by
 * @connection.
 */
const InfKeepalive*
inf_tcp_connection_get_keepalive(InfTcpConnection* connection)
{
  g_return_val_if_fail(INF_IS_TCP_CONNECTION(connection), NULL);
  return &amp;INF_TCP_CONNECTION_PRIVATE(connection)-&gt;keepalive;
}

/* Creates a new TCP connection from an accepted socket. This is only used
 * by InfdTcpServer and should not be considered regular API. Do not call
 * this function. Language bindings should not wrap it. */
InfTcpConnection*
_inf_tcp_connection_accepted(InfIo* io,
                             InfNativeSocket socket,
                             InfIpAddress* address,
                             guint port,
                             const InfKeepalive* keepalive,
                             GError** error)
{
  InfTcpConnection* connection;
  InfTcpConnectionPrivate* priv;
  int errcode;

  g_return_val_if_fail(INF_IS_IO(io), NULL);
  g_return_val_if_fail(socket != INVALID_SOCKET, NULL);
  g_return_val_if_fail(address != NULL, NULL);
  g_return_val_if_fail(keepalive != NULL, NULL);

  if(inf_tcp_connection_configure_socket(socket, keepalive, error) != TRUE)
    return NULL;

  g_return_val_if_fail(address != NULL, NULL);
  g_return_val_if_fail(port != 0, NULL);

  connection = inf_tcp_connection_new(io, address, port);

  inf_ip_address_free(address);

  priv = INF_TCP_CONNECTION_PRIVATE(connection);
  priv-&gt;socket = socket;
  priv-&gt;keepalive = *keepalive;

  inf_tcp_connection_connected(connection);
  return connection;
}

/* vim:set et sw=2 ts=2: */
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerHTML.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
