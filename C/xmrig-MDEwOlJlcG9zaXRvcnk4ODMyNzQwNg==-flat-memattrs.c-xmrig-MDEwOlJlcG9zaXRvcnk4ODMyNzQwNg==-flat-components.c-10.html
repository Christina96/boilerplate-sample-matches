
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 16, <button onclick='openModal()' class='match'>CODE CLONE</button></h2>
        <div class="column">
            <h3>xmrig-MDEwOlJlcG9zaXRvcnk4ODMyNzQwNg==-flat-memattrs.c</h3>
            <pre><code>1  #include &quot;private/autogen/config.h&quot;
2  #include &quot;hwloc.h&quot;
3  #include &quot;private/private.h&quot;
4  #include &quot;private/debug.h&quot;
5  static __hwloc_inline
6  hwloc_uint64_t hwloc__memattr_get_convenience_value(hwloc_memattr_id_t id,
7                                                      hwloc_obj_t node)
8  {
9    if (id == HWLOC_MEMATTR_ID_CAPACITY)
10      return node-&gt;attr-&gt;numanode.local_memory;
11    else if (id == HWLOC_MEMATTR_ID_LOCALITY)
12      return hwloc_bitmap_weight(node-&gt;cpuset);
13    else
14      assert(0);
15    return 0; &amp;bsol;* shut up the compiler */
<span onclick='openModal()' class='match'>16  }
17  void
18  hwloc_internal_memattrs_init(struct hwloc_topology *topology)
19  {
20    topology-&gt;nr_memattrs = 0;
21    topology-&gt;memattrs = NULL;
</span>22  }
23  static void
24  hwloc__setup_memattr(struct hwloc_internal_memattr_s *imattr,
25                       char *name,
26                       unsigned long flags,
27                       unsigned long iflags)
28  {
29    imattr-&gt;name = name;
30    imattr-&gt;flags = flags;
31    imattr-&gt;iflags = iflags;
32    imattr-&gt;nr_targets = 0;
33    imattr-&gt;targets = NULL;
34  }
35  void
36  hwloc_internal_memattrs_prepare(struct hwloc_topology *topology)
37  {
38    topology-&gt;memattrs = malloc(HWLOC_MEMATTR_ID_MAX * sizeof(*topology-&gt;memattrs));
39    if (!topology-&gt;memattrs)
40      return;
41    hwloc__setup_memattr(&amp;topology-&gt;memattrs[HWLOC_MEMATTR_ID_CAPACITY],
42                         (char *) &quot;Capacity&quot;,
43                         HWLOC_MEMATTR_FLAG_HIGHER_FIRST,
44                         HWLOC_IMATTR_FLAG_STATIC_NAME|HWLOC_IMATTR_FLAG_CONVENIENCE);
45    hwloc__setup_memattr(&amp;topology-&gt;memattrs[HWLOC_MEMATTR_ID_LOCALITY],
46                         (char *) &quot;Locality&quot;,
47                         HWLOC_MEMATTR_FLAG_LOWER_FIRST,
48                         HWLOC_IMATTR_FLAG_STATIC_NAME|HWLOC_IMATTR_FLAG_CONVENIENCE);
49    hwloc__setup_memattr(&amp;topology-&gt;memattrs[HWLOC_MEMATTR_ID_BANDWIDTH],
50                         (char *) &quot;Bandwidth&quot;,
51                         HWLOC_MEMATTR_FLAG_HIGHER_FIRST|HWLOC_MEMATTR_FLAG_NEED_INITIATOR,
52                         HWLOC_IMATTR_FLAG_STATIC_NAME);
53    hwloc__setup_memattr(&amp;topology-&gt;memattrs[HWLOC_MEMATTR_ID_READ_BANDWIDTH],
54                         (char *) &quot;ReadBandwidth&quot;,
55                         HWLOC_MEMATTR_FLAG_HIGHER_FIRST|HWLOC_MEMATTR_FLAG_NEED_INITIATOR,
56                         HWLOC_IMATTR_FLAG_STATIC_NAME);
57    hwloc__setup_memattr(&amp;topology-&gt;memattrs[HWLOC_MEMATTR_ID_WRITE_BANDWIDTH],
58                         (char *) &quot;WriteBandwidth&quot;,
59                         HWLOC_MEMATTR_FLAG_HIGHER_FIRST|HWLOC_MEMATTR_FLAG_NEED_INITIATOR,
60                         HWLOC_IMATTR_FLAG_STATIC_NAME);
61    hwloc__setup_memattr(&amp;topology-&gt;memattrs[HWLOC_MEMATTR_ID_LATENCY],
62                         (char *) &quot;Latency&quot;,
63                         HWLOC_MEMATTR_FLAG_LOWER_FIRST|HWLOC_MEMATTR_FLAG_NEED_INITIATOR,
64                         HWLOC_IMATTR_FLAG_STATIC_NAME);
65    hwloc__setup_memattr(&amp;topology-&gt;memattrs[HWLOC_MEMATTR_ID_READ_LATENCY],
66                         (char *) &quot;ReadLatency&quot;,
67                         HWLOC_MEMATTR_FLAG_LOWER_FIRST|HWLOC_MEMATTR_FLAG_NEED_INITIATOR,
68                         HWLOC_IMATTR_FLAG_STATIC_NAME);
69    hwloc__setup_memattr(&amp;topology-&gt;memattrs[HWLOC_MEMATTR_ID_WRITE_LATENCY],
70                         (char *) &quot;WriteLatency&quot;,
71                         HWLOC_MEMATTR_FLAG_LOWER_FIRST|HWLOC_MEMATTR_FLAG_NEED_INITIATOR,
72                         HWLOC_IMATTR_FLAG_STATIC_NAME);
73    topology-&gt;nr_memattrs = HWLOC_MEMATTR_ID_MAX;
74  }
75  static void
76  hwloc__imi_destroy(struct hwloc_internal_memattr_initiator_s *imi)
77  {
78    if (imi-&gt;initiator.type == HWLOC_LOCATION_TYPE_CPUSET)
79      hwloc_bitmap_free(imi-&gt;initiator.location.cpuset);
80  }
81  static void
82  hwloc__imtg_destroy(struct hwloc_internal_memattr_s *imattr,
83                      struct hwloc_internal_memattr_target_s *imtg)
84  {
85    if (imattr-&gt;flags &amp; HWLOC_MEMATTR_FLAG_NEED_INITIATOR) {
86      unsigned k;
87      for(k=0; k&lt;imtg-&gt;nr_initiators; k++)
88        hwloc__imi_destroy(&amp;imtg-&gt;initiators[k]);
89    }
90    free(imtg-&gt;initiators);
91  }
92  void
93  hwloc_internal_memattrs_destroy(struct hwloc_topology *topology)
94  {
95    unsigned id;
96    for(id=0; id&lt;topology-&gt;nr_memattrs; id++) {
97      struct hwloc_internal_memattr_s *imattr = &amp;topology-&gt;memattrs[id];
98      unsigned j;
99      for(j=0; j&lt;imattr-&gt;nr_targets; j++)
100        hwloc__imtg_destroy(imattr, &amp;imattr-&gt;targets[j]);
101      free(imattr-&gt;targets);
102      if (!(imattr-&gt;iflags &amp; HWLOC_IMATTR_FLAG_STATIC_NAME))
103        free(imattr-&gt;name);
104    }
105    free(topology-&gt;memattrs);
106    topology-&gt;memattrs = NULL;
107    topology-&gt;nr_memattrs = 0;
108  }
109  int
110  hwloc_internal_memattrs_dup(struct hwloc_topology *new, struct hwloc_topology *old)
111  {
112    struct hwloc_tma *tma = new-&gt;tma;
113    struct hwloc_internal_memattr_s *imattrs;
114    hwloc_memattr_id_t id;
115    imattrs = hwloc_tma_malloc(tma, old-&gt;nr_memattrs * sizeof(*imattrs));
116    if (!imattrs)
117      return -1;
118    new-&gt;memattrs = imattrs;
119    new-&gt;nr_memattrs = old-&gt;nr_memattrs;
120    memcpy(imattrs, old-&gt;memattrs, old-&gt;nr_memattrs * sizeof(*imattrs));
121    for(id=0; id&lt;old-&gt;nr_memattrs; id++) {
122      struct hwloc_internal_memattr_s *oimattr = &amp;old-&gt;memattrs[id];
123      struct hwloc_internal_memattr_s *nimattr = &amp;imattrs[id];
124      unsigned j;
125      assert(oimattr-&gt;name);
126      nimattr-&gt;name = hwloc_tma_strdup(tma, oimattr-&gt;name);
127      if (!nimattr-&gt;name) {
128        assert(!tma || !tma-&gt;dontfree); &amp;bsol;* this tma cannot fail to allocate */
129        new-&gt;nr_memattrs = id;
130        goto failed;
131      }
132      nimattr-&gt;iflags &amp;= ~HWLOC_IMATTR_FLAG_STATIC_NAME;
133      nimattr-&gt;iflags &amp;= ~HWLOC_IMATTR_FLAG_CACHE_VALID; &amp;bsol;* cache will need refresh */
134      if (!oimattr-&gt;nr_targets)
135        continue;
136      nimattr-&gt;targets = hwloc_tma_malloc(tma, oimattr-&gt;nr_targets * sizeof(*nimattr-&gt;targets));
137      if (!nimattr-&gt;targets) {
138        free(nimattr-&gt;name);
139        new-&gt;nr_memattrs = id;
140        goto failed;
141      }
142      memcpy(nimattr-&gt;targets, oimattr-&gt;targets, oimattr-&gt;nr_targets * sizeof(*nimattr-&gt;targets));
143      for(j=0; j&lt;oimattr-&gt;nr_targets; j++) {
144        struct hwloc_internal_memattr_target_s *oimtg = &amp;oimattr-&gt;targets[j];
145        struct hwloc_internal_memattr_target_s *nimtg = &amp;nimattr-&gt;targets[j];
146        unsigned k;
147        nimtg-&gt;obj = NULL; &amp;bsol;* cache will need refresh */
148        if (!oimtg-&gt;nr_initiators)
149          continue;
150        nimtg-&gt;initiators = hwloc_tma_malloc(tma, oimtg-&gt;nr_initiators * sizeof(*nimtg-&gt;initiators));
151        if (!nimtg-&gt;initiators) {
152          nimattr-&gt;nr_targets = j;
153          new-&gt;nr_memattrs = id+1;
154          goto failed;
155        }
156        memcpy(nimtg-&gt;initiators, oimtg-&gt;initiators, oimtg-&gt;nr_initiators * sizeof(*nimtg-&gt;initiators));
157        for(k=0; k&lt;oimtg-&gt;nr_initiators; k++) {
158          struct hwloc_internal_memattr_initiator_s *oimi = &amp;oimtg-&gt;initiators[k];
159          struct hwloc_internal_memattr_initiator_s *nimi = &amp;nimtg-&gt;initiators[k];
160          if (oimi-&gt;initiator.type == HWLOC_LOCATION_TYPE_CPUSET) {
161            nimi-&gt;initiator.location.cpuset = hwloc_bitmap_tma_dup(tma, oimi-&gt;initiator.location.cpuset);
162            if (!nimi-&gt;initiator.location.cpuset) {
163              nimtg-&gt;nr_initiators = k;
164              nimattr-&gt;nr_targets = j+1;
165              new-&gt;nr_memattrs = id+1;
166              goto failed;
167            }
168          } else if (oimi-&gt;initiator.type == HWLOC_LOCATION_TYPE_OBJECT) {
169            nimi-&gt;initiator.location.object.obj = NULL; &amp;bsol;* cache will need refresh */
170          }
171        }
172      }
173    }
174    return 0;
175   failed:
176    hwloc_internal_memattrs_destroy(new);
177    return -1;
178  }
179  int
180  hwloc_memattr_get_by_name(hwloc_topology_t topology,
181                            const char *name,
182                            hwloc_memattr_id_t *idp)
183  {
184    unsigned id;
185    for(id=0; id&lt;topology-&gt;nr_memattrs; id++) {
186      if (!strcmp(topology-&gt;memattrs[id].name, name)) {
187        *idp = id;
188        return 0;
189      }
190    }
191    errno = EINVAL;
192    return -1;
193  }
194  int
195  hwloc_memattr_get_name(hwloc_topology_t topology,
196                         hwloc_memattr_id_t id,
197                         const char **namep)
198  {
199    if (id &gt;= topology-&gt;nr_memattrs) {
200      errno = EINVAL;
201      return -1;
202    }
203    *namep = topology-&gt;memattrs[id].name;
204    return 0;
205  }
206  int
207  hwloc_memattr_get_flags(hwloc_topology_t topology,
208                          hwloc_memattr_id_t id,
209                          unsigned long *flagsp)
210  {
211    if (id &gt;= topology-&gt;nr_memattrs) {
212      errno = EINVAL;
213      return -1;
214    }
215    *flagsp = topology-&gt;memattrs[id].flags;
216    return 0;
217  }
218  int
219  hwloc_memattr_register(hwloc_topology_t topology,
220                         const char *_name,
221                         unsigned long flags,
222                         hwloc_memattr_id_t *id)
223  {
224    struct hwloc_internal_memattr_s *newattrs;
225    char *name;
226    unsigned i;
227    if (flags &amp; ~(HWLOC_MEMATTR_FLAG_NEED_INITIATOR|HWLOC_MEMATTR_FLAG_LOWER_FIRST|HWLOC_MEMATTR_FLAG_HIGHER_FIRST)) {
228      errno = EINVAL;
229      return -1;
230    }
231    if (!(flags &amp; (HWLOC_MEMATTR_FLAG_LOWER_FIRST|HWLOC_MEMATTR_FLAG_HIGHER_FIRST))) {
232      errno = EINVAL;
233      return -1;
234    }
235    if ((flags &amp; (HWLOC_MEMATTR_FLAG_LOWER_FIRST|HWLOC_MEMATTR_FLAG_HIGHER_FIRST))
236        == (HWLOC_MEMATTR_FLAG_LOWER_FIRST|HWLOC_MEMATTR_FLAG_HIGHER_FIRST)) {
237      errno = EINVAL;
238      return -1;
239    }
240    if (!_name) {
241      errno = EINVAL;
242      return -1;
243    }
244    for(i=0; i&lt;topology-&gt;nr_memattrs; i++) {
245      if (!strcmp(_name, topology-&gt;memattrs[i].name)) {
246        errno = EBUSY;
247        return -1;
248      }
249    }
250    name = strdup(_name);
251    if (!name)
252      return -1;
253    newattrs = realloc(topology-&gt;memattrs, (topology-&gt;nr_memattrs + 1) * sizeof(*topology-&gt;memattrs));
254    if (!newattrs) {
255      free(name);
256      return -1;
257    }
258    hwloc__setup_memattr(&amp;newattrs[topology-&gt;nr_memattrs],
259                         name, flags, 0);
260    newattrs[topology-&gt;nr_memattrs].iflags |= HWLOC_IMATTR_FLAG_CACHE_VALID;
261    *id = topology-&gt;nr_memattrs;
262    topology-&gt;nr_memattrs++;
263    topology-&gt;memattrs = newattrs;
264    return 0;
265  }
266  static int
267  match_internal_location(struct hwloc_internal_location_s *iloc,
268                          struct hwloc_internal_memattr_initiator_s *imi)
269  {
270    if (iloc-&gt;type != imi-&gt;initiator.type)
271      return 0;
272    switch (iloc-&gt;type) {
273    case HWLOC_LOCATION_TYPE_CPUSET:
274      return hwloc_bitmap_isincluded(iloc-&gt;location.cpuset, imi-&gt;initiator.location.cpuset);
275    case HWLOC_LOCATION_TYPE_OBJECT:
276      return iloc-&gt;location.object.type == imi-&gt;initiator.location.object.type
277        &amp;&amp; iloc-&gt;location.object.gp_index == imi-&gt;initiator.location.object.gp_index;
278    default:
279      return 0;
280    }
281  }
282  static int
283  to_internal_location(struct hwloc_internal_location_s *iloc,
284                       struct hwloc_location *location)
285  {
286    iloc-&gt;type = location-&gt;type;
287    switch (location-&gt;type) {
288    case HWLOC_LOCATION_TYPE_CPUSET:
289      if (!location-&gt;location.cpuset || hwloc_bitmap_iszero(location-&gt;location.cpuset)) {
290        errno = EINVAL;
291        return -1;
292      }
293      iloc-&gt;location.cpuset = location-&gt;location.cpuset;
294      return 0;
295    case HWLOC_LOCATION_TYPE_OBJECT:
296      if (!location-&gt;location.object) {
297        errno = EINVAL;
298        return -1;
299      }
300      iloc-&gt;location.object.gp_index = location-&gt;location.object-&gt;gp_index;
301      iloc-&gt;location.object.type = location-&gt;location.object-&gt;type;
302      return 0;
303    default:
304      errno = EINVAL;
305      return -1;
306    }
307  }
308  static int
309  from_internal_location(struct hwloc_internal_location_s *iloc,
310                         struct hwloc_location *location)
311  {
312    location-&gt;type = iloc-&gt;type;
313    switch (iloc-&gt;type) {
314    case HWLOC_LOCATION_TYPE_CPUSET:
315      location-&gt;location.cpuset = iloc-&gt;location.cpuset;
316      return 0;
317    case HWLOC_LOCATION_TYPE_OBJECT:
318      location-&gt;location.object = iloc-&gt;location.object.obj;
319      if (!location-&gt;location.object)
320        return -1;
321      return 0;
322    default:
323      errno = EINVAL;
324      return -1;
325    }
326  }
327  static int
328  hwloc__imi_refresh(struct hwloc_topology *topology,
329                     struct hwloc_internal_memattr_initiator_s *imi)
330  {
331    switch (imi-&gt;initiator.type) {
332    case HWLOC_LOCATION_TYPE_CPUSET: {
333      hwloc_bitmap_and(imi-&gt;initiator.location.cpuset, imi-&gt;initiator.location.cpuset, topology-&gt;levels[0][0]-&gt;cpuset);
334      if (hwloc_bitmap_iszero(imi-&gt;initiator.location.cpuset)) {
335        hwloc__imi_destroy(imi);
336        return -1;
337      }
338      return 0;
339    }
340    case HWLOC_LOCATION_TYPE_OBJECT: {
341      hwloc_obj_t obj = hwloc_get_obj_by_type_and_gp_index(topology,
342                                                           imi-&gt;initiator.location.object.type,
343                                                           imi-&gt;initiator.location.object.gp_index);
344      if (!obj) {
345        hwloc__imi_destroy(imi);
346        return -1;
347      }
348      imi-&gt;initiator.location.object.obj = obj;
349      return 0;
350    }
351    default:
352      assert(0);
353    }
354    return -1;
355  }
356  static int
357  hwloc__imtg_refresh(struct hwloc_topology *topology,
358                      struct hwloc_internal_memattr_s *imattr,
359                      struct hwloc_internal_memattr_target_s *imtg)
360  {
361    hwloc_obj_t node;
362    assert(!(imattr-&gt;iflags &amp; HWLOC_IMATTR_FLAG_CONVENIENCE));
363    if (imtg-&gt;gp_index == (hwloc_uint64_t) -1) {
364      if (imtg-&gt;type == HWLOC_OBJ_NUMANODE)
365        node = hwloc_get_numanode_obj_by_os_index(topology, imtg-&gt;os_index);
366      else if (imtg-&gt;type == HWLOC_OBJ_PU)
367        node = hwloc_get_pu_obj_by_os_index(topology, imtg-&gt;os_index);
368      else
369        node = NULL;
370    } else {
371      node = hwloc_get_obj_by_type_and_gp_index(topology, imtg-&gt;type, imtg-&gt;gp_index);
372    }
373    if (!node) {
374      hwloc__imtg_destroy(imattr, imtg);
375      return -1;
376    }
377    imtg-&gt;gp_index = node-&gt;gp_index;
378    imtg-&gt;obj = node;
379    if (imattr-&gt;flags &amp; HWLOC_MEMATTR_FLAG_NEED_INITIATOR) {
380      unsigned k, l;
381      for(k=0, l=0; k&lt;imtg-&gt;nr_initiators; k++) {
382        int err = hwloc__imi_refresh(topology, &amp;imtg-&gt;initiators[k]);
383        if (err &lt; 0)
384          continue;
385        if (k != l)
386          memcpy(&amp;imtg-&gt;initiators[l], &amp;imtg-&gt;initiators[k], sizeof(*imtg-&gt;initiators));
387        l++;
388      }
389      imtg-&gt;nr_initiators = l;
390      if (!imtg-&gt;nr_initiators) {
391        hwloc__imtg_destroy(imattr, imtg);
392        return -1;
393      }
394    }
395    return 0;
396  }
397  static void
398  hwloc__imattr_refresh(struct hwloc_topology *topology,
399                        struct hwloc_internal_memattr_s *imattr)
400  {
401    unsigned j, k;
402    for(j=0, k=0; j&lt;imattr-&gt;nr_targets; j++) {
403      int ret = hwloc__imtg_refresh(topology, imattr, &amp;imattr-&gt;targets[j]);
404      if (!ret) {
405        if (j != k)
406          memcpy(&amp;imattr-&gt;targets[k], &amp;imattr-&gt;targets[j], sizeof(*imattr-&gt;targets));
407        k++;
408      }
409    }
410    imattr-&gt;nr_targets = k;
411    imattr-&gt;iflags |= HWLOC_IMATTR_FLAG_CACHE_VALID;
412  }
413  void
414  hwloc_internal_memattrs_refresh(struct hwloc_topology *topology)
415  {
416    unsigned id;
417    for(id=0; id&lt;topology-&gt;nr_memattrs; id++) {
418      struct hwloc_internal_memattr_s *imattr = &amp;topology-&gt;memattrs[id];
419      if (imattr-&gt;iflags &amp; HWLOC_IMATTR_FLAG_CACHE_VALID)
420        continue;
421      hwloc__imattr_refresh(topology, imattr);
422    }
423  }
424  void
425  hwloc_internal_memattrs_need_refresh(struct hwloc_topology *topology)
426  {
427    unsigned id;
428    for(id=0; id&lt;topology-&gt;nr_memattrs; id++) {
429      struct hwloc_internal_memattr_s *imattr = &amp;topology-&gt;memattrs[id];
430      if (imattr-&gt;iflags &amp; HWLOC_IMATTR_FLAG_CONVENIENCE)
431        continue;
432      imattr-&gt;iflags &amp;= ~HWLOC_IMATTR_FLAG_CACHE_VALID;
433    }
434  }
435  static struct hwloc_internal_memattr_target_s *
436  hwloc__memattr_get_target(struct hwloc_internal_memattr_s *imattr,
437                            hwloc_obj_type_t target_type,
438                            hwloc_uint64_t target_gp_index,
439                            unsigned target_os_index,
440                            int create)
441  {
442    struct hwloc_internal_memattr_target_s *news, *new;
443    unsigned j;
444    for(j=0; j&lt;imattr-&gt;nr_targets; j++) {
445      if (target_type == imattr-&gt;targets[j].type)
446        if ((target_gp_index != (hwloc_uint64_t)-1 &amp;&amp; target_gp_index == imattr-&gt;targets[j].gp_index)
447            || (target_os_index != (unsigned)-1 &amp;&amp; target_os_index == imattr-&gt;targets[j].os_index))
448          return &amp;imattr-&gt;targets[j];
449    }
450    if (!create)
451      return NULL;
452    news = realloc(imattr-&gt;targets, (imattr-&gt;nr_targets+1)*sizeof(*imattr-&gt;targets));
453    if (!news)
454      return NULL;
455    imattr-&gt;targets = news;
456    new = &amp;news[imattr-&gt;nr_targets];
457    new-&gt;type = target_type;
458    new-&gt;gp_index = target_gp_index;
459    new-&gt;os_index = target_os_index;
460    new-&gt;obj = NULL;
461    imattr-&gt;iflags &amp;= ~HWLOC_IMATTR_FLAG_CACHE_VALID;
462    new-&gt;nr_initiators = 0;
463    new-&gt;initiators = NULL;
464    new-&gt;noinitiator_value = 0;
465    imattr-&gt;nr_targets++;
466    return new;
467  }
468  static struct hwloc_internal_memattr_initiator_s *
469  hwloc__memattr_get_initiator_from_location(struct hwloc_internal_memattr_s *imattr,
470                                             struct hwloc_internal_memattr_target_s *imtg,
471                                             struct hwloc_location *location);
472  int
473  hwloc_memattr_get_targets(hwloc_topology_t topology,
474                            hwloc_memattr_id_t id,
475                            struct hwloc_location *initiator,
476                            unsigned long flags,
477                            unsigned *nrp, hwloc_obj_t *targets, hwloc_uint64_t *values)
478  {
479    struct hwloc_internal_memattr_s *imattr;
480    unsigned i, found = 0, max;
481    if (flags) {
482      errno = EINVAL;
483      return -1;
484    }
485    if (!nrp || (*nrp &amp;&amp; !targets)) {
486      errno = EINVAL;
487      return -1;
488    }
489    max = *nrp;
490    if (id &gt;= topology-&gt;nr_memattrs) {
491      errno = EINVAL;
492      return -1;
493    }
494    imattr = &amp;topology-&gt;memattrs[id];
495    if (imattr-&gt;iflags &amp; HWLOC_IMATTR_FLAG_CONVENIENCE) {
496      for(i=0; ; i++) {
497        hwloc_obj_t node = hwloc_get_obj_by_type(topology, HWLOC_OBJ_NUMANODE, i);
498        if (!node)
499          break;
500        if (found&lt;max) {
501          targets[found] = node;
502          if (values)
503            values[found] = hwloc__memattr_get_convenience_value(id, node);
504        }
505        found++;
506      }
507      goto done;
508    }
509    if (!(imattr-&gt;iflags &amp; HWLOC_IMATTR_FLAG_CACHE_VALID))
510      hwloc__imattr_refresh(topology, imattr);
511    for(i=0; i&lt;imattr-&gt;nr_targets; i++) {
512      struct hwloc_internal_memattr_target_s *imtg = &amp;imattr-&gt;targets[i];
513      hwloc_uint64_t value = 0;
514      if (imattr-&gt;flags &amp; HWLOC_MEMATTR_FLAG_NEED_INITIATOR) {
515        if (initiator) {
516          struct hwloc_internal_memattr_initiator_s *imi = hwloc__memattr_get_initiator_from_location(imattr, imtg, initiator);
517          if (!imi)
518            continue;
519          value = imi-&gt;value;
520        }
521      } else {
522        value = imtg-&gt;noinitiator_value;
523      }
524      if (found&lt;max) {
525        targets[found] = imtg-&gt;obj;
526        if (values)
527          values[found] = value;
528      }
529      found++;
530    }
531   done:
532    *nrp = found;
533    return 0;
534  }
535  static struct hwloc_internal_memattr_initiator_s *
536  hwloc__memattr_target_get_initiator(struct hwloc_internal_memattr_target_s *imtg,
537                                      struct hwloc_internal_location_s *iloc,
538                                      int create)
539  {
540    struct hwloc_internal_memattr_initiator_s *news, *new;
541    unsigned k;
542    for(k=0; k&lt;imtg-&gt;nr_initiators; k++) {
543      struct hwloc_internal_memattr_initiator_s *imi = &amp;imtg-&gt;initiators[k];
544      if (match_internal_location(iloc, imi)) {
545        return imi;
546      }
547    }
548    if (!create)
549      return NULL;
550    news = realloc(imtg-&gt;initiators, (imtg-&gt;nr_initiators+1)*sizeof(*imtg-&gt;initiators));
551    if (!news)
552      return NULL;
553    new = &amp;news[imtg-&gt;nr_initiators];
554    new-&gt;initiator = *iloc;
555    if (iloc-&gt;type == HWLOC_LOCATION_TYPE_CPUSET) {
556      new-&gt;initiator.location.cpuset = hwloc_bitmap_dup(iloc-&gt;location.cpuset);
557      if (!new-&gt;initiator.location.cpuset)
558        goto out_with_realloc;
559    }
560    imtg-&gt;nr_initiators++;
561    imtg-&gt;initiators = news;
562    return new;
563   out_with_realloc:
564    imtg-&gt;initiators = news;
565    return NULL;
566  }
567  static struct hwloc_internal_memattr_initiator_s *
568  hwloc__memattr_get_initiator_from_location(struct hwloc_internal_memattr_s *imattr,
569                                             struct hwloc_internal_memattr_target_s *imtg,
570                                             struct hwloc_location *location)
571  {
572    struct hwloc_internal_memattr_initiator_s *imi;
573    struct hwloc_internal_location_s iloc;
574    assert(imattr-&gt;flags &amp; HWLOC_MEMATTR_FLAG_NEED_INITIATOR);
575    if (!location) {
576      errno = EINVAL;
577      return NULL;
578    }
579    if (to_internal_location(&amp;iloc, location) &lt; 0) {
580      errno = EINVAL;
581      return NULL;
582    }
583    imi = hwloc__memattr_target_get_initiator(imtg, &amp;iloc, 0);
584    if (!imi) {
585      errno = EINVAL;
586      return NULL;
587    }
588    return imi;
589  }
590  int
591  hwloc_memattr_get_initiators(hwloc_topology_t topology,
592                               hwloc_memattr_id_t id,
593                               hwloc_obj_t target_node,
594                               unsigned long flags,
595                               unsigned *nrp, struct hwloc_location *initiators, hwloc_uint64_t *values)
596  {
597    struct hwloc_internal_memattr_s *imattr;
598    struct hwloc_internal_memattr_target_s *imtg;
599    unsigned i, max;
600    if (flags) {
601      errno = EINVAL;
602      return -1;
603    }
604    if (!nrp || (*nrp &amp;&amp; !initiators)) {
605      errno = EINVAL;
606      return -1;
607    }
608    max = *nrp;
609    if (id &gt;= topology-&gt;nr_memattrs) {
610      errno = EINVAL;
611      return -1;
612    }
613    imattr = &amp;topology-&gt;memattrs[id];
614    if (!(imattr-&gt;flags &amp; HWLOC_MEMATTR_FLAG_NEED_INITIATOR)) {
615      *nrp = 0;
616      return 0;
617    }
618    assert(!(imattr-&gt;iflags &amp; HWLOC_IMATTR_FLAG_CONVENIENCE));
619    if (!(imattr-&gt;iflags &amp; HWLOC_IMATTR_FLAG_CACHE_VALID))
620      hwloc__imattr_refresh(topology, imattr);
621    imtg = hwloc__memattr_get_target(imattr, target_node-&gt;type, target_node-&gt;gp_index, target_node-&gt;os_index, 0);
622    if (!imtg) {
623      errno = EINVAL;
624      return -1;
625    }
626    for(i=0; i&lt;imtg-&gt;nr_initiators &amp;&amp; i&lt;max; i++) {
627      struct hwloc_internal_memattr_initiator_s *imi = &amp;imtg-&gt;initiators[i];
628      int err = from_internal_location(&amp;imi-&gt;initiator, &amp;initiators[i]);
629      assert(!err);
630      if (values)
631        values[i] = imi-&gt;value;
632    }
633    *nrp = imtg-&gt;nr_initiators;
634    return 0;
635  }
636  int
637  hwloc_memattr_get_value(hwloc_topology_t topology,
638                          hwloc_memattr_id_t id,
639                          hwloc_obj_t target_node,
640                          struct hwloc_location *initiator,
641                          unsigned long flags,
642                          hwloc_uint64_t *valuep)
643  {
644    struct hwloc_internal_memattr_s *imattr;
645    struct hwloc_internal_memattr_target_s *imtg;
646    if (flags) {
647      errno = EINVAL;
648      return -1;
649    }
650    if (id &gt;= topology-&gt;nr_memattrs) {
651      errno = EINVAL;
652      return -1;
653    }
654    imattr = &amp;topology-&gt;memattrs[id];
655    if (imattr-&gt;iflags &amp; HWLOC_IMATTR_FLAG_CONVENIENCE) {
656      *valuep = hwloc__memattr_get_convenience_value(id, target_node);
657      return 0;
658    }
659    if (!(imattr-&gt;iflags &amp; HWLOC_IMATTR_FLAG_CACHE_VALID))
660      hwloc__imattr_refresh(topology, imattr);
661    imtg = hwloc__memattr_get_target(imattr, target_node-&gt;type, target_node-&gt;gp_index, target_node-&gt;os_index, 0);
662    if (!imtg) {
663      errno = EINVAL;
664      return -1;
665    }
666    if (imattr-&gt;flags &amp; HWLOC_MEMATTR_FLAG_NEED_INITIATOR) {
667      struct hwloc_internal_memattr_initiator_s *imi = hwloc__memattr_get_initiator_from_location(imattr, imtg, initiator);
668      if (!imi)
669        return -1;
670      *valuep = imi-&gt;value;
671    } else {
672      *valuep = imtg-&gt;noinitiator_value;
673    }
674    return 0;
675  }
676  static int
677  hwloc__internal_memattr_set_value(hwloc_topology_t topology,
678                                    hwloc_memattr_id_t id,
679                                    hwloc_obj_type_t target_type,
680                                    hwloc_uint64_t target_gp_index,
681                                    unsigned target_os_index,
682                                    struct hwloc_internal_location_s *initiator,
683                                    hwloc_uint64_t value)
684  {
685    struct hwloc_internal_memattr_s *imattr;
686    struct hwloc_internal_memattr_target_s *imtg;
687    if (id &gt;= topology-&gt;nr_memattrs) {
688      errno = EINVAL;
689      return -1;
690    }
691    imattr = &amp;topology-&gt;memattrs[id];
692    if (imattr-&gt;flags &amp; HWLOC_MEMATTR_FLAG_NEED_INITIATOR) {
693      if (!initiator) {
694        errno = EINVAL;
695        return -1;
696      }
697    }
698    if (imattr-&gt;iflags &amp; HWLOC_IMATTR_FLAG_CONVENIENCE) {
699      errno = EINVAL;
700      return -1;
701    }
702    if (topology-&gt;is_loaded &amp;&amp; !(imattr-&gt;iflags &amp; HWLOC_IMATTR_FLAG_CACHE_VALID))
703      hwloc__imattr_refresh(topology, imattr);
704    imtg = hwloc__memattr_get_target(imattr, target_type, target_gp_index, target_os_index, 1);
705    if (!imtg)
706      return -1;
707    if (imattr-&gt;flags &amp; HWLOC_MEMATTR_FLAG_NEED_INITIATOR) {
708      struct hwloc_internal_memattr_initiator_s *imi = hwloc__memattr_target_get_initiator(imtg, initiator, 1);
709      if (!imi)
710        return -1;
711      imi-&gt;value = value;
712    } else {
713      imtg-&gt;noinitiator_value = value;
714    }
715    return 0;
716  }
717  int
718  hwloc_internal_memattr_set_value(hwloc_topology_t topology,
719                                   hwloc_memattr_id_t id,
720                                   hwloc_obj_type_t target_type,
721                                   hwloc_uint64_t target_gp_index,
722                                   unsigned target_os_index,
723                                   struct hwloc_internal_location_s *initiator,
724                                   hwloc_uint64_t value)
725  {
726    assert(id != HWLOC_MEMATTR_ID_CAPACITY);
727    assert(id != HWLOC_MEMATTR_ID_LOCALITY);
728    return hwloc__internal_memattr_set_value(topology, id, target_type, target_gp_index, target_os_index, initiator, value);
729  }
730  int
731  hwloc_memattr_set_value(hwloc_topology_t topology,
732                          hwloc_memattr_id_t id,
733                          hwloc_obj_t target_node,
734                          struct hwloc_location *initiator,
735                          unsigned long flags,
736                          hwloc_uint64_t value)
737  {
738    struct hwloc_internal_location_s iloc, *ilocp;
739    if (flags) {
740      errno = EINVAL;
741      return -1;
742    }
743    if (initiator) {
744      if (to_internal_location(&amp;iloc, initiator) &lt; 0) {
745        errno = EINVAL;
746        return -1;
747      }
748      ilocp = &amp;iloc;
749    } else {
750      ilocp = NULL;
751    }
752    return hwloc__internal_memattr_set_value(topology, id, target_node-&gt;type, target_node-&gt;gp_index, target_node-&gt;os_index, ilocp, value);
753  }
754  static void
755  hwloc__update_best_target(hwloc_obj_t *best_obj, hwloc_uint64_t *best_value, int *found,
756                            hwloc_obj_t new_obj, hwloc_uint64_t new_value,
757                            int keep_highest)
758  {
759    if (*found) {
760      if (keep_highest) {
761        if (new_value &lt;= *best_value)
762          return;
763      } else {
764        if (new_value &gt;= *best_value)
765          return;
766      }
767    }
768    *best_obj = new_obj;
769    *best_value = new_value;
770    *found = 1;
771  }
772  int
773  hwloc_memattr_get_best_target(hwloc_topology_t topology,
774                                hwloc_memattr_id_t id,
775                                struct hwloc_location *initiator,
776                                unsigned long flags,
777                                hwloc_obj_t *bestp, hwloc_uint64_t *valuep)
778  {
779    struct hwloc_internal_memattr_s *imattr;
780    hwloc_uint64_t best_value = 0; &amp;bsol;* shutup the compiler */
781    hwloc_obj_t best = NULL;
782    int found = 0;
783    unsigned j;
784    if (flags) {
785      errno = EINVAL;
786      return -1;
787    }
788    if (id &gt;= topology-&gt;nr_memattrs) {
789      errno = EINVAL;
790      return -1;
791    }
792    imattr = &amp;topology-&gt;memattrs[id];
793    if (imattr-&gt;iflags &amp; HWLOC_IMATTR_FLAG_CONVENIENCE) {
794      for(j=0; ; j++) {
795        hwloc_obj_t node = hwloc_get_obj_by_type(topology, HWLOC_OBJ_NUMANODE, j);
796        hwloc_uint64_t value;
797        if (!node)
798          break;
799        value = hwloc__memattr_get_convenience_value(id, node);
800        hwloc__update_best_target(&amp;best, &amp;best_value, &amp;found,
801                                  node, value,
802                                  imattr-&gt;flags &amp; HWLOC_MEMATTR_FLAG_HIGHER_FIRST);
803      }
804      goto done;
805    }
806    if (!(imattr-&gt;iflags &amp; HWLOC_IMATTR_FLAG_CACHE_VALID))
807      hwloc__imattr_refresh(topology, imattr);
808    for(j=0; j&lt;imattr-&gt;nr_targets; j++) {
809      struct hwloc_internal_memattr_target_s *imtg = &amp;imattr-&gt;targets[j];
810      hwloc_uint64_t value;
811      if (imattr-&gt;flags &amp; HWLOC_MEMATTR_FLAG_NEED_INITIATOR) {
812        struct hwloc_internal_memattr_initiator_s *imi = hwloc__memattr_get_initiator_from_location(imattr, imtg, initiator);
813        if (!imi)
814          continue;
815        value = imi-&gt;value;
816      } else {
817        value = imtg-&gt;noinitiator_value;
818      }
819      hwloc__update_best_target(&amp;best, &amp;best_value, &amp;found,
820                                imtg-&gt;obj, value,
821                                imattr-&gt;flags &amp; HWLOC_MEMATTR_FLAG_HIGHER_FIRST);
822    }
823   done:
824    if (found) {
825      assert(best);
826      *bestp = best;
827      if (valuep)
828        *valuep = best_value;
829      return 0;
830    } else {
831      errno = ENOENT;
832      return -1;
833    }
834  }
835  static void
836  hwloc__update_best_initiator(struct hwloc_internal_location_s *best_initiator, hwloc_uint64_t *best_value, int *found,
837                               struct hwloc_internal_location_s *new_initiator, hwloc_uint64_t new_value,
838                               int keep_highest)
839  {
840    if (*found) {
841      if (keep_highest) {
842        if (new_value &lt;= *best_value)
843          return;
844      } else {
845        if (new_value &gt;= *best_value)
846          return;
847      }
848    }
849    *best_initiator = *new_initiator;
850    *best_value = new_value;
851    *found = 1;
852  }
853  int
854  hwloc_memattr_get_best_initiator(hwloc_topology_t topology,
855                                   hwloc_memattr_id_t id,
856                                   hwloc_obj_t target_node,
857                                   unsigned long flags,
858                                   struct hwloc_location *bestp, hwloc_uint64_t *valuep)
859  {
860    struct hwloc_internal_memattr_s *imattr;
861    struct hwloc_internal_memattr_target_s *imtg;
862    struct hwloc_internal_location_s best_initiator;
863    hwloc_uint64_t best_value;
864    int found;
865    unsigned i;
866    if (flags) {
867      errno = EINVAL;
868      return -1;
869    }
870    if (id &gt;= topology-&gt;nr_memattrs) {
871      errno = EINVAL;
872      return -1;
873    }
874    imattr = &amp;topology-&gt;memattrs[id];
875    if (!(imattr-&gt;flags &amp; HWLOC_MEMATTR_FLAG_NEED_INITIATOR)) {
876      errno = EINVAL;
877      return -1;
878    }
879    if (!(imattr-&gt;iflags &amp; HWLOC_IMATTR_FLAG_CACHE_VALID))
880      hwloc__imattr_refresh(topology, imattr);
881    imtg = hwloc__memattr_get_target(imattr, target_node-&gt;type, target_node-&gt;gp_index, target_node-&gt;os_index, 0);
882    if (!imtg) {
883      errno = EINVAL;
884      return -1;
885    }
886    found = 0;
887    for(i=0; i&lt;imtg-&gt;nr_initiators; i++) {
888      struct hwloc_internal_memattr_initiator_s *imi = &amp;imtg-&gt;initiators[i];
889      hwloc__update_best_initiator(&amp;best_initiator, &amp;best_value, &amp;found,
890                                   &amp;imi-&gt;initiator, imi-&gt;value,
891                                   imattr-&gt;flags &amp; HWLOC_MEMATTR_FLAG_HIGHER_FIRST);
892    }
893    if (found) {
894      if (valuep)
895        *valuep = best_value;
896      return from_internal_location(&amp;best_initiator, bestp);
897    } else {
898      errno = ENOENT;
899      return -1;
900    }
901  }
902  static __hwloc_inline int
903  match_local_obj_cpuset(hwloc_obj_t node, hwloc_cpuset_t cpuset, unsigned long flags)
904  {
905    if (flags &amp; HWLOC_LOCAL_NUMANODE_FLAG_ALL)
906      return 1;
907    if ((flags &amp; HWLOC_LOCAL_NUMANODE_FLAG_LARGER_LOCALITY)
908        &amp;&amp; hwloc_bitmap_isincluded(cpuset, node-&gt;cpuset))
909      return 1;
910    if ((flags &amp; HWLOC_LOCAL_NUMANODE_FLAG_SMALLER_LOCALITY)
911        &amp;&amp; hwloc_bitmap_isincluded(node-&gt;cpuset, cpuset))
912      return 1;
913    return hwloc_bitmap_isequal(node-&gt;cpuset, cpuset);
914  }
915  int
916  hwloc_get_local_numanode_objs(hwloc_topology_t topology,
917                                struct hwloc_location *location,
918                                unsigned *nrp,
919                                hwloc_obj_t *nodes,
920                                unsigned long flags)
921  {
922    hwloc_cpuset_t cpuset;
923    hwloc_obj_t node;
924    unsigned i;
925    if (flags &amp; ~(HWLOC_LOCAL_NUMANODE_FLAG_SMALLER_LOCALITY
926                  |HWLOC_LOCAL_NUMANODE_FLAG_LARGER_LOCALITY
927                  | HWLOC_LOCAL_NUMANODE_FLAG_ALL)) {
928      errno = EINVAL;
929      return -1;
930    }
931    if (!nrp || (*nrp &amp;&amp; !nodes)) {
932      errno = EINVAL;
933      return -1;
934    }
935    if (!location) {
936      if (!(flags &amp; HWLOC_LOCAL_NUMANODE_FLAG_ALL)) {
937        errno = EINVAL;
938        return -1;
939      }
940      cpuset = NULL; &amp;bsol;* unused */
941    } else {
942      if (location-&gt;type == HWLOC_LOCATION_TYPE_CPUSET) {
943        cpuset = location-&gt;location.cpuset;
944      } else if (location-&gt;type == HWLOC_LOCATION_TYPE_OBJECT) {
945        hwloc_obj_t obj = location-&gt;location.object;
946        while (!obj-&gt;cpuset)
947          obj = obj-&gt;parent;
948        cpuset = obj-&gt;cpuset;
949      } else {
950        errno = EINVAL;
951        return -1;
952      }
953    }
954    i = 0;
955    for(node = hwloc_get_obj_by_type(topology, HWLOC_OBJ_NUMANODE, 0);
956        node;
957        node = node-&gt;next_cousin) {
958      if (!match_local_obj_cpuset(node, cpuset, flags))
959        continue;
960      if (i &lt; *nrp)
961        nodes[i] = node;
962      i++;
963    }
964    *nrp = i;
965    return 0;
966  }
967  struct hwloc_memory_tier_s {
968    hwloc_obj_t node;
969    uint64_t local_bw;
970    enum hwloc_memory_tier_type_e {
971      HWLOC_MEMORY_TIER_UNKNOWN,
972      HWLOC_MEMORY_TIER_DRAM,
973      HWLOC_MEMORY_TIER_HBM,
974      HWLOC_MEMORY_TIER_SPM, &amp;bsol;* Specific-Purpose Memory is usually HBM, we&#x27;ll use BW to confirm */
975      HWLOC_MEMORY_TIER_NVM,
976      HWLOC_MEMORY_TIER_GPU,
977    } type;
978  };
979  static int compare_tiers(const void *_a, const void *_b)
980  {
981    const struct hwloc_memory_tier_s *a = _a, *b = _b;
982    if (a-&gt;type != b-&gt;type)
983      return a-&gt;type - b-&gt;type;
984    if (a-&gt;local_bw &gt; b-&gt;local_bw)
985      return -1;
986    else if (a-&gt;local_bw &lt; b-&gt;local_bw)
987      return 1;
988    return 0;
989  }
990  int
991  hwloc_internal_memattrs_guess_memory_tiers(hwloc_topology_t topology)
992  {
993    struct hwloc_internal_memattr_s *imattr;
994    struct hwloc_memory_tier_s *tiers;
995    unsigned i, j, n;
996    const char *env;
997    int spm_is_hbm = -1; &amp;bsol;* -1 will guess from BW, 0 no, 1 forced */
998    int mark_dram = 1;
999    unsigned first_spm, first_nvm;
1000    hwloc_uint64_t max_unknown_bw, min_spm_bw;
1001    env = getenv(&quot;HWLOC_MEMTIERS_GUESS&quot;);
1002    if (env) {
1003      if (!strcmp(env, &quot;none&quot;)) {
1004        return 0;
1005      } else if (!strcmp(env, &quot;default&quot;)) {
1006      } else if (!strcmp(env, &quot;spm_is_hbm&quot;)) {
1007        hwloc_debug(&quot;Assuming SPM-tier is HBM, ignore bandwidth\n&quot;);
1008        spm_is_hbm = 1;
1009      } else if (HWLOC_SHOW_CRITICAL_ERRORS()) {
1010        fprintf(stderr, &quot;hwloc: Failed to recognize HWLOC_MEMTIERS_GUESS value %s\n&quot;, env);
1011      }
1012    }
1013    imattr = &amp;topology-&gt;memattrs[HWLOC_MEMATTR_ID_BANDWIDTH];
1014    if (!(imattr-&gt;iflags &amp; HWLOC_IMATTR_FLAG_CACHE_VALID))
1015      hwloc__imattr_refresh(topology, imattr);
1016    n = hwloc_get_nbobjs_by_depth(topology, HWLOC_TYPE_DEPTH_NUMANODE);
1017    assert(n);
1018    tiers = malloc(n * sizeof(*tiers));
1019    if (!tiers)
1020      return -1;
1021    for(i=0; i&lt;n; i++) {
1022      hwloc_obj_t node;
1023      const char *daxtype;
1024      struct hwloc_internal_location_s iloc;
1025      struct hwloc_internal_memattr_target_s *imtg = NULL;
1026      struct hwloc_internal_memattr_initiator_s *imi;
1027      node = hwloc_get_obj_by_depth(topology, HWLOC_TYPE_DEPTH_NUMANODE, i);
1028      assert(node);
1029      tiers[i].node = node;
1030      tiers[i].type = HWLOC_MEMORY_TIER_UNKNOWN;
1031      tiers[i].local_bw = 0; &amp;bsol;* unknown */
1032      daxtype = hwloc_obj_get_info_by_name(node, &quot;DAXType&quot;);
1033      if (daxtype &amp;&amp; !strcmp(daxtype, &quot;NVM&quot;))
1034        tiers[i].type = HWLOC_MEMORY_TIER_NVM;
1035      if (daxtype &amp;&amp; !strcmp(daxtype, &quot;SPM&quot;))
1036        tiers[i].type = HWLOC_MEMORY_TIER_SPM;
1037      if (node-&gt;subtype &amp;&amp; !strcmp(node-&gt;subtype, &quot;GPUMemory&quot;))
1038        tiers[i].type = HWLOC_MEMORY_TIER_GPU;
1039      if (spm_is_hbm == -1) {
1040        for(j=0; j&lt;imattr-&gt;nr_targets; j++)
1041          if (imattr-&gt;targets[j].obj == node) {
1042            imtg = &amp;imattr-&gt;targets[j];
1043            break;
1044          }
1045        if (imtg &amp;&amp; !hwloc_bitmap_iszero(node-&gt;cpuset)) {
1046          iloc.type = HWLOC_LOCATION_TYPE_CPUSET;
1047          iloc.location.cpuset = node-&gt;cpuset;
1048          imi = hwloc__memattr_target_get_initiator(imtg, &amp;iloc, 0);
1049          if (imi)
1050            tiers[i].local_bw = imi-&gt;value;
1051        }
1052      }
1053    }
1054    qsort(tiers, n, sizeof(*tiers), compare_tiers);
1055    hwloc_debug(&quot;Sorting memory tiers...\n&quot;);
1056    for(i=0; i&lt;n; i++)
1057      hwloc_debug(&quot;  tier %u = node L#%u P#%u with tier type %d and local BW #%llu\n&quot;,
1058                  i,
1059                  tiers[i].node-&gt;logical_index, tiers[i].node-&gt;os_index,
1060                  tiers[i].type, (unsigned long long) tiers[i].local_bw);
1061    for(i=0; i&lt;n; i++) {
1062      if (tiers[i].type &gt; HWLOC_MEMORY_TIER_UNKNOWN)
1063        break;
1064    }
1065    first_spm = i;
1066    if (first_spm &gt; 0)
1067      max_unknown_bw = tiers[0].local_bw;
1068    else
1069      max_unknown_bw = 0;
1070    for(i=first_spm; i&lt;n; i++) {
1071      if (tiers[i].type &gt; HWLOC_MEMORY_TIER_SPM)
1072        break;
1073    }
1074    first_nvm = i;
1075    if (first_nvm &gt; first_spm)
1076      min_spm_bw = tiers[first_nvm-1].local_bw;
1077    else
1078      min_spm_bw = 0;
1079    if (spm_is_hbm == -1) {
1080      hwloc_debug(&quot;UNKNOWN-memory-tier max bandwidth %llu\n&quot;, (unsigned long long) max_unknown_bw);
1081      hwloc_debug(&quot;SPM-memory-tier min bandwidth %llu\n&quot;, (unsigned long long) min_spm_bw);
1082      if (max_unknown_bw &gt; 0 &amp;&amp; min_spm_bw &gt; 0 &amp;&amp; max_unknown_bw*2 &lt; min_spm_bw) {
1083        hwloc_debug(&quot;assuming SPM means HBM and !SPM means DRAM since bandwidths are very different\n&quot;);
1084        spm_is_hbm = 1;
1085      } else {
1086        hwloc_debug(&quot;cannot assume SPM means HBM\n&quot;);
1087        spm_is_hbm = 0;
1088      }
1089    }
1090    if (spm_is_hbm) {
1091      for(i=0; i&lt;first_spm; i++)
1092        tiers[i].type = HWLOC_MEMORY_TIER_DRAM;
1093      for(i=first_spm; i&lt;first_nvm; i++)
1094        tiers[i].type = HWLOC_MEMORY_TIER_HBM;
1095    }
1096    if (first_spm == n)
1097      mark_dram = 0;
1098    for(i=0; i&lt;n; i++) {
1099      const char *type = NULL;
1100      if (tiers[i].node-&gt;subtype) &amp;bsol;* don&#x27;t overwrite the existing subtype */
1101        continue;
1102      switch (tiers[i].type) {
1103      case HWLOC_MEMORY_TIER_DRAM:
1104        if (mark_dram)
1105          type = &quot;DRAM&quot;;
1106        break;
1107      case HWLOC_MEMORY_TIER_HBM:
1108        type = &quot;HBM&quot;;
1109        break;
1110      case HWLOC_MEMORY_TIER_SPM:
1111        type = &quot;SPM&quot;;
1112        break;
1113      case HWLOC_MEMORY_TIER_NVM:
1114        type = &quot;NVM&quot;;
1115        break;
1116      default:
1117        break;
1118      }
1119      if (type) {
1120        hwloc_debug(&quot;Marking node L#%u P#%u as %s\n&quot;, tiers[i].node-&gt;logical_index, tiers[i].node-&gt;os_index, type);
1121        tiers[i].node-&gt;subtype = strdup(type);
1122      }
1123    }
1124    free(tiers);
1125    return 0;
1126  }
</code></pre>
        </div>
        <div class="column">
            <h3>xmrig-MDEwOlJlcG9zaXRvcnk4ODMyNzQwNg==-flat-components.c</h3>
            <pre><code>1  #include &quot;private/autogen/config.h&quot;
2  #include &quot;hwloc.h&quot;
3  #include &quot;private/private.h&quot;
4  #include &quot;private/xml.h&quot;
5  #include &quot;private/misc.h&quot;
6  #define HWLOC_COMPONENT_STOP_NAME &quot;stop&quot;
7  #define HWLOC_COMPONENT_EXCLUDE_CHAR &#x27;-&#x27;
8  #define HWLOC_COMPONENT_SEPS &quot;,&quot;
9  #define HWLOC_COMPONENT_PHASESEP_CHAR &#x27;:&#x27;
10  static struct hwloc_disc_component * hwloc_disc_components = NULL;
11  static unsigned hwloc_components_users = 0; &amp;bsol;* first one initializes, last ones destroys */
12  static int hwloc_components_verbose = 0;
13  #ifdef HWLOC_HAVE_PLUGINS
14  static int hwloc_plugins_verbose = 0;
15  static const char * hwloc_plugins_blacklist = NULL;
16  #endif
17  #ifdef HWLOC_WIN_SYS
18  #include &lt;windows.h&gt;
19  static LONG hwloc_components_mutex = 0;
20  #define HWLOC_COMPONENTS_LOCK() do {						\
21    while (InterlockedCompareExchange(&amp;hwloc_components_mutex, 1, 0) != 0)	\
22      SwitchToThread();								\
23  } while (0)
24  #define HWLOC_COMPONENTS_UNLOCK() do {						\
25    assert(hwloc_components_mutex == 1);						\
26    hwloc_components_mutex = 0;							\
27  } while (0)
28  #elif defined HWLOC_HAVE_PTHREAD_MUTEX
29  #include &lt;pthread.h&gt;
30  static pthread_mutex_t hwloc_components_mutex = PTHREAD_MUTEX_INITIALIZER;
31  #define HWLOC_COMPONENTS_LOCK() pthread_mutex_lock(&amp;hwloc_components_mutex)
32  #define HWLOC_COMPONENTS_UNLOCK() pthread_mutex_unlock(&amp;hwloc_components_mutex)
33  #else &amp;bsol;* HWLOC_WIN_SYS || HWLOC_HAVE_PTHREAD_MUTEX */
34  #error No mutex implementation available
35  #endif
36  #ifdef HWLOC_HAVE_PLUGINS
37  #ifdef HWLOC_HAVE_LTDL
38  #include &lt;ltdl.h&gt;
39  typedef lt_dlhandle hwloc_dlhandle;
40  #define hwloc_dlinit lt_dlinit
41  #define hwloc_dlexit lt_dlexit
42  #define hwloc_dlopenext lt_dlopenext
43  #define hwloc_dlclose lt_dlclose
44  #define hwloc_dlerror lt_dlerror
45  #define hwloc_dlsym lt_dlsym
46  #define hwloc_dlforeachfile lt_dlforeachfile
47  #else &amp;bsol;* !HWLOC_HAVE_LTDL */
48  #include &lt;dlfcn.h&gt;
49  typedef void * hwloc_dlhandle;
50  static __hwloc_inline int hwloc_dlinit(void) { return 0; }
51  static __hwloc_inline int hwloc_dlexit(void) { return 0; }
52  #define hwloc_dlclose dlclose
53  #define hwloc_dlerror dlerror
54  #define hwloc_dlsym dlsym
55  #include &lt;sys/stat.h&gt;
56  #include &lt;sys/types.h&gt;
57  #include &lt;dirent.h&gt;
58  #include &lt;unistd.h&gt;
59  static hwloc_dlhandle hwloc_dlopenext(const char *_filename)
60  {
61    hwloc_dlhandle handle;
62    char *filename = NULL;
63    (void) asprintf(&amp;filename, &quot;%s.so&quot;, _filename);
64    if (!filename)
65      return NULL;
66    handle = dlopen(filename, RTLD_NOW|RTLD_LOCAL);
67    free(filename);
68    return handle;
69  }
70  static int
71  hwloc_dlforeachfile(const char *_paths,
72  		    int (*func)(const char *filename, void *data),
73  		    void *data)
74  {
75    char *paths = NULL, *path;
76    paths = strdup(_paths);
77    if (!paths)
78      return -1;
79    path = paths;
80    while (*path) {
81      char *colon;
82      DIR *dir;
83      struct dirent *dirent;
84      colon = strchr(path, &#x27;:&#x27;);
85      if (colon)
86        *colon = &#x27;\0&#x27;;
87      if (hwloc_plugins_verbose)
88        fprintf(stderr, &quot;hwloc:  Looking under %s\n&quot;, path);
89      dir = opendir(path);
90      if (!dir)
91        goto next;
92      while ((dirent = readdir(dir)) != NULL) {
93        char *abs_name, *suffix;
94        struct stat stbuf;
95        int err;
96        err = asprintf(&amp;abs_name, &quot;%s/%s&quot;, path, dirent-&gt;d_name);
97        if (err &lt; 0)
98  	continue;
99        err = stat(abs_name, &amp;stbuf);
100        if (err &lt; 0) {
101  	free(abs_name);
102          continue;
103        }
104        if (!S_ISREG(stbuf.st_mode)) {
105  	free(abs_name);
106  	continue;
107        }
108        suffix = strrchr(abs_name, &#x27;.&#x27;);
109        if (!suffix || strcmp(suffix, &quot;.so&quot;)) {
110  	free(abs_name);
111  	continue;
112        }
113        *suffix = &#x27;\0&#x27;;
114        err = func(abs_name, data);
115        if (err) {
116  	free(abs_name);
117  	continue;
118        }
119        free(abs_name);
120      }
121      closedir(dir);
122    next:
123      if (!colon)
124        break;
125      path = colon+1;
126    }
127    free(paths);
128    return 0;
129  }
130  #endif &amp;bsol;* !HWLOC_HAVE_LTDL */
131  static struct hwloc__plugin_desc {
132    char *name;
133    struct hwloc_component *component;
134    char *filename;
135    hwloc_dlhandle handle;
136    struct hwloc__plugin_desc *next;
137  } *hwloc_plugins = NULL;
138  static int
139  hwloc__dlforeach_cb(const char *filename, void *_data __hwloc_attribute_unused)
140  {
141    const char *basename;
142    hwloc_dlhandle handle;
143    struct hwloc_component *component;
144    struct hwloc__plugin_desc *desc, **prevdesc;
145    char *componentsymbolname;
146    if (hwloc_plugins_verbose)
147      fprintf(stderr, &quot;hwloc: Plugin dlforeach found `%s&#x27;\n&quot;, filename);
148    basename = strrchr(filename, &#x27;/&#x27;);
149    if (!basename)
150      basename = filename;
151    else
152      basename++;
153    if (hwloc_plugins_blacklist &amp;&amp; strstr(hwloc_plugins_blacklist, basename)) {
154      if (hwloc_plugins_verbose)
155        fprintf(stderr, &quot;hwloc: Plugin `%s&#x27; is blacklisted in the environment\n&quot;, basename);
156      goto out;
157    }
158    handle = hwloc_dlopenext(filename);
159    if (!handle) {
160      if (hwloc_plugins_verbose)
161        fprintf(stderr, &quot;hwloc: Failed to load plugin: %s\n&quot;, hwloc_dlerror());
162      goto out;
163    }
164    componentsymbolname = malloc(strlen(basename)+10+1);
165    if (!componentsymbolname) {
166      if (hwloc_plugins_verbose)
167        fprintf(stderr, &quot;hwloc: Failed to allocation component `%s&#x27; symbol\n&quot;,
168  	      basename);
169      goto out_with_handle;
170    }
171    sprintf(componentsymbolname, &quot;%s_component&quot;, basename);
172    component = hwloc_dlsym(handle, componentsymbolname);
173    if (!component) {
174      if (hwloc_plugins_verbose)
175        fprintf(stderr, &quot;hwloc: Failed to find component symbol `%s&#x27;\n&quot;,
176  	      componentsymbolname);
177      free(componentsymbolname);
178      goto out_with_handle;
179    }
180    if (component-&gt;abi != HWLOC_COMPONENT_ABI) {
181      if (hwloc_plugins_verbose)
182        fprintf(stderr, &quot;hwloc: Plugin symbol ABI %u instead of %d\n&quot;,
183  	      component-&gt;abi, HWLOC_COMPONENT_ABI);
184      free(componentsymbolname);
185      goto out_with_handle;
186    }
187    if (hwloc_plugins_verbose)
188      fprintf(stderr, &quot;hwloc: Plugin contains expected symbol `%s&#x27;\n&quot;,
189  	    componentsymbolname);
190    free(componentsymbolname);
191    if (HWLOC_COMPONENT_TYPE_DISC == component-&gt;type) {
192      if (strncmp(basename, &quot;hwloc_&quot;, 6)) {
193        if (hwloc_plugins_verbose)
194  	fprintf(stderr, &quot;hwloc: Plugin name `%s&#x27; doesn&#x27;t match its type DISCOVERY\n&quot;, basename);
195        goto out_with_handle;
196      }
197    } else if (HWLOC_COMPONENT_TYPE_XML == component-&gt;type) {
198      if (strncmp(basename, &quot;hwloc_xml_&quot;, 10)) {
199        if (hwloc_plugins_verbose)
200  	fprintf(stderr, &quot;hwloc: Plugin name `%s&#x27; doesn&#x27;t match its type XML\n&quot;, basename);
201        goto out_with_handle;
202      }
203    } else {
204      if (hwloc_plugins_verbose)
205        fprintf(stderr, &quot;hwloc: Plugin name `%s&#x27; has invalid type %u\n&quot;,
206  	      basename, (unsigned) component-&gt;type);
207      goto out_with_handle;
208    }
209    desc = malloc(sizeof(*desc));
210    if (!desc)
211      goto out_with_handle;
212    desc-&gt;name = strdup(basename);
213    desc-&gt;filename = strdup(filename);
214    desc-&gt;component = component;
215    desc-&gt;handle = handle;
216    desc-&gt;next = NULL;
217    if (hwloc_plugins_verbose)
218      fprintf(stderr, &quot;hwloc: Plugin descriptor `%s&#x27; ready\n&quot;, basename);
219    prevdesc = &amp;hwloc_plugins;
220    while (*prevdesc)
221      prevdesc = &amp;((*prevdesc)-&gt;next);
222    *prevdesc = desc;
223    if (hwloc_plugins_verbose)
224      fprintf(stderr, &quot;hwloc: Plugin descriptor `%s&#x27; queued\n&quot;, basename);
225    return 0;
226   out_with_handle:
227    hwloc_dlclose(handle);
228   out:
229    return 0;
230  }
231  static void
232  hwloc_plugins_exit(void)
233  {
234    struct hwloc__plugin_desc *desc, *next;
235    if (hwloc_plugins_verbose)
236      fprintf(stderr, &quot;hwloc: Closing all plugins\n&quot;);
237    desc = hwloc_plugins;
238    while (desc) {
239      next = desc-&gt;next;
240      hwloc_dlclose(desc-&gt;handle);
241      free(desc-&gt;name);
242      free(desc-&gt;filename);
243      free(desc);
244      desc = next;
245    }
246    hwloc_plugins = NULL;
247    hwloc_dlexit();
248  }
249  static int
250  hwloc_plugins_init(void)
251  {
252    const char *verboseenv;
253    const char *path = HWLOC_PLUGINS_PATH;
254    const char *env;
255    int err;
256    verboseenv = getenv(&quot;HWLOC_PLUGINS_VERBOSE&quot;);
257    hwloc_plugins_verbose = verboseenv ? atoi(verboseenv) : 0;
258    hwloc_plugins_blacklist = getenv(&quot;HWLOC_PLUGINS_BLACKLIST&quot;);
259    err = hwloc_dlinit();
260    if (err)
261      goto out;
262    env = getenv(&quot;HWLOC_PLUGINS_PATH&quot;);
263    if (env)
264      path = env;
265    hwloc_plugins = NULL;
266    if (hwloc_plugins_verbose)
267      fprintf(stderr, &quot;hwloc: Starting plugin dlforeach in %s\n&quot;, path);
268    err = hwloc_dlforeachfile(path, hwloc__dlforeach_cb, NULL);
269    if (err)
270      goto out_with_init;
271    return 0;
272   out_with_init:
273    hwloc_plugins_exit();
274   out:
275    return -1;
276  }
277  #endif &amp;bsol;* HWLOC_HAVE_PLUGINS */
278  static int
279  hwloc_disc_component_register(struct hwloc_disc_component *component,
280  			      const char *filename)
281  {
282    struct hwloc_disc_component **prev;
283    if (!strcmp(component-&gt;name, HWLOC_COMPONENT_STOP_NAME)) {
284      if (hwloc_components_verbose)
285        fprintf(stderr, &quot;hwloc: Cannot register discovery component with reserved name `&quot; HWLOC_COMPONENT_STOP_NAME &quot;&#x27;\n&quot;);
286      return -1;
287    }
288    if (strchr(component-&gt;name, HWLOC_COMPONENT_EXCLUDE_CHAR)
289        || strchr(component-&gt;name, HWLOC_COMPONENT_PHASESEP_CHAR)
290        || strcspn(component-&gt;name, HWLOC_COMPONENT_SEPS) != strlen(component-&gt;name)) {
291      if (hwloc_components_verbose)
292        fprintf(stderr, &quot;hwloc: Cannot register discovery component with name `%s&#x27; containing reserved characters `%c&quot; HWLOC_COMPONENT_SEPS &quot;&#x27;\n&quot;,
293  	      component-&gt;name, HWLOC_COMPONENT_EXCLUDE_CHAR);
294      return -1;
295    }
296    if (!component-&gt;phases
297        || (component-&gt;phases != HWLOC_DISC_PHASE_GLOBAL
298  	  &amp;&amp; component-&gt;phases &amp; ~(HWLOC_DISC_PHASE_CPU
299  				   |HWLOC_DISC_PHASE_MEMORY
300  				   |HWLOC_DISC_PHASE_PCI
301  				   |HWLOC_DISC_PHASE_IO
302  				   |HWLOC_DISC_PHASE_MISC
303  				   |HWLOC_DISC_PHASE_ANNOTATE
304  				   |HWLOC_DISC_PHASE_TWEAK))) {
305      if (HWLOC_SHOW_CRITICAL_ERRORS())
306        fprintf(stderr, &quot;hwloc: Cannot register discovery component `%s&#x27; with invalid phases 0x%x\n&quot;,
307                component-&gt;name, component-&gt;phases);
308      return -1;
309    }
310    prev = &amp;hwloc_disc_components;
311    while (NULL != *prev) {
312      if (!strcmp((*prev)-&gt;name, component-&gt;name)) {
313        if ((*prev)-&gt;priority &lt; component-&gt;priority) {
314  	if (hwloc_components_verbose)
315  	  fprintf(stderr, &quot;hwloc: Dropping previously registered discovery component `%s&#x27;, priority %u lower than new one %u\n&quot;,
316  		  (*prev)-&gt;name, (*prev)-&gt;priority, component-&gt;priority);
317  	*prev = (*prev)-&gt;next;
318        } else {
319  	if (hwloc_components_verbose)
320  	  fprintf(stderr, &quot;hwloc: Ignoring new discovery component `%s&#x27;, priority %u lower than previously registered one %u\n&quot;,
321  		  component-&gt;name, component-&gt;priority, (*prev)-&gt;priority);
322  	return -1;
323        }
324      }
325      prev = &amp;((*prev)-&gt;next);
326    }
327    if (hwloc_components_verbose)
328      fprintf(stderr, &quot;hwloc: Registered discovery component `%s&#x27; phases 0x%x with priority %u (%s%s)\n&quot;,
329  	    component-&gt;name, component-&gt;phases, component-&gt;priority,
330  	    filename ? &quot;from plugin &quot; : &quot;statically build&quot;, filename ? filename : &quot;&quot;);
331    prev = &amp;hwloc_disc_components;
332    while (NULL != *prev) {
333      if ((*prev)-&gt;priority &lt; component-&gt;priority)
334        break;
335      prev = &amp;((*prev)-&gt;next);
336    }
337    component-&gt;next = *prev;
338    *prev = component;
339    return 0;
340  }
341  #include &quot;static-components.h&quot;
342  static void (**hwloc_component_finalize_cbs)(unsigned long);
343  static unsigned hwloc_component_finalize_cb_count;
344  void
345  hwloc_components_init(void)
346  {
347  #ifdef HWLOC_HAVE_PLUGINS
348    struct hwloc__plugin_desc *desc;
349  #endif
350    const char *verboseenv;
351    unsigned i;
352    HWLOC_COMPONENTS_LOCK();
353    assert((unsigned) -1 != hwloc_components_users);
354    if (0 != hwloc_components_users++) {
355      HWLOC_COMPONENTS_UNLOCK();
356      return;
357    }
358    verboseenv = getenv(&quot;HWLOC_COMPONENTS_VERBOSE&quot;);
359    hwloc_components_verbose = verboseenv ? atoi(verboseenv) : 0;
360  #ifdef HWLOC_HAVE_PLUGINS
361    hwloc_plugins_init();
362  #endif
363    hwloc_component_finalize_cbs = NULL;
364    hwloc_component_finalize_cb_count = 0;
365    for(i=0; NULL != hwloc_static_components[i]; i++)
366      hwloc_component_finalize_cb_count++;
367  #ifdef HWLOC_HAVE_PLUGINS
368    for(desc = hwloc_plugins; NULL != desc; desc = desc-&gt;next)
369      hwloc_component_finalize_cb_count++;
370  #endif
371    if (hwloc_component_finalize_cb_count) {
372      hwloc_component_finalize_cbs = calloc(hwloc_component_finalize_cb_count,
373  					  sizeof(*hwloc_component_finalize_cbs));
374      assert(hwloc_component_finalize_cbs);
375      hwloc_component_finalize_cb_count = 0;
376    }
377    for(i=0; NULL != hwloc_static_components[i]; i++) {
378      if (hwloc_static_components[i]-&gt;flags) {
379        if (HWLOC_SHOW_CRITICAL_ERRORS())
380          fprintf(stderr, &quot;hwloc: Ignoring static component with invalid flags %lx\n&quot;,
381                  hwloc_static_components[i]-&gt;flags);
382        continue;
383      }
384      if (hwloc_static_components[i]-&gt;init &amp;&amp; hwloc_static_components[i]-&gt;init(0) &lt; 0) {
385        if (hwloc_components_verbose)
386  	fprintf(stderr, &quot;hwloc: Ignoring static component, failed to initialize\n&quot;);
387        continue;
388      }
389      if (hwloc_static_components[i]-&gt;finalize)
390        hwloc_component_finalize_cbs[hwloc_component_finalize_cb_count++] = hwloc_static_components[i]-&gt;finalize;
391      if (HWLOC_COMPONENT_TYPE_DISC == hwloc_static_components[i]-&gt;type)
392        hwloc_disc_component_register(hwloc_static_components[i]-&gt;data, NULL);
393      else if (HWLOC_COMPONENT_TYPE_XML == hwloc_static_components[i]-&gt;type)
394        hwloc_xml_callbacks_register(hwloc_static_components[i]-&gt;data);
395      else
396        assert(0);
397    }
398  #ifdef HWLOC_HAVE_PLUGINS
399    for(desc = hwloc_plugins; NULL != desc; desc = desc-&gt;next) {
400      if (desc-&gt;component-&gt;flags) {
401        if (HWLOC_SHOW_CRITICAL_ERRORS())
402          fprintf(stderr, &quot;hwloc: Ignoring plugin `%s&#x27; component with invalid flags %lx\n&quot;,
403                  desc-&gt;name, desc-&gt;component-&gt;flags);
404        continue;
405      }
406      if (desc-&gt;component-&gt;init &amp;&amp; desc-&gt;component-&gt;init(0) &lt; 0) {
407        if (hwloc_components_verbose)
408  	fprintf(stderr, &quot;hwloc: Ignoring plugin `%s&#x27;, failed to initialize\n&quot;, desc-&gt;name);
409        continue;
410      }
411      if (desc-&gt;component-&gt;finalize)
412        hwloc_component_finalize_cbs[hwloc_component_finalize_cb_count++] = desc-&gt;component-&gt;finalize;
413      if (HWLOC_COMPONENT_TYPE_DISC == desc-&gt;component-&gt;type)
414        hwloc_disc_component_register(desc-&gt;component-&gt;data, desc-&gt;filename);
415      else if (HWLOC_COMPONENT_TYPE_XML == desc-&gt;component-&gt;type)
416        hwloc_xml_callbacks_register(desc-&gt;component-&gt;data);
417      else
418        assert(0);
419    }
420  #endif
421    HWLOC_COMPONENTS_UNLOCK();
<span onclick='openModal()' class='match'>422  }
423  void
424  hwloc_topology_components_init(struct hwloc_topology *topology)
425  {
426    topology-&gt;nr_blacklisted_components = 0;
427    topology-&gt;blacklisted_components = NULL;
</span>428    topology-&gt;backends = NULL;
429    topology-&gt;backend_phases = 0;
430    topology-&gt;backend_excluded_phases = 0;
431  }
432  static struct hwloc_disc_component *
433  hwloc_disc_component_find(const char *name, const char **endp)
434  {
435    struct hwloc_disc_component *comp;
436    size_t length;
437    const char *end = strchr(name, HWLOC_COMPONENT_PHASESEP_CHAR);
438    if (end) {
439      length = end-name;
440      if (endp)
441        *endp = end+1;
442    } else {
443      length = strlen(name);
444      if (endp)
445        *endp = NULL;
446    }
447    comp = hwloc_disc_components;
448    while (NULL != comp) {
449      if (!strncmp(name, comp-&gt;name, length))
450        return comp;
451      comp = comp-&gt;next;
452    }
453    return NULL;
454  }
455  static unsigned
456  hwloc_phases_from_string(const char *s)
457  {
458    if (!s)
459      return ~0U;
460    if (s[0]&lt;&#x27;0&#x27; || s[0]&gt;&#x27;9&#x27;) {
461      if (!strcasecmp(s, &quot;global&quot;))
462        return HWLOC_DISC_PHASE_GLOBAL;
463      else if (!strcasecmp(s, &quot;cpu&quot;))
464        return HWLOC_DISC_PHASE_CPU;
465      if (!strcasecmp(s, &quot;memory&quot;))
466        return HWLOC_DISC_PHASE_MEMORY;
467      if (!strcasecmp(s, &quot;pci&quot;))
468        return HWLOC_DISC_PHASE_PCI;
469      if (!strcasecmp(s, &quot;io&quot;))
470        return HWLOC_DISC_PHASE_IO;
471      if (!strcasecmp(s, &quot;misc&quot;))
472        return HWLOC_DISC_PHASE_MISC;
473      if (!strcasecmp(s, &quot;annotate&quot;))
474        return HWLOC_DISC_PHASE_ANNOTATE;
475      if (!strcasecmp(s, &quot;tweak&quot;))
476        return HWLOC_DISC_PHASE_TWEAK;
477      return 0;
478    }
479    return (unsigned) strtoul(s, NULL, 0);
480  }
481  static int
482  hwloc_disc_component_blacklist_one(struct hwloc_topology *topology,
483  				   const char *name)
484  {
485    struct hwloc_topology_forced_component_s *blacklisted;
486    struct hwloc_disc_component *comp;
487    unsigned phases;
488    unsigned i;
489    if (!strcmp(name, &quot;linuxpci&quot;) || !strcmp(name, &quot;linuxio&quot;)) {
490      if (hwloc_components_verbose)
491        fprintf(stderr, &quot;hwloc: Replacing deprecated component `%s&#x27; with `linux&#x27; IO phases in blacklisting\n&quot;, name);
492      comp = hwloc_disc_component_find(&quot;linux&quot;, NULL);
493      phases = HWLOC_DISC_PHASE_PCI | HWLOC_DISC_PHASE_IO | HWLOC_DISC_PHASE_MISC | HWLOC_DISC_PHASE_ANNOTATE;
494    } else {
495      const char *end;
496      comp = hwloc_disc_component_find(name, &amp;end);
497      phases = hwloc_phases_from_string(end);
498    }
499    if (!comp) {
500      errno = EINVAL;
501      return -1;
502    }
503    if (hwloc_components_verbose)
504      fprintf(stderr, &quot;hwloc: Blacklisting component `%s` phases 0x%x\n&quot;, comp-&gt;name, phases);
505    for(i=0; i&lt;topology-&gt;nr_blacklisted_components; i++) {
506      if (topology-&gt;blacklisted_components[i].component == comp) {
507        topology-&gt;blacklisted_components[i].phases |= phases;
508        return 0;
509      }
510    }
511    blacklisted = realloc(topology-&gt;blacklisted_components, (topology-&gt;nr_blacklisted_components+1)*sizeof(*blacklisted));
512    if (!blacklisted)
513      return -1;
514    blacklisted[topology-&gt;nr_blacklisted_components].component = comp;
515    blacklisted[topology-&gt;nr_blacklisted_components].phases = phases;
516    topology-&gt;blacklisted_components = blacklisted;
517    topology-&gt;nr_blacklisted_components++;
518    return 0;
519  }
520  int
521  hwloc_topology_set_components(struct hwloc_topology *topology,
522  			      unsigned long flags,
523  			      const char *name)
524  {
525    if (topology-&gt;is_loaded) {
526      errno = EBUSY;
527      return -1;
528    }
529    if (flags &amp; ~HWLOC_TOPOLOGY_COMPONENTS_FLAG_BLACKLIST) {
530      errno = EINVAL;
531      return -1;
532    }
533    if (flags != HWLOC_TOPOLOGY_COMPONENTS_FLAG_BLACKLIST) {
534      errno = EINVAL;
535      return -1;
536    }
537    if (!strncmp(name, &quot;all&quot;, 3) &amp;&amp; name[3] == HWLOC_COMPONENT_PHASESEP_CHAR) {
538      topology-&gt;backend_excluded_phases = hwloc_phases_from_string(name+4);
539      return 0;
540    }
541    return hwloc_disc_component_blacklist_one(topology, name);
542  }
543  int
544  hwloc_disc_component_force_enable(struct hwloc_topology *topology,
545  				  int envvar_forced,
546  				  const char *name,
547  				  const void *data1, const void *data2, const void *data3)
548  {
549    struct hwloc_disc_component *comp;
550    struct hwloc_backend *backend;
551    if (topology-&gt;is_loaded) {
552      errno = EBUSY;
553      return -1;
554    }
555    comp = hwloc_disc_component_find(name, NULL);
556    if (!comp) {
557      errno = ENOSYS;
558      return -1;
559    }
560    backend = comp-&gt;instantiate(topology, comp, 0U &amp;bsol;* force-enabled don&#x27;t get any phase blacklisting */,
561  			      data1, data2, data3);
562    if (backend) {
563      int err;
564      backend-&gt;envvar_forced = envvar_forced;
565      if (topology-&gt;backends)
566        hwloc_backends_disable_all(topology);
567      err = hwloc_backend_enable(backend);
568      if (comp-&gt;phases == HWLOC_DISC_PHASE_GLOBAL) {
569        char *env = getenv(&quot;HWLOC_ANNOTATE_GLOBAL_COMPONENTS&quot;);
570        if (env &amp;&amp; atoi(env))
571  	topology-&gt;backend_excluded_phases &amp;= ~HWLOC_DISC_PHASE_ANNOTATE;
572      }
573      return err;
574    } else
575      return -1;
576  }
577  static int
578  hwloc_disc_component_try_enable(struct hwloc_topology *topology,
579  				struct hwloc_disc_component *comp,
580  				int envvar_forced,
581  				unsigned blacklisted_phases)
582  {
583    struct hwloc_backend *backend;
584    if (!(comp-&gt;phases &amp; ~(topology-&gt;backend_excluded_phases | blacklisted_phases))) {
585      if (hwloc_components_verbose)
586        fprintf(stderr, &quot;hwloc: Excluding discovery component `%s&#x27; phases 0x%x, conflicts with excludes 0x%x\n&quot;,
587  	      comp-&gt;name, comp-&gt;phases, topology-&gt;backend_excluded_phases);
588      return -1;
589    }
590    backend = comp-&gt;instantiate(topology, comp, topology-&gt;backend_excluded_phases | blacklisted_phases,
591  			      NULL, NULL, NULL);
592    if (!backend) {
593      if (hwloc_components_verbose || (envvar_forced &amp;&amp; HWLOC_SHOW_CRITICAL_ERRORS()))
594        fprintf(stderr, &quot;hwloc: Failed to instantiate discovery component `%s&#x27;\n&quot;, comp-&gt;name);
595      return -1;
596    }
597    backend-&gt;phases &amp;= ~blacklisted_phases;
598    backend-&gt;envvar_forced = envvar_forced;
599    return hwloc_backend_enable(backend);
600  }
601  void
602  hwloc_disc_components_enable_others(struct hwloc_topology *topology)
603  {
604    struct hwloc_disc_component *comp;
605    struct hwloc_backend *backend;
606    int tryall = 1;
607    const char *_env;
608    char *env; &amp;bsol;* we&#x27;ll to modify the env value, so duplicate it */
609    unsigned i;
610    _env = getenv(&quot;HWLOC_COMPONENTS&quot;);
611    env = _env ? strdup(_env) : NULL;
612    if (env) {
613      char *curenv = env;
614      size_t s;
615      while (*curenv) {
616        s = strcspn(curenv, HWLOC_COMPONENT_SEPS);
617        if (s) {
618  	char c;
619  	if (curenv[0] != HWLOC_COMPONENT_EXCLUDE_CHAR)
620  	  goto nextname;
621  	c = curenv[s];
622  	curenv[s] = &#x27;\0&#x27;;
623  	hwloc_disc_component_blacklist_one(topology, curenv+1);
624  	for(i=0; i&lt;s; i++)
625  	  curenv[i] = *HWLOC_COMPONENT_SEPS;
626  	curenv[s] = c;
627        }
628      nextname:
629        curenv += s;
630        if (*curenv)
631  	curenv++;
632      }
633    }
634    if (env) {
635      char *curenv = env;
636      size_t s;
637      while (*curenv) {
638        s = strcspn(curenv, HWLOC_COMPONENT_SEPS);
639        if (s) {
640  	char c;
641  	const char *name;
642  	if (!strncmp(curenv, HWLOC_COMPONENT_STOP_NAME, s)) {
643  	  tryall = 0;
644  	  break;
645  	}
646  	c = curenv[s];
647  	curenv[s] = &#x27;\0&#x27;;
648  	name = curenv;
649  	if (!strcmp(name, &quot;linuxpci&quot;) || !strcmp(name, &quot;linuxio&quot;)) {
650  	  if (hwloc_components_verbose)
651  	    fprintf(stderr, &quot;hwloc: Replacing deprecated component `%s&#x27; with `linux&#x27; in envvar forcing\n&quot;, name);
652  	  name = &quot;linux&quot;;
653  	}
654  	comp = hwloc_disc_component_find(name, NULL &amp;bsol;* we enable the entire component, phases must be blacklisted separately */);
655  	if (comp) {
656  	  unsigned blacklisted_phases = 0U;
657  	  for(i=0; i&lt;topology-&gt;nr_blacklisted_components; i++)
658  	    if (comp == topology-&gt;blacklisted_components[i].component) {
659  	      blacklisted_phases = topology-&gt;blacklisted_components[i].phases;
660  	      break;
661  	    }
662  	  if (comp-&gt;phases &amp; ~blacklisted_phases)
663  	    hwloc_disc_component_try_enable(topology, comp, 1 &amp;bsol;* envvar forced */, blacklisted_phases);
664  	} else {
665            if (HWLOC_SHOW_CRITICAL_ERRORS())
666              fprintf(stderr, &quot;hwloc: Cannot find discovery component `%s&#x27;\n&quot;, name);
667  	}
668  	curenv[s] = c;
669        }
670        curenv += s;
671        if (*curenv)
672  	curenv++;
673      }
674    }
675    if (tryall) {
676      comp = hwloc_disc_components;
677      while (NULL != comp) {
678        unsigned blacklisted_phases = 0U;
679        if (!comp-&gt;enabled_by_default)
680  	goto nextcomp;
681        for(i=0; i&lt;topology-&gt;nr_blacklisted_components; i++)
682  	if (comp == topology-&gt;blacklisted_components[i].component) {
683  	  blacklisted_phases = topology-&gt;blacklisted_components[i].phases;
684  	  break;
685  	}
686        if (!(comp-&gt;phases &amp; ~blacklisted_phases)) {
687  	if (hwloc_components_verbose)
688  	  fprintf(stderr, &quot;hwloc: Excluding blacklisted discovery component `%s&#x27; phases 0x%x\n&quot;,
689  		  comp-&gt;name, comp-&gt;phases);
690  	goto nextcomp;
691        }
692        hwloc_disc_component_try_enable(topology, comp, 0 &amp;bsol;* defaults, not envvar forced */, blacklisted_phases);
693  nextcomp:
694        comp = comp-&gt;next;
695      }
696    }
697    if (hwloc_components_verbose) {
698      int first = 1;
699      backend = topology-&gt;backends;
700      fprintf(stderr, &quot;hwloc: Final list of enabled discovery components: &quot;);
701      while (backend != NULL) {
702        fprintf(stderr, &quot;%s%s(0x%x)&quot;, first ? &quot;&quot; : &quot;,&quot;, backend-&gt;component-&gt;name, backend-&gt;phases);
703        backend = backend-&gt;next;
704        first = 0;
705      }
706      fprintf(stderr, &quot;\n&quot;);
707    }
708    free(env);
709  }
710  void
711  hwloc_components_fini(void)
712  {
713    unsigned i;
714    HWLOC_COMPONENTS_LOCK();
715    assert(0 != hwloc_components_users);
716    if (0 != --hwloc_components_users) {
717      HWLOC_COMPONENTS_UNLOCK();
718      return;
719    }
720    for(i=0; i&lt;hwloc_component_finalize_cb_count; i++)
721      hwloc_component_finalize_cbs[hwloc_component_finalize_cb_count-i-1](0);
722    free(hwloc_component_finalize_cbs);
723    hwloc_component_finalize_cbs = NULL;
724    hwloc_component_finalize_cb_count = 0;
725    hwloc_disc_components = NULL;
726    hwloc_xml_callbacks_reset();
727  #ifdef HWLOC_HAVE_PLUGINS
728    hwloc_plugins_exit();
729  #endif
730    HWLOC_COMPONENTS_UNLOCK();
731  }
732  struct hwloc_backend *
733  hwloc_backend_alloc(struct hwloc_topology *topology,
734  		    struct hwloc_disc_component *component)
735  {
736    struct hwloc_backend * backend = malloc(sizeof(*backend));
737    if (!backend) {
738      errno = ENOMEM;
739      return NULL;
740    }
741    backend-&gt;component = component;
742    backend-&gt;topology = topology;
743    backend-&gt;phases = component-&gt;phases &amp; ~topology-&gt;backend_excluded_phases;
744    if (backend-&gt;phases != component-&gt;phases &amp;&amp; hwloc_components_verbose)
745      fprintf(stderr, &quot;hwloc: Trying discovery component `%s&#x27; with phases 0x%x instead of 0x%x\n&quot;,
746  	    component-&gt;name, backend-&gt;phases, component-&gt;phases);
747    backend-&gt;flags = 0;
748    backend-&gt;discover = NULL;
749    backend-&gt;get_pci_busid_cpuset = NULL;
750    backend-&gt;disable = NULL;
751    backend-&gt;is_thissystem = -1;
752    backend-&gt;next = NULL;
753    backend-&gt;envvar_forced = 0;
754    return backend;
755  }
756  static void
757  hwloc_backend_disable(struct hwloc_backend *backend)
758  {
759    if (backend-&gt;disable)
760      backend-&gt;disable(backend);
761    free(backend);
762  }
763  int
764  hwloc_backend_enable(struct hwloc_backend *backend)
765  {
766    struct hwloc_topology *topology = backend-&gt;topology;
767    struct hwloc_backend **pprev;
768    if (backend-&gt;flags) {
769      if (HWLOC_SHOW_CRITICAL_ERRORS())
770        fprintf(stderr, &quot;hwloc: Cannot enable discovery component `%s&#x27; phases 0x%x with unknown flags %lx\n&quot;,
771                backend-&gt;component-&gt;name, backend-&gt;component-&gt;phases, backend-&gt;flags);
772      return -1;
773    }
774    pprev = &amp;topology-&gt;backends;
775    while (NULL != *pprev) {
776      if ((*pprev)-&gt;component == backend-&gt;component) {
777        if (hwloc_components_verbose)
778  	fprintf(stderr, &quot;hwloc: Cannot enable  discovery component `%s&#x27; phases 0x%x twice\n&quot;,
779  		backend-&gt;component-&gt;name, backend-&gt;component-&gt;phases);
780        hwloc_backend_disable(backend);
781        errno = EBUSY;
782        return -1;
783      }
784      pprev = &amp;((*pprev)-&gt;next);
785    }
786    if (hwloc_components_verbose)
787      fprintf(stderr, &quot;hwloc: Enabling discovery component `%s&#x27; with phases 0x%x (among 0x%x)\n&quot;,
788  	    backend-&gt;component-&gt;name, backend-&gt;phases, backend-&gt;component-&gt;phases);
789    pprev = &amp;topology-&gt;backends;
790    while (NULL != *pprev)
791      pprev = &amp;((*pprev)-&gt;next);
792    backend-&gt;next = *pprev;
793    *pprev = backend;
794    topology-&gt;backend_phases |= backend-&gt;component-&gt;phases;
795    topology-&gt;backend_excluded_phases |= backend-&gt;component-&gt;excluded_phases;
796    return 0;
797  }
798  void
799  hwloc_backends_is_thissystem(struct hwloc_topology *topology)
800  {
801    struct hwloc_backend *backend;
802    const char *local_env;
803    topology-&gt;is_thissystem = 1;
804    backend = topology-&gt;backends;
805    while (backend != NULL) {
806      if (backend-&gt;envvar_forced == 0 &amp;&amp; backend-&gt;is_thissystem != -1) {
807        assert(backend-&gt;is_thissystem == 0);
808        topology-&gt;is_thissystem = 0;
809      }
810      backend = backend-&gt;next;
811    }
812    if (topology-&gt;flags &amp; HWLOC_TOPOLOGY_FLAG_IS_THISSYSTEM)
813      topology-&gt;is_thissystem = 1;
814    backend = topology-&gt;backends;
815    while (backend != NULL) {
816      if (backend-&gt;envvar_forced == 1 &amp;&amp; backend-&gt;is_thissystem != -1) {
817        assert(backend-&gt;is_thissystem == 0);
818        topology-&gt;is_thissystem = 0;
819      }
820      backend = backend-&gt;next;
821    }
822    local_env = getenv(&quot;HWLOC_THISSYSTEM&quot;);
823    if (local_env)
824      topology-&gt;is_thissystem = atoi(local_env);
825  }
826  void
827  hwloc_backends_find_callbacks(struct hwloc_topology *topology)
828  {
829    struct hwloc_backend *backend = topology-&gt;backends;
830    topology-&gt;get_pci_busid_cpuset_backend = NULL;
831    while (backend != NULL) {
832      if (backend-&gt;get_pci_busid_cpuset) {
833        topology-&gt;get_pci_busid_cpuset_backend = backend;
834        return;
835      }
836      backend = backend-&gt;next;
837    }
838    return;
839  }
840  void
841  hwloc_backends_disable_all(struct hwloc_topology *topology)
842  {
843    struct hwloc_backend *backend;
844    while (NULL != (backend = topology-&gt;backends)) {
845      struct hwloc_backend *next = backend-&gt;next;
846      if (hwloc_components_verbose)
847        fprintf(stderr, &quot;hwloc: Disabling discovery component `%s&#x27;\n&quot;,
848  	      backend-&gt;component-&gt;name);
849      hwloc_backend_disable(backend);
850      topology-&gt;backends = next;
851    }
852    topology-&gt;backends = NULL;
853    topology-&gt;backend_excluded_phases = 0;
854  }
855  void
856  hwloc_topology_components_fini(struct hwloc_topology *topology)
857  {
858    assert(!topology-&gt;backends);
859    free(topology-&gt;blacklisted_components);
860  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from xmrig-MDEwOlJlcG9zaXRvcnk4ODMyNzQwNg==-flat-memattrs.c</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from xmrig-MDEwOlJlcG9zaXRvcnk4ODMyNzQwNg==-flat-components.c</div>
                </div>
                <div class="column column_space"><pre><code>16  }
17  void
18  hwloc_internal_memattrs_init(struct hwloc_topology *topology)
19  {
20    topology-&gt;nr_memattrs = 0;
21    topology-&gt;memattrs = NULL;
</pre></code></div>
                <div class="column column_space"><pre><code>422  }
423  void
424  hwloc_topology_components_init(struct hwloc_topology *topology)
425  {
426    topology-&gt;nr_blacklisted_components = 0;
427    topology-&gt;blacklisted_components = NULL;
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    