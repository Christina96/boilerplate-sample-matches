
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 1.7508417508417509%, Tokens: 13</h2>
        <div class="column">
            <h3>libtomcrypt-MDEwOlJlcG9zaXRvcnk3NzcwMTE=-flat-ccm_memory.c</h3>
            <pre><code>1  #include "tomcrypt_private.h"
2  #ifdef LTC_CCM_MODE
3  int ccm_memory(int cipher,
4      const unsigned char *key,    unsigned long keylen,
5      symmetric_key       *uskey,
6      const unsigned char *nonce,  unsigned long noncelen,
7      const unsigned char *header, unsigned long headerlen,
8            unsigned char *pt,     unsigned long ptlen,
9            unsigned char *ct,
10            unsigned char *tag,    unsigned long *taglen,
11                      int  direction)
12  {
13     unsigned char  PAD[16], ctr[16], CTRPAD[16], ptTag[16], b, *pt_real;
14     unsigned char *pt_work = NULL;
15     symmetric_key *skey;
16     int            err;
17     unsigned long  len, L, x, y, z, CTRlen;
18     if (uskey == NULL) {
19        LTC_ARGCHK(key    != NULL);
20     }
21     LTC_ARGCHK(nonce  != NULL);
22     if (headerlen > 0) {
23        LTC_ARGCHK(header != NULL);
24     }
25     LTC_ARGCHK(pt     != NULL);
26     LTC_ARGCHK(ct     != NULL);
27     LTC_ARGCHK(tag    != NULL);
28     LTC_ARGCHK(taglen != NULL);
29     pt_real = pt;
30  #ifdef LTC_FAST
31     if (16 % sizeof(LTC_FAST_TYPE)) {
32        return CRYPT_INVALID_ARG;
33     }
34  #endif
35     if ((err = cipher_is_valid(cipher)) != CRYPT_OK) {
36        return err;
37     }
38     if (cipher_descriptor[cipher].block_length != 16) {
39        return CRYPT_INVALID_CIPHER;
40     }
41     if (*taglen < 4 || *taglen > 16 || (*taglen % 2) == 1 || headerlen > 0x7fffffffu) {
42        return CRYPT_INVALID_ARG;
43     }
44     if (cipher_descriptor[cipher].accel_ccm_memory != NULL) {
45         return cipher_descriptor[cipher].accel_ccm_memory(
46             key,    keylen,
47             uskey,
48             nonce,  noncelen,
49             header, headerlen,
50             pt,     ptlen,
51             ct,
52             tag,    taglen,
53             direction);
54     }
55     len = ptlen;
56     L   = 0;
57     while (len) {
58        ++L;
59        len >>= 8;
60     }
61     if (L <= 1) {
62        L = 2;
63     }
64     noncelen = (noncelen > 13) ? 13 : noncelen;
65     if ((15 - noncelen) > L) {
66        L = 15 - noncelen;
67     }
68     if (L > 8) {
69        return CRYPT_INVALID_ARG;
70     }
71     if (uskey == NULL) {
72        skey = XMALLOC(sizeof(*skey));
73        if (skey == NULL) {
74           return CRYPT_MEM;
75        }
76        if ((err = cipher_descriptor[cipher].setup(key, keylen, 0, skey)) != CRYPT_OK) {
77           XFREE(skey);
78           return err;
79        }
80     } else {
81        skey = uskey;
82     }
83     if (direction == CCM_DECRYPT && ptlen > 0) {
84        pt_work = XMALLOC(ptlen);
85        if (pt_work == NULL) {
86           goto error;
87        }
88        pt = pt_work;
89     }
90     x = 0;
91     PAD[x++] = (unsigned char)(((headerlen > 0) ? (1<<6) : 0) |
92              (((*taglen - 2)>>1)<<3)        |
93              (L-1));
94     for (y = 0; y < 15 - L; y++) {
95         PAD[x++] = nonce[y];
96     }
97     len = ptlen;
98     for (y = L; y < 4; y++) {
99         len <<= 8;
100     }
101     for (y = 0; L > 4 && (L-y)>4; y++) {
102         PAD[x++] = 0;
103     }
104     for (; y < L; y++) {
105         PAD[x++] = (unsigned char)((len >> 24) & 255);
106         len <<= 8;
107     }
108     if ((err = cipher_descriptor[cipher].ecb_encrypt(PAD, PAD, skey)) != CRYPT_OK) {
109         goto error;
110     }
111     if (headerlen > 0) {
112        x = 0;
113        if (headerlen < ((1UL<<16) - (1UL<<8))) {
114           PAD[x++] ^= (headerlen>>8) & 255;
115           PAD[x++] ^= headerlen & 255;
<span onclick='openModal()' class='match'>116        } else {
117           PAD[x++] ^= 0xFF;
118           PAD[x++] ^= 0xFE;
119           PAD[x++] ^= (headerlen>>24) & 255;
120           PAD[x++] ^= (headerlen>>16) & 255;
121           PAD[x++] ^= (headerlen>>8) & 255;
122           PAD[x++] ^= headerlen & 255;
</span>123        }
124        for (y = 0; y < headerlen; y++) {
125            if (x == 16) {
126               if ((err = cipher_descriptor[cipher].ecb_encrypt(PAD, PAD, skey)) != CRYPT_OK) {
127                  goto error;
128               }
129               x = 0;
130            }
131            PAD[x++] ^= header[y];
132        }
133        if ((err = cipher_descriptor[cipher].ecb_encrypt(PAD, PAD, skey)) != CRYPT_OK) {
134           goto error;
135        }
136     }
137     x = 0;
138     ctr[x++] = (unsigned char)L-1;
139     for (y = 0; y < (16 - (L+1)); ++y) {
140        ctr[x++] = nonce[y];
141     }
142     while (x < 16) {
143        ctr[x++] = 0;
144     }
145     x      = 0;
146     CTRlen = 16;
147     if (ptlen > 0) {
148        y = 0;
149  #ifdef LTC_FAST
150        if (ptlen & ~15)  {
151            if (direction == CCM_ENCRYPT) {
152               for (; y < (ptlen & ~15); y += 16) {
153                  for (z = 15; z > 15-L; z--) {
154                      ctr[z] = (ctr[z] + 1) & 255;
155                      if (ctr[z]) break;
156                  }
157                  if ((err = cipher_descriptor[cipher].ecb_encrypt(ctr, CTRPAD, skey)) != CRYPT_OK) {
158                     goto error;
159                  }
160                  for (z = 0; z < 16; z += sizeof(LTC_FAST_TYPE)) {
161                      *(LTC_FAST_TYPE_PTR_CAST(&PAD[z]))  ^= *(LTC_FAST_TYPE_PTR_CAST(&pt[y+z]));
162                      *(LTC_FAST_TYPE_PTR_CAST(&ct[y+z])) = *(LTC_FAST_TYPE_PTR_CAST(&pt[y+z])) ^ *(LTC_FAST_TYPE_PTR_CAST(&CTRPAD[z]));
163                  }
164                  if ((err = cipher_descriptor[cipher].ecb_encrypt(PAD, PAD, skey)) != CRYPT_OK) {
165                     goto error;
166                  }
167               }
168            } else { &bsol;* direction == CCM_DECRYPT */
169               for (; y < (ptlen & ~15); y += 16) {
170                  for (z = 15; z > 15-L; z--) {
171                      ctr[z] = (ctr[z] + 1) & 255;
172                      if (ctr[z]) break;
173                  }
174                  if ((err = cipher_descriptor[cipher].ecb_encrypt(ctr, CTRPAD, skey)) != CRYPT_OK) {
175                     goto error;
176                  }
177                  for (z = 0; z < 16; z += sizeof(LTC_FAST_TYPE)) {
178                      *(LTC_FAST_TYPE_PTR_CAST(&pt[y+z])) = *(LTC_FAST_TYPE_PTR_CAST(&ct[y+z])) ^ *(LTC_FAST_TYPE_PTR_CAST(&CTRPAD[z]));
179                      *(LTC_FAST_TYPE_PTR_CAST(&PAD[z]))  ^= *(LTC_FAST_TYPE_PTR_CAST(&pt[y+z]));
180                  }
181                  if ((err = cipher_descriptor[cipher].ecb_encrypt(PAD, PAD, skey)) != CRYPT_OK) {
182                     goto error;
183                  }
184               }
185            }
186        }
187  #endif
188        for (; y < ptlen; y++) {
189            if (CTRlen == 16) {
190               for (z = 15; z > 15-L; z--) {
191                   ctr[z] = (ctr[z] + 1) & 255;
192                   if (ctr[z]) break;
193               }
194               if ((err = cipher_descriptor[cipher].ecb_encrypt(ctr, CTRPAD, skey)) != CRYPT_OK) {
195                  goto error;
196               }
197               CTRlen = 0;
198            }
199            if (direction == CCM_ENCRYPT) {
200               b     = pt[y];
201               ct[y] = b ^ CTRPAD[CTRlen++];
202            } else {
203               b     = ct[y] ^ CTRPAD[CTRlen++];
204               pt[y] = b;
205            }
206            if (x == 16) {
207               if ((err = cipher_descriptor[cipher].ecb_encrypt(PAD, PAD, skey)) != CRYPT_OK) {
208                  goto error;
209               }
210               x = 0;
211            }
212            PAD[x++] ^= b;
213        }
214        if (x != 0) {
215           if ((err = cipher_descriptor[cipher].ecb_encrypt(PAD, PAD, skey)) != CRYPT_OK) {
216              goto error;
217           }
218        }
219     }
220     for (y = 15; y > 15 - L; y--) {
221        ctr[y] = 0x00;
222     }
223     if ((err = cipher_descriptor[cipher].ecb_encrypt(ctr, CTRPAD, skey)) != CRYPT_OK) {
224        goto error;
225     }
226     if (skey != uskey) {
227        cipher_descriptor[cipher].done(skey);
228  #ifdef LTC_CLEAN_STACK
229        zeromem(skey,   sizeof(*skey));
230  #endif
231     }
232     if (direction == CCM_ENCRYPT) {
233        for (x = 0; x < 16 && x < *taglen; x++) {
234            tag[x] = PAD[x] ^ CTRPAD[x];
235        }
236        *taglen = x;
237     } else { &bsol;* direction == CCM_DECRYPT */
238        for (x = 0; x < 16 && x < *taglen; x++) {
239           ptTag[x] = tag[x] ^ CTRPAD[x];
240        }
241        *taglen = x;
242        err = XMEM_NEQ(ptTag, PAD, *taglen);
243        if (ptlen > 0) {
244           copy_or_zeromem(pt, pt_real, ptlen, err);
245        }
246     }
247  #ifdef LTC_CLEAN_STACK
248     zeromem(PAD,    sizeof(PAD));
249     zeromem(CTRPAD, sizeof(CTRPAD));
250     if (pt_work != NULL) {
251       zeromem(pt_work, ptlen);
252     }
253  #endif
254  error:
255     if (pt_work) {
256        XFREE(pt_work);
257     }
258     if (skey != uskey) {
259        XFREE(skey);
260     }
261     return err;
262  }
263  #endif
</code></pre>
        </div>
        <div class="column">
            <h3>libfuse-MDEwOlJlcG9zaXRvcnk0ODI5NjE3Nw==-flat-passthrough_ll.c</h3>
            <pre><code>1  #define _GNU_SOURCE
2  #define FUSE_USE_VERSION 34
3  #include <fuse_lowlevel.h>
4  #include <unistd.h>
5  #include <stdlib.h>
6  #include <stdio.h>
7  #include <stddef.h>
8  #include <stdbool.h>
9  #include <string.h>
10  #include <limits.h>
11  #include <dirent.h>
12  #include <assert.h>
13  #include <errno.h>
14  #include <inttypes.h>
15  #include <pthread.h>
16  #include <sys/file.h>
17  #include <sys/xattr.h>
18  #include "passthrough_helpers.h"
19  #if defined(__GNUC__) && (__GNUC__ > 4 || __GNUC__ == 4 && __GNUC_MINOR__ >= 6) && !defined __cplusplus
20  _Static_assert(sizeof(fuse_ino_t) >= sizeof(uintptr_t),
21  	       "fuse_ino_t too small to hold uintptr_t values!");
22  #else
23  struct _uintptr_to_must_hold_fuse_ino_t_dummy_struct \
24  	{ unsigned _uintptr_to_must_hold_fuse_ino_t:
25  			((sizeof(fuse_ino_t) >= sizeof(uintptr_t)) ? 1 : -1); };
26  #endif
27  struct lo_inode {
28  	struct lo_inode *next; &bsol;* protected by lo->mutex */
29  	struct lo_inode *prev; &bsol;* protected by lo->mutex */
30  	int fd;
31  	ino_t ino;
32  	dev_t dev;
33  	uint64_t refcount; &bsol;* protected by lo->mutex */
34  };
35  enum {
36  	CACHE_NEVER,
37  	CACHE_NORMAL,
38  	CACHE_ALWAYS,
39  };
40  struct lo_data {
41  	pthread_mutex_t mutex;
42  	int debug;
43  	int writeback;
44  	int flock;
45  	int xattr;
46  	char *source;
47  	double timeout;
48  	int cache;
49  	int timeout_set;
50  	struct lo_inode root; &bsol;* protected by lo->mutex */
51  };
52  static const struct fuse_opt lo_opts[] = {
53  	{ "writeback",
54  	  offsetof(struct lo_data, writeback), 1 },
55  	{ "no_writeback",
56  	  offsetof(struct lo_data, writeback), 0 },
57  	{ "source=%s",
58  	  offsetof(struct lo_data, source), 0 },
59  	{ "flock",
60  	  offsetof(struct lo_data, flock), 1 },
61  	{ "no_flock",
62  	  offsetof(struct lo_data, flock), 0 },
63  	{ "xattr",
64  	  offsetof(struct lo_data, xattr), 1 },
65  	{ "no_xattr",
66  	  offsetof(struct lo_data, xattr), 0 },
67  	{ "timeout=%lf",
68  	  offsetof(struct lo_data, timeout), 0 },
69  	{ "timeout=",
70  	  offsetof(struct lo_data, timeout_set), 1 },
71  	{ "cache=never",
72  	  offsetof(struct lo_data, cache), CACHE_NEVER },
73  	{ "cache=auto",
74  	  offsetof(struct lo_data, cache), CACHE_NORMAL },
75  	{ "cache=always",
76  	  offsetof(struct lo_data, cache), CACHE_ALWAYS },
77  	FUSE_OPT_END
78  };
79  static void passthrough_ll_help(void)
80  {
81  	printf(
82  "    -o writeback           Enable writeback\n"
83  "    -o no_writeback        Disable write back\n"
84  "    -o source=/home/dir    Source directory to be mounted\n"
85  "    -o flock               Enable flock\n"
86  "    -o no_flock            Disable flock\n"
87  "    -o xattr               Enable xattr\n"
88  "    -o no_xattr            Disable xattr\n"
89  "    -o timeout=1.0         Caching timeout\n"
90  "    -o timeout=0/1         Timeout is set\n"
91  "    -o cache=never         Disable cache\n"
92  "    -o cache=auto          Auto enable cache\n"
93  "    -o cache=always        Cache always\n");
94  }
95  static struct lo_data *lo_data(fuse_req_t req)
96  {
97  	return (struct lo_data *) fuse_req_userdata(req);
98  }
99  static struct lo_inode *lo_inode(fuse_req_t req, fuse_ino_t ino)
100  {
101  	if (ino == FUSE_ROOT_ID)
102  		return &lo_data(req)->root;
103  	else
104  		return (struct lo_inode *) (uintptr_t) ino;
105  }
106  static int lo_fd(fuse_req_t req, fuse_ino_t ino)
107  {
108  	return lo_inode(req, ino)->fd;
109  }
110  static bool lo_debug(fuse_req_t req)
111  {
112  	return lo_data(req)->debug != 0;
113  }
114  static void lo_init(void *userdata,
115  		    struct fuse_conn_info *conn)
116  {
117  	struct lo_data *lo = (struct lo_data*) userdata;
118  	if(conn->capable & FUSE_CAP_EXPORT_SUPPORT)
119  		conn->want |= FUSE_CAP_EXPORT_SUPPORT;
120  	if (lo->writeback &&
121  	    conn->capable & FUSE_CAP_WRITEBACK_CACHE) {
122  		if (lo->debug)
123  			fuse_log(FUSE_LOG_DEBUG, "lo_init: activating writeback\n");
124  		conn->want |= FUSE_CAP_WRITEBACK_CACHE;
125  	}
126  	if (lo->flock && conn->capable & FUSE_CAP_FLOCK_LOCKS) {
127  		if (lo->debug)
128  			fuse_log(FUSE_LOG_DEBUG, "lo_init: activating flock locks\n");
129  		conn->want |= FUSE_CAP_FLOCK_LOCKS;
130  	}
131  }
132  static void lo_destroy(void *userdata)
133  {
134  	struct lo_data *lo = (struct lo_data*) userdata;
135  	while (lo->root.next != &lo->root) {
136  		struct lo_inode* next = lo->root.next;
137  		lo->root.next = next->next;
138  		free(next);
139  	}
140  }
141  static void lo_getattr(fuse_req_t req, fuse_ino_t ino,
142  			     struct fuse_file_info *fi)
143  {
144  	int res;
145  	struct stat buf;
146  	struct lo_data *lo = lo_data(req);
147  	(void) fi;
148  	res = fstatat(lo_fd(req, ino), "", &buf, AT_EMPTY_PATH | AT_SYMLINK_NOFOLLOW);
149  	if (res == -1)
150  		return (void) fuse_reply_err(req, errno);
151  	fuse_reply_attr(req, &buf, lo->timeout);
152  }
153  static void lo_setattr(fuse_req_t req, fuse_ino_t ino, struct stat *attr,
154  		       int valid, struct fuse_file_info *fi)
155  {
156  	int saverr;
157  	char procname[64];
158  	struct lo_inode *inode = lo_inode(req, ino);
159  	int ifd = inode->fd;
160  	int res;
161  	if (valid & FUSE_SET_ATTR_MODE) {
162  		if (fi) {
163  			res = fchmod(fi->fh, attr->st_mode);
164  		} else {
165  			sprintf(procname, "/proc/self/fd/%i", ifd);
166  			res = chmod(procname, attr->st_mode);
167  		}
168  		if (res == -1)
169  			goto out_err;
170  	}
171  	if (valid & (FUSE_SET_ATTR_UID | FUSE_SET_ATTR_GID)) {
172  		uid_t uid = (valid & FUSE_SET_ATTR_UID) ?
173  			attr->st_uid : (uid_t) -1;
174  		gid_t gid = (valid & FUSE_SET_ATTR_GID) ?
175  			attr->st_gid : (gid_t) -1;
176  		res = fchownat(ifd, "", uid, gid,
177  			       AT_EMPTY_PATH | AT_SYMLINK_NOFOLLOW);
178  		if (res == -1)
179  			goto out_err;
180  	}
181  	if (valid & FUSE_SET_ATTR_SIZE) {
182  		if (fi) {
183  			res = ftruncate(fi->fh, attr->st_size);
184  		} else {
185  			sprintf(procname, "/proc/self/fd/%i", ifd);
186  			res = truncate(procname, attr->st_size);
187  		}
188  		if (res == -1)
189  			goto out_err;
190  	}
191  	if (valid & (FUSE_SET_ATTR_ATIME | FUSE_SET_ATTR_MTIME)) {
192  		struct timespec tv[2];
193  		tv[0].tv_sec = 0;
194  		tv[1].tv_sec = 0;
195  		tv[0].tv_nsec = UTIME_OMIT;
196  		tv[1].tv_nsec = UTIME_OMIT;
197  		if (valid & FUSE_SET_ATTR_ATIME_NOW)
198  			tv[0].tv_nsec = UTIME_NOW;
199  		else if (valid & FUSE_SET_ATTR_ATIME)
200  			tv[0] = attr->st_atim;
201  		if (valid & FUSE_SET_ATTR_MTIME_NOW)
202  			tv[1].tv_nsec = UTIME_NOW;
203  		else if (valid & FUSE_SET_ATTR_MTIME)
204  			tv[1] = attr->st_mtim;
205  		if (fi)
206  			res = futimens(fi->fh, tv);
207  		else {
208  			sprintf(procname, "/proc/self/fd/%i", ifd);
209  			res = utimensat(AT_FDCWD, procname, tv, 0);
210  		}
211  		if (res == -1)
212  			goto out_err;
213  	}
214  	return lo_getattr(req, ino, fi);
215  out_err:
216  	saverr = errno;
217  	fuse_reply_err(req, saverr);
218  }
219  static struct lo_inode *lo_find(struct lo_data *lo, struct stat *st)
220  {
221  	struct lo_inode *p;
222  	struct lo_inode *ret = NULL;
223  	pthread_mutex_lock(&lo->mutex);
224  	for (p = lo->root.next; p != &lo->root; p = p->next) {
225  		if (p->ino == st->st_ino && p->dev == st->st_dev) {
226  			assert(p->refcount > 0);
227  			ret = p;
228  			ret->refcount++;
229  			break;
230  		}
231  	}
232  	pthread_mutex_unlock(&lo->mutex);
233  	return ret;
234  }
235  static int lo_do_lookup(fuse_req_t req, fuse_ino_t parent, const char *name,
236  			 struct fuse_entry_param *e)
237  {
238  	int newfd;
239  	int res;
240  	int saverr;
241  	struct lo_data *lo = lo_data(req);
242  	struct lo_inode *inode;
243  	memset(e, 0, sizeof(*e));
244  	e->attr_timeout = lo->timeout;
245  	e->entry_timeout = lo->timeout;
246  	newfd = openat(lo_fd(req, parent), name, O_PATH | O_NOFOLLOW);
247  	if (newfd == -1)
248  		goto out_err;
249  	res = fstatat(newfd, "", &e->attr, AT_EMPTY_PATH | AT_SYMLINK_NOFOLLOW);
250  	if (res == -1)
251  		goto out_err;
252  	inode = lo_find(lo_data(req), &e->attr);
253  	if (inode) {
254  		close(newfd);
255  		newfd = -1;
256  	} else {
257  		struct lo_inode *prev, *next;
258  		saverr = ENOMEM;
259  		inode = calloc(1, sizeof(struct lo_inode));
260  		if (!inode)
261  			goto out_err;
262  		inode->refcount = 1;
263  		inode->fd = newfd;
264  		inode->ino = e->attr.st_ino;
265  		inode->dev = e->attr.st_dev;
266  		pthread_mutex_lock(&lo->mutex);
267  		prev = &lo->root;
268  		next = prev->next;
269  		next->prev = inode;
270  		inode->next = next;
271  		inode->prev = prev;
272  		prev->next = inode;
273  		pthread_mutex_unlock(&lo->mutex);
274  	}
275  	e->ino = (uintptr_t) inode;
276  	if (lo_debug(req))
277  		fuse_log(FUSE_LOG_DEBUG, "  %lli/%s -> %lli\n",
278  			(unsigned long long) parent, name, (unsigned long long) e->ino);
279  	return 0;
280  out_err:
281  	saverr = errno;
282  	if (newfd != -1)
283  		close(newfd);
284  	return saverr;
285  }
286  static void lo_lookup(fuse_req_t req, fuse_ino_t parent, const char *name)
287  {
288  	struct fuse_entry_param e;
289  	int err;
290  	if (lo_debug(req))
291  		fuse_log(FUSE_LOG_DEBUG, "lo_lookup(parent=%" PRIu64 ", name=%s)\n",
292  			parent, name);
293  	err = lo_do_lookup(req, parent, name, &e);
294  	if (err)
295  		fuse_reply_err(req, err);
296  	else
297  		fuse_reply_entry(req, &e);
298  }
299  static void lo_mknod_symlink(fuse_req_t req, fuse_ino_t parent,
300  			     const char *name, mode_t mode, dev_t rdev,
301  			     const char *link)
302  {
303  	int res;
304  	int saverr;
305  	struct lo_inode *dir = lo_inode(req, parent);
306  	struct fuse_entry_param e;
307  	res = mknod_wrapper(dir->fd, name, link, mode, rdev);
308  	saverr = errno;
309  	if (res == -1)
310  		goto out;
311  	saverr = lo_do_lookup(req, parent, name, &e);
312  	if (saverr)
313  		goto out;
314  	if (lo_debug(req))
315  		fuse_log(FUSE_LOG_DEBUG, "  %lli/%s -> %lli\n",
316  			(unsigned long long) parent, name, (unsigned long long) e.ino);
317  	fuse_reply_entry(req, &e);
318  	return;
319  out:
320  	fuse_reply_err(req, saverr);
321  }
322  static void lo_mknod(fuse_req_t req, fuse_ino_t parent,
323  		     const char *name, mode_t mode, dev_t rdev)
324  {
325  	lo_mknod_symlink(req, parent, name, mode, rdev, NULL);
326  }
327  static void lo_mkdir(fuse_req_t req, fuse_ino_t parent, const char *name,
328  		     mode_t mode)
329  {
330  	lo_mknod_symlink(req, parent, name, S_IFDIR | mode, 0, NULL);
331  }
332  static void lo_symlink(fuse_req_t req, const char *link,
333  		       fuse_ino_t parent, const char *name)
334  {
335  	lo_mknod_symlink(req, parent, name, S_IFLNK, 0, link);
336  }
337  static void lo_link(fuse_req_t req, fuse_ino_t ino, fuse_ino_t parent,
338  		    const char *name)
339  {
340  	int res;
341  	struct lo_data *lo = lo_data(req);
342  	struct lo_inode *inode = lo_inode(req, ino);
343  	struct fuse_entry_param e;
344  	char procname[64];
345  	int saverr;
346  	memset(&e, 0, sizeof(struct fuse_entry_param));
347  	e.attr_timeout = lo->timeout;
348  	e.entry_timeout = lo->timeout;
349  	sprintf(procname, "/proc/self/fd/%i", inode->fd);
350  	res = linkat(AT_FDCWD, procname, lo_fd(req, parent), name,
351  		     AT_SYMLINK_FOLLOW);
352  	if (res == -1)
353  		goto out_err;
354  	res = fstatat(inode->fd, "", &e.attr, AT_EMPTY_PATH | AT_SYMLINK_NOFOLLOW);
355  	if (res == -1)
356  		goto out_err;
357  	pthread_mutex_lock(&lo->mutex);
358  	inode->refcount++;
359  	pthread_mutex_unlock(&lo->mutex);
360  	e.ino = (uintptr_t) inode;
361  	if (lo_debug(req))
362  		fuse_log(FUSE_LOG_DEBUG, "  %lli/%s -> %lli\n",
363  			(unsigned long long) parent, name,
364  			(unsigned long long) e.ino);
365  	fuse_reply_entry(req, &e);
366  	return;
367  out_err:
368  	saverr = errno;
369  	fuse_reply_err(req, saverr);
370  }
371  static void lo_rmdir(fuse_req_t req, fuse_ino_t parent, const char *name)
372  {
373  	int res;
374  	res = unlinkat(lo_fd(req, parent), name, AT_REMOVEDIR);
375  	fuse_reply_err(req, res == -1 ? errno : 0);
376  }
377  static void lo_rename(fuse_req_t req, fuse_ino_t parent, const char *name,
378  		      fuse_ino_t newparent, const char *newname,
379  		      unsigned int flags)
380  {
381  	int res;
382  	if (flags) {
383  		fuse_reply_err(req, EINVAL);
384  		return;
385  	}
386  	res = renameat(lo_fd(req, parent), name,
387  			lo_fd(req, newparent), newname);
388  	fuse_reply_err(req, res == -1 ? errno : 0);
389  }
390  static void lo_unlink(fuse_req_t req, fuse_ino_t parent, const char *name)
391  {
392  	int res;
393  	res = unlinkat(lo_fd(req, parent), name, 0);
394  	fuse_reply_err(req, res == -1 ? errno : 0);
395  }
396  static void unref_inode(struct lo_data *lo, struct lo_inode *inode, uint64_t n)
397  {
398  	if (!inode)
399  		return;
400  	pthread_mutex_lock(&lo->mutex);
401  	assert(inode->refcount >= n);
402  	inode->refcount -= n;
403  	if (!inode->refcount) {
404  		struct lo_inode *prev, *next;
405  		prev = inode->prev;
406  		next = inode->next;
407  		next->prev = prev;
408  		prev->next = next;
409  		pthread_mutex_unlock(&lo->mutex);
410  		close(inode->fd);
411  		free(inode);
412  	} else {
413  		pthread_mutex_unlock(&lo->mutex);
414  	}
415  }
416  static void lo_forget_one(fuse_req_t req, fuse_ino_t ino, uint64_t nlookup)
417  {
418  	struct lo_data *lo = lo_data(req);
419  	struct lo_inode *inode = lo_inode(req, ino);
420  	if (lo_debug(req)) {
421  		fuse_log(FUSE_LOG_DEBUG, "  forget %lli %lli -%lli\n",
422  			(unsigned long long) ino,
423  			(unsigned long long) inode->refcount,
424  			(unsigned long long) nlookup);
425  	}
426  	unref_inode(lo, inode, nlookup);
427  }
428  static void lo_forget(fuse_req_t req, fuse_ino_t ino, uint64_t nlookup)
429  {
430  	lo_forget_one(req, ino, nlookup);
431  	fuse_reply_none(req);
432  }
433  static void lo_forget_multi(fuse_req_t req, size_t count,
434  				struct fuse_forget_data *forgets)
435  {
436  	int i;
437  	for (i = 0; i < count; i++)
438  		lo_forget_one(req, forgets[i].ino, forgets[i].nlookup);
439  	fuse_reply_none(req);
440  }
441  static void lo_readlink(fuse_req_t req, fuse_ino_t ino)
442  {
443  	char buf[PATH_MAX + 1];
444  	int res;
445  	res = readlinkat(lo_fd(req, ino), "", buf, sizeof(buf));
446  	if (res == -1)
447  		return (void) fuse_reply_err(req, errno);
448  	if (res == sizeof(buf))
449  		return (void) fuse_reply_err(req, ENAMETOOLONG);
450  	buf[res] = '\0';
451  	fuse_reply_readlink(req, buf);
452  }
453  struct lo_dirp {
454  	DIR *dp;
455  	struct dirent *entry;
456  	off_t offset;
457  };
458  static struct lo_dirp *lo_dirp(struct fuse_file_info *fi)
459  {
460  	return (struct lo_dirp *) (uintptr_t) fi->fh;
461  }
462  static void lo_opendir(fuse_req_t req, fuse_ino_t ino, struct fuse_file_info *fi)
463  {
464  	int error = ENOMEM;
465  	struct lo_data *lo = lo_data(req);
466  	struct lo_dirp *d;
467  	int fd;
468  	d = calloc(1, sizeof(struct lo_dirp));
469  	if (d == NULL)
470  		goto out_err;
471  	fd = openat(lo_fd(req, ino), ".", O_RDONLY);
472  	if (fd == -1)
473  		goto out_errno;
474  	d->dp = fdopendir(fd);
475  	if (d->dp == NULL)
476  		goto out_errno;
477  	d->offset = 0;
478  	d->entry = NULL;
479  	fi->fh = (uintptr_t) d;
480  	if (lo->cache == CACHE_ALWAYS)
481  		fi->cache_readdir = 1;
482  	fuse_reply_open(req, fi);
483  	return;
484  out_errno:
485  	error = errno;
486  out_err:
487  	if (d) {
488  		if (fd != -1)
489  			close(fd);
490  		free(d);
491  	}
492  	fuse_reply_err(req, error);
493  }
494  static int is_dot_or_dotdot(const char *name)
495  {
496  	return name[0] == '.' && (name[1] == '\0' ||
497  				  (name[1] == '.' && name[2] == '\0'));
498  }
499  static void lo_do_readdir(fuse_req_t req, fuse_ino_t ino, size_t size,
500  			  off_t offset, struct fuse_file_info *fi, int plus)
501  {
502  	struct lo_dirp *d = lo_dirp(fi);
503  	char *buf;
504  	char *p;
505  	size_t rem = size;
506  	int err;
507  	(void) ino;
508  	buf = calloc(1, size);
509  	if (!buf) {
510  		err = ENOMEM;
511  		goto error;
512  	}
513  	p = buf;
514  	if (offset != d->offset) {
515  		seekdir(d->dp, offset);
516  		d->entry = NULL;
517  		d->offset = offset;
518  	}
519  	while (1) {
520  		size_t entsize;
521  		off_t nextoff;
522  		const char *name;
523  		if (!d->entry) {
524  			errno = 0;
525  			d->entry = readdir(d->dp);
526  			if (!d->entry) {
527  				if (errno) {  
528  					err = errno;
529  					goto error;
530  				} else {  
531  					break; 
532  				}
533  			}
534  		}
535  		nextoff = d->entry->d_off;
536  		name = d->entry->d_name;
537  		fuse_ino_t entry_ino = 0;
538  		if (plus) {
539  			struct fuse_entry_param e;
540  			if (is_dot_or_dotdot(name)) {
541  				e = (struct fuse_entry_param) {
542  					.attr.st_ino = d->entry->d_ino,
543  					.attr.st_mode = d->entry->d_type << 12,
544  				};
545  			} else {
546  				err = lo_do_lookup(req, ino, name, &e);
547  				if (err)
548  					goto error;
549  				entry_ino = e.ino;
550  			}
551  			entsize = fuse_add_direntry_plus(req, p, rem, name,
552  							 &e, nextoff);
553  		} else {
554  			struct stat st = {
555  				.st_ino = d->entry->d_ino,
556  				.st_mode = d->entry->d_type << 12,
557  			};
558  			entsize = fuse_add_direntry(req, p, rem, name,
559  						    &st, nextoff);
560  		}
561  		if (entsize > rem) {
562  			if (entry_ino != 0) 
563  				lo_forget_one(req, entry_ino, 1);
564  			break;
565  		}
566  		p += entsize;
567  		rem -= entsize;
568  		d->entry = NULL;
569  		d->offset = nextoff;
570  	}
571      err = 0;
572  error:
573      if (err && rem == size)
574  	    fuse_reply_err(req, err);
575      else
576  	    fuse_reply_buf(req, buf, size - rem);
577      free(buf);
578  }
579  static void lo_readdir(fuse_req_t req, fuse_ino_t ino, size_t size,
580  		       off_t offset, struct fuse_file_info *fi)
581  {
582  	lo_do_readdir(req, ino, size, offset, fi, 0);
583  }
584  static void lo_readdirplus(fuse_req_t req, fuse_ino_t ino, size_t size,
585  			   off_t offset, struct fuse_file_info *fi)
586  {
587  	lo_do_readdir(req, ino, size, offset, fi, 1);
588  }
589  static void lo_releasedir(fuse_req_t req, fuse_ino_t ino, struct fuse_file_info *fi)
590  {
591  	struct lo_dirp *d = lo_dirp(fi);
592  	(void) ino;
593  	closedir(d->dp);
594  	free(d);
595  	fuse_reply_err(req, 0);
596  }
597  static void lo_create(fuse_req_t req, fuse_ino_t parent, const char *name,
598  		      mode_t mode, struct fuse_file_info *fi)
599  {
600  	int fd;
601  	struct lo_data *lo = lo_data(req);
602  	struct fuse_entry_param e;
603  	int err;
604  	if (lo_debug(req))
605  		fuse_log(FUSE_LOG_DEBUG, "lo_create(parent=%" PRIu64 ", name=%s)\n",
606  			parent, name);
607  	fd = openat(lo_fd(req, parent), name,
608  		    (fi->flags | O_CREAT) & ~O_NOFOLLOW, mode);
609  	if (fd == -1)
610  		return (void) fuse_reply_err(req, errno);
611  	fi->fh = fd;
612  	if (lo->cache == CACHE_NEVER)
613  		fi->direct_io = 1;
614  	else if (lo->cache == CACHE_ALWAYS)
615  		fi->keep_cache = 1;
616  	err = lo_do_lookup(req, parent, name, &e);
617  	if (err)
618  		fuse_reply_err(req, err);
619  	else
620  		fuse_reply_create(req, &e, fi);
621  }
622  static void lo_fsyncdir(fuse_req_t req, fuse_ino_t ino, int datasync,
623  			struct fuse_file_info *fi)
624  {
625  	int res;
626  	int fd = dirfd(lo_dirp(fi)->dp);
627  	(void) ino;
628  	if (datasync)
629  		res = fdatasync(fd);
630  	else
631  		res = fsync(fd);
632  	fuse_reply_err(req, res == -1 ? errno : 0);
633  }
634  static void lo_open(fuse_req_t req, fuse_ino_t ino, struct fuse_file_info *fi)
635  {
636  	int fd;
637  	char buf[64];
638  	struct lo_data *lo = lo_data(req);
639  	if (lo_debug(req))
640  		fuse_log(FUSE_LOG_DEBUG, "lo_open(ino=%" PRIu64 ", flags=%d)\n",
641  			ino, fi->flags);
642  	if (lo->writeback && (fi->flags & O_ACCMODE) == O_WRONLY) {
643  		fi->flags &= ~O_ACCMODE;
644  		fi->flags |= O_RDWR;
645  	}
646  	if (lo->writeback && (fi->flags & O_APPEND))
647  		fi->flags &= ~O_APPEND;
648  	sprintf(buf, "/proc/self/fd/%i", lo_fd(req, ino));
649  	fd = open(buf, fi->flags & ~O_NOFOLLOW);
650  	if (fd == -1)
651  		return (void) fuse_reply_err(req, errno);
652  	fi->fh = fd;
653  	if (lo->cache == CACHE_NEVER)
654  		fi->direct_io = 1;
655  	else if (lo->cache == CACHE_ALWAYS)
656  		fi->keep_cache = 1;
657  	fuse_reply_open(req, fi);
658  }
659  static void lo_release(fuse_req_t req, fuse_ino_t ino, struct fuse_file_info *fi)
660  {
661  	(void) ino;
662  	close(fi->fh);
663  	fuse_reply_err(req, 0);
664  }
665  static void lo_flush(fuse_req_t req, fuse_ino_t ino, struct fuse_file_info *fi)
666  {
667  	int res;
668  	(void) ino;
669  	res = close(dup(fi->fh));
670  	fuse_reply_err(req, res == -1 ? errno : 0);
671  }
672  static void lo_fsync(fuse_req_t req, fuse_ino_t ino, int datasync,
673  		     struct fuse_file_info *fi)
674  {
675  	int res;
676  	(void) ino;
677  	if (datasync)
678  		res = fdatasync(fi->fh);
679  	else
680  		res = fsync(fi->fh);
681  	fuse_reply_err(req, res == -1 ? errno : 0);
682  }
683  static void lo_read(fuse_req_t req, fuse_ino_t ino, size_t size,
684  		    off_t offset, struct fuse_file_info *fi)
685  {
686  	struct fuse_bufvec buf = FUSE_BUFVEC_INIT(size);
687  	if (lo_debug(req))
688  		fuse_log(FUSE_LOG_DEBUG, "lo_read(ino=%" PRIu64 ", size=%zd, "
689  			"off=%lu)\n", ino, size, (unsigned long) offset);
690  	buf.buf[0].flags = FUSE_BUF_IS_FD | FUSE_BUF_FD_SEEK;
691  	buf.buf[0].fd = fi->fh;
692  	buf.buf[0].pos = offset;
693  	fuse_reply_data(req, &buf, FUSE_BUF_SPLICE_MOVE);
694  }
695  static void lo_write_buf(fuse_req_t req, fuse_ino_t ino,
696  			 struct fuse_bufvec *in_buf, off_t off,
697  			 struct fuse_file_info *fi)
698  {
699  	(void) ino;
700  	ssize_t res;
701  	struct fuse_bufvec out_buf = FUSE_BUFVEC_INIT(fuse_buf_size(in_buf));
702  	out_buf.buf[0].flags = FUSE_BUF_IS_FD | FUSE_BUF_FD_SEEK;
703  	out_buf.buf[0].fd = fi->fh;
704  	out_buf.buf[0].pos = off;
705  	if (lo_debug(req))
706  		fuse_log(FUSE_LOG_DEBUG, "lo_write(ino=%" PRIu64 ", size=%zd, off=%lu)\n",
707  			ino, out_buf.buf[0].size, (unsigned long) off);
708  	res = fuse_buf_copy(&out_buf, in_buf, 0);
709  	if(res < 0)
710  		fuse_reply_err(req, -res);
711  	else
712  		fuse_reply_write(req, (size_t) res);
713  }
714  static void lo_statfs(fuse_req_t req, fuse_ino_t ino)
715  {
716  	int res;
717  	struct statvfs stbuf;
718  	res = fstatvfs(lo_fd(req, ino), &stbuf);
719  	if (res == -1)
720  		fuse_reply_err(req, errno);
721  	else
722  		fuse_reply_statfs(req, &stbuf);
723  }
724  static void lo_fallocate(fuse_req_t req, fuse_ino_t ino, int mode,
725  			 off_t offset, off_t length, struct fuse_file_info *fi)
726  {
727  	int err = EOPNOTSUPP;
728  	(void) ino;
729  #ifdef HAVE_FALLOCATE
730  	err = fallocate(fi->fh, mode, offset, length);
731  	if (err < 0)
732  		err = errno;
733  #elif defined(HAVE_POSIX_FALLOCATE)
734  	if (mode) {
735  		fuse_reply_err(req, EOPNOTSUPP);
736  		return;
737  	}
738  	err = posix_fallocate(fi->fh, offset, length);
739  #endif
740  	fuse_reply_err(req, err);
741  }
742  static void lo_flock(fuse_req_t req, fuse_ino_t ino, struct fuse_file_info *fi,
743  		     int op)
744  {
745  	int res;
746  	(void) ino;
747  	res = flock(fi->fh, op);
748  	fuse_reply_err(req, res == -1 ? errno : 0);
749  }
750  static void lo_getxattr(fuse_req_t req, fuse_ino_t ino, const char *name,
751  			size_t size)
752  {
753  	char *value = NULL;
754  	char procname[64];
755  	struct lo_inode *inode = lo_inode(req, ino);
756  	ssize_t ret;
757  	int saverr;
758  	saverr = ENOSYS;
759  	if (!lo_data(req)->xattr)
760  		goto out;
761  	if (lo_debug(req)) {
762  		fuse_log(FUSE_LOG_DEBUG, "lo_getxattr(ino=%" PRIu64 ", name=%s size=%zd)\n",
763  			ino, name, size);
764  	}
765  	sprintf(procname, "/proc/self/fd/%i", inode->fd);
766  	if (size) {
767  		value = malloc(size);
768  		if (!value)
769  			goto out_err;
770  		ret = getxattr(procname, name, value, size);
771  		if (ret == -1)
772  			goto out_err;
773  		saverr = 0;
774  		if (ret == 0)
775  			goto out;
776  		fuse_reply_buf(req, value, ret);
777  	} else {
778  		ret = getxattr(procname, name, NULL, 0);
779  		if (ret == -1)
780  			goto out_err;
781  		fuse_reply_xattr(req, ret);
782  	}
783  out_free:
784  	free(value);
785  	return;
786  out_err:
787  	saverr = errno;
788  out:
789  	fuse_reply_err(req, saverr);
790  	goto out_free;
791  }
792  static void lo_listxattr(fuse_req_t req, fuse_ino_t ino, size_t size)
793  {
794  	char *value = NULL;
795  	char procname[64];
796  	struct lo_inode *inode = lo_inode(req, ino);
797  	ssize_t ret;
798  	int saverr;
799  	saverr = ENOSYS;
800  	if (!lo_data(req)->xattr)
801  		goto out;
802  	if (lo_debug(req)) {
803  		fuse_log(FUSE_LOG_DEBUG, "lo_listxattr(ino=%" PRIu64 ", size=%zd)\n",
804  			ino, size);
805  	}
806  	sprintf(procname, "/proc/self/fd/%i", inode->fd);
807  	if (size) {
808  		value = malloc(size);
809  		if (!value)
810  			goto out_err;
811  		ret = listxattr(procname, value, size);
812  		if (ret == -1)
813  			goto out_err;
814  		saverr = 0;
815  		if (ret == 0)
816  			goto out;
817  		fuse_reply_buf(req, value, ret);
818  	} else {
819  		ret = listxattr(procname, NULL, 0);
820  		if (ret == -1)
821  			goto out_err;
822  		fuse_reply_xattr(req, ret);
823  	}
824  out_free:
825  	free(value);
826  	return;
827  out_err:
828  	saverr = errno;
829  out:
830  	fuse_reply_err(req, saverr);
831  	goto out_free;
832  }
833  static void lo_setxattr(fuse_req_t req, fuse_ino_t ino, const char *name,
834  			const char *value, size_t size, int flags)
835  {
836  	char procname[64];
837  	struct lo_inode *inode = lo_inode(req, ino);
838  	ssize_t ret;
839  	int saverr;
840  	saverr = ENOSYS;
841  	if (!lo_data(req)->xattr)
842  		goto out;
843  	if (lo_debug(req)) {
844  		fuse_log(FUSE_LOG_DEBUG, "lo_setxattr(ino=%" PRIu64 ", name=%s value=%s size=%zd)\n",
845  			ino, name, value, size);
846  	}
847  	sprintf(procname, "/proc/self/fd/%i", inode->fd);
848  	ret = setxattr(procname, name, value, size, flags);
849  	saverr = ret == -1 ? errno : 0;
850  out:
851  	fuse_reply_err(req, saverr);
852  }
853  static void lo_removexattr(fuse_req_t req, fuse_ino_t ino, const char *name)
854  {
855  	char procname[64];
856  	struct lo_inode *inode = lo_inode(req, ino);
857  	ssize_t ret;
858  	int saverr;
859  	saverr = ENOSYS;
860  	if (!lo_data(req)->xattr)
861  		goto out;
862  	if (lo_debug(req)) {
863  		fuse_log(FUSE_LOG_DEBUG, "lo_removexattr(ino=%" PRIu64 ", name=%s)\n",
864  			ino, name);
865  	}
866  	sprintf(procname, "/proc/self/fd/%i", inode->fd);
867  	ret = removexattr(procname, name);
868  	saverr = ret == -1 ? errno : 0;
869  out:
870  	fuse_reply_err(req, saverr);
871  }
872  #ifdef HAVE_COPY_FILE_RANGE
873  static void lo_copy_file_range(fuse_req_t req, fuse_ino_t ino_in, off_t off_in,
874  			       struct fuse_file_info *fi_in,
875  			       fuse_ino_t ino_out, off_t off_out,
876  			       struct fuse_file_info *fi_out, size_t len,
877  			       int flags)
878  {
879  	ssize_t res;
880  	if (lo_debug(req))
881  		fuse_log(FUSE_LOG_DEBUG, "lo_copy_file_range(ino=%" PRIu64 "/fd=%lu, "
882  				"off=%lu, ino=%" PRIu64 "/fd=%lu, "
883  				"off=%lu, size=%zd, flags=0x%x)\n",
884  			ino_in, fi_in->fh, off_in, ino_out, fi_out->fh, off_out,
885  			len, flags);
886  	res = copy_file_range(fi_in->fh, &off_in, fi_out->fh, &off_out, len,
887  			      flags);
888  	if (res < 0)
889  		fuse_reply_err(req, errno);
890  	else
891  		fuse_reply_write(req, res);
892  }
893  #endif
894  static void lo_lseek(fuse_req_t req, fuse_ino_t ino, off_t off, int whence,
895  		     struct fuse_file_info *fi)
896  {
897  	off_t res;
898  	(void)ino;
899  	res = lseek(fi->fh, off, whence);
900  	if (res != -1)
901  		fuse_reply_lseek(req, res);
902  	else
903  		fuse_reply_err(req, errno);
904  }
<span onclick='openModal()' class='match'>905  static const struct fuse_lowlevel_ops lo_oper = {
906  	.init		= lo_init,
907  	.destroy	= lo_destroy,
908  	.lookup		= lo_lookup,
909  	.mkdir		= lo_mkdir,
910  	.mknod		= lo_mknod,
911  	.symlink	= lo_symlink,
912  	.link		= lo_link,
913  	.unlink		= lo_unlink,
914  	.rmdir		= lo_rmdir,
915  	.rename		= lo_rename,
916  	.forget		= lo_forget,
917  	.forget_multi	= lo_forget_multi,
</span>918  	.getattr	= lo_getattr,
919  	.setattr	= lo_setattr,
920  	.readlink	= lo_readlink,
921  	.opendir	= lo_opendir,
922  	.readdir	= lo_readdir,
923  	.readdirplus	= lo_readdirplus,
924  	.releasedir	= lo_releasedir,
925  	.fsyncdir	= lo_fsyncdir,
926  	.create		= lo_create,
927  	.open		= lo_open,
928  	.release	= lo_release,
929  	.flush		= lo_flush,
930  	.fsync		= lo_fsync,
931  	.read		= lo_read,
932  	.write_buf      = lo_write_buf,
933  	.statfs		= lo_statfs,
934  	.fallocate	= lo_fallocate,
935  	.flock		= lo_flock,
936  	.getxattr	= lo_getxattr,
937  	.listxattr	= lo_listxattr,
938  	.setxattr	= lo_setxattr,
939  	.removexattr	= lo_removexattr,
940  #ifdef HAVE_COPY_FILE_RANGE
941  	.copy_file_range = lo_copy_file_range,
942  #endif
943  	.lseek		= lo_lseek,
944  };
945  int main(int argc, char *argv[])
946  {
947  	struct fuse_args args = FUSE_ARGS_INIT(argc, argv);
948  	struct fuse_session *se;
949  	struct fuse_cmdline_opts opts;
950  	struct fuse_loop_config config;
951  	struct lo_data lo = { .debug = 0,
952  	                      .writeback = 0 };
953  	int ret = -1;
954  	umask(0);
955  	pthread_mutex_init(&lo.mutex, NULL);
956  	lo.root.next = lo.root.prev = &lo.root;
957  	lo.root.fd = -1;
958  	lo.cache = CACHE_NORMAL;
959  	if (fuse_parse_cmdline(&args, &opts) != 0)
960  		return 1;
961  	if (opts.show_help) {
962  		printf("usage: %s [options] <mountpoint>\n\n", argv[0]);
963  		fuse_cmdline_help();
964  		fuse_lowlevel_help();
965  		passthrough_ll_help();
966  		ret = 0;
967  		goto err_out1;
968  	} else if (opts.show_version) {
969  		printf("FUSE library version %s\n", fuse_pkgversion());
970  		fuse_lowlevel_version();
971  		ret = 0;
972  		goto err_out1;
973  	}
974  	if(opts.mountpoint == NULL) {
975  		printf("usage: %s [options] <mountpoint>\n", argv[0]);
976  		printf("       %s --help\n", argv[0]);
977  		ret = 1;
978  		goto err_out1;
979  	}
980  	if (fuse_opt_parse(&args, &lo, lo_opts, NULL)== -1)
981  		return 1;
982  	lo.debug = opts.debug;
983  	lo.root.refcount = 2;
984  	if (lo.source) {
985  		struct stat stat;
986  		int res;
987  		res = lstat(lo.source, &stat);
988  		if (res == -1) {
989  			fuse_log(FUSE_LOG_ERR, "failed to stat source (\"%s\"): %m\n",
990  				 lo.source);
991  			exit(1);
992  		}
993  		if (!S_ISDIR(stat.st_mode)) {
994  			fuse_log(FUSE_LOG_ERR, "source is not a directory\n");
995  			exit(1);
996  		}
997  	} else {
998  		lo.source = strdup("/");
999  		if(!lo.source) {
1000  			fuse_log(FUSE_LOG_ERR, "fuse: memory allocation failed\n");
1001  			exit(1);
1002  		}
1003  	}
1004  	if (!lo.timeout_set) {
1005  		switch (lo.cache) {
1006  		case CACHE_NEVER:
1007  			lo.timeout = 0.0;
1008  			break;
1009  		case CACHE_NORMAL:
1010  			lo.timeout = 1.0;
1011  			break;
1012  		case CACHE_ALWAYS:
1013  			lo.timeout = 86400.0;
1014  			break;
1015  		}
1016  	} else if (lo.timeout < 0) {
1017  		fuse_log(FUSE_LOG_ERR, "timeout is negative (%lf)\n",
1018  			 lo.timeout);
1019  		exit(1);
1020  	}
1021  	lo.root.fd = open(lo.source, O_PATH);
1022  	if (lo.root.fd == -1) {
1023  		fuse_log(FUSE_LOG_ERR, "open(\"%s\", O_PATH): %m\n",
1024  			 lo.source);
1025  		exit(1);
1026  	}
1027  	se = fuse_session_new(&args, &lo_oper, sizeof(lo_oper), &lo);
1028  	if (se == NULL)
1029  	    goto err_out1;
1030  	if (fuse_set_signal_handlers(se) != 0)
1031  	    goto err_out2;
1032  	if (fuse_session_mount(se, opts.mountpoint) != 0)
1033  	    goto err_out3;
1034  	fuse_daemonize(opts.foreground);
1035  	if (opts.singlethread)
1036  		ret = fuse_session_loop(se);
1037  	else {
1038  		config.clone_fd = opts.clone_fd;
1039  		config.max_idle_threads = opts.max_idle_threads;
1040  		ret = fuse_session_loop_mt(se, &config);
1041  	}
1042  	fuse_session_unmount(se);
1043  err_out3:
1044  	fuse_remove_signal_handlers(se);
1045  err_out2:
1046  	fuse_session_destroy(se);
1047  err_out1:
1048  	free(opts.mountpoint);
1049  	fuse_opt_free_args(&args);
1050  	if (lo.root.fd >= 0)
1051  		close(lo.root.fd);
1052  	free(lo.source);
1053  	return ret ? 1 : 0;
1054  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from libtomcrypt-MDEwOlJlcG9zaXRvcnk3NzcwMTE=-flat-ccm_memory.c</div>
                <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from libfuse-MDEwOlJlcG9zaXRvcnk0ODI5NjE3Nw==-flat-passthrough_ll.c</div>
                <div class="column column_space"><pre><code>116        } else {
117           PAD[x++] ^= 0xFF;
118           PAD[x++] ^= 0xFE;
119           PAD[x++] ^= (headerlen>>24) & 255;
120           PAD[x++] ^= (headerlen>>16) & 255;
121           PAD[x++] ^= (headerlen>>8) & 255;
122           PAD[x++] ^= headerlen & 255;
</pre></code></div>
                <div class="column column_space"><pre><code>905  static const struct fuse_lowlevel_ops lo_oper = {
906  	.init		= lo_init,
907  	.destroy	= lo_destroy,
908  	.lookup		= lo_lookup,
909  	.mkdir		= lo_mkdir,
910  	.mknod		= lo_mknod,
911  	.symlink	= lo_symlink,
912  	.link		= lo_link,
913  	.unlink		= lo_unlink,
914  	.rmdir		= lo_rmdir,
915  	.rename		= lo_rename,
916  	.forget		= lo_forget,
917  	.forget_multi	= lo_forget_multi,
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    