
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 18, <button onclick='openModal()' class='match'>CODE CLONE</button></h2>
        <div class="column">
            <h3>xmrig-MDEwOlJlcG9zaXRvcnk4ODMyNzQwNg==-flat-topology-synthetic.c</h3>
            <pre><code>1  #include &quot;private/autogen/config.h&quot;
2  #include &quot;hwloc.h&quot;
3  #include &quot;private/private.h&quot;
4  #include &quot;private/misc.h&quot;
5  #include &quot;private/debug.h&quot;
6  #include &lt;limits.h&gt;
7  #include &lt;assert.h&gt;
8  #ifdef HAVE_STRINGS_H
9  #include &lt;strings.h&gt;
10  #endif
11  struct hwloc_synthetic_attr_s {
12    hwloc_obj_type_t type;
13    unsigned depth; &amp;bsol;* For caches/groups */
14    hwloc_obj_cache_type_t cachetype; &amp;bsol;* For caches */
15    hwloc_uint64_t memorysize; &amp;bsol;* For caches/memory */
16  };
17  struct hwloc_synthetic_indexes_s {
18    const char *string;
19    unsigned long string_length;
20    unsigned *array;
21    unsigned next; &amp;bsol;* id of the next object for that level */
22  };
23  struct hwloc_synthetic_level_data_s {
24    unsigned arity;
25    unsigned long totalwidth;
26    struct hwloc_synthetic_attr_s attr;
27    struct hwloc_synthetic_indexes_s indexes;
28    struct hwloc_synthetic_attached_s {
29      struct hwloc_synthetic_attr_s attr;
30      struct hwloc_synthetic_attached_s *next;
31    } *attached;
32  };
33  struct hwloc_synthetic_backend_data_s {
34    char *string;
35    unsigned long numa_attached_nr;
36    struct hwloc_synthetic_indexes_s numa_attached_indexes;
37  #define HWLOC_SYNTHETIC_MAX_DEPTH 128
38    struct hwloc_synthetic_level_data_s level[HWLOC_SYNTHETIC_MAX_DEPTH];
39  };
40  struct hwloc_synthetic_intlv_loop_s {
41    unsigned step;
42    unsigned nb;
43    unsigned level_depth;
44  };
45  static void
46  hwloc_synthetic_process_indexes(struct hwloc_synthetic_backend_data_s *data,
47  				struct hwloc_synthetic_indexes_s *indexes,
48  				unsigned long total,
49  				int verbose)
50  {
51    const char *attr = indexes-&gt;string;
52    unsigned long length = indexes-&gt;string_length;
53    unsigned *array = NULL;
54    size_t i;
55    if (!attr)
56      return;
57    array = calloc(total, sizeof(*array));
58    if (!array) {
59      if (verbose)
60        fprintf(stderr, &quot;Failed to allocate synthetic index array of size %lu\n&quot;, total);
61      goto out;
62    }
63    i = strspn(attr, &quot;0123456789,&quot;);
64    if (i == length) {
65      for(i=0; i&lt;total; i++) {
66        const char *next;
67        unsigned idx = strtoul(attr, (char **) &amp;next, 10);
68        if (next == attr) {
69  	if (verbose)
70  	  fprintf(stderr, &quot;Failed to read synthetic index #%lu at &#x27;%s&#x27;\n&quot;, (unsigned long) i, attr);
71  	goto out_with_array;
72        }
73        array[i] = idx;
74        if (i != total-1) {
75  	if (*next != &#x27;,&#x27;) {
76  	  if (verbose)
77  	    fprintf(stderr, &quot;Missing comma after synthetic index #%lu at &#x27;%s&#x27;\n&quot;, (unsigned long) i, attr);
78  	  goto out_with_array;
79  	}
80  	attr = next+1;
81        } else {
82  	attr = next;
83        }
84      }
85      indexes-&gt;array = array;
86    } else {
87      unsigned nr_loops = 1, cur_loop;
88      unsigned minstep = total;
89      unsigned long nbs = 1;
90      unsigned j, mul;
91      const char *tmp;
92      struct hwloc_synthetic_intlv_loop_s *loops;
93      tmp = attr;
94      while (tmp) {
95        tmp = strchr(tmp, &#x27;:&#x27;);
96        if (!tmp || tmp &gt;= attr+length)
97  	break;
98        nr_loops++;
99        tmp++;
100      }
101      loops = malloc((nr_loops+1) * sizeof(*loops));
102      if (!loops)
103        goto out_with_array;
104      if (*attr &gt;= &#x27;0&#x27; &amp;&amp; *attr &lt;= &#x27;9&#x27;) {
105        unsigned step, nb;
106        tmp = attr;
107        cur_loop = 0;
108        while (tmp) {
109  	char *tmp2, *tmp3;
110  	step = (unsigned) strtol(tmp, &amp;tmp2, 0);
111  	if (tmp2 == tmp || *tmp2 != &#x27;*&#x27;) {
112  	  if (verbose)
113  	    fprintf(stderr, &quot;Failed to read synthetic index interleaving loop &#x27;%s&#x27; without number before &#x27;*&#x27;\n&quot;, tmp);
114  	  free(loops);
115  	  goto out_with_array;
116  	}
117  	if (!step) {
118  	  if (verbose)
119  	    fprintf(stderr, &quot;Invalid interleaving loop with step 0 at &#x27;%s&#x27;\n&quot;, tmp);
120  	  free(loops);
121  	  goto out_with_array;
122  	}
123  	tmp2++;
124  	nb = (unsigned) strtol(tmp2, &amp;tmp3, 0);
125  	if (tmp3 == tmp2 || (*tmp3 &amp;&amp; *tmp3 != &#x27;:&#x27; &amp;&amp; *tmp3 != &#x27;)&#x27; &amp;&amp; *tmp3 != &#x27; &#x27;)) {
126  	  if (verbose)
127  	    fprintf(stderr, &quot;Failed to read synthetic index interleaving loop &#x27;%s&#x27; without number between &#x27;*&#x27; and &#x27;:&#x27;\n&quot;, tmp);
128  	  free(loops);
129  	  goto out_with_array;
130  	}
131  	if (!nb) {
132  	  if (verbose)
133  	    fprintf(stderr, &quot;Invalid interleaving loop with number 0 at &#x27;%s&#x27;\n&quot;, tmp2);
134  	  free(loops);
135  	  goto out_with_array;
136  	}
137  	loops[cur_loop].step = step;
138  	loops[cur_loop].nb = nb;
139  	if (step &lt; minstep)
140  	  minstep = step;
141  	nbs *= nb;
142  	cur_loop++;
143  	if (*tmp3 == &#x27;)&#x27; || *tmp3 == &#x27; &#x27;)
144  	  break;
145  	tmp = (const char*) (tmp3+1);
146        }
147      } else {
148        hwloc_obj_type_t type;
149        union hwloc_obj_attr_u attrs;
150        int err;
151        tmp = attr;
152        cur_loop = 0;
153        while (tmp) {
154  	err = hwloc_type_sscanf(tmp, &amp;type, &amp;attrs, sizeof(attrs));
155  	if (err &lt; 0) {
156  	  if (verbose)
157  	    fprintf(stderr, &quot;Failed to read synthetic index interleaving loop type &#x27;%s&#x27;\n&quot;, tmp);
158  	  free(loops);
159  	  goto out_with_array;
160  	}
161  	if (type == HWLOC_OBJ_MISC || type == HWLOC_OBJ_BRIDGE || type == HWLOC_OBJ_PCI_DEVICE || type == HWLOC_OBJ_OS_DEVICE) {
162  	  if (verbose)
163  	    fprintf(stderr, &quot;Misc object type disallowed in synthetic index interleaving loop type &#x27;%s&#x27;\n&quot;, tmp);
164  	  free(loops);
165  	  goto out_with_array;
166  	}
167  	for(i=0; ; i++) {
168  	  if (!data-&gt;level[i].arity) {
169  	    loops[cur_loop].level_depth = (unsigned)-1;
170  	    break;
171  	  }
172  	  if (type != data-&gt;level[i].attr.type)
173  	    continue;
174  	  if (type == HWLOC_OBJ_GROUP
175  	      &amp;&amp; attrs.group.depth != (unsigned) -1
176  	      &amp;&amp; attrs.group.depth != data-&gt;level[i].attr.depth)
177  	    continue;
178  	  loops[cur_loop].level_depth = (unsigned)i;
179  	  break;
180  	}
181  	if (loops[cur_loop].level_depth == (unsigned)-1) {
182  	  if (verbose)
183  	    fprintf(stderr, &quot;Failed to find level for synthetic index interleaving loop type &#x27;%s&#x27;\n&quot;,
184  		    tmp);
185  	  free(loops);
186  	  goto out_with_array;
187  	}
188  	tmp = strchr(tmp, &#x27;:&#x27;);
189  	if (!tmp || tmp &gt; attr+length)
190  	  break;
191  	tmp++;
192  	cur_loop++;
193        }
194        for(cur_loop=0; cur_loop&lt;nr_loops; cur_loop++) {
195  	unsigned mydepth = loops[cur_loop].level_depth;
196  	unsigned prevdepth = 0;
197  	unsigned step, nb;
198  	for(i=0; i&lt;nr_loops; i++) {
199  	  if (loops[i].level_depth == mydepth &amp;&amp; i != cur_loop) {
200  	    if (verbose)
201  	      fprintf(stderr, &quot;Invalid duplicate interleaving loop type in synthetic index &#x27;%s&#x27;\n&quot;, attr);
202  	    free(loops);
203  	    goto out_with_array;
204  	  }
205  	  if (loops[i].level_depth &lt; mydepth
206  	      &amp;&amp; loops[i].level_depth &gt; prevdepth)
207  	    prevdepth = loops[i].level_depth;
208  	}
209  	step = total / data-&gt;level[mydepth].totalwidth; &amp;bsol;* number of objects below us */
210  	nb = data-&gt;level[mydepth].totalwidth / data-&gt;level[prevdepth].totalwidth; &amp;bsol;* number of us within parent */
211  	loops[cur_loop].step = step;
212  	loops[cur_loop].nb = nb;
213  	assert(nb);
214  	assert(step);
215  	if (step &lt; minstep)
216  	  minstep = step;
217  	nbs *= nb;
218        }
219      }
220      assert(nbs);
221      if (nbs != total) {
222        if (minstep == total/nbs) {
223  	loops[nr_loops].step = 1;
224  	loops[nr_loops].nb = total/nbs;
225  	nr_loops++;
226        } else {
227  	if (verbose)
228  	  fprintf(stderr, &quot;Invalid index interleaving total width %lu instead of %lu\n&quot;, nbs, total);
229  	free(loops);
230  	goto out_with_array;
231        }
232      }
233      mul = 1;
234      for(i=0; i&lt;nr_loops; i++) {
235        unsigned step = loops[i].step;
236        unsigned nb = loops[i].nb;
237        for(j=0; j&lt;total; j++)
238  	array[j] += ((j / step) % nb) * mul;
239        mul *= nb;
240      }
241      free(loops);
242      for(j=0; j&lt;total; j++) {
243        if (array[j] &gt;= total) {
244  	if (verbose)
245  	  fprintf(stderr, &quot;Invalid index interleaving generates out-of-range index %u\n&quot;, array[j]);
246  	goto out_with_array;
247        }
248        if (!array[j] &amp;&amp; j) {
249  	if (verbose)
250  	  fprintf(stderr, &quot;Invalid index interleaving generates duplicate index values\n&quot;);
251  	goto out_with_array;
252        }
253      }
254      indexes-&gt;array = array;
255    }
256    return;
257   out_with_array:
258    free(array);
259   out:
260    return;
261  }
262  static hwloc_uint64_t
263  hwloc_synthetic_parse_memory_attr(const char *attr, const char **endp)
264  {
265    const char *endptr;
266    hwloc_uint64_t size;
267    size = strtoull(attr, (char **) &amp;endptr, 0);
268    if (!hwloc_strncasecmp(endptr, &quot;TB&quot;, 2)) {
269      size *= 1000ULL*1000ULL*1000ULL*1000ULL;
270      endptr += 2;
271    } else if (!hwloc_strncasecmp(endptr, &quot;TiB&quot;, 3)) {
272      size &lt;&lt;= 40;
273      endptr += 3;
274    } else if (!hwloc_strncasecmp(endptr, &quot;GB&quot;, 2)) {
275      size *= 1000ULL*1000ULL*1000ULL;
276      endptr += 2;
277    } else if (!hwloc_strncasecmp(endptr, &quot;GiB&quot;, 3)) {
278      size &lt;&lt;= 30;
279      endptr += 3;
280    } else if (!hwloc_strncasecmp(endptr, &quot;MB&quot;, 2)) {
281      size *= 1000ULL*1000ULL;
282      endptr += 2;
283    } else if (!hwloc_strncasecmp(endptr, &quot;MiB&quot;, 3)) {
284      size &lt;&lt;= 20;
285      endptr += 3;
286    } else if (!hwloc_strncasecmp(endptr, &quot;kB&quot;, 2)) {
287      size *= 1000ULL;
288      endptr += 2;
289    } else if (!hwloc_strncasecmp(endptr, &quot;kiB&quot;, 3)) {
290      size &lt;&lt;= 10;
291      endptr += 3;
292    }
293    *endp = endptr;
294    return size;
295  }
296  static int
297  hwloc_synthetic_parse_attrs(const char *attrs, const char **next_posp,
298  			    struct hwloc_synthetic_attr_s *sattr,
299  			    struct hwloc_synthetic_indexes_s *sind,
300  			    int verbose)
301  {
302    hwloc_obj_type_t type = sattr-&gt;type;
303    const char *next_pos;
304    hwloc_uint64_t memorysize = 0;
305    const char *index_string = NULL;
306    size_t index_string_length = 0;
307    next_pos = (const char *) strchr(attrs, &#x27;)&#x27;);
308    if (!next_pos) {
309      if (verbose)
310        fprintf(stderr, &quot;Missing attribute closing bracket in synthetic string doesn&#x27;t have a number of objects at &#x27;%s&#x27;\n&quot;, attrs);
311      errno = EINVAL;
312      return -1;
313    }
314    while (&#x27;)&#x27; != *attrs) {
315      int iscache = hwloc__obj_type_is_cache(type);
316      if (iscache &amp;&amp; !strncmp(&quot;size=&quot;, attrs, 5)) {
317        memorysize = hwloc_synthetic_parse_memory_attr(attrs+5, &amp;attrs);
318      } else if (!iscache &amp;&amp; !strncmp(&quot;memory=&quot;, attrs, 7)) {
319        memorysize = hwloc_synthetic_parse_memory_attr(attrs+7, &amp;attrs);
320      } else if (!strncmp(&quot;indexes=&quot;, attrs, 8)) {
321        index_string = attrs+8;
322        attrs += 8;
323        index_string_length = strcspn(attrs, &quot; )&quot;);
324        attrs += index_string_length;
325      } else {
326        if (verbose)
327  	fprintf(stderr, &quot;Unknown attribute at &#x27;%s&#x27;\n&quot;, attrs);
328        errno = EINVAL;
329        return -1;
330      }
331      if (&#x27; &#x27; == *attrs)
332        attrs++;
333      else if (&#x27;)&#x27; != *attrs) {
334        if (verbose)
335  	fprintf(stderr, &quot;Missing parameter separator at &#x27;%s&#x27;\n&quot;, attrs);
336        errno = EINVAL;
337        return -1;
338      }
339    }
340    sattr-&gt;memorysize = memorysize;
341    if (index_string) {
342      if (sind-&gt;string &amp;&amp; verbose)
343        fprintf(stderr, &quot;Overwriting duplicate indexes attribute with last occurence\n&quot;);
344      sind-&gt;string = index_string;
345      sind-&gt;string_length = (unsigned long)index_string_length;
346    }
347    *next_posp = next_pos+1;
348    return 0;
349  }
350  static void
351  hwloc_synthetic_free_levels(struct hwloc_synthetic_backend_data_s *data)
352  {
353    unsigned i;
354    for(i=0; i&lt;HWLOC_SYNTHETIC_MAX_DEPTH; i++) {
355      struct hwloc_synthetic_level_data_s *curlevel = &amp;data-&gt;level[i];
356      struct hwloc_synthetic_attached_s **pprev = &amp;curlevel-&gt;attached;
357      while (*pprev) {
358        struct hwloc_synthetic_attached_s *cur = *pprev;
359        *pprev = cur-&gt;next;
360        free(cur);
361      }
362      free(curlevel-&gt;indexes.array);
363      if (!curlevel-&gt;arity)
364        break;
365    }
366    free(data-&gt;numa_attached_indexes.array);
367  }
368  static int
369  hwloc_backend_synthetic_init(struct hwloc_synthetic_backend_data_s *data,
370  			     const char *description)
371  {
372    const char *pos, *next_pos;
373    unsigned long item, count;
374    unsigned i;
375    int type_count[HWLOC_OBJ_TYPE_MAX];
376    unsigned unset;
377    int verbose = 0;
378    const char *env = getenv(&quot;HWLOC_SYNTHETIC_VERBOSE&quot;);
379    int err;
380    unsigned long totalarity = 1;
381    if (env)
382      verbose = atoi(env);
383    data-&gt;numa_attached_nr = 0;
384    data-&gt;numa_attached_indexes.array = NULL;
385    data-&gt;level[0].totalwidth = 1;
386    data-&gt;level[0].attr.type = HWLOC_OBJ_MACHINE;
387    data-&gt;level[0].indexes.string = NULL;
388    data-&gt;level[0].indexes.array = NULL;
389    data-&gt;level[0].attr.memorysize = 0;
390    data-&gt;level[0].attached = NULL;
391    type_count[HWLOC_OBJ_MACHINE] = 1;
392    if (*description == &#x27;(&#x27;) {
393      err = hwloc_synthetic_parse_attrs(description+1, &amp;description, &amp;data-&gt;level[0].attr, &amp;data-&gt;level[0].indexes, verbose);
394      if (err &lt; 0)
395        return err;
396    }
397    data-&gt;numa_attached_indexes.string = NULL;
398    data-&gt;numa_attached_indexes.array = NULL;
399    for (pos = description, count = 1; *pos; pos = next_pos) {
400      hwloc_obj_type_t type = HWLOC_OBJ_TYPE_NONE;
401      union hwloc_obj_attr_u attrs;
402      data-&gt;level[count-1].arity = 0;
403      while (*pos == &#x27; &#x27; || *pos == &#x27;\n&#x27;)
404        pos++;
405      if (!*pos)
406        break;
407      if (*pos == &#x27;[&#x27;) {
408        struct hwloc_synthetic_attached_s *attached, **pprev;
409        char *attr;
410        pos++;
411        if (hwloc_type_sscanf(pos, &amp;type, &amp;attrs, sizeof(attrs)) &lt; 0) {
412  	if (verbose)
413  	  fprintf(stderr, &quot;Synthetic string with unknown attached object type at &#x27;%s&#x27;\n&quot;, pos);
414  	errno = EINVAL;
415  	goto error;
416        }
417        if (type != HWLOC_OBJ_NUMANODE) {
418  	if (verbose)
419  	  fprintf(stderr, &quot;Synthetic string with disallowed attached object type at &#x27;%s&#x27;\n&quot;, pos);
420  	errno = EINVAL;
421  	goto error;
422        }
423        data-&gt;numa_attached_nr += data-&gt;level[count-1].totalwidth;
424        attached = malloc(sizeof(*attached));
425        if (attached) {
426  	attached-&gt;attr.type = type;
427  	attached-&gt;attr.memorysize = 0;
428  	attached-&gt;next = NULL;
429  	pprev = &amp;data-&gt;level[count-1].attached;
430  	while (*pprev)
431  	  pprev = &amp;((*pprev)-&gt;next);
432  	*pprev = attached;
433        }
434        next_pos = strchr(pos, &#x27;]&#x27;);
435        if (!next_pos) {
436  	if (verbose)
437  	  fprintf(stderr,&quot;Synthetic string doesn&#x27;t have a closing `]&#x27; after attached object type at &#x27;%s&#x27;\n&quot;, pos);
438  	errno = EINVAL;
439  	goto error;
440        }
441        attr = strchr(pos, &#x27;(&#x27;);
442        if (attr &amp;&amp; attr &lt; next_pos &amp;&amp; attached) {
443  	const char *dummy;
444  	err = hwloc_synthetic_parse_attrs(attr+1, &amp;dummy, &amp;attached-&gt;attr, &amp;data-&gt;numa_attached_indexes, verbose);
445  	if (err &lt; 0)
446  	  goto error;
447        }
448        next_pos++;
449        continue;
450      }
451      data-&gt;level[count].indexes.string = NULL;
452      data-&gt;level[count].indexes.array = NULL;
453      data-&gt;level[count].attached = NULL;
454      if (*pos &lt; &#x27;0&#x27; || *pos &gt; &#x27;9&#x27;) {
455        if (hwloc_type_sscanf(pos, &amp;type, &amp;attrs, sizeof(attrs)) &lt; 0) {
456  	if (!strncmp(pos, &quot;Tile&quot;, 4) || !strncmp(pos, &quot;Module&quot;, 6)) {
457  	  type = HWLOC_OBJ_GROUP;
458  	} else {
459  	  if (verbose)
460  	    fprintf(stderr, &quot;Synthetic string with unknown object type at &#x27;%s&#x27;\n&quot;, pos);
461  	  errno = EINVAL;
462  	  goto error;
463  	}
464        }
465        if (type == HWLOC_OBJ_MACHINE || type == HWLOC_OBJ_MISC || type == HWLOC_OBJ_BRIDGE || type == HWLOC_OBJ_PCI_DEVICE || type == HWLOC_OBJ_OS_DEVICE) {
466  	if (verbose)
467  	  fprintf(stderr, &quot;Synthetic string with disallowed object type at &#x27;%s&#x27;\n&quot;, pos);
468  	errno = EINVAL;
469  	goto error;
470        }
471        next_pos = strchr(pos, &#x27;:&#x27;);
472        if (!next_pos) {
473  	if (verbose)
474  	  fprintf(stderr,&quot;Synthetic string doesn&#x27;t have a `:&#x27; after object type at &#x27;%s&#x27;\n&quot;, pos);
475  	errno = EINVAL;
476  	goto error;
477        }
478        pos = next_pos + 1;
479      }
480      data-&gt;level[count].attr.type = type;
481      data-&gt;level[count].attr.depth = (unsigned) -1;
482      data-&gt;level[count].attr.cachetype = (hwloc_obj_cache_type_t) -1;
483      if (hwloc__obj_type_is_cache(type)) {
484        data-&gt;level[count].attr.depth = attrs.cache.depth;
485        data-&gt;level[count].attr.cachetype = attrs.cache.type;
486      } else if (type == HWLOC_OBJ_GROUP) {
487        data-&gt;level[count].attr.depth = attrs.group.depth;
488      }
489      item = strtoul(pos, (char **)&amp;next_pos, 0);
490      if (next_pos == pos) {
491        if (verbose)
492  	fprintf(stderr,&quot;Synthetic string doesn&#x27;t have a number of objects at &#x27;%s&#x27;\n&quot;, pos);
493        errno = EINVAL;
494        goto error;
495      }
496      if (!item) {
497        if (verbose)
498  	fprintf(stderr,&quot;Synthetic string with disallow 0 number of objects at &#x27;%s&#x27;\n&quot;, pos);
499        errno = EINVAL;
500        goto error;
501      }
502      totalarity *= item;
503      data-&gt;level[count].totalwidth = totalarity;
504      data-&gt;level[count].indexes.string = NULL;
505      data-&gt;level[count].indexes.array = NULL;
506      data-&gt;level[count].attr.memorysize = 0;
507      if (*next_pos == &#x27;(&#x27;) {
508        err = hwloc_synthetic_parse_attrs(next_pos+1, &amp;next_pos, &amp;data-&gt;level[count].attr, &amp;data-&gt;level[count].indexes, verbose);
509        if (err &lt; 0)
510  	goto error;
511      }
512      if (count + 1 &gt;= HWLOC_SYNTHETIC_MAX_DEPTH) {
513        if (verbose)
514  	fprintf(stderr,&quot;Too many synthetic levels, max %d\n&quot;, HWLOC_SYNTHETIC_MAX_DEPTH);
515        errno = EINVAL;
516        goto error;
517      }
518      if (item &gt; UINT_MAX) {
519        if (verbose)
520  	fprintf(stderr,&quot;Too big arity, max %u\n&quot;, UINT_MAX);
521        errno = EINVAL;
522        goto error;
523      }
524      data-&gt;level[count-1].arity = (unsigned)item;
525      count++;
526    }
527    if (data-&gt;level[count-1].attr.type != HWLOC_OBJ_TYPE_NONE &amp;&amp; data-&gt;level[count-1].attr.type != HWLOC_OBJ_PU) {
528      if (verbose)
529        fprintf(stderr, &quot;Synthetic string cannot use non-PU type for last level\n&quot;);
530      errno = EINVAL;
531      return -1;
532    }
533    data-&gt;level[count-1].attr.type = HWLOC_OBJ_PU;
534    for(i=HWLOC_OBJ_TYPE_MIN; i&lt;HWLOC_OBJ_TYPE_MAX; i++) {
535      type_count[i] = 0;
536    }
537    for(i=count-1; i&gt;0; i--) {
538      hwloc_obj_type_t type = data-&gt;level[i].attr.type;
539      if (type != HWLOC_OBJ_TYPE_NONE) {
540        type_count[type]++;
541      }
542    }
543    if (!type_count[HWLOC_OBJ_PU]) {
544      if (verbose)
545        fprintf(stderr, &quot;Synthetic string missing ending number of PUs\n&quot;);
546      errno = EINVAL;
547      return -1;
548    } else if (type_count[HWLOC_OBJ_PU] &gt; 1) {
549      if (verbose)
550        fprintf(stderr, &quot;Synthetic string cannot have several PU levels\n&quot;);
551      errno = EINVAL;
552      return -1;
553    }
554    if (type_count[HWLOC_OBJ_PACKAGE] &gt; 1) {
555      if (verbose)
556        fprintf(stderr, &quot;Synthetic string cannot have several package levels\n&quot;);
557      errno = EINVAL;
558      return -1;
559    }
560    if (type_count[HWLOC_OBJ_DIE] &gt; 1) {
561      if (verbose)
562        fprintf(stderr, &quot;Synthetic string cannot have several die levels\n&quot;);
563      errno = EINVAL;
564      return -1;
565    }
566    if (type_count[HWLOC_OBJ_NUMANODE] &gt; 1) {
567      if (verbose)
568        fprintf(stderr, &quot;Synthetic string cannot have several NUMA node levels\n&quot;);
569      errno = EINVAL;
570      return -1;
571    }
572    if (type_count[HWLOC_OBJ_NUMANODE] &amp;&amp; data-&gt;numa_attached_nr) {
573      if (verbose)
574        fprintf(stderr,&quot;Synthetic string cannot have NUMA nodes both as a level and attached\n&quot;);
575      errno = EINVAL;
576      return -1;
577    }
578    if (type_count[HWLOC_OBJ_CORE] &gt; 1) {
579      if (verbose)
580        fprintf(stderr, &quot;Synthetic string cannot have several core levels\n&quot;);
581      errno = EINVAL;
582      return -1;
583    }
584    unset = 0;
585    for(i=1; i&lt;count-1; i++) {
586      if (data-&gt;level[i].attr.type == HWLOC_OBJ_TYPE_NONE)
587        unset++;
588    }
589    if (unset &amp;&amp; unset != count-2) {
590      if (verbose)
591        fprintf(stderr, &quot;Synthetic string cannot mix unspecified and specified types for levels\n&quot;);
592      errno = EINVAL;
593      return -1;
594    }
595    if (unset) {
596      unsigned _count = count;
597      unsigned neednuma = 0;
598      unsigned needpack = 0;
599      unsigned needcore = 0;
600      unsigned needcaches = 0;
601      unsigned needgroups = 0;
602      _count -= 2;
603      neednuma = (_count &gt;= 1 &amp;&amp; !data-&gt;numa_attached_nr);
604      _count -= neednuma;
605      needpack = (_count &gt;= 1);
606      _count -= needpack;
607      needcore = (_count &gt;= 1);
608      _count -= needcore;
609      needcaches = (_count &gt; 4 ? 4 : _count);
610      _count -= needcaches;
611      needgroups = _count;
612      for(i = 0; i &lt; needgroups; i++) {
613        unsigned depth = 1 + i;
614        data-&gt;level[depth].attr.type = HWLOC_OBJ_GROUP;
615        type_count[HWLOC_OBJ_GROUP]++;
616      }
617      if (needpack) {
618        unsigned depth = 1 + needgroups;
619        data-&gt;level[depth].attr.type = HWLOC_OBJ_PACKAGE;
620        type_count[HWLOC_OBJ_PACKAGE] = 1;
621      }
622      if (neednuma) {
623        unsigned depth = 1 + needgroups + needpack;
624        data-&gt;level[depth].attr.type = HWLOC_OBJ_NUMANODE;
625        type_count[HWLOC_OBJ_NUMANODE] = 1;
626      }
627      if (needcaches) {
628        unsigned l3depth = 1 + needgroups + needpack + neednuma;
629        unsigned l2depth = l3depth + (needcaches &gt;= 3);
630        unsigned l1depth = l2depth + 1;
631        unsigned l1idepth = l1depth + 1;
632        if (needcaches &gt;= 3) {
633  	data-&gt;level[l3depth].attr.type = HWLOC_OBJ_L3CACHE;
634  	data-&gt;level[l3depth].attr.depth = 3;
635  	data-&gt;level[l3depth].attr.cachetype = HWLOC_OBJ_CACHE_UNIFIED;
636  	type_count[HWLOC_OBJ_L3CACHE] = 1;
637        }
638        data-&gt;level[l2depth].attr.type = HWLOC_OBJ_L2CACHE;
639        data-&gt;level[l2depth].attr.depth = 2;
640        data-&gt;level[l2depth].attr.cachetype = HWLOC_OBJ_CACHE_UNIFIED;
641        type_count[HWLOC_OBJ_L2CACHE] = 1;
642        if (needcaches &gt;= 2) {
643  	data-&gt;level[l1depth].attr.type = HWLOC_OBJ_L1CACHE;
644  	data-&gt;level[l1depth].attr.depth = 1;
645  	data-&gt;level[l1depth].attr.cachetype = HWLOC_OBJ_CACHE_DATA;
646  	type_count[HWLOC_OBJ_L1CACHE] = 1;
647        }
648        if (needcaches &gt;= 4) {
649  	data-&gt;level[l1idepth].attr.type = HWLOC_OBJ_L1ICACHE;
650  	data-&gt;level[l1idepth].attr.depth = 1;
651  	data-&gt;level[l1idepth].attr.cachetype = HWLOC_OBJ_CACHE_INSTRUCTION;
652  	type_count[HWLOC_OBJ_L1ICACHE] = 1;
653        }
654      }
655      if (needcore) {
656        unsigned depth = 1 + needgroups + needpack + neednuma + needcaches;
657        data-&gt;level[depth].attr.type = HWLOC_OBJ_CORE;
658        type_count[HWLOC_OBJ_CORE] = 1;
659      }
660    }
661    if (!type_count[HWLOC_OBJ_NUMANODE] &amp;&amp; !data-&gt;numa_attached_nr) {
662      if (verbose)
663        fprintf(stderr, &quot;Inserting a NUMA level with a single object at depth 1\n&quot;);
664      memmove(&amp;data-&gt;level[2], &amp;data-&gt;level[1], count*sizeof(struct hwloc_synthetic_level_data_s));
665      data-&gt;level[1].attr.type = HWLOC_OBJ_NUMANODE;
666      data-&gt;level[1].indexes.string = NULL;
667      data-&gt;level[1].indexes.array = NULL;
668      data-&gt;level[1].attr.memorysize = 0;
669      data-&gt;level[1].totalwidth = data-&gt;level[0].totalwidth;
670      data-&gt;level[1].arity = data-&gt;level[0].arity;
671      data-&gt;level[0].arity = 1;
672      count++;
673    }
674    for (i=0; i&lt;count; i++) {
675      struct hwloc_synthetic_level_data_s *curlevel = &amp;data-&gt;level[i];
676      hwloc_obj_type_t type = curlevel-&gt;attr.type;
677      if (type == HWLOC_OBJ_GROUP) {
678        if (curlevel-&gt;attr.depth == (unsigned)-1)
679  	curlevel-&gt;attr.depth = type_count[HWLOC_OBJ_GROUP]--;
680      } else if (hwloc__obj_type_is_cache(type)) {
681        if (!curlevel-&gt;attr.memorysize) {
682  	if (1 == curlevel-&gt;attr.depth)
683  	  curlevel-&gt;attr.memorysize = 32*1024;
684  	else
685  	  curlevel-&gt;attr.memorysize = 256ULL*1024 &lt;&lt; (2*curlevel-&gt;attr.depth);
686        }
687      } else if (type == HWLOC_OBJ_NUMANODE &amp;&amp; !curlevel-&gt;attr.memorysize) {
688        curlevel-&gt;attr.memorysize = 1024*1024*1024;
689      }
690      hwloc_synthetic_process_indexes(data, &amp;data-&gt;level[i].indexes, data-&gt;level[i].totalwidth, verbose);
691    }
692    hwloc_synthetic_process_indexes(data, &amp;data-&gt;numa_attached_indexes, data-&gt;numa_attached_nr, verbose);
693    data-&gt;string = strdup(description);
694    data-&gt;level[count-1].arity = 0;
695    return 0;
696   error:
697    hwloc_synthetic_free_levels(data);
698    return -1;
699  }
700  static void
701  hwloc_synthetic_set_attr(struct hwloc_synthetic_attr_s *sattr,
702  			 hwloc_obj_t obj)
703  {
704    switch (obj-&gt;type) {
705    case HWLOC_OBJ_GROUP:
706      obj-&gt;attr-&gt;group.kind = HWLOC_GROUP_KIND_SYNTHETIC;
707      obj-&gt;attr-&gt;group.subkind = sattr-&gt;depth-1;
708      break;
709    case HWLOC_OBJ_MACHINE:
710      break;
711    case HWLOC_OBJ_NUMANODE:
712      obj-&gt;attr-&gt;numanode.local_memory = sattr-&gt;memorysize;
713      obj-&gt;attr-&gt;numanode.page_types_len = 1;
714      obj-&gt;attr-&gt;numanode.page_types = malloc(sizeof(*obj-&gt;attr-&gt;numanode.page_types));
715      memset(obj-&gt;attr-&gt;numanode.page_types, 0, sizeof(*obj-&gt;attr-&gt;numanode.page_types));
716      obj-&gt;attr-&gt;numanode.page_types[0].size = 4096;
717      obj-&gt;attr-&gt;numanode.page_types[0].count = sattr-&gt;memorysize / 4096;
718      break;
719    case HWLOC_OBJ_PACKAGE:
720    case HWLOC_OBJ_DIE:
721      break;
722    case HWLOC_OBJ_L1CACHE:
723    case HWLOC_OBJ_L2CACHE:
724    case HWLOC_OBJ_L3CACHE:
725    case HWLOC_OBJ_L4CACHE:
726    case HWLOC_OBJ_L5CACHE:
727    case HWLOC_OBJ_L1ICACHE:
728    case HWLOC_OBJ_L2ICACHE:
729    case HWLOC_OBJ_L3ICACHE:
730      obj-&gt;attr-&gt;cache.depth = sattr-&gt;depth;
731      obj-&gt;attr-&gt;cache.linesize = 64;
732      obj-&gt;attr-&gt;cache.type = sattr-&gt;cachetype;
733      obj-&gt;attr-&gt;cache.size = sattr-&gt;memorysize;
734      break;
735    case HWLOC_OBJ_CORE:
736      break;
737    case HWLOC_OBJ_PU:
738      break;
739    default:
740      assert(0);
741      break;
742    }
743  }
744  static unsigned
745  hwloc_synthetic_next_index(struct hwloc_synthetic_indexes_s *indexes, hwloc_obj_type_t type)
746  {
747    unsigned os_index = indexes-&gt;next++;
748    if (indexes-&gt;array)
749      os_index = indexes-&gt;array[os_index];
750    else if (hwloc__obj_type_is_cache(type) || type == HWLOC_OBJ_GROUP)
751      os_index = HWLOC_UNKNOWN_INDEX;
752    return os_index;
753  }
754  static void
755  hwloc_synthetic_insert_attached(struct hwloc_topology *topology,
756  				struct hwloc_synthetic_backend_data_s *data,
757  				struct hwloc_synthetic_attached_s *attached,
758  				hwloc_bitmap_t set)
759  {
760    hwloc_obj_t child;
761    unsigned attached_os_index;
762    if (!attached)
763      return;
764    assert(attached-&gt;attr.type == HWLOC_OBJ_NUMANODE);
765    attached_os_index = hwloc_synthetic_next_index(&amp;data-&gt;numa_attached_indexes, HWLOC_OBJ_NUMANODE);
766    child = hwloc_alloc_setup_object(topology, attached-&gt;attr.type, attached_os_index);
767    child-&gt;cpuset = hwloc_bitmap_dup(set);
768    child-&gt;nodeset = hwloc_bitmap_alloc();
769    hwloc_bitmap_set(child-&gt;nodeset, attached_os_index);
770    hwloc_synthetic_set_attr(&amp;attached-&gt;attr, child);
771    hwloc__insert_object_by_cpuset(topology, NULL, child, &quot;synthetic:attached&quot;);
772    hwloc_synthetic_insert_attached(topology, data, attached-&gt;next, set);
773  }
774  static void
775  hwloc__look_synthetic(struct hwloc_topology *topology,
776  		      struct hwloc_synthetic_backend_data_s *data,
777  		      int level,
778  		      hwloc_bitmap_t parent_cpuset)
779  {
780    hwloc_obj_t obj;
781    unsigned i;
782    struct hwloc_synthetic_level_data_s *curlevel = &amp;data-&gt;level[level];
783    hwloc_obj_type_t type = curlevel-&gt;attr.type;
784    hwloc_bitmap_t set;
785    unsigned os_index;
786    assert(hwloc__obj_type_is_normal(type) || type == HWLOC_OBJ_NUMANODE);
787    assert(type != HWLOC_OBJ_MACHINE);
788    os_index = hwloc_synthetic_next_index(&amp;curlevel-&gt;indexes, type);
789    set = hwloc_bitmap_alloc();
790    if (!curlevel-&gt;arity) {
791      hwloc_bitmap_set(set, os_index);
792    } else {
793      for (i = 0; i &lt; curlevel-&gt;arity; i++)
794        hwloc__look_synthetic(topology, data, level + 1, set);
795    }
796    hwloc_bitmap_or(parent_cpuset, parent_cpuset, set);
797    if (hwloc_filter_check_keep_object_type(topology, type)) {
798      obj = hwloc_alloc_setup_object(topology, type, os_index);
799      obj-&gt;cpuset = hwloc_bitmap_dup(set);
800      if (type == HWLOC_OBJ_NUMANODE) {
801        obj-&gt;nodeset = hwloc_bitmap_alloc();
802        hwloc_bitmap_set(obj-&gt;nodeset, os_index);
803      }
804      hwloc_synthetic_set_attr(&amp;curlevel-&gt;attr, obj);
805      hwloc__insert_object_by_cpuset(topology, NULL, obj, &quot;synthetic&quot;);
806    }
807    hwloc_synthetic_insert_attached(topology, data, curlevel-&gt;attached, set);
808    hwloc_bitmap_free(set);
809  }
810  static int
811  hwloc_look_synthetic(struct hwloc_backend *backend, struct hwloc_disc_status *dstatus)
812  {
813    struct hwloc_topology *topology = backend-&gt;topology;
814    struct hwloc_synthetic_backend_data_s *data = backend-&gt;private_data;
815    hwloc_bitmap_t cpuset = hwloc_bitmap_alloc();
816    unsigned i;
817    assert(dstatus-&gt;phase == HWLOC_DISC_PHASE_GLOBAL);
818    assert(!topology-&gt;levels[0][0]-&gt;cpuset);
819    hwloc_alloc_root_sets(topology-&gt;levels[0][0]);
820    topology-&gt;support.discovery-&gt;pu = 1;
821    topology-&gt;support.discovery-&gt;numa = 1; &amp;bsol;* we add a single NUMA node if none is given */
822    topology-&gt;support.discovery-&gt;numa_memory = 1; &amp;bsol;* specified or default size */
823    for (i = 0; data-&gt;level[i].arity &gt; 0; i++)
824      data-&gt;level[i].indexes.next = 0;
825    data-&gt;numa_attached_indexes.next = 0;
826    data-&gt;level[i].indexes.next = 0;
827    topology-&gt;levels[0][0]-&gt;type = data-&gt;level[0].attr.type;
828    hwloc_synthetic_set_attr(&amp;data-&gt;level[0].attr, topology-&gt;levels[0][0]);
829    for (i = 0; i &lt; data-&gt;level[0].arity; i++)
830      hwloc__look_synthetic(topology, data, 1, cpuset);
831    hwloc_synthetic_insert_attached(topology, data, data-&gt;level[0].attached, cpuset);
832    hwloc_bitmap_free(cpuset);
833    hwloc_obj_add_info(topology-&gt;levels[0][0], &quot;Backend&quot;, &quot;Synthetic&quot;);
834    hwloc_obj_add_info(topology-&gt;levels[0][0], &quot;SyntheticDescription&quot;, data-&gt;string);
835    return 0;
836  }
837  static void
838  hwloc_synthetic_backend_disable(struct hwloc_backend *backend)
839  {
840    struct hwloc_synthetic_backend_data_s *data = backend-&gt;private_data;
841    hwloc_synthetic_free_levels(data);
842    free(data-&gt;string);
843    free(data);
844  }
845  static struct hwloc_backend *
846  hwloc_synthetic_component_instantiate(struct hwloc_topology *topology,
847  				      struct hwloc_disc_component *component,
848  				      unsigned excluded_phases __hwloc_attribute_unused,
849  				      const void *_data1,
850  				      const void *_data2 __hwloc_attribute_unused,
851  				      const void *_data3 __hwloc_attribute_unused)
852  {
853    struct hwloc_backend *backend;
854    struct hwloc_synthetic_backend_data_s *data;
855    int err;
856    if (!_data1) {
857      const char *env = getenv(&quot;HWLOC_SYNTHETIC&quot;);
858      if (env) {
859        _data1 = env;
860      } else {
861        errno = EINVAL;
862        goto out;
863      }
864    }
865    backend = hwloc_backend_alloc(topology, component);
866    if (!backend)
867      goto out;
868    data = malloc(sizeof(*data));
869    if (!data) {
870      errno = ENOMEM;
871      goto out_with_backend;
872    }
873    err = hwloc_backend_synthetic_init(data, (const char *) _data1);
874    if (err &lt; 0)
875      goto out_with_data;
876    backend-&gt;private_data = data;
877    backend-&gt;discover = hwloc_look_synthetic;
878    backend-&gt;disable = hwloc_synthetic_backend_disable;
879    backend-&gt;is_thissystem = 0;
880    return backend;
881   out_with_data:
882    free(data);
883   out_with_backend:
884    free(backend);
885   out:
886    return NULL;
887  }
888  static struct hwloc_disc_component hwloc_synthetic_disc_component = {
889    &quot;synthetic&quot;,
890    HWLOC_DISC_PHASE_GLOBAL,
891    ~0,
892    hwloc_synthetic_component_instantiate,
893    30,
894    1,
895    NULL
896  };
897  const struct hwloc_component hwloc_synthetic_component = {
898    HWLOC_COMPONENT_ABI,
899    NULL, NULL,
900    HWLOC_COMPONENT_TYPE_DISC,
901    0,
902    &amp;hwloc_synthetic_disc_component
903  };
904  static __hwloc_inline int
905  hwloc__export_synthetic_update_status(int *ret, char **tmp, ssize_t *tmplen, int res)
906  {
907    if (res &lt; 0)
908      return -1;
909    *ret += res;
910    if (res &gt;= *tmplen)
911      res = *tmplen&gt;0 ? (int)(*tmplen) - 1 : 0;
912    *tmp += res;
913    *tmplen -= res;
914    return 0;
915  }
916  static __hwloc_inline void
917  hwloc__export_synthetic_add_char(int *ret, char **tmp, ssize_t *tmplen, char c)
918  {
919    if (*tmplen &gt; 1) {
920      (*tmp)[0] = c;
921      (*tmp)[1] = &#x27;\0&#x27;;
922      (*tmp)++;
923      (*tmplen)--;
924    }
925    (*ret)++;
926  }
927  static int
928  hwloc__export_synthetic_indexes(hwloc_obj_t *level, unsigned total,
929  				char *buffer, size_t buflen)
930  {
931    unsigned step = 1;
932    unsigned nr_loops = 0;
933    struct hwloc_synthetic_intlv_loop_s *loops = NULL, *tmploops;
934    hwloc_obj_t cur;
935    unsigned i, j;
936    ssize_t tmplen = buflen;
937    char *tmp = buffer;
938    int res, ret = 0;
939    if (level[0]-&gt;os_index)
940      goto exportall;
941    while (step != total) {
942      if (total % step)
943        goto exportall;
944      for(i=1; i&lt;total; i++)
945        if (level[i]-&gt;os_index == step)
946  	break;
947      if (i == total)
948        goto exportall;
949      for(j=2; j&lt;total/i; j++)
950        if (level[i*j]-&gt;os_index != step*j)
951  	break;
952      nr_loops++;
953      tmploops = realloc(loops, nr_loops*sizeof(*loops));
954      if (!tmploops)
955        goto exportall;
956      loops = tmploops;
957      loops[nr_loops-1].step = i;
958      loops[nr_loops-1].nb = j;
959      step *= j;
960    }
961    for(i=0; i&lt;total; i++) {
962      unsigned ind = 0;
963      unsigned mul = 1;
964      for(j=0; j&lt;nr_loops; j++) {
965        ind += (i / loops[j].step) % loops[j].nb * mul;
966        mul *= loops[j].nb;
967      }
968      if (level[i]-&gt;os_index != ind)
969        goto exportall;
970    }
971    for(j=0; j&lt;nr_loops; j++) {
972      res = hwloc_snprintf(tmp, tmplen, &quot;%u*%u%s&quot;, loops[j].step, loops[j].nb,
973  			 j == nr_loops-1 ? &quot;)&quot; : &quot;:&quot;);
974      if (hwloc__export_synthetic_update_status(&amp;ret, &amp;tmp, &amp;tmplen, res) &lt; 0) {
975        free(loops);
976        return -1;
977      }
978    }
979    free(loops);
980    return ret;
981   exportall:
982    free(loops);
983    cur = level[0];
984    while (cur) {
985      res = hwloc_snprintf(tmp, tmplen, &quot;%u%s&quot;, cur-&gt;os_index,
986  			 cur-&gt;next_cousin ? &quot;,&quot; : &quot;)&quot;);
987      if (hwloc__export_synthetic_update_status(&amp;ret, &amp;tmp, &amp;tmplen, res) &lt; 0)
988        return -1;
989      cur = cur-&gt;next_cousin;
990    }
991    return ret;
992  }
993  static int
994  hwloc__export_synthetic_obj_attr(struct hwloc_topology * topology,
995  				 hwloc_obj_t obj,
996  				 char *buffer, size_t buflen)
997  {
998    const char * separator = &quot; &quot;;
999    const char * prefix = &quot;(&quot;;
1000    char cachesize[64] = &quot;&quot;;
1001    char memsize[64] = &quot;&quot;;
1002    int needindexes = 0;
1003    if (hwloc__obj_type_is_cache(obj-&gt;type) &amp;&amp; obj-&gt;attr-&gt;cache.size) {
1004      snprintf(cachesize, sizeof(cachesize), &quot;%ssize=%llu&quot;,
1005  	     prefix, (unsigned long long) obj-&gt;attr-&gt;cache.size);
1006      prefix = separator;
1007    }
1008    if (obj-&gt;type == HWLOC_OBJ_NUMANODE &amp;&amp; obj-&gt;attr-&gt;numanode.local_memory) {
1009      snprintf(memsize, sizeof(memsize), &quot;%smemory=%llu&quot;,
1010  	     prefix, (unsigned long long) obj-&gt;attr-&gt;numanode.local_memory);
1011      prefix = separator;
1012    }
1013    if (!obj-&gt;logical_index &amp;bsol;* only display indexes once per level (not for non-first NUMA children, etc.) */
1014        &amp;&amp; (obj-&gt;type == HWLOC_OBJ_PU || obj-&gt;type == HWLOC_OBJ_NUMANODE)) {
1015      hwloc_obj_t cur = obj;
1016      while (cur) {
1017        if (cur-&gt;os_index != cur-&gt;logical_index) {
1018  	needindexes = 1;
1019  	break;
1020        }
1021        cur = cur-&gt;next_cousin;
1022      }
1023    }
1024    if (*cachesize || *memsize || needindexes) {
1025      ssize_t tmplen = buflen;
1026      char *tmp = buffer;
1027      int res, ret = 0;
1028      res = hwloc_snprintf(tmp, tmplen, &quot;%s%s%s&quot;, cachesize, memsize, needindexes ? &quot;&quot; : &quot;)&quot;);
1029      if (hwloc__export_synthetic_update_status(&amp;ret, &amp;tmp, &amp;tmplen, res) &lt; 0)
1030        return -1;
1031      if (needindexes) {
1032        unsigned total;
1033        hwloc_obj_t *level;
1034        if (obj-&gt;depth &lt; 0) {
1035  	assert(obj-&gt;depth == HWLOC_TYPE_DEPTH_NUMANODE);
1036  	total = topology-&gt;slevels[HWLOC_SLEVEL_NUMANODE].nbobjs;
1037  	level = topology-&gt;slevels[HWLOC_SLEVEL_NUMANODE].objs;
1038        } else {
1039  	total = topology-&gt;level_nbobjects[obj-&gt;depth];
1040  	level = topology-&gt;levels[obj-&gt;depth];
1041        }
1042        res = hwloc_snprintf(tmp, tmplen, &quot;%sindexes=&quot;, prefix);
1043        if (hwloc__export_synthetic_update_status(&amp;ret, &amp;tmp, &amp;tmplen, res) &lt; 0)
1044  	return -1;
1045        res = hwloc__export_synthetic_indexes(level, total, tmp, tmplen);
1046        if (hwloc__export_synthetic_update_status(&amp;ret, &amp;tmp, &amp;tmplen, res) &lt; 0)
1047  	return -1;
1048      }
1049      return ret;
1050    } else {
1051      return 0;
1052    }
1053  }
1054  static int
1055  hwloc__export_synthetic_obj(struct hwloc_topology * topology, unsigned long flags,
1056  			    hwloc_obj_t obj, unsigned arity,
1057  			    char *buffer, size_t buflen)
1058  {
1059    char aritys[12] = &quot;&quot;;
1060    ssize_t tmplen = buflen;
1061    char *tmp = buffer;
1062    int res, ret = 0;
1063    if (arity != (unsigned)-1)
1064      snprintf(aritys, sizeof(aritys), &quot;:%u&quot;, arity);
1065    if (hwloc__obj_type_is_cache(obj-&gt;type)
1066        &amp;&amp; (flags &amp; HWLOC_TOPOLOGY_EXPORT_SYNTHETIC_FLAG_NO_EXTENDED_TYPES)) {
1067      res = hwloc_snprintf(tmp, tmplen, &quot;Cache%s&quot;, aritys);
1068    } else if (obj-&gt;type == HWLOC_OBJ_PACKAGE
1069  	     &amp;&amp; (flags &amp; (HWLOC_TOPOLOGY_EXPORT_SYNTHETIC_FLAG_NO_EXTENDED_TYPES
1070  			  |HWLOC_TOPOLOGY_EXPORT_SYNTHETIC_FLAG_V1))) {
1071      res = hwloc_snprintf(tmp, tmplen, &quot;Socket%s&quot;, aritys);
1072    } else if (obj-&gt;type == HWLOC_OBJ_DIE
1073  	     &amp;&amp; (flags &amp; (HWLOC_TOPOLOGY_EXPORT_SYNTHETIC_FLAG_NO_EXTENDED_TYPES
1074  			  |HWLOC_TOPOLOGY_EXPORT_SYNTHETIC_FLAG_V1))) {
1075      res = hwloc_snprintf(tmp, tmplen, &quot;Group%s&quot;, aritys);
1076    } else if (obj-&gt;type == HWLOC_OBJ_GROUP &amp;bsol;* don&#x27;t export group depth */
1077        || flags &amp; HWLOC_TOPOLOGY_EXPORT_SYNTHETIC_FLAG_NO_EXTENDED_TYPES) {
1078      res = hwloc_snprintf(tmp, tmplen, &quot;%s%s&quot;, hwloc_obj_type_string(obj-&gt;type), aritys);
1079    } else {
1080      char types[64];
1081      hwloc_obj_type_snprintf(types, sizeof(types), obj, 1);
1082      res = hwloc_snprintf(tmp, tmplen, &quot;%s%s&quot;, types, aritys);
1083    }
1084    if (hwloc__export_synthetic_update_status(&amp;ret, &amp;tmp, &amp;tmplen, res) &lt; 0)
1085      return -1;
1086    if (!(flags &amp; HWLOC_TOPOLOGY_EXPORT_SYNTHETIC_FLAG_NO_ATTRS)) {
1087      res = hwloc__export_synthetic_obj_attr(topology, obj, tmp, tmplen);
1088      if (hwloc__export_synthetic_update_status(&amp;ret, &amp;tmp, &amp;tmplen, res) &lt; 0)
1089        return -1;
1090    }
1091    return ret;
1092  }
1093  static int
1094  hwloc__export_synthetic_memory_children(struct hwloc_topology * topology, unsigned long flags,
1095  					hwloc_obj_t parent,
1096  					char *buffer, size_t buflen,
1097  					int needprefix, int verbose)
1098  {
1099    hwloc_obj_t mchild;
1100    ssize_t tmplen = buflen;
1101    char *tmp = buffer;
1102    int res, ret = 0;
1103    mchild = parent-&gt;memory_first_child;
1104    if (!mchild)
1105      return 0;
1106    if (flags &amp; HWLOC_TOPOLOGY_EXPORT_SYNTHETIC_FLAG_V1) {
1107      if (parent-&gt;memory_arity &gt; 1 || mchild-&gt;type != HWLOC_OBJ_NUMANODE) {
1108        if (verbose)
1109  	fprintf(stderr, &quot;Cannot export to synthetic v1 if multiple memory children are attached to the same location.\n&quot;);
1110        errno = EINVAL;
1111        return -1;
1112      }
1113      if (needprefix)
1114        hwloc__export_synthetic_add_char(&amp;ret, &amp;tmp, &amp;tmplen, &#x27; &#x27;);
1115      res = hwloc__export_synthetic_obj(topology, flags, mchild, 1, tmp, tmplen);
1116      if (hwloc__export_synthetic_update_status(&amp;ret, &amp;tmp, &amp;tmplen, res) &lt; 0)
1117        return -1;
1118      return ret;
1119    }
1120    while (mchild) {
1121      hwloc_obj_t numanode = mchild;
1122      while (numanode &amp;&amp; numanode-&gt;type != HWLOC_OBJ_NUMANODE) {
1123        assert(numanode-&gt;arity == 1);
1124        numanode = numanode-&gt;memory_first_child;
1125      }
1126      assert(numanode); &amp;bsol;* there&#x27;s always a numanode at the bottom of the memory tree */
<span onclick='openModal()' class='match'>1127      if (needprefix)
1128        hwloc__export_synthetic_add_char(&amp;ret, &amp;tmp, &amp;tmplen, &#x27; &#x27;);
1129      hwloc__export_synthetic_add_char(&amp;ret, &amp;tmp, &amp;tmplen, &#x27;[&#x27;);
</span>1130      res = hwloc__export_synthetic_obj(topology, flags, numanode, (unsigned)-1, tmp, tmplen);
1131      if (hwloc__export_synthetic_update_status(&amp;ret, &amp;tmp, &amp;tmplen, res) &lt; 0)
1132        return -1;
1133      hwloc__export_synthetic_add_char(&amp;ret, &amp;tmp, &amp;tmplen, &#x27;]&#x27;);
1134      needprefix = 1;
1135      mchild = mchild-&gt;next_sibling;
1136    }
1137    return ret;
1138  }
1139  static int
1140  hwloc_check_memory_symmetric(struct hwloc_topology * topology)
1141  {
1142    hwloc_bitmap_t remaining_nodes;
1143    remaining_nodes = hwloc_bitmap_dup(hwloc_get_root_obj(topology)-&gt;nodeset);
1144    if (!remaining_nodes)
1145      return -1;
1146    while (!hwloc_bitmap_iszero(remaining_nodes)) {
1147      unsigned idx;
1148      hwloc_obj_t node;
1149      hwloc_obj_t first_parent;
1150      unsigned i;
1151      idx = hwloc_bitmap_first(remaining_nodes);
1152      node = hwloc_get_numanode_obj_by_os_index(topology, idx);
1153      assert(node);
1154      first_parent = node-&gt;parent;
1155      for(i=0; i&lt;hwloc_get_nbobjs_by_depth(topology, first_parent-&gt;depth); i++) {
1156        hwloc_obj_t parent, mchild;
1157        parent = hwloc_get_obj_by_depth(topology, first_parent-&gt;depth, i);
1158        assert(parent);
1159        if (parent-&gt;memory_arity != first_parent-&gt;memory_arity)
1160  	goto out_with_bitmap;
1161        mchild = parent-&gt;memory_first_child;
1162        while (mchild) {
1163  	hwloc_bitmap_clr(remaining_nodes, mchild-&gt;os_index); &amp;bsol;* cannot use parent-&gt;nodeset, some normal children may have other NUMA nodes */
1164  	mchild = mchild-&gt;next_sibling;
1165        }
1166      }
1167    }
1168    hwloc_bitmap_free(remaining_nodes);
1169    return 0;
1170   out_with_bitmap:
1171    hwloc_bitmap_free(remaining_nodes);
1172    return -1;
1173  }
1174  int
1175  hwloc_topology_export_synthetic(struct hwloc_topology * topology,
1176  				char *buffer, size_t buflen,
1177  				unsigned long flags)
1178  {
1179    hwloc_obj_t obj = hwloc_get_root_obj(topology);
1180    ssize_t tmplen = buflen;
1181    char *tmp = buffer;
1182    int res, ret = 0;
1183    unsigned arity;
1184    int needprefix = 0;
1185    int verbose = 0;
1186    const char *env = getenv(&quot;HWLOC_SYNTHETIC_VERBOSE&quot;);
1187    if (env)
1188      verbose = atoi(env);
1189    if (!topology-&gt;is_loaded) {
1190      errno = EINVAL;
1191      return -1;
1192    }
1193    if (flags &amp; ~(HWLOC_TOPOLOGY_EXPORT_SYNTHETIC_FLAG_NO_EXTENDED_TYPES
1194  		|HWLOC_TOPOLOGY_EXPORT_SYNTHETIC_FLAG_NO_ATTRS
1195  		|HWLOC_TOPOLOGY_EXPORT_SYNTHETIC_FLAG_V1
1196  		|HWLOC_TOPOLOGY_EXPORT_SYNTHETIC_FLAG_IGNORE_MEMORY)) {
1197      errno = EINVAL;
1198      return -1;
1199    }
1200    if (!obj-&gt;symmetric_subtree) {
1201      if (verbose)
1202        fprintf(stderr, &quot;Cannot export to synthetic unless topology is symmetric (root-&gt;symmetric_subtree must be set).\n&quot;);
1203      errno = EINVAL;
1204      return -1;
1205    }
1206    if (!(flags &amp; HWLOC_TOPOLOGY_EXPORT_SYNTHETIC_FLAG_IGNORE_MEMORY)
1207        &amp;&amp; hwloc_check_memory_symmetric(topology) &lt; 0) {
1208      if (verbose)
1209        fprintf(stderr, &quot;Cannot export to synthetic unless memory is attached symmetrically.\n&quot;);
1210      errno = EINVAL;
1211      return -1;
1212    }
1213    if (flags &amp; HWLOC_TOPOLOGY_EXPORT_SYNTHETIC_FLAG_V1) {
1214      hwloc_obj_t node;
1215      signed pdepth;
1216      node = hwloc_get_obj_by_type(topology, HWLOC_OBJ_NUMANODE, 0);
1217      assert(node);
1218      assert(hwloc__obj_type_is_normal(node-&gt;parent-&gt;type)); &amp;bsol;* only depth-1 memory children for now */
1219      pdepth = node-&gt;parent-&gt;depth;
1220      while ((node = node-&gt;next_cousin) != NULL) {
1221        assert(hwloc__obj_type_is_normal(node-&gt;parent-&gt;type)); &amp;bsol;* only depth-1 memory children for now */
1222        if (node-&gt;parent-&gt;depth != pdepth) {
1223  	if (verbose)
1224  	  fprintf(stderr, &quot;Cannot export to synthetic v1 if memory is attached to parents at different depths.\n&quot;);
1225  	errno = EINVAL;
1226  	return -1;
1227        }
1228      }
1229    }
1230    if (!(flags &amp; HWLOC_TOPOLOGY_EXPORT_SYNTHETIC_FLAG_NO_ATTRS)) {
1231      res = hwloc__export_synthetic_obj_attr(topology, obj, tmp, tmplen);
1232      if (res &gt; 0)
1233        needprefix = 1;
1234      if (hwloc__export_synthetic_update_status(&amp;ret, &amp;tmp, &amp;tmplen, res) &lt; 0)
1235        return -1;
1236    }
1237    if (!(flags &amp; HWLOC_TOPOLOGY_EXPORT_SYNTHETIC_FLAG_IGNORE_MEMORY)) {
1238      res = hwloc__export_synthetic_memory_children(topology, flags, obj, tmp, tmplen, needprefix, verbose);
1239      if (res &gt; 0)
1240        needprefix = 1;
1241      if (hwloc__export_synthetic_update_status(&amp;ret, &amp;tmp, &amp;tmplen, res) &lt; 0)
1242        return -1;
1243    }
1244    arity = obj-&gt;arity;
1245    while (arity) {
1246      obj = obj-&gt;first_child;
1247      if (needprefix)
1248        hwloc__export_synthetic_add_char(&amp;ret, &amp;tmp, &amp;tmplen, &#x27; &#x27;);
1249      res = hwloc__export_synthetic_obj(topology, flags, obj, arity, tmp, tmplen);
1250      if (hwloc__export_synthetic_update_status(&amp;ret, &amp;tmp, &amp;tmplen, res) &lt; 0)
1251        return -1;
1252      if (!(flags &amp; HWLOC_TOPOLOGY_EXPORT_SYNTHETIC_FLAG_IGNORE_MEMORY)) {
1253        res = hwloc__export_synthetic_memory_children(topology, flags, obj, tmp, tmplen, 1, verbose);
1254        if (hwloc__export_synthetic_update_status(&amp;ret, &amp;tmp, &amp;tmplen, res) &lt; 0)
1255  	return -1;
1256      }
1257      needprefix = 1;
1258      arity = obj-&gt;arity;
1259    }
1260    return ret;
1261  }
</code></pre>
        </div>
        <div class="column">
            <h3>xmrig-MDEwOlJlcG9zaXRvcnk4ODMyNzQwNg==-flat-topology-synthetic.c</h3>
            <pre><code>1  #include &quot;private/autogen/config.h&quot;
2  #include &quot;hwloc.h&quot;
3  #include &quot;private/private.h&quot;
4  #include &quot;private/misc.h&quot;
5  #include &quot;private/debug.h&quot;
6  #include &lt;limits.h&gt;
7  #include &lt;assert.h&gt;
8  #ifdef HAVE_STRINGS_H
9  #include &lt;strings.h&gt;
10  #endif
11  struct hwloc_synthetic_attr_s {
12    hwloc_obj_type_t type;
13    unsigned depth; &amp;bsol;* For caches/groups */
14    hwloc_obj_cache_type_t cachetype; &amp;bsol;* For caches */
15    hwloc_uint64_t memorysize; &amp;bsol;* For caches/memory */
16  };
17  struct hwloc_synthetic_indexes_s {
18    const char *string;
19    unsigned long string_length;
20    unsigned *array;
21    unsigned next; &amp;bsol;* id of the next object for that level */
22  };
23  struct hwloc_synthetic_level_data_s {
24    unsigned arity;
25    unsigned long totalwidth;
26    struct hwloc_synthetic_attr_s attr;
27    struct hwloc_synthetic_indexes_s indexes;
28    struct hwloc_synthetic_attached_s {
29      struct hwloc_synthetic_attr_s attr;
30      struct hwloc_synthetic_attached_s *next;
31    } *attached;
32  };
33  struct hwloc_synthetic_backend_data_s {
34    char *string;
35    unsigned long numa_attached_nr;
36    struct hwloc_synthetic_indexes_s numa_attached_indexes;
37  #define HWLOC_SYNTHETIC_MAX_DEPTH 128
38    struct hwloc_synthetic_level_data_s level[HWLOC_SYNTHETIC_MAX_DEPTH];
39  };
40  struct hwloc_synthetic_intlv_loop_s {
41    unsigned step;
42    unsigned nb;
43    unsigned level_depth;
44  };
45  static void
46  hwloc_synthetic_process_indexes(struct hwloc_synthetic_backend_data_s *data,
47  				struct hwloc_synthetic_indexes_s *indexes,
48  				unsigned long total,
49  				int verbose)
50  {
51    const char *attr = indexes-&gt;string;
52    unsigned long length = indexes-&gt;string_length;
53    unsigned *array = NULL;
54    size_t i;
55    if (!attr)
56      return;
57    array = calloc(total, sizeof(*array));
58    if (!array) {
59      if (verbose)
60        fprintf(stderr, &quot;Failed to allocate synthetic index array of size %lu\n&quot;, total);
61      goto out;
62    }
63    i = strspn(attr, &quot;0123456789,&quot;);
64    if (i == length) {
65      for(i=0; i&lt;total; i++) {
66        const char *next;
67        unsigned idx = strtoul(attr, (char **) &amp;next, 10);
68        if (next == attr) {
69  	if (verbose)
70  	  fprintf(stderr, &quot;Failed to read synthetic index #%lu at &#x27;%s&#x27;\n&quot;, (unsigned long) i, attr);
71  	goto out_with_array;
72        }
73        array[i] = idx;
74        if (i != total-1) {
75  	if (*next != &#x27;,&#x27;) {
76  	  if (verbose)
77  	    fprintf(stderr, &quot;Missing comma after synthetic index #%lu at &#x27;%s&#x27;\n&quot;, (unsigned long) i, attr);
78  	  goto out_with_array;
79  	}
80  	attr = next+1;
81        } else {
82  	attr = next;
83        }
84      }
85      indexes-&gt;array = array;
86    } else {
87      unsigned nr_loops = 1, cur_loop;
88      unsigned minstep = total;
89      unsigned long nbs = 1;
90      unsigned j, mul;
91      const char *tmp;
92      struct hwloc_synthetic_intlv_loop_s *loops;
93      tmp = attr;
94      while (tmp) {
95        tmp = strchr(tmp, &#x27;:&#x27;);
96        if (!tmp || tmp &gt;= attr+length)
97  	break;
98        nr_loops++;
99        tmp++;
100      }
101      loops = malloc((nr_loops+1) * sizeof(*loops));
102      if (!loops)
103        goto out_with_array;
104      if (*attr &gt;= &#x27;0&#x27; &amp;&amp; *attr &lt;= &#x27;9&#x27;) {
105        unsigned step, nb;
106        tmp = attr;
107        cur_loop = 0;
108        while (tmp) {
109  	char *tmp2, *tmp3;
110  	step = (unsigned) strtol(tmp, &amp;tmp2, 0);
111  	if (tmp2 == tmp || *tmp2 != &#x27;*&#x27;) {
112  	  if (verbose)
113  	    fprintf(stderr, &quot;Failed to read synthetic index interleaving loop &#x27;%s&#x27; without number before &#x27;*&#x27;\n&quot;, tmp);
114  	  free(loops);
115  	  goto out_with_array;
116  	}
117  	if (!step) {
118  	  if (verbose)
119  	    fprintf(stderr, &quot;Invalid interleaving loop with step 0 at &#x27;%s&#x27;\n&quot;, tmp);
120  	  free(loops);
121  	  goto out_with_array;
122  	}
123  	tmp2++;
124  	nb = (unsigned) strtol(tmp2, &amp;tmp3, 0);
125  	if (tmp3 == tmp2 || (*tmp3 &amp;&amp; *tmp3 != &#x27;:&#x27; &amp;&amp; *tmp3 != &#x27;)&#x27; &amp;&amp; *tmp3 != &#x27; &#x27;)) {
126  	  if (verbose)
127  	    fprintf(stderr, &quot;Failed to read synthetic index interleaving loop &#x27;%s&#x27; without number between &#x27;*&#x27; and &#x27;:&#x27;\n&quot;, tmp);
128  	  free(loops);
129  	  goto out_with_array;
130  	}
131  	if (!nb) {
132  	  if (verbose)
133  	    fprintf(stderr, &quot;Invalid interleaving loop with number 0 at &#x27;%s&#x27;\n&quot;, tmp2);
134  	  free(loops);
135  	  goto out_with_array;
136  	}
137  	loops[cur_loop].step = step;
138  	loops[cur_loop].nb = nb;
139  	if (step &lt; minstep)
140  	  minstep = step;
141  	nbs *= nb;
142  	cur_loop++;
143  	if (*tmp3 == &#x27;)&#x27; || *tmp3 == &#x27; &#x27;)
144  	  break;
145  	tmp = (const char*) (tmp3+1);
146        }
147      } else {
148        hwloc_obj_type_t type;
149        union hwloc_obj_attr_u attrs;
150        int err;
151        tmp = attr;
152        cur_loop = 0;
153        while (tmp) {
154  	err = hwloc_type_sscanf(tmp, &amp;type, &amp;attrs, sizeof(attrs));
155  	if (err &lt; 0) {
156  	  if (verbose)
157  	    fprintf(stderr, &quot;Failed to read synthetic index interleaving loop type &#x27;%s&#x27;\n&quot;, tmp);
158  	  free(loops);
159  	  goto out_with_array;
160  	}
161  	if (type == HWLOC_OBJ_MISC || type == HWLOC_OBJ_BRIDGE || type == HWLOC_OBJ_PCI_DEVICE || type == HWLOC_OBJ_OS_DEVICE) {
162  	  if (verbose)
163  	    fprintf(stderr, &quot;Misc object type disallowed in synthetic index interleaving loop type &#x27;%s&#x27;\n&quot;, tmp);
164  	  free(loops);
165  	  goto out_with_array;
166  	}
167  	for(i=0; ; i++) {
168  	  if (!data-&gt;level[i].arity) {
169  	    loops[cur_loop].level_depth = (unsigned)-1;
170  	    break;
171  	  }
172  	  if (type != data-&gt;level[i].attr.type)
173  	    continue;
174  	  if (type == HWLOC_OBJ_GROUP
175  	      &amp;&amp; attrs.group.depth != (unsigned) -1
176  	      &amp;&amp; attrs.group.depth != data-&gt;level[i].attr.depth)
177  	    continue;
178  	  loops[cur_loop].level_depth = (unsigned)i;
179  	  break;
180  	}
181  	if (loops[cur_loop].level_depth == (unsigned)-1) {
182  	  if (verbose)
183  	    fprintf(stderr, &quot;Failed to find level for synthetic index interleaving loop type &#x27;%s&#x27;\n&quot;,
184  		    tmp);
185  	  free(loops);
186  	  goto out_with_array;
187  	}
188  	tmp = strchr(tmp, &#x27;:&#x27;);
189  	if (!tmp || tmp &gt; attr+length)
190  	  break;
191  	tmp++;
192  	cur_loop++;
193        }
194        for(cur_loop=0; cur_loop&lt;nr_loops; cur_loop++) {
195  	unsigned mydepth = loops[cur_loop].level_depth;
196  	unsigned prevdepth = 0;
197  	unsigned step, nb;
198  	for(i=0; i&lt;nr_loops; i++) {
199  	  if (loops[i].level_depth == mydepth &amp;&amp; i != cur_loop) {
200  	    if (verbose)
201  	      fprintf(stderr, &quot;Invalid duplicate interleaving loop type in synthetic index &#x27;%s&#x27;\n&quot;, attr);
202  	    free(loops);
203  	    goto out_with_array;
204  	  }
205  	  if (loops[i].level_depth &lt; mydepth
206  	      &amp;&amp; loops[i].level_depth &gt; prevdepth)
207  	    prevdepth = loops[i].level_depth;
208  	}
209  	step = total / data-&gt;level[mydepth].totalwidth; &amp;bsol;* number of objects below us */
210  	nb = data-&gt;level[mydepth].totalwidth / data-&gt;level[prevdepth].totalwidth; &amp;bsol;* number of us within parent */
211  	loops[cur_loop].step = step;
212  	loops[cur_loop].nb = nb;
213  	assert(nb);
214  	assert(step);
215  	if (step &lt; minstep)
216  	  minstep = step;
217  	nbs *= nb;
218        }
219      }
220      assert(nbs);
221      if (nbs != total) {
222        if (minstep == total/nbs) {
223  	loops[nr_loops].step = 1;
224  	loops[nr_loops].nb = total/nbs;
225  	nr_loops++;
226        } else {
227  	if (verbose)
228  	  fprintf(stderr, &quot;Invalid index interleaving total width %lu instead of %lu\n&quot;, nbs, total);
229  	free(loops);
230  	goto out_with_array;
231        }
232      }
233      mul = 1;
234      for(i=0; i&lt;nr_loops; i++) {
235        unsigned step = loops[i].step;
236        unsigned nb = loops[i].nb;
237        for(j=0; j&lt;total; j++)
238  	array[j] += ((j / step) % nb) * mul;
239        mul *= nb;
240      }
241      free(loops);
242      for(j=0; j&lt;total; j++) {
243        if (array[j] &gt;= total) {
244  	if (verbose)
245  	  fprintf(stderr, &quot;Invalid index interleaving generates out-of-range index %u\n&quot;, array[j]);
246  	goto out_with_array;
247        }
248        if (!array[j] &amp;&amp; j) {
249  	if (verbose)
250  	  fprintf(stderr, &quot;Invalid index interleaving generates duplicate index values\n&quot;);
251  	goto out_with_array;
252        }
253      }
254      indexes-&gt;array = array;
255    }
256    return;
257   out_with_array:
258    free(array);
259   out:
260    return;
261  }
262  static hwloc_uint64_t
263  hwloc_synthetic_parse_memory_attr(const char *attr, const char **endp)
264  {
265    const char *endptr;
266    hwloc_uint64_t size;
267    size = strtoull(attr, (char **) &amp;endptr, 0);
268    if (!hwloc_strncasecmp(endptr, &quot;TB&quot;, 2)) {
269      size *= 1000ULL*1000ULL*1000ULL*1000ULL;
270      endptr += 2;
271    } else if (!hwloc_strncasecmp(endptr, &quot;TiB&quot;, 3)) {
272      size &lt;&lt;= 40;
273      endptr += 3;
274    } else if (!hwloc_strncasecmp(endptr, &quot;GB&quot;, 2)) {
275      size *= 1000ULL*1000ULL*1000ULL;
276      endptr += 2;
277    } else if (!hwloc_strncasecmp(endptr, &quot;GiB&quot;, 3)) {
278      size &lt;&lt;= 30;
279      endptr += 3;
280    } else if (!hwloc_strncasecmp(endptr, &quot;MB&quot;, 2)) {
281      size *= 1000ULL*1000ULL;
282      endptr += 2;
283    } else if (!hwloc_strncasecmp(endptr, &quot;MiB&quot;, 3)) {
284      size &lt;&lt;= 20;
285      endptr += 3;
286    } else if (!hwloc_strncasecmp(endptr, &quot;kB&quot;, 2)) {
287      size *= 1000ULL;
288      endptr += 2;
289    } else if (!hwloc_strncasecmp(endptr, &quot;kiB&quot;, 3)) {
290      size &lt;&lt;= 10;
291      endptr += 3;
292    }
293    *endp = endptr;
294    return size;
295  }
296  static int
297  hwloc_synthetic_parse_attrs(const char *attrs, const char **next_posp,
298  			    struct hwloc_synthetic_attr_s *sattr,
299  			    struct hwloc_synthetic_indexes_s *sind,
300  			    int verbose)
301  {
302    hwloc_obj_type_t type = sattr-&gt;type;
303    const char *next_pos;
304    hwloc_uint64_t memorysize = 0;
305    const char *index_string = NULL;
306    size_t index_string_length = 0;
307    next_pos = (const char *) strchr(attrs, &#x27;)&#x27;);
308    if (!next_pos) {
309      if (verbose)
310        fprintf(stderr, &quot;Missing attribute closing bracket in synthetic string doesn&#x27;t have a number of objects at &#x27;%s&#x27;\n&quot;, attrs);
311      errno = EINVAL;
312      return -1;
313    }
314    while (&#x27;)&#x27; != *attrs) {
315      int iscache = hwloc__obj_type_is_cache(type);
316      if (iscache &amp;&amp; !strncmp(&quot;size=&quot;, attrs, 5)) {
317        memorysize = hwloc_synthetic_parse_memory_attr(attrs+5, &amp;attrs);
318      } else if (!iscache &amp;&amp; !strncmp(&quot;memory=&quot;, attrs, 7)) {
319        memorysize = hwloc_synthetic_parse_memory_attr(attrs+7, &amp;attrs);
320      } else if (!strncmp(&quot;indexes=&quot;, attrs, 8)) {
321        index_string = attrs+8;
322        attrs += 8;
323        index_string_length = strcspn(attrs, &quot; )&quot;);
324        attrs += index_string_length;
325      } else {
326        if (verbose)
327  	fprintf(stderr, &quot;Unknown attribute at &#x27;%s&#x27;\n&quot;, attrs);
328        errno = EINVAL;
329        return -1;
330      }
331      if (&#x27; &#x27; == *attrs)
332        attrs++;
333      else if (&#x27;)&#x27; != *attrs) {
334        if (verbose)
335  	fprintf(stderr, &quot;Missing parameter separator at &#x27;%s&#x27;\n&quot;, attrs);
336        errno = EINVAL;
337        return -1;
338      }
339    }
340    sattr-&gt;memorysize = memorysize;
341    if (index_string) {
342      if (sind-&gt;string &amp;&amp; verbose)
343        fprintf(stderr, &quot;Overwriting duplicate indexes attribute with last occurence\n&quot;);
344      sind-&gt;string = index_string;
345      sind-&gt;string_length = (unsigned long)index_string_length;
346    }
347    *next_posp = next_pos+1;
348    return 0;
349  }
350  static void
351  hwloc_synthetic_free_levels(struct hwloc_synthetic_backend_data_s *data)
352  {
353    unsigned i;
354    for(i=0; i&lt;HWLOC_SYNTHETIC_MAX_DEPTH; i++) {
355      struct hwloc_synthetic_level_data_s *curlevel = &amp;data-&gt;level[i];
356      struct hwloc_synthetic_attached_s **pprev = &amp;curlevel-&gt;attached;
357      while (*pprev) {
358        struct hwloc_synthetic_attached_s *cur = *pprev;
359        *pprev = cur-&gt;next;
360        free(cur);
361      }
362      free(curlevel-&gt;indexes.array);
363      if (!curlevel-&gt;arity)
364        break;
365    }
366    free(data-&gt;numa_attached_indexes.array);
367  }
368  static int
369  hwloc_backend_synthetic_init(struct hwloc_synthetic_backend_data_s *data,
370  			     const char *description)
371  {
372    const char *pos, *next_pos;
373    unsigned long item, count;
374    unsigned i;
375    int type_count[HWLOC_OBJ_TYPE_MAX];
376    unsigned unset;
377    int verbose = 0;
378    const char *env = getenv(&quot;HWLOC_SYNTHETIC_VERBOSE&quot;);
379    int err;
380    unsigned long totalarity = 1;
381    if (env)
382      verbose = atoi(env);
383    data-&gt;numa_attached_nr = 0;
384    data-&gt;numa_attached_indexes.array = NULL;
385    data-&gt;level[0].totalwidth = 1;
386    data-&gt;level[0].attr.type = HWLOC_OBJ_MACHINE;
387    data-&gt;level[0].indexes.string = NULL;
388    data-&gt;level[0].indexes.array = NULL;
389    data-&gt;level[0].attr.memorysize = 0;
390    data-&gt;level[0].attached = NULL;
391    type_count[HWLOC_OBJ_MACHINE] = 1;
392    if (*description == &#x27;(&#x27;) {
393      err = hwloc_synthetic_parse_attrs(description+1, &amp;description, &amp;data-&gt;level[0].attr, &amp;data-&gt;level[0].indexes, verbose);
394      if (err &lt; 0)
395        return err;
396    }
397    data-&gt;numa_attached_indexes.string = NULL;
398    data-&gt;numa_attached_indexes.array = NULL;
399    for (pos = description, count = 1; *pos; pos = next_pos) {
400      hwloc_obj_type_t type = HWLOC_OBJ_TYPE_NONE;
401      union hwloc_obj_attr_u attrs;
402      data-&gt;level[count-1].arity = 0;
403      while (*pos == &#x27; &#x27; || *pos == &#x27;\n&#x27;)
404        pos++;
405      if (!*pos)
406        break;
407      if (*pos == &#x27;[&#x27;) {
408        struct hwloc_synthetic_attached_s *attached, **pprev;
409        char *attr;
410        pos++;
411        if (hwloc_type_sscanf(pos, &amp;type, &amp;attrs, sizeof(attrs)) &lt; 0) {
412  	if (verbose)
413  	  fprintf(stderr, &quot;Synthetic string with unknown attached object type at &#x27;%s&#x27;\n&quot;, pos);
414  	errno = EINVAL;
415  	goto error;
416        }
417        if (type != HWLOC_OBJ_NUMANODE) {
418  	if (verbose)
419  	  fprintf(stderr, &quot;Synthetic string with disallowed attached object type at &#x27;%s&#x27;\n&quot;, pos);
420  	errno = EINVAL;
421  	goto error;
422        }
423        data-&gt;numa_attached_nr += data-&gt;level[count-1].totalwidth;
424        attached = malloc(sizeof(*attached));
425        if (attached) {
426  	attached-&gt;attr.type = type;
427  	attached-&gt;attr.memorysize = 0;
428  	attached-&gt;next = NULL;
429  	pprev = &amp;data-&gt;level[count-1].attached;
430  	while (*pprev)
431  	  pprev = &amp;((*pprev)-&gt;next);
432  	*pprev = attached;
433        }
434        next_pos = strchr(pos, &#x27;]&#x27;);
435        if (!next_pos) {
436  	if (verbose)
437  	  fprintf(stderr,&quot;Synthetic string doesn&#x27;t have a closing `]&#x27; after attached object type at &#x27;%s&#x27;\n&quot;, pos);
438  	errno = EINVAL;
439  	goto error;
440        }
441        attr = strchr(pos, &#x27;(&#x27;);
442        if (attr &amp;&amp; attr &lt; next_pos &amp;&amp; attached) {
443  	const char *dummy;
444  	err = hwloc_synthetic_parse_attrs(attr+1, &amp;dummy, &amp;attached-&gt;attr, &amp;data-&gt;numa_attached_indexes, verbose);
445  	if (err &lt; 0)
446  	  goto error;
447        }
448        next_pos++;
449        continue;
450      }
451      data-&gt;level[count].indexes.string = NULL;
452      data-&gt;level[count].indexes.array = NULL;
453      data-&gt;level[count].attached = NULL;
454      if (*pos &lt; &#x27;0&#x27; || *pos &gt; &#x27;9&#x27;) {
455        if (hwloc_type_sscanf(pos, &amp;type, &amp;attrs, sizeof(attrs)) &lt; 0) {
456  	if (!strncmp(pos, &quot;Tile&quot;, 4) || !strncmp(pos, &quot;Module&quot;, 6)) {
457  	  type = HWLOC_OBJ_GROUP;
458  	} else {
459  	  if (verbose)
460  	    fprintf(stderr, &quot;Synthetic string with unknown object type at &#x27;%s&#x27;\n&quot;, pos);
461  	  errno = EINVAL;
462  	  goto error;
463  	}
464        }
465        if (type == HWLOC_OBJ_MACHINE || type == HWLOC_OBJ_MISC || type == HWLOC_OBJ_BRIDGE || type == HWLOC_OBJ_PCI_DEVICE || type == HWLOC_OBJ_OS_DEVICE) {
466  	if (verbose)
467  	  fprintf(stderr, &quot;Synthetic string with disallowed object type at &#x27;%s&#x27;\n&quot;, pos);
468  	errno = EINVAL;
469  	goto error;
470        }
471        next_pos = strchr(pos, &#x27;:&#x27;);
472        if (!next_pos) {
473  	if (verbose)
474  	  fprintf(stderr,&quot;Synthetic string doesn&#x27;t have a `:&#x27; after object type at &#x27;%s&#x27;\n&quot;, pos);
475  	errno = EINVAL;
476  	goto error;
477        }
478        pos = next_pos + 1;
479      }
480      data-&gt;level[count].attr.type = type;
481      data-&gt;level[count].attr.depth = (unsigned) -1;
482      data-&gt;level[count].attr.cachetype = (hwloc_obj_cache_type_t) -1;
483      if (hwloc__obj_type_is_cache(type)) {
484        data-&gt;level[count].attr.depth = attrs.cache.depth;
485        data-&gt;level[count].attr.cachetype = attrs.cache.type;
486      } else if (type == HWLOC_OBJ_GROUP) {
487        data-&gt;level[count].attr.depth = attrs.group.depth;
488      }
489      item = strtoul(pos, (char **)&amp;next_pos, 0);
490      if (next_pos == pos) {
491        if (verbose)
492  	fprintf(stderr,&quot;Synthetic string doesn&#x27;t have a number of objects at &#x27;%s&#x27;\n&quot;, pos);
493        errno = EINVAL;
494        goto error;
495      }
496      if (!item) {
497        if (verbose)
498  	fprintf(stderr,&quot;Synthetic string with disallow 0 number of objects at &#x27;%s&#x27;\n&quot;, pos);
499        errno = EINVAL;
500        goto error;
501      }
502      totalarity *= item;
503      data-&gt;level[count].totalwidth = totalarity;
504      data-&gt;level[count].indexes.string = NULL;
505      data-&gt;level[count].indexes.array = NULL;
506      data-&gt;level[count].attr.memorysize = 0;
507      if (*next_pos == &#x27;(&#x27;) {
508        err = hwloc_synthetic_parse_attrs(next_pos+1, &amp;next_pos, &amp;data-&gt;level[count].attr, &amp;data-&gt;level[count].indexes, verbose);
509        if (err &lt; 0)
510  	goto error;
511      }
512      if (count + 1 &gt;= HWLOC_SYNTHETIC_MAX_DEPTH) {
513        if (verbose)
514  	fprintf(stderr,&quot;Too many synthetic levels, max %d\n&quot;, HWLOC_SYNTHETIC_MAX_DEPTH);
515        errno = EINVAL;
516        goto error;
517      }
518      if (item &gt; UINT_MAX) {
519        if (verbose)
520  	fprintf(stderr,&quot;Too big arity, max %u\n&quot;, UINT_MAX);
521        errno = EINVAL;
522        goto error;
523      }
524      data-&gt;level[count-1].arity = (unsigned)item;
525      count++;
526    }
527    if (data-&gt;level[count-1].attr.type != HWLOC_OBJ_TYPE_NONE &amp;&amp; data-&gt;level[count-1].attr.type != HWLOC_OBJ_PU) {
528      if (verbose)
529        fprintf(stderr, &quot;Synthetic string cannot use non-PU type for last level\n&quot;);
530      errno = EINVAL;
531      return -1;
532    }
533    data-&gt;level[count-1].attr.type = HWLOC_OBJ_PU;
534    for(i=HWLOC_OBJ_TYPE_MIN; i&lt;HWLOC_OBJ_TYPE_MAX; i++) {
535      type_count[i] = 0;
536    }
537    for(i=count-1; i&gt;0; i--) {
538      hwloc_obj_type_t type = data-&gt;level[i].attr.type;
539      if (type != HWLOC_OBJ_TYPE_NONE) {
540        type_count[type]++;
541      }
542    }
543    if (!type_count[HWLOC_OBJ_PU]) {
544      if (verbose)
545        fprintf(stderr, &quot;Synthetic string missing ending number of PUs\n&quot;);
546      errno = EINVAL;
547      return -1;
548    } else if (type_count[HWLOC_OBJ_PU] &gt; 1) {
549      if (verbose)
550        fprintf(stderr, &quot;Synthetic string cannot have several PU levels\n&quot;);
551      errno = EINVAL;
552      return -1;
553    }
554    if (type_count[HWLOC_OBJ_PACKAGE] &gt; 1) {
555      if (verbose)
556        fprintf(stderr, &quot;Synthetic string cannot have several package levels\n&quot;);
557      errno = EINVAL;
558      return -1;
559    }
560    if (type_count[HWLOC_OBJ_DIE] &gt; 1) {
561      if (verbose)
562        fprintf(stderr, &quot;Synthetic string cannot have several die levels\n&quot;);
563      errno = EINVAL;
564      return -1;
565    }
566    if (type_count[HWLOC_OBJ_NUMANODE] &gt; 1) {
567      if (verbose)
568        fprintf(stderr, &quot;Synthetic string cannot have several NUMA node levels\n&quot;);
569      errno = EINVAL;
570      return -1;
571    }
572    if (type_count[HWLOC_OBJ_NUMANODE] &amp;&amp; data-&gt;numa_attached_nr) {
573      if (verbose)
574        fprintf(stderr,&quot;Synthetic string cannot have NUMA nodes both as a level and attached\n&quot;);
575      errno = EINVAL;
576      return -1;
577    }
578    if (type_count[HWLOC_OBJ_CORE] &gt; 1) {
579      if (verbose)
580        fprintf(stderr, &quot;Synthetic string cannot have several core levels\n&quot;);
581      errno = EINVAL;
582      return -1;
583    }
584    unset = 0;
585    for(i=1; i&lt;count-1; i++) {
586      if (data-&gt;level[i].attr.type == HWLOC_OBJ_TYPE_NONE)
587        unset++;
588    }
589    if (unset &amp;&amp; unset != count-2) {
590      if (verbose)
591        fprintf(stderr, &quot;Synthetic string cannot mix unspecified and specified types for levels\n&quot;);
592      errno = EINVAL;
593      return -1;
594    }
595    if (unset) {
596      unsigned _count = count;
597      unsigned neednuma = 0;
598      unsigned needpack = 0;
599      unsigned needcore = 0;
600      unsigned needcaches = 0;
601      unsigned needgroups = 0;
602      _count -= 2;
603      neednuma = (_count &gt;= 1 &amp;&amp; !data-&gt;numa_attached_nr);
604      _count -= neednuma;
605      needpack = (_count &gt;= 1);
606      _count -= needpack;
607      needcore = (_count &gt;= 1);
608      _count -= needcore;
609      needcaches = (_count &gt; 4 ? 4 : _count);
610      _count -= needcaches;
611      needgroups = _count;
612      for(i = 0; i &lt; needgroups; i++) {
613        unsigned depth = 1 + i;
614        data-&gt;level[depth].attr.type = HWLOC_OBJ_GROUP;
615        type_count[HWLOC_OBJ_GROUP]++;
616      }
617      if (needpack) {
618        unsigned depth = 1 + needgroups;
619        data-&gt;level[depth].attr.type = HWLOC_OBJ_PACKAGE;
620        type_count[HWLOC_OBJ_PACKAGE] = 1;
621      }
622      if (neednuma) {
623        unsigned depth = 1 + needgroups + needpack;
624        data-&gt;level[depth].attr.type = HWLOC_OBJ_NUMANODE;
625        type_count[HWLOC_OBJ_NUMANODE] = 1;
626      }
627      if (needcaches) {
628        unsigned l3depth = 1 + needgroups + needpack + neednuma;
629        unsigned l2depth = l3depth + (needcaches &gt;= 3);
630        unsigned l1depth = l2depth + 1;
631        unsigned l1idepth = l1depth + 1;
632        if (needcaches &gt;= 3) {
633  	data-&gt;level[l3depth].attr.type = HWLOC_OBJ_L3CACHE;
634  	data-&gt;level[l3depth].attr.depth = 3;
635  	data-&gt;level[l3depth].attr.cachetype = HWLOC_OBJ_CACHE_UNIFIED;
636  	type_count[HWLOC_OBJ_L3CACHE] = 1;
637        }
638        data-&gt;level[l2depth].attr.type = HWLOC_OBJ_L2CACHE;
639        data-&gt;level[l2depth].attr.depth = 2;
640        data-&gt;level[l2depth].attr.cachetype = HWLOC_OBJ_CACHE_UNIFIED;
641        type_count[HWLOC_OBJ_L2CACHE] = 1;
642        if (needcaches &gt;= 2) {
643  	data-&gt;level[l1depth].attr.type = HWLOC_OBJ_L1CACHE;
644  	data-&gt;level[l1depth].attr.depth = 1;
645  	data-&gt;level[l1depth].attr.cachetype = HWLOC_OBJ_CACHE_DATA;
646  	type_count[HWLOC_OBJ_L1CACHE] = 1;
647        }
648        if (needcaches &gt;= 4) {
649  	data-&gt;level[l1idepth].attr.type = HWLOC_OBJ_L1ICACHE;
650  	data-&gt;level[l1idepth].attr.depth = 1;
651  	data-&gt;level[l1idepth].attr.cachetype = HWLOC_OBJ_CACHE_INSTRUCTION;
652  	type_count[HWLOC_OBJ_L1ICACHE] = 1;
653        }
654      }
655      if (needcore) {
656        unsigned depth = 1 + needgroups + needpack + neednuma + needcaches;
657        data-&gt;level[depth].attr.type = HWLOC_OBJ_CORE;
658        type_count[HWLOC_OBJ_CORE] = 1;
659      }
660    }
661    if (!type_count[HWLOC_OBJ_NUMANODE] &amp;&amp; !data-&gt;numa_attached_nr) {
662      if (verbose)
663        fprintf(stderr, &quot;Inserting a NUMA level with a single object at depth 1\n&quot;);
664      memmove(&amp;data-&gt;level[2], &amp;data-&gt;level[1], count*sizeof(struct hwloc_synthetic_level_data_s));
665      data-&gt;level[1].attr.type = HWLOC_OBJ_NUMANODE;
666      data-&gt;level[1].indexes.string = NULL;
667      data-&gt;level[1].indexes.array = NULL;
668      data-&gt;level[1].attr.memorysize = 0;
669      data-&gt;level[1].totalwidth = data-&gt;level[0].totalwidth;
670      data-&gt;level[1].arity = data-&gt;level[0].arity;
671      data-&gt;level[0].arity = 1;
672      count++;
673    }
674    for (i=0; i&lt;count; i++) {
675      struct hwloc_synthetic_level_data_s *curlevel = &amp;data-&gt;level[i];
676      hwloc_obj_type_t type = curlevel-&gt;attr.type;
677      if (type == HWLOC_OBJ_GROUP) {
678        if (curlevel-&gt;attr.depth == (unsigned)-1)
679  	curlevel-&gt;attr.depth = type_count[HWLOC_OBJ_GROUP]--;
680      } else if (hwloc__obj_type_is_cache(type)) {
681        if (!curlevel-&gt;attr.memorysize) {
682  	if (1 == curlevel-&gt;attr.depth)
683  	  curlevel-&gt;attr.memorysize = 32*1024;
684  	else
685  	  curlevel-&gt;attr.memorysize = 256ULL*1024 &lt;&lt; (2*curlevel-&gt;attr.depth);
686        }
687      } else if (type == HWLOC_OBJ_NUMANODE &amp;&amp; !curlevel-&gt;attr.memorysize) {
688        curlevel-&gt;attr.memorysize = 1024*1024*1024;
689      }
690      hwloc_synthetic_process_indexes(data, &amp;data-&gt;level[i].indexes, data-&gt;level[i].totalwidth, verbose);
691    }
692    hwloc_synthetic_process_indexes(data, &amp;data-&gt;numa_attached_indexes, data-&gt;numa_attached_nr, verbose);
693    data-&gt;string = strdup(description);
694    data-&gt;level[count-1].arity = 0;
695    return 0;
696   error:
697    hwloc_synthetic_free_levels(data);
698    return -1;
699  }
700  static void
701  hwloc_synthetic_set_attr(struct hwloc_synthetic_attr_s *sattr,
702  			 hwloc_obj_t obj)
703  {
704    switch (obj-&gt;type) {
705    case HWLOC_OBJ_GROUP:
706      obj-&gt;attr-&gt;group.kind = HWLOC_GROUP_KIND_SYNTHETIC;
707      obj-&gt;attr-&gt;group.subkind = sattr-&gt;depth-1;
708      break;
709    case HWLOC_OBJ_MACHINE:
710      break;
711    case HWLOC_OBJ_NUMANODE:
712      obj-&gt;attr-&gt;numanode.local_memory = sattr-&gt;memorysize;
713      obj-&gt;attr-&gt;numanode.page_types_len = 1;
714      obj-&gt;attr-&gt;numanode.page_types = malloc(sizeof(*obj-&gt;attr-&gt;numanode.page_types));
715      memset(obj-&gt;attr-&gt;numanode.page_types, 0, sizeof(*obj-&gt;attr-&gt;numanode.page_types));
716      obj-&gt;attr-&gt;numanode.page_types[0].size = 4096;
717      obj-&gt;attr-&gt;numanode.page_types[0].count = sattr-&gt;memorysize / 4096;
718      break;
719    case HWLOC_OBJ_PACKAGE:
720    case HWLOC_OBJ_DIE:
721      break;
722    case HWLOC_OBJ_L1CACHE:
723    case HWLOC_OBJ_L2CACHE:
724    case HWLOC_OBJ_L3CACHE:
725    case HWLOC_OBJ_L4CACHE:
726    case HWLOC_OBJ_L5CACHE:
727    case HWLOC_OBJ_L1ICACHE:
728    case HWLOC_OBJ_L2ICACHE:
729    case HWLOC_OBJ_L3ICACHE:
730      obj-&gt;attr-&gt;cache.depth = sattr-&gt;depth;
731      obj-&gt;attr-&gt;cache.linesize = 64;
732      obj-&gt;attr-&gt;cache.type = sattr-&gt;cachetype;
733      obj-&gt;attr-&gt;cache.size = sattr-&gt;memorysize;
734      break;
735    case HWLOC_OBJ_CORE:
736      break;
737    case HWLOC_OBJ_PU:
738      break;
739    default:
740      assert(0);
741      break;
742    }
743  }
744  static unsigned
745  hwloc_synthetic_next_index(struct hwloc_synthetic_indexes_s *indexes, hwloc_obj_type_t type)
746  {
747    unsigned os_index = indexes-&gt;next++;
748    if (indexes-&gt;array)
749      os_index = indexes-&gt;array[os_index];
750    else if (hwloc__obj_type_is_cache(type) || type == HWLOC_OBJ_GROUP)
751      os_index = HWLOC_UNKNOWN_INDEX;
752    return os_index;
753  }
754  static void
755  hwloc_synthetic_insert_attached(struct hwloc_topology *topology,
756  				struct hwloc_synthetic_backend_data_s *data,
757  				struct hwloc_synthetic_attached_s *attached,
758  				hwloc_bitmap_t set)
759  {
760    hwloc_obj_t child;
761    unsigned attached_os_index;
762    if (!attached)
763      return;
764    assert(attached-&gt;attr.type == HWLOC_OBJ_NUMANODE);
765    attached_os_index = hwloc_synthetic_next_index(&amp;data-&gt;numa_attached_indexes, HWLOC_OBJ_NUMANODE);
766    child = hwloc_alloc_setup_object(topology, attached-&gt;attr.type, attached_os_index);
767    child-&gt;cpuset = hwloc_bitmap_dup(set);
768    child-&gt;nodeset = hwloc_bitmap_alloc();
769    hwloc_bitmap_set(child-&gt;nodeset, attached_os_index);
770    hwloc_synthetic_set_attr(&amp;attached-&gt;attr, child);
771    hwloc__insert_object_by_cpuset(topology, NULL, child, &quot;synthetic:attached&quot;);
772    hwloc_synthetic_insert_attached(topology, data, attached-&gt;next, set);
773  }
774  static void
775  hwloc__look_synthetic(struct hwloc_topology *topology,
776  		      struct hwloc_synthetic_backend_data_s *data,
777  		      int level,
778  		      hwloc_bitmap_t parent_cpuset)
779  {
780    hwloc_obj_t obj;
781    unsigned i;
782    struct hwloc_synthetic_level_data_s *curlevel = &amp;data-&gt;level[level];
783    hwloc_obj_type_t type = curlevel-&gt;attr.type;
784    hwloc_bitmap_t set;
785    unsigned os_index;
786    assert(hwloc__obj_type_is_normal(type) || type == HWLOC_OBJ_NUMANODE);
787    assert(type != HWLOC_OBJ_MACHINE);
788    os_index = hwloc_synthetic_next_index(&amp;curlevel-&gt;indexes, type);
789    set = hwloc_bitmap_alloc();
790    if (!curlevel-&gt;arity) {
791      hwloc_bitmap_set(set, os_index);
792    } else {
793      for (i = 0; i &lt; curlevel-&gt;arity; i++)
794        hwloc__look_synthetic(topology, data, level + 1, set);
795    }
796    hwloc_bitmap_or(parent_cpuset, parent_cpuset, set);
797    if (hwloc_filter_check_keep_object_type(topology, type)) {
798      obj = hwloc_alloc_setup_object(topology, type, os_index);
799      obj-&gt;cpuset = hwloc_bitmap_dup(set);
800      if (type == HWLOC_OBJ_NUMANODE) {
801        obj-&gt;nodeset = hwloc_bitmap_alloc();
802        hwloc_bitmap_set(obj-&gt;nodeset, os_index);
803      }
804      hwloc_synthetic_set_attr(&amp;curlevel-&gt;attr, obj);
805      hwloc__insert_object_by_cpuset(topology, NULL, obj, &quot;synthetic&quot;);
806    }
807    hwloc_synthetic_insert_attached(topology, data, curlevel-&gt;attached, set);
808    hwloc_bitmap_free(set);
809  }
810  static int
811  hwloc_look_synthetic(struct hwloc_backend *backend, struct hwloc_disc_status *dstatus)
812  {
813    struct hwloc_topology *topology = backend-&gt;topology;
814    struct hwloc_synthetic_backend_data_s *data = backend-&gt;private_data;
815    hwloc_bitmap_t cpuset = hwloc_bitmap_alloc();
816    unsigned i;
817    assert(dstatus-&gt;phase == HWLOC_DISC_PHASE_GLOBAL);
818    assert(!topology-&gt;levels[0][0]-&gt;cpuset);
819    hwloc_alloc_root_sets(topology-&gt;levels[0][0]);
820    topology-&gt;support.discovery-&gt;pu = 1;
821    topology-&gt;support.discovery-&gt;numa = 1; &amp;bsol;* we add a single NUMA node if none is given */
822    topology-&gt;support.discovery-&gt;numa_memory = 1; &amp;bsol;* specified or default size */
823    for (i = 0; data-&gt;level[i].arity &gt; 0; i++)
824      data-&gt;level[i].indexes.next = 0;
825    data-&gt;numa_attached_indexes.next = 0;
826    data-&gt;level[i].indexes.next = 0;
827    topology-&gt;levels[0][0]-&gt;type = data-&gt;level[0].attr.type;
828    hwloc_synthetic_set_attr(&amp;data-&gt;level[0].attr, topology-&gt;levels[0][0]);
829    for (i = 0; i &lt; data-&gt;level[0].arity; i++)
830      hwloc__look_synthetic(topology, data, 1, cpuset);
831    hwloc_synthetic_insert_attached(topology, data, data-&gt;level[0].attached, cpuset);
832    hwloc_bitmap_free(cpuset);
833    hwloc_obj_add_info(topology-&gt;levels[0][0], &quot;Backend&quot;, &quot;Synthetic&quot;);
834    hwloc_obj_add_info(topology-&gt;levels[0][0], &quot;SyntheticDescription&quot;, data-&gt;string);
835    return 0;
836  }
837  static void
838  hwloc_synthetic_backend_disable(struct hwloc_backend *backend)
839  {
840    struct hwloc_synthetic_backend_data_s *data = backend-&gt;private_data;
841    hwloc_synthetic_free_levels(data);
842    free(data-&gt;string);
843    free(data);
844  }
845  static struct hwloc_backend *
846  hwloc_synthetic_component_instantiate(struct hwloc_topology *topology,
847  				      struct hwloc_disc_component *component,
848  				      unsigned excluded_phases __hwloc_attribute_unused,
849  				      const void *_data1,
850  				      const void *_data2 __hwloc_attribute_unused,
851  				      const void *_data3 __hwloc_attribute_unused)
852  {
853    struct hwloc_backend *backend;
854    struct hwloc_synthetic_backend_data_s *data;
855    int err;
856    if (!_data1) {
857      const char *env = getenv(&quot;HWLOC_SYNTHETIC&quot;);
858      if (env) {
859        _data1 = env;
860      } else {
861        errno = EINVAL;
862        goto out;
863      }
864    }
865    backend = hwloc_backend_alloc(topology, component);
866    if (!backend)
867      goto out;
868    data = malloc(sizeof(*data));
869    if (!data) {
870      errno = ENOMEM;
871      goto out_with_backend;
872    }
873    err = hwloc_backend_synthetic_init(data, (const char *) _data1);
874    if (err &lt; 0)
875      goto out_with_data;
876    backend-&gt;private_data = data;
877    backend-&gt;discover = hwloc_look_synthetic;
878    backend-&gt;disable = hwloc_synthetic_backend_disable;
879    backend-&gt;is_thissystem = 0;
880    return backend;
881   out_with_data:
882    free(data);
883   out_with_backend:
884    free(backend);
885   out:
886    return NULL;
887  }
888  static struct hwloc_disc_component hwloc_synthetic_disc_component = {
889    &quot;synthetic&quot;,
890    HWLOC_DISC_PHASE_GLOBAL,
891    ~0,
892    hwloc_synthetic_component_instantiate,
893    30,
894    1,
895    NULL
896  };
897  const struct hwloc_component hwloc_synthetic_component = {
898    HWLOC_COMPONENT_ABI,
899    NULL, NULL,
900    HWLOC_COMPONENT_TYPE_DISC,
901    0,
902    &amp;hwloc_synthetic_disc_component
903  };
904  static __hwloc_inline int
905  hwloc__export_synthetic_update_status(int *ret, char **tmp, ssize_t *tmplen, int res)
906  {
907    if (res &lt; 0)
908      return -1;
909    *ret += res;
910    if (res &gt;= *tmplen)
911      res = *tmplen&gt;0 ? (int)(*tmplen) - 1 : 0;
912    *tmp += res;
913    *tmplen -= res;
914    return 0;
915  }
916  static __hwloc_inline void
917  hwloc__export_synthetic_add_char(int *ret, char **tmp, ssize_t *tmplen, char c)
918  {
919    if (*tmplen &gt; 1) {
920      (*tmp)[0] = c;
921      (*tmp)[1] = &#x27;\0&#x27;;
922      (*tmp)++;
923      (*tmplen)--;
924    }
925    (*ret)++;
926  }
927  static int
928  hwloc__export_synthetic_indexes(hwloc_obj_t *level, unsigned total,
929  				char *buffer, size_t buflen)
930  {
931    unsigned step = 1;
932    unsigned nr_loops = 0;
933    struct hwloc_synthetic_intlv_loop_s *loops = NULL, *tmploops;
934    hwloc_obj_t cur;
935    unsigned i, j;
936    ssize_t tmplen = buflen;
937    char *tmp = buffer;
938    int res, ret = 0;
939    if (level[0]-&gt;os_index)
940      goto exportall;
941    while (step != total) {
942      if (total % step)
943        goto exportall;
944      for(i=1; i&lt;total; i++)
945        if (level[i]-&gt;os_index == step)
946  	break;
947      if (i == total)
948        goto exportall;
949      for(j=2; j&lt;total/i; j++)
950        if (level[i*j]-&gt;os_index != step*j)
951  	break;
952      nr_loops++;
953      tmploops = realloc(loops, nr_loops*sizeof(*loops));
954      if (!tmploops)
955        goto exportall;
956      loops = tmploops;
957      loops[nr_loops-1].step = i;
958      loops[nr_loops-1].nb = j;
959      step *= j;
960    }
961    for(i=0; i&lt;total; i++) {
962      unsigned ind = 0;
963      unsigned mul = 1;
964      for(j=0; j&lt;nr_loops; j++) {
965        ind += (i / loops[j].step) % loops[j].nb * mul;
966        mul *= loops[j].nb;
967      }
968      if (level[i]-&gt;os_index != ind)
969        goto exportall;
970    }
971    for(j=0; j&lt;nr_loops; j++) {
972      res = hwloc_snprintf(tmp, tmplen, &quot;%u*%u%s&quot;, loops[j].step, loops[j].nb,
973  			 j == nr_loops-1 ? &quot;)&quot; : &quot;:&quot;);
974      if (hwloc__export_synthetic_update_status(&amp;ret, &amp;tmp, &amp;tmplen, res) &lt; 0) {
975        free(loops);
976        return -1;
977      }
978    }
979    free(loops);
980    return ret;
981   exportall:
982    free(loops);
983    cur = level[0];
984    while (cur) {
985      res = hwloc_snprintf(tmp, tmplen, &quot;%u%s&quot;, cur-&gt;os_index,
986  			 cur-&gt;next_cousin ? &quot;,&quot; : &quot;)&quot;);
987      if (hwloc__export_synthetic_update_status(&amp;ret, &amp;tmp, &amp;tmplen, res) &lt; 0)
988        return -1;
989      cur = cur-&gt;next_cousin;
990    }
991    return ret;
992  }
993  static int
994  hwloc__export_synthetic_obj_attr(struct hwloc_topology * topology,
995  				 hwloc_obj_t obj,
996  				 char *buffer, size_t buflen)
997  {
998    const char * separator = &quot; &quot;;
999    const char * prefix = &quot;(&quot;;
1000    char cachesize[64] = &quot;&quot;;
1001    char memsize[64] = &quot;&quot;;
1002    int needindexes = 0;
1003    if (hwloc__obj_type_is_cache(obj-&gt;type) &amp;&amp; obj-&gt;attr-&gt;cache.size) {
1004      snprintf(cachesize, sizeof(cachesize), &quot;%ssize=%llu&quot;,
1005  	     prefix, (unsigned long long) obj-&gt;attr-&gt;cache.size);
1006      prefix = separator;
1007    }
1008    if (obj-&gt;type == HWLOC_OBJ_NUMANODE &amp;&amp; obj-&gt;attr-&gt;numanode.local_memory) {
1009      snprintf(memsize, sizeof(memsize), &quot;%smemory=%llu&quot;,
1010  	     prefix, (unsigned long long) obj-&gt;attr-&gt;numanode.local_memory);
1011      prefix = separator;
1012    }
1013    if (!obj-&gt;logical_index &amp;bsol;* only display indexes once per level (not for non-first NUMA children, etc.) */
1014        &amp;&amp; (obj-&gt;type == HWLOC_OBJ_PU || obj-&gt;type == HWLOC_OBJ_NUMANODE)) {
1015      hwloc_obj_t cur = obj;
1016      while (cur) {
1017        if (cur-&gt;os_index != cur-&gt;logical_index) {
1018  	needindexes = 1;
1019  	break;
1020        }
1021        cur = cur-&gt;next_cousin;
1022      }
1023    }
1024    if (*cachesize || *memsize || needindexes) {
1025      ssize_t tmplen = buflen;
1026      char *tmp = buffer;
1027      int res, ret = 0;
1028      res = hwloc_snprintf(tmp, tmplen, &quot;%s%s%s&quot;, cachesize, memsize, needindexes ? &quot;&quot; : &quot;)&quot;);
1029      if (hwloc__export_synthetic_update_status(&amp;ret, &amp;tmp, &amp;tmplen, res) &lt; 0)
1030        return -1;
1031      if (needindexes) {
1032        unsigned total;
1033        hwloc_obj_t *level;
1034        if (obj-&gt;depth &lt; 0) {
1035  	assert(obj-&gt;depth == HWLOC_TYPE_DEPTH_NUMANODE);
1036  	total = topology-&gt;slevels[HWLOC_SLEVEL_NUMANODE].nbobjs;
1037  	level = topology-&gt;slevels[HWLOC_SLEVEL_NUMANODE].objs;
1038        } else {
1039  	total = topology-&gt;level_nbobjects[obj-&gt;depth];
1040  	level = topology-&gt;levels[obj-&gt;depth];
1041        }
1042        res = hwloc_snprintf(tmp, tmplen, &quot;%sindexes=&quot;, prefix);
1043        if (hwloc__export_synthetic_update_status(&amp;ret, &amp;tmp, &amp;tmplen, res) &lt; 0)
1044  	return -1;
1045        res = hwloc__export_synthetic_indexes(level, total, tmp, tmplen);
1046        if (hwloc__export_synthetic_update_status(&amp;ret, &amp;tmp, &amp;tmplen, res) &lt; 0)
1047  	return -1;
1048      }
1049      return ret;
1050    } else {
1051      return 0;
1052    }
1053  }
1054  static int
1055  hwloc__export_synthetic_obj(struct hwloc_topology * topology, unsigned long flags,
1056  			    hwloc_obj_t obj, unsigned arity,
1057  			    char *buffer, size_t buflen)
1058  {
1059    char aritys[12] = &quot;&quot;;
1060    ssize_t tmplen = buflen;
1061    char *tmp = buffer;
1062    int res, ret = 0;
1063    if (arity != (unsigned)-1)
1064      snprintf(aritys, sizeof(aritys), &quot;:%u&quot;, arity);
1065    if (hwloc__obj_type_is_cache(obj-&gt;type)
1066        &amp;&amp; (flags &amp; HWLOC_TOPOLOGY_EXPORT_SYNTHETIC_FLAG_NO_EXTENDED_TYPES)) {
1067      res = hwloc_snprintf(tmp, tmplen, &quot;Cache%s&quot;, aritys);
1068    } else if (obj-&gt;type == HWLOC_OBJ_PACKAGE
1069  	     &amp;&amp; (flags &amp; (HWLOC_TOPOLOGY_EXPORT_SYNTHETIC_FLAG_NO_EXTENDED_TYPES
1070  			  |HWLOC_TOPOLOGY_EXPORT_SYNTHETIC_FLAG_V1))) {
1071      res = hwloc_snprintf(tmp, tmplen, &quot;Socket%s&quot;, aritys);
1072    } else if (obj-&gt;type == HWLOC_OBJ_DIE
1073  	     &amp;&amp; (flags &amp; (HWLOC_TOPOLOGY_EXPORT_SYNTHETIC_FLAG_NO_EXTENDED_TYPES
1074  			  |HWLOC_TOPOLOGY_EXPORT_SYNTHETIC_FLAG_V1))) {
1075      res = hwloc_snprintf(tmp, tmplen, &quot;Group%s&quot;, aritys);
1076    } else if (obj-&gt;type == HWLOC_OBJ_GROUP &amp;bsol;* don&#x27;t export group depth */
1077        || flags &amp; HWLOC_TOPOLOGY_EXPORT_SYNTHETIC_FLAG_NO_EXTENDED_TYPES) {
1078      res = hwloc_snprintf(tmp, tmplen, &quot;%s%s&quot;, hwloc_obj_type_string(obj-&gt;type), aritys);
1079    } else {
1080      char types[64];
1081      hwloc_obj_type_snprintf(types, sizeof(types), obj, 1);
1082      res = hwloc_snprintf(tmp, tmplen, &quot;%s%s&quot;, types, aritys);
1083    }
1084    if (hwloc__export_synthetic_update_status(&amp;ret, &amp;tmp, &amp;tmplen, res) &lt; 0)
1085      return -1;
1086    if (!(flags &amp; HWLOC_TOPOLOGY_EXPORT_SYNTHETIC_FLAG_NO_ATTRS)) {
1087      res = hwloc__export_synthetic_obj_attr(topology, obj, tmp, tmplen);
1088      if (hwloc__export_synthetic_update_status(&amp;ret, &amp;tmp, &amp;tmplen, res) &lt; 0)
1089        return -1;
1090    }
1091    return ret;
1092  }
1093  static int
1094  hwloc__export_synthetic_memory_children(struct hwloc_topology * topology, unsigned long flags,
1095  					hwloc_obj_t parent,
1096  					char *buffer, size_t buflen,
1097  					int needprefix, int verbose)
1098  {
1099    hwloc_obj_t mchild;
1100    ssize_t tmplen = buflen;
1101    char *tmp = buffer;
1102    int res, ret = 0;
1103    mchild = parent-&gt;memory_first_child;
1104    if (!mchild)
1105      return 0;
1106    if (flags &amp; HWLOC_TOPOLOGY_EXPORT_SYNTHETIC_FLAG_V1) {
1107      if (parent-&gt;memory_arity &gt; 1 || mchild-&gt;type != HWLOC_OBJ_NUMANODE) {
1108        if (verbose)
1109  	fprintf(stderr, &quot;Cannot export to synthetic v1 if multiple memory children are attached to the same location.\n&quot;);
1110        errno = EINVAL;
1111        return -1;
1112      }
1113      if (needprefix)
1114        hwloc__export_synthetic_add_char(&amp;ret, &amp;tmp, &amp;tmplen, &#x27; &#x27;);
1115      res = hwloc__export_synthetic_obj(topology, flags, mchild, 1, tmp, tmplen);
1116      if (hwloc__export_synthetic_update_status(&amp;ret, &amp;tmp, &amp;tmplen, res) &lt; 0)
1117        return -1;
1118      return ret;
1119    }
1120    while (mchild) {
1121      hwloc_obj_t numanode = mchild;
1122      while (numanode &amp;&amp; numanode-&gt;type != HWLOC_OBJ_NUMANODE) {
1123        assert(numanode-&gt;arity == 1);
1124        numanode = numanode-&gt;memory_first_child;
1125      }
1126      assert(numanode); &amp;bsol;* there&#x27;s always a numanode at the bottom of the memory tree */
1127      if (needprefix)
1128        hwloc__export_synthetic_add_char(&amp;ret, &amp;tmp, &amp;tmplen, &#x27; &#x27;);
1129      hwloc__export_synthetic_add_char(&amp;ret, &amp;tmp, &amp;tmplen, &#x27;[&#x27;);
1130      res = hwloc__export_synthetic_obj(topology, flags, numanode, (unsigned)-1, tmp, tmplen);
1131      if (hwloc__export_synthetic_update_status(&amp;ret, &amp;tmp, &amp;tmplen, res) &lt; 0)
1132        return -1;
1133      hwloc__export_synthetic_add_char(&amp;ret, &amp;tmp, &amp;tmplen, &#x27;]&#x27;);
1134      needprefix = 1;
1135      mchild = mchild-&gt;next_sibling;
1136    }
1137    return ret;
1138  }
1139  static int
1140  hwloc_check_memory_symmetric(struct hwloc_topology * topology)
1141  {
1142    hwloc_bitmap_t remaining_nodes;
1143    remaining_nodes = hwloc_bitmap_dup(hwloc_get_root_obj(topology)-&gt;nodeset);
1144    if (!remaining_nodes)
1145      return -1;
1146    while (!hwloc_bitmap_iszero(remaining_nodes)) {
1147      unsigned idx;
1148      hwloc_obj_t node;
1149      hwloc_obj_t first_parent;
1150      unsigned i;
1151      idx = hwloc_bitmap_first(remaining_nodes);
1152      node = hwloc_get_numanode_obj_by_os_index(topology, idx);
1153      assert(node);
1154      first_parent = node-&gt;parent;
1155      for(i=0; i&lt;hwloc_get_nbobjs_by_depth(topology, first_parent-&gt;depth); i++) {
1156        hwloc_obj_t parent, mchild;
1157        parent = hwloc_get_obj_by_depth(topology, first_parent-&gt;depth, i);
1158        assert(parent);
1159        if (parent-&gt;memory_arity != first_parent-&gt;memory_arity)
1160  	goto out_with_bitmap;
1161        mchild = parent-&gt;memory_first_child;
1162        while (mchild) {
1163  	hwloc_bitmap_clr(remaining_nodes, mchild-&gt;os_index); &amp;bsol;* cannot use parent-&gt;nodeset, some normal children may have other NUMA nodes */
1164  	mchild = mchild-&gt;next_sibling;
1165        }
1166      }
1167    }
1168    hwloc_bitmap_free(remaining_nodes);
1169    return 0;
1170   out_with_bitmap:
1171    hwloc_bitmap_free(remaining_nodes);
1172    return -1;
1173  }
1174  int
1175  hwloc_topology_export_synthetic(struct hwloc_topology * topology,
1176  				char *buffer, size_t buflen,
1177  				unsigned long flags)
1178  {
1179    hwloc_obj_t obj = hwloc_get_root_obj(topology);
1180    ssize_t tmplen = buflen;
1181    char *tmp = buffer;
1182    int res, ret = 0;
1183    unsigned arity;
1184    int needprefix = 0;
1185    int verbose = 0;
1186    const char *env = getenv(&quot;HWLOC_SYNTHETIC_VERBOSE&quot;);
1187    if (env)
1188      verbose = atoi(env);
1189    if (!topology-&gt;is_loaded) {
1190      errno = EINVAL;
1191      return -1;
1192    }
1193    if (flags &amp; ~(HWLOC_TOPOLOGY_EXPORT_SYNTHETIC_FLAG_NO_EXTENDED_TYPES
1194  		|HWLOC_TOPOLOGY_EXPORT_SYNTHETIC_FLAG_NO_ATTRS
1195  		|HWLOC_TOPOLOGY_EXPORT_SYNTHETIC_FLAG_V1
1196  		|HWLOC_TOPOLOGY_EXPORT_SYNTHETIC_FLAG_IGNORE_MEMORY)) {
1197      errno = EINVAL;
1198      return -1;
1199    }
1200    if (!obj-&gt;symmetric_subtree) {
1201      if (verbose)
1202        fprintf(stderr, &quot;Cannot export to synthetic unless topology is symmetric (root-&gt;symmetric_subtree must be set).\n&quot;);
1203      errno = EINVAL;
1204      return -1;
1205    }
1206    if (!(flags &amp; HWLOC_TOPOLOGY_EXPORT_SYNTHETIC_FLAG_IGNORE_MEMORY)
1207        &amp;&amp; hwloc_check_memory_symmetric(topology) &lt; 0) {
1208      if (verbose)
1209        fprintf(stderr, &quot;Cannot export to synthetic unless memory is attached symmetrically.\n&quot;);
1210      errno = EINVAL;
1211      return -1;
1212    }
1213    if (flags &amp; HWLOC_TOPOLOGY_EXPORT_SYNTHETIC_FLAG_V1) {
1214      hwloc_obj_t node;
1215      signed pdepth;
1216      node = hwloc_get_obj_by_type(topology, HWLOC_OBJ_NUMANODE, 0);
1217      assert(node);
1218      assert(hwloc__obj_type_is_normal(node-&gt;parent-&gt;type)); &amp;bsol;* only depth-1 memory children for now */
1219      pdepth = node-&gt;parent-&gt;depth;
1220      while ((node = node-&gt;next_cousin) != NULL) {
1221        assert(hwloc__obj_type_is_normal(node-&gt;parent-&gt;type)); &amp;bsol;* only depth-1 memory children for now */
1222        if (node-&gt;parent-&gt;depth != pdepth) {
1223  	if (verbose)
1224  	  fprintf(stderr, &quot;Cannot export to synthetic v1 if memory is attached to parents at different depths.\n&quot;);
1225  	errno = EINVAL;
1226  	return -1;
1227        }
1228      }
1229    }
1230    if (!(flags &amp; HWLOC_TOPOLOGY_EXPORT_SYNTHETIC_FLAG_NO_ATTRS)) {
1231      res = hwloc__export_synthetic_obj_attr(topology, obj, tmp, tmplen);
1232      if (res &gt; 0)
1233        needprefix = 1;
1234      if (hwloc__export_synthetic_update_status(&amp;ret, &amp;tmp, &amp;tmplen, res) &lt; 0)
1235        return -1;
1236    }
1237    if (!(flags &amp; HWLOC_TOPOLOGY_EXPORT_SYNTHETIC_FLAG_IGNORE_MEMORY)) {
1238      res = hwloc__export_synthetic_memory_children(topology, flags, obj, tmp, tmplen, needprefix, verbose);
1239      if (res &gt; 0)
1240        needprefix = 1;
1241      if (hwloc__export_synthetic_update_status(&amp;ret, &amp;tmp, &amp;tmplen, res) &lt; 0)
1242        return -1;
1243    }
1244    arity = obj-&gt;arity;
1245    while (arity) {
1246      obj = obj-&gt;first_child;
<span onclick='openModal()' class='match'>1247      if (needprefix)
1248        hwloc__export_synthetic_add_char(&amp;ret, &amp;tmp, &amp;tmplen, &#x27; &#x27;);
1249      res = hwloc__export_synthetic_obj(topology, flags, obj, arity, tmp, tmplen);
</span>1250      if (hwloc__export_synthetic_update_status(&amp;ret, &amp;tmp, &amp;tmplen, res) &lt; 0)
1251        return -1;
1252      if (!(flags &amp; HWLOC_TOPOLOGY_EXPORT_SYNTHETIC_FLAG_IGNORE_MEMORY)) {
1253        res = hwloc__export_synthetic_memory_children(topology, flags, obj, tmp, tmplen, 1, verbose);
1254        if (hwloc__export_synthetic_update_status(&amp;ret, &amp;tmp, &amp;tmplen, res) &lt; 0)
1255  	return -1;
1256      }
1257      needprefix = 1;
1258      arity = obj-&gt;arity;
1259    }
1260    return ret;
1261  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from xmrig-MDEwOlJlcG9zaXRvcnk4ODMyNzQwNg==-flat-topology-synthetic.c</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from xmrig-MDEwOlJlcG9zaXRvcnk4ODMyNzQwNg==-flat-topology-synthetic.c</div>
                </div>
                <div class="column column_space"><pre><code>1127      if (needprefix)
1128        hwloc__export_synthetic_add_char(&amp;ret, &amp;tmp, &amp;tmplen, &#x27; &#x27;);
1129      hwloc__export_synthetic_add_char(&amp;ret, &amp;tmp, &amp;tmplen, &#x27;[&#x27;);
</pre></code></div>
                <div class="column column_space"><pre><code>1247      if (needprefix)
1248        hwloc__export_synthetic_add_char(&amp;ret, &amp;tmp, &amp;tmplen, &#x27; &#x27;);
1249      res = hwloc__export_synthetic_obj(topology, flags, obj, arity, tmp, tmplen);
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    