
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 15, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>PINRemoteImage-MDEwOlJlcG9zaXRvcnkzOTUzNzEwMw==-flat-img2webp.c</h3>
            <pre><code>1  #include <stdio.h>
2  #include <stdlib.h>
3  #include <string.h>
4  #ifdef HAVE_CONFIG_H
5  #include "webp/config.h"
6  #endif
7  #include "../examples/example_util.h"
8  #include "../imageio/image_dec.h"
9  #include "../imageio/imageio_util.h"
10  #include "./stopwatch.h"
11  #include "./unicode.h"
12  #include "webp/encode.h"
13  #include "webp/mux.h"
14  static void Help(void) {
15    printf("Usage:\n\n");
16    printf("  img2webp [file-level options] [image files...] "
17           "[per-frame options...]\n");
18    printf("\n");
19    printf("File-level options (only used at the start of compression):\n");
20    printf(" -min_size ............ minimize size\n");
21    printf(" -loop <int> .......... loop count (default: 0, = infinite loop)\n");
22    printf(" -kmax <int> .......... maximum number of frame between key-frames\n"
23           "                        (0=only keyframes)\n");
24    printf(" -kmin <int> .......... minimum number of frame between key-frames\n"
25           "                        (0=disable key-frames altogether)\n");
26    printf(" -mixed ............... use mixed lossy/lossless automatic mode\n");
27    printf(" -v ................... verbose mode\n");
28    printf(" -h ................... this help\n");
29    printf(" -version ............. print version number and exit\n");
30    printf("\n");
31    printf("Per-frame options (only used for subsequent images input):\n");
32    printf(" -d <int> ............. frame duration in ms (default: 100)\n");
33    printf(" -lossless  ........... use lossless mode (default)\n");
34    printf(" -lossy ... ........... use lossy mode\n");
35    printf(" -q <float> ........... quality\n");
36    printf(" -m <int> ............. method to use\n");
37    printf("\n");
38    printf("example: img2webp -loop 2 in0.png -lossy in1.jpg\n"
39           "                  -d 80 in2.tiff -o out.webp\n");
40    printf("\nNote: if a single file name is passed as the argument, the "
41           "arguments will be\n");
42    printf("tokenized from this file. The file name must not start with "
43           "the character '-'.\n");
44  }
45  static int ReadImage(const char filename[], WebPPicture* const pic) {
46    const uint8_t* data = NULL;
47    size_t data_size = 0;
48    WebPImageReader reader;
49    int ok;
50  #ifdef HAVE_WINCODEC_H
51    ok = ReadPictureWithWIC(filename, pic, 1, NULL);
52    if (ok) return 1;
53  #endif
54    if (!ImgIoUtilReadFile(filename, &data, &data_size)) return 0;
55    reader = WebPGuessImageReader(data, data_size);
<span onclick='openModal()' class='match'>56    ok = reader(data, data_size, pic, 1, NULL);
57    free((void*)data);
</span>58    return ok;
59  }
60  static int SetLoopCount(int loop_count, WebPData* const webp_data) {
61    int ok = 1;
62    WebPMuxError err;
63    uint32_t features;
64    WebPMuxAnimParams new_params;
65    WebPMux* const mux = WebPMuxCreate(webp_data, 1);
66    if (mux == NULL) return 0;
67    err = WebPMuxGetFeatures(mux, &features);
68    ok = (err == WEBP_MUX_OK);
69    if (!ok || !(features & ANIMATION_FLAG)) goto End;
70    err = WebPMuxGetAnimationParams(mux, &new_params);
71    ok = (err == WEBP_MUX_OK);
72    if (ok) {
73      new_params.loop_count = loop_count;
74      err = WebPMuxSetAnimationParams(mux, &new_params);
75      ok = (err == WEBP_MUX_OK);
76    }
77    if (ok) {
78      WebPDataClear(webp_data);
79      err = WebPMuxAssemble(mux, webp_data);
80      ok = (err == WEBP_MUX_OK);
81    }
82   End:
83    WebPMuxDelete(mux);
84    if (!ok) {
85      fprintf(stderr, "Error during loop-count setting\n");
86    }
87    return ok;
88  }
89  int main(int argc, const char* argv[]) {
90    const char* output = NULL;
91    WebPAnimEncoder* enc = NULL;
92    int verbose = 0;
93    int pic_num = 0;
94    int duration = 100;
95    int timestamp_ms = 0;
96    int loop_count = 0;
97    int width = 0, height = 0;
98    WebPAnimEncoderOptions anim_config;
99    WebPConfig config;
100    WebPPicture pic;
101    WebPData webp_data;
102    int c;
103    int have_input = 0;
104    CommandLineArguments cmd_args;
105    int ok;
106    INIT_WARGV(argc, argv);
107    ok = ExUtilInitCommandLineArguments(argc - 1, argv + 1, &cmd_args);
108    if (!ok) FREE_WARGV_AND_RETURN(1);
109    argc = cmd_args.argc_;
110    argv = cmd_args.argv_;
111    WebPDataInit(&webp_data);
112    if (!WebPAnimEncoderOptionsInit(&anim_config) ||
113        !WebPConfigInit(&config) ||
114        !WebPPictureInit(&pic)) {
115      fprintf(stderr, "Library version mismatch!\n");
116      ok = 0;
117      goto End;
118    }
119    for (c = 0; ok && c < argc; ++c) {
120      if (argv[c][0] == '-') {
121        int parse_error = 0;
122        if (!strcmp(argv[c], "-o") && c + 1 < argc) {
123          argv[c] = NULL;
124          output = (const char*)GET_WARGV_SHIFTED(argv, ++c);
125        } else if (!strcmp(argv[c], "-kmin") && c + 1 < argc) {
126          argv[c] = NULL;
127          anim_config.kmin = ExUtilGetInt(argv[++c], 0, &parse_error);
128        } else if (!strcmp(argv[c], "-kmax") && c + 1 < argc) {
129          argv[c] = NULL;
130          anim_config.kmax = ExUtilGetInt(argv[++c], 0, &parse_error);
131        } else if (!strcmp(argv[c], "-loop") && c + 1 < argc) {
132          argv[c] = NULL;
133          loop_count = ExUtilGetInt(argv[++c], 0, &parse_error);
134          if (loop_count < 0) {
135            fprintf(stderr, "Invalid non-positive loop-count (%d)\n", loop_count);
136            parse_error = 1;
137          }
138        } else if (!strcmp(argv[c], "-min_size")) {
139          anim_config.minimize_size = 1;
140        } else if (!strcmp(argv[c], "-mixed")) {
141          anim_config.allow_mixed = 1;
142          config.lossless = 0;
143        } else if (!strcmp(argv[c], "-v")) {
144          verbose = 1;
145        } else if (!strcmp(argv[c], "-h") || !strcmp(argv[c], "-help")) {
146          Help();
147          goto End;
148        } else if (!strcmp(argv[c], "-version")) {
149          const int enc_version = WebPGetEncoderVersion();
150          const int mux_version = WebPGetMuxVersion();
151          printf("WebP Encoder version: %d.%d.%d\nWebP Mux version: %d.%d.%d\n",
152                 (enc_version >> 16) & 0xff, (enc_version >> 8) & 0xff,
153                 enc_version & 0xff, (mux_version >> 16) & 0xff,
154                 (mux_version >> 8) & 0xff, mux_version & 0xff);
155          goto End;
156        } else {
157          continue;
158        }
159        ok = !parse_error;
160        if (!ok) goto End;
161        argv[c] = NULL;   
162      } else {
163        have_input |= 1;
164      }
165    }
166    if (!have_input) {
167      fprintf(stderr, "No input file(s) for generating animation!\n");
168      goto End;
169    }
170    pic_num = 0;
171    config.lossless = 1;
172    for (c = 0; ok && c < argc; ++c) {
173      if (argv[c] == NULL) continue;
174      if (argv[c][0] == '-') {    
175        int parse_error = 0;
176        if (!strcmp(argv[c], "-lossy")) {
177          if (!anim_config.allow_mixed) config.lossless = 0;
178        } else if (!strcmp(argv[c], "-lossless")) {
179          if (!anim_config.allow_mixed) config.lossless = 1;
180        } else if (!strcmp(argv[c], "-q") && c + 1 < argc) {
181          config.quality = ExUtilGetFloat(argv[++c], &parse_error);
182        } else if (!strcmp(argv[c], "-m") && c + 1 < argc) {
183          config.method = ExUtilGetInt(argv[++c], 0, &parse_error);
184        } else if (!strcmp(argv[c], "-d") && c + 1 < argc) {
185          duration = ExUtilGetInt(argv[++c], 0, &parse_error);
186          if (duration <= 0) {
187            fprintf(stderr, "Invalid negative duration (%d)\n", duration);
188            parse_error = 1;
189          }
190        } else {
191          parse_error = 1;   
192          fprintf(stderr, "Unknown option [%s]\n", argv[c]);
193        }
194        ok = !parse_error;
195        if (!ok) goto End;
196        continue;
197      }
198      if (ok) {
199        ok = WebPValidateConfig(&config);
200        if (!ok) {
201          fprintf(stderr, "Invalid configuration.\n");
202          goto End;
203        }
204      }
205      pic.use_argb = 1;
206      ok = ReadImage((const char*)GET_WARGV_SHIFTED(argv, c), &pic);
207      if (!ok) goto End;
208      if (enc == NULL) {
209        width  = pic.width;
210        height = pic.height;
211        enc = WebPAnimEncoderNew(width, height, &anim_config);
212        ok = (enc != NULL);
213        if (!ok) {
214          fprintf(stderr, "Could not create WebPAnimEncoder object.\n");
215        }
216      }
217      if (ok) {
218        ok = (width == pic.width && height == pic.height);
219        if (!ok) {
220          fprintf(stderr, "Frame #%d dimension mismatched! "
221                          "Got %d x %d. Was expecting %d x %d.\n",
222                  pic_num, pic.width, pic.height, width, height);
223        }
224      }
225      if (ok) {
226        ok = WebPAnimEncoderAdd(enc, &pic, timestamp_ms, &config);
227        if (!ok) {
228          fprintf(stderr, "Error while adding frame #%d\n", pic_num);
229        }
230      }
231      WebPPictureFree(&pic);
232      if (!ok) goto End;
233      if (verbose) {
234        WFPRINTF(stderr, "Added frame #%3d at time %4d (file: %s)\n",
235                 pic_num, timestamp_ms, GET_WARGV_SHIFTED(argv, c));
236      }
237      timestamp_ms += duration;
238      ++pic_num;
239    }
240    ok = ok && WebPAnimEncoderAdd(enc, NULL, timestamp_ms, NULL);
241    ok = ok && WebPAnimEncoderAssemble(enc, &webp_data);
242    if (!ok) {
243      fprintf(stderr, "Error during final animation assembly.\n");
244    }
245   End:
246    WebPAnimEncoderDelete(enc);
247    if (ok && loop_count > 0) {  
248      ok = SetLoopCount(loop_count, &webp_data);
249    }
250    if (ok) {
251      if (output != NULL) {
252        ok = ImgIoUtilWriteFile(output, webp_data.bytes, webp_data.size);
253        if (ok) WFPRINTF(stderr, "output file: %s     ", (const W_CHAR*)output);
254      } else {
255        fprintf(stderr, "[no output file specified]   ");
256      }
257    }
258    if (ok) {
259      fprintf(stderr, "[%d frames, %u bytes].\n",
260              pic_num, (unsigned int)webp_data.size);
261    }
262    WebPDataClear(&webp_data);
263    ExUtilDeleteCommandLineArguments(&cmd_args);
264    FREE_WARGV_AND_RETURN(ok ? 0 : 1);
265  }
</code></pre>
        </div>
        <div class="column">
            <h3>PINRemoteImage-MDEwOlJlcG9zaXRvcnkzOTUzNzEwMw==-flat-backward_references_enc.c</h3>
            <pre><code>1  #include <assert.h>
2  #include <math.h>
3  #include "src/enc/backward_references_enc.h"
4  #include "src/enc/histogram_enc.h"
5  #include "src/dsp/lossless.h"
6  #include "src/dsp/lossless_common.h"
7  #include "src/dsp/dsp.h"
8  #include "src/utils/color_cache_utils.h"
9  #include "src/utils/utils.h"
10  #define MIN_BLOCK_SIZE 256  
11  #define MAX_ENTROPY    (1e30f)
12  #define WINDOW_SIZE ((1 << WINDOW_SIZE_BITS) - 120)
13  #define MIN_LENGTH 4
14  static const uint8_t plane_to_code_lut[128] = {
15   96,   73,  55,  39,  23,  13,   5,  1,  255, 255, 255, 255, 255, 255, 255, 255,
16   101,  78,  58,  42,  26,  16,   8,  2,    0,   3,  9,   17,  27,  43,  59,  79,
17   102,  86,  62,  46,  32,  20,  10,  6,    4,   7,  11,  21,  33,  47,  63,  87,
18   105,  90,  70,  52,  37,  28,  18,  14,  12,  15,  19,  29,  38,  53,  71,  91,
19   110,  99,  82,  66,  48,  35,  30,  24,  22,  25,  31,  36,  49,  67,  83, 100,
20   115, 108,  94,  76,  64,  50,  44,  40,  34,  41,  45,  51,  65,  77,  95, 109,
21   118, 113, 103,  92,  80,  68,  60,  56,  54,  57,  61,  69,  81,  93, 104, 114,
22   119, 116, 111, 106,  97,  88,  84,  74,  72,  75,  85,  89,  98, 107, 112, 117
23  };
24  extern int VP8LDistanceToPlaneCode(int xsize, int dist);
25  int VP8LDistanceToPlaneCode(int xsize, int dist) {
26    const int yoffset = dist / xsize;
27    const int xoffset = dist - yoffset * xsize;
28    if (xoffset <= 8 && yoffset < 8) {
29      return plane_to_code_lut[yoffset * 16 + 8 - xoffset] + 1;
30    } else if (xoffset > xsize - 8 && yoffset < 7) {
31      return plane_to_code_lut[(yoffset + 1) * 16 + 8 + (xsize - xoffset)] + 1;
32    }
33    return dist + 120;
34  }
35  static WEBP_INLINE int FindMatchLength(const uint32_t* const array1,
36                                         const uint32_t* const array2,
37                                         int best_len_match, int max_limit) {
38    if (array1[best_len_match] != array2[best_len_match]) return 0;
39    return VP8LVectorMismatch(array1, array2, max_limit);
40  }
41  struct PixOrCopyBlock {
42    PixOrCopyBlock* next_;   
43    PixOrCopy* start_;       
44    int size_;               
45  };
46  extern void VP8LClearBackwardRefs(VP8LBackwardRefs* const refs);
47  void VP8LClearBackwardRefs(VP8LBackwardRefs* const refs) {
48    assert(refs != NULL);
49    if (refs->tail_ != NULL) {
50      *refs->tail_ = refs->free_blocks_;  
51    }
52    refs->free_blocks_ = refs->refs_;
53    refs->tail_ = &refs->refs_;
54    refs->last_block_ = NULL;
55    refs->refs_ = NULL;
56  }
57  void VP8LBackwardRefsClear(VP8LBackwardRefs* const refs) {
58    assert(refs != NULL);
59    VP8LClearBackwardRefs(refs);
60    while (refs->free_blocks_ != NULL) {
61      PixOrCopyBlock* const next = refs->free_blocks_->next_;
62      WebPSafeFree(refs->free_blocks_);
63      refs->free_blocks_ = next;
64    }
65  }
66  void VP8LBackwardRefsInit(VP8LBackwardRefs* const refs, int block_size) {
67    assert(refs != NULL);
68    memset(refs, 0, sizeof(*refs));
69    refs->tail_ = &refs->refs_;
70    refs->block_size_ =
71        (block_size < MIN_BLOCK_SIZE) ? MIN_BLOCK_SIZE : block_size;
72  }
73  VP8LRefsCursor VP8LRefsCursorInit(const VP8LBackwardRefs* const refs) {
74    VP8LRefsCursor c;
75    c.cur_block_ = refs->refs_;
76    if (refs->refs_ != NULL) {
77      c.cur_pos = c.cur_block_->start_;
78      c.last_pos_ = c.cur_pos + c.cur_block_->size_;
79    } else {
80      c.cur_pos = NULL;
81      c.last_pos_ = NULL;
82    }
83    return c;
84  }
85  void VP8LRefsCursorNextBlock(VP8LRefsCursor* const c) {
86    PixOrCopyBlock* const b = c->cur_block_->next_;
87    c->cur_pos = (b == NULL) ? NULL : b->start_;
88    c->last_pos_ = (b == NULL) ? NULL : b->start_ + b->size_;
89    c->cur_block_ = b;
90  }
91  static PixOrCopyBlock* BackwardRefsNewBlock(VP8LBackwardRefs* const refs) {
92    PixOrCopyBlock* b = refs->free_blocks_;
93    if (b == NULL) {   
94      const size_t total_size =
95          sizeof(*b) + refs->block_size_ * sizeof(*b->start_);
96      b = (PixOrCopyBlock*)WebPSafeMalloc(1ULL, total_size);
97      if (b == NULL) {
98        refs->error_ |= 1;
99        return NULL;
100      }
101      b->start_ = (PixOrCopy*)((uint8_t*)b + sizeof(*b));  
102    } else {  
103      refs->free_blocks_ = b->next_;
104    }
105    *refs->tail_ = b;
106    refs->tail_ = &b->next_;
107    refs->last_block_ = b;
108    b->next_ = NULL;
109    b->size_ = 0;
110    return b;
111  }
112  extern void VP8LBackwardRefsCursorAdd(VP8LBackwardRefs* const refs,
113                                        const PixOrCopy v);
114  void VP8LBackwardRefsCursorAdd(VP8LBackwardRefs* const refs,
115                                 const PixOrCopy v) {
116    PixOrCopyBlock* b = refs->last_block_;
117    if (b == NULL || b->size_ == refs->block_size_) {
118      b = BackwardRefsNewBlock(refs);
119      if (b == NULL) return;   
120    }
121    b->start_[b->size_++] = v;
122  }
123  int VP8LHashChainInit(VP8LHashChain* const p, int size) {
124    assert(p->size_ == 0);
125    assert(p->offset_length_ == NULL);
126    assert(size > 0);
127    p->offset_length_ =
128        (uint32_t*)WebPSafeMalloc(size, sizeof(*p->offset_length_));
129    if (p->offset_length_ == NULL) return 0;
130    p->size_ = size;
131    return 1;
132  }
133  void VP8LHashChainClear(VP8LHashChain* const p) {
134    assert(p != NULL);
135    WebPSafeFree(p->offset_length_);
136    p->size_ = 0;
137    p->offset_length_ = NULL;
138  }
139  static const uint32_t kHashMultiplierHi = 0xc6a4a793u;
140  static const uint32_t kHashMultiplierLo = 0x5bd1e996u;
141  static WEBP_UBSAN_IGNORE_UNSIGNED_OVERFLOW WEBP_INLINE
142  uint32_t GetPixPairHash64(const uint32_t* const argb) {
143    uint32_t key;
144    key  = argb[1] * kHashMultiplierHi;
145    key += argb[0] * kHashMultiplierLo;
146    key = key >> (32 - HASH_BITS);
147    return key;
148  }
149  static int GetMaxItersForQuality(int quality) {
150    return 8 + (quality * quality) / 128;
151  }
152  static int GetWindowSizeForHashChain(int quality, int xsize) {
153    const int max_window_size = (quality > 75) ? WINDOW_SIZE
154                              : (quality > 50) ? (xsize << 8)
155                              : (quality > 25) ? (xsize << 6)
156                              : (xsize << 4);
157    assert(xsize > 0);
158    return (max_window_size > WINDOW_SIZE) ? WINDOW_SIZE : max_window_size;
159  }
160  static WEBP_INLINE int MaxFindCopyLength(int len) {
161    return (len < MAX_LENGTH) ? len : MAX_LENGTH;
162  }
163  int VP8LHashChainFill(VP8LHashChain* const p, int quality,
164                        const uint32_t* const argb, int xsize, int ysize,
165                        int low_effort) {
166    const int size = xsize * ysize;
167    const int iter_max = GetMaxItersForQuality(quality);
168    const uint32_t window_size = GetWindowSizeForHashChain(quality, xsize);
169    int pos;
170    int argb_comp;
171    uint32_t base_position;
172    int32_t* hash_to_first_index;
173    int32_t* chain = (int32_t*)p->offset_length_;
174    assert(size > 0);
175    assert(p->size_ != 0);
176    assert(p->offset_length_ != NULL);
177    if (size <= 2) {
178      p->offset_length_[0] = p->offset_length_[size - 1] = 0;
179      return 1;
180    }
181    hash_to_first_index =
182        (int32_t*)WebPSafeMalloc(HASH_SIZE, sizeof(*hash_to_first_index));
183    if (hash_to_first_index == NULL) return 0;
184    memset(hash_to_first_index, 0xff, HASH_SIZE * sizeof(*hash_to_first_index));
185    argb_comp = (argb[0] == argb[1]);
186    for (pos = 0; pos < size - 2;) {
187      uint32_t hash_code;
188      const int argb_comp_next = (argb[pos + 1] == argb[pos + 2]);
189      if (argb_comp && argb_comp_next) {
190        uint32_t tmp[2];
191        uint32_t len = 1;
192        tmp[0] = argb[pos];
193        while (pos + (int)len + 2 < size && argb[pos + len + 2] == argb[pos]) {
194          ++len;
195        }
196        if (len > MAX_LENGTH) {
197          memset(chain + pos, 0xff, (len - MAX_LENGTH) * sizeof(*chain));
198          pos += len - MAX_LENGTH;
199          len = MAX_LENGTH;
200        }
201        while (len) {
202          tmp[1] = len--;
203          hash_code = GetPixPairHash64(tmp);
204          chain[pos] = hash_to_first_index[hash_code];
205          hash_to_first_index[hash_code] = pos++;
206        }
207        argb_comp = 0;
208      } else {
209        hash_code = GetPixPairHash64(argb + pos);
210        chain[pos] = hash_to_first_index[hash_code];
211        hash_to_first_index[hash_code] = pos++;
212        argb_comp = argb_comp_next;
213      }
214    }
215    chain[pos] = hash_to_first_index[GetPixPairHash64(argb + pos)];
216    WebPSafeFree(hash_to_first_index);
217    assert(size > 2);
218    p->offset_length_[0] = p->offset_length_[size - 1] = 0;
219    for (base_position = size - 2; base_position > 0;) {
220      const int max_len = MaxFindCopyLength(size - 1 - base_position);
221      const uint32_t* const argb_start = argb + base_position;
222      int iter = iter_max;
223      int best_length = 0;
224      uint32_t best_distance = 0;
225      uint32_t best_argb;
226      const int min_pos =
227          (base_position > window_size) ? base_position - window_size : 0;
228      const int length_max = (max_len < 256) ? max_len : 256;
229      uint32_t max_base_position;
230      pos = chain[base_position];
231      if (!low_effort) {
232        int curr_length;
233        if (base_position >= (uint32_t)xsize) {
234          curr_length = FindMatchLength(argb_start - xsize, argb_start,
235                                        best_length, max_len);
236          if (curr_length > best_length) {
237            best_length = curr_length;
238            best_distance = xsize;
239          }
240          --iter;
241        }
242        curr_length =
243            FindMatchLength(argb_start - 1, argb_start, best_length, max_len);
244        if (curr_length > best_length) {
245          best_length = curr_length;
246          best_distance = 1;
247        }
248        --iter;
249        if (best_length == MAX_LENGTH) pos = min_pos - 1;
250      }
251      best_argb = argb_start[best_length];
252      for (; pos >= min_pos && --iter; pos = chain[pos]) {
253        int curr_length;
254        assert(base_position > (uint32_t)pos);
255        if (argb[pos + best_length] != best_argb) continue;
256        curr_length = VP8LVectorMismatch(argb + pos, argb_start, max_len);
257        if (best_length < curr_length) {
258          best_length = curr_length;
259          best_distance = base_position - pos;
260          best_argb = argb_start[best_length];
261          if (best_length >= length_max) break;
262        }
263      }
264      max_base_position = base_position;
265      while (1) {
266        assert(best_length <= MAX_LENGTH);
267        assert(best_distance <= WINDOW_SIZE);
268        p->offset_length_[base_position] =
269            (best_distance << MAX_LENGTH_BITS) | (uint32_t)best_length;
270        --base_position;
271        if (best_distance == 0 || base_position == 0) break;
272        if (base_position < best_distance ||
273            argb[base_position - best_distance] != argb[base_position]) {
274          break;
275        }
276        if (best_length == MAX_LENGTH && best_distance != 1 &&
277            base_position + MAX_LENGTH < max_base_position) {
278          break;
279        }
280        if (best_length < MAX_LENGTH) {
281          ++best_length;
282          max_base_position = base_position;
283        }
284      }
285    }
286    return 1;
287  }
288  static WEBP_INLINE void AddSingleLiteral(uint32_t pixel, int use_color_cache,
289                                           VP8LColorCache* const hashers,
290                                           VP8LBackwardRefs* const refs) {
291    PixOrCopy v;
292    if (use_color_cache) {
293      const uint32_t key = VP8LColorCacheGetIndex(hashers, pixel);
294      if (VP8LColorCacheLookup(hashers, key) == pixel) {
295        v = PixOrCopyCreateCacheIdx(key);
296      } else {
297        v = PixOrCopyCreateLiteral(pixel);
298        VP8LColorCacheSet(hashers, key, pixel);
299      }
300    } else {
301      v = PixOrCopyCreateLiteral(pixel);
302    }
303    VP8LBackwardRefsCursorAdd(refs, v);
304  }
305  static int BackwardReferencesRle(int xsize, int ysize,
306                                   const uint32_t* const argb,
307                                   int cache_bits, VP8LBackwardRefs* const refs) {
308    const int pix_count = xsize * ysize;
309    int i, k;
310    const int use_color_cache = (cache_bits > 0);
311    VP8LColorCache hashers;
312    if (use_color_cache && !VP8LColorCacheInit(&hashers, cache_bits)) {
313      return 0;
314    }
315    VP8LClearBackwardRefs(refs);
316    AddSingleLiteral(argb[0], use_color_cache, &hashers, refs);
317    i = 1;
318    while (i < pix_count) {
319      const int max_len = MaxFindCopyLength(pix_count - i);
320      const int rle_len = FindMatchLength(argb + i, argb + i - 1, 0, max_len);
321      const int prev_row_len = (i < xsize) ? 0 :
322          FindMatchLength(argb + i, argb + i - xsize, 0, max_len);
323      if (rle_len >= prev_row_len && rle_len >= MIN_LENGTH) {
324        VP8LBackwardRefsCursorAdd(refs, PixOrCopyCreateCopy(1, rle_len));
325        i += rle_len;
326      } else if (prev_row_len >= MIN_LENGTH) {
327        VP8LBackwardRefsCursorAdd(refs, PixOrCopyCreateCopy(xsize, prev_row_len));
328        if (use_color_cache) {
329          for (k = 0; k < prev_row_len; ++k) {
330            VP8LColorCacheInsert(&hashers, argb[i + k]);
331          }
332        }
333        i += prev_row_len;
334      } else {
335        AddSingleLiteral(argb[i], use_color_cache, &hashers, refs);
336        i++;
337      }
338    }
339    if (use_color_cache) VP8LColorCacheClear(&hashers);
340    return !refs->error_;
341  }
342  static int BackwardReferencesLz77(int xsize, int ysize,
343                                    const uint32_t* const argb, int cache_bits,
344                                    const VP8LHashChain* const hash_chain,
345                                    VP8LBackwardRefs* const refs) {
346    int i;
347    int i_last_check = -1;
348    int ok = 0;
349    int cc_init = 0;
350    const int use_color_cache = (cache_bits > 0);
351    const int pix_count = xsize * ysize;
352    VP8LColorCache hashers;
353    if (use_color_cache) {
354      cc_init = VP8LColorCacheInit(&hashers, cache_bits);
355      if (!cc_init) goto Error;
356    }
357    VP8LClearBackwardRefs(refs);
358    for (i = 0; i < pix_count;) {
359      int offset = 0;
360      int len = 0;
361      int j;
362      VP8LHashChainFindCopy(hash_chain, i, &offset, &len);
363      if (len >= MIN_LENGTH) {
364        const int len_ini = len;
365        int max_reach = 0;
366        const int j_max =
367            (i + len_ini >= pix_count) ? pix_count - 1 : i + len_ini;
368        i_last_check = (i > i_last_check) ? i : i_last_check;
369        for (j = i_last_check + 1; j <= j_max; ++j) {
370          const int len_j = VP8LHashChainFindLength(hash_chain, j);
371          const int reach =
372              j + (len_j >= MIN_LENGTH ? len_j : 1);  
373          if (reach > max_reach) {
374            len = j - i;
375            max_reach = reach;
376            if (max_reach >= pix_count) break;
377          }
378        }
379      } else {
380        len = 1;
381      }
382      assert(len > 0);
383      if (len == 1) {
384        AddSingleLiteral(argb[i], use_color_cache, &hashers, refs);
385      } else {
386        VP8LBackwardRefsCursorAdd(refs, PixOrCopyCreateCopy(offset, len));
387        if (use_color_cache) {
388          for (j = i; j < i + len; ++j) VP8LColorCacheInsert(&hashers, argb[j]);
389        }
390      }
391      i += len;
392    }
393    ok = !refs->error_;
394   Error:
395    if (cc_init) VP8LColorCacheClear(&hashers);
396    return ok;
397  }
398  #define WINDOW_OFFSETS_SIZE_MAX 32
399  static int BackwardReferencesLz77Box(int xsize, int ysize,
400                                       const uint32_t* const argb, int cache_bits,
401                                       const VP8LHashChain* const hash_chain_best,
402                                       VP8LHashChain* hash_chain,
403                                       VP8LBackwardRefs* const refs) {
404    int i;
405    const int pix_count = xsize * ysize;
406    uint16_t* counts;
407    int window_offsets[WINDOW_OFFSETS_SIZE_MAX] = {0};
408    int window_offsets_new[WINDOW_OFFSETS_SIZE_MAX] = {0};
409    int window_offsets_size = 0;
410    int window_offsets_new_size = 0;
411    uint16_t* const counts_ini =
412        (uint16_t*)WebPSafeMalloc(xsize * ysize, sizeof(*counts_ini));
413    int best_offset_prev = -1, best_length_prev = -1;
414    if (counts_ini == NULL) return 0;
415    i = pix_count - 2;
416    counts = counts_ini + i;
417    counts[1] = 1;
418    for (; i >= 0; --i, --counts) {
419      if (argb[i] == argb[i + 1]) {
420        counts[0] = counts[1] + (counts[1] != MAX_LENGTH);
421      } else {
422        counts[0] = 1;
423      }
424    }
425    {
426      int x, y;
427      for (y = 0; y <= 6; ++y) {
428        for (x = -6; x <= 6; ++x) {
429          const int offset = y * xsize + x;
430          int plane_code;
431          if (offset <= 0) continue;
432          plane_code = VP8LDistanceToPlaneCode(xsize, offset) - 1;
433          if (plane_code >= WINDOW_OFFSETS_SIZE_MAX) continue;
434          window_offsets[plane_code] = offset;
435        }
436      }
437      for (i = 0; i < WINDOW_OFFSETS_SIZE_MAX; ++i) {
438        if (window_offsets[i] == 0) continue;
439        window_offsets[window_offsets_size++] = window_offsets[i];
440      }
441      for (i = 0; i < window_offsets_size; ++i) {
442        int j;
443        int is_reachable = 0;
444        for (j = 0; j < window_offsets_size && !is_reachable; ++j) {
445          is_reachable |= (window_offsets[i] == window_offsets[j] + 1);
446        }
447        if (!is_reachable) {
448          window_offsets_new[window_offsets_new_size] = window_offsets[i];
449          ++window_offsets_new_size;
450        }
451      }
452    }
453    hash_chain->offset_length_[0] = 0;
454    for (i = 1; i < pix_count; ++i) {
455      int ind;
456      int best_length = VP8LHashChainFindLength(hash_chain_best, i);
457      int best_offset;
458      int do_compute = 1;
459      if (best_length >= MAX_LENGTH) {
460        best_offset = VP8LHashChainFindOffset(hash_chain_best, i);
461        for (ind = 0; ind < window_offsets_size; ++ind) {
462          if (best_offset == window_offsets[ind]) {
463            do_compute = 0;
464            break;
465          }
466        }
467      }
468      if (do_compute) {
469        const int use_prev =
470            (best_length_prev > 1) && (best_length_prev < MAX_LENGTH);
471        const int num_ind =
472            use_prev ? window_offsets_new_size : window_offsets_size;
473        best_length = use_prev ? best_length_prev - 1 : 0;
474        best_offset = use_prev ? best_offset_prev : 0;
475        for (ind = 0; ind < num_ind; ++ind) {
476          int curr_length = 0;
477          int j = i;
478          int j_offset =
479              use_prev ? i - window_offsets_new[ind] : i - window_offsets[ind];
480          if (j_offset < 0 || argb[j_offset] != argb[i]) continue;
481          do {
482            const int counts_j_offset = counts_ini[j_offset];
483            const int counts_j = counts_ini[j];
484            if (counts_j_offset != counts_j) {
485              curr_length +=
486                  (counts_j_offset < counts_j) ? counts_j_offset : counts_j;
487              break;
488            }
489            curr_length += counts_j_offset;
490            j_offset += counts_j_offset;
491            j += counts_j_offset;
492          } while (curr_length <= MAX_LENGTH && j < pix_count &&
493                   argb[j_offset] == argb[j]);
494          if (best_length < curr_length) {
495            best_offset =
496                use_prev ? window_offsets_new[ind] : window_offsets[ind];
497            if (curr_length >= MAX_LENGTH) {
498              best_length = MAX_LENGTH;
499              break;
500            } else {
501              best_length = curr_length;
502            }
503          }
504        }
505      }
506      assert(i + best_length <= pix_count);
507      assert(best_length <= MAX_LENGTH);
508      if (best_length <= MIN_LENGTH) {
509        hash_chain->offset_length_[i] = 0;
510        best_offset_prev = 0;
511        best_length_prev = 0;
512      } else {
513        hash_chain->offset_length_[i] =
514            (best_offset << MAX_LENGTH_BITS) | (uint32_t)best_length;
515        best_offset_prev = best_offset;
516        best_length_prev = best_length;
517      }
518    }
519    hash_chain->offset_length_[0] = 0;
520    WebPSafeFree(counts_ini);
521    return BackwardReferencesLz77(xsize, ysize, argb, cache_bits, hash_chain,
522                                  refs);
523  }
524  static void BackwardReferences2DLocality(int xsize,
525                                           const VP8LBackwardRefs* const refs) {
526    VP8LRefsCursor c = VP8LRefsCursorInit(refs);
527    while (VP8LRefsCursorOk(&c)) {
528      if (PixOrCopyIsCopy(c.cur_pos)) {
529        const int dist = c.cur_pos->argb_or_distance;
530        const int transformed_dist = VP8LDistanceToPlaneCode(xsize, dist);
531        c.cur_pos->argb_or_distance = transformed_dist;
532      }
533      VP8LRefsCursorNext(&c);
534    }
535  }
536  static int CalculateBestCacheSize(const uint32_t* argb, int quality,
537                                    const VP8LBackwardRefs* const refs,
538                                    int* const best_cache_bits) {
539    int i;
540    const int cache_bits_max = (quality <= 25) ? 0 : *best_cache_bits;
541    double entropy_min = MAX_ENTROPY;
542    int cc_init[MAX_COLOR_CACHE_BITS + 1] = { 0 };
543    VP8LColorCache hashers[MAX_COLOR_CACHE_BITS + 1];
544    VP8LRefsCursor c = VP8LRefsCursorInit(refs);
545    VP8LHistogram* histos[MAX_COLOR_CACHE_BITS + 1] = { NULL };
546    int ok = 0;
547    assert(cache_bits_max >= 0 && cache_bits_max <= MAX_COLOR_CACHE_BITS);
548    if (cache_bits_max == 0) {
549      *best_cache_bits = 0;
550      return 1;
551    }
552    for (i = 0; i <= cache_bits_max; ++i) {
553      histos[i] = VP8LAllocateHistogram(i);
554      if (histos[i] == NULL) goto Error;
555      VP8LHistogramInit(histos[i], i, &bsol;*init_arrays=*/ 1);
556      if (i == 0) continue;
557      cc_init[i] = VP8LColorCacheInit(&hashers[i], i);
558      if (!cc_init[i]) goto Error;
559    }
560    while (VP8LRefsCursorOk(&c)) {
561      const PixOrCopy* const v = c.cur_pos;
562      if (PixOrCopyIsLiteral(v)) {
563        const uint32_t pix = *argb++;
564        const uint32_t a = (pix >> 24) & 0xff;
565        const uint32_t r = (pix >> 16) & 0xff;
566        const uint32_t g = (pix >>  8) & 0xff;
567        const uint32_t b = (pix >>  0) & 0xff;
568        int key = VP8LHashPix(pix, 32 - cache_bits_max);
569        ++histos[0]->blue_[b];
570        ++histos[0]->literal_[g];
571        ++histos[0]->red_[r];
572        ++histos[0]->alpha_[a];
573        for (i = cache_bits_max; i >= 1; --i, key >>= 1) {
574          if (VP8LColorCacheLookup(&hashers[i], key) == pix) {
575            ++histos[i]->literal_[NUM_LITERAL_CODES + NUM_LENGTH_CODES + key];
576          } else {
577            VP8LColorCacheSet(&hashers[i], key, pix);
578            ++histos[i]->blue_[b];
579            ++histos[i]->literal_[g];
580            ++histos[i]->red_[r];
581            ++histos[i]->alpha_[a];
582          }
583        }
584      } else {
585        int len = PixOrCopyLength(v);
586        uint32_t argb_prev = *argb ^ 0xffffffffu;
587        do {
588          if (*argb != argb_prev) {
589            int key = VP8LHashPix(*argb, 32 - cache_bits_max);
590            for (i = cache_bits_max; i >= 1; --i, key >>= 1) {
591              hashers[i].colors_[key] = *argb;
592            }
593            argb_prev = *argb;
594          }
595          argb++;
596        } while (--len != 0);
597      }
598      VP8LRefsCursorNext(&c);
599    }
600    for (i = 0; i <= cache_bits_max; ++i) {
601      const double entropy = VP8LHistogramEstimateBits(histos[i]);
602      if (i == 0 || entropy < entropy_min) {
603        entropy_min = entropy;
604        *best_cache_bits = i;
605      }
606    }
607    ok = 1;
608  Error:
609    for (i = 0; i <= cache_bits_max; ++i) {
610      if (cc_init[i]) VP8LColorCacheClear(&hashers[i]);
611      VP8LFreeHistogram(histos[i]);
612    }
613    return ok;
614  }
615  static int BackwardRefsWithLocalCache(const uint32_t* const argb,
616                                        int cache_bits,
617                                        VP8LBackwardRefs* const refs) {
618    int pixel_index = 0;
619    VP8LColorCache hashers;
620    VP8LRefsCursor c = VP8LRefsCursorInit(refs);
621    if (!VP8LColorCacheInit(&hashers, cache_bits)) return 0;
622    while (VP8LRefsCursorOk(&c)) {
623      PixOrCopy* const v = c.cur_pos;
624      if (PixOrCopyIsLiteral(v)) {
625        const uint32_t argb_literal = v->argb_or_distance;
626        const int ix = VP8LColorCacheContains(&hashers, argb_literal);
627        if (ix >= 0) {
628          *v = PixOrCopyCreateCacheIdx(ix);
629        } else {
630          VP8LColorCacheInsert(&hashers, argb_literal);
631        }
632        ++pixel_index;
633      } else {
634        int k;
635        assert(PixOrCopyIsCopy(v));
636        for (k = 0; k < v->len; ++k) {
637          VP8LColorCacheInsert(&hashers, argb[pixel_index++]);
638        }
639      }
640      VP8LRefsCursorNext(&c);
641    }
642    VP8LColorCacheClear(&hashers);
643    return 1;
644  }
645  static VP8LBackwardRefs* GetBackwardReferencesLowEffort(
646      int width, int height, const uint32_t* const argb,
647      int* const cache_bits, const VP8LHashChain* const hash_chain,
648      VP8LBackwardRefs* const refs_lz77) {
649    *cache_bits = 0;
650    if (!BackwardReferencesLz77(width, height, argb, 0, hash_chain, refs_lz77)) {
651      return NULL;
652    }
653    BackwardReferences2DLocality(width, refs_lz77);
654    return refs_lz77;
655  }
656  extern int VP8LBackwardReferencesTraceBackwards(
657      int xsize, int ysize, const uint32_t* const argb, int cache_bits,
658      const VP8LHashChain* const hash_chain,
659      const VP8LBackwardRefs* const refs_src, VP8LBackwardRefs* const refs_dst);
660  static VP8LBackwardRefs* GetBackwardReferences(
661      int width, int height, const uint32_t* const argb, int quality,
662      int lz77_types_to_try, int* const cache_bits,
663      const VP8LHashChain* const hash_chain, VP8LBackwardRefs* best,
664      VP8LBackwardRefs* worst) {
665    const int cache_bits_initial = *cache_bits;
666    double bit_cost_best = -1;
667    VP8LHistogram* histo = NULL;
668    int lz77_type, lz77_type_best = 0;
669    VP8LHashChain hash_chain_box;
670    memset(&hash_chain_box, 0, sizeof(hash_chain_box));
671    histo = VP8LAllocateHistogram(MAX_COLOR_CACHE_BITS);
672    if (histo == NULL) goto Error;
673    for (lz77_type = 1; lz77_types_to_try;
674         lz77_types_to_try &= ~lz77_type, lz77_type <<= 1) {
675      int res = 0;
676      double bit_cost;
677      int cache_bits_tmp = cache_bits_initial;
678      if ((lz77_types_to_try & lz77_type) == 0) continue;
679      switch (lz77_type) {
680        case kLZ77RLE:
<span onclick='openModal()' class='match'>681          res = BackwardReferencesRle(width, height, argb, 0, worst);
682          break;
</span>683        case kLZ77Standard:
684          res = BackwardReferencesLz77(width, height, argb, 0, hash_chain, worst);
685          break;
686        case kLZ77Box:
687          if (!VP8LHashChainInit(&hash_chain_box, width * height)) goto Error;
688          res = BackwardReferencesLz77Box(width, height, argb, 0, hash_chain,
689                                          &hash_chain_box, worst);
690          break;
691        default:
692          assert(0);
693      }
694      if (!res) goto Error;
695      if (!CalculateBestCacheSize(argb, quality, worst, &cache_bits_tmp)) {
696        goto Error;
697      }
698      if (cache_bits_tmp > 0) {
699        if (!BackwardRefsWithLocalCache(argb, cache_bits_tmp, worst)) {
700          goto Error;
701        }
702      }
703      VP8LHistogramCreate(histo, worst, cache_bits_tmp);
704      bit_cost = VP8LHistogramEstimateBits(histo);
705      if (lz77_type_best == 0 || bit_cost < bit_cost_best) {
706        VP8LBackwardRefs* const tmp = worst;
707        worst = best;
708        best = tmp;
709        bit_cost_best = bit_cost;
710        *cache_bits = cache_bits_tmp;
711        lz77_type_best = lz77_type;
712      }
713    }
714    assert(lz77_type_best > 0);
715    if ((lz77_type_best == kLZ77Standard || lz77_type_best == kLZ77Box) &&
716        quality >= 25) {
717      const VP8LHashChain* const hash_chain_tmp =
718          (lz77_type_best == kLZ77Standard) ? hash_chain : &hash_chain_box;
719      if (VP8LBackwardReferencesTraceBackwards(width, height, argb, *cache_bits,
720                                               hash_chain_tmp, best, worst)) {
721        double bit_cost_trace;
722        VP8LHistogramCreate(histo, worst, *cache_bits);
723        bit_cost_trace = VP8LHistogramEstimateBits(histo);
724        if (bit_cost_trace < bit_cost_best) best = worst;
725      }
726    }
727    BackwardReferences2DLocality(width, best);
728  Error:
729    VP8LHashChainClear(&hash_chain_box);
730    VP8LFreeHistogram(histo);
731    return best;
732  }
733  VP8LBackwardRefs* VP8LGetBackwardReferences(
734      int width, int height, const uint32_t* const argb, int quality,
735      int low_effort, int lz77_types_to_try, int* const cache_bits,
736      const VP8LHashChain* const hash_chain, VP8LBackwardRefs* const refs_tmp1,
737      VP8LBackwardRefs* const refs_tmp2) {
738    if (low_effort) {
739      return GetBackwardReferencesLowEffort(width, height, argb, cache_bits,
740                                            hash_chain, refs_tmp1);
741    } else {
742      return GetBackwardReferences(width, height, argb, quality,
743                                   lz77_types_to_try, cache_bits, hash_chain,
744                                   refs_tmp1, refs_tmp2);
745    }
746  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from PINRemoteImage-MDEwOlJlcG9zaXRvcnkzOTUzNzEwMw==-flat-img2webp.c</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from PINRemoteImage-MDEwOlJlcG9zaXRvcnkzOTUzNzEwMw==-flat-backward_references_enc.c</div>
                </div>
                <div class="column column_space"><pre><code>56    ok = reader(data, data_size, pic, 1, NULL);
57    free((void*)data);
</pre></code></div>
                <div class="column column_space"><pre><code>681          res = BackwardReferencesRle(width, height, argb, 0, worst);
682          break;
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    