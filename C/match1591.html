<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML><HEAD><TITLE>Matches for vipsload.c & ppmload.c</TITLE>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
</HEAD>
<body>
  <div style="align-items: center; display: flex; justify-content: space-around;">
    <div>
      <h3 align="center">
Matches for vipsload.c & ppmload.c
      </h3>
      <h1 align="center">
        27.8%
      </h1>
      <center>
        <a href="index.html" target="_top">
          INDEX
        </a>
        <span>-</span>
        <a href="help-en.html" target="_top">
          HELP
        </a>
      </center>
    </div>
    <div>
<TABLE BORDER="1" CELLSPACING="0" BGCOLOR="#d0d0d0">
<TR><TH><TH>vipsload.c (52.70936%)<TH>ppmload.c (18.938053%)<TH>Tokens
<TR><TD BGCOLOR="#0000ff"><FONT COLOR="#0000ff">-</FONT><TD><A HREF="javascript:ZweiFrames('match1591-0.html#0',2,'match1591-1.html#0',3)" NAME="0">(226-280)<TD><A HREF="javascript:ZweiFrames('match1591-0.html#0',2,'match1591-1.html#0',3)" NAME="0">(814-866)</A><TD ALIGN=center><FONT COLOR="#ff0000">32</FONT>
<TR><TD BGCOLOR="#f63526"><FONT COLOR="#f63526">-</FONT><TD><A HREF="javascript:ZweiFrames('match1591-0.html#1',2,'match1591-1.html#1',3)" NAME="1">(298-367)<TD><A HREF="javascript:ZweiFrames('match1591-0.html#1',2,'match1591-1.html#1',3)" NAME="1">(873-957)</A><TD ALIGN=center><FONT COLOR="#d70000">27</FONT>
<TR><TD BGCOLOR="#980517"><FONT COLOR="#980517">-</FONT><TD><A HREF="javascript:ZweiFrames('match1591-0.html#2',2,'match1591-1.html#2',3)" NAME="2">(147-171)<TD><A HREF="javascript:ZweiFrames('match1591-0.html#2',2,'match1591-1.html#2',3)" NAME="2">(727-750)</A><TD ALIGN=center><FONT COLOR="#af0000">22</FONT>
<TR><TD BGCOLOR="#53858b"><FONT COLOR="#53858b">-</FONT><TD><A HREF="javascript:ZweiFrames('match1591-0.html#3',2,'match1591-1.html#3',3)" NAME="3">(96-113)<TD><A HREF="javascript:ZweiFrames('match1591-0.html#3',2,'match1591-1.html#3',3)" NAME="3">(776-793)</A><TD ALIGN=center><FONT COLOR="#6f0000">14</FONT>
<TR><TD BGCOLOR="#6cc417"><FONT COLOR="#6cc417">-</FONT><TD><A HREF="javascript:ZweiFrames('match1591-0.html#4',2,'match1591-1.html#4',3)" NAME="4">(214-222)<TD><A HREF="javascript:ZweiFrames('match1591-0.html#4',2,'match1591-1.html#4',3)" NAME="4">(804-812)</A><TD ALIGN=center><FONT COLOR="#5f0000">12</FONT>
</TABLE>
    </div>
  </div>
  <hr>
  <div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>vipsload.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
/* load vips from a file
 *
 * 24/11/11
 */

/*

    This file is part of VIPS.
    
    VIPS is free software; you can redistribute it and/or modify
    it under the terms of the GNU Lesser General Public License as published by
    the Free Software Foundation; either version 2 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public License
    along with this program; if not, write to the Free Software
    Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
    02110-1301  USA

 */

/*

    These files are distributed with VIPS - http://www.vips.ecs.soton.ac.uk

 */

/*
#define DEBUG
 */

#ifdef HAVE_CONFIG_H
#include &lt;config.h&gt;
#endif /*HAVE_CONFIG_H*/
#include &lt;vips/intl.h&gt;

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

#include &lt;vips/vips.h&gt;
#include &lt;vips/internal.h&gt;

typedef struct _VipsForeignLoadVips {
	VipsForeignLoad parent_object;

	/* Source to load from (set by subclasses).
	 */
	VipsSource *source;

} VipsForeignLoadVips;

typedef VipsForeignLoadClass VipsForeignLoadVipsClass;

G_DEFINE_ABSTRACT_TYPE( VipsForeignLoadVips, vips_foreign_load_vips, 
	VIPS_TYPE_FOREIGN_LOAD );

static void
vips_foreign_load_vips_dispose( GObject *gobject )
{
	VipsForeignLoadVips *vips = (VipsForeignLoadVips *) gobject;

	VIPS_UNREF( vips-&gt;source );

	G_OBJECT_CLASS( vips_foreign_load_vips_parent_class )-&gt;
		dispose( gobject );
}

static VipsForeignFlags
vips_foreign_load_vips_get_flags_source( VipsSource *source )
{
	unsigned char *data;
	VipsForeignFlags flags;

	flags = VIPS_FOREIGN_PARTIAL;

	if( vips_source_sniff_at_most( source, &amp;data, 4 ) == 4 &amp;&amp;
		*((guint32 *) data) == VIPS_MAGIC_SPARC ) 
		flags |= VIPS_FOREIGN_BIGENDIAN;

	return( flags );
}

static VipsForeignFlags
vips_foreign_load_vips_get_flags( VipsForeignLoad *load )
{
	VipsForeignLoadVips *vips = (VipsForeignLoadVips *) load;

<A NAME="3"></A>	return( vips_foreign_load_vips_get_flags_source( vips-&gt;source ) );
}

<FONT color="#53858b"><A HREF="javascript:ZweiFrames('match1591-1.html#3',3,'match1591-top.html#3',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>static VipsForeignFlags
vips_foreign_load_vips_get_flags_filename( const char *filename )
{
	VipsSource *source;
	VipsForeignFlags flags;

	if( !(source = vips_source_new_from_file( filename )) )
		return( 0 );
	flags = vips_foreign_load_vips_get_flags_source( source );
	VIPS_UNREF( source );

	return( flags );
}

static int
vips_foreign_load_vips_header( VipsForeignLoad *load )
{
	VipsForeignLoadVips *vips = (VipsForeignLoadVips *) load;</B></FONT>

	const char *filename;
	VipsImage *image;
	VipsImage *x;

	if( (filename = 
		vips_connection_filename( VIPS_CONNECTION( vips-&gt;source ) )) ) {
		if( !(image = vips_image_new_mode( filename, &quot;r&quot; )) )
			return( -1 );
	}
	else {
		VipsObjectClass *class = VIPS_OBJECT_GET_CLASS( load );

		/* We could add load vips from memory, fd, via mmap etc. here.
		 * We should perhaps move iofuncs/vips.c into this file.
		 *
		 * For now, just fail unless there's a filename associated
		 * with this source.
		 */
		vips_error( class-&gt;nickname, 
			&quot;%s&quot;, _( &quot;no filename associated with source&quot; ) );
		return( -1 );
	}

	/* What a hack. Remove the @out that's there now and replace it with
	 * our image. 
	 */
	g_object_get( load, &quot;out&quot;, &amp;x, NULL );
	g_object_unref( x );
	g_object_unref( x );
<A NAME="2"></A>
	g_object_set( load, &quot;out&quot;, image, NULL );

<FONT color="#980517"><A HREF="javascript:ZweiFrames('match1591-1.html#2',3,'match1591-top.html#2',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>	return( 0 );
}

static void
vips_foreign_load_vips_class_init( VipsForeignLoadVipsClass *class )
{
	GObjectClass *gobject_class = G_OBJECT_CLASS( class );
	VipsObjectClass *object_class = (VipsObjectClass *) class;
	VipsForeignClass *foreign_class = (VipsForeignClass *) class;
	VipsForeignLoadClass *load_class = (VipsForeignLoadClass *) class;

	gobject_class-&gt;dispose = vips_foreign_load_vips_dispose;

	object_class-&gt;nickname = &quot;vipsload_base&quot;;
	object_class-&gt;description = _( &quot;load vips base class&quot; );

	/* We are fast at is_a(), so high priority.
	 */
	foreign_class-&gt;priority = 200;

	load_class-&gt;get_flags = vips_foreign_load_vips_get_flags;
	load_class-&gt;get_flags_filename = 
		vips_foreign_load_vips_get_flags_filename;
	load_class-&gt;header = vips_foreign_load_vips_header;
	load_class-&gt;load = NULL;</B></FONT>

}

static void
vips_foreign_load_vips_init( VipsForeignLoadVips *vips )
{
}

typedef struct _VipsForeignLoadVipsFile {
	VipsForeignLoadVips parent_object;

	char *filename;

} VipsForeignLoadVipsFile;

typedef VipsForeignLoadVipsClass VipsForeignLoadVipsFileClass;

G_DEFINE_TYPE( VipsForeignLoadVipsFile, vips_foreign_load_vips_file, 
	vips_foreign_load_vips_get_type() );

static int
vips_foreign_load_vips_file_build( VipsObject *object )
{
	VipsForeignLoadVips *vips = (VipsForeignLoadVips *) object;
	VipsForeignLoadVipsFile *file = (VipsForeignLoadVipsFile *) object;

	if( file-&gt;filename &amp;&amp;
		!(vips-&gt;source = vips_source_new_from_file( file-&gt;filename )) )
		return( -1 );

	if( VIPS_OBJECT_CLASS( vips_foreign_load_vips_file_parent_class )-&gt;
		build( object ) )
		return( -1 );

	return( 0 );
}

const char *vips__suffs[] = { &quot;.v&quot;, &quot;.vips&quot;, NULL };

<A NAME="4"></A>static gboolean
vips_foreign_load_vips_file_is_a( const char *filename )
{
<FONT color="#6cc417"><A HREF="javascript:ZweiFrames('match1591-1.html#4',3,'match1591-top.html#4',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>	return( vips__file_magic( filename ) );
}

static void
vips_foreign_load_vips_file_class_init( VipsForeignLoadVipsClass *class )
{
	GObjectClass *gobject_class = G_OBJECT_CLASS( class );
	VipsObjectClass *object_class = (VipsObjectClass *) class;
	VipsForeignClass *foreign_class = (VipsForeignClass *) class;</B></FONT>
<A NAME="0"></A>	VipsForeignLoadClass *load_class = (VipsForeignLoadClass *) class;

	gobject_class-&gt;set_property = vips_object_set_property;
<FONT color="#0000ff"><A HREF="javascript:ZweiFrames('match1591-1.html#0',3,'match1591-top.html#0',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>	gobject_class-&gt;get_property = vips_object_get_property;

	object_class-&gt;nickname = &quot;vipsload&quot;;
	object_class-&gt;description = _( &quot;load vips from file&quot; );
	object_class-&gt;build = vips_foreign_load_vips_file_build;

	foreign_class-&gt;suffs = vips__suffs;

	load_class-&gt;is_a = vips_foreign_load_vips_file_is_a;

	VIPS_ARG_STRING( class, &quot;filename&quot;, 1, 
		_( &quot;Filename&quot; ),
		_( &quot;Filename to load from&quot; ),
		VIPS_ARGUMENT_REQUIRED_INPUT, 
		G_STRUCT_OFFSET( VipsForeignLoadVipsFile, filename ),
		NULL );
}

static void
vips_foreign_load_vips_file_init( VipsForeignLoadVipsFile *file )
{
}

typedef struct _VipsForeignLoadVipsSource {
	VipsForeignLoadVips parent_object;

	VipsSource *source;

} VipsForeignLoadVipsSource;

typedef VipsForeignLoadVipsClass VipsForeignLoadVipsSourceClass;

G_DEFINE_TYPE( VipsForeignLoadVipsSource, vips_foreign_load_vips_source, 
	vips_foreign_load_vips_get_type() );

static int
vips_foreign_load_vips_source_build( VipsObject *object )
{
	VipsForeignLoadVips *vips = (VipsForeignLoadVips *) object;
	VipsForeignLoadVipsSource *source = 
		(VipsForeignLoadVipsSource *) object;

	if( source-&gt;source ) {
		vips-&gt;source = source-&gt;source;
		g_object_ref( vips-&gt;source );
	}

	if( VIPS_OBJECT_CLASS( vips_foreign_load_vips_source_parent_class )-&gt;
		build( object ) )
		return( -1 );

	return( 0 );
}

static gboolean</B></FONT>
vips_foreign_load_vips_source_is_a_source( VipsSource *source )
{
	const char *filename;

	return( (filename = 
		vips_connection_filename( VIPS_CONNECTION( source ) )) &amp;&amp;
		vips__file_magic( filename ) );
}

static void
vips_foreign_load_vips_source_class_init( VipsForeignLoadVipsClass *class )
{
	GObjectClass *gobject_class = G_OBJECT_CLASS( class );
	VipsObjectClass *object_class = (VipsObjectClass *) class;
<A NAME="1"></A>	VipsForeignLoadClass *load_class = (VipsForeignLoadClass *) class;

	gobject_class-&gt;set_property = vips_object_set_property;
<FONT color="#f63526"><A HREF="javascript:ZweiFrames('match1591-1.html#1',3,'match1591-top.html#1',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>	gobject_class-&gt;get_property = vips_object_get_property;

	object_class-&gt;nickname = &quot;vipsload_source&quot;;
	object_class-&gt;description = _( &quot;load vips from source&quot; );
	object_class-&gt;build = vips_foreign_load_vips_source_build;

	load_class-&gt;is_a_source = 
		vips_foreign_load_vips_source_is_a_source;

	VIPS_ARG_OBJECT( class, &quot;source&quot;, 1,
		_( &quot;Source&quot; ),
		_( &quot;Source to load from&quot; ),
		VIPS_ARGUMENT_REQUIRED_INPUT, 
		G_STRUCT_OFFSET( VipsForeignLoadVipsSource, source ),
		VIPS_TYPE_SOURCE );

}

static void
vips_foreign_load_vips_source_init( VipsForeignLoadVipsSource *source )
{
}

/**
 * vips_vipsload:
 * @filename: file to load
 * @out: (out): decompressed image
 * @...: %NULL-terminated list of optional named arguments
 *
 * Read in a vips image. 
 *
 * See also: vips_vipssave().
 *
 * Returns: 0 on success, -1 on error.
 */
int
vips_vipsload( const char *filename, VipsImage **out, ... )
{
	va_list ap;
	int result;

	va_start( ap, out );
	result = vips_call_split( &quot;vipsload&quot;, ap, filename, out );
	va_end( ap );

	return( result );
}

/**
 * vips_vipsload_source:
 * @source: source to load from
 * @out: (out): decompressed image
 * @...: %NULL-terminated list of optional named arguments
 *
 * Exactly as vips_vipsload(), but read from a source. 
 *
 * Returns: 0 on success, -1 on error.
 */
int
vips_vipsload_source( VipsSource *source, VipsImage **out, ... )
{
	va_list ap;
	int result;

	va_start( ap, out );
	result = vips_call_split( &quot;vipsload_source&quot;, ap, source, out );
	va_end( ap );

	return( result );
}</B></FONT>
</PRE>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>ppmload.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
/* load ppm from a file
 *
 * Stephen Chan ... original code
 *
 * 21/11/00 JC
 *	- hacked for VIPS
 *	- reads ppm/pgm/pbm
 *	- mmaps binary pgm/ppm
 *	- reads all ascii formats (slowly!)
 * 22/11/00 JC
 *	- oops, ascii read was broken
 *	- does 16/32 bit ascii now as well
 * 24/5/01
 *	- im_ppm2vips_header() added
 * 28/11/03 JC
 *	- better no-overshoot on tile loop
 * 22/5/04
 *	- does 16/32 bit binary too
 *	- tiny fix for missing file close on read error
 * 19/8/05
 * 	- use im_raw2vips() for binary read
 * 9/9/05
 * 	- tiny cleanups
 * 3/11/07
 * 	- use im_wbuffer() for bg writes
 * 1/5/10
 * 	- add PFM (portable float map) support
 * 19/12/11
 * 	- rework as a set of fns ready to be called from a class
 * 8/11/14
 * 	- add 1 bit write
 * 29/7/19 Kyle-Kyle
 * 	- fix a loop with malformed ppm
 * 13/11/19
 * 	- redone with source/target
 * 	- sequential load, plus mmap for filename sources
 * 	- faster plus lower memory use
 * 02/02/20
 * 	- ban max_vaue &lt; 0 
 * 27/6/20
 * 	- add ppmload_source
 * 22/11/20
 * 	- fix msb_first default [ewelot]
 * 26/12/20
 * 	- don't byteswap ascii formats
 * 	- set metadata for map loads
 * 	- byteswap binary loads
 */

/*

    This file is part of VIPS.
    
    VIPS is free software; you can redistribute it and/or modify
    it under the terms of the GNU Lesser General Public License as published by
    the Free Software Foundation; either version 2 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public License
    along with this program; if not, write to the Free Software
    Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
    02110-1301  USA

 */

/*

    These files are distributed with VIPS - http://www.vips.ecs.soton.ac.uk

 */

/*
#define DEBUG
 */

#ifdef HAVE_CONFIG_H
#include &lt;config.h&gt;
#endif /*HAVE_CONFIG_H*/
#include &lt;vips/intl.h&gt;

#include &lt;ctype.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;

#include &lt;vips/vips.h&gt;
#include &lt;vips/internal.h&gt;

#include &quot;pforeign.h&quot;

#ifdef HAVE_PPM

typedef struct _VipsForeignLoadPpm {
	VipsForeignLoad parent_object;

	/* The source we load from, and the buffered wrapper for it.
	 */
	VipsSource *source;
	VipsSbuf *sbuf;

	/* Properties of this ppm, from the header.
	 */
	int width;
	int height;
	int bands;
	VipsBandFormat format;
	VipsInterpretation interpretation;
	float scale;
	int max_value;
	int index;		/* ppm type .. index in magic_names[] */
	int bits;		/* 1, 8, 16 or 32 */
	gboolean ascii;		/* TRUE for ascii encoding */
	gboolean msb_first;	/* TRUE if most sig byte is first */

	gboolean have_read_header;

} VipsForeignLoadPpm;

typedef VipsForeignLoadClass VipsForeignLoadPpmClass;

G_DEFINE_ABSTRACT_TYPE( VipsForeignLoadPpm, vips_foreign_load_ppm, 
	VIPS_TYPE_FOREIGN_LOAD );

/* ppm types.
 */
static char *magic_names[] = {
	&quot;P1&quot;,	/* pbm ... 1 band 1 bit, ascii */
	&quot;P2&quot;,	/* pgm ... 1 band many bit, ascii */
	&quot;P3&quot;,	/* ppm ... 3 band many bit, ascii */
	&quot;P4&quot;,	/* pbm ... 1 band 1 bit, binary */
	&quot;P5&quot;,	/* pgm ... 1 band 8 bit, binary */
	&quot;P6&quot;,	/* ppm ... 3 band 8 bit, binary */
	&quot;PF&quot;,	/* pfm ... 3 band 32 bit, binary */
	&quot;Pf&quot;	/* pfm ... 1 band 32 bit, binary */
};

/* Shared with ppmsave.
 */
const char *vips__ppm_suffs[] = { &quot;.ppm&quot;, &quot;.pgm&quot;, &quot;.pbm&quot;, &quot;.pfm&quot;, NULL };

static gboolean
vips_foreign_load_ppm_is_a_source( VipsSource *source )
{
	const unsigned char *data;

	if( (data = vips_source_sniff( source, 2 )) ) { 
		int i;

		for( i = 0; i &lt; VIPS_NUMBER( magic_names ); i++ )
			if( vips_isprefix( magic_names[i], (char *) data ) )
				return( TRUE );
	}

	return( FALSE );
}

static int
get_int( VipsSbuf *sbuf, int *i )
{
	const char *txt;

	if( vips_sbuf_skip_whitespace( sbuf ) ||
		!(txt = vips_sbuf_get_non_whitespace( sbuf )) )
		return( -1 );

	*i = atoi( txt ); 

	return( 0 );
}

static int
get_float( VipsSbuf *sbuf, float *f )
{
	const char *txt;

	if( vips_sbuf_skip_whitespace( sbuf ) ||
		!(txt = vips_sbuf_get_non_whitespace( sbuf )) )
		return( -1 );

	/* We don't want the locale str -&gt; float conversion.
	 */
	*f = g_ascii_strtod( txt, NULL );

	return( 0 );
}

static void
vips_foreign_load_ppm_dispose( GObject *gobject )
{
	VipsForeignLoadPpm *ppm = (VipsForeignLoadPpm *) gobject;

#ifdef DEBUG
	printf( &quot;vips_foreign_load_ppm_dispose: %p\n&quot;, ppm );
#endif /*DEBUG*/

	VIPS_UNREF( ppm-&gt;sbuf );
	VIPS_UNREF( ppm-&gt;source );

	G_OBJECT_CLASS( vips_foreign_load_ppm_parent_class )-&gt;
		dispose( gobject );
}

static int
vips_foreign_load_ppm_build( VipsObject *object )
{
	VipsForeignLoadPpm *ppm = (VipsForeignLoadPpm *) object;

	if( ppm-&gt;source ) 
		ppm-&gt;sbuf = vips_sbuf_new_from_source( ppm-&gt;source );

	if( VIPS_OBJECT_CLASS( vips_foreign_load_ppm_parent_class )-&gt;
		build( object ) )
		return( -1 );

	return( 0 );
}

/* Scan the header into our class.
 */
static int
vips_foreign_load_ppm_parse_header( VipsForeignLoadPpm *ppm )
{
	VipsObjectClass *class = VIPS_OBJECT_GET_CLASS( ppm );

	int i;
	char buf[2];

	/* Characteristics, indexed by ppm type.
	 */
	static int lookup_bits[] = {
		1, 8, 8, 1, 8, 8, 32, 32
	};
	static int lookup_bands[] = {
		1, 1, 3, 1, 1, 3, 3, 1
	};
	static int lookup_ascii[] = {
		1, 1, 1, 0, 0, 0, 0, 0
	};

	if( vips_source_rewind( ppm-&gt;source ) )
		return( -1 );

	/* Read in the magic number.
	 */
	buf[0] = VIPS_SBUF_GETC( ppm-&gt;sbuf );
	buf[1] = VIPS_SBUF_GETC( ppm-&gt;sbuf );

	for( i = 0; i &lt; VIPS_NUMBER( magic_names ); i++ )
		if( vips_isprefix( magic_names[i], buf ) ) 
			break;
	if( i == VIPS_NUMBER( magic_names ) ) {
		vips_error( class-&gt;nickname, &quot;%s&quot;, _( &quot;bad magic number&quot; ) );
		return( -1 );
	}
	ppm-&gt;index = i;
	ppm-&gt;bits = lookup_bits[i];
	ppm-&gt;bands = lookup_bands[i];
	ppm-&gt;ascii = lookup_ascii[i];

	/* Default ... can be changed below for PFM images.
	 */
	ppm-&gt;msb_first = 1;

	/* Read in size.
	 */
	if( get_int( ppm-&gt;sbuf, &amp;ppm-&gt;width ) ||
		get_int( ppm-&gt;sbuf, &amp;ppm-&gt;height ) )
		return( -1 );

	/* Read in max value / scale for &gt;1 bit images.
	 */
	if( ppm-&gt;bits &gt; 1 ) {
		if( ppm-&gt;index == 6 || 
			ppm-&gt;index == 7 ) {
			if( get_float( ppm-&gt;sbuf, &amp;ppm-&gt;scale ) )
				return( -1 );

			/* Scale &gt; 0 means big-endian.
			 */
			ppm-&gt;msb_first = ppm-&gt;scale &gt; 0;
		}
		else {
			if( get_int( ppm-&gt;sbuf, &amp;ppm-&gt;max_value ) )
				return( -1 );

			/* max_value must be &gt; 0 and &lt;= 65535, according to
			 * the spec, but we allow up to 32 bits per pixel.
			 */
			if( ppm-&gt;max_value &lt; 0 )
				ppm-&gt;max_value = 0;

			if( ppm-&gt;max_value &gt; 255 )
				ppm-&gt;bits = 16;
			if( ppm-&gt;max_value &gt; 65535 )
				ppm-&gt;bits = 32;
		}
	}

	/* For binary images, there is always exactly 1 more whitespace
	 * character before the data starts.
	 */
	if( !ppm-&gt;ascii &amp;&amp; 
		!isspace( VIPS_SBUF_GETC( ppm-&gt;sbuf ) ) ) {
		vips_error( class-&gt;nickname, &quot;%s&quot;, 
			_( &quot;no whitespace before start of binary data&quot; ) );
		return( -1 );
	}

	/* Choose a VIPS bandfmt.
	 */
	switch( ppm-&gt;bits ) {
	case 1:
	case 8:
		ppm-&gt;format = VIPS_FORMAT_UCHAR;
		break;

	case 16:
		ppm-&gt;format = VIPS_FORMAT_USHORT;
		break;

	case 32:
		if( ppm-&gt;index == 6 || 
			ppm-&gt;index == 7 )
			ppm-&gt;format = VIPS_FORMAT_FLOAT;
		else
			ppm-&gt;format = VIPS_FORMAT_UINT;
		break;

	default:
		g_assert_not_reached();

		/* Stop compiler warnings.
		 */
		ppm-&gt;format = VIPS_FORMAT_UCHAR;
	}

	if( ppm-&gt;bands == 1 ) {
		if( ppm-&gt;format == VIPS_FORMAT_USHORT )
			ppm-&gt;interpretation = VIPS_INTERPRETATION_GREY16;
		else
			ppm-&gt;interpretation = VIPS_INTERPRETATION_B_W;
	}
	else {
		if( ppm-&gt;format == VIPS_FORMAT_USHORT )
			ppm-&gt;interpretation = VIPS_INTERPRETATION_RGB16;
		else 
			ppm-&gt;interpretation = VIPS_INTERPRETATION_sRGB;
	}

	ppm-&gt;have_read_header = TRUE;

#ifdef DEBUG
	printf( &quot;vips_foreign_load_ppm_parse_header:\n&quot; ); 
	printf( &quot;\twidth = %d\n&quot;, ppm-&gt;width ); 
	printf( &quot;\theight = %d\n&quot;, ppm-&gt;height ); 
	printf( &quot;\tbands = %d\n&quot;, ppm-&gt;bands ); 
	printf( &quot;\tformat = %s\n&quot;,
		vips_enum_nick( VIPS_TYPE_BAND_FORMAT, 
			ppm-&gt;format ) );
	printf( &quot;\tinterpretation = %s\n&quot;,
		vips_enum_nick( VIPS_TYPE_INTERPRETATION, 
			ppm-&gt;interpretation ) );
	printf( &quot;\tscale = %g\n&quot;, ppm-&gt;scale ); 
	printf( &quot;\tmax_value = %d\n&quot;, ppm-&gt;max_value ); 
	printf( &quot;\tbits = %d\n&quot;, ppm-&gt;bits ); 
	printf( &quot;\tacsii = %d\n&quot;, ppm-&gt;ascii ); 
	printf( &quot;\tmsb_first = %d\n&quot;, ppm-&gt;msb_first ); 
#endif /*DEBUG*/

	return( 0 );
}

static VipsForeignFlags
vips_foreign_load_ppm_get_flags( VipsForeignLoad *load )
{
	VipsForeignLoadPpm *ppm = (VipsForeignLoadPpm *) load;

	VipsForeignFlags flags;

	flags = 0;

	/* If this source supports fast mmap and this PPM is &gt;=8 bit binary,
	 * then we can mmap the file and support partial load. Otherwise,
	 * it's sequential.
	 */
	if( !ppm-&gt;have_read_header &amp;&amp;
		vips_foreign_load_ppm_parse_header( ppm ) )
		return( 0 );
	if( vips_source_is_mappable( ppm-&gt;source ) &amp;&amp;
		!ppm-&gt;ascii &amp;&amp; 
		ppm-&gt;bits &gt;= 8 )
		flags |= VIPS_FOREIGN_PARTIAL;
	else
		flags |= VIPS_FOREIGN_SEQUENTIAL;

	return( flags );
}

static void
vips_foreign_load_ppm_set_image_metadata( VipsForeignLoadPpm *ppm, 
	VipsImage *image )
{
	image-&gt;Type = ppm-&gt;interpretation;

	if( ppm-&gt;index == 6 || 
		ppm-&gt;index == 7 ) 
		vips_image_set_double( image, 
			&quot;pfm-scale&quot;, VIPS_FABS( ppm-&gt;scale ) );
	else
		vips_image_set_double( image, 
			&quot;ppm-max-value&quot;, VIPS_ABS( ppm-&gt;max_value ) );

	VIPS_SETSTR( image-&gt;filename, vips_connection_filename( 
		VIPS_CONNECTION( ppm-&gt;sbuf-&gt;source ) ) );

#ifdef DEBUG
	printf( &quot;vips_foreign_load_ppm_set_image: &quot; );
	vips_object_print_summary( VIPS_OBJECT( image ) );
#endif /*DEBUG*/
}

static void
vips_foreign_load_ppm_set_image( VipsForeignLoadPpm *ppm, VipsImage *image )
{
	vips_image_init_fields( image,
		ppm-&gt;width, ppm-&gt;height, ppm-&gt;bands, ppm-&gt;format, 
		VIPS_CODING_NONE, ppm-&gt;interpretation, 1.0, 1.0 );

        (void) vips_image_pipelinev( image, VIPS_DEMAND_STYLE_THINSTRIP, NULL );

	vips_foreign_load_ppm_set_image_metadata( ppm, image );

#ifdef DEBUG
	printf( &quot;vips_foreign_load_ppm_set_image: &quot; );
	vips_object_print_summary( VIPS_OBJECT( image ) );
#endif /*DEBUG*/
}

static int
vips_foreign_load_ppm_header( VipsForeignLoad *load )
{
	VipsForeignLoadPpm *ppm = (VipsForeignLoadPpm *) load;

	if( !ppm-&gt;have_read_header &amp;&amp;
		vips_foreign_load_ppm_parse_header( ppm ) )
		return( 0 );

	vips_foreign_load_ppm_set_image( ppm, load-&gt;out );

	vips_source_minimise( ppm-&gt;source );

	return( 0 );
}

/* Read a ppm/pgm file using mmap().
 */
static VipsImage *
vips_foreign_load_ppm_map( VipsForeignLoadPpm *ppm )
{
	gint64 header_offset;
	size_t length;
	const void *data;
	VipsImage *out;

#ifdef DEBUG
	printf( &quot;vips_foreign_load_ppm_map:\n&quot; );
#endif /*DEBUG*/

	vips_sbuf_unbuffer( ppm-&gt;sbuf );
	header_offset = vips_source_seek( ppm-&gt;source, 0, SEEK_CUR );
	data = vips_source_map( ppm-&gt;source, &amp;length );
	if( header_offset &lt; 0 || 
		!data )
		return( NULL );
	data += header_offset;
       	length -= header_offset;

	if( !(out = vips_image_new_from_memory( data, length,
		ppm-&gt;width, ppm-&gt;height, ppm-&gt;bands, ppm-&gt;format )) )
		return( NULL );

	vips_foreign_load_ppm_set_image_metadata( ppm, out );

	return( out );
}

static int
vips_foreign_load_ppm_generate_binary( VipsRegion *or, 
	void *seq, void *a, void *b, gboolean *stop )
{
        VipsRect *r = &amp;or-&gt;valid;
	VipsForeignLoadPpm *ppm = (VipsForeignLoadPpm *) a;
	VipsObjectClass *class = VIPS_OBJECT_GET_CLASS( ppm );
	VipsImage *image = or-&gt;im;
	size_t sizeof_line = VIPS_IMAGE_SIZEOF_LINE( image );

	int y;

	for( y = 0; y &lt; r-&gt;height; y++ ) {
		VipsPel *q = VIPS_REGION_ADDR( or, 0, r-&gt;top + y );

		size_t n_bytes;

		n_bytes = sizeof_line;
		while( n_bytes &gt; 0 ) {
			gint64 bytes_read;

			bytes_read = 
				vips_source_read( ppm-&gt;source, q, n_bytes );
			if( bytes_read &lt; 0 ) 
				return( -1 );
			if( bytes_read == 0 ) {
				vips_error( class-&gt;nickname, 
					&quot;%s&quot;, _( &quot;file truncated&quot; ) );
				return( -1 );
			}

			q += bytes_read;
			n_bytes -= bytes_read;
		}
	}

	return( 0 );
}

static int
vips_foreign_load_ppm_generate_1bit_ascii( VipsRegion *or, 
	void *seq, void *a, void *b, gboolean *stop )
{
        VipsRect *r = &amp;or-&gt;valid;
	VipsForeignLoadPpm *ppm = (VipsForeignLoadPpm *) a;
	VipsImage *image = or-&gt;im;

	int x, y;

	for( y = 0; y &lt; r-&gt;height; y++ ) {
		VipsPel *q = VIPS_REGION_ADDR( or, 0, r-&gt;top + y );

		for( x = 0; x &lt; image-&gt;Xsize; x++ ) {
			int val;

			if( get_int( ppm-&gt;sbuf, &amp;val ) )
				return( -1 );

			if( val )
				q[x] = 0;
			else
				q[x] = 255;
		}
	}

	return( 0 );
}

static int
vips_foreign_load_ppm_generate_1bit_binary( VipsRegion *or, 
	void *seq, void *a, void *b, gboolean *stop )
{
        VipsRect *r = &amp;or-&gt;valid;
	VipsForeignLoadPpm *ppm = (VipsForeignLoadPpm *) a;
	VipsImage *image = or-&gt;im;

	int x, y;

	for( y = 0; y &lt; r-&gt;height; y++ ) {
		VipsPel *q = VIPS_REGION_ADDR( or, 0, r-&gt;top + y );

		int bits;

		/* Not needed, but stop a compiler warning.
		 */
		bits = 0;

		for( x = 0; x &lt; image-&gt;Xsize; x++ ) {
			if( (x &amp; 7) == 0 )
				bits = VIPS_SBUF_GETC( ppm-&gt;sbuf );
			q[x] = (bits &amp; 128) ? 0 : 255;
			bits = VIPS_LSHIFT_INT( bits, 1 );
		}
	}

	return( 0 );
}

static int
vips_foreign_load_ppm_generate_ascii_int( VipsRegion *or, 
	void *seq, void *a, void *b, gboolean *stop )
{
        VipsRect *r = &amp;or-&gt;valid;
	VipsForeignLoadPpm *ppm = (VipsForeignLoadPpm *) a;
	VipsImage *image = or-&gt;im;
	int n_elements = image-&gt;Xsize * image-&gt;Bands;

	int i, y;

	for( y = 0; y &lt; r-&gt;height; y++ ) {
		VipsPel *q = VIPS_REGION_ADDR( or, r-&gt;left, r-&gt;top + y );

		for( i = 0; i &lt; n_elements; i++ ) {
			int val;

			if( get_int( ppm-&gt;sbuf, &amp;val ) )
				return( -1 );
			
			switch( image-&gt;BandFmt ) {
			case VIPS_FORMAT_UCHAR:
				q[i] = VIPS_CLIP( 0, val, 255 );
				break;

			case VIPS_FORMAT_USHORT:
				((unsigned short *) q)[i] = 
					VIPS_CLIP( 0, val, 65535 );
				break;

			case VIPS_FORMAT_UINT:
				((unsigned int *) q)[i] = val;
				break;

			default:
				g_assert_not_reached();
			}
		}
	}

	return( 0 );
}

static VipsImage *
vips_foreign_load_ppm_scan( VipsForeignLoadPpm *ppm )
{
	VipsImage **t = (VipsImage **) 
		vips_object_local_array( VIPS_OBJECT( ppm ), 2 );

	VipsImage *out;
	VipsGenerateFn generate;

	/* What sort of read are we doing?
	 */
	if( !ppm-&gt;ascii &amp;&amp; ppm-&gt;bits &gt;= 8 ) {
#ifdef DEBUG
		printf( &quot;vips_foreign_load_ppm_source: &gt;1 bit binary load\n&quot; );
#endif /*DEBUG*/

		generate = vips_foreign_load_ppm_generate_binary;

		/* The binary loader does not use the buffered IO 
		 * object.
		 */
		vips_sbuf_unbuffer( ppm-&gt;sbuf ); 
	}
	else if( !ppm-&gt;ascii &amp;&amp; ppm-&gt;bits == 1 ) {
#ifdef DEBUG
		printf( &quot;vips_foreign_load_ppm_source: 1-bit binary load\n&quot; );
#endif /*DEBUG*/

		generate = vips_foreign_load_ppm_generate_1bit_binary;
	}
	else if( ppm-&gt;ascii &amp;&amp; ppm-&gt;bits == 1 ) {
#ifdef DEBUG
		printf( &quot;vips_foreign_load_ppm_source: 1-bit ascii load\n&quot; );
#endif /*DEBUG*/

		generate = vips_foreign_load_ppm_generate_1bit_ascii;
	}
	else {
#ifdef DEBUG
		printf( &quot;vips_foreign_load_ppm_source: &gt;1-bit ascii load\n&quot; );
#endif /*DEBUG*/

		generate = vips_foreign_load_ppm_generate_ascii_int;
	}

	t[0] = vips_image_new(); 
	vips_foreign_load_ppm_set_image( ppm, t[0] );
	if( vips_image_generate( t[0], NULL, generate, NULL, ppm, NULL ) ||
		vips_sequential( t[0], &amp;out, NULL ) )
		return( NULL );

	return( out );
}

static int
vips_foreign_load_ppm_load( VipsForeignLoad *load )
{
	VipsForeignLoadPpm *ppm = (VipsForeignLoadPpm *) load;
	VipsImage **t = (VipsImage **) 
		vips_object_local_array( (VipsObject *) load, 2 );

	if( !ppm-&gt;have_read_header &amp;&amp;
		vips_foreign_load_ppm_parse_header( ppm ) )
		return( 0 );

	/* If the source is mappable and this is a binary file, we can map it.
	 */
	if( vips_source_is_mappable( ppm-&gt;source ) &amp;&amp;
		!ppm-&gt;ascii &amp;&amp; 
		ppm-&gt;bits &gt;= 8 ) {
		if( !(t[0] = vips_foreign_load_ppm_map( ppm )) ) 
			return( -1 );
	}
	else {
		if( !(t[0] = vips_foreign_load_ppm_scan( ppm )) ) 
			return( -1 );
	}

#ifdef DEBUG
	printf( &quot;vips_foreign_load_ppm: byteswap = %d\n&quot;, 
		vips_amiMSBfirst() != ppm-&gt;msb_first );
#endif /*DEBUG*/

	/* Don't byteswap the ascii formats.
	 */
	if( vips__byteswap_bool( t[0], &amp;t[1],
			!ppm-&gt;ascii &amp;&amp;
                        vips_amiMSBfirst() != ppm-&gt;msb_first ) ||
		vips_image_write( t[1], load-&gt;real ) ) 
		return( -1 );

<A NAME="2"></A>	if( vips_source_decode( ppm-&gt;source ) )
		return( -1 );

<FONT color="#980517"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match1591-0.html#2',2,'match1591-top.html#2',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>	return( 0 );
}

static void
vips_foreign_load_ppm_class_init( VipsForeignLoadPpmClass *class )
{
	GObjectClass *gobject_class = G_OBJECT_CLASS( class );
	VipsObjectClass *object_class = (VipsObjectClass *) class;
	VipsForeignClass *foreign_class = (VipsForeignClass *) class;
	VipsForeignLoadClass *load_class = (VipsForeignLoadClass *) class;

	gobject_class-&gt;dispose = vips_foreign_load_ppm_dispose;
	gobject_class-&gt;set_property = vips_object_set_property;
	gobject_class-&gt;get_property = vips_object_get_property;

	object_class-&gt;nickname = &quot;ppmload_base&quot;;
	object_class-&gt;description = _( &quot;load ppm base class&quot; );
	object_class-&gt;build = vips_foreign_load_ppm_build;

	foreign_class-&gt;suffs = vips__ppm_suffs;

	/* We are fast at is_a(), so high priority.
	 */
	foreign_class-&gt;priority = 200;</B></FONT>

	load_class-&gt;get_flags = vips_foreign_load_ppm_get_flags;
	load_class-&gt;header = vips_foreign_load_ppm_header;
	load_class-&gt;load = vips_foreign_load_ppm_load;

}

static void
vips_foreign_load_ppm_init( VipsForeignLoadPpm *ppm )
{
	ppm-&gt;scale = 1.0;
}

typedef struct _VipsForeignLoadPpmFile {
	VipsForeignLoadPpm parent_object;

	char *filename;

} VipsForeignLoadPpmFile;

typedef VipsForeignLoadPpmClass VipsForeignLoadPpmFileClass;

<A NAME="3"></A>G_DEFINE_TYPE( VipsForeignLoadPpmFile, vips_foreign_load_ppm_file, 
	vips_foreign_load_ppm_get_type() );

<FONT color="#53858b"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match1591-0.html#3',2,'match1591-top.html#3',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>static gboolean
vips_foreign_load_ppm_file_is_a( const char *filename )
{
	VipsSource *source;
	gboolean result;

	if( !(source = vips_source_new_from_file( filename )) )
		return( FALSE );
	result = vips_foreign_load_ppm_is_a_source( source );
	VIPS_UNREF( source );

	return( result );
}

static int
vips_foreign_load_ppm_file_build( VipsObject *object )
{
	VipsForeignLoadPpmFile *file = (VipsForeignLoadPpmFile *) object;</B></FONT>
	VipsForeignLoadPpm *ppm = (VipsForeignLoadPpm *) object;

	if( file-&gt;filename &amp;&amp;
		!(ppm-&gt;source = vips_source_new_from_file( file-&gt;filename )) )
		return( -1 );

	if( VIPS_OBJECT_CLASS( vips_foreign_load_ppm_file_parent_class )-&gt;
<A NAME="4"></A>		build( object ) )
		return( -1 );

<FONT color="#6cc417"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match1591-0.html#4',2,'match1591-top.html#4',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>	return( 0 );
}

static void
vips_foreign_load_ppm_file_class_init( VipsForeignLoadPpmClass *class )
{
	GObjectClass *gobject_class = G_OBJECT_CLASS( class );
<A NAME="0"></A>	VipsObjectClass *object_class = (VipsObjectClass *) class;
	VipsForeignLoadClass *load_class = (VipsForeignLoadClass *) class;</B></FONT>

<FONT color="#0000ff"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match1591-0.html#0',2,'match1591-top.html#0',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>	gobject_class-&gt;set_property = vips_object_set_property;
	gobject_class-&gt;get_property = vips_object_get_property;

	object_class-&gt;nickname = &quot;ppmload&quot;;
	object_class-&gt;description = _( &quot;load ppm from file&quot; );
	object_class-&gt;build = vips_foreign_load_ppm_file_build;

	load_class-&gt;is_a = vips_foreign_load_ppm_file_is_a;

	VIPS_ARG_STRING( class, &quot;filename&quot;, 1, 
		_( &quot;Filename&quot; ),
		_( &quot;Filename to load from&quot; ),
		VIPS_ARGUMENT_REQUIRED_INPUT, 
		G_STRUCT_OFFSET( VipsForeignLoadPpmFile, filename ),
		NULL );
}

static void
vips_foreign_load_ppm_file_init( VipsForeignLoadPpmFile *file )
{
}

typedef struct _VipsForeignLoadPpmSource {
	VipsForeignLoadPpm parent_object;

	VipsSource *source;

} VipsForeignLoadPpmSource;

typedef VipsForeignLoadPpmClass VipsForeignLoadPpmSourceClass;

G_DEFINE_TYPE( VipsForeignLoadPpmSource, vips_foreign_load_ppm_source,
	vips_foreign_load_ppm_get_type() );

static int
vips_foreign_load_ppm_source_build( VipsObject *object )
{
	VipsForeignLoadPpm *ppm = (VipsForeignLoadPpm *) object;
	VipsForeignLoadPpmSource *source = (VipsForeignLoadPpmSource *) object;

	if( source-&gt;source ) {
		ppm-&gt;source = source-&gt;source;
		g_object_ref( ppm-&gt;source );
	}

	if( VIPS_OBJECT_CLASS( vips_foreign_load_ppm_source_parent_class )-&gt;
		build( object ) )
		return( -1 );

	return( 0 );
}

static void</B></FONT>
vips_foreign_load_ppm_source_class_init( VipsForeignLoadPpmFileClass *class )
{
	GObjectClass *gobject_class = G_OBJECT_CLASS( class );
<A NAME="1"></A>	VipsObjectClass *object_class = (VipsObjectClass *) class;
	VipsForeignLoadClass *load_class = (VipsForeignLoadClass *) class;

<FONT color="#f63526"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match1591-0.html#1',2,'match1591-top.html#1',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>	gobject_class-&gt;set_property = vips_object_set_property;
	gobject_class-&gt;get_property = vips_object_get_property;

	object_class-&gt;nickname = &quot;ppmload_source&quot;;
	object_class-&gt;build = vips_foreign_load_ppm_source_build;

	load_class-&gt;is_a_source = vips_foreign_load_ppm_is_a_source;

	VIPS_ARG_OBJECT( class, &quot;source&quot;, 1,
		_( &quot;Source&quot; ),
		_( &quot;Source to load from&quot; ),
		VIPS_ARGUMENT_REQUIRED_INPUT, 
		G_STRUCT_OFFSET( VipsForeignLoadPpmSource, source ),
		VIPS_TYPE_SOURCE );

}

static void
vips_foreign_load_ppm_source_init( VipsForeignLoadPpmSource *source )
{
}

#endif /*HAVE_PPM*/

/**
 * vips_ppmload:
 * @filename: file to load
 * @out: (out): output image
 * @...: %NULL-terminated list of optional named arguments
 *
 * Read a PPM/PBM/PGM/PFM file into a VIPS image. 
 *
 * It can read 1, 8, 16 and 32 bit images, colour or monochrome,
 * stored in binary or in ASCII. One bit images become 8 bit VIPS images, 
 * with 0 and 255 for 0 and 1.
 *
 * See also: vips_image_new_from_file().
 *
 * Returns: 0 on success, -1 on error.
 */
int
vips_ppmload( const char *filename, VipsImage **out, ... )
{
	va_list ap;
	int result;

	va_start( ap, out );
	result = vips_call_split( &quot;ppmload&quot;, ap, filename, out ); 
	va_end( ap );

	return( result );
}

/**
 * vips_ppmload_source:
 * @source: source to load
 * @out: (out): output image
 * @...: %NULL-terminated list of optional named arguments
 *
 * Optional arguments:
 *
 * * @skip: skip this many lines at start of file
 * * @lines: read this many lines from file
 * * @whitespace: set of whitespace characters
 * * @separator: set of separator characters
 * * @fail: %gboolean, fail on errors
 *
 * Exactly as vips_ppmload(), but read from a source. 
 *
 * See also: vips_ppmload().
 *
 * Returns: 0 on success, -1 on error.
 */
int
vips_ppmload_source( VipsSource *source, VipsImage **out, ... )
{
	va_list ap;
	int result;

	va_start( ap, out );
	result = vips_call_split( &quot;ppmload_source&quot;, ap, source, out ); 
	va_end( ap );

	return( result );
}</B></FONT>
</PRE>
</div>
  </div>
</body>
</html>
