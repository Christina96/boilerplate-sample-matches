
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 16, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>Adafruit_nRF52_Arduino-MDEwOlJlcG9zaXRvcnk3NDM1NDcyOQ==-flat-nrf_qdec.h</h3>
            <pre><code>1  #ifndef NRF_QDEC_H__
2  #define NRF_QDEC_H__
3  #include <nrfx.h>
4  #ifdef __cplusplus
5  extern "C" {
6  #endif
7  #define NRF_QDEC_LED_NOT_CONNECTED  0xFFFFFFFF
8  typedef enum
9  {
10      NRF_QDEC_TASK_START      = offsetof(NRF_QDEC_Type, TASKS_START),     &bsol;**< Starting the quadrature decoder. */
11      NRF_QDEC_TASK_STOP       = offsetof(NRF_QDEC_Type, TASKS_STOP),      &bsol;**< Stopping the quadrature decoder. */
12      NRF_QDEC_TASK_READCLRACC = offsetof(NRF_QDEC_Type, TASKS_READCLRACC) &bsol;**< Reading and clearing ACC and ACCDBL registers. */
13  } nrf_qdec_task_t;
14  typedef enum
15  {
16      NRF_QDEC_EVENT_SAMPLERDY = offsetof(NRF_QDEC_Type, EVENTS_SAMPLERDY), &bsol;**< Event generated for every new sample.  */
17      NRF_QDEC_EVENT_REPORTRDY = offsetof(NRF_QDEC_Type, EVENTS_REPORTRDY), &bsol;**< Event generated for every new report.  */
18      NRF_QDEC_EVENT_ACCOF     = offsetof(NRF_QDEC_Type, EVENTS_ACCOF)      &bsol;**< Event generated for every accumulator overflow. */
19  } nrf_qdec_event_t;
20  typedef enum
21  {
22      NRF_QDEC_SHORT_REPORTRDY_READCLRACC_MASK = QDEC_SHORTS_REPORTRDY_READCLRACC_Msk, &bsol;**< Shortcut between REPORTRDY event and READCLRACC task.  */
23      NRF_QDEC_SHORT_SAMPLERDY_STOP_MASK       = QDEC_SHORTS_SAMPLERDY_STOP_Msk        &bsol;**< Shortcut between SAMPLERDY event and STOP task.  */
24  } nrf_qdec_short_mask_t;
25  typedef enum
26  {
27      NRF_QDEC_INT_SAMPLERDY_MASK = QDEC_INTENSET_SAMPLERDY_Msk, &bsol;**< Mask for enabling or disabling an interrupt on SAMPLERDY event.  */
28      NRF_QDEC_INT_REPORTRDY_MASK = QDEC_INTENSET_REPORTRDY_Msk, &bsol;**< Mask for enabling or disabling an interrupt on REPORTRDY event.  */
29      NRF_QDEC_INT_ACCOF_MASK     = QDEC_INTENSET_ACCOF_Msk      &bsol;**< Mask for enabling or disabling an interrupt on ACCOF event.  */
30  } nrf_qdec_int_mask_t;
31  typedef enum
32  {
33      NRF_QDEC_DISABLE = QDEC_ENABLE_ENABLE_Disabled, &bsol;**< Mask for disabling the QDEC periperal. When disabled, the QDEC decoder pins are not active.  */
34      NRF_QDEC_ENABLE  = QDEC_ENABLE_ENABLE_Enabled   &bsol;**< Mask for enabling the QDEC periperal. When enabled, the QDEC pins are active. */
35  } nrf_qdec_enable_t;
36  typedef enum
37  {
38      NRF_QDEC_DBFEN_DISABLE = QDEC_DBFEN_DBFEN_Disabled, &bsol;**< Mask for disabling the debounce filter.  */
39      NRF_QDEC_DBFEN_ENABLE  = QDEC_DBFEN_DBFEN_Enabled   &bsol;**< Mask for enabling the debounce filter.  */
40  } nrf_qdec_dbfen_t;
41  typedef enum
42  {
43      NRF_QDEC_LEPOL_ACTIVE_LOW  = QDEC_LEDPOL_LEDPOL_ActiveLow, &bsol;**< QDEC LED active on output pin low.  */
44      NRF_QDEC_LEPOL_ACTIVE_HIGH = QDEC_LEDPOL_LEDPOL_ActiveHigh &bsol;**< QDEC LED active on output pin high.  */
45  } nrf_qdec_ledpol_t;
46  typedef enum
47  {
48      NRF_QDEC_SAMPLEPER_128us   = QDEC_SAMPLEPER_SAMPLEPER_128us,  &bsol;**< QDEC sampling period 128 microseconds.  */
49      NRF_QDEC_SAMPLEPER_256us   = QDEC_SAMPLEPER_SAMPLEPER_256us,  &bsol;**< QDEC sampling period 256 microseconds.  */
50      NRF_QDEC_SAMPLEPER_512us   = QDEC_SAMPLEPER_SAMPLEPER_512us,  &bsol;**< QDEC sampling period 512 microseconds.  */
51      NRF_QDEC_SAMPLEPER_1024us  = QDEC_SAMPLEPER_SAMPLEPER_1024us, &bsol;**< QDEC sampling period 1024 microseconds.  */
52      NRF_QDEC_SAMPLEPER_2048us  = QDEC_SAMPLEPER_SAMPLEPER_2048us, &bsol;**< QDEC sampling period 2048 microseconds.  */
53      NRF_QDEC_SAMPLEPER_4096us  = QDEC_SAMPLEPER_SAMPLEPER_4096us, &bsol;**< QDEC sampling period 4096 microseconds.  */
54      NRF_QDEC_SAMPLEPER_8192us  = QDEC_SAMPLEPER_SAMPLEPER_8192us, &bsol;**< QDEC sampling period 8192 microseconds.  */
55      NRF_QDEC_SAMPLEPER_16384us = QDEC_SAMPLEPER_SAMPLEPER_16384us &bsol;**< QDEC sampling period 16384 microseconds.  */
56  } nrf_qdec_sampleper_t;
57  typedef enum
58  {
59      NRF_QDEC_REPORTPER_10  = QDEC_REPORTPER_REPORTPER_10Smpl,  &bsol;**< QDEC report period 10 samples.  */
60      NRF_QDEC_REPORTPER_40  = QDEC_REPORTPER_REPORTPER_40Smpl,  &bsol;**< QDEC report period 40 samples.  */
61      NRF_QDEC_REPORTPER_80  = QDEC_REPORTPER_REPORTPER_80Smpl,  &bsol;**< QDEC report period 80 samples.  */
62      NRF_QDEC_REPORTPER_120 = QDEC_REPORTPER_REPORTPER_120Smpl, &bsol;**< QDEC report period 120 samples. */
63      NRF_QDEC_REPORTPER_160 = QDEC_REPORTPER_REPORTPER_160Smpl, &bsol;**< QDEC report period 160 samples. */
64      NRF_QDEC_REPORTPER_200 = QDEC_REPORTPER_REPORTPER_200Smpl, &bsol;**< QDEC report period 200 samples. */
65      NRF_QDEC_REPORTPER_240 = QDEC_REPORTPER_REPORTPER_240Smpl, &bsol;**< QDEC report period 240 samples. */
66      NRF_QDEC_REPORTPER_280 = QDEC_REPORTPER_REPORTPER_280Smpl, &bsol;**< QDEC report period 280 samples. */
67      NRF_QDEC_REPORTPER_DISABLED                                &bsol;**< QDEC reporting disabled.        */
68  } nrf_qdec_reportper_t;
69  NRF_STATIC_INLINE void nrf_qdec_enable(NRF_QDEC_Type * p_reg);
70  NRF_STATIC_INLINE void nrf_qdec_disable(NRF_QDEC_Type * p_reg);
71  NRF_STATIC_INLINE uint32_t nrf_qdec_enable_get(NRF_QDEC_Type const * p_reg);
72  NRF_STATIC_INLINE void nrf_qdec_int_enable(NRF_QDEC_Type * p_reg, uint32_t mask);
73  NRF_STATIC_INLINE void nrf_qdec_int_disable(NRF_QDEC_Type * p_reg, uint32_t mask);
74  NRF_STATIC_INLINE uint32_t nrf_qdec_int_enable_check(NRF_QDEC_Type const * p_reg, uint32_t mask);
75  NRF_STATIC_INLINE void nrf_qdec_dbfen_enable(NRF_QDEC_Type * p_reg);
76  NRF_STATIC_INLINE void nrf_qdec_dbfen_disable(NRF_QDEC_Type * p_reg);
77  NRF_STATIC_INLINE uint32_t nrf_qdec_dbfen_get(NRF_QDEC_Type const * p_reg);
78  NRF_STATIC_INLINE void nrf_qdec_pio_assign(NRF_QDEC_Type * p_reg,
79                                             uint32_t        psela,
80                                             uint32_t        pselb,
81                                             uint32_t        pselled);
82  NRF_STATIC_INLINE void nrf_qdec_task_trigger(NRF_QDEC_Type * p_reg, nrf_qdec_task_t task);
83  NRF_STATIC_INLINE uint32_t nrf_qdec_task_address_get(NRF_QDEC_Type const * p_reg,
84                                                       nrf_qdec_task_t       task);
85  NRF_STATIC_INLINE void nrf_qdec_event_clear(NRF_QDEC_Type * p_reg, nrf_qdec_event_t event);
86  NRF_STATIC_INLINE bool nrf_qdec_event_check(NRF_QDEC_Type const * p_reg, nrf_qdec_event_t event);
87  NRF_STATIC_INLINE uint32_t nrf_qdec_event_address_get(NRF_QDEC_Type const * p_reg,
88                                                        nrf_qdec_event_t      event);
89  NRF_STATIC_INLINE void nrf_qdec_shorts_enable(NRF_QDEC_Type * p_reg, uint32_t mask);
90  NRF_STATIC_INLINE void nrf_qdec_shorts_disable(NRF_QDEC_Type * p_reg, uint32_t mask);
91  NRF_STATIC_INLINE uint32_t nrf_qdec_sampleper_to_value(nrf_qdec_sampleper_t sampleper);
92  NRF_STATIC_INLINE void nrf_qdec_sampleper_set(NRF_QDEC_Type *      p_reg,
93                                                nrf_qdec_sampleper_t sampleper);
94  NRF_STATIC_INLINE nrf_qdec_sampleper_t nrf_qdec_sampleper_get(NRF_QDEC_Type const * p_reg);
95  NRF_STATIC_INLINE int32_t nrf_qdec_sample_get(NRF_QDEC_Type const * p_reg);
96  NRF_STATIC_INLINE int32_t nrf_qdec_acc_get(NRF_QDEC_Type const * p_reg);
97  NRF_STATIC_INLINE int32_t nrf_qdec_accread_get(NRF_QDEC_Type const * p_reg);
98  NRF_STATIC_INLINE uint32_t nrf_qdec_accdbl_get(NRF_QDEC_Type const * p_reg);
99  NRF_STATIC_INLINE uint32_t nrf_qdec_accdblread_get(NRF_QDEC_Type const * p_reg);
100  NRF_STATIC_INLINE void nrf_qdec_ledpre_set(NRF_QDEC_Type * p_reg, uint32_t time_us);
101  NRF_STATIC_INLINE uint32_t nrf_qdec_ledpre_get(NRF_QDEC_Type const * p_reg);
102  NRF_STATIC_INLINE void nrf_qdec_reportper_set(NRF_QDEC_Type *      p_reg,
103                                                nrf_qdec_reportper_t reportper);
104  NRF_STATIC_INLINE uint32_t nrf_qdec_reportper_get(NRF_QDEC_Type const * p_reg);
105  NRF_STATIC_INLINE uint32_t nrf_qdec_reportper_to_value(uint32_t reportper);
106  NRF_STATIC_INLINE void nrf_qdec_ledpol_set(NRF_QDEC_Type * p_reg, nrf_qdec_ledpol_t pol);
107  NRF_STATIC_INLINE uint32_t nrf_qdec_ledpol_get(NRF_QDEC_Type const * p_reg);
108  #ifndef NRF_DECLARE_ONLY
109  NRF_STATIC_INLINE void nrf_qdec_enable(NRF_QDEC_Type * p_reg)
110  {
111      p_reg->ENABLE = NRF_QDEC_ENABLE;
112  }
113  NRF_STATIC_INLINE void nrf_qdec_disable(NRF_QDEC_Type * p_reg)
114  {
115      p_reg->ENABLE = NRF_QDEC_DISABLE;
116  }
117  NRF_STATIC_INLINE uint32_t nrf_qdec_enable_get(NRF_QDEC_Type const * p_reg)
118  {
119      return p_reg->ENABLE;
120  }
121  NRF_STATIC_INLINE void nrf_qdec_int_enable(NRF_QDEC_Type * p_reg, uint32_t mask)
122  {
123      p_reg->INTENSET = mask; 
124  }
125  NRF_STATIC_INLINE void nrf_qdec_int_disable(NRF_QDEC_Type * p_reg, uint32_t mask)
126  {
127      p_reg->INTENCLR = mask; 
128  }
129  NRF_STATIC_INLINE uint32_t nrf_qdec_int_enable_check(NRF_QDEC_Type const * p_reg, uint32_t mask)
130  {
131      return p_reg->INTENSET & mask; 
132  }
133  NRF_STATIC_INLINE void nrf_qdec_dbfen_enable(NRF_QDEC_Type * p_reg)
134  {
135      p_reg->DBFEN = NRF_QDEC_DBFEN_ENABLE;
136  }
137  NRF_STATIC_INLINE void nrf_qdec_dbfen_disable(NRF_QDEC_Type * p_reg)
138  {
139      p_reg->DBFEN = NRF_QDEC_DBFEN_DISABLE;
140  }
141  NRF_STATIC_INLINE uint32_t nrf_qdec_dbfen_get(NRF_QDEC_Type const * p_reg)
142  {
143      return p_reg->DBFEN;
144  }
145  NRF_STATIC_INLINE void nrf_qdec_pio_assign(NRF_QDEC_Type * p_reg,
<span onclick='openModal()' class='match'>146                                             uint32_t        psela,
147                                             uint32_t        pselb,
148                                             uint32_t        pselled)
149  {
150  #if defined(QDEC_PSEL_A_CONNECT_Pos)
151      p_reg->PSEL.A = psela;
</span>152  #else
153      p_reg->PSELA = psela;
154  #endif
155  #if defined(QDEC_PSEL_B_CONNECT_Pos)
156      p_reg->PSEL.B = pselb;
157  #else
158      p_reg->PSELB = pselb;
159  #endif
160  #if defined(QDEC_PSEL_LED_CONNECT_Pos)
161      p_reg->PSEL.LED = pselled;
162  #else
163      p_reg->PSELLED = pselled;
164  #endif
165  }
166  NRF_STATIC_INLINE void nrf_qdec_task_trigger(NRF_QDEC_Type * p_reg, nrf_qdec_task_t task)
167  {
168      *( (volatile uint32_t *)( (uint8_t *)p_reg + (uint32_t)task) ) = 1;
169  }
170  NRF_STATIC_INLINE uint32_t nrf_qdec_task_address_get(NRF_QDEC_Type const * p_reg,
171                                                       nrf_qdec_task_t       task)
172  {
173      return (uint32_t)( (uint8_t *)p_reg + (uint32_t)task);
174  }
175  NRF_STATIC_INLINE void nrf_qdec_event_clear(NRF_QDEC_Type * p_reg, nrf_qdec_event_t event)
176  {
177      *( (volatile uint32_t *)( (uint8_t *)p_reg + (uint32_t)event) ) = 0;
178  #if __CORTEX_M == 0x04
179      volatile uint32_t dummy = *((volatile uint32_t *)((uint8_t *)p_reg + event));
180      (void)dummy;
181  #endif
182  }
183  NRF_STATIC_INLINE bool nrf_qdec_event_check(NRF_QDEC_Type const * p_reg, nrf_qdec_event_t event)
184  {
185      return (bool)*(volatile uint32_t *)( (uint8_t *)p_reg + (uint32_t)event);
186  }
187  NRF_STATIC_INLINE uint32_t nrf_qdec_event_address_get(NRF_QDEC_Type const * p_reg,
188                                                        nrf_qdec_event_t      event)
189  {
190      return (uint32_t)( (uint8_t *)p_reg + (uint32_t)event);
191  }
192  NRF_STATIC_INLINE void nrf_qdec_shorts_enable(NRF_QDEC_Type * p_reg, uint32_t mask)
193  {
194      p_reg->SHORTS |= mask;
195  }
196  NRF_STATIC_INLINE void nrf_qdec_shorts_disable(NRF_QDEC_Type * p_reg, uint32_t mask)
197  {
198      p_reg->SHORTS &= ~mask;
199  }
200  NRF_STATIC_INLINE uint32_t nrf_qdec_sampleper_to_value(nrf_qdec_sampleper_t sampleper)
201  {
202      return (1 << (7 + sampleper));
203  }
204  NRF_STATIC_INLINE void nrf_qdec_sampleper_set(NRF_QDEC_Type *      p_reg,
205                                                nrf_qdec_sampleper_t sampleper)
206  {
207      p_reg->SAMPLEPER = sampleper;
208  }
209  NRF_STATIC_INLINE nrf_qdec_sampleper_t nrf_qdec_sampleper_get(NRF_QDEC_Type const * p_reg)
210  {
211      return (nrf_qdec_sampleper_t)(p_reg->SAMPLEPER);
212  }
213  NRF_STATIC_INLINE int32_t nrf_qdec_sample_get(NRF_QDEC_Type const * p_reg)
214  {
215      return p_reg->SAMPLE;
216  }
217  NRF_STATIC_INLINE int32_t nrf_qdec_acc_get(NRF_QDEC_Type const * p_reg)
218  {
219      return p_reg->ACC;
220  }
221  NRF_STATIC_INLINE int32_t nrf_qdec_accread_get(NRF_QDEC_Type const * p_reg)
222  {
223      return p_reg->ACCREAD;
224  }
225  NRF_STATIC_INLINE uint32_t nrf_qdec_accdbl_get(NRF_QDEC_Type const * p_reg)
226  {
227      return p_reg->ACCDBL;
228  }
229  NRF_STATIC_INLINE uint32_t nrf_qdec_accdblread_get(NRF_QDEC_Type const * p_reg)
230  {
231      return p_reg->ACCDBLREAD;
232  }
233  NRF_STATIC_INLINE void nrf_qdec_ledpre_set(NRF_QDEC_Type * p_reg, uint32_t time_us)
234  {
235      p_reg->LEDPRE = time_us;
236  }
237  NRF_STATIC_INLINE uint32_t nrf_qdec_ledpre_get(NRF_QDEC_Type const * p_reg)
238  {
239      return p_reg->LEDPRE;
240  }
241  NRF_STATIC_INLINE void nrf_qdec_reportper_set(NRF_QDEC_Type *      p_reg,
242                                                nrf_qdec_reportper_t reportper)
243  {
244      p_reg->REPORTPER = reportper;
245  }
246  NRF_STATIC_INLINE uint32_t nrf_qdec_reportper_get(NRF_QDEC_Type const * p_reg)
247  {
248      return p_reg->REPORTPER;
249  }
250  NRF_STATIC_INLINE uint32_t nrf_qdec_reportper_to_value(uint32_t reportper)
251  {
252      return (reportper == NRF_QDEC_REPORTPER_10) ? 10 : reportper * 40;
253  }
254  NRF_STATIC_INLINE void nrf_qdec_ledpol_set(NRF_QDEC_Type * p_reg, nrf_qdec_ledpol_t pol)
255  {
256      p_reg->LEDPOL = pol;
257  }
258  NRF_STATIC_INLINE uint32_t nrf_qdec_ledpol_get(NRF_QDEC_Type const * p_reg)
259  {
260      return p_reg->LEDPOL;
261  }
262  #endif 
263  #ifdef __cplusplus
264  }
265  #endif
266  #endif 
</code></pre>
        </div>
        <div class="column">
            <h3>Adafruit_nRF52_Arduino-MDEwOlJlcG9zaXRvcnk3NDM1NDcyOQ==-flat-nrf_spis.h</h3>
            <pre><code>1  #ifndef NRF_SPIS_H__
2  #define NRF_SPIS_H__
3  #include <nrfx.h>
4  #ifdef __cplusplus
5  extern "C" {
6  #endif
7  #define NRF_SPIS_PIN_NOT_CONNECTED  0xFFFFFFFF
8  typedef enum
9  {
10      NRF_SPIS_TASK_ACQUIRE = offsetof(NRF_SPIS_Type, TASKS_ACQUIRE), 
11      NRF_SPIS_TASK_RELEASE = offsetof(NRF_SPIS_Type, TASKS_RELEASE), 
12  } nrf_spis_task_t;
13  typedef enum
14  {
15      NRF_SPIS_EVENT_END      = offsetof(NRF_SPIS_Type, EVENTS_END),     
16      NRF_SPIS_EVENT_ACQUIRED = offsetof(NRF_SPIS_Type, EVENTS_ACQUIRED) 
17  } nrf_spis_event_t;
18  typedef enum
19  {
20      NRF_SPIS_SHORT_END_ACQUIRE = SPIS_SHORTS_END_ACQUIRE_Msk 
21  } nrf_spis_short_mask_t;
22  typedef enum
23  {
24      NRF_SPIS_INT_END_MASK      = SPIS_INTENSET_END_Msk,     
25      NRF_SPIS_INT_ACQUIRED_MASK = SPIS_INTENSET_ACQUIRED_Msk 
26  } nrf_spis_int_mask_t;
27  typedef enum
28  {
29      NRF_SPIS_MODE_0, 
30      NRF_SPIS_MODE_1, 
31      NRF_SPIS_MODE_2, 
32      NRF_SPIS_MODE_3  
33  } nrf_spis_mode_t;
34  typedef enum
35  {
36      NRF_SPIS_BIT_ORDER_MSB_FIRST = SPIS_CONFIG_ORDER_MsbFirst, 
37      NRF_SPIS_BIT_ORDER_LSB_FIRST = SPIS_CONFIG_ORDER_LsbFirst  
38  } nrf_spis_bit_order_t;
39  typedef enum
40  {
41      NRF_SPIS_SEMSTAT_FREE       = 0, 
42      NRF_SPIS_SEMSTAT_CPU        = 1, 
43      NRF_SPIS_SEMSTAT_SPIS       = 2, 
44      NRF_SPIS_SEMSTAT_CPUPENDING = 3  
45  } nrf_spis_semstat_t;
46  typedef enum
47  {
48      NRF_SPIS_STATUS_OVERREAD = SPIS_STATUS_OVERREAD_Msk, 
49      NRF_SPIS_STATUS_OVERFLOW = SPIS_STATUS_OVERFLOW_Msk  
50  } nrf_spis_status_mask_t;
51  NRF_STATIC_INLINE void nrf_spis_task_trigger(NRF_SPIS_Type * p_reg,
52                                               nrf_spis_task_t task);
53  NRF_STATIC_INLINE uint32_t nrf_spis_task_address_get(NRF_SPIS_Type const * p_reg,
54                                                       nrf_spis_task_t       task);
55  NRF_STATIC_INLINE void nrf_spis_event_clear(NRF_SPIS_Type *  p_reg,
56                                              nrf_spis_event_t event);
57  NRF_STATIC_INLINE bool nrf_spis_event_check(NRF_SPIS_Type const * p_reg,
58                                              nrf_spis_event_t      event);
59  NRF_STATIC_INLINE uint32_t nrf_spis_event_address_get(NRF_SPIS_Type const * p_reg,
60                                                        nrf_spis_event_t      event);
61  NRF_STATIC_INLINE void nrf_spis_shorts_enable(NRF_SPIS_Type * p_reg,
62                                                uint32_t        mask);
63  NRF_STATIC_INLINE void nrf_spis_shorts_disable(NRF_SPIS_Type * p_reg,
64                                                 uint32_t        mask);
65  NRF_STATIC_INLINE void nrf_spis_int_enable(NRF_SPIS_Type * p_reg,
66                                             uint32_t        mask);
67  NRF_STATIC_INLINE void nrf_spis_int_disable(NRF_SPIS_Type * p_reg,
68                                              uint32_t        mask);
69  NRF_STATIC_INLINE uint32_t nrf_spis_int_enable_check(NRF_SPIS_Type const * p_reg, uint32_t mask);
70  #if defined(DPPI_PRESENT) || defined(__NRFX_DOXYGEN__)
71  NRF_STATIC_INLINE void nrf_spis_subscribe_set(NRF_SPIS_Type * p_reg,
72                                                nrf_spis_task_t task,
73                                                uint8_t         channel);
74  NRF_STATIC_INLINE void nrf_spis_subscribe_clear(NRF_SPIS_Type * p_reg,
75                                                  nrf_spis_task_t task);
76  NRF_STATIC_INLINE void nrf_spis_publish_set(NRF_SPIS_Type *  p_reg,
77                                              nrf_spis_event_t event,
78                                              uint8_t          channel);
79  NRF_STATIC_INLINE void nrf_spis_publish_clear(NRF_SPIS_Type *  p_reg,
80                                                nrf_spis_event_t event);
81  #endif 
82  NRF_STATIC_INLINE void nrf_spis_enable(NRF_SPIS_Type * p_reg);
83  NRF_STATIC_INLINE void nrf_spis_disable(NRF_SPIS_Type * p_reg);
84  NRF_STATIC_INLINE nrf_spis_semstat_t nrf_spis_semaphore_status_get(NRF_SPIS_Type const * p_reg);
85  NRF_STATIC_INLINE nrf_spis_status_mask_t nrf_spis_status_get(NRF_SPIS_Type const * p_reg);
86  NRF_STATIC_INLINE void nrf_spis_pins_set(NRF_SPIS_Type * p_reg,
87                                           uint32_t        sck_pin,
88                                           uint32_t        mosi_pin,
89                                           uint32_t        miso_pin,
90                                           uint32_t        csn_pin);
91  NRF_STATIC_INLINE void nrf_spis_tx_buffer_set(NRF_SPIS_Type * p_reg,
92                                                uint8_t const * p_buffer,
93                                                size_t          length);
94  NRF_STATIC_INLINE void nrf_spis_rx_buffer_set(NRF_SPIS_Type * p_reg,
95                                                uint8_t *       p_buffer,
96                                                size_t          length);
97  NRF_STATIC_INLINE size_t nrf_spis_tx_amount_get(NRF_SPIS_Type const * p_reg);
98  NRF_STATIC_INLINE size_t nrf_spis_rx_amount_get(NRF_SPIS_Type const * p_reg);
99  NRF_STATIC_INLINE void nrf_spis_configure(NRF_SPIS_Type *      p_reg,
100                                            nrf_spis_mode_t      spi_mode,
101                                            nrf_spis_bit_order_t spi_bit_order);
102  NRF_STATIC_INLINE void nrf_spis_def_set(NRF_SPIS_Type * p_reg,
103                                          uint8_t         def);
104  NRF_STATIC_INLINE void nrf_spis_orc_set(NRF_SPIS_Type * p_reg,
105                                          uint8_t         orc);
106  #if defined(SPIS_TXD_LIST_LIST_Msk) || defined(__NRFX_DOXYGEN__)
107  NRF_STATIC_INLINE void nrf_spis_tx_list_enable(NRF_SPIS_Type * p_reg);
108  NRF_STATIC_INLINE void nrf_spis_tx_list_disable(NRF_SPIS_Type * p_reg);
109  #endif 
110  #if defined(SPIS_RXD_LIST_LIST_Msk) || defined(__NRFX_DOXYGEN__)
111  NRF_STATIC_INLINE void nrf_spis_rx_list_enable(NRF_SPIS_Type * p_reg);
112  NRF_STATIC_INLINE void nrf_spis_rx_list_disable(NRF_SPIS_Type * p_reg);
113  #endif 
114  #ifndef NRF_DECLARE_ONLY
115  NRF_STATIC_INLINE void nrf_spis_task_trigger(NRF_SPIS_Type * p_reg,
116                                               nrf_spis_task_t task)
117  {
118      *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
119  }
120  NRF_STATIC_INLINE uint32_t nrf_spis_task_address_get(NRF_SPIS_Type const * p_reg,
121                                                       nrf_spis_task_t       task)
122  {
123      return (uint32_t)p_reg + (uint32_t)task;
124  }
125  NRF_STATIC_INLINE void nrf_spis_event_clear(NRF_SPIS_Type *  p_reg,
126                                              nrf_spis_event_t event)
127  {
128      *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
129  #if __CORTEX_M == 0x04
130      volatile uint32_t dummy = *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event));
131      (void)dummy;
132  #endif
133  }
134  NRF_STATIC_INLINE bool nrf_spis_event_check(NRF_SPIS_Type const * p_reg,
135                                              nrf_spis_event_t      event)
136  {
137      return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
138  }
139  NRF_STATIC_INLINE uint32_t nrf_spis_event_address_get(NRF_SPIS_Type const * p_reg,
140                                                        nrf_spis_event_t      event)
141  {
142      return (uint32_t)p_reg + (uint32_t)event;
143  }
144  NRF_STATIC_INLINE void nrf_spis_shorts_enable(NRF_SPIS_Type * p_reg,
145                                                uint32_t        mask)
146  {
147      p_reg->SHORTS |= mask;
148  }
149  NRF_STATIC_INLINE void nrf_spis_shorts_disable(NRF_SPIS_Type * p_reg,
150                                                 uint32_t        mask)
151  {
152      p_reg->SHORTS &= ~(mask);
153  }
154  NRF_STATIC_INLINE void nrf_spis_int_enable(NRF_SPIS_Type * p_reg,
155                                             uint32_t        mask)
156  {
157      p_reg->INTENSET = mask;
158  }
159  NRF_STATIC_INLINE void nrf_spis_int_disable(NRF_SPIS_Type * p_reg,
160                                              uint32_t mask)
161  {
162      p_reg->INTENCLR = mask;
163  }
164  NRF_STATIC_INLINE uint32_t nrf_spis_int_enable_check(NRF_SPIS_Type const * p_reg, uint32_t mask)
165  {
166      return p_reg->INTENSET & mask;
167  }
168  #if defined(DPPI_PRESENT)
169  NRF_STATIC_INLINE void nrf_spis_subscribe_set(NRF_SPIS_Type * p_reg,
170                                                nrf_spis_task_t task,
171                                                uint8_t         channel)
172  {
173      *((volatile uint32_t *) ((uint8_t *) p_reg + (uint32_t) task + 0x80uL)) =
174              ((uint32_t)channel | SPIS_SUBSCRIBE_ACQUIRE_EN_Msk);
175  }
176  NRF_STATIC_INLINE void nrf_spis_subscribe_clear(NRF_SPIS_Type * p_reg,
177                                                  nrf_spis_task_t task)
178  {
179      *((volatile uint32_t *) ((uint8_t *) p_reg + (uint32_t) task + 0x80uL)) = 0;
180  }
181  NRF_STATIC_INLINE void nrf_spis_publish_set(NRF_SPIS_Type *  p_reg,
182                                              nrf_spis_event_t event,
183                                              uint8_t          channel)
184  {
185      *((volatile uint32_t *) ((uint8_t *) p_reg + (uint32_t) event + 0x80uL)) =
186              ((uint32_t)channel | SPIS_PUBLISH_END_EN_Msk);
187  }
188  NRF_STATIC_INLINE void nrf_spis_publish_clear(NRF_SPIS_Type *  p_reg,
189                                                nrf_spis_event_t event)
190  {
191      *((volatile uint32_t *) ((uint8_t *) p_reg + (uint32_t) event + 0x80uL)) = 0;
192  }
193  #endif 
194  NRF_STATIC_INLINE void nrf_spis_enable(NRF_SPIS_Type * p_reg)
195  {
196      p_reg->ENABLE = (SPIS_ENABLE_ENABLE_Enabled << SPIS_ENABLE_ENABLE_Pos);
197  }
198  NRF_STATIC_INLINE void nrf_spis_disable(NRF_SPIS_Type * p_reg)
199  {
200      p_reg->ENABLE = (SPIS_ENABLE_ENABLE_Disabled << SPIS_ENABLE_ENABLE_Pos);
201  }
202  NRF_STATIC_INLINE nrf_spis_semstat_t nrf_spis_semaphore_status_get(NRF_SPIS_Type const * p_reg)
203  {
204      return (nrf_spis_semstat_t) ((p_reg->SEMSTAT & SPIS_SEMSTAT_SEMSTAT_Msk)
205                                   >> SPIS_SEMSTAT_SEMSTAT_Pos);
206  }
207  NRF_STATIC_INLINE nrf_spis_status_mask_t nrf_spis_status_get(NRF_SPIS_Type const * p_reg)
208  {
209      return (nrf_spis_status_mask_t) p_reg->STATUS;
210  }
211  NRF_STATIC_INLINE void nrf_spis_pins_set(NRF_SPIS_Type * p_reg,
212                                           uint32_t        sck_pin,
<span onclick='openModal()' class='match'>213                                           uint32_t        mosi_pin,
214                                           uint32_t        miso_pin,
215                                           uint32_t        csn_pin)
216  {
217  #if defined (NRF51)
218      p_reg->PSELSCK  = sck_pin;
</span>219      p_reg->PSELMOSI = mosi_pin;
220      p_reg->PSELMISO = miso_pin;
221      p_reg->PSELCSN  = csn_pin;
222  #else
223      p_reg->PSEL.SCK  = sck_pin;
224      p_reg->PSEL.MOSI = mosi_pin;
225      p_reg->PSEL.MISO = miso_pin;
226      p_reg->PSEL.CSN  = csn_pin;
227  #endif
228  }
229  NRF_STATIC_INLINE void nrf_spis_tx_buffer_set(NRF_SPIS_Type * p_reg,
230                                                uint8_t const * p_buffer,
231                                                size_t          length)
232  {
233  #if defined (NRF51)
234      p_reg->TXDPTR = (uint32_t)p_buffer;
235      p_reg->MAXTX  = length;
236  #else
237      p_reg->TXD.PTR    = (uint32_t)p_buffer;
238      p_reg->TXD.MAXCNT = length;
239  #endif
240  }
241  NRF_STATIC_INLINE void nrf_spis_rx_buffer_set(NRF_SPIS_Type * p_reg,
242                                                uint8_t *       p_buffer,
243                                                size_t          length)
244  {
245  #if defined (NRF51)
246      p_reg->RXDPTR = (uint32_t)p_buffer;
247      p_reg->MAXRX  = length;
248  #else
249      p_reg->RXD.PTR    = (uint32_t)p_buffer;
250      p_reg->RXD.MAXCNT = length;
251  #endif
252  }
253  NRF_STATIC_INLINE size_t nrf_spis_tx_amount_get(NRF_SPIS_Type const * p_reg)
254  {
255  #if defined (NRF51)
256      return p_reg->AMOUNTTX;
257  #else
258      return p_reg->TXD.AMOUNT;
259  #endif
260  }
261  NRF_STATIC_INLINE size_t nrf_spis_rx_amount_get(NRF_SPIS_Type const * p_reg)
262  {
263  #if defined (NRF51)
264      return p_reg->AMOUNTRX;
265  #else
266      return p_reg->RXD.AMOUNT;
267  #endif
268  }
269  NRF_STATIC_INLINE void nrf_spis_configure(NRF_SPIS_Type *      p_reg,
270                                            nrf_spis_mode_t      spi_mode,
271                                            nrf_spis_bit_order_t spi_bit_order)
272  {
273      uint32_t config = (spi_bit_order == NRF_SPIS_BIT_ORDER_MSB_FIRST ?
274          SPIS_CONFIG_ORDER_MsbFirst : SPIS_CONFIG_ORDER_LsbFirst);
275      switch (spi_mode)
276      {
277      default:
278      case NRF_SPIS_MODE_0:
279          config |= (SPIS_CONFIG_CPOL_ActiveHigh << SPIS_CONFIG_CPOL_Pos) |
280                    (SPIS_CONFIG_CPHA_Leading    << SPIS_CONFIG_CPHA_Pos);
281          break;
282      case NRF_SPIS_MODE_1:
283          config |= (SPIS_CONFIG_CPOL_ActiveHigh << SPIS_CONFIG_CPOL_Pos) |
284                    (SPIS_CONFIG_CPHA_Trailing   << SPIS_CONFIG_CPHA_Pos);
285          break;
286      case NRF_SPIS_MODE_2:
287          config |= (SPIS_CONFIG_CPOL_ActiveLow  << SPIS_CONFIG_CPOL_Pos) |
288                    (SPIS_CONFIG_CPHA_Leading    << SPIS_CONFIG_CPHA_Pos);
289          break;
290      case NRF_SPIS_MODE_3:
291          config |= (SPIS_CONFIG_CPOL_ActiveLow  << SPIS_CONFIG_CPOL_Pos) |
292                    (SPIS_CONFIG_CPHA_Trailing   << SPIS_CONFIG_CPHA_Pos);
293          break;
294      }
295      p_reg->CONFIG = config;
296  }
297  NRF_STATIC_INLINE void nrf_spis_orc_set(NRF_SPIS_Type * p_reg,
298                                          uint8_t         orc)
299  {
300      p_reg->ORC = orc;
301  }
302  NRF_STATIC_INLINE void nrf_spis_def_set(NRF_SPIS_Type * p_reg,
303                                          uint8_t         def)
304  {
305      p_reg->DEF = def;
306  }
307  #if defined(SPIS_TXD_LIST_LIST_Msk)
308  NRF_STATIC_INLINE void nrf_spis_tx_list_enable(NRF_SPIS_Type * p_reg)
309  {
310      p_reg->TXD.LIST = SPIS_TXD_LIST_LIST_ArrayList << SPIS_TXD_LIST_LIST_Pos;
311  }
312  NRF_STATIC_INLINE void nrf_spis_tx_list_disable(NRF_SPIS_Type * p_reg)
313  {
314      p_reg->TXD.LIST = SPIS_TXD_LIST_LIST_Disabled << SPIS_TXD_LIST_LIST_Pos;
315  }
316  #endif 
317  #if defined(SPIS_RXD_LIST_LIST_Msk)
318  NRF_STATIC_INLINE void nrf_spis_rx_list_enable(NRF_SPIS_Type * p_reg)
319  {
320      p_reg->RXD.LIST = SPIS_RXD_LIST_LIST_ArrayList << SPIS_RXD_LIST_LIST_Pos;
321  }
322  NRF_STATIC_INLINE void nrf_spis_rx_list_disable(NRF_SPIS_Type * p_reg)
323  {
324      p_reg->RXD.LIST = SPIS_RXD_LIST_LIST_Disabled << SPIS_RXD_LIST_LIST_Pos;
325  }
326  #endif 
327  #endif 
328  #ifdef __cplusplus
329  }
330  #endif
331  #endif 
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from Adafruit_nRF52_Arduino-MDEwOlJlcG9zaXRvcnk3NDM1NDcyOQ==-flat-nrf_qdec.h</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from Adafruit_nRF52_Arduino-MDEwOlJlcG9zaXRvcnk3NDM1NDcyOQ==-flat-nrf_spis.h</div>
                </div>
                <div class="column column_space"><pre><code>146                                             uint32_t        psela,
147                                             uint32_t        pselb,
148                                             uint32_t        pselled)
149  {
150  #if defined(QDEC_PSEL_A_CONNECT_Pos)
151      p_reg->PSEL.A = psela;
</pre></code></div>
                <div class="column column_space"><pre><code>213                                           uint32_t        mosi_pin,
214                                           uint32_t        miso_pin,
215                                           uint32_t        csn_pin)
216  {
217  #if defined (NRF51)
218      p_reg->PSELSCK  = sck_pin;
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    