<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for LabS2LabQ.c &amp; thumbnail.c</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for LabS2LabQ.c &amp; thumbnail.c
      </h3>
<h1 align="center">
        2.4%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>LabS2LabQ.c (14.285714%)<th>thumbnail.c (1.323043%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(130-144)<td><a href="#" name="0">(205-225)</a><td align="center"><font color="#ff0000">12</font>
</td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>LabS2LabQ.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 #ifdef HAVE_CONFIG_H
2 #include &lt;config.h&gt;
3 #include &lt;vips/intl.h&gt;
4 #include &lt;stdio.h&gt;
5 #include &lt;vips/vips.h&gt;
6 #include "pcolour.h"
7 typedef VipsColourCode VipsLabS2LabQ;
8 typedef VipsColourCodeClass VipsLabS2LabQClass;
9 G_DEFINE_TYPE( VipsLabS2LabQ, vips_LabS2LabQ, VIPS_TYPE_COLOUR_CODE );
10 static void
11 vips_LabS2LabQ_line( VipsColour *colour, VipsPel *out, VipsPel **in, int width )
12 {
13 	signed short *p = (signed short *) in[0];
14 	unsigned char *q = (unsigned char *) out;
15 	int i;
16 	for( i = 0; i &lt; width; i++ ) {
17 		int l, a, b;
18 		unsigned char ext;
19 		l = p[0] + 16;
20 		l = VIPS_CLIP( 0, l, 32767 );
21 		l &gt;&gt;= 5;
22 		a = p[1];
23 		if( a &gt;= 0 )
24 			a += 16;
25 		else
26 			a -= 16;
27 		a = VIPS_CLIP( -32768, a, 32767 );
28 		a &gt;&gt;= 5;
29 		b = p[2];
30 		if( b &gt;= 0 )
31 			b += 16;
32 		else
33 			b -= 16;
34 		b = VIPS_CLIP( -32768, b, 32767 );
35 		b &gt;&gt;= 5;
36 		p += 3;
37 		q[0] = l &gt;&gt; 2;
38 		q[1] = a &gt;&gt; 3;
39 		q[2] = b &gt;&gt; 3;
40 		ext = (l &lt;&lt; 6) &amp; 0xc0;
41 		ext |= (a &lt;&lt; 3) &amp; 0x38;
42 		ext |= b &amp; 0x7;
43 		q[3] = ext;
44 		q += 4;
45 	}
46 }
47 static void
48 vips_LabS2LabQ_class_init( VipsLabS2LabQClass *class )
49 {
50 	VipsObjectClass *object_class = (VipsObjectClass *) class;
51 	VipsColourClass *colour_class = VIPS_COLOUR_CLASS( class );
52 	object_class-&gt;nickname = "LabS2LabQ";
53 <a name="0"></a>	object_class-&gt;description = _( "transform short Lab to LabQ coding" );
54 	colour_class-&gt;process_line = vips_LabS2LabQ_line;
55 <font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>}
56 static void
57 vips_LabS2LabQ_init( VipsLabS2LabQ *LabS2LabQ )
58 {
59 	VipsColour *colour = VIPS_COLOUR( LabS2LabQ );
60 	VipsColourCode *code = VIPS_COLOUR_CODE( LabS2LabQ );
61 	colour-&gt;coding = VIPS_CODING_LABQ;
62 	colour-&gt;interpretation = VIPS_INTERPRETATION_LABQ;
63 	colour-&gt;format = VIPS_FORMAT_UCHAR;
64 	colour-&gt;input_bands = 3;
65 	colour-&gt;bands = 4;
66 	code-&gt;input_coding = VIPS_CODING_NONE;</b></font>
67 	code-&gt;input_format = VIPS_FORMAT_SHORT;
68 }
69 int
70 vips_LabS2LabQ( VipsImage *in, VipsImage **out, ... )
71 {
72 	va_list ap;
73 	int result;
74 	va_start( ap, out );
75 	result = vips_call_split( "LabS2LabQ", ap, in, out );
76 	va_end( ap );
77 	return( result );
78 }
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>thumbnail.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 #ifdef HAVE_CONFIG_H
2 #include &lt;config.h&gt;
3 #include &lt;vips/intl.h&gt;
4 #include &lt;stdio.h&gt;
5 #include &lt;stdlib.h&gt;
6 #include &lt;math.h&gt;
7 #include &lt;vips/vips.h&gt;
8 #include &lt;vips/internal.h&gt;
9 #define VIPS_TYPE_THUMBNAIL (vips_thumbnail_get_type())
10 #define VIPS_THUMBNAIL( obj ) \
11 	(G_TYPE_CHECK_INSTANCE_CAST( (obj), VIPS_TYPE_THUMBNAIL, VipsThumbnail ))
12 #define VIPS_THUMBNAIL_CLASS( klass ) \
13 	(G_TYPE_CHECK_CLASS_CAST( (klass), \
14 		VIPS_TYPE_THUMBNAIL, VipsThumbnailClass))
15 #define VIPS_IS_THUMBNAIL( obj ) \
16 	(G_TYPE_CHECK_INSTANCE_TYPE( (obj), VIPS_TYPE_THUMBNAIL ))
17 #define VIPS_IS_THUMBNAIL_CLASS( klass ) \
18 	(G_TYPE_CHECK_CLASS_TYPE( (klass), VIPS_TYPE_THUMBNAIL ))
19 #define VIPS_THUMBNAIL_GET_CLASS( obj ) \
20 	(G_TYPE_INSTANCE_GET_CLASS( (obj), \
21 		VIPS_TYPE_THUMBNAIL, VipsThumbnailClass ))
22 #define MAX_LEVELS (256)
23 typedef struct _VipsThumbnail {
24 	VipsOperation parent_instance;
25 	VipsImage *out;
26 	int width;
27 	int height;
28 	VipsSize size;
29 	gboolean auto_rotate;
30 	gboolean no_rotate;
31 	VipsInteresting crop;
32 	gboolean linear;
33 	char *export_profile;
34 	char *import_profile;
35 	VipsIntent intent;
36 	const char *loader;			int input_width;
37 	int input_height;
38 	int page_height;
39 	int orientation; 			gboolean swap; 				int n_pages;				int n_loaded_pages;			int n_subifds;			
40 	int level_count;
41 	int level_width[MAX_LEVELS];
42 	int level_height[MAX_LEVELS];
43 	int heif_thumbnail_width;
44 	int heif_thumbnail_height;
45 	gboolean subifd_pyramid;
46 	gboolean page_pyramid;
47 } VipsThumbnail;
48 typedef struct _VipsThumbnailClass {
49 	VipsOperationClass parent_class;
50 	int (*get_info)( VipsThumbnail *thumbnail );  
51 	VipsImage *(*open)( VipsThumbnail *thumbnail, double factor );
52 } VipsThumbnailClass;
53 G_DEFINE_ABSTRACT_TYPE( VipsThumbnail, vips_thumbnail, VIPS_TYPE_OPERATION );
54 static void
55 vips_thumbnail_dispose( GObject *gobject )
56 {
57 #ifdef DEBUG
58 	printf( "vips_thumbnail_dispose: " );
59 	vips_object_print_name( VIPS_OBJECT( gobject ) );
60 	printf( "\n" );
61 	G_OBJECT_CLASS( vips_thumbnail_parent_class )-&gt;dispose( gobject );
62 }
63 static void
64 vips_thumbnail_finalize( GObject *gobject )
65 {
66 #ifdef DEBUG
67 	printf( "vips_thumbnail_finalize: " );
68 	vips_object_print_name( VIPS_OBJECT( gobject ) );
69 	printf( "\n" );
70 	G_OBJECT_CLASS( vips_thumbnail_parent_class )-&gt;finalize( gobject );
71 }
72 static int
73 get_int( VipsImage *image, const char *field, int default_value )
74 {
75 	const char *str;
76 	if( vips_image_get_typeof( image, field ) &amp;&amp;
77 		!vips_image_get_string( image, field, &amp;str ) ) 
78 <a name="0"></a>		return( atoi( str ) );
79 	return( default_value );
80 <font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>}
81 static void
82 vips_thumbnail_read_header( VipsThumbnail *thumbnail, VipsImage *image )
83 {
84 	thumbnail-&gt;input_width = image-&gt;Xsize;
85 	thumbnail-&gt;input_height = image-&gt;Ysize;
86 	thumbnail-&gt;orientation = vips_image_get_orientation( image );
87 	thumbnail-&gt;swap = vips_image_get_orientation_swap( image );
88 	thumbnail-&gt;page_height = vips_image_get_page_height( image );
89 	thumbnail-&gt;n_pages = vips_image_get_n_pages( image );
90 	thumbnail-&gt;n_subifds = vips_image_get_n_subifds( image );
91 	thumbnail-&gt;n_loaded_pages = </b></font>
92 		thumbnail-&gt;input_height / thumbnail-&gt;page_height;
93 	if( vips_isprefix( "VipsForeignLoadOpenslide", thumbnail-&gt;loader ) ) {
94 		int level_count;
95 		int level;
96 		level_count = get_int( image, "openslide.level-count", 1 );
97 		level_count = VIPS_CLIP( 1, level_count, MAX_LEVELS );
98 		thumbnail-&gt;level_count = level_count;
99 		for( level = 0; level &lt; level_count; level++ ) {
100 			char name[256];
101 			vips_snprintf( name, 256, 
102 				"openslide.level[%d].width", level );
103 			thumbnail-&gt;level_width[level] =
104 				 get_int( image, name, 0 );
105 			vips_snprintf( name, 256, 
106 				"openslide.level[%d].height", level );
107 			thumbnail-&gt;level_height[level] =
108 				get_int( image, name, 0 );
109 		}
110 	}
111 }
112 static void
113 vips_thumbnail_get_pyramid_page( VipsThumbnail *thumbnail ) 
114 {
115 	VipsThumbnailClass *class = VIPS_THUMBNAIL_GET_CLASS( thumbnail );
116 	int i;
117 #ifdef DEBUG
118 	printf( "vips_thumbnail_get_pyramid_page:\n" );
119 	if( thumbnail-&gt;n_pages &lt; 2 )
120 		return;
121 	for( i = 0; i &lt; thumbnail-&gt;n_pages; i++ ) {
122 		VipsImage *page;
123 		int level_width;
124 		int level_height;
125 		int expected_level_width;
126 		int expected_level_height;
127 		if( !(page = class-&gt;open( thumbnail, i )) )
128 			return;
129 		level_width = page-&gt;Xsize;
130 		level_height = page-&gt;Ysize;
131 		VIPS_UNREF( page );
132 		expected_level_width = thumbnail-&gt;input_width / (1 &lt;&lt; i);
133 		expected_level_height = thumbnail-&gt;input_height / (1 &lt;&lt; i);
134 		if( abs( level_width - expected_level_width ) &gt; 5 ||
135 			level_width &lt; 2 )
136 			return;
137 		if( abs( level_height - expected_level_height ) &gt; 5 ||
138 			level_height &lt; 2 )
139 			return;
140 		thumbnail-&gt;level_width[i] = level_width;
141 		thumbnail-&gt;level_height[i] = level_height;
142 	}
143 #ifdef DEBUG
144 	printf( "vips_thumbnail_get_pyramid_page: "
145 		"%d layer pyramid detected\n",
146 		thumbnail-&gt;n_pages );
147 	thumbnail-&gt;level_count = thumbnail-&gt;n_pages;
148 }
149 static void
150 vips_thumbnail_get_tiff_pyramid_subifd( VipsThumbnail *thumbnail ) 
151 {
152 	VipsThumbnailClass *class = VIPS_THUMBNAIL_GET_CLASS( thumbnail );
153 	int i;
154 #ifdef DEBUG
155 	printf( "vips_thumbnail_get_tiff_pyramid_subifd:\n" );
156 	for( i = 0; i &lt; thumbnail-&gt;n_subifds; i++ ) {
157 		VipsImage *page;
158 		int level_width;
159 		int level_height;
160 		int expected_level_width;
161 		int expected_level_height;
162 		if( !(page = class-&gt;open( thumbnail, i )) )
163 			return;
164 		level_width = page-&gt;Xsize;
165 		level_height = page-&gt;Ysize;
166 		VIPS_UNREF( page );
167 		expected_level_width = thumbnail-&gt;input_width / (2 &lt;&lt; i);
168 		expected_level_height = thumbnail-&gt;input_height / (2 &lt;&lt; i);
169 		if( abs( level_width - expected_level_width ) &gt; 5 ||
170 			level_width &lt; 2 )
171 			return;
172 		if( abs( level_height - expected_level_height ) &gt; 5 ||
173 			level_height &lt; 2 )
174 			return;
175 		thumbnail-&gt;level_width[i] = level_width;
176 		thumbnail-&gt;level_height[i] = level_height;
177 	}
178 #ifdef DEBUG
179 	printf( "vips_thumbnail_get_tiff_pyramid_subifd: "
180 		"%d layer pyramid detected\n",
181 		thumbnail-&gt;n_subifds );
182 	thumbnail-&gt;level_count = thumbnail-&gt;n_subifds;
183 }
184 static int
185 vips_thumbnail_get_heif_thumb_info( VipsThumbnail *thumbnail ) 
186 {
187 	VipsThumbnailClass *class = VIPS_THUMBNAIL_GET_CLASS( thumbnail );
188 	VipsImage *thumb;
189 	if( !(thumb = class-&gt;open( thumbnail, 1 )) )
190 		return( -1 );
191 	if( thumb-&gt;Xsize &lt; thumbnail-&gt;input_width ) {
192 		thumbnail-&gt;heif_thumbnail_width = thumb-&gt;Xsize;
193 		thumbnail-&gt;heif_thumbnail_height = thumb-&gt;Ysize;
194 	}
195 	VIPS_UNREF( thumb );
196 	return( 0 );
197 }
198 static void
199 vips_thumbnail_calculate_shrink( VipsThumbnail *thumbnail, 
200 	int input_width, int input_height, double *hshrink, double *vshrink )
201 {
202 	gboolean rotate = 
203 		thumbnail-&gt;swap &amp;&amp;
204 		thumbnail-&gt;auto_rotate;
205 	int target_width = rotate ? 
206 		thumbnail-&gt;height : thumbnail-&gt;width;
207 	int target_height = rotate ? 
208 		thumbnail-&gt;width : thumbnail-&gt;height;
209 	VipsDirection direction;
210 	*hshrink = (double) input_width / target_width;
211 	*vshrink = (double) input_height / target_height;
212 	if( thumbnail-&gt;crop != VIPS_INTERESTING_NONE ) {
213 		if( *hshrink &lt; *vshrink )
214 			direction = VIPS_DIRECTION_HORIZONTAL;
215 		else
216 			direction = VIPS_DIRECTION_VERTICAL;
217 	}
218 	else {
219 		if( *hshrink &lt; *vshrink )
220 			direction = VIPS_DIRECTION_VERTICAL;
221 		else
222 			direction = VIPS_DIRECTION_HORIZONTAL;
223 	}
224 	if( thumbnail-&gt;size != VIPS_SIZE_FORCE ) {
225 		if( direction == VIPS_DIRECTION_HORIZONTAL )
226 			*vshrink = *hshrink;
227 		else
228 			*hshrink = *vshrink;
229 	}
230 	if( thumbnail-&gt;size == VIPS_SIZE_UP ) {
231 		*hshrink = VIPS_MIN( 1, *hshrink );
232 		*vshrink = VIPS_MIN( 1, *vshrink );
233 	}
234 	else if( thumbnail-&gt;size == VIPS_SIZE_DOWN ) {
235 		*hshrink = VIPS_MAX( 1, *hshrink );
236 		*vshrink = VIPS_MAX( 1, *vshrink );
237 	}
238 	*hshrink = VIPS_MIN( *hshrink, input_width );
239 	*vshrink = VIPS_MIN( *vshrink, input_height );
240 }
241 static double
242 vips_thumbnail_calculate_common_shrink( VipsThumbnail *thumbnail, 
243 	int width, int height )
244 {
245 	double hshrink;
246 	double vshrink;
247 	double shrink;
248 	vips_thumbnail_calculate_shrink( thumbnail, width, height, 
249 		&amp;hshrink, &amp;vshrink ); 
250 	shrink = VIPS_MIN( hshrink, vshrink );
251 	return( shrink ); 
252 }
253 static int
254 vips_thumbnail_find_jpegshrink( VipsThumbnail *thumbnail, 
255 	int width, int height )
256 {
257 	double shrink = vips_thumbnail_calculate_common_shrink( thumbnail, 
258 		width, height ); 
259 	if( thumbnail-&gt;linear )
260 		return( 1 ); 
261 	if( shrink &gt;= 16 )
262 		return( 8 );
263 	else if( shrink &gt;= 8 )
264 		return( 4 );
265 	else if( shrink &gt;= 4 )
266 		return( 2 );
267 	else 
268 		return( 1 );
269 }
270 static int
271 vips_thumbnail_find_pyrlevel( VipsThumbnail *thumbnail, 
272 	int width, int height )
273 {
274 	int level;
275 	g_assert( thumbnail-&gt;level_count &gt; 0 );
276 	g_assert( thumbnail-&gt;level_count &lt;= MAX_LEVELS );
277 	for( level = thumbnail-&gt;level_count - 1; level &gt;= 0; level-- ) 
278 		if( vips_thumbnail_calculate_common_shrink( thumbnail, 
279 			thumbnail-&gt;level_width[level], 
280 			thumbnail-&gt;level_height[level] ) &gt;= 1.0 ) 
281 			return( level );
282 	return( 0 );
283 }
284 static VipsImage *
285 vips_thumbnail_open( VipsThumbnail *thumbnail )
286 {
287 	VipsThumbnailClass *class = VIPS_THUMBNAIL_GET_CLASS( thumbnail );
288 	VipsImage *im;
289 	double factor;
290 	if( class-&gt;get_info( thumbnail ) )
291 		return( NULL );
292 	g_info( "selected loader is %s", thumbnail-&gt;loader ); 
293 	g_info( "input size is %d x %d", 
294 		thumbnail-&gt;input_width, thumbnail-&gt;input_height ); 
295 	if( vips_isprefix( "VipsForeignLoadTiff", thumbnail-&gt;loader ) ) {
296 		thumbnail-&gt;subifd_pyramid = TRUE;
297 		vips_thumbnail_get_tiff_pyramid_subifd( thumbnail );
298 		if( thumbnail-&gt;level_count == 0 ) {
299 			thumbnail-&gt;subifd_pyramid = FALSE;
300 			thumbnail-&gt;page_pyramid = TRUE;
301 			vips_thumbnail_get_pyramid_page( thumbnail );
302 			if( thumbnail-&gt;level_count == 0 ) 
303 				thumbnail-&gt;page_pyramid = FALSE;
304 		}
305 	}
306 	if( vips_isprefix( "VipsForeignLoadJp2k", thumbnail-&gt;loader ) ) {
307 		if( thumbnail-&gt;level_count == 0 ) {
308 			thumbnail-&gt;subifd_pyramid = FALSE;
309 			thumbnail-&gt;page_pyramid = TRUE;
310 			vips_thumbnail_get_pyramid_page( thumbnail );
311 			if( thumbnail-&gt;level_count == 0 ) 
312 				thumbnail-&gt;page_pyramid = FALSE;
313 		}
314 	}
315 	if( vips_isprefix( "VipsForeignLoadHeif", thumbnail-&gt;loader ) ) 
316 		vips_thumbnail_get_heif_thumb_info( thumbnail );
317 	factor = 1.0;
318 	if( vips_isprefix( "VipsForeignLoadJpeg", thumbnail-&gt;loader ) ) 
319 		factor = vips_thumbnail_find_jpegshrink( thumbnail, 
320 			thumbnail-&gt;input_width, thumbnail-&gt;input_height );
321 	else if( vips_isprefix( "VipsForeignLoadTiff", thumbnail-&gt;loader ) ||
322 		vips_isprefix( "VipsForeignLoadJp2k", thumbnail-&gt;loader ) ||
323 		vips_isprefix( "VipsForeignLoadOpenslide", 
324 			thumbnail-&gt;loader ) ) {
325 		if( thumbnail-&gt;level_count &gt; 0 )
326 			factor = vips_thumbnail_find_pyrlevel( thumbnail, 
327 				thumbnail-&gt;input_width, 
328 				thumbnail-&gt;input_height );
329 	}
330 	else if( vips_isprefix( "VipsForeignLoadPdf", thumbnail-&gt;loader ) ||
331 		vips_isprefix( "VipsForeignLoadWebp", thumbnail-&gt;loader ) ||
332 		vips_isprefix( "VipsForeignLoadSvg", thumbnail-&gt;loader ) ) 
333 		factor = vips_thumbnail_calculate_common_shrink( thumbnail, 
334 			thumbnail-&gt;input_width, 
335 			thumbnail-&gt;page_height );
336 	else if( vips_isprefix( "VipsForeignLoadHeif", thumbnail-&gt;loader ) ) {
337 		double shrink_factor = vips_thumbnail_calculate_common_shrink( 
338 			thumbnail, 
339 			thumbnail-&gt;heif_thumbnail_width, 
340 			thumbnail-&gt;heif_thumbnail_height );
341 		factor = shrink_factor &gt; 1.0 ? 1 : 0;
342 	}
343 	g_info( "loading with factor %g pre-shrink", factor ); 
344 	if( !(im = class-&gt;open( thumbnail, factor )) )
345 		return( NULL );
346 	g_info( "pre-shrunk size is %d x %d", im-&gt;Xsize, im-&gt;Ysize ); 
347 	return( im ); 
348 }
349 static int
350 vips_thumbnail_build( VipsObject *object )
351 {
352 	VipsThumbnail *thumbnail = VIPS_THUMBNAIL( object );
353 	VipsImage **t = (VipsImage **) vips_object_local_array( object, 15 );
354 	VipsImage *in;
355 	int preshrunk_page_height;
356 	double hshrink;
357 	double vshrink;
358 	gboolean have_imported;
359 	VipsInterpretation input_interpretation;
360 	VipsBandFormat unpremultiplied_format;
361 #ifdef DEBUG
362 	printf( "vips_thumbnail_build: " );
363 	vips_object_print_name( object );
364 	printf( "\n" );
365 	if( VIPS_OBJECT_CLASS( vips_thumbnail_parent_class )-&gt;build( object ) )
366 		return( -1 );
367 	if( vips_object_argument_isset( object, "no_rotate" ) ) 
368 		thumbnail-&gt;auto_rotate = !thumbnail-&gt;no_rotate;
369 	if( !vips_object_argument_isset( object, "height" ) )
370 		thumbnail-&gt;height = thumbnail-&gt;width;
371 	if( !(t[0] = vips_thumbnail_open( thumbnail )) )
372 		return( -1 );
373 	in = t[0];
374 	preshrunk_page_height = vips_image_get_page_height( in );
375 	if( in-&gt;Coding == VIPS_CODING_RAD ) {
376 		g_info( "unpacking Rad to float" );
377 		if( vips_rad2float( in, &amp;t[12], NULL ) )
378 			return( -1 );
379 		in = t[12];
380 	}
381 	input_interpretation = in-&gt;Type;
382 	have_imported = FALSE;
383 	if( thumbnail-&gt;linear ) {
384 		if( in-&gt;Coding == VIPS_CODING_NONE &amp;&amp;
385 			(in-&gt;BandFmt == VIPS_FORMAT_UCHAR ||
386 			 in-&gt;BandFmt == VIPS_FORMAT_USHORT) &amp;&amp;
387 			(vips_image_get_typeof( in, VIPS_META_ICC_NAME ) || 
388 			 thumbnail-&gt;import_profile) ) {
389 			g_info( "importing to XYZ PCS" );
390 			if( thumbnail-&gt;import_profile ) 
391 				g_info( "fallback input profile %s", 
392 					thumbnail-&gt;import_profile );
393 			if( vips_icc_import( in, &amp;t[1], 
394 				"input_profile", thumbnail-&gt;import_profile,
395 				"embedded", TRUE,
396 				"intent", thumbnail-&gt;intent,
397 				"pcs", VIPS_PCS_XYZ,
398 				NULL ) )  
399 				return( -1 );
400 			in = t[1];
401 			have_imported = TRUE;
402 		}
403 		else {
404 			VipsInterpretation interpretation;
405 			if( in-&gt;Bands &lt; 3 )
406 				interpretation = VIPS_INTERPRETATION_GREY16; 
407 			else 
408 				interpretation = VIPS_INTERPRETATION_scRGB; 
409 			g_info( "converting to processing space %s",
410 				vips_enum_nick( VIPS_TYPE_INTERPRETATION, 
411 					interpretation ) ); 
412 			if( vips_colourspace( in, &amp;t[2], interpretation, 
413 				NULL ) ) 
414 				return( -1 ); 
415 			in = t[2];
416 		}
417 	}
418 	else {
419 		VipsInterpretation interpretation;
420 		if( in-&gt;Bands &lt; 3 )
421 			interpretation = VIPS_INTERPRETATION_B_W; 
422 		else 
423 			interpretation = VIPS_INTERPRETATION_sRGB; 
424 		g_info( "converting to processing space %s",
425 			vips_enum_nick( VIPS_TYPE_INTERPRETATION, 
426 				interpretation ) ); 
427 		if( vips_colourspace( in, &amp;t[2], interpretation, 
428 			NULL ) ) 
429 			return( -1 ); 
430 		in = t[2];
431 	}
432 	vips_thumbnail_calculate_shrink( thumbnail, 
433 		in-&gt;Xsize, preshrunk_page_height, &amp;hshrink, &amp;vshrink );
434 	if( in-&gt;Ysize &gt; preshrunk_page_height ) {
435 		int target_page_height = VIPS_RINT( 
436 			preshrunk_page_height / vshrink );
437 		int target_image_height = target_page_height * 
438 			thumbnail-&gt;n_loaded_pages;
439 		vshrink = (double) in-&gt;Ysize / target_image_height;
440 	}
441 	unpremultiplied_format = VIPS_FORMAT_NOTSET;
442 	if( vips_image_hasalpha( in ) &amp;&amp; 
443 	 	hshrink != 1.0 &amp;&amp;
444 		vshrink != 1.0  ) { 
445 		g_info( "premultiplying alpha" ); 
446 		unpremultiplied_format = in-&gt;BandFmt;
447 		if( vips_premultiply( in, &amp;t[3], NULL ) ) 
448 			return( -1 );
449 		in = t[3];
450 	}
451 	if( vips_resize( in, &amp;t[4], 1.0 / hshrink, 
452 		"vscale", 1.0 / vshrink, 
453 		NULL ) ) 
454 		return( -1 );
455 	in = t[4];
456 	if( unpremultiplied_format != VIPS_FORMAT_NOTSET ) {
457 		g_info( "unpremultiplying alpha" ); 
458 		if( vips_unpremultiply( in, &amp;t[5], NULL ) || 
459 			vips_cast( t[5], &amp;t[6], unpremultiplied_format, NULL ) )
460 			return( -1 );
461 		in = t[6];
462 	}
463 	if( thumbnail-&gt;n_loaded_pages &gt; 1 ) {
464 		int output_page_height = 
465 			VIPS_RINT( preshrunk_page_height / vshrink );
466 		if( vips_copy( in, &amp;t[13], NULL ) )
467 			return( -1 );
468 		in = t[13];
469 		vips_image_set_int( in, 
470 			VIPS_META_PAGE_HEIGHT, output_page_height );
471 	}
472 	if( have_imported ) { 
473 		if( thumbnail-&gt;export_profile ||
474 			vips_image_get_typeof( in, VIPS_META_ICC_NAME ) ) {
475 			g_info( "exporting to device space with a profile" );
476 			if( vips_icc_export( in, &amp;t[7], 
477 				"output_profile", thumbnail-&gt;export_profile,
478 				"intent", thumbnail-&gt;intent,
479 				NULL ) )  
480 				return( -1 );
481 			in = t[7];
482 		}
483 		else {
484 			g_info( "converting to sRGB" );
485 			if( vips_colourspace( in, &amp;t[7], 
486 				VIPS_INTERPRETATION_sRGB, NULL ) ) 
487 				return( -1 ); 
488 			in = t[7];
489 		}
490 	}
491 	else if( thumbnail-&gt;export_profile ) {
492 		g_info( "transforming to %s", thumbnail-&gt;export_profile );
493 		if( thumbnail-&gt;import_profile ||
494 			(vips_image_get_typeof( in, VIPS_META_ICC_NAME ) ||
495 			 thumbnail-&gt;import_profile) ) {
496 			g_info( "transforming with supplied profiles" ); 
497 			if( vips_icc_transform( in, &amp;t[7], 
498 				thumbnail-&gt;export_profile,
499 				"input_profile", thumbnail-&gt;import_profile,
500 				"intent", thumbnail-&gt;intent,
501 				"embedded", TRUE,
502 				NULL ) ) 
503 				return( -1 );
504 			in = t[7];
505 		}
506 		else {
507 			g_info( "exporting with %s", 
508 				thumbnail-&gt;export_profile ); 
509 			if( vips_colourspace( in, &amp;t[7], 
510 				VIPS_INTERPRETATION_XYZ, NULL ) || 
511 				vips_icc_export( t[7], &amp;t[10], 
512 					"output_profile", 
513 						thumbnail-&gt;export_profile,
514 					"intent", thumbnail-&gt;intent,
515 					NULL ) )  
516 				return( -1 ); 
517 			in = t[10];
518 		}
519 	}
520 	else if( thumbnail-&gt;linear ) {
521 		g_info( "reverting to input space %s",
522 			vips_enum_nick( VIPS_TYPE_INTERPRETATION, 
523 				input_interpretation ) ); 
524 		if( vips_colourspace( in, &amp;t[7], 
525 			input_interpretation, NULL ) ) 
526 			return( -1 ); 
527 		in = t[7];
528 	}
529 	if( thumbnail-&gt;auto_rotate &amp;&amp;
530 		thumbnail-&gt;orientation != 1 ) {
531 		g_info( "rotating by EXIF orientation %d", 
532 			thumbnail-&gt;orientation ); 
533 		if( !(t[9] = vips_image_copy_memory( in )) ||
534 			vips_autorot( t[9], &amp;t[14], NULL ) )
535 			return( -1 );
536 		in = t[14];
537 	}
538 	if( thumbnail-&gt;crop != VIPS_INTERESTING_NONE ) {
539 		int crop_width = VIPS_MIN( thumbnail-&gt;width, in-&gt;Xsize );
540 		int crop_height = VIPS_MIN( thumbnail-&gt;height, in-&gt;Ysize );
541 		g_info( "cropping to %dx%d", crop_width, crop_height ); 
542 		if( !(t[8] = vips_image_copy_memory( in )) ||
543 			vips_smartcrop( t[8], &amp;t[11], 
544 				crop_width, crop_height, 
545 				"interesting", thumbnail-&gt;crop,
546 				NULL ) )
547 			return( -1 ); 
548 		in = t[11];
549 	}
550 	g_object_set( thumbnail, "out", vips_image_new(), NULL ); 
551 	if( vips_image_write( in, thumbnail-&gt;out ) )
552 		return( -1 );
553 	return( 0 );
554 }
555 static void
556 vips_thumbnail_class_init( VipsThumbnailClass *class )
557 {
558 	GObjectClass *gobject_class = G_OBJECT_CLASS( class );
559 	VipsObjectClass *vobject_class = VIPS_OBJECT_CLASS( class );
560 	VipsOperationClass *operation_class = VIPS_OPERATION_CLASS( class );
561 	gobject_class-&gt;dispose = vips_thumbnail_dispose;
562 	gobject_class-&gt;finalize = vips_thumbnail_finalize;
563 	gobject_class-&gt;set_property = vips_object_set_property;
564 	gobject_class-&gt;get_property = vips_object_get_property;
565 	vobject_class-&gt;nickname = "thumbnail_base";
566 	vobject_class-&gt;description = _( "thumbnail generation" );
567 	vobject_class-&gt;build = vips_thumbnail_build;
568 	operation_class-&gt;flags = VIPS_OPERATION_NOCACHE;
569 	VIPS_ARG_IMAGE( class, "out", 2, 
570 		_( "Output" ), 
571 		_( "Output image" ),
572 		VIPS_ARGUMENT_REQUIRED_OUTPUT, 
573 		G_STRUCT_OFFSET( VipsThumbnail, out ) );
574 	VIPS_ARG_INT( class, "width", 3, 
575 		_( "Target width" ), 
576 		_( "Size to this width" ),
577 		VIPS_ARGUMENT_REQUIRED_INPUT,
578 		G_STRUCT_OFFSET( VipsThumbnail, width ),
579 		1, VIPS_MAX_COORD, 1 );
580 	VIPS_ARG_INT( class, "height", 113, 
581 		_( "Target height" ), 
582 		_( "Size to this height" ),
583 		VIPS_ARGUMENT_OPTIONAL_INPUT,
584 		G_STRUCT_OFFSET( VipsThumbnail, height ),
585 		1, VIPS_MAX_COORD, 1 );
586 	VIPS_ARG_ENUM( class, "size", 114, 
587 		_( "size" ), 
588 		_( "Only upsize, only downsize, or both" ),
589 		VIPS_ARGUMENT_OPTIONAL_INPUT,
590 		G_STRUCT_OFFSET( VipsThumbnail, size ),
591 		VIPS_TYPE_SIZE, VIPS_SIZE_BOTH ); 
592 	VIPS_ARG_BOOL( class, "no_rotate", 115, 
593 		_( "No rotate" ), 
594 		_( "Don't use orientation tags to rotate image upright" ),
595 		VIPS_ARGUMENT_OPTIONAL_INPUT,
596 		G_STRUCT_OFFSET( VipsThumbnail, no_rotate ),
597 		FALSE ); 
598 	VIPS_ARG_ENUM( class, "crop", 116, 
599 		_( "Crop" ), 
600 		_( "Reduce to fill target rectangle, then crop" ),
601 		VIPS_ARGUMENT_OPTIONAL_INPUT,
602 		G_STRUCT_OFFSET( VipsThumbnail, crop ),
603 		VIPS_TYPE_INTERESTING, VIPS_INTERESTING_NONE ); 
604 	VIPS_ARG_BOOL( class, "linear", 117, 
605 		_( "Linear" ), 
606 		_( "Reduce in linear light" ),
607 		VIPS_ARGUMENT_OPTIONAL_INPUT,
608 		G_STRUCT_OFFSET( VipsThumbnail, linear ),
609 		FALSE ); 
610 	VIPS_ARG_STRING( class, "import_profile", 118, 
611 		_( "Import profile" ), 
612 		_( "Fallback import profile" ),
613 		VIPS_ARGUMENT_OPTIONAL_INPUT,
614 		G_STRUCT_OFFSET( VipsThumbnail, import_profile ),
615 		NULL ); 
616 	VIPS_ARG_STRING( class, "export_profile", 119, 
617 		_( "Export profile" ), 
618 		_( "Fallback export profile" ),
619 		VIPS_ARGUMENT_OPTIONAL_INPUT,
620 		G_STRUCT_OFFSET( VipsThumbnail, export_profile ),
621 		NULL ); 
622 	VIPS_ARG_ENUM( class, "intent", 120, 
623 		_( "Intent" ), 
624 		_( "Rendering intent" ),
625 		VIPS_ARGUMENT_OPTIONAL_INPUT,
626 		G_STRUCT_OFFSET( VipsThumbnail, intent ),
627 		VIPS_TYPE_INTENT, VIPS_INTENT_RELATIVE );
628 	VIPS_ARG_BOOL( class, "auto_rotate", 121, 
629 		_( "Auto rotate" ), 
630 		_( "Use orientation tags to rotate image upright" ),
631 		VIPS_ARGUMENT_OPTIONAL_INPUT | VIPS_ARGUMENT_DEPRECATED,
632 		G_STRUCT_OFFSET( VipsThumbnail, auto_rotate ),
633 		TRUE ); 
634 }
635 static void
636 vips_thumbnail_init( VipsThumbnail *thumbnail )
637 {
638 	thumbnail-&gt;width = 1;
639 	thumbnail-&gt;height = 1;
640 	thumbnail-&gt;auto_rotate = TRUE;
641 	thumbnail-&gt;intent = VIPS_INTENT_RELATIVE;
642 }
643 typedef struct _VipsThumbnailFile {
644 	VipsThumbnail parent_object;
645 	char *filename; 
646 } VipsThumbnailFile;
647 typedef VipsThumbnailClass VipsThumbnailFileClass;
648 G_DEFINE_TYPE( VipsThumbnailFile, vips_thumbnail_file, 
649 	vips_thumbnail_get_type() );
650 static int
651 vips_thumbnail_file_get_info( VipsThumbnail *thumbnail )
652 {
653 	VipsThumbnailFile *file = (VipsThumbnailFile *) thumbnail;
654 	VipsImage *image;
655 	g_info( "thumbnailing %s", file-&gt;filename ); 
656 	if( !(thumbnail-&gt;loader = vips_foreign_find_load( file-&gt;filename )) ||
657 		!(image = vips_image_new_from_file( file-&gt;filename, NULL )) )
658 		return( -1 );
659 	vips_thumbnail_read_header( thumbnail, image );
660 	g_object_unref( image );
661 	return( 0 );
662 }
663 static VipsImage *
664 vips_thumbnail_file_open( VipsThumbnail *thumbnail, double factor )
665 {
666 	VipsThumbnailFile *file = (VipsThumbnailFile *) thumbnail;
667 	if( vips_isprefix( "VipsForeignLoadJpeg", thumbnail-&gt;loader ) ) {
668 		return( vips_image_new_from_file( file-&gt;filename, 
669 			"access", VIPS_ACCESS_SEQUENTIAL,
670 			"shrink", (int) factor,
671 			NULL ) );
672 	}
673 	else if( vips_isprefix( "VipsForeignLoadOpenslide", 
674 		thumbnail-&gt;loader ) ) {
675 		return( vips_image_new_from_file( file-&gt;filename, 
676 			"access", VIPS_ACCESS_SEQUENTIAL,
677 			"level", (int) factor,
678 			NULL ) );
679 	}
680 	else if( vips_isprefix( "VipsForeignLoadPdf", thumbnail-&gt;loader ) ||
681 		vips_isprefix( "VipsForeignLoadSvg", thumbnail-&gt;loader ) ||
682 		vips_isprefix( "VipsForeignLoadWebp", thumbnail-&gt;loader ) ) {
683 		return( vips_image_new_from_file( file-&gt;filename, 
684 			"access", VIPS_ACCESS_SEQUENTIAL,
685 			"scale", 1.0 / factor,
686 			NULL ) );
687 	}
688 	else if( vips_isprefix( "VipsForeignLoadJp2k", thumbnail-&gt;loader ) ) {
689 		if( thumbnail-&gt;page_pyramid )
690 			return( vips_image_new_from_file( file-&gt;filename, 
691 				"access", VIPS_ACCESS_SEQUENTIAL,
692 				"page", (int) factor,
693 				NULL ) );
694 		else
695 			return( vips_image_new_from_file( file-&gt;filename, 
696 				"access", VIPS_ACCESS_SEQUENTIAL,
697 				NULL ) );
698 	}
699 	else if( vips_isprefix( "VipsForeignLoadTiff", thumbnail-&gt;loader ) ) {
700 		if( thumbnail-&gt;subifd_pyramid )
701 			return( vips_image_new_from_file( file-&gt;filename, 
702 				"access", VIPS_ACCESS_SEQUENTIAL,
703 				"subifd", (int) factor,
704 				NULL ) );
705 		else if( thumbnail-&gt;page_pyramid )
706 			return( vips_image_new_from_file( file-&gt;filename, 
707 				"access", VIPS_ACCESS_SEQUENTIAL,
708 				"page", (int) factor,
709 				NULL ) );
710 		else
711 			return( vips_image_new_from_file( file-&gt;filename, 
712 				"access", VIPS_ACCESS_SEQUENTIAL,
713 				NULL ) );
714 	}
715 	else if( vips_isprefix( "VipsForeignLoadHeif", thumbnail-&gt;loader ) ) {
716 		return( vips_image_new_from_file( file-&gt;filename, 
717 			"access", VIPS_ACCESS_SEQUENTIAL,
718 			"thumbnail", (int) factor,
719 			NULL ) );
720 	}
721 	else {
722 		return( vips_image_new_from_file( file-&gt;filename, 
723 			"access", VIPS_ACCESS_SEQUENTIAL,
724 			NULL ) );
725 	}
726 }
727 static void
728 vips_thumbnail_file_class_init( VipsThumbnailClass *class )
729 {
730 	GObjectClass *gobject_class = G_OBJECT_CLASS( class );
731 	VipsObjectClass *vobject_class = VIPS_OBJECT_CLASS( class );
732 	VipsThumbnailClass *thumbnail_class = VIPS_THUMBNAIL_CLASS( class );
733 	gobject_class-&gt;set_property = vips_object_set_property;
734 	gobject_class-&gt;get_property = vips_object_get_property;
735 	vobject_class-&gt;nickname = "thumbnail";
736 	vobject_class-&gt;description = _( "generate thumbnail from file" );
737 	thumbnail_class-&gt;get_info = vips_thumbnail_file_get_info;
738 	thumbnail_class-&gt;open = vips_thumbnail_file_open;
739 	VIPS_ARG_STRING( class, "filename", 1, 
740 		_( "Filename" ),
741 		_( "Filename to read from" ),
742 		VIPS_ARGUMENT_REQUIRED_INPUT, 
743 		G_STRUCT_OFFSET( VipsThumbnailFile, filename ),
744 		NULL );
745 }
746 static void
747 vips_thumbnail_file_init( VipsThumbnailFile *file )
748 {
749 }
750 int
751 vips_thumbnail( const char *filename, VipsImage **out, int width, ... )
752 {
753 	va_list ap;
754 	int result;
755 	va_start( ap, width );
756 	result = vips_call_split( "thumbnail", ap, filename, out, width );
757 	va_end( ap );
758 	return( result );
759 }
760 typedef struct _VipsThumbnailBuffer {
761 	VipsThumbnail parent_object;
762 	VipsArea *buf;
763 	char *option_string;
764 } VipsThumbnailBuffer;
765 typedef VipsThumbnailClass VipsThumbnailBufferClass;
766 G_DEFINE_TYPE( VipsThumbnailBuffer, vips_thumbnail_buffer, 
767 	vips_thumbnail_get_type() );
768 static int
769 vips_thumbnail_buffer_get_info( VipsThumbnail *thumbnail )
770 {
771 	VipsThumbnailBuffer *buffer = (VipsThumbnailBuffer *) thumbnail;
772 	VipsImage *image;
773 	g_info( "thumbnailing %zd bytes of data", buffer-&gt;buf-&gt;length ); 
774 	if( !(thumbnail-&gt;loader = vips_foreign_find_load_buffer( 
775 			buffer-&gt;buf-&gt;data, buffer-&gt;buf-&gt;length )) ||
776 		!(image = vips_image_new_from_buffer( 
777 			buffer-&gt;buf-&gt;data, buffer-&gt;buf-&gt;length, 
778 			buffer-&gt;option_string, NULL )) )
779 		return( -1 );
780 	vips_thumbnail_read_header( thumbnail, image );
781 	g_object_unref( image );
782 	return( 0 );
783 }
784 static VipsImage *
785 vips_thumbnail_buffer_open( VipsThumbnail *thumbnail, double factor )
786 {
787 	VipsThumbnailBuffer *buffer = (VipsThumbnailBuffer *) thumbnail;
788 	if( vips_isprefix( "VipsForeignLoadJpeg", thumbnail-&gt;loader ) ) {
789 		return( vips_image_new_from_buffer( 
790 			buffer-&gt;buf-&gt;data, buffer-&gt;buf-&gt;length, 
791 			buffer-&gt;option_string,
792 			"access", VIPS_ACCESS_SEQUENTIAL,
793 			"shrink", (int) factor,
794 			NULL ) );
795 	}
796 	else if( vips_isprefix( "VipsForeignLoadOpenslide", 
797 		thumbnail-&gt;loader ) ) {
798 		return( vips_image_new_from_buffer( 
799 			buffer-&gt;buf-&gt;data, buffer-&gt;buf-&gt;length, 
800 			buffer-&gt;option_string,
801 			"access", VIPS_ACCESS_SEQUENTIAL,
802 			"level", (int) factor,
803 			NULL ) );
804 	}
805 	else if( vips_isprefix( "VipsForeignLoadPdf", thumbnail-&gt;loader ) ||
806 		vips_isprefix( "VipsForeignLoadSvg", thumbnail-&gt;loader ) ||
807 		vips_isprefix( "VipsForeignLoadWebp", thumbnail-&gt;loader ) ) {
808 		return( vips_image_new_from_buffer( 
809 			buffer-&gt;buf-&gt;data, buffer-&gt;buf-&gt;length, 
810 			buffer-&gt;option_string,
811 			"access", VIPS_ACCESS_SEQUENTIAL,
812 			"scale", 1.0 / factor,
813 			NULL ) );
814 	}
815 	else if( vips_isprefix( "VipsForeignLoadJp2k", thumbnail-&gt;loader ) ) {
816 		if( thumbnail-&gt;page_pyramid )
817 			return( vips_image_new_from_buffer( 
818 				buffer-&gt;buf-&gt;data, buffer-&gt;buf-&gt;length, 
819 				buffer-&gt;option_string,
820 				"access", VIPS_ACCESS_SEQUENTIAL,
821 				"page", (int) factor,
822 				NULL ) );
823 		else
824 			return( vips_image_new_from_buffer( 
825 				buffer-&gt;buf-&gt;data, buffer-&gt;buf-&gt;length, 
826 				buffer-&gt;option_string,
827 				"access", VIPS_ACCESS_SEQUENTIAL,
828 				NULL ) );
829 	}
830 	else if( vips_isprefix( "VipsForeignLoadTiff", thumbnail-&gt;loader ) ) {
831 		if( thumbnail-&gt;subifd_pyramid )
832 			return( vips_image_new_from_buffer( 
833 				buffer-&gt;buf-&gt;data, buffer-&gt;buf-&gt;length, 
834 				buffer-&gt;option_string,
835 				"access", VIPS_ACCESS_SEQUENTIAL,
836 				"subifd", (int) factor,
837 				NULL ) );
838 		else if( thumbnail-&gt;page_pyramid )
839 			return( vips_image_new_from_buffer( 
840 				buffer-&gt;buf-&gt;data, buffer-&gt;buf-&gt;length, 
841 				buffer-&gt;option_string,
842 				"access", VIPS_ACCESS_SEQUENTIAL,
843 				"page", (int) factor,
844 				NULL ) );
845 		else
846 			return( vips_image_new_from_buffer( 
847 				buffer-&gt;buf-&gt;data, buffer-&gt;buf-&gt;length, 
848 				buffer-&gt;option_string,
849 				"access", VIPS_ACCESS_SEQUENTIAL,
850 				NULL ) );
851 	}
852 	else if( vips_isprefix( "VipsForeignLoadHeif", thumbnail-&gt;loader ) ) {
853 		return( vips_image_new_from_buffer( 
854 			buffer-&gt;buf-&gt;data, buffer-&gt;buf-&gt;length, 
855 			buffer-&gt;option_string,
856 			"access", VIPS_ACCESS_SEQUENTIAL,
857 			"thumbnail", (int) factor,
858 			NULL ) );
859 	}
860 	else {
861 		return( vips_image_new_from_buffer( 
862 			buffer-&gt;buf-&gt;data, buffer-&gt;buf-&gt;length, 
863 			buffer-&gt;option_string,
864 			"access", VIPS_ACCESS_SEQUENTIAL,
865 			NULL ) );
866 	}
867 }
868 static void
869 vips_thumbnail_buffer_class_init( VipsThumbnailClass *class )
870 {
871 	GObjectClass *gobject_class = G_OBJECT_CLASS( class );
872 	VipsObjectClass *vobject_class = VIPS_OBJECT_CLASS( class );
873 	VipsThumbnailClass *thumbnail_class = VIPS_THUMBNAIL_CLASS( class );
874 	gobject_class-&gt;set_property = vips_object_set_property;
875 	gobject_class-&gt;get_property = vips_object_get_property;
876 	vobject_class-&gt;nickname = "thumbnail_buffer";
877 	vobject_class-&gt;description = _( "generate thumbnail from buffer" );
878 	thumbnail_class-&gt;get_info = vips_thumbnail_buffer_get_info;
879 	thumbnail_class-&gt;open = vips_thumbnail_buffer_open;
880 	VIPS_ARG_BOXED( class, "buffer", 1, 
881 		_( "Buffer" ),
882 		_( "Buffer to load from" ),
883 		VIPS_ARGUMENT_REQUIRED_INPUT, 
884 		G_STRUCT_OFFSET( VipsThumbnailBuffer, buf ),
885 		VIPS_TYPE_BLOB );
886 	VIPS_ARG_STRING( class, "option_string", 20,
887 		_( "Extra options" ),
888 		_( "Options that are passed on to the underlying loader" ),
889 		VIPS_ARGUMENT_OPTIONAL_INPUT,
890 		G_STRUCT_OFFSET( VipsThumbnailBuffer, option_string ),
891 		"" );
892 }
893 static void
894 vips_thumbnail_buffer_init( VipsThumbnailBuffer *buffer )
895 {
896 }
897 int
898 vips_thumbnail_buffer( void *buf, size_t len, VipsImage **out, int width, ... )
899 {
900 	va_list ap;
901 	VipsBlob *blob;
902 	int result;
903 	blob = vips_blob_new( NULL, buf, len );
904 	va_start( ap, width );
905 	result = vips_call_split( "thumbnail_buffer", ap, blob, out, width );
906 	va_end( ap );
907 	vips_area_unref( VIPS_AREA( blob ) );
908 	return( result );
909 }
910 typedef struct _VipsThumbnailSource {
911 	VipsThumbnail parent_object;
912 	VipsSource *source;
913 	char *option_string;
914 } VipsThumbnailSource;
915 typedef VipsThumbnailClass VipsThumbnailSourceClass;
916 G_DEFINE_TYPE( VipsThumbnailSource, vips_thumbnail_source, 
917 	vips_thumbnail_get_type() );
918 static int
919 vips_thumbnail_source_get_info( VipsThumbnail *thumbnail )
920 {
921 	VipsThumbnailSource *source = (VipsThumbnailSource *) thumbnail;
922 	VipsImage *image;
923 	g_info( "thumbnailing source" ); 
924 	if( !(thumbnail-&gt;loader = vips_foreign_find_load_source( 
925 			source-&gt;source )) ||
926 		!(image = vips_image_new_from_source( source-&gt;source, 
927 			source-&gt;option_string, NULL )) )
928 		return( -1 );
929 	vips_thumbnail_read_header( thumbnail, image );
930 	g_object_unref( image );
931 	return( 0 );
932 }
933 static VipsImage *
934 vips_thumbnail_source_open( VipsThumbnail *thumbnail, double factor )
935 {
936 	VipsThumbnailSource *source = (VipsThumbnailSource *) thumbnail;
937 	if( vips_isprefix( "VipsForeignLoadJpeg", thumbnail-&gt;loader ) ) {
938 		return( vips_image_new_from_source( 
939 			source-&gt;source, 
940 			source-&gt;option_string,
941 			"access", VIPS_ACCESS_SEQUENTIAL,
942 			"shrink", (int) factor,
943 			NULL ) );
944 	}
945 	else if( vips_isprefix( "VipsForeignLoadOpenslide", 
946 		thumbnail-&gt;loader ) ) {
947 		return( vips_image_new_from_source( 
948 			source-&gt;source, 
949 			source-&gt;option_string,
950 			"access", VIPS_ACCESS_SEQUENTIAL,
951 			"level", (int) factor,
952 			NULL ) );
953 	}
954 	else if( vips_isprefix( "VipsForeignLoadPdf", thumbnail-&gt;loader ) ||
955 		vips_isprefix( "VipsForeignLoadSvg", thumbnail-&gt;loader ) ||
956 		vips_isprefix( "VipsForeignLoadWebp", thumbnail-&gt;loader ) ) {
957 		return( vips_image_new_from_source( 
958 			source-&gt;source, 
959 			source-&gt;option_string,
960 			"access", VIPS_ACCESS_SEQUENTIAL,
961 			"scale", 1.0 / factor,
962 			NULL ) );
963 	}
964 	else if( vips_isprefix( "VipsForeignLoadJp2k", thumbnail-&gt;loader ) ) {
965 		if( thumbnail-&gt;page_pyramid )
966 			return( vips_image_new_from_source(
967 				source-&gt;source, 
968 				source-&gt;option_string,
969 				"access", VIPS_ACCESS_SEQUENTIAL,
970 				"page", (int) factor,
971 				NULL ) );
972 		else
973 			return( vips_image_new_from_source(
974 				source-&gt;source, 
975 				source-&gt;option_string,
976 				"access", VIPS_ACCESS_SEQUENTIAL,
977 				NULL ) );
978 	}
979 	else if( vips_isprefix( "VipsForeignLoadTiff", thumbnail-&gt;loader ) ) {
980 		if( thumbnail-&gt;subifd_pyramid )
981 			return( vips_image_new_from_source(
982 				source-&gt;source, 
983 				source-&gt;option_string,
984 				"access", VIPS_ACCESS_SEQUENTIAL,
985 				"subifd", (int) factor,
986 				NULL ) );
987 		else if( thumbnail-&gt;page_pyramid )
988 			return( vips_image_new_from_source(
989 				source-&gt;source, 
990 				source-&gt;option_string,
991 				"access", VIPS_ACCESS_SEQUENTIAL,
992 				"page", (int) factor,
993 				NULL ) );
994 		else
995 			return( vips_image_new_from_source(
996 				source-&gt;source, 
997 				source-&gt;option_string,
998 				"access", VIPS_ACCESS_SEQUENTIAL,
999 				NULL ) );
1000 	}
1001 	else if( vips_isprefix( "VipsForeignLoadHeif", thumbnail-&gt;loader ) ) {
1002 		return( vips_image_new_from_source( 
1003 			source-&gt;source, 
1004 			source-&gt;option_string,
1005 			"access", VIPS_ACCESS_SEQUENTIAL,
1006 			"thumbnail", (int) factor,
1007 			NULL ) );
1008 	}
1009 	else {
1010 		return( vips_image_new_from_source( 
1011 			source-&gt;source, 
1012 			source-&gt;option_string,
1013 			"access", VIPS_ACCESS_SEQUENTIAL,
1014 			NULL ) );
1015 	}
1016 }
1017 static void
1018 vips_thumbnail_source_class_init( VipsThumbnailClass *class )
1019 {
1020 	GObjectClass *gobject_class = G_OBJECT_CLASS( class );
1021 	VipsObjectClass *vobject_class = VIPS_OBJECT_CLASS( class );
1022 	VipsThumbnailClass *thumbnail_class = VIPS_THUMBNAIL_CLASS( class );
1023 	gobject_class-&gt;set_property = vips_object_set_property;
1024 	gobject_class-&gt;get_property = vips_object_get_property;
1025 	vobject_class-&gt;nickname = "thumbnail_source";
1026 	vobject_class-&gt;description = _( "generate thumbnail from source" );
1027 	thumbnail_class-&gt;get_info = vips_thumbnail_source_get_info;
1028 	thumbnail_class-&gt;open = vips_thumbnail_source_open;
1029 	VIPS_ARG_OBJECT( class, "source", 1,
1030 		_( "Source" ),
1031 		_( "Source to load from" ),
1032 		VIPS_ARGUMENT_REQUIRED_INPUT, 
1033 		G_STRUCT_OFFSET( VipsThumbnailSource, source ),
1034 		VIPS_TYPE_SOURCE );
1035 	VIPS_ARG_STRING( class, "option_string", 20,
1036 		_( "Extra options" ),
1037 		_( "Options that are passed on to the underlying loader" ),
1038 		VIPS_ARGUMENT_OPTIONAL_INPUT,
1039 		G_STRUCT_OFFSET( VipsThumbnailSource, option_string ),
1040 		"" );
1041 }
1042 static void
1043 vips_thumbnail_source_init( VipsThumbnailSource *source )
1044 {
1045 }
1046 int
1047 vips_thumbnail_source( VipsSource *source, VipsImage **out, int width, ... )
1048 {
1049 	va_list ap;
1050 	int result;
1051 	va_start( ap, width );
1052 	result = vips_call_split( "thumbnail_source", ap, source, out, width );
1053 	va_end( ap );
1054 	return( result );
1055 }
1056 typedef struct _VipsThumbnailImage {
1057 	VipsThumbnail parent_object;
1058 	VipsImage *in;
1059 } VipsThumbnailImage;
1060 typedef VipsThumbnailClass VipsThumbnailImageClass;
1061 G_DEFINE_TYPE( VipsThumbnailImage, vips_thumbnail_image, 
1062 	vips_thumbnail_get_type() );
1063 static int
1064 vips_thumbnail_image_get_info( VipsThumbnail *thumbnail )
1065 {
1066 	VipsThumbnailImage *image = (VipsThumbnailImage *) thumbnail;
1067 	thumbnail-&gt;loader = "image source";
1068 	vips_thumbnail_read_header( thumbnail, image-&gt;in );
1069 	return( 0 );
1070 }
1071 static VipsImage *
1072 vips_thumbnail_image_open( VipsThumbnail *thumbnail, double factor )
1073 {
1074 	VipsThumbnailImage *image = (VipsThumbnailImage *) thumbnail;
1075 	g_object_ref( image-&gt;in ); 
1076 	return( image-&gt;in ); 
1077 }
1078 static void
1079 vips_thumbnail_image_class_init( VipsThumbnailClass *class )
1080 {
1081 	GObjectClass *gobject_class = G_OBJECT_CLASS( class );
1082 	VipsObjectClass *vobject_class = VIPS_OBJECT_CLASS( class );
1083 	VipsThumbnailClass *thumbnail_class = VIPS_THUMBNAIL_CLASS( class );
1084 	gobject_class-&gt;set_property = vips_object_set_property;
1085 	gobject_class-&gt;get_property = vips_object_get_property;
1086 	vobject_class-&gt;nickname = "thumbnail_image";
1087 	vobject_class-&gt;description = _( "generate thumbnail from image" );
1088 	thumbnail_class-&gt;get_info = vips_thumbnail_image_get_info;
1089 	thumbnail_class-&gt;open = vips_thumbnail_image_open;
1090 	VIPS_ARG_IMAGE( class, "in", 1, 
1091 		_( "Input" ), 
1092 		_( "Input image argument" ),
1093 		VIPS_ARGUMENT_REQUIRED_INPUT,
1094 		G_STRUCT_OFFSET( VipsThumbnailImage, in ) );
1095 }
1096 static void
1097 vips_thumbnail_image_init( VipsThumbnailImage *image )
1098 {
1099 }
1100 int
1101 vips_thumbnail_image( VipsImage *in, VipsImage **out, int width, ... )
1102 {
1103 	va_list ap;
1104 	int result;
1105 	va_start( ap, width );
1106 	result = vips_call_split( "thumbnail_image", ap, in, out, width );
1107 	va_end( ap );
1108 	return( result );
1109 }
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
