<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML><HEAD><TITLE>Matches for inf-simulated-connection.c & inf-chat-session.c</TITLE>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
</HEAD>
<body>
  <div style="align-items: center; display: flex; justify-content: space-around;">
    <div>
      <h3 align="center">
Matches for inf-simulated-connection.c & inf-chat-session.c
      </h3>
      <h1 align="center">
        3.2%
      </h1>
      <center>
        <a href="index.html" target="_top">
          INDEX
        </a>
        <span>-</span>
        <a href="help-en.html" target="_top">
          HELP
        </a>
      </center>
    </div>
    <div>
<TABLE BORDER="1" CELLSPACING="0" BGCOLOR="#d0d0d0">
<TR><TH><TH>inf-simulated-connection.c (5.109489%)<TH>inf-chat-session.c (2.3569024%)<TH>Tokens
<TR><TD BGCOLOR="#0000ff"><FONT COLOR="#0000ff">-</FONT><TD><A HREF="javascript:ZweiFrames('match2495-0.html#0',2,'match2495-1.html#0',3)" NAME="0">(241-265)<TD><A HREF="javascript:ZweiFrames('match2495-0.html#0',2,'match2495-1.html#0',3)" NAME="0">(752-775)</A><TD ALIGN=center><FONT COLOR="#ff0000">14</FONT>
</TABLE>
    </div>
  </div>
  <hr>
  <div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>inf-simulated-connection.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
/* libinfinity - a GObject-based infinote implementation
 * Copyright (C) 2007-2015 Armin Burgmeier &lt;armin@arbur.net&gt;
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston,
 * MA 02110-1301, USA.
 */

/**
 * SECTION:inf-simulated-connection
 * @title: InfSimulatedConnection
 * @short_description: Simulated network connection
 * @include: libinfinity/common/inf-simulated-connection.h
 * @stability: Unstable
 *
 * #InfSimulatedConnection simulates a connection and can be used everywhere
 * where a #InfXmlConnection is expected. Use
 * inf_simulated_connection_connect() to connect two such connections so that
 * data sent through one is received by the other.
 */

#include &lt;libinfinity/common/inf-simulated-connection.h&gt;
#include &lt;libinfinity/common/inf-xml-connection.h&gt;
#include &lt;libinfinity/inf-define-enum.h&gt;

static const GEnumValue inf_simulated_connection_mode_values[] = {
  {
    INF_SIMULATED_CONNECTION_IMMEDIATE,
    &quot;INF_SIMULATED_CONNECTION_IMMEDIATE&quot;,
    &quot;immediate&quot;
  }, {
    INF_SIMULATED_CONNECTION_DELAYED,
    &quot;INF_SIMULATED_CONNECTION_DELAYED&quot;,
    &quot;delayed&quot;
  }, {
    INF_SIMULATED_CONNECTION_IO_CONTROLLED,
    &quot;INF_SIMULATED_CONNECTION_IO_CONTROLLED&quot;,
    &quot;io-controlled&quot;
  }, {
    0,
    NULL,
    NULL
  }
};

typedef struct _InfSimulatedConnectionPrivate InfSimulatedConnectionPrivate;
struct _InfSimulatedConnectionPrivate {
  InfIo* io;
  InfIoDispatch* io_handler;

  InfSimulatedConnection* target;
  InfSimulatedConnectionMode mode;

  xmlNodePtr queue;
  xmlNodePtr queue_last_item;
};

enum {
  PROP_0,

  PROP_IO,

  PROP_TARGET,
  PROP_MODE,

  /* From InfXmlConnection */
  PROP_STATUS,
  PROP_NETWORK,
  PROP_LOCAL_ID,
  PROP_REMOTE_ID,
  PROP_LOCAL_CERTIFICATE,
  PROP_REMOTE_CERTIFICATE
};

#define INF_SIMULATED_CONNECTION_PRIVATE(obj) (G_TYPE_INSTANCE_GET_PRIVATE((obj), INF_TYPE_SIMULATED_CONNECTION, InfSimulatedConnectionPrivate))

static void inf_simulated_connection_xml_connection_iface_init(InfXmlConnectionInterface* iface);
INF_DEFINE_ENUM_TYPE(InfSimulatedConnectionMode, inf_simulated_connection_mode, inf_simulated_connection_mode_values)
G_DEFINE_TYPE_WITH_CODE(InfSimulatedConnection, inf_simulated_connection, G_TYPE_OBJECT,
  G_ADD_PRIVATE(InfSimulatedConnection)
  G_IMPLEMENT_INTERFACE(INF_TYPE_XML_CONNECTION, inf_simulated_connection_xml_connection_iface_init))

static void
inf_simulated_connection_clear_queue(InfSimulatedConnection* connection)
{
  InfSimulatedConnectionPrivate* priv;
  xmlNodePtr next;

  priv = INF_SIMULATED_CONNECTION_PRIVATE(connection);

  if(priv-&gt;io_handler != NULL)
  {
    g_assert(priv-&gt;io != NULL);

    inf_io_remove_dispatch(priv-&gt;io, priv-&gt;io_handler);
    priv-&gt;io_handler = NULL;
  }

  while(priv-&gt;queue != NULL)
  {
    next = priv-&gt;queue-&gt;next;
    xmlFreeNode(priv-&gt;queue);
    priv-&gt;queue = next;
  }

  priv-&gt;queue_last_item = NULL;
}

static void
inf_simulated_connection_unset_target(InfSimulatedConnection* connection)
{
  InfSimulatedConnectionPrivate* priv;
  InfSimulatedConnection* target;
  InfSimulatedConnectionPrivate* target_priv;

  priv = INF_SIMULATED_CONNECTION_PRIVATE(connection);
  target = priv-&gt;target;

  if(target != NULL)
  {
    target_priv = INF_SIMULATED_CONNECTION_PRIVATE(priv-&gt;target);
    g_assert(target_priv-&gt;target == connection);

    priv-&gt;target = NULL;
    target_priv-&gt;target = NULL;

    inf_simulated_connection_clear_queue(connection);
    inf_simulated_connection_clear_queue(target);

    g_object_notify(G_OBJECT(connection), &quot;target&quot;);
    g_object_notify(G_OBJECT(connection), &quot;status&quot;);
    g_object_notify(G_OBJECT(target), &quot;target&quot;);
    g_object_notify(G_OBJECT(target), &quot;status&quot;);
  }
}

static void
inf_simulated_connection_set_target(InfSimulatedConnection* connection,
                                    InfSimulatedConnection* target)
{
  InfSimulatedConnectionPrivate* priv;

  inf_simulated_connection_unset_target(connection);
  if(target != NULL) inf_simulated_connection_unset_target(target);

  priv = INF_SIMULATED_CONNECTION_PRIVATE(connection);
  priv-&gt;target = target;

  if(target != NULL)
  {
    priv = INF_SIMULATED_CONNECTION_PRIVATE(target);
    priv-&gt;target = connection;
  }

  g_object_notify(G_OBJECT(connection), &quot;target&quot;);
  g_object_notify(G_OBJECT(connection), &quot;status&quot;);

  if(target != NULL)
  {
    g_object_notify(G_OBJECT(target), &quot;target&quot;);
    g_object_notify(G_OBJECT(target), &quot;status&quot;);
  }
}

/*
 * GObject overrides
 */

static void
inf_simulated_connection_init(InfSimulatedConnection* connection)
{
  InfSimulatedConnectionPrivate* priv;
  priv = INF_SIMULATED_CONNECTION_PRIVATE(connection);

  priv-&gt;io = NULL;

  priv-&gt;target = NULL;
  priv-&gt;mode = INF_SIMULATED_CONNECTION_IMMEDIATE;
}

static void
inf_simulated_connection_dispose(GObject* object)
{
  InfSimulatedConnection* connection;
  InfSimulatedConnectionPrivate* priv;

  connection = INF_SIMULATED_CONNECTION(object);
  priv = INF_SIMULATED_CONNECTION_PRIVATE(connection);

  inf_simulated_connection_unset_target(connection);
  g_assert(priv-&gt;io_handler == NULL);

  if(priv-&gt;io != NULL)
  {
    g_object_unref(priv-&gt;io);
    priv-&gt;io = NULL;
  }

  G_OBJECT_CLASS(inf_simulated_connection_parent_class)-&gt;dispose(object);
}

static void
inf_simulated_connection_set_property(GObject* object,
                                      guint prop_id,
                                      const GValue* value,
                                      GParamSpec* pspec)
{
  InfSimulatedConnection* sim;
  InfSimulatedConnectionPrivate* priv;

  sim = INF_SIMULATED_CONNECTION(object);
  priv = INF_SIMULATED_CONNECTION_PRIVATE(sim);

  switch(prop_id)
  {
  case PROP_IO:
    g_assert(priv-&gt;io == NULL); /* construct only */
    priv-&gt;io = INF_IO(g_value_get_object(value));
    if(priv-&gt;io) g_object_ref(priv-&gt;io);
    break;
  case PROP_TARGET:
    inf_simulated_connection_set_target(
      sim,
      INF_SIMULATED_CONNECTION(g_value_get_object(value))
    );

<A NAME="0"></A>    break;
  case PROP_MODE:
    inf_simulated_connection_set_mode(sim, g_value_get_enum(value));
<FONT color="#0000ff"><A HREF="javascript:ZweiFrames('match2495-1.html#0',3,'match2495-top.html#0',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>    break;
  default:
    G_OBJECT_WARN_INVALID_PROPERTY_ID(object, prop_id, pspec);
    break;
  }
}

static void
inf_simulated_connection_get_property(GObject* object,
                                      guint prop_id,
                                      GValue* value,
                                      GParamSpec* pspec)
{
  InfSimulatedConnection* sim;
  InfSimulatedConnectionPrivate* priv;
  gchar* id;

  sim = INF_SIMULATED_CONNECTION(object);
  priv = INF_SIMULATED_CONNECTION_PRIVATE(sim);

  switch(prop_id)
  {
  case PROP_IO:
    g_value_set_object(value, G_OBJECT(priv-&gt;io));
    break;</B></FONT>
  case PROP_TARGET:
    g_value_set_object(value, G_OBJECT(priv-&gt;target));
    break;
  case PROP_MODE:
    g_value_set_enum(value, priv-&gt;mode);
    break;
  case PROP_STATUS:
    if(priv-&gt;target != NULL)
      g_value_set_enum(value, INF_XML_CONNECTION_OPEN);
    else
      g_value_set_enum(value, INF_XML_CONNECTION_CLOSED);

    break;
  case PROP_NETWORK:
    g_value_set_static_string(value, &quot;simulated&quot;);
    break;
  case PROP_LOCAL_ID:
    id = g_strdup_printf(&quot;simulated-%p&quot;, (void*)sim);
    g_value_take_string(value, id);
    break;
  case PROP_REMOTE_ID:
    g_assert(priv-&gt;target != NULL);
    id = g_strdup_printf(&quot;simulated-%p&quot;, (void*)priv-&gt;target);
    g_value_take_string(value, id);
    break;
  case PROP_LOCAL_CERTIFICATE:
    g_value_set_pointer(value, NULL);
    break;
  case PROP_REMOTE_CERTIFICATE:
    g_value_set_boxed(value, NULL);
    break;
  default:
    G_OBJECT_WARN_INVALID_PROPERTY_ID(object, prop_id, pspec);
    break;
  }
}

/*
 * InfXmlConnection interface implementation
 */

static void
inf_simulated_connection_xml_connection_close(InfXmlConnection* connection)
{
  InfSimulatedConnectionPrivate* priv;
  priv = INF_SIMULATED_CONNECTION_PRIVATE(connection);

  g_assert(priv-&gt;target != NULL);
  inf_simulated_connection_unset_target(INF_SIMULATED_CONNECTION(connection));
}

static void
inf_simulated_connection_dispatch_func(gpointer user_data)
{
  InfSimulatedConnection* connection;
  InfSimulatedConnectionPrivate* priv;

  connection = INF_SIMULATED_CONNECTION(user_data);
  priv = INF_SIMULATED_CONNECTION_PRIVATE(connection);

  priv-&gt;io_handler = NULL;
  inf_simulated_connection_flush(connection);
}

static void
inf_simulated_connection_xml_connection_send(InfXmlConnection* connection,
                                             xmlNodePtr xml)
{
  InfSimulatedConnectionPrivate* priv;
  priv = INF_SIMULATED_CONNECTION_PRIVATE(connection);

  g_assert(priv-&gt;target != NULL);

  switch(priv-&gt;mode)
  {
  case INF_SIMULATED_CONNECTION_IMMEDIATE:
    inf_xml_connection_sent(connection, xml);
    inf_xml_connection_received(INF_XML_CONNECTION(priv-&gt;target), xml);
    xmlFreeNode(xml);
    break;
  case INF_SIMULATED_CONNECTION_DELAYED:
  case INF_SIMULATED_CONNECTION_IO_CONTROLLED:
    xmlUnlinkNode(xml);
    if(priv-&gt;queue == NULL)
    {
      priv-&gt;queue = xml;
      priv-&gt;queue_last_item = xml;
    }
    else
    {
      priv-&gt;queue_last_item-&gt;next = xml;
      priv-&gt;queue_last_item = xml;
    }

    if(priv-&gt;mode == INF_SIMULATED_CONNECTION_IO_CONTROLLED)
    {
      if(priv-&gt;io_handler == NULL)
      {
        g_assert(priv-&gt;io != NULL);

        priv-&gt;io_handler = inf_io_add_dispatch(
          priv-&gt;io,
          inf_simulated_connection_dispatch_func,
          connection,
          NULL
        );
      }
    }

    break;
  default:
    g_assert_not_reached();
    break;
  }
}

/*
 * GObject type registration
 */

static void
inf_simulated_connection_class_init(
  InfSimulatedConnectionClass* connection_class)
{
  GObjectClass* object_class;
  object_class = G_OBJECT_CLASS(connection_class);

  object_class-&gt;dispose = inf_simulated_connection_dispose;
  object_class-&gt;set_property = inf_simulated_connection_set_property;
  object_class-&gt;get_property = inf_simulated_connection_get_property;

  g_object_class_install_property(
    object_class,
    PROP_IO,
    g_param_spec_object(
      &quot;io&quot;,
      &quot;IO&quot;,
      &quot;The main loop to be used for IO_CONTROLLED mode&quot;,
      INF_TYPE_IO,
      G_PARAM_READWRITE | G_PARAM_CONSTRUCT_ONLY
    )
  );

  g_object_class_install_property(
    object_class,
    PROP_TARGET,
    g_param_spec_object(
      &quot;target&quot;,
      &quot;Target connection&quot;,
      &quot;The simulated connection receiving data sent through this connection&quot;,
      INF_TYPE_SIMULATED_CONNECTION,
      G_PARAM_READWRITE
    )
  );

  g_object_class_install_property(
    object_class,
    PROP_MODE,
    g_param_spec_enum(
      &quot;mode&quot;,
      &quot;Mode&quot;,
      &quot;The mode of the simulated connection&quot;,
      INF_TYPE_SIMULATED_CONNECTION_MODE,
      INF_SIMULATED_CONNECTION_IMMEDIATE,
      G_PARAM_READWRITE | G_PARAM_CONSTRUCT
    )
  );

  g_object_class_override_property(object_class, PROP_STATUS, &quot;status&quot;);
  g_object_class_override_property(object_class, PROP_NETWORK, &quot;network&quot;);
  g_object_class_override_property(object_class, PROP_LOCAL_ID, &quot;local-id&quot;);
  g_object_class_override_property(object_class, PROP_REMOTE_ID, &quot;remote-id&quot;);

  g_object_class_override_property(
    object_class,
    PROP_LOCAL_CERTIFICATE,
    &quot;local-certificate&quot;
  );

  g_object_class_override_property(
    object_class,
    PROP_REMOTE_CERTIFICATE,
    &quot;remote-certificate&quot;
  );
}

static void
inf_simulated_connection_xml_connection_iface_init(
  InfXmlConnectionInterface* iface)
{
  iface-&gt;close = inf_simulated_connection_xml_connection_close;
  iface-&gt;send = inf_simulated_connection_xml_connection_send;
}

/*
 * Public API
 */

/**
 * inf_simulated_connection_new: (constructor)
 *
 * Creates a new #InfSimulatedConnection. A connection created this way cannot
 * be switched to %INF_SIMULATED_CONNECTION_IO_CONTROLLED mode. Use
 * inf_simulated_connection_new_with_io() instead if you intend to do that.
 *
 * Returns: (transfer full): A new #InfSimulatedConnection.
 **/
InfSimulatedConnection*
inf_simulated_connection_new(void)
{
  GObject* object;
  object = g_object_new(INF_TYPE_SIMULATED_CONNECTION, NULL);
  return INF_SIMULATED_CONNECTION(object);
}

/**
 * inf_simulated_connection_new_with_io: (constructor)
 * @io: The main loop to be used for %INF_SIMULATED_CONNECTION_IO_CONTROLLED
 * mode.
 *
 * Creates a new #InfSimulatedConnection with the given #InfIo. This
 * connection can be used with %INF_SIMULATED_CONNECTION_IO_CONTROLLED mode.
 * If you don't intend to use that mode then using
 * inf_simulated_connection_new() is also good enough since the #InfIo object
 * is not required in that case.
 *
 * Returns: (transfer full): A new #InfSimulatedConnection.
 */
InfSimulatedConnection*
inf_simulated_connection_new_with_io(InfIo* io)
{
  GObject* object;

  g_return_val_if_fail(INF_IS_IO(io), NULL);

  object = g_object_new(INF_TYPE_SIMULATED_CONNECTION, &quot;io&quot;, io, NULL);
  return INF_SIMULATED_CONNECTION(object);
}

/**
 * inf_simulated_connection_connect:
 * @connection: A #InfSimulatedConnection.
 * @to: The target connection.
 *
 * Connects two simulated connections, so that data sent through one of them
 * is received by the other one and vice versa. So one call to this function
 * connects both #InfSimulatedConnection&lt;!-- --&gt;s to each other. There is no
 * need to call this function once for each connection.
 *
 * If one or both of the connections already have another target, then the
 * simulated connection between those is closed first.
 */
void
inf_simulated_connection_connect(InfSimulatedConnection* connection,
                                 InfSimulatedConnection* to)
{
  inf_simulated_connection_set_target(connection, to);
}

/**
 * inf_simulated_connection_set_mode:
 * @connection: A #InfSimulatedConnection.
 * @mode: The new mode to set.
 *
 * Sets the mode of the simulated connection.
 *
 * In %INF_SIMULATED_CONNECTION_IMMEDIATE mode, messages sent through the
 * connection are received by the target during the call to
 * inf_xml_connection_send().
 *
 * In %INF_SIMULATED_CONNECTION_DELAYED mode, messages sent are queued and
 * received by the target when inf_simulated_connection_flush() is called.
 *
 * In %INF_SIMULATED_CONNECTION_IO_CONTROLLED mode, messages are queued and
 * received by the target as soon as a dispatch handler (see
 * inf_io_add_dispatch()) installed on the main loop is called.
 *
 * When changing the mode from %INF_SIMULATED_CONNECTION_DELAYED or
 * %INF_SIMULATED_CONNECTION_IO_CONTROLLED to
 * %INF_SIMULATED_CONNECTION_IMMEDIATE, then the queue is flushed, too.
 */
void
inf_simulated_connection_set_mode(InfSimulatedConnection* connection,
                                  InfSimulatedConnectionMode mode)
{
  InfSimulatedConnectionPrivate* priv;
  priv = INF_SIMULATED_CONNECTION_PRIVATE(connection);

  g_return_if_fail(priv-&gt;io != NULL ||
                   mode != INF_SIMULATED_CONNECTION_IO_CONTROLLED);

  if(priv-&gt;mode != mode)
  {
    if(mode == INF_SIMULATED_CONNECTION_IMMEDIATE)
      inf_simulated_connection_flush(connection);

    priv-&gt;mode = mode;
    g_object_notify(G_OBJECT(connection), &quot;mode&quot;);
  }
}

/**
 * inf_simulated_connection_flush:
 * @connection: A #InfSimulatedConnection.
 *
 * When @connection's mode is %INF_SIMULATED_CONNECTION_DELAYED or
 * %INF_SIMULATED_CONNECTION_IO_CONTROLLED, then calling this function makes
 * the target connection receive all the queued messages.
 */
void
inf_simulated_connection_flush(InfSimulatedConnection* connection)
{
  InfSimulatedConnectionPrivate* priv;
  xmlNodePtr next;

  priv = INF_SIMULATED_CONNECTION_PRIVATE(connection);
  g_return_if_fail(priv-&gt;target != NULL);

  if(priv-&gt;mode == INF_SIMULATED_CONNECTION_IO_CONTROLLED)
  {
    g_assert(priv-&gt;io != NULL);

    if(priv-&gt;io_handler != NULL)
    {
      inf_io_remove_dispatch(priv-&gt;io, priv-&gt;io_handler);
      priv-&gt;io_handler = NULL;
    }
  }

  while(priv-&gt;queue != NULL)
  {
    inf_xml_connection_sent(
      INF_XML_CONNECTION(connection),
      priv-&gt;queue
    );

    inf_xml_connection_received(
      INF_XML_CONNECTION(priv-&gt;target),
      priv-&gt;queue
    );

    next = priv-&gt;queue-&gt;next;
    xmlFreeNode(priv-&gt;queue);
    priv-&gt;queue = next;
  }

  priv-&gt;queue_last_item = NULL;
}

/* vim:set et sw=2 ts=2: */
</PRE>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>inf-chat-session.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
/* libinfinity - a GObject-based infinote implementation
 * Copyright (C) 2007-2015 Armin Burgmeier &lt;armin@arbur.net&gt;
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free
 * Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
 */

/**
 * SECTION:inf-chat-session
 * @title: InfChatSession
 * @short_description: Simple standalone chat
 * @include: libinfinity/common/inf-chat-session.h
 * @stability: Unstable
 *
 * #InfChatSession represents a chat session. Normally, there is one chat
 * session per server, and it can be enabled via infd_directory_enable_chat().
 * Clients can subscribe to the chat session via
 * infc_browser_subscribe_chat().
 **/

#include &lt;libinfinity/common/inf-chat-session.h&gt;
#include &lt;libinfinity/common/inf-xml-util.h&gt;
#include &lt;libinfinity/common/inf-error.h&gt;

#include &lt;libinfinity/inf-i18n.h&gt;
#include &lt;libinfinity/inf-signals.h&gt;

#include &lt;errno.h&gt;
#include &lt;string.h&gt;

typedef struct _InfChatSessionLogUserlistForeachData
  InfChatSessionLogUserlistForeachData;
struct _InfChatSessionLogUserlistForeachData {
  FILE* log_file;
  gchar* time_str;
  guint users_total;
};

typedef struct _InfChatSessionPrivate InfChatSessionPrivate;
struct _InfChatSessionPrivate {
  gchar* log_filename;
  FILE* log_file;
};

enum {
  PROP_0,

  PROP_LOG_FILE
};

enum {
  RECEIVE_MESSAGE,
  SEND_MESSAGE,

  LAST_SIGNAL
};

#define INF_CHAT_SESSION_PRIVATE(obj) (G_TYPE_INSTANCE_GET_PRIVATE((obj), INF_TYPE_CHAT_SESSION, InfChatSessionPrivate))

static guint chat_session_signals[LAST_SIGNAL];
static GQuark inf_chat_session_error_quark;

G_DEFINE_TYPE_WITH_CODE(InfChatSession, inf_chat_session, INF_TYPE_SESSION,
  G_ADD_PRIVATE(InfChatSession))

/*
 * Error functions
 */

/* Currently unused, but can be used for a later translate_error vfunc
 * implementation. */
#if 0
static const gchar*
inf_chat_session_strerror(InfChatSessionError code)
{
  switch(code)
  {
  case INF_CHAT_SESSION_ERROR_TYPE_INVALID:
    return _(&quot;An invalid message type was sent&quot;);
  case INF_CHAT_SESSION_ERROR_NO_SUCH_USER:
    return _(&quot;A user with the requested ID does not exist&quot;);
  case INF_CHAT_SESSION_ERROR_FAILED:
    return _(&quot;An unknown chat session error has occurred&quot;);
  default:
    return _(&quot;An error with unknown error code occurred&quot;);
  }
}
#endif

/*
 * Message Type &lt;-&gt; string conversions
 */

static const gchar*
inf_chat_session_message_type_to_string(InfChatBufferMessageType type)
{
  switch(type)
  {
  case INF_CHAT_BUFFER_MESSAGE_NORMAL: return &quot;normal&quot;;
  case INF_CHAT_BUFFER_MESSAGE_EMOTE: return &quot;emote&quot;;
  case INF_CHAT_BUFFER_MESSAGE_USERJOIN: return &quot;userjoin&quot;;
  case INF_CHAT_BUFFER_MESSAGE_USERPART: return &quot;userpart&quot;;
  default: g_assert_not_reached(); return NULL;
  }
}

static gboolean
inf_chat_session_message_type_from_string(const gchar* string,
                                          InfChatBufferMessageType* type,
                                          GError** error)
{
  if(strcmp(string, &quot;normal&quot;) == 0)
  {
    *type = INF_CHAT_BUFFER_MESSAGE_NORMAL;
    return TRUE;
  }
  else if(strcmp(string, &quot;emote&quot;) == 0)
  {
    *type = INF_CHAT_BUFFER_MESSAGE_EMOTE;
    return TRUE;
  }
  else if(strcmp(string, &quot;userjoin&quot;) == 0)
  {
    *type = INF_CHAT_BUFFER_MESSAGE_USERJOIN;
    return TRUE;
  }
  else if(strcmp(string, &quot;userpart&quot;) == 0)
  {
    *type = INF_CHAT_BUFFER_MESSAGE_USERPART;
    return TRUE;
  }

  g_set_error(
    error,
    inf_chat_session_error_quark,
    INF_CHAT_SESSION_ERROR_TYPE_INVALID,
    &quot;Invalid message type: \&quot;%s\&quot;&quot;,
    string
  );

  return FALSE;
}

/*
 * Message XML functions
 */

static xmlNodePtr
inf_chat_session_message_to_xml(InfChatSession* session,
                                const InfChatBufferMessage* message,
                                gboolean for_sync)
{
  xmlNodePtr xml;
  xml = xmlNewNode(NULL, (const xmlChar*)&quot;message&quot;);

  if(message-&gt;type != INF_CHAT_BUFFER_MESSAGE_NORMAL)
  {
    inf_xml_util_set_attribute(
      xml,
      &quot;type&quot;,
      inf_chat_session_message_type_to_string(message-&gt;type)
    );
  }

  if(for_sync)
    inf_xml_util_set_attribute_long(xml, &quot;time&quot;, (long)message-&gt;time);

  inf_xml_util_set_attribute_uint(
    xml,
    &quot;user&quot;,
    inf_user_get_id(message-&gt;user)
  );

  if(message-&gt;text != NULL)
    inf_xml_util_add_child_text(xml, message-&gt;text, message-&gt;length);

  return xml;
}

static gboolean
inf_chat_session_message_from_xml(InfChatSession* session,
                                  InfChatBufferMessage* message,
                                  xmlNodePtr xml,
                                  gboolean for_sync,
                                  GError** error)
{
  xmlChar* type;
  gboolean result;
  InfChatBufferMessageType message_type;
  InfChatBufferMessageFlags message_flags;
  long message_time;
  guint user_id;
  InfUserTable* user_table;
  InfUser* user;

  message_flags = 0;

  type = inf_xml_util_get_attribute(xml, &quot;type&quot;);
  if(type == NULL)
  {
    message_type = INF_CHAT_BUFFER_MESSAGE_NORMAL;
  }
  else
  {
    result = inf_chat_session_message_type_from_string(
      (const char*)type,
      &amp;message_type,
      error
    );

    xmlFree(type);
    if(result == FALSE) return FALSE;
  }

  if(for_sync)
  {
    result = inf_xml_util_get_attribute_long_required(
      xml,
      &quot;time&quot;,
      &amp;message_time,
      error
    );

    if(result == FALSE) return FALSE;
    message_flags = INF_CHAT_BUFFER_MESSAGE_BACKLOG;
  }
  else
  {
    if(message_type == INF_CHAT_BUFFER_MESSAGE_USERJOIN ||
       message_type == INF_CHAT_BUFFER_MESSAGE_USERPART)
    {
      g_set_error(
        error,
        inf_chat_session_error_quark,
        INF_CHAT_SESSION_ERROR_TYPE_INVALID,
        &quot;Non-backlog message type cannot be \&quot;%s\&quot;&quot;,
        inf_chat_session_message_type_to_string(message_type)
      );

      return FALSE;
    }

    message_time = time(NULL);
  }

  if(!inf_xml_util_get_attribute_uint_required(xml, &quot;user&quot;, &amp;user_id, error))
    return FALSE;

  user_table = inf_session_get_user_table(INF_SESSION(session));
  user = inf_user_table_lookup_user_by_id(user_table, user_id);

  if(user == NULL)
  {
    g_set_error(
      error,
      inf_chat_session_error_quark,
      INF_CHAT_SESSION_ERROR_NO_SUCH_USER,
      _(&quot;No such user with ID \&quot;%u\&quot;&quot;),
      user_id
    );

    return FALSE;
  }

  if(message_type != INF_CHAT_BUFFER_MESSAGE_USERJOIN &amp;&amp;
     message_type != INF_CHAT_BUFFER_MESSAGE_USERPART)
  {
    message-&gt;text =
      inf_xml_util_get_child_text(xml, &amp;message-&gt;length, NULL, error);
    if(!message-&gt;text)
      return FALSE;
  }
  else
  {
    message-&gt;text = NULL;
    message-&gt;length = 0;
  }

  message-&gt;type = message_type;
  message-&gt;user = user;
  message-&gt;time = message_time;
  message-&gt;flags = message_flags;

  return TRUE;
}

/*
 * Logging functions
 */

static gchar*
inf_chat_session_strdup_strftime(const char* format,
                                 const struct tm* tm,
                                 gsize* len)
{
  gsize alloc;
  gchar* str;
  size_t result;

  alloc = 64;
  str = g_malloc(alloc * sizeof(gchar));
  result = strftime(str, alloc, format, tm);

  while(result == 0 &amp;&amp; alloc &lt; 1024)
  {
    alloc *= 2;
    str = g_realloc(str, alloc * sizeof(gchar));
    result = strftime(str, alloc, format, tm);
  }

  if(result == 0)
  {
    g_free(str);
    return NULL;
  }

  if(len) *len = result;
  return str;
}

static void
inf_chat_session_log_message(InfChatSession* session,
                             const InfChatBufferMessage* message)
{
  InfChatSessionPrivate* priv;
  struct tm* tm;
  gchar* time_str;
  const gchar* name;
  const gchar* text;

  priv = INF_CHAT_SESSION_PRIVATE(session);

  if(priv-&gt;log_file != NULL)
  {
    tm = localtime(&amp;message-&gt;time);
    time_str = inf_chat_session_strdup_strftime(&quot;%c&quot;, tm, NULL);
    name = inf_user_get_name(message-&gt;user);
    text = message-&gt;text;

    switch(message-&gt;type)
    {
    case INF_CHAT_BUFFER_MESSAGE_NORMAL:
      fprintf(priv-&gt;log_file, &quot;%s &lt;%s&gt; %s\n&quot;, time_str, name, message-&gt;text);
      break;
    case INF_CHAT_BUFFER_MESSAGE_EMOTE:
      fprintf(priv-&gt;log_file, &quot;%s * %s %s\n&quot;, time_str, name, message-&gt;text);
      break;
    case INF_CHAT_BUFFER_MESSAGE_USERJOIN:
      fprintf(priv-&gt;log_file, _(&quot;%s --- %s has joined\n&quot;), time_str, name);
      break;
    case INF_CHAT_BUFFER_MESSAGE_USERPART:
      fprintf(priv-&gt;log_file, _(&quot;%s --- %s has left\n&quot;), time_str, name);
      break;
    default:
      g_assert_not_reached();
      break;
    }

    g_free(time_str);
    fflush(priv-&gt;log_file);
  }
}

static void
inf_chat_session_log_userlist_foreach_func(InfUser* user,
                                           gpointer user_data)
{
  InfChatSessionLogUserlistForeachData* data;
  data = (InfChatSessionLogUserlistForeachData*)user_data;

  if(inf_user_get_status(user) != INF_USER_UNAVAILABLE)
  {
    fprintf(
      data-&gt;log_file,
      &quot;%s --- [%s]\n&quot;,
      data-&gt;time_str,
      inf_user_get_name(user)
    );

    ++ data-&gt;users_total;
  }
}

static void
inf_chat_session_log_userlist(InfChatSession* session)
{
  InfChatSessionPrivate* priv;
  InfChatSessionLogUserlistForeachData data;
  time_t cur_time;
  struct tm* tm;

  priv = INF_CHAT_SESSION_PRIVATE(session);
  if(priv-&gt;log_file != NULL)
  {
    cur_time = time(NULL);
    tm = localtime(&amp;cur_time);

    data.time_str = inf_chat_session_strdup_strftime(&quot;%c&quot;, tm, NULL);
    data.log_file = priv-&gt;log_file;
    data.users_total = 0;

    inf_user_table_foreach_user(
      inf_session_get_user_table(INF_SESSION(session)),
      inf_chat_session_log_userlist_foreach_func,
      &amp;data
    );

    fprintf(
      data.log_file,
      _(&quot;%s --- %u users total\n&quot;),
      data.time_str,
      data.users_total
    );

    g_free(data.time_str);
    fflush(data.log_file);
  }
}

/*
 * Message reception
 */

static gboolean
inf_chat_session_receive_message(InfChatSession* session,
                                 InfXmlConnection* connection,
                                 xmlNodePtr xml,
                                 GError** error)
{
  InfChatSessionPrivate* priv;
  InfChatBufferMessage message;
  gboolean sync;

  priv = INF_CHAT_SESSION_PRIVATE(session);

  if(inf_session_get_status(INF_SESSION(session)) ==
     INF_SESSION_SYNCHRONIZING)
  {
    sync = TRUE;
  }
  else
  {
    sync = FALSE;
  }

  if(!inf_chat_session_message_from_xml(session, &amp;message, xml, sync, error))
    return FALSE;

  if(!sync &amp;&amp;
     (inf_user_get_status(message.user) == INF_USER_UNAVAILABLE ||
      inf_user_get_connection(message.user) != connection))
  {
    g_set_error_literal(
      error,
      inf_user_error_quark(),
      INF_USER_ERROR_NOT_JOINED,
      _(&quot;User did not join from this connection&quot;)
    );

    g_free(message.text);
    return FALSE;
  }

  g_signal_emit(
    session,
    chat_session_signals[RECEIVE_MESSAGE],
    0,
    &amp;message
  );

  g_free(message.text);
  return TRUE;
}

static void
inf_chat_session_user_join(InfChatSession* session,
                           InfUser* user)
{
  InfChatBufferMessage message;

  message.type = INF_CHAT_BUFFER_MESSAGE_USERJOIN;
  message.user = user;
  message.text = NULL;
  message.length = 0;
  message.time = time(NULL);
  message.flags = 0;

  g_signal_emit(session, chat_session_signals[RECEIVE_MESSAGE], 0, &amp;message);
}

static void
inf_chat_session_user_part(InfChatSession* session,
                           InfUser* user)
{
  InfChatBufferMessage message;

  message.type = INF_CHAT_BUFFER_MESSAGE_USERPART;
  message.user = user;
  message.text = NULL;
  message.length = 0;
  message.time = time(NULL);
  message.flags = 0;

  g_signal_emit(session, chat_session_signals[RECEIVE_MESSAGE], 0, &amp;message);
}

/*
 * Signal handlers
 */

static void
inf_chat_session_set_status_cb(InfUser* user,
                               InfUserStatus new_status,
                               gpointer user_data)
{
  InfSession* session;
  session = INF_SESSION(user_data);

  if(inf_session_get_status(session) == INF_SESSION_RUNNING)
  {
    if(inf_user_get_status(user) != INF_USER_UNAVAILABLE &amp;&amp;
       new_status == INF_USER_UNAVAILABLE)
    {
      inf_chat_session_user_part(INF_CHAT_SESSION(session), user);
    }
    else if(inf_user_get_status(user) == INF_USER_UNAVAILABLE &amp;&amp;
            new_status != INF_USER_UNAVAILABLE)
    {
      inf_chat_session_user_join(INF_CHAT_SESSION(session), user);
    }
  }
}

static void
inf_chat_session_add_user_cb(InfUserTable* user_table,
                             InfUser* user,
                             gpointer user_data)
{
  g_signal_connect(
    user,
    &quot;set-status&quot;,
    G_CALLBACK(inf_chat_session_set_status_cb),
    user_data
  );

  if(inf_session_get_status(INF_SESSION(user_data)) == INF_SESSION_RUNNING)
    if(inf_user_get_status(user) != INF_USER_UNAVAILABLE)
      inf_chat_session_user_join(INF_CHAT_SESSION(user_data), user);
}

static void
inf_chat_session_remove_user_cb(InfUserTable* user_table,
                                InfUser* user,
                                gpointer user_data)
{
  if(inf_session_get_status(INF_SESSION(user_data)) == INF_SESSION_RUNNING)
    if(inf_user_get_status(user) != INF_USER_UNAVAILABLE)
      inf_chat_session_user_part(INF_CHAT_SESSION(user_data), user);

  inf_signal_handlers_disconnect_by_func(
    user,
    G_CALLBACK(inf_chat_session_set_status_cb),
    user_data
  );
}

static void
inf_chat_session_add_message_cb(InfChatBuffer* buffer,
                                const InfChatBufferMessage* message,
                                gpointer user_data)
{
  /* Ignore these messages, we cannot send them */
  if(message-&gt;type != INF_CHAT_BUFFER_MESSAGE_USERJOIN &amp;&amp;
     message-&gt;type != INF_CHAT_BUFFER_MESSAGE_USERPART)
  {
    /* A message has been added to the buffer, so send it */
    g_signal_emit(
      user_data,
      chat_session_signals[SEND_MESSAGE],
      0,
      message
    );
  }
}

/*
 * GObject overrides
 */

static void
inf_chat_session_init(InfChatSession* session)
{
  InfChatSessionPrivate* priv;
  priv = INF_CHAT_SESSION_PRIVATE(session);

  priv-&gt;log_filename = NULL;
  priv-&gt;log_file = NULL;
}

static void
inf_chat_session_constructed_foreach_user_func(InfUser* user,
                                               gpointer user_data)
{
  g_signal_connect(
    user,
    &quot;set-status&quot;,
    G_CALLBACK(inf_chat_session_set_status_cb),
    user_data
  );
}

static void
inf_chat_session_constructed(GObject* object)
{
  InfUserTable* user_table;
  InfChatBuffer* buffer;

  G_OBJECT_CLASS(inf_chat_session_parent_class)-&gt;constructed(object);
  user_table = inf_session_get_user_table(INF_SESSION(object));

  g_signal_connect_after(
    user_table,
    &quot;add-user&quot;,
    G_CALLBACK(inf_chat_session_add_user_cb),
    object
  );

  g_signal_connect_after(
    user_table,
    &quot;remove-user&quot;,
    G_CALLBACK(inf_chat_session_remove_user_cb),
    object
  );

  inf_user_table_foreach_user(
    INF_USER_TABLE(user_table),
    inf_chat_session_constructed_foreach_user_func,
    object
  );

  buffer = INF_CHAT_BUFFER(inf_session_get_buffer(INF_SESSION(object)));
  g_assert(INF_IS_CHAT_BUFFER(buffer));

  g_signal_connect_after(
    buffer,
    &quot;add-message&quot;,
    G_CALLBACK(inf_chat_session_add_message_cb),
    object
  );
}

static void
inf_chat_session_dispose_foreach_user_func(InfUser* user,
                                           gpointer user_data)
{
  inf_signal_handlers_disconnect_by_func(
    user,
    G_CALLBACK(inf_chat_session_set_status_cb),
    user_data
  );
}

static void
inf_chat_session_dispose(GObject* object)
{
  InfChatSession* session;
  InfChatBuffer* buffer;
  InfUserTable* user_table;

  session = INF_CHAT_SESSION(object);
  user_table = inf_session_get_user_table(INF_SESSION(session));
  buffer = INF_CHAT_BUFFER(inf_session_get_buffer(INF_SESSION(session)));

  inf_user_table_foreach_user(
    INF_USER_TABLE(user_table),
    inf_chat_session_dispose_foreach_user_func,
    session
  );

  inf_signal_handlers_disconnect_by_func(
    user_table,
    G_CALLBACK(inf_chat_session_add_user_cb),
    session
  );

  inf_signal_handlers_disconnect_by_func(
    user_table,
    G_CALLBACK(inf_chat_session_remove_user_cb),
    session
  );

  inf_signal_handlers_disconnect_by_func(
    buffer,
    G_CALLBACK(inf_chat_session_add_message_cb),
    session
  );

  G_OBJECT_CLASS(inf_chat_session_parent_class)-&gt;dispose(object);
}

static void
inf_chat_session_finalize(GObject* object)
{
  InfChatSession* session;
  InfChatSessionPrivate* priv;

  session = INF_CHAT_SESSION(object);
  priv = INF_CHAT_SESSION_PRIVATE(session);

  inf_chat_session_set_log_file(session, NULL, NULL);

  G_OBJECT_CLASS(inf_chat_session_parent_class)-&gt;finalize(object);
}

static void
inf_chat_session_set_property(GObject* object,
                              guint prop_id,
                              const GValue* value,
                              GParamSpec* pspec)
{
  InfChatSession* session;
  InfChatSessionPrivate* priv;
  const gchar* log_file;
  GError* error;

  session = INF_CHAT_SESSION(object);
  priv = INF_CHAT_SESSION_PRIVATE(session);

  switch(prop_id)
  {
  case PROP_LOG_FILE:
    error = NULL;
    log_file = g_value_get_string(value);

    if(!inf_chat_session_set_log_file(session, log_file, &amp;error))
    {
      g_warning(&quot;Failed to set log file: %s\n&quot;, error-&gt;message);
<A NAME="0"></A>      g_error_free(error);
    }

<FONT color="#0000ff"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match2495-0.html#0',2,'match2495-top.html#0',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>    break;
  default:
    G_OBJECT_WARN_INVALID_PROPERTY_ID(object, prop_id, pspec);
    break;
  }
}

static void
inf_chat_session_get_property(GObject* object,
                              guint prop_id,
                              GValue* value,
                              GParamSpec* pspec)
{
  InfChatSession* session;
  InfChatSessionPrivate* priv;

  session = INF_CHAT_SESSION(object);
  priv = INF_CHAT_SESSION_PRIVATE(session);

  switch(prop_id)
  {
  case PROP_LOG_FILE:
    g_value_set_string(value, priv-&gt;log_filename);
    break;</B></FONT>
  default:
    G_OBJECT_WARN_INVALID_PROPERTY_ID(object, prop_id, pspec);
    break;
  }
}

/*
 * InfSession virtual functions and default signal handlers
 */

static void
inf_chat_session_to_xml_sync(InfSession* session,
                             xmlNodePtr parent)
{
  InfChatBuffer* buffer;
  InfSessionClass* parent_class;
  const InfChatBufferMessage* message;
  xmlNodePtr child;
  guint i;

  buffer = INF_CHAT_BUFFER(inf_session_get_buffer(session));
  parent_class = INF_SESSION_CLASS(inf_chat_session_parent_class);

  g_assert(parent_class-&gt;to_xml_sync != NULL);
  parent_class-&gt;to_xml_sync(session, parent);

  for(i = 0; i &lt; inf_chat_buffer_get_n_messages(buffer); ++i)
  {
    message = inf_chat_buffer_get_message(buffer, i);

    child = inf_chat_session_message_to_xml(
      INF_CHAT_SESSION(session),
      message,
      TRUE
    );

    xmlAddChild(parent, child);
  }
}

static gboolean
inf_chat_session_process_xml_sync(InfSession* session,
                                  InfXmlConnection* connection,
                                  xmlNodePtr xml,
                                  GError** error)
{
  InfSessionClass* parent_class;

  if(strcmp((const char*)xml-&gt;name, &quot;message&quot;) == 0)
  {
    return inf_chat_session_receive_message(
      INF_CHAT_SESSION(session),
      connection,
      xml,
      error
    );
  }
  else
  {
    parent_class = INF_SESSION_CLASS(inf_chat_session_parent_class);
    g_assert(parent_class-&gt;process_xml_sync != NULL);
    return parent_class-&gt;process_xml_sync(session, connection, xml, error);
  }
}

static InfCommunicationScope
inf_chat_session_process_xml_run(InfSession* session,
                                 InfXmlConnection* connection,
                                 xmlNodePtr xml,
                                 GError** error)
{
  InfSessionClass* parent_class;
  gboolean result;

  if(strcmp((const char*)xml-&gt;name, &quot;message&quot;) == 0)
  {
    result = inf_chat_session_receive_message(
      INF_CHAT_SESSION(session),
      connection,
      xml,
      error
    );

    if(!result)
      return INF_COMMUNICATION_SCOPE_PTP;
    else
      return INF_COMMUNICATION_SCOPE_GROUP;
  }
  else
  {
    parent_class = INF_SESSION_CLASS(inf_chat_session_parent_class);
    g_assert(parent_class-&gt;process_xml_run != NULL);
    return parent_class-&gt;process_xml_run(session, connection, xml, error);
  }
}

static void
inf_chat_session_synchronization_complete(InfSession* session,
                                          InfXmlConnection* connection)
{
  InfSessionClass* parent_class;

  if(inf_session_get_status(session) == INF_SESSION_SYNCHRONIZING)
    inf_chat_session_log_userlist(INF_CHAT_SESSION(session));

  parent_class = INF_SESSION_CLASS(inf_chat_session_parent_class);
  g_assert(parent_class-&gt;synchronization_complete != NULL);
  parent_class-&gt;synchronization_complete(session, connection);
}

static void
inf_chat_session_synchronization_failed(InfSession* session,
                                        InfXmlConnection* connection,
                                        const GError* error)
{
  InfSessionClass* parent_class;
  InfChatSessionPrivate* priv;
  time_t cur_time;
  struct tm* tm;
  gchar* time_str;

  if(inf_session_get_status(session) == INF_SESSION_SYNCHRONIZING)
  {
    priv = INF_CHAT_SESSION_PRIVATE(session);
    if(priv-&gt;log_file != NULL)
    {
      cur_time = time(NULL);
      tm = localtime(&amp;cur_time);
      time_str = inf_chat_session_strdup_strftime(&quot;%c&quot;, tm, NULL);

      fprintf(
        priv-&gt;log_file,
        &quot;%s --- Synchronization failed: %s\n&quot;,
        time_str,
        error-&gt;message
      );

      g_free(time_str);
    }
  }

  parent_class = INF_SESSION_CLASS(inf_chat_session_parent_class);
  g_assert(parent_class-&gt;synchronization_failed != NULL);
  parent_class-&gt;synchronization_failed(session, connection, error);
}

static InfUser*
inf_chat_session_user_new(InfSession* session,
                          GParameter* params,
                          guint n_params)
{
  return g_object_newv(INF_TYPE_USER, n_params, params);
}

static void
inf_chat_session_receive_message_handler(InfChatSession* session,
                                         const InfChatBufferMessage* message)
{
  InfChatBuffer* buffer;
  buffer = INF_CHAT_BUFFER(inf_session_get_buffer(INF_SESSION(session)));

  /* The add_message signal handler would try to send the message, so prevent
   * this. */
  inf_signal_handlers_block_by_func(
    buffer,
    G_CALLBACK(inf_chat_session_add_message_cb),
    session
  );

  switch(message-&gt;type)
  {
  case INF_CHAT_BUFFER_MESSAGE_NORMAL:
    inf_chat_buffer_add_message(
      buffer,
      message-&gt;user,
      message-&gt;text,
      message-&gt;length,
      message-&gt;time,
      message-&gt;flags
    );
    break;
  case INF_CHAT_BUFFER_MESSAGE_EMOTE:
    inf_chat_buffer_add_emote_message(
      buffer,
      message-&gt;user,
      message-&gt;text,
      message-&gt;length,
      message-&gt;time,
      message-&gt;flags
    );
    break;
  case INF_CHAT_BUFFER_MESSAGE_USERJOIN:
    inf_chat_buffer_add_userjoin_message(
      buffer,
      message-&gt;user,
      message-&gt;time,
      message-&gt;flags
    );
    break;
  case INF_CHAT_BUFFER_MESSAGE_USERPART:
    inf_chat_buffer_add_userpart_message(
      buffer,
      message-&gt;user,
      message-&gt;time,
      message-&gt;flags
    );
    break;
  default:
    g_assert_not_reached();
    break;
  }

  inf_signal_handlers_unblock_by_func(
    buffer,
    G_CALLBACK(inf_chat_session_add_message_cb),
    session
  );

  /* Backlog messages (received during synchronization) are not yet logged.
   * We will need to parse the last messages in the log first and check
   * whether they have already been logged. */
  if(inf_session_get_status(INF_SESSION(session)) == INF_SESSION_RUNNING)
    inf_chat_session_log_message(session, message);
}

static void
inf_chat_session_send_message_handler(InfChatSession* session,
                                      const InfChatBufferMessage* message)
{
  xmlNodePtr xml;

  /* Actually send the message over the network */
  xml = inf_chat_session_message_to_xml(session, message, FALSE);
  inf_session_send_to_subscriptions(INF_SESSION(session), xml);

  inf_chat_session_log_message(session, message);
}

/*
 * GType registration
 */

static void
inf_chat_session_class_init(InfChatSessionClass* chat_session_class)
{
  GObjectClass* object_class;
  InfSessionClass* session_class;

  object_class = G_OBJECT_CLASS(chat_session_class);
  session_class = INF_SESSION_CLASS(chat_session_class);

  object_class-&gt;constructed = inf_chat_session_constructed;
  object_class-&gt;dispose = inf_chat_session_dispose;
  object_class-&gt;finalize = inf_chat_session_finalize;
  object_class-&gt;set_property = inf_chat_session_set_property;
  object_class-&gt;get_property = inf_chat_session_get_property;

  session_class-&gt;to_xml_sync = inf_chat_session_to_xml_sync;
  session_class-&gt;process_xml_sync = inf_chat_session_process_xml_sync;
  session_class-&gt;process_xml_run = inf_chat_session_process_xml_run;
  session_class-&gt;synchronization_complete =
    inf_chat_session_synchronization_complete;
  session_class-&gt;synchronization_failed =
    inf_chat_session_synchronization_failed;

  session_class-&gt;user_new = inf_chat_session_user_new;

  chat_session_class-&gt;receive_message =
    inf_chat_session_receive_message_handler;
  chat_session_class-&gt;send_message =
    inf_chat_session_send_message_handler;

  inf_chat_session_error_quark =
    g_quark_from_static_string(&quot;INF_CHAT_SESSION_ERROR&quot;);

  g_object_class_install_property(
    object_class,
    PROP_LOG_FILE,
    g_param_spec_string(
      &quot;log-file&quot;,
      &quot;Log file&quot;,
      &quot;The file into which to store all received messages&quot;,
      NULL,
      G_PARAM_READWRITE
    )
  );

  /**
   * InfChatSession::receive-message:
   * @session: The #InfChatSession that is receiving a message.
   * @message: The #InfChatBufferMessage that was received.
   *
   * This signal is emitted whenever a message has been received. If the
   * session is in %INF_SESSION_SYNCHRONIZING state the received message was
   * a backlog message.
   */
  chat_session_signals[RECEIVE_MESSAGE] = g_signal_new(
    &quot;receive-message&quot;,
    G_OBJECT_CLASS_TYPE(object_class),
    G_SIGNAL_RUN_LAST,
    G_STRUCT_OFFSET(InfChatSessionClass, receive_message),
    NULL, NULL,
    g_cclosure_marshal_VOID__BOXED,
    G_TYPE_NONE,
    1,
    INF_TYPE_CHAT_BUFFER_MESSAGE | G_SIGNAL_TYPE_STATIC_SCOPE
  );

  /**
   * InfChatSession::send-message:
   * @session: The #InfChatSession that is sending a message.
   * @message: The #InfChatBufferMessage that is sent.
   *
   * This signal is emitted whenever a message is sent. Messages can be sent
   * by calling inf_chat_buffer_add_message() or
   * inf_chat_buffer_add_emote_message() on the session's #InfChatBuffer.
   * Messages of type %INF_CHAT_BUFFER_MESSAGE_USERJOIN or
   * %INF_CHAT_BUFFER_MESSAGE_USERPART can not be sent explicitely, so this
   * signal will never be emitted for such messages.
   */
  chat_session_signals[SEND_MESSAGE] = g_signal_new(
    &quot;send-message&quot;,
    G_OBJECT_CLASS_TYPE(object_class),
    G_SIGNAL_RUN_LAST,
    G_STRUCT_OFFSET(InfChatSessionClass, send_message),
    NULL, NULL,
    g_cclosure_marshal_VOID__BOXED,
    G_TYPE_NONE,
    1,
    INF_TYPE_CHAT_BUFFER_MESSAGE | G_SIGNAL_TYPE_STATIC_SCOPE
  );
}

/*
 * Public API
 */

/**
 * inf_chat_session_new: (constructor)
 * @manager: A #InfCommunicationManager.
 * @buffer: The #InfChatBuffer to use for the session.
 * @status: Initial status of the session. If this is
 * %INF_SESSION_SYNCHRONIZING or %INF_SESSION_PRESYNC, then @sync_group and
 * @sync_connection need to be set.
 * @sync_group: A group in which the session is synchronized. Ignored if
 * @status is %INF_SESSION_RUNNING.
 * @sync_connection: A connection to synchronize the session from. Ignored if
 * @status is %INF_SESSION_RUNNING.
 *
 * Creates a new #InfChatSession with the messages contained in @buffer as
 * initial messages. The communication manager is used to send and receive
 * requests from subscription and synchronization.
 *
 * If @status is %INF_SESSION_PRESYNC or %INF_SESSION_SYNCHRONIZING, then the
 * session will initially be synchronized, meaning an initial backlog is
 * retrieved from @sync_connection (which must not be %NULL in this case). If
 * you are subscribed to the session, set the subscription group via
 * inf_session_set_subscription_group().
 *
 * Returns: (transfer full): A new #InfChatSession.
 */
InfChatSession*
inf_chat_session_new(InfCommunicationManager* manager,
                     InfChatBuffer* buffer,
                     InfSessionStatus status,
                     InfCommunicationGroup* sync_group,
                     InfXmlConnection* sync_connection)
{
  InfChatSession* session;

  g_return_val_if_fail(INF_COMMUNICATION_IS_MANAGER(manager), NULL);
  g_return_val_if_fail(INF_IS_CHAT_BUFFER(buffer), NULL);

  g_return_val_if_fail(
    (status == INF_SESSION_RUNNING &amp;&amp;
     sync_group == NULL &amp;&amp; sync_connection == NULL) ||
    (status != INF_SESSION_RUNNING &amp;&amp;
     INF_COMMUNICATION_IS_GROUP(sync_group) &amp;&amp;
     INF_IS_XML_CONNECTION(sync_connection)),
    NULL
  );

  session = INF_CHAT_SESSION(
    g_object_new(
      INF_TYPE_CHAT_SESSION,
      &quot;communication-manager&quot;, manager,
      &quot;buffer&quot;, buffer,
      &quot;status&quot;, status,
      &quot;sync-group&quot;, sync_group,
      &quot;sync-connection&quot;, sync_connection,
      NULL
    )
  );

  return session;
}

/**
 * inf_chat_session_set_log_file:
 * @session: A #InfChatSession.
 * @log_file: (type filename): A filename to store all received messages into.
 * @error: Location to store error information, if any.
 *
 * Sets a file onto which all received messages are appended. The file is
 * created if it does not exist. If a previous log file was set, then it is
 * closed before opening the new file.
 *
 * Backlog messages received upon synchronization are not logged.
 *
 * Returns: %TRUE if the log file could be opened, %FALSE otherwise (in which
 * case @error is set).
 */
gboolean
inf_chat_session_set_log_file(InfChatSession* session,
                              const gchar* log_file,
                              GError** error)
{
  InfChatSessionPrivate* priv;
  FILE* new_file;
  int save_errno;
  long offset;
  time_t cur_time;
  struct tm* tm;
  gchar* time_str;
  guint len;

  g_return_val_if_fail(INF_IS_CHAT_SESSION(session), FALSE);
  priv = INF_CHAT_SESSION_PRIVATE(session);

  /* Open the new log file before doing anything else, so that we keep
   * the current log file if this fails. */
  if(log_file != NULL)
  {
    new_file = fopen(log_file, &quot;a&quot;);
    if(new_file == NULL)
    {
      save_errno = errno;
    }
    else
    {
      offset = ftell(new_file);
      if(offset == -1)
      {
        save_errno = errno;
        fclose(new_file);
        new_file = NULL;
      }
    }

    if(new_file == NULL)
    {
      g_set_error_literal(
        error,
        G_FILE_ERROR,
        g_file_error_from_errno(save_errno),
        strerror(save_errno)
      );

      return FALSE;
    }
  }

  cur_time = time(NULL);
  tm = localtime(&amp;cur_time);
  time_str = inf_chat_session_strdup_strftime(&quot;%c&quot;, tm, NULL);

  if(priv-&gt;log_file != NULL)
  {
    fprintf(priv-&gt;log_file, _(&quot;%s --- Log closed\n&quot;), time_str);
    fclose(priv-&gt;log_file);
  }

  if(log_file != NULL)
  {
    len = strlen(log_file);
    priv-&gt;log_filename =
      g_realloc(priv-&gt;log_filename, (len + 1) * sizeof(gchar));
    memcpy(priv-&gt;log_filename, log_file, len);
    priv-&gt;log_filename[len] = '\0';
    priv-&gt;log_file = new_file;

    if(offset &gt; 0) fprintf(priv-&gt;log_file, &quot;\n&quot;);
    fprintf(priv-&gt;log_file, _(&quot;%s --- Log opened\n&quot;), time_str);

    if(inf_session_get_status(INF_SESSION(session)) == INF_SESSION_RUNNING)
      inf_chat_session_log_userlist(session);
    else
      fflush(priv-&gt;log_file);
  }
  else
  {
    g_free(priv-&gt;log_filename);
    priv-&gt;log_filename = NULL;
    priv-&gt;log_file = NULL;
  }

  g_free(time_str);
  return TRUE;
}

/* vim:set et sw=2 ts=2: */
</PRE>
</div>
  </div>
</body>
</html>
