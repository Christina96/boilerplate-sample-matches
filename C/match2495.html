<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html><head><title>Matches for inf-simulated-connection.c &amp; inf-chat-session.c</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for inf-simulated-connection.c &amp; inf-chat-session.c
      </h3>
<h1 align="center">
        3.2%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>inf-simulated-connection.c (5.109489%)<th>inf-chat-session.c (2.3569024%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(241-265)<td><a href="#" name="0">(752-775)</a><td align="center"><font color="#ff0000">14</font>
</td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>inf-simulated-connection.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
/* libinfinity - a GObject-based infinote implementation
 * Copyright (C) 2007-2015 Armin Burgmeier &lt;armin@arbur.net&gt;
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston,
 * MA 02110-1301, USA.
 */

/**
 * SECTION:inf-simulated-connection
 * @title: InfSimulatedConnection
 * @short_description: Simulated network connection
 * @include: libinfinity/common/inf-simulated-connection.h
 * @stability: Unstable
 *
 * #InfSimulatedConnection simulates a connection and can be used everywhere
 * where a #InfXmlConnection is expected. Use
 * inf_simulated_connection_connect() to connect two such connections so that
 * data sent through one is received by the other.
 */

#include &lt;libinfinity/common/inf-simulated-connection.h&gt;
#include &lt;libinfinity/common/inf-xml-connection.h&gt;
#include &lt;libinfinity/inf-define-enum.h&gt;

static const GEnumValue inf_simulated_connection_mode_values[] = {
  {
    INF_SIMULATED_CONNECTION_IMMEDIATE,
    "INF_SIMULATED_CONNECTION_IMMEDIATE",
    "immediate"
  }, {
    INF_SIMULATED_CONNECTION_DELAYED,
    "INF_SIMULATED_CONNECTION_DELAYED",
    "delayed"
  }, {
    INF_SIMULATED_CONNECTION_IO_CONTROLLED,
    "INF_SIMULATED_CONNECTION_IO_CONTROLLED",
    "io-controlled"
  }, {
    0,
    NULL,
    NULL
  }
};

typedef struct _InfSimulatedConnectionPrivate InfSimulatedConnectionPrivate;
struct _InfSimulatedConnectionPrivate {
  InfIo* io;
  InfIoDispatch* io_handler;

  InfSimulatedConnection* target;
  InfSimulatedConnectionMode mode;

  xmlNodePtr queue;
  xmlNodePtr queue_last_item;
};

enum {
  PROP_0,

  PROP_IO,

  PROP_TARGET,
  PROP_MODE,

  /* From InfXmlConnection */
  PROP_STATUS,
  PROP_NETWORK,
  PROP_LOCAL_ID,
  PROP_REMOTE_ID,
  PROP_LOCAL_CERTIFICATE,
  PROP_REMOTE_CERTIFICATE
};

#define INF_SIMULATED_CONNECTION_PRIVATE(obj) (G_TYPE_INSTANCE_GET_PRIVATE((obj), INF_TYPE_SIMULATED_CONNECTION, InfSimulatedConnectionPrivate))

static void inf_simulated_connection_xml_connection_iface_init(InfXmlConnectionInterface* iface);
INF_DEFINE_ENUM_TYPE(InfSimulatedConnectionMode, inf_simulated_connection_mode, inf_simulated_connection_mode_values)
G_DEFINE_TYPE_WITH_CODE(InfSimulatedConnection, inf_simulated_connection, G_TYPE_OBJECT,
  G_ADD_PRIVATE(InfSimulatedConnection)
  G_IMPLEMENT_INTERFACE(INF_TYPE_XML_CONNECTION, inf_simulated_connection_xml_connection_iface_init))

static void
inf_simulated_connection_clear_queue(InfSimulatedConnection* connection)
{
  InfSimulatedConnectionPrivate* priv;
  xmlNodePtr next;

  priv = INF_SIMULATED_CONNECTION_PRIVATE(connection);

  if(priv-&gt;io_handler != NULL)
  {
    g_assert(priv-&gt;io != NULL);

    inf_io_remove_dispatch(priv-&gt;io, priv-&gt;io_handler);
    priv-&gt;io_handler = NULL;
  }

  while(priv-&gt;queue != NULL)
  {
    next = priv-&gt;queue-&gt;next;
    xmlFreeNode(priv-&gt;queue);
    priv-&gt;queue = next;
  }

  priv-&gt;queue_last_item = NULL;
}

static void
inf_simulated_connection_unset_target(InfSimulatedConnection* connection)
{
  InfSimulatedConnectionPrivate* priv;
  InfSimulatedConnection* target;
  InfSimulatedConnectionPrivate* target_priv;

  priv = INF_SIMULATED_CONNECTION_PRIVATE(connection);
  target = priv-&gt;target;

  if(target != NULL)
  {
    target_priv = INF_SIMULATED_CONNECTION_PRIVATE(priv-&gt;target);
    g_assert(target_priv-&gt;target == connection);

    priv-&gt;target = NULL;
    target_priv-&gt;target = NULL;

    inf_simulated_connection_clear_queue(connection);
    inf_simulated_connection_clear_queue(target);

    g_object_notify(G_OBJECT(connection), "target");
    g_object_notify(G_OBJECT(connection), "status");
    g_object_notify(G_OBJECT(target), "target");
    g_object_notify(G_OBJECT(target), "status");
  }
}

static void
inf_simulated_connection_set_target(InfSimulatedConnection* connection,
                                    InfSimulatedConnection* target)
{
  InfSimulatedConnectionPrivate* priv;

  inf_simulated_connection_unset_target(connection);
  if(target != NULL) inf_simulated_connection_unset_target(target);

  priv = INF_SIMULATED_CONNECTION_PRIVATE(connection);
  priv-&gt;target = target;

  if(target != NULL)
  {
    priv = INF_SIMULATED_CONNECTION_PRIVATE(target);
    priv-&gt;target = connection;
  }

  g_object_notify(G_OBJECT(connection), "target");
  g_object_notify(G_OBJECT(connection), "status");

  if(target != NULL)
  {
    g_object_notify(G_OBJECT(target), "target");
    g_object_notify(G_OBJECT(target), "status");
  }
}

/*
 * GObject overrides
 */

static void
inf_simulated_connection_init(InfSimulatedConnection* connection)
{
  InfSimulatedConnectionPrivate* priv;
  priv = INF_SIMULATED_CONNECTION_PRIVATE(connection);

  priv-&gt;io = NULL;

  priv-&gt;target = NULL;
  priv-&gt;mode = INF_SIMULATED_CONNECTION_IMMEDIATE;
}

static void
inf_simulated_connection_dispose(GObject* object)
{
  InfSimulatedConnection* connection;
  InfSimulatedConnectionPrivate* priv;

  connection = INF_SIMULATED_CONNECTION(object);
  priv = INF_SIMULATED_CONNECTION_PRIVATE(connection);

  inf_simulated_connection_unset_target(connection);
  g_assert(priv-&gt;io_handler == NULL);

  if(priv-&gt;io != NULL)
  {
    g_object_unref(priv-&gt;io);
    priv-&gt;io = NULL;
  }

  G_OBJECT_CLASS(inf_simulated_connection_parent_class)-&gt;dispose(object);
}

static void
inf_simulated_connection_set_property(GObject* object,
                                      guint prop_id,
                                      const GValue* value,
                                      GParamSpec* pspec)
{
  InfSimulatedConnection* sim;
  InfSimulatedConnectionPrivate* priv;

  sim = INF_SIMULATED_CONNECTION(object);
  priv = INF_SIMULATED_CONNECTION_PRIVATE(sim);

  switch(prop_id)
  {
  case PROP_IO:
    g_assert(priv-&gt;io == NULL); /* construct only */
    priv-&gt;io = INF_IO(g_value_get_object(value));
    if(priv-&gt;io) g_object_ref(priv-&gt;io);
    break;
  case PROP_TARGET:
    inf_simulated_connection_set_target(
      sim,
      INF_SIMULATED_CONNECTION(g_value_get_object(value))
    );

<a name="0"></a>    break;
  case PROP_MODE:
    inf_simulated_connection_set_mode(sim, g_value_get_enum(value));
<font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>    break;
  default:
    G_OBJECT_WARN_INVALID_PROPERTY_ID(object, prop_id, pspec);
    break;
  }
}

static void
inf_simulated_connection_get_property(GObject* object,
                                      guint prop_id,
                                      GValue* value,
                                      GParamSpec* pspec)
{
  InfSimulatedConnection* sim;
  InfSimulatedConnectionPrivate* priv;
  gchar* id;

  sim = INF_SIMULATED_CONNECTION(object);
  priv = INF_SIMULATED_CONNECTION_PRIVATE(sim);

  switch(prop_id)
  {
  case PROP_IO:
    g_value_set_object(value, G_OBJECT(priv-&gt;io));
    break;</b></font>
  case PROP_TARGET:
    g_value_set_object(value, G_OBJECT(priv-&gt;target));
    break;
  case PROP_MODE:
    g_value_set_enum(value, priv-&gt;mode);
    break;
  case PROP_STATUS:
    if(priv-&gt;target != NULL)
      g_value_set_enum(value, INF_XML_CONNECTION_OPEN);
    else
      g_value_set_enum(value, INF_XML_CONNECTION_CLOSED);

    break;
  case PROP_NETWORK:
    g_value_set_static_string(value, "simulated");
    break;
  case PROP_LOCAL_ID:
    id = g_strdup_printf("simulated-%p", (void*)sim);
    g_value_take_string(value, id);
    break;
  case PROP_REMOTE_ID:
    g_assert(priv-&gt;target != NULL);
    id = g_strdup_printf("simulated-%p", (void*)priv-&gt;target);
    g_value_take_string(value, id);
    break;
  case PROP_LOCAL_CERTIFICATE:
    g_value_set_pointer(value, NULL);
    break;
  case PROP_REMOTE_CERTIFICATE:
    g_value_set_boxed(value, NULL);
    break;
  default:
    G_OBJECT_WARN_INVALID_PROPERTY_ID(object, prop_id, pspec);
    break;
  }
}

/*
 * InfXmlConnection interface implementation
 */

static void
inf_simulated_connection_xml_connection_close(InfXmlConnection* connection)
{
  InfSimulatedConnectionPrivate* priv;
  priv = INF_SIMULATED_CONNECTION_PRIVATE(connection);

  g_assert(priv-&gt;target != NULL);
  inf_simulated_connection_unset_target(INF_SIMULATED_CONNECTION(connection));
}

static void
inf_simulated_connection_dispatch_func(gpointer user_data)
{
  InfSimulatedConnection* connection;
  InfSimulatedConnectionPrivate* priv;

  connection = INF_SIMULATED_CONNECTION(user_data);
  priv = INF_SIMULATED_CONNECTION_PRIVATE(connection);

  priv-&gt;io_handler = NULL;
  inf_simulated_connection_flush(connection);
}

static void
inf_simulated_connection_xml_connection_send(InfXmlConnection* connection,
                                             xmlNodePtr xml)
{
  InfSimulatedConnectionPrivate* priv;
  priv = INF_SIMULATED_CONNECTION_PRIVATE(connection);

  g_assert(priv-&gt;target != NULL);

  switch(priv-&gt;mode)
  {
  case INF_SIMULATED_CONNECTION_IMMEDIATE:
    inf_xml_connection_sent(connection, xml);
    inf_xml_connection_received(INF_XML_CONNECTION(priv-&gt;target), xml);
    xmlFreeNode(xml);
    break;
  case INF_SIMULATED_CONNECTION_DELAYED:
  case INF_SIMULATED_CONNECTION_IO_CONTROLLED:
    xmlUnlinkNode(xml);
    if(priv-&gt;queue == NULL)
    {
      priv-&gt;queue = xml;
      priv-&gt;queue_last_item = xml;
    }
    else
    {
      priv-&gt;queue_last_item-&gt;next = xml;
      priv-&gt;queue_last_item = xml;
    }

    if(priv-&gt;mode == INF_SIMULATED_CONNECTION_IO_CONTROLLED)
    {
      if(priv-&gt;io_handler == NULL)
      {
        g_assert(priv-&gt;io != NULL);

        priv-&gt;io_handler = inf_io_add_dispatch(
          priv-&gt;io,
          inf_simulated_connection_dispatch_func,
          connection,
          NULL
        );
      }
    }

    break;
  default:
    g_assert_not_reached();
    break;
  }
}

/*
 * GObject type registration
 */

static void
inf_simulated_connection_class_init(
  InfSimulatedConnectionClass* connection_class)
{
  GObjectClass* object_class;
  object_class = G_OBJECT_CLASS(connection_class);

  object_class-&gt;dispose = inf_simulated_connection_dispose;
  object_class-&gt;set_property = inf_simulated_connection_set_property;
  object_class-&gt;get_property = inf_simulated_connection_get_property;

  g_object_class_install_property(
    object_class,
    PROP_IO,
    g_param_spec_object(
      "io",
      "IO",
      "The main loop to be used for IO_CONTROLLED mode",
      INF_TYPE_IO,
      G_PARAM_READWRITE | G_PARAM_CONSTRUCT_ONLY
    )
  );

  g_object_class_install_property(
    object_class,
    PROP_TARGET,
    g_param_spec_object(
      "target",
      "Target connection",
      "The simulated connection receiving data sent through this connection",
      INF_TYPE_SIMULATED_CONNECTION,
      G_PARAM_READWRITE
    )
  );

  g_object_class_install_property(
    object_class,
    PROP_MODE,
    g_param_spec_enum(
      "mode",
      "Mode",
      "The mode of the simulated connection",
      INF_TYPE_SIMULATED_CONNECTION_MODE,
      INF_SIMULATED_CONNECTION_IMMEDIATE,
      G_PARAM_READWRITE | G_PARAM_CONSTRUCT
    )
  );

  g_object_class_override_property(object_class, PROP_STATUS, "status");
  g_object_class_override_property(object_class, PROP_NETWORK, "network");
  g_object_class_override_property(object_class, PROP_LOCAL_ID, "local-id");
  g_object_class_override_property(object_class, PROP_REMOTE_ID, "remote-id");

  g_object_class_override_property(
    object_class,
    PROP_LOCAL_CERTIFICATE,
    "local-certificate"
  );

  g_object_class_override_property(
    object_class,
    PROP_REMOTE_CERTIFICATE,
    "remote-certificate"
  );
}

static void
inf_simulated_connection_xml_connection_iface_init(
  InfXmlConnectionInterface* iface)
{
  iface-&gt;close = inf_simulated_connection_xml_connection_close;
  iface-&gt;send = inf_simulated_connection_xml_connection_send;
}

/*
 * Public API
 */

/**
 * inf_simulated_connection_new: (constructor)
 *
 * Creates a new #InfSimulatedConnection. A connection created this way cannot
 * be switched to %INF_SIMULATED_CONNECTION_IO_CONTROLLED mode. Use
 * inf_simulated_connection_new_with_io() instead if you intend to do that.
 *
 * Returns: (transfer full): A new #InfSimulatedConnection.
 **/
InfSimulatedConnection*
inf_simulated_connection_new(void)
{
  GObject* object;
  object = g_object_new(INF_TYPE_SIMULATED_CONNECTION, NULL);
  return INF_SIMULATED_CONNECTION(object);
}

/**
 * inf_simulated_connection_new_with_io: (constructor)
 * @io: The main loop to be used for %INF_SIMULATED_CONNECTION_IO_CONTROLLED
 * mode.
 *
 * Creates a new #InfSimulatedConnection with the given #InfIo. This
 * connection can be used with %INF_SIMULATED_CONNECTION_IO_CONTROLLED mode.
 * If you don't intend to use that mode then using
 * inf_simulated_connection_new() is also good enough since the #InfIo object
 * is not required in that case.
 *
 * Returns: (transfer full): A new #InfSimulatedConnection.
 */
InfSimulatedConnection*
inf_simulated_connection_new_with_io(InfIo* io)
{
  GObject* object;

  g_return_val_if_fail(INF_IS_IO(io), NULL);

  object = g_object_new(INF_TYPE_SIMULATED_CONNECTION, "io", io, NULL);
  return INF_SIMULATED_CONNECTION(object);
}

/**
 * inf_simulated_connection_connect:
 * @connection: A #InfSimulatedConnection.
 * @to: The target connection.
 *
 * Connects two simulated connections, so that data sent through one of them
 * is received by the other one and vice versa. So one call to this function
 * connects both #InfSimulatedConnection&lt;!-- --&gt;s to each other. There is no
 * need to call this function once for each connection.
 *
 * If one or both of the connections already have another target, then the
 * simulated connection between those is closed first.
 */
void
inf_simulated_connection_connect(InfSimulatedConnection* connection,
                                 InfSimulatedConnection* to)
{
  inf_simulated_connection_set_target(connection, to);
}

/**
 * inf_simulated_connection_set_mode:
 * @connection: A #InfSimulatedConnection.
 * @mode: The new mode to set.
 *
 * Sets the mode of the simulated connection.
 *
 * In %INF_SIMULATED_CONNECTION_IMMEDIATE mode, messages sent through the
 * connection are received by the target during the call to
 * inf_xml_connection_send().
 *
 * In %INF_SIMULATED_CONNECTION_DELAYED mode, messages sent are queued and
 * received by the target when inf_simulated_connection_flush() is called.
 *
 * In %INF_SIMULATED_CONNECTION_IO_CONTROLLED mode, messages are queued and
 * received by the target as soon as a dispatch handler (see
 * inf_io_add_dispatch()) installed on the main loop is called.
 *
 * When changing the mode from %INF_SIMULATED_CONNECTION_DELAYED or
 * %INF_SIMULATED_CONNECTION_IO_CONTROLLED to
 * %INF_SIMULATED_CONNECTION_IMMEDIATE, then the queue is flushed, too.
 */
void
inf_simulated_connection_set_mode(InfSimulatedConnection* connection,
                                  InfSimulatedConnectionMode mode)
{
  InfSimulatedConnectionPrivate* priv;
  priv = INF_SIMULATED_CONNECTION_PRIVATE(connection);

  g_return_if_fail(priv-&gt;io != NULL ||
                   mode != INF_SIMULATED_CONNECTION_IO_CONTROLLED);

  if(priv-&gt;mode != mode)
  {
    if(mode == INF_SIMULATED_CONNECTION_IMMEDIATE)
      inf_simulated_connection_flush(connection);

    priv-&gt;mode = mode;
    g_object_notify(G_OBJECT(connection), "mode");
  }
}

/**
 * inf_simulated_connection_flush:
 * @connection: A #InfSimulatedConnection.
 *
 * When @connection's mode is %INF_SIMULATED_CONNECTION_DELAYED or
 * %INF_SIMULATED_CONNECTION_IO_CONTROLLED, then calling this function makes
 * the target connection receive all the queued messages.
 */
void
inf_simulated_connection_flush(InfSimulatedConnection* connection)
{
  InfSimulatedConnectionPrivate* priv;
  xmlNodePtr next;

  priv = INF_SIMULATED_CONNECTION_PRIVATE(connection);
  g_return_if_fail(priv-&gt;target != NULL);

  if(priv-&gt;mode == INF_SIMULATED_CONNECTION_IO_CONTROLLED)
  {
    g_assert(priv-&gt;io != NULL);

    if(priv-&gt;io_handler != NULL)
    {
      inf_io_remove_dispatch(priv-&gt;io, priv-&gt;io_handler);
      priv-&gt;io_handler = NULL;
    }
  }

  while(priv-&gt;queue != NULL)
  {
    inf_xml_connection_sent(
      INF_XML_CONNECTION(connection),
      priv-&gt;queue
    );

    inf_xml_connection_received(
      INF_XML_CONNECTION(priv-&gt;target),
      priv-&gt;queue
    );

    next = priv-&gt;queue-&gt;next;
    xmlFreeNode(priv-&gt;queue);
    priv-&gt;queue = next;
  }

  priv-&gt;queue_last_item = NULL;
}

/* vim:set et sw=2 ts=2: */
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>inf-chat-session.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
/* libinfinity - a GObject-based infinote implementation
 * Copyright (C) 2007-2015 Armin Burgmeier &lt;armin@arbur.net&gt;
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free
 * Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
 */

/**
 * SECTION:inf-chat-session
 * @title: InfChatSession
 * @short_description: Simple standalone chat
 * @include: libinfinity/common/inf-chat-session.h
 * @stability: Unstable
 *
 * #InfChatSession represents a chat session. Normally, there is one chat
 * session per server, and it can be enabled via infd_directory_enable_chat().
 * Clients can subscribe to the chat session via
 * infc_browser_subscribe_chat().
 **/

#include &lt;libinfinity/common/inf-chat-session.h&gt;
#include &lt;libinfinity/common/inf-xml-util.h&gt;
#include &lt;libinfinity/common/inf-error.h&gt;

#include &lt;libinfinity/inf-i18n.h&gt;
#include &lt;libinfinity/inf-signals.h&gt;

#include &lt;errno.h&gt;
#include &lt;string.h&gt;

typedef struct _InfChatSessionLogUserlistForeachData
  InfChatSessionLogUserlistForeachData;
struct _InfChatSessionLogUserlistForeachData {
  FILE* log_file;
  gchar* time_str;
  guint users_total;
};

typedef struct _InfChatSessionPrivate InfChatSessionPrivate;
struct _InfChatSessionPrivate {
  gchar* log_filename;
  FILE* log_file;
};

enum {
  PROP_0,

  PROP_LOG_FILE
};

enum {
  RECEIVE_MESSAGE,
  SEND_MESSAGE,

  LAST_SIGNAL
};

#define INF_CHAT_SESSION_PRIVATE(obj) (G_TYPE_INSTANCE_GET_PRIVATE((obj), INF_TYPE_CHAT_SESSION, InfChatSessionPrivate))

static guint chat_session_signals[LAST_SIGNAL];
static GQuark inf_chat_session_error_quark;

G_DEFINE_TYPE_WITH_CODE(InfChatSession, inf_chat_session, INF_TYPE_SESSION,
  G_ADD_PRIVATE(InfChatSession))

/*
 * Error functions
 */

/* Currently unused, but can be used for a later translate_error vfunc
 * implementation. */
#if 0
static const gchar*
inf_chat_session_strerror(InfChatSessionError code)
{
  switch(code)
  {
  case INF_CHAT_SESSION_ERROR_TYPE_INVALID:
    return _("An invalid message type was sent");
  case INF_CHAT_SESSION_ERROR_NO_SUCH_USER:
    return _("A user with the requested ID does not exist");
  case INF_CHAT_SESSION_ERROR_FAILED:
    return _("An unknown chat session error has occurred");
  default:
    return _("An error with unknown error code occurred");
  }
}
#endif

/*
 * Message Type &lt;-&gt; string conversions
 */

static const gchar*
inf_chat_session_message_type_to_string(InfChatBufferMessageType type)
{
  switch(type)
  {
  case INF_CHAT_BUFFER_MESSAGE_NORMAL: return "normal";
  case INF_CHAT_BUFFER_MESSAGE_EMOTE: return "emote";
  case INF_CHAT_BUFFER_MESSAGE_USERJOIN: return "userjoin";
  case INF_CHAT_BUFFER_MESSAGE_USERPART: return "userpart";
  default: g_assert_not_reached(); return NULL;
  }
}

static gboolean
inf_chat_session_message_type_from_string(const gchar* string,
                                          InfChatBufferMessageType* type,
                                          GError** error)
{
  if(strcmp(string, "normal") == 0)
  {
    *type = INF_CHAT_BUFFER_MESSAGE_NORMAL;
    return TRUE;
  }
  else if(strcmp(string, "emote") == 0)
  {
    *type = INF_CHAT_BUFFER_MESSAGE_EMOTE;
    return TRUE;
  }
  else if(strcmp(string, "userjoin") == 0)
  {
    *type = INF_CHAT_BUFFER_MESSAGE_USERJOIN;
    return TRUE;
  }
  else if(strcmp(string, "userpart") == 0)
  {
    *type = INF_CHAT_BUFFER_MESSAGE_USERPART;
    return TRUE;
  }

  g_set_error(
    error,
    inf_chat_session_error_quark,
    INF_CHAT_SESSION_ERROR_TYPE_INVALID,
    "Invalid message type: \"%s\"",
    string
  );

  return FALSE;
}

/*
 * Message XML functions
 */

static xmlNodePtr
inf_chat_session_message_to_xml(InfChatSession* session,
                                const InfChatBufferMessage* message,
                                gboolean for_sync)
{
  xmlNodePtr xml;
  xml = xmlNewNode(NULL, (const xmlChar*)"message");

  if(message-&gt;type != INF_CHAT_BUFFER_MESSAGE_NORMAL)
  {
    inf_xml_util_set_attribute(
      xml,
      "type",
      inf_chat_session_message_type_to_string(message-&gt;type)
    );
  }

  if(for_sync)
    inf_xml_util_set_attribute_long(xml, "time", (long)message-&gt;time);

  inf_xml_util_set_attribute_uint(
    xml,
    "user",
    inf_user_get_id(message-&gt;user)
  );

  if(message-&gt;text != NULL)
    inf_xml_util_add_child_text(xml, message-&gt;text, message-&gt;length);

  return xml;
}

static gboolean
inf_chat_session_message_from_xml(InfChatSession* session,
                                  InfChatBufferMessage* message,
                                  xmlNodePtr xml,
                                  gboolean for_sync,
                                  GError** error)
{
  xmlChar* type;
  gboolean result;
  InfChatBufferMessageType message_type;
  InfChatBufferMessageFlags message_flags;
  long message_time;
  guint user_id;
  InfUserTable* user_table;
  InfUser* user;

  message_flags = 0;

  type = inf_xml_util_get_attribute(xml, "type");
  if(type == NULL)
  {
    message_type = INF_CHAT_BUFFER_MESSAGE_NORMAL;
  }
  else
  {
    result = inf_chat_session_message_type_from_string(
      (const char*)type,
      &amp;message_type,
      error
    );

    xmlFree(type);
    if(result == FALSE) return FALSE;
  }

  if(for_sync)
  {
    result = inf_xml_util_get_attribute_long_required(
      xml,
      "time",
      &amp;message_time,
      error
    );

    if(result == FALSE) return FALSE;
    message_flags = INF_CHAT_BUFFER_MESSAGE_BACKLOG;
  }
  else
  {
    if(message_type == INF_CHAT_BUFFER_MESSAGE_USERJOIN ||
       message_type == INF_CHAT_BUFFER_MESSAGE_USERPART)
    {
      g_set_error(
        error,
        inf_chat_session_error_quark,
        INF_CHAT_SESSION_ERROR_TYPE_INVALID,
        "Non-backlog message type cannot be \"%s\"",
        inf_chat_session_message_type_to_string(message_type)
      );

      return FALSE;
    }

    message_time = time(NULL);
  }

  if(!inf_xml_util_get_attribute_uint_required(xml, "user", &amp;user_id, error))
    return FALSE;

  user_table = inf_session_get_user_table(INF_SESSION(session));
  user = inf_user_table_lookup_user_by_id(user_table, user_id);

  if(user == NULL)
  {
    g_set_error(
      error,
      inf_chat_session_error_quark,
      INF_CHAT_SESSION_ERROR_NO_SUCH_USER,
      _("No such user with ID \"%u\""),
      user_id
    );

    return FALSE;
  }

  if(message_type != INF_CHAT_BUFFER_MESSAGE_USERJOIN &amp;&amp;
     message_type != INF_CHAT_BUFFER_MESSAGE_USERPART)
  {
    message-&gt;text =
      inf_xml_util_get_child_text(xml, &amp;message-&gt;length, NULL, error);
    if(!message-&gt;text)
      return FALSE;
  }
  else
  {
    message-&gt;text = NULL;
    message-&gt;length = 0;
  }

  message-&gt;type = message_type;
  message-&gt;user = user;
  message-&gt;time = message_time;
  message-&gt;flags = message_flags;

  return TRUE;
}

/*
 * Logging functions
 */

static gchar*
inf_chat_session_strdup_strftime(const char* format,
                                 const struct tm* tm,
                                 gsize* len)
{
  gsize alloc;
  gchar* str;
  size_t result;

  alloc = 64;
  str = g_malloc(alloc * sizeof(gchar));
  result = strftime(str, alloc, format, tm);

  while(result == 0 &amp;&amp; alloc &lt; 1024)
  {
    alloc *= 2;
    str = g_realloc(str, alloc * sizeof(gchar));
    result = strftime(str, alloc, format, tm);
  }

  if(result == 0)
  {
    g_free(str);
    return NULL;
  }

  if(len) *len = result;
  return str;
}

static void
inf_chat_session_log_message(InfChatSession* session,
                             const InfChatBufferMessage* message)
{
  InfChatSessionPrivate* priv;
  struct tm* tm;
  gchar* time_str;
  const gchar* name;
  const gchar* text;

  priv = INF_CHAT_SESSION_PRIVATE(session);

  if(priv-&gt;log_file != NULL)
  {
    tm = localtime(&amp;message-&gt;time);
    time_str = inf_chat_session_strdup_strftime("%c", tm, NULL);
    name = inf_user_get_name(message-&gt;user);
    text = message-&gt;text;

    switch(message-&gt;type)
    {
    case INF_CHAT_BUFFER_MESSAGE_NORMAL:
      fprintf(priv-&gt;log_file, "%s &lt;%s&gt; %s\n", time_str, name, message-&gt;text);
      break;
    case INF_CHAT_BUFFER_MESSAGE_EMOTE:
      fprintf(priv-&gt;log_file, "%s * %s %s\n", time_str, name, message-&gt;text);
      break;
    case INF_CHAT_BUFFER_MESSAGE_USERJOIN:
      fprintf(priv-&gt;log_file, _("%s --- %s has joined\n"), time_str, name);
      break;
    case INF_CHAT_BUFFER_MESSAGE_USERPART:
      fprintf(priv-&gt;log_file, _("%s --- %s has left\n"), time_str, name);
      break;
    default:
      g_assert_not_reached();
      break;
    }

    g_free(time_str);
    fflush(priv-&gt;log_file);
  }
}

static void
inf_chat_session_log_userlist_foreach_func(InfUser* user,
                                           gpointer user_data)
{
  InfChatSessionLogUserlistForeachData* data;
  data = (InfChatSessionLogUserlistForeachData*)user_data;

  if(inf_user_get_status(user) != INF_USER_UNAVAILABLE)
  {
    fprintf(
      data-&gt;log_file,
      "%s --- [%s]\n",
      data-&gt;time_str,
      inf_user_get_name(user)
    );

    ++ data-&gt;users_total;
  }
}

static void
inf_chat_session_log_userlist(InfChatSession* session)
{
  InfChatSessionPrivate* priv;
  InfChatSessionLogUserlistForeachData data;
  time_t cur_time;
  struct tm* tm;

  priv = INF_CHAT_SESSION_PRIVATE(session);
  if(priv-&gt;log_file != NULL)
  {
    cur_time = time(NULL);
    tm = localtime(&amp;cur_time);

    data.time_str = inf_chat_session_strdup_strftime("%c", tm, NULL);
    data.log_file = priv-&gt;log_file;
    data.users_total = 0;

    inf_user_table_foreach_user(
      inf_session_get_user_table(INF_SESSION(session)),
      inf_chat_session_log_userlist_foreach_func,
      &amp;data
    );

    fprintf(
      data.log_file,
      _("%s --- %u users total\n"),
      data.time_str,
      data.users_total
    );

    g_free(data.time_str);
    fflush(data.log_file);
  }
}

/*
 * Message reception
 */

static gboolean
inf_chat_session_receive_message(InfChatSession* session,
                                 InfXmlConnection* connection,
                                 xmlNodePtr xml,
                                 GError** error)
{
  InfChatSessionPrivate* priv;
  InfChatBufferMessage message;
  gboolean sync;

  priv = INF_CHAT_SESSION_PRIVATE(session);

  if(inf_session_get_status(INF_SESSION(session)) ==
     INF_SESSION_SYNCHRONIZING)
  {
    sync = TRUE;
  }
  else
  {
    sync = FALSE;
  }

  if(!inf_chat_session_message_from_xml(session, &amp;message, xml, sync, error))
    return FALSE;

  if(!sync &amp;&amp;
     (inf_user_get_status(message.user) == INF_USER_UNAVAILABLE ||
      inf_user_get_connection(message.user) != connection))
  {
    g_set_error_literal(
      error,
      inf_user_error_quark(),
      INF_USER_ERROR_NOT_JOINED,
      _("User did not join from this connection")
    );

    g_free(message.text);
    return FALSE;
  }

  g_signal_emit(
    session,
    chat_session_signals[RECEIVE_MESSAGE],
    0,
    &amp;message
  );

  g_free(message.text);
  return TRUE;
}

static void
inf_chat_session_user_join(InfChatSession* session,
                           InfUser* user)
{
  InfChatBufferMessage message;

  message.type = INF_CHAT_BUFFER_MESSAGE_USERJOIN;
  message.user = user;
  message.text = NULL;
  message.length = 0;
  message.time = time(NULL);
  message.flags = 0;

  g_signal_emit(session, chat_session_signals[RECEIVE_MESSAGE], 0, &amp;message);
}

static void
inf_chat_session_user_part(InfChatSession* session,
                           InfUser* user)
{
  InfChatBufferMessage message;

  message.type = INF_CHAT_BUFFER_MESSAGE_USERPART;
  message.user = user;
  message.text = NULL;
  message.length = 0;
  message.time = time(NULL);
  message.flags = 0;

  g_signal_emit(session, chat_session_signals[RECEIVE_MESSAGE], 0, &amp;message);
}

/*
 * Signal handlers
 */

static void
inf_chat_session_set_status_cb(InfUser* user,
                               InfUserStatus new_status,
                               gpointer user_data)
{
  InfSession* session;
  session = INF_SESSION(user_data);

  if(inf_session_get_status(session) == INF_SESSION_RUNNING)
  {
    if(inf_user_get_status(user) != INF_USER_UNAVAILABLE &amp;&amp;
       new_status == INF_USER_UNAVAILABLE)
    {
      inf_chat_session_user_part(INF_CHAT_SESSION(session), user);
    }
    else if(inf_user_get_status(user) == INF_USER_UNAVAILABLE &amp;&amp;
            new_status != INF_USER_UNAVAILABLE)
    {
      inf_chat_session_user_join(INF_CHAT_SESSION(session), user);
    }
  }
}

static void
inf_chat_session_add_user_cb(InfUserTable* user_table,
                             InfUser* user,
                             gpointer user_data)
{
  g_signal_connect(
    user,
    "set-status",
    G_CALLBACK(inf_chat_session_set_status_cb),
    user_data
  );

  if(inf_session_get_status(INF_SESSION(user_data)) == INF_SESSION_RUNNING)
    if(inf_user_get_status(user) != INF_USER_UNAVAILABLE)
      inf_chat_session_user_join(INF_CHAT_SESSION(user_data), user);
}

static void
inf_chat_session_remove_user_cb(InfUserTable* user_table,
                                InfUser* user,
                                gpointer user_data)
{
  if(inf_session_get_status(INF_SESSION(user_data)) == INF_SESSION_RUNNING)
    if(inf_user_get_status(user) != INF_USER_UNAVAILABLE)
      inf_chat_session_user_part(INF_CHAT_SESSION(user_data), user);

  inf_signal_handlers_disconnect_by_func(
    user,
    G_CALLBACK(inf_chat_session_set_status_cb),
    user_data
  );
}

static void
inf_chat_session_add_message_cb(InfChatBuffer* buffer,
                                const InfChatBufferMessage* message,
                                gpointer user_data)
{
  /* Ignore these messages, we cannot send them */
  if(message-&gt;type != INF_CHAT_BUFFER_MESSAGE_USERJOIN &amp;&amp;
     message-&gt;type != INF_CHAT_BUFFER_MESSAGE_USERPART)
  {
    /* A message has been added to the buffer, so send it */
    g_signal_emit(
      user_data,
      chat_session_signals[SEND_MESSAGE],
      0,
      message
    );
  }
}

/*
 * GObject overrides
 */

static void
inf_chat_session_init(InfChatSession* session)
{
  InfChatSessionPrivate* priv;
  priv = INF_CHAT_SESSION_PRIVATE(session);

  priv-&gt;log_filename = NULL;
  priv-&gt;log_file = NULL;
}

static void
inf_chat_session_constructed_foreach_user_func(InfUser* user,
                                               gpointer user_data)
{
  g_signal_connect(
    user,
    "set-status",
    G_CALLBACK(inf_chat_session_set_status_cb),
    user_data
  );
}

static void
inf_chat_session_constructed(GObject* object)
{
  InfUserTable* user_table;
  InfChatBuffer* buffer;

  G_OBJECT_CLASS(inf_chat_session_parent_class)-&gt;constructed(object);
  user_table = inf_session_get_user_table(INF_SESSION(object));

  g_signal_connect_after(
    user_table,
    "add-user",
    G_CALLBACK(inf_chat_session_add_user_cb),
    object
  );

  g_signal_connect_after(
    user_table,
    "remove-user",
    G_CALLBACK(inf_chat_session_remove_user_cb),
    object
  );

  inf_user_table_foreach_user(
    INF_USER_TABLE(user_table),
    inf_chat_session_constructed_foreach_user_func,
    object
  );

  buffer = INF_CHAT_BUFFER(inf_session_get_buffer(INF_SESSION(object)));
  g_assert(INF_IS_CHAT_BUFFER(buffer));

  g_signal_connect_after(
    buffer,
    "add-message",
    G_CALLBACK(inf_chat_session_add_message_cb),
    object
  );
}

static void
inf_chat_session_dispose_foreach_user_func(InfUser* user,
                                           gpointer user_data)
{
  inf_signal_handlers_disconnect_by_func(
    user,
    G_CALLBACK(inf_chat_session_set_status_cb),
    user_data
  );
}

static void
inf_chat_session_dispose(GObject* object)
{
  InfChatSession* session;
  InfChatBuffer* buffer;
  InfUserTable* user_table;

  session = INF_CHAT_SESSION(object);
  user_table = inf_session_get_user_table(INF_SESSION(session));
  buffer = INF_CHAT_BUFFER(inf_session_get_buffer(INF_SESSION(session)));

  inf_user_table_foreach_user(
    INF_USER_TABLE(user_table),
    inf_chat_session_dispose_foreach_user_func,
    session
  );

  inf_signal_handlers_disconnect_by_func(
    user_table,
    G_CALLBACK(inf_chat_session_add_user_cb),
    session
  );

  inf_signal_handlers_disconnect_by_func(
    user_table,
    G_CALLBACK(inf_chat_session_remove_user_cb),
    session
  );

  inf_signal_handlers_disconnect_by_func(
    buffer,
    G_CALLBACK(inf_chat_session_add_message_cb),
    session
  );

  G_OBJECT_CLASS(inf_chat_session_parent_class)-&gt;dispose(object);
}

static void
inf_chat_session_finalize(GObject* object)
{
  InfChatSession* session;
  InfChatSessionPrivate* priv;

  session = INF_CHAT_SESSION(object);
  priv = INF_CHAT_SESSION_PRIVATE(session);

  inf_chat_session_set_log_file(session, NULL, NULL);

  G_OBJECT_CLASS(inf_chat_session_parent_class)-&gt;finalize(object);
}

static void
inf_chat_session_set_property(GObject* object,
                              guint prop_id,
                              const GValue* value,
                              GParamSpec* pspec)
{
  InfChatSession* session;
  InfChatSessionPrivate* priv;
  const gchar* log_file;
  GError* error;

  session = INF_CHAT_SESSION(object);
  priv = INF_CHAT_SESSION_PRIVATE(session);

  switch(prop_id)
  {
  case PROP_LOG_FILE:
    error = NULL;
    log_file = g_value_get_string(value);

    if(!inf_chat_session_set_log_file(session, log_file, &amp;error))
    {
      g_warning("Failed to set log file: %s\n", error-&gt;message);
<a name="0"></a>      g_error_free(error);
    }

<font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>    break;
  default:
    G_OBJECT_WARN_INVALID_PROPERTY_ID(object, prop_id, pspec);
    break;
  }
}

static void
inf_chat_session_get_property(GObject* object,
                              guint prop_id,
                              GValue* value,
                              GParamSpec* pspec)
{
  InfChatSession* session;
  InfChatSessionPrivate* priv;

  session = INF_CHAT_SESSION(object);
  priv = INF_CHAT_SESSION_PRIVATE(session);

  switch(prop_id)
  {
  case PROP_LOG_FILE:
    g_value_set_string(value, priv-&gt;log_filename);
    break;</b></font>
  default:
    G_OBJECT_WARN_INVALID_PROPERTY_ID(object, prop_id, pspec);
    break;
  }
}

/*
 * InfSession virtual functions and default signal handlers
 */

static void
inf_chat_session_to_xml_sync(InfSession* session,
                             xmlNodePtr parent)
{
  InfChatBuffer* buffer;
  InfSessionClass* parent_class;
  const InfChatBufferMessage* message;
  xmlNodePtr child;
  guint i;

  buffer = INF_CHAT_BUFFER(inf_session_get_buffer(session));
  parent_class = INF_SESSION_CLASS(inf_chat_session_parent_class);

  g_assert(parent_class-&gt;to_xml_sync != NULL);
  parent_class-&gt;to_xml_sync(session, parent);

  for(i = 0; i &lt; inf_chat_buffer_get_n_messages(buffer); ++i)
  {
    message = inf_chat_buffer_get_message(buffer, i);

    child = inf_chat_session_message_to_xml(
      INF_CHAT_SESSION(session),
      message,
      TRUE
    );

    xmlAddChild(parent, child);
  }
}

static gboolean
inf_chat_session_process_xml_sync(InfSession* session,
                                  InfXmlConnection* connection,
                                  xmlNodePtr xml,
                                  GError** error)
{
  InfSessionClass* parent_class;

  if(strcmp((const char*)xml-&gt;name, "message") == 0)
  {
    return inf_chat_session_receive_message(
      INF_CHAT_SESSION(session),
      connection,
      xml,
      error
    );
  }
  else
  {
    parent_class = INF_SESSION_CLASS(inf_chat_session_parent_class);
    g_assert(parent_class-&gt;process_xml_sync != NULL);
    return parent_class-&gt;process_xml_sync(session, connection, xml, error);
  }
}

static InfCommunicationScope
inf_chat_session_process_xml_run(InfSession* session,
                                 InfXmlConnection* connection,
                                 xmlNodePtr xml,
                                 GError** error)
{
  InfSessionClass* parent_class;
  gboolean result;

  if(strcmp((const char*)xml-&gt;name, "message") == 0)
  {
    result = inf_chat_session_receive_message(
      INF_CHAT_SESSION(session),
      connection,
      xml,
      error
    );

    if(!result)
      return INF_COMMUNICATION_SCOPE_PTP;
    else
      return INF_COMMUNICATION_SCOPE_GROUP;
  }
  else
  {
    parent_class = INF_SESSION_CLASS(inf_chat_session_parent_class);
    g_assert(parent_class-&gt;process_xml_run != NULL);
    return parent_class-&gt;process_xml_run(session, connection, xml, error);
  }
}

static void
inf_chat_session_synchronization_complete(InfSession* session,
                                          InfXmlConnection* connection)
{
  InfSessionClass* parent_class;

  if(inf_session_get_status(session) == INF_SESSION_SYNCHRONIZING)
    inf_chat_session_log_userlist(INF_CHAT_SESSION(session));

  parent_class = INF_SESSION_CLASS(inf_chat_session_parent_class);
  g_assert(parent_class-&gt;synchronization_complete != NULL);
  parent_class-&gt;synchronization_complete(session, connection);
}

static void
inf_chat_session_synchronization_failed(InfSession* session,
                                        InfXmlConnection* connection,
                                        const GError* error)
{
  InfSessionClass* parent_class;
  InfChatSessionPrivate* priv;
  time_t cur_time;
  struct tm* tm;
  gchar* time_str;

  if(inf_session_get_status(session) == INF_SESSION_SYNCHRONIZING)
  {
    priv = INF_CHAT_SESSION_PRIVATE(session);
    if(priv-&gt;log_file != NULL)
    {
      cur_time = time(NULL);
      tm = localtime(&amp;cur_time);
      time_str = inf_chat_session_strdup_strftime("%c", tm, NULL);

      fprintf(
        priv-&gt;log_file,
        "%s --- Synchronization failed: %s\n",
        time_str,
        error-&gt;message
      );

      g_free(time_str);
    }
  }

  parent_class = INF_SESSION_CLASS(inf_chat_session_parent_class);
  g_assert(parent_class-&gt;synchronization_failed != NULL);
  parent_class-&gt;synchronization_failed(session, connection, error);
}

static InfUser*
inf_chat_session_user_new(InfSession* session,
                          GParameter* params,
                          guint n_params)
{
  return g_object_newv(INF_TYPE_USER, n_params, params);
}

static void
inf_chat_session_receive_message_handler(InfChatSession* session,
                                         const InfChatBufferMessage* message)
{
  InfChatBuffer* buffer;
  buffer = INF_CHAT_BUFFER(inf_session_get_buffer(INF_SESSION(session)));

  /* The add_message signal handler would try to send the message, so prevent
   * this. */
  inf_signal_handlers_block_by_func(
    buffer,
    G_CALLBACK(inf_chat_session_add_message_cb),
    session
  );

  switch(message-&gt;type)
  {
  case INF_CHAT_BUFFER_MESSAGE_NORMAL:
    inf_chat_buffer_add_message(
      buffer,
      message-&gt;user,
      message-&gt;text,
      message-&gt;length,
      message-&gt;time,
      message-&gt;flags
    );
    break;
  case INF_CHAT_BUFFER_MESSAGE_EMOTE:
    inf_chat_buffer_add_emote_message(
      buffer,
      message-&gt;user,
      message-&gt;text,
      message-&gt;length,
      message-&gt;time,
      message-&gt;flags
    );
    break;
  case INF_CHAT_BUFFER_MESSAGE_USERJOIN:
    inf_chat_buffer_add_userjoin_message(
      buffer,
      message-&gt;user,
      message-&gt;time,
      message-&gt;flags
    );
    break;
  case INF_CHAT_BUFFER_MESSAGE_USERPART:
    inf_chat_buffer_add_userpart_message(
      buffer,
      message-&gt;user,
      message-&gt;time,
      message-&gt;flags
    );
    break;
  default:
    g_assert_not_reached();
    break;
  }

  inf_signal_handlers_unblock_by_func(
    buffer,
    G_CALLBACK(inf_chat_session_add_message_cb),
    session
  );

  /* Backlog messages (received during synchronization) are not yet logged.
   * We will need to parse the last messages in the log first and check
   * whether they have already been logged. */
  if(inf_session_get_status(INF_SESSION(session)) == INF_SESSION_RUNNING)
    inf_chat_session_log_message(session, message);
}

static void
inf_chat_session_send_message_handler(InfChatSession* session,
                                      const InfChatBufferMessage* message)
{
  xmlNodePtr xml;

  /* Actually send the message over the network */
  xml = inf_chat_session_message_to_xml(session, message, FALSE);
  inf_session_send_to_subscriptions(INF_SESSION(session), xml);

  inf_chat_session_log_message(session, message);
}

/*
 * GType registration
 */

static void
inf_chat_session_class_init(InfChatSessionClass* chat_session_class)
{
  GObjectClass* object_class;
  InfSessionClass* session_class;

  object_class = G_OBJECT_CLASS(chat_session_class);
  session_class = INF_SESSION_CLASS(chat_session_class);

  object_class-&gt;constructed = inf_chat_session_constructed;
  object_class-&gt;dispose = inf_chat_session_dispose;
  object_class-&gt;finalize = inf_chat_session_finalize;
  object_class-&gt;set_property = inf_chat_session_set_property;
  object_class-&gt;get_property = inf_chat_session_get_property;

  session_class-&gt;to_xml_sync = inf_chat_session_to_xml_sync;
  session_class-&gt;process_xml_sync = inf_chat_session_process_xml_sync;
  session_class-&gt;process_xml_run = inf_chat_session_process_xml_run;
  session_class-&gt;synchronization_complete =
    inf_chat_session_synchronization_complete;
  session_class-&gt;synchronization_failed =
    inf_chat_session_synchronization_failed;

  session_class-&gt;user_new = inf_chat_session_user_new;

  chat_session_class-&gt;receive_message =
    inf_chat_session_receive_message_handler;
  chat_session_class-&gt;send_message =
    inf_chat_session_send_message_handler;

  inf_chat_session_error_quark =
    g_quark_from_static_string("INF_CHAT_SESSION_ERROR");

  g_object_class_install_property(
    object_class,
    PROP_LOG_FILE,
    g_param_spec_string(
      "log-file",
      "Log file",
      "The file into which to store all received messages",
      NULL,
      G_PARAM_READWRITE
    )
  );

  /**
   * InfChatSession::receive-message:
   * @session: The #InfChatSession that is receiving a message.
   * @message: The #InfChatBufferMessage that was received.
   *
   * This signal is emitted whenever a message has been received. If the
   * session is in %INF_SESSION_SYNCHRONIZING state the received message was
   * a backlog message.
   */
  chat_session_signals[RECEIVE_MESSAGE] = g_signal_new(
    "receive-message",
    G_OBJECT_CLASS_TYPE(object_class),
    G_SIGNAL_RUN_LAST,
    G_STRUCT_OFFSET(InfChatSessionClass, receive_message),
    NULL, NULL,
    g_cclosure_marshal_VOID__BOXED,
    G_TYPE_NONE,
    1,
    INF_TYPE_CHAT_BUFFER_MESSAGE | G_SIGNAL_TYPE_STATIC_SCOPE
  );

  /**
   * InfChatSession::send-message:
   * @session: The #InfChatSession that is sending a message.
   * @message: The #InfChatBufferMessage that is sent.
   *
   * This signal is emitted whenever a message is sent. Messages can be sent
   * by calling inf_chat_buffer_add_message() or
   * inf_chat_buffer_add_emote_message() on the session's #InfChatBuffer.
   * Messages of type %INF_CHAT_BUFFER_MESSAGE_USERJOIN or
   * %INF_CHAT_BUFFER_MESSAGE_USERPART can not be sent explicitely, so this
   * signal will never be emitted for such messages.
   */
  chat_session_signals[SEND_MESSAGE] = g_signal_new(
    "send-message",
    G_OBJECT_CLASS_TYPE(object_class),
    G_SIGNAL_RUN_LAST,
    G_STRUCT_OFFSET(InfChatSessionClass, send_message),
    NULL, NULL,
    g_cclosure_marshal_VOID__BOXED,
    G_TYPE_NONE,
    1,
    INF_TYPE_CHAT_BUFFER_MESSAGE | G_SIGNAL_TYPE_STATIC_SCOPE
  );
}

/*
 * Public API
 */

/**
 * inf_chat_session_new: (constructor)
 * @manager: A #InfCommunicationManager.
 * @buffer: The #InfChatBuffer to use for the session.
 * @status: Initial status of the session. If this is
 * %INF_SESSION_SYNCHRONIZING or %INF_SESSION_PRESYNC, then @sync_group and
 * @sync_connection need to be set.
 * @sync_group: A group in which the session is synchronized. Ignored if
 * @status is %INF_SESSION_RUNNING.
 * @sync_connection: A connection to synchronize the session from. Ignored if
 * @status is %INF_SESSION_RUNNING.
 *
 * Creates a new #InfChatSession with the messages contained in @buffer as
 * initial messages. The communication manager is used to send and receive
 * requests from subscription and synchronization.
 *
 * If @status is %INF_SESSION_PRESYNC or %INF_SESSION_SYNCHRONIZING, then the
 * session will initially be synchronized, meaning an initial backlog is
 * retrieved from @sync_connection (which must not be %NULL in this case). If
 * you are subscribed to the session, set the subscription group via
 * inf_session_set_subscription_group().
 *
 * Returns: (transfer full): A new #InfChatSession.
 */
InfChatSession*
inf_chat_session_new(InfCommunicationManager* manager,
                     InfChatBuffer* buffer,
                     InfSessionStatus status,
                     InfCommunicationGroup* sync_group,
                     InfXmlConnection* sync_connection)
{
  InfChatSession* session;

  g_return_val_if_fail(INF_COMMUNICATION_IS_MANAGER(manager), NULL);
  g_return_val_if_fail(INF_IS_CHAT_BUFFER(buffer), NULL);

  g_return_val_if_fail(
    (status == INF_SESSION_RUNNING &amp;&amp;
     sync_group == NULL &amp;&amp; sync_connection == NULL) ||
    (status != INF_SESSION_RUNNING &amp;&amp;
     INF_COMMUNICATION_IS_GROUP(sync_group) &amp;&amp;
     INF_IS_XML_CONNECTION(sync_connection)),
    NULL
  );

  session = INF_CHAT_SESSION(
    g_object_new(
      INF_TYPE_CHAT_SESSION,
      "communication-manager", manager,
      "buffer", buffer,
      "status", status,
      "sync-group", sync_group,
      "sync-connection", sync_connection,
      NULL
    )
  );

  return session;
}

/**
 * inf_chat_session_set_log_file:
 * @session: A #InfChatSession.
 * @log_file: (type filename): A filename to store all received messages into.
 * @error: Location to store error information, if any.
 *
 * Sets a file onto which all received messages are appended. The file is
 * created if it does not exist. If a previous log file was set, then it is
 * closed before opening the new file.
 *
 * Backlog messages received upon synchronization are not logged.
 *
 * Returns: %TRUE if the log file could be opened, %FALSE otherwise (in which
 * case @error is set).
 */
gboolean
inf_chat_session_set_log_file(InfChatSession* session,
                              const gchar* log_file,
                              GError** error)
{
  InfChatSessionPrivate* priv;
  FILE* new_file;
  int save_errno;
  long offset;
  time_t cur_time;
  struct tm* tm;
  gchar* time_str;
  guint len;

  g_return_val_if_fail(INF_IS_CHAT_SESSION(session), FALSE);
  priv = INF_CHAT_SESSION_PRIVATE(session);

  /* Open the new log file before doing anything else, so that we keep
   * the current log file if this fails. */
  if(log_file != NULL)
  {
    new_file = fopen(log_file, "a");
    if(new_file == NULL)
    {
      save_errno = errno;
    }
    else
    {
      offset = ftell(new_file);
      if(offset == -1)
      {
        save_errno = errno;
        fclose(new_file);
        new_file = NULL;
      }
    }

    if(new_file == NULL)
    {
      g_set_error_literal(
        error,
        G_FILE_ERROR,
        g_file_error_from_errno(save_errno),
        strerror(save_errno)
      );

      return FALSE;
    }
  }

  cur_time = time(NULL);
  tm = localtime(&amp;cur_time);
  time_str = inf_chat_session_strdup_strftime("%c", tm, NULL);

  if(priv-&gt;log_file != NULL)
  {
    fprintf(priv-&gt;log_file, _("%s --- Log closed\n"), time_str);
    fclose(priv-&gt;log_file);
  }

  if(log_file != NULL)
  {
    len = strlen(log_file);
    priv-&gt;log_filename =
      g_realloc(priv-&gt;log_filename, (len + 1) * sizeof(gchar));
    memcpy(priv-&gt;log_filename, log_file, len);
    priv-&gt;log_filename[len] = '\0';
    priv-&gt;log_file = new_file;

    if(offset &gt; 0) fprintf(priv-&gt;log_file, "\n");
    fprintf(priv-&gt;log_file, _("%s --- Log opened\n"), time_str);

    if(inf_session_get_status(INF_SESSION(session)) == INF_SESSION_RUNNING)
      inf_chat_session_log_userlist(session);
    else
      fflush(priv-&gt;log_file);
  }
  else
  {
    g_free(priv-&gt;log_filename);
    priv-&gt;log_filename = NULL;
    priv-&gt;log_file = NULL;
  }

  g_free(time_str);
  return TRUE;
}

/* vim:set et sw=2 ts=2: */
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerHTML.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
