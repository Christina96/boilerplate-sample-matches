<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for inf-simulated-connection.c &amp; inf-chat-session.c</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for inf-simulated-connection.c &amp; inf-chat-session.c
      </h3>
<h1 align="center">
        3.2%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>inf-simulated-connection.c (5.109489%)<th>inf-chat-session.c (2.3569024%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(241-265)<td><a href="#" name="0">(752-775)</a><td align="center"><font color="#ff0000">14</font>
</td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>inf-simulated-connection.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 #include &lt;libinfinity/common/inf-simulated-connection.h&gt;
2 #include &lt;libinfinity/common/inf-xml-connection.h&gt;
3 #include &lt;libinfinity/inf-define-enum.h&gt;
4 static const GEnumValue inf_simulated_connection_mode_values[] = {
5   {
6     INF_SIMULATED_CONNECTION_IMMEDIATE,
7     "INF_SIMULATED_CONNECTION_IMMEDIATE",
8     "immediate"
9   }, {
10     INF_SIMULATED_CONNECTION_DELAYED,
11     "INF_SIMULATED_CONNECTION_DELAYED",
12     "delayed"
13   }, {
14     INF_SIMULATED_CONNECTION_IO_CONTROLLED,
15     "INF_SIMULATED_CONNECTION_IO_CONTROLLED",
16     "io-controlled"
17   }, {
18     0,
19     NULL,
20     NULL
21   }
22 };
23 typedef struct _InfSimulatedConnectionPrivate InfSimulatedConnectionPrivate;
24 struct _InfSimulatedConnectionPrivate {
25   InfIo* io;
26   InfIoDispatch* io_handler;
27   InfSimulatedConnection* target;
28   InfSimulatedConnectionMode mode;
29   xmlNodePtr queue;
30   xmlNodePtr queue_last_item;
31 };
32 enum {
33   PROP_0,
34   PROP_IO,
35   PROP_TARGET,
36   PROP_MODE,
37   PROP_STATUS,
38   PROP_NETWORK,
39   PROP_LOCAL_ID,
40   PROP_REMOTE_ID,
41   PROP_LOCAL_CERTIFICATE,
42   PROP_REMOTE_CERTIFICATE
43 };
44 #define INF_SIMULATED_CONNECTION_PRIVATE(obj) (G_TYPE_INSTANCE_GET_PRIVATE((obj), INF_TYPE_SIMULATED_CONNECTION, InfSimulatedConnectionPrivate))
45 static void inf_simulated_connection_xml_connection_iface_init(InfXmlConnectionInterface* iface);
46 INF_DEFINE_ENUM_TYPE(InfSimulatedConnectionMode, inf_simulated_connection_mode, inf_simulated_connection_mode_values)
47 G_DEFINE_TYPE_WITH_CODE(InfSimulatedConnection, inf_simulated_connection, G_TYPE_OBJECT,
48   G_ADD_PRIVATE(InfSimulatedConnection)
49   G_IMPLEMENT_INTERFACE(INF_TYPE_XML_CONNECTION, inf_simulated_connection_xml_connection_iface_init))
50 static void
51 inf_simulated_connection_clear_queue(InfSimulatedConnection* connection)
52 {
53   InfSimulatedConnectionPrivate* priv;
54   xmlNodePtr next;
55   priv = INF_SIMULATED_CONNECTION_PRIVATE(connection);
56   if(priv-&gt;io_handler != NULL)
57   {
58     g_assert(priv-&gt;io != NULL);
59     inf_io_remove_dispatch(priv-&gt;io, priv-&gt;io_handler);
60     priv-&gt;io_handler = NULL;
61   }
62   while(priv-&gt;queue != NULL)
63   {
64     next = priv-&gt;queue-&gt;next;
65     xmlFreeNode(priv-&gt;queue);
66     priv-&gt;queue = next;
67   }
68   priv-&gt;queue_last_item = NULL;
69 }
70 static void
71 inf_simulated_connection_unset_target(InfSimulatedConnection* connection)
72 {
73   InfSimulatedConnectionPrivate* priv;
74   InfSimulatedConnection* target;
75   InfSimulatedConnectionPrivate* target_priv;
76   priv = INF_SIMULATED_CONNECTION_PRIVATE(connection);
77   target = priv-&gt;target;
78   if(target != NULL)
79   {
80     target_priv = INF_SIMULATED_CONNECTION_PRIVATE(priv-&gt;target);
81     g_assert(target_priv-&gt;target == connection);
82     priv-&gt;target = NULL;
83     target_priv-&gt;target = NULL;
84     inf_simulated_connection_clear_queue(connection);
85     inf_simulated_connection_clear_queue(target);
86     g_object_notify(G_OBJECT(connection), "target");
87     g_object_notify(G_OBJECT(connection), "status");
88     g_object_notify(G_OBJECT(target), "target");
89     g_object_notify(G_OBJECT(target), "status");
90   }
91 }
92 static void
93 inf_simulated_connection_set_target(InfSimulatedConnection* connection,
94                                     InfSimulatedConnection* target)
95 {
96   InfSimulatedConnectionPrivate* priv;
97   inf_simulated_connection_unset_target(connection);
98   if(target != NULL) inf_simulated_connection_unset_target(target);
99   priv = INF_SIMULATED_CONNECTION_PRIVATE(connection);
100   priv-&gt;target = target;
101   if(target != NULL)
102   {
103     priv = INF_SIMULATED_CONNECTION_PRIVATE(target);
104     priv-&gt;target = connection;
105   }
106   g_object_notify(G_OBJECT(connection), "target");
107   g_object_notify(G_OBJECT(connection), "status");
108   if(target != NULL)
109   {
110     g_object_notify(G_OBJECT(target), "target");
111     g_object_notify(G_OBJECT(target), "status");
112   }
113 }
114 static void
115 inf_simulated_connection_init(InfSimulatedConnection* connection)
116 {
117   InfSimulatedConnectionPrivate* priv;
118   priv = INF_SIMULATED_CONNECTION_PRIVATE(connection);
119   priv-&gt;io = NULL;
120   priv-&gt;target = NULL;
121   priv-&gt;mode = INF_SIMULATED_CONNECTION_IMMEDIATE;
122 }
123 static void
124 inf_simulated_connection_dispose(GObject* object)
125 {
126   InfSimulatedConnection* connection;
127   InfSimulatedConnectionPrivate* priv;
128   connection = INF_SIMULATED_CONNECTION(object);
129   priv = INF_SIMULATED_CONNECTION_PRIVATE(connection);
130   inf_simulated_connection_unset_target(connection);
131   g_assert(priv-&gt;io_handler == NULL);
132   if(priv-&gt;io != NULL)
133   {
134     g_object_unref(priv-&gt;io);
135     priv-&gt;io = NULL;
136   }
137   G_OBJECT_CLASS(inf_simulated_connection_parent_class)-&gt;dispose(object);
138 }
139 static void
140 inf_simulated_connection_set_property(GObject* object,
141                                       guint prop_id,
142                                       const GValue* value,
143                                       GParamSpec* pspec)
144 {
145   InfSimulatedConnection* sim;
146   InfSimulatedConnectionPrivate* priv;
147   sim = INF_SIMULATED_CONNECTION(object);
148   priv = INF_SIMULATED_CONNECTION_PRIVATE(sim);
149   switch(prop_id)
150   {
151   case PROP_IO:
152     g_assert(priv-&gt;io == NULL);     priv-&gt;io = INF_IO(g_value_get_object(value));
153     if(priv-&gt;io) g_object_ref(priv-&gt;io);
154     break;
155   case PROP_TARGET:
156     inf_simulated_connection_set_target(
157       sim,
158       INF_SIMULATED_CONNECTION(g_value_get_object(value))
159     );
160 <a name="0"></a>    break;
161   case PROP_MODE:
162     inf_simulated_connection_set_mode(sim, g_value_get_enum(value));
163 <font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>    break;
164   default:
165     G_OBJECT_WARN_INVALID_PROPERTY_ID(object, prop_id, pspec);
166     break;
167   }
168 }
169 static void
170 inf_simulated_connection_get_property(GObject* object,
171                                       guint prop_id,
172                                       GValue* value,
173                                       GParamSpec* pspec)
174 {
175   InfSimulatedConnection* sim;
176   InfSimulatedConnectionPrivate* priv;
177   gchar* id;
178   sim = INF_SIMULATED_CONNECTION(object);
179   priv = INF_SIMULATED_CONNECTION_PRIVATE(sim);
180   switch(prop_id)
181   {
182   case PROP_IO:
183     g_value_set_object(value, G_OBJECT(priv-&gt;io));
184     break;</b></font>
185   case PROP_TARGET:
186     g_value_set_object(value, G_OBJECT(priv-&gt;target));
187     break;
188   case PROP_MODE:
189     g_value_set_enum(value, priv-&gt;mode);
190     break;
191   case PROP_STATUS:
192     if(priv-&gt;target != NULL)
193       g_value_set_enum(value, INF_XML_CONNECTION_OPEN);
194     else
195       g_value_set_enum(value, INF_XML_CONNECTION_CLOSED);
196     break;
197   case PROP_NETWORK:
198     g_value_set_static_string(value, "simulated");
199     break;
200   case PROP_LOCAL_ID:
201     id = g_strdup_printf("simulated-%p", (void*)sim);
202     g_value_take_string(value, id);
203     break;
204   case PROP_REMOTE_ID:
205     g_assert(priv-&gt;target != NULL);
206     id = g_strdup_printf("simulated-%p", (void*)priv-&gt;target);
207     g_value_take_string(value, id);
208     break;
209   case PROP_LOCAL_CERTIFICATE:
210     g_value_set_pointer(value, NULL);
211     break;
212   case PROP_REMOTE_CERTIFICATE:
213     g_value_set_boxed(value, NULL);
214     break;
215   default:
216     G_OBJECT_WARN_INVALID_PROPERTY_ID(object, prop_id, pspec);
217     break;
218   }
219 }
220 static void
221 inf_simulated_connection_xml_connection_close(InfXmlConnection* connection)
222 {
223   InfSimulatedConnectionPrivate* priv;
224   priv = INF_SIMULATED_CONNECTION_PRIVATE(connection);
225   g_assert(priv-&gt;target != NULL);
226   inf_simulated_connection_unset_target(INF_SIMULATED_CONNECTION(connection));
227 }
228 static void
229 inf_simulated_connection_dispatch_func(gpointer user_data)
230 {
231   InfSimulatedConnection* connection;
232   InfSimulatedConnectionPrivate* priv;
233   connection = INF_SIMULATED_CONNECTION(user_data);
234   priv = INF_SIMULATED_CONNECTION_PRIVATE(connection);
235   priv-&gt;io_handler = NULL;
236   inf_simulated_connection_flush(connection);
237 }
238 static void
239 inf_simulated_connection_xml_connection_send(InfXmlConnection* connection,
240                                              xmlNodePtr xml)
241 {
242   InfSimulatedConnectionPrivate* priv;
243   priv = INF_SIMULATED_CONNECTION_PRIVATE(connection);
244   g_assert(priv-&gt;target != NULL);
245   switch(priv-&gt;mode)
246   {
247   case INF_SIMULATED_CONNECTION_IMMEDIATE:
248     inf_xml_connection_sent(connection, xml);
249     inf_xml_connection_received(INF_XML_CONNECTION(priv-&gt;target), xml);
250     xmlFreeNode(xml);
251     break;
252   case INF_SIMULATED_CONNECTION_DELAYED:
253   case INF_SIMULATED_CONNECTION_IO_CONTROLLED:
254     xmlUnlinkNode(xml);
255     if(priv-&gt;queue == NULL)
256     {
257       priv-&gt;queue = xml;
258       priv-&gt;queue_last_item = xml;
259     }
260     else
261     {
262       priv-&gt;queue_last_item-&gt;next = xml;
263       priv-&gt;queue_last_item = xml;
264     }
265     if(priv-&gt;mode == INF_SIMULATED_CONNECTION_IO_CONTROLLED)
266     {
267       if(priv-&gt;io_handler == NULL)
268       {
269         g_assert(priv-&gt;io != NULL);
270         priv-&gt;io_handler = inf_io_add_dispatch(
271           priv-&gt;io,
272           inf_simulated_connection_dispatch_func,
273           connection,
274           NULL
275         );
276       }
277     }
278     break;
279   default:
280     g_assert_not_reached();
281     break;
282   }
283 }
284 static void
285 inf_simulated_connection_class_init(
286   InfSimulatedConnectionClass* connection_class)
287 {
288   GObjectClass* object_class;
289   object_class = G_OBJECT_CLASS(connection_class);
290   object_class-&gt;dispose = inf_simulated_connection_dispose;
291   object_class-&gt;set_property = inf_simulated_connection_set_property;
292   object_class-&gt;get_property = inf_simulated_connection_get_property;
293   g_object_class_install_property(
294     object_class,
295     PROP_IO,
296     g_param_spec_object(
297       "io",
298       "IO",
299       "The main loop to be used for IO_CONTROLLED mode",
300       INF_TYPE_IO,
301       G_PARAM_READWRITE | G_PARAM_CONSTRUCT_ONLY
302     )
303   );
304   g_object_class_install_property(
305     object_class,
306     PROP_TARGET,
307     g_param_spec_object(
308       "target",
309       "Target connection",
310       "The simulated connection receiving data sent through this connection",
311       INF_TYPE_SIMULATED_CONNECTION,
312       G_PARAM_READWRITE
313     )
314   );
315   g_object_class_install_property(
316     object_class,
317     PROP_MODE,
318     g_param_spec_enum(
319       "mode",
320       "Mode",
321       "The mode of the simulated connection",
322       INF_TYPE_SIMULATED_CONNECTION_MODE,
323       INF_SIMULATED_CONNECTION_IMMEDIATE,
324       G_PARAM_READWRITE | G_PARAM_CONSTRUCT
325     )
326   );
327   g_object_class_override_property(object_class, PROP_STATUS, "status");
328   g_object_class_override_property(object_class, PROP_NETWORK, "network");
329   g_object_class_override_property(object_class, PROP_LOCAL_ID, "local-id");
330   g_object_class_override_property(object_class, PROP_REMOTE_ID, "remote-id");
331   g_object_class_override_property(
332     object_class,
333     PROP_LOCAL_CERTIFICATE,
334     "local-certificate"
335   );
336   g_object_class_override_property(
337     object_class,
338     PROP_REMOTE_CERTIFICATE,
339     "remote-certificate"
340   );
341 }
342 static void
343 inf_simulated_connection_xml_connection_iface_init(
344   InfXmlConnectionInterface* iface)
345 {
346   iface-&gt;close = inf_simulated_connection_xml_connection_close;
347   iface-&gt;send = inf_simulated_connection_xml_connection_send;
348 }
349 InfSimulatedConnection*
350 inf_simulated_connection_new(void)
351 {
352   GObject* object;
353   object = g_object_new(INF_TYPE_SIMULATED_CONNECTION, NULL);
354   return INF_SIMULATED_CONNECTION(object);
355 }
356 InfSimulatedConnection*
357 inf_simulated_connection_new_with_io(InfIo* io)
358 {
359   GObject* object;
360   g_return_val_if_fail(INF_IS_IO(io), NULL);
361   object = g_object_new(INF_TYPE_SIMULATED_CONNECTION, "io", io, NULL);
362   return INF_SIMULATED_CONNECTION(object);
363 }
364 void
365 inf_simulated_connection_connect(InfSimulatedConnection* connection,
366                                  InfSimulatedConnection* to)
367 {
368   inf_simulated_connection_set_target(connection, to);
369 }
370 void
371 inf_simulated_connection_set_mode(InfSimulatedConnection* connection,
372                                   InfSimulatedConnectionMode mode)
373 {
374   InfSimulatedConnectionPrivate* priv;
375   priv = INF_SIMULATED_CONNECTION_PRIVATE(connection);
376   g_return_if_fail(priv-&gt;io != NULL ||
377                    mode != INF_SIMULATED_CONNECTION_IO_CONTROLLED);
378   if(priv-&gt;mode != mode)
379   {
380     if(mode == INF_SIMULATED_CONNECTION_IMMEDIATE)
381       inf_simulated_connection_flush(connection);
382     priv-&gt;mode = mode;
383     g_object_notify(G_OBJECT(connection), "mode");
384   }
385 }
386 void
387 inf_simulated_connection_flush(InfSimulatedConnection* connection)
388 {
389   InfSimulatedConnectionPrivate* priv;
390   xmlNodePtr next;
391   priv = INF_SIMULATED_CONNECTION_PRIVATE(connection);
392   g_return_if_fail(priv-&gt;target != NULL);
393   if(priv-&gt;mode == INF_SIMULATED_CONNECTION_IO_CONTROLLED)
394   {
395     g_assert(priv-&gt;io != NULL);
396     if(priv-&gt;io_handler != NULL)
397     {
398       inf_io_remove_dispatch(priv-&gt;io, priv-&gt;io_handler);
399       priv-&gt;io_handler = NULL;
400     }
401   }
402   while(priv-&gt;queue != NULL)
403   {
404     inf_xml_connection_sent(
405       INF_XML_CONNECTION(connection),
406       priv-&gt;queue
407     );
408     inf_xml_connection_received(
409       INF_XML_CONNECTION(priv-&gt;target),
410       priv-&gt;queue
411     );
412     next = priv-&gt;queue-&gt;next;
413     xmlFreeNode(priv-&gt;queue);
414     priv-&gt;queue = next;
415   }
416   priv-&gt;queue_last_item = NULL;
417 }
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>inf-chat-session.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 #include &lt;libinfinity/common/inf-chat-session.h&gt;
2 #include &lt;libinfinity/common/inf-xml-util.h&gt;
3 #include &lt;libinfinity/common/inf-error.h&gt;
4 #include &lt;libinfinity/inf-i18n.h&gt;
5 #include &lt;libinfinity/inf-signals.h&gt;
6 #include &lt;errno.h&gt;
7 #include &lt;string.h&gt;
8 typedef struct _InfChatSessionLogUserlistForeachData
9   InfChatSessionLogUserlistForeachData;
10 struct _InfChatSessionLogUserlistForeachData {
11   FILE* log_file;
12   gchar* time_str;
13   guint users_total;
14 };
15 typedef struct _InfChatSessionPrivate InfChatSessionPrivate;
16 struct _InfChatSessionPrivate {
17   gchar* log_filename;
18   FILE* log_file;
19 };
20 enum {
21   PROP_0,
22   PROP_LOG_FILE
23 };
24 enum {
25   RECEIVE_MESSAGE,
26   SEND_MESSAGE,
27   LAST_SIGNAL
28 };
29 #define INF_CHAT_SESSION_PRIVATE(obj) (G_TYPE_INSTANCE_GET_PRIVATE((obj), INF_TYPE_CHAT_SESSION, InfChatSessionPrivate))
30 static guint chat_session_signals[LAST_SIGNAL];
31 static GQuark inf_chat_session_error_quark;
32 G_DEFINE_TYPE_WITH_CODE(InfChatSession, inf_chat_session, INF_TYPE_SESSION,
33   G_ADD_PRIVATE(InfChatSession))
34 #if 0
35 static const gchar*
36 inf_chat_session_strerror(InfChatSessionError code)
37 {
38   switch(code)
39   {
40   case INF_CHAT_SESSION_ERROR_TYPE_INVALID:
41     return _("An invalid message type was sent");
42   case INF_CHAT_SESSION_ERROR_NO_SUCH_USER:
43     return _("A user with the requested ID does not exist");
44   case INF_CHAT_SESSION_ERROR_FAILED:
45     return _("An unknown chat session error has occurred");
46   default:
47     return _("An error with unknown error code occurred");
48   }
49 }
50 #endif
51 static const gchar*
52 inf_chat_session_message_type_to_string(InfChatBufferMessageType type)
53 {
54   switch(type)
55   {
56   case INF_CHAT_BUFFER_MESSAGE_NORMAL: return "normal";
57   case INF_CHAT_BUFFER_MESSAGE_EMOTE: return "emote";
58   case INF_CHAT_BUFFER_MESSAGE_USERJOIN: return "userjoin";
59   case INF_CHAT_BUFFER_MESSAGE_USERPART: return "userpart";
60   default: g_assert_not_reached(); return NULL;
61   }
62 }
63 static gboolean
64 inf_chat_session_message_type_from_string(const gchar* string,
65                                           InfChatBufferMessageType* type,
66                                           GError** error)
67 {
68   if(strcmp(string, "normal") == 0)
69   {
70     *type = INF_CHAT_BUFFER_MESSAGE_NORMAL;
71     return TRUE;
72   }
73   else if(strcmp(string, "emote") == 0)
74   {
75     *type = INF_CHAT_BUFFER_MESSAGE_EMOTE;
76     return TRUE;
77   }
78   else if(strcmp(string, "userjoin") == 0)
79   {
80     *type = INF_CHAT_BUFFER_MESSAGE_USERJOIN;
81     return TRUE;
82   }
83   else if(strcmp(string, "userpart") == 0)
84   {
85     *type = INF_CHAT_BUFFER_MESSAGE_USERPART;
86     return TRUE;
87   }
88   g_set_error(
89     error,
90     inf_chat_session_error_quark,
91     INF_CHAT_SESSION_ERROR_TYPE_INVALID,
92     "Invalid message type: \"%s\"",
93     string
94   );
95   return FALSE;
96 }
97 static xmlNodePtr
98 inf_chat_session_message_to_xml(InfChatSession* session,
99                                 const InfChatBufferMessage* message,
100                                 gboolean for_sync)
101 {
102   xmlNodePtr xml;
103   xml = xmlNewNode(NULL, (const xmlChar*)"message");
104   if(message-&gt;type != INF_CHAT_BUFFER_MESSAGE_NORMAL)
105   {
106     inf_xml_util_set_attribute(
107       xml,
108       "type",
109       inf_chat_session_message_type_to_string(message-&gt;type)
110     );
111   }
112   if(for_sync)
113     inf_xml_util_set_attribute_long(xml, "time", (long)message-&gt;time);
114   inf_xml_util_set_attribute_uint(
115     xml,
116     "user",
117     inf_user_get_id(message-&gt;user)
118   );
119   if(message-&gt;text != NULL)
120     inf_xml_util_add_child_text(xml, message-&gt;text, message-&gt;length);
121   return xml;
122 }
123 static gboolean
124 inf_chat_session_message_from_xml(InfChatSession* session,
125                                   InfChatBufferMessage* message,
126                                   xmlNodePtr xml,
127                                   gboolean for_sync,
128                                   GError** error)
129 {
130   xmlChar* type;
131   gboolean result;
132   InfChatBufferMessageType message_type;
133   InfChatBufferMessageFlags message_flags;
134   long message_time;
135   guint user_id;
136   InfUserTable* user_table;
137   InfUser* user;
138   message_flags = 0;
139   type = inf_xml_util_get_attribute(xml, "type");
140   if(type == NULL)
141   {
142     message_type = INF_CHAT_BUFFER_MESSAGE_NORMAL;
143   }
144   else
145   {
146     result = inf_chat_session_message_type_from_string(
147       (const char*)type,
148       &amp;message_type,
149       error
150     );
151     xmlFree(type);
152     if(result == FALSE) return FALSE;
153   }
154   if(for_sync)
155   {
156     result = inf_xml_util_get_attribute_long_required(
157       xml,
158       "time",
159       &amp;message_time,
160       error
161     );
162     if(result == FALSE) return FALSE;
163     message_flags = INF_CHAT_BUFFER_MESSAGE_BACKLOG;
164   }
165   else
166   {
167     if(message_type == INF_CHAT_BUFFER_MESSAGE_USERJOIN ||
168        message_type == INF_CHAT_BUFFER_MESSAGE_USERPART)
169     {
170       g_set_error(
171         error,
172         inf_chat_session_error_quark,
173         INF_CHAT_SESSION_ERROR_TYPE_INVALID,
174         "Non-backlog message type cannot be \"%s\"",
175         inf_chat_session_message_type_to_string(message_type)
176       );
177       return FALSE;
178     }
179     message_time = time(NULL);
180   }
181   if(!inf_xml_util_get_attribute_uint_required(xml, "user", &amp;user_id, error))
182     return FALSE;
183   user_table = inf_session_get_user_table(INF_SESSION(session));
184   user = inf_user_table_lookup_user_by_id(user_table, user_id);
185   if(user == NULL)
186   {
187     g_set_error(
188       error,
189       inf_chat_session_error_quark,
190       INF_CHAT_SESSION_ERROR_NO_SUCH_USER,
191       _("No such user with ID \"%u\""),
192       user_id
193     );
194     return FALSE;
195   }
196   if(message_type != INF_CHAT_BUFFER_MESSAGE_USERJOIN &amp;&amp;
197      message_type != INF_CHAT_BUFFER_MESSAGE_USERPART)
198   {
199     message-&gt;text =
200       inf_xml_util_get_child_text(xml, &amp;message-&gt;length, NULL, error);
201     if(!message-&gt;text)
202       return FALSE;
203   }
204   else
205   {
206     message-&gt;text = NULL;
207     message-&gt;length = 0;
208   }
209   message-&gt;type = message_type;
210   message-&gt;user = user;
211   message-&gt;time = message_time;
212   message-&gt;flags = message_flags;
213   return TRUE;
214 }
215 static gchar*
216 inf_chat_session_strdup_strftime(const char* format,
217                                  const struct tm* tm,
218                                  gsize* len)
219 {
220   gsize alloc;
221   gchar* str;
222   size_t result;
223   alloc = 64;
224   str = g_malloc(alloc * sizeof(gchar));
225   result = strftime(str, alloc, format, tm);
226   while(result == 0 &amp;&amp; alloc &lt; 1024)
227   {
228     alloc *= 2;
229     str = g_realloc(str, alloc * sizeof(gchar));
230     result = strftime(str, alloc, format, tm);
231   }
232   if(result == 0)
233   {
234     g_free(str);
235     return NULL;
236   }
237   if(len) *len = result;
238   return str;
239 }
240 static void
241 inf_chat_session_log_message(InfChatSession* session,
242                              const InfChatBufferMessage* message)
243 {
244   InfChatSessionPrivate* priv;
245   struct tm* tm;
246   gchar* time_str;
247   const gchar* name;
248   const gchar* text;
249   priv = INF_CHAT_SESSION_PRIVATE(session);
250   if(priv-&gt;log_file != NULL)
251   {
252     tm = localtime(&amp;message-&gt;time);
253     time_str = inf_chat_session_strdup_strftime("%c", tm, NULL);
254     name = inf_user_get_name(message-&gt;user);
255     text = message-&gt;text;
256     switch(message-&gt;type)
257     {
258     case INF_CHAT_BUFFER_MESSAGE_NORMAL:
259       fprintf(priv-&gt;log_file, "%s &lt;%s&gt; %s\n", time_str, name, message-&gt;text);
260       break;
261     case INF_CHAT_BUFFER_MESSAGE_EMOTE:
262       fprintf(priv-&gt;log_file, "%s * %s %s\n", time_str, name, message-&gt;text);
263       break;
264     case INF_CHAT_BUFFER_MESSAGE_USERJOIN:
265       fprintf(priv-&gt;log_file, _("%s --- %s has joined\n"), time_str, name);
266       break;
267     case INF_CHAT_BUFFER_MESSAGE_USERPART:
268       fprintf(priv-&gt;log_file, _("%s --- %s has left\n"), time_str, name);
269       break;
270     default:
271       g_assert_not_reached();
272       break;
273     }
274     g_free(time_str);
275     fflush(priv-&gt;log_file);
276   }
277 }
278 static void
279 inf_chat_session_log_userlist_foreach_func(InfUser* user,
280                                            gpointer user_data)
281 {
282   InfChatSessionLogUserlistForeachData* data;
283   data = (InfChatSessionLogUserlistForeachData*)user_data;
284   if(inf_user_get_status(user) != INF_USER_UNAVAILABLE)
285   {
286     fprintf(
287       data-&gt;log_file,
288       "%s --- [%s]\n",
289       data-&gt;time_str,
290       inf_user_get_name(user)
291     );
292     ++ data-&gt;users_total;
293   }
294 }
295 static void
296 inf_chat_session_log_userlist(InfChatSession* session)
297 {
298   InfChatSessionPrivate* priv;
299   InfChatSessionLogUserlistForeachData data;
300   time_t cur_time;
301   struct tm* tm;
302   priv = INF_CHAT_SESSION_PRIVATE(session);
303   if(priv-&gt;log_file != NULL)
304   {
305     cur_time = time(NULL);
306     tm = localtime(&amp;cur_time);
307     data.time_str = inf_chat_session_strdup_strftime("%c", tm, NULL);
308     data.log_file = priv-&gt;log_file;
309     data.users_total = 0;
310     inf_user_table_foreach_user(
311       inf_session_get_user_table(INF_SESSION(session)),
312       inf_chat_session_log_userlist_foreach_func,
313       &amp;data
314     );
315     fprintf(
316       data.log_file,
317       _("%s --- %u users total\n"),
318       data.time_str,
319       data.users_total
320     );
321     g_free(data.time_str);
322     fflush(data.log_file);
323   }
324 }
325 static gboolean
326 inf_chat_session_receive_message(InfChatSession* session,
327                                  InfXmlConnection* connection,
328                                  xmlNodePtr xml,
329                                  GError** error)
330 {
331   InfChatSessionPrivate* priv;
332   InfChatBufferMessage message;
333   gboolean sync;
334   priv = INF_CHAT_SESSION_PRIVATE(session);
335   if(inf_session_get_status(INF_SESSION(session)) ==
336      INF_SESSION_SYNCHRONIZING)
337   {
338     sync = TRUE;
339   }
340   else
341   {
342     sync = FALSE;
343   }
344   if(!inf_chat_session_message_from_xml(session, &amp;message, xml, sync, error))
345     return FALSE;
346   if(!sync &amp;&amp;
347      (inf_user_get_status(message.user) == INF_USER_UNAVAILABLE ||
348       inf_user_get_connection(message.user) != connection))
349   {
350     g_set_error_literal(
351       error,
352       inf_user_error_quark(),
353       INF_USER_ERROR_NOT_JOINED,
354       _("User did not join from this connection")
355     );
356     g_free(message.text);
357     return FALSE;
358   }
359   g_signal_emit(
360     session,
361     chat_session_signals[RECEIVE_MESSAGE],
362     0,
363     &amp;message
364   );
365   g_free(message.text);
366   return TRUE;
367 }
368 static void
369 inf_chat_session_user_join(InfChatSession* session,
370                            InfUser* user)
371 {
372   InfChatBufferMessage message;
373   message.type = INF_CHAT_BUFFER_MESSAGE_USERJOIN;
374   message.user = user;
375   message.text = NULL;
376   message.length = 0;
377   message.time = time(NULL);
378   message.flags = 0;
379   g_signal_emit(session, chat_session_signals[RECEIVE_MESSAGE], 0, &amp;message);
380 }
381 static void
382 inf_chat_session_user_part(InfChatSession* session,
383                            InfUser* user)
384 {
385   InfChatBufferMessage message;
386   message.type = INF_CHAT_BUFFER_MESSAGE_USERPART;
387   message.user = user;
388   message.text = NULL;
389   message.length = 0;
390   message.time = time(NULL);
391   message.flags = 0;
392   g_signal_emit(session, chat_session_signals[RECEIVE_MESSAGE], 0, &amp;message);
393 }
394 static void
395 inf_chat_session_set_status_cb(InfUser* user,
396                                InfUserStatus new_status,
397                                gpointer user_data)
398 {
399   InfSession* session;
400   session = INF_SESSION(user_data);
401   if(inf_session_get_status(session) == INF_SESSION_RUNNING)
402   {
403     if(inf_user_get_status(user) != INF_USER_UNAVAILABLE &amp;&amp;
404        new_status == INF_USER_UNAVAILABLE)
405     {
406       inf_chat_session_user_part(INF_CHAT_SESSION(session), user);
407     }
408     else if(inf_user_get_status(user) == INF_USER_UNAVAILABLE &amp;&amp;
409             new_status != INF_USER_UNAVAILABLE)
410     {
411       inf_chat_session_user_join(INF_CHAT_SESSION(session), user);
412     }
413   }
414 }
415 static void
416 inf_chat_session_add_user_cb(InfUserTable* user_table,
417                              InfUser* user,
418                              gpointer user_data)
419 {
420   g_signal_connect(
421     user,
422     "set-status",
423     G_CALLBACK(inf_chat_session_set_status_cb),
424     user_data
425   );
426   if(inf_session_get_status(INF_SESSION(user_data)) == INF_SESSION_RUNNING)
427     if(inf_user_get_status(user) != INF_USER_UNAVAILABLE)
428       inf_chat_session_user_join(INF_CHAT_SESSION(user_data), user);
429 }
430 static void
431 inf_chat_session_remove_user_cb(InfUserTable* user_table,
432                                 InfUser* user,
433                                 gpointer user_data)
434 {
435   if(inf_session_get_status(INF_SESSION(user_data)) == INF_SESSION_RUNNING)
436     if(inf_user_get_status(user) != INF_USER_UNAVAILABLE)
437       inf_chat_session_user_part(INF_CHAT_SESSION(user_data), user);
438   inf_signal_handlers_disconnect_by_func(
439     user,
440     G_CALLBACK(inf_chat_session_set_status_cb),
441     user_data
442   );
443 }
444 static void
445 inf_chat_session_add_message_cb(InfChatBuffer* buffer,
446                                 const InfChatBufferMessage* message,
447                                 gpointer user_data)
448 {
449   if(message-&gt;type != INF_CHAT_BUFFER_MESSAGE_USERJOIN &amp;&amp;
450      message-&gt;type != INF_CHAT_BUFFER_MESSAGE_USERPART)
451   {
452     g_signal_emit(
453       user_data,
454       chat_session_signals[SEND_MESSAGE],
455       0,
456       message
457     );
458   }
459 }
460 static void
461 inf_chat_session_init(InfChatSession* session)
462 {
463   InfChatSessionPrivate* priv;
464   priv = INF_CHAT_SESSION_PRIVATE(session);
465   priv-&gt;log_filename = NULL;
466   priv-&gt;log_file = NULL;
467 }
468 static void
469 inf_chat_session_constructed_foreach_user_func(InfUser* user,
470                                                gpointer user_data)
471 {
472   g_signal_connect(
473     user,
474     "set-status",
475     G_CALLBACK(inf_chat_session_set_status_cb),
476     user_data
477   );
478 }
479 static void
480 inf_chat_session_constructed(GObject* object)
481 {
482   InfUserTable* user_table;
483   InfChatBuffer* buffer;
484   G_OBJECT_CLASS(inf_chat_session_parent_class)-&gt;constructed(object);
485   user_table = inf_session_get_user_table(INF_SESSION(object));
486   g_signal_connect_after(
487     user_table,
488     "add-user",
489     G_CALLBACK(inf_chat_session_add_user_cb),
490     object
491   );
492   g_signal_connect_after(
493     user_table,
494     "remove-user",
495     G_CALLBACK(inf_chat_session_remove_user_cb),
496     object
497   );
498   inf_user_table_foreach_user(
499     INF_USER_TABLE(user_table),
500     inf_chat_session_constructed_foreach_user_func,
501     object
502   );
503   buffer = INF_CHAT_BUFFER(inf_session_get_buffer(INF_SESSION(object)));
504   g_assert(INF_IS_CHAT_BUFFER(buffer));
505   g_signal_connect_after(
506     buffer,
507     "add-message",
508     G_CALLBACK(inf_chat_session_add_message_cb),
509     object
510   );
511 }
512 static void
513 inf_chat_session_dispose_foreach_user_func(InfUser* user,
514                                            gpointer user_data)
515 {
516   inf_signal_handlers_disconnect_by_func(
517     user,
518     G_CALLBACK(inf_chat_session_set_status_cb),
519     user_data
520   );
521 }
522 static void
523 inf_chat_session_dispose(GObject* object)
524 {
525   InfChatSession* session;
526   InfChatBuffer* buffer;
527   InfUserTable* user_table;
528   session = INF_CHAT_SESSION(object);
529   user_table = inf_session_get_user_table(INF_SESSION(session));
530   buffer = INF_CHAT_BUFFER(inf_session_get_buffer(INF_SESSION(session)));
531   inf_user_table_foreach_user(
532     INF_USER_TABLE(user_table),
533     inf_chat_session_dispose_foreach_user_func,
534     session
535   );
536   inf_signal_handlers_disconnect_by_func(
537     user_table,
538     G_CALLBACK(inf_chat_session_add_user_cb),
539     session
540   );
541   inf_signal_handlers_disconnect_by_func(
542     user_table,
543     G_CALLBACK(inf_chat_session_remove_user_cb),
544     session
545   );
546   inf_signal_handlers_disconnect_by_func(
547     buffer,
548     G_CALLBACK(inf_chat_session_add_message_cb),
549     session
550   );
551   G_OBJECT_CLASS(inf_chat_session_parent_class)-&gt;dispose(object);
552 }
553 static void
554 inf_chat_session_finalize(GObject* object)
555 {
556   InfChatSession* session;
557   InfChatSessionPrivate* priv;
558   session = INF_CHAT_SESSION(object);
559   priv = INF_CHAT_SESSION_PRIVATE(session);
560   inf_chat_session_set_log_file(session, NULL, NULL);
561   G_OBJECT_CLASS(inf_chat_session_parent_class)-&gt;finalize(object);
562 }
563 static void
564 inf_chat_session_set_property(GObject* object,
565                               guint prop_id,
566                               const GValue* value,
567                               GParamSpec* pspec)
568 {
569   InfChatSession* session;
570   InfChatSessionPrivate* priv;
571   const gchar* log_file;
572   GError* error;
573   session = INF_CHAT_SESSION(object);
574   priv = INF_CHAT_SESSION_PRIVATE(session);
575   switch(prop_id)
576   {
577   case PROP_LOG_FILE:
578     error = NULL;
579     log_file = g_value_get_string(value);
580     if(!inf_chat_session_set_log_file(session, log_file, &amp;error))
581     {
582       g_warning("Failed to set log file: %s\n", error-&gt;message);
583 <a name="0"></a>      g_error_free(error);
584     }
585 <font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>    break;
586   default:
587     G_OBJECT_WARN_INVALID_PROPERTY_ID(object, prop_id, pspec);
588     break;
589   }
590 }
591 static void
592 inf_chat_session_get_property(GObject* object,
593                               guint prop_id,
594                               GValue* value,
595                               GParamSpec* pspec)
596 {
597   InfChatSession* session;
598   InfChatSessionPrivate* priv;
599   session = INF_CHAT_SESSION(object);
600   priv = INF_CHAT_SESSION_PRIVATE(session);
601   switch(prop_id)
602   {
603   case PROP_LOG_FILE:
604     g_value_set_string(value, priv-&gt;log_filename);
605     break;</b></font>
606   default:
607     G_OBJECT_WARN_INVALID_PROPERTY_ID(object, prop_id, pspec);
608     break;
609   }
610 }
611 static void
612 inf_chat_session_to_xml_sync(InfSession* session,
613                              xmlNodePtr parent)
614 {
615   InfChatBuffer* buffer;
616   InfSessionClass* parent_class;
617   const InfChatBufferMessage* message;
618   xmlNodePtr child;
619   guint i;
620   buffer = INF_CHAT_BUFFER(inf_session_get_buffer(session));
621   parent_class = INF_SESSION_CLASS(inf_chat_session_parent_class);
622   g_assert(parent_class-&gt;to_xml_sync != NULL);
623   parent_class-&gt;to_xml_sync(session, parent);
624   for(i = 0; i &lt; inf_chat_buffer_get_n_messages(buffer); ++i)
625   {
626     message = inf_chat_buffer_get_message(buffer, i);
627     child = inf_chat_session_message_to_xml(
628       INF_CHAT_SESSION(session),
629       message,
630       TRUE
631     );
632     xmlAddChild(parent, child);
633   }
634 }
635 static gboolean
636 inf_chat_session_process_xml_sync(InfSession* session,
637                                   InfXmlConnection* connection,
638                                   xmlNodePtr xml,
639                                   GError** error)
640 {
641   InfSessionClass* parent_class;
642   if(strcmp((const char*)xml-&gt;name, "message") == 0)
643   {
644     return inf_chat_session_receive_message(
645       INF_CHAT_SESSION(session),
646       connection,
647       xml,
648       error
649     );
650   }
651   else
652   {
653     parent_class = INF_SESSION_CLASS(inf_chat_session_parent_class);
654     g_assert(parent_class-&gt;process_xml_sync != NULL);
655     return parent_class-&gt;process_xml_sync(session, connection, xml, error);
656   }
657 }
658 static InfCommunicationScope
659 inf_chat_session_process_xml_run(InfSession* session,
660                                  InfXmlConnection* connection,
661                                  xmlNodePtr xml,
662                                  GError** error)
663 {
664   InfSessionClass* parent_class;
665   gboolean result;
666   if(strcmp((const char*)xml-&gt;name, "message") == 0)
667   {
668     result = inf_chat_session_receive_message(
669       INF_CHAT_SESSION(session),
670       connection,
671       xml,
672       error
673     );
674     if(!result)
675       return INF_COMMUNICATION_SCOPE_PTP;
676     else
677       return INF_COMMUNICATION_SCOPE_GROUP;
678   }
679   else
680   {
681     parent_class = INF_SESSION_CLASS(inf_chat_session_parent_class);
682     g_assert(parent_class-&gt;process_xml_run != NULL);
683     return parent_class-&gt;process_xml_run(session, connection, xml, error);
684   }
685 }
686 static void
687 inf_chat_session_synchronization_complete(InfSession* session,
688                                           InfXmlConnection* connection)
689 {
690   InfSessionClass* parent_class;
691   if(inf_session_get_status(session) == INF_SESSION_SYNCHRONIZING)
692     inf_chat_session_log_userlist(INF_CHAT_SESSION(session));
693   parent_class = INF_SESSION_CLASS(inf_chat_session_parent_class);
694   g_assert(parent_class-&gt;synchronization_complete != NULL);
695   parent_class-&gt;synchronization_complete(session, connection);
696 }
697 static void
698 inf_chat_session_synchronization_failed(InfSession* session,
699                                         InfXmlConnection* connection,
700                                         const GError* error)
701 {
702   InfSessionClass* parent_class;
703   InfChatSessionPrivate* priv;
704   time_t cur_time;
705   struct tm* tm;
706   gchar* time_str;
707   if(inf_session_get_status(session) == INF_SESSION_SYNCHRONIZING)
708   {
709     priv = INF_CHAT_SESSION_PRIVATE(session);
710     if(priv-&gt;log_file != NULL)
711     {
712       cur_time = time(NULL);
713       tm = localtime(&amp;cur_time);
714       time_str = inf_chat_session_strdup_strftime("%c", tm, NULL);
715       fprintf(
716         priv-&gt;log_file,
717         "%s --- Synchronization failed: %s\n",
718         time_str,
719         error-&gt;message
720       );
721       g_free(time_str);
722     }
723   }
724   parent_class = INF_SESSION_CLASS(inf_chat_session_parent_class);
725   g_assert(parent_class-&gt;synchronization_failed != NULL);
726   parent_class-&gt;synchronization_failed(session, connection, error);
727 }
728 static InfUser*
729 inf_chat_session_user_new(InfSession* session,
730                           GParameter* params,
731                           guint n_params)
732 {
733   return g_object_newv(INF_TYPE_USER, n_params, params);
734 }
735 static void
736 inf_chat_session_receive_message_handler(InfChatSession* session,
737                                          const InfChatBufferMessage* message)
738 {
739   InfChatBuffer* buffer;
740   buffer = INF_CHAT_BUFFER(inf_session_get_buffer(INF_SESSION(session)));
741   inf_signal_handlers_block_by_func(
742     buffer,
743     G_CALLBACK(inf_chat_session_add_message_cb),
744     session
745   );
746   switch(message-&gt;type)
747   {
748   case INF_CHAT_BUFFER_MESSAGE_NORMAL:
749     inf_chat_buffer_add_message(
750       buffer,
751       message-&gt;user,
752       message-&gt;text,
753       message-&gt;length,
754       message-&gt;time,
755       message-&gt;flags
756     );
757     break;
758   case INF_CHAT_BUFFER_MESSAGE_EMOTE:
759     inf_chat_buffer_add_emote_message(
760       buffer,
761       message-&gt;user,
762       message-&gt;text,
763       message-&gt;length,
764       message-&gt;time,
765       message-&gt;flags
766     );
767     break;
768   case INF_CHAT_BUFFER_MESSAGE_USERJOIN:
769     inf_chat_buffer_add_userjoin_message(
770       buffer,
771       message-&gt;user,
772       message-&gt;time,
773       message-&gt;flags
774     );
775     break;
776   case INF_CHAT_BUFFER_MESSAGE_USERPART:
777     inf_chat_buffer_add_userpart_message(
778       buffer,
779       message-&gt;user,
780       message-&gt;time,
781       message-&gt;flags
782     );
783     break;
784   default:
785     g_assert_not_reached();
786     break;
787   }
788   inf_signal_handlers_unblock_by_func(
789     buffer,
790     G_CALLBACK(inf_chat_session_add_message_cb),
791     session
792   );
793   if(inf_session_get_status(INF_SESSION(session)) == INF_SESSION_RUNNING)
794     inf_chat_session_log_message(session, message);
795 }
796 static void
797 inf_chat_session_send_message_handler(InfChatSession* session,
798                                       const InfChatBufferMessage* message)
799 {
800   xmlNodePtr xml;
801   xml = inf_chat_session_message_to_xml(session, message, FALSE);
802   inf_session_send_to_subscriptions(INF_SESSION(session), xml);
803   inf_chat_session_log_message(session, message);
804 }
805 static void
806 inf_chat_session_class_init(InfChatSessionClass* chat_session_class)
807 {
808   GObjectClass* object_class;
809   InfSessionClass* session_class;
810   object_class = G_OBJECT_CLASS(chat_session_class);
811   session_class = INF_SESSION_CLASS(chat_session_class);
812   object_class-&gt;constructed = inf_chat_session_constructed;
813   object_class-&gt;dispose = inf_chat_session_dispose;
814   object_class-&gt;finalize = inf_chat_session_finalize;
815   object_class-&gt;set_property = inf_chat_session_set_property;
816   object_class-&gt;get_property = inf_chat_session_get_property;
817   session_class-&gt;to_xml_sync = inf_chat_session_to_xml_sync;
818   session_class-&gt;process_xml_sync = inf_chat_session_process_xml_sync;
819   session_class-&gt;process_xml_run = inf_chat_session_process_xml_run;
820   session_class-&gt;synchronization_complete =
821     inf_chat_session_synchronization_complete;
822   session_class-&gt;synchronization_failed =
823     inf_chat_session_synchronization_failed;
824   session_class-&gt;user_new = inf_chat_session_user_new;
825   chat_session_class-&gt;receive_message =
826     inf_chat_session_receive_message_handler;
827   chat_session_class-&gt;send_message =
828     inf_chat_session_send_message_handler;
829   inf_chat_session_error_quark =
830     g_quark_from_static_string("INF_CHAT_SESSION_ERROR");
831   g_object_class_install_property(
832     object_class,
833     PROP_LOG_FILE,
834     g_param_spec_string(
835       "log-file",
836       "Log file",
837       "The file into which to store all received messages",
838       NULL,
839       G_PARAM_READWRITE
840     )
841   );
842   chat_session_signals[RECEIVE_MESSAGE] = g_signal_new(
843     "receive-message",
844     G_OBJECT_CLASS_TYPE(object_class),
845     G_SIGNAL_RUN_LAST,
846     G_STRUCT_OFFSET(InfChatSessionClass, receive_message),
847     NULL, NULL,
848     g_cclosure_marshal_VOID__BOXED,
849     G_TYPE_NONE,
850     1,
851     INF_TYPE_CHAT_BUFFER_MESSAGE | G_SIGNAL_TYPE_STATIC_SCOPE
852   );
853   chat_session_signals[SEND_MESSAGE] = g_signal_new(
854     "send-message",
855     G_OBJECT_CLASS_TYPE(object_class),
856     G_SIGNAL_RUN_LAST,
857     G_STRUCT_OFFSET(InfChatSessionClass, send_message),
858     NULL, NULL,
859     g_cclosure_marshal_VOID__BOXED,
860     G_TYPE_NONE,
861     1,
862     INF_TYPE_CHAT_BUFFER_MESSAGE | G_SIGNAL_TYPE_STATIC_SCOPE
863   );
864 }
865 InfChatSession*
866 inf_chat_session_new(InfCommunicationManager* manager,
867                      InfChatBuffer* buffer,
868                      InfSessionStatus status,
869                      InfCommunicationGroup* sync_group,
870                      InfXmlConnection* sync_connection)
871 {
872   InfChatSession* session;
873   g_return_val_if_fail(INF_COMMUNICATION_IS_MANAGER(manager), NULL);
874   g_return_val_if_fail(INF_IS_CHAT_BUFFER(buffer), NULL);
875   g_return_val_if_fail(
876     (status == INF_SESSION_RUNNING &amp;&amp;
877      sync_group == NULL &amp;&amp; sync_connection == NULL) ||
878     (status != INF_SESSION_RUNNING &amp;&amp;
879      INF_COMMUNICATION_IS_GROUP(sync_group) &amp;&amp;
880      INF_IS_XML_CONNECTION(sync_connection)),
881     NULL
882   );
883   session = INF_CHAT_SESSION(
884     g_object_new(
885       INF_TYPE_CHAT_SESSION,
886       "communication-manager", manager,
887       "buffer", buffer,
888       "status", status,
889       "sync-group", sync_group,
890       "sync-connection", sync_connection,
891       NULL
892     )
893   );
894   return session;
895 }
896 gboolean
897 inf_chat_session_set_log_file(InfChatSession* session,
898                               const gchar* log_file,
899                               GError** error)
900 {
901   InfChatSessionPrivate* priv;
902   FILE* new_file;
903   int save_errno;
904   long offset;
905   time_t cur_time;
906   struct tm* tm;
907   gchar* time_str;
908   guint len;
909   g_return_val_if_fail(INF_IS_CHAT_SESSION(session), FALSE);
910   priv = INF_CHAT_SESSION_PRIVATE(session);
911   if(log_file != NULL)
912   {
913     new_file = fopen(log_file, "a");
914     if(new_file == NULL)
915     {
916       save_errno = errno;
917     }
918     else
919     {
920       offset = ftell(new_file);
921       if(offset == -1)
922       {
923         save_errno = errno;
924         fclose(new_file);
925         new_file = NULL;
926       }
927     }
928     if(new_file == NULL)
929     {
930       g_set_error_literal(
931         error,
932         G_FILE_ERROR,
933         g_file_error_from_errno(save_errno),
934         strerror(save_errno)
935       );
936       return FALSE;
937     }
938   }
939   cur_time = time(NULL);
940   tm = localtime(&amp;cur_time);
941   time_str = inf_chat_session_strdup_strftime("%c", tm, NULL);
942   if(priv-&gt;log_file != NULL)
943   {
944     fprintf(priv-&gt;log_file, _("%s --- Log closed\n"), time_str);
945     fclose(priv-&gt;log_file);
946   }
947   if(log_file != NULL)
948   {
949     len = strlen(log_file);
950     priv-&gt;log_filename =
951       g_realloc(priv-&gt;log_filename, (len + 1) * sizeof(gchar));
952     memcpy(priv-&gt;log_filename, log_file, len);
953     priv-&gt;log_filename[len] = '\0';
954     priv-&gt;log_file = new_file;
955     if(offset &gt; 0) fprintf(priv-&gt;log_file, "\n");
956     fprintf(priv-&gt;log_file, _("%s --- Log opened\n"), time_str);
957     if(inf_session_get_status(INF_SESSION(session)) == INF_SESSION_RUNNING)
958       inf_chat_session_log_userlist(session);
959     else
960       fflush(priv-&gt;log_file);
961   }
962   else
963   {
964     g_free(priv-&gt;log_filename);
965     priv-&gt;log_filename = NULL;
966     priv-&gt;log_file = NULL;
967   }
968   g_free(time_str);
969   return TRUE;
970 }
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
