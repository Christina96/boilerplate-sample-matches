
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 31, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>PINRemoteImage-MDEwOlJlcG9zaXRvcnkzOTUzNzEwMw==-flat-cpu.c</h3>
            <pre><code>1  #include "src/dsp/dsp.h"
2  #if defined(WEBP_HAVE_NEON_RTCD)
3  #include <stdio.h>
4  #include <string.h>
5  #endif
6  #if defined(WEBP_ANDROID_NEON)
7  #include <cpu-features.h>
8  #endif
9  #if (defined(__pic__) || defined(__PIC__)) && defined(__i386__)
10  static WEBP_INLINE void GetCPUInfo(int cpu_info[4], int info_type) {
11    __asm__ volatile (
12      "mov %%ebx, %%edi\n"
13      "cpuid\n"
14      "xchg %%edi, %%ebx\n"
15      : "=a"(cpu_info[0]), "=D"(cpu_info[1]), "=c"(cpu_info[2]), "=d"(cpu_info[3])
16      : "a"(info_type), "c"(0));
17  }
18  #elif defined(__x86_64__) && \
19        (defined(__code_model_medium__) || defined(__code_model_large__)) && \
20        defined(__PIC__)
21  static WEBP_INLINE void GetCPUInfo(int cpu_info[4], int info_type) {
22    __asm__ volatile (
23      "xchg{q}\t{%%rbx}, %q1\n"
24      "cpuid\n"
25      "xchg{q}\t{%%rbx}, %q1\n"
26      : "=a"(cpu_info[0]), "=&r"(cpu_info[1]), "=c"(cpu_info[2]),
27        "=d"(cpu_info[3])
28      : "a"(info_type), "c"(0));
29  }
30  #elif defined(__i386__) || defined(__x86_64__)
31  static WEBP_INLINE void GetCPUInfo(int cpu_info[4], int info_type) {
32    __asm__ volatile (
33      "cpuid\n"
34      : "=a"(cpu_info[0]), "=b"(cpu_info[1]), "=c"(cpu_info[2]), "=d"(cpu_info[3])
35      : "a"(info_type), "c"(0));
36  }
37  #elif (defined(_M_X64) || defined(_M_IX86)) && \
38        defined(_MSC_FULL_VER) && _MSC_FULL_VER >= 150030729  
39  #include <intrin.h>
40  #define GetCPUInfo(info, type) __cpuidex(info, type, 0)  
41  #elif defined(WEBP_MSC_SSE2)
42  #define GetCPUInfo __cpuid
43  #endif
44  #if !defined(__native_client__) && (defined(__i386__) || defined(__x86_64__))
45  static WEBP_INLINE uint64_t xgetbv(void) {
46    const uint32_t ecx = 0;
47    uint32_t eax, edx;
48    __asm__ volatile (
49      ".byte 0x0f, 0x01, 0xd0\n"
50      : "=a"(eax), "=d"(edx) : "c" (ecx));
51    return ((uint64_t)edx << 32) | eax;
52  }
53  #elif (defined(_M_X64) || defined(_M_IX86)) && \
54        defined(_MSC_FULL_VER) && _MSC_FULL_VER >= 160040219  
55  #include <immintrin.h>
56  #define xgetbv() _xgetbv(0)
57  #elif defined(_MSC_VER) && defined(_M_IX86)
58  static WEBP_INLINE uint64_t xgetbv(void) {
59    uint32_t eax_, edx_;
60    __asm {
61      xor ecx, ecx  
62      __asm _emit 0x0f __asm _emit 0x01 __asm _emit 0xd0
63      mov eax_, eax
64      mov edx_, edx
65    }
66    return ((uint64_t)edx_ << 32) | eax_;
67  }
68  #else
69  #define xgetbv() 0U  
70  #endif
71  #if defined(__i386__) || defined(__x86_64__) || defined(WEBP_MSC_SSE2)
72  static int CheckSlowModel(int info) {
73    static const uint8_t kSlowModels[] = {
74      0x37, 0x4a, 0x4d,  
75      0x1c, 0x26, 0x27   
76    };
77    const uint32_t model = ((info & 0xf0000) >> 12) | ((info >> 4) & 0xf);
78    const uint32_t family = (info >> 8) & 0xf;
79    if (family == 0x06) {
80      size_t i;
81      for (i = 0; i < sizeof(kSlowModels) / sizeof(kSlowModels[0]); ++i) {
82        if (model == kSlowModels[i]) return 1;
83      }
84    }
85    return 0;
86  }
87  static int x86CPUInfo(CPUFeature feature) {
88    int max_cpuid_value;
89    int cpu_info[4];
90    int is_intel = 0;
91    GetCPUInfo(cpu_info, 0);
92    max_cpuid_value = cpu_info[0];
93    if (max_cpuid_value < 1) {
94      return 0;
95    } else {
96      const int VENDOR_ID_INTEL_EBX = 0x756e6547;  
97      const int VENDOR_ID_INTEL_EDX = 0x49656e69;  
98      const int VENDOR_ID_INTEL_ECX = 0x6c65746e;  
99      is_intel = (cpu_info[1] == VENDOR_ID_INTEL_EBX &&
100                  cpu_info[2] == VENDOR_ID_INTEL_ECX &&
101                  cpu_info[3] == VENDOR_ID_INTEL_EDX);    
102    }
103    GetCPUInfo(cpu_info, 1);
104    if (feature == kSSE2) {
105      return !!(cpu_info[3] & (1 << 26));
106    }
<span onclick='openModal()' class='match'>107    if (feature == kSSE3) {
108      return !!(cpu_info[2] & (1 << 0));
109    }
110    if (feature == kSlowSSSE3) {
111      if (is_intel && (cpu_info[2] & (1 << 9))) {   
</span>112        return CheckSlowModel(cpu_info[0]);
113      }
114      return 0;
115    }
116    if (feature == kSSE4_1) {
117      return !!(cpu_info[2] & (1 << 19));
118    }
119    if (feature == kAVX) {
120      if ((cpu_info[2] & 0x18000000) == 0x18000000) {
121        return (xgetbv() & 0x6) == 0x6;
122      }
123    }
124    if (feature == kAVX2) {
125      if (x86CPUInfo(kAVX) && max_cpuid_value >= 7) {
126        GetCPUInfo(cpu_info, 7);
127        return !!(cpu_info[1] & (1 << 5));
128      }
129    }
130    return 0;
131  }
132  VP8CPUInfo VP8GetCPUInfo = x86CPUInfo;
133  #elif defined(WEBP_ANDROID_NEON)  
134  static int AndroidCPUInfo(CPUFeature feature) {
135    const AndroidCpuFamily cpu_family = android_getCpuFamily();
136    const uint64_t cpu_features = android_getCpuFeatures();
137    if (feature == kNEON) {
138      return cpu_family == ANDROID_CPU_FAMILY_ARM &&
139             (cpu_features & ANDROID_CPU_ARM_FEATURE_NEON) != 0;
140    }
141    return 0;
142  }
143  VP8CPUInfo VP8GetCPUInfo = AndroidCPUInfo;
144  #elif defined(WEBP_USE_NEON)
145  static int armCPUInfo(CPUFeature feature) {
146    if (feature != kNEON) return 0;
147  #if defined(__linux__) && defined(WEBP_HAVE_NEON_RTCD)
148    {
149      int has_neon = 0;
150      char line[200];
151      FILE* const cpuinfo = fopen("/proc/cpuinfo", "r");
152      if (cpuinfo == NULL) return 0;
153      while (fgets(line, sizeof(line), cpuinfo)) {
154        if (!strncmp(line, "Features", 8)) {
155          if (strstr(line, " neon ") != NULL) {
156            has_neon = 1;
157            break;
158          }
159        }
160      }
161      fclose(cpuinfo);
162      return has_neon;
163    }
164  #else
165    return 1;
166  #endif
167  }
168  VP8CPUInfo VP8GetCPUInfo = armCPUInfo;
169  #elif defined(WEBP_USE_MIPS32) || defined(WEBP_USE_MIPS_DSP_R2) || \
170        defined(WEBP_USE_MSA)
171  static int mipsCPUInfo(CPUFeature feature) {
172    if ((feature == kMIPS32) || (feature == kMIPSdspR2) || (feature == kMSA)) {
173      return 1;
174    } else {
175      return 0;
176    }
177  }
178  VP8CPUInfo VP8GetCPUInfo = mipsCPUInfo;
179  #else
180  VP8CPUInfo VP8GetCPUInfo = NULL;
181  #endif
</code></pre>
        </div>
        <div class="column">
            <h3>PINRemoteImage-MDEwOlJlcG9zaXRvcnkzOTUzNzEwMw==-flat-cpu.c</h3>
            <pre><code>1  #include "src/dsp/dsp.h"
2  #if defined(WEBP_HAVE_NEON_RTCD)
3  #include <stdio.h>
4  #include <string.h>
5  #endif
6  #if defined(WEBP_ANDROID_NEON)
7  #include <cpu-features.h>
8  #endif
9  #if (defined(__pic__) || defined(__PIC__)) && defined(__i386__)
10  static WEBP_INLINE void GetCPUInfo(int cpu_info[4], int info_type) {
11    __asm__ volatile (
12      "mov %%ebx, %%edi\n"
13      "cpuid\n"
14      "xchg %%edi, %%ebx\n"
15      : "=a"(cpu_info[0]), "=D"(cpu_info[1]), "=c"(cpu_info[2]), "=d"(cpu_info[3])
16      : "a"(info_type), "c"(0));
17  }
18  #elif defined(__x86_64__) && \
19        (defined(__code_model_medium__) || defined(__code_model_large__)) && \
20        defined(__PIC__)
21  static WEBP_INLINE void GetCPUInfo(int cpu_info[4], int info_type) {
22    __asm__ volatile (
23      "xchg{q}\t{%%rbx}, %q1\n"
24      "cpuid\n"
25      "xchg{q}\t{%%rbx}, %q1\n"
26      : "=a"(cpu_info[0]), "=&r"(cpu_info[1]), "=c"(cpu_info[2]),
27        "=d"(cpu_info[3])
28      : "a"(info_type), "c"(0));
29  }
30  #elif defined(__i386__) || defined(__x86_64__)
31  static WEBP_INLINE void GetCPUInfo(int cpu_info[4], int info_type) {
32    __asm__ volatile (
33      "cpuid\n"
34      : "=a"(cpu_info[0]), "=b"(cpu_info[1]), "=c"(cpu_info[2]), "=d"(cpu_info[3])
35      : "a"(info_type), "c"(0));
36  }
37  #elif (defined(_M_X64) || defined(_M_IX86)) && \
38        defined(_MSC_FULL_VER) && _MSC_FULL_VER >= 150030729  
39  #include <intrin.h>
40  #define GetCPUInfo(info, type) __cpuidex(info, type, 0)  
41  #elif defined(WEBP_MSC_SSE2)
42  #define GetCPUInfo __cpuid
43  #endif
44  #if !defined(__native_client__) && (defined(__i386__) || defined(__x86_64__))
45  static WEBP_INLINE uint64_t xgetbv(void) {
46    const uint32_t ecx = 0;
47    uint32_t eax, edx;
48    __asm__ volatile (
49      ".byte 0x0f, 0x01, 0xd0\n"
50      : "=a"(eax), "=d"(edx) : "c" (ecx));
51    return ((uint64_t)edx << 32) | eax;
52  }
53  #elif (defined(_M_X64) || defined(_M_IX86)) && \
54        defined(_MSC_FULL_VER) && _MSC_FULL_VER >= 160040219  
55  #include <immintrin.h>
56  #define xgetbv() _xgetbv(0)
57  #elif defined(_MSC_VER) && defined(_M_IX86)
58  static WEBP_INLINE uint64_t xgetbv(void) {
59    uint32_t eax_, edx_;
60    __asm {
61      xor ecx, ecx  
62      __asm _emit 0x0f __asm _emit 0x01 __asm _emit 0xd0
63      mov eax_, eax
64      mov edx_, edx
65    }
66    return ((uint64_t)edx_ << 32) | eax_;
67  }
68  #else
69  #define xgetbv() 0U  
70  #endif
71  #if defined(__i386__) || defined(__x86_64__) || defined(WEBP_MSC_SSE2)
72  static int CheckSlowModel(int info) {
73    static const uint8_t kSlowModels[] = {
74      0x37, 0x4a, 0x4d,  
75      0x1c, 0x26, 0x27   
76    };
77    const uint32_t model = ((info & 0xf0000) >> 12) | ((info >> 4) & 0xf);
78    const uint32_t family = (info >> 8) & 0xf;
79    if (family == 0x06) {
80      size_t i;
81      for (i = 0; i < sizeof(kSlowModels) / sizeof(kSlowModels[0]); ++i) {
82        if (model == kSlowModels[i]) return 1;
83      }
84    }
85    return 0;
86  }
87  static int x86CPUInfo(CPUFeature feature) {
88    int max_cpuid_value;
89    int cpu_info[4];
90    int is_intel = 0;
91    GetCPUInfo(cpu_info, 0);
92    max_cpuid_value = cpu_info[0];
93    if (max_cpuid_value < 1) {
94      return 0;
95    } else {
96      const int VENDOR_ID_INTEL_EBX = 0x756e6547;  
97      const int VENDOR_ID_INTEL_EDX = 0x49656e69;  
98      const int VENDOR_ID_INTEL_ECX = 0x6c65746e;  
99      is_intel = (cpu_info[1] == VENDOR_ID_INTEL_EBX &&
100                  cpu_info[2] == VENDOR_ID_INTEL_ECX &&
101                  cpu_info[3] == VENDOR_ID_INTEL_EDX);    
102    }
103    GetCPUInfo(cpu_info, 1);
104    if (feature == kSSE2) {
105      return !!(cpu_info[3] & (1 << 26));
106    }
107    if (feature == kSSE3) {
108      return !!(cpu_info[2] & (1 << 0));
109    }
110    if (feature == kSlowSSSE3) {
111      if (is_intel && (cpu_info[2] & (1 << 9))) {   
112        return CheckSlowModel(cpu_info[0]);
113      }
114      return 0;
115    }
<span onclick='openModal()' class='match'>116    if (feature == kSSE4_1) {
117      return !!(cpu_info[2] & (1 << 19));
118    }
119    if (feature == kAVX) {
120      if ((cpu_info[2] & 0x18000000) == 0x18000000) {
</span>121        return (xgetbv() & 0x6) == 0x6;
122      }
123    }
124    if (feature == kAVX2) {
125      if (x86CPUInfo(kAVX) && max_cpuid_value >= 7) {
126        GetCPUInfo(cpu_info, 7);
127        return !!(cpu_info[1] & (1 << 5));
128      }
129    }
130    return 0;
131  }
132  VP8CPUInfo VP8GetCPUInfo = x86CPUInfo;
133  #elif defined(WEBP_ANDROID_NEON)  
134  static int AndroidCPUInfo(CPUFeature feature) {
135    const AndroidCpuFamily cpu_family = android_getCpuFamily();
136    const uint64_t cpu_features = android_getCpuFeatures();
137    if (feature == kNEON) {
138      return cpu_family == ANDROID_CPU_FAMILY_ARM &&
139             (cpu_features & ANDROID_CPU_ARM_FEATURE_NEON) != 0;
140    }
141    return 0;
142  }
143  VP8CPUInfo VP8GetCPUInfo = AndroidCPUInfo;
144  #elif defined(WEBP_USE_NEON)
145  static int armCPUInfo(CPUFeature feature) {
146    if (feature != kNEON) return 0;
147  #if defined(__linux__) && defined(WEBP_HAVE_NEON_RTCD)
148    {
149      int has_neon = 0;
150      char line[200];
151      FILE* const cpuinfo = fopen("/proc/cpuinfo", "r");
152      if (cpuinfo == NULL) return 0;
153      while (fgets(line, sizeof(line), cpuinfo)) {
154        if (!strncmp(line, "Features", 8)) {
155          if (strstr(line, " neon ") != NULL) {
156            has_neon = 1;
157            break;
158          }
159        }
160      }
161      fclose(cpuinfo);
162      return has_neon;
163    }
164  #else
165    return 1;
166  #endif
167  }
168  VP8CPUInfo VP8GetCPUInfo = armCPUInfo;
169  #elif defined(WEBP_USE_MIPS32) || defined(WEBP_USE_MIPS_DSP_R2) || \
170        defined(WEBP_USE_MSA)
171  static int mipsCPUInfo(CPUFeature feature) {
172    if ((feature == kMIPS32) || (feature == kMIPSdspR2) || (feature == kMSA)) {
173      return 1;
174    } else {
175      return 0;
176    }
177  }
178  VP8CPUInfo VP8GetCPUInfo = mipsCPUInfo;
179  #else
180  VP8CPUInfo VP8GetCPUInfo = NULL;
181  #endif
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from PINRemoteImage-MDEwOlJlcG9zaXRvcnkzOTUzNzEwMw==-flat-cpu.c</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from PINRemoteImage-MDEwOlJlcG9zaXRvcnkzOTUzNzEwMw==-flat-cpu.c</div>
                </div>
                <div class="column column_space"><pre><code>107    if (feature == kSSE3) {
108      return !!(cpu_info[2] & (1 << 0));
109    }
110    if (feature == kSlowSSSE3) {
111      if (is_intel && (cpu_info[2] & (1 << 9))) {   
</pre></code></div>
                <div class="column column_space"><pre><code>116    if (feature == kSSE4_1) {
117      return !!(cpu_info[2] & (1 << 19));
118    }
119    if (feature == kAVX) {
120      if ((cpu_info[2] & 0x18000000) == 0x18000000) {
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    