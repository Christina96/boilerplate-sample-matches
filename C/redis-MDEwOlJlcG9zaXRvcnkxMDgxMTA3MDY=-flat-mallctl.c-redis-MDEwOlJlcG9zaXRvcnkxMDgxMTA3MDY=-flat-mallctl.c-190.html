
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 17, <button onclick='openModal()' class='match'>CODE CLONE</button></h2>
        <div class="column">
            <h3>redis-MDEwOlJlcG9zaXRvcnkxMDgxMTA3MDY=-flat-mallctl.c</h3>
            <pre><code>1  #include &quot;test/jemalloc_test.h&quot;
2  #include &quot;jemalloc/internal/hook.h&quot;
3  #include &quot;jemalloc/internal/util.h&quot;
4  TEST_BEGIN(test_mallctl_errors) {
5  	uint64_t epoch;
6  	size_t sz;
7  	assert_d_eq(mallctl(&quot;no_such_name&quot;, NULL, NULL, NULL, 0), ENOENT,
8  	    &quot;mallctl() should return ENOENT for non-existent names&quot;);
9  	assert_d_eq(mallctl(&quot;version&quot;, NULL, NULL, &quot;0.0.0&quot;, strlen(&quot;0.0.0&quot;)),
10  	    EPERM, &quot;mallctl() should return EPERM on attempt to write &quot;
11  	    &quot;read-only value&quot;);
12  	assert_d_eq(mallctl(&quot;epoch&quot;, NULL, NULL, (void *)&amp;epoch,
13  	    sizeof(epoch)-1), EINVAL,
14  	    &quot;mallctl() should return EINVAL for input size mismatch&quot;);
15  	assert_d_eq(mallctl(&quot;epoch&quot;, NULL, NULL, (void *)&amp;epoch,
16  	    sizeof(epoch)+1), EINVAL,
17  	    &quot;mallctl() should return EINVAL for input size mismatch&quot;);
18  	sz = sizeof(epoch)-1;
19  	assert_d_eq(mallctl(&quot;epoch&quot;, (void *)&amp;epoch, &amp;sz, NULL, 0), EINVAL,
20  	    &quot;mallctl() should return EINVAL for output size mismatch&quot;);
21  	sz = sizeof(epoch)+1;
22  	assert_d_eq(mallctl(&quot;epoch&quot;, (void *)&amp;epoch, &amp;sz, NULL, 0), EINVAL,
23  	    &quot;mallctl() should return EINVAL for output size mismatch&quot;);
24  }
25  TEST_END
26  TEST_BEGIN(test_mallctlnametomib_errors) {
27  	size_t mib[1];
28  	size_t miblen;
29  	miblen = sizeof(mib)/sizeof(size_t);
30  	assert_d_eq(mallctlnametomib(&quot;no_such_name&quot;, mib, &amp;miblen), ENOENT,
31  	    &quot;mallctlnametomib() should return ENOENT for non-existent names&quot;);
32  }
33  TEST_END
34  TEST_BEGIN(test_mallctlbymib_errors) {
35  	uint64_t epoch;
36  	size_t sz;
37  	size_t mib[1];
38  	size_t miblen;
39  	miblen = sizeof(mib)/sizeof(size_t);
40  	assert_d_eq(mallctlnametomib(&quot;version&quot;, mib, &amp;miblen), 0,
41  	    &quot;Unexpected mallctlnametomib() failure&quot;);
42  	assert_d_eq(mallctlbymib(mib, miblen, NULL, NULL, &quot;0.0.0&quot;,
43  	    strlen(&quot;0.0.0&quot;)), EPERM, &quot;mallctl() should return EPERM on &quot;
44  	    &quot;attempt to write read-only value&quot;);
45  	miblen = sizeof(mib)/sizeof(size_t);
46  	assert_d_eq(mallctlnametomib(&quot;epoch&quot;, mib, &amp;miblen), 0,
47  	    &quot;Unexpected mallctlnametomib() failure&quot;);
48  	assert_d_eq(mallctlbymib(mib, miblen, NULL, NULL, (void *)&amp;epoch,
49  	    sizeof(epoch)-1), EINVAL,
50  	    &quot;mallctlbymib() should return EINVAL for input size mismatch&quot;);
51  	assert_d_eq(mallctlbymib(mib, miblen, NULL, NULL, (void *)&amp;epoch,
52  	    sizeof(epoch)+1), EINVAL,
53  	    &quot;mallctlbymib() should return EINVAL for input size mismatch&quot;);
54  	sz = sizeof(epoch)-1;
55  	assert_d_eq(mallctlbymib(mib, miblen, (void *)&amp;epoch, &amp;sz, NULL, 0),
56  	    EINVAL,
57  	    &quot;mallctlbymib() should return EINVAL for output size mismatch&quot;);
58  	sz = sizeof(epoch)+1;
59  	assert_d_eq(mallctlbymib(mib, miblen, (void *)&amp;epoch, &amp;sz, NULL, 0),
60  	    EINVAL,
61  	    &quot;mallctlbymib() should return EINVAL for output size mismatch&quot;);
62  }
63  TEST_END
64  TEST_BEGIN(test_mallctl_read_write) {
65  	uint64_t old_epoch, new_epoch;
66  	size_t sz = sizeof(old_epoch);
67  	assert_d_eq(mallctl(&quot;epoch&quot;, NULL, NULL, NULL, 0), 0,
68  	    &quot;Unexpected mallctl() failure&quot;);
69  	assert_zu_eq(sz, sizeof(old_epoch), &quot;Unexpected output size&quot;);
70  	assert_d_eq(mallctl(&quot;epoch&quot;, (void *)&amp;old_epoch, &amp;sz, NULL, 0), 0,
71  	    &quot;Unexpected mallctl() failure&quot;);
72  	assert_zu_eq(sz, sizeof(old_epoch), &quot;Unexpected output size&quot;);
73  	assert_d_eq(mallctl(&quot;epoch&quot;, NULL, NULL, (void *)&amp;new_epoch,
74  	    sizeof(new_epoch)), 0, &quot;Unexpected mallctl() failure&quot;);
75  	assert_zu_eq(sz, sizeof(old_epoch), &quot;Unexpected output size&quot;);
76  	assert_d_eq(mallctl(&quot;epoch&quot;, (void *)&amp;old_epoch, &amp;sz,
77  	    (void *)&amp;new_epoch, sizeof(new_epoch)), 0,
78  	    &quot;Unexpected mallctl() failure&quot;);
79  	assert_zu_eq(sz, sizeof(old_epoch), &quot;Unexpected output size&quot;);
80  }
81  TEST_END
82  TEST_BEGIN(test_mallctlnametomib_short_mib) {
83  	size_t mib[4];
84  	size_t miblen;
85  	miblen = 3;
86  	mib[3] = 42;
87  	assert_d_eq(mallctlnametomib(&quot;arenas.bin.0.nregs&quot;, mib, &amp;miblen), 0,
88  	    &quot;Unexpected mallctlnametomib() failure&quot;);
89  	assert_zu_eq(miblen, 3, &quot;Unexpected mib output length&quot;);
90  	assert_zu_eq(mib[3], 42,
91  	    &quot;mallctlnametomib() wrote past the end of the input mib&quot;);
92  }
93  TEST_END
94  TEST_BEGIN(test_mallctl_config) {
95  #define TEST_MALLCTL_CONFIG(config, t) do {				\
96  	t oldval;							\
97  	size_t sz = sizeof(oldval);					\
98  	assert_d_eq(mallctl(&quot;config.&quot;#config, (void *)&amp;oldval, &amp;sz,	\
99  	    NULL, 0), 0, &quot;Unexpected mallctl() failure&quot;);		\
100  	assert_b_eq(oldval, config_##config, &quot;Incorrect config value&quot;);	\
101  	assert_zu_eq(sz, sizeof(oldval), &quot;Unexpected output size&quot;);	\
102  } while (0)
103  	TEST_MALLCTL_CONFIG(cache_oblivious, bool);
104  	TEST_MALLCTL_CONFIG(debug, bool);
105  	TEST_MALLCTL_CONFIG(fill, bool);
106  	TEST_MALLCTL_CONFIG(lazy_lock, bool);
107  	TEST_MALLCTL_CONFIG(malloc_conf, const char *);
108  	TEST_MALLCTL_CONFIG(prof, bool);
109  	TEST_MALLCTL_CONFIG(prof_libgcc, bool);
110  	TEST_MALLCTL_CONFIG(prof_libunwind, bool);
111  	TEST_MALLCTL_CONFIG(stats, bool);
112  	TEST_MALLCTL_CONFIG(utrace, bool);
113  	TEST_MALLCTL_CONFIG(xmalloc, bool);
114  #undef TEST_MALLCTL_CONFIG
115  }
116  TEST_END
117  TEST_BEGIN(test_mallctl_opt) {
118  	bool config_always = true;
119  #define TEST_MALLCTL_OPT(t, opt, config) do {				\
120  	t oldval;							\
121  	size_t sz = sizeof(oldval);					\
122  	int expected = config_##config ? 0 : ENOENT;			\
123  	int result = mallctl(&quot;opt.&quot;#opt, (void *)&amp;oldval, &amp;sz, NULL,	\
124  	    0);								\
125  	assert_d_eq(result, expected,					\
126  	    &quot;Unexpected mallctl() result for opt.&quot;#opt);		\
127  	assert_zu_eq(sz, sizeof(oldval), &quot;Unexpected output size&quot;);	\
128  } while (0)
129  	TEST_MALLCTL_OPT(bool, abort, always);
130  	TEST_MALLCTL_OPT(bool, abort_conf, always);
131  	TEST_MALLCTL_OPT(bool, confirm_conf, always);
132  	TEST_MALLCTL_OPT(const char *, metadata_thp, always);
133  	TEST_MALLCTL_OPT(bool, retain, always);
134  	TEST_MALLCTL_OPT(const char *, dss, always);
135  	TEST_MALLCTL_OPT(unsigned, narenas, always);
136  	TEST_MALLCTL_OPT(const char *, percpu_arena, always);
137  	TEST_MALLCTL_OPT(size_t, oversize_threshold, always);
138  	TEST_MALLCTL_OPT(bool, background_thread, always);
139  	TEST_MALLCTL_OPT(ssize_t, dirty_decay_ms, always);
140  	TEST_MALLCTL_OPT(ssize_t, muzzy_decay_ms, always);
141  	TEST_MALLCTL_OPT(bool, stats_print, always);
142  	TEST_MALLCTL_OPT(const char *, junk, fill);
143  	TEST_MALLCTL_OPT(bool, zero, fill);
144  	TEST_MALLCTL_OPT(bool, utrace, utrace);
145  	TEST_MALLCTL_OPT(bool, xmalloc, xmalloc);
146  	TEST_MALLCTL_OPT(bool, tcache, always);
147  	TEST_MALLCTL_OPT(size_t, lg_extent_max_active_fit, always);
148  	TEST_MALLCTL_OPT(size_t, lg_tcache_max, always);
149  	TEST_MALLCTL_OPT(const char *, thp, always);
150  	TEST_MALLCTL_OPT(bool, prof, prof);
151  	TEST_MALLCTL_OPT(const char *, prof_prefix, prof);
152  	TEST_MALLCTL_OPT(bool, prof_active, prof);
153  	TEST_MALLCTL_OPT(ssize_t, lg_prof_sample, prof);
154  	TEST_MALLCTL_OPT(bool, prof_accum, prof);
155  	TEST_MALLCTL_OPT(ssize_t, lg_prof_interval, prof);
156  	TEST_MALLCTL_OPT(bool, prof_gdump, prof);
157  	TEST_MALLCTL_OPT(bool, prof_final, prof);
158  	TEST_MALLCTL_OPT(bool, prof_leak, prof);
159  #undef TEST_MALLCTL_OPT
160  }
161  TEST_END
162  TEST_BEGIN(test_manpage_example) {
163  	unsigned nbins, i;
164  	size_t mib[4];
165  	size_t len, miblen;
166  	len = sizeof(nbins);
167  	assert_d_eq(mallctl(&quot;arenas.nbins&quot;, (void *)&amp;nbins, &amp;len, NULL, 0), 0,
168  	    &quot;Unexpected mallctl() failure&quot;);
169  	miblen = 4;
170  	assert_d_eq(mallctlnametomib(&quot;arenas.bin.0.size&quot;, mib, &amp;miblen), 0,
171  	    &quot;Unexpected mallctlnametomib() failure&quot;);
172  	for (i = 0; i &lt; nbins; i++) {
173  		size_t bin_size;
174  		mib[2] = i;
175  		len = sizeof(bin_size);
176  		assert_d_eq(mallctlbymib(mib, miblen, (void *)&amp;bin_size, &amp;len,
177  		    NULL, 0), 0, &quot;Unexpected mallctlbymib() failure&quot;);
178  	}
179  }
180  TEST_END
181  TEST_BEGIN(test_tcache_none) {
182  	test_skip_if(!opt_tcache);
183  	void *p0 = mallocx(42, 0);
184  	assert_ptr_not_null(p0, &quot;Unexpected mallocx() failure&quot;);
185  	void *q = mallocx(42, 0);
186  	assert_ptr_not_null(q, &quot;Unexpected mallocx() failure&quot;);
187  	dallocx(p0, 0);
188  	dallocx(q, MALLOCX_TCACHE_NONE);
189  	void *p1 = mallocx(42, 0);
190  	assert_ptr_not_null(p1, &quot;Unexpected mallocx() failure&quot;);
191  	assert_ptr_eq(p0, p1, &quot;Expected tcache to allocate cached region&quot;);
192  	dallocx(p1, MALLOCX_TCACHE_NONE);
193  }
194  TEST_END
195  TEST_BEGIN(test_tcache) {
196  #define NTCACHES	10
197  	unsigned tis[NTCACHES];
198  	void *ps[NTCACHES];
199  	void *qs[NTCACHES];
200  	unsigned i;
201  	size_t sz, psz, qsz;
202  	psz = 42;
203  	qsz = nallocx(psz, 0) + 1;
204  	for (i = 0; i &lt; NTCACHES; i++) {
205  		sz = sizeof(unsigned);
206  		assert_d_eq(mallctl(&quot;tcache.create&quot;, (void *)&amp;tis[i], &amp;sz, NULL,
207  		    0), 0, &quot;Unexpected mallctl() failure, i=%u&quot;, i);
208  	}
209  	for (i = 0; i &lt; NTCACHES; i++) {
210  		assert_d_eq(mallctl(&quot;tcache.destroy&quot;, NULL, NULL,
211  		    (void *)&amp;tis[i], sizeof(unsigned)), 0,
212  		    &quot;Unexpected mallctl() failure, i=%u&quot;, i);
213  	}
214  	for (i = 0; i &lt; NTCACHES; i++) {
215  		sz = sizeof(unsigned);
216  		assert_d_eq(mallctl(&quot;tcache.create&quot;, (void *)&amp;tis[i], &amp;sz, NULL,
217  		    0), 0, &quot;Unexpected mallctl() failure, i=%u&quot;, i);
218  	}
219  	for (i = 0; i &lt; NTCACHES; i++) {
220  		assert_d_eq(mallctl(&quot;tcache.flush&quot;, NULL, NULL, (void *)&amp;tis[i],
221  		    sizeof(unsigned)), 0, &quot;Unexpected mallctl() failure, i=%u&quot;,
222  		    i);
223  	}
224  	for (i = 0; i &lt; NTCACHES; i++) {
225  		ps[i] = mallocx(psz, MALLOCX_TCACHE(tis[i]));
226  		assert_ptr_not_null(ps[i], &quot;Unexpected mallocx() failure, i=%u&quot;,
227  		    i);
228  		dallocx(ps[i], MALLOCX_TCACHE(tis[i]));
229  		qs[i] = mallocx(qsz, MALLOCX_TCACHE(tis[i]));
230  		assert_ptr_not_null(qs[i], &quot;Unexpected mallocx() failure, i=%u&quot;,
231  		    i);
232  		dallocx(qs[i], MALLOCX_TCACHE(tis[i]));
233  	}
234  	for (i = 0; i &lt; NTCACHES; i++) {
235  		void *p0 = ps[i];
236  		ps[i] = mallocx(psz, MALLOCX_TCACHE(tis[i]));
237  		assert_ptr_not_null(ps[i], &quot;Unexpected mallocx() failure, i=%u&quot;,
238  		    i);
239  		assert_ptr_eq(ps[i], p0,
240  		    &quot;Expected mallocx() to allocate cached region, i=%u&quot;, i);
241  	}
242  	for (i = 0; i &lt; NTCACHES; i++) {
243  		void *q0 = qs[i];
244  		qs[i] = rallocx(ps[i], qsz, MALLOCX_TCACHE(tis[i]));
245  		assert_ptr_not_null(qs[i], &quot;Unexpected rallocx() failure, i=%u&quot;,
246  		    i);
247  		assert_ptr_eq(qs[i], q0,
248  		    &quot;Expected rallocx() to allocate cached region, i=%u&quot;, i);
249  		if (qs[i] == NULL) {
250  			qs[i] = ps[i];
251  		}
252  	}
253  	for (i = 0; i &lt; NTCACHES; i++) {
254  		dallocx(qs[i], MALLOCX_TCACHE(tis[i]));
255  	}
256  	for (i = 0; i &lt; NTCACHES/2; i++) {
257  		assert_d_eq(mallctl(&quot;tcache.flush&quot;, NULL, NULL, (void *)&amp;tis[i],
258  		    sizeof(unsigned)), 0, &quot;Unexpected mallctl() failure, i=%u&quot;,
259  		    i);
260  	}
261  	for (i = 0; i &lt; NTCACHES; i++) {
262  		assert_d_eq(mallctl(&quot;tcache.destroy&quot;, NULL, NULL,
263  		    (void *)&amp;tis[i], sizeof(unsigned)), 0,
264  		    &quot;Unexpected mallctl() failure, i=%u&quot;, i);
265  	}
266  }
267  TEST_END
268  TEST_BEGIN(test_thread_arena) {
269  	unsigned old_arena_ind, new_arena_ind, narenas;
270  	const char *opa;
271  	size_t sz = sizeof(opa);
272  	assert_d_eq(mallctl(&quot;opt.percpu_arena&quot;, (void *)&amp;opa, &amp;sz, NULL, 0), 0,
273  	    &quot;Unexpected mallctl() failure&quot;);
274  	sz = sizeof(unsigned);
275  	assert_d_eq(mallctl(&quot;arenas.narenas&quot;, (void *)&amp;narenas, &amp;sz, NULL, 0),
276  	    0, &quot;Unexpected mallctl() failure&quot;);
277  	if (opt_oversize_threshold != 0) {
278  		narenas--;
279  	}
280  	assert_u_eq(narenas, opt_narenas, &quot;Number of arenas incorrect&quot;);
281  	if (strcmp(opa, &quot;disabled&quot;) == 0) {
282  		new_arena_ind = narenas - 1;
283  		assert_d_eq(mallctl(&quot;thread.arena&quot;, (void *)&amp;old_arena_ind, &amp;sz,
284  		    (void *)&amp;new_arena_ind, sizeof(unsigned)), 0,
285  		    &quot;Unexpected mallctl() failure&quot;);
286  		new_arena_ind = 0;
287  		assert_d_eq(mallctl(&quot;thread.arena&quot;, (void *)&amp;old_arena_ind, &amp;sz,
288  		    (void *)&amp;new_arena_ind, sizeof(unsigned)), 0,
289  		    &quot;Unexpected mallctl() failure&quot;);
290  	} else {
291  		assert_d_eq(mallctl(&quot;thread.arena&quot;, (void *)&amp;old_arena_ind, &amp;sz,
292  		    NULL, 0), 0, &quot;Unexpected mallctl() failure&quot;);
293  		new_arena_ind = percpu_arena_ind_limit(opt_percpu_arena) - 1;
294  		if (old_arena_ind != new_arena_ind) {
295  			assert_d_eq(mallctl(&quot;thread.arena&quot;,
296  			    (void *)&amp;old_arena_ind, &amp;sz, (void *)&amp;new_arena_ind,
297  			    sizeof(unsigned)), EPERM, &quot;thread.arena ctl &quot;
298  			    &quot;should not be allowed with percpu arena&quot;);
299  		}
300  	}
301  }
302  TEST_END
303  TEST_BEGIN(test_arena_i_initialized) {
304  	unsigned narenas, i;
305  	size_t sz;
306  	size_t mib[3];
307  	size_t miblen = sizeof(mib) / sizeof(size_t);
308  	bool initialized;
309  	sz = sizeof(narenas);
310  	assert_d_eq(mallctl(&quot;arenas.narenas&quot;, (void *)&amp;narenas, &amp;sz, NULL, 0),
311  	    0, &quot;Unexpected mallctl() failure&quot;);
312  	assert_d_eq(mallctlnametomib(&quot;arena.0.initialized&quot;, mib, &amp;miblen), 0,
313  	    &quot;Unexpected mallctlnametomib() failure&quot;);
314  	for (i = 0; i &lt; narenas; i++) {
315  		mib[1] = i;
316  		sz = sizeof(initialized);
317  		assert_d_eq(mallctlbymib(mib, miblen, &amp;initialized, &amp;sz, NULL,
318  		    0), 0, &quot;Unexpected mallctl() failure&quot;);
319  	}
320  	mib[1] = MALLCTL_ARENAS_ALL;
321  	sz = sizeof(initialized);
322  	assert_d_eq(mallctlbymib(mib, miblen, &amp;initialized, &amp;sz, NULL, 0), 0,
323  	    &quot;Unexpected mallctl() failure&quot;);
324  	assert_true(initialized,
325  	    &quot;Merged arena statistics should always be initialized&quot;);
326  	sz = sizeof(initialized);
327  	assert_d_eq(mallctl(
328  	    &quot;arena.&quot; STRINGIFY(MALLCTL_ARENAS_ALL) &quot;.initialized&quot;,
329  	    (void *)&amp;initialized, &amp;sz, NULL, 0), 0,
330  	    &quot;Unexpected mallctl() failure&quot;);
331  	assert_true(initialized,
332  	    &quot;Merged arena statistics should always be initialized&quot;);
333  }
334  TEST_END
335  TEST_BEGIN(test_arena_i_dirty_decay_ms) {
336  	ssize_t dirty_decay_ms, orig_dirty_decay_ms, prev_dirty_decay_ms;
337  	size_t sz = sizeof(ssize_t);
338  	assert_d_eq(mallctl(&quot;arena.0.dirty_decay_ms&quot;,
339  	    (void *)&amp;orig_dirty_decay_ms, &amp;sz, NULL, 0), 0,
340  	    &quot;Unexpected mallctl() failure&quot;);
341  	dirty_decay_ms = -2;
342  	assert_d_eq(mallctl(&quot;arena.0.dirty_decay_ms&quot;, NULL, NULL,
343  	    (void *)&amp;dirty_decay_ms, sizeof(ssize_t)), EFAULT,
344  	    &quot;Unexpected mallctl() success&quot;);
345  	dirty_decay_ms = 0x7fffffff;
346  	assert_d_eq(mallctl(&quot;arena.0.dirty_decay_ms&quot;, NULL, NULL,
347  	    (void *)&amp;dirty_decay_ms, sizeof(ssize_t)), 0,
348  	    &quot;Unexpected mallctl() failure&quot;);
349  	for (prev_dirty_decay_ms = dirty_decay_ms, dirty_decay_ms = -1;
350  	    dirty_decay_ms &lt; 20; prev_dirty_decay_ms = dirty_decay_ms,
351  	    dirty_decay_ms++) {
352  		ssize_t old_dirty_decay_ms;
353  		assert_d_eq(mallctl(&quot;arena.0.dirty_decay_ms&quot;,
354  		    (void *)&amp;old_dirty_decay_ms, &amp;sz, (void *)&amp;dirty_decay_ms,
355  		    sizeof(ssize_t)), 0, &quot;Unexpected mallctl() failure&quot;);
356  		assert_zd_eq(old_dirty_decay_ms, prev_dirty_decay_ms,
357  		    &quot;Unexpected old arena.0.dirty_decay_ms&quot;);
358  	}
359  }
360  TEST_END
361  TEST_BEGIN(test_arena_i_muzzy_decay_ms) {
362  	ssize_t muzzy_decay_ms, orig_muzzy_decay_ms, prev_muzzy_decay_ms;
363  	size_t sz = sizeof(ssize_t);
364  	assert_d_eq(mallctl(&quot;arena.0.muzzy_decay_ms&quot;,
365  	    (void *)&amp;orig_muzzy_decay_ms, &amp;sz, NULL, 0), 0,
366  	    &quot;Unexpected mallctl() failure&quot;);
367  	muzzy_decay_ms = -2;
368  	assert_d_eq(mallctl(&quot;arena.0.muzzy_decay_ms&quot;, NULL, NULL,
369  	    (void *)&amp;muzzy_decay_ms, sizeof(ssize_t)), EFAULT,
370  	    &quot;Unexpected mallctl() success&quot;);
371  	muzzy_decay_ms = 0x7fffffff;
372  	assert_d_eq(mallctl(&quot;arena.0.muzzy_decay_ms&quot;, NULL, NULL,
373  	    (void *)&amp;muzzy_decay_ms, sizeof(ssize_t)), 0,
374  	    &quot;Unexpected mallctl() failure&quot;);
375  	for (prev_muzzy_decay_ms = muzzy_decay_ms, muzzy_decay_ms = -1;
376  	    muzzy_decay_ms &lt; 20; prev_muzzy_decay_ms = muzzy_decay_ms,
377  	    muzzy_decay_ms++) {
378  		ssize_t old_muzzy_decay_ms;
379  		assert_d_eq(mallctl(&quot;arena.0.muzzy_decay_ms&quot;,
380  		    (void *)&amp;old_muzzy_decay_ms, &amp;sz, (void *)&amp;muzzy_decay_ms,
381  		    sizeof(ssize_t)), 0, &quot;Unexpected mallctl() failure&quot;);
382  		assert_zd_eq(old_muzzy_decay_ms, prev_muzzy_decay_ms,
383  		    &quot;Unexpected old arena.0.muzzy_decay_ms&quot;);
384  	}
385  }
386  TEST_END
387  TEST_BEGIN(test_arena_i_purge) {
388  	unsigned narenas;
389  	size_t sz = sizeof(unsigned);
390  	size_t mib[3];
391  	size_t miblen = 3;
392  	assert_d_eq(mallctl(&quot;arena.0.purge&quot;, NULL, NULL, NULL, 0), 0,
393  	    &quot;Unexpected mallctl() failure&quot;);
394  	assert_d_eq(mallctl(&quot;arenas.narenas&quot;, (void *)&amp;narenas, &amp;sz, NULL, 0),
395  	    0, &quot;Unexpected mallctl() failure&quot;);
396  	assert_d_eq(mallctlnametomib(&quot;arena.0.purge&quot;, mib, &amp;miblen), 0,
397  	    &quot;Unexpected mallctlnametomib() failure&quot;);
398  	mib[1] = narenas;
399  	assert_d_eq(mallctlbymib(mib, miblen, NULL, NULL, NULL, 0), 0,
400  	    &quot;Unexpected mallctlbymib() failure&quot;);
401  	mib[1] = MALLCTL_ARENAS_ALL;
402  	assert_d_eq(mallctlbymib(mib, miblen, NULL, NULL, NULL, 0), 0,
403  	    &quot;Unexpected mallctlbymib() failure&quot;);
404  }
405  TEST_END
406  TEST_BEGIN(test_arena_i_decay) {
407  	unsigned narenas;
408  	size_t sz = sizeof(unsigned);
409  	size_t mib[3];
410  	size_t miblen = 3;
411  	assert_d_eq(mallctl(&quot;arena.0.decay&quot;, NULL, NULL, NULL, 0), 0,
412  	    &quot;Unexpected mallctl() failure&quot;);
413  	assert_d_eq(mallctl(&quot;arenas.narenas&quot;, (void *)&amp;narenas, &amp;sz, NULL, 0),
414  	    0, &quot;Unexpected mallctl() failure&quot;);
415  	assert_d_eq(mallctlnametomib(&quot;arena.0.decay&quot;, mib, &amp;miblen), 0,
416  	    &quot;Unexpected mallctlnametomib() failure&quot;);
417  	mib[1] = narenas;
418  	assert_d_eq(mallctlbymib(mib, miblen, NULL, NULL, NULL, 0), 0,
419  	    &quot;Unexpected mallctlbymib() failure&quot;);
420  	mib[1] = MALLCTL_ARENAS_ALL;
421  	assert_d_eq(mallctlbymib(mib, miblen, NULL, NULL, NULL, 0), 0,
422  	    &quot;Unexpected mallctlbymib() failure&quot;);
423  }
424  TEST_END
425  TEST_BEGIN(test_arena_i_dss) {
426  	const char *dss_prec_old, *dss_prec_new;
427  	size_t sz = sizeof(dss_prec_old);
428  	size_t mib[3];
429  	size_t miblen;
430  	miblen = sizeof(mib)/sizeof(size_t);
431  	assert_d_eq(mallctlnametomib(&quot;arena.0.dss&quot;, mib, &amp;miblen), 0,
432  	    &quot;Unexpected mallctlnametomib() error&quot;);
433  	dss_prec_new = &quot;disabled&quot;;
434  	assert_d_eq(mallctlbymib(mib, miblen, (void *)&amp;dss_prec_old, &amp;sz,
435  	    (void *)&amp;dss_prec_new, sizeof(dss_prec_new)), 0,
436  	    &quot;Unexpected mallctl() failure&quot;);
437  	assert_str_ne(dss_prec_old, &quot;primary&quot;,
438  	    &quot;Unexpected default for dss precedence&quot;);
439  	assert_d_eq(mallctlbymib(mib, miblen, (void *)&amp;dss_prec_new, &amp;sz,
440  	    (void *)&amp;dss_prec_old, sizeof(dss_prec_old)), 0,
441  	    &quot;Unexpected mallctl() failure&quot;);
442  	assert_d_eq(mallctlbymib(mib, miblen, (void *)&amp;dss_prec_old, &amp;sz, NULL,
443  	    0), 0, &quot;Unexpected mallctl() failure&quot;);
444  	assert_str_ne(dss_prec_old, &quot;primary&quot;,
445  	    &quot;Unexpected value for dss precedence&quot;);
446  	mib[1] = narenas_total_get();
447  	dss_prec_new = &quot;disabled&quot;;
448  	assert_d_eq(mallctlbymib(mib, miblen, (void *)&amp;dss_prec_old, &amp;sz,
449  	    (void *)&amp;dss_prec_new, sizeof(dss_prec_new)), 0,
450  	    &quot;Unexpected mallctl() failure&quot;);
451  	assert_str_ne(dss_prec_old, &quot;primary&quot;,
452  	    &quot;Unexpected default for dss precedence&quot;);
453  	assert_d_eq(mallctlbymib(mib, miblen, (void *)&amp;dss_prec_new, &amp;sz,
454  	    (void *)&amp;dss_prec_old, sizeof(dss_prec_new)), 0,
455  	    &quot;Unexpected mallctl() failure&quot;);
456  	assert_d_eq(mallctlbymib(mib, miblen, (void *)&amp;dss_prec_old, &amp;sz, NULL,
457  	    0), 0, &quot;Unexpected mallctl() failure&quot;);
458  	assert_str_ne(dss_prec_old, &quot;primary&quot;,
459  	    &quot;Unexpected value for dss precedence&quot;);
460  }
461  TEST_END
462  TEST_BEGIN(test_arena_i_retain_grow_limit) {
463  	size_t old_limit, new_limit, default_limit;
464  	size_t mib[3];
465  	size_t miblen;
466  	bool retain_enabled;
467  	size_t sz = sizeof(retain_enabled);
468  	assert_d_eq(mallctl(&quot;opt.retain&quot;, &amp;retain_enabled, &amp;sz, NULL, 0),
469  	    0, &quot;Unexpected mallctl() failure&quot;);
470  	test_skip_if(!retain_enabled);
471  	sz = sizeof(default_limit);
472  	miblen = sizeof(mib)/sizeof(size_t);
473  	assert_d_eq(mallctlnametomib(&quot;arena.0.retain_grow_limit&quot;, mib, &amp;miblen),
474  	    0, &quot;Unexpected mallctlnametomib() error&quot;);
475  	assert_d_eq(mallctlbymib(mib, miblen, &amp;default_limit, &amp;sz, NULL, 0), 0,
476  	    &quot;Unexpected mallctl() failure&quot;);
477  	assert_zu_eq(default_limit, SC_LARGE_MAXCLASS,
478  	    &quot;Unexpected default for retain_grow_limit&quot;);
479  	new_limit = PAGE - 1;
480  	assert_d_eq(mallctlbymib(mib, miblen, NULL, NULL, &amp;new_limit,
481  	    sizeof(new_limit)), EFAULT, &quot;Unexpected mallctl() success&quot;);
482  	new_limit = PAGE + 1;
483  	assert_d_eq(mallctlbymib(mib, miblen, NULL, NULL, &amp;new_limit,
484  	    sizeof(new_limit)), 0, &quot;Unexpected mallctl() failure&quot;);
485  	assert_d_eq(mallctlbymib(mib, miblen, &amp;old_limit, &amp;sz, NULL, 0), 0,
486  	    &quot;Unexpected mallctl() failure&quot;);
487  	assert_zu_eq(old_limit, PAGE,
488  	    &quot;Unexpected value for retain_grow_limit&quot;);
489  	new_limit = sz_pind2sz(10) - 1;
490  	assert_d_eq(mallctlbymib(mib, miblen, NULL, NULL, &amp;new_limit,
491  	    sizeof(new_limit)), 0, &quot;Unexpected mallctl() failure&quot;);
492  	assert_d_eq(mallctlbymib(mib, miblen, &amp;old_limit, &amp;sz, NULL, 0), 0,
493  	    &quot;Unexpected mallctl() failure&quot;);
494  	assert_zu_eq(old_limit, sz_pind2sz(9),
495  	    &quot;Unexpected value for retain_grow_limit&quot;);
496  	assert_d_eq(mallctlbymib(mib, miblen, NULL, NULL, &amp;default_limit,
497  	    sizeof(default_limit)), 0, &quot;Unexpected mallctl() failure&quot;);
498  }
499  TEST_END
500  TEST_BEGIN(test_arenas_dirty_decay_ms) {
501  	ssize_t dirty_decay_ms, orig_dirty_decay_ms, prev_dirty_decay_ms;
502  	size_t sz = sizeof(ssize_t);
503  	assert_d_eq(mallctl(&quot;arenas.dirty_decay_ms&quot;,
504  	    (void *)&amp;orig_dirty_decay_ms, &amp;sz, NULL, 0), 0,
505  	    &quot;Unexpected mallctl() failure&quot;);
506  	dirty_decay_ms = -2;
507  	assert_d_eq(mallctl(&quot;arenas.dirty_decay_ms&quot;, NULL, NULL,
508  	    (void *)&amp;dirty_decay_ms, sizeof(ssize_t)), EFAULT,
509  	    &quot;Unexpected mallctl() success&quot;);
510  	dirty_decay_ms = 0x7fffffff;
511  	assert_d_eq(mallctl(&quot;arenas.dirty_decay_ms&quot;, NULL, NULL,
512  	    (void *)&amp;dirty_decay_ms, sizeof(ssize_t)), 0,
513  	    &quot;Expected mallctl() failure&quot;);
514  	for (prev_dirty_decay_ms = dirty_decay_ms, dirty_decay_ms = -1;
515  	    dirty_decay_ms &lt; 20; prev_dirty_decay_ms = dirty_decay_ms,
516  	    dirty_decay_ms++) {
517  		ssize_t old_dirty_decay_ms;
518  		assert_d_eq(mallctl(&quot;arenas.dirty_decay_ms&quot;,
519  		    (void *)&amp;old_dirty_decay_ms, &amp;sz, (void *)&amp;dirty_decay_ms,
520  		    sizeof(ssize_t)), 0, &quot;Unexpected mallctl() failure&quot;);
<span onclick='openModal()' class='match'>521  		assert_zd_eq(old_dirty_decay_ms, prev_dirty_decay_ms,
522  		    &quot;Unexpected old arenas.dirty_decay_ms&quot;);
523  	}
524  }
525  TEST_END
526  TEST_BEGIN(test_arenas_muzzy_decay_ms) {
527  	ssize_t muzzy_decay_ms, orig_muzzy_decay_ms, prev_muzzy_decay_ms;
</span>528  	size_t sz = sizeof(ssize_t);
529  	assert_d_eq(mallctl(&quot;arenas.muzzy_decay_ms&quot;,
530  	    (void *)&amp;orig_muzzy_decay_ms, &amp;sz, NULL, 0), 0,
531  	    &quot;Unexpected mallctl() failure&quot;);
532  	muzzy_decay_ms = -2;
533  	assert_d_eq(mallctl(&quot;arenas.muzzy_decay_ms&quot;, NULL, NULL,
534  	    (void *)&amp;muzzy_decay_ms, sizeof(ssize_t)), EFAULT,
535  	    &quot;Unexpected mallctl() success&quot;);
536  	muzzy_decay_ms = 0x7fffffff;
537  	assert_d_eq(mallctl(&quot;arenas.muzzy_decay_ms&quot;, NULL, NULL,
538  	    (void *)&amp;muzzy_decay_ms, sizeof(ssize_t)), 0,
539  	    &quot;Expected mallctl() failure&quot;);
540  	for (prev_muzzy_decay_ms = muzzy_decay_ms, muzzy_decay_ms = -1;
541  	    muzzy_decay_ms &lt; 20; prev_muzzy_decay_ms = muzzy_decay_ms,
542  	    muzzy_decay_ms++) {
543  		ssize_t old_muzzy_decay_ms;
544  		assert_d_eq(mallctl(&quot;arenas.muzzy_decay_ms&quot;,
545  		    (void *)&amp;old_muzzy_decay_ms, &amp;sz, (void *)&amp;muzzy_decay_ms,
546  		    sizeof(ssize_t)), 0, &quot;Unexpected mallctl() failure&quot;);
547  		assert_zd_eq(old_muzzy_decay_ms, prev_muzzy_decay_ms,
548  		    &quot;Unexpected old arenas.muzzy_decay_ms&quot;);
549  	}
550  }
551  TEST_END
552  TEST_BEGIN(test_arenas_constants) {
553  #define TEST_ARENAS_CONSTANT(t, name, expected) do {			\
554  	t name;								\
555  	size_t sz = sizeof(t);						\
556  	assert_d_eq(mallctl(&quot;arenas.&quot;#name, (void *)&amp;name, &amp;sz, NULL,	\
557  	    0), 0, &quot;Unexpected mallctl() failure&quot;);			\
558  	assert_zu_eq(name, expected, &quot;Incorrect &quot;#name&quot; size&quot;);		\
559  } while (0)
560  	TEST_ARENAS_CONSTANT(size_t, quantum, QUANTUM);
561  	TEST_ARENAS_CONSTANT(size_t, page, PAGE);
562  	TEST_ARENAS_CONSTANT(unsigned, nbins, SC_NBINS);
563  	TEST_ARENAS_CONSTANT(unsigned, nlextents, SC_NSIZES - SC_NBINS);
564  #undef TEST_ARENAS_CONSTANT
565  }
566  TEST_END
567  TEST_BEGIN(test_arenas_bin_constants) {
568  #define TEST_ARENAS_BIN_CONSTANT(t, name, expected) do {		\
569  	t name;								\
570  	size_t sz = sizeof(t);						\
571  	assert_d_eq(mallctl(&quot;arenas.bin.0.&quot;#name, (void *)&amp;name, &amp;sz,	\
572  	    NULL, 0), 0, &quot;Unexpected mallctl() failure&quot;);		\
573  	assert_zu_eq(name, expected, &quot;Incorrect &quot;#name&quot; size&quot;);		\
574  } while (0)
575  	TEST_ARENAS_BIN_CONSTANT(size_t, size, bin_infos[0].reg_size);
576  	TEST_ARENAS_BIN_CONSTANT(uint32_t, nregs, bin_infos[0].nregs);
577  	TEST_ARENAS_BIN_CONSTANT(size_t, slab_size,
578  	    bin_infos[0].slab_size);
579  	TEST_ARENAS_BIN_CONSTANT(uint32_t, nshards, bin_infos[0].n_shards);
580  #undef TEST_ARENAS_BIN_CONSTANT
581  }
582  TEST_END
583  TEST_BEGIN(test_arenas_lextent_constants) {
584  #define TEST_ARENAS_LEXTENT_CONSTANT(t, name, expected) do {		\
585  	t name;								\
586  	size_t sz = sizeof(t);						\
587  	assert_d_eq(mallctl(&quot;arenas.lextent.0.&quot;#name, (void *)&amp;name,	\
588  	    &amp;sz, NULL, 0), 0, &quot;Unexpected mallctl() failure&quot;);		\
589  	assert_zu_eq(name, expected, &quot;Incorrect &quot;#name&quot; size&quot;);		\
590  } while (0)
591  	TEST_ARENAS_LEXTENT_CONSTANT(size_t, size,
592  	    SC_LARGE_MINCLASS);
593  #undef TEST_ARENAS_LEXTENT_CONSTANT
594  }
595  TEST_END
596  TEST_BEGIN(test_arenas_create) {
597  	unsigned narenas_before, arena, narenas_after;
598  	size_t sz = sizeof(unsigned);
599  	assert_d_eq(mallctl(&quot;arenas.narenas&quot;, (void *)&amp;narenas_before, &amp;sz,
600  	    NULL, 0), 0, &quot;Unexpected mallctl() failure&quot;);
601  	assert_d_eq(mallctl(&quot;arenas.create&quot;, (void *)&amp;arena, &amp;sz, NULL, 0), 0,
602  	    &quot;Unexpected mallctl() failure&quot;);
603  	assert_d_eq(mallctl(&quot;arenas.narenas&quot;, (void *)&amp;narenas_after, &amp;sz, NULL,
604  	    0), 0, &quot;Unexpected mallctl() failure&quot;);
605  	assert_u_eq(narenas_before+1, narenas_after,
606  	    &quot;Unexpected number of arenas before versus after extension&quot;);
607  	assert_u_eq(arena, narenas_after-1, &quot;Unexpected arena index&quot;);
608  }
609  TEST_END
610  TEST_BEGIN(test_arenas_lookup) {
611  	unsigned arena, arena1;
612  	void *ptr;
613  	size_t sz = sizeof(unsigned);
614  	assert_d_eq(mallctl(&quot;arenas.create&quot;, (void *)&amp;arena, &amp;sz, NULL, 0), 0,
615  	    &quot;Unexpected mallctl() failure&quot;);
616  	ptr = mallocx(42, MALLOCX_ARENA(arena) | MALLOCX_TCACHE_NONE);
617  	assert_ptr_not_null(ptr, &quot;Unexpected mallocx() failure&quot;);
618  	assert_d_eq(mallctl(&quot;arenas.lookup&quot;, &amp;arena1, &amp;sz, &amp;ptr, sizeof(ptr)),
619  	    0, &quot;Unexpected mallctl() failure&quot;);
620  	assert_u_eq(arena, arena1, &quot;Unexpected arena index&quot;);
621  	dallocx(ptr, 0);
622  }
623  TEST_END
624  TEST_BEGIN(test_stats_arenas) {
625  #define TEST_STATS_ARENAS(t, name) do {					\
626  	t name;								\
627  	size_t sz = sizeof(t);						\
628  	assert_d_eq(mallctl(&quot;stats.arenas.0.&quot;#name, (void *)&amp;name, &amp;sz,	\
629  	    NULL, 0), 0, &quot;Unexpected mallctl() failure&quot;);		\
630  } while (0)
631  	TEST_STATS_ARENAS(unsigned, nthreads);
632  	TEST_STATS_ARENAS(const char *, dss);
633  	TEST_STATS_ARENAS(ssize_t, dirty_decay_ms);
634  	TEST_STATS_ARENAS(ssize_t, muzzy_decay_ms);
635  	TEST_STATS_ARENAS(size_t, pactive);
636  	TEST_STATS_ARENAS(size_t, pdirty);
637  #undef TEST_STATS_ARENAS
638  }
639  TEST_END
640  static void
641  alloc_hook(void *extra, UNUSED hook_alloc_t type, UNUSED void *result,
642      UNUSED uintptr_t result_raw, UNUSED uintptr_t args_raw[3]) {
643  	*(bool *)extra = true;
644  }
645  static void
646  dalloc_hook(void *extra, UNUSED hook_dalloc_t type,
647      UNUSED void *address, UNUSED uintptr_t args_raw[3]) {
648  	*(bool *)extra = true;
649  }
650  TEST_BEGIN(test_hooks) {
651  	bool hook_called = false;
652  	hooks_t hooks = {&amp;alloc_hook, &amp;dalloc_hook, NULL, &amp;hook_called};
653  	void *handle = NULL;
654  	size_t sz = sizeof(handle);
655  	int err = mallctl(&quot;experimental.hooks.install&quot;, &amp;handle, &amp;sz, &amp;hooks,
656  	    sizeof(hooks));
657  	assert_d_eq(err, 0, &quot;Hook installation failed&quot;);
658  	assert_ptr_ne(handle, NULL, &quot;Hook installation gave null handle&quot;);
659  	void *ptr = mallocx(1, 0);
660  	assert_true(hook_called, &quot;Alloc hook not called&quot;);
661  	hook_called = false;
662  	free(ptr);
663  	assert_true(hook_called, &quot;Free hook not called&quot;);
664  	err = mallctl(&quot;experimental.hooks.remove&quot;, NULL, NULL, &amp;handle,
665  	    sizeof(handle));
666  	assert_d_eq(err, 0, &quot;Hook removal failed&quot;);
667  	hook_called = false;
668  	ptr = mallocx(1, 0);
669  	free(ptr);
670  	assert_false(hook_called, &quot;Hook called after removal&quot;);
671  }
672  TEST_END
673  TEST_BEGIN(test_hooks_exhaustion) {
674  	bool hook_called = false;
675  	hooks_t hooks = {&amp;alloc_hook, &amp;dalloc_hook, NULL, &amp;hook_called};
676  	void *handle;
677  	void *handles[HOOK_MAX];
678  	size_t sz = sizeof(handle);
679  	int err;
680  	for (int i = 0; i &lt; HOOK_MAX; i++) {
681  		handle = NULL;
682  		err = mallctl(&quot;experimental.hooks.install&quot;, &amp;handle, &amp;sz,
683  		    &amp;hooks, sizeof(hooks));
684  		assert_d_eq(err, 0, &quot;Error installation hooks&quot;);
685  		assert_ptr_ne(handle, NULL, &quot;Got NULL handle&quot;);
686  		handles[i] = handle;
687  	}
688  	err = mallctl(&quot;experimental.hooks.install&quot;, &amp;handle, &amp;sz, &amp;hooks,
689  	    sizeof(hooks));
690  	assert_d_eq(err, EAGAIN, &quot;Should have failed hook installation&quot;);
691  	for (int i = 0; i &lt; HOOK_MAX; i++) {
692  		err = mallctl(&quot;experimental.hooks.remove&quot;, NULL, NULL,
693  		    &amp;handles[i], sizeof(handles[i]));
694  		assert_d_eq(err, 0, &quot;Hook removal failed&quot;);
695  	}
696  	handle = NULL;
697  	err = mallctl(&quot;experimental.hooks.install&quot;, &amp;handle, &amp;sz, &amp;hooks,
698  	    sizeof(hooks));
699  	assert_d_eq(err, 0, &quot;Hook insertion failed&quot;);
700  	assert_ptr_ne(handle, NULL, &quot;Got NULL handle&quot;);
701  	err = mallctl(&quot;experimental.hooks.remove&quot;, NULL, NULL, &amp;handle,
702  	    sizeof(handle));
703  	assert_d_eq(err, 0, &quot;Hook removal failed&quot;);
704  }
705  TEST_END
706  int
707  main(void) {
708  	return test(
709  	    test_mallctl_errors,
710  	    test_mallctlnametomib_errors,
711  	    test_mallctlbymib_errors,
712  	    test_mallctl_read_write,
713  	    test_mallctlnametomib_short_mib,
714  	    test_mallctl_config,
715  	    test_mallctl_opt,
716  	    test_manpage_example,
717  	    test_tcache_none,
718  	    test_tcache,
719  	    test_thread_arena,
720  	    test_arena_i_initialized,
721  	    test_arena_i_dirty_decay_ms,
722  	    test_arena_i_muzzy_decay_ms,
723  	    test_arena_i_purge,
724  	    test_arena_i_decay,
725  	    test_arena_i_dss,
726  	    test_arena_i_retain_grow_limit,
727  	    test_arenas_dirty_decay_ms,
728  	    test_arenas_muzzy_decay_ms,
729  	    test_arenas_constants,
730  	    test_arenas_bin_constants,
731  	    test_arenas_lextent_constants,
732  	    test_arenas_create,
733  	    test_arenas_lookup,
734  	    test_stats_arenas,
735  	    test_hooks,
736  	    test_hooks_exhaustion);
737  }
</code></pre>
        </div>
        <div class="column">
            <h3>redis-MDEwOlJlcG9zaXRvcnkxMDgxMTA3MDY=-flat-mallctl.c</h3>
            <pre><code>1  #include &quot;test/jemalloc_test.h&quot;
2  #include &quot;jemalloc/internal/hook.h&quot;
3  #include &quot;jemalloc/internal/util.h&quot;
4  TEST_BEGIN(test_mallctl_errors) {
5  	uint64_t epoch;
6  	size_t sz;
7  	assert_d_eq(mallctl(&quot;no_such_name&quot;, NULL, NULL, NULL, 0), ENOENT,
8  	    &quot;mallctl() should return ENOENT for non-existent names&quot;);
9  	assert_d_eq(mallctl(&quot;version&quot;, NULL, NULL, &quot;0.0.0&quot;, strlen(&quot;0.0.0&quot;)),
10  	    EPERM, &quot;mallctl() should return EPERM on attempt to write &quot;
11  	    &quot;read-only value&quot;);
12  	assert_d_eq(mallctl(&quot;epoch&quot;, NULL, NULL, (void *)&amp;epoch,
13  	    sizeof(epoch)-1), EINVAL,
14  	    &quot;mallctl() should return EINVAL for input size mismatch&quot;);
15  	assert_d_eq(mallctl(&quot;epoch&quot;, NULL, NULL, (void *)&amp;epoch,
16  	    sizeof(epoch)+1), EINVAL,
17  	    &quot;mallctl() should return EINVAL for input size mismatch&quot;);
18  	sz = sizeof(epoch)-1;
19  	assert_d_eq(mallctl(&quot;epoch&quot;, (void *)&amp;epoch, &amp;sz, NULL, 0), EINVAL,
20  	    &quot;mallctl() should return EINVAL for output size mismatch&quot;);
21  	sz = sizeof(epoch)+1;
22  	assert_d_eq(mallctl(&quot;epoch&quot;, (void *)&amp;epoch, &amp;sz, NULL, 0), EINVAL,
23  	    &quot;mallctl() should return EINVAL for output size mismatch&quot;);
24  }
25  TEST_END
26  TEST_BEGIN(test_mallctlnametomib_errors) {
27  	size_t mib[1];
28  	size_t miblen;
29  	miblen = sizeof(mib)/sizeof(size_t);
30  	assert_d_eq(mallctlnametomib(&quot;no_such_name&quot;, mib, &amp;miblen), ENOENT,
31  	    &quot;mallctlnametomib() should return ENOENT for non-existent names&quot;);
32  }
33  TEST_END
34  TEST_BEGIN(test_mallctlbymib_errors) {
35  	uint64_t epoch;
36  	size_t sz;
37  	size_t mib[1];
38  	size_t miblen;
39  	miblen = sizeof(mib)/sizeof(size_t);
40  	assert_d_eq(mallctlnametomib(&quot;version&quot;, mib, &amp;miblen), 0,
41  	    &quot;Unexpected mallctlnametomib() failure&quot;);
42  	assert_d_eq(mallctlbymib(mib, miblen, NULL, NULL, &quot;0.0.0&quot;,
43  	    strlen(&quot;0.0.0&quot;)), EPERM, &quot;mallctl() should return EPERM on &quot;
44  	    &quot;attempt to write read-only value&quot;);
45  	miblen = sizeof(mib)/sizeof(size_t);
46  	assert_d_eq(mallctlnametomib(&quot;epoch&quot;, mib, &amp;miblen), 0,
47  	    &quot;Unexpected mallctlnametomib() failure&quot;);
48  	assert_d_eq(mallctlbymib(mib, miblen, NULL, NULL, (void *)&amp;epoch,
49  	    sizeof(epoch)-1), EINVAL,
50  	    &quot;mallctlbymib() should return EINVAL for input size mismatch&quot;);
51  	assert_d_eq(mallctlbymib(mib, miblen, NULL, NULL, (void *)&amp;epoch,
52  	    sizeof(epoch)+1), EINVAL,
53  	    &quot;mallctlbymib() should return EINVAL for input size mismatch&quot;);
54  	sz = sizeof(epoch)-1;
55  	assert_d_eq(mallctlbymib(mib, miblen, (void *)&amp;epoch, &amp;sz, NULL, 0),
56  	    EINVAL,
57  	    &quot;mallctlbymib() should return EINVAL for output size mismatch&quot;);
58  	sz = sizeof(epoch)+1;
59  	assert_d_eq(mallctlbymib(mib, miblen, (void *)&amp;epoch, &amp;sz, NULL, 0),
60  	    EINVAL,
61  	    &quot;mallctlbymib() should return EINVAL for output size mismatch&quot;);
62  }
63  TEST_END
64  TEST_BEGIN(test_mallctl_read_write) {
65  	uint64_t old_epoch, new_epoch;
66  	size_t sz = sizeof(old_epoch);
67  	assert_d_eq(mallctl(&quot;epoch&quot;, NULL, NULL, NULL, 0), 0,
68  	    &quot;Unexpected mallctl() failure&quot;);
69  	assert_zu_eq(sz, sizeof(old_epoch), &quot;Unexpected output size&quot;);
70  	assert_d_eq(mallctl(&quot;epoch&quot;, (void *)&amp;old_epoch, &amp;sz, NULL, 0), 0,
71  	    &quot;Unexpected mallctl() failure&quot;);
72  	assert_zu_eq(sz, sizeof(old_epoch), &quot;Unexpected output size&quot;);
73  	assert_d_eq(mallctl(&quot;epoch&quot;, NULL, NULL, (void *)&amp;new_epoch,
74  	    sizeof(new_epoch)), 0, &quot;Unexpected mallctl() failure&quot;);
75  	assert_zu_eq(sz, sizeof(old_epoch), &quot;Unexpected output size&quot;);
76  	assert_d_eq(mallctl(&quot;epoch&quot;, (void *)&amp;old_epoch, &amp;sz,
77  	    (void *)&amp;new_epoch, sizeof(new_epoch)), 0,
78  	    &quot;Unexpected mallctl() failure&quot;);
79  	assert_zu_eq(sz, sizeof(old_epoch), &quot;Unexpected output size&quot;);
80  }
81  TEST_END
82  TEST_BEGIN(test_mallctlnametomib_short_mib) {
83  	size_t mib[4];
84  	size_t miblen;
85  	miblen = 3;
86  	mib[3] = 42;
87  	assert_d_eq(mallctlnametomib(&quot;arenas.bin.0.nregs&quot;, mib, &amp;miblen), 0,
88  	    &quot;Unexpected mallctlnametomib() failure&quot;);
89  	assert_zu_eq(miblen, 3, &quot;Unexpected mib output length&quot;);
90  	assert_zu_eq(mib[3], 42,
91  	    &quot;mallctlnametomib() wrote past the end of the input mib&quot;);
92  }
93  TEST_END
94  TEST_BEGIN(test_mallctl_config) {
95  #define TEST_MALLCTL_CONFIG(config, t) do {				\
96  	t oldval;							\
97  	size_t sz = sizeof(oldval);					\
98  	assert_d_eq(mallctl(&quot;config.&quot;#config, (void *)&amp;oldval, &amp;sz,	\
99  	    NULL, 0), 0, &quot;Unexpected mallctl() failure&quot;);		\
100  	assert_b_eq(oldval, config_##config, &quot;Incorrect config value&quot;);	\
101  	assert_zu_eq(sz, sizeof(oldval), &quot;Unexpected output size&quot;);	\
102  } while (0)
103  	TEST_MALLCTL_CONFIG(cache_oblivious, bool);
104  	TEST_MALLCTL_CONFIG(debug, bool);
105  	TEST_MALLCTL_CONFIG(fill, bool);
106  	TEST_MALLCTL_CONFIG(lazy_lock, bool);
107  	TEST_MALLCTL_CONFIG(malloc_conf, const char *);
108  	TEST_MALLCTL_CONFIG(prof, bool);
109  	TEST_MALLCTL_CONFIG(prof_libgcc, bool);
110  	TEST_MALLCTL_CONFIG(prof_libunwind, bool);
111  	TEST_MALLCTL_CONFIG(stats, bool);
112  	TEST_MALLCTL_CONFIG(utrace, bool);
113  	TEST_MALLCTL_CONFIG(xmalloc, bool);
114  #undef TEST_MALLCTL_CONFIG
115  }
116  TEST_END
117  TEST_BEGIN(test_mallctl_opt) {
118  	bool config_always = true;
119  #define TEST_MALLCTL_OPT(t, opt, config) do {				\
120  	t oldval;							\
121  	size_t sz = sizeof(oldval);					\
122  	int expected = config_##config ? 0 : ENOENT;			\
123  	int result = mallctl(&quot;opt.&quot;#opt, (void *)&amp;oldval, &amp;sz, NULL,	\
124  	    0);								\
125  	assert_d_eq(result, expected,					\
126  	    &quot;Unexpected mallctl() result for opt.&quot;#opt);		\
127  	assert_zu_eq(sz, sizeof(oldval), &quot;Unexpected output size&quot;);	\
128  } while (0)
129  	TEST_MALLCTL_OPT(bool, abort, always);
130  	TEST_MALLCTL_OPT(bool, abort_conf, always);
131  	TEST_MALLCTL_OPT(bool, confirm_conf, always);
132  	TEST_MALLCTL_OPT(const char *, metadata_thp, always);
133  	TEST_MALLCTL_OPT(bool, retain, always);
134  	TEST_MALLCTL_OPT(const char *, dss, always);
135  	TEST_MALLCTL_OPT(unsigned, narenas, always);
136  	TEST_MALLCTL_OPT(const char *, percpu_arena, always);
137  	TEST_MALLCTL_OPT(size_t, oversize_threshold, always);
138  	TEST_MALLCTL_OPT(bool, background_thread, always);
139  	TEST_MALLCTL_OPT(ssize_t, dirty_decay_ms, always);
140  	TEST_MALLCTL_OPT(ssize_t, muzzy_decay_ms, always);
141  	TEST_MALLCTL_OPT(bool, stats_print, always);
142  	TEST_MALLCTL_OPT(const char *, junk, fill);
143  	TEST_MALLCTL_OPT(bool, zero, fill);
144  	TEST_MALLCTL_OPT(bool, utrace, utrace);
145  	TEST_MALLCTL_OPT(bool, xmalloc, xmalloc);
146  	TEST_MALLCTL_OPT(bool, tcache, always);
147  	TEST_MALLCTL_OPT(size_t, lg_extent_max_active_fit, always);
148  	TEST_MALLCTL_OPT(size_t, lg_tcache_max, always);
149  	TEST_MALLCTL_OPT(const char *, thp, always);
150  	TEST_MALLCTL_OPT(bool, prof, prof);
151  	TEST_MALLCTL_OPT(const char *, prof_prefix, prof);
152  	TEST_MALLCTL_OPT(bool, prof_active, prof);
153  	TEST_MALLCTL_OPT(ssize_t, lg_prof_sample, prof);
154  	TEST_MALLCTL_OPT(bool, prof_accum, prof);
155  	TEST_MALLCTL_OPT(ssize_t, lg_prof_interval, prof);
156  	TEST_MALLCTL_OPT(bool, prof_gdump, prof);
157  	TEST_MALLCTL_OPT(bool, prof_final, prof);
158  	TEST_MALLCTL_OPT(bool, prof_leak, prof);
159  #undef TEST_MALLCTL_OPT
160  }
161  TEST_END
162  TEST_BEGIN(test_manpage_example) {
163  	unsigned nbins, i;
164  	size_t mib[4];
165  	size_t len, miblen;
166  	len = sizeof(nbins);
167  	assert_d_eq(mallctl(&quot;arenas.nbins&quot;, (void *)&amp;nbins, &amp;len, NULL, 0), 0,
168  	    &quot;Unexpected mallctl() failure&quot;);
169  	miblen = 4;
170  	assert_d_eq(mallctlnametomib(&quot;arenas.bin.0.size&quot;, mib, &amp;miblen), 0,
171  	    &quot;Unexpected mallctlnametomib() failure&quot;);
172  	for (i = 0; i &lt; nbins; i++) {
173  		size_t bin_size;
174  		mib[2] = i;
175  		len = sizeof(bin_size);
176  		assert_d_eq(mallctlbymib(mib, miblen, (void *)&amp;bin_size, &amp;len,
177  		    NULL, 0), 0, &quot;Unexpected mallctlbymib() failure&quot;);
178  	}
179  }
180  TEST_END
181  TEST_BEGIN(test_tcache_none) {
182  	test_skip_if(!opt_tcache);
183  	void *p0 = mallocx(42, 0);
184  	assert_ptr_not_null(p0, &quot;Unexpected mallocx() failure&quot;);
185  	void *q = mallocx(42, 0);
186  	assert_ptr_not_null(q, &quot;Unexpected mallocx() failure&quot;);
187  	dallocx(p0, 0);
188  	dallocx(q, MALLOCX_TCACHE_NONE);
189  	void *p1 = mallocx(42, 0);
190  	assert_ptr_not_null(p1, &quot;Unexpected mallocx() failure&quot;);
191  	assert_ptr_eq(p0, p1, &quot;Expected tcache to allocate cached region&quot;);
192  	dallocx(p1, MALLOCX_TCACHE_NONE);
193  }
194  TEST_END
195  TEST_BEGIN(test_tcache) {
196  #define NTCACHES	10
197  	unsigned tis[NTCACHES];
198  	void *ps[NTCACHES];
199  	void *qs[NTCACHES];
200  	unsigned i;
201  	size_t sz, psz, qsz;
202  	psz = 42;
203  	qsz = nallocx(psz, 0) + 1;
204  	for (i = 0; i &lt; NTCACHES; i++) {
205  		sz = sizeof(unsigned);
206  		assert_d_eq(mallctl(&quot;tcache.create&quot;, (void *)&amp;tis[i], &amp;sz, NULL,
207  		    0), 0, &quot;Unexpected mallctl() failure, i=%u&quot;, i);
208  	}
209  	for (i = 0; i &lt; NTCACHES; i++) {
210  		assert_d_eq(mallctl(&quot;tcache.destroy&quot;, NULL, NULL,
211  		    (void *)&amp;tis[i], sizeof(unsigned)), 0,
212  		    &quot;Unexpected mallctl() failure, i=%u&quot;, i);
213  	}
214  	for (i = 0; i &lt; NTCACHES; i++) {
215  		sz = sizeof(unsigned);
216  		assert_d_eq(mallctl(&quot;tcache.create&quot;, (void *)&amp;tis[i], &amp;sz, NULL,
217  		    0), 0, &quot;Unexpected mallctl() failure, i=%u&quot;, i);
218  	}
219  	for (i = 0; i &lt; NTCACHES; i++) {
220  		assert_d_eq(mallctl(&quot;tcache.flush&quot;, NULL, NULL, (void *)&amp;tis[i],
221  		    sizeof(unsigned)), 0, &quot;Unexpected mallctl() failure, i=%u&quot;,
222  		    i);
223  	}
224  	for (i = 0; i &lt; NTCACHES; i++) {
225  		ps[i] = mallocx(psz, MALLOCX_TCACHE(tis[i]));
226  		assert_ptr_not_null(ps[i], &quot;Unexpected mallocx() failure, i=%u&quot;,
227  		    i);
228  		dallocx(ps[i], MALLOCX_TCACHE(tis[i]));
229  		qs[i] = mallocx(qsz, MALLOCX_TCACHE(tis[i]));
230  		assert_ptr_not_null(qs[i], &quot;Unexpected mallocx() failure, i=%u&quot;,
231  		    i);
232  		dallocx(qs[i], MALLOCX_TCACHE(tis[i]));
233  	}
234  	for (i = 0; i &lt; NTCACHES; i++) {
235  		void *p0 = ps[i];
236  		ps[i] = mallocx(psz, MALLOCX_TCACHE(tis[i]));
237  		assert_ptr_not_null(ps[i], &quot;Unexpected mallocx() failure, i=%u&quot;,
238  		    i);
239  		assert_ptr_eq(ps[i], p0,
240  		    &quot;Expected mallocx() to allocate cached region, i=%u&quot;, i);
241  	}
242  	for (i = 0; i &lt; NTCACHES; i++) {
243  		void *q0 = qs[i];
244  		qs[i] = rallocx(ps[i], qsz, MALLOCX_TCACHE(tis[i]));
245  		assert_ptr_not_null(qs[i], &quot;Unexpected rallocx() failure, i=%u&quot;,
246  		    i);
247  		assert_ptr_eq(qs[i], q0,
248  		    &quot;Expected rallocx() to allocate cached region, i=%u&quot;, i);
249  		if (qs[i] == NULL) {
250  			qs[i] = ps[i];
251  		}
252  	}
253  	for (i = 0; i &lt; NTCACHES; i++) {
254  		dallocx(qs[i], MALLOCX_TCACHE(tis[i]));
255  	}
256  	for (i = 0; i &lt; NTCACHES/2; i++) {
257  		assert_d_eq(mallctl(&quot;tcache.flush&quot;, NULL, NULL, (void *)&amp;tis[i],
258  		    sizeof(unsigned)), 0, &quot;Unexpected mallctl() failure, i=%u&quot;,
259  		    i);
260  	}
261  	for (i = 0; i &lt; NTCACHES; i++) {
262  		assert_d_eq(mallctl(&quot;tcache.destroy&quot;, NULL, NULL,
263  		    (void *)&amp;tis[i], sizeof(unsigned)), 0,
264  		    &quot;Unexpected mallctl() failure, i=%u&quot;, i);
265  	}
266  }
267  TEST_END
268  TEST_BEGIN(test_thread_arena) {
269  	unsigned old_arena_ind, new_arena_ind, narenas;
270  	const char *opa;
271  	size_t sz = sizeof(opa);
272  	assert_d_eq(mallctl(&quot;opt.percpu_arena&quot;, (void *)&amp;opa, &amp;sz, NULL, 0), 0,
273  	    &quot;Unexpected mallctl() failure&quot;);
274  	sz = sizeof(unsigned);
275  	assert_d_eq(mallctl(&quot;arenas.narenas&quot;, (void *)&amp;narenas, &amp;sz, NULL, 0),
276  	    0, &quot;Unexpected mallctl() failure&quot;);
277  	if (opt_oversize_threshold != 0) {
278  		narenas--;
279  	}
280  	assert_u_eq(narenas, opt_narenas, &quot;Number of arenas incorrect&quot;);
281  	if (strcmp(opa, &quot;disabled&quot;) == 0) {
282  		new_arena_ind = narenas - 1;
283  		assert_d_eq(mallctl(&quot;thread.arena&quot;, (void *)&amp;old_arena_ind, &amp;sz,
284  		    (void *)&amp;new_arena_ind, sizeof(unsigned)), 0,
285  		    &quot;Unexpected mallctl() failure&quot;);
286  		new_arena_ind = 0;
287  		assert_d_eq(mallctl(&quot;thread.arena&quot;, (void *)&amp;old_arena_ind, &amp;sz,
288  		    (void *)&amp;new_arena_ind, sizeof(unsigned)), 0,
289  		    &quot;Unexpected mallctl() failure&quot;);
290  	} else {
291  		assert_d_eq(mallctl(&quot;thread.arena&quot;, (void *)&amp;old_arena_ind, &amp;sz,
292  		    NULL, 0), 0, &quot;Unexpected mallctl() failure&quot;);
293  		new_arena_ind = percpu_arena_ind_limit(opt_percpu_arena) - 1;
294  		if (old_arena_ind != new_arena_ind) {
295  			assert_d_eq(mallctl(&quot;thread.arena&quot;,
296  			    (void *)&amp;old_arena_ind, &amp;sz, (void *)&amp;new_arena_ind,
297  			    sizeof(unsigned)), EPERM, &quot;thread.arena ctl &quot;
298  			    &quot;should not be allowed with percpu arena&quot;);
299  		}
300  	}
301  }
302  TEST_END
303  TEST_BEGIN(test_arena_i_initialized) {
304  	unsigned narenas, i;
305  	size_t sz;
306  	size_t mib[3];
307  	size_t miblen = sizeof(mib) / sizeof(size_t);
308  	bool initialized;
309  	sz = sizeof(narenas);
310  	assert_d_eq(mallctl(&quot;arenas.narenas&quot;, (void *)&amp;narenas, &amp;sz, NULL, 0),
311  	    0, &quot;Unexpected mallctl() failure&quot;);
312  	assert_d_eq(mallctlnametomib(&quot;arena.0.initialized&quot;, mib, &amp;miblen), 0,
313  	    &quot;Unexpected mallctlnametomib() failure&quot;);
314  	for (i = 0; i &lt; narenas; i++) {
315  		mib[1] = i;
316  		sz = sizeof(initialized);
317  		assert_d_eq(mallctlbymib(mib, miblen, &amp;initialized, &amp;sz, NULL,
318  		    0), 0, &quot;Unexpected mallctl() failure&quot;);
319  	}
320  	mib[1] = MALLCTL_ARENAS_ALL;
321  	sz = sizeof(initialized);
322  	assert_d_eq(mallctlbymib(mib, miblen, &amp;initialized, &amp;sz, NULL, 0), 0,
323  	    &quot;Unexpected mallctl() failure&quot;);
324  	assert_true(initialized,
325  	    &quot;Merged arena statistics should always be initialized&quot;);
326  	sz = sizeof(initialized);
327  	assert_d_eq(mallctl(
328  	    &quot;arena.&quot; STRINGIFY(MALLCTL_ARENAS_ALL) &quot;.initialized&quot;,
329  	    (void *)&amp;initialized, &amp;sz, NULL, 0), 0,
330  	    &quot;Unexpected mallctl() failure&quot;);
331  	assert_true(initialized,
332  	    &quot;Merged arena statistics should always be initialized&quot;);
333  }
334  TEST_END
335  TEST_BEGIN(test_arena_i_dirty_decay_ms) {
336  	ssize_t dirty_decay_ms, orig_dirty_decay_ms, prev_dirty_decay_ms;
337  	size_t sz = sizeof(ssize_t);
338  	assert_d_eq(mallctl(&quot;arena.0.dirty_decay_ms&quot;,
339  	    (void *)&amp;orig_dirty_decay_ms, &amp;sz, NULL, 0), 0,
340  	    &quot;Unexpected mallctl() failure&quot;);
341  	dirty_decay_ms = -2;
342  	assert_d_eq(mallctl(&quot;arena.0.dirty_decay_ms&quot;, NULL, NULL,
343  	    (void *)&amp;dirty_decay_ms, sizeof(ssize_t)), EFAULT,
344  	    &quot;Unexpected mallctl() success&quot;);
345  	dirty_decay_ms = 0x7fffffff;
346  	assert_d_eq(mallctl(&quot;arena.0.dirty_decay_ms&quot;, NULL, NULL,
347  	    (void *)&amp;dirty_decay_ms, sizeof(ssize_t)), 0,
348  	    &quot;Unexpected mallctl() failure&quot;);
349  	for (prev_dirty_decay_ms = dirty_decay_ms, dirty_decay_ms = -1;
350  	    dirty_decay_ms &lt; 20; prev_dirty_decay_ms = dirty_decay_ms,
351  	    dirty_decay_ms++) {
352  		ssize_t old_dirty_decay_ms;
353  		assert_d_eq(mallctl(&quot;arena.0.dirty_decay_ms&quot;,
354  		    (void *)&amp;old_dirty_decay_ms, &amp;sz, (void *)&amp;dirty_decay_ms,
355  		    sizeof(ssize_t)), 0, &quot;Unexpected mallctl() failure&quot;);
356  		assert_zd_eq(old_dirty_decay_ms, prev_dirty_decay_ms,
357  		    &quot;Unexpected old arena.0.dirty_decay_ms&quot;);
358  	}
359  }
360  TEST_END
361  TEST_BEGIN(test_arena_i_muzzy_decay_ms) {
362  	ssize_t muzzy_decay_ms, orig_muzzy_decay_ms, prev_muzzy_decay_ms;
363  	size_t sz = sizeof(ssize_t);
364  	assert_d_eq(mallctl(&quot;arena.0.muzzy_decay_ms&quot;,
365  	    (void *)&amp;orig_muzzy_decay_ms, &amp;sz, NULL, 0), 0,
366  	    &quot;Unexpected mallctl() failure&quot;);
367  	muzzy_decay_ms = -2;
368  	assert_d_eq(mallctl(&quot;arena.0.muzzy_decay_ms&quot;, NULL, NULL,
369  	    (void *)&amp;muzzy_decay_ms, sizeof(ssize_t)), EFAULT,
370  	    &quot;Unexpected mallctl() success&quot;);
371  	muzzy_decay_ms = 0x7fffffff;
372  	assert_d_eq(mallctl(&quot;arena.0.muzzy_decay_ms&quot;, NULL, NULL,
373  	    (void *)&amp;muzzy_decay_ms, sizeof(ssize_t)), 0,
374  	    &quot;Unexpected mallctl() failure&quot;);
375  	for (prev_muzzy_decay_ms = muzzy_decay_ms, muzzy_decay_ms = -1;
376  	    muzzy_decay_ms &lt; 20; prev_muzzy_decay_ms = muzzy_decay_ms,
377  	    muzzy_decay_ms++) {
378  		ssize_t old_muzzy_decay_ms;
379  		assert_d_eq(mallctl(&quot;arena.0.muzzy_decay_ms&quot;,
380  		    (void *)&amp;old_muzzy_decay_ms, &amp;sz, (void *)&amp;muzzy_decay_ms,
381  		    sizeof(ssize_t)), 0, &quot;Unexpected mallctl() failure&quot;);
382  		assert_zd_eq(old_muzzy_decay_ms, prev_muzzy_decay_ms,
383  		    &quot;Unexpected old arena.0.muzzy_decay_ms&quot;);
384  	}
385  }
386  TEST_END
387  TEST_BEGIN(test_arena_i_purge) {
388  	unsigned narenas;
389  	size_t sz = sizeof(unsigned);
390  	size_t mib[3];
391  	size_t miblen = 3;
392  	assert_d_eq(mallctl(&quot;arena.0.purge&quot;, NULL, NULL, NULL, 0), 0,
393  	    &quot;Unexpected mallctl() failure&quot;);
394  	assert_d_eq(mallctl(&quot;arenas.narenas&quot;, (void *)&amp;narenas, &amp;sz, NULL, 0),
395  	    0, &quot;Unexpected mallctl() failure&quot;);
396  	assert_d_eq(mallctlnametomib(&quot;arena.0.purge&quot;, mib, &amp;miblen), 0,
397  	    &quot;Unexpected mallctlnametomib() failure&quot;);
398  	mib[1] = narenas;
399  	assert_d_eq(mallctlbymib(mib, miblen, NULL, NULL, NULL, 0), 0,
400  	    &quot;Unexpected mallctlbymib() failure&quot;);
401  	mib[1] = MALLCTL_ARENAS_ALL;
402  	assert_d_eq(mallctlbymib(mib, miblen, NULL, NULL, NULL, 0), 0,
403  	    &quot;Unexpected mallctlbymib() failure&quot;);
404  }
405  TEST_END
406  TEST_BEGIN(test_arena_i_decay) {
407  	unsigned narenas;
408  	size_t sz = sizeof(unsigned);
409  	size_t mib[3];
410  	size_t miblen = 3;
411  	assert_d_eq(mallctl(&quot;arena.0.decay&quot;, NULL, NULL, NULL, 0), 0,
412  	    &quot;Unexpected mallctl() failure&quot;);
413  	assert_d_eq(mallctl(&quot;arenas.narenas&quot;, (void *)&amp;narenas, &amp;sz, NULL, 0),
414  	    0, &quot;Unexpected mallctl() failure&quot;);
415  	assert_d_eq(mallctlnametomib(&quot;arena.0.decay&quot;, mib, &amp;miblen), 0,
416  	    &quot;Unexpected mallctlnametomib() failure&quot;);
417  	mib[1] = narenas;
418  	assert_d_eq(mallctlbymib(mib, miblen, NULL, NULL, NULL, 0), 0,
419  	    &quot;Unexpected mallctlbymib() failure&quot;);
420  	mib[1] = MALLCTL_ARENAS_ALL;
421  	assert_d_eq(mallctlbymib(mib, miblen, NULL, NULL, NULL, 0), 0,
422  	    &quot;Unexpected mallctlbymib() failure&quot;);
423  }
424  TEST_END
425  TEST_BEGIN(test_arena_i_dss) {
426  	const char *dss_prec_old, *dss_prec_new;
427  	size_t sz = sizeof(dss_prec_old);
428  	size_t mib[3];
429  	size_t miblen;
430  	miblen = sizeof(mib)/sizeof(size_t);
431  	assert_d_eq(mallctlnametomib(&quot;arena.0.dss&quot;, mib, &amp;miblen), 0,
432  	    &quot;Unexpected mallctlnametomib() error&quot;);
433  	dss_prec_new = &quot;disabled&quot;;
434  	assert_d_eq(mallctlbymib(mib, miblen, (void *)&amp;dss_prec_old, &amp;sz,
435  	    (void *)&amp;dss_prec_new, sizeof(dss_prec_new)), 0,
436  	    &quot;Unexpected mallctl() failure&quot;);
437  	assert_str_ne(dss_prec_old, &quot;primary&quot;,
438  	    &quot;Unexpected default for dss precedence&quot;);
439  	assert_d_eq(mallctlbymib(mib, miblen, (void *)&amp;dss_prec_new, &amp;sz,
440  	    (void *)&amp;dss_prec_old, sizeof(dss_prec_old)), 0,
441  	    &quot;Unexpected mallctl() failure&quot;);
442  	assert_d_eq(mallctlbymib(mib, miblen, (void *)&amp;dss_prec_old, &amp;sz, NULL,
443  	    0), 0, &quot;Unexpected mallctl() failure&quot;);
444  	assert_str_ne(dss_prec_old, &quot;primary&quot;,
445  	    &quot;Unexpected value for dss precedence&quot;);
446  	mib[1] = narenas_total_get();
447  	dss_prec_new = &quot;disabled&quot;;
448  	assert_d_eq(mallctlbymib(mib, miblen, (void *)&amp;dss_prec_old, &amp;sz,
449  	    (void *)&amp;dss_prec_new, sizeof(dss_prec_new)), 0,
450  	    &quot;Unexpected mallctl() failure&quot;);
451  	assert_str_ne(dss_prec_old, &quot;primary&quot;,
452  	    &quot;Unexpected default for dss precedence&quot;);
453  	assert_d_eq(mallctlbymib(mib, miblen, (void *)&amp;dss_prec_new, &amp;sz,
454  	    (void *)&amp;dss_prec_old, sizeof(dss_prec_new)), 0,
455  	    &quot;Unexpected mallctl() failure&quot;);
456  	assert_d_eq(mallctlbymib(mib, miblen, (void *)&amp;dss_prec_old, &amp;sz, NULL,
457  	    0), 0, &quot;Unexpected mallctl() failure&quot;);
458  	assert_str_ne(dss_prec_old, &quot;primary&quot;,
459  	    &quot;Unexpected value for dss precedence&quot;);
460  }
461  TEST_END
462  TEST_BEGIN(test_arena_i_retain_grow_limit) {
463  	size_t old_limit, new_limit, default_limit;
464  	size_t mib[3];
465  	size_t miblen;
466  	bool retain_enabled;
467  	size_t sz = sizeof(retain_enabled);
468  	assert_d_eq(mallctl(&quot;opt.retain&quot;, &amp;retain_enabled, &amp;sz, NULL, 0),
469  	    0, &quot;Unexpected mallctl() failure&quot;);
470  	test_skip_if(!retain_enabled);
471  	sz = sizeof(default_limit);
472  	miblen = sizeof(mib)/sizeof(size_t);
473  	assert_d_eq(mallctlnametomib(&quot;arena.0.retain_grow_limit&quot;, mib, &amp;miblen),
474  	    0, &quot;Unexpected mallctlnametomib() error&quot;);
475  	assert_d_eq(mallctlbymib(mib, miblen, &amp;default_limit, &amp;sz, NULL, 0), 0,
476  	    &quot;Unexpected mallctl() failure&quot;);
477  	assert_zu_eq(default_limit, SC_LARGE_MAXCLASS,
478  	    &quot;Unexpected default for retain_grow_limit&quot;);
479  	new_limit = PAGE - 1;
480  	assert_d_eq(mallctlbymib(mib, miblen, NULL, NULL, &amp;new_limit,
481  	    sizeof(new_limit)), EFAULT, &quot;Unexpected mallctl() success&quot;);
482  	new_limit = PAGE + 1;
483  	assert_d_eq(mallctlbymib(mib, miblen, NULL, NULL, &amp;new_limit,
484  	    sizeof(new_limit)), 0, &quot;Unexpected mallctl() failure&quot;);
485  	assert_d_eq(mallctlbymib(mib, miblen, &amp;old_limit, &amp;sz, NULL, 0), 0,
486  	    &quot;Unexpected mallctl() failure&quot;);
487  	assert_zu_eq(old_limit, PAGE,
488  	    &quot;Unexpected value for retain_grow_limit&quot;);
489  	new_limit = sz_pind2sz(10) - 1;
490  	assert_d_eq(mallctlbymib(mib, miblen, NULL, NULL, &amp;new_limit,
491  	    sizeof(new_limit)), 0, &quot;Unexpected mallctl() failure&quot;);
492  	assert_d_eq(mallctlbymib(mib, miblen, &amp;old_limit, &amp;sz, NULL, 0), 0,
493  	    &quot;Unexpected mallctl() failure&quot;);
494  	assert_zu_eq(old_limit, sz_pind2sz(9),
495  	    &quot;Unexpected value for retain_grow_limit&quot;);
496  	assert_d_eq(mallctlbymib(mib, miblen, NULL, NULL, &amp;default_limit,
497  	    sizeof(default_limit)), 0, &quot;Unexpected mallctl() failure&quot;);
498  }
499  TEST_END
500  TEST_BEGIN(test_arenas_dirty_decay_ms) {
501  	ssize_t dirty_decay_ms, orig_dirty_decay_ms, prev_dirty_decay_ms;
502  	size_t sz = sizeof(ssize_t);
503  	assert_d_eq(mallctl(&quot;arenas.dirty_decay_ms&quot;,
504  	    (void *)&amp;orig_dirty_decay_ms, &amp;sz, NULL, 0), 0,
505  	    &quot;Unexpected mallctl() failure&quot;);
506  	dirty_decay_ms = -2;
507  	assert_d_eq(mallctl(&quot;arenas.dirty_decay_ms&quot;, NULL, NULL,
508  	    (void *)&amp;dirty_decay_ms, sizeof(ssize_t)), EFAULT,
509  	    &quot;Unexpected mallctl() success&quot;);
510  	dirty_decay_ms = 0x7fffffff;
511  	assert_d_eq(mallctl(&quot;arenas.dirty_decay_ms&quot;, NULL, NULL,
512  	    (void *)&amp;dirty_decay_ms, sizeof(ssize_t)), 0,
513  	    &quot;Expected mallctl() failure&quot;);
514  	for (prev_dirty_decay_ms = dirty_decay_ms, dirty_decay_ms = -1;
515  	    dirty_decay_ms &lt; 20; prev_dirty_decay_ms = dirty_decay_ms,
516  	    dirty_decay_ms++) {
517  		ssize_t old_dirty_decay_ms;
518  		assert_d_eq(mallctl(&quot;arenas.dirty_decay_ms&quot;,
519  		    (void *)&amp;old_dirty_decay_ms, &amp;sz, (void *)&amp;dirty_decay_ms,
520  		    sizeof(ssize_t)), 0, &quot;Unexpected mallctl() failure&quot;);
521  		assert_zd_eq(old_dirty_decay_ms, prev_dirty_decay_ms,
522  		    &quot;Unexpected old arenas.dirty_decay_ms&quot;);
523  	}
524  }
525  TEST_END
526  TEST_BEGIN(test_arenas_muzzy_decay_ms) {
527  	ssize_t muzzy_decay_ms, orig_muzzy_decay_ms, prev_muzzy_decay_ms;
528  	size_t sz = sizeof(ssize_t);
529  	assert_d_eq(mallctl(&quot;arenas.muzzy_decay_ms&quot;,
530  	    (void *)&amp;orig_muzzy_decay_ms, &amp;sz, NULL, 0), 0,
531  	    &quot;Unexpected mallctl() failure&quot;);
532  	muzzy_decay_ms = -2;
533  	assert_d_eq(mallctl(&quot;arenas.muzzy_decay_ms&quot;, NULL, NULL,
534  	    (void *)&amp;muzzy_decay_ms, sizeof(ssize_t)), EFAULT,
535  	    &quot;Unexpected mallctl() success&quot;);
536  	muzzy_decay_ms = 0x7fffffff;
537  	assert_d_eq(mallctl(&quot;arenas.muzzy_decay_ms&quot;, NULL, NULL,
538  	    (void *)&amp;muzzy_decay_ms, sizeof(ssize_t)), 0,
539  	    &quot;Expected mallctl() failure&quot;);
540  	for (prev_muzzy_decay_ms = muzzy_decay_ms, muzzy_decay_ms = -1;
541  	    muzzy_decay_ms &lt; 20; prev_muzzy_decay_ms = muzzy_decay_ms,
542  	    muzzy_decay_ms++) {
543  		ssize_t old_muzzy_decay_ms;
544  		assert_d_eq(mallctl(&quot;arenas.muzzy_decay_ms&quot;,
545  		    (void *)&amp;old_muzzy_decay_ms, &amp;sz, (void *)&amp;muzzy_decay_ms,
546  		    sizeof(ssize_t)), 0, &quot;Unexpected mallctl() failure&quot;);
<span onclick='openModal()' class='match'>547  		assert_zd_eq(old_muzzy_decay_ms, prev_muzzy_decay_ms,
548  		    &quot;Unexpected old arenas.muzzy_decay_ms&quot;);
549  	}
550  }
551  TEST_END
552  TEST_BEGIN(test_arenas_constants) {
553  #define TEST_ARENAS_CONSTANT(t, name, expected) do {			\
</span>554  	t name;								\
555  	size_t sz = sizeof(t);						\
556  	assert_d_eq(mallctl(&quot;arenas.&quot;#name, (void *)&amp;name, &amp;sz, NULL,	\
557  	    0), 0, &quot;Unexpected mallctl() failure&quot;);			\
558  	assert_zu_eq(name, expected, &quot;Incorrect &quot;#name&quot; size&quot;);		\
559  } while (0)
560  	TEST_ARENAS_CONSTANT(size_t, quantum, QUANTUM);
561  	TEST_ARENAS_CONSTANT(size_t, page, PAGE);
562  	TEST_ARENAS_CONSTANT(unsigned, nbins, SC_NBINS);
563  	TEST_ARENAS_CONSTANT(unsigned, nlextents, SC_NSIZES - SC_NBINS);
564  #undef TEST_ARENAS_CONSTANT
565  }
566  TEST_END
567  TEST_BEGIN(test_arenas_bin_constants) {
568  #define TEST_ARENAS_BIN_CONSTANT(t, name, expected) do {		\
569  	t name;								\
570  	size_t sz = sizeof(t);						\
571  	assert_d_eq(mallctl(&quot;arenas.bin.0.&quot;#name, (void *)&amp;name, &amp;sz,	\
572  	    NULL, 0), 0, &quot;Unexpected mallctl() failure&quot;);		\
573  	assert_zu_eq(name, expected, &quot;Incorrect &quot;#name&quot; size&quot;);		\
574  } while (0)
575  	TEST_ARENAS_BIN_CONSTANT(size_t, size, bin_infos[0].reg_size);
576  	TEST_ARENAS_BIN_CONSTANT(uint32_t, nregs, bin_infos[0].nregs);
577  	TEST_ARENAS_BIN_CONSTANT(size_t, slab_size,
578  	    bin_infos[0].slab_size);
579  	TEST_ARENAS_BIN_CONSTANT(uint32_t, nshards, bin_infos[0].n_shards);
580  #undef TEST_ARENAS_BIN_CONSTANT
581  }
582  TEST_END
583  TEST_BEGIN(test_arenas_lextent_constants) {
584  #define TEST_ARENAS_LEXTENT_CONSTANT(t, name, expected) do {		\
585  	t name;								\
586  	size_t sz = sizeof(t);						\
587  	assert_d_eq(mallctl(&quot;arenas.lextent.0.&quot;#name, (void *)&amp;name,	\
588  	    &amp;sz, NULL, 0), 0, &quot;Unexpected mallctl() failure&quot;);		\
589  	assert_zu_eq(name, expected, &quot;Incorrect &quot;#name&quot; size&quot;);		\
590  } while (0)
591  	TEST_ARENAS_LEXTENT_CONSTANT(size_t, size,
592  	    SC_LARGE_MINCLASS);
593  #undef TEST_ARENAS_LEXTENT_CONSTANT
594  }
595  TEST_END
596  TEST_BEGIN(test_arenas_create) {
597  	unsigned narenas_before, arena, narenas_after;
598  	size_t sz = sizeof(unsigned);
599  	assert_d_eq(mallctl(&quot;arenas.narenas&quot;, (void *)&amp;narenas_before, &amp;sz,
600  	    NULL, 0), 0, &quot;Unexpected mallctl() failure&quot;);
601  	assert_d_eq(mallctl(&quot;arenas.create&quot;, (void *)&amp;arena, &amp;sz, NULL, 0), 0,
602  	    &quot;Unexpected mallctl() failure&quot;);
603  	assert_d_eq(mallctl(&quot;arenas.narenas&quot;, (void *)&amp;narenas_after, &amp;sz, NULL,
604  	    0), 0, &quot;Unexpected mallctl() failure&quot;);
605  	assert_u_eq(narenas_before+1, narenas_after,
606  	    &quot;Unexpected number of arenas before versus after extension&quot;);
607  	assert_u_eq(arena, narenas_after-1, &quot;Unexpected arena index&quot;);
608  }
609  TEST_END
610  TEST_BEGIN(test_arenas_lookup) {
611  	unsigned arena, arena1;
612  	void *ptr;
613  	size_t sz = sizeof(unsigned);
614  	assert_d_eq(mallctl(&quot;arenas.create&quot;, (void *)&amp;arena, &amp;sz, NULL, 0), 0,
615  	    &quot;Unexpected mallctl() failure&quot;);
616  	ptr = mallocx(42, MALLOCX_ARENA(arena) | MALLOCX_TCACHE_NONE);
617  	assert_ptr_not_null(ptr, &quot;Unexpected mallocx() failure&quot;);
618  	assert_d_eq(mallctl(&quot;arenas.lookup&quot;, &amp;arena1, &amp;sz, &amp;ptr, sizeof(ptr)),
619  	    0, &quot;Unexpected mallctl() failure&quot;);
620  	assert_u_eq(arena, arena1, &quot;Unexpected arena index&quot;);
621  	dallocx(ptr, 0);
622  }
623  TEST_END
624  TEST_BEGIN(test_stats_arenas) {
625  #define TEST_STATS_ARENAS(t, name) do {					\
626  	t name;								\
627  	size_t sz = sizeof(t);						\
628  	assert_d_eq(mallctl(&quot;stats.arenas.0.&quot;#name, (void *)&amp;name, &amp;sz,	\
629  	    NULL, 0), 0, &quot;Unexpected mallctl() failure&quot;);		\
630  } while (0)
631  	TEST_STATS_ARENAS(unsigned, nthreads);
632  	TEST_STATS_ARENAS(const char *, dss);
633  	TEST_STATS_ARENAS(ssize_t, dirty_decay_ms);
634  	TEST_STATS_ARENAS(ssize_t, muzzy_decay_ms);
635  	TEST_STATS_ARENAS(size_t, pactive);
636  	TEST_STATS_ARENAS(size_t, pdirty);
637  #undef TEST_STATS_ARENAS
638  }
639  TEST_END
640  static void
641  alloc_hook(void *extra, UNUSED hook_alloc_t type, UNUSED void *result,
642      UNUSED uintptr_t result_raw, UNUSED uintptr_t args_raw[3]) {
643  	*(bool *)extra = true;
644  }
645  static void
646  dalloc_hook(void *extra, UNUSED hook_dalloc_t type,
647      UNUSED void *address, UNUSED uintptr_t args_raw[3]) {
648  	*(bool *)extra = true;
649  }
650  TEST_BEGIN(test_hooks) {
651  	bool hook_called = false;
652  	hooks_t hooks = {&amp;alloc_hook, &amp;dalloc_hook, NULL, &amp;hook_called};
653  	void *handle = NULL;
654  	size_t sz = sizeof(handle);
655  	int err = mallctl(&quot;experimental.hooks.install&quot;, &amp;handle, &amp;sz, &amp;hooks,
656  	    sizeof(hooks));
657  	assert_d_eq(err, 0, &quot;Hook installation failed&quot;);
658  	assert_ptr_ne(handle, NULL, &quot;Hook installation gave null handle&quot;);
659  	void *ptr = mallocx(1, 0);
660  	assert_true(hook_called, &quot;Alloc hook not called&quot;);
661  	hook_called = false;
662  	free(ptr);
663  	assert_true(hook_called, &quot;Free hook not called&quot;);
664  	err = mallctl(&quot;experimental.hooks.remove&quot;, NULL, NULL, &amp;handle,
665  	    sizeof(handle));
666  	assert_d_eq(err, 0, &quot;Hook removal failed&quot;);
667  	hook_called = false;
668  	ptr = mallocx(1, 0);
669  	free(ptr);
670  	assert_false(hook_called, &quot;Hook called after removal&quot;);
671  }
672  TEST_END
673  TEST_BEGIN(test_hooks_exhaustion) {
674  	bool hook_called = false;
675  	hooks_t hooks = {&amp;alloc_hook, &amp;dalloc_hook, NULL, &amp;hook_called};
676  	void *handle;
677  	void *handles[HOOK_MAX];
678  	size_t sz = sizeof(handle);
679  	int err;
680  	for (int i = 0; i &lt; HOOK_MAX; i++) {
681  		handle = NULL;
682  		err = mallctl(&quot;experimental.hooks.install&quot;, &amp;handle, &amp;sz,
683  		    &amp;hooks, sizeof(hooks));
684  		assert_d_eq(err, 0, &quot;Error installation hooks&quot;);
685  		assert_ptr_ne(handle, NULL, &quot;Got NULL handle&quot;);
686  		handles[i] = handle;
687  	}
688  	err = mallctl(&quot;experimental.hooks.install&quot;, &amp;handle, &amp;sz, &amp;hooks,
689  	    sizeof(hooks));
690  	assert_d_eq(err, EAGAIN, &quot;Should have failed hook installation&quot;);
691  	for (int i = 0; i &lt; HOOK_MAX; i++) {
692  		err = mallctl(&quot;experimental.hooks.remove&quot;, NULL, NULL,
693  		    &amp;handles[i], sizeof(handles[i]));
694  		assert_d_eq(err, 0, &quot;Hook removal failed&quot;);
695  	}
696  	handle = NULL;
697  	err = mallctl(&quot;experimental.hooks.install&quot;, &amp;handle, &amp;sz, &amp;hooks,
698  	    sizeof(hooks));
699  	assert_d_eq(err, 0, &quot;Hook insertion failed&quot;);
700  	assert_ptr_ne(handle, NULL, &quot;Got NULL handle&quot;);
701  	err = mallctl(&quot;experimental.hooks.remove&quot;, NULL, NULL, &amp;handle,
702  	    sizeof(handle));
703  	assert_d_eq(err, 0, &quot;Hook removal failed&quot;);
704  }
705  TEST_END
706  int
707  main(void) {
708  	return test(
709  	    test_mallctl_errors,
710  	    test_mallctlnametomib_errors,
711  	    test_mallctlbymib_errors,
712  	    test_mallctl_read_write,
713  	    test_mallctlnametomib_short_mib,
714  	    test_mallctl_config,
715  	    test_mallctl_opt,
716  	    test_manpage_example,
717  	    test_tcache_none,
718  	    test_tcache,
719  	    test_thread_arena,
720  	    test_arena_i_initialized,
721  	    test_arena_i_dirty_decay_ms,
722  	    test_arena_i_muzzy_decay_ms,
723  	    test_arena_i_purge,
724  	    test_arena_i_decay,
725  	    test_arena_i_dss,
726  	    test_arena_i_retain_grow_limit,
727  	    test_arenas_dirty_decay_ms,
728  	    test_arenas_muzzy_decay_ms,
729  	    test_arenas_constants,
730  	    test_arenas_bin_constants,
731  	    test_arenas_lextent_constants,
732  	    test_arenas_create,
733  	    test_arenas_lookup,
734  	    test_stats_arenas,
735  	    test_hooks,
736  	    test_hooks_exhaustion);
737  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from redis-MDEwOlJlcG9zaXRvcnkxMDgxMTA3MDY=-flat-mallctl.c</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from redis-MDEwOlJlcG9zaXRvcnkxMDgxMTA3MDY=-flat-mallctl.c</div>
                </div>
                <div class="column column_space"><pre><code>521  		assert_zd_eq(old_dirty_decay_ms, prev_dirty_decay_ms,
522  		    &quot;Unexpected old arenas.dirty_decay_ms&quot;);
523  	}
524  }
525  TEST_END
526  TEST_BEGIN(test_arenas_muzzy_decay_ms) {
527  	ssize_t muzzy_decay_ms, orig_muzzy_decay_ms, prev_muzzy_decay_ms;
</pre></code></div>
                <div class="column column_space"><pre><code>547  		assert_zd_eq(old_muzzy_decay_ms, prev_muzzy_decay_ms,
548  		    &quot;Unexpected old arenas.muzzy_decay_ms&quot;);
549  	}
550  }
551  TEST_END
552  TEST_BEGIN(test_arenas_constants) {
553  #define TEST_ARENAS_CONSTANT(t, name, expected) do {			\
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    