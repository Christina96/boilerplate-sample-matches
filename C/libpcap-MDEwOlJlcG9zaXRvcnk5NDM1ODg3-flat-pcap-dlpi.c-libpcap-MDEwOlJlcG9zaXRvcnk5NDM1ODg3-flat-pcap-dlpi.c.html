
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 17, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>libpcap-MDEwOlJlcG9zaXRvcnk5NDM1ODg3-flat-pcap-dlpi.c</h3>
            <pre><code>1  #ifdef HAVE_CONFIG_H
2  #include <config.h>
3  #endif
4  #include <sys/types.h>
5  #include <sys/time.h>
6  #ifdef HAVE_SYS_BUFMOD_H
7  #include <sys/bufmod.h>
8  #endif
9  #include <sys/dlpi.h>
10  #ifdef HAVE_SYS_DLPI_EXT_H
11  #include <sys/dlpi_ext.h>
12  #endif
13  #ifdef HAVE_HPUX9
14  #include <sys/socket.h>
15  #endif
16  #ifdef DL_HP_PPA_REQ
17  #include <sys/stat.h>
18  #endif
19  #include <sys/stream.h>
20  #if defined(HAVE_SOLARIS) && defined(HAVE_SYS_BUFMOD_H)
21  #include <sys/systeminfo.h>
22  #endif
23  #ifdef HAVE_HPUX9
24  #include <net/if.h>
25  #endif
26  #ifdef HAVE_HPUX9
27  #include <nlist.h>
28  #endif
29  #include <errno.h>
30  #include <fcntl.h>
31  #include <memory.h>
32  #include <stdio.h>
33  #include <stdlib.h>
34  #include <string.h>
35  #include <stropts.h>
36  #include <unistd.h>
37  #include <limits.h>
38  #include "pcap-int.h"
39  #include "dlpisubs.h"
40  #ifdef HAVE_OS_PROTO_H
41  #include "os-proto.h"
42  #endif
43  #if defined(__hpux)
44    #define HAVE_DEV_DLPI
45  #elif defined(_AIX)
46    #define PCAP_DEV_PREFIX "/dev/dlpi"
47  #elif defined(HAVE_SOLARIS)
48    #define PCAP_DEV_PREFIX "/dev"
49  #endif
50  #define	MAXDLBUF	8192
51  static char *split_dname(char *, u_int *, char *);
52  static int dl_doattach(int, int, char *);
53  #ifdef DL_HP_RAWDLS
54  static int dl_dohpuxbind(int, char *);
55  #endif
56  static int dlpromiscon(pcap_t *, bpf_u_int32);
57  static int dlbindreq(int, bpf_u_int32, char *);
58  static int dlbindack(int, char *, char *, int *);
59  static int dlokack(int, const char *, char *, char *, int *);
60  static int dlinforeq(int, char *);
61  static int dlinfoack(int, char *, char *);
62  #ifdef HAVE_DL_PASSIVE_REQ_T
63  static void dlpassive(int, char *);
64  #endif
65  #ifdef DL_HP_RAWDLS
66  static int dlrawdatareq(int, const u_char *, int);
67  #endif
68  static int recv_ack(int, int, const char *, char *, char *, int *);
69  static char *dlstrerror(char *, size_t, bpf_u_int32);
70  static char *dlprim(char *, size_t, bpf_u_int32);
71  #if defined(HAVE_SOLARIS) && defined(HAVE_SYS_BUFMOD_H)
72  #define GET_RELEASE_BUFSIZE	32
73  static void get_release(char *, size_t, bpf_u_int32 *, bpf_u_int32 *,
74      bpf_u_int32 *);
75  #endif
76  static int send_request(int, char *, int, char *, char *);
77  #ifdef HAVE_HPUX9
78  static int dlpi_kread(int, off_t, void *, u_int, char *);
79  #endif
80  #ifdef HAVE_DEV_DLPI
81  static int get_dlpi_ppa(int, const char *, u_int, u_int *, char *);
82  #endif
83  #define MAKE_DL_PRIMITIVES(ptr)	((union DL_primitives *)(void *)(ptr))
84  static int
85  pcap_read_dlpi(pcap_t *p, int cnt, pcap_handler callback, u_char *user)
86  {
87  	int cc;
88  	u_char *bp;
89  	int flags;
90  	bpf_u_int32 ctlbuf[MAXDLBUF];
91  	struct strbuf ctl = {
92  		MAXDLBUF,
93  		0,
94  		(char *)ctlbuf
95  	};
96  	struct strbuf data;
97  	flags = 0;
98  	cc = p->cc;
99  	if (cc == 0) {
100  		data.buf = (char *)p->buffer + p->offset;
101  		data.maxlen = p->bufsize;
102  		data.len = 0;
103  		do {
104  			if (p->break_loop) {
105  				p->break_loop = 0;
106  				return (-2);
107  			}
108  			ctl.buf = (char *)ctlbuf;
109  			ctl.maxlen = MAXDLBUF;
110  			ctl.len = 0;
111  			if (getmsg(p->fd, &ctl, &data, &flags) < 0) {
112  				switch (errno) {
113  				case EINTR:
114  					cc = 0;
115  					continue;
116  				case EAGAIN:
117  					return (0);
118  				}
119  				pcap_fmt_errmsg_for_errno(p->errbuf,
120  				    sizeof(p->errbuf), errno, "getmsg");
121  				return (-1);
122  			}
123  			cc = data.len;
124  		} while (cc == 0);
125  		bp = p->buffer + p->offset;
126  	} else
127  		bp = p->bp;
128  	return (pcap_process_pkts(p, callback, user, cnt, bp, cc));
129  }
130  static int
131  pcap_inject_dlpi(pcap_t *p, const void *buf, int size)
132  {
133  #ifdef DL_HP_RAWDLS
134  	struct pcap_dlpi *pd = p->priv;
135  #endif
136  	int ret;
137  #if defined(DLIOCRAW)
138  	ret = write(p->fd, buf, size);
139  	if (ret == -1) {
140  		pcap_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,
141  		    errno, "send");
142  		return (-1);
143  	}
144  #elif defined(DL_HP_RAWDLS)
145  	if (pd->send_fd < 0) {
146  		snprintf(p->errbuf, PCAP_ERRBUF_SIZE,
147  		    "send: Output FD couldn't be opened");
148  		return (-1);
149  	}
150  	ret = dlrawdatareq(pd->send_fd, buf, size);
151  	if (ret == -1) {
152  		pcap_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,
153  		    errno, "send");
154  		return (-1);
155  	}
156  	ret = size;
157  #else &bsol;* no raw mode */
158  	pcap_strlcpy(p->errbuf, "send: Not supported on this version of this OS",
159  	    PCAP_ERRBUF_SIZE);
160  	ret = -1;
161  #endif &bsol;* raw mode */
162  	return (ret);
163  }
164  #ifndef DL_IPATM
165  #define DL_IPATM	0x12	&bsol;* ATM Classical IP interface */
166  #endif
167  #ifdef HAVE_SOLARIS
168  #ifndef A_GET_UNITS
169  #define A_GET_UNITS	(('A'<<8)|118)
170  #endif &bsol;* A_GET_UNITS */
171  #ifndef A_PROMISCON_REQ
172  #define A_PROMISCON_REQ	(('A'<<8)|121)
173  #endif &bsol;* A_PROMISCON_REQ */
174  #endif &bsol;* HAVE_SOLARIS */
175  static void
176  pcap_cleanup_dlpi(pcap_t *p)
177  {
178  #ifdef DL_HP_RAWDLS
179  	struct pcap_dlpi *pd = p->priv;
180  	if (pd->send_fd >= 0) {
181  		close(pd->send_fd);
182  		pd->send_fd = -1;
183  	}
184  #endif
185  	pcap_cleanup_live_common(p);
186  }
187  static int
188  open_dlpi_device(const char *name, u_int *ppa, char *errbuf)
189  {
190  	int status;
191  	char dname[100];
192  	char *cp;
193  	int fd;
194  #ifdef HAVE_DEV_DLPI
195  	u_int unit;
196  #else
197  	char dname2[100];
198  #endif
199  #ifdef HAVE_DEV_DLPI
200  	cp = strrchr(name, '/');
201  	if (cp == NULL)
202  		pcap_strlcpy(dname, name, sizeof(dname));
203  	else
204  		pcap_strlcpy(dname, cp + 1, sizeof(dname));
205  	cp = split_dname(dname, &unit, errbuf);
206  	if (cp == NULL) {
207  		return (PCAP_ERROR_NO_SUCH_DEVICE);
208  	}
209  	*cp = '\0';
210  	cp = "/dev/dlpi";
211  	if ((fd = open(cp, O_RDWR)) < 0) {
212  		if (errno == EPERM || errno == EACCES) {
213  			status = PCAP_ERROR_PERM_DENIED;
214  			snprintf(errbuf, PCAP_ERRBUF_SIZE,
215  			    "Attempt to open %s failed with %s - root privilege may be required",
216  			    cp, (errno == EPERM) ? "EPERM" : "EACCES");
217  		} else {
218  			status = PCAP_ERROR;
219  			pcap_fmt_errmsg_for_errno(errbuf, PCAP_ERRBUF_SIZE,
220  			    errno, "Attempt to open %s failed", cp);
221  		}
222  		return (status);
223  	}
224  	status = get_dlpi_ppa(fd, dname, unit, ppa, errbuf);
225  	if (status < 0) {
226  		close(fd);
227  		return (status);
228  	}
229  #else
230  	if (*name == '/')
231  		pcap_strlcpy(dname, name, sizeof(dname));
232  	else
233  		snprintf(dname, sizeof(dname), "%s/%s", PCAP_DEV_PREFIX,
234  		    name);
235  	cp = split_dname(dname, ppa, errbuf);
236  	if (cp == NULL) {
237  		return (PCAP_ERROR_NO_SUCH_DEVICE);
238  	}
239  	pcap_strlcpy(dname2, dname, sizeof(dname));
240  	*cp = '\0';
241  	if ((fd = open(dname, O_RDWR)) < 0) {
242  		if (errno != ENOENT) {
243  			if (errno == EPERM || errno == EACCES) {
244  				status = PCAP_ERROR_PERM_DENIED;
245  				snprintf(errbuf, PCAP_ERRBUF_SIZE,
246  				    "Attempt to open %s failed with %s - root privilege may be required",
247  				    dname,
248  				    (errno == EPERM) ? "EPERM" : "EACCES");
249  			} else {
250  				status = PCAP_ERROR;
251  				pcap_fmt_errmsg_for_errno(errbuf,
252  				    PCAP_ERRBUF_SIZE, errno,
253  				    "Attempt to open %s failed", dname);
254  			}
255  			return (status);
256  		}
257  		if ((fd = open(dname2, O_RDWR)) < 0) {
258  			if (errno == ENOENT) {
259  				status = PCAP_ERROR_NO_SUCH_DEVICE;
260  				snprintf(errbuf, PCAP_ERRBUF_SIZE,
261  				    "%s: No DLPI device found", name);
262  			} else {
263  				if (errno == EPERM || errno == EACCES) {
264  					status = PCAP_ERROR_PERM_DENIED;
265  					snprintf(errbuf, PCAP_ERRBUF_SIZE,
266  					    "Attempt to open %s failed with %s - root privilege may be required",
267  					    dname2,
268  					    (errno == EPERM) ? "EPERM" : "EACCES");
269  				} else {
270  					status = PCAP_ERROR;
271  					pcap_fmt_errmsg_for_errno(errbuf,
272  					    PCAP_ERRBUF_SIZE, errno,
273  					    "Attempt to open %s failed",
274  					    dname2);
275  				}
276  			}
277  			return (status);
278  		}
279  		*ppa = 0;
280  	}
281  #endif
282  	return (fd);
283  }
284  static int
285  pcap_activate_dlpi(pcap_t *p)
286  {
287  #ifdef DL_HP_RAWDLS
288  	struct pcap_dlpi *pd = p->priv;
289  #endif
290  	int status = 0;
291  	int retv;
292  	u_int ppa;
293  #ifdef HAVE_SOLARIS
294  	int isatm = 0;
295  #endif
296  	register dl_info_ack_t *infop;
297  #ifdef HAVE_SYS_BUFMOD_H
298  	bpf_u_int32 ss;
299  #ifdef HAVE_SOLARIS
300  	char release[GET_RELEASE_BUFSIZE];
301  	bpf_u_int32 osmajor, osminor, osmicro;
302  #endif
303  #endif
304  	bpf_u_int32 buf[MAXDLBUF];
305  	p->fd = open_dlpi_device(p->opt.device, &ppa, p->errbuf);
306  	if (p->fd < 0) {
307  		status = p->fd;
308  		goto bad;
309  	}
310  #ifdef DL_HP_RAWDLS
311  	pd->send_fd = open("/dev/dlpi", O_RDWR);
312  #endif
313  	if (dlinforeq(p->fd, p->errbuf) < 0 ||
314  	    dlinfoack(p->fd, (char *)buf, p->errbuf) < 0) {
315  		status = PCAP_ERROR;
316  		goto bad;
317  	}
318  	infop = &(MAKE_DL_PRIMITIVES(buf))->info_ack;
319  #ifdef HAVE_SOLARIS
320  	if (infop->dl_mac_type == DL_IPATM)
321  		isatm = 1;
322  #endif
323  	if (infop->dl_provider_style == DL_STYLE2) {
324  		retv = dl_doattach(p->fd, ppa, p->errbuf);
325  		if (retv < 0) {
326  			status = retv;
327  			goto bad;
328  		}
329  #ifdef DL_HP_RAWDLS
330  		if (pd->send_fd >= 0) {
331  			retv = dl_doattach(pd->send_fd, ppa, p->errbuf);
332  			if (retv < 0) {
333  				status = retv;
334  				goto bad;
335  			}
336  		}
337  #endif
338  	}
339  	if (p->opt.rfmon) {
340  		status = PCAP_ERROR_RFMON_NOTSUP;
341  		goto bad;
342  	}
343  #ifdef HAVE_DL_PASSIVE_REQ_T
344  	dlpassive(p->fd, p->errbuf);
345  #endif
346  #if !defined(HAVE_HPUX9) && !defined(HAVE_HPUX10_20_OR_LATER) && !defined(sinix)
347  #ifdef _AIX
348  	if ((dlbindreq(p->fd, 1537, p->errbuf) < 0 &&
349  	     dlbindreq(p->fd, 2, p->errbuf) < 0) ||
350  	     dlbindack(p->fd, (char *)buf, p->errbuf, NULL) < 0) {
351  		status = PCAP_ERROR;
352  		goto bad;
353  	}
354  #elif defined(DL_HP_RAWDLS)
355  	if (dl_dohpuxbind(p->fd, p->errbuf) < 0) {
356  		status = PCAP_ERROR;
357  		goto bad;
358  	}
359  	if (pd->send_fd >= 0) {
360  		if (dl_dohpuxbind(pd->send_fd, p->errbuf) < 0) {
361  			status = PCAP_ERROR;
362  			goto bad;
363  		}
364  	}
365  #else &bsol;* neither AIX nor HP-UX */
366  	if (dlbindreq(p->fd, 0, p->errbuf) < 0 ||
367  	    dlbindack(p->fd, (char *)buf, p->errbuf, NULL) < 0) {
368  		status = PCAP_ERROR;
369  		goto bad;
370  	}
371  #endif &bsol;* AIX vs. HP-UX vs. other */
372  #endif &bsol;* !HP-UX 9 and !HP-UX 10.20 or later and !SINIX */
373  	if (p->snapshot <= 0 || p->snapshot > MAXIMUM_SNAPLEN)
374  		p->snapshot = MAXIMUM_SNAPLEN;
375  #ifdef HAVE_SOLARIS
376  	if (isatm) {
377  		if (strioctl(p->fd, A_PROMISCON_REQ, 0, NULL) < 0) {
378  			status = PCAP_ERROR;
379  			pcap_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,
380  			    errno, "A_PROMISCON_REQ");
381  			goto bad;
382  		}
383  	} else
384  #endif
385  	if (p->opt.promisc) {
386  		retv = dlpromiscon(p, DL_PROMISC_PHYS);
387  		if (retv < 0) {
388  			if (retv == PCAP_ERROR_PERM_DENIED)
389  				status = PCAP_ERROR_PROMISC_PERM_DENIED;
390  			else
391  				status = retv;
392  			goto bad;
393  		}
394  #if !defined(__hpux) && !defined(sinix)
395  		retv = dlpromiscon(p, DL_PROMISC_MULTI);
396  		if (retv < 0)
397  			status = PCAP_WARNING;
398  #endif
399  	}
400  #ifndef sinix
401  #if defined(__hpux)
402  	if (!p->opt.promisc) {
403  #elif defined(HAVE_SOLARIS)
404  	if (!isatm) {
405  #else
406  	{
407  #endif
408  		retv = dlpromiscon(p, DL_PROMISC_SAP);
409  		if (retv < 0) {
410  			if (p->opt.promisc) {
411  				status = PCAP_WARNING;
412  			} else {
413  				status = retv;
414  				goto bad;
415  			}
416  		}
417  	}
418  #endif &bsol;* sinix */
419  #if defined(HAVE_HPUX9) || defined(HAVE_HPUX10_20_OR_LATER)
420  	if (dl_dohpuxbind(p->fd, p->errbuf) < 0) {
421  		status = PCAP_ERROR;
422  		goto bad;
423  	}
424  	if (pd->send_fd >= 0) {
425  		if (dl_dohpuxbind(pd->send_fd, p->errbuf) < 0) {
426  			status = PCAP_ERROR;
427  			goto bad;
428  		}
429  	}
430  #endif
431  	if (dlinforeq(p->fd, p->errbuf) < 0 ||
432  	    dlinfoack(p->fd, (char *)buf, p->errbuf) < 0) {
433  		status = PCAP_ERROR;
434  		goto bad;
435  	}
436  	infop = &(MAKE_DL_PRIMITIVES(buf))->info_ack;
437  	if (pcap_process_mactype(p, infop->dl_mac_type) != 0) {
438  		status = PCAP_ERROR;
439  		goto bad;
440  	}
441  #ifdef	DLIOCRAW
442  	if (strioctl(p->fd, DLIOCRAW, 0, NULL) < 0) {
<span onclick='openModal()' class='match'>443  		status = PCAP_ERROR;
444  		pcap_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,
445  		    errno, "DLIOCRAW");
446  		goto bad;
</span>447  	}
448  #endif
449  #ifdef HAVE_SYS_BUFMOD_H
450  	ss = p->snapshot;
451  #ifdef HAVE_SOLARIS
452  	get_release(release, sizeof (release), &osmajor, &osminor, &osmicro);
453  	if (osmajor == 5 && (osminor <= 2 || (osminor == 3 && osmicro < 2)) &&
454  	    getenv("BUFMOD_FIXED") == NULL) {
455  		snprintf(p->errbuf, PCAP_ERRBUF_SIZE,
456  		"WARNING: bufmod is broken in SunOS %s; ignoring snaplen.",
457  		    release);
458  		ss = 0;
459  		status = PCAP_WARNING;
460  	}
461  #endif
462  	if (pcap_conf_bufmod(p, ss) != 0) {
463  		status = PCAP_ERROR;
464  		goto bad;
465  	}
466  #endif
467  	if (ioctl(p->fd, I_FLUSH, FLUSHR) != 0) {
468  		status = PCAP_ERROR;
469  		pcap_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,
470  		    errno, "FLUSHR");
471  		goto bad;
472  	}
473  	if (pcap_alloc_databuf(p) != 0) {
474  		status = PCAP_ERROR;
475  		goto bad;
476  	}
477  	p->selectable_fd = p->fd;
478  	p->read_op = pcap_read_dlpi;
479  	p->inject_op = pcap_inject_dlpi;
480  	p->setfilter_op = pcap_install_bpf_program;	&bsol;* no kernel filtering */
481  	p->setdirection_op = NULL;	&bsol;* Not implemented.*/
482  	p->set_datalink_op = NULL;	&bsol;* can't change data link type */
483  	p->getnonblock_op = pcap_getnonblock_fd;
484  	p->setnonblock_op = pcap_setnonblock_fd;
485  	p->stats_op = pcap_stats_dlpi;
486  	p->cleanup_op = pcap_cleanup_dlpi;
487  	return (status);
488  bad:
489  	pcap_cleanup_dlpi(p);
490  	return (status);
491  }
492  static char *
493  split_dname(char *device, u_int *unitp, char *ebuf)
494  {
495  	char *cp;
496  	char *eos;
497  	long unit;
498  	cp = device + strlen(device) - 1;
499  	if (*cp < '0' || *cp > '9') {
500  		snprintf(ebuf, PCAP_ERRBUF_SIZE, "%s missing unit number",
501  		    device);
502  		return (NULL);
503  	}
504  	while (cp-1 >= device && *(cp-1) >= '0' && *(cp-1) <= '9')
505  		cp--;
506  	errno = 0;
507  	unit = strtol(cp, &eos, 10);
508  	if (*eos != '\0') {
509  		snprintf(ebuf, PCAP_ERRBUF_SIZE, "%s bad unit number", device);
510  		return (NULL);
511  	}
512  	if (errno == ERANGE || unit > INT_MAX) {
513  		snprintf(ebuf, PCAP_ERRBUF_SIZE, "%s unit number too large",
514  		    device);
515  		return (NULL);
516  	}
517  	if (unit < 0) {
518  		snprintf(ebuf, PCAP_ERRBUF_SIZE, "%s unit number is negative",
519  		    device);
520  		return (NULL);
521  	}
522  	*unitp = (u_int)unit;
523  	return (cp);
524  }
525  static int
526  dl_doattach(int fd, int ppa, char *ebuf)
527  {
528  	dl_attach_req_t	req;
529  	bpf_u_int32 buf[MAXDLBUF];
530  	int err;
531  	req.dl_primitive = DL_ATTACH_REQ;
532  	req.dl_ppa = ppa;
533  	if (send_request(fd, (char *)&req, sizeof(req), "attach", ebuf) < 0)
534  		return (PCAP_ERROR);
535  	err = dlokack(fd, "attach", (char *)buf, ebuf, NULL);
536  	if (err < 0)
537  		return (err);
538  	return (0);
539  }
540  #ifdef DL_HP_RAWDLS
541  static int
542  dl_dohpuxbind(int fd, char *ebuf)
543  {
544  	int hpsap;
545  	int uerror;
546  	bpf_u_int32 buf[MAXDLBUF];
547  	hpsap = 22;
548  	for (;;) {
549  		if (dlbindreq(fd, hpsap, ebuf) < 0)
550  			return (-1);
551  		if (dlbindack(fd, (char *)buf, ebuf, &uerror) >= 0)
552  			break;
553  		if (uerror != EBUSY) {
554  			return (-1);
555  		}
556  		*ebuf = '\0';
557  		hpsap++;
558  		if (hpsap > 100) {
559  			pcap_strlcpy(ebuf,
560  			    "All SAPs from 22 through 100 are in use",
561  			    PCAP_ERRBUF_SIZE);
562  			return (-1);
563  		}
564  	}
565  	return (0);
566  }
567  #endif
568  #define STRINGIFY(n)	#n
569  static int
570  dlpromiscon(pcap_t *p, bpf_u_int32 level)
571  {
572  	dl_promiscon_req_t req;
573  	bpf_u_int32 buf[MAXDLBUF];
574  	int err;
575  	int uerror;
576  	req.dl_primitive = DL_PROMISCON_REQ;
577  	req.dl_level = level;
578  	if (send_request(p->fd, (char *)&req, sizeof(req), "promiscon",
579  	    p->errbuf) < 0)
580  		return (PCAP_ERROR);
581  	err = dlokack(p->fd, "promiscon" STRINGIFY(level), (char *)buf,
582  	    p->errbuf, &uerror);
583  	if (err < 0) {
584  		if (err == PCAP_ERROR_PERM_DENIED) {
585  			snprintf(p->errbuf, PCAP_ERRBUF_SIZE,
586  			    "Attempt to set promiscuous mode failed with %s - root privilege may be required",
587  			    (uerror == EPERM) ? "EPERM" : "EACCES");
588  			err = PCAP_ERROR_PROMISC_PERM_DENIED;
589  		}
590  		return (err);
591  	}
592  	return (0);
593  }
594  static int
595  is_dlpi_interface(const char *name)
596  {
597  	int fd;
598  	u_int ppa;
599  	char errbuf[PCAP_ERRBUF_SIZE];
600  	fd = open_dlpi_device(name, &ppa, errbuf);
601  	if (fd < 0) {
602  		if (fd == PCAP_ERROR_NO_SUCH_DEVICE) {
603  			return (0);
604  		}
605  		return (1);
606  	}
607  	close(fd);
608  	return (1);
609  }
610  static int
611  get_if_flags(const char *name _U_, bpf_u_int32 *flags _U_, char *errbuf _U_)
612  {
613  	if (*flags & PCAP_IF_LOOPBACK) {
614  		*flags |= PCAP_IF_CONNECTION_STATUS_NOT_APPLICABLE;
615  		return (0);
616  	}
617  	return (0);
618  }
619  int
620  pcap_platform_finddevs(pcap_if_list_t *devlistp, char *errbuf)
621  {
622  #ifdef HAVE_SOLARIS
623  	int fd;
624  	union {
625  		u_int nunits;
626  		char pad[516];	&bsol;* XXX - must be at least 513; is 516
627  				   in "atmgetunits" */
628  	} buf;
629  	char baname[2+1+1];
630  	u_int i;
631  #endif
632  	if (pcap_findalldevs_interfaces(devlistp, errbuf, is_dlpi_interface,
633  	    get_if_flags) == -1)
634  		return (-1);	&bsol;* failure */
635  #ifdef HAVE_SOLARIS
636  	if ((fd = open("/dev/ba", O_RDWR)) < 0) {
637  		return (0);
638  	}
639  	if (strioctl(fd, A_GET_UNITS, sizeof(buf), (char *)&buf) < 0) {
640  		pcap_fmt_errmsg_for_errno(errbuf, PCAP_ERRBUF_SIZE,
641  		    errno, "A_GET_UNITS");
642  		return (-1);
643  	}
644  	for (i = 0; i < buf.nunits; i++) {
645  		snprintf(baname, sizeof baname, "ba%u", i);
646  		if (pcap_add_dev(devlistp, baname, 0, NULL, errbuf) == NULL)
647  			return (-1);
648  	}
649  #endif
650  	return (0);
651  }
652  static int
653  send_request(int fd, char *ptr, int len, char *what, char *ebuf)
654  {
655  	struct	strbuf	ctl;
656  	int	flags;
657  	ctl.maxlen = 0;
658  	ctl.len = len;
659  	ctl.buf = ptr;
660  	flags = 0;
661  	if (putmsg(fd, &ctl, (struct strbuf *) NULL, flags) < 0) {
662  		pcap_fmt_errmsg_for_errno(ebuf, PCAP_ERRBUF_SIZE,
663  		    errno, "send_request: putmsg \"%s\"", what);
664  		return (-1);
665  	}
666  	return (0);
667  }
668  static int
669  recv_ack(int fd, int size, const char *what, char *bufp, char *ebuf, int *uerror)
670  {
671  	union	DL_primitives	*dlp;
672  	struct	strbuf	ctl;
673  	int	flags;
674  	char	errmsgbuf[PCAP_ERRBUF_SIZE];
675  	char	dlprimbuf[64];
676  	if (uerror != NULL)
677  		*uerror = 0;
678  	ctl.maxlen = MAXDLBUF;
679  	ctl.len = 0;
680  	ctl.buf = bufp;
681  	flags = 0;
682  	if (getmsg(fd, &ctl, (struct strbuf*)NULL, &flags) < 0) {
683  		pcap_fmt_errmsg_for_errno(ebuf, PCAP_ERRBUF_SIZE,
684  		    errno, "recv_ack: %s getmsg", what);
685  		return (PCAP_ERROR);
686  	}
687  	dlp = MAKE_DL_PRIMITIVES(ctl.buf);
688  	switch (dlp->dl_primitive) {
689  	case DL_INFO_ACK:
690  	case DL_BIND_ACK:
691  	case DL_OK_ACK:
692  #ifdef DL_HP_PPA_ACK
693  	case DL_HP_PPA_ACK:
694  #endif
695  		break;
696  	case DL_ERROR_ACK:
697  		switch (dlp->error_ack.dl_errno) {
698  		case DL_SYSERR:
699  			if (uerror != NULL)
700  				*uerror = dlp->error_ack.dl_unix_errno;
701  			pcap_fmt_errmsg_for_errno(ebuf, PCAP_ERRBUF_SIZE,
702  			    dlp->error_ack.dl_unix_errno,
703  			    "recv_ack: %s: UNIX error", what);
704  			if (dlp->error_ack.dl_unix_errno == EPERM ||
705  			    dlp->error_ack.dl_unix_errno == EACCES)
706  				return (PCAP_ERROR_PERM_DENIED);
707  			break;
708  		default:
709  			snprintf(ebuf, PCAP_ERRBUF_SIZE,
710  			    "recv_ack: %s: %s", what,
711  			    dlstrerror(errmsgbuf, sizeof (errmsgbuf), dlp->error_ack.dl_errno));
712  			if (dlp->error_ack.dl_errno == DL_BADPPA)
713  				return (PCAP_ERROR_NO_SUCH_DEVICE);
714  			else if (dlp->error_ack.dl_errno == DL_ACCESS)
715  				return (PCAP_ERROR_PERM_DENIED);
716  			break;
717  		}
718  		return (PCAP_ERROR);
719  	default:
720  		snprintf(ebuf, PCAP_ERRBUF_SIZE,
721  		    "recv_ack: %s: Unexpected primitive ack %s",
722  		    what, dlprim(dlprimbuf, sizeof (dlprimbuf), dlp->dl_primitive));
723  		return (PCAP_ERROR);
724  	}
725  	if (ctl.len < size) {
726  		snprintf(ebuf, PCAP_ERRBUF_SIZE,
727  		    "recv_ack: %s: Ack too small (%d < %d)",
728  		    what, ctl.len, size);
729  		return (PCAP_ERROR);
730  	}
731  	return (ctl.len);
732  }
733  static char *
734  dlstrerror(char *errbuf, size_t errbufsize, bpf_u_int32 dl_errno)
735  {
736  	switch (dl_errno) {
737  	case DL_ACCESS:
738  		return ("Improper permissions for request");
739  	case DL_BADADDR:
740  		return ("DLSAP addr in improper format or invalid");
741  	case DL_BADCORR:
742  		return ("Seq number not from outstand DL_CONN_IND");
743  	case DL_BADDATA:
744  		return ("User data exceeded provider limit");
745  	case DL_BADPPA:
746  #ifdef HAVE_DEV_DLPI
747  		return ("Specified PPA was invalid");
748  #else
749  		return ("Specified PPA (device unit) was invalid");
750  #endif
751  	case DL_BADPRIM:
752  		return ("Primitive received not known by provider");
753  	case DL_BADQOSPARAM:
754  		return ("QOS parameters contained invalid values");
755  	case DL_BADQOSTYPE:
756  		return ("QOS structure type is unknown/unsupported");
757  	case DL_BADSAP:
758  		return ("Bad LSAP selector");
759  	case DL_BADTOKEN:
760  		return ("Token used not an active stream");
761  	case DL_BOUND:
762  		return ("Attempted second bind with dl_max_conind");
763  	case DL_INITFAILED:
764  		return ("Physical link initialization failed");
765  	case DL_NOADDR:
766  		return ("Provider couldn't allocate alternate address");
767  	case DL_NOTINIT:
768  		return ("Physical link not initialized");
769  	case DL_OUTSTATE:
770  		return ("Primitive issued in improper state");
771  	case DL_SYSERR:
772  		return ("UNIX system error occurred");
773  	case DL_UNSUPPORTED:
774  		return ("Requested service not supplied by provider");
775  	case DL_UNDELIVERABLE:
776  		return ("Previous data unit could not be delivered");
777  	case DL_NOTSUPPORTED:
778  		return ("Primitive is known but not supported");
779  	case DL_TOOMANY:
780  		return ("Limit exceeded");
781  	case DL_NOTENAB:
782  		return ("Promiscuous mode not enabled");
783  	case DL_BUSY:
784  		return ("Other streams for PPA in post-attached");
785  	case DL_NOAUTO:
786  		return ("Automatic handling XID&TEST not supported");
787  	case DL_NOXIDAUTO:
788  		return ("Automatic handling of XID not supported");
789  	case DL_NOTESTAUTO:
790  		return ("Automatic handling of TEST not supported");
791  	case DL_XIDAUTO:
792  		return ("Automatic handling of XID response");
793  	case DL_TESTAUTO:
794  		return ("Automatic handling of TEST response");
795  	case DL_PENDING:
796  		return ("Pending outstanding connect indications");
797  	default:
798  		snprintf(errbuf, errbufsize, "Error %02x", dl_errno);
799  		return (errbuf);
800  	}
801  }
802  static char *
803  dlprim(char *primbuf, size_t primbufsize, bpf_u_int32 prim)
804  {
805  	switch (prim) {
806  	case DL_INFO_REQ:
807  		return ("DL_INFO_REQ");
808  	case DL_INFO_ACK:
809  		return ("DL_INFO_ACK");
810  	case DL_ATTACH_REQ:
811  		return ("DL_ATTACH_REQ");
812  	case DL_DETACH_REQ:
813  		return ("DL_DETACH_REQ");
814  	case DL_BIND_REQ:
815  		return ("DL_BIND_REQ");
816  	case DL_BIND_ACK:
817  		return ("DL_BIND_ACK");
818  	case DL_UNBIND_REQ:
819  		return ("DL_UNBIND_REQ");
820  	case DL_OK_ACK:
821  		return ("DL_OK_ACK");
822  	case DL_ERROR_ACK:
823  		return ("DL_ERROR_ACK");
824  	case DL_SUBS_BIND_REQ:
825  		return ("DL_SUBS_BIND_REQ");
826  	case DL_SUBS_BIND_ACK:
827  		return ("DL_SUBS_BIND_ACK");
828  	case DL_UNITDATA_REQ:
829  		return ("DL_UNITDATA_REQ");
830  	case DL_UNITDATA_IND:
831  		return ("DL_UNITDATA_IND");
832  	case DL_UDERROR_IND:
833  		return ("DL_UDERROR_IND");
834  	case DL_UDQOS_REQ:
835  		return ("DL_UDQOS_REQ");
836  	case DL_CONNECT_REQ:
837  		return ("DL_CONNECT_REQ");
838  	case DL_CONNECT_IND:
839  		return ("DL_CONNECT_IND");
840  	case DL_CONNECT_RES:
841  		return ("DL_CONNECT_RES");
842  	case DL_CONNECT_CON:
843  		return ("DL_CONNECT_CON");
844  	case DL_TOKEN_REQ:
845  		return ("DL_TOKEN_REQ");
846  	case DL_TOKEN_ACK:
847  		return ("DL_TOKEN_ACK");
848  	case DL_DISCONNECT_REQ:
849  		return ("DL_DISCONNECT_REQ");
850  	case DL_DISCONNECT_IND:
851  		return ("DL_DISCONNECT_IND");
852  	case DL_RESET_REQ:
853  		return ("DL_RESET_REQ");
854  	case DL_RESET_IND:
855  		return ("DL_RESET_IND");
856  	case DL_RESET_RES:
857  		return ("DL_RESET_RES");
858  	case DL_RESET_CON:
859  		return ("DL_RESET_CON");
860  	default:
861  		snprintf(primbuf, primbufsize, "unknown primitive 0x%x",
862  		    prim);
863  		return (primbuf);
864  	}
865  }
866  static int
867  dlbindreq(int fd, bpf_u_int32 sap, char *ebuf)
868  {
869  	dl_bind_req_t	req;
870  	memset((char *)&req, 0, sizeof(req));
871  	req.dl_primitive = DL_BIND_REQ;
872  #if defined(DL_HP_RAWDLS)
873  	req.dl_max_conind = 1;			&bsol;* XXX magic number */
874  	req.dl_service_mode = DL_HP_RAWDLS;
875  #elif defined(DL_CLDLS)
876  	req.dl_service_mode = DL_CLDLS;
877  #endif
878  	req.dl_sap = sap;
879  	return (send_request(fd, (char *)&req, sizeof(req), "bind", ebuf));
880  }
881  static int
882  dlbindack(int fd, char *bufp, char *ebuf, int *uerror)
883  {
884  	return (recv_ack(fd, DL_BIND_ACK_SIZE, "bind", bufp, ebuf, uerror));
885  }
886  static int
887  dlokack(int fd, const char *what, char *bufp, char *ebuf, int *uerror)
888  {
889  	return (recv_ack(fd, DL_OK_ACK_SIZE, what, bufp, ebuf, uerror));
890  }
891  static int
892  dlinforeq(int fd, char *ebuf)
893  {
894  	dl_info_req_t req;
895  	req.dl_primitive = DL_INFO_REQ;
896  	return (send_request(fd, (char *)&req, sizeof(req), "info", ebuf));
897  }
898  static int
899  dlinfoack(int fd, char *bufp, char *ebuf)
900  {
901  	return (recv_ack(fd, DL_INFO_ACK_SIZE, "info", bufp, ebuf, NULL));
902  }
903  #ifdef HAVE_DL_PASSIVE_REQ_T
904  static void
905  dlpassive(int fd, char *ebuf)
906  {
907  	dl_passive_req_t req;
908  	bpf_u_int32 buf[MAXDLBUF];
909  	req.dl_primitive = DL_PASSIVE_REQ;
910  	if (send_request(fd, (char *)&req, sizeof(req), "dlpassive", ebuf) == 0)
911  	    (void) dlokack(fd, "dlpassive", (char *)buf, ebuf, NULL);
912  }
913  #endif
914  #ifdef DL_HP_RAWDLS
915  static int
916  dlrawdatareq(int fd, const u_char *datap, int datalen)
917  {
918  	struct strbuf ctl, data;
919  	long buf[MAXDLBUF];	&bsol;* XXX - char? */
920  	union DL_primitives *dlp;
921  	int dlen;
922  	dlp = MAKE_DL_PRIMITIVES(buf);
923  	dlp->dl_primitive = DL_HP_RAWDATA_REQ;
924  	dlen = DL_HP_RAWDATA_REQ_SIZE;
925  	ctl.maxlen = 0;
926  	ctl.len = dlen;
927  	ctl.buf = (void *)buf;
928  	data.maxlen = 0;
929  	data.len = datalen;
930  	data.buf = (void *)datap;
931  	return (putmsg(fd, &ctl, &data, 0));
932  }
933  #endif &bsol;* DL_HP_RAWDLS */
934  #if defined(HAVE_SOLARIS) && defined(HAVE_SYS_BUFMOD_H)
935  static void
936  get_release(char *buf, size_t bufsize, bpf_u_int32 *majorp,
937      bpf_u_int32 *minorp, bpf_u_int32 *microp)
938  {
939  	char *cp;
940  	*majorp = 0;
941  	*minorp = 0;
942  	*microp = 0;
943  	if (sysinfo(SI_RELEASE, buf, bufsize) < 0) {
944  		pcap_strlcpy(buf, "?", bufsize);
945  		return;
946  	}
947  	cp = buf;
948  	if (!PCAP_ISDIGIT((unsigned char)*cp))
949  		return;
950  	*majorp = strtol(cp, &cp, 10);
951  	if (*cp++ != '.')
952  		return;
953  	*minorp =  strtol(cp, &cp, 10);
954  	if (*cp++ != '.')
955  		return;
956  	*microp =  strtol(cp, &cp, 10);
957  }
958  #endif
959  #ifdef DL_HP_PPA_REQ
960  static int
961  get_dlpi_ppa(register int fd, register const char *device, register u_int unit,
962      u_int *ppa, register char *ebuf)
963  {
964  	register dl_hp_ppa_ack_t *ap;
965  	register dl_hp_ppa_info_t *ipstart, *ip;
966  	register u_int i;
967  	char dname[100];
968  	register u_long majdev;
969  	struct stat statbuf;
970  	dl_hp_ppa_req_t	req;
971  	char buf[MAXDLBUF];
972  	char *ppa_data_buf;
973  	dl_hp_ppa_ack_t	*dlp;
974  	struct strbuf ctl;
975  	int flags;
976  	memset((char *)&req, 0, sizeof(req));
977  	req.dl_primitive = DL_HP_PPA_REQ;
978  	memset((char *)buf, 0, sizeof(buf));
979  	if (send_request(fd, (char *)&req, sizeof(req), "hpppa", ebuf) < 0)
980  		return (PCAP_ERROR);
981  	ctl.maxlen = DL_HP_PPA_ACK_SIZE;
982  	ctl.len = 0;
983  	ctl.buf = (char *)buf;
984  	flags = 0;
985  	if (getmsg(fd, &ctl, (struct strbuf *)NULL, &flags) < 0) {
986  		pcap_fmt_errmsg_for_errno(ebuf, PCAP_ERRBUF_SIZE,
987  		    errno, "get_dlpi_ppa: hpppa getmsg");
988  		return (PCAP_ERROR);
989  	}
990  	if (ctl.len == -1) {
991  		snprintf(ebuf, PCAP_ERRBUF_SIZE,
992  		    "get_dlpi_ppa: hpppa getmsg: control buffer has no data");
993  		return (PCAP_ERROR);
994  	}
995  	dlp = (dl_hp_ppa_ack_t *)ctl.buf;
996  	if (dlp->dl_primitive != DL_HP_PPA_ACK) {
997  		snprintf(ebuf, PCAP_ERRBUF_SIZE,
998  		    "get_dlpi_ppa: hpppa unexpected primitive ack 0x%x",
999  		    (bpf_u_int32)dlp->dl_primitive);
1000  		return (PCAP_ERROR);
1001  	}
1002  	if ((size_t)ctl.len < DL_HP_PPA_ACK_SIZE) {
1003  		snprintf(ebuf, PCAP_ERRBUF_SIZE,
1004  		    "get_dlpi_ppa: hpppa ack too small (%d < %lu)",
1005  		     ctl.len, (unsigned long)DL_HP_PPA_ACK_SIZE);
1006  		return (PCAP_ERROR);
1007  	}
1008  	if ((ppa_data_buf = (char *)malloc(dlp->dl_length)) == NULL) {
1009  		pcap_fmt_errmsg_for_errno(ebuf, PCAP_ERRBUF_SIZE,
1010  		    errno, "get_dlpi_ppa: hpppa malloc");
1011  		return (PCAP_ERROR);
1012  	}
1013  	ctl.maxlen = dlp->dl_length;
1014  	ctl.len = 0;
1015  	ctl.buf = (char *)ppa_data_buf;
1016  	if (getmsg(fd, &ctl, (struct strbuf *)NULL, &flags) < 0) {
1017  		pcap_fmt_errmsg_for_errno(ebuf, PCAP_ERRBUF_SIZE,
1018  		    errno, "get_dlpi_ppa: hpppa getmsg");
1019  		free(ppa_data_buf);
1020  		return (PCAP_ERROR);
1021  	}
1022  	if (ctl.len == -1) {
1023  		snprintf(ebuf, PCAP_ERRBUF_SIZE,
1024  		    "get_dlpi_ppa: hpppa getmsg: control buffer has no data");
1025  		return (PCAP_ERROR);
1026  	}
1027  	if ((u_int)ctl.len < dlp->dl_length) {
1028  		snprintf(ebuf, PCAP_ERRBUF_SIZE,
1029  		    "get_dlpi_ppa: hpppa ack too small (%d < %lu)",
1030  		    ctl.len, (unsigned long)dlp->dl_length);
1031  		free(ppa_data_buf);
1032  		return (PCAP_ERROR);
1033  	}
1034  	ap = (dl_hp_ppa_ack_t *)buf;
1035  	ipstart = (dl_hp_ppa_info_t *)ppa_data_buf;
1036  	ip = ipstart;
1037  #ifdef HAVE_DL_HP_PPA_INFO_T_DL_MODULE_ID_1
1038  	for (i = 0; i < ap->dl_count; i++) {
1039  		if ((strcmp((const char *)ip->dl_module_id_1, device) == 0 ||
1040  		     strcmp((const char *)ip->dl_module_id_2, device) == 0) &&
1041  		    ip->dl_instance_num == unit)
1042  			break;
1043  		ip = (dl_hp_ppa_info_t *)((u_char *)ipstart + ip->dl_next_offset);
1044  	}
1045  #else
1046  	i = ap->dl_count;
1047  #endif
1048  	if (i == ap->dl_count) {
1049  		snprintf(dname, sizeof(dname), "/dev/%s%u", device, unit);
1050  		if (stat(dname, &statbuf) < 0) {
1051  			pcap_fmt_errmsg_for_errno(ebuf, PCAP_ERRBUF_SIZE,
1052  			    errno, "stat: %s", dname);
1053  			return (PCAP_ERROR);
1054  		}
1055  		majdev = major(statbuf.st_rdev);
1056  		ip = ipstart;
1057  		for (i = 0; i < ap->dl_count; i++) {
1058  			if (ip->dl_mjr_num == majdev &&
1059  			    ip->dl_instance_num == unit)
1060  				break;
1061  			ip = (dl_hp_ppa_info_t *)((u_char *)ipstart + ip->dl_next_offset);
1062  		}
1063  	}
1064  	if (i == ap->dl_count) {
1065  		snprintf(ebuf, PCAP_ERRBUF_SIZE,
1066  		    "can't find /dev/dlpi PPA for %s%u", device, unit);
1067  		return (PCAP_ERROR_NO_SUCH_DEVICE);
1068  	}
1069  	if (ip->dl_hdw_state == HDW_DEAD) {
1070  		snprintf(ebuf, PCAP_ERRBUF_SIZE,
1071  		    "%s%d: hardware state: DOWN\n", device, unit);
1072  		free(ppa_data_buf);
1073  		return (PCAP_ERROR);
1074  	}
1075  	*ppa = ip->dl_ppa;
1076  	free(ppa_data_buf);
1077  	return (0);
1078  }
1079  #endif
1080  #ifdef HAVE_HPUX9
1081  static struct nlist nl[] = {
1082  #define NL_IFNET 0
1083  	{ "ifnet" },
1084  	{ "" }
1085  };
1086  static char path_vmunix[] = "/hp-ux";
1087  static int
1088  get_dlpi_ppa(register int fd, register const char *ifname, register u_int unit,
1089      u_int *ppa, register char *ebuf)
1090  {
1091  	register const char *cp;
1092  	register int kd;
1093  	void *addr;
1094  	struct ifnet ifnet;
1095  	char if_name[sizeof(ifnet.if_name) + 1];
1096  	cp = strrchr(ifname, '/');
1097  	if (cp != NULL)
1098  		ifname = cp + 1;
1099  	if (nlist(path_vmunix, &nl) < 0) {
1100  		snprintf(ebuf, PCAP_ERRBUF_SIZE, "nlist %s failed",
1101  		    path_vmunix);
1102  		return (PCAP_ERROR);
1103  	}
1104  	if (nl[NL_IFNET].n_value == 0) {
1105  		snprintf(ebuf, PCAP_ERRBUF_SIZE,
1106  		    "couldn't find %s kernel symbol",
1107  		    nl[NL_IFNET].n_name);
1108  		return (PCAP_ERROR);
1109  	}
1110  	kd = open("/dev/kmem", O_RDONLY);
1111  	if (kd < 0) {
1112  		pcap_fmt_errmsg_for_errno(ebuf, PCAP_ERRBUF_SIZE,
1113  		    errno, "kmem open");
1114  		return (PCAP_ERROR);
1115  	}
1116  	if (dlpi_kread(kd, nl[NL_IFNET].n_value,
1117  	    &addr, sizeof(addr), ebuf) < 0) {
1118  		close(kd);
1119  		return (PCAP_ERROR);
1120  	}
1121  	for (; addr != NULL; addr = ifnet.if_next) {
1122  		if (dlpi_kread(kd, (off_t)addr,
1123  		    &ifnet, sizeof(ifnet), ebuf) < 0 ||
1124  		    dlpi_kread(kd, (off_t)ifnet.if_name,
1125  		    if_name, sizeof(ifnet.if_name), ebuf) < 0) {
1126  			(void)close(kd);
1127  			return (PCAP_ERROR);
1128  		}
1129  		if_name[sizeof(ifnet.if_name)] = '\0';
1130  		if (strcmp(if_name, ifname) == 0 && ifnet.if_unit == unit) {
1131  			*ppa = ifnet.if_index;
1132  			return (0);
1133  		}
1134  	}
1135  	snprintf(ebuf, PCAP_ERRBUF_SIZE, "Can't find %s", ifname);
1136  	return (PCAP_ERROR_NO_SUCH_DEVICE);
1137  }
1138  static int
1139  dlpi_kread(register int fd, register off_t addr,
1140      register void *buf, register u_int len, register char *ebuf)
1141  {
1142  	register int cc;
1143  	if (lseek(fd, addr, SEEK_SET) < 0) {
1144  		pcap_fmt_errmsg_for_errno(ebuf, PCAP_ERRBUF_SIZE,
1145  		    errno, "lseek");
1146  		return (-1);
1147  	}
1148  	cc = read(fd, buf, len);
1149  	if (cc < 0) {
1150  		pcap_fmt_errmsg_for_errno(ebuf, PCAP_ERRBUF_SIZE,
1151  		    errno, "read");
1152  		return (-1);
1153  	} else if (cc != len) {
1154  		snprintf(ebuf, PCAP_ERRBUF_SIZE, "short read (%d != %d)", cc,
1155  		    len);
1156  		return (-1);
1157  	}
1158  	return (cc);
1159  }
1160  #endif
1161  pcap_t *
1162  pcap_create_interface(const char *device _U_, char *ebuf)
1163  {
1164  	pcap_t *p;
1165  #ifdef DL_HP_RAWDLS
1166  	struct pcap_dlpi *pd;
1167  #endif
1168  	p = PCAP_CREATE_COMMON(ebuf, struct pcap_dlpi);
1169  	if (p == NULL)
1170  		return (NULL);
1171  #ifdef DL_HP_RAWDLS
1172  	pd = p->priv;
1173  	pd->send_fd = -1;	&bsol;* it hasn't been opened yet */
1174  #endif
1175  	p->activate_op = pcap_activate_dlpi;
1176  	return (p);
1177  }
1178  const char *
1179  pcap_lib_version(void)
1180  {
1181  	return (PCAP_VERSION_STRING);
1182  }
</code></pre>
        </div>
        <div class="column">
            <h3>libpcap-MDEwOlJlcG9zaXRvcnk5NDM1ODg3-flat-pcap-dlpi.c</h3>
            <pre><code>1  #ifdef HAVE_CONFIG_H
2  #include <config.h>
3  #endif
4  #include <sys/types.h>
5  #include <sys/time.h>
6  #ifdef HAVE_SYS_BUFMOD_H
7  #include <sys/bufmod.h>
8  #endif
9  #include <sys/dlpi.h>
10  #ifdef HAVE_SYS_DLPI_EXT_H
11  #include <sys/dlpi_ext.h>
12  #endif
13  #ifdef HAVE_HPUX9
14  #include <sys/socket.h>
15  #endif
16  #ifdef DL_HP_PPA_REQ
17  #include <sys/stat.h>
18  #endif
19  #include <sys/stream.h>
20  #if defined(HAVE_SOLARIS) && defined(HAVE_SYS_BUFMOD_H)
21  #include <sys/systeminfo.h>
22  #endif
23  #ifdef HAVE_HPUX9
24  #include <net/if.h>
25  #endif
26  #ifdef HAVE_HPUX9
27  #include <nlist.h>
28  #endif
29  #include <errno.h>
30  #include <fcntl.h>
31  #include <memory.h>
32  #include <stdio.h>
33  #include <stdlib.h>
34  #include <string.h>
35  #include <stropts.h>
36  #include <unistd.h>
37  #include <limits.h>
38  #include "pcap-int.h"
39  #include "dlpisubs.h"
40  #ifdef HAVE_OS_PROTO_H
41  #include "os-proto.h"
42  #endif
43  #if defined(__hpux)
44    #define HAVE_DEV_DLPI
45  #elif defined(_AIX)
46    #define PCAP_DEV_PREFIX "/dev/dlpi"
47  #elif defined(HAVE_SOLARIS)
48    #define PCAP_DEV_PREFIX "/dev"
49  #endif
50  #define	MAXDLBUF	8192
51  static char *split_dname(char *, u_int *, char *);
52  static int dl_doattach(int, int, char *);
53  #ifdef DL_HP_RAWDLS
54  static int dl_dohpuxbind(int, char *);
55  #endif
56  static int dlpromiscon(pcap_t *, bpf_u_int32);
57  static int dlbindreq(int, bpf_u_int32, char *);
58  static int dlbindack(int, char *, char *, int *);
59  static int dlokack(int, const char *, char *, char *, int *);
60  static int dlinforeq(int, char *);
61  static int dlinfoack(int, char *, char *);
62  #ifdef HAVE_DL_PASSIVE_REQ_T
63  static void dlpassive(int, char *);
64  #endif
65  #ifdef DL_HP_RAWDLS
66  static int dlrawdatareq(int, const u_char *, int);
67  #endif
68  static int recv_ack(int, int, const char *, char *, char *, int *);
69  static char *dlstrerror(char *, size_t, bpf_u_int32);
70  static char *dlprim(char *, size_t, bpf_u_int32);
71  #if defined(HAVE_SOLARIS) && defined(HAVE_SYS_BUFMOD_H)
72  #define GET_RELEASE_BUFSIZE	32
73  static void get_release(char *, size_t, bpf_u_int32 *, bpf_u_int32 *,
74      bpf_u_int32 *);
75  #endif
76  static int send_request(int, char *, int, char *, char *);
77  #ifdef HAVE_HPUX9
78  static int dlpi_kread(int, off_t, void *, u_int, char *);
79  #endif
80  #ifdef HAVE_DEV_DLPI
81  static int get_dlpi_ppa(int, const char *, u_int, u_int *, char *);
82  #endif
83  #define MAKE_DL_PRIMITIVES(ptr)	((union DL_primitives *)(void *)(ptr))
84  static int
85  pcap_read_dlpi(pcap_t *p, int cnt, pcap_handler callback, u_char *user)
86  {
87  	int cc;
88  	u_char *bp;
89  	int flags;
90  	bpf_u_int32 ctlbuf[MAXDLBUF];
91  	struct strbuf ctl = {
92  		MAXDLBUF,
93  		0,
94  		(char *)ctlbuf
95  	};
96  	struct strbuf data;
97  	flags = 0;
98  	cc = p->cc;
99  	if (cc == 0) {
100  		data.buf = (char *)p->buffer + p->offset;
101  		data.maxlen = p->bufsize;
102  		data.len = 0;
103  		do {
104  			if (p->break_loop) {
105  				p->break_loop = 0;
106  				return (-2);
107  			}
108  			ctl.buf = (char *)ctlbuf;
109  			ctl.maxlen = MAXDLBUF;
110  			ctl.len = 0;
111  			if (getmsg(p->fd, &ctl, &data, &flags) < 0) {
112  				switch (errno) {
113  				case EINTR:
114  					cc = 0;
115  					continue;
116  				case EAGAIN:
117  					return (0);
118  				}
119  				pcap_fmt_errmsg_for_errno(p->errbuf,
120  				    sizeof(p->errbuf), errno, "getmsg");
121  				return (-1);
122  			}
123  			cc = data.len;
124  		} while (cc == 0);
125  		bp = p->buffer + p->offset;
126  	} else
127  		bp = p->bp;
128  	return (pcap_process_pkts(p, callback, user, cnt, bp, cc));
129  }
130  static int
131  pcap_inject_dlpi(pcap_t *p, const void *buf, int size)
132  {
133  #ifdef DL_HP_RAWDLS
134  	struct pcap_dlpi *pd = p->priv;
135  #endif
136  	int ret;
137  #if defined(DLIOCRAW)
138  	ret = write(p->fd, buf, size);
139  	if (ret == -1) {
140  		pcap_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,
141  		    errno, "send");
142  		return (-1);
143  	}
144  #elif defined(DL_HP_RAWDLS)
145  	if (pd->send_fd < 0) {
146  		snprintf(p->errbuf, PCAP_ERRBUF_SIZE,
147  		    "send: Output FD couldn't be opened");
148  		return (-1);
149  	}
150  	ret = dlrawdatareq(pd->send_fd, buf, size);
151  	if (ret == -1) {
152  		pcap_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,
153  		    errno, "send");
154  		return (-1);
155  	}
156  	ret = size;
157  #else &bsol;* no raw mode */
158  	pcap_strlcpy(p->errbuf, "send: Not supported on this version of this OS",
159  	    PCAP_ERRBUF_SIZE);
160  	ret = -1;
161  #endif &bsol;* raw mode */
162  	return (ret);
163  }
164  #ifndef DL_IPATM
165  #define DL_IPATM	0x12	&bsol;* ATM Classical IP interface */
166  #endif
167  #ifdef HAVE_SOLARIS
168  #ifndef A_GET_UNITS
169  #define A_GET_UNITS	(('A'<<8)|118)
170  #endif &bsol;* A_GET_UNITS */
171  #ifndef A_PROMISCON_REQ
172  #define A_PROMISCON_REQ	(('A'<<8)|121)
173  #endif &bsol;* A_PROMISCON_REQ */
174  #endif &bsol;* HAVE_SOLARIS */
175  static void
176  pcap_cleanup_dlpi(pcap_t *p)
177  {
178  #ifdef DL_HP_RAWDLS
179  	struct pcap_dlpi *pd = p->priv;
180  	if (pd->send_fd >= 0) {
181  		close(pd->send_fd);
182  		pd->send_fd = -1;
183  	}
184  #endif
185  	pcap_cleanup_live_common(p);
186  }
187  static int
188  open_dlpi_device(const char *name, u_int *ppa, char *errbuf)
189  {
190  	int status;
191  	char dname[100];
192  	char *cp;
193  	int fd;
194  #ifdef HAVE_DEV_DLPI
195  	u_int unit;
196  #else
197  	char dname2[100];
198  #endif
199  #ifdef HAVE_DEV_DLPI
200  	cp = strrchr(name, '/');
201  	if (cp == NULL)
202  		pcap_strlcpy(dname, name, sizeof(dname));
203  	else
204  		pcap_strlcpy(dname, cp + 1, sizeof(dname));
205  	cp = split_dname(dname, &unit, errbuf);
206  	if (cp == NULL) {
207  		return (PCAP_ERROR_NO_SUCH_DEVICE);
208  	}
209  	*cp = '\0';
210  	cp = "/dev/dlpi";
211  	if ((fd = open(cp, O_RDWR)) < 0) {
212  		if (errno == EPERM || errno == EACCES) {
213  			status = PCAP_ERROR_PERM_DENIED;
214  			snprintf(errbuf, PCAP_ERRBUF_SIZE,
215  			    "Attempt to open %s failed with %s - root privilege may be required",
216  			    cp, (errno == EPERM) ? "EPERM" : "EACCES");
217  		} else {
218  			status = PCAP_ERROR;
219  			pcap_fmt_errmsg_for_errno(errbuf, PCAP_ERRBUF_SIZE,
220  			    errno, "Attempt to open %s failed", cp);
221  		}
222  		return (status);
223  	}
224  	status = get_dlpi_ppa(fd, dname, unit, ppa, errbuf);
225  	if (status < 0) {
226  		close(fd);
227  		return (status);
228  	}
229  #else
230  	if (*name == '/')
231  		pcap_strlcpy(dname, name, sizeof(dname));
232  	else
233  		snprintf(dname, sizeof(dname), "%s/%s", PCAP_DEV_PREFIX,
234  		    name);
235  	cp = split_dname(dname, ppa, errbuf);
236  	if (cp == NULL) {
237  		return (PCAP_ERROR_NO_SUCH_DEVICE);
238  	}
239  	pcap_strlcpy(dname2, dname, sizeof(dname));
240  	*cp = '\0';
241  	if ((fd = open(dname, O_RDWR)) < 0) {
242  		if (errno != ENOENT) {
243  			if (errno == EPERM || errno == EACCES) {
244  				status = PCAP_ERROR_PERM_DENIED;
245  				snprintf(errbuf, PCAP_ERRBUF_SIZE,
246  				    "Attempt to open %s failed with %s - root privilege may be required",
247  				    dname,
248  				    (errno == EPERM) ? "EPERM" : "EACCES");
249  			} else {
250  				status = PCAP_ERROR;
251  				pcap_fmt_errmsg_for_errno(errbuf,
252  				    PCAP_ERRBUF_SIZE, errno,
253  				    "Attempt to open %s failed", dname);
254  			}
255  			return (status);
256  		}
257  		if ((fd = open(dname2, O_RDWR)) < 0) {
258  			if (errno == ENOENT) {
259  				status = PCAP_ERROR_NO_SUCH_DEVICE;
260  				snprintf(errbuf, PCAP_ERRBUF_SIZE,
261  				    "%s: No DLPI device found", name);
262  			} else {
263  				if (errno == EPERM || errno == EACCES) {
264  					status = PCAP_ERROR_PERM_DENIED;
265  					snprintf(errbuf, PCAP_ERRBUF_SIZE,
266  					    "Attempt to open %s failed with %s - root privilege may be required",
267  					    dname2,
268  					    (errno == EPERM) ? "EPERM" : "EACCES");
269  				} else {
270  					status = PCAP_ERROR;
271  					pcap_fmt_errmsg_for_errno(errbuf,
272  					    PCAP_ERRBUF_SIZE, errno,
273  					    "Attempt to open %s failed",
274  					    dname2);
275  				}
276  			}
277  			return (status);
278  		}
279  		*ppa = 0;
280  	}
281  #endif
282  	return (fd);
283  }
284  static int
285  pcap_activate_dlpi(pcap_t *p)
286  {
287  #ifdef DL_HP_RAWDLS
288  	struct pcap_dlpi *pd = p->priv;
289  #endif
290  	int status = 0;
291  	int retv;
292  	u_int ppa;
293  #ifdef HAVE_SOLARIS
294  	int isatm = 0;
295  #endif
296  	register dl_info_ack_t *infop;
297  #ifdef HAVE_SYS_BUFMOD_H
298  	bpf_u_int32 ss;
299  #ifdef HAVE_SOLARIS
300  	char release[GET_RELEASE_BUFSIZE];
301  	bpf_u_int32 osmajor, osminor, osmicro;
302  #endif
303  #endif
304  	bpf_u_int32 buf[MAXDLBUF];
305  	p->fd = open_dlpi_device(p->opt.device, &ppa, p->errbuf);
306  	if (p->fd < 0) {
307  		status = p->fd;
308  		goto bad;
309  	}
310  #ifdef DL_HP_RAWDLS
311  	pd->send_fd = open("/dev/dlpi", O_RDWR);
312  #endif
313  	if (dlinforeq(p->fd, p->errbuf) < 0 ||
314  	    dlinfoack(p->fd, (char *)buf, p->errbuf) < 0) {
315  		status = PCAP_ERROR;
316  		goto bad;
317  	}
318  	infop = &(MAKE_DL_PRIMITIVES(buf))->info_ack;
319  #ifdef HAVE_SOLARIS
320  	if (infop->dl_mac_type == DL_IPATM)
321  		isatm = 1;
322  #endif
323  	if (infop->dl_provider_style == DL_STYLE2) {
324  		retv = dl_doattach(p->fd, ppa, p->errbuf);
325  		if (retv < 0) {
326  			status = retv;
327  			goto bad;
328  		}
329  #ifdef DL_HP_RAWDLS
330  		if (pd->send_fd >= 0) {
331  			retv = dl_doattach(pd->send_fd, ppa, p->errbuf);
332  			if (retv < 0) {
333  				status = retv;
334  				goto bad;
335  			}
336  		}
337  #endif
338  	}
339  	if (p->opt.rfmon) {
340  		status = PCAP_ERROR_RFMON_NOTSUP;
341  		goto bad;
342  	}
343  #ifdef HAVE_DL_PASSIVE_REQ_T
344  	dlpassive(p->fd, p->errbuf);
345  #endif
346  #if !defined(HAVE_HPUX9) && !defined(HAVE_HPUX10_20_OR_LATER) && !defined(sinix)
347  #ifdef _AIX
348  	if ((dlbindreq(p->fd, 1537, p->errbuf) < 0 &&
349  	     dlbindreq(p->fd, 2, p->errbuf) < 0) ||
350  	     dlbindack(p->fd, (char *)buf, p->errbuf, NULL) < 0) {
351  		status = PCAP_ERROR;
352  		goto bad;
353  	}
354  #elif defined(DL_HP_RAWDLS)
355  	if (dl_dohpuxbind(p->fd, p->errbuf) < 0) {
356  		status = PCAP_ERROR;
357  		goto bad;
358  	}
359  	if (pd->send_fd >= 0) {
360  		if (dl_dohpuxbind(pd->send_fd, p->errbuf) < 0) {
361  			status = PCAP_ERROR;
362  			goto bad;
363  		}
364  	}
365  #else &bsol;* neither AIX nor HP-UX */
366  	if (dlbindreq(p->fd, 0, p->errbuf) < 0 ||
367  	    dlbindack(p->fd, (char *)buf, p->errbuf, NULL) < 0) {
368  		status = PCAP_ERROR;
369  		goto bad;
370  	}
371  #endif &bsol;* AIX vs. HP-UX vs. other */
372  #endif &bsol;* !HP-UX 9 and !HP-UX 10.20 or later and !SINIX */
373  	if (p->snapshot <= 0 || p->snapshot > MAXIMUM_SNAPLEN)
374  		p->snapshot = MAXIMUM_SNAPLEN;
375  #ifdef HAVE_SOLARIS
376  	if (isatm) {
377  		if (strioctl(p->fd, A_PROMISCON_REQ, 0, NULL) < 0) {
<span onclick='openModal()' class='match'>378  			status = PCAP_ERROR;
379  			pcap_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,
380  			    errno, "A_PROMISCON_REQ");
381  			goto bad;
</span>382  		}
383  	} else
384  #endif
385  	if (p->opt.promisc) {
386  		retv = dlpromiscon(p, DL_PROMISC_PHYS);
387  		if (retv < 0) {
388  			if (retv == PCAP_ERROR_PERM_DENIED)
389  				status = PCAP_ERROR_PROMISC_PERM_DENIED;
390  			else
391  				status = retv;
392  			goto bad;
393  		}
394  #if !defined(__hpux) && !defined(sinix)
395  		retv = dlpromiscon(p, DL_PROMISC_MULTI);
396  		if (retv < 0)
397  			status = PCAP_WARNING;
398  #endif
399  	}
400  #ifndef sinix
401  #if defined(__hpux)
402  	if (!p->opt.promisc) {
403  #elif defined(HAVE_SOLARIS)
404  	if (!isatm) {
405  #else
406  	{
407  #endif
408  		retv = dlpromiscon(p, DL_PROMISC_SAP);
409  		if (retv < 0) {
410  			if (p->opt.promisc) {
411  				status = PCAP_WARNING;
412  			} else {
413  				status = retv;
414  				goto bad;
415  			}
416  		}
417  	}
418  #endif &bsol;* sinix */
419  #if defined(HAVE_HPUX9) || defined(HAVE_HPUX10_20_OR_LATER)
420  	if (dl_dohpuxbind(p->fd, p->errbuf) < 0) {
421  		status = PCAP_ERROR;
422  		goto bad;
423  	}
424  	if (pd->send_fd >= 0) {
425  		if (dl_dohpuxbind(pd->send_fd, p->errbuf) < 0) {
426  			status = PCAP_ERROR;
427  			goto bad;
428  		}
429  	}
430  #endif
431  	if (dlinforeq(p->fd, p->errbuf) < 0 ||
432  	    dlinfoack(p->fd, (char *)buf, p->errbuf) < 0) {
433  		status = PCAP_ERROR;
434  		goto bad;
435  	}
436  	infop = &(MAKE_DL_PRIMITIVES(buf))->info_ack;
437  	if (pcap_process_mactype(p, infop->dl_mac_type) != 0) {
438  		status = PCAP_ERROR;
439  		goto bad;
440  	}
441  #ifdef	DLIOCRAW
442  	if (strioctl(p->fd, DLIOCRAW, 0, NULL) < 0) {
443  		status = PCAP_ERROR;
444  		pcap_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,
445  		    errno, "DLIOCRAW");
446  		goto bad;
447  	}
448  #endif
449  #ifdef HAVE_SYS_BUFMOD_H
450  	ss = p->snapshot;
451  #ifdef HAVE_SOLARIS
452  	get_release(release, sizeof (release), &osmajor, &osminor, &osmicro);
453  	if (osmajor == 5 && (osminor <= 2 || (osminor == 3 && osmicro < 2)) &&
454  	    getenv("BUFMOD_FIXED") == NULL) {
455  		snprintf(p->errbuf, PCAP_ERRBUF_SIZE,
456  		"WARNING: bufmod is broken in SunOS %s; ignoring snaplen.",
457  		    release);
458  		ss = 0;
459  		status = PCAP_WARNING;
460  	}
461  #endif
462  	if (pcap_conf_bufmod(p, ss) != 0) {
463  		status = PCAP_ERROR;
464  		goto bad;
465  	}
466  #endif
467  	if (ioctl(p->fd, I_FLUSH, FLUSHR) != 0) {
468  		status = PCAP_ERROR;
469  		pcap_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,
470  		    errno, "FLUSHR");
471  		goto bad;
472  	}
473  	if (pcap_alloc_databuf(p) != 0) {
474  		status = PCAP_ERROR;
475  		goto bad;
476  	}
477  	p->selectable_fd = p->fd;
478  	p->read_op = pcap_read_dlpi;
479  	p->inject_op = pcap_inject_dlpi;
480  	p->setfilter_op = pcap_install_bpf_program;	&bsol;* no kernel filtering */
481  	p->setdirection_op = NULL;	&bsol;* Not implemented.*/
482  	p->set_datalink_op = NULL;	&bsol;* can't change data link type */
483  	p->getnonblock_op = pcap_getnonblock_fd;
484  	p->setnonblock_op = pcap_setnonblock_fd;
485  	p->stats_op = pcap_stats_dlpi;
486  	p->cleanup_op = pcap_cleanup_dlpi;
487  	return (status);
488  bad:
489  	pcap_cleanup_dlpi(p);
490  	return (status);
491  }
492  static char *
493  split_dname(char *device, u_int *unitp, char *ebuf)
494  {
495  	char *cp;
496  	char *eos;
497  	long unit;
498  	cp = device + strlen(device) - 1;
499  	if (*cp < '0' || *cp > '9') {
500  		snprintf(ebuf, PCAP_ERRBUF_SIZE, "%s missing unit number",
501  		    device);
502  		return (NULL);
503  	}
504  	while (cp-1 >= device && *(cp-1) >= '0' && *(cp-1) <= '9')
505  		cp--;
506  	errno = 0;
507  	unit = strtol(cp, &eos, 10);
508  	if (*eos != '\0') {
509  		snprintf(ebuf, PCAP_ERRBUF_SIZE, "%s bad unit number", device);
510  		return (NULL);
511  	}
512  	if (errno == ERANGE || unit > INT_MAX) {
513  		snprintf(ebuf, PCAP_ERRBUF_SIZE, "%s unit number too large",
514  		    device);
515  		return (NULL);
516  	}
517  	if (unit < 0) {
518  		snprintf(ebuf, PCAP_ERRBUF_SIZE, "%s unit number is negative",
519  		    device);
520  		return (NULL);
521  	}
522  	*unitp = (u_int)unit;
523  	return (cp);
524  }
525  static int
526  dl_doattach(int fd, int ppa, char *ebuf)
527  {
528  	dl_attach_req_t	req;
529  	bpf_u_int32 buf[MAXDLBUF];
530  	int err;
531  	req.dl_primitive = DL_ATTACH_REQ;
532  	req.dl_ppa = ppa;
533  	if (send_request(fd, (char *)&req, sizeof(req), "attach", ebuf) < 0)
534  		return (PCAP_ERROR);
535  	err = dlokack(fd, "attach", (char *)buf, ebuf, NULL);
536  	if (err < 0)
537  		return (err);
538  	return (0);
539  }
540  #ifdef DL_HP_RAWDLS
541  static int
542  dl_dohpuxbind(int fd, char *ebuf)
543  {
544  	int hpsap;
545  	int uerror;
546  	bpf_u_int32 buf[MAXDLBUF];
547  	hpsap = 22;
548  	for (;;) {
549  		if (dlbindreq(fd, hpsap, ebuf) < 0)
550  			return (-1);
551  		if (dlbindack(fd, (char *)buf, ebuf, &uerror) >= 0)
552  			break;
553  		if (uerror != EBUSY) {
554  			return (-1);
555  		}
556  		*ebuf = '\0';
557  		hpsap++;
558  		if (hpsap > 100) {
559  			pcap_strlcpy(ebuf,
560  			    "All SAPs from 22 through 100 are in use",
561  			    PCAP_ERRBUF_SIZE);
562  			return (-1);
563  		}
564  	}
565  	return (0);
566  }
567  #endif
568  #define STRINGIFY(n)	#n
569  static int
570  dlpromiscon(pcap_t *p, bpf_u_int32 level)
571  {
572  	dl_promiscon_req_t req;
573  	bpf_u_int32 buf[MAXDLBUF];
574  	int err;
575  	int uerror;
576  	req.dl_primitive = DL_PROMISCON_REQ;
577  	req.dl_level = level;
578  	if (send_request(p->fd, (char *)&req, sizeof(req), "promiscon",
579  	    p->errbuf) < 0)
580  		return (PCAP_ERROR);
581  	err = dlokack(p->fd, "promiscon" STRINGIFY(level), (char *)buf,
582  	    p->errbuf, &uerror);
583  	if (err < 0) {
584  		if (err == PCAP_ERROR_PERM_DENIED) {
585  			snprintf(p->errbuf, PCAP_ERRBUF_SIZE,
586  			    "Attempt to set promiscuous mode failed with %s - root privilege may be required",
587  			    (uerror == EPERM) ? "EPERM" : "EACCES");
588  			err = PCAP_ERROR_PROMISC_PERM_DENIED;
589  		}
590  		return (err);
591  	}
592  	return (0);
593  }
594  static int
595  is_dlpi_interface(const char *name)
596  {
597  	int fd;
598  	u_int ppa;
599  	char errbuf[PCAP_ERRBUF_SIZE];
600  	fd = open_dlpi_device(name, &ppa, errbuf);
601  	if (fd < 0) {
602  		if (fd == PCAP_ERROR_NO_SUCH_DEVICE) {
603  			return (0);
604  		}
605  		return (1);
606  	}
607  	close(fd);
608  	return (1);
609  }
610  static int
611  get_if_flags(const char *name _U_, bpf_u_int32 *flags _U_, char *errbuf _U_)
612  {
613  	if (*flags & PCAP_IF_LOOPBACK) {
614  		*flags |= PCAP_IF_CONNECTION_STATUS_NOT_APPLICABLE;
615  		return (0);
616  	}
617  	return (0);
618  }
619  int
620  pcap_platform_finddevs(pcap_if_list_t *devlistp, char *errbuf)
621  {
622  #ifdef HAVE_SOLARIS
623  	int fd;
624  	union {
625  		u_int nunits;
626  		char pad[516];	&bsol;* XXX - must be at least 513; is 516
627  				   in "atmgetunits" */
628  	} buf;
629  	char baname[2+1+1];
630  	u_int i;
631  #endif
632  	if (pcap_findalldevs_interfaces(devlistp, errbuf, is_dlpi_interface,
633  	    get_if_flags) == -1)
634  		return (-1);	&bsol;* failure */
635  #ifdef HAVE_SOLARIS
636  	if ((fd = open("/dev/ba", O_RDWR)) < 0) {
637  		return (0);
638  	}
639  	if (strioctl(fd, A_GET_UNITS, sizeof(buf), (char *)&buf) < 0) {
640  		pcap_fmt_errmsg_for_errno(errbuf, PCAP_ERRBUF_SIZE,
641  		    errno, "A_GET_UNITS");
642  		return (-1);
643  	}
644  	for (i = 0; i < buf.nunits; i++) {
645  		snprintf(baname, sizeof baname, "ba%u", i);
646  		if (pcap_add_dev(devlistp, baname, 0, NULL, errbuf) == NULL)
647  			return (-1);
648  	}
649  #endif
650  	return (0);
651  }
652  static int
653  send_request(int fd, char *ptr, int len, char *what, char *ebuf)
654  {
655  	struct	strbuf	ctl;
656  	int	flags;
657  	ctl.maxlen = 0;
658  	ctl.len = len;
659  	ctl.buf = ptr;
660  	flags = 0;
661  	if (putmsg(fd, &ctl, (struct strbuf *) NULL, flags) < 0) {
662  		pcap_fmt_errmsg_for_errno(ebuf, PCAP_ERRBUF_SIZE,
663  		    errno, "send_request: putmsg \"%s\"", what);
664  		return (-1);
665  	}
666  	return (0);
667  }
668  static int
669  recv_ack(int fd, int size, const char *what, char *bufp, char *ebuf, int *uerror)
670  {
671  	union	DL_primitives	*dlp;
672  	struct	strbuf	ctl;
673  	int	flags;
674  	char	errmsgbuf[PCAP_ERRBUF_SIZE];
675  	char	dlprimbuf[64];
676  	if (uerror != NULL)
677  		*uerror = 0;
678  	ctl.maxlen = MAXDLBUF;
679  	ctl.len = 0;
680  	ctl.buf = bufp;
681  	flags = 0;
682  	if (getmsg(fd, &ctl, (struct strbuf*)NULL, &flags) < 0) {
683  		pcap_fmt_errmsg_for_errno(ebuf, PCAP_ERRBUF_SIZE,
684  		    errno, "recv_ack: %s getmsg", what);
685  		return (PCAP_ERROR);
686  	}
687  	dlp = MAKE_DL_PRIMITIVES(ctl.buf);
688  	switch (dlp->dl_primitive) {
689  	case DL_INFO_ACK:
690  	case DL_BIND_ACK:
691  	case DL_OK_ACK:
692  #ifdef DL_HP_PPA_ACK
693  	case DL_HP_PPA_ACK:
694  #endif
695  		break;
696  	case DL_ERROR_ACK:
697  		switch (dlp->error_ack.dl_errno) {
698  		case DL_SYSERR:
699  			if (uerror != NULL)
700  				*uerror = dlp->error_ack.dl_unix_errno;
701  			pcap_fmt_errmsg_for_errno(ebuf, PCAP_ERRBUF_SIZE,
702  			    dlp->error_ack.dl_unix_errno,
703  			    "recv_ack: %s: UNIX error", what);
704  			if (dlp->error_ack.dl_unix_errno == EPERM ||
705  			    dlp->error_ack.dl_unix_errno == EACCES)
706  				return (PCAP_ERROR_PERM_DENIED);
707  			break;
708  		default:
709  			snprintf(ebuf, PCAP_ERRBUF_SIZE,
710  			    "recv_ack: %s: %s", what,
711  			    dlstrerror(errmsgbuf, sizeof (errmsgbuf), dlp->error_ack.dl_errno));
712  			if (dlp->error_ack.dl_errno == DL_BADPPA)
713  				return (PCAP_ERROR_NO_SUCH_DEVICE);
714  			else if (dlp->error_ack.dl_errno == DL_ACCESS)
715  				return (PCAP_ERROR_PERM_DENIED);
716  			break;
717  		}
718  		return (PCAP_ERROR);
719  	default:
720  		snprintf(ebuf, PCAP_ERRBUF_SIZE,
721  		    "recv_ack: %s: Unexpected primitive ack %s",
722  		    what, dlprim(dlprimbuf, sizeof (dlprimbuf), dlp->dl_primitive));
723  		return (PCAP_ERROR);
724  	}
725  	if (ctl.len < size) {
726  		snprintf(ebuf, PCAP_ERRBUF_SIZE,
727  		    "recv_ack: %s: Ack too small (%d < %d)",
728  		    what, ctl.len, size);
729  		return (PCAP_ERROR);
730  	}
731  	return (ctl.len);
732  }
733  static char *
734  dlstrerror(char *errbuf, size_t errbufsize, bpf_u_int32 dl_errno)
735  {
736  	switch (dl_errno) {
737  	case DL_ACCESS:
738  		return ("Improper permissions for request");
739  	case DL_BADADDR:
740  		return ("DLSAP addr in improper format or invalid");
741  	case DL_BADCORR:
742  		return ("Seq number not from outstand DL_CONN_IND");
743  	case DL_BADDATA:
744  		return ("User data exceeded provider limit");
745  	case DL_BADPPA:
746  #ifdef HAVE_DEV_DLPI
747  		return ("Specified PPA was invalid");
748  #else
749  		return ("Specified PPA (device unit) was invalid");
750  #endif
751  	case DL_BADPRIM:
752  		return ("Primitive received not known by provider");
753  	case DL_BADQOSPARAM:
754  		return ("QOS parameters contained invalid values");
755  	case DL_BADQOSTYPE:
756  		return ("QOS structure type is unknown/unsupported");
757  	case DL_BADSAP:
758  		return ("Bad LSAP selector");
759  	case DL_BADTOKEN:
760  		return ("Token used not an active stream");
761  	case DL_BOUND:
762  		return ("Attempted second bind with dl_max_conind");
763  	case DL_INITFAILED:
764  		return ("Physical link initialization failed");
765  	case DL_NOADDR:
766  		return ("Provider couldn't allocate alternate address");
767  	case DL_NOTINIT:
768  		return ("Physical link not initialized");
769  	case DL_OUTSTATE:
770  		return ("Primitive issued in improper state");
771  	case DL_SYSERR:
772  		return ("UNIX system error occurred");
773  	case DL_UNSUPPORTED:
774  		return ("Requested service not supplied by provider");
775  	case DL_UNDELIVERABLE:
776  		return ("Previous data unit could not be delivered");
777  	case DL_NOTSUPPORTED:
778  		return ("Primitive is known but not supported");
779  	case DL_TOOMANY:
780  		return ("Limit exceeded");
781  	case DL_NOTENAB:
782  		return ("Promiscuous mode not enabled");
783  	case DL_BUSY:
784  		return ("Other streams for PPA in post-attached");
785  	case DL_NOAUTO:
786  		return ("Automatic handling XID&TEST not supported");
787  	case DL_NOXIDAUTO:
788  		return ("Automatic handling of XID not supported");
789  	case DL_NOTESTAUTO:
790  		return ("Automatic handling of TEST not supported");
791  	case DL_XIDAUTO:
792  		return ("Automatic handling of XID response");
793  	case DL_TESTAUTO:
794  		return ("Automatic handling of TEST response");
795  	case DL_PENDING:
796  		return ("Pending outstanding connect indications");
797  	default:
798  		snprintf(errbuf, errbufsize, "Error %02x", dl_errno);
799  		return (errbuf);
800  	}
801  }
802  static char *
803  dlprim(char *primbuf, size_t primbufsize, bpf_u_int32 prim)
804  {
805  	switch (prim) {
806  	case DL_INFO_REQ:
807  		return ("DL_INFO_REQ");
808  	case DL_INFO_ACK:
809  		return ("DL_INFO_ACK");
810  	case DL_ATTACH_REQ:
811  		return ("DL_ATTACH_REQ");
812  	case DL_DETACH_REQ:
813  		return ("DL_DETACH_REQ");
814  	case DL_BIND_REQ:
815  		return ("DL_BIND_REQ");
816  	case DL_BIND_ACK:
817  		return ("DL_BIND_ACK");
818  	case DL_UNBIND_REQ:
819  		return ("DL_UNBIND_REQ");
820  	case DL_OK_ACK:
821  		return ("DL_OK_ACK");
822  	case DL_ERROR_ACK:
823  		return ("DL_ERROR_ACK");
824  	case DL_SUBS_BIND_REQ:
825  		return ("DL_SUBS_BIND_REQ");
826  	case DL_SUBS_BIND_ACK:
827  		return ("DL_SUBS_BIND_ACK");
828  	case DL_UNITDATA_REQ:
829  		return ("DL_UNITDATA_REQ");
830  	case DL_UNITDATA_IND:
831  		return ("DL_UNITDATA_IND");
832  	case DL_UDERROR_IND:
833  		return ("DL_UDERROR_IND");
834  	case DL_UDQOS_REQ:
835  		return ("DL_UDQOS_REQ");
836  	case DL_CONNECT_REQ:
837  		return ("DL_CONNECT_REQ");
838  	case DL_CONNECT_IND:
839  		return ("DL_CONNECT_IND");
840  	case DL_CONNECT_RES:
841  		return ("DL_CONNECT_RES");
842  	case DL_CONNECT_CON:
843  		return ("DL_CONNECT_CON");
844  	case DL_TOKEN_REQ:
845  		return ("DL_TOKEN_REQ");
846  	case DL_TOKEN_ACK:
847  		return ("DL_TOKEN_ACK");
848  	case DL_DISCONNECT_REQ:
849  		return ("DL_DISCONNECT_REQ");
850  	case DL_DISCONNECT_IND:
851  		return ("DL_DISCONNECT_IND");
852  	case DL_RESET_REQ:
853  		return ("DL_RESET_REQ");
854  	case DL_RESET_IND:
855  		return ("DL_RESET_IND");
856  	case DL_RESET_RES:
857  		return ("DL_RESET_RES");
858  	case DL_RESET_CON:
859  		return ("DL_RESET_CON");
860  	default:
861  		snprintf(primbuf, primbufsize, "unknown primitive 0x%x",
862  		    prim);
863  		return (primbuf);
864  	}
865  }
866  static int
867  dlbindreq(int fd, bpf_u_int32 sap, char *ebuf)
868  {
869  	dl_bind_req_t	req;
870  	memset((char *)&req, 0, sizeof(req));
871  	req.dl_primitive = DL_BIND_REQ;
872  #if defined(DL_HP_RAWDLS)
873  	req.dl_max_conind = 1;			&bsol;* XXX magic number */
874  	req.dl_service_mode = DL_HP_RAWDLS;
875  #elif defined(DL_CLDLS)
876  	req.dl_service_mode = DL_CLDLS;
877  #endif
878  	req.dl_sap = sap;
879  	return (send_request(fd, (char *)&req, sizeof(req), "bind", ebuf));
880  }
881  static int
882  dlbindack(int fd, char *bufp, char *ebuf, int *uerror)
883  {
884  	return (recv_ack(fd, DL_BIND_ACK_SIZE, "bind", bufp, ebuf, uerror));
885  }
886  static int
887  dlokack(int fd, const char *what, char *bufp, char *ebuf, int *uerror)
888  {
889  	return (recv_ack(fd, DL_OK_ACK_SIZE, what, bufp, ebuf, uerror));
890  }
891  static int
892  dlinforeq(int fd, char *ebuf)
893  {
894  	dl_info_req_t req;
895  	req.dl_primitive = DL_INFO_REQ;
896  	return (send_request(fd, (char *)&req, sizeof(req), "info", ebuf));
897  }
898  static int
899  dlinfoack(int fd, char *bufp, char *ebuf)
900  {
901  	return (recv_ack(fd, DL_INFO_ACK_SIZE, "info", bufp, ebuf, NULL));
902  }
903  #ifdef HAVE_DL_PASSIVE_REQ_T
904  static void
905  dlpassive(int fd, char *ebuf)
906  {
907  	dl_passive_req_t req;
908  	bpf_u_int32 buf[MAXDLBUF];
909  	req.dl_primitive = DL_PASSIVE_REQ;
910  	if (send_request(fd, (char *)&req, sizeof(req), "dlpassive", ebuf) == 0)
911  	    (void) dlokack(fd, "dlpassive", (char *)buf, ebuf, NULL);
912  }
913  #endif
914  #ifdef DL_HP_RAWDLS
915  static int
916  dlrawdatareq(int fd, const u_char *datap, int datalen)
917  {
918  	struct strbuf ctl, data;
919  	long buf[MAXDLBUF];	&bsol;* XXX - char? */
920  	union DL_primitives *dlp;
921  	int dlen;
922  	dlp = MAKE_DL_PRIMITIVES(buf);
923  	dlp->dl_primitive = DL_HP_RAWDATA_REQ;
924  	dlen = DL_HP_RAWDATA_REQ_SIZE;
925  	ctl.maxlen = 0;
926  	ctl.len = dlen;
927  	ctl.buf = (void *)buf;
928  	data.maxlen = 0;
929  	data.len = datalen;
930  	data.buf = (void *)datap;
931  	return (putmsg(fd, &ctl, &data, 0));
932  }
933  #endif &bsol;* DL_HP_RAWDLS */
934  #if defined(HAVE_SOLARIS) && defined(HAVE_SYS_BUFMOD_H)
935  static void
936  get_release(char *buf, size_t bufsize, bpf_u_int32 *majorp,
937      bpf_u_int32 *minorp, bpf_u_int32 *microp)
938  {
939  	char *cp;
940  	*majorp = 0;
941  	*minorp = 0;
942  	*microp = 0;
943  	if (sysinfo(SI_RELEASE, buf, bufsize) < 0) {
944  		pcap_strlcpy(buf, "?", bufsize);
945  		return;
946  	}
947  	cp = buf;
948  	if (!PCAP_ISDIGIT((unsigned char)*cp))
949  		return;
950  	*majorp = strtol(cp, &cp, 10);
951  	if (*cp++ != '.')
952  		return;
953  	*minorp =  strtol(cp, &cp, 10);
954  	if (*cp++ != '.')
955  		return;
956  	*microp =  strtol(cp, &cp, 10);
957  }
958  #endif
959  #ifdef DL_HP_PPA_REQ
960  static int
961  get_dlpi_ppa(register int fd, register const char *device, register u_int unit,
962      u_int *ppa, register char *ebuf)
963  {
964  	register dl_hp_ppa_ack_t *ap;
965  	register dl_hp_ppa_info_t *ipstart, *ip;
966  	register u_int i;
967  	char dname[100];
968  	register u_long majdev;
969  	struct stat statbuf;
970  	dl_hp_ppa_req_t	req;
971  	char buf[MAXDLBUF];
972  	char *ppa_data_buf;
973  	dl_hp_ppa_ack_t	*dlp;
974  	struct strbuf ctl;
975  	int flags;
976  	memset((char *)&req, 0, sizeof(req));
977  	req.dl_primitive = DL_HP_PPA_REQ;
978  	memset((char *)buf, 0, sizeof(buf));
979  	if (send_request(fd, (char *)&req, sizeof(req), "hpppa", ebuf) < 0)
980  		return (PCAP_ERROR);
981  	ctl.maxlen = DL_HP_PPA_ACK_SIZE;
982  	ctl.len = 0;
983  	ctl.buf = (char *)buf;
984  	flags = 0;
985  	if (getmsg(fd, &ctl, (struct strbuf *)NULL, &flags) < 0) {
986  		pcap_fmt_errmsg_for_errno(ebuf, PCAP_ERRBUF_SIZE,
987  		    errno, "get_dlpi_ppa: hpppa getmsg");
988  		return (PCAP_ERROR);
989  	}
990  	if (ctl.len == -1) {
991  		snprintf(ebuf, PCAP_ERRBUF_SIZE,
992  		    "get_dlpi_ppa: hpppa getmsg: control buffer has no data");
993  		return (PCAP_ERROR);
994  	}
995  	dlp = (dl_hp_ppa_ack_t *)ctl.buf;
996  	if (dlp->dl_primitive != DL_HP_PPA_ACK) {
997  		snprintf(ebuf, PCAP_ERRBUF_SIZE,
998  		    "get_dlpi_ppa: hpppa unexpected primitive ack 0x%x",
999  		    (bpf_u_int32)dlp->dl_primitive);
1000  		return (PCAP_ERROR);
1001  	}
1002  	if ((size_t)ctl.len < DL_HP_PPA_ACK_SIZE) {
1003  		snprintf(ebuf, PCAP_ERRBUF_SIZE,
1004  		    "get_dlpi_ppa: hpppa ack too small (%d < %lu)",
1005  		     ctl.len, (unsigned long)DL_HP_PPA_ACK_SIZE);
1006  		return (PCAP_ERROR);
1007  	}
1008  	if ((ppa_data_buf = (char *)malloc(dlp->dl_length)) == NULL) {
1009  		pcap_fmt_errmsg_for_errno(ebuf, PCAP_ERRBUF_SIZE,
1010  		    errno, "get_dlpi_ppa: hpppa malloc");
1011  		return (PCAP_ERROR);
1012  	}
1013  	ctl.maxlen = dlp->dl_length;
1014  	ctl.len = 0;
1015  	ctl.buf = (char *)ppa_data_buf;
1016  	if (getmsg(fd, &ctl, (struct strbuf *)NULL, &flags) < 0) {
1017  		pcap_fmt_errmsg_for_errno(ebuf, PCAP_ERRBUF_SIZE,
1018  		    errno, "get_dlpi_ppa: hpppa getmsg");
1019  		free(ppa_data_buf);
1020  		return (PCAP_ERROR);
1021  	}
1022  	if (ctl.len == -1) {
1023  		snprintf(ebuf, PCAP_ERRBUF_SIZE,
1024  		    "get_dlpi_ppa: hpppa getmsg: control buffer has no data");
1025  		return (PCAP_ERROR);
1026  	}
1027  	if ((u_int)ctl.len < dlp->dl_length) {
1028  		snprintf(ebuf, PCAP_ERRBUF_SIZE,
1029  		    "get_dlpi_ppa: hpppa ack too small (%d < %lu)",
1030  		    ctl.len, (unsigned long)dlp->dl_length);
1031  		free(ppa_data_buf);
1032  		return (PCAP_ERROR);
1033  	}
1034  	ap = (dl_hp_ppa_ack_t *)buf;
1035  	ipstart = (dl_hp_ppa_info_t *)ppa_data_buf;
1036  	ip = ipstart;
1037  #ifdef HAVE_DL_HP_PPA_INFO_T_DL_MODULE_ID_1
1038  	for (i = 0; i < ap->dl_count; i++) {
1039  		if ((strcmp((const char *)ip->dl_module_id_1, device) == 0 ||
1040  		     strcmp((const char *)ip->dl_module_id_2, device) == 0) &&
1041  		    ip->dl_instance_num == unit)
1042  			break;
1043  		ip = (dl_hp_ppa_info_t *)((u_char *)ipstart + ip->dl_next_offset);
1044  	}
1045  #else
1046  	i = ap->dl_count;
1047  #endif
1048  	if (i == ap->dl_count) {
1049  		snprintf(dname, sizeof(dname), "/dev/%s%u", device, unit);
1050  		if (stat(dname, &statbuf) < 0) {
1051  			pcap_fmt_errmsg_for_errno(ebuf, PCAP_ERRBUF_SIZE,
1052  			    errno, "stat: %s", dname);
1053  			return (PCAP_ERROR);
1054  		}
1055  		majdev = major(statbuf.st_rdev);
1056  		ip = ipstart;
1057  		for (i = 0; i < ap->dl_count; i++) {
1058  			if (ip->dl_mjr_num == majdev &&
1059  			    ip->dl_instance_num == unit)
1060  				break;
1061  			ip = (dl_hp_ppa_info_t *)((u_char *)ipstart + ip->dl_next_offset);
1062  		}
1063  	}
1064  	if (i == ap->dl_count) {
1065  		snprintf(ebuf, PCAP_ERRBUF_SIZE,
1066  		    "can't find /dev/dlpi PPA for %s%u", device, unit);
1067  		return (PCAP_ERROR_NO_SUCH_DEVICE);
1068  	}
1069  	if (ip->dl_hdw_state == HDW_DEAD) {
1070  		snprintf(ebuf, PCAP_ERRBUF_SIZE,
1071  		    "%s%d: hardware state: DOWN\n", device, unit);
1072  		free(ppa_data_buf);
1073  		return (PCAP_ERROR);
1074  	}
1075  	*ppa = ip->dl_ppa;
1076  	free(ppa_data_buf);
1077  	return (0);
1078  }
1079  #endif
1080  #ifdef HAVE_HPUX9
1081  static struct nlist nl[] = {
1082  #define NL_IFNET 0
1083  	{ "ifnet" },
1084  	{ "" }
1085  };
1086  static char path_vmunix[] = "/hp-ux";
1087  static int
1088  get_dlpi_ppa(register int fd, register const char *ifname, register u_int unit,
1089      u_int *ppa, register char *ebuf)
1090  {
1091  	register const char *cp;
1092  	register int kd;
1093  	void *addr;
1094  	struct ifnet ifnet;
1095  	char if_name[sizeof(ifnet.if_name) + 1];
1096  	cp = strrchr(ifname, '/');
1097  	if (cp != NULL)
1098  		ifname = cp + 1;
1099  	if (nlist(path_vmunix, &nl) < 0) {
1100  		snprintf(ebuf, PCAP_ERRBUF_SIZE, "nlist %s failed",
1101  		    path_vmunix);
1102  		return (PCAP_ERROR);
1103  	}
1104  	if (nl[NL_IFNET].n_value == 0) {
1105  		snprintf(ebuf, PCAP_ERRBUF_SIZE,
1106  		    "couldn't find %s kernel symbol",
1107  		    nl[NL_IFNET].n_name);
1108  		return (PCAP_ERROR);
1109  	}
1110  	kd = open("/dev/kmem", O_RDONLY);
1111  	if (kd < 0) {
1112  		pcap_fmt_errmsg_for_errno(ebuf, PCAP_ERRBUF_SIZE,
1113  		    errno, "kmem open");
1114  		return (PCAP_ERROR);
1115  	}
1116  	if (dlpi_kread(kd, nl[NL_IFNET].n_value,
1117  	    &addr, sizeof(addr), ebuf) < 0) {
1118  		close(kd);
1119  		return (PCAP_ERROR);
1120  	}
1121  	for (; addr != NULL; addr = ifnet.if_next) {
1122  		if (dlpi_kread(kd, (off_t)addr,
1123  		    &ifnet, sizeof(ifnet), ebuf) < 0 ||
1124  		    dlpi_kread(kd, (off_t)ifnet.if_name,
1125  		    if_name, sizeof(ifnet.if_name), ebuf) < 0) {
1126  			(void)close(kd);
1127  			return (PCAP_ERROR);
1128  		}
1129  		if_name[sizeof(ifnet.if_name)] = '\0';
1130  		if (strcmp(if_name, ifname) == 0 && ifnet.if_unit == unit) {
1131  			*ppa = ifnet.if_index;
1132  			return (0);
1133  		}
1134  	}
1135  	snprintf(ebuf, PCAP_ERRBUF_SIZE, "Can't find %s", ifname);
1136  	return (PCAP_ERROR_NO_SUCH_DEVICE);
1137  }
1138  static int
1139  dlpi_kread(register int fd, register off_t addr,
1140      register void *buf, register u_int len, register char *ebuf)
1141  {
1142  	register int cc;
1143  	if (lseek(fd, addr, SEEK_SET) < 0) {
1144  		pcap_fmt_errmsg_for_errno(ebuf, PCAP_ERRBUF_SIZE,
1145  		    errno, "lseek");
1146  		return (-1);
1147  	}
1148  	cc = read(fd, buf, len);
1149  	if (cc < 0) {
1150  		pcap_fmt_errmsg_for_errno(ebuf, PCAP_ERRBUF_SIZE,
1151  		    errno, "read");
1152  		return (-1);
1153  	} else if (cc != len) {
1154  		snprintf(ebuf, PCAP_ERRBUF_SIZE, "short read (%d != %d)", cc,
1155  		    len);
1156  		return (-1);
1157  	}
1158  	return (cc);
1159  }
1160  #endif
1161  pcap_t *
1162  pcap_create_interface(const char *device _U_, char *ebuf)
1163  {
1164  	pcap_t *p;
1165  #ifdef DL_HP_RAWDLS
1166  	struct pcap_dlpi *pd;
1167  #endif
1168  	p = PCAP_CREATE_COMMON(ebuf, struct pcap_dlpi);
1169  	if (p == NULL)
1170  		return (NULL);
1171  #ifdef DL_HP_RAWDLS
1172  	pd = p->priv;
1173  	pd->send_fd = -1;	&bsol;* it hasn't been opened yet */
1174  #endif
1175  	p->activate_op = pcap_activate_dlpi;
1176  	return (p);
1177  }
1178  const char *
1179  pcap_lib_version(void)
1180  {
1181  	return (PCAP_VERSION_STRING);
1182  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from libpcap-MDEwOlJlcG9zaXRvcnk5NDM1ODg3-flat-pcap-dlpi.c</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from libpcap-MDEwOlJlcG9zaXRvcnk5NDM1ODg3-flat-pcap-dlpi.c</div>
                </div>
                <div class="column column_space"><pre><code>443  		status = PCAP_ERROR;
444  		pcap_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,
445  		    errno, "DLIOCRAW");
446  		goto bad;
</pre></code></div>
                <div class="column column_space"><pre><code>378  			status = PCAP_ERROR;
379  			pcap_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,
380  			    errno, "A_PROMISCON_REQ");
381  			goto bad;
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    