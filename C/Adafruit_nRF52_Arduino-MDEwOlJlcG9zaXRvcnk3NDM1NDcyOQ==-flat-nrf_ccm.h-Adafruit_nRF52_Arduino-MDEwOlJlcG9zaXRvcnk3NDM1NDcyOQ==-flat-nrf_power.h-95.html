
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 21, <button onclick='openModal()' class='match'>CODE CLONE</button></h2>
        <div class="column">
            <h3>Adafruit_nRF52_Arduino-MDEwOlJlcG9zaXRvcnk3NDM1NDcyOQ==-flat-nrf_ccm.h</h3>
            <pre><code>1  #ifndef NRF_CCM_H__
2  #define NRF_CCM_H__
3  #include &lt;nrfx.h&gt;
4  #ifdef __cplusplus
5  extern &quot;C&quot; {
6  #endif
7  typedef enum
8  {
9      NRF_CCM_TASK_KSGEN        = offsetof(NRF_CCM_Type, TASKS_KSGEN),        
10      NRF_CCM_TASK_CRYPT        = offsetof(NRF_CCM_Type, TASKS_CRYPT),        
11      NRF_CCM_TASK_STOP         = offsetof(NRF_CCM_Type, TASKS_STOP),         
12  #if defined(CCM_RATEOVERRIDE_RATEOVERRIDE_Pos) || defined(__NRFX_DOXYGEN__)
13      NRF_CCM_TASK_RATEOVERRIDE = offsetof(NRF_CCM_Type, TASKS_RATEOVERRIDE), 
14  #endif
15  } nrf_ccm_task_t;
16  typedef enum
17  {
18      NRF_CCM_EVENT_ENDKSGEN = offsetof(NRF_CCM_Type, EVENTS_ENDKSGEN), 
19      NRF_CCM_EVENT_ENDCRYPT = offsetof(NRF_CCM_Type, EVENTS_ENDCRYPT), 
20      NRF_CCM_EVENT_ERROR    = offsetof(NRF_CCM_Type, EVENTS_ERROR),    
21  } nrf_ccm_event_t;
22  typedef enum
23  {
24      NRF_CCM_INT_ENDKSGEN_MASK  = CCM_INTENSET_ENDKSGEN_Msk, 
25      NRF_CCM_INT_ENDCRYPT_MASK  = CCM_INTENSET_ENDCRYPT_Msk, 
26      NRF_CCM_INT_ERROR_MASK     = CCM_INTENSET_ERROR_Msk,    
27  } nrf_ccm_int_mask_t;
28  typedef enum
29  {
30      NRF_CCM_MODE_ENCRYPTION = CCM_MODE_MODE_Encryption, 
31      NRF_CCM_MODE_DECRYPTION = CCM_MODE_MODE_Decryption, 
32  } nrf_ccm_mode_t;
33  #if defined(CCM_MODE_DATARATE_Pos) || defined(__NRFX_DOXYGEN__)
34  typedef enum
35  {
36      NRF_CCM_DATARATE_1M   = CCM_MODE_DATARATE_1Mbit,   
37      NRF_CCM_DATARATE_2M   = CCM_MODE_DATARATE_2Mbit,   
38  #if defined(CCM_MODE_DATARATE_125Kbps) || defined(__NRFX_DOXYGEN__)
39      NRF_CCM_DATARATE_125K = CCM_MODE_DATARATE_125Kbps, 
40  #endif
41  #if defined(CCM_MODE_DATARATE_500Kbps) || defined(__NRFX_DOXYGEN__)
42      NRF_CCM_DATARATE_500K = CCM_MODE_DATARATE_500Kbps, 
43  #endif
44  } nrf_ccm_datarate_t;
45  #endif 
46  #if defined(CCM_MODE_LENGTH_Pos) || defined(__NRFX_DOXYGEN__)
47  typedef enum
48  {
49      NRF_CCM_LENGTH_DEFAULT  = CCM_MODE_LENGTH_Default,  
50      NRF_CCM_LENGTH_EXTENDED = CCM_MODE_LENGTH_Extended, 
51  } nrf_ccm_length_t;
52  #endif 
53  typedef struct {
54      nrf_ccm_mode_t     mode;     
55  #if defined(CCM_MODE_DATARATE_Pos) || defined(__NRFX_DOXYGEN__)
56      nrf_ccm_datarate_t datarate; 
57  #endif
58  #if defined(CCM_MODE_LENGTH_Pos) || defined(__NRFX_DOXYGEN__)
59      nrf_ccm_length_t   length;   
60  #endif
61  } nrf_ccm_config_t;
<span onclick='openModal()' class='match'>62  NRF_STATIC_INLINE void nrf_ccm_task_trigger(NRF_CCM_Type * p_reg,
63                                              nrf_ccm_task_t task);
64  NRF_STATIC_INLINE uint32_t nrf_ccm_task_address_get(NRF_CCM_Type const * p_reg,
65                                                      nrf_ccm_task_t       task);
</span>66  NRF_STATIC_INLINE void nrf_ccm_event_clear(NRF_CCM_Type *  p_reg,
67                                             nrf_ccm_event_t event);
68  NRF_STATIC_INLINE bool nrf_ccm_event_check(NRF_CCM_Type const * p_reg,
69                                             nrf_ccm_event_t      event);
70  NRF_STATIC_INLINE uint32_t nrf_ccm_event_address_get(NRF_CCM_Type const * p_reg,
71                                                       nrf_ccm_event_t      event);
72  NRF_STATIC_INLINE void nrf_ccm_int_enable(NRF_CCM_Type * p_reg, uint32_t mask);
73  NRF_STATIC_INLINE void nrf_ccm_int_disable(NRF_CCM_Type * p_reg, uint32_t mask);
74  NRF_STATIC_INLINE uint32_t nrf_ccm_int_enable_check(NRF_CCM_Type const * p_reg, uint32_t mask);
75  NRF_STATIC_INLINE void nrf_ccm_enable(NRF_CCM_Type * p_reg);
76  NRF_STATIC_INLINE void nrf_ccm_disable(NRF_CCM_Type * p_reg);
77  NRF_STATIC_INLINE void nrf_ccm_configure(NRF_CCM_Type *           p_reg,
78                                           nrf_ccm_config_t const * p_config);
79  #if defined(CCM_MAXPACKETSIZE_MAXPACKETSIZE_Pos) || defined(__NRFX_DOXYGEN__)
80  NRF_STATIC_INLINE void nrf_ccm_maxpacketsize_set(NRF_CCM_Type * p_reg,
81                                                   uint8_t        size);
82  #endif 
83  NRF_STATIC_INLINE bool nrf_ccm_micstatus_get(NRF_CCM_Type const * p_reg);
84  NRF_STATIC_INLINE void nrf_ccm_cnfptr_set(NRF_CCM_Type *   p_reg,
85                                            uint32_t const * p_data);
86  NRF_STATIC_INLINE uint32_t * nrf_ccm_cnfptr_get(NRF_CCM_Type const * p_reg);
87  NRF_STATIC_INLINE void nrf_ccm_inptr_set(NRF_CCM_Type *   p_reg,
88                                           uint32_t const * p_data);
89  NRF_STATIC_INLINE uint32_t * nrf_ccm_inptr_get(NRF_CCM_Type const * p_reg);
90  NRF_STATIC_INLINE void nrf_ccm_outptr_set(NRF_CCM_Type *   p_reg,
91                                            uint32_t const * p_data);
92  NRF_STATIC_INLINE uint32_t * nrf_ccm_outptr_get(NRF_CCM_Type const * p_reg);
93  NRF_STATIC_INLINE void nrf_ccm_scratchptr_set(NRF_CCM_Type *   p_reg,
94                                                uint32_t const * p_area);
95  NRF_STATIC_INLINE uint32_t * nrf_ccm_stratchptr_get(NRF_CCM_Type const * p_reg);
96  #if defined(CCM_RATEOVERRIDE_RATEOVERRIDE_Pos) || defined(__NRFX_DOXYGEN__)
97  NRF_STATIC_INLINE void nrf_ccm_datarate_override_set(NRF_CCM_Type *     p_reg,
98                                                       nrf_ccm_datarate_t datarate);
99  #endif 
100  #ifndef NRF_DECLARE_ONLY
101  NRF_STATIC_INLINE void nrf_ccm_task_trigger(NRF_CCM_Type * p_reg,
102                                              nrf_ccm_task_t task)
103  {
104      *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
105  }
106  NRF_STATIC_INLINE uint32_t nrf_ccm_task_address_get(NRF_CCM_Type const * p_reg,
107                                                      nrf_ccm_task_t       task)
108  {
109      return ((uint32_t)p_reg + (uint32_t)task);
110  }
111  NRF_STATIC_INLINE void nrf_ccm_event_clear(NRF_CCM_Type *  p_reg,
112                                             nrf_ccm_event_t event)
113  {
114      *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
115  #if __CORTEX_M == 0x04
116      volatile uint32_t dummy = *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event));
117      (void)dummy;
118  #endif
119  }
120  NRF_STATIC_INLINE bool nrf_ccm_event_check(NRF_CCM_Type const * p_reg,
121                                             nrf_ccm_event_t      event)
122  {
123      return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
124  }
125  NRF_STATIC_INLINE uint32_t nrf_ccm_event_address_get(NRF_CCM_Type const * p_reg,
126                                                       nrf_ccm_event_t      event)
127  {
128      return ((uint32_t)p_reg + (uint32_t)event);
129  }
130  NRF_STATIC_INLINE void nrf_ccm_int_enable(NRF_CCM_Type * p_reg, uint32_t mask)
131  {
132      p_reg-&gt;INTENSET = mask;
133  }
134  NRF_STATIC_INLINE void nrf_ccm_int_disable(NRF_CCM_Type * p_reg, uint32_t mask)
135  {
136      p_reg-&gt;INTENCLR = mask;
137  }
138  NRF_STATIC_INLINE uint32_t nrf_ccm_int_enable_check(NRF_CCM_Type const * p_reg, uint32_t mask)
139  {
140      return p_reg-&gt;INTENSET &amp; mask;
141  }
142  NRF_STATIC_INLINE void nrf_ccm_enable(NRF_CCM_Type * p_reg)
143  {
144      p_reg-&gt;ENABLE = (CCM_ENABLE_ENABLE_Enabled &lt;&lt; CCM_ENABLE_ENABLE_Pos);
145  }
146  NRF_STATIC_INLINE void nrf_ccm_disable(NRF_CCM_Type * p_reg)
147  {
148      p_reg-&gt;ENABLE = (CCM_ENABLE_ENABLE_Disabled &lt;&lt; CCM_ENABLE_ENABLE_Pos);
149  }
150  NRF_STATIC_INLINE void nrf_ccm_configure(NRF_CCM_Type *           p_reg,
151                                           nrf_ccm_config_t const * p_config)
152  {
153      p_reg-&gt;MODE = (((uint32_t)p_config-&gt;mode     &lt;&lt; CCM_MODE_MODE_Pos) |
154  #if defined(CCM_MODE_DATARATE_Pos)
155                     ((uint32_t)p_config-&gt;datarate &lt;&lt; CCM_MODE_DATARATE_Pos) |
156  #endif
157  #if defined(CCM_MODE_LENGTH_Pos)
158                     ((uint32_t)p_config-&gt;length   &lt;&lt; CCM_MODE_LENGTH_Pos) |
159  #endif
160                     0);
161  }
162  #if defined(CCM_MAXPACKETSIZE_MAXPACKETSIZE_Pos)
163  NRF_STATIC_INLINE void nrf_ccm_maxpacketsize_set(NRF_CCM_Type * p_reg,
164                                                   uint8_t        size)
165  {
166      NRFX_ASSERT((size &gt;= 0x1B) &amp;&amp; (size &lt;= 0xFB));
167      p_reg-&gt;MAXPACKETSIZE = size;
168  }
169  #endif 
170  NRF_STATIC_INLINE bool nrf_ccm_micstatus_get(NRF_CCM_Type const * p_reg)
171  {
172      return (bool)(p_reg-&gt;MICSTATUS);
173  }
174  NRF_STATIC_INLINE void nrf_ccm_cnfptr_set(NRF_CCM_Type *   p_reg,
175                                            uint32_t const * p_data)
176  {
177      p_reg-&gt;CNFPTR = (uint32_t)p_data;
178  }
179  NRF_STATIC_INLINE uint32_t * nrf_ccm_cnfptr_get(NRF_CCM_Type const * p_reg)
180  {
181  #if defined(NRF5340_XXAA_NETWORK)
182      return (uint32_t *)(p_reg-&gt;CNFPTR | 0x01000000);
183  #else
184      return (uint32_t *)(p_reg-&gt;CNFPTR);
185  #endif
186  }
187  NRF_STATIC_INLINE void nrf_ccm_inptr_set(NRF_CCM_Type *   p_reg,
188                                           uint32_t const * p_data)
189  {
190      p_reg-&gt;INPTR = (uint32_t)p_data;
191  }
192  NRF_STATIC_INLINE uint32_t * nrf_ccm_inptr_get(NRF_CCM_Type const * p_reg)
193  {
194  #if defined(NRF5340_XXAA_NETWORK)
195      return (uint32_t *)(p_reg-&gt;INPTR | 0x01000000);
196  #else
197      return (uint32_t *)(p_reg-&gt;INPTR);
198  #endif
199  }
200  NRF_STATIC_INLINE void nrf_ccm_outptr_set(NRF_CCM_Type *   p_reg,
201                                            uint32_t const * p_data)
202  {
203      p_reg-&gt;OUTPTR = (uint32_t)p_data;
204  }
205  NRF_STATIC_INLINE uint32_t * nrf_ccm_outptr_get(NRF_CCM_Type const * p_reg)
206  {
207  #if defined(NRF5340_XXAA_NETWORK)
208      return (uint32_t *)(p_reg-&gt;OUTPTR | 0x01000000);
209  #else
210      return (uint32_t *)(p_reg-&gt;OUTPTR);
211  #endif
212  }
213  NRF_STATIC_INLINE void nrf_ccm_scratchptr_set(NRF_CCM_Type *   p_reg,
214                                                uint32_t const * p_area)
215  {
216      p_reg-&gt;SCRATCHPTR = (uint32_t)p_area;
217  }
218  NRF_STATIC_INLINE uint32_t * nrf_ccm_stratchptr_get(NRF_CCM_Type const * p_reg)
219  {
220  #if defined(NRF5340_XXAA_NETWORK)
221      return (uint32_t *)(p_reg-&gt;SCRATCHPTR | 0x01000000);
222  #else
223      return (uint32_t *)(p_reg-&gt;SCRATCHPTR);
224  #endif
225  }
226  #if defined(CCM_RATEOVERRIDE_RATEOVERRIDE_Pos)
227  NRF_STATIC_INLINE void nrf_ccm_datarate_override_set(NRF_CCM_Type *     p_reg,
228                                                       nrf_ccm_datarate_t datarate)
229  {
230      p_reg-&gt;RATEOVERRIDE = ((uint32_t)datarate &lt;&lt; CCM_RATEOVERRIDE_RATEOVERRIDE_Pos);
231  }
232  #endif
233  #endif 
234  #ifdef __cplusplus
235  }
236  #endif
237  #endif  
</code></pre>
        </div>
        <div class="column">
            <h3>Adafruit_nRF52_Arduino-MDEwOlJlcG9zaXRvcnk3NDM1NDcyOQ==-flat-nrf_power.h</h3>
            <pre><code>1  #ifndef NRF_POWER_H__
2  #define NRF_POWER_H__
3  #include &lt;nrfx.h&gt;
4  #ifdef __cplusplus
5  extern &quot;C&quot; {
6  #endif
7  #if defined(POWER_INTENSET_SLEEPENTER_Msk) || defined(__NRFX_DOXYGEN__)
8  #define NRF_POWER_HAS_SLEEPEVT 1
9  #else
10  #define NRF_POWER_HAS_SLEEPEVT 0
11  #endif
12  #if defined(POWER_USBREGSTATUS_VBUSDETECT_Msk) || defined(__NRFX_DOXYGEN__)
13  #define NRF_POWER_HAS_USBREG 1
14  #else
15  #define NRF_POWER_HAS_USBREG 0
16  #endif
17  #if defined(POWER_DCDCEN0_DCDCEN_Msk) || defined(__NRFX_DOXYGEN__)
18  #define NRF_POWER_HAS_DCDCEN_VDDH 1
19  #else
20  #define NRF_POWER_HAS_DCDCEN_VDDH 0
21  #endif
22  #if defined(POWER_DCDCEN_DCDCEN_Msk) || defined(__NRFX_DOXYGEN__)
23  #define NRF_POWER_HAS_DCDCEN 1
24  #else
25  #define NRF_POWER_HAS_DCDCEN 0
26  #endif
27  #if defined(POWER_INTENSET_POFWARN_Msk) || defined(__NRFX_DOXYGEN__)
28  #define NRF_POWER_HAS_POFWARN 1
29  #else
30  #define NRF_POWER_HAS_POFWARN 0
31  #endif
32  #if defined(POWER_POFCON_THRESHOLD_Msk) || defined(__NRFX_DOXYGEN__)
33  #define NRF_POWER_HAS_POFCON 1
34  #else
35  #define NRF_POWER_HAS_POFCON 0
36  #endif
37  #if defined(POWER_POFCON_THRESHOLDVDDH_Msk) || defined(__NRFX_DOXYGEN__)
38  #define NRF_POWER_HAS_POFCON_VDDH 1
39  #else
40  #define NRF_POWER_HAS_POFCON_VDDH 0
41  #endif
42  #if defined(POWER_RESETREAS_RESETPIN_Msk) || defined(__NRFX_DOXYGEN__)
43  #define NRF_POWER_HAS_RESETREAS 1
44  #else
45  #define NRF_POWER_HAS_RESETREAS 0
46  #endif
47  #if defined(POWER_MAINREGSTATUS_MAINREGSTATUS_Msk) || defined(__NRFX_DOXYGEN__)
48  #define NRF_POWER_HAS_MAINREGSTATUS 1
49  #else
50  #define NRF_POWER_HAS_MAINREGSTATUS 0
51  #endif
52  typedef enum
53  {
54      NRF_POWER_TASK_CONSTLAT  = offsetof(NRF_POWER_Type, TASKS_CONSTLAT), &amp;bsol;**&lt; Enable constant latency mode. */
55      NRF_POWER_TASK_LOWPWR    = offsetof(NRF_POWER_Type, TASKS_LOWPWR  ), &amp;bsol;**&lt; Enable low-power mode (variable latency). */
56  } nrf_power_task_t;
57  typedef enum
58  {
59  #if NRF_POWER_HAS_POFWARN
60      NRF_POWER_EVENT_POFWARN      = offsetof(NRF_POWER_Type, EVENTS_POFWARN    ), &amp;bsol;**&lt; Power failure warning. */
61  #endif
62  #if NRF_POWER_HAS_SLEEPEVT
63      NRF_POWER_EVENT_SLEEPENTER   = offsetof(NRF_POWER_Type, EVENTS_SLEEPENTER ), &amp;bsol;**&lt; CPU entered WFI/WFE sleep. */
64      NRF_POWER_EVENT_SLEEPEXIT    = offsetof(NRF_POWER_Type, EVENTS_SLEEPEXIT  ), &amp;bsol;**&lt; CPU exited WFI/WFE sleep. */
65  #endif
66  #if NRF_POWER_HAS_USBREG
67      NRF_POWER_EVENT_USBDETECTED  = offsetof(NRF_POWER_Type, EVENTS_USBDETECTED), &amp;bsol;**&lt; Voltage supply detected on VBUS. */
68      NRF_POWER_EVENT_USBREMOVED   = offsetof(NRF_POWER_Type, EVENTS_USBREMOVED ), &amp;bsol;**&lt; Voltage supply removed from VBUS. */
69      NRF_POWER_EVENT_USBPWRRDY    = offsetof(NRF_POWER_Type, EVENTS_USBPWRRDY  ), &amp;bsol;**&lt; USB 3.3&amp;nbsp;V supply ready. */
70  #endif
71  } nrf_power_event_t;
72  typedef enum
73  {
74  #if NRF_POWER_HAS_POFWARN
75      NRF_POWER_INT_POFWARN_MASK     = POWER_INTENSET_POFWARN_Msk    , &amp;bsol;**&lt; Write &#x27;1&#x27; to Enable interrupt for POFWARN event. */
76  #endif
77  #if NRF_POWER_HAS_SLEEPEVT
78      NRF_POWER_INT_SLEEPENTER_MASK  = POWER_INTENSET_SLEEPENTER_Msk , &amp;bsol;**&lt; Write &#x27;1&#x27; to Enable interrupt for SLEEPENTER event. */
79      NRF_POWER_INT_SLEEPEXIT_MASK   = POWER_INTENSET_SLEEPEXIT_Msk  , &amp;bsol;**&lt; Write &#x27;1&#x27; to Enable interrupt for SLEEPEXIT event. */
80  #endif
81  #if NRF_POWER_HAS_USBREG
82      NRF_POWER_INT_USBDETECTED_MASK = POWER_INTENSET_USBDETECTED_Msk, &amp;bsol;**&lt; Write &#x27;1&#x27; to Enable interrupt for USBDETECTED event. */
83      NRF_POWER_INT_USBREMOVED_MASK  = POWER_INTENSET_USBREMOVED_Msk , &amp;bsol;**&lt; Write &#x27;1&#x27; to Enable interrupt for USBREMOVED event. */
84      NRF_POWER_INT_USBPWRRDY_MASK   = POWER_INTENSET_USBPWRRDY_Msk  , &amp;bsol;**&lt; Write &#x27;1&#x27; to Enable interrupt for USBPWRRDY event. */
85  #endif
86  } nrf_power_int_mask_t;
87  #if NRF_POWER_HAS_RESETREAS
88  typedef enum
89  {
90      NRF_POWER_RESETREAS_RESETPIN_MASK = POWER_RESETREAS_RESETPIN_Msk, &amp;bsol;**&lt; Bit mask of RESETPIN field. */
91      NRF_POWER_RESETREAS_DOG_MASK      = POWER_RESETREAS_DOG_Msk     , &amp;bsol;**&lt; Bit mask of DOG field. */
92      NRF_POWER_RESETREAS_SREQ_MASK     = POWER_RESETREAS_SREQ_Msk    , &amp;bsol;**&lt; Bit mask of SREQ field. */
93      NRF_POWER_RESETREAS_LOCKUP_MASK   = POWER_RESETREAS_LOCKUP_Msk  , &amp;bsol;**&lt; Bit mask of LOCKUP field. */
94      NRF_POWER_RESETREAS_OFF_MASK      = POWER_RESETREAS_OFF_Msk     , &amp;bsol;**&lt; Bit mask of OFF field. */
95  #if defined(POWER_RESETREAS_LPCOMP_Msk) || defined(__NRFX_DOXYGEN__)
96      NRF_POWER_RESETREAS_LPCOMP_MASK   = POWER_RESETREAS_LPCOMP_Msk  , &amp;bsol;**&lt; Bit mask of LPCOMP field. */
97  #endif
98      NRF_POWER_RESETREAS_DIF_MASK      = POWER_RESETREAS_DIF_Msk     , &amp;bsol;**&lt; Bit mask of DIF field. */
99  #if defined(POWER_RESETREAS_NFC_Msk) || defined(__NRFX_DOXYGEN__)
100      NRF_POWER_RESETREAS_NFC_MASK      = POWER_RESETREAS_NFC_Msk     , &amp;bsol;**&lt; Bit mask of NFC field. */
101  #endif
102  #if defined(POWER_RESETREAS_VBUS_Msk) || defined(__NRFX_DOXYGEN__)
103      NRF_POWER_RESETREAS_VBUS_MASK     = POWER_RESETREAS_VBUS_Msk    , &amp;bsol;**&lt; Bit mask of VBUS field. */
104  #endif
105  } nrf_power_resetreas_mask_t;
106  #endif 
107  #if NRF_POWER_HAS_USBREG
108  typedef enum
109  {
110      NRF_POWER_USBREGSTATUS_VBUSDETECT_MASK = POWER_USBREGSTATUS_VBUSDETECT_Msk, &amp;bsol;**&lt; USB detected or removed.     */
111      NRF_POWER_USBREGSTATUS_OUTPUTRDY_MASK  = POWER_USBREGSTATUS_OUTPUTRDY_Msk   &amp;bsol;**&lt; USB 3.3&amp;nbsp;V supply ready. */
112  } nrf_power_usbregstatus_mask_t;
113  #endif 
114  #if defined(POWER_RAMSTATUS_RAMBLOCK0_Msk) || defined(__NRFX_DOXYGEN__)
115  typedef enum
116  {
117      NRF_POWER_RAMBLOCK0 = POWER_RAMSTATUS_RAMBLOCK0_Pos,
118      NRF_POWER_RAMBLOCK1 = POWER_RAMSTATUS_RAMBLOCK1_Pos,
119      NRF_POWER_RAMBLOCK2 = POWER_RAMSTATUS_RAMBLOCK2_Pos,
120      NRF_POWER_RAMBLOCK3 = POWER_RAMSTATUS_RAMBLOCK3_Pos
121  } nrf_power_ramblock_t;
122  typedef enum
123  {
124      NRF_POWER_RAMBLOCK0_MASK = POWER_RAMSTATUS_RAMBLOCK0_Msk,
125      NRF_POWER_RAMBLOCK1_MASK = POWER_RAMSTATUS_RAMBLOCK1_Msk,
126      NRF_POWER_RAMBLOCK2_MASK = POWER_RAMSTATUS_RAMBLOCK2_Msk,
127      NRF_POWER_RAMBLOCK3_MASK = POWER_RAMSTATUS_RAMBLOCK3_Msk
128  } nrf_power_ramblock_mask_t;
129  #endif 
130  typedef enum
131  {
132      NRF_POWER_ONRAM0,  &amp;bsol;**&lt; Keep RAM block 0 ON or OFF in System ON mode.                 */
133      NRF_POWER_OFFRAM0, &amp;bsol;**&lt; Keep retention on RAM block 0 when RAM block is switched OFF. */
134      NRF_POWER_ONRAM1,  &amp;bsol;**&lt; Keep RAM block 1 ON or OFF in System ON mode.                 */
135      NRF_POWER_OFFRAM1, &amp;bsol;**&lt; Keep retention on RAM block 1 when RAM block is switched OFF. */
136      NRF_POWER_ONRAM2,  &amp;bsol;**&lt; Keep RAM block 2 ON or OFF in System ON mode.                 */
137      NRF_POWER_OFFRAM2, &amp;bsol;**&lt; Keep retention on RAM block 2 when RAM block is switched OFF. */
138      NRF_POWER_ONRAM3,  &amp;bsol;**&lt; Keep RAM block 3 ON or OFF in System ON mode.                 */
139      NRF_POWER_OFFRAM3, &amp;bsol;**&lt; Keep retention on RAM block 3 when RAM block is switched OFF. */
140  }nrf_power_onoffram_t;
141  typedef enum
142  {
143      NRF_POWER_ONRAM0_MASK  = 1U &lt;&lt; NRF_POWER_ONRAM0,  &amp;bsol;**&lt; Keep RAM block 0 ON or OFF in System ON mode.                 */
144      NRF_POWER_OFFRAM0_MASK = 1U &lt;&lt; NRF_POWER_OFFRAM0, &amp;bsol;**&lt; Keep retention on RAM block 0 when RAM block is switched OFF. */
145      NRF_POWER_ONRAM1_MASK  = 1U &lt;&lt; NRF_POWER_ONRAM1,  &amp;bsol;**&lt; Keep RAM block 1 ON or OFF in System ON mode.                 */
146      NRF_POWER_OFFRAM1_MASK = 1U &lt;&lt; NRF_POWER_OFFRAM1, &amp;bsol;**&lt; Keep retention on RAM block 1 when RAM block is switched OFF. */
147      NRF_POWER_ONRAM2_MASK  = 1U &lt;&lt; NRF_POWER_ONRAM2,  &amp;bsol;**&lt; Keep RAM block 2 ON or OFF in System ON mode.                 */
148      NRF_POWER_OFFRAM2_MASK = 1U &lt;&lt; NRF_POWER_OFFRAM2, &amp;bsol;**&lt; Keep retention on RAM block 2 when RAM block is switched OFF. */
149      NRF_POWER_ONRAM3_MASK  = 1U &lt;&lt; NRF_POWER_ONRAM3,  &amp;bsol;**&lt; Keep RAM block 3 ON or OFF in System ON mode.                 */
150      NRF_POWER_OFFRAM3_MASK = 1U &lt;&lt; NRF_POWER_OFFRAM3, &amp;bsol;**&lt; Keep retention on RAM block 3 when RAM block is switched OFF. */
151  }nrf_power_onoffram_mask_t;
152  #if NRF_POWER_HAS_POFCON
153  typedef enum
154  {
155      NRF_POWER_POFTHR_V21 = POWER_POFCON_THRESHOLD_V21, &amp;bsol;**&lt; Set threshold to 2.1&amp;nbsp;V. */
156      NRF_POWER_POFTHR_V23 = POWER_POFCON_THRESHOLD_V23, &amp;bsol;**&lt; Set threshold to 2.3&amp;nbsp;V. */
157      NRF_POWER_POFTHR_V25 = POWER_POFCON_THRESHOLD_V25, &amp;bsol;**&lt; Set threshold to 2.5&amp;nbsp;V. */
158      NRF_POWER_POFTHR_V27 = POWER_POFCON_THRESHOLD_V27, &amp;bsol;**&lt; Set threshold to 2.7&amp;nbsp;V. */
159  #if defined(POWER_POFCON_THRESHOLD_V17) || defined(__NRFX_DOXYGEN__)
160      NRF_POWER_POFTHR_V17 = POWER_POFCON_THRESHOLD_V17, &amp;bsol;**&lt; Set threshold to 1.7&amp;nbsp;V. */
161      NRF_POWER_POFTHR_V18 = POWER_POFCON_THRESHOLD_V18, &amp;bsol;**&lt; Set threshold to 1.8&amp;nbsp;V. */
162      NRF_POWER_POFTHR_V19 = POWER_POFCON_THRESHOLD_V19, &amp;bsol;**&lt; Set threshold to 1.9&amp;nbsp;V. */
163      NRF_POWER_POFTHR_V20 = POWER_POFCON_THRESHOLD_V20, &amp;bsol;**&lt; Set threshold to 2.0&amp;nbsp;V. */
164      NRF_POWER_POFTHR_V22 = POWER_POFCON_THRESHOLD_V22, &amp;bsol;**&lt; Set threshold to 2.2&amp;nbsp;V. */
165      NRF_POWER_POFTHR_V24 = POWER_POFCON_THRESHOLD_V24, &amp;bsol;**&lt; Set threshold to 2.4&amp;nbsp;V. */
166      NRF_POWER_POFTHR_V26 = POWER_POFCON_THRESHOLD_V26, &amp;bsol;**&lt; Set threshold to 2.6&amp;nbsp;V. */
167      NRF_POWER_POFTHR_V28 = POWER_POFCON_THRESHOLD_V28, &amp;bsol;**&lt; Set threshold to 2.8&amp;nbsp;V. */
168  #endif 
169  } nrf_power_pof_thr_t;
170  #endif 
171  #if NRF_POWER_HAS_POFCON_VDDH
172  typedef enum
173  {
174      NRF_POWER_POFTHRVDDH_V27 = POWER_POFCON_THRESHOLDVDDH_V27, &amp;bsol;**&lt; Set threshold to 2.7&amp;nbsp;V. */
175      NRF_POWER_POFTHRVDDH_V28 = POWER_POFCON_THRESHOLDVDDH_V28, &amp;bsol;**&lt; Set threshold to 2.8&amp;nbsp;V. */
176      NRF_POWER_POFTHRVDDH_V29 = POWER_POFCON_THRESHOLDVDDH_V29, &amp;bsol;**&lt; Set threshold to 2.9&amp;nbsp;V. */
177      NRF_POWER_POFTHRVDDH_V30 = POWER_POFCON_THRESHOLDVDDH_V30, &amp;bsol;**&lt; Set threshold to 3.0&amp;nbsp;V. */
178      NRF_POWER_POFTHRVDDH_V31 = POWER_POFCON_THRESHOLDVDDH_V31, &amp;bsol;**&lt; Set threshold to 3.1&amp;nbsp;V. */
179      NRF_POWER_POFTHRVDDH_V32 = POWER_POFCON_THRESHOLDVDDH_V32, &amp;bsol;**&lt; Set threshold to 3.2&amp;nbsp;V. */
180      NRF_POWER_POFTHRVDDH_V33 = POWER_POFCON_THRESHOLDVDDH_V33, &amp;bsol;**&lt; Set threshold to 3.3&amp;nbsp;V. */
181      NRF_POWER_POFTHRVDDH_V34 = POWER_POFCON_THRESHOLDVDDH_V34, &amp;bsol;**&lt; Set threshold to 3.4&amp;nbsp;V. */
182      NRF_POWER_POFTHRVDDH_V35 = POWER_POFCON_THRESHOLDVDDH_V35, &amp;bsol;**&lt; Set threshold to 3.5&amp;nbsp;V. */
183      NRF_POWER_POFTHRVDDH_V36 = POWER_POFCON_THRESHOLDVDDH_V36, &amp;bsol;**&lt; Set threshold to 3.6&amp;nbsp;V. */
184      NRF_POWER_POFTHRVDDH_V37 = POWER_POFCON_THRESHOLDVDDH_V37, &amp;bsol;**&lt; Set threshold to 3.7&amp;nbsp;V. */
185      NRF_POWER_POFTHRVDDH_V38 = POWER_POFCON_THRESHOLDVDDH_V38, &amp;bsol;**&lt; Set threshold to 3.8&amp;nbsp;V. */
186      NRF_POWER_POFTHRVDDH_V39 = POWER_POFCON_THRESHOLDVDDH_V39, &amp;bsol;**&lt; Set threshold to 3.9&amp;nbsp;V. */
187      NRF_POWER_POFTHRVDDH_V40 = POWER_POFCON_THRESHOLDVDDH_V40, &amp;bsol;**&lt; Set threshold to 4.0&amp;nbsp;V. */
188      NRF_POWER_POFTHRVDDH_V41 = POWER_POFCON_THRESHOLDVDDH_V41, &amp;bsol;**&lt; Set threshold to 4.1&amp;nbsp;V. */
189      NRF_POWER_POFTHRVDDH_V42 = POWER_POFCON_THRESHOLDVDDH_V42, &amp;bsol;**&lt; Set threshold to 4.2&amp;nbsp;V. */
190  } nrf_power_pof_thrvddh_t;
191  #endif 
192  #if NRF_POWER_HAS_MAINREGSTATUS
193  typedef enum
194  {
195      NRF_POWER_MAINREGSTATUS_NORMAL = POWER_MAINREGSTATUS_MAINREGSTATUS_Normal, &amp;bsol;**&lt; Normal voltage mode. Voltage supplied on VDD. */
196      NRF_POWER_MAINREGSTATUS_HIGH   = POWER_MAINREGSTATUS_MAINREGSTATUS_High    &amp;bsol;**&lt; High voltage mode. Voltage supplied on VDDH.  */
197  } nrf_power_mainregstatus_t;
198  #endif
199  #if defined(POWER_RAM_POWER_S0POWER_Msk) || defined(__NRFX_DOXYGEN__)
200  typedef enum
201  {
202      NRF_POWER_RAMPOWER_S0POWER = POWER_RAM_POWER_S0POWER_Pos,
203      NRF_POWER_RAMPOWER_S1POWER,  &amp;bsol;**&lt; Keep RAM section S1 ON in System ON mode. */
204      NRF_POWER_RAMPOWER_S2POWER,  &amp;bsol;**&lt; Keep RAM section S2 ON in System ON mode. */
205      NRF_POWER_RAMPOWER_S3POWER,  &amp;bsol;**&lt; Keep RAM section S3 ON in System ON mode. */
206      NRF_POWER_RAMPOWER_S4POWER,  &amp;bsol;**&lt; Keep RAM section S4 ON in System ON mode. */
207      NRF_POWER_RAMPOWER_S5POWER,  &amp;bsol;**&lt; Keep RAM section S5 ON in System ON mode. */
208      NRF_POWER_RAMPOWER_S6POWER,  &amp;bsol;**&lt; Keep RAM section S6 ON in System ON mode. */
209      NRF_POWER_RAMPOWER_S7POWER,  &amp;bsol;**&lt; Keep RAM section S7 ON in System ON mode. */
210      NRF_POWER_RAMPOWER_S8POWER,  &amp;bsol;**&lt; Keep RAM section S8 ON in System ON mode. */
211      NRF_POWER_RAMPOWER_S9POWER,  &amp;bsol;**&lt; Keep RAM section S9 ON in System ON mode. */
212      NRF_POWER_RAMPOWER_S10POWER, &amp;bsol;**&lt; Keep RAM section S10 ON in System ON mode. */
213      NRF_POWER_RAMPOWER_S11POWER, &amp;bsol;**&lt; Keep RAM section S11 ON in System ON mode. */
214      NRF_POWER_RAMPOWER_S12POWER, &amp;bsol;**&lt; Keep RAM section S12 ON in System ON mode. */
215      NRF_POWER_RAMPOWER_S13POWER, &amp;bsol;**&lt; Keep RAM section S13 ON in System ON mode. */
216      NRF_POWER_RAMPOWER_S14POWER, &amp;bsol;**&lt; Keep RAM section S14 ON in System ON mode. */
217      NRF_POWER_RAMPOWER_S15POWER, &amp;bsol;**&lt; Keep RAM section S15 ON in System ON mode. */
218      NRF_POWER_RAMPOWER_S0RETENTION = POWER_RAM_POWER_S0RETENTION_Pos,
219      NRF_POWER_RAMPOWER_S1RETENTION,  &amp;bsol;**&lt; Keep section retention in OFF mode when section is OFF. */
220      NRF_POWER_RAMPOWER_S2RETENTION,  &amp;bsol;**&lt; Keep section retention in OFF mode when section is OFF. */
221      NRF_POWER_RAMPOWER_S3RETENTION,  &amp;bsol;**&lt; Keep section retention in OFF mode when section is OFF. */
222      NRF_POWER_RAMPOWER_S4RETENTION,  &amp;bsol;**&lt; Keep section retention in OFF mode when section is OFF. */
223      NRF_POWER_RAMPOWER_S5RETENTION,  &amp;bsol;**&lt; Keep section retention in OFF mode when section is OFF. */
224      NRF_POWER_RAMPOWER_S6RETENTION,  &amp;bsol;**&lt; Keep section retention in OFF mode when section is OFF. */
225      NRF_POWER_RAMPOWER_S7RETENTION,  &amp;bsol;**&lt; Keep section retention in OFF mode when section is OFF. */
226      NRF_POWER_RAMPOWER_S8RETENTION,  &amp;bsol;**&lt; Keep section retention in OFF mode when section is OFF. */
227      NRF_POWER_RAMPOWER_S9RETENTION,  &amp;bsol;**&lt; Keep section retention in OFF mode when section is OFF. */
228      NRF_POWER_RAMPOWER_S10RETENTION, &amp;bsol;**&lt; Keep section retention in OFF mode when section is OFF. */
229      NRF_POWER_RAMPOWER_S11RETENTION, &amp;bsol;**&lt; Keep section retention in OFF mode when section is OFF. */
230      NRF_POWER_RAMPOWER_S12RETENTION, &amp;bsol;**&lt; Keep section retention in OFF mode when section is OFF. */
231      NRF_POWER_RAMPOWER_S13RETENTION, &amp;bsol;**&lt; Keep section retention in OFF mode when section is OFF. */
232      NRF_POWER_RAMPOWER_S14RETENTION, &amp;bsol;**&lt; Keep section retention in OFF mode when section is OFF. */
233      NRF_POWER_RAMPOWER_S15RETENTION, &amp;bsol;**&lt; Keep section retention in OFF mode when section is OFF. */
234  } nrf_power_rampower_t;
235  typedef enum
236  {
237      NRF_POWER_RAMPOWER_S0POWER_MASK  = 1UL &lt;&lt; NRF_POWER_RAMPOWER_S0POWER ,
238      NRF_POWER_RAMPOWER_S1POWER_MASK  = 1UL &lt;&lt; NRF_POWER_RAMPOWER_S1POWER ,
239      NRF_POWER_RAMPOWER_S2POWER_MASK  = 1UL &lt;&lt; NRF_POWER_RAMPOWER_S2POWER ,
240      NRF_POWER_RAMPOWER_S3POWER_MASK  = 1UL &lt;&lt; NRF_POWER_RAMPOWER_S3POWER ,
241      NRF_POWER_RAMPOWER_S4POWER_MASK  = 1UL &lt;&lt; NRF_POWER_RAMPOWER_S4POWER ,
242      NRF_POWER_RAMPOWER_S5POWER_MASK  = 1UL &lt;&lt; NRF_POWER_RAMPOWER_S5POWER ,
243      NRF_POWER_RAMPOWER_S7POWER_MASK  = 1UL &lt;&lt; NRF_POWER_RAMPOWER_S7POWER ,
244      NRF_POWER_RAMPOWER_S8POWER_MASK  = 1UL &lt;&lt; NRF_POWER_RAMPOWER_S8POWER ,
245      NRF_POWER_RAMPOWER_S9POWER_MASK  = 1UL &lt;&lt; NRF_POWER_RAMPOWER_S9POWER ,
246      NRF_POWER_RAMPOWER_S10POWER_MASK = 1UL &lt;&lt; NRF_POWER_RAMPOWER_S10POWER,
247      NRF_POWER_RAMPOWER_S11POWER_MASK = 1UL &lt;&lt; NRF_POWER_RAMPOWER_S11POWER,
248      NRF_POWER_RAMPOWER_S12POWER_MASK = 1UL &lt;&lt; NRF_POWER_RAMPOWER_S12POWER,
249      NRF_POWER_RAMPOWER_S13POWER_MASK = 1UL &lt;&lt; NRF_POWER_RAMPOWER_S13POWER,
250      NRF_POWER_RAMPOWER_S14POWER_MASK = 1UL &lt;&lt; NRF_POWER_RAMPOWER_S14POWER,
251      NRF_POWER_RAMPOWER_S15POWER_MASK = 1UL &lt;&lt; NRF_POWER_RAMPOWER_S15POWER,
252      NRF_POWER_RAMPOWER_S0RETENTION_MASK  = 1UL &lt;&lt; NRF_POWER_RAMPOWER_S0RETENTION ,
253      NRF_POWER_RAMPOWER_S1RETENTION_MASK  = 1UL &lt;&lt; NRF_POWER_RAMPOWER_S1RETENTION ,
254      NRF_POWER_RAMPOWER_S2RETENTION_MASK  = 1UL &lt;&lt; NRF_POWER_RAMPOWER_S2RETENTION ,
255      NRF_POWER_RAMPOWER_S3RETENTION_MASK  = 1UL &lt;&lt; NRF_POWER_RAMPOWER_S3RETENTION ,
256      NRF_POWER_RAMPOWER_S4RETENTION_MASK  = 1UL &lt;&lt; NRF_POWER_RAMPOWER_S4RETENTION ,
257      NRF_POWER_RAMPOWER_S5RETENTION_MASK  = 1UL &lt;&lt; NRF_POWER_RAMPOWER_S5RETENTION ,
258      NRF_POWER_RAMPOWER_S7RETENTION_MASK  = 1UL &lt;&lt; NRF_POWER_RAMPOWER_S7RETENTION ,
259      NRF_POWER_RAMPOWER_S8RETENTION_MASK  = 1UL &lt;&lt; NRF_POWER_RAMPOWER_S8RETENTION ,
260      NRF_POWER_RAMPOWER_S9RETENTION_MASK  = 1UL &lt;&lt; NRF_POWER_RAMPOWER_S9RETENTION ,
261      NRF_POWER_RAMPOWER_S10RETENTION_MASK = 1UL &lt;&lt; NRF_POWER_RAMPOWER_S10RETENTION,
262      NRF_POWER_RAMPOWER_S11RETENTION_MASK = 1UL &lt;&lt; NRF_POWER_RAMPOWER_S11RETENTION,
263      NRF_POWER_RAMPOWER_S12RETENTION_MASK = 1UL &lt;&lt; NRF_POWER_RAMPOWER_S12RETENTION,
264      NRF_POWER_RAMPOWER_S13RETENTION_MASK = 1UL &lt;&lt; NRF_POWER_RAMPOWER_S13RETENTION,
265      NRF_POWER_RAMPOWER_S14RETENTION_MASK = 1UL &lt;&lt; NRF_POWER_RAMPOWER_S14RETENTION,
266      NRF_POWER_RAMPOWER_S15RETENTION_MASK = (int)(1UL &lt;&lt; NRF_POWER_RAMPOWER_S15RETENTION),
267  } nrf_power_rampower_mask_t;
268  #endif 
<span onclick='openModal()' class='match'>269  NRF_STATIC_INLINE void nrf_power_task_trigger(NRF_POWER_Type * p_reg, nrf_power_task_t task);
270  NRF_STATIC_INLINE uint32_t nrf_power_task_address_get(NRF_POWER_Type const * p_reg,
271                                                        nrf_power_task_t       task);
</span>272  NRF_STATIC_INLINE void nrf_power_event_clear(NRF_POWER_Type * p_reg, nrf_power_event_t event);
273  NRF_STATIC_INLINE bool nrf_power_event_check(NRF_POWER_Type const * p_reg, nrf_power_event_t event);
274  NRF_STATIC_INLINE bool nrf_power_event_get_and_clear(NRF_POWER_Type *  p_reg,
275                                                       nrf_power_event_t event);
276  NRF_STATIC_INLINE uint32_t nrf_power_event_address_get(NRF_POWER_Type const * p_reg,
277                                                         nrf_power_event_t      event);
278  NRF_STATIC_INLINE void nrf_power_int_enable(NRF_POWER_Type * p_reg, uint32_t mask);
279  NRF_STATIC_INLINE uint32_t nrf_power_int_enable_check(NRF_POWER_Type const * p_reg, uint32_t mask);
280  NRF_STATIC_INLINE uint32_t nrf_power_int_enable_get(NRF_POWER_Type const * p_reg);
281  NRF_STATIC_INLINE void nrf_power_int_disable(NRF_POWER_Type * p_reg, uint32_t mask);
282  #if defined(DPPI_PRESENT) || defined(__NRFX_DOXYGEN__)
283  NRF_STATIC_INLINE void nrf_power_subscribe_set(NRF_POWER_Type * p_reg,
284                                                 nrf_power_task_t task,
285                                                 uint8_t          channel);
286  NRF_STATIC_INLINE void nrf_power_subscribe_clear(NRF_POWER_Type * p_reg, nrf_power_task_t task);
287  NRF_STATIC_INLINE void nrf_power_publish_set(NRF_POWER_Type *  p_reg,
288                                               nrf_power_event_t event,
289                                               uint8_t           channel);
290  NRF_STATIC_INLINE void nrf_power_publish_clear(NRF_POWER_Type * p_reg, nrf_power_event_t event);
291  #endif 
292  #if NRF_POWER_HAS_RESETREAS
293  NRF_STATIC_INLINE uint32_t nrf_power_resetreas_get(NRF_POWER_Type const * p_reg);
294  NRF_STATIC_INLINE void nrf_power_resetreas_clear(NRF_POWER_Type * p_reg, uint32_t mask);
295  #endif 
296  #if defined(POWER_POWERSTATUS_LTEMODEM_Msk) || defined(__NRFX_DOXYGEN__)
297  NRF_STATIC_INLINE bool nrf_power_powerstatus_get(NRF_POWER_Type const * p_reg);
298  #endif
299  #if defined(POWER_RAMSTATUS_RAMBLOCK0_Msk) || defined(__NRFX_DOXYGEN__)
300  NRF_STATIC_INLINE uint32_t nrf_power_ramstatus_get(NRF_POWER_Type const * p_reg);
301  #endif 
302  #if defined(POWER_SYSTEMOFF_SYSTEMOFF_Enter)
303  NRF_STATIC_INLINE void nrf_power_system_off(NRF_POWER_Type * p_reg);
304  #endif 
305  #if NRF_POWER_HAS_POFCON
306  NRF_STATIC_INLINE void nrf_power_pofcon_set(NRF_POWER_Type *    p_reg,
307                                              bool                enable,
308                                              nrf_power_pof_thr_t thr);
309  NRF_STATIC_INLINE nrf_power_pof_thr_t nrf_power_pofcon_get(NRF_POWER_Type const * p_reg,
310                                                             bool *                 p_enabled);
311  #endif 
312  #if NRF_POWER_HAS_POFCON_VDDH
313  NRF_STATIC_INLINE void nrf_power_pofcon_vddh_set(NRF_POWER_Type *        p_reg,
314                                                   nrf_power_pof_thrvddh_t thr);
315  NRF_STATIC_INLINE nrf_power_pof_thrvddh_t nrf_power_pofcon_vddh_get(NRF_POWER_Type const * p_reg);
316  #endif 
317  NRF_STATIC_INLINE void nrf_power_gpregret_set(NRF_POWER_Type * p_reg, uint8_t val);
318  NRF_STATIC_INLINE uint8_t nrf_power_gpregret_get(NRF_POWER_Type const * p_reg);
319  #if defined(POWER_GPREGRET2_GPREGRET_Msk) || defined(__NRFX_DOXYGEN__)
320  NRF_STATIC_INLINE void nrf_power_gpregret2_set(NRF_POWER_Type * p_reg, uint8_t val);
321  NRF_STATIC_INLINE uint8_t nrf_power_gpregret2_get(NRF_POWER_Type const * p_reg);
322  #endif 
323  NRF_STATIC_INLINE uint8_t nrf_power_gpregret_ext_get(NRF_POWER_Type const * p_reg, uint8_t reg_num);
324  NRF_STATIC_INLINE void nrf_power_gpregret_ext_set(NRF_POWER_Type * p_reg,
325                                                    uint8_t          reg_num,
326                                                    uint8_t          val);
327  #if NRF_POWER_HAS_DCDCEN
328  NRF_STATIC_INLINE void nrf_power_dcdcen_set(NRF_POWER_Type * p_reg, bool enable);
329  NRF_STATIC_INLINE bool nrf_power_dcdcen_get(NRF_POWER_Type const * p_reg);
330  #endif 
331  #if defined(POWER_RAM_POWER_S0POWER_Msk) || defined(__NRFX_DOXYGEN__)
332  NRF_STATIC_INLINE void nrf_power_rampower_mask_on(NRF_POWER_Type * p_reg,
333                                                    uint8_t          block,
334                                                    uint32_t         section_mask);
335  NRF_STATIC_INLINE void nrf_power_rampower_mask_off(NRF_POWER_Type * p_reg,
336                                                     uint8_t          block,
337                                                     uint32_t         section_mask);
338  NRF_STATIC_INLINE uint32_t nrf_power_rampower_mask_get(NRF_POWER_Type const * p_reg, uint8_t block);
339  #endif &amp;bsol;* defined(POWER_RAM_POWER_S0POWER_Msk) || defined(__NRFX_DOXYGEN__) */
340  #if NRF_POWER_HAS_DCDCEN_VDDH
341  NRF_STATIC_INLINE void nrf_power_dcdcen_vddh_set(NRF_POWER_Type * p_reg, bool enable);
342  NRF_STATIC_INLINE bool nrf_power_dcdcen_vddh_get(NRF_POWER_Type const * p_reg);
343  #endif 
344  #if NRF_POWER_HAS_MAINREGSTATUS
345  NRF_STATIC_INLINE
346  nrf_power_mainregstatus_t nrf_power_mainregstatus_get(NRF_POWER_Type const * p_reg);
347  #endif 
348  #if NRF_POWER_HAS_USBREG
349  NRF_STATIC_INLINE uint32_t nrf_power_usbregstatus_get(NRF_POWER_Type const * p_reg);
350  NRF_STATIC_INLINE bool nrf_power_usbregstatus_vbusdet_get(NRF_POWER_Type const * p_reg);
351  NRF_STATIC_INLINE bool nrf_power_usbregstatus_outrdy_get(NRF_POWER_Type const * p_reg);
352  #endif 
353  #ifndef NRF_DECLARE_ONLY
354  NRF_STATIC_INLINE void nrf_power_task_trigger(NRF_POWER_Type * p_reg, nrf_power_task_t task)
355  {
356      *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
357  }
358  NRF_STATIC_INLINE uint32_t nrf_power_task_address_get(NRF_POWER_Type const * p_reg,
359                                                        nrf_power_task_t       task)
360  {
361      return ((uint32_t)p_reg + (uint32_t)task);
362  }
363  NRF_STATIC_INLINE void nrf_power_event_clear(NRF_POWER_Type * p_reg, nrf_power_event_t event)
364  {
365      *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
366  #if __CORTEX_M == 0x04
367      volatile uint32_t dummy = *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event));
368      (void)dummy;
369  #endif
370  }
371  NRF_STATIC_INLINE bool nrf_power_event_check(NRF_POWER_Type const * p_reg, nrf_power_event_t event)
372  {
373      return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
374  }
375  NRF_STATIC_INLINE bool nrf_power_event_get_and_clear(NRF_POWER_Type *  p_reg,
376                                                       nrf_power_event_t event)
377  {
378      bool ret = nrf_power_event_check(p_reg, event);
379      if (ret)
380      {
381          nrf_power_event_clear(p_reg, event);
382      }
383      return ret;
384  }
385  NRF_STATIC_INLINE uint32_t nrf_power_event_address_get(NRF_POWER_Type const * p_reg,
386                                                         nrf_power_event_t      event)
387  {
388      return ((uint32_t)p_reg + (uint32_t)event);
389  }
390  NRF_STATIC_INLINE void nrf_power_int_enable(NRF_POWER_Type * p_reg, uint32_t mask)
391  {
392      p_reg-&gt;INTENSET = mask;
393  }
394  NRF_STATIC_INLINE uint32_t nrf_power_int_enable_check(NRF_POWER_Type const * p_reg, uint32_t mask)
395  {
396      return p_reg-&gt;INTENSET &amp; mask;
397  }
398  NRF_STATIC_INLINE uint32_t nrf_power_int_enable_get(NRF_POWER_Type const * p_reg)
399  {
400      return p_reg-&gt;INTENSET;
401  }
402  NRF_STATIC_INLINE void nrf_power_int_disable(NRF_POWER_Type * p_reg, uint32_t mask)
403  {
404      p_reg-&gt;INTENCLR = mask;
405  }
406  #if defined(DPPI_PRESENT)
407  NRF_STATIC_INLINE void nrf_power_subscribe_set(NRF_POWER_Type * p_reg,
408                                                 nrf_power_task_t task,
409                                                 uint8_t          channel)
410  {
411      *((volatile uint32_t *) ((uint8_t *) p_reg + (uint32_t) task + 0x80uL)) =
412              ((uint32_t)channel | POWER_SUBSCRIBE_CONSTLAT_EN_Msk);
413  }
414  NRF_STATIC_INLINE void nrf_power_subscribe_clear(NRF_POWER_Type * p_reg, nrf_power_task_t task)
415  {
416      *((volatile uint32_t *) ((uint8_t *) p_reg + (uint32_t) task + 0x80uL)) = 0;
417  }
418  NRF_STATIC_INLINE void nrf_power_publish_set(NRF_POWER_Type *  p_reg,
419                                               nrf_power_event_t event,
420                                               uint8_t           channel)
421  {
422      *((volatile uint32_t *) ((uint8_t *) p_reg + (uint32_t) event + 0x80uL)) =
423              ((uint32_t)channel | POWER_PUBLISH_SLEEPENTER_EN_Msk);
424  }
425  NRF_STATIC_INLINE void nrf_power_publish_clear(NRF_POWER_Type * p_reg, nrf_power_event_t event)
426  {
427      *((volatile uint32_t *) ((uint8_t *) p_reg + (uint32_t) event + 0x80uL)) = 0;
428  }
429  #endif 
430  #if NRF_POWER_HAS_RESETREAS
431  NRF_STATIC_INLINE uint32_t nrf_power_resetreas_get(NRF_POWER_Type const * p_reg)
432  {
433      return p_reg-&gt;RESETREAS;
434  }
435  NRF_STATIC_INLINE void nrf_power_resetreas_clear(NRF_POWER_Type * p_reg, uint32_t mask)
436  {
437      p_reg-&gt;RESETREAS = mask;
438  }
439  #endif 
440  #if defined(POWER_POWERSTATUS_LTEMODEM_Msk)
441  NRF_STATIC_INLINE bool nrf_power_powerstatus_get(NRF_POWER_Type const * p_reg)
442  {
443      return (p_reg-&gt;POWERSTATUS &amp; POWER_POWERSTATUS_LTEMODEM_Msk) ==
444             (POWER_POWERSTATUS_LTEMODEM_ON &lt;&lt; POWER_POWERSTATUS_LTEMODEM_Pos);
445  }
446  #endif 
447  #if defined(POWER_RAMSTATUS_RAMBLOCK0_Msk)
448  NRF_STATIC_INLINE uint32_t nrf_power_ramstatus_get(NRF_POWER_Type const * p_reg)
449  {
450      return p_reg-&gt;RAMSTATUS;
451  }
452  #endif 
453  #if defined(POWER_SYSTEMOFF_SYSTEMOFF_Enter)
454  NRF_STATIC_INLINE void nrf_power_system_off(NRF_POWER_Type * p_reg)
455  {
456      p_reg-&gt;SYSTEMOFF = POWER_SYSTEMOFF_SYSTEMOFF_Enter;
457      __DSB();
458      while (true)
459      {
460          __WFE();
461      }
462  }
463  #endif 
464  #if NRF_POWER_HAS_POFCON
465  NRF_STATIC_INLINE void nrf_power_pofcon_set(NRF_POWER_Type *    p_reg,
466                                              bool                enable,
467                                              nrf_power_pof_thr_t thr)
468  {
469      NRFX_ASSERT(thr == (thr &amp; (POWER_POFCON_THRESHOLD_Msk &gt;&gt; POWER_POFCON_THRESHOLD_Pos)));
470  #if NRF_POWER_HAS_POFCON_VDDH
471      uint32_t pofcon = p_reg-&gt;POFCON;
472      pofcon &amp;= ~(POWER_POFCON_THRESHOLD_Msk | POWER_POFCON_POF_Msk);
473      pofcon |=
474  #else 
475      p_reg-&gt;POFCON =
476  #endif
477          (((uint32_t)thr) &lt;&lt; POWER_POFCON_THRESHOLD_Pos) |
478          (enable ?
479          (POWER_POFCON_POF_Enabled &lt;&lt; POWER_POFCON_POF_Pos)
480          :
481          (POWER_POFCON_POF_Disabled &lt;&lt; POWER_POFCON_POF_Pos));
482  #if NRF_POWER_HAS_POFCON_VDDH
483      p_reg-&gt;POFCON = pofcon;
484  #endif
485  }
486  NRF_STATIC_INLINE nrf_power_pof_thr_t nrf_power_pofcon_get(NRF_POWER_Type const * p_reg,
487                                                             bool *                 p_enabled)
488  {
489      uint32_t pofcon = p_reg-&gt;POFCON;
490      if (NULL != p_enabled)
491      {
492          (*p_enabled) = ((pofcon &amp; POWER_POFCON_POF_Msk) &gt;&gt; POWER_POFCON_POF_Pos)
493              == POWER_POFCON_POF_Enabled;
494      }
495      return (nrf_power_pof_thr_t)((pofcon &amp; POWER_POFCON_THRESHOLD_Msk) &gt;&gt;
496          POWER_POFCON_THRESHOLD_Pos);
497  }
498  #endif 
499  #if NRF_POWER_HAS_POFCON_VDDH
500  NRF_STATIC_INLINE void nrf_power_pofcon_vddh_set(NRF_POWER_Type *        p_reg,
501                                                   nrf_power_pof_thrvddh_t thr)
502  {
503      NRFX_ASSERT(thr == (thr &amp; (POWER_POFCON_THRESHOLDVDDH_Msk &gt;&gt; POWER_POFCON_THRESHOLDVDDH_Pos)));
504      uint32_t pofcon = p_reg-&gt;POFCON;
505      pofcon &amp;= ~POWER_POFCON_THRESHOLDVDDH_Msk;
506      pofcon |= (((uint32_t)thr) &lt;&lt; POWER_POFCON_THRESHOLDVDDH_Pos);
507      p_reg-&gt;POFCON = pofcon;
508  }
509  NRF_STATIC_INLINE nrf_power_pof_thrvddh_t nrf_power_pofcon_vddh_get(NRF_POWER_Type const * p_reg)
510  {
511      return (nrf_power_pof_thrvddh_t)((p_reg-&gt;POFCON &amp; POWER_POFCON_THRESHOLDVDDH_Msk) &gt;&gt;
512                                       POWER_POFCON_THRESHOLDVDDH_Pos);
513  }
514  #endif 
515  NRF_STATIC_INLINE void nrf_power_gpregret_set(NRF_POWER_Type * p_reg, uint8_t val)
516  {
517      volatile uint32_t * p_gpregret;
518      if (sizeof(p_reg-&gt;GPREGRET) &gt; sizeof(uint32_t))
519      {
520          p_gpregret = &amp;((volatile uint32_t *)p_reg-&gt;GPREGRET)[0];
521      }
522      else
523      {
524          p_gpregret = &amp;((volatile uint32_t *)&amp;p_reg-&gt;GPREGRET)[0];
525      }
526      *p_gpregret = val;
527  }
528  NRF_STATIC_INLINE uint8_t nrf_power_gpregret_get(NRF_POWER_Type const * p_reg)
529  {
530      volatile uint32_t * p_gpregret;
531      if (sizeof(p_reg-&gt;GPREGRET) &gt; sizeof(uint32_t))
532      {
533          p_gpregret = &amp;((volatile uint32_t *)p_reg-&gt;GPREGRET)[0];
534      }
535      else
536      {
537          p_gpregret = &amp;((volatile uint32_t *)&amp;p_reg-&gt;GPREGRET)[0];
538      }
539      return *p_gpregret;
540  }
541  NRF_STATIC_INLINE void nrf_power_gpregret_ext_set(NRF_POWER_Type * p_reg,
542                                                    uint8_t          reg_num,
543                                                    uint8_t          val)
544  {
545  #if defined(NRF91_SERIES) || defined(NRF5340_XXAA_APPLICATION) || defined(NRF5340_XXAA_NETWORK)
546      p_reg-&gt;GPREGRET[reg_num] = val;
547  #else
548      NRFX_ASSERT(reg_num &lt; 1);
549      p_reg-&gt;GPREGRET = val;
550  #endif
551  }
552  NRF_STATIC_INLINE uint8_t nrf_power_gpregret_ext_get(NRF_POWER_Type const * p_reg, uint8_t reg_num)
553  {
554  #if defined(NRF91_SERIES) || defined(NRF5340_XXAA_APPLICATION) || defined(NRF5340_XXAA_NETWORK)
555      return p_reg-&gt;GPREGRET[reg_num];
556  #else
557      NRFX_ASSERT(reg_num &lt; 1);
558      return p_reg-&gt;GPREGRET;
559  #endif
560  }
561  #if defined(POWER_GPREGRET2_GPREGRET_Msk)
562  NRF_STATIC_INLINE void nrf_power_gpregret2_set(NRF_POWER_Type * p_reg, uint8_t val)
563  {
564      p_reg-&gt;GPREGRET2 = val;
565  }
566  NRF_STATIC_INLINE uint8_t nrf_power_gpregret2_get(NRF_POWER_Type const * p_reg)
567  {
568      return p_reg-&gt;GPREGRET2;
569  }
570  #endif
571  #if NRF_POWER_HAS_DCDCEN
572  NRF_STATIC_INLINE void nrf_power_dcdcen_set(NRF_POWER_Type * p_reg, bool enable)
573  {
574      p_reg-&gt;DCDCEN = (enable ? POWER_DCDCEN_DCDCEN_Enabled : POWER_DCDCEN_DCDCEN_Disabled) &lt;&lt;
575                      POWER_DCDCEN_DCDCEN_Pos;
576  }
577  NRF_STATIC_INLINE bool nrf_power_dcdcen_get(NRF_POWER_Type const * p_reg)
578  {
579      return (p_reg-&gt;DCDCEN &amp; POWER_DCDCEN_DCDCEN_Msk)
580              ==
581             (POWER_DCDCEN_DCDCEN_Enabled &lt;&lt; POWER_DCDCEN_DCDCEN_Pos);
582  }
583  #endif 
584  #if defined(POWER_RAM_POWER_S0POWER_Msk)
585  NRF_STATIC_INLINE void nrf_power_rampower_mask_on(NRF_POWER_Type * p_reg,
586                                                    uint8_t          block,
587                                                    uint32_t         section_mask)
588  {
589      p_reg-&gt;RAM[block].POWERSET = section_mask;
590  }
591  NRF_STATIC_INLINE void nrf_power_rampower_mask_off(NRF_POWER_Type * p_reg,
592                                                     uint8_t          block,
593                                                     uint32_t         section_mask)
594  {
595      p_reg-&gt;RAM[block].POWERCLR = section_mask;
596  }
597  NRF_STATIC_INLINE uint32_t nrf_power_rampower_mask_get(NRF_POWER_Type const * p_reg, uint8_t block)
598  {
599      return p_reg-&gt;RAM[block].POWER;
600  }
601  #endif 
602  #if NRF_POWER_HAS_DCDCEN_VDDH
603  NRF_STATIC_INLINE void nrf_power_dcdcen_vddh_set(NRF_POWER_Type * p_reg, bool enable)
604  {
605      p_reg-&gt;DCDCEN0 = (enable ? POWER_DCDCEN0_DCDCEN_Enabled : POWER_DCDCEN0_DCDCEN_Disabled) &lt;&lt;
606                       POWER_DCDCEN0_DCDCEN_Pos;
607  }
608  NRF_STATIC_INLINE bool nrf_power_dcdcen_vddh_get(NRF_POWER_Type const * p_reg)
609  {
610      return (p_reg-&gt;DCDCEN0 &amp; POWER_DCDCEN0_DCDCEN_Msk)
611              ==
612             (POWER_DCDCEN0_DCDCEN_Enabled &lt;&lt; POWER_DCDCEN0_DCDCEN_Pos);
613  }
614  #endif 
615  #if NRF_POWER_HAS_MAINREGSTATUS
616  NRF_STATIC_INLINE
617  nrf_power_mainregstatus_t nrf_power_mainregstatus_get(NRF_POWER_Type const * p_reg)
618  {
619      return (nrf_power_mainregstatus_t)(((p_reg-&gt;MAINREGSTATUS) &amp;
620          POWER_MAINREGSTATUS_MAINREGSTATUS_Msk) &gt;&gt;
621          POWER_MAINREGSTATUS_MAINREGSTATUS_Pos);
622  }
623  #endif 
624  #if NRF_POWER_HAS_USBREG
625  NRF_STATIC_INLINE uint32_t nrf_power_usbregstatus_get(NRF_POWER_Type const * p_reg)
626  {
627      return p_reg-&gt;USBREGSTATUS;
628  }
629  NRF_STATIC_INLINE bool nrf_power_usbregstatus_vbusdet_get(NRF_POWER_Type const * p_reg)
630  {
631      return (nrf_power_usbregstatus_get(p_reg) &amp; NRF_POWER_USBREGSTATUS_VBUSDETECT_MASK) != 0;
632  }
633  NRF_STATIC_INLINE bool nrf_power_usbregstatus_outrdy_get(NRF_POWER_Type const * p_reg)
634  {
635      return (nrf_power_usbregstatus_get(p_reg) &amp; NRF_POWER_USBREGSTATUS_OUTPUTRDY_MASK) != 0;
636  }
637  #endif 
638  #endif 
639  #ifdef __cplusplus
640  }
641  #endif
642  #endif 
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from Adafruit_nRF52_Arduino-MDEwOlJlcG9zaXRvcnk3NDM1NDcyOQ==-flat-nrf_ccm.h</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from Adafruit_nRF52_Arduino-MDEwOlJlcG9zaXRvcnk3NDM1NDcyOQ==-flat-nrf_power.h</div>
                </div>
                <div class="column column_space"><pre><code>62  NRF_STATIC_INLINE void nrf_ccm_task_trigger(NRF_CCM_Type * p_reg,
63                                              nrf_ccm_task_t task);
64  NRF_STATIC_INLINE uint32_t nrf_ccm_task_address_get(NRF_CCM_Type const * p_reg,
65                                                      nrf_ccm_task_t       task);
</pre></code></div>
                <div class="column column_space"><pre><code>269  NRF_STATIC_INLINE void nrf_power_task_trigger(NRF_POWER_Type * p_reg, nrf_power_task_t task);
270  NRF_STATIC_INLINE uint32_t nrf_power_task_address_get(NRF_POWER_Type const * p_reg,
271                                                        nrf_power_task_t       task);
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    