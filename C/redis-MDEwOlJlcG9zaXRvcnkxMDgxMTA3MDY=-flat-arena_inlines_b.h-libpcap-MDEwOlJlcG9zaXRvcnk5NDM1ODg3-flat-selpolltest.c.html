
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 5.492730210016155%, Tokens: 8, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>redis-MDEwOlJlcG9zaXRvcnkxMDgxMTA3MDY=-flat-arena_inlines_b.h</h3>
            <pre><code>1  #ifndef JEMALLOC_INTERNAL_ARENA_INLINES_B_H
2  #define JEMALLOC_INTERNAL_ARENA_INLINES_B_H
3  #include "jemalloc/internal/jemalloc_internal_types.h"
4  #include "jemalloc/internal/mutex.h"
5  #include "jemalloc/internal/rtree.h"
6  #include "jemalloc/internal/sc.h"
7  #include "jemalloc/internal/sz.h"
8  #include "jemalloc/internal/ticker.h"
9  JEMALLOC_ALWAYS_INLINE bool
10  arena_has_default_hooks(arena_t *arena) {
11  	return (extent_hooks_get(arena) == &extent_hooks_default);
12  }
13  JEMALLOC_ALWAYS_INLINE arena_t *
14  arena_choose_maybe_huge(tsd_t *tsd, arena_t *arena, size_t size) {
15  	if (arena != NULL) {
16  		return arena;
17  	}
18  	if (unlikely(size >= oversize_threshold)) {
19  		arena_t *tsd_arena = tsd_arena_get(tsd);
20  		if (tsd_arena == NULL || arena_is_auto(tsd_arena)) {
21  			return arena_choose_huge(tsd);
22  		}
23  	}
24  	return arena_choose(tsd, NULL);
25  }
26  JEMALLOC_ALWAYS_INLINE prof_tctx_t *
27  arena_prof_tctx_get(tsdn_t *tsdn, const void *ptr, alloc_ctx_t *alloc_ctx) {
28  	cassert(config_prof);
29  	assert(ptr != NULL);
30  	if (alloc_ctx == NULL) {
31  		const extent_t *extent = iealloc(tsdn, ptr);
32  		if (unlikely(!extent_slab_get(extent))) {
33  			return large_prof_tctx_get(tsdn, extent);
34  		}
35  	} else {
36  		if (unlikely(!alloc_ctx->slab)) {
37  			return large_prof_tctx_get(tsdn, iealloc(tsdn, ptr));
38  		}
39  	}
40  	return (prof_tctx_t *)(uintptr_t)1U;
41  }
42  JEMALLOC_ALWAYS_INLINE void
43  arena_prof_tctx_set(tsdn_t *tsdn, const void *ptr, size_t usize,
44      alloc_ctx_t *alloc_ctx, prof_tctx_t *tctx) {
45  	cassert(config_prof);
46  	assert(ptr != NULL);
47  	if (alloc_ctx == NULL) {
48  		extent_t *extent = iealloc(tsdn, ptr);
49  		if (unlikely(!extent_slab_get(extent))) {
50  			large_prof_tctx_set(tsdn, extent, tctx);
51  		}
52  	} else {
53  		if (unlikely(!alloc_ctx->slab)) {
54  			large_prof_tctx_set(tsdn, iealloc(tsdn, ptr), tctx);
55  		}
56  	}
57  }
58  static inline void
59  arena_prof_tctx_reset(tsdn_t *tsdn, const void *ptr, prof_tctx_t *tctx) {
60  	cassert(config_prof);
61  	assert(ptr != NULL);
62  	extent_t *extent = iealloc(tsdn, ptr);
63  	assert(!extent_slab_get(extent));
64  	large_prof_tctx_reset(tsdn, extent);
65  }
66  JEMALLOC_ALWAYS_INLINE nstime_t
67  arena_prof_alloc_time_get(tsdn_t *tsdn, const void *ptr,
68      alloc_ctx_t *alloc_ctx) {
69  	cassert(config_prof);
70  	assert(ptr != NULL);
71  	extent_t *extent = iealloc(tsdn, ptr);
72  	assert(!extent_slab_get(extent));
73  	return large_prof_alloc_time_get(extent);
74  }
75  JEMALLOC_ALWAYS_INLINE void
76  arena_prof_alloc_time_set(tsdn_t *tsdn, const void *ptr, alloc_ctx_t *alloc_ctx,
77      nstime_t t) {
78  	cassert(config_prof);
79  	assert(ptr != NULL);
80  	extent_t *extent = iealloc(tsdn, ptr);
81  	assert(!extent_slab_get(extent));
82  	large_prof_alloc_time_set(extent, t);
83  }
84  JEMALLOC_ALWAYS_INLINE void
85  arena_decay_ticks(tsdn_t *tsdn, arena_t *arena, unsigned nticks) {
86  	tsd_t *tsd;
87  	ticker_t *decay_ticker;
88  	if (unlikely(tsdn_null(tsdn))) {
89  		return;
90  	}
91  	tsd = tsdn_tsd(tsdn);
92  	decay_ticker = decay_ticker_get(tsd, arena_ind_get(arena));
93  	if (unlikely(decay_ticker == NULL)) {
94  		return;
95  	}
96  	if (unlikely(ticker_ticks(decay_ticker, nticks))) {
97  		arena_decay(tsdn, arena, false, false);
98  	}
99  }
100  JEMALLOC_ALWAYS_INLINE void
101  arena_decay_tick(tsdn_t *tsdn, arena_t *arena) {
102  	malloc_mutex_assert_not_owner(tsdn, &arena->decay_dirty.mtx);
103  	malloc_mutex_assert_not_owner(tsdn, &arena->decay_muzzy.mtx);
104  	arena_decay_ticks(tsdn, arena, 1);
105  }
106  JEMALLOC_ALWAYS_INLINE void
107  arena_decay_extent(tsdn_t *tsdn,arena_t *arena, extent_hooks_t **r_extent_hooks,
108      extent_t *extent) {
109  	size_t extent_size = extent_size_get(extent);
110  	extent_dalloc_wrapper(tsdn, arena,
111  	    r_extent_hooks, extent);
112  	if (config_stats) {
113  		arena_stats_lock(tsdn, &arena->stats);
114  		arena_stats_add_u64(tsdn, &arena->stats,
115  		    &arena->decay_dirty.stats->nmadvise, 1);
116  		arena_stats_add_u64(tsdn, &arena->stats,
117  		    &arena->decay_dirty.stats->purged, extent_size >> LG_PAGE);
118  		arena_stats_sub_zu(tsdn, &arena->stats, &arena->stats.mapped,
119  		    extent_size);
120  		arena_stats_unlock(tsdn, &arena->stats);
121  	}
122  }
123  JEMALLOC_ALWAYS_INLINE void *
124  arena_malloc(tsdn_t *tsdn, arena_t *arena, size_t size, szind_t ind, bool zero,
125      tcache_t *tcache, bool slow_path) {
126  	assert(!tsdn_null(tsdn) || tcache == NULL);
127  	if (likely(tcache != NULL)) {
<span onclick='openModal()' class='match'>128  		if (likely(size <= SC_SMALL_MAXCLASS)) {
129  			return tcache_alloc_small(tsdn_tsd(tsdn), arena,
130  			    tcache, size, ind, zero, slow_path);
131  		}
132  		if (likely(size <= tcache_maxclass)) {
133  			return tcache_alloc_large(tsdn_tsd(tsdn), arena,
134  			    tcache, size, ind, zero, slow_path);
135  		}
</span>136  		assert(size > tcache_maxclass);
137  	}
138  	return arena_malloc_hard(tsdn, arena, size, ind, zero);
139  }
140  JEMALLOC_ALWAYS_INLINE arena_t *
141  arena_aalloc(tsdn_t *tsdn, const void *ptr) {
142  	return extent_arena_get(iealloc(tsdn, ptr));
143  }
144  JEMALLOC_ALWAYS_INLINE size_t
145  arena_salloc(tsdn_t *tsdn, const void *ptr) {
146  	assert(ptr != NULL);
147  	rtree_ctx_t rtree_ctx_fallback;
148  	rtree_ctx_t *rtree_ctx = tsdn_rtree_ctx(tsdn, &rtree_ctx_fallback);
149  	szind_t szind = rtree_szind_read(tsdn, &extents_rtree, rtree_ctx,
150  	    (uintptr_t)ptr, true);
151  	assert(szind != SC_NSIZES);
152  	return sz_index2size(szind);
153  }
154  JEMALLOC_ALWAYS_INLINE size_t
155  arena_vsalloc(tsdn_t *tsdn, const void *ptr) {
156  	rtree_ctx_t rtree_ctx_fallback;
157  	rtree_ctx_t *rtree_ctx = tsdn_rtree_ctx(tsdn, &rtree_ctx_fallback);
158  	extent_t *extent;
159  	szind_t szind;
160  	if (rtree_extent_szind_read(tsdn, &extents_rtree, rtree_ctx,
161  	    (uintptr_t)ptr, false, &extent, &szind)) {
162  		return 0;
163  	}
164  	if (extent == NULL) {
165  		return 0;
166  	}
167  	assert(extent_state_get(extent) == extent_state_active);
168  	assert(extent_addr_get(extent) == ptr || extent_slab_get(extent));
169  	assert(szind != SC_NSIZES);
170  	return sz_index2size(szind);
171  }
172  static inline void
173  arena_dalloc_large_no_tcache(tsdn_t *tsdn, void *ptr, szind_t szind) {
174  	if (config_prof && unlikely(szind < SC_NBINS)) {
175  		arena_dalloc_promoted(tsdn, ptr, NULL, true);
176  	} else {
177  		extent_t *extent = iealloc(tsdn, ptr);
178  		large_dalloc(tsdn, extent);
179  	}
180  }
181  static inline void
182  arena_dalloc_no_tcache(tsdn_t *tsdn, void *ptr) {
183  	assert(ptr != NULL);
184  	rtree_ctx_t rtree_ctx_fallback;
185  	rtree_ctx_t *rtree_ctx = tsdn_rtree_ctx(tsdn, &rtree_ctx_fallback);
186  	szind_t szind;
187  	bool slab;
188  	rtree_szind_slab_read(tsdn, &extents_rtree, rtree_ctx, (uintptr_t)ptr,
189  	    true, &szind, &slab);
190  	if (config_debug) {
191  		extent_t *extent = rtree_extent_read(tsdn, &extents_rtree,
192  		    rtree_ctx, (uintptr_t)ptr, true);
193  		assert(szind == extent_szind_get(extent));
194  		assert(szind < SC_NSIZES);
195  		assert(slab == extent_slab_get(extent));
196  	}
197  	if (likely(slab)) {
198  		arena_dalloc_small(tsdn, ptr);
199  	} else {
200  		arena_dalloc_large_no_tcache(tsdn, ptr, szind);
201  	}
202  }
203  JEMALLOC_ALWAYS_INLINE void
204  arena_dalloc_large(tsdn_t *tsdn, void *ptr, tcache_t *tcache, szind_t szind,
205      bool slow_path) {
206  	if (szind < nhbins) {
207  		if (config_prof && unlikely(szind < SC_NBINS)) {
208  			arena_dalloc_promoted(tsdn, ptr, tcache, slow_path);
209  		} else {
210  			tcache_dalloc_large(tsdn_tsd(tsdn), tcache, ptr, szind,
211  			    slow_path);
212  		}
213  	} else {
214  		extent_t *extent = iealloc(tsdn, ptr);
215  		large_dalloc(tsdn, extent);
216  	}
217  }
218  JEMALLOC_ALWAYS_INLINE void
219  arena_dalloc(tsdn_t *tsdn, void *ptr, tcache_t *tcache,
220      alloc_ctx_t *alloc_ctx, bool slow_path) {
221  	assert(!tsdn_null(tsdn) || tcache == NULL);
222  	assert(ptr != NULL);
223  	if (unlikely(tcache == NULL)) {
224  		arena_dalloc_no_tcache(tsdn, ptr);
225  		return;
226  	}
227  	szind_t szind;
228  	bool slab;
229  	rtree_ctx_t *rtree_ctx;
230  	if (alloc_ctx != NULL) {
231  		szind = alloc_ctx->szind;
232  		slab = alloc_ctx->slab;
233  		assert(szind != SC_NSIZES);
234  	} else {
235  		rtree_ctx = tsd_rtree_ctx(tsdn_tsd(tsdn));
236  		rtree_szind_slab_read(tsdn, &extents_rtree, rtree_ctx,
237  		    (uintptr_t)ptr, true, &szind, &slab);
238  	}
239  	if (config_debug) {
240  		rtree_ctx = tsd_rtree_ctx(tsdn_tsd(tsdn));
241  		extent_t *extent = rtree_extent_read(tsdn, &extents_rtree,
242  		    rtree_ctx, (uintptr_t)ptr, true);
243  		assert(szind == extent_szind_get(extent));
244  		assert(szind < SC_NSIZES);
245  		assert(slab == extent_slab_get(extent));
246  	}
247  	if (likely(slab)) {
248  		tcache_dalloc_small(tsdn_tsd(tsdn), tcache, ptr, szind,
249  		    slow_path);
250  	} else {
251  		arena_dalloc_large(tsdn, ptr, tcache, szind, slow_path);
252  	}
253  }
254  static inline void
255  arena_sdalloc_no_tcache(tsdn_t *tsdn, void *ptr, size_t size) {
256  	assert(ptr != NULL);
257  	assert(size <= SC_LARGE_MAXCLASS);
258  	szind_t szind;
259  	bool slab;
260  	if (!config_prof || !opt_prof) {
261  		szind = sz_size2index(size);
262  		slab = (szind < SC_NBINS);
263  	}
264  	if ((config_prof && opt_prof) || config_debug) {
265  		rtree_ctx_t rtree_ctx_fallback;
266  		rtree_ctx_t *rtree_ctx = tsdn_rtree_ctx(tsdn,
267  		    &rtree_ctx_fallback);
268  		rtree_szind_slab_read(tsdn, &extents_rtree, rtree_ctx,
269  		    (uintptr_t)ptr, true, &szind, &slab);
270  		assert(szind == sz_size2index(size));
271  		assert((config_prof && opt_prof) || slab == (szind < SC_NBINS));
272  		if (config_debug) {
273  			extent_t *extent = rtree_extent_read(tsdn,
274  			    &extents_rtree, rtree_ctx, (uintptr_t)ptr, true);
275  			assert(szind == extent_szind_get(extent));
276  			assert(slab == extent_slab_get(extent));
277  		}
278  	}
279  	if (likely(slab)) {
280  		arena_dalloc_small(tsdn, ptr);
281  	} else {
282  		arena_dalloc_large_no_tcache(tsdn, ptr, szind);
283  	}
284  }
285  JEMALLOC_ALWAYS_INLINE void
286  arena_sdalloc(tsdn_t *tsdn, void *ptr, size_t size, tcache_t *tcache,
287      alloc_ctx_t *alloc_ctx, bool slow_path) {
288  	assert(!tsdn_null(tsdn) || tcache == NULL);
289  	assert(ptr != NULL);
290  	assert(size <= SC_LARGE_MAXCLASS);
291  	if (unlikely(tcache == NULL)) {
292  		arena_sdalloc_no_tcache(tsdn, ptr, size);
293  		return;
294  	}
295  	szind_t szind;
296  	bool slab;
297  	alloc_ctx_t local_ctx;
298  	if (config_prof && opt_prof) {
299  		if (alloc_ctx == NULL) {
300  			rtree_ctx_t rtree_ctx_fallback;
301  			rtree_ctx_t *rtree_ctx = tsdn_rtree_ctx(tsdn,
302  			    &rtree_ctx_fallback);
303  			rtree_szind_slab_read(tsdn, &extents_rtree, rtree_ctx,
304  			    (uintptr_t)ptr, true, &local_ctx.szind,
305  			    &local_ctx.slab);
306  			assert(local_ctx.szind == sz_size2index(size));
307  			alloc_ctx = &local_ctx;
308  		}
309  		slab = alloc_ctx->slab;
310  		szind = alloc_ctx->szind;
311  	} else {
312  		szind = sz_size2index(size);
313  		slab = (szind < SC_NBINS);
314  	}
315  	if (config_debug) {
316  		rtree_ctx_t *rtree_ctx = tsd_rtree_ctx(tsdn_tsd(tsdn));
317  		rtree_szind_slab_read(tsdn, &extents_rtree, rtree_ctx,
318  		    (uintptr_t)ptr, true, &szind, &slab);
319  		extent_t *extent = rtree_extent_read(tsdn,
320  		    &extents_rtree, rtree_ctx, (uintptr_t)ptr, true);
321  		assert(szind == extent_szind_get(extent));
322  		assert(slab == extent_slab_get(extent));
323  	}
324  	if (likely(slab)) {
325  		tcache_dalloc_small(tsdn_tsd(tsdn), tcache, ptr, szind,
326  		    slow_path);
327  	} else {
328  		arena_dalloc_large(tsdn, ptr, tcache, szind, slow_path);
329  	}
330  }
331  #endif &bsol;* JEMALLOC_INTERNAL_ARENA_INLINES_B_H */
</code></pre>
        </div>
        <div class="column">
            <h3>libpcap-MDEwOlJlcG9zaXRvcnk5NDM1ODg3-flat-selpolltest.c</h3>
            <pre><code>1  #include "varattrs.h"
2  #ifndef lint
3  static const char copyright[] _U_ =
4      "@(#) Copyright (c) 1988, 1989, 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1997, 2000\n\
5  The Regents of the University of California.  All rights reserved.\n";
6  #endif
7  #include <pcap.h>
8  #include <stdio.h>
9  #include <stdlib.h>
10  #include <string.h>
11  #include <stdarg.h>
12  #include <unistd.h>
13  #include <errno.h>
14  #include <sys/types.h>
15  #ifdef HAVE_SYS_SELECT_H
16  #include <sys/select.h>
17  #else
18  #include <sys/time.h>	&bsol;* older UN*Xes */
19  #endif
20  #include <poll.h>
21  #include "pcap/funcattrs.h"
22  static char *program_name;
23  static void countme(u_char *, const struct pcap_pkthdr *, const u_char *);
24  static void PCAP_NORETURN usage(void);
25  static void PCAP_NORETURN error(const char *, ...) PCAP_PRINTFLIKE(1, 2);
26  static void warning(const char *, ...) PCAP_PRINTFLIKE(1, 2);
27  static char *copy_argv(char **);
28  static pcap_t *pd;
29  int
30  main(int argc, char **argv)
31  {
32  	register int op;
33  	bpf_u_int32 localnet, netmask;
34  	register char *cp, *cmdbuf, *device;
35  	int doselect, dopoll, dotimeout, dononblock, quiet;
36  	const char *mechanism;
37  	struct bpf_program fcode;
38  	char ebuf[PCAP_ERRBUF_SIZE];
39  	pcap_if_t *devlist;
40  	int selectable_fd = -1;
41  	const struct timeval *required_timeout;
42  	int status;
43  	int packet_count;
44  	device = NULL;
45  	doselect = 0;
46  	dopoll = 0;
47  	mechanism = NULL;
48  	dotimeout = 0;
49  	dononblock = 0;
50  	quiet = 0;
51  	if ((cp = strrchr(argv[0], '/')) != NULL)
52  		program_name = cp + 1;
53  	else
54  		program_name = argv[0];
55  	opterr = 0;
56  	while ((op = getopt(argc, argv, "i:sptnq")) != -1) {
57  		switch (op) {
58  		case 'i':
59  			device = optarg;
60  			break;
61  		case 's':
62  			doselect = 1;
63  			mechanism = "select() and pcap_dispatch()";
64  			break;
65  		case 'p':
66  			dopoll = 1;
67  			mechanism = "poll() and pcap_dispatch()";
68  			break;
69  		case 't':
70  			dotimeout = 1;
71  			break;
72  		case 'n':
73  			dononblock = 1;
74  			break;
75  		case 'q':
76  			quiet = 1;
77  			break;
78  		default:
79  			usage();
80  		}
81  	}
<span onclick='openModal()' class='match'>82  	if (doselect && dopoll) {
83  		fprintf(stderr, "selpolltest: choose select (-s) or poll (-p), but not both\n");
84  		return 1;
85  	}
86  	if (dotimeout && !doselect && !dopoll) {
87  		fprintf(stderr, "selpolltest: timeout (-t) requires select (-s) or poll (-p)\n");
88  		return 1;
89  	}
</span>90  	if (device == NULL) {
91  		if (pcap_findalldevs(&devlist, ebuf) == -1)
92  			error("%s", ebuf);
93  		if (devlist == NULL)
94  			error("no interfaces available for capture");
95  		device = strdup(devlist->name);
96  		pcap_freealldevs(devlist);
97  	}
98  	*ebuf = '\0';
99  	pd = pcap_open_live(device, 65535, 0, 1000, ebuf);
100  	if (pd == NULL)
101  		error("%s", ebuf);
102  	else if (*ebuf)
103  		warning("%s", ebuf);
104  	if (pcap_lookupnet(device, &localnet, &netmask, ebuf) < 0) {
105  		localnet = 0;
106  		netmask = 0;
107  		warning("%s", ebuf);
108  	}
109  	cmdbuf = copy_argv(&argv[optind]);
110  	if (pcap_compile(pd, &fcode, cmdbuf, 1, netmask) < 0)
111  		error("%s", pcap_geterr(pd));
112  	if (pcap_setfilter(pd, &fcode) < 0)
113  		error("%s", pcap_geterr(pd));
114  	if (doselect || dopoll) {
115  		selectable_fd = pcap_get_selectable_fd(pd);
116  		if (selectable_fd == -1) {
117  			printf("Listening on %s, using %s, with a timeout\n",
118  			    device, mechanism);
119  			required_timeout = pcap_get_required_select_timeout(pd);
120  			if (required_timeout == NULL)
121  				error("select()/poll() isn't supported on %s, even with a timeout",
122  				    device);
123  			dononblock = 1;
124  		} else {
125  			printf("Listening on %s, using %s\n", device,
126  			    mechanism);
127  			required_timeout = NULL;
128  		}
129  	} else
130  		printf("Listening on %s, using pcap_dispatch()\n", device);
131  	if (dononblock) {
132  		if (pcap_setnonblock(pd, 1, ebuf) == -1)
133  			error("pcap_setnonblock failed: %s", ebuf);
134  	}
135  	if (doselect) {
136  		for (;;) {
137  			fd_set setread, setexcept;
138  			struct timeval seltimeout;
139  			struct timeval *timeoutp;
140  			FD_ZERO(&setread);
141  			if (selectable_fd != -1) {
142  				FD_SET(selectable_fd, &setread);
143  				FD_ZERO(&setexcept);
144  				FD_SET(selectable_fd, &setexcept);
145  			}
146  			required_timeout = pcap_get_required_select_timeout(pd);
147  			if (dotimeout) {
148  				seltimeout.tv_sec = 0;
149  				if (required_timeout != NULL &&
150  				    required_timeout->tv_usec < 1000)
151  					seltimeout.tv_usec = required_timeout->tv_usec;
152  				else
153  					seltimeout.tv_usec = 1000;
154  				timeoutp = &seltimeout;
155  			} else if (required_timeout != NULL) {
156  				seltimeout = *required_timeout;
157  				timeoutp = &seltimeout;
158  			} else {
159  				timeoutp = NULL;
160  			}
161  			status = select((selectable_fd == -1) ?
162  			    0 : selectable_fd + 1, &setread, NULL, &setexcept,
163  			    timeoutp);
164  			if (status == -1) {
165  				printf("Select returns error (%s)\n",
166  				    strerror(errno));
167  			} else {
168  				if (!quiet) {
169  					if (status == 0)
170  						printf("Select timed out: ");
171  					else{
172  						printf("Select returned a descriptor: ");
173  						if (FD_ISSET(selectable_fd, &setread))
174  							printf("readable, ");
175  						else
176  							printf("not readable, ");
177  						if (FD_ISSET(selectable_fd, &setexcept))
178  							printf("exceptional condition\n");
179  						else
180  							printf("no exceptional condition\n");
181  					}
182  				}
183  				packet_count = 0;
184  				status = pcap_dispatch(pd, -1, countme,
185  				    (u_char *)&packet_count);
186  				if (status < 0)
187  					break;
188  				if (status != 0 || packet_count != 0 ||
189  				    required_timeout != NULL) {
190  					printf("%d packets seen, %d packets counted after select returns\n",
191  					    status, packet_count);
192  				}
193  			}
194  		}
195  	} else if (dopoll) {
196  		for (;;) {
197  			struct pollfd fd;
198  			int polltimeout;
199  			fd.fd = selectable_fd;
200  			fd.events = POLLIN;
201  			required_timeout = pcap_get_required_select_timeout(pd);
202  			if (dotimeout)
203  				polltimeout = 1;
204  			else if (required_timeout != NULL &&
205  			    required_timeout->tv_usec >= 1000)
206  				polltimeout = (int)(required_timeout->tv_usec/1000);
207  			else
208  				polltimeout = -1;
209  			status = poll(&fd, (selectable_fd == -1) ? 0 : 1, polltimeout);
210  			if (status == -1) {
211  				printf("Poll returns error (%s)\n",
212  				    strerror(errno));
213  			} else {
214  				if (!quiet) {
215  					if (status == 0)
216  						printf("Poll timed out\n");
217  					else {
218  						printf("Poll returned a descriptor: ");
219  						if (fd.revents & POLLIN)
220  							printf("readable, ");
221  						else
222  							printf("not readable, ");
223  						if (fd.revents & POLLERR)
224  							printf("exceptional condition, ");
225  						else
226  							printf("no exceptional condition, ");
227  						if (fd.revents & POLLHUP)
228  							printf("disconnect, ");
229  						else
230  							printf("no disconnect, ");
231  						if (fd.revents & POLLNVAL)
232  							printf("invalid\n");
233  						else
234  							printf("not invalid\n");
235  					}
236  				}
237  				packet_count = 0;
238  				status = pcap_dispatch(pd, -1, countme,
239  				    (u_char *)&packet_count);
240  				if (status < 0)
241  					break;
242  				if (status != 0 || packet_count != 0 ||
243  				    required_timeout != NULL) {
244  					printf("%d packets seen, %d packets counted after poll returns\n",
245  					    status, packet_count);
246  				}
247  			}
248  		}
249  	} else {
250  		for (;;) {
251  			packet_count = 0;
252  			status = pcap_dispatch(pd, -1, countme,
253  			    (u_char *)&packet_count);
254  			if (status < 0)
255  				break;
256  			printf("%d packets seen, %d packets counted after pcap_dispatch returns\n",
257  			    status, packet_count);
258  		}
259  	}
260  	if (status == -2) {
261  		putchar('\n');
262  	}
263  	(void)fflush(stdout);
264  	if (status == -1) {
265  		(void)fprintf(stderr, "%s: pcap_dispatch: %s\n",
266  		    program_name, pcap_geterr(pd));
267  	}
268  	pcap_close(pd);
269  	exit(status == -1 ? 1 : 0);
270  }
271  static void
272  countme(u_char *user, const struct pcap_pkthdr *h _U_, const u_char *sp _U_)
273  {
274  	int *counterp = (int *)user;
275  	(*counterp)++;
276  }
277  static void
278  usage(void)
279  {
280  	(void)fprintf(stderr, "Usage: %s [ -sptnq ] [ -i interface ] [expression]\n",
281  	    program_name);
282  	exit(1);
283  }
284  static void
285  error(const char *fmt, ...)
286  {
287  	va_list ap;
288  	(void)fprintf(stderr, "%s: ", program_name);
289  	va_start(ap, fmt);
290  	(void)vfprintf(stderr, fmt, ap);
291  	va_end(ap);
292  	if (*fmt) {
293  		fmt += strlen(fmt);
294  		if (fmt[-1] != '\n')
295  			(void)fputc('\n', stderr);
296  	}
297  	exit(1);
298  }
299  static void
300  warning(const char *fmt, ...)
301  {
302  	va_list ap;
303  	(void)fprintf(stderr, "%s: WARNING: ", program_name);
304  	va_start(ap, fmt);
305  	(void)vfprintf(stderr, fmt, ap);
306  	va_end(ap);
307  	if (*fmt) {
308  		fmt += strlen(fmt);
309  		if (fmt[-1] != '\n')
310  			(void)fputc('\n', stderr);
311  	}
312  }
313  static char *
314  copy_argv(register char **argv)
315  {
316  	register char **p;
317  	register size_t len = 0;
318  	char *buf;
319  	char *src, *dst;
320  	p = argv;
321  	if (*p == 0)
322  		return 0;
323  	while (*p)
324  		len += strlen(*p++) + 1;
325  	buf = (char *)malloc(len);
326  	if (buf == NULL)
327  		error("copy_argv: malloc");
328  	p = argv;
329  	dst = buf;
330  	while ((src = *p++) != NULL) {
331  		while ((*dst++ = *src++) != '\0')
332  			;
333  		dst[-1] = ' ';
334  	}
335  	dst[-1] = '\0';
336  	return buf;
337  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from redis-MDEwOlJlcG9zaXRvcnkxMDgxMTA3MDY=-flat-arena_inlines_b.h</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from libpcap-MDEwOlJlcG9zaXRvcnk5NDM1ODg3-flat-selpolltest.c</div>
                </div>
                <div class="column column_space"><pre><code>128  		if (likely(size <= SC_SMALL_MAXCLASS)) {
129  			return tcache_alloc_small(tsdn_tsd(tsdn), arena,
130  			    tcache, size, ind, zero, slow_path);
131  		}
132  		if (likely(size <= tcache_maxclass)) {
133  			return tcache_alloc_large(tsdn_tsd(tsdn), arena,
134  			    tcache, size, ind, zero, slow_path);
135  		}
</pre></code></div>
                <div class="column column_space"><pre><code>82  	if (doselect && dopoll) {
83  		fprintf(stderr, "selpolltest: choose select (-s) or poll (-p), but not both\n");
84  		return 1;
85  	}
86  	if (dotimeout && !doselect && !dopoll) {
87  		fprintf(stderr, "selpolltest: timeout (-t) requires select (-s) or poll (-p)\n");
88  		return 1;
89  	}
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    