<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for mmexternal.c &amp; omczmq.c</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for mmexternal.c &amp; omczmq.c
      </h3>
<h1 align="center">
        4.6%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>mmexternal.c (5.159705%)<th>omczmq.c (4.242424%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(89-99)<td><a href="#" name="0">(48-59)</a><td align="center"><font color="#ff0000">21</font>
</td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>mmexternal.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 #include "config.h"
2 #include &lt;stdio.h&gt;
3 #include &lt;stdarg.h&gt;
4 #include &lt;stdlib.h&gt;
5 #include &lt;string.h&gt;
6 #include &lt;assert.h&gt;
7 #include &lt;signal.h&gt;
8 #include &lt;errno.h&gt;
9 #include &lt;unistd.h&gt;
10 #include &lt;fcntl.h&gt;
11 #include &lt;sys/wait.h&gt;
12 #include &lt;sys/uio.h&gt;
13 #include "rsyslog.h"
14 #include "conf.h"
15 #include "syslogd-types.h"
16 #include "srUtils.h"
17 #include "module-template.h"
18 #include "msg.h"
19 #include "errmsg.h"
20 #include "cfsysline.h"
21 #include "glbl.h"
22 #include "rsconf.h"
23 MODULE_TYPE_OUTPUT
24 MODULE_TYPE_NOKEEP
25 MODULE_CNFNAME("mmexternal")
26 DEF_OMOD_STATIC_DATA
27 typedef struct _instanceData {
28 	int bForceSingleInst;		int inputProp;		#define	INPUT_MSG 0
29 #define	INPUT_RAWMSG 1
30 #define INPUT_JSON 2
31 	uchar *outputFileName;		pthread_mutex_t mut;	} instanceData;
32 typedef struct wrkrInstanceData {
33 	instanceData *pData;
34 	pid_t pid;			int fdOutput;			int fdPipeOut;			int fdPipeIn;			int bIsRunning;			char *respBuf;			int maxLenRespBuf;		int lenRespBuf;			int idxRespBuf;		} wrkrInstanceData_t;
35 typedef struct configSettings_s {
36 	uchar *szBinary;	} configSettings_t;
37 static configSettings_t cs;
38 <a name="0"></a>
39 <font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>static struct cnfparamdescr actpdescr[] = {
40 	{ "binary", eCmdHdlrString, CNFPARAM_REQUIRED },
41 	{ "interface.input", eCmdHdlrString, 0 },
42 	{ "output", eCmdHdlrString, 0 },
43 	{ "forcesingleinstance", eCmdHdlrBinary, 0 }
44 };
45 static struct cnfparamblk actpblk =
46 	{ CNFPARAMBLK_VERSION,
47 	  sizeof(actpdescr)/sizeof(struct cnfparamdescr),
48 	  actpdescr
49 	};</b></font>
50 BEGINinitConfVars		CODESTARTinitConfVars
51 	cs.szBinary = NULL;	ENDinitConfVars
52 BEGINcreateInstance
53 CODESTARTcreateInstance
54 	pData-&gt;inputProp = INPUT_MSG;
55 	pthread_mutex_init(&amp;pData-&gt;mut, NULL);
56 ENDcreateInstance
57 BEGINcreateWrkrInstance
58 CODESTARTcreateWrkrInstance
59 	pWrkrData-&gt;fdPipeIn = -1;
60 	pWrkrData-&gt;fdPipeOut = -1;
61 	pWrkrData-&gt;fdOutput = -1;
62 	pWrkrData-&gt;bIsRunning = 0;
63 	pWrkrData-&gt;respBuf = NULL;
64 	pWrkrData-&gt;maxLenRespBuf = 0;
65 	pWrkrData-&gt;lenRespBuf = 0;
66 	pWrkrData-&gt;idxRespBuf = 0;
67 ENDcreateWrkrInstance
68 BEGINisCompatibleWithFeature
69 CODESTARTisCompatibleWithFeature
70 	if(eFeat == sFEATURERepeatedMsgReduction)
71 		iRet = RS_RET_OK;
72 ENDisCompatibleWithFeature
73 BEGINfreeInstance
74 	int i;
75 CODESTARTfreeInstance
76 	pthread_mutex_destroy(&amp;pData-&gt;mut);
77 	free(pData-&gt;szBinary);
78 	free(pData-&gt;outputFileName);
79 	if(pData-&gt;aParams != NULL) {
80 		for (i = 0; i &lt; pData-&gt;iParams; i++) {
81 			free(pData-&gt;aParams[i]);
82 		}
83 		free(pData-&gt;aParams);
84 	}
85 ENDfreeInstance
86 BEGINfreeWrkrInstance
87 CODESTARTfreeWrkrInstance
88 	free(pWrkrData-&gt;respBuf);
89 ENDfreeWrkrInstance
90 BEGINdbgPrintInstInfo
91 CODESTARTdbgPrintInstInfo
92 ENDdbgPrintInstInfo
93 BEGINtryResume
94 CODESTARTtryResume
95 ENDtryResume
96 static void
97 writeOutputDebug(wrkrInstanceData_t *__restrict__ const pWrkrData,
98 	const char *__restrict__ const buf,
99 	const ssize_t lenBuf)
100 {
101 	char errStr[1024];
102 	ssize_t r;
103 	if(pWrkrData-&gt;pData-&gt;outputFileName == NULL)
104 		goto done;
105 	if(pWrkrData-&gt;fdOutput == -1) {
106 		pWrkrData-&gt;fdOutput = open((char*)pWrkrData-&gt;pData-&gt;outputFileName,
107 				       O_WRONLY | O_APPEND | O_CREAT, 0600);
108 		if(pWrkrData-&gt;fdOutput == -1) {
109 			DBGPRINTF("mmexternal: error opening output file %s: %s\n",
110 				   pWrkrData-&gt;pData-&gt;outputFileName,
111 				   rs_strerror_r(errno, errStr, sizeof(errStr)));
112 			goto done;
113 		}
114 	}
115 	r = write(pWrkrData-&gt;fdOutput, buf, (size_t) lenBuf);
116 	if(r != lenBuf) {
117 		DBGPRINTF("mmexternal: problem writing output file %s: bytes "
118 			  "requested %lld, written %lld, msg: %s\n",
119 			   pWrkrData-&gt;pData-&gt;outputFileName, (long long) lenBuf, (long long) r,
120 			   rs_strerror_r(errno, errStr, sizeof(errStr)));
121 	}
122 done:	return;
123 }
124 static void
125 processProgramReply(wrkrInstanceData_t *__restrict__ const pWrkrData, smsg_t *const pMsg)
126 {
127 	rsRetVal iRet;
128 	char errStr[1024];
129 	ssize_t r;
130 	int numCharsRead;
131 	char *newptr;
132 	numCharsRead = 0;
133 	do {
134 		if(pWrkrData-&gt;maxLenRespBuf &lt; numCharsRead + 256) { 			pWrkrData-&gt;maxLenRespBuf += 4096;
135 			if((newptr = realloc(pWrkrData-&gt;respBuf, pWrkrData-&gt;maxLenRespBuf)) == NULL) {
136 				DBGPRINTF("mmexternal: error realloc responseBuf: %s\n",
137 					   rs_strerror_r(errno, errStr, sizeof(errStr)));
138 				strcpy(pWrkrData-&gt;respBuf, "{}\n");
139 				numCharsRead = 3;
140 				break;
141 			}
142 			pWrkrData-&gt;respBuf = newptr;
143 		}
144 		r = read(pWrkrData-&gt;fdPipeIn, pWrkrData-&gt;respBuf+numCharsRead,
145 			 pWrkrData-&gt;maxLenRespBuf-numCharsRead-1);
146 		if(r &gt; 0) {
147 			numCharsRead += r;
148 			pWrkrData-&gt;respBuf[numCharsRead] = '\0'; 		} else {
149 			strcpy(pWrkrData-&gt;respBuf, "{}\n");
150 			numCharsRead = 3;
151 		}
152 		if(Debug &amp;&amp; r == -1) {
153 			DBGPRINTF("mmexternal: error reading from external program: %s\n",
154 				   rs_strerror_r(errno, errStr, sizeof(errStr)));
155 		}
156 	} while(pWrkrData-&gt;respBuf[numCharsRead-1] != '\n');
157 	writeOutputDebug(pWrkrData, pWrkrData-&gt;respBuf, numCharsRead);
158 	pWrkrData-&gt;respBuf[numCharsRead-1] = '\0';
159 	iRet = MsgSetPropsViaJSON(pMsg, (uchar*)pWrkrData-&gt;respBuf);
160 	if(iRet != RS_RET_OK) {
161 		LogError(0, iRet, "mmexternal: invalid reply '%s' from program '%s'",
162 				pWrkrData-&gt;respBuf, pWrkrData-&gt;pData-&gt;szBinary);
163 	}
164 	return;
165 }
166 static void __attribute__((noreturn))
167 execBinary(wrkrInstanceData_t *pWrkrData, const int fdStdin, const int fdStdOutErr)
168 {
169 	int i;
170 	struct sigaction sigAct;
171 	sigset_t set;
172 	char *newenviron[] = { NULL };
173 	if(dup2(fdStdin, STDIN_FILENO) == -1) {
174 		perror("mmexternal: dup() stdin failed\n");
175 	}
176 	if(dup2(fdStdOutErr, STDOUT_FILENO) == -1) {
177 		perror("mmexternal: dup() stdout failed\n");
178 	}
179 	if(dup2(fdStdOutErr, STDERR_FILENO) == -1) {
180 		perror("mmexternal: dup() stderr failed\n");
181 	}
182 #	ifndef VALGRIND 	for(i = 3 ; i &lt;= 65535 ; ++i)
183 		close(i);
184 #	endif
185 	memset(&amp;sigAct, 0, sizeof(sigAct));
186 	sigemptyset(&amp;sigAct.sa_mask);
187 	sigAct.sa_handler = SIG_DFL;
188 	for(i = 1 ; i &lt; NSIG ; ++i)
189 		sigaction(i, &amp;sigAct, NULL);
190 	sigAct.sa_handler = SIG_IGN;
191 	sigaction(SIGINT, &amp;sigAct, NULL);
192 	sigemptyset(&amp;set);
193 	sigprocmask(SIG_SETMASK, &amp;set, NULL);
194 	alarm(0);
195 	execve((char*)pWrkrData-&gt;pData-&gt;szBinary, pWrkrData-&gt;pData-&gt;aParams, newenviron);
196 	char errstr[1024];
197 	char errbuf[2048];
198 	rs_strerror_r(errno, errstr, sizeof(errstr));
199 	errstr[sizeof(errstr)-1] = '\0';
200 	const size_t lenbuf = snprintf(errbuf, sizeof(errbuf),
201 		"mmexternal: failed to execute binary '%s': %s\n",
202 		  pWrkrData-&gt;pData-&gt;szBinary, errstr);
203 	errbuf[sizeof(errbuf)-1] = '\0';
204 	if(write(2, errbuf, lenbuf) != (ssize_t) lenbuf) {
205 		exit(2);
206 	}
207 	exit(1);
208 }
209 static rsRetVal
210 openPipe(wrkrInstanceData_t *pWrkrData)
211 {
212 	int pipestdin[2];
213 	int pipestdout[2];
214 	pid_t cpid;
215 	DEFiRet;
216 	if(pipe(pipestdin) == -1) {
217 		ABORT_FINALIZE(RS_RET_ERR_CREAT_PIPE);
218 	}
219 	if(pipe(pipestdout) == -1) {
220 		ABORT_FINALIZE(RS_RET_ERR_CREAT_PIPE);
221 	}
222 	DBGPRINTF("mmexternal: executing program '%s' with '%d' parameters\n",
223 		  pWrkrData-&gt;pData-&gt;szBinary, pWrkrData-&gt;pData-&gt;iParams);
224 	assert(pWrkrData-&gt;pData-&gt;szBinary != NULL);
225 	assert(pWrkrData-&gt;pData-&gt;aParams != NULL);
226 	cpid = fork();
227 	if(cpid == -1) {
228 		ABORT_FINALIZE(RS_RET_ERR_FORK);
229 	}
230 	pWrkrData-&gt;pid = cpid;
231 	if(cpid == 0) {
232 		close(pipestdin[1]); 		close(pipestdout[0]); 		execBinary(pWrkrData, pipestdin[0], pipestdout[1]);
233 	}
234 	DBGPRINTF("mmexternal: child has pid %d\n", (int) cpid);
235 	pWrkrData-&gt;fdPipeIn = dup(pipestdout[0]);
236 	close(pipestdin[0]);
237 	close(pipestdout[1]);
238 	pWrkrData-&gt;pid = cpid;
239 	pWrkrData-&gt;fdPipeOut = pipestdin[1];
240 	pWrkrData-&gt;bIsRunning = 1;
241 finalize_it:
242 	RETiRet;
243 }
244 static rsRetVal
245 cleanup(wrkrInstanceData_t *pWrkrData)
246 {
247 	int status;
248 	int ret;
249 	DEFiRet;
250 	assert(pWrkrData-&gt;bIsRunning == 1);
251 	ret = waitpid(pWrkrData-&gt;pid, &amp;status, 0);
252 	if(ret == pWrkrData-&gt;pid) {
253 		glblReportChildProcessExit(runConf, pWrkrData-&gt;pData-&gt;szBinary, pWrkrData-&gt;pid, status);
254 	}
255 	if(pWrkrData-&gt;fdOutput != -1) {
256 		close(pWrkrData-&gt;fdOutput);
257 		pWrkrData-&gt;fdOutput = -1;
258 	}
259 	if(pWrkrData-&gt;fdPipeIn != -1) {
260 		close(pWrkrData-&gt;fdPipeIn);
261 		pWrkrData-&gt;fdPipeIn = -1;
262 	}
263 	if(pWrkrData-&gt;fdPipeOut != -1) {
264 		close(pWrkrData-&gt;fdPipeOut);
265 		pWrkrData-&gt;fdPipeOut = -1;
266 	}
267 	pWrkrData-&gt;bIsRunning = 0;
268 	pWrkrData-&gt;bIsRunning = 0;
269 	RETiRet;
270 }
271 static rsRetVal
272 tryRestart(wrkrInstanceData_t *pWrkrData)
273 {
274 	DEFiRet;
275 	assert(pWrkrData-&gt;bIsRunning == 0);
276 	iRet = openPipe(pWrkrData);
277 	RETiRet;
278 }
279 static rsRetVal
280 callExtProg(wrkrInstanceData_t *__restrict__ const pWrkrData, smsg_t *__restrict__ const pMsg)
281 {
282 	int lenWritten;
283 	int lenWrite;
284 	int writeOffset;
285 	int i_iov;
286 	struct iovec iov[2];
287 	int bFreeInputstr = 1; 	const uchar *inputstr = NULL; 	DEFiRet;
288 	if(pWrkrData-&gt;pData-&gt;inputProp == INPUT_MSG) {
289 		inputstr = getMSG(pMsg);
290 		lenWrite = getMSGLen(pMsg);
291 		bFreeInputstr = 0;
292 	} else if(pWrkrData-&gt;pData-&gt;inputProp == INPUT_RAWMSG) {
293 		getRawMsg(pMsg, (uchar**)&amp;inputstr, &amp;lenWrite);
294 		bFreeInputstr = 0;
295 	} else  {
296 		inputstr = msgGetJSONMESG(pMsg);
297 		lenWrite = strlen((const char*)inputstr);
298 	}
299 	writeOffset = 0;
300 	do {
301 		DBGPRINTF("mmexternal: writing to prog (fd %d, offset %d): %s\n",
302 			  pWrkrData-&gt;fdPipeOut, (int) writeOffset, inputstr);
303 		i_iov = 0;
304 		if(writeOffset &lt; lenWrite) {
305 			iov[0].iov_base = (char*)inputstr+writeOffset;
306 			iov[0].iov_len = lenWrite - writeOffset;
307 			++i_iov;
308 		}
309 		iov[i_iov].iov_base = (void*)"\n";
310 		iov[i_iov].iov_len = 1;
311 		lenWritten = writev(pWrkrData-&gt;fdPipeOut, iov, i_iov+1);
312 		if(lenWritten == -1) {
313 			switch(errno) {
314 			case EPIPE:
315 				LogMsg(0, RS_RET_ERR_WRITE_PIPE, LOG_WARNING,
316 						"mmexternal: program '%s' (pid %ld) terminated; will be restarted",
317 						pWrkrData-&gt;pData-&gt;szBinary, (long) pWrkrData-&gt;pid);
318 				CHKiRet(cleanup(pWrkrData));
319 				CHKiRet(tryRestart(pWrkrData));
320 				writeOffset = 0;
321 				break;
322 			default:
323 				LogError(errno, RS_RET_ERR_WRITE_PIPE, "mmexternal: error sending message to program");
324 				ABORT_FINALIZE(RS_RET_ERR_WRITE_PIPE);
325 				break;
326 			}
327 		} else {
328 			writeOffset += lenWritten;
329 		}
330 	} while(lenWritten != lenWrite+1);
331 	processProgramReply(pWrkrData, pMsg);
332 finalize_it:
333 	if(bFreeInputstr) {
334 		free((void*)inputstr);
335 	}
336 	RETiRet;
337 }
338 BEGINdoAction_NoStrings
339 	smsg_t **ppMsg = (smsg_t **) pMsgData;
340 	smsg_t *pMsg = ppMsg[0];
341 	instanceData *pData;
342 CODESTARTdoAction
343 	pData = pWrkrData-&gt;pData;
344 	if(pData-&gt;bForceSingleInst)
345 		pthread_mutex_lock(&amp;pData-&gt;mut);
346 	if(pWrkrData-&gt;bIsRunning == 0) {
347 		openPipe(pWrkrData);
348 	}
349 	iRet = callExtProg(pWrkrData, pMsg);
350 	if(iRet != RS_RET_OK)
351 		iRet = RS_RET_SUSPENDED;
352 	if(pData-&gt;bForceSingleInst)
353 		pthread_mutex_unlock(&amp;pData-&gt;mut);
354 ENDdoAction
355 static void
356 setInstParamDefaults(instanceData *pData)
357 {
358 	pData-&gt;szBinary = NULL;
359 	pData-&gt;aParams = NULL;
360 	pData-&gt;outputFileName = NULL;
361 	pData-&gt;iParams = 0;
362 	pData-&gt;bForceSingleInst = 0;
363 }
364 BEGINnewActInst
365 	struct cnfparamvals *pvals;
366 	int i;
367 	const char *cstr = NULL;
368 CODESTARTnewActInst
369 	if((pvals = nvlstGetParams(lst, &amp;actpblk, NULL)) == NULL) {
370 		ABORT_FINALIZE(RS_RET_MISSING_CNFPARAMS);
371 	}
372 	CHKiRet(createInstance(&amp;pData));
373 	setInstParamDefaults(pData);
374 	CODE_STD_STRING_REQUESTnewActInst(1)
375 	for(i = 0 ; i &lt; actpblk.nParams ; ++i) {
376 		if(!pvals[i].bUsed)
377 			continue;
378 		if(!strcmp(actpblk.descr[i].name, "binary")) {
379 			CHKiRet(split_binary_parameters(&amp;pData-&gt;szBinary, &amp;pData-&gt;aParams, &amp;pData-&gt;iParams,
380 				pvals[i].val.d.estr));
381 		} else if(!strcmp(actpblk.descr[i].name, "output")) {
382 			pData-&gt;outputFileName = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
383 		} else if(!strcmp(actpblk.descr[i].name, "forcesingleinstance")) {
384 			pData-&gt;bForceSingleInst = (int) pvals[i].val.d.n;
385 		} else if(!strcmp(actpblk.descr[i].name, "interface.input")) {
386 			cstr = es_str2cstr(pvals[i].val.d.estr, NULL);
387 			if(!strcmp(cstr, "msg"))
388 				pData-&gt;inputProp = INPUT_MSG;
389 			else if(!strcmp(cstr, "rawmsg"))
390 				pData-&gt;inputProp = INPUT_RAWMSG;
391 			else if(!strcmp(cstr, "fulljson"))
392 				pData-&gt;inputProp = INPUT_JSON;
393 			else {
394 				LogError(0, RS_RET_INVLD_INTERFACE_INPUT,
395 					"mmexternal: invalid interface.input parameter '%s'",
396 					cstr);
397 				ABORT_FINALIZE(RS_RET_INVLD_INTERFACE_INPUT);
398 			}
399 		} else {
400 			DBGPRINTF("mmexternal: program error, non-handled param '%s'\n", actpblk.descr[i].name);
401 		}
402 	}
403 	CHKiRet(OMSRsetEntry(*ppOMSR, 0, NULL, OMSR_TPL_AS_MSG));
404 	DBGPRINTF("mmexternal: bForceSingleInst %d\n", pData-&gt;bForceSingleInst);
405 	DBGPRINTF("mmexternal: interface.input '%s', mode %d\n", cstr, pData-&gt;inputProp);
406 CODE_STD_FINALIZERnewActInst
407 	free((void*)cstr);
408 	cnfparamvalsDestruct(pvals, &amp;actpblk);
409 ENDnewActInst
410 NO_LEGACY_CONF_parseSelectorAct
411 BEGINmodExit
412 CODESTARTmodExit
413 	free(cs.szBinary);
414 	cs.szBinary = NULL;
415 ENDmodExit
416 BEGINqueryEtryPt
417 CODESTARTqueryEtryPt
418 CODEqueryEtryPt_STD_OMOD_QUERIES
419 CODEqueryEtryPt_STD_OMOD8_QUERIES
420 CODEqueryEtryPt_STD_CONF2_CNFNAME_QUERIES
421 CODEqueryEtryPt_STD_CONF2_OMOD_QUERIES
422 ENDqueryEtryPt
423 BEGINmodInit()
424 CODESTARTmodInit
425 INITLegCnfVars
426 	*ipIFVersProvided = CURR_MOD_IF_VERSION; CODEmodInit_QueryRegCFSLineHdlr
427 CODEmodInit_QueryRegCFSLineHdlr
428 ENDmodInit
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>omczmq.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 #include "config.h"
2 #include "rsyslog.h"
3 #include &lt;stdio.h&gt;
4 #include &lt;stdarg.h&gt;
5 #include &lt;stdlib.h&gt;
6 #include &lt;string.h&gt;
7 #include &lt;assert.h&gt;
8 #include &lt;signal.h&gt;
9 #include &lt;errno.h&gt;
10 #include &lt;unistd.h&gt;
11 #include "conf.h"
12 #include "syslogd-types.h"
13 #include "srUtils.h"
14 #include "template.h"
15 #include "module-template.h"
16 #include "errmsg.h"
17 #include "cfsysline.h"
18 #include &lt;czmq.h&gt;
19 MODULE_TYPE_OUTPUT
20 MODULE_TYPE_NOKEEP
21 MODULE_CNFNAME("omczmq")
22 DEF_OMOD_STATIC_DATA
23 <a name="0"></a>
24 static pthread_mutex_t mutDoAct = PTHREAD_MUTEX_INITIALIZER;
25 <font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>static struct cnfparamdescr modpdescr[] = {
26 	{ "authenticator", eCmdHdlrBinary, 0 },
27 	{ "authtype", eCmdHdlrGetWord, 0 },
28 	{ "clientcertpath", eCmdHdlrGetWord, 0 },
29 	{ "servercertpath", eCmdHdlrGetWord, 0 }
30 };
31 static struct cnfparamblk modpblk = {
32 	CNFPARAMBLK_VERSION,
33 	sizeof(modpdescr)/sizeof(struct cnfparamdescr),
34 	modpdescr
35 };</b></font>
36 struct modConfData_s {
37 	rsconf_t *pConf;
38 	uchar *tplName;
39 	int authenticator;
40 	char *authType;
41 	char *serverCertPath;
42 	char *clientCertPath;
43 };
44 static modConfData_t *runModConf = NULL;
45 static zactor_t *authActor;
46 typedef struct _instanceData {
47 	zsock_t *sock;
48 	bool serverish;
49 	int sendTimeout;
50 	zlist_t *topics;
51 	bool sendError;
52 	char *sockEndpoints;
53 	int sockType;
54 	int sendHWM;
55 #if(CZMQ_VERSION_MAJOR &gt;= 4 &amp;&amp; ZMQ_VERSION_MAJOR &gt;=4 &amp;&amp; ZMQ_VERSION_MINOR &gt;=2)
56 	int heartbeatIvl;
57 	int heartbeatTimeout;
58 	int heartbeatTTL;
59 	int connectTimeout;
60 #endif
61 	uchar *tplName;
62 	sbool topicFrame;
63 	sbool dynaTopic;
64 } instanceData;
65 typedef struct wrkrInstanceData {
66 	instanceData *pData;
67 } wrkrInstanceData_t;
68 static struct cnfparamdescr actpdescr[] = {
69 	{ "endpoints", eCmdHdlrGetWord, 1 },
70 	{ "socktype", eCmdHdlrGetWord, 1 },
71 	{ "sendhwm", eCmdHdlrGetWord, 0 },
72 #if(CZMQ_VERSION_MAJOR &gt;= 4 &amp;&amp; ZMQ_VERSION_MAJOR &gt;=4 &amp;&amp; ZMQ_VERSION_MINOR &gt;=2)
73 	{ "heartbeatttl", eCmdHdlrGetWord, 0},
74 	{ "heartbeativl", eCmdHdlrGetWord, 0},
75 	{ "heartbeattimeout", eCmdHdlrGetWord, 0},
76 	{ "connecttimeout", eCmdHdlrGetWord, 0},
77 #endif
78 	{ "sendtimeout", eCmdHdlrGetWord, 0 },
79 	{ "template", eCmdHdlrGetWord, 0 },
80 	{ "topics", eCmdHdlrGetWord, 0 },
81 	{ "topicframe", eCmdHdlrGetWord, 0},
82 	{ "dynatopic", eCmdHdlrBinary, 0 }
83 };
84 static struct cnfparamblk actpblk = {
85 	CNFPARAMBLK_VERSION,
86 	sizeof(actpdescr) / sizeof(struct cnfparamdescr),
87 	actpdescr
88 };
89 static rsRetVal initCZMQ(instanceData* pData) {
90 	DEFiRet;
91 	int rc;
92 	putenv((char*)"ZSYS_SIGHANDLER=false");
93 	pData-&gt;sock = zsock_new(pData-&gt;sockType);
94 	if(!pData-&gt;sock) {
95 		LogError(0, RS_RET_NO_ERRCODE,
96 				"omczmq: new socket failed for endpoints: %s",
97 				pData-&gt;sockEndpoints);
98 		ABORT_FINALIZE(RS_RET_SUSPENDED);
99 	}
100 	zsock_set_sndtimeo(pData-&gt;sock, pData-&gt;sendTimeout);
101 #if(CZMQ_VERSION_MAJOR &gt;= 4 &amp;&amp; ZMQ_VERSION_MAJOR &gt;=4 &amp;&amp; ZMQ_VERSION_MINOR &gt;=2)
102 	if(pData-&gt;heartbeatIvl &gt; 0 &amp;&amp; pData-&gt;heartbeatTimeout &gt; 0 &amp;&amp; pData-&gt;heartbeatTTL &gt; 0) {
103 		zsock_set_heartbeat_ivl(pData-&gt;sock, pData-&gt;heartbeatIvl);
104 		zsock_set_heartbeat_timeout(pData-&gt;sock, pData-&gt;heartbeatTimeout);
105 		zsock_set_heartbeat_ttl(pData-&gt;sock, pData-&gt;heartbeatTTL);
106 	}
107 #endif
108 	if(runModConf-&gt;authType) {
109 		if (!strcmp(runModConf-&gt;authType, "CURVESERVER")) {
110 			zcert_t *serverCert = zcert_load(runModConf-&gt;serverCertPath);
111 			if(!serverCert) {
112 				LogError(0, NO_ERRCODE, "could not load cert %s",
113 					runModConf-&gt;serverCertPath);
114 				ABORT_FINALIZE(RS_RET_ERR);
115 			}
116 			zsock_set_zap_domain(pData-&gt;sock, "global");
117 			zsock_set_curve_server(pData-&gt;sock, 1);
118 			zcert_apply(serverCert, pData-&gt;sock);
119 			zcert_destroy(&amp;serverCert);
120 		}
121 		else if(!strcmp(runModConf-&gt;authType, "CURVECLIENT")) {
122 			zcert_t *serverCert = zcert_load(runModConf-&gt;serverCertPath);
123 			if(!serverCert) {
124 				LogError(0, NO_ERRCODE, "could not load cert %s",
125 					runModConf-&gt;serverCertPath);
126 				ABORT_FINALIZE(RS_RET_ERR);
127 			}
128 			const char *server_key = zcert_public_txt(serverCert);
129 			zcert_destroy(&amp;serverCert);
130 			zsock_set_curve_serverkey(pData-&gt;sock, server_key);
131 			zcert_t *clientCert = zcert_load(runModConf-&gt;clientCertPath);
132 			if(!clientCert) {
133 				LogError(0, NO_ERRCODE, "could not load cert %s",
134 					runModConf-&gt;clientCertPath);
135 				ABORT_FINALIZE(RS_RET_ERR);
136 			}
137 			zcert_apply(clientCert, pData-&gt;sock);
138 			zcert_destroy(&amp;clientCert);
139 		}
140 	}
141 	switch(pData-&gt;sockType) {
142 		case ZMQ_PUB:
143 #if defined(ZMQ_RADIO)
144 		case ZMQ_RADIO:
145 #endif
146 			pData-&gt;serverish = true;
147 			break;
148 		case ZMQ_PUSH:
149 #if defined(ZMQ_SCATTER)
150 		case ZMQ_SCATTER:
151 #endif
152 		case ZMQ_DEALER:
153 #if defined(ZMQ_CLIENT)
154 		case ZMQ_CLIENT:
155 #endif
156 			pData-&gt;serverish = false;
157 			break;
158 	}
159 	rc = zsock_attach(pData-&gt;sock, pData-&gt;sockEndpoints, pData-&gt;serverish);
160 	if(rc == -1) {
161 		LogError(0, NO_ERRCODE, "zsock_attach to %s failed",
162 				pData-&gt;sockEndpoints);
163 		ABORT_FINALIZE(RS_RET_SUSPENDED);
164 	}
165 finalize_it:
166 	RETiRet;
167 }
168 static rsRetVal outputCZMQ(uchar** ppString, instanceData* pData) {
169 	DEFiRet;
170 	if(NULL == pData-&gt;sock) {
171 		CHKiRet(initCZMQ(pData));
172 	}
173 #if defined(ZMQ_RADIO)
174 	DBGPRINTF("omczmq: ZMQ_RADIO is defined...\n");
175 	if((pData-&gt;sockType == ZMQ_PUB || pData-&gt;sockType == ZMQ_RADIO) &amp;&amp; pData-&gt;topics) {
176 #else
177 	DBGPRINTF("omczmq: ZMQ_RADIO is NOT defined...\n");
178 	if(pData-&gt;sockType == ZMQ_PUB &amp;&amp; pData-&gt;topics) {
179 #endif
180 		int templateIndex = 1;
181 		const char *topic = (const char *)zlist_first(pData-&gt;topics);
182 		while(topic) {
183 			int rc;
184 			if(pData-&gt;dynaTopic)
185 				topic = (const char*)ppString[templateIndex];
186 			if (pData-&gt;sockType == ZMQ_PUB) {
187 				if(pData-&gt;topicFrame) {
188 					rc = zstr_sendx(pData-&gt;sock, topic, (char*)ppString[0], NULL);
189 				}
190 				else {
191 					rc = zstr_sendf(pData-&gt;sock, "%s%s", topic, (char*)ppString[0]);
192 				}
193 				if(rc != 0) {
194 					pData-&gt;sendError = true;
195 					ABORT_FINALIZE(RS_RET_SUSPENDED);
196 				}
197 			}
198 #if defined(ZMQ_RADIO)
199 			else if(pData-&gt;sockType == ZMQ_RADIO) {
200 				DBGPRINTF("omczmq: sending on RADIO socket...\n");
201 				zframe_t *frame = zframe_from((char*)ppString[0]);
202 				if (!frame) {
203 					DBGPRINTF("omczmq: failed to create frame...\n");
204 					pData-&gt;sendError = true;
205 					ABORT_FINALIZE(RS_RET_SUSPENDED);
206 				}
207 				rc = zframe_set_group(frame, topic);
208 				if (rc != 0) {
209 					DBGPRINTF("omczmq: failed to set group '%d'...\n", rc);
210 					pData-&gt;sendError = true;
211 					ABORT_FINALIZE(RS_RET_SUSPENDED);
212 				}
213 				DBGPRINTF("omczmq: set RADIO group to '%s'\n", topic);
214 				rc = zframe_send(&amp;frame, pData-&gt;sock, 0);
215 				if(rc != 0) {
216 					pData-&gt;sendError = true;
217 					ABORT_FINALIZE(RS_RET_SUSPENDED);
218 				}
219 			}
220 #endif
221 			topic = zlist_next(pData-&gt;topics);
222 			templateIndex++;
223 		}
224 	}
225 	else {
226 		int rc = zstr_send(pData-&gt;sock, (char*)ppString[0]);
227 		if(rc != 0) {
228 			pData-&gt;sendError = true;
229 			DBGPRINTF("omczmq: send error: %d", rc);
230 			ABORT_FINALIZE(RS_RET_SUSPENDED);
231 		}
232 	}
233 finalize_it:
234 	RETiRet;
235 }
236 static inline void
237 setInstParamDefaults(instanceData* pData) {
238 	pData-&gt;sockEndpoints = NULL;
239 	pData-&gt;sock = NULL;
240 	pData-&gt;sendError = false;
241 	pData-&gt;serverish = false;
242 	pData-&gt;tplName = NULL;
243 	pData-&gt;sockType = -1;
244 	pData-&gt;sendTimeout = -1;
245 	pData-&gt;topics = NULL;
246 	pData-&gt;topicFrame = false;
247 #if(CZMQ_VERSION_MAJOR &gt;= 4 &amp;&amp; ZMQ_VERSION_MAJOR &gt;=4 &amp;&amp; ZMQ_VERSION_MINOR &gt;=2)
248 	pData-&gt;heartbeatIvl = 0;
249 	pData-&gt;heartbeatTimeout = 0;
250 	pData-&gt;heartbeatTTL = 0;
251 #endif
252 }
253 BEGINcreateInstance
254 CODESTARTcreateInstance
255 ENDcreateInstance
256 BEGINcreateWrkrInstance
257 CODESTARTcreateWrkrInstance
258 ENDcreateWrkrInstance
259 BEGINisCompatibleWithFeature
260 CODESTARTisCompatibleWithFeature
261 	if(eFeat == sFEATURERepeatedMsgReduction) {
262 		iRet = RS_RET_OK;
263 	}
264 ENDisCompatibleWithFeature
265 BEGINdbgPrintInstInfo
266 CODESTARTdbgPrintInstInfo
267 ENDdbgPrintInstInfo
268 BEGINfreeInstance
269 CODESTARTfreeInstance
270 	zlist_destroy(&amp;pData-&gt;topics);
271 	zsock_destroy(&amp;pData-&gt;sock);
272 	free(pData-&gt;sockEndpoints);
273 	free(pData-&gt;tplName);
274 ENDfreeInstance
275 BEGINfreeWrkrInstance
276 CODESTARTfreeWrkrInstance
277 ENDfreeWrkrInstance
278 BEGINtryResume
279 	instanceData *pData;
280 CODESTARTtryResume
281 	pthread_mutex_lock(&amp;mutDoAct);
282 	pData = pWrkrData-&gt;pData;
283 	DBGPRINTF("omczmq: trying to resume...\n");
284 	zsock_destroy(&amp;pData-&gt;sock);
285 	iRet = initCZMQ(pData);
286 	pthread_mutex_unlock(&amp;mutDoAct);
287 ENDtryResume
288 BEGINbeginCnfLoad
289 CODESTARTbeginCnfLoad
290 	runModConf = pModConf;
291 	runModConf-&gt;pConf = pConf;
292 	runModConf-&gt;authenticator = 0;
293 	runModConf-&gt;authType = NULL;
294 	runModConf-&gt;serverCertPath = NULL;
295 	runModConf-&gt;clientCertPath = NULL;
296 ENDbeginCnfLoad
297 BEGINcheckCnf
298 CODESTARTcheckCnf
299 ENDcheckCnf
300 BEGINactivateCnf
301 CODESTARTactivateCnf
302 	runModConf = pModConf;
303 	if(runModConf-&gt;authenticator == 1) {
304 		if(!authActor) {
305 			DBGPRINTF("omczmq: starting authActor\n");
306 			authActor = zactor_new(zauth, NULL);
307 			if(!strcmp(runModConf-&gt;clientCertPath, "*")) {
308 				zstr_sendx(authActor, "CURVE", CURVE_ALLOW_ANY, NULL);
309 			}
310 			else {
311 				zstr_sendx(authActor, "CURVE", runModConf-&gt;clientCertPath, NULL);
312 			}
313 			zsock_wait(authActor);
314 		}
315 	}
316 ENDactivateCnf
317 BEGINfreeCnf
318 CODESTARTfreeCnf
319 	free(pModConf-&gt;tplName);
320 	free(pModConf-&gt;authType);
321 	free(pModConf-&gt;serverCertPath);
322 	free(pModConf-&gt;clientCertPath);
323 	DBGPRINTF("omczmq: stopping authActor\n");
324 	zactor_destroy(&amp;authActor);
325 ENDfreeCnf
326 BEGINsetModCnf
327 	struct cnfparamvals *pvals = NULL;
328 	int i;
329 CODESTARTsetModCnf
330 	pvals = nvlstGetParams(lst, &amp;modpblk, NULL);
331 	if (pvals == NULL) {
332 		LogError(0, RS_RET_MISSING_CNFPARAMS, "error processing module");
333 		ABORT_FINALIZE(RS_RET_MISSING_CNFPARAMS);
334 	}
335 	for (i=0; i&lt;modpblk.nParams; ++i) {
336 		if(!pvals[i].bUsed) {
337 			DBGPRINTF("omczmq: pvals[i].bUSed continuing\n");
338 			continue;
339 		}
340 		if(!strcmp(modpblk.descr[i].name, "authenticator")) {
341 			runModConf-&gt;authenticator = (int)pvals[i].val.d.n;
342 		}
343 		else if(!strcmp(modpblk.descr[i].name, "authtype")) {
344 			runModConf-&gt;authType = es_str2cstr(pvals[i].val.d.estr, NULL);
345 			DBGPRINTF("omczmq: authtype set to %s\n", runModConf-&gt;authType);
346 		}
347 		else if(!strcmp(modpblk.descr[i].name, "servercertpath")) {
348 			runModConf-&gt;serverCertPath = es_str2cstr(pvals[i].val.d.estr, NULL);
349 			DBGPRINTF("omczmq: serverCertPath set to %s\n", runModConf-&gt;serverCertPath);
350 		}
351 		else if(!strcmp(modpblk.descr[i].name, "clientcertpath")) {
352 			runModConf-&gt;clientCertPath = es_str2cstr(pvals[i].val.d.estr, NULL);
353 			DBGPRINTF("omczmq: clientCertPath set to %s\n", runModConf-&gt;clientCertPath);
354 		}
355 		else {
356 			LogError(0, RS_RET_INVALID_PARAMS,
357 						"omczmq: config error, unknown "
358 						"param %s in setModCnf\n",
359 						modpblk.descr[i].name);
360 		}
361 	}
362 	DBGPRINTF("omczmq: authenticator set to %d\n", runModConf-&gt;authenticator);
363 	DBGPRINTF("omczmq: authType set to %s\n", runModConf-&gt;authType);
364 	DBGPRINTF("omczmq: serverCertPath set to %s\n", runModConf-&gt;serverCertPath);
365 	DBGPRINTF("omczmq: clientCertPath set to %s\n", runModConf-&gt;clientCertPath);
366 finalize_it:
367 		if(pvals != NULL)
368 			cnfparamvalsDestruct(pvals, &amp;modpblk);
369 ENDsetModCnf
370 BEGINendCnfLoad
371 CODESTARTendCnfLoad
372 	runModConf = NULL;
373 ENDendCnfLoad
374 BEGINdoAction
375 	instanceData *pData;
376 CODESTARTdoAction
377 	pthread_mutex_lock(&amp;mutDoAct);
378 	pData = pWrkrData-&gt;pData;
379 	iRet = outputCZMQ(ppString, pData);
380 	pthread_mutex_unlock(&amp;mutDoAct);
381 ENDdoAction
382 BEGINnewActInst
383 	struct cnfparamvals *pvals;
384 	int i;
385 	int iNumTpls;
386 CODESTARTnewActInst
387 	if ((pvals = nvlstGetParams(lst, &amp;actpblk, NULL)) == NULL) {
388 		ABORT_FINALIZE(RS_RET_MISSING_CNFPARAMS);
389 	}
390 	CHKiRet(createInstance(&amp;pData));
391 	setInstParamDefaults(pData);
392 	for(i = 0; i &lt; actpblk.nParams; ++i) {
393 		if(!pvals[i].bUsed) {
394 			continue;
395 		}
396 		if(!strcmp(actpblk.descr[i].name, "endpoints")) {
397 			pData-&gt;sockEndpoints = es_str2cstr(pvals[i].val.d.estr, NULL);
398 			DBGPRINTF("omczmq: sockEndPoints set to '%s'\n", pData-&gt;sockEndpoints);
399 		}
400 		else if(!strcmp(actpblk.descr[i].name, "template")) {
401 			pData-&gt;tplName = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
402 			DBGPRINTF("omczmq: template set to '%s'\n", pData-&gt;tplName);
403 		}
404 		else if(!strcmp(actpblk.descr[i].name, "dynatopic")) {
405 			pData-&gt;dynaTopic = pvals[i].val.d.n;
406 			DBGPRINTF("omczmq: dynaTopic set to %s\n", pData-&gt;dynaTopic ? "true" : "false");
407 		}
408 		else if(!strcmp(actpblk.descr[i].name, "sendtimeout")) {
409 			pData-&gt;sendTimeout = atoi(es_str2cstr(pvals[i].val.d.estr, NULL));
410 			DBGPRINTF("omczmq: sendTimeout set to %d\n", pData-&gt;sendTimeout);
411 		}
412 		else if(!strcmp(actpblk.descr[i].name, "sendhwm")) {
413 			pData-&gt;sendTimeout = atoi(es_str2cstr(pvals[i].val.d.estr, NULL));
414 			DBGPRINTF("omczmq: sendHWM set to %d\n", pData-&gt;sendHWM);
415 		}
416 #if (CZMQ_VERSION_MAJOR &gt;= 4 &amp;&amp; ZMQ_VERSION_MAJOR &gt;=4 &amp;&amp; ZMQ_VERSION_MINOR &gt;=2)
417 		else if(!strcmp(actpblk.descr[i].name, "heartbeativl")) {
418 			pData-&gt;heartbeatIvl = atoi(es_str2cstr(pvals[i].val.d.estr, NULL));
419 			DBGPRINTF("omczmq: heartbeatbeatIvl set to %d\n", pData-&gt;heartbeatIvl);
420 		}
421 		else if(!strcmp(actpblk.descr[i].name, "heartbeattimeout")) {
422 			pData-&gt;heartbeatTimeout = atoi(es_str2cstr(pvals[i].val.d.estr, NULL));
423 			DBGPRINTF("omczmq: heartbeatTimeout set to %d\n", pData-&gt;heartbeatTimeout);
424 		}
425 		else if(!strcmp(actpblk.descr[i].name, "heartbeatttl")) {
426 			pData-&gt;heartbeatTimeout = atoi(es_str2cstr(pvals[i].val.d.estr, NULL));
427 			DBGPRINTF("omczmq: heartbeatTTL set to %d\n", pData-&gt;heartbeatTTL);
428 		}
429 #endif
430 		else if(!strcmp(actpblk.descr[i].name, "socktype")){
431 			char *stringType = es_str2cstr(pvals[i].val.d.estr, NULL);
432 			if(stringType != NULL){
433 				if(!strcmp("PUB", stringType)) {
434 					pData-&gt;sockType = ZMQ_PUB;
435 					DBGPRINTF("omczmq: sockType set to ZMQ_PUB\n");
436 				}
437 #if defined(ZMQ_RADIO)
438 				else if(!strcmp("RADIO", stringType)) {
439 					pData-&gt;sockType = ZMQ_RADIO;
440 					DBGPRINTF("omczmq: sockType set to ZMQ_RADIO\n");
441 				}
442 #endif
443 				else if(!strcmp("PUSH", stringType)) {
444 					pData-&gt;sockType = ZMQ_PUSH;
445 					DBGPRINTF("omczmq: sockType set to ZMQ_PUSH\n");
446 				}
447 #if defined(ZMQ_SCATTER)
448 				else if(!strcmp("SCATTER", stringType)) {
449 					pData-&gt;sockType = ZMQ_SCATTER;
450 					DBGPRINTF("omczmq: sockType set to ZMQ_SCATTER\n");
451 				}
452 #endif
453 				else if(!strcmp("DEALER", stringType)) {
454 					pData-&gt;sockType = ZMQ_DEALER;
455 					DBGPRINTF("omczmq: sockType set to ZMQ_DEALER\n");
456 				}
457 #if defined(ZMQ_CLIENT)
458 				else if(!strcmp("CLIENT", stringType)) {
459 					pData-&gt;sockType = ZMQ_CLIENT;
460 					DBGPRINTF("omczmq: sockType set to ZMQ_CLIENT\n");
461 				}
462 #endif
463 				free(stringType);
464 			}
465 			else{
466 				LogError(0, RS_RET_OUT_OF_MEMORY,
467 						"omczmq: out of memory");
468 				ABORT_FINALIZE(RS_RET_OUT_OF_MEMORY);
469 			}
470 		}
471 		else if(!strcmp(actpblk.descr[i].name, "topicframe")) {
472 			pData-&gt;topicFrame = pvals[i].val.d.n;
473 			DBGPRINTF("omczmq: topicFrame set to %s\n", pData-&gt;topicFrame ? "true" : "false");
474 		}
475 		else if(!strcmp(actpblk.descr[i].name, "topics")) {
476 			pData-&gt;topics = zlist_new();
477 			char *topics = es_str2cstr(pvals[i].val.d.estr, NULL);
478 			DBGPRINTF("omczmq: topics set to %s\n", topics);
479 			char *topics_org = topics;
480 			char topic[256];
481 			if(topics == NULL){
482 				LogError(0, RS_RET_OUT_OF_MEMORY,
483 					"out of memory");
484 				ABORT_FINALIZE(RS_RET_OUT_OF_MEMORY);
485 			}
486 			while(*topics) {
487 				char *delimiter = strchr(topics, ',');
488 				if (!delimiter) {
489 					delimiter = topics + strlen(topics);
490 				}
491 				memcpy (topic, topics, delimiter - topics);
492 				topic[delimiter-topics] = 0;
493 				char *current_topic = strdup(topic);
494 				zlist_append (pData-&gt;topics, current_topic);
495 				if(*delimiter == 0) {
496 					break;
497 				}
498 				topics = delimiter + 1;
499 			}
500 			free(topics_org);
501 		}
502 		else {
503 			LogError(0, NO_ERRCODE,
504 					"omczmq: config error - '%s' is not a valid option",
505 					actpblk.descr[i].name);
506 			ABORT_FINALIZE(RS_RET_CONFIG_ERROR);
507 		}
508 	}
509 	iNumTpls = 1;
510 	if (pData-&gt;dynaTopic) {
511 		iNumTpls = zlist_size (pData-&gt;topics) + iNumTpls;
512 	}
513 	CODE_STD_STRING_REQUESTnewActInst(iNumTpls)
514 	if (pData-&gt;tplName == NULL) {
515 		CHKiRet(OMSRsetEntry(*ppOMSR, 0, (uchar*)strdup("RSYSLOG_ForwardFormat"),
516 					OMSR_NO_RQD_TPL_OPTS));
517 	}
518 	else {
519 		CHKiRet(OMSRsetEntry(*ppOMSR, 0, (uchar*)pData-&gt;tplName, OMSR_NO_RQD_TPL_OPTS));
520 	}
521 	i = 1;
522 	if (pData-&gt;dynaTopic) {
523 		char *topic = zlist_first(pData-&gt;topics);
524 		while (topic) {
525 			CHKiRet(OMSRsetEntry(*ppOMSR, i, (uchar*)strdup(topic), OMSR_NO_RQD_TPL_OPTS));
526 			i++;
527 			topic = zlist_next(pData-&gt;topics);
528 		}
529 	}
530 	CODE_STD_FINALIZERnewActInst
531 	cnfparamvalsDestruct(pvals, &amp;actpblk);
532 ENDnewActInst
533 BEGINinitConfVars
534 CODESTARTinitConfVars
535 ENDinitConfVars
536 NO_LEGACY_CONF_parseSelectorAct
537 BEGINmodExit
538 CODESTARTmodExit
539 ENDmodExit
540 BEGINqueryEtryPt
541 CODESTARTqueryEtryPt
542 	CODEqueryEtryPt_STD_OMOD_QUERIES
543 	CODEqueryEtryPt_STD_CONF2_OMOD_QUERIES
544 	CODEqueryEtryPt_STD_CONF2_QUERIES
545 	CODEqueryEtryPt_STD_CONF2_setModCnf_QUERIES
546 	CODEqueryEtryPt_STD_OMOD8_QUERIES
547 ENDqueryEtryPt
548 BEGINmodInit()
549 CODESTARTmodInit
550 	*ipIFVersProvided = CURR_MOD_IF_VERSION;
551 CODEmodInit_QueryRegCFSLineHdlr
552 	INITChkCoreFeature(bCoreSupportsBatching, CORE_FEATURE_BATCHING);
553 	DBGPRINTF("omczmq: module compiled with rsyslog version %s.\n", VERSION);
554 	INITLegCnfVars
555 ENDmodInit
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
