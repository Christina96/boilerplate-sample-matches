<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML><HEAD><TITLE>Matches for mmexternal.c & omczmq.c</TITLE>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
</HEAD>
<body>
  <div style="align-items: center; display: flex; justify-content: space-around;">
    <div>
      <h3 align="center">
Matches for mmexternal.c & omczmq.c
      </h3>
      <h1 align="center">
        4.6%
      </h1>
      <center>
        <a href="index.html" target="_top">
          INDEX
        </a>
        <span>-</span>
        <a href="help-en.html" target="_top">
          HELP
        </a>
      </center>
    </div>
    <div>
<TABLE BORDER="1" CELLSPACING="0" BGCOLOR="#d0d0d0">
<TR><TH><TH>mmexternal.c (5.159705%)<TH>omczmq.c (4.242424%)<TH>Tokens
<TR><TD BGCOLOR="#0000ff"><FONT COLOR="#0000ff">-</FONT><TD><A HREF="javascript:ZweiFrames('match2422-0.html#0',2,'match2422-1.html#0',3)" NAME="0">(89-99)<TD><A HREF="javascript:ZweiFrames('match2422-0.html#0',2,'match2422-1.html#0',3)" NAME="0">(48-59)</A><TD ALIGN=center><FONT COLOR="#ff0000">21</FONT>
</TABLE>
    </div>
  </div>
  <hr>
  <div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>mmexternal.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
/* mmexternal.c
 * This core plugin is an interface module to message modification
 * modules written in languages other than C.
 *
 * Copyright 2014-2018 by Rainer Gerhards
 *
 * This file is part of rsyslog.
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *       -or-
 *       see COPYING.ASL20 in the source distribution
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#include &quot;config.h&quot;
#include &lt;stdio.h&gt;
#include &lt;stdarg.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;assert.h&gt;
#include &lt;signal.h&gt;
#include &lt;errno.h&gt;
#include &lt;unistd.h&gt;
#include &lt;fcntl.h&gt;
#include &lt;sys/wait.h&gt;
#include &lt;sys/uio.h&gt;
#include &quot;rsyslog.h&quot;
#include &quot;conf.h&quot;
#include &quot;syslogd-types.h&quot;
#include &quot;srUtils.h&quot;
#include &quot;module-template.h&quot;
#include &quot;msg.h&quot;
#include &quot;errmsg.h&quot;
#include &quot;cfsysline.h&quot;
#include &quot;glbl.h&quot;
#include &quot;rsconf.h&quot;


MODULE_TYPE_OUTPUT
MODULE_TYPE_NOKEEP
MODULE_CNFNAME(&quot;mmexternal&quot;)

/* internal structures
 */
DEF_OMOD_STATIC_DATA

typedef struct _instanceData {
	uchar *szBinary;	/* name of binary to call */
	char **aParams;		/* Optional Parameters for binary command */
	int iParams;		/* Holds the count of parameters if set*/
	int bForceSingleInst;	/* only a single wrkr instance of program permitted? */
	int inputProp;		/* what to provide as input to the external program? */
#define	INPUT_MSG 0
#define	INPUT_RAWMSG 1
#define INPUT_JSON 2
	uchar *outputFileName;	/* name of file for std[out/err] or NULL if to discard */
	pthread_mutex_t mut;	/* make sure only one instance is active */
} instanceData;

typedef struct wrkrInstanceData {
	instanceData *pData;
	pid_t pid;		/* pid of currently running process */
	int fdOutput;		/* it's fd (-1 if closed) */
	int fdPipeOut;		/* file descriptor to write to */
	int fdPipeIn;		/* fd we receive messages from the program (if we want to) */
	int bIsRunning;		/* is binary currently running? 0-no, 1-yes */
	char *respBuf;		/* buffer to read exernal plugin's response */
	int maxLenRespBuf;	/* (current) maximum length of response buffer */
	int lenRespBuf;		/* actual nbr of chars in response buffer */
	int idxRespBuf;		/* last char read from response buffer */
} wrkrInstanceData_t;

typedef struct configSettings_s {
	uchar *szBinary;	/* name of binary to call */
} configSettings_t;
static configSettings_t cs;

<A NAME="0"></A>
/* tables for interfacing with the v6 config system */
/* action (instance) parameters */
<FONT color="#0000ff"><A HREF="javascript:ZweiFrames('match2422-1.html#0',3,'match2422-top.html#0',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>static struct cnfparamdescr actpdescr[] = {
	{ &quot;binary&quot;, eCmdHdlrString, CNFPARAM_REQUIRED },
	{ &quot;interface.input&quot;, eCmdHdlrString, 0 },
	{ &quot;output&quot;, eCmdHdlrString, 0 },
	{ &quot;forcesingleinstance&quot;, eCmdHdlrBinary, 0 }
};
static struct cnfparamblk actpblk =
	{ CNFPARAMBLK_VERSION,
	  sizeof(actpdescr)/sizeof(struct cnfparamdescr),
	  actpdescr
	};</B></FONT>

BEGINinitConfVars		/* (re)set config variables to default values */
CODESTARTinitConfVars
	cs.szBinary = NULL;	/* name of binary to call */
ENDinitConfVars

/* config settings */

BEGINcreateInstance
CODESTARTcreateInstance
	pData-&gt;inputProp = INPUT_MSG;
	pthread_mutex_init(&amp;pData-&gt;mut, NULL);
ENDcreateInstance

BEGINcreateWrkrInstance
CODESTARTcreateWrkrInstance
	pWrkrData-&gt;fdPipeIn = -1;
	pWrkrData-&gt;fdPipeOut = -1;
	pWrkrData-&gt;fdOutput = -1;
	pWrkrData-&gt;bIsRunning = 0;
	pWrkrData-&gt;respBuf = NULL;
	pWrkrData-&gt;maxLenRespBuf = 0;
	pWrkrData-&gt;lenRespBuf = 0;
	pWrkrData-&gt;idxRespBuf = 0;
ENDcreateWrkrInstance


BEGINisCompatibleWithFeature
CODESTARTisCompatibleWithFeature
	if(eFeat == sFEATURERepeatedMsgReduction)
		iRet = RS_RET_OK;
ENDisCompatibleWithFeature


BEGINfreeInstance
	int i;
CODESTARTfreeInstance
	pthread_mutex_destroy(&amp;pData-&gt;mut);
	free(pData-&gt;szBinary);
	free(pData-&gt;outputFileName);
	if(pData-&gt;aParams != NULL) {
		for (i = 0; i &lt; pData-&gt;iParams; i++) {
			free(pData-&gt;aParams[i]);
		}
		free(pData-&gt;aParams);
	}
ENDfreeInstance

BEGINfreeWrkrInstance
CODESTARTfreeWrkrInstance
	free(pWrkrData-&gt;respBuf);
ENDfreeWrkrInstance


BEGINdbgPrintInstInfo
CODESTARTdbgPrintInstInfo
ENDdbgPrintInstInfo


BEGINtryResume
CODESTARTtryResume
ENDtryResume


/* As this is just a debug function, we only make
 * best effort to write the message but do *not* try very
 * hard to handle errors. -- rgerhards, 2014-01-16
 */
static void
writeOutputDebug(wrkrInstanceData_t *__restrict__ const pWrkrData,
	const char *__restrict__ const buf,
	const ssize_t lenBuf)
{
	char errStr[1024];
	ssize_t r;

	if(pWrkrData-&gt;pData-&gt;outputFileName == NULL)
		goto done;

	if(pWrkrData-&gt;fdOutput == -1) {
		pWrkrData-&gt;fdOutput = open((char*)pWrkrData-&gt;pData-&gt;outputFileName,
				       O_WRONLY | O_APPEND | O_CREAT, 0600);
		if(pWrkrData-&gt;fdOutput == -1) {
			DBGPRINTF(&quot;mmexternal: error opening output file %s: %s\n&quot;,
				   pWrkrData-&gt;pData-&gt;outputFileName,
				   rs_strerror_r(errno, errStr, sizeof(errStr)));
			goto done;
		}
	}

	r = write(pWrkrData-&gt;fdOutput, buf, (size_t) lenBuf);
	if(r != lenBuf) {
		DBGPRINTF(&quot;mmexternal: problem writing output file %s: bytes &quot;
			  &quot;requested %lld, written %lld, msg: %s\n&quot;,
			   pWrkrData-&gt;pData-&gt;outputFileName, (long long) lenBuf, (long long) r,
			   rs_strerror_r(errno, errStr, sizeof(errStr)));
	}
done:	return;
}


/* Get reply from external program. Note that we *must* receive one
 * reply for each message sent (half-duplex protocol). As such, the last
 * char we read MUST be \n ... we cannot have multiple LF as this is
 * forbidden by the plugin interface. We cannot have multiple responses
 * for multiple messages, as we are in half-duplex mode! This makes
 * things quite a bit simpler. So don't think the simple code does
 * not handle those border-cases that are describe to cannot exist!
 */
static void
processProgramReply(wrkrInstanceData_t *__restrict__ const pWrkrData, smsg_t *const pMsg)
{
	rsRetVal iRet;
	char errStr[1024];
	ssize_t r;
	int numCharsRead;
	char *newptr;

	numCharsRead = 0;
	do {
		if(pWrkrData-&gt;maxLenRespBuf &lt; numCharsRead + 256) { /* 256 to permit at least a decent read */
			pWrkrData-&gt;maxLenRespBuf += 4096;
			if((newptr = realloc(pWrkrData-&gt;respBuf, pWrkrData-&gt;maxLenRespBuf)) == NULL) {
				DBGPRINTF(&quot;mmexternal: error realloc responseBuf: %s\n&quot;,
					   rs_strerror_r(errno, errStr, sizeof(errStr)));
				/* emergency - fake no update */
				strcpy(pWrkrData-&gt;respBuf, &quot;{}\n&quot;);
				numCharsRead = 3;
				break;
			}
			pWrkrData-&gt;respBuf = newptr;
		}
		r = read(pWrkrData-&gt;fdPipeIn, pWrkrData-&gt;respBuf+numCharsRead,
			 pWrkrData-&gt;maxLenRespBuf-numCharsRead-1);
		if(r &gt; 0) {
			numCharsRead += r;
			pWrkrData-&gt;respBuf[numCharsRead] = '\0'; /* space reserved in read! */
		} else {
			/* emergency - fake no update */
			strcpy(pWrkrData-&gt;respBuf, &quot;{}\n&quot;);
			numCharsRead = 3;
		}
		if(Debug &amp;&amp; r == -1) {
			DBGPRINTF(&quot;mmexternal: error reading from external program: %s\n&quot;,
				   rs_strerror_r(errno, errStr, sizeof(errStr)));
		}
	} while(pWrkrData-&gt;respBuf[numCharsRead-1] != '\n');

	writeOutputDebug(pWrkrData, pWrkrData-&gt;respBuf, numCharsRead);
	/* strip LF, which is not part of the JSON message but framing */
	pWrkrData-&gt;respBuf[numCharsRead-1] = '\0';
	iRet = MsgSetPropsViaJSON(pMsg, (uchar*)pWrkrData-&gt;respBuf);
	if(iRet != RS_RET_OK) {
		LogError(0, iRet, &quot;mmexternal: invalid reply '%s' from program '%s'&quot;,
				pWrkrData-&gt;respBuf, pWrkrData-&gt;pData-&gt;szBinary);
	}

	return;
}



/* execute the child process (must be called in child context
 * after fork).
 * Note: all output will go to std[err/out] of the **child**, so
 * rsyslog will never see it except as script output. Do NOT
 * use dbgprintf() or LogError() and friends.
 */
static void __attribute__((noreturn))
execBinary(wrkrInstanceData_t *pWrkrData, const int fdStdin, const int fdStdOutErr)
{
	int i;
	struct sigaction sigAct;
	sigset_t set;
	char *newenviron[] = { NULL };

	if(dup2(fdStdin, STDIN_FILENO) == -1) {
		perror(&quot;mmexternal: dup() stdin failed\n&quot;);
	}
	if(dup2(fdStdOutErr, STDOUT_FILENO) == -1) {
		perror(&quot;mmexternal: dup() stdout failed\n&quot;);
	}
	if(dup2(fdStdOutErr, STDERR_FILENO) == -1) {
		perror(&quot;mmexternal: dup() stderr failed\n&quot;);
	}

	/* we close all file handles as we fork soon
	 * Is there a better way to do this? - mail me! rgerhards@adiscon.com
	 */
#	ifndef VALGRIND /* we can not use this with valgrind - too many errors... */
	for(i = 3 ; i &lt;= 65535 ; ++i)
		close(i);
#	endif

	/* reset signal handlers to default */
	memset(&amp;sigAct, 0, sizeof(sigAct));
	sigemptyset(&amp;sigAct.sa_mask);
	sigAct.sa_handler = SIG_DFL;
	for(i = 1 ; i &lt; NSIG ; ++i)
		sigaction(i, &amp;sigAct, NULL);
	/* we need to block SIGINT, otherwise the external program is cancelled when we are
	 * stopped in debug mode.
	 */
	sigAct.sa_handler = SIG_IGN;
	sigaction(SIGINT, &amp;sigAct, NULL);
	sigemptyset(&amp;set);
	sigprocmask(SIG_SETMASK, &amp;set, NULL);

	alarm(0);

	/* finally exec child */
	execve((char*)pWrkrData-&gt;pData-&gt;szBinary, pWrkrData-&gt;pData-&gt;aParams, newenviron);

	/* we should never reach this point, but if we do, we complain and terminate */
	char errstr[1024];
	char errbuf[2048];
	rs_strerror_r(errno, errstr, sizeof(errstr));
	errstr[sizeof(errstr)-1] = '\0';
	const size_t lenbuf = snprintf(errbuf, sizeof(errbuf),
		&quot;mmexternal: failed to execute binary '%s': %s\n&quot;,
		  pWrkrData-&gt;pData-&gt;szBinary, errstr);
	errbuf[sizeof(errbuf)-1] = '\0';
	if(write(2, errbuf, lenbuf) != (ssize_t) lenbuf) {
		/* just keep static analyzers happy... */
		exit(2);
	}
	exit(1);
}


/* creates a pipe and starts program, uses pipe as stdin for program.
 * rgerhards, 2009-04-01
 */
static rsRetVal
openPipe(wrkrInstanceData_t *pWrkrData)
{
	int pipestdin[2];
	int pipestdout[2];
	pid_t cpid;
	DEFiRet;

	if(pipe(pipestdin) == -1) {
		ABORT_FINALIZE(RS_RET_ERR_CREAT_PIPE);
	}
	if(pipe(pipestdout) == -1) {
		ABORT_FINALIZE(RS_RET_ERR_CREAT_PIPE);
	}

	DBGPRINTF(&quot;mmexternal: executing program '%s' with '%d' parameters\n&quot;,
		  pWrkrData-&gt;pData-&gt;szBinary, pWrkrData-&gt;pData-&gt;iParams);

	/* final sanity check */
	assert(pWrkrData-&gt;pData-&gt;szBinary != NULL);
	assert(pWrkrData-&gt;pData-&gt;aParams != NULL);

	/* NO OUTPUT AFTER FORK! */
	cpid = fork();
	if(cpid == -1) {
		ABORT_FINALIZE(RS_RET_ERR_FORK);
	}
	pWrkrData-&gt;pid = cpid;

	if(cpid == 0) {
		/* we are now the child, just exec the binary. */
		close(pipestdin[1]); /* close those pipe &quot;ports&quot; that */
		close(pipestdout[0]); /* we don't need */
		execBinary(pWrkrData, pipestdin[0], pipestdout[1]);
		/*NO CODE HERE - WILL NEVER BE REACHED!*/
	}

	DBGPRINTF(&quot;mmexternal: child has pid %d\n&quot;, (int) cpid);
	pWrkrData-&gt;fdPipeIn = dup(pipestdout[0]);
	close(pipestdin[0]);
	close(pipestdout[1]);
	pWrkrData-&gt;pid = cpid;
	pWrkrData-&gt;fdPipeOut = pipestdin[1];
	pWrkrData-&gt;bIsRunning = 1;
finalize_it:
	RETiRet;
}


/* clean up after a terminated child
 */
static rsRetVal
cleanup(wrkrInstanceData_t *pWrkrData)
{
	int status;
	int ret;
	DEFiRet;

	assert(pWrkrData-&gt;bIsRunning == 1);
	ret = waitpid(pWrkrData-&gt;pid, &amp;status, 0);

	/* waitpid will fail with errno == ECHILD if the child process has already
	   been reaped by the rsyslogd main loop (see rsyslogd.c) */
	if(ret == pWrkrData-&gt;pid) {
		glblReportChildProcessExit(runConf, pWrkrData-&gt;pData-&gt;szBinary, pWrkrData-&gt;pid, status);
	}

	if(pWrkrData-&gt;fdOutput != -1) {
		close(pWrkrData-&gt;fdOutput);
		pWrkrData-&gt;fdOutput = -1;
	}
	if(pWrkrData-&gt;fdPipeIn != -1) {
		close(pWrkrData-&gt;fdPipeIn);
		pWrkrData-&gt;fdPipeIn = -1;
	}
	if(pWrkrData-&gt;fdPipeOut != -1) {
		close(pWrkrData-&gt;fdPipeOut);
		pWrkrData-&gt;fdPipeOut = -1;
	}
	pWrkrData-&gt;bIsRunning = 0;
	pWrkrData-&gt;bIsRunning = 0;
	RETiRet;
}


/* try to restart the binary when it has stopped.
 */
static rsRetVal
tryRestart(wrkrInstanceData_t *pWrkrData)
{
	DEFiRet;
	assert(pWrkrData-&gt;bIsRunning == 0);

	iRet = openPipe(pWrkrData);
	RETiRet;
}

/* write to pipe
 * note that we do not try to run block-free. If the users fears something
 * may block (and this not be acceptable), the action should be run on its
 * own action queue.
 */
static rsRetVal
callExtProg(wrkrInstanceData_t *__restrict__ const pWrkrData, smsg_t *__restrict__ const pMsg)
{
	int lenWritten;
	int lenWrite;
	int writeOffset;
	int i_iov;
	struct iovec iov[2];
	int bFreeInputstr = 1; /* we must only free if it does not point to msg-obj mem! */
	const uchar *inputstr = NULL; /* string to be processed by external program */
	DEFiRet;

	if(pWrkrData-&gt;pData-&gt;inputProp == INPUT_MSG) {
		inputstr = getMSG(pMsg);
		lenWrite = getMSGLen(pMsg);
		bFreeInputstr = 0;
	} else if(pWrkrData-&gt;pData-&gt;inputProp == INPUT_RAWMSG) {
		getRawMsg(pMsg, (uchar**)&amp;inputstr, &amp;lenWrite);
		bFreeInputstr = 0;
	} else  {
		inputstr = msgGetJSONMESG(pMsg);
		lenWrite = strlen((const char*)inputstr);
	}

	writeOffset = 0;
	do {
		DBGPRINTF(&quot;mmexternal: writing to prog (fd %d, offset %d): %s\n&quot;,
			  pWrkrData-&gt;fdPipeOut, (int) writeOffset, inputstr);
		i_iov = 0;
		if(writeOffset &lt; lenWrite) {
			iov[0].iov_base = (char*)inputstr+writeOffset;
			iov[0].iov_len = lenWrite - writeOffset;
			++i_iov;
		}
		iov[i_iov].iov_base = (void*)&quot;\n&quot;;
		iov[i_iov].iov_len = 1;
		lenWritten = writev(pWrkrData-&gt;fdPipeOut, iov, i_iov+1);
		if(lenWritten == -1) {
			switch(errno) {
			case EPIPE:
				LogMsg(0, RS_RET_ERR_WRITE_PIPE, LOG_WARNING,
						&quot;mmexternal: program '%s' (pid %ld) terminated; will be restarted&quot;,
						pWrkrData-&gt;pData-&gt;szBinary, (long) pWrkrData-&gt;pid);
				CHKiRet(cleanup(pWrkrData));
				CHKiRet(tryRestart(pWrkrData));
				writeOffset = 0;
				break;
			default:
				LogError(errno, RS_RET_ERR_WRITE_PIPE, &quot;mmexternal: error sending message to program&quot;);
				ABORT_FINALIZE(RS_RET_ERR_WRITE_PIPE);
				break;
			}
		} else {
			writeOffset += lenWritten;
		}
	} while(lenWritten != lenWrite+1);

	processProgramReply(pWrkrData, pMsg);

finalize_it:
	/* we need to free json input strings, only. All others point to memory
	 * inside the msg object, which is destroyed when the msg is destroyed.
	 */
	if(bFreeInputstr) {
		free((void*)inputstr);
	}
	RETiRet;
}


BEGINdoAction_NoStrings
	smsg_t **ppMsg = (smsg_t **) pMsgData;
	smsg_t *pMsg = ppMsg[0];
	instanceData *pData;
CODESTARTdoAction
	pData = pWrkrData-&gt;pData;
	if(pData-&gt;bForceSingleInst)
		pthread_mutex_lock(&amp;pData-&gt;mut);
	if(pWrkrData-&gt;bIsRunning == 0) {
		openPipe(pWrkrData);
	}

	iRet = callExtProg(pWrkrData, pMsg);

	if(iRet != RS_RET_OK)
		iRet = RS_RET_SUSPENDED;
	if(pData-&gt;bForceSingleInst)
		pthread_mutex_unlock(&amp;pData-&gt;mut);
ENDdoAction


static void
setInstParamDefaults(instanceData *pData)
{
	pData-&gt;szBinary = NULL;
	pData-&gt;aParams = NULL;
	pData-&gt;outputFileName = NULL;
	pData-&gt;iParams = 0;
	pData-&gt;bForceSingleInst = 0;
}


BEGINnewActInst
	struct cnfparamvals *pvals;
	int i;
	const char *cstr = NULL;
CODESTARTnewActInst
	if((pvals = nvlstGetParams(lst, &amp;actpblk, NULL)) == NULL) {
		ABORT_FINALIZE(RS_RET_MISSING_CNFPARAMS);
	}

	CHKiRet(createInstance(&amp;pData));
	setInstParamDefaults(pData);

	CODE_STD_STRING_REQUESTnewActInst(1)
	for(i = 0 ; i &lt; actpblk.nParams ; ++i) {
		if(!pvals[i].bUsed)
			continue;
		if(!strcmp(actpblk.descr[i].name, &quot;binary&quot;)) {
			CHKiRet(split_binary_parameters(&amp;pData-&gt;szBinary, &amp;pData-&gt;aParams, &amp;pData-&gt;iParams,
				pvals[i].val.d.estr));
		} else if(!strcmp(actpblk.descr[i].name, &quot;output&quot;)) {
			pData-&gt;outputFileName = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
		} else if(!strcmp(actpblk.descr[i].name, &quot;forcesingleinstance&quot;)) {
			pData-&gt;bForceSingleInst = (int) pvals[i].val.d.n;
		} else if(!strcmp(actpblk.descr[i].name, &quot;interface.input&quot;)) {
			cstr = es_str2cstr(pvals[i].val.d.estr, NULL);
			if(!strcmp(cstr, &quot;msg&quot;))
				pData-&gt;inputProp = INPUT_MSG;
			else if(!strcmp(cstr, &quot;rawmsg&quot;))
				pData-&gt;inputProp = INPUT_RAWMSG;
			else if(!strcmp(cstr, &quot;fulljson&quot;))
				pData-&gt;inputProp = INPUT_JSON;
			else {
				LogError(0, RS_RET_INVLD_INTERFACE_INPUT,
					&quot;mmexternal: invalid interface.input parameter '%s'&quot;,
					cstr);
				ABORT_FINALIZE(RS_RET_INVLD_INTERFACE_INPUT);
			}
		} else {
			DBGPRINTF(&quot;mmexternal: program error, non-handled param '%s'\n&quot;, actpblk.descr[i].name);
		}
	}

	CHKiRet(OMSRsetEntry(*ppOMSR, 0, NULL, OMSR_TPL_AS_MSG));
	DBGPRINTF(&quot;mmexternal: bForceSingleInst %d\n&quot;, pData-&gt;bForceSingleInst);
	DBGPRINTF(&quot;mmexternal: interface.input '%s', mode %d\n&quot;, cstr, pData-&gt;inputProp);
CODE_STD_FINALIZERnewActInst
	free((void*)cstr);
	cnfparamvalsDestruct(pvals, &amp;actpblk);
ENDnewActInst

NO_LEGACY_CONF_parseSelectorAct


BEGINmodExit
CODESTARTmodExit
	free(cs.szBinary);
	cs.szBinary = NULL;
ENDmodExit


BEGINqueryEtryPt
CODESTARTqueryEtryPt
CODEqueryEtryPt_STD_OMOD_QUERIES
CODEqueryEtryPt_STD_OMOD8_QUERIES
CODEqueryEtryPt_STD_CONF2_CNFNAME_QUERIES
CODEqueryEtryPt_STD_CONF2_OMOD_QUERIES
ENDqueryEtryPt

BEGINmodInit()
CODESTARTmodInit
INITLegCnfVars
	*ipIFVersProvided = CURR_MOD_IF_VERSION; /* we only support the current interface specification */
CODEmodInit_QueryRegCFSLineHdlr
CODEmodInit_QueryRegCFSLineHdlr
ENDmodInit
</PRE>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>omczmq.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
/* omczmq.c
 * Copyright (C) 2016 Brian Knox
 * Copyright (C) 2014 Rainer Gerhards
 *
 * Author: Brian Knox &lt;bknox@digitalocean.com&gt;
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


#include &quot;config.h&quot;
#include &quot;rsyslog.h&quot;
#include &lt;stdio.h&gt;
#include &lt;stdarg.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;assert.h&gt;
#include &lt;signal.h&gt;
#include &lt;errno.h&gt;
#include &lt;unistd.h&gt;
#include &quot;conf.h&quot;
#include &quot;syslogd-types.h&quot;
#include &quot;srUtils.h&quot;
#include &quot;template.h&quot;
#include &quot;module-template.h&quot;
#include &quot;errmsg.h&quot;
#include &quot;cfsysline.h&quot;
#include &lt;czmq.h&gt;

MODULE_TYPE_OUTPUT
MODULE_TYPE_NOKEEP
MODULE_CNFNAME(&quot;omczmq&quot;)

DEF_OMOD_STATIC_DATA
<A NAME="0"></A>
static pthread_mutex_t mutDoAct = PTHREAD_MUTEX_INITIALIZER;

<FONT color="#0000ff"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match2422-0.html#0',2,'match2422-top.html#0',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>static struct cnfparamdescr modpdescr[] = {
	{ &quot;authenticator&quot;, eCmdHdlrBinary, 0 },
	{ &quot;authtype&quot;, eCmdHdlrGetWord, 0 },
	{ &quot;clientcertpath&quot;, eCmdHdlrGetWord, 0 },
	{ &quot;servercertpath&quot;, eCmdHdlrGetWord, 0 }
};

static struct cnfparamblk modpblk = {
	CNFPARAMBLK_VERSION,
	sizeof(modpdescr)/sizeof(struct cnfparamdescr),
	modpdescr
};</B></FONT>

struct modConfData_s {
	rsconf_t *pConf;
	uchar *tplName;
	int authenticator;
	char *authType;
	char *serverCertPath;
	char *clientCertPath;
};

static modConfData_t *runModConf = NULL;
static zactor_t *authActor;

typedef struct _instanceData {
	zsock_t *sock;
	bool serverish;
	int sendTimeout;
	zlist_t *topics;
	bool sendError;
	char *sockEndpoints;
	int sockType;
	int sendHWM;
#if(CZMQ_VERSION_MAJOR &gt;= 4 &amp;&amp; ZMQ_VERSION_MAJOR &gt;=4 &amp;&amp; ZMQ_VERSION_MINOR &gt;=2)
	int heartbeatIvl;
	int heartbeatTimeout;
	int heartbeatTTL;
	int connectTimeout;
#endif
	uchar *tplName;
	sbool topicFrame;
	sbool dynaTopic;
} instanceData;

typedef struct wrkrInstanceData {
	instanceData *pData;
} wrkrInstanceData_t;

static struct cnfparamdescr actpdescr[] = {
	{ &quot;endpoints&quot;, eCmdHdlrGetWord, 1 },
	{ &quot;socktype&quot;, eCmdHdlrGetWord, 1 },
	{ &quot;sendhwm&quot;, eCmdHdlrGetWord, 0 },
#if(CZMQ_VERSION_MAJOR &gt;= 4 &amp;&amp; ZMQ_VERSION_MAJOR &gt;=4 &amp;&amp; ZMQ_VERSION_MINOR &gt;=2)
	{ &quot;heartbeatttl&quot;, eCmdHdlrGetWord, 0},
	{ &quot;heartbeativl&quot;, eCmdHdlrGetWord, 0},
	{ &quot;heartbeattimeout&quot;, eCmdHdlrGetWord, 0},
	{ &quot;connecttimeout&quot;, eCmdHdlrGetWord, 0},
#endif
	{ &quot;sendtimeout&quot;, eCmdHdlrGetWord, 0 },
	{ &quot;template&quot;, eCmdHdlrGetWord, 0 },
	{ &quot;topics&quot;, eCmdHdlrGetWord, 0 },
	{ &quot;topicframe&quot;, eCmdHdlrGetWord, 0},
	{ &quot;dynatopic&quot;, eCmdHdlrBinary, 0 }
};

static struct cnfparamblk actpblk = {
	CNFPARAMBLK_VERSION,
	sizeof(actpdescr) / sizeof(struct cnfparamdescr),
	actpdescr
};

static rsRetVal initCZMQ(instanceData* pData) {
	DEFiRet;
	int rc;
	putenv((char*)&quot;ZSYS_SIGHANDLER=false&quot;);
	pData-&gt;sock = zsock_new(pData-&gt;sockType);
	if(!pData-&gt;sock) {
		LogError(0, RS_RET_NO_ERRCODE,
				&quot;omczmq: new socket failed for endpoints: %s&quot;,
				pData-&gt;sockEndpoints);
		ABORT_FINALIZE(RS_RET_SUSPENDED);
	}

	zsock_set_sndtimeo(pData-&gt;sock, pData-&gt;sendTimeout);

#if(CZMQ_VERSION_MAJOR &gt;= 4 &amp;&amp; ZMQ_VERSION_MAJOR &gt;=4 &amp;&amp; ZMQ_VERSION_MINOR &gt;=2)
	if(pData-&gt;heartbeatIvl &gt; 0 &amp;&amp; pData-&gt;heartbeatTimeout &gt; 0 &amp;&amp; pData-&gt;heartbeatTTL &gt; 0) {
		zsock_set_heartbeat_ivl(pData-&gt;sock, pData-&gt;heartbeatIvl);
		zsock_set_heartbeat_timeout(pData-&gt;sock, pData-&gt;heartbeatTimeout);
		zsock_set_heartbeat_ttl(pData-&gt;sock, pData-&gt;heartbeatTTL);
	}
#endif

	if(runModConf-&gt;authType) {
		if (!strcmp(runModConf-&gt;authType, &quot;CURVESERVER&quot;)) {
			zcert_t *serverCert = zcert_load(runModConf-&gt;serverCertPath);
			if(!serverCert) {
				LogError(0, NO_ERRCODE, &quot;could not load cert %s&quot;,
					runModConf-&gt;serverCertPath);
				ABORT_FINALIZE(RS_RET_ERR);
			}
			zsock_set_zap_domain(pData-&gt;sock, &quot;global&quot;);
			zsock_set_curve_server(pData-&gt;sock, 1);
			zcert_apply(serverCert, pData-&gt;sock);
			zcert_destroy(&amp;serverCert);
		}
		else if(!strcmp(runModConf-&gt;authType, &quot;CURVECLIENT&quot;)) {
			zcert_t *serverCert = zcert_load(runModConf-&gt;serverCertPath);
			if(!serverCert) {
				LogError(0, NO_ERRCODE, &quot;could not load cert %s&quot;,
					runModConf-&gt;serverCertPath);
				ABORT_FINALIZE(RS_RET_ERR);
			}
			const char *server_key = zcert_public_txt(serverCert);
			zcert_destroy(&amp;serverCert);
			zsock_set_curve_serverkey(pData-&gt;sock, server_key);

			zcert_t *clientCert = zcert_load(runModConf-&gt;clientCertPath);
			if(!clientCert) {
				LogError(0, NO_ERRCODE, &quot;could not load cert %s&quot;,
					runModConf-&gt;clientCertPath);
				ABORT_FINALIZE(RS_RET_ERR);
			}

			zcert_apply(clientCert, pData-&gt;sock);
			zcert_destroy(&amp;clientCert);
		}
	}

	switch(pData-&gt;sockType) {
		case ZMQ_PUB:
#if defined(ZMQ_RADIO)
		case ZMQ_RADIO:
#endif
			pData-&gt;serverish = true;
			break;
		case ZMQ_PUSH:
#if defined(ZMQ_SCATTER)
		case ZMQ_SCATTER:
#endif
		case ZMQ_DEALER:
#if defined(ZMQ_CLIENT)
		case ZMQ_CLIENT:
#endif
			pData-&gt;serverish = false;
			break;
	}

	rc = zsock_attach(pData-&gt;sock, pData-&gt;sockEndpoints, pData-&gt;serverish);
	if(rc == -1) {
		LogError(0, NO_ERRCODE, &quot;zsock_attach to %s failed&quot;,
				pData-&gt;sockEndpoints);
		ABORT_FINALIZE(RS_RET_SUSPENDED);
	}

finalize_it:
	RETiRet;
}

static rsRetVal outputCZMQ(uchar** ppString, instanceData* pData) {
	DEFiRet;

	if(NULL == pData-&gt;sock) {
		CHKiRet(initCZMQ(pData));
	}

	/* if we are using a PUB (or RADIO) socket and we have a topic list then we
	 * need some special care and attention */
#if defined(ZMQ_RADIO)
	DBGPRINTF(&quot;omczmq: ZMQ_RADIO is defined...\n&quot;);
	if((pData-&gt;sockType == ZMQ_PUB || pData-&gt;sockType == ZMQ_RADIO) &amp;&amp; pData-&gt;topics) {
#else
	DBGPRINTF(&quot;omczmq: ZMQ_RADIO is NOT defined...\n&quot;);
	if(pData-&gt;sockType == ZMQ_PUB &amp;&amp; pData-&gt;topics) {
#endif
		int templateIndex = 1;
		const char *topic = (const char *)zlist_first(pData-&gt;topics);
		while(topic) {
			int rc;
			/* if dynaTopic is true, the topic is constructed by rsyslog
			 * by applying the supplied template to the message properties */
			if(pData-&gt;dynaTopic)
				topic = (const char*)ppString[templateIndex];

			if (pData-&gt;sockType == ZMQ_PUB) {
				/* if topicFrame is true, send the topic as a separate zmq frame */
				if(pData-&gt;topicFrame) {
					rc = zstr_sendx(pData-&gt;sock, topic, (char*)ppString[0], NULL);
				}

				/* if topicFrame is false, concatenate the topic with the
				 * message in the same frame */
				else {
					rc = zstr_sendf(pData-&gt;sock, &quot;%s%s&quot;, topic, (char*)ppString[0]);
				}

				/* if we have a send error notify rsyslog */
				if(rc != 0) {
					pData-&gt;sendError = true;
					ABORT_FINALIZE(RS_RET_SUSPENDED);
				}
			}
#if defined(ZMQ_RADIO)
			else if(pData-&gt;sockType == ZMQ_RADIO) {
				DBGPRINTF(&quot;omczmq: sending on RADIO socket...\n&quot;);
				zframe_t *frame = zframe_from((char*)ppString[0]);
				if (!frame) {
					DBGPRINTF(&quot;omczmq: failed to create frame...\n&quot;);
					pData-&gt;sendError = true;
					ABORT_FINALIZE(RS_RET_SUSPENDED);
				}
				rc = zframe_set_group(frame, topic);
				if (rc != 0) {
					DBGPRINTF(&quot;omczmq: failed to set group '%d'...\n&quot;, rc);
					pData-&gt;sendError = true;
					ABORT_FINALIZE(RS_RET_SUSPENDED);
				}
				DBGPRINTF(&quot;omczmq: set RADIO group to '%s'\n&quot;, topic);
				rc = zframe_send(&amp;frame, pData-&gt;sock, 0);
				if(rc != 0) {
					pData-&gt;sendError = true;
					ABORT_FINALIZE(RS_RET_SUSPENDED);
				}
			}
#endif

			/* get the next topic from the list, and increment
			 * our topic index */
			topic = zlist_next(pData-&gt;topics);
			templateIndex++;
		}
	}

	/* we aren't a PUB socket and we don't have a topic list - this means
	 * we can just send the message using the rsyslog template */
	else {
		int rc = zstr_send(pData-&gt;sock, (char*)ppString[0]);
		if(rc != 0) {
			pData-&gt;sendError = true;
			DBGPRINTF(&quot;omczmq: send error: %d&quot;, rc);
			ABORT_FINALIZE(RS_RET_SUSPENDED);
		}
	}
finalize_it:
	RETiRet;
}

static inline void
setInstParamDefaults(instanceData* pData) {
	pData-&gt;sockEndpoints = NULL;
	pData-&gt;sock = NULL;
	pData-&gt;sendError = false;
	pData-&gt;serverish = false;
	pData-&gt;tplName = NULL;
	pData-&gt;sockType = -1;
	pData-&gt;sendTimeout = -1;
	pData-&gt;topics = NULL;
	pData-&gt;topicFrame = false;
#if(CZMQ_VERSION_MAJOR &gt;= 4 &amp;&amp; ZMQ_VERSION_MAJOR &gt;=4 &amp;&amp; ZMQ_VERSION_MINOR &gt;=2)
	pData-&gt;heartbeatIvl = 0;
	pData-&gt;heartbeatTimeout = 0;
	pData-&gt;heartbeatTTL = 0;
#endif
}


BEGINcreateInstance
CODESTARTcreateInstance
ENDcreateInstance

BEGINcreateWrkrInstance
CODESTARTcreateWrkrInstance
ENDcreateWrkrInstance

BEGINisCompatibleWithFeature
CODESTARTisCompatibleWithFeature
	if(eFeat == sFEATURERepeatedMsgReduction) {
		iRet = RS_RET_OK;
	}
ENDisCompatibleWithFeature
BEGINdbgPrintInstInfo
CODESTARTdbgPrintInstInfo
ENDdbgPrintInstInfo

BEGINfreeInstance
CODESTARTfreeInstance
	zlist_destroy(&amp;pData-&gt;topics);
	zsock_destroy(&amp;pData-&gt;sock);
	free(pData-&gt;sockEndpoints);
	free(pData-&gt;tplName);
ENDfreeInstance


BEGINfreeWrkrInstance
CODESTARTfreeWrkrInstance
ENDfreeWrkrInstance

BEGINtryResume
	instanceData *pData;
CODESTARTtryResume
	pthread_mutex_lock(&amp;mutDoAct);
	pData = pWrkrData-&gt;pData;
	DBGPRINTF(&quot;omczmq: trying to resume...\n&quot;);
	zsock_destroy(&amp;pData-&gt;sock);
	iRet = initCZMQ(pData);
	pthread_mutex_unlock(&amp;mutDoAct);
ENDtryResume

BEGINbeginCnfLoad
CODESTARTbeginCnfLoad
	runModConf = pModConf;
	runModConf-&gt;pConf = pConf;
	runModConf-&gt;authenticator = 0;
	runModConf-&gt;authType = NULL;
	runModConf-&gt;serverCertPath = NULL;
	runModConf-&gt;clientCertPath = NULL;
ENDbeginCnfLoad

BEGINcheckCnf
CODESTARTcheckCnf
ENDcheckCnf

BEGINactivateCnf
CODESTARTactivateCnf
	runModConf = pModConf;
	if(runModConf-&gt;authenticator == 1) {
		if(!authActor) {
			DBGPRINTF(&quot;omczmq: starting authActor\n&quot;);
			authActor = zactor_new(zauth, NULL);
			if(!strcmp(runModConf-&gt;clientCertPath, &quot;*&quot;)) {
				zstr_sendx(authActor, &quot;CURVE&quot;, CURVE_ALLOW_ANY, NULL);
			}
			else {
				zstr_sendx(authActor, &quot;CURVE&quot;, runModConf-&gt;clientCertPath, NULL);
			}
			zsock_wait(authActor);
		}
	}
ENDactivateCnf

BEGINfreeCnf
CODESTARTfreeCnf
	free(pModConf-&gt;tplName);
	free(pModConf-&gt;authType);
	free(pModConf-&gt;serverCertPath);
	free(pModConf-&gt;clientCertPath);
	DBGPRINTF(&quot;omczmq: stopping authActor\n&quot;);
	zactor_destroy(&amp;authActor);
ENDfreeCnf

BEGINsetModCnf
	struct cnfparamvals *pvals = NULL;
	int i;
CODESTARTsetModCnf
	pvals = nvlstGetParams(lst, &amp;modpblk, NULL);
	if (pvals == NULL) {
		LogError(0, RS_RET_MISSING_CNFPARAMS, &quot;error processing module&quot;);
		ABORT_FINALIZE(RS_RET_MISSING_CNFPARAMS);
	}

	for (i=0; i&lt;modpblk.nParams; ++i) {
		if(!pvals[i].bUsed) {
			DBGPRINTF(&quot;omczmq: pvals[i].bUSed continuing\n&quot;);
			continue;
		}
		if(!strcmp(modpblk.descr[i].name, &quot;authenticator&quot;)) {
			runModConf-&gt;authenticator = (int)pvals[i].val.d.n;
		}
		else if(!strcmp(modpblk.descr[i].name, &quot;authtype&quot;)) {
			runModConf-&gt;authType = es_str2cstr(pvals[i].val.d.estr, NULL);
			DBGPRINTF(&quot;omczmq: authtype set to %s\n&quot;, runModConf-&gt;authType);
		}
		else if(!strcmp(modpblk.descr[i].name, &quot;servercertpath&quot;)) {
			runModConf-&gt;serverCertPath = es_str2cstr(pvals[i].val.d.estr, NULL);
			DBGPRINTF(&quot;omczmq: serverCertPath set to %s\n&quot;, runModConf-&gt;serverCertPath);
		}
		else if(!strcmp(modpblk.descr[i].name, &quot;clientcertpath&quot;)) {
			runModConf-&gt;clientCertPath = es_str2cstr(pvals[i].val.d.estr, NULL);
			DBGPRINTF(&quot;omczmq: clientCertPath set to %s\n&quot;, runModConf-&gt;clientCertPath);
		}
		else {
			LogError(0, RS_RET_INVALID_PARAMS,
						&quot;omczmq: config error, unknown &quot;
						&quot;param %s in setModCnf\n&quot;,
						modpblk.descr[i].name);
		}
	}

	DBGPRINTF(&quot;omczmq: authenticator set to %d\n&quot;, runModConf-&gt;authenticator);
	DBGPRINTF(&quot;omczmq: authType set to %s\n&quot;, runModConf-&gt;authType);
	DBGPRINTF(&quot;omczmq: serverCertPath set to %s\n&quot;, runModConf-&gt;serverCertPath);
	DBGPRINTF(&quot;omczmq: clientCertPath set to %s\n&quot;, runModConf-&gt;clientCertPath);

finalize_it:
		if(pvals != NULL)
			cnfparamvalsDestruct(pvals, &amp;modpblk);
ENDsetModCnf

BEGINendCnfLoad
CODESTARTendCnfLoad
	runModConf = NULL;
ENDendCnfLoad


BEGINdoAction
	instanceData *pData;
CODESTARTdoAction
	pthread_mutex_lock(&amp;mutDoAct);
	pData = pWrkrData-&gt;pData;
	iRet = outputCZMQ(ppString, pData);
	pthread_mutex_unlock(&amp;mutDoAct);
ENDdoAction


BEGINnewActInst
	struct cnfparamvals *pvals;
	int i;
	int iNumTpls;
CODESTARTnewActInst
	if ((pvals = nvlstGetParams(lst, &amp;actpblk, NULL)) == NULL) {
		ABORT_FINALIZE(RS_RET_MISSING_CNFPARAMS);
	}

	CHKiRet(createInstance(&amp;pData));
	setInstParamDefaults(pData);

	for(i = 0; i &lt; actpblk.nParams; ++i) {
		if(!pvals[i].bUsed) {
			continue;
		}

		if(!strcmp(actpblk.descr[i].name, &quot;endpoints&quot;)) {
			pData-&gt;sockEndpoints = es_str2cstr(pvals[i].val.d.estr, NULL);
			DBGPRINTF(&quot;omczmq: sockEndPoints set to '%s'\n&quot;, pData-&gt;sockEndpoints);
		}
		else if(!strcmp(actpblk.descr[i].name, &quot;template&quot;)) {
			pData-&gt;tplName = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
			DBGPRINTF(&quot;omczmq: template set to '%s'\n&quot;, pData-&gt;tplName);
		}
		else if(!strcmp(actpblk.descr[i].name, &quot;dynatopic&quot;)) {
			pData-&gt;dynaTopic = pvals[i].val.d.n;
			DBGPRINTF(&quot;omczmq: dynaTopic set to %s\n&quot;, pData-&gt;dynaTopic ? &quot;true&quot; : &quot;false&quot;);
		}
		else if(!strcmp(actpblk.descr[i].name, &quot;sendtimeout&quot;)) {
			pData-&gt;sendTimeout = atoi(es_str2cstr(pvals[i].val.d.estr, NULL));
			DBGPRINTF(&quot;omczmq: sendTimeout set to %d\n&quot;, pData-&gt;sendTimeout);
		}
		else if(!strcmp(actpblk.descr[i].name, &quot;sendhwm&quot;)) {
			pData-&gt;sendTimeout = atoi(es_str2cstr(pvals[i].val.d.estr, NULL));
			DBGPRINTF(&quot;omczmq: sendHWM set to %d\n&quot;, pData-&gt;sendHWM);
		}
#if (CZMQ_VERSION_MAJOR &gt;= 4 &amp;&amp; ZMQ_VERSION_MAJOR &gt;=4 &amp;&amp; ZMQ_VERSION_MINOR &gt;=2)
		else if(!strcmp(actpblk.descr[i].name, &quot;heartbeativl&quot;)) {
			pData-&gt;heartbeatIvl = atoi(es_str2cstr(pvals[i].val.d.estr, NULL));
			DBGPRINTF(&quot;omczmq: heartbeatbeatIvl set to %d\n&quot;, pData-&gt;heartbeatIvl);
		}
		else if(!strcmp(actpblk.descr[i].name, &quot;heartbeattimeout&quot;)) {
			pData-&gt;heartbeatTimeout = atoi(es_str2cstr(pvals[i].val.d.estr, NULL));
			DBGPRINTF(&quot;omczmq: heartbeatTimeout set to %d\n&quot;, pData-&gt;heartbeatTimeout);
		}
		else if(!strcmp(actpblk.descr[i].name, &quot;heartbeatttl&quot;)) {
			pData-&gt;heartbeatTimeout = atoi(es_str2cstr(pvals[i].val.d.estr, NULL));
			DBGPRINTF(&quot;omczmq: heartbeatTTL set to %d\n&quot;, pData-&gt;heartbeatTTL);
		}
#endif
		else if(!strcmp(actpblk.descr[i].name, &quot;socktype&quot;)){
			char *stringType = es_str2cstr(pvals[i].val.d.estr, NULL);
			if(stringType != NULL){
				if(!strcmp(&quot;PUB&quot;, stringType)) {
					pData-&gt;sockType = ZMQ_PUB;
					DBGPRINTF(&quot;omczmq: sockType set to ZMQ_PUB\n&quot;);
				}
#if defined(ZMQ_RADIO)
				else if(!strcmp(&quot;RADIO&quot;, stringType)) {
					pData-&gt;sockType = ZMQ_RADIO;
					DBGPRINTF(&quot;omczmq: sockType set to ZMQ_RADIO\n&quot;);
				}
#endif
				else if(!strcmp(&quot;PUSH&quot;, stringType)) {
					pData-&gt;sockType = ZMQ_PUSH;
					DBGPRINTF(&quot;omczmq: sockType set to ZMQ_PUSH\n&quot;);
				}
#if defined(ZMQ_SCATTER)
				else if(!strcmp(&quot;SCATTER&quot;, stringType)) {
					pData-&gt;sockType = ZMQ_SCATTER;
					DBGPRINTF(&quot;omczmq: sockType set to ZMQ_SCATTER\n&quot;);
				}
#endif
				else if(!strcmp(&quot;DEALER&quot;, stringType)) {
					pData-&gt;sockType = ZMQ_DEALER;
					DBGPRINTF(&quot;omczmq: sockType set to ZMQ_DEALER\n&quot;);
				}
#if defined(ZMQ_CLIENT)
				else if(!strcmp(&quot;CLIENT&quot;, stringType)) {
					pData-&gt;sockType = ZMQ_CLIENT;
					DBGPRINTF(&quot;omczmq: sockType set to ZMQ_CLIENT\n&quot;);
				}
#endif
				free(stringType);
			}
			else{
				LogError(0, RS_RET_OUT_OF_MEMORY,
						&quot;omczmq: out of memory&quot;);
				ABORT_FINALIZE(RS_RET_OUT_OF_MEMORY);
			}
		}
		else if(!strcmp(actpblk.descr[i].name, &quot;topicframe&quot;)) {
			pData-&gt;topicFrame = pvals[i].val.d.n;
			DBGPRINTF(&quot;omczmq: topicFrame set to %s\n&quot;, pData-&gt;topicFrame ? &quot;true&quot; : &quot;false&quot;);
		}
		else if(!strcmp(actpblk.descr[i].name, &quot;topics&quot;)) {
			pData-&gt;topics = zlist_new();
			char *topics = es_str2cstr(pvals[i].val.d.estr, NULL);
			DBGPRINTF(&quot;omczmq: topics set to %s\n&quot;, topics);
			char *topics_org = topics;
			char topic[256];
			if(topics == NULL){
				LogError(0, RS_RET_OUT_OF_MEMORY,
					&quot;out of memory&quot;);
				ABORT_FINALIZE(RS_RET_OUT_OF_MEMORY);
			}

			while(*topics) {
				char *delimiter = strchr(topics, ',');
				if (!delimiter) {
					delimiter = topics + strlen(topics);
				}
				memcpy (topic, topics, delimiter - topics);
				topic[delimiter-topics] = 0;
				char *current_topic = strdup(topic);
				zlist_append (pData-&gt;topics, current_topic);
				if(*delimiter == 0) {
					break;
				}
				topics = delimiter + 1;
			}
			free(topics_org);

		}
		else {
			LogError(0, NO_ERRCODE,
					&quot;omczmq: config error - '%s' is not a valid option&quot;,
					actpblk.descr[i].name);
			ABORT_FINALIZE(RS_RET_CONFIG_ERROR);
		}
	}

	iNumTpls = 1;
	if (pData-&gt;dynaTopic) {
		iNumTpls = zlist_size (pData-&gt;topics) + iNumTpls;
	}
	CODE_STD_STRING_REQUESTnewActInst(iNumTpls)
	
	if (pData-&gt;tplName == NULL) {
		CHKiRet(OMSRsetEntry(*ppOMSR, 0, (uchar*)strdup(&quot;RSYSLOG_ForwardFormat&quot;),
					OMSR_NO_RQD_TPL_OPTS));
	}
	else {
		CHKiRet(OMSRsetEntry(*ppOMSR, 0, (uchar*)pData-&gt;tplName, OMSR_NO_RQD_TPL_OPTS));
	}

	i = 1;
	if (pData-&gt;dynaTopic) {
		char *topic = zlist_first(pData-&gt;topics);
		while (topic) {
			CHKiRet(OMSRsetEntry(*ppOMSR, i, (uchar*)strdup(topic), OMSR_NO_RQD_TPL_OPTS));
			i++;
			topic = zlist_next(pData-&gt;topics);
		}
	}

	CODE_STD_FINALIZERnewActInst
	cnfparamvalsDestruct(pvals, &amp;actpblk);
ENDnewActInst

BEGINinitConfVars
CODESTARTinitConfVars
ENDinitConfVars

NO_LEGACY_CONF_parseSelectorAct

BEGINmodExit
CODESTARTmodExit
ENDmodExit

BEGINqueryEtryPt
CODESTARTqueryEtryPt
	CODEqueryEtryPt_STD_OMOD_QUERIES
	CODEqueryEtryPt_STD_CONF2_OMOD_QUERIES
	CODEqueryEtryPt_STD_CONF2_QUERIES
	CODEqueryEtryPt_STD_CONF2_setModCnf_QUERIES
	CODEqueryEtryPt_STD_OMOD8_QUERIES
ENDqueryEtryPt


BEGINmodInit()
CODESTARTmodInit
	*ipIFVersProvided = CURR_MOD_IF_VERSION;
CODEmodInit_QueryRegCFSLineHdlr
	INITChkCoreFeature(bCoreSupportsBatching, CORE_FEATURE_BATCHING);
	DBGPRINTF(&quot;omczmq: module compiled with rsyslog version %s.\n&quot;, VERSION);

	INITLegCnfVars
ENDmodInit
</PRE>
</div>
  </div>
</body>
</html>
