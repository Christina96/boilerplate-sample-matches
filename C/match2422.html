<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html><head><title>Matches for mmexternal.c &amp; omczmq.c</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for mmexternal.c &amp; omczmq.c
      </h3>
<h1 align="center">
        4.6%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>mmexternal.c (5.159705%)<th>omczmq.c (4.242424%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(89-99)<td><a href="#" name="0">(48-59)</a><td align="center"><font color="#ff0000">21</font>
</td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>mmexternal.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
/* mmexternal.c
 * This core plugin is an interface module to message modification
 * modules written in languages other than C.
 *
 * Copyright 2014-2018 by Rainer Gerhards
 *
 * This file is part of rsyslog.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *       -or-
 *       see COPYING.ASL20 in the source distribution
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#include "config.h"
#include &lt;stdio.h&gt;
#include &lt;stdarg.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;assert.h&gt;
#include &lt;signal.h&gt;
#include &lt;errno.h&gt;
#include &lt;unistd.h&gt;
#include &lt;fcntl.h&gt;
#include &lt;sys/wait.h&gt;
#include &lt;sys/uio.h&gt;
#include "rsyslog.h"
#include "conf.h"
#include "syslogd-types.h"
#include "srUtils.h"
#include "module-template.h"
#include "msg.h"
#include "errmsg.h"
#include "cfsysline.h"
#include "glbl.h"
#include "rsconf.h"


MODULE_TYPE_OUTPUT
MODULE_TYPE_NOKEEP
MODULE_CNFNAME("mmexternal")

/* internal structures
 */
DEF_OMOD_STATIC_DATA

typedef struct _instanceData {
	uchar *szBinary;	/* name of binary to call */
	char **aParams;		/* Optional Parameters for binary command */
	int iParams;		/* Holds the count of parameters if set*/
	int bForceSingleInst;	/* only a single wrkr instance of program permitted? */
	int inputProp;		/* what to provide as input to the external program? */
#define	INPUT_MSG 0
#define	INPUT_RAWMSG 1
#define INPUT_JSON 2
	uchar *outputFileName;	/* name of file for std[out/err] or NULL if to discard */
	pthread_mutex_t mut;	/* make sure only one instance is active */
} instanceData;

typedef struct wrkrInstanceData {
	instanceData *pData;
	pid_t pid;		/* pid of currently running process */
	int fdOutput;		/* it's fd (-1 if closed) */
	int fdPipeOut;		/* file descriptor to write to */
	int fdPipeIn;		/* fd we receive messages from the program (if we want to) */
	int bIsRunning;		/* is binary currently running? 0-no, 1-yes */
	char *respBuf;		/* buffer to read exernal plugin's response */
	int maxLenRespBuf;	/* (current) maximum length of response buffer */
	int lenRespBuf;		/* actual nbr of chars in response buffer */
	int idxRespBuf;		/* last char read from response buffer */
} wrkrInstanceData_t;

typedef struct configSettings_s {
	uchar *szBinary;	/* name of binary to call */
} configSettings_t;
static configSettings_t cs;

<a name="0"></a>
/* tables for interfacing with the v6 config system */
/* action (instance) parameters */
<font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>static struct cnfparamdescr actpdescr[] = {
	{ "binary", eCmdHdlrString, CNFPARAM_REQUIRED },
	{ "interface.input", eCmdHdlrString, 0 },
	{ "output", eCmdHdlrString, 0 },
	{ "forcesingleinstance", eCmdHdlrBinary, 0 }
};
static struct cnfparamblk actpblk =
	{ CNFPARAMBLK_VERSION,
	  sizeof(actpdescr)/sizeof(struct cnfparamdescr),
	  actpdescr
	};</b></font>

BEGINinitConfVars		/* (re)set config variables to default values */
CODESTARTinitConfVars
	cs.szBinary = NULL;	/* name of binary to call */
ENDinitConfVars

/* config settings */

BEGINcreateInstance
CODESTARTcreateInstance
	pData-&gt;inputProp = INPUT_MSG;
	pthread_mutex_init(&amp;pData-&gt;mut, NULL);
ENDcreateInstance

BEGINcreateWrkrInstance
CODESTARTcreateWrkrInstance
	pWrkrData-&gt;fdPipeIn = -1;
	pWrkrData-&gt;fdPipeOut = -1;
	pWrkrData-&gt;fdOutput = -1;
	pWrkrData-&gt;bIsRunning = 0;
	pWrkrData-&gt;respBuf = NULL;
	pWrkrData-&gt;maxLenRespBuf = 0;
	pWrkrData-&gt;lenRespBuf = 0;
	pWrkrData-&gt;idxRespBuf = 0;
ENDcreateWrkrInstance


BEGINisCompatibleWithFeature
CODESTARTisCompatibleWithFeature
	if(eFeat == sFEATURERepeatedMsgReduction)
		iRet = RS_RET_OK;
ENDisCompatibleWithFeature


BEGINfreeInstance
	int i;
CODESTARTfreeInstance
	pthread_mutex_destroy(&amp;pData-&gt;mut);
	free(pData-&gt;szBinary);
	free(pData-&gt;outputFileName);
	if(pData-&gt;aParams != NULL) {
		for (i = 0; i &lt; pData-&gt;iParams; i++) {
			free(pData-&gt;aParams[i]);
		}
		free(pData-&gt;aParams);
	}
ENDfreeInstance

BEGINfreeWrkrInstance
CODESTARTfreeWrkrInstance
	free(pWrkrData-&gt;respBuf);
ENDfreeWrkrInstance


BEGINdbgPrintInstInfo
CODESTARTdbgPrintInstInfo
ENDdbgPrintInstInfo


BEGINtryResume
CODESTARTtryResume
ENDtryResume


/* As this is just a debug function, we only make
 * best effort to write the message but do *not* try very
 * hard to handle errors. -- rgerhards, 2014-01-16
 */
static void
writeOutputDebug(wrkrInstanceData_t *__restrict__ const pWrkrData,
	const char *__restrict__ const buf,
	const ssize_t lenBuf)
{
	char errStr[1024];
	ssize_t r;

	if(pWrkrData-&gt;pData-&gt;outputFileName == NULL)
		goto done;

	if(pWrkrData-&gt;fdOutput == -1) {
		pWrkrData-&gt;fdOutput = open((char*)pWrkrData-&gt;pData-&gt;outputFileName,
				       O_WRONLY | O_APPEND | O_CREAT, 0600);
		if(pWrkrData-&gt;fdOutput == -1) {
			DBGPRINTF("mmexternal: error opening output file %s: %s\n",
				   pWrkrData-&gt;pData-&gt;outputFileName,
				   rs_strerror_r(errno, errStr, sizeof(errStr)));
			goto done;
		}
	}

	r = write(pWrkrData-&gt;fdOutput, buf, (size_t) lenBuf);
	if(r != lenBuf) {
		DBGPRINTF("mmexternal: problem writing output file %s: bytes "
			  "requested %lld, written %lld, msg: %s\n",
			   pWrkrData-&gt;pData-&gt;outputFileName, (long long) lenBuf, (long long) r,
			   rs_strerror_r(errno, errStr, sizeof(errStr)));
	}
done:	return;
}


/* Get reply from external program. Note that we *must* receive one
 * reply for each message sent (half-duplex protocol). As such, the last
 * char we read MUST be \n ... we cannot have multiple LF as this is
 * forbidden by the plugin interface. We cannot have multiple responses
 * for multiple messages, as we are in half-duplex mode! This makes
 * things quite a bit simpler. So don't think the simple code does
 * not handle those border-cases that are describe to cannot exist!
 */
static void
processProgramReply(wrkrInstanceData_t *__restrict__ const pWrkrData, smsg_t *const pMsg)
{
	rsRetVal iRet;
	char errStr[1024];
	ssize_t r;
	int numCharsRead;
	char *newptr;

	numCharsRead = 0;
	do {
		if(pWrkrData-&gt;maxLenRespBuf &lt; numCharsRead + 256) { /* 256 to permit at least a decent read */
			pWrkrData-&gt;maxLenRespBuf += 4096;
			if((newptr = realloc(pWrkrData-&gt;respBuf, pWrkrData-&gt;maxLenRespBuf)) == NULL) {
				DBGPRINTF("mmexternal: error realloc responseBuf: %s\n",
					   rs_strerror_r(errno, errStr, sizeof(errStr)));
				/* emergency - fake no update */
				strcpy(pWrkrData-&gt;respBuf, "{}\n");
				numCharsRead = 3;
				break;
			}
			pWrkrData-&gt;respBuf = newptr;
		}
		r = read(pWrkrData-&gt;fdPipeIn, pWrkrData-&gt;respBuf+numCharsRead,
			 pWrkrData-&gt;maxLenRespBuf-numCharsRead-1);
		if(r &gt; 0) {
			numCharsRead += r;
			pWrkrData-&gt;respBuf[numCharsRead] = '\0'; /* space reserved in read! */
		} else {
			/* emergency - fake no update */
			strcpy(pWrkrData-&gt;respBuf, "{}\n");
			numCharsRead = 3;
		}
		if(Debug &amp;&amp; r == -1) {
			DBGPRINTF("mmexternal: error reading from external program: %s\n",
				   rs_strerror_r(errno, errStr, sizeof(errStr)));
		}
	} while(pWrkrData-&gt;respBuf[numCharsRead-1] != '\n');

	writeOutputDebug(pWrkrData, pWrkrData-&gt;respBuf, numCharsRead);
	/* strip LF, which is not part of the JSON message but framing */
	pWrkrData-&gt;respBuf[numCharsRead-1] = '\0';
	iRet = MsgSetPropsViaJSON(pMsg, (uchar*)pWrkrData-&gt;respBuf);
	if(iRet != RS_RET_OK) {
		LogError(0, iRet, "mmexternal: invalid reply '%s' from program '%s'",
				pWrkrData-&gt;respBuf, pWrkrData-&gt;pData-&gt;szBinary);
	}

	return;
}



/* execute the child process (must be called in child context
 * after fork).
 * Note: all output will go to std[err/out] of the **child**, so
 * rsyslog will never see it except as script output. Do NOT
 * use dbgprintf() or LogError() and friends.
 */
static void __attribute__((noreturn))
execBinary(wrkrInstanceData_t *pWrkrData, const int fdStdin, const int fdStdOutErr)
{
	int i;
	struct sigaction sigAct;
	sigset_t set;
	char *newenviron[] = { NULL };

	if(dup2(fdStdin, STDIN_FILENO) == -1) {
		perror("mmexternal: dup() stdin failed\n");
	}
	if(dup2(fdStdOutErr, STDOUT_FILENO) == -1) {
		perror("mmexternal: dup() stdout failed\n");
	}
	if(dup2(fdStdOutErr, STDERR_FILENO) == -1) {
		perror("mmexternal: dup() stderr failed\n");
	}

	/* we close all file handles as we fork soon
	 * Is there a better way to do this? - mail me! rgerhards@adiscon.com
	 */
#	ifndef VALGRIND /* we can not use this with valgrind - too many errors... */
	for(i = 3 ; i &lt;= 65535 ; ++i)
		close(i);
#	endif

	/* reset signal handlers to default */
	memset(&amp;sigAct, 0, sizeof(sigAct));
	sigemptyset(&amp;sigAct.sa_mask);
	sigAct.sa_handler = SIG_DFL;
	for(i = 1 ; i &lt; NSIG ; ++i)
		sigaction(i, &amp;sigAct, NULL);
	/* we need to block SIGINT, otherwise the external program is cancelled when we are
	 * stopped in debug mode.
	 */
	sigAct.sa_handler = SIG_IGN;
	sigaction(SIGINT, &amp;sigAct, NULL);
	sigemptyset(&amp;set);
	sigprocmask(SIG_SETMASK, &amp;set, NULL);

	alarm(0);

	/* finally exec child */
	execve((char*)pWrkrData-&gt;pData-&gt;szBinary, pWrkrData-&gt;pData-&gt;aParams, newenviron);

	/* we should never reach this point, but if we do, we complain and terminate */
	char errstr[1024];
	char errbuf[2048];
	rs_strerror_r(errno, errstr, sizeof(errstr));
	errstr[sizeof(errstr)-1] = '\0';
	const size_t lenbuf = snprintf(errbuf, sizeof(errbuf),
		"mmexternal: failed to execute binary '%s': %s\n",
		  pWrkrData-&gt;pData-&gt;szBinary, errstr);
	errbuf[sizeof(errbuf)-1] = '\0';
	if(write(2, errbuf, lenbuf) != (ssize_t) lenbuf) {
		/* just keep static analyzers happy... */
		exit(2);
	}
	exit(1);
}


/* creates a pipe and starts program, uses pipe as stdin for program.
 * rgerhards, 2009-04-01
 */
static rsRetVal
openPipe(wrkrInstanceData_t *pWrkrData)
{
	int pipestdin[2];
	int pipestdout[2];
	pid_t cpid;
	DEFiRet;

	if(pipe(pipestdin) == -1) {
		ABORT_FINALIZE(RS_RET_ERR_CREAT_PIPE);
	}
	if(pipe(pipestdout) == -1) {
		ABORT_FINALIZE(RS_RET_ERR_CREAT_PIPE);
	}

	DBGPRINTF("mmexternal: executing program '%s' with '%d' parameters\n",
		  pWrkrData-&gt;pData-&gt;szBinary, pWrkrData-&gt;pData-&gt;iParams);

	/* final sanity check */
	assert(pWrkrData-&gt;pData-&gt;szBinary != NULL);
	assert(pWrkrData-&gt;pData-&gt;aParams != NULL);

	/* NO OUTPUT AFTER FORK! */
	cpid = fork();
	if(cpid == -1) {
		ABORT_FINALIZE(RS_RET_ERR_FORK);
	}
	pWrkrData-&gt;pid = cpid;

	if(cpid == 0) {
		/* we are now the child, just exec the binary. */
		close(pipestdin[1]); /* close those pipe "ports" that */
		close(pipestdout[0]); /* we don't need */
		execBinary(pWrkrData, pipestdin[0], pipestdout[1]);
		/*NO CODE HERE - WILL NEVER BE REACHED!*/
	}

	DBGPRINTF("mmexternal: child has pid %d\n", (int) cpid);
	pWrkrData-&gt;fdPipeIn = dup(pipestdout[0]);
	close(pipestdin[0]);
	close(pipestdout[1]);
	pWrkrData-&gt;pid = cpid;
	pWrkrData-&gt;fdPipeOut = pipestdin[1];
	pWrkrData-&gt;bIsRunning = 1;
finalize_it:
	RETiRet;
}


/* clean up after a terminated child
 */
static rsRetVal
cleanup(wrkrInstanceData_t *pWrkrData)
{
	int status;
	int ret;
	DEFiRet;

	assert(pWrkrData-&gt;bIsRunning == 1);
	ret = waitpid(pWrkrData-&gt;pid, &amp;status, 0);

	/* waitpid will fail with errno == ECHILD if the child process has already
	   been reaped by the rsyslogd main loop (see rsyslogd.c) */
	if(ret == pWrkrData-&gt;pid) {
		glblReportChildProcessExit(runConf, pWrkrData-&gt;pData-&gt;szBinary, pWrkrData-&gt;pid, status);
	}

	if(pWrkrData-&gt;fdOutput != -1) {
		close(pWrkrData-&gt;fdOutput);
		pWrkrData-&gt;fdOutput = -1;
	}
	if(pWrkrData-&gt;fdPipeIn != -1) {
		close(pWrkrData-&gt;fdPipeIn);
		pWrkrData-&gt;fdPipeIn = -1;
	}
	if(pWrkrData-&gt;fdPipeOut != -1) {
		close(pWrkrData-&gt;fdPipeOut);
		pWrkrData-&gt;fdPipeOut = -1;
	}
	pWrkrData-&gt;bIsRunning = 0;
	pWrkrData-&gt;bIsRunning = 0;
	RETiRet;
}


/* try to restart the binary when it has stopped.
 */
static rsRetVal
tryRestart(wrkrInstanceData_t *pWrkrData)
{
	DEFiRet;
	assert(pWrkrData-&gt;bIsRunning == 0);

	iRet = openPipe(pWrkrData);
	RETiRet;
}

/* write to pipe
 * note that we do not try to run block-free. If the users fears something
 * may block (and this not be acceptable), the action should be run on its
 * own action queue.
 */
static rsRetVal
callExtProg(wrkrInstanceData_t *__restrict__ const pWrkrData, smsg_t *__restrict__ const pMsg)
{
	int lenWritten;
	int lenWrite;
	int writeOffset;
	int i_iov;
	struct iovec iov[2];
	int bFreeInputstr = 1; /* we must only free if it does not point to msg-obj mem! */
	const uchar *inputstr = NULL; /* string to be processed by external program */
	DEFiRet;

	if(pWrkrData-&gt;pData-&gt;inputProp == INPUT_MSG) {
		inputstr = getMSG(pMsg);
		lenWrite = getMSGLen(pMsg);
		bFreeInputstr = 0;
	} else if(pWrkrData-&gt;pData-&gt;inputProp == INPUT_RAWMSG) {
		getRawMsg(pMsg, (uchar**)&amp;inputstr, &amp;lenWrite);
		bFreeInputstr = 0;
	} else  {
		inputstr = msgGetJSONMESG(pMsg);
		lenWrite = strlen((const char*)inputstr);
	}

	writeOffset = 0;
	do {
		DBGPRINTF("mmexternal: writing to prog (fd %d, offset %d): %s\n",
			  pWrkrData-&gt;fdPipeOut, (int) writeOffset, inputstr);
		i_iov = 0;
		if(writeOffset &lt; lenWrite) {
			iov[0].iov_base = (char*)inputstr+writeOffset;
			iov[0].iov_len = lenWrite - writeOffset;
			++i_iov;
		}
		iov[i_iov].iov_base = (void*)"\n";
		iov[i_iov].iov_len = 1;
		lenWritten = writev(pWrkrData-&gt;fdPipeOut, iov, i_iov+1);
		if(lenWritten == -1) {
			switch(errno) {
			case EPIPE:
				LogMsg(0, RS_RET_ERR_WRITE_PIPE, LOG_WARNING,
						"mmexternal: program '%s' (pid %ld) terminated; will be restarted",
						pWrkrData-&gt;pData-&gt;szBinary, (long) pWrkrData-&gt;pid);
				CHKiRet(cleanup(pWrkrData));
				CHKiRet(tryRestart(pWrkrData));
				writeOffset = 0;
				break;
			default:
				LogError(errno, RS_RET_ERR_WRITE_PIPE, "mmexternal: error sending message to program");
				ABORT_FINALIZE(RS_RET_ERR_WRITE_PIPE);
				break;
			}
		} else {
			writeOffset += lenWritten;
		}
	} while(lenWritten != lenWrite+1);

	processProgramReply(pWrkrData, pMsg);

finalize_it:
	/* we need to free json input strings, only. All others point to memory
	 * inside the msg object, which is destroyed when the msg is destroyed.
	 */
	if(bFreeInputstr) {
		free((void*)inputstr);
	}
	RETiRet;
}


BEGINdoAction_NoStrings
	smsg_t **ppMsg = (smsg_t **) pMsgData;
	smsg_t *pMsg = ppMsg[0];
	instanceData *pData;
CODESTARTdoAction
	pData = pWrkrData-&gt;pData;
	if(pData-&gt;bForceSingleInst)
		pthread_mutex_lock(&amp;pData-&gt;mut);
	if(pWrkrData-&gt;bIsRunning == 0) {
		openPipe(pWrkrData);
	}

	iRet = callExtProg(pWrkrData, pMsg);

	if(iRet != RS_RET_OK)
		iRet = RS_RET_SUSPENDED;
	if(pData-&gt;bForceSingleInst)
		pthread_mutex_unlock(&amp;pData-&gt;mut);
ENDdoAction


static void
setInstParamDefaults(instanceData *pData)
{
	pData-&gt;szBinary = NULL;
	pData-&gt;aParams = NULL;
	pData-&gt;outputFileName = NULL;
	pData-&gt;iParams = 0;
	pData-&gt;bForceSingleInst = 0;
}


BEGINnewActInst
	struct cnfparamvals *pvals;
	int i;
	const char *cstr = NULL;
CODESTARTnewActInst
	if((pvals = nvlstGetParams(lst, &amp;actpblk, NULL)) == NULL) {
		ABORT_FINALIZE(RS_RET_MISSING_CNFPARAMS);
	}

	CHKiRet(createInstance(&amp;pData));
	setInstParamDefaults(pData);

	CODE_STD_STRING_REQUESTnewActInst(1)
	for(i = 0 ; i &lt; actpblk.nParams ; ++i) {
		if(!pvals[i].bUsed)
			continue;
		if(!strcmp(actpblk.descr[i].name, "binary")) {
			CHKiRet(split_binary_parameters(&amp;pData-&gt;szBinary, &amp;pData-&gt;aParams, &amp;pData-&gt;iParams,
				pvals[i].val.d.estr));
		} else if(!strcmp(actpblk.descr[i].name, "output")) {
			pData-&gt;outputFileName = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
		} else if(!strcmp(actpblk.descr[i].name, "forcesingleinstance")) {
			pData-&gt;bForceSingleInst = (int) pvals[i].val.d.n;
		} else if(!strcmp(actpblk.descr[i].name, "interface.input")) {
			cstr = es_str2cstr(pvals[i].val.d.estr, NULL);
			if(!strcmp(cstr, "msg"))
				pData-&gt;inputProp = INPUT_MSG;
			else if(!strcmp(cstr, "rawmsg"))
				pData-&gt;inputProp = INPUT_RAWMSG;
			else if(!strcmp(cstr, "fulljson"))
				pData-&gt;inputProp = INPUT_JSON;
			else {
				LogError(0, RS_RET_INVLD_INTERFACE_INPUT,
					"mmexternal: invalid interface.input parameter '%s'",
					cstr);
				ABORT_FINALIZE(RS_RET_INVLD_INTERFACE_INPUT);
			}
		} else {
			DBGPRINTF("mmexternal: program error, non-handled param '%s'\n", actpblk.descr[i].name);
		}
	}

	CHKiRet(OMSRsetEntry(*ppOMSR, 0, NULL, OMSR_TPL_AS_MSG));
	DBGPRINTF("mmexternal: bForceSingleInst %d\n", pData-&gt;bForceSingleInst);
	DBGPRINTF("mmexternal: interface.input '%s', mode %d\n", cstr, pData-&gt;inputProp);
CODE_STD_FINALIZERnewActInst
	free((void*)cstr);
	cnfparamvalsDestruct(pvals, &amp;actpblk);
ENDnewActInst

NO_LEGACY_CONF_parseSelectorAct


BEGINmodExit
CODESTARTmodExit
	free(cs.szBinary);
	cs.szBinary = NULL;
ENDmodExit


BEGINqueryEtryPt
CODESTARTqueryEtryPt
CODEqueryEtryPt_STD_OMOD_QUERIES
CODEqueryEtryPt_STD_OMOD8_QUERIES
CODEqueryEtryPt_STD_CONF2_CNFNAME_QUERIES
CODEqueryEtryPt_STD_CONF2_OMOD_QUERIES
ENDqueryEtryPt

BEGINmodInit()
CODESTARTmodInit
INITLegCnfVars
	*ipIFVersProvided = CURR_MOD_IF_VERSION; /* we only support the current interface specification */
CODEmodInit_QueryRegCFSLineHdlr
CODEmodInit_QueryRegCFSLineHdlr
ENDmodInit
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>omczmq.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
/* omczmq.c
 * Copyright (C) 2016 Brian Knox
 * Copyright (C) 2014 Rainer Gerhards
 *
 * Author: Brian Knox &lt;bknox@digitalocean.com&gt;
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


#include "config.h"
#include "rsyslog.h"
#include &lt;stdio.h&gt;
#include &lt;stdarg.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;assert.h&gt;
#include &lt;signal.h&gt;
#include &lt;errno.h&gt;
#include &lt;unistd.h&gt;
#include "conf.h"
#include "syslogd-types.h"
#include "srUtils.h"
#include "template.h"
#include "module-template.h"
#include "errmsg.h"
#include "cfsysline.h"
#include &lt;czmq.h&gt;

MODULE_TYPE_OUTPUT
MODULE_TYPE_NOKEEP
MODULE_CNFNAME("omczmq")

DEF_OMOD_STATIC_DATA
<a name="0"></a>
static pthread_mutex_t mutDoAct = PTHREAD_MUTEX_INITIALIZER;

<font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>static struct cnfparamdescr modpdescr[] = {
	{ "authenticator", eCmdHdlrBinary, 0 },
	{ "authtype", eCmdHdlrGetWord, 0 },
	{ "clientcertpath", eCmdHdlrGetWord, 0 },
	{ "servercertpath", eCmdHdlrGetWord, 0 }
};

static struct cnfparamblk modpblk = {
	CNFPARAMBLK_VERSION,
	sizeof(modpdescr)/sizeof(struct cnfparamdescr),
	modpdescr
};</b></font>

struct modConfData_s {
	rsconf_t *pConf;
	uchar *tplName;
	int authenticator;
	char *authType;
	char *serverCertPath;
	char *clientCertPath;
};

static modConfData_t *runModConf = NULL;
static zactor_t *authActor;

typedef struct _instanceData {
	zsock_t *sock;
	bool serverish;
	int sendTimeout;
	zlist_t *topics;
	bool sendError;
	char *sockEndpoints;
	int sockType;
	int sendHWM;
#if(CZMQ_VERSION_MAJOR &gt;= 4 &amp;&amp; ZMQ_VERSION_MAJOR &gt;=4 &amp;&amp; ZMQ_VERSION_MINOR &gt;=2)
	int heartbeatIvl;
	int heartbeatTimeout;
	int heartbeatTTL;
	int connectTimeout;
#endif
	uchar *tplName;
	sbool topicFrame;
	sbool dynaTopic;
} instanceData;

typedef struct wrkrInstanceData {
	instanceData *pData;
} wrkrInstanceData_t;

static struct cnfparamdescr actpdescr[] = {
	{ "endpoints", eCmdHdlrGetWord, 1 },
	{ "socktype", eCmdHdlrGetWord, 1 },
	{ "sendhwm", eCmdHdlrGetWord, 0 },
#if(CZMQ_VERSION_MAJOR &gt;= 4 &amp;&amp; ZMQ_VERSION_MAJOR &gt;=4 &amp;&amp; ZMQ_VERSION_MINOR &gt;=2)
	{ "heartbeatttl", eCmdHdlrGetWord, 0},
	{ "heartbeativl", eCmdHdlrGetWord, 0},
	{ "heartbeattimeout", eCmdHdlrGetWord, 0},
	{ "connecttimeout", eCmdHdlrGetWord, 0},
#endif
	{ "sendtimeout", eCmdHdlrGetWord, 0 },
	{ "template", eCmdHdlrGetWord, 0 },
	{ "topics", eCmdHdlrGetWord, 0 },
	{ "topicframe", eCmdHdlrGetWord, 0},
	{ "dynatopic", eCmdHdlrBinary, 0 }
};

static struct cnfparamblk actpblk = {
	CNFPARAMBLK_VERSION,
	sizeof(actpdescr) / sizeof(struct cnfparamdescr),
	actpdescr
};

static rsRetVal initCZMQ(instanceData* pData) {
	DEFiRet;
	int rc;
	putenv((char*)"ZSYS_SIGHANDLER=false");
	pData-&gt;sock = zsock_new(pData-&gt;sockType);
	if(!pData-&gt;sock) {
		LogError(0, RS_RET_NO_ERRCODE,
				"omczmq: new socket failed for endpoints: %s",
				pData-&gt;sockEndpoints);
		ABORT_FINALIZE(RS_RET_SUSPENDED);
	}

	zsock_set_sndtimeo(pData-&gt;sock, pData-&gt;sendTimeout);

#if(CZMQ_VERSION_MAJOR &gt;= 4 &amp;&amp; ZMQ_VERSION_MAJOR &gt;=4 &amp;&amp; ZMQ_VERSION_MINOR &gt;=2)
	if(pData-&gt;heartbeatIvl &gt; 0 &amp;&amp; pData-&gt;heartbeatTimeout &gt; 0 &amp;&amp; pData-&gt;heartbeatTTL &gt; 0) {
		zsock_set_heartbeat_ivl(pData-&gt;sock, pData-&gt;heartbeatIvl);
		zsock_set_heartbeat_timeout(pData-&gt;sock, pData-&gt;heartbeatTimeout);
		zsock_set_heartbeat_ttl(pData-&gt;sock, pData-&gt;heartbeatTTL);
	}
#endif

	if(runModConf-&gt;authType) {
		if (!strcmp(runModConf-&gt;authType, "CURVESERVER")) {
			zcert_t *serverCert = zcert_load(runModConf-&gt;serverCertPath);
			if(!serverCert) {
				LogError(0, NO_ERRCODE, "could not load cert %s",
					runModConf-&gt;serverCertPath);
				ABORT_FINALIZE(RS_RET_ERR);
			}
			zsock_set_zap_domain(pData-&gt;sock, "global");
			zsock_set_curve_server(pData-&gt;sock, 1);
			zcert_apply(serverCert, pData-&gt;sock);
			zcert_destroy(&amp;serverCert);
		}
		else if(!strcmp(runModConf-&gt;authType, "CURVECLIENT")) {
			zcert_t *serverCert = zcert_load(runModConf-&gt;serverCertPath);
			if(!serverCert) {
				LogError(0, NO_ERRCODE, "could not load cert %s",
					runModConf-&gt;serverCertPath);
				ABORT_FINALIZE(RS_RET_ERR);
			}
			const char *server_key = zcert_public_txt(serverCert);
			zcert_destroy(&amp;serverCert);
			zsock_set_curve_serverkey(pData-&gt;sock, server_key);

			zcert_t *clientCert = zcert_load(runModConf-&gt;clientCertPath);
			if(!clientCert) {
				LogError(0, NO_ERRCODE, "could not load cert %s",
					runModConf-&gt;clientCertPath);
				ABORT_FINALIZE(RS_RET_ERR);
			}

			zcert_apply(clientCert, pData-&gt;sock);
			zcert_destroy(&amp;clientCert);
		}
	}

	switch(pData-&gt;sockType) {
		case ZMQ_PUB:
#if defined(ZMQ_RADIO)
		case ZMQ_RADIO:
#endif
			pData-&gt;serverish = true;
			break;
		case ZMQ_PUSH:
#if defined(ZMQ_SCATTER)
		case ZMQ_SCATTER:
#endif
		case ZMQ_DEALER:
#if defined(ZMQ_CLIENT)
		case ZMQ_CLIENT:
#endif
			pData-&gt;serverish = false;
			break;
	}

	rc = zsock_attach(pData-&gt;sock, pData-&gt;sockEndpoints, pData-&gt;serverish);
	if(rc == -1) {
		LogError(0, NO_ERRCODE, "zsock_attach to %s failed",
				pData-&gt;sockEndpoints);
		ABORT_FINALIZE(RS_RET_SUSPENDED);
	}

finalize_it:
	RETiRet;
}

static rsRetVal outputCZMQ(uchar** ppString, instanceData* pData) {
	DEFiRet;

	if(NULL == pData-&gt;sock) {
		CHKiRet(initCZMQ(pData));
	}

	/* if we are using a PUB (or RADIO) socket and we have a topic list then we
	 * need some special care and attention */
#if defined(ZMQ_RADIO)
	DBGPRINTF("omczmq: ZMQ_RADIO is defined...\n");
	if((pData-&gt;sockType == ZMQ_PUB || pData-&gt;sockType == ZMQ_RADIO) &amp;&amp; pData-&gt;topics) {
#else
	DBGPRINTF("omczmq: ZMQ_RADIO is NOT defined...\n");
	if(pData-&gt;sockType == ZMQ_PUB &amp;&amp; pData-&gt;topics) {
#endif
		int templateIndex = 1;
		const char *topic = (const char *)zlist_first(pData-&gt;topics);
		while(topic) {
			int rc;
			/* if dynaTopic is true, the topic is constructed by rsyslog
			 * by applying the supplied template to the message properties */
			if(pData-&gt;dynaTopic)
				topic = (const char*)ppString[templateIndex];

			if (pData-&gt;sockType == ZMQ_PUB) {
				/* if topicFrame is true, send the topic as a separate zmq frame */
				if(pData-&gt;topicFrame) {
					rc = zstr_sendx(pData-&gt;sock, topic, (char*)ppString[0], NULL);
				}

				/* if topicFrame is false, concatenate the topic with the
				 * message in the same frame */
				else {
					rc = zstr_sendf(pData-&gt;sock, "%s%s", topic, (char*)ppString[0]);
				}

				/* if we have a send error notify rsyslog */
				if(rc != 0) {
					pData-&gt;sendError = true;
					ABORT_FINALIZE(RS_RET_SUSPENDED);
				}
			}
#if defined(ZMQ_RADIO)
			else if(pData-&gt;sockType == ZMQ_RADIO) {
				DBGPRINTF("omczmq: sending on RADIO socket...\n");
				zframe_t *frame = zframe_from((char*)ppString[0]);
				if (!frame) {
					DBGPRINTF("omczmq: failed to create frame...\n");
					pData-&gt;sendError = true;
					ABORT_FINALIZE(RS_RET_SUSPENDED);
				}
				rc = zframe_set_group(frame, topic);
				if (rc != 0) {
					DBGPRINTF("omczmq: failed to set group '%d'...\n", rc);
					pData-&gt;sendError = true;
					ABORT_FINALIZE(RS_RET_SUSPENDED);
				}
				DBGPRINTF("omczmq: set RADIO group to '%s'\n", topic);
				rc = zframe_send(&amp;frame, pData-&gt;sock, 0);
				if(rc != 0) {
					pData-&gt;sendError = true;
					ABORT_FINALIZE(RS_RET_SUSPENDED);
				}
			}
#endif

			/* get the next topic from the list, and increment
			 * our topic index */
			topic = zlist_next(pData-&gt;topics);
			templateIndex++;
		}
	}

	/* we aren't a PUB socket and we don't have a topic list - this means
	 * we can just send the message using the rsyslog template */
	else {
		int rc = zstr_send(pData-&gt;sock, (char*)ppString[0]);
		if(rc != 0) {
			pData-&gt;sendError = true;
			DBGPRINTF("omczmq: send error: %d", rc);
			ABORT_FINALIZE(RS_RET_SUSPENDED);
		}
	}
finalize_it:
	RETiRet;
}

static inline void
setInstParamDefaults(instanceData* pData) {
	pData-&gt;sockEndpoints = NULL;
	pData-&gt;sock = NULL;
	pData-&gt;sendError = false;
	pData-&gt;serverish = false;
	pData-&gt;tplName = NULL;
	pData-&gt;sockType = -1;
	pData-&gt;sendTimeout = -1;
	pData-&gt;topics = NULL;
	pData-&gt;topicFrame = false;
#if(CZMQ_VERSION_MAJOR &gt;= 4 &amp;&amp; ZMQ_VERSION_MAJOR &gt;=4 &amp;&amp; ZMQ_VERSION_MINOR &gt;=2)
	pData-&gt;heartbeatIvl = 0;
	pData-&gt;heartbeatTimeout = 0;
	pData-&gt;heartbeatTTL = 0;
#endif
}


BEGINcreateInstance
CODESTARTcreateInstance
ENDcreateInstance

BEGINcreateWrkrInstance
CODESTARTcreateWrkrInstance
ENDcreateWrkrInstance

BEGINisCompatibleWithFeature
CODESTARTisCompatibleWithFeature
	if(eFeat == sFEATURERepeatedMsgReduction) {
		iRet = RS_RET_OK;
	}
ENDisCompatibleWithFeature
BEGINdbgPrintInstInfo
CODESTARTdbgPrintInstInfo
ENDdbgPrintInstInfo

BEGINfreeInstance
CODESTARTfreeInstance
	zlist_destroy(&amp;pData-&gt;topics);
	zsock_destroy(&amp;pData-&gt;sock);
	free(pData-&gt;sockEndpoints);
	free(pData-&gt;tplName);
ENDfreeInstance


BEGINfreeWrkrInstance
CODESTARTfreeWrkrInstance
ENDfreeWrkrInstance

BEGINtryResume
	instanceData *pData;
CODESTARTtryResume
	pthread_mutex_lock(&amp;mutDoAct);
	pData = pWrkrData-&gt;pData;
	DBGPRINTF("omczmq: trying to resume...\n");
	zsock_destroy(&amp;pData-&gt;sock);
	iRet = initCZMQ(pData);
	pthread_mutex_unlock(&amp;mutDoAct);
ENDtryResume

BEGINbeginCnfLoad
CODESTARTbeginCnfLoad
	runModConf = pModConf;
	runModConf-&gt;pConf = pConf;
	runModConf-&gt;authenticator = 0;
	runModConf-&gt;authType = NULL;
	runModConf-&gt;serverCertPath = NULL;
	runModConf-&gt;clientCertPath = NULL;
ENDbeginCnfLoad

BEGINcheckCnf
CODESTARTcheckCnf
ENDcheckCnf

BEGINactivateCnf
CODESTARTactivateCnf
	runModConf = pModConf;
	if(runModConf-&gt;authenticator == 1) {
		if(!authActor) {
			DBGPRINTF("omczmq: starting authActor\n");
			authActor = zactor_new(zauth, NULL);
			if(!strcmp(runModConf-&gt;clientCertPath, "*")) {
				zstr_sendx(authActor, "CURVE", CURVE_ALLOW_ANY, NULL);
			}
			else {
				zstr_sendx(authActor, "CURVE", runModConf-&gt;clientCertPath, NULL);
			}
			zsock_wait(authActor);
		}
	}
ENDactivateCnf

BEGINfreeCnf
CODESTARTfreeCnf
	free(pModConf-&gt;tplName);
	free(pModConf-&gt;authType);
	free(pModConf-&gt;serverCertPath);
	free(pModConf-&gt;clientCertPath);
	DBGPRINTF("omczmq: stopping authActor\n");
	zactor_destroy(&amp;authActor);
ENDfreeCnf

BEGINsetModCnf
	struct cnfparamvals *pvals = NULL;
	int i;
CODESTARTsetModCnf
	pvals = nvlstGetParams(lst, &amp;modpblk, NULL);
	if (pvals == NULL) {
		LogError(0, RS_RET_MISSING_CNFPARAMS, "error processing module");
		ABORT_FINALIZE(RS_RET_MISSING_CNFPARAMS);
	}

	for (i=0; i&lt;modpblk.nParams; ++i) {
		if(!pvals[i].bUsed) {
			DBGPRINTF("omczmq: pvals[i].bUSed continuing\n");
			continue;
		}
		if(!strcmp(modpblk.descr[i].name, "authenticator")) {
			runModConf-&gt;authenticator = (int)pvals[i].val.d.n;
		}
		else if(!strcmp(modpblk.descr[i].name, "authtype")) {
			runModConf-&gt;authType = es_str2cstr(pvals[i].val.d.estr, NULL);
			DBGPRINTF("omczmq: authtype set to %s\n", runModConf-&gt;authType);
		}
		else if(!strcmp(modpblk.descr[i].name, "servercertpath")) {
			runModConf-&gt;serverCertPath = es_str2cstr(pvals[i].val.d.estr, NULL);
			DBGPRINTF("omczmq: serverCertPath set to %s\n", runModConf-&gt;serverCertPath);
		}
		else if(!strcmp(modpblk.descr[i].name, "clientcertpath")) {
			runModConf-&gt;clientCertPath = es_str2cstr(pvals[i].val.d.estr, NULL);
			DBGPRINTF("omczmq: clientCertPath set to %s\n", runModConf-&gt;clientCertPath);
		}
		else {
			LogError(0, RS_RET_INVALID_PARAMS,
						"omczmq: config error, unknown "
						"param %s in setModCnf\n",
						modpblk.descr[i].name);
		}
	}

	DBGPRINTF("omczmq: authenticator set to %d\n", runModConf-&gt;authenticator);
	DBGPRINTF("omczmq: authType set to %s\n", runModConf-&gt;authType);
	DBGPRINTF("omczmq: serverCertPath set to %s\n", runModConf-&gt;serverCertPath);
	DBGPRINTF("omczmq: clientCertPath set to %s\n", runModConf-&gt;clientCertPath);

finalize_it:
		if(pvals != NULL)
			cnfparamvalsDestruct(pvals, &amp;modpblk);
ENDsetModCnf

BEGINendCnfLoad
CODESTARTendCnfLoad
	runModConf = NULL;
ENDendCnfLoad


BEGINdoAction
	instanceData *pData;
CODESTARTdoAction
	pthread_mutex_lock(&amp;mutDoAct);
	pData = pWrkrData-&gt;pData;
	iRet = outputCZMQ(ppString, pData);
	pthread_mutex_unlock(&amp;mutDoAct);
ENDdoAction


BEGINnewActInst
	struct cnfparamvals *pvals;
	int i;
	int iNumTpls;
CODESTARTnewActInst
	if ((pvals = nvlstGetParams(lst, &amp;actpblk, NULL)) == NULL) {
		ABORT_FINALIZE(RS_RET_MISSING_CNFPARAMS);
	}

	CHKiRet(createInstance(&amp;pData));
	setInstParamDefaults(pData);

	for(i = 0; i &lt; actpblk.nParams; ++i) {
		if(!pvals[i].bUsed) {
			continue;
		}

		if(!strcmp(actpblk.descr[i].name, "endpoints")) {
			pData-&gt;sockEndpoints = es_str2cstr(pvals[i].val.d.estr, NULL);
			DBGPRINTF("omczmq: sockEndPoints set to '%s'\n", pData-&gt;sockEndpoints);
		}
		else if(!strcmp(actpblk.descr[i].name, "template")) {
			pData-&gt;tplName = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
			DBGPRINTF("omczmq: template set to '%s'\n", pData-&gt;tplName);
		}
		else if(!strcmp(actpblk.descr[i].name, "dynatopic")) {
			pData-&gt;dynaTopic = pvals[i].val.d.n;
			DBGPRINTF("omczmq: dynaTopic set to %s\n", pData-&gt;dynaTopic ? "true" : "false");
		}
		else if(!strcmp(actpblk.descr[i].name, "sendtimeout")) {
			pData-&gt;sendTimeout = atoi(es_str2cstr(pvals[i].val.d.estr, NULL));
			DBGPRINTF("omczmq: sendTimeout set to %d\n", pData-&gt;sendTimeout);
		}
		else if(!strcmp(actpblk.descr[i].name, "sendhwm")) {
			pData-&gt;sendTimeout = atoi(es_str2cstr(pvals[i].val.d.estr, NULL));
			DBGPRINTF("omczmq: sendHWM set to %d\n", pData-&gt;sendHWM);
		}
#if (CZMQ_VERSION_MAJOR &gt;= 4 &amp;&amp; ZMQ_VERSION_MAJOR &gt;=4 &amp;&amp; ZMQ_VERSION_MINOR &gt;=2)
		else if(!strcmp(actpblk.descr[i].name, "heartbeativl")) {
			pData-&gt;heartbeatIvl = atoi(es_str2cstr(pvals[i].val.d.estr, NULL));
			DBGPRINTF("omczmq: heartbeatbeatIvl set to %d\n", pData-&gt;heartbeatIvl);
		}
		else if(!strcmp(actpblk.descr[i].name, "heartbeattimeout")) {
			pData-&gt;heartbeatTimeout = atoi(es_str2cstr(pvals[i].val.d.estr, NULL));
			DBGPRINTF("omczmq: heartbeatTimeout set to %d\n", pData-&gt;heartbeatTimeout);
		}
		else if(!strcmp(actpblk.descr[i].name, "heartbeatttl")) {
			pData-&gt;heartbeatTimeout = atoi(es_str2cstr(pvals[i].val.d.estr, NULL));
			DBGPRINTF("omczmq: heartbeatTTL set to %d\n", pData-&gt;heartbeatTTL);
		}
#endif
		else if(!strcmp(actpblk.descr[i].name, "socktype")){
			char *stringType = es_str2cstr(pvals[i].val.d.estr, NULL);
			if(stringType != NULL){
				if(!strcmp("PUB", stringType)) {
					pData-&gt;sockType = ZMQ_PUB;
					DBGPRINTF("omczmq: sockType set to ZMQ_PUB\n");
				}
#if defined(ZMQ_RADIO)
				else if(!strcmp("RADIO", stringType)) {
					pData-&gt;sockType = ZMQ_RADIO;
					DBGPRINTF("omczmq: sockType set to ZMQ_RADIO\n");
				}
#endif
				else if(!strcmp("PUSH", stringType)) {
					pData-&gt;sockType = ZMQ_PUSH;
					DBGPRINTF("omczmq: sockType set to ZMQ_PUSH\n");
				}
#if defined(ZMQ_SCATTER)
				else if(!strcmp("SCATTER", stringType)) {
					pData-&gt;sockType = ZMQ_SCATTER;
					DBGPRINTF("omczmq: sockType set to ZMQ_SCATTER\n");
				}
#endif
				else if(!strcmp("DEALER", stringType)) {
					pData-&gt;sockType = ZMQ_DEALER;
					DBGPRINTF("omczmq: sockType set to ZMQ_DEALER\n");
				}
#if defined(ZMQ_CLIENT)
				else if(!strcmp("CLIENT", stringType)) {
					pData-&gt;sockType = ZMQ_CLIENT;
					DBGPRINTF("omczmq: sockType set to ZMQ_CLIENT\n");
				}
#endif
				free(stringType);
			}
			else{
				LogError(0, RS_RET_OUT_OF_MEMORY,
						"omczmq: out of memory");
				ABORT_FINALIZE(RS_RET_OUT_OF_MEMORY);
			}
		}
		else if(!strcmp(actpblk.descr[i].name, "topicframe")) {
			pData-&gt;topicFrame = pvals[i].val.d.n;
			DBGPRINTF("omczmq: topicFrame set to %s\n", pData-&gt;topicFrame ? "true" : "false");
		}
		else if(!strcmp(actpblk.descr[i].name, "topics")) {
			pData-&gt;topics = zlist_new();
			char *topics = es_str2cstr(pvals[i].val.d.estr, NULL);
			DBGPRINTF("omczmq: topics set to %s\n", topics);
			char *topics_org = topics;
			char topic[256];
			if(topics == NULL){
				LogError(0, RS_RET_OUT_OF_MEMORY,
					"out of memory");
				ABORT_FINALIZE(RS_RET_OUT_OF_MEMORY);
			}

			while(*topics) {
				char *delimiter = strchr(topics, ',');
				if (!delimiter) {
					delimiter = topics + strlen(topics);
				}
				memcpy (topic, topics, delimiter - topics);
				topic[delimiter-topics] = 0;
				char *current_topic = strdup(topic);
				zlist_append (pData-&gt;topics, current_topic);
				if(*delimiter == 0) {
					break;
				}
				topics = delimiter + 1;
			}
			free(topics_org);

		}
		else {
			LogError(0, NO_ERRCODE,
					"omczmq: config error - '%s' is not a valid option",
					actpblk.descr[i].name);
			ABORT_FINALIZE(RS_RET_CONFIG_ERROR);
		}
	}

	iNumTpls = 1;
	if (pData-&gt;dynaTopic) {
		iNumTpls = zlist_size (pData-&gt;topics) + iNumTpls;
	}
	CODE_STD_STRING_REQUESTnewActInst(iNumTpls)
	
	if (pData-&gt;tplName == NULL) {
		CHKiRet(OMSRsetEntry(*ppOMSR, 0, (uchar*)strdup("RSYSLOG_ForwardFormat"),
					OMSR_NO_RQD_TPL_OPTS));
	}
	else {
		CHKiRet(OMSRsetEntry(*ppOMSR, 0, (uchar*)pData-&gt;tplName, OMSR_NO_RQD_TPL_OPTS));
	}

	i = 1;
	if (pData-&gt;dynaTopic) {
		char *topic = zlist_first(pData-&gt;topics);
		while (topic) {
			CHKiRet(OMSRsetEntry(*ppOMSR, i, (uchar*)strdup(topic), OMSR_NO_RQD_TPL_OPTS));
			i++;
			topic = zlist_next(pData-&gt;topics);
		}
	}

	CODE_STD_FINALIZERnewActInst
	cnfparamvalsDestruct(pvals, &amp;actpblk);
ENDnewActInst

BEGINinitConfVars
CODESTARTinitConfVars
ENDinitConfVars

NO_LEGACY_CONF_parseSelectorAct

BEGINmodExit
CODESTARTmodExit
ENDmodExit

BEGINqueryEtryPt
CODESTARTqueryEtryPt
	CODEqueryEtryPt_STD_OMOD_QUERIES
	CODEqueryEtryPt_STD_CONF2_OMOD_QUERIES
	CODEqueryEtryPt_STD_CONF2_QUERIES
	CODEqueryEtryPt_STD_CONF2_setModCnf_QUERIES
	CODEqueryEtryPt_STD_OMOD8_QUERIES
ENDqueryEtryPt


BEGINmodInit()
CODESTARTmodInit
	*ipIFVersProvided = CURR_MOD_IF_VERSION;
CODEmodInit_QueryRegCFSLineHdlr
	INITChkCoreFeature(bCoreSupportsBatching, CORE_FEATURE_BATCHING);
	DBGPRINTF("omczmq: module compiled with rsyslog version %s.\n", VERSION);

	INITLegCnfVars
ENDmodInit
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
