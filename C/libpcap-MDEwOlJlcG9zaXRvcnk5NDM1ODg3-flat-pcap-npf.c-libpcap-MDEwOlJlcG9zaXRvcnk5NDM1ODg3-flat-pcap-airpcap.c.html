
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 18, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>libpcap-MDEwOlJlcG9zaXRvcnk5NDM1ODg3-flat-pcap-npf.c</h3>
            <pre><code>1  #ifdef HAVE_CONFIG_H
2  #include <config.h>
3  #endif
4  #include <errno.h>
5  #include <limits.h> &bsol;* for INT_MAX */
6  #define PCAP_DONT_INCLUDE_PCAP_BPF_H
7  #include <Packet32.h>
8  #include <pcap-int.h>
9  #include <pcap/dlt.h>
10  #define		BPF_RET		0x06
11  #define		BPF_K		0x00
12  #if defined(__MINGW32__) && !defined(__MINGW64_VERSION_MAJOR)
13    #include <ddk/ntddndis.h>
14    #include <ddk/ndis.h>
15  #else
16    #include <ntddndis.h>  &bsol;* MSVC/TDM-MinGW/MinGW64 */
17  #endif
18  #ifdef HAVE_DAG_API
19    #include <dagnew.h>
20    #include <dagapi.h>
21  #endif &bsol;* HAVE_DAG_API */
22  #include "diag-control.h"
23  #include "pcap-airpcap.h"
24  static int pcap_setfilter_npf(pcap_t *, struct bpf_program *);
25  static int pcap_setfilter_win32_dag(pcap_t *, struct bpf_program *);
26  static int pcap_getnonblock_npf(pcap_t *);
27  static int pcap_setnonblock_npf(pcap_t *, int);
28  #define	WIN32_DEFAULT_USER_BUFFER_SIZE 256000
29  #define	WIN32_DEFAULT_KERNEL_BUFFER_SIZE 1000000
30  #define SWAPS(_X) ((_X & 0xff) << 8) | (_X >> 8)
31  struct pcap_win {
32  	ADAPTER *adapter;		&bsol;* the packet32 ADAPTER for the device */
33  	int nonblock;
34  	int rfmon_selfstart;		&bsol;* a flag tells whether the monitor mode is set by itself */
35  	int filtering_in_kernel;	&bsol;* using kernel filter */
36  #ifdef HAVE_DAG_API
37  	int	dag_fcs_bits;		&bsol;* Number of checksum bits from link layer */
38  #endif
39  #ifdef ENABLE_REMOTE
40  	int samp_npkt;			&bsol;* parameter needed for sampling, with '1 out of N' method has been requested */
41  	struct timeval samp_time;	&bsol;* parameter needed for sampling, with '1 every N ms' method has been requested */
42  #endif
43  };
44  #ifndef HAVE_NPCAP_PACKET_API
45  static int
46  PacketIsMonitorModeSupported(PCHAR AdapterName _U_)
47  {
48  	return (0);
49  }
50  static int
51  PacketSetMonitorMode(PCHAR AdapterName _U_, int mode _U_)
52  {
53  	return (0);
54  }
55  static int
56  PacketGetMonitorMode(PCHAR AdapterName _U_)
57  {
58  	return (-1);
59  }
60  #endif
61  #define NT_STATUS_CUSTOMER_DEFINED	0x20000000
62  #define NDIS_STATUS_INVALID_OID		0xc0010017
63  #define NDIS_STATUS_NOT_SUPPORTED	0xc00000bb	&bsol;* STATUS_NOT_SUPPORTED */
64  #define NDIS_STATUS_NOT_RECOGNIZED	0x00010001
65  static int
66  oid_get_request(ADAPTER *adapter, bpf_u_int32 oid, void *data, size_t *lenp,
67      char *errbuf)
68  {
69  	PACKET_OID_DATA *oid_data_arg;
70  	oid_data_arg = malloc(sizeof (PACKET_OID_DATA) + *lenp);
71  	if (oid_data_arg == NULL) {
72  		snprintf(errbuf, PCAP_ERRBUF_SIZE,
73  		    "Couldn't allocate argument buffer for PacketRequest");
74  		return (PCAP_ERROR);
75  	}
76  	oid_data_arg->Oid = oid;
77  	oid_data_arg->Length = (ULONG)(*lenp);	&bsol;* XXX - check for ridiculously large value? */
78  	if (!PacketRequest(adapter, FALSE, oid_data_arg)) {
79  		pcap_fmt_errmsg_for_win32_err(errbuf, PCAP_ERRBUF_SIZE,
80  		    GetLastError(), "Error calling PacketRequest");
81  		free(oid_data_arg);
82  		return (-1);
83  	}
84  	*lenp = oid_data_arg->Length;
85  	memcpy(data, oid_data_arg->Data, *lenp);
86  	free(oid_data_arg);
87  	return (0);
88  }
89  static int
90  pcap_stats_npf(pcap_t *p, struct pcap_stat *ps)
91  {
92  	struct pcap_win *pw = p->priv;
93  	struct bpf_stat bstats;
94  	if (!PacketGetStats(pw->adapter, &bstats)) {
95  		pcap_fmt_errmsg_for_win32_err(p->errbuf, PCAP_ERRBUF_SIZE,
96  		    GetLastError(), "PacketGetStats error");
97  		return (-1);
98  	}
99  	ps->ps_recv = bstats.bs_recv;
100  	ps->ps_drop = bstats.bs_drop;
101  #if 0
102  	ps->ps_ifdrop = bstats.ps_ifdrop;
103  #else
104  	ps->ps_ifdrop = 0;
105  #endif
106  	return (0);
107  }
108  static struct pcap_stat *
109  pcap_stats_ex_npf(pcap_t *p, int *pcap_stat_size)
110  {
111  	struct pcap_win *pw = p->priv;
112  	struct bpf_stat bstats;
113  	*pcap_stat_size = sizeof (p->stat);
114  	if (!PacketGetStatsEx(pw->adapter, &bstats)) {
115  		pcap_fmt_errmsg_for_win32_err(p->errbuf, PCAP_ERRBUF_SIZE,
116  		    GetLastError(), "PacketGetStatsEx error");
117  		return (NULL);
118  	}
119  	p->stat.ps_recv = bstats.bs_recv;
120  	p->stat.ps_drop = bstats.bs_drop;
121  	p->stat.ps_ifdrop = bstats.ps_ifdrop;
122  #ifdef _WIN32
123  	p->stat.ps_capt = bstats.bs_capt;
124  #endif
125  	return (&p->stat);
126  }
127  static int
128  pcap_setbuff_npf(pcap_t *p, int dim)
129  {
130  	struct pcap_win *pw = p->priv;
131  	if(PacketSetBuff(pw->adapter,dim)==FALSE)
132  	{
133  		snprintf(p->errbuf, PCAP_ERRBUF_SIZE, "driver error: not enough memory to allocate the kernel buffer");
134  		return (-1);
135  	}
136  	return (0);
137  }
138  static int
139  pcap_setmode_npf(pcap_t *p, int mode)
140  {
141  	struct pcap_win *pw = p->priv;
142  	if(PacketSetMode(pw->adapter,mode)==FALSE)
143  	{
144  		snprintf(p->errbuf, PCAP_ERRBUF_SIZE, "driver error: working mode not recognized");
145  		return (-1);
146  	}
147  	return (0);
148  }
149  static int
150  pcap_setmintocopy_npf(pcap_t *p, int size)
151  {
152  	struct pcap_win *pw = p->priv;
153  	if(PacketSetMinToCopy(pw->adapter, size)==FALSE)
154  	{
155  		snprintf(p->errbuf, PCAP_ERRBUF_SIZE, "driver error: unable to set the requested mintocopy size");
156  		return (-1);
157  	}
158  	return (0);
159  }
160  static HANDLE
161  pcap_getevent_npf(pcap_t *p)
162  {
163  	struct pcap_win *pw = p->priv;
164  	return (PacketGetReadEvent(pw->adapter));
165  }
166  static int
167  pcap_oid_get_request_npf(pcap_t *p, bpf_u_int32 oid, void *data, size_t *lenp)
168  {
169  	struct pcap_win *pw = p->priv;
170  	return (oid_get_request(pw->adapter, oid, data, lenp, p->errbuf));
171  }
172  static int
173  pcap_oid_set_request_npf(pcap_t *p, bpf_u_int32 oid, const void *data,
174      size_t *lenp)
175  {
176  	struct pcap_win *pw = p->priv;
177  	PACKET_OID_DATA *oid_data_arg;
178  	oid_data_arg = malloc(sizeof (PACKET_OID_DATA) + *lenp);
179  	if (oid_data_arg == NULL) {
180  		snprintf(p->errbuf, PCAP_ERRBUF_SIZE,
181  		    "Couldn't allocate argument buffer for PacketRequest");
182  		return (PCAP_ERROR);
183  	}
184  	oid_data_arg->Oid = oid;
185  	oid_data_arg->Length = (ULONG)(*lenp);	&bsol;* XXX - check for ridiculously large value? */
186  	memcpy(oid_data_arg->Data, data, *lenp);
187  	if (!PacketRequest(pw->adapter, TRUE, oid_data_arg)) {
188  		pcap_fmt_errmsg_for_win32_err(p->errbuf, PCAP_ERRBUF_SIZE,
189  		    GetLastError(), "Error calling PacketRequest");
190  		free(oid_data_arg);
191  		return (PCAP_ERROR);
192  	}
193  	*lenp = oid_data_arg->Length;
194  	free(oid_data_arg);
195  	return (0);
196  }
197  static u_int
198  pcap_sendqueue_transmit_npf(pcap_t *p, pcap_send_queue *queue, int sync)
199  {
200  	struct pcap_win *pw = p->priv;
201  	u_int res;
202  	res = PacketSendPackets(pw->adapter,
203  		queue->buffer,
204  		queue->len,
205  		(BOOLEAN)sync);
206  	if(res != queue->len){
207  		pcap_fmt_errmsg_for_win32_err(p->errbuf, PCAP_ERRBUF_SIZE,
208  		    GetLastError(), "Error queueing packets");
209  	}
210  	return (res);
211  }
212  static int
213  pcap_setuserbuffer_npf(pcap_t *p, int size)
214  {
215  	unsigned char *new_buff;
216  	if (size<=0) {
217  		snprintf(p->errbuf, PCAP_ERRBUF_SIZE,
218  		    "Error: invalid size %d",size);
219  		return (-1);
220  	}
221  	new_buff=(unsigned char*)malloc(sizeof(char)*size);
222  	if (!new_buff) {
223  		snprintf(p->errbuf, PCAP_ERRBUF_SIZE,
224  		    "Error: not enough memory");
225  		return (-1);
226  	}
227  	free(p->buffer);
228  	p->buffer=new_buff;
229  	p->bufsize=size;
230  	return (0);
231  }
232  #ifdef HAVE_NPCAP_PACKET_API
233  static int
234  pcap_live_dump_npf(pcap_t *p, char *filename _U_, int maxsize _U_,
235      int maxpacks _U_)
236  {
237  	snprintf(p->errbuf, PCAP_ERRBUF_SIZE,
238  	    "Npcap doesn't support kernel dump mode");
239  	return (-1);
240  }
241  static int
242  pcap_live_dump_ended_npf(pcap_t *p, int sync)
243  {
244  	snprintf(p->errbuf, PCAP_ERRBUF_SIZE,
245  	    "Npcap doesn't support kernel dump mode");
246  	return (-1);
247  }
248  #else &bsol;* HAVE_NPCAP_PACKET_API */
249  static int
250  pcap_live_dump_npf(pcap_t *p, char *filename, int maxsize, int maxpacks)
251  {
252  	struct pcap_win *pw = p->priv;
253  	BOOLEAN res;
254  	res = PacketSetMode(pw->adapter, PACKET_MODE_DUMP);
255  	if(res == FALSE){
256  		snprintf(p->errbuf, PCAP_ERRBUF_SIZE,
257  		    "Error setting dump mode");
258  		return (-1);
259  	}
260  	res = PacketSetDumpName(pw->adapter, filename, (int)strlen(filename));
261  	if(res == FALSE){
262  		snprintf(p->errbuf, PCAP_ERRBUF_SIZE,
263  		    "Error setting kernel dump file name");
264  		return (-1);
265  	}
266  	res = PacketSetDumpLimits(pw->adapter, maxsize, maxpacks);
267  	if(res == FALSE) {
268  		snprintf(p->errbuf, PCAP_ERRBUF_SIZE,
269  				"Error setting dump limit");
270  		return (-1);
271  	}
272  	return (0);
273  }
274  static int
275  pcap_live_dump_ended_npf(pcap_t *p, int sync)
276  {
277  	struct pcap_win *pw = p->priv;
278  	return (PacketIsDumpEnded(pw->adapter, (BOOLEAN)sync));
279  }
280  #endif &bsol;* HAVE_NPCAP_PACKET_API */
281  #ifdef HAVE_AIRPCAP_API
282  static PAirpcapHandle
283  pcap_get_airpcap_handle_npf(pcap_t *p)
284  {
285  	struct pcap_win *pw = p->priv;
286  	return (PacketGetAirPcapHandle(pw->adapter));
287  }
288  #else &bsol;* HAVE_AIRPCAP_API */
289  static PAirpcapHandle
290  pcap_get_airpcap_handle_npf(pcap_t *p _U_)
291  {
292  	return (NULL);
293  }
294  #endif &bsol;* HAVE_AIRPCAP_API */
295  static int
296  pcap_read_npf(pcap_t *p, int cnt, pcap_handler callback, u_char *user)
297  {
298  	PACKET Packet;
299  	int cc;
300  	int n;
301  	register u_char *bp, *ep;
302  	u_char *datap;
303  	struct pcap_win *pw = p->priv;
304  	cc = p->cc;
305  	if (cc == 0) {
306  		if (p->break_loop) {
307  			p->break_loop = 0;
308  			return (PCAP_ERROR_BREAK);
309  		}
310  		PacketInitPacket(&Packet, (BYTE *)p->buffer, p->bufsize);
311  		if (!PacketReceivePacket(pw->adapter, &Packet, TRUE)) {
312  			DWORD errcode = GetLastError();
313  			if (errcode == ERROR_GEN_FAILURE ||
314  			    errcode == ERROR_DEVICE_REMOVED) {
315  				const char *errcode_msg;
316  				if (errcode == ERROR_GEN_FAILURE)
317  					errcode_msg = "ERROR_GEN_FAILURE/STATUS_UNSUCCESSFUL";
318  				else
319  					errcode_msg = "ERROR_DEVICE_REMOVED/STATUS_DEVICE_REMOVED";
320  				snprintf(p->errbuf, PCAP_ERRBUF_SIZE,
321  				    "The interface disappeared (error code %s)",
322  				    errcode_msg);
323  			} else {
324  				pcap_fmt_errmsg_for_win32_err(p->errbuf,
325  				    PCAP_ERRBUF_SIZE, errcode,
326  				    "PacketReceivePacket error");
327  			}
328  			return (PCAP_ERROR);
329  		}
330  		cc = Packet.ulBytesReceived;
331  		bp = p->buffer;
332  	}
333  	else
334  		bp = p->bp;
335  #define bhp ((struct bpf_hdr *)bp)
336  	n = 0;
337  	ep = bp + cc;
338  	for (;;) {
339  		register u_int caplen, hdrlen;
340  		if (p->break_loop) {
341  			if (n == 0) {
342  				p->break_loop = 0;
343  				return (PCAP_ERROR_BREAK);
344  			} else {
345  				p->bp = bp;
346  				p->cc = (int) (ep - bp);
347  				return (n);
348  			}
349  		}
350  		if (bp >= ep)
351  			break;
352  		caplen = bhp->bh_caplen;
353  		hdrlen = bhp->bh_hdrlen;
354  		datap = bp + hdrlen;
355  		if (pw->filtering_in_kernel ||
356  		    p->fcode.bf_insns == NULL ||
<span onclick='openModal()' class='match'>357  		    pcap_filter(p->fcode.bf_insns, datap, bhp->bh_datalen, caplen)) {
358  #ifdef ENABLE_REMOTE
</span>359  			switch (p->rmt_samp.method) {
360  			case PCAP_SAMP_1_EVERY_N:
361  				pw->samp_npkt = (pw->samp_npkt + 1) % p->rmt_samp.value;
362  				if (pw->samp_npkt != 0) {
363  					bp += Packet_WORDALIGN(caplen + hdrlen);
364  					continue;
365  				}
366  				break;
367  			case PCAP_SAMP_FIRST_AFTER_N_MS:
368  			    {
369  				struct pcap_pkthdr *pkt_header = (struct pcap_pkthdr*) bp;
370  				if (pkt_header->ts.tv_sec < pw->samp_time.tv_sec ||
371  				   (pkt_header->ts.tv_sec == pw->samp_time.tv_sec && pkt_header->ts.tv_usec < pw->samp_time.tv_usec)) {
372  					bp += Packet_WORDALIGN(caplen + hdrlen);
373  					continue;
374  				}
375  				pw->samp_time.tv_usec = pkt_header->ts.tv_usec + p->rmt_samp.value * 1000;
376  				if (pw->samp_time.tv_usec > 1000000) {
377  					pw->samp_time.tv_sec = pkt_header->ts.tv_sec + pw->samp_time.tv_usec / 1000000;
378  					pw->samp_time.tv_usec = pw->samp_time.tv_usec % 1000000;
379  				}
380  			    }
381  			}
382  #endif	&bsol;* ENABLE_REMOTE */
383  			(*callback)(user, (struct pcap_pkthdr*)bp, datap);
384  			bp += Packet_WORDALIGN(caplen + hdrlen);
385  			if (++n >= cnt && !PACKET_COUNT_IS_UNLIMITED(cnt)) {
386  				p->bp = bp;
387  				p->cc = (int) (ep - bp);
388  				return (n);
389  			}
390  		} else {
391  			bp += Packet_WORDALIGN(caplen + hdrlen);
392  		}
393  	}
394  #undef bhp
395  	p->cc = 0;
396  	return (n);
397  }
398  #ifdef HAVE_DAG_API
399  static int
400  pcap_read_win32_dag(pcap_t *p, int cnt, pcap_handler callback, u_char *user)
401  {
402  	struct pcap_win *pw = p->priv;
403  	PACKET Packet;
404  	u_char *dp = NULL;
405  	int	packet_len = 0, caplen = 0;
406  	struct pcap_pkthdr	pcap_header;
407  	u_char *endofbuf;
408  	int n = 0;
409  	dag_record_t *header;
410  	unsigned erf_record_len;
411  	ULONGLONG ts;
412  	int cc;
413  	unsigned swt;
414  	unsigned dfp = pw->adapter->DagFastProcess;
415  	cc = p->cc;
416  	if (cc == 0) &bsol;* Get new packets only if we have processed all the ones of the previous read */
417  	{
418  		PacketInitPacket(&Packet, (BYTE *)p->buffer, p->bufsize);
419  		if (!PacketReceivePacket(pw->adapter, &Packet, TRUE)) {
420  			snprintf(p->errbuf, PCAP_ERRBUF_SIZE, "read error: PacketReceivePacket failed");
421  			return (-1);
422  		}
423  		cc = Packet.ulBytesReceived;
424  		if(cc == 0)
425  			return (0);
426  		header = (dag_record_t*)pw->adapter->DagBuffer;
427  	}
428  	else
429  		header = (dag_record_t*)p->bp;
430  	endofbuf = (char*)header + cc;
431  	if (PACKET_COUNT_IS_UNLIMITED(cnt))
432  		cnt = INT_MAX;
433  	do
434  	{
435  		erf_record_len = SWAPS(header->rlen);
436  		if((char*)header + erf_record_len > endofbuf)
437  			break;
438  		p->stat.ps_recv++;
439  		dp = ((u_char *)header) + dag_record_size;
440  		switch(header->type)
441  		{
442  		case TYPE_ATM:
443  			packet_len = ATM_SNAPLEN;
444  			caplen = ATM_SNAPLEN;
445  			dp += 4;
446  			break;
447  		case TYPE_ETH:
448  			swt = SWAPS(header->wlen);
449  			packet_len = swt - (pw->dag_fcs_bits);
450  			caplen = erf_record_len - dag_record_size - 2;
451  			if (caplen > packet_len)
452  			{
453  				caplen = packet_len;
454  			}
455  			dp += 2;
456  			break;
457  		case TYPE_HDLC_POS:
458  			swt = SWAPS(header->wlen);
459  			packet_len = swt - (pw->dag_fcs_bits);
460  			caplen = erf_record_len - dag_record_size;
461  			if (caplen > packet_len)
462  			{
463  				caplen = packet_len;
464  			}
465  			break;
466  		}
467  		if(caplen > p->snapshot)
468  			caplen = p->snapshot;
469  		if (p->break_loop)
470  		{
471  			if (n == 0)
472  			{
473  				p->break_loop = 0;
474  				return (-2);
475  			}
476  			else
477  			{
478  				p->bp = (char*)header;
479  				p->cc = endofbuf - (char*)header;
480  				return (n);
481  			}
482  		}
483  		if(!dfp)
484  		{
485  			ts = header->ts;
486  			pcap_header.ts.tv_sec = (int)(ts >> 32);
487  			ts = (ts & 0xffffffffi64) * 1000000;
488  			ts += 0x80000000; &bsol;* rounding */
489  			pcap_header.ts.tv_usec = (int)(ts >> 32);
490  			if (pcap_header.ts.tv_usec >= 1000000) {
491  				pcap_header.ts.tv_usec -= 1000000;
492  				pcap_header.ts.tv_sec++;
493  			}
494  		}
495  		if (p->fcode.bf_insns)
496  		{
497  			if (pcap_filter(p->fcode.bf_insns, dp, packet_len, caplen) == 0)
498  			{
499  				header = (dag_record_t*)((char*)header + erf_record_len);
500  				continue;
501  			}
502  		}
503  		pcap_header.caplen = caplen;
504  		pcap_header.len = packet_len;
505  		(*callback)(user, &pcap_header, dp);
506  		header = (dag_record_t*)((char*)header + erf_record_len);
507  		if (++n >= cnt && !PACKET_COUNT_IS_UNLIMITED(cnt))
508  		{
509  			p->bp = (char*)header;
510  			p->cc = endofbuf - (char*)header;
511  			return (n);
512  		}
513  	}
514  	while((u_char*)header < endofbuf);
515  	return (1);
516  }
517  #endif &bsol;* HAVE_DAG_API */
518  static int
519  pcap_inject_npf(pcap_t *p, const void *buf, int size)
520  {
521  	struct pcap_win *pw = p->priv;
522  	PACKET pkt;
523  	PacketInitPacket(&pkt, (PVOID)buf, size);
524  	if(PacketSendPacket(pw->adapter,&pkt,TRUE) == FALSE) {
525  		pcap_fmt_errmsg_for_win32_err(p->errbuf, PCAP_ERRBUF_SIZE,
526  		    GetLastError(), "send error: PacketSendPacket failed");
527  		return (-1);
528  	}
529  	return (size);
530  }
531  static void
532  pcap_cleanup_npf(pcap_t *p)
533  {
534  	struct pcap_win *pw = p->priv;
535  	if (pw->adapter != NULL) {
536  		PacketCloseAdapter(pw->adapter);
537  		pw->adapter = NULL;
538  	}
539  	if (pw->rfmon_selfstart)
540  	{
541  		PacketSetMonitorMode(p->opt.device, 0);
542  	}
543  	pcap_cleanup_live_common(p);
544  }
545  static void
546  pcap_breakloop_npf(pcap_t *p)
547  {
548  	pcap_breakloop_common(p);
549  	struct pcap_win *pw = p->priv;
550  	SetEvent(PacketGetReadEvent(pw->adapter));
551  }
552  static int
553  pcap_activate_npf(pcap_t *p)
554  {
555  	struct pcap_win *pw = p->priv;
556  	NetType type;
557  	int res;
558  	int status = 0;
559  	struct bpf_insn total_insn;
560  	struct bpf_program total_prog;
561  	if (p->opt.rfmon) {
562  		if (PacketGetMonitorMode(p->opt.device) == 1)
563  		{
564  			pw->rfmon_selfstart = 0;
565  		}
566  		else
567  		{
568  			if ((res = PacketSetMonitorMode(p->opt.device, 1)) != 1)
569  			{
570  				pw->rfmon_selfstart = 0;
571  				if (res == 0)
572  				{
573  					return PCAP_ERROR_RFMON_NOTSUP;
574  				}
575  				else
576  				{
577  					return PCAP_ERROR;
578  				}
579  			}
580  			else
581  			{
582  				pw->rfmon_selfstart = 1;
583  			}
584  		}
585  	}
586  	pcap_wsockinit();
587  	pw->adapter = PacketOpenAdapter(p->opt.device);
588  	if (pw->adapter == NULL)
589  	{
590  		DWORD errcode = GetLastError();
591  		switch (errcode) {
592  		case ERROR_BAD_UNIT:
593  			p->errbuf[0] = '\0';
594  			return (PCAP_ERROR_NO_SUCH_DEVICE);
595  		case ERROR_ACCESS_DENIED:
596  			snprintf(p->errbuf, PCAP_ERRBUF_SIZE,
597  			    "The helper program for \"Admin-only Mode\" must be allowed to make changes to your device");
598  			return (PCAP_ERROR_PERM_DENIED);
599  		default:
600  			pcap_fmt_errmsg_for_win32_err(p->errbuf, PCAP_ERRBUF_SIZE,
601  			    errcode, "Error opening adapter");
602  			if (pw->rfmon_selfstart)
603  			{
604  				PacketSetMonitorMode(p->opt.device, 0);
605  			}
606  			return (PCAP_ERROR);
607  		}
608  	}
609  	if(PacketGetNetType (pw->adapter,&type) == FALSE)
610  	{
611  		pcap_fmt_errmsg_for_win32_err(p->errbuf, PCAP_ERRBUF_SIZE,
612  		    GetLastError(), "Cannot determine the network type");
613  		goto bad;
614  	}
615  	switch (type.LinkType)
616  	{
617  	case NdisMedium802_3:
618  		p->linktype = DLT_EN10MB;
619  		p->dlt_list = (u_int *) malloc(sizeof(u_int) * 2);
620  		if (p->dlt_list == NULL)
621  		{
622  			pcap_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,
623  			    errno, "malloc");
624  			goto bad;
625  		}
626  		p->dlt_list[0] = DLT_EN10MB;
627  		p->dlt_list[1] = DLT_DOCSIS;
628  		p->dlt_count = 2;
629  		break;
630  	case NdisMedium802_5:
631  		p->linktype = DLT_IEEE802;
632  		break;
633  	case NdisMediumFddi:
634  		p->linktype = DLT_FDDI;
635  		break;
636  	case NdisMediumWan:
637  		p->linktype = DLT_EN10MB;
638  		break;
639  	case NdisMediumArcnetRaw:
640  		p->linktype = DLT_ARCNET;
641  		break;
642  	case NdisMediumArcnet878_2:
643  		p->linktype = DLT_ARCNET;
644  		break;
645  	case NdisMediumAtm:
646  		p->linktype = DLT_ATM_RFC1483;
647  		break;
648  	case NdisMediumWirelessWan:
649  		p->linktype = DLT_RAW;
650  		break;
651  	case NdisMediumIP:
652  		p->linktype = DLT_RAW;
653  		break;
654  	case NdisMediumNull:
655  		p->linktype = DLT_NULL;
656  		break;
657  	case NdisMediumCHDLC:
658  		p->linktype = DLT_CHDLC;
659  		break;
660  	case NdisMediumPPPSerial:
661  		p->linktype = DLT_PPP_SERIAL;
662  		break;
663  	case NdisMediumBare80211:
664  		p->linktype = DLT_IEEE802_11;
665  		break;
666  	case NdisMediumRadio80211:
667  		p->linktype = DLT_IEEE802_11_RADIO;
668  		break;
669  	case NdisMediumPpi:
670  		p->linktype = DLT_PPI;
671  		break;
672  	default:
673  		p->linktype = DLT_EN10MB;
674  		snprintf(p->errbuf, PCAP_ERRBUF_SIZE,
675  		    "Unknown NdisMedium value %d, defaulting to DLT_EN10MB",
676  		    type.LinkType);
677  		status = PCAP_WARNING;
678  		break;
679  	}
680  #ifdef HAVE_PACKET_GET_TIMESTAMP_MODES
681  	switch (p->opt.tstamp_type) {
682  	case PCAP_TSTAMP_HOST_HIPREC_UNSYNCED:
683  		if (!PacketSetTimestampMode(pw->adapter, TIMESTAMPMODE_SINGLE_SYNCHRONIZATION))
684  		{
685  			pcap_fmt_errmsg_for_win32_err(p->errbuf, PCAP_ERRBUF_SIZE,
686  			    GetLastError(), "Cannot set the time stamp mode to TIMESTAMPMODE_SINGLE_SYNCHRONIZATION");
687  			goto bad;
688  		}
689  		break;
690  	case PCAP_TSTAMP_HOST_LOWPREC:
691  		if (!PacketSetTimestampMode(pw->adapter, TIMESTAMPMODE_QUERYSYSTEMTIME))
692  		{
693  			pcap_fmt_errmsg_for_win32_err(p->errbuf, PCAP_ERRBUF_SIZE,
694  			    GetLastError(), "Cannot set the time stamp mode to TIMESTAMPMODE_QUERYSYSTEMTIME");
695  			goto bad;
696  		}
697  		break;
698  	case PCAP_TSTAMP_HOST_HIPREC:
699  		if (!PacketSetTimestampMode(pw->adapter, TIMESTAMPMODE_QUERYSYSTEMTIME_PRECISE))
700  		{
701  			pcap_fmt_errmsg_for_win32_err(p->errbuf, PCAP_ERRBUF_SIZE,
702  			    GetLastError(), "Cannot set the time stamp mode to TIMESTAMPMODE_QUERYSYSTEMTIME_PRECISE");
703  			goto bad;
704  		}
705  		break;
706  	case PCAP_TSTAMP_HOST:
707  		break;
708  	}
709  #endif &bsol;* HAVE_PACKET_GET_TIMESTAMP_MODES */
710  	if (p->snapshot <= 0 || p->snapshot > MAXIMUM_SNAPLEN)
711  		p->snapshot = MAXIMUM_SNAPLEN;
712  	if (p->opt.promisc)
713  	{
714  		if (PacketSetHwFilter(pw->adapter,NDIS_PACKET_TYPE_PROMISCUOUS) == FALSE)
715  		{
716  			DWORD errcode = GetLastError();
717  			if (errcode != ERROR_NOT_SUPPORTED &&
718  			    errcode != (NDIS_STATUS_NOT_SUPPORTED|NT_STATUS_CUSTOMER_DEFINED))
719  			{
720  				pcap_fmt_errmsg_for_win32_err(p->errbuf,
721  				    PCAP_ERRBUF_SIZE, errcode,
722  				    "failed to set hardware filter to promiscuous mode");
723  				goto bad;
724  			}
725  		}
726  	}
727  	else
728  	{
729  		if (PacketSetHwFilter(pw->adapter,
730  			NDIS_PACKET_TYPE_ALL_LOCAL |
731  			NDIS_PACKET_TYPE_DIRECTED |
732  			NDIS_PACKET_TYPE_BROADCAST |
733  			NDIS_PACKET_TYPE_MULTICAST) == FALSE)
734  		{
735  			DWORD errcode = GetLastError();
736  			if (errcode != (NDIS_STATUS_NOT_SUPPORTED|NT_STATUS_CUSTOMER_DEFINED))
737  			{
738  				pcap_fmt_errmsg_for_win32_err(p->errbuf,
739  				    PCAP_ERRBUF_SIZE, errcode,
740  				    "failed to set hardware filter to non-promiscuous mode");
741  				goto bad;
742  			}
743  		}
744  	}
745  	p->bufsize = WIN32_DEFAULT_USER_BUFFER_SIZE;
746  	if(!(pw->adapter->Flags & INFO_FLAG_DAG_CARD))
747  	{
748  		if (p->opt.buffer_size == 0)
749  			p->opt.buffer_size = WIN32_DEFAULT_KERNEL_BUFFER_SIZE;
750  		if(PacketSetBuff(pw->adapter,p->opt.buffer_size)==FALSE)
751  		{
752  			snprintf(p->errbuf, PCAP_ERRBUF_SIZE, "driver error: not enough memory to allocate the kernel buffer");
753  			goto bad;
754  		}
755  		p->buffer = malloc(p->bufsize);
756  		if (p->buffer == NULL)
757  		{
758  			pcap_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,
759  			    errno, "malloc");
760  			goto bad;
761  		}
762  		if (p->opt.immediate)
763  		{
764  			if(PacketSetMinToCopy(pw->adapter,0)==FALSE)
765  			{
766  				pcap_fmt_errmsg_for_win32_err(p->errbuf,
767  				    PCAP_ERRBUF_SIZE, GetLastError(),
768  				    "Error calling PacketSetMinToCopy");
769  				goto bad;
770  			}
771  		}
772  		else
773  		{
774  			if(PacketSetMinToCopy(pw->adapter,16000)==FALSE)
775  			{
776  				pcap_fmt_errmsg_for_win32_err(p->errbuf,
777  				    PCAP_ERRBUF_SIZE, GetLastError(),
778  				    "Error calling PacketSetMinToCopy");
779  				goto bad;
780  			}
781  		}
782  	} else {
783  #ifdef HAVE_DAG_API
784  		LONG	status;
785  		HKEY	dagkey;
786  		DWORD	lptype;
787  		DWORD	lpcbdata;
788  		int		postype = 0;
789  		char	keyname[512];
790  		snprintf(keyname, sizeof(keyname), "%s\\CardParams\\%s",
791  			"SYSTEM\\CurrentControlSet\\Services\\DAG",
792  			strstr(_strlwr(p->opt.device), "dag"));
793  		do
794  		{
795  			status = RegOpenKeyEx(HKEY_LOCAL_MACHINE, keyname, 0, KEY_READ, &dagkey);
796  			if(status != ERROR_SUCCESS)
797  				break;
798  			status = RegQueryValueEx(dagkey,
799  				"PosType",
800  				NULL,
801  				&lptype,
802  				(char*)&postype,
803  				&lpcbdata);
804  			if(status != ERROR_SUCCESS)
805  			{
806  				postype = 0;
807  			}
808  			RegCloseKey(dagkey);
809  		}
810  		while(FALSE);
811  		p->snapshot = PacketSetSnapLen(pw->adapter, p->snapshot);
812  		pw->dag_fcs_bits = pw->adapter->DagFcsLen;
813  #else &bsol;* HAVE_DAG_API */
814  		goto bad;
815  #endif &bsol;* HAVE_DAG_API */
816  	}
817  	total_insn.code = (u_short)(BPF_RET | BPF_K);
818  	total_insn.jt = 0;
819  	total_insn.jf = 0;
820  	total_insn.k = p->snapshot;
821  	total_prog.bf_len = 1;
822  	total_prog.bf_insns = &total_insn;
823  	if (!PacketSetBpf(pw->adapter, &total_prog)) {
824  		pcap_fmt_errmsg_for_win32_err(p->errbuf, PCAP_ERRBUF_SIZE,
825  		    GetLastError(), "PacketSetBpf");
826  		status = PCAP_ERROR;
827  		goto bad;
828  	}
829  	PacketSetReadTimeout(pw->adapter, p->opt.timeout);
830  	if (p->opt.nocapture_local)
831  	{
832  		if (!PacketSetLoopbackBehavior(pw->adapter, NPF_DISABLE_LOOPBACK))
833  		{
834  			snprintf(p->errbuf, PCAP_ERRBUF_SIZE,
835  			    "Unable to disable the capture of loopback packets.");
836  			goto bad;
837  		}
838  	}
839  #ifdef HAVE_DAG_API
840  	if(pw->adapter->Flags & INFO_FLAG_DAG_CARD)
841  	{
842  		p->read_op = pcap_read_win32_dag;
843  		p->setfilter_op = pcap_setfilter_win32_dag;
844  	}
845  	else
846  	{
847  #endif &bsol;* HAVE_DAG_API */
848  		p->read_op = pcap_read_npf;
849  		p->setfilter_op = pcap_setfilter_npf;
850  #ifdef HAVE_DAG_API
851  	}
852  #endif &bsol;* HAVE_DAG_API */
853  	p->setdirection_op = NULL;	&bsol;* Not implemented. */
854  	p->inject_op = pcap_inject_npf;
855  	p->set_datalink_op = NULL;	&bsol;* can't change data link type */
856  	p->getnonblock_op = pcap_getnonblock_npf;
857  	p->setnonblock_op = pcap_setnonblock_npf;
858  	p->stats_op = pcap_stats_npf;
859  	p->breakloop_op = pcap_breakloop_npf;
860  	p->stats_ex_op = pcap_stats_ex_npf;
861  	p->setbuff_op = pcap_setbuff_npf;
862  	p->setmode_op = pcap_setmode_npf;
863  	p->setmintocopy_op = pcap_setmintocopy_npf;
864  	p->getevent_op = pcap_getevent_npf;
865  	p->oid_get_request_op = pcap_oid_get_request_npf;
866  	p->oid_set_request_op = pcap_oid_set_request_npf;
867  	p->sendqueue_transmit_op = pcap_sendqueue_transmit_npf;
868  	p->setuserbuffer_op = pcap_setuserbuffer_npf;
869  	p->live_dump_op = pcap_live_dump_npf;
870  	p->live_dump_ended_op = pcap_live_dump_ended_npf;
871  	p->get_airpcap_handle_op = pcap_get_airpcap_handle_npf;
872  	p->cleanup_op = pcap_cleanup_npf;
873  	p->handle = pw->adapter->hFile;
874  	return (status);
875  bad:
876  	pcap_cleanup_npf(p);
877  	return (PCAP_ERROR);
878  }
879  static int
880  pcap_can_set_rfmon_npf(pcap_t *p)
881  {
882  	return (PacketIsMonitorModeSupported(p->opt.device) == 1);
883  }
884  #ifdef HAVE_PACKET_GET_TIMESTAMP_MODES
885  static int
886  get_ts_types(const char *device, pcap_t *p, char *ebuf)
887  {
888  	char *device_copy = NULL;
889  	ADAPTER *adapter = NULL;
890  	ULONG num_ts_modes;
891  	ULONG ts_modes[4];
892  	BOOL ret;
893  	DWORD error = ERROR_SUCCESS;
894  	ULONG *modes = NULL;
895  	int status = 0;
896  	do {
897  		device_copy = strdup(device);
898  		if (device_copy == NULL) {
899  			pcap_fmt_errmsg_for_errno(ebuf, PCAP_ERRBUF_SIZE, errno, "malloc");
900  			status = -1;
901  			break;
902  		}
903  		adapter = PacketOpenAdapter(device_copy);
904  		if (adapter == NULL)
905  		{
906  			error = GetLastError();
907  			if (error == ERROR_BAD_UNIT ||
908  			    error == ERROR_ACCESS_DENIED) {
909  				p->tstamp_type_count = 0;
910  				p->tstamp_type_list = NULL;
911  				status = 0;
912  			} else {
913  				pcap_fmt_errmsg_for_win32_err(ebuf,
914  				    PCAP_ERRBUF_SIZE, error,
915  				    "Error opening adapter");
916  				status = -1;
917  			}
918  			break;
919  		}
920  		ts_modes[0] = sizeof(ts_modes) / sizeof(ULONG);
921  		ret = PacketGetTimestampModes(adapter, ts_modes);
922  		if (!ret) {
923  			error = GetLastError();
924  			if (error != ERROR_MORE_DATA) {
925  				if (error == ERROR_INVALID_FUNCTION) {
926  					snprintf(ebuf, PCAP_ERRBUF_SIZE,
927  					    "PacketGetTimestampModes() failed with ERROR_INVALID_FUNCTION; try uninstalling Npcap, and WinPcap if installed, and re-installing it from npcap.com");
928  					status = -1;
929  					break;
930  				}
931  				pcap_fmt_errmsg_for_win32_err(ebuf,
932  				    PCAP_ERRBUF_SIZE, error,
933  				    "Error calling PacketGetTimestampModes");
934  				status = -1;
935  				break;
936  			}
937  			num_ts_modes = ts_modes[0];
938  			modes = (ULONG *)malloc((1 + num_ts_modes) * sizeof(ULONG));
939  			if (modes == NULL) {
940  				pcap_fmt_errmsg_for_errno(ebuf, PCAP_ERRBUF_SIZE, errno, "malloc");
941  				status = -1;
942  				break;
943  			}
944  			modes[0] = 1 + num_ts_modes;
945  			if (!PacketGetTimestampModes(adapter, modes)) {
946  				pcap_fmt_errmsg_for_win32_err(ebuf,
947  						PCAP_ERRBUF_SIZE, GetLastError(),
948  						"Error calling PacketGetTimestampModes");
949  				status = -1;
950  				break;
951  			}
952  			if (modes[0] != num_ts_modes) {
953  				snprintf(ebuf, PCAP_ERRBUF_SIZE,
954  						"First PacketGetTimestampModes() call gives %lu modes, second call gives %lu modes",
955  						num_ts_modes, modes[0]);
956  				status = -1;
957  				break;
958  			}
959  		}
960  		else {
961  			modes = ts_modes;
962  			num_ts_modes = ts_modes[0];
963  		}
964  		if (modes[0] == 0) {
965  			snprintf(ebuf, PCAP_ERRBUF_SIZE,
966  			    "PacketGetTimestampModes() reports 0 modes supported.");
967  			status = -1;
968  			break;
969  		}
970  		p->tstamp_type_list = malloc((1 + num_ts_modes) * sizeof(u_int));
971  		if (p->tstamp_type_list == NULL) {
972  			pcap_fmt_errmsg_for_errno(ebuf, PCAP_ERRBUF_SIZE, errno, "malloc");
973  			status = -1;
974  			break;
975  		}
976  		u_int num_ts_types = 0;
977  		p->tstamp_type_list[num_ts_types] =
978  		    PCAP_TSTAMP_HOST;
979  		num_ts_types++;
980  		for (ULONG i = 0; i < num_ts_modes; i++) {
981  			switch (modes[i + 1]) {
982  			case TIMESTAMPMODE_SINGLE_SYNCHRONIZATION:
983  				p->tstamp_type_list[num_ts_types] =
984  				    PCAP_TSTAMP_HOST_HIPREC_UNSYNCED;
985  				num_ts_types++;
986  				break;
987  			case TIMESTAMPMODE_QUERYSYSTEMTIME:
988  				p->tstamp_type_list[num_ts_types] =
989  				    PCAP_TSTAMP_HOST_LOWPREC;
990  				num_ts_types++;
991  				break;
992  			case TIMESTAMPMODE_QUERYSYSTEMTIME_PRECISE:
993  				p->tstamp_type_list[num_ts_types] =
994  				    PCAP_TSTAMP_HOST_HIPREC;
995  				num_ts_types++;
996  				break;
997  			default:
998  				break;
999  			}
1000  		}
1001  		p->tstamp_type_count = num_ts_types;
1002  	} while (0);
1003  	if (device_copy != NULL) {
1004  		free(device_copy);
1005  	}
1006  	if (modes != NULL && modes != ts_modes) {
1007  		free(modes);
1008  	}
1009  	if (adapter != NULL) {
1010  		PacketCloseAdapter(adapter);
1011  	}
1012  	return status;
1013  }
1014  #else &bsol;* HAVE_PACKET_GET_TIMESTAMP_MODES */
1015  static int
1016  get_ts_types(const char *device _U_, pcap_t *p _U_, char *ebuf _U_)
1017  {
1018  	return 0;
1019  }
1020  #endif &bsol;* HAVE_PACKET_GET_TIMESTAMP_MODES */
1021  pcap_t *
1022  pcap_create_interface(const char *device _U_, char *ebuf)
1023  {
1024  	pcap_t *p;
1025  	p = PCAP_CREATE_COMMON(ebuf, struct pcap_win);
1026  	if (p == NULL)
1027  		return (NULL);
1028  	p->activate_op = pcap_activate_npf;
1029  	p->can_set_rfmon_op = pcap_can_set_rfmon_npf;
1030  	if (get_ts_types(device, p, ebuf) == -1) {
1031  		pcap_close(p);
1032  		return (NULL);
1033  	}
1034  	return (p);
1035  }
1036  static int
1037  pcap_setfilter_npf(pcap_t *p, struct bpf_program *fp)
1038  {
1039  	struct pcap_win *pw = p->priv;
1040  	if(PacketSetBpf(pw->adapter,fp)==FALSE){
1041  		if (pcap_install_bpf_program(p, fp) < 0)
1042  			return (-1);
1043  		pw->filtering_in_kernel = 0;	&bsol;* filtering in userland */
1044  		return (0);
1045  	}
1046  	pw->filtering_in_kernel = 1;	&bsol;* filtering in the kernel */
1047  	p->cc = 0;
1048  	return (0);
1049  }
1050  static int
1051  pcap_setfilter_win32_dag(pcap_t *p, struct bpf_program *fp) {
1052  	if(!fp)
1053  	{
1054  		pcap_strlcpy(p->errbuf, "setfilter: No filter specified", sizeof(p->errbuf));
1055  		return (-1);
1056  	}
1057  	if (pcap_install_bpf_program(p, fp) < 0)
1058  		return (-1);
1059  	return (0);
1060  }
1061  static int
1062  pcap_getnonblock_npf(pcap_t *p)
1063  {
1064  	struct pcap_win *pw = p->priv;
1065  	return (pw->nonblock);
1066  }
1067  static int
1068  pcap_setnonblock_npf(pcap_t *p, int nonblock)
1069  {
1070  	struct pcap_win *pw = p->priv;
1071  	int newtimeout;
1072  	if (nonblock) {
1073  		newtimeout = -1;
1074  	} else {
1075  		newtimeout = p->opt.timeout;
1076  	}
1077  	if (!PacketSetReadTimeout(pw->adapter, newtimeout)) {
1078  		pcap_fmt_errmsg_for_win32_err(p->errbuf, PCAP_ERRBUF_SIZE,
1079  		    GetLastError(), "PacketSetReadTimeout");
1080  		return (-1);
1081  	}
1082  	pw->nonblock = (newtimeout == -1);
1083  	return (0);
1084  }
1085  static int
1086  pcap_add_if_npf(pcap_if_list_t *devlistp, char *name, bpf_u_int32 flags,
1087      const char *description, char *errbuf)
1088  {
1089  	pcap_if_t *curdev;
1090  	npf_if_addr if_addrs[MAX_NETWORK_ADDRESSES];
1091  	LONG if_addr_size;
1092  	int res = 0;
1093  	if_addr_size = MAX_NETWORK_ADDRESSES;
1094  	curdev = pcap_add_dev(devlistp, name, flags, description, errbuf);
1095  	if (curdev == NULL) {
1096  		return (-1);
1097  	}
1098  	if (!PacketGetNetInfoEx((void *)name, if_addrs, &if_addr_size)) {
1099  		return (0);
1100  	}
1101  	while (if_addr_size-- > 0) {
1102  		res = pcap_add_addr_to_dev(curdev,
1103  		    (struct sockaddr *)&if_addrs[if_addr_size].IPAddress,
1104  		    sizeof (struct sockaddr_storage),
1105  		    (struct sockaddr *)&if_addrs[if_addr_size].SubnetMask,
1106  		    sizeof (struct sockaddr_storage),
1107  		    (struct sockaddr *)&if_addrs[if_addr_size].Broadcast,
1108  		    sizeof (struct sockaddr_storage),
1109  		    NULL,
1110  		    0,
1111  		    errbuf);
1112  		if (res == -1) {
1113  			break;
1114  		}
1115  	}
1116  	return (res);
1117  }
1118  static int
1119  get_if_flags(const char *name, bpf_u_int32 *flags, char *errbuf)
1120  {
1121  	char *name_copy;
1122  	ADAPTER *adapter;
1123  	int status;
1124  	size_t len;
1125  	NDIS_HARDWARE_STATUS hardware_status;
1126  #ifdef OID_GEN_PHYSICAL_MEDIUM
1127  	NDIS_PHYSICAL_MEDIUM phys_medium;
1128  	bpf_u_int32 gen_physical_medium_oids[] = {
1129    #ifdef OID_GEN_PHYSICAL_MEDIUM_EX
1130  		OID_GEN_PHYSICAL_MEDIUM_EX,
1131    #endif
1132  		OID_GEN_PHYSICAL_MEDIUM
1133  	};
1134  #define N_GEN_PHYSICAL_MEDIUM_OIDS	(sizeof gen_physical_medium_oids / sizeof gen_physical_medium_oids[0])
1135  	size_t i;
1136  #endif &bsol;* OID_GEN_PHYSICAL_MEDIUM */
1137  #ifdef OID_GEN_LINK_STATE
1138  	NDIS_LINK_STATE link_state;
1139  #endif
1140  	int connect_status;
1141  	if (*flags & PCAP_IF_LOOPBACK) {
1142  		*flags |= PCAP_IF_UP | PCAP_IF_RUNNING | PCAP_IF_CONNECTION_STATUS_NOT_APPLICABLE;
1143  		return (0);
1144  	}
1145  	name_copy = strdup(name);
1146  	adapter = PacketOpenAdapter(name_copy);
1147  	free(name_copy);
1148  	if (adapter == NULL) {
1149  		return (0);
1150  	}
1151  #ifdef HAVE_AIRPCAP_API
1152  	if (PacketGetAirPcapHandle(adapter)) {
1153  		*flags = PCAP_IF_UP | PCAP_IF_RUNNING;
1154  		*flags |= PCAP_IF_WIRELESS;
1155  		*flags |= PCAP_IF_CONNECTION_STATUS_NOT_APPLICABLE;
1156  		PacketCloseAdapter(adapter);
1157  		return (0);
1158  	}
1159  #endif
1160  	len = sizeof (hardware_status);
1161  	status = oid_get_request(adapter, OID_GEN_HARDWARE_STATUS,
1162  	    &hardware_status, &len, errbuf);
1163  	if (status == 0) {
1164  		switch (hardware_status) {
1165  		case NdisHardwareStatusReady:
1166  			*flags |= PCAP_IF_UP | PCAP_IF_RUNNING;
1167  			break;
1168  		case NdisHardwareStatusInitializing:
1169  		case NdisHardwareStatusReset:
1170  			*flags |= PCAP_IF_UP;
1171  			break;
1172  		case NdisHardwareStatusClosing:
1173  		case NdisHardwareStatusNotReady:
1174  			break;
1175  		default:
1176  			break;
1177  		}
1178  	} else {
1179  		*flags |= PCAP_IF_UP | PCAP_IF_RUNNING;
1180  	}
1181  #ifdef OID_GEN_PHYSICAL_MEDIUM
1182  	for (i = 0; i < N_GEN_PHYSICAL_MEDIUM_OIDS; i++) {
1183  		len = sizeof (phys_medium);
1184  		status = oid_get_request(adapter, gen_physical_medium_oids[i],
1185  		    &phys_medium, &len, errbuf);
1186  		if (status == 0) {
1187  			break;
1188  		}
1189  	}
1190  	if (status == 0) {
1191  DIAG_OFF_ENUM_SWITCH
1192  		switch (phys_medium) {
1193  		case NdisPhysicalMediumWirelessLan:
1194  		case NdisPhysicalMediumWirelessWan:
1195  		case NdisPhysicalMediumNative802_11:
1196  		case NdisPhysicalMediumBluetooth:
1197  		case NdisPhysicalMediumUWB:
1198  		case NdisPhysicalMediumIrda:
1199  			*flags |= PCAP_IF_WIRELESS;
1200  			break;
1201  		default:
1202  			break;
1203  		}
1204  DIAG_ON_ENUM_SWITCH
1205  	}
1206  #endif
1207  #ifdef OID_GEN_LINK_STATE
1208  	len = sizeof(link_state);
1209  	status = oid_get_request(adapter, OID_GEN_LINK_STATE, &link_state,
1210  	    &len, errbuf);
1211  	if (status == 0) {
1212  		switch (link_state.MediaConnectState) {
1213  		case MediaConnectStateConnected:
1214  			*flags |= PCAP_IF_CONNECTION_STATUS_CONNECTED;
1215  			break;
1216  		case MediaConnectStateDisconnected:
1217  			*flags |= PCAP_IF_CONNECTION_STATUS_DISCONNECTED;
1218  			break;
1219  		case MediaConnectStateUnknown:
1220  		default:
1221  			break;
1222  		}
1223  	}
1224  #else
1225  	status = -1;
1226  #endif
1227  	if (status == -1) {
1228  		status = oid_get_request(adapter, OID_GEN_MEDIA_CONNECT_STATUS,
1229  		    &connect_status, &len, errbuf);
1230  		if (status == 0) {
1231  			switch (connect_status) {
1232  			case NdisMediaStateConnected:
1233  				*flags |= PCAP_IF_CONNECTION_STATUS_CONNECTED;
1234  				break;
1235  			case NdisMediaStateDisconnected:
1236  				*flags |= PCAP_IF_CONNECTION_STATUS_DISCONNECTED;
1237  				break;
1238  			}
1239  		}
1240  	}
1241  	PacketCloseAdapter(adapter);
1242  	return (0);
1243  }
1244  int
1245  pcap_platform_finddevs(pcap_if_list_t *devlistp, char *errbuf)
1246  {
1247  	int ret = 0;
1248  	const char *desc;
1249  	char *AdaptersName;
1250  	ULONG NameLength;
1251  	char *name;
1252  	NameLength = 0;
1253  	if (!PacketGetAdapterNames(NULL, &NameLength))
1254  	{
1255  		DWORD last_error = GetLastError();
1256  		if (last_error != ERROR_INSUFFICIENT_BUFFER)
1257  		{
1258  			pcap_fmt_errmsg_for_win32_err(errbuf, PCAP_ERRBUF_SIZE,
1259  			    last_error, "PacketGetAdapterNames");
1260  			return (-1);
1261  		}
1262  	}
1263  	if (NameLength <= 0)
1264  		return 0;
1265  	AdaptersName = (char*) malloc(NameLength);
1266  	if (AdaptersName == NULL)
1267  	{
1268  		snprintf(errbuf, PCAP_ERRBUF_SIZE, "Cannot allocate enough memory to list the adapters.");
1269  		return (-1);
1270  	}
1271  	if (!PacketGetAdapterNames(AdaptersName, &NameLength)) {
1272  		pcap_fmt_errmsg_for_win32_err(errbuf, PCAP_ERRBUF_SIZE,
1273  		    GetLastError(), "PacketGetAdapterNames");
1274  		free(AdaptersName);
1275  		return (-1);
1276  	}
1277  	desc = &AdaptersName[0];
1278  	while (*desc != '\0' || *(desc + 1) != '\0')
1279  		desc++;
1280  	desc += 2;
1281  	name = &AdaptersName[0];
1282  	while (*name != '\0') {
1283  		bpf_u_int32 flags = 0;
1284  #ifdef HAVE_AIRPCAP_API
1285  		if (device_is_airpcap(name, errbuf) == 1) {
1286  			name += strlen(name) + 1;
1287  			desc += strlen(desc) + 1;
1288  			continue;
1289  		}
1290  #endif
1291  #ifdef HAVE_PACKET_IS_LOOPBACK_ADAPTER
1292  		if (PacketIsLoopbackAdapter(name)) {
1293  			flags |= PCAP_IF_LOOPBACK;
1294  		}
1295  #endif
1296  		if (get_if_flags(name, &flags, errbuf) == -1) {
1297  			ret = -1;
1298  			break;
1299  		}
1300  		if (pcap_add_if_npf(devlistp, name, flags, desc,
1301  		    errbuf) == -1) {
1302  			ret = -1;
1303  			break;
1304  		}
1305  		name += strlen(name) + 1;
1306  		desc += strlen(desc) + 1;
1307  	}
1308  	free(AdaptersName);
1309  	return (ret);
1310  }
1311  #define ADAPTERSNAME_LEN	8192
1312  char *
1313  pcap_lookupdev(char *errbuf)
1314  {
1315  	DWORD dwVersion;
1316  	DWORD dwWindowsMajorVersion;
1317  	if (pcap_new_api) {
1318  		snprintf(errbuf, PCAP_ERRBUF_SIZE,
1319  		    "pcap_lookupdev() is deprecated and is not supported in programs calling pcap_init()");
1320  		return (NULL);
1321  	}
1322  DIAG_OFF_DEPRECATION
1323  	dwVersion = GetVersion();	&bsol;* get the OS version */
1324  DIAG_ON_DEPRECATION
1325  	dwWindowsMajorVersion = (DWORD)(LOBYTE(LOWORD(dwVersion)));
1326  	if (dwVersion >= 0x80000000 && dwWindowsMajorVersion >= 4) {
1327  		ULONG NameLength = ADAPTERSNAME_LEN;
1328  		static char AdaptersName[ADAPTERSNAME_LEN];
1329  		if (PacketGetAdapterNames(AdaptersName,&NameLength) )
1330  			return (AdaptersName);
1331  		else
1332  			return NULL;
1333  	} else {
1334  		ULONG NameLength = ADAPTERSNAME_LEN;
1335  		static WCHAR AdaptersName[ADAPTERSNAME_LEN];
1336  		size_t BufferSpaceLeft;
1337  		char *tAstr;
1338  		WCHAR *Unameptr;
1339  		char *Adescptr;
1340  		size_t namelen, i;
1341  		WCHAR *TAdaptersName = (WCHAR*)malloc(ADAPTERSNAME_LEN * sizeof(WCHAR));
1342  		int NAdapts = 0;
1343  		if(TAdaptersName == NULL)
1344  		{
1345  			(void)snprintf(errbuf, PCAP_ERRBUF_SIZE, "memory allocation failure");
1346  			return NULL;
1347  		}
1348  		if ( !PacketGetAdapterNames((PTSTR)TAdaptersName,&NameLength) )
1349  		{
1350  			pcap_fmt_errmsg_for_win32_err(errbuf, PCAP_ERRBUF_SIZE,
1351  			    GetLastError(), "PacketGetAdapterNames");
1352  			free(TAdaptersName);
1353  			return NULL;
1354  		}
1355  		BufferSpaceLeft = ADAPTERSNAME_LEN * sizeof(WCHAR);
1356  		tAstr = (char*)TAdaptersName;
1357  		Unameptr = AdaptersName;
1358  		do {
1359  			namelen = strlen(tAstr) + 1;
1360  			if (BufferSpaceLeft < namelen * sizeof(WCHAR)) {
1361  				goto quit;
1362  			}
1363  			BufferSpaceLeft -= namelen * sizeof(WCHAR);
1364  			for (i = 0; i < namelen; i++)
1365  				*Unameptr++ = *tAstr++;
1366  			NAdapts++;
1367  		} while (namelen != 1);
1368  		Adescptr = (char *)Unameptr;
1369  		while(NAdapts--)
1370  		{
1371  			size_t desclen;
1372  			desclen = strlen(tAstr) + 1;
1373  			if (BufferSpaceLeft < desclen) {
1374  				goto quit;
1375  			}
1376  			memcpy(Adescptr, tAstr, desclen);
1377  			Adescptr += desclen;
1378  			tAstr += desclen;
1379  			BufferSpaceLeft -= desclen;
1380  		}
1381  	quit:
1382  		free(TAdaptersName);
1383  		return (char *)(AdaptersName);
1384  	}
1385  }
1386  int
1387  pcap_lookupnet(const char *device, bpf_u_int32 *netp, bpf_u_int32 *maskp,
1388      char *errbuf)
1389  {
1390  	npf_if_addr if_addrs[MAX_NETWORK_ADDRESSES];
1391  	LONG if_addr_size = MAX_NETWORK_ADDRESSES;
1392  	struct sockaddr_in *t_addr;
1393  	LONG i;
1394  	if (!PacketGetNetInfoEx((void *)device, if_addrs, &if_addr_size)) {
1395  		*netp = *maskp = 0;
1396  		return (0);
1397  	}
1398  	for(i = 0; i < if_addr_size; i++)
1399  	{
1400  		if(if_addrs[i].IPAddress.ss_family == AF_INET)
1401  		{
1402  			t_addr = (struct sockaddr_in *) &(if_addrs[i].IPAddress);
1403  			*netp = t_addr->sin_addr.S_un.S_addr;
1404  			t_addr = (struct sockaddr_in *) &(if_addrs[i].SubnetMask);
1405  			*maskp = t_addr->sin_addr.S_un.S_addr;
1406  			*netp &= *maskp;
1407  			return (0);
1408  		}
1409  	}
1410  	*netp = *maskp = 0;
1411  	return (0);
1412  }
1413  static const char *pcap_lib_version_string;
1414  #ifdef HAVE_VERSION_H
1415  #include "../../version.h"
1416  static const char pcap_version_string[] =
1417  	WINPCAP_PRODUCT_NAME " version " WINPCAP_VER_STRING ", based on " PCAP_VERSION_STRING;
1418  const char *
1419  pcap_lib_version(void)
1420  {
1421  	if (pcap_lib_version_string == NULL) {
1422  		const char *packet_version_string = PacketGetVersion();
1423  		if (strcmp(WINPCAP_VER_STRING, packet_version_string) == 0) {
1424  			pcap_lib_version_string = pcap_version_string;
1425  		} else {
1426  			char *full_pcap_version_string;
1427  			if (pcap_asprintf(&full_pcap_version_string,
1428  			    WINPCAP_PRODUCT_NAME " version " WINPCAP_VER_STRING " (packet.dll version %s), based on " PCAP_VERSION_STRING,
1429  			    packet_version_string) != -1) {
1430  				pcap_lib_version_string = full_pcap_version_string;
1431  			}
1432  		}
1433  	}
1434  	return (pcap_lib_version_string);
1435  }
1436  #else &bsol;* HAVE_VERSION_H */
1437  const char *
1438  pcap_lib_version(void)
1439  {
1440  	if (pcap_lib_version_string == NULL) {
1441  		char *full_pcap_version_string;
1442  		if (pcap_asprintf(&full_pcap_version_string,
1443  		    PCAP_VERSION_STRING " (packet.dll version %s)",
1444  		    PacketGetVersion()) != -1) {
1445  			pcap_lib_version_string = full_pcap_version_string;
1446  		}
1447  	}
1448  	return (pcap_lib_version_string);
1449  }
1450  #endif &bsol;* HAVE_VERSION_H */
</code></pre>
        </div>
        <div class="column">
            <h3>libpcap-MDEwOlJlcG9zaXRvcnk5NDM1ODg3-flat-pcap-airpcap.c</h3>
            <pre><code>1  #ifdef HAVE_CONFIG_H
2  #include <config.h>
3  #endif
4  #include "pcap-int.h"
5  #include <airpcap.h>
6  #include "pcap-airpcap.h"
7  #define	AIRPCAP_DEFAULT_USER_BUFFER_SIZE 256000
8  #define	AIRPCAP_DEFAULT_KERNEL_BUFFER_SIZE 1000000
9  static pcap_code_handle_t airpcap_lib;
10  typedef PCHAR (*AirpcapGetLastErrorHandler)(PAirpcapHandle);
11  typedef BOOL (*AirpcapGetDeviceListHandler)(PAirpcapDeviceDescription *, PCHAR);
12  typedef VOID (*AirpcapFreeDeviceListHandler)(PAirpcapDeviceDescription);
13  typedef PAirpcapHandle (*AirpcapOpenHandler)(PCHAR, PCHAR);
14  typedef VOID (*AirpcapCloseHandler)(PAirpcapHandle);
15  typedef BOOL (*AirpcapSetDeviceMacFlagsHandler)(PAirpcapHandle, UINT);
16  typedef BOOL (*AirpcapSetLinkTypeHandler)(PAirpcapHandle, AirpcapLinkType);
17  typedef BOOL (*AirpcapGetLinkTypeHandler)(PAirpcapHandle, PAirpcapLinkType);
18  typedef BOOL (*AirpcapSetKernelBufferHandler)(PAirpcapHandle, UINT);
19  typedef BOOL (*AirpcapSetFilterHandler)(PAirpcapHandle, PVOID, UINT);
20  typedef BOOL (*AirpcapSetMinToCopyHandler)(PAirpcapHandle, UINT);
21  typedef BOOL (*AirpcapGetReadEventHandler)(PAirpcapHandle, HANDLE *);
22  typedef BOOL (*AirpcapReadHandler)(PAirpcapHandle, PBYTE, UINT, PUINT);
23  typedef BOOL (*AirpcapWriteHandler)(PAirpcapHandle, PCHAR, ULONG);
24  typedef BOOL (*AirpcapGetStatsHandler)(PAirpcapHandle, PAirpcapStats);
25  static AirpcapGetLastErrorHandler p_AirpcapGetLastError;
26  static AirpcapGetDeviceListHandler p_AirpcapGetDeviceList;
27  static AirpcapFreeDeviceListHandler p_AirpcapFreeDeviceList;
28  static AirpcapOpenHandler p_AirpcapOpen;
29  static AirpcapCloseHandler p_AirpcapClose;
30  static AirpcapSetDeviceMacFlagsHandler p_AirpcapSetDeviceMacFlags;
31  static AirpcapSetLinkTypeHandler p_AirpcapSetLinkType;
32  static AirpcapGetLinkTypeHandler p_AirpcapGetLinkType;
33  static AirpcapSetKernelBufferHandler p_AirpcapSetKernelBuffer;
34  static AirpcapSetFilterHandler p_AirpcapSetFilter;
35  static AirpcapSetMinToCopyHandler p_AirpcapSetMinToCopy;
36  static AirpcapGetReadEventHandler p_AirpcapGetReadEvent;
37  static AirpcapReadHandler p_AirpcapRead;
38  static AirpcapWriteHandler p_AirpcapWrite;
39  static AirpcapGetStatsHandler p_AirpcapGetStats;
40  typedef enum LONG
41  {
42  	AIRPCAP_API_UNLOADED = 0,
43  	AIRPCAP_API_LOADED,
44  	AIRPCAP_API_CANNOT_LOAD,
45  	AIRPCAP_API_LOADING
46  } AIRPCAP_API_LOAD_STATUS;
47  static AIRPCAP_API_LOAD_STATUS	airpcap_load_status;
48  static AIRPCAP_API_LOAD_STATUS
49  load_airpcap_functions(void)
50  {
51  	AIRPCAP_API_LOAD_STATUS current_status;
52  	current_status = InterlockedCompareExchange((LONG *)&airpcap_load_status,
53  	    AIRPCAP_API_LOADING, AIRPCAP_API_UNLOADED);
54  	while (current_status == AIRPCAP_API_LOADING) {
55  		current_status = InterlockedCompareExchange((LONG*)&airpcap_load_status,
56  		    AIRPCAP_API_LOADING, AIRPCAP_API_LOADING);
57  		Sleep(10);
58  	}
59  	if (current_status == AIRPCAP_API_LOADED)
60  		return AIRPCAP_API_LOADED;
61  	if (current_status == AIRPCAP_API_CANNOT_LOAD)
62  		return AIRPCAP_API_CANNOT_LOAD;
63  	current_status = AIRPCAP_API_CANNOT_LOAD;
64  	airpcap_lib = pcap_load_code("airpcap.dll");
65  	if (airpcap_lib != NULL) {
66  		p_AirpcapGetLastError = (AirpcapGetLastErrorHandler) pcap_find_function(airpcap_lib, "AirpcapGetLastError");
67  		p_AirpcapGetDeviceList = (AirpcapGetDeviceListHandler) pcap_find_function(airpcap_lib, "AirpcapGetDeviceList");
68  		p_AirpcapFreeDeviceList = (AirpcapFreeDeviceListHandler) pcap_find_function(airpcap_lib, "AirpcapFreeDeviceList");
69  		p_AirpcapOpen = (AirpcapOpenHandler) pcap_find_function(airpcap_lib, "AirpcapOpen");
70  		p_AirpcapClose = (AirpcapCloseHandler) pcap_find_function(airpcap_lib, "AirpcapClose");
71  		p_AirpcapSetDeviceMacFlags = (AirpcapSetDeviceMacFlagsHandler) pcap_find_function(airpcap_lib, "AirpcapSetDeviceMacFlags");
72  		p_AirpcapSetLinkType = (AirpcapSetLinkTypeHandler) pcap_find_function(airpcap_lib, "AirpcapSetLinkType");
73  		p_AirpcapGetLinkType = (AirpcapGetLinkTypeHandler) pcap_find_function(airpcap_lib, "AirpcapGetLinkType");
74  		p_AirpcapSetKernelBuffer = (AirpcapSetKernelBufferHandler) pcap_find_function(airpcap_lib, "AirpcapSetKernelBuffer");
75  		p_AirpcapSetFilter = (AirpcapSetFilterHandler) pcap_find_function(airpcap_lib, "AirpcapSetFilter");
76  		p_AirpcapSetMinToCopy = (AirpcapSetMinToCopyHandler) pcap_find_function(airpcap_lib, "AirpcapSetMinToCopy");
77  		p_AirpcapGetReadEvent = (AirpcapGetReadEventHandler) pcap_find_function(airpcap_lib, "AirpcapGetReadEvent");
78  		p_AirpcapRead = (AirpcapReadHandler) pcap_find_function(airpcap_lib, "AirpcapRead");
79  		p_AirpcapWrite = (AirpcapWriteHandler) pcap_find_function(airpcap_lib, "AirpcapWrite");
80  		p_AirpcapGetStats = (AirpcapGetStatsHandler) pcap_find_function(airpcap_lib, "AirpcapGetStats");
81  		if (p_AirpcapGetLastError != NULL &&
82  		    p_AirpcapGetDeviceList != NULL &&
83  		    p_AirpcapFreeDeviceList != NULL &&
84  		    p_AirpcapOpen != NULL &&
85  		    p_AirpcapClose != NULL &&
86  		    p_AirpcapSetDeviceMacFlags != NULL &&
87  		    p_AirpcapSetLinkType != NULL &&
88  		    p_AirpcapGetLinkType != NULL &&
89  		    p_AirpcapSetKernelBuffer != NULL &&
90  		    p_AirpcapSetFilter != NULL &&
91  		    p_AirpcapSetMinToCopy != NULL &&
92  		    p_AirpcapGetReadEvent != NULL &&
93  		    p_AirpcapRead != NULL &&
94  		    p_AirpcapWrite != NULL &&
95  		    p_AirpcapGetStats != NULL) {
96  			current_status = AIRPCAP_API_LOADED;
97  		}
98  	}
99  	if (current_status != AIRPCAP_API_LOADED) {
100  		if (airpcap_lib != NULL) {
101  			FreeLibrary(airpcap_lib);
102  			airpcap_lib = NULL;
103  		}
104  	}
105  	InterlockedExchange((LONG *)&airpcap_load_status, current_status);
106  	return current_status;
107  }
108  struct pcap_airpcap {
109  	PAirpcapHandle adapter;
110  	int filtering_in_kernel;
111  	int nonblock;
112  	int read_timeout;
113  	HANDLE read_event;
114  	struct pcap_stat stat;
115  };
116  static int
117  airpcap_setfilter(pcap_t *p, struct bpf_program *fp)
118  {
119  	struct pcap_airpcap *pa = p->priv;
120  	if (!p_AirpcapSetFilter(pa->adapter, fp->bf_insns,
121  	    fp->bf_len * sizeof(struct bpf_insn))) {
122  		if (pcap_install_bpf_program(p, fp) < 0)
123  			return (-1);
124  		pa->filtering_in_kernel = 0;	&bsol;* filtering in userland */
125  		return (0);
126  	}
127  	pa->filtering_in_kernel = 1;	&bsol;* filtering in the kernel */
128  	p->cc = 0;
129  	return (0);
130  }
131  static int
132  airpcap_set_datalink(pcap_t *p, int dlt)
133  {
134  	struct pcap_airpcap *pa = p->priv;
135  	AirpcapLinkType type;
136  	switch (dlt) {
137  	case DLT_IEEE802_11_RADIO:
138  		type = AIRPCAP_LT_802_11_PLUS_RADIO;
139  		break;
140  	case DLT_PPI:
141  		type = AIRPCAP_LT_802_11_PLUS_PPI;
142  		break;
143  	case DLT_IEEE802_11:
144  		type = AIRPCAP_LT_802_11;
145  		break;
146  	default:
147  		return (0);
148  	}
149  	if (!p_AirpcapSetLinkType(pa->adapter, type)) {
150  		snprintf(p->errbuf, PCAP_ERRBUF_SIZE,
151  		    "AirpcapSetLinkType() failed: %s",
152  		    p_AirpcapGetLastError(pa->adapter));
153  		return (-1);
154  	}
155  	p->linktype = dlt;
156  	return (0);
157  }
158  static int
159  airpcap_getnonblock(pcap_t *p)
160  {
161  	struct pcap_airpcap *pa = p->priv;
162  	return (pa->nonblock);
163  }
164  static int
165  airpcap_setnonblock(pcap_t *p, int nonblock)
166  {
167  	struct pcap_airpcap *pa = p->priv;
168  	int newtimeout;
169  	if (nonblock) {
170  		newtimeout = -1;
171  	} else {
172  		newtimeout = p->opt.timeout;
173  	}
174  	pa->read_timeout = newtimeout;
175  	pa->nonblock = (newtimeout == -1);
176  	return (0);
177  }
178  static int
179  airpcap_stats(pcap_t *p, struct pcap_stat *ps)
180  {
181  	struct pcap_airpcap *pa = p->priv;
182  	AirpcapStats tas;
183  	if (!p_AirpcapGetStats(pa->adapter, &tas)) {
184  		snprintf(p->errbuf, PCAP_ERRBUF_SIZE,
185  		    "AirpcapGetStats() failed: %s",
186  		    p_AirpcapGetLastError(pa->adapter));
187  		return (-1);
188  	}
189  	ps->ps_drop = tas.Drops;
190  	ps->ps_recv = tas.Recvs;
191  	ps->ps_ifdrop = tas.IfDrops;
192  	return (0);
193  }
194  static struct pcap_stat *
195  airpcap_stats_ex(pcap_t *p, int *pcap_stat_size)
196  {
197  	struct pcap_airpcap *pa = p->priv;
198  	AirpcapStats tas;
199  	*pcap_stat_size = sizeof (p->stat);
200  	if (!p_AirpcapGetStats(pa->adapter, &tas)) {
201  		snprintf(p->errbuf, PCAP_ERRBUF_SIZE,
202  		    "AirpcapGetStats() failed: %s",
203  		    p_AirpcapGetLastError(pa->adapter));
204  		return (NULL);
205  	}
206  	p->stat.ps_recv = tas.Recvs;
207  	p->stat.ps_drop = tas.Drops;
208  	p->stat.ps_ifdrop = tas.IfDrops;
209  #ifdef _WIN32
210  	p->stat.ps_capt = tas.Capt;
211  #endif
212  	return (&p->stat);
213  }
214  static int
215  airpcap_setbuff(pcap_t *p, int dim)
216  {
217  	struct pcap_airpcap *pa = p->priv;
218  	if (!p_AirpcapSetKernelBuffer(pa->adapter, dim)) {
219  		snprintf(p->errbuf, PCAP_ERRBUF_SIZE,
220  		    "AirpcapSetKernelBuffer() failed: %s",
221  		    p_AirpcapGetLastError(pa->adapter));
222  		return (-1);
223  	}
224  	return (0);
225  }
226  static int
227  airpcap_setmode(pcap_t *p, int mode)
228  {
229  	 if (mode != MODE_CAPT) {
230  		snprintf(p->errbuf, PCAP_ERRBUF_SIZE,
231  		    "Only MODE_CAPT is supported on an AirPcap adapter");
232  		return (-1);
233  	 }
234  	 return (0);
235  }
236  static int
237  airpcap_setmintocopy(pcap_t *p, int size)
238  {
239  	struct pcap_airpcap *pa = p->priv;
240  	if (!p_AirpcapSetMinToCopy(pa->adapter, size)) {
241  		snprintf(p->errbuf, PCAP_ERRBUF_SIZE,
242  		    "AirpcapSetMinToCopy() failed: %s",
243  		    p_AirpcapGetLastError(pa->adapter));
244  		return (-1);
245  	}
246  	return (0);
247  }
248  static HANDLE
249  airpcap_getevent(pcap_t *p)
250  {
251  	struct pcap_airpcap *pa = p->priv;
252  	return (pa->read_event);
253  }
254  static int
255  airpcap_oid_get_request(pcap_t *p, bpf_u_int32 oid _U_, void *data _U_,
256      size_t *lenp _U_)
257  {
258  	snprintf(p->errbuf, PCAP_ERRBUF_SIZE,
259  	    "Getting OID values is not supported on an AirPcap adapter");
260  	return (PCAP_ERROR);
261  }
262  static int
263  airpcap_oid_set_request(pcap_t *p, bpf_u_int32 oid _U_, const void *data _U_,
264      size_t *lenp _U_)
265  {
266  	snprintf(p->errbuf, PCAP_ERRBUF_SIZE,
267  	    "Setting OID values is not supported on an AirPcap adapter");
268  	return (PCAP_ERROR);
269  }
270  static u_int
271  airpcap_sendqueue_transmit(pcap_t *p, pcap_send_queue *queue _U_, int sync _U_)
272  {
273  	snprintf(p->errbuf, PCAP_ERRBUF_SIZE,
274  	    "Cannot queue packets for transmission on an AirPcap adapter");
275  	return (0);
276  }
277  static int
278  airpcap_setuserbuffer(pcap_t *p, int size)
279  {
280  	unsigned char *new_buff;
281  	if (size <= 0) {
282  		snprintf(p->errbuf, PCAP_ERRBUF_SIZE,
283  		    "Error: invalid size %d",size);
284  		return (-1);
285  	}
286  	new_buff = (unsigned char *)malloc(sizeof(char)*size);
287  	if (!new_buff) {
288  		snprintf(p->errbuf, PCAP_ERRBUF_SIZE,
289  		    "Error: not enough memory");
290  		return (-1);
291  	}
292  	free(p->buffer);
293  	p->buffer = new_buff;
294  	p->bufsize = size;
295  	return (0);
296  }
297  static int
298  airpcap_live_dump(pcap_t *p, char *filename _U_, int maxsize _U_,
299      int maxpacks _U_)
300  {
301  	snprintf(p->errbuf, PCAP_ERRBUF_SIZE,
302  	    "AirPcap adapters don't support live dump");
303  	return (-1);
304  }
305  static int
306  airpcap_live_dump_ended(pcap_t *p, int sync _U_)
307  {
308  	snprintf(p->errbuf, PCAP_ERRBUF_SIZE,
309  	    "AirPcap adapters don't support live dump");
310  	return (-1);
311  }
312  static PAirpcapHandle
313  airpcap_get_airpcap_handle(pcap_t *p)
314  {
315  	struct pcap_airpcap *pa = p->priv;
316  	return (pa->adapter);
317  }
318  static int
319  airpcap_read(pcap_t *p, int cnt, pcap_handler callback, u_char *user)
320  {
321  	struct pcap_airpcap *pa = p->priv;
322  	int cc;
323  	int n;
324  	register u_char *bp, *ep;
325  	UINT bytes_read;
326  	u_char *datap;
327  	cc = p->cc;
328  	if (cc == 0) {
329  		if (p->break_loop) {
330  			p->break_loop = 0;
331  			return (PCAP_ERROR_BREAK);
332  		}
333  		if (pa->read_timeout != -1) {
334  			WaitForSingleObject(pa->read_event,
335  			    (pa->read_timeout ==0 )? INFINITE: pa->read_timeout);
336  		}
337  		if (!p_AirpcapRead(pa->adapter, (PBYTE)p->buffer,
338  		    p->bufsize, &bytes_read)) {
339  			snprintf(p->errbuf, PCAP_ERRBUF_SIZE,
340  			    "AirpcapRead() failed: %s",
341  			    p_AirpcapGetLastError(pa->adapter));
342  			return (-1);
343  		}
344  		cc = bytes_read;
345  		bp = p->buffer;
346  	} else
347  		bp = p->bp;
348  #define bhp ((AirpcapBpfHeader *)bp)
349  	n = 0;
350  	ep = bp + cc;
351  	for (;;) {
352  		register u_int caplen, hdrlen;
353  		if (p->break_loop) {
354  			if (n == 0) {
355  				p->break_loop = 0;
356  				return (PCAP_ERROR_BREAK);
357  			} else {
358  				p->bp = bp;
359  				p->cc = (int) (ep - bp);
360  				return (n);
361  			}
362  		}
363  		if (bp >= ep)
364  			break;
365  		caplen = bhp->Caplen;
366  		hdrlen = bhp->Hdrlen;
367  		datap = bp + hdrlen;
368  		if (pa->filtering_in_kernel ||
369  		    p->fcode.bf_insns == NULL ||
<span onclick='openModal()' class='match'>370  		    pcap_filter(p->fcode.bf_insns, datap, bhp->Originallen, caplen)) {
371  			struct pcap_pkthdr pkthdr;
</span>372  			pkthdr.ts.tv_sec = bhp->TsSec;
373  			pkthdr.ts.tv_usec = bhp->TsUsec;
374  			pkthdr.caplen = caplen;
375  			pkthdr.len = bhp->Originallen;
376  			(*callback)(user, &pkthdr, datap);
377  			bp += AIRPCAP_WORDALIGN(caplen + hdrlen);
378  			if (++n >= cnt && !PACKET_COUNT_IS_UNLIMITED(cnt)) {
379  				p->bp = bp;
380  				p->cc = (int)(ep - bp);
381  				return (n);
382  			}
383  		} else {
384  			bp += AIRPCAP_WORDALIGN(caplen + hdrlen);
385  		}
386  	}
387  #undef bhp
388  	p->cc = 0;
389  	return (n);
390  }
391  static int
392  airpcap_inject(pcap_t *p, const void *buf, int size)
393  {
394  	struct pcap_airpcap *pa = p->priv;
395  	if (!p_AirpcapWrite(pa->adapter, (void *)buf, size)) {
396  		snprintf(p->errbuf, PCAP_ERRBUF_SIZE,
397  		    "AirpcapWrite() failed: %s",
398  		    p_AirpcapGetLastError(pa->adapter));
399  		return (-1);
400  	}
401  	return (size);
402  }
403  static void
404  airpcap_cleanup(pcap_t *p)
405  {
406  	struct pcap_airpcap *pa = p->priv;
407  	if (pa->adapter != NULL) {
408  		p_AirpcapClose(pa->adapter);
409  		pa->adapter = NULL;
410  	}
411  	pcap_cleanup_live_common(p);
412  }
413  static void
414  airpcap_breakloop(pcap_t *p)
415  {
416  	HANDLE read_event;
417  	pcap_breakloop_common(p);
418  	struct pcap_airpcap *pa = p->priv;
419  	if (!p_AirpcapGetReadEvent(pa->adapter, &read_event))
420  		return;
421  	SetEvent(read_event);
422  }
423  static int
424  airpcap_activate(pcap_t *p)
425  {
426  	struct pcap_airpcap *pa = p->priv;
427  	char *device = p->opt.device;
428  	char airpcap_errbuf[AIRPCAP_ERRBUF_SIZE];
429  	BOOL status;
430  	AirpcapLinkType link_type;
431  	pa->adapter = p_AirpcapOpen(device, airpcap_errbuf);
432  	if (pa->adapter == NULL) {
433  		snprintf(p->errbuf, PCAP_ERRBUF_SIZE, "%s", airpcap_errbuf);
434  		return (PCAP_ERROR);
435  	}
436  	if (p->opt.rfmon) {
437  		status = p_AirpcapSetDeviceMacFlags(pa->adapter,
438  		    AIRPCAP_MF_MONITOR_MODE_ON);
439  	} else
440  		status = p_AirpcapSetDeviceMacFlags(pa->adapter,
441  		    AIRPCAP_MF_ACK_FRAMES_ON);
442  	if (!status) {
443  		p_AirpcapClose(pa->adapter);
444  		snprintf(p->errbuf, PCAP_ERRBUF_SIZE,
445  		    "AirpcapSetDeviceMacFlags() failed: %s",
446  		    p_AirpcapGetLastError(pa->adapter));
447  		return (PCAP_ERROR);
448  	}
449  	if (p->snapshot <= 0 || p->snapshot > MAXIMUM_SNAPLEN)
450  		p->snapshot = MAXIMUM_SNAPLEN;
451  	if (p->opt.buffer_size == 0)
452  		p->opt.buffer_size = AIRPCAP_DEFAULT_KERNEL_BUFFER_SIZE;
453  	if (!p_AirpcapSetKernelBuffer(pa->adapter, p->opt.buffer_size)) {
454  		snprintf(p->errbuf, PCAP_ERRBUF_SIZE,
455  		    "AirpcapSetKernelBuffer() failed: %s",
456  		    p_AirpcapGetLastError(pa->adapter));
457  		goto bad;
458  	}
459  	if(!p_AirpcapGetReadEvent(pa->adapter, &pa->read_event)) {
460  		snprintf(p->errbuf, PCAP_ERRBUF_SIZE,
461  		    "AirpcapGetReadEvent() failed: %s",
462  		    p_AirpcapGetLastError(pa->adapter));
463  		goto bad;
464  	}
465  	p->bufsize = AIRPCAP_DEFAULT_USER_BUFFER_SIZE;
466  	p->buffer = malloc(p->bufsize);
467  	if (p->buffer == NULL) {
468  		pcap_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,
469  		    errno, "malloc");
470  		goto bad;
471  	}
472  	if (p->opt.immediate) {
473  		if (!p_AirpcapSetMinToCopy(pa->adapter, 0)) {
474  			snprintf(p->errbuf, PCAP_ERRBUF_SIZE,
475  			    "AirpcapSetMinToCopy() failed: %s",
476  			    p_AirpcapGetLastError(pa->adapter));
477  			goto bad;
478  		}
479  	} else {
480  		if (!p_AirpcapSetMinToCopy(pa->adapter, 16000)) {
481  			snprintf(p->errbuf, PCAP_ERRBUF_SIZE,
482  			    "AirpcapSetMinToCopy() failed: %s",
483  			    p_AirpcapGetLastError(pa->adapter));
484  			goto bad;
485  		}
486  	}
487  	if (!p_AirpcapGetLinkType(pa->adapter, &link_type)) {
488  		snprintf(p->errbuf, PCAP_ERRBUF_SIZE,
489  		    "AirpcapGetLinkType() failed: %s",
490  		    p_AirpcapGetLastError(pa->adapter));
491  		goto bad;
492  	}
493  	switch (link_type) {
494  	case AIRPCAP_LT_802_11_PLUS_RADIO:
495  		p->linktype = DLT_IEEE802_11_RADIO;
496  		break;
497  	case AIRPCAP_LT_802_11_PLUS_PPI:
498  		p->linktype = DLT_PPI;
499  		break;
500  	case AIRPCAP_LT_802_11:
501  		p->linktype = DLT_IEEE802_11;
502  		break;
503  	case AIRPCAP_LT_UNKNOWN:
504  	default:
505  		snprintf(p->errbuf, PCAP_ERRBUF_SIZE,
506  		    "AirpcapGetLinkType() returned unknown link type %u",
507  		    link_type);
508  		goto bad;
509  	}
510  	p->dlt_list = (u_int *) malloc(sizeof(u_int) * 3);
511  	if (p->dlt_list == NULL) {
512  		pcap_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,
513  		    errno, "malloc");
514  		goto bad;
515  	}
516  	p->dlt_list[0] = DLT_IEEE802_11_RADIO;
517  	p->dlt_list[1] = DLT_PPI;
518  	p->dlt_list[2] = DLT_IEEE802_11;
519  	p->dlt_count = 3;
520  	p->read_op = airpcap_read;
521  	p->inject_op = airpcap_inject;
522  	p->setfilter_op = airpcap_setfilter;
523  	p->setdirection_op = NULL;	&bsol;* Not implemented. */
524  	p->set_datalink_op = airpcap_set_datalink;
525  	p->getnonblock_op = airpcap_getnonblock;
526  	p->setnonblock_op = airpcap_setnonblock;
527  	p->breakloop_op = airpcap_breakloop;
528  	p->stats_op = airpcap_stats;
529  	p->stats_ex_op = airpcap_stats_ex;
530  	p->setbuff_op = airpcap_setbuff;
531  	p->setmode_op = airpcap_setmode;
532  	p->setmintocopy_op = airpcap_setmintocopy;
533  	p->getevent_op = airpcap_getevent;
534  	p->oid_get_request_op = airpcap_oid_get_request;
535  	p->oid_set_request_op = airpcap_oid_set_request;
536  	p->sendqueue_transmit_op = airpcap_sendqueue_transmit;
537  	p->setuserbuffer_op = airpcap_setuserbuffer;
538  	p->live_dump_op = airpcap_live_dump;
539  	p->live_dump_ended_op = airpcap_live_dump_ended;
540  	p->get_airpcap_handle_op = airpcap_get_airpcap_handle;
541  	p->cleanup_op = airpcap_cleanup;
542  	return (0);
543   bad:
544  	airpcap_cleanup(p);
545  	return (PCAP_ERROR);
546  }
547  static int
548  airpcap_can_set_rfmon(pcap_t *p)
549  {
550  	return (1);
551  }
552  int
553  device_is_airpcap(const char *device, char *ebuf)
554  {
555  	static const char airpcap_prefix[] = "\\\\.\\airpcap";
556  	if (strncmp(device, airpcap_prefix, sizeof airpcap_prefix - 1) == 0) {
557  		return (1);
558  	}
559  	return (0);
560  }
561  pcap_t *
562  airpcap_create(const char *device, char *ebuf, int *is_ours)
563  {
564  	int ret;
565  	pcap_t *p;
566  	if (load_airpcap_functions() != AIRPCAP_API_LOADED) {
567  		*is_ours = 0;
568  		return (NULL);
569  	}
570  	ret = device_is_airpcap(device, ebuf);
571  	if (ret == 0) {
572  		*is_ours = 0;
573  		return (NULL);
574  	}
575  	*is_ours = 1;
576  	p = PCAP_CREATE_COMMON(ebuf, struct pcap_airpcap);
577  	if (p == NULL)
578  		return (NULL);
579  	p->activate_op = airpcap_activate;
580  	p->can_set_rfmon_op = airpcap_can_set_rfmon;
581  	return (p);
582  }
583  int
584  airpcap_findalldevs(pcap_if_list_t *devlistp, char *errbuf)
585  {
586  	AirpcapDeviceDescription *airpcap_devices, *airpcap_device;
587  	char airpcap_errbuf[AIRPCAP_ERRBUF_SIZE];
588  	if (load_airpcap_functions() != AIRPCAP_API_LOADED) {
589  		return (0);
590  	}
591  	if (!p_AirpcapGetDeviceList(&airpcap_devices, airpcap_errbuf)) {
592  		snprintf(errbuf, PCAP_ERRBUF_SIZE,
593  		    "AirpcapGetDeviceList() failed: %s", airpcap_errbuf);
594  		return (-1);
595  	}
596  	for (airpcap_device = airpcap_devices; airpcap_device != NULL;
597  	    airpcap_device = airpcap_device->next) {
598  		if (pcap_add_dev(devlistp, airpcap_device->Name, 0,
599  		    airpcap_device->Description, errbuf) == NULL) {
600  			p_AirpcapFreeDeviceList(airpcap_devices);
601  			return (-1);
602  		}
603  	}
604  	p_AirpcapFreeDeviceList(airpcap_devices);
605  	return (0);
606  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from libpcap-MDEwOlJlcG9zaXRvcnk5NDM1ODg3-flat-pcap-npf.c</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from libpcap-MDEwOlJlcG9zaXRvcnk5NDM1ODg3-flat-pcap-airpcap.c</div>
                </div>
                <div class="column column_space"><pre><code>357  		    pcap_filter(p->fcode.bf_insns, datap, bhp->bh_datalen, caplen)) {
358  #ifdef ENABLE_REMOTE
</pre></code></div>
                <div class="column column_space"><pre><code>370  		    pcap_filter(p->fcode.bf_insns, datap, bhp->Originallen, caplen)) {
371  			struct pcap_pkthdr pkthdr;
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    