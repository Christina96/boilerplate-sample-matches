
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 15.734265734265735%, Tokens: 17</h2>
        <div class="column">
            <h3>xmrig-MDEwOlJlcG9zaXRvcnk4ODMyNzQwNg==-flat-IConfig.h</h3>
            <pre><code>1  #ifndef XMRIG_ICONFIG_H
2  #define XMRIG_ICONFIG_H
3  #include "3rdparty/rapidjson/fwd.h"
4  namespace xmrig {
5  class IJsonReader;
6  class String;
7  class IConfig
8  {
9  public:
10      enum Keys {
<span onclick='openModal()' class='match'>11          AlgorithmKey         = 'a',
12          CoinKey              = 1025,
13          ApiWorkerIdKey       = 4002,
14          ApiIdKey             = 4005,
15          HttpPort             = 4100,
16          HttpAccessTokenKey   = 4101,
17          HttpRestrictedKey    = 4104,
18          HttpEnabledKey       = 4106,
19          HttpHostKey          = 4107,
20          BackgroundKey        = 'B',
21          ColorKey             = 1002,
22          ConfigKey            = 'c',
23          DonateLevelKey       = 1003,
24          KeepAliveKey         = 'k',
25          LogFileKey           = 'l',
26          PasswordKey          = 'p',
27          RetriesKey           = 'r',
</span>28          RetryPauseKey        = 'R',
29          RigIdKey             = 1012,
30          SyslogKey            = 'S',
31          UrlKey               = 'o',
32          UserAgentKey         = 1008,
33          UserKey              = 'u',
34          UserpassKey          = 'O',
35          ProxyKey             = 'x',
36          VerboseKey           = 1100,
37          TlsKey               = 1013,
38          FingerprintKey       = 1014,
39          ProxyDonateKey       = 1017,
40          DaemonKey            = 1018,
41          DaemonPollKey        = 1019,
42          SelfSelectKey        = 1028,
43          DataDirKey           = 1035,
44          TitleKey             = 1037,
45          NoTitleKey           = 1038,
46          PauseOnBatteryKey    = 1041,
47          StressKey            = 1042,
48          BenchKey             = 1043,
49          BenchSubmitKey       = 1044,
50          BenchVerifyKey       = 1045,
51          BenchSeedKey         = 1046,
52          BenchHashKey         = 1047,
53          BenchTokenKey        = 1048,
54          DmiKey               = 1049,
55          HugePageSizeKey      = 1050,
56          PauseOnActiveKey     = 1051,
57          SubmitToOriginKey    = 1052,
58          DnsIPv6Key           = 1053,
59          DnsTtlKey            = 1054,
60          SpendSecretKey       = 1055,
61          DaemonZMQPortKey     = 1056,
62          HugePagesJitKey      = 1057,
63          RotationKey          = 1058,
64          DaemonJobTimeoutKey  = 1059,
65          CPUPriorityKey       = 1021,
66          NicehashKey          = 1006,
67          PrintTimeKey         = 1007,
68          CPUKey               = 1024,
69          AVKey                = 'v',
70          CPUAffinityKey       = 1020,
71          DryRunKey            = 5000,
72          HugePagesKey         = 1009,
73          ThreadsKey           = 't',
74          AssemblyKey          = 1015,
75          RandomXInitKey       = 1022,
76          RandomXNumaKey       = 1023,
77          RandomXModeKey       = 1029,
78          RandomX1GbPagesKey   = 1031,
79          RandomXWrmsrKey      = 1032,
80          RandomXRdmsrKey      = 1033,
81          CPUMaxThreadsKey     = 1026,
82          MemoryPoolKey        = 1027,
83          YieldKey             = 1030,
84          Argon2ImplKey        = 1039,
85          RandomXCacheQoSKey   = 1040,
86          OclPlatformKey       = 1400,
87          OclAffinityKey       = 1401,
88          OclDevicesKey        = 1402,
89          OclLaunchKey         = 1403,
90          OclCacheKey          = 1404,
91          OclPrintKey          = 1405,
92          OclLoaderKey         = 1406,
93          OclSridedIndexKey    = 1407,
94          OclMemChunkKey       = 1408,
95          OclUnrollKey         = 1409,
96          OclCompModeKey       = 1410,
97          OclKey               = 1411,
98          AccessLogFileKey     = 'A',
99          BindKey              = 'b',
100          CustomDiffKey        = 1102,
101          CustomDiffStatsKey   = 1104,
102          DebugKey             = 1101,
103          ModeKey              = 'm',
104          PoolCoinKey          = 'C',
105          ReuseTimeoutKey      = 1106,
106          WorkersKey           = 1103,
107          WorkersAdvKey        = 1107,
108          TlsBindKey           = 1108,
109          TlsCertKey           = 1109,
110          TlsCertKeyKey        = 1110,
111          TlsDHparamKey        = 1111,
112          TlsCiphersKey        = 1112,
113          TlsCipherSuitesKey   = 1113,
114          TlsProtocolsKey      = 1114,
115          TlsGenKey            = 1117,
116          AlgoExtKey           = 1115,
117          ProxyPasswordKey     = 1116,
118          LoginFileKey         = 'L',
119          CudaMaxThreadsKey    = 1200,
120          CudaBFactorKey       = 1201,
121          CudaBSleepKey        = 1202,
122          CudaDevicesKey       = 1203,
123          CudaLaunchKey        = 1204,
124          CudaAffinityKey      = 1205,
125          CudaMaxUsageKey      = 1206,
126          CudaKey              = 1207,
127          CudaLoaderKey        = 1208,
128          NvmlKey              = 1209,
129          HealthPrintTimeKey   = 1210,
130      };
131      virtual ~IConfig() = default;
132      virtual bool isWatch() const                                       = 0;
133      virtual bool read(const IJsonReader &reader, const char *fileName) = 0;
134      virtual bool save()                                                = 0;
135      virtual const String &fileName() const                             = 0;
136      virtual void getJSON(rapidjson::Document &doc) const               = 0;
137      virtual void setFileName(const char *fileName)                     = 0;
138  };
139  } &bsol;* namespace xmrig */
140  #endif 
</code></pre>
        </div>
        <div class="column">
            <h3>libtomcrypt-MDEwOlJlcG9zaXRvcnk3NzcwMTE=-flat-rabbit.c</h3>
            <pre><code>1  #include "tomcrypt_private.h"
2  #ifdef LTC_RABBIT
3  static LTC_INLINE ulong32 ss_rabbit_g_func(ulong32 x);
4  static LTC_INLINE void ss_rabbit_next_state(rabbit_ctx *p_instance);
5  static LTC_INLINE void ss_rabbit_gen_1_block(rabbit_state* st, unsigned char *out);
6  static LTC_INLINE ulong32 ss_rabbit_g_func(ulong32 x)
7  {
8     ulong32 a, b, h, l;
9     a = x &  0xFFFF;
10     b = x >> 16;
11     h = ((((ulong32)(a*a)>>17) + (ulong32)(a*b))>>15) + b*b;
12     l = x * x;
13     return (ulong32)(h^l);
14  }
15  static LTC_INLINE void ss_rabbit_next_state(rabbit_ctx *p_instance)
16  {
17     ulong32 g[8], c_old[8], i;
18     for (i=0; i<8; i++) {
19        c_old[i] = p_instance->c[i];
20     }
21     p_instance->c[0] = (ulong32)(p_instance->c[0] + 0x4D34D34D + p_instance->carry);
22     p_instance->c[1] = (ulong32)(p_instance->c[1] + 0xD34D34D3 + (p_instance->c[0] < c_old[0]));
23     p_instance->c[2] = (ulong32)(p_instance->c[2] + 0x34D34D34 + (p_instance->c[1] < c_old[1]));
24     p_instance->c[3] = (ulong32)(p_instance->c[3] + 0x4D34D34D + (p_instance->c[2] < c_old[2]));
25     p_instance->c[4] = (ulong32)(p_instance->c[4] + 0xD34D34D3 + (p_instance->c[3] < c_old[3]));
26     p_instance->c[5] = (ulong32)(p_instance->c[5] + 0x34D34D34 + (p_instance->c[4] < c_old[4]));
27     p_instance->c[6] = (ulong32)(p_instance->c[6] + 0x4D34D34D + (p_instance->c[5] < c_old[5]));
28     p_instance->c[7] = (ulong32)(p_instance->c[7] + 0xD34D34D3 + (p_instance->c[6] < c_old[6]));
29     p_instance->carry = (p_instance->c[7] < c_old[7]);
30     for (i=0;i<8;i++) {
31        g[i] = ss_rabbit_g_func((ulong32)(p_instance->x[i] + p_instance->c[i]));
32     }
33     p_instance->x[0] = (ulong32)(g[0] + ROLc(g[7],16) + ROLc(g[6], 16));
34     p_instance->x[1] = (ulong32)(g[1] + ROLc(g[0], 8) + g[7]);
35     p_instance->x[2] = (ulong32)(g[2] + ROLc(g[1],16) + ROLc(g[0], 16));
36     p_instance->x[3] = (ulong32)(g[3] + ROLc(g[2], 8) + g[1]);
37     p_instance->x[4] = (ulong32)(g[4] + ROLc(g[3],16) + ROLc(g[2], 16));
38     p_instance->x[5] = (ulong32)(g[5] + ROLc(g[4], 8) + g[3]);
39     p_instance->x[6] = (ulong32)(g[6] + ROLc(g[5],16) + ROLc(g[4], 16));
40     p_instance->x[7] = (ulong32)(g[7] + ROLc(g[6], 8) + g[5]);
41  }
42  static LTC_INLINE void ss_rabbit_gen_1_block(rabbit_state* st, unsigned char *out)
43  {
44      ulong32 *ptr;
45      ss_rabbit_next_state(&(st->work_ctx));
46      ptr = (ulong32*)&(st->work_ctx.x);
47      STORE32L((ptr[0] ^ (ptr[5]>>16) ^ (ulong32)(ptr[3]<<16)), out+ 0);
48      STORE32L((ptr[2] ^ (ptr[7]>>16) ^ (ulong32)(ptr[5]<<16)), out+ 4);
49      STORE32L((ptr[4] ^ (ptr[1]>>16) ^ (ulong32)(ptr[7]<<16)), out+ 8);
50      STORE32L((ptr[6] ^ (ptr[3]>>16) ^ (ulong32)(ptr[1]<<16)), out+12);
51  }
52  int rabbit_setup(rabbit_state* st, const unsigned char *key, unsigned long keylen)
53  {
54     ulong32 k0, k1, k2, k3, i;
55     unsigned char  tmpkey[16] = {0};
56     LTC_ARGCHK(st != NULL);
57     LTC_ARGCHK(key != NULL);
58     LTC_ARGCHK(keylen <= 16);
59     XMEMSET(st, 0, sizeof(rabbit_state));
60     XMEMCPY(tmpkey, key, keylen);
61     LOAD32L(k0, tmpkey+ 0);
62     LOAD32L(k1, tmpkey+ 4);
63     LOAD32L(k2, tmpkey+ 8);
64     LOAD32L(k3, tmpkey+12);
65  #ifdef LTC_CLEAN_STACK
66     zeromem(tmpkey, sizeof(tmpkey));
67  #endif
<span onclick='openModal()' class='match'>68     st->master_ctx.x[0] = k0;
69     st->master_ctx.x[2] = k1;
70     st->master_ctx.x[4] = k2;
71     st->master_ctx.x[6] = k3;
72     st->master_ctx.x[1] = (ulong32)(k3<<16) | (k2>>16);
73     st->master_ctx.x[3] = (ulong32)(k0<<16) | (k3>>16);
74     st->master_ctx.x[5] = (ulong32)(k1<<16) | (k0>>16);
75     st->master_ctx.x[7] = (ulong32)(k2<<16) | (k1>>16);
76     st->master_ctx.c[0] = ROLc(k2, 16);
77     st->master_ctx.c[2] = ROLc(k3, 16);
78     st->master_ctx.c[4] = ROLc(k0, 16);
79     st->master_ctx.c[6] = ROLc(k1, 16);
80     st->master_ctx.c[1] = (k0&0xFFFF0000) | (k1&0xFFFF);
81     st->master_ctx.c[3] = (k1&0xFFFF0000) | (k2&0xFFFF);
82     st->master_ctx.c[5] = (k2&0xFFFF0000) | (k3&0xFFFF);
83     st->master_ctx.c[7] = (k3&0xFFFF0000) | (k0&0xFFFF);
84     st->master_ctx.carry = 0;
</span>85     for (i=0; i<4; i++) {
86        ss_rabbit_next_state(&(st->master_ctx));
87     }
88     for (i=0; i<8; i++) {
89        st->master_ctx.c[i] ^= st->master_ctx.x[(i+4)&0x7];
90     }
91     for (i=0; i<8; i++) {
92        st->work_ctx.x[i] = st->master_ctx.x[i];
93        st->work_ctx.c[i] = st->master_ctx.c[i];
94     }
95     st->work_ctx.carry = st->master_ctx.carry;
96     XMEMSET(&(st->block), 0, sizeof(st->block));
97     st->unused = 0;
98     return CRYPT_OK;
99  }
100  int rabbit_setiv(rabbit_state* st, const unsigned char *iv, unsigned long ivlen)
101  {
102     ulong32 i0, i1, i2, i3, i;
103     unsigned char  tmpiv[8] = {0};
104     LTC_ARGCHK(st != NULL);
105     LTC_ARGCHK(iv != NULL || ivlen == 0);
106     LTC_ARGCHK(ivlen <= 8);
107     if (iv && ivlen > 0) XMEMCPY(tmpiv, iv, ivlen);
108     LOAD32L(i0, tmpiv+0);
109     LOAD32L(i2, tmpiv+4);
110     i1 = (i0>>16) | (i2&0xFFFF0000);
111     i3 = (i2<<16) | (i0&0x0000FFFF);
112     st->work_ctx.c[0] = st->master_ctx.c[0] ^ i0;
113     st->work_ctx.c[1] = st->master_ctx.c[1] ^ i1;
114     st->work_ctx.c[2] = st->master_ctx.c[2] ^ i2;
115     st->work_ctx.c[3] = st->master_ctx.c[3] ^ i3;
116     st->work_ctx.c[4] = st->master_ctx.c[4] ^ i0;
117     st->work_ctx.c[5] = st->master_ctx.c[5] ^ i1;
118     st->work_ctx.c[6] = st->master_ctx.c[6] ^ i2;
119     st->work_ctx.c[7] = st->master_ctx.c[7] ^ i3;
120     for (i=0; i<8; i++) {
121        st->work_ctx.x[i] = st->master_ctx.x[i];
122     }
123     st->work_ctx.carry = st->master_ctx.carry;
124     for (i=0; i<4; i++) {
125        ss_rabbit_next_state(&(st->work_ctx));
126     }
127     XMEMSET(&(st->block), 0, sizeof(st->block));
128     st->unused = 0;
129     return CRYPT_OK;
130  }
131  int rabbit_crypt(rabbit_state* st, const unsigned char *in, unsigned long inlen, unsigned char *out)
132  {
133     unsigned char buf[16];
134     unsigned long i, j;
135     if (inlen == 0) return CRYPT_OK; &bsol;* nothing to do */
136     LTC_ARGCHK(st        != NULL);
137     LTC_ARGCHK(in        != NULL);
138     LTC_ARGCHK(out       != NULL);
139     if (st->unused > 0) {
140        j = MIN(st->unused, inlen);
141        for (i = 0; i < j; ++i, st->unused--) out[i] = in[i] ^ st->block[16 - st->unused];
142        inlen -= j;
143        if (inlen == 0) return CRYPT_OK;
144        out += j;
145        in  += j;
146     }
147     for (;;) {
148       ss_rabbit_gen_1_block(st, buf);
149       if (inlen <= 16) {
150         for (i = 0; i < inlen; ++i) out[i] = in[i] ^ buf[i];
151         st->unused = 16 - inlen;
152         for (i = inlen; i < 16; ++i) st->block[i] = buf[i];
153         return CRYPT_OK;
154       }
155       for (i = 0; i < 16; ++i) out[i] = in[i] ^ buf[i];
156       inlen -= 16;
157       out += 16;
158       in  += 16;
159     }
160  }
161  int rabbit_keystream(rabbit_state *st, unsigned char *out, unsigned long outlen)
162  {
163     if (outlen == 0) return CRYPT_OK; &bsol;* nothing to do */
164     LTC_ARGCHK(out != NULL);
165     XMEMSET(out, 0, outlen);
166     return rabbit_crypt(st, out, outlen, out);
167  }
168  int rabbit_done(rabbit_state *st)
169  {
170     LTC_ARGCHK(st != NULL);
171     zeromem(st, sizeof(rabbit_state));
172     return CRYPT_OK;
173  }
174  int rabbit_test(void)
175  {
176  #ifndef LTC_TEST
177     return CRYPT_NOP;
178  #else
179     rabbit_state st;
180     int err;
181     unsigned char out[1000] = { 0 };
182     {
183        {
184           unsigned char k[]  = { 0x0F, 0x62, 0xB5, 0x08, 0x5B, 0xAE, 0x01, 0x54,
185                                  0xA7, 0xFA, 0x4D, 0xA0, 0xF3, 0x46, 0x99, 0xEC };
186           unsigned char iv[] = { 0x28, 0x8F, 0xF6, 0x5D, 0xC4, 0x2B, 0x92, 0xF9 };
187           char pt[64]        = { 0 };
188           unsigned char ct[] = { 0x61, 0x3C, 0xB0, 0xBA, 0x96, 0xAF, 0xF6, 0xCA,
189                                  0xCF, 0x2A, 0x45, 0x9A, 0x10, 0x2A, 0x7F, 0x78,
190                                  0xCA, 0x98, 0x5C, 0xF8, 0xFD, 0xD1, 0x47, 0x40,
191                                  0x18, 0x75, 0x8E, 0x36, 0xAE, 0x99, 0x23, 0xF5,
192                                  0x19, 0xD1, 0x3D, 0x71, 0x8D, 0xAF, 0x8D, 0x7C,
193                                  0x0C, 0x10, 0x9B, 0x79, 0xD5, 0x74, 0x94, 0x39,
194                                  0xB7, 0xEF, 0xA4, 0xC4, 0xC9, 0xC8, 0xD2, 0x9D,
195                                  0xC5, 0xB3, 0x88, 0x83, 0x14, 0xA6, 0x81, 0x6F };
196           unsigned long ptlen = sizeof(pt);
197           if ((err = rabbit_setup(&st, k, sizeof(k)))                   != CRYPT_OK) return err;
198           if ((err = rabbit_setiv(&st, iv, sizeof(iv)))                 != CRYPT_OK) return err;
199           if ((err = rabbit_crypt(&st, (unsigned char*)pt, ptlen, out)) != CRYPT_OK) return err;
200           if (compare_testvector(out, ptlen, ct, ptlen, "RABBIT-TV1", 1))   return CRYPT_FAIL_TESTVECTOR;
201        }
202        {
203           unsigned char k[]  = { 0x0F, 0x62, 0xB5, 0x08, 0x5B, 0xAE, 0x01, 0x54,
204                                  0xA7, 0xFA, 0x4D, 0xA0, 0xF3, 0x46, 0x99, 0xEC };
205           unsigned char iv[] = { 0x28, 0x8F, 0xF6, 0x5D, 0xC4, 0x2B, 0x92, 0xF9 };
206           char          pt[39] = { 0 };
207           unsigned char ct[] = { 0x61, 0x3C, 0xB0, 0xBA,   0x96, 0xAF, 0xF6, 0xCA,
208                                  0xCF, 0x2A, 0x45, 0x9A,   0x10, 0x2A, 0x7F, 0x78,
209                                  0xCA, 0x98, 0x5C, 0xF8,   0xFD, 0xD1, 0x47, 0x40,
210                                  0x18, 0x75, 0x8E, 0x36,   0xAE, 0x99, 0x23, 0xF5,
211                                  0x19, 0xD1, 0x3D, 0x71,   0x8D, 0xAF, 0x8D };
212           unsigned long ptlen = sizeof(pt);
213           if ((err = rabbit_setup(&st, k, sizeof(k)))                          != CRYPT_OK) return err;
214           if ((err = rabbit_setiv(&st, iv, sizeof(iv)))                        != CRYPT_OK) return err;
215           if ((err = rabbit_crypt(&st, (unsigned char*)pt,       5, out))      != CRYPT_OK) return err;
216           if ((err = rabbit_crypt(&st, (unsigned char*)pt +  5, 11, out +  5)) != CRYPT_OK) return err;
217           if ((err = rabbit_crypt(&st, (unsigned char*)pt + 16, 14, out + 16)) != CRYPT_OK) return err;
218           if ((err = rabbit_crypt(&st, (unsigned char*)pt + 30,  2, out + 30)) != CRYPT_OK) return err;
219           if ((err = rabbit_crypt(&st, (unsigned char*)pt + 32,  7, out + 32)) != CRYPT_OK) return err;
220           if (compare_testvector(out, ptlen, ct, ptlen, "RABBIT-TV2", 1))   return CRYPT_FAIL_TESTVECTOR;
221        }
222        {
223           unsigned char k[]  = { 0x0F, 0x62, 0xB5, 0x08, 0x5B, 0xAE, 0x01, 0x54,
224                                  0xA7, 0xFA, 0x4D, 0xA0, 0xF3, 0x46, 0x99, 0xEC };
225           unsigned char iv[] = { 0x28, 0x8F, 0xF6, 0x5D, 0xC4, 0x2B, 0x92, 0xF9 };
226           char          pt[] = "Kilroy was here, there, and everywhere!";
227           unsigned char ct[] = { 0x2a, 0x55, 0xdc, 0xc8,   0xf9, 0xd6, 0xd6, 0xbd,
228                                  0xae, 0x59, 0x65, 0xf2,   0x75, 0x58, 0x1a, 0x54,
229                                  0xea, 0xec, 0x34, 0x9d,   0x8f, 0xb4, 0x6b, 0x60,
230                                  0x79, 0x1b, 0xea, 0x16,   0xcb, 0xef, 0x46, 0x87,
231                                  0x60, 0xa6, 0x55, 0x14,   0xff, 0xca, 0xac };
232           unsigned long ptlen = XSTRLEN(pt);
233           unsigned char out2[1000] = { 0 };
234           unsigned char nulls[1000] = { 0 };
235           if ((err = rabbit_setup(&st, k, sizeof(k)))                          != CRYPT_OK) return err;
236           if ((err = rabbit_setiv(&st, iv, sizeof(iv)))                        != CRYPT_OK) return err;
237           if ((err = rabbit_crypt(&st, (unsigned char*)pt,       5, out))      != CRYPT_OK) return err;
238           if ((err = rabbit_crypt(&st, (unsigned char*)pt +  5, 29, out +  5)) != CRYPT_OK) return err;
239           if ((err = rabbit_crypt(&st, (unsigned char*)pt + 34,  5, out + 34)) != CRYPT_OK) return err;
240           if (compare_testvector(out, ptlen, ct, ptlen, "RABBIT-TV3", 1))   return CRYPT_FAIL_TESTVECTOR;
241           if ((err = rabbit_memory(k, sizeof(k), iv, sizeof(iv),
242                                     (unsigned char*)pt, sizeof(pt), out))      != CRYPT_OK) return err;
243           if (compare_testvector(out, ptlen, ct, ptlen, "RABBIT-TV4", 1))   return CRYPT_FAIL_TESTVECTOR;
244           if ((err = rabbit_setiv(&st, iv, sizeof(iv)))                        != CRYPT_OK) return err;
245           if ((err = rabbit_crypt(&st, out, ptlen, out2))                      != CRYPT_OK) return err;
246           if (compare_testvector(out2, ptlen, pt, ptlen, "RABBIT-TV5", 1))  return CRYPT_FAIL_TESTVECTOR;
247           if ((err = rabbit_done(&st))                      != CRYPT_OK) return err;
248           if (compare_testvector(&st, sizeof(st), nulls, sizeof(st), "RABBIT-TV6", 1))  return CRYPT_FAIL_TESTVECTOR;
249        }
250        return CRYPT_OK;
251     }
252  #endif
253  }
254  #endif
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from xmrig-MDEwOlJlcG9zaXRvcnk4ODMyNzQwNg==-flat-IConfig.h</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from libtomcrypt-MDEwOlJlcG9zaXRvcnk3NzcwMTE=-flat-rabbit.c</div>
                </div>
                <div class="column column_space"><pre><code>11          AlgorithmKey         = 'a',
12          CoinKey              = 1025,
13          ApiWorkerIdKey       = 4002,
14          ApiIdKey             = 4005,
15          HttpPort             = 4100,
16          HttpAccessTokenKey   = 4101,
17          HttpRestrictedKey    = 4104,
18          HttpEnabledKey       = 4106,
19          HttpHostKey          = 4107,
20          BackgroundKey        = 'B',
21          ColorKey             = 1002,
22          ConfigKey            = 'c',
23          DonateLevelKey       = 1003,
24          KeepAliveKey         = 'k',
25          LogFileKey           = 'l',
26          PasswordKey          = 'p',
27          RetriesKey           = 'r',
</pre></code></div>
                <div class="column column_space"><pre><code>68     st->master_ctx.x[0] = k0;
69     st->master_ctx.x[2] = k1;
70     st->master_ctx.x[4] = k2;
71     st->master_ctx.x[6] = k3;
72     st->master_ctx.x[1] = (ulong32)(k3<<16) | (k2>>16);
73     st->master_ctx.x[3] = (ulong32)(k0<<16) | (k3>>16);
74     st->master_ctx.x[5] = (ulong32)(k1<<16) | (k0>>16);
75     st->master_ctx.x[7] = (ulong32)(k2<<16) | (k1>>16);
76     st->master_ctx.c[0] = ROLc(k2, 16);
77     st->master_ctx.c[2] = ROLc(k3, 16);
78     st->master_ctx.c[4] = ROLc(k0, 16);
79     st->master_ctx.c[6] = ROLc(k1, 16);
80     st->master_ctx.c[1] = (k0&0xFFFF0000) | (k1&0xFFFF);
81     st->master_ctx.c[3] = (k1&0xFFFF0000) | (k2&0xFFFF);
82     st->master_ctx.c[5] = (k2&0xFFFF0000) | (k3&0xFFFF);
83     st->master_ctx.c[7] = (k3&0xFFFF0000) | (k0&0xFFFF);
84     st->master_ctx.carry = 0;
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    