
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 5.418422636965683%, Tokens: 13</h2>
        <div class="column">
            <h3>libtomcrypt-MDEwOlJlcG9zaXRvcnk3NzcwMTE=-flat-eax_test.c</h3>
            <pre><code>1  #include "tomcrypt_private.h"
2  #ifdef LTC_EAX_MODE
3  int eax_test(void)
4  {
5  #ifndef LTC_TEST
6     return CRYPT_NOP;
7  #else
8     static const struct {
9         int               keylen,
10                         noncelen,
11                        headerlen,
12                           msglen;
13         unsigned char        key[MAXBLOCKSIZE],
14                            nonce[MAXBLOCKSIZE],
15                           header[MAXBLOCKSIZE],
16                        plaintext[MAXBLOCKSIZE],
17                       ciphertext[MAXBLOCKSIZE],
18                              tag[MAXBLOCKSIZE];
19     } tests[] = {
<span onclick='openModal()' class='match'>20  {
21     16, 0, 0, 0,
22     { 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
23       0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f },
24     { 0 },
25     { 0 },
26     { 0 },
27     { 0 },
28     { 0x9a, 0xd0, 0x7e, 0x7d, 0xbf, 0xf3, 0x01, 0xf5,
29       0x05, 0xde, 0x59, 0x6b, 0x96, 0x15, 0xdf, 0xff }
</span>30  },
31  {
32     16, 16, 0, 0,
33     { 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
34       0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f },
35     { 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
36       0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f },
37     { 0 },
38     { 0 },
39     { 0 },
40     { 0x1c, 0xe1, 0x0d, 0x3e, 0xff, 0xd4, 0xca, 0xdb,
41       0xe2, 0xe4, 0x4b, 0x58, 0xd6, 0x0a, 0xb9, 0xec }
42  },
43  {
44     16, 0, 16, 0,
45     { 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
46       0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f },
47     { 0 },
48     { 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
49       0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f },
50     { 0 },
51     { 0 },
52     { 0x3a, 0x69, 0x8f, 0x7a, 0x27, 0x0e, 0x51, 0xb0,
53       0xf6, 0x5b, 0x3d, 0x3e, 0x47, 0x19, 0x3c, 0xff }
54  },
55  {
56     16, 16, 16, 32,
57     { 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
58       0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f },
59     { 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
60       0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f },
61     { 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
62       0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f },
63     { 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
64       0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,
65       0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17,
66       0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f },
67     { 0x29, 0xd8, 0x78, 0xd1, 0xa3, 0xbe, 0x85, 0x7b,
68       0x6f, 0xb8, 0xc8, 0xea, 0x59, 0x50, 0xa7, 0x78,
69       0x33, 0x1f, 0xbf, 0x2c, 0xcf, 0x33, 0x98, 0x6f,
70       0x35, 0xe8, 0xcf, 0x12, 0x1d, 0xcb, 0x30, 0xbc },
71     { 0x4f, 0xbe, 0x03, 0x38, 0xbe, 0x1c, 0x8c, 0x7e,
72       0x1d, 0x7a, 0xe7, 0xe4, 0x5b, 0x92, 0xc5, 0x87 }
73  },
74  {
75     16, 15, 14, 29,
76     { 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
77       0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f },
78     { 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
79       0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e },
80     { 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
81       0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d },
82     { 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
83       0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,
84       0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17,
85       0x18, 0x19, 0x1a, 0x1b, 0x1c },
86     { 0xdd, 0x25, 0xc7, 0x54, 0xc5, 0xb1, 0x7c, 0x59,
87       0x28, 0xb6, 0x9b, 0x73, 0x15, 0x5f, 0x7b, 0xb8,
88       0x88, 0x8f, 0xaf, 0x37, 0x09, 0x1a, 0xd9, 0x2c,
89       0x8a, 0x24, 0xdb, 0x86, 0x8b },
90     { 0x0d, 0x1a, 0x14, 0xe5, 0x22, 0x24, 0xff, 0xd2,
91       0x3a, 0x05, 0xfa, 0x02, 0xcd, 0xef, 0x52, 0xda }
92  },
93  {
94     16, 16, 8, 0,
95     { 0x23, 0x39, 0x52, 0xde, 0xe4, 0xd5, 0xed, 0x5f,
96       0x9b, 0x9c, 0x6d, 0x6f, 0xf8, 0x0f, 0xf4, 0x78 },
97     { 0x62, 0xec, 0x67, 0xf9, 0xc3, 0xa4, 0xa4, 0x07,
98       0xfc, 0xb2, 0xa8, 0xc4, 0x90, 0x31, 0xa8, 0xb3 },
99     { 0x6b, 0xfb, 0x91, 0x4f, 0xd0, 0x7e, 0xae, 0x6b },
100     { 0x00 },
101     { 0x00 },
102     { 0xe0, 0x37, 0x83, 0x0e, 0x83, 0x89, 0xf2, 0x7b,
103       0x02, 0x5a, 0x2d, 0x65, 0x27, 0xe7, 0x9d, 0x01 }
104  },
105  {
106     16, 16, 8, 2,
107     { 0x91, 0x94, 0x5d, 0x3f, 0x4d, 0xcb, 0xee, 0x0b,
108       0xf4, 0x5e, 0xf5, 0x22, 0x55, 0xf0, 0x95, 0xa4 },
109     { 0xbe, 0xca, 0xf0, 0x43, 0xb0, 0xa2, 0x3d, 0x84,
110       0x31, 0x94, 0xba, 0x97, 0x2c, 0x66, 0xde, 0xbd },
111     { 0xfa, 0x3b, 0xfd, 0x48, 0x06, 0xeb, 0x53, 0xfa },
112     { 0xf7, 0xfb },
113     { 0x19, 0xdd },
114     { 0x5c, 0x4c, 0x93, 0x31, 0x04, 0x9d, 0x0b, 0xda,
115       0xb0, 0x27, 0x74, 0x08, 0xf6, 0x79, 0x67, 0xe5 }
116  },
117  {
118     16, 16, 8, 5,
119     { 0x01, 0xf7, 0x4a, 0xd6, 0x40, 0x77, 0xf2, 0xe7,
120       0x04, 0xc0, 0xf6, 0x0a, 0xda, 0x3d, 0xd5, 0x23 },
121     { 0x70, 0xc3, 0xdb, 0x4f, 0x0d, 0x26, 0x36, 0x84,
122       0x00, 0xa1, 0x0e, 0xd0, 0x5d, 0x2b, 0xff, 0x5e },
123     { 0x23, 0x4a, 0x34, 0x63, 0xc1, 0x26, 0x4a, 0xc6 },
124     { 0x1a, 0x47, 0xcb, 0x49, 0x33 },
125     { 0xd8, 0x51, 0xd5, 0xba, 0xe0 },
126     { 0x3a, 0x59, 0xf2, 0x38, 0xa2, 0x3e, 0x39, 0x19,
127       0x9d, 0xc9, 0x26, 0x66, 0x26, 0xc4, 0x0f, 0x80 }
128  }
129  };
130     int err, x, idx, res;
131     unsigned long len;
132     unsigned char outct[MAXBLOCKSIZE], outtag[MAXBLOCKSIZE];
133      if ((idx = find_cipher("aes")) == -1) {
134         if ((idx = find_cipher("rijndael")) == -1) {
135            return CRYPT_NOP;
136         }
137      }
138      for (x = 0; x < (int)(sizeof(tests)/sizeof(tests[0])); x++) {
139          len = sizeof(outtag);
140          if ((err = eax_encrypt_authenticate_memory(idx, tests[x].key, tests[x].keylen,
141              tests[x].nonce, tests[x].noncelen, tests[x].header, tests[x].headerlen,
142              tests[x].plaintext, tests[x].msglen, outct, outtag, &len)) != CRYPT_OK) {
143             return err;
144          }
145          if (compare_testvector(outtag, len, tests[x].tag, len, "EAX Tag", x) ||
146                compare_testvector(outct, tests[x].msglen, tests[x].ciphertext, tests[x].msglen, "EAX CT", x)) {
147             return CRYPT_FAIL_TESTVECTOR;
148          }
149          if ((err = eax_decrypt_verify_memory(idx, tests[x].key, tests[x].keylen,
150               tests[x].nonce, tests[x].noncelen, tests[x].header, tests[x].headerlen,
151               outct, tests[x].msglen, outct, outtag, len, &res)) != CRYPT_OK) {
152              return err;
153          }
154          if ((res != 1) || compare_testvector(outct, tests[x].msglen, tests[x].plaintext, tests[x].msglen, "EAX", x)) {
155  #ifdef LTC_TEST_DBG
156             printf("\n\nEAX: Failure-decrypt - res = %d\n", res);
157  #endif
158             return CRYPT_FAIL_TESTVECTOR;
159          }
160      }
161      return CRYPT_OK;
162  #endif &bsol;* LTC_TEST */
163  }
164  #endif &bsol;* LTC_EAX_MODE */
</code></pre>
        </div>
        <div class="column">
            <h3>libfuse-MDEwOlJlcG9zaXRvcnk0ODI5NjE3Nw==-flat-fusermount.c</h3>
            <pre><code>1  #define _GNU_SOURCE &bsol;* for clone and strchrnul */
2  #include "fuse_config.h"
3  #include "mount_util.h"
4  #include <stdio.h>
5  #include <stdlib.h>
6  #include <string.h>
7  #include <ctype.h>
8  #include <unistd.h>
9  #include <getopt.h>
10  #include <errno.h>
11  #include <fcntl.h>
12  #include <pwd.h>
13  #include <paths.h>
14  #include <mntent.h>
15  #include <sys/wait.h>
16  #include <sys/stat.h>
17  #include "fuse_mount_compat.h"
18  #include <sys/fsuid.h>
19  #include <sys/socket.h>
20  #include <sys/utsname.h>
21  #include <sched.h>
22  #include <stdbool.h>
23  #include <sys/vfs.h>
24  #define FUSE_COMMFD_ENV		"_FUSE_COMMFD"
25  #define FUSE_DEV "/dev/fuse"
26  static const char *progname;
27  static int user_allow_other = 0;
28  static int mount_max = 1000;
29  static int auto_unmount = 0;
30  #ifdef GETMNTENT_NEEDS_UNESCAPING
31  static void unescape(char *buf) {
32  	char *src = buf;
33  	char *dest = buf;
34  	while (1) {
35  		char *next_src = strchrnul(src, '\\');
36  		int offset = next_src - src;
37  		memmove(dest, src, offset);
38  		src = next_src;
39  		dest += offset;
40  		if(*src == '\0') {
41  			*dest = *src;
42  			return;
43  		}
44  		src++;
45  		if('0' <= src[0] && src[0] < '2' &&
46  		   '0' <= src[1] && src[1] < '8' &&
47  		   '0' <= src[2] && src[2] < '8') {
48  			*dest++ = (src[0] - '0') << 6
49  			        | (src[1] - '0') << 3
50  			        | (src[2] - '0') << 0;
51  			src += 3;
52  		} else if (src[0] == '\\') {
53  			*dest++ = '\\';
54  			src += 1;
55  		} else {
56  			*dest++ = '\\';
57  		}
58  	}
59  }
60  static struct mntent *GETMNTENT(FILE *stream)
61  {
62  	struct mntent *entp = getmntent(stream);
63  	if(entp != NULL) {
64  		unescape(entp->mnt_fsname);
65  		unescape(entp->mnt_dir);
66  		unescape(entp->mnt_type);
67  		unescape(entp->mnt_opts);
68  	}
69  	return entp;
70  }
71  #else
72  #define GETMNTENT getmntent
73  #endif 
74  static const char *get_user_name(void)
75  {
76  	struct passwd *pw = getpwuid(getuid());
77  	if (pw != NULL && pw->pw_name != NULL)
78  		return pw->pw_name;
79  	else {
80  		fprintf(stderr, "%s: could not determine username\n", progname);
81  		return NULL;
82  	}
83  }
84  static uid_t oldfsuid;
85  static gid_t oldfsgid;
86  static void drop_privs(void)
87  {
88  	if (getuid() != 0) {
89  		oldfsuid = setfsuid(getuid());
90  		oldfsgid = setfsgid(getgid());
91  	}
92  }
93  static void restore_privs(void)
94  {
95  	if (getuid() != 0) {
96  		setfsuid(oldfsuid);
97  		setfsgid(oldfsgid);
98  	}
99  }
100  #ifndef IGNORE_MTAB
101  static int lock_umount(void)
102  {
103  	const char *mtab_lock = _PATH_MOUNTED ".fuselock";
104  	int mtablock;
105  	int res;
106  	struct stat mtab_stat;
107  	if (lstat(_PATH_MOUNTED, &mtab_stat) == 0 && S_ISLNK(mtab_stat.st_mode))
108  		return -1;
109  	mtablock = open(mtab_lock, O_RDWR | O_CREAT, 0600);
110  	if (mtablock == -1) {
111  		fprintf(stderr, "%s: unable to open fuse lock file: %s\n",
112  			progname, strerror(errno));
113  		return -1;
114  	}
115  	res = lockf(mtablock, F_LOCK, 0);
116  	if (res < 0) {
117  		fprintf(stderr, "%s: error getting lock: %s\n", progname,
118  			strerror(errno));
119  		close(mtablock);
120  		return -1;
121  	}
122  	return mtablock;
123  }
124  static void unlock_umount(int mtablock)
125  {
126  	if (mtablock >= 0) {
127  		int res;
128  		res = lockf(mtablock, F_ULOCK, 0);
129  		if (res < 0) {
130  			fprintf(stderr, "%s: error releasing lock: %s\n",
131  				progname, strerror(errno));
132  		}
133  		close(mtablock);
134  	}
135  }
136  static int add_mount(const char *source, const char *mnt, const char *type,
137  		     const char *opts)
138  {
139  	return fuse_mnt_add_mount(progname, source, mnt, type, opts);
140  }
141  static int may_unmount(const char *mnt, int quiet)
142  {
143  	struct mntent *entp;
144  	FILE *fp;
145  	const char *user = NULL;
146  	char uidstr[32];
147  	unsigned uidlen = 0;
148  	int found;
149  	const char *mtab = _PATH_MOUNTED;
150  	user = get_user_name();
151  	if (user == NULL)
152  		return -1;
153  	fp = setmntent(mtab, "r");
154  	if (fp == NULL) {
155  		fprintf(stderr, "%s: failed to open %s: %s\n", progname, mtab,
156  			strerror(errno));
157  		return -1;
158  	}
159  	uidlen = sprintf(uidstr, "%u", getuid());
160  	found = 0;
161  	while ((entp = GETMNTENT(fp)) != NULL) {
162  		if (!found && strcmp(entp->mnt_dir, mnt) == 0 &&
163  		    (strcmp(entp->mnt_type, "fuse") == 0 ||
164  		     strcmp(entp->mnt_type, "fuseblk") == 0 ||
165  		     strncmp(entp->mnt_type, "fuse.", 5) == 0 ||
166  		     strncmp(entp->mnt_type, "fuseblk.", 8) == 0)) {
167  			char *p = strstr(entp->mnt_opts, "user=");
168  			if (p &&
169  			    (p == entp->mnt_opts || *(p-1) == ',') &&
170  			    strcmp(p + 5, user) == 0) {
171  				found = 1;
172  				break;
173  			}
174  			else if ((p =
175  				  strstr(entp->mnt_opts, "user_id=")) &&
176  				 (p == entp->mnt_opts ||
177  				  *(p-1) == ',') &&
178  				 strncmp(p + 8, uidstr, uidlen) == 0 &&
179  				 (*(p+8+uidlen) == ',' ||
180  				  *(p+8+uidlen) == '\0')) {
181  				found = 1;
182  				break;
183  			}
184  		}
185  	}
186  	endmntent(fp);
187  	if (!found) {
188  		if (!quiet)
189  			fprintf(stderr,
190  				"%s: entry for %s not found in %s\n",
191  				progname, mnt, mtab);
192  		return -1;
193  	}
194  	return 0;
195  }
196  #endif
197  static int check_is_mount_child(void *p)
198  {
199  	const char **a = p;
200  	const char *last = a[0];
201  	const char *mnt = a[1];
202  	const char *type = a[2];
203  	int res;
204  	const char *procmounts = "/proc/mounts";
205  	int found;
206  	FILE *fp;
207  	struct mntent *entp;
208  	int count;
209  	res = mount("", "/", "", MS_PRIVATE | MS_REC, NULL);
210  	if (res == -1) {
211  		fprintf(stderr, "%s: failed to mark mounts private: %s\n",
212  			progname, strerror(errno));
213  		return 1;
214  	}
215  	fp = setmntent(procmounts, "r");
216  	if (fp == NULL) {
217  		fprintf(stderr, "%s: failed to open %s: %s\n", progname,
218  			procmounts, strerror(errno));
219  		return 1;
220  	}
221  	count = 0;
222  	while (GETMNTENT(fp) != NULL)
223  		count++;
224  	endmntent(fp);
225  	fp = setmntent(procmounts, "r");
226  	if (fp == NULL) {
227  		fprintf(stderr, "%s: failed to open %s: %s\n", progname,
228  			procmounts, strerror(errno));
229  		return 1;
230  	}
231  	res = mount(".", "/", "", MS_BIND | MS_REC, NULL);
232  	if (res == -1) {
233  		fprintf(stderr, "%s: failed to bind parent to /: %s\n",
234  			progname, strerror(errno));
235  		return 1;
236  	}
237  	found = 0;
238  	while ((entp = GETMNTENT(fp)) != NULL) {
239  		if (count > 0) {
240  			count--;
241  			continue;
242  		}
243  		if (entp->mnt_dir[0] == '/' &&
244  		    strcmp(entp->mnt_dir + 1, last) == 0 &&
245  		    (!type || strcmp(entp->mnt_type, type) == 0)) {
246  			found = 1;
247  			break;
248  		}
249  	}
250  	endmntent(fp);
251  	if (!found) {
252  		fprintf(stderr, "%s: %s not mounted\n", progname, mnt);
253  		return 1;
254  	}
255  	return 0;
256  }
257  static pid_t clone_newns(void *a)
258  {
259  	char buf[131072];
260  	char *stack = buf + (sizeof(buf) / 2 - ((size_t) buf & 15));
261  #ifdef __ia64__
262  	extern int __clone2(int (*fn)(void *),
263  			    void *child_stack_base, size_t stack_size,
264  			    int flags, void *arg, pid_t *ptid,
265  			    void *tls, pid_t *ctid);
266  	return __clone2(check_is_mount_child, stack, sizeof(buf) / 2,
267  			CLONE_NEWNS, a, NULL, NULL, NULL);
268  #else
269  	return clone(check_is_mount_child, stack, CLONE_NEWNS, a);
270  #endif
271  }
272  static int check_is_mount(const char *last, const char *mnt, const char *type)
273  {
274  	pid_t pid, p;
275  	int status;
276  	const char *a[3] = { last, mnt, type };
277  	pid = clone_newns((void *) a);
278  	if (pid == (pid_t) -1) {
279  		fprintf(stderr, "%s: failed to clone namespace: %s\n",
280  			progname, strerror(errno));
281  		return -1;
282  	}
283  	p = waitpid(pid, &status, __WCLONE);
284  	if (p == (pid_t) -1) {
285  		fprintf(stderr, "%s: waitpid failed: %s\n",
286  			progname, strerror(errno));
287  		return -1;
288  	}
289  	if (!WIFEXITED(status)) {
290  		fprintf(stderr, "%s: child terminated abnormally (status %i)\n",
291  			progname, status);
292  		return -1;
293  	}
294  	if (WEXITSTATUS(status) != 0)
295  		return -1;
296  	return 0;
297  }
298  static int chdir_to_parent(char *copy, const char **lastp)
299  {
300  	char *tmp;
301  	const char *parent;
302  	char buf[65536];
303  	int res;
304  	tmp = strrchr(copy, '/');
305  	if (tmp == NULL || tmp[1] == '\0') {
306  		fprintf(stderr, "%s: internal error: invalid abs path: <%s>\n",
307  			progname, copy);
308  		return -1;
309  	}
310  	if (tmp != copy) {
311  		*tmp = '\0';
312  		parent = copy;
313  		*lastp = tmp + 1;
314  	} else if (tmp[1] != '\0') {
315  		*lastp = tmp + 1;
316  		parent = "/";
317  	} else {
318  		*lastp = ".";
319  		parent = "/";
320  	}
321  	res = chdir(parent);
322  	if (res == -1) {
323  		fprintf(stderr, "%s: failed to chdir to %s: %s\n",
324  			progname, parent, strerror(errno));
325  		return -1;
326  	}
327  	if (getcwd(buf, sizeof(buf)) == NULL) {
328  		fprintf(stderr, "%s: failed to obtain current directory: %s\n",
329  			progname, strerror(errno));
330  		return -1;
331  	}
332  	if (strcmp(buf, parent) != 0) {
333  		fprintf(stderr, "%s: mountpoint moved (%s -> %s)\n", progname,
334  			parent, buf);
335  		return -1;
336  	}
337  	return 0;
338  }
339  #ifndef IGNORE_MTAB
340  static int unmount_fuse_locked(const char *mnt, int quiet, int lazy)
341  {
342  	int res;
343  	char *copy;
344  	const char *last;
345  	int umount_flags = (lazy ? UMOUNT_DETACH : 0) | UMOUNT_NOFOLLOW;
346  	if (getuid() != 0) {
347  		res = may_unmount(mnt, quiet);
348  		if (res == -1)
349  			return -1;
350  	}
351  	copy = strdup(mnt);
352  	if (copy == NULL) {
353  		fprintf(stderr, "%s: failed to allocate memory\n", progname);
354  		return -1;
355  	}
356  	drop_privs();
357  	res = chdir_to_parent(copy, &last);
358  	restore_privs();
359  	if (res == -1)
360  		goto out;
361  	res = umount2(last, umount_flags);
362  	if (res == -1 && !quiet) {
363  		fprintf(stderr, "%s: failed to unmount %s: %s\n",
364  			progname, mnt, strerror(errno));
365  	}
366  out:
367  	free(copy);
368  	if (res == -1)
369  		return -1;
370  	res = chdir("/");
371  	if (res == -1) {
372  		fprintf(stderr, "%s: failed to chdir to '/'\n", progname);
373  		return -1;
374  	}
375  	return fuse_mnt_remove_mount(progname, mnt);
376  }
377  static int unmount_fuse(const char *mnt, int quiet, int lazy)
378  {
379  	int res;
380  	int mtablock = lock_umount();
381  	res = unmount_fuse_locked(mnt, quiet, lazy);
382  	unlock_umount(mtablock);
383  	return res;
384  }
385  static int count_fuse_fs(void)
386  {
387  	struct mntent *entp;
388  	int count = 0;
389  	const char *mtab = _PATH_MOUNTED;
390  	FILE *fp = setmntent(mtab, "r");
391  	if (fp == NULL) {
392  		fprintf(stderr, "%s: failed to open %s: %s\n", progname, mtab,
393  			strerror(errno));
394  		return -1;
395  	}
396  	while ((entp = GETMNTENT(fp)) != NULL) {
397  		if (strcmp(entp->mnt_type, "fuse") == 0 ||
398  		    strncmp(entp->mnt_type, "fuse.", 5) == 0)
399  			count ++;
400  	}
401  	endmntent(fp);
402  	return count;
403  }
404  #else &bsol;* IGNORE_MTAB */
405  static int count_fuse_fs(void)
406  {
407  	return 0;
408  }
409  static int add_mount(const char *source, const char *mnt, const char *type,
410  		     const char *opts)
411  {
412  	(void) source;
413  	(void) mnt;
414  	(void) type;
415  	(void) opts;
416  	return 0;
417  }
418  static int unmount_fuse(const char *mnt, int quiet, int lazy)
419  {
420  	(void) quiet;
421  	return fuse_mnt_umount(progname, mnt, mnt, lazy);
422  }
423  #endif &bsol;* IGNORE_MTAB */
424  static void strip_line(char *line)
425  {
426  	char *s = strchr(line, '#');
427  	if (s != NULL)
428  		s[0] = '\0';
429  	for (s = line + strlen(line) - 1;
430  	     s >= line && isspace((unsigned char) *s); s--);
431  	s[1] = '\0';
432  	for (s = line; isspace((unsigned char) *s); s++);
433  	if (s != line)
434  		memmove(line, s, strlen(s)+1);
435  }
436  static void parse_line(char *line, int linenum)
437  {
438  	int tmp;
439  	if (strcmp(line, "user_allow_other") == 0)
440  		user_allow_other = 1;
441  	else if (sscanf(line, "mount_max = %i", &tmp) == 1)
442  		mount_max = tmp;
443  	else if(line[0])
444  		fprintf(stderr,
445  			"%s: unknown parameter in %s at line %i: '%s'\n",
446  			progname, FUSE_CONF, linenum, line);
447  }
448  static void read_conf(void)
449  {
450  	FILE *fp = fopen(FUSE_CONF, "r");
451  	if (fp != NULL) {
452  		int linenum = 1;
453  		char line[256];
454  		int isnewline = 1;
455  		while (fgets(line, sizeof(line), fp) != NULL) {
456  			if (isnewline) {
457  				if (line[strlen(line)-1] == '\n') {
458  					strip_line(line);
459  					parse_line(line, linenum);
460  				} else {
461  					isnewline = 0;
462  				}
463  			} else if(line[strlen(line)-1] == '\n') {
464  				fprintf(stderr, "%s: reading %s: line %i too long\n", progname, FUSE_CONF, linenum);
465  				isnewline = 1;
466  			}
467  			if (isnewline)
468  				linenum ++;
469  		}
470  		if (!isnewline) {
471  			fprintf(stderr, "%s: reading %s: missing newline at end of file\n", progname, FUSE_CONF);
472  		}
473  		if (ferror(fp)) {
474  			fprintf(stderr, "%s: reading %s: read failed\n", progname, FUSE_CONF);
475  			exit(1);
476  		}
477  		fclose(fp);
478  	} else if (errno != ENOENT) {
479  		bool fatal = (errno != EACCES && errno != ELOOP &&
480  			      errno != ENAMETOOLONG && errno != ENOTDIR &&
481  			      errno != EOVERFLOW);
482  		fprintf(stderr, "%s: failed to open %s: %s\n",
483  			progname, FUSE_CONF, strerror(errno));
484  		if (fatal)
485  			exit(1);
486  	}
487  }
488  static int begins_with(const char *s, const char *beg)
489  {
490  	if (strncmp(s, beg, strlen(beg)) == 0)
491  		return 1;
492  	else
493  		return 0;
494  }
495  struct mount_flags {
496  	const char *opt;
497  	unsigned long flag;
498  	int on;
499  	int safe;
500  };
<span onclick='openModal()' class='match'>501  static struct mount_flags mount_flags[] = {
502  	{"rw",	    MS_RDONLY,	    0, 1},
503  	{"ro",	    MS_RDONLY,	    1, 1},
504  	{"suid",    MS_NOSUID,	    0, 0},
505  	{"nosuid",  MS_NOSUID,	    1, 1},
506  	{"dev",	    MS_NODEV,	    0, 0},
507  	{"nodev",   MS_NODEV,	    1, 1},
</span>508  	{"exec",    MS_NOEXEC,	    0, 1},
509  	{"noexec",  MS_NOEXEC,	    1, 1},
510  	{"async",   MS_SYNCHRONOUS, 0, 1},
511  	{"sync",    MS_SYNCHRONOUS, 1, 1},
512  	{"atime",   MS_NOATIME,	    0, 1},
513  	{"noatime", MS_NOATIME,	    1, 1},
514  	{"diratime",        MS_NODIRATIME,  0, 1},
515  	{"nodiratime",      MS_NODIRATIME,  1, 1},
516  	{"lazytime",        MS_LAZYTIME,    1, 1},
517  	{"nolazytime",      MS_LAZYTIME,    0, 1},
518  	{"relatime",        MS_RELATIME,    1, 1},
519  	{"norelatime",      MS_RELATIME,    0, 1},
520  	{"strictatime",     MS_STRICTATIME, 1, 1},
521  	{"nostrictatime",   MS_STRICTATIME, 0, 1},
522  	{"dirsync", MS_DIRSYNC,	    1, 1},
523  	{NULL,	    0,		    0, 0}
524  };
525  static int find_mount_flag(const char *s, unsigned len, int *on, int *flag)
526  {
527  	int i;
528  	for (i = 0; mount_flags[i].opt != NULL; i++) {
529  		const char *opt = mount_flags[i].opt;
530  		if (strlen(opt) == len && strncmp(opt, s, len) == 0) {
531  			*on = mount_flags[i].on;
532  			*flag = mount_flags[i].flag;
533  			if (!mount_flags[i].safe && getuid() != 0) {
534  				*flag = 0;
535  				fprintf(stderr,
536  					"%s: unsafe option %s ignored\n",
537  					progname, opt);
538  			}
539  			return 1;
540  		}
541  	}
542  	return 0;
543  }
544  static int add_option(char **optsp, const char *opt, unsigned expand)
545  {
546  	char *newopts;
547  	if (*optsp == NULL)
548  		newopts = strdup(opt);
549  	else {
550  		unsigned oldsize = strlen(*optsp);
551  		unsigned newsize = oldsize + 1 + strlen(opt) + expand + 1;
552  		newopts = (char *) realloc(*optsp, newsize);
553  		if (newopts)
554  			sprintf(newopts + oldsize, ",%s", opt);
555  	}
556  	if (newopts == NULL) {
557  		fprintf(stderr, "%s: failed to allocate memory\n", progname);
558  		return -1;
559  	}
560  	*optsp = newopts;
561  	return 0;
562  }
563  static int get_mnt_opts(int flags, char *opts, char **mnt_optsp)
564  {
565  	int i;
566  	int l;
567  	if (!(flags & MS_RDONLY) && add_option(mnt_optsp, "rw", 0) == -1)
568  		return -1;
569  	for (i = 0; mount_flags[i].opt != NULL; i++) {
570  		if (mount_flags[i].on && (flags & mount_flags[i].flag) &&
571  		    add_option(mnt_optsp, mount_flags[i].opt, 0) == -1)
572  			return -1;
573  	}
574  	if (add_option(mnt_optsp, opts, 0) == -1)
575  		return -1;
576  	l = strlen(*mnt_optsp);
577  	if ((*mnt_optsp)[l-1] == ',')
578  		(*mnt_optsp)[l-1] = '\0';
579  	if (getuid() != 0) {
580  		const char *user = get_user_name();
581  		if (user == NULL)
582  			return -1;
583  		if (add_option(mnt_optsp, "user=", strlen(user)) == -1)
584  			return -1;
585  		strcat(*mnt_optsp, user);
586  	}
587  	return 0;
588  }
589  static int opt_eq(const char *s, unsigned len, const char *opt)
590  {
591  	if(strlen(opt) == len && strncmp(s, opt, len) == 0)
592  		return 1;
593  	else
594  		return 0;
595  }
596  static int get_string_opt(const char *s, unsigned len, const char *opt,
597  			  char **val)
598  {
599  	int i;
600  	unsigned opt_len = strlen(opt);
601  	char *d;
602  	if (*val)
603  		free(*val);
604  	*val = (char *) malloc(len - opt_len + 1);
605  	if (!*val) {
606  		fprintf(stderr, "%s: failed to allocate memory\n", progname);
607  		return 0;
608  	}
609  	d = *val;
610  	s += opt_len;
611  	len -= opt_len;
612  	for (i = 0; i < len; i++) {
613  		if (s[i] == '\\' && i + 1 < len)
614  			i++;
615  		*d++ = s[i];
616  	}
617  	*d = '\0';
618  	return 1;
619  }
620  static int mount_notrunc(const char *source, const char *target,
621  			 const char *filesystemtype, unsigned long mountflags,
622  			 const char *data) {
623  	if (strlen(data) > sysconf(_SC_PAGESIZE) - 1) {
624  		fprintf(stderr, "%s: mount options too long\n", progname);
625  		errno = EINVAL;
626  		return -1;
627  	}
628  	return mount(source, target, filesystemtype, mountflags, data);
629  }
630  static int do_mount(const char *mnt, const char **typep, mode_t rootmode,
631  		    int fd, const char *opts, const char *dev, char **sourcep,
632  		    char **mnt_optsp)
633  {
634  	int res;
635  	int flags = MS_NOSUID | MS_NODEV;
636  	char *optbuf;
637  	char *mnt_opts = NULL;
638  	const char *s;
639  	char *d;
640  	char *fsname = NULL;
641  	char *subtype = NULL;
642  	char *source = NULL;
643  	char *type = NULL;
644  	int blkdev = 0;
645  	optbuf = (char *) malloc(strlen(opts) + 128);
646  	if (!optbuf) {
647  		fprintf(stderr, "%s: failed to allocate memory\n", progname);
648  		return -1;
649  	}
650  	for (s = opts, d = optbuf; *s;) {
651  		unsigned len;
652  		const char *fsname_str = "fsname=";
653  		const char *subtype_str = "subtype=";
654  		bool escape_ok = begins_with(s, fsname_str) ||
655  				 begins_with(s, subtype_str);
656  		for (len = 0; s[len]; len++) {
657  			if (escape_ok && s[len] == '\\' && s[len + 1])
658  				len++;
659  			else if (s[len] == ',')
660  				break;
661  		}
662  		if (begins_with(s, fsname_str)) {
663  			if (!get_string_opt(s, len, fsname_str, &fsname))
664  				goto err;
665  		} else if (begins_with(s, subtype_str)) {
666  			if (!get_string_opt(s, len, subtype_str, &subtype))
667  				goto err;
668  		} else if (opt_eq(s, len, "blkdev")) {
669  			if (getuid() != 0) {
670  				fprintf(stderr,
671  					"%s: option blkdev is privileged\n",
672  					progname);
673  				goto err;
674  			}
675  			blkdev = 1;
676  		} else if (opt_eq(s, len, "auto_unmount")) {
677  			auto_unmount = 1;
678  		} else if (!opt_eq(s, len, "nonempty") &&
679  			   !begins_with(s, "fd=") &&
680  			   !begins_with(s, "rootmode=") &&
681  			   !begins_with(s, "user_id=") &&
682  			   !begins_with(s, "group_id=")) {
683  			int on;
684  			int flag;
685  			int skip_option = 0;
686  			if (opt_eq(s, len, "large_read")) {
687  				struct utsname utsname;
688  				unsigned kmaj, kmin;
689  				res = uname(&utsname);
690  				if (res == 0 &&
691  				    sscanf(utsname.release, "%u.%u",
692  					   &kmaj, &kmin) == 2 &&
693  				    (kmaj > 2 || (kmaj == 2 && kmin > 4))) {
694  					fprintf(stderr, "%s: note: 'large_read' mount option is deprecated for %i.%i kernels\n", progname, kmaj, kmin);
695  					skip_option = 1;
696  				}
697  			}
698  			if (getuid() != 0 && !user_allow_other &&
699  			    (opt_eq(s, len, "allow_other") ||
700  			     opt_eq(s, len, "allow_root"))) {
701  				fprintf(stderr, "%s: option %.*s only allowed if 'user_allow_other' is set in %s\n", progname, len, s, FUSE_CONF);
702  				goto err;
703  			}
704  			if (!skip_option) {
705  				if (find_mount_flag(s, len, &on, &flag)) {
706  					if (on)
707  						flags |= flag;
708  					else
709  						flags  &= ~flag;
710  				} else if (opt_eq(s, len, "default_permissions") ||
711  					   opt_eq(s, len, "allow_other") ||
712  					   begins_with(s, "max_read=") ||
713  					   begins_with(s, "blksize=")) {
714  					memcpy(d, s, len);
715  					d += len;
716  					*d++ = ',';
717  				} else {
718  					fprintf(stderr, "%s: unknown option '%.*s'\n", progname, len, s);
719  					exit(1);
720  				}
721  			}
722  		}
723  		s += len;
724  		if (*s)
725  			s++;
726  	}
727  	*d = '\0';
728  	res = get_mnt_opts(flags, optbuf, &mnt_opts);
729  	if (res == -1)
730  		goto err;
731  	sprintf(d, "fd=%i,rootmode=%o,user_id=%u,group_id=%u",
732  		fd, rootmode, getuid(), getgid());
733  	source = malloc((fsname ? strlen(fsname) : 0) +
734  			(subtype ? strlen(subtype) : 0) + strlen(dev) + 32);
735  	type = malloc((subtype ? strlen(subtype) : 0) + 32);
736  	if (!type || !source) {
737  		fprintf(stderr, "%s: failed to allocate memory\n", progname);
738  		goto err;
739  	}
740  	if (subtype)
741  		sprintf(type, "%s.%s", blkdev ? "fuseblk" : "fuse", subtype);
742  	else
743  		strcpy(type, blkdev ? "fuseblk" : "fuse");
744  	if (fsname)
745  		strcpy(source, fsname);
746  	else
747  		strcpy(source, subtype ? subtype : dev);
748  	res = mount_notrunc(source, mnt, type, flags, optbuf);
749  	if (res == -1 && errno == ENODEV && subtype) {
750  		strcpy(type, blkdev ? "fuseblk" : "fuse");
751  		if (fsname) {
752  			if (!blkdev)
753  				sprintf(source, "%s#%s", subtype, fsname);
754  		} else {
755  			strcpy(source, type);
756  		}
757  		res = mount_notrunc(source, mnt, type, flags, optbuf);
758  	}
759  	if (res == -1 && errno == EINVAL) {
760  		sprintf(d, "fd=%i,rootmode=%o,user_id=%u",
761  			fd, rootmode, getuid());
762  		res = mount_notrunc(source, mnt, type, flags, optbuf);
763  	}
764  	if (res == -1) {
765  		int errno_save = errno;
766  		if (blkdev && errno == ENODEV && !fuse_mnt_check_fuseblk())
767  			fprintf(stderr, "%s: 'fuseblk' support missing\n",
768  				progname);
769  		else
770  			fprintf(stderr, "%s: mount failed: %s\n", progname,
771  				strerror(errno_save));
772  		goto err;
773  	}
774  	*sourcep = source;
775  	*typep = type;
776  	*mnt_optsp = mnt_opts;
777  	free(fsname);
778  	free(optbuf);
779  	return 0;
780  err:
781  	free(fsname);
782  	free(subtype);
783  	free(source);
784  	free(type);
785  	free(mnt_opts);
786  	free(optbuf);
787  	return -1;
788  }
789  static int check_perm(const char **mntp, struct stat *stbuf, int *mountpoint_fd)
790  {
791  	int res;
792  	const char *mnt = *mntp;
793  	const char *origmnt = mnt;
794  	struct statfs fs_buf;
795  	size_t i;
796  	res = lstat(mnt, stbuf);
797  	if (res == -1) {
798  		fprintf(stderr, "%s: failed to access mountpoint %s: %s\n",
799  			progname, mnt, strerror(errno));
800  		return -1;
801  	}
802  	if (getuid() == 0)
803  		return 0;
804  	if (S_ISDIR(stbuf->st_mode)) {
805  		res = chdir(mnt);
806  		if (res == -1) {
807  			fprintf(stderr,
808  				"%s: failed to chdir to mountpoint: %s\n",
809  				progname, strerror(errno));
810  			return -1;
811  		}
812  		mnt = *mntp = ".";
813  		res = lstat(mnt, stbuf);
814  		if (res == -1) {
815  			fprintf(stderr,
816  				"%s: failed to access mountpoint %s: %s\n",
817  				progname, origmnt, strerror(errno));
818  			return -1;
819  		}
820  		if ((stbuf->st_mode & S_ISVTX) && stbuf->st_uid != getuid()) {
821  			fprintf(stderr, "%s: mountpoint %s not owned by user\n",
822  				progname, origmnt);
823  			return -1;
824  		}
825  		res = access(mnt, W_OK);
826  		if (res == -1) {
827  			fprintf(stderr, "%s: user has no write access to mountpoint %s\n",
828  				progname, origmnt);
829  			return -1;
830  		}
831  	} else if (S_ISREG(stbuf->st_mode)) {
832  		static char procfile[256];
833  		*mountpoint_fd = open(mnt, O_WRONLY);
834  		if (*mountpoint_fd == -1) {
835  			fprintf(stderr, "%s: failed to open %s: %s\n",
836  				progname, mnt, strerror(errno));
837  			return -1;
838  		}
839  		res = fstat(*mountpoint_fd, stbuf);
840  		if (res == -1) {
841  			fprintf(stderr,
842  				"%s: failed to access mountpoint %s: %s\n",
843  				progname, mnt, strerror(errno));
844  			return -1;
845  		}
846  		if (!S_ISREG(stbuf->st_mode)) {
847  			fprintf(stderr,
848  				"%s: mountpoint %s is no longer a regular file\n",
849  				progname, mnt);
850  			return -1;
851  		}
852  		sprintf(procfile, "/proc/self/fd/%i", *mountpoint_fd);
853  		*mntp = procfile;
854  	} else {
855  		fprintf(stderr,
856  			"%s: mountpoint %s is not a directory or a regular file\n",
857  			progname, mnt);
858  		return -1;
859  	}
860  	if (statfs(*mntp, &fs_buf)) {
861  		fprintf(stderr, "%s: failed to access mountpoint %s: %s\n",
862  			progname, mnt, strerror(errno));
863  		return -1;
864  	}
865  	typeof(fs_buf.f_type) f_type_whitelist[] = {
866  		0x61756673 &bsol;* AUFS_SUPER_MAGIC */,
867  		0x00000187 &bsol;* AUTOFS_SUPER_MAGIC */,
868  		0xCA451A4E &bsol;* BCACHEFS_STATFS_MAGIC */,
869  		0x9123683E &bsol;* BTRFS_SUPER_MAGIC */,
870  		0x00C36400 &bsol;* CEPH_SUPER_MAGIC */,
871  		0xFF534D42 &bsol;* CIFS_MAGIC_NUMBER */,
872  		0x0000F15F &bsol;* ECRYPTFS_SUPER_MAGIC */,
873  		0X2011BAB0 &bsol;* EXFAT_SUPER_MAGIC */,
874  		0x0000EF53 &bsol;* EXT[234]_SUPER_MAGIC */,
875  		0xF2F52010 &bsol;* F2FS_SUPER_MAGIC */,
876  		0x65735546 &bsol;* FUSE_SUPER_MAGIC */,
877  		0x01161970 &bsol;* GFS2_MAGIC */,
878  		0x47504653 &bsol;* GPFS_SUPER_MAGIC */,
879  		0x0000482b &bsol;* HFSPLUS_SUPER_MAGIC */,
880  		0x000072B6 &bsol;* JFFS2_SUPER_MAGIC */,
881  		0x3153464A &bsol;* JFS_SUPER_MAGIC */,
882  		0x0BD00BD0 &bsol;* LL_SUPER_MAGIC */,
883  		0X00004D44 &bsol;* MSDOS_SUPER_MAGIC */,
884  		0x0000564C &bsol;* NCP_SUPER_MAGIC */,
885  		0x00006969 &bsol;* NFS_SUPER_MAGIC */,
886  		0x00003434 &bsol;* NILFS_SUPER_MAGIC */,
887  		0x5346544E &bsol;* NTFS_SB_MAGIC */,
888  		0x5346414f &bsol;* OPENAFS_SUPER_MAGIC */,
889  		0x794C7630 &bsol;* OVERLAYFS_SUPER_MAGIC */,
890  		0x52654973 &bsol;* REISERFS_SUPER_MAGIC */,
891  		0xFE534D42 &bsol;* SMB2_SUPER_MAGIC */,
892  		0x73717368 &bsol;* SQUASHFS_MAGIC */,
893  		0x01021994 &bsol;* TMPFS_MAGIC */,
894  		0x24051905 &bsol;* UBIFS_SUPER_MAGIC */,
895  		0x736675005346544e &bsol;* UFSD */,
896  		0x58465342 &bsol;* XFS_SB_MAGIC */,
897  		0x2FC12FC1 &bsol;* ZFS_SUPER_MAGIC */,
898  	};
899  	for (i = 0; i < sizeof(f_type_whitelist)/sizeof(f_type_whitelist[0]); i++) {
900  		if (f_type_whitelist[i] == fs_buf.f_type)
901  			return 0;
902  	}
903  	fprintf(stderr, "%s: mounting over filesystem type %#010lx is forbidden\n",
904  		progname, (unsigned long)fs_buf.f_type);
905  	return -1;
906  }
907  static int try_open(const char *dev, char **devp, int silent)
908  {
909  	int fd = open(dev, O_RDWR);
910  	if (fd != -1) {
911  		*devp = strdup(dev);
912  		if (*devp == NULL) {
913  			fprintf(stderr, "%s: failed to allocate memory\n",
914  				progname);
915  			close(fd);
916  			fd = -1;
917  		}
918  	} else if (errno == ENODEV ||
919  		   errno == ENOENT)&bsol;* check for ENOENT too, for the udev case */
920  		return -2;
921  	else if (!silent) {
922  		fprintf(stderr, "%s: failed to open %s: %s\n", progname, dev,
923  			strerror(errno));
924  	}
925  	return fd;
926  }
927  static int try_open_fuse_device(char **devp)
928  {
929  	int fd;
930  	drop_privs();
931  	fd = try_open(FUSE_DEV, devp, 0);
932  	restore_privs();
933  	return fd;
934  }
935  static int open_fuse_device(char **devp)
936  {
937  	int fd = try_open_fuse_device(devp);
938  	if (fd >= -1)
939  		return fd;
940  	fprintf(stderr,
941  		"%s: fuse device not found, try 'modprobe fuse' first\n",
942  		progname);
943  	return -1;
944  }
945  static int mount_fuse(const char *mnt, const char *opts, const char **type)
946  {
947  	int res;
948  	int fd;
949  	char *dev;
950  	struct stat stbuf;
951  	char *source = NULL;
952  	char *mnt_opts = NULL;
953  	const char *real_mnt = mnt;
954  	int mountpoint_fd = -1;
955  	fd = open_fuse_device(&dev);
956  	if (fd == -1)
957  		return -1;
958  	drop_privs();
959  	read_conf();
960  	if (getuid() != 0 && mount_max != -1) {
961  		int mount_count = count_fuse_fs();
962  		if (mount_count >= mount_max) {
963  			fprintf(stderr, "%s: too many FUSE filesystems mounted; mount_max=N can be set in %s\n", progname, FUSE_CONF);
964  			goto fail_close_fd;
965  		}
966  	}
967  	res = check_perm(&real_mnt, &stbuf, &mountpoint_fd);
968  	restore_privs();
969  	if (res != -1)
970  		res = do_mount(real_mnt, type, stbuf.st_mode & S_IFMT,
971  			       fd, opts, dev, &source, &mnt_opts);
972  	if (mountpoint_fd != -1)
973  		close(mountpoint_fd);
974  	if (res == -1)
975  		goto fail_close_fd;
976  	res = chdir("/");
977  	if (res == -1) {
978  		fprintf(stderr, "%s: failed to chdir to '/'\n", progname);
979  		goto fail_close_fd;
980  	}
981  	if (geteuid() == 0) {
982  		res = add_mount(source, mnt, *type, mnt_opts);
983  		if (res == -1) {
984  			goto fail_close_fd;
985  		}
986  	}
987  out_free:
988  	free(source);
989  	free(mnt_opts);
990  	free(dev);
991  	return fd;
992  fail_close_fd:
993  	close(fd);
994  	fd = -1;
995  	goto out_free;
996  }
997  static int send_fd(int sock_fd, int fd)
998  {
999  	int retval;
1000  	struct msghdr msg;
1001  	struct cmsghdr *p_cmsg;
1002  	struct iovec vec;
1003  	size_t cmsgbuf[CMSG_SPACE(sizeof(fd)) / sizeof(size_t)];
1004  	int *p_fds;
1005  	char sendchar = 0;
1006  	msg.msg_control = cmsgbuf;
1007  	msg.msg_controllen = sizeof(cmsgbuf);
1008  	p_cmsg = CMSG_FIRSTHDR(&msg);
1009  	p_cmsg->cmsg_level = SOL_SOCKET;
1010  	p_cmsg->cmsg_type = SCM_RIGHTS;
1011  	p_cmsg->cmsg_len = CMSG_LEN(sizeof(fd));
1012  	p_fds = (int *) CMSG_DATA(p_cmsg);
1013  	*p_fds = fd;
1014  	msg.msg_controllen = p_cmsg->cmsg_len;
1015  	msg.msg_name = NULL;
1016  	msg.msg_namelen = 0;
1017  	msg.msg_iov = &vec;
1018  	msg.msg_iovlen = 1;
1019  	msg.msg_flags = 0;
1020  	vec.iov_base = &sendchar;
1021  	vec.iov_len = sizeof(sendchar);
1022  	while ((retval = sendmsg(sock_fd, &msg, 0)) == -1 && errno == EINTR);
1023  	if (retval != 1) {
1024  		perror("sending file descriptor");
1025  		return -1;
1026  	}
1027  	return 0;
1028  }
1029  static int recheck_ENOTCONN_as_owner(const char *mnt)
1030  {
1031  	int pid = fork();
1032  	if(pid == -1) {
1033  		perror("fuse: recheck_ENOTCONN_as_owner can't fork");
1034  		_exit(EXIT_FAILURE);
1035  	} else if(pid == 0) {
1036  		uid_t uid = getuid();
1037  		gid_t gid = getgid();
1038  		if(setresgid(gid, gid, gid) == -1) {
1039  			perror("fuse: can't set resgid");
1040  			_exit(EXIT_FAILURE);
1041  		}
1042  		if(setresuid(uid, uid, uid) == -1) {
1043  			perror("fuse: can't set resuid");
1044  			_exit(EXIT_FAILURE);
1045  		}
1046  		int fd = open(mnt, O_RDONLY);
1047  		if(fd == -1 && errno == ENOTCONN)
1048  			_exit(EXIT_SUCCESS);
1049  		else
1050  			_exit(EXIT_FAILURE);
1051  	} else {
1052  		int status;
1053  		int res = waitpid(pid, &status, 0);
1054  		if (res == -1) {
1055  			perror("fuse: waiting for child failed");
1056  			_exit(EXIT_FAILURE);
1057  		}
1058  		return WIFEXITED(status) && WEXITSTATUS(status) == EXIT_SUCCESS;
1059  	}
1060  }
1061  static int should_auto_unmount(const char *mnt, const char *type)
1062  {
1063  	char *copy;
1064  	const char *last;
1065  	int result = 0;
1066  	int fd;
1067  	copy = strdup(mnt);
1068  	if (copy == NULL) {
1069  	fprintf(stderr, "%s: failed to allocate memory\n", progname);
1070  		return 0;
1071  	}
1072  	if (chdir_to_parent(copy, &last) == -1)
1073  		goto out;
1074  	if (check_is_mount(last, mnt, type) == -1)
1075  		goto out;
1076  	fd = open(mnt, O_RDONLY);
1077  	if (fd != -1) {
1078  		close(fd);
1079  	} else {
1080  		switch(errno) {
1081  		case ENOTCONN:
1082  			result = 1;
1083  			break;
1084  		case EACCES:
1085  			result = recheck_ENOTCONN_as_owner(mnt);
1086  			break;
1087  		default:
1088  			result = 0;
1089  			break;
1090  		}
1091  	}
1092  out:
1093  	free(copy);
1094  	return result;
1095  }
1096  static void usage(void)
1097  {
1098  	printf("%s: [options] mountpoint\n"
1099  	       "Options:\n"
1100  	       " -h		    print help\n"
1101  	       " -V		    print version\n"
1102  	       " -o opt[,opt...]    mount options\n"
1103  	       " -u		    unmount\n"
1104  	       " -q		    quiet\n"
1105  	       " -z		    lazy unmount\n",
1106  	       progname);
1107  	exit(1);
1108  }
1109  static void show_version(void)
1110  {
1111  	printf("fusermount3 version: %s\n", PACKAGE_VERSION);
1112  	exit(0);
1113  }
1114  int main(int argc, char *argv[])
1115  {
1116  	sigset_t sigset;
1117  	int ch;
1118  	int fd;
1119  	int res;
1120  	char *origmnt;
1121  	char *mnt;
1122  	static int unmount = 0;
1123  	static int lazy = 0;
1124  	static int quiet = 0;
1125  	char *commfd;
1126  	int cfd;
1127  	const char *opts = "";
1128  	const char *type = NULL;
1129  	int setup_auto_unmount_only = 0;
1130  	static const struct option long_opts[] = {
1131  		{"unmount", no_argument, NULL, 'u'},
1132  		{"auto-unmount", no_argument, NULL, 'U'},
1133  		{"lazy",    no_argument, NULL, 'z'},
1134  		{"quiet",   no_argument, NULL, 'q'},
1135  		{"help",    no_argument, NULL, 'h'},
1136  		{"version", no_argument, NULL, 'V'},
1137  		{"options", required_argument, NULL, 'o'},
1138  		{0, 0, 0, 0}};
1139  	progname = strdup(argc > 0 ? argv[0] : "fusermount");
1140  	if (progname == NULL) {
1141  		fprintf(stderr, "%s: failed to allocate memory\n", argv[0]);
1142  		exit(1);
1143  	}
1144  	while ((ch = getopt_long(argc, argv, "hVo:uzq", long_opts,
1145  				 NULL)) != -1) {
1146  		switch (ch) {
1147  		case 'h':
1148  			usage();
1149  			break;
1150  		case 'V':
1151  			show_version();
1152  			break;
1153  		case 'o':
1154  			opts = optarg;
1155  			break;
1156  		case 'u':
1157  			unmount = 1;
1158  			break;
1159  		case 'U':
1160  			unmount = 1;
1161  			auto_unmount = 1;
1162  			setup_auto_unmount_only = 1;
1163  			break;
1164  		case 'z':
1165  			lazy = 1;
1166  			break;
1167  		case 'q':
1168  			quiet = 1;
1169  			break;
1170  		default:
1171  			exit(1);
1172  		}
1173  	}
1174  	if (lazy && !unmount) {
1175  		fprintf(stderr, "%s: -z can only be used with -u\n", progname);
1176  		exit(1);
1177  	}
1178  	if (optind >= argc) {
1179  		fprintf(stderr, "%s: missing mountpoint argument\n", progname);
1180  		exit(1);
1181  	} else if (argc > optind + 1) {
1182  		fprintf(stderr, "%s: extra arguments after the mountpoint\n",
1183  			progname);
1184  		exit(1);
1185  	}
1186  	origmnt = argv[optind];
1187  	drop_privs();
1188  	mnt = fuse_mnt_resolve_path(progname, origmnt);
1189  	if (mnt != NULL) {
1190  		res = chdir("/");
1191  		if (res == -1) {
1192  			fprintf(stderr, "%s: failed to chdir to '/'\n", progname);
1193  			goto err_out;
1194  		}
1195  	}
1196  	restore_privs();
1197  	if (mnt == NULL)
1198  		exit(1);
1199  	umask(033);
1200  	if (!setup_auto_unmount_only && unmount)
1201  		goto do_unmount;
1202  	commfd = getenv(FUSE_COMMFD_ENV);
1203  	if (commfd == NULL) {
1204  		fprintf(stderr, "%s: old style mounting not supported\n",
1205  			progname);
1206  		goto err_out;
1207  	}
1208  	cfd = atoi(commfd);
1209  	if (setup_auto_unmount_only)
1210  		goto wait_for_auto_unmount;
1211  	fd = mount_fuse(mnt, opts, &type);
1212  	if (fd == -1)
1213  		goto err_out;
1214  	res = send_fd(cfd, fd);
1215  	if (res == -1)
1216  		goto err_out;
1217  	close(fd);
1218  	if (!auto_unmount) {
1219  		free(mnt);
1220  		return 0;
1221  	}
1222  wait_for_auto_unmount:
1223  	setsid();
1224  	res = chdir("/");
1225  	if (res == -1) {
1226  		fprintf(stderr, "%s: failed to chdir to '/'\n", progname);
1227  		goto err_out;
1228  	}
1229  	sigfillset(&sigset);
1230  	sigprocmask(SIG_BLOCK, &sigset, NULL);
1231  	lazy  = 1;
1232  	quiet = 1;
1233  	while (1) {
1234  		unsigned char buf[16];
1235  		int n = recv(cfd, buf, sizeof(buf), 0);
1236  		if (!n)
1237  			break;
1238  		if (n < 0) {
1239  			if (errno == EINTR)
1240  				continue;
1241  			break;
1242  		}
1243  	}
1244  	if (!should_auto_unmount(mnt, type)) {
1245  		goto success_out;
1246  	}
1247  do_unmount:
1248  	if (geteuid() == 0)
1249  		res = unmount_fuse(mnt, quiet, lazy);
1250  	else {
1251  		res = umount2(mnt, lazy ? UMOUNT_DETACH : 0);
1252  		if (res == -1 && !quiet)
1253  			fprintf(stderr,
1254  				"%s: failed to unmount %s: %s\n",
1255  				progname, mnt, strerror(errno));
1256  	}
1257  	if (res == -1)
1258  		goto err_out;
1259  success_out:
1260  	free(mnt);
1261  	return 0;
1262  err_out:
1263  	free(mnt);
1264  	exit(1);
1265  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from libtomcrypt-MDEwOlJlcG9zaXRvcnk3NzcwMTE=-flat-eax_test.c</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from libfuse-MDEwOlJlcG9zaXRvcnk0ODI5NjE3Nw==-flat-fusermount.c</div>
                </div>
                <div class="column column_space"><pre><code>20  {
21     16, 0, 0, 0,
22     { 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
23       0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f },
24     { 0 },
25     { 0 },
26     { 0 },
27     { 0 },
28     { 0x9a, 0xd0, 0x7e, 0x7d, 0xbf, 0xf3, 0x01, 0xf5,
29       0x05, 0xde, 0x59, 0x6b, 0x96, 0x15, 0xdf, 0xff }
</pre></code></div>
                <div class="column column_space"><pre><code>501  static struct mount_flags mount_flags[] = {
502  	{"rw",	    MS_RDONLY,	    0, 1},
503  	{"ro",	    MS_RDONLY,	    1, 1},
504  	{"suid",    MS_NOSUID,	    0, 0},
505  	{"nosuid",  MS_NOSUID,	    1, 1},
506  	{"dev",	    MS_NODEV,	    0, 0},
507  	{"nodev",   MS_NODEV,	    1, 1},
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    