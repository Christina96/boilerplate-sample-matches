<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for smartcrop.c &amp; quadratic.c</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for smartcrop.c &amp; quadratic.c
      </h3>
<h1 align="center">
        7.0%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>smartcrop.c (6.3241105%)<th>quadratic.c (7.960199%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(390-408)<td><a href="#" name="0">(323-341)</a><td align="center"><font color="#ff0000">16</font>
</td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>smartcrop.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 #ifdef HAVE_CONFIG_H
2 #include &lt;config.h&gt;
3 #include &lt;vips/intl.h&gt;
4 #include &lt;stdio.h&gt;
5 #include &lt;string.h&gt;
6 #include &lt;stdlib.h&gt;
7 #include &lt;vips/vips.h&gt;
8 #include &lt;vips/debug.h&gt;
9 #include "pconversion.h"
10 #include "bandary.h"
11 typedef struct _VipsSmartcrop {
12 	VipsConversion parent_instance;
13 	VipsImage *in;
14 	int width;
15 	int height;
16 	VipsInteresting interesting;
17 } VipsSmartcrop;
18 typedef VipsConversionClass VipsSmartcropClass;
19 G_DEFINE_TYPE( VipsSmartcrop, vips_smartcrop, VIPS_TYPE_CONVERSION );
20 static int
21 vips_smartcrop_score( VipsSmartcrop *smartcrop, VipsImage *in, 
22 	int left, int top, int width, int height, double *score )
23 {
24 	VipsImage **t = (VipsImage **) 
25 		vips_object_local_array( VIPS_OBJECT( smartcrop ), 2 );
26 	if( vips_extract_area( in, &amp;t[0], left, top, width, height, NULL ) ||
27 		vips_hist_find( t[0], &amp;t[1], NULL ) ||
28 		vips_hist_entropy( t[1], score, NULL ) )
29 		return( -1 );
30 	return( 0 );
31 }
32 static int
33 vips_smartcrop_entropy( VipsSmartcrop *smartcrop, 
34 	VipsImage *in, int *left, int *top )
35 {
36 	int max_slice_size;
37 	int width;
38 	int height;
39 	*left = 0;
40 	*top = 0;
41 	width = in-&gt;Xsize;
42 	height = in-&gt;Ysize;
43 	max_slice_size = VIPS_MAX( 
44 		ceil( (width - smartcrop-&gt;width) / 8.0 ),
45 		ceil( (height - smartcrop-&gt;height) / 8.0 ) );
46 	while( width &gt; smartcrop-&gt;width || 
47 		height &gt; smartcrop-&gt;height ) {
48 		const int slice_width = 
49 			VIPS_MIN( width - smartcrop-&gt;width, max_slice_size );
50 		const int slice_height = 
51 			VIPS_MIN( height - smartcrop-&gt;height, max_slice_size );
52 		if( slice_width &gt; 0 ) { 
53 			double left_score;
54 			double right_score;
55 			if( vips_smartcrop_score( smartcrop, in, 
56 				*left, *top, 
57 				slice_width, height, &amp;left_score ) )
58 				return( -1 );
59 			if( vips_smartcrop_score( smartcrop, in, 
60 				*left + width - slice_width, *top, 
61 				slice_width, height, &amp;right_score ) )
62 				return( -1 ); 
63 			width -= slice_width;
64 			if( left_score &lt; right_score ) 
65 				*left += slice_width;
66 		}
67 		if( slice_height &gt; 0 ) { 
68 			double top_score;
69 			double bottom_score;
70 			if( vips_smartcrop_score( smartcrop, in, 
71 				*left, *top, 
72 				width, slice_height, &amp;top_score ) )
73 				return( -1 );
74 			if( vips_smartcrop_score( smartcrop, in, 
75 				*left, *top + height - slice_height, 
76 				width, slice_height, &amp;bottom_score ) )
77 				return( -1 ); 
78 			height -= slice_height;
79 			if( top_score &lt; bottom_score ) 
80 				*top += slice_height;
81 		}
82 	}
83 	return( 0 );
84 }
85 static int
86 pythagoras( VipsSmartcrop *smartcrop, VipsImage *in, VipsImage **out )
87 {
88 	VipsImage **t = (VipsImage **) 
89 		vips_object_local_array( VIPS_OBJECT( smartcrop ), 
90 			2 * in-&gt;Bands + 1 );
91 	int i;
92 	for( i = 0; i &lt; in-&gt;Bands; i++ ) 
93 		if( vips_extract_band( in, &amp;t[i], i, NULL ) )
94 			return( -1 );
95 	for( i = 0; i &lt; in-&gt;Bands; i++ ) 
96 		if( vips_multiply( t[i], t[i], &amp;t[i + in-&gt;Bands], NULL ) )
97 			return( -1 );
98 	if( vips_sum( &amp;t[in-&gt;Bands], &amp;t[2 * in-&gt;Bands], in-&gt;Bands, NULL ) ||
99 		vips_pow_const1( t[2 * in-&gt;Bands], out, 0.5, NULL ) )
100 		return( -1 );
101 	return( 0 );
102 }
103 static int
104 vips_smartcrop_attention( VipsSmartcrop *smartcrop, 
105 	VipsImage *in, int *left, int *top )
106 {
107 	static double skin_vector[] = {-0.78, -0.57, -0.44};
108 	static double ones[] = {1.0, 1.0, 1.0};
109 	VipsImage **t = (VipsImage **) 
110 		vips_object_local_array( VIPS_OBJECT( smartcrop ), 24 );
111 	double hscale;
112 	double vscale;
113 	double sigma;
114 	double max;
115 	int x_pos;
116 	int y_pos;
117 	hscale = 32.0 / in-&gt;Xsize;
118 	vscale = 32.0 / in-&gt;Ysize;
119 	sigma = VIPS_MAX( sqrt( pow( smartcrop-&gt;width * hscale, 2 ) +
120 		pow( smartcrop-&gt;height * vscale, 2 ) ) / 10, 1.0 );
121 	if ( vips_resize( in, &amp;t[17], hscale,
122 		"vscale", vscale,
123 		NULL ) )
124 		return( -1 );
125 	if( !(t[21] = vips_image_new_matrixv( 3, 3,
126 		 0.0, -1.0,  0.0, 
127 		-1.0,  4.0, -1.0, 
128 		 0.0, -1.0,  0.0 )) )
129 		return( -1 );
130 	if( vips_colourspace( t[17], &amp;t[0], VIPS_INTERPRETATION_XYZ, NULL ) ||
131 		vips_extract_band( t[0], &amp;t[1], 0, "n", 3, NULL ) )
132 		return( -1 );
133 	if( vips_extract_band( t[1], &amp;t[2], 1, NULL ) ||
134 		vips_conv( t[2], &amp;t[3], t[21], 
135 			"precision", VIPS_PRECISION_INTEGER,
136 			NULL ) ||
137 		vips_linear1( t[3], &amp;t[4], 5.0, 0.0, NULL ) ||
138 		vips_abs( t[4], &amp;t[14], NULL ) )
139 		return( -1 );
140 	if( 
141 		pythagoras( smartcrop, t[1], &amp;t[5] ) ||
142 		vips_divide( t[1], t[5], &amp;t[6], NULL ) ||
143 		vips_linear( t[6], &amp;t[7], ones, skin_vector, 3, NULL ) ||
144 		pythagoras( smartcrop, t[7], &amp;t[8] ) ||
145 		vips_linear1( t[8], &amp;t[9], -100.0, 100.0, NULL ) ||
146 		vips_more_const1( t[2], &amp;t[10], 5.0, NULL ) ||
147 		!(t[11] = vips_image_new_from_image1( t[10], 0.0 )) ||
148 		vips_ifthenelse( t[10], t[9], t[11], &amp;t[15], NULL ) )
149 		return( -1 );
150 	if( vips_colourspace( t[1], &amp;t[12], 
151 		VIPS_INTERPRETATION_LAB, NULL ) ||
152 		vips_extract_band( t[12], &amp;t[13], 1, NULL ) ||
153 		vips_ifthenelse( t[10], t[13], t[11], &amp;t[16], NULL ) )
154 		return( -1 );
155 	if( vips_sum( &amp;t[14], &amp;t[18], 3, NULL ) ||
156 		vips_gaussblur( t[18], &amp;t[19], sigma, NULL ) ||
157 		vips_max( t[19], &amp;max, "x", &amp;x_pos, "y", &amp;y_pos, NULL ) )
158 		return( -1 ); 
159 	*left = VIPS_CLIP( 0, 
160 		x_pos / hscale - smartcrop-&gt;width / 2, 
161 		in-&gt;Xsize - smartcrop-&gt;width );
162 	*top = VIPS_CLIP( 0, 
163 		y_pos / vscale - smartcrop-&gt;height / 2, 
164 		in-&gt;Ysize - smartcrop-&gt;height ); 
165 	return( 0 ); 
166 }
167 static int
168 vips_smartcrop_build( VipsObject *object )
169 {
170 	VipsObjectClass *class = VIPS_OBJECT_GET_CLASS( object );
171 	VipsConversion *conversion = VIPS_CONVERSION( object );
172 	VipsSmartcrop *smartcrop = (VipsSmartcrop *) object;
173 	VipsImage **t = (VipsImage **) vips_object_local_array( object, 2 );
174 	VipsImage *in;
175 	int left;
176 	int top;
177 	if( VIPS_OBJECT_CLASS( vips_smartcrop_parent_class )-&gt;
178 		build( object ) )
179 		return( -1 );
180 	if( smartcrop-&gt;width &gt; smartcrop-&gt;in-&gt;Xsize ||
181 		smartcrop-&gt;height &gt; smartcrop-&gt;in-&gt;Ysize ||
182 		smartcrop-&gt;width &lt;= 0 || smartcrop-&gt;height &lt;= 0 ) {
183 		vips_error( class-&gt;nickname, "%s", _( "bad extract area" ) );
184 		return( -1 );
185 	}
186 	in = smartcrop-&gt;in;
187 	if( vips_image_hasalpha( in ) ) { 
188 		if( vips_premultiply( in, &amp;t[0], NULL ) ) 
189 			return( -1 );
190 		in = t[0];
191 	}
192 	switch( smartcrop-&gt;interesting ) {
193 	case VIPS_INTERESTING_NONE:
194 	case VIPS_INTERESTING_LOW:
195 		left = 0;
196 		top = 0;
197 		break;
198 	case VIPS_INTERESTING_CENTRE:
199 		left = (in-&gt;Xsize - smartcrop-&gt;width) / 2;
200 		top = (in-&gt;Ysize - smartcrop-&gt;height) / 2;
201 		break;
202 	case VIPS_INTERESTING_ENTROPY:
203 		if( vips_smartcrop_entropy( smartcrop, in, &amp;left, &amp;top ) )
204 			return( -1 );
205 		break;
206 	case VIPS_INTERESTING_ATTENTION:
207 		if( vips_smartcrop_attention( smartcrop, in, &amp;left, &amp;top ) )
208 			return( -1 );
209 		break;
210 	case VIPS_INTERESTING_HIGH:
211 		left = in-&gt;Xsize - smartcrop-&gt;width;
212 		top = in-&gt;Ysize - smartcrop-&gt;height;
213 		break;
214 	case VIPS_INTERESTING_ALL:
215 		left = 0;
216 		top = 0;
217 		smartcrop-&gt;width = in-&gt;Xsize;
218 		smartcrop-&gt;height = in-&gt;Ysize;
219 		break;
220 	default:
221 		g_assert_not_reached();
222 		left = 0;
223 		top = 0;
224 		break;
225 	}
226 	if( vips_extract_area( smartcrop-&gt;in, &amp;t[1], 
227 <a name="0"></a>			left, top, 
228 			smartcrop-&gt;width, smartcrop-&gt;height, NULL ) ||
229 		vips_image_write( t[1], conversion-&gt;out ) )
230 <font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>		return( -1 ); 
231 	return( 0 );
232 }
233 static void
234 vips_smartcrop_class_init( VipsSmartcropClass *class )
235 {
236 	GObjectClass *gobject_class = G_OBJECT_CLASS( class );
237 	VipsObjectClass *vobject_class = VIPS_OBJECT_CLASS( class );
238 	VIPS_DEBUG_MSG( "vips_smartcrop_class_init\n" );
239 	gobject_class-&gt;set_property = vips_object_set_property;
240 	gobject_class-&gt;get_property = vips_object_get_property;
241 	vobject_class-&gt;nickname = "smartcrop";
242 	vobject_class-&gt;description = _( "extract an area from an image" );
243 	vobject_class-&gt;build = vips_smartcrop_build;</b></font>
244 	VIPS_ARG_IMAGE( class, "input", 0, 
245 		_( "Input" ), 
246 		_( "Input image" ),
247 		VIPS_ARGUMENT_REQUIRED_INPUT,
248 		G_STRUCT_OFFSET( VipsSmartcrop, in ) );
249 	VIPS_ARG_INT( class, "width", 4, 
250 		_( "Width" ), 
251 		_( "Width of extract area" ),
252 		VIPS_ARGUMENT_REQUIRED_INPUT,
253 		G_STRUCT_OFFSET( VipsSmartcrop, width ),
254 		1, VIPS_MAX_COORD, 1 );
255 	VIPS_ARG_INT( class, "height", 5, 
256 		_( "Height" ), 
257 		_( "Height of extract area" ),
258 		VIPS_ARGUMENT_REQUIRED_INPUT,
259 		G_STRUCT_OFFSET( VipsSmartcrop, height ),
260 		1, VIPS_MAX_COORD, 1 );
261 	VIPS_ARG_ENUM( class, "interesting", 6, 
262 		_( "Interesting" ), 
263 		_( "How to measure interestingness" ),
264 		VIPS_ARGUMENT_OPTIONAL_INPUT,
265 		G_STRUCT_OFFSET( VipsSmartcrop, interesting ),
266 		VIPS_TYPE_INTERESTING, VIPS_INTERESTING_ATTENTION );
267 }
268 static void
269 vips_smartcrop_init( VipsSmartcrop *smartcrop )
270 {
271 	smartcrop-&gt;interesting = VIPS_INTERESTING_ATTENTION;
272 }
273 int
274 vips_smartcrop( VipsImage *in, VipsImage **out, int width, int height, ... )
275 {
276 	va_list ap;
277 	int result;
278 	va_start( ap, height );
279 	result = vips_call_split( "smartcrop", ap, in, out, width, height );
280 	va_end( ap );
281 	return( result );
282 }
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>quadratic.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 #ifdef HAVE_CONFIG_H
2 #include &lt;config.h&gt;
3 #include &lt;vips/intl.h&gt;
4 #include &lt;stdio.h&gt;
5 #include &lt;math.h&gt;
6 #include &lt;vips/vips.h&gt;
7 #include &lt;vips/debug.h&gt;
8 #include "presample.h"
9 typedef struct _VipsQuadratic {
10 	VipsResample parent_instance;
11 	VipsImage *coeff;
12 	VipsInterpolate *interpolate;
13 	VipsImage *mat;
14 	int order;
15 } VipsQuadratic;
16 typedef VipsResampleClass VipsQuadraticClass;
17 G_DEFINE_TYPE( VipsQuadratic, vips_quadratic, VIPS_TYPE_RESAMPLE );
18 static void
19 vips_quadratic_dispose( GObject *gobject )
20 {
21 	VipsQuadratic *quadratic = (VipsQuadratic *) gobject;
22 	VIPS_UNREF( quadratic-&gt;mat ); 
23 	G_OBJECT_CLASS( vips_quadratic_parent_class )-&gt;dispose( gobject );
24 }
25 static int
26 vips_quadratic_gen( VipsRegion *or, void *vseq, 
27 	void *a, void *b, gboolean *stop )
28 {
29 	VipsRegion *ir = (VipsRegion *) vseq;
30 	VipsQuadratic *quadratic = (VipsQuadratic *) b;
31 	VipsResample *resample = VIPS_RESAMPLE( quadratic );
32 	VipsInterpolateMethod interpolate_fn = 
33 		vips_interpolate_get_method( quadratic-&gt;interpolate );
34 	const VipsImage *in = (VipsImage *) a;
35 	const int ps = VIPS_IMAGE_SIZEOF_PEL( in );
36 	double *vec = VIPS_MATRIX( quadratic-&gt;mat, 0, 0 );
37 	int clip_width = resample-&gt;in-&gt;Xsize;
38 	int clip_height = resample-&gt;in-&gt;Ysize;
39 	int xlow = or-&gt;valid.left;
40 	int ylow = or-&gt;valid.top;
41 	int xhigh = VIPS_RECT_RIGHT( &amp;or-&gt;valid );
42 	int yhigh = VIPS_RECT_BOTTOM( &amp;or-&gt;valid );
43 	VipsPel *q;
44 	int xo, yo;			int z;
45 	double fxi, fyi; 		double dx, dy;        		double ddx, ddy;      	
46 	VipsRect image;
47 	image.left = 0;
48 	image.top = 0;
49 	image.width = in-&gt;Xsize;
50 	image.height = in-&gt;Ysize;
51 	if( vips_region_image( ir, &amp;image ) )
52 		return( -1 );
53 	for( yo = ylow; yo &lt; yhigh; yo++ ) {
54 		fxi = 0.0;
55 		fyi = 0.0;
56 		dx = 0.0;
57 		dy = 0.0;
58 		ddx = 0.0;
59 		ddy = 0.0;
60 		switch( quadratic-&gt;order ) {
61 		case 3: 
62 			fxi += vec[10] * yo * yo + vec[8] * xlow * xlow;
63 			fyi += vec[11] * yo * yo + vec[9] * xlow * xlow;
64 			dx += vec[8];
65 			ddx += vec[8] * 2.0;
66 			dy += vec[9];
67 			ddy += vec[9] * 2.0;
68 		case 2: 
69 			fxi += vec[6] * xlow * yo;
70 			fyi += vec[7] * xlow * yo;
71 			dx += vec[6] * yo;
72 			dy += vec[7] * yo;
73 		case 1: 
74 			fxi += vec[4] * yo + vec[2] * xlow;
75 			fyi += vec[5] * yo + vec[3] * xlow;
76 			dx += vec[2];
77 			dy += vec[3];
78 		case 0: 
79 			fxi += vec[0];
80 			fyi += vec[1];    
81 			break;
82 		default:
83 		    	g_assert_not_reached();
84 		}
85 		printf( "dx = %g, dy = %g\n", dx, dy );
86 		q = VIPS_REGION_ADDR( or, xlow, yo );
87 		for( xo = xlow; xo &lt; xhigh; xo++ ) {
88 			int xi, yi; 	
89 			xi = fxi;
90 			yi = fyi;
91 			if( xi &lt; 0 || 
92 				yi &lt; 0 || 
93 				xi &gt;= clip_width || 
94 				yi &gt;= clip_height ) {
95 				for( z = 0; z &lt; ps; z++ ) 
96 					q[z] = 0;
97 			}
98 			else 
99 				interpolate_fn( quadratic-&gt;interpolate, 
100 					q, ir, fxi, fyi );
101 			q += ps;
102 			fxi += dx;
103 			fyi += dy;
104 			if( quadratic-&gt;order &gt; 2 ) {
105 				dx += ddx;
106 				dy += ddy;
107 			}
108 		}
109 	}
110 	return( 0 );
111 }
112 static int
113 vips_quadratic_build( VipsObject *object )
114 {
115 	VipsObjectClass *class = VIPS_OBJECT_GET_CLASS( object );
116 	VipsResample *resample = VIPS_RESAMPLE( object );
117 	VipsQuadratic *quadratic = (VipsQuadratic *) object;
118 	int window_size;
119 	int window_offset;
120 	VipsImage *in;
121 	VipsImage *t;
122 	if( VIPS_OBJECT_CLASS( vips_quadratic_parent_class )-&gt;build( object ) )
123 		return( -1 );
124 	if( vips_image_pipelinev( resample-&gt;out, 
125 		VIPS_DEMAND_STYLE_ANY, resample-&gt;in, NULL ) )
126 		return( -1 );
127 	in = resample-&gt;in;
128         if( vips_check_uncoded( class-&gt;nickname, in ) ||
129 		vips_check_noncomplex( class-&gt;nickname, in ) ||
130 		vips_check_matrix( class-&gt;nickname, 
131 			quadratic-&gt;coeff, &amp;quadratic-&gt;mat  ) )
132                 return( -1 );
133 	if( quadratic-&gt;mat-&gt;Xsize != 2 ) {
134 		vips_error( class-&gt;nickname, 
135 			"%s", _( "coefficient matrix must have width 2" ) ); 
136 		return( -1 );
137 	} 
138         switch( quadratic-&gt;mat-&gt;Ysize ) {
139 	case 1: 
140 		quadratic-&gt;order = 0; 
141 		break;
142 	case 3: 
143 		quadratic-&gt;order = 1; 
144 		break;
145 	case 4: 
146 		quadratic-&gt;order = 2; 
147 		break;
148 	case 6: 
149 		quadratic-&gt;order = 3; 
150 		break;
151 	default:
152 		vips_error( class-&gt;nickname, 
153 			"%s", _( "coefficient matrix must have height "
154 				"1, 3, 4 or 6" ) );
155 		return( -1 );
156 	} 
157 	if( !quadratic-&gt;interpolate )
158 		quadratic-&gt;interpolate = vips_interpolate_new( "bilinear" );
159 	window_size = vips_interpolate_get_window_size( quadratic-&gt;interpolate );
160 	window_offset = vips_interpolate_get_window_offset( quadratic-&gt;interpolate );
161 	if( vips_embed( in, &amp;t, 
162 		window_offset, window_offset, 
163 		in-&gt;Xsize + window_size, in-&gt;Ysize + window_size,
164 		"extend", VIPS_EXTEND_COPY,
165 		NULL ) )
166 		return( -1 );
167 	vips_object_local( object, t );
168 	in = t;
169         if( !(t = vips_image_copy_memory( in )) )
170                 return( -1 );
171 	vips_object_local( object, t );
172 	in = t;
173 <a name="0"></a>	if( vips_image_generate( resample-&gt;out,
174 		vips_start_one, vips_quadratic_gen, vips_stop_one, 
175 			in, quadratic ) )
176 <font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>		return( -1 );
177         return( 0 );
178 }
179 static void
180 vips_quadratic_class_init( VipsQuadraticClass *class )
181 {
182 	GObjectClass *gobject_class = G_OBJECT_CLASS( class );
183 	VipsObjectClass *vobject_class = VIPS_OBJECT_CLASS( class );
184 	VIPS_DEBUG_MSG( "vips_quadratic_class_init\n" );
185 	gobject_class-&gt;dispose = vips_quadratic_dispose;
186 	gobject_class-&gt;set_property = vips_object_set_property;
187 	gobject_class-&gt;get_property = vips_object_get_property;
188 	vobject_class-&gt;nickname = "quadratic";
189 	vobject_class-&gt;description = </b></font>
190 		_( "resample an image with a quadratic transform" );
191 	vobject_class-&gt;build = vips_quadratic_build;
192 	VIPS_ARG_IMAGE( class, "coeff", 8, 
193 		_( "Coeff" ), 
194 		_( "Coefficient matrix" ),
195 		VIPS_ARGUMENT_REQUIRED_INPUT,
196 		G_STRUCT_OFFSET( VipsQuadratic, coeff ) );
197 	VIPS_ARG_INTERPOLATE( class, "interpolate", 9, 
198 		_( "Interpolate" ), 
199 		_( "Interpolate values with this" ),
200 		VIPS_ARGUMENT_OPTIONAL_INPUT,
201 		G_STRUCT_OFFSET( VipsQuadratic, interpolate ) );
202 }
203 static void
204 vips_quadratic_init( VipsQuadratic *quadratic )
205 {
206 }
207 int
208 vips_quadratic( VipsImage *in, VipsImage **out, VipsImage *coeff, ... )
209 {
210 	va_list ap;
211 	int result;
212 	va_start( ap, coeff );
213 	result = vips_call_split( "quadratic", ap, in, out, coeff );
214 	va_end( ap );
215 	return( result );
216 }
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
