<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML><HEAD><TITLE>Matches for smartcrop.c & quadratic.c</TITLE>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
</HEAD>
<body>
  <div style="align-items: center; display: flex; justify-content: space-around;">
    <div>
      <h3 align="center">
Matches for smartcrop.c & quadratic.c
      </h3>
      <h1 align="center">
        7.0%
      </h1>
      <center>
        <a href="index.html" target="_top">
          INDEX
        </a>
        <span>-</span>
        <a href="help-en.html" target="_top">
          HELP
        </a>
      </center>
    </div>
    <div>
<TABLE BORDER="1" CELLSPACING="0" BGCOLOR="#d0d0d0">
<TR><TH><TH>smartcrop.c (6.3241105%)<TH>quadratic.c (7.960199%)<TH>Tokens
<TR><TD BGCOLOR="#0000ff"><FONT COLOR="#0000ff">-</FONT><TD><A HREF="javascript:ZweiFrames('match19620-0.html#0',2,'match19620-1.html#0',3)" NAME="0">(390-408)<TD><A HREF="javascript:ZweiFrames('match19620-0.html#0',2,'match19620-1.html#0',3)" NAME="0">(323-341)</A><TD ALIGN=center><FONT COLOR="#ff0000">16</FONT>
</TABLE>
    </div>
  </div>
  <hr>
  <div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>smartcrop.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
/* crop an image down to a specified size by removing boring parts
 *
 * Adapted from sharp's smartcrop feature, with kind permission.
 *
 * 1/3/17
 * 	- first version, from sharp
 * 14/3/17
 * 	- revised attention smartcrop
 * 8/6/17
 * 	- revised again
 * 15/9/18 lovell
 * 	- move shrink to start of processing
 * 22/9/18 jcupitt
 * 	- add low and high
 * 19/3/20 jcupitt
 * 	- add all
 */

/*

    This file is part of VIPS.
    
    VIPS is free software; you can redistribute it and/or modify
    it under the terms of the GNU Lesser General Public License as published by
    the Free Software Foundation; either version 2 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public License
    along with this program; if not, write to the Free Software
    Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
    02110-1301  USA

 */

/*

    These files are distributed with VIPS - http://www.vips.ecs.soton.ac.uk

 */

/*
#define VIPS_DEBUG
 */

#ifdef HAVE_CONFIG_H
#include &lt;config.h&gt;
#endif /*HAVE_CONFIG_H*/
#include &lt;vips/intl.h&gt;

#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;stdlib.h&gt;

#include &lt;vips/vips.h&gt;
#include &lt;vips/debug.h&gt;

#include &quot;pconversion.h&quot;

#include &quot;bandary.h&quot;

typedef struct _VipsSmartcrop {
	VipsConversion parent_instance;

	VipsImage *in;
	int width;
	int height;
	VipsInteresting interesting;

} VipsSmartcrop;

typedef VipsConversionClass VipsSmartcropClass;

G_DEFINE_TYPE( VipsSmartcrop, vips_smartcrop, VIPS_TYPE_CONVERSION );

static int
vips_smartcrop_score( VipsSmartcrop *smartcrop, VipsImage *in, 
	int left, int top, int width, int height, double *score )
{
	VipsImage **t = (VipsImage **) 
		vips_object_local_array( VIPS_OBJECT( smartcrop ), 2 );

	if( vips_extract_area( in, &amp;t[0], left, top, width, height, NULL ) ||
		vips_hist_find( t[0], &amp;t[1], NULL ) ||
		vips_hist_entropy( t[1], score, NULL ) )
		return( -1 );

	return( 0 );
}

/* Entropy-style smartcrop. Repeatedly discard low interest areas. This should
 * be faster for very large images. 
 */
static int
vips_smartcrop_entropy( VipsSmartcrop *smartcrop, 
	VipsImage *in, int *left, int *top )
{
	int max_slice_size;
	int width;
	int height;

	*left = 0;
	*top = 0;
	width = in-&gt;Xsize;
	height = in-&gt;Ysize;

	/* How much do we trim by each iteration? Aim for 8 steps in the axis
	 * that needs trimming most.
	 */
	max_slice_size = VIPS_MAX( 
		ceil( (width - smartcrop-&gt;width) / 8.0 ),
		ceil( (height - smartcrop-&gt;height) / 8.0 ) );

	/* Repeatedly take a slice off width and height until we 
	 * reach the target.
	 */
	while( width &gt; smartcrop-&gt;width || 
		height &gt; smartcrop-&gt;height ) {
		const int slice_width = 
			VIPS_MIN( width - smartcrop-&gt;width, max_slice_size );
		const int slice_height = 
			VIPS_MIN( height - smartcrop-&gt;height, max_slice_size );

		if( slice_width &gt; 0 ) { 
			double left_score;
			double right_score;

			if( vips_smartcrop_score( smartcrop, in, 
				*left, *top, 
				slice_width, height, &amp;left_score ) )
				return( -1 );

			if( vips_smartcrop_score( smartcrop, in, 
				*left + width - slice_width, *top, 
				slice_width, height, &amp;right_score ) )
				return( -1 ); 

			width -= slice_width;
			if( left_score &lt; right_score ) 
				*left += slice_width;
		}

		if( slice_height &gt; 0 ) { 
			double top_score;
			double bottom_score;

			if( vips_smartcrop_score( smartcrop, in, 
				*left, *top, 
				width, slice_height, &amp;top_score ) )
				return( -1 );

			if( vips_smartcrop_score( smartcrop, in, 
				*left, *top + height - slice_height, 
				width, slice_height, &amp;bottom_score ) )
				return( -1 ); 

			height -= slice_height;
			if( top_score &lt; bottom_score ) 
				*top += slice_height;
		}
	}

	return( 0 );
}

/* Calculate sqrt(b1^2 + b2^2 ...)
 */
static int
pythagoras( VipsSmartcrop *smartcrop, VipsImage *in, VipsImage **out )
{
	VipsImage **t = (VipsImage **) 
		vips_object_local_array( VIPS_OBJECT( smartcrop ), 
			2 * in-&gt;Bands + 1 );

	int i;

	for( i = 0; i &lt; in-&gt;Bands; i++ ) 
		if( vips_extract_band( in, &amp;t[i], i, NULL ) )
			return( -1 );

	for( i = 0; i &lt; in-&gt;Bands; i++ ) 
		if( vips_multiply( t[i], t[i], &amp;t[i + in-&gt;Bands], NULL ) )
			return( -1 );

	if( vips_sum( &amp;t[in-&gt;Bands], &amp;t[2 * in-&gt;Bands], in-&gt;Bands, NULL ) ||
		vips_pow_const1( t[2 * in-&gt;Bands], out, 0.5, NULL ) )
		return( -1 );

	return( 0 );
}

static int
vips_smartcrop_attention( VipsSmartcrop *smartcrop, 
	VipsImage *in, int *left, int *top )
{
	/* From smartcrop.js.
	 */
	static double skin_vector[] = {-0.78, -0.57, -0.44};
	static double ones[] = {1.0, 1.0, 1.0};

	VipsImage **t = (VipsImage **) 
		vips_object_local_array( VIPS_OBJECT( smartcrop ), 24 );

	double hscale;
	double vscale;
	double sigma;
	double max;
	int x_pos;
	int y_pos;

	/* The size we shrink to gives the precision with which we can place
	 * the crop
	 */
	hscale = 32.0 / in-&gt;Xsize;
	vscale = 32.0 / in-&gt;Ysize;
	sigma = VIPS_MAX( sqrt( pow( smartcrop-&gt;width * hscale, 2 ) +
		pow( smartcrop-&gt;height * vscale, 2 ) ) / 10, 1.0 );
	if ( vips_resize( in, &amp;t[17], hscale,
		&quot;vscale&quot;, vscale,
		NULL ) )
		return( -1 );

	/* Simple edge detect.
	 */
	if( !(t[21] = vips_image_new_matrixv( 3, 3,
		 0.0, -1.0,  0.0, 
		-1.0,  4.0, -1.0, 
		 0.0, -1.0,  0.0 )) )
		return( -1 );

	/* Convert to XYZ and just use the first three bands.
	 */
	if( vips_colourspace( t[17], &amp;t[0], VIPS_INTERPRETATION_XYZ, NULL ) ||
		vips_extract_band( t[0], &amp;t[1], 0, &quot;n&quot;, 3, NULL ) )
		return( -1 );

	/* Edge detect on Y. 
	 */
	if( vips_extract_band( t[1], &amp;t[2], 1, NULL ) ||
		vips_conv( t[2], &amp;t[3], t[21], 
			&quot;precision&quot;, VIPS_PRECISION_INTEGER,
			NULL ) ||
		vips_linear1( t[3], &amp;t[4], 5.0, 0.0, NULL ) ||
		vips_abs( t[4], &amp;t[14], NULL ) )
		return( -1 );

	/* Look for skin colours. Taken from smartcrop.js.
	 */
	if( 
		/* Normalise to magnitude of colour in XYZ.
		 */
		pythagoras( smartcrop, t[1], &amp;t[5] ) ||
		vips_divide( t[1], t[5], &amp;t[6], NULL ) ||

		/* Distance from skin point.
		 */
		vips_linear( t[6], &amp;t[7], ones, skin_vector, 3, NULL ) ||
		pythagoras( smartcrop, t[7], &amp;t[8] ) ||

		/* Rescale to 100 - 0 score.
		 */
		vips_linear1( t[8], &amp;t[9], -100.0, 100.0, NULL ) ||

		/* Ignore dark areas.
		 */
		vips_more_const1( t[2], &amp;t[10], 5.0, NULL ) ||
		!(t[11] = vips_image_new_from_image1( t[10], 0.0 )) ||
		vips_ifthenelse( t[10], t[9], t[11], &amp;t[15], NULL ) )
		return( -1 );

	/* Look for saturated areas.
	 */
	if( vips_colourspace( t[1], &amp;t[12], 
		VIPS_INTERPRETATION_LAB, NULL ) ||
		vips_extract_band( t[12], &amp;t[13], 1, NULL ) ||
		vips_ifthenelse( t[10], t[13], t[11], &amp;t[16], NULL ) )
		return( -1 );

	/* Sum, blur and find maxpos.
	 *
	 * The amount of blur is related to the size of the crop
	 * area: how large an area we want to consider for the scoring
	 * function.
	 */

	if( vips_sum( &amp;t[14], &amp;t[18], 3, NULL ) ||
		vips_gaussblur( t[18], &amp;t[19], sigma, NULL ) ||
		vips_max( t[19], &amp;max, &quot;x&quot;, &amp;x_pos, &quot;y&quot;, &amp;y_pos, NULL ) )
		return( -1 ); 

	/* Centre the crop over the max.
	 */
	*left = VIPS_CLIP( 0, 
		x_pos / hscale - smartcrop-&gt;width / 2, 
		in-&gt;Xsize - smartcrop-&gt;width );
	*top = VIPS_CLIP( 0, 
		y_pos / vscale - smartcrop-&gt;height / 2, 
		in-&gt;Ysize - smartcrop-&gt;height ); 

	return( 0 ); 
}

static int
vips_smartcrop_build( VipsObject *object )
{
	VipsObjectClass *class = VIPS_OBJECT_GET_CLASS( object );
	VipsConversion *conversion = VIPS_CONVERSION( object );
	VipsSmartcrop *smartcrop = (VipsSmartcrop *) object;
	VipsImage **t = (VipsImage **) vips_object_local_array( object, 2 );

	VipsImage *in;
	int left;
	int top;

	if( VIPS_OBJECT_CLASS( vips_smartcrop_parent_class )-&gt;
		build( object ) )
		return( -1 );

	if( smartcrop-&gt;width &gt; smartcrop-&gt;in-&gt;Xsize ||
		smartcrop-&gt;height &gt; smartcrop-&gt;in-&gt;Ysize ||
		smartcrop-&gt;width &lt;= 0 || smartcrop-&gt;height &lt;= 0 ) {
		vips_error( class-&gt;nickname, &quot;%s&quot;, _( &quot;bad extract area&quot; ) );
		return( -1 );
	}

	in = smartcrop-&gt;in;

	/* If there's an alpha, we have to premultiply before searching for
	 * content. There could be stuff in transparent areas which we don't
	 * want to consider. 
	 */
	if( vips_image_hasalpha( in ) ) { 
		if( vips_premultiply( in, &amp;t[0], NULL ) ) 
			return( -1 );
		in = t[0];
	}

	switch( smartcrop-&gt;interesting ) {
	case VIPS_INTERESTING_NONE:
	case VIPS_INTERESTING_LOW:
		left = 0;
		top = 0;
		break;

	case VIPS_INTERESTING_CENTRE:
		left = (in-&gt;Xsize - smartcrop-&gt;width) / 2;
		top = (in-&gt;Ysize - smartcrop-&gt;height) / 2;
		break;

	case VIPS_INTERESTING_ENTROPY:
		if( vips_smartcrop_entropy( smartcrop, in, &amp;left, &amp;top ) )
			return( -1 );
		break;

	case VIPS_INTERESTING_ATTENTION:
		if( vips_smartcrop_attention( smartcrop, in, &amp;left, &amp;top ) )
			return( -1 );
		break;

	case VIPS_INTERESTING_HIGH:
		left = in-&gt;Xsize - smartcrop-&gt;width;
		top = in-&gt;Ysize - smartcrop-&gt;height;
		break;

	case VIPS_INTERESTING_ALL:
		left = 0;
		top = 0;
		smartcrop-&gt;width = in-&gt;Xsize;
		smartcrop-&gt;height = in-&gt;Ysize;
		break;

	default:
		g_assert_not_reached();

		/* Stop a compiler warning.
		 */
		left = 0;
		top = 0;
		break;
	}

	if( vips_extract_area( smartcrop-&gt;in, &amp;t[1], 
<A NAME="0"></A>			left, top, 
			smartcrop-&gt;width, smartcrop-&gt;height, NULL ) ||
		vips_image_write( t[1], conversion-&gt;out ) )
<FONT color="#0000ff"><A HREF="javascript:ZweiFrames('match19620-1.html#0',3,'match19620-top.html#0',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>		return( -1 ); 

	return( 0 );
}

static void
vips_smartcrop_class_init( VipsSmartcropClass *class )
{
	GObjectClass *gobject_class = G_OBJECT_CLASS( class );
	VipsObjectClass *vobject_class = VIPS_OBJECT_CLASS( class );

	VIPS_DEBUG_MSG( &quot;vips_smartcrop_class_init\n&quot; );

	gobject_class-&gt;set_property = vips_object_set_property;
	gobject_class-&gt;get_property = vips_object_get_property;

	vobject_class-&gt;nickname = &quot;smartcrop&quot;;
	vobject_class-&gt;description = _( &quot;extract an area from an image&quot; );
	vobject_class-&gt;build = vips_smartcrop_build;</B></FONT>

	VIPS_ARG_IMAGE( class, &quot;input&quot;, 0, 
		_( &quot;Input&quot; ), 
		_( &quot;Input image&quot; ),
		VIPS_ARGUMENT_REQUIRED_INPUT,
		G_STRUCT_OFFSET( VipsSmartcrop, in ) );

	VIPS_ARG_INT( class, &quot;width&quot;, 4, 
		_( &quot;Width&quot; ), 
		_( &quot;Width of extract area&quot; ),
		VIPS_ARGUMENT_REQUIRED_INPUT,
		G_STRUCT_OFFSET( VipsSmartcrop, width ),
		1, VIPS_MAX_COORD, 1 );

	VIPS_ARG_INT( class, &quot;height&quot;, 5, 
		_( &quot;Height&quot; ), 
		_( &quot;Height of extract area&quot; ),
		VIPS_ARGUMENT_REQUIRED_INPUT,
		G_STRUCT_OFFSET( VipsSmartcrop, height ),
		1, VIPS_MAX_COORD, 1 );

	VIPS_ARG_ENUM( class, &quot;interesting&quot;, 6, 
		_( &quot;Interesting&quot; ), 
		_( &quot;How to measure interestingness&quot; ),
		VIPS_ARGUMENT_OPTIONAL_INPUT,
		G_STRUCT_OFFSET( VipsSmartcrop, interesting ),
		VIPS_TYPE_INTERESTING, VIPS_INTERESTING_ATTENTION );

}

static void
vips_smartcrop_init( VipsSmartcrop *smartcrop )
{
	smartcrop-&gt;interesting = VIPS_INTERESTING_ATTENTION;
}

/**
 * vips_smartcrop: (method)
 * @in: input image
 * @out: (out): output image
 * @width: width of area to extract
 * @height: height of area to extract
 * @...: %NULL-terminated list of optional named arguments
 *
 * Optional arguments:
 *
 * * @interesting: #VipsInteresting to use to find interesting areas (default: #VIPS_INTERESTING_ATTENTION)
 *
 * Crop an image down to a specified width and height by removing boring parts. 
 *
 * Use @interesting to pick the method vips uses to decide which bits of the
 * image should be kept.
 *
 * You can test xoffset / yoffset on @out to find the location of the crop
 * within the input image.
 *
 * See also: vips_extract_area().
 * 
 * Returns: 0 on success, -1 on error.
 */
int
vips_smartcrop( VipsImage *in, VipsImage **out, int width, int height, ... )
{
	va_list ap;
	int result;

	va_start( ap, height );
	result = vips_call_split( &quot;smartcrop&quot;, ap, in, out, width, height );
	va_end( ap );

	return( result );
}
</PRE>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>quadratic.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
/* Resample an image with a quadratic transform.
 *
 * Original code from Reimar Lenz,
 * Adapted by Lars Raffelt for many bands,
 * VIPSified by JC ... other numeric types, partial output
 *
 * 7/11/12
 * 	- rewritten again for vips8
 */

/*

    This file is part of VIPS.
    
    VIPS is free software; you can redistribute it and/or modify
    it under the terms of the GNU Lesser General Public License as published by
    the Free Software Foundation; either version 2 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public License
    along with this program; if not, write to the Free Software
    Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
    02110-1301  USA

 */

/*

    These files are distributed with VIPS - http://www.vips.ecs.soton.ac.uk

 */

/*
#define DEBUG
#define DEBUG_GEOMETRY
 */

#ifdef HAVE_CONFIG_H
#include &lt;config.h&gt;
#endif /*HAVE_CONFIG_H*/
#include &lt;vips/intl.h&gt;

#include &lt;stdio.h&gt;
#include &lt;math.h&gt;

#include &lt;vips/vips.h&gt;
#include &lt;vips/debug.h&gt;

#include &quot;presample.h&quot;

/* The transform we compute:

x',y'  = coordinates of srcim
x,y    = coordinates of dstim
a .. l = coefficients

x = x' + a              : order 0     image shift only
  + b x' + c y'   	: order 1     + affine transf.
  + d x' y'             : order 2     + bilinear transf.
  + e x' x' + f y' y'   : order 3     + quadratic transf.

y = y' + g            
  + h y' + i x'   
  + j y' x'             
  + k y' y' + l x' x'  

input matrix:

  a g
  --
  b h
  c i
  --
  d j
  --
  e k
  f l

matrix height may be 1, 3, 4, 6

 */

typedef struct _VipsQuadratic {
	VipsResample parent_instance;

	VipsImage *coeff;
	VipsInterpolate *interpolate;

	/* The coeff array argment, made into an in-memory double.
	 */
	VipsImage *mat;

	/* Transform order.
	 */
	int order;
} VipsQuadratic;

typedef VipsResampleClass VipsQuadraticClass;

G_DEFINE_TYPE( VipsQuadratic, vips_quadratic, VIPS_TYPE_RESAMPLE );

static void
vips_quadratic_dispose( GObject *gobject )
{
	VipsQuadratic *quadratic = (VipsQuadratic *) gobject;

	VIPS_UNREF( quadratic-&gt;mat ); 

	G_OBJECT_CLASS( vips_quadratic_parent_class )-&gt;dispose( gobject );
}

static int
vips_quadratic_gen( VipsRegion *or, void *vseq, 
	void *a, void *b, gboolean *stop )
{
	VipsRegion *ir = (VipsRegion *) vseq;
	VipsQuadratic *quadratic = (VipsQuadratic *) b;
	VipsResample *resample = VIPS_RESAMPLE( quadratic );
	VipsInterpolateMethod interpolate_fn = 
		vips_interpolate_get_method( quadratic-&gt;interpolate );

	/* @in is the enlarged image (borders on, after vips_embed()). Use
	 * @resample-&gt;in for the original, not-expanded image. 
	 */
	const VipsImage *in = (VipsImage *) a;

	const int ps = VIPS_IMAGE_SIZEOF_PEL( in );

	double *vec = VIPS_MATRIX( quadratic-&gt;mat, 0, 0 );

	int clip_width = resample-&gt;in-&gt;Xsize;
	int clip_height = resample-&gt;in-&gt;Ysize;

	int xlow = or-&gt;valid.left;
	int ylow = or-&gt;valid.top;
	int xhigh = VIPS_RECT_RIGHT( &amp;or-&gt;valid );
	int yhigh = VIPS_RECT_BOTTOM( &amp;or-&gt;valid );

	VipsPel *q;

	int xo, yo;		/* output coordinates, dstimage */
	int z;
	double fxi, fyi; 	/* input coordinates */
	double dx, dy;        	/* xo derivative of input coord. */
	double ddx, ddy;      	/* 2nd xo derivative of input coord. */

	VipsRect image;

	image.left = 0;
	image.top = 0;
	image.width = in-&gt;Xsize;
	image.height = in-&gt;Ysize;
	if( vips_region_image( ir, &amp;image ) )
		return( -1 );

	for( yo = ylow; yo &lt; yhigh; yo++ ) {
		fxi = 0.0;
		fyi = 0.0;
		dx = 0.0;
		dy = 0.0;
		ddx = 0.0;
		ddy = 0.0;

		switch( quadratic-&gt;order ) {
		case 3: 
			fxi += vec[10] * yo * yo + vec[8] * xlow * xlow;
			fyi += vec[11] * yo * yo + vec[9] * xlow * xlow;
			dx += vec[8];
			ddx += vec[8] * 2.0;
			dy += vec[9];
			ddy += vec[9] * 2.0;

		case 2: 
			fxi += vec[6] * xlow * yo;
			fyi += vec[7] * xlow * yo;
			dx += vec[6] * yo;
			dy += vec[7] * yo;

		case 1: 
			fxi += vec[4] * yo + vec[2] * xlow;
			fyi += vec[5] * yo + vec[3] * xlow;
			dx += vec[2];
			dy += vec[3];

		case 0: 
			fxi += vec[0];
			fyi += vec[1];    
			break;

		default:
		    	g_assert_not_reached();
		}

		printf( &quot;dx = %g, dy = %g\n&quot;, dx, dy );

		q = VIPS_REGION_ADDR( or, xlow, yo );

		for( xo = xlow; xo &lt; xhigh; xo++ ) {
			int xi, yi; 	

			xi = fxi;
			yi = fyi;

			/* Clipping! 
			 */
			if( xi &lt; 0 || 
				yi &lt; 0 || 
				xi &gt;= clip_width || 
				yi &gt;= clip_height ) {
				for( z = 0; z &lt; ps; z++ ) 
					q[z] = 0;
			}
			else 
				interpolate_fn( quadratic-&gt;interpolate, 
					q, ir, fxi, fyi );

			q += ps;

			fxi += dx;
			fyi += dy;

			if( quadratic-&gt;order &gt; 2 ) {
				dx += ddx;
				dy += ddy;
			}
		}
	}

	return( 0 );
}

static int
vips_quadratic_build( VipsObject *object )
{
	VipsObjectClass *class = VIPS_OBJECT_GET_CLASS( object );
	VipsResample *resample = VIPS_RESAMPLE( object );
	VipsQuadratic *quadratic = (VipsQuadratic *) object;

	int window_size;
	int window_offset;
	VipsImage *in;
	VipsImage *t;

	if( VIPS_OBJECT_CLASS( vips_quadratic_parent_class )-&gt;build( object ) )
		return( -1 );

	/* We have the whole of the input in memory, so we can generate any
	 * output.
	 */
	if( vips_image_pipelinev( resample-&gt;out, 
		VIPS_DEMAND_STYLE_ANY, resample-&gt;in, NULL ) )
		return( -1 );

	in = resample-&gt;in;

        if( vips_check_uncoded( class-&gt;nickname, in ) ||
		vips_check_noncomplex( class-&gt;nickname, in ) ||
		vips_check_matrix( class-&gt;nickname, 
			quadratic-&gt;coeff, &amp;quadratic-&gt;mat  ) )
                return( -1 );

	if( quadratic-&gt;mat-&gt;Xsize != 2 ) {
		vips_error( class-&gt;nickname, 
			&quot;%s&quot;, _( &quot;coefficient matrix must have width 2&quot; ) ); 
		return( -1 );
	} 
        switch( quadratic-&gt;mat-&gt;Ysize ) {
	case 1: 
		quadratic-&gt;order = 0; 
		break;

	case 3: 
		quadratic-&gt;order = 1; 
		break;

	case 4: 
		quadratic-&gt;order = 2; 
		break;

	case 6: 
		quadratic-&gt;order = 3; 
		break;

	default:
		vips_error( class-&gt;nickname, 
			&quot;%s&quot;, _( &quot;coefficient matrix must have height &quot;
				&quot;1, 3, 4 or 6&quot; ) );
		return( -1 );
	} 

	if( !quadratic-&gt;interpolate )
		quadratic-&gt;interpolate = vips_interpolate_new( &quot;bilinear&quot; );

	window_size = vips_interpolate_get_window_size( quadratic-&gt;interpolate );
	window_offset = vips_interpolate_get_window_offset( quadratic-&gt;interpolate );

	/* Enlarge the input image. 
	 */
	if( vips_embed( in, &amp;t, 
		window_offset, window_offset, 
		in-&gt;Xsize + window_size, in-&gt;Ysize + window_size,
		&quot;extend&quot;, VIPS_EXTEND_COPY,
		NULL ) )
		return( -1 );
	vips_object_local( object, t );
	in = t;

        /* We need random access to our input.
         */
        if( !(t = vips_image_copy_memory( in )) )
                return( -1 );
	vips_object_local( object, t );
	in = t;

<A NAME="0"></A>	if( vips_image_generate( resample-&gt;out,
		vips_start_one, vips_quadratic_gen, vips_stop_one, 
			in, quadratic ) )
<FONT color="#0000ff"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match19620-0.html#0',2,'match19620-top.html#0',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>		return( -1 );

        return( 0 );
}

static void
vips_quadratic_class_init( VipsQuadraticClass *class )
{
	GObjectClass *gobject_class = G_OBJECT_CLASS( class );
	VipsObjectClass *vobject_class = VIPS_OBJECT_CLASS( class );

	VIPS_DEBUG_MSG( &quot;vips_quadratic_class_init\n&quot; );

	gobject_class-&gt;dispose = vips_quadratic_dispose;
	gobject_class-&gt;set_property = vips_object_set_property;
	gobject_class-&gt;get_property = vips_object_get_property;

	vobject_class-&gt;nickname = &quot;quadratic&quot;;
	vobject_class-&gt;description = </B></FONT>
		_( &quot;resample an image with a quadratic transform&quot; );
	vobject_class-&gt;build = vips_quadratic_build;

	VIPS_ARG_IMAGE( class, &quot;coeff&quot;, 8, 
		_( &quot;Coeff&quot; ), 
		_( &quot;Coefficient matrix&quot; ),
		VIPS_ARGUMENT_REQUIRED_INPUT,
		G_STRUCT_OFFSET( VipsQuadratic, coeff ) );

	VIPS_ARG_INTERPOLATE( class, &quot;interpolate&quot;, 9, 
		_( &quot;Interpolate&quot; ), 
		_( &quot;Interpolate values with this&quot; ),
		VIPS_ARGUMENT_OPTIONAL_INPUT,
		G_STRUCT_OFFSET( VipsQuadratic, interpolate ) );
}

static void
vips_quadratic_init( VipsQuadratic *quadratic )
{
}

/**
 * vips_quadratic: (method)
 * @in: input image
 * @out: (out): output image
 * @coeff: horizontal quadratic
 * @...: %NULL-terminated list of optional named arguments
 *
 * Optional arguments:
 *
 * * @interpolate: use this interpolator (default bilinear)
 *
 * This operation is unfinished and unusable, sorry. 
 *
 * See also: vips_affine().
 *
 * Returns: 0 on success, -1 on error
 */
int
vips_quadratic( VipsImage *in, VipsImage **out, VipsImage *coeff, ... )
{
	va_list ap;
	int result;

	va_start( ap, coeff );
	result = vips_call_split( &quot;quadratic&quot;, ap, in, out, coeff );
	va_end( ap );

	return( result );
}
</PRE>
</div>
  </div>
</body>
</html>
