<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for mmnormalize.c &amp; srutils.c</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for mmnormalize.c &amp; srutils.c
      </h3>
<h1 align="center">
        2.3%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>mmnormalize.c (3.1662269%)<th>srutils.c (1.8154311%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(94-99)<td><a href="#" name="0">(64-69)</a><td align="center"><font color="#ff0000">12</font>
</td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>mmnormalize.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 #include "config.h"
2 #include "rsyslog.h"
3 #include &lt;stdio.h&gt;
4 #include &lt;stdarg.h&gt;
5 #include &lt;stdlib.h&gt;
6 #include &lt;string.h&gt;
7 #include &lt;assert.h&gt;
8 #include &lt;signal.h&gt;
9 #include &lt;errno.h&gt;
10 #include &lt;unistd.h&gt;
11 #include &lt;libestr.h&gt;
12 #include &lt;json.h&gt;
13 #include &lt;liblognorm.h&gt;
14 #include "conf.h"
15 #include "syslogd-types.h"
16 #include "template.h"
17 #include "module-template.h"
18 #include "errmsg.h"
19 #include "cfsysline.h"
20 #include "dirty.h"
21 #include "unicode-helper.h"
22 MODULE_TYPE_OUTPUT
23 MODULE_TYPE_NOKEEP
24 MODULE_CNFNAME("mmnormalize")
25 static rsRetVal resetConfigVariables(uchar __attribute__((unused)) *pp, void __attribute__((unused)) *pVal);
26 DEF_OMOD_STATIC_DATA
27 static struct cnfparamdescr modpdescr[] = {
28 	{ "allowregex", eCmdHdlrBinary, 0 }
29 };
30 static struct cnfparamblk modpblk = {
31 	CNFPARAMBLK_VERSION,
32 	sizeof(modpdescr)/sizeof(struct cnfparamdescr),
33 	modpdescr
34 };
35 typedef struct _instanceData {
36 } instanceData;
37 typedef struct wrkrInstanceData {
38 	instanceData *pData;
39 } wrkrInstanceData_t;
40 typedef struct configSettings_s {
41 	uchar *rule;
42 } configSettings_t;
43 static configSettings_t cs;
44 <a name="0"></a>
45 <font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>static struct cnfparamdescr actpdescr[] = {
46 	{ "rulebase", eCmdHdlrGetWord, 0 },
47 	{ "rule", eCmdHdlrArray, 0 },
48 	{ "path", eCmdHdlrGetWord, 0 },
49 	{ "userawmsg", eCmdHdlrBinary, 0 },
50 	{ "variable", eCmdHdlrGetWord, 0 }</b></font>
51 };
52 static struct cnfparamblk actpblk =
53 	{ CNFPARAMBLK_VERSION,
54 	  sizeof(actpdescr)/sizeof(struct cnfparamdescr),
55 	  actpdescr
56 	};
57 struct modConfData_s {
58 	rsconf_t *pConf;		int allow_regex;
59 };
60 static modConfData_t *loadModConf = NULL;static modConfData_t *runModConf = NULL;
61 static void
62 errCallBack(void __attribute__((unused)) *cookie, const char *msg,
63 	    size_t __attribute__((unused)) lenMsg)
64 {
65 	LogError(0, RS_RET_ERR_LIBLOGNORM, "liblognorm error: %s", msg);
66 }
67 static rsRetVal
68 buildInstance(instanceData *pData)
69 {
70 	DEFiRet;
71 	if((pData-&gt;ctxln = ln_initCtx()) == NULL) {
72 		LogError(0, RS_RET_ERR_LIBLOGNORM_INIT, "error: could not initialize "
73 				"liblognorm ctx, cannot activate action");
74 		ABORT_FINALIZE(RS_RET_ERR_LIBLOGNORM_INIT);
75 	}
76 	ln_setCtxOpts(pData-&gt;ctxln, loadModConf-&gt;allow_regex);
77 	ln_setErrMsgCB(pData-&gt;ctxln, errCallBack, NULL);
78 	if(pData-&gt;rule !=NULL &amp;&amp; pData-&gt;rulebase == NULL) {
79 		if(ln_loadSamplesFromString(pData-&gt;ctxln, (char*) pData-&gt;rule) !=0) {
80 			LogError(0, RS_RET_NO_RULEBASE, "error: normalization rule '%s' "
81 					"could not be loaded cannot activate action", pData-&gt;rule);
82 			ln_exitCtx(pData-&gt;ctxln);
83 			ABORT_FINALIZE(RS_RET_ERR_LIBLOGNORM_SAMPDB_LOAD);
84 		}
85 		free(pData-&gt;rule);
86 		pData-&gt;rule = NULL;
87 	} else if(pData-&gt;rule ==NULL &amp;&amp; pData-&gt;rulebase != NULL) {
88 		if(ln_loadSamples(pData-&gt;ctxln, (char*) pData-&gt;rulebase) != 0) {
89 			LogError(0, RS_RET_NO_RULEBASE, "error: normalization rulebase '%s' "
90 					"could not be loaded cannot activate action", pData-&gt;rulebase);
91 			ln_exitCtx(pData-&gt;ctxln);
92 			ABORT_FINALIZE(RS_RET_ERR_LIBLOGNORM_SAMPDB_LOAD);
93 		}
94 	}
95 finalize_it:
96 	RETiRet;
97 }
98 BEGINinitConfVars		CODESTARTinitConfVars
99 	resetConfigVariables(NULL, NULL);
100 ENDinitConfVars
101 BEGINcreateInstance
102 CODESTARTcreateInstance
103 ENDcreateInstance
104 BEGINcreateWrkrInstance
105 CODESTARTcreateWrkrInstance
106 ENDcreateWrkrInstance
107 BEGINbeginCnfLoad
108 CODESTARTbeginCnfLoad
109 	loadModConf = pModConf;
110 	pModConf-&gt;pConf = pConf;
111 ENDbeginCnfLoad
112 BEGINendCnfLoad
113 CODESTARTendCnfLoad
114 	loadModConf = NULL; 	free(cs.rulebase);
115 	free(cs.rule);
116 	cs.rulebase = NULL;
117 	cs.rule = NULL;
118 ENDendCnfLoad
119 BEGINcheckCnf
120 CODESTARTcheckCnf
121 ENDcheckCnf
122 BEGINactivateCnf
123 CODESTARTactivateCnf
124 	runModConf = pModConf;
125 ENDactivateCnf
126 BEGINfreeCnf
127 CODESTARTfreeCnf
128 ENDfreeCnf
129 BEGINisCompatibleWithFeature
130 CODESTARTisCompatibleWithFeature
131 ENDisCompatibleWithFeature
132 BEGINfreeInstance
133 CODESTARTfreeInstance
134 	free(pData-&gt;rulebase);
135 	free(pData-&gt;rule);
136 	ln_exitCtx(pData-&gt;ctxln);
137 	free(pData-&gt;pszPath);
138 	msgPropDescrDestruct(pData-&gt;varDescr);
139 	free(pData-&gt;varDescr);
140 ENDfreeInstance
141 BEGINfreeWrkrInstance
142 CODESTARTfreeWrkrInstance
143 ENDfreeWrkrInstance
144 BEGINdbgPrintInstInfo
145 CODESTARTdbgPrintInstInfo
146 	dbgprintf("mmnormalize\n");
147 	dbgprintf("\tvariable='%s'\n", pData-&gt;varDescr-&gt;name);
148 	dbgprintf("\trulebase='%s'\n", pData-&gt;rulebase);
149 	dbgprintf("\trule='%s'\n", pData-&gt;rule);
150 	dbgprintf("\tpath='%s'\n", pData-&gt;pszPath);
151 	dbgprintf("\tbUseRawMsg='%d'\n", pData-&gt;bUseRawMsg);
152 ENDdbgPrintInstInfo
153 BEGINtryResume
154 CODESTARTtryResume
155 ENDtryResume
156 BEGINdoAction_NoStrings
157 	smsg_t **ppMsg = (smsg_t **) pMsgData;
158 	smsg_t *pMsg = ppMsg[0];
159 	uchar *buf;
160 	rs_size_t len;
161 	int r;
162 	struct json_object *json = NULL;
163 	unsigned short freeBuf = 0;
164 CODESTARTdoAction
165 	if(pWrkrData-&gt;pData-&gt;bUseRawMsg) {
166 		getRawMsg(pMsg, &amp;buf, &amp;len);
167 	} else if (pWrkrData-&gt;pData-&gt;varDescr) {
168 		buf = MsgGetProp(pMsg, NULL, pWrkrData-&gt;pData-&gt;varDescr, &amp;len, &amp;freeBuf, NULL);
169 	} else {
170 		buf = getMSG(pMsg);
171 		len = getMSGLen(pMsg);
172 	}
173 	r = ln_normalize(pWrkrData-&gt;pData-&gt;ctxln, (char*)buf, len, &amp;json);
174 	if (freeBuf) {
175 		free(buf);
176 		buf = NULL;
177 	}
178 	if(r != 0) {
179 		DBGPRINTF("error %d during ln_normalize\n", r);
180 		MsgSetParseSuccess(pMsg, 0);
181 	} else {
182 		MsgSetParseSuccess(pMsg, 1);
183 	}
184 	msgAddJSON(pMsg, (uchar*)pWrkrData-&gt;pData-&gt;pszPath + 1, json, 0, 0);
185 ENDdoAction
186 static void
187 setInstParamDefaults(instanceData *pData)
188 {
189 	pData-&gt;rulebase = NULL;
190 	pData-&gt;rule = NULL;
191 	pData-&gt;bUseRawMsg = 0;
192 	pData-&gt;pszPath = strdup("$!");
193 	pData-&gt;varDescr = NULL;
194 }
195 BEGINsetModCnf
196 	struct cnfparamvals *pvals = NULL;
197 	int i;
198 CODESTARTsetModCnf
199 	pvals = nvlstGetParams(lst, &amp;modpblk, NULL);
200 	if(pvals == NULL) {
201 		LogError(0, RS_RET_MISSING_CNFPARAMS, "mmnormalize: error processing module "
202 						"config parameters missing [module(...)]");
203 		ABORT_FINALIZE(RS_RET_MISSING_CNFPARAMS);
204 	}
205 	if(Debug) {
206 		dbgprintf("module (global) param blk for mmnormalize:\n");
207 		cnfparamsPrint(&amp;modpblk, pvals);
208 	}
209 	for(i = 0 ; i &lt; modpblk.nParams ; ++i) {
210 		if(!pvals[i].bUsed)
211 			continue;
212 		if(!strcmp(modpblk.descr[i].name, "allowregex")) {
213 			loadModConf-&gt;allow_regex = (int) pvals[i].val.d.n;
214 		} else {
215 			dbgprintf("mmnormalize: program error, non-handled "
216 					  "param '%s' in setModCnf\n", modpblk.descr[i].name);
217 		}
218 	}
219 finalize_it:
220 	if(pvals != NULL)
221 		cnfparamvalsDestruct(pvals, &amp;modpblk);
222 ENDsetModCnf
223 BEGINnewActInst
224 	struct cnfparamvals *pvals;
225 	int i;
226 	int bDestructPValsOnExit;
227 	char *cstr;
228 	char *varName = NULL;
229 	char *buffer;
230 	char *tStr;
231 	int size = 0;
232 CODESTARTnewActInst
233 	DBGPRINTF("newActInst (mmnormalize)\n");
234 	bDestructPValsOnExit = 0;
235 	pvals = nvlstGetParams(lst, &amp;actpblk, NULL);
236 	if(pvals == NULL) {
237 		LogError(0, RS_RET_MISSING_CNFPARAMS, "mmnormalize: error reading "
238 				"config parameters");
239 		ABORT_FINALIZE(RS_RET_MISSING_CNFPARAMS);
240 	}
241 	bDestructPValsOnExit = 1;
242 	if(Debug) {
243 		dbgprintf("action param blk in mmnormalize:\n");
244 		cnfparamsPrint(&amp;actpblk, pvals);
245 	}
246 	CHKiRet(createInstance(&amp;pData));
247 	setInstParamDefaults(pData);
248 	for(i = 0 ; i &lt; actpblk.nParams ; ++i) {
249 		if(!pvals[i].bUsed)
250 			continue;
251 		if(!strcmp(actpblk.descr[i].name, "rulebase")) {
252 			pData-&gt;rulebase = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
253 		} else if(!strcmp(actpblk.descr[i].name, "rule")) {
254 			for(int j=0; j &lt; pvals[i].val.d.ar-&gt;nmemb; ++j) {
255 				tStr = (char*)es_str2cstr(pvals[i].val.d.ar-&gt;arr[j], NULL);
256 				size += strlen(tStr);
257 				free(tStr);
258 			}
259 			buffer = malloc(size + pvals[i].val.d.ar-&gt;nmemb + 1);
260 			tStr = (char*)es_str2cstr(pvals[i].val.d.ar-&gt;arr[0], NULL);
261 			strcpy(buffer, tStr);
262 			free(tStr);
263 			strcat(buffer, "\n");
264 			for(int j=1; j &lt; pvals[i].val.d.ar-&gt;nmemb; ++j) {
265 				tStr = (char*)es_str2cstr(pvals[i].val.d.ar-&gt;arr[j], NULL);
266 				strcat(buffer, tStr);
267 				free(tStr);
268 				strcat(buffer, "\n");
269 			}
270 			strcat(buffer, "\0");
271 			pData-&gt;rule = (uchar*)buffer;
272 		} else if(!strcmp(actpblk.descr[i].name, "userawmsg")) {
273 			pData-&gt;bUseRawMsg = (int) pvals[i].val.d.n;
274 		} else if(!strcmp(actpblk.descr[i].name, "variable")) {
275 			varName = es_str2cstr(pvals[i].val.d.estr, NULL);
276 		} else if(!strcmp(actpblk.descr[i].name, "path")) {
277 			cstr = es_str2cstr(pvals[i].val.d.estr, NULL);
278 			if (strlen(cstr) &lt; 2) {
279 				LogError(0, RS_RET_VALUE_NOT_SUPPORTED,
280 						"mmnormalize: valid path name should be at least "
281 						"2 symbols long, got %s",	cstr);
282 				free(cstr);
283 			} else if (cstr[0] != '$') {
284 				LogError(0, RS_RET_VALUE_NOT_SUPPORTED,
285 						"mmnormalize: valid path name should start with $,"
286 						"got %s", cstr);
287 				free(cstr);
288 			} else {
289 				free(pData-&gt;pszPath);
290 				pData-&gt;pszPath = cstr;
291 			}
292 			continue;
293 		} else {
294 			DBGPRINTF("mmnormalize: program error, non-handled "
295 			  "param '%s'\n", actpblk.descr[i].name);
296 		}
297 	}
298 	if (varName) {
299 		if(pData-&gt;bUseRawMsg) {
300 			LogError(0, RS_RET_CONFIG_ERROR,
301 			                "mmnormalize: 'variable' param can't be used with 'useRawMsg'. "
302 			                "Ignoring 'variable', will use raw message.");
303 		} else {
304 			CHKmalloc(pData-&gt;varDescr = malloc(sizeof(msgPropDescr_t)));
305 			CHKiRet(msgPropDescrFill(pData-&gt;varDescr, (uchar*) varName, strlen(varName)));
306 		}
307 		free(varName);
308 		varName = NULL;
309 	}
310 	if(!pData-&gt;rulebase) {
311 		if(!pData-&gt;rule) {
312 			LogError(0, RS_RET_CONFIG_ERROR, "mmnormalize: rulebase needed. "
313 					"Use option rulebase or rule.");
314 		}
315 	}
316 	if(pData-&gt;rulebase) {
317 		if(pData-&gt;rule) {
318 			LogError(0, RS_RET_CONFIG_ERROR,
319 					"mmnormalize: only one rulebase possible, rulebase "
320 					"can't be used with rule");
321 		}
322 	}
323 	CODE_STD_STRING_REQUESTnewActInst(1)
324 	CHKiRet(OMSRsetEntry(*ppOMSR, 0, NULL, OMSR_TPL_AS_MSG));
325 	iRet = buildInstance(pData);
326 CODE_STD_FINALIZERnewActInst
327 	if(bDestructPValsOnExit)
328 		cnfparamvalsDestruct(pvals, &amp;actpblk);
329 ENDnewActInst
330 BEGINparseSelectorAct
331 CODESTARTparseSelectorAct
332 CODE_STD_STRING_REQUESTparseSelectorAct(1)
333 	if(strncmp((char*) p, ":mmnormalize:", sizeof(":mmnormalize:") - 1)) {
334 		ABORT_FINALIZE(RS_RET_CONFLINE_UNPROCESSED);
335 	}
336 	if(cs.rulebase == NULL &amp;&amp; cs.rule == NULL) {
337 		LogError(0, RS_RET_NO_RULEBASE, "error: no normalization rulebase was specified, use "
338 				"$MMNormalizeSampleDB directive first!");
339 		ABORT_FINALIZE(RS_RET_NO_RULEBASE);
340 	}
341 	p += sizeof(":mmnormalize:") - 1; 	CHKiRet(createInstance(&amp;pData));
342 	pData-&gt;rulebase = cs.rulebase;
343 	pData-&gt;rule = cs.rule;
344 	pData-&gt;bUseRawMsg = cs.bUseRawMsg;
345 	pData-&gt;pszPath = strdup("$!"); 	cs.bUseRawMsg = 0;
346 	cs.rulebase = NULL; 	cs.rule = NULL;
347 	if(*(p-1) == ';')
348 		--p;
349 	CHKiRet(cflineParseTemplateName(&amp;p, *ppOMSR, 0, OMSR_TPL_AS_MSG, (uchar*) "RSYSLOG_FileFormat"));
350 	CHKiRet(buildInstance(pData));
351 CODE_STD_FINALIZERparseSelectorAct
352 ENDparseSelectorAct
353 BEGINmodExit
354 CODESTARTmodExit
355 ENDmodExit
356 BEGINqueryEtryPt
357 CODESTARTqueryEtryPt
358 CODEqueryEtryPt_STD_OMOD_QUERIES
359 CODEqueryEtryPt_STD_OMOD8_QUERIES
360 CODEqueryEtryPt_STD_CONF2_QUERIES
361 CODEqueryEtryPt_STD_CONF2_setModCnf_QUERIES
362 CODEqueryEtryPt_STD_CONF2_OMOD_QUERIES
363 ENDqueryEtryPt
364 static rsRetVal resetConfigVariables(uchar __attribute__((unused)) *pp, void __attribute__((unused)) *pVal)
365 {
366 	DEFiRet;
367 	cs.rulebase = NULL;
368 	cs.rule = NULL;
369 	cs.bUseRawMsg = 0;
370 	RETiRet;
371 }
372 static rsRetVal
373 setRuleBase(void __attribute__((unused)) *pVal, uchar *pszName)
374 {
375 	DEFiRet;
376 	cs.rulebase = pszName;
377 	pszName = NULL;
378 	RETiRet;
379 }
380 BEGINmodInit()
381 	rsRetVal localRet;
382 	rsRetVal (*pomsrGetSupportedTplOpts)(unsigned long *pOpts);
383 	unsigned long opts;
384 	int bMsgPassingSupported;
385 CODESTARTmodInit
386 INITLegCnfVars
387 	*ipIFVersProvided = CURR_MOD_IF_VERSION;
388 CODEmodInit_QueryRegCFSLineHdlr
389 	DBGPRINTF("mmnormalize: module compiled with rsyslog version %s.\n", VERSION);
390 	bMsgPassingSupported = 0;
391 	localRet = pHostQueryEtryPt((uchar*)"OMSRgetSupportedTplOpts",
392 			&amp;pomsrGetSupportedTplOpts);
393 	if(localRet == RS_RET_OK) {
394 		CHKiRet((*pomsrGetSupportedTplOpts)(&amp;opts));
395 		if(opts &amp; OMSR_TPL_AS_MSG)
396 			bMsgPassingSupported = 1;
397 	} else if(localRet != RS_RET_ENTRY_POINT_NOT_FOUND) {
398 		ABORT_FINALIZE(localRet); 	}
399 	if(!bMsgPassingSupported) {
400 		DBGPRINTF("mmnormalize: msg-passing is not supported by rsyslog core, "
401 			  "can not continue.\n");
402 		ABORT_FINALIZE(RS_RET_NO_MSG_PASSING);
403 	}
404 	CHKiRet(omsdRegCFSLineHdlr((uchar *)"mmnormalizerulebase", 0, eCmdHdlrGetWord,
405 				    setRuleBase, NULL, STD_LOADABLE_MODULE_ID));
406 	CHKiRet(omsdRegCFSLineHdlr((uchar *)"mmnormalizerule", 0, eCmdHdlrGetWord, NULL,
407 				NULL, STD_LOADABLE_MODULE_ID));
408 	CHKiRet(omsdRegCFSLineHdlr((uchar *)"mmnormalizeuserawmsg", 0, eCmdHdlrBinary,
409 				NULL, &amp;cs.bUseRawMsg, STD_LOADABLE_MODULE_ID));
410 	CHKiRet(omsdRegCFSLineHdlr((uchar *)"resetconfigvariables", 1, eCmdHdlrCustomHandler,
411 				    resetConfigVariables, NULL, STD_LOADABLE_MODULE_ID));
412 ENDmodInit
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>srutils.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 #include "config.h"
2 #include &lt;stdio.h&gt;
3 #include &lt;stdlib.h&gt;
4 #include &lt;string.h&gt;
5 #include &lt;unistd.h&gt;
6 #include &lt;errno.h&gt;
7 #include &lt;sys/stat.h&gt;
8 #include &lt;sys/types.h&gt;
9 #include &lt;signal.h&gt;
10 #include &lt;assert.h&gt;
11 #include &lt;sys/wait.h&gt;
12 #include &lt;ctype.h&gt;
13 #include &lt;inttypes.h&gt;
14 #include &lt;fcntl.h&gt;
15 #include "rsyslog.h"
16 #include "srUtils.h"
17 #include "obj.h"
18 #include "errmsg.h"
19 #include "glbl.h"
20 #include "rsconf.h"
21 #if _POSIX_TIMERS &lt;= 0
22 #include &lt;sys/time.h&gt;
23 #endif
24 <font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>syslogName_t	syslogPriNames[] = {
25 	{"alert",	LOG_ALERT},
26 	{"crit",	LOG_CRIT},
27 	{"debug",	LOG_DEBUG},
28 	{"emerg",	LOG_EMERG},
29 	{"err",		LOG_ERR},</b></font>
30 	{"error",	LOG_ERR},			{"info",	LOG_INFO},
31 	{"none",	INTERNAL_NOPRI},		{"notice",	LOG_NOTICE},
32 	{"panic",	LOG_EMERG},			{"warn",	LOG_WARNING},			{"warning",	LOG_WARNING},
33 	{"*",		TABLE_ALLPRI},
34 	{NULL,		-1}
35 };
36 #ifndef LOG_AUTHPRIV
37 #	define LOG_AUTHPRIV LOG_AUTH
38 #endif
39 syslogName_t	syslogFacNames[] = {
40 	{"auth",         LOG_AUTH},
41 	{"authpriv",     LOG_AUTHPRIV},
42 	{"cron",         LOG_CRON},
43 	{"daemon",       LOG_DAEMON},
44 	{"kern",         LOG_KERN},
45 	{"lpr",          LOG_LPR},
46 	{"mail",         LOG_MAIL},
47 	{"mark",         LOG_MARK},			{"news",         LOG_NEWS},
48 	{"ntp",          (12&lt;&lt;3) },             	{"security",     LOG_AUTH},			{"bsd_security", (13&lt;&lt;3) },			{"syslog",       LOG_SYSLOG},
49 	{"user",         LOG_USER},
50 	{"uucp",         LOG_UUCP},
51 #if defined(_AIX)  	{ "caa",         LOG_CAA },
52 	{ "aso",         LOG_ASO },
53 #endif
54 #if defined(LOG_FTP)
55 	{"ftp",          LOG_FTP},
56 #endif
57 #if defined(LOG_AUDIT)
58 	{"audit",        LOG_AUDIT},
59 #endif
60 	{"console",	 (14 &lt;&lt; 3)},			{"local0",       LOG_LOCAL0},
61 	{"local1",       LOG_LOCAL1},
62 	{"local2",       LOG_LOCAL2},
63 	{"local3",       LOG_LOCAL3},
64 	{"local4",       LOG_LOCAL4},
65 	{"local5",       LOG_LOCAL5},
66 	{"local6",       LOG_LOCAL6},
67 	{"local7",       LOG_LOCAL7},
68 	{"invld",        LOG_INVLD},
69 	{NULL,           -1},
70 };
71 rsRetVal srUtilItoA(char *pBuf, int iLenBuf, number_t iToConv)
72 {
73 	int i;
74 	int bIsNegative;
75 	char szBuf[64];	
76 	assert(pBuf != NULL);
77 	assert(iLenBuf &gt; 1);	
78 	if(iToConv &lt; 0)
79 	{
80 		bIsNegative = RSTRUE;
81 		iToConv *= -1;
82 	}
83 	else
84 		bIsNegative = RSFALSE;
85 	i = 0;
86 	do
87 	{
88 		szBuf[i++] = iToConv % 10 + '0';
89 		iToConv /= 10;
90 	} while(iToConv &gt; 0);		--i; 
91 	if(i + 2 &gt; iLenBuf)			return RS_RET_PROVIDED_BUFFER_TOO_SMALL;
92 	if(bIsNegative == RSTRUE)
93 		*pBuf++ = '-';
94 	while(i &gt;= 0)
95 		*pBuf++ = szBuf[i--];
96 	*pBuf = '\0';	
97 	return RS_RET_OK;
98 }
99 uchar *srUtilStrDup(uchar *pOld, size_t len)
100 {
101 	uchar *pNew;
102 	assert(pOld != NULL);
103 	if((pNew = malloc(len + 1)) != NULL)
104 		memcpy(pNew, pOld, len + 1);
105 	return pNew;
106 }
107 static int real_makeFileParentDirs(const uchar *const szFile, const size_t lenFile, const mode_t mode,
108 	const uid_t uid, const gid_t gid, const int bFailOnChownFail)
109 {
110 	uchar *p;
111 	uchar *pszWork;
112 	size_t len;
113 	assert(szFile != NULL);
114 	assert(lenFile &gt; 0);
115 	len = lenFile + 1; 	if((pszWork = malloc(len)) == NULL)
116 		return -1;
117 	memcpy(pszWork, szFile, len);
118 	for(p = pszWork+1 ; *p ; p++)
119 		if(*p == '/') {
120 			*p = '\0';
121 			int bErr = 0;
122 			if(mkdir((char*)pszWork, mode) == 0) {
123 				if(uid != (uid_t) -1 || gid != (gid_t) -1) {
124 					if(chown((char*)pszWork, uid, gid) != 0) {
125 						LogError(errno, RS_RET_DIR_CHOWN_ERROR,
126 							"chown for directory '%s' failed", pszWork);
127 						if(bFailOnChownFail) {
128 							bErr = 1;
129 						}
130 					}
131 				}
132 			} else if(errno != EEXIST) {
133 				bErr = 1;
134 			}
135 			if(bErr) {
136 				int eSave = errno;
137 				free(pszWork);
138 				errno = eSave;
139 				return -1;
140 			}
141 			*p = '/';
142 		}
143 	free(pszWork);
144 	return 0;
145 }
146 int makeFileParentDirs(const uchar *const szFile, const size_t lenFile, const mode_t mode,
147 		       const uid_t uid, const gid_t gid, const int bFailOnChownFail)
148 {
149 	static pthread_mutex_t mutParentDir = PTHREAD_MUTEX_INITIALIZER;
150 	int r;		pthread_mutex_lock(&amp;mutParentDir);
151 	pthread_cleanup_push(mutexCancelCleanup, &amp;mutParentDir);
152 	r = real_makeFileParentDirs(szFile, lenFile, mode, uid, gid, bFailOnChownFail);
153 	pthread_mutex_unlock(&amp;mutParentDir);
154 	pthread_cleanup_pop(0);
155 	return r;
156 }
157 int execProg(uchar *program, int bWait, uchar *arg)
158 {
159 	int pid;
160 	int sig;
161 	struct sigaction sigAct;
162 	dbgprintf("exec program '%s' with param '%s'\n", program, arg);
163 	pid = fork();
164 	if (pid &lt; 0) {
165 		return 0;
166 	}
167 	if(pid) {       		if(bWait) {
168 			int status;
169 			if(waitpid(pid, &amp;status, 0) == pid) {
170 				glblReportChildProcessExit(runConf, program, pid, status);
171 			} else if(errno != ECHILD) {
172 				dbgprintf("could not wait on child after executing '%s'",
173 						(char*)program);
174 			}
175 		}
176 		return pid;
177 	}
178 	alarm(0); 
179 	memset(&amp;sigAct, 0, sizeof(sigAct));
180 	sigemptyset(&amp;sigAct.sa_mask);
181 	sigAct.sa_handler = SIG_DFL;
182 	for(sig = 1 ; sig &lt; NSIG ; ++sig)
183 		sigaction(sig, &amp;sigAct, NULL);
184 	execlp((char*)program, (char*) program, (char*)arg, NULL);
185 	perror("exec");
186 	fprintf(stderr, "exec program was '%s' with param '%s'\n", program, arg);
187 	exit(1); }
188 void skipWhiteSpace(uchar **pp)
189 {
190 	register uchar *p;
191 	assert(pp != NULL);
192 	assert(*pp != NULL);
193 	p = *pp;
194 	while(*p &amp;&amp; isspace((int) *p))
195 		++p;
196 	*pp = p;
197 }
198 PRAGMA_DIAGNOSTIC_PUSH
199 PRAGMA_IGNORE_Wformat_nonliteral
200 rsRetVal genFileName(uchar **ppName, uchar *pDirName, size_t lenDirName, uchar *pFName,
201 		     size_t lenFName, int64_t lNum, int lNumDigits)
202 {
203 	DEFiRet;
204 	uchar *pName;
205 	uchar *pNameWork;
206 	size_t lenName;
207 	uchar szBuf[128];		char szFmtBuf[32];		size_t lenBuf;
208 	if(lNum &lt; 0) {
209 		szBuf[0] = '\0';
210 		lenBuf = 0;
211 	} else {
212 		if(lNumDigits &gt; 0) {
213 			snprintf(szFmtBuf, sizeof(szFmtBuf), ".%%0%d" PRId64, lNumDigits);
214 			lenBuf = snprintf((char*)szBuf, sizeof(szBuf), szFmtBuf, lNum);
215 		} else
216 			lenBuf = snprintf((char*)szBuf, sizeof(szBuf), ".%" PRId64, lNum);
217 	}
218 	lenName = lenDirName + 1 + lenFName + lenBuf + 1; 	if((pName = malloc(lenName)) == NULL)
219 		ABORT_FINALIZE(RS_RET_OUT_OF_MEMORY);
220 	memcpy(pName, pDirName, lenDirName);
221 	pNameWork = pName + lenDirName;
222 	*pNameWork++ = '/';
223 	memcpy(pNameWork, pFName, lenFName);
224 	pNameWork += lenFName;
225 	if(lenBuf &gt; 0) {
226 		memcpy(pNameWork, szBuf, lenBuf);
227 		pNameWork += lenBuf;
228 	}
229 	*pNameWork = '\0';
230 	*ppName = pName;
231 finalize_it:
232 	RETiRet;
233 }
234 PRAGMA_DIAGNOSTIC_POP
235 int getNumberDigits(long lNum)
236 {
237 	int iDig;
238 	if(lNum == 0)
239 		iDig = 1;
240 	else
241 		for(iDig = 0 ; lNum != 0 ; ++iDig)
242 			lNum /= 10;
243 	return iDig;
244 }
245 rsRetVal
246 timeoutComp(struct timespec *pt, long iTimeout)
247 {
248 #	if _POSIX_TIMERS &lt;= 0
249 	struct timeval tv;
250 #	endif
251 	assert(pt != NULL);
252 #	if _POSIX_TIMERS &gt; 0
253 	clock_gettime(CLOCK_REALTIME, pt);
254 #	else
255 	gettimeofday(&amp;tv, NULL);
256 	pt-&gt;tv_sec = tv.tv_sec;
257 	pt-&gt;tv_nsec = tv.tv_usec * 1000;
258 #	endif
259 	pt-&gt;tv_sec += iTimeout / 1000;
260 	pt-&gt;tv_nsec += (iTimeout % 1000) * 1000000; 	if(pt-&gt;tv_nsec &gt; 999999999) { 		pt-&gt;tv_nsec -= 1000000000;
261 		++pt-&gt;tv_sec;
262 	}
263 	return RS_RET_OK; }
264 long long
265 currentTimeMills(void)
266 {
267 	struct timespec tm;
268 #	if _POSIX_TIMERS &lt;= 0
269 	struct timeval tv;
270 #	endif
271 #	if _POSIX_TIMERS &gt; 0
272 	clock_gettime(CLOCK_REALTIME, &amp;tm);
273 #	else
274 	gettimeofday(&amp;tv, NULL);
275 	tm.tv_sec = tv.tv_sec;
276 	tm.tv_nsec = tv.tv_usec * 1000;
277 #	endif
278 	return ((long long) tm.tv_sec) * 1000 + (tm.tv_nsec / 1000000);
279 }
280 long
281 timeoutVal(struct timespec *pt)
282 {
283 	struct timespec t;
284 	long iTimeout;
285 #	if _POSIX_TIMERS &lt;= 0
286 	struct timeval tv;
287 #	endif
288 	assert(pt != NULL);
289 #	if _POSIX_TIMERS &gt; 0
290 	clock_gettime(CLOCK_REALTIME, &amp;t);
291 #	else
292 	gettimeofday(&amp;tv, NULL);
293 	t.tv_sec = tv.tv_sec;
294 	t.tv_nsec = tv.tv_usec * 1000;
295 #	endif
296 	iTimeout = (pt-&gt;tv_nsec - t.tv_nsec) / 1000000;
297 	iTimeout += (pt-&gt;tv_sec - t.tv_sec) * 1000;
298 	if(iTimeout &lt; 0)
299 		iTimeout = 0;
300 	return iTimeout;
301 }
302 void
303 mutexCancelCleanup(void *arg)
304 {
305 	assert(arg != NULL);
306 	d_pthread_mutex_unlock((pthread_mutex_t*) arg);
307 }
308 void
309 srSleep(int iSeconds, int iuSeconds)
310 {
311 	struct timeval tvSelectTimeout;
312 	tvSelectTimeout.tv_sec = iSeconds;
313 	tvSelectTimeout.tv_usec = iuSeconds; 	select(0, NULL, NULL, NULL, &amp;tvSelectTimeout);
314 }
315 char *rs_strerror_r(int errnum, char *buf, size_t buflen) {
316 #ifndef HAVE_STRERROR_R
317 	char *pszErr;
318 	pszErr = strerror(errnum);
319 	snprintf(buf, buflen, "%s", pszErr);
320 #else
321 #	ifdef STRERROR_R_CHAR_P
322 		char *p = strerror_r(errnum, buf, buflen);
323 		if (p != buf) {
324 			strncpy(buf, p, buflen);
325 			buf[buflen - 1] = '\0';
326 		}
327 #	else
328 		strerror_r(errnum, buf, buflen);
329 #	endif
330 #endif 	return buf;
331 }
332 int decodeSyslogName(uchar *name, syslogName_t *codetab)
333 {
334 	register syslogName_t *c;
335 	register uchar *p;
336 	uchar buf[80];
337 	assert(name != NULL);
338 	assert(codetab != NULL);
339 	DBGPRINTF("symbolic name: %s", name);
340 	if(isdigit((int) *name)) {
341 		DBGPRINTF("\n");
342 		return (atoi((char*) name));
343 	}
344 	strncpy((char*) buf, (char*) name, 79);
345 	for(p = buf; *p; p++) {
346 		if (isupper((int) *p))
347 			*p = tolower((int) *p);
348 	}
349 	for(c = codetab; c-&gt;c_name; c++) {
350 		if(!strcmp((char*) buf, (char*) c-&gt;c_name)) {
351 			DBGPRINTF(" ==&gt; %d\n", c-&gt;c_val);
352 			return (c-&gt;c_val);
353 		}
354 	}
355 	DBGPRINTF("\n");
356 	return (-1);
357 }
358 int getSubString(uchar **ppSrc,  char *pDst, size_t DstSize, char cSep)
359 {
360 	uchar *pSrc = *ppSrc;
361 	int iErr = 0; 	while((cSep == ' ' ? !isspace(*pSrc) : *pSrc != cSep) &amp;&amp; *pSrc != '\n' &amp;&amp; *pSrc != '\0' &amp;&amp; DstSize&gt;1) {
362 		*pDst++ = *(pSrc)++;
363 		DstSize--;
364 	}
365 	if ((cSep == ' ' ? !isspace(*pSrc) : *pSrc != cSep) &amp;&amp; *pSrc != '\n' &amp;&amp; *pSrc != '\0') {
366 		dbgprintf("in getSubString, error Src buffer &gt; Dst buffer\n");
367 		iErr = 1;
368 	}
369 	if (*pSrc == '\0' || *pSrc == '\n')
370 		*ppSrc = pSrc;
371 	else
372 		*ppSrc = pSrc+1;
373 	*pDst = '\0';
374 	return iErr;
375 }
376 rsRetVal
377 getFileSize(uchar *pszName, off_t *pSize)
378 {
379 	int ret;
380 	struct stat statBuf;
381 	DEFiRet;
382 	ret = stat((char*) pszName, &amp;statBuf);
383 	if(ret == -1) {
384 		switch(errno) {
385 			case EACCES: ABORT_FINALIZE(RS_RET_NO_FILE_ACCESS);
386 			case ENOTDIR:
387 			case ENOENT:  ABORT_FINALIZE(RS_RET_FILE_NOT_FOUND);
388 			default:      ABORT_FINALIZE(RS_RET_FILE_NO_STAT);
389 		}
390 	}
391 	*pSize = statBuf.st_size;
392 finalize_it:
393 	RETiRet;
394 }
395 int
396 containsGlobWildcard(char *str)
397 {
398 	char *p;
399 	if(!str) {
400 		return 0;
401 	}
402 	for(p = str; *p != '\0'; p++) {
403 		if((*p == '?' || *p == '*' || *p == '[' || *p == '{') &amp;&amp;
404 				(p == str || *(p-1) != '\\')) {
405 			return 1;
406 		}
407 	}
408 	return 0;
409 }
410 static void seedRandomInsecureNumber(void)
411 {
412 	struct timespec t;
413 	timeoutComp(&amp;t, 0);
414 	long long x = t.tv_sec * 3 + t.tv_nsec * 2;
415 	srandom((unsigned int) x);
416 }
417 static long int randomInsecureNumber(void)
418 {
419 	return random();
420 }
421 #ifdef OS_LINUX
422 static int fdURandom = -1;
423 void seedRandomNumber(void)
424 {
425 	if(fdURandom &gt;= 0) {
426 		return;
427 	}
428 	fdURandom = open("/dev/urandom", O_RDONLY);
429 	if(fdURandom == -1) {
430 		LogError(errno, RS_RET_IO_ERROR, "failed to seed random number generation,"
431 			" will use fallback (open urandom failed)");
432 		seedRandomInsecureNumber();
433 	}
434 }
435 void seedRandomNumberForChild(void)
436 {
437 	fdURandom = -1;
438 	seedRandomNumber();
439 }
440 long int randomNumber(void)
441 {
442 	long int ret;
443 	if(fdURandom &gt;= 0) {
444 		if(read(fdURandom, &amp;ret, sizeof(long int)) == -1) {
445 			LogError(errno, RS_RET_IO_ERROR, "failed to generate random number, will"
446 				" use fallback (read urandom failed)");
447 			ret = randomInsecureNumber();
448 		}
449 	} else {
450 		ret = randomInsecureNumber();
451 	}
452 	return ret;
453 }
454 #else
455 void seedRandomNumber(void)
456 {
457 	seedRandomInsecureNumber();
458 }
459 void seedRandomNumberForChild(void)
460 {
461 	seedRandomNumber();
462 }
463 long int randomNumber(void)
464 {
465 	return randomInsecureNumber();
466 }
467 #endif
468 rsRetVal ATTR_NONNULL()
469 split_binary_parameters(uchar **const szBinary, char ***const __restrict__ aParams,
470 	int *const iParams, es_str_t *const param_binary)
471 {
472 	es_size_t iCnt;
473 	es_size_t iStr;
474 	int iPrm;
475 	es_str_t *estrParams = NULL;
476 	es_str_t *estrBinary = param_binary;
477 	es_str_t *estrTmp = NULL;
478 	uchar *c;
479 	int bInQuotes;
480 	DEFiRet;
481 	assert(iParams != NULL);
482 	assert(param_binary != NULL);
483 	c = es_getBufAddr(param_binary);
484 	iCnt = 0;
485 	while(iCnt &lt; es_strlen(param_binary) ) {
486 		if (c[iCnt] == ' ') {
487 			estrBinary = es_newStrFromSubStr( param_binary, 0, iCnt);
488 			estrParams = es_newStrFromSubStr( param_binary, iCnt+1,
489 					es_strlen(param_binary));
490 			break;
491 		}
492 		iCnt++;
493 	}
494 	*szBinary = (uchar*)es_str2cstr(estrBinary, NULL);
495 	DBGPRINTF("szBinary = '%s'\n", *szBinary);
496 	*iParams = 1; 	if (estrParams != NULL) {
497 		 (*iParams)++; 		if(Debug) {
498 			char *params = es_str2cstr(estrParams, NULL);
499 			dbgprintf("szParams = '%s'\n", params);
500 			free(params);
501 		}
502 		c = es_getBufAddr(estrParams);
503 		for(iCnt = 0 ; iCnt &lt; es_strlen(estrParams) ; ++iCnt) {
504 			if (c[iCnt] == ' ' &amp;&amp; c[iCnt-1] != '\\')
505 				 (*iParams)++;
506 		}
507 	}
508 	DBGPRINTF("iParams %d (+1 for NULL terminator)\n", *iParams);
509 	CHKmalloc(*aParams = malloc((*iParams + 1) * sizeof(char*)));
510 	iPrm = 0;
511 	bInQuotes = FALSE;
512 	(*aParams)[iPrm] = strdup((char*)*szBinary);
513 	iPrm++;
514 	if (estrParams != NULL) {
515 		iCnt = iStr = 0;
516 		c = es_getBufAddr(estrParams); 		while(iCnt &lt; es_strlen(estrParams) ) {
517 			if ( c[iCnt] == ' ' &amp;&amp; !bInQuotes ) {
518 				estrTmp = es_newStrFromSubStr( estrParams, iStr, iCnt-iStr);
519 			} else if ( iCnt+1 &gt;= es_strlen(estrParams) ) {
520 				estrTmp = es_newStrFromSubStr( estrParams, iStr, iCnt-iStr+1);
521 			} else if (c[iCnt] == '"') {
522 				bInQuotes = !bInQuotes;
523 			}
524 			if ( estrTmp != NULL ) {
525 				(*aParams)[iPrm] = es_str2cstr(estrTmp, NULL);
526 				iStr = iCnt+1; 				DBGPRINTF("Param (%d): '%s'\n", iPrm, (*aParams)[iPrm]);
527 				es_deleteStr( estrTmp );
528 				estrTmp = NULL;
529 				iPrm++;
530 			}
531 			iCnt++;
532 		}
533 	}
534 	(*aParams)[iPrm] = NULL; 
535 finalize_it:
536 	if(estrBinary != param_binary) {
537 		es_deleteStr(estrBinary);
538 	}
539 	if(estrParams != NULL) {
540 		es_deleteStr(estrParams);
541 	}
542 	RETiRet;
543 }
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
