<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML><HEAD><TITLE>Matches for mmnormalize.c & srutils.c</TITLE>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
</HEAD>
<body>
  <div style="align-items: center; display: flex; justify-content: space-around;">
    <div>
      <h3 align="center">
Matches for mmnormalize.c & srutils.c
      </h3>
      <h1 align="center">
        2.3%
      </h1>
      <center>
        <a href="index.html" target="_top">
          INDEX
        </a>
        <span>-</span>
        <a href="help-en.html" target="_top">
          HELP
        </a>
      </center>
    </div>
    <div>
<TABLE BORDER="1" CELLSPACING="0" BGCOLOR="#d0d0d0">
<TR><TH><TH>mmnormalize.c (3.1662269%)<TH>srutils.c (1.8154311%)<TH>Tokens
<TR><TD BGCOLOR="#0000ff"><FONT COLOR="#0000ff">-</FONT><TD><A HREF="javascript:ZweiFrames('match3532-0.html#0',2,'match3532-1.html#0',3)" NAME="0">(94-99)<TD><A HREF="javascript:ZweiFrames('match3532-0.html#0',2,'match3532-1.html#0',3)" NAME="0">(64-69)</A><TD ALIGN=center><FONT COLOR="#ff0000">12</FONT>
</TABLE>
    </div>
  </div>
  <hr>
  <div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>mmnormalize.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
/* mmnormalize.c
 * This is a message modification module. It normalizes the input message with
 * the help of liblognorm. The message's JSON variables are updated.
 *
 * NOTE: read comments in module-template.h for details on the calling interface!
 *
 * File begun on 2010-01-01 by RGerhards
 *
 * Copyright 2010-2015 Rainer Gerhards and Adiscon GmbH.
 *
 * This file is part of rsyslog.
 *
 * Rsyslog is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * Rsyslog is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with Rsyslog.  If not, see &lt;http://www.gnu.org/licenses/&gt;.
 *
 * A copy of the GPL can be found in the file &quot;COPYING&quot; in this distribution.
 */
#include &quot;config.h&quot;
#include &quot;rsyslog.h&quot;
#include &lt;stdio.h&gt;
#include &lt;stdarg.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;assert.h&gt;
#include &lt;signal.h&gt;
#include &lt;errno.h&gt;
#include &lt;unistd.h&gt;
#include &lt;libestr.h&gt;
#include &lt;json.h&gt;
#include &lt;liblognorm.h&gt;
#include &quot;conf.h&quot;
#include &quot;syslogd-types.h&quot;
#include &quot;template.h&quot;
#include &quot;module-template.h&quot;
#include &quot;errmsg.h&quot;
#include &quot;cfsysline.h&quot;
#include &quot;dirty.h&quot;
#include &quot;unicode-helper.h&quot;

MODULE_TYPE_OUTPUT
MODULE_TYPE_NOKEEP
MODULE_CNFNAME(&quot;mmnormalize&quot;)

static rsRetVal resetConfigVariables(uchar __attribute__((unused)) *pp, void __attribute__((unused)) *pVal);

/* static data */

/* internal structures
 */
DEF_OMOD_STATIC_DATA

static struct cnfparamdescr modpdescr[] = {
	{ &quot;allowregex&quot;, eCmdHdlrBinary, 0 }
};

static struct cnfparamblk modpblk = {
	CNFPARAMBLK_VERSION,
	sizeof(modpdescr)/sizeof(struct cnfparamdescr),
	modpdescr
};

typedef struct _instanceData {
	sbool bUseRawMsg;	/**&lt; use %rawmsg% instead of %msg% */
	uchar   *rule;		/* rule to use */
	uchar 	*rulebase;	/**&lt; name of rulebase to use */
	ln_ctx ctxln;		/**&lt; context to be used for liblognorm */
	char *pszPath;		/**&lt; path of normalized data */
	msgPropDescr_t *varDescr;/**&lt; name of variable to use */
} instanceData;

typedef struct wrkrInstanceData {
	instanceData *pData;
} wrkrInstanceData_t;

typedef struct configSettings_s {
	uchar *rulebase;		/**&lt; name of normalization rulebase to use */
	uchar *rule;
	int bUseRawMsg;	/**&lt; use %rawmsg% instead of %msg% */
} configSettings_t;
static configSettings_t cs;
<A NAME="0"></A>
/* tables for interfacing with the v6 config system */
/* action (instance) parameters */
<FONT color="#0000ff"><A HREF="javascript:ZweiFrames('match3532-1.html#0',3,'match3532-top.html#0',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>static struct cnfparamdescr actpdescr[] = {
	{ &quot;rulebase&quot;, eCmdHdlrGetWord, 0 },
	{ &quot;rule&quot;, eCmdHdlrArray, 0 },
	{ &quot;path&quot;, eCmdHdlrGetWord, 0 },
	{ &quot;userawmsg&quot;, eCmdHdlrBinary, 0 },
	{ &quot;variable&quot;, eCmdHdlrGetWord, 0 }</B></FONT>
};
static struct cnfparamblk actpblk =
	{ CNFPARAMBLK_VERSION,
	  sizeof(actpdescr)/sizeof(struct cnfparamdescr),
	  actpdescr
	};

struct modConfData_s {
	rsconf_t *pConf;	/* our overall config object */
	int allow_regex;
};

static modConfData_t *loadModConf = NULL;/* modConf ptr to use for the current load process */
static modConfData_t *runModConf = NULL;/* modConf ptr to use for the current exec process */

/* callback for liblognorm error messages */
static void
errCallBack(void __attribute__((unused)) *cookie, const char *msg,
	    size_t __attribute__((unused)) lenMsg)
{
	LogError(0, RS_RET_ERR_LIBLOGNORM, &quot;liblognorm error: %s&quot;, msg);
}

/* to be called to build the liblognorm part of the instance ONCE ALL PARAMETERS ARE CORRECT
 * (and set within pData!).
 */
static rsRetVal
buildInstance(instanceData *pData)
{
	DEFiRet;
	if((pData-&gt;ctxln = ln_initCtx()) == NULL) {
		LogError(0, RS_RET_ERR_LIBLOGNORM_INIT, &quot;error: could not initialize &quot;
				&quot;liblognorm ctx, cannot activate action&quot;);
		ABORT_FINALIZE(RS_RET_ERR_LIBLOGNORM_INIT);
	}
	ln_setCtxOpts(pData-&gt;ctxln, loadModConf-&gt;allow_regex);
	ln_setErrMsgCB(pData-&gt;ctxln, errCallBack, NULL);
	if(pData-&gt;rule !=NULL &amp;&amp; pData-&gt;rulebase == NULL) {
		if(ln_loadSamplesFromString(pData-&gt;ctxln, (char*) pData-&gt;rule) !=0) {
			LogError(0, RS_RET_NO_RULEBASE, &quot;error: normalization rule '%s' &quot;
					&quot;could not be loaded cannot activate action&quot;, pData-&gt;rule);
			ln_exitCtx(pData-&gt;ctxln);
			ABORT_FINALIZE(RS_RET_ERR_LIBLOGNORM_SAMPDB_LOAD);
		}
		free(pData-&gt;rule);
		pData-&gt;rule = NULL;
	} else if(pData-&gt;rule ==NULL &amp;&amp; pData-&gt;rulebase != NULL) {
		if(ln_loadSamples(pData-&gt;ctxln, (char*) pData-&gt;rulebase) != 0) {
			LogError(0, RS_RET_NO_RULEBASE, &quot;error: normalization rulebase '%s' &quot;
					&quot;could not be loaded cannot activate action&quot;, pData-&gt;rulebase);
			ln_exitCtx(pData-&gt;ctxln);
			ABORT_FINALIZE(RS_RET_ERR_LIBLOGNORM_SAMPDB_LOAD);
		}
	}
finalize_it:
	RETiRet;
}


BEGINinitConfVars		/* (re)set config variables to default values */
CODESTARTinitConfVars
	resetConfigVariables(NULL, NULL);
ENDinitConfVars


BEGINcreateInstance
CODESTARTcreateInstance
ENDcreateInstance


BEGINcreateWrkrInstance
CODESTARTcreateWrkrInstance
ENDcreateWrkrInstance


BEGINbeginCnfLoad
CODESTARTbeginCnfLoad
	loadModConf = pModConf;
	pModConf-&gt;pConf = pConf;
ENDbeginCnfLoad


BEGINendCnfLoad
CODESTARTendCnfLoad
	loadModConf = NULL; /* done loading */
	/* free legacy config vars */
	free(cs.rulebase);
	free(cs.rule);
	cs.rulebase = NULL;
	cs.rule = NULL;
ENDendCnfLoad

BEGINcheckCnf
CODESTARTcheckCnf
ENDcheckCnf

BEGINactivateCnf
CODESTARTactivateCnf
	runModConf = pModConf;
ENDactivateCnf

BEGINfreeCnf
CODESTARTfreeCnf
ENDfreeCnf


BEGINisCompatibleWithFeature
CODESTARTisCompatibleWithFeature
ENDisCompatibleWithFeature


BEGINfreeInstance
CODESTARTfreeInstance
	free(pData-&gt;rulebase);
	free(pData-&gt;rule);
	ln_exitCtx(pData-&gt;ctxln);
	free(pData-&gt;pszPath);
	msgPropDescrDestruct(pData-&gt;varDescr);
	free(pData-&gt;varDescr);
ENDfreeInstance


BEGINfreeWrkrInstance
CODESTARTfreeWrkrInstance
ENDfreeWrkrInstance


BEGINdbgPrintInstInfo
CODESTARTdbgPrintInstInfo
	dbgprintf(&quot;mmnormalize\n&quot;);
	dbgprintf(&quot;\tvariable='%s'\n&quot;, pData-&gt;varDescr-&gt;name);
	dbgprintf(&quot;\trulebase='%s'\n&quot;, pData-&gt;rulebase);
	dbgprintf(&quot;\trule='%s'\n&quot;, pData-&gt;rule);
	dbgprintf(&quot;\tpath='%s'\n&quot;, pData-&gt;pszPath);
	dbgprintf(&quot;\tbUseRawMsg='%d'\n&quot;, pData-&gt;bUseRawMsg);
ENDdbgPrintInstInfo


BEGINtryResume
CODESTARTtryResume
ENDtryResume

BEGINdoAction_NoStrings
	smsg_t **ppMsg = (smsg_t **) pMsgData;
	smsg_t *pMsg = ppMsg[0];
	uchar *buf;
	rs_size_t len;
	int r;
	struct json_object *json = NULL;
	unsigned short freeBuf = 0;
CODESTARTdoAction
	if(pWrkrData-&gt;pData-&gt;bUseRawMsg) {
		getRawMsg(pMsg, &amp;buf, &amp;len);
	} else if (pWrkrData-&gt;pData-&gt;varDescr) {
		buf = MsgGetProp(pMsg, NULL, pWrkrData-&gt;pData-&gt;varDescr, &amp;len, &amp;freeBuf, NULL);
	} else {
		buf = getMSG(pMsg);
		len = getMSGLen(pMsg);
	}
	r = ln_normalize(pWrkrData-&gt;pData-&gt;ctxln, (char*)buf, len, &amp;json);
	if (freeBuf) {
		free(buf);
		buf = NULL;
	}
	if(r != 0) {
		DBGPRINTF(&quot;error %d during ln_normalize\n&quot;, r);
		MsgSetParseSuccess(pMsg, 0);
	} else {
		MsgSetParseSuccess(pMsg, 1);
	}

	msgAddJSON(pMsg, (uchar*)pWrkrData-&gt;pData-&gt;pszPath + 1, json, 0, 0);

ENDdoAction


static void
setInstParamDefaults(instanceData *pData)
{
	pData-&gt;rulebase = NULL;
	pData-&gt;rule = NULL;
	pData-&gt;bUseRawMsg = 0;
	pData-&gt;pszPath = strdup(&quot;$!&quot;);
	pData-&gt;varDescr = NULL;
}

BEGINsetModCnf
	struct cnfparamvals *pvals = NULL;
	int i;
CODESTARTsetModCnf
	pvals = nvlstGetParams(lst, &amp;modpblk, NULL);
	if(pvals == NULL) {
		LogError(0, RS_RET_MISSING_CNFPARAMS, &quot;mmnormalize: error processing module &quot;
						&quot;config parameters missing [module(...)]&quot;);
		ABORT_FINALIZE(RS_RET_MISSING_CNFPARAMS);
	}
	
	if(Debug) {
		dbgprintf(&quot;module (global) param blk for mmnormalize:\n&quot;);
		cnfparamsPrint(&amp;modpblk, pvals);
	}
	
	for(i = 0 ; i &lt; modpblk.nParams ; ++i) {
		if(!pvals[i].bUsed)
			continue;
		if(!strcmp(modpblk.descr[i].name, &quot;allowregex&quot;)) {
			loadModConf-&gt;allow_regex = (int) pvals[i].val.d.n;
		} else {
			dbgprintf(&quot;mmnormalize: program error, non-handled &quot;
					  &quot;param '%s' in setModCnf\n&quot;, modpblk.descr[i].name);
		}
	}
	
finalize_it:
	if(pvals != NULL)
		cnfparamvalsDestruct(pvals, &amp;modpblk);
ENDsetModCnf


BEGINnewActInst
	struct cnfparamvals *pvals;
	int i;
	int bDestructPValsOnExit;
	char *cstr;
	char *varName = NULL;
	char *buffer;
	char *tStr;
	int size = 0;
CODESTARTnewActInst
	DBGPRINTF(&quot;newActInst (mmnormalize)\n&quot;);

	bDestructPValsOnExit = 0;
	pvals = nvlstGetParams(lst, &amp;actpblk, NULL);
	if(pvals == NULL) {
		LogError(0, RS_RET_MISSING_CNFPARAMS, &quot;mmnormalize: error reading &quot;
				&quot;config parameters&quot;);
		ABORT_FINALIZE(RS_RET_MISSING_CNFPARAMS);
	}
	bDestructPValsOnExit = 1;

	if(Debug) {
		dbgprintf(&quot;action param blk in mmnormalize:\n&quot;);
		cnfparamsPrint(&amp;actpblk, pvals);
	}

	CHKiRet(createInstance(&amp;pData));
	setInstParamDefaults(pData);

	for(i = 0 ; i &lt; actpblk.nParams ; ++i) {
		if(!pvals[i].bUsed)
			continue;
		if(!strcmp(actpblk.descr[i].name, &quot;rulebase&quot;)) {
			pData-&gt;rulebase = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
		} else if(!strcmp(actpblk.descr[i].name, &quot;rule&quot;)) {
			for(int j=0; j &lt; pvals[i].val.d.ar-&gt;nmemb; ++j) {
				tStr = (char*)es_str2cstr(pvals[i].val.d.ar-&gt;arr[j], NULL);
				size += strlen(tStr);
				free(tStr);
			}
			buffer = malloc(size + pvals[i].val.d.ar-&gt;nmemb + 1);
			tStr = (char*)es_str2cstr(pvals[i].val.d.ar-&gt;arr[0], NULL);
			strcpy(buffer, tStr);
			free(tStr);
			strcat(buffer, &quot;\n&quot;);
			for(int j=1; j &lt; pvals[i].val.d.ar-&gt;nmemb; ++j) {
				tStr = (char*)es_str2cstr(pvals[i].val.d.ar-&gt;arr[j], NULL);
				strcat(buffer, tStr);
				free(tStr);
				strcat(buffer, &quot;\n&quot;);
			}
			strcat(buffer, &quot;\0&quot;);
			pData-&gt;rule = (uchar*)buffer;
		} else if(!strcmp(actpblk.descr[i].name, &quot;userawmsg&quot;)) {
			pData-&gt;bUseRawMsg = (int) pvals[i].val.d.n;
		} else if(!strcmp(actpblk.descr[i].name, &quot;variable&quot;)) {
			varName = es_str2cstr(pvals[i].val.d.estr, NULL);
		} else if(!strcmp(actpblk.descr[i].name, &quot;path&quot;)) {
			cstr = es_str2cstr(pvals[i].val.d.estr, NULL);
			if (strlen(cstr) &lt; 2) {
				LogError(0, RS_RET_VALUE_NOT_SUPPORTED,
						&quot;mmnormalize: valid path name should be at least &quot;
						&quot;2 symbols long, got %s&quot;,	cstr);
				free(cstr);
			} else if (cstr[0] != '$') {
				LogError(0, RS_RET_VALUE_NOT_SUPPORTED,
						&quot;mmnormalize: valid path name should start with $,&quot;
						&quot;got %s&quot;, cstr);
				free(cstr);
			} else {
				free(pData-&gt;pszPath);
				pData-&gt;pszPath = cstr;
			}
			continue;
		} else {
			DBGPRINTF(&quot;mmnormalize: program error, non-handled &quot;
			  &quot;param '%s'\n&quot;, actpblk.descr[i].name);
		}
	}

	if (varName) {
		if(pData-&gt;bUseRawMsg) {
			LogError(0, RS_RET_CONFIG_ERROR,
			                &quot;mmnormalize: 'variable' param can't be used with 'useRawMsg'. &quot;
			                &quot;Ignoring 'variable', will use raw message.&quot;);
		} else {
			CHKmalloc(pData-&gt;varDescr = malloc(sizeof(msgPropDescr_t)));
			CHKiRet(msgPropDescrFill(pData-&gt;varDescr, (uchar*) varName, strlen(varName)));
		}
		free(varName);
		varName = NULL;
	}
	if(!pData-&gt;rulebase) {
		if(!pData-&gt;rule) {
			LogError(0, RS_RET_CONFIG_ERROR, &quot;mmnormalize: rulebase needed. &quot;
					&quot;Use option rulebase or rule.&quot;);
		}
	}
	if(pData-&gt;rulebase) {
		if(pData-&gt;rule) {
			LogError(0, RS_RET_CONFIG_ERROR,
					&quot;mmnormalize: only one rulebase possible, rulebase &quot;
					&quot;can't be used with rule&quot;);
		}
	}

	CODE_STD_STRING_REQUESTnewActInst(1)
	CHKiRet(OMSRsetEntry(*ppOMSR, 0, NULL, OMSR_TPL_AS_MSG));
	iRet = buildInstance(pData);
CODE_STD_FINALIZERnewActInst
	if(bDestructPValsOnExit)
		cnfparamvalsDestruct(pvals, &amp;actpblk);
ENDnewActInst


BEGINparseSelectorAct
CODESTARTparseSelectorAct
CODE_STD_STRING_REQUESTparseSelectorAct(1)
	/* first check if this config line is actually for us */
	if(strncmp((char*) p, &quot;:mmnormalize:&quot;, sizeof(&quot;:mmnormalize:&quot;) - 1)) {
		ABORT_FINALIZE(RS_RET_CONFLINE_UNPROCESSED);
	}

	if(cs.rulebase == NULL &amp;&amp; cs.rule == NULL) {
		LogError(0, RS_RET_NO_RULEBASE, &quot;error: no normalization rulebase was specified, use &quot;
				&quot;$MMNormalizeSampleDB directive first!&quot;);
		ABORT_FINALIZE(RS_RET_NO_RULEBASE);
	}

	/* ok, if we reach this point, we have something for us */
	p += sizeof(&quot;:mmnormalize:&quot;) - 1; /* eat indicator sequence  (-1 because of '\0'!) */
	CHKiRet(createInstance(&amp;pData));

	pData-&gt;rulebase = cs.rulebase;
	pData-&gt;rule = cs.rule;
	pData-&gt;bUseRawMsg = cs.bUseRawMsg;
	pData-&gt;pszPath = strdup(&quot;$!&quot;); /* old interface does not support this feature */
	/* all config vars auto-reset! */
	cs.bUseRawMsg = 0;
	cs.rulebase = NULL; /* we used it up! */
	cs.rule = NULL;

	/* check if a non-standard template is to be applied */
	if(*(p-1) == ';')
		--p;
	/* we call the function below because we need to call it via our interface definition. However,
	 * the format specified (if any) is always ignored.
	 */
	CHKiRet(cflineParseTemplateName(&amp;p, *ppOMSR, 0, OMSR_TPL_AS_MSG, (uchar*) &quot;RSYSLOG_FileFormat&quot;));
	CHKiRet(buildInstance(pData));
CODE_STD_FINALIZERparseSelectorAct
ENDparseSelectorAct


BEGINmodExit
CODESTARTmodExit
ENDmodExit


BEGINqueryEtryPt
CODESTARTqueryEtryPt
CODEqueryEtryPt_STD_OMOD_QUERIES
CODEqueryEtryPt_STD_OMOD8_QUERIES
CODEqueryEtryPt_STD_CONF2_QUERIES
CODEqueryEtryPt_STD_CONF2_setModCnf_QUERIES
CODEqueryEtryPt_STD_CONF2_OMOD_QUERIES
ENDqueryEtryPt



/* Reset config variables for this module to default values.
 */
static rsRetVal resetConfigVariables(uchar __attribute__((unused)) *pp, void __attribute__((unused)) *pVal)
{
	DEFiRet;
	cs.rulebase = NULL;
	cs.rule = NULL;
	cs.bUseRawMsg = 0;
	RETiRet;
}

/* set the rulebase name */
static rsRetVal
setRuleBase(void __attribute__((unused)) *pVal, uchar *pszName)
{
	DEFiRet;
	cs.rulebase = pszName;
	pszName = NULL;
	RETiRet;
}

BEGINmodInit()
	rsRetVal localRet;
	rsRetVal (*pomsrGetSupportedTplOpts)(unsigned long *pOpts);
	unsigned long opts;
	int bMsgPassingSupported;
CODESTARTmodInit
INITLegCnfVars
	*ipIFVersProvided = CURR_MOD_IF_VERSION;
		/* we only support the current interface specification */
CODEmodInit_QueryRegCFSLineHdlr
	DBGPRINTF(&quot;mmnormalize: module compiled with rsyslog version %s.\n&quot;, VERSION);
	/* check if the rsyslog core supports parameter passing code */
	bMsgPassingSupported = 0;
	localRet = pHostQueryEtryPt((uchar*)&quot;OMSRgetSupportedTplOpts&quot;,
			&amp;pomsrGetSupportedTplOpts);
	if(localRet == RS_RET_OK) {
		/* found entry point, so let's see if core supports msg passing */
		CHKiRet((*pomsrGetSupportedTplOpts)(&amp;opts));
		if(opts &amp; OMSR_TPL_AS_MSG)
			bMsgPassingSupported = 1;
	} else if(localRet != RS_RET_ENTRY_POINT_NOT_FOUND) {
		ABORT_FINALIZE(localRet); /* Something else went wrong, not acceptable */
	}
	
	if(!bMsgPassingSupported) {
		DBGPRINTF(&quot;mmnormalize: msg-passing is not supported by rsyslog core, &quot;
			  &quot;can not continue.\n&quot;);
		ABORT_FINALIZE(RS_RET_NO_MSG_PASSING);
	}

	CHKiRet(omsdRegCFSLineHdlr((uchar *)&quot;mmnormalizerulebase&quot;, 0, eCmdHdlrGetWord,
				    setRuleBase, NULL, STD_LOADABLE_MODULE_ID));
	CHKiRet(omsdRegCFSLineHdlr((uchar *)&quot;mmnormalizerule&quot;, 0, eCmdHdlrGetWord, NULL,
				NULL, STD_LOADABLE_MODULE_ID));
	CHKiRet(omsdRegCFSLineHdlr((uchar *)&quot;mmnormalizeuserawmsg&quot;, 0, eCmdHdlrBinary,
				NULL, &amp;cs.bUseRawMsg, STD_LOADABLE_MODULE_ID));
	CHKiRet(omsdRegCFSLineHdlr((uchar *)&quot;resetconfigvariables&quot;, 1, eCmdHdlrCustomHandler,
				    resetConfigVariables, NULL, STD_LOADABLE_MODULE_ID));
ENDmodInit

/* vi:set ai:
 */
</PRE>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>srutils.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
/**\file srUtils.c
 * \brief General utilties that fit nowhere else.
 *
 * The namespace for this file is &quot;srUtil&quot;.
 *
 * \author  Rainer Gerhards &lt;rgerhards@adiscon.com&gt;
 * \date    2003-09-09
 *          Coding begun.
 *
 * Copyright 2003-2018 Rainer Gerhards and Adiscon GmbH.
 *
 * This file is part of the rsyslog runtime library.
 *
 * The rsyslog runtime library is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * The rsyslog runtime library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with the rsyslog runtime library.  If not, see &lt;http://www.gnu.org/licenses/&gt;.
 *
 * A copy of the GPL can be found in the file &quot;COPYING&quot; in this distribution.
 * A copy of the LGPL can be found in the file &quot;COPYING.LESSER&quot; in this distribution.
 */
#include &quot;config.h&quot;

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;unistd.h&gt;
#include &lt;errno.h&gt;
#include &lt;sys/stat.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;signal.h&gt;
#include &lt;assert.h&gt;
#include &lt;sys/wait.h&gt;
#include &lt;ctype.h&gt;
#include &lt;inttypes.h&gt;
#include &lt;fcntl.h&gt;

#include &quot;rsyslog.h&quot;
#include &quot;srUtils.h&quot;
#include &quot;obj.h&quot;
#include &quot;errmsg.h&quot;
#include &quot;glbl.h&quot;
#include &quot;rsconf.h&quot;

#if _POSIX_TIMERS &lt;= 0
#include &lt;sys/time.h&gt;
#endif

/* here we host some syslog specific names. There currently is no better place
 * to do it, but over here is also not ideal... -- rgerhards, 2008-02-14
 * rgerhards, 2008-04-16: note in LGPL move: the code tables below exist in
 * the same way in BSD, so it is not a problem to move them from GPLv3 to LGPL.
<A NAME="0"></A> * And nobody modified them since it was under LGPL, so we can also move it
 * to ASL 2.0.
 */
<FONT color="#0000ff"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match3532-0.html#0',2,'match3532-top.html#0',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>syslogName_t	syslogPriNames[] = {
	{&quot;alert&quot;,	LOG_ALERT},
	{&quot;crit&quot;,	LOG_CRIT},
	{&quot;debug&quot;,	LOG_DEBUG},
	{&quot;emerg&quot;,	LOG_EMERG},
	{&quot;err&quot;,		LOG_ERR},</B></FONT>
	{&quot;error&quot;,	LOG_ERR},		/* DEPRECATED */
	{&quot;info&quot;,	LOG_INFO},
	{&quot;none&quot;,	INTERNAL_NOPRI},	/* INTERNAL */
	{&quot;notice&quot;,	LOG_NOTICE},
	{&quot;panic&quot;,	LOG_EMERG},		/* DEPRECATED */
	{&quot;warn&quot;,	LOG_WARNING},		/* DEPRECATED */
	{&quot;warning&quot;,	LOG_WARNING},
	{&quot;*&quot;,		TABLE_ALLPRI},
	{NULL,		-1}
};

#ifndef LOG_AUTHPRIV
#	define LOG_AUTHPRIV LOG_AUTH
#endif
syslogName_t	syslogFacNames[] = {
	{&quot;auth&quot;,         LOG_AUTH},
	{&quot;authpriv&quot;,     LOG_AUTHPRIV},
	{&quot;cron&quot;,         LOG_CRON},
	{&quot;daemon&quot;,       LOG_DAEMON},
	{&quot;kern&quot;,         LOG_KERN},
	{&quot;lpr&quot;,          LOG_LPR},
	{&quot;mail&quot;,         LOG_MAIL},
	{&quot;mark&quot;,         LOG_MARK},		/* INTERNAL */
	{&quot;news&quot;,         LOG_NEWS},
	{&quot;ntp&quot;,          (12&lt;&lt;3) },             /* NTP, perhaps BSD-specific? */
	{&quot;security&quot;,     LOG_AUTH},		/* DEPRECATED */
	{&quot;bsd_security&quot;, (13&lt;&lt;3) },		/* BSD-specific, unfortunatly with duplicate name... */
	{&quot;syslog&quot;,       LOG_SYSLOG},
	{&quot;user&quot;,         LOG_USER},
	{&quot;uucp&quot;,         LOG_UUCP},
#if defined(_AIX)  /* AIXPORT : These are necessary for AIX */
	{ &quot;caa&quot;,         LOG_CAA },
	{ &quot;aso&quot;,         LOG_ASO },
#endif
#if defined(LOG_FTP)
	{&quot;ftp&quot;,          LOG_FTP},
#endif
#if defined(LOG_AUDIT)
	{&quot;audit&quot;,        LOG_AUDIT},
#endif
	{&quot;console&quot;,	 (14 &lt;&lt; 3)},		/* BSD-specific priority */
	{&quot;local0&quot;,       LOG_LOCAL0},
	{&quot;local1&quot;,       LOG_LOCAL1},
	{&quot;local2&quot;,       LOG_LOCAL2},
	{&quot;local3&quot;,       LOG_LOCAL3},
	{&quot;local4&quot;,       LOG_LOCAL4},
	{&quot;local5&quot;,       LOG_LOCAL5},
	{&quot;local6&quot;,       LOG_LOCAL6},
	{&quot;local7&quot;,       LOG_LOCAL7},
	{&quot;invld&quot;,        LOG_INVLD},
	{NULL,           -1},
};

/* ################################################################# *
 * private members                                                   *
 * ################################################################# */

/* As this is not a &quot;real&quot; object, there won't be any private
 * members in this file.
 */

/* ################################################################# *
 * public members                                                    *
 * ################################################################# */

rsRetVal srUtilItoA(char *pBuf, int iLenBuf, number_t iToConv)
{
	int i;
	int bIsNegative;
	char szBuf[64];	/* sufficiently large for my lifespan and those of my children... ;) */

	assert(pBuf != NULL);
	assert(iLenBuf &gt; 1);	/* This is actually an app error and as thus checked for... */

	if(iToConv &lt; 0)
	{
		bIsNegative = RSTRUE;
		iToConv *= -1;
	}
	else
		bIsNegative = RSFALSE;

	/* first generate a string with the digits in the reverse direction */
	i = 0;
	do
	{
		szBuf[i++] = iToConv % 10 + '0';
		iToConv /= 10;
	} while(iToConv &gt; 0);	/* warning: do...while()! */
	--i; /* undo last increment - we were pointing at NEXT location */

	/* make sure we are within bounds... */
	if(i + 2 &gt; iLenBuf)	/* +2 because: a) i starts at zero! b) the \0 byte */
		return RS_RET_PROVIDED_BUFFER_TOO_SMALL;

	/* then move it to the right direction... */
	if(bIsNegative == RSTRUE)
		*pBuf++ = '-';
	while(i &gt;= 0)
		*pBuf++ = szBuf[i--];
	*pBuf = '\0';	/* terminate it!!! */

	return RS_RET_OK;
}

uchar *srUtilStrDup(uchar *pOld, size_t len)
{
	uchar *pNew;

	assert(pOld != NULL);

	if((pNew = malloc(len + 1)) != NULL)
		memcpy(pNew, pOld, len + 1);

	return pNew;
}


/* creates a path recursively
 * Return 0 on success, -1 otherwise. On failure, errno * hold the last OS error.
 * Param &quot;mode&quot; holds the mode that all non-existing directories are to be
 * created with.
 * Note that we have a potential race inside that code, a race that even exists
 * outside of the rsyslog process (if multiple instances run, or other programs
 * generate directories): If the directory does not exist, a context switch happens,
 * at that moment another process creates it, then our creation on the context
 * switch back fails. This actually happened in practice, and depending on the
 * configuration it is even likely to happen. We can not solve this situation
 * with a mutex, as that works only within out process space. So the solution
 * is that we take the optimistic approach, try the creation, and if it fails
 * with &quot;already exists&quot; we go back and do one retry of the check/create
 * sequence. That should then succeed. If the directory is still not found but
 * the creation fails in the similar way, we return an error on that second
 * try because otherwise we would potentially run into an endless loop.
 * loop. -- rgerhards, 2010-03-25
 * The likeliest scenario for a prolonged contest of creating the parent directiories
 * is within our process space. This can happen with a high probability when two
 * threads, that want to start logging to files within same directory tree, are
 * started close to each other. We should fix what we can. -- nipakoo, 2017-11-25
 */
static int real_makeFileParentDirs(const uchar *const szFile, const size_t lenFile, const mode_t mode,
	const uid_t uid, const gid_t gid, const int bFailOnChownFail)
{
	uchar *p;
	uchar *pszWork;
	size_t len;

	assert(szFile != NULL);
	assert(lenFile &gt; 0);

	len = lenFile + 1; /* add one for '\0'-byte */
	if((pszWork = malloc(len)) == NULL)
		return -1;
	memcpy(pszWork, szFile, len);
	for(p = pszWork+1 ; *p ; p++)
		if(*p == '/') {
			/* temporarily terminate string, create dir and go on */
			*p = '\0';
			int bErr = 0;
			if(mkdir((char*)pszWork, mode) == 0) {
				if(uid != (uid_t) -1 || gid != (gid_t) -1) {
					/* we need to set owner/group */
					if(chown((char*)pszWork, uid, gid) != 0) {
						LogError(errno, RS_RET_DIR_CHOWN_ERROR,
							&quot;chown for directory '%s' failed&quot;, pszWork);
						if(bFailOnChownFail) {
							/* ignore if configured to do so */
							bErr = 1;
						}
					}
				}
			} else if(errno != EEXIST) {
				/* EEXIST is ok, means this component exists */
				bErr = 1;
			}

			if(bErr) {
				int eSave = errno;
				free(pszWork);
				errno = eSave;
				return -1;
			}
			*p = '/';
		}
	free(pszWork);
	return 0;
}
/* note: this small function is the stub for the brain-dead POSIX cancel handling */
int makeFileParentDirs(const uchar *const szFile, const size_t lenFile, const mode_t mode,
		       const uid_t uid, const gid_t gid, const int bFailOnChownFail)
{
	static pthread_mutex_t mutParentDir = PTHREAD_MUTEX_INITIALIZER;
	int r;	/* needs to be declared OUTSIDE of pthread_cleanup... macros! */
	pthread_mutex_lock(&amp;mutParentDir);
	pthread_cleanup_push(mutexCancelCleanup, &amp;mutParentDir);

	r = real_makeFileParentDirs(szFile, lenFile, mode, uid, gid, bFailOnChownFail);

	pthread_mutex_unlock(&amp;mutParentDir);
	pthread_cleanup_pop(0);
	return r;
}


/* execute a program with a single argument
 * returns child pid if everything ok, 0 on failure. if
 * it fails, errno is set. if it fails after the fork(), the caller
 * can not be notfied for obvious reasons. if bwait is set to 1,
 * the code waits until the child terminates - that potentially takes
 * a lot of time.
 * implemented 2007-07-20 rgerhards
 */
int execProg(uchar *program, int bWait, uchar *arg)
{
	int pid;
	int sig;
	struct sigaction sigAct;

	dbgprintf(&quot;exec program '%s' with param '%s'\n&quot;, program, arg);
	pid = fork();
	if (pid &lt; 0) {
		return 0;
	}

	if(pid) {       /* Parent */
		if(bWait) {
			/* waitpid will fail with errno == ECHILD if the child process has already
			   been reaped by the rsyslogd main loop (see rsyslogd.c) */
			int status;
			if(waitpid(pid, &amp;status, 0) == pid) {
				glblReportChildProcessExit(runConf, program, pid, status);
			} else if(errno != ECHILD) {
				/* we do not use logerror(), because
				* that might bring us into an endless
				* loop. At some time, we may
				* reconsider this behaviour.
				*/
				dbgprintf(&quot;could not wait on child after executing '%s'&quot;,
						(char*)program);
			}
		}
		return pid;
	}
	/* Child */
	alarm(0); /* create a clean environment before we exec the real child */

	memset(&amp;sigAct, 0, sizeof(sigAct));
	sigemptyset(&amp;sigAct.sa_mask);
	sigAct.sa_handler = SIG_DFL;

	for(sig = 1 ; sig &lt; NSIG ; ++sig)
		sigaction(sig, &amp;sigAct, NULL);

	execlp((char*)program, (char*) program, (char*)arg, NULL);
	/* In the long term, it's a good idea to implement some enhanced error
	 * checking here. However, it can not easily be done. For starters, we
	 * may run into endless loops if we log to syslog. The next problem is
	 * that output is typically not seen by the user. For the time being,
	 * we use no error reporting, which is quite consitent with the old
	 * system() way of doing things. rgerhards, 2007-07-20
	 */
	perror(&quot;exec&quot;);
	fprintf(stderr, &quot;exec program was '%s' with param '%s'\n&quot;, program, arg);
	exit(1); /* not much we can do in this case */
}


/* skip over whitespace in a standard C string. The
 * provided pointer is advanced to the first non-whitespace
 * charater or the \0 byte, if there is none. It is never
 * moved past the \0.
 */
void skipWhiteSpace(uchar **pp)
{
	register uchar *p;

	assert(pp != NULL);
	assert(*pp != NULL);

	p = *pp;
	while(*p &amp;&amp; isspace((int) *p))
		++p;
	*pp = p;
}


/* generate a file name from four parts:
 * &lt;directory name&gt;/&lt;name&gt;.&lt;number&gt;
 * If number is negative, it is not used. If any of the strings is
 * NULL, an empty string is used instead. Length must be provided.
 * lNumDigits is the minimum number of digits that lNum should have. This
 * is to pretty-print the file name, e.g. lNum = 3, lNumDigits= 4 will
 * result in &quot;0003&quot; being used inside the file name. Set lNumDigits to 0
 * to use as few space as possible.
 * rgerhards, 2008-01-03
 */
PRAGMA_DIAGNOSTIC_PUSH
PRAGMA_IGNORE_Wformat_nonliteral
rsRetVal genFileName(uchar **ppName, uchar *pDirName, size_t lenDirName, uchar *pFName,
		     size_t lenFName, int64_t lNum, int lNumDigits)
{
	DEFiRet;
	uchar *pName;
	uchar *pNameWork;
	size_t lenName;
	uchar szBuf[128];	/* buffer for number */
	char szFmtBuf[32];	/* buffer for snprintf format */
	size_t lenBuf;

	if(lNum &lt; 0) {
		szBuf[0] = '\0';
		lenBuf = 0;
	} else {
		if(lNumDigits &gt; 0) {
			snprintf(szFmtBuf, sizeof(szFmtBuf), &quot;.%%0%d&quot; PRId64, lNumDigits);
			lenBuf = snprintf((char*)szBuf, sizeof(szBuf), szFmtBuf, lNum);
		} else
			lenBuf = snprintf((char*)szBuf, sizeof(szBuf), &quot;.%&quot; PRId64, lNum);
	}

	lenName = lenDirName + 1 + lenFName + lenBuf + 1; /* last +1 for \0 char! */
	if((pName = malloc(lenName)) == NULL)
		ABORT_FINALIZE(RS_RET_OUT_OF_MEMORY);

	/* got memory, now construct string */
	memcpy(pName, pDirName, lenDirName);
	pNameWork = pName + lenDirName;
	*pNameWork++ = '/';
	memcpy(pNameWork, pFName, lenFName);
	pNameWork += lenFName;
	if(lenBuf &gt; 0) {
		memcpy(pNameWork, szBuf, lenBuf);
		pNameWork += lenBuf;
	}
	*pNameWork = '\0';

	*ppName = pName;

finalize_it:
	RETiRet;
}
PRAGMA_DIAGNOSTIC_POP

/* get the number of digits required to represent a given number. We use an
 * iterative approach as we do not like to draw in the floating point
 * library just for log(). -- rgerhards, 2008-01-10
 */
int getNumberDigits(long lNum)
{
	int iDig;

	if(lNum == 0)
		iDig = 1;
	else
		for(iDig = 0 ; lNum != 0 ; ++iDig)
			lNum /= 10;

	return iDig;
}


/* compute an absolute time timeout suitable for calls to pthread_cond_timedwait()
 * iTimeout is in milliseconds
 * rgerhards, 2008-01-14
 */
rsRetVal
timeoutComp(struct timespec *pt, long iTimeout)
{
#	if _POSIX_TIMERS &lt;= 0
	struct timeval tv;
#	endif

	assert(pt != NULL);
	/* compute timeout */

#	if _POSIX_TIMERS &gt; 0
	/* this is the &quot;regular&quot; code */
	clock_gettime(CLOCK_REALTIME, pt);
#	else
	gettimeofday(&amp;tv, NULL);
	pt-&gt;tv_sec = tv.tv_sec;
	pt-&gt;tv_nsec = tv.tv_usec * 1000;
#	endif
	pt-&gt;tv_sec += iTimeout / 1000;
	pt-&gt;tv_nsec += (iTimeout % 1000) * 1000000; /* think INTEGER arithmetic! */
	if(pt-&gt;tv_nsec &gt; 999999999) { /* overrun? */
		pt-&gt;tv_nsec -= 1000000000;
		++pt-&gt;tv_sec;
	}
	return RS_RET_OK; /* so far, this is static... */
}

long long
currentTimeMills(void)
{
	struct timespec tm;
#	if _POSIX_TIMERS &lt;= 0
	struct timeval tv;
#	endif

#	if _POSIX_TIMERS &gt; 0
	clock_gettime(CLOCK_REALTIME, &amp;tm);
#	else
	gettimeofday(&amp;tv, NULL);
	tm.tv_sec = tv.tv_sec;
	tm.tv_nsec = tv.tv_usec * 1000;
#	endif

	return ((long long) tm.tv_sec) * 1000 + (tm.tv_nsec / 1000000);
}


/* This function is kind of the reverse of timeoutComp() - it takes an absolute
 * timeout value and computes how far this is in the future. If the value is already
 * in the past, 0 is returned. The return value is in ms.
 * rgerhards, 2008-01-25
 */
long
timeoutVal(struct timespec *pt)
{
	struct timespec t;
	long iTimeout;
#	if _POSIX_TIMERS &lt;= 0
	struct timeval tv;
#	endif

	assert(pt != NULL);
	/* compute timeout */
#	if _POSIX_TIMERS &gt; 0
	/* this is the &quot;regular&quot; code */
	clock_gettime(CLOCK_REALTIME, &amp;t);
#	else
	gettimeofday(&amp;tv, NULL);
	t.tv_sec = tv.tv_sec;
	t.tv_nsec = tv.tv_usec * 1000;
#	endif
	iTimeout = (pt-&gt;tv_nsec - t.tv_nsec) / 1000000;
	iTimeout += (pt-&gt;tv_sec - t.tv_sec) * 1000;

	if(iTimeout &lt; 0)
		iTimeout = 0;

	return iTimeout;
}


/* cancellation cleanup handler - frees provided mutex
 * rgerhards, 2008-01-14
 */
void
mutexCancelCleanup(void *arg)
{
	assert(arg != NULL);
	d_pthread_mutex_unlock((pthread_mutex_t*) arg);
}


/* rsSleep() - a fairly portable way to to sleep. It
 * will wake up when
 * a) the wake-time is over
 * rgerhards, 2008-01-28
 */
void
srSleep(int iSeconds, int iuSeconds)
{
	struct timeval tvSelectTimeout;

	tvSelectTimeout.tv_sec = iSeconds;
	tvSelectTimeout.tv_usec = iuSeconds; /* micro seconds */
	select(0, NULL, NULL, NULL, &amp;tvSelectTimeout);
}


/* From varmojfekoj's mail on why he provided rs_strerror_r():
 * There are two problems with strerror_r():
 * I see you've rewritten some of the code which calls it to use only
 * the supplied buffer; unfortunately the GNU implementation sometimes
 * doesn't use the buffer at all and returns a pointer to some
 * immutable string instead, as noted in the man page.
 *
 * The other problem is that on some systems strerror_r() has a return
 * type of int.
 *
 * So I've written a wrapper function rs_strerror_r(), which should
 * take care of all this and be used instead.
 *
 * Added 2008-01-30
 */
char *rs_strerror_r(int errnum, char *buf, size_t buflen) {
#ifndef HAVE_STRERROR_R
	char *pszErr;
	pszErr = strerror(errnum);
	snprintf(buf, buflen, &quot;%s&quot;, pszErr);
#else
#	ifdef STRERROR_R_CHAR_P
		char *p = strerror_r(errnum, buf, buflen);
		if (p != buf) {
			strncpy(buf, p, buflen);
			buf[buflen - 1] = '\0';
		}
#	else
		strerror_r(errnum, buf, buflen);
#	endif
#endif /* #ifdef __hpux */
	return buf;
}


/*  Decode a symbolic name to a numeric value */
int decodeSyslogName(uchar *name, syslogName_t *codetab)
{
	register syslogName_t *c;
	register uchar *p;
	uchar buf[80];

	assert(name != NULL);
	assert(codetab != NULL);

	DBGPRINTF(&quot;symbolic name: %s&quot;, name);
	if(isdigit((int) *name)) {
		DBGPRINTF(&quot;\n&quot;);
		return (atoi((char*) name));
	}
	strncpy((char*) buf, (char*) name, 79);
	for(p = buf; *p; p++) {
		if (isupper((int) *p))
			*p = tolower((int) *p);
	}
	for(c = codetab; c-&gt;c_name; c++) {
		if(!strcmp((char*) buf, (char*) c-&gt;c_name)) {
			DBGPRINTF(&quot; ==&gt; %d\n&quot;, c-&gt;c_val);
			return (c-&gt;c_val);
		}
	}
	DBGPRINTF(&quot;\n&quot;);
	return (-1);
}


/**
 * getSubString
 *
 * Copy a string byte by byte until the occurrence
 * of a given separator.
 *
 * \param ppSrc		Pointer to a pointer of the source array of characters. If a
			separator detected the Pointer points to the next char after the
			separator. Except if the end of the string is dedected ('\n').
			Then it points to the terminator char.
 * \param pDst		Pointer to the destination array of characters. Here the substing
			will be stored.
 * \param DstSize	Maximum numbers of characters to store.
 * \param cSep		Separator char.
 * \ret int		Returns 0 if no error occurred.
 *
 * rgerhards, 2008-02-12: some notes are due... I will once again fix this function, this time
 * so that it treats ' ' as a request for whitespace. But in general, the function and its callers
 * should be changed over time, this is not really very good code...
 */
int getSubString(uchar **ppSrc,  char *pDst, size_t DstSize, char cSep)
{
	uchar *pSrc = *ppSrc;
	int iErr = 0; /* 0 = no error, &gt;0 = error */
	while((cSep == ' ' ? !isspace(*pSrc) : *pSrc != cSep) &amp;&amp; *pSrc != '\n' &amp;&amp; *pSrc != '\0' &amp;&amp; DstSize&gt;1) {
		*pDst++ = *(pSrc)++;
		DstSize--;
	}
	/* check if the Dst buffer was to small */
	if ((cSep == ' ' ? !isspace(*pSrc) : *pSrc != cSep) &amp;&amp; *pSrc != '\n' &amp;&amp; *pSrc != '\0') {
		dbgprintf(&quot;in getSubString, error Src buffer &gt; Dst buffer\n&quot;);
		iErr = 1;
	}
	if (*pSrc == '\0' || *pSrc == '\n')
		/* this line was missing, causing ppSrc to be invalid when it
		 * was returned in case of end-of-string. rgerhards 2005-07-29
		 */
		*ppSrc = pSrc;
	else
		*ppSrc = pSrc+1;
	*pDst = '\0';
	return iErr;
}


/* get the size of a file or return appropriate error code. If an error is returned,
 * *pSize content is undefined.
 * rgerhards, 2009-06-12
 */
rsRetVal
getFileSize(uchar *pszName, off_t *pSize)
{
	int ret;
	struct stat statBuf;
	DEFiRet;

	ret = stat((char*) pszName, &amp;statBuf);
	if(ret == -1) {
		switch(errno) {
			case EACCES: ABORT_FINALIZE(RS_RET_NO_FILE_ACCESS);
			case ENOTDIR:
			case ENOENT:  ABORT_FINALIZE(RS_RET_FILE_NOT_FOUND);
			default:      ABORT_FINALIZE(RS_RET_FILE_NO_STAT);
		}
	}

	*pSize = statBuf.st_size;

finalize_it:
	RETiRet;
}

/* Returns 1 if the given string contains a non-escaped glob(3)
 * wildcard character and 0 otherwise (or if the string is empty).
 */
int
containsGlobWildcard(char *str)
{
	char *p;
	if(!str) {
		return 0;
	}
	/* From Linux Programmer's Guide:
	 * &quot;A string is a wildcard pattern if it contains one of the characters '?', '*', '{' or '['&quot;
	 * &quot;One can remove the special meaning of '?', '*', '{' and '[' by preceding them by a backslash&quot;
	 */
	for(p = str; *p != '\0'; p++) {
		if((*p == '?' || *p == '*' || *p == '[' || *p == '{') &amp;&amp;
				(p == str || *(p-1) != '\\')) {
			return 1;
		}
	}
	return 0;
}

static void seedRandomInsecureNumber(void)
{
	struct timespec t;
	timeoutComp(&amp;t, 0);
	long long x = t.tv_sec * 3 + t.tv_nsec * 2;
	srandom((unsigned int) x);
}

static long int randomInsecureNumber(void)
{
	return random();
}

#ifdef OS_LINUX
static int fdURandom = -1;
void seedRandomNumber(void)
{
	if(fdURandom &gt;= 0) {
		/* Already opened. */
		return;
	}
	fdURandom = open(&quot;/dev/urandom&quot;, O_RDONLY);
	if(fdURandom == -1) {
		LogError(errno, RS_RET_IO_ERROR, &quot;failed to seed random number generation,&quot;
			&quot; will use fallback (open urandom failed)&quot;);
		seedRandomInsecureNumber();
	}
}

void seedRandomNumberForChild(void)
{
	/* The file descriptor inherited from our parent will have been closed after
	 * the fork. Discard this and call seedRandomNumber() to open /dev/urandom
	 * again.
	 */
	fdURandom = -1;
	seedRandomNumber();
}

long int randomNumber(void)
{
	long int ret;
	if(fdURandom &gt;= 0) {
		if(read(fdURandom, &amp;ret, sizeof(long int)) == -1) {
			LogError(errno, RS_RET_IO_ERROR, &quot;failed to generate random number, will&quot;
				&quot; use fallback (read urandom failed)&quot;);
			ret = randomInsecureNumber();
		}
	} else {
		ret = randomInsecureNumber();
	}
	return ret;
}
#else
void seedRandomNumber(void)
{
	seedRandomInsecureNumber();
}

void seedRandomNumberForChild(void)
{
	seedRandomNumber();
}

long int randomNumber(void)
{
	return randomInsecureNumber();
}
#endif


/* process &quot;binary&quot; parameters where this is needed to execute
 * programs (namely mmexternal and omprog).
 * Most importantly, split them into argv[] and get the binary name
 */
rsRetVal ATTR_NONNULL()
split_binary_parameters(uchar **const szBinary, char ***const __restrict__ aParams,
	int *const iParams, es_str_t *const param_binary)
{
	es_size_t iCnt;
	es_size_t iStr;
	int iPrm;
	es_str_t *estrParams = NULL;
	es_str_t *estrBinary = param_binary;
	es_str_t *estrTmp = NULL;
	uchar *c;
	int bInQuotes;
	DEFiRet;
	assert(iParams != NULL);
	assert(param_binary != NULL);

	/* Search for end of binary name */
	c = es_getBufAddr(param_binary);
	iCnt = 0;
	while(iCnt &lt; es_strlen(param_binary) ) {
		if (c[iCnt] == ' ') {
			/* Split binary name from parameters */
			estrBinary = es_newStrFromSubStr( param_binary, 0, iCnt);
			estrParams = es_newStrFromSubStr( param_binary, iCnt+1,
					es_strlen(param_binary));
			break;
		}
		iCnt++;
	}
	*szBinary = (uchar*)es_str2cstr(estrBinary, NULL);
	DBGPRINTF(&quot;szBinary = '%s'\n&quot;, *szBinary);

	*iParams = 1; /* we always have argv[0] */
	/* count size of argv[] */
	if (estrParams != NULL) {
		 (*iParams)++; /* last parameter is not counted in loop below! */
		if(Debug) {
			char *params = es_str2cstr(estrParams, NULL);
			dbgprintf(&quot;szParams = '%s'\n&quot;, params);
			free(params);
		}
		c = es_getBufAddr(estrParams);
		for(iCnt = 0 ; iCnt &lt; es_strlen(estrParams) ; ++iCnt) {
			if (c[iCnt] == ' ' &amp;&amp; c[iCnt-1] != '\\')
				 (*iParams)++;
		}
	}
	DBGPRINTF(&quot;iParams %d (+1 for NULL terminator)\n&quot;, *iParams);

	/* create argv[] */
	CHKmalloc(*aParams = malloc((*iParams + 1) * sizeof(char*)));
	iPrm = 0;
	bInQuotes = FALSE;
	/* Set first parameter to binary */
	(*aParams)[iPrm] = strdup((char*)*szBinary);
	iPrm++;
	if (estrParams != NULL) {
		iCnt = iStr = 0;
		c = es_getBufAddr(estrParams); /* Reset to beginning */
		while(iCnt &lt; es_strlen(estrParams) ) {
			if ( c[iCnt] == ' ' &amp;&amp; !bInQuotes ) {
				estrTmp = es_newStrFromSubStr( estrParams, iStr, iCnt-iStr);
			} else if ( iCnt+1 &gt;= es_strlen(estrParams) ) {
				estrTmp = es_newStrFromSubStr( estrParams, iStr, iCnt-iStr+1);
			} else if (c[iCnt] == '&quot;') {
				bInQuotes = !bInQuotes;
			}

			if ( estrTmp != NULL ) {
				(*aParams)[iPrm] = es_str2cstr(estrTmp, NULL);
				iStr = iCnt+1; /* Set new start */
				DBGPRINTF(&quot;Param (%d): '%s'\n&quot;, iPrm, (*aParams)[iPrm]);
				es_deleteStr( estrTmp );
				estrTmp = NULL;
				iPrm++;
			}
			iCnt++;
		}
	}
	(*aParams)[iPrm] = NULL; /* NULL per argv[] convention */

finalize_it:
	if(estrBinary != param_binary) {
		es_deleteStr(estrBinary);
	}
	if(estrParams != NULL) {
		es_deleteStr(estrParams);
	}
	RETiRet;
}
</PRE>
</div>
  </div>
</body>
</html>
