<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for inf-async-operation.c &amp; inf-io.c</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for inf-async-operation.c &amp; inf-io.c
      </h3>
<h1 align="center">
        12.7%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>inf-async-operation.c (12.244898%)<th>inf-io.c (13.333333%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(107-168)<td><a href="#" name="0">(84-121)</a><td align="center"><font color="#ff0000">12</font>
</td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>inf-async-operation.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 #include &lt;libinfinity/common/inf-async-operation.h&gt;
2 #include &lt;libinfinity/inf-i18n.h&gt;
3 struct _InfAsyncOperation {
4   InfIo* io;
5   InfIoDispatch* dispatch;
6   GThread* thread;
7   GMutex mutex;
8   InfAsyncOperationRunFunc run_func;
9   InfAsyncOperationDoneFunc done_func;
10   gpointer user_data;
11   gpointer run_data;
12   GDestroyNotify run_notify;
13 };
14 static void
15 inf_async_operation_dispatch(gpointer data)
16 {
17   InfAsyncOperation* op;
18   op = (InfAsyncOperation*)data;
19   g_mutex_lock(&amp;op-&gt;mutex);
20   op-&gt;dispatch = NULL;
21   g_mutex_unlock(&amp;op-&gt;mutex);
22   if(op-&gt;done_func != NULL)
23     op-&gt;done_func(op-&gt;run_data, op-&gt;user_data);
24   if(op-&gt;run_notify != NULL)
25     op-&gt;run_notify(op-&gt;run_data);
26   op-&gt;run_data = NULL;
27   op-&gt;run_notify = NULL;
28   op-&gt;thread = NULL;
29   g_mutex_clear(&amp;op-&gt;mutex);
30   inf_async_operation_free(op);
31 }
32 static gpointer
33 inf_async_operation_thread_start(gpointer data)
34 {
35   InfAsyncOperation* op;
36   op = (InfAsyncOperation*)data;
37   op-&gt;run_func(&amp;op-&gt;run_data, &amp;op-&gt;run_notify, op-&gt;user_data);
38   g_mutex_lock(&amp;op-&gt;mutex);
39   g_assert(op-&gt;dispatch == NULL);
40   if(op-&gt;io != NULL)
41   {
42     op-&gt;dispatch = inf_io_add_dispatch(
43       op-&gt;io,
44       inf_async_operation_dispatch,
45       op,
46       NULL
47     );
48     g_mutex_unlock(&amp;op-&gt;mutex);
49   }
50   else
51   {
52     if(op-&gt;run_notify != NULL)
53       op-&gt;run_notify(op-&gt;run_data);
54     g_mutex_unlock(&amp;op-&gt;mutex);
55     g_mutex_clear(&amp;op-&gt;mutex);
56     g_thread_unref(op-&gt;thread);
57     g_slice_free(InfAsyncOperation, op);
58 <a name="0"></a>  }
59   return NULL;
60 <font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>}
61 static void
62 inf_async_operation_io_unref_func(gpointer user_data,
63                                   GObject* where_the_object_was)
64 {
65   g_error(
66     "%s",
67     _("InfIo object was deleted without InfAsyncOperation being freed! "
68       "This is a programming error that leaves the program in an "
69       "inconsistent state. Therefore, the program is aborted. Please "
70       "fix your code.")
71   );
72   g_assert_not_reached();
73 }
74 InfAsyncOperation*
75 inf_async_operation_new(InfIo* io,
76                         InfAsyncOperationRunFunc run_func,
77                         InfAsyncOperationDoneFunc done_func,
78                         gpointer user_data)
79 {
80   InfAsyncOperation* op;
81   g_return_val_if_fail(INF_IS_IO(io), NULL);
82   g_return_val_if_fail(run_func != NULL, NULL);
83   g_return_val_if_fail(done_func != NULL, NULL);
84   op = g_slice_new(InfAsyncOperation);</b></font>
85   op-&gt;io = io;
86   op-&gt;dispatch = NULL;
87   op-&gt;thread = NULL;
88   op-&gt;run_func = run_func;
89   op-&gt;done_func = done_func;
90   op-&gt;user_data = user_data;
91   op-&gt;run_data = NULL;
92   op-&gt;run_notify = NULL;
93   g_object_weak_ref(
94     G_OBJECT(io),
95     inf_async_operation_io_unref_func,
96     op
97   );
98   return op;
99 }
100 gboolean
101 inf_async_operation_start(InfAsyncOperation* op,
102                           GError** error)
103 {
104   g_return_val_if_fail(op != NULL, FALSE);
105   g_return_val_if_fail(op-&gt;thread == NULL, FALSE);
106   g_mutex_init(&amp;op-&gt;mutex);
107   g_mutex_lock(&amp;op-&gt;mutex);
108   op-&gt;thread = g_thread_try_new(
109     "InfAsyncOperation",
110     inf_async_operation_thread_start,
111     op,
112     error
113   );
114   if(op-&gt;thread == NULL)
115   {
116     g_mutex_unlock(&amp;op-&gt;mutex);
117     g_mutex_clear(&amp;op-&gt;mutex);
118     inf_async_operation_free(op);
119     return FALSE;
120   }
121   g_mutex_unlock(&amp;op-&gt;mutex);
122   return TRUE;
123 }
124 void
125 inf_async_operation_free(InfAsyncOperation* op)
126 {
127   g_return_if_fail(op != NULL);
128   if(op-&gt;thread == NULL)
129   {
130     g_assert(op-&gt;io != NULL);
131     g_object_weak_unref(
132       G_OBJECT(op-&gt;io),
133       inf_async_operation_io_unref_func,
134       op
135     );
136     g_slice_free(InfAsyncOperation, op);
137   }
138   else
139   {
140     g_mutex_lock(&amp;op-&gt;mutex);
141     g_assert(op-&gt;io != NULL);
142     if(op-&gt;dispatch == NULL)
143     {
144       g_object_weak_unref(
145         G_OBJECT(op-&gt;io),
146         inf_async_operation_io_unref_func,
147         op
148       );
149       op-&gt;io = NULL;
150       g_mutex_unlock(&amp;op-&gt;mutex);
151     }
152     else
153     {
154       inf_io_remove_dispatch(op-&gt;io, op-&gt;dispatch);
155       if(op-&gt;run_notify != NULL) op-&gt;run_notify(op-&gt;run_data);
156       g_mutex_unlock(&amp;op-&gt;mutex);
157       g_mutex_clear(&amp;op-&gt;mutex);
158       g_thread_unref(op-&gt;thread);
159       g_slice_free(InfAsyncOperation, op);
160     }
161   }
162 }
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>inf-io.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 #include &lt;libinfinity/common/inf-io.h&gt;
2 #include &lt;libinfinity/inf-define-enum.h&gt;
3 typedef struct _InfIoWatchUnix InfIoWatchUnix;
4 struct _InfIoWatchUnix {
5   InfNativeSocket socket;
6   gpointer user_data;
7   GDestroyNotify notify;
8 };
9 static const GFlagsValue inf_io_event_values[] = {
10   {
11     INF_IO_INCOMING,
12     "INF_IO_INCOMING",
13     "incoming"
14   }, {
15     INF_IO_OUTGOING,
16     "INF_IO_OUTGOING",
17     "outgoing"
18   }, {
19     INF_IO_ERROR,
20     "INF_IO_ERROR",
21     "error"
22   }, {
23     0,
24     NULL,
25     NULL
26   }
27 };
28 INF_DEFINE_FLAGS_TYPE(InfIoEvent, inf_io_event, inf_io_event_values)
29 G_DEFINE_INTERFACE(InfIo, inf_io, G_TYPE_OBJECT)
30 static void
31 inf_io_watch_unix_free(gpointer data)
32 {
33   InfIoWatchUnix* unixwatch;
34   unixwatch = (InfIoWatchUnix*)data;
35 <a name="0"></a>
36   unixwatch-&gt;notify(unixwatch-&gt;user_data);
37   g_slice_free(InfIoWatchUnix, unixwatch);
38 <font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>}
39 static void
40 inf_io_default_init(InfIoInterface* iface)
41 {
42 }
43 InfIoWatch*
44 inf_io_add_watch(InfIo* io,
45                  InfNativeSocket* socket,
46                  InfIoEvent events,
47                  InfIoWatchFunc func,
48                  gpointer user_data,
49                  GDestroyNotify notify)
50 {
51   InfIoInterface* iface;
52   g_return_val_if_fail(INF_IS_IO(io), NULL);
53   g_return_val_if_fail(socket != NULL, NULL);
54   g_return_val_if_fail(func != NULL, NULL);
55   iface = INF_IO_GET_IFACE(io);</b></font>
56   g_return_val_if_fail(iface-&gt;add_watch != NULL, NULL);
57   return iface-&gt;add_watch(io, socket, events, func, user_data, notify);
58 }
59 #ifdef G_OS_UNIX
60 InfIoWatch*
61 inf_io_add_watch_from_fd(InfIo* io,
62                          int fd,
63                          InfIoEvent events,
64                          InfIoWatchFunc func,
65                          gpointer user_data,
66                          GDestroyNotify notify)
67 {
68   InfIoWatchUnix* watch;
69   watch = g_slice_new(InfIoWatchUnix);
70   watch-&gt;socket = fd;
71   watch-&gt;user_data = user_data;
72   watch-&gt;notify = notify;
73   return inf_io_add_watch(
74     io,
75     &amp;watch-&gt;socket,
76     events,
77     func,
78     watch,
79     inf_io_watch_unix_free
80   );
81 }
82 #endif
83 void
84 inf_io_update_watch(InfIo* io,
85                     InfIoWatch* watch,
86                     InfIoEvent events)
87 {
88   InfIoInterface* iface;
89   g_return_if_fail(INF_IS_IO(io));
90   g_return_if_fail(watch != NULL);
91   iface = INF_IO_GET_IFACE(io);
92   g_return_if_fail(iface-&gt;update_watch != NULL);
93   iface-&gt;update_watch(io, watch, events);
94 }
95 void
96 inf_io_remove_watch(InfIo* io,
97                     InfIoWatch* watch)
98 {
99   InfIoInterface* iface;
100   g_return_if_fail(INF_IS_IO(io));
101   g_return_if_fail(watch != NULL);
102   iface = INF_IO_GET_IFACE(io);
103   g_return_if_fail(iface-&gt;remove_watch != NULL);
104   iface-&gt;remove_watch(io, watch);
105 }
106 InfIoTimeout*
107 inf_io_add_timeout(InfIo* io,
108                    guint msecs,
109                    InfIoTimeoutFunc func,
110                    gpointer user_data,
111                    GDestroyNotify notify)
112 {
113   InfIoInterface* iface;
114   g_return_val_if_fail(INF_IS_IO(io), NULL);
115   g_return_val_if_fail(func != NULL, NULL);
116   iface = INF_IO_GET_IFACE(io);
117   g_return_val_if_fail(iface-&gt;add_timeout != NULL, NULL);
118   return iface-&gt;add_timeout(io, msecs, func, user_data, notify);
119 }
120 void
121 inf_io_remove_timeout(InfIo* io,
122                       InfIoTimeout* timeout)
123 {
124   InfIoInterface* iface;
125   g_return_if_fail(INF_IS_IO(io));
126   g_return_if_fail(timeout != NULL);
127   iface = INF_IO_GET_IFACE(io);
128   g_return_if_fail(iface-&gt;remove_timeout != NULL);
129   iface-&gt;remove_timeout(io, timeout);
130 }
131 InfIoDispatch*
132 inf_io_add_dispatch(InfIo* io,
133                     InfIoDispatchFunc func,
134                     gpointer user_data,
135                     GDestroyNotify notify)
136 {
137   InfIoInterface* iface;
138   g_return_val_if_fail(INF_IS_IO(io), NULL);
139   g_return_val_if_fail(func != NULL, NULL);
140   iface = INF_IO_GET_IFACE(io);
141   g_return_val_if_fail(iface-&gt;add_dispatch != NULL, NULL);
142   return iface-&gt;add_dispatch(io, func, user_data, notify);
143 }
144 void
145 inf_io_remove_dispatch(InfIo* io,
146                        InfIoDispatch* dispatch)
147 {
148   InfIoInterface* iface;
149   g_return_if_fail(INF_IS_IO(io));
150   g_return_if_fail(dispatch != NULL);
151   iface = INF_IO_GET_IFACE(io);
152   g_return_if_fail(iface-&gt;remove_dispatch != NULL);
153   iface-&gt;remove_dispatch(io, dispatch);
154 }
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
