<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for mmdarwin.c &amp; glbl.c</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for mmdarwin.c &amp; glbl.c
      </h3>
<h1 align="center">
        5.7%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>mmdarwin.c (9.320695%)<th>glbl.c (4.1520057%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(121-140)<td><a href="#" name="0">(172-186)</a><td align="center"><font color="#ff0000">24</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(697-717)<td><a href="#" name="1">(1245-1253)</a><td align="center"><font color="#e90000">22</font>
<tr onclick='openModal("#980517")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#980517"><font color="#980517">-</font><td><a href="#" name="2">(596-609)<td><a href="#" name="2">(1000-1014)</a><td align="center"><font color="#8a0000">13</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>mmdarwin.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
#include "config.h"
#include "rsyslog.h"
#include &lt;stdio.h&gt;
#include &lt;stdarg.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;assert.h&gt;
#include &lt;signal.h&gt;
#include &lt;errno.h&gt;
#include &lt;unistd.h&gt;
#include &lt;stdint.h&gt;
#include &lt;pthread.h&gt;
#include "conf.h"
#include "syslogd-types.h"
#include "srUtils.h"
#include "template.h"
#include "module-template.h"
#include "errmsg.h"
#include "parserif.h"
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;sys/un.h&gt;
#include &lt;sys/socket.h&gt;
#include &lt;uuid/uuid.h&gt;
#include &lt;json.h&gt;
#include "protocol.h" 
#define JSON_DEFAULT_CONTAINER "!mmdarwin"
#define JSON_DARWIN_ID "darwin_id"
#define INVLD_SOCK -1
#define INITIAL_BUFFER_SIZE 32
#define BUFFER_DEFAULT_MAX_SIZE 65536
MODULE_TYPE_OUTPUT
MODULE_TYPE_NOKEEP
MODULE_CNFNAME("mmdarwin")
DEFobjCurrIf(glbl)
DEF_OMOD_STATIC_DATA
typedef struct dyn_buffer_t
{
	char *buffer;
	size_t bufferAllocSize;
	size_t bufferMsgSize;
	size_t bufferMaxSize;
} dyn_buffer;
typedef struct _instanceData
{
	enum darwin_filter_response_type response;		struct
	{
		int nmemb;
		char **name;
		char **varname;
	} fieldList; 	unsigned int socketMaxUse;
	sbool sendPartial;
} instanceData;
typedef struct wrkrInstanceData
{
	instanceData *pData;
	int sock;				 	struct sockaddr_un addr; 	uint8_t pktSentSocket;
	dyn_buffer darwinBody; 	dyn_buffer fieldBuffer;
} wrkrInstanceData_t;
struct modConfData_s
{
	rsconf_t *pConf;
	const char *container;
};
static modConfData_t *loadModConf = NULL;
static modConfData_t *runModConf = NULL;
static struct cnfparamdescr modpdescr[] = {
	{"container", eCmdHdlrGetWord, 0},
};
static struct cnfparamblk modpblk =
	{CNFPARAMBLK_VERSION,
	 sizeof(modpdescr) / sizeof(struct cnfparamdescr),
	 modpdescr};
static struct cnfparamdescr actpdescr[] = {
<font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>	{"key", eCmdHdlrGetWord, CNFPARAM_REQUIRED},
	{"socketpath", eCmdHdlrGetWord, CNFPARAM_REQUIRED},
	{"fields", eCmdHdlrArray, CNFPARAM_REQUIRED},
	{"filtercode", eCmdHdlrGetWord, 0},				{"response", eCmdHdlrGetWord, 0},				{"send_partial", eCmdHdlrBinary, 0},			{"socket_max_use", eCmdHdlrNonNegInt, 0}, };
static struct cnfparamblk actpblk = {
	CNFPARAMBLK_VERSION,
	sizeof(actpdescr) / sizeof(struct cnfparamdescr),
	actpdescr};
#define min(a, b) \
	({ __typeof__ (a) _a = (a); \
	__typeof__ (b) _b = (b); \
	_a &lt; _b ? _a : _b; })
static rsRetVal openSocket(wrkrInstanceData_t *pWrkrData);</b></font>
static rsRetVal closeSocket(wrkrInstanceData_t *pWrkrData);
static rsRetVal doTryResume(wrkrInstanceData_t *pWrkrData);
static rsRetVal sendMsg(wrkrInstanceData_t *pWrkrData, void *msg, size_t len);
static rsRetVal receiveMsg(wrkrInstanceData_t *pWrkrData, void *response, size_t len);
const char* get_uuid_object(smsg_t *const pMsg);
int get_field(smsg_t *const pMsg, const char *pFieldName, char **ppRetString);
int expand_buffer(dyn_buffer *pBody, size_t new_size);
int add_field_to_body(dyn_buffer *pBody, const char *field, size_t size);
int start_new_line(dyn_buffer *pBody);
int end_body(dyn_buffer *pBody);
static rsRetVal openSocket(wrkrInstanceData_t *pWrkrData)
{
	DEFiRet;
	assert(pWrkrData-&gt;sock == INVLD_SOCK);
	if ((pWrkrData-&gt;sock = socket(AF_UNIX, SOCK_STREAM, 0)) == -1)
	{
		char errStr[1024];
		int eno = errno;
		DBGPRINTF("mmdarwin::openSocket:: error %d creating AF_UNIX/SOCK_STREAM: %s.\n",
				  eno, rs_strerror_r(eno, errStr, sizeof(errStr)));
		pWrkrData-&gt;sock = INVLD_SOCK;
		ABORT_FINALIZE(RS_RET_NO_SOCKET);
	}
	memset(&amp;pWrkrData-&gt;addr, 0, sizeof(struct sockaddr_un));
	pWrkrData-&gt;addr.sun_family = AF_UNIX;
	strncpy(pWrkrData-&gt;addr.sun_path, (char *)pWrkrData-&gt;pData-&gt;pSockName, sizeof(pWrkrData-&gt;addr.sun_path) - 1);
	DBGPRINTF("mmdarwin::openSocket:: connecting to Darwin...\n");
	if (connect(pWrkrData-&gt;sock, (struct sockaddr *)&amp;pWrkrData-&gt;addr, sizeof(struct sockaddr_un)) == -1)
	{
		LogError(errno, RS_RET_NO_SOCKET, "mmdarwin::openSocket:: error connecting to Darwin "
										  "via socket '%s'",
				 pWrkrData-&gt;pData-&gt;pSockName);
		pWrkrData-&gt;sock = INVLD_SOCK;
		ABORT_FINALIZE(RS_RET_NO_SOCKET);
	}
	DBGPRINTF("mmdarwin::openSocket:: connected !\n");
finalize_it:
	if (iRet != RS_RET_OK)
	{
		closeSocket(pWrkrData);
	}
	RETiRet;
}
static rsRetVal closeSocket(wrkrInstanceData_t *pWrkrData)
{
	DEFiRet;
	if (pWrkrData-&gt;sock != INVLD_SOCK)
	{
		if (close(pWrkrData-&gt;sock) != 0)
		{
			char errStr[1024];
			int eno = errno;
			DBGPRINTF("mmdarwin::closeSocket:: error %d closing the socket: %s.\n",
					  eno, rs_strerror_r(eno, errStr, sizeof(errStr)));
		}
		pWrkrData-&gt;sock = INVLD_SOCK;
	}
	RETiRet;
}
static rsRetVal doTryResume(wrkrInstanceData_t *pWrkrData)
{
	DEFiRet;
	DBGPRINTF("mmdarwin::doTryResume:: trying to resume\n");
	closeSocket(pWrkrData);
	iRet = openSocket(pWrkrData);
	if (iRet != RS_RET_OK)
	{
		iRet = RS_RET_SUSPENDED;
	}
	RETiRet;
}
static rsRetVal sendMsg(wrkrInstanceData_t *pWrkrData, void *msg, size_t len)
{
	DEFiRet;
	DBGPRINTF("mmdarwin::sendMsg:: sending message to Darwin...\n");
	if (pWrkrData-&gt;sock == INVLD_SOCK)
	{
		CHKiRet(doTryResume(pWrkrData));
	}
	if (pWrkrData-&gt;sock != INVLD_SOCK)
	{
		if (send(pWrkrData-&gt;sock, msg, len, 0) == -1)
		{
			char errStr[1024];
			DBGPRINTF("mmdarwin::sendData:: error while sending data: error[%d] -&gt; %s\n",
					  errno, rs_strerror_r(errno, errStr, sizeof(errStr)));
			iRet = RS_RET_SUSPENDED;
		}
	}
finalize_it:
	RETiRet;
}
static rsRetVal receiveMsg(wrkrInstanceData_t *pWrkrData, void *response, size_t len)
{
	DEFiRet;
	DBGPRINTF("mmdarwin::receiveMsg:: receiving message from Darwin...\n");
	if (pWrkrData-&gt;sock == INVLD_SOCK)
	{
		CHKiRet(doTryResume(pWrkrData));
	}
	if (pWrkrData-&gt;sock != INVLD_SOCK)
	{
		if (recv(pWrkrData-&gt;sock, response, len, MSG_WAITALL) &lt;= 0)
		{
			char errStr[1024];
			DBGPRINTF("mmdarwin::receiveMsg:: error while receiving data: error[%d] -&gt; %s\n",
					  errno, rs_strerror_r(errno, errStr, sizeof(errStr)));
			iRet = RS_RET_NONE;
		}
	}
finalize_it:
	RETiRet;
}
int get_field(smsg_t *const pMsg, const char *pFieldName, char **ppRetString)
{
	DBGPRINTF("mmdarwin::get_field:: getting key '%s' in msg\n", pFieldName);
	struct json_object *pJson = NULL;
	char *pFieldString = NULL;
	int retVal = 0;
	msgPropDescr_t propDesc;
	msgPropDescrFill(&amp;propDesc, (uchar *)pFieldName, strlen(pFieldName));
	msgGetJSONPropJSONorString(pMsg, &amp;propDesc, &amp;pJson, (uchar **)&amp;pFieldString);
	if (pFieldString)
	{
		*ppRetString = pFieldString;
		DBGPRINTF("mmdarwin::get_field:: got string\n");
		retVal = 1;
	}
	else if (pJson)
	{
		pFieldString = (char *)json_object_get_string(pJson);
		if (pFieldString)
		{
			*ppRetString = strdup(pFieldString);
			retVal = 1;
			DBGPRINTF("mmdarwin::get_field:: got string from json\n");
			json_object_put(pJson);
		}
	}
	msgPropDescrDestruct(&amp;propDesc);
	return retVal;
}
int expand_buffer(dyn_buffer *pBody, size_t new_size)
{
	if (new_size &gt; pBody-&gt;bufferMaxSize)
		return -1;
	while (pBody-&gt;bufferAllocSize &lt; new_size)
		pBody-&gt;bufferAllocSize += INITIAL_BUFFER_SIZE;
	DBGPRINTF("mmdarwin::expand_buffer:: expanding buffer to %zu\n", pBody-&gt;bufferAllocSize);
	char *tmp = realloc(pBody-&gt;buffer, pBody-&gt;bufferAllocSize * sizeof(char));
	if (!tmp)
	{
		DBGPRINTF("mmdarwin::expand_buffer:: could not resize buffer\n");
		return -1;
	}
	pBody-&gt;buffer = tmp;
	return 0;
}
int add_field_to_body(dyn_buffer *pBody, const char *field, size_t size)
{
	int beginning = (pBody-&gt;bufferMsgSize == 0) ? 2 : 0;
	size_t requiredBodySize = pBody-&gt;bufferMsgSize + size + 4 + beginning;
	if (requiredBodySize &gt; pBody-&gt;bufferAllocSize)
	{
		if (expand_buffer(pBody, requiredBodySize) != 0)
		{
			return -1;
		}
	}
	if (!pBody-&gt;bufferMsgSize)
	{
		pBody-&gt;buffer[0] = '[';
		pBody-&gt;buffer[1] = '[';
		pBody-&gt;bufferMsgSize += 2;
	}
	pBody-&gt;buffer[pBody-&gt;bufferMsgSize++] = '\"';
	memcpy((void *)&amp;pBody-&gt;buffer[pBody-&gt;bufferMsgSize], (const void *)field, size);
	pBody-&gt;bufferMsgSize += size;
	pBody-&gt;buffer[pBody-&gt;bufferMsgSize++] = '\"';
	pBody-&gt;buffer[pBody-&gt;bufferMsgSize++] = ',';
	return 0;
}
int start_new_line(dyn_buffer *pBody)
{
	if (!pBody-&gt;bufferMsgSize)
	{
		return -1;
	}
	DBGPRINTF("mmdarwin::start_new_line:: starting new line entry in body\n");
	if (pBody-&gt;bufferAllocSize &lt; pBody-&gt;bufferMsgSize + 2)
	{
		if (expand_buffer(pBody, pBody-&gt;bufferAllocSize + 2) != 0)
		{
			return -1;
		}
	}
	pBody-&gt;buffer[pBody-&gt;bufferMsgSize - 1] = ']';
	pBody-&gt;buffer[pBody-&gt;bufferMsgSize++] = ',';
	pBody-&gt;buffer[pBody-&gt;bufferMsgSize++] = '[';
	return 0;
}
int end_body(dyn_buffer *pBody)
{
	if (!pBody-&gt;bufferMsgSize)
	{
		return -1;
	}
	DBGPRINTF("mmdarwin::end_body:: finishing body structure\n");
	if (pBody-&gt;bufferAllocSize &lt; pBody-&gt;bufferMsgSize + 2)
	{
		if (expand_buffer(pBody, pBody-&gt;bufferAllocSize + 2) != 0)
		{
			return -1;
		}
	}
	pBody-&gt;buffer[pBody-&gt;bufferMsgSize - 1] = ']';
	pBody-&gt;buffer[pBody-&gt;bufferMsgSize++] = ']';
	pBody-&gt;buffer[pBody-&gt;bufferMsgSize++] = '\0';
	return 0;
}
const char* get_uuid_object(smsg_t *const pMsg) {
	struct json_object *mmdarwin_object = NULL;
	const char *result = NULL, *key = NULL;
	msgPropDescr_t propDesc;
	msgPropDescrFill(&amp;propDesc, (uchar *)runModConf-&gt;container, strlen(runModConf-&gt;container));
	msgGetJSONPropJSON(pMsg, &amp;propDesc, &amp;mmdarwin_object);
	if(mmdarwin_object) {
		struct json_object_iterator it = json_object_iter_begin(mmdarwin_object);
		struct json_object_iterator itEnd = json_object_iter_end(mmdarwin_object);
		while(!json_object_iter_equal(&amp;it, &amp;itEnd)) {
			key = json_object_iter_peek_name(&amp;it);
			if(!strcmp(key, JSON_DARWIN_ID)) {
				result = strdup(json_object_get_string(json_object_iter_peek_value(&amp;it)));
				break;
			}
			json_object_iter_next(&amp;it);
		}
		json_object_put(mmdarwin_object);
	}
	msgPropDescrDestruct(&amp;propDesc);
	return result;
}
BEGINbeginCnfLoad
CODESTARTbeginCnfLoad
	loadModConf = pModConf;
pModConf-&gt;pConf = pConf;
ENDbeginCnfLoad
BEGINendCnfLoad
CODESTARTendCnfLoad
ENDendCnfLoad
BEGINcheckCnf
CODESTARTcheckCnf
ENDcheckCnf
BEGINactivateCnf
CODESTARTactivateCnf
	runModConf = pModConf;
ENDactivateCnf
BEGINfreeCnf
CODESTARTfreeCnf
	free((void *)pModConf-&gt;container);
ENDfreeCnf
BEGINdbgPrintInstInfo
CODESTARTdbgPrintInstInfo
	DBGPRINTF("%s\n", pData-&gt;pSockName);
ENDdbgPrintInstInfo
BEGINcreateInstance
CODESTARTcreateInstance
ENDcreateInstance
BEGINcreateWrkrInstance
CODESTARTcreateWrkrInstance
	pWrkrData-&gt;pktSentSocket = 0;
	pWrkrData-&gt;darwinBody.bufferAllocSize = 0;
	pWrkrData-&gt;darwinBody.bufferMaxSize = BUFFER_DEFAULT_MAX_SIZE;
	pWrkrData-&gt;darwinBody.bufferMsgSize = 0;
	pWrkrData-&gt;sock = INVLD_SOCK;
ENDcreateWrkrInstance
BEGINisCompatibleWithFeature
CODESTARTisCompatibleWithFeature
ENDisCompatibleWithFeature
BEGINfreeInstance
CODESTARTfreeInstance
	if (pData-&gt;fieldList.name != NULL)
	{
		for (int i = 0; i &lt; pData-&gt;fieldList.nmemb; ++i)
		{
			free(pData-&gt;fieldList.name[i]);
			free(pData-&gt;fieldList.varname[i]);
		}
		free(pData-&gt;fieldList.name);
		free(pData-&gt;fieldList.varname);
	}
	free(pData-&gt;pUUIDKey);
	free(pData-&gt;pCertitudeKey);
	free(pData-&gt;pSockName);
ENDfreeInstance
BEGINfreeWrkrInstance
CODESTARTfreeWrkrInstance
	closeSocket(pWrkrData);
	free(pWrkrData-&gt;darwinBody.buffer);
ENDfreeWrkrInstance
BEGINsetModCnf
struct cnfparamvals *pvals = NULL;
int i;
CODESTARTsetModCnf
	loadModConf-&gt;container = NULL;
	pvals = nvlstGetParams(lst, &amp;modpblk, NULL);
	if (pvals == NULL)
	{
<a name="2"></a>		LogError(0, RS_RET_MISSING_CNFPARAMS,
				"mmdarwin: error processing module config parameters missing [module(...)]");
		ABORT_FINALIZE(RS_RET_MISSING_CNFPARAMS);
<font color="#980517"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>	}
	if (Debug)
	{
		DBGPRINTF("mmdarwin::setModCnf:: module (global) param blk for mmdarwin:\n");
		cnfparamsPrint(&amp;modpblk, pvals);
	}
	for (i = 0; i &lt; modpblk.nParams; ++i)
	{
		if (!pvals[i].bUsed)
			continue;
		if (!strcmp(modpblk.descr[i].name, "container"))
		{
			loadModConf-&gt;container = es_str2cstr(pvals[i].val.d.estr, NULL);</b></font>
			if(loadModConf-&gt;container[0] != '!' &amp;&amp; loadModConf-&gt;container[0] != '.') {
				LogError(0, RS_RET_INVALID_PARAMS, "mmdarwin: container should either"
					" begin with '!' or '.'\n");
				ABORT_FINALIZE(RS_RET_INVALID_PARAMS);
			}
		}
		else
		{
			DBGPRINTF("mmdarwin::setModCnf:: program error, non-handled "
					"param '%s'\n",
					modpblk.descr[i].name);
		}
	}
	if (loadModConf-&gt;container == NULL)
	{
		CHKmalloc(loadModConf-&gt;container = strdup(JSON_DEFAULT_CONTAINER));
	}
finalize_it :
	if (pvals != NULL)
		cnfparamvalsDestruct(pvals, &amp;modpblk);
ENDsetModCnf
static inline void setInstParamDefaults(instanceData *pData)
{
	DBGPRINTF("mmdarwin::setInstParamDefaults::\n");
	pData-&gt;pUUIDKey = NULL;
	pData-&gt;pCertitudeKey = NULL;
	pData-&gt;pSockName = NULL;
	pData-&gt;fieldList.nmemb = 0;
	pData-&gt;filterCode = DARWIN_FILTER_CODE_NO;
	pData-&gt;response = DARWIN_RESPONSE_SEND_NO;
	pData-&gt;socketMaxUse = 0;
	pData-&gt;sendPartial = 0;
}
BEGINnewActInst
	struct cnfparamvals *pvals;
	int i;
CODESTARTnewActInst
	DBGPRINTF("mmdarwin::newActInst::\n");
	if ((pvals = nvlstGetParams(lst, &amp;actpblk, NULL)) == NULL)
	{
		ABORT_FINALIZE(RS_RET_MISSING_CNFPARAMS);
	}
	CODE_STD_STRING_REQUESTnewActInst(1)
	CHKiRet(OMSRsetEntry(*ppOMSR, 0, NULL, OMSR_TPL_AS_MSG));
	CHKiRet(createInstance(&amp;pData));
	setInstParamDefaults(pData);
	for (i = 0; i &lt; actpblk.nParams; ++i)
	{
		if (!pvals[i].bUsed)
			continue;
		if (!strcmp(actpblk.descr[i].name, "key"))
		{
			char *key = es_str2cstr(pvals[i].val.d.estr, NULL);
			char vnamebuf[1024];
			snprintf(vnamebuf, sizeof(vnamebuf), "%s!%s", loadModConf-&gt;container, key);
			CHKmalloc(pData-&gt;pCertitudeKey = strdup(vnamebuf));
			free(key);
			DBGPRINTF("mmdarwin::newActInst:: certitudeKey is %s\n", pData-&gt;pCertitudeKey);
		}
		else if (!strcmp(actpblk.descr[i].name, "socketpath"))
		{
			pData-&gt;pSockName = (uchar *)es_str2cstr(pvals[i].val.d.estr, NULL);
			DBGPRINTF("mmdarwin::newActInst:: sockName is %s\n", pData-&gt;pSockName);
		}
		else if (!strcmp(actpblk.descr[i].name, "socket_max_use"))
		{
			pData-&gt;socketMaxUse = (uint32_t)pvals[i].val.d.n;
			DBGPRINTF("mmdarwin::newActInst:: socketMaxUse is %d\n", pData-&gt;socketMaxUse);
		}
		else if (!strcmp(actpblk.descr[i].name, "send_partial"))
		{
			pData-&gt;sendPartial = (sbool)pvals[i].val.d.n;
			if (pData-&gt;sendPartial)
			{
				DBGPRINTF("mmdarwin::newActInst:: sending bodies even if fields are missing\n");
			}
			else
<a name="1"></a>			{
				DBGPRINTF("mmdarwin::newActInst:: only sending complete bodies\n");
			}
<font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>		}
		else if (!strcmp(actpblk.descr[i].name, "response"))
		{
			char *response = es_str2cstr(pvals[i].val.d.estr, NULL);
			if (!strcmp(response, "no"))
			{
				pData-&gt;response = DARWIN_RESPONSE_SEND_NO;
				DBGPRINTF("mmdarwin::newActInst:: response type is 'no'\n");
			}
			else if (!strcmp(response, "back"))
			{
				pData-&gt;response = DARWIN_RESPONSE_SEND_BACK;
				DBGPRINTF("mmdarwin::newActInst:: response type is 'back'\n");
			}
			else if (!strcmp(response, "darwin"))
			{
				pData-&gt;response = DARWIN_RESPONSE_SEND_DARWIN;
				DBGPRINTF("mmdarwin::newActInst:: response type is 'darwin'\n");
			}
			else if (!strcmp(response, "both"))</b></font>
			{
				pData-&gt;response = DARWIN_RESPONSE_SEND_BOTH;
				DBGPRINTF("mmdarwin::newActInst:: response type is 'both'\n");
			}
			else
			{
				DBGPRINTF(
					"mmdarwin::newActInst:: invalid 'response' value: %s. 'No response' set.\n",
					response);
				pData-&gt;response = DARWIN_RESPONSE_SEND_NO;
				DBGPRINTF("mmdarwin::newActInst:: response type is 'no'\n");
			}
			free(response);
		}
		else if (!strcmp(actpblk.descr[i].name, "filtercode"))
		{
			char *filterCode = es_str2cstr(pvals[i].val.d.estr, NULL);
			pData-&gt;filterCode = strtoull(filterCode, NULL, 16);
			free(filterCode);
		}
		else if (!strcmp(actpblk.descr[i].name, "fields"))
		{
			pData-&gt;fieldList.nmemb = pvals[i].val.d.ar-&gt;nmemb;
			CHKmalloc(pData-&gt;fieldList.name = calloc(pData-&gt;fieldList.nmemb, sizeof(char *)));
			CHKmalloc(pData-&gt;fieldList.varname = calloc(pData-&gt;fieldList.nmemb, sizeof(char *)));
			for (int j = 0; j &lt; pData-&gt;fieldList.nmemb; ++j)
			{
				char *const param = es_str2cstr(pvals[i].val.d.ar-&gt;arr[j], NULL);
				char *varname = NULL;
				char *name;
				if (*param == ':')
				{
					char *b = strchr(param + 1, ':');
					if (b == NULL)
					{
						parser_errmsg(
							"mmdarwin::newActInst:: missing closing colon: '%s'", param);
						ABORT_FINALIZE(RS_RET_ERR);
					}
					*b = '\0'; 					varname = param + 1;
					name = b + 1;
				}
				else
				{
					name = param;
				}
				CHKmalloc(pData-&gt;fieldList.name[j] = strdup(name));
				char vnamebuf[1024];
				snprintf(vnamebuf, sizeof(vnamebuf),
						"%s!%s", loadModConf-&gt;container,
						(varname == NULL) ? name : varname);
				CHKmalloc(pData-&gt;fieldList.varname[j] = strdup(vnamebuf));
				free(param);
				DBGPRINTF("mmdarwin::newActInst:: will look for field %s\n", pData-&gt;fieldList.name[j]);
			}
		}
		else
		{
			DBGPRINTF(
			"mmdarwin::newActInst:: program error, non-handled param '%s'\n", actpblk.descr[i].name);
		}
	}
	size_t sizeKey = strlen(loadModConf-&gt;container) + strlen(JSON_DARWIN_ID) + 2;
	pData-&gt;pUUIDKey = malloc(sizeKey);
	snprintf(pData-&gt;pUUIDKey, sizeKey, "%s!%s", loadModConf-&gt;container, JSON_DARWIN_ID);
	DBGPRINTF("mmdarwin:: uuid key is %s\n", pData-&gt;pUUIDKey);
CODE_STD_FINALIZERnewActInst
	cnfparamvalsDestruct(pvals, &amp;actpblk);
ENDnewActInst
BEGINtryResume
CODESTARTtryResume
	iRet = doTryResume(pWrkrData);
ENDtryResume
BEGINdoAction_NoStrings
	smsg_t **ppMsg = (smsg_t **)pMsgData; 	smsg_t *pMsg = ppMsg[0]; 	instanceData *pData = pWrkrData-&gt;pData; 	char *pFieldValue = NULL; 	int fieldsNum = 0; 
CODESTARTdoAction
	DBGPRINTF("mmdarwin::doAction:: beggining action\n");
	pWrkrData-&gt;darwinBody.bufferMsgSize = 0;
	fieldsNum = 0;
	for (int i = 0; i &lt; pData-&gt;fieldList.nmemb; i++)
	{
		DBGPRINTF("mmdarwin::doAction:: processing field '%s'\n", pData-&gt;fieldList.name[i]);
		pFieldValue = NULL;
		if (pData-&gt;fieldList.name[i][0] != '!' &amp;&amp; pData-&gt;fieldList.name[i][0] != '.')
		{
			pFieldValue = strdup(pData-&gt;fieldList.name[i]);
		}
		else
		{
			if (!get_field(pMsg, pData-&gt;fieldList.name[i], &amp;pFieldValue))
			{
				DBGPRINTF("mmdarwin::doAction:: \
could not extract field '%s' from message\n", pData-&gt;fieldList.name[i]);
				continue;
			}
		}
		DBGPRINTF(
			"mmdarwin::doAction:: got value of field '%s': '%s'\n", pData-&gt;fieldList.name[i], pFieldValue);
		if (add_field_to_body(&amp;(pWrkrData-&gt;darwinBody), pFieldValue, strlen(pFieldValue)) != 0)
		{
			DBGPRINTF("mmdarwin::doAction:: could not add field to body, aborting\n");
			free(pFieldValue);
			ABORT_FINALIZE(RS_RET_ERR);
		}
		fieldsNum++;
		free(pFieldValue);
	}
	if (fieldsNum)
	{
		if (!pData-&gt;sendPartial &amp;&amp; fieldsNum != pData-&gt;fieldList.nmemb)
		{
			DBGPRINTF("mmdarwin::doAction:: not all fields could be retrieved, not sending partial message."
	" (if you wish to send partial messages anyway, set 'send_partial' to 'on' in instance parameters)\n");
			FINALIZE;
		}
		if (end_body(&amp;(pWrkrData-&gt;darwinBody)) != 0)
			ABORT_FINALIZE(RS_RET_ERR);
	}
	else
	{
		DBGPRINTF("mmdarwin::doAction:: no fields retrieved, finalizing\n");
		FINALIZE;
	}
	DBGPRINTF("mmdarwin::doAction:: body to send: '%s'\n", pWrkrData-&gt;darwinBody.buffer);
	if (pData-&gt;socketMaxUse)
	{
		if (!pWrkrData-&gt;pktSentSocket)
		{
			DBGPRINTF("mmdarwin::doAction:: opening a new connection\n");
			CHKiRet(doTryResume(pWrkrData));
		}
		pWrkrData-&gt;pktSentSocket = (pWrkrData-&gt;pktSentSocket + 1) % pData-&gt;socketMaxUse;
	}
	darwin_filter_packet_t header = {
		.type = DARWIN_PACKET_OTHER,
		.response = pData-&gt;response,
		.filter_code = pData-&gt;filterCode,
		.body_size = pWrkrData-&gt;darwinBody.bufferMsgSize};
	const char *uuid = get_uuid_object(pMsg);
	if(uuid) {
		DBGPRINTF("mmdarwin: using existing UUID = %s\n", uuid);
		if(uuid_parse(uuid, header.evt_id))
			LogError(0, RS_RET_ERR, "mmdarwin:: failed to parse existing UUID: %s\n", uuid);
		free((void*)uuid);
	}
	else {
		uuid_generate(header.evt_id);
		char uuidStr[40];
		uuid_unparse(header.evt_id, uuidStr);
		DBGPRINTF("mmdarwin: generated new UUID = %s\n", uuidStr);
		msgAddJSON(pMsg, (uchar *)pData-&gt;pUUIDKey, json_object_new_string(uuidStr), 0, 0);
	}
	DBGPRINTF("mmdarwin::doAction:: sending header to Darwin\n");
	CHKiRet(sendMsg(pWrkrData, &amp;header, sizeof(darwin_filter_packet_t)));
	DBGPRINTF("mmdarwin::doAction:: sending body to Darwin\n");
	CHKiRet(sendMsg(pWrkrData, (void *)(pWrkrData-&gt;darwinBody.buffer), pWrkrData-&gt;darwinBody.bufferMsgSize));
	if (pData-&gt;response == DARWIN_RESPONSE_SEND_NO || pData-&gt;response == DARWIN_RESPONSE_SEND_DARWIN)
	{
		DBGPRINTF("mmdarwin::doAction:: no response will be sent back "
				"(darwin response type is set to 'no' or 'darwin')\n");
		goto finalize_it;
	}
	darwin_filter_packet_t response;
	memset(&amp;response, 0, sizeof(response));
	DBGPRINTF("mmdarwin::doAction:: receiving from Darwin\n");
	CHKiRet(receiveMsg(pWrkrData, &amp;response, sizeof(response)));
	unsigned int certitude = response.certitude_list[0];
	DBGPRINTF("mmdarwin::doAction:: end of the transaction, certitude is %d\n", certitude);
	msgAddJSON(pMsg, (uchar *)pData-&gt;pCertitudeKey, json_object_new_int(certitude), 0, 0);
finalize_it :
	DBGPRINTF("mmdarwin::doAction:: finished processing log line\n");
ENDdoAction
NO_LEGACY_CONF_parseSelectorAct
BEGINmodExit
CODESTARTmodExit
	objRelease(glbl, CORE_COMPONENT);
ENDmodExit
BEGINqueryEtryPt
CODESTARTqueryEtryPt
CODEqueryEtryPt_STD_OMOD_QUERIES
CODEqueryEtryPt_STD_OMOD8_QUERIES
CODEqueryEtryPt_STD_CONF2_setModCnf_QUERIES
CODEqueryEtryPt_STD_CONF2_OMOD_QUERIES
CODEqueryEtryPt_STD_CONF2_QUERIES
ENDqueryEtryPt
BEGINmodInit()
CODESTARTmodInit
	*ipIFVersProvided = CURR_MOD_IF_VERSION;
CODEmodInit_QueryRegCFSLineHdlr
	DBGPRINTF("mmdarwin::modInit:: module compiled with rsyslog version %s.\n", VERSION);
	CHKiRet(objUse(glbl, CORE_COMPONENT));
ENDmodInit
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>glbl.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
#include "config.h"
#include &lt;stdlib.h&gt;
#include &lt;sys/socket.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;sys/stat.h&gt;
#include &lt;sys/wait.h&gt;
#include &lt;fcntl.h&gt;
#include &lt;unistd.h&gt;
#include &lt;pthread.h&gt;
#include &lt;ctype.h&gt;
#include &lt;assert.h&gt;
#include &lt;stdint.h&gt;
#include &lt;errno.h&gt;
#include "rsyslog.h"
#include "obj.h"
#include "unicode-helper.h"
#include "cfsysline.h"
#include "glbl.h"
#include "prop.h"
#include "atomic.h"
#include "errmsg.h"
#include "action.h"
#include "parserif.h"
#include "rainerscript.h"
#include "srUtils.h"
#include "operatingstate.h"
#include "net.h"
#include "rsconf.h"
#include "queue.h"
#include "dnscache.h"
#include "parser.h"
#include "timezones.h"
#ifndef DFLT_NETSTRM_DRVR
#	define DFLT_NETSTRM_DRVR ((uchar*)"ptcp")
#endif
DEFobjStaticHelpers
DEFobjCurrIf(prop)
DEFobjCurrIf(net)
static struct cnfobj *mainqCnfObj = NULL;static int bPreserveFQDN = 0;		static prop_t *propLocalIPIF = NULL;static int propLocalIPIF_set = 0;	static prop_t *propLocalHostName = NULL;static prop_t *propLocalHostNameToDelete = NULL;static uchar *LocalHostName = NULL;static uchar *LocalHostNameOverride = NULL;static uchar *LocalFQDNName = NULL;static uchar *LocalDomain = NULL;static int iMaxLine = 8096;
int bTerminateInputs = 0;		int glblUnloadModules = 1;
char** glblDbgFiles = NULL;
size_t glblDbgFilesNum = 0;
int glblDbgWhitelist = 1;
int glblPermitCtlC = 0;
pid_t glbl_ourpid;
#ifndef HAVE_ATOMIC_BUILTINS
DEF_ATOMIC_HELPER_MUT(mutTerminateInputs);
#endif
#ifdef USE_UNLIMITED_SELECT
static int iFdSetSize = howmany(FD_SETSIZE, __NFDBITS) * sizeof (fd_mask); #endif
static uchar *SourceIPofLocalClient = NULL;	
static struct cnfparamdescr cnfparamdescr[] = {
	{ "workdirectory", eCmdHdlrString, 0 },
	{ "operatingstatefile", eCmdHdlrString, 0 },
	{ "dropmsgswithmaliciousdnsptrrecords", eCmdHdlrBinary, 0 },
	{ "localhostname", eCmdHdlrGetWord, 0 },
	{ "preservefqdn", eCmdHdlrBinary, 0 },
	{ "debug.onshutdown", eCmdHdlrBinary, 0 },
	{ "debug.logfile", eCmdHdlrString, 0 },
	{ "debug.gnutls", eCmdHdlrNonNegInt, 0 },
	{ "debug.unloadmodules", eCmdHdlrBinary, 0 },
	{ "defaultnetstreamdrivercafile", eCmdHdlrString, 0 },
	{ "defaultnetstreamdriverkeyfile", eCmdHdlrString, 0 },
	{ "defaultnetstreamdrivercertfile", eCmdHdlrString, 0 },
	{ "defaultnetstreamdriver", eCmdHdlrString, 0 },
	{ "maxmessagesize", eCmdHdlrSize, 0 },
	{ "oversizemsg.errorfile", eCmdHdlrGetWord, 0 },
	{ "oversizemsg.report", eCmdHdlrBinary, 0 },
	{ "oversizemsg.input.mode", eCmdHdlrGetWord, 0 },
	{ "reportchildprocessexits", eCmdHdlrGetWord, 0 },
	{ "action.reportsuspension", eCmdHdlrBinary, 0 },
	{ "action.reportsuspensioncontinuation", eCmdHdlrBinary, 0 },
	{ "parser.controlcharacterescapeprefix", eCmdHdlrGetChar, 0 },
	{ "parser.droptrailinglfonreception", eCmdHdlrBinary, 0 },
	{ "parser.escapecontrolcharactersonreceive", eCmdHdlrBinary, 0 },
	{ "parser.spacelfonreceive", eCmdHdlrBinary, 0 },
	{ "parser.escape8bitcharactersonreceive", eCmdHdlrBinary, 0},
	{ "parser.escapecontrolcharactertab", eCmdHdlrBinary, 0},
	{ "parser.escapecontrolcharacterscstyle", eCmdHdlrBinary, 0 },
	{ "parser.parsehostnameandtag", eCmdHdlrBinary, 0 },
	{ "parser.permitslashinprogramname", eCmdHdlrBinary, 0 },
	{ "stdlog.channelspec", eCmdHdlrString, 0 },
	{ "janitor.interval", eCmdHdlrPositiveInt, 0 },
	{ "senders.reportnew", eCmdHdlrBinary, 0 },
	{ "senders.reportgoneaway", eCmdHdlrBinary, 0 },
	{ "senders.timeoutafter", eCmdHdlrPositiveInt, 0 },
	{ "senders.keeptrack", eCmdHdlrBinary, 0 },
	{ "inputs.timeout.shutdown", eCmdHdlrPositiveInt, 0 },
	{ "privdrop.group.keepsupplemental", eCmdHdlrBinary, 0 },
	{ "privdrop.group.id", eCmdHdlrPositiveInt, 0 },
	{ "privdrop.group.name", eCmdHdlrGID, 0 },
	{ "privdrop.user.id", eCmdHdlrPositiveInt, 0 },
	{ "privdrop.user.name", eCmdHdlrUID, 0 },
	{ "net.ipprotocol", eCmdHdlrGetWord, 0 },
	{ "net.acladdhostnameonfail", eCmdHdlrBinary, 0 },
	{ "net.aclresolvehostname", eCmdHdlrBinary, 0 },
	{ "net.enabledns", eCmdHdlrBinary, 0 },
	{ "net.permitACLwarning", eCmdHdlrBinary, 0 },
	{ "abortonuncleanconfig", eCmdHdlrBinary, 0 },
	{ "variables.casesensitive", eCmdHdlrBinary, 0 },
	{ "environment", eCmdHdlrArray, 0 },
	{ "processinternalmessages", eCmdHdlrBinary, 0 },
	{ "umask", eCmdHdlrFileCreateMode, 0 },
	{ "security.abortonidresolutionfail", eCmdHdlrBinary, 0 },
	{ "internal.developeronly.options", eCmdHdlrInt, 0 },
	{ "internalmsg.ratelimit.interval", eCmdHdlrPositiveInt, 0 },
	{ "internalmsg.ratelimit.burst", eCmdHdlrPositiveInt, 0 },
	{ "internalmsg.severity", eCmdHdlrSeverity, 0 },
	{ "errormessagestostderr.maxnumber", eCmdHdlrPositiveInt, 0 },
	{ "shutdown.enable.ctlc", eCmdHdlrBinary, 0 },
	{ "default.action.queue.timeoutshutdown", eCmdHdlrInt, 0 },
	{ "default.action.queue.timeoutactioncompletion", eCmdHdlrInt, 0 },
	{ "default.action.queue.timeoutenqueue", eCmdHdlrInt, 0 },
	{ "default.action.queue.timeoutworkerthreadshutdown", eCmdHdlrInt, 0 },
<a name="0"></a>	{ "default.ruleset.queue.timeoutshutdown", eCmdHdlrInt, 0 },
	{ "default.ruleset.queue.timeoutactioncompletion", eCmdHdlrInt, 0 },
	{ "default.ruleset.queue.timeoutenqueue", eCmdHdlrInt, 0 },
<font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>	{ "default.ruleset.queue.timeoutworkerthreadshutdown", eCmdHdlrInt, 0 },
	{ "reverselookup.cache.ttl.default", eCmdHdlrNonNegInt, 0 },
	{ "reverselookup.cache.ttl.enable", eCmdHdlrBinary, 0 },
	{ "parser.supportcompressionextension", eCmdHdlrBinary, 0 },
	{ "shutdown.queue.doublesize", eCmdHdlrBinary, 0 },
	{ "debug.files", eCmdHdlrArray, 0 },
	{ "debug.whitelist", eCmdHdlrBinary, 0 }
};
static struct cnfparamblk paramblk =
	{ CNFPARAMBLK_VERSION,
	  sizeof(cnfparamdescr)/sizeof(struct cnfparamdescr),
	  cnfparamdescr
	};
static struct cnfparamvals *cnfparamvals = NULL;</b></font>
int
glblGetMaxLine(rsconf_t *cnf)
{
	return((cnf != NULL) ? cnf-&gt;globals.iMaxLine : iMaxLine);
}
int
GetGnuTLSLoglevel(rsconf_t *cnf)
{
	return(cnf-&gt;globals.iGnuTLSLoglevel);
}
#define SIMP_PROP(nameFunc, nameVar, dataType) \
	SIMP_PROP_GET(nameFunc, nameVar, dataType) \
	SIMP_PROP_SET(nameFunc, nameVar, dataType)
#define SIMP_PROP_SET(nameFunc, nameVar, dataType) \
static rsRetVal Set##nameFunc(dataType newVal) \
{ \
	nameVar = newVal; \
	return RS_RET_OK; \
}
#define SIMP_PROP_GET(nameFunc, nameVar, dataType) \
static dataType Get##nameFunc(void) \
{ \
	return(nameVar); \
}
SIMP_PROP(PreserveFQDN, bPreserveFQDN, int)
SIMP_PROP(mainqCnfObj, mainqCnfObj, struct cnfobj *)
#ifdef USE_UNLIMITED_SELECT
SIMP_PROP(FdSetSize, iFdSetSize, int)
#endif
#undef SIMP_PROP
#undef SIMP_PROP_SET
#undef SIMP_PROP_GET
#define SIMP_PROP(nameFunc, nameVar, dataType) \
	SIMP_PROP_GET(nameFunc, nameVar, dataType) \
	SIMP_PROP_SET(nameFunc, nameVar, dataType)
#define SIMP_PROP_SET(nameFunc, nameVar, dataType) \
static rsRetVal Set##nameFunc(dataType newVal) \
{ \
	loadConf-&gt;globals.nameVar = newVal; \
	return RS_RET_OK; \
}
#define SIMP_PROP_GET(nameFunc, nameVar, dataType) \
static dataType Get##nameFunc(rsconf_t *cnf) \
{ \
	return(cnf-&gt;globals.nameVar); \
}
SIMP_PROP(DropMalPTRMsgs, bDropMalPTRMsgs, int)
SIMP_PROP(DisableDNS, bDisableDNS, int)
SIMP_PROP(ParserEscapeControlCharactersCStyle, parser.bParserEscapeCCCStyle, int)
SIMP_PROP(ParseHOSTNAMEandTAG, parser.bParseHOSTNAMEandTAG, int)
SIMP_PROP(OptionDisallowWarning, optionDisallowWarning, int)
SIMP_PROP_GET(DfltNetstrmDrvrCAF, pszDfltNetstrmDrvrCAF, uchar*)
SIMP_PROP_GET(DfltNetstrmDrvrCertFile, pszDfltNetstrmDrvrCertFile, uchar*)
SIMP_PROP_GET(DfltNetstrmDrvrKeyFile, pszDfltNetstrmDrvrKeyFile, uchar*)
SIMP_PROP_GET(ParserControlCharacterEscapePrefix, parser.cCCEscapeChar, uchar)
SIMP_PROP_GET(ParserDropTrailingLFOnReception, parser.bDropTrailingLF, int)
SIMP_PROP_GET(ParserEscapeControlCharactersOnReceive, parser.bEscapeCCOnRcv, int)
SIMP_PROP_GET(ParserSpaceLFOnReceive, parser.bSpaceLFOnRcv, int)
SIMP_PROP_GET(ParserEscape8BitCharactersOnReceive, parser.bEscape8BitChars, int)
SIMP_PROP_GET(ParserEscapeControlCharacterTab, parser.bEscapeTab, int)
#undef SIMP_PROP
#undef SIMP_PROP_SET
#undef SIMP_PROP_GET
static int GetGlobalInputTermState(void)
{
	return ATOMIC_FETCH_32BIT(&amp;bTerminateInputs, &amp;mutTerminateInputs);
}
static void SetGlobalInputTermination(void)
{
	ATOMIC_STORE_1_TO_INT(&amp;bTerminateInputs, &amp;mutTerminateInputs);
}
static rsRetVal
storeLocalHostIPIF(uchar *myIP)
{
	DEFiRet;
	if(propLocalIPIF != NULL) {
		CHKiRet(prop.Destruct(&amp;propLocalIPIF));
	}
	CHKiRet(prop.Construct(&amp;propLocalIPIF));
	CHKiRet(prop.SetString(propLocalIPIF, myIP, ustrlen(myIP)));
	CHKiRet(prop.ConstructFinalize(propLocalIPIF));
	DBGPRINTF("rsyslog/glbl: using '%s' as localhost IP\n", myIP);
finalize_it:
	RETiRet;
}
static rsRetVal
setLocalHostIPIF(void __attribute__((unused)) *pVal, uchar *pNewVal)
{
	uchar myIP[128];
	rsRetVal localRet;
	DEFiRet;
	CHKiRet(objUse(net, CORE_COMPONENT));
	if(propLocalIPIF_set) {
		LogError(0, RS_RET_ERR, "$LocalHostIPIF is already set "
				"and cannot be reset; place it at TOP OF rsyslog.conf!");
		ABORT_FINALIZE(RS_RET_ERR);
	}
	localRet = net.GetIFIPAddr(pNewVal, AF_UNSPEC, myIP, (int) sizeof(myIP));
	if(localRet != RS_RET_OK) {
		LogError(0, RS_RET_ERR, "$LocalHostIPIF: IP address for interface "
				"'%s' cannnot be obtained - ignoring directive", pNewVal);
	} else  {
		storeLocalHostIPIF(myIP);
	}
finalize_it:
	free(pNewVal); 	RETiRet;
}
static rsRetVal setWorkDir(void __attribute__((unused)) *pVal, uchar *pNewVal)
{
	size_t lenDir;
	int i;
	struct stat sb;
	DEFiRet;
	lenDir = ustrlen(pNewVal);
	i = lenDir - 1;
	while(i &gt; 0 &amp;&amp; pNewVal[i] == '/') {
		--i;
	}
	if(i &lt; 0) {
		LogError(0, RS_RET_ERR_WRKDIR, "$WorkDirectory: empty value "
				"- directive ignored");
		ABORT_FINALIZE(RS_RET_ERR_WRKDIR);
	}
	if(i != (int) lenDir - 1) {
		pNewVal[i+1] = '\0';
		LogError(0, RS_RET_WRN_WRKDIR, "$WorkDirectory: trailing slashes "
			"removed, new value is '%s'", pNewVal);
	}
	if(stat((char*) pNewVal, &amp;sb) != 0) {
		LogError(0, RS_RET_ERR_WRKDIR, "$WorkDirectory: %s can not be "
				"accessed, probably does not exist - directive ignored", pNewVal);
		ABORT_FINALIZE(RS_RET_ERR_WRKDIR);
	}
	if(!S_ISDIR(sb.st_mode)) {
		LogError(0, RS_RET_ERR_WRKDIR, "$WorkDirectory: %s not a directory - directive ignored",
				pNewVal);
		ABORT_FINALIZE(RS_RET_ERR_WRKDIR);
	}
	free(loadConf-&gt;globals.pszWorkDir);
	loadConf-&gt;globals.pszWorkDir = pNewVal;
finalize_it:
	RETiRet;
}
static rsRetVal
setDfltNetstrmDrvrCAF(void __attribute__((unused)) *pVal, uchar *pNewVal) {
	DEFiRet;
	FILE *fp;
	free(loadConf-&gt;globals.pszDfltNetstrmDrvrCAF);
	fp = fopen((const char*)pNewVal, "r");
	if(fp == NULL) {
		LogError(errno, RS_RET_NO_FILE_ACCESS,
			"error: defaultnetstreamdrivercafile file '%s' "
			"could not be accessed", pNewVal);
	} else {
		fclose(fp);
		loadConf-&gt;globals.pszDfltNetstrmDrvrCAF = pNewVal;
	}
	RETiRet;
}
static rsRetVal
setDfltNetstrmDrvrCertFile(void __attribute__((unused)) *pVal, uchar *pNewVal) {
	DEFiRet;
	FILE *fp;
	free(loadConf-&gt;globals.pszDfltNetstrmDrvrCertFile);
	fp = fopen((const char*)pNewVal, "r");
	if(fp == NULL) {
		LogError(errno, RS_RET_NO_FILE_ACCESS,
			"error: defaultnetstreamdrivercertfile '%s' "
			"could not be accessed", pNewVal);
	} else {
		fclose(fp);
		loadConf-&gt;globals.pszDfltNetstrmDrvrCertFile = pNewVal;
	}
	RETiRet;
}
static rsRetVal
setDfltNetstrmDrvrKeyFile(void __attribute__((unused)) *pVal, uchar *pNewVal) {
	DEFiRet;
	FILE *fp;
	free(loadConf-&gt;globals.pszDfltNetstrmDrvrKeyFile);
	fp = fopen((const char*)pNewVal, "r");
	if(fp == NULL) {
		LogError(errno, RS_RET_NO_FILE_ACCESS,
			"error: defaultnetstreamdriverkeyfile '%s' "
			"could not be accessed", pNewVal);
	} else {
		fclose(fp);
		loadConf-&gt;globals.pszDfltNetstrmDrvrKeyFile = pNewVal;
	}
	RETiRet;
}
static rsRetVal
setDfltNetstrmDrvr(void __attribute__((unused)) *pVal, uchar *pNewVal) {
	DEFiRet;
	free(loadConf-&gt;globals.pszDfltNetstrmDrvr);
	loadConf-&gt;globals.pszDfltNetstrmDrvr = pNewVal;
	RETiRet;
}
static rsRetVal
setParserControlCharacterEscapePrefix(void __attribute__((unused)) *pVal, uchar *pNewVal) {
	DEFiRet;
	loadConf-&gt;globals.parser.cCCEscapeChar = *pNewVal;
	RETiRet;
}
static rsRetVal
setParserDropTrailingLFOnReception(void __attribute__((unused)) *pVal, int pNewVal) {
	DEFiRet;
	loadConf-&gt;globals.parser.bDropTrailingLF = pNewVal;
	RETiRet;
}
static rsRetVal
setParserEscapeControlCharactersOnReceive(void __attribute__((unused)) *pVal, int pNewVal) {
	DEFiRet;
	loadConf-&gt;globals.parser.bEscapeCCOnRcv = pNewVal;
	RETiRet;
}
static rsRetVal
setParserSpaceLFOnReceive(void __attribute__((unused)) *pVal, int pNewVal) {
	DEFiRet;
	loadConf-&gt;globals.parser.bSpaceLFOnRcv = pNewVal;
	RETiRet;
}
static rsRetVal
setParserEscape8BitCharactersOnReceive(void __attribute__((unused)) *pVal, int pNewVal) {
	DEFiRet;
	loadConf-&gt;globals.parser.bEscape8BitChars = pNewVal;
	RETiRet;
}
static rsRetVal
setParserEscapeControlCharacterTab(void __attribute__((unused)) *pVal, int pNewVal) {
	DEFiRet;
	loadConf-&gt;globals.parser.bEscapeTab = pNewVal;
	RETiRet;
}
static void
setMaxLine(const int64_t iNew)
{
	if(iNew &lt; 128) {
		LogError(0, RS_RET_INVALID_VALUE, "maxMessageSize tried to set "
				"to %lld, but cannot be less than 128 - set to 128 "
				"instead", (long long) iNew);
		loadConf-&gt;globals.iMaxLine = 128;
	} else if(iNew &gt; (int64_t) INT_MAX) {
		LogError(0, RS_RET_INVALID_VALUE, "maxMessageSize larger than "
				"INT_MAX (%d) - reduced to INT_MAX", INT_MAX);
		loadConf-&gt;globals.iMaxLine = INT_MAX;
	} else {
		loadConf-&gt;globals.iMaxLine = (int) iNew;
	}
}
static rsRetVal
legacySetMaxMessageSize(void __attribute__((unused)) *pVal, int64_t iNew)
{
	setMaxLine(iNew);
	return RS_RET_OK;
}
static rsRetVal
setDebugFile(void __attribute__((unused)) *pVal, uchar *pNewVal)
{
	DEFiRet;
	dbgSetDebugFile(pNewVal);
	free(pNewVal);
	RETiRet;
}
static rsRetVal
setDebugLevel(void __attribute__((unused)) *pVal, int level)
{
	DEFiRet;
	dbgSetDebugLevel(level);
	dbgprintf("debug level %d set via config file\n", level);
	dbgprintf("This is rsyslog version " VERSION "\n");
	RETiRet;
}
static rsRetVal ATTR_NONNULL()
setOversizeMsgInputMode(const uchar *const mode)
{
	DEFiRet;
	if(!strcmp((char*)mode, "truncate")) {
		loadConf-&gt;globals.oversizeMsgInputMode = glblOversizeMsgInputMode_Truncate;
	} else if(!strcmp((char*)mode, "split")) {
		loadConf-&gt;globals.oversizeMsgInputMode = glblOversizeMsgInputMode_Split;
	} else if(!strcmp((char*)mode, "accept")) {
		loadConf-&gt;globals.oversizeMsgInputMode = glblOversizeMsgInputMode_Accept;
	} else {
		loadConf-&gt;globals.oversizeMsgInputMode = glblOversizeMsgInputMode_Truncate;
	}
	RETiRet;
}
static rsRetVal ATTR_NONNULL()
setReportChildProcessExits(const uchar *const mode)
{
	DEFiRet;
	if(!strcmp((char*)mode, "none")) {
		loadConf-&gt;globals.reportChildProcessExits = REPORT_CHILD_PROCESS_EXITS_NONE;
	} else if(!strcmp((char*)mode, "errors")) {
		loadConf-&gt;globals.reportChildProcessExits = REPORT_CHILD_PROCESS_EXITS_ERRORS;
	} else if(!strcmp((char*)mode, "all")) {
		loadConf-&gt;globals.reportChildProcessExits = REPORT_CHILD_PROCESS_EXITS_ALL;
	} else {
		LogError(0, RS_RET_CONF_PARAM_INVLD,
				"invalid value '%s' for global parameter reportChildProcessExits -- ignored",
				mode);
		iRet = RS_RET_CONF_PARAM_INVLD;
	}
	RETiRet;
}
static int
getDefPFFamily(rsconf_t *cnf)
{
	return cnf-&gt;globals.iDefPFFamily;
}
static prop_t*
GetLocalHostIP(void)
{
	assert(propLocalIPIF != NULL);
	return(propLocalIPIF);
}
static rsRetVal
SetLocalHostName(uchar *const newname)
{
	uchar *toFree;
	if(LocalHostName == NULL || strcmp((const char*)LocalHostName, (const char*) newname)) {
		toFree = LocalHostName;
		LocalHostName = newname;
	} else {
		toFree = newname;
	}
	free(toFree);
	return RS_RET_OK;
}
static uchar*
GetLocalHostName(void)
{
	uchar *pszRet;
	if(LocalHostNameOverride != NULL) {
		pszRet = LocalHostNameOverride;
		goto done;
	}
	if(LocalHostName == NULL)
		pszRet = (uchar*) "[localhost]";
	else {
		if(GetPreserveFQDN() == 1)
			pszRet = LocalFQDNName;
		else
			pszRet = LocalHostName;
	}
done:
	return(pszRet);
}
uchar*
glblGetOversizeMsgErrorFile(rsconf_t *cnf)
{
	return cnf-&gt;globals.oversizeMsgErrorFile;
}
const uchar*
glblGetOperatingStateFile(rsconf_t *cnf)
{
	return cnf-&gt;globals.operatingStateFile;
}
int
glblGetOversizeMsgInputMode(rsconf_t *cnf)
{
	return cnf-&gt;globals.oversizeMsgInputMode;
}
int
glblReportOversizeMessage(rsconf_t *cnf)
{
	return cnf-&gt;globals.reportOversizeMsg;
}
void
glblReportChildProcessExit(rsconf_t *cnf, const uchar *name, pid_t pid, int status)
{
	DBGPRINTF("waitpid for child %ld returned status: %2.2x\n", (long) pid, status);
	if(cnf-&gt;globals.reportChildProcessExits == REPORT_CHILD_PROCESS_EXITS_NONE
		|| (cnf-&gt;globals.reportChildProcessExits == REPORT_CHILD_PROCESS_EXITS_ERRORS
			&amp;&amp; WIFEXITED(status) &amp;&amp; WEXITSTATUS(status) == 0)) {
		return;
	}
	if(WIFEXITED(status)) {
		int severity = WEXITSTATUS(status) == 0 ? LOG_INFO : LOG_WARNING;
		if(name != NULL) {
			LogMsg(0, NO_ERRCODE, severity, "program '%s' (pid %ld) exited with status %d",
					name, (long) pid, WEXITSTATUS(status));
		} else {
			LogMsg(0, NO_ERRCODE, severity, "child process (pid %ld) exited with status %d",
					(long) pid, WEXITSTATUS(status));
		}
	} else if(WIFSIGNALED(status)) {
		if(name != NULL) {
			LogMsg(0, NO_ERRCODE, LOG_WARNING, "program '%s' (pid %ld) terminated by signal %d",
					name, (long) pid, WTERMSIG(status));
		} else {
			LogMsg(0, NO_ERRCODE, LOG_WARNING, "child process (pid %ld) terminated by signal %d",
					(long) pid, WTERMSIG(status));
		}
	}
}
static rsRetVal
SetLocalDomain(uchar *newname)
{
	free(LocalDomain);
	LocalDomain = newname;
	return RS_RET_OK;
}
static uchar*
GetLocalDomain(void)
{
	return LocalDomain;
}
static rsRetVal
GenerateLocalHostNameProperty(void)
{
	uchar *pszPrev;
	int lenPrev;
	prop_t *hostnameNew;
	uchar *pszName;
	DEFiRet;
	if(propLocalHostNameToDelete != NULL)
		prop.Destruct(&amp;propLocalHostNameToDelete);
	if(LocalHostNameOverride == NULL) {
		if(LocalHostName == NULL)
			pszName = (uchar*) "[localhost]";
		else {
			if(GetPreserveFQDN() == 1)
				pszName = LocalFQDNName;
			else
				pszName = LocalHostName;
		}
	} else { 		pszName = LocalHostNameOverride;
	}
	DBGPRINTF("GenerateLocalHostName uses '%s'\n", pszName);
	if(propLocalHostName == NULL)
		pszPrev = (uchar*)""; 	else
		prop.GetString(propLocalHostName, &amp;pszPrev, &amp;lenPrev);
	if(ustrcmp(pszPrev, pszName)) {
		CHKiRet(prop.Construct(&amp;hostnameNew));
		CHKiRet(prop.SetString(hostnameNew, pszName, ustrlen(pszName)));
		CHKiRet(prop.ConstructFinalize(hostnameNew));
		propLocalHostNameToDelete = propLocalHostName;
		propLocalHostName = hostnameNew;
	}
finalize_it:
	RETiRet;
}
static prop_t*
GetLocalHostNameProp(void)
{
	return(propLocalHostName);
}
static rsRetVal
SetLocalFQDNName(uchar *newname)
{
	free(LocalFQDNName);
	LocalFQDNName = newname;
	return RS_RET_OK;
}
static uchar*
GetLocalFQDNName(void)
{
	return(LocalFQDNName == NULL ? (uchar*) "[localhost]" : LocalFQDNName);
}
static uchar*
GetWorkDir(rsconf_t *cnf)
{
	return(cnf-&gt;globals.pszWorkDir == NULL ? (uchar*) "" : cnf-&gt;globals.pszWorkDir);
}
const uchar *
glblGetWorkDirRaw(rsconf_t *cnf)
{
	return cnf-&gt;globals.pszWorkDir;
}
static uchar*
GetDfltNetstrmDrvr(rsconf_t *cnf)
{
	return(cnf-&gt;globals.pszDfltNetstrmDrvr == NULL ? DFLT_NETSTRM_DRVR : cnf-&gt;globals.pszDfltNetstrmDrvr);
}
static rsRetVal
SetSourceIPofLocalClient(uchar *newname)
{
	if(SourceIPofLocalClient != NULL) {
		free(SourceIPofLocalClient); }
	SourceIPofLocalClient = newname;
	return RS_RET_OK;
}
static uchar*
GetSourceIPofLocalClient(void)
{
	return(SourceIPofLocalClient);
}
BEGINobjQueryInterface(glbl)
CODESTARTobjQueryInterface(glbl)
	if(pIf-&gt;ifVersion != glblCURR_IF_VERSION) { 		ABORT_FINALIZE(RS_RET_INTERFACE_NOT_SUPPORTED);
	}
	pIf-&gt;GetWorkDir = GetWorkDir;
	pIf-&gt;GenerateLocalHostNameProperty = GenerateLocalHostNameProperty;
	pIf-&gt;GetLocalHostNameProp = GetLocalHostNameProp;
	pIf-&gt;GetLocalHostIP = GetLocalHostIP;
	pIf-&gt;SetGlobalInputTermination = SetGlobalInputTermination;
	pIf-&gt;GetGlobalInputTermState = GetGlobalInputTermState;
	pIf-&gt;GetSourceIPofLocalClient = GetSourceIPofLocalClient;		pIf-&gt;SetSourceIPofLocalClient = SetSourceIPofLocalClient;		pIf-&gt;GetDefPFFamily = getDefPFFamily;
	pIf-&gt;GetDisableDNS = GetDisableDNS;
	pIf-&gt;GetMaxLine = glblGetMaxLine;
	pIf-&gt;GetOptionDisallowWarning = GetOptionDisallowWarning;
	pIf-&gt;GetDfltNetstrmDrvrCAF = GetDfltNetstrmDrvrCAF;
	pIf-&gt;GetDfltNetstrmDrvrCertFile = GetDfltNetstrmDrvrCertFile;
	pIf-&gt;GetDfltNetstrmDrvrKeyFile = GetDfltNetstrmDrvrKeyFile;
	pIf-&gt;GetDfltNetstrmDrvr = GetDfltNetstrmDrvr;
	pIf-&gt;GetParserControlCharacterEscapePrefix = GetParserControlCharacterEscapePrefix;
	pIf-&gt;GetParserDropTrailingLFOnReception = GetParserDropTrailingLFOnReception;
	pIf-&gt;GetParserEscapeControlCharactersOnReceive = GetParserEscapeControlCharactersOnReceive;
	pIf-&gt;GetParserSpaceLFOnReceive = GetParserSpaceLFOnReceive;
	pIf-&gt;GetParserEscape8BitCharactersOnReceive = GetParserEscape8BitCharactersOnReceive;
	pIf-&gt;GetParserEscapeControlCharacterTab = GetParserEscapeControlCharacterTab;
#define SIMP_PROP(name) \
	pIf-&gt;Get##name = Get##name; \
	pIf-&gt;Set##name = Set##name;
	SIMP_PROP(PreserveFQDN);
	SIMP_PROP(DropMalPTRMsgs);
	SIMP_PROP(mainqCnfObj);
	SIMP_PROP(LocalFQDNName)
	SIMP_PROP(LocalHostName)
	SIMP_PROP(LocalDomain)
	SIMP_PROP(ParserEscapeControlCharactersCStyle)
	SIMP_PROP(ParseHOSTNAMEandTAG)
#ifdef USE_UNLIMITED_SELECT
	SIMP_PROP(FdSetSize)
#endif
#undef	SIMP_PROP
finalize_it:
ENDobjQueryInterface(glbl)
static rsRetVal resetConfigVariables(uchar __attribute__((unused)) *pp, void __attribute__((unused)) *pVal)
{
	free(loadConf-&gt;globals.pszDfltNetstrmDrvr);
	loadConf-&gt;globals.pszDfltNetstrmDrvr = NULL;
	free(loadConf-&gt;globals.pszDfltNetstrmDrvrCAF);
	loadConf-&gt;globals.pszDfltNetstrmDrvrCAF = NULL;
	free(loadConf-&gt;globals.pszDfltNetstrmDrvrKeyFile);
	loadConf-&gt;globals.pszDfltNetstrmDrvrKeyFile = NULL;
	free(loadConf-&gt;globals.pszDfltNetstrmDrvrCertFile);
	loadConf-&gt;globals.pszDfltNetstrmDrvrCertFile = NULL;
	free(LocalHostNameOverride);
	LocalHostNameOverride = NULL;
	free(loadConf-&gt;globals.oversizeMsgErrorFile);
	loadConf-&gt;globals.oversizeMsgErrorFile = NULL;
	loadConf-&gt;globals.oversizeMsgInputMode = glblOversizeMsgInputMode_Accept;
	loadConf-&gt;globals.reportChildProcessExits = REPORT_CHILD_PROCESS_EXITS_ERRORS;
	free(loadConf-&gt;globals.pszWorkDir);
	loadConf-&gt;globals.pszWorkDir = NULL;
	free((void*)loadConf-&gt;globals.operatingStateFile);
	loadConf-&gt;globals.operatingStateFile = NULL;
	loadConf-&gt;globals.bDropMalPTRMsgs = 0;
	bPreserveFQDN = 0;
	loadConf-&gt;globals.iMaxLine = 8192;
	loadConf-&gt;globals.reportOversizeMsg = 1;
	loadConf-&gt;globals.parser.cCCEscapeChar = '#';
	loadConf-&gt;globals.parser.bDropTrailingLF = 1;
	loadConf-&gt;globals.parser.bEscapeCCOnRcv = 1; 	loadConf-&gt;globals.parser.bSpaceLFOnRcv = 0;
	loadConf-&gt;globals.parser.bEscape8BitChars = 0; 	loadConf-&gt;globals.parser.bEscapeTab = 1; 	loadConf-&gt;globals.parser.bParserEscapeCCCStyle = 0;
#ifdef USE_UNLIMITED_SELECT
	iFdSetSize = howmany(FD_SETSIZE, __NFDBITS) * sizeof (fd_mask);
#endif
	return RS_RET_OK;
}
void
glblPrepCnf(void)
{
	free(mainqCnfObj);
	mainqCnfObj = NULL;
	free(cnfparamvals);
	cnfparamvals = NULL;
}
int
bs_arrcmp_glblDbgFiles(const void *s1, const void *s2)
{
	return strcmp((char*)s1, *(char**)s2);
}
void
glblProcessCnf(struct cnfobj *o)
{
	int i;
	cnfparamvals = nvlstGetParams(o-&gt;nvlst, &amp;paramblk, cnfparamvals);
	if(cnfparamvals == NULL) {
<a name="2"></a>		LogError(0, RS_RET_MISSING_CNFPARAMS, "error processing global "
				"config parameters [global(...)]");
		goto done;
<font color="#980517"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>	}
	if(Debug) {
		dbgprintf("glbl param blk after glblProcessCnf:\n");
		cnfparamsPrint(&amp;paramblk, cnfparamvals);
	}
	for(i = 0 ; i &lt; paramblk.nParams ; ++i) {
		if(!cnfparamvals[i].bUsed)
			continue;
		if(!strcmp(paramblk.descr[i].name, "processinternalmessages")) {
			loadConf-&gt;globals.bProcessInternalMessages = (int) cnfparamvals[i].val.d.n;</b></font>
			cnfparamvals[i].bUsed = TRUE;
		} else if(!strcmp(paramblk.descr[i].name, "internal.developeronly.options")) {
			loadConf-&gt;globals.glblDevOptions = (uint64_t) cnfparamvals[i].val.d.n;
			cnfparamvals[i].bUsed = TRUE;
		} else if(!strcmp(paramblk.descr[i].name, "stdlog.channelspec")) {
#ifndef ENABLE_LIBLOGGING_STDLOG
			LogError(0, RS_RET_ERR, "rsyslog wasn't "
				"compiled with liblogging-stdlog support. "
				"The 'stdlog.channelspec' parameter "
				"is ignored. Note: the syslog API is used instead.\n");
#else
			loadConf-&gt;globals.stdlog_chanspec = (uchar*) es_str2cstr(cnfparamvals[i].val.d.estr, NULL);
			stdlog_close(loadConf-&gt;globals.stdlog_hdl);
			loadConf-&gt;globals.stdlog_hdl = stdlog_open("rsyslogd", 0, STDLOG_SYSLOG,
					(char*) loadConf-&gt;globals.stdlog_chanspec);
			cnfparamvals[i].bUsed = TRUE;
#endif
		} else if(!strcmp(paramblk.descr[i].name, "operatingstatefile")) {
			if(loadConf-&gt;globals.operatingStateFile != NULL) {
				LogError(errno, RS_RET_PARAM_ERROR,
					"error: operatingStateFile already set to '%s' - "
					"new value ignored", loadConf-&gt;globals.operatingStateFile);
			} else {
				loadConf-&gt;globals.operatingStateFile =
					(uchar*) es_str2cstr(cnfparamvals[i].val.d.estr, NULL);
				osf_open();
			}
		} else if(!strcmp(paramblk.descr[i].name, "security.abortonidresolutionfail")) {
			loadConf-&gt;globals.abortOnIDResolutionFail = (int) cnfparamvals[i].val.d.n;
			cnfparamvals[i].bUsed = TRUE;
		}
	}
done:	return;
}
void
glblProcessMainQCnf(struct cnfobj *o)
{
	if(mainqCnfObj == NULL) {
		mainqCnfObj = o;
	} else {
		LogError(0, RS_RET_ERR, "main_queue() object can only be specified "
				"once - all but first ignored\n");
	}
}
void
glblDestructMainqCnfObj(void)
{
	if (mainqCnfObj != NULL) {
		nvlstChkUnused(mainqCnfObj-&gt;nvlst);
		cnfobjDestruct(mainqCnfObj);
		mainqCnfObj = NULL;
	}
}
static int
qs_arrcmp_glblDbgFiles(const void *s1, const void *s2)
{
	return strcmp(*((char**)s1), *((char**)s2));
}
static rsRetVal
do_setenv(const char *const var)
{
	char varname[128];
	const char *val = var;
	size_t i;
	DEFiRet;
	for(i = 0 ; *val != '=' ; ++i, ++val) {
		if(i == sizeof(varname)-i) {
			parser_errmsg("environment variable name too long "
				"[max %zu chars] or malformed entry: '%s'",
				sizeof(varname)-1, var);
			ABORT_FINALIZE(RS_RET_ERR_SETENV);
		}
		if(*val == '\0') {
			parser_errmsg("environment variable entry is missing "
				"equal sign (for value): '%s'", var);
			ABORT_FINALIZE(RS_RET_ERR_SETENV);
		}
		varname[i] = *val;
	}
	varname[i] = '\0';
	++val;
	DBGPRINTF("do_setenv, var '%s', val '%s'\n", varname, val);
	if(setenv(varname, val, 1) != 0) {
		char errStr[1024];
		rs_strerror_r(errno, errStr, sizeof(errStr));
		parser_errmsg("error setting environment variable "
			"'%s' to '%s': %s", varname, val, errStr);
		ABORT_FINALIZE(RS_RET_ERR_SETENV);
	}
finalize_it:
	RETiRet;
}
rsRetVal
glblDoneLoadCnf(void)
{
	int i;
	unsigned char *cstr;
	DEFiRet;
	CHKiRet(objUse(net, CORE_COMPONENT));
	sortTimezones(loadConf);
	DBGPRINTF("Timezone information table (%d entries):\n", loadConf-&gt;timezones.ntzinfos);
	displayTimezones(loadConf);
	if(cnfparamvals == NULL)
		goto finalize_it;
	for(i = 0 ; i &lt; paramblk.nParams ; ++i) {
		if(!cnfparamvals[i].bUsed)
			continue;
		if(!strcmp(paramblk.descr[i].name, "workdirectory")) {
			cstr = (uchar*) es_str2cstr(cnfparamvals[i].val.d.estr, NULL);
			setWorkDir(NULL, cstr);
		} else if(!strcmp(paramblk.descr[i].name, "variables.casesensitive")) {
			const int val = (int) cnfparamvals[i].val.d.n;
			fjson_global_do_case_sensitive_comparison(val);
			DBGPRINTF("global/config: set case sensitive variables to %d\n",
				val);
		} else if(!strcmp(paramblk.descr[i].name, "localhostname")) {
			free(LocalHostNameOverride);
			LocalHostNameOverride = (uchar*)
				es_str2cstr(cnfparamvals[i].val.d.estr, NULL);
		} else if(!strcmp(paramblk.descr[i].name, "defaultnetstreamdriverkeyfile")) {
			cstr = (uchar*) es_str2cstr(cnfparamvals[i].val.d.estr, NULL);
			setDfltNetstrmDrvrKeyFile(NULL, cstr);
		} else if(!strcmp(paramblk.descr[i].name, "defaultnetstreamdrivercertfile")) {
			cstr = (uchar*) es_str2cstr(cnfparamvals[i].val.d.estr, NULL);
			setDfltNetstrmDrvrCertFile(NULL, cstr);
		} else if(!strcmp(paramblk.descr[i].name, "defaultnetstreamdrivercafile")) {
			cstr = (uchar*) es_str2cstr(cnfparamvals[i].val.d.estr, NULL);
			setDfltNetstrmDrvrCAF(NULL, cstr);
		} else if(!strcmp(paramblk.descr[i].name, "defaultnetstreamdriver")) {
			cstr = (uchar*) es_str2cstr(cnfparamvals[i].val.d.estr, NULL);
			setDfltNetstrmDrvr(NULL, cstr);
		} else if(!strcmp(paramblk.descr[i].name, "preservefqdn")) {
			bPreserveFQDN = (int) cnfparamvals[i].val.d.n;
		} else if(!strcmp(paramblk.descr[i].name,
				"dropmsgswithmaliciousdnsptrrecords")) {
			loadConf-&gt;globals.bDropMalPTRMsgs = (int) cnfparamvals[i].val.d.n;
		} else if(!strcmp(paramblk.descr[i].name, "action.reportsuspension")) {
			loadConf-&gt;globals.bActionReportSuspension = (int) cnfparamvals[i].val.d.n;
		} else if(!strcmp(paramblk.descr[i].name, "action.reportsuspensioncontinuation")) {
			loadConf-&gt;globals.bActionReportSuspensionCont = (int) cnfparamvals[i].val.d.n;
		} else if(!strcmp(paramblk.descr[i].name, "maxmessagesize")) {
			setMaxLine(cnfparamvals[i].val.d.n);
		} else if(!strcmp(paramblk.descr[i].name, "oversizemsg.errorfile")) {
			free(loadConf-&gt;globals.oversizeMsgErrorFile);
			loadConf-&gt;globals.oversizeMsgErrorFile = (uchar*)es_str2cstr(cnfparamvals[i].val.d.estr, NULL);
		} else if(!strcmp(paramblk.descr[i].name, "oversizemsg.report")) {
			loadConf-&gt;globals.reportOversizeMsg = (int) cnfparamvals[i].val.d.n;
		} else if(!strcmp(paramblk.descr[i].name, "oversizemsg.input.mode")) {
			const char *const tmp = es_str2cstr(cnfparamvals[i].val.d.estr, NULL);
			setOversizeMsgInputMode((uchar*) tmp);
			free((void*)tmp);
		} else if(!strcmp(paramblk.descr[i].name, "reportchildprocessexits")) {
			const char *const tmp = es_str2cstr(cnfparamvals[i].val.d.estr, NULL);
			setReportChildProcessExits((uchar*) tmp);
			free((void*)tmp);
		} else if(!strcmp(paramblk.descr[i].name, "debug.onshutdown")) {
			loadConf-&gt;globals.debugOnShutdown = (int) cnfparamvals[i].val.d.n;
			LogError(0, RS_RET_OK, "debug: onShutdown set to %d", loadConf-&gt;globals.debugOnShutdown);
		} else if(!strcmp(paramblk.descr[i].name, "debug.gnutls")) {
			loadConf-&gt;globals.iGnuTLSLoglevel = (int) cnfparamvals[i].val.d.n;
		} else if(!strcmp(paramblk.descr[i].name, "debug.unloadmodules")) {
			glblUnloadModules = (int) cnfparamvals[i].val.d.n;
		} else if(!strcmp(paramblk.descr[i].name, "parser.controlcharacterescapeprefix")) {
			uchar* tmp = (uchar*) es_str2cstr(cnfparamvals[i].val.d.estr, NULL);
			setParserControlCharacterEscapePrefix(NULL, tmp);
			free(tmp);
		} else if(!strcmp(paramblk.descr[i].name, "parser.droptrailinglfonreception")) {
			const int tmp = (int) cnfparamvals[i].val.d.n;
			setParserDropTrailingLFOnReception(NULL, tmp);
		} else if(!strcmp(paramblk.descr[i].name, "parser.escapecontrolcharactersonreceive")) {
			const int tmp = (int) cnfparamvals[i].val.d.n;
			setParserEscapeControlCharactersOnReceive(NULL, tmp);
		} else if(!strcmp(paramblk.descr[i].name, "parser.spacelfonreceive")) {
			const int tmp = (int) cnfparamvals[i].val.d.n;
			setParserSpaceLFOnReceive(NULL, tmp);
		} else if(!strcmp(paramblk.descr[i].name, "parser.escape8bitcharactersonreceive")) {
			const int tmp = (int) cnfparamvals[i].val.d.n;
			setParserEscape8BitCharactersOnReceive(NULL, tmp);
		} else if(!strcmp(paramblk.descr[i].name, "parser.escapecontrolcharactertab")) {
			const int tmp = (int) cnfparamvals[i].val.d.n;
			setParserEscapeControlCharacterTab(NULL, tmp);
		} else if(!strcmp(paramblk.descr[i].name, "parser.escapecontrolcharacterscstyle")) {
			const int tmp = (int) cnfparamvals[i].val.d.n;
			SetParserEscapeControlCharactersCStyle(tmp);
		} else if(!strcmp(paramblk.descr[i].name, "parser.parsehostnameandtag")) {
			const int tmp = (int) cnfparamvals[i].val.d.n;
			SetParseHOSTNAMEandTAG(tmp);
		} else if(!strcmp(paramblk.descr[i].name, "parser.permitslashinprogramname")) {
			loadConf-&gt;globals.parser.bPermitSlashInProgramname = (int) cnfparamvals[i].val.d.n;
		} else if(!strcmp(paramblk.descr[i].name, "debug.logfile")) {
			if(pszAltDbgFileName == NULL) {
				pszAltDbgFileName = es_str2cstr(cnfparamvals[i].val.d.estr, NULL);
				if(altdbg != -1) {
					close(altdbg);
				}
				if((altdbg = open(pszAltDbgFileName, O_WRONLY|O_CREAT|O_TRUNC|O_NOCTTY
				|O_CLOEXEC, S_IRUSR|S_IWUSR)) == -1) {
					LogError(0, RS_RET_ERR, "debug log file '%s' could not be opened",
							pszAltDbgFileName);
				}
			}
<a name="1"></a>			LogError(0, RS_RET_OK, "debug log file is '%s', fd %d", pszAltDbgFileName, altdbg);
		} else if(!strcmp(paramblk.descr[i].name, "janitor.interval")) {
			loadConf-&gt;globals.janitorInterval = (int) cnfparamvals[i].val.d.n;
<font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>		} else if(!strcmp(paramblk.descr[i].name, "net.ipprotocol")) {
			char *proto = es_str2cstr(cnfparamvals[i].val.d.estr, NULL);
			if(!strcmp(proto, "unspecified")) {
				loadConf-&gt;globals.iDefPFFamily = PF_UNSPEC;
			} else if(!strcmp(proto, "ipv4-only")) {
				loadConf-&gt;globals.iDefPFFamily = PF_INET;
			} else if(!strcmp(proto, "ipv6-only")) {
				loadConf-&gt;globals.iDefPFFamily = PF_INET6;
			} else{</b></font>
				LogError(0, RS_RET_ERR, "invalid net.ipprotocol "
					"parameter '%s' -- ignored", proto);
			}
			free(proto);
		} else if(!strcmp(paramblk.descr[i].name, "senders.reportnew")) {
			loadConf-&gt;globals.reportNewSenders = (int) cnfparamvals[i].val.d.n;
		} else if(!strcmp(paramblk.descr[i].name, "senders.reportgoneaway")) {
			loadConf-&gt;globals.reportGoneAwaySenders = (int) cnfparamvals[i].val.d.n;
		} else if(!strcmp(paramblk.descr[i].name, "senders.timeoutafter")) {
			loadConf-&gt;globals.senderStatsTimeout = (int) cnfparamvals[i].val.d.n;
		} else if(!strcmp(paramblk.descr[i].name, "senders.keeptrack")) {
			loadConf-&gt;globals.senderKeepTrack = (int) cnfparamvals[i].val.d.n;
		} else if(!strcmp(paramblk.descr[i].name, "inputs.timeout.shutdown")) {
			loadConf-&gt;globals.inputTimeoutShutdown = (int) cnfparamvals[i].val.d.n;
		} else if(!strcmp(paramblk.descr[i].name, "privdrop.group.keepsupplemental")) {
			loadConf-&gt;globals.gidDropPrivKeepSupplemental = (int) cnfparamvals[i].val.d.n;
		} else if(!strcmp(paramblk.descr[i].name, "privdrop.group.id")) {
			loadConf-&gt;globals.gidDropPriv = (int) cnfparamvals[i].val.d.n;
		} else if(!strcmp(paramblk.descr[i].name, "privdrop.group.name")) {
			loadConf-&gt;globals.gidDropPriv = (int) cnfparamvals[i].val.d.n;
		} else if(!strcmp(paramblk.descr[i].name, "privdrop.user.id")) {
			loadConf-&gt;globals.uidDropPriv = (int) cnfparamvals[i].val.d.n;
		} else if(!strcmp(paramblk.descr[i].name, "privdrop.user.name")) {
			loadConf-&gt;globals.uidDropPriv = (int) cnfparamvals[i].val.d.n;
		} else if(!strcmp(paramblk.descr[i].name, "security.abortonidresolutionfail")) {
			loadConf-&gt;globals.abortOnIDResolutionFail = (int) cnfparamvals[i].val.d.n;
		} else if(!strcmp(paramblk.descr[i].name, "net.acladdhostnameonfail")) {
			loadConf-&gt;globals.ACLAddHostnameOnFail = (int) cnfparamvals[i].val.d.n;
		} else if(!strcmp(paramblk.descr[i].name, "net.aclresolvehostname")) {
			loadConf-&gt;globals.ACLDontResolve = !((int) cnfparamvals[i].val.d.n);
		} else if(!strcmp(paramblk.descr[i].name, "net.enabledns")) {
			SetDisableDNS(!((int) cnfparamvals[i].val.d.n));
		} else if(!strcmp(paramblk.descr[i].name, "net.permitwarning")) {
			SetOptionDisallowWarning(!((int) cnfparamvals[i].val.d.n));
		} else if(!strcmp(paramblk.descr[i].name, "abortonuncleanconfig")) {
			loadConf-&gt;globals.bAbortOnUncleanConfig = cnfparamvals[i].val.d.n;
		} else if(!strcmp(paramblk.descr[i].name, "internalmsg.ratelimit.burst")) {
			loadConf-&gt;globals.intMsgRateLimitBurst = (int) cnfparamvals[i].val.d.n;
		} else if(!strcmp(paramblk.descr[i].name, "internalmsg.ratelimit.interval")) {
			loadConf-&gt;globals.intMsgRateLimitItv = (int) cnfparamvals[i].val.d.n;
		} else if(!strcmp(paramblk.descr[i].name, "internalmsg.severity")) {
			loadConf-&gt;globals.intMsgsSeverityFilter = (int) cnfparamvals[i].val.d.n;
			if((loadConf-&gt;globals.intMsgsSeverityFilter &lt; 0) ||
			(loadConf-&gt;globals.intMsgsSeverityFilter &gt; 7)) {
				parser_errmsg("invalid internalmsg.severity value");
				loadConf-&gt;globals.intMsgsSeverityFilter = DFLT_INT_MSGS_SEV_FILTER;
			}
		} else if(!strcmp(paramblk.descr[i].name, "environment")) {
			for(int j = 0 ; j &lt;  cnfparamvals[i].val.d.ar-&gt;nmemb ; ++j) {
				char *const var = es_str2cstr(cnfparamvals[i].val.d.ar-&gt;arr[j], NULL);
				do_setenv(var);
				free(var);
			}
		} else if(!strcmp(paramblk.descr[i].name, "errormessagestostderr.maxnumber")) {
			loadConf-&gt;globals.maxErrMsgToStderr = (int) cnfparamvals[i].val.d.n;
		} else if(!strcmp(paramblk.descr[i].name, "debug.files")) {
			free(glblDbgFiles); 			glblDbgFilesNum = cnfparamvals[i].val.d.ar-&gt;nmemb;
			glblDbgFiles = (char**) malloc(cnfparamvals[i].val.d.ar-&gt;nmemb * sizeof(char*));
			for(int j = 0 ; j &lt;  cnfparamvals[i].val.d.ar-&gt;nmemb ; ++j) {
				glblDbgFiles[j] = es_str2cstr(cnfparamvals[i].val.d.ar-&gt;arr[j], NULL);
			}
			qsort(glblDbgFiles, glblDbgFilesNum, sizeof(char*), qs_arrcmp_glblDbgFiles);
		} else if(!strcmp(paramblk.descr[i].name, "debug.whitelist")) {
			glblDbgWhitelist = (int) cnfparamvals[i].val.d.n;
		} else if(!strcmp(paramblk.descr[i].name, "shutdown.queue.doublesize")) {
			loadConf-&gt;globals.shutdownQueueDoubleSize = (int) cnfparamvals[i].val.d.n;
		} else if(!strcmp(paramblk.descr[i].name, "umask")) {
			loadConf-&gt;globals.umask = (int) cnfparamvals[i].val.d.n;
		} else if(!strcmp(paramblk.descr[i].name, "shutdown.enable.ctlc")) {
			loadConf-&gt;globals.permitCtlC = (int) cnfparamvals[i].val.d.n;
		} else if(!strcmp(paramblk.descr[i].name, "default.action.queue.timeoutshutdown")) {
			loadConf-&gt;globals.actq_dflt_toQShutdown = cnfparamvals[i].val.d.n;
		} else if(!strcmp(paramblk.descr[i].name, "default.action.queue.timeoutactioncompletion")) {
			loadConf-&gt;globals.actq_dflt_toActShutdown = cnfparamvals[i].val.d.n;
		} else if(!strcmp(paramblk.descr[i].name, "default.action.queue.timeoutenqueue")) {
			loadConf-&gt;globals.actq_dflt_toEnq = cnfparamvals[i].val.d.n;
		} else if(!strcmp(paramblk.descr[i].name, "default.action.queue.timeoutworkerthreadshutdown")) {
			loadConf-&gt;globals.actq_dflt_toWrkShutdown = cnfparamvals[i].val.d.n;
		} else if(!strcmp(paramblk.descr[i].name, "default.ruleset.queue.timeoutshutdown")) {
			loadConf-&gt;globals.ruleset_dflt_toQShutdown = cnfparamvals[i].val.d.n;
		} else if(!strcmp(paramblk.descr[i].name, "default.ruleset.queue.timeoutactioncompletion")) {
			loadConf-&gt;globals.ruleset_dflt_toActShutdown = cnfparamvals[i].val.d.n;
		} else if(!strcmp(paramblk.descr[i].name, "default.ruleset.queue.timeoutenqueue")) {
			loadConf-&gt;globals.ruleset_dflt_toEnq = cnfparamvals[i].val.d.n;
		} else if(!strcmp(paramblk.descr[i].name, "default.ruleset.queue.timeoutworkerthreadshutdown")) {
			loadConf-&gt;globals.ruleset_dflt_toWrkShutdown = cnfparamvals[i].val.d.n;
		} else if(!strcmp(paramblk.descr[i].name, "reverselookup.cache.ttl.default")) {
			loadConf-&gt;globals.dnscacheDefaultTTL = cnfparamvals[i].val.d.n;
		} else if(!strcmp(paramblk.descr[i].name, "reverselookup.cache.ttl.enable")) {
			loadConf-&gt;globals.dnscacheEnableTTL = cnfparamvals[i].val.d.n;
		} else if(!strcmp(paramblk.descr[i].name, "parser.supportcompressionextension")) {
			loadConf-&gt;globals.bSupportCompressionExtension = cnfparamvals[i].val.d.n;
		} else {
			dbgprintf("glblDoneLoadCnf: program error, non-handled "
				"param '%s'\n", paramblk.descr[i].name);
		}
	}
	if(loadConf-&gt;globals.debugOnShutdown &amp;&amp; Debug != DEBUG_FULL) {
		Debug = DEBUG_ONDEMAND;
		stddbg = -1;
	}
finalize_it:	RETiRet;
}
BEGINAbstractObjClassInit(glbl, 1, OBJ_IS_CORE_MODULE) 	CHKiRet(objUse(prop, CORE_COMPONENT));
	storeLocalHostIPIF((uchar*)"127.0.0.1");
	CHKiRet(regCfSysLineHdlr((uchar *)"debugfile", 0, eCmdHdlrGetWord, setDebugFile, NULL, NULL));
	CHKiRet(regCfSysLineHdlr((uchar *)"debuglevel", 0, eCmdHdlrInt, setDebugLevel, NULL, NULL));
	CHKiRet(regCfSysLineHdlr((uchar *)"workdirectory", 0, eCmdHdlrGetWord, setWorkDir, NULL, NULL));
	CHKiRet(regCfSysLineHdlr((uchar *)"dropmsgswithmaliciousdnsptrrecords", 0, eCmdHdlrBinary, SetDropMalPTRMsgs,
	NULL, NULL));
	CHKiRet(regCfSysLineHdlr((uchar *)"defaultnetstreamdriver", 0, eCmdHdlrGetWord, setDfltNetstrmDrvr, NULL,
	NULL));
	CHKiRet(regCfSysLineHdlr((uchar *)"defaultnetstreamdrivercafile", 0, eCmdHdlrGetWord,
	setDfltNetstrmDrvrCAF, NULL, NULL));
	CHKiRet(regCfSysLineHdlr((uchar *)"defaultnetstreamdriverkeyfile", 0, eCmdHdlrGetWord,
	setDfltNetstrmDrvrKeyFile, NULL, NULL));
	CHKiRet(regCfSysLineHdlr((uchar *)"defaultnetstreamdrivercertfile", 0, eCmdHdlrGetWord,
	setDfltNetstrmDrvrCertFile, NULL, NULL));
	CHKiRet(regCfSysLineHdlr((uchar *)"localhostname", 0, eCmdHdlrGetWord, NULL, &amp;LocalHostNameOverride, NULL));
	CHKiRet(regCfSysLineHdlr((uchar *)"localhostipif", 0, eCmdHdlrGetWord, setLocalHostIPIF, NULL, NULL));
	CHKiRet(regCfSysLineHdlr((uchar *)"optimizeforuniprocessor", 0, eCmdHdlrGoneAway, NULL, NULL, NULL));
	CHKiRet(regCfSysLineHdlr((uchar *)"preservefqdn", 0, eCmdHdlrBinary, NULL, &amp;bPreserveFQDN, NULL));
	CHKiRet(regCfSysLineHdlr((uchar *)"maxmessagesize", 0, eCmdHdlrSize, legacySetMaxMessageSize, NULL, NULL));
	CHKiRet(regCfSysLineHdlr((uchar *)"controlcharacterescapeprefix", 0, eCmdHdlrGetChar,
	setParserControlCharacterEscapePrefix, NULL, NULL));
	CHKiRet(regCfSysLineHdlr((uchar *)"droptrailinglfonreception", 0, eCmdHdlrBinary,
	setParserDropTrailingLFOnReception, NULL, NULL));
	CHKiRet(regCfSysLineHdlr((uchar *)"escapecontrolcharactersonreceive", 0, eCmdHdlrBinary,
	setParserEscapeControlCharactersOnReceive, NULL, NULL));
	CHKiRet(regCfSysLineHdlr((uchar *)"spacelfonreceive", 0, eCmdHdlrBinary,
	setParserSpaceLFOnReceive, NULL, NULL));
	CHKiRet(regCfSysLineHdlr((uchar *)"escape8bitcharactersonreceive", 0, eCmdHdlrBinary,
	setParserEscape8BitCharactersOnReceive,	NULL, NULL));
	CHKiRet(regCfSysLineHdlr((uchar *)"escapecontrolcharactertab", 0, eCmdHdlrBinary,
	setParserEscapeControlCharacterTab, NULL, NULL));
	CHKiRet(regCfSysLineHdlr((uchar *)"resetconfigvariables", 1, eCmdHdlrCustomHandler,
	resetConfigVariables, NULL, NULL));
	INIT_ATOMIC_HELPER_MUT(mutTerminateInputs);
ENDObjClassInit(glbl)
BEGINObjClassExit(glbl, OBJ_IS_CORE_MODULE) 	free(LocalDomain);
	free(LocalHostName);
	free(LocalHostNameOverride);
	free(LocalFQDNName);
	objRelease(prop, CORE_COMPONENT);
	if(propLocalHostNameToDelete != NULL)
		prop.Destruct(&amp;propLocalHostNameToDelete);
	DESTROY_ATOMIC_HELPER_MUT(mutTerminateInputs);
ENDObjClassExit(glbl)
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
