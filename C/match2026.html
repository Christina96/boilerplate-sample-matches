<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for mmdarwin.c &amp; glbl.c</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for mmdarwin.c &amp; glbl.c
      </h3>
<h1 align="center">
        5.7%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>mmdarwin.c (9.320695%)<th>glbl.c (4.1520057%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(121-140)<td><a href="#" name="0">(172-186)</a><td align="center"><font color="#ff0000">24</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(697-717)<td><a href="#" name="1">(1245-1253)</a><td align="center"><font color="#e90000">22</font>
<tr onclick='openModal("#980517")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#980517"><font color="#980517">-</font><td><a href="#" name="2">(596-609)<td><a href="#" name="2">(1000-1014)</a><td align="center"><font color="#8a0000">13</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>mmdarwin.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 #include "config.h"
2 #include "rsyslog.h"
3 #include &lt;stdio.h&gt;
4 #include &lt;stdarg.h&gt;
5 #include &lt;stdlib.h&gt;
6 #include &lt;string.h&gt;
7 #include &lt;assert.h&gt;
8 #include &lt;signal.h&gt;
9 #include &lt;errno.h&gt;
10 #include &lt;unistd.h&gt;
11 #include &lt;stdint.h&gt;
12 #include &lt;pthread.h&gt;
13 #include "conf.h"
14 #include "syslogd-types.h"
15 #include "srUtils.h"
16 #include "template.h"
17 #include "module-template.h"
18 #include "errmsg.h"
19 #include "parserif.h"
20 #include &lt;stdio.h&gt;
21 #include &lt;stdlib.h&gt;
22 #include &lt;string.h&gt;
23 #include &lt;sys/un.h&gt;
24 #include &lt;sys/socket.h&gt;
25 #include &lt;uuid/uuid.h&gt;
26 #include &lt;json.h&gt;
27 #include "protocol.h" 
28 #define JSON_DEFAULT_CONTAINER "!mmdarwin"
29 #define JSON_DARWIN_ID "darwin_id"
30 #define INVLD_SOCK -1
31 #define INITIAL_BUFFER_SIZE 32
32 #define BUFFER_DEFAULT_MAX_SIZE 65536
33 MODULE_TYPE_OUTPUT
34 MODULE_TYPE_NOKEEP
35 MODULE_CNFNAME("mmdarwin")
36 DEFobjCurrIf(glbl)
37 DEF_OMOD_STATIC_DATA
38 typedef struct dyn_buffer_t
39 {
40 	char *buffer;
41 	size_t bufferAllocSize;
42 	size_t bufferMsgSize;
43 	size_t bufferMaxSize;
44 } dyn_buffer;
45 typedef struct _instanceData
46 {
47 	enum darwin_filter_response_type response;		struct
48 	{
49 		int nmemb;
50 		char **name;
51 		char **varname;
52 	} fieldList; 	unsigned int socketMaxUse;
53 	sbool sendPartial;
54 } instanceData;
55 typedef struct wrkrInstanceData
56 {
57 	instanceData *pData;
58 	int sock;				 	struct sockaddr_un addr; 	uint8_t pktSentSocket;
59 	dyn_buffer darwinBody; 	dyn_buffer fieldBuffer;
60 } wrkrInstanceData_t;
61 struct modConfData_s
62 {
63 	rsconf_t *pConf;
64 	const char *container;
65 };
66 static modConfData_t *loadModConf = NULL;
67 static modConfData_t *runModConf = NULL;
68 static struct cnfparamdescr modpdescr[] = {
69 	{"container", eCmdHdlrGetWord, 0},
70 };
71 static struct cnfparamblk modpblk =
72 	{CNFPARAMBLK_VERSION,
73 	 sizeof(modpdescr) / sizeof(struct cnfparamdescr),
74 	 modpdescr};
75 static struct cnfparamdescr actpdescr[] = {
76 <font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>	{"key", eCmdHdlrGetWord, CNFPARAM_REQUIRED},
77 	{"socketpath", eCmdHdlrGetWord, CNFPARAM_REQUIRED},
78 	{"fields", eCmdHdlrArray, CNFPARAM_REQUIRED},
79 	{"filtercode", eCmdHdlrGetWord, 0},				{"response", eCmdHdlrGetWord, 0},				{"send_partial", eCmdHdlrBinary, 0},			{"socket_max_use", eCmdHdlrNonNegInt, 0}, };
80 static struct cnfparamblk actpblk = {
81 	CNFPARAMBLK_VERSION,
82 	sizeof(actpdescr) / sizeof(struct cnfparamdescr),
83 	actpdescr};
84 #define min(a, b) \
85 	({ __typeof__ (a) _a = (a); \
86 	__typeof__ (b) _b = (b); \
87 	_a &lt; _b ? _a : _b; })
88 static rsRetVal openSocket(wrkrInstanceData_t *pWrkrData);</b></font>
89 static rsRetVal closeSocket(wrkrInstanceData_t *pWrkrData);
90 static rsRetVal doTryResume(wrkrInstanceData_t *pWrkrData);
91 static rsRetVal sendMsg(wrkrInstanceData_t *pWrkrData, void *msg, size_t len);
92 static rsRetVal receiveMsg(wrkrInstanceData_t *pWrkrData, void *response, size_t len);
93 const char* get_uuid_object(smsg_t *const pMsg);
94 int get_field(smsg_t *const pMsg, const char *pFieldName, char **ppRetString);
95 int expand_buffer(dyn_buffer *pBody, size_t new_size);
96 int add_field_to_body(dyn_buffer *pBody, const char *field, size_t size);
97 int start_new_line(dyn_buffer *pBody);
98 int end_body(dyn_buffer *pBody);
99 static rsRetVal openSocket(wrkrInstanceData_t *pWrkrData)
100 {
101 	DEFiRet;
102 	assert(pWrkrData-&gt;sock == INVLD_SOCK);
103 	if ((pWrkrData-&gt;sock = socket(AF_UNIX, SOCK_STREAM, 0)) == -1)
104 	{
105 		char errStr[1024];
106 		int eno = errno;
107 		DBGPRINTF("mmdarwin::openSocket:: error %d creating AF_UNIX/SOCK_STREAM: %s.\n",
108 				  eno, rs_strerror_r(eno, errStr, sizeof(errStr)));
109 		pWrkrData-&gt;sock = INVLD_SOCK;
110 		ABORT_FINALIZE(RS_RET_NO_SOCKET);
111 	}
112 	memset(&amp;pWrkrData-&gt;addr, 0, sizeof(struct sockaddr_un));
113 	pWrkrData-&gt;addr.sun_family = AF_UNIX;
114 	strncpy(pWrkrData-&gt;addr.sun_path, (char *)pWrkrData-&gt;pData-&gt;pSockName, sizeof(pWrkrData-&gt;addr.sun_path) - 1);
115 	DBGPRINTF("mmdarwin::openSocket:: connecting to Darwin...\n");
116 	if (connect(pWrkrData-&gt;sock, (struct sockaddr *)&amp;pWrkrData-&gt;addr, sizeof(struct sockaddr_un)) == -1)
117 	{
118 		LogError(errno, RS_RET_NO_SOCKET, "mmdarwin::openSocket:: error connecting to Darwin "
119 										  "via socket '%s'",
120 				 pWrkrData-&gt;pData-&gt;pSockName);
121 		pWrkrData-&gt;sock = INVLD_SOCK;
122 		ABORT_FINALIZE(RS_RET_NO_SOCKET);
123 	}
124 	DBGPRINTF("mmdarwin::openSocket:: connected !\n");
125 finalize_it:
126 	if (iRet != RS_RET_OK)
127 	{
128 		closeSocket(pWrkrData);
129 	}
130 	RETiRet;
131 }
132 static rsRetVal closeSocket(wrkrInstanceData_t *pWrkrData)
133 {
134 	DEFiRet;
135 	if (pWrkrData-&gt;sock != INVLD_SOCK)
136 	{
137 		if (close(pWrkrData-&gt;sock) != 0)
138 		{
139 			char errStr[1024];
140 			int eno = errno;
141 			DBGPRINTF("mmdarwin::closeSocket:: error %d closing the socket: %s.\n",
142 					  eno, rs_strerror_r(eno, errStr, sizeof(errStr)));
143 		}
144 		pWrkrData-&gt;sock = INVLD_SOCK;
145 	}
146 	RETiRet;
147 }
148 static rsRetVal doTryResume(wrkrInstanceData_t *pWrkrData)
149 {
150 	DEFiRet;
151 	DBGPRINTF("mmdarwin::doTryResume:: trying to resume\n");
152 	closeSocket(pWrkrData);
153 	iRet = openSocket(pWrkrData);
154 	if (iRet != RS_RET_OK)
155 	{
156 		iRet = RS_RET_SUSPENDED;
157 	}
158 	RETiRet;
159 }
160 static rsRetVal sendMsg(wrkrInstanceData_t *pWrkrData, void *msg, size_t len)
161 {
162 	DEFiRet;
163 	DBGPRINTF("mmdarwin::sendMsg:: sending message to Darwin...\n");
164 	if (pWrkrData-&gt;sock == INVLD_SOCK)
165 	{
166 		CHKiRet(doTryResume(pWrkrData));
167 	}
168 	if (pWrkrData-&gt;sock != INVLD_SOCK)
169 	{
170 		if (send(pWrkrData-&gt;sock, msg, len, 0) == -1)
171 		{
172 			char errStr[1024];
173 			DBGPRINTF("mmdarwin::sendData:: error while sending data: error[%d] -&gt; %s\n",
174 					  errno, rs_strerror_r(errno, errStr, sizeof(errStr)));
175 			iRet = RS_RET_SUSPENDED;
176 		}
177 	}
178 finalize_it:
179 	RETiRet;
180 }
181 static rsRetVal receiveMsg(wrkrInstanceData_t *pWrkrData, void *response, size_t len)
182 {
183 	DEFiRet;
184 	DBGPRINTF("mmdarwin::receiveMsg:: receiving message from Darwin...\n");
185 	if (pWrkrData-&gt;sock == INVLD_SOCK)
186 	{
187 		CHKiRet(doTryResume(pWrkrData));
188 	}
189 	if (pWrkrData-&gt;sock != INVLD_SOCK)
190 	{
191 		if (recv(pWrkrData-&gt;sock, response, len, MSG_WAITALL) &lt;= 0)
192 		{
193 			char errStr[1024];
194 			DBGPRINTF("mmdarwin::receiveMsg:: error while receiving data: error[%d] -&gt; %s\n",
195 					  errno, rs_strerror_r(errno, errStr, sizeof(errStr)));
196 			iRet = RS_RET_NONE;
197 		}
198 	}
199 finalize_it:
200 	RETiRet;
201 }
202 int get_field(smsg_t *const pMsg, const char *pFieldName, char **ppRetString)
203 {
204 	DBGPRINTF("mmdarwin::get_field:: getting key '%s' in msg\n", pFieldName);
205 	struct json_object *pJson = NULL;
206 	char *pFieldString = NULL;
207 	int retVal = 0;
208 	msgPropDescr_t propDesc;
209 	msgPropDescrFill(&amp;propDesc, (uchar *)pFieldName, strlen(pFieldName));
210 	msgGetJSONPropJSONorString(pMsg, &amp;propDesc, &amp;pJson, (uchar **)&amp;pFieldString);
211 	if (pFieldString)
212 	{
213 		*ppRetString = pFieldString;
214 		DBGPRINTF("mmdarwin::get_field:: got string\n");
215 		retVal = 1;
216 	}
217 	else if (pJson)
218 	{
219 		pFieldString = (char *)json_object_get_string(pJson);
220 		if (pFieldString)
221 		{
222 			*ppRetString = strdup(pFieldString);
223 			retVal = 1;
224 			DBGPRINTF("mmdarwin::get_field:: got string from json\n");
225 			json_object_put(pJson);
226 		}
227 	}
228 	msgPropDescrDestruct(&amp;propDesc);
229 	return retVal;
230 }
231 int expand_buffer(dyn_buffer *pBody, size_t new_size)
232 {
233 	if (new_size &gt; pBody-&gt;bufferMaxSize)
234 		return -1;
235 	while (pBody-&gt;bufferAllocSize &lt; new_size)
236 		pBody-&gt;bufferAllocSize += INITIAL_BUFFER_SIZE;
237 	DBGPRINTF("mmdarwin::expand_buffer:: expanding buffer to %zu\n", pBody-&gt;bufferAllocSize);
238 	char *tmp = realloc(pBody-&gt;buffer, pBody-&gt;bufferAllocSize * sizeof(char));
239 	if (!tmp)
240 	{
241 		DBGPRINTF("mmdarwin::expand_buffer:: could not resize buffer\n");
242 		return -1;
243 	}
244 	pBody-&gt;buffer = tmp;
245 	return 0;
246 }
247 int add_field_to_body(dyn_buffer *pBody, const char *field, size_t size)
248 {
249 	int beginning = (pBody-&gt;bufferMsgSize == 0) ? 2 : 0;
250 	size_t requiredBodySize = pBody-&gt;bufferMsgSize + size + 4 + beginning;
251 	if (requiredBodySize &gt; pBody-&gt;bufferAllocSize)
252 	{
253 		if (expand_buffer(pBody, requiredBodySize) != 0)
254 		{
255 			return -1;
256 		}
257 	}
258 	if (!pBody-&gt;bufferMsgSize)
259 	{
260 		pBody-&gt;buffer[0] = '[';
261 		pBody-&gt;buffer[1] = '[';
262 		pBody-&gt;bufferMsgSize += 2;
263 	}
264 	pBody-&gt;buffer[pBody-&gt;bufferMsgSize++] = '\"';
265 	memcpy((void *)&amp;pBody-&gt;buffer[pBody-&gt;bufferMsgSize], (const void *)field, size);
266 	pBody-&gt;bufferMsgSize += size;
267 	pBody-&gt;buffer[pBody-&gt;bufferMsgSize++] = '\"';
268 	pBody-&gt;buffer[pBody-&gt;bufferMsgSize++] = ',';
269 	return 0;
270 }
271 int start_new_line(dyn_buffer *pBody)
272 {
273 	if (!pBody-&gt;bufferMsgSize)
274 	{
275 		return -1;
276 	}
277 	DBGPRINTF("mmdarwin::start_new_line:: starting new line entry in body\n");
278 	if (pBody-&gt;bufferAllocSize &lt; pBody-&gt;bufferMsgSize + 2)
279 	{
280 		if (expand_buffer(pBody, pBody-&gt;bufferAllocSize + 2) != 0)
281 		{
282 			return -1;
283 		}
284 	}
285 	pBody-&gt;buffer[pBody-&gt;bufferMsgSize - 1] = ']';
286 	pBody-&gt;buffer[pBody-&gt;bufferMsgSize++] = ',';
287 	pBody-&gt;buffer[pBody-&gt;bufferMsgSize++] = '[';
288 	return 0;
289 }
290 int end_body(dyn_buffer *pBody)
291 {
292 	if (!pBody-&gt;bufferMsgSize)
293 	{
294 		return -1;
295 	}
296 	DBGPRINTF("mmdarwin::end_body:: finishing body structure\n");
297 	if (pBody-&gt;bufferAllocSize &lt; pBody-&gt;bufferMsgSize + 2)
298 	{
299 		if (expand_buffer(pBody, pBody-&gt;bufferAllocSize + 2) != 0)
300 		{
301 			return -1;
302 		}
303 	}
304 	pBody-&gt;buffer[pBody-&gt;bufferMsgSize - 1] = ']';
305 	pBody-&gt;buffer[pBody-&gt;bufferMsgSize++] = ']';
306 	pBody-&gt;buffer[pBody-&gt;bufferMsgSize++] = '\0';
307 	return 0;
308 }
309 const char* get_uuid_object(smsg_t *const pMsg) {
310 	struct json_object *mmdarwin_object = NULL;
311 	const char *result = NULL, *key = NULL;
312 	msgPropDescr_t propDesc;
313 	msgPropDescrFill(&amp;propDesc, (uchar *)runModConf-&gt;container, strlen(runModConf-&gt;container));
314 	msgGetJSONPropJSON(pMsg, &amp;propDesc, &amp;mmdarwin_object);
315 	if(mmdarwin_object) {
316 		struct json_object_iterator it = json_object_iter_begin(mmdarwin_object);
317 		struct json_object_iterator itEnd = json_object_iter_end(mmdarwin_object);
318 		while(!json_object_iter_equal(&amp;it, &amp;itEnd)) {
319 			key = json_object_iter_peek_name(&amp;it);
320 			if(!strcmp(key, JSON_DARWIN_ID)) {
321 				result = strdup(json_object_get_string(json_object_iter_peek_value(&amp;it)));
322 				break;
323 			}
324 			json_object_iter_next(&amp;it);
325 		}
326 		json_object_put(mmdarwin_object);
327 	}
328 	msgPropDescrDestruct(&amp;propDesc);
329 	return result;
330 }
331 BEGINbeginCnfLoad
332 CODESTARTbeginCnfLoad
333 	loadModConf = pModConf;
334 pModConf-&gt;pConf = pConf;
335 ENDbeginCnfLoad
336 BEGINendCnfLoad
337 CODESTARTendCnfLoad
338 ENDendCnfLoad
339 BEGINcheckCnf
340 CODESTARTcheckCnf
341 ENDcheckCnf
342 BEGINactivateCnf
343 CODESTARTactivateCnf
344 	runModConf = pModConf;
345 ENDactivateCnf
346 BEGINfreeCnf
347 CODESTARTfreeCnf
348 	free((void *)pModConf-&gt;container);
349 ENDfreeCnf
350 BEGINdbgPrintInstInfo
351 CODESTARTdbgPrintInstInfo
352 	DBGPRINTF("%s\n", pData-&gt;pSockName);
353 ENDdbgPrintInstInfo
354 BEGINcreateInstance
355 CODESTARTcreateInstance
356 ENDcreateInstance
357 BEGINcreateWrkrInstance
358 CODESTARTcreateWrkrInstance
359 	pWrkrData-&gt;pktSentSocket = 0;
360 	pWrkrData-&gt;darwinBody.bufferAllocSize = 0;
361 	pWrkrData-&gt;darwinBody.bufferMaxSize = BUFFER_DEFAULT_MAX_SIZE;
362 	pWrkrData-&gt;darwinBody.bufferMsgSize = 0;
363 	pWrkrData-&gt;sock = INVLD_SOCK;
364 ENDcreateWrkrInstance
365 BEGINisCompatibleWithFeature
366 CODESTARTisCompatibleWithFeature
367 ENDisCompatibleWithFeature
368 BEGINfreeInstance
369 CODESTARTfreeInstance
370 	if (pData-&gt;fieldList.name != NULL)
371 	{
372 		for (int i = 0; i &lt; pData-&gt;fieldList.nmemb; ++i)
373 		{
374 			free(pData-&gt;fieldList.name[i]);
375 			free(pData-&gt;fieldList.varname[i]);
376 		}
377 		free(pData-&gt;fieldList.name);
378 		free(pData-&gt;fieldList.varname);
379 	}
380 	free(pData-&gt;pUUIDKey);
381 	free(pData-&gt;pCertitudeKey);
382 	free(pData-&gt;pSockName);
383 ENDfreeInstance
384 BEGINfreeWrkrInstance
385 CODESTARTfreeWrkrInstance
386 	closeSocket(pWrkrData);
387 	free(pWrkrData-&gt;darwinBody.buffer);
388 ENDfreeWrkrInstance
389 BEGINsetModCnf
390 struct cnfparamvals *pvals = NULL;
391 int i;
392 CODESTARTsetModCnf
393 	loadModConf-&gt;container = NULL;
394 	pvals = nvlstGetParams(lst, &amp;modpblk, NULL);
395 	if (pvals == NULL)
396 	{
397 <a name="2"></a>		LogError(0, RS_RET_MISSING_CNFPARAMS,
398 				"mmdarwin: error processing module config parameters missing [module(...)]");
399 		ABORT_FINALIZE(RS_RET_MISSING_CNFPARAMS);
400 <font color="#980517"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>	}
401 	if (Debug)
402 	{
403 		DBGPRINTF("mmdarwin::setModCnf:: module (global) param blk for mmdarwin:\n");
404 		cnfparamsPrint(&amp;modpblk, pvals);
405 	}
406 	for (i = 0; i &lt; modpblk.nParams; ++i)
407 	{
408 		if (!pvals[i].bUsed)
409 			continue;
410 		if (!strcmp(modpblk.descr[i].name, "container"))
411 		{
412 			loadModConf-&gt;container = es_str2cstr(pvals[i].val.d.estr, NULL);</b></font>
413 			if(loadModConf-&gt;container[0] != '!' &amp;&amp; loadModConf-&gt;container[0] != '.') {
414 				LogError(0, RS_RET_INVALID_PARAMS, "mmdarwin: container should either"
415 					" begin with '!' or '.'\n");
416 				ABORT_FINALIZE(RS_RET_INVALID_PARAMS);
417 			}
418 		}
419 		else
420 		{
421 			DBGPRINTF("mmdarwin::setModCnf:: program error, non-handled "
422 					"param '%s'\n",
423 					modpblk.descr[i].name);
424 		}
425 	}
426 	if (loadModConf-&gt;container == NULL)
427 	{
428 		CHKmalloc(loadModConf-&gt;container = strdup(JSON_DEFAULT_CONTAINER));
429 	}
430 finalize_it :
431 	if (pvals != NULL)
432 		cnfparamvalsDestruct(pvals, &amp;modpblk);
433 ENDsetModCnf
434 static inline void setInstParamDefaults(instanceData *pData)
435 {
436 	DBGPRINTF("mmdarwin::setInstParamDefaults::\n");
437 	pData-&gt;pUUIDKey = NULL;
438 	pData-&gt;pCertitudeKey = NULL;
439 	pData-&gt;pSockName = NULL;
440 	pData-&gt;fieldList.nmemb = 0;
441 	pData-&gt;filterCode = DARWIN_FILTER_CODE_NO;
442 	pData-&gt;response = DARWIN_RESPONSE_SEND_NO;
443 	pData-&gt;socketMaxUse = 0;
444 	pData-&gt;sendPartial = 0;
445 }
446 BEGINnewActInst
447 	struct cnfparamvals *pvals;
448 	int i;
449 CODESTARTnewActInst
450 	DBGPRINTF("mmdarwin::newActInst::\n");
451 	if ((pvals = nvlstGetParams(lst, &amp;actpblk, NULL)) == NULL)
452 	{
453 		ABORT_FINALIZE(RS_RET_MISSING_CNFPARAMS);
454 	}
455 	CODE_STD_STRING_REQUESTnewActInst(1)
456 	CHKiRet(OMSRsetEntry(*ppOMSR, 0, NULL, OMSR_TPL_AS_MSG));
457 	CHKiRet(createInstance(&amp;pData));
458 	setInstParamDefaults(pData);
459 	for (i = 0; i &lt; actpblk.nParams; ++i)
460 	{
461 		if (!pvals[i].bUsed)
462 			continue;
463 		if (!strcmp(actpblk.descr[i].name, "key"))
464 		{
465 			char *key = es_str2cstr(pvals[i].val.d.estr, NULL);
466 			char vnamebuf[1024];
467 			snprintf(vnamebuf, sizeof(vnamebuf), "%s!%s", loadModConf-&gt;container, key);
468 			CHKmalloc(pData-&gt;pCertitudeKey = strdup(vnamebuf));
469 			free(key);
470 			DBGPRINTF("mmdarwin::newActInst:: certitudeKey is %s\n", pData-&gt;pCertitudeKey);
471 		}
472 		else if (!strcmp(actpblk.descr[i].name, "socketpath"))
473 		{
474 			pData-&gt;pSockName = (uchar *)es_str2cstr(pvals[i].val.d.estr, NULL);
475 			DBGPRINTF("mmdarwin::newActInst:: sockName is %s\n", pData-&gt;pSockName);
476 		}
477 		else if (!strcmp(actpblk.descr[i].name, "socket_max_use"))
478 		{
479 			pData-&gt;socketMaxUse = (uint32_t)pvals[i].val.d.n;
480 			DBGPRINTF("mmdarwin::newActInst:: socketMaxUse is %d\n", pData-&gt;socketMaxUse);
481 		}
482 		else if (!strcmp(actpblk.descr[i].name, "send_partial"))
483 		{
484 			pData-&gt;sendPartial = (sbool)pvals[i].val.d.n;
485 			if (pData-&gt;sendPartial)
486 			{
487 				DBGPRINTF("mmdarwin::newActInst:: sending bodies even if fields are missing\n");
488 			}
489 			else
490 <a name="1"></a>			{
491 				DBGPRINTF("mmdarwin::newActInst:: only sending complete bodies\n");
492 			}
493 <font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>		}
494 		else if (!strcmp(actpblk.descr[i].name, "response"))
495 		{
496 			char *response = es_str2cstr(pvals[i].val.d.estr, NULL);
497 			if (!strcmp(response, "no"))
498 			{
499 				pData-&gt;response = DARWIN_RESPONSE_SEND_NO;
500 				DBGPRINTF("mmdarwin::newActInst:: response type is 'no'\n");
501 			}
502 			else if (!strcmp(response, "back"))
503 			{
504 				pData-&gt;response = DARWIN_RESPONSE_SEND_BACK;
505 				DBGPRINTF("mmdarwin::newActInst:: response type is 'back'\n");
506 			}
507 			else if (!strcmp(response, "darwin"))
508 			{
509 				pData-&gt;response = DARWIN_RESPONSE_SEND_DARWIN;
510 				DBGPRINTF("mmdarwin::newActInst:: response type is 'darwin'\n");
511 			}
512 			else if (!strcmp(response, "both"))</b></font>
513 			{
514 				pData-&gt;response = DARWIN_RESPONSE_SEND_BOTH;
515 				DBGPRINTF("mmdarwin::newActInst:: response type is 'both'\n");
516 			}
517 			else
518 			{
519 				DBGPRINTF(
520 					"mmdarwin::newActInst:: invalid 'response' value: %s. 'No response' set.\n",
521 					response);
522 				pData-&gt;response = DARWIN_RESPONSE_SEND_NO;
523 				DBGPRINTF("mmdarwin::newActInst:: response type is 'no'\n");
524 			}
525 			free(response);
526 		}
527 		else if (!strcmp(actpblk.descr[i].name, "filtercode"))
528 		{
529 			char *filterCode = es_str2cstr(pvals[i].val.d.estr, NULL);
530 			pData-&gt;filterCode = strtoull(filterCode, NULL, 16);
531 			free(filterCode);
532 		}
533 		else if (!strcmp(actpblk.descr[i].name, "fields"))
534 		{
535 			pData-&gt;fieldList.nmemb = pvals[i].val.d.ar-&gt;nmemb;
536 			CHKmalloc(pData-&gt;fieldList.name = calloc(pData-&gt;fieldList.nmemb, sizeof(char *)));
537 			CHKmalloc(pData-&gt;fieldList.varname = calloc(pData-&gt;fieldList.nmemb, sizeof(char *)));
538 			for (int j = 0; j &lt; pData-&gt;fieldList.nmemb; ++j)
539 			{
540 				char *const param = es_str2cstr(pvals[i].val.d.ar-&gt;arr[j], NULL);
541 				char *varname = NULL;
542 				char *name;
543 				if (*param == ':')
544 				{
545 					char *b = strchr(param + 1, ':');
546 					if (b == NULL)
547 					{
548 						parser_errmsg(
549 							"mmdarwin::newActInst:: missing closing colon: '%s'", param);
550 						ABORT_FINALIZE(RS_RET_ERR);
551 					}
552 					*b = '\0'; 					varname = param + 1;
553 					name = b + 1;
554 				}
555 				else
556 				{
557 					name = param;
558 				}
559 				CHKmalloc(pData-&gt;fieldList.name[j] = strdup(name));
560 				char vnamebuf[1024];
561 				snprintf(vnamebuf, sizeof(vnamebuf),
562 						"%s!%s", loadModConf-&gt;container,
563 						(varname == NULL) ? name : varname);
564 				CHKmalloc(pData-&gt;fieldList.varname[j] = strdup(vnamebuf));
565 				free(param);
566 				DBGPRINTF("mmdarwin::newActInst:: will look for field %s\n", pData-&gt;fieldList.name[j]);
567 			}
568 		}
569 		else
570 		{
571 			DBGPRINTF(
572 			"mmdarwin::newActInst:: program error, non-handled param '%s'\n", actpblk.descr[i].name);
573 		}
574 	}
575 	size_t sizeKey = strlen(loadModConf-&gt;container) + strlen(JSON_DARWIN_ID) + 2;
576 	pData-&gt;pUUIDKey = malloc(sizeKey);
577 	snprintf(pData-&gt;pUUIDKey, sizeKey, "%s!%s", loadModConf-&gt;container, JSON_DARWIN_ID);
578 	DBGPRINTF("mmdarwin:: uuid key is %s\n", pData-&gt;pUUIDKey);
579 CODE_STD_FINALIZERnewActInst
580 	cnfparamvalsDestruct(pvals, &amp;actpblk);
581 ENDnewActInst
582 BEGINtryResume
583 CODESTARTtryResume
584 	iRet = doTryResume(pWrkrData);
585 ENDtryResume
586 BEGINdoAction_NoStrings
587 	smsg_t **ppMsg = (smsg_t **)pMsgData; 	smsg_t *pMsg = ppMsg[0]; 	instanceData *pData = pWrkrData-&gt;pData; 	char *pFieldValue = NULL; 	int fieldsNum = 0; 
588 CODESTARTdoAction
589 	DBGPRINTF("mmdarwin::doAction:: beggining action\n");
590 	pWrkrData-&gt;darwinBody.bufferMsgSize = 0;
591 	fieldsNum = 0;
592 	for (int i = 0; i &lt; pData-&gt;fieldList.nmemb; i++)
593 	{
594 		DBGPRINTF("mmdarwin::doAction:: processing field '%s'\n", pData-&gt;fieldList.name[i]);
595 		pFieldValue = NULL;
596 		if (pData-&gt;fieldList.name[i][0] != '!' &amp;&amp; pData-&gt;fieldList.name[i][0] != '.')
597 		{
598 			pFieldValue = strdup(pData-&gt;fieldList.name[i]);
599 		}
600 		else
601 		{
602 			if (!get_field(pMsg, pData-&gt;fieldList.name[i], &amp;pFieldValue))
603 			{
604 				DBGPRINTF("mmdarwin::doAction:: \
605 could not extract field '%s' from message\n", pData-&gt;fieldList.name[i]);
606 				continue;
607 			}
608 		}
609 		DBGPRINTF(
610 			"mmdarwin::doAction:: got value of field '%s': '%s'\n", pData-&gt;fieldList.name[i], pFieldValue);
611 		if (add_field_to_body(&amp;(pWrkrData-&gt;darwinBody), pFieldValue, strlen(pFieldValue)) != 0)
612 		{
613 			DBGPRINTF("mmdarwin::doAction:: could not add field to body, aborting\n");
614 			free(pFieldValue);
615 			ABORT_FINALIZE(RS_RET_ERR);
616 		}
617 		fieldsNum++;
618 		free(pFieldValue);
619 	}
620 	if (fieldsNum)
621 	{
622 		if (!pData-&gt;sendPartial &amp;&amp; fieldsNum != pData-&gt;fieldList.nmemb)
623 		{
624 			DBGPRINTF("mmdarwin::doAction:: not all fields could be retrieved, not sending partial message."
625 	" (if you wish to send partial messages anyway, set 'send_partial' to 'on' in instance parameters)\n");
626 			FINALIZE;
627 		}
628 		if (end_body(&amp;(pWrkrData-&gt;darwinBody)) != 0)
629 			ABORT_FINALIZE(RS_RET_ERR);
630 	}
631 	else
632 	{
633 		DBGPRINTF("mmdarwin::doAction:: no fields retrieved, finalizing\n");
634 		FINALIZE;
635 	}
636 	DBGPRINTF("mmdarwin::doAction:: body to send: '%s'\n", pWrkrData-&gt;darwinBody.buffer);
637 	if (pData-&gt;socketMaxUse)
638 	{
639 		if (!pWrkrData-&gt;pktSentSocket)
640 		{
641 			DBGPRINTF("mmdarwin::doAction:: opening a new connection\n");
642 			CHKiRet(doTryResume(pWrkrData));
643 		}
644 		pWrkrData-&gt;pktSentSocket = (pWrkrData-&gt;pktSentSocket + 1) % pData-&gt;socketMaxUse;
645 	}
646 	darwin_filter_packet_t header = {
647 		.type = DARWIN_PACKET_OTHER,
648 		.response = pData-&gt;response,
649 		.filter_code = pData-&gt;filterCode,
650 		.body_size = pWrkrData-&gt;darwinBody.bufferMsgSize};
651 	const char *uuid = get_uuid_object(pMsg);
652 	if(uuid) {
653 		DBGPRINTF("mmdarwin: using existing UUID = %s\n", uuid);
654 		if(uuid_parse(uuid, header.evt_id))
655 			LogError(0, RS_RET_ERR, "mmdarwin:: failed to parse existing UUID: %s\n", uuid);
656 		free((void*)uuid);
657 	}
658 	else {
659 		uuid_generate(header.evt_id);
660 		char uuidStr[40];
661 		uuid_unparse(header.evt_id, uuidStr);
662 		DBGPRINTF("mmdarwin: generated new UUID = %s\n", uuidStr);
663 		msgAddJSON(pMsg, (uchar *)pData-&gt;pUUIDKey, json_object_new_string(uuidStr), 0, 0);
664 	}
665 	DBGPRINTF("mmdarwin::doAction:: sending header to Darwin\n");
666 	CHKiRet(sendMsg(pWrkrData, &amp;header, sizeof(darwin_filter_packet_t)));
667 	DBGPRINTF("mmdarwin::doAction:: sending body to Darwin\n");
668 	CHKiRet(sendMsg(pWrkrData, (void *)(pWrkrData-&gt;darwinBody.buffer), pWrkrData-&gt;darwinBody.bufferMsgSize));
669 	if (pData-&gt;response == DARWIN_RESPONSE_SEND_NO || pData-&gt;response == DARWIN_RESPONSE_SEND_DARWIN)
670 	{
671 		DBGPRINTF("mmdarwin::doAction:: no response will be sent back "
672 				"(darwin response type is set to 'no' or 'darwin')\n");
673 		goto finalize_it;
674 	}
675 	darwin_filter_packet_t response;
676 	memset(&amp;response, 0, sizeof(response));
677 	DBGPRINTF("mmdarwin::doAction:: receiving from Darwin\n");
678 	CHKiRet(receiveMsg(pWrkrData, &amp;response, sizeof(response)));
679 	unsigned int certitude = response.certitude_list[0];
680 	DBGPRINTF("mmdarwin::doAction:: end of the transaction, certitude is %d\n", certitude);
681 	msgAddJSON(pMsg, (uchar *)pData-&gt;pCertitudeKey, json_object_new_int(certitude), 0, 0);
682 finalize_it :
683 	DBGPRINTF("mmdarwin::doAction:: finished processing log line\n");
684 ENDdoAction
685 NO_LEGACY_CONF_parseSelectorAct
686 BEGINmodExit
687 CODESTARTmodExit
688 	objRelease(glbl, CORE_COMPONENT);
689 ENDmodExit
690 BEGINqueryEtryPt
691 CODESTARTqueryEtryPt
692 CODEqueryEtryPt_STD_OMOD_QUERIES
693 CODEqueryEtryPt_STD_OMOD8_QUERIES
694 CODEqueryEtryPt_STD_CONF2_setModCnf_QUERIES
695 CODEqueryEtryPt_STD_CONF2_OMOD_QUERIES
696 CODEqueryEtryPt_STD_CONF2_QUERIES
697 ENDqueryEtryPt
698 BEGINmodInit()
699 CODESTARTmodInit
700 	*ipIFVersProvided = CURR_MOD_IF_VERSION;
701 CODEmodInit_QueryRegCFSLineHdlr
702 	DBGPRINTF("mmdarwin::modInit:: module compiled with rsyslog version %s.\n", VERSION);
703 	CHKiRet(objUse(glbl, CORE_COMPONENT));
704 ENDmodInit
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>glbl.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 #include "config.h"
2 #include &lt;stdlib.h&gt;
3 #include &lt;sys/socket.h&gt;
4 #include &lt;sys/types.h&gt;
5 #include &lt;sys/stat.h&gt;
6 #include &lt;sys/wait.h&gt;
7 #include &lt;fcntl.h&gt;
8 #include &lt;unistd.h&gt;
9 #include &lt;pthread.h&gt;
10 #include &lt;ctype.h&gt;
11 #include &lt;assert.h&gt;
12 #include &lt;stdint.h&gt;
13 #include &lt;errno.h&gt;
14 #include "rsyslog.h"
15 #include "obj.h"
16 #include "unicode-helper.h"
17 #include "cfsysline.h"
18 #include "glbl.h"
19 #include "prop.h"
20 #include "atomic.h"
21 #include "errmsg.h"
22 #include "action.h"
23 #include "parserif.h"
24 #include "rainerscript.h"
25 #include "srUtils.h"
26 #include "operatingstate.h"
27 #include "net.h"
28 #include "rsconf.h"
29 #include "queue.h"
30 #include "dnscache.h"
31 #include "parser.h"
32 #include "timezones.h"
33 #ifndef DFLT_NETSTRM_DRVR
34 #	define DFLT_NETSTRM_DRVR ((uchar*)"ptcp")
35 #endif
36 DEFobjStaticHelpers
37 DEFobjCurrIf(prop)
38 DEFobjCurrIf(net)
39 static struct cnfobj *mainqCnfObj = NULL;static int bPreserveFQDN = 0;		static prop_t *propLocalIPIF = NULL;static int propLocalIPIF_set = 0;	static prop_t *propLocalHostName = NULL;static prop_t *propLocalHostNameToDelete = NULL;static uchar *LocalHostName = NULL;static uchar *LocalHostNameOverride = NULL;static uchar *LocalFQDNName = NULL;static uchar *LocalDomain = NULL;static int iMaxLine = 8096;
40 int bTerminateInputs = 0;		int glblUnloadModules = 1;
41 char** glblDbgFiles = NULL;
42 size_t glblDbgFilesNum = 0;
43 int glblDbgWhitelist = 1;
44 int glblPermitCtlC = 0;
45 pid_t glbl_ourpid;
46 #ifndef HAVE_ATOMIC_BUILTINS
47 DEF_ATOMIC_HELPER_MUT(mutTerminateInputs);
48 #endif
49 #ifdef USE_UNLIMITED_SELECT
50 static int iFdSetSize = howmany(FD_SETSIZE, __NFDBITS) * sizeof (fd_mask); #endif
51 static uchar *SourceIPofLocalClient = NULL;	
52 static struct cnfparamdescr cnfparamdescr[] = {
53 	{ "workdirectory", eCmdHdlrString, 0 },
54 	{ "operatingstatefile", eCmdHdlrString, 0 },
55 	{ "dropmsgswithmaliciousdnsptrrecords", eCmdHdlrBinary, 0 },
56 	{ "localhostname", eCmdHdlrGetWord, 0 },
57 	{ "preservefqdn", eCmdHdlrBinary, 0 },
58 	{ "debug.onshutdown", eCmdHdlrBinary, 0 },
59 	{ "debug.logfile", eCmdHdlrString, 0 },
60 	{ "debug.gnutls", eCmdHdlrNonNegInt, 0 },
61 	{ "debug.unloadmodules", eCmdHdlrBinary, 0 },
62 	{ "defaultnetstreamdrivercafile", eCmdHdlrString, 0 },
63 	{ "defaultnetstreamdriverkeyfile", eCmdHdlrString, 0 },
64 	{ "defaultnetstreamdrivercertfile", eCmdHdlrString, 0 },
65 	{ "defaultnetstreamdriver", eCmdHdlrString, 0 },
66 	{ "maxmessagesize", eCmdHdlrSize, 0 },
67 	{ "oversizemsg.errorfile", eCmdHdlrGetWord, 0 },
68 	{ "oversizemsg.report", eCmdHdlrBinary, 0 },
69 	{ "oversizemsg.input.mode", eCmdHdlrGetWord, 0 },
70 	{ "reportchildprocessexits", eCmdHdlrGetWord, 0 },
71 	{ "action.reportsuspension", eCmdHdlrBinary, 0 },
72 	{ "action.reportsuspensioncontinuation", eCmdHdlrBinary, 0 },
73 	{ "parser.controlcharacterescapeprefix", eCmdHdlrGetChar, 0 },
74 	{ "parser.droptrailinglfonreception", eCmdHdlrBinary, 0 },
75 	{ "parser.escapecontrolcharactersonreceive", eCmdHdlrBinary, 0 },
76 	{ "parser.spacelfonreceive", eCmdHdlrBinary, 0 },
77 	{ "parser.escape8bitcharactersonreceive", eCmdHdlrBinary, 0},
78 	{ "parser.escapecontrolcharactertab", eCmdHdlrBinary, 0},
79 	{ "parser.escapecontrolcharacterscstyle", eCmdHdlrBinary, 0 },
80 	{ "parser.parsehostnameandtag", eCmdHdlrBinary, 0 },
81 	{ "parser.permitslashinprogramname", eCmdHdlrBinary, 0 },
82 	{ "stdlog.channelspec", eCmdHdlrString, 0 },
83 	{ "janitor.interval", eCmdHdlrPositiveInt, 0 },
84 	{ "senders.reportnew", eCmdHdlrBinary, 0 },
85 	{ "senders.reportgoneaway", eCmdHdlrBinary, 0 },
86 	{ "senders.timeoutafter", eCmdHdlrPositiveInt, 0 },
87 	{ "senders.keeptrack", eCmdHdlrBinary, 0 },
88 	{ "inputs.timeout.shutdown", eCmdHdlrPositiveInt, 0 },
89 	{ "privdrop.group.keepsupplemental", eCmdHdlrBinary, 0 },
90 	{ "privdrop.group.id", eCmdHdlrPositiveInt, 0 },
91 	{ "privdrop.group.name", eCmdHdlrGID, 0 },
92 	{ "privdrop.user.id", eCmdHdlrPositiveInt, 0 },
93 	{ "privdrop.user.name", eCmdHdlrUID, 0 },
94 	{ "net.ipprotocol", eCmdHdlrGetWord, 0 },
95 	{ "net.acladdhostnameonfail", eCmdHdlrBinary, 0 },
96 	{ "net.aclresolvehostname", eCmdHdlrBinary, 0 },
97 	{ "net.enabledns", eCmdHdlrBinary, 0 },
98 	{ "net.permitACLwarning", eCmdHdlrBinary, 0 },
99 	{ "abortonuncleanconfig", eCmdHdlrBinary, 0 },
100 	{ "variables.casesensitive", eCmdHdlrBinary, 0 },
101 	{ "environment", eCmdHdlrArray, 0 },
102 	{ "processinternalmessages", eCmdHdlrBinary, 0 },
103 	{ "umask", eCmdHdlrFileCreateMode, 0 },
104 	{ "security.abortonidresolutionfail", eCmdHdlrBinary, 0 },
105 	{ "internal.developeronly.options", eCmdHdlrInt, 0 },
106 	{ "internalmsg.ratelimit.interval", eCmdHdlrPositiveInt, 0 },
107 	{ "internalmsg.ratelimit.burst", eCmdHdlrPositiveInt, 0 },
108 	{ "internalmsg.severity", eCmdHdlrSeverity, 0 },
109 	{ "errormessagestostderr.maxnumber", eCmdHdlrPositiveInt, 0 },
110 	{ "shutdown.enable.ctlc", eCmdHdlrBinary, 0 },
111 	{ "default.action.queue.timeoutshutdown", eCmdHdlrInt, 0 },
112 	{ "default.action.queue.timeoutactioncompletion", eCmdHdlrInt, 0 },
113 	{ "default.action.queue.timeoutenqueue", eCmdHdlrInt, 0 },
114 	{ "default.action.queue.timeoutworkerthreadshutdown", eCmdHdlrInt, 0 },
115 <a name="0"></a>	{ "default.ruleset.queue.timeoutshutdown", eCmdHdlrInt, 0 },
116 	{ "default.ruleset.queue.timeoutactioncompletion", eCmdHdlrInt, 0 },
117 	{ "default.ruleset.queue.timeoutenqueue", eCmdHdlrInt, 0 },
118 <font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>	{ "default.ruleset.queue.timeoutworkerthreadshutdown", eCmdHdlrInt, 0 },
119 	{ "reverselookup.cache.ttl.default", eCmdHdlrNonNegInt, 0 },
120 	{ "reverselookup.cache.ttl.enable", eCmdHdlrBinary, 0 },
121 	{ "parser.supportcompressionextension", eCmdHdlrBinary, 0 },
122 	{ "shutdown.queue.doublesize", eCmdHdlrBinary, 0 },
123 	{ "debug.files", eCmdHdlrArray, 0 },
124 	{ "debug.whitelist", eCmdHdlrBinary, 0 }
125 };
126 static struct cnfparamblk paramblk =
127 	{ CNFPARAMBLK_VERSION,
128 	  sizeof(cnfparamdescr)/sizeof(struct cnfparamdescr),
129 	  cnfparamdescr
130 	};
131 static struct cnfparamvals *cnfparamvals = NULL;</b></font>
132 int
133 glblGetMaxLine(rsconf_t *cnf)
134 {
135 	return((cnf != NULL) ? cnf-&gt;globals.iMaxLine : iMaxLine);
136 }
137 int
138 GetGnuTLSLoglevel(rsconf_t *cnf)
139 {
140 	return(cnf-&gt;globals.iGnuTLSLoglevel);
141 }
142 #define SIMP_PROP(nameFunc, nameVar, dataType) \
143 	SIMP_PROP_GET(nameFunc, nameVar, dataType) \
144 	SIMP_PROP_SET(nameFunc, nameVar, dataType)
145 #define SIMP_PROP_SET(nameFunc, nameVar, dataType) \
146 static rsRetVal Set##nameFunc(dataType newVal) \
147 { \
148 	nameVar = newVal; \
149 	return RS_RET_OK; \
150 }
151 #define SIMP_PROP_GET(nameFunc, nameVar, dataType) \
152 static dataType Get##nameFunc(void) \
153 { \
154 	return(nameVar); \
155 }
156 SIMP_PROP(PreserveFQDN, bPreserveFQDN, int)
157 SIMP_PROP(mainqCnfObj, mainqCnfObj, struct cnfobj *)
158 #ifdef USE_UNLIMITED_SELECT
159 SIMP_PROP(FdSetSize, iFdSetSize, int)
160 #endif
161 #undef SIMP_PROP
162 #undef SIMP_PROP_SET
163 #undef SIMP_PROP_GET
164 #define SIMP_PROP(nameFunc, nameVar, dataType) \
165 	SIMP_PROP_GET(nameFunc, nameVar, dataType) \
166 	SIMP_PROP_SET(nameFunc, nameVar, dataType)
167 #define SIMP_PROP_SET(nameFunc, nameVar, dataType) \
168 static rsRetVal Set##nameFunc(dataType newVal) \
169 { \
170 	loadConf-&gt;globals.nameVar = newVal; \
171 	return RS_RET_OK; \
172 }
173 #define SIMP_PROP_GET(nameFunc, nameVar, dataType) \
174 static dataType Get##nameFunc(rsconf_t *cnf) \
175 { \
176 	return(cnf-&gt;globals.nameVar); \
177 }
178 SIMP_PROP(DropMalPTRMsgs, bDropMalPTRMsgs, int)
179 SIMP_PROP(DisableDNS, bDisableDNS, int)
180 SIMP_PROP(ParserEscapeControlCharactersCStyle, parser.bParserEscapeCCCStyle, int)
181 SIMP_PROP(ParseHOSTNAMEandTAG, parser.bParseHOSTNAMEandTAG, int)
182 SIMP_PROP(OptionDisallowWarning, optionDisallowWarning, int)
183 SIMP_PROP_GET(DfltNetstrmDrvrCAF, pszDfltNetstrmDrvrCAF, uchar*)
184 SIMP_PROP_GET(DfltNetstrmDrvrCertFile, pszDfltNetstrmDrvrCertFile, uchar*)
185 SIMP_PROP_GET(DfltNetstrmDrvrKeyFile, pszDfltNetstrmDrvrKeyFile, uchar*)
186 SIMP_PROP_GET(ParserControlCharacterEscapePrefix, parser.cCCEscapeChar, uchar)
187 SIMP_PROP_GET(ParserDropTrailingLFOnReception, parser.bDropTrailingLF, int)
188 SIMP_PROP_GET(ParserEscapeControlCharactersOnReceive, parser.bEscapeCCOnRcv, int)
189 SIMP_PROP_GET(ParserSpaceLFOnReceive, parser.bSpaceLFOnRcv, int)
190 SIMP_PROP_GET(ParserEscape8BitCharactersOnReceive, parser.bEscape8BitChars, int)
191 SIMP_PROP_GET(ParserEscapeControlCharacterTab, parser.bEscapeTab, int)
192 #undef SIMP_PROP
193 #undef SIMP_PROP_SET
194 #undef SIMP_PROP_GET
195 static int GetGlobalInputTermState(void)
196 {
197 	return ATOMIC_FETCH_32BIT(&amp;bTerminateInputs, &amp;mutTerminateInputs);
198 }
199 static void SetGlobalInputTermination(void)
200 {
201 	ATOMIC_STORE_1_TO_INT(&amp;bTerminateInputs, &amp;mutTerminateInputs);
202 }
203 static rsRetVal
204 storeLocalHostIPIF(uchar *myIP)
205 {
206 	DEFiRet;
207 	if(propLocalIPIF != NULL) {
208 		CHKiRet(prop.Destruct(&amp;propLocalIPIF));
209 	}
210 	CHKiRet(prop.Construct(&amp;propLocalIPIF));
211 	CHKiRet(prop.SetString(propLocalIPIF, myIP, ustrlen(myIP)));
212 	CHKiRet(prop.ConstructFinalize(propLocalIPIF));
213 	DBGPRINTF("rsyslog/glbl: using '%s' as localhost IP\n", myIP);
214 finalize_it:
215 	RETiRet;
216 }
217 static rsRetVal
218 setLocalHostIPIF(void __attribute__((unused)) *pVal, uchar *pNewVal)
219 {
220 	uchar myIP[128];
221 	rsRetVal localRet;
222 	DEFiRet;
223 	CHKiRet(objUse(net, CORE_COMPONENT));
224 	if(propLocalIPIF_set) {
225 		LogError(0, RS_RET_ERR, "$LocalHostIPIF is already set "
226 				"and cannot be reset; place it at TOP OF rsyslog.conf!");
227 		ABORT_FINALIZE(RS_RET_ERR);
228 	}
229 	localRet = net.GetIFIPAddr(pNewVal, AF_UNSPEC, myIP, (int) sizeof(myIP));
230 	if(localRet != RS_RET_OK) {
231 		LogError(0, RS_RET_ERR, "$LocalHostIPIF: IP address for interface "
232 				"'%s' cannnot be obtained - ignoring directive", pNewVal);
233 	} else  {
234 		storeLocalHostIPIF(myIP);
235 	}
236 finalize_it:
237 	free(pNewVal); 	RETiRet;
238 }
239 static rsRetVal setWorkDir(void __attribute__((unused)) *pVal, uchar *pNewVal)
240 {
241 	size_t lenDir;
242 	int i;
243 	struct stat sb;
244 	DEFiRet;
245 	lenDir = ustrlen(pNewVal);
246 	i = lenDir - 1;
247 	while(i &gt; 0 &amp;&amp; pNewVal[i] == '/') {
248 		--i;
249 	}
250 	if(i &lt; 0) {
251 		LogError(0, RS_RET_ERR_WRKDIR, "$WorkDirectory: empty value "
252 				"- directive ignored");
253 		ABORT_FINALIZE(RS_RET_ERR_WRKDIR);
254 	}
255 	if(i != (int) lenDir - 1) {
256 		pNewVal[i+1] = '\0';
257 		LogError(0, RS_RET_WRN_WRKDIR, "$WorkDirectory: trailing slashes "
258 			"removed, new value is '%s'", pNewVal);
259 	}
260 	if(stat((char*) pNewVal, &amp;sb) != 0) {
261 		LogError(0, RS_RET_ERR_WRKDIR, "$WorkDirectory: %s can not be "
262 				"accessed, probably does not exist - directive ignored", pNewVal);
263 		ABORT_FINALIZE(RS_RET_ERR_WRKDIR);
264 	}
265 	if(!S_ISDIR(sb.st_mode)) {
266 		LogError(0, RS_RET_ERR_WRKDIR, "$WorkDirectory: %s not a directory - directive ignored",
267 				pNewVal);
268 		ABORT_FINALIZE(RS_RET_ERR_WRKDIR);
269 	}
270 	free(loadConf-&gt;globals.pszWorkDir);
271 	loadConf-&gt;globals.pszWorkDir = pNewVal;
272 finalize_it:
273 	RETiRet;
274 }
275 static rsRetVal
276 setDfltNetstrmDrvrCAF(void __attribute__((unused)) *pVal, uchar *pNewVal) {
277 	DEFiRet;
278 	FILE *fp;
279 	free(loadConf-&gt;globals.pszDfltNetstrmDrvrCAF);
280 	fp = fopen((const char*)pNewVal, "r");
281 	if(fp == NULL) {
282 		LogError(errno, RS_RET_NO_FILE_ACCESS,
283 			"error: defaultnetstreamdrivercafile file '%s' "
284 			"could not be accessed", pNewVal);
285 	} else {
286 		fclose(fp);
287 		loadConf-&gt;globals.pszDfltNetstrmDrvrCAF = pNewVal;
288 	}
289 	RETiRet;
290 }
291 static rsRetVal
292 setDfltNetstrmDrvrCertFile(void __attribute__((unused)) *pVal, uchar *pNewVal) {
293 	DEFiRet;
294 	FILE *fp;
295 	free(loadConf-&gt;globals.pszDfltNetstrmDrvrCertFile);
296 	fp = fopen((const char*)pNewVal, "r");
297 	if(fp == NULL) {
298 		LogError(errno, RS_RET_NO_FILE_ACCESS,
299 			"error: defaultnetstreamdrivercertfile '%s' "
300 			"could not be accessed", pNewVal);
301 	} else {
302 		fclose(fp);
303 		loadConf-&gt;globals.pszDfltNetstrmDrvrCertFile = pNewVal;
304 	}
305 	RETiRet;
306 }
307 static rsRetVal
308 setDfltNetstrmDrvrKeyFile(void __attribute__((unused)) *pVal, uchar *pNewVal) {
309 	DEFiRet;
310 	FILE *fp;
311 	free(loadConf-&gt;globals.pszDfltNetstrmDrvrKeyFile);
312 	fp = fopen((const char*)pNewVal, "r");
313 	if(fp == NULL) {
314 		LogError(errno, RS_RET_NO_FILE_ACCESS,
315 			"error: defaultnetstreamdriverkeyfile '%s' "
316 			"could not be accessed", pNewVal);
317 	} else {
318 		fclose(fp);
319 		loadConf-&gt;globals.pszDfltNetstrmDrvrKeyFile = pNewVal;
320 	}
321 	RETiRet;
322 }
323 static rsRetVal
324 setDfltNetstrmDrvr(void __attribute__((unused)) *pVal, uchar *pNewVal) {
325 	DEFiRet;
326 	free(loadConf-&gt;globals.pszDfltNetstrmDrvr);
327 	loadConf-&gt;globals.pszDfltNetstrmDrvr = pNewVal;
328 	RETiRet;
329 }
330 static rsRetVal
331 setParserControlCharacterEscapePrefix(void __attribute__((unused)) *pVal, uchar *pNewVal) {
332 	DEFiRet;
333 	loadConf-&gt;globals.parser.cCCEscapeChar = *pNewVal;
334 	RETiRet;
335 }
336 static rsRetVal
337 setParserDropTrailingLFOnReception(void __attribute__((unused)) *pVal, int pNewVal) {
338 	DEFiRet;
339 	loadConf-&gt;globals.parser.bDropTrailingLF = pNewVal;
340 	RETiRet;
341 }
342 static rsRetVal
343 setParserEscapeControlCharactersOnReceive(void __attribute__((unused)) *pVal, int pNewVal) {
344 	DEFiRet;
345 	loadConf-&gt;globals.parser.bEscapeCCOnRcv = pNewVal;
346 	RETiRet;
347 }
348 static rsRetVal
349 setParserSpaceLFOnReceive(void __attribute__((unused)) *pVal, int pNewVal) {
350 	DEFiRet;
351 	loadConf-&gt;globals.parser.bSpaceLFOnRcv = pNewVal;
352 	RETiRet;
353 }
354 static rsRetVal
355 setParserEscape8BitCharactersOnReceive(void __attribute__((unused)) *pVal, int pNewVal) {
356 	DEFiRet;
357 	loadConf-&gt;globals.parser.bEscape8BitChars = pNewVal;
358 	RETiRet;
359 }
360 static rsRetVal
361 setParserEscapeControlCharacterTab(void __attribute__((unused)) *pVal, int pNewVal) {
362 	DEFiRet;
363 	loadConf-&gt;globals.parser.bEscapeTab = pNewVal;
364 	RETiRet;
365 }
366 static void
367 setMaxLine(const int64_t iNew)
368 {
369 	if(iNew &lt; 128) {
370 		LogError(0, RS_RET_INVALID_VALUE, "maxMessageSize tried to set "
371 				"to %lld, but cannot be less than 128 - set to 128 "
372 				"instead", (long long) iNew);
373 		loadConf-&gt;globals.iMaxLine = 128;
374 	} else if(iNew &gt; (int64_t) INT_MAX) {
375 		LogError(0, RS_RET_INVALID_VALUE, "maxMessageSize larger than "
376 				"INT_MAX (%d) - reduced to INT_MAX", INT_MAX);
377 		loadConf-&gt;globals.iMaxLine = INT_MAX;
378 	} else {
379 		loadConf-&gt;globals.iMaxLine = (int) iNew;
380 	}
381 }
382 static rsRetVal
383 legacySetMaxMessageSize(void __attribute__((unused)) *pVal, int64_t iNew)
384 {
385 	setMaxLine(iNew);
386 	return RS_RET_OK;
387 }
388 static rsRetVal
389 setDebugFile(void __attribute__((unused)) *pVal, uchar *pNewVal)
390 {
391 	DEFiRet;
392 	dbgSetDebugFile(pNewVal);
393 	free(pNewVal);
394 	RETiRet;
395 }
396 static rsRetVal
397 setDebugLevel(void __attribute__((unused)) *pVal, int level)
398 {
399 	DEFiRet;
400 	dbgSetDebugLevel(level);
401 	dbgprintf("debug level %d set via config file\n", level);
402 	dbgprintf("This is rsyslog version " VERSION "\n");
403 	RETiRet;
404 }
405 static rsRetVal ATTR_NONNULL()
406 setOversizeMsgInputMode(const uchar *const mode)
407 {
408 	DEFiRet;
409 	if(!strcmp((char*)mode, "truncate")) {
410 		loadConf-&gt;globals.oversizeMsgInputMode = glblOversizeMsgInputMode_Truncate;
411 	} else if(!strcmp((char*)mode, "split")) {
412 		loadConf-&gt;globals.oversizeMsgInputMode = glblOversizeMsgInputMode_Split;
413 	} else if(!strcmp((char*)mode, "accept")) {
414 		loadConf-&gt;globals.oversizeMsgInputMode = glblOversizeMsgInputMode_Accept;
415 	} else {
416 		loadConf-&gt;globals.oversizeMsgInputMode = glblOversizeMsgInputMode_Truncate;
417 	}
418 	RETiRet;
419 }
420 static rsRetVal ATTR_NONNULL()
421 setReportChildProcessExits(const uchar *const mode)
422 {
423 	DEFiRet;
424 	if(!strcmp((char*)mode, "none")) {
425 		loadConf-&gt;globals.reportChildProcessExits = REPORT_CHILD_PROCESS_EXITS_NONE;
426 	} else if(!strcmp((char*)mode, "errors")) {
427 		loadConf-&gt;globals.reportChildProcessExits = REPORT_CHILD_PROCESS_EXITS_ERRORS;
428 	} else if(!strcmp((char*)mode, "all")) {
429 		loadConf-&gt;globals.reportChildProcessExits = REPORT_CHILD_PROCESS_EXITS_ALL;
430 	} else {
431 		LogError(0, RS_RET_CONF_PARAM_INVLD,
432 				"invalid value '%s' for global parameter reportChildProcessExits -- ignored",
433 				mode);
434 		iRet = RS_RET_CONF_PARAM_INVLD;
435 	}
436 	RETiRet;
437 }
438 static int
439 getDefPFFamily(rsconf_t *cnf)
440 {
441 	return cnf-&gt;globals.iDefPFFamily;
442 }
443 static prop_t*
444 GetLocalHostIP(void)
445 {
446 	assert(propLocalIPIF != NULL);
447 	return(propLocalIPIF);
448 }
449 static rsRetVal
450 SetLocalHostName(uchar *const newname)
451 {
452 	uchar *toFree;
453 	if(LocalHostName == NULL || strcmp((const char*)LocalHostName, (const char*) newname)) {
454 		toFree = LocalHostName;
455 		LocalHostName = newname;
456 	} else {
457 		toFree = newname;
458 	}
459 	free(toFree);
460 	return RS_RET_OK;
461 }
462 static uchar*
463 GetLocalHostName(void)
464 {
465 	uchar *pszRet;
466 	if(LocalHostNameOverride != NULL) {
467 		pszRet = LocalHostNameOverride;
468 		goto done;
469 	}
470 	if(LocalHostName == NULL)
471 		pszRet = (uchar*) "[localhost]";
472 	else {
473 		if(GetPreserveFQDN() == 1)
474 			pszRet = LocalFQDNName;
475 		else
476 			pszRet = LocalHostName;
477 	}
478 done:
479 	return(pszRet);
480 }
481 uchar*
482 glblGetOversizeMsgErrorFile(rsconf_t *cnf)
483 {
484 	return cnf-&gt;globals.oversizeMsgErrorFile;
485 }
486 const uchar*
487 glblGetOperatingStateFile(rsconf_t *cnf)
488 {
489 	return cnf-&gt;globals.operatingStateFile;
490 }
491 int
492 glblGetOversizeMsgInputMode(rsconf_t *cnf)
493 {
494 	return cnf-&gt;globals.oversizeMsgInputMode;
495 }
496 int
497 glblReportOversizeMessage(rsconf_t *cnf)
498 {
499 	return cnf-&gt;globals.reportOversizeMsg;
500 }
501 void
502 glblReportChildProcessExit(rsconf_t *cnf, const uchar *name, pid_t pid, int status)
503 {
504 	DBGPRINTF("waitpid for child %ld returned status: %2.2x\n", (long) pid, status);
505 	if(cnf-&gt;globals.reportChildProcessExits == REPORT_CHILD_PROCESS_EXITS_NONE
506 		|| (cnf-&gt;globals.reportChildProcessExits == REPORT_CHILD_PROCESS_EXITS_ERRORS
507 			&amp;&amp; WIFEXITED(status) &amp;&amp; WEXITSTATUS(status) == 0)) {
508 		return;
509 	}
510 	if(WIFEXITED(status)) {
511 		int severity = WEXITSTATUS(status) == 0 ? LOG_INFO : LOG_WARNING;
512 		if(name != NULL) {
513 			LogMsg(0, NO_ERRCODE, severity, "program '%s' (pid %ld) exited with status %d",
514 					name, (long) pid, WEXITSTATUS(status));
515 		} else {
516 			LogMsg(0, NO_ERRCODE, severity, "child process (pid %ld) exited with status %d",
517 					(long) pid, WEXITSTATUS(status));
518 		}
519 	} else if(WIFSIGNALED(status)) {
520 		if(name != NULL) {
521 			LogMsg(0, NO_ERRCODE, LOG_WARNING, "program '%s' (pid %ld) terminated by signal %d",
522 					name, (long) pid, WTERMSIG(status));
523 		} else {
524 			LogMsg(0, NO_ERRCODE, LOG_WARNING, "child process (pid %ld) terminated by signal %d",
525 					(long) pid, WTERMSIG(status));
526 		}
527 	}
528 }
529 static rsRetVal
530 SetLocalDomain(uchar *newname)
531 {
532 	free(LocalDomain);
533 	LocalDomain = newname;
534 	return RS_RET_OK;
535 }
536 static uchar*
537 GetLocalDomain(void)
538 {
539 	return LocalDomain;
540 }
541 static rsRetVal
542 GenerateLocalHostNameProperty(void)
543 {
544 	uchar *pszPrev;
545 	int lenPrev;
546 	prop_t *hostnameNew;
547 	uchar *pszName;
548 	DEFiRet;
549 	if(propLocalHostNameToDelete != NULL)
550 		prop.Destruct(&amp;propLocalHostNameToDelete);
551 	if(LocalHostNameOverride == NULL) {
552 		if(LocalHostName == NULL)
553 			pszName = (uchar*) "[localhost]";
554 		else {
555 			if(GetPreserveFQDN() == 1)
556 				pszName = LocalFQDNName;
557 			else
558 				pszName = LocalHostName;
559 		}
560 	} else { 		pszName = LocalHostNameOverride;
561 	}
562 	DBGPRINTF("GenerateLocalHostName uses '%s'\n", pszName);
563 	if(propLocalHostName == NULL)
564 		pszPrev = (uchar*)""; 	else
565 		prop.GetString(propLocalHostName, &amp;pszPrev, &amp;lenPrev);
566 	if(ustrcmp(pszPrev, pszName)) {
567 		CHKiRet(prop.Construct(&amp;hostnameNew));
568 		CHKiRet(prop.SetString(hostnameNew, pszName, ustrlen(pszName)));
569 		CHKiRet(prop.ConstructFinalize(hostnameNew));
570 		propLocalHostNameToDelete = propLocalHostName;
571 		propLocalHostName = hostnameNew;
572 	}
573 finalize_it:
574 	RETiRet;
575 }
576 static prop_t*
577 GetLocalHostNameProp(void)
578 {
579 	return(propLocalHostName);
580 }
581 static rsRetVal
582 SetLocalFQDNName(uchar *newname)
583 {
584 	free(LocalFQDNName);
585 	LocalFQDNName = newname;
586 	return RS_RET_OK;
587 }
588 static uchar*
589 GetLocalFQDNName(void)
590 {
591 	return(LocalFQDNName == NULL ? (uchar*) "[localhost]" : LocalFQDNName);
592 }
593 static uchar*
594 GetWorkDir(rsconf_t *cnf)
595 {
596 	return(cnf-&gt;globals.pszWorkDir == NULL ? (uchar*) "" : cnf-&gt;globals.pszWorkDir);
597 }
598 const uchar *
599 glblGetWorkDirRaw(rsconf_t *cnf)
600 {
601 	return cnf-&gt;globals.pszWorkDir;
602 }
603 static uchar*
604 GetDfltNetstrmDrvr(rsconf_t *cnf)
605 {
606 	return(cnf-&gt;globals.pszDfltNetstrmDrvr == NULL ? DFLT_NETSTRM_DRVR : cnf-&gt;globals.pszDfltNetstrmDrvr);
607 }
608 static rsRetVal
609 SetSourceIPofLocalClient(uchar *newname)
610 {
611 	if(SourceIPofLocalClient != NULL) {
612 		free(SourceIPofLocalClient); }
613 	SourceIPofLocalClient = newname;
614 	return RS_RET_OK;
615 }
616 static uchar*
617 GetSourceIPofLocalClient(void)
618 {
619 	return(SourceIPofLocalClient);
620 }
621 BEGINobjQueryInterface(glbl)
622 CODESTARTobjQueryInterface(glbl)
623 	if(pIf-&gt;ifVersion != glblCURR_IF_VERSION) { 		ABORT_FINALIZE(RS_RET_INTERFACE_NOT_SUPPORTED);
624 	}
625 	pIf-&gt;GetWorkDir = GetWorkDir;
626 	pIf-&gt;GenerateLocalHostNameProperty = GenerateLocalHostNameProperty;
627 	pIf-&gt;GetLocalHostNameProp = GetLocalHostNameProp;
628 	pIf-&gt;GetLocalHostIP = GetLocalHostIP;
629 	pIf-&gt;SetGlobalInputTermination = SetGlobalInputTermination;
630 	pIf-&gt;GetGlobalInputTermState = GetGlobalInputTermState;
631 	pIf-&gt;GetSourceIPofLocalClient = GetSourceIPofLocalClient;		pIf-&gt;SetSourceIPofLocalClient = SetSourceIPofLocalClient;		pIf-&gt;GetDefPFFamily = getDefPFFamily;
632 	pIf-&gt;GetDisableDNS = GetDisableDNS;
633 	pIf-&gt;GetMaxLine = glblGetMaxLine;
634 	pIf-&gt;GetOptionDisallowWarning = GetOptionDisallowWarning;
635 	pIf-&gt;GetDfltNetstrmDrvrCAF = GetDfltNetstrmDrvrCAF;
636 	pIf-&gt;GetDfltNetstrmDrvrCertFile = GetDfltNetstrmDrvrCertFile;
637 	pIf-&gt;GetDfltNetstrmDrvrKeyFile = GetDfltNetstrmDrvrKeyFile;
638 	pIf-&gt;GetDfltNetstrmDrvr = GetDfltNetstrmDrvr;
639 	pIf-&gt;GetParserControlCharacterEscapePrefix = GetParserControlCharacterEscapePrefix;
640 	pIf-&gt;GetParserDropTrailingLFOnReception = GetParserDropTrailingLFOnReception;
641 	pIf-&gt;GetParserEscapeControlCharactersOnReceive = GetParserEscapeControlCharactersOnReceive;
642 	pIf-&gt;GetParserSpaceLFOnReceive = GetParserSpaceLFOnReceive;
643 	pIf-&gt;GetParserEscape8BitCharactersOnReceive = GetParserEscape8BitCharactersOnReceive;
644 	pIf-&gt;GetParserEscapeControlCharacterTab = GetParserEscapeControlCharacterTab;
645 #define SIMP_PROP(name) \
646 	pIf-&gt;Get##name = Get##name; \
647 	pIf-&gt;Set##name = Set##name;
648 	SIMP_PROP(PreserveFQDN);
649 	SIMP_PROP(DropMalPTRMsgs);
650 	SIMP_PROP(mainqCnfObj);
651 	SIMP_PROP(LocalFQDNName)
652 	SIMP_PROP(LocalHostName)
653 	SIMP_PROP(LocalDomain)
654 	SIMP_PROP(ParserEscapeControlCharactersCStyle)
655 	SIMP_PROP(ParseHOSTNAMEandTAG)
656 #ifdef USE_UNLIMITED_SELECT
657 	SIMP_PROP(FdSetSize)
658 #endif
659 #undef	SIMP_PROP
660 finalize_it:
661 ENDobjQueryInterface(glbl)
662 static rsRetVal resetConfigVariables(uchar __attribute__((unused)) *pp, void __attribute__((unused)) *pVal)
663 {
664 	free(loadConf-&gt;globals.pszDfltNetstrmDrvr);
665 	loadConf-&gt;globals.pszDfltNetstrmDrvr = NULL;
666 	free(loadConf-&gt;globals.pszDfltNetstrmDrvrCAF);
667 	loadConf-&gt;globals.pszDfltNetstrmDrvrCAF = NULL;
668 	free(loadConf-&gt;globals.pszDfltNetstrmDrvrKeyFile);
669 	loadConf-&gt;globals.pszDfltNetstrmDrvrKeyFile = NULL;
670 	free(loadConf-&gt;globals.pszDfltNetstrmDrvrCertFile);
671 	loadConf-&gt;globals.pszDfltNetstrmDrvrCertFile = NULL;
672 	free(LocalHostNameOverride);
673 	LocalHostNameOverride = NULL;
674 	free(loadConf-&gt;globals.oversizeMsgErrorFile);
675 	loadConf-&gt;globals.oversizeMsgErrorFile = NULL;
676 	loadConf-&gt;globals.oversizeMsgInputMode = glblOversizeMsgInputMode_Accept;
677 	loadConf-&gt;globals.reportChildProcessExits = REPORT_CHILD_PROCESS_EXITS_ERRORS;
678 	free(loadConf-&gt;globals.pszWorkDir);
679 	loadConf-&gt;globals.pszWorkDir = NULL;
680 	free((void*)loadConf-&gt;globals.operatingStateFile);
681 	loadConf-&gt;globals.operatingStateFile = NULL;
682 	loadConf-&gt;globals.bDropMalPTRMsgs = 0;
683 	bPreserveFQDN = 0;
684 	loadConf-&gt;globals.iMaxLine = 8192;
685 	loadConf-&gt;globals.reportOversizeMsg = 1;
686 	loadConf-&gt;globals.parser.cCCEscapeChar = '#';
687 	loadConf-&gt;globals.parser.bDropTrailingLF = 1;
688 	loadConf-&gt;globals.parser.bEscapeCCOnRcv = 1; 	loadConf-&gt;globals.parser.bSpaceLFOnRcv = 0;
689 	loadConf-&gt;globals.parser.bEscape8BitChars = 0; 	loadConf-&gt;globals.parser.bEscapeTab = 1; 	loadConf-&gt;globals.parser.bParserEscapeCCCStyle = 0;
690 #ifdef USE_UNLIMITED_SELECT
691 	iFdSetSize = howmany(FD_SETSIZE, __NFDBITS) * sizeof (fd_mask);
692 #endif
693 	return RS_RET_OK;
694 }
695 void
696 glblPrepCnf(void)
697 {
698 	free(mainqCnfObj);
699 	mainqCnfObj = NULL;
700 	free(cnfparamvals);
701 	cnfparamvals = NULL;
702 }
703 int
704 bs_arrcmp_glblDbgFiles(const void *s1, const void *s2)
705 {
706 	return strcmp((char*)s1, *(char**)s2);
707 }
708 void
709 glblProcessCnf(struct cnfobj *o)
710 {
711 	int i;
712 	cnfparamvals = nvlstGetParams(o-&gt;nvlst, &amp;paramblk, cnfparamvals);
713 	if(cnfparamvals == NULL) {
714 <a name="2"></a>		LogError(0, RS_RET_MISSING_CNFPARAMS, "error processing global "
715 				"config parameters [global(...)]");
716 		goto done;
717 <font color="#980517"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>	}
718 	if(Debug) {
719 		dbgprintf("glbl param blk after glblProcessCnf:\n");
720 		cnfparamsPrint(&amp;paramblk, cnfparamvals);
721 	}
722 	for(i = 0 ; i &lt; paramblk.nParams ; ++i) {
723 		if(!cnfparamvals[i].bUsed)
724 			continue;
725 		if(!strcmp(paramblk.descr[i].name, "processinternalmessages")) {
726 			loadConf-&gt;globals.bProcessInternalMessages = (int) cnfparamvals[i].val.d.n;</b></font>
727 			cnfparamvals[i].bUsed = TRUE;
728 		} else if(!strcmp(paramblk.descr[i].name, "internal.developeronly.options")) {
729 			loadConf-&gt;globals.glblDevOptions = (uint64_t) cnfparamvals[i].val.d.n;
730 			cnfparamvals[i].bUsed = TRUE;
731 		} else if(!strcmp(paramblk.descr[i].name, "stdlog.channelspec")) {
732 #ifndef ENABLE_LIBLOGGING_STDLOG
733 			LogError(0, RS_RET_ERR, "rsyslog wasn't "
734 				"compiled with liblogging-stdlog support. "
735 				"The 'stdlog.channelspec' parameter "
736 				"is ignored. Note: the syslog API is used instead.\n");
737 #else
738 			loadConf-&gt;globals.stdlog_chanspec = (uchar*) es_str2cstr(cnfparamvals[i].val.d.estr, NULL);
739 			stdlog_close(loadConf-&gt;globals.stdlog_hdl);
740 			loadConf-&gt;globals.stdlog_hdl = stdlog_open("rsyslogd", 0, STDLOG_SYSLOG,
741 					(char*) loadConf-&gt;globals.stdlog_chanspec);
742 			cnfparamvals[i].bUsed = TRUE;
743 #endif
744 		} else if(!strcmp(paramblk.descr[i].name, "operatingstatefile")) {
745 			if(loadConf-&gt;globals.operatingStateFile != NULL) {
746 				LogError(errno, RS_RET_PARAM_ERROR,
747 					"error: operatingStateFile already set to '%s' - "
748 					"new value ignored", loadConf-&gt;globals.operatingStateFile);
749 			} else {
750 				loadConf-&gt;globals.operatingStateFile =
751 					(uchar*) es_str2cstr(cnfparamvals[i].val.d.estr, NULL);
752 				osf_open();
753 			}
754 		} else if(!strcmp(paramblk.descr[i].name, "security.abortonidresolutionfail")) {
755 			loadConf-&gt;globals.abortOnIDResolutionFail = (int) cnfparamvals[i].val.d.n;
756 			cnfparamvals[i].bUsed = TRUE;
757 		}
758 	}
759 done:	return;
760 }
761 void
762 glblProcessMainQCnf(struct cnfobj *o)
763 {
764 	if(mainqCnfObj == NULL) {
765 		mainqCnfObj = o;
766 	} else {
767 		LogError(0, RS_RET_ERR, "main_queue() object can only be specified "
768 				"once - all but first ignored\n");
769 	}
770 }
771 void
772 glblDestructMainqCnfObj(void)
773 {
774 	if (mainqCnfObj != NULL) {
775 		nvlstChkUnused(mainqCnfObj-&gt;nvlst);
776 		cnfobjDestruct(mainqCnfObj);
777 		mainqCnfObj = NULL;
778 	}
779 }
780 static int
781 qs_arrcmp_glblDbgFiles(const void *s1, const void *s2)
782 {
783 	return strcmp(*((char**)s1), *((char**)s2));
784 }
785 static rsRetVal
786 do_setenv(const char *const var)
787 {
788 	char varname[128];
789 	const char *val = var;
790 	size_t i;
791 	DEFiRet;
792 	for(i = 0 ; *val != '=' ; ++i, ++val) {
793 		if(i == sizeof(varname)-i) {
794 			parser_errmsg("environment variable name too long "
795 				"[max %zu chars] or malformed entry: '%s'",
796 				sizeof(varname)-1, var);
797 			ABORT_FINALIZE(RS_RET_ERR_SETENV);
798 		}
799 		if(*val == '\0') {
800 			parser_errmsg("environment variable entry is missing "
801 				"equal sign (for value): '%s'", var);
802 			ABORT_FINALIZE(RS_RET_ERR_SETENV);
803 		}
804 		varname[i] = *val;
805 	}
806 	varname[i] = '\0';
807 	++val;
808 	DBGPRINTF("do_setenv, var '%s', val '%s'\n", varname, val);
809 	if(setenv(varname, val, 1) != 0) {
810 		char errStr[1024];
811 		rs_strerror_r(errno, errStr, sizeof(errStr));
812 		parser_errmsg("error setting environment variable "
813 			"'%s' to '%s': %s", varname, val, errStr);
814 		ABORT_FINALIZE(RS_RET_ERR_SETENV);
815 	}
816 finalize_it:
817 	RETiRet;
818 }
819 rsRetVal
820 glblDoneLoadCnf(void)
821 {
822 	int i;
823 	unsigned char *cstr;
824 	DEFiRet;
825 	CHKiRet(objUse(net, CORE_COMPONENT));
826 	sortTimezones(loadConf);
827 	DBGPRINTF("Timezone information table (%d entries):\n", loadConf-&gt;timezones.ntzinfos);
828 	displayTimezones(loadConf);
829 	if(cnfparamvals == NULL)
830 		goto finalize_it;
831 	for(i = 0 ; i &lt; paramblk.nParams ; ++i) {
832 		if(!cnfparamvals[i].bUsed)
833 			continue;
834 		if(!strcmp(paramblk.descr[i].name, "workdirectory")) {
835 			cstr = (uchar*) es_str2cstr(cnfparamvals[i].val.d.estr, NULL);
836 			setWorkDir(NULL, cstr);
837 		} else if(!strcmp(paramblk.descr[i].name, "variables.casesensitive")) {
838 			const int val = (int) cnfparamvals[i].val.d.n;
839 			fjson_global_do_case_sensitive_comparison(val);
840 			DBGPRINTF("global/config: set case sensitive variables to %d\n",
841 				val);
842 		} else if(!strcmp(paramblk.descr[i].name, "localhostname")) {
843 			free(LocalHostNameOverride);
844 			LocalHostNameOverride = (uchar*)
845 				es_str2cstr(cnfparamvals[i].val.d.estr, NULL);
846 		} else if(!strcmp(paramblk.descr[i].name, "defaultnetstreamdriverkeyfile")) {
847 			cstr = (uchar*) es_str2cstr(cnfparamvals[i].val.d.estr, NULL);
848 			setDfltNetstrmDrvrKeyFile(NULL, cstr);
849 		} else if(!strcmp(paramblk.descr[i].name, "defaultnetstreamdrivercertfile")) {
850 			cstr = (uchar*) es_str2cstr(cnfparamvals[i].val.d.estr, NULL);
851 			setDfltNetstrmDrvrCertFile(NULL, cstr);
852 		} else if(!strcmp(paramblk.descr[i].name, "defaultnetstreamdrivercafile")) {
853 			cstr = (uchar*) es_str2cstr(cnfparamvals[i].val.d.estr, NULL);
854 			setDfltNetstrmDrvrCAF(NULL, cstr);
855 		} else if(!strcmp(paramblk.descr[i].name, "defaultnetstreamdriver")) {
856 			cstr = (uchar*) es_str2cstr(cnfparamvals[i].val.d.estr, NULL);
857 			setDfltNetstrmDrvr(NULL, cstr);
858 		} else if(!strcmp(paramblk.descr[i].name, "preservefqdn")) {
859 			bPreserveFQDN = (int) cnfparamvals[i].val.d.n;
860 		} else if(!strcmp(paramblk.descr[i].name,
861 				"dropmsgswithmaliciousdnsptrrecords")) {
862 			loadConf-&gt;globals.bDropMalPTRMsgs = (int) cnfparamvals[i].val.d.n;
863 		} else if(!strcmp(paramblk.descr[i].name, "action.reportsuspension")) {
864 			loadConf-&gt;globals.bActionReportSuspension = (int) cnfparamvals[i].val.d.n;
865 		} else if(!strcmp(paramblk.descr[i].name, "action.reportsuspensioncontinuation")) {
866 			loadConf-&gt;globals.bActionReportSuspensionCont = (int) cnfparamvals[i].val.d.n;
867 		} else if(!strcmp(paramblk.descr[i].name, "maxmessagesize")) {
868 			setMaxLine(cnfparamvals[i].val.d.n);
869 		} else if(!strcmp(paramblk.descr[i].name, "oversizemsg.errorfile")) {
870 			free(loadConf-&gt;globals.oversizeMsgErrorFile);
871 			loadConf-&gt;globals.oversizeMsgErrorFile = (uchar*)es_str2cstr(cnfparamvals[i].val.d.estr, NULL);
872 		} else if(!strcmp(paramblk.descr[i].name, "oversizemsg.report")) {
873 			loadConf-&gt;globals.reportOversizeMsg = (int) cnfparamvals[i].val.d.n;
874 		} else if(!strcmp(paramblk.descr[i].name, "oversizemsg.input.mode")) {
875 			const char *const tmp = es_str2cstr(cnfparamvals[i].val.d.estr, NULL);
876 			setOversizeMsgInputMode((uchar*) tmp);
877 			free((void*)tmp);
878 		} else if(!strcmp(paramblk.descr[i].name, "reportchildprocessexits")) {
879 			const char *const tmp = es_str2cstr(cnfparamvals[i].val.d.estr, NULL);
880 			setReportChildProcessExits((uchar*) tmp);
881 			free((void*)tmp);
882 		} else if(!strcmp(paramblk.descr[i].name, "debug.onshutdown")) {
883 			loadConf-&gt;globals.debugOnShutdown = (int) cnfparamvals[i].val.d.n;
884 			LogError(0, RS_RET_OK, "debug: onShutdown set to %d", loadConf-&gt;globals.debugOnShutdown);
885 		} else if(!strcmp(paramblk.descr[i].name, "debug.gnutls")) {
886 			loadConf-&gt;globals.iGnuTLSLoglevel = (int) cnfparamvals[i].val.d.n;
887 		} else if(!strcmp(paramblk.descr[i].name, "debug.unloadmodules")) {
888 			glblUnloadModules = (int) cnfparamvals[i].val.d.n;
889 		} else if(!strcmp(paramblk.descr[i].name, "parser.controlcharacterescapeprefix")) {
890 			uchar* tmp = (uchar*) es_str2cstr(cnfparamvals[i].val.d.estr, NULL);
891 			setParserControlCharacterEscapePrefix(NULL, tmp);
892 			free(tmp);
893 		} else if(!strcmp(paramblk.descr[i].name, "parser.droptrailinglfonreception")) {
894 			const int tmp = (int) cnfparamvals[i].val.d.n;
895 			setParserDropTrailingLFOnReception(NULL, tmp);
896 		} else if(!strcmp(paramblk.descr[i].name, "parser.escapecontrolcharactersonreceive")) {
897 			const int tmp = (int) cnfparamvals[i].val.d.n;
898 			setParserEscapeControlCharactersOnReceive(NULL, tmp);
899 		} else if(!strcmp(paramblk.descr[i].name, "parser.spacelfonreceive")) {
900 			const int tmp = (int) cnfparamvals[i].val.d.n;
901 			setParserSpaceLFOnReceive(NULL, tmp);
902 		} else if(!strcmp(paramblk.descr[i].name, "parser.escape8bitcharactersonreceive")) {
903 			const int tmp = (int) cnfparamvals[i].val.d.n;
904 			setParserEscape8BitCharactersOnReceive(NULL, tmp);
905 		} else if(!strcmp(paramblk.descr[i].name, "parser.escapecontrolcharactertab")) {
906 			const int tmp = (int) cnfparamvals[i].val.d.n;
907 			setParserEscapeControlCharacterTab(NULL, tmp);
908 		} else if(!strcmp(paramblk.descr[i].name, "parser.escapecontrolcharacterscstyle")) {
909 			const int tmp = (int) cnfparamvals[i].val.d.n;
910 			SetParserEscapeControlCharactersCStyle(tmp);
911 		} else if(!strcmp(paramblk.descr[i].name, "parser.parsehostnameandtag")) {
912 			const int tmp = (int) cnfparamvals[i].val.d.n;
913 			SetParseHOSTNAMEandTAG(tmp);
914 		} else if(!strcmp(paramblk.descr[i].name, "parser.permitslashinprogramname")) {
915 			loadConf-&gt;globals.parser.bPermitSlashInProgramname = (int) cnfparamvals[i].val.d.n;
916 		} else if(!strcmp(paramblk.descr[i].name, "debug.logfile")) {
917 			if(pszAltDbgFileName == NULL) {
918 				pszAltDbgFileName = es_str2cstr(cnfparamvals[i].val.d.estr, NULL);
919 				if(altdbg != -1) {
920 					close(altdbg);
921 				}
922 				if((altdbg = open(pszAltDbgFileName, O_WRONLY|O_CREAT|O_TRUNC|O_NOCTTY
923 				|O_CLOEXEC, S_IRUSR|S_IWUSR)) == -1) {
924 					LogError(0, RS_RET_ERR, "debug log file '%s' could not be opened",
925 							pszAltDbgFileName);
926 				}
927 			}
928 <a name="1"></a>			LogError(0, RS_RET_OK, "debug log file is '%s', fd %d", pszAltDbgFileName, altdbg);
929 		} else if(!strcmp(paramblk.descr[i].name, "janitor.interval")) {
930 			loadConf-&gt;globals.janitorInterval = (int) cnfparamvals[i].val.d.n;
931 <font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>		} else if(!strcmp(paramblk.descr[i].name, "net.ipprotocol")) {
932 			char *proto = es_str2cstr(cnfparamvals[i].val.d.estr, NULL);
933 			if(!strcmp(proto, "unspecified")) {
934 				loadConf-&gt;globals.iDefPFFamily = PF_UNSPEC;
935 			} else if(!strcmp(proto, "ipv4-only")) {
936 				loadConf-&gt;globals.iDefPFFamily = PF_INET;
937 			} else if(!strcmp(proto, "ipv6-only")) {
938 				loadConf-&gt;globals.iDefPFFamily = PF_INET6;
939 			} else{</b></font>
940 				LogError(0, RS_RET_ERR, "invalid net.ipprotocol "
941 					"parameter '%s' -- ignored", proto);
942 			}
943 			free(proto);
944 		} else if(!strcmp(paramblk.descr[i].name, "senders.reportnew")) {
945 			loadConf-&gt;globals.reportNewSenders = (int) cnfparamvals[i].val.d.n;
946 		} else if(!strcmp(paramblk.descr[i].name, "senders.reportgoneaway")) {
947 			loadConf-&gt;globals.reportGoneAwaySenders = (int) cnfparamvals[i].val.d.n;
948 		} else if(!strcmp(paramblk.descr[i].name, "senders.timeoutafter")) {
949 			loadConf-&gt;globals.senderStatsTimeout = (int) cnfparamvals[i].val.d.n;
950 		} else if(!strcmp(paramblk.descr[i].name, "senders.keeptrack")) {
951 			loadConf-&gt;globals.senderKeepTrack = (int) cnfparamvals[i].val.d.n;
952 		} else if(!strcmp(paramblk.descr[i].name, "inputs.timeout.shutdown")) {
953 			loadConf-&gt;globals.inputTimeoutShutdown = (int) cnfparamvals[i].val.d.n;
954 		} else if(!strcmp(paramblk.descr[i].name, "privdrop.group.keepsupplemental")) {
955 			loadConf-&gt;globals.gidDropPrivKeepSupplemental = (int) cnfparamvals[i].val.d.n;
956 		} else if(!strcmp(paramblk.descr[i].name, "privdrop.group.id")) {
957 			loadConf-&gt;globals.gidDropPriv = (int) cnfparamvals[i].val.d.n;
958 		} else if(!strcmp(paramblk.descr[i].name, "privdrop.group.name")) {
959 			loadConf-&gt;globals.gidDropPriv = (int) cnfparamvals[i].val.d.n;
960 		} else if(!strcmp(paramblk.descr[i].name, "privdrop.user.id")) {
961 			loadConf-&gt;globals.uidDropPriv = (int) cnfparamvals[i].val.d.n;
962 		} else if(!strcmp(paramblk.descr[i].name, "privdrop.user.name")) {
963 			loadConf-&gt;globals.uidDropPriv = (int) cnfparamvals[i].val.d.n;
964 		} else if(!strcmp(paramblk.descr[i].name, "security.abortonidresolutionfail")) {
965 			loadConf-&gt;globals.abortOnIDResolutionFail = (int) cnfparamvals[i].val.d.n;
966 		} else if(!strcmp(paramblk.descr[i].name, "net.acladdhostnameonfail")) {
967 			loadConf-&gt;globals.ACLAddHostnameOnFail = (int) cnfparamvals[i].val.d.n;
968 		} else if(!strcmp(paramblk.descr[i].name, "net.aclresolvehostname")) {
969 			loadConf-&gt;globals.ACLDontResolve = !((int) cnfparamvals[i].val.d.n);
970 		} else if(!strcmp(paramblk.descr[i].name, "net.enabledns")) {
971 			SetDisableDNS(!((int) cnfparamvals[i].val.d.n));
972 		} else if(!strcmp(paramblk.descr[i].name, "net.permitwarning")) {
973 			SetOptionDisallowWarning(!((int) cnfparamvals[i].val.d.n));
974 		} else if(!strcmp(paramblk.descr[i].name, "abortonuncleanconfig")) {
975 			loadConf-&gt;globals.bAbortOnUncleanConfig = cnfparamvals[i].val.d.n;
976 		} else if(!strcmp(paramblk.descr[i].name, "internalmsg.ratelimit.burst")) {
977 			loadConf-&gt;globals.intMsgRateLimitBurst = (int) cnfparamvals[i].val.d.n;
978 		} else if(!strcmp(paramblk.descr[i].name, "internalmsg.ratelimit.interval")) {
979 			loadConf-&gt;globals.intMsgRateLimitItv = (int) cnfparamvals[i].val.d.n;
980 		} else if(!strcmp(paramblk.descr[i].name, "internalmsg.severity")) {
981 			loadConf-&gt;globals.intMsgsSeverityFilter = (int) cnfparamvals[i].val.d.n;
982 			if((loadConf-&gt;globals.intMsgsSeverityFilter &lt; 0) ||
983 			(loadConf-&gt;globals.intMsgsSeverityFilter &gt; 7)) {
984 				parser_errmsg("invalid internalmsg.severity value");
985 				loadConf-&gt;globals.intMsgsSeverityFilter = DFLT_INT_MSGS_SEV_FILTER;
986 			}
987 		} else if(!strcmp(paramblk.descr[i].name, "environment")) {
988 			for(int j = 0 ; j &lt;  cnfparamvals[i].val.d.ar-&gt;nmemb ; ++j) {
989 				char *const var = es_str2cstr(cnfparamvals[i].val.d.ar-&gt;arr[j], NULL);
990 				do_setenv(var);
991 				free(var);
992 			}
993 		} else if(!strcmp(paramblk.descr[i].name, "errormessagestostderr.maxnumber")) {
994 			loadConf-&gt;globals.maxErrMsgToStderr = (int) cnfparamvals[i].val.d.n;
995 		} else if(!strcmp(paramblk.descr[i].name, "debug.files")) {
996 			free(glblDbgFiles); 			glblDbgFilesNum = cnfparamvals[i].val.d.ar-&gt;nmemb;
997 			glblDbgFiles = (char**) malloc(cnfparamvals[i].val.d.ar-&gt;nmemb * sizeof(char*));
998 			for(int j = 0 ; j &lt;  cnfparamvals[i].val.d.ar-&gt;nmemb ; ++j) {
999 				glblDbgFiles[j] = es_str2cstr(cnfparamvals[i].val.d.ar-&gt;arr[j], NULL);
1000 			}
1001 			qsort(glblDbgFiles, glblDbgFilesNum, sizeof(char*), qs_arrcmp_glblDbgFiles);
1002 		} else if(!strcmp(paramblk.descr[i].name, "debug.whitelist")) {
1003 			glblDbgWhitelist = (int) cnfparamvals[i].val.d.n;
1004 		} else if(!strcmp(paramblk.descr[i].name, "shutdown.queue.doublesize")) {
1005 			loadConf-&gt;globals.shutdownQueueDoubleSize = (int) cnfparamvals[i].val.d.n;
1006 		} else if(!strcmp(paramblk.descr[i].name, "umask")) {
1007 			loadConf-&gt;globals.umask = (int) cnfparamvals[i].val.d.n;
1008 		} else if(!strcmp(paramblk.descr[i].name, "shutdown.enable.ctlc")) {
1009 			loadConf-&gt;globals.permitCtlC = (int) cnfparamvals[i].val.d.n;
1010 		} else if(!strcmp(paramblk.descr[i].name, "default.action.queue.timeoutshutdown")) {
1011 			loadConf-&gt;globals.actq_dflt_toQShutdown = cnfparamvals[i].val.d.n;
1012 		} else if(!strcmp(paramblk.descr[i].name, "default.action.queue.timeoutactioncompletion")) {
1013 			loadConf-&gt;globals.actq_dflt_toActShutdown = cnfparamvals[i].val.d.n;
1014 		} else if(!strcmp(paramblk.descr[i].name, "default.action.queue.timeoutenqueue")) {
1015 			loadConf-&gt;globals.actq_dflt_toEnq = cnfparamvals[i].val.d.n;
1016 		} else if(!strcmp(paramblk.descr[i].name, "default.action.queue.timeoutworkerthreadshutdown")) {
1017 			loadConf-&gt;globals.actq_dflt_toWrkShutdown = cnfparamvals[i].val.d.n;
1018 		} else if(!strcmp(paramblk.descr[i].name, "default.ruleset.queue.timeoutshutdown")) {
1019 			loadConf-&gt;globals.ruleset_dflt_toQShutdown = cnfparamvals[i].val.d.n;
1020 		} else if(!strcmp(paramblk.descr[i].name, "default.ruleset.queue.timeoutactioncompletion")) {
1021 			loadConf-&gt;globals.ruleset_dflt_toActShutdown = cnfparamvals[i].val.d.n;
1022 		} else if(!strcmp(paramblk.descr[i].name, "default.ruleset.queue.timeoutenqueue")) {
1023 			loadConf-&gt;globals.ruleset_dflt_toEnq = cnfparamvals[i].val.d.n;
1024 		} else if(!strcmp(paramblk.descr[i].name, "default.ruleset.queue.timeoutworkerthreadshutdown")) {
1025 			loadConf-&gt;globals.ruleset_dflt_toWrkShutdown = cnfparamvals[i].val.d.n;
1026 		} else if(!strcmp(paramblk.descr[i].name, "reverselookup.cache.ttl.default")) {
1027 			loadConf-&gt;globals.dnscacheDefaultTTL = cnfparamvals[i].val.d.n;
1028 		} else if(!strcmp(paramblk.descr[i].name, "reverselookup.cache.ttl.enable")) {
1029 			loadConf-&gt;globals.dnscacheEnableTTL = cnfparamvals[i].val.d.n;
1030 		} else if(!strcmp(paramblk.descr[i].name, "parser.supportcompressionextension")) {
1031 			loadConf-&gt;globals.bSupportCompressionExtension = cnfparamvals[i].val.d.n;
1032 		} else {
1033 			dbgprintf("glblDoneLoadCnf: program error, non-handled "
1034 				"param '%s'\n", paramblk.descr[i].name);
1035 		}
1036 	}
1037 	if(loadConf-&gt;globals.debugOnShutdown &amp;&amp; Debug != DEBUG_FULL) {
1038 		Debug = DEBUG_ONDEMAND;
1039 		stddbg = -1;
1040 	}
1041 finalize_it:	RETiRet;
1042 }
1043 BEGINAbstractObjClassInit(glbl, 1, OBJ_IS_CORE_MODULE) 	CHKiRet(objUse(prop, CORE_COMPONENT));
1044 	storeLocalHostIPIF((uchar*)"127.0.0.1");
1045 	CHKiRet(regCfSysLineHdlr((uchar *)"debugfile", 0, eCmdHdlrGetWord, setDebugFile, NULL, NULL));
1046 	CHKiRet(regCfSysLineHdlr((uchar *)"debuglevel", 0, eCmdHdlrInt, setDebugLevel, NULL, NULL));
1047 	CHKiRet(regCfSysLineHdlr((uchar *)"workdirectory", 0, eCmdHdlrGetWord, setWorkDir, NULL, NULL));
1048 	CHKiRet(regCfSysLineHdlr((uchar *)"dropmsgswithmaliciousdnsptrrecords", 0, eCmdHdlrBinary, SetDropMalPTRMsgs,
1049 	NULL, NULL));
1050 	CHKiRet(regCfSysLineHdlr((uchar *)"defaultnetstreamdriver", 0, eCmdHdlrGetWord, setDfltNetstrmDrvr, NULL,
1051 	NULL));
1052 	CHKiRet(regCfSysLineHdlr((uchar *)"defaultnetstreamdrivercafile", 0, eCmdHdlrGetWord,
1053 	setDfltNetstrmDrvrCAF, NULL, NULL));
1054 	CHKiRet(regCfSysLineHdlr((uchar *)"defaultnetstreamdriverkeyfile", 0, eCmdHdlrGetWord,
1055 	setDfltNetstrmDrvrKeyFile, NULL, NULL));
1056 	CHKiRet(regCfSysLineHdlr((uchar *)"defaultnetstreamdrivercertfile", 0, eCmdHdlrGetWord,
1057 	setDfltNetstrmDrvrCertFile, NULL, NULL));
1058 	CHKiRet(regCfSysLineHdlr((uchar *)"localhostname", 0, eCmdHdlrGetWord, NULL, &amp;LocalHostNameOverride, NULL));
1059 	CHKiRet(regCfSysLineHdlr((uchar *)"localhostipif", 0, eCmdHdlrGetWord, setLocalHostIPIF, NULL, NULL));
1060 	CHKiRet(regCfSysLineHdlr((uchar *)"optimizeforuniprocessor", 0, eCmdHdlrGoneAway, NULL, NULL, NULL));
1061 	CHKiRet(regCfSysLineHdlr((uchar *)"preservefqdn", 0, eCmdHdlrBinary, NULL, &amp;bPreserveFQDN, NULL));
1062 	CHKiRet(regCfSysLineHdlr((uchar *)"maxmessagesize", 0, eCmdHdlrSize, legacySetMaxMessageSize, NULL, NULL));
1063 	CHKiRet(regCfSysLineHdlr((uchar *)"controlcharacterescapeprefix", 0, eCmdHdlrGetChar,
1064 	setParserControlCharacterEscapePrefix, NULL, NULL));
1065 	CHKiRet(regCfSysLineHdlr((uchar *)"droptrailinglfonreception", 0, eCmdHdlrBinary,
1066 	setParserDropTrailingLFOnReception, NULL, NULL));
1067 	CHKiRet(regCfSysLineHdlr((uchar *)"escapecontrolcharactersonreceive", 0, eCmdHdlrBinary,
1068 	setParserEscapeControlCharactersOnReceive, NULL, NULL));
1069 	CHKiRet(regCfSysLineHdlr((uchar *)"spacelfonreceive", 0, eCmdHdlrBinary,
1070 	setParserSpaceLFOnReceive, NULL, NULL));
1071 	CHKiRet(regCfSysLineHdlr((uchar *)"escape8bitcharactersonreceive", 0, eCmdHdlrBinary,
1072 	setParserEscape8BitCharactersOnReceive,	NULL, NULL));
1073 	CHKiRet(regCfSysLineHdlr((uchar *)"escapecontrolcharactertab", 0, eCmdHdlrBinary,
1074 	setParserEscapeControlCharacterTab, NULL, NULL));
1075 	CHKiRet(regCfSysLineHdlr((uchar *)"resetconfigvariables", 1, eCmdHdlrCustomHandler,
1076 	resetConfigVariables, NULL, NULL));
1077 	INIT_ATOMIC_HELPER_MUT(mutTerminateInputs);
1078 ENDObjClassInit(glbl)
1079 BEGINObjClassExit(glbl, OBJ_IS_CORE_MODULE) 	free(LocalDomain);
1080 	free(LocalHostName);
1081 	free(LocalHostNameOverride);
1082 	free(LocalFQDNName);
1083 	objRelease(prop, CORE_COMPONENT);
1084 	if(propLocalHostNameToDelete != NULL)
1085 		prop.Destruct(&amp;propLocalHostNameToDelete);
1086 	DESTROY_ATOMIC_HELPER_MUT(mutTerminateInputs);
1087 ENDObjClassExit(glbl)
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
