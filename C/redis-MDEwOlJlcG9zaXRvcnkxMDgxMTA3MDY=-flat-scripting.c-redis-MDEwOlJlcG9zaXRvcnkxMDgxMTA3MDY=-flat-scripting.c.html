
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 30, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>redis-MDEwOlJlcG9zaXRvcnkxMDgxMTA3MDY=-flat-scripting.c</h3>
            <pre><code>1  #ifdef _WIN32
2  #include "Win32_Interop/Win32_Portability.h"
3  #endif
4  #include "server.h"
5  #include "sha1.h"
6  #include "rand.h"
7  #include "cluster.h"
8  #include <lua.h>
9  #include <lauxlib.h>
10  #include <lualib.h>
11  #include <ctype.h>
12  #include <math.h>
13  char *redisProtocolToLuaType_Int(lua_State *lua, char *reply);
14  char *redisProtocolToLuaType_Bulk(lua_State *lua, char *reply);
15  char *redisProtocolToLuaType_Status(lua_State *lua, char *reply);
16  char *redisProtocolToLuaType_Error(lua_State *lua, char *reply);
17  char *redisProtocolToLuaType_MultiBulk(lua_State *lua, char *reply);
18  int redis_math_random (lua_State *L);
19  int redis_math_randomseed (lua_State *L);
20  void ldbInit(void);
21  void ldbDisable(client *c);
22  void ldbEnable(client *c);
23  void evalGenericCommandWithDebugging(client *c, int evalsha);
24  void luaLdbLineHook(lua_State *lua, lua_Debug *ar);
25  void ldbLog(sds entry);
26  void ldbLogRedisReply(char *reply);
27  sds ldbCatStackValue(sds s, lua_State *lua, int idx);
28  #define LDB_BREAKPOINTS_MAX 64  &bsol;* Max number of breakpoints. */
29  #define LDB_MAX_LEN_DEFAULT 256 &bsol;* Default len limit for replies / var dumps. */
30  struct ldbState {
31      int fd;     &bsol;* Socket of the debugging client. */
32      int active; &bsol;* Are we debugging EVAL right now? */
33      int forked; &bsol;* Is this a fork()ed debugging session? */
34      list *logs; &bsol;* List of messages to send to the client. */
35      list *traces; &bsol;* Messages about Redis commands executed since last stop.*/
36      list *children; &bsol;* All forked debugging sessions pids. */
37      int bp[LDB_BREAKPOINTS_MAX]; &bsol;* An array of breakpoints line numbers. */
38      int bpcount; &bsol;* Number of valid entries inside bp. */
39      int step;   &bsol;* Stop at next line ragardless of breakpoints. */
40      int luabp;  &bsol;* Stop at next line because redis.breakpoint() was called. */
41      sds *src;   &bsol;* Lua script source code split by line. */
42      int lines;  &bsol;* Number of lines in 'src'. */
43      int currentline;    &bsol;* Current line number. */
44      sds cbuf;   &bsol;* Debugger client command buffer. */
45      size_t maxlen;  &bsol;* Max var dump / reply length. */
46      int maxlen_hint_sent; &bsol;* Did we already hint about "set maxlen"? */
47  } ldb;
48  void sha1hex(char *digest, char *script, size_t len) {
49      SHA1_CTX ctx;
50      unsigned char hash[20];
51      char *cset = "0123456789abcdef";
52      int j;
53      SHA1Init(&ctx);
54      SHA1Update(&ctx,(unsigned char*)script,len);
55      SHA1Final(hash,&ctx);
56      for (j = 0; j < 20; j++) {
57          digest[j*2] = cset[((hash[j]&0xF0)>>4)];
58          digest[j*2+1] = cset[(hash[j]&0xF)];
59      }
60      digest[40] = '\0';
61  }
62  char *redisProtocolToLuaType(lua_State *lua, char* reply) {
63      char *p = reply;
64      switch(*p) {
65      case ':': p = redisProtocolToLuaType_Int(lua,reply); break;
66      case '$': p = redisProtocolToLuaType_Bulk(lua,reply); break;
67      case '+': p = redisProtocolToLuaType_Status(lua,reply); break;
68      case '-': p = redisProtocolToLuaType_Error(lua,reply); break;
69      case '*': p = redisProtocolToLuaType_MultiBulk(lua,reply); break;
70      }
71      return p;
72  }
73  char *redisProtocolToLuaType_Int(lua_State *lua, char *reply) {
74      char *p = strchr(reply+1,'\r');
75      PORT_LONGLONG value;
76      string2ll(reply+1,p-reply-1,&value);
77      lua_pushnumber(lua,(lua_Number)value);
78      return p+2;
79  }
80  char *redisProtocolToLuaType_Bulk(lua_State *lua, char *reply) {
81      char *p = strchr(reply+1,'\r');
82      PORT_LONGLONG bulklen;
83      string2ll(reply+1,p-reply-1,&bulklen);
84      if (bulklen == -1) {
85          lua_pushboolean(lua,0);
86          return p+2;
87      } else {
88          lua_pushlstring(lua,p+2,(size_t)bulklen);                               WIN_PORT_FIX &bsol;* cast (size_t) */
89          return p+2+bulklen+2;
90      }
91  }
92  char *redisProtocolToLuaType_Status(lua_State *lua, char *reply) {
93      char *p = strchr(reply+1,'\r');
94      lua_newtable(lua);
95      lua_pushstring(lua,"ok");
96      lua_pushlstring(lua,reply+1,p-reply-1);
97      lua_settable(lua,-3);
98      return p+2;
99  }
100  char *redisProtocolToLuaType_Error(lua_State *lua, char *reply) {
101      char *p = strchr(reply+1,'\r');
102      lua_newtable(lua);
103      lua_pushstring(lua,"err");
104      lua_pushlstring(lua,reply+1,p-reply-1);
105      lua_settable(lua,-3);
106      return p+2;
107  }
108  char *redisProtocolToLuaType_MultiBulk(lua_State *lua, char *reply) {
109      char *p = strchr(reply+1,'\r');
110      PORT_LONGLONG mbulklen;
111      int j = 0;
112      string2ll(reply+1,p-reply-1,&mbulklen);
113      p += 2;
114      if (mbulklen == -1) {
115          lua_pushboolean(lua,0);
116          return p;
117      }
118      lua_newtable(lua);
119      for (j = 0; j < mbulklen; j++) {
120          lua_pushnumber(lua,j+1);
121          p = redisProtocolToLuaType(lua,p);
122          lua_settable(lua,-3);
123      }
124      return p;
125  }
126  void luaPushError(lua_State *lua, char *error) {
127      lua_Debug dbg;
128      if (ldb.active && ldb.step) {
129          ldbLog(sdscatprintf(sdsempty(),"<error> %s",error));
130      }
131      lua_newtable(lua);
132      lua_pushstring(lua,"err");
133      if(lua_getstack(lua, 1, &dbg) && lua_getinfo(lua, "nSl", &dbg)) {
134          sds msg = sdscatprintf(sdsempty(), "%s: %d: %s",
135              dbg.source, dbg.currentline, error);
136          lua_pushstring(lua, msg);
137          sdsfree(msg);
138      } else {
139          lua_pushstring(lua, error);
140      }
141      lua_settable(lua,-3);
142  }
143  int luaRaiseError(lua_State *lua) {
144      lua_pushstring(lua,"err");
145      lua_gettable(lua,-2);
146      return lua_error(lua);
147  }
148  void luaSortArray(lua_State *lua) {
149      lua_getglobal(lua,"table");
150      lua_pushstring(lua,"sort");
151      lua_gettable(lua,-2);       &bsol;* Stack: array, table, table.sort */
152      lua_pushvalue(lua,-3);      &bsol;* Stack: array, table, table.sort, array */
153      if (lua_pcall(lua,1,0,0)) {
154          lua_pop(lua,1);             &bsol;* Stack: array, table */
155          lua_pushstring(lua,"sort"); &bsol;* Stack: array, table, sort */
156          lua_gettable(lua,-2);       &bsol;* Stack: array, table, table.sort */
157          lua_pushvalue(lua,-3);      &bsol;* Stack: array, table, table.sort, array */
158          lua_getglobal(lua,"__redis__compare_helper");
159          lua_call(lua,2,0);
160      }
161      lua_pop(lua,1);             &bsol;* Stack: array (sorted) */
162  }
163  void luaReplyToRedisReply(client *c, lua_State *lua) {
164      int t = lua_type(lua,-1);
165      switch(t) {
166      case LUA_TSTRING:
167          addReplyBulkCBuffer(c,(char*)lua_tostring(lua,-1),lua_strlen(lua,-1));
168          break;
169      case LUA_TBOOLEAN:
170          addReply(c,lua_toboolean(lua,-1) ? shared.cone : shared.nullbulk);
171          break;
172      case LUA_TNUMBER:
173          addReplyLongLong(c,(PORT_LONGLONG)lua_tonumber(lua,-1));
174          break;
175      case LUA_TTABLE:
176          lua_pushstring(lua,"err");
177          lua_gettable(lua,-2);
178          t = lua_type(lua,-1);
179          if (t == LUA_TSTRING) {
180              sds err = sdsnew(lua_tostring(lua,-1));
181              sdsmapchars(err,"\r\n","  ",2);
182              addReplySds(c,sdscatprintf(sdsempty(),"-%s\r\n",err));
183              sdsfree(err);
184              lua_pop(lua,2);
185              return;
186          }
187          lua_pop(lua,1);
188          lua_pushstring(lua,"ok");
189          lua_gettable(lua,-2);
190          t = lua_type(lua,-1);
191          if (t == LUA_TSTRING) {
192              sds ok = sdsnew(lua_tostring(lua,-1));
193              sdsmapchars(ok,"\r\n","  ",2);
194              addReplySds(c,sdscatprintf(sdsempty(),"+%s\r\n",ok));
195              sdsfree(ok);
196              lua_pop(lua,1);
197          } else {
198              void *replylen = addDeferredMultiBulkLength(c);
199              int j = 1, mbulklen = 0;
200              lua_pop(lua,1); &bsol;* Discard the 'ok' field value we popped */
201              while(1) {
202                  lua_pushnumber(lua,j++);
203                  lua_gettable(lua,-2);
204                  t = lua_type(lua,-1);
205                  if (t == LUA_TNIL) {
206                      lua_pop(lua,1);
207                      break;
208                  }
209                  luaReplyToRedisReply(c, lua);
210                  mbulklen++;
211              }
212              setDeferredMultiBulkLength(c,replylen,mbulklen);
213          }
214          break;
215      default:
216          addReply(c,shared.nullbulk);
217      }
218      lua_pop(lua,1);
219  }
220  #define LUA_CMD_OBJCACHE_SIZE 32
221  #define LUA_CMD_OBJCACHE_MAX_LEN 64
222  int luaRedisGenericCommand(lua_State *lua, int raise_error) {
223      int j, argc = lua_gettop(lua);
224      struct redisCommand *cmd;
225      client *c = server.lua_client;
226      sds reply;
227      static robj **argv = NULL;
228      static int argv_size = 0;
229      static robj *cached_objects[LUA_CMD_OBJCACHE_SIZE];
230      static size_t cached_objects_len[LUA_CMD_OBJCACHE_SIZE];
231      static int inuse = 0;   &bsol;* Recursive calls detection. */
232      if (server.lua_multi_emitted || (server.lua_caller->flags & CLIENT_MULTI)) {
233          c->flags |= CLIENT_MULTI;
234      } else {
235          c->flags &= ~CLIENT_MULTI;
236      }
237      if (inuse) {
238          char *recursion_warning =
239              "luaRedisGenericCommand() recursive call detected. "
240              "Are you doing funny stuff with Lua debug hooks?";
241          serverLog(LL_WARNING,"%s",recursion_warning);
242          luaPushError(lua,recursion_warning);
243          return 1;
244      }
245      inuse++;
246      if (argc == 0) {
247          luaPushError(lua,
248              "Please specify at least one argument for redis.call()");
249          inuse--;
250          return raise_error ? luaRaiseError(lua) : 1;
251      }
252      if (argv_size < argc) {
253          argv = zrealloc(argv,sizeof(robj*)*argc);
254          argv_size = argc;
255      }
256      for (j = 0; j < argc; j++) {
257          char *obj_s;
258          size_t obj_len;
259          char dbuf[64];
260          if (lua_type(lua,j+1) == LUA_TNUMBER) {
261              lua_Number num = lua_tonumber(lua,j+1);
262              obj_len = snprintf(dbuf,sizeof(dbuf),"%.17g",(double)num);
263              obj_s = dbuf;
264          } else {
265              obj_s = (char*)lua_tolstring(lua,j+1,&obj_len);
266              if (obj_s == NULL) break; &bsol;* Not a string. */
267          }
268          if (j < LUA_CMD_OBJCACHE_SIZE && cached_objects[j] &&
269              cached_objects_len[j] >= obj_len)
270          {
271              sds s = cached_objects[j]->ptr;
272              argv[j] = cached_objects[j];
273              cached_objects[j] = NULL;
274              memcpy(s,obj_s,obj_len+1);
275              sdssetlen(s, obj_len);
276          } else {
277              argv[j] = createStringObject(obj_s, obj_len);
278          }
279      }
280      if (j != argc) {
281          j--;
282          while (j >= 0) {
283              decrRefCount(argv[j]);
284              j--;
285          }
286          luaPushError(lua,
287              "Lua redis() command arguments must be strings or integers");
288          inuse--;
289          return raise_error ? luaRaiseError(lua) : 1;
290      }
291      c->argv = argv;
292      c->argc = argc;
293      moduleCallCommandFilters(c);
294      argv = c->argv;
295      argc = c->argc;
296      if (ldb.active && ldb.step) {
297          sds cmdlog = sdsnew("<redis>");
298          for (j = 0; j < c->argc; j++) {
299              if (j == 10) {
300                  cmdlog = sdscatprintf(cmdlog," ... (%d more)",
301                      c->argc-j-1);
302                  break;
303              } else {
304                  cmdlog = sdscatlen(cmdlog," ",1);
305                  cmdlog = sdscatsds(cmdlog,c->argv[j]->ptr);
306              }
307          }
308          ldbLog(cmdlog);
309      }
310      cmd = lookupCommand(argv[0]->ptr);
311      if (!cmd || ((cmd->arity > 0 && cmd->arity != argc) ||
312                     (argc < -cmd->arity)))
313      {
314          if (cmd)
315              luaPushError(lua,
316                  "Wrong number of args calling Redis command From Lua script");
317          else
318              luaPushError(lua,"Unknown Redis command called from Lua script");
319          goto cleanup;
320      }
321      c->cmd = c->lastcmd = cmd;
322      if (cmd->flags & CMD_NOSCRIPT) {
323          luaPushError(lua, "This Redis command is not allowed from scripts");
324          goto cleanup;
325      }
326      if (cmd->flags & CMD_WRITE) {
327          int deny_write_type = writeCommandsDeniedByDiskError();
328          if (server.lua_random_dirty && !server.lua_replicate_commands) {
329              luaPushError(lua,
330                  "Write commands not allowed after non deterministic commands. Call redis.replicate_commands() at the start of your script in order to switch to single commands replication mode.");
331              goto cleanup;
332          } else if (server.masterhost && server.repl_slave_ro &&
333                     !server.loading &&
334                     !(server.lua_caller->flags & CLIENT_MASTER))
335          {
336              luaPushError(lua, shared.roslaveerr->ptr);
337              goto cleanup;
338          } else if (deny_write_type != DISK_ERROR_TYPE_NONE) {
339              if (deny_write_type == DISK_ERROR_TYPE_RDB) {
340                  luaPushError(lua, shared.bgsaveerr->ptr);
341              } else {
342                  sds aof_write_err = sdscatfmt(sdsempty(),
343                      "-MISCONF Errors writing to the AOF file: %s\r\n",
344                      strerror(server.aof_last_write_errno));
345                  luaPushError(lua, aof_write_err);
346                  sdsfree(aof_write_err);
347              }
348              goto cleanup;
349          }
350      }
351      if (server.maxmemory &&             &bsol;* Maxmemory is actually enabled. */
352          !server.loading &&              &bsol;* Don't care about mem if loading. */
353          !server.masterhost &&           &bsol;* Slave must execute the script. */
354          server.lua_write_dirty == 0 &&  &bsol;* Script had no side effects so far. */
355          server.lua_oom &&               &bsol;* Detected OOM when script start. */
356          (cmd->flags & CMD_DENYOOM))
357      {
358          luaPushError(lua, shared.oomerr->ptr);
359          goto cleanup;
360      }
361      if (cmd->flags & CMD_RANDOM) server.lua_random_dirty = 1;
362      if (cmd->flags & CMD_WRITE) server.lua_write_dirty = 1;
363      if (server.cluster_enabled && !server.loading &&
364          !(server.lua_caller->flags & CLIENT_MASTER))
365      {
366          c->flags &= ~(CLIENT_READONLY|CLIENT_ASKING);
367          c->flags |= server.lua_caller->flags & (CLIENT_READONLY|CLIENT_ASKING);
368          if (getNodeByQuery(c,c->cmd,c->argv,c->argc,NULL,NULL) !=
369                             server.cluster->myself)
370          {
371              luaPushError(lua,
372                  "Lua script attempted to access a non local key in a "
373                  "cluster node");
374              goto cleanup;
375          }
376      }
377      if (server.lua_replicate_commands &&
378          !server.lua_multi_emitted &&
379          !(server.lua_caller->flags & CLIENT_MULTI) &&
380          server.lua_write_dirty &&
381          server.lua_repl != PROPAGATE_NONE)
382      {
383          execCommandPropagateMulti(server.lua_caller);
384          server.lua_multi_emitted = 1;
385      }
386      int call_flags = CMD_CALL_SLOWLOG | CMD_CALL_STATS;
387      if (server.lua_replicate_commands) {
388          if (server.lua_repl & PROPAGATE_AOF)
389              call_flags |= CMD_CALL_PROPAGATE_AOF;
390          if (server.lua_repl & PROPAGATE_REPL)
391              call_flags |= CMD_CALL_PROPAGATE_REPL;
392      }
393      call(c,call_flags);
394      if (listLength(c->reply) == 0 && c->bufpos < PROTO_REPLY_CHUNK_BYTES) {
395          c->buf[c->bufpos] = '\0';
396          reply = c->buf;
397          c->bufpos = 0;
398      } else {
399          reply = sdsnewlen(c->buf,c->bufpos);
400          c->bufpos = 0;
401          while(listLength(c->reply)) {
402              clientReplyBlock *o = listNodeValue(listFirst(c->reply));
403              reply = sdscatlen(reply,o->buf,o->used);
404              listDelNode(c->reply,listFirst(c->reply));
405          }
406      }
407      if (raise_error && reply[0] != '-') raise_error = 0;
408      redisProtocolToLuaType(lua,reply);
409      if (ldb.active && ldb.step)
410          ldbLogRedisReply(reply);
411      if ((cmd->flags & CMD_SORT_FOR_SCRIPT) &&
412          (server.lua_replicate_commands == 0) &&
413          (reply[0] == '*' && reply[1] != '-')) {
414              luaSortArray(lua);
415      }
416      if (reply != c->buf) sdsfree(reply);
417      c->reply_bytes = 0;
418  cleanup:
419      for (j = 0; j < c->argc; j++) {
420          robj *o = c->argv[j];
421          if (j < LUA_CMD_OBJCACHE_SIZE &&
422              o->refcount == 1 &&
423              (o->encoding == OBJ_ENCODING_RAW ||
424               o->encoding == OBJ_ENCODING_EMBSTR) &&
425              sdslen(o->ptr) <= LUA_CMD_OBJCACHE_MAX_LEN)
426          {
427              sds s = o->ptr;
428              if (cached_objects[j]) decrRefCount(cached_objects[j]);
429              cached_objects[j] = o;
430              cached_objects_len[j] = sdsalloc(s);
431          } else {
432              decrRefCount(o);
433          }
434      }
435      if (c->argv != argv) {
436          zfree(c->argv);
437          argv = NULL;
438          argv_size = 0;
439      }
440      if (raise_error) {
441          inuse--;
442          return luaRaiseError(lua);
443      }
444      inuse--;
445      return 1;
446  }
447  int luaRedisCallCommand(lua_State *lua) {
448      return luaRedisGenericCommand(lua,1);
449  }
450  int luaRedisPCallCommand(lua_State *lua) {
451      return luaRedisGenericCommand(lua,0);
452  }
453  int luaRedisSha1hexCommand(lua_State *lua) {
454      int argc = lua_gettop(lua);
455      char digest[41];
456      size_t len;
457      char *s;
458      if (argc != 1) {
459          lua_pushstring(lua, "wrong number of arguments");
460          return lua_error(lua);
461      }
462      s = (char*)lua_tolstring(lua,1,&len);
463      sha1hex(digest,s,len);
464      lua_pushstring(lua,digest);
465      return 1;
466  }
467  int luaRedisReturnSingleFieldTable(lua_State *lua, char *field) {
468      if (lua_gettop(lua) != 1 || lua_type(lua,-1) != LUA_TSTRING) {
469          luaPushError(lua, "wrong number or type of arguments");
470          return 1;
471      }
472      lua_newtable(lua);
473      lua_pushstring(lua, field);
474      lua_pushvalue(lua, -3);
475      lua_settable(lua, -3);
476      return 1;
477  }
478  int luaRedisErrorReplyCommand(lua_State *lua) {
479      return luaRedisReturnSingleFieldTable(lua,"err");
480  }
481  int luaRedisStatusReplyCommand(lua_State *lua) {
482      return luaRedisReturnSingleFieldTable(lua,"ok");
483  }
484  int luaRedisReplicateCommandsCommand(lua_State *lua) {
485      if (server.lua_write_dirty) {
486          lua_pushboolean(lua,0);
487      } else {
488          server.lua_replicate_commands = 1;
489          redisSrand48(rand());
490          lua_pushboolean(lua,1);
491      }
492      return 1;
493  }
494  int luaRedisBreakpointCommand(lua_State *lua) {
495      if (ldb.active) {
496          ldb.luabp = 1;
497          lua_pushboolean(lua,1);
498      } else {
499          lua_pushboolean(lua,0);
500      }
501      return 1;
502  }
503  int luaRedisDebugCommand(lua_State *lua) {
504      if (!ldb.active) return 0;
505      int argc = lua_gettop(lua);
506      sds log = sdscatprintf(sdsempty(),"<debug> line %d: ", ldb.currentline);
507      while(argc--) {
508          log = ldbCatStackValue(log,lua,-1 - argc);
509          if (argc != 0) log = sdscatlen(log,", ",2);
510      }
511      ldbLog(log);
512      return 0;
513  }
514  int luaRedisSetReplCommand(lua_State *lua) {
515      int argc = lua_gettop(lua);
516      int flags;
517      if (server.lua_replicate_commands == 0) {
518          lua_pushstring(lua, "You can set the replication behavior only after turning on single commands replication with redis.replicate_commands().");
519          return lua_error(lua);
520      } else if (argc != 1) {
521          lua_pushstring(lua, "redis.set_repl() requires two arguments.");
522          return lua_error(lua);
523      }
524      flags = lua_tonumber(lua,-1);
525      if ((flags & ~(PROPAGATE_AOF|PROPAGATE_REPL)) != 0) {
526          lua_pushstring(lua, "Invalid replication flags. Use REPL_AOF, REPL_REPLICA, REPL_ALL or REPL_NONE.");
527          return lua_error(lua);
528      }
529      server.lua_repl = flags;
530      return 0;
531  }
532  int luaLogCommand(lua_State *lua) {
533      int j, argc = lua_gettop(lua);
534      int level;
535      sds log;
536      if (argc < 2) {
537          lua_pushstring(lua, "redis.log() requires two arguments or more.");
538          return lua_error(lua);
539      } else if (!lua_isnumber(lua,-argc)) {
540          lua_pushstring(lua, "First argument must be a number (log level).");
541          return lua_error(lua);
542      }
543      level = (int)lua_tonumber(lua,-argc);                                       WIN_PORT_FIX &bsol;* cast (int) */
544      if (level < LL_DEBUG || level > LL_WARNING) {
545          lua_pushstring(lua, "Invalid debug level.");
546          return lua_error(lua);
547      }
548      log = sdsempty();
549      for (j = 1; j < argc; j++) {
550          size_t len;
551          char *s;
552          s = (char*)lua_tolstring(lua,(-argc)+j,&len);
553          if (s) {
554              if (j != 1) log = sdscatlen(log," ",1);
555              log = sdscatlen(log,s,len);
556          }
557      }
558      serverLogRaw(level,log);
559      sdsfree(log);
560      return 0;
561  }
562  void luaLoadLib(lua_State *lua, const char *libname, lua_CFunction luafunc) {
563    lua_pushcfunction(lua, luafunc);
564    lua_pushstring(lua, libname);
565    lua_call(lua, 1, 0);
566  }
567  LUALIB_API int (luaopen_cjson) (lua_State *L);
568  LUALIB_API int (luaopen_struct) (lua_State *L);
569  LUALIB_API int (luaopen_cmsgpack) (lua_State *L);
570  LUALIB_API int (luaopen_bit) (lua_State *L);
571  void luaLoadLibraries(lua_State *lua) {
572      luaLoadLib(lua, "", luaopen_base);
573      luaLoadLib(lua, LUA_TABLIBNAME, luaopen_table);
574      luaLoadLib(lua, LUA_STRLIBNAME, luaopen_string);
575      luaLoadLib(lua, LUA_MATHLIBNAME, luaopen_math);
576      luaLoadLib(lua, LUA_DBLIBNAME, luaopen_debug);
577      luaLoadLib(lua, "cjson", luaopen_cjson);
578      luaLoadLib(lua, "struct", luaopen_struct);
579      luaLoadLib(lua, "cmsgpack", luaopen_cmsgpack);
580      luaLoadLib(lua, "bit", luaopen_bit);
581  #if 0 &bsol;* Stuff that we don't load currently, for sandboxing concerns. */
582      luaLoadLib(lua, LUA_LOADLIBNAME, luaopen_package);
583      luaLoadLib(lua, LUA_OSLIBNAME, luaopen_os);
584  #endif
585  }
586  void luaRemoveUnsupportedFunctions(lua_State *lua) {
587      lua_pushnil(lua);
588      lua_setglobal(lua,"loadfile");
589      lua_pushnil(lua);
590      lua_setglobal(lua,"dofile");
591  }
592  void scriptingEnableGlobalsProtection(lua_State *lua) {
593      char *s[32];
594      sds code = sdsempty();
595      int j = 0;
596      s[j++]="local dbg=debug\n";
597      s[j++]="local mt = {}\n";
598      s[j++]="setmetatable(_G, mt)\n";
599      s[j++]="mt.__newindex = function (t, n, v)\n";
600      s[j++]="  if dbg.getinfo(2) then\n";
601      s[j++]="    local w = dbg.getinfo(2, \"S\").what\n";
602      s[j++]="    if w ~= \"main\" and w ~= \"C\" then\n";
603      s[j++]="      error(\"Script attempted to create global variable '\"..tostring(n)..\"'\", 2)\n";
604      s[j++]="    end\n";
605      s[j++]="  end\n";
606      s[j++]="  rawset(t, n, v)\n";
607      s[j++]="end\n";
608      s[j++]="mt.__index = function (t, n)\n";
609      s[j++]="  if dbg.getinfo(2) and dbg.getinfo(2, \"S\").what ~= \"C\" then\n";
610      s[j++]="    error(\"Script attempted to access nonexistent global variable '\"..tostring(n)..\"'\", 2)\n";
611      s[j++]="  end\n";
612      s[j++]="  return rawget(t, n)\n";
613      s[j++]="end\n";
614      s[j++]="debug = nil\n";
615      s[j++]=NULL;
616      for (j = 0; s[j] != NULL; j++) code = sdscatlen(code,s[j],strlen(s[j]));
617      luaL_loadbuffer(lua,code,sdslen(code),"@enable_strict_lua");
618      lua_pcall(lua,0,0,0);
619      sdsfree(code);
620  }
621  void scriptingInit(int setup) {
622      lua_State *lua = lua_open();
623      if (setup) {
624          server.lua_client = NULL;
625          server.lua_caller = NULL;
626          server.lua_timedout = 0;
627          ldbInit();
628      }
629      luaLoadLibraries(lua);
630      luaRemoveUnsupportedFunctions(lua);
631      server.lua_scripts = dictCreate(&shaScriptObjectDictType,NULL);
632      server.lua_scripts_mem = 0;
633      lua_newtable(lua);
634      lua_pushstring(lua,"call");
635      lua_pushcfunction(lua,luaRedisCallCommand);
636      lua_settable(lua,-3);
637      lua_pushstring(lua,"pcall");
638      lua_pushcfunction(lua,luaRedisPCallCommand);
639      lua_settable(lua,-3);
640      lua_pushstring(lua,"log");
641      lua_pushcfunction(lua,luaLogCommand);
642      lua_settable(lua,-3);
643      lua_pushstring(lua,"LOG_DEBUG");
644      lua_pushnumber(lua,LL_DEBUG);
645      lua_settable(lua,-3);
646      lua_pushstring(lua,"LOG_VERBOSE");
647      lua_pushnumber(lua,LL_VERBOSE);
648      lua_settable(lua,-3);
649      lua_pushstring(lua,"LOG_NOTICE");
650      lua_pushnumber(lua,LL_NOTICE);
651      lua_settable(lua,-3);
652      lua_pushstring(lua,"LOG_WARNING");
653      lua_pushnumber(lua,LL_WARNING);
654      lua_settable(lua,-3);
655      lua_pushstring(lua, "sha1hex");
656      lua_pushcfunction(lua, luaRedisSha1hexCommand);
657      lua_settable(lua, -3);
658      lua_pushstring(lua, "error_reply");
659      lua_pushcfunction(lua, luaRedisErrorReplyCommand);
660      lua_settable(lua, -3);
661      lua_pushstring(lua, "status_reply");
662      lua_pushcfunction(lua, luaRedisStatusReplyCommand);
663      lua_settable(lua, -3);
664      lua_pushstring(lua, "replicate_commands");
665      lua_pushcfunction(lua, luaRedisReplicateCommandsCommand);
666      lua_settable(lua, -3);
667      lua_pushstring(lua,"set_repl");
668      lua_pushcfunction(lua,luaRedisSetReplCommand);
669      lua_settable(lua,-3);
670      lua_pushstring(lua,"REPL_NONE");
671      lua_pushnumber(lua,PROPAGATE_NONE);
672      lua_settable(lua,-3);
673      lua_pushstring(lua,"REPL_AOF");
674      lua_pushnumber(lua,PROPAGATE_AOF);
675      lua_settable(lua,-3);
676      lua_pushstring(lua,"REPL_SLAVE");
677      lua_pushnumber(lua,PROPAGATE_REPL);
678      lua_settable(lua,-3);
679      lua_pushstring(lua,"REPL_REPLICA");
680      lua_pushnumber(lua,PROPAGATE_REPL);
681      lua_settable(lua,-3);
682      lua_pushstring(lua,"REPL_ALL");
683      lua_pushnumber(lua,PROPAGATE_AOF|PROPAGATE_REPL);
684      lua_settable(lua,-3);
685      lua_pushstring(lua,"breakpoint");
686      lua_pushcfunction(lua,luaRedisBreakpointCommand);
687      lua_settable(lua,-3);
688      lua_pushstring(lua,"debug");
689      lua_pushcfunction(lua,luaRedisDebugCommand);
690      lua_settable(lua,-3);
691      lua_setglobal(lua,"redis");
692      lua_getglobal(lua,"math");
693      lua_pushstring(lua,"random");
694      lua_pushcfunction(lua,redis_math_random);
695      lua_settable(lua,-3);
696      lua_pushstring(lua,"randomseed");
697      lua_pushcfunction(lua,redis_math_randomseed);
698      lua_settable(lua,-3);
699      lua_setglobal(lua,"math");
700      {
701          char *compare_func =    "function __redis__compare_helper(a,b)\n"
702                                  "  if a == false then a = '' end\n"
<span onclick='openModal()' class='match'>703                                  "  if b == false then b = '' end\n"
704                                  "  return a<b\n"
705                                  "end\n";
706          luaL_loadbuffer(lua,compare_func,strlen(compare_func),"@cmp_func_def");
707          lua_pcall(lua,0,0,0);
708      }
709      {
</span>710          char *errh_func =       "local dbg = debug\n"
711                                  "function __redis__err__handler(err)\n"
712                                  "  local i = dbg.getinfo(2,'nSl')\n"
713                                  "  if i and i.what == 'C' then\n"
714                                  "    i = dbg.getinfo(3,'nSl')\n"
715                                  "  end\n"
716                                  "  if i then\n"
717                                  "    return i.source .. ':' .. i.currentline .. ': ' .. err\n"
718                                  "  else\n"
719                                  "    return err\n"
720                                  "  end\n"
721                                  "end\n";
722          luaL_loadbuffer(lua,errh_func,strlen(errh_func),"@err_handler_def");
723          lua_pcall(lua,0,0,0);
724      }
725      if (server.lua_client == NULL) {
726          server.lua_client = createClient(-1);
727          server.lua_client->flags |= CLIENT_LUA;
728      }
729      scriptingEnableGlobalsProtection(lua);
730      server.lua = lua;
731  }
732  void scriptingRelease(void) {
733      dictRelease(server.lua_scripts);
734      server.lua_scripts_mem = 0;
735      lua_close(server.lua);
736  }
737  void scriptingReset(void) {
738      scriptingRelease();
739      scriptingInit(0);
740  }
741  void luaSetGlobalArray(lua_State *lua, char *var, robj **elev, int elec) {
742      int j;
743      lua_newtable(lua);
744      for (j = 0; j < elec; j++) {
745          lua_pushlstring(lua,(char*)elev[j]->ptr,sdslen(elev[j]->ptr));
746          lua_rawseti(lua,-2,j+1);
747      }
748      lua_setglobal(lua,var);
749  }
750  int redis_math_random (lua_State *L) {
751    lua_Number r = (lua_Number)(redisLrand48()%REDIS_LRAND48_MAX) /
752                                  (lua_Number)REDIS_LRAND48_MAX;
753    switch (lua_gettop(L)) {  &bsol;* check number of arguments */
754      case 0: {  &bsol;* no arguments */
755        lua_pushnumber(L, r);  &bsol;* Number between 0 and 1 */
756        break;
757      }
758      case 1: {  &bsol;* only upper limit */
759        int u = luaL_checkint(L, 1);
760        luaL_argcheck(L, 1<=u, 1, "interval is empty");
761        lua_pushnumber(L, floor(r*u)+1);  &bsol;* int between 1 and `u' */
762        break;
763      }
764      case 2: {  &bsol;* lower and upper limits */
765        int l = luaL_checkint(L, 1);
766        int u = luaL_checkint(L, 2);
767        luaL_argcheck(L, l<=u, 2, "interval is empty");
768        lua_pushnumber(L, floor(r*(u-l+1))+l);  &bsol;* int between `l' and `u' */
769        break;
770      }
771      default: return luaL_error(L, "wrong number of arguments");
772    }
773    return 1;
774  }
775  int redis_math_randomseed (lua_State *L) {
776    redisSrand48(luaL_checkint(L, 1));
777    return 0;
778  }
779  sds luaCreateFunction(client *c, lua_State *lua, robj *body) {
780      char funcname[43];
781      dictEntry *de;
782      funcname[0] = 'f';
783      funcname[1] = '_';
784      sha1hex(funcname+2,body->ptr,sdslen(body->ptr));
785      sds sha = sdsnewlen(funcname+2,40);
786      if ((de = dictFind(server.lua_scripts,sha)) != NULL) {
787          sdsfree(sha);
788          return dictGetKey(de);
789      }
790      sds funcdef = sdsempty();
791      funcdef = sdscat(funcdef,"function ");
792      funcdef = sdscatlen(funcdef,funcname,42);
793      funcdef = sdscatlen(funcdef,"() ",3);
794      funcdef = sdscatlen(funcdef,body->ptr,sdslen(body->ptr));
795      funcdef = sdscatlen(funcdef,"\nend",4);
796      if (luaL_loadbuffer(lua,funcdef,sdslen(funcdef),"@user_script")) {
797          if (c != NULL) {
798              addReplyErrorFormat(c,
799                  "Error compiling script (new function): %s\n",
800                  lua_tostring(lua,-1));
801          }
802          lua_pop(lua,1);
803          sdsfree(sha);
804          sdsfree(funcdef);
805          return NULL;
806      }
807      sdsfree(funcdef);
808      if (lua_pcall(lua,0,0,0)) {
809          if (c != NULL) {
810              addReplyErrorFormat(c,"Error running script (new function): %s\n",
811                  lua_tostring(lua,-1));
812          }
813          lua_pop(lua,1);
814          sdsfree(sha);
815          return NULL;
816      }
817      int retval = dictAdd(server.lua_scripts,sha,body);
818      serverAssertWithInfo(c ? c : server.lua_client,NULL,retval == DICT_OK);
819      server.lua_scripts_mem += sdsZmallocSize(sha) + getStringObjectSdsUsedMemory(body);
820      incrRefCount(body);
821      return sha;
822  }
823  void luaMaskCountHook(lua_State *lua, lua_Debug *ar) {
824      PORT_LONGLONG elapsed = mstime() - server.lua_time_start;
825      UNUSED(ar);
826      UNUSED(lua);
827      if (elapsed >= server.lua_time_limit && server.lua_timedout == 0) {
828          serverLog(LL_WARNING,"Lua slow script detected: still in execution after %lld milliseconds. You can try killing the script using the SCRIPT KILL command.",elapsed);
829          server.lua_timedout = 1;
830          protectClient(server.lua_caller);
831      }
832      if (server.lua_timedout) processEventsWhileBlocked();
833      if (server.lua_kill) {
834          serverLog(LL_WARNING,"Lua script killed by user with SCRIPT KILL.");
835          lua_pushstring(lua,"Script killed by user with SCRIPT KILL...");
836          lua_error(lua);
837      }
838  }
839  void evalGenericCommand(client *c, int evalsha) {
840      lua_State *lua = server.lua;
841      char funcname[43];
842      PORT_LONGLONG numkeys;
843      PORT_LONGLONG initial_server_dirty = server.dirty;
844      int delhook = 0, err;
845      redisSrand48(0);
846      server.lua_random_dirty = 0;
847      server.lua_write_dirty = 0;
848      server.lua_replicate_commands = server.lua_always_replicate_commands;
849      server.lua_multi_emitted = 0;
850      server.lua_repl = PROPAGATE_AOF|PROPAGATE_REPL;
851      if (getLongLongFromObjectOrReply(c,c->argv[2],&numkeys,NULL) != C_OK)
852          return;
853      if (numkeys > (c->argc - 3)) {
854          addReplyError(c,"Number of keys can't be greater than number of args");
855          return;
856      } else if (numkeys < 0) {
857          addReplyError(c,"Number of keys can't be negative");
858          return;
859      }
860      funcname[0] = 'f';
861      funcname[1] = '_';
862      if (!evalsha) {
863          sha1hex(funcname+2,c->argv[1]->ptr,sdslen(c->argv[1]->ptr));
864      } else {
865          int j;
866          char *sha = c->argv[1]->ptr;
867          for (j = 0; j < 40; j++)
868              funcname[j+2] = (sha[j] >= 'A' && sha[j] <= 'Z') ?
869                  sha[j]+('a'-'A') : sha[j];
870          funcname[42] = '\0';
871      }
872      lua_getglobal(lua, "__redis__err__handler");
873      lua_getglobal(lua, funcname);
874      if (lua_isnil(lua,-1)) {
875          lua_pop(lua,1); &bsol;* remove the nil from the stack */
876          if (evalsha) {
877              lua_pop(lua,1); &bsol;* remove the error handler from the stack. */
878              addReply(c, shared.noscripterr);
879              return;
880          }
881          if (luaCreateFunction(c,lua,c->argv[1]) == NULL) {
882              lua_pop(lua,1); &bsol;* remove the error handler from the stack. */
883              return;
884          }
885          lua_getglobal(lua, funcname);
886          serverAssert(!lua_isnil(lua,-1));
887      }
888      luaSetGlobalArray(lua,"KEYS",c->argv+3,(int)numkeys);                       WIN_PORT_FIX &bsol;* cast (int) */
889      luaSetGlobalArray(lua,"ARGV",c->argv+3+numkeys,(int)(c->argc-3-numkeys));   WIN_PORT_FIX &bsol;* cast (int) */
890      selectDb(server.lua_client,c->db->id);
891      server.lua_caller = c;
892      server.lua_time_start = mstime();
893      server.lua_kill = 0;
894      if (server.lua_time_limit > 0 && ldb.active == 0) {
895          lua_sethook(lua,luaMaskCountHook,LUA_MASKCOUNT,100000);
896          delhook = 1;
897      } else if (ldb.active) {
898          lua_sethook(server.lua,luaLdbLineHook,LUA_MASKLINE|LUA_MASKCOUNT,100000);
899          delhook = 1;
900      }
901      err = lua_pcall(lua,0,1,-2);
902      if (delhook) lua_sethook(lua,NULL,0,0); &bsol;* Disable hook */
903      if (server.lua_timedout) {
904          server.lua_timedout = 0;
905          unprotectClient(c);
906          if (server.masterhost && server.master)
907              queueClientForReprocessing(server.master);
908      }
909      server.lua_caller = NULL;
910      #define LUA_GC_CYCLE_PERIOD 50
911      {
912          static PORT_LONG gc_count = 0;
913          gc_count++;
914          if (gc_count == LUA_GC_CYCLE_PERIOD) {
915              lua_gc(lua,LUA_GCSTEP,LUA_GC_CYCLE_PERIOD);
916              gc_count = 0;
917          }
918      }
919      if (err) {
920          addReplyErrorFormat(c,"Error running script (call to %s): %s\n",
921              funcname, lua_tostring(lua,-1));
922          lua_pop(lua,2); &bsol;* Consume the Lua reply and remove error handler. */
923      } else {
924          luaReplyToRedisReply(c,lua); &bsol;* Convert and consume the reply. */
925          lua_pop(lua,1); &bsol;* Remove the error handler. */
926      }
927      if (server.lua_replicate_commands) {
928          preventCommandPropagation(c);
929          if (server.lua_multi_emitted) {
930              robj *propargv[1];
931              propargv[0] = createStringObject("EXEC",4);
932              alsoPropagate(server.execCommand,c->db->id,propargv,1,
933                  PROPAGATE_AOF|PROPAGATE_REPL);
934              decrRefCount(propargv[0]);
935          }
936      }
937      if (evalsha && !server.lua_replicate_commands) {
938          if (!replicationScriptCacheExists(c->argv[1]->ptr)) {
939              robj *script = dictFetchValue(server.lua_scripts,c->argv[1]->ptr);
940              replicationScriptCacheAdd(c->argv[1]->ptr);
941              serverAssertWithInfo(c,NULL,script != NULL);
942              if (server.dirty == initial_server_dirty) {
943                  rewriteClientCommandVector(c,3,
944                      resetRefCount(createStringObject("SCRIPT",6)),
945                      resetRefCount(createStringObject("LOAD",4)),
946                      script);
947              } else {
948                  rewriteClientCommandArgument(c,0,
949                      resetRefCount(createStringObject("EVAL",4)));
950                  rewriteClientCommandArgument(c,1,script);
951              }
952              forceCommandPropagation(c,PROPAGATE_REPL|PROPAGATE_AOF);
953          }
954      }
955  }
956  void evalCommand(client *c) {
957      if (!(c->flags & CLIENT_LUA_DEBUG))
958          evalGenericCommand(c,0);
959      else
960          evalGenericCommandWithDebugging(c,0);
961  }
962  void evalShaCommand(client *c) {
963      if (sdslen(c->argv[1]->ptr) != 40) {
964          addReply(c, shared.noscripterr);
965          return;
966      }
967      if (!(c->flags & CLIENT_LUA_DEBUG))
968          evalGenericCommand(c,1);
969      else {
970          addReplyError(c,"Please use EVAL instead of EVALSHA for debugging");
971          return;
972      }
973  }
974  void scriptCommand(client *c) {
975      if (c->argc == 2 && !strcasecmp(c->argv[1]->ptr,"help")) {
976          const char *help[] = {
977  "DEBUG (yes|sync|no) -- Set the debug mode for subsequent scripts executed.",
978  "EXISTS <sha1> [<sha1> ...] -- Return information about the existence of the scripts in the script cache.",
979  "FLUSH -- Flush the Lua scripts cache. Very dangerous on replicas.",
980  "KILL -- Kill the currently executing Lua script.",
981  "LOAD <script> -- Load a script into the scripts cache, without executing it.",
982  NULL
983          };
984          addReplyHelp(c, help);
985      } else if (c->argc == 2 && !strcasecmp(c->argv[1]->ptr,"flush")) {
986          scriptingReset();
987          addReply(c,shared.ok);
988          replicationScriptCacheFlush();
989          server.dirty++; &bsol;* Propagating this command is a good idea. */
990      } else if (c->argc >= 2 && !strcasecmp(c->argv[1]->ptr,"exists")) {
991          int j;
992          addReplyMultiBulkLen(c, c->argc-2);
993          for (j = 2; j < c->argc; j++) {
994              if (dictFind(server.lua_scripts,c->argv[j]->ptr))
995                  addReply(c,shared.cone);
996              else
997                  addReply(c,shared.czero);
998          }
999      } else if (c->argc == 3 && !strcasecmp(c->argv[1]->ptr,"load")) {
1000          sds sha = luaCreateFunction(c,server.lua,c->argv[2]);
1001          if (sha == NULL) return; &bsol;* The error was sent by luaCreateFunction(). */
1002          addReplyBulkCBuffer(c,sha,40);
1003          forceCommandPropagation(c,PROPAGATE_REPL|PROPAGATE_AOF);
1004      } else if (c->argc == 2 && !strcasecmp(c->argv[1]->ptr,"kill")) {
1005          if (server.lua_caller == NULL) {
1006              addReplySds(c,sdsnew("-NOTBUSY No scripts in execution right now.\r\n"));
1007          } else if (server.lua_caller->flags & CLIENT_MASTER) {
1008              addReplySds(c,sdsnew("-UNKILLABLE The busy script was sent by a master instance in the context of replication and cannot be killed.\r\n"));
1009          } else if (server.lua_write_dirty) {
1010              addReplySds(c,sdsnew("-UNKILLABLE Sorry the script already executed write commands against the dataset. You can either wait the script termination or kill the server in a hard way using the SHUTDOWN NOSAVE command.\r\n"));
1011          } else {
1012              server.lua_kill = 1;
1013              addReply(c,shared.ok);
1014          }
1015      } else if (c->argc == 3 && !strcasecmp(c->argv[1]->ptr,"debug")) {
1016          if (clientHasPendingReplies(c)) {
1017              addReplyError(c,"SCRIPT DEBUG must be called outside a pipeline");
1018              return;
1019          }
1020          if (!strcasecmp(c->argv[2]->ptr,"no")) {
1021              ldbDisable(c);
1022              addReply(c,shared.ok);
1023          } else if (!strcasecmp(c->argv[2]->ptr,"yes")) {
1024              ldbEnable(c);
1025              addReply(c,shared.ok);
1026          } else if (!strcasecmp(c->argv[2]->ptr,"sync")) {
1027              ldbEnable(c);
1028              addReply(c,shared.ok);
1029              c->flags |= CLIENT_LUA_DEBUG_SYNC;
1030          } else {
1031              addReplyError(c,"Use SCRIPT DEBUG yes/sync/no");
1032              return;
1033          }
1034      } else {
1035          addReplySubcommandSyntaxError(c);
1036      }
1037  }
1038  void ldbInit(void) {
1039      ldb.fd = -1;
1040      ldb.active = 0;
1041      ldb.logs = listCreate();
1042      listSetFreeMethod(ldb.logs,(void (*)(void*))sdsfree);
1043      ldb.children = listCreate();
1044      ldb.src = NULL;
1045      ldb.lines = 0;
1046      ldb.cbuf = sdsempty();
1047  }
1048  void ldbFlushLog(list *log) {
1049      listNode *ln;
1050      while((ln = listFirst(log)) != NULL)
1051          listDelNode(log,ln);
1052  }
1053  void ldbEnable(client *c) {
1054      c->flags |= CLIENT_LUA_DEBUG;
1055      ldbFlushLog(ldb.logs);
1056      ldb.fd = c->fd;
1057      ldb.step = 1;
1058      ldb.bpcount = 0;
1059      ldb.luabp = 0;
1060      sdsfree(ldb.cbuf);
1061      ldb.cbuf = sdsempty();
1062      ldb.maxlen = LDB_MAX_LEN_DEFAULT;
1063      ldb.maxlen_hint_sent = 0;
1064  }
1065  void ldbDisable(client *c) {
1066      c->flags &= ~(CLIENT_LUA_DEBUG|CLIENT_LUA_DEBUG_SYNC);
1067  }
1068  void ldbLog(sds entry) {
1069      listAddNodeTail(ldb.logs,entry);
1070  }
1071  void ldbLogWithMaxLen(sds entry) {
1072      int trimmed = 0;
1073      if (ldb.maxlen && sdslen(entry) > ldb.maxlen) {
1074          sdsrange(entry,0,ldb.maxlen-1);
1075          entry = sdscatlen(entry," ...",4);
1076          trimmed = 1;
1077      }
1078      ldbLog(entry);
1079      if (trimmed && ldb.maxlen_hint_sent == 0) {
1080          ldb.maxlen_hint_sent = 1;
1081          ldbLog(sdsnew(
1082          "<hint> The above reply was trimmed. Use 'maxlen 0' to disable trimming."));
1083      }
1084  }
1085  void ldbSendLogs(void) {
1086      sds proto = sdsempty();
1087      proto = sdscatfmt(proto,"*%i\r\n", (int)listLength(ldb.logs));
1088      while(listLength(ldb.logs)) {
1089          listNode *ln = listFirst(ldb.logs);
1090          proto = sdscatlen(proto,"+",1);
1091          sdsmapchars(ln->value,"\r\n","  ",2);
1092          proto = sdscatsds(proto,ln->value);
1093          proto = sdscatlen(proto,"\r\n",2);
1094          listDelNode(ldb.logs,ln);
1095      }
1096      if (write(ldb.fd,proto,sdslen(proto)) == -1) {
1097      }
1098      sdsfree(proto);
1099  }
1100  int ldbStartSession(client *c) {
1101  #ifndef _WIN32
1102      ldb.forked = (c->flags & CLIENT_LUA_DEBUG_SYNC) == 0;
1103      if (ldb.forked) {
1104          pid_t cp = fork();
1105          if (cp == -1) {
1106              addReplyError(c,"Fork() failed: can't run EVAL in debugging mode.");
1107              return 0;
1108          } else if (cp == 0) {
1109              struct sigaction act;
1110              sigemptyset(&act.sa_mask);
1111              act.sa_flags = 0;
1112              act.sa_handler = SIG_IGN;
1113              sigaction(SIGTERM, &act, NULL);
1114              sigaction(SIGINT, &act, NULL);
1115              serverLog(LL_WARNING,"Redis forked for debugging eval");
1116              closeListeningSockets(0);
1117          } else {
1118              listAddNodeTail(ldb.children,(void*)(unsigned long)cp);
1119              freeClientAsync(c); &bsol;* Close the client in the parent side. */
1120              return 0;
1121          }
1122      } else {
1123          serverLog(LL_WARNING,
1124              "Redis synchronous debugging eval session started");
1125      }
1126      anetBlock(NULL,ldb.fd);
1127      anetSendTimeout(NULL,ldb.fd,5000);
1128      ldb.active = 1;
1129      sds srcstring = sdsdup(c->argv[1]->ptr);
1130      size_t srclen = sdslen(srcstring);
1131      while(srclen && (srcstring[srclen-1] == '\n' ||
1132                       srcstring[srclen-1] == '\r'))
1133      {
1134          srcstring[--srclen] = '\0';
1135      }
1136      sdssetlen(srcstring,srclen);
1137      ldb.src = sdssplitlen(srcstring,sdslen(srcstring),"\n",1,&ldb.lines);
1138      sdsfree(srcstring);
1139      return 1;
1140  #endif 
1141      return 0;
1142  }
1143  void ldbEndSession(client *c) {
1144      ldbLog(sdsnew("<endsession>"));
1145      ldbSendLogs();
1146      if (ldb.forked) {
1147          writeToClient(c->fd, c, 0);
1148          serverLog(LL_WARNING,"Lua debugging session child exiting");
1149          exitFromChild(0);
1150      } else {
1151          serverLog(LL_WARNING,
1152              "Redis synchronous debugging eval session ended");
1153      }
1154      anetNonBlock(NULL,ldb.fd);
1155      anetSendTimeout(NULL,ldb.fd,0);
1156      c->flags |= CLIENT_CLOSE_AFTER_REPLY;
1157      sdsfreesplitres(ldb.src,ldb.lines);
1158      ldb.lines = 0;
1159      ldb.active = 0;
1160  }
1161  int ldbRemoveChild(pid_t pid) {
1162      listNode *ln = listSearchKey(ldb.children,(void*)(PORT_ULONG)pid);
1163      if (ln) {
1164          listDelNode(ldb.children,ln);
1165          return 1;
1166      }
1167      return 0;
1168  }
1169  int ldbPendingChildren(void) {
1170      return (int)listLength(ldb.children);                                       WIN_PORT_FIX &bsol;* cast (int) */
1171  }
1172  void ldbKillForkedSessions(void) {
1173  #ifndef _WIN32
1174      listIter li;
1175      listNode *ln;
1176      listRewind(ldb.children,&li);
1177      while((ln = listNext(&li))) {
1178          pid_t pid = (unsigned long) ln->value;
1179          serverLog(LL_WARNING,"Killing debugging session %ld",(long)pid);
1180          kill(pid,SIGKILL);
1181      }
1182      listRelease(ldb.children);
1183      ldb.children = listCreate();
1184  #endif
1185  }
1186  void evalGenericCommandWithDebugging(client *c, int evalsha) {
1187      if (ldbStartSession(c)) {
1188          evalGenericCommand(c,evalsha);
1189          ldbEndSession(c);
1190      } else {
1191          ldbDisable(c);
1192      }
1193  }
1194  char *ldbGetSourceLine(int line) {
1195      int idx = line-1;
1196      if (idx < 0 || idx >= ldb.lines) return "<out of range source code line>";
1197      return ldb.src[idx];
1198  }
1199  int ldbIsBreakpoint(int line) {
1200      int j;
1201      for (j = 0; j < ldb.bpcount; j++)
1202          if (ldb.bp[j] == line) return 1;
1203      return 0;
1204  }
1205  int ldbAddBreakpoint(int line) {
1206      if (line <= 0 || line > ldb.lines) return 0;
1207      if (!ldbIsBreakpoint(line) && ldb.bpcount != LDB_BREAKPOINTS_MAX) {
1208          ldb.bp[ldb.bpcount++] = line;
1209          return 1;
1210      }
1211      return 0;
1212  }
1213  int ldbDelBreakpoint(int line) {
1214      int j;
1215      for (j = 0; j < ldb.bpcount; j++) {
1216          if (ldb.bp[j] == line) {
1217              ldb.bpcount--;
1218              memmove(ldb.bp+j,ldb.bp+j+1,ldb.bpcount-j);
1219              return 1;
1220          }
1221      }
1222      return 0;
1223  }
1224  sds *ldbReplParseCommand(int *argcp) {
1225      sds *argv = NULL;
1226      int argc = 0;
1227      if (sdslen(ldb.cbuf) == 0) return NULL;
1228      sds copy = sdsdup(ldb.cbuf);
1229      char *p = copy;
1230      p = strchr(p,'*'); if (!p) goto protoerr;
1231      char *plen = p+1; &bsol;* Multi bulk len pointer. */
1232      p = strstr(p,"\r\n"); if (!p) goto protoerr;
1233      *p = '\0'; p += 2;
1234      *argcp = atoi(plen);
1235      if (*argcp <= 0 || *argcp > 1024) goto protoerr;
1236      argv = zmalloc(sizeof(sds)*(*argcp));
1237      argc = 0;
1238      while(argc < *argcp) {
1239          if (*p != '$') goto protoerr;
1240          plen = p+1; &bsol;* Bulk string len pointer. */
1241          p = strstr(p,"\r\n"); if (!p) goto protoerr;
1242          *p = '\0'; p += 2;
1243          int slen = atoi(plen); &bsol;* Length of this arg. */
1244          if (slen <= 0 || slen > 1024) goto protoerr;
1245          argv[argc++] = sdsnewlen(p,slen);
1246          p += slen; &bsol;* Skip the already parsed argument. */
1247          if (p[0] != '\r' || p[1] != '\n') goto protoerr;
1248          p += 2; &bsol;* Skip \r\n. */
1249      }
1250      sdsfree(copy);
1251      return argv;
1252  protoerr:
1253      sdsfreesplitres(argv,argc);
1254      sdsfree(copy);
1255      return NULL;
1256  }
1257  void ldbLogSourceLine(int lnum) {
1258      char *line = ldbGetSourceLine(lnum);
1259      char *prefix;
1260      int bp = ldbIsBreakpoint(lnum);
1261      int current = ldb.currentline == lnum;
1262      if (current && bp)
1263          prefix = "->#";
1264      else if (current)
1265          prefix = "-> ";
1266      else if (bp)
1267          prefix = "  #";
1268      else
1269          prefix = "   ";
1270      sds thisline = sdscatprintf(sdsempty(),"%s%-3d %s", prefix, lnum, line);
1271      ldbLog(thisline);
1272  }
1273  void ldbList(int around, int context) {
1274      int j;
1275      for (j = 1; j <= ldb.lines; j++) {
1276          if (around != 0 && abs(around-j) > context) continue;
1277          ldbLogSourceLine(j);
1278      }
1279  }
1280  #define LDB_MAX_VALUES_DEPTH (LUA_MINSTACK/2)
1281  sds ldbCatStackValueRec(sds s, lua_State *lua, int idx, int level) {
1282      int t = lua_type(lua,idx);
1283      if (level++ == LDB_MAX_VALUES_DEPTH)
1284          return sdscat(s,"<max recursion level reached! Nested table?>");
1285      switch(t) {
1286      case LUA_TSTRING:
1287          {
1288          size_t strl;
1289          char *strp = (char*)lua_tolstring(lua,idx,&strl);
1290          s = sdscatrepr(s,strp,strl);
1291          }
1292          break;
1293      case LUA_TBOOLEAN:
1294          s = sdscat(s,lua_toboolean(lua,idx) ? "true" : "false");
1295          break;
1296      case LUA_TNUMBER:
1297          s = sdscatprintf(s,"%g",(double)lua_tonumber(lua,idx));
1298          break;
1299      case LUA_TNIL:
1300          s = sdscatlen(s,"nil",3);
1301          break;
1302      case LUA_TTABLE:
1303          {
1304          int expected_index = 1; &bsol;* First index we expect in an array. */
1305          int is_array = 1; &bsol;* Will be set to null if check fails. */
1306          sds repr1 = sdsempty();
1307          sds repr2 = sdsempty();
1308          lua_pushnil(lua); &bsol;* The first key to start the iteration is nil. */
1309          while (lua_next(lua,idx-1)) {
1310              if (is_array &&
1311                  (lua_type(lua,-2) != LUA_TNUMBER ||
1312                   lua_tonumber(lua,-2) != expected_index)) is_array = 0;
1313              repr1 = ldbCatStackValueRec(repr1,lua,-1,level);
1314              repr1 = sdscatlen(repr1,"; ",2);
1315              repr2 = sdscatlen(repr2,"[",1);
1316              repr2 = ldbCatStackValueRec(repr2,lua,-2,level);
1317              repr2 = sdscatlen(repr2,"]=",2);
1318              repr2 = ldbCatStackValueRec(repr2,lua,-1,level);
1319              repr2 = sdscatlen(repr2,"; ",2);
1320              lua_pop(lua,1); &bsol;* Stack: table, key. Ready for next iteration. */
1321              expected_index++;
1322          }
1323          if (sdslen(repr1)) sdsrange(repr1,0,-3);
1324          if (sdslen(repr2)) sdsrange(repr2,0,-3);
1325          s = sdscatlen(s,"{",1);
1326          s = sdscatsds(s,is_array ? repr1 : repr2);
1327          s = sdscatlen(s,"}",1);
1328          sdsfree(repr1);
1329          sdsfree(repr2);
1330          }
1331          break;
1332      case LUA_TFUNCTION:
1333      case LUA_TUSERDATA:
1334      case LUA_TTHREAD:
1335      case LUA_TLIGHTUSERDATA:
1336          {
1337          const void *p = lua_topointer(lua,idx);
1338          char *typename = "unknown";
1339          if (t == LUA_TFUNCTION) typename = "function";
1340          else if (t == LUA_TUSERDATA) typename = "userdata";
1341          else if (t == LUA_TTHREAD) typename = "thread";
1342          else if (t == LUA_TLIGHTUSERDATA) typename = "light-userdata";
1343          s = sdscatprintf(s,"\"%s@%p\"",typename,p);
1344          }
1345          break;
1346      default:
1347          s = sdscat(s,"\"<unknown-lua-type>\"");
1348          break;
1349      }
1350      return s;
1351  }
1352  sds ldbCatStackValue(sds s, lua_State *lua, int idx) {
1353      return ldbCatStackValueRec(s,lua,idx,0);
1354  }
1355  void ldbLogStackValue(lua_State *lua, char *prefix) {
1356      sds s = sdsnew(prefix);
1357      s = ldbCatStackValue(s,lua,-1);
1358      ldbLogWithMaxLen(s);
1359  }
1360  char *ldbRedisProtocolToHuman_Int(sds *o, char *reply);
1361  char *ldbRedisProtocolToHuman_Bulk(sds *o, char *reply);
1362  char *ldbRedisProtocolToHuman_Status(sds *o, char *reply);
1363  char *ldbRedisProtocolToHuman_MultiBulk(sds *o, char *reply);
1364  char *ldbRedisProtocolToHuman(sds *o, char *reply) {
1365      char *p = reply;
1366      switch(*p) {
1367      case ':': p = ldbRedisProtocolToHuman_Int(o,reply); break;
1368      case '$': p = ldbRedisProtocolToHuman_Bulk(o,reply); break;
1369      case '+': p = ldbRedisProtocolToHuman_Status(o,reply); break;
1370      case '-': p = ldbRedisProtocolToHuman_Status(o,reply); break;
1371      case '*': p = ldbRedisProtocolToHuman_MultiBulk(o,reply); break;
1372      }
1373      return p;
1374  }
1375  char *ldbRedisProtocolToHuman_Int(sds *o, char *reply) {
1376      char *p = strchr(reply+1,'\r');
1377      *o = sdscatlen(*o,reply+1,p-reply-1);
1378      return p+2;
1379  }
1380  char *ldbRedisProtocolToHuman_Bulk(sds *o, char *reply) {
1381      char *p = strchr(reply+1,'\r');
1382      PORT_LONGLONG bulklen;
1383      string2ll(reply+1,p-reply-1,&bulklen);
1384      if (bulklen == -1) {
1385          *o = sdscatlen(*o,"NULL",4);
1386          return p+2;
1387      } else {
1388          *o = sdscatrepr(*o,p+2,bulklen);
1389          return p+2+bulklen+2;
1390      }
1391  }
1392  char *ldbRedisProtocolToHuman_Status(sds *o, char *reply) {
1393      char *p = strchr(reply+1,'\r');
1394      *o = sdscatrepr(*o,reply,p-reply);
1395      return p+2;
1396  }
1397  char *ldbRedisProtocolToHuman_MultiBulk(sds *o, char *reply) {
1398      char *p = strchr(reply+1,'\r');
1399      PORT_LONGLONG mbulklen;
1400      int j = 0;
1401      string2ll(reply+1,p-reply-1,&mbulklen);
1402      p += 2;
1403      if (mbulklen == -1) {
1404          *o = sdscatlen(*o,"NULL",4);
1405          return p;
1406      }
1407      *o = sdscatlen(*o,"[",1);
1408      for (j = 0; j < mbulklen; j++) {
1409          p = ldbRedisProtocolToHuman(o,p);
1410          if (j != mbulklen-1) *o = sdscatlen(*o,",",1);
1411      }
1412      *o = sdscatlen(*o,"]",1);
1413      return p;
1414  }
1415  void ldbLogRedisReply(char *reply) {
1416      sds log = sdsnew("<reply> ");
1417      ldbRedisProtocolToHuman(&log,reply);
1418      ldbLogWithMaxLen(log);
1419  }
1420  void ldbPrint(lua_State *lua, char *varname) {
1421      lua_Debug ar;
1422      int l = 0; &bsol;* Stack level. */
1423      while (lua_getstack(lua,l,&ar) != 0) {
1424          l++;
1425          const char *name;
1426          int i = 1; &bsol;* Variable index. */
1427          while((name = lua_getlocal(lua,&ar,i)) != NULL) {
1428              i++;
1429              if (strcmp(varname,name) == 0) {
1430                  ldbLogStackValue(lua,"<value> ");
1431                  lua_pop(lua,1);
1432                  return;
1433              } else {
1434                  lua_pop(lua,1); &bsol;* Discard the var name on the stack. */
1435              }
1436          }
1437      }
1438      if (!strcmp(varname,"ARGV") || !strcmp(varname,"KEYS")) {
1439          lua_getglobal(lua, varname);
1440          ldbLogStackValue(lua,"<value> ");
1441          lua_pop(lua,1);
1442      } else {
1443          ldbLog(sdsnew("No such variable."));
1444      }
1445  }
1446  void ldbPrintAll(lua_State *lua) {
1447      lua_Debug ar;
1448      int vars = 0;
1449      if (lua_getstack(lua,0,&ar) != 0) {
1450          const char *name;
1451          int i = 1; &bsol;* Variable index. */
1452          while((name = lua_getlocal(lua,&ar,i)) != NULL) {
1453              i++;
1454              if (!strstr(name,"(*temporary)")) {
1455                  sds prefix = sdscatprintf(sdsempty(),"<value> %s = ",name);
1456                  ldbLogStackValue(lua,prefix);
1457                  sdsfree(prefix);
1458                  vars++;
1459              }
1460              lua_pop(lua,1);
1461          }
1462      }
1463      if (vars == 0) {
1464          ldbLog(sdsnew("No local variables in the current context."));
1465      }
1466  }
1467  void ldbBreak(sds *argv, int argc) {
1468      if (argc == 1) {
1469          if (ldb.bpcount == 0) {
1470              ldbLog(sdsnew("No breakpoints set. Use 'b <line>' to add one."));
1471              return;
1472          } else {
1473              ldbLog(sdscatfmt(sdsempty(),"%i breakpoints set:",ldb.bpcount));
1474              int j;
1475              for (j = 0; j < ldb.bpcount; j++)
1476                  ldbLogSourceLine(ldb.bp[j]);
1477          }
1478      } else {
1479          int j;
1480          for (j = 1; j < argc; j++) {
1481              char *arg = argv[j];
1482              PORT_LONG line;
1483              if (!string2l(arg,sdslen(arg),&line)) {
1484                  ldbLog(sdscatfmt(sdsempty(),"Invalid argument:'%s'",arg));
1485              } else {
1486                  if (line == 0) {
1487                      ldb.bpcount = 0;
1488                      ldbLog(sdsnew("All breakpoints removed."));
1489                  } else if (line > 0) {
1490                      if (ldb.bpcount == LDB_BREAKPOINTS_MAX) {
1491                          ldbLog(sdsnew("Too many breakpoints set."));
1492                      } else if (ldbAddBreakpoint((int)line)) {                   WIN_PORT_FIX &bsol;* cast (int) */
1493                          ldbList((int)line,1);                                   WIN_PORT_FIX &bsol;* cast (int) */
1494                      } else {
1495                          ldbLog(sdsnew("Wrong line number."));
1496                      }
1497                  } else if (line < 0) {
1498                      if (ldbDelBreakpoint((int)(-line)))                         WIN_PORT_FIX &bsol;* cast (int) */
1499                          ldbLog(sdsnew("Breakpoint removed."));
1500                      else
1501                          ldbLog(sdsnew("No breakpoint in the specified line."));
1502                  }
1503              }
1504          }
1505      }
1506  }
1507  void ldbEval(lua_State *lua, sds *argv, int argc) {
1508      sds code = sdsjoinsds(argv+1,argc-1," ",1);
1509      sds expr = sdscatsds(sdsnew("return "),code);
1510      if (luaL_loadbuffer(lua,expr,sdslen(expr),"@ldb_eval")) {
1511          lua_pop(lua,1);
1512          if (luaL_loadbuffer(lua,code,sdslen(code),"@ldb_eval")) {
1513              ldbLog(sdscatfmt(sdsempty(),"<error> %s",lua_tostring(lua,-1)));
1514              lua_pop(lua,1);
1515              sdsfree(code);
1516              sdsfree(expr);
1517              return;
1518          }
1519      }
1520      sdsfree(code);
1521      sdsfree(expr);
1522      if (lua_pcall(lua,0,1,0)) {
1523          ldbLog(sdscatfmt(sdsempty(),"<error> %s",lua_tostring(lua,-1)));
1524          lua_pop(lua,1);
1525          return;
1526      }
1527      ldbLogStackValue(lua,"<retval> ");
1528      lua_pop(lua,1);
1529  }
1530  void ldbRedis(lua_State *lua, sds *argv, int argc) {
1531      int j, saved_rc = server.lua_replicate_commands;
1532      lua_getglobal(lua,"redis");
1533      lua_pushstring(lua,"call");
1534      lua_gettable(lua,-2);       &bsol;* Stack: redis, redis.call */
1535      for (j = 1; j < argc; j++)
1536          lua_pushlstring(lua,argv[j],sdslen(argv[j]));
1537      ldb.step = 1;               &bsol;* Force redis.call() to log. */
1538      server.lua_replicate_commands = 1;
1539      lua_pcall(lua,argc-1,1,0);  &bsol;* Stack: redis, result */
1540      ldb.step = 0;               &bsol;* Disable logging. */
1541      server.lua_replicate_commands = saved_rc;
1542      lua_pop(lua,2);             &bsol;* Discard the result and clean the stack. */
1543  }
1544  void ldbTrace(lua_State *lua) {
1545      lua_Debug ar;
1546      int level = 0;
1547      while(lua_getstack(lua,level,&ar)) {
1548          lua_getinfo(lua,"Snl",&ar);
1549          if(strstr(ar.short_src,"user_script") != NULL) {
1550              ldbLog(sdscatprintf(sdsempty(),"%s %s:",
1551                  (level == 0) ? "In" : "From",
1552                  ar.name ? ar.name : "top level"));
1553              ldbLogSourceLine(ar.currentline);
1554          }
1555          level++;
1556      }
1557      if (level == 0) {
1558          ldbLog(sdsnew("<error> Can't retrieve Lua stack."));
1559      }
1560  }
1561  void ldbMaxlen(sds *argv, int argc) {
1562      if (argc == 2) {
1563          int newval = atoi(argv[1]);
1564          ldb.maxlen_hint_sent = 1; &bsol;* User knows about this command. */
1565          if (newval != 0 && newval <= 60) newval = 60;
1566          ldb.maxlen = newval;
1567      }
1568      if (ldb.maxlen) {
1569          ldbLog(sdscatprintf(sdsempty(),"<value> replies are truncated at %d bytes.",(int)ldb.maxlen));
1570      } else {
1571          ldbLog(sdscatprintf(sdsempty(),"<value> replies are unlimited."));
1572      }
1573  }
1574  int ldbRepl(lua_State *lua) {
1575      sds *argv;
1576      int argc;
1577      while(1) {
1578          while((argv = ldbReplParseCommand(&argc)) == NULL) {
1579              char buf[1024];
1580              int nread = (int)read(ldb.fd,buf,sizeof(buf));                      WIN_PORT_FIX &bsol;* cast (int) */
1581              if (nread <= 0) {
1582                  ldb.step = 0;
1583                  ldb.bpcount = 0;
1584                  return C_ERR;
1585              }
1586              ldb.cbuf = sdscatlen(ldb.cbuf,buf,nread);
1587          }
1588          sdsfree(ldb.cbuf);
1589          ldb.cbuf = sdsempty();
1590          if (!strcasecmp(argv[0],"h") || !strcasecmp(argv[0],"help")) {
1591  ldbLog(sdsnew("Redis Lua debugger help:"));
1592  ldbLog(sdsnew("[h]elp               Show this help."));
1593  ldbLog(sdsnew("[s]tep               Run current line and stop again."));
1594  ldbLog(sdsnew("[n]ext               Alias for step."));
1595  ldbLog(sdsnew("[c]continue          Run till next breakpoint."));
1596  ldbLog(sdsnew("[l]list              List source code around current line."));
1597  ldbLog(sdsnew("[l]list [line]       List source code around [line]."));
1598  ldbLog(sdsnew("                     line = 0 means: current position."));
1599  ldbLog(sdsnew("[l]list [line] [ctx] In this form [ctx] specifies how many lines"));
1600  ldbLog(sdsnew("                     to show before/after [line]."));
1601  ldbLog(sdsnew("[w]hole              List all source code. Alias for 'list 1 1000000'."));
1602  ldbLog(sdsnew("[p]rint              Show all the local variables."));
1603  ldbLog(sdsnew("[p]rint <var>        Show the value of the specified variable."));
1604  ldbLog(sdsnew("                     Can also show global vars KEYS and ARGV."));
1605  ldbLog(sdsnew("[b]reak              Show all breakpoints."));
1606  ldbLog(sdsnew("[b]reak <line>       Add a breakpoint to the specified line."));
1607  ldbLog(sdsnew("[b]reak -<line>      Remove breakpoint from the specified line."));
1608  ldbLog(sdsnew("[b]reak 0            Remove all breakpoints."));
1609  ldbLog(sdsnew("[t]race              Show a backtrace."));
1610  ldbLog(sdsnew("[e]eval <code>       Execute some Lua code (in a different callframe)."));
1611  ldbLog(sdsnew("[r]edis <cmd>        Execute a Redis command."));
1612  ldbLog(sdsnew("[m]axlen [len]       Trim logged Redis replies and Lua var dumps to len."));
1613  ldbLog(sdsnew("                     Specifying zero as <len> means unlimited."));
1614  ldbLog(sdsnew("[a]bort              Stop the execution of the script. In sync"));
1615  ldbLog(sdsnew("                     mode dataset changes will be retained."));
1616  ldbLog(sdsnew(""));
1617  ldbLog(sdsnew("Debugger functions you can call from Lua scripts:"));
1618  ldbLog(sdsnew("redis.debug()        Produce logs in the debugger console."));
1619  ldbLog(sdsnew("redis.breakpoint()   Stop execution like if there was a breakpoing."));
1620  ldbLog(sdsnew("                     in the next line of code."));
1621              ldbSendLogs();
1622          } else if (!strcasecmp(argv[0],"s") || !strcasecmp(argv[0],"step") ||
1623                     !strcasecmp(argv[0],"n") || !strcasecmp(argv[0],"next")) {
1624              ldb.step = 1;
1625              break;
1626          } else if (!strcasecmp(argv[0],"c") || !strcasecmp(argv[0],"continue")){
1627              break;
1628          } else if (!strcasecmp(argv[0],"t") || !strcasecmp(argv[0],"trace")) {
1629              ldbTrace(lua);
1630              ldbSendLogs();
1631          } else if (!strcasecmp(argv[0],"m") || !strcasecmp(argv[0],"maxlen")) {
1632              ldbMaxlen(argv,argc);
1633              ldbSendLogs();
1634          } else if (!strcasecmp(argv[0],"b") || !strcasecmp(argv[0],"break")) {
1635              ldbBreak(argv,argc);
1636              ldbSendLogs();
1637          } else if (!strcasecmp(argv[0],"e") || !strcasecmp(argv[0],"eval")) {
1638              ldbEval(lua,argv,argc);
1639              ldbSendLogs();
1640          } else if (!strcasecmp(argv[0],"a") || !strcasecmp(argv[0],"abort")) {
1641              lua_pushstring(lua, "script aborted for user request");
1642              lua_error(lua);
1643          } else if (argc > 1 &&
1644                     (!strcasecmp(argv[0],"r") || !strcasecmp(argv[0],"redis"))) {
1645              ldbRedis(lua,argv,argc);
1646              ldbSendLogs();
1647          } else if ((!strcasecmp(argv[0],"p") || !strcasecmp(argv[0],"print"))) {
1648              if (argc == 2)
1649                  ldbPrint(lua,argv[1]);
1650              else
1651                  ldbPrintAll(lua);
1652              ldbSendLogs();
1653          } else if (!strcasecmp(argv[0],"l") || !strcasecmp(argv[0],"list")){
1654              int around = ldb.currentline, ctx = 5;
1655              if (argc > 1) {
1656                  int num = atoi(argv[1]);
1657                  if (num > 0) around = num;
1658              }
1659              if (argc > 2) ctx = atoi(argv[2]);
1660              ldbList(around,ctx);
1661              ldbSendLogs();
1662          } else if (!strcasecmp(argv[0],"w") || !strcasecmp(argv[0],"whole")){
1663              ldbList(1,1000000);
1664              ldbSendLogs();
1665          } else {
1666              ldbLog(sdsnew("<error> Unknown Redis Lua debugger command or "
1667                            "wrong number of arguments."));
1668              ldbSendLogs();
1669          }
1670          sdsfreesplitres(argv,argc);
1671      }
1672      sdsfreesplitres(argv,argc);
1673      return C_OK;
1674  }
1675  void luaLdbLineHook(lua_State *lua, lua_Debug *ar) {
1676      lua_getstack(lua,0,ar);
1677      lua_getinfo(lua,"Sl",ar);
1678      ldb.currentline = ar->currentline;
1679      int bp = ldbIsBreakpoint(ldb.currentline) || ldb.luabp;
1680      int timeout = 0;
1681      if(strstr(ar->short_src,"user_script") == NULL) return;
1682      if (ar->event == LUA_HOOKCOUNT && ldb.step == 0 && bp == 0) {
1683          mstime_t elapsed = mstime() - server.lua_time_start;
1684          mstime_t timelimit = server.lua_time_limit ?
1685                               server.lua_time_limit : 5000;
1686          if (elapsed >= timelimit) {
1687              timeout = 1;
1688              ldb.step = 1;
1689          } else {
1690              return; &bsol;* No timeout, ignore the COUNT event. */
1691          }
1692      }
1693      if (ldb.step || bp) {
1694          char *reason = "step over";
1695          if (bp) reason = ldb.luabp ? "redis.breakpoint() called" :
1696                                       "break point";
1697          else if (timeout) reason = "timeout reached, infinite loop?";
1698          ldb.step = 0;
1699          ldb.luabp = 0;
1700          ldbLog(sdscatprintf(sdsempty(),
1701              "* Stopped at %d, stop reason = %s",
1702              ldb.currentline, reason));
1703          ldbLogSourceLine(ldb.currentline);
1704          ldbSendLogs();
1705          if (ldbRepl(lua) == C_ERR && timeout) {
1706              lua_pushstring(lua, "timeout during Lua debugging with client closing connection");
1707              lua_error(lua);
1708          }
1709          server.lua_time_start = mstime();
1710      }
1711  }
</code></pre>
        </div>
        <div class="column">
            <h3>redis-MDEwOlJlcG9zaXRvcnkxMDgxMTA3MDY=-flat-scripting.c</h3>
            <pre><code>1  #ifdef _WIN32
2  #include "Win32_Interop/Win32_Portability.h"
3  #endif
4  #include "server.h"
5  #include "sha1.h"
6  #include "rand.h"
7  #include "cluster.h"
8  #include <lua.h>
9  #include <lauxlib.h>
10  #include <lualib.h>
11  #include <ctype.h>
12  #include <math.h>
13  char *redisProtocolToLuaType_Int(lua_State *lua, char *reply);
14  char *redisProtocolToLuaType_Bulk(lua_State *lua, char *reply);
15  char *redisProtocolToLuaType_Status(lua_State *lua, char *reply);
16  char *redisProtocolToLuaType_Error(lua_State *lua, char *reply);
17  char *redisProtocolToLuaType_MultiBulk(lua_State *lua, char *reply);
18  int redis_math_random (lua_State *L);
19  int redis_math_randomseed (lua_State *L);
20  void ldbInit(void);
21  void ldbDisable(client *c);
22  void ldbEnable(client *c);
23  void evalGenericCommandWithDebugging(client *c, int evalsha);
24  void luaLdbLineHook(lua_State *lua, lua_Debug *ar);
25  void ldbLog(sds entry);
26  void ldbLogRedisReply(char *reply);
27  sds ldbCatStackValue(sds s, lua_State *lua, int idx);
28  #define LDB_BREAKPOINTS_MAX 64  &bsol;* Max number of breakpoints. */
29  #define LDB_MAX_LEN_DEFAULT 256 &bsol;* Default len limit for replies / var dumps. */
30  struct ldbState {
31      int fd;     &bsol;* Socket of the debugging client. */
32      int active; &bsol;* Are we debugging EVAL right now? */
33      int forked; &bsol;* Is this a fork()ed debugging session? */
34      list *logs; &bsol;* List of messages to send to the client. */
35      list *traces; &bsol;* Messages about Redis commands executed since last stop.*/
36      list *children; &bsol;* All forked debugging sessions pids. */
37      int bp[LDB_BREAKPOINTS_MAX]; &bsol;* An array of breakpoints line numbers. */
38      int bpcount; &bsol;* Number of valid entries inside bp. */
39      int step;   &bsol;* Stop at next line ragardless of breakpoints. */
40      int luabp;  &bsol;* Stop at next line because redis.breakpoint() was called. */
41      sds *src;   &bsol;* Lua script source code split by line. */
42      int lines;  &bsol;* Number of lines in 'src'. */
43      int currentline;    &bsol;* Current line number. */
44      sds cbuf;   &bsol;* Debugger client command buffer. */
45      size_t maxlen;  &bsol;* Max var dump / reply length. */
46      int maxlen_hint_sent; &bsol;* Did we already hint about "set maxlen"? */
47  } ldb;
48  void sha1hex(char *digest, char *script, size_t len) {
49      SHA1_CTX ctx;
50      unsigned char hash[20];
51      char *cset = "0123456789abcdef";
52      int j;
53      SHA1Init(&ctx);
54      SHA1Update(&ctx,(unsigned char*)script,len);
55      SHA1Final(hash,&ctx);
56      for (j = 0; j < 20; j++) {
57          digest[j*2] = cset[((hash[j]&0xF0)>>4)];
58          digest[j*2+1] = cset[(hash[j]&0xF)];
59      }
60      digest[40] = '\0';
61  }
62  char *redisProtocolToLuaType(lua_State *lua, char* reply) {
63      char *p = reply;
64      switch(*p) {
65      case ':': p = redisProtocolToLuaType_Int(lua,reply); break;
66      case '$': p = redisProtocolToLuaType_Bulk(lua,reply); break;
67      case '+': p = redisProtocolToLuaType_Status(lua,reply); break;
68      case '-': p = redisProtocolToLuaType_Error(lua,reply); break;
69      case '*': p = redisProtocolToLuaType_MultiBulk(lua,reply); break;
70      }
71      return p;
72  }
73  char *redisProtocolToLuaType_Int(lua_State *lua, char *reply) {
74      char *p = strchr(reply+1,'\r');
75      PORT_LONGLONG value;
76      string2ll(reply+1,p-reply-1,&value);
77      lua_pushnumber(lua,(lua_Number)value);
78      return p+2;
79  }
80  char *redisProtocolToLuaType_Bulk(lua_State *lua, char *reply) {
81      char *p = strchr(reply+1,'\r');
82      PORT_LONGLONG bulklen;
83      string2ll(reply+1,p-reply-1,&bulklen);
84      if (bulklen == -1) {
85          lua_pushboolean(lua,0);
86          return p+2;
87      } else {
88          lua_pushlstring(lua,p+2,(size_t)bulklen);                               WIN_PORT_FIX &bsol;* cast (size_t) */
89          return p+2+bulklen+2;
90      }
91  }
92  char *redisProtocolToLuaType_Status(lua_State *lua, char *reply) {
93      char *p = strchr(reply+1,'\r');
94      lua_newtable(lua);
95      lua_pushstring(lua,"ok");
96      lua_pushlstring(lua,reply+1,p-reply-1);
97      lua_settable(lua,-3);
98      return p+2;
99  }
100  char *redisProtocolToLuaType_Error(lua_State *lua, char *reply) {
101      char *p = strchr(reply+1,'\r');
102      lua_newtable(lua);
103      lua_pushstring(lua,"err");
104      lua_pushlstring(lua,reply+1,p-reply-1);
105      lua_settable(lua,-3);
106      return p+2;
107  }
108  char *redisProtocolToLuaType_MultiBulk(lua_State *lua, char *reply) {
109      char *p = strchr(reply+1,'\r');
110      PORT_LONGLONG mbulklen;
111      int j = 0;
112      string2ll(reply+1,p-reply-1,&mbulklen);
113      p += 2;
114      if (mbulklen == -1) {
115          lua_pushboolean(lua,0);
116          return p;
117      }
118      lua_newtable(lua);
119      for (j = 0; j < mbulklen; j++) {
120          lua_pushnumber(lua,j+1);
121          p = redisProtocolToLuaType(lua,p);
122          lua_settable(lua,-3);
123      }
124      return p;
125  }
126  void luaPushError(lua_State *lua, char *error) {
127      lua_Debug dbg;
128      if (ldb.active && ldb.step) {
129          ldbLog(sdscatprintf(sdsempty(),"<error> %s",error));
130      }
131      lua_newtable(lua);
132      lua_pushstring(lua,"err");
133      if(lua_getstack(lua, 1, &dbg) && lua_getinfo(lua, "nSl", &dbg)) {
134          sds msg = sdscatprintf(sdsempty(), "%s: %d: %s",
135              dbg.source, dbg.currentline, error);
136          lua_pushstring(lua, msg);
137          sdsfree(msg);
138      } else {
139          lua_pushstring(lua, error);
140      }
141      lua_settable(lua,-3);
142  }
143  int luaRaiseError(lua_State *lua) {
144      lua_pushstring(lua,"err");
145      lua_gettable(lua,-2);
146      return lua_error(lua);
147  }
148  void luaSortArray(lua_State *lua) {
149      lua_getglobal(lua,"table");
150      lua_pushstring(lua,"sort");
151      lua_gettable(lua,-2);       &bsol;* Stack: array, table, table.sort */
152      lua_pushvalue(lua,-3);      &bsol;* Stack: array, table, table.sort, array */
153      if (lua_pcall(lua,1,0,0)) {
154          lua_pop(lua,1);             &bsol;* Stack: array, table */
155          lua_pushstring(lua,"sort"); &bsol;* Stack: array, table, sort */
156          lua_gettable(lua,-2);       &bsol;* Stack: array, table, table.sort */
157          lua_pushvalue(lua,-3);      &bsol;* Stack: array, table, table.sort, array */
158          lua_getglobal(lua,"__redis__compare_helper");
159          lua_call(lua,2,0);
160      }
161      lua_pop(lua,1);             &bsol;* Stack: array (sorted) */
162  }
163  void luaReplyToRedisReply(client *c, lua_State *lua) {
164      int t = lua_type(lua,-1);
165      switch(t) {
166      case LUA_TSTRING:
167          addReplyBulkCBuffer(c,(char*)lua_tostring(lua,-1),lua_strlen(lua,-1));
168          break;
169      case LUA_TBOOLEAN:
170          addReply(c,lua_toboolean(lua,-1) ? shared.cone : shared.nullbulk);
171          break;
172      case LUA_TNUMBER:
173          addReplyLongLong(c,(PORT_LONGLONG)lua_tonumber(lua,-1));
174          break;
175      case LUA_TTABLE:
176          lua_pushstring(lua,"err");
177          lua_gettable(lua,-2);
178          t = lua_type(lua,-1);
179          if (t == LUA_TSTRING) {
180              sds err = sdsnew(lua_tostring(lua,-1));
181              sdsmapchars(err,"\r\n","  ",2);
182              addReplySds(c,sdscatprintf(sdsempty(),"-%s\r\n",err));
183              sdsfree(err);
184              lua_pop(lua,2);
185              return;
186          }
187          lua_pop(lua,1);
188          lua_pushstring(lua,"ok");
189          lua_gettable(lua,-2);
190          t = lua_type(lua,-1);
191          if (t == LUA_TSTRING) {
192              sds ok = sdsnew(lua_tostring(lua,-1));
193              sdsmapchars(ok,"\r\n","  ",2);
194              addReplySds(c,sdscatprintf(sdsempty(),"+%s\r\n",ok));
195              sdsfree(ok);
196              lua_pop(lua,1);
197          } else {
198              void *replylen = addDeferredMultiBulkLength(c);
199              int j = 1, mbulklen = 0;
200              lua_pop(lua,1); &bsol;* Discard the 'ok' field value we popped */
201              while(1) {
202                  lua_pushnumber(lua,j++);
203                  lua_gettable(lua,-2);
204                  t = lua_type(lua,-1);
205                  if (t == LUA_TNIL) {
206                      lua_pop(lua,1);
207                      break;
208                  }
209                  luaReplyToRedisReply(c, lua);
210                  mbulklen++;
211              }
212              setDeferredMultiBulkLength(c,replylen,mbulklen);
213          }
214          break;
215      default:
216          addReply(c,shared.nullbulk);
217      }
218      lua_pop(lua,1);
219  }
220  #define LUA_CMD_OBJCACHE_SIZE 32
221  #define LUA_CMD_OBJCACHE_MAX_LEN 64
222  int luaRedisGenericCommand(lua_State *lua, int raise_error) {
223      int j, argc = lua_gettop(lua);
224      struct redisCommand *cmd;
225      client *c = server.lua_client;
226      sds reply;
227      static robj **argv = NULL;
228      static int argv_size = 0;
229      static robj *cached_objects[LUA_CMD_OBJCACHE_SIZE];
230      static size_t cached_objects_len[LUA_CMD_OBJCACHE_SIZE];
231      static int inuse = 0;   &bsol;* Recursive calls detection. */
232      if (server.lua_multi_emitted || (server.lua_caller->flags & CLIENT_MULTI)) {
233          c->flags |= CLIENT_MULTI;
234      } else {
235          c->flags &= ~CLIENT_MULTI;
236      }
237      if (inuse) {
238          char *recursion_warning =
239              "luaRedisGenericCommand() recursive call detected. "
240              "Are you doing funny stuff with Lua debug hooks?";
241          serverLog(LL_WARNING,"%s",recursion_warning);
242          luaPushError(lua,recursion_warning);
243          return 1;
244      }
245      inuse++;
246      if (argc == 0) {
247          luaPushError(lua,
248              "Please specify at least one argument for redis.call()");
249          inuse--;
250          return raise_error ? luaRaiseError(lua) : 1;
251      }
252      if (argv_size < argc) {
253          argv = zrealloc(argv,sizeof(robj*)*argc);
254          argv_size = argc;
255      }
256      for (j = 0; j < argc; j++) {
257          char *obj_s;
258          size_t obj_len;
259          char dbuf[64];
260          if (lua_type(lua,j+1) == LUA_TNUMBER) {
261              lua_Number num = lua_tonumber(lua,j+1);
262              obj_len = snprintf(dbuf,sizeof(dbuf),"%.17g",(double)num);
263              obj_s = dbuf;
264          } else {
265              obj_s = (char*)lua_tolstring(lua,j+1,&obj_len);
266              if (obj_s == NULL) break; &bsol;* Not a string. */
267          }
268          if (j < LUA_CMD_OBJCACHE_SIZE && cached_objects[j] &&
269              cached_objects_len[j] >= obj_len)
270          {
271              sds s = cached_objects[j]->ptr;
272              argv[j] = cached_objects[j];
273              cached_objects[j] = NULL;
274              memcpy(s,obj_s,obj_len+1);
275              sdssetlen(s, obj_len);
276          } else {
277              argv[j] = createStringObject(obj_s, obj_len);
278          }
279      }
280      if (j != argc) {
281          j--;
282          while (j >= 0) {
283              decrRefCount(argv[j]);
284              j--;
285          }
286          luaPushError(lua,
287              "Lua redis() command arguments must be strings or integers");
288          inuse--;
289          return raise_error ? luaRaiseError(lua) : 1;
290      }
291      c->argv = argv;
292      c->argc = argc;
293      moduleCallCommandFilters(c);
294      argv = c->argv;
295      argc = c->argc;
296      if (ldb.active && ldb.step) {
297          sds cmdlog = sdsnew("<redis>");
298          for (j = 0; j < c->argc; j++) {
299              if (j == 10) {
300                  cmdlog = sdscatprintf(cmdlog," ... (%d more)",
301                      c->argc-j-1);
302                  break;
303              } else {
304                  cmdlog = sdscatlen(cmdlog," ",1);
305                  cmdlog = sdscatsds(cmdlog,c->argv[j]->ptr);
306              }
307          }
308          ldbLog(cmdlog);
309      }
310      cmd = lookupCommand(argv[0]->ptr);
311      if (!cmd || ((cmd->arity > 0 && cmd->arity != argc) ||
312                     (argc < -cmd->arity)))
313      {
314          if (cmd)
315              luaPushError(lua,
316                  "Wrong number of args calling Redis command From Lua script");
317          else
318              luaPushError(lua,"Unknown Redis command called from Lua script");
319          goto cleanup;
320      }
321      c->cmd = c->lastcmd = cmd;
322      if (cmd->flags & CMD_NOSCRIPT) {
323          luaPushError(lua, "This Redis command is not allowed from scripts");
324          goto cleanup;
325      }
326      if (cmd->flags & CMD_WRITE) {
327          int deny_write_type = writeCommandsDeniedByDiskError();
328          if (server.lua_random_dirty && !server.lua_replicate_commands) {
329              luaPushError(lua,
330                  "Write commands not allowed after non deterministic commands. Call redis.replicate_commands() at the start of your script in order to switch to single commands replication mode.");
331              goto cleanup;
332          } else if (server.masterhost && server.repl_slave_ro &&
333                     !server.loading &&
334                     !(server.lua_caller->flags & CLIENT_MASTER))
335          {
336              luaPushError(lua, shared.roslaveerr->ptr);
337              goto cleanup;
338          } else if (deny_write_type != DISK_ERROR_TYPE_NONE) {
339              if (deny_write_type == DISK_ERROR_TYPE_RDB) {
340                  luaPushError(lua, shared.bgsaveerr->ptr);
341              } else {
342                  sds aof_write_err = sdscatfmt(sdsempty(),
343                      "-MISCONF Errors writing to the AOF file: %s\r\n",
344                      strerror(server.aof_last_write_errno));
345                  luaPushError(lua, aof_write_err);
346                  sdsfree(aof_write_err);
347              }
348              goto cleanup;
349          }
350      }
351      if (server.maxmemory &&             &bsol;* Maxmemory is actually enabled. */
352          !server.loading &&              &bsol;* Don't care about mem if loading. */
353          !server.masterhost &&           &bsol;* Slave must execute the script. */
354          server.lua_write_dirty == 0 &&  &bsol;* Script had no side effects so far. */
355          server.lua_oom &&               &bsol;* Detected OOM when script start. */
356          (cmd->flags & CMD_DENYOOM))
357      {
358          luaPushError(lua, shared.oomerr->ptr);
359          goto cleanup;
360      }
361      if (cmd->flags & CMD_RANDOM) server.lua_random_dirty = 1;
362      if (cmd->flags & CMD_WRITE) server.lua_write_dirty = 1;
363      if (server.cluster_enabled && !server.loading &&
364          !(server.lua_caller->flags & CLIENT_MASTER))
365      {
366          c->flags &= ~(CLIENT_READONLY|CLIENT_ASKING);
367          c->flags |= server.lua_caller->flags & (CLIENT_READONLY|CLIENT_ASKING);
368          if (getNodeByQuery(c,c->cmd,c->argv,c->argc,NULL,NULL) !=
369                             server.cluster->myself)
370          {
371              luaPushError(lua,
372                  "Lua script attempted to access a non local key in a "
373                  "cluster node");
374              goto cleanup;
375          }
376      }
377      if (server.lua_replicate_commands &&
378          !server.lua_multi_emitted &&
379          !(server.lua_caller->flags & CLIENT_MULTI) &&
380          server.lua_write_dirty &&
381          server.lua_repl != PROPAGATE_NONE)
382      {
383          execCommandPropagateMulti(server.lua_caller);
384          server.lua_multi_emitted = 1;
385      }
386      int call_flags = CMD_CALL_SLOWLOG | CMD_CALL_STATS;
387      if (server.lua_replicate_commands) {
388          if (server.lua_repl & PROPAGATE_AOF)
389              call_flags |= CMD_CALL_PROPAGATE_AOF;
390          if (server.lua_repl & PROPAGATE_REPL)
391              call_flags |= CMD_CALL_PROPAGATE_REPL;
392      }
393      call(c,call_flags);
394      if (listLength(c->reply) == 0 && c->bufpos < PROTO_REPLY_CHUNK_BYTES) {
395          c->buf[c->bufpos] = '\0';
396          reply = c->buf;
397          c->bufpos = 0;
398      } else {
399          reply = sdsnewlen(c->buf,c->bufpos);
400          c->bufpos = 0;
401          while(listLength(c->reply)) {
402              clientReplyBlock *o = listNodeValue(listFirst(c->reply));
403              reply = sdscatlen(reply,o->buf,o->used);
404              listDelNode(c->reply,listFirst(c->reply));
405          }
406      }
407      if (raise_error && reply[0] != '-') raise_error = 0;
408      redisProtocolToLuaType(lua,reply);
409      if (ldb.active && ldb.step)
410          ldbLogRedisReply(reply);
411      if ((cmd->flags & CMD_SORT_FOR_SCRIPT) &&
412          (server.lua_replicate_commands == 0) &&
413          (reply[0] == '*' && reply[1] != '-')) {
414              luaSortArray(lua);
415      }
416      if (reply != c->buf) sdsfree(reply);
417      c->reply_bytes = 0;
418  cleanup:
419      for (j = 0; j < c->argc; j++) {
420          robj *o = c->argv[j];
421          if (j < LUA_CMD_OBJCACHE_SIZE &&
422              o->refcount == 1 &&
423              (o->encoding == OBJ_ENCODING_RAW ||
424               o->encoding == OBJ_ENCODING_EMBSTR) &&
425              sdslen(o->ptr) <= LUA_CMD_OBJCACHE_MAX_LEN)
426          {
427              sds s = o->ptr;
428              if (cached_objects[j]) decrRefCount(cached_objects[j]);
429              cached_objects[j] = o;
430              cached_objects_len[j] = sdsalloc(s);
431          } else {
432              decrRefCount(o);
433          }
434      }
435      if (c->argv != argv) {
436          zfree(c->argv);
437          argv = NULL;
438          argv_size = 0;
439      }
440      if (raise_error) {
441          inuse--;
442          return luaRaiseError(lua);
443      }
444      inuse--;
445      return 1;
446  }
447  int luaRedisCallCommand(lua_State *lua) {
448      return luaRedisGenericCommand(lua,1);
449  }
450  int luaRedisPCallCommand(lua_State *lua) {
451      return luaRedisGenericCommand(lua,0);
452  }
453  int luaRedisSha1hexCommand(lua_State *lua) {
454      int argc = lua_gettop(lua);
455      char digest[41];
456      size_t len;
457      char *s;
458      if (argc != 1) {
459          lua_pushstring(lua, "wrong number of arguments");
460          return lua_error(lua);
461      }
462      s = (char*)lua_tolstring(lua,1,&len);
463      sha1hex(digest,s,len);
464      lua_pushstring(lua,digest);
465      return 1;
466  }
467  int luaRedisReturnSingleFieldTable(lua_State *lua, char *field) {
468      if (lua_gettop(lua) != 1 || lua_type(lua,-1) != LUA_TSTRING) {
469          luaPushError(lua, "wrong number or type of arguments");
470          return 1;
471      }
472      lua_newtable(lua);
473      lua_pushstring(lua, field);
474      lua_pushvalue(lua, -3);
475      lua_settable(lua, -3);
476      return 1;
477  }
478  int luaRedisErrorReplyCommand(lua_State *lua) {
479      return luaRedisReturnSingleFieldTable(lua,"err");
480  }
481  int luaRedisStatusReplyCommand(lua_State *lua) {
482      return luaRedisReturnSingleFieldTable(lua,"ok");
483  }
484  int luaRedisReplicateCommandsCommand(lua_State *lua) {
485      if (server.lua_write_dirty) {
486          lua_pushboolean(lua,0);
487      } else {
488          server.lua_replicate_commands = 1;
489          redisSrand48(rand());
490          lua_pushboolean(lua,1);
491      }
492      return 1;
493  }
494  int luaRedisBreakpointCommand(lua_State *lua) {
495      if (ldb.active) {
496          ldb.luabp = 1;
497          lua_pushboolean(lua,1);
498      } else {
499          lua_pushboolean(lua,0);
500      }
501      return 1;
502  }
503  int luaRedisDebugCommand(lua_State *lua) {
504      if (!ldb.active) return 0;
505      int argc = lua_gettop(lua);
506      sds log = sdscatprintf(sdsempty(),"<debug> line %d: ", ldb.currentline);
507      while(argc--) {
508          log = ldbCatStackValue(log,lua,-1 - argc);
509          if (argc != 0) log = sdscatlen(log,", ",2);
510      }
511      ldbLog(log);
512      return 0;
513  }
514  int luaRedisSetReplCommand(lua_State *lua) {
515      int argc = lua_gettop(lua);
516      int flags;
517      if (server.lua_replicate_commands == 0) {
518          lua_pushstring(lua, "You can set the replication behavior only after turning on single commands replication with redis.replicate_commands().");
519          return lua_error(lua);
520      } else if (argc != 1) {
521          lua_pushstring(lua, "redis.set_repl() requires two arguments.");
522          return lua_error(lua);
523      }
524      flags = lua_tonumber(lua,-1);
525      if ((flags & ~(PROPAGATE_AOF|PROPAGATE_REPL)) != 0) {
526          lua_pushstring(lua, "Invalid replication flags. Use REPL_AOF, REPL_REPLICA, REPL_ALL or REPL_NONE.");
527          return lua_error(lua);
528      }
529      server.lua_repl = flags;
530      return 0;
531  }
532  int luaLogCommand(lua_State *lua) {
533      int j, argc = lua_gettop(lua);
534      int level;
535      sds log;
536      if (argc < 2) {
537          lua_pushstring(lua, "redis.log() requires two arguments or more.");
538          return lua_error(lua);
539      } else if (!lua_isnumber(lua,-argc)) {
540          lua_pushstring(lua, "First argument must be a number (log level).");
541          return lua_error(lua);
542      }
543      level = (int)lua_tonumber(lua,-argc);                                       WIN_PORT_FIX &bsol;* cast (int) */
544      if (level < LL_DEBUG || level > LL_WARNING) {
545          lua_pushstring(lua, "Invalid debug level.");
546          return lua_error(lua);
547      }
548      log = sdsempty();
549      for (j = 1; j < argc; j++) {
550          size_t len;
551          char *s;
552          s = (char*)lua_tolstring(lua,(-argc)+j,&len);
553          if (s) {
554              if (j != 1) log = sdscatlen(log," ",1);
555              log = sdscatlen(log,s,len);
556          }
557      }
558      serverLogRaw(level,log);
559      sdsfree(log);
560      return 0;
561  }
562  void luaLoadLib(lua_State *lua, const char *libname, lua_CFunction luafunc) {
563    lua_pushcfunction(lua, luafunc);
564    lua_pushstring(lua, libname);
565    lua_call(lua, 1, 0);
566  }
567  LUALIB_API int (luaopen_cjson) (lua_State *L);
568  LUALIB_API int (luaopen_struct) (lua_State *L);
569  LUALIB_API int (luaopen_cmsgpack) (lua_State *L);
570  LUALIB_API int (luaopen_bit) (lua_State *L);
571  void luaLoadLibraries(lua_State *lua) {
572      luaLoadLib(lua, "", luaopen_base);
573      luaLoadLib(lua, LUA_TABLIBNAME, luaopen_table);
574      luaLoadLib(lua, LUA_STRLIBNAME, luaopen_string);
575      luaLoadLib(lua, LUA_MATHLIBNAME, luaopen_math);
576      luaLoadLib(lua, LUA_DBLIBNAME, luaopen_debug);
577      luaLoadLib(lua, "cjson", luaopen_cjson);
578      luaLoadLib(lua, "struct", luaopen_struct);
579      luaLoadLib(lua, "cmsgpack", luaopen_cmsgpack);
580      luaLoadLib(lua, "bit", luaopen_bit);
581  #if 0 &bsol;* Stuff that we don't load currently, for sandboxing concerns. */
582      luaLoadLib(lua, LUA_LOADLIBNAME, luaopen_package);
583      luaLoadLib(lua, LUA_OSLIBNAME, luaopen_os);
584  #endif
585  }
586  void luaRemoveUnsupportedFunctions(lua_State *lua) {
587      lua_pushnil(lua);
588      lua_setglobal(lua,"loadfile");
589      lua_pushnil(lua);
590      lua_setglobal(lua,"dofile");
591  }
592  void scriptingEnableGlobalsProtection(lua_State *lua) {
593      char *s[32];
594      sds code = sdsempty();
595      int j = 0;
596      s[j++]="local dbg=debug\n";
597      s[j++]="local mt = {}\n";
598      s[j++]="setmetatable(_G, mt)\n";
599      s[j++]="mt.__newindex = function (t, n, v)\n";
600      s[j++]="  if dbg.getinfo(2) then\n";
601      s[j++]="    local w = dbg.getinfo(2, \"S\").what\n";
602      s[j++]="    if w ~= \"main\" and w ~= \"C\" then\n";
603      s[j++]="      error(\"Script attempted to create global variable '\"..tostring(n)..\"'\", 2)\n";
604      s[j++]="    end\n";
605      s[j++]="  end\n";
606      s[j++]="  rawset(t, n, v)\n";
607      s[j++]="end\n";
608      s[j++]="mt.__index = function (t, n)\n";
609      s[j++]="  if dbg.getinfo(2) and dbg.getinfo(2, \"S\").what ~= \"C\" then\n";
610      s[j++]="    error(\"Script attempted to access nonexistent global variable '\"..tostring(n)..\"'\", 2)\n";
611      s[j++]="  end\n";
612      s[j++]="  return rawget(t, n)\n";
613      s[j++]="end\n";
614      s[j++]="debug = nil\n";
615      s[j++]=NULL;
616      for (j = 0; s[j] != NULL; j++) code = sdscatlen(code,s[j],strlen(s[j]));
617      luaL_loadbuffer(lua,code,sdslen(code),"@enable_strict_lua");
618      lua_pcall(lua,0,0,0);
619      sdsfree(code);
620  }
621  void scriptingInit(int setup) {
622      lua_State *lua = lua_open();
623      if (setup) {
624          server.lua_client = NULL;
625          server.lua_caller = NULL;
626          server.lua_timedout = 0;
627          ldbInit();
628      }
629      luaLoadLibraries(lua);
630      luaRemoveUnsupportedFunctions(lua);
631      server.lua_scripts = dictCreate(&shaScriptObjectDictType,NULL);
632      server.lua_scripts_mem = 0;
633      lua_newtable(lua);
634      lua_pushstring(lua,"call");
635      lua_pushcfunction(lua,luaRedisCallCommand);
636      lua_settable(lua,-3);
637      lua_pushstring(lua,"pcall");
638      lua_pushcfunction(lua,luaRedisPCallCommand);
639      lua_settable(lua,-3);
640      lua_pushstring(lua,"log");
641      lua_pushcfunction(lua,luaLogCommand);
642      lua_settable(lua,-3);
643      lua_pushstring(lua,"LOG_DEBUG");
644      lua_pushnumber(lua,LL_DEBUG);
645      lua_settable(lua,-3);
646      lua_pushstring(lua,"LOG_VERBOSE");
647      lua_pushnumber(lua,LL_VERBOSE);
648      lua_settable(lua,-3);
649      lua_pushstring(lua,"LOG_NOTICE");
650      lua_pushnumber(lua,LL_NOTICE);
651      lua_settable(lua,-3);
652      lua_pushstring(lua,"LOG_WARNING");
653      lua_pushnumber(lua,LL_WARNING);
654      lua_settable(lua,-3);
655      lua_pushstring(lua, "sha1hex");
656      lua_pushcfunction(lua, luaRedisSha1hexCommand);
657      lua_settable(lua, -3);
658      lua_pushstring(lua, "error_reply");
659      lua_pushcfunction(lua, luaRedisErrorReplyCommand);
660      lua_settable(lua, -3);
661      lua_pushstring(lua, "status_reply");
662      lua_pushcfunction(lua, luaRedisStatusReplyCommand);
663      lua_settable(lua, -3);
664      lua_pushstring(lua, "replicate_commands");
665      lua_pushcfunction(lua, luaRedisReplicateCommandsCommand);
666      lua_settable(lua, -3);
667      lua_pushstring(lua,"set_repl");
668      lua_pushcfunction(lua,luaRedisSetReplCommand);
669      lua_settable(lua,-3);
670      lua_pushstring(lua,"REPL_NONE");
671      lua_pushnumber(lua,PROPAGATE_NONE);
672      lua_settable(lua,-3);
673      lua_pushstring(lua,"REPL_AOF");
674      lua_pushnumber(lua,PROPAGATE_AOF);
675      lua_settable(lua,-3);
676      lua_pushstring(lua,"REPL_SLAVE");
677      lua_pushnumber(lua,PROPAGATE_REPL);
678      lua_settable(lua,-3);
679      lua_pushstring(lua,"REPL_REPLICA");
680      lua_pushnumber(lua,PROPAGATE_REPL);
681      lua_settable(lua,-3);
682      lua_pushstring(lua,"REPL_ALL");
683      lua_pushnumber(lua,PROPAGATE_AOF|PROPAGATE_REPL);
684      lua_settable(lua,-3);
685      lua_pushstring(lua,"breakpoint");
686      lua_pushcfunction(lua,luaRedisBreakpointCommand);
687      lua_settable(lua,-3);
688      lua_pushstring(lua,"debug");
689      lua_pushcfunction(lua,luaRedisDebugCommand);
690      lua_settable(lua,-3);
691      lua_setglobal(lua,"redis");
692      lua_getglobal(lua,"math");
693      lua_pushstring(lua,"random");
694      lua_pushcfunction(lua,redis_math_random);
695      lua_settable(lua,-3);
696      lua_pushstring(lua,"randomseed");
697      lua_pushcfunction(lua,redis_math_randomseed);
698      lua_settable(lua,-3);
699      lua_setglobal(lua,"math");
700      {
701          char *compare_func =    "function __redis__compare_helper(a,b)\n"
702                                  "  if a == false then a = '' end\n"
703                                  "  if b == false then b = '' end\n"
704                                  "  return a<b\n"
705                                  "end\n";
706          luaL_loadbuffer(lua,compare_func,strlen(compare_func),"@cmp_func_def");
707          lua_pcall(lua,0,0,0);
708      }
709      {
710          char *errh_func =       "local dbg = debug\n"
711                                  "function __redis__err__handler(err)\n"
712                                  "  local i = dbg.getinfo(2,'nSl')\n"
713                                  "  if i and i.what == 'C' then\n"
714                                  "    i = dbg.getinfo(3,'nSl')\n"
715                                  "  end\n"
716                                  "  if i then\n"
717                                  "    return i.source .. ':' .. i.currentline .. ': ' .. err\n"
718                                  "  else\n"
<span onclick='openModal()' class='match'>719                                  "    return err\n"
720                                  "  end\n"
721                                  "end\n";
722          luaL_loadbuffer(lua,errh_func,strlen(errh_func),"@err_handler_def");
723          lua_pcall(lua,0,0,0);
724      }
725      if (server.lua_client == NULL) {
</span>726          server.lua_client = createClient(-1);
727          server.lua_client->flags |= CLIENT_LUA;
728      }
729      scriptingEnableGlobalsProtection(lua);
730      server.lua = lua;
731  }
732  void scriptingRelease(void) {
733      dictRelease(server.lua_scripts);
734      server.lua_scripts_mem = 0;
735      lua_close(server.lua);
736  }
737  void scriptingReset(void) {
738      scriptingRelease();
739      scriptingInit(0);
740  }
741  void luaSetGlobalArray(lua_State *lua, char *var, robj **elev, int elec) {
742      int j;
743      lua_newtable(lua);
744      for (j = 0; j < elec; j++) {
745          lua_pushlstring(lua,(char*)elev[j]->ptr,sdslen(elev[j]->ptr));
746          lua_rawseti(lua,-2,j+1);
747      }
748      lua_setglobal(lua,var);
749  }
750  int redis_math_random (lua_State *L) {
751    lua_Number r = (lua_Number)(redisLrand48()%REDIS_LRAND48_MAX) /
752                                  (lua_Number)REDIS_LRAND48_MAX;
753    switch (lua_gettop(L)) {  &bsol;* check number of arguments */
754      case 0: {  &bsol;* no arguments */
755        lua_pushnumber(L, r);  &bsol;* Number between 0 and 1 */
756        break;
757      }
758      case 1: {  &bsol;* only upper limit */
759        int u = luaL_checkint(L, 1);
760        luaL_argcheck(L, 1<=u, 1, "interval is empty");
761        lua_pushnumber(L, floor(r*u)+1);  &bsol;* int between 1 and `u' */
762        break;
763      }
764      case 2: {  &bsol;* lower and upper limits */
765        int l = luaL_checkint(L, 1);
766        int u = luaL_checkint(L, 2);
767        luaL_argcheck(L, l<=u, 2, "interval is empty");
768        lua_pushnumber(L, floor(r*(u-l+1))+l);  &bsol;* int between `l' and `u' */
769        break;
770      }
771      default: return luaL_error(L, "wrong number of arguments");
772    }
773    return 1;
774  }
775  int redis_math_randomseed (lua_State *L) {
776    redisSrand48(luaL_checkint(L, 1));
777    return 0;
778  }
779  sds luaCreateFunction(client *c, lua_State *lua, robj *body) {
780      char funcname[43];
781      dictEntry *de;
782      funcname[0] = 'f';
783      funcname[1] = '_';
784      sha1hex(funcname+2,body->ptr,sdslen(body->ptr));
785      sds sha = sdsnewlen(funcname+2,40);
786      if ((de = dictFind(server.lua_scripts,sha)) != NULL) {
787          sdsfree(sha);
788          return dictGetKey(de);
789      }
790      sds funcdef = sdsempty();
791      funcdef = sdscat(funcdef,"function ");
792      funcdef = sdscatlen(funcdef,funcname,42);
793      funcdef = sdscatlen(funcdef,"() ",3);
794      funcdef = sdscatlen(funcdef,body->ptr,sdslen(body->ptr));
795      funcdef = sdscatlen(funcdef,"\nend",4);
796      if (luaL_loadbuffer(lua,funcdef,sdslen(funcdef),"@user_script")) {
797          if (c != NULL) {
798              addReplyErrorFormat(c,
799                  "Error compiling script (new function): %s\n",
800                  lua_tostring(lua,-1));
801          }
802          lua_pop(lua,1);
803          sdsfree(sha);
804          sdsfree(funcdef);
805          return NULL;
806      }
807      sdsfree(funcdef);
808      if (lua_pcall(lua,0,0,0)) {
809          if (c != NULL) {
810              addReplyErrorFormat(c,"Error running script (new function): %s\n",
811                  lua_tostring(lua,-1));
812          }
813          lua_pop(lua,1);
814          sdsfree(sha);
815          return NULL;
816      }
817      int retval = dictAdd(server.lua_scripts,sha,body);
818      serverAssertWithInfo(c ? c : server.lua_client,NULL,retval == DICT_OK);
819      server.lua_scripts_mem += sdsZmallocSize(sha) + getStringObjectSdsUsedMemory(body);
820      incrRefCount(body);
821      return sha;
822  }
823  void luaMaskCountHook(lua_State *lua, lua_Debug *ar) {
824      PORT_LONGLONG elapsed = mstime() - server.lua_time_start;
825      UNUSED(ar);
826      UNUSED(lua);
827      if (elapsed >= server.lua_time_limit && server.lua_timedout == 0) {
828          serverLog(LL_WARNING,"Lua slow script detected: still in execution after %lld milliseconds. You can try killing the script using the SCRIPT KILL command.",elapsed);
829          server.lua_timedout = 1;
830          protectClient(server.lua_caller);
831      }
832      if (server.lua_timedout) processEventsWhileBlocked();
833      if (server.lua_kill) {
834          serverLog(LL_WARNING,"Lua script killed by user with SCRIPT KILL.");
835          lua_pushstring(lua,"Script killed by user with SCRIPT KILL...");
836          lua_error(lua);
837      }
838  }
839  void evalGenericCommand(client *c, int evalsha) {
840      lua_State *lua = server.lua;
841      char funcname[43];
842      PORT_LONGLONG numkeys;
843      PORT_LONGLONG initial_server_dirty = server.dirty;
844      int delhook = 0, err;
845      redisSrand48(0);
846      server.lua_random_dirty = 0;
847      server.lua_write_dirty = 0;
848      server.lua_replicate_commands = server.lua_always_replicate_commands;
849      server.lua_multi_emitted = 0;
850      server.lua_repl = PROPAGATE_AOF|PROPAGATE_REPL;
851      if (getLongLongFromObjectOrReply(c,c->argv[2],&numkeys,NULL) != C_OK)
852          return;
853      if (numkeys > (c->argc - 3)) {
854          addReplyError(c,"Number of keys can't be greater than number of args");
855          return;
856      } else if (numkeys < 0) {
857          addReplyError(c,"Number of keys can't be negative");
858          return;
859      }
860      funcname[0] = 'f';
861      funcname[1] = '_';
862      if (!evalsha) {
863          sha1hex(funcname+2,c->argv[1]->ptr,sdslen(c->argv[1]->ptr));
864      } else {
865          int j;
866          char *sha = c->argv[1]->ptr;
867          for (j = 0; j < 40; j++)
868              funcname[j+2] = (sha[j] >= 'A' && sha[j] <= 'Z') ?
869                  sha[j]+('a'-'A') : sha[j];
870          funcname[42] = '\0';
871      }
872      lua_getglobal(lua, "__redis__err__handler");
873      lua_getglobal(lua, funcname);
874      if (lua_isnil(lua,-1)) {
875          lua_pop(lua,1); &bsol;* remove the nil from the stack */
876          if (evalsha) {
877              lua_pop(lua,1); &bsol;* remove the error handler from the stack. */
878              addReply(c, shared.noscripterr);
879              return;
880          }
881          if (luaCreateFunction(c,lua,c->argv[1]) == NULL) {
882              lua_pop(lua,1); &bsol;* remove the error handler from the stack. */
883              return;
884          }
885          lua_getglobal(lua, funcname);
886          serverAssert(!lua_isnil(lua,-1));
887      }
888      luaSetGlobalArray(lua,"KEYS",c->argv+3,(int)numkeys);                       WIN_PORT_FIX &bsol;* cast (int) */
889      luaSetGlobalArray(lua,"ARGV",c->argv+3+numkeys,(int)(c->argc-3-numkeys));   WIN_PORT_FIX &bsol;* cast (int) */
890      selectDb(server.lua_client,c->db->id);
891      server.lua_caller = c;
892      server.lua_time_start = mstime();
893      server.lua_kill = 0;
894      if (server.lua_time_limit > 0 && ldb.active == 0) {
895          lua_sethook(lua,luaMaskCountHook,LUA_MASKCOUNT,100000);
896          delhook = 1;
897      } else if (ldb.active) {
898          lua_sethook(server.lua,luaLdbLineHook,LUA_MASKLINE|LUA_MASKCOUNT,100000);
899          delhook = 1;
900      }
901      err = lua_pcall(lua,0,1,-2);
902      if (delhook) lua_sethook(lua,NULL,0,0); &bsol;* Disable hook */
903      if (server.lua_timedout) {
904          server.lua_timedout = 0;
905          unprotectClient(c);
906          if (server.masterhost && server.master)
907              queueClientForReprocessing(server.master);
908      }
909      server.lua_caller = NULL;
910      #define LUA_GC_CYCLE_PERIOD 50
911      {
912          static PORT_LONG gc_count = 0;
913          gc_count++;
914          if (gc_count == LUA_GC_CYCLE_PERIOD) {
915              lua_gc(lua,LUA_GCSTEP,LUA_GC_CYCLE_PERIOD);
916              gc_count = 0;
917          }
918      }
919      if (err) {
920          addReplyErrorFormat(c,"Error running script (call to %s): %s\n",
921              funcname, lua_tostring(lua,-1));
922          lua_pop(lua,2); &bsol;* Consume the Lua reply and remove error handler. */
923      } else {
924          luaReplyToRedisReply(c,lua); &bsol;* Convert and consume the reply. */
925          lua_pop(lua,1); &bsol;* Remove the error handler. */
926      }
927      if (server.lua_replicate_commands) {
928          preventCommandPropagation(c);
929          if (server.lua_multi_emitted) {
930              robj *propargv[1];
931              propargv[0] = createStringObject("EXEC",4);
932              alsoPropagate(server.execCommand,c->db->id,propargv,1,
933                  PROPAGATE_AOF|PROPAGATE_REPL);
934              decrRefCount(propargv[0]);
935          }
936      }
937      if (evalsha && !server.lua_replicate_commands) {
938          if (!replicationScriptCacheExists(c->argv[1]->ptr)) {
939              robj *script = dictFetchValue(server.lua_scripts,c->argv[1]->ptr);
940              replicationScriptCacheAdd(c->argv[1]->ptr);
941              serverAssertWithInfo(c,NULL,script != NULL);
942              if (server.dirty == initial_server_dirty) {
943                  rewriteClientCommandVector(c,3,
944                      resetRefCount(createStringObject("SCRIPT",6)),
945                      resetRefCount(createStringObject("LOAD",4)),
946                      script);
947              } else {
948                  rewriteClientCommandArgument(c,0,
949                      resetRefCount(createStringObject("EVAL",4)));
950                  rewriteClientCommandArgument(c,1,script);
951              }
952              forceCommandPropagation(c,PROPAGATE_REPL|PROPAGATE_AOF);
953          }
954      }
955  }
956  void evalCommand(client *c) {
957      if (!(c->flags & CLIENT_LUA_DEBUG))
958          evalGenericCommand(c,0);
959      else
960          evalGenericCommandWithDebugging(c,0);
961  }
962  void evalShaCommand(client *c) {
963      if (sdslen(c->argv[1]->ptr) != 40) {
964          addReply(c, shared.noscripterr);
965          return;
966      }
967      if (!(c->flags & CLIENT_LUA_DEBUG))
968          evalGenericCommand(c,1);
969      else {
970          addReplyError(c,"Please use EVAL instead of EVALSHA for debugging");
971          return;
972      }
973  }
974  void scriptCommand(client *c) {
975      if (c->argc == 2 && !strcasecmp(c->argv[1]->ptr,"help")) {
976          const char *help[] = {
977  "DEBUG (yes|sync|no) -- Set the debug mode for subsequent scripts executed.",
978  "EXISTS <sha1> [<sha1> ...] -- Return information about the existence of the scripts in the script cache.",
979  "FLUSH -- Flush the Lua scripts cache. Very dangerous on replicas.",
980  "KILL -- Kill the currently executing Lua script.",
981  "LOAD <script> -- Load a script into the scripts cache, without executing it.",
982  NULL
983          };
984          addReplyHelp(c, help);
985      } else if (c->argc == 2 && !strcasecmp(c->argv[1]->ptr,"flush")) {
986          scriptingReset();
987          addReply(c,shared.ok);
988          replicationScriptCacheFlush();
989          server.dirty++; &bsol;* Propagating this command is a good idea. */
990      } else if (c->argc >= 2 && !strcasecmp(c->argv[1]->ptr,"exists")) {
991          int j;
992          addReplyMultiBulkLen(c, c->argc-2);
993          for (j = 2; j < c->argc; j++) {
994              if (dictFind(server.lua_scripts,c->argv[j]->ptr))
995                  addReply(c,shared.cone);
996              else
997                  addReply(c,shared.czero);
998          }
999      } else if (c->argc == 3 && !strcasecmp(c->argv[1]->ptr,"load")) {
1000          sds sha = luaCreateFunction(c,server.lua,c->argv[2]);
1001          if (sha == NULL) return; &bsol;* The error was sent by luaCreateFunction(). */
1002          addReplyBulkCBuffer(c,sha,40);
1003          forceCommandPropagation(c,PROPAGATE_REPL|PROPAGATE_AOF);
1004      } else if (c->argc == 2 && !strcasecmp(c->argv[1]->ptr,"kill")) {
1005          if (server.lua_caller == NULL) {
1006              addReplySds(c,sdsnew("-NOTBUSY No scripts in execution right now.\r\n"));
1007          } else if (server.lua_caller->flags & CLIENT_MASTER) {
1008              addReplySds(c,sdsnew("-UNKILLABLE The busy script was sent by a master instance in the context of replication and cannot be killed.\r\n"));
1009          } else if (server.lua_write_dirty) {
1010              addReplySds(c,sdsnew("-UNKILLABLE Sorry the script already executed write commands against the dataset. You can either wait the script termination or kill the server in a hard way using the SHUTDOWN NOSAVE command.\r\n"));
1011          } else {
1012              server.lua_kill = 1;
1013              addReply(c,shared.ok);
1014          }
1015      } else if (c->argc == 3 && !strcasecmp(c->argv[1]->ptr,"debug")) {
1016          if (clientHasPendingReplies(c)) {
1017              addReplyError(c,"SCRIPT DEBUG must be called outside a pipeline");
1018              return;
1019          }
1020          if (!strcasecmp(c->argv[2]->ptr,"no")) {
1021              ldbDisable(c);
1022              addReply(c,shared.ok);
1023          } else if (!strcasecmp(c->argv[2]->ptr,"yes")) {
1024              ldbEnable(c);
1025              addReply(c,shared.ok);
1026          } else if (!strcasecmp(c->argv[2]->ptr,"sync")) {
1027              ldbEnable(c);
1028              addReply(c,shared.ok);
1029              c->flags |= CLIENT_LUA_DEBUG_SYNC;
1030          } else {
1031              addReplyError(c,"Use SCRIPT DEBUG yes/sync/no");
1032              return;
1033          }
1034      } else {
1035          addReplySubcommandSyntaxError(c);
1036      }
1037  }
1038  void ldbInit(void) {
1039      ldb.fd = -1;
1040      ldb.active = 0;
1041      ldb.logs = listCreate();
1042      listSetFreeMethod(ldb.logs,(void (*)(void*))sdsfree);
1043      ldb.children = listCreate();
1044      ldb.src = NULL;
1045      ldb.lines = 0;
1046      ldb.cbuf = sdsempty();
1047  }
1048  void ldbFlushLog(list *log) {
1049      listNode *ln;
1050      while((ln = listFirst(log)) != NULL)
1051          listDelNode(log,ln);
1052  }
1053  void ldbEnable(client *c) {
1054      c->flags |= CLIENT_LUA_DEBUG;
1055      ldbFlushLog(ldb.logs);
1056      ldb.fd = c->fd;
1057      ldb.step = 1;
1058      ldb.bpcount = 0;
1059      ldb.luabp = 0;
1060      sdsfree(ldb.cbuf);
1061      ldb.cbuf = sdsempty();
1062      ldb.maxlen = LDB_MAX_LEN_DEFAULT;
1063      ldb.maxlen_hint_sent = 0;
1064  }
1065  void ldbDisable(client *c) {
1066      c->flags &= ~(CLIENT_LUA_DEBUG|CLIENT_LUA_DEBUG_SYNC);
1067  }
1068  void ldbLog(sds entry) {
1069      listAddNodeTail(ldb.logs,entry);
1070  }
1071  void ldbLogWithMaxLen(sds entry) {
1072      int trimmed = 0;
1073      if (ldb.maxlen && sdslen(entry) > ldb.maxlen) {
1074          sdsrange(entry,0,ldb.maxlen-1);
1075          entry = sdscatlen(entry," ...",4);
1076          trimmed = 1;
1077      }
1078      ldbLog(entry);
1079      if (trimmed && ldb.maxlen_hint_sent == 0) {
1080          ldb.maxlen_hint_sent = 1;
1081          ldbLog(sdsnew(
1082          "<hint> The above reply was trimmed. Use 'maxlen 0' to disable trimming."));
1083      }
1084  }
1085  void ldbSendLogs(void) {
1086      sds proto = sdsempty();
1087      proto = sdscatfmt(proto,"*%i\r\n", (int)listLength(ldb.logs));
1088      while(listLength(ldb.logs)) {
1089          listNode *ln = listFirst(ldb.logs);
1090          proto = sdscatlen(proto,"+",1);
1091          sdsmapchars(ln->value,"\r\n","  ",2);
1092          proto = sdscatsds(proto,ln->value);
1093          proto = sdscatlen(proto,"\r\n",2);
1094          listDelNode(ldb.logs,ln);
1095      }
1096      if (write(ldb.fd,proto,sdslen(proto)) == -1) {
1097      }
1098      sdsfree(proto);
1099  }
1100  int ldbStartSession(client *c) {
1101  #ifndef _WIN32
1102      ldb.forked = (c->flags & CLIENT_LUA_DEBUG_SYNC) == 0;
1103      if (ldb.forked) {
1104          pid_t cp = fork();
1105          if (cp == -1) {
1106              addReplyError(c,"Fork() failed: can't run EVAL in debugging mode.");
1107              return 0;
1108          } else if (cp == 0) {
1109              struct sigaction act;
1110              sigemptyset(&act.sa_mask);
1111              act.sa_flags = 0;
1112              act.sa_handler = SIG_IGN;
1113              sigaction(SIGTERM, &act, NULL);
1114              sigaction(SIGINT, &act, NULL);
1115              serverLog(LL_WARNING,"Redis forked for debugging eval");
1116              closeListeningSockets(0);
1117          } else {
1118              listAddNodeTail(ldb.children,(void*)(unsigned long)cp);
1119              freeClientAsync(c); &bsol;* Close the client in the parent side. */
1120              return 0;
1121          }
1122      } else {
1123          serverLog(LL_WARNING,
1124              "Redis synchronous debugging eval session started");
1125      }
1126      anetBlock(NULL,ldb.fd);
1127      anetSendTimeout(NULL,ldb.fd,5000);
1128      ldb.active = 1;
1129      sds srcstring = sdsdup(c->argv[1]->ptr);
1130      size_t srclen = sdslen(srcstring);
1131      while(srclen && (srcstring[srclen-1] == '\n' ||
1132                       srcstring[srclen-1] == '\r'))
1133      {
1134          srcstring[--srclen] = '\0';
1135      }
1136      sdssetlen(srcstring,srclen);
1137      ldb.src = sdssplitlen(srcstring,sdslen(srcstring),"\n",1,&ldb.lines);
1138      sdsfree(srcstring);
1139      return 1;
1140  #endif 
1141      return 0;
1142  }
1143  void ldbEndSession(client *c) {
1144      ldbLog(sdsnew("<endsession>"));
1145      ldbSendLogs();
1146      if (ldb.forked) {
1147          writeToClient(c->fd, c, 0);
1148          serverLog(LL_WARNING,"Lua debugging session child exiting");
1149          exitFromChild(0);
1150      } else {
1151          serverLog(LL_WARNING,
1152              "Redis synchronous debugging eval session ended");
1153      }
1154      anetNonBlock(NULL,ldb.fd);
1155      anetSendTimeout(NULL,ldb.fd,0);
1156      c->flags |= CLIENT_CLOSE_AFTER_REPLY;
1157      sdsfreesplitres(ldb.src,ldb.lines);
1158      ldb.lines = 0;
1159      ldb.active = 0;
1160  }
1161  int ldbRemoveChild(pid_t pid) {
1162      listNode *ln = listSearchKey(ldb.children,(void*)(PORT_ULONG)pid);
1163      if (ln) {
1164          listDelNode(ldb.children,ln);
1165          return 1;
1166      }
1167      return 0;
1168  }
1169  int ldbPendingChildren(void) {
1170      return (int)listLength(ldb.children);                                       WIN_PORT_FIX &bsol;* cast (int) */
1171  }
1172  void ldbKillForkedSessions(void) {
1173  #ifndef _WIN32
1174      listIter li;
1175      listNode *ln;
1176      listRewind(ldb.children,&li);
1177      while((ln = listNext(&li))) {
1178          pid_t pid = (unsigned long) ln->value;
1179          serverLog(LL_WARNING,"Killing debugging session %ld",(long)pid);
1180          kill(pid,SIGKILL);
1181      }
1182      listRelease(ldb.children);
1183      ldb.children = listCreate();
1184  #endif
1185  }
1186  void evalGenericCommandWithDebugging(client *c, int evalsha) {
1187      if (ldbStartSession(c)) {
1188          evalGenericCommand(c,evalsha);
1189          ldbEndSession(c);
1190      } else {
1191          ldbDisable(c);
1192      }
1193  }
1194  char *ldbGetSourceLine(int line) {
1195      int idx = line-1;
1196      if (idx < 0 || idx >= ldb.lines) return "<out of range source code line>";
1197      return ldb.src[idx];
1198  }
1199  int ldbIsBreakpoint(int line) {
1200      int j;
1201      for (j = 0; j < ldb.bpcount; j++)
1202          if (ldb.bp[j] == line) return 1;
1203      return 0;
1204  }
1205  int ldbAddBreakpoint(int line) {
1206      if (line <= 0 || line > ldb.lines) return 0;
1207      if (!ldbIsBreakpoint(line) && ldb.bpcount != LDB_BREAKPOINTS_MAX) {
1208          ldb.bp[ldb.bpcount++] = line;
1209          return 1;
1210      }
1211      return 0;
1212  }
1213  int ldbDelBreakpoint(int line) {
1214      int j;
1215      for (j = 0; j < ldb.bpcount; j++) {
1216          if (ldb.bp[j] == line) {
1217              ldb.bpcount--;
1218              memmove(ldb.bp+j,ldb.bp+j+1,ldb.bpcount-j);
1219              return 1;
1220          }
1221      }
1222      return 0;
1223  }
1224  sds *ldbReplParseCommand(int *argcp) {
1225      sds *argv = NULL;
1226      int argc = 0;
1227      if (sdslen(ldb.cbuf) == 0) return NULL;
1228      sds copy = sdsdup(ldb.cbuf);
1229      char *p = copy;
1230      p = strchr(p,'*'); if (!p) goto protoerr;
1231      char *plen = p+1; &bsol;* Multi bulk len pointer. */
1232      p = strstr(p,"\r\n"); if (!p) goto protoerr;
1233      *p = '\0'; p += 2;
1234      *argcp = atoi(plen);
1235      if (*argcp <= 0 || *argcp > 1024) goto protoerr;
1236      argv = zmalloc(sizeof(sds)*(*argcp));
1237      argc = 0;
1238      while(argc < *argcp) {
1239          if (*p != '$') goto protoerr;
1240          plen = p+1; &bsol;* Bulk string len pointer. */
1241          p = strstr(p,"\r\n"); if (!p) goto protoerr;
1242          *p = '\0'; p += 2;
1243          int slen = atoi(plen); &bsol;* Length of this arg. */
1244          if (slen <= 0 || slen > 1024) goto protoerr;
1245          argv[argc++] = sdsnewlen(p,slen);
1246          p += slen; &bsol;* Skip the already parsed argument. */
1247          if (p[0] != '\r' || p[1] != '\n') goto protoerr;
1248          p += 2; &bsol;* Skip \r\n. */
1249      }
1250      sdsfree(copy);
1251      return argv;
1252  protoerr:
1253      sdsfreesplitres(argv,argc);
1254      sdsfree(copy);
1255      return NULL;
1256  }
1257  void ldbLogSourceLine(int lnum) {
1258      char *line = ldbGetSourceLine(lnum);
1259      char *prefix;
1260      int bp = ldbIsBreakpoint(lnum);
1261      int current = ldb.currentline == lnum;
1262      if (current && bp)
1263          prefix = "->#";
1264      else if (current)
1265          prefix = "-> ";
1266      else if (bp)
1267          prefix = "  #";
1268      else
1269          prefix = "   ";
1270      sds thisline = sdscatprintf(sdsempty(),"%s%-3d %s", prefix, lnum, line);
1271      ldbLog(thisline);
1272  }
1273  void ldbList(int around, int context) {
1274      int j;
1275      for (j = 1; j <= ldb.lines; j++) {
1276          if (around != 0 && abs(around-j) > context) continue;
1277          ldbLogSourceLine(j);
1278      }
1279  }
1280  #define LDB_MAX_VALUES_DEPTH (LUA_MINSTACK/2)
1281  sds ldbCatStackValueRec(sds s, lua_State *lua, int idx, int level) {
1282      int t = lua_type(lua,idx);
1283      if (level++ == LDB_MAX_VALUES_DEPTH)
1284          return sdscat(s,"<max recursion level reached! Nested table?>");
1285      switch(t) {
1286      case LUA_TSTRING:
1287          {
1288          size_t strl;
1289          char *strp = (char*)lua_tolstring(lua,idx,&strl);
1290          s = sdscatrepr(s,strp,strl);
1291          }
1292          break;
1293      case LUA_TBOOLEAN:
1294          s = sdscat(s,lua_toboolean(lua,idx) ? "true" : "false");
1295          break;
1296      case LUA_TNUMBER:
1297          s = sdscatprintf(s,"%g",(double)lua_tonumber(lua,idx));
1298          break;
1299      case LUA_TNIL:
1300          s = sdscatlen(s,"nil",3);
1301          break;
1302      case LUA_TTABLE:
1303          {
1304          int expected_index = 1; &bsol;* First index we expect in an array. */
1305          int is_array = 1; &bsol;* Will be set to null if check fails. */
1306          sds repr1 = sdsempty();
1307          sds repr2 = sdsempty();
1308          lua_pushnil(lua); &bsol;* The first key to start the iteration is nil. */
1309          while (lua_next(lua,idx-1)) {
1310              if (is_array &&
1311                  (lua_type(lua,-2) != LUA_TNUMBER ||
1312                   lua_tonumber(lua,-2) != expected_index)) is_array = 0;
1313              repr1 = ldbCatStackValueRec(repr1,lua,-1,level);
1314              repr1 = sdscatlen(repr1,"; ",2);
1315              repr2 = sdscatlen(repr2,"[",1);
1316              repr2 = ldbCatStackValueRec(repr2,lua,-2,level);
1317              repr2 = sdscatlen(repr2,"]=",2);
1318              repr2 = ldbCatStackValueRec(repr2,lua,-1,level);
1319              repr2 = sdscatlen(repr2,"; ",2);
1320              lua_pop(lua,1); &bsol;* Stack: table, key. Ready for next iteration. */
1321              expected_index++;
1322          }
1323          if (sdslen(repr1)) sdsrange(repr1,0,-3);
1324          if (sdslen(repr2)) sdsrange(repr2,0,-3);
1325          s = sdscatlen(s,"{",1);
1326          s = sdscatsds(s,is_array ? repr1 : repr2);
1327          s = sdscatlen(s,"}",1);
1328          sdsfree(repr1);
1329          sdsfree(repr2);
1330          }
1331          break;
1332      case LUA_TFUNCTION:
1333      case LUA_TUSERDATA:
1334      case LUA_TTHREAD:
1335      case LUA_TLIGHTUSERDATA:
1336          {
1337          const void *p = lua_topointer(lua,idx);
1338          char *typename = "unknown";
1339          if (t == LUA_TFUNCTION) typename = "function";
1340          else if (t == LUA_TUSERDATA) typename = "userdata";
1341          else if (t == LUA_TTHREAD) typename = "thread";
1342          else if (t == LUA_TLIGHTUSERDATA) typename = "light-userdata";
1343          s = sdscatprintf(s,"\"%s@%p\"",typename,p);
1344          }
1345          break;
1346      default:
1347          s = sdscat(s,"\"<unknown-lua-type>\"");
1348          break;
1349      }
1350      return s;
1351  }
1352  sds ldbCatStackValue(sds s, lua_State *lua, int idx) {
1353      return ldbCatStackValueRec(s,lua,idx,0);
1354  }
1355  void ldbLogStackValue(lua_State *lua, char *prefix) {
1356      sds s = sdsnew(prefix);
1357      s = ldbCatStackValue(s,lua,-1);
1358      ldbLogWithMaxLen(s);
1359  }
1360  char *ldbRedisProtocolToHuman_Int(sds *o, char *reply);
1361  char *ldbRedisProtocolToHuman_Bulk(sds *o, char *reply);
1362  char *ldbRedisProtocolToHuman_Status(sds *o, char *reply);
1363  char *ldbRedisProtocolToHuman_MultiBulk(sds *o, char *reply);
1364  char *ldbRedisProtocolToHuman(sds *o, char *reply) {
1365      char *p = reply;
1366      switch(*p) {
1367      case ':': p = ldbRedisProtocolToHuman_Int(o,reply); break;
1368      case '$': p = ldbRedisProtocolToHuman_Bulk(o,reply); break;
1369      case '+': p = ldbRedisProtocolToHuman_Status(o,reply); break;
1370      case '-': p = ldbRedisProtocolToHuman_Status(o,reply); break;
1371      case '*': p = ldbRedisProtocolToHuman_MultiBulk(o,reply); break;
1372      }
1373      return p;
1374  }
1375  char *ldbRedisProtocolToHuman_Int(sds *o, char *reply) {
1376      char *p = strchr(reply+1,'\r');
1377      *o = sdscatlen(*o,reply+1,p-reply-1);
1378      return p+2;
1379  }
1380  char *ldbRedisProtocolToHuman_Bulk(sds *o, char *reply) {
1381      char *p = strchr(reply+1,'\r');
1382      PORT_LONGLONG bulklen;
1383      string2ll(reply+1,p-reply-1,&bulklen);
1384      if (bulklen == -1) {
1385          *o = sdscatlen(*o,"NULL",4);
1386          return p+2;
1387      } else {
1388          *o = sdscatrepr(*o,p+2,bulklen);
1389          return p+2+bulklen+2;
1390      }
1391  }
1392  char *ldbRedisProtocolToHuman_Status(sds *o, char *reply) {
1393      char *p = strchr(reply+1,'\r');
1394      *o = sdscatrepr(*o,reply,p-reply);
1395      return p+2;
1396  }
1397  char *ldbRedisProtocolToHuman_MultiBulk(sds *o, char *reply) {
1398      char *p = strchr(reply+1,'\r');
1399      PORT_LONGLONG mbulklen;
1400      int j = 0;
1401      string2ll(reply+1,p-reply-1,&mbulklen);
1402      p += 2;
1403      if (mbulklen == -1) {
1404          *o = sdscatlen(*o,"NULL",4);
1405          return p;
1406      }
1407      *o = sdscatlen(*o,"[",1);
1408      for (j = 0; j < mbulklen; j++) {
1409          p = ldbRedisProtocolToHuman(o,p);
1410          if (j != mbulklen-1) *o = sdscatlen(*o,",",1);
1411      }
1412      *o = sdscatlen(*o,"]",1);
1413      return p;
1414  }
1415  void ldbLogRedisReply(char *reply) {
1416      sds log = sdsnew("<reply> ");
1417      ldbRedisProtocolToHuman(&log,reply);
1418      ldbLogWithMaxLen(log);
1419  }
1420  void ldbPrint(lua_State *lua, char *varname) {
1421      lua_Debug ar;
1422      int l = 0; &bsol;* Stack level. */
1423      while (lua_getstack(lua,l,&ar) != 0) {
1424          l++;
1425          const char *name;
1426          int i = 1; &bsol;* Variable index. */
1427          while((name = lua_getlocal(lua,&ar,i)) != NULL) {
1428              i++;
1429              if (strcmp(varname,name) == 0) {
1430                  ldbLogStackValue(lua,"<value> ");
1431                  lua_pop(lua,1);
1432                  return;
1433              } else {
1434                  lua_pop(lua,1); &bsol;* Discard the var name on the stack. */
1435              }
1436          }
1437      }
1438      if (!strcmp(varname,"ARGV") || !strcmp(varname,"KEYS")) {
1439          lua_getglobal(lua, varname);
1440          ldbLogStackValue(lua,"<value> ");
1441          lua_pop(lua,1);
1442      } else {
1443          ldbLog(sdsnew("No such variable."));
1444      }
1445  }
1446  void ldbPrintAll(lua_State *lua) {
1447      lua_Debug ar;
1448      int vars = 0;
1449      if (lua_getstack(lua,0,&ar) != 0) {
1450          const char *name;
1451          int i = 1; &bsol;* Variable index. */
1452          while((name = lua_getlocal(lua,&ar,i)) != NULL) {
1453              i++;
1454              if (!strstr(name,"(*temporary)")) {
1455                  sds prefix = sdscatprintf(sdsempty(),"<value> %s = ",name);
1456                  ldbLogStackValue(lua,prefix);
1457                  sdsfree(prefix);
1458                  vars++;
1459              }
1460              lua_pop(lua,1);
1461          }
1462      }
1463      if (vars == 0) {
1464          ldbLog(sdsnew("No local variables in the current context."));
1465      }
1466  }
1467  void ldbBreak(sds *argv, int argc) {
1468      if (argc == 1) {
1469          if (ldb.bpcount == 0) {
1470              ldbLog(sdsnew("No breakpoints set. Use 'b <line>' to add one."));
1471              return;
1472          } else {
1473              ldbLog(sdscatfmt(sdsempty(),"%i breakpoints set:",ldb.bpcount));
1474              int j;
1475              for (j = 0; j < ldb.bpcount; j++)
1476                  ldbLogSourceLine(ldb.bp[j]);
1477          }
1478      } else {
1479          int j;
1480          for (j = 1; j < argc; j++) {
1481              char *arg = argv[j];
1482              PORT_LONG line;
1483              if (!string2l(arg,sdslen(arg),&line)) {
1484                  ldbLog(sdscatfmt(sdsempty(),"Invalid argument:'%s'",arg));
1485              } else {
1486                  if (line == 0) {
1487                      ldb.bpcount = 0;
1488                      ldbLog(sdsnew("All breakpoints removed."));
1489                  } else if (line > 0) {
1490                      if (ldb.bpcount == LDB_BREAKPOINTS_MAX) {
1491                          ldbLog(sdsnew("Too many breakpoints set."));
1492                      } else if (ldbAddBreakpoint((int)line)) {                   WIN_PORT_FIX &bsol;* cast (int) */
1493                          ldbList((int)line,1);                                   WIN_PORT_FIX &bsol;* cast (int) */
1494                      } else {
1495                          ldbLog(sdsnew("Wrong line number."));
1496                      }
1497                  } else if (line < 0) {
1498                      if (ldbDelBreakpoint((int)(-line)))                         WIN_PORT_FIX &bsol;* cast (int) */
1499                          ldbLog(sdsnew("Breakpoint removed."));
1500                      else
1501                          ldbLog(sdsnew("No breakpoint in the specified line."));
1502                  }
1503              }
1504          }
1505      }
1506  }
1507  void ldbEval(lua_State *lua, sds *argv, int argc) {
1508      sds code = sdsjoinsds(argv+1,argc-1," ",1);
1509      sds expr = sdscatsds(sdsnew("return "),code);
1510      if (luaL_loadbuffer(lua,expr,sdslen(expr),"@ldb_eval")) {
1511          lua_pop(lua,1);
1512          if (luaL_loadbuffer(lua,code,sdslen(code),"@ldb_eval")) {
1513              ldbLog(sdscatfmt(sdsempty(),"<error> %s",lua_tostring(lua,-1)));
1514              lua_pop(lua,1);
1515              sdsfree(code);
1516              sdsfree(expr);
1517              return;
1518          }
1519      }
1520      sdsfree(code);
1521      sdsfree(expr);
1522      if (lua_pcall(lua,0,1,0)) {
1523          ldbLog(sdscatfmt(sdsempty(),"<error> %s",lua_tostring(lua,-1)));
1524          lua_pop(lua,1);
1525          return;
1526      }
1527      ldbLogStackValue(lua,"<retval> ");
1528      lua_pop(lua,1);
1529  }
1530  void ldbRedis(lua_State *lua, sds *argv, int argc) {
1531      int j, saved_rc = server.lua_replicate_commands;
1532      lua_getglobal(lua,"redis");
1533      lua_pushstring(lua,"call");
1534      lua_gettable(lua,-2);       &bsol;* Stack: redis, redis.call */
1535      for (j = 1; j < argc; j++)
1536          lua_pushlstring(lua,argv[j],sdslen(argv[j]));
1537      ldb.step = 1;               &bsol;* Force redis.call() to log. */
1538      server.lua_replicate_commands = 1;
1539      lua_pcall(lua,argc-1,1,0);  &bsol;* Stack: redis, result */
1540      ldb.step = 0;               &bsol;* Disable logging. */
1541      server.lua_replicate_commands = saved_rc;
1542      lua_pop(lua,2);             &bsol;* Discard the result and clean the stack. */
1543  }
1544  void ldbTrace(lua_State *lua) {
1545      lua_Debug ar;
1546      int level = 0;
1547      while(lua_getstack(lua,level,&ar)) {
1548          lua_getinfo(lua,"Snl",&ar);
1549          if(strstr(ar.short_src,"user_script") != NULL) {
1550              ldbLog(sdscatprintf(sdsempty(),"%s %s:",
1551                  (level == 0) ? "In" : "From",
1552                  ar.name ? ar.name : "top level"));
1553              ldbLogSourceLine(ar.currentline);
1554          }
1555          level++;
1556      }
1557      if (level == 0) {
1558          ldbLog(sdsnew("<error> Can't retrieve Lua stack."));
1559      }
1560  }
1561  void ldbMaxlen(sds *argv, int argc) {
1562      if (argc == 2) {
1563          int newval = atoi(argv[1]);
1564          ldb.maxlen_hint_sent = 1; &bsol;* User knows about this command. */
1565          if (newval != 0 && newval <= 60) newval = 60;
1566          ldb.maxlen = newval;
1567      }
1568      if (ldb.maxlen) {
1569          ldbLog(sdscatprintf(sdsempty(),"<value> replies are truncated at %d bytes.",(int)ldb.maxlen));
1570      } else {
1571          ldbLog(sdscatprintf(sdsempty(),"<value> replies are unlimited."));
1572      }
1573  }
1574  int ldbRepl(lua_State *lua) {
1575      sds *argv;
1576      int argc;
1577      while(1) {
1578          while((argv = ldbReplParseCommand(&argc)) == NULL) {
1579              char buf[1024];
1580              int nread = (int)read(ldb.fd,buf,sizeof(buf));                      WIN_PORT_FIX &bsol;* cast (int) */
1581              if (nread <= 0) {
1582                  ldb.step = 0;
1583                  ldb.bpcount = 0;
1584                  return C_ERR;
1585              }
1586              ldb.cbuf = sdscatlen(ldb.cbuf,buf,nread);
1587          }
1588          sdsfree(ldb.cbuf);
1589          ldb.cbuf = sdsempty();
1590          if (!strcasecmp(argv[0],"h") || !strcasecmp(argv[0],"help")) {
1591  ldbLog(sdsnew("Redis Lua debugger help:"));
1592  ldbLog(sdsnew("[h]elp               Show this help."));
1593  ldbLog(sdsnew("[s]tep               Run current line and stop again."));
1594  ldbLog(sdsnew("[n]ext               Alias for step."));
1595  ldbLog(sdsnew("[c]continue          Run till next breakpoint."));
1596  ldbLog(sdsnew("[l]list              List source code around current line."));
1597  ldbLog(sdsnew("[l]list [line]       List source code around [line]."));
1598  ldbLog(sdsnew("                     line = 0 means: current position."));
1599  ldbLog(sdsnew("[l]list [line] [ctx] In this form [ctx] specifies how many lines"));
1600  ldbLog(sdsnew("                     to show before/after [line]."));
1601  ldbLog(sdsnew("[w]hole              List all source code. Alias for 'list 1 1000000'."));
1602  ldbLog(sdsnew("[p]rint              Show all the local variables."));
1603  ldbLog(sdsnew("[p]rint <var>        Show the value of the specified variable."));
1604  ldbLog(sdsnew("                     Can also show global vars KEYS and ARGV."));
1605  ldbLog(sdsnew("[b]reak              Show all breakpoints."));
1606  ldbLog(sdsnew("[b]reak <line>       Add a breakpoint to the specified line."));
1607  ldbLog(sdsnew("[b]reak -<line>      Remove breakpoint from the specified line."));
1608  ldbLog(sdsnew("[b]reak 0            Remove all breakpoints."));
1609  ldbLog(sdsnew("[t]race              Show a backtrace."));
1610  ldbLog(sdsnew("[e]eval <code>       Execute some Lua code (in a different callframe)."));
1611  ldbLog(sdsnew("[r]edis <cmd>        Execute a Redis command."));
1612  ldbLog(sdsnew("[m]axlen [len]       Trim logged Redis replies and Lua var dumps to len."));
1613  ldbLog(sdsnew("                     Specifying zero as <len> means unlimited."));
1614  ldbLog(sdsnew("[a]bort              Stop the execution of the script. In sync"));
1615  ldbLog(sdsnew("                     mode dataset changes will be retained."));
1616  ldbLog(sdsnew(""));
1617  ldbLog(sdsnew("Debugger functions you can call from Lua scripts:"));
1618  ldbLog(sdsnew("redis.debug()        Produce logs in the debugger console."));
1619  ldbLog(sdsnew("redis.breakpoint()   Stop execution like if there was a breakpoing."));
1620  ldbLog(sdsnew("                     in the next line of code."));
1621              ldbSendLogs();
1622          } else if (!strcasecmp(argv[0],"s") || !strcasecmp(argv[0],"step") ||
1623                     !strcasecmp(argv[0],"n") || !strcasecmp(argv[0],"next")) {
1624              ldb.step = 1;
1625              break;
1626          } else if (!strcasecmp(argv[0],"c") || !strcasecmp(argv[0],"continue")){
1627              break;
1628          } else if (!strcasecmp(argv[0],"t") || !strcasecmp(argv[0],"trace")) {
1629              ldbTrace(lua);
1630              ldbSendLogs();
1631          } else if (!strcasecmp(argv[0],"m") || !strcasecmp(argv[0],"maxlen")) {
1632              ldbMaxlen(argv,argc);
1633              ldbSendLogs();
1634          } else if (!strcasecmp(argv[0],"b") || !strcasecmp(argv[0],"break")) {
1635              ldbBreak(argv,argc);
1636              ldbSendLogs();
1637          } else if (!strcasecmp(argv[0],"e") || !strcasecmp(argv[0],"eval")) {
1638              ldbEval(lua,argv,argc);
1639              ldbSendLogs();
1640          } else if (!strcasecmp(argv[0],"a") || !strcasecmp(argv[0],"abort")) {
1641              lua_pushstring(lua, "script aborted for user request");
1642              lua_error(lua);
1643          } else if (argc > 1 &&
1644                     (!strcasecmp(argv[0],"r") || !strcasecmp(argv[0],"redis"))) {
1645              ldbRedis(lua,argv,argc);
1646              ldbSendLogs();
1647          } else if ((!strcasecmp(argv[0],"p") || !strcasecmp(argv[0],"print"))) {
1648              if (argc == 2)
1649                  ldbPrint(lua,argv[1]);
1650              else
1651                  ldbPrintAll(lua);
1652              ldbSendLogs();
1653          } else if (!strcasecmp(argv[0],"l") || !strcasecmp(argv[0],"list")){
1654              int around = ldb.currentline, ctx = 5;
1655              if (argc > 1) {
1656                  int num = atoi(argv[1]);
1657                  if (num > 0) around = num;
1658              }
1659              if (argc > 2) ctx = atoi(argv[2]);
1660              ldbList(around,ctx);
1661              ldbSendLogs();
1662          } else if (!strcasecmp(argv[0],"w") || !strcasecmp(argv[0],"whole")){
1663              ldbList(1,1000000);
1664              ldbSendLogs();
1665          } else {
1666              ldbLog(sdsnew("<error> Unknown Redis Lua debugger command or "
1667                            "wrong number of arguments."));
1668              ldbSendLogs();
1669          }
1670          sdsfreesplitres(argv,argc);
1671      }
1672      sdsfreesplitres(argv,argc);
1673      return C_OK;
1674  }
1675  void luaLdbLineHook(lua_State *lua, lua_Debug *ar) {
1676      lua_getstack(lua,0,ar);
1677      lua_getinfo(lua,"Sl",ar);
1678      ldb.currentline = ar->currentline;
1679      int bp = ldbIsBreakpoint(ldb.currentline) || ldb.luabp;
1680      int timeout = 0;
1681      if(strstr(ar->short_src,"user_script") == NULL) return;
1682      if (ar->event == LUA_HOOKCOUNT && ldb.step == 0 && bp == 0) {
1683          mstime_t elapsed = mstime() - server.lua_time_start;
1684          mstime_t timelimit = server.lua_time_limit ?
1685                               server.lua_time_limit : 5000;
1686          if (elapsed >= timelimit) {
1687              timeout = 1;
1688              ldb.step = 1;
1689          } else {
1690              return; &bsol;* No timeout, ignore the COUNT event. */
1691          }
1692      }
1693      if (ldb.step || bp) {
1694          char *reason = "step over";
1695          if (bp) reason = ldb.luabp ? "redis.breakpoint() called" :
1696                                       "break point";
1697          else if (timeout) reason = "timeout reached, infinite loop?";
1698          ldb.step = 0;
1699          ldb.luabp = 0;
1700          ldbLog(sdscatprintf(sdsempty(),
1701              "* Stopped at %d, stop reason = %s",
1702              ldb.currentline, reason));
1703          ldbLogSourceLine(ldb.currentline);
1704          ldbSendLogs();
1705          if (ldbRepl(lua) == C_ERR && timeout) {
1706              lua_pushstring(lua, "timeout during Lua debugging with client closing connection");
1707              lua_error(lua);
1708          }
1709          server.lua_time_start = mstime();
1710      }
1711  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from redis-MDEwOlJlcG9zaXRvcnkxMDgxMTA3MDY=-flat-scripting.c</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from redis-MDEwOlJlcG9zaXRvcnkxMDgxMTA3MDY=-flat-scripting.c</div>
                </div>
                <div class="column column_space"><pre><code>703                                  "  if b == false then b = '' end\n"
704                                  "  return a<b\n"
705                                  "end\n";
706          luaL_loadbuffer(lua,compare_func,strlen(compare_func),"@cmp_func_def");
707          lua_pcall(lua,0,0,0);
708      }
709      {
</pre></code></div>
                <div class="column column_space"><pre><code>719                                  "    return err\n"
720                                  "  end\n"
721                                  "end\n";
722          luaL_loadbuffer(lua,errh_func,strlen(errh_func),"@err_handler_def");
723          lua_pcall(lua,0,0,0);
724      }
725      if (server.lua_client == NULL) {
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    