
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 20, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>redis-MDEwOlJlcG9zaXRvcnkxMDgxMTA3MDY=-flat-networking.c</h3>
            <pre><code>1  #ifdef _WIN32
2  #include "Win32_Interop/Win32_Portability.h"
3  #include "Win32_Interop/Win32_Error.h"
4  #endif
5  #include "server.h"
6  #include "atomicvar.h"
7  #ifdef _WIN32
8  #include "Win32_Interop/Win32_QFork.h"
9  #else
10  #include <sys/uio.h>
11  #endif
12  #include <math.h>
13  #include <ctype.h>
14  WIN32_ONLY(extern int WSIOCP_QueueAccept(int listenfd);)
15  WIN32_ONLY(extern int WSIOCP_CloseSocketStateRFD(int listenfd);)
16  static void setProtocolError(const char *errstr, client *c);
17  size_t sdsZmallocSize(sds s) {
18      void *sh = sdsAllocPtr(s);
19      return zmalloc_size(sh);
20  }
21  size_t getStringObjectSdsUsedMemory(robj *o) {
22      serverAssertWithInfo(NULL,o,o->type == OBJ_STRING);
23      switch(o->encoding) {
24      case OBJ_ENCODING_RAW: return sdsZmallocSize(o->ptr);
25      case OBJ_ENCODING_EMBSTR: return zmalloc_size(o)-sizeof(robj);
26      default: return 0; &bsol;* Just integer encoding for now. */
27      }
28  }
29  void *dupClientReplyValue(void *o) {
30      clientReplyBlock *old = o;
31      clientReplyBlock *buf = zmalloc(sizeof(clientReplyBlock) + old->size);
32      memcpy(buf, o, sizeof(clientReplyBlock) + old->size);
33      return buf;
34  }
35  void freeClientReplyValue(void *o) {
36      zfree(o);
37  }
38  int listMatchObjects(void *a, void *b) {
39      return equalStringObjects(a,b);
40  }
41  void linkClient(client *c) {
42      listAddNodeTail(server.clients,c);
43      c->client_list_node = listLast(server.clients);
44      uint64_t id = htonu64(c->id);
45      raxInsert(server.clients_index,(unsigned char*)&id,sizeof(id),c,NULL);
46  }
47  client *createClient(int fd) {
48      client *c = zmalloc(sizeof(client));
49      if (fd != -1) {
50          anetNonBlock(NULL,fd);
51          anetEnableTcpNoDelay(NULL,fd);
52          if (server.tcpkeepalive)
53              anetKeepAlive(NULL,fd,server.tcpkeepalive);
54          if (aeCreateFileEvent(server.el,fd,AE_READABLE,
55              readQueryFromClient, c) == AE_ERR)
56          {
57              close(fd);
58              zfree(c);
59              return NULL;
60          }
61      }
62      selectDb(c,0);
63      uint64_t client_id;
64      atomicGetIncr(server.next_client_id,client_id,1);
65      c->id = client_id;
66      c->fd = fd;
67      c->name = NULL;
68      c->bufpos = 0;
69      c->qb_pos = 0;
70      c->querybuf = sdsempty();
71      c->pending_querybuf = sdsempty();
72      c->querybuf_peak = 0;
73      c->reqtype = 0;
74      c->argc = 0;
75      c->argv = NULL;
76      c->cmd = c->lastcmd = NULL;
77      c->multibulklen = 0;
78      c->bulklen = -1;
79      c->sentlen = 0;
80      c->flags = 0;
81      c->ctime = c->lastinteraction = server.unixtime;
82      c->authenticated = 0;
83      c->replstate = REPL_STATE_NONE;
84      c->repl_put_online_on_ack = 0;
85      c->reploff = 0;
86      c->read_reploff = 0;
87      c->repl_ack_off = 0;
88      c->repl_ack_time = 0;
89      c->slave_listening_port = 0;
90      c->slave_ip[0] = '\0';
91      c->slave_capa = SLAVE_CAPA_NONE;
<span onclick='openModal()' class='match'>92      c->reply = listCreate();
93      c->reply_bytes = 0;
94      c->obuf_soft_limit_reached_time = 0;
95      listSetFreeMethod(c->reply,freeClientReplyValue);
</span>96      listSetDupMethod(c->reply,dupClientReplyValue);
97      c->btype = BLOCKED_NONE;
98      c->bpop.timeout = 0;
99      c->bpop.keys = dictCreate(&objectKeyHeapPointerValueDictType,NULL);
100      c->bpop.target = NULL;
101      c->bpop.xread_group = NULL;
102      c->bpop.xread_consumer = NULL;
103      c->bpop.xread_group_noack = 0;
104      c->bpop.numreplicas = 0;
105      c->bpop.reploffset = 0;
106      c->woff = 0;
107      c->watched_keys = listCreate();
108      c->pubsub_channels = dictCreate(&objectKeyPointerValueDictType,NULL);
109      c->pubsub_patterns = listCreate();
110      c->peerid = NULL;
111      c->client_list_node = NULL;
112      listSetFreeMethod(c->pubsub_patterns,decrRefCountVoid);
113      listSetMatchMethod(c->pubsub_patterns,listMatchObjects);
114      if (fd != -1) linkClient(c);
115      initClientMultiState(c);
116      return c;
117  }
118  void clientInstallWriteHandler(client *c) {
119      if (!(c->flags & CLIENT_PENDING_WRITE) &&
120          (c->replstate == REPL_STATE_NONE ||
121           (c->replstate == SLAVE_STATE_ONLINE && !c->repl_put_online_on_ack)))
122      {
123          c->flags |= CLIENT_PENDING_WRITE;
124          listAddNodeHead(server.clients_pending_write,c);
125      }
126  }
127  int prepareClientToWrite(client *c) {
128      if (c->flags & (CLIENT_LUA|CLIENT_MODULE)) return C_OK;
129      if (c->flags & (CLIENT_REPLY_OFF|CLIENT_REPLY_SKIP)) return C_ERR;
130      if ((c->flags & CLIENT_MASTER) &&
131          !(c->flags & CLIENT_MASTER_FORCE_REPLY)) return C_ERR;
132      if (c->fd <= 0) return C_ERR; &bsol;* Fake client for AOF loading. */
133      if (!clientHasPendingReplies(c)) clientInstallWriteHandler(c);
134      return C_OK;
135  }
136  int _addReplyToBuffer(client *c, const char *s, size_t len) {
137      size_t available = sizeof(c->buf)-c->bufpos;
138      if (c->flags & CLIENT_CLOSE_AFTER_REPLY) return C_OK;
139      if (listLength(c->reply) > 0) return C_ERR;
140      if (len > available) return C_ERR;
141      memcpy(c->buf+c->bufpos,s,len);
142      c->bufpos+=(int)len;                                                        WIN_PORT_FIX &bsol;* cast (int) */
143      return C_OK;
144  }
145  void _addReplyStringToList(client *c, const char *s, size_t len) {
146      if (c->flags & CLIENT_CLOSE_AFTER_REPLY) return;
147      listNode *ln = listLast(c->reply);
148      clientReplyBlock *tail = ln? listNodeValue(ln): NULL;
149      if (tail) {
150          size_t avail = tail->size - tail->used;
151          size_t copy = avail >= len? len: avail;
152          memcpy(tail->buf + tail->used, s, copy);
153          tail->used += copy;
154          s += copy;
155          len -= copy;
156      }
157      if (len) {
158          size_t size = len < PROTO_REPLY_CHUNK_BYTES? PROTO_REPLY_CHUNK_BYTES: len;
159          tail = zmalloc(size + sizeof(clientReplyBlock));
160          tail->size = zmalloc_usable(tail) - sizeof(clientReplyBlock);
161          tail->used = len;
162          memcpy(tail->buf, s, len);
163          listAddNodeTail(c->reply, tail);
164          c->reply_bytes += tail->size;
165      }
166      asyncCloseClientOnOutputBufferLimitReached(c);
167  }
168  void addReply(client *c, robj *obj) {
169      if (prepareClientToWrite(c) != C_OK) return;
170      if (sdsEncodedObject(obj)) {
171          if (_addReplyToBuffer(c,obj->ptr,sdslen(obj->ptr)) != C_OK)
172              _addReplyStringToList(c,obj->ptr,sdslen(obj->ptr));
173      } else if (obj->encoding == OBJ_ENCODING_INT) {
174          char buf[32];
175          size_t len = ll2string(buf,sizeof(buf),(PORT_LONG)obj->ptr);
176          if (_addReplyToBuffer(c,buf,len) != C_OK)
177              _addReplyStringToList(c,buf,len);
178      } else {
179          serverPanic("Wrong obj->encoding in addReply()");
180      }
181  }
182  void addReplySds(client *c, sds s) {
183      if (prepareClientToWrite(c) != C_OK) {
184          sdsfree(s);
185          return;
186      }
187      if (_addReplyToBuffer(c,s,sdslen(s)) != C_OK)
188          _addReplyStringToList(c,s,sdslen(s));
189      sdsfree(s);
190  }
191  void addReplyString(client *c, const char *s, size_t len) {
192      if (prepareClientToWrite(c) != C_OK) return;
193      if (_addReplyToBuffer(c,s,len) != C_OK)
194          _addReplyStringToList(c,s,len);
195  }
196  void addReplyErrorLength(client *c, const char *s, size_t len) {
197      if (!len || s[0] != '-') addReplyString(c,"-ERR ",5);
198      addReplyString(c,s,len);
199      addReplyString(c,"\r\n",2);
200      if (c->flags & (CLIENT_MASTER|CLIENT_SLAVE) && !(c->flags & CLIENT_MONITOR)) {
201          char* to = c->flags & CLIENT_MASTER? "master": "replica";
202          char* from = c->flags & CLIENT_MASTER? "replica": "master";
203          char *cmdname = c->lastcmd ? c->lastcmd->name : "<unknown>";
204          serverLog(LL_WARNING,"== CRITICAL == This %s is sending an error "
205                               "to its %s: '%s' after processing the command "
206                               "'%s'", from, to, s, cmdname);
207      }
208  }
209  void addReplyError(client *c, const char *err) {
210      addReplyErrorLength(c,err,strlen(err));
211  }
212  void addReplyErrorFormat(client *c, const char *fmt, ...) {
213      size_t l, j;
214      va_list ap;
215      va_start(ap,fmt);
216      sds s = sdscatvprintf(sdsempty(),fmt,ap);
217      va_end(ap);
218      l = sdslen(s);
219      for (j = 0; j < l; j++) {
220          if (s[j] == '\r' || s[j] == '\n') s[j] = ' ';
221      }
222      addReplyErrorLength(c,s,sdslen(s));
223      sdsfree(s);
224  }
225  void addReplyStatusLength(client *c, const char *s, size_t len) {
226      addReplyString(c,"+",1);
227      addReplyString(c,s,len);
228      addReplyString(c,"\r\n",2);
229  }
230  void addReplyStatus(client *c, const char *status) {
231      addReplyStatusLength(c,status,strlen(status));
232  }
233  void addReplyStatusFormat(client *c, const char *fmt, ...) {
234      va_list ap;
235      va_start(ap,fmt);
236      sds s = sdscatvprintf(sdsempty(),fmt,ap);
237      va_end(ap);
238      addReplyStatusLength(c,s,sdslen(s));
239      sdsfree(s);
240  }
241  void *addDeferredMultiBulkLength(client *c) {
242      if (prepareClientToWrite(c) != C_OK) return NULL;
243      listAddNodeTail(c->reply,NULL); &bsol;* NULL is our placeholder. */
244      return listLast(c->reply);
245  }
246  void setDeferredMultiBulkLength(client *c, void *node, PORT_LONG length) {
247      listNode *ln = (listNode*)node;
248      clientReplyBlock *next;
249      char lenstr[128];
250      size_t lenstr_len = sprintf(lenstr, "*%ld\r\n", length);
251      if (node == NULL) return;
252      serverAssert(!listNodeValue(ln));
253      if (ln->next != NULL && (next = listNodeValue(ln->next)) &&
254          next->size - next->used >= lenstr_len &&
255          next->used < PROTO_REPLY_CHUNK_BYTES * 4) {
256          memmove(next->buf + lenstr_len, next->buf, next->used);
257          memcpy(next->buf, lenstr, lenstr_len);
258          next->used += lenstr_len;
259          listDelNode(c->reply,ln);
260      } else {
261          clientReplyBlock *buf = zmalloc(lenstr_len + sizeof(clientReplyBlock));
262          buf->size = zmalloc_usable(buf) - sizeof(clientReplyBlock);
263          buf->used = lenstr_len;
264          memcpy(buf->buf, lenstr, lenstr_len);
265          listNodeValue(ln) = buf;
266          c->reply_bytes += buf->size;
267      }
268      asyncCloseClientOnOutputBufferLimitReached(c);
269  }
270  void addReplyDouble(client *c, double d) {
271      char dbuf[128], sbuf[128];
272      int dlen, slen;
273      if (isinf(d)) {
274          addReplyBulkCString(c, d > 0 ? "inf" : "-inf");
275      } else {
276          dlen = snprintf(dbuf,sizeof(dbuf),"%.17g",d);
277          slen = snprintf(sbuf,sizeof(sbuf),"$%d\r\n%s\r\n",dlen,dbuf);
278          addReplyString(c,sbuf,slen);
279      }
280  }
281  void addReplyHumanLongDouble(client *c, PORT_LONGDOUBLE d) {
282      robj *o = createStringObjectFromLongDouble(d,1);
283      addReplyBulk(c,o);
284      decrRefCount(o);
285  }
286  void addReplyLongLongWithPrefix(client *c, PORT_LONGLONG ll, char prefix) {
287      char buf[128];
288      int len;
289      if (prefix == '*' && ll < OBJ_SHARED_BULKHDR_LEN && ll >= 0) {
290          addReply(c,shared.mbulkhdr[ll]);
291          return;
292      } else if (prefix == '$' && ll < OBJ_SHARED_BULKHDR_LEN && ll >= 0) {
293          addReply(c,shared.bulkhdr[ll]);
294          return;
295      }
296      buf[0] = prefix;
297      len = ll2string(buf+1,sizeof(buf)-1,ll);
298      buf[len+1] = '\r';
299      buf[len+2] = '\n';
300      addReplyString(c,buf,(size_t)len+3);  WIN_PORT_FIX &bsol;* cast (size_t) */
301  }
302  void addReplyLongLong(client *c, PORT_LONGLONG ll) {
303      if (ll == 0)
304          addReply(c,shared.czero);
305      else if (ll == 1)
306          addReply(c,shared.cone);
307      else
308          addReplyLongLongWithPrefix(c,ll,':');
309  }
310  void addReplyMultiBulkLen(client *c, PORT_LONG length) {
311      if (length < OBJ_SHARED_BULKHDR_LEN)
312          addReply(c,shared.mbulkhdr[length]);
313      else
314          addReplyLongLongWithPrefix(c,length,'*');
315  }
316  void addReplyBulkLen(client *c, robj *obj) {
317      size_t len;
318      if (sdsEncodedObject(obj)) {
319          len = sdslen(obj->ptr);
320      } else {
321          PORT_LONG n = (PORT_LONG)obj->ptr;
322          len = 1;
323          if (n < 0) {
324              len++;
325              n = -n;
326          }
327          while((n = n/10) != 0) {
328              len++;
329          }
330      }
331      if (len < OBJ_SHARED_BULKHDR_LEN)
332          addReply(c,shared.bulkhdr[len]);
333      else
334          addReplyLongLongWithPrefix(c,len,'$');
335  }
336  void addReplyBulk(client *c, robj *obj) {
337      addReplyBulkLen(c,obj);
338      addReply(c,obj);
339      addReply(c,shared.crlf);
340  }
341  void addReplyBulkCBuffer(client *c, const void *p, size_t len) {
342      addReplyLongLongWithPrefix(c,len,'$');
343      addReplyString(c,p,len);
344      addReply(c,shared.crlf);
345  }
346  void addReplyBulkSds(client *c, sds s)  {
347      addReplyLongLongWithPrefix(c,sdslen(s),'$');
348      addReplySds(c,s);
349      addReply(c,shared.crlf);
350  }
351  void addReplyBulkCString(client *c, const char *s) {
352      if (s == NULL) {
353          addReply(c,shared.nullbulk);
354      } else {
355          addReplyBulkCBuffer(c,s,strlen(s));
356      }
357  }
358  void addReplyBulkLongLong(client *c, PORT_LONGLONG ll) {
359      char buf[64];
360      int len;
361      len = ll2string(buf,64,ll);
362      addReplyBulkCBuffer(c,buf,len);
363  }
364  void addReplyHelp(client *c, const char **help) {
365      sds cmd = sdsnew((char*) c->argv[0]->ptr);
366      void *blenp = addDeferredMultiBulkLength(c);
367      int blen = 0;
368      sdstoupper(cmd);
369      addReplyStatusFormat(c,
370          "%s <subcommand> arg arg ... arg. Subcommands are:",cmd);
371      sdsfree(cmd);
372      while (help[blen]) addReplyStatus(c,help[blen++]);
373      blen++;  &bsol;* Account for the header line(s). */
374      setDeferredMultiBulkLength(c,blenp,blen);
375  }
376  void addReplySubcommandSyntaxError(client *c) {
377      sds cmd = sdsnew((char*) c->argv[0]->ptr);
378      sdstoupper(cmd);
379      addReplyErrorFormat(c,
380          "Unknown subcommand or wrong number of arguments for '%s'. Try %s HELP.",
381          (char*)c->argv[1]->ptr,cmd);
382      sdsfree(cmd);
383  }
384  void AddReplyFromClient(client *dst, client *src) {
385      if (prepareClientToWrite(dst) != C_OK)
386          return;
387      addReplyString(dst,src->buf, src->bufpos);
388      if (listLength(src->reply))
389          listJoin(dst->reply,src->reply);
390      dst->reply_bytes += src->reply_bytes;
391      src->reply_bytes = 0;
392      src->bufpos = 0;
393  }
394  void copyClientOutputBuffer(client *dst, client *src) {
395      listRelease(dst->reply);
396      dst->sentlen = 0;
397      dst->reply = listDup(src->reply);
398      memcpy(dst->buf,src->buf,src->bufpos);
399      dst->bufpos = src->bufpos;
400      dst->reply_bytes = src->reply_bytes;
401  }
402  int clientHasPendingReplies(client *c) {
403      return c->bufpos || listLength(c->reply);
404  }
405  #define MAX_ACCEPTS_PER_CALL 1000
406  static void acceptCommonHandler(int fd, int flags, char *ip) {
407      client *c;
408      if ((c = createClient(fd)) == NULL) {
409          serverLog(LL_WARNING,
410              "Error registering fd event for the new client: %s (fd=%d)",
411              IF_WIN32(wsa_strerror(errno), strerror(errno)),fd);
412          close(fd); &bsol;* May be already closed, just ignore errors */
413          return;
414      }
415      if (listLength(server.clients) > (PORT_ULONG) server.maxclients) {
416          char *err = "-ERR max number of clients reached\r\n";
417          if (write(c->fd,err,strlen(err)) == -1) {
418          }
419          server.stat_rejected_conn++;
420  #ifdef _WIN32
421          freeClientAsync(c);
422  #else
423          freeClient(c);
424  #endif
425          return;
426      }
427      if (server.protected_mode &&
428          server.bindaddr_count == 0 &&
429          server.requirepass == NULL &&
430          !(flags & CLIENT_UNIX_SOCKET) &&
431          ip != NULL)
432      {
433          if (strcmp(ip,"127.0.0.1") && strcmp(ip,"::1")) {
434              char *err =
435                  "-DENIED Redis is running in protected mode because protected "
436                  "mode is enabled, no bind address was specified, no "
437                  "authentication password is requested to clients. In this mode "
438                  "connections are only accepted from the loopback interface. "
439                  "If you want to connect from external computers to Redis you "
440                  "may adopt one of the following solutions: "
441                  "1) Just disable protected mode sending the command "
442                  "'CONFIG SET protected-mode no' from the loopback interface "
443                  "by connecting to Redis from the same host the server is "
444                  "running, however MAKE SURE Redis is not publicly accessible "
445                  "from internet if you do so. Use CONFIG REWRITE to make this "
446                  "change permanent. "
447                  "2) Alternatively you can just disable the protected mode by "
448                  "editing the Redis configuration file, and setting the protected "
449                  "mode option to 'no', and then restarting the server. "
450                  "3) If you started the server manually just for testing, restart "
451                  "it with the '--protected-mode no' option. "
452                  "4) Setup a bind address or an authentication password. "
453                  "NOTE: You only need to do one of the above things in order for "
454                  "the server to start accepting connections from the outside.\r\n";
455              if (write(c->fd,err,strlen(err)) == -1) {
456              }
457              server.stat_rejected_conn++;
458              freeClient(c);
459              return;
460          }
461      }
462      server.stat_numconnections++;
463      c->flags |= flags;
464  }
465  void acceptTcpHandler(aeEventLoop *el, int fd, void *privdata, int mask) {
466      int cport, cfd, max = MAX_ACCEPTS_PER_CALL;
467      char cip[NET_IP_STR_LEN];
468      UNUSED(el);
469      UNUSED(mask);
470      UNUSED(privdata);
471      while(max--) {
472          cfd = anetTcpAccept(server.neterr, fd, cip, sizeof(cip), &cport);
473          if (cfd == ANET_ERR) {
474              if (errno != EWOULDBLOCK) {
475                  serverLog(LL_WARNING,
476                      "Accepting client connection: %s", server.neterr);
477  #ifdef _WIN32
478                  if (WSIOCP_QueueAccept(fd) == -1) {
479                      serverLog(LL_WARNING,
480                          "acceptTcpHandler: failed to queue another accept.");
481                  }
482  #endif
483              }
484              return;
485          }
486          serverLog(LL_VERBOSE,"Accepted %s:%d", cip, cport);
487          acceptCommonHandler(cfd,0,cip);
488      }
489  }
490  void acceptUnixHandler(aeEventLoop *el, int fd, void *privdata, int mask) {
491      int cfd, max = MAX_ACCEPTS_PER_CALL;
492      UNUSED(el);
493      UNUSED(mask);
494      UNUSED(privdata);
495      while(max--) {
496          cfd = anetUnixAccept(server.neterr, fd);
497          if (cfd == ANET_ERR) {
498              if (errno != EWOULDBLOCK)
499                  serverLog(LL_WARNING,
500                      "Accepting client connection: %s", server.neterr);
501              return;
502          }
503          serverLog(LL_VERBOSE,"Accepted connection to %s", server.unixsocket);
504          acceptCommonHandler(cfd,CLIENT_UNIX_SOCKET,NULL);
505      }
506  }
507  static void freeClientArgv(client *c) {
508      int j;
509      for (j = 0; j < c->argc; j++)
510          decrRefCount(c->argv[j]);
511      c->argc = 0;
512      c->cmd = NULL;
513  }
514  void disconnectSlaves(void) {
515      while (listLength(server.slaves)) {
516          listNode *ln = listFirst(server.slaves);
517          freeClient((client*)ln->value);
518      }
519  }
520  void unlinkClient(client *c) {
521      listNode *ln;
522      if (server.current_client == c) server.current_client = NULL;
523      if (c->fd != -1) {
524          if (c->client_list_node) {
525              uint64_t id = htonu64(c->id);
526              raxRemove(server.clients_index,(unsigned char*)&id,sizeof(id),NULL);
527              listDelNode(server.clients,c->client_list_node);
528              c->client_list_node = NULL;
529          }
530          if ((c->flags & CLIENT_SLAVE) &&
531              (c->replstate == SLAVE_STATE_WAIT_BGSAVE_END)) {
532  #ifdef _WIN32
533  			WSIOCP_CloseSocketStateRFD(c->fd); 
534  #else
535  			shutdown(c->fd, SHUT_RDWR);
536  #endif
537          }
538          aeDeleteFileEvent(server.el,c->fd,AE_READABLE);
539          aeDeleteFileEvent(server.el,c->fd,AE_WRITABLE);
540          close(c->fd);
541          c->fd = -1;
542      }
543      if (c->flags & CLIENT_PENDING_WRITE) {
544          ln = listSearchKey(server.clients_pending_write,c);
545          serverAssert(ln != NULL);
546          listDelNode(server.clients_pending_write,ln);
547          c->flags &= ~CLIENT_PENDING_WRITE;
548      }
549      if (c->flags & CLIENT_UNBLOCKED) {
550          ln = listSearchKey(server.unblocked_clients,c);
551          serverAssert(ln != NULL);
552          listDelNode(server.unblocked_clients,ln);
553          c->flags &= ~CLIENT_UNBLOCKED;
554      }
555  }
556  void freeClient(client *c) {
557      listNode *ln;
558      if (c->flags & CLIENT_PROTECTED) {
559          freeClientAsync(c);
560          return;
561      }
562      if (server.master && c->flags & CLIENT_MASTER) {
563          serverLog(LL_WARNING,"Connection with master lost.");
564          if (!(c->flags & (CLIENT_CLOSE_AFTER_REPLY|
565                            CLIENT_CLOSE_ASAP|
566                            CLIENT_BLOCKED)))
567          {
568              replicationCacheMaster(c);
569              return;
570          }
571      }
572      if ((c->flags & CLIENT_SLAVE) && !(c->flags & CLIENT_MONITOR)) {
573          serverLog(LL_WARNING,"Connection with replica %s lost.",
574              replicationGetSlaveName(c));
575      }
576      sdsfree(c->querybuf);
577      sdsfree(c->pending_querybuf);
578      c->querybuf = NULL;
579      if (c->flags & CLIENT_BLOCKED) unblockClient(c);
580      dictRelease(c->bpop.keys);
581      unwatchAllKeys(c);
582      listRelease(c->watched_keys);
583      pubsubUnsubscribeAllChannels(c,0);
584      pubsubUnsubscribeAllPatterns(c,0);
585      dictRelease(c->pubsub_channels);
586      listRelease(c->pubsub_patterns);
587      listRelease(c->reply);
588      freeClientArgv(c);
589      unlinkClient(c);
590      if (c->flags & CLIENT_SLAVE) {
591          if (c->replstate == SLAVE_STATE_SEND_BULK) {
592  #ifdef _WIN32
593              if (c->repldbfd != -1) {
594                  DeleteFileA(c->replFileCopy);
595                  memset(c->replFileCopy, 0, MAX_PATH);
596              }
597  #endif
598              if (c->repldbfd != -1) close(c->repldbfd);
599              if (c->replpreamble) sdsfree(c->replpreamble);
600          }
601          list *l = (c->flags & CLIENT_MONITOR) ? server.monitors : server.slaves;
602          ln = listSearchKey(l,c);
603          serverAssert(ln != NULL);
604          listDelNode(l,ln);
605          if (getClientType(c) == CLIENT_TYPE_SLAVE && listLength(server.slaves) == 0)
606              server.repl_no_slaves_since = server.unixtime;
607          refreshGoodSlavesCount();
608      }
609      if (c->flags & CLIENT_MASTER) replicationHandleMasterDisconnection();
610      if (c->flags & CLIENT_CLOSE_ASAP) {
611          ln = listSearchKey(server.clients_to_close,c);
612          serverAssert(ln != NULL);
613          listDelNode(server.clients_to_close,ln);
614      }
615      if (c->name) decrRefCount(c->name);
616      zfree(c->argv);
617      freeClientMultiState(c);
618      sdsfree(c->peerid);
619      zfree(c);
620  }
621  void freeClientAsync(client *c) {
622      if (c->flags & CLIENT_CLOSE_ASAP || c->flags & CLIENT_LUA) return;
623      c->flags |= CLIENT_CLOSE_ASAP;
624      listAddNodeTail(server.clients_to_close,c);
625  }
626  void freeClientsInAsyncFreeQueue(void) {
627      while (listLength(server.clients_to_close)) {
628          listNode *ln = listFirst(server.clients_to_close);
629          client *c = listNodeValue(ln);
630          c->flags &= ~CLIENT_CLOSE_ASAP;
631          freeClient(c);
632          listDelNode(server.clients_to_close,ln);
633      }
634  }
635  client *lookupClientByID(uint64_t id) {
636      id = htonu64(id);
637      client *c = raxFind(server.clients_index,(unsigned char*)&id,sizeof(id));
638      return (c == raxNotFound) ? NULL : c;
639  }
640  int writeToClient(int fd, client *c, int handler_installed) {
641      ssize_t nwritten = 0, totwritten = 0;
642      size_t objlen;
643      clientReplyBlock *o;
644      while(clientHasPendingReplies(c)) {
645          if (c->bufpos > 0) {
646  #ifdef _WIN32
647              nwritten = c->bufpos - c->sentlen;
648              int result = WSIOCP_SocketSend(fd, c->buf + c->sentlen, nwritten,
649                  server.el, c, c->buf, NULL);
650              if (result == SOCKET_ERROR && errno != WSA_IO_PENDING) {
651                  nwritten = -1;
652                  if (errno == WSAEWOULDBLOCK) {
653                      serverLog(LL_DEBUG, "writeToClient: will try again (EAGAIN) due to WSAEWOULDBLOCK");
654                      errno = EAGAIN;
655                  }
656                  break;
657              }
658  #else
659              nwritten = write(fd,c->buf+c->sentlen,c->bufpos-c->sentlen);
660              if (nwritten <= 0) break;
661  #endif
662              c->sentlen += nwritten;
663              totwritten += nwritten;
664              if ((int)c->sentlen == c->bufpos) {
665                  c->bufpos = 0;
666                  c->sentlen = 0;
667              }
668          } else {
669              o = listNodeValue(listFirst(c->reply));
670              objlen = o->used;
671              if (objlen == 0) {
672                  c->reply_bytes -= o->size;
673                  listDelNode(c->reply,listFirst(c->reply));
674                  continue;
675              }
676  #ifdef _WIN32
677  			nwritten = objlen - c->sentlen;
678              int result = WSIOCP_SocketSend(fd, o->buf+c->sentlen, nwritten,
679                  server.el, c, o->buf, NULL);
680              if (result == SOCKET_ERROR && errno != WSA_IO_PENDING) {
681                  nwritten = -1;
682                  if (errno == WSAEWOULDBLOCK) {
683                      serverLog(LL_DEBUG, "writeToClient: will try again (EAGAIN) due to WSAEWOULDBLOCK");
684                      errno = EAGAIN;
685                  }
686                  break;
687              }
688  			if (nwritten <= 0) break;
689              c->sentlen += nwritten;
690              totwritten += nwritten;
691  #else
692              nwritten = write(fd, o->buf + c->sentlen, objlen - c->sentlen);
693              if (nwritten <= 0) break;
694              c->sentlen += nwritten;
695              totwritten += nwritten;
696  #endif
697              if (c->sentlen == objlen) {
698                  c->reply_bytes -= (PORT_ULONG)o->size;
699                  listDelNode(c->reply,listFirst(c->reply));
700                  c->sentlen = 0;
701                  if (listLength(c->reply) == 0)
702                      serverAssert(c->reply_bytes == 0);
703              }
704          }
705          if (totwritten > NET_MAX_WRITES_PER_EVENT &&
706              (server.maxmemory == 0 ||
707               zmalloc_used_memory() < server.maxmemory) &&
708              !(c->flags & CLIENT_SLAVE)) break;
709      }
710      server.stat_net_output_bytes += totwritten;
711      if (nwritten == -1) {
712          if (errno == EAGAIN) {
713              nwritten = 0;
714          } else {
715              serverLog(LL_VERBOSE,
716                  "Error writing to client: %s", IF_WIN32(wsa_strerror,strerror)(errno));
717              freeClient(c);
718              return C_ERR;
719          }
720      }
721      if (totwritten > 0) {
722          if (!(c->flags & CLIENT_MASTER)) c->lastinteraction = server.unixtime;
723      }
724      if (!clientHasPendingReplies(c)) {
725          c->sentlen = 0;
726          if (handler_installed) aeDeleteFileEvent(server.el,c->fd,AE_WRITABLE);
727          if (c->flags & CLIENT_CLOSE_AFTER_REPLY) {
728  #ifdef _WIN32
729              freeClientAsync(c);
730  #else
731              freeClient(c);
732  #endif
733              return C_ERR;
734          }
735      }
736  #if _WIN32
737      else if (handler_installed) {
738          if (aeCreateFileEvent(server.el, c->fd, AE_WRITABLE,
739              sendReplyToClient, c) == AE_ERR)
740          {
741              serverLog(LL_WARNING, "writeToClient: aeCreateFileEvent failed");
742              freeClientAsync(c);
743              return C_ERR;
744          }
745          else {
746              serverLog(LL_DEBUG, "writeToClient: re-scheduling sendReplyToClient() for pending client replies");
747          }
748      }
749  #endif
750      return C_OK;
751  }
752  void sendReplyToClient(aeEventLoop *el, int fd, void *privdata, int mask) {
753      UNUSED(el);
754      UNUSED(mask);
755      writeToClient(fd,privdata,1);
756  }
757  int handleClientsWithPendingWrites(void) {
758      listIter li;
759      listNode *ln;
760      int processed = listLength(server.clients_pending_write);
761      listRewind(server.clients_pending_write,&li);
762      while((ln = listNext(&li))) {
763          client *c = listNodeValue(ln);
764          c->flags &= ~CLIENT_PENDING_WRITE;
765          listDelNode(server.clients_pending_write,ln);
766          if (c->flags & CLIENT_PROTECTED) continue;
767          if (writeToClient(c->fd,c,0) == C_ERR) continue;
768          if (clientHasPendingReplies(c)) {
769              int ae_flags = AE_WRITABLE;
770              if (server.aof_state == AOF_ON &&
771                  server.aof_fsync == AOF_FSYNC_ALWAYS)
772              {
773                  ae_flags |= AE_BARRIER;
774              }
775              if (aeCreateFileEvent(server.el, c->fd, ae_flags,
776                  sendReplyToClient, c) == AE_ERR)
777              {
778                      freeClientAsync(c);
779              }
780          }
781      }
782      return processed;
783  }
784  void resetClient(client *c) {
785      redisCommandProc *prevcmd = c->cmd ? c->cmd->proc : NULL;
786      freeClientArgv(c);
787      c->reqtype = 0;
788      c->multibulklen = 0;
789      c->bulklen = -1;
790      if (!(c->flags & CLIENT_MULTI) && prevcmd != askingCommand)
791          c->flags &= ~CLIENT_ASKING;
792      c->flags &= ~CLIENT_REPLY_SKIP;
793      if (c->flags & CLIENT_REPLY_SKIP_NEXT) {
794          c->flags |= CLIENT_REPLY_SKIP;
795          c->flags &= ~CLIENT_REPLY_SKIP_NEXT;
796      }
797  }
798  void protectClient(client *c) {
799      c->flags |= CLIENT_PROTECTED;
800      aeDeleteFileEvent(server.el,c->fd,AE_READABLE);
801      aeDeleteFileEvent(server.el,c->fd,AE_WRITABLE);
802  }
803  void unprotectClient(client *c) {
804      if (c->flags & CLIENT_PROTECTED) {
805          c->flags &= ~CLIENT_PROTECTED;
806          aeCreateFileEvent(server.el,c->fd,AE_READABLE,readQueryFromClient,c);
807          if (clientHasPendingReplies(c)) clientInstallWriteHandler(c);
808      }
809  }
810  int processInlineBuffer(client *c) {
811      char *newline;
812      int argc, j, linefeed_chars = 1;
813      sds *argv, aux;
814      size_t querylen;
815      newline = strchr(c->querybuf+c->qb_pos,'\n');
816      if (newline == NULL) {
817          if (sdslen(c->querybuf)-c->qb_pos > PROTO_INLINE_MAX_SIZE) {
818              addReplyError(c,"Protocol error: too big inline request");
819              setProtocolError("too big inline request",c);
820          }
821          return C_ERR;
822      }
823      if (newline && newline != c->querybuf+c->qb_pos && *(newline-1) == '\r')
824          newline--, linefeed_chars++;
825      querylen = newline-(c->querybuf+c->qb_pos);
826      aux = sdsnewlen(c->querybuf+c->qb_pos,querylen);
827      argv = sdssplitargs(aux,&argc);
828      sdsfree(aux);
829      if (argv == NULL) {
830          addReplyError(c,"Protocol error: unbalanced quotes in request");
831          setProtocolError("unbalanced quotes in inline request",c);
832          return C_ERR;
833      }
834      if (querylen == 0 && getClientType(c) == CLIENT_TYPE_SLAVE)
835          c->repl_ack_time = server.unixtime;
836      c->qb_pos += querylen+linefeed_chars;
837      if (argc) {
838          if (c->argv) zfree(c->argv);
839          c->argv = zmalloc(sizeof(robj*)*argc);
840      }
841      for (c->argc = 0, j = 0; j < argc; j++) {
842          c->argv[c->argc] = createObject(OBJ_STRING,argv[j]);
843          c->argc++;
844      }
845      zfree(argv);
846      return C_OK;
847  }
848  #define PROTO_DUMP_LEN 128
849  static void setProtocolError(const char *errstr, client *c) {
850      if (server.verbosity <= LL_VERBOSE) {
851          sds client = catClientInfoString(sdsempty(),c);
852          char buf[256];
853          if (sdslen(c->querybuf)-c->qb_pos < PROTO_DUMP_LEN) {
854              snprintf(buf,sizeof(buf),"Query buffer during protocol error: '%s'", c->querybuf+c->qb_pos);
855          } else {
856              snprintf(buf,sizeof(buf),"Query buffer during protocol error: '%.*s' (... more %Iu bytes ...) '%.*s'", PROTO_DUMP_LEN/2, c->querybuf+c->qb_pos, sdslen(c->querybuf)-c->qb_pos-PROTO_DUMP_LEN, PROTO_DUMP_LEN/2, c->querybuf+sdslen(c->querybuf)-PROTO_DUMP_LEN/2); WIN_PORT_FIX &bsol;* %zu -> %Iu */
857          }
858          char *p = buf;
859          while (*p != '\0') {
860              if (!isprint(*p)) *p = '.';
861              p++;
862          }
863          serverLog(LL_VERBOSE,
864              "Protocol error (%s) from client: %s. %s", errstr, client, buf);
865          sdsfree(client);
866      }
867      c->flags |= CLIENT_CLOSE_AFTER_REPLY;
868  }
869  int processMultibulkBuffer(client *c) {
870      char *newline = NULL;
871      int ok;
872      PORT_LONGLONG ll;
873      if (c->multibulklen == 0) {
874          serverAssertWithInfo(c,NULL,c->argc == 0);
875          newline = strchr(c->querybuf+c->qb_pos,'\r');
876          if (newline == NULL) {
877              if (sdslen(c->querybuf)-c->qb_pos > PROTO_INLINE_MAX_SIZE) {
878                  addReplyError(c,"Protocol error: too big mbulk count string");
879                  setProtocolError("too big mbulk count string",c);
880              }
881              return C_ERR;
882          }
883          if (newline-(c->querybuf+c->qb_pos) > (ssize_t)(sdslen(c->querybuf)-c->qb_pos-2))
884              return C_ERR;
885          serverAssertWithInfo(c,NULL,c->querybuf[c->qb_pos] == '*');
886          ok = string2ll(c->querybuf+1+c->qb_pos,newline-(c->querybuf+1+c->qb_pos),&ll);
887          if (!ok || ll > 1024*1024) {
888              addReplyError(c,"Protocol error: invalid multibulk length");
889              setProtocolError("invalid mbulk count",c);
890              return C_ERR;
891          }
892          c->qb_pos = (newline-c->querybuf)+2;
893          if (ll <= 0) return C_OK;
894          c->multibulklen = (int)ll;
895          if (c->argv) zfree(c->argv);
896          c->argv = zmalloc(sizeof(robj*)*c->multibulklen);
897      }
898      serverAssertWithInfo(c,NULL,c->multibulklen > 0);
899      while(c->multibulklen) {
900          if (c->bulklen == -1) {
901              newline = strchr(c->querybuf+c->qb_pos,'\r');
902              if (newline == NULL) {
903                  if (sdslen(c->querybuf)-c->qb_pos > PROTO_INLINE_MAX_SIZE) {
904                      addReplyError(c,
905                          "Protocol error: too big bulk count string");
906                      setProtocolError("too big bulk count string",c);
907                      return C_ERR;
908                  }
909                  break;
910              }
911              if (newline-(c->querybuf+c->qb_pos) > (ssize_t)(sdslen(c->querybuf)-c->qb_pos-2))
912                  break;
913              if (c->querybuf[c->qb_pos] != '$') {
914                  addReplyErrorFormat(c,
915                      "Protocol error: expected '$', got '%c'",
916                      c->querybuf[c->qb_pos]);
917                  setProtocolError("expected $ but got something else",c);
918                  return C_ERR;
919              }
920              ok = string2ll(c->querybuf+c->qb_pos+1,newline-(c->querybuf+c->qb_pos+1),&ll);
921              if (!ok || ll < 0 || ll > server.proto_max_bulk_len) {
922                  addReplyError(c,"Protocol error: invalid bulk length");
923                  setProtocolError("invalid bulk length",c);
924                  return C_ERR;
925              }
926              c->qb_pos = newline-c->querybuf+2;
927              if (ll >= PROTO_MBULK_BIG_ARG) {
928                  if (sdslen(c->querybuf)-c->qb_pos <= (size_t)ll+2) {
929                      sdsrange(c->querybuf,c->qb_pos,-1);
930                      c->qb_pos = 0;
931                      c->querybuf = sdsMakeRoomFor(c->querybuf,ll+2);
932                  }
933              }
934              c->bulklen = (PORT_LONG)ll;                                        WIN_PORT_FIX &bsol;* cast (PORT_LONG) */
935          }
936          if (sdslen(c->querybuf)-c->qb_pos < (size_t)(c->bulklen+2)) {
937              break;
938          } else {
939              if (c->qb_pos == 0 &&
940                  c->bulklen >= PROTO_MBULK_BIG_ARG &&
941                  sdslen(c->querybuf) == (size_t)(c->bulklen+2))
942              {
943                  c->argv[c->argc++] = createObject(OBJ_STRING,c->querybuf);
944                  sdsIncrLen(c->querybuf,-2); &bsol;* remove CRLF */
945                  c->querybuf = sdsnewlen(SDS_NOINIT,c->bulklen+2);
946                  sdsclear(c->querybuf);
947              } else {
948                  c->argv[c->argc++] =
949                      createStringObject(c->querybuf+c->qb_pos,c->bulklen);
950                  c->qb_pos += c->bulklen+2;
951              }
952              c->bulklen = -1;
953              c->multibulklen--;
954          }
955      }
956      if (c->multibulklen == 0) return C_OK;
957      return C_ERR;
958  }
959  void processInputBuffer(client *c) {
960      server.current_client = c;
961      while(c->qb_pos < sdslen(c->querybuf)) {
962          if (!(c->flags & CLIENT_SLAVE) && clientsArePaused()) break;
963          if (c->flags & CLIENT_BLOCKED) break;
964          if (server.lua_timedout && c->flags & CLIENT_MASTER) break;
965          if (c->flags & (CLIENT_CLOSE_AFTER_REPLY|CLIENT_CLOSE_ASAP)) break;
966          if (!c->reqtype) {
967              if (c->querybuf[c->qb_pos] == '*') {
968                  c->reqtype = PROTO_REQ_MULTIBULK;
969              } else {
970                  c->reqtype = PROTO_REQ_INLINE;
971              }
972          }
973          if (c->reqtype == PROTO_REQ_INLINE) {
974              if (processInlineBuffer(c) != C_OK) break;
975          } else if (c->reqtype == PROTO_REQ_MULTIBULK) {
976              if (processMultibulkBuffer(c) != C_OK) break;
977          } else {
978              serverPanic("Unknown request type");
979          }
980          if (c->argc == 0) {
981              resetClient(c);
982          } else {
983              if (processCommand(c) == C_OK) {
984                  if (c->flags & CLIENT_MASTER && !(c->flags & CLIENT_MULTI)) {
985                      c->reploff = c->read_reploff - sdslen(c->querybuf) + c->qb_pos;
986                  }
987                  if (!(c->flags & CLIENT_BLOCKED) || c->btype != BLOCKED_MODULE)
988                      resetClient(c);
989              }
990              if (server.current_client == NULL) break;
991          }
992      }
993      if (server.current_client != NULL && c->qb_pos) {
994          sdsrange(c->querybuf,c->qb_pos,-1);
995          c->qb_pos = 0;
996      }
997      server.current_client = NULL;
998  }
999  void processInputBufferAndReplicate(client *c) {
1000      if (!(c->flags & CLIENT_MASTER)) {
1001          processInputBuffer(c);
1002      } else {
1003          size_t prev_offset = c->reploff;
1004          processInputBuffer(c);
1005          size_t applied = c->reploff - prev_offset;
1006          if (applied) {
1007              replicationFeedSlavesFromMasterStream(server.slaves,
1008                      c->pending_querybuf, applied);
1009              sdsrange(c->pending_querybuf,applied,-1);
1010          }
1011      }
1012  }
1013  void readQueryFromClient(aeEventLoop *el, int fd, void *privdata, int mask) {
1014      client *c = (client*) privdata;
1015      int nread, readlen;
1016      size_t qblen;
1017      UNUSED(el);
1018      UNUSED(mask);
1019      readlen = PROTO_IOBUF_LEN;
1020      if (c->reqtype == PROTO_REQ_MULTIBULK && c->multibulklen && c->bulklen != -1
1021          && c->bulklen >= PROTO_MBULK_BIG_ARG)
1022      {
1023          ssize_t remaining = (size_t)(c->bulklen+2)-sdslen(c->querybuf);
1024          if (remaining > 0 && remaining < readlen) readlen = remaining;
1025      }
1026      qblen = sdslen(c->querybuf);
1027      if (c->querybuf_peak < qblen) c->querybuf_peak = qblen;
1028      c->querybuf = sdsMakeRoomFor(c->querybuf, readlen);
1029      nread = (int)read(fd, c->querybuf+qblen, readlen);                          WIN_PORT_FIX &bsol;* cast (int) */
1030      if (nread == -1) {
1031          if (errno == EAGAIN) {
1032              return;
1033          } else {
1034              serverLog(LL_VERBOSE, "Reading from client: %s", IF_WIN32(wsa_strerror(errno), strerror(errno)));
1035              freeClient(c);
1036              return;
1037          }
1038      } else if (nread == 0) {
1039          serverLog(LL_VERBOSE, "Client closed connection");
1040          freeClient(c);
1041          return;
1042      } else if (c->flags & CLIENT_MASTER) {
1043          c->pending_querybuf = sdscatlen(c->pending_querybuf,
1044                                          c->querybuf+qblen,nread);
1045      }
1046      WIN32_ONLY(WSIOCP_QueueNextRead(fd);)
1047      sdsIncrLen(c->querybuf,nread);
1048      c->lastinteraction = server.unixtime;
1049      if (c->flags & CLIENT_MASTER) c->read_reploff += nread;
1050      server.stat_net_input_bytes += nread;
1051      if (sdslen(c->querybuf) > server.client_max_querybuf_len) {
1052          sds ci = catClientInfoString(sdsempty(),c), bytes = sdsempty();
1053          bytes = sdscatrepr(bytes,c->querybuf,64);
1054          serverLog(LL_WARNING,"Closing client that reached max query buffer length: %s (qbuf initial bytes: %s)", ci, bytes);
1055          sdsfree(ci);
1056          sdsfree(bytes);
1057          freeClient(c);
1058          return;
1059      }
1060      processInputBufferAndReplicate(c);
1061  }
1062  void getClientsMaxBuffers(PORT_ULONG *longest_output_list,
1063                            PORT_ULONG *biggest_input_buffer) {
1064      client *c;
1065      listNode *ln;
1066      listIter li;
1067      PORT_ULONG lol = 0, bib = 0;
1068      listRewind(server.clients,&li);
1069      while ((ln = listNext(&li)) != NULL) {
1070          c = listNodeValue(ln);
1071          if (listLength(c->reply) > lol) lol = listLength(c->reply);
1072          if (sdslen(c->querybuf) > bib) bib = (PORT_ULONG)sdslen(c->querybuf);   WIN_PORT_FIX &bsol;* cast (PORT_ULONG) */
1073      }
1074      *longest_output_list = lol;
1075      *biggest_input_buffer = bib;
1076  }
1077  void genClientPeerId(client *client, char *peerid,
1078                              size_t peerid_len) {
1079      if (client->flags & CLIENT_UNIX_SOCKET) {
1080          snprintf(peerid,peerid_len,"%s:0",server.unixsocket);
1081      } else {
1082          anetFormatPeer(client->fd,peerid,peerid_len);
1083      }
1084  }
1085  char *getClientPeerId(client *c) {
1086      char peerid[NET_PEER_ID_LEN];
1087      if (c->peerid == NULL) {
1088          genClientPeerId(c,peerid,sizeof(peerid));
1089          c->peerid = sdsnew(peerid);
1090      }
1091      return c->peerid;
1092  }
1093  sds catClientInfoString(sds s, client *client) {
1094      char flags[16], events[3], *p;
1095      int emask;
1096      p = flags;
1097      if (client->flags & CLIENT_SLAVE) {
1098          if (client->flags & CLIENT_MONITOR)
1099              *p++ = 'O';
1100          else
1101              *p++ = 'S';
1102      }
1103      if (client->flags & CLIENT_MASTER) *p++ = 'M';
1104      if (client->flags & CLIENT_PUBSUB) *p++ = 'P';
1105      if (client->flags & CLIENT_MULTI) *p++ = 'x';
1106      if (client->flags & CLIENT_BLOCKED) *p++ = 'b';
1107      if (client->flags & CLIENT_DIRTY_CAS) *p++ = 'd';
1108      if (client->flags & CLIENT_CLOSE_AFTER_REPLY) *p++ = 'c';
1109      if (client->flags & CLIENT_UNBLOCKED) *p++ = 'u';
1110      if (client->flags & CLIENT_CLOSE_ASAP) *p++ = 'A';
1111      if (client->flags & CLIENT_UNIX_SOCKET) *p++ = 'U';
1112      if (client->flags & CLIENT_READONLY) *p++ = 'r';
1113      if (p == flags) *p++ = 'N';
1114      *p++ = '\0';
1115      emask = client->fd == -1 ? 0 : aeGetFileEvents(server.el,client->fd);
1116      p = events;
1117      if (emask & AE_READABLE) *p++ = 'r';
1118      if (emask & AE_WRITABLE) *p++ = 'w';
1119      *p = '\0';
1120      return sdscatfmt(s,
1121          "id=%U addr=%s fd=%i name=%s age=%I idle=%I flags=%s db=%i sub=%i psub=%i multi=%i qbuf=%U qbuf-free=%U obl=%U oll=%U omem=%U events=%s cmd=%s",
1122          (PORT_ULONGLONG) client->id,
1123          getClientPeerId(client),
1124          client->fd,
1125          client->name ? (char*)client->name->ptr : "",
1126          (PORT_LONGLONG)(server.unixtime - client->ctime),
1127          (PORT_LONGLONG)(server.unixtime - client->lastinteraction),
1128          flags,
1129          client->db->id,
1130          (int) dictSize(client->pubsub_channels),
1131          (int) listLength(client->pubsub_patterns),
1132          (client->flags & CLIENT_MULTI) ? client->mstate.count : -1,
1133          (PORT_ULONGLONG) sdslen(client->querybuf),
1134          (PORT_ULONGLONG) sdsavail(client->querybuf),
1135          (PORT_ULONGLONG) client->bufpos,
1136          (PORT_ULONGLONG) listLength(client->reply),
1137          (PORT_ULONGLONG) getClientOutputBufferMemoryUsage(client),
1138          events,
1139          client->lastcmd ? client->lastcmd->name : "NULL");
1140  }
1141  sds getAllClientsInfoString(int type) {
1142      listNode *ln;
1143      listIter li;
1144      client *client;
1145      sds o = sdsnewlen(SDS_NOINIT,200*listLength(server.clients));
1146      sdsclear(o);
1147      listRewind(server.clients,&li);
1148      while ((ln = listNext(&li)) != NULL) {
1149          client = listNodeValue(ln);
1150          if (type != -1 && getClientType(client) != type) continue;
1151          o = catClientInfoString(o,client);
1152          o = sdscatlen(o,"\n",1);
1153      }
1154      return o;
1155  }
1156  void clientCommand(client *c) {
1157      listNode *ln;
1158      listIter li;
1159      client *client;
1160      if (c->argc == 2 && !strcasecmp(c->argv[1]->ptr,"help")) {
1161          const char *help[] = {
1162  "id                     -- Return the ID of the current connection.",
1163  "getname                -- Return the name of the current connection.",
1164  "kill <ip:port>         -- Kill connection made from <ip:port>.",
1165  "kill <option> <value> [option value ...] -- Kill connections. Options are:",
1166  "     addr <ip:port>                      -- Kill connection made from <ip:port>",
1167  "     type (normal|master|replica|pubsub) -- Kill connections by type.",
1168  "     skipme (yes|no)   -- Skip killing current connection (default: yes).",
1169  "list [options ...]     -- Return information about client connections. Options:",
1170  "     type (normal|master|replica|pubsub) -- Return clients of specified type.",
1171  "pause <timeout>        -- Suspend all Redis clients for <timout> milliseconds.",
1172  "reply (on|off|skip)    -- Control the replies sent to the current connection.",
1173  "setname <name>         -- Assign the name <name> to the current connection.",
1174  "unblock <clientid> [TIMEOUT|ERROR] -- Unblock the specified blocked client.",
1175  NULL
1176          };
1177          addReplyHelp(c, help);
1178      } else if (!strcasecmp(c->argv[1]->ptr,"id") && c->argc == 2) {
1179          addReplyLongLong(c,c->id);
1180      } else if (!strcasecmp(c->argv[1]->ptr,"list")) {
1181          int type = -1;
1182          if (c->argc == 4 && !strcasecmp(c->argv[2]->ptr,"type")) {
1183              type = getClientTypeByName(c->argv[3]->ptr);
1184              if (type == -1) {
1185                  addReplyErrorFormat(c,"Unknown client type '%s'",
1186                      (char*) c->argv[3]->ptr);
1187                  return;
1188               }
1189          } else if (c->argc != 2) {
1190              addReply(c,shared.syntaxerr);
1191              return;
1192          }
1193          sds o = getAllClientsInfoString(type);
1194          addReplyBulkCBuffer(c,o,sdslen(o));
1195          sdsfree(o);
1196      } else if (!strcasecmp(c->argv[1]->ptr,"reply") && c->argc == 3) {
1197          if (!strcasecmp(c->argv[2]->ptr,"on")) {
1198              c->flags &= ~(CLIENT_REPLY_SKIP|CLIENT_REPLY_OFF);
1199              addReply(c,shared.ok);
1200          } else if (!strcasecmp(c->argv[2]->ptr,"off")) {
1201              c->flags |= CLIENT_REPLY_OFF;
1202          } else if (!strcasecmp(c->argv[2]->ptr,"skip")) {
1203              if (!(c->flags & CLIENT_REPLY_OFF))
1204                  c->flags |= CLIENT_REPLY_SKIP_NEXT;
1205          } else {
1206              addReply(c,shared.syntaxerr);
1207              return;
1208          }
1209      } else if (!strcasecmp(c->argv[1]->ptr,"kill")) {
1210          char *addr = NULL;
1211          int type = -1;
1212          uint64_t id = 0;
1213          int skipme = 1;
1214          int killed = 0, close_this_client = 0;
1215          if (c->argc == 3) {
1216              addr = c->argv[2]->ptr;
1217              skipme = 0; &bsol;* With the old form, you can kill yourself. */
1218          } else if (c->argc > 3) {
1219              int i = 2; &bsol;* Next option index. */
1220              while(i < c->argc) {
1221                  int moreargs = c->argc > i+1;
1222                  if (!strcasecmp(c->argv[i]->ptr,"id") && moreargs) {
1223                      PORT_LONGLONG tmp;
1224                      if (getLongLongFromObjectOrReply(c,c->argv[i+1],&tmp,NULL)
1225                          != C_OK) return;
1226                      id = tmp;
1227                  } else if (!strcasecmp(c->argv[i]->ptr,"type") && moreargs) {
1228                      type = getClientTypeByName(c->argv[i+1]->ptr);
1229                      if (type == -1) {
1230                          addReplyErrorFormat(c,"Unknown client type '%s'",
1231                              (char*) c->argv[i+1]->ptr);
1232                          return;
1233                      }
1234                  } else if (!strcasecmp(c->argv[i]->ptr,"addr") && moreargs) {
1235                      addr = c->argv[i+1]->ptr;
1236                  } else if (!strcasecmp(c->argv[i]->ptr,"skipme") && moreargs) {
1237                      if (!strcasecmp(c->argv[i+1]->ptr,"yes")) {
1238                          skipme = 1;
1239                      } else if (!strcasecmp(c->argv[i+1]->ptr,"no")) {
1240                          skipme = 0;
1241                      } else {
1242                          addReply(c,shared.syntaxerr);
1243                          return;
1244                      }
1245                  } else {
1246                      addReply(c,shared.syntaxerr);
1247                      return;
1248                  }
1249                  i += 2;
1250              }
1251          } else {
1252              addReply(c,shared.syntaxerr);
1253              return;
1254          }
1255          listRewind(server.clients,&li);
1256          while ((ln = listNext(&li)) != NULL) {
1257              client = listNodeValue(ln);
1258              if (addr && strcmp(getClientPeerId(client),addr) != 0) continue;
1259              if (type != -1 && getClientType(client) != type) continue;
1260              if (id != 0 && client->id != id) continue;
1261              if (c == client && skipme) continue;
1262              if (c == client) {
1263                  close_this_client = 1;
1264              } else {
1265                  freeClient(client);
1266              }
1267              killed++;
1268          }
1269          if (c->argc == 3) {
1270              if (killed == 0)
1271                  addReplyError(c,"No such client");
1272              else
1273                  addReply(c,shared.ok);
1274          } else {
1275              addReplyLongLong(c,killed);
1276          }
1277          if (close_this_client) c->flags |= CLIENT_CLOSE_AFTER_REPLY;
1278      } else if (!strcasecmp(c->argv[1]->ptr,"unblock") && (c->argc == 3 ||
1279                                                            c->argc == 4))
1280      {
1281          PORT_LONGLONG id;
1282          int unblock_error = 0;
1283          if (c->argc == 4) {
1284              if (!strcasecmp(c->argv[3]->ptr,"timeout")) {
1285                  unblock_error = 0;
1286              } else if (!strcasecmp(c->argv[3]->ptr,"error")) {
1287                  unblock_error = 1;
1288              } else {
1289                  addReplyError(c,
1290                      "CLIENT UNBLOCK reason should be TIMEOUT or ERROR");
1291                  return;
1292              }
1293          }
1294          if (getLongLongFromObjectOrReply(c,c->argv[2],&id,NULL)
1295              != C_OK) return;
1296          struct client *target = lookupClientByID(id);
1297          if (target && target->flags & CLIENT_BLOCKED) {
1298              if (unblock_error)
1299                  addReplyError(target,
1300                      "-UNBLOCKED client unblocked via CLIENT UNBLOCK");
1301              else
1302                  replyToBlockedClientTimedOut(target);
1303              unblockClient(target);
1304              addReply(c,shared.cone);
1305          } else {
1306              addReply(c,shared.czero);
1307          }
1308      } else if (!strcasecmp(c->argv[1]->ptr,"setname") && c->argc == 3) {
1309          int j, len = (int)sdslen(c->argv[2]->ptr);                              WIN_PORT_FIX &bsol;* cast (int) */
1310          char *p = c->argv[2]->ptr;
1311          if (len == 0) {
1312              if (c->name) decrRefCount(c->name);
1313              c->name = NULL;
1314              addReply(c,shared.ok);
1315              return;
1316          }
1317          for (j = 0; j < len; j++) {
1318              if (p[j] < '!' || p[j] > '~') { &bsol;* ASCII is assumed. */
1319                  addReplyError(c,
1320                      "Client names cannot contain spaces, "
1321                      "newlines or special characters.");
1322                  return;
1323              }
1324          }
1325          if (c->name) decrRefCount(c->name);
1326          c->name = c->argv[2];
1327          incrRefCount(c->name);
1328          addReply(c,shared.ok);
1329      } else if (!strcasecmp(c->argv[1]->ptr,"getname") && c->argc == 2) {
1330          if (c->name)
1331              addReplyBulk(c,c->name);
1332          else
1333              addReply(c,shared.nullbulk);
1334      } else if (!strcasecmp(c->argv[1]->ptr,"pause") && c->argc == 3) {
1335          PORT_LONGLONG duration;
1336          if (getTimeoutFromObjectOrReply(c,c->argv[2],&duration,UNIT_MILLISECONDS)
1337                                          != C_OK) return;
1338          pauseClients(duration);
1339          addReply(c,shared.ok);
1340      } else {
1341          addReplyErrorFormat(c, "Unknown subcommand or wrong number of arguments for '%s'. Try CLIENT HELP", (char*)c->argv[1]->ptr);
1342      }
1343  }
1344  void securityWarningCommand(client *c) {
1345      static time_t logged_time;
1346      time_t now = time(NULL);
1347      if (labs(now-logged_time) > 60) {
1348          serverLog(LL_WARNING,"Possible SECURITY ATTACK detected. It looks like somebody is sending POST or Host: commands to Redis. This is likely due to an attacker attempting to use Cross Protocol Scripting to compromise your Redis instance. Connection aborted.");
1349          logged_time = now;
1350      }
1351      freeClientAsync(c);
1352  }
1353  void rewriteClientCommandVector(client *c, int argc, ...) {
1354      va_list ap;
1355      int j;
1356      robj **argv; &bsol;* The new argument vector */
1357      argv = zmalloc(sizeof(robj*)*argc);
1358      va_start(ap,argc);
1359      for (j = 0; j < argc; j++) {
1360          robj *a;
1361          a = va_arg(ap, robj*);
1362          argv[j] = a;
1363          incrRefCount(a);
1364      }
1365      for (j = 0; j < c->argc; j++) decrRefCount(c->argv[j]);
1366      zfree(c->argv);
1367      c->argv = argv;
1368      c->argc = argc;
1369      c->cmd = lookupCommandOrOriginal(c->argv[0]->ptr);
1370      serverAssertWithInfo(c,NULL,c->cmd != NULL);
1371      va_end(ap);
1372  }
1373  void replaceClientCommandVector(client *c, int argc, robj **argv) {
1374      freeClientArgv(c);
1375      zfree(c->argv);
1376      c->argv = argv;
1377      c->argc = argc;
1378      c->cmd = lookupCommandOrOriginal(c->argv[0]->ptr);
1379      serverAssertWithInfo(c,NULL,c->cmd != NULL);
1380  }
1381  void rewriteClientCommandArgument(client *c, int i, robj *newval) {
1382      robj *oldval;
1383      if (i >= c->argc) {
1384          c->argv = zrealloc(c->argv,sizeof(robj*)*((PORT_ULONG)i+1));  WIN_PORT_FIX &bsol;* cast (PORT_ULONG) */
1385          c->argc = i+1;
1386          c->argv[i] = NULL;
1387      }
1388      oldval = c->argv[i];
1389      c->argv[i] = newval;
1390      incrRefCount(newval);
1391      if (oldval) decrRefCount(oldval);
1392      if (i == 0) {
1393          c->cmd = lookupCommandOrOriginal(c->argv[0]->ptr);
1394          serverAssertWithInfo(c,NULL,c->cmd != NULL);
1395      }
1396  }
1397  PORT_ULONG getClientOutputBufferMemoryUsage(client *c) {
1398      PORT_ULONG list_item_size = sizeof(listNode) + sizeof(clientReplyBlock);
1399      return c->reply_bytes + (list_item_size*listLength(c->reply));
1400  }
1401  int getClientType(client *c) {
1402      if (c->flags & CLIENT_MASTER) return CLIENT_TYPE_MASTER;
1403      if ((c->flags & CLIENT_SLAVE) && !(c->flags & CLIENT_MONITOR))
1404          return CLIENT_TYPE_SLAVE;
1405      if (c->flags & CLIENT_PUBSUB) return CLIENT_TYPE_PUBSUB;
1406      return CLIENT_TYPE_NORMAL;
1407  }
1408  int getClientTypeByName(char *name) {
1409      if (!strcasecmp(name,"normal")) return CLIENT_TYPE_NORMAL;
1410      else if (!strcasecmp(name,"slave")) return CLIENT_TYPE_SLAVE;
1411      else if (!strcasecmp(name,"replica")) return CLIENT_TYPE_SLAVE;
1412      else if (!strcasecmp(name,"pubsub")) return CLIENT_TYPE_PUBSUB;
1413      else if (!strcasecmp(name,"master")) return CLIENT_TYPE_MASTER;
1414      else return -1;
1415  }
1416  char *getClientTypeName(int class) {
1417      switch(class) {
1418      case CLIENT_TYPE_NORMAL: return "normal";
1419      case CLIENT_TYPE_SLAVE:  return "slave";
1420      case CLIENT_TYPE_PUBSUB: return "pubsub";
1421      case CLIENT_TYPE_MASTER: return "master";
1422      default:                       return NULL;
1423      }
1424  }
1425  int checkClientOutputBufferLimits(client *c) {
1426      int soft = 0, hard = 0, class;
1427      PORT_ULONG used_mem = getClientOutputBufferMemoryUsage(c);
1428      class = getClientType(c);
1429      if (class == CLIENT_TYPE_MASTER) class = CLIENT_TYPE_NORMAL;
1430      if (server.client_obuf_limits[class].hard_limit_bytes &&
1431          used_mem >= server.client_obuf_limits[class].hard_limit_bytes)
1432          hard = 1;
1433      if (server.client_obuf_limits[class].soft_limit_bytes &&
1434          used_mem >= server.client_obuf_limits[class].soft_limit_bytes)
1435          soft = 1;
1436      if (soft) {
1437          if (c->obuf_soft_limit_reached_time == 0) {
1438              c->obuf_soft_limit_reached_time = server.unixtime;
1439              soft = 0; &bsol;* First time we see the soft limit reached */
1440          } else {
1441              time_t elapsed = server.unixtime - c->obuf_soft_limit_reached_time;
1442              if (elapsed <=
1443                  server.client_obuf_limits[class].soft_limit_seconds) {
1444                  soft = 0; &bsol;* The client still did not reached the max number of
1445                               seconds for the soft limit to be considered
1446                               reached. */
1447              }
1448          }
1449      } else {
1450          c->obuf_soft_limit_reached_time = 0;
1451      }
1452      return soft || hard;
1453  }
1454  void asyncCloseClientOnOutputBufferLimitReached(client *c) {
1455      if (c->fd == -1) return; &bsol;* It is unsafe to free fake clients. */
1456      POSIX_ONLY(serverAssert(c->reply_bytes < PORT_ULONG_MAX-(1024*64));)
1457      if (c->reply_bytes == 0 || c->flags & CLIENT_CLOSE_ASAP) return;
1458      if (checkClientOutputBufferLimits(c)) {
1459          sds client = catClientInfoString(sdsempty(),c);
1460          freeClientAsync(c);
1461          serverLog(LL_WARNING,"Client %s scheduled to be closed ASAP for overcoming of output buffer limits.", client);
1462          sdsfree(client);
1463      }
1464  }
1465  void flushSlavesOutputBuffers(void) {
1466      listIter li;
1467      listNode *ln;
1468      listRewind(server.slaves,&li);
1469      while((ln = listNext(&li))) {
1470          client *slave = listNodeValue(ln);
1471          int events = aeGetFileEvents(server.el,slave->fd);
1472          int can_receive_writes = (events & AE_WRITABLE) ||
1473                                   (slave->flags & CLIENT_PENDING_WRITE);
1474          if (slave->replstate == SLAVE_STATE_ONLINE &&
1475              can_receive_writes &&
1476              !slave->repl_put_online_on_ack &&
1477              clientHasPendingReplies(slave))
1478          {
1479              writeToClient(slave->fd,slave,0);
1480          }
1481      }
1482  }
1483  void pauseClients(mstime_t end) {
1484      if (!server.clients_paused || end > server.clients_pause_end_time)
1485          server.clients_pause_end_time = end;
1486      server.clients_paused = 1;
1487  }
1488  int clientsArePaused(void) {
1489      if (server.clients_paused &&
1490          server.clients_pause_end_time < server.mstime)
1491      {
1492          listNode *ln;
1493          listIter li;
1494          client *c;
1495          server.clients_paused = 0;
1496          listRewind(server.clients,&li);
1497          while ((ln = listNext(&li)) != NULL) {
1498              c = listNodeValue(ln);
1499              if (c->flags & (CLIENT_SLAVE|CLIENT_BLOCKED)) continue;
1500              queueClientForReprocessing(c);
1501          }
1502      }
1503      return server.clients_paused;
1504  }
1505  int processEventsWhileBlocked(void) {
1506      int iterations = 4; &bsol;* See the function top-comment. */
1507      int count = 0;
1508      while (iterations--) {
1509          int events = 0;
1510          events += aeProcessEvents(server.el, AE_FILE_EVENTS|AE_DONT_WAIT);
1511          events += handleClientsWithPendingWrites();
1512          if (!events) break;
1513          count += events;
1514      }
1515      return count;
1516  }
</code></pre>
        </div>
        <div class="column">
            <h3>redis-MDEwOlJlcG9zaXRvcnkxMDgxMTA3MDY=-flat-aof.c</h3>
            <pre><code>1  #ifdef _WIN32
2  #include "Win32_Interop/win32_types.h"
3  #include "Win32_Interop/Win32_Error.h"
4  #endif
5  #include "server.h"
6  #include "bio.h"
7  #include "rio.h"
8  #include <signal.h>
9  #include <fcntl.h>
10  #include <sys/stat.h>
11  #include <sys/types.h>
12  #ifndef _WIN32
13  #include <sys/time.h>
14  #include <sys/resource.h>
15  #include <sys/wait.h>
16  #include <sys/param.h>
17  #else
18  #include "Win32_Interop/Win32_QFork.h"
19  #include <direct.h>
20  #define MAXPATHLEN 1024
21  #endif
22  void aofUpdateCurrentSize(void);
23  void aofClosePipes(void);
24  #define AOF_RW_BUF_BLOCK_SIZE (1024*1024*10)    &bsol;* 10 MB per block */
25  typedef struct aofrwblock {
26      PORT_ULONG used, free;
27      char buf[AOF_RW_BUF_BLOCK_SIZE];
28  } aofrwblock;
29  void aofRewriteBufferReset(void) {
30      if (server.aof_rewrite_buf_blocks)
31          listRelease(server.aof_rewrite_buf_blocks);
32      server.aof_rewrite_buf_blocks = listCreate();
33      listSetFreeMethod(server.aof_rewrite_buf_blocks,zfree);
34  }
35  PORT_ULONG aofRewriteBufferSize(void) {
36      listNode *ln;
37      listIter li;
38      PORT_ULONG size = 0;
39      listRewind(server.aof_rewrite_buf_blocks,&li);
40      while((ln = listNext(&li))) {
41          aofrwblock *block = listNodeValue(ln);
42          size += block->used;
43      }
44      return size;
45  }
46  void aofChildWriteDiffData(aeEventLoop *el, int fd, void *privdata, int mask) {
47      listNode *ln;
48      aofrwblock *block;
49      ssize_t nwritten;
50      UNUSED(el);
51      UNUSED(fd);
52      UNUSED(privdata);
53      UNUSED(mask);
54      while(1) {
55          ln = listFirst(server.aof_rewrite_buf_blocks);
56          block = ln ? ln->value : NULL;
57          if (server.aof_stop_sending_diff || !block) {
58  #ifndef _WIN32
59              aeDeleteFileEvent(server.el,server.aof_pipe_write_data_to_child,
60                                AE_WRITABLE);
61  #endif
62              return;
63          }
64          if (block->used > 0) {
65              nwritten = write(server.aof_pipe_write_data_to_child,
66                               block->buf,block->used);
67              if (nwritten <= 0) return;
68              memmove(block->buf,block->buf+nwritten,block->used-nwritten);
69              block->used -= nwritten;
70              block->free += nwritten;
71          }
72          if (block->used == 0) listDelNode(server.aof_rewrite_buf_blocks,ln);
73      }
74  }
75  void aofRewriteBufferAppend(unsigned char *s, PORT_ULONG len) {
76      listNode *ln = listLast(server.aof_rewrite_buf_blocks);
77      aofrwblock *block = ln ? ln->value : NULL;
78      while(len) {
79          if (block) {
80              PORT_ULONG thislen = (block->free < len) ? block->free : len;
81              if (thislen) {  &bsol;* The current block is not already full. */
82                  memcpy(block->buf+block->used, s, thislen);
83                  block->used += thislen;
84                  block->free -= thislen;
85                  s += thislen;
86                  len -= thislen;
87              }
88          }
89          if (len) { &bsol;* First block to allocate, or need another block. */
90              int numblocks;
91              block = zmalloc(sizeof(*block));
92  #ifdef _WIN32
93              if (block) {
94  #endif
95                  block->free = AOF_RW_BUF_BLOCK_SIZE;
96                  block->used = 0;
97  #ifdef _WIN32
98              }
99  #endif
100              listAddNodeTail(server.aof_rewrite_buf_blocks,block);
101              numblocks = (int) listLength(server.aof_rewrite_buf_blocks);         WIN_PORT_FIX &bsol;* cast (int) */
102              if (((numblocks+1) % 10) == 0) {
103                  int level = ((numblocks+1) % 100) == 0 ? LL_WARNING :
104                                                           LL_NOTICE;
105                  serverLog(level,"Background AOF buffer size: %Iu MB", WIN_PORT_FIX &bsol;* %lu -> %Iu */
106                      aofRewriteBufferSize()/(1024*1024));
107              }
108          }
109      }
110  #ifndef _WIN32
111      if (aeGetFileEvents(server.el,server.aof_pipe_write_data_to_child) == 0) {
112          aeCreateFileEvent(server.el, server.aof_pipe_write_data_to_child,
113              AE_WRITABLE, aofChildWriteDiffData, NULL);
114      }
115  #endif
116  }
117  ssize_t aofRewriteBufferWrite(int fd) {
118      listNode *ln;
119      listIter li;
120      ssize_t count = 0;
121      listRewind(server.aof_rewrite_buf_blocks,&li);
122      while((ln = listNext(&li))) {
123          aofrwblock *block = listNodeValue(ln);
124          ssize_t nwritten;
125          if (block->used) {
126              nwritten = write(fd,block->buf,block->used);
127              if (nwritten != (ssize_t)block->used) {
128                  if (nwritten == 0) errno = EIO;
129                  return -1;
130              }
131              count += nwritten;
132          }
133      }
134      return count;
135  }
136  int aofFsyncInProgress(void) {
137      return bioPendingJobsOfType(BIO_AOF_FSYNC) != 0;
138  }
139  void aof_background_fsync(int fd) {
140      bioCreateBackgroundJob(BIO_AOF_FSYNC,(void*)(PORT_LONG)fd,NULL,NULL);
141  }
142  static void killAppendOnlyChild(void) {
143      POSIX_ONLY(int statloc;)
144      if (server.aof_child_pid == -1) return;
145      serverLog(LL_NOTICE,"Killing running AOF rewrite child: %Id", WIN_PORT_FIX &bsol;* %ld -> %Id */
146          (PORT_LONG) server.aof_child_pid);
147  #ifdef _WIN32
148          AbortForkOperation();
149  #else
150      if (kill(server.aof_child_pid,SIGUSR1) != -1) {
151          while(wait3(&statloc,0,NULL) != server.aof_child_pid);
152      }
153  #endif
154      aofRewriteBufferReset();
155      aofRemoveTempFile(server.aof_child_pid);
156      server.aof_child_pid = -1;
157      server.aof_rewrite_time_start = -1;
158      aofClosePipes();
159  }
160  void stopAppendOnly(void) {
161      serverAssert(server.aof_state != AOF_OFF);
162      flushAppendOnlyFile(1);
163      redis_fsync(server.aof_fd);
164      close(server.aof_fd);
165      server.aof_fd = -1;
166      server.aof_selected_db = -1;
167      server.aof_state = AOF_OFF;
168      killAppendOnlyChild();
169  }
170  int startAppendOnly(void) {
171      char cwd[MAXPATHLEN]; &bsol;* Current working dir path for error messages. */
172      int newfd;
173      newfd = open(server.aof_filename,O_WRONLY|O_APPEND|O_CREAT WIN32_ONLY(|_O_BINARY), IF_WIN32(_S_IREAD|_S_IWRITE, 0644));
174      serverAssert(server.aof_state == AOF_OFF);
175      if (newfd == -1) {
176          char *cwdp = IF_WIN32(_getcwd, getcwd)(cwd, MAXPATHLEN);
177          serverLog(LL_WARNING,
178              "Redis needs to enable the AOF but can't open the "
179              "append only file %s (in server root dir %s): %s",
180              server.aof_filename,
181              cwdp ? cwdp : "unknown",
182              IF_WIN32(wsa_strerror(errno), strerror(errno)));
183          return C_ERR;
184      }
185      if (server.rdb_child_pid != -1) {
186          server.aof_rewrite_scheduled = 1;
187          serverLog(LL_WARNING,"AOF was enabled but there is already a child process saving an RDB file on disk. An AOF background was scheduled to start when possible.");
188      } else {
189          if (server.aof_child_pid != -1) {
190              serverLog(LL_WARNING,"AOF was enabled but there is already an AOF rewriting in background. Stopping background AOF and starting a rewrite now.");
191              killAppendOnlyChild();
192          }
193          if (rewriteAppendOnlyFileBackground() == C_ERR) {
194              close(newfd);
195              serverLog(LL_WARNING,"Redis needs to enable the AOF but can't trigger a background AOF rewrite operation. Check the above logs for more info about the error.");
196              return C_ERR;
197          }
198      }
199      server.aof_state = AOF_WAIT_REWRITE;
200      server.aof_last_fsync = server.unixtime;
201      server.aof_fd = newfd;
202      return C_OK;
203  }
204  ssize_t aofWrite(int fd, const char *buf, size_t len) {
205      ssize_t nwritten = 0, totwritten = 0;
206      while(len) {
207          nwritten = write(fd, buf, len);
208          if (nwritten < 0) {
209              if (errno == EINTR) {
210                  continue;
211              }
212              return totwritten ? totwritten : -1;
213          }
214          len -= nwritten;
215          buf += nwritten;
216          totwritten += nwritten;
217      }
218      return totwritten;
219  }
220  #define AOF_WRITE_LOG_ERROR_RATE 30 &bsol;* Seconds between errors logging. */
221  void flushAppendOnlyFile(int force) {
222      ssize_t nwritten;
223      int sync_in_progress = 0;
224      mstime_t latency;
225      if (sdslen(server.aof_buf) == 0) {
226          if (server.aof_fsync == AOF_FSYNC_EVERYSEC &&
227              server.aof_fsync_offset != server.aof_current_size &&
228              server.unixtime > server.aof_last_fsync &&
229              !(sync_in_progress = aofFsyncInProgress())) {
230              goto try_fsync;
231          } else {
232              return;
233          }
234      }
235      if (server.aof_fsync == AOF_FSYNC_EVERYSEC)
236          sync_in_progress = aofFsyncInProgress();
237      if (server.aof_fsync == AOF_FSYNC_EVERYSEC && !force) {
238          if (sync_in_progress) {
239              if (server.aof_flush_postponed_start == 0) {
240                  server.aof_flush_postponed_start = server.unixtime;
241                  return;
242              } else if (server.unixtime - server.aof_flush_postponed_start < 2) {
243                  return;
244              }
245              server.aof_delayed_fsync++;
246              serverLog(LL_NOTICE,"Asynchronous AOF fsync is taking too long (disk is busy?). Writing the AOF buffer without waiting for fsync to complete, this may slow down Redis.");
247          }
248      }
249      latencyStartMonitor(latency);
250      nwritten = aofWrite(server.aof_fd,server.aof_buf,sdslen(server.aof_buf));
251      latencyEndMonitor(latency);
252      if (sync_in_progress) {
253          latencyAddSampleIfNeeded("aof-write-pending-fsync",latency);
254      } else if (server.aof_child_pid != -1 || server.rdb_child_pid != -1) {
255          latencyAddSampleIfNeeded("aof-write-active-child",latency);
256      } else {
257          latencyAddSampleIfNeeded("aof-write-alone",latency);
258      }
259      latencyAddSampleIfNeeded("aof-write",latency);
260      server.aof_flush_postponed_start = 0;
261      if (nwritten != (ssize_t)sdslen(server.aof_buf)) {
262          static time_t last_write_error_log = 0;
263          int can_log = 0;
264          if ((server.unixtime - last_write_error_log) > AOF_WRITE_LOG_ERROR_RATE) {
265              can_log = 1;
266              last_write_error_log = server.unixtime;
267          }
268          if (nwritten == -1) {
269              if (can_log) {
270                  serverLog(LL_WARNING,"Error writing to the AOF file: %s",
271                      IF_WIN32(wsa_strerror(errno), strerror(errno)));
272                  server.aof_last_write_errno = errno;
273              }
274          } else {
275              if (can_log) {
276                  serverLog(LL_WARNING,"Short write while writing to "
277                                         "the AOF file: (nwritten=%lld, "
278                                         "expected=%lld)",
279                                         (PORT_LONGLONG)nwritten,
280                                         (PORT_LONGLONG)sdslen(server.aof_buf));
281              }
282              if (ftruncate(server.aof_fd, server.aof_current_size) == -1) {
283                  if (can_log) {
284                      serverLog(LL_WARNING, "Could not remove short write "
285                               "from the append-only file.  Redis may refuse "
286                               "to load the AOF the next time it starts.  "
287                               "ftruncate: %s", IF_WIN32(wsa_strerror(errno), strerror(errno)));
288                  }
289              } else {
290                  nwritten = -1;
291              }
292              server.aof_last_write_errno = ENOSPC;
293          }
294          if (server.aof_fsync == AOF_FSYNC_ALWAYS) {
295              serverLog(LL_WARNING,"Can't recover from AOF write error when the AOF fsync policy is 'always'. Exiting...");
296              exit(1);
297          } else {
298              server.aof_last_write_status = C_ERR;
299              if (nwritten > 0) {
300                  server.aof_current_size += nwritten;
301                  sdsrange(server.aof_buf,(int)nwritten,-1);                      WIN_PORT_FIX &bsol;* cast (int) */
302              }
303              return; &bsol;* We'll try again on the next call... */
304          }
305      } else {
306          if (server.aof_last_write_status == C_ERR) {
307              serverLog(LL_WARNING,
308                  "AOF write error looks solved, Redis can write again.");
309              server.aof_last_write_status = C_OK;
310          }
311      }
312      server.aof_current_size += nwritten;
313      if ((sdslen(server.aof_buf)+sdsavail(server.aof_buf)) < 4000) {
314          sdsclear(server.aof_buf);
315      } else {
316          sdsfree(server.aof_buf);
317          server.aof_buf = sdsempty();
318      }
319  try_fsync:
320      if (server.aof_no_fsync_on_rewrite &&
321          (server.aof_child_pid != -1 || server.rdb_child_pid != -1))
322              return;
323      if (server.aof_fsync == AOF_FSYNC_ALWAYS) {
324          latencyStartMonitor(latency);
325          redis_fsync(server.aof_fd); &bsol;* Let's try to get this data on the disk */
326          latencyEndMonitor(latency);
327          latencyAddSampleIfNeeded("aof-fsync-always",latency);
328          server.aof_fsync_offset = server.aof_current_size;
329          server.aof_last_fsync = server.unixtime;
330      } else if ((server.aof_fsync == AOF_FSYNC_EVERYSEC &&
331                  server.unixtime > server.aof_last_fsync)) {
332          if (!sync_in_progress) {
333              aof_background_fsync(server.aof_fd);
334              server.aof_fsync_offset = server.aof_current_size;
335          }
336          server.aof_last_fsync = server.unixtime;
337      }
338  }
339  sds catAppendOnlyGenericCommand(sds dst, int argc, robj **argv) {
340      char buf[32];
341      int len, j;
342      robj *o;
343      buf[0] = '*';
344      len = 1+ll2string(buf+1,sizeof(buf)-1,argc);
345      buf[len++] = '\r';
346      buf[len++] = '\n';
347      dst = sdscatlen(dst,buf,len);
348      for (j = 0; j < argc; j++) {
349          o = getDecodedObject(argv[j]);
350          buf[0] = '$';
351          len = 1+ll2string(buf+1,sizeof(buf)-1,sdslen(o->ptr));
352          buf[len++] = '\r';
353          buf[len++] = '\n';
354          dst = sdscatlen(dst,buf,len);
355          dst = sdscatlen(dst,o->ptr,sdslen(o->ptr));
356          dst = sdscatlen(dst,"\r\n",2);
357          decrRefCount(o);
358      }
359      return dst;
360  }
361  sds catAppendOnlyExpireAtCommand(sds buf, struct redisCommand *cmd, robj *key, robj *seconds) {
362      PORT_LONGLONG when;
363      robj *argv[3];
364      seconds = getDecodedObject(seconds);
365      when = strtoll(seconds->ptr,NULL,10);
366      if (cmd->proc == expireCommand || cmd->proc == setexCommand ||
367          cmd->proc == expireatCommand)
368      {
369          when *= 1000;
370      }
371      if (cmd->proc == expireCommand || cmd->proc == pexpireCommand ||
372          cmd->proc == setexCommand || cmd->proc == psetexCommand)
373      {
374          when += mstime();
375      }
376      decrRefCount(seconds);
377      argv[0] = createStringObject("PEXPIREAT",9);
378      argv[1] = key;
379      argv[2] = createStringObjectFromLongLong(when);
380      buf = catAppendOnlyGenericCommand(buf, 3, argv);
381      decrRefCount(argv[0]);
382      decrRefCount(argv[2]);
383      return buf;
384  }
385  void feedAppendOnlyFile(struct redisCommand *cmd, int dictid, robj **argv, int argc) {
386      sds buf = sdsempty();
387      robj *tmpargv[3];
388      if (dictid != server.aof_selected_db) {
389          char seldb[64];
390          snprintf(seldb,sizeof(seldb),"%d",dictid);
391          WIN32_ONLY(seldb[sizeof(seldb)-1] = 0;) &bsol;*get rid of C6053 warning*/
392          buf = sdscatprintf(buf,"*2\r\n$6\r\nSELECT\r\n$%Iu\r\n%s\r\n", WIN_PORT_FIX &bsol;* %lu -> %Iu */
393              (PORT_ULONG)strlen(seldb),seldb);
394          server.aof_selected_db = dictid;
395      }
396      if (cmd->proc == expireCommand || cmd->proc == pexpireCommand ||
397          cmd->proc == expireatCommand) {
398          buf = catAppendOnlyExpireAtCommand(buf,cmd,argv[1],argv[2]);
399      } else if (cmd->proc == setexCommand || cmd->proc == psetexCommand) {
400          tmpargv[0] = createStringObject("SET",3);
401          tmpargv[1] = argv[1];
402          tmpargv[2] = argv[3];
403          buf = catAppendOnlyGenericCommand(buf,3,tmpargv);
404          decrRefCount(tmpargv[0]);
405          buf = catAppendOnlyExpireAtCommand(buf,cmd,argv[1],argv[2]);
406      } else if (cmd->proc == setCommand && argc > 3) {
407          int i;
408          robj *exarg = NULL, *pxarg = NULL;
409          buf = catAppendOnlyGenericCommand(buf,3,argv);
410          for (i = 3; i < argc; i ++) {
411              if (!strcasecmp(argv[i]->ptr, "ex")) exarg = argv[i+1];
412              if (!strcasecmp(argv[i]->ptr, "px")) pxarg = argv[i+1];
413          }
414          serverAssert(!(exarg && pxarg));
415          if (exarg)
416              buf = catAppendOnlyExpireAtCommand(buf,server.expireCommand,argv[1],
417                                                 exarg);
418          if (pxarg)
419              buf = catAppendOnlyExpireAtCommand(buf,server.pexpireCommand,argv[1],
420                                                 pxarg);
421      } else {
422          buf = catAppendOnlyGenericCommand(buf,argc,argv);
423      }
424      if (server.aof_state == AOF_ON)
425          server.aof_buf = sdscatlen(server.aof_buf,buf,sdslen(buf));
426      if (server.aof_child_pid != -1)
427          aofRewriteBufferAppend((unsigned char*)buf,(PORT_ULONG)sdslen(buf));    WIN_PORT_FIX &bsol;* cast (PORT_ULONG) */
428      sdsfree(buf);
429  }
430  struct client *createFakeClient(void) {
431      struct client *c = zmalloc(sizeof(*c));
432      selectDb(c,0);
433      c->fd = -1;
434      c->name = NULL;
<span onclick='openModal()' class='match'>435      c->querybuf = sdsempty();
436      c->querybuf_peak = 0;
437      c->argc = 0;
438      c->argv = NULL;
</span>439      c->bufpos = 0;
440      c->flags = 0;
441      c->btype = BLOCKED_NONE;
442      c->replstate = SLAVE_STATE_WAIT_BGSAVE_START;
443      c->reply = listCreate();
444      c->reply_bytes = 0;
445      c->obuf_soft_limit_reached_time = 0;
446      c->watched_keys = listCreate();
447      c->peerid = NULL;
448      listSetFreeMethod(c->reply,freeClientReplyValue);
449      listSetDupMethod(c->reply,dupClientReplyValue);
450      initClientMultiState(c);
451      return c;
452  }
453  void freeFakeClientArgv(struct client *c) {
454      int j;
455      for (j = 0; j < c->argc; j++)
456          decrRefCount(c->argv[j]);
457      zfree(c->argv);
458  }
459  void freeFakeClient(struct client *c) {
460      sdsfree(c->querybuf);
461      listRelease(c->reply);
462      listRelease(c->watched_keys);
463      freeClientMultiState(c);
464      zfree(c);
465  }
466  int loadAppendOnlyFile(char *filename) {
467      struct client *fakeClient;
468      FILE *fp = fopen(filename, IF_WIN32("rb", "r"));
469      struct redis_stat sb;
470      int old_aof_state = server.aof_state;
471      PORT_LONG loops = 0;
472      off_t valid_up_to = 0; &bsol;* Offset of latest well-formed command loaded. */
473      off_t valid_before_multi = 0; &bsol;* Offset before MULTI command loaded. */
474      if (fp == NULL) {
475          serverLog(LL_WARNING,"Fatal error: can't open the append log file for reading: %s",strerror(errno));
476          exit(1);
477      }
478      if (fp && redis_fstat(fileno(fp),&sb) != -1 && sb.st_size == 0) {
479          server.aof_current_size = 0;
480          server.aof_fsync_offset = server.aof_current_size;
481          fclose(fp);
482          return C_ERR;
483      }
484      server.aof_state = AOF_OFF;
485      fakeClient = createFakeClient();
486      startLoading(fp);
487      char sig[5]; &bsol;* "REDIS" */
488      if (fread(sig,1,5,fp) != 5 || memcmp(sig,"REDIS",5) != 0) {
489          if (fseek(fp,0,SEEK_SET) == -1) goto readerr;
490      } else {
491          rio rdb;
492          serverLog(LL_NOTICE,"Reading RDB preamble from AOF file...");
493          if (fseek(fp,0,SEEK_SET) == -1) goto readerr;
494          rioInitWithFile(&rdb,fp);
495          if (rdbLoadRio(&rdb,NULL,1) != C_OK) {
496              serverLog(LL_WARNING,"Error reading the RDB preamble of the AOF file, AOF loading aborted");
497              goto readerr;
498          } else {
499              serverLog(LL_NOTICE,"Reading the remaining AOF tail...");
500          }
501      }
502      while(1) {
503          int argc, j;
504          PORT_ULONG len;
505          robj **argv;
506          char buf[128];
507          sds argsds;
508          struct redisCommand *cmd;
509          if (!(loops++ % 1000)) {
510              loadingProgress((off_t) ftello(fp));                                 WIN_PORT_FIX &bsol;* cast (off_t) */
511              processEventsWhileBlocked();
512          }
513          if (fgets(buf,sizeof(buf),fp) == NULL) {
514              if (feof(fp))
515                  break;
516              else
517                  goto readerr;
518          }
519          if (buf[0] != '*') goto fmterr;
520          if (buf[1] == '\0') goto readerr;
521          argc = atoi(buf+1);
522          if (argc < 1) goto fmterr;
523          argv = zmalloc(sizeof(robj*)*argc);
524          fakeClient->argc = argc;
525          fakeClient->argv = argv;
526          for (j = 0; j < argc; j++) {
527              char *readres = fgets(buf,sizeof(buf),fp);
528              if (readres == NULL || buf[0] != '$') {
529                  fakeClient->argc = j; &bsol;* Free up to j-1. */
530                  freeFakeClientArgv(fakeClient);
531                  if (readres == NULL)
532                      goto readerr;
533                  else
534                      goto fmterr;
535              }
536              len = strtol(buf+1,NULL,10);
537              argsds = sdsnewlen(SDS_NOINIT,len);
538              if (len && fread(argsds,len,1,fp) == 0) {
539                  sdsfree(argsds);
540                  fakeClient->argc = j; &bsol;* Free up to j-1. */
541                  freeFakeClientArgv(fakeClient);
542                  goto readerr;
543              }
544              argv[j] = createObject(OBJ_STRING,argsds);
545              if (fread(buf,2,1,fp) == 0) {
546                  fakeClient->argc = j+1; &bsol;* Free up to j. */
547                  freeFakeClientArgv(fakeClient);
548                  goto readerr;
549              }
550          }
551          cmd = lookupCommand(argv[0]->ptr);
552          if (!cmd) {
553              serverLog(LL_WARNING,
554                  "Unknown command '%s' reading the append only file",
555                  (char*)argv[0]->ptr);
556              exit(1);
557          }
558          if (cmd == server.multiCommand) valid_before_multi = valid_up_to;
559          fakeClient->cmd = cmd;
560          if (fakeClient->flags & CLIENT_MULTI &&
561              fakeClient->cmd->proc != execCommand)
562          {
563              queueMultiCommand(fakeClient);
564          } else {
565              cmd->proc(fakeClient);
566          }
567          serverAssert(fakeClient->bufpos == 0 &&
568                       listLength(fakeClient->reply) == 0);
569          serverAssert((fakeClient->flags & CLIENT_BLOCKED) == 0);
570          freeFakeClientArgv(fakeClient);
571          fakeClient->cmd = NULL;
572          if (server.aof_load_truncated) valid_up_to = ftello(fp);
573      }
574      if (fakeClient->flags & CLIENT_MULTI) {
575          serverLog(LL_WARNING,
576              "Revert incomplete MULTI/EXEC transaction in AOF file");
577          valid_up_to = valid_before_multi;
578          goto uxeof;
579      }
580  loaded_ok: &bsol;* DB loaded, cleanup and return C_OK to the caller. */
581      fclose(fp);
582      freeFakeClient(fakeClient);
583      server.aof_state = old_aof_state;
584      stopLoading();
585      aofUpdateCurrentSize();
586      server.aof_rewrite_base_size = server.aof_current_size;
587      server.aof_fsync_offset = server.aof_current_size;
588      return C_OK;
589  readerr: &bsol;* Read error. If feof(fp) is true, fall through to unexpected EOF. */
590      if (!feof(fp)) {
591          if (fakeClient) freeFakeClient(fakeClient); &bsol;* avoid valgrind warning */
592          serverLog(LL_WARNING,"Unrecoverable error reading the append only file: %s", strerror(errno));
593          exit(1);
594      }
595  uxeof: &bsol;* Unexpected AOF end of file. */
596      if (server.aof_load_truncated) {
597          serverLog(LL_WARNING,"!!! Warning: short read while loading the AOF file !!!");
598          serverLog(LL_WARNING,"!!! Truncating the AOF at offset %llu !!!",
599              (PORT_ULONGLONG) valid_up_to);
600          if (valid_up_to == -1 || truncate(filename,valid_up_to) == -1) {
601              if (valid_up_to == -1) {
602                  serverLog(LL_WARNING,"Last valid command offset is invalid");
603              } else {
604                  serverLog(LL_WARNING,"Error truncating the AOF file: %s",
605                      IF_WIN32(wsa_strerror(errno), strerror(errno)));
606              }
607          } else {
608              if (server.aof_fd != -1 && lseek(server.aof_fd,0,SEEK_END) == -1) {
609                  serverLog(LL_WARNING,"Can't seek the end of the AOF file: %s",
610                      IF_WIN32(wsa_strerror(errno), strerror(errno)));
611              } else {
612                  serverLog(LL_WARNING,
613                      "AOF loaded anyway because aof-load-truncated is enabled");
614                  goto loaded_ok;
615              }
616          }
617      }
618      if (fakeClient) freeFakeClient(fakeClient); &bsol;* avoid valgrind warning */
619      serverLog(LL_WARNING,"Unexpected end of file reading the append only file. You can: 1) Make a backup of your AOF file, then use ./redis-check-aof --fix <filename>. 2) Alternatively you can set the 'aof-load-truncated' configuration option to yes and restart the server.");
620      exit(1);
621  fmterr: &bsol;* Format error. */
622      if (fakeClient) freeFakeClient(fakeClient); &bsol;* avoid valgrind warning */
623      serverLog(LL_WARNING,"Bad file format reading the append only file: make a backup of your AOF file, then use ./redis-check-aof --fix <filename>");
624      exit(1);
625  }
626  int rioWriteBulkObject(rio *r, robj *obj) {
627      if (obj->encoding == OBJ_ENCODING_INT) {
628          return (int)rioWriteBulkLongLong(r,(PORT_LONG)obj->ptr);               WIN_PORT_FIX &bsol;* cast (int) */
629      } else if (sdsEncodedObject(obj)) {
630          return (int)rioWriteBulkString(r,obj->ptr,sdslen(obj->ptr));           WIN_PORT_FIX &bsol;* cast (int) */
631      } else {
632          serverPanic("Unknown string encoding");
633      }
634  }
635  int rewriteListObject(rio *r, robj *key, robj *o) {
636      PORT_LONGLONG count = 0, items = listTypeLength(o);
637      if (o->encoding == OBJ_ENCODING_QUICKLIST) {
638          quicklist *list = o->ptr;
639          quicklistIter *li = quicklistGetIterator(list, AL_START_HEAD);
640          quicklistEntry entry;
641          while (quicklistNext(li,&entry)) {
642              if (count == 0) {
643                  PORT_LONGLONG cmd_items = (items > AOF_REWRITE_ITEMS_PER_CMD) ?  WIN_PORT_FIX &bsol;* int -> PORT_LONGLONG */
644                      AOF_REWRITE_ITEMS_PER_CMD : items;
645                  if (rioWriteBulkCount(r,'*',2+cmd_items) == 0) return 0;
646                  if (rioWriteBulkString(r,"RPUSH",5) == 0) return 0;
647                  if (rioWriteBulkObject(r,key) == 0) return 0;
648              }
649              if (entry.value) {
650                  if (rioWriteBulkString(r,(char*)entry.value,entry.sz) == 0) return 0;
651              } else {
652                  if (rioWriteBulkLongLong(r,entry.longval) == 0) return 0;
653              }
654              if (++count == AOF_REWRITE_ITEMS_PER_CMD) count = 0;
655              items--;
656          }
657          quicklistReleaseIterator(li);
658      } else {
659          serverPanic("Unknown list encoding");
660      }
661      return 1;
662  }
663  int rewriteSetObject(rio *r, robj *key, robj *o) {
664      PORT_LONGLONG count = 0, items = setTypeSize(o);
665      if (o->encoding == OBJ_ENCODING_INTSET) {
666          int ii = 0;
667          int64_t llval;
668          while(intsetGet(o->ptr,ii++,&llval)) {
669              if (count == 0) {
670                  int cmd_items = (items > AOF_REWRITE_ITEMS_PER_CMD) ?
671                      AOF_REWRITE_ITEMS_PER_CMD : (int)items;               WIN_PORT_FIX &bsol;* cast (int) */
672                  if (rioWriteBulkCount(r,'*',(PORT_LONG)2+cmd_items) == 0) return 0;  WIN_PORT_FIX &bsol;* cast (PORT_LONG) */
673                  if (rioWriteBulkString(r,"SADD",4) == 0) return 0;
674                  if (rioWriteBulkObject(r,key) == 0) return 0;
675              }
676              if (rioWriteBulkLongLong(r,llval) == 0) return 0;
677              if (++count == AOF_REWRITE_ITEMS_PER_CMD) count = 0;
678              items--;
679          }
680      } else if (o->encoding == OBJ_ENCODING_HT) {
681          dictIterator *di = dictGetIterator(o->ptr);
682          dictEntry *de;
683          while((de = dictNext(di)) != NULL) {
684              sds ele = dictGetKey(de);
685              if (count == 0) {
686                  int cmd_items = (items > AOF_REWRITE_ITEMS_PER_CMD) ?
687                      AOF_REWRITE_ITEMS_PER_CMD : (int)items;               WIN_PORT_FIX &bsol;* cast (int) */
688                  if (rioWriteBulkCount(r,'*',(PORT_LONG)2+cmd_items) == 0) return 0;  WIN_PORT_FIX &bsol;* cast (PORT_LONG) */
689                  if (rioWriteBulkString(r,"SADD",4) == 0) return 0;
690                  if (rioWriteBulkObject(r,key) == 0) return 0;
691              }
692              if (rioWriteBulkString(r,ele,sdslen(ele)) == 0) return 0;
693              if (++count == AOF_REWRITE_ITEMS_PER_CMD) count = 0;
694              items--;
695          }
696          dictReleaseIterator(di);
697      } else {
698          serverPanic("Unknown set encoding");
699      }
700      return 1;
701  }
702  int rewriteSortedSetObject(rio *r, robj *key, robj *o) {
703      PORT_LONGLONG count = 0, items = zsetLength(o);
704      if (o->encoding == OBJ_ENCODING_ZIPLIST) {
705          unsigned char *zl = o->ptr;
706          unsigned char *eptr, *sptr;
707          unsigned char *vstr;
708          unsigned int vlen;
709          PORT_LONGLONG vll;
710          double score;
711          eptr = ziplistIndex(zl,0);
712          serverAssert(eptr != NULL);
713          sptr = ziplistNext(zl,eptr);
714          serverAssert(sptr != NULL);
715          while (eptr != NULL) {
716              serverAssert(ziplistGet(eptr,&vstr,&vlen,&vll));
717              score = zzlGetScore(sptr);
718              if (count == 0) {
719                  int cmd_items = (items > AOF_REWRITE_ITEMS_PER_CMD) ?
720                      AOF_REWRITE_ITEMS_PER_CMD : (int)items;               WIN_PORT_FIX &bsol;* cast (int) */
721                  if (rioWriteBulkCount(r,'*',2+((PORT_LONG)cmd_items)*2) == 0) return 0;  WIN_PORT_FIX &bsol;* cast (PORT_LONG) */
722                  if (rioWriteBulkString(r,"ZADD",4) == 0) return 0;
723                  if (rioWriteBulkObject(r,key) == 0) return 0;
724              }
725              if (rioWriteBulkDouble(r,score) == 0) return 0;
726              if (vstr != NULL) {
727                  if (rioWriteBulkString(r,(char*)vstr,vlen) == 0) return 0;
728              } else {
729                  if (rioWriteBulkLongLong(r,vll) == 0) return 0;
730              }
731              zzlNext(zl,&eptr,&sptr);
732              if (++count == AOF_REWRITE_ITEMS_PER_CMD) count = 0;
733              items--;
734          }
735      } else if (o->encoding == OBJ_ENCODING_SKIPLIST) {
736          zset *zs = o->ptr;
737          dictIterator *di = dictGetIterator(zs->dict);
738          dictEntry *de;
739          while((de = dictNext(di)) != NULL) {
740              sds ele = dictGetKey(de);
741              double *score = dictGetVal(de);
742              if (count == 0) {
743                  int cmd_items = (items > AOF_REWRITE_ITEMS_PER_CMD) ?
744                      AOF_REWRITE_ITEMS_PER_CMD : (int)items;               WIN_PORT_FIX &bsol;* cast (int) */
745                  if (rioWriteBulkCount(r,'*',2+((PORT_LONG)cmd_items)*2) == 0) return 0;  WIN_PORT_FIX &bsol;* cast (PORT_LONG) */
746                  if (rioWriteBulkString(r,"ZADD",4) == 0) return 0;
747                  if (rioWriteBulkObject(r,key) == 0) return 0;
748              }
749              if (rioWriteBulkDouble(r,*score) == 0) return 0;
750              if (rioWriteBulkString(r,ele,sdslen(ele)) == 0) return 0;
751              if (++count == AOF_REWRITE_ITEMS_PER_CMD) count = 0;
752              items--;
753          }
754          dictReleaseIterator(di);
755      } else {
756          serverPanic("Unknown sorted zset encoding");
757      }
758      return 1;
759  }
760  static int rioWriteHashIteratorCursor(rio *r, hashTypeIterator *hi, int what) {
761      if (hi->encoding == OBJ_ENCODING_ZIPLIST) {
762          unsigned char *vstr = NULL;
763          unsigned int vlen = UINT_MAX;
764          PORT_LONGLONG vll = LLONG_MAX;
765          hashTypeCurrentFromZiplist(hi, what, &vstr, &vlen, &vll);
766          if (vstr)
767              return (int)rioWriteBulkString(r, (char*)vstr, vlen);       WIN_PORT_FIX &bsol;* cast (int) */
768          else
769              return (int)rioWriteBulkLongLong(r, vll);                   WIN_PORT_FIX &bsol;* cast (int) */
770      } else if (hi->encoding == OBJ_ENCODING_HT) {
771          sds value = hashTypeCurrentFromHashTable(hi, what);
772          return (int)rioWriteBulkString(r, value, sdslen(value));        WIN_PORT_FIX &bsol;* cast (int) */
773      }
774      serverPanic("Unknown hash encoding");
775      return 0;
776  }
777  int rewriteHashObject(rio *r, robj *key, robj *o) {
778      hashTypeIterator *hi;
779      PORT_LONGLONG count = 0, items = hashTypeLength(o);
780      hi = hashTypeInitIterator(o);
781      while (hashTypeNext(hi) != C_ERR) {
782          if (count == 0) {
783              int cmd_items = (int) ((items > AOF_REWRITE_ITEMS_PER_CMD) ? WIN_PORT_FIX &bsol;* cast (int) */
784                  AOF_REWRITE_ITEMS_PER_CMD : items);
785              if (rioWriteBulkCount(r,'*',2+((PORT_LONG)cmd_items)*2) == 0) return 0;  WIN_PORT_FIX &bsol;* cast (PORT_LONG) */
786              if (rioWriteBulkString(r,"HMSET",5) == 0) return 0;
787              if (rioWriteBulkObject(r,key) == 0) return 0;
788          }
789          if (rioWriteHashIteratorCursor(r, hi, OBJ_HASH_KEY) == 0) return 0;
790          if (rioWriteHashIteratorCursor(r, hi, OBJ_HASH_VALUE) == 0) return 0;
791          if (++count == AOF_REWRITE_ITEMS_PER_CMD) count = 0;
792          items--;
793      }
794      hashTypeReleaseIterator(hi);
795      return 1;
796  }
797  int rioWriteBulkStreamID(rio *r,streamID *id) {
798      int retval;
799      sds replyid = sdscatfmt(sdsempty(),"%U-%U",id->ms,id->seq);
800      retval = rioWriteBulkString(r,replyid,sdslen(replyid));
801      sdsfree(replyid);
802      return retval;
803  }
804  int rioWriteStreamPendingEntry(rio *r, robj *key, const char *groupname, size_t groupname_len, streamConsumer *consumer, unsigned char *rawid, streamNACK *nack) {
805      streamID id;
806      streamDecodeID(rawid,&id);
807      if (rioWriteBulkCount(r,'*',12) == 0) return 0;
808      if (rioWriteBulkString(r,"XCLAIM",6) == 0) return 0;
809      if (rioWriteBulkObject(r,key) == 0) return 0;
810      if (rioWriteBulkString(r,groupname,groupname_len) == 0) return 0;
811      if (rioWriteBulkString(r,consumer->name,sdslen(consumer->name)) == 0) return 0;
812      if (rioWriteBulkString(r,"0",1) == 0) return 0;
813      if (rioWriteBulkStreamID(r,&id) == 0) return 0;
814      if (rioWriteBulkString(r,"TIME",4) == 0) return 0;
815      if (rioWriteBulkLongLong(r,nack->delivery_time) == 0) return 0;
816      if (rioWriteBulkString(r,"RETRYCOUNT",10) == 0) return 0;
817      if (rioWriteBulkLongLong(r,nack->delivery_count) == 0) return 0;
818      if (rioWriteBulkString(r,"JUSTID",6) == 0) return 0;
819      if (rioWriteBulkString(r,"FORCE",5) == 0) return 0;
820      return 1;
821  }
822  int rewriteStreamObject(rio *r, robj *key, robj *o) {
823      stream *s = o->ptr;
824      streamIterator si;
825      streamIteratorStart(&si,s,NULL,NULL,0);
826      streamID id;
827      int64_t numfields;
828      if (s->length) {
829          while(streamIteratorGetID(&si,&id,&numfields)) {
830              if (rioWriteBulkCount(r,'*',3+numfields*2) == 0) return 0;
831              if (rioWriteBulkString(r,"XADD",4) == 0) return 0;
832              if (rioWriteBulkObject(r,key) == 0) return 0;
833              if (rioWriteBulkStreamID(r,&id) == 0) return 0;
834              while(numfields--) {
835                  unsigned char *field, *value;
836                  int64_t field_len, value_len;
837                  streamIteratorGetField(&si,&field,&value,&field_len,&value_len);
838                  if (rioWriteBulkString(r,(char*)field,field_len) == 0) return 0;
839                  if (rioWriteBulkString(r,(char*)value,value_len) == 0) return 0;
840              }
841          }
842      } else {
843          if (rioWriteBulkCount(r,'*',7) == 0) return 0;
844          if (rioWriteBulkString(r,"XADD",4) == 0) return 0;
845          if (rioWriteBulkObject(r,key) == 0) return 0;
846          if (rioWriteBulkString(r,"MAXLEN",6) == 0) return 0;
847          if (rioWriteBulkString(r,"0",1) == 0) return 0;
848          if (rioWriteBulkStreamID(r,&s->last_id) == 0) return 0;
849          if (rioWriteBulkString(r,"x",1) == 0) return 0;
850          if (rioWriteBulkString(r,"y",1) == 0) return 0;
851      }
852      if (rioWriteBulkCount(r,'*',3) == 0) return 0;
853      if (rioWriteBulkString(r,"XSETID",6) == 0) return 0;
854      if (rioWriteBulkObject(r,key) == 0) return 0;
855      if (rioWriteBulkStreamID(r,&s->last_id) == 0) return 0;
856      if (s->cgroups) {
857          raxIterator ri;
858          raxStart(&ri,s->cgroups);
859          raxSeek(&ri,"^",NULL,0);
860          while(raxNext(&ri)) {
861              streamCG *group = ri.data;
862              if (rioWriteBulkCount(r,'*',5) == 0) return 0;
863              if (rioWriteBulkString(r,"XGROUP",6) == 0) return 0;
864              if (rioWriteBulkString(r,"CREATE",6) == 0) return 0;
865              if (rioWriteBulkObject(r,key) == 0) return 0;
866              if (rioWriteBulkString(r,(char*)ri.key,ri.key_len) == 0) return 0;
867              if (rioWriteBulkStreamID(r,&group->last_id) == 0) return 0;
868              raxIterator ri_cons;
869              raxStart(&ri_cons,group->consumers);
870              raxSeek(&ri_cons,"^",NULL,0);
871              while(raxNext(&ri_cons)) {
872                  streamConsumer *consumer = ri_cons.data;
873                  raxIterator ri_pel;
874                  raxStart(&ri_pel,consumer->pel);
875                  raxSeek(&ri_pel,"^",NULL,0);
876                  while(raxNext(&ri_pel)) {
877                      streamNACK *nack = ri_pel.data;
878                      if (rioWriteStreamPendingEntry(r,key,(char*)ri.key,
879                                                     ri.key_len,consumer,
880                                                     ri_pel.key,nack) == 0)
881                      {
882                          return 0;
883                      }
884                  }
885                  raxStop(&ri_pel);
886              }
887              raxStop(&ri_cons);
888          }
889          raxStop(&ri);
890      }
891      streamIteratorStop(&si);
892      return 1;
893  }
894  int rewriteModuleObject(rio *r, robj *key, robj *o) {
895      RedisModuleIO io;
896      moduleValue *mv = o->ptr;
897      moduleType *mt = mv->type;
898      moduleInitIOContext(io,mt,r,key);
899      mt->aof_rewrite(&io,key,mv->value);
900      if (io.ctx) {
901          moduleFreeContext(io.ctx);
902          zfree(io.ctx);
903      }
904      return io.error ? 0 : 1;
905  }
906  ssize_t aofReadDiffFromParent(void) {
907  #ifndef _WIN32
908      char buf[65536]; &bsol;* Default pipe buffer size on most Linux systems. */
909  #else
910      char* buf = zmalloc(65536); 
911  #endif
912      ssize_t nread, total = 0;
913      while ((nread =
914              read(server.aof_pipe_read_data_from_parent,buf,IF_WIN32(65536,sizeof(buf)))) > 0) {
915          server.aof_child_diff = sdscatlen(server.aof_child_diff,buf,nread);
916          total += nread;
917      }
918  #ifdef _WIN32
919      zfree(buf);
920  #endif
921      return total;
922  }
923  int rewriteAppendOnlyFileRio(rio *aof) {
924      dictIterator *di = NULL;
925      dictEntry *de;
926      size_t processed = 0;
927      int j;
928      for (j = 0; j < server.dbnum; j++) {
929          char selectcmd[] = "*2\r\n$6\r\nSELECT\r\n";
930          redisDb *db = server.db+j;
931          dict *d = db->dict;
932          if (dictSize(d) == 0) continue;
933          di = dictGetSafeIterator(d);
934          if (rioWrite(aof,selectcmd,sizeof(selectcmd)-1) == 0) goto werr;
935          if (rioWriteBulkLongLong(aof,j) == 0) goto werr;
936          while((de = dictNext(di)) != NULL) {
937              sds keystr;
938              robj key, *o;
939              PORT_LONGLONG expiretime;
940              keystr = dictGetKey(de);
941              o = dictGetVal(de);
942              initStaticStringObject(key,keystr);
943              expiretime = getExpire(db,&key);
944              if (o->type == OBJ_STRING) {
945                  char cmd[]="*3\r\n$3\r\nSET\r\n";
946                  if (rioWrite(aof,cmd,sizeof(cmd)-1) == 0) goto werr;
947                  if (rioWriteBulkObject(aof,&key) == 0) goto werr;
948                  if (rioWriteBulkObject(aof,o) == 0) goto werr;
949              } else if (o->type == OBJ_LIST) {
950                  if (rewriteListObject(aof,&key,o) == 0) goto werr;
951              } else if (o->type == OBJ_SET) {
952                  if (rewriteSetObject(aof,&key,o) == 0) goto werr;
953              } else if (o->type == OBJ_ZSET) {
954                  if (rewriteSortedSetObject(aof,&key,o) == 0) goto werr;
955              } else if (o->type == OBJ_HASH) {
956                  if (rewriteHashObject(aof,&key,o) == 0) goto werr;
957              } else if (o->type == OBJ_STREAM) {
958                  if (rewriteStreamObject(aof,&key,o) == 0) goto werr;
959              } else if (o->type == OBJ_MODULE) {
960                  if (rewriteModuleObject(aof,&key,o) == 0) goto werr;
961              } else {
962                  serverPanic("Unknown object type");
963              }
964              if (expiretime != -1) {
965                  char cmd[]="*3\r\n$9\r\nPEXPIREAT\r\n";
966                  if (rioWrite(aof,cmd,sizeof(cmd)-1) == 0) goto werr;
967                  if (rioWriteBulkObject(aof,&key) == 0) goto werr;
968                  if (rioWriteBulkLongLong(aof,expiretime) == 0) goto werr;
969              }
970              if (aof->processed_bytes > processed+AOF_READ_DIFF_INTERVAL_BYTES) {
971                  processed = aof->processed_bytes;
972                  aofReadDiffFromParent();
973              }
974          }
975          dictReleaseIterator(di);
976          di = NULL;
977      }
978      return C_OK;
979  werr:
980      if (di) dictReleaseIterator(di);
981      return C_ERR;
982  }
983  int rewriteAppendOnlyFile(char *filename) {
984      rio aof;
985      FILE *fp;
986      char tmpfile[256];
987      char byte;
988      snprintf(tmpfile,256,"temp-rewriteaof-%d.aof", (int) getpid());
989      fp = fopen(tmpfile, IF_WIN32("wb", "w"));
990      if (!fp) {
991          serverLog(LL_WARNING, "Opening the temp file for AOF rewrite in rewriteAppendOnlyFile(): %s", IF_WIN32(wsa_strerror(errno), strerror(errno)));
992          return C_ERR;
993      }
994      server.aof_child_diff = sdsempty();
995      rioInitWithFile(&aof,fp);
996      if (server.aof_rewrite_incremental_fsync)
997          rioSetAutoSync(&aof,REDIS_AUTOSYNC_BYTES);
998      if (server.aof_use_rdb_preamble) {
999          int error;
1000          if (rdbSaveRio(&aof,&error,RDB_SAVE_AOF_PREAMBLE,NULL) == C_ERR) {
1001              errno = error;
1002              goto werr;
1003          }
1004      } else {
1005          if (rewriteAppendOnlyFileRio(&aof) == C_ERR) goto werr;
1006      }
1007      if (fflush(fp) == EOF) goto werr;
1008      if (fsync(fileno(fp)) == -1) goto werr;
1009      int nodata = 0;
1010      mstime_t start = mstime();
1011      while(mstime()-start < 1000 && nodata < 20) {
1012          if (aeWait(server.aof_pipe_read_data_from_parent, AE_READABLE, 1) <= 0)
1013          {
1014              nodata++;
1015              continue;
1016          }
1017          nodata = 0; &bsol;* Start counting from zero, we stop on N *contiguous*
1018                         timeouts. */
1019          aofReadDiffFromParent();
1020      }
1021      if (write(server.aof_pipe_write_ack_to_parent,"!",1) != 1) goto werr;
1022  #ifndef _WIN32
1023      if (anetNonBlock(NULL,server.aof_pipe_read_ack_from_parent) != ANET_OK)
1024          goto werr;
1025  #endif
1026      if (syncRead(server.aof_pipe_read_ack_from_parent,&byte,1,5000) != 1 ||
1027          byte != '!') goto werr;
1028      serverLog(LL_NOTICE,"Parent agreed to stop sending diffs. Finalizing AOF...");
1029      aofReadDiffFromParent();
1030      serverLog(LL_NOTICE,
1031          "Concatenating %.2f MB of AOF diff received from parent.",
1032          (double) (sdslen(server.aof_child_diff) / (1024*1024)));  WIN_PORT_FIX
1033      if (rioWrite(&aof,server.aof_child_diff,sdslen(server.aof_child_diff)) == 0)
1034          goto werr;
1035      if (fflush(fp) == EOF) goto werr;
1036      if (fsync(fileno(fp)) == -1) goto werr;
1037      if (fclose(fp) == EOF) goto werr;
1038      if (rename(tmpfile,filename) == -1) {
1039          serverLog(LL_WARNING,"Error moving temp append only file on the final destination: %s", IF_WIN32(wsa_strerror(errno), strerror(errno)));
1040          unlink(tmpfile);
1041          return C_ERR;
1042      }
1043      serverLog(LL_NOTICE,"SYNC append only file rewrite performed");
1044      return C_OK;
1045  werr:
1046      serverLog(LL_WARNING,"Write error writing append only file on disk: %s", IF_WIN32(wsa_strerror(errno), strerror(errno)));
1047      fclose(fp);
1048      unlink(tmpfile);
1049      return C_ERR;
1050  }
1051  void aofChildPipeReadable(aeEventLoop *el, int fd, void *privdata, int mask) {
1052      char byte;
1053      UNUSED(el);
1054      UNUSED(privdata);
1055      UNUSED(mask);
1056      if (read(fd,&byte,1) == 1 && byte == '!') {
1057          serverLog(LL_NOTICE,"AOF rewrite child asks to stop sending diffs.");
1058          server.aof_stop_sending_diff = 1;
1059          if (write(server.aof_pipe_write_ack_to_child,"!",1) != 1) {
1060              serverLog(LL_WARNING,"Can't send ACK to AOF child: %s",
1061                  IF_WIN32(wsa_strerror(errno), strerror(errno)));
1062          }
1063      }
1064  #ifndef _WIN32
1065      aeDeleteFileEvent(server.el,server.aof_pipe_read_ack_from_child,AE_READABLE);
1066  #endif
1067  }
1068  int aofCreatePipes(void) {
1069      int fds[6] = {-1, -1, -1, -1, -1, -1};
1070      int j;
1071      if (pipe(fds) == -1) goto error; &bsol;* parent -> children data. */
1072      if (pipe(fds+2) == -1) goto error; &bsol;* children -> parent ack. */
1073      if (pipe(fds+4) == -1) goto error; &bsol;* parent -> children ack. */
1074  #ifndef WIN32
1075      if (anetNonBlock(NULL,fds[0]) != ANET_OK) goto error;
1076      if (anetNonBlock(NULL,fds[1]) != ANET_OK) goto error;
1077      if (aeCreateFileEvent(server.el, fds[2], AE_READABLE, aofChildPipeReadable, NULL) == AE_ERR) goto error;
1078  #else
1079      if (FDAPI_PipeSetNonBlock(fds[0], 1) != 0) goto error;
1080      if (FDAPI_PipeSetNonBlock(fds[1], 1) != 0) goto error;
1081      if (FDAPI_PipeSetNonBlock(fds[2], 1) != 0) goto error;
1082  #endif
1083      server.aof_pipe_write_data_to_child = fds[1];
1084      server.aof_pipe_read_data_from_parent = fds[0];
1085      server.aof_pipe_write_ack_to_parent = fds[3];
1086      server.aof_pipe_read_ack_from_child = fds[2];
1087      server.aof_pipe_write_ack_to_child = fds[5];
1088      server.aof_pipe_read_ack_from_parent = fds[4];
1089      server.aof_stop_sending_diff = 0;
1090      return C_OK;
1091  error:
1092      serverLog(LL_WARNING,"Error opening /setting AOF rewrite IPC pipes: %s",
1093          IF_WIN32(wsa_strerror(errno), strerror(errno)));
1094      for (j = 0; j < 6; j++) if(fds[j] != -1) close(fds[j]);
1095      return C_ERR;
1096  }
1097  void aofClosePipes(void) {
1098      aeDeleteFileEvent(server.el,server.aof_pipe_read_ack_from_child,AE_READABLE);
1099      aeDeleteFileEvent(server.el,server.aof_pipe_write_data_to_child,AE_WRITABLE);
1100      close(server.aof_pipe_write_data_to_child);
1101      close(server.aof_pipe_read_data_from_parent);
1102      close(server.aof_pipe_write_ack_to_parent);
1103      close(server.aof_pipe_read_ack_from_child);
1104      close(server.aof_pipe_write_ack_to_child);
1105      close(server.aof_pipe_read_ack_from_parent);
1106  }
1107  int rewriteAppendOnlyFileBackground(void) {
1108      pid_t childpid;
1109      PORT_LONGLONG start;
1110      if (server.aof_child_pid != -1 || server.rdb_child_pid != -1) return C_ERR;
1111      if (aofCreatePipes() != C_OK) return C_ERR;
1112      openChildInfoPipe();
1113      start = ustime();
1114  #ifndef _WIN32
1115      if ((childpid = fork()) == 0) {
1116  #endif
1117          char tmpfile[256];
1118  #ifndef _WIN32
1119          closeListeningSockets(0);
1120          redisSetProcTitle("redis-aof-rewrite");
1121  #endif
1122          snprintf(tmpfile,256,"temp-rewriteaof-bg-%d.aof", (int) getpid());
1123  #ifdef _WIN32
1124          childpid = BeginForkOperation_Aof(server.aof_pipe_write_ack_to_parent,
1125              server.aof_pipe_read_ack_from_parent,
1126              server.aof_pipe_read_data_from_parent,
1127              tmpfile,
1128              &server,
1129              sizeof(server),
1130              dictGetHashFunctionSeed(),
1131              modules);
1132  #else
1133          if (rewriteAppendOnlyFile(tmpfile) == C_OK) {
1134              size_t private_dirty = zmalloc_get_private_dirty(-1);
1135              if (private_dirty) {
1136                  serverLog(LL_NOTICE,
1137                      "AOF rewrite: %Iu MB of memory used by copy-on-write", WIN_PORT_FIX &bsol;* %zu -> %Iu */
1138                      private_dirty/(1024*1024));
1139              }
1140              server.child_info_data.cow_size = private_dirty;
1141              sendChildInfo(CHILD_INFO_TYPE_AOF);
1142              exitFromChild(0);
1143          } else {
1144              exitFromChild(1);
1145          }
1146      } else {
1147  #endif
1148          server.stat_fork_time = ustime()-start;
1149  #ifdef _WIN32
1150          if (server.stat_fork_time == 0) {
1151              server.stat_fork_time = 100000; 
1152          }
1153  #endif
1154          server.stat_fork_rate = (double)(zmalloc_used_memory() * 1000000 / server.stat_fork_time / (1024 * 1024 * 1024)); &bsol;* GB per second. */  WIN_PORT_FIX
1155          latencyAddSampleIfNeeded("fork",server.stat_fork_time/1000);
1156          if (childpid == -1) {
1157              closeChildInfoPipe();
1158              serverLog(LL_WARNING,
1159                  "Can't rewrite append only file in background: fork: %s",
1160                  IF_WIN32(wsa_strerror(errno), strerror(errno)));
1161              aofClosePipes();
1162              return C_ERR;
1163          }
1164          serverLog(LL_NOTICE,
1165              "Background append only file rewriting started by pid %d",childpid);
1166          server.aof_rewrite_scheduled = 0;
1167          server.aof_rewrite_time_start = time(NULL);
1168          server.aof_child_pid = childpid;
1169          updateDictResizePolicy();
1170          server.aof_selected_db = -1;
1171          replicationScriptCacheFlush();
1172          return C_OK;
1173  #ifndef _WIN32
1174      }
1175  #endif
1176      return C_OK; &bsol;* unreached */
1177  }
1178  void bgrewriteaofCommand(client *c) {
1179      if (server.aof_child_pid != -1) {
1180          addReplyError(c,"Background append only file rewriting already in progress");
1181      } else if (server.rdb_child_pid != -1) {
1182          server.aof_rewrite_scheduled = 1;
1183          addReplyStatus(c,"Background append only file rewriting scheduled");
1184      } else if (rewriteAppendOnlyFileBackground() == C_OK) {
1185          addReplyStatus(c,"Background append only file rewriting started");
1186      } else {
1187          addReply(c,shared.err);
1188      }
1189  }
1190  void aofRemoveTempFile(pid_t childpid) {
1191      char tmpfile[256];
1192      snprintf(tmpfile,256,"temp-rewriteaof-bg-%d.aof", (int) childpid);
1193      WIN32_ONLY(tmpfile[sizeof(tmpfile) - 1] = 0;) &bsol;*get rid of C6053 warning*/
1194      unlink(tmpfile);
1195  }
1196  void aofUpdateCurrentSize(void) {
1197      struct redis_stat sb;
1198      mstime_t latency;
1199  #ifdef _WIN32
1200      if (server.aof_fd == -1) {
1201          serverLog(LL_NOTICE, "Unable to check the AOF length: %s", "appendfd is -1");
1202          return;
1203      }
1204  #endif
1205      latencyStartMonitor(latency);
1206      if (redis_fstat(server.aof_fd,&sb) == -1) {
1207          serverLog(LL_WARNING,"Unable to obtain the AOF file length. stat: %s",
1208              IF_WIN32(wsa_strerror(errno), strerror(errno)));
1209      } else {
1210          server.aof_current_size = sb.st_size;
1211      }
1212      latencyEndMonitor(latency);
1213      latencyAddSampleIfNeeded("aof-fstat",latency);
1214  }
1215  void backgroundRewriteDoneHandler(int exitcode, int bysignal) {
1216      if (!bysignal && exitcode == 0) {
1217          int newfd, oldfd;
1218          char tmpfile[256];
1219          PORT_LONGLONG now = ustime();
1220          mstime_t latency;
1221          serverLog(LL_NOTICE,
1222              "Background AOF rewrite terminated with success");
1223          latencyStartMonitor(latency);
1224  #ifdef _WIN32
1225          snprintf(tmpfile,256,"temp-rewriteaof-bg-%d.aof",
1226              getpid());
1227          newfd = open(tmpfile,O_WRONLY|O_APPEND|O_CREAT|_O_BINARY,_S_IREAD|_S_IWRITE);
1228  #else
1229          snprintf(tmpfile,256,"temp-rewriteaof-bg-%d.aof",
1230              (int)server.aof_child_pid);
1231          newfd = open(tmpfile,O_WRONLY|O_APPEND);
1232  #endif
1233          if (newfd == -1) {
1234              serverLog(LL_WARNING,
1235                  "Unable to open the temporary AOF produced by the child: %s", IF_WIN32(wsa_strerror(errno), strerror(errno)));
1236              goto cleanup;
1237          }
1238          if (aofRewriteBufferWrite(newfd) == -1) {
1239              serverLog(LL_WARNING,
1240                  "Error trying to flush the parent diff to the rewritten AOF: %s", IF_WIN32(wsa_strerror(errno), strerror(errno)));
1241              close(newfd);
1242              goto cleanup;
1243          }
1244          latencyEndMonitor(latency);
1245          latencyAddSampleIfNeeded("aof-rewrite-diff-write",latency);
1246          serverLog(LL_NOTICE,
1247              "Residual parent diff successfully flushed to the rewritten AOF (%.2f MB)", (double) (aofRewriteBufferSize() / (1024*1024)));  WIN_PORT_FIX
1248  #ifdef _WIN32
1249          oldfd = -1; &bsol;* We'll set this to the current AOF filedes later. */
1250          char tmpfile_win_old[256];
1251          snprintf(tmpfile_win_old, 256, "temp-rewriteaof-old-%d.aof",
1252              (int) server.aof_child_pid);
1253          if (server.aof_fd != -1) {
1254              close(server.aof_fd);
1255              if (rename(server.aof_filename, tmpfile_win_old) == -1) {
1256                  serverLog(LL_WARNING,
1257                      "Error trying to rename the existing AOF to old tempfile: %s", IF_WIN32(wsa_strerror(errno), strerror(errno)));
1258                  unlink(tmpfile_win_old);
1259                  goto cleanup;
1260              }
1261          }
1262          latencyStartMonitor(latency);
1263          close(newfd);
1264          if (rename(tmpfile, server.aof_filename) == -1) {
1265              serverLog(LL_WARNING,
1266                  "Error trying to rename the temporary AOF file %s into %s: %s",
1267                  tmpfile,
1268                  server.aof_filename,
1269                  IF_WIN32(wsa_strerror(errno), strerror(errno)));
1270              if (server.aof_fd != -1) {
1271                  if (rename(tmpfile_win_old, server.aof_filename) == -1) {
1272                      serverLog(LL_WARNING,
1273                          "Error trying to rename the old tempfile %s into the existing AOF file %s: %s",
1274                          tmpfile,
1275                          server.aof_filename,
1276                          IF_WIN32(wsa_strerror(errno), strerror(errno)));
1277                      serverLog(LL_WARNING,
1278                          "Error trying to rename the existing AOF from old tempfile: %s", IF_WIN32(wsa_strerror(errno), strerror(errno)));
1279                  }
1280              }
1281              goto cleanup;
1282          }
1283          newfd = open(server.aof_filename, O_WRONLY | O_APPEND | _O_BINARY, 0);
1284          if (newfd == -1) {
1285              serverLog(LL_WARNING, "Not able to reopen the temporary AOF file after rename");
1286              goto cleanup;
1287          }
1288          if (server.aof_fd != -1) {
1289              server.aof_fd = open(
1290                  tmpfile_win_old,
1291                  O_WRONLY | O_APPEND | O_CREAT | _O_BINARY | _O_TEMPORARY,     
1292                  0644);
1293          }
1294  #else
1295          if (server.aof_fd == -1) {
1296              oldfd = open(server.aof_filename,O_RDONLY|O_NONBLOCK);
1297          } else {
1298              oldfd = -1; &bsol;* We'll set this to the current AOF filedes later. */
1299          }
1300          latencyStartMonitor(latency);
1301          if (rename(tmpfile,server.aof_filename) == -1) {
1302              serverLog(LL_WARNING,
1303                  "Error trying to rename the temporary AOF file %s into %s: %s",
1304                  tmpfile,
1305                  server.aof_filename,
1306                  strerror(errno));
1307              close(newfd);
1308              if (oldfd != -1) close(oldfd);
1309              goto cleanup;
1310          }
1311  #endif
1312          latencyEndMonitor(latency);
1313          latencyAddSampleIfNeeded("aof-rename",latency);
1314          if (server.aof_fd == -1) {
1315              close(newfd);
1316          } else {
1317              oldfd = server.aof_fd;
1318              server.aof_fd = newfd;
1319              if (server.aof_fsync == AOF_FSYNC_ALWAYS)
1320                  redis_fsync(newfd);
1321              else if (server.aof_fsync == AOF_FSYNC_EVERYSEC)
1322                  aof_background_fsync(newfd);
1323              server.aof_selected_db = -1; &bsol;* Make sure SELECT is re-issued */
1324              aofUpdateCurrentSize();
1325              server.aof_rewrite_base_size = server.aof_current_size;
1326              server.aof_fsync_offset = server.aof_current_size;
1327              sdsfree(server.aof_buf);
1328              server.aof_buf = sdsempty();
1329          }
1330          server.aof_lastbgrewrite_status = C_OK;
1331          serverLog(LL_NOTICE, "Background AOF rewrite finished successfully");
1332          if (server.aof_state == AOF_WAIT_REWRITE)
1333              server.aof_state = AOF_ON;
1334          if (oldfd != -1) bioCreateBackgroundJob(BIO_CLOSE_FILE,(void*)(long)oldfd,NULL,NULL);
1335          serverLog(LL_VERBOSE,
1336              "Background AOF rewrite signal handler took %lldus", ustime()-now);
1337      } else if (!bysignal && exitcode != 0) {
1338          server.aof_lastbgrewrite_status = C_ERR;
1339          serverLog(LL_WARNING,
1340              "Background AOF rewrite terminated with error");
1341      } else {
1342          if (bysignal != SIGUSR1)
1343              server.aof_lastbgrewrite_status = C_ERR;
1344          serverLog(LL_WARNING,
1345              "Background AOF rewrite terminated by signal %d", bysignal);
1346      }
1347  cleanup:
1348      aofClosePipes();
1349      aofRewriteBufferReset();
1350      aofRemoveTempFile(IF_WIN32(getpid(), server.aof_child_pid));
1351      server.aof_child_pid = -1;
1352      server.aof_rewrite_time_last = time(NULL)-server.aof_rewrite_time_start;
1353      server.aof_rewrite_time_start = -1;
1354      if (server.aof_state == AOF_WAIT_REWRITE)
1355          server.aof_rewrite_scheduled = 1;
1356  }
1357  #ifdef _WIN32
1358  void aofProcessDiffRewriteEvents(aeEventLoop* eventLoop)
1359  {
1360      if (server.aof_child_pid != -1 && server.aof_pipe_read_ack_from_child != -1) {
1361          if (server.aof_stop_sending_diff == 0) {
1362              aofChildWriteDiffData(eventLoop,server.aof_pipe_write_data_to_child,NULL,0);
1363          }
1364          if (server.aof_stop_sending_diff == 0) {
1365              aofChildPipeReadable(eventLoop,server.aof_pipe_read_ack_from_child,NULL,0);
1366          }
1367      }
1368  }
1369  #endif
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from redis-MDEwOlJlcG9zaXRvcnkxMDgxMTA3MDY=-flat-networking.c</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from redis-MDEwOlJlcG9zaXRvcnkxMDgxMTA3MDY=-flat-aof.c</div>
                </div>
                <div class="column column_space"><pre><code>92      c->reply = listCreate();
93      c->reply_bytes = 0;
94      c->obuf_soft_limit_reached_time = 0;
95      listSetFreeMethod(c->reply,freeClientReplyValue);
</pre></code></div>
                <div class="column column_space"><pre><code>435      c->querybuf = sdsempty();
436      c->querybuf_peak = 0;
437      c->argc = 0;
438      c->argv = NULL;
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    