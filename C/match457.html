<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for format_dispatch.c &amp; conver_dispatch.c</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for format_dispatch.c &amp; conver_dispatch.c
      </h3>
<h1 align="center">
        40.9%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>format_dispatch.c (78.16092%)<th>conver_dispatch.c (27.717392%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(307-349)<td><a href="#" name="0">(624-694)</a><td align="center"><font color="#ff0000">30</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(128-182)<td><a href="#" name="1">(340-396)</a><td align="center"><font color="#ff0000">30</font>
<tr onclick='openModal("#980517")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#980517"><font color="#980517">-</font><td><a href="#" name="2">(247-286)<td><a href="#" name="2">(818-864)</a><td align="center"><font color="#b20000">21</font>
<tr onclick='openModal("#53858b")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#53858b"><font color="#53858b">-</font><td><a href="#" name="3">(195-234)<td><a href="#" name="3">(569-617)</a><td align="center"><font color="#b20000">21</font>
<tr onclick='openModal("#6cc417")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#6cc417"><font color="#6cc417">-</font><td><a href="#" name="4">(422-461)<td><a href="#" name="4">(123-153)</a><td align="center"><font color="#880000">16</font>
<tr onclick='openModal("#151b8d")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#151b8d"><font color="#151b8d">-</font><td><a href="#" name="5">(47-70)<td><a href="#" name="5">(48-72)</a><td align="center"><font color="#880000">16</font>
<tr onclick='openModal("#8c8774")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#8c8774"><font color="#8c8774">-</font><td><a href="#" name="6">(73-95)<td><a href="#" name="6">(165-198)</a><td align="center"><font color="#7f0000">15</font>
<tr onclick='openModal("#38a4a5")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#38a4a5"><font color="#38a4a5">-</font><td><a href="#" name="7">(376-396)<td><a href="#" name="7">(868-897)</a><td align="center"><font color="#770000">14</font>
<tr onclick='openModal("#c58917")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#c58917"><font color="#c58917">-</font><td><a href="#" name="8">(351-372)<td><a href="#" name="8">(397-426)</a><td align="center"><font color="#770000">14</font>
<tr onclick='openModal("#83a33a")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#83a33a"><font color="#83a33a">-</font><td><a href="#" name="9">(102-122)<td><a href="#" name="9">(94-118)</a><td align="center"><font color="#770000">14</font>
<tr onclick='openModal("#ad5910")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#ad5910"><font color="#ad5910">-</font><td><a href="#" name="10">(399-418)<td><a href="#" name="10">(205-235)</a><td align="center"><font color="#6e0000">13</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>format_dispatch.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 #ifdef HAVE_CONFIG_H
2 #include &lt;config.h&gt;
3 #include &lt;vips/intl.h&gt;
4 #include &lt;stdio.h&gt;
5 #include &lt;vips/vips.h&gt;
6 #include &lt;vips/vips7compat.h&gt;
7 static int
8 jpeg2vips_vec( im_object *argv )
9 {
10 <a name="5"></a>	char *in = argv[0];
11 	IMAGE *out = argv[1];
12 <font color="#151b8d"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>	if( im_jpeg2vips( in, out ) )
13 		return( -1 );
14 	return( 0 );
15 }
16 static im_arg_desc jpeg2vips_args[] = {
17 	IM_INPUT_STRING( "in" ),
18 	IM_OUTPUT_IMAGE( "out" )
19 };
20 static im_function jpeg2vips_desc = {
21 	"im_jpeg2vips",				"convert from jpeg",			0,					jpeg2vips_vec,				IM_NUMBER( jpeg2vips_args ), 		jpeg2vips_args 			};
22 static int
23 vips2dz_vec( im_object *argv )
24 {
25 <a name="6"></a>	IMAGE *in = argv[0];</b></font>
26 	char *out = argv[1];
27 <font color="#8c8774"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>	if( im_vips2dz( in, out ) )
28 		return( -1 );
29 	return( 0 );
30 }
31 static im_arg_desc vips2dz_args[] = {
32 	IM_INPUT_IMAGE( "in" ),
33 	IM_INPUT_STRING( "out" )
34 };
35 static im_function vips2dz_desc = {
36 	"im_vips2dz",				"save as deepzoom",			0,					vips2dz_vec,				IM_NUMBER( vips2dz_args ), 		vips2dz_args 			};
37 static int
38 vips2jpeg_vec( im_object *argv )
39 {</b></font>
40 	IMAGE *in = argv[0];
41 	char *out = argv[1];
42 <a name="9"></a>	if( im_vips2jpeg( in, out ) )
43 		return( -1 );
44 <font color="#83a33a"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>	return( 0 );
45 }
46 static im_arg_desc vips2jpeg_args[] = {
47 	IM_INPUT_IMAGE( "in" ),
48 	IM_INPUT_STRING( "out" )
49 };
50 static im_function vips2jpeg_desc = {
51 	"im_vips2jpeg",				"convert to jpeg",			0,					vips2jpeg_vec,				IM_NUMBER( vips2jpeg_args ), 		vips2jpeg_args 			};
52 static int
53 vips2mimejpeg_vec( im_object *argv )
54 {
55 	IMAGE *in = argv[0];</b></font>
56 	int qfac = *((int *) argv[1]);
57 <a name="1"></a>	if( im_vips2mimejpeg( in, qfac ) )
58 		return( -1 );
59 <font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>	return( 0 );
60 }
61 static im_arg_desc vips2mimejpeg_args[] = {
62 	IM_INPUT_IMAGE( "in" ),
63 	IM_INPUT_INT( "qfac" )
64 };
65 static im_function vips2mimejpeg_desc = {
66 	"im_vips2mimejpeg",			"convert to jpeg as mime type on stdout", 	0,					vips2mimejpeg_vec,			IM_NUMBER( vips2mimejpeg_args ), 	vips2mimejpeg_args 		};
67 static im_arg_desc vips2png_args[] = {
68 	IM_INPUT_IMAGE( "in" ),
69 	IM_INPUT_STRING( "out" )
70 };
71 static int
72 vips2png_vec( im_object *argv )
73 {
74 	return( im_vips2png( argv[0], argv[1] ) );
75 }
76 static im_function vips2png_desc = {
77 	"im_vips2png", 				"convert VIPS image to PNG file", 	0,
78 	vips2png_vec, 				IM_NUMBER( vips2png_args ), 		vips2png_args 			};
79 static im_arg_desc png2vips_args[] = {
80 	IM_INPUT_STRING( "in" ),
81 	IM_OUTPUT_IMAGE( "out" )
82 };
83 static int
84 png2vips_vec( im_object *argv )
85 {</b></font>
86 	return( im_png2vips( argv[0], argv[1] ) );
87 }
88 static im_function png2vips_desc = {
89 	"im_png2vips", 				"convert PNG file to VIPS image", 	0,
90 <a name="3"></a>	png2vips_vec, 				IM_NUMBER( png2vips_args ), 		png2vips_args 			<font color="#53858b"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>};
91 static im_arg_desc exr2vips_args[] = {
92 	IM_INPUT_STRING( "in" ),
93 	IM_OUTPUT_IMAGE( "out" )
94 };
95 static int
96 exr2vips_vec( im_object *argv )
97 {
98 	return( im_exr2vips( argv[0], argv[1] ) );
99 }
100 static im_function exr2vips_desc = {
101 	"im_exr2vips", 				"convert an OpenEXR file to VIPS", 	0,
102 	exr2vips_vec, 				IM_NUMBER( exr2vips_args ), 		exr2vips_args 			};
103 static im_arg_desc vips2tiff_args[] = {
104 	IM_INPUT_IMAGE( "in" ),
105 	IM_INPUT_STRING( "out" )
106 };
107 static int
108 vips2tiff_vec( im_object *argv )
109 {</b></font>
110 	return( im_vips2tiff( argv[0], argv[1] ) );
111 }
112 static im_function vips2tiff_desc = {
113 	"im_vips2tiff", 			"convert VIPS image to TIFF file", 	0,
114 <a name="2"></a>	vips2tiff_vec, 				IM_NUMBER( vips2tiff_args ), 		vips2tiff_args 			<font color="#980517"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>};
115 static im_arg_desc magick2vips_args[] = {
116 	IM_INPUT_STRING( "in" ),
117 	IM_OUTPUT_IMAGE( "out" )
118 };
119 static int
120 magick2vips_vec( im_object *argv )
121 {
122 	return( im_magick2vips( argv[0], argv[1] ) );
123 }
124 static im_function magick2vips_desc = {
125 	"im_magick2vips", 			"load file with libMagick", 		0,
126 	magick2vips_vec, 			IM_NUMBER( magick2vips_args ), 		magick2vips_args 		};
127 static im_arg_desc tiff2vips_args[] = {
128 	IM_INPUT_STRING( "in" ),
129 	IM_OUTPUT_IMAGE( "out" )
130 };
131 static int
132 tiff2vips_vec( im_object *argv )
133 {</b></font>
134 	return( im_tiff2vips( argv[0], argv[1] ) );
135 }
136 static im_function tiff2vips_desc = {
137 	"im_tiff2vips", 			"convert TIFF file to VIPS image", 	0,
138 	tiff2vips_vec, 				IM_NUMBER( tiff2vips_args ), 		tiff2vips_args 			};
139 static int
140 analyze2vips_vec( im_object *argv )
141 {
142 <a name="0"></a>        const char *in = argv[0];
143         IMAGE *out = argv[1];
144 <font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>        return( im_analyze2vips( in, out ) );
145 }
146 static im_arg_desc analyze2vips_arg_types[] = {
147         IM_INPUT_STRING( "filename" ),
148         IM_OUTPUT_IMAGE( "im" )
149 };
150 static im_function analyze2vips_desc = {
151         "im_analyze2vips",          	        "read a file in analyze format",        0,                             	        analyze2vips_vec,                       IM_NUMBER( analyze2vips_arg_types ),        analyze2vips_arg_types          };
152 static int
153 csv2vips_vec( im_object *argv )
154 {
155         const char *in = argv[0];
156         IMAGE *out = argv[1];
157         return( im_csv2vips( in, out ) );
158 }
159 static im_arg_desc csv2vips_arg_types[] = {
160         IM_INPUT_STRING( "filename" ),
161         IM_OUTPUT_IMAGE( "im" )
162 };
163 static im_function csv2vips_desc = {
164         "im_csv2vips",          	        "read a file in csv format",        0,                             	        csv2vips_vec,                       IM_NUMBER( csv2vips_arg_types ),        csv2vips_arg_types          };
165 static int
166 <a name="8"></a>vips2csv_vec( im_object *argv )
167 {</b></font>
168         IMAGE *in = argv[0];
169 <font color="#c58917"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>        const char *filename = argv[1];
170         return( im_vips2csv( in, filename ) );
171 }
172 static im_arg_desc vips2csv_arg_types[] = {
173         IM_INPUT_IMAGE( "in" ),
174         IM_INPUT_STRING( "filename" )
175 };
176 static im_function vips2csv_desc = {
177         "im_vips2csv",          	        "write an image in csv format",	        0,                          	        vips2csv_vec,               	        IM_NUMBER( vips2csv_arg_types ),        vips2csv_arg_types          	};
178 static int
179 ppm2vips_vec( im_object *argv )
180 {</b></font>
181 <a name="7"></a>        const char *in = argv[0];
182         IMAGE *out = argv[1];
183 <font color="#38a4a5"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>        return( im_ppm2vips( in, out ) );
184 }
185 static im_arg_desc ppm2vips_arg_types[] = {
186         IM_INPUT_STRING( "filename" ),
187         IM_OUTPUT_IMAGE( "im" )
188 };
189 static im_function ppm2vips_desc = {
190         "im_ppm2vips",                          "read a file in pbm/pgm/ppm format",             0,                                      ppm2vips_vec,                  	        IM_NUMBER( ppm2vips_arg_types ),        ppm2vips_arg_types              };
191 static int
192 vips2ppm_vec( im_object *argv )
193 {
194 <a name="10"></a>        IMAGE *im = argv[0];</b></font>
195         const char *filename = argv[1];
196 <font color="#ad5910"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>        return( im_vips2ppm( im, filename ) );
197 }
198 static im_arg_desc vips2ppm_arg_types[] = {
199         IM_INPUT_IMAGE( "im" ),
200         IM_INPUT_STRING( "filename" )
201 };
202 static im_function vips2ppm_desc = {
203         "im_vips2ppm",                          "write a file in pbm/pgm/ppm format",             0,                                      vips2ppm_vec,                  	        IM_NUMBER( vips2ppm_arg_types ),        vips2ppm_arg_types              };
204 static int
205 fits2vips_vec( im_object *argv )
206 {</b></font>
207 <a name="4"></a>	char *in = argv[0];
208 	IMAGE *out = argv[1];
209 <font color="#6cc417"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>	if( im_fits2vips( in, out ) )
210 		return( -1 );
211 	return( 0 );
212 }
213 static im_arg_desc fits2vips_args[] = {
214 	IM_INPUT_STRING( "in" ),
215 	IM_OUTPUT_IMAGE( "out" )
216 };
217 static im_function fits2vips_desc = {
218 	"im_fits2vips",				"convert from fits",			0,					fits2vips_vec,				IM_NUMBER( fits2vips_args ), 		fits2vips_args 			};
219 static im_function *list[] = {
220 	&amp;csv2vips_desc,
221 	&amp;fits2vips_desc,
222 	&amp;jpeg2vips_desc,
223 	&amp;magick2vips_desc,
224 	&amp;png2vips_desc,
225 	&amp;exr2vips_desc,
226 	&amp;ppm2vips_desc,
227 	&amp;analyze2vips_desc,
228 	&amp;tiff2vips_desc,
229 	&amp;vips2csv_desc,
230 	&amp;vips2dz_desc,
231 	&amp;vips2jpeg_desc,
232 	&amp;vips2mimejpeg_desc,
233 	&amp;vips2png_desc,
234 	&amp;vips2ppm_desc,
235 	&amp;vips2tiff_desc
236 };</b></font>
237 im_package im__format = {
238 	"format",
239 	IM_NUMBER( list ),
240 	list
241 };
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>conver_dispatch.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 #ifdef HAVE_CONFIG_H
2 #include &lt;config.h&gt;
3 #include &lt;vips/intl.h&gt;
4 #include &lt;vips/vips.h&gt;
5 #include &lt;vips/vips7compat.h&gt;
6 static int
7 system_vec( im_object *argv )
8 {
9 	IMAGE *in = argv[0];
10 <a name="5"></a>	char *cmd = argv[1];
11 	char **out = (char **) &amp;argv[2];
12 <font color="#151b8d"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>	if( im_system( in, cmd, out ) )
13 		return( -1 );
14 	return( 0 );
15 }
16 static im_arg_desc system_args[] = {
17 	IM_INPUT_IMAGE( "im" ),
18 	IM_INPUT_STRING( "command" ),
19 	IM_OUTPUT_STRING( "output" )
20 };
21 static im_function system_desc = {
22 	"im_system",				"run command on image",			0,					system_vec, 				IM_NUMBER( system_args ),		system_args 			};
23 static int
24 system_image_vec( im_object *argv )
25 {
26 	IMAGE *in = argv[0];</b></font>
27 	IMAGE *out = argv[1];
28 	char *in_format = argv[2];
29 	char *out_format = argv[3];
30 	char *cmd = argv[4];
31 	char **log = (char **) &amp;argv[5];
32 	IMAGE *out_image;
33 	if( !(out_image = im_system_image( in, 
34 		in_format, out_format, cmd, log )) ) {
35 		im_error( "im_system_image", "%s", *log );
36 		return( -1 );
37 	}
38 	if( im_copy( out_image, out ) ||
39 		im_add_close_callback( out, 
40 			(im_callback_fn) im_close, out_image, NULL ) ) {
41 		im_close( out_image );
42 <a name="9"></a>		return( -1 );
43 	}
44 <font color="#83a33a"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>	return( 0 );
45 }
46 static im_arg_desc system_image_args[] = {
47 	IM_INPUT_IMAGE( "in" ),
48 	IM_OUTPUT_IMAGE( "out" ),
49 	IM_INPUT_STRING( "in_format" ),
50 	IM_INPUT_STRING( "out_format" ),
51 	IM_INPUT_STRING( "command" ),
52 	IM_OUTPUT_STRING( "log" )
53 };
54 static im_function system_image_desc = {
55 	"im_system_image",			"run command on image, with image output",	0,					system_image_vec, 			IM_NUMBER( system_image_args ),		system_image_args 		};
56 static int
57 subsample_vec( im_object *argv )
58 {
59 	IMAGE *in = argv[0];</b></font>
60 	IMAGE *out = argv[1];
61 <a name="4"></a>	int xsh = *((int *) argv[2]);
62 	int ysh = *((int *) argv[3]);
63 <font color="#6cc417"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>	if( im_subsample( in, out, xsh, ysh ) )
64 		return( -1 );
65 	return( 0 );
66 }
67 static im_arg_desc subsample_args[] = {
68 	IM_INPUT_IMAGE( "in" ),
69 	IM_OUTPUT_IMAGE( "out" ),
70 	IM_INPUT_INT( "xshrink" ),
71 	IM_INPUT_INT( "yshrink" )
72 };
73 static im_function subsample_desc = {
74 	"im_subsample",				"subsample image by integer factors",		IM_FN_PIO,				subsample_vec,				IM_NUMBER( subsample_args ), 		subsample_args 			};
75 static im_arg_desc gaussnoise_args[] = {
76 	IM_OUTPUT_IMAGE( "out" ),
77 	IM_INPUT_INT( "xsize" ),
78 	IM_INPUT_INT( "ysize" ),
79 	IM_INPUT_DOUBLE( "mean" ),
80 	IM_INPUT_DOUBLE( "sigma" )
81 };</b></font>
82 static int
83 gaussnoise_vec( im_object *argv )
84 {
85 	int xsize = *((int *) argv[1]);
86 	int ysize = *((int *) argv[2]);
87 <a name="6"></a>	double mean = *((double *) argv[3]);
88 	double sigma = *((double *) argv[4]);
89 <font color="#8c8774"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>	if( im_gaussnoise( argv[0], xsize, ysize, mean, sigma ) )
90 		return( -1 );
91 	return( 0 );
92 }
93 static im_function gaussnoise_desc = {
94 	"im_gaussnoise", 			"generate image of gaussian noise with specified statistics",
95 	IM_FN_PIO | IM_FN_NOCACHE,		gaussnoise_vec, 			IM_NUMBER( gaussnoise_args ), 		gaussnoise_args 		};
96 static im_arg_desc extract_args[] = {
97 	IM_INPUT_IMAGE( "input" ),
98 	IM_OUTPUT_IMAGE( "output" ),
99 	IM_INPUT_INT( "left" ),
100 	IM_INPUT_INT( "top" ),
101 	IM_INPUT_INT( "width" ),
102 	IM_INPUT_INT( "height" ),
103 	IM_INPUT_INT( "band" )
104 };
105 static int
106 extract_vec( im_object *argv )
107 {</b></font>
108 	int left = *((int *) argv[2]);
109 	int top = *((int *) argv[3]);
110 	int width = *((int *) argv[4]);
111 <a name="10"></a>	int height = *((int *) argv[5]);
112 	int band = *((int *) argv[6]);
113 <font color="#ad5910"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>	return( im_extract_areabands( argv[0], argv[1], 
114 		left, top, width, height, band, 1 ) );
115 }
116 static im_function extract_desc = {
117 	"im_extract", 				"extract area/band",			IM_FN_TRANSFORM | IM_FN_PIO,		extract_vec, 				IM_NUMBER( extract_args ), 		extract_args 			};
118 static im_arg_desc extract_area_args[] = {
119 	IM_INPUT_IMAGE( "input" ),
120 	IM_OUTPUT_IMAGE( "output" ),
121 	IM_INPUT_INT( "left" ),
122 	IM_INPUT_INT( "top" ),
123 	IM_INPUT_INT( "width" ),
124 	IM_INPUT_INT( "height" )
125 };
126 static int
127 extract_area_vec( im_object *argv )
128 {</b></font>
129 	int x = *((int *) argv[2]);
130 	int y = *((int *) argv[3]);
131 	int w = *((int *) argv[4]);
132 	int h = *((int *) argv[5]);
133 	return( im_extract_area( argv[0], argv[1], x, y, w, h ) );
134 }
135 static im_function extract_area_desc = {
136 	"im_extract_area", 			"extract area",				IM_FN_TRANSFORM | IM_FN_PIO,		extract_area_vec, 			IM_NUMBER( extract_area_args ), 	extract_area_args 		};
137 static im_arg_desc extract_bands_args[] = {
138 	IM_INPUT_IMAGE( "input" ),
139 	IM_OUTPUT_IMAGE( "output" ),
140 	IM_INPUT_INT( "band" ),
141 	IM_INPUT_INT( "nbands" ),
142 };
143 static int
144 extract_bands_vec( im_object *argv )
145 {
146 	int chsel = *((int *) argv[2]);
147 	int nbands = *((int *) argv[3]);
148 	return( im_extract_bands( argv[0], argv[1], chsel, nbands ) );
149 }
150 static im_function extract_bands_desc = {
151 	"im_extract_bands", 			"extract several bands",		IM_FN_PIO,				extract_bands_vec, 			IM_NUMBER( extract_bands_args ),	extract_bands_args 		};
152 static im_arg_desc extract_band_args[] = {
153 	IM_INPUT_IMAGE( "input" ),
154 	IM_OUTPUT_IMAGE( "output" ),
155 	IM_INPUT_INT( "band" )
156 };
157 static int
158 extract_band_vec( im_object *argv )
159 {
160 	int chsel = *((int *) argv[2]);
161 	return( im_extract_band( argv[0], argv[1], chsel ) );
162 }
163 static im_function extract_band_desc = {
164 	"im_extract_band", 			"extract band",				IM_FN_PIO,				extract_band_vec, 			IM_NUMBER( extract_band_args ), 	extract_band_args 		};
165 static im_arg_desc extract_areabands_args[] = {
166 	IM_INPUT_IMAGE( "input" ),
167 	IM_OUTPUT_IMAGE( "output" ),
168 	IM_INPUT_INT( "left" ),
169 	IM_INPUT_INT( "top" ),
170 	IM_INPUT_INT( "width" ),
171 	IM_INPUT_INT( "height" ),
172 	IM_INPUT_INT( "band" ),
173 	IM_INPUT_INT( "nbands" )
174 };
175 static int
176 extract_areabands_vec( im_object *argv )
177 {
178 	int left = *((int *) argv[2]);
179 	int top = *((int *) argv[3]);
180 	int width = *((int *) argv[4]);
181 	int height = *((int *) argv[5]);
182 <a name="1"></a>	int band = *((int *) argv[6]);
183 	int nbands = *((int *) argv[7]);
184 <font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>	return( im_extract_areabands( argv[0], argv[1],
185 		left, top, width, height, band, nbands ) );
186 }
187 static im_function extract_areabands_desc = {
188 	"im_extract_areabands",         	"extract area and bands",       	IM_FN_TRANSFORM | IM_FN_PIO,		extract_areabands_vec,          	IM_NUMBER( extract_areabands_args ),	extract_areabands_args          };
189 static im_arg_desc one_in_one_out[] = {
190 	IM_INPUT_IMAGE( "in" ),
191 	IM_OUTPUT_IMAGE( "out" )
192 };
193 static im_arg_desc two_in_one_out[] = {
194 	IM_INPUT_IMAGE( "in1" ),
195 	IM_INPUT_IMAGE( "in2" ),
196 	IM_OUTPUT_IMAGE( "out" )
197 };
198 static int
199 bandjoin_vec( im_object *argv )
200 {
201 	return( im_bandjoin( argv[0], argv[1], argv[2] ) );
202 }
203 static im_function bandjoin_desc = {
204 	"im_bandjoin", 				"bandwise join of two images",		IM_FN_PIO,				bandjoin_vec, 				IM_NUMBER( two_in_one_out ), 		two_in_one_out 			};
205 static im_arg_desc gbandjoin_args[] = {
206 	IM_INPUT_IMAGEVEC( "in" ),
207 	IM_OUTPUT_IMAGE( "out" )
208 };
209 <a name="8"></a>static int
210 gbandjoin_vec( im_object *argv )
211 {</b></font>
212 <font color="#c58917"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>	im_imagevec_object *iv = (im_imagevec_object *) argv[0];
213 	return( im_gbandjoin( iv-&gt;vec, argv[1], iv-&gt;n ) );
214 }
215 static im_function gbandjoin_desc = {
216 	"im_gbandjoin", 			"bandwise join of many images",		IM_FN_PIO,				gbandjoin_vec, 				IM_NUMBER( gbandjoin_args ), 		gbandjoin_args 			};
217 static im_arg_desc text_args[] = {
218 	IM_OUTPUT_IMAGE( "out" ),
219 	IM_INPUT_STRING( "text" ),
220 	IM_INPUT_STRING( "font" ),
221 	IM_INPUT_INT( "width" ),
222 	IM_INPUT_INT( "alignment" ),
223 	IM_INPUT_INT( "dpi" )
224 };
225 static int
226 text_vec( im_object *argv )
227 {</b></font>
228 	int width = *((int *) argv[3]);
229 	int alignment = *((int *) argv[4]);
230 	int dpi = *((int *) argv[5]);
231 	return( im_text( argv[0], argv[1], argv[2], width, alignment, dpi ) );
232 }
233 static im_function text_desc = {
234 	"im_text", 				"generate text image",			IM_FN_PIO,				text_vec, 				IM_NUMBER( text_args ), 		text_args 			};
235 static im_arg_desc black_args[] = {
236 	IM_OUTPUT_IMAGE( "output" ),
237 	IM_INPUT_INT( "x_size" ),
238 	IM_INPUT_INT( "y_size" ),
239 	IM_INPUT_INT( "bands" )
240 };
241 static int
242 black_vec( im_object *argv )
243 {
244 	int xs = *((int *) argv[1]);
245 	int ys = *((int *) argv[2]);
246 	int bands = *((int *) argv[3]);
247 	return( im_black( argv[0], xs, ys, bands ) );
248 }
249 static im_function black_desc = {
250 	"im_black", 				"generate black image",			IM_FN_PIO,				black_vec, 				IM_NUMBER( black_args ), 		black_args 			};
251 static im_arg_desc clip2fmt_args[] = {
252 	IM_INPUT_IMAGE( "in" ),
253 	IM_OUTPUT_IMAGE( "out" ),
254 	IM_INPUT_INT( "ofmt" )
255 };
256 static int
257 clip2fmt_vec( im_object *argv )
258 {
259 	int ofmt = *((int *) argv[2]);
260 	return( im_clip2fmt( argv[0], argv[1], ofmt ) );
261 }
262 static im_function clip2fmt_desc = {
263 	"im_clip2fmt", 				"convert image format to ofmt",		IM_FN_PIO | IM_FN_PTOP,			clip2fmt_vec, 				IM_NUMBER( clip2fmt_args ),		clip2fmt_args 			};
264 static int
265 c2rect_vec( im_object *argv )
266 {
267 	return( im_c2rect( argv[0], argv[1] ) );
268 }
269 static im_function c2rect_desc = {
270 	"im_c2rect", 				"convert phase and amplitude to real and imaginary",
271 	IM_FN_PTOP | IM_FN_PIO,			c2rect_vec, 				IM_NUMBER( one_in_one_out ), 		one_in_one_out 			};
272 static int
273 c2amph_vec( im_object *argv )
274 {
275 	return( im_c2amph( argv[0], argv[1] ) );
276 }
277 static im_function c2amph_desc = {
278 	"im_c2amph", 				"convert real and imaginary to phase and amplitude",
279 	IM_FN_PTOP | IM_FN_PIO,			c2amph_vec, 				IM_NUMBER( one_in_one_out ), 		one_in_one_out 			};
280 static int
281 ri2c_vec( im_object *argv )
282 {
283 	return( im_ri2c( argv[0], argv[1], argv[2] ) );
284 }
285 static im_function ri2c_desc = {
286 	"im_ri2c", 				"join two non-complex images to form complex",
287 	IM_FN_PTOP | IM_FN_PIO,			ri2c_vec, 				IM_NUMBER( two_in_one_out ), 		two_in_one_out 			};
288 static int
289 <a name="3"></a>c2imag_vec( im_object *argv )
290 {
291 	return( im_c2imag( argv[0], argv[1] ) );
292 <font color="#53858b"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>}
293 static im_function c2imag_desc = {
294 	"im_c2imag", 				"extract imaginary part of complex image",
295 	IM_FN_PTOP | IM_FN_PIO,			c2imag_vec, 				IM_NUMBER( one_in_one_out ), 		one_in_one_out 			};
296 static int
297 c2real_vec( im_object *argv )
298 {
299 	return( im_c2real( argv[0], argv[1] ) );
300 }
301 static im_function c2real_desc = {
302 	"im_c2real", 				"extract real part of complex image",
303 	IM_FN_PTOP | IM_FN_PIO,			c2real_vec, 				IM_NUMBER( one_in_one_out ), 		one_in_one_out 			};
304 static im_arg_desc copy_set_args[] = {
305 	IM_INPUT_IMAGE( "input" ),
306 	IM_OUTPUT_IMAGE( "output" ),
307 	IM_INPUT_INT( "Type" ),
308 	IM_INPUT_DOUBLE( "Xres" ),
309 	IM_INPUT_DOUBLE( "Yres" ),
310 	IM_INPUT_INT( "Xoffset" ),
311 	IM_INPUT_INT( "Yoffset" )
312 };
313 static int
314 copy_set_vec( im_object *argv )
315 {</b></font>
316 	int Type = *((int *) argv[2]);
317 	float Xres = *((double *) argv[3]);
318 	float Yres = *((double *) argv[4]);
319 <a name="0"></a>	int Xoffset = *((int *) argv[5]);
320 	int Yoffset = *((int *) argv[6]);
321 <font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>	return( im_copy_set( argv[0], argv[1],
322 		Type, Xres, Yres, Xoffset, Yoffset ) );
323 }
324 static im_function copy_set_desc = {
325 	"im_copy_set", 				"copy image, setting informational fields",
326 	IM_FN_PIO,			
327 	copy_set_vec, 				IM_NUMBER( copy_set_args ), 		copy_set_args 			};
328 static im_arg_desc copy_set_meta_args[] = {
329 	IM_INPUT_IMAGE( "input" ),
330 	IM_OUTPUT_IMAGE( "output" ),
331 	IM_INPUT_STRING( "field" ),
332 	IM_INPUT_GVALUE( "value" )
333 };
334 static int
335 copy_set_meta_vec( im_object *argv )
336 {
337 	const char *field = argv[2];
338 	GValue *value = argv[3];
339 	return( im_copy_set_meta( argv[0], argv[1], field, value ) ); 
340 }
341 static im_function copy_set_meta_desc = {
342 	"im_copy_set_meta", 			"copy image, setting a meta field",
343 	IM_FN_PIO,			
344 	copy_set_meta_vec, 			IM_NUMBER( copy_set_meta_args ),	copy_set_meta_args 		};
345 static im_arg_desc copy_morph_args[] = {
346 	IM_INPUT_IMAGE( "input" ),
347 	IM_OUTPUT_IMAGE( "output" ),
348 	IM_INPUT_INT( "Bands" ),
349 	IM_INPUT_INT( "BandFmt" ),
350 	IM_INPUT_INT( "Coding" )
351 };
352 static int
353 copy_morph_vec( im_object *argv )
354 {</b></font>
355 	int Bands = *((int *) argv[2]);
356 	int BandFmt = *((int *) argv[3]);
357 	int Coding = *((int *) argv[4]);
358 	return( im_copy_morph( argv[0], argv[1],
359 		Bands, BandFmt, Coding ) );
360 }
361 static im_function copy_morph_desc = {
362 	"im_copy_morph", 				"copy image, setting pixel layout",
363 	IM_FN_PIO,			
364 	copy_morph_vec, 			IM_NUMBER( copy_morph_args ), 		copy_morph_args 		};
365 static int
366 copy_vec( im_object *argv )
367 {
368 	return( im_copy( argv[0], argv[1] ) );
369 }
370 static im_function copy_desc = {
371 	"im_copy", 				"copy image",
372 	IM_FN_PIO | IM_FN_NOCACHE,
373 	copy_vec, 				IM_NUMBER( one_in_one_out ), 		one_in_one_out 			};
374 static int
375 copy_file_vec( im_object *argv )
376 {
377 	return( im_copy_file( argv[0], argv[1] ) );
378 }
379 static im_function copy_file_desc = {
380 	"im_copy_file", 				"copy image to a file and return that",
381 	IM_FN_PIO,			
382 	copy_file_vec, 				IM_NUMBER( one_in_one_out ), 		one_in_one_out 			};
383 static int
384 copy_swap_vec( im_object *argv )
385 {
386 	return( im_copy_swap( argv[0], argv[1] ) );
387 }
388 static im_function copy_swap_desc = {
389 	"im_copy_swap", 				"copy image, swapping byte order",
390 	IM_FN_PIO,			
391 	copy_swap_vec, 				IM_NUMBER( one_in_one_out ), 		one_in_one_out 			};
392 static int
393 fliphor_vec( im_object *argv )
394 {
395 	return( im_fliphor( argv[0], argv[1] ) );
396 }
397 static im_function fliphor_desc = {
398 	"im_fliphor", 				"flip image left-right",
399 	IM_FN_PIO,				fliphor_vec, 				IM_NUMBER( one_in_one_out ), 		one_in_one_out 			};
400 static int
401 <a name="2"></a>flipver_vec( im_object *argv )
402 {
403 	return( im_flipver( argv[0], argv[1] ) );
404 <font color="#980517"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>}
405 static im_function flipver_desc = {
406 	"im_flipver", 				"flip image top-bottom",
407 	IM_FN_PIO,				flipver_vec, 				IM_NUMBER( one_in_one_out ), 		one_in_one_out 			};
408 static int
409 falsecolour_vec( im_object *argv )
410 {
411 	return( im_falsecolour( argv[0], argv[1] ) );
412 }
413 static im_function falsecolour_desc = {
414 	"im_falsecolour", 			"turn luminance changes into chrominance changes",
415 	IM_FN_PTOP | IM_FN_PIO,			falsecolour_vec, 			IM_NUMBER( one_in_one_out ), 		one_in_one_out 			};
416 static im_arg_desc insert_args[] = {
417 	IM_INPUT_IMAGE( "in" ),
418 	IM_INPUT_IMAGE( "sub" ),
419 	IM_OUTPUT_IMAGE( "out" ),
420 	IM_INPUT_INT( "x" ),
421 	IM_INPUT_INT( "y" )
422 };
423 static int
424 insert_vec( im_object *argv )
425 {</b></font>
426 <a name="7"></a>	int x = *((int *) argv[3]);
427 	int y = *((int *) argv[4]);
428 <font color="#38a4a5"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>	return( im_insert( argv[0], argv[1], argv[2], x, y ) );
429 }
430 static im_function insert_desc = {
431 	"im_insert", 				"insert sub-image into main image at position",
432 	IM_FN_PIO | IM_FN_TRANSFORM,		insert_vec, 				IM_NUMBER( insert_args ), 		insert_args 			};
433 static im_arg_desc insertset_args[] = {
434 	IM_INPUT_IMAGE( "main" ),
435 	IM_INPUT_IMAGE( "sub" ),
436 	IM_OUTPUT_IMAGE( "out" ),
437 	IM_INPUT_INTVEC( "x" ),
438 	IM_INPUT_INTVEC( "y" )
439 };
440 static int
441 insertset_vec( im_object *argv )
442 {
443 	im_intvec_object *xv = (im_intvec_object *) argv[3];</b></font>
444 	im_intvec_object *yv = (im_intvec_object *) argv[4];
445 	if( xv-&gt;n != yv-&gt;n ) {
446 		im_error( "im_insertset", "%s", 
447 			_( "vectors not same length" ) );
448 		return( -1 );
449 	}
450 	if( im_insertset( argv[0], argv[1], argv[2], xv-&gt;n, xv-&gt;vec, yv-&gt;vec ) )
451 		return( -1 );
452 	return( 0 );
453 }
454 static im_function insertset_desc = {
455 	"im_insertset", 			"insert sub into main at every position in x, y",
456 	0,					insertset_vec, 				IM_NUMBER( insertset_args ), 		insertset_args 			};
457 static int
458 insert_noexpand_vec( im_object *argv )
459 {
460 	int x = *((int *) argv[3]);
461 	int y = *((int *) argv[4]);
462 	return( im_insert_noexpand( argv[0], argv[1], argv[2], x, y ) );
463 }
464 static im_function insert_noexpand_desc = {
465 	"im_insert_noexpand", 			"insert sub-image into main image at position, no expansion",
466 	IM_FN_PIO | IM_FN_TRANSFORM,		insert_noexpand_vec, 			IM_NUMBER( insert_args ),		insert_args 			};
467 static int
468 rot180_vec( im_object *argv )
469 {
470 	return( im_rot180( argv[0], argv[1] ) );
471 }
472 static im_function rot180_desc = {
473 	"im_rot180", 				"rotate image 180 degrees",
474 	IM_FN_PIO | IM_FN_TRANSFORM,		rot180_vec, 				IM_NUMBER( one_in_one_out ), 		one_in_one_out 			};
475 static int
476 rot90_vec( im_object *argv )
477 {
478 	return( im_rot90( argv[0], argv[1] ) );
479 }
480 static im_function rot90_desc = {
481 	"im_rot90", 				"rotate image 90 degrees clockwise",
482 	IM_FN_PIO | IM_FN_TRANSFORM,		rot90_vec, 				IM_NUMBER( one_in_one_out ), 		one_in_one_out 			};
483 static int
484 rot270_vec( im_object *argv )
485 {
486 	return( im_rot270( argv[0], argv[1] ) );
487 }
488 static im_function rot270_desc = {
489 	"im_rot270", 				"rotate image 270 degrees clockwise",
490 	IM_FN_PIO | IM_FN_TRANSFORM,		rot270_vec, 				IM_NUMBER( one_in_one_out ), 		one_in_one_out 			};
491 static int
492 lrjoin_vec( im_object *argv )
493 {
494 	return( im_lrjoin( argv[0], argv[1], argv[2] ) );
495 }
496 static im_function lrjoin_desc = {
497 	"im_lrjoin", 				"join two images left-right",
498 	IM_FN_PIO | IM_FN_TRANSFORM,		lrjoin_vec, 				IM_NUMBER( two_in_one_out ), 		two_in_one_out 			};
499 static int
500 tbjoin_vec( im_object *argv )
501 {
502 	return( im_tbjoin( argv[0], argv[1], argv[2] ) );
503 }
504 static im_function tbjoin_desc = {
505 	"im_tbjoin", 				"join two images top-bottom",
506 	IM_FN_PIO | IM_FN_TRANSFORM,		tbjoin_vec, 				IM_NUMBER( two_in_one_out ), 		two_in_one_out 			};
507 static int
508 scale_vec( im_object *argv )
509 {
510 	return( im_scale( argv[0], argv[1] ) );
511 }
512 static im_function scale_desc = {
513 	"im_scale", 				"scale image linearly to fit range 0-255",
514 	IM_FN_PIO,				scale_vec, 				IM_NUMBER( one_in_one_out ), 		one_in_one_out 			};
515 static int
516 scaleps_vec( im_object *argv )
517 {
518 	return( im_scaleps( argv[0], argv[1] ) );
519 }
520 static im_function scaleps_desc = {
521 	"im_scaleps", 				"logarithmic scale of image to fit range 0-255",
522 	0,					scaleps_vec, 				IM_NUMBER( one_in_one_out ), 		one_in_one_out 			};
523 static im_arg_desc grid_args[] = {
524 	IM_INPUT_IMAGE( "input" ),
525 	IM_OUTPUT_IMAGE( "output" ),
526 	IM_INPUT_INT( "tile_height" ),
527 	IM_INPUT_INT( "across" ),
528 	IM_INPUT_INT( "down" )
529 };
530 static int
531 grid_vec( im_object *argv )
532 {
533 	int tile_height = *((int *) argv[2]);
534 	int across = *((int *) argv[3]);
535 	int down = *((int *) argv[4]);
536 	return( im_grid( argv[0], argv[1], tile_height, across, down ) );
537 }
538 static im_function grid_desc = {
539 	"im_grid", 				"chop a tall thin image into a grid of images",
540 	IM_FN_TRANSFORM | IM_FN_PIO,		grid_vec, 				IM_NUMBER( grid_args ), 		grid_args 			};
541 static im_arg_desc replicate_args[] = {
542 	IM_INPUT_IMAGE( "input" ),
543 	IM_OUTPUT_IMAGE( "output" ),
544 	IM_INPUT_INT( "across" ),
545 	IM_INPUT_INT( "down" )
546 };
547 static int
548 replicate_vec( im_object *argv )
549 {
550 	int across = *((int *) argv[2]);
551 	int down = *((int *) argv[3]);
552 	return( im_replicate( argv[0], argv[1], across, down ) );
553 }
554 static im_function replicate_desc = {
555 	"im_replicate", 			"replicate an image horizontally and vertically",
556 	IM_FN_TRANSFORM | IM_FN_PIO,		replicate_vec, 				IM_NUMBER( replicate_args ), 		replicate_args 			};
557 static im_arg_desc zoom_args[] = {
558 	IM_INPUT_IMAGE( "input" ),
559 	IM_OUTPUT_IMAGE( "output" ),
560 	IM_INPUT_INT( "xfac" ),
561 	IM_INPUT_INT( "yfac" )
562 };
563 static int
564 zoom_vec( im_object *argv )
565 {
566 	int xfac = *((int *) argv[2]);
567 	int yfac = *((int *) argv[3]);
568 	return( im_zoom( argv[0], argv[1], xfac, yfac ) );
569 }
570 static im_function zoom_desc = {
571 	"im_zoom", 				"simple zoom of an image by integer factors",
572 	IM_FN_TRANSFORM | IM_FN_PIO,		zoom_vec, 				IM_NUMBER( zoom_args ),			zoom_args 			};
573 static int
574 msb_vec (im_object * argv)
575 {
576   return im_msb (argv[0], argv[1]);
577 }
578 static im_function msb_desc = {
579   "im_msb",			  "convert to uchar by discarding bits",
580   IM_FN_PIO | IM_FN_PTOP,	  msb_vec,			  IM_NUMBER (one_in_one_out),	  one_in_one_out		};
581 static im_arg_desc msb_band_args[] = {
582   IM_INPUT_IMAGE ("in"),
583   IM_OUTPUT_IMAGE ("out"),
584   IM_INPUT_INT ("band")
585 };
586 static int
587 msb_band_vec (im_object * argv)
588 {
589   IMAGE *in = (IMAGE *) argv[0];
590   IMAGE *out = (IMAGE *) argv[1];
591   int *band = (int *) argv[2];
592   return im_msb_band (in, out, *band);
593 }
594 static im_function msb_band_desc = {
595   "im_msb_band",		  "convert to single band uchar by discarding bits",
596   IM_FN_PIO | IM_FN_PTOP,	  msb_band_vec,			  IM_NUMBER (msb_band_args),	  msb_band_args			};
597 static im_arg_desc wrap_args[] = {
598 	IM_INPUT_IMAGE( "in" ),
599 	IM_OUTPUT_IMAGE( "out" ),
600 	IM_INPUT_INT( "x" ),
601 	IM_INPUT_INT( "y" )
602 };
603 static int
604 wrap_vec (im_object * argv)
605 {
606   return im_wrap( argv[0], argv[1], *(int*)argv[2], *(int*)argv[3] );
607 }
608 static im_function wrap_desc = {
609   "im_wrap",			  "shift image origin, wrapping at sides",
610   IM_FN_PIO | IM_FN_TRANSFORM,	  wrap_vec,			  IM_NUMBER (wrap_args),	  wrap_args			};
611 static im_arg_desc embed_args[] = {
612 	IM_INPUT_IMAGE( "in" ),
613 	IM_OUTPUT_IMAGE( "out" ),
614 	IM_INPUT_INT( "type" ),
615 	IM_INPUT_INT( "x" ),
616 	IM_INPUT_INT( "y" ),
617 	IM_INPUT_INT( "width" ),
618 	IM_INPUT_INT( "height" )
619 };
620 static int
621 embed_vec( im_object *argv )
622 {
623 	int type = *((int *) argv[2]);
624 	int x = *((int *) argv[3]);
625 	int y = *((int *) argv[4]);
626 	int width = *((int *) argv[5]);
627 	int height = *((int *) argv[6]);
628 	return( im_embed( argv[0], argv[1], type, x, y, width, height ) );
629 }
630 static im_function embed_desc = {
631 	"im_embed",	 			"embed in within a set of borders", 
632 	IM_FN_PIO | IM_FN_TRANSFORM,		embed_vec, 				IM_NUMBER( embed_args ), 		embed_args 			};
633 static im_function *conv_list[] = {
634 	&amp;gaussnoise_desc,
635 	&amp;bandjoin_desc,
636 	&amp;black_desc,
637 	&amp;c2amph_desc,
638 	&amp;c2imag_desc,
639 	&amp;c2real_desc,
640 	&amp;c2rect_desc,
641 	&amp;clip2fmt_desc,
642 	&amp;copy_desc,
643 	&amp;copy_file_desc,
644 	&amp;copy_morph_desc,
645 	&amp;copy_swap_desc,
646 	&amp;copy_set_desc,
647 	&amp;copy_set_meta_desc,
648 	&amp;extract_area_desc,
649 	&amp;extract_areabands_desc,
650 	&amp;extract_band_desc,
651 	&amp;extract_bands_desc,
652 	&amp;extract_desc,
653 	&amp;falsecolour_desc,
654 	&amp;fliphor_desc,
655 	&amp;flipver_desc,
656 	&amp;gbandjoin_desc,
657 	&amp;grid_desc,
658 	&amp;insert_desc,
659 	&amp;insertset_desc,
660 	&amp;insert_noexpand_desc,
661 	&amp;embed_desc,
662 	&amp;lrjoin_desc,
663         &amp;msb_desc,
664         &amp;msb_band_desc,
665 	&amp;replicate_desc,
666 	&amp;ri2c_desc,
667 	&amp;rot180_desc,
668 	&amp;rot270_desc,
669 	&amp;rot90_desc,
670 	&amp;scale_desc,
671 	&amp;scaleps_desc,
672 	&amp;subsample_desc,
673 	&amp;system_desc,
674 	&amp;system_image_desc,
675 	&amp;tbjoin_desc,
676 	&amp;text_desc,
677 	&amp;wrap_desc,
678 	&amp;zoom_desc
679 };
680 im_package im__conversion = {
681 	"conversion",
682 	IM_NUMBER( conv_list ),
683 	conv_list
684 };
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
