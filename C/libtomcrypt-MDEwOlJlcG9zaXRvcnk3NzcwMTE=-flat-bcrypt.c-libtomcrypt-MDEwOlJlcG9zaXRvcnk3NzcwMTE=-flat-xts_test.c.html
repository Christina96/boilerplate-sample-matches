
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 20.47244094488189%, Tokens: 8</h2>
        <div class="column">
            <h3>libtomcrypt-MDEwOlJlcG9zaXRvcnk3NzcwMTE=-flat-bcrypt.c</h3>
            <pre><code>1  #include "tomcrypt_private.h"
2  #ifdef LTC_BCRYPT
3  #define BCRYPT_WORDS 8
4  #define BCRYPT_HASHSIZE (BCRYPT_WORDS * 4)
5  static int s_bcrypt_hash(const unsigned char *pt,
6                          const unsigned char *pass, unsigned long passlen,
7                          const unsigned char *salt, unsigned long saltlen,
8                                unsigned char *out,  unsigned long *outlen)
9  {
10     symmetric_key key;
11     int err, n;
12     ulong32 ct[BCRYPT_WORDS];
13     if ((err = blowfish_setup_with_data(pass, passlen, salt, saltlen, &key)) != CRYPT_OK) {
14        return err;
15     }
16     for (n = 0; n < 64; ++n) {
17        if ((err = blowfish_expand(salt, saltlen, NULL, 0, &key)) != CRYPT_OK) {
18           return err;
19        }
20        if ((err = blowfish_expand(pass, passlen, NULL, 0, &key)) != CRYPT_OK) {
21           return err;
22        }
23     }
24     for (n = 0; n < BCRYPT_WORDS; ++n) {
25        LOAD32H(ct[n], &pt[n*4]);
26     }
27     for (n = 0; n < 64; ++n) {
28        blowfish_enc(ct, BCRYPT_WORDS/2, &key);
29     }
30     for (n = 0; n < BCRYPT_WORDS; ++n) {
31        STORE32L(ct[n], &out[4 * n]);
32     }
33     *outlen = sizeof(ct);
34  #ifdef LTC_CLEAN_STACK
35     zeromem(&key, sizeof(key));
36     zeromem(ct, sizeof(ct));
37  #endif
38     return CRYPT_OK;
39  }
40  static int s_bcrypt_pbkdf_hash(const unsigned char *pass, unsigned long passlen,
41                           const unsigned char *salt, unsigned long saltlen,
42                                 unsigned char *out,  unsigned long *outlen)
43  {
44     const unsigned char pt[] = "OxychromaticBlowfishSwatDynamite";
45     return s_bcrypt_hash(pt, pass, passlen, salt, saltlen, out, outlen);
46  }
<span onclick='openModal()' class='match'>47  int bcrypt_pbkdf_openbsd(const          void *secret, unsigned long secret_len,
48                           const unsigned char *salt,   unsigned long salt_len,
49                                 unsigned int  rounds,            int hash_idx,
</span>50                                 unsigned char *out,    unsigned long *outlen)
51  {
52     int err;
53     ulong32 blkno;
54     unsigned long left, itts, x, y, hashed_pass_len, step_size, steps, dest, used_rounds;
55     unsigned char *buf[3], blkbuf[4];
56     unsigned char *hashed_pass;
57     LTC_ARGCHK(secret != NULL);
58     LTC_ARGCHK(salt   != NULL);
59     LTC_ARGCHK(out    != NULL);
60     LTC_ARGCHK(outlen != NULL);
61     if ((secret_len == 0) || (salt_len == 0) || (*outlen == 0)) {
62        return CRYPT_INVALID_ARG;
63     }
64     if ((err = hash_is_valid(hash_idx)) != CRYPT_OK) {
65        return err;
66     }
67     if (rounds == 0) {
68        used_rounds = LTC_BCRYPT_DEFAULT_ROUNDS;
69     } else {
70        used_rounds = rounds;
71     }
72     buf[0]      = XMALLOC(MAXBLOCKSIZE * 3);
73     hashed_pass = XMALLOC(MAXBLOCKSIZE);
74     if (buf[0] == NULL || hashed_pass == NULL) {
75        if (hashed_pass != NULL) {
76           XFREE(hashed_pass);
77        }
78        if (buf[0] != NULL) {
79           XFREE(buf[0]);
80        }
81        return CRYPT_MEM;
82     }
83     buf[1] = buf[0] + MAXBLOCKSIZE;
84     buf[2] = buf[1] + MAXBLOCKSIZE;
85     step_size = (*outlen + BCRYPT_HASHSIZE - 1) / BCRYPT_HASHSIZE;
86     steps = (*outlen + step_size - 1) / step_size;
87     hashed_pass_len = MAXBLOCKSIZE;
88     if ((err = hash_memory(hash_idx, (unsigned char*)secret, secret_len, hashed_pass, &hashed_pass_len)) != CRYPT_OK) {
89        goto LBL_ERR;
90     }
91     left   = *outlen;
92     blkno  = 0;
93     while (left != 0) {
94         ++blkno;
95         STORE32H(blkno, blkbuf);
96         zeromem(buf[0], MAXBLOCKSIZE*2);
97         x = MAXBLOCKSIZE;
98         if ((err = hash_memory_multi(hash_idx, buf[0], &x,
99                                      salt, salt_len,
100                                      blkbuf, 4uL,
101                                      LTC_NULL)) != CRYPT_OK) {
102            goto LBL_ERR;
103         }
104         y = MAXBLOCKSIZE;
105         if ((err = s_bcrypt_pbkdf_hash(hashed_pass, hashed_pass_len, buf[0], x, buf[1], &y)) != CRYPT_OK) {
106            goto LBL_ERR;
107         }
108         XMEMCPY(buf[2], buf[1], y);
109         for (itts = 1; itts < used_rounds; ++itts) {
110            x = MAXBLOCKSIZE;
111            if ((err = hash_memory(hash_idx, buf[1], y, buf[0], &x)) != CRYPT_OK) {
112               goto LBL_ERR;
113            }
114            y = MAXBLOCKSIZE;
115            if ((err = s_bcrypt_pbkdf_hash(hashed_pass, hashed_pass_len, buf[0], x, buf[1], &y)) != CRYPT_OK) {
116               goto LBL_ERR;
117            }
118            for (x = 0; x < y; x++) {
119               buf[2][x] ^= buf[1][x];
120            }
121         }
122         steps = MIN(steps, left);
123         for (y = 0; y < steps; ++y) {
124            dest = y * step_size + (blkno - 1);
125            if (dest >= *outlen)
126               break;
127            out[dest] = buf[2][y];
128         }
129         left -= y;
130     }
131     err = CRYPT_OK;
132  LBL_ERR:
133  #ifdef LTC_CLEAN_STACK
134     zeromem(buf[0], MAXBLOCKSIZE*3);
135     zeromem(hashed_pass, MAXBLOCKSIZE);
136  #endif
137     XFREE(hashed_pass);
138     XFREE(buf[0]);
139     return err;
140  }
141  #endif
</code></pre>
        </div>
        <div class="column">
            <h3>libtomcrypt-MDEwOlJlcG9zaXRvcnk3NzcwMTE=-flat-xts_test.c</h3>
            <pre><code>1  #include "tomcrypt_private.h"
2  #ifdef LTC_XTS_MODE
3  #ifndef LTC_NO_TEST
4  static int s_xts_test_accel_xts_encrypt(const unsigned char *pt, unsigned char *ct, unsigned long blocks,
5                                         unsigned char *tweak, const symmetric_key *skey1, const symmetric_key *skey2)
6  {
7     int ret;
8     symmetric_xts xts;
9     int (*orig)(const unsigned char *, unsigned char *,
10                 unsigned long , unsigned char *,
11                 const symmetric_key *, const symmetric_key *);
12     if ((xts.cipher = find_cipher("aes")) == -1) {
13        if ((xts.cipher = find_cipher("rijndael")) == -1) {
14           return CRYPT_NOP;
15        }
16     }
17     orig = cipher_descriptor[xts.cipher].accel_xts_encrypt;
18     cipher_descriptor[xts.cipher].accel_xts_encrypt = NULL;
19     XMEMCPY(&xts.key1, skey1, sizeof(symmetric_key));
20     XMEMCPY(&xts.key2, skey2, sizeof(symmetric_key));
21     ret = xts_encrypt(pt, blocks << 4, ct, tweak, &xts);
22     cipher_descriptor[xts.cipher].accel_xts_encrypt = orig;
23     return ret;
24  }
25  static int s_xts_test_accel_xts_decrypt(const unsigned char *ct, unsigned char *pt, unsigned long blocks,
26                                         unsigned char *tweak, const symmetric_key *skey1, const symmetric_key *skey2)
27  {
28     int ret;
29     symmetric_xts xts;
<span onclick='openModal()' class='match'>30     int (*orig)(const unsigned char *, unsigned char *,
31                 unsigned long , unsigned char *,
</span>32                 const symmetric_key *, const symmetric_key *);
33     if ((xts.cipher = find_cipher("aes")) == -1) {
34        if ((xts.cipher = find_cipher("rijndael")) == -1) {
35           return CRYPT_NOP;
36        }
37     }
38     orig = cipher_descriptor[xts.cipher].accel_xts_decrypt;
39     cipher_descriptor[xts.cipher].accel_xts_decrypt = NULL;
40     XMEMCPY(&xts.key1, skey1, sizeof(symmetric_key));
41     XMEMCPY(&xts.key2, skey2, sizeof(symmetric_key));
42     ret = xts_decrypt(ct, blocks << 4, pt, tweak, &xts);
43     cipher_descriptor[xts.cipher].accel_xts_decrypt = orig;
44     return ret;
45  }
46  #endif
47  int xts_test(void)
48  {
49  #ifdef LTC_NO_TEST
50     return CRYPT_NOP;
51  #else
52     static const struct
53     {
54        int keylen;
55        unsigned char key1[32];
56        unsigned char key2[32];
57        ulong64 seqnum;
58        unsigned long PTLEN;
59        unsigned char PTX[512], CTX[512];
60     } tests[] = {
61  {
62     32,
63     { 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 },
64     { 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 },
65     0,
66     32,
67     { 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 },
68     { 0x91,0x7c,0xf6,0x9e,0xbd,0x68,0xb2,0xec,0x9b,0x9f,0xe9,0xa3,0xea,0xdd,0xa6,0x92,0xcd,0x43,0xd2,0xf5,0x95,0x98,0xed,0x85,0x8c,0x02,0xc2,0x65,0x2f,0xbf,0x92,0x2e },
69  },
70  {
71     32,
72     { 0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11 },
73     { 0x22,0x22,0x22,0x22,0x22,0x22,0x22,0x22,0x22,0x22,0x22,0x22,0x22,0x22,0x22,0x22 },
74     CONST64(0x3333333333),
75     32,
76     { 0x44,0x44,0x44,0x44,0x44,0x44,0x44,0x44,0x44,0x44,0x44,0x44,0x44,0x44,0x44,0x44,0x44,0x44,0x44,0x44,0x44,0x44,0x44,0x44,0x44,0x44,0x44,0x44,0x44,0x44,0x44,0x44 },
77     { 0xc4,0x54,0x18,0x5e,0x6a,0x16,0x93,0x6e,0x39,0x33,0x40,0x38,0xac,0xef,0x83,0x8b,0xfb,0x18,0x6f,0xff,0x74,0x80,0xad,0xc4,0x28,0x93,0x82,0xec,0xd6,0xd3,0x94,0xf0 },
78  },
79  {
80     32,
81     { 0xff,0xfe,0xfd,0xfc,0xfb,0xfa,0xf9,0xf8,0xf7,0xf6,0xf5,0xf4,0xf3,0xf2,0xf1,0xf0 },
82     { 0xbf,0xbe,0xbd,0xbc,0xbb,0xba,0xb9,0xb8,0xb7,0xb6,0xb5,0xb4,0xb3,0xb2,0xb1,0xb0 },
83     CONST64(0x123456789a),
84     32,
85     { 0x44,0x44,0x44,0x44,0x44,0x44,0x44,0x44,0x44,0x44,0x44,0x44,0x44,0x44,0x44,0x44,0x44,0x44,0x44,0x44,0x44,0x44,0x44,0x44,0x44,0x44,0x44,0x44,0x44,0x44,0x44,0x44 },
86     { 0xb0,0x1f,0x86,0xf8,0xed,0xc1,0x86,0x37,0x06,0xfa,0x8a,0x42,0x53,0xe3,0x4f,0x28,0xaf,0x31,0x9d,0xe3,0x83,0x34,0x87,0x0f,0x4d,0xd1,0xf9,0x4c,0xbe,0x98,0x32,0xf1 },
87  },
88  {
89     32,
90     { 0x27,0x18,0x28,0x18,0x28,0x45,0x90,0x45,0x23,0x53,0x60,0x28,0x74,0x71,0x35,0x26 },
91     { 0x31,0x41,0x59,0x26,0x53,0x58,0x97,0x93,0x23,0x84,0x62,0x64,0x33,0x83,0x27,0x95 },
92     0,
93     512,
94     {
95  0x00,0x01,0x02,0x03,0x04,0x05,0x06,0x07,0x08,0x09,0x0a,0x0b,0x0c,0x0d,0x0e,0x0f,0x10,0x11,0x12,0x13,0x14,0x15,0x16,0x17,0x18,0x19,0x1a,0x1b,0x1c,0x1d,0x1e,0x1f,
96  0x20,0x21,0x22,0x23,0x24,0x25,0x26,0x27,0x28,0x29,0x2a,0x2b,0x2c,0x2d,0x2e,0x2f,0x30,0x31,0x32,0x33,0x34,0x35,0x36,0x37,0x38,0x39,0x3a,0x3b,0x3c,0x3d,0x3e,0x3f,
97  0x40,0x41,0x42,0x43,0x44,0x45,0x46,0x47,0x48,0x49,0x4a,0x4b,0x4c,0x4d,0x4e,0x4f,0x50,0x51,0x52,0x53,0x54,0x55,0x56,0x57,0x58,0x59,0x5a,0x5b,0x5c,0x5d,0x5e,0x5f,
98  0x60,0x61,0x62,0x63,0x64,0x65,0x66,0x67,0x68,0x69,0x6a,0x6b,0x6c,0x6d,0x6e,0x6f,0x70,0x71,0x72,0x73,0x74,0x75,0x76,0x77,0x78,0x79,0x7a,0x7b,0x7c,0x7d,0x7e,0x7f,
99  0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8a,0x8b,0x8c,0x8d,0x8e,0x8f,0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9a,0x9b,0x9c,0x9d,0x9e,0x9f,
100  0xa0,0xa1,0xa2,0xa3,0xa4,0xa5,0xa6,0xa7,0xa8,0xa9,0xaa,0xab,0xac,0xad,0xae,0xaf,0xb0,0xb1,0xb2,0xb3,0xb4,0xb5,0xb6,0xb7,0xb8,0xb9,0xba,0xbb,0xbc,0xbd,0xbe,0xbf,
101  0xc0,0xc1,0xc2,0xc3,0xc4,0xc5,0xc6,0xc7,0xc8,0xc9,0xca,0xcb,0xcc,0xcd,0xce,0xcf,0xd0,0xd1,0xd2,0xd3,0xd4,0xd5,0xd6,0xd7,0xd8,0xd9,0xda,0xdb,0xdc,0xdd,0xde,0xdf,
102  0xe0,0xe1,0xe2,0xe3,0xe4,0xe5,0xe6,0xe7,0xe8,0xe9,0xea,0xeb,0xec,0xed,0xee,0xef,0xf0,0xf1,0xf2,0xf3,0xf4,0xf5,0xf6,0xf7,0xf8,0xf9,0xfa,0xfb,0xfc,0xfd,0xfe,0xff,
103  0x00,0x01,0x02,0x03,0x04,0x05,0x06,0x07,0x08,0x09,0x0a,0x0b,0x0c,0x0d,0x0e,0x0f,0x10,0x11,0x12,0x13,0x14,0x15,0x16,0x17,0x18,0x19,0x1a,0x1b,0x1c,0x1d,0x1e,0x1f,
104  0x20,0x21,0x22,0x23,0x24,0x25,0x26,0x27,0x28,0x29,0x2a,0x2b,0x2c,0x2d,0x2e,0x2f,0x30,0x31,0x32,0x33,0x34,0x35,0x36,0x37,0x38,0x39,0x3a,0x3b,0x3c,0x3d,0x3e,0x3f,
105  0x40,0x41,0x42,0x43,0x44,0x45,0x46,0x47,0x48,0x49,0x4a,0x4b,0x4c,0x4d,0x4e,0x4f,0x50,0x51,0x52,0x53,0x54,0x55,0x56,0x57,0x58,0x59,0x5a,0x5b,0x5c,0x5d,0x5e,0x5f,
106  0x60,0x61,0x62,0x63,0x64,0x65,0x66,0x67,0x68,0x69,0x6a,0x6b,0x6c,0x6d,0x6e,0x6f,0x70,0x71,0x72,0x73,0x74,0x75,0x76,0x77,0x78,0x79,0x7a,0x7b,0x7c,0x7d,0x7e,0x7f,
107  0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8a,0x8b,0x8c,0x8d,0x8e,0x8f,0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9a,0x9b,0x9c,0x9d,0x9e,0x9f,
108  0xa0,0xa1,0xa2,0xa3,0xa4,0xa5,0xa6,0xa7,0xa8,0xa9,0xaa,0xab,0xac,0xad,0xae,0xaf,0xb0,0xb1,0xb2,0xb3,0xb4,0xb5,0xb6,0xb7,0xb8,0xb9,0xba,0xbb,0xbc,0xbd,0xbe,0xbf,
109  0xc0,0xc1,0xc2,0xc3,0xc4,0xc5,0xc6,0xc7,0xc8,0xc9,0xca,0xcb,0xcc,0xcd,0xce,0xcf,0xd0,0xd1,0xd2,0xd3,0xd4,0xd5,0xd6,0xd7,0xd8,0xd9,0xda,0xdb,0xdc,0xdd,0xde,0xdf,
110  0xe0,0xe1,0xe2,0xe3,0xe4,0xe5,0xe6,0xe7,0xe8,0xe9,0xea,0xeb,0xec,0xed,0xee,0xef,0xf0,0xf1,0xf2,0xf3,0xf4,0xf5,0xf6,0xf7,0xf8,0xf9,0xfa,0xfb,0xfc,0xfd,0xfe,0xff,
111     },
112     {
113  0x27,0xa7,0x47,0x9b,0xef,0xa1,0xd4,0x76,0x48,0x9f,0x30,0x8c,0xd4,0xcf,0xa6,0xe2,0xa9,0x6e,0x4b,0xbe,0x32,0x08,0xff,0x25,0x28,0x7d,0xd3,0x81,0x96,0x16,0xe8,0x9c,
114  0xc7,0x8c,0xf7,0xf5,0xe5,0x43,0x44,0x5f,0x83,0x33,0xd8,0xfa,0x7f,0x56,0x00,0x00,0x05,0x27,0x9f,0xa5,0xd8,0xb5,0xe4,0xad,0x40,0xe7,0x36,0xdd,0xb4,0xd3,0x54,0x12,
115  0x32,0x80,0x63,0xfd,0x2a,0xab,0x53,0xe5,0xea,0x1e,0x0a,0x9f,0x33,0x25,0x00,0xa5,0xdf,0x94,0x87,0xd0,0x7a,0x5c,0x92,0xcc,0x51,0x2c,0x88,0x66,0xc7,0xe8,0x60,0xce,
116  0x93,0xfd,0xf1,0x66,0xa2,0x49,0x12,0xb4,0x22,0x97,0x61,0x46,0xae,0x20,0xce,0x84,0x6b,0xb7,0xdc,0x9b,0xa9,0x4a,0x76,0x7a,0xae,0xf2,0x0c,0x0d,0x61,0xad,0x02,0x65,
117  0x5e,0xa9,0x2d,0xc4,0xc4,0xe4,0x1a,0x89,0x52,0xc6,0x51,0xd3,0x31,0x74,0xbe,0x51,0xa1,0x0c,0x42,0x11,0x10,0xe6,0xd8,0x15,0x88,0xed,0xe8,0x21,0x03,0xa2,0x52,0xd8,
118  0xa7,0x50,0xe8,0x76,0x8d,0xef,0xff,0xed,0x91,0x22,0x81,0x0a,0xae,0xb9,0x9f,0x91,0x72,0xaf,0x82,0xb6,0x04,0xdc,0x4b,0x8e,0x51,0xbc,0xb0,0x82,0x35,0xa6,0xf4,0x34,
119  0x13,0x32,0xe4,0xca,0x60,0x48,0x2a,0x4b,0xa1,0xa0,0x3b,0x3e,0x65,0x00,0x8f,0xc5,0xda,0x76,0xb7,0x0b,0xf1,0x69,0x0d,0xb4,0xea,0xe2,0x9c,0x5f,0x1b,0xad,0xd0,0x3c,
120  0x5c,0xcf,0x2a,0x55,0xd7,0x05,0xdd,0xcd,0x86,0xd4,0x49,0x51,0x1c,0xeb,0x7e,0xc3,0x0b,0xf1,0x2b,0x1f,0xa3,0x5b,0x91,0x3f,0x9f,0x74,0x7a,0x8a,0xfd,0x1b,0x13,0x0e,
121  0x94,0xbf,0xf9,0x4e,0xff,0xd0,0x1a,0x91,0x73,0x5c,0xa1,0x72,0x6a,0xcd,0x0b,0x19,0x7c,0x4e,0x5b,0x03,0x39,0x36,0x97,0xe1,0x26,0x82,0x6f,0xb6,0xbb,0xde,0x8e,0xcc,
122  0x1e,0x08,0x29,0x85,0x16,0xe2,0xc9,0xed,0x03,0xff,0x3c,0x1b,0x78,0x60,0xf6,0xde,0x76,0xd4,0xce,0xcd,0x94,0xc8,0x11,0x98,0x55,0xef,0x52,0x97,0xca,0x67,0xe9,0xf3,
123  0xe7,0xff,0x72,0xb1,0xe9,0x97,0x85,0xca,0x0a,0x7e,0x77,0x20,0xc5,0xb3,0x6d,0xc6,0xd7,0x2c,0xac,0x95,0x74,0xc8,0xcb,0xbc,0x2f,0x80,0x1e,0x23,0xe5,0x6f,0xd3,0x44,
124  0xb0,0x7f,0x22,0x15,0x4b,0xeb,0xa0,0xf0,0x8c,0xe8,0x89,0x1e,0x64,0x3e,0xd9,0x95,0xc9,0x4d,0x9a,0x69,0xc9,0xf1,0xb5,0xf4,0x99,0x02,0x7a,0x78,0x57,0x2a,0xee,0xbd,
125  0x74,0xd2,0x0c,0xc3,0x98,0x81,0xc2,0x13,0xee,0x77,0x0b,0x10,0x10,0xe4,0xbe,0xa7,0x18,0x84,0x69,0x77,0xae,0x11,0x9f,0x7a,0x02,0x3a,0xb5,0x8c,0xca,0x0a,0xd7,0x52,
126  0xaf,0xe6,0x56,0xbb,0x3c,0x17,0x25,0x6a,0x9f,0x6e,0x9b,0xf1,0x9f,0xdd,0x5a,0x38,0xfc,0x82,0xbb,0xe8,0x72,0xc5,0x53,0x9e,0xdb,0x60,0x9e,0xf4,0xf7,0x9c,0x20,0x3e,
127  0xbb,0x14,0x0f,0x2e,0x58,0x3c,0xb2,0xad,0x15,0xb4,0xaa,0x5b,0x65,0x50,0x16,0xa8,0x44,0x92,0x77,0xdb,0xd4,0x77,0xef,0x2c,0x8d,0x6c,0x01,0x7d,0xb7,0x38,0xb1,0x8d,
128  0xeb,0x4a,0x42,0x7d,0x19,0x23,0xce,0x3f,0xf2,0x62,0x73,0x57,0x79,0xa4,0x18,0xf2,0x0a,0x28,0x2d,0xf9,0x20,0x14,0x7b,0xea,0xbe,0x42,0x1e,0xe5,0x31,0x9d,0x05,0x68,
129     }
130  },
131  {
132     32,
133     { 0xff,0xfe,0xfd,0xfc,0xfb,0xfa,0xf9,0xf8,0xf7,0xf6,0xf5,0xf4,0xf3,0xf2,0xf1,0xf0 },
134     { 0xbf,0xbe,0xbd,0xbc,0xbb,0xba,0xb9,0xb8,0xb7,0xb6,0xb5,0xb4,0xb3,0xb2,0xb1,0xb0 },
135     CONST64(0x123456789a),
136     17,
137     { 0x00,0x01,0x02,0x03,0x04,0x05,0x06,0x07,0x08,0x09,0x0a,0x0b,0x0c,0x0d,0x0e,0x0f,0x10 },
138     { 0x6c,0x16,0x25,0xdb,0x46,0x71,0x52,0x2d,0x3d,0x75,0x99,0x60,0x1d,0xe7,0xca,0x09,0xed },
139  },
140  {
141     32,
142     { 0xff,0xfe,0xfd,0xfc,0xfb,0xfa,0xf9,0xf8,0xf7,0xf6,0xf5,0xf4,0xf3,0xf2,0xf1,0xf0 },
143     { 0xbf,0xbe,0xbd,0xbc,0xbb,0xba,0xb9,0xb8,0xb7,0xb6,0xb5,0xb4,0xb3,0xb2,0xb1,0xb0 },
144     CONST64(0x123456789a),
145     25,
146     { 0x00,0x01,0x02,0x03,0x04,0x05,0x06,0x07,0x08,0x09,0x0a,0x0b,0x0c,0x0d,0x0e,0x0f,0x10,0x11,0x12,0x13,0x14,0x15,0x16,0x17,0x18 },
147     { 0x8f,0x4d,0xcb,0xad,0x55,0x55,0x8d,0x7b,0x4e,0x01,0xd9,0x37,0x9c,0xd4,0xea,0x22,0xed,0xbf,0x9d,0xac,0xe4,0x5d,0x6f,0x6a,0x73 },
148  },
149  {
150     32,
151     { 0xff,0xfe,0xfd,0xfc,0xfb,0xfa,0xf9,0xf8,0xf7,0xf6,0xf5,0xf4,0xf3,0xf2,0xf1,0xf0 },
152     { 0xbf,0xbe,0xbd,0xbc,0xbb,0xba,0xb9,0xb8,0xb7,0xb6,0xb5,0xb4,0xb3,0xb2,0xb1,0xb0 },
153     CONST64(0x123456789a),
154     31,
155     { 0x00,0x01,0x02,0x03,0x04,0x05,0x06,0x07,0x08,0x09,0x0a,0x0b,0x0c,0x0d,0x0e,0x0f,0x10,0x11,0x12,0x13,0x14,0x15,0x16,0x17,0x18,0x19,0x1a,0x1b,0x1c,0x1d,0x1e },
156     { 0xd0,0x5b,0xc0,0x90,0xa8,0xe0,0x4f,0x1b,0x3d,0x3e,0xcd,0xd5,0xba,0xec,0x0f,0xd4,0xed,0xbf,0x9d,0xac,0xe4,0x5d,0x6f,0x6a,0x73,0x06,0xe6,0x4b,0xe5,0xdd,0x82 },
157  },
158  };
159     unsigned char OUT[512], Torg[16], T[16];
160     ulong64 seq;
161     symmetric_xts xts;
162     int i, j, k, err, idx;
163     unsigned long len;
164     if ((idx = find_cipher("aes")) == -1) {
165        if ((idx = find_cipher("rijndael")) == -1) {
166           return CRYPT_NOP;
167        }
168     }
169     for (k = 0; k < 4; ++k) {
170        cipher_descriptor[idx].accel_xts_encrypt = NULL;
171        cipher_descriptor[idx].accel_xts_decrypt = NULL;
172        if (k & 0x1) {
173           cipher_descriptor[idx].accel_xts_encrypt = s_xts_test_accel_xts_encrypt;
174        }
175        if (k & 0x2) {
176           cipher_descriptor[idx].accel_xts_decrypt = s_xts_test_accel_xts_decrypt;
177        }
178        for (j = 0; j < 2; j++) {
179           for (i = 0; i < (int)(sizeof(tests) / sizeof(tests[0])); i++) {
180              if ((j == 1) && ((tests[i].PTLEN < 32) || (tests[i].PTLEN % 32))) {
181                 continue;
182              }
183              if ((k > 0) && (j == 1)) {
184                 continue;
185              }
186              len = tests[i].PTLEN / 2;
187              err = xts_start(idx, tests[i].key1, tests[i].key2, tests[i].keylen / 2, 0, &xts);
188              if (err != CRYPT_OK) {
189                 return err;
190              }
191              seq = tests[i].seqnum;
192              STORE64L(seq, Torg);
193              XMEMSET(Torg + 8, 0, 8);
194              XMEMCPY(T, Torg, sizeof(T));
195              if (j == 0) {
196                 err = xts_encrypt(tests[i].PTX, tests[i].PTLEN, OUT, T, &xts);
197                 if (err != CRYPT_OK) {
198                    xts_done(&xts);
199                    return err;
200                 }
201              } else {
202                 err = xts_encrypt(tests[i].PTX, len, OUT, T, &xts);
203                 if (err != CRYPT_OK) {
204                    xts_done(&xts);
205                    return err;
206                 }
207                 err = xts_encrypt(&tests[i].PTX[len], len, &OUT[len], T, &xts);
208                 if (err != CRYPT_OK) {
209                    xts_done(&xts);
210                    return err;
211                 }
212              }
213              if (compare_testvector(OUT, tests[i].PTLEN, tests[i].CTX, tests[i].PTLEN, "XTS encrypt", i)) {
214                 xts_done(&xts);
215                 return CRYPT_FAIL_TESTVECTOR;
216              }
217              XMEMCPY(T, Torg, sizeof(T));
218              if (j == 0) {
219                 err = xts_decrypt(tests[i].CTX, tests[i].PTLEN, OUT, T, &xts);
220                 if (err != CRYPT_OK) {
221                    xts_done(&xts);
222                    return err;
223                 }
224              } else {
225                 err = xts_decrypt(tests[i].CTX, len, OUT, T, &xts);
226                 if (err != CRYPT_OK) {
227                    xts_done(&xts);
228                    return err;
229                 }
230                 err = xts_decrypt(&tests[i].CTX[len], len, &OUT[len], T, &xts);
231                 if (err != CRYPT_OK) {
232                    xts_done(&xts);
233                    return err;
234                 }
235              }
236              if (compare_testvector(OUT, tests[i].PTLEN, tests[i].PTX, tests[i].PTLEN, "XTS decrypt", i)) {
237                 xts_done(&xts);
238                 return CRYPT_FAIL_TESTVECTOR;
239              }
240              xts_done(&xts);
241           }
242        }
243     }
244     return CRYPT_OK;
245  #endif
246  }
247  #endif
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from libtomcrypt-MDEwOlJlcG9zaXRvcnk3NzcwMTE=-flat-bcrypt.c</div>
                <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from libtomcrypt-MDEwOlJlcG9zaXRvcnk3NzcwMTE=-flat-xts_test.c</div>
                <div class="column column_space"><pre><code>47  int bcrypt_pbkdf_openbsd(const          void *secret, unsigned long secret_len,
48                           const unsigned char *salt,   unsigned long salt_len,
49                                 unsigned int  rounds,            int hash_idx,
</pre></code></div>
                <div class="column column_space"><pre><code>30     int (*orig)(const unsigned char *, unsigned char *,
31                 unsigned long , unsigned char *,
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    