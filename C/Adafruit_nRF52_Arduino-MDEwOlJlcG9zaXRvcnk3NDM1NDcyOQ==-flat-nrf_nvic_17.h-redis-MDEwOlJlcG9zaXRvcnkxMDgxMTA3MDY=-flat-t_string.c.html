
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 3.7243947858473%, Tokens: 10</h2>
        <div class="column">
            <h3>Adafruit_nRF52_Arduino-MDEwOlJlcG9zaXRvcnk3NDM1NDcyOQ==-flat-nrf_nvic_17.h</h3>
            <pre><code>1  #ifndef NRF_NVIC_H__
2  #define NRF_NVIC_H__
3  #include <stdint.h>
4  #include "nrf.h"
5  #include "nrf_svc.h"
6  #include "nrf_error.h"
7  #include "nrf_error_soc.h"
8  #ifdef __cplusplus
9  extern "C" {
10  #endif
11  #define __NRF_NVIC_NVMC_IRQn (30) &bsol;**< The peripheral ID of the NVMC. IRQ numbers are used to identify peripherals, but the NVMC doesn't have an IRQ number in the MDK. */
12  #define __NRF_NVIC_ISER_COUNT (2) &bsol;**< The number of ISER/ICER registers in the NVIC that are used. */
13  #define __NRF_NVIC_SD_IRQ_PRIOS ((uint8_t)( \
14        (1U << 0)  &bsol;**< Priority level high .*/   \
15      | (1U << 1)  &bsol;**< Priority level medium. */ \
16      | (1U << 4)  &bsol;**< Priority level low. */    \
17    ))
18  #define __NRF_NVIC_APP_IRQ_PRIOS ((uint8_t)~__NRF_NVIC_SD_IRQ_PRIOS)
19  #define __NRF_NVIC_SD_IRQS_0 ((uint32_t)( \
20        (1U << POWER_CLOCK_IRQn) \
21      | (1U << RADIO_IRQn) \
22      | (1U << RTC0_IRQn) \
23      | (1U << TIMER0_IRQn) \
24      | (1U << RNG_IRQn) \
25      | (1U << ECB_IRQn) \
26      | (1U << CCM_AAR_IRQn) \
27      | (1U << TEMP_IRQn) \
28      | (1U << __NRF_NVIC_NVMC_IRQn) \
29      | (1U << (uint32_t)SWI5_IRQn) \
30    ))
31  #define __NRF_NVIC_SD_IRQS_1 ((uint32_t)0)
32  #define __NRF_NVIC_APP_IRQS_0 (~__NRF_NVIC_SD_IRQS_0)
33  #define __NRF_NVIC_APP_IRQS_1 (~__NRF_NVIC_SD_IRQS_1)
34  typedef struct
35  {
36    uint32_t volatile __irq_masks[__NRF_NVIC_ISER_COUNT]; &bsol;**< IRQs enabled by the application in the NVIC. */
37    uint32_t volatile __cr_flag;                          &bsol;**< Non-zero if already in a critical region */
38  } nrf_nvic_state_t;
39  extern nrf_nvic_state_t nrf_nvic_state;
40  __STATIC_INLINE int __sd_nvic_irq_disable(void);
41  __STATIC_INLINE void __sd_nvic_irq_enable(void);
42  __STATIC_INLINE uint32_t __sd_nvic_app_accessible_irq(IRQn_Type IRQn);
43  __STATIC_INLINE uint32_t __sd_nvic_is_app_accessible_priority(uint32_t priority);
44  __STATIC_INLINE uint32_t sd_nvic_EnableIRQ(IRQn_Type IRQn);
45  __STATIC_INLINE uint32_t sd_nvic_DisableIRQ(IRQn_Type IRQn);
46  __STATIC_INLINE uint32_t sd_nvic_GetPendingIRQ(IRQn_Type IRQn, uint32_t * p_pending_irq);
47  __STATIC_INLINE uint32_t sd_nvic_SetPendingIRQ(IRQn_Type IRQn);
48  __STATIC_INLINE uint32_t sd_nvic_ClearPendingIRQ(IRQn_Type IRQn);
49  __STATIC_INLINE uint32_t sd_nvic_SetPriority(IRQn_Type IRQn, uint32_t priority);
50  __STATIC_INLINE uint32_t sd_nvic_GetPriority(IRQn_Type IRQn, uint32_t * p_priority);
51  __STATIC_INLINE uint32_t sd_nvic_SystemReset(void);
52  __STATIC_INLINE uint32_t sd_nvic_critical_region_enter(uint8_t * p_is_nested_critical_region);
53  __STATIC_INLINE uint32_t sd_nvic_critical_region_exit(uint8_t is_nested_critical_region);
54  #ifndef SUPPRESS_INLINE_IMPLEMENTATION
55  __STATIC_INLINE int __sd_nvic_irq_disable(void)
56  {
57    int pm = __get_PRIMASK();
58    __disable_irq();
59    return pm;
60  }
61  __STATIC_INLINE void __sd_nvic_irq_enable(void)
62  {
63    __enable_irq();
64  }
65  __STATIC_INLINE uint32_t __sd_nvic_app_accessible_irq(IRQn_Type IRQn)
66  {
67    if (IRQn < 32)
68    {
69      return ((1UL<<IRQn) & __NRF_NVIC_APP_IRQS_0) != 0;
70    }
<span onclick='openModal()' class='match'>71    else if (IRQn < 64)
72    {
73      return ((1UL<<(IRQn-32)) & __NRF_NVIC_APP_IRQS_1) != 0;
74    }
75    else
76    {
77      return 1;
78    }
79  }
80  __STATIC_INLINE uint32_t __sd_nvic_is_app_accessible_priority(uint32_t priority)
81  {
</span>82    if( (priority >= (1 << __NVIC_PRIO_BITS))
83     || (((1 << priority) & __NRF_NVIC_APP_IRQ_PRIOS) == 0)
84      )
85    {
86      return 0;
87    }
88    return 1;
89  }
90  __STATIC_INLINE uint32_t sd_nvic_EnableIRQ(IRQn_Type IRQn)
91  {
92    if (!__sd_nvic_app_accessible_irq(IRQn))
93    {
94      return NRF_ERROR_SOC_NVIC_INTERRUPT_NOT_AVAILABLE;
95    }
96    if (!__sd_nvic_is_app_accessible_priority(NVIC_GetPriority(IRQn)))
97    {
98      return NRF_ERROR_SOC_NVIC_INTERRUPT_PRIORITY_NOT_ALLOWED;
99    }
100    if (nrf_nvic_state.__cr_flag)
101    {
102      nrf_nvic_state.__irq_masks[(uint32_t)((int32_t)IRQn) >> 5] |= (uint32_t)(1 << ((uint32_t)((int32_t)IRQn) & (uint32_t)0x1F));
103    }
104    else
105    {
106      NVIC_EnableIRQ(IRQn);
107    }
108    return NRF_SUCCESS;
109  }
110  __STATIC_INLINE uint32_t sd_nvic_DisableIRQ(IRQn_Type IRQn)
111  {
112    if (!__sd_nvic_app_accessible_irq(IRQn))
113    {
114      return NRF_ERROR_SOC_NVIC_INTERRUPT_NOT_AVAILABLE;
115    }
116    if (nrf_nvic_state.__cr_flag)
117    {
118      nrf_nvic_state.__irq_masks[(uint32_t)((int32_t)IRQn) >> 5] &= ~(1UL << ((uint32_t)(IRQn) & 0x1F));
119    }
120    else
121    {
122      NVIC_DisableIRQ(IRQn);
123    }
124    return NRF_SUCCESS;
125  }
126  __STATIC_INLINE uint32_t sd_nvic_GetPendingIRQ(IRQn_Type IRQn, uint32_t * p_pending_irq)
127  {
128    if (__sd_nvic_app_accessible_irq(IRQn))
129    {
130      *p_pending_irq = NVIC_GetPendingIRQ(IRQn);
131      return NRF_SUCCESS;
132    }
133    else
134    {
135      return NRF_ERROR_SOC_NVIC_INTERRUPT_NOT_AVAILABLE;
136    }
137  }
138  __STATIC_INLINE uint32_t sd_nvic_SetPendingIRQ(IRQn_Type IRQn)
139  {
140    if (__sd_nvic_app_accessible_irq(IRQn))
141    {
142      NVIC_SetPendingIRQ(IRQn);
143      return NRF_SUCCESS;
144    }
145    else
146    {
147      return NRF_ERROR_SOC_NVIC_INTERRUPT_NOT_AVAILABLE;
148    }
149  }
150  __STATIC_INLINE uint32_t sd_nvic_ClearPendingIRQ(IRQn_Type IRQn)
151  {
152    if (__sd_nvic_app_accessible_irq(IRQn))
153    {
154      NVIC_ClearPendingIRQ(IRQn);
155      return NRF_SUCCESS;
156    }
157    else
158    {
159      return NRF_ERROR_SOC_NVIC_INTERRUPT_NOT_AVAILABLE;
160    }
161  }
162  __STATIC_INLINE uint32_t sd_nvic_SetPriority(IRQn_Type IRQn, uint32_t priority)
163  {
164    if (!__sd_nvic_app_accessible_irq(IRQn))
165    {
166      return NRF_ERROR_SOC_NVIC_INTERRUPT_NOT_AVAILABLE;
167    }
168    if (!__sd_nvic_is_app_accessible_priority(priority))
169    {
170      return NRF_ERROR_SOC_NVIC_INTERRUPT_PRIORITY_NOT_ALLOWED;
171    }
172    NVIC_SetPriority(IRQn, (uint32_t)priority);
173    return NRF_SUCCESS;
174  }
175  __STATIC_INLINE uint32_t sd_nvic_GetPriority(IRQn_Type IRQn, uint32_t * p_priority)
176  {
177    if (__sd_nvic_app_accessible_irq(IRQn))
178    {
179      *p_priority = (NVIC_GetPriority(IRQn) & 0xFF);
180      return NRF_SUCCESS;
181    }
182    else
183    {
184      return NRF_ERROR_SOC_NVIC_INTERRUPT_NOT_AVAILABLE;
185    }
186  }
187  __STATIC_INLINE uint32_t sd_nvic_SystemReset(void)
188  {
189    NVIC_SystemReset();
190    return NRF_ERROR_SOC_NVIC_SHOULD_NOT_RETURN;
191  }
192  __STATIC_INLINE uint32_t sd_nvic_critical_region_enter(uint8_t * p_is_nested_critical_region)
193  {
194    int was_masked = __sd_nvic_irq_disable();
195    if (!nrf_nvic_state.__cr_flag)
196    {
197      nrf_nvic_state.__cr_flag = 1;
198      nrf_nvic_state.__irq_masks[0] = ( NVIC->ICER[0] & __NRF_NVIC_APP_IRQS_0 );
199      NVIC->ICER[0] = __NRF_NVIC_APP_IRQS_0;
200      nrf_nvic_state.__irq_masks[1] = ( NVIC->ICER[1] & __NRF_NVIC_APP_IRQS_1 );
201      NVIC->ICER[1] = __NRF_NVIC_APP_IRQS_1;
202      *p_is_nested_critical_region = 0;
203    }
204    else
205    {
206      *p_is_nested_critical_region = 1;
207    }
208    if (!was_masked)
209    {
210      __sd_nvic_irq_enable();
211    }
212    return NRF_SUCCESS;
213  }
214  __STATIC_INLINE uint32_t sd_nvic_critical_region_exit(uint8_t is_nested_critical_region)
215  {
216    if (nrf_nvic_state.__cr_flag && (is_nested_critical_region == 0))
217    {
218      int was_masked = __sd_nvic_irq_disable();
219      NVIC->ISER[0] = nrf_nvic_state.__irq_masks[0];
220      NVIC->ISER[1] = nrf_nvic_state.__irq_masks[1];
221      nrf_nvic_state.__cr_flag = 0;
222      if (!was_masked)
223      {
224        __sd_nvic_irq_enable();
225      }
226    }
227    return NRF_SUCCESS;
228  }
229  #endif &bsol;* SUPPRESS_INLINE_IMPLEMENTATION */
230  #ifdef __cplusplus
231  }
232  #endif
233  #endif 
</code></pre>
        </div>
        <div class="column">
            <h3>redis-MDEwOlJlcG9zaXRvcnkxMDgxMTA3MDY=-flat-t_string.c</h3>
            <pre><code>1  #include "server.h"
2  #include <math.h> &bsol;* isnan(), isinf() */
3  static int checkStringLength(client *c, PORT_LONGLONG size) {
4      if (size > 512*1024*1024) {
5          addReplyError(c,"string exceeds maximum allowed size (512MB)");
6          return C_ERR;
7      }
8      return C_OK;
9  }
10  #define OBJ_SET_NO_FLAGS 0
11  #define OBJ_SET_NX (1<<0)     &bsol;* Set if key not exists. */
12  #define OBJ_SET_XX (1<<1)     &bsol;* Set if key exists. */
13  #define OBJ_SET_EX (1<<2)     &bsol;* Set if time in seconds is given */
14  #define OBJ_SET_PX (1<<3)     &bsol;* Set if time in ms in given */
15  void setGenericCommand(client *c, int flags, robj *key, robj *val, robj *expire, int unit, robj *ok_reply, robj *abort_reply) {
16      PORT_LONGLONG milliseconds = 0; &bsol;* initialized to avoid any harmness warning */
17      if (expire) {
18          if (getLongLongFromObjectOrReply(c, expire, &milliseconds, NULL) != C_OK)
19              return;
20          if (milliseconds <= 0) {
21              addReplyErrorFormat(c,"invalid expire time in %s",c->cmd->name);
22              return;
23          }
24          if (unit == UNIT_SECONDS) milliseconds *= 1000;
25      }
26      if ((flags & OBJ_SET_NX && lookupKeyWrite(c->db,key) != NULL) ||
27          (flags & OBJ_SET_XX && lookupKeyWrite(c->db,key) == NULL))
28      {
29          addReply(c, abort_reply ? abort_reply : shared.nullbulk);
30          return;
31      }
32      setKey(c->db,key,val);
33      server.dirty++;
34      if (expire) setExpire(c,c->db,key,mstime()+milliseconds);
35      notifyKeyspaceEvent(NOTIFY_STRING,"set",key,c->db->id);
36      if (expire) notifyKeyspaceEvent(NOTIFY_GENERIC,
37          "expire",key,c->db->id);
38      addReply(c, ok_reply ? ok_reply : shared.ok);
39  }
40  void setCommand(client *c) {
41      int j;
42      robj *expire = NULL;
43      int unit = UNIT_SECONDS;
44      int flags = OBJ_SET_NO_FLAGS;
45      for (j = 3; j < c->argc; j++) {
46          char *a = c->argv[j]->ptr;
47          robj *next = (j == c->argc-1) ? NULL : c->argv[j+1];
48          if ((a[0] == 'n' || a[0] == 'N') &&
49              (a[1] == 'x' || a[1] == 'X') && a[2] == '\0' &&
50              !(flags & OBJ_SET_XX))
51          {
52              flags |= OBJ_SET_NX;
53          } else if ((a[0] == 'x' || a[0] == 'X') &&
54                     (a[1] == 'x' || a[1] == 'X') && a[2] == '\0' &&
55                     !(flags & OBJ_SET_NX))
56          {
57              flags |= OBJ_SET_XX;
58          } else if ((a[0] == 'e' || a[0] == 'E') &&
59                     (a[1] == 'x' || a[1] == 'X') && a[2] == '\0' &&
60                     !(flags & OBJ_SET_PX) && next)
61          {
62              flags |= OBJ_SET_EX;
63              unit = UNIT_SECONDS;
64              expire = next;
65              j++;
66          } else if ((a[0] == 'p' || a[0] == 'P') &&
67                     (a[1] == 'x' || a[1] == 'X') && a[2] == '\0' &&
68                     !(flags & OBJ_SET_EX) && next)
69          {
70              flags |= OBJ_SET_PX;
71              unit = UNIT_MILLISECONDS;
72              expire = next;
73              j++;
74          } else {
75              addReply(c,shared.syntaxerr);
76              return;
77          }
78      }
79      c->argv[2] = tryObjectEncoding(c->argv[2]);
80      setGenericCommand(c,flags,c->argv[1],c->argv[2],expire,unit,NULL,NULL);
81  }
82  void setnxCommand(client *c) {
83      c->argv[2] = tryObjectEncoding(c->argv[2]);
84      setGenericCommand(c,OBJ_SET_NX,c->argv[1],c->argv[2],NULL,0,shared.cone,shared.czero);
85  }
86  void setexCommand(client *c) {
87      c->argv[3] = tryObjectEncoding(c->argv[3]);
88      setGenericCommand(c,OBJ_SET_NO_FLAGS,c->argv[1],c->argv[3],c->argv[2],UNIT_SECONDS,NULL,NULL);
89  }
90  void psetexCommand(client *c) {
91      c->argv[3] = tryObjectEncoding(c->argv[3]);
92      setGenericCommand(c,OBJ_SET_NO_FLAGS,c->argv[1],c->argv[3],c->argv[2],UNIT_MILLISECONDS,NULL,NULL);
93  }
94  int getGenericCommand(client *c) {
95      robj *o;
96      if ((o = lookupKeyReadOrReply(c,c->argv[1],shared.nullbulk)) == NULL)
97          return C_OK;
<span onclick='openModal()' class='match'>98      if (o->type != OBJ_STRING) {
99          addReply(c,shared.wrongtypeerr);
100          return C_ERR;
101      } else {
102          addReplyBulk(c,o);
103          return C_OK;
104      }
105  }
106  void getCommand(client *c) {
</span>107      getGenericCommand(c);
108  }
109  void getsetCommand(client *c) {
110      if (getGenericCommand(c) == C_ERR) return;
111      c->argv[2] = tryObjectEncoding(c->argv[2]);
112      setKey(c->db,c->argv[1],c->argv[2]);
113      notifyKeyspaceEvent(NOTIFY_STRING,"set",c->argv[1],c->db->id);
114      server.dirty++;
115  }
116  void setrangeCommand(client *c) {
117      robj *o;
118      PORT_LONG offset;
119      sds value = c->argv[3]->ptr;
120      if (getLongFromObjectOrReply(c,c->argv[2],&offset,NULL) != C_OK)
121          return;
122      if (offset < 0) {
123          addReplyError(c,"offset is out of range");
124          return;
125      }
126      o = lookupKeyWrite(c->db,c->argv[1]);
127      if (o == NULL) {
128          if (sdslen(value) == 0) {
129              addReply(c,shared.czero);
130              return;
131          }
132          if (checkStringLength(c,offset+sdslen(value)) != C_OK)
133              return;
134          o = createObject(OBJ_STRING,sdsnewlen(NULL, offset+sdslen(value)));
135          dbAdd(c->db,c->argv[1],o);
136      } else {
137          size_t olen;
138          if (checkType(c,o,OBJ_STRING))
139              return;
140          olen = stringObjectLen(o);
141          if (sdslen(value) == 0) {
142              addReplyLongLong(c,olen);
143              return;
144          }
145          if (checkStringLength(c,offset+sdslen(value)) != C_OK)
146              return;
147          o = dbUnshareStringValue(c->db,c->argv[1],o);
148      }
149      if (sdslen(value) > 0) {
150          o->ptr = sdsgrowzero(o->ptr,offset+sdslen(value));
151          memcpy((char*)o->ptr+offset,value,sdslen(value));
152          signalModifiedKey(c->db,c->argv[1]);
153          notifyKeyspaceEvent(NOTIFY_STRING,
154              "setrange",c->argv[1],c->db->id);
155          server.dirty++;
156      }
157      addReplyLongLong(c,sdslen(o->ptr));
158  }
159  void getrangeCommand(client *c) {
160      robj *o;
161      PORT_LONGLONG start, end;
162      char *str, llbuf[32];
163      size_t strlen;
164      if (getLongLongFromObjectOrReply(c,c->argv[2],&start,NULL) != C_OK)
165          return;
166      if (getLongLongFromObjectOrReply(c,c->argv[3],&end,NULL) != C_OK)
167          return;
168      if ((o = lookupKeyReadOrReply(c,c->argv[1],shared.emptybulk)) == NULL ||
169          checkType(c,o,OBJ_STRING)) return;
170      if (o->encoding == OBJ_ENCODING_INT) {
171          str = llbuf;
172          strlen = ll2string(llbuf,sizeof(llbuf),(PORT_LONG)o->ptr);
173      } else {
174          str = o->ptr;
175          strlen = sdslen(str);
176      }
177      if (start < 0 && end < 0 && start > end) {
178          addReply(c,shared.emptybulk);
179          return;
180      }
181      if (start < 0) start = strlen+start;
182      if (end < 0) end = strlen+end;
183      if (start < 0) start = 0;
184      if (end < 0) end = 0;
185      if ((PORT_ULONGLONG)end >= strlen) end = strlen-1;
186      if (start > end || strlen == 0) {
187          addReply(c,shared.emptybulk);
188      } else {
189          addReplyBulkCBuffer(c,(char*)str+start,end-start+1);
190      }
191  }
192  void mgetCommand(client *c) {
193      int j;
194      addReplyMultiBulkLen(c,c->argc-1);
195      for (j = 1; j < c->argc; j++) {
196          robj *o = lookupKeyRead(c->db,c->argv[j]);
197          if (o == NULL) {
198              addReply(c,shared.nullbulk);
199          } else {
200              if (o->type != OBJ_STRING) {
201                  addReply(c,shared.nullbulk);
202              } else {
203                  addReplyBulk(c,o);
204              }
205          }
206      }
207  }
208  void msetGenericCommand(client *c, int nx) {
209      int j;
210      if ((c->argc % 2) == 0) {
211          addReplyError(c,"wrong number of arguments for MSET");
212          return;
213      }
214      if (nx) {
215          for (j = 1; j < c->argc; j += 2) {
216              if (lookupKeyWrite(c->db,c->argv[j]) != NULL) {
217                  addReply(c, shared.czero);
218                  return;
219              }
220          }
221      }
222      for (j = 1; j < c->argc; j += 2) {
223          c->argv[j+1] = tryObjectEncoding(c->argv[j+1]);
224          setKey(c->db,c->argv[j],c->argv[j+1]);
225          notifyKeyspaceEvent(NOTIFY_STRING,"set",c->argv[j],c->db->id);
226      }
227      server.dirty += (c->argc-1)/2;
228      addReply(c, nx ? shared.cone : shared.ok);
229  }
230  void msetCommand(client *c) {
231      msetGenericCommand(c,0);
232  }
233  void msetnxCommand(client *c) {
234      msetGenericCommand(c,1);
235  }
236  void incrDecrCommand(client *c, PORT_LONGLONG incr) {
237      PORT_LONGLONG value, oldvalue;
238      robj *o, *new;
239      o = lookupKeyWrite(c->db,c->argv[1]);
240      if (o != NULL && checkType(c,o,OBJ_STRING)) return;
241      if (getLongLongFromObjectOrReply(c,o,&value,NULL) != C_OK) return;
242      oldvalue = value;
243      if ((incr < 0 && oldvalue < 0 && incr < (LLONG_MIN-oldvalue)) ||
244          (incr > 0 && oldvalue > 0 && incr > (LLONG_MAX-oldvalue))) {
245          addReplyError(c,"increment or decrement would overflow");
246          return;
247      }
248      value += incr;
249      if (o && o->refcount == 1 && o->encoding == OBJ_ENCODING_INT &&
250          (value < 0 || value >= OBJ_SHARED_INTEGERS) &&
251          value >= LONG_MIN && value <= LONG_MAX)
252      {
253          new = o;
254          o->ptr = (void*)((PORT_LONG)value);
255      } else {
256          new = createStringObjectFromLongLongForValue(value);
257          if (o) {
258              dbOverwrite(c->db,c->argv[1],new);
259          } else {
260              dbAdd(c->db,c->argv[1],new);
261          }
262      }
263      signalModifiedKey(c->db,c->argv[1]);
264      notifyKeyspaceEvent(NOTIFY_STRING,"incrby",c->argv[1],c->db->id);
265      server.dirty++;
266      addReply(c,shared.colon);
267      addReply(c,new);
268      addReply(c,shared.crlf);
269  }
270  void incrCommand(client *c) {
271      incrDecrCommand(c,1);
272  }
273  void decrCommand(client *c) {
274      incrDecrCommand(c,-1);
275  }
276  void incrbyCommand(client *c) {
277      PORT_LONGLONG incr;
278      if (getLongLongFromObjectOrReply(c, c->argv[2], &incr, NULL) != C_OK) return;
279      incrDecrCommand(c,incr);
280  }
281  void decrbyCommand(client *c) {
282      PORT_LONGLONG incr;
283      if (getLongLongFromObjectOrReply(c, c->argv[2], &incr, NULL) != C_OK) return;
284      incrDecrCommand(c,-incr);
285  }
286  void incrbyfloatCommand(client *c) {
287      PORT_LONGDOUBLE incr, value;
288      robj *o, *new, *aux;
289      o = lookupKeyWrite(c->db,c->argv[1]);
290      if (o != NULL && checkType(c,o,OBJ_STRING)) return;
291      if (getLongDoubleFromObjectOrReply(c,o,&value,NULL) != C_OK ||
292          getLongDoubleFromObjectOrReply(c,c->argv[2],&incr,NULL) != C_OK)
293          return;
294      value += incr;
295      if (isnan(value) || isinf(value)) {
296          addReplyError(c,"increment would produce NaN or Infinity");
297          return;
298      }
299      new = createStringObjectFromLongDouble(value,1);
300      if (o)
301          dbOverwrite(c->db,c->argv[1],new);
302      else
303          dbAdd(c->db,c->argv[1],new);
304      signalModifiedKey(c->db,c->argv[1]);
305      notifyKeyspaceEvent(NOTIFY_STRING,"incrbyfloat",c->argv[1],c->db->id);
306      server.dirty++;
307      addReplyBulk(c,new);
308      aux = createStringObject("SET",3);
309      rewriteClientCommandArgument(c,0,aux);
310      decrRefCount(aux);
311      rewriteClientCommandArgument(c,2,new);
312  }
313  void appendCommand(client *c) {
314      size_t totlen;
315      robj *o, *append;
316      o = lookupKeyWrite(c->db,c->argv[1]);
317      if (o == NULL) {
318          c->argv[2] = tryObjectEncoding(c->argv[2]);
319          dbAdd(c->db,c->argv[1],c->argv[2]);
320          incrRefCount(c->argv[2]);
321          totlen = stringObjectLen(c->argv[2]);
322      } else {
323          if (checkType(c,o,OBJ_STRING))
324              return;
325          append = c->argv[2];
326          totlen = stringObjectLen(o)+sdslen(append->ptr);
327          if (checkStringLength(c,totlen) != C_OK)
328              return;
329          o = dbUnshareStringValue(c->db,c->argv[1],o);
330          o->ptr = sdscatlen(o->ptr,append->ptr,sdslen(append->ptr));
331          totlen = sdslen(o->ptr);
332      }
333      signalModifiedKey(c->db,c->argv[1]);
334      notifyKeyspaceEvent(NOTIFY_STRING,"append",c->argv[1],c->db->id);
335      server.dirty++;
336      addReplyLongLong(c,totlen);
337  }
338  void strlenCommand(client *c) {
339      robj *o;
340      if ((o = lookupKeyReadOrReply(c,c->argv[1],shared.czero)) == NULL ||
341          checkType(c,o,OBJ_STRING)) return;
342      addReplyLongLong(c,stringObjectLen(o));
343  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from Adafruit_nRF52_Arduino-MDEwOlJlcG9zaXRvcnk3NDM1NDcyOQ==-flat-nrf_nvic_17.h</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from redis-MDEwOlJlcG9zaXRvcnkxMDgxMTA3MDY=-flat-t_string.c</div>
                </div>
                <div class="column column_space"><pre><code>71    else if (IRQn < 64)
72    {
73      return ((1UL<<(IRQn-32)) & __NRF_NVIC_APP_IRQS_1) != 0;
74    }
75    else
76    {
77      return 1;
78    }
79  }
80  __STATIC_INLINE uint32_t __sd_nvic_is_app_accessible_priority(uint32_t priority)
81  {
</pre></code></div>
                <div class="column column_space"><pre><code>98      if (o->type != OBJ_STRING) {
99          addReply(c,shared.wrongtypeerr);
100          return C_ERR;
101      } else {
102          addReplyBulk(c,o);
103          return C_OK;
104      }
105  }
106  void getCommand(client *c) {
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    