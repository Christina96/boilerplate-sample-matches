
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 13.043478260869565%, Tokens: 8, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>redis-MDEwOlJlcG9zaXRvcnkxMDgxMTA3MDY=-flat-ql.c</h3>
            <pre><code>1  #include "test/jemalloc_test.h"
2  #include "jemalloc/internal/ql.h"
3  #define NENTRIES 9
4  typedef struct list_s list_t;
5  typedef ql_head(list_t) list_head_t;
6  struct list_s {
7  	ql_elm(list_t) link;
8  	char id;
9  };
10  static void
11  test_empty_list(list_head_t *head) {
12  	list_t *t;
13  	unsigned i;
14  	assert_ptr_null(ql_first(head), "Unexpected element for empty list");
15  	assert_ptr_null(ql_last(head, link),
16  	    "Unexpected element for empty list");
17  	i = 0;
18  	ql_foreach(t, head, link) {
19  		i++;
20  	}
21  	assert_u_eq(i, 0, "Unexpected element for empty list");
22  	i = 0;
23  	ql_reverse_foreach(t, head, link) {
24  		i++;
25  	}
26  	assert_u_eq(i, 0, "Unexpected element for empty list");
27  }
28  TEST_BEGIN(test_ql_empty) {
29  	list_head_t head;
30  	ql_new(&head);
31  	test_empty_list(&head);
32  }
33  TEST_END
34  static void
35  init_entries(list_t *entries, unsigned nentries) {
36  	unsigned i;
<span onclick='openModal()' class='match'>37  	for (i = 0; i < nentries; i++) {
38  		entries[i].id = 'a' + i;
39  		ql_elm_new(&entries[i], link);
40  	}
41  }
42  static void
</span>43  test_entries_list(list_head_t *head, list_t *entries, unsigned nentries) {
44  	list_t *t;
45  	unsigned i;
46  	assert_c_eq(ql_first(head)->id, entries[0].id, "Element id mismatch");
47  	assert_c_eq(ql_last(head, link)->id, entries[nentries-1].id,
48  	    "Element id mismatch");
49  	i = 0;
50  	ql_foreach(t, head, link) {
51  		assert_c_eq(t->id, entries[i].id, "Element id mismatch");
52  		i++;
53  	}
54  	i = 0;
55  	ql_reverse_foreach(t, head, link) {
56  		assert_c_eq(t->id, entries[nentries-i-1].id,
57  		    "Element id mismatch");
58  		i++;
59  	}
60  	for (i = 0; i < nentries-1; i++) {
61  		t = ql_next(head, &entries[i], link);
62  		assert_c_eq(t->id, entries[i+1].id, "Element id mismatch");
63  	}
64  	assert_ptr_null(ql_next(head, &entries[nentries-1], link),
65  	    "Unexpected element");
66  	assert_ptr_null(ql_prev(head, &entries[0], link), "Unexpected element");
67  	for (i = 1; i < nentries; i++) {
68  		t = ql_prev(head, &entries[i], link);
69  		assert_c_eq(t->id, entries[i-1].id, "Element id mismatch");
70  	}
71  }
72  TEST_BEGIN(test_ql_tail_insert) {
73  	list_head_t head;
74  	list_t entries[NENTRIES];
75  	unsigned i;
76  	ql_new(&head);
77  	init_entries(entries, sizeof(entries)/sizeof(list_t));
78  	for (i = 0; i < NENTRIES; i++) {
79  		ql_tail_insert(&head, &entries[i], link);
80  	}
81  	test_entries_list(&head, entries, NENTRIES);
82  }
83  TEST_END
84  TEST_BEGIN(test_ql_tail_remove) {
85  	list_head_t head;
86  	list_t entries[NENTRIES];
87  	unsigned i;
88  	ql_new(&head);
89  	init_entries(entries, sizeof(entries)/sizeof(list_t));
90  	for (i = 0; i < NENTRIES; i++) {
91  		ql_tail_insert(&head, &entries[i], link);
92  	}
93  	for (i = 0; i < NENTRIES; i++) {
94  		test_entries_list(&head, entries, NENTRIES-i);
95  		ql_tail_remove(&head, list_t, link);
96  	}
97  	test_empty_list(&head);
98  }
99  TEST_END
100  TEST_BEGIN(test_ql_head_insert) {
101  	list_head_t head;
102  	list_t entries[NENTRIES];
103  	unsigned i;
104  	ql_new(&head);
105  	init_entries(entries, sizeof(entries)/sizeof(list_t));
106  	for (i = 0; i < NENTRIES; i++) {
107  		ql_head_insert(&head, &entries[NENTRIES-i-1], link);
108  	}
109  	test_entries_list(&head, entries, NENTRIES);
110  }
111  TEST_END
112  TEST_BEGIN(test_ql_head_remove) {
113  	list_head_t head;
114  	list_t entries[NENTRIES];
115  	unsigned i;
116  	ql_new(&head);
117  	init_entries(entries, sizeof(entries)/sizeof(list_t));
118  	for (i = 0; i < NENTRIES; i++) {
119  		ql_head_insert(&head, &entries[NENTRIES-i-1], link);
120  	}
121  	for (i = 0; i < NENTRIES; i++) {
122  		test_entries_list(&head, &entries[i], NENTRIES-i);
123  		ql_head_remove(&head, list_t, link);
124  	}
125  	test_empty_list(&head);
126  }
127  TEST_END
128  TEST_BEGIN(test_ql_insert) {
129  	list_head_t head;
130  	list_t entries[8];
131  	list_t *a, *b, *c, *d, *e, *f, *g, *h;
132  	ql_new(&head);
133  	init_entries(entries, sizeof(entries)/sizeof(list_t));
134  	a = &entries[0];
135  	b = &entries[1];
136  	c = &entries[2];
137  	d = &entries[3];
138  	e = &entries[4];
139  	f = &entries[5];
140  	g = &entries[6];
141  	h = &entries[7];
142  	ql_tail_insert(&head, f, link);
143  	ql_before_insert(&head, f, b, link);
144  	ql_before_insert(&head, f, c, link);
145  	ql_after_insert(f, h, link);
146  	ql_after_insert(f, g, link);
147  	ql_before_insert(&head, b, a, link);
148  	ql_after_insert(c, d, link);
149  	ql_before_insert(&head, f, e, link);
150  	test_entries_list(&head, entries, sizeof(entries)/sizeof(list_t));
151  }
152  TEST_END
153  int
154  main(void) {
155  	return test(
156  	    test_ql_empty,
157  	    test_ql_tail_insert,
158  	    test_ql_tail_remove,
159  	    test_ql_head_insert,
160  	    test_ql_head_remove,
161  	    test_ql_insert);
162  }
</code></pre>
        </div>
        <div class="column">
            <h3>xmrig-MDEwOlJlcG9zaXRvcnk4ODMyNzQwNg==-flat-argon2-avx512f.c</h3>
            <pre><code>1  #include "argon2-avx512f.h"
2  #ifdef HAVE_AVX512F
3  #include <stdint.h>
4  #include <string.h>
5  #ifdef __GNUC__
6  #   include <x86intrin.h>
7  #else
8  #   include <intrin.h>
9  #endif
10  #define ror64(x, n) _mm512_ror_epi64((x), (n))
11  static __m512i f(__m512i x, __m512i y)
12  {
13      __m512i z = _mm512_mul_epu32(x, y);
14      return _mm512_add_epi64(_mm512_add_epi64(x, y), _mm512_add_epi64(z, z));
15  }
16  #define G1(A0, B0, C0, D0, A1, B1, C1, D1) \
17      do { \
18          A0 = f(A0, B0); \
19          A1 = f(A1, B1); \
20  \
21          D0 = _mm512_xor_si512(D0, A0); \
22          D1 = _mm512_xor_si512(D1, A1); \
23  \
24          D0 = ror64(D0, 32); \
25          D1 = ror64(D1, 32); \
26  \
27          C0 = f(C0, D0); \
28          C1 = f(C1, D1); \
29  \
30          B0 = _mm512_xor_si512(B0, C0); \
31          B1 = _mm512_xor_si512(B1, C1); \
32  \
33          B0 = ror64(B0, 24); \
34          B1 = ror64(B1, 24); \
35      } while ((void)0, 0)
36  #define G2(A0, B0, C0, D0, A1, B1, C1, D1) \
37      do { \
38          A0 = f(A0, B0); \
39          A1 = f(A1, B1); \
40  \
41          D0 = _mm512_xor_si512(D0, A0); \
42          D1 = _mm512_xor_si512(D1, A1); \
43  \
44          D0 = ror64(D0, 16); \
45          D1 = ror64(D1, 16); \
46  \
47          C0 = f(C0, D0); \
48          C1 = f(C1, D1); \
49  \
50          B0 = _mm512_xor_si512(B0, C0); \
51          B1 = _mm512_xor_si512(B1, C1); \
52  \
53          B0 = ror64(B0, 63); \
54          B1 = ror64(B1, 63); \
55      } while ((void)0, 0)
56  #define DIAGONALIZE(A0, B0, C0, D0, A1, B1, C1, D1) \
57      do { \
58          B0 = _mm512_permutex_epi64(B0, _MM_SHUFFLE(0, 3, 2, 1)); \
59          B1 = _mm512_permutex_epi64(B1, _MM_SHUFFLE(0, 3, 2, 1)); \
60  \
61          C0 = _mm512_permutex_epi64(C0, _MM_SHUFFLE(1, 0, 3, 2)); \
62          C1 = _mm512_permutex_epi64(C1, _MM_SHUFFLE(1, 0, 3, 2)); \
63  \
64          D0 = _mm512_permutex_epi64(D0, _MM_SHUFFLE(2, 1, 0, 3)); \
65          D1 = _mm512_permutex_epi64(D1, _MM_SHUFFLE(2, 1, 0, 3)); \
66      } while ((void)0, 0)
67  #define UNDIAGONALIZE(A0, B0, C0, D0, A1, B1, C1, D1) \
68      do { \
69          B0 = _mm512_permutex_epi64(B0, _MM_SHUFFLE(2, 1, 0, 3)); \
70          B1 = _mm512_permutex_epi64(B1, _MM_SHUFFLE(2, 1, 0, 3)); \
71  \
72          C0 = _mm512_permutex_epi64(C0, _MM_SHUFFLE(1, 0, 3, 2)); \
73          C1 = _mm512_permutex_epi64(C1, _MM_SHUFFLE(1, 0, 3, 2)); \
74  \
75          D0 = _mm512_permutex_epi64(D0, _MM_SHUFFLE(0, 3, 2, 1)); \
76          D1 = _mm512_permutex_epi64(D1, _MM_SHUFFLE(0, 3, 2, 1)); \
77      } while ((void)0, 0)
78  #define BLAKE2_ROUND(A0, B0, C0, D0, A1, B1, C1, D1) \
79      do { \
80          G1(A0, B0, C0, D0, A1, B1, C1, D1); \
81          G2(A0, B0, C0, D0, A1, B1, C1, D1); \
82  \
83          DIAGONALIZE(A0, B0, C0, D0, A1, B1, C1, D1); \
84  \
85          G1(A0, B0, C0, D0, A1, B1, C1, D1); \
86          G2(A0, B0, C0, D0, A1, B1, C1, D1); \
87  \
88          UNDIAGONALIZE(A0, B0, C0, D0, A1, B1, C1, D1); \
89      } while ((void)0, 0)
90  #define SWAP_HALVES(A0, A1) \
91      do { \
92          __m512i t0, t1; \
93          t0 = _mm512_shuffle_i64x2(A0, A1, _MM_SHUFFLE(1, 0, 1, 0)); \
94          t1 = _mm512_shuffle_i64x2(A0, A1, _MM_SHUFFLE(3, 2, 3, 2)); \
95          A0 = t0; \
96          A1 = t1; \
97      } while((void)0, 0)
98  #define SWAP_QUARTERS(A0, A1) \
99      do { \
100          SWAP_HALVES(A0, A1); \
101          A0 = _mm512_permutexvar_epi64(_mm512_setr_epi64(0, 1, 4, 5, 2, 3, 6, 7), A0); \
102          A1 = _mm512_permutexvar_epi64(_mm512_setr_epi64(0, 1, 4, 5, 2, 3, 6, 7), A1); \
103      } while((void)0, 0)
104  #define UNSWAP_QUARTERS(A0, A1) \
105      do { \
106          A0 = _mm512_permutexvar_epi64(_mm512_setr_epi64(0, 1, 4, 5, 2, 3, 6, 7), A0); \
107          A1 = _mm512_permutexvar_epi64(_mm512_setr_epi64(0, 1, 4, 5, 2, 3, 6, 7), A1); \
108          SWAP_HALVES(A0, A1); \
109      } while((void)0, 0)
110  #define BLAKE2_ROUND1(A0, C0, B0, D0, A1, C1, B1, D1) \
111      do { \
112          SWAP_HALVES(A0, B0); \
113          SWAP_HALVES(C0, D0); \
114          SWAP_HALVES(A1, B1); \
115          SWAP_HALVES(C1, D1); \
116          BLAKE2_ROUND(A0, B0, C0, D0, A1, B1, C1, D1); \
117          SWAP_HALVES(A0, B0); \
118          SWAP_HALVES(C0, D0); \
119          SWAP_HALVES(A1, B1); \
120          SWAP_HALVES(C1, D1); \
121      } while ((void)0, 0)
122  #define BLAKE2_ROUND2(A0, A1, B0, B1, C0, C1, D0, D1) \
123      do { \
124          SWAP_QUARTERS(A0, A1); \
125          SWAP_QUARTERS(B0, B1); \
126          SWAP_QUARTERS(C0, C1); \
127          SWAP_QUARTERS(D0, D1); \
128          BLAKE2_ROUND(A0, B0, C0, D0, A1, B1, C1, D1); \
129          UNSWAP_QUARTERS(A0, A1); \
130          UNSWAP_QUARTERS(B0, B1); \
131          UNSWAP_QUARTERS(C0, C1); \
132          UNSWAP_QUARTERS(D0, D1); \
133      } while ((void)0, 0)
134  enum {
135      ARGON2_VECS_IN_BLOCK = ARGON2_OWORDS_IN_BLOCK / 4,
136  };
137  static void fill_block(__m512i *s, const block *ref_block, block *next_block,
138                         int with_xor)
139  {
140      __m512i block_XY[ARGON2_VECS_IN_BLOCK];
141      unsigned int i;
142      if (with_xor) {
143          for (i = 0; i < ARGON2_VECS_IN_BLOCK; i++) {
144              s[i] =_mm512_xor_si512(
145                  s[i], _mm512_loadu_si512((const __m512i *)ref_block->v + i));
146              block_XY[i] = _mm512_xor_si512(
147                  s[i], _mm512_loadu_si512((const __m512i *)next_block->v + i));
148          }
149      } else {
150          for (i = 0; i < ARGON2_VECS_IN_BLOCK; i++) {
151              block_XY[i] = s[i] =_mm512_xor_si512(
152                  s[i], _mm512_loadu_si512((const __m512i *)ref_block->v + i));
153          }
154      }
155      for (i = 0; i < 2; ++i) {
156          BLAKE2_ROUND1(
157              s[8 * i + 0], s[8 * i + 1], s[8 * i + 2], s[8 * i + 3],
158              s[8 * i + 4], s[8 * i + 5], s[8 * i + 6], s[8 * i + 7]);
159      }
160      for (i = 0; i < 2; ++i) {
161          BLAKE2_ROUND2(
162              s[2 * 0 + i], s[2 * 1 + i], s[2 * 2 + i], s[2 * 3 + i],
163              s[2 * 4 + i], s[2 * 5 + i], s[2 * 6 + i], s[2 * 7 + i]);
164      }
<span onclick='openModal()' class='match'>165      for (i = 0; i < ARGON2_VECS_IN_BLOCK; i++) {
166          s[i] = _mm512_xor_si512(s[i], block_XY[i]);
167          _mm512_storeu_si512((__m512i *)next_block->v + i, s[i]);
168      }
169  }
170  static void next_addresses(block *address_block, block *input_block)
</span>171  {
172      __m512i zero_block[ARGON2_VECS_IN_BLOCK];
173      __m512i zero2_block[ARGON2_VECS_IN_BLOCK];
174      memset(zero_block, 0, sizeof(zero_block));
175      memset(zero2_block, 0, sizeof(zero2_block));
176      input_block->v[6]++;
177      fill_block(zero_block, input_block, address_block, 0);
178      fill_block(zero2_block, address_block, address_block, 0);
179  }
180  void xmrig_ar2_fill_segment_avx512f(const argon2_instance_t *instance, argon2_position_t position)
181  {
182      block *ref_block = NULL, *curr_block = NULL;
183      block address_block, input_block;
184      uint64_t pseudo_rand, ref_index, ref_lane;
185      uint32_t prev_offset, curr_offset;
186      uint32_t starting_index, i;
187      __m512i state[ARGON2_VECS_IN_BLOCK];
188      int data_independent_addressing;
189      if (instance == NULL) {
190          return;
191      }
192      data_independent_addressing = (instance->type == Argon2_i) ||
193              (instance->type == Argon2_id && (position.pass == 0) &&
194               (position.slice < ARGON2_SYNC_POINTS / 2));
195      if (data_independent_addressing) {
196          init_block_value(&input_block, 0);
197          input_block.v[0] = position.pass;
198          input_block.v[1] = position.lane;
199          input_block.v[2] = position.slice;
200          input_block.v[3] = instance->memory_blocks;
201          input_block.v[4] = instance->passes;
202          input_block.v[5] = instance->type;
203      }
204      starting_index = 0;
205      if ((0 == position.pass) && (0 == position.slice)) {
206          starting_index = 2; &bsol;* we have already generated the first two blocks */
207          if (data_independent_addressing) {
208              next_addresses(&address_block, &input_block);
209          }
210      }
211      curr_offset = position.lane * instance->lane_length +
212                    position.slice * instance->segment_length + starting_index;
213      if (0 == curr_offset % instance->lane_length) {
214          prev_offset = curr_offset + instance->lane_length - 1;
215      } else {
216          prev_offset = curr_offset - 1;
217      }
218      memcpy(state, ((instance->memory + prev_offset)->v), ARGON2_BLOCK_SIZE);
219      for (i = starting_index; i < instance->segment_length;
220           ++i, ++curr_offset, ++prev_offset) {
221          if (curr_offset % instance->lane_length == 1) {
222              prev_offset = curr_offset - 1;
223          }
224          if (data_independent_addressing) {
225              if (i % ARGON2_ADDRESSES_IN_BLOCK == 0) {
226                  next_addresses(&address_block, &input_block);
227              }
228              pseudo_rand = address_block.v[i % ARGON2_ADDRESSES_IN_BLOCK];
229          } else {
230              pseudo_rand = instance->memory[prev_offset].v[0];
231          }
232          ref_lane = ((pseudo_rand >> 32)) % instance->lanes;
233          if ((position.pass == 0) && (position.slice == 0)) {
234              ref_lane = position.lane;
235          }
236          position.index = i;
237          ref_index = xmrig_ar2_index_alpha(instance, &position, pseudo_rand & 0xFFFFFFFF, ref_lane == position.lane);
238          ref_block =
239              instance->memory + instance->lane_length * ref_lane + ref_index;
240          curr_block = instance->memory + curr_offset;
241          if (0 == position.pass || ARGON2_VERSION_10 == instance->version) {
242              fill_block(state, ref_block, curr_block, 0);
243          } else {
244              fill_block(state, ref_block, curr_block, 1);
245          }
246      }
247  }
248  extern int cpu_flags_has_avx512f(void);
249  int xmrig_ar2_check_avx512f(void) { return cpu_flags_has_avx512f(); }
250  #else
251  void xmrig_ar2_fill_segment_avx512f(const argon2_instance_t *instance, argon2_position_t position) {}
252  int xmrig_ar2_check_avx512f(void) { return 0; }
253  #endif
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from redis-MDEwOlJlcG9zaXRvcnkxMDgxMTA3MDY=-flat-ql.c</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from xmrig-MDEwOlJlcG9zaXRvcnk4ODMyNzQwNg==-flat-argon2-avx512f.c</div>
                </div>
                <div class="column column_space"><pre><code>37  	for (i = 0; i < nentries; i++) {
38  		entries[i].id = 'a' + i;
39  		ql_elm_new(&entries[i], link);
40  	}
41  }
42  static void
</pre></code></div>
                <div class="column column_space"><pre><code>165      for (i = 0; i < ARGON2_VECS_IN_BLOCK; i++) {
166          s[i] = _mm512_xor_si512(s[i], block_XY[i]);
167          _mm512_storeu_si512((__m512i *)next_block->v + i, s[i]);
168      }
169  }
170  static void next_addresses(block *address_block, block *input_block)
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    