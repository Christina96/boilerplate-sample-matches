
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 5.67741935483871%, Tokens: 9, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>PINRemoteImage-MDEwOlJlcG9zaXRvcnkzOTUzNzEwMw==-flat-iterator_enc.c</h3>
            <pre><code>1  #include <string.h>
2  #include "src/enc/vp8i_enc.h"
3  static void InitLeft(VP8EncIterator* const it) {
4    it->y_left_[-1] = it->u_left_[-1] = it->v_left_[-1] =
5        (it->y_ > 0) ? 129 : 127;
6    memset(it->y_left_, 129, 16);
7    memset(it->u_left_, 129, 8);
8    memset(it->v_left_, 129, 8);
9    it->left_nz_[8] = 0;
10    if (it->top_derr_ != NULL) {
11      memset(&it->left_derr_, 0, sizeof(it->left_derr_));
12    }
13  }
14  static void InitTop(VP8EncIterator* const it) {
15    const VP8Encoder* const enc = it->enc_;
16    const size_t top_size = enc->mb_w_ * 16;
17    memset(enc->y_top_, 127, 2 * top_size);
18    memset(enc->nz_, 0, enc->mb_w_ * sizeof(*enc->nz_));
19    if (enc->top_derr_ != NULL) {
20      memset(enc->top_derr_, 0, enc->mb_w_ * sizeof(*enc->top_derr_));
21    }
22  }
23  void VP8IteratorSetRow(VP8EncIterator* const it, int y) {
24    VP8Encoder* const enc = it->enc_;
25    it->x_ = 0;
26    it->y_ = y;
27    it->bw_ = &enc->parts_[y & (enc->num_parts_ - 1)];
28    it->preds_ = enc->preds_ + y * 4 * enc->preds_w_;
29    it->nz_ = enc->nz_;
30    it->mb_ = enc->mb_info_ + y * enc->mb_w_;
31    it->y_top_ = enc->y_top_;
32    it->uv_top_ = enc->uv_top_;
33    InitLeft(it);
34  }
35  void VP8IteratorReset(VP8EncIterator* const it) {
36    VP8Encoder* const enc = it->enc_;
37    VP8IteratorSetRow(it, 0);
38    VP8IteratorSetCountDown(it, enc->mb_w_ * enc->mb_h_);  
39    InitTop(it);
40    memset(it->bit_count_, 0, sizeof(it->bit_count_));
41    it->do_trellis_ = 0;
42  }
43  void VP8IteratorSetCountDown(VP8EncIterator* const it, int count_down) {
44    it->count_down_ = it->count_down0_ = count_down;
45  }
46  int VP8IteratorIsDone(const VP8EncIterator* const it) {
47    return (it->count_down_ <= 0);
48  }
49  void VP8IteratorInit(VP8Encoder* const enc, VP8EncIterator* const it) {
50    it->enc_ = enc;
51    it->yuv_in_   = (uint8_t*)WEBP_ALIGN(it->yuv_mem_);
52    it->yuv_out_  = it->yuv_in_ + YUV_SIZE_ENC;
53    it->yuv_out2_ = it->yuv_out_ + YUV_SIZE_ENC;
54    it->yuv_p_    = it->yuv_out2_ + YUV_SIZE_ENC;
55    it->lf_stats_ = enc->lf_stats_;
56    it->percent0_ = enc->percent_;
57    it->y_left_ = (uint8_t*)WEBP_ALIGN(it->yuv_left_mem_ + 1);
58    it->u_left_ = it->y_left_ + 16 + 16;
59    it->v_left_ = it->u_left_ + 16;
60    it->top_derr_ = enc->top_derr_;
61    VP8IteratorReset(it);
62  }
63  int VP8IteratorProgress(const VP8EncIterator* const it, int delta) {
64    VP8Encoder* const enc = it->enc_;
65    if (delta && enc->pic_->progress_hook != NULL) {
66      const int done = it->count_down0_ - it->count_down_;
67      const int percent = (it->count_down0_ <= 0)
68                        ? it->percent0_
69                        : it->percent0_ + delta * done / it->count_down0_;
70      return WebPReportProgress(enc->pic_, percent, &enc->percent_);
71    }
72    return 1;
73  }
74  static WEBP_INLINE int MinSize(int a, int b) { return (a < b) ? a : b; }
75  static void ImportBlock(const uint8_t* src, int src_stride,
76                          uint8_t* dst, int w, int h, int size) {
77    int i;
78    for (i = 0; i < h; ++i) {
79      memcpy(dst, src, w);
80      if (w < size) {
81        memset(dst + w, dst[w - 1], size - w);
82      }
83      dst += BPS;
84      src += src_stride;
85    }
86    for (i = h; i < size; ++i) {
87      memcpy(dst, dst - BPS, size);
88      dst += BPS;
89    }
90  }
91  static void ImportLine(const uint8_t* src, int src_stride,
92                         uint8_t* dst, int len, int total_len) {
93    int i;
94    for (i = 0; i < len; ++i, src += src_stride) dst[i] = *src;
95    for (; i < total_len; ++i) dst[i] = dst[len - 1];
96  }
97  void VP8IteratorImport(VP8EncIterator* const it, uint8_t* const tmp_32) {
98    const VP8Encoder* const enc = it->enc_;
99    const int x = it->x_, y = it->y_;
100    const WebPPicture* const pic = enc->pic_;
101    const uint8_t* const ysrc = pic->y + (y * pic->y_stride  + x) * 16;
102    const uint8_t* const usrc = pic->u + (y * pic->uv_stride + x) * 8;
103    const uint8_t* const vsrc = pic->v + (y * pic->uv_stride + x) * 8;
104    const int w = MinSize(pic->width - x * 16, 16);
105    const int h = MinSize(pic->height - y * 16, 16);
106    const int uv_w = (w + 1) >> 1;
107    const int uv_h = (h + 1) >> 1;
108    ImportBlock(ysrc, pic->y_stride,  it->yuv_in_ + Y_OFF_ENC, w, h, 16);
109    ImportBlock(usrc, pic->uv_stride, it->yuv_in_ + U_OFF_ENC, uv_w, uv_h, 8);
110    ImportBlock(vsrc, pic->uv_stride, it->yuv_in_ + V_OFF_ENC, uv_w, uv_h, 8);
111    if (tmp_32 == NULL) return;
112    if (x == 0) {
113      InitLeft(it);
114    } else {
115      if (y == 0) {
116        it->y_left_[-1] = it->u_left_[-1] = it->v_left_[-1] = 127;
117      } else {
118        it->y_left_[-1] = ysrc[- 1 - pic->y_stride];
119        it->u_left_[-1] = usrc[- 1 - pic->uv_stride];
120        it->v_left_[-1] = vsrc[- 1 - pic->uv_stride];
121      }
122      ImportLine(ysrc - 1, pic->y_stride,  it->y_left_, h,   16);
123      ImportLine(usrc - 1, pic->uv_stride, it->u_left_, uv_h, 8);
124      ImportLine(vsrc - 1, pic->uv_stride, it->v_left_, uv_h, 8);
125    }
126    it->y_top_  = tmp_32 + 0;
127    it->uv_top_ = tmp_32 + 16;
128    if (y == 0) {
129      memset(tmp_32, 127, 32 * sizeof(*tmp_32));
130    } else {
131      ImportLine(ysrc - pic->y_stride,  1, tmp_32,          w,   16);
132      ImportLine(usrc - pic->uv_stride, 1, tmp_32 + 16,     uv_w, 8);
133      ImportLine(vsrc - pic->uv_stride, 1, tmp_32 + 16 + 8, uv_w, 8);
134    }
135  }
136  static void ExportBlock(const uint8_t* src, uint8_t* dst, int dst_stride,
137                          int w, int h) {
138    while (h-- > 0) {
139      memcpy(dst, src, w);
140      dst += dst_stride;
141      src += BPS;
142    }
143  }
144  void VP8IteratorExport(const VP8EncIterator* const it) {
145    const VP8Encoder* const enc = it->enc_;
146    if (enc->config_->show_compressed) {
147      const int x = it->x_, y = it->y_;
148      const uint8_t* const ysrc = it->yuv_out_ + Y_OFF_ENC;
149      const uint8_t* const usrc = it->yuv_out_ + U_OFF_ENC;
150      const uint8_t* const vsrc = it->yuv_out_ + V_OFF_ENC;
151      const WebPPicture* const pic = enc->pic_;
152      uint8_t* const ydst = pic->y + (y * pic->y_stride + x) * 16;
153      uint8_t* const udst = pic->u + (y * pic->uv_stride + x) * 8;
154      uint8_t* const vdst = pic->v + (y * pic->uv_stride + x) * 8;
155      int w = (pic->width - x * 16);
156      int h = (pic->height - y * 16);
157      if (w > 16) w = 16;
158      if (h > 16) h = 16;
159      ExportBlock(ysrc, ydst, pic->y_stride, w, h);
160      {   
161        const int uv_w = (w + 1) >> 1;
162        const int uv_h = (h + 1) >> 1;
163        ExportBlock(usrc, udst, pic->uv_stride, uv_w, uv_h);
164        ExportBlock(vsrc, vdst, pic->uv_stride, uv_w, uv_h);
165      }
166    }
167  }
168  #define BIT(nz, n) (!!((nz) & (1 << (n))))
169  void VP8IteratorNzToBytes(VP8EncIterator* const it) {
170    const int tnz = it->nz_[0], lnz = it->nz_[-1];
171    int* const top_nz = it->top_nz_;
172    int* const left_nz = it->left_nz_;
173    top_nz[0] = BIT(tnz, 12);
174    top_nz[1] = BIT(tnz, 13);
175    top_nz[2] = BIT(tnz, 14);
176    top_nz[3] = BIT(tnz, 15);
177    top_nz[4] = BIT(tnz, 18);
178    top_nz[5] = BIT(tnz, 19);
179    top_nz[6] = BIT(tnz, 22);
180    top_nz[7] = BIT(tnz, 23);
181    top_nz[8] = BIT(tnz, 24);
182    left_nz[0] = BIT(lnz,  3);
183    left_nz[1] = BIT(lnz,  7);
184    left_nz[2] = BIT(lnz, 11);
185    left_nz[3] = BIT(lnz, 15);
186    left_nz[4] = BIT(lnz, 17);
187    left_nz[5] = BIT(lnz, 19);
188    left_nz[6] = BIT(lnz, 21);
189    left_nz[7] = BIT(lnz, 23);
190  }
191  void VP8IteratorBytesToNz(VP8EncIterator* const it) {
192    uint32_t nz = 0;
193    const int* const top_nz = it->top_nz_;
194    const int* const left_nz = it->left_nz_;
195    nz |= (top_nz[0] << 12) | (top_nz[1] << 13);
196    nz |= (top_nz[2] << 14) | (top_nz[3] << 15);
197    nz |= (top_nz[4] << 18) | (top_nz[5] << 19);
198    nz |= (top_nz[6] << 22) | (top_nz[7] << 23);
199    nz |= (top_nz[8] << 24);  
200    nz |= (left_nz[0] << 3) | (left_nz[1] << 7);
201    nz |= (left_nz[2] << 11);
202    nz |= (left_nz[4] << 17) | (left_nz[6] << 21);
203    *it->nz_ = nz;
204  }
205  #undef BIT
206  void VP8IteratorSaveBoundary(VP8EncIterator* const it) {
207    VP8Encoder* const enc = it->enc_;
208    const int x = it->x_, y = it->y_;
209    const uint8_t* const ysrc = it->yuv_out_ + Y_OFF_ENC;
<span onclick='openModal()' class='match'>210    const uint8_t* const uvsrc = it->yuv_out_ + U_OFF_ENC;
211    if (x < enc->mb_w_ - 1) {   
212      int i;
213      for (i = 0; i < 16; ++i) {
214        it->y_left_[i] = ysrc[15 + i * BPS];
</span>215      }
216      for (i = 0; i < 8; ++i) {
217        it->u_left_[i] = uvsrc[7 + i * BPS];
218        it->v_left_[i] = uvsrc[15 + i * BPS];
219      }
220      it->y_left_[-1] = it->y_top_[15];
221      it->u_left_[-1] = it->uv_top_[0 + 7];
222      it->v_left_[-1] = it->uv_top_[8 + 7];
223    }
224    if (y < enc->mb_h_ - 1) {  
225      memcpy(it->y_top_, ysrc + 15 * BPS, 16);
226      memcpy(it->uv_top_, uvsrc + 7 * BPS, 8 + 8);
227    }
228  }
229  int VP8IteratorNext(VP8EncIterator* const it) {
230    if (++it->x_ == it->enc_->mb_w_) {
231      VP8IteratorSetRow(it, ++it->y_);
232    } else {
233      it->preds_ += 4;
234      it->mb_ += 1;
235      it->nz_ += 1;
236      it->y_top_ += 16;
237      it->uv_top_ += 16;
238    }
239    return (0 < --it->count_down_);
240  }
241  void VP8SetIntra16Mode(const VP8EncIterator* const it, int mode) {
242    uint8_t* preds = it->preds_;
243    int y;
244    for (y = 0; y < 4; ++y) {
245      memset(preds, mode, 4);
246      preds += it->enc_->preds_w_;
247    }
248    it->mb_->type_ = 1;
249  }
250  void VP8SetIntra4Mode(const VP8EncIterator* const it, const uint8_t* modes) {
251    uint8_t* preds = it->preds_;
252    int y;
253    for (y = 4; y > 0; --y) {
254      memcpy(preds, modes, 4 * sizeof(*modes));
255      preds += it->enc_->preds_w_;
256      modes += 4;
257    }
258    it->mb_->type_ = 0;
259  }
260  void VP8SetIntraUVMode(const VP8EncIterator* const it, int mode) {
261    it->mb_->uv_mode_ = mode;
262  }
263  void VP8SetSkip(const VP8EncIterator* const it, int skip) {
264    it->mb_->skip_ = skip;
265  }
266  void VP8SetSegment(const VP8EncIterator* const it, int segment) {
267    it->mb_->segment_ = segment;
268  }
269  static const uint8_t VP8TopLeftI4[16] = {
270    17, 21, 25, 29,
271    13, 17, 21, 25,
272    9,  13, 17, 21,
273    5,   9, 13, 17
274  };
275  void VP8IteratorStartI4(VP8EncIterator* const it) {
276    const VP8Encoder* const enc = it->enc_;
277    int i;
278    it->i4_ = 0;    
279    it->i4_top_ = it->i4_boundary_ + VP8TopLeftI4[0];
280    for (i = 0; i < 17; ++i) {    
281      it->i4_boundary_[i] = it->y_left_[15 - i];
282    }
283    for (i = 0; i < 16; ++i) {    
284      it->i4_boundary_[17 + i] = it->y_top_[i];
285    }
286    if (it->x_ < enc->mb_w_ - 1) {
287      for (i = 16; i < 16 + 4; ++i) {
288        it->i4_boundary_[17 + i] = it->y_top_[i];
289      }
290    } else {    
291      for (i = 16; i < 16 + 4; ++i) {
292        it->i4_boundary_[17 + i] = it->i4_boundary_[17 + 15];
293      }
294    }
295    VP8IteratorNzToBytes(it);  
296  }
297  int VP8IteratorRotateI4(VP8EncIterator* const it,
298                          const uint8_t* const yuv_out) {
299    const uint8_t* const blk = yuv_out + VP8Scan[it->i4_];
300    uint8_t* const top = it->i4_top_;
301    int i;
302    for (i = 0; i <= 3; ++i) {
303      top[-4 + i] = blk[i + 3 * BPS];   
304    }
305    if ((it->i4_ & 3) != 3) {  
306      for (i = 0; i <= 2; ++i) {        
307        top[i] = blk[3 + (2 - i) * BPS];
308      }
309    } else {  
310      for (i = 0; i <= 3; ++i) {
311        top[i] = top[i + 4];
312      }
313    }
314    ++it->i4_;
315    if (it->i4_ == 16) {    
316      return 0;
317    }
318    it->i4_top_ = it->i4_boundary_ + VP8TopLeftI4[it->i4_];
319    return 1;
320  }
</code></pre>
        </div>
        <div class="column">
            <h3>PINRemoteImage-MDEwOlJlcG9zaXRvcnkzOTUzNzEwMw==-flat-webpmux.c</h3>
            <pre><code>1  #ifdef HAVE_CONFIG_H
2  #include "webp/config.h"
3  #endif
4  #include <assert.h>
5  #include <stdio.h>
6  #include <stdlib.h>
7  #include <string.h>
8  #include "webp/decode.h"
9  #include "webp/mux.h"
10  #include "../examples/example_util.h"
11  #include "../imageio/imageio_util.h"
12  #include "./unicode.h"
13  typedef enum {
14    NIL_ACTION = 0,
15    ACTION_GET,
16    ACTION_SET,
17    ACTION_STRIP,
18    ACTION_INFO,
19    ACTION_HELP,
20    ACTION_DURATION
21  } ActionType;
22  typedef enum {
23    NIL_SUBTYPE = 0,
24    SUBTYPE_ANMF,
25    SUBTYPE_LOOP,
26    SUBTYPE_BGCOLOR
27  } FeatureSubType;
28  typedef struct {
29    FeatureSubType subtype_;
30    const char* filename_;
31    const char* params_;
32  } FeatureArg;
33  typedef enum {
34    NIL_FEATURE = 0,
35    FEATURE_EXIF,
36    FEATURE_XMP,
37    FEATURE_ICCP,
38    FEATURE_ANMF,
39    FEATURE_DURATION,
40    LAST_FEATURE
41  } FeatureType;
42  static const char* const kFourccList[LAST_FEATURE] = {
43    NULL, "EXIF", "XMP ", "ICCP", "ANMF"
44  };
45  static const char* const kDescriptions[LAST_FEATURE] = {
46    NULL, "EXIF metadata", "XMP metadata", "ICC profile",
47    "Animation frame"
48  };
49  typedef struct {
50    CommandLineArguments cmd_args_;
51    ActionType action_type_;
52    const char* input_;
53    const char* output_;
54    FeatureType type_;
55    FeatureArg* args_;
56    int arg_count_;
57  } Config;
58  static int CountOccurrences(const CommandLineArguments* const args,
59                              const char* const arg) {
60    int i;
61    int num_occurences = 0;
62    for (i = 0; i < args->argc_; ++i) {
63      if (!strcmp(args->argv_[i], arg)) {
64        ++num_occurences;
65      }
66    }
67    return num_occurences;
68  }
69  static const char* const kErrorMessages[-WEBP_MUX_NOT_ENOUGH_DATA + 1] = {
70    "WEBP_MUX_NOT_FOUND", "WEBP_MUX_INVALID_ARGUMENT", "WEBP_MUX_BAD_DATA",
71    "WEBP_MUX_MEMORY_ERROR", "WEBP_MUX_NOT_ENOUGH_DATA"
72  };
73  static const char* ErrorString(WebPMuxError err) {
74    assert(err <= WEBP_MUX_NOT_FOUND && err >= WEBP_MUX_NOT_ENOUGH_DATA);
75    return kErrorMessages[-err];
76  }
77  #define RETURN_IF_ERROR(ERR_MSG)                                     \
78    if (err != WEBP_MUX_OK) {                                          \
79      fprintf(stderr, ERR_MSG);                                        \
80      return err;                                                      \
81    }
82  #define RETURN_IF_ERROR3(ERR_MSG, FORMAT_STR1, FORMAT_STR2)          \
83    if (err != WEBP_MUX_OK) {                                          \
84      fprintf(stderr, ERR_MSG, FORMAT_STR1, FORMAT_STR2);              \
85      return err;                                                      \
86    }
87  #define ERROR_GOTO1(ERR_MSG, LABEL)                                  \
88    do {                                                               \
89      fprintf(stderr, ERR_MSG);                                        \
90      ok = 0;                                                          \
91      goto LABEL;                                                      \
92    } while (0)
93  #define ERROR_GOTO2(ERR_MSG, FORMAT_STR, LABEL)                      \
94    do {                                                               \
95      fprintf(stderr, ERR_MSG, FORMAT_STR);                            \
96      ok = 0;                                                          \
97      goto LABEL;                                                      \
98    } while (0)
99  #define ERROR_GOTO3(ERR_MSG, FORMAT_STR1, FORMAT_STR2, LABEL)        \
100    do {                                                               \
101      fprintf(stderr, ERR_MSG, FORMAT_STR1, FORMAT_STR2);              \
102      ok = 0;                                                          \
103      goto LABEL;                                                      \
104    } while (0)
105  static WebPMuxError DisplayInfo(const WebPMux* mux) {
106    int width, height;
107    uint32_t flag;
108    WebPMuxError err = WebPMuxGetCanvasSize(mux, &width, &height);
109    assert(err == WEBP_MUX_OK);  
110    printf("Canvas size: %d x %d\n", width, height);
111    err = WebPMuxGetFeatures(mux, &flag);
112    RETURN_IF_ERROR("Failed to retrieve features\n");
113    if (flag == 0) {
114      printf("No features present.\n");
115      return err;
116    }
117    printf("Features present:");
118    if (flag & ANIMATION_FLAG) printf(" animation");
119    if (flag & ICCP_FLAG)      printf(" ICC profile");
120    if (flag & EXIF_FLAG)      printf(" EXIF metadata");
121    if (flag & XMP_FLAG)       printf(" XMP metadata");
122    if (flag & ALPHA_FLAG)     printf(" transparency");
123    printf("\n");
124    if (flag & ANIMATION_FLAG) {
125      const WebPChunkId id = WEBP_CHUNK_ANMF;
126      const char* const type_str = "frame";
127      int nFrames;
128      WebPMuxAnimParams params;
129      err = WebPMuxGetAnimationParams(mux, &params);
130      assert(err == WEBP_MUX_OK);
131      printf("Background color : 0x%.8X  Loop Count : %d\n",
132             params.bgcolor, params.loop_count);
<span onclick='openModal()' class='match'>133      err = WebPMuxNumChunks(mux, id, &nFrames);
134      assert(err == WEBP_MUX_OK);
135      printf("Number of %ss: %d\n", type_str, nFrames);
136      if (nFrames > 0) {
137        int i;
138        printf("No.: width height alpha x_offset y_offset ");
139        printf("duration   dispose blend ");
140        printf("image_size  compression\n");
141        for (i = 1; i <= nFrames; i++) {
142          WebPMuxFrameInfo frame;
143          err = WebPMuxGetFrame(mux, i, &frame);
</span>144          if (err == WEBP_MUX_OK) {
145            WebPBitstreamFeatures features;
146            const VP8StatusCode status = WebPGetFeatures(
147                frame.bitstream.bytes, frame.bitstream.size, &features);
148            assert(status == VP8_STATUS_OK);  
149            (void)status;
150            printf("%3d: %5d %5d %5s %8d %8d ", i, features.width,
151                   features.height, features.has_alpha ? "yes" : "no",
152                   frame.x_offset, frame.y_offset);
153            {
154              const char* const dispose =
155                  (frame.dispose_method == WEBP_MUX_DISPOSE_NONE) ? "none"
156                                                                  : "background";
157              const char* const blend =
158                  (frame.blend_method == WEBP_MUX_BLEND) ? "yes" : "no";
159              printf("%8d %10s %5s ", frame.duration, dispose, blend);
160            }
161            printf("%10d %11s\n", (int)frame.bitstream.size,
162                   (features.format == 1) ? "lossy" :
163                   (features.format == 2) ? "lossless" :
164                                            "undefined");
165          }
166          WebPDataClear(&frame.bitstream);
167          RETURN_IF_ERROR3("Failed to retrieve %s#%d\n", type_str, i);
168        }
169      }
170    }
171    if (flag & ICCP_FLAG) {
172      WebPData icc_profile;
173      err = WebPMuxGetChunk(mux, "ICCP", &icc_profile);
174      assert(err == WEBP_MUX_OK);
175      printf("Size of the ICC profile data: %d\n", (int)icc_profile.size);
176    }
177    if (flag & EXIF_FLAG) {
178      WebPData exif;
179      err = WebPMuxGetChunk(mux, "EXIF", &exif);
180      assert(err == WEBP_MUX_OK);
181      printf("Size of the EXIF metadata: %d\n", (int)exif.size);
182    }
183    if (flag & XMP_FLAG) {
184      WebPData xmp;
185      err = WebPMuxGetChunk(mux, "XMP ", &xmp);
186      assert(err == WEBP_MUX_OK);
187      printf("Size of the XMP metadata: %d\n", (int)xmp.size);
188    }
189    if ((flag & ALPHA_FLAG) && !(flag & ANIMATION_FLAG)) {
190      WebPMuxFrameInfo image;
191      err = WebPMuxGetFrame(mux, 1, &image);
192      if (err == WEBP_MUX_OK) {
193        printf("Size of the image (with alpha): %d\n", (int)image.bitstream.size);
194      }
195      WebPDataClear(&image.bitstream);
196      RETURN_IF_ERROR("Failed to retrieve the image\n");
197    }
198    return WEBP_MUX_OK;
199  }
200  static void PrintHelp(void) {
201    printf("Usage: webpmux -get GET_OPTIONS INPUT -o OUTPUT\n");
202    printf("       webpmux -set SET_OPTIONS INPUT -o OUTPUT\n");
203    printf("       webpmux -duration DURATION_OPTIONS [-duration ...]\n");
204    printf("               INPUT -o OUTPUT\n");
205    printf("       webpmux -strip STRIP_OPTIONS INPUT -o OUTPUT\n");
206    printf("       webpmux -frame FRAME_OPTIONS [-frame...] [-loop LOOP_COUNT]"
207           "\n");
208    printf("               [-bgcolor BACKGROUND_COLOR] -o OUTPUT\n");
209    printf("       webpmux -info INPUT\n");
210    printf("       webpmux [-h|-help]\n");
211    printf("       webpmux -version\n");
212    printf("       webpmux argument_file_name\n");
213    printf("\n");
214    printf("GET_OPTIONS:\n");
215    printf(" Extract relevant data:\n");
216    printf("   icc       get ICC profile\n");
217    printf("   exif      get EXIF metadata\n");
218    printf("   xmp       get XMP metadata\n");
219    printf("   frame n   get nth frame\n");
220    printf("\n");
221    printf("SET_OPTIONS:\n");
222    printf(" Set color profile/metadata:\n");
223    printf("   icc  file.icc     set ICC profile\n");
224    printf("   exif file.exif    set EXIF metadata\n");
225    printf("   xmp  file.xmp     set XMP metadata\n");
226    printf("   where:    'file.icc' contains the ICC profile to be set,\n");
227    printf("             'file.exif' contains the EXIF metadata to be set\n");
228    printf("             'file.xmp' contains the XMP metadata to be set\n");
229    printf("\n");
230    printf("DURATION_OPTIONS:\n");
231    printf(" Set duration of selected frames:\n");
232    printf("   duration            set duration for each frames\n");
233    printf("   duration,frame      set duration of a particular frame\n");
234    printf("   duration,start,end  set duration of frames in the\n");
235    printf("                        interval [start,end])\n");
236    printf("   where: 'duration' is the duration in milliseconds\n");
237    printf("          'start' is the start frame index\n");
238    printf("          'end' is the inclusive end frame index\n");
239    printf("           The special 'end' value '0' means: last frame.\n");
240    printf("\n");
241    printf("STRIP_OPTIONS:\n");
242    printf(" Strip color profile/metadata:\n");
243    printf("   icc       strip ICC profile\n");
244    printf("   exif      strip EXIF metadata\n");
245    printf("   xmp       strip XMP metadata\n");
246    printf("\n");
247    printf("FRAME_OPTIONS(i):\n");
248    printf(" Create animation:\n");
249    printf("   file_i +di+[xi+yi[+mi[bi]]]\n");
250    printf("   where:    'file_i' is the i'th animation frame (WebP format),\n");
251    printf("             'di' is the pause duration before next frame,\n");
252    printf("             'xi','yi' specify the image offset for this frame,\n");
253    printf("             'mi' is the dispose method for this frame (0 or 1),\n");
254    printf("             'bi' is the blending method for this frame (+b or -b)"
255           "\n");
256    printf("\n");
257    printf("LOOP_COUNT:\n");
258    printf(" Number of times to repeat the animation.\n");
259    printf(" Valid range is 0 to 65535 [Default: 0 (infinite)].\n");
260    printf("\n");
261    printf("BACKGROUND_COLOR:\n");
262    printf(" Background color of the canvas.\n");
263    printf("  A,R,G,B\n");
264    printf("  where:    'A', 'R', 'G' and 'B' are integers in the range 0 to 255 "
265           "specifying\n");
266    printf("            the Alpha, Red, Green and Blue component values "
267           "respectively\n");
268    printf("            [Default: 255,255,255,255]\n");
269    printf("\nINPUT & OUTPUT are in WebP format.\n");
270    printf("\nNote: The nature of EXIF, XMP and ICC data is not checked");
271    printf(" and is assumed to be\nvalid.\n");
272    printf("\nNote: if a single file name is passed as the argument, the "
273           "arguments will be\n");
274    printf("tokenized from this file. The file name must not start with "
275           "the character '-'.\n");
276  }
277  static void WarnAboutOddOffset(const WebPMuxFrameInfo* const info) {
278    if ((info->x_offset | info->y_offset) & 1) {
279      fprintf(stderr, "Warning: odd offsets will be snapped to even values"
280              " (%d, %d) -> (%d, %d)\n", info->x_offset, info->y_offset,
281              info->x_offset & ~1, info->y_offset & ~1);
282    }
283  }
284  static int CreateMux(const char* const filename, WebPMux** mux) {
285    WebPData bitstream;
286    assert(mux != NULL);
287    if (!ExUtilReadFileToWebPData(filename, &bitstream)) return 0;
288    *mux = WebPMuxCreate(&bitstream, 1);
289    WebPDataClear(&bitstream);
290    if (*mux != NULL) return 1;
291    WFPRINTF(stderr, "Failed to create mux object from file %s.\n",
292             (const W_CHAR*)filename);
293    return 0;
294  }
295  static int WriteData(const char* filename, const WebPData* const webpdata) {
296    int ok = 0;
297    FILE* fout = WSTRCMP(filename, "-") ? WFOPEN(filename, "wb")
298                                        : ImgIoUtilSetBinaryMode(stdout);
299    if (fout == NULL) {
300      WFPRINTF(stderr, "Error opening output WebP file %s!\n",
301               (const W_CHAR*)filename);
302      return 0;
303    }
304    if (fwrite(webpdata->bytes, webpdata->size, 1, fout) != 1) {
305      WFPRINTF(stderr, "Error writing file %s!\n", (const W_CHAR*)filename);
306    } else {
307      WFPRINTF(stderr, "Saved file %s (%d bytes)\n",
308               (const W_CHAR*)filename, (int)webpdata->size);
309      ok = 1;
310    }
311    if (fout != stdout) fclose(fout);
312    return ok;
313  }
314  static int WriteWebP(WebPMux* const mux, const char* filename) {
315    int ok;
316    WebPData webp_data;
317    const WebPMuxError err = WebPMuxAssemble(mux, &webp_data);
318    if (err != WEBP_MUX_OK) {
319      fprintf(stderr, "Error (%s) assembling the WebP file.\n", ErrorString(err));
320      return 0;
321    }
322    ok = WriteData(filename, &webp_data);
323    WebPDataClear(&webp_data);
324    return ok;
325  }
326  static WebPMux* DuplicateMuxHeader(const WebPMux* const mux) {
327    WebPMux* new_mux = WebPMuxNew();
328    WebPMuxAnimParams p;
329    WebPMuxError err;
330    int i;
331    int ok = 1;
332    if (new_mux == NULL) return NULL;
333    err = WebPMuxGetAnimationParams(mux, &p);
334    if (err == WEBP_MUX_OK) {
335      err = WebPMuxSetAnimationParams(new_mux, &p);
336      if (err != WEBP_MUX_OK) {
337        ERROR_GOTO2("Error (%s) handling animation params.\n",
338                    ErrorString(err), End);
339      }
340    } else {
341    }
342    for (i = 1; i <= 3; ++i) {
343      WebPData metadata;
344      err = WebPMuxGetChunk(mux, kFourccList[i], &metadata);
345      if (err == WEBP_MUX_OK && metadata.size > 0) {
346        err = WebPMuxSetChunk(new_mux, kFourccList[i], &metadata, 1);
347        if (err != WEBP_MUX_OK) {
348          ERROR_GOTO1("Error transferring metadata in DuplicateMux().", End);
349        }
350      }
351    }
352   End:
353    if (!ok) {
354      WebPMuxDelete(new_mux);
355      new_mux = NULL;
356    }
357    return new_mux;
358  }
359  static int ParseFrameArgs(const char* args, WebPMuxFrameInfo* const info) {
360    int dispose_method, dummy;
361    char plus_minus, blend_method;
362    const int num_args = sscanf(args, "+%d+%d+%d+%d%c%c+%d", &info->duration,
363                                &info->x_offset, &info->y_offset, &dispose_method,
364                                &plus_minus, &blend_method, &dummy);
365    switch (num_args) {
366      case 1:
367        info->x_offset = info->y_offset = 0;  
368      case 3:
369        dispose_method = 0;  
370      case 4:
371        plus_minus = '+';
372        blend_method = 'b';  
373      case 6:
374        break;
375      case 2:
376      case 5:
377      default:
378        return 0;
379    }
380    WarnAboutOddOffset(info);
381    info->dispose_method = (WebPMuxAnimDispose)dispose_method;
382    if (blend_method != 'b') return 0;
383    if (plus_minus != '-' && plus_minus != '+') return 0;
384    info->blend_method =
385        (plus_minus == '+') ? WEBP_MUX_BLEND : WEBP_MUX_NO_BLEND;
386    return 1;
387  }
388  static int ParseBgcolorArgs(const char* args, uint32_t* const bgcolor) {
389    uint32_t a, r, g, b;
390    if (sscanf(args, "%u,%u,%u,%u", &a, &r, &g, &b) != 4) return 0;
391    if (a >= 256 || r >= 256 || g >= 256 || b >= 256) return 0;
392    *bgcolor = (a << 24) | (r << 16) | (g << 8) | (b << 0);
393    return 1;
394  }
395  static void DeleteConfig(Config* const config) {
396    if (config != NULL) {
397      free(config->args_);
398      ExUtilDeleteCommandLineArguments(&config->cmd_args_);
399      memset(config, 0, sizeof(*config));
400    }
401  }
402  static int ValidateCommandLine(const CommandLineArguments* const cmd_args,
403                                 int* num_feature_args) {
404    int num_frame_args;
405    int num_loop_args;
406    int num_bgcolor_args;
407    int num_durations_args;
408    int ok = 1;
409    assert(num_feature_args != NULL);
410    *num_feature_args = 0;
411    if (CountOccurrences(cmd_args, "-get") > 1) {
412      ERROR_GOTO1("ERROR: Multiple '-get' arguments specified.\n", ErrValidate);
413    }
414    if (CountOccurrences(cmd_args, "-set") > 1) {
415      ERROR_GOTO1("ERROR: Multiple '-set' arguments specified.\n", ErrValidate);
416    }
417    if (CountOccurrences(cmd_args, "-strip") > 1) {
418      ERROR_GOTO1("ERROR: Multiple '-strip' arguments specified.\n", ErrValidate);
419    }
420    if (CountOccurrences(cmd_args, "-info") > 1) {
421      ERROR_GOTO1("ERROR: Multiple '-info' arguments specified.\n", ErrValidate);
422    }
423    if (CountOccurrences(cmd_args, "-o") > 1) {
424      ERROR_GOTO1("ERROR: Multiple output files specified.\n", ErrValidate);
425    }
426    num_frame_args = CountOccurrences(cmd_args, "-frame");
427    num_loop_args = CountOccurrences(cmd_args, "-loop");
428    num_bgcolor_args = CountOccurrences(cmd_args, "-bgcolor");
429    num_durations_args = CountOccurrences(cmd_args, "-duration");
430    if (num_loop_args > 1) {
431      ERROR_GOTO1("ERROR: Multiple loop counts specified.\n", ErrValidate);
432    }
433    if (num_bgcolor_args > 1) {
434      ERROR_GOTO1("ERROR: Multiple background colors specified.\n", ErrValidate);
435    }
436    if ((num_frame_args == 0) && (num_loop_args + num_bgcolor_args > 0)) {
437      ERROR_GOTO1("ERROR: Loop count and background color are relevant only in "
438                  "case of animation.\n", ErrValidate);
439    }
440    if (num_durations_args > 0 && num_frame_args != 0) {
441      ERROR_GOTO1("ERROR: Can not combine -duration and -frame commands.\n",
442                  ErrValidate);
443    }
444    assert(ok == 1);
445    if (num_durations_args > 0) {
446      *num_feature_args = num_durations_args;
447    } else if (num_frame_args == 0) {
448      *num_feature_args = 1;
449    } else {
450      *num_feature_args = num_frame_args + num_loop_args + num_bgcolor_args;
451    }
452   ErrValidate:
453    return ok;
454  }
455  #define ACTION_IS_NIL (config->action_type_ == NIL_ACTION)
456  #define FEATURETYPE_IS_NIL (config->type_ == NIL_FEATURE)
457  #define CHECK_NUM_ARGS_AT_LEAST(NUM, LABEL)                              \
458    if (argc < i + (NUM)) {                                                \
459      fprintf(stderr, "ERROR: Too few arguments for '%s'.\n", argv[i]);    \
460      goto LABEL;                                                          \
461    }
462  #define CHECK_NUM_ARGS_AT_MOST(NUM, LABEL)                               \
463    if (argc > i + (NUM)) {                                                \
464      fprintf(stderr, "ERROR: Too many arguments for '%s'.\n", argv[i]);   \
465      goto LABEL;                                                          \
466    }
467  #define CHECK_NUM_ARGS_EXACTLY(NUM, LABEL)                               \
468    CHECK_NUM_ARGS_AT_LEAST(NUM, LABEL);                                   \
469    CHECK_NUM_ARGS_AT_MOST(NUM, LABEL);
470  static int ParseCommandLine(Config* config, const W_CHAR** const unicode_argv) {
471    int i = 0;
472    int feature_arg_index = 0;
473    int ok = 1;
474    int argc = config->cmd_args_.argc_;
475    const char* const* argv = config->cmd_args_.argv_;
476    const char* const* wargv =
477        (unicode_argv != NULL) ? (const char**)(unicode_argv + 1) : argv;
478    while (i < argc) {
479      FeatureArg* const arg = &config->args_[feature_arg_index];
480      if (argv[i][0] == '-') {  
481        if (!strcmp(argv[i], "-set")) {
482          if (ACTION_IS_NIL) {
483            config->action_type_ = ACTION_SET;
484          } else {
485            ERROR_GOTO1("ERROR: Multiple actions specified.\n", ErrParse);
486          }
487          ++i;
488        } else if (!strcmp(argv[i], "-duration")) {
489          CHECK_NUM_ARGS_AT_LEAST(2, ErrParse);
490          if (ACTION_IS_NIL || config->action_type_ == ACTION_DURATION) {
491            config->action_type_ = ACTION_DURATION;
492          } else {
493            ERROR_GOTO1("ERROR: Multiple actions specified.\n", ErrParse);
494          }
495          if (FEATURETYPE_IS_NIL || config->type_ == FEATURE_DURATION) {
496            config->type_ = FEATURE_DURATION;
497          } else {
498            ERROR_GOTO1("ERROR: Multiple features specified.\n", ErrParse);
499          }
500          arg->params_ = argv[i + 1];
501          ++feature_arg_index;
502          i += 2;
503        } else if (!strcmp(argv[i], "-get")) {
504          if (ACTION_IS_NIL) {
505            config->action_type_ = ACTION_GET;
506          } else {
507            ERROR_GOTO1("ERROR: Multiple actions specified.\n", ErrParse);
508          }
509          ++i;
510        } else if (!strcmp(argv[i], "-strip")) {
511          if (ACTION_IS_NIL) {
512            config->action_type_ = ACTION_STRIP;
513            config->arg_count_ = 0;
514          } else {
515            ERROR_GOTO1("ERROR: Multiple actions specified.\n", ErrParse);
516          }
517          ++i;
518        } else if (!strcmp(argv[i], "-frame")) {
519          CHECK_NUM_ARGS_AT_LEAST(3, ErrParse);
520          if (ACTION_IS_NIL || config->action_type_ == ACTION_SET) {
521            config->action_type_ = ACTION_SET;
522          } else {
523            ERROR_GOTO1("ERROR: Multiple actions specified.\n", ErrParse);
524          }
525          if (FEATURETYPE_IS_NIL || config->type_ == FEATURE_ANMF) {
526            config->type_ = FEATURE_ANMF;
527          } else {
528            ERROR_GOTO1("ERROR: Multiple features specified.\n", ErrParse);
529          }
530          arg->subtype_ = SUBTYPE_ANMF;
531          arg->filename_ = argv[i + 1];
532          arg->params_ = argv[i + 2];
533          ++feature_arg_index;
534          i += 3;
535        } else if (!strcmp(argv[i], "-loop") || !strcmp(argv[i], "-bgcolor")) {
536          CHECK_NUM_ARGS_AT_LEAST(2, ErrParse);
537          if (ACTION_IS_NIL || config->action_type_ == ACTION_SET) {
538            config->action_type_ = ACTION_SET;
539          } else {
540            ERROR_GOTO1("ERROR: Multiple actions specified.\n", ErrParse);
541          }
542          if (FEATURETYPE_IS_NIL || config->type_ == FEATURE_ANMF) {
543            config->type_ = FEATURE_ANMF;
544          } else {
545            ERROR_GOTO1("ERROR: Multiple features specified.\n", ErrParse);
546          }
547          arg->subtype_ =
548              !strcmp(argv[i], "-loop") ? SUBTYPE_LOOP : SUBTYPE_BGCOLOR;
549          arg->params_ = argv[i + 1];
550          ++feature_arg_index;
551          i += 2;
552        } else if (!strcmp(argv[i], "-o")) {
553          CHECK_NUM_ARGS_AT_LEAST(2, ErrParse);
554          config->output_ = wargv[i + 1];
555          i += 2;
556        } else if (!strcmp(argv[i], "-info")) {
557          CHECK_NUM_ARGS_EXACTLY(2, ErrParse);
558          if (config->action_type_ != NIL_ACTION) {
559            ERROR_GOTO1("ERROR: Multiple actions specified.\n", ErrParse);
560          } else {
561            config->action_type_ = ACTION_INFO;
562            config->arg_count_ = 0;
563            config->input_ = wargv[i + 1];
564          }
565          i += 2;
566        } else if (!strcmp(argv[i], "-h") || !strcmp(argv[i], "-help")) {
567          PrintHelp();
568          DeleteConfig(config);
569          LOCAL_FREE((W_CHAR** const)unicode_argv);
570          exit(0);
571        } else if (!strcmp(argv[i], "-version")) {
572          const int version = WebPGetMuxVersion();
573          printf("%d.%d.%d\n",
574                 (version >> 16) & 0xff, (version >> 8) & 0xff, version & 0xff);
575          DeleteConfig(config);
576          LOCAL_FREE((W_CHAR** const)unicode_argv);
577          exit(0);
578        } else if (!strcmp(argv[i], "--")) {
579          if (i < argc - 1) {
580            ++i;
581            if (config->input_ == NULL) {
582              config->input_ = wargv[i];
583            } else {
584              ERROR_GOTO2("ERROR at '%s': Multiple input files specified.\n",
585                          argv[i], ErrParse);
586            }
587          }
588          break;
589        } else {
590          ERROR_GOTO2("ERROR: Unknown option: '%s'.\n", argv[i], ErrParse);
591        }
592      } else {  
593        if (ACTION_IS_NIL) {
594          ERROR_GOTO1("ERROR: Action must be specified before other arguments.\n",
595                      ErrParse);
596        }
597        if (!strcmp(argv[i], "icc") || !strcmp(argv[i], "exif") ||
598            !strcmp(argv[i], "xmp")) {
599          if (FEATURETYPE_IS_NIL) {
600            config->type_ = (!strcmp(argv[i], "icc")) ? FEATURE_ICCP :
601                (!strcmp(argv[i], "exif")) ? FEATURE_EXIF : FEATURE_XMP;
602          } else {
603            ERROR_GOTO1("ERROR: Multiple features specified.\n", ErrParse);
604          }
605          if (config->action_type_ == ACTION_SET) {
606            CHECK_NUM_ARGS_AT_LEAST(2, ErrParse);
607            arg->filename_ = wargv[i + 1];
608            ++feature_arg_index;
609            i += 2;
610          } else {
611            ++i;
612          }
613        } else if (!strcmp(argv[i], "frame") &&
614                   (config->action_type_ == ACTION_GET)) {
615          CHECK_NUM_ARGS_AT_LEAST(2, ErrParse);
616          config->type_ = FEATURE_ANMF;
617          arg->params_ = argv[i + 1];
618          ++feature_arg_index;
619          i += 2;
620        } else {  
621          if (config->input_ == NULL) {
622            config->input_ = wargv[i];
623          } else {
624            ERROR_GOTO2("ERROR at '%s': Multiple input files specified.\n",
625                        argv[i], ErrParse);
626          }
627          ++i;
628        }
629      }
630    }
631   ErrParse:
632    return ok;
633  }
634  static int ValidateConfig(Config* const config) {
635    int ok = 1;
636    if (ACTION_IS_NIL) {
637      ERROR_GOTO1("ERROR: No action specified.\n", ErrValidate2);
638    }
639    if (FEATURETYPE_IS_NIL && config->action_type_ != ACTION_INFO) {
640      ERROR_GOTO1("ERROR: No feature specified.\n", ErrValidate2);
641    }
642    if (config->input_ == NULL) {
643      if (config->action_type_ != ACTION_SET) {
644        ERROR_GOTO1("ERROR: No input file specified.\n", ErrValidate2);
645      } else if (config->type_ != FEATURE_ANMF) {
646        ERROR_GOTO1("ERROR: No input file specified.\n", ErrValidate2);
647      }
648    }
649    if (config->output_ == NULL && config->action_type_ != ACTION_INFO) {
650      ERROR_GOTO1("ERROR: No output file specified.\n", ErrValidate2);
651    }
652   ErrValidate2:
653    return ok;
654  }
655  static int InitializeConfig(int argc, const char* argv[], Config* const config,
656                              const W_CHAR** const unicode_argv) {
657    int num_feature_args = 0;
658    int ok;
659    memset(config, 0, sizeof(*config));
660    ok = ExUtilInitCommandLineArguments(argc, argv, &config->cmd_args_);
661    if (!ok) return 0;
662    if (!ValidateCommandLine(&config->cmd_args_, &num_feature_args)) {
663      ERROR_GOTO1("Exiting due to command-line parsing error.\n", Err1);
664    }
665    config->arg_count_ = num_feature_args;
666    config->args_ = (FeatureArg*)calloc(num_feature_args, sizeof(*config->args_));
667    if (config->args_ == NULL) {
668      ERROR_GOTO1("ERROR: Memory allocation error.\n", Err1);
669    }
670    if (!ParseCommandLine(config, unicode_argv) || !ValidateConfig(config)) {
671      ERROR_GOTO1("Exiting due to command-line parsing error.\n", Err1);
672    }
673   Err1:
674    return ok;
675  }
676  #undef ACTION_IS_NIL
677  #undef FEATURETYPE_IS_NIL
678  #undef CHECK_NUM_ARGS_AT_LEAST
679  #undef CHECK_NUM_ARGS_AT_MOST
680  #undef CHECK_NUM_ARGS_EXACTLY
681  static int GetFrame(const WebPMux* mux, const Config* config) {
682    WebPMuxError err = WEBP_MUX_OK;
683    WebPMux* mux_single = NULL;
684    int num = 0;
685    int ok = 1;
686    int parse_error = 0;
687    const WebPChunkId id = WEBP_CHUNK_ANMF;
688    WebPMuxFrameInfo info;
689    WebPDataInit(&info.bitstream);
690    num = ExUtilGetInt(config->args_[0].params_, 10, &parse_error);
691    if (num < 0) {
692      ERROR_GOTO1("ERROR: Frame/Fragment index must be non-negative.\n", ErrGet);
693    }
694    if (parse_error) goto ErrGet;
695    err = WebPMuxGetFrame(mux, num, &info);
696    if (err == WEBP_MUX_OK && info.id != id) err = WEBP_MUX_NOT_FOUND;
697    if (err != WEBP_MUX_OK) {
698      ERROR_GOTO3("ERROR (%s): Could not get frame %d.\n",
699                  ErrorString(err), num, ErrGet);
700    }
701    mux_single = WebPMuxNew();
702    if (mux_single == NULL) {
703      err = WEBP_MUX_MEMORY_ERROR;
704      ERROR_GOTO2("ERROR (%s): Could not allocate a mux object.\n",
705                  ErrorString(err), ErrGet);
706    }
707    err = WebPMuxSetImage(mux_single, &info.bitstream, 1);
708    if (err != WEBP_MUX_OK) {
709      ERROR_GOTO2("ERROR (%s): Could not create single image mux object.\n",
710                  ErrorString(err), ErrGet);
711    }
712    ok = WriteWebP(mux_single, config->output_);
713   ErrGet:
714    WebPDataClear(&info.bitstream);
715    WebPMuxDelete(mux_single);
716    return ok && !parse_error;
717  }
718  static int Process(const Config* config) {
719    WebPMux* mux = NULL;
720    WebPData chunk;
721    WebPMuxError err = WEBP_MUX_OK;
722    int ok = 1;
723    switch (config->action_type_) {
724      case ACTION_GET: {
725        ok = CreateMux(config->input_, &mux);
726        if (!ok) goto Err2;
727        switch (config->type_) {
728          case FEATURE_ANMF:
729            ok = GetFrame(mux, config);
730            break;
731          case FEATURE_ICCP:
732          case FEATURE_EXIF:
733          case FEATURE_XMP:
734            err = WebPMuxGetChunk(mux, kFourccList[config->type_], &chunk);
735            if (err != WEBP_MUX_OK) {
736              ERROR_GOTO3("ERROR (%s): Could not get the %s.\n",
737                          ErrorString(err), kDescriptions[config->type_], Err2);
738            }
739            ok = WriteData(config->output_, &chunk);
740            break;
741          default:
742            ERROR_GOTO1("ERROR: Invalid feature for action 'get'.\n", Err2);
743            break;
744        }
745        break;
746      }
747      case ACTION_SET: {
748        switch (config->type_) {
749          case FEATURE_ANMF: {
750            int i;
751            WebPMuxAnimParams params = { 0xFFFFFFFF, 0 };
752            mux = WebPMuxNew();
753            if (mux == NULL) {
754              ERROR_GOTO2("ERROR (%s): Could not allocate a mux object.\n",
755                          ErrorString(WEBP_MUX_MEMORY_ERROR), Err2);
756            }
757            for (i = 0; i < config->arg_count_; ++i) {
758              switch (config->args_[i].subtype_) {
759                case SUBTYPE_BGCOLOR: {
760                  uint32_t bgcolor;
761                  ok = ParseBgcolorArgs(config->args_[i].params_, &bgcolor);
762                  if (!ok) {
763                    ERROR_GOTO1("ERROR: Could not parse the background color \n",
764                                Err2);
765                  }
766                  params.bgcolor = bgcolor;
767                  break;
768                }
769                case SUBTYPE_LOOP: {
770                  int parse_error = 0;
771                  const int loop_count =
772                      ExUtilGetInt(config->args_[i].params_, 10, &parse_error);
773                  if (loop_count < 0 || loop_count > 65535) {
774                    ERROR_GOTO1("ERROR: Loop count must be in the range 0 to "
775                                "65535.\n", Err2);
776                  }
777                  ok = !parse_error;
778                  if (!ok) goto Err2;
779                  params.loop_count = loop_count;
780                  break;
781                }
782                case SUBTYPE_ANMF: {
783                  WebPMuxFrameInfo frame;
784                  frame.id = WEBP_CHUNK_ANMF;
785                  ok = ExUtilReadFileToWebPData(config->args_[i].filename_,
786                                                &frame.bitstream);
787                  if (!ok) goto Err2;
788                  ok = ParseFrameArgs(config->args_[i].params_, &frame);
789                  if (!ok) {
790                    WebPDataClear(&frame.bitstream);
791                    ERROR_GOTO1("ERROR: Could not parse frame properties.\n",
792                                Err2);
793                  }
794                  err = WebPMuxPushFrame(mux, &frame, 1);
795                  WebPDataClear(&frame.bitstream);
796                  if (err != WEBP_MUX_OK) {
797                    ERROR_GOTO3("ERROR (%s): Could not add a frame at index %d."
798                                "\n", ErrorString(err), i, Err2);
799                  }
800                  break;
801                }
802                default: {
803                  ERROR_GOTO1("ERROR: Invalid subtype for 'frame'", Err2);
804                  break;
805                }
806              }
807            }
808            err = WebPMuxSetAnimationParams(mux, &params);
809            if (err != WEBP_MUX_OK) {
810              ERROR_GOTO2("ERROR (%s): Could not set animation parameters.\n",
811                          ErrorString(err), Err2);
812            }
813            break;
814          }
815          case FEATURE_ICCP:
816          case FEATURE_EXIF:
817          case FEATURE_XMP: {
818            ok = CreateMux(config->input_, &mux);
819            if (!ok) goto Err2;
820            ok = ExUtilReadFileToWebPData(config->args_[0].filename_, &chunk);
821            if (!ok) goto Err2;
822            err = WebPMuxSetChunk(mux, kFourccList[config->type_], &chunk, 1);
823            free((void*)chunk.bytes);
824            if (err != WEBP_MUX_OK) {
825              ERROR_GOTO3("ERROR (%s): Could not set the %s.\n",
826                          ErrorString(err), kDescriptions[config->type_], Err2);
827            }
828            break;
829          }
830          default: {
831            ERROR_GOTO1("ERROR: Invalid feature for action 'set'.\n", Err2);
832            break;
833          }
834        }
835        ok = WriteWebP(mux, config->output_);
836        break;
837      }
838      case ACTION_DURATION: {
839        int num_frames;
840        ok = CreateMux(config->input_, &mux);
841        if (!ok) goto Err2;
842        err = WebPMuxNumChunks(mux, WEBP_CHUNK_ANMF, &num_frames);
843        ok = (err == WEBP_MUX_OK);
844        if (!ok) {
845          ERROR_GOTO1("ERROR: can not parse the number of frames.\n", Err2);
846        }
847        if (num_frames == 0) {
848          fprintf(stderr, "Doesn't look like the source is animated. "
849                          "Skipping duration setting.\n");
850          ok = WriteWebP(mux, config->output_);
851          if (!ok) goto Err2;
852        } else {
853          int i;
854          int* durations = NULL;
855          WebPMux* new_mux = DuplicateMuxHeader(mux);
856          if (new_mux == NULL) goto Err2;
857          durations = (int*)WebPMalloc((size_t)num_frames * sizeof(*durations));
858          if (durations == NULL) goto Err2;
859          for (i = 0; i < num_frames; ++i) durations[i] = -1;
860          for (i = 0; i < config->arg_count_; ++i) {
861            int k;
862            int args[3];
863            int duration, start, end;
864            const int nb_args = ExUtilGetInts(config->args_[i].params_,
865                                              10, 3, args);
866            ok = (nb_args >= 1);
867            if (!ok) goto Err3;
868            duration = args[0];
869            if (duration < 0) {
870              ERROR_GOTO1("ERROR: duration must be strictly positive.\n", Err3);
871            }
872            if (nb_args == 1) {   
873              start = 1;
874              end = num_frames;
875            } else {
876              start = args[1];
877              if (start <= 0) {
878                start = 1;
879              } else if (start > num_frames) {
880                start = num_frames;
881              }
882              end = (nb_args >= 3) ? args[2] : start;
883              if (end == 0 || end > num_frames) end = num_frames;
884            }
885            for (k = start; k <= end; ++k) {
886              assert(k >= 1 && k <= num_frames);
887              durations[k - 1] = duration;
888            }
889          }
890          for (i = 1; i <= num_frames; ++i) {
891            WebPMuxFrameInfo frame;
892            err = WebPMuxGetFrame(mux, i, &frame);
893            if (err != WEBP_MUX_OK || frame.id != WEBP_CHUNK_ANMF) {
894              ERROR_GOTO2("ERROR: can not retrieve frame #%d.\n", i, Err3);
895            }
896            if (durations[i - 1] >= 0) frame.duration = durations[i - 1];
897            err = WebPMuxPushFrame(new_mux, &frame, 1);
898            if (err != WEBP_MUX_OK) {
899              ERROR_GOTO2("ERROR: error push frame data #%d\n", i, Err3);
900            }
901            WebPDataClear(&frame.bitstream);
902          }
903          WebPMuxDelete(mux);
904          ok = WriteWebP(new_mux, config->output_);
905          mux = new_mux;  
906          new_mux = NULL;
907   Err3:
908          WebPFree(durations);
909          WebPMuxDelete(new_mux);
910          if (!ok) goto Err2;
911        }
912        break;
913      }
914      case ACTION_STRIP: {
915        ok = CreateMux(config->input_, &mux);
916        if (!ok) goto Err2;
917        if (config->type_ == FEATURE_ICCP || config->type_ == FEATURE_EXIF ||
918            config->type_ == FEATURE_XMP) {
919          err = WebPMuxDeleteChunk(mux, kFourccList[config->type_]);
920          if (err != WEBP_MUX_OK) {
921            ERROR_GOTO3("ERROR (%s): Could not strip the %s.\n",
922                        ErrorString(err), kDescriptions[config->type_], Err2);
923          }
924        } else {
925          ERROR_GOTO1("ERROR: Invalid feature for action 'strip'.\n", Err2);
926          break;
927        }
928        ok = WriteWebP(mux, config->output_);
929        break;
930      }
931      case ACTION_INFO: {
932        ok = CreateMux(config->input_, &mux);
933        if (!ok) goto Err2;
934        ok = (DisplayInfo(mux) == WEBP_MUX_OK);
935        break;
936      }
937      default: {
938        assert(0);  
939        break;
940      }
941    }
942   Err2:
943    WebPMuxDelete(mux);
944    return ok;
945  }
946  int main(int argc, const char* argv[]) {
947    Config config;
948    int ok;
949    INIT_WARGV(argc, argv);
950    ok = InitializeConfig(argc - 1, argv + 1, &config, GET_WARGV_OR_NULL());
951    if (ok) {
952      ok = Process(&config);
953    } else {
954      PrintHelp();
955    }
956    DeleteConfig(&config);
957    FREE_WARGV_AND_RETURN(!ok);
958  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from PINRemoteImage-MDEwOlJlcG9zaXRvcnkzOTUzNzEwMw==-flat-iterator_enc.c</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from PINRemoteImage-MDEwOlJlcG9zaXRvcnkzOTUzNzEwMw==-flat-webpmux.c</div>
                </div>
                <div class="column column_space"><pre><code>210    const uint8_t* const uvsrc = it->yuv_out_ + U_OFF_ENC;
211    if (x < enc->mb_w_ - 1) {   
212      int i;
213      for (i = 0; i < 16; ++i) {
214        it->y_left_[i] = ysrc[15 + i * BPS];
</pre></code></div>
                <div class="column column_space"><pre><code>133      err = WebPMuxNumChunks(mux, id, &nFrames);
134      assert(err == WEBP_MUX_OK);
135      printf("Number of %ss: %d\n", type_str, nFrames);
136      if (nFrames > 0) {
137        int i;
138        printf("No.: width height alpha x_offset y_offset ");
139        printf("duration   dispose blend ");
140        printf("image_size  compression\n");
141        for (i = 1; i <= nFrames; i++) {
142          WebPMuxFrameInfo frame;
143          err = WebPMuxGetFrame(mux, i, &frame);
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    