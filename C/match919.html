<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for huffman.c &amp; inffast.c</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for huffman.c &amp; inffast.c
      </h3>
<h1 align="center">
        5.6%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>huffman.c (10.15625%)<th>inffast.c (3.9156628%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(101-108)<td><a href="#" name="0">(99-113)</a><td align="center"><font color="#ff0000">13</font>
</td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>huffman.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 #include "bzlib_private.h"
2 #define WEIGHTOF(zz0)  ((zz0) &amp; 0xffffff00)
3 #define DEPTHOF(zz1)   ((zz1) &amp; 0x000000ff)
4 #define MYMAX(zz2,zz3) ((zz2) &gt; (zz3) ? (zz2) : (zz3))
5 #define ADDWEIGHTS(zw1,zw2)                           \
6    (WEIGHTOF(zw1)+WEIGHTOF(zw2)) |                    \
7    (1 + MYMAX(DEPTHOF(zw1),DEPTHOF(zw2)))
8 #define UPHEAP(z)                                     \
9 {                                                     \
10    Int32 zz, tmp;                                     \
11    zz = z; tmp = heap[zz];                            \
12    while (weight[tmp] &lt; weight[heap[zz &gt;&gt; 1]]) {      \
13       heap[zz] = heap[zz &gt;&gt; 1];                       \
14       zz &gt;&gt;= 1;                                       \
15    }                                                  \
16    heap[zz] = tmp;                                    \
17 }
18 #define DOWNHEAP(z)                                   \
19 {                                                     \
20    Int32 zz, yy, tmp;                                 \
21    zz = z; tmp = heap[zz];                            \
22    while (True) {                                     \
23       yy = zz &lt;&lt; 1;                                   \
24       if (yy &gt; nHeap) break;                          \
25       if (yy &lt; nHeap &amp;&amp;                               \
26           weight[heap[yy+1]] &lt; weight[heap[yy]])      \
27          yy++;                                        \
28       if (weight[tmp] &lt; weight[heap[yy]]) break;      \
29       heap[zz] = heap[yy];                            \
30       zz = yy;                                        \
31    }                                                  \
32    heap[zz] = tmp;                                    \
33 }
34 void BZ2_hbMakeCodeLengths ( UChar *len, 
35                              Int32 *freq,
36                              Int32 alphaSize,
37                              Int32 maxLen )
38 {
39    Int32 nNodes, nHeap, n1, n2, i, j, k;
40    Bool  tooLong;
41    Int32 heap   [ BZ_MAX_ALPHA_SIZE + 2 ];
42    Int32 weight [ BZ_MAX_ALPHA_SIZE * 2 ];
43    Int32 parent [ BZ_MAX_ALPHA_SIZE * 2 ]; 
44    for (i = 0; i &lt; alphaSize; i++)
45       weight[i+1] = (freq[i] == 0 ? 1 : freq[i]) &lt;&lt; 8;
46    while (True) {
47       nNodes = alphaSize;
48       nHeap = 0;
49       heap[0] = 0;
50       weight[0] = 0;
51       parent[0] = -2;
52       for (i = 1; i &lt;= alphaSize; i++) {
53          parent[i] = -1;
54          nHeap++;
55          heap[nHeap] = i;
56          UPHEAP(nHeap);
57       }
58 <a name="0"></a>      AssertH( nHeap &lt; (BZ_MAX_ALPHA_SIZE+2), 2001 );
59       while (nHeap &gt; 1) {
60 <font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>         n1 = heap[1]; heap[1] = heap[nHeap]; nHeap--; DOWNHEAP(1);
61          n2 = heap[1]; heap[1] = heap[nHeap]; nHeap--; DOWNHEAP(1);
62          nNodes++;
63          parent[n1] = parent[n2] = nNodes;
64          weight[nNodes] = ADDWEIGHTS(weight[n1], weight[n2]);
65          parent[nNodes] = -1;
66          nHeap++;
67          heap[nHeap] = nNodes;</b></font>
68          UPHEAP(nHeap);
69       }
70       AssertH( nNodes &lt; (BZ_MAX_ALPHA_SIZE * 2), 2002 );
71       tooLong = False;
72       for (i = 1; i &lt;= alphaSize; i++) {
73          j = 0;
74          k = i;
75          while (parent[k] &gt;= 0) { k = parent[k]; j++; }
76          len[i-1] = j;
77          if (j &gt; maxLen) tooLong = True;
78       }
79       if (! tooLong) break;
80       for (i = 1; i &lt;= alphaSize; i++) {
81          j = weight[i] &gt;&gt; 8;
82          j = 1 + (j / 2);
83          weight[i] = j &lt;&lt; 8;
84       }
85    }
86 }
87 void BZ2_hbAssignCodes ( Int32 *code,
88                          UChar *length,
89                          Int32 minLen,
90                          Int32 maxLen,
91                          Int32 alphaSize )
92 {
93    Int32 n, vec, i;
94    vec = 0;
95    for (n = minLen; n &lt;= maxLen; n++) {
96       for (i = 0; i &lt; alphaSize; i++)
97          if (length[i] == n) { code[i] = vec; vec++; };
98       vec &lt;&lt;= 1;
99    }
100 }
101 void BZ2_hbCreateDecodeTables ( Int32 *limit,
102                                 Int32 *base,
103                                 Int32 *perm,
104                                 UChar *length,
105                                 Int32 minLen,
106                                 Int32 maxLen,
107                                 Int32 alphaSize )
108 {
109    Int32 pp, i, j, vec;
110    pp = 0;
111    for (i = minLen; i &lt;= maxLen; i++)
112       for (j = 0; j &lt; alphaSize; j++)
113          if (length[j] == i) { perm[pp] = j; pp++; };
114    for (i = 0; i &lt; BZ_MAX_CODE_LEN; i++) base[i] = 0;
115    for (i = 0; i &lt; alphaSize; i++) base[length[i]+1]++;
116    for (i = 1; i &lt; BZ_MAX_CODE_LEN; i++) base[i] += base[i-1];
117    for (i = 0; i &lt; BZ_MAX_CODE_LEN; i++) limit[i] = 0;
118    vec = 0;
119    for (i = minLen; i &lt;= maxLen; i++) {
120       vec += (base[i+1] - base[i]);
121       limit[i] = vec-1;
122       vec &lt;&lt;= 1;
123    }
124    for (i = minLen + 1; i &lt;= maxLen; i++)
125       base[i] = ((limit[i-1] + 1) &lt;&lt; 1) - base[i];
126 }
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>inffast.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 #include "zutil.h"
2 #include "inftrees.h"
3 #include "inflate.h"
4 #include "inffast.h"
5 #ifndef ASMINF
6 #ifdef POSTINC
7 #  define OFF 0
8 #  define PUP(a) *(a)++
9 #else
10 #  define OFF 1
11 #  define PUP(a) *++(a)
12 #endif
13 void ZLIB_INTERNAL inflate_fast(strm, start)
14 z_streamp strm;
15 unsigned start;         {
16     struct inflate_state FAR *state;
17     unsigned char FAR *in;          unsigned char FAR *last;        unsigned char FAR *out;         unsigned char FAR *beg;         unsigned char FAR *end;     #ifdef INFLATE_STRICT
18     unsigned dmax;              #endif
19     unsigned wsize;                 unsigned whave;                 unsigned wnext;                 unsigned char FAR *window;      unsigned long hold;             unsigned bits;                  code const FAR *lcode;          code const FAR *dcode;          unsigned lmask;                 unsigned dmask;                 code here;                      unsigned op;                    unsigned len;                   unsigned dist;                  unsigned char FAR *from;    <a name="0"></a>
20     state = (struct inflate_state FAR *)strm-&gt;state;
21 <font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>    in = strm-&gt;next_in - OFF;
22     last = in + (strm-&gt;avail_in - 5);
23     out = strm-&gt;next_out - OFF;
24     beg = out - (start - strm-&gt;avail_out);
25     end = out + (strm-&gt;avail_out - 257);
26 #ifdef INFLATE_STRICT
27     dmax = state-&gt;dmax;
28 #endif
29     wsize = state-&gt;wsize;
30     whave = state-&gt;whave;
31     wnext = state-&gt;wnext;
32     window = state-&gt;window;
33     hold = state-&gt;hold;
34     bits = state-&gt;bits;
35     lcode = state-&gt;lencode;</b></font>
36     dcode = state-&gt;distcode;
37     lmask = (1U &lt;&lt; state-&gt;lenbits) - 1;
38     dmask = (1U &lt;&lt; state-&gt;distbits) - 1;
39     do {
40         if (bits &lt; 15) {
41             hold += (unsigned long)(PUP(in)) &lt;&lt; bits;
42             bits += 8;
43             hold += (unsigned long)(PUP(in)) &lt;&lt; bits;
44             bits += 8;
45         }
46         here = lcode[hold &amp; lmask];
47       dolen:
48         op = (unsigned)(here.bits);
49         hold &gt;&gt;= op;
50         bits -= op;
51         op = (unsigned)(here.op);
52         if (op == 0) {                                      Tracevv((stderr, here.val &gt;= 0x20 &amp;&amp; here.val &lt; 0x7f ?
53                     "inflate:         literal '%c'\n" :
54                     "inflate:         literal 0x%02x\n", here.val));
55             PUP(out) = (unsigned char)(here.val);
56         }
57         else if (op &amp; 16) {                                 len = (unsigned)(here.val);
58             op &amp;= 15;                                       if (op) {
59                 if (bits &lt; op) {
60                     hold += (unsigned long)(PUP(in)) &lt;&lt; bits;
61                     bits += 8;
62                 }
63                 len += (unsigned)hold &amp; ((1U &lt;&lt; op) - 1);
64                 hold &gt;&gt;= op;
65                 bits -= op;
66             }
67             Tracevv((stderr, "inflate:         length %u\n", len));
68             if (bits &lt; 15) {
69                 hold += (unsigned long)(PUP(in)) &lt;&lt; bits;
70                 bits += 8;
71                 hold += (unsigned long)(PUP(in)) &lt;&lt; bits;
72                 bits += 8;
73             }
74             here = dcode[hold &amp; dmask];
75           dodist:
76             op = (unsigned)(here.bits);
77             hold &gt;&gt;= op;
78             bits -= op;
79             op = (unsigned)(here.op);
80             if (op &amp; 16) {                                      dist = (unsigned)(here.val);
81                 op &amp;= 15;                                       if (bits &lt; op) {
82                     hold += (unsigned long)(PUP(in)) &lt;&lt; bits;
83                     bits += 8;
84                     if (bits &lt; op) {
85                         hold += (unsigned long)(PUP(in)) &lt;&lt; bits;
86                         bits += 8;
87                     }
88                 }
89                 dist += (unsigned)hold &amp; ((1U &lt;&lt; op) - 1);
90 #ifdef INFLATE_STRICT
91                 if (dist &gt; dmax) {
92                     strm-&gt;msg = (char *)"invalid distance too far back";
93                     state-&gt;mode = BAD;
94                     break;
95                 }
96 #endif
97                 hold &gt;&gt;= op;
98                 bits -= op;
99                 Tracevv((stderr, "inflate:         distance %u\n", dist));
100                 op = (unsigned)(out - beg);                     if (dist &gt; op) {                                    op = dist - op;                                 if (op &gt; whave) {
101                         if (state-&gt;sane) {
102                             strm-&gt;msg =
103                                 (char *)"invalid distance too far back";
104                             state-&gt;mode = BAD;
105                             break;
106                         }
107 #ifdef INFLATE_ALLOW_INVALID_DISTANCE_TOOFAR_ARRR
108                         if (len &lt;= op - whave) {
109                             do {
110                                 PUP(out) = 0;
111                             } while (--len);
112                             continue;
113                         }
114                         len -= op - whave;
115                         do {
116                             PUP(out) = 0;
117                         } while (--op &gt; whave);
118                         if (op == 0) {
119                             from = out - dist;
120                             do {
121                                 PUP(out) = PUP(from);
122                             } while (--len);
123                             continue;
124                         }
125 #endif
126                     }
127                     from = window - OFF;
128                     if (wnext == 0) {                                   from += wsize - op;
129                         if (op &lt; len) {                                     len -= op;
130                             do {
131                                 PUP(out) = PUP(from);
132                             } while (--op);
133                             from = out - dist;                          }
134                     }
135                     else if (wnext &lt; op) {                              from += wsize + wnext - op;
136                         op -= wnext;
137                         if (op &lt; len) {                                     len -= op;
138                             do {
139                                 PUP(out) = PUP(from);
140                             } while (--op);
141                             from = window - OFF;
142                             if (wnext &lt; len) {                                  op = wnext;
143                                 len -= op;
144                                 do {
145                                     PUP(out) = PUP(from);
146                                 } while (--op);
147                                 from = out - dist;                                  }
148                         }
149                     }
150                     else {                                              from += wnext - op;
151                         if (op &lt; len) {                                     len -= op;
152                             do {
153                                 PUP(out) = PUP(from);
154                             } while (--op);
155                             from = out - dist;                          }
156                     }
157                     while (len &gt; 2) {
158                         PUP(out) = PUP(from);
159                         PUP(out) = PUP(from);
160                         PUP(out) = PUP(from);
161                         len -= 3;
162                     }
163                     if (len) {
164                         PUP(out) = PUP(from);
165                         if (len &gt; 1)
166                             PUP(out) = PUP(from);
167                     }
168                 }
169                 else {
170                     from = out - dist;                              do {                                                PUP(out) = PUP(from);
171                         PUP(out) = PUP(from);
172                         PUP(out) = PUP(from);
173                         len -= 3;
174                     } while (len &gt; 2);
175                     if (len) {
176                         PUP(out) = PUP(from);
177                         if (len &gt; 1)
178                             PUP(out) = PUP(from);
179                     }
180                 }
181             }
182             else if ((op &amp; 64) == 0) {                          here = dcode[here.val + (hold &amp; ((1U &lt;&lt; op) - 1))];
183                 goto dodist;
184             }
185             else {
186                 strm-&gt;msg = (char *)"invalid distance code";
187                 state-&gt;mode = BAD;
188                 break;
189             }
190         }
191         else if ((op &amp; 64) == 0) {                          here = lcode[here.val + (hold &amp; ((1U &lt;&lt; op) - 1))];
192             goto dolen;
193         }
194         else if (op &amp; 32) {                                 Tracevv((stderr, "inflate:         end of block\n"));
195             state-&gt;mode = TYPE;
196             break;
197         }
198         else {
199             strm-&gt;msg = (char *)"invalid literal/length code";
200             state-&gt;mode = BAD;
201             break;
202         }
203     } while (in &lt; last &amp;&amp; out &lt; end);
204     len = bits &gt;&gt; 3;
205     in -= len;
206     bits -= len &lt;&lt; 3;
207     hold &amp;= (1U &lt;&lt; bits) - 1;
208     strm-&gt;next_in = in + OFF;
209     strm-&gt;next_out = out + OFF;
210     strm-&gt;avail_in = (unsigned)(in &lt; last ? 5 + (last - in) : 5 - (in - last));
211     strm-&gt;avail_out = (unsigned)(out &lt; end ?
212                                  257 + (end - out) : 257 - (out - end));
213     state-&gt;hold = hold;
214     state-&gt;bits = bits;
215     return;
216 }
#endif </pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
