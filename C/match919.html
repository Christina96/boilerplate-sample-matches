<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML><HEAD><TITLE>Matches for huffman.c & inffast.c</TITLE>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
</HEAD>
<body>
  <div style="align-items: center; display: flex; justify-content: space-around;">
    <div>
      <h3 align="center">
Matches for huffman.c & inffast.c
      </h3>
      <h1 align="center">
        5.6%
      </h1>
      <center>
        <a href="index.html" target="_top">
          INDEX
        </a>
        <span>-</span>
        <a href="help-en.html" target="_top">
          HELP
        </a>
      </center>
    </div>
    <div>
<TABLE BORDER="1" CELLSPACING="0" BGCOLOR="#d0d0d0">
<TR><TH><TH>huffman.c (10.15625%)<TH>inffast.c (3.9156628%)<TH>Tokens
<TR><TD BGCOLOR="#0000ff"><FONT COLOR="#0000ff">-</FONT><TD><A HREF="javascript:ZweiFrames('match919-0.html#0',2,'match919-1.html#0',3)" NAME="0">(101-108)<TD><A HREF="javascript:ZweiFrames('match919-0.html#0',2,'match919-1.html#0',3)" NAME="0">(99-113)</A><TD ALIGN=center><FONT COLOR="#ff0000">13</FONT>
</TABLE>
    </div>
  </div>
  <hr>
  <div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>huffman.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>

/*-------------------------------------------------------------*/
/*--- Huffman coding low-level stuff                        ---*/
/*---                                             huffman.c ---*/
/*-------------------------------------------------------------*/

/* ------------------------------------------------------------------
   This file is part of bzip2/libbzip2, a program and library for
   lossless, block-sorting data compression.

   bzip2/libbzip2 version 1.0.5 of 10 December 2007
   Copyright (C) 1996-2007 Julian Seward &lt;jseward@bzip.org&gt;

   Please read the WARNING, DISCLAIMER and PATENTS sections in the 
   README file.

   This program is released under the terms of the license contained
   in the file LICENSE.
   ------------------------------------------------------------------ */


#include &quot;bzlib_private.h&quot;

/*---------------------------------------------------*/
#define WEIGHTOF(zz0)  ((zz0) &amp; 0xffffff00)
#define DEPTHOF(zz1)   ((zz1) &amp; 0x000000ff)
#define MYMAX(zz2,zz3) ((zz2) &gt; (zz3) ? (zz2) : (zz3))

#define ADDWEIGHTS(zw1,zw2)                           \
   (WEIGHTOF(zw1)+WEIGHTOF(zw2)) |                    \
   (1 + MYMAX(DEPTHOF(zw1),DEPTHOF(zw2)))

#define UPHEAP(z)                                     \
{                                                     \
   Int32 zz, tmp;                                     \
   zz = z; tmp = heap[zz];                            \
   while (weight[tmp] &lt; weight[heap[zz &gt;&gt; 1]]) {      \
      heap[zz] = heap[zz &gt;&gt; 1];                       \
      zz &gt;&gt;= 1;                                       \
   }                                                  \
   heap[zz] = tmp;                                    \
}

#define DOWNHEAP(z)                                   \
{                                                     \
   Int32 zz, yy, tmp;                                 \
   zz = z; tmp = heap[zz];                            \
   while (True) {                                     \
      yy = zz &lt;&lt; 1;                                   \
      if (yy &gt; nHeap) break;                          \
      if (yy &lt; nHeap &amp;&amp;                               \
          weight[heap[yy+1]] &lt; weight[heap[yy]])      \
         yy++;                                        \
      if (weight[tmp] &lt; weight[heap[yy]]) break;      \
      heap[zz] = heap[yy];                            \
      zz = yy;                                        \
   }                                                  \
   heap[zz] = tmp;                                    \
}


/*---------------------------------------------------*/
void BZ2_hbMakeCodeLengths ( UChar *len, 
                             Int32 *freq,
                             Int32 alphaSize,
                             Int32 maxLen )
{
   /*--
      Nodes and heap entries run from 1.  Entry 0
      for both the heap and nodes is a sentinel.
   --*/
   Int32 nNodes, nHeap, n1, n2, i, j, k;
   Bool  tooLong;

   Int32 heap   [ BZ_MAX_ALPHA_SIZE + 2 ];
   Int32 weight [ BZ_MAX_ALPHA_SIZE * 2 ];
   Int32 parent [ BZ_MAX_ALPHA_SIZE * 2 ]; 

   for (i = 0; i &lt; alphaSize; i++)
      weight[i+1] = (freq[i] == 0 ? 1 : freq[i]) &lt;&lt; 8;

   while (True) {

      nNodes = alphaSize;
      nHeap = 0;

      heap[0] = 0;
      weight[0] = 0;
      parent[0] = -2;

      for (i = 1; i &lt;= alphaSize; i++) {
         parent[i] = -1;
         nHeap++;
         heap[nHeap] = i;
         UPHEAP(nHeap);
      }

<A NAME="0"></A>      AssertH( nHeap &lt; (BZ_MAX_ALPHA_SIZE+2), 2001 );
   
      while (nHeap &gt; 1) {
<FONT color="#0000ff"><A HREF="javascript:ZweiFrames('match919-1.html#0',3,'match919-top.html#0',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>         n1 = heap[1]; heap[1] = heap[nHeap]; nHeap--; DOWNHEAP(1);
         n2 = heap[1]; heap[1] = heap[nHeap]; nHeap--; DOWNHEAP(1);
         nNodes++;
         parent[n1] = parent[n2] = nNodes;
         weight[nNodes] = ADDWEIGHTS(weight[n1], weight[n2]);
         parent[nNodes] = -1;
         nHeap++;
         heap[nHeap] = nNodes;</B></FONT>
         UPHEAP(nHeap);
      }

      AssertH( nNodes &lt; (BZ_MAX_ALPHA_SIZE * 2), 2002 );

      tooLong = False;
      for (i = 1; i &lt;= alphaSize; i++) {
         j = 0;
         k = i;
         while (parent[k] &gt;= 0) { k = parent[k]; j++; }
         len[i-1] = j;
         if (j &gt; maxLen) tooLong = True;
      }
      
      if (! tooLong) break;

      /* 17 Oct 04: keep-going condition for the following loop used
         to be 'i &lt; alphaSize', which missed the last element,
         theoretically leading to the possibility of the compressor
         looping.  However, this count-scaling step is only needed if
         one of the generated Huffman code words is longer than
         maxLen, which up to and including version 1.0.2 was 20 bits,
         which is extremely unlikely.  In version 1.0.3 maxLen was
         changed to 17 bits, which has minimal effect on compression
         ratio, but does mean this scaling step is used from time to
         time, enough to verify that it works.

         This means that bzip2-1.0.3 and later will only produce
         Huffman codes with a maximum length of 17 bits.  However, in
         order to preserve backwards compatibility with bitstreams
         produced by versions pre-1.0.3, the decompressor must still
         handle lengths of up to 20. */

      for (i = 1; i &lt;= alphaSize; i++) {
         j = weight[i] &gt;&gt; 8;
         j = 1 + (j / 2);
         weight[i] = j &lt;&lt; 8;
      }
   }
}


/*---------------------------------------------------*/
void BZ2_hbAssignCodes ( Int32 *code,
                         UChar *length,
                         Int32 minLen,
                         Int32 maxLen,
                         Int32 alphaSize )
{
   Int32 n, vec, i;

   vec = 0;
   for (n = minLen; n &lt;= maxLen; n++) {
      for (i = 0; i &lt; alphaSize; i++)
         if (length[i] == n) { code[i] = vec; vec++; };
      vec &lt;&lt;= 1;
   }
}


/*---------------------------------------------------*/
void BZ2_hbCreateDecodeTables ( Int32 *limit,
                                Int32 *base,
                                Int32 *perm,
                                UChar *length,
                                Int32 minLen,
                                Int32 maxLen,
                                Int32 alphaSize )
{
   Int32 pp, i, j, vec;

   pp = 0;
   for (i = minLen; i &lt;= maxLen; i++)
      for (j = 0; j &lt; alphaSize; j++)
         if (length[j] == i) { perm[pp] = j; pp++; };

   for (i = 0; i &lt; BZ_MAX_CODE_LEN; i++) base[i] = 0;
   for (i = 0; i &lt; alphaSize; i++) base[length[i]+1]++;

   for (i = 1; i &lt; BZ_MAX_CODE_LEN; i++) base[i] += base[i-1];

   for (i = 0; i &lt; BZ_MAX_CODE_LEN; i++) limit[i] = 0;
   vec = 0;

   for (i = minLen; i &lt;= maxLen; i++) {
      vec += (base[i+1] - base[i]);
      limit[i] = vec-1;
      vec &lt;&lt;= 1;
   }
   for (i = minLen + 1; i &lt;= maxLen; i++)
      base[i] = ((limit[i-1] + 1) &lt;&lt; 1) - base[i];
}


/*-------------------------------------------------------------*/
/*--- end                                         huffman.c ---*/
/*-------------------------------------------------------------*/
</PRE>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>inffast.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
/* inffast.c -- fast decoding
 * Copyright (C) 1995-2008, 2010 Mark Adler
 * For conditions of distribution and use, see copyright notice in zlib.h
 */

#include &quot;zutil.h&quot;
#include &quot;inftrees.h&quot;
#include &quot;inflate.h&quot;
#include &quot;inffast.h&quot;

#ifndef ASMINF

/* Allow machine dependent optimization for post-increment or pre-increment.
   Based on testing to date,
   Pre-increment preferred for:
   - PowerPC G3 (Adler)
   - MIPS R5000 (Randers-Pehrson)
   Post-increment preferred for:
   - none
   No measurable difference:
   - Pentium III (Anderson)
   - M68060 (Nikl)
 */
#ifdef POSTINC
#  define OFF 0
#  define PUP(a) *(a)++
#else
#  define OFF 1
#  define PUP(a) *++(a)
#endif

/*
   Decode literal, length, and distance codes and write out the resulting
   literal and match bytes until either not enough input or output is
   available, an end-of-block is encountered, or a data error is encountered.
   When large enough input and output buffers are supplied to inflate(), for
   example, a 16K input buffer and a 64K output buffer, more than 95% of the
   inflate execution time is spent in this routine.

   Entry assumptions:

        state-&gt;mode == LEN
        strm-&gt;avail_in &gt;= 6
        strm-&gt;avail_out &gt;= 258
        start &gt;= strm-&gt;avail_out
        state-&gt;bits &lt; 8

   On return, state-&gt;mode is one of:

        LEN -- ran out of enough output space or enough available input
        TYPE -- reached end of block code, inflate() to interpret next block
        BAD -- error in block data

   Notes:

    - The maximum input bits used by a length/distance pair is 15 bits for the
      length code, 5 bits for the length extra, 15 bits for the distance code,
      and 13 bits for the distance extra.  This totals 48 bits, or six bytes.
      Therefore if strm-&gt;avail_in &gt;= 6, then there is enough input to avoid
      checking for available input while decoding.

    - The maximum bytes that a single length/distance pair can output is 258
      bytes, which is the maximum length that can be coded.  inflate_fast()
      requires strm-&gt;avail_out &gt;= 258 for each loop to avoid checking for
      output space.
 */
void ZLIB_INTERNAL inflate_fast(strm, start)
z_streamp strm;
unsigned start;         /* inflate()'s starting value for strm-&gt;avail_out */
{
    struct inflate_state FAR *state;
    unsigned char FAR *in;      /* local strm-&gt;next_in */
    unsigned char FAR *last;    /* while in &lt; last, enough input available */
    unsigned char FAR *out;     /* local strm-&gt;next_out */
    unsigned char FAR *beg;     /* inflate()'s initial strm-&gt;next_out */
    unsigned char FAR *end;     /* while out &lt; end, enough space available */
#ifdef INFLATE_STRICT
    unsigned dmax;              /* maximum distance from zlib header */
#endif
    unsigned wsize;             /* window size or zero if not using window */
    unsigned whave;             /* valid bytes in the window */
    unsigned wnext;             /* window write index */
    unsigned char FAR *window;  /* allocated sliding window, if wsize != 0 */
    unsigned long hold;         /* local strm-&gt;hold */
    unsigned bits;              /* local strm-&gt;bits */
    code const FAR *lcode;      /* local strm-&gt;lencode */
    code const FAR *dcode;      /* local strm-&gt;distcode */
    unsigned lmask;             /* mask for first level of length codes */
    unsigned dmask;             /* mask for first level of distance codes */
    code here;                  /* retrieved table entry */
    unsigned op;                /* code bits, operation, extra bits, or */
                                /*  window position, window bytes to copy */
    unsigned len;               /* match length, unused bytes */
    unsigned dist;              /* match distance */
    unsigned char FAR *from;    /* where to copy match from */
<A NAME="0"></A>
    /* copy state to local variables */
    state = (struct inflate_state FAR *)strm-&gt;state;
<FONT color="#0000ff"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match919-0.html#0',2,'match919-top.html#0',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>    in = strm-&gt;next_in - OFF;
    last = in + (strm-&gt;avail_in - 5);
    out = strm-&gt;next_out - OFF;
    beg = out - (start - strm-&gt;avail_out);
    end = out + (strm-&gt;avail_out - 257);
#ifdef INFLATE_STRICT
    dmax = state-&gt;dmax;
#endif
    wsize = state-&gt;wsize;
    whave = state-&gt;whave;
    wnext = state-&gt;wnext;
    window = state-&gt;window;
    hold = state-&gt;hold;
    bits = state-&gt;bits;
    lcode = state-&gt;lencode;</B></FONT>
    dcode = state-&gt;distcode;
    lmask = (1U &lt;&lt; state-&gt;lenbits) - 1;
    dmask = (1U &lt;&lt; state-&gt;distbits) - 1;

    /* decode literals and length/distances until end-of-block or not enough
       input data or output space */
    do {
        if (bits &lt; 15) {
            hold += (unsigned long)(PUP(in)) &lt;&lt; bits;
            bits += 8;
            hold += (unsigned long)(PUP(in)) &lt;&lt; bits;
            bits += 8;
        }
        here = lcode[hold &amp; lmask];
      dolen:
        op = (unsigned)(here.bits);
        hold &gt;&gt;= op;
        bits -= op;
        op = (unsigned)(here.op);
        if (op == 0) {                          /* literal */
            Tracevv((stderr, here.val &gt;= 0x20 &amp;&amp; here.val &lt; 0x7f ?
                    &quot;inflate:         literal '%c'\n&quot; :
                    &quot;inflate:         literal 0x%02x\n&quot;, here.val));
            PUP(out) = (unsigned char)(here.val);
        }
        else if (op &amp; 16) {                     /* length base */
            len = (unsigned)(here.val);
            op &amp;= 15;                           /* number of extra bits */
            if (op) {
                if (bits &lt; op) {
                    hold += (unsigned long)(PUP(in)) &lt;&lt; bits;
                    bits += 8;
                }
                len += (unsigned)hold &amp; ((1U &lt;&lt; op) - 1);
                hold &gt;&gt;= op;
                bits -= op;
            }
            Tracevv((stderr, &quot;inflate:         length %u\n&quot;, len));
            if (bits &lt; 15) {
                hold += (unsigned long)(PUP(in)) &lt;&lt; bits;
                bits += 8;
                hold += (unsigned long)(PUP(in)) &lt;&lt; bits;
                bits += 8;
            }
            here = dcode[hold &amp; dmask];
          dodist:
            op = (unsigned)(here.bits);
            hold &gt;&gt;= op;
            bits -= op;
            op = (unsigned)(here.op);
            if (op &amp; 16) {                      /* distance base */
                dist = (unsigned)(here.val);
                op &amp;= 15;                       /* number of extra bits */
                if (bits &lt; op) {
                    hold += (unsigned long)(PUP(in)) &lt;&lt; bits;
                    bits += 8;
                    if (bits &lt; op) {
                        hold += (unsigned long)(PUP(in)) &lt;&lt; bits;
                        bits += 8;
                    }
                }
                dist += (unsigned)hold &amp; ((1U &lt;&lt; op) - 1);
#ifdef INFLATE_STRICT
                if (dist &gt; dmax) {
                    strm-&gt;msg = (char *)&quot;invalid distance too far back&quot;;
                    state-&gt;mode = BAD;
                    break;
                }
#endif
                hold &gt;&gt;= op;
                bits -= op;
                Tracevv((stderr, &quot;inflate:         distance %u\n&quot;, dist));
                op = (unsigned)(out - beg);     /* max distance in output */
                if (dist &gt; op) {                /* see if copy from window */
                    op = dist - op;             /* distance back in window */
                    if (op &gt; whave) {
                        if (state-&gt;sane) {
                            strm-&gt;msg =
                                (char *)&quot;invalid distance too far back&quot;;
                            state-&gt;mode = BAD;
                            break;
                        }
#ifdef INFLATE_ALLOW_INVALID_DISTANCE_TOOFAR_ARRR
                        if (len &lt;= op - whave) {
                            do {
                                PUP(out) = 0;
                            } while (--len);
                            continue;
                        }
                        len -= op - whave;
                        do {
                            PUP(out) = 0;
                        } while (--op &gt; whave);
                        if (op == 0) {
                            from = out - dist;
                            do {
                                PUP(out) = PUP(from);
                            } while (--len);
                            continue;
                        }
#endif
                    }
                    from = window - OFF;
                    if (wnext == 0) {           /* very common case */
                        from += wsize - op;
                        if (op &lt; len) {         /* some from window */
                            len -= op;
                            do {
                                PUP(out) = PUP(from);
                            } while (--op);
                            from = out - dist;  /* rest from output */
                        }
                    }
                    else if (wnext &lt; op) {      /* wrap around window */
                        from += wsize + wnext - op;
                        op -= wnext;
                        if (op &lt; len) {         /* some from end of window */
                            len -= op;
                            do {
                                PUP(out) = PUP(from);
                            } while (--op);
                            from = window - OFF;
                            if (wnext &lt; len) {  /* some from start of window */
                                op = wnext;
                                len -= op;
                                do {
                                    PUP(out) = PUP(from);
                                } while (--op);
                                from = out - dist;      /* rest from output */
                            }
                        }
                    }
                    else {                      /* contiguous in window */
                        from += wnext - op;
                        if (op &lt; len) {         /* some from window */
                            len -= op;
                            do {
                                PUP(out) = PUP(from);
                            } while (--op);
                            from = out - dist;  /* rest from output */
                        }
                    }
                    while (len &gt; 2) {
                        PUP(out) = PUP(from);
                        PUP(out) = PUP(from);
                        PUP(out) = PUP(from);
                        len -= 3;
                    }
                    if (len) {
                        PUP(out) = PUP(from);
                        if (len &gt; 1)
                            PUP(out) = PUP(from);
                    }
                }
                else {
                    from = out - dist;          /* copy direct from output */
                    do {                        /* minimum length is three */
                        PUP(out) = PUP(from);
                        PUP(out) = PUP(from);
                        PUP(out) = PUP(from);
                        len -= 3;
                    } while (len &gt; 2);
                    if (len) {
                        PUP(out) = PUP(from);
                        if (len &gt; 1)
                            PUP(out) = PUP(from);
                    }
                }
            }
            else if ((op &amp; 64) == 0) {          /* 2nd level distance code */
                here = dcode[here.val + (hold &amp; ((1U &lt;&lt; op) - 1))];
                goto dodist;
            }
            else {
                strm-&gt;msg = (char *)&quot;invalid distance code&quot;;
                state-&gt;mode = BAD;
                break;
            }
        }
        else if ((op &amp; 64) == 0) {              /* 2nd level length code */
            here = lcode[here.val + (hold &amp; ((1U &lt;&lt; op) - 1))];
            goto dolen;
        }
        else if (op &amp; 32) {                     /* end-of-block */
            Tracevv((stderr, &quot;inflate:         end of block\n&quot;));
            state-&gt;mode = TYPE;
            break;
        }
        else {
            strm-&gt;msg = (char *)&quot;invalid literal/length code&quot;;
            state-&gt;mode = BAD;
            break;
        }
    } while (in &lt; last &amp;&amp; out &lt; end);

    /* return unused bytes (on entry, bits &lt; 8, so in won't go too far back) */
    len = bits &gt;&gt; 3;
    in -= len;
    bits -= len &lt;&lt; 3;
    hold &amp;= (1U &lt;&lt; bits) - 1;

    /* update state and return */
    strm-&gt;next_in = in + OFF;
    strm-&gt;next_out = out + OFF;
    strm-&gt;avail_in = (unsigned)(in &lt; last ? 5 + (last - in) : 5 - (in - last));
    strm-&gt;avail_out = (unsigned)(out &lt; end ?
                                 257 + (end - out) : 257 - (out - end));
    state-&gt;hold = hold;
    state-&gt;bits = bits;
    return;
}

/*
   inflate_fast() speedups that turned out slower (on a PowerPC G3 750CXe):
   - Using bit fields for code structure
   - Different op definition to avoid &amp; for extra bits (do &amp; for table bits)
   - Three separate decoding do-loops for direct, window, and wnext == 0
   - Special case for distance &gt; 1 copies to do overlapped load and store copy
   - Explicit branch predictions (based on measured branch probabilities)
   - Deferring match copy and interspersed it with decoding subsequent codes
   - Swapping literal/length else
   - Swapping window/direct else
   - Larger unrolled copy loops (three is about right)
   - Moving len -= 3 statement into middle of loop
 */

#endif /* !ASMINF */
</PRE>
</div>
  </div>
</body>
</html>
