<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for huffman.c &amp; inffast.c</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for huffman.c &amp; inffast.c
      </h3>
<h1 align="center">
        5.6%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>huffman.c (10.15625%)<th>inffast.c (3.9156628%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(101-108)<td><a href="#" name="0">(99-113)</a><td align="center"><font color="#ff0000">13</font>
</td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>huffman.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
#include "bzlib_private.h"
#define WEIGHTOF(zz0)  ((zz0) &amp; 0xffffff00)
#define DEPTHOF(zz1)   ((zz1) &amp; 0x000000ff)
#define MYMAX(zz2,zz3) ((zz2) &gt; (zz3) ? (zz2) : (zz3))
#define ADDWEIGHTS(zw1,zw2)                           \
   (WEIGHTOF(zw1)+WEIGHTOF(zw2)) |                    \
   (1 + MYMAX(DEPTHOF(zw1),DEPTHOF(zw2)))
#define UPHEAP(z)                                     \
{                                                     \
   Int32 zz, tmp;                                     \
   zz = z; tmp = heap[zz];                            \
   while (weight[tmp] &lt; weight[heap[zz &gt;&gt; 1]]) {      \
      heap[zz] = heap[zz &gt;&gt; 1];                       \
      zz &gt;&gt;= 1;                                       \
   }                                                  \
   heap[zz] = tmp;                                    \
}
#define DOWNHEAP(z)                                   \
{                                                     \
   Int32 zz, yy, tmp;                                 \
   zz = z; tmp = heap[zz];                            \
   while (True) {                                     \
      yy = zz &lt;&lt; 1;                                   \
      if (yy &gt; nHeap) break;                          \
      if (yy &lt; nHeap &amp;&amp;                               \
          weight[heap[yy+1]] &lt; weight[heap[yy]])      \
         yy++;                                        \
      if (weight[tmp] &lt; weight[heap[yy]]) break;      \
      heap[zz] = heap[yy];                            \
      zz = yy;                                        \
   }                                                  \
   heap[zz] = tmp;                                    \
}
void BZ2_hbMakeCodeLengths ( UChar *len, 
                             Int32 *freq,
                             Int32 alphaSize,
                             Int32 maxLen )
{
   Int32 nNodes, nHeap, n1, n2, i, j, k;
   Bool  tooLong;
   Int32 heap   [ BZ_MAX_ALPHA_SIZE + 2 ];
   Int32 weight [ BZ_MAX_ALPHA_SIZE * 2 ];
   Int32 parent [ BZ_MAX_ALPHA_SIZE * 2 ]; 
   for (i = 0; i &lt; alphaSize; i++)
      weight[i+1] = (freq[i] == 0 ? 1 : freq[i]) &lt;&lt; 8;
   while (True) {
      nNodes = alphaSize;
      nHeap = 0;
      heap[0] = 0;
      weight[0] = 0;
      parent[0] = -2;
      for (i = 1; i &lt;= alphaSize; i++) {
         parent[i] = -1;
         nHeap++;
         heap[nHeap] = i;
         UPHEAP(nHeap);
      }
<a name="0"></a>      AssertH( nHeap &lt; (BZ_MAX_ALPHA_SIZE+2), 2001 );
      while (nHeap &gt; 1) {
<font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>         n1 = heap[1]; heap[1] = heap[nHeap]; nHeap--; DOWNHEAP(1);
         n2 = heap[1]; heap[1] = heap[nHeap]; nHeap--; DOWNHEAP(1);
         nNodes++;
         parent[n1] = parent[n2] = nNodes;
         weight[nNodes] = ADDWEIGHTS(weight[n1], weight[n2]);
         parent[nNodes] = -1;
         nHeap++;
         heap[nHeap] = nNodes;</b></font>
         UPHEAP(nHeap);
      }
      AssertH( nNodes &lt; (BZ_MAX_ALPHA_SIZE * 2), 2002 );
      tooLong = False;
      for (i = 1; i &lt;= alphaSize; i++) {
         j = 0;
         k = i;
         while (parent[k] &gt;= 0) { k = parent[k]; j++; }
         len[i-1] = j;
         if (j &gt; maxLen) tooLong = True;
      }
      if (! tooLong) break;
      for (i = 1; i &lt;= alphaSize; i++) {
         j = weight[i] &gt;&gt; 8;
         j = 1 + (j / 2);
         weight[i] = j &lt;&lt; 8;
      }
   }
}
void BZ2_hbAssignCodes ( Int32 *code,
                         UChar *length,
                         Int32 minLen,
                         Int32 maxLen,
                         Int32 alphaSize )
{
   Int32 n, vec, i;
   vec = 0;
   for (n = minLen; n &lt;= maxLen; n++) {
      for (i = 0; i &lt; alphaSize; i++)
         if (length[i] == n) { code[i] = vec; vec++; };
      vec &lt;&lt;= 1;
   }
}
void BZ2_hbCreateDecodeTables ( Int32 *limit,
                                Int32 *base,
                                Int32 *perm,
                                UChar *length,
                                Int32 minLen,
                                Int32 maxLen,
                                Int32 alphaSize )
{
   Int32 pp, i, j, vec;
   pp = 0;
   for (i = minLen; i &lt;= maxLen; i++)
      for (j = 0; j &lt; alphaSize; j++)
         if (length[j] == i) { perm[pp] = j; pp++; };
   for (i = 0; i &lt; BZ_MAX_CODE_LEN; i++) base[i] = 0;
   for (i = 0; i &lt; alphaSize; i++) base[length[i]+1]++;
   for (i = 1; i &lt; BZ_MAX_CODE_LEN; i++) base[i] += base[i-1];
   for (i = 0; i &lt; BZ_MAX_CODE_LEN; i++) limit[i] = 0;
   vec = 0;
   for (i = minLen; i &lt;= maxLen; i++) {
      vec += (base[i+1] - base[i]);
      limit[i] = vec-1;
      vec &lt;&lt;= 1;
   }
   for (i = minLen + 1; i &lt;= maxLen; i++)
      base[i] = ((limit[i-1] + 1) &lt;&lt; 1) - base[i];
}
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>inffast.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
#include "zutil.h"
#include "inftrees.h"
#include "inflate.h"
#include "inffast.h"
#ifndef ASMINF
#ifdef POSTINC
#  define OFF 0
#  define PUP(a) *(a)++
#else
#  define OFF 1
#  define PUP(a) *++(a)
#endif
void ZLIB_INTERNAL inflate_fast(strm, start)
z_streamp strm;
unsigned start;         {
    struct inflate_state FAR *state;
    unsigned char FAR *in;          unsigned char FAR *last;        unsigned char FAR *out;         unsigned char FAR *beg;         unsigned char FAR *end;     #ifdef INFLATE_STRICT
    unsigned dmax;              #endif
    unsigned wsize;                 unsigned whave;                 unsigned wnext;                 unsigned char FAR *window;      unsigned long hold;             unsigned bits;                  code const FAR *lcode;          code const FAR *dcode;          unsigned lmask;                 unsigned dmask;                 code here;                      unsigned op;                    unsigned len;                   unsigned dist;                  unsigned char FAR *from;    <a name="0"></a>
    state = (struct inflate_state FAR *)strm-&gt;state;
<font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>    in = strm-&gt;next_in - OFF;
    last = in + (strm-&gt;avail_in - 5);
    out = strm-&gt;next_out - OFF;
    beg = out - (start - strm-&gt;avail_out);
    end = out + (strm-&gt;avail_out - 257);
#ifdef INFLATE_STRICT
    dmax = state-&gt;dmax;
#endif
    wsize = state-&gt;wsize;
    whave = state-&gt;whave;
    wnext = state-&gt;wnext;
    window = state-&gt;window;
    hold = state-&gt;hold;
    bits = state-&gt;bits;
    lcode = state-&gt;lencode;</b></font>
    dcode = state-&gt;distcode;
    lmask = (1U &lt;&lt; state-&gt;lenbits) - 1;
    dmask = (1U &lt;&lt; state-&gt;distbits) - 1;
    do {
        if (bits &lt; 15) {
            hold += (unsigned long)(PUP(in)) &lt;&lt; bits;
            bits += 8;
            hold += (unsigned long)(PUP(in)) &lt;&lt; bits;
            bits += 8;
        }
        here = lcode[hold &amp; lmask];
      dolen:
        op = (unsigned)(here.bits);
        hold &gt;&gt;= op;
        bits -= op;
        op = (unsigned)(here.op);
        if (op == 0) {                                      Tracevv((stderr, here.val &gt;= 0x20 &amp;&amp; here.val &lt; 0x7f ?
                    "inflate:         literal '%c'\n" :
                    "inflate:         literal 0x%02x\n", here.val));
            PUP(out) = (unsigned char)(here.val);
        }
        else if (op &amp; 16) {                                 len = (unsigned)(here.val);
            op &amp;= 15;                                       if (op) {
                if (bits &lt; op) {
                    hold += (unsigned long)(PUP(in)) &lt;&lt; bits;
                    bits += 8;
                }
                len += (unsigned)hold &amp; ((1U &lt;&lt; op) - 1);
                hold &gt;&gt;= op;
                bits -= op;
            }
            Tracevv((stderr, "inflate:         length %u\n", len));
            if (bits &lt; 15) {
                hold += (unsigned long)(PUP(in)) &lt;&lt; bits;
                bits += 8;
                hold += (unsigned long)(PUP(in)) &lt;&lt; bits;
                bits += 8;
            }
            here = dcode[hold &amp; dmask];
          dodist:
            op = (unsigned)(here.bits);
            hold &gt;&gt;= op;
            bits -= op;
            op = (unsigned)(here.op);
            if (op &amp; 16) {                                      dist = (unsigned)(here.val);
                op &amp;= 15;                                       if (bits &lt; op) {
                    hold += (unsigned long)(PUP(in)) &lt;&lt; bits;
                    bits += 8;
                    if (bits &lt; op) {
                        hold += (unsigned long)(PUP(in)) &lt;&lt; bits;
                        bits += 8;
                    }
                }
                dist += (unsigned)hold &amp; ((1U &lt;&lt; op) - 1);
#ifdef INFLATE_STRICT
                if (dist &gt; dmax) {
                    strm-&gt;msg = (char *)"invalid distance too far back";
                    state-&gt;mode = BAD;
                    break;
                }
#endif
                hold &gt;&gt;= op;
                bits -= op;
                Tracevv((stderr, "inflate:         distance %u\n", dist));
                op = (unsigned)(out - beg);                     if (dist &gt; op) {                                    op = dist - op;                                 if (op &gt; whave) {
                        if (state-&gt;sane) {
                            strm-&gt;msg =
                                (char *)"invalid distance too far back";
                            state-&gt;mode = BAD;
                            break;
                        }
#ifdef INFLATE_ALLOW_INVALID_DISTANCE_TOOFAR_ARRR
                        if (len &lt;= op - whave) {
                            do {
                                PUP(out) = 0;
                            } while (--len);
                            continue;
                        }
                        len -= op - whave;
                        do {
                            PUP(out) = 0;
                        } while (--op &gt; whave);
                        if (op == 0) {
                            from = out - dist;
                            do {
                                PUP(out) = PUP(from);
                            } while (--len);
                            continue;
                        }
#endif
                    }
                    from = window - OFF;
                    if (wnext == 0) {                                   from += wsize - op;
                        if (op &lt; len) {                                     len -= op;
                            do {
                                PUP(out) = PUP(from);
                            } while (--op);
                            from = out - dist;                          }
                    }
                    else if (wnext &lt; op) {                              from += wsize + wnext - op;
                        op -= wnext;
                        if (op &lt; len) {                                     len -= op;
                            do {
                                PUP(out) = PUP(from);
                            } while (--op);
                            from = window - OFF;
                            if (wnext &lt; len) {                                  op = wnext;
                                len -= op;
                                do {
                                    PUP(out) = PUP(from);
                                } while (--op);
                                from = out - dist;                                  }
                        }
                    }
                    else {                                              from += wnext - op;
                        if (op &lt; len) {                                     len -= op;
                            do {
                                PUP(out) = PUP(from);
                            } while (--op);
                            from = out - dist;                          }
                    }
                    while (len &gt; 2) {
                        PUP(out) = PUP(from);
                        PUP(out) = PUP(from);
                        PUP(out) = PUP(from);
                        len -= 3;
                    }
                    if (len) {
                        PUP(out) = PUP(from);
                        if (len &gt; 1)
                            PUP(out) = PUP(from);
                    }
                }
                else {
                    from = out - dist;                              do {                                                PUP(out) = PUP(from);
                        PUP(out) = PUP(from);
                        PUP(out) = PUP(from);
                        len -= 3;
                    } while (len &gt; 2);
                    if (len) {
                        PUP(out) = PUP(from);
                        if (len &gt; 1)
                            PUP(out) = PUP(from);
                    }
                }
            }
            else if ((op &amp; 64) == 0) {                          here = dcode[here.val + (hold &amp; ((1U &lt;&lt; op) - 1))];
                goto dodist;
            }
            else {
                strm-&gt;msg = (char *)"invalid distance code";
                state-&gt;mode = BAD;
                break;
            }
        }
        else if ((op &amp; 64) == 0) {                          here = lcode[here.val + (hold &amp; ((1U &lt;&lt; op) - 1))];
            goto dolen;
        }
        else if (op &amp; 32) {                                 Tracevv((stderr, "inflate:         end of block\n"));
            state-&gt;mode = TYPE;
            break;
        }
        else {
            strm-&gt;msg = (char *)"invalid literal/length code";
            state-&gt;mode = BAD;
            break;
        }
    } while (in &lt; last &amp;&amp; out &lt; end);
    len = bits &gt;&gt; 3;
    in -= len;
    bits -= len &lt;&lt; 3;
    hold &amp;= (1U &lt;&lt; bits) - 1;
    strm-&gt;next_in = in + OFF;
    strm-&gt;next_out = out + OFF;
    strm-&gt;avail_in = (unsigned)(in &lt; last ? 5 + (last - in) : 5 - (in - last));
    strm-&gt;avail_out = (unsigned)(out &lt; end ?
                                 257 + (end - out) : 257 - (out - end));
    state-&gt;hold = hold;
    state-&gt;bits = bits;
    return;
}
#endif </pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
