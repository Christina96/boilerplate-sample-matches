<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html><head><title>Matches for inf-adopted-user.c &amp; inf-text-move-operation.c</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for inf-adopted-user.c &amp; inf-text-move-operation.c
      </h3>
<h1 align="center">
        26.7%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>inf-adopted-user.c (45.37037%)<th>inf-text-move-operation.c (18.918919%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(152-185)<td><a href="#" name="0">(78-111)</a><td align="center"><font color="#ff0000">21</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(109-136)<td><a href="#" name="1">(55-76)</a><td align="center"><font color="#b60000">15</font>
<tr onclick='openModal("#980517")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#980517"><font color="#980517">-</font><td><a href="#" name="2">(68-92)<td><a href="#" name="2">(244-290)</a><td align="center"><font color="#9d0000">13</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>inf-adopted-user.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
/* libinfinity - a GObject-based infinote implementation
 * Copyright (C) 2007-2015 Armin Burgmeier &lt;armin@arbur.net&gt;
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston,
 * MA 02110-1301, USA.
 */

/**
 * SECTION:inf-adopted-user
 * @title: InfAdoptedUser
 * @short_description: User in a #InfAdoptedUser.
 * @include: libinfinity/adopted/inf-adopted-user.h
 * @see_also: #InfAdoptedSession, #InfAdoptedAlgorithm
 * @stability: Unstable
 *
 * #InfAdoptedUser is a #InfUser&lt;!-- --&gt;-derived class that is used in
 * #InfAdoptedSession. It holds all user-specific information that is needed
 * by #InfAdoptedAlgorithm to handle the concurrency control. This includes
 * the user's request log which stores all the requests made by the user and
 * a state vector which specifies the document state that the user has, as
 * known to the local host. This information is extracted from the most recent
 * request received from the user.
 */

#include &lt;libinfinity/adopted/inf-adopted-user.h&gt;
#include &lt;libinfinity/adopted/inf-adopted-state-vector.h&gt;

typedef struct _InfAdoptedUserPrivate InfAdoptedUserPrivate;
struct _InfAdoptedUserPrivate {
  InfAdoptedStateVector* vector;
  InfAdoptedRequestLog* log;
};

enum {
  PROP_0,

  PROP_VECTOR,
  PROP_REQUEST_LOG
};

#define INF_ADOPTED_USER_GET_PRIVATE(obj) (G_TYPE_INSTANCE_GET_PRIVATE((obj), INF_ADOPTED_TYPE_USER, InfAdoptedUserPrivate))
#define INF_ADOPTED_USER_PRIVATE(obj)     ((InfAdoptedUserPrivate*)(obj)-&gt;priv)

G_DEFINE_TYPE_WITH_CODE(InfAdoptedUser, inf_adopted_user, INF_TYPE_USER,
  G_ADD_PRIVATE(InfAdoptedUser))

static void
inf_adopted_user_init(InfAdoptedUser* user)
{
  InfAdoptedUserPrivate* priv;
  user-&gt;priv = INF_ADOPTED_USER_GET_PRIVATE(user);
  priv = INF_ADOPTED_USER_PRIVATE(user);
<a name="2"></a>
  priv-&gt;vector = inf_adopted_state_vector_new();
  priv-&gt;log = NULL;
<font color="#980517"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>}

static void
inf_adopted_user_constructed(GObject* object)
{
  InfAdoptedUser* user;
  InfAdoptedUserPrivate* priv;

  G_OBJECT_CLASS(inf_adopted_user_parent_class)-&gt;constructed(object);

  user = INF_ADOPTED_USER(object);
  priv = INF_ADOPTED_USER_PRIVATE(user);

  /* Create empty request log if none was set during construction */
  priv-&gt;log = inf_adopted_request_log_new(inf_user_get_id(INF_USER(user)));
}

static void
inf_adopted_user_dispose(GObject* object)
{
  InfAdoptedUser* user;
  InfAdoptedUserPrivate* priv;

  user = INF_ADOPTED_USER(object);
  priv = INF_ADOPTED_USER_PRIVATE(user);</b></font>

  if(priv-&gt;log != NULL)
  {
    g_object_unref(priv-&gt;log);
    priv-&gt;log = NULL;
  }

  G_OBJECT_CLASS(inf_adopted_user_parent_class)-&gt;dispose(object);
}

static void
inf_adopted_user_finalize(GObject* object)
{
<a name="1"></a>  InfAdoptedUser* user;
  InfAdoptedUserPrivate* priv;

<font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>  user = INF_ADOPTED_USER(object);
  priv = INF_ADOPTED_USER_PRIVATE(user);

  inf_adopted_state_vector_free(priv-&gt;vector);

  G_OBJECT_CLASS(inf_adopted_user_parent_class)-&gt;finalize(object);
}

static void
inf_adopted_user_set_property(GObject* object,
                              guint prop_id,
                              const GValue* value,
                              GParamSpec* pspec)
{
  InfAdoptedUser* user;
  InfAdoptedUserPrivate* priv;
  InfAdoptedRequestLog* log;

  user = INF_ADOPTED_USER(object);
  priv = INF_ADOPTED_USER_PRIVATE(user);

  switch(prop_id)
  {
  case PROP_VECTOR:
    inf_adopted_state_vector_free(priv-&gt;vector);
    priv-&gt;vector = g_value_dup_boxed(value);
    break;
  case PROP_REQUEST_LOG:</b></font>
    g_assert(priv-&gt;log == NULL); /* construct only */

    if(g_value_get_object(value) != NULL)
    {
      log = INF_ADOPTED_REQUEST_LOG(g_value_get_object(value));

      g_assert(
        inf_adopted_request_log_get_user_id(log) ==
        inf_user_get_id(INF_USER(user))
      );

      priv-&gt;log = log;
<a name="0"></a>      g_object_ref(log);
    }

<font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>    break;
  default:
    G_OBJECT_WARN_INVALID_PROPERTY_ID(object, prop_id, pspec);
    break;
  }
}

static void
inf_adopted_user_get_property(GObject* object,
                              guint prop_id,
                              GValue* value,
                              GParamSpec* pspec)
{
  InfAdoptedUser* user;
  InfAdoptedUserPrivate* priv;

  user = INF_ADOPTED_USER(object);
  priv = INF_ADOPTED_USER_PRIVATE(user);

  switch(prop_id)
  {
  case PROP_VECTOR:
    g_value_set_boxed(value, priv-&gt;vector);
    break;
  case PROP_REQUEST_LOG:
    g_value_set_object(value, G_OBJECT(priv-&gt;log));
    break;
  default:
    G_OBJECT_WARN_INVALID_PROPERTY_ID(object, prop_id, pspec);
    break;
  }
}

static void</b></font>
inf_adopted_user_class_init(InfAdoptedUserClass* user_class)
{
  GObjectClass* object_class;
  object_class = G_OBJECT_CLASS(user_class);

  object_class-&gt;constructed = inf_adopted_user_constructed;
  object_class-&gt;dispose = inf_adopted_user_dispose;
  object_class-&gt;finalize = inf_adopted_user_finalize;
  object_class-&gt;set_property = inf_adopted_user_set_property;
  object_class-&gt;get_property = inf_adopted_user_get_property;

  g_object_class_install_property(
    object_class,
    PROP_VECTOR,
    g_param_spec_boxed(
      "vector",
      "State vector",
      "The state this user is currently at",
      INF_ADOPTED_TYPE_STATE_VECTOR,
      G_PARAM_READWRITE
    )
  );

  g_object_class_install_property(
    object_class,
    PROP_REQUEST_LOG,
    g_param_spec_object(
      "request-log",
      "Request log",
      "Request log of this user",
      INF_ADOPTED_TYPE_REQUEST_LOG,
      G_PARAM_READWRITE | G_PARAM_CONSTRUCT_ONLY
    )
  );
}

/**
 * inf_adopted_user_get_component:
 * @user: A #InfAdoptedUser.
 * @id: The component to retrieve.
 *
 * Returns the amount of requests @user is guaranteed to have processed from
 * the user with ID @id.
 *
 * Returns: The number of requests @user has processed from @id.
 **/
guint
inf_adopted_user_get_component(InfAdoptedUser* user,
                               guint id)
{
  g_return_val_if_fail(INF_ADOPTED_IS_USER(user), 0);
  g_return_val_if_fail(id != 0, 0);

  return inf_adopted_state_vector_get(
    INF_ADOPTED_USER_PRIVATE(user)-&gt;vector,
    id
  );
}

/**
 * inf_adopted_user_get_vector:
 * @user: A #InfAdoptedUser.
 *
 * Returns the current vector time of @user.
 *
 * Returns: (transfer none): The current vector time of @user.
 **/
InfAdoptedStateVector*
inf_adopted_user_get_vector(InfAdoptedUser* user)
{
  g_return_val_if_fail(INF_ADOPTED_IS_USER(user), NULL);
  return INF_ADOPTED_USER_PRIVATE(user)-&gt;vector;
}

/**
 * inf_adopted_user_set_vector:
 * @user: A #InfAdoptedUser.
 * @vec: A #InfAdoptedStateVector.
 *
 * Updates the state vector of @user. This function takes ownership of @vec.
 **/
void
inf_adopted_user_set_vector(InfAdoptedUser* user,
                            InfAdoptedStateVector* vec)
{
  InfAdoptedUserPrivate* priv;

  g_return_if_fail(INF_ADOPTED_IS_USER(user));
  g_return_if_fail(vec != NULL);

  priv = INF_ADOPTED_USER_PRIVATE(user);

  inf_adopted_state_vector_free(priv-&gt;vector);
  priv-&gt;vector = vec;

  g_object_notify(G_OBJECT(user), "vector");
}

/**
 * inf_adopted_user_get_request_log:
 * @user: A #InfAdoptedUser.
 *
 * Returns the request log of @user.
 *
 * Returns: (transfer none): User's #InfAdoptedRequestLog.
 **/
InfAdoptedRequestLog*
inf_adopted_user_get_request_log(InfAdoptedUser* user)
{
  g_return_val_if_fail(INF_ADOPTED_IS_USER(user), NULL);
  return INF_ADOPTED_USER_PRIVATE(user)-&gt;log;
}

/* vim:set et sw=2 ts=2: */
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>inf-text-move-operation.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
/* libinfinity - a GObject-based infinote implementation
 * Copyright (C) 2007-2015 Armin Burgmeier &lt;armin@arbur.net&gt;
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston,
 * MA 02110-1301, USA.
 */

#include &lt;libinftext/inf-text-move-operation.h&gt;
#include &lt;libinftext/inf-text-insert-operation.h&gt;
#include &lt;libinftext/inf-text-delete-operation.h&gt;
#include &lt;libinftext/inf-text-buffer.h&gt;
#include &lt;libinftext/inf-text-user.h&gt;

#include &lt;libinfinity/adopted/inf-adopted-operation.h&gt;
#include &lt;libinfinity/inf-i18n.h&gt;

typedef struct _InfTextMoveOperationPrivate InfTextMoveOperationPrivate;
struct _InfTextMoveOperationPrivate {
  guint position;
  gint length;
};

enum {
  PROP_0,

  PROP_POSITION,
  PROP_LENGTH
};

#define INF_TEXT_MOVE_OPERATION_PRIVATE(obj) (G_TYPE_INSTANCE_GET_PRIVATE((obj), INF_TEXT_TYPE_MOVE_OPERATION, InfTextMoveOperationPrivate))

static void inf_text_move_operation_operation_iface_init(InfAdoptedOperationInterface* iface);
G_DEFINE_TYPE_WITH_CODE(InfTextMoveOperation, inf_text_move_operation, G_TYPE_OBJECT,
  G_ADD_PRIVATE(InfTextMoveOperation)
  G_IMPLEMENT_INTERFACE(INF_ADOPTED_TYPE_OPERATION, inf_text_move_operation_operation_iface_init))

static void
inf_text_move_operation_init(InfTextMoveOperation* operation)
{
<a name="1"></a>  InfTextMoveOperationPrivate* priv;
  priv = INF_TEXT_MOVE_OPERATION_PRIVATE(operation);

<font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>  priv-&gt;position = 0;
  priv-&gt;length = 0;
}

static void
inf_text_move_operation_set_property(GObject* object,
                                     guint prop_id,
                                     const GValue* value,
                                     GParamSpec* pspec)
{
  InfTextMoveOperation* operation;
  InfTextMoveOperationPrivate* priv;

  operation = INF_TEXT_MOVE_OPERATION(object);
  priv = INF_TEXT_MOVE_OPERATION_PRIVATE(operation);

  switch(prop_id)
  {
  case PROP_POSITION:
    priv-&gt;position = g_value_get_uint(value);
<a name="0"></a>    break;
  case PROP_LENGTH:</b></font>
    priv-&gt;length = g_value_get_int(value);
<font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>    break;
  default:
    G_OBJECT_WARN_INVALID_PROPERTY_ID(object, prop_id, pspec);
    break;
  }
}

static void
inf_text_move_operation_get_property(GObject* object,
                                     guint prop_id,
                                     GValue* value,
                                     GParamSpec* pspec)
{
  InfTextMoveOperation* operation;
  InfTextMoveOperationPrivate* priv;

  operation = INF_TEXT_MOVE_OPERATION(object);
  priv = INF_TEXT_MOVE_OPERATION_PRIVATE(operation);

  switch(prop_id)
  {
  case PROP_POSITION:
    g_value_set_uint(value, priv-&gt;position);
    break;
  case PROP_LENGTH:
    g_value_set_int(value, priv-&gt;length);
    break;
  default:
    G_OBJECT_WARN_INVALID_PROPERTY_ID(object, prop_id, pspec);
    break;
  }
}

static gboolean</b></font>
inf_text_move_operation_need_concurrency_id(InfAdoptedOperation* operation,
                                            InfAdoptedOperation* against)
{
  g_assert(INF_TEXT_IS_MOVE_OPERATION(operation));
  return FALSE;
}

static InfAdoptedOperation*
inf_text_move_operation_transform(InfAdoptedOperation* operation,
                                  InfAdoptedOperation* against,
                                  InfAdoptedOperation* operation_lcs,
                                  InfAdoptedOperation* against_lcs,
                                  gint concurrency_id)
{
  InfTextMoveOperationPrivate* priv;
  guint new_pos;
  gint new_len;

  g_assert(INF_TEXT_IS_MOVE_OPERATION(operation));

  priv = INF_TEXT_MOVE_OPERATION_PRIVATE(operation);
  new_pos = priv-&gt;position;
  new_len = priv-&gt;length;

  if(INF_TEXT_IS_INSERT_OPERATION(against))
  {
    inf_text_move_operation_transform_insert(
      inf_text_insert_operation_get_position(
        INF_TEXT_INSERT_OPERATION(against)
      ),
      inf_text_insert_operation_get_length(
        INF_TEXT_INSERT_OPERATION(against)
      ),
      &amp;new_pos,
      &amp;new_len,
      TRUE /* left gravity */
    );
  }
  else if(INF_TEXT_IS_DELETE_OPERATION(against))
  {
    inf_text_move_operation_transform_delete(
      inf_text_delete_operation_get_position(
        INF_TEXT_DELETE_OPERATION(against)
      ),
      inf_text_delete_operation_get_length(
        INF_TEXT_DELETE_OPERATION(against)
      ),
      &amp;new_pos,
      &amp;new_len
    );
  }
  else
  {
    g_assert_not_reached();
    return NULL;
  }

  return INF_ADOPTED_OPERATION(
    g_object_new(
      INF_TEXT_TYPE_MOVE_OPERATION,
      "position", new_pos,
      "length", new_len,
      NULL
    )
  );
}

static InfAdoptedOperation*
inf_text_move_operation_copy(InfAdoptedOperation* operation)
{
  InfTextMoveOperationPrivate* priv;
  GObject* object;

  g_assert(INF_TEXT_IS_MOVE_OPERATION(operation));

  priv = INF_TEXT_MOVE_OPERATION_PRIVATE(operation);

  object = g_object_new(
    INF_TEXT_TYPE_MOVE_OPERATION,
    "position", priv-&gt;position,
    "length", priv-&gt;length,
    NULL
  );

  return INF_ADOPTED_OPERATION(object);
}

static InfAdoptedOperationFlags
inf_text_move_operation_get_flags(InfAdoptedOperation* operation)
{
  /* Does not affect the buffer */
  return 0;
}

static gboolean
inf_text_move_operation_apply(InfAdoptedOperation* operation,
                              InfAdoptedUser* by,
                              InfBuffer* buffer,
                              GError** error)
{
  InfTextMoveOperationPrivate* priv;
  guint length;

  g_assert(INF_TEXT_IS_MOVE_OPERATION(operation));
  g_assert(INF_TEXT_IS_USER(by));

  priv = INF_TEXT_MOVE_OPERATION_PRIVATE(operation);  
  length = inf_text_buffer_get_length(INF_TEXT_BUFFER(buffer));

  if(priv-&gt;position &gt; length ||
     priv-&gt;position + priv-&gt;length &gt; length)
  {
    g_set_error_literal(
      error,
      g_quark_from_static_string("INF_TEXT_OPERATION_ERROR"),
      INF_TEXT_OPERATION_ERROR_INVALID_MOVE,
      _("Attempt to move cursor or selection beyond the end of the document")
    );

    return FALSE;
  }
  else
  {
    inf_text_user_set_selection(
      INF_TEXT_USER(by),
      priv-&gt;position,
      priv-&gt;length,
      TRUE /* explicit move request */
    );
<a name="2"></a>
    return TRUE;
  }
<font color="#980517"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>}

static void
inf_text_move_operation_class_init(
  InfTextMoveOperationClass* move_operation_class)
{
  GObjectClass* object_class;
  object_class = G_OBJECT_CLASS(move_operation_class);

  object_class-&gt;set_property = inf_text_move_operation_set_property;
  object_class-&gt;get_property = inf_text_move_operation_get_property;

  g_object_class_install_property(
    object_class,
    PROP_POSITION,
    g_param_spec_uint(
      "position",
      "Position",
      "Position where to place the user's caret at",
      0,
      G_MAXUINT,
      0,
      G_PARAM_READWRITE | G_PARAM_CONSTRUCT_ONLY
    )
  );

  g_object_class_install_property(
    object_class,
    PROP_LENGTH,
    g_param_spec_int(
      "length",
      "Length",
      "The number of characters of the selected text",
      G_MININT,
      G_MAXINT,
      0,
      G_PARAM_READWRITE | G_PARAM_CONSTRUCT_ONLY
    )
  );
}

static void
inf_text_move_operation_operation_iface_init(
  InfAdoptedOperationInterface* iface)
{
  iface-&gt;need_concurrency_id = inf_text_move_operation_need_concurrency_id;
  iface-&gt;transform = inf_text_move_operation_transform;</b></font>
  iface-&gt;copy = inf_text_move_operation_copy;
  iface-&gt;get_flags = inf_text_move_operation_get_flags;
  iface-&gt;apply = inf_text_move_operation_apply;
  iface-&gt;apply_transformed = NULL;
  iface-&gt;revert = NULL;
}

/**
 * inf_text_move_operation_new: (constructor)
 * @position: The position to place the user's caret at.
 * @length: The number of characters to select. Negative means selection
 * towards the beginning of the buffer.
 *
 * Creates a new move operation that, when applied, changes the caret and
 * selection of the applying user.
 *
 * Returns: (transfer full): A new #InfTextMoveOperation.
 **/
InfTextMoveOperation*
inf_text_move_operation_new(guint position,
                            gint length)
{
  GObject* object;

  object = g_object_new(
    INF_TEXT_TYPE_MOVE_OPERATION,
    "position", position,
    "length", length,
    NULL
  );

  return INF_TEXT_MOVE_OPERATION(object);
}

/**
 * inf_text_move_operation_get_position:
 * @operation: A #InfTextMoveOperation.
 *
 * Returns the position at which @operation places the user's cursor.
 *
 * Returns: The position of @operation.
 **/
guint
inf_text_move_operation_get_position(InfTextMoveOperation* operation)
{
  g_return_val_if_fail(INF_TEXT_IS_MOVE_OPERATION(operation), 0);
  return INF_TEXT_MOVE_OPERATION_PRIVATE(operation)-&gt;position;
}

/**
 * inf_text_move_operation_get_length:
 * @operation: A #InfTextMoveOperation.
 *
 * Returns the length to which @operation changes the user's selection.
 * Negative means selection towards the beginning of the buffer.
 *
 * Returns: The length of @operation.
 **/
gint
inf_text_move_operation_get_length(InfTextMoveOperation* operation)
{
  g_return_val_if_fail(INF_TEXT_IS_MOVE_OPERATION(operation), 0);
  return INF_TEXT_MOVE_OPERATION_PRIVATE(operation)-&gt;length;
}

/**
 * inf_text_move_operation_transform_insert:
 * @insert_position: The position at which text is inserted.
 * @insert_length: The number of inserted characters.
 * @move_position: (inout): Points to the character offset to which the caret
 * is moved.
 * @move_length: (inout): Points to the number of characters selected.
 * Negative means towards the beginning.
 * @left_gravity: Whether the move position and length have left gravity.
 *
 * Changes *@move_position and *@move_length so that they point to the same
 * region when @insert_length characters are inserted at @insert_position.
 *
 * If text is inserted at the same position as @move_position, then
 * @move_position is kept at the position it currently is if @left_gravity is
 * %TRUE, otherwise it is shifted to the right.
 *
 * If *@move_length is nonzero, then the selection length is never enlarged if
 * text is inserted at the selection bounds, not depending on whether
 * @left_gravity is set or not.
 **/
void
inf_text_move_operation_transform_insert(guint insert_position,
                                         guint insert_length,
                                         guint* move_position,
                                         gint* move_length,
                                         gboolean left_gravity)
{
  guint cur_pos;
  guint cur_bound;
  
  g_return_if_fail(move_position != NULL);
  g_return_if_fail(move_length != NULL);

  cur_pos = *move_position;
  cur_bound = *move_position + *move_length;

  if(cur_pos == cur_bound)
  {
    if( (insert_position &lt; cur_pos) ||
        (insert_position == cur_pos &amp;&amp; !left_gravity))
    {
      cur_pos += insert_length;
      cur_bound += insert_length;
    }
  }
  else
  {
    if(cur_bound &gt; cur_pos)
    {
      if(insert_position &lt;= cur_pos)
      {
        cur_pos += insert_length;
        cur_bound += insert_length;
      }
      else if(insert_position &lt; cur_bound)
      {
        cur_bound += insert_length;
      }
    }
    else
    {
      if(insert_position &lt;= cur_bound)
      {
        cur_pos += insert_length;
        cur_bound += insert_length;
      }
      else if(insert_position &lt; cur_pos)
      {
        cur_pos += insert_length;
      }
    }
  }

  *move_position = cur_pos;
  *move_length = (gint)cur_bound - (gint)cur_pos;
}

/**
 * inf_text_move_operation_transform_delete:
 * @delete_position: The position at which text is deleted.
 * @delete_length: The number of deleted characters.
 * @move_position: (inout): Points to the character offset to which the caret
 * is moved.
 * @move_length: (inout): Points to the number of characters selected.
 * Negative means towards the beginning.
 *
 * Changes *@move_position and *@move_length so that they point to the same
 * region when @delete_length characters are deleted starting from
 * @delete_position.
 **/
void
inf_text_move_operation_transform_delete(guint delete_position,
                                         guint delete_length,
                                         guint* move_position,
                                         gint* move_length)
{
  guint cur_pos;
  gint cur_len;

  g_return_if_fail(move_position != NULL);
  g_return_if_fail(move_length != NULL);

  cur_pos = *move_position;
  cur_len = *move_length;

  if(cur_pos &gt;= delete_position + delete_length)
    *move_position = cur_pos - delete_length;
  else if(cur_pos &gt; delete_position)
    *move_position = delete_position;
  else
    *move_position = cur_pos;

  if(cur_len &lt; 0)
  {
    if(delete_position + delete_length &lt;= cur_pos + cur_len)
    {
      *move_length = cur_len;
    }
    else if(delete_position &gt;= cur_pos)
    {
      *move_length = cur_len;
    }
    else if(delete_position &lt;= cur_pos + cur_len &amp;&amp;
            delete_position + delete_length &gt;= cur_pos)
    {
      *move_length = 0;
    }
    else if(delete_position &lt;= cur_pos + cur_len &amp;&amp;
            delete_position + delete_length &gt; cur_pos + cur_len)
    {
      *move_length = -(gint)(cur_pos - (delete_position + delete_length));
    }
    else if(delete_position &gt; cur_pos + cur_len &amp;&amp;
            delete_position + delete_length &gt; cur_pos)
    {
      *move_length = delete_position - (cur_pos + cur_len);
    }
    else if(delete_position &gt; cur_pos + cur_len &amp;&amp;
            delete_position + delete_length &lt;= cur_pos)
    {
      *move_length = cur_len + (gint)delete_length;
    }
    else
    {
      g_assert_not_reached();
    }
  }
  else
  {
    if(delete_position + delete_length &lt;= cur_pos)
    {
      *move_length = cur_len;
    }
    else if(delete_position &gt;= cur_pos + cur_len)
    {
      *move_length = cur_len;
    }
    else if(delete_position &lt;= cur_pos &amp;&amp;
            delete_position + delete_length &gt;= cur_pos + cur_len)
    {
      *move_length = 0;
    }
    else if(delete_position &lt;= cur_pos &amp;&amp;
            delete_position + delete_length &gt; cur_pos)
    {
      *move_length = cur_pos + cur_len - (delete_position + delete_length);
    }
    else if(delete_position &gt; cur_pos &amp;&amp;
             delete_position + delete_length &gt; cur_pos + cur_len)
    {
      *move_length = cur_pos - delete_position;
    }
    else if(delete_position &gt; cur_pos &amp;&amp;
            delete_position + delete_length &lt;= cur_pos + cur_len)
    {
      *move_length = cur_len - delete_length;
    }
    else
    {
      g_assert_not_reached();
    }
  }
}

/* vim:set et sw=2 ts=2: */
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
