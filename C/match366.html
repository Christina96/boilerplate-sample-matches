<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for inf-adopted-user.c &amp; inf-text-move-operation.c</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for inf-adopted-user.c &amp; inf-text-move-operation.c
      </h3>
<h1 align="center">
        26.7%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>inf-adopted-user.c (45.37037%)<th>inf-text-move-operation.c (18.918919%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(152-185)<td><a href="#" name="0">(78-111)</a><td align="center"><font color="#ff0000">21</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(109-136)<td><a href="#" name="1">(55-76)</a><td align="center"><font color="#b60000">15</font>
<tr onclick='openModal("#980517")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#980517"><font color="#980517">-</font><td><a href="#" name="2">(68-92)<td><a href="#" name="2">(244-290)</a><td align="center"><font color="#9d0000">13</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>inf-adopted-user.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 #include &lt;libinfinity/adopted/inf-adopted-user.h&gt;
2 #include &lt;libinfinity/adopted/inf-adopted-state-vector.h&gt;
3 typedef struct _InfAdoptedUserPrivate InfAdoptedUserPrivate;
4 struct _InfAdoptedUserPrivate {
5   InfAdoptedStateVector* vector;
6   InfAdoptedRequestLog* log;
7 };
8 enum {
9   PROP_0,
10   PROP_VECTOR,
11   PROP_REQUEST_LOG
12 };
13 #define INF_ADOPTED_USER_GET_PRIVATE(obj) (G_TYPE_INSTANCE_GET_PRIVATE((obj), INF_ADOPTED_TYPE_USER, InfAdoptedUserPrivate))
14 #define INF_ADOPTED_USER_PRIVATE(obj)     ((InfAdoptedUserPrivate*)(obj)-&gt;priv)
15 G_DEFINE_TYPE_WITH_CODE(InfAdoptedUser, inf_adopted_user, INF_TYPE_USER,
16   G_ADD_PRIVATE(InfAdoptedUser))
17 static void
18 inf_adopted_user_init(InfAdoptedUser* user)
19 {
20   InfAdoptedUserPrivate* priv;
21   user-&gt;priv = INF_ADOPTED_USER_GET_PRIVATE(user);
22   priv = INF_ADOPTED_USER_PRIVATE(user);
23 <a name="2"></a>
24   priv-&gt;vector = inf_adopted_state_vector_new();
25   priv-&gt;log = NULL;
26 <font color="#980517"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>}
27 static void
28 inf_adopted_user_constructed(GObject* object)
29 {
30   InfAdoptedUser* user;
31   InfAdoptedUserPrivate* priv;
32   G_OBJECT_CLASS(inf_adopted_user_parent_class)-&gt;constructed(object);
33   user = INF_ADOPTED_USER(object);
34   priv = INF_ADOPTED_USER_PRIVATE(user);
35   priv-&gt;log = inf_adopted_request_log_new(inf_user_get_id(INF_USER(user)));
36 }
37 static void
38 inf_adopted_user_dispose(GObject* object)
39 {
40   InfAdoptedUser* user;
41   InfAdoptedUserPrivate* priv;
42   user = INF_ADOPTED_USER(object);
43   priv = INF_ADOPTED_USER_PRIVATE(user);</b></font>
44   if(priv-&gt;log != NULL)
45   {
46     g_object_unref(priv-&gt;log);
47     priv-&gt;log = NULL;
48   }
49   G_OBJECT_CLASS(inf_adopted_user_parent_class)-&gt;dispose(object);
50 }
51 static void
52 inf_adopted_user_finalize(GObject* object)
53 {
54 <a name="1"></a>  InfAdoptedUser* user;
55   InfAdoptedUserPrivate* priv;
56 <font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>  user = INF_ADOPTED_USER(object);
57   priv = INF_ADOPTED_USER_PRIVATE(user);
58   inf_adopted_state_vector_free(priv-&gt;vector);
59   G_OBJECT_CLASS(inf_adopted_user_parent_class)-&gt;finalize(object);
60 }
61 static void
62 inf_adopted_user_set_property(GObject* object,
63                               guint prop_id,
64                               const GValue* value,
65                               GParamSpec* pspec)
66 {
67   InfAdoptedUser* user;
68   InfAdoptedUserPrivate* priv;
69   InfAdoptedRequestLog* log;
70   user = INF_ADOPTED_USER(object);
71   priv = INF_ADOPTED_USER_PRIVATE(user);
72   switch(prop_id)
73   {
74   case PROP_VECTOR:
75     inf_adopted_state_vector_free(priv-&gt;vector);
76     priv-&gt;vector = g_value_dup_boxed(value);
77     break;
78   case PROP_REQUEST_LOG:</b></font>
79     g_assert(priv-&gt;log == NULL); 
80     if(g_value_get_object(value) != NULL)
81     {
82       log = INF_ADOPTED_REQUEST_LOG(g_value_get_object(value));
83       g_assert(
84         inf_adopted_request_log_get_user_id(log) ==
85         inf_user_get_id(INF_USER(user))
86       );
87       priv-&gt;log = log;
88 <a name="0"></a>      g_object_ref(log);
89     }
90 <font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>    break;
91   default:
92     G_OBJECT_WARN_INVALID_PROPERTY_ID(object, prop_id, pspec);
93     break;
94   }
95 }
96 static void
97 inf_adopted_user_get_property(GObject* object,
98                               guint prop_id,
99                               GValue* value,
100                               GParamSpec* pspec)
101 {
102   InfAdoptedUser* user;
103   InfAdoptedUserPrivate* priv;
104   user = INF_ADOPTED_USER(object);
105   priv = INF_ADOPTED_USER_PRIVATE(user);
106   switch(prop_id)
107   {
108   case PROP_VECTOR:
109     g_value_set_boxed(value, priv-&gt;vector);
110     break;
111   case PROP_REQUEST_LOG:
112     g_value_set_object(value, G_OBJECT(priv-&gt;log));
113     break;
114   default:
115     G_OBJECT_WARN_INVALID_PROPERTY_ID(object, prop_id, pspec);
116     break;
117   }
118 }
119 static void</b></font>
120 inf_adopted_user_class_init(InfAdoptedUserClass* user_class)
121 {
122   GObjectClass* object_class;
123   object_class = G_OBJECT_CLASS(user_class);
124   object_class-&gt;constructed = inf_adopted_user_constructed;
125   object_class-&gt;dispose = inf_adopted_user_dispose;
126   object_class-&gt;finalize = inf_adopted_user_finalize;
127   object_class-&gt;set_property = inf_adopted_user_set_property;
128   object_class-&gt;get_property = inf_adopted_user_get_property;
129   g_object_class_install_property(
130     object_class,
131     PROP_VECTOR,
132     g_param_spec_boxed(
133       "vector",
134       "State vector",
135       "The state this user is currently at",
136       INF_ADOPTED_TYPE_STATE_VECTOR,
137       G_PARAM_READWRITE
138     )
139   );
140   g_object_class_install_property(
141     object_class,
142     PROP_REQUEST_LOG,
143     g_param_spec_object(
144       "request-log",
145       "Request log",
146       "Request log of this user",
147       INF_ADOPTED_TYPE_REQUEST_LOG,
148       G_PARAM_READWRITE | G_PARAM_CONSTRUCT_ONLY
149     )
150   );
151 }
152 guint
153 inf_adopted_user_get_component(InfAdoptedUser* user,
154                                guint id)
155 {
156   g_return_val_if_fail(INF_ADOPTED_IS_USER(user), 0);
157   g_return_val_if_fail(id != 0, 0);
158   return inf_adopted_state_vector_get(
159     INF_ADOPTED_USER_PRIVATE(user)-&gt;vector,
160     id
161   );
162 }
163 InfAdoptedStateVector*
164 inf_adopted_user_get_vector(InfAdoptedUser* user)
165 {
166   g_return_val_if_fail(INF_ADOPTED_IS_USER(user), NULL);
167   return INF_ADOPTED_USER_PRIVATE(user)-&gt;vector;
168 }
169 void
170 inf_adopted_user_set_vector(InfAdoptedUser* user,
171                             InfAdoptedStateVector* vec)
172 {
173   InfAdoptedUserPrivate* priv;
174   g_return_if_fail(INF_ADOPTED_IS_USER(user));
175   g_return_if_fail(vec != NULL);
176   priv = INF_ADOPTED_USER_PRIVATE(user);
177   inf_adopted_state_vector_free(priv-&gt;vector);
178   priv-&gt;vector = vec;
179   g_object_notify(G_OBJECT(user), "vector");
180 }
181 InfAdoptedRequestLog*
182 inf_adopted_user_get_request_log(InfAdoptedUser* user)
183 {
184   g_return_val_if_fail(INF_ADOPTED_IS_USER(user), NULL);
185   return INF_ADOPTED_USER_PRIVATE(user)-&gt;log;
186 }
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>inf-text-move-operation.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 #include &lt;libinftext/inf-text-move-operation.h&gt;
2 #include &lt;libinftext/inf-text-insert-operation.h&gt;
3 #include &lt;libinftext/inf-text-delete-operation.h&gt;
4 #include &lt;libinftext/inf-text-buffer.h&gt;
5 #include &lt;libinftext/inf-text-user.h&gt;
6 #include &lt;libinfinity/adopted/inf-adopted-operation.h&gt;
7 #include &lt;libinfinity/inf-i18n.h&gt;
8 typedef struct _InfTextMoveOperationPrivate InfTextMoveOperationPrivate;
9 struct _InfTextMoveOperationPrivate {
10   guint position;
11   gint length;
12 };
13 enum {
14   PROP_0,
15   PROP_POSITION,
16   PROP_LENGTH
17 };
18 #define INF_TEXT_MOVE_OPERATION_PRIVATE(obj) (G_TYPE_INSTANCE_GET_PRIVATE((obj), INF_TEXT_TYPE_MOVE_OPERATION, InfTextMoveOperationPrivate))
19 static void inf_text_move_operation_operation_iface_init(InfAdoptedOperationInterface* iface);
20 G_DEFINE_TYPE_WITH_CODE(InfTextMoveOperation, inf_text_move_operation, G_TYPE_OBJECT,
21   G_ADD_PRIVATE(InfTextMoveOperation)
22   G_IMPLEMENT_INTERFACE(INF_ADOPTED_TYPE_OPERATION, inf_text_move_operation_operation_iface_init))
23 static void
24 inf_text_move_operation_init(InfTextMoveOperation* operation)
25 {
26 <a name="1"></a>  InfTextMoveOperationPrivate* priv;
27   priv = INF_TEXT_MOVE_OPERATION_PRIVATE(operation);
28 <font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>  priv-&gt;position = 0;
29   priv-&gt;length = 0;
30 }
31 static void
32 inf_text_move_operation_set_property(GObject* object,
33                                      guint prop_id,
34                                      const GValue* value,
35                                      GParamSpec* pspec)
36 {
37   InfTextMoveOperation* operation;
38   InfTextMoveOperationPrivate* priv;
39   operation = INF_TEXT_MOVE_OPERATION(object);
40   priv = INF_TEXT_MOVE_OPERATION_PRIVATE(operation);
41   switch(prop_id)
42   {
43   case PROP_POSITION:
44     priv-&gt;position = g_value_get_uint(value);
45 <a name="0"></a>    break;
46   case PROP_LENGTH:</b></font>
47     priv-&gt;length = g_value_get_int(value);
48 <font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>    break;
49   default:
50     G_OBJECT_WARN_INVALID_PROPERTY_ID(object, prop_id, pspec);
51     break;
52   }
53 }
54 static void
55 inf_text_move_operation_get_property(GObject* object,
56                                      guint prop_id,
57                                      GValue* value,
58                                      GParamSpec* pspec)
59 {
60   InfTextMoveOperation* operation;
61   InfTextMoveOperationPrivate* priv;
62   operation = INF_TEXT_MOVE_OPERATION(object);
63   priv = INF_TEXT_MOVE_OPERATION_PRIVATE(operation);
64   switch(prop_id)
65   {
66   case PROP_POSITION:
67     g_value_set_uint(value, priv-&gt;position);
68     break;
69   case PROP_LENGTH:
70     g_value_set_int(value, priv-&gt;length);
71     break;
72   default:
73     G_OBJECT_WARN_INVALID_PROPERTY_ID(object, prop_id, pspec);
74     break;
75   }
76 }
77 static gboolean</b></font>
78 inf_text_move_operation_need_concurrency_id(InfAdoptedOperation* operation,
79                                             InfAdoptedOperation* against)
80 {
81   g_assert(INF_TEXT_IS_MOVE_OPERATION(operation));
82   return FALSE;
83 }
84 static InfAdoptedOperation*
85 inf_text_move_operation_transform(InfAdoptedOperation* operation,
86                                   InfAdoptedOperation* against,
87                                   InfAdoptedOperation* operation_lcs,
88                                   InfAdoptedOperation* against_lcs,
89                                   gint concurrency_id)
90 {
91   InfTextMoveOperationPrivate* priv;
92   guint new_pos;
93   gint new_len;
94   g_assert(INF_TEXT_IS_MOVE_OPERATION(operation));
95   priv = INF_TEXT_MOVE_OPERATION_PRIVATE(operation);
96   new_pos = priv-&gt;position;
97   new_len = priv-&gt;length;
98   if(INF_TEXT_IS_INSERT_OPERATION(against))
99   {
100     inf_text_move_operation_transform_insert(
101       inf_text_insert_operation_get_position(
102         INF_TEXT_INSERT_OPERATION(against)
103       ),
104       inf_text_insert_operation_get_length(
105         INF_TEXT_INSERT_OPERATION(against)
106       ),
107       &amp;new_pos,
108       &amp;new_len,
109       TRUE     );
110   }
111   else if(INF_TEXT_IS_DELETE_OPERATION(against))
112   {
113     inf_text_move_operation_transform_delete(
114       inf_text_delete_operation_get_position(
115         INF_TEXT_DELETE_OPERATION(against)
116       ),
117       inf_text_delete_operation_get_length(
118         INF_TEXT_DELETE_OPERATION(against)
119       ),
120       &amp;new_pos,
121       &amp;new_len
122     );
123   }
124   else
125   {
126     g_assert_not_reached();
127     return NULL;
128   }
129   return INF_ADOPTED_OPERATION(
130     g_object_new(
131       INF_TEXT_TYPE_MOVE_OPERATION,
132       "position", new_pos,
133       "length", new_len,
134       NULL
135     )
136   );
137 }
138 static InfAdoptedOperation*
139 inf_text_move_operation_copy(InfAdoptedOperation* operation)
140 {
141   InfTextMoveOperationPrivate* priv;
142   GObject* object;
143   g_assert(INF_TEXT_IS_MOVE_OPERATION(operation));
144   priv = INF_TEXT_MOVE_OPERATION_PRIVATE(operation);
145   object = g_object_new(
146     INF_TEXT_TYPE_MOVE_OPERATION,
147     "position", priv-&gt;position,
148     "length", priv-&gt;length,
149     NULL
150   );
151   return INF_ADOPTED_OPERATION(object);
152 }
153 static InfAdoptedOperationFlags
154 inf_text_move_operation_get_flags(InfAdoptedOperation* operation)
155 {
156   return 0;
157 }
158 static gboolean
159 inf_text_move_operation_apply(InfAdoptedOperation* operation,
160                               InfAdoptedUser* by,
161                               InfBuffer* buffer,
162                               GError** error)
163 {
164   InfTextMoveOperationPrivate* priv;
165   guint length;
166   g_assert(INF_TEXT_IS_MOVE_OPERATION(operation));
167   g_assert(INF_TEXT_IS_USER(by));
168   priv = INF_TEXT_MOVE_OPERATION_PRIVATE(operation);  
169   length = inf_text_buffer_get_length(INF_TEXT_BUFFER(buffer));
170   if(priv-&gt;position &gt; length ||
171      priv-&gt;position + priv-&gt;length &gt; length)
172   {
173     g_set_error_literal(
174       error,
175       g_quark_from_static_string("INF_TEXT_OPERATION_ERROR"),
176       INF_TEXT_OPERATION_ERROR_INVALID_MOVE,
177       _("Attempt to move cursor or selection beyond the end of the document")
178     );
179     return FALSE;
180   }
181   else
182   {
183     inf_text_user_set_selection(
184       INF_TEXT_USER(by),
185       priv-&gt;position,
186       priv-&gt;length,
187       TRUE     );
188 <a name="2"></a>
189     return TRUE;
190   }
191 <font color="#980517"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>}
192 static void
193 inf_text_move_operation_class_init(
194   InfTextMoveOperationClass* move_operation_class)
195 {
196   GObjectClass* object_class;
197   object_class = G_OBJECT_CLASS(move_operation_class);
198   object_class-&gt;set_property = inf_text_move_operation_set_property;
199   object_class-&gt;get_property = inf_text_move_operation_get_property;
200   g_object_class_install_property(
201     object_class,
202     PROP_POSITION,
203     g_param_spec_uint(
204       "position",
205       "Position",
206       "Position where to place the user's caret at",
207       0,
208       G_MAXUINT,
209       0,
210       G_PARAM_READWRITE | G_PARAM_CONSTRUCT_ONLY
211     )
212   );
213   g_object_class_install_property(
214     object_class,
215     PROP_LENGTH,
216     g_param_spec_int(
217       "length",
218       "Length",
219       "The number of characters of the selected text",
220       G_MININT,
221       G_MAXINT,
222       0,
223       G_PARAM_READWRITE | G_PARAM_CONSTRUCT_ONLY
224     )
225   );
226 }
227 static void
228 inf_text_move_operation_operation_iface_init(
229   InfAdoptedOperationInterface* iface)
230 {
231   iface-&gt;need_concurrency_id = inf_text_move_operation_need_concurrency_id;
232   iface-&gt;transform = inf_text_move_operation_transform;</b></font>
233   iface-&gt;copy = inf_text_move_operation_copy;
234   iface-&gt;get_flags = inf_text_move_operation_get_flags;
235   iface-&gt;apply = inf_text_move_operation_apply;
236   iface-&gt;apply_transformed = NULL;
237   iface-&gt;revert = NULL;
238 }
239 InfTextMoveOperation*
240 inf_text_move_operation_new(guint position,
241                             gint length)
242 {
243   GObject* object;
244   object = g_object_new(
245     INF_TEXT_TYPE_MOVE_OPERATION,
246     "position", position,
247     "length", length,
248     NULL
249   );
250   return INF_TEXT_MOVE_OPERATION(object);
251 }
252 guint
253 inf_text_move_operation_get_position(InfTextMoveOperation* operation)
254 {
255   g_return_val_if_fail(INF_TEXT_IS_MOVE_OPERATION(operation), 0);
256   return INF_TEXT_MOVE_OPERATION_PRIVATE(operation)-&gt;position;
257 }
258 gint
259 inf_text_move_operation_get_length(InfTextMoveOperation* operation)
260 {
261   g_return_val_if_fail(INF_TEXT_IS_MOVE_OPERATION(operation), 0);
262   return INF_TEXT_MOVE_OPERATION_PRIVATE(operation)-&gt;length;
263 }
264 void
265 inf_text_move_operation_transform_insert(guint insert_position,
266                                          guint insert_length,
267                                          guint* move_position,
268                                          gint* move_length,
269                                          gboolean left_gravity)
270 {
271   guint cur_pos;
272   guint cur_bound;
273   g_return_if_fail(move_position != NULL);
274   g_return_if_fail(move_length != NULL);
275   cur_pos = *move_position;
276   cur_bound = *move_position + *move_length;
277   if(cur_pos == cur_bound)
278   {
279     if( (insert_position &lt; cur_pos) ||
280         (insert_position == cur_pos &amp;&amp; !left_gravity))
281     {
282       cur_pos += insert_length;
283       cur_bound += insert_length;
284     }
285   }
286   else
287   {
288     if(cur_bound &gt; cur_pos)
289     {
290       if(insert_position &lt;= cur_pos)
291       {
292         cur_pos += insert_length;
293         cur_bound += insert_length;
294       }
295       else if(insert_position &lt; cur_bound)
296       {
297         cur_bound += insert_length;
298       }
299     }
300     else
301     {
302       if(insert_position &lt;= cur_bound)
303       {
304         cur_pos += insert_length;
305         cur_bound += insert_length;
306       }
307       else if(insert_position &lt; cur_pos)
308       {
309         cur_pos += insert_length;
310       }
311     }
312   }
313   *move_position = cur_pos;
314   *move_length = (gint)cur_bound - (gint)cur_pos;
315 }
316 void
317 inf_text_move_operation_transform_delete(guint delete_position,
318                                          guint delete_length,
319                                          guint* move_position,
320                                          gint* move_length)
321 {
322   guint cur_pos;
323   gint cur_len;
324   g_return_if_fail(move_position != NULL);
325   g_return_if_fail(move_length != NULL);
326   cur_pos = *move_position;
327   cur_len = *move_length;
328   if(cur_pos &gt;= delete_position + delete_length)
329     *move_position = cur_pos - delete_length;
330   else if(cur_pos &gt; delete_position)
331     *move_position = delete_position;
332   else
333     *move_position = cur_pos;
334   if(cur_len &lt; 0)
335   {
336     if(delete_position + delete_length &lt;= cur_pos + cur_len)
337     {
338       *move_length = cur_len;
339     }
340     else if(delete_position &gt;= cur_pos)
341     {
342       *move_length = cur_len;
343     }
344     else if(delete_position &lt;= cur_pos + cur_len &amp;&amp;
345             delete_position + delete_length &gt;= cur_pos)
346     {
347       *move_length = 0;
348     }
349     else if(delete_position &lt;= cur_pos + cur_len &amp;&amp;
350             delete_position + delete_length &gt; cur_pos + cur_len)
351     {
352       *move_length = -(gint)(cur_pos - (delete_position + delete_length));
353     }
354     else if(delete_position &gt; cur_pos + cur_len &amp;&amp;
355             delete_position + delete_length &gt; cur_pos)
356     {
357       *move_length = delete_position - (cur_pos + cur_len);
358     }
359     else if(delete_position &gt; cur_pos + cur_len &amp;&amp;
360             delete_position + delete_length &lt;= cur_pos)
361     {
362       *move_length = cur_len + (gint)delete_length;
363     }
364     else
365     {
366       g_assert_not_reached();
367     }
368   }
369   else
370   {
371     if(delete_position + delete_length &lt;= cur_pos)
372     {
373       *move_length = cur_len;
374     }
375     else if(delete_position &gt;= cur_pos + cur_len)
376     {
377       *move_length = cur_len;
378     }
379     else if(delete_position &lt;= cur_pos &amp;&amp;
380             delete_position + delete_length &gt;= cur_pos + cur_len)
381     {
382       *move_length = 0;
383     }
384     else if(delete_position &lt;= cur_pos &amp;&amp;
385             delete_position + delete_length &gt; cur_pos)
386     {
387       *move_length = cur_pos + cur_len - (delete_position + delete_length);
388     }
389     else if(delete_position &gt; cur_pos &amp;&amp;
390              delete_position + delete_length &gt; cur_pos + cur_len)
391     {
392       *move_length = cur_pos - delete_position;
393     }
394     else if(delete_position &gt; cur_pos &amp;&amp;
395             delete_position + delete_length &lt;= cur_pos + cur_len)
396     {
397       *move_length = cur_len - delete_length;
398     }
399     else
400     {
401       g_assert_not_reached();
402     }
403   }
404 }
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
