
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 16, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>PINRemoteImage-MDEwOlJlcG9zaXRvcnkzOTUzNzEwMw==-flat-picture_csp_enc.c</h3>
            <pre><code>1  #include <assert.h>
2  #include <stdlib.h>
3  #include <math.h>
4  #include "src/enc/vp8i_enc.h"
5  #include "src/utils/random_utils.h"
6  #include "src/utils/utils.h"
7  #include "src/dsp/dsp.h"
8  #include "src/dsp/lossless.h"
9  #include "src/dsp/yuv.h"
10  #define USE_GAMMA_COMPRESSION
11  #define USE_INVERSE_ALPHA_TABLE
12  #ifdef WORDS_BIGENDIAN
13  #define CHANNEL_OFFSET(i) (i)
14  #else
15  #define CHANNEL_OFFSET(i) (3-(i))
16  #endif
17  #define ALPHA_OFFSET CHANNEL_OFFSET(0)
18  static int CheckNonOpaque(const uint8_t* alpha, int width, int height,
19                            int x_step, int y_step) {
20    if (alpha == NULL) return 0;
21    WebPInitAlphaProcessing();
22    if (x_step == 1) {
23      for (; height-- > 0; alpha += y_step) {
24        if (WebPHasAlpha8b(alpha, width)) return 1;
25      }
26    } else {
27      for (; height-- > 0; alpha += y_step) {
28        if (WebPHasAlpha32b(alpha, width)) return 1;
29      }
30    }
31    return 0;
32  }
33  int WebPPictureHasTransparency(const WebPPicture* picture) {
34    if (picture == NULL) return 0;
35    if (!picture->use_argb) {
36      return CheckNonOpaque(picture->a, picture->width, picture->height,
37                            1, picture->a_stride);
38    } else {
39      const int alpha_offset = ALPHA_OFFSET;
40      return CheckNonOpaque((const uint8_t*)picture->argb + alpha_offset,
41                            picture->width, picture->height,
42                            4, picture->argb_stride * sizeof(*picture->argb));
43    }
44    return 0;
45  }
46  #if defined(USE_GAMMA_COMPRESSION)
47  #define kGamma 0.80      
48  #define kGammaFix 12     
49  #define kGammaScale ((1 << kGammaFix) - 1)
50  #define kGammaTabFix 7   
51  #define kGammaTabScale (1 << kGammaTabFix)
52  #define kGammaTabRounder (kGammaTabScale >> 1)
53  #define kGammaTabSize (1 << (kGammaFix - kGammaTabFix))
54  static int kLinearToGammaTab[kGammaTabSize + 1];
55  static uint16_t kGammaToLinearTab[256];
56  static volatile int kGammaTablesOk = 0;
57  static WEBP_TSAN_IGNORE_FUNCTION void InitGammaTables(void) {
58    if (!kGammaTablesOk) {
59      int v;
60      const double scale = (double)(1 << kGammaTabFix) / kGammaScale;
61      const double norm = 1. / 255.;
62      for (v = 0; v <= 255; ++v) {
63        kGammaToLinearTab[v] =
64            (uint16_t)(pow(norm * v, kGamma) * kGammaScale + .5);
65      }
66      for (v = 0; v <= kGammaTabSize; ++v) {
67        kLinearToGammaTab[v] = (int)(255. * pow(scale * v, 1. / kGamma) + .5);
68      }
69      kGammaTablesOk = 1;
70    }
71  }
72  static WEBP_INLINE uint32_t GammaToLinear(uint8_t v) {
73    return kGammaToLinearTab[v];
74  }
75  static WEBP_INLINE int Interpolate(int v) {
76    const int tab_pos = v >> (kGammaTabFix + 2);    
77    const int x = v & ((kGammaTabScale << 2) - 1);  
78    const int v0 = kLinearToGammaTab[tab_pos];
79    const int v1 = kLinearToGammaTab[tab_pos + 1];
80    const int y = v1 * x + v0 * ((kGammaTabScale << 2) - x);   
81    assert(tab_pos + 1 < kGammaTabSize + 1);
82    return y;
83  }
84  static WEBP_INLINE int LinearToGamma(uint32_t base_value, int shift) {
85    const int y = Interpolate(base_value << shift);   
86    return (y + kGammaTabRounder) >> kGammaTabFix;    
87  }
88  #else
89  static void InitGammaTables(void) {}
90  static WEBP_INLINE uint32_t GammaToLinear(uint8_t v) { return v; }
91  static WEBP_INLINE int LinearToGamma(uint32_t base_value, int shift) {
92    return (int)(base_value << shift);
93  }
94  #endif    
95  static int RGBToY(int r, int g, int b, VP8Random* const rg) {
96    return (rg == NULL) ? VP8RGBToY(r, g, b, YUV_HALF)
97                        : VP8RGBToY(r, g, b, VP8RandomBits(rg, YUV_FIX));
98  }
99  static int RGBToU(int r, int g, int b, VP8Random* const rg) {
100    return (rg == NULL) ? VP8RGBToU(r, g, b, YUV_HALF << 2)
101                        : VP8RGBToU(r, g, b, VP8RandomBits(rg, YUV_FIX + 2));
102  }
103  static int RGBToV(int r, int g, int b, VP8Random* const rg) {
104    return (rg == NULL) ? VP8RGBToV(r, g, b, YUV_HALF << 2)
105                        : VP8RGBToV(r, g, b, VP8RandomBits(rg, YUV_FIX + 2));
106  }
107  static const int kNumIterations = 4;
108  static const int kMinDimensionIterativeConversion = 4;
109  #define SFIX 2                
110  typedef int16_t fixed_t;      
111  typedef uint16_t fixed_y_t;   
112  #define SHALF (1 << SFIX >> 1)
113  #define MAX_Y_T ((256 << SFIX) - 1)
114  #define SROUNDER (1 << (YUV_FIX + SFIX - 1))
115  #if defined(USE_GAMMA_COMPRESSION)
116  #define kGammaF (1./0.45)
117  static uint32_t kLinearToGammaTabS[kGammaTabSize + 2];
118  #define GAMMA_TO_LINEAR_BITS 14
119  static uint32_t kGammaToLinearTabS[MAX_Y_T + 1];   
120  static volatile int kGammaTablesSOk = 0;
121  static WEBP_TSAN_IGNORE_FUNCTION void InitGammaTablesS(void) {
122    assert(2 * GAMMA_TO_LINEAR_BITS < 32);  
123    if (!kGammaTablesSOk) {
124      int v;
125      const double norm = 1. / MAX_Y_T;
126      const double scale = 1. / kGammaTabSize;
127      const double a = 0.09929682680944;
128      const double thresh = 0.018053968510807;
129      const double final_scale = 1 << GAMMA_TO_LINEAR_BITS;
130      for (v = 0; v <= MAX_Y_T; ++v) {
131        const double g = norm * v;
132        double value;
133        if (g <= thresh * 4.5) {
134          value = g / 4.5;
135        } else {
136          const double a_rec = 1. / (1. + a);
137          value = pow(a_rec * (g + a), kGammaF);
138        }
139        kGammaToLinearTabS[v] = (uint32_t)(value * final_scale + .5);
140      }
141      for (v = 0; v <= kGammaTabSize; ++v) {
142        const double g = scale * v;
143        double value;
144        if (g <= thresh) {
145          value = 4.5 * g;
146        } else {
147          value = (1. + a) * pow(g, 1. / kGammaF) - a;
148        }
149        kLinearToGammaTabS[v] =
150            (uint32_t)(MAX_Y_T * value) + (1 << GAMMA_TO_LINEAR_BITS >> 1);
151      }
152      kLinearToGammaTabS[kGammaTabSize + 1] = kLinearToGammaTabS[kGammaTabSize];
153      kGammaTablesSOk = 1;
154    }
155  }
156  static WEBP_INLINE uint32_t GammaToLinearS(int v) {
157    return kGammaToLinearTabS[v];
158  }
159  static WEBP_INLINE uint32_t LinearToGammaS(uint32_t value) {
160    const uint32_t v = value * kGammaTabSize;
161    const uint32_t tab_pos = v >> GAMMA_TO_LINEAR_BITS;
162    const uint32_t x = v - (tab_pos << GAMMA_TO_LINEAR_BITS);  
163    const uint32_t v0 = kLinearToGammaTabS[tab_pos + 0];
164    const uint32_t v1 = kLinearToGammaTabS[tab_pos + 1];
165    const uint32_t v2 = (v1 - v0) * x;    
166    const uint32_t result = v0 + (v2 >> GAMMA_TO_LINEAR_BITS);
167    return result;
168  }
169  #else
170  static void InitGammaTablesS(void) {}
171  static WEBP_INLINE uint32_t GammaToLinearS(int v) {
172    return (v << GAMMA_TO_LINEAR_BITS) / MAX_Y_T;
173  }
174  static WEBP_INLINE uint32_t LinearToGammaS(uint32_t value) {
175    return (MAX_Y_T * value) >> GAMMA_TO_LINEAR_BITS;
176  }
177  #endif    
178  static uint8_t clip_8b(fixed_t v) {
179    return (!(v & ~0xff)) ? (uint8_t)v : (v < 0) ? 0u : 255u;
180  }
181  static fixed_y_t clip_y(int y) {
182    return (!(y & ~MAX_Y_T)) ? (fixed_y_t)y : (y < 0) ? 0 : MAX_Y_T;
183  }
184  static int RGBToGray(int r, int g, int b) {
185    const int luma = 13933 * r + 46871 * g + 4732 * b + YUV_HALF;
186    return (luma >> YUV_FIX);
187  }
188  static uint32_t ScaleDown(int a, int b, int c, int d) {
189    const uint32_t A = GammaToLinearS(a);
190    const uint32_t B = GammaToLinearS(b);
191    const uint32_t C = GammaToLinearS(c);
192    const uint32_t D = GammaToLinearS(d);
193    return LinearToGammaS((A + B + C + D + 2) >> 2);
194  }
195  static WEBP_INLINE void UpdateW(const fixed_y_t* src, fixed_y_t* dst, int w) {
196    int i;
197    for (i = 0; i < w; ++i) {
198      const uint32_t R = GammaToLinearS(src[0 * w + i]);
199      const uint32_t G = GammaToLinearS(src[1 * w + i]);
200      const uint32_t B = GammaToLinearS(src[2 * w + i]);
201      const uint32_t Y = RGBToGray(R, G, B);
202      dst[i] = (fixed_y_t)LinearToGammaS(Y);
203    }
204  }
205  static void UpdateChroma(const fixed_y_t* src1, const fixed_y_t* src2,
206                           fixed_t* dst, int uv_w) {
207    int i;
208    for (i = 0; i < uv_w; ++i) {
209      const int r = ScaleDown(src1[0 * uv_w + 0], src1[0 * uv_w + 1],
210                              src2[0 * uv_w + 0], src2[0 * uv_w + 1]);
211      const int g = ScaleDown(src1[2 * uv_w + 0], src1[2 * uv_w + 1],
212                              src2[2 * uv_w + 0], src2[2 * uv_w + 1]);
213      const int b = ScaleDown(src1[4 * uv_w + 0], src1[4 * uv_w + 1],
214                              src2[4 * uv_w + 0], src2[4 * uv_w + 1]);
215      const int W = RGBToGray(r, g, b);
216      dst[0 * uv_w] = (fixed_t)(r - W);
217      dst[1 * uv_w] = (fixed_t)(g - W);
218      dst[2 * uv_w] = (fixed_t)(b - W);
219      dst  += 1;
220      src1 += 2;
221      src2 += 2;
222    }
223  }
224  static void StoreGray(const fixed_y_t* rgb, fixed_y_t* y, int w) {
225    int i;
226    for (i = 0; i < w; ++i) {
227      y[i] = RGBToGray(rgb[0 * w + i], rgb[1 * w + i], rgb[2 * w + i]);
228    }
229  }
230  static WEBP_INLINE fixed_y_t Filter2(int A, int B, int W0) {
231    const int v0 = (A * 3 + B + 2) >> 2;
232    return clip_y(v0 + W0);
233  }
234  static WEBP_INLINE fixed_y_t UpLift(uint8_t a) {  
235    return ((fixed_y_t)a << SFIX) | SHALF;
236  }
237  static void ImportOneRow(const uint8_t* const r_ptr,
238                           const uint8_t* const g_ptr,
239                           const uint8_t* const b_ptr,
240                           int step,
241                           int pic_width,
242                           fixed_y_t* const dst) {
243    int i;
244    const int w = (pic_width + 1) & ~1;
245    for (i = 0; i < pic_width; ++i) {
246      const int off = i * step;
247      dst[i + 0 * w] = UpLift(r_ptr[off]);
248      dst[i + 1 * w] = UpLift(g_ptr[off]);
249      dst[i + 2 * w] = UpLift(b_ptr[off]);
250    }
251    if (pic_width & 1) {  
252      dst[pic_width + 0 * w] = dst[pic_width + 0 * w - 1];
253      dst[pic_width + 1 * w] = dst[pic_width + 1 * w - 1];
254      dst[pic_width + 2 * w] = dst[pic_width + 2 * w - 1];
255    }
256  }
257  static void InterpolateTwoRows(const fixed_y_t* const best_y,
258                                 const fixed_t* prev_uv,
259                                 const fixed_t* cur_uv,
260                                 const fixed_t* next_uv,
261                                 int w,
262                                 fixed_y_t* out1,
263                                 fixed_y_t* out2) {
264    const int uv_w = w >> 1;
265    const int len = (w - 1) >> 1;   
266    int k = 3;
267    while (k-- > 0) {   
268      out1[0] = Filter2(cur_uv[0], prev_uv[0], best_y[0]);
269      out2[0] = Filter2(cur_uv[0], next_uv[0], best_y[w]);
270      WebPSharpYUVFilterRow(cur_uv, prev_uv, len, best_y + 0 + 1, out1 + 1);
271      WebPSharpYUVFilterRow(cur_uv, next_uv, len, best_y + w + 1, out2 + 1);
272      if (!(w & 1)) {
273        out1[w - 1] = Filter2(cur_uv[uv_w - 1], prev_uv[uv_w - 1],
274                              best_y[w - 1 + 0]);
275        out2[w - 1] = Filter2(cur_uv[uv_w - 1], next_uv[uv_w - 1],
276                              best_y[w - 1 + w]);
277      }
278      out1 += w;
279      out2 += w;
280      prev_uv += uv_w;
281      cur_uv  += uv_w;
282      next_uv += uv_w;
283    }
284  }
285  static WEBP_INLINE uint8_t ConvertRGBToY(int r, int g, int b) {
286    const int luma = 16839 * r + 33059 * g + 6420 * b + SROUNDER;
287    return clip_8b(16 + (luma >> (YUV_FIX + SFIX)));
288  }
289  static WEBP_INLINE uint8_t ConvertRGBToU(int r, int g, int b) {
290    const int u =  -9719 * r - 19081 * g + 28800 * b + SROUNDER;
291    return clip_8b(128 + (u >> (YUV_FIX + SFIX)));
292  }
293  static WEBP_INLINE uint8_t ConvertRGBToV(int r, int g, int b) {
294    const int v = +28800 * r - 24116 * g -  4684 * b + SROUNDER;
295    return clip_8b(128 + (v >> (YUV_FIX + SFIX)));
296  }
297  static int ConvertWRGBToYUV(const fixed_y_t* best_y, const fixed_t* best_uv,
298                              WebPPicture* const picture) {
299    int i, j;
300    uint8_t* dst_y = picture->y;
301    uint8_t* dst_u = picture->u;
302    uint8_t* dst_v = picture->v;
303    const fixed_t* const best_uv_base = best_uv;
304    const int w = (picture->width + 1) & ~1;
305    const int h = (picture->height + 1) & ~1;
306    const int uv_w = w >> 1;
307    const int uv_h = h >> 1;
308    for (best_uv = best_uv_base, j = 0; j < picture->height; ++j) {
309      for (i = 0; i < picture->width; ++i) {
310        const int off = (i >> 1);
311        const int W = best_y[i];
312        const int r = best_uv[off + 0 * uv_w] + W;
313        const int g = best_uv[off + 1 * uv_w] + W;
314        const int b = best_uv[off + 2 * uv_w] + W;
315        dst_y[i] = ConvertRGBToY(r, g, b);
316      }
317      best_y += w;
318      best_uv += (j & 1) * 3 * uv_w;
319      dst_y += picture->y_stride;
320    }
321    for (best_uv = best_uv_base, j = 0; j < uv_h; ++j) {
322      for (i = 0; i < uv_w; ++i) {
323        const int off = i;
324        const int r = best_uv[off + 0 * uv_w];
325        const int g = best_uv[off + 1 * uv_w];
326        const int b = best_uv[off + 2 * uv_w];
327        dst_u[i] = ConvertRGBToU(r, g, b);
328        dst_v[i] = ConvertRGBToV(r, g, b);
329      }
330      best_uv += 3 * uv_w;
331      dst_u += picture->uv_stride;
332      dst_v += picture->uv_stride;
333    }
334    return 1;
335  }
336  #define SAFE_ALLOC(W, H, T) ((T*)WebPSafeMalloc((W) * (H), sizeof(T)))
337  static int PreprocessARGB(const uint8_t* r_ptr,
338                            const uint8_t* g_ptr,
339                            const uint8_t* b_ptr,
340                            int step, int rgb_stride,
341                            WebPPicture* const picture) {
342    const int w = (picture->width + 1) & ~1;
343    const int h = (picture->height + 1) & ~1;
344    const int uv_w = w >> 1;
345    const int uv_h = h >> 1;
346    uint64_t prev_diff_y_sum = ~0;
347    int j, iter;
348    fixed_y_t* const tmp_buffer = SAFE_ALLOC(w * 3, 2, fixed_y_t);   
349    fixed_y_t* const best_y_base = SAFE_ALLOC(w, h, fixed_y_t);
350    fixed_y_t* const target_y_base = SAFE_ALLOC(w, h, fixed_y_t);
351    fixed_y_t* const best_rgb_y = SAFE_ALLOC(w, 2, fixed_y_t);
352    fixed_t* const best_uv_base = SAFE_ALLOC(uv_w * 3, uv_h, fixed_t);
353    fixed_t* const target_uv_base = SAFE_ALLOC(uv_w * 3, uv_h, fixed_t);
<span onclick='openModal()' class='match'>354    fixed_t* const best_rgb_uv = SAFE_ALLOC(uv_w * 3, 1, fixed_t);
355    fixed_y_t* best_y = best_y_base;
</span>356    fixed_y_t* target_y = target_y_base;
357    fixed_t* best_uv = best_uv_base;
358    fixed_t* target_uv = target_uv_base;
359    const uint64_t diff_y_threshold = (uint64_t)(3.0 * w * h);
360    int ok;
361    if (best_y_base == NULL || best_uv_base == NULL ||
362        target_y_base == NULL || target_uv_base == NULL ||
363        best_rgb_y == NULL || best_rgb_uv == NULL ||
364        tmp_buffer == NULL) {
365      ok = WebPEncodingSetError(picture, VP8_ENC_ERROR_OUT_OF_MEMORY);
366      goto End;
367    }
368    assert(picture->width >= kMinDimensionIterativeConversion);
369    assert(picture->height >= kMinDimensionIterativeConversion);
370    WebPInitConvertARGBToYUV();
371    for (j = 0; j < picture->height; j += 2) {
372      const int is_last_row = (j == picture->height - 1);
373      fixed_y_t* const src1 = tmp_buffer + 0 * w;
374      fixed_y_t* const src2 = tmp_buffer + 3 * w;
375      ImportOneRow(r_ptr, g_ptr, b_ptr, step, picture->width, src1);
376      if (!is_last_row) {
377        ImportOneRow(r_ptr + rgb_stride, g_ptr + rgb_stride, b_ptr + rgb_stride,
378                     step, picture->width, src2);
379      } else {
380        memcpy(src2, src1, 3 * w * sizeof(*src2));
381      }
382      StoreGray(src1, best_y + 0, w);
383      StoreGray(src2, best_y + w, w);
384      UpdateW(src1, target_y, w);
385      UpdateW(src2, target_y + w, w);
386      UpdateChroma(src1, src2, target_uv, uv_w);
387      memcpy(best_uv, target_uv, 3 * uv_w * sizeof(*best_uv));
388      best_y += 2 * w;
389      best_uv += 3 * uv_w;
390      target_y += 2 * w;
391      target_uv += 3 * uv_w;
392      r_ptr += 2 * rgb_stride;
393      g_ptr += 2 * rgb_stride;
394      b_ptr += 2 * rgb_stride;
395    }
396    for (iter = 0; iter < kNumIterations; ++iter) {
397      const fixed_t* cur_uv = best_uv_base;
398      const fixed_t* prev_uv = best_uv_base;
399      uint64_t diff_y_sum = 0;
400      best_y = best_y_base;
401      best_uv = best_uv_base;
402      target_y = target_y_base;
403      target_uv = target_uv_base;
404      for (j = 0; j < h; j += 2) {
405        fixed_y_t* const src1 = tmp_buffer + 0 * w;
406        fixed_y_t* const src2 = tmp_buffer + 3 * w;
407        {
408          const fixed_t* const next_uv = cur_uv + ((j < h - 2) ? 3 * uv_w : 0);
409          InterpolateTwoRows(best_y, prev_uv, cur_uv, next_uv, w, src1, src2);
410          prev_uv = cur_uv;
411          cur_uv = next_uv;
412        }
413        UpdateW(src1, best_rgb_y + 0 * w, w);
414        UpdateW(src2, best_rgb_y + 1 * w, w);
415        UpdateChroma(src1, src2, best_rgb_uv, uv_w);
416        diff_y_sum += WebPSharpYUVUpdateY(target_y, best_rgb_y, best_y, 2 * w);
417        WebPSharpYUVUpdateRGB(target_uv, best_rgb_uv, best_uv, 3 * uv_w);
418        best_y += 2 * w;
419        best_uv += 3 * uv_w;
420        target_y += 2 * w;
421        target_uv += 3 * uv_w;
422      }
423      if (iter > 0) {
424        if (diff_y_sum < diff_y_threshold) break;
425        if (diff_y_sum > prev_diff_y_sum) break;
426      }
427      prev_diff_y_sum = diff_y_sum;
428    }
429    ok = ConvertWRGBToYUV(best_y_base, best_uv_base, picture);
430   End:
431    WebPSafeFree(best_y_base);
432    WebPSafeFree(best_uv_base);
433    WebPSafeFree(target_y_base);
434    WebPSafeFree(target_uv_base);
435    WebPSafeFree(best_rgb_y);
436    WebPSafeFree(best_rgb_uv);
437    WebPSafeFree(tmp_buffer);
438    return ok;
439  }
440  #undef SAFE_ALLOC
441  #define SUM4(ptr, step) LinearToGamma(                     \
442      GammaToLinear((ptr)[0]) +                              \
443      GammaToLinear((ptr)[(step)]) +                         \
444      GammaToLinear((ptr)[rgb_stride]) +                     \
445      GammaToLinear((ptr)[rgb_stride + (step)]), 0)          \
446  
447  #define SUM2(ptr) \
448      LinearToGamma(GammaToLinear((ptr)[0]) + GammaToLinear((ptr)[rgb_stride]), 1)
449  #define SUM2ALPHA(ptr) ((ptr)[0] + (ptr)[rgb_stride])
450  #define SUM4ALPHA(ptr) (SUM2ALPHA(ptr) + SUM2ALPHA((ptr) + 4))
451  #if defined(USE_INVERSE_ALPHA_TABLE)
452  static const int kAlphaFix = 19;
453  static const uint32_t kInvAlpha[4 * 0xff + 1] = {
454    0,  &bsol;* alpha = 0 */
455    524288, 262144, 174762, 131072, 104857, 87381, 74898, 65536,
456    58254, 52428, 47662, 43690, 40329, 37449, 34952, 32768,
457    30840, 29127, 27594, 26214, 24966, 23831, 22795, 21845,
458    20971, 20164, 19418, 18724, 18078, 17476, 16912, 16384,
459    15887, 15420, 14979, 14563, 14169, 13797, 13443, 13107,
460    12787, 12483, 12192, 11915, 11650, 11397, 11155, 10922,
461    10699, 10485, 10280, 10082, 9892, 9709, 9532, 9362,
462    9198, 9039, 8886, 8738, 8594, 8456, 8322, 8192,
463    8065, 7943, 7825, 7710, 7598, 7489, 7384, 7281,
464    7182, 7084, 6990, 6898, 6808, 6721, 6636, 6553,
465    6472, 6393, 6316, 6241, 6168, 6096, 6026, 5957,
466    5890, 5825, 5761, 5698, 5637, 5577, 5518, 5461,
467    5405, 5349, 5295, 5242, 5190, 5140, 5090, 5041,
468    4993, 4946, 4899, 4854, 4809, 4766, 4723, 4681,
469    4639, 4599, 4559, 4519, 4481, 4443, 4405, 4369,
470    4332, 4297, 4262, 4228, 4194, 4161, 4128, 4096,
471    4064, 4032, 4002, 3971, 3942, 3912, 3883, 3855,
472    3826, 3799, 3771, 3744, 3718, 3692, 3666, 3640,
473    3615, 3591, 3566, 3542, 3518, 3495, 3472, 3449,
474    3426, 3404, 3382, 3360, 3339, 3318, 3297, 3276,
475    3256, 3236, 3216, 3196, 3177, 3158, 3139, 3120,
476    3102, 3084, 3066, 3048, 3030, 3013, 2995, 2978,
477    2962, 2945, 2928, 2912, 2896, 2880, 2864, 2849,
478    2833, 2818, 2803, 2788, 2774, 2759, 2744, 2730,
479    2716, 2702, 2688, 2674, 2661, 2647, 2634, 2621,
480    2608, 2595, 2582, 2570, 2557, 2545, 2532, 2520,
481    2508, 2496, 2484, 2473, 2461, 2449, 2438, 2427,
482    2416, 2404, 2394, 2383, 2372, 2361, 2351, 2340,
483    2330, 2319, 2309, 2299, 2289, 2279, 2269, 2259,
484    2250, 2240, 2231, 2221, 2212, 2202, 2193, 2184,
485    2175, 2166, 2157, 2148, 2139, 2131, 2122, 2114,
486    2105, 2097, 2088, 2080, 2072, 2064, 2056, 2048,
487    2040, 2032, 2024, 2016, 2008, 2001, 1993, 1985,
488    1978, 1971, 1963, 1956, 1949, 1941, 1934, 1927,
489    1920, 1913, 1906, 1899, 1892, 1885, 1879, 1872,
490    1865, 1859, 1852, 1846, 1839, 1833, 1826, 1820,
491    1814, 1807, 1801, 1795, 1789, 1783, 1777, 1771,
492    1765, 1759, 1753, 1747, 1741, 1736, 1730, 1724,
493    1718, 1713, 1707, 1702, 1696, 1691, 1685, 1680,
494    1675, 1669, 1664, 1659, 1653, 1648, 1643, 1638,
495    1633, 1628, 1623, 1618, 1613, 1608, 1603, 1598,
496    1593, 1588, 1583, 1579, 1574, 1569, 1565, 1560,
497    1555, 1551, 1546, 1542, 1537, 1533, 1528, 1524,
498    1519, 1515, 1510, 1506, 1502, 1497, 1493, 1489,
499    1485, 1481, 1476, 1472, 1468, 1464, 1460, 1456,
500    1452, 1448, 1444, 1440, 1436, 1432, 1428, 1424,
501    1420, 1416, 1413, 1409, 1405, 1401, 1398, 1394,
502    1390, 1387, 1383, 1379, 1376, 1372, 1368, 1365,
503    1361, 1358, 1354, 1351, 1347, 1344, 1340, 1337,
504    1334, 1330, 1327, 1323, 1320, 1317, 1314, 1310,
505    1307, 1304, 1300, 1297, 1294, 1291, 1288, 1285,
506    1281, 1278, 1275, 1272, 1269, 1266, 1263, 1260,
507    1257, 1254, 1251, 1248, 1245, 1242, 1239, 1236,
508    1233, 1230, 1227, 1224, 1222, 1219, 1216, 1213,
509    1210, 1208, 1205, 1202, 1199, 1197, 1194, 1191,
510    1188, 1186, 1183, 1180, 1178, 1175, 1172, 1170,
511    1167, 1165, 1162, 1159, 1157, 1154, 1152, 1149,
512    1147, 1144, 1142, 1139, 1137, 1134, 1132, 1129,
513    1127, 1125, 1122, 1120, 1117, 1115, 1113, 1110,
514    1108, 1106, 1103, 1101, 1099, 1096, 1094, 1092,
515    1089, 1087, 1085, 1083, 1081, 1078, 1076, 1074,
516    1072, 1069, 1067, 1065, 1063, 1061, 1059, 1057,
517    1054, 1052, 1050, 1048, 1046, 1044, 1042, 1040,
518    1038, 1036, 1034, 1032, 1030, 1028, 1026, 1024,
519    1022, 1020, 1018, 1016, 1014, 1012, 1010, 1008,
520    1006, 1004, 1002, 1000, 998, 996, 994, 992,
521    991, 989, 987, 985, 983, 981, 979, 978,
522    976, 974, 972, 970, 969, 967, 965, 963,
523    961, 960, 958, 956, 954, 953, 951, 949,
524    948, 946, 944, 942, 941, 939, 937, 936,
525    934, 932, 931, 929, 927, 926, 924, 923,
526    921, 919, 918, 916, 914, 913, 911, 910,
527    908, 907, 905, 903, 902, 900, 899, 897,
528    896, 894, 893, 891, 890, 888, 887, 885,
529    884, 882, 881, 879, 878, 876, 875, 873,
530    872, 870, 869, 868, 866, 865, 863, 862,
531    860, 859, 858, 856, 855, 853, 852, 851,
532    849, 848, 846, 845, 844, 842, 841, 840,
533    838, 837, 836, 834, 833, 832, 830, 829,
534    828, 826, 825, 824, 823, 821, 820, 819,
535    817, 816, 815, 814, 812, 811, 810, 809,
536    807, 806, 805, 804, 802, 801, 800, 799,
537    798, 796, 795, 794, 793, 791, 790, 789,
538    788, 787, 786, 784, 783, 782, 781, 780,
539    779, 777, 776, 775, 774, 773, 772, 771,
540    769, 768, 767, 766, 765, 764, 763, 762,
541    760, 759, 758, 757, 756, 755, 754, 753,
542    752, 751, 750, 748, 747, 746, 745, 744,
543    743, 742, 741, 740, 739, 738, 737, 736,
544    735, 734, 733, 732, 731, 730, 729, 728,
545    727, 726, 725, 724, 723, 722, 721, 720,
546    719, 718, 717, 716, 715, 714, 713, 712,
547    711, 710, 709, 708, 707, 706, 705, 704,
548    703, 702, 701, 700, 699, 699, 698, 697,
549    696, 695, 694, 693, 692, 691, 690, 689,
550    688, 688, 687, 686, 685, 684, 683, 682,
551    681, 680, 680, 679, 678, 677, 676, 675,
552    674, 673, 673, 672, 671, 670, 669, 668,
553    667, 667, 666, 665, 664, 663, 662, 661,
554    661, 660, 659, 658, 657, 657, 656, 655,
555    654, 653, 652, 652, 651, 650, 649, 648,
556    648, 647, 646, 645, 644, 644, 643, 642,
557    641, 640, 640, 639, 638, 637, 637, 636,
558    635, 634, 633, 633, 632, 631, 630, 630,
559    629, 628, 627, 627, 626, 625, 624, 624,
560    623, 622, 621, 621, 620, 619, 618, 618,
561    617, 616, 616, 615, 614, 613, 613, 612,
562    611, 611, 610, 609, 608, 608, 607, 606,
563    606, 605, 604, 604, 603, 602, 601, 601,
564    600, 599, 599, 598, 597, 597, 596, 595,
565    595, 594, 593, 593, 592, 591, 591, 590,
566    589, 589, 588, 587, 587, 586, 585, 585,
567    584, 583, 583, 582, 581, 581, 580, 579,
568    579, 578, 578, 577, 576, 576, 575, 574,
569    574, 573, 572, 572, 571, 571, 570, 569,
570    569, 568, 568, 567, 566, 566, 565, 564,
571    564, 563, 563, 562, 561, 561, 560, 560,
572    559, 558, 558, 557, 557, 556, 555, 555,
573    554, 554, 553, 553, 552, 551, 551, 550,
574    550, 549, 548, 548, 547, 547, 546, 546,
575    545, 544, 544, 543, 543, 542, 542, 541,
576    541, 540, 539, 539, 538, 538, 537, 537,
577    536, 536, 535, 534, 534, 533, 533, 532,
578    532, 531, 531, 530, 530, 529, 529, 528,
579    527, 527, 526, 526, 525, 525, 524, 524,
580    523, 523, 522, 522, 521, 521, 520, 520,
581    519, 519, 518, 518, 517, 517, 516, 516,
582    515, 515, 514, 514
583  };
584  #define DIVIDE_BY_ALPHA(sum, a)  (((sum) * kInvAlpha[(a)]) >> (kAlphaFix - 2))
585  #else
586  #define DIVIDE_BY_ALPHA(sum, a) (4 * (sum) / (a))
587  #endif  
588  static WEBP_INLINE int LinearToGammaWeighted(const uint8_t* src,
589                                               const uint8_t* a_ptr,
590                                               uint32_t total_a, int step,
591                                               int rgb_stride) {
592    const uint32_t sum =
593        a_ptr[0] * GammaToLinear(src[0]) +
594        a_ptr[step] * GammaToLinear(src[step]) +
595        a_ptr[rgb_stride] * GammaToLinear(src[rgb_stride]) +
596        a_ptr[rgb_stride + step] * GammaToLinear(src[rgb_stride + step]);
597    assert(total_a > 0 && total_a <= 4 * 0xff);
598  #if defined(USE_INVERSE_ALPHA_TABLE)
599    assert((uint64_t)sum * kInvAlpha[total_a] < ((uint64_t)1 << 32));
600  #endif
601    return LinearToGamma(DIVIDE_BY_ALPHA(sum, total_a), 0);
602  }
603  static WEBP_INLINE void ConvertRowToY(const uint8_t* const r_ptr,
604                                        const uint8_t* const g_ptr,
605                                        const uint8_t* const b_ptr,
606                                        int step,
607                                        uint8_t* const dst_y,
608                                        int width,
609                                        VP8Random* const rg) {
610    int i, j;
611    for (i = 0, j = 0; i < width; i += 1, j += step) {
612      dst_y[i] = RGBToY(r_ptr[j], g_ptr[j], b_ptr[j], rg);
613    }
614  }
615  static WEBP_INLINE void AccumulateRGBA(const uint8_t* const r_ptr,
616                                         const uint8_t* const g_ptr,
617                                         const uint8_t* const b_ptr,
618                                         const uint8_t* const a_ptr,
619                                         int rgb_stride,
620                                         uint16_t* dst, int width) {
621    int i, j;
622    for (i = 0, j = 0; i < (width >> 1); i += 1, j += 2 * 4, dst += 4) {
623      const uint32_t a = SUM4ALPHA(a_ptr + j);
624      int r, g, b;
625      if (a == 4 * 0xff || a == 0) {
626        r = SUM4(r_ptr + j, 4);
627        g = SUM4(g_ptr + j, 4);
628        b = SUM4(b_ptr + j, 4);
629      } else {
630        r = LinearToGammaWeighted(r_ptr + j, a_ptr + j, a, 4, rgb_stride);
631        g = LinearToGammaWeighted(g_ptr + j, a_ptr + j, a, 4, rgb_stride);
632        b = LinearToGammaWeighted(b_ptr + j, a_ptr + j, a, 4, rgb_stride);
633      }
634      dst[0] = r;
635      dst[1] = g;
636      dst[2] = b;
637      dst[3] = a;
638    }
639    if (width & 1) {
640      const uint32_t a = 2u * SUM2ALPHA(a_ptr + j);
641      int r, g, b;
642      if (a == 4 * 0xff || a == 0) {
643        r = SUM2(r_ptr + j);
644        g = SUM2(g_ptr + j);
645        b = SUM2(b_ptr + j);
646      } else {
647        r = LinearToGammaWeighted(r_ptr + j, a_ptr + j, a, 0, rgb_stride);
648        g = LinearToGammaWeighted(g_ptr + j, a_ptr + j, a, 0, rgb_stride);
649        b = LinearToGammaWeighted(b_ptr + j, a_ptr + j, a, 0, rgb_stride);
650      }
651      dst[0] = r;
652      dst[1] = g;
653      dst[2] = b;
654      dst[3] = a;
655    }
656  }
657  static WEBP_INLINE void AccumulateRGB(const uint8_t* const r_ptr,
658                                        const uint8_t* const g_ptr,
659                                        const uint8_t* const b_ptr,
660                                        int step, int rgb_stride,
661                                        uint16_t* dst, int width) {
662    int i, j;
663    for (i = 0, j = 0; i < (width >> 1); i += 1, j += 2 * step, dst += 4) {
664      dst[0] = SUM4(r_ptr + j, step);
665      dst[1] = SUM4(g_ptr + j, step);
666      dst[2] = SUM4(b_ptr + j, step);
667    }
668    if (width & 1) {
669      dst[0] = SUM2(r_ptr + j);
670      dst[1] = SUM2(g_ptr + j);
671      dst[2] = SUM2(b_ptr + j);
672    }
673  }
674  static WEBP_INLINE void ConvertRowsToUV(const uint16_t* rgb,
675                                          uint8_t* const dst_u,
676                                          uint8_t* const dst_v,
677                                          int width,
678                                          VP8Random* const rg) {
679    int i;
680    for (i = 0; i < width; i += 1, rgb += 4) {
681      const int r = rgb[0], g = rgb[1], b = rgb[2];
682      dst_u[i] = RGBToU(r, g, b, rg);
683      dst_v[i] = RGBToV(r, g, b, rg);
684    }
685  }
686  static int ImportYUVAFromRGBA(const uint8_t* r_ptr,
687                                const uint8_t* g_ptr,
688                                const uint8_t* b_ptr,
689                                const uint8_t* a_ptr,
690                                int step,         
691                                int rgb_stride,   
692                                float dithering,
693                                int use_iterative_conversion,
694                                WebPPicture* const picture) {
695    int y;
696    const int width = picture->width;
697    const int height = picture->height;
698    const int has_alpha = CheckNonOpaque(a_ptr, width, height, step, rgb_stride);
699    const int is_rgb = (r_ptr < b_ptr);  
700    picture->colorspace = has_alpha ? WEBP_YUV420A : WEBP_YUV420;
701    picture->use_argb = 0;
702    if (width < kMinDimensionIterativeConversion ||
703        height < kMinDimensionIterativeConversion) {
704      use_iterative_conversion = 0;
705    }
706    if (!WebPPictureAllocYUVA(picture, width, height)) {
707      return 0;
708    }
709    if (has_alpha) {
710      assert(step == 4);
711  #if defined(USE_GAMMA_COMPRESSION) && defined(USE_INVERSE_ALPHA_TABLE)
712      assert(kAlphaFix + kGammaFix <= 31);
713  #endif
714    }
715    if (use_iterative_conversion) {
716      InitGammaTablesS();
717      if (!PreprocessARGB(r_ptr, g_ptr, b_ptr, step, rgb_stride, picture)) {
718        return 0;
719      }
720      if (has_alpha) {
721        WebPExtractAlpha(a_ptr, rgb_stride, width, height,
722                         picture->a, picture->a_stride);
723      }
724    } else {
725      const int uv_width = (width + 1) >> 1;
726      int use_dsp = (step == 3);  
727      uint16_t* const tmp_rgb =
728          (uint16_t*)WebPSafeMalloc(4 * uv_width, sizeof(*tmp_rgb));
729      uint8_t* dst_y = picture->y;
730      uint8_t* dst_u = picture->u;
731      uint8_t* dst_v = picture->v;
732      uint8_t* dst_a = picture->a;
733      VP8Random base_rg;
734      VP8Random* rg = NULL;
735      if (dithering > 0.) {
736        VP8InitRandom(&base_rg, dithering);
737        rg = &base_rg;
738        use_dsp = 0;   
739      }
740      WebPInitConvertARGBToYUV();
741      InitGammaTables();
742      if (tmp_rgb == NULL) return 0;  
743      for (y = 0; y < (height >> 1); ++y) {
744        int rows_have_alpha = has_alpha;
745        if (use_dsp) {
746          if (is_rgb) {
747            WebPConvertRGB24ToY(r_ptr, dst_y, width);
748            WebPConvertRGB24ToY(r_ptr + rgb_stride,
749                                dst_y + picture->y_stride, width);
750          } else {
751            WebPConvertBGR24ToY(b_ptr, dst_y, width);
752            WebPConvertBGR24ToY(b_ptr + rgb_stride,
753                                dst_y + picture->y_stride, width);
754          }
755        } else {
756          ConvertRowToY(r_ptr, g_ptr, b_ptr, step, dst_y, width, rg);
757          ConvertRowToY(r_ptr + rgb_stride,
758                        g_ptr + rgb_stride,
759                        b_ptr + rgb_stride, step,
760                        dst_y + picture->y_stride, width, rg);
761        }
762        dst_y += 2 * picture->y_stride;
763        if (has_alpha) {
764          rows_have_alpha &= !WebPExtractAlpha(a_ptr, rgb_stride, width, 2,
765                                               dst_a, picture->a_stride);
766          dst_a += 2 * picture->a_stride;
767        }
768        if (!rows_have_alpha) {
769          AccumulateRGB(r_ptr, g_ptr, b_ptr, step, rgb_stride, tmp_rgb, width);
770        } else {
771          AccumulateRGBA(r_ptr, g_ptr, b_ptr, a_ptr, rgb_stride, tmp_rgb, width);
772        }
773        if (rg == NULL) {
774          WebPConvertRGBA32ToUV(tmp_rgb, dst_u, dst_v, uv_width);
775        } else {
776          ConvertRowsToUV(tmp_rgb, dst_u, dst_v, uv_width, rg);
777        }
778        dst_u += picture->uv_stride;
779        dst_v += picture->uv_stride;
780        r_ptr += 2 * rgb_stride;
781        b_ptr += 2 * rgb_stride;
782        g_ptr += 2 * rgb_stride;
783        if (has_alpha) a_ptr += 2 * rgb_stride;
784      }
785      if (height & 1) {    
786        int row_has_alpha = has_alpha;
787        if (use_dsp) {
788          if (r_ptr < b_ptr) {
789            WebPConvertRGB24ToY(r_ptr, dst_y, width);
790          } else {
791            WebPConvertBGR24ToY(b_ptr, dst_y, width);
792          }
793        } else {
794          ConvertRowToY(r_ptr, g_ptr, b_ptr, step, dst_y, width, rg);
795        }
796        if (row_has_alpha) {
797          row_has_alpha &= !WebPExtractAlpha(a_ptr, 0, width, 1, dst_a, 0);
798        }
799        if (!row_has_alpha) {
800          AccumulateRGB(r_ptr, g_ptr, b_ptr, step, &bsol;* rgb_stride = */ 0,
801                        tmp_rgb, width);
802        } else {
803          AccumulateRGBA(r_ptr, g_ptr, b_ptr, a_ptr, &bsol;* rgb_stride = */ 0,
804                         tmp_rgb, width);
805        }
806        if (rg == NULL) {
807          WebPConvertRGBA32ToUV(tmp_rgb, dst_u, dst_v, uv_width);
808        } else {
809          ConvertRowsToUV(tmp_rgb, dst_u, dst_v, uv_width, rg);
810        }
811      }
812      WebPSafeFree(tmp_rgb);
813    }
814    return 1;
815  }
816  #undef SUM4
817  #undef SUM2
818  #undef SUM4ALPHA
819  #undef SUM2ALPHA
820  static int PictureARGBToYUVA(WebPPicture* picture, WebPEncCSP colorspace,
821                               float dithering, int use_iterative_conversion) {
822    if (picture == NULL) return 0;
823    if (picture->argb == NULL) {
824      return WebPEncodingSetError(picture, VP8_ENC_ERROR_NULL_PARAMETER);
825    } else if ((colorspace & WEBP_CSP_UV_MASK) != WEBP_YUV420) {
826      return WebPEncodingSetError(picture, VP8_ENC_ERROR_INVALID_CONFIGURATION);
827    } else {
828      const uint8_t* const argb = (const uint8_t*)picture->argb;
829      const uint8_t* const a = argb + CHANNEL_OFFSET(0);
830      const uint8_t* const r = argb + CHANNEL_OFFSET(1);
831      const uint8_t* const g = argb + CHANNEL_OFFSET(2);
832      const uint8_t* const b = argb + CHANNEL_OFFSET(3);
833      picture->colorspace = WEBP_YUV420;
834      return ImportYUVAFromRGBA(r, g, b, a, 4, 4 * picture->argb_stride,
835                                dithering, use_iterative_conversion, picture);
836    }
837  }
838  int WebPPictureARGBToYUVADithered(WebPPicture* picture, WebPEncCSP colorspace,
839                                    float dithering) {
840    return PictureARGBToYUVA(picture, colorspace, dithering, 0);
841  }
842  int WebPPictureARGBToYUVA(WebPPicture* picture, WebPEncCSP colorspace) {
843    return PictureARGBToYUVA(picture, colorspace, 0.f, 0);
844  }
845  int WebPPictureSharpARGBToYUVA(WebPPicture* picture) {
846    return PictureARGBToYUVA(picture, WEBP_YUV420, 0.f, 1);
847  }
848  int WebPPictureSmartARGBToYUVA(WebPPicture* picture) {
849    return WebPPictureSharpARGBToYUVA(picture);
850  }
851  int WebPPictureYUVAToARGB(WebPPicture* picture) {
852    if (picture == NULL) return 0;
853    if (picture->y == NULL || picture->u == NULL || picture->v == NULL) {
854      return WebPEncodingSetError(picture, VP8_ENC_ERROR_NULL_PARAMETER);
855    }
856    if ((picture->colorspace & WEBP_CSP_ALPHA_BIT) && picture->a == NULL) {
857      return WebPEncodingSetError(picture, VP8_ENC_ERROR_NULL_PARAMETER);
858    }
859    if ((picture->colorspace & WEBP_CSP_UV_MASK) != WEBP_YUV420) {
860      return WebPEncodingSetError(picture, VP8_ENC_ERROR_INVALID_CONFIGURATION);
861    }
862    if (!WebPPictureAllocARGB(picture, picture->width, picture->height)) return 0;
863    picture->use_argb = 1;
864    {
865      int y;
866      const int width = picture->width;
867      const int height = picture->height;
868      const int argb_stride = 4 * picture->argb_stride;
869      uint8_t* dst = (uint8_t*)picture->argb;
870      const uint8_t* cur_u = picture->u, *cur_v = picture->v, *cur_y = picture->y;
871      WebPUpsampleLinePairFunc upsample =
872          WebPGetLinePairConverter(ALPHA_OFFSET > 0);
873      upsample(cur_y, NULL, cur_u, cur_v, cur_u, cur_v, dst, NULL, width);
874      cur_y += picture->y_stride;
875      dst += argb_stride;
876      for (y = 1; y + 1 < height; y += 2) {
877        const uint8_t* const top_u = cur_u;
878        const uint8_t* const top_v = cur_v;
879        cur_u += picture->uv_stride;
880        cur_v += picture->uv_stride;
881        upsample(cur_y, cur_y + picture->y_stride, top_u, top_v, cur_u, cur_v,
882                 dst, dst + argb_stride, width);
883        cur_y += 2 * picture->y_stride;
884        dst += 2 * argb_stride;
885      }
886      if (height > 1 && !(height & 1)) {
887        upsample(cur_y, NULL, cur_u, cur_v, cur_u, cur_v, dst, NULL, width);
888      }
889      if (picture->colorspace & WEBP_CSP_ALPHA_BIT) {
890        for (y = 0; y < height; ++y) {
891          uint32_t* const argb_dst = picture->argb + y * picture->argb_stride;
892          const uint8_t* const src = picture->a + y * picture->a_stride;
893          int x;
894          for (x = 0; x < width; ++x) {
895            argb_dst[x] = (argb_dst[x] & 0x00ffffffu) | ((uint32_t)src[x] << 24);
896          }
897        }
898      }
899    }
900    return 1;
901  }
902  static int Import(WebPPicture* const picture,
903                    const uint8_t* rgb, int rgb_stride,
904                    int step, int swap_rb, int import_alpha) {
905    int y;
906    const uint8_t* r_ptr = rgb + (swap_rb ? 2 : 0);
907    const uint8_t* g_ptr = rgb + 1;
908    const uint8_t* b_ptr = rgb + (swap_rb ? 0 : 2);
909    const int width = picture->width;
910    const int height = picture->height;
911    if (!picture->use_argb) {
912      const uint8_t* a_ptr = import_alpha ? rgb + 3 : NULL;
913      return ImportYUVAFromRGBA(r_ptr, g_ptr, b_ptr, a_ptr, step, rgb_stride,
914                                0.f &bsol;* no dithering */, 0, picture);
915    }
916    if (!WebPPictureAlloc(picture)) return 0;
917    VP8LDspInit();
918    WebPInitAlphaProcessing();
919    if (import_alpha) {
920      uint32_t* dst = picture->argb;
921      const int do_copy = (ALPHA_OFFSET == 3) && swap_rb;
922      assert(step == 4);
923      if (do_copy) {
924        for (y = 0; y < height; ++y) {
925          memcpy(dst, rgb, width * 4);
926          rgb += rgb_stride;
927          dst += picture->argb_stride;
928        }
929      } else {
930        for (y = 0; y < height; ++y) {
931  #ifdef WORDS_BIGENDIAN
932          const uint8_t* a_ptr = rgb + 3;
933          WebPPackARGB(a_ptr, r_ptr, g_ptr, b_ptr, width, dst);
934          r_ptr += rgb_stride;
935          g_ptr += rgb_stride;
936          b_ptr += rgb_stride;
937  #else
938          VP8LConvertBGRAToRGBA((const uint32_t*)rgb, width, (uint8_t*)dst);
939  #endif
940          rgb += rgb_stride;
941          dst += picture->argb_stride;
942        }
943      }
944    } else {
945      uint32_t* dst = picture->argb;
946      assert(step >= 3);
947      for (y = 0; y < height; ++y) {
948        WebPPackRGB(r_ptr, g_ptr, b_ptr, width, step, dst);
949        r_ptr += rgb_stride;
950        g_ptr += rgb_stride;
951        b_ptr += rgb_stride;
952        dst += picture->argb_stride;
953      }
954    }
955    return 1;
956  }
957  #if !defined(WEBP_REDUCE_CSP)
958  int WebPPictureImportBGR(WebPPicture* picture,
959                           const uint8_t* rgb, int rgb_stride) {
960    return (picture != NULL && rgb != NULL)
961               ? Import(picture, rgb, rgb_stride, 3, 1, 0)
962               : 0;
963  }
964  int WebPPictureImportBGRA(WebPPicture* picture,
965                            const uint8_t* rgba, int rgba_stride) {
966    return (picture != NULL && rgba != NULL)
967               ? Import(picture, rgba, rgba_stride, 4, 1, 1)
968               : 0;
969  }
970  int WebPPictureImportBGRX(WebPPicture* picture,
971                            const uint8_t* rgba, int rgba_stride) {
972    return (picture != NULL && rgba != NULL)
973               ? Import(picture, rgba, rgba_stride, 4, 1, 0)
974               : 0;
975  }
976  #endif   
977  int WebPPictureImportRGB(WebPPicture* picture,
978                           const uint8_t* rgb, int rgb_stride) {
979    return (picture != NULL && rgb != NULL)
980               ? Import(picture, rgb, rgb_stride, 3, 0, 0)
981               : 0;
982  }
983  int WebPPictureImportRGBA(WebPPicture* picture,
984                            const uint8_t* rgba, int rgba_stride) {
985    return (picture != NULL && rgba != NULL)
986               ? Import(picture, rgba, rgba_stride, 4, 0, 1)
987               : 0;
988  }
989  int WebPPictureImportRGBX(WebPPicture* picture,
990                            const uint8_t* rgba, int rgba_stride) {
991    return (picture != NULL && rgba != NULL)
992               ? Import(picture, rgba, rgba_stride, 4, 0, 0)
993               : 0;
994  }
</code></pre>
        </div>
        <div class="column">
            <h3>PINRemoteImage-MDEwOlJlcG9zaXRvcnkzOTUzNzEwMw==-flat-picture_csp_enc.c</h3>
            <pre><code>1  #include <assert.h>
2  #include <stdlib.h>
3  #include <math.h>
4  #include "src/enc/vp8i_enc.h"
5  #include "src/utils/random_utils.h"
6  #include "src/utils/utils.h"
7  #include "src/dsp/dsp.h"
8  #include "src/dsp/lossless.h"
9  #include "src/dsp/yuv.h"
10  #define USE_GAMMA_COMPRESSION
11  #define USE_INVERSE_ALPHA_TABLE
12  #ifdef WORDS_BIGENDIAN
13  #define CHANNEL_OFFSET(i) (i)
14  #else
15  #define CHANNEL_OFFSET(i) (3-(i))
16  #endif
17  #define ALPHA_OFFSET CHANNEL_OFFSET(0)
18  static int CheckNonOpaque(const uint8_t* alpha, int width, int height,
19                            int x_step, int y_step) {
20    if (alpha == NULL) return 0;
21    WebPInitAlphaProcessing();
22    if (x_step == 1) {
23      for (; height-- > 0; alpha += y_step) {
24        if (WebPHasAlpha8b(alpha, width)) return 1;
25      }
26    } else {
27      for (; height-- > 0; alpha += y_step) {
28        if (WebPHasAlpha32b(alpha, width)) return 1;
29      }
30    }
31    return 0;
32  }
33  int WebPPictureHasTransparency(const WebPPicture* picture) {
34    if (picture == NULL) return 0;
35    if (!picture->use_argb) {
36      return CheckNonOpaque(picture->a, picture->width, picture->height,
37                            1, picture->a_stride);
38    } else {
39      const int alpha_offset = ALPHA_OFFSET;
40      return CheckNonOpaque((const uint8_t*)picture->argb + alpha_offset,
41                            picture->width, picture->height,
42                            4, picture->argb_stride * sizeof(*picture->argb));
43    }
44    return 0;
45  }
46  #if defined(USE_GAMMA_COMPRESSION)
47  #define kGamma 0.80      
48  #define kGammaFix 12     
49  #define kGammaScale ((1 << kGammaFix) - 1)
50  #define kGammaTabFix 7   
51  #define kGammaTabScale (1 << kGammaTabFix)
52  #define kGammaTabRounder (kGammaTabScale >> 1)
53  #define kGammaTabSize (1 << (kGammaFix - kGammaTabFix))
54  static int kLinearToGammaTab[kGammaTabSize + 1];
55  static uint16_t kGammaToLinearTab[256];
56  static volatile int kGammaTablesOk = 0;
57  static WEBP_TSAN_IGNORE_FUNCTION void InitGammaTables(void) {
58    if (!kGammaTablesOk) {
59      int v;
60      const double scale = (double)(1 << kGammaTabFix) / kGammaScale;
61      const double norm = 1. / 255.;
62      for (v = 0; v <= 255; ++v) {
63        kGammaToLinearTab[v] =
64            (uint16_t)(pow(norm * v, kGamma) * kGammaScale + .5);
65      }
66      for (v = 0; v <= kGammaTabSize; ++v) {
67        kLinearToGammaTab[v] = (int)(255. * pow(scale * v, 1. / kGamma) + .5);
68      }
69      kGammaTablesOk = 1;
70    }
71  }
72  static WEBP_INLINE uint32_t GammaToLinear(uint8_t v) {
73    return kGammaToLinearTab[v];
74  }
75  static WEBP_INLINE int Interpolate(int v) {
76    const int tab_pos = v >> (kGammaTabFix + 2);    
77    const int x = v & ((kGammaTabScale << 2) - 1);  
78    const int v0 = kLinearToGammaTab[tab_pos];
79    const int v1 = kLinearToGammaTab[tab_pos + 1];
80    const int y = v1 * x + v0 * ((kGammaTabScale << 2) - x);   
81    assert(tab_pos + 1 < kGammaTabSize + 1);
82    return y;
83  }
84  static WEBP_INLINE int LinearToGamma(uint32_t base_value, int shift) {
85    const int y = Interpolate(base_value << shift);   
86    return (y + kGammaTabRounder) >> kGammaTabFix;    
87  }
88  #else
89  static void InitGammaTables(void) {}
90  static WEBP_INLINE uint32_t GammaToLinear(uint8_t v) { return v; }
91  static WEBP_INLINE int LinearToGamma(uint32_t base_value, int shift) {
92    return (int)(base_value << shift);
93  }
94  #endif    
95  static int RGBToY(int r, int g, int b, VP8Random* const rg) {
96    return (rg == NULL) ? VP8RGBToY(r, g, b, YUV_HALF)
97                        : VP8RGBToY(r, g, b, VP8RandomBits(rg, YUV_FIX));
98  }
99  static int RGBToU(int r, int g, int b, VP8Random* const rg) {
100    return (rg == NULL) ? VP8RGBToU(r, g, b, YUV_HALF << 2)
101                        : VP8RGBToU(r, g, b, VP8RandomBits(rg, YUV_FIX + 2));
102  }
103  static int RGBToV(int r, int g, int b, VP8Random* const rg) {
104    return (rg == NULL) ? VP8RGBToV(r, g, b, YUV_HALF << 2)
105                        : VP8RGBToV(r, g, b, VP8RandomBits(rg, YUV_FIX + 2));
106  }
107  static const int kNumIterations = 4;
108  static const int kMinDimensionIterativeConversion = 4;
109  #define SFIX 2                
110  typedef int16_t fixed_t;      
111  typedef uint16_t fixed_y_t;   
112  #define SHALF (1 << SFIX >> 1)
113  #define MAX_Y_T ((256 << SFIX) - 1)
114  #define SROUNDER (1 << (YUV_FIX + SFIX - 1))
115  #if defined(USE_GAMMA_COMPRESSION)
116  #define kGammaF (1./0.45)
117  static uint32_t kLinearToGammaTabS[kGammaTabSize + 2];
118  #define GAMMA_TO_LINEAR_BITS 14
119  static uint32_t kGammaToLinearTabS[MAX_Y_T + 1];   
120  static volatile int kGammaTablesSOk = 0;
121  static WEBP_TSAN_IGNORE_FUNCTION void InitGammaTablesS(void) {
122    assert(2 * GAMMA_TO_LINEAR_BITS < 32);  
123    if (!kGammaTablesSOk) {
124      int v;
125      const double norm = 1. / MAX_Y_T;
126      const double scale = 1. / kGammaTabSize;
127      const double a = 0.09929682680944;
128      const double thresh = 0.018053968510807;
129      const double final_scale = 1 << GAMMA_TO_LINEAR_BITS;
130      for (v = 0; v <= MAX_Y_T; ++v) {
131        const double g = norm * v;
132        double value;
133        if (g <= thresh * 4.5) {
134          value = g / 4.5;
135        } else {
136          const double a_rec = 1. / (1. + a);
137          value = pow(a_rec * (g + a), kGammaF);
138        }
139        kGammaToLinearTabS[v] = (uint32_t)(value * final_scale + .5);
140      }
141      for (v = 0; v <= kGammaTabSize; ++v) {
142        const double g = scale * v;
143        double value;
144        if (g <= thresh) {
145          value = 4.5 * g;
146        } else {
147          value = (1. + a) * pow(g, 1. / kGammaF) - a;
148        }
149        kLinearToGammaTabS[v] =
150            (uint32_t)(MAX_Y_T * value) + (1 << GAMMA_TO_LINEAR_BITS >> 1);
151      }
152      kLinearToGammaTabS[kGammaTabSize + 1] = kLinearToGammaTabS[kGammaTabSize];
153      kGammaTablesSOk = 1;
154    }
155  }
156  static WEBP_INLINE uint32_t GammaToLinearS(int v) {
157    return kGammaToLinearTabS[v];
158  }
159  static WEBP_INLINE uint32_t LinearToGammaS(uint32_t value) {
160    const uint32_t v = value * kGammaTabSize;
161    const uint32_t tab_pos = v >> GAMMA_TO_LINEAR_BITS;
162    const uint32_t x = v - (tab_pos << GAMMA_TO_LINEAR_BITS);  
163    const uint32_t v0 = kLinearToGammaTabS[tab_pos + 0];
164    const uint32_t v1 = kLinearToGammaTabS[tab_pos + 1];
165    const uint32_t v2 = (v1 - v0) * x;    
166    const uint32_t result = v0 + (v2 >> GAMMA_TO_LINEAR_BITS);
167    return result;
168  }
169  #else
170  static void InitGammaTablesS(void) {}
171  static WEBP_INLINE uint32_t GammaToLinearS(int v) {
172    return (v << GAMMA_TO_LINEAR_BITS) / MAX_Y_T;
173  }
174  static WEBP_INLINE uint32_t LinearToGammaS(uint32_t value) {
175    return (MAX_Y_T * value) >> GAMMA_TO_LINEAR_BITS;
176  }
177  #endif    
178  static uint8_t clip_8b(fixed_t v) {
179    return (!(v & ~0xff)) ? (uint8_t)v : (v < 0) ? 0u : 255u;
180  }
181  static fixed_y_t clip_y(int y) {
182    return (!(y & ~MAX_Y_T)) ? (fixed_y_t)y : (y < 0) ? 0 : MAX_Y_T;
183  }
184  static int RGBToGray(int r, int g, int b) {
185    const int luma = 13933 * r + 46871 * g + 4732 * b + YUV_HALF;
186    return (luma >> YUV_FIX);
187  }
188  static uint32_t ScaleDown(int a, int b, int c, int d) {
189    const uint32_t A = GammaToLinearS(a);
190    const uint32_t B = GammaToLinearS(b);
191    const uint32_t C = GammaToLinearS(c);
192    const uint32_t D = GammaToLinearS(d);
193    return LinearToGammaS((A + B + C + D + 2) >> 2);
194  }
195  static WEBP_INLINE void UpdateW(const fixed_y_t* src, fixed_y_t* dst, int w) {
196    int i;
197    for (i = 0; i < w; ++i) {
198      const uint32_t R = GammaToLinearS(src[0 * w + i]);
199      const uint32_t G = GammaToLinearS(src[1 * w + i]);
200      const uint32_t B = GammaToLinearS(src[2 * w + i]);
201      const uint32_t Y = RGBToGray(R, G, B);
202      dst[i] = (fixed_y_t)LinearToGammaS(Y);
203    }
204  }
205  static void UpdateChroma(const fixed_y_t* src1, const fixed_y_t* src2,
206                           fixed_t* dst, int uv_w) {
207    int i;
208    for (i = 0; i < uv_w; ++i) {
209      const int r = ScaleDown(src1[0 * uv_w + 0], src1[0 * uv_w + 1],
210                              src2[0 * uv_w + 0], src2[0 * uv_w + 1]);
211      const int g = ScaleDown(src1[2 * uv_w + 0], src1[2 * uv_w + 1],
212                              src2[2 * uv_w + 0], src2[2 * uv_w + 1]);
213      const int b = ScaleDown(src1[4 * uv_w + 0], src1[4 * uv_w + 1],
214                              src2[4 * uv_w + 0], src2[4 * uv_w + 1]);
215      const int W = RGBToGray(r, g, b);
216      dst[0 * uv_w] = (fixed_t)(r - W);
217      dst[1 * uv_w] = (fixed_t)(g - W);
218      dst[2 * uv_w] = (fixed_t)(b - W);
219      dst  += 1;
220      src1 += 2;
221      src2 += 2;
222    }
223  }
224  static void StoreGray(const fixed_y_t* rgb, fixed_y_t* y, int w) {
225    int i;
226    for (i = 0; i < w; ++i) {
227      y[i] = RGBToGray(rgb[0 * w + i], rgb[1 * w + i], rgb[2 * w + i]);
228    }
229  }
230  static WEBP_INLINE fixed_y_t Filter2(int A, int B, int W0) {
231    const int v0 = (A * 3 + B + 2) >> 2;
232    return clip_y(v0 + W0);
233  }
234  static WEBP_INLINE fixed_y_t UpLift(uint8_t a) {  
235    return ((fixed_y_t)a << SFIX) | SHALF;
236  }
237  static void ImportOneRow(const uint8_t* const r_ptr,
238                           const uint8_t* const g_ptr,
239                           const uint8_t* const b_ptr,
240                           int step,
241                           int pic_width,
242                           fixed_y_t* const dst) {
243    int i;
244    const int w = (pic_width + 1) & ~1;
245    for (i = 0; i < pic_width; ++i) {
246      const int off = i * step;
247      dst[i + 0 * w] = UpLift(r_ptr[off]);
248      dst[i + 1 * w] = UpLift(g_ptr[off]);
249      dst[i + 2 * w] = UpLift(b_ptr[off]);
250    }
251    if (pic_width & 1) {  
252      dst[pic_width + 0 * w] = dst[pic_width + 0 * w - 1];
253      dst[pic_width + 1 * w] = dst[pic_width + 1 * w - 1];
254      dst[pic_width + 2 * w] = dst[pic_width + 2 * w - 1];
255    }
256  }
257  static void InterpolateTwoRows(const fixed_y_t* const best_y,
258                                 const fixed_t* prev_uv,
259                                 const fixed_t* cur_uv,
260                                 const fixed_t* next_uv,
261                                 int w,
262                                 fixed_y_t* out1,
263                                 fixed_y_t* out2) {
264    const int uv_w = w >> 1;
265    const int len = (w - 1) >> 1;   
266    int k = 3;
267    while (k-- > 0) {   
268      out1[0] = Filter2(cur_uv[0], prev_uv[0], best_y[0]);
269      out2[0] = Filter2(cur_uv[0], next_uv[0], best_y[w]);
270      WebPSharpYUVFilterRow(cur_uv, prev_uv, len, best_y + 0 + 1, out1 + 1);
271      WebPSharpYUVFilterRow(cur_uv, next_uv, len, best_y + w + 1, out2 + 1);
272      if (!(w & 1)) {
273        out1[w - 1] = Filter2(cur_uv[uv_w - 1], prev_uv[uv_w - 1],
274                              best_y[w - 1 + 0]);
275        out2[w - 1] = Filter2(cur_uv[uv_w - 1], next_uv[uv_w - 1],
276                              best_y[w - 1 + w]);
277      }
278      out1 += w;
279      out2 += w;
280      prev_uv += uv_w;
281      cur_uv  += uv_w;
282      next_uv += uv_w;
283    }
284  }
285  static WEBP_INLINE uint8_t ConvertRGBToY(int r, int g, int b) {
286    const int luma = 16839 * r + 33059 * g + 6420 * b + SROUNDER;
287    return clip_8b(16 + (luma >> (YUV_FIX + SFIX)));
288  }
289  static WEBP_INLINE uint8_t ConvertRGBToU(int r, int g, int b) {
290    const int u =  -9719 * r - 19081 * g + 28800 * b + SROUNDER;
291    return clip_8b(128 + (u >> (YUV_FIX + SFIX)));
292  }
293  static WEBP_INLINE uint8_t ConvertRGBToV(int r, int g, int b) {
294    const int v = +28800 * r - 24116 * g -  4684 * b + SROUNDER;
295    return clip_8b(128 + (v >> (YUV_FIX + SFIX)));
296  }
297  static int ConvertWRGBToYUV(const fixed_y_t* best_y, const fixed_t* best_uv,
298                              WebPPicture* const picture) {
299    int i, j;
300    uint8_t* dst_y = picture->y;
301    uint8_t* dst_u = picture->u;
302    uint8_t* dst_v = picture->v;
303    const fixed_t* const best_uv_base = best_uv;
304    const int w = (picture->width + 1) & ~1;
305    const int h = (picture->height + 1) & ~1;
306    const int uv_w = w >> 1;
307    const int uv_h = h >> 1;
308    for (best_uv = best_uv_base, j = 0; j < picture->height; ++j) {
309      for (i = 0; i < picture->width; ++i) {
310        const int off = (i >> 1);
311        const int W = best_y[i];
312        const int r = best_uv[off + 0 * uv_w] + W;
313        const int g = best_uv[off + 1 * uv_w] + W;
314        const int b = best_uv[off + 2 * uv_w] + W;
315        dst_y[i] = ConvertRGBToY(r, g, b);
316      }
317      best_y += w;
318      best_uv += (j & 1) * 3 * uv_w;
319      dst_y += picture->y_stride;
320    }
321    for (best_uv = best_uv_base, j = 0; j < uv_h; ++j) {
322      for (i = 0; i < uv_w; ++i) {
323        const int off = i;
324        const int r = best_uv[off + 0 * uv_w];
325        const int g = best_uv[off + 1 * uv_w];
326        const int b = best_uv[off + 2 * uv_w];
327        dst_u[i] = ConvertRGBToU(r, g, b);
328        dst_v[i] = ConvertRGBToV(r, g, b);
329      }
330      best_uv += 3 * uv_w;
331      dst_u += picture->uv_stride;
332      dst_v += picture->uv_stride;
333    }
334    return 1;
335  }
336  #define SAFE_ALLOC(W, H, T) ((T*)WebPSafeMalloc((W) * (H), sizeof(T)))
337  static int PreprocessARGB(const uint8_t* r_ptr,
338                            const uint8_t* g_ptr,
339                            const uint8_t* b_ptr,
340                            int step, int rgb_stride,
341                            WebPPicture* const picture) {
342    const int w = (picture->width + 1) & ~1;
343    const int h = (picture->height + 1) & ~1;
344    const int uv_w = w >> 1;
345    const int uv_h = h >> 1;
346    uint64_t prev_diff_y_sum = ~0;
347    int j, iter;
348    fixed_y_t* const tmp_buffer = SAFE_ALLOC(w * 3, 2, fixed_y_t);   
349    fixed_y_t* const best_y_base = SAFE_ALLOC(w, h, fixed_y_t);
350    fixed_y_t* const target_y_base = SAFE_ALLOC(w, h, fixed_y_t);
351    fixed_y_t* const best_rgb_y = SAFE_ALLOC(w, 2, fixed_y_t);
352    fixed_t* const best_uv_base = SAFE_ALLOC(uv_w * 3, uv_h, fixed_t);
353    fixed_t* const target_uv_base = SAFE_ALLOC(uv_w * 3, uv_h, fixed_t);
<span onclick='openModal()' class='match'>354    fixed_t* const best_rgb_uv = SAFE_ALLOC(uv_w * 3, 1, fixed_t);
355    fixed_y_t* best_y = best_y_base;
</span>356    fixed_y_t* target_y = target_y_base;
357    fixed_t* best_uv = best_uv_base;
358    fixed_t* target_uv = target_uv_base;
359    const uint64_t diff_y_threshold = (uint64_t)(3.0 * w * h);
360    int ok;
361    if (best_y_base == NULL || best_uv_base == NULL ||
362        target_y_base == NULL || target_uv_base == NULL ||
363        best_rgb_y == NULL || best_rgb_uv == NULL ||
364        tmp_buffer == NULL) {
365      ok = WebPEncodingSetError(picture, VP8_ENC_ERROR_OUT_OF_MEMORY);
366      goto End;
367    }
368    assert(picture->width >= kMinDimensionIterativeConversion);
369    assert(picture->height >= kMinDimensionIterativeConversion);
370    WebPInitConvertARGBToYUV();
371    for (j = 0; j < picture->height; j += 2) {
372      const int is_last_row = (j == picture->height - 1);
373      fixed_y_t* const src1 = tmp_buffer + 0 * w;
374      fixed_y_t* const src2 = tmp_buffer + 3 * w;
375      ImportOneRow(r_ptr, g_ptr, b_ptr, step, picture->width, src1);
376      if (!is_last_row) {
377        ImportOneRow(r_ptr + rgb_stride, g_ptr + rgb_stride, b_ptr + rgb_stride,
378                     step, picture->width, src2);
379      } else {
380        memcpy(src2, src1, 3 * w * sizeof(*src2));
381      }
382      StoreGray(src1, best_y + 0, w);
383      StoreGray(src2, best_y + w, w);
384      UpdateW(src1, target_y, w);
385      UpdateW(src2, target_y + w, w);
386      UpdateChroma(src1, src2, target_uv, uv_w);
387      memcpy(best_uv, target_uv, 3 * uv_w * sizeof(*best_uv));
388      best_y += 2 * w;
389      best_uv += 3 * uv_w;
390      target_y += 2 * w;
391      target_uv += 3 * uv_w;
392      r_ptr += 2 * rgb_stride;
393      g_ptr += 2 * rgb_stride;
394      b_ptr += 2 * rgb_stride;
395    }
396    for (iter = 0; iter < kNumIterations; ++iter) {
397      const fixed_t* cur_uv = best_uv_base;
398      const fixed_t* prev_uv = best_uv_base;
399      uint64_t diff_y_sum = 0;
400      best_y = best_y_base;
401      best_uv = best_uv_base;
402      target_y = target_y_base;
403      target_uv = target_uv_base;
404      for (j = 0; j < h; j += 2) {
405        fixed_y_t* const src1 = tmp_buffer + 0 * w;
406        fixed_y_t* const src2 = tmp_buffer + 3 * w;
407        {
408          const fixed_t* const next_uv = cur_uv + ((j < h - 2) ? 3 * uv_w : 0);
409          InterpolateTwoRows(best_y, prev_uv, cur_uv, next_uv, w, src1, src2);
410          prev_uv = cur_uv;
411          cur_uv = next_uv;
412        }
413        UpdateW(src1, best_rgb_y + 0 * w, w);
414        UpdateW(src2, best_rgb_y + 1 * w, w);
415        UpdateChroma(src1, src2, best_rgb_uv, uv_w);
416        diff_y_sum += WebPSharpYUVUpdateY(target_y, best_rgb_y, best_y, 2 * w);
417        WebPSharpYUVUpdateRGB(target_uv, best_rgb_uv, best_uv, 3 * uv_w);
418        best_y += 2 * w;
419        best_uv += 3 * uv_w;
420        target_y += 2 * w;
421        target_uv += 3 * uv_w;
422      }
423      if (iter > 0) {
424        if (diff_y_sum < diff_y_threshold) break;
425        if (diff_y_sum > prev_diff_y_sum) break;
426      }
427      prev_diff_y_sum = diff_y_sum;
428    }
429    ok = ConvertWRGBToYUV(best_y_base, best_uv_base, picture);
430   End:
431    WebPSafeFree(best_y_base);
432    WebPSafeFree(best_uv_base);
433    WebPSafeFree(target_y_base);
434    WebPSafeFree(target_uv_base);
435    WebPSafeFree(best_rgb_y);
436    WebPSafeFree(best_rgb_uv);
437    WebPSafeFree(tmp_buffer);
438    return ok;
439  }
440  #undef SAFE_ALLOC
441  #define SUM4(ptr, step) LinearToGamma(                     \
442      GammaToLinear((ptr)[0]) +                              \
443      GammaToLinear((ptr)[(step)]) +                         \
444      GammaToLinear((ptr)[rgb_stride]) +                     \
445      GammaToLinear((ptr)[rgb_stride + (step)]), 0)          \
446  
447  #define SUM2(ptr) \
448      LinearToGamma(GammaToLinear((ptr)[0]) + GammaToLinear((ptr)[rgb_stride]), 1)
449  #define SUM2ALPHA(ptr) ((ptr)[0] + (ptr)[rgb_stride])
450  #define SUM4ALPHA(ptr) (SUM2ALPHA(ptr) + SUM2ALPHA((ptr) + 4))
451  #if defined(USE_INVERSE_ALPHA_TABLE)
452  static const int kAlphaFix = 19;
453  static const uint32_t kInvAlpha[4 * 0xff + 1] = {
454    0,  &bsol;* alpha = 0 */
455    524288, 262144, 174762, 131072, 104857, 87381, 74898, 65536,
456    58254, 52428, 47662, 43690, 40329, 37449, 34952, 32768,
457    30840, 29127, 27594, 26214, 24966, 23831, 22795, 21845,
458    20971, 20164, 19418, 18724, 18078, 17476, 16912, 16384,
459    15887, 15420, 14979, 14563, 14169, 13797, 13443, 13107,
460    12787, 12483, 12192, 11915, 11650, 11397, 11155, 10922,
461    10699, 10485, 10280, 10082, 9892, 9709, 9532, 9362,
462    9198, 9039, 8886, 8738, 8594, 8456, 8322, 8192,
463    8065, 7943, 7825, 7710, 7598, 7489, 7384, 7281,
464    7182, 7084, 6990, 6898, 6808, 6721, 6636, 6553,
465    6472, 6393, 6316, 6241, 6168, 6096, 6026, 5957,
466    5890, 5825, 5761, 5698, 5637, 5577, 5518, 5461,
467    5405, 5349, 5295, 5242, 5190, 5140, 5090, 5041,
468    4993, 4946, 4899, 4854, 4809, 4766, 4723, 4681,
469    4639, 4599, 4559, 4519, 4481, 4443, 4405, 4369,
470    4332, 4297, 4262, 4228, 4194, 4161, 4128, 4096,
471    4064, 4032, 4002, 3971, 3942, 3912, 3883, 3855,
472    3826, 3799, 3771, 3744, 3718, 3692, 3666, 3640,
473    3615, 3591, 3566, 3542, 3518, 3495, 3472, 3449,
474    3426, 3404, 3382, 3360, 3339, 3318, 3297, 3276,
475    3256, 3236, 3216, 3196, 3177, 3158, 3139, 3120,
476    3102, 3084, 3066, 3048, 3030, 3013, 2995, 2978,
477    2962, 2945, 2928, 2912, 2896, 2880, 2864, 2849,
478    2833, 2818, 2803, 2788, 2774, 2759, 2744, 2730,
479    2716, 2702, 2688, 2674, 2661, 2647, 2634, 2621,
480    2608, 2595, 2582, 2570, 2557, 2545, 2532, 2520,
481    2508, 2496, 2484, 2473, 2461, 2449, 2438, 2427,
482    2416, 2404, 2394, 2383, 2372, 2361, 2351, 2340,
483    2330, 2319, 2309, 2299, 2289, 2279, 2269, 2259,
484    2250, 2240, 2231, 2221, 2212, 2202, 2193, 2184,
485    2175, 2166, 2157, 2148, 2139, 2131, 2122, 2114,
486    2105, 2097, 2088, 2080, 2072, 2064, 2056, 2048,
487    2040, 2032, 2024, 2016, 2008, 2001, 1993, 1985,
488    1978, 1971, 1963, 1956, 1949, 1941, 1934, 1927,
489    1920, 1913, 1906, 1899, 1892, 1885, 1879, 1872,
490    1865, 1859, 1852, 1846, 1839, 1833, 1826, 1820,
491    1814, 1807, 1801, 1795, 1789, 1783, 1777, 1771,
492    1765, 1759, 1753, 1747, 1741, 1736, 1730, 1724,
493    1718, 1713, 1707, 1702, 1696, 1691, 1685, 1680,
494    1675, 1669, 1664, 1659, 1653, 1648, 1643, 1638,
495    1633, 1628, 1623, 1618, 1613, 1608, 1603, 1598,
496    1593, 1588, 1583, 1579, 1574, 1569, 1565, 1560,
497    1555, 1551, 1546, 1542, 1537, 1533, 1528, 1524,
498    1519, 1515, 1510, 1506, 1502, 1497, 1493, 1489,
499    1485, 1481, 1476, 1472, 1468, 1464, 1460, 1456,
500    1452, 1448, 1444, 1440, 1436, 1432, 1428, 1424,
501    1420, 1416, 1413, 1409, 1405, 1401, 1398, 1394,
502    1390, 1387, 1383, 1379, 1376, 1372, 1368, 1365,
503    1361, 1358, 1354, 1351, 1347, 1344, 1340, 1337,
504    1334, 1330, 1327, 1323, 1320, 1317, 1314, 1310,
505    1307, 1304, 1300, 1297, 1294, 1291, 1288, 1285,
506    1281, 1278, 1275, 1272, 1269, 1266, 1263, 1260,
507    1257, 1254, 1251, 1248, 1245, 1242, 1239, 1236,
508    1233, 1230, 1227, 1224, 1222, 1219, 1216, 1213,
509    1210, 1208, 1205, 1202, 1199, 1197, 1194, 1191,
510    1188, 1186, 1183, 1180, 1178, 1175, 1172, 1170,
511    1167, 1165, 1162, 1159, 1157, 1154, 1152, 1149,
512    1147, 1144, 1142, 1139, 1137, 1134, 1132, 1129,
513    1127, 1125, 1122, 1120, 1117, 1115, 1113, 1110,
514    1108, 1106, 1103, 1101, 1099, 1096, 1094, 1092,
515    1089, 1087, 1085, 1083, 1081, 1078, 1076, 1074,
516    1072, 1069, 1067, 1065, 1063, 1061, 1059, 1057,
517    1054, 1052, 1050, 1048, 1046, 1044, 1042, 1040,
518    1038, 1036, 1034, 1032, 1030, 1028, 1026, 1024,
519    1022, 1020, 1018, 1016, 1014, 1012, 1010, 1008,
520    1006, 1004, 1002, 1000, 998, 996, 994, 992,
521    991, 989, 987, 985, 983, 981, 979, 978,
522    976, 974, 972, 970, 969, 967, 965, 963,
523    961, 960, 958, 956, 954, 953, 951, 949,
524    948, 946, 944, 942, 941, 939, 937, 936,
525    934, 932, 931, 929, 927, 926, 924, 923,
526    921, 919, 918, 916, 914, 913, 911, 910,
527    908, 907, 905, 903, 902, 900, 899, 897,
528    896, 894, 893, 891, 890, 888, 887, 885,
529    884, 882, 881, 879, 878, 876, 875, 873,
530    872, 870, 869, 868, 866, 865, 863, 862,
531    860, 859, 858, 856, 855, 853, 852, 851,
532    849, 848, 846, 845, 844, 842, 841, 840,
533    838, 837, 836, 834, 833, 832, 830, 829,
534    828, 826, 825, 824, 823, 821, 820, 819,
535    817, 816, 815, 814, 812, 811, 810, 809,
536    807, 806, 805, 804, 802, 801, 800, 799,
537    798, 796, 795, 794, 793, 791, 790, 789,
538    788, 787, 786, 784, 783, 782, 781, 780,
539    779, 777, 776, 775, 774, 773, 772, 771,
540    769, 768, 767, 766, 765, 764, 763, 762,
541    760, 759, 758, 757, 756, 755, 754, 753,
542    752, 751, 750, 748, 747, 746, 745, 744,
543    743, 742, 741, 740, 739, 738, 737, 736,
544    735, 734, 733, 732, 731, 730, 729, 728,
545    727, 726, 725, 724, 723, 722, 721, 720,
546    719, 718, 717, 716, 715, 714, 713, 712,
547    711, 710, 709, 708, 707, 706, 705, 704,
548    703, 702, 701, 700, 699, 699, 698, 697,
549    696, 695, 694, 693, 692, 691, 690, 689,
550    688, 688, 687, 686, 685, 684, 683, 682,
551    681, 680, 680, 679, 678, 677, 676, 675,
552    674, 673, 673, 672, 671, 670, 669, 668,
553    667, 667, 666, 665, 664, 663, 662, 661,
554    661, 660, 659, 658, 657, 657, 656, 655,
555    654, 653, 652, 652, 651, 650, 649, 648,
556    648, 647, 646, 645, 644, 644, 643, 642,
557    641, 640, 640, 639, 638, 637, 637, 636,
558    635, 634, 633, 633, 632, 631, 630, 630,
559    629, 628, 627, 627, 626, 625, 624, 624,
560    623, 622, 621, 621, 620, 619, 618, 618,
561    617, 616, 616, 615, 614, 613, 613, 612,
562    611, 611, 610, 609, 608, 608, 607, 606,
563    606, 605, 604, 604, 603, 602, 601, 601,
564    600, 599, 599, 598, 597, 597, 596, 595,
565    595, 594, 593, 593, 592, 591, 591, 590,
566    589, 589, 588, 587, 587, 586, 585, 585,
567    584, 583, 583, 582, 581, 581, 580, 579,
568    579, 578, 578, 577, 576, 576, 575, 574,
569    574, 573, 572, 572, 571, 571, 570, 569,
570    569, 568, 568, 567, 566, 566, 565, 564,
571    564, 563, 563, 562, 561, 561, 560, 560,
572    559, 558, 558, 557, 557, 556, 555, 555,
573    554, 554, 553, 553, 552, 551, 551, 550,
574    550, 549, 548, 548, 547, 547, 546, 546,
575    545, 544, 544, 543, 543, 542, 542, 541,
576    541, 540, 539, 539, 538, 538, 537, 537,
577    536, 536, 535, 534, 534, 533, 533, 532,
578    532, 531, 531, 530, 530, 529, 529, 528,
579    527, 527, 526, 526, 525, 525, 524, 524,
580    523, 523, 522, 522, 521, 521, 520, 520,
581    519, 519, 518, 518, 517, 517, 516, 516,
582    515, 515, 514, 514
583  };
584  #define DIVIDE_BY_ALPHA(sum, a)  (((sum) * kInvAlpha[(a)]) >> (kAlphaFix - 2))
585  #else
586  #define DIVIDE_BY_ALPHA(sum, a) (4 * (sum) / (a))
587  #endif  
588  static WEBP_INLINE int LinearToGammaWeighted(const uint8_t* src,
589                                               const uint8_t* a_ptr,
590                                               uint32_t total_a, int step,
591                                               int rgb_stride) {
592    const uint32_t sum =
593        a_ptr[0] * GammaToLinear(src[0]) +
594        a_ptr[step] * GammaToLinear(src[step]) +
595        a_ptr[rgb_stride] * GammaToLinear(src[rgb_stride]) +
596        a_ptr[rgb_stride + step] * GammaToLinear(src[rgb_stride + step]);
597    assert(total_a > 0 && total_a <= 4 * 0xff);
598  #if defined(USE_INVERSE_ALPHA_TABLE)
599    assert((uint64_t)sum * kInvAlpha[total_a] < ((uint64_t)1 << 32));
600  #endif
601    return LinearToGamma(DIVIDE_BY_ALPHA(sum, total_a), 0);
602  }
603  static WEBP_INLINE void ConvertRowToY(const uint8_t* const r_ptr,
604                                        const uint8_t* const g_ptr,
605                                        const uint8_t* const b_ptr,
606                                        int step,
607                                        uint8_t* const dst_y,
608                                        int width,
609                                        VP8Random* const rg) {
610    int i, j;
611    for (i = 0, j = 0; i < width; i += 1, j += step) {
612      dst_y[i] = RGBToY(r_ptr[j], g_ptr[j], b_ptr[j], rg);
613    }
614  }
615  static WEBP_INLINE void AccumulateRGBA(const uint8_t* const r_ptr,
616                                         const uint8_t* const g_ptr,
617                                         const uint8_t* const b_ptr,
618                                         const uint8_t* const a_ptr,
619                                         int rgb_stride,
620                                         uint16_t* dst, int width) {
621    int i, j;
622    for (i = 0, j = 0; i < (width >> 1); i += 1, j += 2 * 4, dst += 4) {
623      const uint32_t a = SUM4ALPHA(a_ptr + j);
624      int r, g, b;
625      if (a == 4 * 0xff || a == 0) {
626        r = SUM4(r_ptr + j, 4);
627        g = SUM4(g_ptr + j, 4);
628        b = SUM4(b_ptr + j, 4);
629      } else {
630        r = LinearToGammaWeighted(r_ptr + j, a_ptr + j, a, 4, rgb_stride);
631        g = LinearToGammaWeighted(g_ptr + j, a_ptr + j, a, 4, rgb_stride);
632        b = LinearToGammaWeighted(b_ptr + j, a_ptr + j, a, 4, rgb_stride);
633      }
634      dst[0] = r;
635      dst[1] = g;
636      dst[2] = b;
637      dst[3] = a;
638    }
639    if (width & 1) {
640      const uint32_t a = 2u * SUM2ALPHA(a_ptr + j);
641      int r, g, b;
642      if (a == 4 * 0xff || a == 0) {
643        r = SUM2(r_ptr + j);
644        g = SUM2(g_ptr + j);
645        b = SUM2(b_ptr + j);
646      } else {
647        r = LinearToGammaWeighted(r_ptr + j, a_ptr + j, a, 0, rgb_stride);
648        g = LinearToGammaWeighted(g_ptr + j, a_ptr + j, a, 0, rgb_stride);
649        b = LinearToGammaWeighted(b_ptr + j, a_ptr + j, a, 0, rgb_stride);
650      }
651      dst[0] = r;
652      dst[1] = g;
653      dst[2] = b;
654      dst[3] = a;
655    }
656  }
657  static WEBP_INLINE void AccumulateRGB(const uint8_t* const r_ptr,
658                                        const uint8_t* const g_ptr,
659                                        const uint8_t* const b_ptr,
660                                        int step, int rgb_stride,
661                                        uint16_t* dst, int width) {
662    int i, j;
663    for (i = 0, j = 0; i < (width >> 1); i += 1, j += 2 * step, dst += 4) {
664      dst[0] = SUM4(r_ptr + j, step);
665      dst[1] = SUM4(g_ptr + j, step);
666      dst[2] = SUM4(b_ptr + j, step);
667    }
668    if (width & 1) {
669      dst[0] = SUM2(r_ptr + j);
670      dst[1] = SUM2(g_ptr + j);
671      dst[2] = SUM2(b_ptr + j);
672    }
673  }
674  static WEBP_INLINE void ConvertRowsToUV(const uint16_t* rgb,
675                                          uint8_t* const dst_u,
676                                          uint8_t* const dst_v,
677                                          int width,
678                                          VP8Random* const rg) {
679    int i;
680    for (i = 0; i < width; i += 1, rgb += 4) {
681      const int r = rgb[0], g = rgb[1], b = rgb[2];
682      dst_u[i] = RGBToU(r, g, b, rg);
683      dst_v[i] = RGBToV(r, g, b, rg);
684    }
685  }
686  static int ImportYUVAFromRGBA(const uint8_t* r_ptr,
687                                const uint8_t* g_ptr,
688                                const uint8_t* b_ptr,
689                                const uint8_t* a_ptr,
690                                int step,         
691                                int rgb_stride,   
692                                float dithering,
693                                int use_iterative_conversion,
694                                WebPPicture* const picture) {
695    int y;
696    const int width = picture->width;
697    const int height = picture->height;
698    const int has_alpha = CheckNonOpaque(a_ptr, width, height, step, rgb_stride);
699    const int is_rgb = (r_ptr < b_ptr);  
700    picture->colorspace = has_alpha ? WEBP_YUV420A : WEBP_YUV420;
701    picture->use_argb = 0;
702    if (width < kMinDimensionIterativeConversion ||
703        height < kMinDimensionIterativeConversion) {
704      use_iterative_conversion = 0;
705    }
706    if (!WebPPictureAllocYUVA(picture, width, height)) {
707      return 0;
708    }
709    if (has_alpha) {
710      assert(step == 4);
711  #if defined(USE_GAMMA_COMPRESSION) && defined(USE_INVERSE_ALPHA_TABLE)
712      assert(kAlphaFix + kGammaFix <= 31);
713  #endif
714    }
715    if (use_iterative_conversion) {
716      InitGammaTablesS();
717      if (!PreprocessARGB(r_ptr, g_ptr, b_ptr, step, rgb_stride, picture)) {
718        return 0;
719      }
720      if (has_alpha) {
721        WebPExtractAlpha(a_ptr, rgb_stride, width, height,
722                         picture->a, picture->a_stride);
723      }
724    } else {
725      const int uv_width = (width + 1) >> 1;
726      int use_dsp = (step == 3);  
727      uint16_t* const tmp_rgb =
728          (uint16_t*)WebPSafeMalloc(4 * uv_width, sizeof(*tmp_rgb));
729      uint8_t* dst_y = picture->y;
730      uint8_t* dst_u = picture->u;
731      uint8_t* dst_v = picture->v;
732      uint8_t* dst_a = picture->a;
733      VP8Random base_rg;
734      VP8Random* rg = NULL;
735      if (dithering > 0.) {
736        VP8InitRandom(&base_rg, dithering);
737        rg = &base_rg;
738        use_dsp = 0;   
739      }
740      WebPInitConvertARGBToYUV();
741      InitGammaTables();
742      if (tmp_rgb == NULL) return 0;  
743      for (y = 0; y < (height >> 1); ++y) {
744        int rows_have_alpha = has_alpha;
745        if (use_dsp) {
746          if (is_rgb) {
747            WebPConvertRGB24ToY(r_ptr, dst_y, width);
748            WebPConvertRGB24ToY(r_ptr + rgb_stride,
749                                dst_y + picture->y_stride, width);
750          } else {
751            WebPConvertBGR24ToY(b_ptr, dst_y, width);
752            WebPConvertBGR24ToY(b_ptr + rgb_stride,
753                                dst_y + picture->y_stride, width);
754          }
755        } else {
756          ConvertRowToY(r_ptr, g_ptr, b_ptr, step, dst_y, width, rg);
757          ConvertRowToY(r_ptr + rgb_stride,
758                        g_ptr + rgb_stride,
759                        b_ptr + rgb_stride, step,
760                        dst_y + picture->y_stride, width, rg);
761        }
762        dst_y += 2 * picture->y_stride;
763        if (has_alpha) {
764          rows_have_alpha &= !WebPExtractAlpha(a_ptr, rgb_stride, width, 2,
765                                               dst_a, picture->a_stride);
766          dst_a += 2 * picture->a_stride;
767        }
768        if (!rows_have_alpha) {
769          AccumulateRGB(r_ptr, g_ptr, b_ptr, step, rgb_stride, tmp_rgb, width);
770        } else {
771          AccumulateRGBA(r_ptr, g_ptr, b_ptr, a_ptr, rgb_stride, tmp_rgb, width);
772        }
773        if (rg == NULL) {
774          WebPConvertRGBA32ToUV(tmp_rgb, dst_u, dst_v, uv_width);
775        } else {
776          ConvertRowsToUV(tmp_rgb, dst_u, dst_v, uv_width, rg);
777        }
778        dst_u += picture->uv_stride;
779        dst_v += picture->uv_stride;
780        r_ptr += 2 * rgb_stride;
781        b_ptr += 2 * rgb_stride;
782        g_ptr += 2 * rgb_stride;
783        if (has_alpha) a_ptr += 2 * rgb_stride;
784      }
785      if (height & 1) {    
786        int row_has_alpha = has_alpha;
787        if (use_dsp) {
788          if (r_ptr < b_ptr) {
789            WebPConvertRGB24ToY(r_ptr, dst_y, width);
790          } else {
791            WebPConvertBGR24ToY(b_ptr, dst_y, width);
792          }
793        } else {
794          ConvertRowToY(r_ptr, g_ptr, b_ptr, step, dst_y, width, rg);
795        }
796        if (row_has_alpha) {
797          row_has_alpha &= !WebPExtractAlpha(a_ptr, 0, width, 1, dst_a, 0);
798        }
799        if (!row_has_alpha) {
800          AccumulateRGB(r_ptr, g_ptr, b_ptr, step, &bsol;* rgb_stride = */ 0,
801                        tmp_rgb, width);
802        } else {
803          AccumulateRGBA(r_ptr, g_ptr, b_ptr, a_ptr, &bsol;* rgb_stride = */ 0,
804                         tmp_rgb, width);
805        }
806        if (rg == NULL) {
807          WebPConvertRGBA32ToUV(tmp_rgb, dst_u, dst_v, uv_width);
808        } else {
809          ConvertRowsToUV(tmp_rgb, dst_u, dst_v, uv_width, rg);
810        }
811      }
812      WebPSafeFree(tmp_rgb);
813    }
814    return 1;
815  }
816  #undef SUM4
817  #undef SUM2
818  #undef SUM4ALPHA
819  #undef SUM2ALPHA
820  static int PictureARGBToYUVA(WebPPicture* picture, WebPEncCSP colorspace,
821                               float dithering, int use_iterative_conversion) {
822    if (picture == NULL) return 0;
823    if (picture->argb == NULL) {
824      return WebPEncodingSetError(picture, VP8_ENC_ERROR_NULL_PARAMETER);
825    } else if ((colorspace & WEBP_CSP_UV_MASK) != WEBP_YUV420) {
826      return WebPEncodingSetError(picture, VP8_ENC_ERROR_INVALID_CONFIGURATION);
827    } else {
828      const uint8_t* const argb = (const uint8_t*)picture->argb;
829      const uint8_t* const a = argb + CHANNEL_OFFSET(0);
830      const uint8_t* const r = argb + CHANNEL_OFFSET(1);
831      const uint8_t* const g = argb + CHANNEL_OFFSET(2);
832      const uint8_t* const b = argb + CHANNEL_OFFSET(3);
833      picture->colorspace = WEBP_YUV420;
834      return ImportYUVAFromRGBA(r, g, b, a, 4, 4 * picture->argb_stride,
835                                dithering, use_iterative_conversion, picture);
836    }
837  }
838  int WebPPictureARGBToYUVADithered(WebPPicture* picture, WebPEncCSP colorspace,
839                                    float dithering) {
840    return PictureARGBToYUVA(picture, colorspace, dithering, 0);
841  }
842  int WebPPictureARGBToYUVA(WebPPicture* picture, WebPEncCSP colorspace) {
843    return PictureARGBToYUVA(picture, colorspace, 0.f, 0);
844  }
845  int WebPPictureSharpARGBToYUVA(WebPPicture* picture) {
846    return PictureARGBToYUVA(picture, WEBP_YUV420, 0.f, 1);
847  }
848  int WebPPictureSmartARGBToYUVA(WebPPicture* picture) {
849    return WebPPictureSharpARGBToYUVA(picture);
850  }
851  int WebPPictureYUVAToARGB(WebPPicture* picture) {
852    if (picture == NULL) return 0;
853    if (picture->y == NULL || picture->u == NULL || picture->v == NULL) {
854      return WebPEncodingSetError(picture, VP8_ENC_ERROR_NULL_PARAMETER);
855    }
856    if ((picture->colorspace & WEBP_CSP_ALPHA_BIT) && picture->a == NULL) {
857      return WebPEncodingSetError(picture, VP8_ENC_ERROR_NULL_PARAMETER);
858    }
859    if ((picture->colorspace & WEBP_CSP_UV_MASK) != WEBP_YUV420) {
860      return WebPEncodingSetError(picture, VP8_ENC_ERROR_INVALID_CONFIGURATION);
861    }
862    if (!WebPPictureAllocARGB(picture, picture->width, picture->height)) return 0;
863    picture->use_argb = 1;
864    {
865      int y;
866      const int width = picture->width;
867      const int height = picture->height;
868      const int argb_stride = 4 * picture->argb_stride;
869      uint8_t* dst = (uint8_t*)picture->argb;
870      const uint8_t* cur_u = picture->u, *cur_v = picture->v, *cur_y = picture->y;
871      WebPUpsampleLinePairFunc upsample =
872          WebPGetLinePairConverter(ALPHA_OFFSET > 0);
873      upsample(cur_y, NULL, cur_u, cur_v, cur_u, cur_v, dst, NULL, width);
874      cur_y += picture->y_stride;
875      dst += argb_stride;
876      for (y = 1; y + 1 < height; y += 2) {
877        const uint8_t* const top_u = cur_u;
878        const uint8_t* const top_v = cur_v;
879        cur_u += picture->uv_stride;
880        cur_v += picture->uv_stride;
881        upsample(cur_y, cur_y + picture->y_stride, top_u, top_v, cur_u, cur_v,
882                 dst, dst + argb_stride, width);
883        cur_y += 2 * picture->y_stride;
884        dst += 2 * argb_stride;
885      }
886      if (height > 1 && !(height & 1)) {
887        upsample(cur_y, NULL, cur_u, cur_v, cur_u, cur_v, dst, NULL, width);
888      }
889      if (picture->colorspace & WEBP_CSP_ALPHA_BIT) {
890        for (y = 0; y < height; ++y) {
891          uint32_t* const argb_dst = picture->argb + y * picture->argb_stride;
892          const uint8_t* const src = picture->a + y * picture->a_stride;
893          int x;
894          for (x = 0; x < width; ++x) {
895            argb_dst[x] = (argb_dst[x] & 0x00ffffffu) | ((uint32_t)src[x] << 24);
896          }
897        }
898      }
899    }
900    return 1;
901  }
902  static int Import(WebPPicture* const picture,
903                    const uint8_t* rgb, int rgb_stride,
904                    int step, int swap_rb, int import_alpha) {
905    int y;
906    const uint8_t* r_ptr = rgb + (swap_rb ? 2 : 0);
907    const uint8_t* g_ptr = rgb + 1;
908    const uint8_t* b_ptr = rgb + (swap_rb ? 0 : 2);
909    const int width = picture->width;
910    const int height = picture->height;
911    if (!picture->use_argb) {
912      const uint8_t* a_ptr = import_alpha ? rgb + 3 : NULL;
913      return ImportYUVAFromRGBA(r_ptr, g_ptr, b_ptr, a_ptr, step, rgb_stride,
914                                0.f &bsol;* no dithering */, 0, picture);
915    }
916    if (!WebPPictureAlloc(picture)) return 0;
917    VP8LDspInit();
918    WebPInitAlphaProcessing();
919    if (import_alpha) {
920      uint32_t* dst = picture->argb;
921      const int do_copy = (ALPHA_OFFSET == 3) && swap_rb;
922      assert(step == 4);
923      if (do_copy) {
924        for (y = 0; y < height; ++y) {
925          memcpy(dst, rgb, width * 4);
926          rgb += rgb_stride;
927          dst += picture->argb_stride;
928        }
929      } else {
930        for (y = 0; y < height; ++y) {
931  #ifdef WORDS_BIGENDIAN
932          const uint8_t* a_ptr = rgb + 3;
933          WebPPackARGB(a_ptr, r_ptr, g_ptr, b_ptr, width, dst);
934          r_ptr += rgb_stride;
935          g_ptr += rgb_stride;
936          b_ptr += rgb_stride;
937  #else
938          VP8LConvertBGRAToRGBA((const uint32_t*)rgb, width, (uint8_t*)dst);
939  #endif
940          rgb += rgb_stride;
941          dst += picture->argb_stride;
942        }
943      }
944    } else {
945      uint32_t* dst = picture->argb;
946      assert(step >= 3);
947      for (y = 0; y < height; ++y) {
948        WebPPackRGB(r_ptr, g_ptr, b_ptr, width, step, dst);
949        r_ptr += rgb_stride;
950        g_ptr += rgb_stride;
951        b_ptr += rgb_stride;
952        dst += picture->argb_stride;
953      }
954    }
955    return 1;
956  }
957  #if !defined(WEBP_REDUCE_CSP)
958  int WebPPictureImportBGR(WebPPicture* picture,
959                           const uint8_t* rgb, int rgb_stride) {
960    return (picture != NULL && rgb != NULL)
961               ? Import(picture, rgb, rgb_stride, 3, 1, 0)
962               : 0;
963  }
964  int WebPPictureImportBGRA(WebPPicture* picture,
965                            const uint8_t* rgba, int rgba_stride) {
966    return (picture != NULL && rgba != NULL)
967               ? Import(picture, rgba, rgba_stride, 4, 1, 1)
968               : 0;
969  }
970  int WebPPictureImportBGRX(WebPPicture* picture,
971                            const uint8_t* rgba, int rgba_stride) {
972    return (picture != NULL && rgba != NULL)
973               ? Import(picture, rgba, rgba_stride, 4, 1, 0)
974               : 0;
975  }
976  #endif   
977  int WebPPictureImportRGB(WebPPicture* picture,
978                           const uint8_t* rgb, int rgb_stride) {
979    return (picture != NULL && rgb != NULL)
980               ? Import(picture, rgb, rgb_stride, 3, 0, 0)
981               : 0;
982  }
983  int WebPPictureImportRGBA(WebPPicture* picture,
984                            const uint8_t* rgba, int rgba_stride) {
985    return (picture != NULL && rgba != NULL)
986               ? Import(picture, rgba, rgba_stride, 4, 0, 1)
987               : 0;
988  }
989  int WebPPictureImportRGBX(WebPPicture* picture,
990                            const uint8_t* rgba, int rgba_stride) {
991    return (picture != NULL && rgba != NULL)
992               ? Import(picture, rgba, rgba_stride, 4, 0, 0)
993               : 0;
994  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from PINRemoteImage-MDEwOlJlcG9zaXRvcnkzOTUzNzEwMw==-flat-picture_csp_enc.c</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from PINRemoteImage-MDEwOlJlcG9zaXRvcnkzOTUzNzEwMw==-flat-picture_csp_enc.c</div>
                </div>
                <div class="column column_space"><pre><code>354    fixed_t* const best_rgb_uv = SAFE_ALLOC(uv_w * 3, 1, fixed_t);
355    fixed_y_t* best_y = best_y_base;
</pre></code></div>
                <div class="column column_space"><pre><code>354    fixed_t* const best_rgb_uv = SAFE_ALLOC(uv_w * 3, 1, fixed_t);
355    fixed_y_t* best_y = best_y_base;
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    