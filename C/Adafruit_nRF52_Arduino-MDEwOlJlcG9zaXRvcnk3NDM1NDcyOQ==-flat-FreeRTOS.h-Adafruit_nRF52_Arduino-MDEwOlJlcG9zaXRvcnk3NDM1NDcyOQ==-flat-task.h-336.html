
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 17, <button onclick='openModal()' class='match'>CODE CLONE</button></h2>
        <div class="column">
            <h3>Adafruit_nRF52_Arduino-MDEwOlJlcG9zaXRvcnk3NDM1NDcyOQ==-flat-FreeRTOS.h</h3>
            <pre><code>1  #ifndef INC_FREERTOS_H
2  #define INC_FREERTOS_H
3  #include &lt;stddef.h&gt;
4  #include &lt;stdint.h&gt; &amp;bsol;* READ COMMENT ABOVE. */
5  #ifdef __cplusplus
6  extern &quot;C&quot; {
7  #endif
8  #include &quot;FreeRTOSConfig.h&quot;
9  #include &quot;projdefs.h&quot;
10  #include &quot;portable.h&quot;
11  #ifndef configUSE_NEWLIB_REENTRANT
12  	#define configUSE_NEWLIB_REENTRANT 0
13  #endif
14  #if ( configUSE_NEWLIB_REENTRANT == 1 )
15  	#include &lt;reent.h&gt;
16  #endif
17  #ifndef configMINIMAL_STACK_SIZE
18  	#error Missing definition:  configMINIMAL_STACK_SIZE must be defined in FreeRTOSConfig.h.  configMINIMAL_STACK_SIZE defines the size (in words) of the stack allocated to the idle task.  Refer to the demo project provided for your port for a suitable value.
19  #endif
20  #ifndef configMAX_PRIORITIES
21  	#error Missing definition:  configMAX_PRIORITIES must be defined in FreeRTOSConfig.h.  See the Configuration section of the FreeRTOS API documentation for details.
22  #endif
23  #if configMAX_PRIORITIES &lt; 1
24  	#error configMAX_PRIORITIES must be defined to be greater than or equal to 1.
25  #endif
26  #ifndef configUSE_PREEMPTION
27  	#error Missing definition:  configUSE_PREEMPTION must be defined in FreeRTOSConfig.h as either 1 or 0.  See the Configuration section of the FreeRTOS API documentation for details.
28  #endif
29  #ifndef configUSE_IDLE_HOOK
30  	#error Missing definition:  configUSE_IDLE_HOOK must be defined in FreeRTOSConfig.h as either 1 or 0.  See the Configuration section of the FreeRTOS API documentation for details.
31  #endif
32  #ifndef configUSE_TICK_HOOK
33  	#error Missing definition:  configUSE_TICK_HOOK must be defined in FreeRTOSConfig.h as either 1 or 0.  See the Configuration section of the FreeRTOS API documentation for details.
34  #endif
35  #ifndef configUSE_16_BIT_TICKS
36  	#error Missing definition:  configUSE_16_BIT_TICKS must be defined in FreeRTOSConfig.h as either 1 or 0.  See the Configuration section of the FreeRTOS API documentation for details.
37  #endif
38  #ifndef configUSE_CO_ROUTINES
39  	#define configUSE_CO_ROUTINES 0
40  #endif
41  #ifndef INCLUDE_vTaskPrioritySet
42  	#define INCLUDE_vTaskPrioritySet 0
43  #endif
44  #ifndef INCLUDE_uxTaskPriorityGet
45  	#define INCLUDE_uxTaskPriorityGet 0
46  #endif
47  #ifndef INCLUDE_vTaskDelete
48  	#define INCLUDE_vTaskDelete 0
49  #endif
50  #ifndef INCLUDE_vTaskSuspend
51  	#define INCLUDE_vTaskSuspend 0
52  #endif
53  #ifndef INCLUDE_vTaskDelayUntil
54  	#define INCLUDE_vTaskDelayUntil 0
55  #endif
56  #ifndef INCLUDE_vTaskDelay
57  	#define INCLUDE_vTaskDelay 0
58  #endif
59  #ifndef INCLUDE_xTaskGetIdleTaskHandle
60  	#define INCLUDE_xTaskGetIdleTaskHandle 0
61  #endif
62  #ifndef INCLUDE_xTaskAbortDelay
63  	#define INCLUDE_xTaskAbortDelay 0
64  #endif
65  #ifndef INCLUDE_xQueueGetMutexHolder
66  	#define INCLUDE_xQueueGetMutexHolder 0
67  #endif
68  #ifndef INCLUDE_xSemaphoreGetMutexHolder
69  	#define INCLUDE_xSemaphoreGetMutexHolder INCLUDE_xQueueGetMutexHolder
70  #endif
71  #ifndef INCLUDE_xTaskGetHandle
72  	#define INCLUDE_xTaskGetHandle 0
73  #endif
74  #ifndef INCLUDE_uxTaskGetStackHighWaterMark
75  	#define INCLUDE_uxTaskGetStackHighWaterMark 0
76  #endif
77  #ifndef INCLUDE_pxTaskGetStackStart
78  	#define INCLUDE_pxTaskGetStackStart 0
79  #endif
80  #ifndef INCLUDE_eTaskGetState
81  	#define INCLUDE_eTaskGetState 0
82  #endif
83  #ifndef INCLUDE_xTaskResumeFromISR
84  	#define INCLUDE_xTaskResumeFromISR 1
85  #endif
86  #ifndef INCLUDE_xTimerPendFunctionCall
87  	#define INCLUDE_xTimerPendFunctionCall 0
88  #endif
89  #ifndef INCLUDE_xTaskGetSchedulerState
90  	#define INCLUDE_xTaskGetSchedulerState 0
91  #endif
92  #ifndef INCLUDE_xTaskGetCurrentTaskHandle
93  	#define INCLUDE_xTaskGetCurrentTaskHandle 0
94  #endif
95  #if configUSE_CO_ROUTINES != 0
96  	#ifndef configMAX_CO_ROUTINE_PRIORITIES
97  		#error configMAX_CO_ROUTINE_PRIORITIES must be greater than or equal to 1.
98  	#endif
99  #endif
100  #ifndef configUSE_DAEMON_TASK_STARTUP_HOOK
101  	#define configUSE_DAEMON_TASK_STARTUP_HOOK 0
102  #endif
103  #ifndef configUSE_APPLICATION_TASK_TAG
104  	#define configUSE_APPLICATION_TASK_TAG 0
105  #endif
106  #ifndef configNUM_THREAD_LOCAL_STORAGE_POINTERS
107  	#define configNUM_THREAD_LOCAL_STORAGE_POINTERS 0
108  #endif
109  #ifndef configUSE_RECURSIVE_MUTEXES
110  	#define configUSE_RECURSIVE_MUTEXES 0
111  #endif
112  #ifndef configUSE_MUTEXES
113  	#define configUSE_MUTEXES 0
114  #endif
115  #ifndef configUSE_TIMERS
116  	#define configUSE_TIMERS 0
117  #endif
118  #ifndef configUSE_COUNTING_SEMAPHORES
119  	#define configUSE_COUNTING_SEMAPHORES 0
120  #endif
121  #ifndef configUSE_ALTERNATIVE_API
122  	#define configUSE_ALTERNATIVE_API 0
123  #endif
124  #ifndef portCRITICAL_NESTING_IN_TCB
125  	#define portCRITICAL_NESTING_IN_TCB 0
126  #endif
127  #ifndef configMAX_TASK_NAME_LEN
128  	#define configMAX_TASK_NAME_LEN 16
129  #endif
130  #ifndef configIDLE_SHOULD_YIELD
131  	#define configIDLE_SHOULD_YIELD		1
132  #endif
133  #if configMAX_TASK_NAME_LEN &lt; 1
134  	#error configMAX_TASK_NAME_LEN must be set to a minimum of 1 in FreeRTOSConfig.h
135  #endif
136  #ifndef configASSERT
137  	#define configASSERT( x )
138  	#define configASSERT_DEFINED 0
139  #else
140  	#define configASSERT_DEFINED 1
141  #endif
142  #if configUSE_TIMERS == 1
143  	#ifndef configTIMER_TASK_PRIORITY
144  		#error If configUSE_TIMERS is set to 1 then configTIMER_TASK_PRIORITY must also be defined.
145  	#endif &amp;bsol;* configTIMER_TASK_PRIORITY */
146  	#ifndef configTIMER_QUEUE_LENGTH
147  		#error If configUSE_TIMERS is set to 1 then configTIMER_QUEUE_LENGTH must also be defined.
148  	#endif &amp;bsol;* configTIMER_QUEUE_LENGTH */
149  	#ifndef configTIMER_TASK_STACK_DEPTH
150  		#error If configUSE_TIMERS is set to 1 then configTIMER_TASK_STACK_DEPTH must also be defined.
151  	#endif &amp;bsol;* configTIMER_TASK_STACK_DEPTH */
152  #endif &amp;bsol;* configUSE_TIMERS */
153  #ifndef portSET_INTERRUPT_MASK_FROM_ISR
154  	#define portSET_INTERRUPT_MASK_FROM_ISR() 0
155  #endif
156  #ifndef portCLEAR_INTERRUPT_MASK_FROM_ISR
157  	#define portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedStatusValue ) ( void ) uxSavedStatusValue
158  #endif
159  #ifndef portCLEAN_UP_TCB
160  	#define portCLEAN_UP_TCB( pxTCB ) ( void ) pxTCB
161  #endif
162  #ifndef portPRE_TASK_DELETE_HOOK
163  	#define portPRE_TASK_DELETE_HOOK( pvTaskToDelete, pxYieldPending )
164  #endif
165  #ifndef portSETUP_TCB
166  	#define portSETUP_TCB( pxTCB ) ( void ) pxTCB
167  #endif
168  #ifndef configQUEUE_REGISTRY_SIZE
169  	#define configQUEUE_REGISTRY_SIZE 0U
170  #endif
171  #if ( configQUEUE_REGISTRY_SIZE &lt; 1 )
172  	#define vQueueAddToRegistry( xQueue, pcName )
173  	#define vQueueUnregisterQueue( xQueue )
174  	#define pcQueueGetName( xQueue )
175  #endif
176  #ifndef portPOINTER_SIZE_TYPE
177  	#define portPOINTER_SIZE_TYPE uint32_t
178  #endif
179  #ifndef traceSTART
180  	#define traceSTART()
181  #endif
182  #ifndef traceEND
183  	#define traceEND()
184  #endif
185  #ifndef traceTASK_SWITCHED_IN
186  	#define traceTASK_SWITCHED_IN()
187  #endif
188  #ifndef traceINCREASE_TICK_COUNT
189  	#define traceINCREASE_TICK_COUNT( x )
190  #endif
191  #ifndef traceLOW_POWER_IDLE_BEGIN
192  	#define traceLOW_POWER_IDLE_BEGIN()
193  #endif
194  #ifndef	traceLOW_POWER_IDLE_END
195  	#define traceLOW_POWER_IDLE_END()
196  #endif
197  #ifndef traceTASK_SWITCHED_OUT
198  	#define traceTASK_SWITCHED_OUT()
199  #endif
200  #ifndef traceTASK_PRIORITY_INHERIT
201  	#define traceTASK_PRIORITY_INHERIT( pxTCBOfMutexHolder, uxInheritedPriority )
202  #endif
203  #ifndef traceTASK_PRIORITY_DISINHERIT
204  	#define traceTASK_PRIORITY_DISINHERIT( pxTCBOfMutexHolder, uxOriginalPriority )
205  #endif
206  #ifndef traceBLOCKING_ON_QUEUE_RECEIVE
207  	#define traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue )
208  #endif
209  #ifndef traceBLOCKING_ON_QUEUE_PEEK
210  	#define traceBLOCKING_ON_QUEUE_PEEK( pxQueue )
211  #endif
212  #ifndef traceBLOCKING_ON_QUEUE_SEND
213  	#define traceBLOCKING_ON_QUEUE_SEND( pxQueue )
214  #endif
215  #ifndef configCHECK_FOR_STACK_OVERFLOW
216  	#define configCHECK_FOR_STACK_OVERFLOW 0
217  #endif
218  #ifndef configRECORD_STACK_HIGH_ADDRESS
219  	#define configRECORD_STACK_HIGH_ADDRESS 0
220  #endif
221  #ifndef configINCLUDE_FREERTOS_TASK_C_ADDITIONS_H
222  	#define configINCLUDE_FREERTOS_TASK_C_ADDITIONS_H 0
223  #endif
224  #ifndef traceMOVED_TASK_TO_READY_STATE
225  	#define traceMOVED_TASK_TO_READY_STATE( pxTCB )
226  #endif
227  #ifndef tracePOST_MOVED_TASK_TO_READY_STATE
228  	#define tracePOST_MOVED_TASK_TO_READY_STATE( pxTCB )
229  #endif
230  #ifndef traceREADDED_TASK_TO_READY_STATE
231  	#define traceREADDED_TASK_TO_READY_STATE( pxTCB )	traceMOVED_TASK_TO_READY_STATE( pxTCB )
232  #endif
233  #ifndef traceMOVED_TASK_TO_DELAYED_LIST
234  	#define traceMOVED_TASK_TO_DELAYED_LIST()
235  #endif
236  #ifndef traceMOVED_TASK_TO_OVERFLOW_DELAYED_LIST
237  	#define traceMOVED_TASK_TO_OVERFLOW_DELAYED_LIST()
238  #endif
239  #ifndef traceMOVED_TASK_TO_SUSPENDED_LIST
240  	#define traceMOVED_TASK_TO_SUSPENDED_LIST( pxTCB )
241  #endif
242  #ifndef traceQUEUE_CREATE
243  	#define traceQUEUE_CREATE( pxNewQueue )
244  #endif
245  #ifndef traceQUEUE_CREATE_FAILED
246  	#define traceQUEUE_CREATE_FAILED( ucQueueType )
247  #endif
248  #ifndef traceCREATE_MUTEX
249  	#define traceCREATE_MUTEX( pxNewQueue )
250  #endif
251  #ifndef traceCREATE_MUTEX_FAILED
252  	#define traceCREATE_MUTEX_FAILED()
253  #endif
254  #ifndef traceGIVE_MUTEX_RECURSIVE
255  	#define traceGIVE_MUTEX_RECURSIVE( pxMutex )
256  #endif
257  #ifndef traceGIVE_MUTEX_RECURSIVE_FAILED
258  	#define traceGIVE_MUTEX_RECURSIVE_FAILED( pxMutex )
259  #endif
260  #ifndef traceTAKE_MUTEX_RECURSIVE
261  	#define traceTAKE_MUTEX_RECURSIVE( pxMutex )
262  #endif
263  #ifndef traceTAKE_MUTEX_RECURSIVE_FAILED
264  	#define traceTAKE_MUTEX_RECURSIVE_FAILED( pxMutex )
265  #endif
266  #ifndef traceCREATE_COUNTING_SEMAPHORE
267  	#define traceCREATE_COUNTING_SEMAPHORE()
268  #endif
269  #ifndef traceCREATE_COUNTING_SEMAPHORE_FAILED
270  	#define traceCREATE_COUNTING_SEMAPHORE_FAILED()
271  #endif
272  #ifndef traceQUEUE_SEND
273  	#define traceQUEUE_SEND( pxQueue )
274  #endif
275  #ifndef traceQUEUE_SEND_FAILED
276  	#define traceQUEUE_SEND_FAILED( pxQueue )
277  #endif
278  #ifndef traceQUEUE_RECEIVE
279  	#define traceQUEUE_RECEIVE( pxQueue )
280  #endif
281  #ifndef traceQUEUE_PEEK
282  	#define traceQUEUE_PEEK( pxQueue )
283  #endif
284  #ifndef traceQUEUE_PEEK_FAILED
285  	#define traceQUEUE_PEEK_FAILED( pxQueue )
286  #endif
287  #ifndef traceQUEUE_PEEK_FROM_ISR
288  	#define traceQUEUE_PEEK_FROM_ISR( pxQueue )
289  #endif
290  #ifndef traceQUEUE_RECEIVE_FAILED
291  	#define traceQUEUE_RECEIVE_FAILED( pxQueue )
292  #endif
293  #ifndef traceQUEUE_SEND_FROM_ISR
294  	#define traceQUEUE_SEND_FROM_ISR( pxQueue )
295  #endif
296  #ifndef traceQUEUE_SEND_FROM_ISR_FAILED
297  	#define traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue )
298  #endif
299  #ifndef traceQUEUE_RECEIVE_FROM_ISR
300  	#define traceQUEUE_RECEIVE_FROM_ISR( pxQueue )
301  #endif
302  #ifndef traceQUEUE_RECEIVE_FROM_ISR_FAILED
303  	#define traceQUEUE_RECEIVE_FROM_ISR_FAILED( pxQueue )
304  #endif
305  #ifndef traceQUEUE_PEEK_FROM_ISR_FAILED
306  	#define traceQUEUE_PEEK_FROM_ISR_FAILED( pxQueue )
307  #endif
308  #ifndef traceQUEUE_DELETE
309  	#define traceQUEUE_DELETE( pxQueue )
310  #endif
311  #ifndef traceTASK_CREATE
312  	#define traceTASK_CREATE( pxNewTCB )
313  #endif
314  #ifndef traceTASK_CREATE_FAILED
315  	#define traceTASK_CREATE_FAILED()
316  #endif
317  #ifndef traceTASK_DELETE
318  	#define traceTASK_DELETE( pxTaskToDelete )
319  #endif
320  #ifndef traceTASK_DELAY_UNTIL
321  	#define traceTASK_DELAY_UNTIL( x )
322  #endif
323  #ifndef traceTASK_DELAY
324  	#define traceTASK_DELAY()
325  #endif
326  #ifndef traceTASK_PRIORITY_SET
327  	#define traceTASK_PRIORITY_SET( pxTask, uxNewPriority )
328  #endif
329  #ifndef traceTASK_SUSPEND
330  	#define traceTASK_SUSPEND( pxTaskToSuspend )
331  #endif
332  #ifndef traceTASK_RESUME
333  	#define traceTASK_RESUME( pxTaskToResume )
334  #endif
335  #ifndef traceTASK_RESUME_FROM_ISR
336  	#define traceTASK_RESUME_FROM_ISR( pxTaskToResume )
337  #endif
338  #ifndef traceTASK_INCREMENT_TICK
339  	#define traceTASK_INCREMENT_TICK( xTickCount )
340  #endif
341  #ifndef traceTIMER_CREATE
342  	#define traceTIMER_CREATE( pxNewTimer )
343  #endif
344  #ifndef traceTIMER_CREATE_FAILED
345  	#define traceTIMER_CREATE_FAILED()
346  #endif
347  #ifndef traceTIMER_COMMAND_SEND
348  	#define traceTIMER_COMMAND_SEND( xTimer, xMessageID, xMessageValueValue, xReturn )
349  #endif
350  #ifndef traceTIMER_EXPIRED
351  	#define traceTIMER_EXPIRED( pxTimer )
352  #endif
353  #ifndef traceTIMER_COMMAND_RECEIVED
354  	#define traceTIMER_COMMAND_RECEIVED( pxTimer, xMessageID, xMessageValue )
355  #endif
356  #ifndef traceMALLOC
357      #define traceMALLOC( pvAddress, uiSize )
358  #endif
359  #ifndef traceFREE
360      #define traceFREE( pvAddress, uiSize )
361  #endif
362  #ifndef traceEVENT_GROUP_CREATE
363  	#define traceEVENT_GROUP_CREATE( xEventGroup )
364  #endif
365  #ifndef traceEVENT_GROUP_CREATE_FAILED
366  	#define traceEVENT_GROUP_CREATE_FAILED()
367  #endif
368  #ifndef traceEVENT_GROUP_SYNC_BLOCK
369  	#define traceEVENT_GROUP_SYNC_BLOCK( xEventGroup, uxBitsToSet, uxBitsToWaitFor )
370  #endif
371  #ifndef traceEVENT_GROUP_SYNC_END
372  	#define traceEVENT_GROUP_SYNC_END( xEventGroup, uxBitsToSet, uxBitsToWaitFor, xTimeoutOccurred ) ( void ) xTimeoutOccurred
373  #endif
374  #ifndef traceEVENT_GROUP_WAIT_BITS_BLOCK
375  	#define traceEVENT_GROUP_WAIT_BITS_BLOCK( xEventGroup, uxBitsToWaitFor )
376  #endif
377  #ifndef traceEVENT_GROUP_WAIT_BITS_END
378  	#define traceEVENT_GROUP_WAIT_BITS_END( xEventGroup, uxBitsToWaitFor, xTimeoutOccurred ) ( void ) xTimeoutOccurred
379  #endif
380  #ifndef traceEVENT_GROUP_CLEAR_BITS
381  	#define traceEVENT_GROUP_CLEAR_BITS( xEventGroup, uxBitsToClear )
382  #endif
383  #ifndef traceEVENT_GROUP_CLEAR_BITS_FROM_ISR
384  	#define traceEVENT_GROUP_CLEAR_BITS_FROM_ISR( xEventGroup, uxBitsToClear )
385  #endif
386  #ifndef traceEVENT_GROUP_SET_BITS
387  	#define traceEVENT_GROUP_SET_BITS( xEventGroup, uxBitsToSet )
388  #endif
389  #ifndef traceEVENT_GROUP_SET_BITS_FROM_ISR
390  	#define traceEVENT_GROUP_SET_BITS_FROM_ISR( xEventGroup, uxBitsToSet )
391  #endif
392  #ifndef traceEVENT_GROUP_DELETE
393  	#define traceEVENT_GROUP_DELETE( xEventGroup )
394  #endif
395  #ifndef tracePEND_FUNC_CALL
396  	#define tracePEND_FUNC_CALL(xFunctionToPend, pvParameter1, ulParameter2, ret)
397  #endif
398  #ifndef tracePEND_FUNC_CALL_FROM_ISR
399  	#define tracePEND_FUNC_CALL_FROM_ISR(xFunctionToPend, pvParameter1, ulParameter2, ret)
400  #endif
401  #ifndef traceQUEUE_REGISTRY_ADD
402  	#define traceQUEUE_REGISTRY_ADD(xQueue, pcQueueName)
403  #endif
404  #ifndef traceTASK_NOTIFY_TAKE_BLOCK
405  	#define traceTASK_NOTIFY_TAKE_BLOCK()
406  #endif
407  #ifndef traceTASK_NOTIFY_TAKE
408  	#define traceTASK_NOTIFY_TAKE()
409  #endif
410  #ifndef traceTASK_NOTIFY_WAIT_BLOCK
411  	#define traceTASK_NOTIFY_WAIT_BLOCK()
412  #endif
413  #ifndef traceTASK_NOTIFY_WAIT
414  	#define traceTASK_NOTIFY_WAIT()
415  #endif
416  #ifndef traceTASK_NOTIFY
417  	#define traceTASK_NOTIFY()
418  #endif
419  #ifndef traceTASK_NOTIFY_FROM_ISR
420  	#define traceTASK_NOTIFY_FROM_ISR()
421  #endif
422  #ifndef traceTASK_NOTIFY_GIVE_FROM_ISR
423  	#define traceTASK_NOTIFY_GIVE_FROM_ISR()
424  #endif
425  #ifndef traceISR_EXIT_TO_SCHEDULER
426  	#define traceISR_EXIT_TO_SCHEDULER()
427  #endif
428  #ifndef traceISR_EXIT
429  	#define traceISR_EXIT()
430  #endif
431  #ifndef traceISR_ENTER
432  	#define traceISR_ENTER()
433  #endif
434  #ifndef traceSTREAM_BUFFER_CREATE_FAILED
435  	#define traceSTREAM_BUFFER_CREATE_FAILED( xIsMessageBuffer )
436  #endif
437  #ifndef traceSTREAM_BUFFER_CREATE_STATIC_FAILED
438  	#define traceSTREAM_BUFFER_CREATE_STATIC_FAILED( xReturn, xIsMessageBuffer )
439  #endif
440  #ifndef traceSTREAM_BUFFER_CREATE
441  	#define traceSTREAM_BUFFER_CREATE( pxStreamBuffer, xIsMessageBuffer )
442  #endif
443  #ifndef traceSTREAM_BUFFER_DELETE
444  	#define traceSTREAM_BUFFER_DELETE( xStreamBuffer )
445  #endif
446  #ifndef traceSTREAM_BUFFER_RESET
447  	#define traceSTREAM_BUFFER_RESET( xStreamBuffer )
448  #endif
449  #ifndef traceBLOCKING_ON_STREAM_BUFFER_SEND
450  	#define traceBLOCKING_ON_STREAM_BUFFER_SEND( xStreamBuffer )
451  #endif
452  #ifndef traceSTREAM_BUFFER_SEND
453  	#define traceSTREAM_BUFFER_SEND( xStreamBuffer, xBytesSent )
454  #endif
455  #ifndef traceSTREAM_BUFFER_SEND_FAILED
456  	#define traceSTREAM_BUFFER_SEND_FAILED( xStreamBuffer )
457  #endif
458  #ifndef traceSTREAM_BUFFER_SEND_FROM_ISR
459  	#define traceSTREAM_BUFFER_SEND_FROM_ISR( xStreamBuffer, xBytesSent )
460  #endif
461  #ifndef traceBLOCKING_ON_STREAM_BUFFER_RECEIVE
462  	#define traceBLOCKING_ON_STREAM_BUFFER_RECEIVE( xStreamBuffer )
463  #endif
464  #ifndef traceSTREAM_BUFFER_RECEIVE
465  	#define traceSTREAM_BUFFER_RECEIVE( xStreamBuffer, xReceivedLength )
466  #endif
467  #ifndef traceSTREAM_BUFFER_RECEIVE_FAILED
468  	#define traceSTREAM_BUFFER_RECEIVE_FAILED( xStreamBuffer )
469  #endif
470  #ifndef traceSTREAM_BUFFER_RECEIVE_FROM_ISR
471  	#define traceSTREAM_BUFFER_RECEIVE_FROM_ISR( xStreamBuffer, xReceivedLength )
472  #endif
473  #ifndef configGENERATE_RUN_TIME_STATS
474  	#define configGENERATE_RUN_TIME_STATS 0
475  #endif
476  #if ( configGENERATE_RUN_TIME_STATS == 1 )
477  	#ifndef portCONFIGURE_TIMER_FOR_RUN_TIME_STATS
478  		#error If configGENERATE_RUN_TIME_STATS is defined then portCONFIGURE_TIMER_FOR_RUN_TIME_STATS must also be defined.  portCONFIGURE_TIMER_FOR_RUN_TIME_STATS should call a port layer function to setup a peripheral timer/counter that can then be used as the run time counter time base.
479  	#endif &amp;bsol;* portCONFIGURE_TIMER_FOR_RUN_TIME_STATS */
480  	#ifndef portGET_RUN_TIME_COUNTER_VALUE
481  		#ifndef portALT_GET_RUN_TIME_COUNTER_VALUE
482  			#error If configGENERATE_RUN_TIME_STATS is defined then either portGET_RUN_TIME_COUNTER_VALUE or portALT_GET_RUN_TIME_COUNTER_VALUE must also be defined.  See the examples provided and the FreeRTOS web site for more information.
483  		#endif &amp;bsol;* portALT_GET_RUN_TIME_COUNTER_VALUE */
484  	#endif &amp;bsol;* portGET_RUN_TIME_COUNTER_VALUE */
485  #endif &amp;bsol;* configGENERATE_RUN_TIME_STATS */
486  #ifndef portCONFIGURE_TIMER_FOR_RUN_TIME_STATS
487  	#define portCONFIGURE_TIMER_FOR_RUN_TIME_STATS()
488  #endif
489  #ifndef configUSE_MALLOC_FAILED_HOOK
490  	#define configUSE_MALLOC_FAILED_HOOK 0
491  #endif
492  #ifndef portPRIVILEGE_BIT
493  	#define portPRIVILEGE_BIT ( ( UBaseType_t ) 0x00 )
494  #endif
495  #ifndef portYIELD_WITHIN_API
496  	#define portYIELD_WITHIN_API portYIELD
497  #endif
498  #ifndef portSUPPRESS_TICKS_AND_SLEEP
499  	#define portSUPPRESS_TICKS_AND_SLEEP( xExpectedIdleTime )
500  #endif
501  #ifndef configEXPECTED_IDLE_TIME_BEFORE_SLEEP
502  	#define configEXPECTED_IDLE_TIME_BEFORE_SLEEP 2
503  #endif
504  #if configEXPECTED_IDLE_TIME_BEFORE_SLEEP &lt; 2
505  	#error configEXPECTED_IDLE_TIME_BEFORE_SLEEP must not be less than 2
506  #endif
507  #ifndef configUSE_TICKLESS_IDLE
508  	#define configUSE_TICKLESS_IDLE 0
509  #endif
510  #ifndef configPRE_SUPPRESS_TICKS_AND_SLEEP_PROCESSING
511  	#define configPRE_SUPPRESS_TICKS_AND_SLEEP_PROCESSING( x )
512  #endif
513  #ifndef configPRE_SLEEP_PROCESSING
514  	#define configPRE_SLEEP_PROCESSING( x )
515  #endif
516  #ifndef configPOST_SLEEP_PROCESSING
517  	#define configPOST_SLEEP_PROCESSING( x )
518  #endif
519  #ifndef configUSE_QUEUE_SETS
520  	#define configUSE_QUEUE_SETS 0
521  #endif
522  #ifndef portTASK_USES_FLOATING_POINT
523  	#define portTASK_USES_FLOATING_POINT()
524  #endif
525  #ifndef portTASK_CALLS_SECURE_FUNCTIONS
526  	#define portTASK_CALLS_SECURE_FUNCTIONS()
527  #endif
528  #ifndef configUSE_TIME_SLICING
529  	#define configUSE_TIME_SLICING 1
530  #endif
531  #ifndef configINCLUDE_APPLICATION_DEFINED_PRIVILEGED_FUNCTIONS
532  	#define configINCLUDE_APPLICATION_DEFINED_PRIVILEGED_FUNCTIONS 0
533  #endif
534  #ifndef configUSE_STATS_FORMATTING_FUNCTIONS
535  	#define configUSE_STATS_FORMATTING_FUNCTIONS 0
536  #endif
537  #ifndef portASSERT_IF_INTERRUPT_PRIORITY_INVALID
538  	#define portASSERT_IF_INTERRUPT_PRIORITY_INVALID()
539  #endif
540  #ifndef configUSE_TRACE_FACILITY
541  	#define configUSE_TRACE_FACILITY 0
542  #endif
543  #ifndef mtCOVERAGE_TEST_MARKER
544  	#define mtCOVERAGE_TEST_MARKER()
545  #endif
546  #ifndef mtCOVERAGE_TEST_DELAY
547  	#define mtCOVERAGE_TEST_DELAY()
548  #endif
549  #ifndef portASSERT_IF_IN_ISR
550  	#define portASSERT_IF_IN_ISR()
551  #endif
552  #ifndef configUSE_PORT_OPTIMISED_TASK_SELECTION
553  	#define configUSE_PORT_OPTIMISED_TASK_SELECTION 0
554  #endif
555  #ifndef configAPPLICATION_ALLOCATED_HEAP
556  	#define configAPPLICATION_ALLOCATED_HEAP 0
557  #endif
558  #ifndef configUSE_TASK_NOTIFICATIONS
559  	#define configUSE_TASK_NOTIFICATIONS 1
560  #endif
561  #ifndef portTICK_TYPE_IS_ATOMIC
562  	#define portTICK_TYPE_IS_ATOMIC 0
563  #endif
564  #ifndef configSUPPORT_STATIC_ALLOCATION
565  	#define configSUPPORT_STATIC_ALLOCATION 0
566  #endif
567  #ifndef configSUPPORT_DYNAMIC_ALLOCATION
568  	#define configSUPPORT_DYNAMIC_ALLOCATION 1
569  #endif
570  #ifndef configSTACK_DEPTH_TYPE
571  	#define configSTACK_DEPTH_TYPE uint16_t
572  #endif
573  #if( configUSE_TICKLESS_IDLE != 0 )
574  	#if( INCLUDE_vTaskSuspend != 1 )
575  		#error INCLUDE_vTaskSuspend must be set to 1 if configUSE_TICKLESS_IDLE is not set to 0
576  	#endif &amp;bsol;* INCLUDE_vTaskSuspend */
577  #endif &amp;bsol;* configUSE_TICKLESS_IDLE */
578  #if( ( configSUPPORT_STATIC_ALLOCATION == 0 ) &amp;&amp; ( configSUPPORT_DYNAMIC_ALLOCATION == 0 ) )
579  	#error configSUPPORT_STATIC_ALLOCATION and configSUPPORT_DYNAMIC_ALLOCATION cannot both be 0, but can both be 1.
580  #endif
581  #if( ( configUSE_RECURSIVE_MUTEXES == 1 ) &amp;&amp; ( configUSE_MUTEXES != 1 ) )
582  	#error configUSE_MUTEXES must be set to 1 to use recursive mutexes
583  #endif
584  #ifndef configINITIAL_TICK_COUNT
585  	#define configINITIAL_TICK_COUNT 0
586  #endif
587  #if( portTICK_TYPE_IS_ATOMIC == 0 )
588  	#define portTICK_TYPE_ENTER_CRITICAL() portENTER_CRITICAL()
589  	#define portTICK_TYPE_EXIT_CRITICAL() portEXIT_CRITICAL()
590  	#define portTICK_TYPE_SET_INTERRUPT_MASK_FROM_ISR() portSET_INTERRUPT_MASK_FROM_ISR()
591  	#define portTICK_TYPE_CLEAR_INTERRUPT_MASK_FROM_ISR( x ) portCLEAR_INTERRUPT_MASK_FROM_ISR( ( x ) )
592  #else
593  	#define portTICK_TYPE_ENTER_CRITICAL()
594  	#define portTICK_TYPE_EXIT_CRITICAL()
595  	#define portTICK_TYPE_SET_INTERRUPT_MASK_FROM_ISR() 0
596  	#define portTICK_TYPE_CLEAR_INTERRUPT_MASK_FROM_ISR( x ) ( void ) x
597  #endif
598  #ifndef configENABLE_BACKWARD_COMPATIBILITY
599  	#define configENABLE_BACKWARD_COMPATIBILITY 1
600  #endif
601  #ifndef configPRINTF
602  	#define configPRINTF( X )
603  #endif
604  #ifndef configMAX
605  	#define configMAX( a, b ) ( ( ( a ) &gt; ( b ) ) ? ( a ) : ( b ) )
606  #endif
607  #ifndef configMIN
608  	#define configMIN( a, b ) ( ( ( a ) &lt; ( b ) ) ? ( a ) : ( b ) )
609  #endif
610  #if configENABLE_BACKWARD_COMPATIBILITY == 1
611  	#define eTaskStateGet eTaskGetState
612  	#define portTickType TickType_t
613  	#define xTaskHandle TaskHandle_t
614  	#define xQueueHandle QueueHandle_t
615  	#define xSemaphoreHandle SemaphoreHandle_t
616  	#define xQueueSetHandle QueueSetHandle_t
617  	#define xQueueSetMemberHandle QueueSetMemberHandle_t
618  	#define xTimeOutType TimeOut_t
619  	#define xMemoryRegion MemoryRegion_t
620  	#define xTaskParameters TaskParameters_t
621  	#define xTaskStatusType	TaskStatus_t
622  	#define xTimerHandle TimerHandle_t
623  	#define xCoRoutineHandle CoRoutineHandle_t
624  	#define pdTASK_HOOK_CODE TaskHookFunction_t
625  	#define portTICK_RATE_MS portTICK_PERIOD_MS
626  	#define pcTaskGetTaskName pcTaskGetName
627  	#define pcTimerGetTimerName pcTimerGetName
628  	#define pcQueueGetQueueName pcQueueGetName
629  	#define vTaskGetTaskInfo vTaskGetInfo
630  	#define tmrTIMER_CALLBACK TimerCallbackFunction_t
631  	#define pdTASK_CODE TaskFunction_t
632  	#define xListItem ListItem_t
633  	#define xList List_t
634  #endif &amp;bsol;* configENABLE_BACKWARD_COMPATIBILITY */
635  #if( configUSE_ALTERNATIVE_API != 0 )
636  	#error The alternative API was deprecated some time ago, and was removed in FreeRTOS V9.0 0
637  #endif
638  #ifndef configUSE_TASK_FPU_SUPPORT
639  	#define configUSE_TASK_FPU_SUPPORT 1
640  #endif
641  struct xSTATIC_LIST_ITEM
642  {
643  	TickType_t xDummy1;
644  	void *pvDummy2[ 4 ];
645  };
646  typedef struct xSTATIC_LIST_ITEM StaticListItem_t;
647  struct xSTATIC_MINI_LIST_ITEM
648  {
649  	TickType_t xDummy1;
650  	void *pvDummy2[ 2 ];
651  };
652  typedef struct xSTATIC_MINI_LIST_ITEM StaticMiniListItem_t;
653  typedef struct xSTATIC_LIST
654  {
655  	UBaseType_t uxDummy1;
656  	void *pvDummy2;
657  	StaticMiniListItem_t xDummy3;
658  } StaticList_t;
659  typedef struct xSTATIC_TCB
660  {
661  	void				*pxDummy1;
662  	#if ( portUSING_MPU_WRAPPERS == 1 )
663  		xMPU_SETTINGS	xDummy2;
664  	#endif
665  	StaticListItem_t	xDummy3[ 2 ];
666  	UBaseType_t			uxDummy5;
667  	void				*pxDummy6;
668  	uint8_t				ucDummy7[ configMAX_TASK_NAME_LEN ];
669  	#if ( ( portSTACK_GROWTH &gt; 0 ) || ( configRECORD_STACK_HIGH_ADDRESS == 1 ) )
670  		void			*pxDummy8;
671  	#endif
672  	#if ( portCRITICAL_NESTING_IN_TCB == 1 )
673  		UBaseType_t		uxDummy9;
674  	#endif
675  	#if ( configUSE_TRACE_FACILITY == 1 )
676  		UBaseType_t		uxDummy10[ 2 ];
677  	#endif
678  	#if ( configUSE_MUTEXES == 1 )
679  		UBaseType_t		uxDummy12[ 2 ];
680  	#endif
681  	#if ( configUSE_APPLICATION_TASK_TAG == 1 )
682  		void			*pxDummy14;
683  	#endif
684  	#if( configNUM_THREAD_LOCAL_STORAGE_POINTERS &gt; 0 )
685  		void			*pvDummy15[ configNUM_THREAD_LOCAL_STORAGE_POINTERS ];
686  	#endif
687  	#if ( configGENERATE_RUN_TIME_STATS == 1 )
688  		uint32_t		ulDummy16;
689  	#endif
690  	#if ( configUSE_NEWLIB_REENTRANT == 1 )
691  		struct	_reent	xDummy17;
692  	#endif
693  	#if ( configUSE_TASK_NOTIFICATIONS == 1 )
694  		uint32_t 		ulDummy18;
695  		uint8_t 		ucDummy19;
696  	#endif
697  	#if( ( ( configSUPPORT_STATIC_ALLOCATION == 1 ) &amp;&amp; ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) ) || ( portUSING_MPU_WRAPPERS == 1 ) )
698  		uint8_t			uxDummy20;
699  	#endif
700  	#if( INCLUDE_xTaskAbortDelay == 1 )
701  		uint8_t ucDummy21;
702  	#endif
703  } StaticTask_t;
704  typedef struct xSTATIC_QUEUE
705  {
706  	void *pvDummy1[ 3 ];
707  	union
708  	{
709  		void *pvDummy2;
710  		UBaseType_t uxDummy2;
711  	} u;
712  	StaticList_t xDummy3[ 2 ];
713  	UBaseType_t uxDummy4[ 3 ];
714  	uint8_t ucDummy5[ 2 ];
715  	#if( ( configSUPPORT_STATIC_ALLOCATION == 1 ) &amp;&amp; ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) )
716  		uint8_t ucDummy6;
717  	#endif
718  	#if ( configUSE_QUEUE_SETS == 1 )
719  		void *pvDummy7;
720  	#endif
721  	#if ( configUSE_TRACE_FACILITY == 1 )
722  		UBaseType_t uxDummy8;
723  		uint8_t ucDummy9;
724  	#endif
725  } StaticQueue_t;
726  typedef StaticQueue_t StaticSemaphore_t;
727  typedef struct xSTATIC_EVENT_GROUP
728  {
729  	TickType_t xDummy1;
730  	StaticList_t xDummy2;
731  	#if( configUSE_TRACE_FACILITY == 1 )
732  		UBaseType_t uxDummy3;
733  	#endif
734  	#if( ( configSUPPORT_STATIC_ALLOCATION == 1 ) &amp;&amp; ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) )
735  			uint8_t ucDummy4;
736  	#endif
<span onclick='openModal()' class='match'>737  } StaticEventGroup_t;
738  typedef struct xSTATIC_TIMER
739  {
740  	void				*pvDummy1;
741  	StaticListItem_t	xDummy2;
742  	TickType_t			xDummy3;
743  	UBaseType_t			uxDummy4;
</span>744  	void 				*pvDummy5[ 2 ];
745  	#if( configUSE_TRACE_FACILITY == 1 )
746  		UBaseType_t		uxDummy6;
747  	#endif
748  	#if( ( configSUPPORT_STATIC_ALLOCATION == 1 ) &amp;&amp; ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) )
749  		uint8_t 		ucDummy7;
750  	#endif
751  } StaticTimer_t;
752  typedef struct xSTATIC_STREAM_BUFFER
753  {
754  	size_t uxDummy1[ 4 ];
755  	void * pvDummy2[ 3 ];
756  	uint8_t ucDummy3;
757  	#if ( configUSE_TRACE_FACILITY == 1 )
758  		UBaseType_t uxDummy4;
759  	#endif
760  } StaticStreamBuffer_t;
761  typedef StaticStreamBuffer_t StaticMessageBuffer_t;
762  #ifdef __cplusplus
763  }
764  #endif
765  #endif &amp;bsol;* INC_FREERTOS_H */
</code></pre>
        </div>
        <div class="column">
            <h3>Adafruit_nRF52_Arduino-MDEwOlJlcG9zaXRvcnk3NDM1NDcyOQ==-flat-task.h</h3>
            <pre><code>1  #ifndef INC_TASK_H
2  #define INC_TASK_H
3  #ifndef INC_FREERTOS_H
4  	#error &quot;include FreeRTOS.h must appear in source files before include task.h&quot;
5  #endif
6  #include &quot;list.h&quot;
7  #ifdef __cplusplus
8  extern &quot;C&quot; {
9  #endif
10  #define tskKERNEL_VERSION_NUMBER &quot;V10.0.1&quot;
11  #define tskKERNEL_VERSION_MAJOR 10
12  #define tskKERNEL_VERSION_MINOR 0
13  #define tskKERNEL_VERSION_BUILD 1
14  typedef void * TaskHandle_t;
15  typedef BaseType_t (*TaskHookFunction_t)( void * );
16  typedef enum
17  {
18  	eRunning = 0,	&amp;bsol;* A task is querying the state of itself, so must be running. */
19  	eReady,			&amp;bsol;* The task being queried is in a read or pending ready list. */
20  	eBlocked,		&amp;bsol;* The task being queried is in the Blocked state. */
21  	eSuspended,		&amp;bsol;* The task being queried is in the Suspended state, or is in the Blocked state with an infinite time out. */
22  	eDeleted,		&amp;bsol;* The task being queried has been deleted, but its TCB has not yet been freed. */
23  	eInvalid			&amp;bsol;* Used as an &#x27;invalid state&#x27; value. */
24  } eTaskState;
25  typedef enum
26  {
27  	eNoAction = 0,				&amp;bsol;* Notify the task without updating its notify value. */
28  	eSetBits,					&amp;bsol;* Set bits in the task&#x27;s notification value. */
29  	eIncrement,					&amp;bsol;* Increment the task&#x27;s notification value. */
30  	eSetValueWithOverwrite,		&amp;bsol;* Set the task&#x27;s notification value to a specific value even if the previous value has not yet been read by the task. */
31  	eSetValueWithoutOverwrite	&amp;bsol;* Set the task&#x27;s notification value if the previous value has been read by the task. */
32  } eNotifyAction;
33  typedef struct xTIME_OUT
34  {
35  	BaseType_t xOverflowCount;
36  	TickType_t xTimeOnEntering;
<span onclick='openModal()' class='match'>37  } TimeOut_t;
38  typedef struct xMEMORY_REGION
39  {
40  	void *pvBaseAddress;
41  	uint32_t ulLengthInBytes;
42  	uint32_t ulParameters;
43  } MemoryRegion_t;
</span>44  typedef struct xTASK_PARAMETERS
45  {
46  	TaskFunction_t pvTaskCode;
47  	const char * const pcName;	&amp;bsol;*lint !e971 Unqualified char types are allowed for strings and single characters only. */
48  	uint16_t usStackDepth;
49  	void *pvParameters;
50  	UBaseType_t uxPriority;
51  	StackType_t *puxStackBuffer;
52  	MemoryRegion_t xRegions[ portNUM_CONFIGURABLE_REGIONS ];
53  	#if ( ( portUSING_MPU_WRAPPERS == 1 ) &amp;&amp; ( configSUPPORT_STATIC_ALLOCATION == 1 ) )
54  		StaticTask_t * const pxTaskBuffer;
55  	#endif
56  } TaskParameters_t;
57  typedef struct xTASK_STATUS
58  {
59  	TaskHandle_t xHandle;			&amp;bsol;* The handle of the task to which the rest of the information in the structure relates. */
60  	const char *pcTaskName;			&amp;bsol;* A pointer to the task&#x27;s name.  This value will be invalid if the task was deleted since the structure was populated! */ &amp;bsol;*lint !e971 Unqualified char types are allowed for strings and single characters only. */
61  	UBaseType_t xTaskNumber;		&amp;bsol;* A number unique to the task. */
62  	eTaskState eCurrentState;		&amp;bsol;* The state in which the task existed when the structure was populated. */
63  	UBaseType_t uxCurrentPriority;	&amp;bsol;* The priority at which the task was running (may be inherited) when the structure was populated. */
64  	UBaseType_t uxBasePriority;		&amp;bsol;* The priority to which the task will return if the task&#x27;s current priority has been inherited to avoid unbounded priority inversion when obtaining a mutex.  Only valid if configUSE_MUTEXES is defined as 1 in FreeRTOSConfig.h. */
65  	uint32_t ulRunTimeCounter;		&amp;bsol;* The total run time allocated to the task so far, as defined by the run time stats clock.  See http:&amp;bsol;&amp;bsol;www.freertos.org/rtos-run-time-stats.html.  Only valid when configGENERATE_RUN_TIME_STATS is defined as 1 in FreeRTOSConfig.h. */
66  	StackType_t *pxStackBase;		&amp;bsol;* Points to the lowest address of the task&#x27;s stack area. */
67  	uint16_t usStackHighWaterMark;	&amp;bsol;* The minimum amount of stack space that has remained for the task since the task was created.  The closer this value is to zero the closer the task has come to overflowing its stack. */
68  } TaskStatus_t;
69  typedef enum
70  {
71  	eAbortSleep = 0,		&amp;bsol;* A task has been made ready or a context switch pended since portSUPPORESS_TICKS_AND_SLEEP() was called - abort entering a sleep mode. */
72  	eStandardSleep,			&amp;bsol;* Enter a sleep mode that will not last any longer than the expected idle time. */
73  	eNoTasksWaitingTimeout	&amp;bsol;* No tasks are waiting for a timeout so it is safe to enter a sleep mode that can only be exited by an external interrupt. */
74  } eSleepModeStatus;
75  #define tskIDLE_PRIORITY			( ( UBaseType_t ) 0U )
76  #define taskYIELD()					portYIELD()
77  #define taskENTER_CRITICAL()		portENTER_CRITICAL()
78  #define taskENTER_CRITICAL_FROM_ISR() portSET_INTERRUPT_MASK_FROM_ISR()
79  #define taskEXIT_CRITICAL()			portEXIT_CRITICAL()
80  #define taskEXIT_CRITICAL_FROM_ISR( x ) portCLEAR_INTERRUPT_MASK_FROM_ISR( x )
81  #define taskDISABLE_INTERRUPTS()	portDISABLE_INTERRUPTS()
82  #define taskENABLE_INTERRUPTS()		portENABLE_INTERRUPTS()
83  #define taskSCHEDULER_SUSPENDED		( ( BaseType_t ) 0 )
84  #define taskSCHEDULER_NOT_STARTED	( ( BaseType_t ) 1 )
85  #define taskSCHEDULER_RUNNING		( ( BaseType_t ) 2 )
86  #if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )
87  	BaseType_t xTaskCreate(	TaskFunction_t pxTaskCode,
88  							const char * const pcName,	&amp;bsol;*lint !e971 Unqualified char types are allowed for strings and single characters only. */
89  							const configSTACK_DEPTH_TYPE usStackDepth,
90  							void * const pvParameters,
91  							UBaseType_t uxPriority,
92  							TaskHandle_t * const pxCreatedTask ) PRIVILEGED_FUNCTION;
93  #endif
94  #if( configSUPPORT_STATIC_ALLOCATION == 1 )
95  	TaskHandle_t xTaskCreateStatic(	TaskFunction_t pxTaskCode,
96  									const char * const pcName, &amp;bsol;*lint !e971 Unqualified char types are allowed for strings and single characters only. */
97  									const uint32_t ulStackDepth,
98  									void * const pvParameters,
99  									UBaseType_t uxPriority,
100  									StackType_t * const puxStackBuffer,
101  									StaticTask_t * const pxTaskBuffer ) PRIVILEGED_FUNCTION;
102  #endif &amp;bsol;* configSUPPORT_STATIC_ALLOCATION */
103  #if( portUSING_MPU_WRAPPERS == 1 )
104  	BaseType_t xTaskCreateRestricted( const TaskParameters_t * const pxTaskDefinition, TaskHandle_t *pxCreatedTask ) PRIVILEGED_FUNCTION;
105  #endif
106  #if( ( portUSING_MPU_WRAPPERS == 1 ) &amp;&amp; ( configSUPPORT_STATIC_ALLOCATION == 1 ) )
107  	BaseType_t xTaskCreateRestrictedStatic( const TaskParameters_t * const pxTaskDefinition, TaskHandle_t *pxCreatedTask ) PRIVILEGED_FUNCTION;
108  #endif
109  void vTaskAllocateMPURegions( TaskHandle_t xTask, const MemoryRegion_t * const pxRegions ) PRIVILEGED_FUNCTION;
110  void vTaskDelete( TaskHandle_t xTaskToDelete ) PRIVILEGED_FUNCTION;
111  void vTaskDelay( const TickType_t xTicksToDelay ) PRIVILEGED_FUNCTION;
112  void vTaskDelayUntil( TickType_t * const pxPreviousWakeTime, const TickType_t xTimeIncrement ) PRIVILEGED_FUNCTION;
113  BaseType_t xTaskAbortDelay( TaskHandle_t xTask ) PRIVILEGED_FUNCTION;
114  UBaseType_t uxTaskPriorityGet( TaskHandle_t xTask ) PRIVILEGED_FUNCTION;
115  UBaseType_t uxTaskPriorityGetFromISR( TaskHandle_t xTask ) PRIVILEGED_FUNCTION;
116  eTaskState eTaskGetState( TaskHandle_t xTask ) PRIVILEGED_FUNCTION;
117  void vTaskGetInfo( TaskHandle_t xTask, TaskStatus_t *pxTaskStatus, BaseType_t xGetFreeStackSpace, eTaskState eState ) PRIVILEGED_FUNCTION;
118  void vTaskPrioritySet( TaskHandle_t xTask, UBaseType_t uxNewPriority ) PRIVILEGED_FUNCTION;
119  void vTaskSuspend( TaskHandle_t xTaskToSuspend ) PRIVILEGED_FUNCTION;
120  void vTaskResume( TaskHandle_t xTaskToResume ) PRIVILEGED_FUNCTION;
121  BaseType_t xTaskResumeFromISR( TaskHandle_t xTaskToResume ) PRIVILEGED_FUNCTION;
122  void vTaskStartScheduler( void ) PRIVILEGED_FUNCTION;
123  void vTaskEndScheduler( void ) PRIVILEGED_FUNCTION;
124  void vTaskSuspendAll( void ) PRIVILEGED_FUNCTION;
125  BaseType_t xTaskResumeAll( void ) PRIVILEGED_FUNCTION;
126  TickType_t xTaskGetTickCount( void ) PRIVILEGED_FUNCTION;
127  TickType_t xTaskGetTickCountFromISR( void ) PRIVILEGED_FUNCTION;
128  UBaseType_t uxTaskGetNumberOfTasks( void ) PRIVILEGED_FUNCTION;
129  char *pcTaskGetName( TaskHandle_t xTaskToQuery ) PRIVILEGED_FUNCTION; &amp;bsol;*lint !e971 Unqualified char types are allowed for strings and single characters only. */
130  TaskHandle_t xTaskGetHandle( const char *pcNameToQuery ) PRIVILEGED_FUNCTION; &amp;bsol;*lint !e971 Unqualified char types are allowed for strings and single characters only. */
131  UBaseType_t uxTaskGetStackHighWaterMark( TaskHandle_t xTask ) PRIVILEGED_FUNCTION;
132  uint8_t* pxTaskGetStackStart( TaskHandle_t xTask) PRIVILEGED_FUNCTION;
133  #ifdef configUSE_APPLICATION_TASK_TAG
134  	#if configUSE_APPLICATION_TASK_TAG == 1
135  		void vTaskSetApplicationTaskTag( TaskHandle_t xTask, TaskHookFunction_t pxHookFunction ) PRIVILEGED_FUNCTION;
136  		TaskHookFunction_t xTaskGetApplicationTaskTag( TaskHandle_t xTask ) PRIVILEGED_FUNCTION;
137  	#endif &amp;bsol;* configUSE_APPLICATION_TASK_TAG ==1 */
138  #endif &amp;bsol;* ifdef configUSE_APPLICATION_TASK_TAG */
139  #if( configNUM_THREAD_LOCAL_STORAGE_POINTERS &gt; 0 )
140  	void vTaskSetThreadLocalStoragePointer( TaskHandle_t xTaskToSet, BaseType_t xIndex, void *pvValue ) PRIVILEGED_FUNCTION;
141  	void *pvTaskGetThreadLocalStoragePointer( TaskHandle_t xTaskToQuery, BaseType_t xIndex ) PRIVILEGED_FUNCTION;
142  #endif
143  BaseType_t xTaskCallApplicationTaskHook( TaskHandle_t xTask, void *pvParameter ) PRIVILEGED_FUNCTION;
144  TaskHandle_t xTaskGetIdleTaskHandle( void ) PRIVILEGED_FUNCTION;
145  UBaseType_t uxTaskGetSystemState( TaskStatus_t * const pxTaskStatusArray, const UBaseType_t uxArraySize, uint32_t * const pulTotalRunTime ) PRIVILEGED_FUNCTION;
146  void vTaskList( char * pcWriteBuffer ) PRIVILEGED_FUNCTION; &amp;bsol;*lint !e971 Unqualified char types are allowed for strings and single characters only. */
147  void vTaskGetRunTimeStats( char *pcWriteBuffer ) PRIVILEGED_FUNCTION; &amp;bsol;*lint !e971 Unqualified char types are allowed for strings and single characters only. */
148  BaseType_t xTaskGenericNotify( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t *pulPreviousNotificationValue ) PRIVILEGED_FUNCTION;
149  #define xTaskNotify( xTaskToNotify, ulValue, eAction ) xTaskGenericNotify( ( xTaskToNotify ), ( ulValue ), ( eAction ), NULL )
150  #define xTaskNotifyAndQuery( xTaskToNotify, ulValue, eAction, pulPreviousNotifyValue ) xTaskGenericNotify( ( xTaskToNotify ), ( ulValue ), ( eAction ), ( pulPreviousNotifyValue ) )
151  BaseType_t xTaskGenericNotifyFromISR( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t *pulPreviousNotificationValue, BaseType_t *pxHigherPriorityTaskWoken ) PRIVILEGED_FUNCTION;
152  #define xTaskNotifyFromISR( xTaskToNotify, ulValue, eAction, pxHigherPriorityTaskWoken ) xTaskGenericNotifyFromISR( ( xTaskToNotify ), ( ulValue ), ( eAction ), NULL, ( pxHigherPriorityTaskWoken ) )
153  #define xTaskNotifyAndQueryFromISR( xTaskToNotify, ulValue, eAction, pulPreviousNotificationValue, pxHigherPriorityTaskWoken ) xTaskGenericNotifyFromISR( ( xTaskToNotify ), ( ulValue ), ( eAction ), ( pulPreviousNotificationValue ), ( pxHigherPriorityTaskWoken ) )
154  BaseType_t xTaskNotifyWait( uint32_t ulBitsToClearOnEntry, uint32_t ulBitsToClearOnExit, uint32_t *pulNotificationValue, TickType_t xTicksToWait ) PRIVILEGED_FUNCTION;
155  #define xTaskNotifyGive( xTaskToNotify ) xTaskGenericNotify( ( xTaskToNotify ), ( 0 ), eIncrement, NULL )
156  void vTaskNotifyGiveFromISR( TaskHandle_t xTaskToNotify, BaseType_t *pxHigherPriorityTaskWoken ) PRIVILEGED_FUNCTION;
157  uint32_t ulTaskNotifyTake( BaseType_t xClearCountOnExit, TickType_t xTicksToWait ) PRIVILEGED_FUNCTION;
158  BaseType_t xTaskNotifyStateClear( TaskHandle_t xTask );
159  BaseType_t xTaskIncrementTick( void ) PRIVILEGED_FUNCTION;
160  void vTaskPlaceOnEventList( List_t * const pxEventList, const TickType_t xTicksToWait ) PRIVILEGED_FUNCTION;
161  void vTaskPlaceOnUnorderedEventList( List_t * pxEventList, const TickType_t xItemValue, const TickType_t xTicksToWait ) PRIVILEGED_FUNCTION;
162  void vTaskPlaceOnEventListRestricted( List_t * const pxEventList, TickType_t xTicksToWait, const BaseType_t xWaitIndefinitely ) PRIVILEGED_FUNCTION;
163  BaseType_t xTaskRemoveFromEventList( const List_t * const pxEventList ) PRIVILEGED_FUNCTION;
164  void vTaskRemoveFromUnorderedEventList( ListItem_t * pxEventListItem, const TickType_t xItemValue ) PRIVILEGED_FUNCTION;
165  void vTaskSwitchContext( void ) PRIVILEGED_FUNCTION;
166  TickType_t uxTaskResetEventItemValue( void ) PRIVILEGED_FUNCTION;
167  TaskHandle_t xTaskGetCurrentTaskHandle( void ) PRIVILEGED_FUNCTION;
168  void vTaskSetTimeOutState( TimeOut_t * const pxTimeOut ) PRIVILEGED_FUNCTION;
169  BaseType_t xTaskCheckForTimeOut( TimeOut_t * const pxTimeOut, TickType_t * const pxTicksToWait ) PRIVILEGED_FUNCTION;
170  void vTaskMissedYield( void ) PRIVILEGED_FUNCTION;
171  BaseType_t xTaskGetSchedulerState( void ) PRIVILEGED_FUNCTION;
172  BaseType_t xTaskPriorityInherit( TaskHandle_t const pxMutexHolder ) PRIVILEGED_FUNCTION;
173  BaseType_t xTaskPriorityDisinherit( TaskHandle_t const pxMutexHolder ) PRIVILEGED_FUNCTION;
174  void vTaskPriorityDisinheritAfterTimeout( TaskHandle_t const pxMutexHolder, UBaseType_t uxHighestPriorityWaitingTask ) PRIVILEGED_FUNCTION;
175  UBaseType_t uxTaskGetTaskNumber( TaskHandle_t xTask ) PRIVILEGED_FUNCTION;
176  void vTaskSetTaskNumber( TaskHandle_t xTask, const UBaseType_t uxHandle ) PRIVILEGED_FUNCTION;
177  void vTaskStepTick( const TickType_t xTicksToJump ) PRIVILEGED_FUNCTION;
178  eSleepModeStatus eTaskConfirmSleepModeStatus( void ) PRIVILEGED_FUNCTION;
179  void *pvTaskIncrementMutexHeldCount( void ) PRIVILEGED_FUNCTION;
180  void vTaskInternalSetTimeOutState( TimeOut_t * const pxTimeOut ) PRIVILEGED_FUNCTION;
181  #ifdef __cplusplus
182  }
183  #endif
184  #endif &amp;bsol;* INC_TASK_H */
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from Adafruit_nRF52_Arduino-MDEwOlJlcG9zaXRvcnk3NDM1NDcyOQ==-flat-FreeRTOS.h</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from Adafruit_nRF52_Arduino-MDEwOlJlcG9zaXRvcnk3NDM1NDcyOQ==-flat-task.h</div>
                </div>
                <div class="column column_space"><pre><code>737  } StaticEventGroup_t;
738  typedef struct xSTATIC_TIMER
739  {
740  	void				*pvDummy1;
741  	StaticListItem_t	xDummy2;
742  	TickType_t			xDummy3;
743  	UBaseType_t			uxDummy4;
</pre></code></div>
                <div class="column column_space"><pre><code>37  } TimeOut_t;
38  typedef struct xMEMORY_REGION
39  {
40  	void *pvBaseAddress;
41  	uint32_t ulLengthInBytes;
42  	uint32_t ulParameters;
43  } MemoryRegion_t;
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    