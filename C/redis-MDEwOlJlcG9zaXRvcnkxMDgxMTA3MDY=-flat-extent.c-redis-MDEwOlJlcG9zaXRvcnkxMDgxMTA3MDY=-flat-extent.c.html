
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 61, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>redis-MDEwOlJlcG9zaXRvcnkxMDgxMTA3MDY=-flat-extent.c</h3>
            <pre><code>1  #include "test/jemalloc_test.h"
2  #include "test/extent_hooks.h"
3  static bool
4  check_background_thread_enabled(void) {
5  	bool enabled;
6  	size_t sz = sizeof(bool);
7  	int ret = mallctl("background_thread", (void *)&enabled, &sz, NULL,0);
8  	if (ret == ENOENT) {
9  		return false;
10  	}
11  	assert_d_eq(ret, 0, "Unexpected mallctl error");
12  	return enabled;
13  }
14  static void
15  test_extent_body(unsigned arena_ind) {
16  	void *p;
17  	size_t large0, large1, large2, sz;
18  	size_t purge_mib[3];
19  	size_t purge_miblen;
20  	int flags;
21  	bool xallocx_success_a, xallocx_success_b, xallocx_success_c;
22  	flags = MALLOCX_ARENA(arena_ind) | MALLOCX_TCACHE_NONE;
23  	sz = sizeof(size_t);
24  	assert_d_eq(mallctl("arenas.lextent.0.size", (void *)&large0, &sz, NULL,
25  	    0), 0, "Unexpected arenas.lextent.0.size failure");
26  	assert_d_eq(mallctl("arenas.lextent.1.size", (void *)&large1, &sz, NULL,
27  	    0), 0, "Unexpected arenas.lextent.1.size failure");
28  	assert_d_eq(mallctl("arenas.lextent.2.size", (void *)&large2, &sz, NULL,
29  	    0), 0, "Unexpected arenas.lextent.2.size failure");
30  	purge_miblen = sizeof(purge_mib)/sizeof(size_t);
31  	assert_d_eq(mallctlnametomib("arena.0.purge", purge_mib, &purge_miblen),
32  	    0, "Unexpected mallctlnametomib() failure");
33  	purge_mib[1] = (size_t)arena_ind;
34  	called_alloc = false;
35  	try_alloc = true;
36  	try_dalloc = false;
37  	try_decommit = false;
38  	p = mallocx(large0 * 2, flags);
39  	assert_ptr_not_null(p, "Unexpected mallocx() error");
40  	assert_true(called_alloc, "Expected alloc call");
41  	called_dalloc = false;
42  	called_decommit = false;
43  	did_purge_lazy = false;
44  	did_purge_forced = false;
45  	called_split = false;
46  	xallocx_success_a = (xallocx(p, large0, 0, flags) == large0);
47  	assert_d_eq(mallctlbymib(purge_mib, purge_miblen, NULL, NULL, NULL, 0),
48  	    0, "Unexpected arena.%u.purge error", arena_ind);
49  	if (xallocx_success_a) {
50  		assert_true(called_dalloc, "Expected dalloc call");
51  		assert_true(called_decommit, "Expected decommit call");
52  		assert_true(did_purge_lazy || did_purge_forced,
53  		    "Expected purge");
54  	}
55  	assert_true(called_split, "Expected split call");
56  	dallocx(p, flags);
57  	try_dalloc = true;
58  	try_dalloc = false;
59  	try_decommit = true;
60  	p = mallocx(large0 * 2, flags);
61  	assert_ptr_not_null(p, "Unexpected mallocx() error");
62  	did_decommit = false;
63  	did_commit = false;
64  	called_split = false;
<span onclick='openModal()' class='match'>65  	did_split = false;
66  	did_merge = false;
67  	xallocx_success_b = (xallocx(p, large0, 0, flags) == large0);
68  	assert_d_eq(mallctlbymib(purge_mib, purge_miblen, NULL, NULL, NULL, 0),
69  	    0, "Unexpected arena.%u.purge error", arena_ind);
70  	if (xallocx_success_b) {
71  		assert_true(did_split, "Expected split");
72  	}
</span>73  	xallocx_success_c = (xallocx(p, large0 * 2, 0, flags) == large0 * 2);
74  	if (did_split) {
75  		assert_b_eq(did_decommit, did_commit,
76  		    "Expected decommit/commit match");
77  	}
78  	if (xallocx_success_b && xallocx_success_c) {
79  		assert_true(did_merge, "Expected merge");
80  	}
81  	dallocx(p, flags);
82  	try_dalloc = true;
83  	try_decommit = false;
84  	p = mallocx(42, flags);
85  	assert_ptr_not_null(p, "Unexpected mallocx() error");
86  	dallocx(p, flags);
87  }
88  static void
89  test_manual_hook_auto_arena(void) {
90  	unsigned narenas;
91  	size_t old_size, new_size, sz;
92  	size_t hooks_mib[3];
93  	size_t hooks_miblen;
94  	extent_hooks_t *new_hooks, *old_hooks;
95  	extent_hooks_prep();
96  	sz = sizeof(unsigned);
97  	assert_d_eq(mallctl("opt.narenas", (void *)&narenas, &sz, NULL, 0),
98  	    0, "Unexpected mallctl() failure");
99  	if (narenas == 1) {
100  		return;
101  	}
102  	hooks_miblen = sizeof(hooks_mib)/sizeof(size_t);
103  	assert_d_eq(mallctlnametomib("arena.0.extent_hooks", hooks_mib,
104  	    &hooks_miblen), 0, "Unexpected mallctlnametomib() failure");
105  	hooks_mib[1] = 1;
106  	old_size = sizeof(extent_hooks_t *);
107  	new_hooks = &hooks;
108  	new_size = sizeof(extent_hooks_t *);
109  	assert_d_eq(mallctlbymib(hooks_mib, hooks_miblen, (void *)&old_hooks,
110  	    &old_size, (void *)&new_hooks, new_size), 0,
111  	    "Unexpected extent_hooks error");
112  	static bool auto_arena_created = false;
113  	if (old_hooks != &hooks) {
114  		assert_b_eq(auto_arena_created, false,
115  		    "Expected auto arena 1 created only once.");
116  		auto_arena_created = true;
117  	}
118  }
119  static void
120  test_manual_hook_body(void) {
121  	unsigned arena_ind;
122  	size_t old_size, new_size, sz;
123  	size_t hooks_mib[3];
124  	size_t hooks_miblen;
125  	extent_hooks_t *new_hooks, *old_hooks;
126  	extent_hooks_prep();
127  	sz = sizeof(unsigned);
128  	assert_d_eq(mallctl("arenas.create", (void *)&arena_ind, &sz, NULL, 0),
129  	    0, "Unexpected mallctl() failure");
130  	hooks_miblen = sizeof(hooks_mib)/sizeof(size_t);
131  	assert_d_eq(mallctlnametomib("arena.0.extent_hooks", hooks_mib,
132  	    &hooks_miblen), 0, "Unexpected mallctlnametomib() failure");
133  	hooks_mib[1] = (size_t)arena_ind;
134  	old_size = sizeof(extent_hooks_t *);
135  	new_hooks = &hooks;
136  	new_size = sizeof(extent_hooks_t *);
137  	assert_d_eq(mallctlbymib(hooks_mib, hooks_miblen, (void *)&old_hooks,
138  	    &old_size, (void *)&new_hooks, new_size), 0,
139  	    "Unexpected extent_hooks error");
140  	assert_ptr_ne(old_hooks->alloc, extent_alloc_hook,
141  	    "Unexpected extent_hooks error");
142  	assert_ptr_ne(old_hooks->dalloc, extent_dalloc_hook,
143  	    "Unexpected extent_hooks error");
144  	assert_ptr_ne(old_hooks->commit, extent_commit_hook,
145  	    "Unexpected extent_hooks error");
146  	assert_ptr_ne(old_hooks->decommit, extent_decommit_hook,
147  	    "Unexpected extent_hooks error");
148  	assert_ptr_ne(old_hooks->purge_lazy, extent_purge_lazy_hook,
149  	    "Unexpected extent_hooks error");
150  	assert_ptr_ne(old_hooks->purge_forced, extent_purge_forced_hook,
151  	    "Unexpected extent_hooks error");
152  	assert_ptr_ne(old_hooks->split, extent_split_hook,
153  	    "Unexpected extent_hooks error");
154  	assert_ptr_ne(old_hooks->merge, extent_merge_hook,
155  	    "Unexpected extent_hooks error");
156  	if (!check_background_thread_enabled()) {
157  		test_extent_body(arena_ind);
158  	}
159  	assert_d_eq(mallctlbymib(hooks_mib, hooks_miblen, NULL, NULL,
160  	    (void *)&old_hooks, new_size), 0, "Unexpected extent_hooks error");
161  	assert_d_eq(mallctlbymib(hooks_mib, hooks_miblen, (void *)&old_hooks,
162  	    &old_size, NULL, 0), 0, "Unexpected extent_hooks error");
163  	assert_ptr_eq(old_hooks, default_hooks, "Unexpected extent_hooks error");
164  	assert_ptr_eq(old_hooks->alloc, default_hooks->alloc,
165  	    "Unexpected extent_hooks error");
166  	assert_ptr_eq(old_hooks->dalloc, default_hooks->dalloc,
167  	    "Unexpected extent_hooks error");
168  	assert_ptr_eq(old_hooks->commit, default_hooks->commit,
169  	    "Unexpected extent_hooks error");
170  	assert_ptr_eq(old_hooks->decommit, default_hooks->decommit,
171  	    "Unexpected extent_hooks error");
172  	assert_ptr_eq(old_hooks->purge_lazy, default_hooks->purge_lazy,
173  	    "Unexpected extent_hooks error");
174  	assert_ptr_eq(old_hooks->purge_forced, default_hooks->purge_forced,
175  	    "Unexpected extent_hooks error");
176  	assert_ptr_eq(old_hooks->split, default_hooks->split,
177  	    "Unexpected extent_hooks error");
178  	assert_ptr_eq(old_hooks->merge, default_hooks->merge,
179  	    "Unexpected extent_hooks error");
180  }
181  TEST_BEGIN(test_extent_manual_hook) {
182  	test_manual_hook_auto_arena();
183  	test_manual_hook_body();
184  	try_split = false;
185  	test_manual_hook_body();
186  	try_merge = false;
187  	test_manual_hook_body();
188  	try_purge_lazy = false;
189  	try_purge_forced = false;
190  	test_manual_hook_body();
191  	try_split = try_merge = try_purge_lazy = try_purge_forced = true;
192  }
193  TEST_END
194  TEST_BEGIN(test_extent_auto_hook) {
195  	unsigned arena_ind;
196  	size_t new_size, sz;
197  	extent_hooks_t *new_hooks;
198  	extent_hooks_prep();
199  	sz = sizeof(unsigned);
200  	new_hooks = &hooks;
201  	new_size = sizeof(extent_hooks_t *);
202  	assert_d_eq(mallctl("arenas.create", (void *)&arena_ind, &sz,
203  	    (void *)&new_hooks, new_size), 0, "Unexpected mallctl() failure");
204  	test_skip_if(check_background_thread_enabled());
205  	test_extent_body(arena_ind);
206  }
207  TEST_END
208  int
209  main(void) {
210  	return test(
211  	    test_extent_manual_hook,
212  	    test_extent_auto_hook);
213  }
</code></pre>
        </div>
        <div class="column">
            <h3>redis-MDEwOlJlcG9zaXRvcnkxMDgxMTA3MDY=-flat-extent.c</h3>
            <pre><code>1  #include "test/jemalloc_test.h"
2  #include "test/extent_hooks.h"
3  static bool
4  check_background_thread_enabled(void) {
5  	bool enabled;
6  	size_t sz = sizeof(bool);
7  	int ret = mallctl("background_thread", (void *)&enabled, &sz, NULL,0);
8  	if (ret == ENOENT) {
9  		return false;
10  	}
11  	assert_d_eq(ret, 0, "Unexpected mallctl error");
12  	return enabled;
13  }
14  static void
15  test_extent_body(unsigned arena_ind) {
16  	void *p;
17  	size_t large0, large1, large2, sz;
18  	size_t purge_mib[3];
19  	size_t purge_miblen;
20  	int flags;
21  	bool xallocx_success_a, xallocx_success_b, xallocx_success_c;
22  	flags = MALLOCX_ARENA(arena_ind) | MALLOCX_TCACHE_NONE;
23  	sz = sizeof(size_t);
24  	assert_d_eq(mallctl("arenas.lextent.0.size", (void *)&large0, &sz, NULL,
25  	    0), 0, "Unexpected arenas.lextent.0.size failure");
26  	assert_d_eq(mallctl("arenas.lextent.1.size", (void *)&large1, &sz, NULL,
27  	    0), 0, "Unexpected arenas.lextent.1.size failure");
28  	assert_d_eq(mallctl("arenas.lextent.2.size", (void *)&large2, &sz, NULL,
29  	    0), 0, "Unexpected arenas.lextent.2.size failure");
30  	purge_miblen = sizeof(purge_mib)/sizeof(size_t);
31  	assert_d_eq(mallctlnametomib("arena.0.purge", purge_mib, &purge_miblen),
32  	    0, "Unexpected mallctlnametomib() failure");
33  	purge_mib[1] = (size_t)arena_ind;
34  	called_alloc = false;
35  	try_alloc = true;
36  	try_dalloc = false;
37  	try_decommit = false;
38  	p = mallocx(large0 * 2, flags);
39  	assert_ptr_not_null(p, "Unexpected mallocx() error");
40  	assert_true(called_alloc, "Expected alloc call");
41  	called_dalloc = false;
42  	called_decommit = false;
43  	did_purge_lazy = false;
44  	did_purge_forced = false;
45  	called_split = false;
46  	xallocx_success_a = (xallocx(p, large0, 0, flags) == large0);
47  	assert_d_eq(mallctlbymib(purge_mib, purge_miblen, NULL, NULL, NULL, 0),
48  	    0, "Unexpected arena.%u.purge error", arena_ind);
49  	if (xallocx_success_a) {
50  		assert_true(called_dalloc, "Expected dalloc call");
51  		assert_true(called_decommit, "Expected decommit call");
52  		assert_true(did_purge_lazy || did_purge_forced,
53  		    "Expected purge");
54  	}
55  	assert_true(called_split, "Expected split call");
56  	dallocx(p, flags);
57  	try_dalloc = true;
58  	try_dalloc = false;
59  	try_decommit = true;
60  	p = mallocx(large0 * 2, flags);
61  	assert_ptr_not_null(p, "Unexpected mallocx() error");
62  	did_decommit = false;
63  	did_commit = false;
64  	called_split = false;
<span onclick='openModal()' class='match'>65  	did_split = false;
66  	did_merge = false;
67  	xallocx_success_b = (xallocx(p, large0, 0, flags) == large0);
68  	assert_d_eq(mallctlbymib(purge_mib, purge_miblen, NULL, NULL, NULL, 0),
69  	    0, "Unexpected arena.%u.purge error", arena_ind);
70  	if (xallocx_success_b) {
71  		assert_true(did_split, "Expected split");
72  	}
</span>73  	xallocx_success_c = (xallocx(p, large0 * 2, 0, flags) == large0 * 2);
74  	if (did_split) {
75  		assert_b_eq(did_decommit, did_commit,
76  		    "Expected decommit/commit match");
77  	}
78  	if (xallocx_success_b && xallocx_success_c) {
79  		assert_true(did_merge, "Expected merge");
80  	}
81  	dallocx(p, flags);
82  	try_dalloc = true;
83  	try_decommit = false;
84  	p = mallocx(42, flags);
85  	assert_ptr_not_null(p, "Unexpected mallocx() error");
86  	dallocx(p, flags);
87  }
88  static void
89  test_manual_hook_auto_arena(void) {
90  	unsigned narenas;
91  	size_t old_size, new_size, sz;
92  	size_t hooks_mib[3];
93  	size_t hooks_miblen;
94  	extent_hooks_t *new_hooks, *old_hooks;
95  	extent_hooks_prep();
96  	sz = sizeof(unsigned);
97  	assert_d_eq(mallctl("opt.narenas", (void *)&narenas, &sz, NULL, 0),
98  	    0, "Unexpected mallctl() failure");
99  	if (narenas == 1) {
100  		return;
101  	}
102  	hooks_miblen = sizeof(hooks_mib)/sizeof(size_t);
103  	assert_d_eq(mallctlnametomib("arena.0.extent_hooks", hooks_mib,
104  	    &hooks_miblen), 0, "Unexpected mallctlnametomib() failure");
105  	hooks_mib[1] = 1;
106  	old_size = sizeof(extent_hooks_t *);
107  	new_hooks = &hooks;
108  	new_size = sizeof(extent_hooks_t *);
109  	assert_d_eq(mallctlbymib(hooks_mib, hooks_miblen, (void *)&old_hooks,
110  	    &old_size, (void *)&new_hooks, new_size), 0,
111  	    "Unexpected extent_hooks error");
112  	static bool auto_arena_created = false;
113  	if (old_hooks != &hooks) {
114  		assert_b_eq(auto_arena_created, false,
115  		    "Expected auto arena 1 created only once.");
116  		auto_arena_created = true;
117  	}
118  }
119  static void
120  test_manual_hook_body(void) {
121  	unsigned arena_ind;
122  	size_t old_size, new_size, sz;
123  	size_t hooks_mib[3];
124  	size_t hooks_miblen;
125  	extent_hooks_t *new_hooks, *old_hooks;
126  	extent_hooks_prep();
127  	sz = sizeof(unsigned);
128  	assert_d_eq(mallctl("arenas.create", (void *)&arena_ind, &sz, NULL, 0),
129  	    0, "Unexpected mallctl() failure");
130  	hooks_miblen = sizeof(hooks_mib)/sizeof(size_t);
131  	assert_d_eq(mallctlnametomib("arena.0.extent_hooks", hooks_mib,
132  	    &hooks_miblen), 0, "Unexpected mallctlnametomib() failure");
133  	hooks_mib[1] = (size_t)arena_ind;
134  	old_size = sizeof(extent_hooks_t *);
135  	new_hooks = &hooks;
136  	new_size = sizeof(extent_hooks_t *);
137  	assert_d_eq(mallctlbymib(hooks_mib, hooks_miblen, (void *)&old_hooks,
138  	    &old_size, (void *)&new_hooks, new_size), 0,
139  	    "Unexpected extent_hooks error");
140  	assert_ptr_ne(old_hooks->alloc, extent_alloc_hook,
141  	    "Unexpected extent_hooks error");
142  	assert_ptr_ne(old_hooks->dalloc, extent_dalloc_hook,
143  	    "Unexpected extent_hooks error");
144  	assert_ptr_ne(old_hooks->commit, extent_commit_hook,
145  	    "Unexpected extent_hooks error");
146  	assert_ptr_ne(old_hooks->decommit, extent_decommit_hook,
147  	    "Unexpected extent_hooks error");
148  	assert_ptr_ne(old_hooks->purge_lazy, extent_purge_lazy_hook,
149  	    "Unexpected extent_hooks error");
150  	assert_ptr_ne(old_hooks->purge_forced, extent_purge_forced_hook,
151  	    "Unexpected extent_hooks error");
152  	assert_ptr_ne(old_hooks->split, extent_split_hook,
153  	    "Unexpected extent_hooks error");
154  	assert_ptr_ne(old_hooks->merge, extent_merge_hook,
155  	    "Unexpected extent_hooks error");
156  	if (!check_background_thread_enabled()) {
157  		test_extent_body(arena_ind);
158  	}
159  	assert_d_eq(mallctlbymib(hooks_mib, hooks_miblen, NULL, NULL,
160  	    (void *)&old_hooks, new_size), 0, "Unexpected extent_hooks error");
161  	assert_d_eq(mallctlbymib(hooks_mib, hooks_miblen, (void *)&old_hooks,
162  	    &old_size, NULL, 0), 0, "Unexpected extent_hooks error");
163  	assert_ptr_eq(old_hooks, default_hooks, "Unexpected extent_hooks error");
164  	assert_ptr_eq(old_hooks->alloc, default_hooks->alloc,
165  	    "Unexpected extent_hooks error");
166  	assert_ptr_eq(old_hooks->dalloc, default_hooks->dalloc,
167  	    "Unexpected extent_hooks error");
168  	assert_ptr_eq(old_hooks->commit, default_hooks->commit,
169  	    "Unexpected extent_hooks error");
170  	assert_ptr_eq(old_hooks->decommit, default_hooks->decommit,
171  	    "Unexpected extent_hooks error");
172  	assert_ptr_eq(old_hooks->purge_lazy, default_hooks->purge_lazy,
173  	    "Unexpected extent_hooks error");
174  	assert_ptr_eq(old_hooks->purge_forced, default_hooks->purge_forced,
175  	    "Unexpected extent_hooks error");
176  	assert_ptr_eq(old_hooks->split, default_hooks->split,
177  	    "Unexpected extent_hooks error");
178  	assert_ptr_eq(old_hooks->merge, default_hooks->merge,
179  	    "Unexpected extent_hooks error");
180  }
181  TEST_BEGIN(test_extent_manual_hook) {
182  	test_manual_hook_auto_arena();
183  	test_manual_hook_body();
184  	try_split = false;
185  	test_manual_hook_body();
186  	try_merge = false;
187  	test_manual_hook_body();
188  	try_purge_lazy = false;
189  	try_purge_forced = false;
190  	test_manual_hook_body();
191  	try_split = try_merge = try_purge_lazy = try_purge_forced = true;
192  }
193  TEST_END
194  TEST_BEGIN(test_extent_auto_hook) {
195  	unsigned arena_ind;
196  	size_t new_size, sz;
197  	extent_hooks_t *new_hooks;
198  	extent_hooks_prep();
199  	sz = sizeof(unsigned);
200  	new_hooks = &hooks;
201  	new_size = sizeof(extent_hooks_t *);
202  	assert_d_eq(mallctl("arenas.create", (void *)&arena_ind, &sz,
203  	    (void *)&new_hooks, new_size), 0, "Unexpected mallctl() failure");
204  	test_skip_if(check_background_thread_enabled());
205  	test_extent_body(arena_ind);
206  }
207  TEST_END
208  int
209  main(void) {
210  	return test(
211  	    test_extent_manual_hook,
212  	    test_extent_auto_hook);
213  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from redis-MDEwOlJlcG9zaXRvcnkxMDgxMTA3MDY=-flat-extent.c</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from redis-MDEwOlJlcG9zaXRvcnkxMDgxMTA3MDY=-flat-extent.c</div>
                </div>
                <div class="column column_space"><pre><code>65  	did_split = false;
66  	did_merge = false;
67  	xallocx_success_b = (xallocx(p, large0, 0, flags) == large0);
68  	assert_d_eq(mallctlbymib(purge_mib, purge_miblen, NULL, NULL, NULL, 0),
69  	    0, "Unexpected arena.%u.purge error", arena_ind);
70  	if (xallocx_success_b) {
71  		assert_true(did_split, "Expected split");
72  	}
</pre></code></div>
                <div class="column column_space"><pre><code>65  	did_split = false;
66  	did_merge = false;
67  	xallocx_success_b = (xallocx(p, large0, 0, flags) == large0);
68  	assert_d_eq(mallctlbymib(purge_mib, purge_miblen, NULL, NULL, NULL, 0),
69  	    0, "Unexpected arena.%u.purge error", arena_ind);
70  	if (xallocx_success_b) {
71  		assert_true(did_split, "Expected split");
72  	}
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    