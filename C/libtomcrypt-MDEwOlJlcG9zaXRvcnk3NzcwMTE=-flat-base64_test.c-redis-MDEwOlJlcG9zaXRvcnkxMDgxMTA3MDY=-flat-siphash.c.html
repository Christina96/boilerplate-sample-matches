
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 19.96370235934664%, Tokens: 15</h2>
        <div class="column">
            <h3>libtomcrypt-MDEwOlJlcG9zaXRvcnk3NzcwMTE=-flat-base64_test.c</h3>
            <pre><code>1  #include  <tomcrypt_test.h>
2  #if defined(LTC_BASE64) || defined(LTC_BASE64_URL)
3  enum { insane = 0, strict = 1, relaxed = 2, invalid = 666 };
4  int base64_test(void)
5  {
6     unsigned char in[64], tmp[64];
7     char out[256];
8     unsigned long x, l1, l2, slen1;
9     const unsigned char special_case[] = {
10           0xbe, 0xe8, 0x92, 0x3c, 0xa2, 0x25, 0xf0, 0xf8,
11           0x91, 0xe4, 0xef, 0xab, 0x0b, 0x8c, 0xfd, 0xff,
12           0x14, 0xd0, 0x29, 0x9d, 0x00 };
13     const char *As_lf = "QUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFB\nQUFB";
14     const char *As_crlf = "QUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFB\r\nQUFB";
15     const char *As_ssh_lf = "QUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFB\nQUFB";
16     const char *As_ssh_crlf = "QUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFB\r\nQUFB";
17  #if defined(LTC_BASE64)
18     const struct {
19       const char* s;
20       const char* b64;
21     } cases[] = {
<span onclick='openModal()' class='match'>22         {"", ""              },
23         {"f", "Zg=="         },
24         {"fo", "Zm8="        },
25         {"foo", "Zm9v"       },
26         {"foob", "Zm9vYg=="  },
27         {"fooba", "Zm9vYmE=" },
28         {"foobar", "Zm9vYmFy"},
29         {(char*)special_case,"vuiSPKIl8PiR5O+rC4z9/xTQKZ0="}
</span>30     };
31  #endif
32  #ifdef LTC_BASE64_URL
33     const struct {
34        const char* s;
35        int flag;
36     } url_cases[] = {
37           {"vuiSPKIl8PiR5O-rC4z9_xTQKZ0", strict},                       &bsol;* 0 */
38           {"vuiSPKIl8PiR5O-rC4z9_xTQKZ0=", strict},
39           {"vuiS*PKIl8P*iR5O-rC4*z9_xTQKZ0", insane},
40           {"vuiS*PKIl8P*iR5O-rC4*z9_xTQKZ0=", insane},
41           {"vuiS*PKIl8P*iR5O-rC4*z9_xTQKZ0==", insane},
42           {"vuiS*PKIl8P*iR5O-rC4*z9_xTQKZ0===", insane},                 &bsol;* 5 */
43           {"vuiS*PKIl8P*iR5O-rC4*z9_xTQKZ0====", insane},
44           {"vuiS*=PKIl8P*iR5O-rC4*z9_xTQKZ0=", insane},
45           {"vuiS*==PKIl8P*iR5O-rC4*z9_xTQKZ0=", insane},
46           {"vuiS*==\xffPKIl8P*iR5O-rC4*z9_xTQKZ0=", insane},
47           {"vuiS PKIl8P\niR5O-rC4\tz9_xTQKZ0", relaxed},                 &bsol;* 10 */
48           {"vuiS PKIl8P\niR5O-rC4\tz9_xTQKZ0=", relaxed},
49           {"vuiS PKIl8P\niR5O-rC4\tz9_xTQKZ0==", relaxed},
50           {"vuiS PKIl8P\niR5O-rC4\tz9_xTQKZ0===", relaxed},
51           {"vuiS PKIl8P\niR5O-rC4\tz9_xTQKZ0====", relaxed},
52           {"vuiS\rPKIl8P\niR5O-rC4\tz9_xTQKZ0=", relaxed},               &bsol;* 15 */
53           {"vuiS\rPKIl8P\niR5O-rC4\tz9_xTQKZ0= = =\x00", relaxed},
54           {"\nvuiS\rPKIl8P\niR5O-rC4\tz9_xTQKZ0=\n", relaxed},
55           {"vuiSPKIl8PiR5O-rC4z9_xTQK", invalid},
56     };
57     for (x = 0; x < sizeof(url_cases)/sizeof(url_cases[0]); ++x) {
58         slen1 = XSTRLEN(url_cases[x].s);
59         l1 = sizeof(tmp);
60         if(url_cases[x].flag == strict) {
61            DO(base64url_strict_decode(url_cases[x].s, slen1, tmp, &l1));
62            DO(do_compare_testvector(tmp, l1, special_case, sizeof(special_case) - 1, "base64url_strict_decode", x));
63            DO(base64url_sane_decode(url_cases[x].s, slen1, tmp, &l1));
64            DO(do_compare_testvector(tmp, l1, special_case, sizeof(special_case) - 1, "base64url_sane_decode/strict", x));
65            DO(base64url_decode(url_cases[x].s, slen1, tmp, &l1));
66            DO(do_compare_testvector(tmp, l1, special_case, sizeof(special_case) - 1, "base64url_decode/strict", x));
67         }
68         else if(url_cases[x].flag == relaxed) {
69            DO(base64url_strict_decode(url_cases[x].s, slen1, tmp, &l1) == CRYPT_INVALID_PACKET ? CRYPT_OK : CRYPT_FAIL_TESTVECTOR);
70            DO(base64url_sane_decode(url_cases[x].s, slen1, tmp, &l1));
71            DO(do_compare_testvector(tmp, l1, special_case, sizeof(special_case) - 1, "base64url_sane_decode/relaxed", x));
72            DO(base64url_decode(url_cases[x].s, slen1, tmp, &l1));
73            DO(do_compare_testvector(tmp, l1, special_case, sizeof(special_case) - 1, "base64url_decode/relaxed", x));
74         }
75         else if(url_cases[x].flag == insane) {
76            DO(base64url_strict_decode(url_cases[x].s, slen1, tmp, &l1) == CRYPT_INVALID_PACKET ? CRYPT_OK : CRYPT_FAIL_TESTVECTOR);
77            DO(base64url_sane_decode(url_cases[x].s, slen1, tmp, &l1) == CRYPT_INVALID_PACKET ? CRYPT_OK : CRYPT_FAIL_TESTVECTOR);
78            DO(base64url_decode(url_cases[x].s, slen1, tmp, &l1));
79            DO(do_compare_testvector(tmp, l1, special_case, sizeof(special_case) - 1, "base64url_decode/insane", x));
80         }
81         else { &bsol;* invalid */
82            DO(base64url_strict_decode(url_cases[x].s, slen1, tmp, &l1) == CRYPT_INVALID_PACKET ? CRYPT_OK : CRYPT_FAIL_TESTVECTOR);
83            DO(base64url_sane_decode(url_cases[x].s, slen1, tmp, &l1) == CRYPT_INVALID_PACKET ? CRYPT_OK : CRYPT_FAIL_TESTVECTOR);
84            DO(base64url_decode(url_cases[x].s, slen1, tmp, &l1) == CRYPT_INVALID_PACKET ? CRYPT_OK : CRYPT_FAIL_TESTVECTOR);
85         }
86         l2 = sizeof(out);
87         if(x == 0) {
88            DO(base64url_encode(tmp, l1, out, &l2));
89            DO(do_compare_testvector(out, l2, url_cases[x].s, XSTRLEN(url_cases[x].s), "base64url_encode", x));
90         }
91         if(x == 1) {
92            DO(base64url_strict_encode(tmp, l1, out, &l2));
93            DO(do_compare_testvector(out, l2, url_cases[x].s, XSTRLEN(url_cases[x].s), "base64url_strict_encode", x));
94         }
95     }
96  #endif
97  #if defined(LTC_BASE64)
98     for (x = 0; x < sizeof(cases)/sizeof(cases[0]); ++x) {
99         memset(out, 0, sizeof(out));
100         memset(tmp, 0, sizeof(tmp));
101         slen1 = XSTRLEN(cases[x].s);
102         l1 = sizeof(out);
103         DO(base64_encode((unsigned char*)cases[x].s, slen1, out, &l1));
104         DO(do_compare_testvector(out, l1, cases[x].b64, XSTRLEN(cases[x].b64), "base64_encode", x));
105         l2 = sizeof(tmp);
106         DO(base64_strict_decode(out, l1, tmp, &l2));
107         DO(do_compare_testvector(tmp, l2, cases[x].s, slen1, "base64_strict_decode", x));
108         DO(base64_sane_decode(out, l1, tmp, &l2));
109         DO(do_compare_testvector(tmp, l2, cases[x].s, slen1, "base64_sane_decode", x));
110         DO(base64_decode(out, l1, tmp, &l2));
111         DO(do_compare_testvector(tmp, l2, cases[x].s, slen1, "base64_decode", x));
112     }
113     for  (x = 0; x < 64; x++) {
114         ENSURE(yarrow_read(in, x, &yarrow_prng) == x);
115         l1 = sizeof(out);
116         DO(base64_encode(in, x, out, &l1));
117         l2 = sizeof(tmp);
118         DO(base64_decode(out, l1, tmp, &l2));
119         DO(do_compare_testvector(tmp, x, in, x, "random base64", x));
120     }
121     x--;
122     memmove(&out[11], &out[10], l1 - 10);
123     l1++;
124     l2 = sizeof(tmp);
125     out[10] = 0;
126     DO(base64_decode(out, l1, tmp, &l2));
127     DO(compare_testvector(tmp, l2, in, l2, "insane base64 decoding (NUL)", 0));
128     DO(base64_sane_decode(out, l1, tmp, &l2) == CRYPT_INVALID_PACKET ? CRYPT_OK : CRYPT_INVALID_PACKET);
129     DO(base64_strict_decode(out, l1, tmp, &l2) == CRYPT_INVALID_PACKET ? CRYPT_OK : CRYPT_INVALID_PACKET);
130     out[10] = 9; &bsol;* tab */
131     DO(base64_decode(out, l1, tmp, &l2));
132     DO(compare_testvector(tmp, l2, in, l2, "insane base64 decoding (TAB)", 0));
133     DO(base64_sane_decode(out, l1, tmp, &l2));
134     DO(compare_testvector(tmp, l2, in, l2, "relaxed base64 decoding (TAB)", 0));
135     DO(base64_strict_decode(out, l1, tmp, &l2) == CRYPT_INVALID_PACKET ? CRYPT_OK : CRYPT_INVALID_PACKET);
136     memset(in, 'A', sizeof(in));
137     l1 = strlen(As_lf);
138     SHOULD_FAIL(base64_encode_pem(in, 51, out, &l1, 0));
139     l1++;
140     DO(base64_encode_pem(in, 51, out, &l1, 0));
141     DO(compare_testvector(out, l1, As_lf, strlen(As_lf), "PEM output with \\n", 0));
142     l1 = strlen(As_crlf) + 1;
143     DO(base64_encode_pem(in, 51, out, &l1, BASE64_PEM_CRLF));
144     DO(compare_testvector(out, l1, As_crlf, strlen(As_crlf), "PEM output with \\r\\n", 0));
145     l1 = strlen(As_ssh_lf) + 1;
146     DO(base64_encode_pem(in, 57, out, &l1, BASE64_PEM_SSH));
147     DO(compare_testvector(out, l1, As_ssh_lf, strlen(As_ssh_lf), "PEM SSH-style output with \\n", 0));
148     l1 = strlen(As_ssh_crlf) + 1;
149     DO(base64_encode_pem(in, 57, out, &l1, BASE64_PEM_SSH | BASE64_PEM_CRLF));
150     DO(compare_testvector(out, l1, As_ssh_crlf, strlen(As_ssh_crlf), "PEM SSH-style output with \\r\\n", 0));
151  #endif
152     return 0;
153  }
154  #endif
</code></pre>
        </div>
        <div class="column">
            <h3>redis-MDEwOlJlcG9zaXRvcnkxMDgxMTA3MDY=-flat-siphash.c</h3>
            <pre><code>1  #include <assert.h>
2  #include <stdint.h>
3  #include <stdio.h>
4  #include <string.h>
5  #include <ctype.h>
6  int siptlw(int c) {
7      if (c >= 'A' && c <= 'Z') {
8          return c+('a'-'A');
9      } else {
10          return c;
11      }
12  }
13  #if defined(__X86_64__) || defined(__x86_64__) || defined (__i386__)
14  #define UNALIGNED_LE_CPU
15  #endif
16  #define ROTL(x, b) (uint64_t)(((x) << (b)) | ((x) >> (64 - (b))))
17  #define U32TO8_LE(p, v)                                                        \
18      (p)[0] = (uint8_t)((v));                                                   \
19      (p)[1] = (uint8_t)((v) >> 8);                                              \
20      (p)[2] = (uint8_t)((v) >> 16);                                             \
21      (p)[3] = (uint8_t)((v) >> 24);
22  #define U64TO8_LE(p, v)                                                        \
23      U32TO8_LE((p), (uint32_t)((v)));                                           \
24      U32TO8_LE((p) + 4, (uint32_t)((v) >> 32));
25  #ifdef UNALIGNED_LE_CPU
26  #define U8TO64_LE(p) (*((uint64_t*)(p)))
27  #else
28  #define U8TO64_LE(p)                                                           \
29      (((uint64_t)((p)[0])) | ((uint64_t)((p)[1]) << 8) |                        \
30       ((uint64_t)((p)[2]) << 16) | ((uint64_t)((p)[3]) << 24) |                 \
31       ((uint64_t)((p)[4]) << 32) | ((uint64_t)((p)[5]) << 40) |                 \
32       ((uint64_t)((p)[6]) << 48) | ((uint64_t)((p)[7]) << 56))
33  #endif
34  #define U8TO64_LE_NOCASE(p)                                                    \
35      (((uint64_t)(siptlw((p)[0]))) |                                           \
36       ((uint64_t)(siptlw((p)[1])) << 8) |                                      \
37       ((uint64_t)(siptlw((p)[2])) << 16) |                                     \
38       ((uint64_t)(siptlw((p)[3])) << 24) |                                     \
39       ((uint64_t)(siptlw((p)[4])) << 32) |                                              \
40       ((uint64_t)(siptlw((p)[5])) << 40) |                                              \
41       ((uint64_t)(siptlw((p)[6])) << 48) |                                              \
42       ((uint64_t)(siptlw((p)[7])) << 56))
43  #define SIPROUND                                                               \
44      do {                                                                       \
45          v0 += v1;                                                              \
46          v1 = ROTL(v1, 13);                                                     \
47          v1 ^= v0;                                                              \
48          v0 = ROTL(v0, 32);                                                     \
49          v2 += v3;                                                              \
50          v3 = ROTL(v3, 16);                                                     \
51          v3 ^= v2;                                                              \
52          v0 += v3;                                                              \
53          v3 = ROTL(v3, 21);                                                     \
54          v3 ^= v0;                                                              \
55          v2 += v1;                                                              \
56          v1 = ROTL(v1, 17);                                                     \
57          v1 ^= v2;                                                              \
58          v2 = ROTL(v2, 32);                                                     \
59      } while (0)
60  uint64_t siphash(const uint8_t *in, const size_t inlen, const uint8_t *k) {
61  #ifndef UNALIGNED_LE_CPU
62      uint64_t hash;
63      uint8_t *out = (uint8_t*) &hash;
64  #endif
65      uint64_t v0 = 0x736f6d6570736575ULL;
66      uint64_t v1 = 0x646f72616e646f6dULL;
67      uint64_t v2 = 0x6c7967656e657261ULL;
68      uint64_t v3 = 0x7465646279746573ULL;
69      uint64_t k0 = U8TO64_LE(k);
70      uint64_t k1 = U8TO64_LE(k + 8);
71      uint64_t m;
72      const uint8_t *end = in + inlen - (inlen % sizeof(uint64_t));
73      const int left = inlen & 7;
74      uint64_t b = ((uint64_t)inlen) << 56;
75      v3 ^= k1;
76      v2 ^= k0;
77      v1 ^= k1;
78      v0 ^= k0;
79      for (; in != end; in += 8) {
80          m = U8TO64_LE(in);
81          v3 ^= m;
82          SIPROUND;
83          v0 ^= m;
84      }
85      switch (left) {
86      case 7: b |= ((uint64_t)in[6]) << 48; &bsol;* fall-thru */
87      case 6: b |= ((uint64_t)in[5]) << 40; &bsol;* fall-thru */
88      case 5: b |= ((uint64_t)in[4]) << 32; &bsol;* fall-thru */
89      case 4: b |= ((uint64_t)in[3]) << 24; &bsol;* fall-thru */
90      case 3: b |= ((uint64_t)in[2]) << 16; &bsol;* fall-thru */
91      case 2: b |= ((uint64_t)in[1]) << 8; &bsol;* fall-thru */
92      case 1: b |= ((uint64_t)in[0]); break;
93      case 0: break;
94      }
95      v3 ^= b;
96      SIPROUND;
97      v0 ^= b;
98      v2 ^= 0xff;
99      SIPROUND;
100      SIPROUND;
101      b = v0 ^ v1 ^ v2 ^ v3;
102  #ifndef UNALIGNED_LE_CPU
103      U64TO8_LE(out, b);
104      return hash;
105  #else
106      return b;
107  #endif
108  }
109  uint64_t siphash_nocase(const uint8_t *in, const size_t inlen, const uint8_t *k)
110  {
111  #ifndef UNALIGNED_LE_CPU
112      uint64_t hash;
113      uint8_t *out = (uint8_t*) &hash;
114  #endif
115      uint64_t v0 = 0x736f6d6570736575ULL;
116      uint64_t v1 = 0x646f72616e646f6dULL;
117      uint64_t v2 = 0x6c7967656e657261ULL;
118      uint64_t v3 = 0x7465646279746573ULL;
119      uint64_t k0 = U8TO64_LE(k);
120      uint64_t k1 = U8TO64_LE(k + 8);
121      uint64_t m;
122      const uint8_t *end = in + inlen - (inlen % sizeof(uint64_t));
123      const int left = inlen & 7;
124      uint64_t b = ((uint64_t)inlen) << 56;
125      v3 ^= k1;
126      v2 ^= k0;
127      v1 ^= k1;
128      v0 ^= k0;
129      for (; in != end; in += 8) {
130          m = U8TO64_LE_NOCASE(in);
131          v3 ^= m;
132          SIPROUND;
133          v0 ^= m;
134      }
135      switch (left) {
136      case 7: b |= ((uint64_t)siptlw(in[6])) << 48; &bsol;* fall-thru */
137      case 6: b |= ((uint64_t)siptlw(in[5])) << 40; &bsol;* fall-thru */
138      case 5: b |= ((uint64_t)siptlw(in[4])) << 32; &bsol;* fall-thru */
139      case 4: b |= ((uint64_t)siptlw(in[3])) << 24; &bsol;* fall-thru */
140      case 3: b |= ((uint64_t)siptlw(in[2])) << 16; &bsol;* fall-thru */
141      case 2: b |= ((uint64_t)siptlw(in[1])) << 8; &bsol;* fall-thru */
142      case 1: b |= ((uint64_t)siptlw(in[0])); break;
143      case 0: break;
144      }
145      v3 ^= b;
146      SIPROUND;
147      v0 ^= b;
148      v2 ^= 0xff;
149      SIPROUND;
150      SIPROUND;
151      b = v0 ^ v1 ^ v2 ^ v3;
152  #ifndef UNALIGNED_LE_CPU
153      U64TO8_LE(out, b);
154      return hash;
155  #else
156      return b;
157  #endif
158  }
159  #ifdef SIPHASH_TEST
160  const uint8_t vectors_sip64[64][8] = {
161      { 0x31, 0x0e, 0x0e, 0xdd, 0x47, 0xdb, 0x6f, 0x72, },
162      { 0xfd, 0x67, 0xdc, 0x93, 0xc5, 0x39, 0xf8, 0x74, },
163      { 0x5a, 0x4f, 0xa9, 0xd9, 0x09, 0x80, 0x6c, 0x0d, },
164      { 0x2d, 0x7e, 0xfb, 0xd7, 0x96, 0x66, 0x67, 0x85, },
165      { 0xb7, 0x87, 0x71, 0x27, 0xe0, 0x94, 0x27, 0xcf, },
166      { 0x8d, 0xa6, 0x99, 0xcd, 0x64, 0x55, 0x76, 0x18, },
167      { 0xce, 0xe3, 0xfe, 0x58, 0x6e, 0x46, 0xc9, 0xcb, },
168      { 0x37, 0xd1, 0x01, 0x8b, 0xf5, 0x00, 0x02, 0xab, },
169      { 0x62, 0x24, 0x93, 0x9a, 0x79, 0xf5, 0xf5, 0x93, },
170      { 0xb0, 0xe4, 0xa9, 0x0b, 0xdf, 0x82, 0x00, 0x9e, },
171      { 0xf3, 0xb9, 0xdd, 0x94, 0xc5, 0xbb, 0x5d, 0x7a, },
172      { 0xa7, 0xad, 0x6b, 0x22, 0x46, 0x2f, 0xb3, 0xf4, },
173      { 0xfb, 0xe5, 0x0e, 0x86, 0xbc, 0x8f, 0x1e, 0x75, },
174      { 0x90, 0x3d, 0x84, 0xc0, 0x27, 0x56, 0xea, 0x14, },
175      { 0xee, 0xf2, 0x7a, 0x8e, 0x90, 0xca, 0x23, 0xf7, },
176      { 0xe5, 0x45, 0xbe, 0x49, 0x61, 0xca, 0x29, 0xa1, },
177      { 0xdb, 0x9b, 0xc2, 0x57, 0x7f, 0xcc, 0x2a, 0x3f, },
178      { 0x94, 0x47, 0xbe, 0x2c, 0xf5, 0xe9, 0x9a, 0x69, },
179      { 0x9c, 0xd3, 0x8d, 0x96, 0xf0, 0xb3, 0xc1, 0x4b, },
<span onclick='openModal()' class='match'>180      { 0xbd, 0x61, 0x79, 0xa7, 0x1d, 0xc9, 0x6d, 0xbb, },
181      { 0x98, 0xee, 0xa2, 0x1a, 0xf2, 0x5c, 0xd6, 0xbe, },
182      { 0xc7, 0x67, 0x3b, 0x2e, 0xb0, 0xcb, 0xf2, 0xd0, },
183      { 0x88, 0x3e, 0xa3, 0xe3, 0x95, 0x67, 0x53, 0x93, },
184      { 0xc8, 0xce, 0x5c, 0xcd, 0x8c, 0x03, 0x0c, 0xa8, },
185      { 0x94, 0xaf, 0x49, 0xf6, 0xc6, 0x50, 0xad, 0xb8, },
186      { 0xea, 0xb8, 0x85, 0x8a, 0xde, 0x92, 0xe1, 0xbc, },
187      { 0xf3, 0x15, 0xbb, 0x5b, 0xb8, 0x35, 0xd8, 0x17, },
</span>188      { 0xad, 0xcf, 0x6b, 0x07, 0x63, 0x61, 0x2e, 0x2f, },
189      { 0xa5, 0xc9, 0x1d, 0xa7, 0xac, 0xaa, 0x4d, 0xde, },
190      { 0x71, 0x65, 0x95, 0x87, 0x66, 0x50, 0xa2, 0xa6, },
191      { 0x28, 0xef, 0x49, 0x5c, 0x53, 0xa3, 0x87, 0xad, },
192      { 0x42, 0xc3, 0x41, 0xd8, 0xfa, 0x92, 0xd8, 0x32, },
193      { 0xce, 0x7c, 0xf2, 0x72, 0x2f, 0x51, 0x27, 0x71, },
194      { 0xe3, 0x78, 0x59, 0xf9, 0x46, 0x23, 0xf3, 0xa7, },
195      { 0x38, 0x12, 0x05, 0xbb, 0x1a, 0xb0, 0xe0, 0x12, },
196      { 0xae, 0x97, 0xa1, 0x0f, 0xd4, 0x34, 0xe0, 0x15, },
197      { 0xb4, 0xa3, 0x15, 0x08, 0xbe, 0xff, 0x4d, 0x31, },
198      { 0x81, 0x39, 0x62, 0x29, 0xf0, 0x90, 0x79, 0x02, },
199      { 0x4d, 0x0c, 0xf4, 0x9e, 0xe5, 0xd4, 0xdc, 0xca, },
200      { 0x5c, 0x73, 0x33, 0x6a, 0x76, 0xd8, 0xbf, 0x9a, },
201      { 0xd0, 0xa7, 0x04, 0x53, 0x6b, 0xa9, 0x3e, 0x0e, },
202      { 0x92, 0x59, 0x58, 0xfc, 0xd6, 0x42, 0x0c, 0xad, },
203      { 0xa9, 0x15, 0xc2, 0x9b, 0xc8, 0x06, 0x73, 0x18, },
204      { 0x95, 0x2b, 0x79, 0xf3, 0xbc, 0x0a, 0xa6, 0xd4, },
205      { 0xf2, 0x1d, 0xf2, 0xe4, 0x1d, 0x45, 0x35, 0xf9, },
206      { 0x87, 0x57, 0x75, 0x19, 0x04, 0x8f, 0x53, 0xa9, },
207      { 0x10, 0xa5, 0x6c, 0xf5, 0xdf, 0xcd, 0x9a, 0xdb, },
208      { 0xeb, 0x75, 0x09, 0x5c, 0xcd, 0x98, 0x6c, 0xd0, },
209      { 0x51, 0xa9, 0xcb, 0x9e, 0xcb, 0xa3, 0x12, 0xe6, },
210      { 0x96, 0xaf, 0xad, 0xfc, 0x2c, 0xe6, 0x66, 0xc7, },
211      { 0x72, 0xfe, 0x52, 0x97, 0x5a, 0x43, 0x64, 0xee, },
212      { 0x5a, 0x16, 0x45, 0xb2, 0x76, 0xd5, 0x92, 0xa1, },
213      { 0xb2, 0x74, 0xcb, 0x8e, 0xbf, 0x87, 0x87, 0x0a, },
214      { 0x6f, 0x9b, 0xb4, 0x20, 0x3d, 0xe7, 0xb3, 0x81, },
215      { 0xea, 0xec, 0xb2, 0xa3, 0x0b, 0x22, 0xa8, 0x7f, },
216      { 0x99, 0x24, 0xa4, 0x3c, 0xc1, 0x31, 0x57, 0x24, },
217      { 0xbd, 0x83, 0x8d, 0x3a, 0xaf, 0xbf, 0x8d, 0xb7, },
218      { 0x0b, 0x1a, 0x2a, 0x32, 0x65, 0xd5, 0x1a, 0xea, },
219      { 0x13, 0x50, 0x79, 0xa3, 0x23, 0x1c, 0xe6, 0x60, },
220      { 0x93, 0x2b, 0x28, 0x46, 0xe4, 0xd7, 0x06, 0x66, },
221      { 0xe1, 0x91, 0x5f, 0x5c, 0xb1, 0xec, 0xa4, 0x6c, },
222      { 0xf3, 0x25, 0x96, 0x5c, 0xa1, 0x6d, 0x62, 0x9f, },
223      { 0x57, 0x5f, 0xf2, 0x8e, 0x60, 0x38, 0x1b, 0xe5, },
224      { 0x72, 0x45, 0x06, 0xeb, 0x4c, 0x32, 0x8a, 0x95, },
225  };
226  int siphash_test(void) {
227      uint8_t in[64], k[16];
228      int i;
229      int fails = 0;
230      for (i = 0; i < 16; ++i)
231          k[i] = i;
232      for (i = 0; i < 64; ++i) {
233          in[i] = i;
234          uint64_t hash = siphash(in, i, k);
235          const uint8_t *v = NULL;
236          v = (uint8_t *)vectors_sip64;
237          if (memcmp(&hash, v + (i * 8), 8)) {
238              fails++;
239          }
240      }
241      uint64_t h1, h2;
242      h1 = siphash((uint8_t*)"hello world",11,(uint8_t*)"1234567812345678");
243      h2 = siphash_nocase((uint8_t*)"hello world",11,(uint8_t*)"1234567812345678");
244      if (h1 != h2) fails++;
245      h1 = siphash((uint8_t*)"hello world",11,(uint8_t*)"1234567812345678");
246      h2 = siphash_nocase((uint8_t*)"HELLO world",11,(uint8_t*)"1234567812345678");
247      if (h1 != h2) fails++;
248      h1 = siphash((uint8_t*)"HELLO world",11,(uint8_t*)"1234567812345678");
249      h2 = siphash_nocase((uint8_t*)"HELLO world",11,(uint8_t*)"1234567812345678");
250      if (h1 == h2) fails++;
251      if (!fails) return 0;
252      return 1;
253  }
254  int main(void) {
255      if (siphash_test() == 0) {
256          printf("SipHash test: OK\n");
257          return 0;
258      } else {
259          printf("SipHash test: FAILED\n");
260          return 1;
261      }
262  }
263  #endif
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from libtomcrypt-MDEwOlJlcG9zaXRvcnk3NzcwMTE=-flat-base64_test.c</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from redis-MDEwOlJlcG9zaXRvcnkxMDgxMTA3MDY=-flat-siphash.c</div>
                </div>
                <div class="column column_space"><pre><code>22         {"", ""              },
23         {"f", "Zg=="         },
24         {"fo", "Zm8="        },
25         {"foo", "Zm9v"       },
26         {"foob", "Zm9vYg=="  },
27         {"fooba", "Zm9vYmE=" },
28         {"foobar", "Zm9vYmFy"},
29         {(char*)special_case,"vuiSPKIl8PiR5O+rC4z9/xTQKZ0="}
</pre></code></div>
                <div class="column column_space"><pre><code>180      { 0xbd, 0x61, 0x79, 0xa7, 0x1d, 0xc9, 0x6d, 0xbb, },
181      { 0x98, 0xee, 0xa2, 0x1a, 0xf2, 0x5c, 0xd6, 0xbe, },
182      { 0xc7, 0x67, 0x3b, 0x2e, 0xb0, 0xcb, 0xf2, 0xd0, },
183      { 0x88, 0x3e, 0xa3, 0xe3, 0x95, 0x67, 0x53, 0x93, },
184      { 0xc8, 0xce, 0x5c, 0xcd, 0x8c, 0x03, 0x0c, 0xa8, },
185      { 0x94, 0xaf, 0x49, 0xf6, 0xc6, 0x50, 0xad, 0xb8, },
186      { 0xea, 0xb8, 0x85, 0x8a, 0xde, 0x92, 0xe1, 0xbc, },
187      { 0xf3, 0x15, 0xbb, 0x5b, 0xb8, 0x35, 0xd8, 0x17, },
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    