
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 8.238636363636363%, Tokens: 11</h2>
        <div class="column">
            <h3>libtomcrypt-MDEwOlJlcG9zaXRvcnk3NzcwMTE=-flat-yarrow.c</h3>
            <pre><code>1  #include "tomcrypt_private.h"
2  #ifdef LTC_YARROW
3  const struct ltc_prng_descriptor yarrow_desc =
4  {
5      "yarrow", 64,
6      &yarrow_start,
7      &yarrow_add_entropy,
8      &yarrow_ready,
9      &yarrow_read,
10      &yarrow_done,
11      &yarrow_export,
12      &yarrow_import,
13      &yarrow_test
14  };
15  int yarrow_start(prng_state *prng)
16  {
17     int err;
18     LTC_ARGCHK(prng != NULL);
19     prng->ready = 0;
20  #ifdef LTC_RIJNDAEL
21  #if    LTC_YARROW_AES==0
22     prng->u.yarrow.cipher = register_cipher(&rijndael_enc_desc);
23  #elif  LTC_YARROW_AES==1
24     prng->u.yarrow.cipher = register_cipher(&aes_enc_desc);
25  #elif  LTC_YARROW_AES==2
26     prng->u.yarrow.cipher = register_cipher(&rijndael_desc);
27  #elif  LTC_YARROW_AES==3
28     prng->u.yarrow.cipher = register_cipher(&aes_desc);
29  #endif
30  #elif defined(LTC_BLOWFISH)
31     prng->u.yarrow.cipher = register_cipher(&blowfish_desc);
32  #elif defined(LTC_TWOFISH)
33     prng->u.yarrow.cipher = register_cipher(&twofish_desc);
34  #elif defined(LTC_RC6)
35     prng->u.yarrow.cipher = register_cipher(&rc6_desc);
36  #elif defined(LTC_RC5)
37     prng->u.yarrow.cipher = register_cipher(&rc5_desc);
38  #elif defined(LTC_SAFERP)
39     prng->u.yarrow.cipher = register_cipher(&saferp_desc);
40  #elif defined(LTC_RC2)
41     prng->u.yarrow.cipher = register_cipher(&rc2_desc);
42  #elif defined(LTC_NOEKEON)
43     prng->u.yarrow.cipher = register_cipher(&noekeon_desc);
44  #elif defined(LTC_ANUBIS)
45     prng->u.yarrow.cipher = register_cipher(&anubis_desc);
46  #elif defined(LTC_KSEED)
47     prng->u.yarrow.cipher = register_cipher(&kseed_desc);
48  #elif defined(LTC_KHAZAD)
49     prng->u.yarrow.cipher = register_cipher(&khazad_desc);
50  #elif defined(LTC_CAST5)
51     prng->u.yarrow.cipher = register_cipher(&cast5_desc);
52  #elif defined(LTC_XTEA)
53     prng->u.yarrow.cipher = register_cipher(&xtea_desc);
54  #elif defined(LTC_SAFER)
55     prng->u.yarrow.cipher = register_cipher(&safer_sk128_desc);
56  #elif defined(LTC_DES)
57     prng->u.yarrow.cipher = register_cipher(&des3_desc);
58  #else
59     #error LTC_YARROW needs at least one CIPHER
60  #endif
61     if ((err = cipher_is_valid(prng->u.yarrow.cipher)) != CRYPT_OK) {
62        return err;
63     }
64  #ifdef LTC_SHA256
<span onclick='openModal()' class='match'>65     prng->u.yarrow.hash   = register_hash(&sha256_desc);
66  #elif defined(LTC_SHA512)
67     prng->u.yarrow.hash   = register_hash(&sha512_desc);
68  #elif defined(LTC_TIGER)
69     prng->u.yarrow.hash   = register_hash(&tiger_desc);
70  #elif defined(LTC_SHA1)
71     prng->u.yarrow.hash   = register_hash(&sha1_desc);
72  #elif defined(LTC_RIPEMD320)
73     prng->u.yarrow.hash   = register_hash(&rmd320_desc);
74  #elif defined(LTC_RIPEMD256)
75     prng->u.yarrow.hash   = register_hash(&rmd256_desc);
76  #elif defined(LTC_RIPEMD160)
77     prng->u.yarrow.hash   = register_hash(&rmd160_desc);
78  #elif defined(LTC_RIPEMD128)
79     prng->u.yarrow.hash   = register_hash(&rmd128_desc);
80  #elif defined(LTC_MD5)
81     prng->u.yarrow.hash   = register_hash(&md5_desc);
82  #elif defined(LTC_MD4)
83     prng->u.yarrow.hash   = register_hash(&md4_desc);
84  #elif defined(LTC_MD2)
85     prng->u.yarrow.hash   = register_hash(&md2_desc);
</span>86  #elif defined(LTC_WHIRLPOOL)
87     prng->u.yarrow.hash   = register_hash(&whirlpool_desc);
88  #else
89     #error LTC_YARROW needs at least one HASH
90  #endif
91     if ((err = hash_is_valid(prng->u.yarrow.hash)) != CRYPT_OK) {
92        return err;
93     }
94     zeromem(prng->u.yarrow.pool, sizeof(prng->u.yarrow.pool));
95     LTC_MUTEX_INIT(&prng->lock)
96     return CRYPT_OK;
97  }
98  int yarrow_add_entropy(const unsigned char *in, unsigned long inlen, prng_state *prng)
99  {
100     hash_state md;
101     int err;
102     LTC_ARGCHK(prng != NULL);
103     LTC_ARGCHK(in != NULL);
104     LTC_ARGCHK(inlen > 0);
105     LTC_MUTEX_LOCK(&prng->lock);
106     if ((err = hash_is_valid(prng->u.yarrow.hash)) != CRYPT_OK) {
107        goto LBL_UNLOCK;
108     }
109     if ((err = hash_descriptor[prng->u.yarrow.hash].init(&md)) != CRYPT_OK) {
110        goto LBL_UNLOCK;
111     }
112     if ((err = hash_descriptor[prng->u.yarrow.hash].process(&md, prng->u.yarrow.pool,
113                                                          hash_descriptor[prng->u.yarrow.hash].hashsize)) != CRYPT_OK) {
114        goto LBL_UNLOCK;
115     }
116     if ((err = hash_descriptor[prng->u.yarrow.hash].process(&md, in, inlen)) != CRYPT_OK) {
117        goto LBL_UNLOCK;
118     }
119     err = hash_descriptor[prng->u.yarrow.hash].done(&md, prng->u.yarrow.pool);
120  LBL_UNLOCK:
121     LTC_MUTEX_UNLOCK(&prng->lock);
122     return err;
123  }
124  int yarrow_ready(prng_state *prng)
125  {
126     int ks, err;
127     LTC_ARGCHK(prng != NULL);
128     LTC_MUTEX_LOCK(&prng->lock);
129     if ((err = hash_is_valid(prng->u.yarrow.hash)) != CRYPT_OK) {
130        goto LBL_UNLOCK;
131     }
132     if ((err = cipher_is_valid(prng->u.yarrow.cipher)) != CRYPT_OK) {
133        goto LBL_UNLOCK;
134     }
135     ks = (int)hash_descriptor[prng->u.yarrow.hash].hashsize;
136     if ((err = cipher_descriptor[prng->u.yarrow.cipher].keysize(&ks)) != CRYPT_OK) {
137        goto LBL_UNLOCK;
138     }
139     if ((err = ctr_start(prng->u.yarrow.cipher,     &bsol;* what cipher to use */
140                          prng->u.yarrow.pool,       &bsol;* IV */
141                          prng->u.yarrow.pool, ks,   &bsol;* KEY and key size */
142                          0,                       &bsol;* number of rounds */
143                          CTR_COUNTER_LITTLE_ENDIAN, &bsol;* little endian counter */
144                          &prng->u.yarrow.ctr)) != CRYPT_OK) {
145        goto LBL_UNLOCK;
146     }
147     prng->ready = 1;
148  LBL_UNLOCK:
149     LTC_MUTEX_UNLOCK(&prng->lock);
150     return err;
151  }
152  unsigned long yarrow_read(unsigned char *out, unsigned long outlen, prng_state *prng)
153  {
154     if (outlen == 0 || prng == NULL || out == NULL) return 0;
155     LTC_MUTEX_LOCK(&prng->lock);
156     if (!prng->ready) {
157        outlen = 0;
158        goto LBL_UNLOCK;
159     }
160     zeromem(out, outlen);
161     if (ctr_encrypt(out, out, outlen, &prng->u.yarrow.ctr) != CRYPT_OK) {
162        outlen = 0;
163     }
164  LBL_UNLOCK:
165     LTC_MUTEX_UNLOCK(&prng->lock);
166     return outlen;
167  }
168  int yarrow_done(prng_state *prng)
169  {
170     int err;
171     LTC_ARGCHK(prng != NULL);
172     LTC_MUTEX_LOCK(&prng->lock);
173     prng->ready = 0;
174     err = ctr_done(&prng->u.yarrow.ctr);
175     LTC_MUTEX_UNLOCK(&prng->lock);
176     LTC_MUTEX_DESTROY(&prng->lock);
177     return err;
178  }
179  LTC_PRNG_EXPORT(yarrow)
180  int yarrow_import(const unsigned char *in, unsigned long inlen, prng_state *prng)
181  {
182     int err;
183     LTC_ARGCHK(in   != NULL);
184     LTC_ARGCHK(prng != NULL);
185     if (inlen < (unsigned long)yarrow_desc.export_size) return CRYPT_INVALID_ARG;
186     if ((err = yarrow_start(prng)) != CRYPT_OK)                  return err;
187     if ((err = yarrow_add_entropy(in, inlen, prng)) != CRYPT_OK) return err;
188     return CRYPT_OK;
189  }
190  int yarrow_test(void)
191  {
192  #ifndef LTC_TEST
193     return CRYPT_NOP;
194  #else
195     int err;
196     prng_state prng;
197     if ((err = yarrow_start(&prng)) != CRYPT_OK) {
198        return err;
199     }
200     if (cipher_descriptor[prng.u.yarrow.cipher].test &&
201         ((err = cipher_descriptor[prng.u.yarrow.cipher].test()) != CRYPT_OK)) {
202        return err;
203     }
204     if (hash_descriptor[prng.u.yarrow.hash].test &&
205         ((err = hash_descriptor[prng.u.yarrow.hash].test()) != CRYPT_OK)) {
206        return err;
207     }
208     return CRYPT_OK;
209  #endif
210  }
211  #endif
</code></pre>
        </div>
        <div class="column">
            <h3>PINRemoteImage-MDEwOlJlcG9zaXRvcnkzOTUzNzEwMw==-flat-iterator_enc.c</h3>
            <pre><code>1  #include <string.h>
2  #include "src/enc/vp8i_enc.h"
3  static void InitLeft(VP8EncIterator* const it) {
4    it->y_left_[-1] = it->u_left_[-1] = it->v_left_[-1] =
5        (it->y_ > 0) ? 129 : 127;
6    memset(it->y_left_, 129, 16);
7    memset(it->u_left_, 129, 8);
8    memset(it->v_left_, 129, 8);
9    it->left_nz_[8] = 0;
10    if (it->top_derr_ != NULL) {
11      memset(&it->left_derr_, 0, sizeof(it->left_derr_));
12    }
13  }
14  static void InitTop(VP8EncIterator* const it) {
15    const VP8Encoder* const enc = it->enc_;
16    const size_t top_size = enc->mb_w_ * 16;
17    memset(enc->y_top_, 127, 2 * top_size);
18    memset(enc->nz_, 0, enc->mb_w_ * sizeof(*enc->nz_));
19    if (enc->top_derr_ != NULL) {
20      memset(enc->top_derr_, 0, enc->mb_w_ * sizeof(*enc->top_derr_));
21    }
22  }
23  void VP8IteratorSetRow(VP8EncIterator* const it, int y) {
24    VP8Encoder* const enc = it->enc_;
25    it->x_ = 0;
26    it->y_ = y;
27    it->bw_ = &enc->parts_[y & (enc->num_parts_ - 1)];
28    it->preds_ = enc->preds_ + y * 4 * enc->preds_w_;
29    it->nz_ = enc->nz_;
30    it->mb_ = enc->mb_info_ + y * enc->mb_w_;
31    it->y_top_ = enc->y_top_;
32    it->uv_top_ = enc->uv_top_;
33    InitLeft(it);
34  }
35  void VP8IteratorReset(VP8EncIterator* const it) {
36    VP8Encoder* const enc = it->enc_;
37    VP8IteratorSetRow(it, 0);
38    VP8IteratorSetCountDown(it, enc->mb_w_ * enc->mb_h_);  
39    InitTop(it);
40    memset(it->bit_count_, 0, sizeof(it->bit_count_));
41    it->do_trellis_ = 0;
42  }
43  void VP8IteratorSetCountDown(VP8EncIterator* const it, int count_down) {
44    it->count_down_ = it->count_down0_ = count_down;
45  }
46  int VP8IteratorIsDone(const VP8EncIterator* const it) {
47    return (it->count_down_ <= 0);
48  }
49  void VP8IteratorInit(VP8Encoder* const enc, VP8EncIterator* const it) {
<span onclick='openModal()' class='match'>50    it->enc_ = enc;
51    it->yuv_in_   = (uint8_t*)WEBP_ALIGN(it->yuv_mem_);
52    it->yuv_out_  = it->yuv_in_ + YUV_SIZE_ENC;
53    it->yuv_out2_ = it->yuv_out_ + YUV_SIZE_ENC;
54    it->yuv_p_    = it->yuv_out2_ + YUV_SIZE_ENC;
55    it->lf_stats_ = enc->lf_stats_;
56    it->percent0_ = enc->percent_;
57    it->y_left_ = (uint8_t*)WEBP_ALIGN(it->yuv_left_mem_ + 1);
58    it->u_left_ = it->y_left_ + 16 + 16;
59    it->v_left_ = it->u_left_ + 16;
60    it->top_derr_ = enc->top_derr_;
</span>61    VP8IteratorReset(it);
62  }
63  int VP8IteratorProgress(const VP8EncIterator* const it, int delta) {
64    VP8Encoder* const enc = it->enc_;
65    if (delta && enc->pic_->progress_hook != NULL) {
66      const int done = it->count_down0_ - it->count_down_;
67      const int percent = (it->count_down0_ <= 0)
68                        ? it->percent0_
69                        : it->percent0_ + delta * done / it->count_down0_;
70      return WebPReportProgress(enc->pic_, percent, &enc->percent_);
71    }
72    return 1;
73  }
74  static WEBP_INLINE int MinSize(int a, int b) { return (a < b) ? a : b; }
75  static void ImportBlock(const uint8_t* src, int src_stride,
76                          uint8_t* dst, int w, int h, int size) {
77    int i;
78    for (i = 0; i < h; ++i) {
79      memcpy(dst, src, w);
80      if (w < size) {
81        memset(dst + w, dst[w - 1], size - w);
82      }
83      dst += BPS;
84      src += src_stride;
85    }
86    for (i = h; i < size; ++i) {
87      memcpy(dst, dst - BPS, size);
88      dst += BPS;
89    }
90  }
91  static void ImportLine(const uint8_t* src, int src_stride,
92                         uint8_t* dst, int len, int total_len) {
93    int i;
94    for (i = 0; i < len; ++i, src += src_stride) dst[i] = *src;
95    for (; i < total_len; ++i) dst[i] = dst[len - 1];
96  }
97  void VP8IteratorImport(VP8EncIterator* const it, uint8_t* const tmp_32) {
98    const VP8Encoder* const enc = it->enc_;
99    const int x = it->x_, y = it->y_;
100    const WebPPicture* const pic = enc->pic_;
101    const uint8_t* const ysrc = pic->y + (y * pic->y_stride  + x) * 16;
102    const uint8_t* const usrc = pic->u + (y * pic->uv_stride + x) * 8;
103    const uint8_t* const vsrc = pic->v + (y * pic->uv_stride + x) * 8;
104    const int w = MinSize(pic->width - x * 16, 16);
105    const int h = MinSize(pic->height - y * 16, 16);
106    const int uv_w = (w + 1) >> 1;
107    const int uv_h = (h + 1) >> 1;
108    ImportBlock(ysrc, pic->y_stride,  it->yuv_in_ + Y_OFF_ENC, w, h, 16);
109    ImportBlock(usrc, pic->uv_stride, it->yuv_in_ + U_OFF_ENC, uv_w, uv_h, 8);
110    ImportBlock(vsrc, pic->uv_stride, it->yuv_in_ + V_OFF_ENC, uv_w, uv_h, 8);
111    if (tmp_32 == NULL) return;
112    if (x == 0) {
113      InitLeft(it);
114    } else {
115      if (y == 0) {
116        it->y_left_[-1] = it->u_left_[-1] = it->v_left_[-1] = 127;
117      } else {
118        it->y_left_[-1] = ysrc[- 1 - pic->y_stride];
119        it->u_left_[-1] = usrc[- 1 - pic->uv_stride];
120        it->v_left_[-1] = vsrc[- 1 - pic->uv_stride];
121      }
122      ImportLine(ysrc - 1, pic->y_stride,  it->y_left_, h,   16);
123      ImportLine(usrc - 1, pic->uv_stride, it->u_left_, uv_h, 8);
124      ImportLine(vsrc - 1, pic->uv_stride, it->v_left_, uv_h, 8);
125    }
126    it->y_top_  = tmp_32 + 0;
127    it->uv_top_ = tmp_32 + 16;
128    if (y == 0) {
129      memset(tmp_32, 127, 32 * sizeof(*tmp_32));
130    } else {
131      ImportLine(ysrc - pic->y_stride,  1, tmp_32,          w,   16);
132      ImportLine(usrc - pic->uv_stride, 1, tmp_32 + 16,     uv_w, 8);
133      ImportLine(vsrc - pic->uv_stride, 1, tmp_32 + 16 + 8, uv_w, 8);
134    }
135  }
136  static void ExportBlock(const uint8_t* src, uint8_t* dst, int dst_stride,
137                          int w, int h) {
138    while (h-- > 0) {
139      memcpy(dst, src, w);
140      dst += dst_stride;
141      src += BPS;
142    }
143  }
144  void VP8IteratorExport(const VP8EncIterator* const it) {
145    const VP8Encoder* const enc = it->enc_;
146    if (enc->config_->show_compressed) {
147      const int x = it->x_, y = it->y_;
148      const uint8_t* const ysrc = it->yuv_out_ + Y_OFF_ENC;
149      const uint8_t* const usrc = it->yuv_out_ + U_OFF_ENC;
150      const uint8_t* const vsrc = it->yuv_out_ + V_OFF_ENC;
151      const WebPPicture* const pic = enc->pic_;
152      uint8_t* const ydst = pic->y + (y * pic->y_stride + x) * 16;
153      uint8_t* const udst = pic->u + (y * pic->uv_stride + x) * 8;
154      uint8_t* const vdst = pic->v + (y * pic->uv_stride + x) * 8;
155      int w = (pic->width - x * 16);
156      int h = (pic->height - y * 16);
157      if (w > 16) w = 16;
158      if (h > 16) h = 16;
159      ExportBlock(ysrc, ydst, pic->y_stride, w, h);
160      {   
161        const int uv_w = (w + 1) >> 1;
162        const int uv_h = (h + 1) >> 1;
163        ExportBlock(usrc, udst, pic->uv_stride, uv_w, uv_h);
164        ExportBlock(vsrc, vdst, pic->uv_stride, uv_w, uv_h);
165      }
166    }
167  }
168  #define BIT(nz, n) (!!((nz) & (1 << (n))))
169  void VP8IteratorNzToBytes(VP8EncIterator* const it) {
170    const int tnz = it->nz_[0], lnz = it->nz_[-1];
171    int* const top_nz = it->top_nz_;
172    int* const left_nz = it->left_nz_;
173    top_nz[0] = BIT(tnz, 12);
174    top_nz[1] = BIT(tnz, 13);
175    top_nz[2] = BIT(tnz, 14);
176    top_nz[3] = BIT(tnz, 15);
177    top_nz[4] = BIT(tnz, 18);
178    top_nz[5] = BIT(tnz, 19);
179    top_nz[6] = BIT(tnz, 22);
180    top_nz[7] = BIT(tnz, 23);
181    top_nz[8] = BIT(tnz, 24);
182    left_nz[0] = BIT(lnz,  3);
183    left_nz[1] = BIT(lnz,  7);
184    left_nz[2] = BIT(lnz, 11);
185    left_nz[3] = BIT(lnz, 15);
186    left_nz[4] = BIT(lnz, 17);
187    left_nz[5] = BIT(lnz, 19);
188    left_nz[6] = BIT(lnz, 21);
189    left_nz[7] = BIT(lnz, 23);
190  }
191  void VP8IteratorBytesToNz(VP8EncIterator* const it) {
192    uint32_t nz = 0;
193    const int* const top_nz = it->top_nz_;
194    const int* const left_nz = it->left_nz_;
195    nz |= (top_nz[0] << 12) | (top_nz[1] << 13);
196    nz |= (top_nz[2] << 14) | (top_nz[3] << 15);
197    nz |= (top_nz[4] << 18) | (top_nz[5] << 19);
198    nz |= (top_nz[6] << 22) | (top_nz[7] << 23);
199    nz |= (top_nz[8] << 24);  
200    nz |= (left_nz[0] << 3) | (left_nz[1] << 7);
201    nz |= (left_nz[2] << 11);
202    nz |= (left_nz[4] << 17) | (left_nz[6] << 21);
203    *it->nz_ = nz;
204  }
205  #undef BIT
206  void VP8IteratorSaveBoundary(VP8EncIterator* const it) {
207    VP8Encoder* const enc = it->enc_;
208    const int x = it->x_, y = it->y_;
209    const uint8_t* const ysrc = it->yuv_out_ + Y_OFF_ENC;
210    const uint8_t* const uvsrc = it->yuv_out_ + U_OFF_ENC;
211    if (x < enc->mb_w_ - 1) {   
212      int i;
213      for (i = 0; i < 16; ++i) {
214        it->y_left_[i] = ysrc[15 + i * BPS];
215      }
216      for (i = 0; i < 8; ++i) {
217        it->u_left_[i] = uvsrc[7 + i * BPS];
218        it->v_left_[i] = uvsrc[15 + i * BPS];
219      }
220      it->y_left_[-1] = it->y_top_[15];
221      it->u_left_[-1] = it->uv_top_[0 + 7];
222      it->v_left_[-1] = it->uv_top_[8 + 7];
223    }
224    if (y < enc->mb_h_ - 1) {  
225      memcpy(it->y_top_, ysrc + 15 * BPS, 16);
226      memcpy(it->uv_top_, uvsrc + 7 * BPS, 8 + 8);
227    }
228  }
229  int VP8IteratorNext(VP8EncIterator* const it) {
230    if (++it->x_ == it->enc_->mb_w_) {
231      VP8IteratorSetRow(it, ++it->y_);
232    } else {
233      it->preds_ += 4;
234      it->mb_ += 1;
235      it->nz_ += 1;
236      it->y_top_ += 16;
237      it->uv_top_ += 16;
238    }
239    return (0 < --it->count_down_);
240  }
241  void VP8SetIntra16Mode(const VP8EncIterator* const it, int mode) {
242    uint8_t* preds = it->preds_;
243    int y;
244    for (y = 0; y < 4; ++y) {
245      memset(preds, mode, 4);
246      preds += it->enc_->preds_w_;
247    }
248    it->mb_->type_ = 1;
249  }
250  void VP8SetIntra4Mode(const VP8EncIterator* const it, const uint8_t* modes) {
251    uint8_t* preds = it->preds_;
252    int y;
253    for (y = 4; y > 0; --y) {
254      memcpy(preds, modes, 4 * sizeof(*modes));
255      preds += it->enc_->preds_w_;
256      modes += 4;
257    }
258    it->mb_->type_ = 0;
259  }
260  void VP8SetIntraUVMode(const VP8EncIterator* const it, int mode) {
261    it->mb_->uv_mode_ = mode;
262  }
263  void VP8SetSkip(const VP8EncIterator* const it, int skip) {
264    it->mb_->skip_ = skip;
265  }
266  void VP8SetSegment(const VP8EncIterator* const it, int segment) {
267    it->mb_->segment_ = segment;
268  }
269  static const uint8_t VP8TopLeftI4[16] = {
270    17, 21, 25, 29,
271    13, 17, 21, 25,
272    9,  13, 17, 21,
273    5,   9, 13, 17
274  };
275  void VP8IteratorStartI4(VP8EncIterator* const it) {
276    const VP8Encoder* const enc = it->enc_;
277    int i;
278    it->i4_ = 0;    
279    it->i4_top_ = it->i4_boundary_ + VP8TopLeftI4[0];
280    for (i = 0; i < 17; ++i) {    
281      it->i4_boundary_[i] = it->y_left_[15 - i];
282    }
283    for (i = 0; i < 16; ++i) {    
284      it->i4_boundary_[17 + i] = it->y_top_[i];
285    }
286    if (it->x_ < enc->mb_w_ - 1) {
287      for (i = 16; i < 16 + 4; ++i) {
288        it->i4_boundary_[17 + i] = it->y_top_[i];
289      }
290    } else {    
291      for (i = 16; i < 16 + 4; ++i) {
292        it->i4_boundary_[17 + i] = it->i4_boundary_[17 + 15];
293      }
294    }
295    VP8IteratorNzToBytes(it);  
296  }
297  int VP8IteratorRotateI4(VP8EncIterator* const it,
298                          const uint8_t* const yuv_out) {
299    const uint8_t* const blk = yuv_out + VP8Scan[it->i4_];
300    uint8_t* const top = it->i4_top_;
301    int i;
302    for (i = 0; i <= 3; ++i) {
303      top[-4 + i] = blk[i + 3 * BPS];   
304    }
305    if ((it->i4_ & 3) != 3) {  
306      for (i = 0; i <= 2; ++i) {        
307        top[i] = blk[3 + (2 - i) * BPS];
308      }
309    } else {  
310      for (i = 0; i <= 3; ++i) {
311        top[i] = top[i + 4];
312      }
313    }
314    ++it->i4_;
315    if (it->i4_ == 16) {    
316      return 0;
317    }
318    it->i4_top_ = it->i4_boundary_ + VP8TopLeftI4[it->i4_];
319    return 1;
320  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from libtomcrypt-MDEwOlJlcG9zaXRvcnk3NzcwMTE=-flat-yarrow.c</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from PINRemoteImage-MDEwOlJlcG9zaXRvcnkzOTUzNzEwMw==-flat-iterator_enc.c</div>
                </div>
                <div class="column column_space"><pre><code>65     prng->u.yarrow.hash   = register_hash(&sha256_desc);
66  #elif defined(LTC_SHA512)
67     prng->u.yarrow.hash   = register_hash(&sha512_desc);
68  #elif defined(LTC_TIGER)
69     prng->u.yarrow.hash   = register_hash(&tiger_desc);
70  #elif defined(LTC_SHA1)
71     prng->u.yarrow.hash   = register_hash(&sha1_desc);
72  #elif defined(LTC_RIPEMD320)
73     prng->u.yarrow.hash   = register_hash(&rmd320_desc);
74  #elif defined(LTC_RIPEMD256)
75     prng->u.yarrow.hash   = register_hash(&rmd256_desc);
76  #elif defined(LTC_RIPEMD160)
77     prng->u.yarrow.hash   = register_hash(&rmd160_desc);
78  #elif defined(LTC_RIPEMD128)
79     prng->u.yarrow.hash   = register_hash(&rmd128_desc);
80  #elif defined(LTC_MD5)
81     prng->u.yarrow.hash   = register_hash(&md5_desc);
82  #elif defined(LTC_MD4)
83     prng->u.yarrow.hash   = register_hash(&md4_desc);
84  #elif defined(LTC_MD2)
85     prng->u.yarrow.hash   = register_hash(&md2_desc);
</pre></code></div>
                <div class="column column_space"><pre><code>50    it->enc_ = enc;
51    it->yuv_in_   = (uint8_t*)WEBP_ALIGN(it->yuv_mem_);
52    it->yuv_out_  = it->yuv_in_ + YUV_SIZE_ENC;
53    it->yuv_out2_ = it->yuv_out_ + YUV_SIZE_ENC;
54    it->yuv_p_    = it->yuv_out2_ + YUV_SIZE_ENC;
55    it->lf_stats_ = enc->lf_stats_;
56    it->percent0_ = enc->percent_;
57    it->y_left_ = (uint8_t*)WEBP_ALIGN(it->yuv_left_mem_ + 1);
58    it->u_left_ = it->y_left_ + 16 + 16;
59    it->v_left_ = it->u_left_ + 16;
60    it->top_derr_ = enc->top_derr_;
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    