
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 102, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>redis-MDEwOlJlcG9zaXRvcnkxMDgxMTA3MDY=-flat-hook.c</h3>
            <pre><code>1  #include "test/jemalloc_test.h"
2  #include "jemalloc/internal/hook.h"
3  static void *arg_extra;
4  static int arg_type;
5  static void *arg_result;
6  static void *arg_address;
7  static size_t arg_old_usize;
8  static size_t arg_new_usize;
9  static uintptr_t arg_result_raw;
10  static uintptr_t arg_args_raw[4];
11  static int call_count = 0;
12  static void
13  reset_args() {
14  	arg_extra = NULL;
15  	arg_type = 12345;
16  	arg_result = NULL;
17  	arg_address = NULL;
18  	arg_old_usize = 0;
19  	arg_new_usize = 0;
20  	arg_result_raw = 0;
21  	memset(arg_args_raw, 77, sizeof(arg_args_raw));
22  }
23  static void
24  alloc_free_size(size_t sz) {
25  	void *ptr = mallocx(1, 0);
26  	free(ptr);
27  	ptr = mallocx(1, 0);
28  	free(ptr);
29  	ptr = mallocx(1, MALLOCX_TCACHE_NONE);
30  	dallocx(ptr, MALLOCX_TCACHE_NONE);
31  }
32  static void
33  be_reentrant() {
34  	alloc_free_size(1);
35  	alloc_free_size(1024);
36  	alloc_free_size(64 * 1024);
37  	alloc_free_size(256 * 1024);
38  	alloc_free_size(1024 * 1024);
39  	void *ptr = mallocx(129, 0);
40  	ptr = rallocx(ptr, 130, 0);
41  	free(ptr);
42  	ptr = mallocx(2 * 1024 * 1024, 0);
43  	free(ptr);
44  	ptr = mallocx(1 * 1024 * 1024, 0);
45  	ptr = rallocx(ptr, 2 * 1024 * 1024, 0);
46  	free(ptr);
47  	ptr = mallocx(1, 0);
48  	ptr = rallocx(ptr, 1000, 0);
49  	free(ptr);
50  }
51  static void
52  set_args_raw(uintptr_t *args_raw, int nargs) {
53  	memcpy(arg_args_raw, args_raw, sizeof(uintptr_t) * nargs);
54  }
55  static void
56  assert_args_raw(uintptr_t *args_raw_expected, int nargs) {
57  	int cmp = memcmp(args_raw_expected, arg_args_raw,
58  	    sizeof(uintptr_t) * nargs);
59  	assert_d_eq(cmp, 0, "Raw args mismatch");
60  }
61  static void
62  reset() {
63  	call_count = 0;
64  	reset_args();
65  }
66  static void
67  test_alloc_hook(void *extra, hook_alloc_t type, void *result,
68      uintptr_t result_raw, uintptr_t args_raw[3]) {
69  	call_count++;
70  	arg_extra = extra;
71  	arg_type = (int)type;
72  	arg_result = result;
73  	arg_result_raw = result_raw;
74  	set_args_raw(args_raw, 3);
75  	be_reentrant();
76  }
77  static void
78  test_dalloc_hook(void *extra, hook_dalloc_t type, void *address,
79      uintptr_t args_raw[3]) {
80  	call_count++;
81  	arg_extra = extra;
82  	arg_type = (int)type;
83  	arg_address = address;
84  	set_args_raw(args_raw, 3);
85  	be_reentrant();
86  }
87  static void
88  test_expand_hook(void *extra, hook_expand_t type, void *address,
89      size_t old_usize, size_t new_usize, uintptr_t result_raw,
90      uintptr_t args_raw[4]) {
91  	call_count++;
92  	arg_extra = extra;
93  	arg_type = (int)type;
94  	arg_address = address;
95  	arg_old_usize = old_usize;
96  	arg_new_usize = new_usize;
97  	arg_result_raw = result_raw;
98  	set_args_raw(args_raw, 4);
99  	be_reentrant();
100  }
101  TEST_BEGIN(test_hooks_basic) {
102  	hooks_t hooks = {
103  		&test_alloc_hook, &test_dalloc_hook, &test_expand_hook,
104  		(void *)111};
105  	void *handle = hook_install(TSDN_NULL, &hooks);
106  	uintptr_t args_raw[4] = {10, 20, 30, 40};
107  	reset_args();
108  	hook_invoke_alloc(hook_alloc_posix_memalign, (void *)222, 333,
109  	    args_raw);
110  	assert_ptr_eq(arg_extra, (void *)111, "Passed wrong user pointer");
111  	assert_d_eq((int)hook_alloc_posix_memalign, arg_type,
112  	    "Passed wrong alloc type");
113  	assert_ptr_eq((void *)222, arg_result, "Passed wrong result address");
114  	assert_u64_eq(333, arg_result_raw, "Passed wrong result");
115  	assert_args_raw(args_raw, 3);
116  	reset_args();
117  	hook_invoke_dalloc(hook_dalloc_sdallocx, (void *)222, args_raw);
118  	assert_d_eq((int)hook_dalloc_sdallocx, arg_type,
119  	    "Passed wrong dalloc type");
120  	assert_ptr_eq((void *)111, arg_extra, "Passed wrong user pointer");
121  	assert_ptr_eq((void *)222, arg_address, "Passed wrong address");
122  	assert_args_raw(args_raw, 3);
123  	reset_args();
124  	hook_invoke_expand(hook_expand_xallocx, (void *)222, 333, 444, 555,
125  	    args_raw);
126  	assert_d_eq((int)hook_expand_xallocx, arg_type,
127  	    "Passed wrong expand type");
128  	assert_ptr_eq((void *)111, arg_extra, "Passed wrong user pointer");
129  	assert_ptr_eq((void *)222, arg_address, "Passed wrong address");
130  	assert_zu_eq(333, arg_old_usize, "Passed wrong old usize");
131  	assert_zu_eq(444, arg_new_usize, "Passed wrong new usize");
132  	assert_zu_eq(555, arg_result_raw, "Passed wrong result");
133  	assert_args_raw(args_raw, 4);
134  	hook_remove(TSDN_NULL, handle);
135  }
136  TEST_END
137  TEST_BEGIN(test_hooks_null) {
138  	hooks_t hooks1 = {NULL, NULL, NULL, NULL};
139  	hooks_t hooks2 = {&test_alloc_hook, NULL, NULL, NULL};
140  	hooks_t hooks3 = {NULL, &test_dalloc_hook, NULL, NULL};
141  	hooks_t hooks4 = {NULL, NULL, &test_expand_hook, NULL};
142  	void *handle1 = hook_install(TSDN_NULL, &hooks1);
143  	void *handle2 = hook_install(TSDN_NULL, &hooks2);
144  	void *handle3 = hook_install(TSDN_NULL, &hooks3);
145  	void *handle4 = hook_install(TSDN_NULL, &hooks4);
146  	assert_ptr_ne(handle1, NULL, "Hook installation failed");
147  	assert_ptr_ne(handle2, NULL, "Hook installation failed");
148  	assert_ptr_ne(handle3, NULL, "Hook installation failed");
149  	assert_ptr_ne(handle4, NULL, "Hook installation failed");
150  	uintptr_t args_raw[4] = {10, 20, 30, 40};
151  	call_count = 0;
152  	hook_invoke_alloc(hook_alloc_malloc, NULL, 0, args_raw);
153  	assert_d_eq(call_count, 1, "Called wrong number of times");
154  	call_count = 0;
155  	hook_invoke_dalloc(hook_dalloc_free, NULL, args_raw);
156  	assert_d_eq(call_count, 1, "Called wrong number of times");
157  	call_count = 0;
158  	hook_invoke_expand(hook_expand_realloc, NULL, 0, 0, 0, args_raw);
159  	assert_d_eq(call_count, 1, "Called wrong number of times");
160  	hook_remove(TSDN_NULL, handle1);
161  	hook_remove(TSDN_NULL, handle2);
162  	hook_remove(TSDN_NULL, handle3);
163  	hook_remove(TSDN_NULL, handle4);
164  }
165  TEST_END
166  TEST_BEGIN(test_hooks_remove) {
167  	hooks_t hooks = {&test_alloc_hook, NULL, NULL, NULL};
168  	void *handle = hook_install(TSDN_NULL, &hooks);
169  	assert_ptr_ne(handle, NULL, "Hook installation failed");
170  	call_count = 0;
171  	uintptr_t args_raw[4] = {10, 20, 30, 40};
172  	hook_invoke_alloc(hook_alloc_malloc, NULL, 0, args_raw);
173  	assert_d_eq(call_count, 1, "Hook not invoked");
174  	call_count = 0;
175  	hook_remove(TSDN_NULL, handle);
176  	hook_invoke_alloc(hook_alloc_malloc, NULL, 0, NULL);
177  	assert_d_eq(call_count, 0, "Hook invoked after removal");
178  }
179  TEST_END
180  TEST_BEGIN(test_hooks_alloc_simple) {
181  	hooks_t hooks = {&test_alloc_hook, NULL, NULL, (void *)123};
182  	void *handle = hook_install(TSDN_NULL, &hooks);
183  	assert_ptr_ne(handle, NULL, "Hook installation failed");
184  	volatile int err;
185  	void *volatile ptr;
186  	reset();
187  	ptr = malloc(1);
188  	assert_d_eq(call_count, 1, "Hook not called");
189  	assert_ptr_eq(arg_extra, (void *)123, "Wrong extra");
190  	assert_d_eq(arg_type, (int)hook_alloc_malloc, "Wrong hook type");
191  	assert_ptr_eq(ptr, arg_result, "Wrong result");
192  	assert_u64_eq((uintptr_t)ptr, (uintptr_t)arg_result_raw,
193  	    "Wrong raw result");
194  	assert_u64_eq((uintptr_t)1, arg_args_raw[0], "Wrong argument");
195  	free(ptr);
196  	reset();
197  	err = posix_memalign((void **)&ptr, 1024, 1);
198  	assert_d_eq(call_count, 1, "Hook not called");
199  	assert_ptr_eq(arg_extra, (void *)123, "Wrong extra");
200  	assert_d_eq(arg_type, (int)hook_alloc_posix_memalign,
201  	    "Wrong hook type");
202  	assert_ptr_eq(ptr, arg_result, "Wrong result");
203  	assert_u64_eq((uintptr_t)err, (uintptr_t)arg_result_raw,
204  	    "Wrong raw result");
205  	assert_u64_eq((uintptr_t)&ptr, arg_args_raw[0], "Wrong argument");
206  	assert_u64_eq((uintptr_t)1024, arg_args_raw[1], "Wrong argument");
207  	assert_u64_eq((uintptr_t)1, arg_args_raw[2], "Wrong argument");
208  	free(ptr);
209  	reset();
<span onclick='openModal()' class='match'>210  	ptr = aligned_alloc(1024, 1);
211  	assert_d_eq(call_count, 1, "Hook not called");
212  	assert_ptr_eq(arg_extra, (void *)123, "Wrong extra");
213  	assert_d_eq(arg_type, (int)hook_alloc_aligned_alloc,
214  	    "Wrong hook type");
215  	assert_ptr_eq(ptr, arg_result, "Wrong result");
216  	assert_u64_eq((uintptr_t)ptr, (uintptr_t)arg_result_raw,
217  	    "Wrong raw result");
218  	assert_u64_eq((uintptr_t)1024, arg_args_raw[0], "Wrong argument");
219  	assert_u64_eq((uintptr_t)1, arg_args_raw[1], "Wrong argument");
220  	free(ptr);
221  	reset();
</span>222  	ptr = calloc(11, 13);
223  	assert_d_eq(call_count, 1, "Hook not called");
224  	assert_ptr_eq(arg_extra, (void *)123, "Wrong extra");
225  	assert_d_eq(arg_type, (int)hook_alloc_calloc, "Wrong hook type");
226  	assert_ptr_eq(ptr, arg_result, "Wrong result");
227  	assert_u64_eq((uintptr_t)ptr, (uintptr_t)arg_result_raw,
228  	    "Wrong raw result");
229  	assert_u64_eq((uintptr_t)11, arg_args_raw[0], "Wrong argument");
230  	assert_u64_eq((uintptr_t)13, arg_args_raw[1], "Wrong argument");
231  	free(ptr);
232  #ifdef JEMALLOC_OVERRIDE_MEMALIGN
233  	reset();
234  	ptr = memalign(1024, 1);
235  	assert_d_eq(call_count, 1, "Hook not called");
236  	assert_ptr_eq(arg_extra, (void *)123, "Wrong extra");
237  	assert_d_eq(arg_type, (int)hook_alloc_memalign, "Wrong hook type");
238  	assert_ptr_eq(ptr, arg_result, "Wrong result");
239  	assert_u64_eq((uintptr_t)ptr, (uintptr_t)arg_result_raw,
240  	    "Wrong raw result");
241  	assert_u64_eq((uintptr_t)1024, arg_args_raw[0], "Wrong argument");
242  	assert_u64_eq((uintptr_t)1, arg_args_raw[1], "Wrong argument");
243  	free(ptr);
244  #endif &bsol;* JEMALLOC_OVERRIDE_MEMALIGN */
245  #ifdef JEMALLOC_OVERRIDE_VALLOC
246  	reset();
247  	ptr = valloc(1);
248  	assert_d_eq(call_count, 1, "Hook not called");
249  	assert_ptr_eq(arg_extra, (void *)123, "Wrong extra");
250  	assert_d_eq(arg_type, (int)hook_alloc_valloc, "Wrong hook type");
251  	assert_ptr_eq(ptr, arg_result, "Wrong result");
252  	assert_u64_eq((uintptr_t)ptr, (uintptr_t)arg_result_raw,
253  	    "Wrong raw result");
254  	assert_u64_eq((uintptr_t)1, arg_args_raw[0], "Wrong argument");
255  	free(ptr);
256  #endif &bsol;* JEMALLOC_OVERRIDE_VALLOC */
257  	reset();
258  	ptr = mallocx(1, MALLOCX_LG_ALIGN(10));
259  	assert_d_eq(call_count, 1, "Hook not called");
260  	assert_ptr_eq(arg_extra, (void *)123, "Wrong extra");
261  	assert_d_eq(arg_type, (int)hook_alloc_mallocx, "Wrong hook type");
262  	assert_ptr_eq(ptr, arg_result, "Wrong result");
263  	assert_u64_eq((uintptr_t)ptr, (uintptr_t)arg_result_raw,
264  	    "Wrong raw result");
265  	assert_u64_eq((uintptr_t)1, arg_args_raw[0], "Wrong argument");
266  	assert_u64_eq((uintptr_t)MALLOCX_LG_ALIGN(10), arg_args_raw[1],
267  	    "Wrong flags");
268  	free(ptr);
269  	hook_remove(TSDN_NULL, handle);
270  }
271  TEST_END
272  TEST_BEGIN(test_hooks_dalloc_simple) {
273  	hooks_t hooks = {NULL, &test_dalloc_hook, NULL, (void *)123};
274  	void *handle = hook_install(TSDN_NULL, &hooks);
275  	assert_ptr_ne(handle, NULL, "Hook installation failed");
276  	void *volatile ptr;
277  	reset();
278  	ptr = malloc(1);
279  	free(ptr);
280  	assert_d_eq(call_count, 1, "Hook not called");
281  	assert_ptr_eq(arg_extra, (void *)123, "Wrong extra");
282  	assert_d_eq(arg_type, (int)hook_dalloc_free, "Wrong hook type");
283  	assert_ptr_eq(ptr, arg_address, "Wrong pointer freed");
284  	assert_u64_eq((uintptr_t)ptr, arg_args_raw[0], "Wrong raw arg");
285  	reset();
286  	ptr = malloc(1);
287  	dallocx(ptr, MALLOCX_TCACHE_NONE);
288  	assert_d_eq(call_count, 1, "Hook not called");
289  	assert_ptr_eq(arg_extra, (void *)123, "Wrong extra");
290  	assert_d_eq(arg_type, (int)hook_dalloc_dallocx, "Wrong hook type");
291  	assert_ptr_eq(ptr, arg_address, "Wrong pointer freed");
292  	assert_u64_eq((uintptr_t)ptr, arg_args_raw[0], "Wrong raw arg");
293  	assert_u64_eq((uintptr_t)MALLOCX_TCACHE_NONE, arg_args_raw[1],
294  	    "Wrong raw arg");
295  	reset();
296  	ptr = malloc(1);
297  	sdallocx(ptr, 1, MALLOCX_TCACHE_NONE);
298  	assert_d_eq(call_count, 1, "Hook not called");
299  	assert_ptr_eq(arg_extra, (void *)123, "Wrong extra");
300  	assert_d_eq(arg_type, (int)hook_dalloc_sdallocx, "Wrong hook type");
301  	assert_ptr_eq(ptr, arg_address, "Wrong pointer freed");
302  	assert_u64_eq((uintptr_t)ptr, arg_args_raw[0], "Wrong raw arg");
303  	assert_u64_eq((uintptr_t)1, arg_args_raw[1], "Wrong raw arg");
304  	assert_u64_eq((uintptr_t)MALLOCX_TCACHE_NONE, arg_args_raw[2],
305  	    "Wrong raw arg");
306  	hook_remove(TSDN_NULL, handle);
307  }
308  TEST_END
309  TEST_BEGIN(test_hooks_expand_simple) {
310  	hooks_t hooks = {NULL, NULL, &test_expand_hook, (void *)123};
311  	void *handle = hook_install(TSDN_NULL, &hooks);
312  	assert_ptr_ne(handle, NULL, "Hook installation failed");
313  	void *volatile ptr;
314  	reset();
315  	ptr = malloc(1);
316  	size_t new_usize = xallocx(ptr, 100, 200, MALLOCX_TCACHE_NONE);
317  	assert_d_eq(call_count, 1, "Hook not called");
318  	assert_ptr_eq(arg_extra, (void *)123, "Wrong extra");
319  	assert_d_eq(arg_type, (int)hook_expand_xallocx, "Wrong hook type");
320  	assert_ptr_eq(ptr, arg_address, "Wrong pointer expanded");
321  	assert_u64_eq(arg_old_usize, nallocx(1, 0), "Wrong old usize");
322  	assert_u64_eq(arg_new_usize, sallocx(ptr, 0), "Wrong new usize");
323  	assert_u64_eq(new_usize, arg_result_raw, "Wrong result");
324  	assert_u64_eq((uintptr_t)ptr, arg_args_raw[0], "Wrong arg");
325  	assert_u64_eq(100, arg_args_raw[1], "Wrong arg");
326  	assert_u64_eq(200, arg_args_raw[2], "Wrong arg");
327  	assert_u64_eq(MALLOCX_TCACHE_NONE, arg_args_raw[3], "Wrong arg");
328  	hook_remove(TSDN_NULL, handle);
329  }
330  TEST_END
331  TEST_BEGIN(test_hooks_realloc_as_malloc_or_free) {
332  	hooks_t hooks = {&test_alloc_hook, &test_dalloc_hook,
333  		&test_expand_hook, (void *)123};
334  	void *handle = hook_install(TSDN_NULL, &hooks);
335  	assert_ptr_ne(handle, NULL, "Hook installation failed");
336  	void *volatile ptr;
337  	reset();
338  	ptr = realloc(NULL, 1);
339  	assert_d_eq(call_count, 1, "Hook not called");
340  	assert_ptr_eq(arg_extra, (void *)123, "Wrong extra");
341  	assert_d_eq(arg_type, (int)hook_alloc_realloc, "Wrong hook type");
342  	assert_ptr_eq(ptr, arg_result, "Wrong result");
343  	assert_u64_eq((uintptr_t)ptr, (uintptr_t)arg_result_raw,
344  	    "Wrong raw result");
345  	assert_u64_eq((uintptr_t)NULL, arg_args_raw[0], "Wrong argument");
346  	assert_u64_eq((uintptr_t)1, arg_args_raw[1], "Wrong argument");
347  	free(ptr);
348  	ptr = malloc(1);
349  	reset();
350  	realloc(ptr, 0);
351  	assert_d_eq(call_count, 1, "Hook not called");
352  	assert_ptr_eq(arg_extra, (void *)123, "Wrong extra");
353  	assert_d_eq(arg_type, (int)hook_dalloc_realloc, "Wrong hook type");
354  	assert_ptr_eq(ptr, arg_address, "Wrong pointer freed");
355  	assert_u64_eq((uintptr_t)ptr, arg_args_raw[0], "Wrong raw arg");
356  	assert_u64_eq((uintptr_t)0, arg_args_raw[1], "Wrong raw arg");
357  	reset();
358  	ptr = realloc(NULL, 0);
359  	assert_d_eq(call_count, 1, "Hook not called");
360  	assert_ptr_eq(arg_extra, (void *)123, "Wrong extra");
361  	assert_d_eq(arg_type, (int)hook_alloc_realloc, "Wrong hook type");
362  	assert_ptr_eq(ptr, arg_result, "Wrong result");
363  	assert_u64_eq((uintptr_t)ptr, (uintptr_t)arg_result_raw,
364  	    "Wrong raw result");
365  	assert_u64_eq((uintptr_t)NULL, arg_args_raw[0], "Wrong argument");
366  	assert_u64_eq((uintptr_t)0, arg_args_raw[1], "Wrong argument");
367  	free(ptr);
368  	hook_remove(TSDN_NULL, handle);
369  }
370  TEST_END
371  static void
372  do_realloc_test(void *(*ralloc)(void *, size_t, int), int flags,
373      int expand_type, int dalloc_type) {
374  	hooks_t hooks = {&test_alloc_hook, &test_dalloc_hook,
375  		&test_expand_hook, (void *)123};
376  	void *handle = hook_install(TSDN_NULL, &hooks);
377  	assert_ptr_ne(handle, NULL, "Hook installation failed");
378  	void *volatile ptr;
379  	void *volatile ptr2;
380  	ptr = malloc(129);
381  	reset();
382  	ptr2 = ralloc(ptr, 130, flags);
383  	assert_ptr_eq(ptr, ptr2, "Small realloc moved");
384  	assert_d_eq(call_count, 1, "Hook not called");
385  	assert_ptr_eq(arg_extra, (void *)123, "Wrong extra");
386  	assert_d_eq(arg_type, expand_type, "Wrong hook type");
387  	assert_ptr_eq(ptr, arg_address, "Wrong address");
388  	assert_u64_eq((uintptr_t)ptr, (uintptr_t)arg_result_raw,
389  	    "Wrong raw result");
390  	assert_u64_eq((uintptr_t)ptr, arg_args_raw[0], "Wrong argument");
391  	assert_u64_eq((uintptr_t)130, arg_args_raw[1], "Wrong argument");
392  	free(ptr);
393  	ptr = malloc(2 * 1024 * 1024);
394  	free(ptr);
395  	ptr2 = malloc(1 * 1024 * 1024);
396  	reset();
397  	ptr = ralloc(ptr2, 2 * 1024 * 1024, flags);
398  	if (ptr == ptr2) {
399  		assert_d_eq(call_count, 1, "Hook not called");
400  		assert_d_eq(arg_type, expand_type, "Wrong hook type");
401  	} else {
402  		assert_d_eq(call_count, 2, "Wrong hooks called");
403  		assert_ptr_eq(ptr, arg_result, "Wrong address");
404  		assert_d_eq(arg_type, dalloc_type, "Wrong hook type");
405  	}
406  	assert_ptr_eq(arg_extra, (void *)123, "Wrong extra");
407  	assert_ptr_eq(ptr2, arg_address, "Wrong address");
408  	assert_u64_eq((uintptr_t)ptr, (uintptr_t)arg_result_raw,
409  	    "Wrong raw result");
410  	assert_u64_eq((uintptr_t)ptr2, arg_args_raw[0], "Wrong argument");
411  	assert_u64_eq((uintptr_t)2 * 1024 * 1024, arg_args_raw[1],
412  	    "Wrong argument");
413  	free(ptr);
414  	ptr = malloc(8);
415  	reset();
416  	ptr2 = ralloc(ptr, 128, flags);
417  	assert_ptr_ne(ptr, ptr2, "Small realloc didn't move");
418  	assert_d_eq(call_count, 2, "Hook not called");
419  	assert_ptr_eq(arg_extra, (void *)123, "Wrong extra");
420  	assert_d_eq(arg_type, dalloc_type, "Wrong hook type");
421  	assert_ptr_eq(ptr, arg_address, "Wrong address");
422  	assert_ptr_eq(ptr2, arg_result, "Wrong address");
423  	assert_u64_eq((uintptr_t)ptr2, (uintptr_t)arg_result_raw,
424  	    "Wrong raw result");
425  	assert_u64_eq((uintptr_t)ptr, arg_args_raw[0], "Wrong argument");
426  	assert_u64_eq((uintptr_t)128, arg_args_raw[1], "Wrong argument");
427  	free(ptr2);
428  	ptr = malloc(1);
429  	reset();
430  	ptr2 = ralloc(ptr, 2 * 1024 * 1024, flags);
431  	assert_ptr_ne(ptr, ptr2, "Large realloc didn't move");
432  	assert_d_eq(call_count, 2, "Hook not called");
433  	assert_ptr_eq(arg_extra, (void *)123, "Wrong extra");
434  	assert_d_eq(arg_type, dalloc_type, "Wrong hook type");
435  	assert_ptr_eq(ptr, arg_address, "Wrong address");
436  	assert_ptr_eq(ptr2, arg_result, "Wrong address");
437  	assert_u64_eq((uintptr_t)ptr2, (uintptr_t)arg_result_raw,
438  	    "Wrong raw result");
439  	assert_u64_eq((uintptr_t)ptr, arg_args_raw[0], "Wrong argument");
440  	assert_u64_eq((uintptr_t)2 * 1024 * 1024, arg_args_raw[1],
441  	    "Wrong argument");
442  	free(ptr2);
443  	hook_remove(TSDN_NULL, handle);
444  }
445  static void *
446  realloc_wrapper(void *ptr, size_t size, UNUSED int flags) {
447  	return realloc(ptr, size);
448  }
449  TEST_BEGIN(test_hooks_realloc) {
450  	do_realloc_test(&realloc_wrapper, 0, hook_expand_realloc,
451  	    hook_dalloc_realloc);
452  }
453  TEST_END
454  TEST_BEGIN(test_hooks_rallocx) {
455  	do_realloc_test(&rallocx, MALLOCX_TCACHE_NONE, hook_expand_rallocx,
456  	    hook_dalloc_rallocx);
457  }
458  TEST_END
459  int
460  main(void) {
461  	return test_no_reentrancy(
462  	    test_hooks_basic,
463  	    test_hooks_null,
464  	    test_hooks_remove,
465  	    test_hooks_alloc_simple,
466  	    test_hooks_dalloc_simple,
467  	    test_hooks_expand_simple,
468  	    test_hooks_realloc_as_malloc_or_free,
469  	    test_hooks_realloc,
470  	    test_hooks_rallocx);
471  }
</code></pre>
        </div>
        <div class="column">
            <h3>redis-MDEwOlJlcG9zaXRvcnkxMDgxMTA3MDY=-flat-hook.c</h3>
            <pre><code>1  #include "test/jemalloc_test.h"
2  #include "jemalloc/internal/hook.h"
3  static void *arg_extra;
4  static int arg_type;
5  static void *arg_result;
6  static void *arg_address;
7  static size_t arg_old_usize;
8  static size_t arg_new_usize;
9  static uintptr_t arg_result_raw;
10  static uintptr_t arg_args_raw[4];
11  static int call_count = 0;
12  static void
13  reset_args() {
14  	arg_extra = NULL;
15  	arg_type = 12345;
16  	arg_result = NULL;
17  	arg_address = NULL;
18  	arg_old_usize = 0;
19  	arg_new_usize = 0;
20  	arg_result_raw = 0;
21  	memset(arg_args_raw, 77, sizeof(arg_args_raw));
22  }
23  static void
24  alloc_free_size(size_t sz) {
25  	void *ptr = mallocx(1, 0);
26  	free(ptr);
27  	ptr = mallocx(1, 0);
28  	free(ptr);
29  	ptr = mallocx(1, MALLOCX_TCACHE_NONE);
30  	dallocx(ptr, MALLOCX_TCACHE_NONE);
31  }
32  static void
33  be_reentrant() {
34  	alloc_free_size(1);
35  	alloc_free_size(1024);
36  	alloc_free_size(64 * 1024);
37  	alloc_free_size(256 * 1024);
38  	alloc_free_size(1024 * 1024);
39  	void *ptr = mallocx(129, 0);
40  	ptr = rallocx(ptr, 130, 0);
41  	free(ptr);
42  	ptr = mallocx(2 * 1024 * 1024, 0);
43  	free(ptr);
44  	ptr = mallocx(1 * 1024 * 1024, 0);
45  	ptr = rallocx(ptr, 2 * 1024 * 1024, 0);
46  	free(ptr);
47  	ptr = mallocx(1, 0);
48  	ptr = rallocx(ptr, 1000, 0);
49  	free(ptr);
50  }
51  static void
52  set_args_raw(uintptr_t *args_raw, int nargs) {
53  	memcpy(arg_args_raw, args_raw, sizeof(uintptr_t) * nargs);
54  }
55  static void
56  assert_args_raw(uintptr_t *args_raw_expected, int nargs) {
57  	int cmp = memcmp(args_raw_expected, arg_args_raw,
58  	    sizeof(uintptr_t) * nargs);
59  	assert_d_eq(cmp, 0, "Raw args mismatch");
60  }
61  static void
62  reset() {
63  	call_count = 0;
64  	reset_args();
65  }
66  static void
67  test_alloc_hook(void *extra, hook_alloc_t type, void *result,
68      uintptr_t result_raw, uintptr_t args_raw[3]) {
69  	call_count++;
70  	arg_extra = extra;
71  	arg_type = (int)type;
72  	arg_result = result;
73  	arg_result_raw = result_raw;
74  	set_args_raw(args_raw, 3);
75  	be_reentrant();
76  }
77  static void
78  test_dalloc_hook(void *extra, hook_dalloc_t type, void *address,
79      uintptr_t args_raw[3]) {
80  	call_count++;
81  	arg_extra = extra;
82  	arg_type = (int)type;
83  	arg_address = address;
84  	set_args_raw(args_raw, 3);
85  	be_reentrant();
86  }
87  static void
88  test_expand_hook(void *extra, hook_expand_t type, void *address,
89      size_t old_usize, size_t new_usize, uintptr_t result_raw,
90      uintptr_t args_raw[4]) {
91  	call_count++;
92  	arg_extra = extra;
93  	arg_type = (int)type;
94  	arg_address = address;
95  	arg_old_usize = old_usize;
96  	arg_new_usize = new_usize;
97  	arg_result_raw = result_raw;
98  	set_args_raw(args_raw, 4);
99  	be_reentrant();
100  }
101  TEST_BEGIN(test_hooks_basic) {
102  	hooks_t hooks = {
103  		&test_alloc_hook, &test_dalloc_hook, &test_expand_hook,
104  		(void *)111};
105  	void *handle = hook_install(TSDN_NULL, &hooks);
106  	uintptr_t args_raw[4] = {10, 20, 30, 40};
107  	reset_args();
108  	hook_invoke_alloc(hook_alloc_posix_memalign, (void *)222, 333,
109  	    args_raw);
110  	assert_ptr_eq(arg_extra, (void *)111, "Passed wrong user pointer");
111  	assert_d_eq((int)hook_alloc_posix_memalign, arg_type,
112  	    "Passed wrong alloc type");
113  	assert_ptr_eq((void *)222, arg_result, "Passed wrong result address");
114  	assert_u64_eq(333, arg_result_raw, "Passed wrong result");
115  	assert_args_raw(args_raw, 3);
116  	reset_args();
117  	hook_invoke_dalloc(hook_dalloc_sdallocx, (void *)222, args_raw);
118  	assert_d_eq((int)hook_dalloc_sdallocx, arg_type,
119  	    "Passed wrong dalloc type");
120  	assert_ptr_eq((void *)111, arg_extra, "Passed wrong user pointer");
121  	assert_ptr_eq((void *)222, arg_address, "Passed wrong address");
122  	assert_args_raw(args_raw, 3);
123  	reset_args();
124  	hook_invoke_expand(hook_expand_xallocx, (void *)222, 333, 444, 555,
125  	    args_raw);
126  	assert_d_eq((int)hook_expand_xallocx, arg_type,
127  	    "Passed wrong expand type");
128  	assert_ptr_eq((void *)111, arg_extra, "Passed wrong user pointer");
129  	assert_ptr_eq((void *)222, arg_address, "Passed wrong address");
130  	assert_zu_eq(333, arg_old_usize, "Passed wrong old usize");
131  	assert_zu_eq(444, arg_new_usize, "Passed wrong new usize");
132  	assert_zu_eq(555, arg_result_raw, "Passed wrong result");
133  	assert_args_raw(args_raw, 4);
134  	hook_remove(TSDN_NULL, handle);
135  }
136  TEST_END
137  TEST_BEGIN(test_hooks_null) {
138  	hooks_t hooks1 = {NULL, NULL, NULL, NULL};
139  	hooks_t hooks2 = {&test_alloc_hook, NULL, NULL, NULL};
140  	hooks_t hooks3 = {NULL, &test_dalloc_hook, NULL, NULL};
141  	hooks_t hooks4 = {NULL, NULL, &test_expand_hook, NULL};
142  	void *handle1 = hook_install(TSDN_NULL, &hooks1);
143  	void *handle2 = hook_install(TSDN_NULL, &hooks2);
144  	void *handle3 = hook_install(TSDN_NULL, &hooks3);
145  	void *handle4 = hook_install(TSDN_NULL, &hooks4);
146  	assert_ptr_ne(handle1, NULL, "Hook installation failed");
147  	assert_ptr_ne(handle2, NULL, "Hook installation failed");
148  	assert_ptr_ne(handle3, NULL, "Hook installation failed");
149  	assert_ptr_ne(handle4, NULL, "Hook installation failed");
150  	uintptr_t args_raw[4] = {10, 20, 30, 40};
151  	call_count = 0;
152  	hook_invoke_alloc(hook_alloc_malloc, NULL, 0, args_raw);
153  	assert_d_eq(call_count, 1, "Called wrong number of times");
154  	call_count = 0;
155  	hook_invoke_dalloc(hook_dalloc_free, NULL, args_raw);
156  	assert_d_eq(call_count, 1, "Called wrong number of times");
157  	call_count = 0;
158  	hook_invoke_expand(hook_expand_realloc, NULL, 0, 0, 0, args_raw);
159  	assert_d_eq(call_count, 1, "Called wrong number of times");
160  	hook_remove(TSDN_NULL, handle1);
161  	hook_remove(TSDN_NULL, handle2);
162  	hook_remove(TSDN_NULL, handle3);
163  	hook_remove(TSDN_NULL, handle4);
164  }
165  TEST_END
166  TEST_BEGIN(test_hooks_remove) {
167  	hooks_t hooks = {&test_alloc_hook, NULL, NULL, NULL};
168  	void *handle = hook_install(TSDN_NULL, &hooks);
169  	assert_ptr_ne(handle, NULL, "Hook installation failed");
170  	call_count = 0;
171  	uintptr_t args_raw[4] = {10, 20, 30, 40};
172  	hook_invoke_alloc(hook_alloc_malloc, NULL, 0, args_raw);
173  	assert_d_eq(call_count, 1, "Hook not invoked");
174  	call_count = 0;
175  	hook_remove(TSDN_NULL, handle);
176  	hook_invoke_alloc(hook_alloc_malloc, NULL, 0, NULL);
177  	assert_d_eq(call_count, 0, "Hook invoked after removal");
178  }
179  TEST_END
180  TEST_BEGIN(test_hooks_alloc_simple) {
181  	hooks_t hooks = {&test_alloc_hook, NULL, NULL, (void *)123};
182  	void *handle = hook_install(TSDN_NULL, &hooks);
183  	assert_ptr_ne(handle, NULL, "Hook installation failed");
184  	volatile int err;
185  	void *volatile ptr;
186  	reset();
187  	ptr = malloc(1);
188  	assert_d_eq(call_count, 1, "Hook not called");
189  	assert_ptr_eq(arg_extra, (void *)123, "Wrong extra");
190  	assert_d_eq(arg_type, (int)hook_alloc_malloc, "Wrong hook type");
191  	assert_ptr_eq(ptr, arg_result, "Wrong result");
192  	assert_u64_eq((uintptr_t)ptr, (uintptr_t)arg_result_raw,
193  	    "Wrong raw result");
194  	assert_u64_eq((uintptr_t)1, arg_args_raw[0], "Wrong argument");
195  	free(ptr);
196  	reset();
197  	err = posix_memalign((void **)&ptr, 1024, 1);
198  	assert_d_eq(call_count, 1, "Hook not called");
199  	assert_ptr_eq(arg_extra, (void *)123, "Wrong extra");
200  	assert_d_eq(arg_type, (int)hook_alloc_posix_memalign,
201  	    "Wrong hook type");
202  	assert_ptr_eq(ptr, arg_result, "Wrong result");
203  	assert_u64_eq((uintptr_t)err, (uintptr_t)arg_result_raw,
204  	    "Wrong raw result");
205  	assert_u64_eq((uintptr_t)&ptr, arg_args_raw[0], "Wrong argument");
206  	assert_u64_eq((uintptr_t)1024, arg_args_raw[1], "Wrong argument");
207  	assert_u64_eq((uintptr_t)1, arg_args_raw[2], "Wrong argument");
208  	free(ptr);
209  	reset();
210  	ptr = aligned_alloc(1024, 1);
211  	assert_d_eq(call_count, 1, "Hook not called");
212  	assert_ptr_eq(arg_extra, (void *)123, "Wrong extra");
213  	assert_d_eq(arg_type, (int)hook_alloc_aligned_alloc,
214  	    "Wrong hook type");
215  	assert_ptr_eq(ptr, arg_result, "Wrong result");
216  	assert_u64_eq((uintptr_t)ptr, (uintptr_t)arg_result_raw,
217  	    "Wrong raw result");
218  	assert_u64_eq((uintptr_t)1024, arg_args_raw[0], "Wrong argument");
219  	assert_u64_eq((uintptr_t)1, arg_args_raw[1], "Wrong argument");
220  	free(ptr);
221  	reset();
<span onclick='openModal()' class='match'>222  	ptr = calloc(11, 13);
223  	assert_d_eq(call_count, 1, "Hook not called");
224  	assert_ptr_eq(arg_extra, (void *)123, "Wrong extra");
225  	assert_d_eq(arg_type, (int)hook_alloc_calloc, "Wrong hook type");
226  	assert_ptr_eq(ptr, arg_result, "Wrong result");
227  	assert_u64_eq((uintptr_t)ptr, (uintptr_t)arg_result_raw,
228  	    "Wrong raw result");
229  	assert_u64_eq((uintptr_t)11, arg_args_raw[0], "Wrong argument");
230  	assert_u64_eq((uintptr_t)13, arg_args_raw[1], "Wrong argument");
231  	free(ptr);
232  #ifdef JEMALLOC_OVERRIDE_MEMALIGN
</span>233  	reset();
234  	ptr = memalign(1024, 1);
235  	assert_d_eq(call_count, 1, "Hook not called");
236  	assert_ptr_eq(arg_extra, (void *)123, "Wrong extra");
237  	assert_d_eq(arg_type, (int)hook_alloc_memalign, "Wrong hook type");
238  	assert_ptr_eq(ptr, arg_result, "Wrong result");
239  	assert_u64_eq((uintptr_t)ptr, (uintptr_t)arg_result_raw,
240  	    "Wrong raw result");
241  	assert_u64_eq((uintptr_t)1024, arg_args_raw[0], "Wrong argument");
242  	assert_u64_eq((uintptr_t)1, arg_args_raw[1], "Wrong argument");
243  	free(ptr);
244  #endif &bsol;* JEMALLOC_OVERRIDE_MEMALIGN */
245  #ifdef JEMALLOC_OVERRIDE_VALLOC
246  	reset();
247  	ptr = valloc(1);
248  	assert_d_eq(call_count, 1, "Hook not called");
249  	assert_ptr_eq(arg_extra, (void *)123, "Wrong extra");
250  	assert_d_eq(arg_type, (int)hook_alloc_valloc, "Wrong hook type");
251  	assert_ptr_eq(ptr, arg_result, "Wrong result");
252  	assert_u64_eq((uintptr_t)ptr, (uintptr_t)arg_result_raw,
253  	    "Wrong raw result");
254  	assert_u64_eq((uintptr_t)1, arg_args_raw[0], "Wrong argument");
255  	free(ptr);
256  #endif &bsol;* JEMALLOC_OVERRIDE_VALLOC */
257  	reset();
258  	ptr = mallocx(1, MALLOCX_LG_ALIGN(10));
259  	assert_d_eq(call_count, 1, "Hook not called");
260  	assert_ptr_eq(arg_extra, (void *)123, "Wrong extra");
261  	assert_d_eq(arg_type, (int)hook_alloc_mallocx, "Wrong hook type");
262  	assert_ptr_eq(ptr, arg_result, "Wrong result");
263  	assert_u64_eq((uintptr_t)ptr, (uintptr_t)arg_result_raw,
264  	    "Wrong raw result");
265  	assert_u64_eq((uintptr_t)1, arg_args_raw[0], "Wrong argument");
266  	assert_u64_eq((uintptr_t)MALLOCX_LG_ALIGN(10), arg_args_raw[1],
267  	    "Wrong flags");
268  	free(ptr);
269  	hook_remove(TSDN_NULL, handle);
270  }
271  TEST_END
272  TEST_BEGIN(test_hooks_dalloc_simple) {
273  	hooks_t hooks = {NULL, &test_dalloc_hook, NULL, (void *)123};
274  	void *handle = hook_install(TSDN_NULL, &hooks);
275  	assert_ptr_ne(handle, NULL, "Hook installation failed");
276  	void *volatile ptr;
277  	reset();
278  	ptr = malloc(1);
279  	free(ptr);
280  	assert_d_eq(call_count, 1, "Hook not called");
281  	assert_ptr_eq(arg_extra, (void *)123, "Wrong extra");
282  	assert_d_eq(arg_type, (int)hook_dalloc_free, "Wrong hook type");
283  	assert_ptr_eq(ptr, arg_address, "Wrong pointer freed");
284  	assert_u64_eq((uintptr_t)ptr, arg_args_raw[0], "Wrong raw arg");
285  	reset();
286  	ptr = malloc(1);
287  	dallocx(ptr, MALLOCX_TCACHE_NONE);
288  	assert_d_eq(call_count, 1, "Hook not called");
289  	assert_ptr_eq(arg_extra, (void *)123, "Wrong extra");
290  	assert_d_eq(arg_type, (int)hook_dalloc_dallocx, "Wrong hook type");
291  	assert_ptr_eq(ptr, arg_address, "Wrong pointer freed");
292  	assert_u64_eq((uintptr_t)ptr, arg_args_raw[0], "Wrong raw arg");
293  	assert_u64_eq((uintptr_t)MALLOCX_TCACHE_NONE, arg_args_raw[1],
294  	    "Wrong raw arg");
295  	reset();
296  	ptr = malloc(1);
297  	sdallocx(ptr, 1, MALLOCX_TCACHE_NONE);
298  	assert_d_eq(call_count, 1, "Hook not called");
299  	assert_ptr_eq(arg_extra, (void *)123, "Wrong extra");
300  	assert_d_eq(arg_type, (int)hook_dalloc_sdallocx, "Wrong hook type");
301  	assert_ptr_eq(ptr, arg_address, "Wrong pointer freed");
302  	assert_u64_eq((uintptr_t)ptr, arg_args_raw[0], "Wrong raw arg");
303  	assert_u64_eq((uintptr_t)1, arg_args_raw[1], "Wrong raw arg");
304  	assert_u64_eq((uintptr_t)MALLOCX_TCACHE_NONE, arg_args_raw[2],
305  	    "Wrong raw arg");
306  	hook_remove(TSDN_NULL, handle);
307  }
308  TEST_END
309  TEST_BEGIN(test_hooks_expand_simple) {
310  	hooks_t hooks = {NULL, NULL, &test_expand_hook, (void *)123};
311  	void *handle = hook_install(TSDN_NULL, &hooks);
312  	assert_ptr_ne(handle, NULL, "Hook installation failed");
313  	void *volatile ptr;
314  	reset();
315  	ptr = malloc(1);
316  	size_t new_usize = xallocx(ptr, 100, 200, MALLOCX_TCACHE_NONE);
317  	assert_d_eq(call_count, 1, "Hook not called");
318  	assert_ptr_eq(arg_extra, (void *)123, "Wrong extra");
319  	assert_d_eq(arg_type, (int)hook_expand_xallocx, "Wrong hook type");
320  	assert_ptr_eq(ptr, arg_address, "Wrong pointer expanded");
321  	assert_u64_eq(arg_old_usize, nallocx(1, 0), "Wrong old usize");
322  	assert_u64_eq(arg_new_usize, sallocx(ptr, 0), "Wrong new usize");
323  	assert_u64_eq(new_usize, arg_result_raw, "Wrong result");
324  	assert_u64_eq((uintptr_t)ptr, arg_args_raw[0], "Wrong arg");
325  	assert_u64_eq(100, arg_args_raw[1], "Wrong arg");
326  	assert_u64_eq(200, arg_args_raw[2], "Wrong arg");
327  	assert_u64_eq(MALLOCX_TCACHE_NONE, arg_args_raw[3], "Wrong arg");
328  	hook_remove(TSDN_NULL, handle);
329  }
330  TEST_END
331  TEST_BEGIN(test_hooks_realloc_as_malloc_or_free) {
332  	hooks_t hooks = {&test_alloc_hook, &test_dalloc_hook,
333  		&test_expand_hook, (void *)123};
334  	void *handle = hook_install(TSDN_NULL, &hooks);
335  	assert_ptr_ne(handle, NULL, "Hook installation failed");
336  	void *volatile ptr;
337  	reset();
338  	ptr = realloc(NULL, 1);
339  	assert_d_eq(call_count, 1, "Hook not called");
340  	assert_ptr_eq(arg_extra, (void *)123, "Wrong extra");
341  	assert_d_eq(arg_type, (int)hook_alloc_realloc, "Wrong hook type");
342  	assert_ptr_eq(ptr, arg_result, "Wrong result");
343  	assert_u64_eq((uintptr_t)ptr, (uintptr_t)arg_result_raw,
344  	    "Wrong raw result");
345  	assert_u64_eq((uintptr_t)NULL, arg_args_raw[0], "Wrong argument");
346  	assert_u64_eq((uintptr_t)1, arg_args_raw[1], "Wrong argument");
347  	free(ptr);
348  	ptr = malloc(1);
349  	reset();
350  	realloc(ptr, 0);
351  	assert_d_eq(call_count, 1, "Hook not called");
352  	assert_ptr_eq(arg_extra, (void *)123, "Wrong extra");
353  	assert_d_eq(arg_type, (int)hook_dalloc_realloc, "Wrong hook type");
354  	assert_ptr_eq(ptr, arg_address, "Wrong pointer freed");
355  	assert_u64_eq((uintptr_t)ptr, arg_args_raw[0], "Wrong raw arg");
356  	assert_u64_eq((uintptr_t)0, arg_args_raw[1], "Wrong raw arg");
357  	reset();
358  	ptr = realloc(NULL, 0);
359  	assert_d_eq(call_count, 1, "Hook not called");
360  	assert_ptr_eq(arg_extra, (void *)123, "Wrong extra");
361  	assert_d_eq(arg_type, (int)hook_alloc_realloc, "Wrong hook type");
362  	assert_ptr_eq(ptr, arg_result, "Wrong result");
363  	assert_u64_eq((uintptr_t)ptr, (uintptr_t)arg_result_raw,
364  	    "Wrong raw result");
365  	assert_u64_eq((uintptr_t)NULL, arg_args_raw[0], "Wrong argument");
366  	assert_u64_eq((uintptr_t)0, arg_args_raw[1], "Wrong argument");
367  	free(ptr);
368  	hook_remove(TSDN_NULL, handle);
369  }
370  TEST_END
371  static void
372  do_realloc_test(void *(*ralloc)(void *, size_t, int), int flags,
373      int expand_type, int dalloc_type) {
374  	hooks_t hooks = {&test_alloc_hook, &test_dalloc_hook,
375  		&test_expand_hook, (void *)123};
376  	void *handle = hook_install(TSDN_NULL, &hooks);
377  	assert_ptr_ne(handle, NULL, "Hook installation failed");
378  	void *volatile ptr;
379  	void *volatile ptr2;
380  	ptr = malloc(129);
381  	reset();
382  	ptr2 = ralloc(ptr, 130, flags);
383  	assert_ptr_eq(ptr, ptr2, "Small realloc moved");
384  	assert_d_eq(call_count, 1, "Hook not called");
385  	assert_ptr_eq(arg_extra, (void *)123, "Wrong extra");
386  	assert_d_eq(arg_type, expand_type, "Wrong hook type");
387  	assert_ptr_eq(ptr, arg_address, "Wrong address");
388  	assert_u64_eq((uintptr_t)ptr, (uintptr_t)arg_result_raw,
389  	    "Wrong raw result");
390  	assert_u64_eq((uintptr_t)ptr, arg_args_raw[0], "Wrong argument");
391  	assert_u64_eq((uintptr_t)130, arg_args_raw[1], "Wrong argument");
392  	free(ptr);
393  	ptr = malloc(2 * 1024 * 1024);
394  	free(ptr);
395  	ptr2 = malloc(1 * 1024 * 1024);
396  	reset();
397  	ptr = ralloc(ptr2, 2 * 1024 * 1024, flags);
398  	if (ptr == ptr2) {
399  		assert_d_eq(call_count, 1, "Hook not called");
400  		assert_d_eq(arg_type, expand_type, "Wrong hook type");
401  	} else {
402  		assert_d_eq(call_count, 2, "Wrong hooks called");
403  		assert_ptr_eq(ptr, arg_result, "Wrong address");
404  		assert_d_eq(arg_type, dalloc_type, "Wrong hook type");
405  	}
406  	assert_ptr_eq(arg_extra, (void *)123, "Wrong extra");
407  	assert_ptr_eq(ptr2, arg_address, "Wrong address");
408  	assert_u64_eq((uintptr_t)ptr, (uintptr_t)arg_result_raw,
409  	    "Wrong raw result");
410  	assert_u64_eq((uintptr_t)ptr2, arg_args_raw[0], "Wrong argument");
411  	assert_u64_eq((uintptr_t)2 * 1024 * 1024, arg_args_raw[1],
412  	    "Wrong argument");
413  	free(ptr);
414  	ptr = malloc(8);
415  	reset();
416  	ptr2 = ralloc(ptr, 128, flags);
417  	assert_ptr_ne(ptr, ptr2, "Small realloc didn't move");
418  	assert_d_eq(call_count, 2, "Hook not called");
419  	assert_ptr_eq(arg_extra, (void *)123, "Wrong extra");
420  	assert_d_eq(arg_type, dalloc_type, "Wrong hook type");
421  	assert_ptr_eq(ptr, arg_address, "Wrong address");
422  	assert_ptr_eq(ptr2, arg_result, "Wrong address");
423  	assert_u64_eq((uintptr_t)ptr2, (uintptr_t)arg_result_raw,
424  	    "Wrong raw result");
425  	assert_u64_eq((uintptr_t)ptr, arg_args_raw[0], "Wrong argument");
426  	assert_u64_eq((uintptr_t)128, arg_args_raw[1], "Wrong argument");
427  	free(ptr2);
428  	ptr = malloc(1);
429  	reset();
430  	ptr2 = ralloc(ptr, 2 * 1024 * 1024, flags);
431  	assert_ptr_ne(ptr, ptr2, "Large realloc didn't move");
432  	assert_d_eq(call_count, 2, "Hook not called");
433  	assert_ptr_eq(arg_extra, (void *)123, "Wrong extra");
434  	assert_d_eq(arg_type, dalloc_type, "Wrong hook type");
435  	assert_ptr_eq(ptr, arg_address, "Wrong address");
436  	assert_ptr_eq(ptr2, arg_result, "Wrong address");
437  	assert_u64_eq((uintptr_t)ptr2, (uintptr_t)arg_result_raw,
438  	    "Wrong raw result");
439  	assert_u64_eq((uintptr_t)ptr, arg_args_raw[0], "Wrong argument");
440  	assert_u64_eq((uintptr_t)2 * 1024 * 1024, arg_args_raw[1],
441  	    "Wrong argument");
442  	free(ptr2);
443  	hook_remove(TSDN_NULL, handle);
444  }
445  static void *
446  realloc_wrapper(void *ptr, size_t size, UNUSED int flags) {
447  	return realloc(ptr, size);
448  }
449  TEST_BEGIN(test_hooks_realloc) {
450  	do_realloc_test(&realloc_wrapper, 0, hook_expand_realloc,
451  	    hook_dalloc_realloc);
452  }
453  TEST_END
454  TEST_BEGIN(test_hooks_rallocx) {
455  	do_realloc_test(&rallocx, MALLOCX_TCACHE_NONE, hook_expand_rallocx,
456  	    hook_dalloc_rallocx);
457  }
458  TEST_END
459  int
460  main(void) {
461  	return test_no_reentrancy(
462  	    test_hooks_basic,
463  	    test_hooks_null,
464  	    test_hooks_remove,
465  	    test_hooks_alloc_simple,
466  	    test_hooks_dalloc_simple,
467  	    test_hooks_expand_simple,
468  	    test_hooks_realloc_as_malloc_or_free,
469  	    test_hooks_realloc,
470  	    test_hooks_rallocx);
471  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from redis-MDEwOlJlcG9zaXRvcnkxMDgxMTA3MDY=-flat-hook.c</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from redis-MDEwOlJlcG9zaXRvcnkxMDgxMTA3MDY=-flat-hook.c</div>
                </div>
                <div class="column column_space"><pre><code>210  	ptr = aligned_alloc(1024, 1);
211  	assert_d_eq(call_count, 1, "Hook not called");
212  	assert_ptr_eq(arg_extra, (void *)123, "Wrong extra");
213  	assert_d_eq(arg_type, (int)hook_alloc_aligned_alloc,
214  	    "Wrong hook type");
215  	assert_ptr_eq(ptr, arg_result, "Wrong result");
216  	assert_u64_eq((uintptr_t)ptr, (uintptr_t)arg_result_raw,
217  	    "Wrong raw result");
218  	assert_u64_eq((uintptr_t)1024, arg_args_raw[0], "Wrong argument");
219  	assert_u64_eq((uintptr_t)1, arg_args_raw[1], "Wrong argument");
220  	free(ptr);
221  	reset();
</pre></code></div>
                <div class="column column_space"><pre><code>222  	ptr = calloc(11, 13);
223  	assert_d_eq(call_count, 1, "Hook not called");
224  	assert_ptr_eq(arg_extra, (void *)123, "Wrong extra");
225  	assert_d_eq(arg_type, (int)hook_alloc_calloc, "Wrong hook type");
226  	assert_ptr_eq(ptr, arg_result, "Wrong result");
227  	assert_u64_eq((uintptr_t)ptr, (uintptr_t)arg_result_raw,
228  	    "Wrong raw result");
229  	assert_u64_eq((uintptr_t)11, arg_args_raw[0], "Wrong argument");
230  	assert_u64_eq((uintptr_t)13, arg_args_raw[1], "Wrong argument");
231  	free(ptr);
232  #ifdef JEMALLOC_OVERRIDE_MEMALIGN
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    