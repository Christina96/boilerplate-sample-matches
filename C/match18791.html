<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML><HEAD><TITLE>Matches for morph.c & ppmload.c</TITLE>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
</HEAD>
<body>
  <div style="align-items: center; display: flex; justify-content: space-around;">
    <div>
      <h3 align="center">
Matches for morph.c & ppmload.c
      </h3>
      <h1 align="center">
        7.4%
      </h1>
      <center>
        <a href="index.html" target="_top">
          INDEX
        </a>
        <span>-</span>
        <a href="help-en.html" target="_top">
          HELP
        </a>
      </center>
    </div>
    <div>
<TABLE BORDER="1" CELLSPACING="0" BGCOLOR="#d0d0d0">
<TR><TH><TH>morph.c (7.8125%)<TH>ppmload.c (7.079646%)<TH>Tokens
<TR><TD BGCOLOR="#0000ff"><FONT COLOR="#0000ff">-</FONT><TD><A HREF="javascript:ZweiFrames('match18791-0.html#0',2,'match18791-1.html#0',3)" NAME="0">(616-631)<TD><A HREF="javascript:ZweiFrames('match18791-0.html#0',2,'match18791-1.html#0',3)" NAME="0">(553-566)</A><TD ALIGN=center><FONT COLOR="#ff0000">14</FONT>
<TR><TD BGCOLOR="#f63526"><FONT COLOR="#f63526">-</FONT><TD><A HREF="javascript:ZweiFrames('match18791-0.html#1',2,'match18791-1.html#1',3)" NAME="1">(508-523)<TD><A HREF="javascript:ZweiFrames('match18791-0.html#1',2,'match18791-1.html#1',3)" NAME="1">(524-537)</A><TD ALIGN=center><FONT COLOR="#ff0000">14</FONT>
<TR><TD BGCOLOR="#980517"><FONT COLOR="#980517">-</FONT><TD><A HREF="javascript:ZweiFrames('match18791-0.html#2',2,'match18791-1.html#2',3)" NAME="2">(399-412)<TD><A HREF="javascript:ZweiFrames('match18791-0.html#2',2,'match18791-1.html#2',3)" NAME="2">(585-596)</A><TD ALIGN=center><FONT COLOR="#da0000">12</FONT>
</TABLE>
    </div>
  </div>
  <hr>
  <div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>morph.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
/* morphology
 *
 * 19/9/95 JC
 *	- rewritten
 * 6/7/99 JC
 *	- small tidies
 * 7/4/04 
 *	- now uses im_embed() with edge stretching on the input, not
 *	  the output
 *	- sets Xoffset / Yoffset
 * 21/4/08
 * 	- only rebuild the buffer offsets if bpl changes
 * 	- small cleanups
 * 25/10/10
 * 	- start again from the Orc'd im_conv
 * 29/10/10
 * 	- use VipsVector
 * 	- do erode as well 
 * 7/11/10
 * 	- gtk-doc
 * 	- do (!=0) to make uchar, if we're not given uchar
 * 28/6/13
 * 	- oops, fix !=0 code
 * 23/10/13	
 * 	- from vips_conv()
 * 25/2/20 kleisauke
 * 	- rewritten as a class
 * 	- merged with hitmiss
 */

/*

    This file is part of VIPS.
    
    VIPS is free software; you can redistribute it and/or modify
    it under the terms of the GNU Lesser General Public License as published by
    the Free Software Foundation; either version 2 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public License
    along with this program; if not, write to the Free Software
    Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
    02110-1301  USA

 */

/*

    These files are distributed with VIPS - http://www.vips.ecs.soton.ac.uk

 */

#ifdef HAVE_CONFIG_H
#include &lt;config.h&gt;
#endif /*HAVE_CONFIG_H*/
#include &lt;vips/intl.h&gt;

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;limits.h&gt;

#include &lt;vips/vips.h&gt;
#include &lt;vips/vector.h&gt;
#include &lt;vips/debug.h&gt;
#include &lt;vips/internal.h&gt;

#include &quot;pmorphology.h&quot;

/* We can't run more than this many passes. Larger than this and we
 * fall back to C.
 * TODO: Could this be raised to 20? Just like convi.
 */
#define MAX_PASS (10)

/* A pass with a vector. 
 */
typedef struct {
	int first;		/* The index of the first mask coff we use */
	int last;		/* The index of the last mask coff we use */

	int r;			/* Set previous result in this var */

	/* The code we generate for this section of this mask. 
	 */
	VipsVector *vector;
} Pass;

/** 
 * VipsOperationMorphology:
 * @VIPS_OPERATION_MORPHOLOGY_ERODE: true if all set
 * @VIPS_OPERATION_MORPHOLOGY_DILATE: true if one set
 *
 * More like hit-miss, really. 
 *
 * See also: vips_morph().
 */

typedef struct {
	VipsMorphology parent_instance;

	VipsImage *out;
	VipsImage *mask;
	VipsOperationMorphology morph;

	/* @mask cast ready for processing.
	 */
	VipsImage *M;

	int n_point;		/* w * h for our matrix */

	int *coeff;			/* Mask coefficients */

	/* The passes we generate for this mask.
	 */
	int n_pass;	
	Pass pass[MAX_PASS];
} VipsMorph;

typedef VipsMorphologyClass VipsMorphClass;

G_DEFINE_TYPE( VipsMorph, vips_morph, VIPS_TYPE_MORPHOLOGY );

/* Our sequence value.
 */
typedef struct {
	VipsMorph *morph;
	VipsRegion *ir;		/* Input region */

	int *soff;		/* Offsets we check for set */
	int ss;			/* ... and number we check for set */
	int *coff;		/* Offsets we check for clear */
	int cs;			/* ... and number we check for clear */

	int last_bpl;		/* Avoid recalcing offsets, if we can */

	/* In vector mode we need a pair of intermediate buffers to keep the 
	 * results of each pass in.
	 */
	void *t1;
	void *t2;
} VipsMorphSequence;

static void
vips_morph_compile_free( VipsMorph *morph )
{
	int i;

	for( i = 0; i &lt; morph-&gt;n_pass; i++ )
		VIPS_FREEF( vips_vector_free, morph-&gt;pass[i].vector );
	morph-&gt;n_pass = 0;
}

static void
vips_morph_dispose( GObject *gobject )
{
	VipsMorph *morph = (VipsMorph *) gobject;

#ifdef DEBUG
	printf( &quot;vips_morph_dispose: &quot; );
	vips_object_print_name( VIPS_OBJECT( gobject ) );
	printf( &quot;\n&quot; );
#endif /*DEBUG*/

	vips_morph_compile_free( morph ); 

	G_OBJECT_CLASS( vips_morph_parent_class )-&gt;dispose( gobject );
}

/* Free a sequence value.
 */
static int
vips_morph_stop( void *vseq, void *a, void *b )
{
	VipsMorphSequence *seq = (VipsMorphSequence *) vseq;

	VIPS_UNREF( seq-&gt;ir );
	VIPS_FREE( seq-&gt;t1 );
	VIPS_FREE( seq-&gt;t2 );

	return( 0 );
}

/* Morph start function.
 */
static void *
vips_morph_start( VipsImage *out, void *a, void *b )
{
	VipsImage *in = (VipsImage *) a;
	VipsMorph *morph = (VipsMorph *) b;

	VipsMorphSequence *seq;

	if( !(seq = VIPS_NEW( out, VipsMorphSequence )) )
		return( NULL );

	/* Init!
	 */
	seq-&gt;morph = morph;
	seq-&gt;ir = NULL;
	seq-&gt;soff = NULL;
	seq-&gt;ss = 0;
	seq-&gt;coff = NULL;
	seq-&gt;cs = 0;
	seq-&gt;last_bpl = -1;
	seq-&gt;t1 = NULL;
	seq-&gt;t2 = NULL;

	seq-&gt;ir = vips_region_new( in );

	/* C mode.
	 */
	seq-&gt;soff = VIPS_ARRAY( out, morph-&gt;n_point, int );
	seq-&gt;coff = VIPS_ARRAY( out, morph-&gt;n_point, int );

	if( !seq-&gt;soff || 
		!seq-&gt;coff ) {
		vips_morph_stop( seq, in, morph );
		return( NULL );
	}

	/* Vector mode.
	 */
	if( morph-&gt;n_pass ) {
		seq-&gt;t1 = VIPS_ARRAY( NULL, 
			VIPS_IMAGE_N_ELEMENTS( in ), VipsPel );
		seq-&gt;t2 = VIPS_ARRAY( NULL, 
			VIPS_IMAGE_N_ELEMENTS( in ), VipsPel );

		if( !seq-&gt;t1 || 
			!seq-&gt;t2 ) {
			vips_morph_stop( seq, in, morph );
			return( NULL );
		}
	}

	return( seq );
}

#define TEMP( N, S ) vips_vector_temporary( v, N, S )
#define SCANLINE( N, P, S ) vips_vector_source_scanline( v, N, P, S )
#define CONST( N, V, S ) vips_vector_constant( v, N, V, S )
#define ASM2( OP, A, B ) vips_vector_asm2( v, OP, A, B )
#define ASM3( OP, A, B, C ) vips_vector_asm3( v, OP, A, B, C )

/* Generate code for a section of the mask. first is the index we start
 * at, we set last to the index of the last one we use before we run 
 * out of intermediates / constants / parameters / sources or mask
 * coefficients.
 *
 * 0 for success, -1 on error.
 */
static int
vips_morph_compile_section( VipsMorph *morph, Pass *pass, gboolean first_pass )
{
	VipsMorphology *morphology = (VipsMorphology *) morph;
	VipsImage *M = morph-&gt;M;

	VipsVector *v;
	char offset[256];
	char source[256];
	char zero[256];
	char one[256];
	int i;

	pass-&gt;vector = v = vips_vector_new( &quot;morph&quot;, 1 );

	/* The value we fetch from the image, the accumulated sum.
	 */
	TEMP( &quot;value&quot;, 1 );
	TEMP( &quot;sum&quot;, 1 );

	CONST( zero, 0, 1 );
	CONST( one, 255, 1 );

	/* Init the sum. If this is the first pass, it's a constant. If this
	 * is a later pass, we have to init the sum from the result 
	 * of the previous pass. 
	 */
	if( first_pass ) {
		if( morph-&gt;morph == VIPS_OPERATION_MORPHOLOGY_DILATE )
			ASM2( &quot;copyb&quot;, &quot;sum&quot;, zero );
		else
			ASM2( &quot;copyb&quot;, &quot;sum&quot;, one );
	}
	else {
		/* &quot;r&quot; is the result of the previous pass. 
		 */
		pass-&gt;r = vips_vector_source_name( v, &quot;r&quot;, 1 );
		ASM2( &quot;loadb&quot;, &quot;sum&quot;, &quot;r&quot; );
	}

	for( i = pass-&gt;first; i &lt; morph-&gt;n_point; i++ ) {
		int x = i % M-&gt;Xsize;
		int y = i / M-&gt;Xsize;

		/* Exclude don't-care elements.
		 */
		if( morph-&gt;coeff[i] == 128 )
			continue;

		/* The source. sl0 is the first scanline in the mask.
		 */
		SCANLINE( source, y, 1 );

		/* The offset, only for non-first-columns though.
		 */
		if( x &gt; 0 ) {
			CONST( offset, morphology-&gt;in-&gt;Bands * x, 1 );
			ASM3( &quot;loadoffb&quot;, &quot;value&quot;, source, offset );
		}
		else
			ASM2( &quot;loadb&quot;, &quot;value&quot;, source );

		/* Join to our sum. If the mask element is zero, we have to
		 * add an extra negate.
		 */
		if( morph-&gt;morph == VIPS_OPERATION_MORPHOLOGY_DILATE ) {
			if( !morph-&gt;coeff[i] ) 
				ASM3( &quot;xorb&quot;, &quot;value&quot;, &quot;value&quot;, one );
			ASM3( &quot;orb&quot;, &quot;sum&quot;, &quot;sum&quot;, &quot;value&quot; );
		}
		else {
			if( !morph-&gt;coeff[i] ) {
				/* You'd think we could use andnb, but it
				 * fails on some machines with some orc
				 * versions :( 
				 */
				ASM3( &quot;xorb&quot;, &quot;value&quot;, &quot;value&quot;, one );
				ASM3( &quot;andb&quot;, &quot;sum&quot;, &quot;sum&quot;, &quot;value&quot; );
			}
			else
				ASM3( &quot;andb&quot;, &quot;sum&quot;, &quot;sum&quot;, &quot;value&quot; );
		}

		if( vips_vector_full( v ) )
			break;
	}

	pass-&gt;last = i;

	ASM2( &quot;copyb&quot;, &quot;d1&quot;, &quot;sum&quot; );

	if( !vips_vector_compile( v ) ) 
		return( -1 );

#ifdef DEBUG
	printf( &quot;done matrix coeffs %d to %d\n&quot;, pass-&gt;first, pass-&gt;last );
	vips_vector_print( v );
#endif /*DEBUG*/

	return( 0 );
}

/* Generate a set of passes.
 */
static int
vips_morph_compile( VipsMorph *morph )
{
	int i;
	Pass *pass;

#ifdef DEBUG
	printf( &quot;vips_morph_compile: generating vector code\n&quot; );
#endif /*DEBUG*/

	/* Generate passes until we've used up the whole mask.
	 */
	for( i = 0;;) {
		/* Skip any don't-care coefficients at the start of the mask 
		 * region.
		 */
		for( ; i &lt; morph-&gt;n_point &amp;&amp; morph-&gt;coeff[i] == 128; i++ )
			;
		if( i == morph-&gt;n_point )
			break;

		/* Allocate space for another pass.
		 */
		if( morph-&gt;n_pass == MAX_PASS ) 
			return( -1 );
		pass = &amp;morph-&gt;pass[morph-&gt;n_pass];
		morph-&gt;n_pass += 1;

		pass-&gt;first = i;
		pass-&gt;last = i;
		pass-&gt;r = -1;

		if( vips_morph_compile_section( morph, pass, morph-&gt;n_pass == 1 ) )
			return( -1 );
		i = pass-&gt;last + 1;
<A NAME="2"></A>
		if( i &gt;= morph-&gt;n_point )
			break;
<FONT color="#980517"><A HREF="javascript:ZweiFrames('match18791-1.html#2',3,'match18791-top.html#2',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>	}

	return( 0 );
}

/* Dilate!
 */
static int
vips_dilate_gen( VipsRegion *or, 
	void *vseq, void *a, void *b, gboolean *stop )
{
	VipsMorphSequence *seq = (VipsMorphSequence *) vseq;
	VipsMorph *morph = (VipsMorph *) b;
	VipsImage *M = morph-&gt;M;</B></FONT>
	VipsRegion *ir = seq-&gt;ir;

	int *soff = seq-&gt;soff;
	int *coff = seq-&gt;coff;

	VipsRect *r = &amp;or-&gt;valid;
	int le = r-&gt;left;
	int to = r-&gt;top;
	int bo = VIPS_RECT_BOTTOM( r );
	int sz = VIPS_REGION_N_ELEMENTS( or );

	VipsRect s;
	int x, y;
	int *t;
	int result, i;

	/* Prepare the section of the input image we need. A little larger
	 * than the section of the output image we are producing.
	 */
	s = *r;
	s.width += M-&gt;Xsize - 1;
	s.height += M-&gt;Ysize - 1;
	if( vips_region_prepare( ir, &amp;s ) )
		return( -1 );

#ifdef DEBUG_VERBOSE
	printf( &quot;vips_dilate_gen: preparing %dx%d@%dx%d pixels\n&quot;, 
		s.width, s.height, s.left, s.top );
#endif /*DEBUG_VERBOSE*/

	/* Scan mask, building offsets we check when processing. Only do this
	 * if the bpl has changed since the previous vips_region_prepare().
	 */
	if( seq-&gt;last_bpl != VIPS_REGION_LSKIP( ir ) ) {
		seq-&gt;last_bpl = VIPS_REGION_LSKIP( ir );

		seq-&gt;ss = 0;
		seq-&gt;cs = 0;
		for( t = morph-&gt;coeff, y = 0; y &lt; M-&gt;Ysize; y++ )
			for( x = 0; x &lt; M-&gt;Xsize; x++, t++ )
				switch( *t ) {
				case 255:
					soff[seq-&gt;ss++] =
						VIPS_REGION_ADDR( ir, 
							x + le, y + to ) -
						VIPS_REGION_ADDR( ir, le, to );
					break;

				case 128:
					break;

				case 0:
					coff[seq-&gt;cs++] =
						VIPS_REGION_ADDR( ir, 
							x + le, y + to ) -
						VIPS_REGION_ADDR( ir, le, to );
					break;

				default:
					g_assert_not_reached();
				}
	}

	/* Dilate!
	 */
	for( y = to; y &lt; bo; y++ ) {
		VipsPel *p = VIPS_REGION_ADDR( ir, le, y );
		VipsPel *q = VIPS_REGION_ADDR( or, le, y );

		/* Loop along line.
		 */
		for( x = 0; x &lt; sz; x++, q++, p++ ) {
			/* Search for a hit on the set list.
			 */
			result = 0;
			for( i = 0; i &lt; seq-&gt;ss; i++ )
				if( p[soff[i]] ) {
					/* Found a match! 
					 */
					result = 255;
					break;
				}

			/* No set pixels ... search for a hit in the clear
			 * pixels.
			 */
			if( !result )
				for( i = 0; i &lt; seq-&gt;cs; i++ )
					if( !p[coff[i]] ) {
						/* Found a match! 
						 */
						result = 255;
<A NAME="1"></A>						break;
					}

<FONT color="#f63526"><A HREF="javascript:ZweiFrames('match18791-1.html#1',3,'match18791-top.html#1',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>			*q = result;
		}
	}
	
	return( 0 );
}

/* Erode!
 */
static int
vips_erode_gen( VipsRegion *or, 
	void *vseq, void *a, void *b, gboolean *stop )
{
	VipsMorphSequence *seq = (VipsMorphSequence *) vseq;
	VipsMorph *morph = (VipsMorph *) b;
	VipsImage *M = morph-&gt;M;</B></FONT>
	VipsRegion *ir = seq-&gt;ir;

	int *soff = seq-&gt;soff;
	int *coff = seq-&gt;coff;

	VipsRect *r = &amp;or-&gt;valid;
	int le = r-&gt;left;
	int to = r-&gt;top;
	int bo = VIPS_RECT_BOTTOM( r );
	int sz = VIPS_REGION_N_ELEMENTS( or );

	VipsRect s;
	int x, y;
	int *t;
	int result, i;

	/* Prepare the section of the input image we need. A little larger
	 * than the section of the output image we are producing.
	 */
	s = *r;
	s.width += M-&gt;Xsize - 1;
	s.height += M-&gt;Ysize - 1;
	if( vips_region_prepare( ir, &amp;s ) )
		return( -1 );

#ifdef DEBUG_VERBOSE
	printf( &quot;vips_erode_gen: preparing %dx%d@%dx%d pixels\n&quot;, 
		s.width, s.height, s.left, s.top );
#endif /*DEBUG_VERBOSE*/

	/* Scan mask, building offsets we check when processing. Only do this
	 * if the bpl has changed since the previous vips_region_prepare().
	 */
	if( seq-&gt;last_bpl != VIPS_REGION_LSKIP( ir ) ) {
		seq-&gt;last_bpl = VIPS_REGION_LSKIP( ir );

		seq-&gt;ss = 0;
		seq-&gt;cs = 0;
		for( t = morph-&gt;coeff, y = 0; y &lt; M-&gt;Ysize; y++ )
			for( x = 0; x &lt; M-&gt;Xsize; x++, t++ )
				switch( *t ) {
				case 255:
					soff[seq-&gt;ss++] =
						VIPS_REGION_ADDR( ir, 
							x + le, y + to ) -
						VIPS_REGION_ADDR( ir, le, to );
					break;

				case 128:
					break;

				case 0:
					coff[seq-&gt;cs++] =
						VIPS_REGION_ADDR( ir, 
							x + le, y + to ) -
						VIPS_REGION_ADDR( ir, le, to );
					break;

				default:
					g_assert_not_reached();
				}
	}

	/* Erode!
	 */
	for( y = to; y &lt; bo; y++ ) {
		VipsPel *p = VIPS_REGION_ADDR( ir, le, y );
		VipsPel *q = VIPS_REGION_ADDR( or, le, y );

		/* Loop along line.
		 */
		for( x = 0; x &lt; sz; x++, q++, p++ ) {
			/* Check all set pixels are set.
			 */
			result = 255;
			for( i = 0; i &lt; seq-&gt;ss; i++ )
				if( !p[soff[i]] ) {
					/* Found a mismatch! 
					 */
					result = 0;
					break;
				}

			/* Check all clear pixels are clear.
			 */
			if( result )
				for( i = 0; i &lt; seq-&gt;cs; i++ )
					if( p[coff[i]] ) {
						result = 0;
<A NAME="0"></A>						break;
					}

<FONT color="#0000ff"><A HREF="javascript:ZweiFrames('match18791-1.html#0',3,'match18791-top.html#0',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>			*q = result;
		}
	}
	
	return( 0 );
}

/* The vector codepath.
 */
static int
vips_morph_gen_vector( VipsRegion *or, 
	void *vseq, void *a, void *b, gboolean *stop )
{
	VipsMorphSequence *seq = (VipsMorphSequence *) vseq;
	VipsMorph *morph = (VipsMorph *) b;
	VipsImage *M = morph-&gt;M;</B></FONT>
	VipsRegion *ir = seq-&gt;ir;
	VipsRect *r = &amp;or-&gt;valid;
	int sz = VIPS_REGION_N_ELEMENTS( or );

	VipsRect s;
	int y, j;
	VipsExecutor executor[MAX_PASS];

	/* Prepare the section of the input image we need. A little larger
	 * than the section of the output image we are producing.
	 */
	s = *r;
	s.width += M-&gt;Xsize - 1;
	s.height += M-&gt;Ysize - 1;
	if( vips_region_prepare( ir, &amp;s ) )
		return( -1 );

#ifdef DEBUG_VERBOSE
	printf( &quot;vips_morph_gen_vector: preparing %dx%d@%dx%d pixels\n&quot;, 
		s.width, s.height, s.left, s.top );
#endif /*DEBUG_VERBOSE*/

	for( j = 0; j &lt; morph-&gt;n_pass; j++ ) 
		vips_executor_set_program( &amp;executor[j], 
			morph-&gt;pass[j].vector, sz );

	VIPS_GATE_START( &quot;vips_morph_gen_vector: work&quot; ); 

	for( y = 0; y &lt; r-&gt;height; y++ ) { 
		for( j = 0; j &lt; morph-&gt;n_pass; j++ ) {
			void *d;

			/* The last pass goes to the output image,
			 * intermediate passes go to t2.
			 */
			if( j == morph-&gt;n_pass - 1 )
				d = VIPS_REGION_ADDR( or, r-&gt;left, r-&gt;top + y );
			else 
				d = seq-&gt;t2;

			vips_executor_set_scanline( &amp;executor[j], 
				ir, r-&gt;left, r-&gt;top + y );
			vips_executor_set_array( &amp;executor[j],
				morph-&gt;pass[j].r, seq-&gt;t1 );
			vips_executor_set_destination( &amp;executor[j], d );
			vips_executor_run( &amp;executor[j] );

			VIPS_SWAP( void *, seq-&gt;t1, seq-&gt;t2 );
		}
	}

	VIPS_GATE_STOP( &quot;vips_morph_gen_vector: work&quot; ); 

	VIPS_COUNT_PIXELS( or, &quot;vips_morph_gen_vector&quot; ); 

	return( 0 );
}

static int
vips_morph_build( VipsObject *object )
{
	VipsObjectClass *class = VIPS_OBJECT_GET_CLASS( object );
	VipsMorphology *morphology = (VipsMorphology *) object;
	VipsMorph *morph = (VipsMorph *) object;
	VipsImage **t = (VipsImage **) vips_object_local_array( object, 5 );

	VipsImage *in;
	VipsImage *M;
	VipsGenerateFn generate;
	double *coeff;
	int i;

	if( VIPS_OBJECT_CLASS( vips_morph_parent_class )-&gt;build( object ) )
		return( -1 );

	in = morphology-&gt;in;

	/* Unpack for processing.
	 */
	if( vips_image_decode( in, &amp;t[0] ) )
		return( -1 );
	in = t[0];

	if( vips_check_matrix( class-&gt;nickname, morph-&gt;mask, &amp;t[1] ) )
		return( -1 ); 
	morph-&gt;M = M = t[1];
	morph-&gt;n_point = M-&gt;Xsize * M-&gt;Ysize;

	if( vips_embed( in, &amp;t[2], 
		M-&gt;Xsize / 2, M-&gt;Ysize / 2, 
		in-&gt;Xsize + M-&gt;Xsize - 1, in-&gt;Ysize + M-&gt;Ysize - 1,
		&quot;extend&quot;, VIPS_EXTEND_COPY,
		NULL ) )
		return( -1 );
	in = t[2]; 

	/* Make sure we are uchar.
	 */
	if( vips_cast( in, &amp;t[3], VIPS_FORMAT_UCHAR, NULL ) )
		return( -1 );
	in = t[3];

	/* Make an int version of our mask.
	 */
	if( vips__image_intize( M, &amp;t[4] ) )
		return( -1 ); 
	M = t[4];

	coeff = VIPS_MATRIX( M, 0, 0 ); 
	if( !(morph-&gt;coeff = VIPS_ARRAY( object, morph-&gt;n_point, int )) )
		return( -1 );

	for( i = 0; i &lt; morph-&gt;n_point; i++ ) {
		if( coeff[i] != 0 &amp;&amp; 
			coeff[i] != 128 &amp;&amp;
			coeff[i] != 255 ) {
			vips_error( class-&gt;nickname, 
				_( &quot;bad mask element (%f &quot;
				&quot;should be 0, 128 or 255)&quot; ),
				coeff[i] );
			return( -1 );
		}
		morph-&gt;coeff[i] = coeff[i];
	}

	/* Default to the C path.
	 */
	generate = morph-&gt;morph == VIPS_OPERATION_MORPHOLOGY_DILATE
		? vips_dilate_gen : vips_erode_gen;

	/* Generate code for this mask / image, if possible.
	 */
	if( vips_vector_isenabled() ) {
		if( !vips_morph_compile( morph ) ) {
			generate = vips_morph_gen_vector;
			g_info( &quot;morph: using vector path&quot; ); 
		}
		else
			vips_morph_compile_free( morph );
	}

	g_object_set( morph, &quot;out&quot;, vips_image_new(), NULL ); 
	if( vips_image_pipelinev( morph-&gt;out, 
		VIPS_DEMAND_STYLE_SMALLTILE, in, NULL ) )
		return( -1 );

	/* Prepare output. Consider a 7x7 mask and a 7x7 image --- the output
	 * would be 1x1.
	 */
	morph-&gt;out-&gt;Xsize -= M-&gt;Xsize - 1;
	morph-&gt;out-&gt;Ysize -= M-&gt;Ysize - 1;

	if( vips_image_generate( morph-&gt;out, 
		vips_morph_start, generate, vips_morph_stop, in, morph ) )
		return( -1 );

	morph-&gt;out-&gt;Xoffset = -M-&gt;Xsize / 2;
	morph-&gt;out-&gt;Yoffset = -M-&gt;Ysize / 2;

	vips_reorder_margin_hint( morph-&gt;out, morph-&gt;n_point );

	return( 0 );
}

static void
vips_morph_class_init( VipsMorphClass *class )
{
	GObjectClass *gobject_class = G_OBJECT_CLASS( class );
	VipsObjectClass *object_class = (VipsObjectClass *) class;

	gobject_class-&gt;set_property = vips_object_set_property;
	gobject_class-&gt;get_property = vips_object_get_property;

	gobject_class-&gt;dispose = vips_morph_dispose;

	object_class-&gt;nickname = &quot;morph&quot;;
	object_class-&gt;description = _( &quot;morphology operation&quot; );
	object_class-&gt;build = vips_morph_build;

	VIPS_ARG_IMAGE( class, &quot;out&quot;, 10, 
		_( &quot;Output&quot; ), 
		_( &quot;Output image&quot; ),
		VIPS_ARGUMENT_REQUIRED_OUTPUT, 
		G_STRUCT_OFFSET( VipsMorph, out ) );

	VIPS_ARG_IMAGE( class, &quot;mask&quot;, 20, 
		_( &quot;Mask&quot; ), 
		_( &quot;Input matrix image&quot; ),
		VIPS_ARGUMENT_REQUIRED_INPUT, 
		G_STRUCT_OFFSET( VipsMorph, mask ) );

	VIPS_ARG_ENUM( class, &quot;morph&quot;, 103, 
		_( &quot;Morphology&quot; ), 
		_( &quot;Morphological operation to perform&quot; ),
		VIPS_ARGUMENT_REQUIRED_INPUT, 
		G_STRUCT_OFFSET( VipsMorph, morph ), 
		VIPS_TYPE_OPERATION_MORPHOLOGY, 
			VIPS_OPERATION_MORPHOLOGY_ERODE ); 

}

static void
vips_morph_init( VipsMorph *morph )
{
	morph-&gt;morph = VIPS_OPERATION_MORPHOLOGY_ERODE;
	morph-&gt;coeff = NULL;
}

/**
 * vips_morph: (method)
 * @in: input image
 * @out: (out): output image
 * @mask: morphology with this mask
 * @morph: operation to perform
 * @...: %NULL-terminated list of optional named arguments
 *
 * Performs a morphological operation on @in using @mask as a
 * structuring element. 
 *
 * The image should have 0 (black) for no object and 255
 * (non-zero) for an object. Note that this is the reverse of the usual
 * convention for these operations, but more convenient when combined with the
 * boolean operators. The output image is the same
 * size as the input image: edge pxels are made by expanding the input image
 * as necessary.
 *
 * Mask coefficients can be either 0 (for object) or 255 (for background) 
 * or 128 (for do not care).  The origin of the mask is at location
 * (m.xsize / 2, m.ysize / 2), integer division.  All algorithms have been 
 * based on the book &quot;Fundamentals of Digital Image Processing&quot; by A. Jain, 
 * pp 384-388, Prentice-Hall, 1989. 
 *
 * For #VIPS_OPERATION_MORPHOLOGY_ERODE, 
 * the whole mask must match for the output pixel to be
 * set, that is, the result is the logical AND of the selected input pixels.
 *
 * For #VIPS_OPERATION_MORPHOLOGY_DILATE, 
 * the output pixel is set if any part of the mask 
 * matches, that is, the result is the logical OR of the selected input pixels.
 *
 * See the boolean operations vips_andimage(), vips_orimage() and 
 * vips_eorimage() 
 * for analogues of the usual set difference and set union operations.
 *
 * Operations are performed using the processor's vector unit,
 * if possible. Disable this with --vips-novector or VIPS_NOVECTOR.
 *
 * Returns: 0 on success, -1 on error
 */
int 
vips_morph( VipsImage *in, VipsImage **out, VipsImage *mask, 
	VipsOperationMorphology morph, ... )
{
	va_list ap;
	int result;

	va_start( ap, morph );
	result = vips_call_split( &quot;morph&quot;, ap, in, out, mask, morph );
	va_end( ap );

	return( result );
}
</PRE>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>ppmload.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
/* load ppm from a file
 *
 * Stephen Chan ... original code
 *
 * 21/11/00 JC
 *	- hacked for VIPS
 *	- reads ppm/pgm/pbm
 *	- mmaps binary pgm/ppm
 *	- reads all ascii formats (slowly!)
 * 22/11/00 JC
 *	- oops, ascii read was broken
 *	- does 16/32 bit ascii now as well
 * 24/5/01
 *	- im_ppm2vips_header() added
 * 28/11/03 JC
 *	- better no-overshoot on tile loop
 * 22/5/04
 *	- does 16/32 bit binary too
 *	- tiny fix for missing file close on read error
 * 19/8/05
 * 	- use im_raw2vips() for binary read
 * 9/9/05
 * 	- tiny cleanups
 * 3/11/07
 * 	- use im_wbuffer() for bg writes
 * 1/5/10
 * 	- add PFM (portable float map) support
 * 19/12/11
 * 	- rework as a set of fns ready to be called from a class
 * 8/11/14
 * 	- add 1 bit write
 * 29/7/19 Kyle-Kyle
 * 	- fix a loop with malformed ppm
 * 13/11/19
 * 	- redone with source/target
 * 	- sequential load, plus mmap for filename sources
 * 	- faster plus lower memory use
 * 02/02/20
 * 	- ban max_vaue &lt; 0 
 * 27/6/20
 * 	- add ppmload_source
 * 22/11/20
 * 	- fix msb_first default [ewelot]
 * 26/12/20
 * 	- don't byteswap ascii formats
 * 	- set metadata for map loads
 * 	- byteswap binary loads
 */

/*

    This file is part of VIPS.
    
    VIPS is free software; you can redistribute it and/or modify
    it under the terms of the GNU Lesser General Public License as published by
    the Free Software Foundation; either version 2 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public License
    along with this program; if not, write to the Free Software
    Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
    02110-1301  USA

 */

/*

    These files are distributed with VIPS - http://www.vips.ecs.soton.ac.uk

 */

/*
#define DEBUG
 */

#ifdef HAVE_CONFIG_H
#include &lt;config.h&gt;
#endif /*HAVE_CONFIG_H*/
#include &lt;vips/intl.h&gt;

#include &lt;ctype.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;

#include &lt;vips/vips.h&gt;
#include &lt;vips/internal.h&gt;

#include &quot;pforeign.h&quot;

#ifdef HAVE_PPM

typedef struct _VipsForeignLoadPpm {
	VipsForeignLoad parent_object;

	/* The source we load from, and the buffered wrapper for it.
	 */
	VipsSource *source;
	VipsSbuf *sbuf;

	/* Properties of this ppm, from the header.
	 */
	int width;
	int height;
	int bands;
	VipsBandFormat format;
	VipsInterpretation interpretation;
	float scale;
	int max_value;
	int index;		/* ppm type .. index in magic_names[] */
	int bits;		/* 1, 8, 16 or 32 */
	gboolean ascii;		/* TRUE for ascii encoding */
	gboolean msb_first;	/* TRUE if most sig byte is first */

	gboolean have_read_header;

} VipsForeignLoadPpm;

typedef VipsForeignLoadClass VipsForeignLoadPpmClass;

G_DEFINE_ABSTRACT_TYPE( VipsForeignLoadPpm, vips_foreign_load_ppm, 
	VIPS_TYPE_FOREIGN_LOAD );

/* ppm types.
 */
static char *magic_names[] = {
	&quot;P1&quot;,	/* pbm ... 1 band 1 bit, ascii */
	&quot;P2&quot;,	/* pgm ... 1 band many bit, ascii */
	&quot;P3&quot;,	/* ppm ... 3 band many bit, ascii */
	&quot;P4&quot;,	/* pbm ... 1 band 1 bit, binary */
	&quot;P5&quot;,	/* pgm ... 1 band 8 bit, binary */
	&quot;P6&quot;,	/* ppm ... 3 band 8 bit, binary */
	&quot;PF&quot;,	/* pfm ... 3 band 32 bit, binary */
	&quot;Pf&quot;	/* pfm ... 1 band 32 bit, binary */
};

/* Shared with ppmsave.
 */
const char *vips__ppm_suffs[] = { &quot;.ppm&quot;, &quot;.pgm&quot;, &quot;.pbm&quot;, &quot;.pfm&quot;, NULL };

static gboolean
vips_foreign_load_ppm_is_a_source( VipsSource *source )
{
	const unsigned char *data;

	if( (data = vips_source_sniff( source, 2 )) ) { 
		int i;

		for( i = 0; i &lt; VIPS_NUMBER( magic_names ); i++ )
			if( vips_isprefix( magic_names[i], (char *) data ) )
				return( TRUE );
	}

	return( FALSE );
}

static int
get_int( VipsSbuf *sbuf, int *i )
{
	const char *txt;

	if( vips_sbuf_skip_whitespace( sbuf ) ||
		!(txt = vips_sbuf_get_non_whitespace( sbuf )) )
		return( -1 );

	*i = atoi( txt ); 

	return( 0 );
}

static int
get_float( VipsSbuf *sbuf, float *f )
{
	const char *txt;

	if( vips_sbuf_skip_whitespace( sbuf ) ||
		!(txt = vips_sbuf_get_non_whitespace( sbuf )) )
		return( -1 );

	/* We don't want the locale str -&gt; float conversion.
	 */
	*f = g_ascii_strtod( txt, NULL );

	return( 0 );
}

static void
vips_foreign_load_ppm_dispose( GObject *gobject )
{
	VipsForeignLoadPpm *ppm = (VipsForeignLoadPpm *) gobject;

#ifdef DEBUG
	printf( &quot;vips_foreign_load_ppm_dispose: %p\n&quot;, ppm );
#endif /*DEBUG*/

	VIPS_UNREF( ppm-&gt;sbuf );
	VIPS_UNREF( ppm-&gt;source );

	G_OBJECT_CLASS( vips_foreign_load_ppm_parent_class )-&gt;
		dispose( gobject );
}

static int
vips_foreign_load_ppm_build( VipsObject *object )
{
	VipsForeignLoadPpm *ppm = (VipsForeignLoadPpm *) object;

	if( ppm-&gt;source ) 
		ppm-&gt;sbuf = vips_sbuf_new_from_source( ppm-&gt;source );

	if( VIPS_OBJECT_CLASS( vips_foreign_load_ppm_parent_class )-&gt;
		build( object ) )
		return( -1 );

	return( 0 );
}

/* Scan the header into our class.
 */
static int
vips_foreign_load_ppm_parse_header( VipsForeignLoadPpm *ppm )
{
	VipsObjectClass *class = VIPS_OBJECT_GET_CLASS( ppm );

	int i;
	char buf[2];

	/* Characteristics, indexed by ppm type.
	 */
	static int lookup_bits[] = {
		1, 8, 8, 1, 8, 8, 32, 32
	};
	static int lookup_bands[] = {
		1, 1, 3, 1, 1, 3, 3, 1
	};
	static int lookup_ascii[] = {
		1, 1, 1, 0, 0, 0, 0, 0
	};

	if( vips_source_rewind( ppm-&gt;source ) )
		return( -1 );

	/* Read in the magic number.
	 */
	buf[0] = VIPS_SBUF_GETC( ppm-&gt;sbuf );
	buf[1] = VIPS_SBUF_GETC( ppm-&gt;sbuf );

	for( i = 0; i &lt; VIPS_NUMBER( magic_names ); i++ )
		if( vips_isprefix( magic_names[i], buf ) ) 
			break;
	if( i == VIPS_NUMBER( magic_names ) ) {
		vips_error( class-&gt;nickname, &quot;%s&quot;, _( &quot;bad magic number&quot; ) );
		return( -1 );
	}
	ppm-&gt;index = i;
	ppm-&gt;bits = lookup_bits[i];
	ppm-&gt;bands = lookup_bands[i];
	ppm-&gt;ascii = lookup_ascii[i];

	/* Default ... can be changed below for PFM images.
	 */
	ppm-&gt;msb_first = 1;

	/* Read in size.
	 */
	if( get_int( ppm-&gt;sbuf, &amp;ppm-&gt;width ) ||
		get_int( ppm-&gt;sbuf, &amp;ppm-&gt;height ) )
		return( -1 );

	/* Read in max value / scale for &gt;1 bit images.
	 */
	if( ppm-&gt;bits &gt; 1 ) {
		if( ppm-&gt;index == 6 || 
			ppm-&gt;index == 7 ) {
			if( get_float( ppm-&gt;sbuf, &amp;ppm-&gt;scale ) )
				return( -1 );

			/* Scale &gt; 0 means big-endian.
			 */
			ppm-&gt;msb_first = ppm-&gt;scale &gt; 0;
		}
		else {
			if( get_int( ppm-&gt;sbuf, &amp;ppm-&gt;max_value ) )
				return( -1 );

			/* max_value must be &gt; 0 and &lt;= 65535, according to
			 * the spec, but we allow up to 32 bits per pixel.
			 */
			if( ppm-&gt;max_value &lt; 0 )
				ppm-&gt;max_value = 0;

			if( ppm-&gt;max_value &gt; 255 )
				ppm-&gt;bits = 16;
			if( ppm-&gt;max_value &gt; 65535 )
				ppm-&gt;bits = 32;
		}
	}

	/* For binary images, there is always exactly 1 more whitespace
	 * character before the data starts.
	 */
	if( !ppm-&gt;ascii &amp;&amp; 
		!isspace( VIPS_SBUF_GETC( ppm-&gt;sbuf ) ) ) {
		vips_error( class-&gt;nickname, &quot;%s&quot;, 
			_( &quot;no whitespace before start of binary data&quot; ) );
		return( -1 );
	}

	/* Choose a VIPS bandfmt.
	 */
	switch( ppm-&gt;bits ) {
	case 1:
	case 8:
		ppm-&gt;format = VIPS_FORMAT_UCHAR;
		break;

	case 16:
		ppm-&gt;format = VIPS_FORMAT_USHORT;
		break;

	case 32:
		if( ppm-&gt;index == 6 || 
			ppm-&gt;index == 7 )
			ppm-&gt;format = VIPS_FORMAT_FLOAT;
		else
			ppm-&gt;format = VIPS_FORMAT_UINT;
		break;

	default:
		g_assert_not_reached();

		/* Stop compiler warnings.
		 */
		ppm-&gt;format = VIPS_FORMAT_UCHAR;
	}

	if( ppm-&gt;bands == 1 ) {
		if( ppm-&gt;format == VIPS_FORMAT_USHORT )
			ppm-&gt;interpretation = VIPS_INTERPRETATION_GREY16;
		else
			ppm-&gt;interpretation = VIPS_INTERPRETATION_B_W;
	}
	else {
		if( ppm-&gt;format == VIPS_FORMAT_USHORT )
			ppm-&gt;interpretation = VIPS_INTERPRETATION_RGB16;
		else 
			ppm-&gt;interpretation = VIPS_INTERPRETATION_sRGB;
	}

	ppm-&gt;have_read_header = TRUE;

#ifdef DEBUG
	printf( &quot;vips_foreign_load_ppm_parse_header:\n&quot; ); 
	printf( &quot;\twidth = %d\n&quot;, ppm-&gt;width ); 
	printf( &quot;\theight = %d\n&quot;, ppm-&gt;height ); 
	printf( &quot;\tbands = %d\n&quot;, ppm-&gt;bands ); 
	printf( &quot;\tformat = %s\n&quot;,
		vips_enum_nick( VIPS_TYPE_BAND_FORMAT, 
			ppm-&gt;format ) );
	printf( &quot;\tinterpretation = %s\n&quot;,
		vips_enum_nick( VIPS_TYPE_INTERPRETATION, 
			ppm-&gt;interpretation ) );
	printf( &quot;\tscale = %g\n&quot;, ppm-&gt;scale ); 
	printf( &quot;\tmax_value = %d\n&quot;, ppm-&gt;max_value ); 
	printf( &quot;\tbits = %d\n&quot;, ppm-&gt;bits ); 
	printf( &quot;\tacsii = %d\n&quot;, ppm-&gt;ascii ); 
	printf( &quot;\tmsb_first = %d\n&quot;, ppm-&gt;msb_first ); 
#endif /*DEBUG*/

	return( 0 );
}

static VipsForeignFlags
vips_foreign_load_ppm_get_flags( VipsForeignLoad *load )
{
	VipsForeignLoadPpm *ppm = (VipsForeignLoadPpm *) load;

	VipsForeignFlags flags;

	flags = 0;

	/* If this source supports fast mmap and this PPM is &gt;=8 bit binary,
	 * then we can mmap the file and support partial load. Otherwise,
	 * it's sequential.
	 */
	if( !ppm-&gt;have_read_header &amp;&amp;
		vips_foreign_load_ppm_parse_header( ppm ) )
		return( 0 );
	if( vips_source_is_mappable( ppm-&gt;source ) &amp;&amp;
		!ppm-&gt;ascii &amp;&amp; 
		ppm-&gt;bits &gt;= 8 )
		flags |= VIPS_FOREIGN_PARTIAL;
	else
		flags |= VIPS_FOREIGN_SEQUENTIAL;

	return( flags );
}

static void
vips_foreign_load_ppm_set_image_metadata( VipsForeignLoadPpm *ppm, 
	VipsImage *image )
{
	image-&gt;Type = ppm-&gt;interpretation;

	if( ppm-&gt;index == 6 || 
		ppm-&gt;index == 7 ) 
		vips_image_set_double( image, 
			&quot;pfm-scale&quot;, VIPS_FABS( ppm-&gt;scale ) );
	else
		vips_image_set_double( image, 
			&quot;ppm-max-value&quot;, VIPS_ABS( ppm-&gt;max_value ) );

	VIPS_SETSTR( image-&gt;filename, vips_connection_filename( 
		VIPS_CONNECTION( ppm-&gt;sbuf-&gt;source ) ) );

#ifdef DEBUG
	printf( &quot;vips_foreign_load_ppm_set_image: &quot; );
	vips_object_print_summary( VIPS_OBJECT( image ) );
#endif /*DEBUG*/
}

static void
vips_foreign_load_ppm_set_image( VipsForeignLoadPpm *ppm, VipsImage *image )
{
	vips_image_init_fields( image,
		ppm-&gt;width, ppm-&gt;height, ppm-&gt;bands, ppm-&gt;format, 
		VIPS_CODING_NONE, ppm-&gt;interpretation, 1.0, 1.0 );

        (void) vips_image_pipelinev( image, VIPS_DEMAND_STYLE_THINSTRIP, NULL );

	vips_foreign_load_ppm_set_image_metadata( ppm, image );

#ifdef DEBUG
	printf( &quot;vips_foreign_load_ppm_set_image: &quot; );
	vips_object_print_summary( VIPS_OBJECT( image ) );
#endif /*DEBUG*/
}

static int
vips_foreign_load_ppm_header( VipsForeignLoad *load )
{
	VipsForeignLoadPpm *ppm = (VipsForeignLoadPpm *) load;

	if( !ppm-&gt;have_read_header &amp;&amp;
		vips_foreign_load_ppm_parse_header( ppm ) )
		return( 0 );

	vips_foreign_load_ppm_set_image( ppm, load-&gt;out );

	vips_source_minimise( ppm-&gt;source );

	return( 0 );
}

/* Read a ppm/pgm file using mmap().
 */
static VipsImage *
vips_foreign_load_ppm_map( VipsForeignLoadPpm *ppm )
{
	gint64 header_offset;
	size_t length;
	const void *data;
	VipsImage *out;

#ifdef DEBUG
	printf( &quot;vips_foreign_load_ppm_map:\n&quot; );
#endif /*DEBUG*/

	vips_sbuf_unbuffer( ppm-&gt;sbuf );
	header_offset = vips_source_seek( ppm-&gt;source, 0, SEEK_CUR );
	data = vips_source_map( ppm-&gt;source, &amp;length );
	if( header_offset &lt; 0 || 
		!data )
		return( NULL );
	data += header_offset;
       	length -= header_offset;

	if( !(out = vips_image_new_from_memory( data, length,
		ppm-&gt;width, ppm-&gt;height, ppm-&gt;bands, ppm-&gt;format )) )
		return( NULL );

	vips_foreign_load_ppm_set_image_metadata( ppm, out );

	return( out );
}

static int
vips_foreign_load_ppm_generate_binary( VipsRegion *or, 
	void *seq, void *a, void *b, gboolean *stop )
{
        VipsRect *r = &amp;or-&gt;valid;
	VipsForeignLoadPpm *ppm = (VipsForeignLoadPpm *) a;
	VipsObjectClass *class = VIPS_OBJECT_GET_CLASS( ppm );
	VipsImage *image = or-&gt;im;
	size_t sizeof_line = VIPS_IMAGE_SIZEOF_LINE( image );

	int y;

	for( y = 0; y &lt; r-&gt;height; y++ ) {
		VipsPel *q = VIPS_REGION_ADDR( or, 0, r-&gt;top + y );

		size_t n_bytes;

		n_bytes = sizeof_line;
		while( n_bytes &gt; 0 ) {
			gint64 bytes_read;

			bytes_read = 
				vips_source_read( ppm-&gt;source, q, n_bytes );
			if( bytes_read &lt; 0 ) 
				return( -1 );
			if( bytes_read == 0 ) {
				vips_error( class-&gt;nickname, 
					&quot;%s&quot;, _( &quot;file truncated&quot; ) );
				return( -1 );
<A NAME="1"></A>			}

			q += bytes_read;
<FONT color="#f63526"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match18791-0.html#1',2,'match18791-top.html#1',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>			n_bytes -= bytes_read;
		}
	}

	return( 0 );
}

static int
vips_foreign_load_ppm_generate_1bit_ascii( VipsRegion *or, 
	void *seq, void *a, void *b, gboolean *stop )
{
        VipsRect *r = &amp;or-&gt;valid;
	VipsForeignLoadPpm *ppm = (VipsForeignLoadPpm *) a;
	VipsImage *image = or-&gt;im;</B></FONT>

	int x, y;

	for( y = 0; y &lt; r-&gt;height; y++ ) {
		VipsPel *q = VIPS_REGION_ADDR( or, 0, r-&gt;top + y );

		for( x = 0; x &lt; image-&gt;Xsize; x++ ) {
			int val;

			if( get_int( ppm-&gt;sbuf, &amp;val ) )
				return( -1 );

<A NAME="0"></A>			if( val )
				q[x] = 0;
			else
<FONT color="#0000ff"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match18791-0.html#0',2,'match18791-top.html#0',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>				q[x] = 255;
		}
	}

	return( 0 );
}

static int
vips_foreign_load_ppm_generate_1bit_binary( VipsRegion *or, 
	void *seq, void *a, void *b, gboolean *stop )
{
        VipsRect *r = &amp;or-&gt;valid;
	VipsForeignLoadPpm *ppm = (VipsForeignLoadPpm *) a;
	VipsImage *image = or-&gt;im;</B></FONT>

	int x, y;

	for( y = 0; y &lt; r-&gt;height; y++ ) {
		VipsPel *q = VIPS_REGION_ADDR( or, 0, r-&gt;top + y );

		int bits;

		/* Not needed, but stop a compiler warning.
		 */
		bits = 0;

		for( x = 0; x &lt; image-&gt;Xsize; x++ ) {
			if( (x &amp; 7) == 0 )
				bits = VIPS_SBUF_GETC( ppm-&gt;sbuf );
<A NAME="2"></A>			q[x] = (bits &amp; 128) ? 0 : 255;
			bits = VIPS_LSHIFT_INT( bits, 1 );
		}
<FONT color="#980517"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match18791-0.html#2',2,'match18791-top.html#2',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>	}

	return( 0 );
}

static int
vips_foreign_load_ppm_generate_ascii_int( VipsRegion *or, 
	void *seq, void *a, void *b, gboolean *stop )
{
        VipsRect *r = &amp;or-&gt;valid;
	VipsForeignLoadPpm *ppm = (VipsForeignLoadPpm *) a;
	VipsImage *image = or-&gt;im;</B></FONT>
	int n_elements = image-&gt;Xsize * image-&gt;Bands;

	int i, y;

	for( y = 0; y &lt; r-&gt;height; y++ ) {
		VipsPel *q = VIPS_REGION_ADDR( or, r-&gt;left, r-&gt;top + y );

		for( i = 0; i &lt; n_elements; i++ ) {
			int val;

			if( get_int( ppm-&gt;sbuf, &amp;val ) )
				return( -1 );
			
			switch( image-&gt;BandFmt ) {
			case VIPS_FORMAT_UCHAR:
				q[i] = VIPS_CLIP( 0, val, 255 );
				break;

			case VIPS_FORMAT_USHORT:
				((unsigned short *) q)[i] = 
					VIPS_CLIP( 0, val, 65535 );
				break;

			case VIPS_FORMAT_UINT:
				((unsigned int *) q)[i] = val;
				break;

			default:
				g_assert_not_reached();
			}
		}
	}

	return( 0 );
}

static VipsImage *
vips_foreign_load_ppm_scan( VipsForeignLoadPpm *ppm )
{
	VipsImage **t = (VipsImage **) 
		vips_object_local_array( VIPS_OBJECT( ppm ), 2 );

	VipsImage *out;
	VipsGenerateFn generate;

	/* What sort of read are we doing?
	 */
	if( !ppm-&gt;ascii &amp;&amp; ppm-&gt;bits &gt;= 8 ) {
#ifdef DEBUG
		printf( &quot;vips_foreign_load_ppm_source: &gt;1 bit binary load\n&quot; );
#endif /*DEBUG*/

		generate = vips_foreign_load_ppm_generate_binary;

		/* The binary loader does not use the buffered IO 
		 * object.
		 */
		vips_sbuf_unbuffer( ppm-&gt;sbuf ); 
	}
	else if( !ppm-&gt;ascii &amp;&amp; ppm-&gt;bits == 1 ) {
#ifdef DEBUG
		printf( &quot;vips_foreign_load_ppm_source: 1-bit binary load\n&quot; );
#endif /*DEBUG*/

		generate = vips_foreign_load_ppm_generate_1bit_binary;
	}
	else if( ppm-&gt;ascii &amp;&amp; ppm-&gt;bits == 1 ) {
#ifdef DEBUG
		printf( &quot;vips_foreign_load_ppm_source: 1-bit ascii load\n&quot; );
#endif /*DEBUG*/

		generate = vips_foreign_load_ppm_generate_1bit_ascii;
	}
	else {
#ifdef DEBUG
		printf( &quot;vips_foreign_load_ppm_source: &gt;1-bit ascii load\n&quot; );
#endif /*DEBUG*/

		generate = vips_foreign_load_ppm_generate_ascii_int;
	}

	t[0] = vips_image_new(); 
	vips_foreign_load_ppm_set_image( ppm, t[0] );
	if( vips_image_generate( t[0], NULL, generate, NULL, ppm, NULL ) ||
		vips_sequential( t[0], &amp;out, NULL ) )
		return( NULL );

	return( out );
}

static int
vips_foreign_load_ppm_load( VipsForeignLoad *load )
{
	VipsForeignLoadPpm *ppm = (VipsForeignLoadPpm *) load;
	VipsImage **t = (VipsImage **) 
		vips_object_local_array( (VipsObject *) load, 2 );

	if( !ppm-&gt;have_read_header &amp;&amp;
		vips_foreign_load_ppm_parse_header( ppm ) )
		return( 0 );

	/* If the source is mappable and this is a binary file, we can map it.
	 */
	if( vips_source_is_mappable( ppm-&gt;source ) &amp;&amp;
		!ppm-&gt;ascii &amp;&amp; 
		ppm-&gt;bits &gt;= 8 ) {
		if( !(t[0] = vips_foreign_load_ppm_map( ppm )) ) 
			return( -1 );
	}
	else {
		if( !(t[0] = vips_foreign_load_ppm_scan( ppm )) ) 
			return( -1 );
	}

#ifdef DEBUG
	printf( &quot;vips_foreign_load_ppm: byteswap = %d\n&quot;, 
		vips_amiMSBfirst() != ppm-&gt;msb_first );
#endif /*DEBUG*/

	/* Don't byteswap the ascii formats.
	 */
	if( vips__byteswap_bool( t[0], &amp;t[1],
			!ppm-&gt;ascii &amp;&amp;
                        vips_amiMSBfirst() != ppm-&gt;msb_first ) ||
		vips_image_write( t[1], load-&gt;real ) ) 
		return( -1 );

	if( vips_source_decode( ppm-&gt;source ) )
		return( -1 );

	return( 0 );
}

static void
vips_foreign_load_ppm_class_init( VipsForeignLoadPpmClass *class )
{
	GObjectClass *gobject_class = G_OBJECT_CLASS( class );
	VipsObjectClass *object_class = (VipsObjectClass *) class;
	VipsForeignClass *foreign_class = (VipsForeignClass *) class;
	VipsForeignLoadClass *load_class = (VipsForeignLoadClass *) class;

	gobject_class-&gt;dispose = vips_foreign_load_ppm_dispose;
	gobject_class-&gt;set_property = vips_object_set_property;
	gobject_class-&gt;get_property = vips_object_get_property;

	object_class-&gt;nickname = &quot;ppmload_base&quot;;
	object_class-&gt;description = _( &quot;load ppm base class&quot; );
	object_class-&gt;build = vips_foreign_load_ppm_build;

	foreign_class-&gt;suffs = vips__ppm_suffs;

	/* We are fast at is_a(), so high priority.
	 */
	foreign_class-&gt;priority = 200;

	load_class-&gt;get_flags = vips_foreign_load_ppm_get_flags;
	load_class-&gt;header = vips_foreign_load_ppm_header;
	load_class-&gt;load = vips_foreign_load_ppm_load;

}

static void
vips_foreign_load_ppm_init( VipsForeignLoadPpm *ppm )
{
	ppm-&gt;scale = 1.0;
}

typedef struct _VipsForeignLoadPpmFile {
	VipsForeignLoadPpm parent_object;

	char *filename;

} VipsForeignLoadPpmFile;

typedef VipsForeignLoadPpmClass VipsForeignLoadPpmFileClass;

G_DEFINE_TYPE( VipsForeignLoadPpmFile, vips_foreign_load_ppm_file, 
	vips_foreign_load_ppm_get_type() );

static gboolean
vips_foreign_load_ppm_file_is_a( const char *filename )
{
	VipsSource *source;
	gboolean result;

	if( !(source = vips_source_new_from_file( filename )) )
		return( FALSE );
	result = vips_foreign_load_ppm_is_a_source( source );
	VIPS_UNREF( source );

	return( result );
}

static int
vips_foreign_load_ppm_file_build( VipsObject *object )
{
	VipsForeignLoadPpmFile *file = (VipsForeignLoadPpmFile *) object;
	VipsForeignLoadPpm *ppm = (VipsForeignLoadPpm *) object;

	if( file-&gt;filename &amp;&amp;
		!(ppm-&gt;source = vips_source_new_from_file( file-&gt;filename )) )
		return( -1 );

	if( VIPS_OBJECT_CLASS( vips_foreign_load_ppm_file_parent_class )-&gt;
		build( object ) )
		return( -1 );

	return( 0 );
}

static void
vips_foreign_load_ppm_file_class_init( VipsForeignLoadPpmClass *class )
{
	GObjectClass *gobject_class = G_OBJECT_CLASS( class );
	VipsObjectClass *object_class = (VipsObjectClass *) class;
	VipsForeignLoadClass *load_class = (VipsForeignLoadClass *) class;

	gobject_class-&gt;set_property = vips_object_set_property;
	gobject_class-&gt;get_property = vips_object_get_property;

	object_class-&gt;nickname = &quot;ppmload&quot;;
	object_class-&gt;description = _( &quot;load ppm from file&quot; );
	object_class-&gt;build = vips_foreign_load_ppm_file_build;

	load_class-&gt;is_a = vips_foreign_load_ppm_file_is_a;

	VIPS_ARG_STRING( class, &quot;filename&quot;, 1, 
		_( &quot;Filename&quot; ),
		_( &quot;Filename to load from&quot; ),
		VIPS_ARGUMENT_REQUIRED_INPUT, 
		G_STRUCT_OFFSET( VipsForeignLoadPpmFile, filename ),
		NULL );
}

static void
vips_foreign_load_ppm_file_init( VipsForeignLoadPpmFile *file )
{
}

typedef struct _VipsForeignLoadPpmSource {
	VipsForeignLoadPpm parent_object;

	VipsSource *source;

} VipsForeignLoadPpmSource;

typedef VipsForeignLoadPpmClass VipsForeignLoadPpmSourceClass;

G_DEFINE_TYPE( VipsForeignLoadPpmSource, vips_foreign_load_ppm_source,
	vips_foreign_load_ppm_get_type() );

static int
vips_foreign_load_ppm_source_build( VipsObject *object )
{
	VipsForeignLoadPpm *ppm = (VipsForeignLoadPpm *) object;
	VipsForeignLoadPpmSource *source = (VipsForeignLoadPpmSource *) object;

	if( source-&gt;source ) {
		ppm-&gt;source = source-&gt;source;
		g_object_ref( ppm-&gt;source );
	}

	if( VIPS_OBJECT_CLASS( vips_foreign_load_ppm_source_parent_class )-&gt;
		build( object ) )
		return( -1 );

	return( 0 );
}

static void
vips_foreign_load_ppm_source_class_init( VipsForeignLoadPpmFileClass *class )
{
	GObjectClass *gobject_class = G_OBJECT_CLASS( class );
	VipsObjectClass *object_class = (VipsObjectClass *) class;
	VipsForeignLoadClass *load_class = (VipsForeignLoadClass *) class;

	gobject_class-&gt;set_property = vips_object_set_property;
	gobject_class-&gt;get_property = vips_object_get_property;

	object_class-&gt;nickname = &quot;ppmload_source&quot;;
	object_class-&gt;build = vips_foreign_load_ppm_source_build;

	load_class-&gt;is_a_source = vips_foreign_load_ppm_is_a_source;

	VIPS_ARG_OBJECT( class, &quot;source&quot;, 1,
		_( &quot;Source&quot; ),
		_( &quot;Source to load from&quot; ),
		VIPS_ARGUMENT_REQUIRED_INPUT, 
		G_STRUCT_OFFSET( VipsForeignLoadPpmSource, source ),
		VIPS_TYPE_SOURCE );

}

static void
vips_foreign_load_ppm_source_init( VipsForeignLoadPpmSource *source )
{
}

#endif /*HAVE_PPM*/

/**
 * vips_ppmload:
 * @filename: file to load
 * @out: (out): output image
 * @...: %NULL-terminated list of optional named arguments
 *
 * Read a PPM/PBM/PGM/PFM file into a VIPS image. 
 *
 * It can read 1, 8, 16 and 32 bit images, colour or monochrome,
 * stored in binary or in ASCII. One bit images become 8 bit VIPS images, 
 * with 0 and 255 for 0 and 1.
 *
 * See also: vips_image_new_from_file().
 *
 * Returns: 0 on success, -1 on error.
 */
int
vips_ppmload( const char *filename, VipsImage **out, ... )
{
	va_list ap;
	int result;

	va_start( ap, out );
	result = vips_call_split( &quot;ppmload&quot;, ap, filename, out ); 
	va_end( ap );

	return( result );
}

/**
 * vips_ppmload_source:
 * @source: source to load
 * @out: (out): output image
 * @...: %NULL-terminated list of optional named arguments
 *
 * Optional arguments:
 *
 * * @skip: skip this many lines at start of file
 * * @lines: read this many lines from file
 * * @whitespace: set of whitespace characters
 * * @separator: set of separator characters
 * * @fail: %gboolean, fail on errors
 *
 * Exactly as vips_ppmload(), but read from a source. 
 *
 * See also: vips_ppmload().
 *
 * Returns: 0 on success, -1 on error.
 */
int
vips_ppmload_source( VipsSource *source, VipsImage **out, ... )
{
	va_list ap;
	int result;

	va_start( ap, out );
	result = vips_call_split( &quot;ppmload_source&quot;, ap, source, out ); 
	va_end( ap );

	return( result );
}
</PRE>
</div>
  </div>
</body>
</html>
