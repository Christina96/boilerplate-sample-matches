
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 4.422604422604422%, Tokens: 9</h2>
        <div class="column">
            <h3>libtomcrypt-MDEwOlJlcG9zaXRvcnk3NzcwMTE=-flat-gcm_mult_h.c</h3>
            <pre><code>1  #include "tomcrypt_private.h"
2  #if defined(LTC_GCM_MODE)
3  void gcm_mult_h(const gcm_state *gcm, unsigned char *I)
4  {
5     unsigned char T[16];
6  #ifdef LTC_GCM_TABLES
7     int x;
8  #ifdef LTC_GCM_TABLES_SSE2
9     asm("movdqa (%0),%%xmm0"::"r"(&gcm->PC[0][I[0]][0]));
10     for (x = 1; x < 16; x++) {
11        asm("pxor (%0),%%xmm0"::"r"(&gcm->PC[x][I[x]][0]));
12     }
13     asm("movdqa %%xmm0,(%0)"::"r"(&T));
14  #else
15     int y;
16     XMEMCPY(T, &gcm->PC[0][I[0]][0], 16);
17     for (x = 1; x < 16; x++) {
18  #ifdef LTC_FAST
<span onclick='openModal()' class='match'>19         for (y = 0; y < 16; y += sizeof(LTC_FAST_TYPE)) {
20             *(LTC_FAST_TYPE_PTR_CAST(T + y)) ^= *(LTC_FAST_TYPE_PTR_CAST(&gcm->PC[x][I[x]][y]));
21         }
22  #else
23         for (y = 0; y < 16; y++) {
24             T[y] ^= gcm->PC[x][I[x]][y];
25         }
</span>26  #endif &bsol;* LTC_FAST */
27     }
28  #endif &bsol;* LTC_GCM_TABLES_SSE2 */
29  #else
30     gcm_gf_mult(gcm->H, I, T);
31  #endif
32     XMEMCPY(I, T, 16);
33  }
34  #endif
</code></pre>
        </div>
        <div class="column">
            <h3>PINRemoteImage-MDEwOlJlcG9zaXRvcnkzOTUzNzEwMw==-flat-webp_enc.c</h3>
            <pre><code>1  #include <assert.h>
2  #include <stdlib.h>
3  #include <string.h>
4  #include <math.h>
5  #include "src/enc/cost_enc.h"
6  #include "src/enc/vp8i_enc.h"
7  #include "src/enc/vp8li_enc.h"
8  #include "src/utils/utils.h"
9  #ifdef PRINT_MEMORY_INFO
10  #include <stdio.h>
11  #endif
12  int WebPGetEncoderVersion(void) {
13    return (ENC_MAJ_VERSION << 16) | (ENC_MIN_VERSION << 8) | ENC_REV_VERSION;
14  }
15  static void ResetSegmentHeader(VP8Encoder* const enc) {
16    VP8EncSegmentHeader* const hdr = &enc->segment_hdr_;
17    hdr->num_segments_ = enc->config_->segments;
18    hdr->update_map_  = (hdr->num_segments_ > 1);
19    hdr->size_ = 0;
20  }
21  static void ResetFilterHeader(VP8Encoder* const enc) {
22    VP8EncFilterHeader* const hdr = &enc->filter_hdr_;
23    hdr->simple_ = 1;
24    hdr->level_ = 0;
25    hdr->sharpness_ = 0;
26    hdr->i4x4_lf_delta_ = 0;
27  }
28  static void ResetBoundaryPredictions(VP8Encoder* const enc) {
29    int i;
30    uint8_t* const top = enc->preds_ - enc->preds_w_;
31    uint8_t* const left = enc->preds_ - 1;
<span onclick='openModal()' class='match'>32    for (i = -1; i < 4 * enc->mb_w_; ++i) {
33      top[i] = B_DC_PRED;
34    }
35    for (i = 0; i < 4 * enc->mb_h_; ++i) {
36      left[i * enc->preds_w_] = B_DC_PRED;
37    }
</span>38    enc->nz_[-1] = 0;   
39  }
40  static void MapConfigToTools(VP8Encoder* const enc) {
41    const WebPConfig* const config = enc->config_;
42    const int method = config->method;
43    const int limit = 100 - config->partition_limit;
44    enc->method_ = method;
45    enc->rd_opt_level_ = (method >= 6) ? RD_OPT_TRELLIS_ALL
46                       : (method >= 5) ? RD_OPT_TRELLIS
47                       : (method >= 3) ? RD_OPT_BASIC
48                       : RD_OPT_NONE;
49    enc->max_i4_header_bits_ =
50        256 * 16 * 16 *                 
51        (limit * limit) / (100 * 100);  
52    enc->mb_header_limit_ =
53        (score_t)256 * 510 * 8 * 1024 / (enc->mb_w_ * enc->mb_h_);
54    enc->thread_level_ = config->thread_level;
55    enc->do_search_ = (config->target_size > 0 || config->target_PSNR > 0);
56    if (!config->low_memory) {
57  #if !defined(DISABLE_TOKEN_BUFFER)
58      enc->use_tokens_ = (enc->rd_opt_level_ >= RD_OPT_BASIC);  
59  #endif
60      if (enc->use_tokens_) {
61        enc->num_parts_ = 1;   
62      }
63    }
64  }
65  static VP8Encoder* InitVP8Encoder(const WebPConfig* const config,
66                                    WebPPicture* const picture) {
67    VP8Encoder* enc;
68    const int use_filter =
69        (config->filter_strength > 0) || (config->autofilter > 0);
70    const int mb_w = (picture->width + 15) >> 4;
71    const int mb_h = (picture->height + 15) >> 4;
72    const int preds_w = 4 * mb_w + 1;
73    const int preds_h = 4 * mb_h + 1;
74    const size_t preds_size = preds_w * preds_h * sizeof(*enc->preds_);
75    const int top_stride = mb_w * 16;
76    const size_t nz_size = (mb_w + 1) * sizeof(*enc->nz_) + WEBP_ALIGN_CST;
77    const size_t info_size = mb_w * mb_h * sizeof(*enc->mb_info_);
78    const size_t samples_size =
79        2 * top_stride * sizeof(*enc->y_top_)  
80        + WEBP_ALIGN_CST;                      
81    const size_t lf_stats_size =
82        config->autofilter ? sizeof(*enc->lf_stats_) + WEBP_ALIGN_CST : 0;
83    const size_t top_derr_size =
84        (config->quality <= ERROR_DIFFUSION_QUALITY || config->pass > 1) ?
85            mb_w * sizeof(*enc->top_derr_) : 0;
86    uint8_t* mem;
87    const uint64_t size = (uint64_t)sizeof(*enc)   
88                        + WEBP_ALIGN_CST           
89                        + info_size                
90                        + preds_size               
91                        + samples_size             
92                        + top_derr_size            
93                        + nz_size                  
94                        + lf_stats_size;           
95  #ifdef PRINT_MEMORY_INFO
96    printf("===================================\n");
97    printf("Memory used:\n"
98           "             encoder: %ld\n"
99           "                info: %ld\n"
100           "               preds: %ld\n"
101           "         top samples: %ld\n"
102           "       top diffusion: %ld\n"
103           "            non-zero: %ld\n"
104           "            lf-stats: %ld\n"
105           "               total: %ld\n",
106           sizeof(*enc) + WEBP_ALIGN_CST, info_size,
107           preds_size, samples_size, top_derr_size, nz_size, lf_stats_size, size);
108    printf("Transient object sizes:\n"
109           "      VP8EncIterator: %ld\n"
110           "        VP8ModeScore: %ld\n"
111           "      VP8SegmentInfo: %ld\n"
112           "         VP8EncProba: %ld\n"
113           "             LFStats: %ld\n",
114           sizeof(VP8EncIterator), sizeof(VP8ModeScore),
115           sizeof(VP8SegmentInfo), sizeof(VP8EncProba),
116           sizeof(LFStats));
117    printf("Picture size (yuv): %ld\n",
118           mb_w * mb_h * 384 * sizeof(uint8_t));
119    printf("===================================\n");
120  #endif
121    mem = (uint8_t*)WebPSafeMalloc(size, sizeof(*mem));
122    if (mem == NULL) {
123      WebPEncodingSetError(picture, VP8_ENC_ERROR_OUT_OF_MEMORY);
124      return NULL;
125    }
126    enc = (VP8Encoder*)mem;
127    mem = (uint8_t*)WEBP_ALIGN(mem + sizeof(*enc));
128    memset(enc, 0, sizeof(*enc));
129    enc->num_parts_ = 1 << config->partitions;
130    enc->mb_w_ = mb_w;
131    enc->mb_h_ = mb_h;
132    enc->preds_w_ = preds_w;
133    enc->mb_info_ = (VP8MBInfo*)mem;
134    mem += info_size;
135    enc->preds_ = mem + 1 + enc->preds_w_;
136    mem += preds_size;
137    enc->nz_ = 1 + (uint32_t*)WEBP_ALIGN(mem);
138    mem += nz_size;
139    enc->lf_stats_ = lf_stats_size ? (LFStats*)WEBP_ALIGN(mem) : NULL;
140    mem += lf_stats_size;
141    mem = (uint8_t*)WEBP_ALIGN(mem);
142    enc->y_top_ = mem;
143    enc->uv_top_ = enc->y_top_ + top_stride;
144    mem += 2 * top_stride;
145    enc->top_derr_ = top_derr_size ? (DError*)mem : NULL;
146    mem += top_derr_size;
147    assert(mem <= (uint8_t*)enc + size);
148    enc->config_ = config;
149    enc->profile_ = use_filter ? ((config->filter_type == 1) ? 0 : 1) : 2;
150    enc->pic_ = picture;
151    enc->percent_ = 0;
152    MapConfigToTools(enc);
153    VP8EncDspInit();
154    VP8DefaultProbas(enc);
155    ResetSegmentHeader(enc);
156    ResetFilterHeader(enc);
157    ResetBoundaryPredictions(enc);
158    VP8EncDspCostInit();
159    VP8EncInitAlpha(enc);
160    {
161      const float scale = 1.f + config->quality * 5.f / 100.f;  
162      VP8TBufferInit(&enc->tokens_, (int)(mb_w * mb_h * 4 * scale));
163    }
164    return enc;
165  }
166  static int DeleteVP8Encoder(VP8Encoder* enc) {
167    int ok = 1;
168    if (enc != NULL) {
169      ok = VP8EncDeleteAlpha(enc);
170      VP8TBufferClear(&enc->tokens_);
171      WebPSafeFree(enc);
172    }
173    return ok;
174  }
175  #if !defined(WEBP_DISABLE_STATS)
176  static double GetPSNR(uint64_t err, uint64_t size) {
177    return (err > 0 && size > 0) ? 10. * log10(255. * 255. * size / err) : 99.;
178  }
179  static void FinalizePSNR(const VP8Encoder* const enc) {
180    WebPAuxStats* stats = enc->pic_->stats;
181    const uint64_t size = enc->sse_count_;
182    const uint64_t* const sse = enc->sse_;
183    stats->PSNR[0] = (float)GetPSNR(sse[0], size);
184    stats->PSNR[1] = (float)GetPSNR(sse[1], size / 4);
185    stats->PSNR[2] = (float)GetPSNR(sse[2], size / 4);
186    stats->PSNR[3] = (float)GetPSNR(sse[0] + sse[1] + sse[2], size * 3 / 2);
187    stats->PSNR[4] = (float)GetPSNR(sse[3], size);
188  }
189  #endif  
190  static void StoreStats(VP8Encoder* const enc) {
191  #if !defined(WEBP_DISABLE_STATS)
192    WebPAuxStats* const stats = enc->pic_->stats;
193    if (stats != NULL) {
194      int i, s;
195      for (i = 0; i < NUM_MB_SEGMENTS; ++i) {
196        stats->segment_level[i] = enc->dqm_[i].fstrength_;
197        stats->segment_quant[i] = enc->dqm_[i].quant_;
198        for (s = 0; s <= 2; ++s) {
199          stats->residual_bytes[s][i] = enc->residual_bytes_[s][i];
200        }
201      }
202      FinalizePSNR(enc);
203      stats->coded_size = enc->coded_size_;
204      for (i = 0; i < 3; ++i) {
205        stats->block_count[i] = enc->block_count_[i];
206      }
207    }
208  #else  
209    WebPReportProgress(enc->pic_, 100, &enc->percent_);  
210  #endif  
211  }
212  int WebPEncodingSetError(const WebPPicture* const pic,
213                           WebPEncodingError error) {
214    assert((int)error < VP8_ENC_ERROR_LAST);
215    assert((int)error >= VP8_ENC_OK);
216    ((WebPPicture*)pic)->error_code = error;
217    return 0;
218  }
219  int WebPReportProgress(const WebPPicture* const pic,
220                         int percent, int* const percent_store) {
221    if (percent_store != NULL && percent != *percent_store) {
222      *percent_store = percent;
223      if (pic->progress_hook && !pic->progress_hook(percent, pic)) {
224        WebPEncodingSetError(pic, VP8_ENC_ERROR_USER_ABORT);
225        return 0;
226      }
227    }
228    return 1;  
229  }
230  int WebPEncode(const WebPConfig* config, WebPPicture* pic) {
231    int ok = 0;
232    if (pic == NULL) return 0;
233    WebPEncodingSetError(pic, VP8_ENC_OK);  
234    if (config == NULL) {  
235      return WebPEncodingSetError(pic, VP8_ENC_ERROR_NULL_PARAMETER);
236    }
237    if (!WebPValidateConfig(config)) {
238      return WebPEncodingSetError(pic, VP8_ENC_ERROR_INVALID_CONFIGURATION);
239    }
240    if (pic->width <= 0 || pic->height <= 0) {
241      return WebPEncodingSetError(pic, VP8_ENC_ERROR_BAD_DIMENSION);
242    }
243    if (pic->width > WEBP_MAX_DIMENSION || pic->height > WEBP_MAX_DIMENSION) {
244      return WebPEncodingSetError(pic, VP8_ENC_ERROR_BAD_DIMENSION);
245    }
246    if (pic->stats != NULL) memset(pic->stats, 0, sizeof(*pic->stats));
247    if (!config->lossless) {
248      VP8Encoder* enc = NULL;
249      if (pic->use_argb || pic->y == NULL || pic->u == NULL || pic->v == NULL) {
250        if (config->use_sharp_yuv || (config->preprocessing & 4)) {
251          if (!WebPPictureSharpARGBToYUVA(pic)) {
252            return 0;
253          }
254        } else {
255          float dithering = 0.f;
256          if (config->preprocessing & 2) {
257            const float x = config->quality / 100.f;
258            const float x2 = x * x;
259            dithering = 1.0f + (0.5f - 1.0f) * x2 * x2;
260          }
261          if (!WebPPictureARGBToYUVADithered(pic, WEBP_YUV420, dithering)) {
262            return 0;
263          }
264        }
265      }
266      if (!config->exact) {
267        WebPCleanupTransparentArea(pic);
268      }
269      enc = InitVP8Encoder(config, pic);
270      if (enc == NULL) return 0;  
271      ok = VP8EncAnalyze(enc);
272      ok = ok && VP8EncStartAlpha(enc);   
273      if (!enc->use_tokens_) {
274        ok = ok && VP8EncLoop(enc);
275      } else {
276        ok = ok && VP8EncTokenLoop(enc);
277      }
278      ok = ok && VP8EncFinishAlpha(enc);
279      ok = ok && VP8EncWrite(enc);
280      StoreStats(enc);
281      if (!ok) {
282        VP8EncFreeBitWriters(enc);
283      }
284      ok &= DeleteVP8Encoder(enc);  
285    } else {
286      if (pic->argb == NULL && !WebPPictureYUVAToARGB(pic)) {
287        return 0;
288      }
289      if (!config->exact) {
290        WebPCleanupTransparentAreaLossless(pic);
291      }
292      ok = VP8LEncodeImage(config, pic);  
293    }
294    return ok;
295  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from libtomcrypt-MDEwOlJlcG9zaXRvcnk3NzcwMTE=-flat-gcm_mult_h.c</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from PINRemoteImage-MDEwOlJlcG9zaXRvcnkzOTUzNzEwMw==-flat-webp_enc.c</div>
                </div>
                <div class="column column_space"><pre><code>19         for (y = 0; y < 16; y += sizeof(LTC_FAST_TYPE)) {
20             *(LTC_FAST_TYPE_PTR_CAST(T + y)) ^= *(LTC_FAST_TYPE_PTR_CAST(&gcm->PC[x][I[x]][y]));
21         }
22  #else
23         for (y = 0; y < 16; y++) {
24             T[y] ^= gcm->PC[x][I[x]][y];
25         }
</pre></code></div>
                <div class="column column_space"><pre><code>32    for (i = -1; i < 4 * enc->mb_w_; ++i) {
33      top[i] = B_DC_PRED;
34    }
35    for (i = 0; i < 4 * enc->mb_h_; ++i) {
36      left[i * enc->preds_w_] = B_DC_PRED;
37    }
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    