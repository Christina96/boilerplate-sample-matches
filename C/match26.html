<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML><HEAD><TITLE>Matches for test_run_cmd.c & test_cmd_messages_proto.c</TITLE>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
</HEAD>
<body>
  <div style="align-items: center; display: flex; justify-content: space-around;">
    <div>
      <h3 align="center">
Matches for test_run_cmd.c & test_cmd_messages_proto.c
      </h3>
      <h1 align="center">
        6.0%
      </h1>
      <center>
        <a href="index.html" target="_top">
          INDEX
        </a>
        <span>-</span>
        <a href="help-en.html" target="_top">
          HELP
        </a>
      </center>
    </div>
    <div>
<TABLE BORDER="1" CELLSPACING="0" BGCOLOR="#d0d0d0">
<TR><TH><TH>test_run_cmd.c (7.9268293%)<TH>test_cmd_messages_proto.c (4.942966%)<TH>Tokens
<TR><TD BGCOLOR="#0000ff"><FONT COLOR="#0000ff">-</FONT><TD><A HREF="javascript:ZweiFrames('match26-0.html#0',2,'match26-1.html#0',3)" NAME="0">(177-208)<TD><A HREF="javascript:ZweiFrames('match26-0.html#0',2,'match26-1.html#0',3)" NAME="0">(152-169)</A><TD ALIGN=center><FONT COLOR="#ff0000">13</FONT>
</TABLE>
    </div>
  </div>
  <hr>
  <div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>test_run_cmd.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
/* Copyright (c) 2013 William Orr &lt;will@worrbase.com&gt;
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the &quot;Software&quot;), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */
#include &quot;config.h&quot;
#include &lt;glib.h&gt;
#include &lt;string.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;sys/uio.h&gt;
#include &lt;unistd.h&gt;

#include &quot;cmd.h&quot;
#include &quot;cmd_internal.h&quot;
#include &quot;log.h&quot;

#include &quot;getpwent.h&quot;

extern char** environ;

struct test_wsh_run_cmd_data {
	wsh_cmd_req_t* req;
	wsh_cmd_res_t* res;
};

static void setup(struct test_wsh_run_cmd_data* fixture,
                  gconstpointer user_data) {
	struct test_wsh_run_cmd_data* data = fixture;
	data-&gt;req = g_slice_new0(wsh_cmd_req_t);
	data-&gt;res = g_slice_new0(wsh_cmd_res_t);

	data-&gt;req-&gt;in_fd = dup(1);
	data-&gt;req-&gt;env = g_strdupv(environ);
	data-&gt;req-&gt;cwd = &quot;/tmp&quot;;
	data-&gt;req-&gt;host = &quot;127.0.0.1&quot;;
	data-&gt;req-&gt;username = &quot;root&quot;;
	data-&gt;req-&gt;password = g_strdup(&quot;test&quot;);

	wsh_init_logger(WSH_LOGGER_SERVER);
}

static void teardown(struct test_wsh_run_cmd_data* fixture,
                     gconstpointer user_data) {
	struct test_wsh_run_cmd_data* data = fixture;

	if (data-&gt;res-&gt;err != NULL)
		g_error_free(data-&gt;res-&gt;err);

	for (gint i = 0; i &lt; data-&gt;res-&gt;std_output_len; i++) {
		g_free(data-&gt;res-&gt;std_output[i]);
	}

	for (gint i = 0; i &lt; data-&gt;res-&gt;std_error_len; i++) {
		g_free(data-&gt;res-&gt;std_error[i]);
	}

	g_strfreev(data-&gt;req-&gt;env);
	g_free(data-&gt;req-&gt;password);

	g_slice_free(wsh_cmd_req_t, data-&gt;req);
	g_slice_free(wsh_cmd_res_t, data-&gt;res);
	wsh_exit_logger();
}

static void test_run_exit_code(struct test_wsh_run_cmd_data* fixture,
                               gconstpointer user_data) {
	wsh_cmd_req_t* req = fixture-&gt;req;
	wsh_cmd_res_t* res = fixture-&gt;res;

	req-&gt;cmd_string = &quot;/bin/ls&quot;;
	gint ret = wsh_run_cmd(res, req);
	g_assert_no_error(res-&gt;err);
	g_assert(ret == 0);
	g_assert(res-&gt;exit_status == 0);

	req-&gt;cmd_string = &quot;/bin/ls this definitely will fail&quot;;
	g_assert_no_error(res-&gt;err);
	g_assert(wsh_run_cmd(res, req) == 0);
	g_assert(res-&gt;exit_status != 0);
}

static void test_run_stdout(struct test_wsh_run_cmd_data* fixture,
                            gconstpointer user_data) {
	wsh_cmd_req_t* req = fixture-&gt;req;
	wsh_cmd_res_t* res = fixture-&gt;res;

	req-&gt;cmd_string = &quot;/bin/echo foo&quot;;
	wsh_run_cmd(res, req);
	g_assert_no_error(res-&gt;err);
	g_assert(res-&gt;exit_status == 0);
	g_assert_cmpstr(res-&gt;std_output[0], ==, &quot;foo&quot;);
	g_assert(res-&gt;std_output_len == 1);

	res-&gt;std_output = NULL;
	res-&gt;std_output_len = 0;

	req-&gt;cmd_string = &quot;/bin/echo foo 1&gt;&amp;2&quot;;
	req-&gt;use_shell = TRUE;
	wsh_run_cmd(res, req);
	g_assert_no_error(res-&gt;err);
	g_assert(res-&gt;exit_status == 0);
	g_assert(res-&gt;std_output_len == 0);

	res-&gt;std_output = NULL;
	res-&gt;std_output_len = 0;

	req-&gt;cmd_string = &quot;/bin/echo -n foo&quot;;
	req-&gt;use_shell = TRUE;
	wsh_run_cmd(res, req);
	g_assert_no_error(res-&gt;err);
	g_assert(res-&gt;exit_status == 0);
	g_assert(res-&gt;std_output_len == 1);
	g_assert_cmpstr(res-&gt;std_output[0], ==, &quot;foo&quot;);
}

static void test_run_stderr(struct test_wsh_run_cmd_data* fixture,
                            gconstpointer user_data) {
	wsh_cmd_req_t* req = fixture-&gt;req;
	wsh_cmd_res_t* res = fixture-&gt;res;

	req-&gt;cmd_string = &quot;/bin/echo foo 1&gt;&amp;2&quot;;
	req-&gt;use_shell = TRUE;
	wsh_run_cmd(res, req);
	g_assert_no_error(res-&gt;err);
	g_assert(res-&gt;exit_status == 0);
	g_assert_cmpstr(res-&gt;std_error[0], ==, &quot;foo&quot;);

	res-&gt;std_error = NULL;
	res-&gt;std_error_len = 0;

	req-&gt;cmd_string = &quot;/bin/echo foo&quot;;
	wsh_run_cmd(res, req);
	g_assert_no_error(res-&gt;err);
	g_assert(res-&gt;exit_status == 0);
	g_assert(res-&gt;std_error_len == 0);
}

static void test_run_err(struct test_wsh_run_cmd_data* fixture,
                         gconstpointer user_data) {
	wsh_cmd_req_t* req = fixture-&gt;req;
	wsh_cmd_res_t* res = fixture-&gt;res;

	// Not going to test every error - just going to test that the functions
	// that produce GError's handle them appropriately
	req-&gt;cmd_string = &quot;echo fail'&quot;;
	wsh_run_cmd(res, req);
	g_assert_error(res-&gt;err, G_SHELL_ERROR, G_SHELL_ERROR_BAD_QUOTING);

	res-&gt;err = NULL;
	req-&gt;cmd_string = &quot;exit 0&quot;;
	req-&gt;use_shell = TRUE;
	req-&gt;cwd = &quot;/foobarbaz&quot;;
	wsh_run_cmd(res, req);
	g_assert_error(res-&gt;err, G_SPAWN_ERROR, G_SPAWN_ERROR_CHDIR);
}

static void test_construct_sudo_cmd(struct test_wsh_run_cmd_data* fixture,
                                    gconstpointer user_data) {
<A NAME="0"></A>	wsh_cmd_req_t* req = fixture-&gt;req;
	GError* err = NULL;

<FONT color="#0000ff"><A HREF="javascript:ZweiFrames('match26-1.html#0',3,'match26-top.html#0',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>	req-&gt;cmd_string = &quot;/bin/ls&quot;;
	req-&gt;use_shell = TRUE;
	gchar* res = wsh_construct_sudo_cmd(req, &amp;err);
	g_assert_cmpstr(res, ==, LIBEXEC_PATH&quot;/wsh-killer 0 /bin/sh -c '/bin/ls'&quot;);
	g_assert_no_error(err);
	g_free(res);

	req-&gt;sudo = TRUE;
	req-&gt;use_shell = TRUE;
	res = wsh_construct_sudo_cmd(req, &amp;err);
	g_assert_cmpstr(res, ==,
	                &quot;sudo -sA -u root &quot;LIBEXEC_PATH&quot;/wsh-killer 0 /bin/sh -c '/bin/ls'&quot;);
	g_assert_no_error(err);
	g_free(res);

	req-&gt;username = &quot;worr&quot;;
	req-&gt;use_shell = TRUE;
	res = wsh_construct_sudo_cmd(req, &amp;err);
	g_assert_cmpstr(res, ==,
	                &quot;sudo -sA -u worr &quot;LIBEXEC_PATH&quot;/wsh-killer 0 /bin/sh -c '/bin/ls'&quot;);
	g_assert_no_error(err);
	g_free(res);

	req-&gt;username = &quot;&quot;;
	req-&gt;use_shell = TRUE;
	res = wsh_construct_sudo_cmd(req, &amp;err);
	g_assert_cmpstr(res, ==,
	                &quot;sudo -sA -u root &quot;LIBEXEC_PATH&quot;/wsh-killer 0 /bin/sh -c '/bin/ls'&quot;);
	g_assert_no_error(err);
	g_free(res);

	req-&gt;username = &quot; &quot;;</B></FONT>
	res = wsh_construct_sudo_cmd(req, &amp;err);
	g_assert_cmpstr(res, ==, NULL);
	g_assert_error(err, WSH_CMD_ERROR, WSH_CMD_PW_ERR);
	g_error_free(err);
	err = NULL;
	g_free(res);

	req-&gt;cmd_string = &quot;&quot;;
	req-&gt;username = &quot;&quot;;
	res = wsh_construct_sudo_cmd(req, &amp;err);
	g_assert_no_error(err);
	g_assert(res == NULL);

	req-&gt;cmd_string = NULL;
	res = wsh_construct_sudo_cmd(req, &amp;err);
	g_assert_no_error(err);
	g_assert(res == NULL);
}

static void test_wsh_run_cmd_path(struct test_wsh_run_cmd_data* fixture,
                                  gconstpointer user_data) {
	wsh_cmd_req_t* req = fixture-&gt;req;
	wsh_cmd_res_t* res = fixture-&gt;res;

	req-&gt;cmd_string = &quot;ls&quot;;
	wsh_run_cmd(res, req);
	g_assert(res-&gt;exit_status == 0);
}

static void test_wsh_run_cmd_timeout(struct test_wsh_run_cmd_data* fixture,
                                     gconstpointer user_data) {
	g_test_timer_start();

	fixture-&gt;req-&gt;cmd_string = &quot;/bin/sleep 5&quot;;
	fixture-&gt;req-&gt;timeout = 1;

	wsh_run_cmd(fixture-&gt;res, fixture-&gt;req);

	gdouble time_len = g_test_timer_elapsed();
	g_assert(time_len &lt; 4.5);
}

int main(int argc, char** argv, char** env) {
	g_test_init(&amp;argc, &amp;argv, NULL);

	g_test_add(&quot;/Library/RunCmd/ConstructSudoCmd&quot;, struct test_wsh_run_cmd_data,
	           NULL, setup, test_construct_sudo_cmd, teardown);
	g_test_add(&quot;/Library/RunCmd/ExitCode&quot;, struct test_wsh_run_cmd_data, NULL,
	           setup, test_run_exit_code, teardown);
	g_test_add(&quot;/Library/RunCmd/Stdout&quot;, struct test_wsh_run_cmd_data, NULL, setup,
	           test_run_stdout, teardown);
	g_test_add(&quot;/Library/RunCmd/Stderr&quot;, struct test_wsh_run_cmd_data, NULL, setup,
	           test_run_stderr, teardown);
	g_test_add(&quot;/Library/RunCmd/Errors&quot;, struct test_wsh_run_cmd_data, NULL, setup,
	           test_run_err, teardown);
	g_test_add(&quot;/Library/RunCmd/Path&quot;, struct test_wsh_run_cmd_data, NULL, setup,
	           test_wsh_run_cmd_path, teardown);
	g_test_add(&quot;/Library/RunCmd/Timeout&quot;, struct test_wsh_run_cmd_data, NULL, setup,
	           test_wsh_run_cmd_timeout, teardown);

	return g_test_run();
}

</PRE>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>test_cmd_messages_proto.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
/* Copyright (c) 2013 William Orr &lt;will@worrbase.com&gt;
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the &quot;Software&quot;), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */
#include &lt;glib.h&gt;
#include &lt;stdlib.h&gt;

#include &quot;auth.pb-c.h&quot;
#include &quot;cmd-messages.pb-c.h&quot;

static gchar* ai_username = &quot;will&quot;;
static gchar* ai_password = &quot;test&quot;;
static gchar* req_cmd = &quot;ls&quot;;
static gchar* req_stdin[2] = { &quot;yes&quot;, &quot;no&quot; };
static gchar* req_env[3] = { &quot;PATH=/usr/bin&quot;, &quot;USER=will&quot;, &quot;MAILTO=will@worrbase.com&quot; };
static gchar* req_cwd = &quot;/tmp&quot;;
static guint64 req_timeout = 5;
static gboolean req_use_shell = TRUE;

static const gsize simple_req_len = 6;
static const guint8 simple_req[] = { 0x0a, 0x02, 0x6c, 0x73, 0x3a, 0x00, };

static const gsize auth_req_len = 20;
static const guint8 auth_req[]
    = { 0x0a, 0x02, 0x6c, 0x73, 0x12, 0x0c, 0x0a, 0x04, 0x77, 0x69, 0x6c, 0x6c, 0x12, 0x04, 0x74, 0x65, 0x73, 0x74, 0x3a, 0x00, };

static const gsize complex_req_len = 77;
static const guint8 complex_req[]
    = { 0x0a, 0x02, 0x6c, 0x73, 0x1a, 0x03, 0x79, 0x65, 0x73, 0x1a, 0x02, 0x6e, 0x6f, 0x22, 0x0d, 0x50, 0x41, 0x54,
        0x48, 0x3d, 0x2f, 0x75, 0x73, 0x72, 0x2f, 0x62, 0x69, 0x6e, 0x22, 0x09, 0x55, 0x53, 0x45, 0x52, 0x3d, 0x77,
        0x69, 0x6c, 0x6c, 0x22, 0x18, 0x4d, 0x41, 0x49, 0x4c, 0x54, 0x4f, 0x3d, 0x77, 0x69, 0x6c, 0x6c, 0x40, 0x77,
        0x6f, 0x72, 0x72, 0x62, 0x61, 0x73, 0x65, 0x2e, 0x63, 0x6f, 0x6d, 0x2a, 0x04, 0x2f, 0x74, 0x6d, 0x70, 0x30,
        0x05, 0x3a, 0x00, 0x58, 0x01
      } ;

static gchar* reply_stdout[4] = { &quot;main.c&quot;, &quot;cmd.c&quot;, &quot;log.c&quot;, &quot;tons of tests&quot; };
static gchar** reply_stderr = NULL;
static const gint reply_ret_code = 0;

static const gsize simple_reply_len = 39;
static const guint8 simple_reply[39]
    = { 0x0a, 0x06, 0x6d, 0x61, 0x69, 0x6e, 0x2e, 0x63, 0x0a, 0x05, 0x63, 0x6d, 0x64, 0x2e, 0x63, 0x0a, 0x05, 0x6c,
        0x6f, 0x67, 0x2e, 0x63, 0x0a, 0x0d, 0x74, 0x6f, 0x6e, 0x73, 0x20, 0x6f, 0x66, 0x20, 0x74, 0x65, 0x73, 0x74,
        0x73, 0x18, 0x00
      };

static const gsize corrupted_req_len = 4;
static const guint8 corrupted_req[5] = { 0x0a, 0x05, 0x02, 0x6c, 0x73 };

static const gsize corrupted_reply_len = 39;
static const guint8 corrupted_reply[39]
    = { 0x5a, 0x06, 0x6d, 0x61, 0x69, 0x6e, 0x2e, 0x63, 0x0a, 0x05, 0x63, 0x6d, 0x64, 0x2e, 0x63, 0x0a, 0x05, 0x6c,
        0x6f, 0x67, 0x2e, 0x63, 0x1e, 0x0d, 0x74, 0x6f, 0x6e, 0x73, 0x20, 0x6f, 0x66, 0x20, 0x74, 0x65, 0x73, 0x74,
        0x73, 0x18, 0x00
      };

static void test_packing_simple_cmd_request(void) {
	CommandRequest req = COMMAND_REQUEST__INIT;
	gsize len;
	guint8* buf;

	req.command = req_cmd;

	len = command_request__get_packed_size(&amp;req);
	g_assert(len == simple_req_len);
	buf = g_slice_alloc0(len);

	command_request__pack(&amp;req, buf);

	for (gsize i = 0; i &lt; len; i++) {
		g_assert(buf[i] == simple_req[i]);
	}

	g_slice_free1(len, buf);
}

static void test_unpacking_simple_cmd_request(void) {
	CommandRequest* req = NULL;

	req = command_request__unpack(NULL, simple_req_len, simple_req);

	g_assert(req != NULL);
	g_assert_cmpstr(req-&gt;command, ==, req_cmd);

	g_assert(req-&gt;stdin == NULL);
	g_assert(req-&gt;env == NULL);
	g_assert(req-&gt;cwd == NULL);
	g_assert(req-&gt;has_timeout == FALSE);

	command_request__free_unpacked(req, NULL);
}

static void test_packing_auth_cmd_request(void) {
	AuthInfo ai = AUTH_INFO__INIT;
	CommandRequest req = COMMAND_REQUEST__INIT;
	gsize len;
	guint8* buf;

	ai.username = ai_username;
	ai.password = ai_password;
	req.auth = &amp;ai;

	req.command = req_cmd;

	len = command_request__get_packed_size(&amp;req);
	g_assert(len == auth_req_len);
	buf = g_slice_alloc0(len);

	command_request__pack(&amp;req, buf);

	for (gsize i = 0; i &lt; len; i++) {
		g_assert(buf[i] == auth_req[i]);
	}

	g_slice_free1(len, buf);
}

static void test_unpacking_auth_cmd_request(void) {
	CommandRequest* req;

	req = command_request__unpack(NULL, auth_req_len, auth_req);

	g_assert_cmpstr(req-&gt;auth-&gt;username, ==, ai_username);
	g_assert_cmpstr(req-&gt;auth-&gt;password, ==, ai_password);
	g_assert_cmpstr(req-&gt;command, ==, req_cmd);

	g_assert(req-&gt;stdin == NULL);
	g_assert(req-&gt;env == NULL);
	g_assert(req-&gt;cwd == NULL);
	g_assert(req-&gt;has_timeout == FALSE);

	command_request__free_unpacked(req, NULL);
<A NAME="0"></A>}

static void test_packing_complex_cmd_request(void) {
<FONT color="#0000ff"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match26-0.html#0',2,'match26-top.html#0',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>	CommandRequest req = COMMAND_REQUEST__INIT;
	gsize len;
	guint8* buf;

	req.command = req_cmd;
	req.stdin = req_stdin;
	req.n_stdin = 2;
	req.env = req_env;
	req.n_env = 3;
	req.cwd = req_cwd;
	req.has_timeout = TRUE;
	req.timeout = req_timeout;
	req.has_use_shell = TRUE;
	req.use_shell = req_use_shell;

	len = command_request__get_packed_size(&amp;req);
	g_assert(len == complex_req_len);
	buf = g_slice_alloc0(len);</B></FONT>

	command_request__pack(&amp;req, buf);

	for (gsize i = 0; i &lt; len; i++) {
		g_assert(buf[i] == complex_req[i]);
	}

	g_slice_free1(len, buf);
}

static void test_unpacking_complex_cmd_request(void) {
	CommandRequest* req;

	req = command_request__unpack(NULL, complex_req_len, complex_req);

	g_assert_cmpstr(req-&gt;command, ==, req_cmd);
	g_assert(req-&gt;auth == NULL);
	g_assert(req-&gt;n_stdin == 2);
	g_assert(req-&gt;n_env == 3);
	g_assert_cmpstr(req-&gt;cwd, ==, req_cwd);
	g_assert(req-&gt;has_timeout);
	g_assert(req-&gt;timeout == req_timeout);
	g_assert(req-&gt;use_shell == req_use_shell);

	for (gsize i = 0; i &lt; req-&gt;n_stdin; i++) {
		g_assert_cmpstr(req-&gt;stdin[i], ==, req_stdin[i]);
	}

	for (gsize i = 0; i &lt; req-&gt;n_env; i++) {
		g_assert_cmpstr(req-&gt;env[i], ==, req_env[i]);
	}

	command_request__free_unpacked(req, NULL);
}

static void test_packing_cmd_response(void) {
	CommandReply reply = COMMAND_REPLY__INIT;
	gsize len;
	guint8* buf;

	reply.stdout = reply_stdout;
	reply.n_stdout = 4;
	reply.stderr = reply_stderr;
	reply.n_stderr = 0;
	reply.ret_code = reply_ret_code;

	len = command_reply__get_packed_size(&amp;reply);
	g_assert(len == simple_reply_len);
	buf = g_slice_alloc0(len);

	command_reply__pack(&amp;reply, buf);

	g_assert(buf != NULL);

	for (gsize i = 0; i &lt; len; i++) {
		g_assert(buf[i] == simple_reply[i]);
	}

	g_slice_free1(len, buf);
}

static void test_unpacking_cmd_response(void) {
	CommandReply* reply = NULL;

	reply = command_reply__unpack(NULL, simple_reply_len, simple_reply);

	g_assert(reply != NULL);
	g_assert(reply-&gt;n_stdout == 4);
	g_assert(reply-&gt;n_stderr == 0);
	g_assert(reply-&gt;ret_code == reply_ret_code);

	for (gsize i = 0; i &lt; reply-&gt;n_stdout; i++) {
		g_assert_cmpstr(reply-&gt;stdout[i], ==, reply_stdout[i]);
	}

	command_reply__free_unpacked(reply, NULL);
}

#if GLIB_CHECK_VERSION(2, 38, 0)
static void test_unpacking_corrupted_request_subprocess(void) {
	CommandRequest* req = NULL;
	command_request__unpack(NULL, corrupted_req_len, corrupted_req);
	g_assert(req == NULL);

	exit(0);
}
#endif

static void test_unpacking_corrupted_request(void) {
#if GLIB_CHECK_VERSION(2, 38, 0)
	g_test_trap_subprocess(&quot;/Library/Protocol/UnpackCorruptCommandRequest/subprocess&quot;,
	                       0, 0);
	g_test_trap_assert_passed();
#else
	CommandRequest* req = NULL;

	if (g_test_trap_fork(0, G_TEST_TRAP_SILENCE_STDOUT)) {
		req = command_request__unpack(NULL, corrupted_req_len, corrupted_req);
		exit(0);
	}

	g_assert(req == NULL);
#endif
}

#if GLIB_CHECK_VERSION(2, 38, 0)
static void test_unpacking_corrupted_response_subproccess(void) {
	CommandReply* reply = NULL;
	command_reply__unpack(NULL, corrupted_reply_len, corrupted_reply);
	g_assert(reply == NULL);

	exit(0);
}
#endif

static void test_unpacking_corrupted_response(void) {
#if GLIB_CHECK_VERSION(2, 38, 0)
	g_test_trap_subprocess(&quot;/Library/Protocol/UnpackCorruptCommandReply/subprocess&quot;,
	                       0, 0);
	g_test_trap_assert_passed();
#else
	CommandReply* reply = NULL;
	if (g_test_trap_fork(0, G_TEST_TRAP_SILENCE_STDOUT)) {
		reply = command_reply__unpack(NULL, corrupted_reply_len, corrupted_reply);
		exit(0);
	}

	g_assert(reply == NULL);
#endif
}

int main(int argc, char** argv) {
	g_test_init(&amp;argc, &amp;argv, NULL);

	g_test_add_func(&quot;/Library/Protocol/PackSimpleCommandRequest&quot;,
	                test_packing_simple_cmd_request);
	g_test_add_func(&quot;/Library/Protocol/UnpackSimpleCommandRequest&quot;,
	                test_unpacking_simple_cmd_request);
	g_test_add_func(&quot;/Library/Protocol/PackAuthCommandRequest&quot;,
	                test_packing_auth_cmd_request);
	g_test_add_func(&quot;/Library/Protocol/UnpackAuthCommandRequest&quot;,
	                test_unpacking_auth_cmd_request);
	g_test_add_func(&quot;/Library/Protocol/PackComplexCommandRequest&quot;,
	                test_packing_complex_cmd_request);
	g_test_add_func(&quot;/Library/Protocol/UnpackComplexCommandRequest&quot;,
	                test_unpacking_complex_cmd_request);
	g_test_add_func(&quot;/Library/Protocol/PackCommandReply&quot;,
	                test_packing_cmd_response);
	g_test_add_func(&quot;/Library/Protocol/UnpackCommandReply&quot;,
	                test_unpacking_cmd_response);
	g_test_add_func(&quot;/Library/Protocol/UnpackCorruptCommandRequest&quot;,
	                test_unpacking_corrupted_request);
	g_test_add_func(&quot;/Library/Protocol/UnpackCorruptCommandReply&quot;,
	                test_unpacking_corrupted_response);

#if GLIB_CHECK_VERSION(2, 38, 0)
	g_test_add_func(&quot;/Library/Protocol/UnpackCorruptCommandRequest/subprocess&quot;,
	                test_unpacking_corrupted_request_subprocess);
	g_test_add_func(&quot;/Library/Protocol/UnpackCorruptCommandReply/subprocess&quot;,
	                test_unpacking_corrupted_response_subproccess);
#endif

	return g_test_run();
}

</PRE>
</div>
  </div>
</body>
</html>
