<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for test_run_cmd.c &amp; test_cmd_messages_proto.c</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for test_run_cmd.c &amp; test_cmd_messages_proto.c
      </h3>
<h1 align="center">
        6.0%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>test_run_cmd.c (7.9268293%)<th>test_cmd_messages_proto.c (4.942966%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(177-208)<td><a href="#" name="0">(152-169)</a><td align="center"><font color="#ff0000">13</font>
</td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>test_run_cmd.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 #include "config.h"
2 #include &lt;glib.h&gt;
3 #include &lt;string.h&gt;
4 #include &lt;sys/types.h&gt;
5 #include &lt;sys/uio.h&gt;
6 #include &lt;unistd.h&gt;
7 #include "cmd.h"
8 #include "cmd_internal.h"
9 #include "log.h"
10 #include "getpwent.h"
11 extern char** environ;
12 struct test_wsh_run_cmd_data {
13 	wsh_cmd_req_t* req;
14 	wsh_cmd_res_t* res;
15 };
16 static void setup(struct test_wsh_run_cmd_data* fixture,
17                   gconstpointer user_data) {
18 	struct test_wsh_run_cmd_data* data = fixture;
19 	data-&gt;req = g_slice_new0(wsh_cmd_req_t);
20 	data-&gt;res = g_slice_new0(wsh_cmd_res_t);
21 	data-&gt;req-&gt;in_fd = dup(1);
22 	data-&gt;req-&gt;env = g_strdupv(environ);
23 	data-&gt;req-&gt;cwd = "/tmp";
24 	data-&gt;req-&gt;host = "127.0.0.1";
25 	data-&gt;req-&gt;username = "root";
26 	data-&gt;req-&gt;password = g_strdup("test");
27 	wsh_init_logger(WSH_LOGGER_SERVER);
28 }
29 static void teardown(struct test_wsh_run_cmd_data* fixture,
30                      gconstpointer user_data) {
31 	struct test_wsh_run_cmd_data* data = fixture;
32 	if (data-&gt;res-&gt;err != NULL)
33 		g_error_free(data-&gt;res-&gt;err);
34 	for (gint i = 0; i &lt; data-&gt;res-&gt;std_output_len; i++) {
35 		g_free(data-&gt;res-&gt;std_output[i]);
36 	}
37 	for (gint i = 0; i &lt; data-&gt;res-&gt;std_error_len; i++) {
38 		g_free(data-&gt;res-&gt;std_error[i]);
39 	}
40 	g_strfreev(data-&gt;req-&gt;env);
41 	g_free(data-&gt;req-&gt;password);
42 	g_slice_free(wsh_cmd_req_t, data-&gt;req);
43 	g_slice_free(wsh_cmd_res_t, data-&gt;res);
44 	wsh_exit_logger();
45 }
46 static void test_run_exit_code(struct test_wsh_run_cmd_data* fixture,
47                                gconstpointer user_data) {
48 	wsh_cmd_req_t* req = fixture-&gt;req;
49 	wsh_cmd_res_t* res = fixture-&gt;res;
50 	req-&gt;cmd_string = "/bin/ls";
51 	gint ret = wsh_run_cmd(res, req);
52 	g_assert_no_error(res-&gt;err);
53 	g_assert(ret == 0);
54 	g_assert(res-&gt;exit_status == 0);
55 	req-&gt;cmd_string = "/bin/ls this definitely will fail";
56 	g_assert_no_error(res-&gt;err);
57 	g_assert(wsh_run_cmd(res, req) == 0);
58 	g_assert(res-&gt;exit_status != 0);
59 }
60 static void test_run_stdout(struct test_wsh_run_cmd_data* fixture,
61                             gconstpointer user_data) {
62 	wsh_cmd_req_t* req = fixture-&gt;req;
63 	wsh_cmd_res_t* res = fixture-&gt;res;
64 	req-&gt;cmd_string = "/bin/echo foo";
65 	wsh_run_cmd(res, req);
66 	g_assert_no_error(res-&gt;err);
67 	g_assert(res-&gt;exit_status == 0);
68 	g_assert_cmpstr(res-&gt;std_output[0], ==, "foo");
69 	g_assert(res-&gt;std_output_len == 1);
70 	res-&gt;std_output = NULL;
71 	res-&gt;std_output_len = 0;
72 	req-&gt;cmd_string = "/bin/echo foo 1&gt;&amp;2";
73 	req-&gt;use_shell = TRUE;
74 	wsh_run_cmd(res, req);
75 	g_assert_no_error(res-&gt;err);
76 	g_assert(res-&gt;exit_status == 0);
77 	g_assert(res-&gt;std_output_len == 0);
78 	res-&gt;std_output = NULL;
79 	res-&gt;std_output_len = 0;
80 	req-&gt;cmd_string = "/bin/echo -n foo";
81 	req-&gt;use_shell = TRUE;
82 	wsh_run_cmd(res, req);
83 	g_assert_no_error(res-&gt;err);
84 	g_assert(res-&gt;exit_status == 0);
85 	g_assert(res-&gt;std_output_len == 1);
86 	g_assert_cmpstr(res-&gt;std_output[0], ==, "foo");
87 }
88 static void test_run_stderr(struct test_wsh_run_cmd_data* fixture,
89                             gconstpointer user_data) {
90 	wsh_cmd_req_t* req = fixture-&gt;req;
91 	wsh_cmd_res_t* res = fixture-&gt;res;
92 	req-&gt;cmd_string = "/bin/echo foo 1&gt;&amp;2";
93 	req-&gt;use_shell = TRUE;
94 	wsh_run_cmd(res, req);
95 	g_assert_no_error(res-&gt;err);
96 	g_assert(res-&gt;exit_status == 0);
97 	g_assert_cmpstr(res-&gt;std_error[0], ==, "foo");
98 	res-&gt;std_error = NULL;
99 	res-&gt;std_error_len = 0;
100 	req-&gt;cmd_string = "/bin/echo foo";
101 	wsh_run_cmd(res, req);
102 	g_assert_no_error(res-&gt;err);
103 	g_assert(res-&gt;exit_status == 0);
104 	g_assert(res-&gt;std_error_len == 0);
105 }
106 static void test_run_err(struct test_wsh_run_cmd_data* fixture,
107                          gconstpointer user_data) {
108 	wsh_cmd_req_t* req = fixture-&gt;req;
109 	wsh_cmd_res_t* res = fixture-&gt;res;
110 	req-&gt;cmd_string = "echo fail'";
111 	wsh_run_cmd(res, req);
112 	g_assert_error(res-&gt;err, G_SHELL_ERROR, G_SHELL_ERROR_BAD_QUOTING);
113 	res-&gt;err = NULL;
114 	req-&gt;cmd_string = "exit 0";
115 	req-&gt;use_shell = TRUE;
116 	req-&gt;cwd = "/foobarbaz";
117 	wsh_run_cmd(res, req);
118 	g_assert_error(res-&gt;err, G_SPAWN_ERROR, G_SPAWN_ERROR_CHDIR);
119 }
120 static void test_construct_sudo_cmd(struct test_wsh_run_cmd_data* fixture,
121                                     gconstpointer user_data) {
122 <a name="0"></a>	wsh_cmd_req_t* req = fixture-&gt;req;
123 	GError* err = NULL;
124 <font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>	req-&gt;cmd_string = "/bin/ls";
125 	req-&gt;use_shell = TRUE;
126 	gchar* res = wsh_construct_sudo_cmd(req, &amp;err);
127 	g_assert_cmpstr(res, ==, LIBEXEC_PATH"/wsh-killer 0 /bin/sh -c '/bin/ls'");
128 	g_assert_no_error(err);
129 	g_free(res);
130 	req-&gt;sudo = TRUE;
131 	req-&gt;use_shell = TRUE;
132 	res = wsh_construct_sudo_cmd(req, &amp;err);
133 	g_assert_cmpstr(res, ==,
134 	                "sudo -sA -u root "LIBEXEC_PATH"/wsh-killer 0 /bin/sh -c '/bin/ls'");
135 	g_assert_no_error(err);
136 	g_free(res);
137 	req-&gt;username = "worr";
138 	req-&gt;use_shell = TRUE;
139 	res = wsh_construct_sudo_cmd(req, &amp;err);
140 	g_assert_cmpstr(res, ==,
141 	                "sudo -sA -u worr "LIBEXEC_PATH"/wsh-killer 0 /bin/sh -c '/bin/ls'");
142 	g_assert_no_error(err);
143 	g_free(res);
144 	req-&gt;username = "";
145 	req-&gt;use_shell = TRUE;
146 	res = wsh_construct_sudo_cmd(req, &amp;err);
147 	g_assert_cmpstr(res, ==,
148 	                "sudo -sA -u root "LIBEXEC_PATH"/wsh-killer 0 /bin/sh -c '/bin/ls'");
149 	g_assert_no_error(err);
150 	g_free(res);
151 	req-&gt;username = " ";</b></font>
152 	res = wsh_construct_sudo_cmd(req, &amp;err);
153 	g_assert_cmpstr(res, ==, NULL);
154 	g_assert_error(err, WSH_CMD_ERROR, WSH_CMD_PW_ERR);
155 	g_error_free(err);
156 	err = NULL;
157 	g_free(res);
158 	req-&gt;cmd_string = "";
159 	req-&gt;username = "";
160 	res = wsh_construct_sudo_cmd(req, &amp;err);
161 	g_assert_no_error(err);
162 	g_assert(res == NULL);
163 	req-&gt;cmd_string = NULL;
164 	res = wsh_construct_sudo_cmd(req, &amp;err);
165 	g_assert_no_error(err);
166 	g_assert(res == NULL);
167 }
168 static void test_wsh_run_cmd_path(struct test_wsh_run_cmd_data* fixture,
169                                   gconstpointer user_data) {
170 	wsh_cmd_req_t* req = fixture-&gt;req;
171 	wsh_cmd_res_t* res = fixture-&gt;res;
172 	req-&gt;cmd_string = "ls";
173 	wsh_run_cmd(res, req);
174 	g_assert(res-&gt;exit_status == 0);
175 }
176 static void test_wsh_run_cmd_timeout(struct test_wsh_run_cmd_data* fixture,
177                                      gconstpointer user_data) {
178 	g_test_timer_start();
179 	fixture-&gt;req-&gt;cmd_string = "/bin/sleep 5";
180 	fixture-&gt;req-&gt;timeout = 1;
181 	wsh_run_cmd(fixture-&gt;res, fixture-&gt;req);
182 	gdouble time_len = g_test_timer_elapsed();
183 	g_assert(time_len &lt; 4.5);
184 }
185 int main(int argc, char** argv, char** env) {
186 	g_test_init(&amp;argc, &amp;argv, NULL);
187 	g_test_add("/Library/RunCmd/ConstructSudoCmd", struct test_wsh_run_cmd_data,
188 	           NULL, setup, test_construct_sudo_cmd, teardown);
189 	g_test_add("/Library/RunCmd/ExitCode", struct test_wsh_run_cmd_data, NULL,
190 	           setup, test_run_exit_code, teardown);
191 	g_test_add("/Library/RunCmd/Stdout", struct test_wsh_run_cmd_data, NULL, setup,
192 	           test_run_stdout, teardown);
193 	g_test_add("/Library/RunCmd/Stderr", struct test_wsh_run_cmd_data, NULL, setup,
194 	           test_run_stderr, teardown);
195 	g_test_add("/Library/RunCmd/Errors", struct test_wsh_run_cmd_data, NULL, setup,
196 	           test_run_err, teardown);
197 	g_test_add("/Library/RunCmd/Path", struct test_wsh_run_cmd_data, NULL, setup,
198 	           test_wsh_run_cmd_path, teardown);
199 	g_test_add("/Library/RunCmd/Timeout", struct test_wsh_run_cmd_data, NULL, setup,
200 	           test_wsh_run_cmd_timeout, teardown);
201 	return g_test_run();
202 }
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>test_cmd_messages_proto.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 #include &lt;glib.h&gt;
2 #include &lt;stdlib.h&gt;
3 #include "auth.pb-c.h"
4 #include "cmd-messages.pb-c.h"
5 static gchar* ai_username = "will";
6 static gchar* ai_password = "test";
7 static gchar* req_cmd = "ls";
8 static gchar* req_stdin[2] = { "yes", "no" };
9 static gchar* req_env[3] = { "PATH=/usr/bin", "USER=will", "MAILTO=will@worrbase.com" };
10 static gchar* req_cwd = "/tmp";
11 static guint64 req_timeout = 5;
12 static gboolean req_use_shell = TRUE;
13 static const gsize simple_req_len = 6;
14 static const guint8 simple_req[] = { 0x0a, 0x02, 0x6c, 0x73, 0x3a, 0x00, };
15 static const gsize auth_req_len = 20;
16 static const guint8 auth_req[]
17     = { 0x0a, 0x02, 0x6c, 0x73, 0x12, 0x0c, 0x0a, 0x04, 0x77, 0x69, 0x6c, 0x6c, 0x12, 0x04, 0x74, 0x65, 0x73, 0x74, 0x3a, 0x00, };
18 static const gsize complex_req_len = 77;
19 static const guint8 complex_req[]
20     = { 0x0a, 0x02, 0x6c, 0x73, 0x1a, 0x03, 0x79, 0x65, 0x73, 0x1a, 0x02, 0x6e, 0x6f, 0x22, 0x0d, 0x50, 0x41, 0x54,
21         0x48, 0x3d, 0x2f, 0x75, 0x73, 0x72, 0x2f, 0x62, 0x69, 0x6e, 0x22, 0x09, 0x55, 0x53, 0x45, 0x52, 0x3d, 0x77,
22         0x69, 0x6c, 0x6c, 0x22, 0x18, 0x4d, 0x41, 0x49, 0x4c, 0x54, 0x4f, 0x3d, 0x77, 0x69, 0x6c, 0x6c, 0x40, 0x77,
23         0x6f, 0x72, 0x72, 0x62, 0x61, 0x73, 0x65, 0x2e, 0x63, 0x6f, 0x6d, 0x2a, 0x04, 0x2f, 0x74, 0x6d, 0x70, 0x30,
24         0x05, 0x3a, 0x00, 0x58, 0x01
25       } ;
26 static gchar* reply_stdout[4] = { "main.c", "cmd.c", "log.c", "tons of tests" };
27 static gchar** reply_stderr = NULL;
28 static const gint reply_ret_code = 0;
29 static const gsize simple_reply_len = 39;
30 static const guint8 simple_reply[39]
31     = { 0x0a, 0x06, 0x6d, 0x61, 0x69, 0x6e, 0x2e, 0x63, 0x0a, 0x05, 0x63, 0x6d, 0x64, 0x2e, 0x63, 0x0a, 0x05, 0x6c,
32         0x6f, 0x67, 0x2e, 0x63, 0x0a, 0x0d, 0x74, 0x6f, 0x6e, 0x73, 0x20, 0x6f, 0x66, 0x20, 0x74, 0x65, 0x73, 0x74,
33         0x73, 0x18, 0x00
34       };
35 static const gsize corrupted_req_len = 4;
36 static const guint8 corrupted_req[5] = { 0x0a, 0x05, 0x02, 0x6c, 0x73 };
37 static const gsize corrupted_reply_len = 39;
38 static const guint8 corrupted_reply[39]
39     = { 0x5a, 0x06, 0x6d, 0x61, 0x69, 0x6e, 0x2e, 0x63, 0x0a, 0x05, 0x63, 0x6d, 0x64, 0x2e, 0x63, 0x0a, 0x05, 0x6c,
40         0x6f, 0x67, 0x2e, 0x63, 0x1e, 0x0d, 0x74, 0x6f, 0x6e, 0x73, 0x20, 0x6f, 0x66, 0x20, 0x74, 0x65, 0x73, 0x74,
41         0x73, 0x18, 0x00
42       };
43 static void test_packing_simple_cmd_request(void) {
44 	CommandRequest req = COMMAND_REQUEST__INIT;
45 	gsize len;
46 	guint8* buf;
47 	req.command = req_cmd;
48 	len = command_request__get_packed_size(&amp;req);
49 	g_assert(len == simple_req_len);
50 	buf = g_slice_alloc0(len);
51 	command_request__pack(&amp;req, buf);
52 	for (gsize i = 0; i &lt; len; i++) {
53 		g_assert(buf[i] == simple_req[i]);
54 	}
55 	g_slice_free1(len, buf);
56 }
57 static void test_unpacking_simple_cmd_request(void) {
58 	CommandRequest* req = NULL;
59 	req = command_request__unpack(NULL, simple_req_len, simple_req);
60 	g_assert(req != NULL);
61 	g_assert_cmpstr(req-&gt;command, ==, req_cmd);
62 	g_assert(req-&gt;stdin == NULL);
63 	g_assert(req-&gt;env == NULL);
64 	g_assert(req-&gt;cwd == NULL);
65 	g_assert(req-&gt;has_timeout == FALSE);
66 	command_request__free_unpacked(req, NULL);
67 }
68 static void test_packing_auth_cmd_request(void) {
69 	AuthInfo ai = AUTH_INFO__INIT;
70 	CommandRequest req = COMMAND_REQUEST__INIT;
71 	gsize len;
72 	guint8* buf;
73 	ai.username = ai_username;
74 	ai.password = ai_password;
75 	req.auth = &amp;ai;
76 	req.command = req_cmd;
77 	len = command_request__get_packed_size(&amp;req);
78 	g_assert(len == auth_req_len);
79 	buf = g_slice_alloc0(len);
80 	command_request__pack(&amp;req, buf);
81 	for (gsize i = 0; i &lt; len; i++) {
82 		g_assert(buf[i] == auth_req[i]);
83 	}
84 	g_slice_free1(len, buf);
85 }
86 static void test_unpacking_auth_cmd_request(void) {
87 	CommandRequest* req;
88 	req = command_request__unpack(NULL, auth_req_len, auth_req);
89 	g_assert_cmpstr(req-&gt;auth-&gt;username, ==, ai_username);
90 	g_assert_cmpstr(req-&gt;auth-&gt;password, ==, ai_password);
91 	g_assert_cmpstr(req-&gt;command, ==, req_cmd);
92 	g_assert(req-&gt;stdin == NULL);
93 	g_assert(req-&gt;env == NULL);
94 	g_assert(req-&gt;cwd == NULL);
95 	g_assert(req-&gt;has_timeout == FALSE);
96 	command_request__free_unpacked(req, NULL);
97 <a name="0"></a>}
98 static void test_packing_complex_cmd_request(void) {
99 <font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>	CommandRequest req = COMMAND_REQUEST__INIT;
100 	gsize len;
101 	guint8* buf;
102 	req.command = req_cmd;
103 	req.stdin = req_stdin;
104 	req.n_stdin = 2;
105 	req.env = req_env;
106 	req.n_env = 3;
107 	req.cwd = req_cwd;
108 	req.has_timeout = TRUE;
109 	req.timeout = req_timeout;
110 	req.has_use_shell = TRUE;
111 	req.use_shell = req_use_shell;
112 	len = command_request__get_packed_size(&amp;req);
113 	g_assert(len == complex_req_len);
114 	buf = g_slice_alloc0(len);</b></font>
115 	command_request__pack(&amp;req, buf);
116 	for (gsize i = 0; i &lt; len; i++) {
117 		g_assert(buf[i] == complex_req[i]);
118 	}
119 	g_slice_free1(len, buf);
120 }
121 static void test_unpacking_complex_cmd_request(void) {
122 	CommandRequest* req;
123 	req = command_request__unpack(NULL, complex_req_len, complex_req);
124 	g_assert_cmpstr(req-&gt;command, ==, req_cmd);
125 	g_assert(req-&gt;auth == NULL);
126 	g_assert(req-&gt;n_stdin == 2);
127 	g_assert(req-&gt;n_env == 3);
128 	g_assert_cmpstr(req-&gt;cwd, ==, req_cwd);
129 	g_assert(req-&gt;has_timeout);
130 	g_assert(req-&gt;timeout == req_timeout);
131 	g_assert(req-&gt;use_shell == req_use_shell);
132 	for (gsize i = 0; i &lt; req-&gt;n_stdin; i++) {
133 		g_assert_cmpstr(req-&gt;stdin[i], ==, req_stdin[i]);
134 	}
135 	for (gsize i = 0; i &lt; req-&gt;n_env; i++) {
136 		g_assert_cmpstr(req-&gt;env[i], ==, req_env[i]);
137 	}
138 	command_request__free_unpacked(req, NULL);
139 }
140 static void test_packing_cmd_response(void) {
141 	CommandReply reply = COMMAND_REPLY__INIT;
142 	gsize len;
143 	guint8* buf;
144 	reply.stdout = reply_stdout;
145 	reply.n_stdout = 4;
146 	reply.stderr = reply_stderr;
147 	reply.n_stderr = 0;
148 	reply.ret_code = reply_ret_code;
149 	len = command_reply__get_packed_size(&amp;reply);
150 	g_assert(len == simple_reply_len);
151 	buf = g_slice_alloc0(len);
152 	command_reply__pack(&amp;reply, buf);
153 	g_assert(buf != NULL);
154 	for (gsize i = 0; i &lt; len; i++) {
155 		g_assert(buf[i] == simple_reply[i]);
156 	}
157 	g_slice_free1(len, buf);
158 }
159 static void test_unpacking_cmd_response(void) {
160 	CommandReply* reply = NULL;
161 	reply = command_reply__unpack(NULL, simple_reply_len, simple_reply);
162 	g_assert(reply != NULL);
163 	g_assert(reply-&gt;n_stdout == 4);
164 	g_assert(reply-&gt;n_stderr == 0);
165 	g_assert(reply-&gt;ret_code == reply_ret_code);
166 	for (gsize i = 0; i &lt; reply-&gt;n_stdout; i++) {
167 		g_assert_cmpstr(reply-&gt;stdout[i], ==, reply_stdout[i]);
168 	}
169 	command_reply__free_unpacked(reply, NULL);
170 }
171 #if GLIB_CHECK_VERSION(2, 38, 0)
172 static void test_unpacking_corrupted_request_subprocess(void) {
173 	CommandRequest* req = NULL;
174 	command_request__unpack(NULL, corrupted_req_len, corrupted_req);
175 	g_assert(req == NULL);
176 	exit(0);
177 }
178 #endif
179 static void test_unpacking_corrupted_request(void) {
180 #if GLIB_CHECK_VERSION(2, 38, 0)
181 	g_test_trap_subprocess("/Library/Protocol/UnpackCorruptCommandRequest/subprocess",
182 	                       0, 0);
183 	g_test_trap_assert_passed();
184 #else
185 	CommandRequest* req = NULL;
186 	if (g_test_trap_fork(0, G_TEST_TRAP_SILENCE_STDOUT)) {
187 		req = command_request__unpack(NULL, corrupted_req_len, corrupted_req);
188 		exit(0);
189 	}
190 	g_assert(req == NULL);
191 #endif
192 }
193 #if GLIB_CHECK_VERSION(2, 38, 0)
194 static void test_unpacking_corrupted_response_subproccess(void) {
195 	CommandReply* reply = NULL;
196 	command_reply__unpack(NULL, corrupted_reply_len, corrupted_reply);
197 	g_assert(reply == NULL);
198 	exit(0);
199 }
200 #endif
201 static void test_unpacking_corrupted_response(void) {
202 #if GLIB_CHECK_VERSION(2, 38, 0)
203 	g_test_trap_subprocess("/Library/Protocol/UnpackCorruptCommandReply/subprocess",
204 	                       0, 0);
205 	g_test_trap_assert_passed();
206 #else
207 	CommandReply* reply = NULL;
208 	if (g_test_trap_fork(0, G_TEST_TRAP_SILENCE_STDOUT)) {
209 		reply = command_reply__unpack(NULL, corrupted_reply_len, corrupted_reply);
210 		exit(0);
211 	}
212 	g_assert(reply == NULL);
213 #endif
214 }
215 int main(int argc, char** argv) {
216 	g_test_init(&amp;argc, &amp;argv, NULL);
217 	g_test_add_func("/Library/Protocol/PackSimpleCommandRequest",
218 	                test_packing_simple_cmd_request);
219 	g_test_add_func("/Library/Protocol/UnpackSimpleCommandRequest",
220 	                test_unpacking_simple_cmd_request);
221 	g_test_add_func("/Library/Protocol/PackAuthCommandRequest",
222 	                test_packing_auth_cmd_request);
223 	g_test_add_func("/Library/Protocol/UnpackAuthCommandRequest",
224 	                test_unpacking_auth_cmd_request);
225 	g_test_add_func("/Library/Protocol/PackComplexCommandRequest",
226 	                test_packing_complex_cmd_request);
227 	g_test_add_func("/Library/Protocol/UnpackComplexCommandRequest",
228 	                test_unpacking_complex_cmd_request);
229 	g_test_add_func("/Library/Protocol/PackCommandReply",
230 	                test_packing_cmd_response);
231 	g_test_add_func("/Library/Protocol/UnpackCommandReply",
232 	                test_unpacking_cmd_response);
233 	g_test_add_func("/Library/Protocol/UnpackCorruptCommandRequest",
234 	                test_unpacking_corrupted_request);
235 	g_test_add_func("/Library/Protocol/UnpackCorruptCommandReply",
236 	                test_unpacking_corrupted_response);
237 #if GLIB_CHECK_VERSION(2, 38, 0)
238 	g_test_add_func("/Library/Protocol/UnpackCorruptCommandRequest/subprocess",
239 	                test_unpacking_corrupted_request_subprocess);
240 	g_test_add_func("/Library/Protocol/UnpackCorruptCommandReply/subprocess",
241 	                test_unpacking_corrupted_response_subproccess);
242 #endif
243 	return g_test_run();
244 }
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
