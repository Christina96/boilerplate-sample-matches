<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for test_run_cmd.c &amp; test_cmd_messages_proto.c</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for test_run_cmd.c &amp; test_cmd_messages_proto.c
      </h3>
<h1 align="center">
        6.0%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>test_run_cmd.c (7.9268293%)<th>test_cmd_messages_proto.c (4.942966%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(177-208)<td><a href="#" name="0">(152-169)</a><td align="center"><font color="#ff0000">13</font>
</td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>test_run_cmd.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
#include "config.h"
#include &lt;glib.h&gt;
#include &lt;string.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;sys/uio.h&gt;
#include &lt;unistd.h&gt;
#include "cmd.h"
#include "cmd_internal.h"
#include "log.h"
#include "getpwent.h"
extern char** environ;
struct test_wsh_run_cmd_data {
	wsh_cmd_req_t* req;
	wsh_cmd_res_t* res;
};
static void setup(struct test_wsh_run_cmd_data* fixture,
                  gconstpointer user_data) {
	struct test_wsh_run_cmd_data* data = fixture;
	data-&gt;req = g_slice_new0(wsh_cmd_req_t);
	data-&gt;res = g_slice_new0(wsh_cmd_res_t);
	data-&gt;req-&gt;in_fd = dup(1);
	data-&gt;req-&gt;env = g_strdupv(environ);
	data-&gt;req-&gt;cwd = "/tmp";
	data-&gt;req-&gt;host = "127.0.0.1";
	data-&gt;req-&gt;username = "root";
	data-&gt;req-&gt;password = g_strdup("test");
	wsh_init_logger(WSH_LOGGER_SERVER);
}
static void teardown(struct test_wsh_run_cmd_data* fixture,
                     gconstpointer user_data) {
	struct test_wsh_run_cmd_data* data = fixture;
	if (data-&gt;res-&gt;err != NULL)
		g_error_free(data-&gt;res-&gt;err);
	for (gint i = 0; i &lt; data-&gt;res-&gt;std_output_len; i++) {
		g_free(data-&gt;res-&gt;std_output[i]);
	}
	for (gint i = 0; i &lt; data-&gt;res-&gt;std_error_len; i++) {
		g_free(data-&gt;res-&gt;std_error[i]);
	}
	g_strfreev(data-&gt;req-&gt;env);
	g_free(data-&gt;req-&gt;password);
	g_slice_free(wsh_cmd_req_t, data-&gt;req);
	g_slice_free(wsh_cmd_res_t, data-&gt;res);
	wsh_exit_logger();
}
static void test_run_exit_code(struct test_wsh_run_cmd_data* fixture,
                               gconstpointer user_data) {
	wsh_cmd_req_t* req = fixture-&gt;req;
	wsh_cmd_res_t* res = fixture-&gt;res;
	req-&gt;cmd_string = "/bin/ls";
	gint ret = wsh_run_cmd(res, req);
	g_assert_no_error(res-&gt;err);
	g_assert(ret == 0);
	g_assert(res-&gt;exit_status == 0);
	req-&gt;cmd_string = "/bin/ls this definitely will fail";
	g_assert_no_error(res-&gt;err);
	g_assert(wsh_run_cmd(res, req) == 0);
	g_assert(res-&gt;exit_status != 0);
}
static void test_run_stdout(struct test_wsh_run_cmd_data* fixture,
                            gconstpointer user_data) {
	wsh_cmd_req_t* req = fixture-&gt;req;
	wsh_cmd_res_t* res = fixture-&gt;res;
	req-&gt;cmd_string = "/bin/echo foo";
	wsh_run_cmd(res, req);
	g_assert_no_error(res-&gt;err);
	g_assert(res-&gt;exit_status == 0);
	g_assert_cmpstr(res-&gt;std_output[0], ==, "foo");
	g_assert(res-&gt;std_output_len == 1);
	res-&gt;std_output = NULL;
	res-&gt;std_output_len = 0;
	req-&gt;cmd_string = "/bin/echo foo 1&gt;&amp;2";
	req-&gt;use_shell = TRUE;
	wsh_run_cmd(res, req);
	g_assert_no_error(res-&gt;err);
	g_assert(res-&gt;exit_status == 0);
	g_assert(res-&gt;std_output_len == 0);
	res-&gt;std_output = NULL;
	res-&gt;std_output_len = 0;
	req-&gt;cmd_string = "/bin/echo -n foo";
	req-&gt;use_shell = TRUE;
	wsh_run_cmd(res, req);
	g_assert_no_error(res-&gt;err);
	g_assert(res-&gt;exit_status == 0);
	g_assert(res-&gt;std_output_len == 1);
	g_assert_cmpstr(res-&gt;std_output[0], ==, "foo");
}
static void test_run_stderr(struct test_wsh_run_cmd_data* fixture,
                            gconstpointer user_data) {
	wsh_cmd_req_t* req = fixture-&gt;req;
	wsh_cmd_res_t* res = fixture-&gt;res;
	req-&gt;cmd_string = "/bin/echo foo 1&gt;&amp;2";
	req-&gt;use_shell = TRUE;
	wsh_run_cmd(res, req);
	g_assert_no_error(res-&gt;err);
	g_assert(res-&gt;exit_status == 0);
	g_assert_cmpstr(res-&gt;std_error[0], ==, "foo");
	res-&gt;std_error = NULL;
	res-&gt;std_error_len = 0;
	req-&gt;cmd_string = "/bin/echo foo";
	wsh_run_cmd(res, req);
	g_assert_no_error(res-&gt;err);
	g_assert(res-&gt;exit_status == 0);
	g_assert(res-&gt;std_error_len == 0);
}
static void test_run_err(struct test_wsh_run_cmd_data* fixture,
                         gconstpointer user_data) {
	wsh_cmd_req_t* req = fixture-&gt;req;
	wsh_cmd_res_t* res = fixture-&gt;res;
	req-&gt;cmd_string = "echo fail'";
	wsh_run_cmd(res, req);
	g_assert_error(res-&gt;err, G_SHELL_ERROR, G_SHELL_ERROR_BAD_QUOTING);
	res-&gt;err = NULL;
	req-&gt;cmd_string = "exit 0";
	req-&gt;use_shell = TRUE;
	req-&gt;cwd = "/foobarbaz";
	wsh_run_cmd(res, req);
	g_assert_error(res-&gt;err, G_SPAWN_ERROR, G_SPAWN_ERROR_CHDIR);
}
static void test_construct_sudo_cmd(struct test_wsh_run_cmd_data* fixture,
                                    gconstpointer user_data) {
<a name="0"></a>	wsh_cmd_req_t* req = fixture-&gt;req;
	GError* err = NULL;
<font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>	req-&gt;cmd_string = "/bin/ls";
	req-&gt;use_shell = TRUE;
	gchar* res = wsh_construct_sudo_cmd(req, &amp;err);
	g_assert_cmpstr(res, ==, LIBEXEC_PATH"/wsh-killer 0 /bin/sh -c '/bin/ls'");
	g_assert_no_error(err);
	g_free(res);
	req-&gt;sudo = TRUE;
	req-&gt;use_shell = TRUE;
	res = wsh_construct_sudo_cmd(req, &amp;err);
	g_assert_cmpstr(res, ==,
	                "sudo -sA -u root "LIBEXEC_PATH"/wsh-killer 0 /bin/sh -c '/bin/ls'");
	g_assert_no_error(err);
	g_free(res);
	req-&gt;username = "worr";
	req-&gt;use_shell = TRUE;
	res = wsh_construct_sudo_cmd(req, &amp;err);
	g_assert_cmpstr(res, ==,
	                "sudo -sA -u worr "LIBEXEC_PATH"/wsh-killer 0 /bin/sh -c '/bin/ls'");
	g_assert_no_error(err);
	g_free(res);
	req-&gt;username = "";
	req-&gt;use_shell = TRUE;
	res = wsh_construct_sudo_cmd(req, &amp;err);
	g_assert_cmpstr(res, ==,
	                "sudo -sA -u root "LIBEXEC_PATH"/wsh-killer 0 /bin/sh -c '/bin/ls'");
	g_assert_no_error(err);
	g_free(res);
	req-&gt;username = " ";</b></font>
	res = wsh_construct_sudo_cmd(req, &amp;err);
	g_assert_cmpstr(res, ==, NULL);
	g_assert_error(err, WSH_CMD_ERROR, WSH_CMD_PW_ERR);
	g_error_free(err);
	err = NULL;
	g_free(res);
	req-&gt;cmd_string = "";
	req-&gt;username = "";
	res = wsh_construct_sudo_cmd(req, &amp;err);
	g_assert_no_error(err);
	g_assert(res == NULL);
	req-&gt;cmd_string = NULL;
	res = wsh_construct_sudo_cmd(req, &amp;err);
	g_assert_no_error(err);
	g_assert(res == NULL);
}
static void test_wsh_run_cmd_path(struct test_wsh_run_cmd_data* fixture,
                                  gconstpointer user_data) {
	wsh_cmd_req_t* req = fixture-&gt;req;
	wsh_cmd_res_t* res = fixture-&gt;res;
	req-&gt;cmd_string = "ls";
	wsh_run_cmd(res, req);
	g_assert(res-&gt;exit_status == 0);
}
static void test_wsh_run_cmd_timeout(struct test_wsh_run_cmd_data* fixture,
                                     gconstpointer user_data) {
	g_test_timer_start();
	fixture-&gt;req-&gt;cmd_string = "/bin/sleep 5";
	fixture-&gt;req-&gt;timeout = 1;
	wsh_run_cmd(fixture-&gt;res, fixture-&gt;req);
	gdouble time_len = g_test_timer_elapsed();
	g_assert(time_len &lt; 4.5);
}
int main(int argc, char** argv, char** env) {
	g_test_init(&amp;argc, &amp;argv, NULL);
	g_test_add("/Library/RunCmd/ConstructSudoCmd", struct test_wsh_run_cmd_data,
	           NULL, setup, test_construct_sudo_cmd, teardown);
	g_test_add("/Library/RunCmd/ExitCode", struct test_wsh_run_cmd_data, NULL,
	           setup, test_run_exit_code, teardown);
	g_test_add("/Library/RunCmd/Stdout", struct test_wsh_run_cmd_data, NULL, setup,
	           test_run_stdout, teardown);
	g_test_add("/Library/RunCmd/Stderr", struct test_wsh_run_cmd_data, NULL, setup,
	           test_run_stderr, teardown);
	g_test_add("/Library/RunCmd/Errors", struct test_wsh_run_cmd_data, NULL, setup,
	           test_run_err, teardown);
	g_test_add("/Library/RunCmd/Path", struct test_wsh_run_cmd_data, NULL, setup,
	           test_wsh_run_cmd_path, teardown);
	g_test_add("/Library/RunCmd/Timeout", struct test_wsh_run_cmd_data, NULL, setup,
	           test_wsh_run_cmd_timeout, teardown);
	return g_test_run();
}
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>test_cmd_messages_proto.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
#include &lt;glib.h&gt;
#include &lt;stdlib.h&gt;
#include "auth.pb-c.h"
#include "cmd-messages.pb-c.h"
static gchar* ai_username = "will";
static gchar* ai_password = "test";
static gchar* req_cmd = "ls";
static gchar* req_stdin[2] = { "yes", "no" };
static gchar* req_env[3] = { "PATH=/usr/bin", "USER=will", "MAILTO=will@worrbase.com" };
static gchar* req_cwd = "/tmp";
static guint64 req_timeout = 5;
static gboolean req_use_shell = TRUE;
static const gsize simple_req_len = 6;
static const guint8 simple_req[] = { 0x0a, 0x02, 0x6c, 0x73, 0x3a, 0x00, };
static const gsize auth_req_len = 20;
static const guint8 auth_req[]
    = { 0x0a, 0x02, 0x6c, 0x73, 0x12, 0x0c, 0x0a, 0x04, 0x77, 0x69, 0x6c, 0x6c, 0x12, 0x04, 0x74, 0x65, 0x73, 0x74, 0x3a, 0x00, };
static const gsize complex_req_len = 77;
static const guint8 complex_req[]
    = { 0x0a, 0x02, 0x6c, 0x73, 0x1a, 0x03, 0x79, 0x65, 0x73, 0x1a, 0x02, 0x6e, 0x6f, 0x22, 0x0d, 0x50, 0x41, 0x54,
        0x48, 0x3d, 0x2f, 0x75, 0x73, 0x72, 0x2f, 0x62, 0x69, 0x6e, 0x22, 0x09, 0x55, 0x53, 0x45, 0x52, 0x3d, 0x77,
        0x69, 0x6c, 0x6c, 0x22, 0x18, 0x4d, 0x41, 0x49, 0x4c, 0x54, 0x4f, 0x3d, 0x77, 0x69, 0x6c, 0x6c, 0x40, 0x77,
        0x6f, 0x72, 0x72, 0x62, 0x61, 0x73, 0x65, 0x2e, 0x63, 0x6f, 0x6d, 0x2a, 0x04, 0x2f, 0x74, 0x6d, 0x70, 0x30,
        0x05, 0x3a, 0x00, 0x58, 0x01
      } ;
static gchar* reply_stdout[4] = { "main.c", "cmd.c", "log.c", "tons of tests" };
static gchar** reply_stderr = NULL;
static const gint reply_ret_code = 0;
static const gsize simple_reply_len = 39;
static const guint8 simple_reply[39]
    = { 0x0a, 0x06, 0x6d, 0x61, 0x69, 0x6e, 0x2e, 0x63, 0x0a, 0x05, 0x63, 0x6d, 0x64, 0x2e, 0x63, 0x0a, 0x05, 0x6c,
        0x6f, 0x67, 0x2e, 0x63, 0x0a, 0x0d, 0x74, 0x6f, 0x6e, 0x73, 0x20, 0x6f, 0x66, 0x20, 0x74, 0x65, 0x73, 0x74,
        0x73, 0x18, 0x00
      };
static const gsize corrupted_req_len = 4;
static const guint8 corrupted_req[5] = { 0x0a, 0x05, 0x02, 0x6c, 0x73 };
static const gsize corrupted_reply_len = 39;
static const guint8 corrupted_reply[39]
    = { 0x5a, 0x06, 0x6d, 0x61, 0x69, 0x6e, 0x2e, 0x63, 0x0a, 0x05, 0x63, 0x6d, 0x64, 0x2e, 0x63, 0x0a, 0x05, 0x6c,
        0x6f, 0x67, 0x2e, 0x63, 0x1e, 0x0d, 0x74, 0x6f, 0x6e, 0x73, 0x20, 0x6f, 0x66, 0x20, 0x74, 0x65, 0x73, 0x74,
        0x73, 0x18, 0x00
      };
static void test_packing_simple_cmd_request(void) {
	CommandRequest req = COMMAND_REQUEST__INIT;
	gsize len;
	guint8* buf;
	req.command = req_cmd;
	len = command_request__get_packed_size(&amp;req);
	g_assert(len == simple_req_len);
	buf = g_slice_alloc0(len);
	command_request__pack(&amp;req, buf);
	for (gsize i = 0; i &lt; len; i++) {
		g_assert(buf[i] == simple_req[i]);
	}
	g_slice_free1(len, buf);
}
static void test_unpacking_simple_cmd_request(void) {
	CommandRequest* req = NULL;
	req = command_request__unpack(NULL, simple_req_len, simple_req);
	g_assert(req != NULL);
	g_assert_cmpstr(req-&gt;command, ==, req_cmd);
	g_assert(req-&gt;stdin == NULL);
	g_assert(req-&gt;env == NULL);
	g_assert(req-&gt;cwd == NULL);
	g_assert(req-&gt;has_timeout == FALSE);
	command_request__free_unpacked(req, NULL);
}
static void test_packing_auth_cmd_request(void) {
	AuthInfo ai = AUTH_INFO__INIT;
	CommandRequest req = COMMAND_REQUEST__INIT;
	gsize len;
	guint8* buf;
	ai.username = ai_username;
	ai.password = ai_password;
	req.auth = &amp;ai;
	req.command = req_cmd;
	len = command_request__get_packed_size(&amp;req);
	g_assert(len == auth_req_len);
	buf = g_slice_alloc0(len);
	command_request__pack(&amp;req, buf);
	for (gsize i = 0; i &lt; len; i++) {
		g_assert(buf[i] == auth_req[i]);
	}
	g_slice_free1(len, buf);
}
static void test_unpacking_auth_cmd_request(void) {
	CommandRequest* req;
	req = command_request__unpack(NULL, auth_req_len, auth_req);
	g_assert_cmpstr(req-&gt;auth-&gt;username, ==, ai_username);
	g_assert_cmpstr(req-&gt;auth-&gt;password, ==, ai_password);
	g_assert_cmpstr(req-&gt;command, ==, req_cmd);
	g_assert(req-&gt;stdin == NULL);
	g_assert(req-&gt;env == NULL);
	g_assert(req-&gt;cwd == NULL);
	g_assert(req-&gt;has_timeout == FALSE);
	command_request__free_unpacked(req, NULL);
<a name="0"></a>}
static void test_packing_complex_cmd_request(void) {
<font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>	CommandRequest req = COMMAND_REQUEST__INIT;
	gsize len;
	guint8* buf;
	req.command = req_cmd;
	req.stdin = req_stdin;
	req.n_stdin = 2;
	req.env = req_env;
	req.n_env = 3;
	req.cwd = req_cwd;
	req.has_timeout = TRUE;
	req.timeout = req_timeout;
	req.has_use_shell = TRUE;
	req.use_shell = req_use_shell;
	len = command_request__get_packed_size(&amp;req);
	g_assert(len == complex_req_len);
	buf = g_slice_alloc0(len);</b></font>
	command_request__pack(&amp;req, buf);
	for (gsize i = 0; i &lt; len; i++) {
		g_assert(buf[i] == complex_req[i]);
	}
	g_slice_free1(len, buf);
}
static void test_unpacking_complex_cmd_request(void) {
	CommandRequest* req;
	req = command_request__unpack(NULL, complex_req_len, complex_req);
	g_assert_cmpstr(req-&gt;command, ==, req_cmd);
	g_assert(req-&gt;auth == NULL);
	g_assert(req-&gt;n_stdin == 2);
	g_assert(req-&gt;n_env == 3);
	g_assert_cmpstr(req-&gt;cwd, ==, req_cwd);
	g_assert(req-&gt;has_timeout);
	g_assert(req-&gt;timeout == req_timeout);
	g_assert(req-&gt;use_shell == req_use_shell);
	for (gsize i = 0; i &lt; req-&gt;n_stdin; i++) {
		g_assert_cmpstr(req-&gt;stdin[i], ==, req_stdin[i]);
	}
	for (gsize i = 0; i &lt; req-&gt;n_env; i++) {
		g_assert_cmpstr(req-&gt;env[i], ==, req_env[i]);
	}
	command_request__free_unpacked(req, NULL);
}
static void test_packing_cmd_response(void) {
	CommandReply reply = COMMAND_REPLY__INIT;
	gsize len;
	guint8* buf;
	reply.stdout = reply_stdout;
	reply.n_stdout = 4;
	reply.stderr = reply_stderr;
	reply.n_stderr = 0;
	reply.ret_code = reply_ret_code;
	len = command_reply__get_packed_size(&amp;reply);
	g_assert(len == simple_reply_len);
	buf = g_slice_alloc0(len);
	command_reply__pack(&amp;reply, buf);
	g_assert(buf != NULL);
	for (gsize i = 0; i &lt; len; i++) {
		g_assert(buf[i] == simple_reply[i]);
	}
	g_slice_free1(len, buf);
}
static void test_unpacking_cmd_response(void) {
	CommandReply* reply = NULL;
	reply = command_reply__unpack(NULL, simple_reply_len, simple_reply);
	g_assert(reply != NULL);
	g_assert(reply-&gt;n_stdout == 4);
	g_assert(reply-&gt;n_stderr == 0);
	g_assert(reply-&gt;ret_code == reply_ret_code);
	for (gsize i = 0; i &lt; reply-&gt;n_stdout; i++) {
		g_assert_cmpstr(reply-&gt;stdout[i], ==, reply_stdout[i]);
	}
	command_reply__free_unpacked(reply, NULL);
}
#if GLIB_CHECK_VERSION(2, 38, 0)
static void test_unpacking_corrupted_request_subprocess(void) {
	CommandRequest* req = NULL;
	command_request__unpack(NULL, corrupted_req_len, corrupted_req);
	g_assert(req == NULL);
	exit(0);
}
#endif
static void test_unpacking_corrupted_request(void) {
#if GLIB_CHECK_VERSION(2, 38, 0)
	g_test_trap_subprocess("/Library/Protocol/UnpackCorruptCommandRequest/subprocess",
	                       0, 0);
	g_test_trap_assert_passed();
#else
	CommandRequest* req = NULL;
	if (g_test_trap_fork(0, G_TEST_TRAP_SILENCE_STDOUT)) {
		req = command_request__unpack(NULL, corrupted_req_len, corrupted_req);
		exit(0);
	}
	g_assert(req == NULL);
#endif
}
#if GLIB_CHECK_VERSION(2, 38, 0)
static void test_unpacking_corrupted_response_subproccess(void) {
	CommandReply* reply = NULL;
	command_reply__unpack(NULL, corrupted_reply_len, corrupted_reply);
	g_assert(reply == NULL);
	exit(0);
}
#endif
static void test_unpacking_corrupted_response(void) {
#if GLIB_CHECK_VERSION(2, 38, 0)
	g_test_trap_subprocess("/Library/Protocol/UnpackCorruptCommandReply/subprocess",
	                       0, 0);
	g_test_trap_assert_passed();
#else
	CommandReply* reply = NULL;
	if (g_test_trap_fork(0, G_TEST_TRAP_SILENCE_STDOUT)) {
		reply = command_reply__unpack(NULL, corrupted_reply_len, corrupted_reply);
		exit(0);
	}
	g_assert(reply == NULL);
#endif
}
int main(int argc, char** argv) {
	g_test_init(&amp;argc, &amp;argv, NULL);
	g_test_add_func("/Library/Protocol/PackSimpleCommandRequest",
	                test_packing_simple_cmd_request);
	g_test_add_func("/Library/Protocol/UnpackSimpleCommandRequest",
	                test_unpacking_simple_cmd_request);
	g_test_add_func("/Library/Protocol/PackAuthCommandRequest",
	                test_packing_auth_cmd_request);
	g_test_add_func("/Library/Protocol/UnpackAuthCommandRequest",
	                test_unpacking_auth_cmd_request);
	g_test_add_func("/Library/Protocol/PackComplexCommandRequest",
	                test_packing_complex_cmd_request);
	g_test_add_func("/Library/Protocol/UnpackComplexCommandRequest",
	                test_unpacking_complex_cmd_request);
	g_test_add_func("/Library/Protocol/PackCommandReply",
	                test_packing_cmd_response);
	g_test_add_func("/Library/Protocol/UnpackCommandReply",
	                test_unpacking_cmd_response);
	g_test_add_func("/Library/Protocol/UnpackCorruptCommandRequest",
	                test_unpacking_corrupted_request);
	g_test_add_func("/Library/Protocol/UnpackCorruptCommandReply",
	                test_unpacking_corrupted_response);
#if GLIB_CHECK_VERSION(2, 38, 0)
	g_test_add_func("/Library/Protocol/UnpackCorruptCommandRequest/subprocess",
	                test_unpacking_corrupted_request_subprocess);
	g_test_add_func("/Library/Protocol/UnpackCorruptCommandReply/subprocess",
	                test_unpacking_corrupted_response_subproccess);
#endif
	return g_test_run();
}
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
