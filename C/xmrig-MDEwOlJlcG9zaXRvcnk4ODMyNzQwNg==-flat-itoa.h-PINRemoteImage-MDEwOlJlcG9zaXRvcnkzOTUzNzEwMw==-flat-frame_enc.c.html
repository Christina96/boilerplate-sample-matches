
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 2.4691358024691357%, Tokens: 9</h2>
        <div class="column">
            <h3>xmrig-MDEwOlJlcG9zaXRvcnk4ODMyNzQwNg==-flat-itoa.h</h3>
            <pre><code>1  #ifndef RAPIDJSON_ITOA_
2  #define RAPIDJSON_ITOA_
3  #include "../rapidjson.h"
4  RAPIDJSON_NAMESPACE_BEGIN
5  namespace internal {
6  inline const char* GetDigitsLut() {
7      static const char cDigitsLut[200] = {
8          '0','0','0','1','0','2','0','3','0','4','0','5','0','6','0','7','0','8','0','9',
9          '1','0','1','1','1','2','1','3','1','4','1','5','1','6','1','7','1','8','1','9',
10          '2','0','2','1','2','2','2','3','2','4','2','5','2','6','2','7','2','8','2','9',
11          '3','0','3','1','3','2','3','3','3','4','3','5','3','6','3','7','3','8','3','9',
12          '4','0','4','1','4','2','4','3','4','4','4','5','4','6','4','7','4','8','4','9',
13          '5','0','5','1','5','2','5','3','5','4','5','5','5','6','5','7','5','8','5','9',
14          '6','0','6','1','6','2','6','3','6','4','6','5','6','6','6','7','6','8','6','9',
15          '7','0','7','1','7','2','7','3','7','4','7','5','7','6','7','7','7','8','7','9',
16          '8','0','8','1','8','2','8','3','8','4','8','5','8','6','8','7','8','8','8','9',
17          '9','0','9','1','9','2','9','3','9','4','9','5','9','6','9','7','9','8','9','9'
18      };
19      return cDigitsLut;
20  }
21  inline char* u32toa(uint32_t value, char* buffer) {
22      RAPIDJSON_ASSERT(buffer != 0);
23      const char* cDigitsLut = GetDigitsLut();
24      if (value < 10000) {
25          const uint32_t d1 = (value / 100) << 1;
26          const uint32_t d2 = (value % 100) << 1;
27          if (value >= 1000)
28              *buffer++ = cDigitsLut[d1];
29          if (value >= 100)
30              *buffer++ = cDigitsLut[d1 + 1];
31          if (value >= 10)
32              *buffer++ = cDigitsLut[d2];
33          *buffer++ = cDigitsLut[d2 + 1];
34      }
35      else if (value < 100000000) {
36          const uint32_t b = value / 10000;
37          const uint32_t c = value % 10000;
38          const uint32_t d1 = (b / 100) << 1;
39          const uint32_t d2 = (b % 100) << 1;
40          const uint32_t d3 = (c / 100) << 1;
41          const uint32_t d4 = (c % 100) << 1;
42          if (value >= 10000000)
43              *buffer++ = cDigitsLut[d1];
44          if (value >= 1000000)
45              *buffer++ = cDigitsLut[d1 + 1];
46          if (value >= 100000)
47              *buffer++ = cDigitsLut[d2];
48          *buffer++ = cDigitsLut[d2 + 1];
49          *buffer++ = cDigitsLut[d3];
50          *buffer++ = cDigitsLut[d3 + 1];
51          *buffer++ = cDigitsLut[d4];
52          *buffer++ = cDigitsLut[d4 + 1];
53      }
54      else {
55          const uint32_t a = value / 100000000; 
56          value %= 100000000;
57          if (a >= 10) {
58              const unsigned i = a << 1;
59              *buffer++ = cDigitsLut[i];
60              *buffer++ = cDigitsLut[i + 1];
61          }
62          else
63              *buffer++ = static_cast<char>('0' + static_cast<char>(a));
64          const uint32_t b = value / 10000; 
65          const uint32_t c = value % 10000; 
66          const uint32_t d1 = (b / 100) << 1;
67          const uint32_t d2 = (b % 100) << 1;
68          const uint32_t d3 = (c / 100) << 1;
69          const uint32_t d4 = (c % 100) << 1;
70          *buffer++ = cDigitsLut[d1];
71          *buffer++ = cDigitsLut[d1 + 1];
72          *buffer++ = cDigitsLut[d2];
73          *buffer++ = cDigitsLut[d2 + 1];
74          *buffer++ = cDigitsLut[d3];
75          *buffer++ = cDigitsLut[d3 + 1];
76          *buffer++ = cDigitsLut[d4];
77          *buffer++ = cDigitsLut[d4 + 1];
78      }
79      return buffer;
80  }
81  inline char* i32toa(int32_t value, char* buffer) {
82      RAPIDJSON_ASSERT(buffer != 0);
83      uint32_t u = static_cast<uint32_t>(value);
84      if (value < 0) {
85          *buffer++ = '-';
86          u = ~u + 1;
87      }
88      return u32toa(u, buffer);
89  }
90  inline char* u64toa(uint64_t value, char* buffer) {
91      RAPIDJSON_ASSERT(buffer != 0);
<span onclick='openModal()' class='match'>92      const char* cDigitsLut = GetDigitsLut();
93      const uint64_t  kTen8 = 100000000;
94      const uint64_t  kTen9 = kTen8 * 10;
95      const uint64_t kTen10 = kTen8 * 100;
</span>96      const uint64_t kTen11 = kTen8 * 1000;
97      const uint64_t kTen12 = kTen8 * 10000;
98      const uint64_t kTen13 = kTen8 * 100000;
99      const uint64_t kTen14 = kTen8 * 1000000;
100      const uint64_t kTen15 = kTen8 * 10000000;
101      const uint64_t kTen16 = kTen8 * kTen8;
102      if (value < kTen8) {
103          uint32_t v = static_cast<uint32_t>(value);
104          if (v < 10000) {
105              const uint32_t d1 = (v / 100) << 1;
106              const uint32_t d2 = (v % 100) << 1;
107              if (v >= 1000)
108                  *buffer++ = cDigitsLut[d1];
109              if (v >= 100)
110                  *buffer++ = cDigitsLut[d1 + 1];
111              if (v >= 10)
112                  *buffer++ = cDigitsLut[d2];
113              *buffer++ = cDigitsLut[d2 + 1];
114          }
115          else {
116              const uint32_t b = v / 10000;
117              const uint32_t c = v % 10000;
118              const uint32_t d1 = (b / 100) << 1;
119              const uint32_t d2 = (b % 100) << 1;
120              const uint32_t d3 = (c / 100) << 1;
121              const uint32_t d4 = (c % 100) << 1;
122              if (value >= 10000000)
123                  *buffer++ = cDigitsLut[d1];
124              if (value >= 1000000)
125                  *buffer++ = cDigitsLut[d1 + 1];
126              if (value >= 100000)
127                  *buffer++ = cDigitsLut[d2];
128              *buffer++ = cDigitsLut[d2 + 1];
129              *buffer++ = cDigitsLut[d3];
130              *buffer++ = cDigitsLut[d3 + 1];
131              *buffer++ = cDigitsLut[d4];
132              *buffer++ = cDigitsLut[d4 + 1];
133          }
134      }
135      else if (value < kTen16) {
136          const uint32_t v0 = static_cast<uint32_t>(value / kTen8);
137          const uint32_t v1 = static_cast<uint32_t>(value % kTen8);
138          const uint32_t b0 = v0 / 10000;
139          const uint32_t c0 = v0 % 10000;
140          const uint32_t d1 = (b0 / 100) << 1;
141          const uint32_t d2 = (b0 % 100) << 1;
142          const uint32_t d3 = (c0 / 100) << 1;
143          const uint32_t d4 = (c0 % 100) << 1;
144          const uint32_t b1 = v1 / 10000;
145          const uint32_t c1 = v1 % 10000;
146          const uint32_t d5 = (b1 / 100) << 1;
147          const uint32_t d6 = (b1 % 100) << 1;
148          const uint32_t d7 = (c1 / 100) << 1;
149          const uint32_t d8 = (c1 % 100) << 1;
150          if (value >= kTen15)
151              *buffer++ = cDigitsLut[d1];
152          if (value >= kTen14)
153              *buffer++ = cDigitsLut[d1 + 1];
154          if (value >= kTen13)
155              *buffer++ = cDigitsLut[d2];
156          if (value >= kTen12)
157              *buffer++ = cDigitsLut[d2 + 1];
158          if (value >= kTen11)
159              *buffer++ = cDigitsLut[d3];
160          if (value >= kTen10)
161              *buffer++ = cDigitsLut[d3 + 1];
162          if (value >= kTen9)
163              *buffer++ = cDigitsLut[d4];
164          *buffer++ = cDigitsLut[d4 + 1];
165          *buffer++ = cDigitsLut[d5];
166          *buffer++ = cDigitsLut[d5 + 1];
167          *buffer++ = cDigitsLut[d6];
168          *buffer++ = cDigitsLut[d6 + 1];
169          *buffer++ = cDigitsLut[d7];
170          *buffer++ = cDigitsLut[d7 + 1];
171          *buffer++ = cDigitsLut[d8];
172          *buffer++ = cDigitsLut[d8 + 1];
173      }
174      else {
175          const uint32_t a = static_cast<uint32_t>(value / kTen16); 
176          value %= kTen16;
177          if (a < 10)
178              *buffer++ = static_cast<char>('0' + static_cast<char>(a));
179          else if (a < 100) {
180              const uint32_t i = a << 1;
181              *buffer++ = cDigitsLut[i];
182              *buffer++ = cDigitsLut[i + 1];
183          }
184          else if (a < 1000) {
185              *buffer++ = static_cast<char>('0' + static_cast<char>(a / 100));
186              const uint32_t i = (a % 100) << 1;
187              *buffer++ = cDigitsLut[i];
188              *buffer++ = cDigitsLut[i + 1];
189          }
190          else {
191              const uint32_t i = (a / 100) << 1;
192              const uint32_t j = (a % 100) << 1;
193              *buffer++ = cDigitsLut[i];
194              *buffer++ = cDigitsLut[i + 1];
195              *buffer++ = cDigitsLut[j];
196              *buffer++ = cDigitsLut[j + 1];
197          }
198          const uint32_t v0 = static_cast<uint32_t>(value / kTen8);
199          const uint32_t v1 = static_cast<uint32_t>(value % kTen8);
200          const uint32_t b0 = v0 / 10000;
201          const uint32_t c0 = v0 % 10000;
202          const uint32_t d1 = (b0 / 100) << 1;
203          const uint32_t d2 = (b0 % 100) << 1;
204          const uint32_t d3 = (c0 / 100) << 1;
205          const uint32_t d4 = (c0 % 100) << 1;
206          const uint32_t b1 = v1 / 10000;
207          const uint32_t c1 = v1 % 10000;
208          const uint32_t d5 = (b1 / 100) << 1;
209          const uint32_t d6 = (b1 % 100) << 1;
210          const uint32_t d7 = (c1 / 100) << 1;
211          const uint32_t d8 = (c1 % 100) << 1;
212          *buffer++ = cDigitsLut[d1];
213          *buffer++ = cDigitsLut[d1 + 1];
214          *buffer++ = cDigitsLut[d2];
215          *buffer++ = cDigitsLut[d2 + 1];
216          *buffer++ = cDigitsLut[d3];
217          *buffer++ = cDigitsLut[d3 + 1];
218          *buffer++ = cDigitsLut[d4];
219          *buffer++ = cDigitsLut[d4 + 1];
220          *buffer++ = cDigitsLut[d5];
221          *buffer++ = cDigitsLut[d5 + 1];
222          *buffer++ = cDigitsLut[d6];
223          *buffer++ = cDigitsLut[d6 + 1];
224          *buffer++ = cDigitsLut[d7];
225          *buffer++ = cDigitsLut[d7 + 1];
226          *buffer++ = cDigitsLut[d8];
227          *buffer++ = cDigitsLut[d8 + 1];
228      }
229      return buffer;
230  }
231  inline char* i64toa(int64_t value, char* buffer) {
232      RAPIDJSON_ASSERT(buffer != 0);
233      uint64_t u = static_cast<uint64_t>(value);
234      if (value < 0) {
235          *buffer++ = '-';
236          u = ~u + 1;
237      }
238      return u64toa(u, buffer);
239  }
240  } 
241  RAPIDJSON_NAMESPACE_END
242  #endif 
</code></pre>
        </div>
        <div class="column">
            <h3>PINRemoteImage-MDEwOlJlcG9zaXRvcnkzOTUzNzEwMw==-flat-frame_enc.c</h3>
            <pre><code>1  #include <string.h>
2  #include <math.h>
3  #include "src/enc/cost_enc.h"
4  #include "src/enc/vp8i_enc.h"
5  #include "src/dsp/dsp.h"
6  #include "src/webp/format_constants.h"  
7  #define SEGMENT_VISU 0
8  #define DEBUG_SEARCH 0    
9  #define HEADER_SIZE_ESTIMATE (RIFF_HEADER_SIZE + CHUNK_HEADER_SIZE +  \
10                                VP8_FRAME_HEADER_SIZE)
11  #define DQ_LIMIT 0.4  
12  #define PARTITION0_SIZE_LIMIT ((VP8_MAX_PARTITION0_SIZE - 2048ULL) << 11)
13  typedef struct {  
14    int is_first;
15    float dq;
16    float q, last_q;
17    double value, last_value;   
18    double target;
19    int do_size_search;
20  } PassStats;
21  static int InitPassStats(const VP8Encoder* const enc, PassStats* const s) {
22    const uint64_t target_size = (uint64_t)enc->config_->target_size;
23    const int do_size_search = (target_size != 0);
24    const float target_PSNR = enc->config_->target_PSNR;
25    s->is_first = 1;
26    s->dq = 10.f;
27    s->q = s->last_q = enc->config_->quality;
28    s->target = do_size_search ? (double)target_size
29              : (target_PSNR > 0.) ? target_PSNR
30              : 40.;   
31    s->value = s->last_value = 0.;
32    s->do_size_search = do_size_search;
33    return do_size_search;
34  }
35  static float Clamp(float v, float min, float max) {
36    return (v < min) ? min : (v > max) ? max : v;
37  }
38  static float ComputeNextQ(PassStats* const s) {
39    float dq;
40    if (s->is_first) {
41      dq = (s->value > s->target) ? -s->dq : s->dq;
42      s->is_first = 0;
43    } else if (s->value != s->last_value) {
44      const double slope = (s->target - s->value) / (s->last_value - s->value);
45      dq = (float)(slope * (s->last_q - s->q));
46    } else {
47      dq = 0.;  
48    }
49    s->dq = Clamp(dq, -30.f, 30.f);
50    s->last_q = s->q;
51    s->last_value = s->value;
52    s->q = Clamp(s->q + s->dq, 0.f, 100.f);
53    return s->q;
54  }
55  const uint8_t VP8Cat3[] = { 173, 148, 140 };
56  const uint8_t VP8Cat4[] = { 176, 155, 140, 135 };
57  const uint8_t VP8Cat5[] = { 180, 157, 141, 134, 130 };
58  const uint8_t VP8Cat6[] =
59      { 254, 254, 243, 230, 196, 177, 153, 140, 133, 130, 129 };
60  static void ResetStats(VP8Encoder* const enc) {
61    VP8EncProba* const proba = &enc->proba_;
62    VP8CalculateLevelCosts(proba);
63    proba->nb_skip_ = 0;
64  }
65  #define SKIP_PROBA_THRESHOLD 250  
66  static int CalcSkipProba(uint64_t nb, uint64_t total) {
67    return (int)(total ? (total - nb) * 255 / total : 255);
68  }
69  static int FinalizeSkipProba(VP8Encoder* const enc) {
70    VP8EncProba* const proba = &enc->proba_;
71    const int nb_mbs = enc->mb_w_ * enc->mb_h_;
72    const int nb_events = proba->nb_skip_;
73    int size;
74    proba->skip_proba_ = CalcSkipProba(nb_events, nb_mbs);
75    proba->use_skip_proba_ = (proba->skip_proba_ < SKIP_PROBA_THRESHOLD);
76    size = 256;   
77    if (proba->use_skip_proba_) {
78      size +=  nb_events * VP8BitCost(1, proba->skip_proba_)
79           + (nb_mbs - nb_events) * VP8BitCost(0, proba->skip_proba_);
80      size += 8 * 256;   
81    }
82    return size;
83  }
84  static int CalcTokenProba(int nb, int total) {
85    assert(nb <= total);
86    return nb ? (255 - nb * 255 / total) : 255;
87  }
88  static int BranchCost(int nb, int total, int proba) {
89    return nb * VP8BitCost(1, proba) + (total - nb) * VP8BitCost(0, proba);
90  }
91  static void ResetTokenStats(VP8Encoder* const enc) {
92    VP8EncProba* const proba = &enc->proba_;
93    memset(proba->stats_, 0, sizeof(proba->stats_));
94  }
95  static int FinalizeTokenProbas(VP8EncProba* const proba) {
96    int has_changed = 0;
97    int size = 0;
98    int t, b, c, p;
99    for (t = 0; t < NUM_TYPES; ++t) {
100      for (b = 0; b < NUM_BANDS; ++b) {
101        for (c = 0; c < NUM_CTX; ++c) {
102          for (p = 0; p < NUM_PROBAS; ++p) {
103            const proba_t stats = proba->stats_[t][b][c][p];
104            const int nb = (stats >> 0) & 0xffff;
105            const int total = (stats >> 16) & 0xffff;
106            const int update_proba = VP8CoeffsUpdateProba[t][b][c][p];
107            const int old_p = VP8CoeffsProba0[t][b][c][p];
108            const int new_p = CalcTokenProba(nb, total);
109            const int old_cost = BranchCost(nb, total, old_p)
110                               + VP8BitCost(0, update_proba);
111            const int new_cost = BranchCost(nb, total, new_p)
112                               + VP8BitCost(1, update_proba)
113                               + 8 * 256;
114            const int use_new_p = (old_cost > new_cost);
115            size += VP8BitCost(use_new_p, update_proba);
116            if (use_new_p) {  
117              proba->coeffs_[t][b][c][p] = new_p;
118              has_changed |= (new_p != old_p);
119              size += 8 * 256;
120            } else {
121              proba->coeffs_[t][b][c][p] = old_p;
122            }
123          }
124        }
125      }
126    }
127    proba->dirty_ = has_changed;
128    return size;
129  }
130  static int GetProba(int a, int b) {
131    const int total = a + b;
132    return (total == 0) ? 255     
133                        : (255 * a + total / 2) / total;  
134  }
135  static void ResetSegments(VP8Encoder* const enc) {
136    int n;
137    for (n = 0; n < enc->mb_w_ * enc->mb_h_; ++n) {
138      enc->mb_info_[n].segment_ = 0;
139    }
140  }
141  static void SetSegmentProbas(VP8Encoder* const enc) {
142    int p[NUM_MB_SEGMENTS] = { 0 };
143    int n;
144    for (n = 0; n < enc->mb_w_ * enc->mb_h_; ++n) {
145      const VP8MBInfo* const mb = &enc->mb_info_[n];
146      ++p[mb->segment_];
147    }
148  #if !defined(WEBP_DISABLE_STATS)
149    if (enc->pic_->stats != NULL) {
150      for (n = 0; n < NUM_MB_SEGMENTS; ++n) {
151        enc->pic_->stats->segment_size[n] = p[n];
152      }
153    }
154  #endif
155    if (enc->segment_hdr_.num_segments_ > 1) {
156      uint8_t* const probas = enc->proba_.segments_;
157      probas[0] = GetProba(p[0] + p[1], p[2] + p[3]);
158      probas[1] = GetProba(p[0], p[1]);
159      probas[2] = GetProba(p[2], p[3]);
160      enc->segment_hdr_.update_map_ =
161          (probas[0] != 255) || (probas[1] != 255) || (probas[2] != 255);
162      if (!enc->segment_hdr_.update_map_) ResetSegments(enc);
163      enc->segment_hdr_.size_ =
164          p[0] * (VP8BitCost(0, probas[0]) + VP8BitCost(0, probas[1])) +
165          p[1] * (VP8BitCost(0, probas[0]) + VP8BitCost(1, probas[1])) +
166          p[2] * (VP8BitCost(1, probas[0]) + VP8BitCost(0, probas[2])) +
167          p[3] * (VP8BitCost(1, probas[0]) + VP8BitCost(1, probas[2]));
168    } else {
169      enc->segment_hdr_.update_map_ = 0;
170      enc->segment_hdr_.size_ = 0;
171    }
172  }
173  static int PutCoeffs(VP8BitWriter* const bw, int ctx, const VP8Residual* res) {
174    int n = res->first;
175    const uint8_t* p = res->prob[n][ctx];
176    if (!VP8PutBit(bw, res->last >= 0, p[0])) {
177      return 0;
178    }
179    while (n < 16) {
180      const int c = res->coeffs[n++];
181      const int sign = c < 0;
182      int v = sign ? -c : c;
183      if (!VP8PutBit(bw, v != 0, p[1])) {
184        p = res->prob[VP8EncBands[n]][0];
185        continue;
186      }
187      if (!VP8PutBit(bw, v > 1, p[2])) {
188        p = res->prob[VP8EncBands[n]][1];
189      } else {
190        if (!VP8PutBit(bw, v > 4, p[3])) {
191          if (VP8PutBit(bw, v != 2, p[4])) {
192            VP8PutBit(bw, v == 4, p[5]);
193          }
194        } else if (!VP8PutBit(bw, v > 10, p[6])) {
195          if (!VP8PutBit(bw, v > 6, p[7])) {
196            VP8PutBit(bw, v == 6, 159);
197          } else {
198            VP8PutBit(bw, v >= 9, 165);
199            VP8PutBit(bw, !(v & 1), 145);
200          }
201        } else {
202          int mask;
203          const uint8_t* tab;
204          if (v < 3 + (8 << 1)) {          
205            VP8PutBit(bw, 0, p[8]);
206            VP8PutBit(bw, 0, p[9]);
207            v -= 3 + (8 << 0);
208            mask = 1 << 2;
209            tab = VP8Cat3;
210          } else if (v < 3 + (8 << 2)) {   
211            VP8PutBit(bw, 0, p[8]);
212            VP8PutBit(bw, 1, p[9]);
213            v -= 3 + (8 << 1);
214            mask = 1 << 3;
215            tab = VP8Cat4;
216          } else if (v < 3 + (8 << 3)) {   
217            VP8PutBit(bw, 1, p[8]);
218            VP8PutBit(bw, 0, p[10]);
219            v -= 3 + (8 << 2);
220            mask = 1 << 4;
221            tab = VP8Cat5;
222          } else {                         
223            VP8PutBit(bw, 1, p[8]);
224            VP8PutBit(bw, 1, p[10]);
225            v -= 3 + (8 << 3);
226            mask = 1 << 10;
227            tab = VP8Cat6;
228          }
229          while (mask) {
230            VP8PutBit(bw, !!(v & mask), *tab++);
231            mask >>= 1;
232          }
233        }
234        p = res->prob[VP8EncBands[n]][2];
235      }
236      VP8PutBitUniform(bw, sign);
237      if (n == 16 || !VP8PutBit(bw, n <= res->last, p[0])) {
238        return 1;   
239      }
240    }
241    return 1;
242  }
243  static void CodeResiduals(VP8BitWriter* const bw, VP8EncIterator* const it,
244                            const VP8ModeScore* const rd) {
245    int x, y, ch;
246    VP8Residual res;
247    uint64_t pos1, pos2, pos3;
248    const int i16 = (it->mb_->type_ == 1);
249    const int segment = it->mb_->segment_;
250    VP8Encoder* const enc = it->enc_;
251    VP8IteratorNzToBytes(it);
252    pos1 = VP8BitWriterPos(bw);
253    if (i16) {
254      VP8InitResidual(0, 1, enc, &res);
255      VP8SetResidualCoeffs(rd->y_dc_levels, &res);
256      it->top_nz_[8] = it->left_nz_[8] =
257        PutCoeffs(bw, it->top_nz_[8] + it->left_nz_[8], &res);
258      VP8InitResidual(1, 0, enc, &res);
259    } else {
260      VP8InitResidual(0, 3, enc, &res);
261    }
262    for (y = 0; y < 4; ++y) {
263      for (x = 0; x < 4; ++x) {
264        const int ctx = it->top_nz_[x] + it->left_nz_[y];
265        VP8SetResidualCoeffs(rd->y_ac_levels[x + y * 4], &res);
266        it->top_nz_[x] = it->left_nz_[y] = PutCoeffs(bw, ctx, &res);
267      }
268    }
269    pos2 = VP8BitWriterPos(bw);
270    VP8InitResidual(0, 2, enc, &res);
271    for (ch = 0; ch <= 2; ch += 2) {
272      for (y = 0; y < 2; ++y) {
273        for (x = 0; x < 2; ++x) {
274          const int ctx = it->top_nz_[4 + ch + x] + it->left_nz_[4 + ch + y];
275          VP8SetResidualCoeffs(rd->uv_levels[ch * 2 + x + y * 2], &res);
276          it->top_nz_[4 + ch + x] = it->left_nz_[4 + ch + y] =
277              PutCoeffs(bw, ctx, &res);
278        }
279      }
280    }
281    pos3 = VP8BitWriterPos(bw);
282    it->luma_bits_ = pos2 - pos1;
283    it->uv_bits_ = pos3 - pos2;
284    it->bit_count_[segment][i16] += it->luma_bits_;
285    it->bit_count_[segment][2] += it->uv_bits_;
286    VP8IteratorBytesToNz(it);
287  }
288  static void RecordResiduals(VP8EncIterator* const it,
289                              const VP8ModeScore* const rd) {
290    int x, y, ch;
291    VP8Residual res;
292    VP8Encoder* const enc = it->enc_;
293    VP8IteratorNzToBytes(it);
294    if (it->mb_->type_ == 1) {   
295      VP8InitResidual(0, 1, enc, &res);
296      VP8SetResidualCoeffs(rd->y_dc_levels, &res);
297      it->top_nz_[8] = it->left_nz_[8] =
298        VP8RecordCoeffs(it->top_nz_[8] + it->left_nz_[8], &res);
299      VP8InitResidual(1, 0, enc, &res);
300    } else {
301      VP8InitResidual(0, 3, enc, &res);
302    }
303    for (y = 0; y < 4; ++y) {
304      for (x = 0; x < 4; ++x) {
305        const int ctx = it->top_nz_[x] + it->left_nz_[y];
306        VP8SetResidualCoeffs(rd->y_ac_levels[x + y * 4], &res);
307        it->top_nz_[x] = it->left_nz_[y] = VP8RecordCoeffs(ctx, &res);
308      }
309    }
310    VP8InitResidual(0, 2, enc, &res);
311    for (ch = 0; ch <= 2; ch += 2) {
312      for (y = 0; y < 2; ++y) {
313        for (x = 0; x < 2; ++x) {
314          const int ctx = it->top_nz_[4 + ch + x] + it->left_nz_[4 + ch + y];
315          VP8SetResidualCoeffs(rd->uv_levels[ch * 2 + x + y * 2], &res);
316          it->top_nz_[4 + ch + x] = it->left_nz_[4 + ch + y] =
317              VP8RecordCoeffs(ctx, &res);
318        }
319      }
320    }
321    VP8IteratorBytesToNz(it);
322  }
323  #if !defined(DISABLE_TOKEN_BUFFER)
324  static int RecordTokens(VP8EncIterator* const it, const VP8ModeScore* const rd,
325                          VP8TBuffer* const tokens) {
326    int x, y, ch;
327    VP8Residual res;
328    VP8Encoder* const enc = it->enc_;
329    VP8IteratorNzToBytes(it);
330    if (it->mb_->type_ == 1) {   
331      const int ctx = it->top_nz_[8] + it->left_nz_[8];
332      VP8InitResidual(0, 1, enc, &res);
333      VP8SetResidualCoeffs(rd->y_dc_levels, &res);
334      it->top_nz_[8] = it->left_nz_[8] =
335          VP8RecordCoeffTokens(ctx, &res, tokens);
336      VP8InitResidual(1, 0, enc, &res);
337    } else {
338      VP8InitResidual(0, 3, enc, &res);
339    }
340    for (y = 0; y < 4; ++y) {
341      for (x = 0; x < 4; ++x) {
342        const int ctx = it->top_nz_[x] + it->left_nz_[y];
343        VP8SetResidualCoeffs(rd->y_ac_levels[x + y * 4], &res);
344        it->top_nz_[x] = it->left_nz_[y] =
345            VP8RecordCoeffTokens(ctx, &res, tokens);
346      }
347    }
348    VP8InitResidual(0, 2, enc, &res);
349    for (ch = 0; ch <= 2; ch += 2) {
350      for (y = 0; y < 2; ++y) {
351        for (x = 0; x < 2; ++x) {
352          const int ctx = it->top_nz_[4 + ch + x] + it->left_nz_[4 + ch + y];
353          VP8SetResidualCoeffs(rd->uv_levels[ch * 2 + x + y * 2], &res);
354          it->top_nz_[4 + ch + x] = it->left_nz_[4 + ch + y] =
355              VP8RecordCoeffTokens(ctx, &res, tokens);
356        }
357      }
358    }
359    VP8IteratorBytesToNz(it);
360    return !tokens->error_;
361  }
362  #endif    
363  #if !defined(WEBP_DISABLE_STATS)
364  #if SEGMENT_VISU
365  static void SetBlock(uint8_t* p, int value, int size) {
366    int y;
367    for (y = 0; y < size; ++y) {
368      memset(p, value, size);
369      p += BPS;
370    }
371  }
372  #endif
373  static void ResetSSE(VP8Encoder* const enc) {
374    enc->sse_[0] = 0;
375    enc->sse_[1] = 0;
376    enc->sse_[2] = 0;
377    enc->sse_count_ = 0;
378  }
379  static void StoreSSE(const VP8EncIterator* const it) {
380    VP8Encoder* const enc = it->enc_;
381    const uint8_t* const in = it->yuv_in_;
382    const uint8_t* const out = it->yuv_out_;
383    enc->sse_[0] += VP8SSE16x16(in + Y_OFF_ENC, out + Y_OFF_ENC);
384    enc->sse_[1] += VP8SSE8x8(in + U_OFF_ENC, out + U_OFF_ENC);
385    enc->sse_[2] += VP8SSE8x8(in + V_OFF_ENC, out + V_OFF_ENC);
386    enc->sse_count_ += 16 * 16;
387  }
388  static void StoreSideInfo(const VP8EncIterator* const it) {
389    VP8Encoder* const enc = it->enc_;
390    const VP8MBInfo* const mb = it->mb_;
391    WebPPicture* const pic = enc->pic_;
392    if (pic->stats != NULL) {
393      StoreSSE(it);
394      enc->block_count_[0] += (mb->type_ == 0);
395      enc->block_count_[1] += (mb->type_ == 1);
396      enc->block_count_[2] += (mb->skip_ != 0);
397    }
398    if (pic->extra_info != NULL) {
399      uint8_t* const info = &pic->extra_info[it->x_ + it->y_ * enc->mb_w_];
400      switch (pic->extra_info_type) {
401        case 1: *info = mb->type_; break;
402        case 2: *info = mb->segment_; break;
403        case 3: *info = enc->dqm_[mb->segment_].quant_; break;
404        case 4: *info = (mb->type_ == 1) ? it->preds_[0] : 0xff; break;
405        case 5: *info = mb->uv_mode_; break;
406        case 6: {
407          const int b = (int)((it->luma_bits_ + it->uv_bits_ + 7) >> 3);
408          *info = (b > 255) ? 255 : b; break;
409        }
410        case 7: *info = mb->alpha_; break;
411        default: *info = 0; break;
412      }
413    }
414  #if SEGMENT_VISU  
415    SetBlock(it->yuv_out_ + Y_OFF_ENC, mb->segment_ * 64, 16);
416    SetBlock(it->yuv_out_ + U_OFF_ENC, it->preds_[0] * 64, 8);
417    SetBlock(it->yuv_out_ + V_OFF_ENC, mb->uv_mode_ * 64, 8);
418  #endif
419  }
420  static void ResetSideInfo(const VP8EncIterator* const it) {
421    VP8Encoder* const enc = it->enc_;
422    WebPPicture* const pic = enc->pic_;
423    if (pic->stats != NULL) {
424      memset(enc->block_count_, 0, sizeof(enc->block_count_));
425    }
426    ResetSSE(enc);
427  }
428  #else  
429  static void ResetSSE(VP8Encoder* const enc) {
430    (void)enc;
431  }
432  static void StoreSideInfo(const VP8EncIterator* const it) {
433    VP8Encoder* const enc = it->enc_;
434    WebPPicture* const pic = enc->pic_;
435    if (pic->extra_info != NULL) {
436      if (it->x_ == 0 && it->y_ == 0) {   
437        memset(pic->extra_info, 0,
438               enc->mb_w_ * enc->mb_h_ * sizeof(*pic->extra_info));
439      }
440    }
441  }
442  static void ResetSideInfo(const VP8EncIterator* const it) {
443    (void)it;
444  }
445  #endif  
446  static double GetPSNR(uint64_t mse, uint64_t size) {
447    return (mse > 0 && size > 0) ? 10. * log10(255. * 255. * size / mse) : 99;
448  }
449  static void SetLoopParams(VP8Encoder* const enc, float q) {
450    q = Clamp(q, 0.f, 100.f);
451    VP8SetSegmentParams(enc, q);      
452    SetSegmentProbas(enc);            
453    ResetStats(enc);
454    ResetSSE(enc);
455  }
456  static uint64_t OneStatPass(VP8Encoder* const enc, VP8RDLevel rd_opt,
457                              int nb_mbs, int percent_delta,
458                              PassStats* const s) {
459    VP8EncIterator it;
460    uint64_t size = 0;
461    uint64_t size_p0 = 0;
462    uint64_t distortion = 0;
463    const uint64_t pixel_count = nb_mbs * 384;
464    VP8IteratorInit(enc, &it);
465    SetLoopParams(enc, s->q);
466    do {
467      VP8ModeScore info;
468      VP8IteratorImport(&it, NULL);
469      if (VP8Decimate(&it, &info, rd_opt)) {
470        ++enc->proba_.nb_skip_;
471      }
472      RecordResiduals(&it, &info);
473      size += info.R + info.H;
474      size_p0 += info.H;
475      distortion += info.D;
476      if (percent_delta && !VP8IteratorProgress(&it, percent_delta)) {
477        return 0;
478      }
479      VP8IteratorSaveBoundary(&it);
480    } while (VP8IteratorNext(&it) && --nb_mbs > 0);
481    size_p0 += enc->segment_hdr_.size_;
482    if (s->do_size_search) {
483      size += FinalizeSkipProba(enc);
484      size += FinalizeTokenProbas(&enc->proba_);
485      size = ((size + size_p0 + 1024) >> 11) + HEADER_SIZE_ESTIMATE;
486      s->value = (double)size;
487    } else {
488      s->value = GetPSNR(distortion, pixel_count);
489    }
490    return size_p0;
491  }
492  static int StatLoop(VP8Encoder* const enc) {
493    const int method = enc->method_;
494    const int do_search = enc->do_search_;
495    const int fast_probe = ((method == 0 || method == 3) && !do_search);
496    int num_pass_left = enc->config_->pass;
497    const int task_percent = 20;
498    const int percent_per_pass =
499        (task_percent + num_pass_left / 2) / num_pass_left;
500    const int final_percent = enc->percent_ + task_percent;
501    const VP8RDLevel rd_opt =
502        (method >= 3 || do_search) ? RD_OPT_BASIC : RD_OPT_NONE;
503    int nb_mbs = enc->mb_w_ * enc->mb_h_;
504    PassStats stats;
505    InitPassStats(enc, &stats);
506    ResetTokenStats(enc);
507    if (fast_probe) {
508      if (method == 3) {  
509        nb_mbs = (nb_mbs > 200) ? nb_mbs >> 1 : 100;
510      } else {
511        nb_mbs = (nb_mbs > 200) ? nb_mbs >> 2 : 50;
512      }
513    }
514    while (num_pass_left-- > 0) {
515      const int is_last_pass = (fabs(stats.dq) <= DQ_LIMIT) ||
516                               (num_pass_left == 0) ||
517                               (enc->max_i4_header_bits_ == 0);
518      const uint64_t size_p0 =
519          OneStatPass(enc, rd_opt, nb_mbs, percent_per_pass, &stats);
520      if (size_p0 == 0) return 0;
521  #if (DEBUG_SEARCH > 0)
522      printf("#%d value:%.1lf -> %.1lf   q:%.2f -> %.2f\n",
523             num_pass_left, stats.last_value, stats.value, stats.last_q, stats.q);
524  #endif
525      if (enc->max_i4_header_bits_ > 0 && size_p0 > PARTITION0_SIZE_LIMIT) {
526        ++num_pass_left;
527        enc->max_i4_header_bits_ >>= 1;  
528        continue;                        
529      }
530      if (is_last_pass) {
531        break;
532      }
533      if (do_search) {
534        ComputeNextQ(&stats);
535        if (fabs(stats.dq) <= DQ_LIMIT) break;
536      }
537    }
538    if (!do_search || !stats.do_size_search) {
539      FinalizeSkipProba(enc);
540      FinalizeTokenProbas(&enc->proba_);
541    }
542    VP8CalculateLevelCosts(&enc->proba_);  
543    return WebPReportProgress(enc->pic_, final_percent, &enc->percent_);
544  }
545  static const uint8_t kAverageBytesPerMB[8] = { 50, 24, 16, 9, 7, 5, 3, 2 };
546  static int PreLoopInitialize(VP8Encoder* const enc) {
547    int p;
548    int ok = 1;
549    const int average_bytes_per_MB = kAverageBytesPerMB[enc->base_quant_ >> 4];
550    const int bytes_per_parts =
551        enc->mb_w_ * enc->mb_h_ * average_bytes_per_MB / enc->num_parts_;
552    for (p = 0; ok && p < enc->num_parts_; ++p) {
553      ok = VP8BitWriterInit(enc->parts_ + p, bytes_per_parts);
554    }
555    if (!ok) {
556      VP8EncFreeBitWriters(enc);  
557      WebPEncodingSetError(enc->pic_, VP8_ENC_ERROR_OUT_OF_MEMORY);
558    }
559    return ok;
560  }
561  static int PostLoopFinalize(VP8EncIterator* const it, int ok) {
562    VP8Encoder* const enc = it->enc_;
563    if (ok) {      
564      int p;
565      for (p = 0; p < enc->num_parts_; ++p) {
566        VP8BitWriterFinish(enc->parts_ + p);
567        ok &= !enc->parts_[p].error_;
568      }
569    }
570    if (ok) {      
571  #if !defined(WEBP_DISABLE_STATS)
572      if (enc->pic_->stats != NULL) {  
573        int i, s;
574        for (i = 0; i <= 2; ++i) {
575          for (s = 0; s < NUM_MB_SEGMENTS; ++s) {
576            enc->residual_bytes_[i][s] = (int)((it->bit_count_[s][i] + 7) >> 3);
577          }
578        }
579      }
580  #endif
581      VP8AdjustFilterStrength(it);     
582    } else {
583      VP8EncFreeBitWriters(enc);
584    }
585    return ok;
586  }
587  static void ResetAfterSkip(VP8EncIterator* const it) {
588    if (it->mb_->type_ == 1) {
589      *it->nz_ = 0;  
590      it->left_nz_[8] = 0;
591    } else {
592      *it->nz_ &= (1 << 24);  
593    }
594  }
595  int VP8EncLoop(VP8Encoder* const enc) {
596    VP8EncIterator it;
597    int ok = PreLoopInitialize(enc);
598    if (!ok) return 0;
599    StatLoop(enc);  
600    VP8IteratorInit(enc, &it);
601    VP8InitFilter(&it);
602    do {
603      VP8ModeScore info;
604      const int dont_use_skip = !enc->proba_.use_skip_proba_;
605      const VP8RDLevel rd_opt = enc->rd_opt_level_;
606      VP8IteratorImport(&it, NULL);
607      if (!VP8Decimate(&it, &info, rd_opt) || dont_use_skip) {
608        CodeResiduals(it.bw_, &it, &info);
609      } else {   
610        ResetAfterSkip(&it);
611      }
612      StoreSideInfo(&it);
613      VP8StoreFilterStats(&it);
614      VP8IteratorExport(&it);
615      ok = VP8IteratorProgress(&it, 20);
616      VP8IteratorSaveBoundary(&it);
617    } while (ok && VP8IteratorNext(&it));
618    return PostLoopFinalize(&it, ok);
619  }
620  #if !defined(DISABLE_TOKEN_BUFFER)
621  #define MIN_COUNT 96  
622  int VP8EncTokenLoop(VP8Encoder* const enc) {
623    int max_count = (enc->mb_w_ * enc->mb_h_) >> 3;
624    int num_pass_left = enc->config_->pass;
<span onclick='openModal()' class='match'>625    const int do_search = enc->do_search_;
626    VP8EncIterator it;
627    VP8EncProba* const proba = &enc->proba_;
628    const VP8RDLevel rd_opt = enc->rd_opt_level_;
629    const uint64_t pixel_count = enc->mb_w_ * enc->mb_h_ * 384;
</span>630    PassStats stats;
631    int ok;
632    InitPassStats(enc, &stats);
633    ok = PreLoopInitialize(enc);
634    if (!ok) return 0;
635    if (max_count < MIN_COUNT) max_count = MIN_COUNT;
636    assert(enc->num_parts_ == 1);
637    assert(enc->use_tokens_);
638    assert(proba->use_skip_proba_ == 0);
639    assert(rd_opt >= RD_OPT_BASIC);   
640    assert(num_pass_left > 0);
641    while (ok && num_pass_left-- > 0) {
642      const int is_last_pass = (fabs(stats.dq) <= DQ_LIMIT) ||
643                               (num_pass_left == 0) ||
644                               (enc->max_i4_header_bits_ == 0);
645      uint64_t size_p0 = 0;
646      uint64_t distortion = 0;
647      int cnt = max_count;
648      VP8IteratorInit(enc, &it);
649      SetLoopParams(enc, stats.q);
650      if (is_last_pass) {
651        ResetTokenStats(enc);
652        VP8InitFilter(&it);  
653      }
654      VP8TBufferClear(&enc->tokens_);
655      do {
656        VP8ModeScore info;
657        VP8IteratorImport(&it, NULL);
658        if (--cnt < 0) {
659          FinalizeTokenProbas(proba);
660          VP8CalculateLevelCosts(proba);  
661          cnt = max_count;
662        }
663        VP8Decimate(&it, &info, rd_opt);
664        ok = RecordTokens(&it, &info, &enc->tokens_);
665        if (!ok) {
666          WebPEncodingSetError(enc->pic_, VP8_ENC_ERROR_OUT_OF_MEMORY);
667          break;
668        }
669        size_p0 += info.H;
670        distortion += info.D;
671        if (is_last_pass) {
672          StoreSideInfo(&it);
673          VP8StoreFilterStats(&it);
674          VP8IteratorExport(&it);
675          ok = VP8IteratorProgress(&it, 20);
676        }
677        VP8IteratorSaveBoundary(&it);
678      } while (ok && VP8IteratorNext(&it));
679      if (!ok) break;
680      size_p0 += enc->segment_hdr_.size_;
681      if (stats.do_size_search) {
682        uint64_t size = FinalizeTokenProbas(&enc->proba_);
683        size += VP8EstimateTokenSize(&enc->tokens_,
684                                     (const uint8_t*)proba->coeffs_);
685        size = (size + size_p0 + 1024) >> 11;  
686        size += HEADER_SIZE_ESTIMATE;
687        stats.value = (double)size;
688      } else {  
689        stats.value = GetPSNR(distortion, pixel_count);
690      }
691  #if (DEBUG_SEARCH > 0)
692      printf("#%2d metric:%.1lf -> %.1lf   last_q=%.2lf q=%.2lf dq=%.2lf\n",
693             num_pass_left, stats.last_value, stats.value,
694             stats.last_q, stats.q, stats.dq);
695  #endif
696      if (enc->max_i4_header_bits_ > 0 && size_p0 > PARTITION0_SIZE_LIMIT) {
697        ++num_pass_left;
698        enc->max_i4_header_bits_ >>= 1;  
699        if (is_last_pass) {
700          ResetSideInfo(&it);
701        }
702        continue;                        
703      }
704      if (is_last_pass) {
705        break;   
706      }
707      if (do_search) {
708        ComputeNextQ(&stats);  
709      }
710    }
711    if (ok) {
712      if (!stats.do_size_search) {
713        FinalizeTokenProbas(&enc->proba_);
714      }
715      ok = VP8EmitTokens(&enc->tokens_, enc->parts_ + 0,
716                         (const uint8_t*)proba->coeffs_, 1);
717    }
718    ok = ok && WebPReportProgress(enc->pic_, enc->percent_ + 20, &enc->percent_);
719    return PostLoopFinalize(&it, ok);
720  }
721  #else
722  int VP8EncTokenLoop(VP8Encoder* const enc) {
723    (void)enc;
724    return 0;   
725  }
726  #endif    
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from xmrig-MDEwOlJlcG9zaXRvcnk4ODMyNzQwNg==-flat-itoa.h</div>
                <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from PINRemoteImage-MDEwOlJlcG9zaXRvcnkzOTUzNzEwMw==-flat-frame_enc.c</div>
                <div class="column column_space"><pre><code>92      const char* cDigitsLut = GetDigitsLut();
93      const uint64_t  kTen8 = 100000000;
94      const uint64_t  kTen9 = kTen8 * 10;
95      const uint64_t kTen10 = kTen8 * 100;
</pre></code></div>
                <div class="column column_space"><pre><code>625    const int do_search = enc->do_search_;
626    VP8EncIterator it;
627    VP8EncProba* const proba = &enc->proba_;
628    const VP8RDLevel rd_opt = enc->rd_opt_level_;
629    const uint64_t pixel_count = enc->mb_w_ * enc->mb_h_ * 384;
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    