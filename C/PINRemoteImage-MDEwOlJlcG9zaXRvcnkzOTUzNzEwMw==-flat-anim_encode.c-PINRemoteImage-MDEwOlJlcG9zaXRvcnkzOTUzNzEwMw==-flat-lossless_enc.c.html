
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 11.332755131540907%, Tokens: 9</h2>
        <div class="column">
            <h3>PINRemoteImage-MDEwOlJlcG9zaXRvcnkzOTUzNzEwMw==-flat-anim_encode.c</h3>
            <pre><code>1  #include <assert.h>
2  #include <limits.h>
3  #include <math.h>    
4  #include <stdio.h>
5  #include <stdlib.h>  
6  #include "src/mux/animi.h"
7  #include "src/utils/utils.h"
8  #include "src/webp/decode.h"
9  #include "src/webp/encode.h"
10  #include "src/webp/format_constants.h"
11  #include "src/webp/mux.h"
12  #if defined(_MSC_VER) && _MSC_VER < 1900
13  #define snprintf _snprintf
14  #endif
15  #define ERROR_STR_MAX_LENGTH 100
16  typedef struct {
17    int x_offset_, y_offset_, width_, height_;
18  } FrameRectangle;
19  typedef struct {
20    WebPMuxFrameInfo sub_frame_;  
21    WebPMuxFrameInfo key_frame_;  
22    int is_key_frame_;            
23  } EncodedFrame;
24  struct WebPAnimEncoder {
25    const int canvas_width_;                  
26    const int canvas_height_;                 
27    const WebPAnimEncoderOptions options_;    
28    FrameRectangle prev_rect_;          
29    WebPConfig last_config_;            
30    WebPConfig last_config_reversed_;   
31    WebPPicture* curr_canvas_;          
32    WebPPicture curr_canvas_copy_;      
33    int curr_canvas_copy_modified_;     
34    WebPPicture prev_canvas_;           
35    WebPPicture prev_canvas_disposed_;  
36    EncodedFrame* encoded_frames_;      
37    size_t size_;             
38    size_t start_;            
39    size_t count_;            
40    size_t flush_count_;      
41    int64_t best_delta_;      
42    int keyframe_;            
43    int count_since_key_frame_;     
44    int first_timestamp_;           
45    int prev_timestamp_;            
46    int prev_candidate_undecided_;  
47    int is_first_frame_;  
48    int got_null_frame_;  
49    size_t in_frame_count_;   
50    size_t out_frame_count_;  
51    WebPMux* mux_;        
52    char error_str_[ERROR_STR_MAX_LENGTH];  
53  };
54  #define DELTA_INFINITY      (1ULL << 32)
55  #define KEYFRAME_NONE       (-1)
56  static void ResetCounters(WebPAnimEncoder* const enc) {
57    enc->start_ = 0;
58    enc->count_ = 0;
59    enc->flush_count_ = 0;
60    enc->best_delta_ = DELTA_INFINITY;
61    enc->keyframe_ = KEYFRAME_NONE;
62  }
63  static void DisableKeyframes(WebPAnimEncoderOptions* const enc_options) {
64    enc_options->kmax = INT_MAX;
65    enc_options->kmin = enc_options->kmax - 1;
66  }
67  #define MAX_CACHED_FRAMES 30
68  static void SanitizeEncoderOptions(WebPAnimEncoderOptions* const enc_options) {
69    int print_warning = enc_options->verbose;
70    if (enc_options->minimize_size) {
71      DisableKeyframes(enc_options);
72    }
73    if (enc_options->kmax == 1) {  
74      enc_options->kmin = 0;
75      enc_options->kmax = 0;
76      return;
77    } else if (enc_options->kmax <= 0) {
78      DisableKeyframes(enc_options);
79      print_warning = 0;
80    }
81    if (enc_options->kmin >= enc_options->kmax) {
82      enc_options->kmin = enc_options->kmax - 1;
83      if (print_warning) {
84        fprintf(stderr, "WARNING: Setting kmin = %d, so that kmin < kmax.\n",
85                enc_options->kmin);
86      }
87    } else {
88      const int kmin_limit = enc_options->kmax / 2 + 1;
89      if (enc_options->kmin < kmin_limit && kmin_limit < enc_options->kmax) {
90        enc_options->kmin = kmin_limit;
91        if (print_warning) {
92          fprintf(stderr,
93                  "WARNING: Setting kmin = %d, so that kmin >= kmax / 2 + 1.\n",
94                  enc_options->kmin);
95        }
96      }
97    }
98    if (enc_options->kmax - enc_options->kmin > MAX_CACHED_FRAMES) {
99      enc_options->kmin = enc_options->kmax - MAX_CACHED_FRAMES;
100      if (print_warning) {
101        fprintf(stderr,
102                "WARNING: Setting kmin = %d, so that kmax - kmin <= %d.\n",
103                enc_options->kmin, MAX_CACHED_FRAMES);
104      }
105    }
106    assert(enc_options->kmin < enc_options->kmax);
107  }
108  #undef MAX_CACHED_FRAMES
109  static void DefaultEncoderOptions(WebPAnimEncoderOptions* const enc_options) {
110    enc_options->anim_params.loop_count = 0;
111    enc_options->anim_params.bgcolor = 0xffffffff;  
112    enc_options->minimize_size = 0;
113    DisableKeyframes(enc_options);
114    enc_options->allow_mixed = 0;
115    enc_options->verbose = 0;
116  }
117  int WebPAnimEncoderOptionsInitInternal(WebPAnimEncoderOptions* enc_options,
118                                         int abi_version) {
119    if (enc_options == NULL ||
120        WEBP_ABI_IS_INCOMPATIBLE(abi_version, WEBP_MUX_ABI_VERSION)) {
121      return 0;
122    }
123    DefaultEncoderOptions(enc_options);
124    return 1;
125  }
126  #define TRANSPARENT_COLOR   0x00000000
127  static void ClearRectangle(WebPPicture* const picture,
128                             int left, int top, int width, int height) {
129    int j;
130    for (j = top; j < top + height; ++j) {
131      uint32_t* const dst = picture->argb + j * picture->argb_stride;
132      int i;
133      for (i = left; i < left + width; ++i) {
134        dst[i] = TRANSPARENT_COLOR;
135      }
136    }
137  }
138  static void WebPUtilClearPic(WebPPicture* const picture,
139                               const FrameRectangle* const rect) {
140    if (rect != NULL) {
141      ClearRectangle(picture, rect->x_offset_, rect->y_offset_,
142                     rect->width_, rect->height_);
143    } else {
144      ClearRectangle(picture, 0, 0, picture->width, picture->height);
145    }
146  }
147  static void MarkNoError(WebPAnimEncoder* const enc) {
148    enc->error_str_[0] = '\0';  
149  }
150  static void MarkError(WebPAnimEncoder* const enc, const char* str) {
151    if (snprintf(enc->error_str_, ERROR_STR_MAX_LENGTH, "%s.", str) < 0) {
152      assert(0);  
153    }
154  }
155  static void MarkError2(WebPAnimEncoder* const enc,
156                         const char* str, int error_code) {
157    if (snprintf(enc->error_str_, ERROR_STR_MAX_LENGTH, "%s: %d.", str,
158                 error_code) < 0) {
159      assert(0);  
160    }
161  }
162  WebPAnimEncoder* WebPAnimEncoderNewInternal(
163      int width, int height, const WebPAnimEncoderOptions* enc_options,
164      int abi_version) {
165    WebPAnimEncoder* enc;
166    if (WEBP_ABI_IS_INCOMPATIBLE(abi_version, WEBP_MUX_ABI_VERSION)) {
167      return NULL;
168    }
169    if (width <= 0 || height <= 0 ||
170        (width * (uint64_t)height) >= MAX_IMAGE_AREA) {
171      return NULL;
172    }
173    enc = (WebPAnimEncoder*)WebPSafeCalloc(1, sizeof(*enc));
174    if (enc == NULL) return NULL;
175    enc->encoded_frames_ = NULL;
176    enc->mux_ = NULL;
177    MarkNoError(enc);
178    *(int*)&enc->canvas_width_ = width;
179    *(int*)&enc->canvas_height_ = height;
180    if (enc_options != NULL) {
181      *(WebPAnimEncoderOptions*)&enc->options_ = *enc_options;
182      SanitizeEncoderOptions((WebPAnimEncoderOptions*)&enc->options_);
183    } else {
184      DefaultEncoderOptions((WebPAnimEncoderOptions*)&enc->options_);
185    }
186    if (!WebPPictureInit(&enc->curr_canvas_copy_) ||
187        !WebPPictureInit(&enc->prev_canvas_) ||
188        !WebPPictureInit(&enc->prev_canvas_disposed_)) {
189      goto Err;
190    }
191    enc->curr_canvas_copy_.width = width;
192    enc->curr_canvas_copy_.height = height;
193    enc->curr_canvas_copy_.use_argb = 1;
194    if (!WebPPictureAlloc(&enc->curr_canvas_copy_) ||
195        !WebPPictureCopy(&enc->curr_canvas_copy_, &enc->prev_canvas_) ||
196        !WebPPictureCopy(&enc->curr_canvas_copy_, &enc->prev_canvas_disposed_)) {
197      goto Err;
198    }
199    WebPUtilClearPic(&enc->prev_canvas_, NULL);
200    enc->curr_canvas_copy_modified_ = 1;
201    ResetCounters(enc);
202    enc->size_ = enc->options_.kmax - enc->options_.kmin + 1;
203    if (enc->size_ < 2) enc->size_ = 2;
204    enc->encoded_frames_ =
205        (EncodedFrame*)WebPSafeCalloc(enc->size_, sizeof(*enc->encoded_frames_));
206    if (enc->encoded_frames_ == NULL) goto Err;
207    enc->mux_ = WebPMuxNew();
208    if (enc->mux_ == NULL) goto Err;
209    enc->count_since_key_frame_ = 0;
210    enc->first_timestamp_ = 0;
211    enc->prev_timestamp_ = 0;
212    enc->prev_candidate_undecided_ = 0;
213    enc->is_first_frame_ = 1;
214    enc->got_null_frame_ = 0;
215    return enc;  
216   Err:
217    WebPAnimEncoderDelete(enc);
218    return NULL;
219  }
220  static void FrameRelease(EncodedFrame* const encoded_frame) {
221    if (encoded_frame != NULL) {
222      WebPDataClear(&encoded_frame->sub_frame_.bitstream);
223      WebPDataClear(&encoded_frame->key_frame_.bitstream);
224      memset(encoded_frame, 0, sizeof(*encoded_frame));
225    }
226  }
227  void WebPAnimEncoderDelete(WebPAnimEncoder* enc) {
228    if (enc != NULL) {
229      WebPPictureFree(&enc->curr_canvas_copy_);
230      WebPPictureFree(&enc->prev_canvas_);
231      WebPPictureFree(&enc->prev_canvas_disposed_);
232      if (enc->encoded_frames_ != NULL) {
233        size_t i;
234        for (i = 0; i < enc->size_; ++i) {
235          FrameRelease(&enc->encoded_frames_[i]);
236        }
237        WebPSafeFree(enc->encoded_frames_);
238      }
239      WebPMuxDelete(enc->mux_);
240      WebPSafeFree(enc);
241    }
242  }
243  static EncodedFrame* GetFrame(const WebPAnimEncoder* const enc,
244                                size_t position) {
245    assert(enc->start_ + position < enc->size_);
246    return &enc->encoded_frames_[enc->start_ + position];
247  }
248  typedef int (*ComparePixelsFunc)(const uint32_t*, int, const uint32_t*, int,
249                                   int, int);
250  static WEBP_INLINE int ComparePixelsLossless(const uint32_t* src, int src_step,
251                                               const uint32_t* dst, int dst_step,
252                                               int length, int max_allowed_diff) {
253    (void)max_allowed_diff;
254    assert(length > 0);
255    while (length-- > 0) {
256      if (*src != *dst) {
257        return 0;
258      }
259      src += src_step;
260      dst += dst_step;
261    }
262    return 1;
263  }
264  static WEBP_INLINE int PixelsAreSimilar(uint32_t src, uint32_t dst,
265                                          int max_allowed_diff) {
266    const int src_a = (src >> 24) & 0xff;
267    const int src_r = (src >> 16) & 0xff;
268    const int src_g = (src >> 8) & 0xff;
269    const int src_b = (src >> 0) & 0xff;
270    const int dst_a = (dst >> 24) & 0xff;
271    const int dst_r = (dst >> 16) & 0xff;
272    const int dst_g = (dst >> 8) & 0xff;
273    const int dst_b = (dst >> 0) & 0xff;
274    return (src_a == dst_a) &&
275           (abs(src_r - dst_r) * dst_a <= (max_allowed_diff * 255)) &&
276           (abs(src_g - dst_g) * dst_a <= (max_allowed_diff * 255)) &&
277           (abs(src_b - dst_b) * dst_a <= (max_allowed_diff * 255));
278  }
279  static WEBP_INLINE int ComparePixelsLossy(const uint32_t* src, int src_step,
280                                            const uint32_t* dst, int dst_step,
281                                            int length, int max_allowed_diff) {
282    assert(length > 0);
283    while (length-- > 0) {
284      if (!PixelsAreSimilar(*src, *dst, max_allowed_diff)) {
285        return 0;
286      }
287      src += src_step;
288      dst += dst_step;
289    }
290    return 1;
291  }
292  static int IsEmptyRect(const FrameRectangle* const rect) {
293    return (rect->width_ == 0) || (rect->height_ == 0);
294  }
295  static int QualityToMaxDiff(float quality) {
296    const double val = pow(quality / 100., 0.5);
297    const double max_diff = 31 * (1 - val) + 1 * val;
298    return (int)(max_diff + 0.5);
299  }
300  static void MinimizeChangeRectangle(const WebPPicture* const src,
301                                      const WebPPicture* const dst,
302                                      FrameRectangle* const rect,
303                                      int is_lossless, float quality) {
304    int i, j;
305    const ComparePixelsFunc compare_pixels =
306        is_lossless ? ComparePixelsLossless : ComparePixelsLossy;
307    const int max_allowed_diff_lossy = QualityToMaxDiff(quality);
308    const int max_allowed_diff = is_lossless ? 0 : max_allowed_diff_lossy;
309    assert(src->width == dst->width && src->height == dst->height);
310    assert(rect->x_offset_ + rect->width_ <= dst->width);
311    assert(rect->y_offset_ + rect->height_ <= dst->height);
312    for (i = rect->x_offset_; i < rect->x_offset_ + rect->width_; ++i) {
313      const uint32_t* const src_argb =
314          &src->argb[rect->y_offset_ * src->argb_stride + i];
315      const uint32_t* const dst_argb =
316          &dst->argb[rect->y_offset_ * dst->argb_stride + i];
317      if (compare_pixels(src_argb, src->argb_stride, dst_argb, dst->argb_stride,
318                         rect->height_, max_allowed_diff)) {
319        --rect->width_;  
320        ++rect->x_offset_;
321      } else {
322        break;
323      }
324    }
325    if (rect->width_ == 0) goto NoChange;
326    for (i = rect->x_offset_ + rect->width_ - 1; i >= rect->x_offset_; --i) {
327      const uint32_t* const src_argb =
328          &src->argb[rect->y_offset_ * src->argb_stride + i];
329      const uint32_t* const dst_argb =
330          &dst->argb[rect->y_offset_ * dst->argb_stride + i];
331      if (compare_pixels(src_argb, src->argb_stride, dst_argb, dst->argb_stride,
332                         rect->height_, max_allowed_diff)) {
333        --rect->width_;  
334      } else {
335        break;
336      }
337    }
338    if (rect->width_ == 0) goto NoChange;
339    for (j = rect->y_offset_; j < rect->y_offset_ + rect->height_; ++j) {
340      const uint32_t* const src_argb =
341          &src->argb[j * src->argb_stride + rect->x_offset_];
342      const uint32_t* const dst_argb =
343          &dst->argb[j * dst->argb_stride + rect->x_offset_];
344      if (compare_pixels(src_argb, 1, dst_argb, 1, rect->width_,
345                         max_allowed_diff)) {
346        --rect->height_;  
347        ++rect->y_offset_;
348      } else {
349        break;
350      }
351    }
352    if (rect->height_ == 0) goto NoChange;
353    for (j = rect->y_offset_ + rect->height_ - 1; j >= rect->y_offset_; --j) {
354      const uint32_t* const src_argb =
355          &src->argb[j * src->argb_stride + rect->x_offset_];
356      const uint32_t* const dst_argb =
357          &dst->argb[j * dst->argb_stride + rect->x_offset_];
358      if (compare_pixels(src_argb, 1, dst_argb, 1, rect->width_,
359                         max_allowed_diff)) {
360        --rect->height_;  
361      } else {
362        break;
363      }
364    }
365    if (rect->height_ == 0) goto NoChange;
366    if (IsEmptyRect(rect)) {
367   NoChange:
368      rect->x_offset_ = 0;
369      rect->y_offset_ = 0;
370      rect->width_ = 0;
371      rect->height_ = 0;
372    }
373  }
374  static WEBP_INLINE void SnapToEvenOffsets(FrameRectangle* const rect) {
375    rect->width_ += (rect->x_offset_ & 1);
376    rect->height_ += (rect->y_offset_ & 1);
377    rect->x_offset_ &= ~1;
378    rect->y_offset_ &= ~1;
379  }
380  typedef struct {
381    int should_try_;               
382    int empty_rect_allowed_;       
383    FrameRectangle rect_ll_;       
384    WebPPicture sub_frame_ll_;     
385    FrameRectangle rect_lossy_;    
386    WebPPicture sub_frame_lossy_;  
387  } SubFrameParams;
388  static int SubFrameParamsInit(SubFrameParams* const params,
389                                int should_try, int empty_rect_allowed) {
390    params->should_try_ = should_try;
391    params->empty_rect_allowed_ = empty_rect_allowed;
392    if (!WebPPictureInit(&params->sub_frame_ll_) ||
393        !WebPPictureInit(&params->sub_frame_lossy_)) {
394      return 0;
395    }
396    return 1;
397  }
398  static void SubFrameParamsFree(SubFrameParams* const params) {
399    WebPPictureFree(&params->sub_frame_ll_);
400    WebPPictureFree(&params->sub_frame_lossy_);
401  }
402  static int GetSubRect(const WebPPicture* const prev_canvas,
403                        const WebPPicture* const curr_canvas, int is_key_frame,
404                        int is_first_frame, int empty_rect_allowed,
405                        int is_lossless, float quality,
406                        FrameRectangle* const rect,
407                        WebPPicture* const sub_frame) {
408    if (!is_key_frame || is_first_frame) {  
409      MinimizeChangeRectangle(prev_canvas, curr_canvas, rect,
410                              is_lossless, quality);
411    }
412    if (IsEmptyRect(rect)) {
413      if (empty_rect_allowed) {  
414        return 1;
415      } else {                   
416        rect->width_ = 1;
417        rect->height_ = 1;
418        assert(rect->x_offset_ == 0);
419        assert(rect->y_offset_ == 0);
420      }
421    }
422    SnapToEvenOffsets(rect);
423    return WebPPictureView(curr_canvas, rect->x_offset_, rect->y_offset_,
424                           rect->width_, rect->height_, sub_frame);
425  }
426  static int GetSubRects(const WebPPicture* const prev_canvas,
427                         const WebPPicture* const curr_canvas, int is_key_frame,
428                         int is_first_frame, float quality,
429                         SubFrameParams* const params) {
430    params->rect_ll_.x_offset_ = 0;
431    params->rect_ll_.y_offset_ = 0;
432    params->rect_ll_.width_ = curr_canvas->width;
433    params->rect_ll_.height_ = curr_canvas->height;
434    if (!GetSubRect(prev_canvas, curr_canvas, is_key_frame, is_first_frame,
435                    params->empty_rect_allowed_, 1, quality,
436                    &params->rect_ll_, &params->sub_frame_ll_)) {
437      return 0;
438    }
439    params->rect_lossy_ = params->rect_ll_;  
<span onclick='openModal()' class='match'>440    return GetSubRect(prev_canvas, curr_canvas, is_key_frame, is_first_frame,
441                      params->empty_rect_allowed_, 0, quality,
442                      &params->rect_lossy_, &params->sub_frame_lossy_);
443  }
444  static WEBP_INLINE int clip(int v, int min_v, int max_v) {
445    return (v < min_v) ? min_v : (v > max_v) ? max_v : v;
</span>446  }
447  int WebPAnimEncoderRefineRect(
448      const WebPPicture* const prev_canvas, const WebPPicture* const curr_canvas,
449      int is_lossless, float quality, int* const x_offset, int* const y_offset,
450      int* const width, int* const height) {
451    FrameRectangle rect;
452    const int right = clip(*x_offset + *width, 0, curr_canvas->width);
453    const int left = clip(*x_offset, 0, curr_canvas->width - 1);
454    const int bottom = clip(*y_offset + *height, 0, curr_canvas->height);
455    const int top = clip(*y_offset, 0, curr_canvas->height - 1);
456    if (prev_canvas == NULL || curr_canvas == NULL ||
457        prev_canvas->width != curr_canvas->width ||
458        prev_canvas->height != curr_canvas->height ||
459        !prev_canvas->use_argb || !curr_canvas->use_argb) {
460      return 0;
461    }
462    rect.x_offset_ = left;
463    rect.y_offset_ = top;
464    rect.width_ = clip(right - left, 0, curr_canvas->width - rect.x_offset_);
465    rect.height_ = clip(bottom - top, 0, curr_canvas->height - rect.y_offset_);
466    MinimizeChangeRectangle(prev_canvas, curr_canvas, &rect, is_lossless,
467                            quality);
468    SnapToEvenOffsets(&rect);
469    *x_offset = rect.x_offset_;
470    *y_offset = rect.y_offset_;
471    *width = rect.width_;
472    *height = rect.height_;
473    return 1;
474  }
475  static void DisposeFrameRectangle(int dispose_method,
476                                    const FrameRectangle* const rect,
477                                    WebPPicture* const curr_canvas) {
478    assert(rect != NULL);
479    if (dispose_method == WEBP_MUX_DISPOSE_BACKGROUND) {
480      WebPUtilClearPic(curr_canvas, rect);
481    }
482  }
483  static uint32_t RectArea(const FrameRectangle* const rect) {
484    return (uint32_t)rect->width_ * rect->height_;
485  }
486  static int IsLosslessBlendingPossible(const WebPPicture* const src,
487                                        const WebPPicture* const dst,
488                                        const FrameRectangle* const rect) {
489    int i, j;
490    assert(src->width == dst->width && src->height == dst->height);
491    assert(rect->x_offset_ + rect->width_ <= dst->width);
492    assert(rect->y_offset_ + rect->height_ <= dst->height);
493    for (j = rect->y_offset_; j < rect->y_offset_ + rect->height_; ++j) {
494      for (i = rect->x_offset_; i < rect->x_offset_ + rect->width_; ++i) {
495        const uint32_t src_pixel = src->argb[j * src->argb_stride + i];
496        const uint32_t dst_pixel = dst->argb[j * dst->argb_stride + i];
497        const uint32_t dst_alpha = dst_pixel >> 24;
498        if (dst_alpha != 0xff && src_pixel != dst_pixel) {
499          return 0;
500        }
501      }
502    }
503    return 1;
504  }
505  static int IsLossyBlendingPossible(const WebPPicture* const src,
506                                     const WebPPicture* const dst,
507                                     const FrameRectangle* const rect,
508                                     float quality) {
509    const int max_allowed_diff_lossy = QualityToMaxDiff(quality);
510    int i, j;
511    assert(src->width == dst->width && src->height == dst->height);
512    assert(rect->x_offset_ + rect->width_ <= dst->width);
513    assert(rect->y_offset_ + rect->height_ <= dst->height);
514    for (j = rect->y_offset_; j < rect->y_offset_ + rect->height_; ++j) {
515      for (i = rect->x_offset_; i < rect->x_offset_ + rect->width_; ++i) {
516        const uint32_t src_pixel = src->argb[j * src->argb_stride + i];
517        const uint32_t dst_pixel = dst->argb[j * dst->argb_stride + i];
518        const uint32_t dst_alpha = dst_pixel >> 24;
519        if (dst_alpha != 0xff &&
520            !PixelsAreSimilar(src_pixel, dst_pixel, max_allowed_diff_lossy)) {
521          return 0;
522        }
523      }
524    }
525    return 1;
526  }
527  static int IncreaseTransparency(const WebPPicture* const src,
528                                  const FrameRectangle* const rect,
529                                  WebPPicture* const dst) {
530    int i, j;
531    int modified = 0;
532    assert(src != NULL && dst != NULL && rect != NULL);
533    assert(src->width == dst->width && src->height == dst->height);
534    for (j = rect->y_offset_; j < rect->y_offset_ + rect->height_; ++j) {
535      const uint32_t* const psrc = src->argb + j * src->argb_stride;
536      uint32_t* const pdst = dst->argb + j * dst->argb_stride;
537      for (i = rect->x_offset_; i < rect->x_offset_ + rect->width_; ++i) {
538        if (psrc[i] == pdst[i] && pdst[i] != TRANSPARENT_COLOR) {
539          pdst[i] = TRANSPARENT_COLOR;
540          modified = 1;
541        }
542      }
543    }
544    return modified;
545  }
546  #undef TRANSPARENT_COLOR
547  static int FlattenSimilarBlocks(const WebPPicture* const src,
548                                  const FrameRectangle* const rect,
549                                  WebPPicture* const dst, float quality) {
550    const int max_allowed_diff_lossy = QualityToMaxDiff(quality);
551    int i, j;
552    int modified = 0;
553    const int block_size = 8;
554    const int y_start = (rect->y_offset_ + block_size) & ~(block_size - 1);
555    const int y_end = (rect->y_offset_ + rect->height_) & ~(block_size - 1);
556    const int x_start = (rect->x_offset_ + block_size) & ~(block_size - 1);
557    const int x_end = (rect->x_offset_ + rect->width_) & ~(block_size - 1);
558    assert(src != NULL && dst != NULL && rect != NULL);
559    assert(src->width == dst->width && src->height == dst->height);
560    assert((block_size & (block_size - 1)) == 0);  
561    for (j = y_start; j < y_end; j += block_size) {
562      for (i = x_start; i < x_end; i += block_size) {
563        int cnt = 0;
564        int avg_r = 0, avg_g = 0, avg_b = 0;
565        int x, y;
566        const uint32_t* const psrc = src->argb + j * src->argb_stride + i;
567        uint32_t* const pdst = dst->argb + j * dst->argb_stride + i;
568        for (y = 0; y < block_size; ++y) {
569          for (x = 0; x < block_size; ++x) {
570            const uint32_t src_pixel = psrc[x + y * src->argb_stride];
571            const int alpha = src_pixel >> 24;
572            if (alpha == 0xff &&
573                PixelsAreSimilar(src_pixel, pdst[x + y * dst->argb_stride],
574                                 max_allowed_diff_lossy)) {
575              ++cnt;
576              avg_r += (src_pixel >> 16) & 0xff;
577              avg_g += (src_pixel >> 8) & 0xff;
578              avg_b += (src_pixel >> 0) & 0xff;
579            }
580          }
581        }
582        if (cnt == block_size * block_size) {
583          const uint32_t color = (0x00          << 24) |
584                                 ((avg_r / cnt) << 16) |
585                                 ((avg_g / cnt) <<  8) |
586                                 ((avg_b / cnt) <<  0);
587          for (y = 0; y < block_size; ++y) {
588            for (x = 0; x < block_size; ++x) {
589              pdst[x + y * dst->argb_stride] = color;
590            }
591          }
592          modified = 1;
593        }
594      }
595    }
596    return modified;
597  }
598  static int EncodeFrame(const WebPConfig* const config, WebPPicture* const pic,
599                         WebPMemoryWriter* const memory) {
600    pic->use_argb = 1;
601    pic->writer = WebPMemoryWrite;
602    pic->custom_ptr = memory;
603    if (!WebPEncode(config, pic)) {
604      return 0;
605    }
606    return 1;
607  }
608  typedef struct {
609    WebPMemoryWriter  mem_;
610    WebPMuxFrameInfo  info_;
611    FrameRectangle    rect_;
612    int               evaluate_;  
613  } Candidate;
614  static WebPEncodingError EncodeCandidate(WebPPicture* const sub_frame,
615                                           const FrameRectangle* const rect,
616                                           const WebPConfig* const encoder_config,
617                                           int use_blending,
618                                           Candidate* const candidate) {
619    WebPConfig config = *encoder_config;
620    WebPEncodingError error_code = VP8_ENC_OK;
621    assert(candidate != NULL);
622    memset(candidate, 0, sizeof(*candidate));
623    candidate->rect_ = *rect;
624    candidate->info_.id = WEBP_CHUNK_ANMF;
625    candidate->info_.x_offset = rect->x_offset_;
626    candidate->info_.y_offset = rect->y_offset_;
627    candidate->info_.dispose_method = WEBP_MUX_DISPOSE_NONE;  
628    candidate->info_.blend_method =
629        use_blending ? WEBP_MUX_BLEND : WEBP_MUX_NO_BLEND;
630    candidate->info_.duration = 0;  
631    WebPMemoryWriterInit(&candidate->mem_);
632    if (!config.lossless && use_blending) {
633      config.autofilter = 0;
634      config.filter_strength = 0;
635    }
636    if (!EncodeFrame(&config, sub_frame, &candidate->mem_)) {
637      error_code = sub_frame->error_code;
638      goto Err;
639    }
640    candidate->evaluate_ = 1;
641    return error_code;
642   Err:
643    WebPMemoryWriterClear(&candidate->mem_);
644    return error_code;
645  }
646  static void CopyCurrentCanvas(WebPAnimEncoder* const enc) {
647    if (enc->curr_canvas_copy_modified_) {
648      WebPCopyPixels(enc->curr_canvas_, &enc->curr_canvas_copy_);
649      enc->curr_canvas_copy_.progress_hook = enc->curr_canvas_->progress_hook;
650      enc->curr_canvas_copy_.user_data = enc->curr_canvas_->user_data;
651      enc->curr_canvas_copy_modified_ = 0;
652    }
653  }
654  enum {
655    LL_DISP_NONE = 0,
656    LL_DISP_BG,
657    LOSSY_DISP_NONE,
658    LOSSY_DISP_BG,
659    CANDIDATE_COUNT
660  };
661  #define MIN_COLORS_LOSSY     31  
662  #define MAX_COLORS_LOSSLESS 194  
663  static WebPEncodingError GenerateCandidates(
664      WebPAnimEncoder* const enc, Candidate candidates[CANDIDATE_COUNT],
665      WebPMuxAnimDispose dispose_method, int is_lossless, int is_key_frame,
666      SubFrameParams* const params,
667      const WebPConfig* const config_ll, const WebPConfig* const config_lossy) {
668    WebPEncodingError error_code = VP8_ENC_OK;
669    const int is_dispose_none = (dispose_method == WEBP_MUX_DISPOSE_NONE);
670    Candidate* const candidate_ll =
671        is_dispose_none ? &candidates[LL_DISP_NONE] : &candidates[LL_DISP_BG];
672    Candidate* const candidate_lossy = is_dispose_none
673                                       ? &candidates[LOSSY_DISP_NONE]
674                                       : &candidates[LOSSY_DISP_BG];
675    WebPPicture* const curr_canvas = &enc->curr_canvas_copy_;
676    const WebPPicture* const prev_canvas =
677        is_dispose_none ? &enc->prev_canvas_ : &enc->prev_canvas_disposed_;
678    int use_blending_ll, use_blending_lossy;
679    int evaluate_ll, evaluate_lossy;
680    CopyCurrentCanvas(enc);
681    use_blending_ll =
682        !is_key_frame &&
683        IsLosslessBlendingPossible(prev_canvas, curr_canvas, &params->rect_ll_);
684    use_blending_lossy =
685        !is_key_frame &&
686        IsLossyBlendingPossible(prev_canvas, curr_canvas, &params->rect_lossy_,
687                                config_lossy->quality);
688    if (!enc->options_.allow_mixed) {
689      evaluate_ll = is_lossless;
690      evaluate_lossy = !is_lossless;
691    } else if (enc->options_.minimize_size) {
692      evaluate_ll = 1;
693      evaluate_lossy = 1;
694    } else {  
695      const int num_colors = WebPGetColorPalette(&params->sub_frame_ll_, NULL);
696      evaluate_ll = (num_colors < MAX_COLORS_LOSSLESS);
697      evaluate_lossy = (num_colors >= MIN_COLORS_LOSSY);
698    }
699    if (evaluate_ll) {
700      CopyCurrentCanvas(enc);
701      if (use_blending_ll) {
702        enc->curr_canvas_copy_modified_ =
703            IncreaseTransparency(prev_canvas, &params->rect_ll_, curr_canvas);
704      }
705      error_code = EncodeCandidate(&params->sub_frame_ll_, &params->rect_ll_,
706                                   config_ll, use_blending_ll, candidate_ll);
707      if (error_code != VP8_ENC_OK) return error_code;
708    }
709    if (evaluate_lossy) {
710      CopyCurrentCanvas(enc);
711      if (use_blending_lossy) {
712        enc->curr_canvas_copy_modified_ =
713            FlattenSimilarBlocks(prev_canvas, &params->rect_lossy_, curr_canvas,
714                                 config_lossy->quality);
715      }
716      error_code =
717          EncodeCandidate(&params->sub_frame_lossy_, &params->rect_lossy_,
718                          config_lossy, use_blending_lossy, candidate_lossy);
719      if (error_code != VP8_ENC_OK) return error_code;
720      enc->curr_canvas_copy_modified_ = 1;
721    }
722    return error_code;
723  }
724  #undef MIN_COLORS_LOSSY
725  #undef MAX_COLORS_LOSSLESS
726  static void GetEncodedData(const WebPMemoryWriter* const memory,
727                             WebPData* const encoded_data) {
728    encoded_data->bytes = memory->mem;
729    encoded_data->size  = memory->size;
730  }
731  static void SetPreviousDisposeMethod(WebPAnimEncoder* const enc,
732                                       WebPMuxAnimDispose dispose_method) {
733    const size_t position = enc->count_ - 2;
734    EncodedFrame* const prev_enc_frame = GetFrame(enc, position);
735    assert(enc->count_ >= 2);  
736    if (enc->prev_candidate_undecided_) {
737      assert(dispose_method == WEBP_MUX_DISPOSE_NONE);
738      prev_enc_frame->sub_frame_.dispose_method = dispose_method;
739      prev_enc_frame->key_frame_.dispose_method = dispose_method;
740    } else {
741      WebPMuxFrameInfo* const prev_info = prev_enc_frame->is_key_frame_
742                                          ? &prev_enc_frame->key_frame_
743                                          : &prev_enc_frame->sub_frame_;
744      prev_info->dispose_method = dispose_method;
745    }
746  }
747  static int IncreasePreviousDuration(WebPAnimEncoder* const enc, int duration) {
748    const size_t position = enc->count_ - 1;
749    EncodedFrame* const prev_enc_frame = GetFrame(enc, position);
750    int new_duration;
751    assert(enc->count_ >= 1);
752    assert(prev_enc_frame->sub_frame_.duration ==
753           prev_enc_frame->key_frame_.duration);
754    assert(prev_enc_frame->sub_frame_.duration ==
755           (prev_enc_frame->sub_frame_.duration & (MAX_DURATION - 1)));
756    assert(duration == (duration & (MAX_DURATION - 1)));
757    new_duration = prev_enc_frame->sub_frame_.duration + duration;
758    if (new_duration >= MAX_DURATION) {  
759      const FrameRectangle rect = { 0, 0, 1, 1 };
760      const uint8_t lossless_1x1_bytes[] = {
761        0x52, 0x49, 0x46, 0x46, 0x14, 0x00, 0x00, 0x00, 0x57, 0x45, 0x42, 0x50,
762        0x56, 0x50, 0x38, 0x4c, 0x08, 0x00, 0x00, 0x00, 0x2f, 0x00, 0x00, 0x00,
763        0x10, 0x88, 0x88, 0x08
764      };
765      const WebPData lossless_1x1 = {
766          lossless_1x1_bytes, sizeof(lossless_1x1_bytes)
767      };
768      const uint8_t lossy_1x1_bytes[] = {
769        0x52, 0x49, 0x46, 0x46, 0x40, 0x00, 0x00, 0x00, 0x57, 0x45, 0x42, 0x50,
770        0x56, 0x50, 0x38, 0x58, 0x0a, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00,
771        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x41, 0x4c, 0x50, 0x48, 0x02, 0x00,
772        0x00, 0x00, 0x00, 0x00, 0x56, 0x50, 0x38, 0x20, 0x18, 0x00, 0x00, 0x00,
773        0x30, 0x01, 0x00, 0x9d, 0x01, 0x2a, 0x01, 0x00, 0x01, 0x00, 0x02, 0x00,
774        0x34, 0x25, 0xa4, 0x00, 0x03, 0x70, 0x00, 0xfe, 0xfb, 0xfd, 0x50, 0x00
775      };
776      const WebPData lossy_1x1 = { lossy_1x1_bytes, sizeof(lossy_1x1_bytes) };
777      const int can_use_lossless =
778          (enc->last_config_.lossless || enc->options_.allow_mixed);
779      EncodedFrame* const curr_enc_frame = GetFrame(enc, enc->count_);
780      curr_enc_frame->is_key_frame_ = 0;
781      curr_enc_frame->sub_frame_.id = WEBP_CHUNK_ANMF;
782      curr_enc_frame->sub_frame_.x_offset = 0;
783      curr_enc_frame->sub_frame_.y_offset = 0;
784      curr_enc_frame->sub_frame_.dispose_method = WEBP_MUX_DISPOSE_NONE;
785      curr_enc_frame->sub_frame_.blend_method = WEBP_MUX_BLEND;
786      curr_enc_frame->sub_frame_.duration = duration;
787      if (!WebPDataCopy(can_use_lossless ? &lossless_1x1 : &lossy_1x1,
788                        &curr_enc_frame->sub_frame_.bitstream)) {
789        return 0;
790      }
791      ++enc->count_;
792      ++enc->count_since_key_frame_;
793      enc->flush_count_ = enc->count_ - 1;
794      enc->prev_candidate_undecided_ = 0;
795      enc->prev_rect_ = rect;
796    } else {                           
797      prev_enc_frame->sub_frame_.duration = new_duration;
798      prev_enc_frame->key_frame_.duration = new_duration;
799    }
800    return 1;
801  }
802  static void PickBestCandidate(WebPAnimEncoder* const enc,
803                                Candidate* const candidates, int is_key_frame,
804                                EncodedFrame* const encoded_frame) {
805    int i;
806    int best_idx = -1;
807    size_t best_size = ~0;
808    for (i = 0; i < CANDIDATE_COUNT; ++i) {
809      if (candidates[i].evaluate_) {
810        const size_t candidate_size = candidates[i].mem_.size;
811        if (candidate_size < best_size) {
812          best_idx = i;
813          best_size = candidate_size;
814        }
815      }
816    }
817    assert(best_idx != -1);
818    for (i = 0; i < CANDIDATE_COUNT; ++i) {
819      if (candidates[i].evaluate_) {
820        if (i == best_idx) {
821          WebPMuxFrameInfo* const dst = is_key_frame
822                                        ? &encoded_frame->key_frame_
823                                        : &encoded_frame->sub_frame_;
824          *dst = candidates[i].info_;
825          GetEncodedData(&candidates[i].mem_, &dst->bitstream);
826          if (!is_key_frame) {
827            const WebPMuxAnimDispose prev_dispose_method =
828                (best_idx == LL_DISP_NONE || best_idx == LOSSY_DISP_NONE)
829                    ? WEBP_MUX_DISPOSE_NONE
830                    : WEBP_MUX_DISPOSE_BACKGROUND;
831            SetPreviousDisposeMethod(enc, prev_dispose_method);
832          }
833          enc->prev_rect_ = candidates[i].rect_;  
834        } else {
835          WebPMemoryWriterClear(&candidates[i].mem_);
836          candidates[i].evaluate_ = 0;
837        }
838      }
839    }
840  }
841  static WebPEncodingError SetFrame(WebPAnimEncoder* const enc,
842                                    const WebPConfig* const config,
843                                    int is_key_frame,
844                                    EncodedFrame* const encoded_frame,
845                                    int* const frame_skipped) {
846    int i;
847    WebPEncodingError error_code = VP8_ENC_OK;
848    const WebPPicture* const curr_canvas = &enc->curr_canvas_copy_;
849    const WebPPicture* const prev_canvas = &enc->prev_canvas_;
850    Candidate candidates[CANDIDATE_COUNT];
851    const int is_lossless = config->lossless;
852    const int consider_lossless = is_lossless || enc->options_.allow_mixed;
853    const int consider_lossy = !is_lossless || enc->options_.allow_mixed;
854    const int is_first_frame = enc->is_first_frame_;
855    const int empty_rect_allowed_none = !is_first_frame;
856    const int empty_rect_allowed_bg = 0;
857    const int dispose_bg_possible =
858        !is_key_frame && !enc->prev_candidate_undecided_;
859    SubFrameParams dispose_none_params;
860    SubFrameParams dispose_bg_params;
861    WebPConfig config_ll = *config;
862    WebPConfig config_lossy = *config;
863    config_ll.lossless = 1;
864    config_lossy.lossless = 0;
865    enc->last_config_ = *config;
866    enc->last_config_reversed_ = config->lossless ? config_lossy : config_ll;
867    *frame_skipped = 0;
868    if (!SubFrameParamsInit(&dispose_none_params, 1, empty_rect_allowed_none) ||
869        !SubFrameParamsInit(&dispose_bg_params, 0, empty_rect_allowed_bg)) {
870      return VP8_ENC_ERROR_INVALID_CONFIGURATION;
871    }
872    memset(candidates, 0, sizeof(candidates));
873    if (!GetSubRects(prev_canvas, curr_canvas, is_key_frame, is_first_frame,
874                     config_lossy.quality, &dispose_none_params)) {
875      error_code = VP8_ENC_ERROR_INVALID_CONFIGURATION;
876      goto Err;
877    }
878    if ((consider_lossless && IsEmptyRect(&dispose_none_params.rect_ll_)) ||
879        (consider_lossy && IsEmptyRect(&dispose_none_params.rect_lossy_))) {
880      assert(empty_rect_allowed_none);
881      *frame_skipped = 1;
882      goto End;
883    }
884    if (dispose_bg_possible) {
885      WebPPicture* const prev_canvas_disposed = &enc->prev_canvas_disposed_;
886      WebPCopyPixels(prev_canvas, prev_canvas_disposed);
887      DisposeFrameRectangle(WEBP_MUX_DISPOSE_BACKGROUND, &enc->prev_rect_,
888                            prev_canvas_disposed);
889      if (!GetSubRects(prev_canvas_disposed, curr_canvas, is_key_frame,
890                       is_first_frame, config_lossy.quality,
891                       &dispose_bg_params)) {
892        error_code = VP8_ENC_ERROR_INVALID_CONFIGURATION;
893        goto Err;
894      }
895      assert(!IsEmptyRect(&dispose_bg_params.rect_ll_));
896      assert(!IsEmptyRect(&dispose_bg_params.rect_lossy_));
897      if (enc->options_.minimize_size) {  
898        dispose_bg_params.should_try_ = 1;
899        dispose_none_params.should_try_ = 1;
900      } else if ((is_lossless &&
901                  RectArea(&dispose_bg_params.rect_ll_) <
902                      RectArea(&dispose_none_params.rect_ll_)) ||
903                 (!is_lossless &&
904                  RectArea(&dispose_bg_params.rect_lossy_) <
905                      RectArea(&dispose_none_params.rect_lossy_))) {
906        dispose_bg_params.should_try_ = 1;  
907        dispose_none_params.should_try_ = 0;
908      }
909    }
910    if (dispose_none_params.should_try_) {
911      error_code = GenerateCandidates(
912          enc, candidates, WEBP_MUX_DISPOSE_NONE, is_lossless, is_key_frame,
913          &dispose_none_params, &config_ll, &config_lossy);
914      if (error_code != VP8_ENC_OK) goto Err;
915    }
916    if (dispose_bg_params.should_try_) {
917      assert(!enc->is_first_frame_);
918      assert(dispose_bg_possible);
919      error_code = GenerateCandidates(
920          enc, candidates, WEBP_MUX_DISPOSE_BACKGROUND, is_lossless, is_key_frame,
921          &dispose_bg_params, &config_ll, &config_lossy);
922      if (error_code != VP8_ENC_OK) goto Err;
923    }
924    PickBestCandidate(enc, candidates, is_key_frame, encoded_frame);
925    goto End;
926   Err:
927    for (i = 0; i < CANDIDATE_COUNT; ++i) {
928      if (candidates[i].evaluate_) {
929        WebPMemoryWriterClear(&candidates[i].mem_);
930      }
931    }
932   End:
933    SubFrameParamsFree(&dispose_none_params);
934    SubFrameParamsFree(&dispose_bg_params);
935    return error_code;
936  }
937  static int64_t KeyFramePenalty(const EncodedFrame* const encoded_frame) {
938    return ((int64_t)encoded_frame->key_frame_.bitstream.size -
939            encoded_frame->sub_frame_.bitstream.size);
940  }
941  static int CacheFrame(WebPAnimEncoder* const enc,
942                        const WebPConfig* const config) {
943    int ok = 0;
944    int frame_skipped = 0;
945    WebPEncodingError error_code = VP8_ENC_OK;
946    const size_t position = enc->count_;
947    EncodedFrame* const encoded_frame = GetFrame(enc, position);
948    ++enc->count_;
949    if (enc->is_first_frame_) {  
950      error_code = SetFrame(enc, config, 1, encoded_frame, &frame_skipped);
951      if (error_code != VP8_ENC_OK) goto End;
952      assert(frame_skipped == 0);  
953      assert(position == 0 && enc->count_ == 1);
954      encoded_frame->is_key_frame_ = 1;
955      enc->flush_count_ = 0;
956      enc->count_since_key_frame_ = 0;
957      enc->prev_candidate_undecided_ = 0;
958    } else {
959      ++enc->count_since_key_frame_;
960      if (enc->count_since_key_frame_ <= enc->options_.kmin) {
961        error_code = SetFrame(enc, config, 0, encoded_frame, &frame_skipped);
962        if (error_code != VP8_ENC_OK) goto End;
963        if (frame_skipped) goto Skip;
964        encoded_frame->is_key_frame_ = 0;
965        enc->flush_count_ = enc->count_ - 1;
966        enc->prev_candidate_undecided_ = 0;
967      } else {
968        int64_t curr_delta;
969        FrameRectangle prev_rect_key, prev_rect_sub;
970        error_code = SetFrame(enc, config, 0, encoded_frame, &frame_skipped);
971        if (error_code != VP8_ENC_OK) goto End;
972        if (frame_skipped) goto Skip;
973        prev_rect_sub = enc->prev_rect_;
974        error_code = SetFrame(enc, config, 1, encoded_frame, &frame_skipped);
975        if (error_code != VP8_ENC_OK) goto End;
976        assert(frame_skipped == 0);  
977        prev_rect_key = enc->prev_rect_;
978        curr_delta = KeyFramePenalty(encoded_frame);
979        if (curr_delta <= enc->best_delta_) {  
980          if (enc->keyframe_ != KEYFRAME_NONE) {
981            EncodedFrame* const old_keyframe = GetFrame(enc, enc->keyframe_);
982            assert(old_keyframe->is_key_frame_);
983            old_keyframe->is_key_frame_ = 0;
984          }
985          encoded_frame->is_key_frame_ = 1;
986          enc->prev_candidate_undecided_ = 1;
987          enc->keyframe_ = (int)position;
988          enc->best_delta_ = curr_delta;
989          enc->flush_count_ = enc->count_ - 1;  
990        } else {
991          encoded_frame->is_key_frame_ = 0;
992          enc->prev_candidate_undecided_ = 0;
993        }
994        if (enc->count_since_key_frame_ >= enc->options_.kmax) {
995          enc->flush_count_ = enc->count_ - 1;
996          enc->count_since_key_frame_ = 0;
997          enc->keyframe_ = KEYFRAME_NONE;
998          enc->best_delta_ = DELTA_INFINITY;
999        }
1000        if (!enc->prev_candidate_undecided_) {
1001          enc->prev_rect_ =
1002              encoded_frame->is_key_frame_ ? prev_rect_key : prev_rect_sub;
1003        }
1004      }
1005    }
1006    WebPCopyPixels(enc->curr_canvas_, &enc->prev_canvas_);
1007    enc->is_first_frame_ = 0;
1008   Skip:
1009    ok = 1;
1010    ++enc->in_frame_count_;
1011   End:
1012    if (!ok || frame_skipped) {
1013      FrameRelease(encoded_frame);
1014      --enc->count_;
1015      if (!enc->is_first_frame_) --enc->count_since_key_frame_;
1016      if (!ok) {
1017        MarkError2(enc, "ERROR adding frame. WebPEncodingError", error_code);
1018      }
1019    }
1020    enc->curr_canvas_->error_code = error_code;   
1021    assert(ok || error_code != VP8_ENC_OK);
1022    return ok;
1023  }
1024  static int FlushFrames(WebPAnimEncoder* const enc) {
1025    while (enc->flush_count_ > 0) {
1026      WebPMuxError err;
1027      EncodedFrame* const curr = GetFrame(enc, 0);
1028      const WebPMuxFrameInfo* const info =
1029          curr->is_key_frame_ ? &curr->key_frame_ : &curr->sub_frame_;
1030      assert(enc->mux_ != NULL);
1031      err = WebPMuxPushFrame(enc->mux_, info, 1);
1032      if (err != WEBP_MUX_OK) {
1033        MarkError2(enc, "ERROR adding frame. WebPMuxError", err);
1034        return 0;
1035      }
1036      if (enc->options_.verbose) {
1037        fprintf(stderr, "INFO: Added frame. offset:%d,%d dispose:%d blend:%d\n",
1038                info->x_offset, info->y_offset, info->dispose_method,
1039                info->blend_method);
1040      }
1041      ++enc->out_frame_count_;
1042      FrameRelease(curr);
1043      ++enc->start_;
1044      --enc->flush_count_;
1045      --enc->count_;
1046      if (enc->keyframe_ != KEYFRAME_NONE) --enc->keyframe_;
1047    }
1048    if (enc->count_ == 1 && enc->start_ != 0) {
1049      const int enc_start_tmp = (int)enc->start_;
1050      EncodedFrame temp = enc->encoded_frames_[0];
1051      enc->encoded_frames_[0] = enc->encoded_frames_[enc_start_tmp];
1052      enc->encoded_frames_[enc_start_tmp] = temp;
1053      FrameRelease(&enc->encoded_frames_[enc_start_tmp]);
1054      enc->start_ = 0;
1055    }
1056    return 1;
1057  }
1058  #undef DELTA_INFINITY
1059  #undef KEYFRAME_NONE
1060  int WebPAnimEncoderAdd(WebPAnimEncoder* enc, WebPPicture* frame, int timestamp,
1061                         const WebPConfig* encoder_config) {
1062    WebPConfig config;
1063    int ok;
1064    if (enc == NULL) {
1065      return 0;
1066    }
1067    MarkNoError(enc);
1068    if (!enc->is_first_frame_) {
1069      const uint32_t prev_frame_duration =
1070          (uint32_t)timestamp - enc->prev_timestamp_;
1071      if (prev_frame_duration >= MAX_DURATION) {
1072        if (frame != NULL) {
1073          frame->error_code = VP8_ENC_ERROR_INVALID_CONFIGURATION;
1074        }
1075        MarkError(enc, "ERROR adding frame: timestamps must be non-decreasing");
1076        return 0;
1077      }
1078      if (!IncreasePreviousDuration(enc, (int)prev_frame_duration)) {
1079        return 0;
1080      }
1081    } else {
1082      enc->first_timestamp_ = timestamp;
1083    }
1084    if (frame == NULL) {  
1085      enc->got_null_frame_ = 1;
1086      enc->prev_timestamp_ = timestamp;
1087      return 1;
1088    }
1089    if (frame->width != enc->canvas_width_ ||
1090        frame->height != enc->canvas_height_) {
1091      frame->error_code = VP8_ENC_ERROR_INVALID_CONFIGURATION;
1092      MarkError(enc, "ERROR adding frame: Invalid frame dimensions");
1093      return 0;
1094    }
1095    if (!frame->use_argb) {  
1096      if (enc->options_.verbose) {
1097        fprintf(stderr, "WARNING: Converting frame from YUV(A) to ARGB format; "
1098                "this incurs a small loss.\n");
1099      }
1100      if (!WebPPictureYUVAToARGB(frame)) {
1101        MarkError(enc, "ERROR converting frame from YUV(A) to ARGB");
1102        return 0;
1103      }
1104    }
1105    if (encoder_config != NULL) {
1106      if (!WebPValidateConfig(encoder_config)) {
1107        MarkError(enc, "ERROR adding frame: Invalid WebPConfig");
1108        return 0;
1109      }
1110      config = *encoder_config;
1111    } else {
1112      WebPConfigInit(&config);
1113      config.lossless = 1;
1114    }
1115    assert(enc->curr_canvas_ == NULL);
1116    enc->curr_canvas_ = frame;  
1117    assert(enc->curr_canvas_copy_modified_ == 1);
1118    CopyCurrentCanvas(enc);
1119    ok = CacheFrame(enc, &config) && FlushFrames(enc);
1120    enc->curr_canvas_ = NULL;
1121    enc->curr_canvas_copy_modified_ = 1;
1122    if (ok) {
1123      enc->prev_timestamp_ = timestamp;
1124    }
1125    return ok;
1126  }
1127  static int DecodeFrameOntoCanvas(const WebPMuxFrameInfo* const frame,
1128                                   WebPPicture* const canvas) {
1129    const WebPData* const image = &frame->bitstream;
1130    WebPPicture sub_image;
1131    WebPDecoderConfig config;
1132    WebPInitDecoderConfig(&config);
1133    WebPUtilClearPic(canvas, NULL);
1134    if (WebPGetFeatures(image->bytes, image->size, &config.input) !=
1135        VP8_STATUS_OK) {
1136      return 0;
1137    }
1138    if (!WebPPictureView(canvas, frame->x_offset, frame->y_offset,
1139                         config.input.width, config.input.height, &sub_image)) {
1140      return 0;
1141    }
1142    config.output.is_external_memory = 1;
1143    config.output.colorspace = MODE_BGRA;
1144    config.output.u.RGBA.rgba = (uint8_t*)sub_image.argb;
1145    config.output.u.RGBA.stride = sub_image.argb_stride * 4;
1146    config.output.u.RGBA.size = config.output.u.RGBA.stride * sub_image.height;
1147    if (WebPDecode(image->bytes, image->size, &config) != VP8_STATUS_OK) {
1148      return 0;
1149    }
1150    return 1;
1151  }
1152  static int FrameToFullCanvas(WebPAnimEncoder* const enc,
1153                               const WebPMuxFrameInfo* const frame,
1154                               WebPData* const full_image) {
1155    WebPPicture* const canvas_buf = &enc->curr_canvas_copy_;
1156    WebPMemoryWriter mem1, mem2;
1157    WebPMemoryWriterInit(&mem1);
1158    WebPMemoryWriterInit(&mem2);
1159    if (!DecodeFrameOntoCanvas(frame, canvas_buf)) goto Err;
1160    if (!EncodeFrame(&enc->last_config_, canvas_buf, &mem1)) goto Err;
1161    GetEncodedData(&mem1, full_image);
1162    if (enc->options_.allow_mixed) {
1163      if (!EncodeFrame(&enc->last_config_reversed_, canvas_buf, &mem2)) goto Err;
1164      if (mem2.size < mem1.size) {
1165        GetEncodedData(&mem2, full_image);
1166        WebPMemoryWriterClear(&mem1);
1167      } else {
1168        WebPMemoryWriterClear(&mem2);
1169      }
1170    }
1171    return 1;
1172   Err:
1173    WebPMemoryWriterClear(&mem1);
1174    WebPMemoryWriterClear(&mem2);
1175    return 0;
1176  }
1177  static WebPMuxError OptimizeSingleFrame(WebPAnimEncoder* const enc,
1178                                          WebPData* const webp_data) {
1179    WebPMuxError err = WEBP_MUX_OK;
1180    int canvas_width, canvas_height;
1181    WebPMuxFrameInfo frame;
1182    WebPData full_image;
1183    WebPData webp_data2;
1184    WebPMux* const mux = WebPMuxCreate(webp_data, 0);
1185    if (mux == NULL) return WEBP_MUX_BAD_DATA;
1186    assert(enc->out_frame_count_ == 1);
1187    WebPDataInit(&frame.bitstream);
1188    WebPDataInit(&full_image);
1189    WebPDataInit(&webp_data2);
1190    err = WebPMuxGetFrame(mux, 1, &frame);
1191    if (err != WEBP_MUX_OK) goto End;
1192    if (frame.id != WEBP_CHUNK_ANMF) goto End;  
1193    err = WebPMuxGetCanvasSize(mux, &canvas_width, &canvas_height);
1194    if (err != WEBP_MUX_OK) goto End;
1195    if (!FrameToFullCanvas(enc, &frame, &full_image)) {
1196      err = WEBP_MUX_BAD_DATA;
1197      goto End;
1198    }
1199    err = WebPMuxSetImage(mux, &full_image, 1);
1200    if (err != WEBP_MUX_OK) goto End;
1201    err = WebPMuxAssemble(mux, &webp_data2);
1202    if (err != WEBP_MUX_OK) goto End;
1203    if (webp_data2.size < webp_data->size) {  
1204      WebPDataClear(webp_data);
1205      *webp_data = webp_data2;
1206      WebPDataInit(&webp_data2);
1207    }
1208   End:
1209    WebPDataClear(&frame.bitstream);
1210    WebPDataClear(&full_image);
1211    WebPMuxDelete(mux);
1212    WebPDataClear(&webp_data2);
1213    return err;
1214  }
1215  int WebPAnimEncoderAssemble(WebPAnimEncoder* enc, WebPData* webp_data) {
1216    WebPMux* mux;
1217    WebPMuxError err;
1218    if (enc == NULL) {
1219      return 0;
1220    }
1221    MarkNoError(enc);
1222    if (webp_data == NULL) {
1223      MarkError(enc, "ERROR assembling: NULL input");
1224      return 0;
1225    }
1226    if (enc->in_frame_count_ == 0) {
1227      MarkError(enc, "ERROR: No frames to assemble");
1228      return 0;
1229    }
1230    if (!enc->got_null_frame_ && enc->in_frame_count_ > 1 && enc->count_ > 0) {
1231      const double delta_time =
1232          (uint32_t)enc->prev_timestamp_ - enc->first_timestamp_;
1233      const int average_duration = (int)(delta_time / (enc->in_frame_count_ - 1));
1234      if (!IncreasePreviousDuration(enc, average_duration)) {
1235        return 0;
1236      }
1237    }
1238    enc->flush_count_ = enc->count_;
1239    if (!FlushFrames(enc)) {
1240      return 0;
1241    }
1242    mux = enc->mux_;
1243    err = WebPMuxSetCanvasSize(mux, enc->canvas_width_, enc->canvas_height_);
1244    if (err != WEBP_MUX_OK) goto Err;
1245    err = WebPMuxSetAnimationParams(mux, &enc->options_.anim_params);
1246    if (err != WEBP_MUX_OK) goto Err;
1247    err = WebPMuxAssemble(mux, webp_data);
1248    if (err != WEBP_MUX_OK) goto Err;
1249    if (enc->out_frame_count_ == 1) {
1250      err = OptimizeSingleFrame(enc, webp_data);
1251      if (err != WEBP_MUX_OK) goto Err;
1252    }
1253    return 1;
1254   Err:
1255    MarkError2(enc, "ERROR assembling WebP", err);
1256    return 0;
1257  }
1258  const char* WebPAnimEncoderGetError(WebPAnimEncoder* enc) {
1259    if (enc == NULL) return NULL;
1260    return enc->error_str_;
1261  }
</code></pre>
        </div>
        <div class="column">
            <h3>PINRemoteImage-MDEwOlJlcG9zaXRvcnkzOTUzNzEwMw==-flat-lossless_enc.c</h3>
            <pre><code>1  #include "src/dsp/dsp.h"
2  #include <assert.h>
3  #include <math.h>
4  #include <stdlib.h>
5  #include "src/dec/vp8li_dec.h"
6  #include "src/utils/endian_inl_utils.h"
7  #include "src/dsp/lossless.h"
8  #include "src/dsp/lossless_common.h"
9  #include "src/dsp/yuv.h"
10  const float kLog2Table[LOG_LOOKUP_IDX_MAX] = {
11    0.0000000000000000f, 0.0000000000000000f,
12    1.0000000000000000f, 1.5849625007211560f,
13    2.0000000000000000f, 2.3219280948873621f,
14    2.5849625007211560f, 2.8073549220576041f,
15    3.0000000000000000f, 3.1699250014423121f,
16    3.3219280948873621f, 3.4594316186372973f,
17    3.5849625007211560f, 3.7004397181410921f,
18    3.8073549220576041f, 3.9068905956085187f,
19    4.0000000000000000f, 4.0874628412503390f,
20    4.1699250014423121f, 4.2479275134435852f,
21    4.3219280948873626f, 4.3923174227787606f,
22    4.4594316186372973f, 4.5235619560570130f,
23    4.5849625007211560f, 4.6438561897747243f,
24    4.7004397181410917f, 4.7548875021634682f,
25    4.8073549220576037f, 4.8579809951275718f,
26    4.9068905956085187f, 4.9541963103868749f,
27    5.0000000000000000f, 5.0443941193584533f,
28    5.0874628412503390f, 5.1292830169449663f,
29    5.1699250014423121f, 5.2094533656289501f,
30    5.2479275134435852f, 5.2854022188622487f,
31    5.3219280948873626f, 5.3575520046180837f,
32    5.3923174227787606f, 5.4262647547020979f,
33    5.4594316186372973f, 5.4918530963296747f,
34    5.5235619560570130f, 5.5545888516776376f,
35    5.5849625007211560f, 5.6147098441152083f,
36    5.6438561897747243f, 5.6724253419714951f,
37    5.7004397181410917f, 5.7279204545631987f,
38    5.7548875021634682f, 5.7813597135246599f,
39    5.8073549220576037f, 5.8328900141647412f,
40    5.8579809951275718f, 5.8826430493618415f,
41    5.9068905956085187f, 5.9307373375628866f,
42    5.9541963103868749f, 5.9772799234999167f,
43    6.0000000000000000f, 6.0223678130284543f,
44    6.0443941193584533f, 6.0660891904577720f,
45    6.0874628412503390f, 6.1085244567781691f,
46    6.1292830169449663f, 6.1497471195046822f,
47    6.1699250014423121f, 6.1898245588800175f,
48    6.2094533656289501f, 6.2288186904958804f,
49    6.2479275134435852f, 6.2667865406949010f,
50    6.2854022188622487f, 6.3037807481771030f,
51    6.3219280948873626f, 6.3398500028846243f,
52    6.3575520046180837f, 6.3750394313469245f,
53    6.3923174227787606f, 6.4093909361377017f,
54    6.4262647547020979f, 6.4429434958487279f,
55    6.4594316186372973f, 6.4757334309663976f,
56    6.4918530963296747f, 6.5077946401986963f,
57    6.5235619560570130f, 6.5391588111080309f,
58    6.5545888516776376f, 6.5698556083309478f,
59    6.5849625007211560f, 6.5999128421871278f,
60    6.6147098441152083f, 6.6293566200796094f,
61    6.6438561897747243f, 6.6582114827517946f,
62    6.6724253419714951f, 6.6865005271832185f,
63    6.7004397181410917f, 6.7142455176661224f,
64    6.7279204545631987f, 6.7414669864011464f,
65    6.7548875021634682f, 6.7681843247769259f,
66    6.7813597135246599f, 6.7944158663501061f,
67    6.8073549220576037f, 6.8201789624151878f,
68    6.8328900141647412f, 6.8454900509443747f,
69    6.8579809951275718f, 6.8703647195834047f,
70    6.8826430493618415f, 6.8948177633079437f,
71    6.9068905956085187f, 6.9188632372745946f,
72    6.9307373375628866f, 6.9425145053392398f,
73    6.9541963103868749f, 6.9657842846620869f,
74    6.9772799234999167f, 6.9886846867721654f,
75    7.0000000000000000f, 7.0112272554232539f,
76    7.0223678130284543f, 7.0334230015374501f,
77    7.0443941193584533f, 7.0552824355011898f,
78    7.0660891904577720f, 7.0768155970508308f,
79    7.0874628412503390f, 7.0980320829605263f,
80    7.1085244567781691f, 7.1189410727235076f,
81    7.1292830169449663f, 7.1395513523987936f,
82    7.1497471195046822f, 7.1598713367783890f,
83    7.1699250014423121f, 7.1799090900149344f,
84    7.1898245588800175f, 7.1996723448363644f,
85    7.2094533656289501f, 7.2191685204621611f,
86    7.2288186904958804f, 7.2384047393250785f,
87    7.2479275134435852f, 7.2573878426926521f,
88    7.2667865406949010f, 7.2761244052742375f,
89    7.2854022188622487f, 7.2946207488916270f,
90    7.3037807481771030f, 7.3128829552843557f,
91    7.3219280948873626f, 7.3309168781146167f,
92    7.3398500028846243f, 7.3487281542310771f,
93    7.3575520046180837f, 7.3663222142458160f,
94    7.3750394313469245f, 7.3837042924740519f,
95    7.3923174227787606f, 7.4008794362821843f,
96    7.4093909361377017f, 7.4178525148858982f,
97    7.4262647547020979f, 7.4346282276367245f,
98    7.4429434958487279f, 7.4512111118323289f,
99    7.4594316186372973f, 7.4676055500829976f,
100    7.4757334309663976f, 7.4838157772642563f,
101    7.4918530963296747f, 7.4998458870832056f,
102    7.5077946401986963f, 7.5156998382840427f,
103    7.5235619560570130f, 7.5313814605163118f,
104    7.5391588111080309f, 7.5468944598876364f,
105    7.5545888516776376f, 7.5622424242210728f,
106    7.5698556083309478f, 7.5774288280357486f,
107    7.5849625007211560f, 7.5924570372680806f,
108    7.5999128421871278f, 7.6073303137496104f,
109    7.6147098441152083f, 7.6220518194563764f,
110    7.6293566200796094f, 7.6366246205436487f,
111    7.6438561897747243f, 7.6510516911789281f,
112    7.6582114827517946f, 7.6653359171851764f,
113    7.6724253419714951f, 7.6794800995054464f,
114    7.6865005271832185f, 7.6934869574993252f,
115    7.7004397181410917f, 7.7073591320808825f,
116    7.7142455176661224f, 7.7210991887071855f,
117    7.7279204545631987f, 7.7347096202258383f,
118    7.7414669864011464f, 7.7481928495894605f,
119    7.7548875021634682f, 7.7615512324444795f,
120    7.7681843247769259f, 7.7747870596011736f,
121    7.7813597135246599f, 7.7879025593914317f,
122    7.7944158663501061f, 7.8008998999203047f,
123    7.8073549220576037f, 7.8137811912170374f,
124    7.8201789624151878f, 7.8265484872909150f,
125    7.8328900141647412f, 7.8392037880969436f,
126    7.8454900509443747f, 7.8517490414160571f,
127    7.8579809951275718f, 7.8641861446542797f,
128    7.8703647195834047f, 7.8765169465649993f,
129    7.8826430493618415f, 7.8887432488982591f,
130    7.8948177633079437f, 7.9008668079807486f,
131    7.9068905956085187f, 7.9128893362299619f,
132    7.9188632372745946f, 7.9248125036057812f,
133    7.9307373375628866f, 7.9366379390025709f,
134    7.9425145053392398f, 7.9483672315846778f,
135    7.9541963103868749f, 7.9600019320680805f,
136    7.9657842846620869f, 7.9715435539507719f,
137    7.9772799234999167f, 7.9829935746943103f,
138    7.9886846867721654f, 7.9943534368588577f
139  };
140  const float kSLog2Table[LOG_LOOKUP_IDX_MAX] = {
141    0.00000000f,    0.00000000f,  2.00000000f,   4.75488750f,
142    8.00000000f,   11.60964047f,  15.50977500f,  19.65148445f,
143    24.00000000f,  28.52932501f,  33.21928095f,  38.05374781f,
144    43.01955001f,  48.10571634f,  53.30296891f,  58.60335893f,
145    64.00000000f,  69.48686830f,  75.05865003f,  80.71062276f,
146    86.43856190f,  92.23866588f,  98.10749561f,  104.04192499f,
147    110.03910002f, 116.09640474f, 122.21143267f, 128.38196256f,
148    134.60593782f, 140.88144886f, 147.20671787f, 153.58008562f,
149    160.00000000f, 166.46500594f, 172.97373660f, 179.52490559f,
150    186.11730005f, 192.74977453f, 199.42124551f, 206.13068654f,
151    212.87712380f, 219.65963219f, 226.47733176f, 233.32938445f,
152    240.21499122f, 247.13338933f, 254.08384998f, 261.06567603f,
153    268.07820003f, 275.12078236f, 282.19280949f, 289.29369244f,
154    296.42286534f, 303.57978409f, 310.76392512f, 317.97478424f,
155    325.21187564f, 332.47473081f, 339.76289772f, 347.07593991f,
156    354.41343574f, 361.77497759f, 369.16017124f, 376.56863518f,
157    384.00000000f, 391.45390785f, 398.93001188f, 406.42797576f,
158    413.94747321f, 421.48818752f, 429.04981119f, 436.63204548f,
159    444.23460010f, 451.85719280f, 459.49954906f, 467.16140179f,
160    474.84249102f, 482.54256363f, 490.26137307f, 497.99867911f,
161    505.75424759f, 513.52785023f, 521.31926438f, 529.12827280f,
162    536.95466351f, 544.79822957f, 552.65876890f, 560.53608414f,
163    568.42998244f, 576.34027536f, 584.26677867f, 592.20931226f,
164    600.16769996f, 608.14176943f, 616.13135206f, 624.13628279f,
165    632.15640007f, 640.19154569f, 648.24156472f, 656.30630539f,
166    664.38561898f, 672.47935976f, 680.58738488f, 688.70955430f,
167    696.84573069f, 704.99577935f, 713.15956818f, 721.33696754f,
168    729.52785023f, 737.73209140f, 745.94956849f, 754.18016116f,
169    762.42375127f, 770.68022275f, 778.94946161f, 787.23135586f,
170    795.52579543f, 803.83267219f, 812.15187982f, 820.48331383f,
171    828.82687147f, 837.18245171f, 845.54995518f, 853.92928416f,
172    862.32034249f, 870.72303558f, 879.13727036f, 887.56295522f,
173    896.00000000f, 904.44831595f, 912.90781569f, 921.37841320f,
174    929.86002376f, 938.35256392f, 946.85595152f, 955.37010560f,
175    963.89494641f, 972.43039537f, 980.97637504f, 989.53280911f,
176    998.09962237f, 1006.67674069f, 1015.26409097f, 1023.86160116f,
177    1032.46920021f, 1041.08681805f, 1049.71438560f, 1058.35183469f,
178    1066.99909811f, 1075.65610955f, 1084.32280357f, 1092.99911564f,
179    1101.68498204f, 1110.38033993f, 1119.08512727f, 1127.79928282f,
180    1136.52274614f, 1145.25545758f, 1153.99735821f, 1162.74838989f,
181    1171.50849518f, 1180.27761738f, 1189.05570047f, 1197.84268914f,
182    1206.63852876f, 1215.44316535f, 1224.25654560f, 1233.07861684f,
183    1241.90932703f, 1250.74862473f, 1259.59645914f, 1268.45278005f,
184    1277.31753781f, 1286.19068338f, 1295.07216828f, 1303.96194457f,
185    1312.85996488f, 1321.76618236f, 1330.68055071f, 1339.60302413f,
186    1348.53355734f, 1357.47210556f, 1366.41862452f, 1375.37307041f,
187    1384.33539991f, 1393.30557020f, 1402.28353887f, 1411.26926400f,
188    1420.26270412f, 1429.26381818f, 1438.27256558f, 1447.28890615f,
189    1456.31280014f, 1465.34420819f, 1474.38309138f, 1483.42941118f,
190    1492.48312945f, 1501.54420843f, 1510.61261078f, 1519.68829949f,
191    1528.77123795f, 1537.86138993f, 1546.95871952f, 1556.06319119f,
192    1565.17476976f, 1574.29342040f, 1583.41910860f, 1592.55180020f,
193    1601.69146137f, 1610.83805860f, 1619.99155871f, 1629.15192882f,
194    1638.31913637f, 1647.49314911f, 1656.67393509f, 1665.86146266f,
195    1675.05570047f, 1684.25661744f, 1693.46418280f, 1702.67836605f,
196    1711.89913698f, 1721.12646563f, 1730.36032233f, 1739.60067768f,
197    1748.84750254f, 1758.10076802f, 1767.36044551f, 1776.62650662f,
198    1785.89892323f, 1795.17766747f, 1804.46271172f, 1813.75402857f,
199    1823.05159087f, 1832.35537170f, 1841.66534438f, 1850.98148244f,
200    1860.30375965f, 1869.63214999f, 1878.96662767f, 1888.30716711f,
201    1897.65374295f, 1907.00633003f, 1916.36490342f, 1925.72943838f,
202    1935.09991037f, 1944.47629506f, 1953.85856831f, 1963.24670620f,
203    1972.64068498f, 1982.04048108f, 1991.44607117f, 2000.85743204f,
204    2010.27454072f, 2019.69737440f, 2029.12591044f, 2038.56012640f
205  };
206  const VP8LPrefixCode kPrefixEncodeCode[PREFIX_LOOKUP_IDX_MAX] = {
207    { 0, 0}, { 0, 0}, { 1, 0}, { 2, 0}, { 3, 0}, { 4, 1}, { 4, 1}, { 5, 1},
208    { 5, 1}, { 6, 2}, { 6, 2}, { 6, 2}, { 6, 2}, { 7, 2}, { 7, 2}, { 7, 2},
209    { 7, 2}, { 8, 3}, { 8, 3}, { 8, 3}, { 8, 3}, { 8, 3}, { 8, 3}, { 8, 3},
210    { 8, 3}, { 9, 3}, { 9, 3}, { 9, 3}, { 9, 3}, { 9, 3}, { 9, 3}, { 9, 3},
211    { 9, 3}, {10, 4}, {10, 4}, {10, 4}, {10, 4}, {10, 4}, {10, 4}, {10, 4},
212    {10, 4}, {10, 4}, {10, 4}, {10, 4}, {10, 4}, {10, 4}, {10, 4}, {10, 4},
213    {10, 4}, {11, 4}, {11, 4}, {11, 4}, {11, 4}, {11, 4}, {11, 4}, {11, 4},
214    {11, 4}, {11, 4}, {11, 4}, {11, 4}, {11, 4}, {11, 4}, {11, 4}, {11, 4},
215    {11, 4}, {12, 5}, {12, 5}, {12, 5}, {12, 5}, {12, 5}, {12, 5}, {12, 5},
216    {12, 5}, {12, 5}, {12, 5}, {12, 5}, {12, 5}, {12, 5}, {12, 5}, {12, 5},
217    {12, 5}, {12, 5}, {12, 5}, {12, 5}, {12, 5}, {12, 5}, {12, 5}, {12, 5},
218    {12, 5}, {12, 5}, {12, 5}, {12, 5}, {12, 5}, {12, 5}, {12, 5}, {12, 5},
219    {12, 5}, {13, 5}, {13, 5}, {13, 5}, {13, 5}, {13, 5}, {13, 5}, {13, 5},
220    {13, 5}, {13, 5}, {13, 5}, {13, 5}, {13, 5}, {13, 5}, {13, 5}, {13, 5},
221    {13, 5}, {13, 5}, {13, 5}, {13, 5}, {13, 5}, {13, 5}, {13, 5}, {13, 5},
222    {13, 5}, {13, 5}, {13, 5}, {13, 5}, {13, 5}, {13, 5}, {13, 5}, {13, 5},
223    {13, 5}, {14, 6}, {14, 6}, {14, 6}, {14, 6}, {14, 6}, {14, 6}, {14, 6},
224    {14, 6}, {14, 6}, {14, 6}, {14, 6}, {14, 6}, {14, 6}, {14, 6}, {14, 6},
225    {14, 6}, {14, 6}, {14, 6}, {14, 6}, {14, 6}, {14, 6}, {14, 6}, {14, 6},
226    {14, 6}, {14, 6}, {14, 6}, {14, 6}, {14, 6}, {14, 6}, {14, 6}, {14, 6},
227    {14, 6}, {14, 6}, {14, 6}, {14, 6}, {14, 6}, {14, 6}, {14, 6}, {14, 6},
228    {14, 6}, {14, 6}, {14, 6}, {14, 6}, {14, 6}, {14, 6}, {14, 6}, {14, 6},
229    {14, 6}, {14, 6}, {14, 6}, {14, 6}, {14, 6}, {14, 6}, {14, 6}, {14, 6},
230    {14, 6}, {14, 6}, {14, 6}, {14, 6}, {14, 6}, {14, 6}, {14, 6}, {14, 6},
231    {14, 6}, {15, 6}, {15, 6}, {15, 6}, {15, 6}, {15, 6}, {15, 6}, {15, 6},
232    {15, 6}, {15, 6}, {15, 6}, {15, 6}, {15, 6}, {15, 6}, {15, 6}, {15, 6},
233    {15, 6}, {15, 6}, {15, 6}, {15, 6}, {15, 6}, {15, 6}, {15, 6}, {15, 6},
234    {15, 6}, {15, 6}, {15, 6}, {15, 6}, {15, 6}, {15, 6}, {15, 6}, {15, 6},
235    {15, 6}, {15, 6}, {15, 6}, {15, 6}, {15, 6}, {15, 6}, {15, 6}, {15, 6},
236    {15, 6}, {15, 6}, {15, 6}, {15, 6}, {15, 6}, {15, 6}, {15, 6}, {15, 6},
237    {15, 6}, {15, 6}, {15, 6}, {15, 6}, {15, 6}, {15, 6}, {15, 6}, {15, 6},
238    {15, 6}, {15, 6}, {15, 6}, {15, 6}, {15, 6}, {15, 6}, {15, 6}, {15, 6},
239    {15, 6}, {16, 7}, {16, 7}, {16, 7}, {16, 7}, {16, 7}, {16, 7}, {16, 7},
240    {16, 7}, {16, 7}, {16, 7}, {16, 7}, {16, 7}, {16, 7}, {16, 7}, {16, 7},
241    {16, 7}, {16, 7}, {16, 7}, {16, 7}, {16, 7}, {16, 7}, {16, 7}, {16, 7},
242    {16, 7}, {16, 7}, {16, 7}, {16, 7}, {16, 7}, {16, 7}, {16, 7}, {16, 7},
243    {16, 7}, {16, 7}, {16, 7}, {16, 7}, {16, 7}, {16, 7}, {16, 7}, {16, 7},
244    {16, 7}, {16, 7}, {16, 7}, {16, 7}, {16, 7}, {16, 7}, {16, 7}, {16, 7},
245    {16, 7}, {16, 7}, {16, 7}, {16, 7}, {16, 7}, {16, 7}, {16, 7}, {16, 7},
246    {16, 7}, {16, 7}, {16, 7}, {16, 7}, {16, 7}, {16, 7}, {16, 7}, {16, 7},
247    {16, 7}, {16, 7}, {16, 7}, {16, 7}, {16, 7}, {16, 7}, {16, 7}, {16, 7},
248    {16, 7}, {16, 7}, {16, 7}, {16, 7}, {16, 7}, {16, 7}, {16, 7}, {16, 7},
249    {16, 7}, {16, 7}, {16, 7}, {16, 7}, {16, 7}, {16, 7}, {16, 7}, {16, 7},
250    {16, 7}, {16, 7}, {16, 7}, {16, 7}, {16, 7}, {16, 7}, {16, 7}, {16, 7},
251    {16, 7}, {16, 7}, {16, 7}, {16, 7}, {16, 7}, {16, 7}, {16, 7}, {16, 7},
252    {16, 7}, {16, 7}, {16, 7}, {16, 7}, {16, 7}, {16, 7}, {16, 7}, {16, 7},
253    {16, 7}, {16, 7}, {16, 7}, {16, 7}, {16, 7}, {16, 7}, {16, 7}, {16, 7},
254    {16, 7}, {16, 7}, {16, 7}, {16, 7}, {16, 7}, {16, 7}, {16, 7}, {16, 7},
255    {16, 7}, {17, 7}, {17, 7}, {17, 7}, {17, 7}, {17, 7}, {17, 7}, {17, 7},
256    {17, 7}, {17, 7}, {17, 7}, {17, 7}, {17, 7}, {17, 7}, {17, 7}, {17, 7},
257    {17, 7}, {17, 7}, {17, 7}, {17, 7}, {17, 7}, {17, 7}, {17, 7}, {17, 7},
258    {17, 7}, {17, 7}, {17, 7}, {17, 7}, {17, 7}, {17, 7}, {17, 7}, {17, 7},
259    {17, 7}, {17, 7}, {17, 7}, {17, 7}, {17, 7}, {17, 7}, {17, 7}, {17, 7},
260    {17, 7}, {17, 7}, {17, 7}, {17, 7}, {17, 7}, {17, 7}, {17, 7}, {17, 7},
261    {17, 7}, {17, 7}, {17, 7}, {17, 7}, {17, 7}, {17, 7}, {17, 7}, {17, 7},
262    {17, 7}, {17, 7}, {17, 7}, {17, 7}, {17, 7}, {17, 7}, {17, 7}, {17, 7},
263    {17, 7}, {17, 7}, {17, 7}, {17, 7}, {17, 7}, {17, 7}, {17, 7}, {17, 7},
264    {17, 7}, {17, 7}, {17, 7}, {17, 7}, {17, 7}, {17, 7}, {17, 7}, {17, 7},
265    {17, 7}, {17, 7}, {17, 7}, {17, 7}, {17, 7}, {17, 7}, {17, 7}, {17, 7},
266    {17, 7}, {17, 7}, {17, 7}, {17, 7}, {17, 7}, {17, 7}, {17, 7}, {17, 7},
267    {17, 7}, {17, 7}, {17, 7}, {17, 7}, {17, 7}, {17, 7}, {17, 7}, {17, 7},
268    {17, 7}, {17, 7}, {17, 7}, {17, 7}, {17, 7}, {17, 7}, {17, 7}, {17, 7},
269    {17, 7}, {17, 7}, {17, 7}, {17, 7}, {17, 7}, {17, 7}, {17, 7}, {17, 7},
270    {17, 7}, {17, 7}, {17, 7}, {17, 7}, {17, 7}, {17, 7}, {17, 7}, {17, 7},
271  };
272  const uint8_t kPrefixEncodeExtraBitsValue[PREFIX_LOOKUP_IDX_MAX] = {
273     0,  0,  0,  0,  0,  0,  1,  0,  1,  0,  1,  2,  3,  0,  1,  2,  3,
274     0,  1,  2,  3,  4,  5,  6,  7,  0,  1,  2,  3,  4,  5,  6,  7,
275     0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15,
276     0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15,
277     0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15,
278    16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31,
279     0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15,
280    16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31,
281     0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15,
282    16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31,
283    32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47,
284    48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63,
285     0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15,
286    16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31,
287    32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47,
288    48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63,
289     0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15,
290    16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31,
291    32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47,
292    48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63,
293    64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79,
294    80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95,
295    96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111,
296    112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126,
297    127,
298     0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15,
299    16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31,
300    32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47,
301    48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63,
302    64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79,
303    80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95,
304    96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111,
305    112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126
306  };
307  static float FastSLog2Slow_C(uint32_t v) {
308    assert(v >= LOG_LOOKUP_IDX_MAX);
309    if (v < APPROX_LOG_WITH_CORRECTION_MAX) {
310      int log_cnt = 0;
311      uint32_t y = 1;
312      int correction = 0;
313      const float v_f = (float)v;
314      const uint32_t orig_v = v;
315      do {
316        ++log_cnt;
317        v = v >> 1;
318        y = y << 1;
319      } while (v >= LOG_LOOKUP_IDX_MAX);
320      correction = (23 * (orig_v & (y - 1))) >> 4;
321      return v_f * (kLog2Table[v] + log_cnt) + correction;
322    } else {
323      return (float)(LOG_2_RECIPROCAL * v * log((double)v));
324    }
325  }
326  static float FastLog2Slow_C(uint32_t v) {
327    assert(v >= LOG_LOOKUP_IDX_MAX);
328    if (v < APPROX_LOG_WITH_CORRECTION_MAX) {
329      int log_cnt = 0;
330      uint32_t y = 1;
331      const uint32_t orig_v = v;
332      double log_2;
333      do {
334        ++log_cnt;
335        v = v >> 1;
336        y = y << 1;
337      } while (v >= LOG_LOOKUP_IDX_MAX);
338      log_2 = kLog2Table[v] + log_cnt;
339      if (orig_v >= APPROX_LOG_MAX) {
340        const int correction = (23 * (orig_v & (y - 1))) >> 4;
341        log_2 += (double)correction / orig_v;
342      }
343      return (float)log_2;
344    } else {
345      return (float)(LOG_2_RECIPROCAL * log((double)v));
346    }
347  }
348  static float CombinedShannonEntropy_C(const int X[256], const int Y[256]) {
349    int i;
350    double retval = 0.;
351    int sumX = 0, sumXY = 0;
352    for (i = 0; i < 256; ++i) {
353      const int x = X[i];
354      if (x != 0) {
355        const int xy = x + Y[i];
356        sumX += x;
357        retval -= VP8LFastSLog2(x);
358        sumXY += xy;
359        retval -= VP8LFastSLog2(xy);
360      } else if (Y[i] != 0) {
361        sumXY += Y[i];
362        retval -= VP8LFastSLog2(Y[i]);
363      }
364    }
365    retval += VP8LFastSLog2(sumX) + VP8LFastSLog2(sumXY);
366    return (float)retval;
367  }
368  void VP8LBitEntropyInit(VP8LBitEntropy* const entropy) {
369    entropy->entropy = 0.;
370    entropy->sum = 0;
371    entropy->nonzeros = 0;
372    entropy->max_val = 0;
373    entropy->nonzero_code = VP8L_NON_TRIVIAL_SYM;
374  }
375  void VP8LBitsEntropyUnrefined(const uint32_t* const array, int n,
376                                VP8LBitEntropy* const entropy) {
377    int i;
378    VP8LBitEntropyInit(entropy);
379    for (i = 0; i < n; ++i) {
380      if (array[i] != 0) {
381        entropy->sum += array[i];
382        entropy->nonzero_code = i;
383        ++entropy->nonzeros;
384        entropy->entropy -= VP8LFastSLog2(array[i]);
385        if (entropy->max_val < array[i]) {
386          entropy->max_val = array[i];
387        }
388      }
389    }
390    entropy->entropy += VP8LFastSLog2(entropy->sum);
391  }
392  static WEBP_INLINE void GetEntropyUnrefinedHelper(
393      uint32_t val, int i, uint32_t* const val_prev, int* const i_prev,
394      VP8LBitEntropy* const bit_entropy, VP8LStreaks* const stats) {
395    const int streak = i - *i_prev;
396    if (*val_prev != 0) {
397      bit_entropy->sum += (*val_prev) * streak;
398      bit_entropy->nonzeros += streak;
399      bit_entropy->nonzero_code = *i_prev;
400      bit_entropy->entropy -= VP8LFastSLog2(*val_prev) * streak;
401      if (bit_entropy->max_val < *val_prev) {
402        bit_entropy->max_val = *val_prev;
403      }
404    }
405    stats->counts[*val_prev != 0] += (streak > 3);
406    stats->streaks[*val_prev != 0][(streak > 3)] += streak;
407    *val_prev = val;
408    *i_prev = i;
409  }
410  static void GetEntropyUnrefined_C(const uint32_t X[], int length,
411                                    VP8LBitEntropy* const bit_entropy,
412                                    VP8LStreaks* const stats) {
413    int i;
414    int i_prev = 0;
415    uint32_t x_prev = X[0];
416    memset(stats, 0, sizeof(*stats));
417    VP8LBitEntropyInit(bit_entropy);
418    for (i = 1; i < length; ++i) {
419      const uint32_t x = X[i];
420      if (x != x_prev) {
421        GetEntropyUnrefinedHelper(x, i, &x_prev, &i_prev, bit_entropy, stats);
422      }
423    }
424    GetEntropyUnrefinedHelper(0, i, &x_prev, &i_prev, bit_entropy, stats);
425    bit_entropy->entropy += VP8LFastSLog2(bit_entropy->sum);
426  }
427  static void GetCombinedEntropyUnrefined_C(const uint32_t X[],
428                                            const uint32_t Y[],
429                                            int length,
430                                            VP8LBitEntropy* const bit_entropy,
431                                            VP8LStreaks* const stats) {
432    int i = 1;
433    int i_prev = 0;
434    uint32_t xy_prev = X[0] + Y[0];
435    memset(stats, 0, sizeof(*stats));
436    VP8LBitEntropyInit(bit_entropy);
437    for (i = 1; i < length; ++i) {
438      const uint32_t xy = X[i] + Y[i];
439      if (xy != xy_prev) {
440        GetEntropyUnrefinedHelper(xy, i, &xy_prev, &i_prev, bit_entropy, stats);
441      }
442    }
443    GetEntropyUnrefinedHelper(0, i, &xy_prev, &i_prev, bit_entropy, stats);
444    bit_entropy->entropy += VP8LFastSLog2(bit_entropy->sum);
445  }
446  void VP8LSubtractGreenFromBlueAndRed_C(uint32_t* argb_data, int num_pixels) {
447    int i;
448    for (i = 0; i < num_pixels; ++i) {
449      const int argb = argb_data[i];
450      const int green = (argb >> 8) & 0xff;
451      const uint32_t new_r = (((argb >> 16) & 0xff) - green) & 0xff;
452      const uint32_t new_b = (((argb >>  0) & 0xff) - green) & 0xff;
453      argb_data[i] = (argb & 0xff00ff00u) | (new_r << 16) | new_b;
454    }
455  }
456  static WEBP_INLINE int ColorTransformDelta(int8_t color_pred, int8_t color) {
457    return ((int)color_pred * color) >> 5;
458  }
459  static WEBP_INLINE int8_t U32ToS8(uint32_t v) {
460    return (int8_t)(v & 0xff);
461  }
462  void VP8LTransformColor_C(const VP8LMultipliers* const m, uint32_t* data,
463                            int num_pixels) {
464    int i;
465    for (i = 0; i < num_pixels; ++i) {
466      const uint32_t argb = data[i];
467      const int8_t green = U32ToS8(argb >>  8);
468      const int8_t red   = U32ToS8(argb >> 16);
469      int new_red = red & 0xff;
470      int new_blue = argb & 0xff;
471      new_red -= ColorTransformDelta(m->green_to_red_, green);
472      new_red &= 0xff;
473      new_blue -= ColorTransformDelta(m->green_to_blue_, green);
474      new_blue -= ColorTransformDelta(m->red_to_blue_, red);
475      new_blue &= 0xff;
476      data[i] = (argb & 0xff00ff00u) | (new_red << 16) | (new_blue);
477    }
478  }
479  static WEBP_INLINE uint8_t TransformColorRed(uint8_t green_to_red,
480                                               uint32_t argb) {
481    const int8_t green = U32ToS8(argb >> 8);
482    int new_red = argb >> 16;
483    new_red -= ColorTransformDelta(green_to_red, green);
484    return (new_red & 0xff);
485  }
486  static WEBP_INLINE uint8_t TransformColorBlue(uint8_t green_to_blue,
487                                                uint8_t red_to_blue,
488                                                uint32_t argb) {
489    const int8_t green = U32ToS8(argb >>  8);
490    const int8_t red   = U32ToS8(argb >> 16);
491    uint8_t new_blue = argb & 0xff;
492    new_blue -= ColorTransformDelta(green_to_blue, green);
493    new_blue -= ColorTransformDelta(red_to_blue, red);
494    return (new_blue & 0xff);
495  }
496  void VP8LCollectColorRedTransforms_C(const uint32_t* argb, int stride,
497                                       int tile_width, int tile_height,
498                                       int green_to_red, int histo[]) {
499    while (tile_height-- > 0) {
500      int x;
501      for (x = 0; x < tile_width; ++x) {
502        ++histo[TransformColorRed((uint8_t)green_to_red, argb[x])];
503      }
504      argb += stride;
505    }
506  }
507  void VP8LCollectColorBlueTransforms_C(const uint32_t* argb, int stride,
508                                        int tile_width, int tile_height,
509                                        int green_to_blue, int red_to_blue,
510                                        int histo[]) {
511    while (tile_height-- > 0) {
512      int x;
513      for (x = 0; x < tile_width; ++x) {
514        ++histo[TransformColorBlue((uint8_t)green_to_blue, (uint8_t)red_to_blue,
515                                   argb[x])];
516      }
517      argb += stride;
518    }
519  }
520  static int VectorMismatch_C(const uint32_t* const array1,
521                              const uint32_t* const array2, int length) {
522    int match_len = 0;
523    while (match_len < length && array1[match_len] == array2[match_len]) {
524      ++match_len;
525    }
526    return match_len;
527  }
528  void VP8LBundleColorMap_C(const uint8_t* const row, int width, int xbits,
529                            uint32_t* dst) {
530    int x;
531    if (xbits > 0) {
532      const int bit_depth = 1 << (3 - xbits);
533      const int mask = (1 << xbits) - 1;
534      uint32_t code = 0xff000000;
535      for (x = 0; x < width; ++x) {
536        const int xsub = x & mask;
537        if (xsub == 0) {
538          code = 0xff000000;
539        }
540        code |= row[x] << (8 + bit_depth * xsub);
541        dst[x >> xbits] = code;
542      }
543    } else {
544      for (x = 0; x < width; ++x) dst[x] = 0xff000000 | (row[x] << 8);
545    }
546  }
547  static double ExtraCost_C(const uint32_t* population, int length) {
548    int i;
549    double cost = 0.;
550    for (i = 2; i < length - 2; ++i) cost += (i >> 1) * population[i + 2];
551    return cost;
552  }
553  static double ExtraCostCombined_C(const uint32_t* X, const uint32_t* Y,
554                                    int length) {
555    int i;
556    double cost = 0.;
557    for (i = 2; i < length - 2; ++i) {
558      const int xy = X[i + 2] + Y[i + 2];
559      cost += (i >> 1) * xy;
560    }
561    return cost;
562  }
563  static void AddVector_C(const uint32_t* a, const uint32_t* b, uint32_t* out,
564                          int size) {
565    int i;
566    for (i = 0; i < size; ++i) out[i] = a[i] + b[i];
567  }
568  static void AddVectorEq_C(const uint32_t* a, uint32_t* out, int size) {
569    int i;
570    for (i = 0; i < size; ++i) out[i] += a[i];
571  }
572  #define ADD(X, ARG, LEN) do {                                                  \
573    if (a->is_used_[X]) {                                                        \
574      if (b->is_used_[X]) {                                                      \
575        VP8LAddVector(a->ARG, b->ARG, out->ARG, (LEN));                          \
576      } else {                                                                   \
577        memcpy(&out->ARG[0], &a->ARG[0], (LEN) * sizeof(out->ARG[0]));           \
578      }                                                                          \
579    } else if (b->is_used_[X]) {                                                 \
580      memcpy(&out->ARG[0], &b->ARG[0], (LEN) * sizeof(out->ARG[0]));             \
581    } else {                                                                     \
582      memset(&out->ARG[0], 0, (LEN) * sizeof(out->ARG[0]));                      \
583    }                                                                            \
584  } while (0)
585  #define ADD_EQ(X, ARG, LEN) do {                                               \
586    if (a->is_used_[X]) {                                                        \
587      if (out->is_used_[X]) {                                                    \
588        VP8LAddVectorEq(a->ARG, out->ARG, (LEN));                                \
589      } else {                                                                   \
590        memcpy(&out->ARG[0], &a->ARG[0], (LEN) * sizeof(out->ARG[0]));           \
591      }                                                                          \
592    }                                                                            \
593  } while (0)
594  void VP8LHistogramAdd(const VP8LHistogram* const a,
595                        const VP8LHistogram* const b, VP8LHistogram* const out) {
596    int i;
597    const int literal_size = VP8LHistogramNumCodes(a->palette_code_bits_);
598    assert(a->palette_code_bits_ == b->palette_code_bits_);
599    if (b != out) {
600      ADD(0, literal_, literal_size);
601      ADD(1, red_, NUM_LITERAL_CODES);
602      ADD(2, blue_, NUM_LITERAL_CODES);
603      ADD(3, alpha_, NUM_LITERAL_CODES);
604      ADD(4, distance_, NUM_DISTANCE_CODES);
605      for (i = 0; i < 5; ++i) {
606        out->is_used_[i] = (a->is_used_[i] | b->is_used_[i]);
607      }
608    } else {
609      ADD_EQ(0, literal_, literal_size);
610      ADD_EQ(1, red_, NUM_LITERAL_CODES);
611      ADD_EQ(2, blue_, NUM_LITERAL_CODES);
612      ADD_EQ(3, alpha_, NUM_LITERAL_CODES);
613      ADD_EQ(4, distance_, NUM_DISTANCE_CODES);
614      for (i = 0; i < 5; ++i) out->is_used_[i] |= a->is_used_[i];
615    }
616  }
617  #undef ADD
618  #undef ADD_EQ
619  static WEBP_INLINE uint32_t Average2(uint32_t a0, uint32_t a1) {
620    return (((a0 ^ a1) & 0xfefefefeu) >> 1) + (a0 & a1);
621  }
622  static WEBP_INLINE uint32_t Average3(uint32_t a0, uint32_t a1, uint32_t a2) {
623    return Average2(Average2(a0, a2), a1);
624  }
625  static WEBP_INLINE uint32_t Average4(uint32_t a0, uint32_t a1,
626                                       uint32_t a2, uint32_t a3) {
627    return Average2(Average2(a0, a1), Average2(a2, a3));
628  }
629  static WEBP_INLINE uint32_t Clip255(uint32_t a) {
630    if (a < 256) {
631      return a;
632    }
<span onclick='openModal()' class='match'>633    return ~a >> 24;
634  }
635  static WEBP_INLINE int AddSubtractComponentFull(int a, int b, int c) {
636    return Clip255(a + b - c);
</span>637  }
638  static WEBP_INLINE uint32_t ClampedAddSubtractFull(uint32_t c0, uint32_t c1,
639                                                     uint32_t c2) {
640    const int a = AddSubtractComponentFull(c0 >> 24, c1 >> 24, c2 >> 24);
641    const int r = AddSubtractComponentFull((c0 >> 16) & 0xff,
642                                           (c1 >> 16) & 0xff,
643                                           (c2 >> 16) & 0xff);
644    const int g = AddSubtractComponentFull((c0 >> 8) & 0xff,
645                                           (c1 >> 8) & 0xff,
646                                           (c2 >> 8) & 0xff);
647    const int b = AddSubtractComponentFull(c0 & 0xff, c1 & 0xff, c2 & 0xff);
648    return ((uint32_t)a << 24) | (r << 16) | (g << 8) | b;
649  }
650  static WEBP_INLINE int AddSubtractComponentHalf(int a, int b) {
651    return Clip255(a + (a - b) / 2);
652  }
653  static WEBP_INLINE uint32_t ClampedAddSubtractHalf(uint32_t c0, uint32_t c1,
654                                                     uint32_t c2) {
655    const uint32_t ave = Average2(c0, c1);
656    const int a = AddSubtractComponentHalf(ave >> 24, c2 >> 24);
657    const int r = AddSubtractComponentHalf((ave >> 16) & 0xff, (c2 >> 16) & 0xff);
658    const int g = AddSubtractComponentHalf((ave >> 8) & 0xff, (c2 >> 8) & 0xff);
659    const int b = AddSubtractComponentHalf((ave >> 0) & 0xff, (c2 >> 0) & 0xff);
660    return ((uint32_t)a << 24) | (r << 16) | (g << 8) | b;
661  }
662  #if defined(__arm__) && \
663      (LOCAL_GCC_VERSION == 0x409 || LOCAL_GCC_VERSION == 0x408)
664  # define LOCAL_INLINE __attribute__ ((noinline))
665  #else
666  # define LOCAL_INLINE WEBP_INLINE
667  #endif
668  static LOCAL_INLINE int Sub3(int a, int b, int c) {
669    const int pb = b - c;
670    const int pa = a - c;
671    return abs(pb) - abs(pa);
672  }
673  #undef LOCAL_INLINE
674  static WEBP_INLINE uint32_t Select(uint32_t a, uint32_t b, uint32_t c) {
675    const int pa_minus_pb =
676        Sub3((a >> 24)       , (b >> 24)       , (c >> 24)       ) +
677        Sub3((a >> 16) & 0xff, (b >> 16) & 0xff, (c >> 16) & 0xff) +
678        Sub3((a >>  8) & 0xff, (b >>  8) & 0xff, (c >>  8) & 0xff) +
679        Sub3((a      ) & 0xff, (b      ) & 0xff, (c      ) & 0xff);
680    return (pa_minus_pb <= 0) ? a : b;
681  }
682  static uint32_t Predictor2(uint32_t left, const uint32_t* const top) {
683    (void)left;
684    return top[0];
685  }
686  static uint32_t Predictor3(uint32_t left, const uint32_t* const top) {
687    (void)left;
688    return top[1];
689  }
690  static uint32_t Predictor4(uint32_t left, const uint32_t* const top) {
691    (void)left;
692    return top[-1];
693  }
694  static uint32_t Predictor5(uint32_t left, const uint32_t* const top) {
695    const uint32_t pred = Average3(left, top[0], top[1]);
696    return pred;
697  }
698  static uint32_t Predictor6(uint32_t left, const uint32_t* const top) {
699    const uint32_t pred = Average2(left, top[-1]);
700    return pred;
701  }
702  static uint32_t Predictor7(uint32_t left, const uint32_t* const top) {
703    const uint32_t pred = Average2(left, top[0]);
704    return pred;
705  }
706  static uint32_t Predictor8(uint32_t left, const uint32_t* const top) {
707    const uint32_t pred = Average2(top[-1], top[0]);
708    (void)left;
709    return pred;
710  }
711  static uint32_t Predictor9(uint32_t left, const uint32_t* const top) {
712    const uint32_t pred = Average2(top[0], top[1]);
713    (void)left;
714    return pred;
715  }
716  static uint32_t Predictor10(uint32_t left, const uint32_t* const top) {
717    const uint32_t pred = Average4(left, top[-1], top[0], top[1]);
718    return pred;
719  }
720  static uint32_t Predictor11(uint32_t left, const uint32_t* const top) {
721    const uint32_t pred = Select(top[0], left, top[-1]);
722    return pred;
723  }
724  static uint32_t Predictor12(uint32_t left, const uint32_t* const top) {
725    const uint32_t pred = ClampedAddSubtractFull(left, top[0], top[-1]);
726    return pred;
727  }
728  static uint32_t Predictor13(uint32_t left, const uint32_t* const top) {
729    const uint32_t pred = ClampedAddSubtractHalf(left, top[0], top[-1]);
730    return pred;
731  }
732  static void PredictorSub0_C(const uint32_t* in, const uint32_t* upper,
733                              int num_pixels, uint32_t* out) {
734    int i;
735    for (i = 0; i < num_pixels; ++i) out[i] = VP8LSubPixels(in[i], ARGB_BLACK);
736    (void)upper;
737  }
738  static void PredictorSub1_C(const uint32_t* in, const uint32_t* upper,
739                              int num_pixels, uint32_t* out) {
740    int i;
741    for (i = 0; i < num_pixels; ++i) out[i] = VP8LSubPixels(in[i], in[i - 1]);
742    (void)upper;
743  }
744  GENERATE_PREDICTOR_SUB(Predictor2, PredictorSub2_C)
745  GENERATE_PREDICTOR_SUB(Predictor3, PredictorSub3_C)
746  GENERATE_PREDICTOR_SUB(Predictor4, PredictorSub4_C)
747  GENERATE_PREDICTOR_SUB(Predictor5, PredictorSub5_C)
748  GENERATE_PREDICTOR_SUB(Predictor6, PredictorSub6_C)
749  GENERATE_PREDICTOR_SUB(Predictor7, PredictorSub7_C)
750  GENERATE_PREDICTOR_SUB(Predictor8, PredictorSub8_C)
751  GENERATE_PREDICTOR_SUB(Predictor9, PredictorSub9_C)
752  GENERATE_PREDICTOR_SUB(Predictor10, PredictorSub10_C)
753  GENERATE_PREDICTOR_SUB(Predictor11, PredictorSub11_C)
754  GENERATE_PREDICTOR_SUB(Predictor12, PredictorSub12_C)
755  GENERATE_PREDICTOR_SUB(Predictor13, PredictorSub13_C)
756  VP8LProcessEncBlueAndRedFunc VP8LSubtractGreenFromBlueAndRed;
757  VP8LTransformColorFunc VP8LTransformColor;
758  VP8LCollectColorBlueTransformsFunc VP8LCollectColorBlueTransforms;
759  VP8LCollectColorRedTransformsFunc VP8LCollectColorRedTransforms;
760  VP8LFastLog2SlowFunc VP8LFastLog2Slow;
761  VP8LFastLog2SlowFunc VP8LFastSLog2Slow;
762  VP8LCostFunc VP8LExtraCost;
763  VP8LCostCombinedFunc VP8LExtraCostCombined;
764  VP8LCombinedShannonEntropyFunc VP8LCombinedShannonEntropy;
765  VP8LGetEntropyUnrefinedFunc VP8LGetEntropyUnrefined;
766  VP8LGetCombinedEntropyUnrefinedFunc VP8LGetCombinedEntropyUnrefined;
767  VP8LAddVectorFunc VP8LAddVector;
768  VP8LAddVectorEqFunc VP8LAddVectorEq;
769  VP8LVectorMismatchFunc VP8LVectorMismatch;
770  VP8LBundleColorMapFunc VP8LBundleColorMap;
771  VP8LPredictorAddSubFunc VP8LPredictorsSub[16];
772  VP8LPredictorAddSubFunc VP8LPredictorsSub_C[16];
773  extern void VP8LEncDspInitSSE2(void);
774  extern void VP8LEncDspInitSSE41(void);
775  extern void VP8LEncDspInitNEON(void);
776  extern void VP8LEncDspInitMIPS32(void);
777  extern void VP8LEncDspInitMIPSdspR2(void);
778  extern void VP8LEncDspInitMSA(void);
779  WEBP_DSP_INIT_FUNC(VP8LEncDspInit) {
780    VP8LDspInit();
781  #if !WEBP_NEON_OMIT_C_CODE
782    VP8LSubtractGreenFromBlueAndRed = VP8LSubtractGreenFromBlueAndRed_C;
783    VP8LTransformColor = VP8LTransformColor_C;
784  #endif
785    VP8LCollectColorBlueTransforms = VP8LCollectColorBlueTransforms_C;
786    VP8LCollectColorRedTransforms = VP8LCollectColorRedTransforms_C;
787    VP8LFastLog2Slow = FastLog2Slow_C;
788    VP8LFastSLog2Slow = FastSLog2Slow_C;
789    VP8LExtraCost = ExtraCost_C;
790    VP8LExtraCostCombined = ExtraCostCombined_C;
791    VP8LCombinedShannonEntropy = CombinedShannonEntropy_C;
792    VP8LGetEntropyUnrefined = GetEntropyUnrefined_C;
793    VP8LGetCombinedEntropyUnrefined = GetCombinedEntropyUnrefined_C;
794    VP8LAddVector = AddVector_C;
795    VP8LAddVectorEq = AddVectorEq_C;
796    VP8LVectorMismatch = VectorMismatch_C;
797    VP8LBundleColorMap = VP8LBundleColorMap_C;
798    VP8LPredictorsSub[0] = PredictorSub0_C;
799    VP8LPredictorsSub[1] = PredictorSub1_C;
800    VP8LPredictorsSub[2] = PredictorSub2_C;
801    VP8LPredictorsSub[3] = PredictorSub3_C;
802    VP8LPredictorsSub[4] = PredictorSub4_C;
803    VP8LPredictorsSub[5] = PredictorSub5_C;
804    VP8LPredictorsSub[6] = PredictorSub6_C;
805    VP8LPredictorsSub[7] = PredictorSub7_C;
806    VP8LPredictorsSub[8] = PredictorSub8_C;
807    VP8LPredictorsSub[9] = PredictorSub9_C;
808    VP8LPredictorsSub[10] = PredictorSub10_C;
809    VP8LPredictorsSub[11] = PredictorSub11_C;
810    VP8LPredictorsSub[12] = PredictorSub12_C;
811    VP8LPredictorsSub[13] = PredictorSub13_C;
812    VP8LPredictorsSub[14] = PredictorSub0_C;  
813    VP8LPredictorsSub[15] = PredictorSub0_C;
814    VP8LPredictorsSub_C[0] = PredictorSub0_C;
815    VP8LPredictorsSub_C[1] = PredictorSub1_C;
816    VP8LPredictorsSub_C[2] = PredictorSub2_C;
817    VP8LPredictorsSub_C[3] = PredictorSub3_C;
818    VP8LPredictorsSub_C[4] = PredictorSub4_C;
819    VP8LPredictorsSub_C[5] = PredictorSub5_C;
820    VP8LPredictorsSub_C[6] = PredictorSub6_C;
821    VP8LPredictorsSub_C[7] = PredictorSub7_C;
822    VP8LPredictorsSub_C[8] = PredictorSub8_C;
823    VP8LPredictorsSub_C[9] = PredictorSub9_C;
824    VP8LPredictorsSub_C[10] = PredictorSub10_C;
825    VP8LPredictorsSub_C[11] = PredictorSub11_C;
826    VP8LPredictorsSub_C[12] = PredictorSub12_C;
827    VP8LPredictorsSub_C[13] = PredictorSub13_C;
828    VP8LPredictorsSub_C[14] = PredictorSub0_C;  
829    VP8LPredictorsSub_C[15] = PredictorSub0_C;
830    if (VP8GetCPUInfo != NULL) {
831  #if defined(WEBP_USE_SSE2)
832      if (VP8GetCPUInfo(kSSE2)) {
833        VP8LEncDspInitSSE2();
834  #if defined(WEBP_USE_SSE41)
835        if (VP8GetCPUInfo(kSSE4_1)) {
836          VP8LEncDspInitSSE41();
837        }
838  #endif
839      }
840  #endif
841  #if defined(WEBP_USE_MIPS32)
842      if (VP8GetCPUInfo(kMIPS32)) {
843        VP8LEncDspInitMIPS32();
844      }
845  #endif
846  #if defined(WEBP_USE_MIPS_DSP_R2)
847      if (VP8GetCPUInfo(kMIPSdspR2)) {
848        VP8LEncDspInitMIPSdspR2();
849      }
850  #endif
851  #if defined(WEBP_USE_MSA)
852      if (VP8GetCPUInfo(kMSA)) {
853        VP8LEncDspInitMSA();
854      }
855  #endif
856    }
857  #if defined(WEBP_USE_NEON)
858    if (WEBP_NEON_OMIT_C_CODE ||
859        (VP8GetCPUInfo != NULL && VP8GetCPUInfo(kNEON))) {
860      VP8LEncDspInitNEON();
861    }
862  #endif
863    assert(VP8LSubtractGreenFromBlueAndRed != NULL);
864    assert(VP8LTransformColor != NULL);
865    assert(VP8LCollectColorBlueTransforms != NULL);
866    assert(VP8LCollectColorRedTransforms != NULL);
867    assert(VP8LFastLog2Slow != NULL);
868    assert(VP8LFastSLog2Slow != NULL);
869    assert(VP8LExtraCost != NULL);
870    assert(VP8LExtraCostCombined != NULL);
871    assert(VP8LCombinedShannonEntropy != NULL);
872    assert(VP8LGetEntropyUnrefined != NULL);
873    assert(VP8LGetCombinedEntropyUnrefined != NULL);
874    assert(VP8LAddVector != NULL);
875    assert(VP8LAddVectorEq != NULL);
876    assert(VP8LVectorMismatch != NULL);
877    assert(VP8LBundleColorMap != NULL);
878    assert(VP8LPredictorsSub[0] != NULL);
879    assert(VP8LPredictorsSub[1] != NULL);
880    assert(VP8LPredictorsSub[2] != NULL);
881    assert(VP8LPredictorsSub[3] != NULL);
882    assert(VP8LPredictorsSub[4] != NULL);
883    assert(VP8LPredictorsSub[5] != NULL);
884    assert(VP8LPredictorsSub[6] != NULL);
885    assert(VP8LPredictorsSub[7] != NULL);
886    assert(VP8LPredictorsSub[8] != NULL);
887    assert(VP8LPredictorsSub[9] != NULL);
888    assert(VP8LPredictorsSub[10] != NULL);
889    assert(VP8LPredictorsSub[11] != NULL);
890    assert(VP8LPredictorsSub[12] != NULL);
891    assert(VP8LPredictorsSub[13] != NULL);
892    assert(VP8LPredictorsSub[14] != NULL);
893    assert(VP8LPredictorsSub[15] != NULL);
894    assert(VP8LPredictorsSub_C[0] != NULL);
895    assert(VP8LPredictorsSub_C[1] != NULL);
896    assert(VP8LPredictorsSub_C[2] != NULL);
897    assert(VP8LPredictorsSub_C[3] != NULL);
898    assert(VP8LPredictorsSub_C[4] != NULL);
899    assert(VP8LPredictorsSub_C[5] != NULL);
900    assert(VP8LPredictorsSub_C[6] != NULL);
901    assert(VP8LPredictorsSub_C[7] != NULL);
902    assert(VP8LPredictorsSub_C[8] != NULL);
903    assert(VP8LPredictorsSub_C[9] != NULL);
904    assert(VP8LPredictorsSub_C[10] != NULL);
905    assert(VP8LPredictorsSub_C[11] != NULL);
906    assert(VP8LPredictorsSub_C[12] != NULL);
907    assert(VP8LPredictorsSub_C[13] != NULL);
908    assert(VP8LPredictorsSub_C[14] != NULL);
909    assert(VP8LPredictorsSub_C[15] != NULL);
910  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from PINRemoteImage-MDEwOlJlcG9zaXRvcnkzOTUzNzEwMw==-flat-anim_encode.c</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from PINRemoteImage-MDEwOlJlcG9zaXRvcnkzOTUzNzEwMw==-flat-lossless_enc.c</div>
                </div>
                <div class="column column_space"><pre><code>440    return GetSubRect(prev_canvas, curr_canvas, is_key_frame, is_first_frame,
441                      params->empty_rect_allowed_, 0, quality,
442                      &params->rect_lossy_, &params->sub_frame_lossy_);
443  }
444  static WEBP_INLINE int clip(int v, int min_v, int max_v) {
445    return (v < min_v) ? min_v : (v > max_v) ? max_v : v;
</pre></code></div>
                <div class="column column_space"><pre><code>633    return ~a >> 24;
634  }
635  static WEBP_INLINE int AddSubtractComponentFull(int a, int b, int c) {
636    return Clip255(a + b - c);
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    