
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 15, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>redis-MDEwOlJlcG9zaXRvcnkxMDgxMTA3MDY=-flat-lparser.c</h3>
            <pre><code>1  #include <string.h>
2  #define lparser_c
3  #define LUA_CORE
4  #include "lua.h"
5  #include "lcode.h"
6  #include "ldebug.h"
7  #include "ldo.h"
8  #include "lfunc.h"
9  #include "llex.h"
10  #include "lmem.h"
11  #include "lobject.h"
12  #include "lopcodes.h"
13  #include "lparser.h"
14  #include "lstate.h"
15  #include "lstring.h"
16  #include "ltable.h"
17  #define hasmultret(k)		((k) == VCALL || (k) == VVARARG)
18  #define getlocvar(fs, i)	((fs)->f->locvars[(fs)->actvar[i]])
19  #define luaY_checklimit(fs,v,l,m)	if ((v)>(l)) errorlimit(fs,l,m)
20  typedef struct BlockCnt {
21    struct BlockCnt *previous;  &bsol;* chain */
22    int breaklist;  &bsol;* list of jumps out of this loop */
23    lu_byte nactvar;  &bsol;* # active locals outside the breakable structure */
24    lu_byte upval;  &bsol;* true if some variable in the block is an upvalue */
25    lu_byte isbreakable;  &bsol;* true if `block' is a loop */
26  } BlockCnt;
27  static void chunk (LexState *ls);
28  static void expr (LexState *ls, expdesc *v);
29  static void anchor_token (LexState *ls) {
30    if (ls->t.token == TK_NAME || ls->t.token == TK_STRING) {
31      TString *ts = ls->t.seminfo.ts;
32      luaX_newstring(ls, getstr(ts), ts->tsv.len);
33    }
34  }
35  static void error_expected (LexState *ls, int token) {
36    luaX_syntaxerror(ls,
37        luaO_pushfstring(ls->L, LUA_QS " expected", luaX_token2str(ls, token)));
38  }
39  static void errorlimit (FuncState *fs, int limit, const char *what) {
40    const char *msg = (fs->f->linedefined == 0) ?
41      luaO_pushfstring(fs->L, "main function has more than %d %s", limit, what) :
42      luaO_pushfstring(fs->L, "function at line %d has more than %d %s",
43                              fs->f->linedefined, limit, what);
44    luaX_lexerror(fs->ls, msg, 0);
45  }
46  static int testnext (LexState *ls, int c) {
47    if (ls->t.token == c) {
48      luaX_next(ls);
49      return 1;
50    }
51    else return 0;
52  }
53  static void check (LexState *ls, int c) {
54    if (ls->t.token != c)
55      error_expected(ls, c);
56  }
57  static void checknext (LexState *ls, int c) {
58    check(ls, c);
59    luaX_next(ls);
60  }
61  #define check_condition(ls,c,msg)	{ if (!(c)) luaX_syntaxerror(ls, msg); }
62  static void check_match (LexState *ls, int what, int who, int where) {
63    if (!testnext(ls, what)) {
64      if (where == ls->linenumber)
65        error_expected(ls, what);
66      else {
67        luaX_syntaxerror(ls, luaO_pushfstring(ls->L,
68               LUA_QS " expected (to close " LUA_QS " at line %d)",
69                luaX_token2str(ls, what), luaX_token2str(ls, who), where));
70      }
71    }
72  }
73  static TString *str_checkname (LexState *ls) {
74    TString *ts;
75    check(ls, TK_NAME);
76    ts = ls->t.seminfo.ts;
77    luaX_next(ls);
78    return ts;
79  }
80  static void init_exp (expdesc *e, expkind k, int i) {
81    e->f = e->t = NO_JUMP;
82    e->k = k;
83    e->u.s.info = i;
84  }
85  static void codestring (LexState *ls, expdesc *e, TString *s) {
86    init_exp(e, VK, luaK_stringK(ls->fs, s));
87  }
88  static void checkname(LexState *ls, expdesc *e) {
89    codestring(ls, e, str_checkname(ls));
90  }
91  static int registerlocalvar (LexState *ls, TString *varname) {
92    FuncState *fs = ls->fs;
93    Proto *f = fs->f;
94    int oldsize = f->sizelocvars;
95    luaM_growvector(ls->L, f->locvars, fs->nlocvars, f->sizelocvars,
96                    LocVar, SHRT_MAX, "too many local variables");
97    while (oldsize < f->sizelocvars) f->locvars[oldsize++].varname = NULL;
98    f->locvars[fs->nlocvars].varname = varname;
99    luaC_objbarrier(ls->L, f, varname);
100    return fs->nlocvars++;
101  }
102  #define new_localvarliteral(ls,v,n) \
103    new_localvar(ls, luaX_newstring(ls, "" v, (sizeof(v)/sizeof(char))-1), n)
104  static void new_localvar (LexState *ls, TString *name, int n) {
105    FuncState *fs = ls->fs;
106    luaY_checklimit(fs, fs->nactvar+n+1, LUAI_MAXVARS, "local variables");
107    fs->actvar[fs->nactvar+n] = cast(unsigned short, registerlocalvar(ls, name));
108  }
109  static void adjustlocalvars (LexState *ls, int nvars) {
110    FuncState *fs = ls->fs;
111    fs->nactvar = cast_byte(fs->nactvar + nvars);
112    for (; nvars; nvars--) {
113      getlocvar(fs, fs->nactvar - nvars).startpc = fs->pc;
114    }
115  }
116  static void removevars (LexState *ls, int tolevel) {
117    FuncState *fs = ls->fs;
118    while (fs->nactvar > tolevel)
119      getlocvar(fs, --fs->nactvar).endpc = fs->pc;
120  }
121  static int indexupvalue (FuncState *fs, TString *name, expdesc *v) {
122    int i;
123    Proto *f = fs->f;
124    int oldsize = f->sizeupvalues;
125    for (i=0; i<f->nups; i++) {
126      if (fs->upvalues[i].k == v->k && fs->upvalues[i].info == v->u.s.info) {
127        lua_assert(f->upvalues[i] == name);
128        return i;
129      }
130    }
131    luaY_checklimit(fs, f->nups + 1, LUAI_MAXUPVALUES, "upvalues");
132    luaM_growvector(fs->L, f->upvalues, f->nups, f->sizeupvalues,
133                    TString *, MAX_INT, "");
134    while (oldsize < f->sizeupvalues) f->upvalues[oldsize++] = NULL;
135    f->upvalues[f->nups] = name;
136    luaC_objbarrier(fs->L, f, name);
137    lua_assert(v->k == VLOCAL || v->k == VUPVAL);
138    fs->upvalues[f->nups].k = cast_byte(v->k);
139    fs->upvalues[f->nups].info = cast_byte(v->u.s.info);
140    return f->nups++;
141  }
142  static int searchvar (FuncState *fs, TString *n) {
143    int i;
144    for (i=fs->nactvar-1; i >= 0; i--) {
145      if (n == getlocvar(fs, i).varname)
146        return i;
147    }
148    return -1;  &bsol;* not found */
149  }
150  static void markupval (FuncState *fs, int level) {
151    BlockCnt *bl = fs->bl;
152    while (bl && bl->nactvar > level) bl = bl->previous;
153    if (bl) bl->upval = 1;
154  }
155  static int singlevaraux (FuncState *fs, TString *n, expdesc *var, int base) {
156    if (fs == NULL) {  &bsol;* no more levels? */
157      init_exp(var, VGLOBAL, NO_REG);  &bsol;* default is global variable */
158      return VGLOBAL;
159    }
160    else {
161      int v = searchvar(fs, n);  &bsol;* look up at current level */
162      if (v >= 0) {
163        init_exp(var, VLOCAL, v);
164        if (!base)
165          markupval(fs, v);  &bsol;* local will be used as an upval */
166        return VLOCAL;
167      }
168      else {  &bsol;* not found at current level; try upper one */
169        if (singlevaraux(fs->prev, n, var, 0) == VGLOBAL)
170          return VGLOBAL;
171        var->u.s.info = indexupvalue(fs, n, var);  &bsol;* else was LOCAL or UPVAL */
172        var->k = VUPVAL;  &bsol;* upvalue in this level */
173        return VUPVAL;
174      }
175    }
176  }
177  static void singlevar (LexState *ls, expdesc *var) {
178    TString *varname = str_checkname(ls);
179    FuncState *fs = ls->fs;
180    if (singlevaraux(fs, varname, var, 1) == VGLOBAL)
181      var->u.s.info = luaK_stringK(fs, varname);  &bsol;* info points to global name */
182  }
183  static void adjust_assign (LexState *ls, int nvars, int nexps, expdesc *e) {
184    FuncState *fs = ls->fs;
185    int extra = nvars - nexps;
186    if (hasmultret(e->k)) {
187      extra++;  &bsol;* includes call itself */
188      if (extra < 0) extra = 0;
189      luaK_setreturns(fs, e, extra);  &bsol;* last exp. provides the difference */
190      if (extra > 1) luaK_reserveregs(fs, extra-1);
191    }
192    else {
193      if (e->k != VVOID) luaK_exp2nextreg(fs, e);  &bsol;* close last expression */
194      if (extra > 0) {
195        int reg = fs->freereg;
196        luaK_reserveregs(fs, extra);
197        luaK_nil(fs, reg, extra);
198      }
199    }
200  }
201  static void enterlevel (LexState *ls) {
202    if (++ls->L->nCcalls > LUAI_MAXCCALLS)
203  	luaX_lexerror(ls, "chunk has too many syntax levels", 0);
204  }
205  #define leavelevel(ls)	((ls)->L->nCcalls--)
206  static void enterblock (FuncState *fs, BlockCnt *bl, lu_byte isbreakable) {
207    bl->breaklist = NO_JUMP;
208    bl->isbreakable = isbreakable;
209    bl->nactvar = fs->nactvar;
210    bl->upval = 0;
211    bl->previous = fs->bl;
212    fs->bl = bl;
213    lua_assert(fs->freereg == fs->nactvar);
214  }
215  static void leaveblock (FuncState *fs) {
216    BlockCnt *bl = fs->bl;
217    fs->bl = bl->previous;
218    removevars(fs->ls, bl->nactvar);
219    if (bl->upval)
220      luaK_codeABC(fs, OP_CLOSE, bl->nactvar, 0, 0);
221    lua_assert(!bl->isbreakable || !bl->upval);
222    lua_assert(bl->nactvar == fs->nactvar);
223    fs->freereg = fs->nactvar;  &bsol;* free registers */
224    luaK_patchtohere(fs, bl->breaklist);
225  }
226  static void pushclosure (LexState *ls, FuncState *func, expdesc *v) {
227    FuncState *fs = ls->fs;
228    Proto *f = fs->f;
229    int oldsize = f->sizep;
230    int i;
231    luaM_growvector(ls->L, f->p, fs->np, f->sizep, Proto *,
232                    MAXARG_Bx, "constant table overflow");
233    while (oldsize < f->sizep) f->p[oldsize++] = NULL;
234    f->p[fs->np++] = func->f;
235    luaC_objbarrier(ls->L, f, func->f);
236    init_exp(v, VRELOCABLE, luaK_codeABx(fs, OP_CLOSURE, 0, fs->np-1));
237    for (i=0; i<func->f->nups; i++) {
238      OpCode o = (func->upvalues[i].k == VLOCAL) ? OP_MOVE : OP_GETUPVAL;
239      luaK_codeABC(fs, o, 0, func->upvalues[i].info, 0);
240    }
241  }
242  static void open_func (LexState *ls, FuncState *fs) {
243    lua_State *L = ls->L;
244    Proto *f = luaF_newproto(L);
245    fs->f = f;
246    fs->prev = ls->fs;  &bsol;* linked list of funcstates */
247    fs->ls = ls;
248    fs->L = L;
249    ls->fs = fs;
250    fs->pc = 0;
251    fs->lasttarget = -1;
252    fs->jpc = NO_JUMP;
253    fs->freereg = 0;
254    fs->nk = 0;
255    fs->np = 0;
256    fs->nlocvars = 0;
257    fs->nactvar = 0;
258    fs->bl = NULL;
259    f->source = ls->source;
260    f->maxstacksize = 2;  &bsol;* registers 0/1 are always valid */
261    fs->h = luaH_new(L, 0, 0);
262    sethvalue2s(L, L->top, fs->h);
263    incr_top(L);
264    setptvalue2s(L, L->top, f);
265    incr_top(L);
266  }
267  static void close_func (LexState *ls) {
268    lua_State *L = ls->L;
269    FuncState *fs = ls->fs;
270    Proto *f = fs->f;
271    removevars(ls, 0);
272    luaK_ret(fs, 0, 0);  &bsol;* final return */
273    luaM_reallocvector(L, f->code, f->sizecode, fs->pc, Instruction);
274    f->sizecode = fs->pc;
275    luaM_reallocvector(L, f->lineinfo, f->sizelineinfo, fs->pc, int);
276    f->sizelineinfo = fs->pc;
277    luaM_reallocvector(L, f->k, f->sizek, fs->nk, TValue);
278    f->sizek = fs->nk;
279    luaM_reallocvector(L, f->p, f->sizep, fs->np, Proto *);
280    f->sizep = fs->np;
281    luaM_reallocvector(L, f->locvars, f->sizelocvars, fs->nlocvars, LocVar);
282    f->sizelocvars = fs->nlocvars;
283    luaM_reallocvector(L, f->upvalues, f->sizeupvalues, f->nups, TString *);
284    f->sizeupvalues = f->nups;
285    lua_assert(luaG_checkcode(f));
286    lua_assert(fs->bl == NULL);
287    ls->fs = fs->prev;
288    if (fs) anchor_token(ls);
289    L->top -= 2;  &bsol;* remove table and prototype from the stack */
290  }
291  Proto *luaY_parser (lua_State *L, ZIO *z, Mbuffer *buff, const char *name) {
292    struct LexState lexstate;
293    struct FuncState funcstate;
294    lexstate.buff = buff;
295    luaX_setinput(L, &lexstate, z, luaS_new(L, name));
296    open_func(&lexstate, &funcstate);
297    funcstate.f->is_vararg = VARARG_ISVARARG;  &bsol;* main func. is always vararg */
298    luaX_next(&lexstate);  &bsol;* read first token */
299    chunk(&lexstate);
300    check(&lexstate, TK_EOS);
301    close_func(&lexstate);
302    lua_assert(funcstate.prev == NULL);
303    lua_assert(funcstate.f->nups == 0);
304    lua_assert(lexstate.fs == NULL);
305    return funcstate.f;
306  }
307  static void field (LexState *ls, expdesc *v) {
308    FuncState *fs = ls->fs;
309    expdesc key;
310    luaK_exp2anyreg(fs, v);
311    luaX_next(ls);  &bsol;* skip the dot or colon */
312    checkname(ls, &key);
313    luaK_indexed(fs, v, &key);
314  }
315  static void yindex (LexState *ls, expdesc *v) {
316    luaX_next(ls);  &bsol;* skip the '[' */
317    expr(ls, v);
318    luaK_exp2val(ls->fs, v);
319    checknext(ls, ']');
320  }
321  struct ConsControl {
322    expdesc v;  &bsol;* last list item read */
323    expdesc *t;  &bsol;* table descriptor */
324    int nh;  &bsol;* total number of `record' elements */
325    int na;  &bsol;* total number of array elements */
326    int tostore;  &bsol;* number of array elements pending to be stored */
327  };
328  static void recfield (LexState *ls, struct ConsControl *cc) {
329    FuncState *fs = ls->fs;
330    int reg = ls->fs->freereg;
331    expdesc key, val;
332    int rkkey;
333    if (ls->t.token == TK_NAME) {
334      luaY_checklimit(fs, cc->nh, MAX_INT, "items in a constructor");
335      checkname(ls, &key);
336    }
337    else  &bsol;* ls->t.token == '[' */
338      yindex(ls, &key);
339    cc->nh++;
340    checknext(ls, '=');
341    rkkey = luaK_exp2RK(fs, &key);
342    expr(ls, &val);
343    luaK_codeABC(fs, OP_SETTABLE, cc->t->u.s.info, rkkey, luaK_exp2RK(fs, &val));
344    fs->freereg = reg;  &bsol;* free registers */
345  }
346  static void closelistfield (FuncState *fs, struct ConsControl *cc) {
347    if (cc->v.k == VVOID) return;  &bsol;* there is no list item */
348    luaK_exp2nextreg(fs, &cc->v);
349    cc->v.k = VVOID;
350    if (cc->tostore == LFIELDS_PER_FLUSH) {
351      luaK_setlist(fs, cc->t->u.s.info, cc->na, cc->tostore);  &bsol;* flush */
352      cc->tostore = 0;  &bsol;* no more items pending */
353    }
354  }
355  static void lastlistfield (FuncState *fs, struct ConsControl *cc) {
356    if (cc->tostore == 0) return;
357    if (hasmultret(cc->v.k)) {
358      luaK_setmultret(fs, &cc->v);
359      luaK_setlist(fs, cc->t->u.s.info, cc->na, LUA_MULTRET);
360      cc->na--;  &bsol;* do not count last expression (unknown number of elements) */
361    }
362    else {
363      if (cc->v.k != VVOID)
364        luaK_exp2nextreg(fs, &cc->v);
365      luaK_setlist(fs, cc->t->u.s.info, cc->na, cc->tostore);
366    }
367  }
368  static void listfield (LexState *ls, struct ConsControl *cc) {
369    expr(ls, &cc->v);
370    luaY_checklimit(ls->fs, cc->na, MAX_INT, "items in a constructor");
371    cc->na++;
372    cc->tostore++;
373  }
374  static void constructor (LexState *ls, expdesc *t) {
375    FuncState *fs = ls->fs;
376    int line = ls->linenumber;
377    int pc = luaK_codeABC(fs, OP_NEWTABLE, 0, 0, 0);
378    struct ConsControl cc;
379    cc.na = cc.nh = cc.tostore = 0;
380    cc.t = t;
381    init_exp(t, VRELOCABLE, pc);
382    init_exp(&cc.v, VVOID, 0);  &bsol;* no value (yet) */
383    luaK_exp2nextreg(ls->fs, t);  &bsol;* fix it at stack top (for gc) */
384    checknext(ls, '{');
385    do {
386      lua_assert(cc.v.k == VVOID || cc.tostore > 0);
387      if (ls->t.token == '}') break;
388      closelistfield(fs, &cc);
389      switch(ls->t.token) {
390        case TK_NAME: {  &bsol;* may be listfields or recfields */
391          luaX_lookahead(ls);
392          if (ls->lookahead.token != '=')  &bsol;* expression? */
393            listfield(ls, &cc);
394          else
395            recfield(ls, &cc);
396          break;
397        }
398        case '[': {  &bsol;* constructor_item -> recfield */
399          recfield(ls, &cc);
400          break;
401        }
402        default: {  &bsol;* constructor_part -> listfield */
403          listfield(ls, &cc);
404          break;
405        }
406      }
407    } while (testnext(ls, ',') || testnext(ls, ';'));
408    check_match(ls, '}', '{', line);
409    lastlistfield(fs, &cc);
410    SETARG_B(fs->f->code[pc], luaO_int2fb(cc.na)); &bsol;* set initial array size */
411    SETARG_C(fs->f->code[pc], luaO_int2fb(cc.nh));  &bsol;* set initial table size */
412  }
413  static void parlist (LexState *ls) {
414    FuncState *fs = ls->fs;
415    Proto *f = fs->f;
416    int nparams = 0;
417    f->is_vararg = 0;
418    if (ls->t.token != ')') {  &bsol;* is `parlist' not empty? */
419      do {
420        switch (ls->t.token) {
421          case TK_NAME: {  &bsol;* param -> NAME */
422            new_localvar(ls, str_checkname(ls), nparams++);
423            break;
424          }
425          case TK_DOTS: {  &bsol;* param -> `...' */
426            luaX_next(ls);
427  #if defined(LUA_COMPAT_VARARG)
428            new_localvarliteral(ls, "arg", nparams++);
429            f->is_vararg = VARARG_HASARG | VARARG_NEEDSARG;
430  #endif
431            f->is_vararg |= VARARG_ISVARARG;
432            break;
433          }
434          default: luaX_syntaxerror(ls, "<name> or " LUA_QL("...") " expected");
435        }
436      } while (!f->is_vararg && testnext(ls, ','));
437    }
438    adjustlocalvars(ls, nparams);
439    f->numparams = cast_byte(fs->nactvar - (f->is_vararg & VARARG_HASARG));
440    luaK_reserveregs(fs, fs->nactvar);  &bsol;* reserve register for parameters */
441  }
442  static void body (LexState *ls, expdesc *e, int needself, int line) {
443    FuncState new_fs;
444    open_func(ls, &new_fs);
445    new_fs.f->linedefined = line;
446    checknext(ls, '(');
447    if (needself) {
448      new_localvarliteral(ls, "self", 0);
449      adjustlocalvars(ls, 1);
450    }
451    parlist(ls);
452    checknext(ls, ')');
453    chunk(ls);
454    new_fs.f->lastlinedefined = ls->linenumber;
455    check_match(ls, TK_END, TK_FUNCTION, line);
456    close_func(ls);
457    pushclosure(ls, &new_fs, e);
458  }
459  static int explist1 (LexState *ls, expdesc *v) {
<span onclick='openModal()' class='match'>460    int n = 1;  &bsol;* at least one expression */
461    expr(ls, v);
</span>462    while (testnext(ls, ',')) {
463      luaK_exp2nextreg(ls->fs, v);
464      expr(ls, v);
465      n++;
466    }
467    return n;
468  }
469  static void funcargs (LexState *ls, expdesc *f) {
470    FuncState *fs = ls->fs;
471    expdesc args;
472    int base, nparams;
473    int line = ls->linenumber;
474    switch (ls->t.token) {
475      case '(': {  &bsol;* funcargs -> `(' [ explist1 ] `)' */
476        if (line != ls->lastline)
477          luaX_syntaxerror(ls,"ambiguous syntax (function call x new statement)");
478        luaX_next(ls);
479        if (ls->t.token == ')')  &bsol;* arg list is empty? */
480          args.k = VVOID;
481        else {
482          explist1(ls, &args);
483          luaK_setmultret(fs, &args);
484        }
485        check_match(ls, ')', '(', line);
486        break;
487      }
488      case '{': {  &bsol;* funcargs -> constructor */
489        constructor(ls, &args);
490        break;
491      }
492      case TK_STRING: {  &bsol;* funcargs -> STRING */
493        codestring(ls, &args, ls->t.seminfo.ts);
494        luaX_next(ls);  &bsol;* must use `seminfo' before `next' */
495        break;
496      }
497      default: {
498        luaX_syntaxerror(ls, "function arguments expected");
499        return;
500      }
501    }
502    lua_assert(f->k == VNONRELOC);
503    base = f->u.s.info;  &bsol;* base register for call */
504    if (hasmultret(args.k))
505      nparams = LUA_MULTRET;  &bsol;* open call */
506    else {
507      if (args.k != VVOID)
508        luaK_exp2nextreg(fs, &args);  &bsol;* close last argument */
509      nparams = fs->freereg - (base+1);
510    }
511    init_exp(f, VCALL, luaK_codeABC(fs, OP_CALL, base, nparams+1, 2));
512    luaK_fixline(fs, line);
513    fs->freereg = base+1;  &bsol;* call remove function and arguments and leaves
514                              (unless changed) one result */
515  }
516  static void prefixexp (LexState *ls, expdesc *v) {
517    switch (ls->t.token) {
518      case '(': {
519        int line = ls->linenumber;
520        luaX_next(ls);
521        expr(ls, v);
522        check_match(ls, ')', '(', line);
523        luaK_dischargevars(ls->fs, v);
524        return;
525      }
526      case TK_NAME: {
527        singlevar(ls, v);
528        return;
529      }
530      default: {
531        luaX_syntaxerror(ls, "unexpected symbol");
532        return;
533      }
534    }
535  }
536  static void primaryexp (LexState *ls, expdesc *v) {
537    FuncState *fs = ls->fs;
538    prefixexp(ls, v);
539    for (;;) {
540      switch (ls->t.token) {
541        case '.': {  &bsol;* field */
542          field(ls, v);
543          break;
544        }
545        case '[': {  &bsol;* `[' exp1 `]' */
546          expdesc key;
547          luaK_exp2anyreg(fs, v);
548          yindex(ls, &key);
549          luaK_indexed(fs, v, &key);
550          break;
551        }
552        case ':': {  &bsol;* `:' NAME funcargs */
553          expdesc key;
554          luaX_next(ls);
555          checkname(ls, &key);
556          luaK_self(fs, v, &key);
557          funcargs(ls, v);
558          break;
559        }
560        case '(': case TK_STRING: case '{': {  &bsol;* funcargs */
561          luaK_exp2nextreg(fs, v);
562          funcargs(ls, v);
563          break;
564        }
565        default: return;
566      }
567    }
568  }
569  static void simpleexp (LexState *ls, expdesc *v) {
570    switch (ls->t.token) {
571      case TK_NUMBER: {
572        init_exp(v, VKNUM, 0);
573        v->u.nval = ls->t.seminfo.r;
574        break;
575      }
576      case TK_STRING: {
577        codestring(ls, v, ls->t.seminfo.ts);
578        break;
579      }
580      case TK_NIL: {
581        init_exp(v, VNIL, 0);
582        break;
583      }
584      case TK_TRUE: {
585        init_exp(v, VTRUE, 0);
586        break;
587      }
588      case TK_FALSE: {
589        init_exp(v, VFALSE, 0);
590        break;
591      }
592      case TK_DOTS: {  &bsol;* vararg */
593        FuncState *fs = ls->fs;
594        check_condition(ls, fs->f->is_vararg,
595                        "cannot use " LUA_QL("...") " outside a vararg function");
596        fs->f->is_vararg &= ~VARARG_NEEDSARG;  &bsol;* don't need 'arg' */
597        init_exp(v, VVARARG, luaK_codeABC(fs, OP_VARARG, 0, 1, 0));
598        break;
599      }
600      case '{': {  &bsol;* constructor */
601        constructor(ls, v);
602        return;
603      }
604      case TK_FUNCTION: {
605        luaX_next(ls);
606        body(ls, v, 0, ls->linenumber);
607        return;
608      }
609      default: {
610        primaryexp(ls, v);
611        return;
612      }
613    }
614    luaX_next(ls);
615  }
616  static UnOpr getunopr (int op) {
617    switch (op) {
618      case TK_NOT: return OPR_NOT;
619      case '-': return OPR_MINUS;
620      case '#': return OPR_LEN;
621      default: return OPR_NOUNOPR;
622    }
623  }
624  static BinOpr getbinopr (int op) {
625    switch (op) {
626      case '+': return OPR_ADD;
627      case '-': return OPR_SUB;
628      case '*': return OPR_MUL;
629      case '/': return OPR_DIV;
630      case '%': return OPR_MOD;
631      case '^': return OPR_POW;
632      case TK_CONCAT: return OPR_CONCAT;
633      case TK_NE: return OPR_NE;
634      case TK_EQ: return OPR_EQ;
635      case '<': return OPR_LT;
636      case TK_LE: return OPR_LE;
637      case '>': return OPR_GT;
638      case TK_GE: return OPR_GE;
639      case TK_AND: return OPR_AND;
640      case TK_OR: return OPR_OR;
641      default: return OPR_NOBINOPR;
642    }
643  }
644  static const struct {
645    lu_byte left;  &bsol;* left priority for each binary operator */
646    lu_byte right; &bsol;* right priority */
647  } priority[] = {  &bsol;* ORDER OPR */
648     {6, 6}, {6, 6}, {7, 7}, {7, 7}, {7, 7},  &bsol;* `+' `-' `/' `%' */
649     {10, 9}, {5, 4},                 &bsol;* power and concat (right associative) */
650     {3, 3}, {3, 3},                  &bsol;* equality and inequality */
651     {3, 3}, {3, 3}, {3, 3}, {3, 3},  &bsol;* order */
652     {2, 2}, {1, 1}                   &bsol;* logical (and/or) */
653  };
654  #define UNARY_PRIORITY	8  &bsol;* priority for unary operators */
655  static BinOpr subexpr (LexState *ls, expdesc *v, unsigned int limit) {
656    BinOpr op;
657    UnOpr uop;
658    enterlevel(ls);
659    uop = getunopr(ls->t.token);
660    if (uop != OPR_NOUNOPR) {
661      luaX_next(ls);
662      subexpr(ls, v, UNARY_PRIORITY);
663      luaK_prefix(ls->fs, uop, v);
664    }
665    else simpleexp(ls, v);
666    op = getbinopr(ls->t.token);
667    while (op != OPR_NOBINOPR && priority[op].left > limit) {
668      expdesc v2;
669      BinOpr nextop;
670      luaX_next(ls);
671      luaK_infix(ls->fs, op, v);
672      nextop = subexpr(ls, &v2, priority[op].right);
673      luaK_posfix(ls->fs, op, v, &v2);
674      op = nextop;
675    }
676    leavelevel(ls);
677    return op;  &bsol;* return first untreated operator */
678  }
679  static void expr (LexState *ls, expdesc *v) {
680    subexpr(ls, v, 0);
681  }
682  static int block_follow (int token) {
683    switch (token) {
684      case TK_ELSE: case TK_ELSEIF: case TK_END:
685      case TK_UNTIL: case TK_EOS:
686        return 1;
687      default: return 0;
688    }
689  }
690  static void block (LexState *ls) {
691    FuncState *fs = ls->fs;
692    BlockCnt bl;
693    enterblock(fs, &bl, 0);
694    chunk(ls);
695    lua_assert(bl.breaklist == NO_JUMP);
696    leaveblock(fs);
697  }
698  struct LHS_assign {
699    struct LHS_assign *prev;
700    expdesc v;  &bsol;* variable (global, local, upvalue, or indexed) */
701  };
702  static void check_conflict (LexState *ls, struct LHS_assign *lh, expdesc *v) {
703    FuncState *fs = ls->fs;
704    int extra = fs->freereg;  &bsol;* eventual position to save local variable */
705    int conflict = 0;
706    for (; lh; lh = lh->prev) {
707      if (lh->v.k == VINDEXED) {
708        if (lh->v.u.s.info == v->u.s.info) {  &bsol;* conflict? */
709          conflict = 1;
710          lh->v.u.s.info = extra;  &bsol;* previous assignment will use safe copy */
711        }
712        if (lh->v.u.s.aux == v->u.s.info) {  &bsol;* conflict? */
713          conflict = 1;
714          lh->v.u.s.aux = extra;  &bsol;* previous assignment will use safe copy */
715        }
716      }
717    }
718    if (conflict) {
719      luaK_codeABC(fs, OP_MOVE, fs->freereg, v->u.s.info, 0);  &bsol;* make copy */
720      luaK_reserveregs(fs, 1);
721    }
722  }
723  static void assignment (LexState *ls, struct LHS_assign *lh, int nvars) {
724    expdesc e;
725    check_condition(ls, VLOCAL <= lh->v.k && lh->v.k <= VINDEXED,
726                        "syntax error");
727    if (testnext(ls, ',')) {  &bsol;* assignment -> `,' primaryexp assignment */
728      struct LHS_assign nv;
729      nv.prev = lh;
730      primaryexp(ls, &nv.v);
731      if (nv.v.k == VLOCAL)
732        check_conflict(ls, lh, &nv.v);
733      luaY_checklimit(ls->fs, nvars, LUAI_MAXCCALLS - ls->L->nCcalls,
734                      "variables in assignment");
735      assignment(ls, &nv, nvars+1);
736    }
737    else {  &bsol;* assignment -> `=' explist1 */
738      int nexps;
739      checknext(ls, '=');
740      nexps = explist1(ls, &e);
741      if (nexps != nvars) {
742        adjust_assign(ls, nvars, nexps, &e);
743        if (nexps > nvars)
744          ls->fs->freereg -= nexps - nvars;  &bsol;* remove extra values */
745      }
746      else {
747        luaK_setoneret(ls->fs, &e);  &bsol;* close last expression */
748        luaK_storevar(ls->fs, &lh->v, &e);
749        return;  &bsol;* avoid default */
750      }
751    }
752    init_exp(&e, VNONRELOC, ls->fs->freereg-1);  &bsol;* default assignment */
753    luaK_storevar(ls->fs, &lh->v, &e);
754  }
755  static int cond (LexState *ls) {
756    expdesc v;
757    expr(ls, &v);  &bsol;* read condition */
758    if (v.k == VNIL) v.k = VFALSE;  &bsol;* `falses' are all equal here */
759    luaK_goiftrue(ls->fs, &v);
760    return v.f;
761  }
762  static void breakstat (LexState *ls) {
763    FuncState *fs = ls->fs;
764    BlockCnt *bl = fs->bl;
765    int upval = 0;
766    while (bl && !bl->isbreakable) {
767      upval |= bl->upval;
768      bl = bl->previous;
769    }
770    if (!bl)
771      luaX_syntaxerror(ls, "no loop to break");
772    if (upval)
773      luaK_codeABC(fs, OP_CLOSE, bl->nactvar, 0, 0);
774    luaK_concat(fs, &bl->breaklist, luaK_jump(fs));
775  }
776  static void whilestat (LexState *ls, int line) {
777    FuncState *fs = ls->fs;
778    int whileinit;
779    int condexit;
780    BlockCnt bl;
781    luaX_next(ls);  &bsol;* skip WHILE */
782    whileinit = luaK_getlabel(fs);
783    condexit = cond(ls);
784    enterblock(fs, &bl, 1);
785    checknext(ls, TK_DO);
786    block(ls);
787    luaK_patchlist(fs, luaK_jump(fs), whileinit);
788    check_match(ls, TK_END, TK_WHILE, line);
789    leaveblock(fs);
790    luaK_patchtohere(fs, condexit);  &bsol;* false conditions finish the loop */
791  }
792  static void repeatstat (LexState *ls, int line) {
793    int condexit;
794    FuncState *fs = ls->fs;
795    int repeat_init = luaK_getlabel(fs);
796    BlockCnt bl1, bl2;
797    enterblock(fs, &bl1, 1);  &bsol;* loop block */
798    enterblock(fs, &bl2, 0);  &bsol;* scope block */
799    luaX_next(ls);  &bsol;* skip REPEAT */
800    chunk(ls);
801    check_match(ls, TK_UNTIL, TK_REPEAT, line);
802    condexit = cond(ls);  &bsol;* read condition (inside scope block) */
803    if (!bl2.upval) {  &bsol;* no upvalues? */
804      leaveblock(fs);  &bsol;* finish scope */
805      luaK_patchlist(ls->fs, condexit, repeat_init);  &bsol;* close the loop */
806    }
807    else {  &bsol;* complete semantics when there are upvalues */
808      breakstat(ls);  &bsol;* if condition then break */
809      luaK_patchtohere(ls->fs, condexit);  &bsol;* else... */
810      leaveblock(fs);  &bsol;* finish scope... */
811      luaK_patchlist(ls->fs, luaK_jump(fs), repeat_init);  &bsol;* and repeat */
812    }
813    leaveblock(fs);  &bsol;* finish loop */
814  }
815  static int exp1 (LexState *ls) {
816    expdesc e;
817    int k;
818    expr(ls, &e);
819    k = e.k;
820    luaK_exp2nextreg(ls->fs, &e);
821    return k;
822  }
823  static void forbody (LexState *ls, int base, int line, int nvars, int isnum) {
824    BlockCnt bl;
825    FuncState *fs = ls->fs;
826    int prep, endfor;
827    adjustlocalvars(ls, 3);  &bsol;* control variables */
828    checknext(ls, TK_DO);
829    prep = isnum ? luaK_codeAsBx(fs, OP_FORPREP, base, NO_JUMP) : luaK_jump(fs);
830    enterblock(fs, &bl, 0);  &bsol;* scope for declared variables */
831    adjustlocalvars(ls, nvars);
832    luaK_reserveregs(fs, nvars);
833    block(ls);
834    leaveblock(fs);  &bsol;* end of scope for declared variables */
835    luaK_patchtohere(fs, prep);
836    endfor = (isnum) ? luaK_codeAsBx(fs, OP_FORLOOP, base, NO_JUMP) :
837                       luaK_codeABC(fs, OP_TFORLOOP, base, 0, nvars);
838    luaK_fixline(fs, line);  &bsol;* pretend that `OP_FOR' starts the loop */
839    luaK_patchlist(fs, (isnum ? endfor : luaK_jump(fs)), prep + 1);
840  }
841  static void fornum (LexState *ls, TString *varname, int line) {
842    FuncState *fs = ls->fs;
843    int base = fs->freereg;
844    new_localvarliteral(ls, "(for index)", 0);
845    new_localvarliteral(ls, "(for limit)", 1);
846    new_localvarliteral(ls, "(for step)", 2);
847    new_localvar(ls, varname, 3);
848    checknext(ls, '=');
849    exp1(ls);  &bsol;* initial value */
850    checknext(ls, ',');
851    exp1(ls);  &bsol;* limit */
852    if (testnext(ls, ','))
853      exp1(ls);  &bsol;* optional step */
854    else {  &bsol;* default step = 1 */
855      luaK_codeABx(fs, OP_LOADK, fs->freereg, luaK_numberK(fs, 1));
856      luaK_reserveregs(fs, 1);
857    }
858    forbody(ls, base, line, 1, 1);
859  }
860  static void forlist (LexState *ls, TString *indexname) {
861    FuncState *fs = ls->fs;
862    expdesc e;
863    int nvars = 0;
864    int line;
865    int base = fs->freereg;
866    new_localvarliteral(ls, "(for generator)", nvars++);
867    new_localvarliteral(ls, "(for state)", nvars++);
868    new_localvarliteral(ls, "(for control)", nvars++);
869    new_localvar(ls, indexname, nvars++);
870    while (testnext(ls, ','))
871      new_localvar(ls, str_checkname(ls), nvars++);
872    checknext(ls, TK_IN);
873    line = ls->linenumber;
874    adjust_assign(ls, 3, explist1(ls, &e), &e);
875    luaK_checkstack(fs, 3);  &bsol;* extra space to call generator */
876    forbody(ls, base, line, nvars - 3, 0);
877  }
878  static void forstat (LexState *ls, int line) {
879    FuncState *fs = ls->fs;
880    TString *varname;
881    BlockCnt bl;
882    enterblock(fs, &bl, 1);  &bsol;* scope for loop and control variables */
883    luaX_next(ls);  &bsol;* skip `for' */
884    varname = str_checkname(ls);  &bsol;* first variable name */
885    switch (ls->t.token) {
886      case '=': fornum(ls, varname, line); break;
887      case ',': case TK_IN: forlist(ls, varname); break;
888      default: luaX_syntaxerror(ls, LUA_QL("=") " or " LUA_QL("in") " expected");
889    }
890    check_match(ls, TK_END, TK_FOR, line);
891    leaveblock(fs);  &bsol;* loop scope (`break' jumps to this point) */
892  }
893  static int test_then_block (LexState *ls) {
894    int condexit;
895    luaX_next(ls);  &bsol;* skip IF or ELSEIF */
896    condexit = cond(ls);
897    checknext(ls, TK_THEN);
898    block(ls);  &bsol;* `then' part */
899    return condexit;
900  }
901  static void ifstat (LexState *ls, int line) {
902    FuncState *fs = ls->fs;
903    int flist;
904    int escapelist = NO_JUMP;
905    flist = test_then_block(ls);  &bsol;* IF cond THEN block */
906    while (ls->t.token == TK_ELSEIF) {
907      luaK_concat(fs, &escapelist, luaK_jump(fs));
908      luaK_patchtohere(fs, flist);
909      flist = test_then_block(ls);  &bsol;* ELSEIF cond THEN block */
910    }
911    if (ls->t.token == TK_ELSE) {
912      luaK_concat(fs, &escapelist, luaK_jump(fs));
913      luaK_patchtohere(fs, flist);
914      luaX_next(ls);  &bsol;* skip ELSE (after patch, for correct line info) */
915      block(ls);  &bsol;* `else' part */
916    }
917    else
918      luaK_concat(fs, &escapelist, flist);
919    luaK_patchtohere(fs, escapelist);
920    check_match(ls, TK_END, TK_IF, line);
921  }
922  static void localfunc (LexState *ls) {
923    expdesc v, b;
924    FuncState *fs = ls->fs;
925    new_localvar(ls, str_checkname(ls), 0);
926    init_exp(&v, VLOCAL, fs->freereg);
927    luaK_reserveregs(fs, 1);
928    adjustlocalvars(ls, 1);
929    body(ls, &b, 0, ls->linenumber);
930    luaK_storevar(fs, &v, &b);
931    getlocvar(fs, fs->nactvar - 1).startpc = fs->pc;
932  }
933  static void localstat (LexState *ls) {
934    int nvars = 0;
935    int nexps;
936    expdesc e;
937    do {
938      new_localvar(ls, str_checkname(ls), nvars++);
939    } while (testnext(ls, ','));
940    if (testnext(ls, '='))
941      nexps = explist1(ls, &e);
942    else {
943      e.k = VVOID;
944      nexps = 0;
945    }
946    adjust_assign(ls, nvars, nexps, &e);
947    adjustlocalvars(ls, nvars);
948  }
949  static int funcname (LexState *ls, expdesc *v) {
950    int needself = 0;
951    singlevar(ls, v);
952    while (ls->t.token == '.')
953      field(ls, v);
954    if (ls->t.token == ':') {
955      needself = 1;
956      field(ls, v);
957    }
958    return needself;
959  }
960  static void funcstat (LexState *ls, int line) {
961    int needself;
962    expdesc v, b;
963    luaX_next(ls);  &bsol;* skip FUNCTION */
964    needself = funcname(ls, &v);
965    body(ls, &b, needself, line);
966    luaK_storevar(ls->fs, &v, &b);
967    luaK_fixline(ls->fs, line);  &bsol;* definition `happens' in the first line */
968  }
969  static void exprstat (LexState *ls) {
970    FuncState *fs = ls->fs;
971    struct LHS_assign v;
972    primaryexp(ls, &v.v);
973    if (v.v.k == VCALL)  &bsol;* stat -> func */
974      SETARG_C(getcode(fs, &v.v), 1);  &bsol;* call statement uses no results */
975    else {  &bsol;* stat -> assignment */
976      v.prev = NULL;
977      assignment(ls, &v, 1);
978    }
979  }
980  static void retstat (LexState *ls) {
981    FuncState *fs = ls->fs;
982    expdesc e;
983    int first, nret;  &bsol;* registers with returned values */
984    luaX_next(ls);  &bsol;* skip RETURN */
985    if (block_follow(ls->t.token) || ls->t.token == ';')
986      first = nret = 0;  &bsol;* return no values */
987    else {
988      nret = explist1(ls, &e);  &bsol;* optional return values */
989      if (hasmultret(e.k)) {
990        luaK_setmultret(fs, &e);
991        if (e.k == VCALL && nret == 1) {  &bsol;* tail call? */
992          SET_OPCODE(getcode(fs,&e), OP_TAILCALL);
993          lua_assert(GETARG_A(getcode(fs,&e)) == fs->nactvar);
994        }
995        first = fs->nactvar;
996        nret = LUA_MULTRET;  &bsol;* return all values */
997      }
998      else {
999        if (nret == 1)  &bsol;* only one single value? */
1000          first = luaK_exp2anyreg(fs, &e);
1001        else {
1002          luaK_exp2nextreg(fs, &e);  &bsol;* values must go to the `stack' */
1003          first = fs->nactvar;  &bsol;* return all `active' values */
1004          lua_assert(nret == fs->freereg - first);
1005        }
1006      }
1007    }
1008    luaK_ret(fs, first, nret);
1009  }
1010  static int statement (LexState *ls) {
1011    int line = ls->linenumber;  &bsol;* may be needed for error messages */
1012    switch (ls->t.token) {
1013      case TK_IF: {  &bsol;* stat -> ifstat */
1014        ifstat(ls, line);
1015        return 0;
1016      }
1017      case TK_WHILE: {  &bsol;* stat -> whilestat */
1018        whilestat(ls, line);
1019        return 0;
1020      }
1021      case TK_DO: {  &bsol;* stat -> DO block END */
1022        luaX_next(ls);  &bsol;* skip DO */
1023        block(ls);
1024        check_match(ls, TK_END, TK_DO, line);
1025        return 0;
1026      }
1027      case TK_FOR: {  &bsol;* stat -> forstat */
1028        forstat(ls, line);
1029        return 0;
1030      }
1031      case TK_REPEAT: {  &bsol;* stat -> repeatstat */
1032        repeatstat(ls, line);
1033        return 0;
1034      }
1035      case TK_FUNCTION: {
1036        funcstat(ls, line);  &bsol;* stat -> funcstat */
1037        return 0;
1038      }
1039      case TK_LOCAL: {  &bsol;* stat -> localstat */
1040        luaX_next(ls);  &bsol;* skip LOCAL */
1041        if (testnext(ls, TK_FUNCTION))  &bsol;* local function? */
1042          localfunc(ls);
1043        else
1044          localstat(ls);
1045        return 0;
1046      }
1047      case TK_RETURN: {  &bsol;* stat -> retstat */
1048        retstat(ls);
1049        return 1;  &bsol;* must be last statement */
1050      }
1051      case TK_BREAK: {  &bsol;* stat -> breakstat */
1052        luaX_next(ls);  &bsol;* skip BREAK */
1053        breakstat(ls);
1054        return 1;  &bsol;* must be last statement */
1055      }
1056      default: {
1057        exprstat(ls);
1058        return 0;  &bsol;* to avoid warnings */
1059      }
1060    }
1061  }
1062  static void chunk (LexState *ls) {
1063    int islast = 0;
1064    enterlevel(ls);
1065    while (!islast && !block_follow(ls->t.token)) {
1066      islast = statement(ls);
1067      testnext(ls, ';');
1068      lua_assert(ls->fs->f->maxstacksize >= ls->fs->freereg &&
1069                 ls->fs->freereg >= ls->fs->nactvar);
1070      ls->fs->freereg = ls->fs->nactvar;  &bsol;* free registers */
1071    }
1072    leavelevel(ls);
1073  }
</code></pre>
        </div>
        <div class="column">
            <h3>redis-MDEwOlJlcG9zaXRvcnkxMDgxMTA3MDY=-flat-ltable.c</h3>
            <pre><code>1  #include <math.h>
2  #include <string.h>
3  #define ltable_c
4  #define LUA_CORE
5  #include "lua.h"
6  #include "ldebug.h"
7  #include "ldo.h"
8  #include "lgc.h"
9  #include "lmem.h"
10  #include "lobject.h"
11  #include "lstate.h"
12  #include "ltable.h"
13  #if LUAI_BITSINT > 26
14  #define MAXBITS		26
15  #else
16  #define MAXBITS		(LUAI_BITSINT-2)
17  #endif
18  #define MAXASIZE	(1 << MAXBITS)
19  #define hashpow2(t,n)      (gnode(t, lmod((n), sizenode(t))))
20  #define hashstr(t,str)  hashpow2(t, (str)->tsv.hash)
21  #define hashboolean(t,p)        hashpow2(t, p)
22  #define hashmod(t,n)	(gnode(t, ((n) % ((sizenode(t)-1)|1))))
23  #define hashpointer(t,p)	hashmod(t, IntPoint(p))
24  #define numints		cast_int(sizeof(lua_Number)/sizeof(int))
25  #define dummynode		(&dummynode_)
26  static const Node dummynode_ = {
27    {{NULL}, LUA_TNIL},  &bsol;* value */
28    {{{NULL}, LUA_TNIL, NULL}}  &bsol;* key */
29  };
30  static Node *hashnum (const Table *t, lua_Number n) {
31    unsigned int a[numints];
32    int i;
33    if (luai_numeq(n, 0))  &bsol;* avoid problems with -0 */
34      return gnode(t, 0);
35    memcpy(a, &n, sizeof(a));
36    for (i = 1; i < numints; i++) a[0] += a[i];
37    return hashmod(t, a[0]);
38  }
39  static Node *mainposition (const Table *t, const TValue *key) {
40    switch (ttype(key)) {
41      case LUA_TNUMBER:
42        return hashnum(t, nvalue(key));
43      case LUA_TSTRING:
44        return hashstr(t, rawtsvalue(key));
45      case LUA_TBOOLEAN:
46        return hashboolean(t, bvalue(key));
47      case LUA_TLIGHTUSERDATA:
48        return hashpointer(t, pvalue(key));
49      default:
50        return hashpointer(t, gcvalue(key));
51    }
52  }
53  static int arrayindex (const TValue *key) {
54    if (ttisnumber(key)) {
55      lua_Number n = nvalue(key);
56      int k;
57      lua_number2int(k, n);
58      if (luai_numeq(cast_num(k), n))
59        return k;
60    }
61    return -1;  &bsol;* `key' did not match some condition */
62  }
63  static int findindex (lua_State *L, Table *t, StkId key) {
64    int i;
65    if (ttisnil(key)) return -1;  &bsol;* first iteration */
66    i = arrayindex(key);
67    if (0 < i && i <= t->sizearray)  &bsol;* is `key' inside array part? */
68      return i-1;  &bsol;* yes; that's the index (corrected to C) */
69    else {
70      Node *n = mainposition(t, key);
71      do {  &bsol;* check whether `key' is somewhere in the chain */
72        if (luaO_rawequalObj(key2tval(n), key) ||
73              (ttype(gkey(n)) == LUA_TDEADKEY && iscollectable(key) &&
74               gcvalue(gkey(n)) == gcvalue(key))) {
75          i = cast_int(n - gnode(t, 0));  &bsol;* key index in hash table */
76          return i + t->sizearray;
77        }
78        else n = gnext(n);
79      } while (n);
80      luaG_runerror(L, "invalid key to " LUA_QL("next"));  &bsol;* key not found */
81      return 0;  &bsol;* to avoid warnings */
82    }
83  }
84  int luaH_next (lua_State *L, Table *t, StkId key) {
85    int i = findindex(L, t, key);  &bsol;* find original element */
86    for (i++; i < t->sizearray; i++) {  &bsol;* try first array part */
87      if (!ttisnil(&t->array[i])) {  &bsol;* a non-nil value? */
88        setnvalue(key, cast_num(i+1));
89        setobj2s(L, key+1, &t->array[i]);
90        return 1;
91      }
92    }
93    for (i -= t->sizearray; i < sizenode(t); i++) {  &bsol;* then hash part */
94      if (!ttisnil(gval(gnode(t, i)))) {  &bsol;* a non-nil value? */
95        setobj2s(L, key, key2tval(gnode(t, i)));
96        setobj2s(L, key+1, gval(gnode(t, i)));
97        return 1;
98      }
99    }
100    return 0;  &bsol;* no more elements */
101  }
102  static int computesizes (int nums[], int *narray) {
103    int i;
104    int twotoi;  &bsol;* 2^i */
105    int a = 0;  &bsol;* number of elements smaller than 2^i */
106    int na = 0;  &bsol;* number of elements to go to array part */
107    int n = 0;  &bsol;* optimal size for array part */
108    for (i = 0, twotoi = 1; twotoi/2 < *narray; i++, twotoi *= 2) {
109      if (nums[i] > 0) {
110        a += nums[i];
111        if (a > twotoi/2) {  &bsol;* more than half elements present? */
112          n = twotoi;  &bsol;* optimal size (till now) */
113          na = a;  &bsol;* all elements smaller than n will go to array part */
114        }
115      }
116      if (a == *narray) break;  &bsol;* all elements already counted */
117    }
118    *narray = n;
119    lua_assert(*narray/2 <= na && na <= *narray);
120    return na;
121  }
122  static int countint (const TValue *key, int *nums) {
123    int k = arrayindex(key);
124    if (0 < k && k <= MAXASIZE) {  &bsol;* is `key' an appropriate array index? */
125      nums[ceillog2(k)]++;  &bsol;* count as such */
126      return 1;
127    }
128    else
129      return 0;
130  }
131  static int numusearray (const Table *t, int *nums) {
132    int lg;
133    int ttlg;  &bsol;* 2^lg */
134    int ause = 0;  &bsol;* summation of `nums' */
135    int i = 1;  &bsol;* count to traverse all array keys */
136    for (lg=0, ttlg=1; lg<=MAXBITS; lg++, ttlg*=2) {  &bsol;* for each slice */
137      int lc = 0;  &bsol;* counter */
138      int lim = ttlg;
139      if (lim > t->sizearray) {
140        lim = t->sizearray;  &bsol;* adjust upper limit */
141        if (i > lim)
142          break;  &bsol;* no more elements to count */
143      }
144      for (; i <= lim; i++) {
145        if (!ttisnil(&t->array[i-1]))
146          lc++;
147      }
148      nums[lg] += lc;
149      ause += lc;
150    }
151    return ause;
152  }
153  static int numusehash (const Table *t, int *nums, int *pnasize) {
<span onclick='openModal()' class='match'>154    int totaluse = 0;  &bsol;* total number of elements */
155    int ause = 0;  &bsol;* summation of `nums' */
</span>156    int i = sizenode(t);
157    while (i--) {
158      Node *n = &t->node[i];
159      if (!ttisnil(gval(n))) {
160        ause += countint(key2tval(n), nums);
161        totaluse++;
162      }
163    }
164    *pnasize += ause;
165    return totaluse;
166  }
167  static void setarrayvector (lua_State *L, Table *t, int size) {
168    int i;
169    luaM_reallocvector(L, t->array, t->sizearray, size, TValue);
170    for (i=t->sizearray; i<size; i++)
171       setnilvalue(&t->array[i]);
172    t->sizearray = size;
173  }
174  static void setnodevector (lua_State *L, Table *t, int size) {
175    int lsize;
176    if (size == 0) {  &bsol;* no elements to hash part? */
177      t->node = cast(Node *, dummynode);  &bsol;* use common `dummynode' */
178      lsize = 0;
179    }
180    else {
181      int i;
182      lsize = ceillog2(size);
183      if (lsize > MAXBITS)
184        luaG_runerror(L, "table overflow");
185      size = twoto(lsize);
186      t->node = luaM_newvector(L, size, Node);
187      for (i=0; i<size; i++) {
188        Node *n = gnode(t, i);
189        gnext(n) = NULL;
190        setnilvalue(gkey(n));
191        setnilvalue(gval(n));
192      }
193    }
194    t->lsizenode = cast_byte(lsize);
195    t->lastfree = gnode(t, size);  &bsol;* all positions are free */
196  }
197  static void resize (lua_State *L, Table *t, int nasize, int nhsize) {
198    int i;
199    int oldasize = t->sizearray;
200    int oldhsize = t->lsizenode;
201    Node *nold = t->node;  &bsol;* save old hash ... */
202    if (nasize > oldasize)  &bsol;* array part must grow? */
203      setarrayvector(L, t, nasize);
204    setnodevector(L, t, nhsize);  
205    if (nasize < oldasize) {  &bsol;* array part must shrink? */
206      t->sizearray = nasize;
207      for (i=nasize; i<oldasize; i++) {
208        if (!ttisnil(&t->array[i]))
209          setobjt2t(L, luaH_setnum(L, t, i+1), &t->array[i]);
210      }
211      luaM_reallocvector(L, t->array, oldasize, nasize, TValue);
212    }
213    for (i = twoto(oldhsize) - 1; i >= 0; i--) {
214      Node *old = nold+i;
215      if (!ttisnil(gval(old)))
216        setobjt2t(L, luaH_set(L, t, key2tval(old)), gval(old));
217    }
218  #ifdef _WIN32
219  #pragma warning(push)
220  #pragma warning(disable: 4334)
221  #endif
222    if (nold != dummynode)
223      luaM_freearray(L, nold, twoto(oldhsize), Node);  &bsol;* free old array */
224  #ifdef _WIN32
225  #pragma warning(pop)
226  #endif
227  }
228  void luaH_resizearray (lua_State *L, Table *t, int nasize) {
229    int nsize = (t->node == dummynode) ? 0 : sizenode(t);
230    resize(L, t, nasize, nsize);
231  }
232  static void rehash (lua_State *L, Table *t, const TValue *ek) {
233    int nasize, na;
234    int nums[MAXBITS+1];  &bsol;* nums[i] = number of keys between 2^(i-1) and 2^i */
235    int i;
236    int totaluse;
237    for (i=0; i<=MAXBITS; i++) nums[i] = 0;  &bsol;* reset counts */
238    nasize = numusearray(t, nums);  &bsol;* count keys in array part */
239    totaluse = nasize;  &bsol;* all those keys are integer keys */
240    totaluse += numusehash(t, nums, &nasize);  &bsol;* count keys in hash part */
241    nasize += countint(ek, nums);
242    totaluse++;
243    na = computesizes(nums, &nasize);
244    resize(L, t, nasize, totaluse - na);
245  }
246  Table *luaH_new (lua_State *L, int narray, int nhash) {
247    Table *t = luaM_new(L, Table);
248    luaC_link(L, obj2gco(t), LUA_TTABLE);
249    t->metatable = NULL;
250    t->flags = cast_byte(~0);
251    t->array = NULL;
252    t->sizearray = 0;
253    t->lsizenode = 0;
254    t->node = cast(Node *, dummynode);
255    setarrayvector(L, t, narray);
256    setnodevector(L, t, nhash);
257    return t;
258  }
259  void luaH_free (lua_State *L, Table *t) {
260  #ifdef _WIN32
261  #pragma warning(push)
262  #pragma warning(disable: 4334)
263  #endif
264      if (t->node != dummynode)
265      luaM_freearray(L, t->node, sizenode(t), Node);
266  #ifdef _WIN32
267  #pragma warning(pop)
268  #endif
269      luaM_freearray(L, t->array, t->sizearray, TValue);
270    luaM_free(L, t);
271  }
272  static Node *getfreepos (Table *t) {
273    while (t->lastfree-- > t->node) {
274      if (ttisnil(gkey(t->lastfree)))
275        return t->lastfree;
276    }
277    return NULL;  &bsol;* could not find a free place */
278  }
279  static TValue *newkey (lua_State *L, Table *t, const TValue *key) {
280    Node *mp = mainposition(t, key);
281    if (!ttisnil(gval(mp)) || mp == dummynode) {
282      Node *othern;
283      Node *n = getfreepos(t);  &bsol;* get a free place */
284      if (n == NULL) {  &bsol;* cannot find a free place? */
285        rehash(L, t, key);  &bsol;* grow table */
286        return luaH_set(L, t, key);  &bsol;* re-insert key into grown table */
287      }
288      lua_assert(n != dummynode);
289      othern = mainposition(t, key2tval(mp));
290      if (othern != mp) {  &bsol;* is colliding node out of its main position? */
291        while (gnext(othern) != mp) othern = gnext(othern);  &bsol;* find previous */
292        gnext(othern) = n;  &bsol;* redo the chain with `n' in place of `mp' */
293        *n = *mp;  &bsol;* copy colliding node into free pos. (mp->next also goes) */
294        gnext(mp) = NULL;  &bsol;* now `mp' is free */
295        setnilvalue(gval(mp));
296      }
297      else {  &bsol;* colliding node is in its own main position */
298        gnext(n) = gnext(mp);  &bsol;* chain new position */
299        gnext(mp) = n;
300        mp = n;
301      }
302    }
303    gkey(mp)->value = key->value; gkey(mp)->tt = key->tt;
304    luaC_barriert(L, t, key);
305    lua_assert(ttisnil(gval(mp)));
306    return gval(mp);
307  }
308  const TValue *luaH_getnum (Table *t, int key) {
309    if (cast(unsigned int, key-1) < cast(unsigned int, t->sizearray))
310      return &t->array[key-1];
311    else {
312      lua_Number nk = cast_num(key);
313      Node *n = hashnum(t, nk);
314      do {  &bsol;* check whether `key' is somewhere in the chain */
315        if (ttisnumber(gkey(n)) && luai_numeq(nvalue(gkey(n)), nk))
316          return gval(n);  &bsol;* that's it */
317        else n = gnext(n);
318      } while (n);
319      return luaO_nilobject;
320    }
321  }
322  const TValue *luaH_getstr (Table *t, TString *key) {
323    Node *n = hashstr(t, key);
324    do {  &bsol;* check whether `key' is somewhere in the chain */
325      if (ttisstring(gkey(n)) && rawtsvalue(gkey(n)) == key)
326        return gval(n);  &bsol;* that's it */
327      else n = gnext(n);
328    } while (n);
329    return luaO_nilobject;
330  }
331  const TValue *luaH_get (Table *t, const TValue *key) {
332    switch (ttype(key)) {
333      case LUA_TNIL: return luaO_nilobject;
334      case LUA_TSTRING: return luaH_getstr(t, rawtsvalue(key));
335      case LUA_TNUMBER: {
336        int k;
337        lua_Number n = nvalue(key);
338        lua_number2int(k, n);
339        if (luai_numeq(cast_num(k), nvalue(key))) &bsol;* index is int? */
340          return luaH_getnum(t, k);  &bsol;* use specialized version */
341      }
342      default: {
343        Node *n = mainposition(t, key);
344        do {  &bsol;* check whether `key' is somewhere in the chain */
345          if (luaO_rawequalObj(key2tval(n), key))
346            return gval(n);  &bsol;* that's it */
347          else n = gnext(n);
348        } while (n);
349        return luaO_nilobject;
350      }
351    }
352  }
353  TValue *luaH_set (lua_State *L, Table *t, const TValue *key) {
354    const TValue *p = luaH_get(t, key);
355    t->flags = 0;
356    if (p != luaO_nilobject)
357      return cast(TValue *, p);
358    else {
359      if (ttisnil(key)) luaG_runerror(L, "table index is nil");
360      else if (ttisnumber(key) && luai_numisnan(nvalue(key)))
361        luaG_runerror(L, "table index is NaN");
362      return newkey(L, t, key);
363    }
364  }
365  TValue *luaH_setnum (lua_State *L, Table *t, int key) {
366    const TValue *p = luaH_getnum(t, key);
367    if (p != luaO_nilobject)
368      return cast(TValue *, p);
369    else {
370      TValue k;
371      setnvalue(&k, cast_num(key));
372      return newkey(L, t, &k);
373    }
374  }
375  TValue *luaH_setstr (lua_State *L, Table *t, TString *key) {
376    const TValue *p = luaH_getstr(t, key);
377    if (p != luaO_nilobject)
378      return cast(TValue *, p);
379    else {
380      TValue k;
381      setsvalue(L, &k, key);
382      return newkey(L, t, &k);
383    }
384  }
385  static int unbound_search (Table *t, unsigned int j) {
386    unsigned int i = j;  &bsol;* i is zero or a present index */
387    j++;
388    while (!ttisnil(luaH_getnum(t, j))) {
389      i = j;
390      j *= 2;
391      if (j > cast(unsigned int, MAX_INT)) {  &bsol;* overflow? */
392        i = 1;
393        while (!ttisnil(luaH_getnum(t, i))) i++;
394        return i - 1;
395      }
396    }
397    while (j - i > 1) {
398      unsigned int m = (i+j)/2;
399      if (ttisnil(luaH_getnum(t, m))) j = m;
400      else i = m;
401    }
402    return i;
403  }
404  int luaH_getn (Table *t) {
405    unsigned int j = t->sizearray;
406    if (j > 0 && ttisnil(&t->array[j - 1])) {
407      unsigned int i = 0;
408      while (j - i > 1) {
409        unsigned int m = (i+j)/2;
410        if (ttisnil(&t->array[m - 1])) j = m;
411        else i = m;
412      }
413      return i;
414    }
415    else if (t->node == dummynode)  &bsol;* hash part is empty? */
416      return j;  &bsol;* that is easy... */
417    else return unbound_search(t, j);
418  }
419  #if defined(LUA_DEBUG)
420  Node *luaH_mainposition (const Table *t, const TValue *key) {
421    return mainposition(t, key);
422  }
423  int luaH_isdummy (Node *n) { return n == dummynode; }
424  #endif
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from redis-MDEwOlJlcG9zaXRvcnkxMDgxMTA3MDY=-flat-lparser.c</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from redis-MDEwOlJlcG9zaXRvcnkxMDgxMTA3MDY=-flat-ltable.c</div>
                </div>
                <div class="column column_space"><pre><code>460    int n = 1;  &bsol;* at least one expression */
461    expr(ls, v);
</pre></code></div>
                <div class="column column_space"><pre><code>154    int totaluse = 0;  &bsol;* total number of elements */
155    int ause = 0;  &bsol;* summation of `nums' */
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    