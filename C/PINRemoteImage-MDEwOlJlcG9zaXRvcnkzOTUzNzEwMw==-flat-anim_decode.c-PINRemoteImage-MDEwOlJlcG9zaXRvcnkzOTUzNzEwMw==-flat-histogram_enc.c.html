
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 21, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>PINRemoteImage-MDEwOlJlcG9zaXRvcnkzOTUzNzEwMw==-flat-anim_decode.c</h3>
            <pre><code>1  #ifdef HAVE_CONFIG_H
2  #include "src/webp/config.h"
3  #endif
4  #include <assert.h>
5  #include <string.h>
6  #include "src/utils/utils.h"
7  #include "src/webp/decode.h"
8  #include "src/webp/demux.h"
9  #define NUM_CHANNELS 4
10  typedef void (*BlendRowFunc)(uint32_t* const, const uint32_t* const, int);
11  static void BlendPixelRowNonPremult(uint32_t* const src,
12                                      const uint32_t* const dst, int num_pixels);
13  static void BlendPixelRowPremult(uint32_t* const src, const uint32_t* const dst,
14                                   int num_pixels);
15  struct WebPAnimDecoder {
16    WebPDemuxer* demux_;             
17    WebPDecoderConfig config_;       
18    BlendRowFunc blend_func_;        
19    WebPAnimInfo info_;              
20    uint8_t* curr_frame_;            
21    uint8_t* prev_frame_disposed_;   
22    int prev_frame_timestamp_;       
23    WebPIterator prev_iter_;         
24    int prev_frame_was_keyframe_;    
25    int next_frame_;                 
26  };
27  static void DefaultDecoderOptions(WebPAnimDecoderOptions* const dec_options) {
28    dec_options->color_mode = MODE_RGBA;
29    dec_options->use_threads = 0;
30  }
31  int WebPAnimDecoderOptionsInitInternal(WebPAnimDecoderOptions* dec_options,
32                                         int abi_version) {
33    if (dec_options == NULL ||
34        WEBP_ABI_IS_INCOMPATIBLE(abi_version, WEBP_DEMUX_ABI_VERSION)) {
35      return 0;
36    }
37    DefaultDecoderOptions(dec_options);
38    return 1;
39  }
40  static int ApplyDecoderOptions(const WebPAnimDecoderOptions* const dec_options,
41                                 WebPAnimDecoder* const dec) {
42    WEBP_CSP_MODE mode;
43    WebPDecoderConfig* config = &dec->config_;
44    assert(dec_options != NULL);
45    mode = dec_options->color_mode;
46    if (mode != MODE_RGBA && mode != MODE_BGRA &&
47        mode != MODE_rgbA && mode != MODE_bgrA) {
48      return 0;
49    }
50    dec->blend_func_ = (mode == MODE_RGBA || mode == MODE_BGRA)
51                           ? &BlendPixelRowNonPremult
52                           : &BlendPixelRowPremult;
53    WebPInitDecoderConfig(config);
54    config->output.colorspace = mode;
55    config->output.is_external_memory = 1;
56    config->options.use_threads = dec_options->use_threads;
57    return 1;
58  }
59  WebPAnimDecoder* WebPAnimDecoderNewInternal(
60      const WebPData* webp_data, const WebPAnimDecoderOptions* dec_options,
61      int abi_version) {
62    WebPAnimDecoderOptions options;
63    WebPAnimDecoder* dec = NULL;
64    if (webp_data == NULL ||
65        WEBP_ABI_IS_INCOMPATIBLE(abi_version, WEBP_DEMUX_ABI_VERSION)) {
66      return NULL;
67    }
68    dec = (WebPAnimDecoder*)WebPSafeCalloc(1ULL, sizeof(*dec));
69    if (dec == NULL) goto Error;
70    if (dec_options != NULL) {
71      options = *dec_options;
72    } else {
73      DefaultDecoderOptions(&options);
74    }
75    if (!ApplyDecoderOptions(&options, dec)) goto Error;
76    dec->demux_ = WebPDemux(webp_data);
77    if (dec->demux_ == NULL) goto Error;
78    dec->info_.canvas_width = WebPDemuxGetI(dec->demux_, WEBP_FF_CANVAS_WIDTH);
79    dec->info_.canvas_height = WebPDemuxGetI(dec->demux_, WEBP_FF_CANVAS_HEIGHT);
80    dec->info_.loop_count = WebPDemuxGetI(dec->demux_, WEBP_FF_LOOP_COUNT);
81    dec->info_.bgcolor = WebPDemuxGetI(dec->demux_, WEBP_FF_BACKGROUND_COLOR);
82    dec->info_.frame_count = WebPDemuxGetI(dec->demux_, WEBP_FF_FRAME_COUNT);
83    dec->curr_frame_ = (uint8_t*)WebPSafeCalloc(
84        dec->info_.canvas_width * NUM_CHANNELS, dec->info_.canvas_height);
85    if (dec->curr_frame_ == NULL) goto Error;
86    dec->prev_frame_disposed_ = (uint8_t*)WebPSafeCalloc(
87        dec->info_.canvas_width * NUM_CHANNELS, dec->info_.canvas_height);
88    if (dec->prev_frame_disposed_ == NULL) goto Error;
89    WebPAnimDecoderReset(dec);
90    return dec;
91   Error:
92    WebPAnimDecoderDelete(dec);
93    return NULL;
94  }
95  int WebPAnimDecoderGetInfo(const WebPAnimDecoder* dec, WebPAnimInfo* info) {
96    if (dec == NULL || info == NULL) return 0;
97    *info = dec->info_;
98    return 1;
99  }
100  static int IsFullFrame(int width, int height, int canvas_width,
101                         int canvas_height) {
102    return (width == canvas_width && height == canvas_height);
103  }
104  static int ZeroFillCanvas(uint8_t* buf, uint32_t canvas_width,
105                            uint32_t canvas_height) {
106    const uint64_t size =
107        (uint64_t)canvas_width * canvas_height * NUM_CHANNELS * sizeof(*buf);
108    if (size != (size_t)size) return 0;
109    memset(buf, 0, (size_t)size);
110    return 1;
111  }
112  static void ZeroFillFrameRect(uint8_t* buf, int buf_stride, int x_offset,
113                                int y_offset, int width, int height) {
114    int j;
115    assert(width * NUM_CHANNELS <= buf_stride);
116    buf += y_offset * buf_stride + x_offset * NUM_CHANNELS;
117    for (j = 0; j < height; ++j) {
118      memset(buf, 0, width * NUM_CHANNELS);
119      buf += buf_stride;
120    }
121  }
122  static int CopyCanvas(const uint8_t* src, uint8_t* dst,
123                        uint32_t width, uint32_t height) {
124    const uint64_t size = (uint64_t)width * height * NUM_CHANNELS;
125    if (size != (size_t)size) return 0;
126    assert(src != NULL && dst != NULL);
127    memcpy(dst, src, (size_t)size);
128    return 1;
129  }
130  static int IsKeyFrame(const WebPIterator* const curr,
131                        const WebPIterator* const prev,
132                        int prev_frame_was_key_frame,
133                        int canvas_width, int canvas_height) {
134    if (curr->frame_num == 1) {
135      return 1;
136    } else if ((!curr->has_alpha || curr->blend_method == WEBP_MUX_NO_BLEND) &&
137               IsFullFrame(curr->width, curr->height,
138                           canvas_width, canvas_height)) {
139      return 1;
140    } else {
141      return (prev->dispose_method == WEBP_MUX_DISPOSE_BACKGROUND) &&
142             (IsFullFrame(prev->width, prev->height, canvas_width,
143                          canvas_height) ||
144              prev_frame_was_key_frame);
145    }
146  }
147  static uint8_t BlendChannelNonPremult(uint32_t src, uint8_t src_a,
148                                        uint32_t dst, uint8_t dst_a,
149                                        uint32_t scale, int shift) {
150    const uint8_t src_channel = (src >> shift) & 0xff;
151    const uint8_t dst_channel = (dst >> shift) & 0xff;
152    const uint32_t blend_unscaled = src_channel * src_a + dst_channel * dst_a;
153    assert(blend_unscaled < (1ULL << 32) / scale);
154    return (blend_unscaled * scale) >> 24;
155  }
156  static uint32_t BlendPixelNonPremult(uint32_t src, uint32_t dst) {
157    const uint8_t src_a = (src >> 24) & 0xff;
158    if (src_a == 0) {
159      return dst;
160    } else {
161      const uint8_t dst_a = (dst >> 24) & 0xff;
162      const uint8_t dst_factor_a = (dst_a * (256 - src_a)) >> 8;
163      const uint8_t blend_a = src_a + dst_factor_a;
164      const uint32_t scale = (1UL << 24) / blend_a;
165      const uint8_t blend_r =
166          BlendChannelNonPremult(src, src_a, dst, dst_factor_a, scale, 0);
167      const uint8_t blend_g =
168          BlendChannelNonPremult(src, src_a, dst, dst_factor_a, scale, 8);
169      const uint8_t blend_b =
170          BlendChannelNonPremult(src, src_a, dst, dst_factor_a, scale, 16);
171      assert(src_a + dst_factor_a < 256);
172      return (blend_r << 0) |
173             (blend_g << 8) |
174             (blend_b << 16) |
175             ((uint32_t)blend_a << 24);
176    }
177  }
178  static void BlendPixelRowNonPremult(uint32_t* const src,
179                                      const uint32_t* const dst, int num_pixels) {
180    int i;
181    for (i = 0; i < num_pixels; ++i) {
182      const uint8_t src_alpha = (src[i] >> 24) & 0xff;
183      if (src_alpha != 0xff) {
184        src[i] = BlendPixelNonPremult(src[i], dst[i]);
185      }
186    }
187  }
188  static WEBP_INLINE uint32_t ChannelwiseMultiply(uint32_t pix, uint32_t scale) {
189    uint32_t mask = 0x00FF00FF;
190    uint32_t rb = ((pix & mask) * scale) >> 8;
191    uint32_t ag = ((pix >> 8) & mask) * scale;
192    return (rb & mask) | (ag & ~mask);
193  }
194  static uint32_t BlendPixelPremult(uint32_t src, uint32_t dst) {
195    const uint8_t src_a = (src >> 24) & 0xff;
196    return src + ChannelwiseMultiply(dst, 256 - src_a);
197  }
198  static void BlendPixelRowPremult(uint32_t* const src, const uint32_t* const dst,
199                                   int num_pixels) {
200    int i;
201    for (i = 0; i < num_pixels; ++i) {
202      const uint8_t src_alpha = (src[i] >> 24) & 0xff;
203      if (src_alpha != 0xff) {
204        src[i] = BlendPixelPremult(src[i], dst[i]);
205      }
206    }
207  }
208  static void FindBlendRangeAtRow(const WebPIterator* const src,
209                                  const WebPIterator* const dst, int canvas_y,
210                                  int* const left1, int* const width1,
211                                  int* const left2, int* const width2) {
212    const int src_max_x = src->x_offset + src->width;
213    const int dst_max_x = dst->x_offset + dst->width;
214    const int dst_max_y = dst->y_offset + dst->height;
<span onclick='openModal()' class='match'>215    assert(canvas_y >= src->y_offset && canvas_y < (src->y_offset + src->height));
216    *left1 = -1;
</span>217    *width1 = 0;
218    *left2 = -1;
219    *width2 = 0;
220    if (canvas_y < dst->y_offset || canvas_y >= dst_max_y ||
221        src->x_offset >= dst_max_x || src_max_x <= dst->x_offset) {
222      *left1 = src->x_offset;
223      *width1 = src->width;
224      return;
225    }
226    if (src->x_offset < dst->x_offset) {
227      *left1 = src->x_offset;
228      *width1 = dst->x_offset - src->x_offset;
229    }
230    if (src_max_x > dst_max_x) {
231      *left2 = dst_max_x;
232      *width2 = src_max_x - dst_max_x;
233    }
234  }
235  int WebPAnimDecoderGetNext(WebPAnimDecoder* dec,
236                             uint8_t** buf_ptr, int* timestamp_ptr) {
237    WebPIterator iter;
238    uint32_t width;
239    uint32_t height;
240    int is_key_frame;
241    int timestamp;
242    BlendRowFunc blend_row;
243    if (dec == NULL || buf_ptr == NULL || timestamp_ptr == NULL) return 0;
244    if (!WebPAnimDecoderHasMoreFrames(dec)) return 0;
245    width = dec->info_.canvas_width;
246    height = dec->info_.canvas_height;
247    blend_row = dec->blend_func_;
248    if (!WebPDemuxGetFrame(dec->demux_, dec->next_frame_, &iter)) {
249      return 0;
250    }
251    timestamp = dec->prev_frame_timestamp_ + iter.duration;
252    is_key_frame = IsKeyFrame(&iter, &dec->prev_iter_,
253                              dec->prev_frame_was_keyframe_, width, height);
254    if (is_key_frame) {
255      if (!ZeroFillCanvas(dec->curr_frame_, width, height)) {
256        goto Error;
257      }
258    } else {
259      if (!CopyCanvas(dec->prev_frame_disposed_, dec->curr_frame_,
260                      width, height)) {
261        goto Error;
262      }
263    }
264    {
265      const uint8_t* in = iter.fragment.bytes;
266      const size_t in_size = iter.fragment.size;
267      const size_t out_offset =
268          (iter.y_offset * width + iter.x_offset) * NUM_CHANNELS;
269      WebPDecoderConfig* const config = &dec->config_;
270      WebPRGBABuffer* const buf = &config->output.u.RGBA;
271      buf->stride = NUM_CHANNELS * width;
272      buf->size = buf->stride * iter.height;
273      buf->rgba = dec->curr_frame_ + out_offset;
274      if (WebPDecode(in, in_size, config) != VP8_STATUS_OK) {
275        goto Error;
276      }
277    }
278    if (iter.frame_num > 1 && iter.blend_method == WEBP_MUX_BLEND &&
279        !is_key_frame) {
280      if (dec->prev_iter_.dispose_method == WEBP_MUX_DISPOSE_NONE) {
281        int y;
282        for (y = 0; y < iter.height; ++y) {
283          const size_t offset =
284              (iter.y_offset + y) * width + iter.x_offset;
285          blend_row((uint32_t*)dec->curr_frame_ + offset,
286                    (uint32_t*)dec->prev_frame_disposed_ + offset, iter.width);
287        }
288      } else {
289        int y;
290        assert(dec->prev_iter_.dispose_method == WEBP_MUX_DISPOSE_BACKGROUND);
291        for (y = 0; y < iter.height; ++y) {
292          const int canvas_y = iter.y_offset + y;
293          int left1, width1, left2, width2;
294          FindBlendRangeAtRow(&iter, &dec->prev_iter_, canvas_y, &left1, &width1,
295                              &left2, &width2);
296          if (width1 > 0) {
297            const size_t offset1 = canvas_y * width + left1;
298            blend_row((uint32_t*)dec->curr_frame_ + offset1,
299                      (uint32_t*)dec->prev_frame_disposed_ + offset1, width1);
300          }
301          if (width2 > 0) {
302            const size_t offset2 = canvas_y * width + left2;
303            blend_row((uint32_t*)dec->curr_frame_ + offset2,
304                      (uint32_t*)dec->prev_frame_disposed_ + offset2, width2);
305          }
306        }
307      }
308    }
309    dec->prev_frame_timestamp_ = timestamp;
310    WebPDemuxReleaseIterator(&dec->prev_iter_);
311    dec->prev_iter_ = iter;
312    dec->prev_frame_was_keyframe_ = is_key_frame;
313    CopyCanvas(dec->curr_frame_, dec->prev_frame_disposed_, width, height);
314    if (dec->prev_iter_.dispose_method == WEBP_MUX_DISPOSE_BACKGROUND) {
315      ZeroFillFrameRect(dec->prev_frame_disposed_, width * NUM_CHANNELS,
316                        dec->prev_iter_.x_offset, dec->prev_iter_.y_offset,
317                        dec->prev_iter_.width, dec->prev_iter_.height);
318    }
319    ++dec->next_frame_;
320    *buf_ptr = dec->curr_frame_;
321    *timestamp_ptr = timestamp;
322    return 1;
323   Error:
324    WebPDemuxReleaseIterator(&iter);
325    return 0;
326  }
327  int WebPAnimDecoderHasMoreFrames(const WebPAnimDecoder* dec) {
328    if (dec == NULL) return 0;
329    return (dec->next_frame_ <= (int)dec->info_.frame_count);
330  }
331  void WebPAnimDecoderReset(WebPAnimDecoder* dec) {
332    if (dec != NULL) {
333      dec->prev_frame_timestamp_ = 0;
334      WebPDemuxReleaseIterator(&dec->prev_iter_);
335      memset(&dec->prev_iter_, 0, sizeof(dec->prev_iter_));
336      dec->prev_frame_was_keyframe_ = 0;
337      dec->next_frame_ = 1;
338    }
339  }
340  const WebPDemuxer* WebPAnimDecoderGetDemuxer(const WebPAnimDecoder* dec) {
341    if (dec == NULL) return NULL;
342    return dec->demux_;
343  }
344  void WebPAnimDecoderDelete(WebPAnimDecoder* dec) {
345    if (dec != NULL) {
346      WebPDemuxReleaseIterator(&dec->prev_iter_);
347      WebPDemuxDelete(dec->demux_);
348      WebPSafeFree(dec->curr_frame_);
349      WebPSafeFree(dec->prev_frame_disposed_);
350      WebPSafeFree(dec);
351    }
352  }
</code></pre>
        </div>
        <div class="column">
            <h3>PINRemoteImage-MDEwOlJlcG9zaXRvcnkzOTUzNzEwMw==-flat-histogram_enc.c</h3>
            <pre><code>1  #ifdef HAVE_CONFIG_H
2  #include "src/webp/config.h"
3  #endif
4  #include <math.h>
5  #include "src/enc/backward_references_enc.h"
6  #include "src/enc/histogram_enc.h"
7  #include "src/dsp/lossless.h"
8  #include "src/dsp/lossless_common.h"
9  #include "src/utils/utils.h"
10  #define MAX_COST 1.e38
11  #define NUM_PARTITIONS 4
12  #define BIN_SIZE (NUM_PARTITIONS * NUM_PARTITIONS * NUM_PARTITIONS)
13  #define MAX_HISTO_GREEDY 100
14  static void HistogramClear(VP8LHistogram* const p) {
15    uint32_t* const literal = p->literal_;
16    const int cache_bits = p->palette_code_bits_;
17    const int histo_size = VP8LGetHistogramSize(cache_bits);
18    memset(p, 0, histo_size);
19    p->palette_code_bits_ = cache_bits;
20    p->literal_ = literal;
21  }
22  static void HistogramSwap(VP8LHistogram** const A, VP8LHistogram** const B) {
23    VP8LHistogram* const tmp = *A;
24    *A = *B;
25    *B = tmp;
26  }
27  static void HistogramCopy(const VP8LHistogram* const src,
28                            VP8LHistogram* const dst) {
29    uint32_t* const dst_literal = dst->literal_;
30    const int dst_cache_bits = dst->palette_code_bits_;
31    const int literal_size = VP8LHistogramNumCodes(dst_cache_bits);
32    const int histo_size = VP8LGetHistogramSize(dst_cache_bits);
33    assert(src->palette_code_bits_ == dst_cache_bits);
34    memcpy(dst, src, histo_size);
35    dst->literal_ = dst_literal;
36    memcpy(dst->literal_, src->literal_, literal_size * sizeof(*dst->literal_));
37  }
38  int VP8LGetHistogramSize(int cache_bits) {
39    const int literal_size = VP8LHistogramNumCodes(cache_bits);
40    const size_t total_size = sizeof(VP8LHistogram) + sizeof(int) * literal_size;
41    assert(total_size <= (size_t)0x7fffffff);
42    return (int)total_size;
43  }
44  void VP8LFreeHistogram(VP8LHistogram* const histo) {
45    WebPSafeFree(histo);
46  }
47  void VP8LFreeHistogramSet(VP8LHistogramSet* const histo) {
48    WebPSafeFree(histo);
49  }
50  void VP8LHistogramStoreRefs(const VP8LBackwardRefs* const refs,
51                              VP8LHistogram* const histo) {
52    VP8LRefsCursor c = VP8LRefsCursorInit(refs);
53    while (VP8LRefsCursorOk(&c)) {
54      VP8LHistogramAddSinglePixOrCopy(histo, c.cur_pos, NULL, 0);
55      VP8LRefsCursorNext(&c);
56    }
57  }
58  void VP8LHistogramCreate(VP8LHistogram* const p,
59                           const VP8LBackwardRefs* const refs,
60                           int palette_code_bits) {
61    if (palette_code_bits >= 0) {
62      p->palette_code_bits_ = palette_code_bits;
63    }
64    HistogramClear(p);
65    VP8LHistogramStoreRefs(refs, p);
66  }
67  void VP8LHistogramInit(VP8LHistogram* const p, int palette_code_bits,
68                         int init_arrays) {
69    p->palette_code_bits_ = palette_code_bits;
70    if (init_arrays) {
71      HistogramClear(p);
72    } else {
73      p->trivial_symbol_ = 0;
74      p->bit_cost_ = 0.;
75      p->literal_cost_ = 0.;
76      p->red_cost_ = 0.;
77      p->blue_cost_ = 0.;
78      memset(p->is_used_, 0, sizeof(p->is_used_));
79    }
80  }
81  VP8LHistogram* VP8LAllocateHistogram(int cache_bits) {
82    VP8LHistogram* histo = NULL;
83    const int total_size = VP8LGetHistogramSize(cache_bits);
84    uint8_t* const memory = (uint8_t*)WebPSafeMalloc(total_size, sizeof(*memory));
85    if (memory == NULL) return NULL;
86    histo = (VP8LHistogram*)memory;
87    histo->literal_ = (uint32_t*)(memory + sizeof(VP8LHistogram));
88    VP8LHistogramInit(histo, cache_bits, &bsol;*init_arrays=*/ 0);
89    return histo;
90  }
91  static void HistogramSetResetPointers(VP8LHistogramSet* const set,
92                                        int cache_bits) {
93    int i;
94    const int histo_size = VP8LGetHistogramSize(cache_bits);
95    uint8_t* memory = (uint8_t*) (set->histograms);
96    memory += set->max_size * sizeof(*set->histograms);
97    for (i = 0; i < set->max_size; ++i) {
98      memory = (uint8_t*) WEBP_ALIGN(memory);
99      set->histograms[i] = (VP8LHistogram*) memory;
100      set->histograms[i]->literal_ = (uint32_t*)(memory + sizeof(VP8LHistogram));
101      memory += histo_size;
102    }
103  }
104  static size_t HistogramSetTotalSize(int size, int cache_bits) {
105    const int histo_size = VP8LGetHistogramSize(cache_bits);
106    return (sizeof(VP8LHistogramSet) + size * (sizeof(VP8LHistogram*) +
107            histo_size + WEBP_ALIGN_CST));
108  }
109  VP8LHistogramSet* VP8LAllocateHistogramSet(int size, int cache_bits) {
110    int i;
111    VP8LHistogramSet* set;
112    const size_t total_size = HistogramSetTotalSize(size, cache_bits);
113    uint8_t* memory = (uint8_t*)WebPSafeMalloc(total_size, sizeof(*memory));
114    if (memory == NULL) return NULL;
115    set = (VP8LHistogramSet*)memory;
116    memory += sizeof(*set);
117    set->histograms = (VP8LHistogram**)memory;
118    set->max_size = size;
119    set->size = size;
120    HistogramSetResetPointers(set, cache_bits);
121    for (i = 0; i < size; ++i) {
122      VP8LHistogramInit(set->histograms[i], cache_bits, &bsol;*init_arrays=*/ 0);
123    }
124    return set;
125  }
126  void VP8LHistogramSetClear(VP8LHistogramSet* const set) {
127    int i;
128    const int cache_bits = set->histograms[0]->palette_code_bits_;
129    const int size = set->max_size;
130    const size_t total_size = HistogramSetTotalSize(size, cache_bits);
131    uint8_t* memory = (uint8_t*)set;
132    memset(memory, 0, total_size);
133    memory += sizeof(*set);
134    set->histograms = (VP8LHistogram**)memory;
135    set->max_size = size;
136    set->size = size;
137    HistogramSetResetPointers(set, cache_bits);
138    for (i = 0; i < size; ++i) {
139      set->histograms[i]->palette_code_bits_ = cache_bits;
140    }
141  }
142  static void HistogramSetRemoveHistogram(VP8LHistogramSet* const set, int i,
143                                          int* const num_used) {
144    assert(set->histograms[i] != NULL);
145    set->histograms[i] = NULL;
146    --*num_used;
147    if (i == set->size - 1) {
148      while (set->size >= 1 && set->histograms[set->size - 1] == NULL) {
149        --set->size;
150      }
151    }
152  }
153  void VP8LHistogramAddSinglePixOrCopy(VP8LHistogram* const histo,
154                                       const PixOrCopy* const v,
155                                       int (*const distance_modifier)(int, int),
156                                       int distance_modifier_arg0) {
157    if (PixOrCopyIsLiteral(v)) {
158      ++histo->alpha_[PixOrCopyLiteral(v, 3)];
159      ++histo->red_[PixOrCopyLiteral(v, 2)];
160      ++histo->literal_[PixOrCopyLiteral(v, 1)];
161      ++histo->blue_[PixOrCopyLiteral(v, 0)];
162    } else if (PixOrCopyIsCacheIdx(v)) {
163      const int literal_ix =
164          NUM_LITERAL_CODES + NUM_LENGTH_CODES + PixOrCopyCacheIdx(v);
165      ++histo->literal_[literal_ix];
166    } else {
167      int code, extra_bits;
168      VP8LPrefixEncodeBits(PixOrCopyLength(v), &code, &extra_bits);
169      ++histo->literal_[NUM_LITERAL_CODES + code];
170      if (distance_modifier == NULL) {
171        VP8LPrefixEncodeBits(PixOrCopyDistance(v), &code, &extra_bits);
172      } else {
173        VP8LPrefixEncodeBits(
174            distance_modifier(distance_modifier_arg0, PixOrCopyDistance(v)),
175            &code, &extra_bits);
176      }
177      ++histo->distance_[code];
178    }
179  }
180  static WEBP_INLINE double BitsEntropyRefine(const VP8LBitEntropy* entropy) {
181    double mix;
182    if (entropy->nonzeros < 5) {
183      if (entropy->nonzeros <= 1) {
184        return 0;
185      }
186      if (entropy->nonzeros == 2) {
187        return 0.99 * entropy->sum + 0.01 * entropy->entropy;
188      }
189      if (entropy->nonzeros == 3) {
190        mix = 0.95;
191      } else {
192        mix = 0.7;  
193      }
194    } else {
195      mix = 0.627;
196    }
197    {
198      double min_limit = 2 * entropy->sum - entropy->max_val;
199      min_limit = mix * min_limit + (1.0 - mix) * entropy->entropy;
200      return (entropy->entropy < min_limit) ? min_limit : entropy->entropy;
201    }
202  }
203  double VP8LBitsEntropy(const uint32_t* const array, int n) {
204    VP8LBitEntropy entropy;
205    VP8LBitsEntropyUnrefined(array, n, &entropy);
206    return BitsEntropyRefine(&entropy);
207  }
208  static double InitialHuffmanCost(void) {
209    static const int kHuffmanCodeOfHuffmanCodeSize = CODE_LENGTH_CODES * 3;
210    static const double kSmallBias = 9.1;
211    return kHuffmanCodeOfHuffmanCodeSize - kSmallBias;
212  }
213  static double FinalHuffmanCost(const VP8LStreaks* const stats) {
214    double retval = InitialHuffmanCost();
215    retval += stats->counts[0] * 1.5625 + 0.234375 * stats->streaks[0][1];
216    retval += stats->counts[1] * 2.578125 + 0.703125 * stats->streaks[1][1];
217    retval += 1.796875 * stats->streaks[0][0];
218    retval += 3.28125 * stats->streaks[1][0];
219    return retval;
220  }
221  static double PopulationCost(const uint32_t* const population, int length,
222                               uint32_t* const trivial_sym,
223                               uint8_t* const is_used) {
224    VP8LBitEntropy bit_entropy;
225    VP8LStreaks stats;
226    VP8LGetEntropyUnrefined(population, length, &bit_entropy, &stats);
227    if (trivial_sym != NULL) {
228      *trivial_sym = (bit_entropy.nonzeros == 1) ? bit_entropy.nonzero_code
229                                                 : VP8L_NON_TRIVIAL_SYM;
230    }
231    *is_used = (stats.streaks[1][0] != 0 || stats.streaks[1][1] != 0);
232    return BitsEntropyRefine(&bit_entropy) + FinalHuffmanCost(&stats);
233  }
234  static WEBP_INLINE double GetCombinedEntropy(const uint32_t* const X,
235                                               const uint32_t* const Y,
236                                               int length, int is_X_used,
237                                               int is_Y_used,
238                                               int trivial_at_end) {
239    VP8LStreaks stats;
240    if (trivial_at_end) {
241      memset(&stats, 0, sizeof(stats));
242      stats.streaks[1][0] = 1;
243      stats.counts[0] = 1;
244      stats.streaks[0][1] = length - 1;
245      return FinalHuffmanCost(&stats);
246    } else {
247      VP8LBitEntropy bit_entropy;
248      if (is_X_used) {
249        if (is_Y_used) {
250          VP8LGetCombinedEntropyUnrefined(X, Y, length, &bit_entropy, &stats);
251        } else {
252          VP8LGetEntropyUnrefined(X, length, &bit_entropy, &stats);
253        }
254      } else {
255        if (is_Y_used) {
256          VP8LGetEntropyUnrefined(Y, length, &bit_entropy, &stats);
257        } else {
258          memset(&stats, 0, sizeof(stats));
259          stats.counts[0] = 1;
260          stats.streaks[0][length > 3] = length;
261          VP8LBitEntropyInit(&bit_entropy);
262        }
263      }
264      return BitsEntropyRefine(&bit_entropy) + FinalHuffmanCost(&stats);
265    }
266  }
267  double VP8LHistogramEstimateBits(VP8LHistogram* const p) {
268    return
269        PopulationCost(p->literal_, VP8LHistogramNumCodes(p->palette_code_bits_),
270                       NULL, &p->is_used_[0])
271        + PopulationCost(p->red_, NUM_LITERAL_CODES, NULL, &p->is_used_[1])
272        + PopulationCost(p->blue_, NUM_LITERAL_CODES, NULL, &p->is_used_[2])
273        + PopulationCost(p->alpha_, NUM_LITERAL_CODES, NULL, &p->is_used_[3])
274        + PopulationCost(p->distance_, NUM_DISTANCE_CODES, NULL, &p->is_used_[4])
275        + VP8LExtraCost(p->literal_ + NUM_LITERAL_CODES, NUM_LENGTH_CODES)
276        + VP8LExtraCost(p->distance_, NUM_DISTANCE_CODES);
277  }
278  static int GetCombinedHistogramEntropy(const VP8LHistogram* const a,
279                                         const VP8LHistogram* const b,
280                                         double cost_threshold,
281                                         double* cost) {
282    const int palette_code_bits = a->palette_code_bits_;
283    int trivial_at_end = 0;
284    assert(a->palette_code_bits_ == b->palette_code_bits_);
285    *cost += GetCombinedEntropy(a->literal_, b->literal_,
286                                VP8LHistogramNumCodes(palette_code_bits),
287                                a->is_used_[0], b->is_used_[0], 0);
288    *cost += VP8LExtraCostCombined(a->literal_ + NUM_LITERAL_CODES,
289                                   b->literal_ + NUM_LITERAL_CODES,
290                                   NUM_LENGTH_CODES);
291    if (*cost > cost_threshold) return 0;
292    if (a->trivial_symbol_ != VP8L_NON_TRIVIAL_SYM &&
293        a->trivial_symbol_ == b->trivial_symbol_) {
294      const uint32_t color_a = (a->trivial_symbol_ >> 24) & 0xff;
295      const uint32_t color_r = (a->trivial_symbol_ >> 16) & 0xff;
296      const uint32_t color_b = (a->trivial_symbol_ >> 0) & 0xff;
297      if ((color_a == 0 || color_a == 0xff) &&
298          (color_r == 0 || color_r == 0xff) &&
299          (color_b == 0 || color_b == 0xff)) {
300        trivial_at_end = 1;
301      }
302    }
303    *cost +=
304        GetCombinedEntropy(a->red_, b->red_, NUM_LITERAL_CODES, a->is_used_[1],
305                           b->is_used_[1], trivial_at_end);
306    if (*cost > cost_threshold) return 0;
307    *cost +=
308        GetCombinedEntropy(a->blue_, b->blue_, NUM_LITERAL_CODES, a->is_used_[2],
309                           b->is_used_[2], trivial_at_end);
310    if (*cost > cost_threshold) return 0;
311    *cost +=
312        GetCombinedEntropy(a->alpha_, b->alpha_, NUM_LITERAL_CODES,
313                           a->is_used_[3], b->is_used_[3], trivial_at_end);
314    if (*cost > cost_threshold) return 0;
315    *cost +=
316        GetCombinedEntropy(a->distance_, b->distance_, NUM_DISTANCE_CODES,
317                           a->is_used_[4], b->is_used_[4], 0);
318    *cost +=
319        VP8LExtraCostCombined(a->distance_, b->distance_, NUM_DISTANCE_CODES);
320    if (*cost > cost_threshold) return 0;
321    return 1;
322  }
323  static WEBP_INLINE void HistogramAdd(const VP8LHistogram* const a,
324                                       const VP8LHistogram* const b,
325                                       VP8LHistogram* const out) {
326    VP8LHistogramAdd(a, b, out);
327    out->trivial_symbol_ = (a->trivial_symbol_ == b->trivial_symbol_)
328                         ? a->trivial_symbol_
329                         : VP8L_NON_TRIVIAL_SYM;
330  }
331  static double HistogramAddEval(const VP8LHistogram* const a,
332                                 const VP8LHistogram* const b,
333                                 VP8LHistogram* const out,
334                                 double cost_threshold) {
335    double cost = 0;
336    const double sum_cost = a->bit_cost_ + b->bit_cost_;
337    cost_threshold += sum_cost;
338    if (GetCombinedHistogramEntropy(a, b, cost_threshold, &cost)) {
339      HistogramAdd(a, b, out);
340      out->bit_cost_ = cost;
341      out->palette_code_bits_ = a->palette_code_bits_;
342    }
343    return cost - sum_cost;
344  }
345  static double HistogramAddThresh(const VP8LHistogram* const a,
346                                   const VP8LHistogram* const b,
347                                   double cost_threshold) {
348    double cost;
349    assert(a != NULL && b != NULL);
350    cost = -a->bit_cost_;
351    GetCombinedHistogramEntropy(a, b, cost_threshold, &cost);
352    return cost;
353  }
354  typedef struct {
355    double literal_max_;
356    double literal_min_;
357    double red_max_;
358    double red_min_;
359    double blue_max_;
360    double blue_min_;
361  } DominantCostRange;
362  static void DominantCostRangeInit(DominantCostRange* const c) {
363    c->literal_max_ = 0.;
364    c->literal_min_ = MAX_COST;
365    c->red_max_ = 0.;
366    c->red_min_ = MAX_COST;
367    c->blue_max_ = 0.;
368    c->blue_min_ = MAX_COST;
369  }
370  static void UpdateDominantCostRange(
371      const VP8LHistogram* const h, DominantCostRange* const c) {
372    if (c->literal_max_ < h->literal_cost_) c->literal_max_ = h->literal_cost_;
373    if (c->literal_min_ > h->literal_cost_) c->literal_min_ = h->literal_cost_;
374    if (c->red_max_ < h->red_cost_) c->red_max_ = h->red_cost_;
375    if (c->red_min_ > h->red_cost_) c->red_min_ = h->red_cost_;
376    if (c->blue_max_ < h->blue_cost_) c->blue_max_ = h->blue_cost_;
377    if (c->blue_min_ > h->blue_cost_) c->blue_min_ = h->blue_cost_;
378  }
379  static void UpdateHistogramCost(VP8LHistogram* const h) {
380    uint32_t alpha_sym, red_sym, blue_sym;
381    const double alpha_cost =
382        PopulationCost(h->alpha_, NUM_LITERAL_CODES, &alpha_sym,
383                       &h->is_used_[3]);
384    const double distance_cost =
385        PopulationCost(h->distance_, NUM_DISTANCE_CODES, NULL, &h->is_used_[4]) +
386        VP8LExtraCost(h->distance_, NUM_DISTANCE_CODES);
387    const int num_codes = VP8LHistogramNumCodes(h->palette_code_bits_);
388    h->literal_cost_ =
389        PopulationCost(h->literal_, num_codes, NULL, &h->is_used_[0]) +
390            VP8LExtraCost(h->literal_ + NUM_LITERAL_CODES, NUM_LENGTH_CODES);
391    h->red_cost_ =
392        PopulationCost(h->red_, NUM_LITERAL_CODES, &red_sym, &h->is_used_[1]);
393    h->blue_cost_ =
394        PopulationCost(h->blue_, NUM_LITERAL_CODES, &blue_sym, &h->is_used_[2]);
395    h->bit_cost_ = h->literal_cost_ + h->red_cost_ + h->blue_cost_ +
396                   alpha_cost + distance_cost;
397    if ((alpha_sym | red_sym | blue_sym) == VP8L_NON_TRIVIAL_SYM) {
398      h->trivial_symbol_ = VP8L_NON_TRIVIAL_SYM;
399    } else {
400      h->trivial_symbol_ =
401          ((uint32_t)alpha_sym << 24) | (red_sym << 16) | (blue_sym << 0);
402    }
403  }
404  static int GetBinIdForEntropy(double min, double max, double val) {
405    const double range = max - min;
406    if (range > 0.) {
407      const double delta = val - min;
408      return (int)((NUM_PARTITIONS - 1e-6) * delta / range);
409    } else {
410      return 0;
411    }
412  }
413  static int GetHistoBinIndex(const VP8LHistogram* const h,
414                              const DominantCostRange* const c, int low_effort) {
415    int bin_id = GetBinIdForEntropy(c->literal_min_, c->literal_max_,
416                                    h->literal_cost_);
417    assert(bin_id < NUM_PARTITIONS);
418    if (!low_effort) {
419      bin_id = bin_id * NUM_PARTITIONS
420             + GetBinIdForEntropy(c->red_min_, c->red_max_, h->red_cost_);
421      bin_id = bin_id * NUM_PARTITIONS
422             + GetBinIdForEntropy(c->blue_min_, c->blue_max_, h->blue_cost_);
423      assert(bin_id < BIN_SIZE);
424    }
425    return bin_id;
426  }
427  static void HistogramBuild(
428      int xsize, int histo_bits, const VP8LBackwardRefs* const backward_refs,
429      VP8LHistogramSet* const image_histo) {
430    int x = 0, y = 0;
431    const int histo_xsize = VP8LSubSampleSize(xsize, histo_bits);
432    VP8LHistogram** const histograms = image_histo->histograms;
433    VP8LRefsCursor c = VP8LRefsCursorInit(backward_refs);
434    assert(histo_bits > 0);
435    VP8LHistogramSetClear(image_histo);
436    while (VP8LRefsCursorOk(&c)) {
437      const PixOrCopy* const v = c.cur_pos;
438      const int ix = (y >> histo_bits) * histo_xsize + (x >> histo_bits);
439      VP8LHistogramAddSinglePixOrCopy(histograms[ix], v, NULL, 0);
440      x += PixOrCopyLength(v);
441      while (x >= xsize) {
442        x -= xsize;
443        ++y;
444      }
445      VP8LRefsCursorNext(&c);
446    }
447  }
448  static const uint16_t kInvalidHistogramSymbol = (uint16_t)(-1);
449  static void HistogramCopyAndAnalyze(VP8LHistogramSet* const orig_histo,
450                                      VP8LHistogramSet* const image_histo,
451                                      int* const num_used,
452                                      uint16_t* const histogram_symbols) {
453    int i, cluster_id;
454    int num_used_orig = *num_used;
455    VP8LHistogram** const orig_histograms = orig_histo->histograms;
456    VP8LHistogram** const histograms = image_histo->histograms;
457    assert(image_histo->max_size == orig_histo->max_size);
458    for (cluster_id = 0, i = 0; i < orig_histo->max_size; ++i) {
459      VP8LHistogram* const histo = orig_histograms[i];
460      UpdateHistogramCost(histo);
461      if (!histo->is_used_[0] && !histo->is_used_[1] && !histo->is_used_[2]
462          && !histo->is_used_[3] && !histo->is_used_[4]) {
463        assert(i > 0);
464        HistogramSetRemoveHistogram(image_histo, i, num_used);
465        HistogramSetRemoveHistogram(orig_histo, i, &num_used_orig);
466        histogram_symbols[i] = kInvalidHistogramSymbol;
467      } else {
468        HistogramCopy(histo, histograms[i]);
469        histogram_symbols[i] = cluster_id++;
470        assert(cluster_id <= image_histo->max_size);
471      }
472    }
473  }
474  static void HistogramAnalyzeEntropyBin(VP8LHistogramSet* const image_histo,
475                                         uint16_t* const bin_map,
476                                         int low_effort) {
477    int i;
478    VP8LHistogram** const histograms = image_histo->histograms;
479    const int histo_size = image_histo->size;
480    DominantCostRange cost_range;
481    DominantCostRangeInit(&cost_range);
482    for (i = 0; i < histo_size; ++i) {
483      if (histograms[i] == NULL) continue;
484      UpdateDominantCostRange(histograms[i], &cost_range);
485    }
486    for (i = 0; i < histo_size; ++i) {
487      if (histograms[i] == NULL) continue;
488      bin_map[i] = GetHistoBinIndex(histograms[i], &cost_range, low_effort);
489    }
490  }
491  static void HistogramCombineEntropyBin(VP8LHistogramSet* const image_histo,
492                                         int* num_used,
493                                         const uint16_t* const clusters,
494                                         uint16_t* const cluster_mappings,
495                                         VP8LHistogram* cur_combo,
496                                         const uint16_t* const bin_map,
497                                         int num_bins,
498                                         double combine_cost_factor,
499                                         int low_effort) {
500    VP8LHistogram** const histograms = image_histo->histograms;
501    int idx;
502    struct {
503      int16_t first;    
504      uint16_t num_combine_failures;   
505    } bin_info[BIN_SIZE];
506    assert(num_bins <= BIN_SIZE);
507    for (idx = 0; idx < num_bins; ++idx) {
508      bin_info[idx].first = -1;
509      bin_info[idx].num_combine_failures = 0;
510    }
511    for (idx = 0; idx < *num_used; ++idx) cluster_mappings[idx] = idx;
512    for (idx = 0; idx < image_histo->size; ++idx) {
513      int bin_id, first;
514      if (histograms[idx] == NULL) continue;
515      bin_id = bin_map[idx];
516      first = bin_info[bin_id].first;
517      if (first == -1) {
518        bin_info[bin_id].first = idx;
519      } else if (low_effort) {
520        HistogramAdd(histograms[idx], histograms[first], histograms[first]);
521        HistogramSetRemoveHistogram(image_histo, idx, num_used);
522        cluster_mappings[clusters[idx]] = clusters[first];
523      } else {
524        const double bit_cost = histograms[idx]->bit_cost_;
525        const double bit_cost_thresh = -bit_cost * combine_cost_factor;
526        const double curr_cost_diff =
527            HistogramAddEval(histograms[first], histograms[idx],
528                             cur_combo, bit_cost_thresh);
529        if (curr_cost_diff < bit_cost_thresh) {
530          const int try_combine =
531              (cur_combo->trivial_symbol_ != VP8L_NON_TRIVIAL_SYM) ||
532              ((histograms[idx]->trivial_symbol_ == VP8L_NON_TRIVIAL_SYM) &&
533               (histograms[first]->trivial_symbol_ == VP8L_NON_TRIVIAL_SYM));
534          const int max_combine_failures = 32;
535          if (try_combine ||
536              bin_info[bin_id].num_combine_failures >= max_combine_failures) {
537            HistogramSwap(&cur_combo, &histograms[first]);
538            HistogramSetRemoveHistogram(image_histo, idx, num_used);
539            cluster_mappings[clusters[idx]] = clusters[first];
540          } else {
541            ++bin_info[bin_id].num_combine_failures;
542          }
543        }
544      }
545    }
546    if (low_effort) {
547      for (idx = 0; idx < image_histo->size; ++idx) {
548        if (histograms[idx] == NULL) continue;
549        UpdateHistogramCost(histograms[idx]);
550      }
551    }
552  }
553  static uint32_t MyRand(uint32_t* const seed) {
554    *seed = (uint32_t)(((uint64_t)(*seed) * 48271u) % 2147483647u);
555    assert(*seed > 0);
556    return *seed;
557  }
558  typedef struct {
559    int idx1;
560    int idx2;
561    double cost_diff;
562    double cost_combo;
563  } HistogramPair;
564  typedef struct {
565    HistogramPair* queue;
566    int size;
567    int max_size;
568  } HistoQueue;
569  static int HistoQueueInit(HistoQueue* const histo_queue, const int max_size) {
570    histo_queue->size = 0;
571    histo_queue->max_size = max_size;
572    histo_queue->queue = (HistogramPair*)WebPSafeMalloc(
573        histo_queue->max_size + 1, sizeof(*histo_queue->queue));
574    return histo_queue->queue != NULL;
575  }
576  static void HistoQueueClear(HistoQueue* const histo_queue) {
577    assert(histo_queue != NULL);
578    WebPSafeFree(histo_queue->queue);
579    histo_queue->size = 0;
580    histo_queue->max_size = 0;
581  }
582  static void HistoQueuePopPair(HistoQueue* const histo_queue,
583                                HistogramPair* const pair) {
<span onclick='openModal()' class='match'>584    assert(pair >= histo_queue->queue &&
585           pair < (histo_queue->queue + histo_queue->size));
586    assert(histo_queue->size > 0);
</span>587    *pair = histo_queue->queue[histo_queue->size - 1];
588    --histo_queue->size;
589  }
590  static void HistoQueueUpdateHead(HistoQueue* const histo_queue,
591                                   HistogramPair* const pair) {
592    assert(pair->cost_diff < 0.);
593    assert(pair >= histo_queue->queue &&
594           pair < (histo_queue->queue + histo_queue->size));
595    assert(histo_queue->size > 0);
596    if (pair->cost_diff < histo_queue->queue[0].cost_diff) {
597      const HistogramPair tmp = histo_queue->queue[0];
598      histo_queue->queue[0] = *pair;
599      *pair = tmp;
600    }
601  }
602  static void HistoQueueUpdatePair(const VP8LHistogram* const h1,
603                                   const VP8LHistogram* const h2,
604                                   double threshold,
605                                   HistogramPair* const pair) {
606    const double sum_cost = h1->bit_cost_ + h2->bit_cost_;
607    pair->cost_combo = 0.;
608    GetCombinedHistogramEntropy(h1, h2, sum_cost + threshold, &pair->cost_combo);
609    pair->cost_diff = pair->cost_combo - sum_cost;
610  }
611  static double HistoQueuePush(HistoQueue* const histo_queue,
612                               VP8LHistogram** const histograms, int idx1,
613                               int idx2, double threshold) {
614    const VP8LHistogram* h1;
615    const VP8LHistogram* h2;
616    HistogramPair pair;
617    if (histo_queue->size == histo_queue->max_size) return 0.;
618    assert(threshold <= 0.);
619    if (idx1 > idx2) {
620      const int tmp = idx2;
621      idx2 = idx1;
622      idx1 = tmp;
623    }
624    pair.idx1 = idx1;
625    pair.idx2 = idx2;
626    h1 = histograms[idx1];
627    h2 = histograms[idx2];
628    HistoQueueUpdatePair(h1, h2, threshold, &pair);
629    if (pair.cost_diff >= threshold) return 0.;
630    histo_queue->queue[histo_queue->size++] = pair;
631    HistoQueueUpdateHead(histo_queue, &histo_queue->queue[histo_queue->size - 1]);
632    return pair.cost_diff;
633  }
634  static int HistogramCombineGreedy(VP8LHistogramSet* const image_histo,
635                                    int* const num_used) {
636    int ok = 0;
637    const int image_histo_size = image_histo->size;
638    int i, j;
639    VP8LHistogram** const histograms = image_histo->histograms;
640    HistoQueue histo_queue;
641    if (!HistoQueueInit(&histo_queue, image_histo_size * image_histo_size)) {
642      goto End;
643    }
644    for (i = 0; i < image_histo_size; ++i) {
645      if (image_histo->histograms[i] == NULL) continue;
646      for (j = i + 1; j < image_histo_size; ++j) {
647        if (image_histo->histograms[j] == NULL) continue;
648        HistoQueuePush(&histo_queue, histograms, i, j, 0.);
649      }
650    }
651    while (histo_queue.size > 0) {
652      const int idx1 = histo_queue.queue[0].idx1;
653      const int idx2 = histo_queue.queue[0].idx2;
654      HistogramAdd(histograms[idx2], histograms[idx1], histograms[idx1]);
655      histograms[idx1]->bit_cost_ = histo_queue.queue[0].cost_combo;
656      HistogramSetRemoveHistogram(image_histo, idx2, num_used);
657      for (i = 0; i < histo_queue.size;) {
658        HistogramPair* const p = histo_queue.queue + i;
659        if (p->idx1 == idx1 || p->idx2 == idx1 ||
660            p->idx1 == idx2 || p->idx2 == idx2) {
661          HistoQueuePopPair(&histo_queue, p);
662        } else {
663          HistoQueueUpdateHead(&histo_queue, p);
664          ++i;
665        }
666      }
667      for (i = 0; i < image_histo->size; ++i) {
668        if (i == idx1 || image_histo->histograms[i] == NULL) continue;
669        HistoQueuePush(&histo_queue, image_histo->histograms, idx1, i, 0.);
670      }
671    }
672    ok = 1;
673   End:
674    HistoQueueClear(&histo_queue);
675    return ok;
676  }
677  static int PairComparison(const void* idx1, const void* idx2) {
678    return (*(int*) idx1 - *(int*) idx2);
679  }
680  static int HistogramCombineStochastic(VP8LHistogramSet* const image_histo,
681                                        int* const num_used, int min_cluster_size,
682                                        int* const do_greedy) {
683    int j, iter;
684    uint32_t seed = 1;
685    int tries_with_no_success = 0;
686    const int outer_iters = *num_used;
687    const int num_tries_no_success = outer_iters / 2;
688    VP8LHistogram** const histograms = image_histo->histograms;
689    HistoQueue histo_queue;
690    const int kHistoQueueSize = 9;
691    int ok = 0;
692    int* mappings;
693    if (*num_used < min_cluster_size) {
694      *do_greedy = 1;
695      return 1;
696    }
697    mappings = (int*) WebPSafeMalloc(*num_used, sizeof(*mappings));
698    if (mappings == NULL) return 0;
699    if (!HistoQueueInit(&histo_queue, kHistoQueueSize)) goto End;
700    for (j = 0, iter = 0; iter < image_histo->size; ++iter) {
701      if (histograms[iter] == NULL) continue;
702      mappings[j++] = iter;
703    }
704    assert(j == *num_used);
705    for (iter = 0;
706         iter < outer_iters && *num_used >= min_cluster_size &&
707             ++tries_with_no_success < num_tries_no_success;
708         ++iter) {
709      int* mapping_index;
710      double best_cost =
711          (histo_queue.size == 0) ? 0. : histo_queue.queue[0].cost_diff;
712      int best_idx1 = -1, best_idx2 = 1;
713      const uint32_t rand_range = (*num_used - 1) * (*num_used);
714      const int num_tries = (*num_used) / 2;
715      for (j = 0; *num_used >= 2 && j < num_tries; ++j) {
716        double curr_cost;
717        const uint32_t tmp = MyRand(&seed) % rand_range;
718        uint32_t idx1 = tmp / (*num_used - 1);
719        uint32_t idx2 = tmp % (*num_used - 1);
720        if (idx2 >= idx1) ++idx2;
721        idx1 = mappings[idx1];
722        idx2 = mappings[idx2];
723        curr_cost =
724            HistoQueuePush(&histo_queue, histograms, idx1, idx2, best_cost);
725        if (curr_cost < 0) {  
726          best_cost = curr_cost;
727          if (histo_queue.size == histo_queue.max_size) break;
728        }
729      }
730      if (histo_queue.size == 0) continue;
731      best_idx1 = histo_queue.queue[0].idx1;
732      best_idx2 = histo_queue.queue[0].idx2;
733      assert(best_idx1 < best_idx2);
734      mapping_index = (int*) bsearch(&best_idx2, mappings, *num_used,
735                                     sizeof(best_idx2), &PairComparison);
736      assert(mapping_index != NULL);
737      memmove(mapping_index, mapping_index + 1, sizeof(*mapping_index) *
738          ((*num_used) - (mapping_index - mappings) - 1));
739      HistogramAdd(histograms[best_idx2], histograms[best_idx1],
740                   histograms[best_idx1]);
741      histograms[best_idx1]->bit_cost_ = histo_queue.queue[0].cost_combo;
742      HistogramSetRemoveHistogram(image_histo, best_idx2, num_used);
743      for (j = 0; j < histo_queue.size;) {
744        HistogramPair* const p = histo_queue.queue + j;
745        const int is_idx1_best = p->idx1 == best_idx1 || p->idx1 == best_idx2;
746        const int is_idx2_best = p->idx2 == best_idx1 || p->idx2 == best_idx2;
747        int do_eval = 0;
748        if (is_idx1_best && is_idx2_best) {
749          HistoQueuePopPair(&histo_queue, p);
750          continue;
751        }
752        if (is_idx1_best) {
753          p->idx1 = best_idx1;
754          do_eval = 1;
755        } else if (is_idx2_best) {
756          p->idx2 = best_idx1;
757          do_eval = 1;
758        }
759        if (p->idx1 > p->idx2) {
760          const int tmp = p->idx2;
761          p->idx2 = p->idx1;
762          p->idx1 = tmp;
763        }
764        if (do_eval) {
765          HistoQueueUpdatePair(histograms[p->idx1], histograms[p->idx2], 0., p);
766          if (p->cost_diff >= 0.) {
767            HistoQueuePopPair(&histo_queue, p);
768            continue;
769          }
770        }
771        HistoQueueUpdateHead(&histo_queue, p);
772        ++j;
773      }
774      tries_with_no_success = 0;
775    }
776    *do_greedy = (*num_used <= min_cluster_size);
777    ok = 1;
778  End:
779    HistoQueueClear(&histo_queue);
780    WebPSafeFree(mappings);
781    return ok;
782  }
783  static void HistogramRemap(const VP8LHistogramSet* const in,
784                             VP8LHistogramSet* const out,
785                             uint16_t* const symbols) {
786    int i;
787    VP8LHistogram** const in_histo = in->histograms;
788    VP8LHistogram** const out_histo = out->histograms;
789    const int in_size = out->max_size;
790    const int out_size = out->size;
791    if (out_size > 1) {
792      for (i = 0; i < in_size; ++i) {
793        int best_out = 0;
794        double best_bits = MAX_COST;
795        int k;
796        if (in_histo[i] == NULL) {
797          symbols[i] = symbols[i - 1];
798          continue;
799        }
800        for (k = 0; k < out_size; ++k) {
801          double cur_bits;
802          cur_bits = HistogramAddThresh(out_histo[k], in_histo[i], best_bits);
803          if (k == 0 || cur_bits < best_bits) {
804            best_bits = cur_bits;
805            best_out = k;
806          }
807        }
808        symbols[i] = best_out;
809      }
810    } else {
811      assert(out_size == 1);
812      for (i = 0; i < in_size; ++i) {
813        symbols[i] = 0;
814      }
815    }
816    VP8LHistogramSetClear(out);
817    out->size = out_size;
818    for (i = 0; i < in_size; ++i) {
819      int idx;
820      if (in_histo[i] == NULL) continue;
821      idx = symbols[i];
822      HistogramAdd(in_histo[i], out_histo[idx], out_histo[idx]);
823    }
824  }
825  static double GetCombineCostFactor(int histo_size, int quality) {
826    double combine_cost_factor = 0.16;
827    if (quality < 90) {
828      if (histo_size > 256) combine_cost_factor /= 2.;
829      if (histo_size > 512) combine_cost_factor /= 2.;
830      if (histo_size > 1024) combine_cost_factor /= 2.;
831      if (quality <= 50) combine_cost_factor /= 2.;
832    }
833    return combine_cost_factor;
834  }
835  static void OptimizeHistogramSymbols(const VP8LHistogramSet* const set,
836                                       uint16_t* const cluster_mappings,
837                                       int num_clusters,
838                                       uint16_t* const cluster_mappings_tmp,
839                                       uint16_t* const symbols) {
840    int i, cluster_max;
841    int do_continue = 1;
842    while (do_continue) {
843      do_continue = 0;
844      for (i = 0; i < num_clusters; ++i) {
845        int k;
846        k = cluster_mappings[i];
847        while (k != cluster_mappings[k]) {
848          cluster_mappings[k] = cluster_mappings[cluster_mappings[k]];
849          k = cluster_mappings[k];
850        }
851        if (k != cluster_mappings[i]) {
852          do_continue = 1;
853          cluster_mappings[i] = k;
854        }
855      }
856    }
857    cluster_max = 0;
858    memset(cluster_mappings_tmp, 0,
859           set->max_size * sizeof(*cluster_mappings_tmp));
860    assert(cluster_mappings[0] == 0);
861    for (i = 0; i < set->max_size; ++i) {
862      int cluster;
863      if (symbols[i] == kInvalidHistogramSymbol) continue;
864      cluster = cluster_mappings[symbols[i]];
865      assert(symbols[i] < num_clusters);
866      if (cluster > 0 && cluster_mappings_tmp[cluster] == 0) {
867        ++cluster_max;
868        cluster_mappings_tmp[cluster] = cluster_max;
869      }
870      symbols[i] = cluster_mappings_tmp[cluster];
871    }
872    cluster_max = 0;
873    for (i = 0; i < set->max_size; ++i) {
874      if (symbols[i] == kInvalidHistogramSymbol) continue;
875      if (symbols[i] <= cluster_max) continue;
876      ++cluster_max;
877      assert(symbols[i] == cluster_max);
878    }
879  }
880  static void RemoveEmptyHistograms(VP8LHistogramSet* const image_histo) {
881    uint32_t size;
882    int i;
883    for (i = 0, size = 0; i < image_histo->size; ++i) {
884      if (image_histo->histograms[i] == NULL) continue;
885      image_histo->histograms[size++] = image_histo->histograms[i];
886    }
887    image_histo->size = size;
888  }
889  int VP8LGetHistoImageSymbols(int xsize, int ysize,
890                               const VP8LBackwardRefs* const refs,
891                               int quality, int low_effort,
892                               int histo_bits, int cache_bits,
893                               VP8LHistogramSet* const image_histo,
894                               VP8LHistogram* const tmp_histo,
895                               uint16_t* const histogram_symbols) {
896    int ok = 0;
897    const int histo_xsize = histo_bits ? VP8LSubSampleSize(xsize, histo_bits) : 1;
898    const int histo_ysize = histo_bits ? VP8LSubSampleSize(ysize, histo_bits) : 1;
899    const int image_histo_raw_size = histo_xsize * histo_ysize;
900    VP8LHistogramSet* const orig_histo =
901        VP8LAllocateHistogramSet(image_histo_raw_size, cache_bits);
902    const int entropy_combine_num_bins = low_effort ? NUM_PARTITIONS : BIN_SIZE;
903    int entropy_combine;
904    uint16_t* const map_tmp =
905        WebPSafeMalloc(2 * image_histo_raw_size, sizeof(map_tmp));
906    uint16_t* const cluster_mappings = map_tmp + image_histo_raw_size;
907    int num_used = image_histo_raw_size;
908    if (orig_histo == NULL || map_tmp == NULL) goto Error;
909    HistogramBuild(xsize, histo_bits, refs, orig_histo);
910    HistogramCopyAndAnalyze(orig_histo, image_histo, &num_used,
911                            histogram_symbols);
912    entropy_combine =
913        (num_used > entropy_combine_num_bins * 2) && (quality < 100);
914    if (entropy_combine) {
915      uint16_t* const bin_map = map_tmp;
916      const double combine_cost_factor =
917          GetCombineCostFactor(image_histo_raw_size, quality);
918      const uint32_t num_clusters = num_used;
919      HistogramAnalyzeEntropyBin(image_histo, bin_map, low_effort);
920      HistogramCombineEntropyBin(image_histo, &num_used, histogram_symbols,
921                                 cluster_mappings, tmp_histo, bin_map,
922                                 entropy_combine_num_bins, combine_cost_factor,
923                                 low_effort);
924      OptimizeHistogramSymbols(image_histo, cluster_mappings, num_clusters,
925                               map_tmp, histogram_symbols);
926    }
927    if (!low_effort || !entropy_combine) {
928      const float x = quality / 100.f;
929      const int threshold_size = (int)(1 + (x * x * x) * (MAX_HISTO_GREEDY - 1));
930      int do_greedy;
931      if (!HistogramCombineStochastic(image_histo, &num_used, threshold_size,
932                                      &do_greedy)) {
933        goto Error;
934      }
935      if (do_greedy) {
936        RemoveEmptyHistograms(image_histo);
937        if (!HistogramCombineGreedy(image_histo, &num_used)) {
938          goto Error;
939        }
940      }
941    }
942    RemoveEmptyHistograms(image_histo);
943    HistogramRemap(orig_histo, image_histo, histogram_symbols);
944    ok = 1;
945   Error:
946    VP8LFreeHistogramSet(orig_histo);
947    WebPSafeFree(map_tmp);
948    return ok;
949  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from PINRemoteImage-MDEwOlJlcG9zaXRvcnkzOTUzNzEwMw==-flat-anim_decode.c</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from PINRemoteImage-MDEwOlJlcG9zaXRvcnkzOTUzNzEwMw==-flat-histogram_enc.c</div>
                </div>
                <div class="column column_space"><pre><code>215    assert(canvas_y >= src->y_offset && canvas_y < (src->y_offset + src->height));
216    *left1 = -1;
</pre></code></div>
                <div class="column column_space"><pre><code>584    assert(pair >= histo_queue->queue &&
585           pair < (histo_queue->queue + histo_queue->size));
586    assert(histo_queue->size > 0);
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    