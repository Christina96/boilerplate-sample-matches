
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 79, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>Adafruit_nRF52_Arduino-MDEwOlJlcG9zaXRvcnk3NDM1NDcyOQ==-flat-nrf_soc.h</h3>
            <pre><code>1  #ifndef NRF_SOC_H__
2  #define NRF_SOC_H__
3  #include <stdint.h>
4  #include "nrf.h"
5  #include "nrf_svc.h"
6  #include "nrf_error.h"
7  #include "nrf_error_soc.h"
8  #ifdef __cplusplus
9  extern "C" {
10  #endif
11  #define SOC_SVC_BASE               (0x20)                   &bsol;**< Base value for SVCs that are available when the SoftDevice is disabled. */
12  #define SOC_SVC_BASE_NOT_AVAILABLE (0x2C)                   &bsol;**< Base value for SVCs that are not available when the SoftDevice is disabled. */
13  #define NRF_RADIO_NOTIFICATION_INACTIVE_GUARANTEED_TIME_US  (62)
14  #define NRF_RADIO_MINIMUM_TIMESLOT_LENGTH_EXTENSION_TIME_US (200)
15  #define NRF_RADIO_MAX_EXTENSION_PROCESSING_TIME_US           (17)
16  #define NRF_RADIO_MIN_EXTENSION_MARGIN_US                    (79)
17  #define SOC_ECB_KEY_LENGTH                (16)                       &bsol;**< ECB key length. */
18  #define SOC_ECB_CLEARTEXT_LENGTH          (16)                       &bsol;**< ECB cleartext length. */
19  #define SOC_ECB_CIPHERTEXT_LENGTH         (SOC_ECB_CLEARTEXT_LENGTH) &bsol;**< ECB ciphertext length. */
20  #define SD_EVT_IRQn                       (SWI2_IRQn)        &bsol;**< SoftDevice Event IRQ number. Used for both protocol events and SoC events. */
21  #define SD_EVT_IRQHandler                 (SWI2_IRQHandler)  &bsol;**< SoftDevice Event IRQ handler. Used for both protocol events and SoC events.
22                                                                         The default interrupt priority for this handler is set to 6 */
23  #define RADIO_NOTIFICATION_IRQn           (SWI1_IRQn)        &bsol;**< The radio notification IRQ number. */
24  #define RADIO_NOTIFICATION_IRQHandler     (SWI1_IRQHandler)  &bsol;**< The radio notification IRQ handler.
25                                                                         The default interrupt priority for this handler is set to 6 */
26  #define NRF_RADIO_LENGTH_MIN_US           (100)               &bsol;**< The shortest allowed radio timeslot, in microseconds. */
27  #define NRF_RADIO_LENGTH_MAX_US           (100000)            &bsol;**< The longest allowed radio timeslot, in microseconds. */
28  #define NRF_RADIO_DISTANCE_MAX_US         (128000000UL - 1UL) &bsol;**< The longest timeslot distance, in microseconds, allowed for the distance parameter (see @ref nrf_radio_request_normal_t) in the request. */
29  #define NRF_RADIO_EARLIEST_TIMEOUT_MAX_US (128000000UL - 1UL) &bsol;**< The longest timeout, in microseconds, allowed when requesting the earliest possible timeslot. */
30  #define NRF_RADIO_START_JITTER_US         (2)                 &bsol;**< The maximum jitter in @ref NRF_RADIO_CALLBACK_SIGNAL_TYPE_START relative to the requested start time. */
31  #define NRF_SOC_SD_PPI_CHANNELS_SD_DISABLED_MSK ((uint32_t)(0))
32  #define NRF_SOC_SD_PPI_CHANNELS_SD_ENABLED_MSK  ((uint32_t)( \
33        (1U << 17) \
34      | (1U << 18) \
35      | (1U << 19) \
36      | (1U << 20) \
37      | (1U << 21) \
38      | (1U << 22) \
39      | (1U << 23) \
40      | (1U << 24) \
41      | (1U << 25) \
42      | (1U << 26) \
43      | (1U << 27) \
44      | (1U << 28) \
45      | (1U << 29) \
46      | (1U << 30) \
47      | (1U << 31) \
48    ))
49  #define NRF_SOC_APP_PPI_CHANNELS_SD_DISABLED_MSK (~NRF_SOC_SD_PPI_CHANNELS_SD_DISABLED_MSK)
50  #define NRF_SOC_APP_PPI_CHANNELS_SD_ENABLED_MSK  (~NRF_SOC_SD_PPI_CHANNELS_SD_ENABLED_MSK)
51  #define NRF_SOC_SD_PPI_GROUPS_SD_DISABLED_MSK    ((uint32_t)(0))
52  #define NRF_SOC_SD_PPI_GROUPS_SD_ENABLED_MSK     ((uint32_t)( \
53        (1U << 4) \
54      | (1U << 5) \
55    ))
56  #define NRF_SOC_APP_PPI_GROUPS_SD_DISABLED_MSK   (~NRF_SOC_SD_PPI_GROUPS_SD_DISABLED_MSK)
57  #define NRF_SOC_APP_PPI_GROUPS_SD_ENABLED_MSK    (~NRF_SOC_SD_PPI_GROUPS_SD_ENABLED_MSK)
58  enum NRF_SOC_SVCS
59  {
60    SD_PPI_CHANNEL_ENABLE_GET   = SOC_SVC_BASE,
61    SD_PPI_CHANNEL_ENABLE_SET   = SOC_SVC_BASE + 1,
62    SD_PPI_CHANNEL_ENABLE_CLR   = SOC_SVC_BASE + 2,
63    SD_PPI_CHANNEL_ASSIGN       = SOC_SVC_BASE + 3,
64    SD_PPI_GROUP_TASK_ENABLE    = SOC_SVC_BASE + 4,
65    SD_PPI_GROUP_TASK_DISABLE   = SOC_SVC_BASE + 5,
66    SD_PPI_GROUP_ASSIGN         = SOC_SVC_BASE + 6,
67    SD_PPI_GROUP_GET            = SOC_SVC_BASE + 7,
68    SD_FLASH_PAGE_ERASE         = SOC_SVC_BASE + 8,
69    SD_FLASH_WRITE              = SOC_SVC_BASE + 9,
70    SD_FLASH_PROTECT            = SOC_SVC_BASE + 10,
71    SD_PROTECTED_REGISTER_WRITE = SOC_SVC_BASE + 11,
72    SD_MUTEX_NEW                            = SOC_SVC_BASE_NOT_AVAILABLE,
73    SD_MUTEX_ACQUIRE                        = SOC_SVC_BASE_NOT_AVAILABLE + 1,
74    SD_MUTEX_RELEASE                        = SOC_SVC_BASE_NOT_AVAILABLE + 2,
75    SD_RAND_APPLICATION_POOL_CAPACITY_GET   = SOC_SVC_BASE_NOT_AVAILABLE + 3,
76    SD_RAND_APPLICATION_BYTES_AVAILABLE_GET = SOC_SVC_BASE_NOT_AVAILABLE + 4,
77    SD_RAND_APPLICATION_VECTOR_GET          = SOC_SVC_BASE_NOT_AVAILABLE + 5,
78    SD_POWER_MODE_SET                       = SOC_SVC_BASE_NOT_AVAILABLE + 6,
79    SD_POWER_SYSTEM_OFF                     = SOC_SVC_BASE_NOT_AVAILABLE + 7,
80    SD_POWER_RESET_REASON_GET               = SOC_SVC_BASE_NOT_AVAILABLE + 8,
81    SD_POWER_RESET_REASON_CLR               = SOC_SVC_BASE_NOT_AVAILABLE + 9,
82    SD_POWER_POF_ENABLE                     = SOC_SVC_BASE_NOT_AVAILABLE + 10,
83    SD_POWER_POF_THRESHOLD_SET              = SOC_SVC_BASE_NOT_AVAILABLE + 11,
84    SD_POWER_RAM_POWER_SET                  = SOC_SVC_BASE_NOT_AVAILABLE + 13,
85    SD_POWER_RAM_POWER_CLR                  = SOC_SVC_BASE_NOT_AVAILABLE + 14,
86    SD_POWER_RAM_POWER_GET                  = SOC_SVC_BASE_NOT_AVAILABLE + 15,
87    SD_POWER_GPREGRET_SET                   = SOC_SVC_BASE_NOT_AVAILABLE + 16,
88    SD_POWER_GPREGRET_CLR                   = SOC_SVC_BASE_NOT_AVAILABLE + 17,
89    SD_POWER_GPREGRET_GET                   = SOC_SVC_BASE_NOT_AVAILABLE + 18,
90    SD_POWER_DCDC_MODE_SET                  = SOC_SVC_BASE_NOT_AVAILABLE + 19,
91    SD_APP_EVT_WAIT                         = SOC_SVC_BASE_NOT_AVAILABLE + 21,
92    SD_CLOCK_HFCLK_REQUEST                  = SOC_SVC_BASE_NOT_AVAILABLE + 22,
93    SD_CLOCK_HFCLK_RELEASE                  = SOC_SVC_BASE_NOT_AVAILABLE + 23,
94    SD_CLOCK_HFCLK_IS_RUNNING               = SOC_SVC_BASE_NOT_AVAILABLE + 24,
95    SD_RADIO_NOTIFICATION_CFG_SET           = SOC_SVC_BASE_NOT_AVAILABLE + 25,
96    SD_ECB_BLOCK_ENCRYPT                    = SOC_SVC_BASE_NOT_AVAILABLE + 26,
97    SD_ECB_BLOCKS_ENCRYPT                   = SOC_SVC_BASE_NOT_AVAILABLE + 27,
98    SD_RADIO_SESSION_OPEN                   = SOC_SVC_BASE_NOT_AVAILABLE + 28,
99    SD_RADIO_SESSION_CLOSE                  = SOC_SVC_BASE_NOT_AVAILABLE + 29,
100    SD_RADIO_REQUEST                        = SOC_SVC_BASE_NOT_AVAILABLE + 30,
101    SD_EVT_GET                              = SOC_SVC_BASE_NOT_AVAILABLE + 31,
102    SD_TEMP_GET                             = SOC_SVC_BASE_NOT_AVAILABLE + 32,
103    SVC_SOC_LAST                            = SOC_SVC_BASE_NOT_AVAILABLE + 37
104  };
105  enum NRF_MUTEX_VALUES
106  {
107    NRF_MUTEX_FREE,
108    NRF_MUTEX_TAKEN
109  };
110  enum NRF_POWER_MODES
111  {
112    NRF_POWER_MODE_CONSTLAT,  &bsol;**< Constant latency mode. See power management in the reference manual. */
113    NRF_POWER_MODE_LOWPWR     &bsol;**< Low power mode. See power management in the reference manual. */
114  };
115  enum NRF_POWER_THRESHOLDS
116  {
117    NRF_POWER_THRESHOLD_V17 = 4UL, &bsol;**< 1.7 Volts power failure threshold. */
118    NRF_POWER_THRESHOLD_V18,       &bsol;**< 1.8 Volts power failure threshold. */
119    NRF_POWER_THRESHOLD_V19,       &bsol;**< 1.9 Volts power failure threshold. */
120    NRF_POWER_THRESHOLD_V20,       &bsol;**< 2.0 Volts power failure threshold. */
121    NRF_POWER_THRESHOLD_V21,       &bsol;**< 2.1 Volts power failure threshold. */
122    NRF_POWER_THRESHOLD_V22,       &bsol;**< 2.2 Volts power failure threshold. */
123    NRF_POWER_THRESHOLD_V23,       &bsol;**< 2.3 Volts power failure threshold. */
124    NRF_POWER_THRESHOLD_V24,       &bsol;**< 2.4 Volts power failure threshold. */
125    NRF_POWER_THRESHOLD_V25,       &bsol;**< 2.5 Volts power failure threshold. */
126    NRF_POWER_THRESHOLD_V26,       &bsol;**< 2.6 Volts power failure threshold. */
127    NRF_POWER_THRESHOLD_V27,       &bsol;**< 2.7 Volts power failure threshold. */
128    NRF_POWER_THRESHOLD_V28        &bsol;**< 2.8 Volts power failure threshold. */
129  };
130  enum NRF_POWER_DCDC_MODES
131  {
132    NRF_POWER_DCDC_DISABLE,          &bsol;**< The DCDC is disabled. */
133    NRF_POWER_DCDC_ENABLE            &bsol;**< The DCDC is enabled.  */
134  };
135  enum NRF_RADIO_NOTIFICATION_DISTANCES
136  {
137    NRF_RADIO_NOTIFICATION_DISTANCE_NONE = 0, &bsol;**< The event does not have a notification. */
138    NRF_RADIO_NOTIFICATION_DISTANCE_800US,    &bsol;**< The distance from the active notification to start of radio activity. */
139    NRF_RADIO_NOTIFICATION_DISTANCE_1740US,   &bsol;**< The distance from the active notification to start of radio activity. */
140    NRF_RADIO_NOTIFICATION_DISTANCE_2680US,   &bsol;**< The distance from the active notification to start of radio activity. */
141    NRF_RADIO_NOTIFICATION_DISTANCE_3620US,   &bsol;**< The distance from the active notification to start of radio activity. */
142    NRF_RADIO_NOTIFICATION_DISTANCE_4560US,   &bsol;**< The distance from the active notification to start of radio activity. */
143    NRF_RADIO_NOTIFICATION_DISTANCE_5500US    &bsol;**< The distance from the active notification to start of radio activity. */
144  };
145  enum NRF_RADIO_NOTIFICATION_TYPES
146  {
147    NRF_RADIO_NOTIFICATION_TYPE_NONE = 0,        &bsol;**< The event does not have a radio notification signal. */
148    NRF_RADIO_NOTIFICATION_TYPE_INT_ON_ACTIVE,   &bsol;**< Using interrupt for notification when the radio will be enabled. */
149    NRF_RADIO_NOTIFICATION_TYPE_INT_ON_INACTIVE, &bsol;**< Using interrupt for notification when the radio has been disabled. */
150    NRF_RADIO_NOTIFICATION_TYPE_INT_ON_BOTH,     &bsol;**< Using interrupt for notification both when the radio will be enabled and disabled. */
151  };
152  enum NRF_RADIO_CALLBACK_SIGNAL_TYPE
153  {
154    NRF_RADIO_CALLBACK_SIGNAL_TYPE_START,             &bsol;**< This signal indicates the start of the radio timeslot. */
155    NRF_RADIO_CALLBACK_SIGNAL_TYPE_TIMER0,            &bsol;**< This signal indicates the NRF_TIMER0 interrupt. */
156    NRF_RADIO_CALLBACK_SIGNAL_TYPE_RADIO,             &bsol;**< This signal indicates the NRF_RADIO interrupt. */
157    NRF_RADIO_CALLBACK_SIGNAL_TYPE_EXTEND_FAILED,     &bsol;**< This signal indicates extend action failed. */
158    NRF_RADIO_CALLBACK_SIGNAL_TYPE_EXTEND_SUCCEEDED   &bsol;**< This signal indicates extend action succeeded. */
159  };
160  enum NRF_RADIO_SIGNAL_CALLBACK_ACTION
161  {
162    NRF_RADIO_SIGNAL_CALLBACK_ACTION_NONE,            &bsol;**< Return without action. */
163    NRF_RADIO_SIGNAL_CALLBACK_ACTION_EXTEND,          &bsol;**< Request an extension of the current
164                                                           timeslot. Maximum execution time for this action:
165                                                           @ref NRF_RADIO_MAX_EXTENSION_PROCESSING_TIME_US.
166                                                           This action must be started at least
167                                                           @ref NRF_RADIO_MIN_EXTENSION_MARGIN_US before
168                                                           the end of the timeslot. */
169    NRF_RADIO_SIGNAL_CALLBACK_ACTION_END,             &bsol;**< End the current radio timeslot. */
170    NRF_RADIO_SIGNAL_CALLBACK_ACTION_REQUEST_AND_END  &bsol;**< Request a new radio timeslot and end the current timeslot. */
171  };
172  enum NRF_RADIO_HFCLK_CFG
173  {
174    NRF_RADIO_HFCLK_CFG_XTAL_GUARANTEED, &bsol;**< The SoftDevice will guarantee that the high frequency clock source is the
175                                             external crystal for the whole duration of the timeslot. This should be the
176                                             preferred option for events that use the radio or require high timing accuracy.
177                                             @note The SoftDevice will automatically turn on and off the external crystal,
<span onclick='openModal()' class='match'>178                                             at the beginning and end of the timeslot, respectively. The crystal may also
179                                             intentionally be left running after the timeslot, in cases where it is needed
180                                             by the SoftDevice shortly after the end of the timeslot. */
181    NRF_RADIO_HFCLK_CFG_NO_GUARANTEE    &bsol;**< This configuration allows for earlier and tighter scheduling of timeslots.
182                                             The RC oscillator may be the clock source in part or for the whole duration of the timeslot.
183                                             The RC oscillator's accuracy must therefore be taken into consideration.
</span>184                                             @note If the application will use the radio peripheral in timeslots with this configuration,
185                                             it must make sure that the crystal is running and stable before starting the radio. */
186  };
187  enum NRF_RADIO_PRIORITY
188  {
189    NRF_RADIO_PRIORITY_HIGH,                          &bsol;**< High (equal priority as the normal connection priority of the SoftDevice stack(s)). */
190    NRF_RADIO_PRIORITY_NORMAL,                        &bsol;**< Normal (equal priority as the priority of secondary activities of the SoftDevice stack(s)). */
191  };
192  enum NRF_RADIO_REQUEST_TYPE
193  {
194    NRF_RADIO_REQ_TYPE_EARLIEST,                      &bsol;**< Request radio timeslot as early as possible. This should always be used for the first request in a session. */
195    NRF_RADIO_REQ_TYPE_NORMAL                         &bsol;**< Normal radio timeslot request. */
196  };
197  enum NRF_SOC_EVTS
198  {
199    NRF_EVT_HFCLKSTARTED,                         &bsol;**< Event indicating that the HFCLK has started. */
200    NRF_EVT_POWER_FAILURE_WARNING,                &bsol;**< Event indicating that a power failure warning has occurred. */
201    NRF_EVT_FLASH_OPERATION_SUCCESS,              &bsol;**< Event indicating that the ongoing flash operation has completed successfully. */
202    NRF_EVT_FLASH_OPERATION_ERROR,                &bsol;**< Event indicating that the ongoing flash operation has timed out with an error. */
203    NRF_EVT_RADIO_BLOCKED,                        &bsol;**< Event indicating that a radio timeslot was blocked. */
204    NRF_EVT_RADIO_CANCELED,                       &bsol;**< Event indicating that a radio timeslot was canceled by SoftDevice. */
205    NRF_EVT_RADIO_SIGNAL_CALLBACK_INVALID_RETURN, &bsol;**< Event indicating that a radio timeslot signal callback handler return was invalid. */
206    NRF_EVT_RADIO_SESSION_IDLE,                   &bsol;**< Event indicating that a radio timeslot session is idle. */
207    NRF_EVT_RADIO_SESSION_CLOSED,                 &bsol;**< Event indicating that a radio timeslot session is closed. */
208    NRF_EVT_NUMBER_OF_EVTS
209  };
210  typedef volatile uint8_t nrf_mutex_t;
211  typedef struct
212  {
213    uint8_t       hfclk;                              &bsol;**< High frequency clock source, see @ref NRF_RADIO_HFCLK_CFG. */
214    uint8_t       priority;                           &bsol;**< The radio timeslot priority, see @ref NRF_RADIO_PRIORITY. */
215    uint32_t      length_us;                          &bsol;**< The radio timeslot length (in the range 100 to 100,000] microseconds). */
216    uint32_t      timeout_us;                         &bsol;**< Longest acceptable delay until the start of the requested timeslot (up to @ref NRF_RADIO_EARLIEST_TIMEOUT_MAX_US microseconds). */
217  } nrf_radio_request_earliest_t;
218  typedef struct
219  {
220    uint8_t       hfclk;                              &bsol;**< High frequency clock source, see @ref NRF_RADIO_HFCLK_CFG. */
221    uint8_t       priority;                           &bsol;**< The radio timeslot priority, see @ref NRF_RADIO_PRIORITY. */
222    uint32_t      distance_us;                        &bsol;**< Distance from the start of the previous radio timeslot (up to @ref NRF_RADIO_DISTANCE_MAX_US microseconds). */
223    uint32_t      length_us;                          &bsol;**< The radio timeslot length (in the range [100..100,000] microseconds). */
224  } nrf_radio_request_normal_t;
225  typedef struct
226  {
227    uint8_t                         request_type;     &bsol;**< Type of request, see @ref NRF_RADIO_REQUEST_TYPE. */
228    union
229    {
230      nrf_radio_request_earliest_t  earliest;         &bsol;**< Parameters for requesting a radio timeslot as early as possible. */
231      nrf_radio_request_normal_t    normal;           &bsol;**< Parameters for requesting a normal radio timeslot. */
232    } params;                                         &bsol;**< Parameter union. */
233  } nrf_radio_request_t;
234  typedef struct
235  {
236    uint8_t               callback_action;            &bsol;**< The action requested by the application when returning from the signal callback, see @ref NRF_RADIO_SIGNAL_CALLBACK_ACTION. */
237    union
238    {
239      struct
240      {
241        nrf_radio_request_t * p_next;                 &bsol;**< The request parameters for the next radio timeslot. */
242      } request;                                      &bsol;**< Additional parameters for return_code @ref NRF_RADIO_SIGNAL_CALLBACK_ACTION_REQUEST_AND_END. */
243      struct
244      {
245        uint32_t              length_us;              &bsol;**< Requested extension of the radio timeslot duration (microseconds) (for minimum time see @ref NRF_RADIO_MINIMUM_TIMESLOT_LENGTH_EXTENSION_TIME_US). */
246      } extend;                                       &bsol;**< Additional parameters for return_code @ref NRF_RADIO_SIGNAL_CALLBACK_ACTION_EXTEND. */
247    } params;                                         &bsol;**< Parameter union. */
248  } nrf_radio_signal_callback_return_param_t;
249  typedef nrf_radio_signal_callback_return_param_t * (*nrf_radio_signal_callback_t) (uint8_t signal_type);
250  typedef uint8_t soc_ecb_key_t[SOC_ECB_KEY_LENGTH];                &bsol;**< Encryption key type. */
251  typedef uint8_t soc_ecb_cleartext_t[SOC_ECB_CLEARTEXT_LENGTH];    &bsol;**< Cleartext data type. */
252  typedef uint8_t soc_ecb_ciphertext_t[SOC_ECB_CIPHERTEXT_LENGTH];  &bsol;**< Ciphertext data type. */
253  typedef struct
254  {
255    soc_ecb_key_t        key;            &bsol;**< Encryption key. */
256    soc_ecb_cleartext_t  cleartext;      &bsol;**< Cleartext data. */
257    soc_ecb_ciphertext_t ciphertext;     &bsol;**< Ciphertext data. */
258  } nrf_ecb_hal_data_t;
259  typedef struct
260  {
261    soc_ecb_key_t const *       p_key;           &bsol;**< Pointer to the Encryption key. */
262    soc_ecb_cleartext_t const * p_cleartext;     &bsol;**< Pointer to the Cleartext data. */
263    soc_ecb_ciphertext_t *      p_ciphertext;    &bsol;**< Pointer to the Ciphertext data. */
264  } nrf_ecb_hal_data_block_t;
265  SVCALL(SD_MUTEX_NEW, uint32_t, sd_mutex_new(nrf_mutex_t * p_mutex));
266  SVCALL(SD_MUTEX_ACQUIRE, uint32_t, sd_mutex_acquire(nrf_mutex_t * p_mutex));
267  SVCALL(SD_MUTEX_RELEASE, uint32_t, sd_mutex_release(nrf_mutex_t * p_mutex));
268  SVCALL(SD_RAND_APPLICATION_POOL_CAPACITY_GET, uint32_t, sd_rand_application_pool_capacity_get(uint8_t * p_pool_capacity));
269  SVCALL(SD_RAND_APPLICATION_BYTES_AVAILABLE_GET, uint32_t, sd_rand_application_bytes_available_get(uint8_t * p_bytes_available));
270  SVCALL(SD_RAND_APPLICATION_VECTOR_GET, uint32_t, sd_rand_application_vector_get(uint8_t * p_buff, uint8_t length));
271  SVCALL(SD_POWER_RESET_REASON_GET, uint32_t, sd_power_reset_reason_get(uint32_t * p_reset_reason));
272  SVCALL(SD_POWER_RESET_REASON_CLR, uint32_t, sd_power_reset_reason_clr(uint32_t reset_reason_clr_msk));
273  SVCALL(SD_POWER_MODE_SET, uint32_t, sd_power_mode_set(uint8_t power_mode));
274  SVCALL(SD_POWER_SYSTEM_OFF, uint32_t, sd_power_system_off(void));
275  SVCALL(SD_POWER_POF_ENABLE, uint32_t, sd_power_pof_enable(uint8_t pof_enable));
276  SVCALL(SD_POWER_POF_THRESHOLD_SET, uint32_t, sd_power_pof_threshold_set(uint8_t threshold));
277  SVCALL(SD_POWER_RAM_POWER_SET, uint32_t, sd_power_ram_power_set(uint8_t index, uint32_t ram_powerset));
278  SVCALL(SD_POWER_RAM_POWER_CLR, uint32_t, sd_power_ram_power_clr(uint8_t index, uint32_t ram_powerclr));
279  SVCALL(SD_POWER_RAM_POWER_GET, uint32_t, sd_power_ram_power_get(uint8_t index, uint32_t * p_ram_power));
280  SVCALL(SD_POWER_GPREGRET_SET, uint32_t, sd_power_gpregret_set(uint32_t gpregret_id, uint32_t gpregret_msk));
281  SVCALL(SD_POWER_GPREGRET_CLR, uint32_t, sd_power_gpregret_clr(uint32_t gpregret_id, uint32_t gpregret_msk));
282  SVCALL(SD_POWER_GPREGRET_GET, uint32_t, sd_power_gpregret_get(uint32_t gpregret_id, uint32_t *p_gpregret));
283  SVCALL(SD_POWER_DCDC_MODE_SET, uint32_t, sd_power_dcdc_mode_set(uint8_t dcdc_mode));
284  SVCALL(SD_CLOCK_HFCLK_REQUEST, uint32_t, sd_clock_hfclk_request(void));
285  SVCALL(SD_CLOCK_HFCLK_RELEASE, uint32_t, sd_clock_hfclk_release(void));
286  SVCALL(SD_CLOCK_HFCLK_IS_RUNNING, uint32_t, sd_clock_hfclk_is_running(uint32_t * p_is_running));
287  SVCALL(SD_APP_EVT_WAIT, uint32_t, sd_app_evt_wait(void));
288  SVCALL(SD_PPI_CHANNEL_ENABLE_GET, uint32_t, sd_ppi_channel_enable_get(uint32_t * p_channel_enable));
289  SVCALL(SD_PPI_CHANNEL_ENABLE_SET, uint32_t, sd_ppi_channel_enable_set(uint32_t channel_enable_set_msk));
290  SVCALL(SD_PPI_CHANNEL_ENABLE_CLR, uint32_t, sd_ppi_channel_enable_clr(uint32_t channel_enable_clr_msk));
291  SVCALL(SD_PPI_CHANNEL_ASSIGN, uint32_t, sd_ppi_channel_assign(uint8_t channel_num, const volatile void * evt_endpoint, const volatile void * task_endpoint));
292  SVCALL(SD_PPI_GROUP_TASK_ENABLE, uint32_t, sd_ppi_group_task_enable(uint8_t group_num));
293  SVCALL(SD_PPI_GROUP_TASK_DISABLE, uint32_t, sd_ppi_group_task_disable(uint8_t group_num));
294  SVCALL(SD_PPI_GROUP_ASSIGN, uint32_t, sd_ppi_group_assign(uint8_t group_num, uint32_t channel_msk));
295  SVCALL(SD_PPI_GROUP_GET, uint32_t, sd_ppi_group_get(uint8_t group_num, uint32_t * p_channel_msk));
296  SVCALL(SD_RADIO_NOTIFICATION_CFG_SET, uint32_t, sd_radio_notification_cfg_set(uint8_t type, uint8_t distance));
297  SVCALL(SD_ECB_BLOCK_ENCRYPT, uint32_t, sd_ecb_block_encrypt(nrf_ecb_hal_data_t * p_ecb_data));
298  SVCALL(SD_ECB_BLOCKS_ENCRYPT, uint32_t, sd_ecb_blocks_encrypt(uint8_t block_count, nrf_ecb_hal_data_block_t * p_data_blocks));
299  SVCALL(SD_EVT_GET, uint32_t, sd_evt_get(uint32_t * p_evt_id));
300  SVCALL(SD_TEMP_GET, uint32_t, sd_temp_get(int32_t * p_temp));
301  SVCALL(SD_FLASH_WRITE, uint32_t, sd_flash_write(uint32_t * p_dst, uint32_t const * p_src, uint32_t size));
302  SVCALL(SD_FLASH_PAGE_ERASE, uint32_t, sd_flash_page_erase(uint32_t page_number));
303  SVCALL(SD_FLASH_PROTECT, uint32_t, sd_flash_protect(uint32_t block_cfg0, uint32_t block_cfg1, uint32_t block_cfg2, uint32_t block_cfg3));
304   SVCALL(SD_RADIO_SESSION_OPEN, uint32_t, sd_radio_session_open(nrf_radio_signal_callback_t p_radio_signal_callback));
305   SVCALL(SD_RADIO_SESSION_CLOSE, uint32_t, sd_radio_session_close(void));
306   SVCALL(SD_RADIO_REQUEST, uint32_t, sd_radio_request(nrf_radio_request_t const * p_request));
307  SVCALL(SD_PROTECTED_REGISTER_WRITE, uint32_t, sd_protected_register_write(volatile uint32_t * p_register, uint32_t value));
308  #ifdef __cplusplus
309  }
310  #endif
311  #endif 
</code></pre>
        </div>
        <div class="column">
            <h3>Adafruit_nRF52_Arduino-MDEwOlJlcG9zaXRvcnk3NDM1NDcyOQ==-flat-nrf_soc_3.h</h3>
            <pre><code>1  #ifndef NRF_SOC_H__
2  #define NRF_SOC_H__
3  #include <stdint.h>
4  #include "nrf.h"
5  #include "nrf_svc.h"
6  #include "nrf_error.h"
7  #include "nrf_error_soc.h"
8  #ifdef __cplusplus
9  extern "C" {
10  #endif
11  #define SOC_SVC_BASE               (0x20)                   &bsol;**< Base value for SVCs that are available when the SoftDevice is disabled. */
12  #define SOC_SVC_BASE_NOT_AVAILABLE (0x2C)                   &bsol;**< Base value for SVCs that are not available when the SoftDevice is disabled. */
13  #define NRF_RADIO_NOTIFICATION_INACTIVE_GUARANTEED_TIME_US  (62)
14  #define NRF_RADIO_MINIMUM_TIMESLOT_LENGTH_EXTENSION_TIME_US (200)
15  #define NRF_RADIO_MAX_EXTENSION_PROCESSING_TIME_US           (17)
16  #define NRF_RADIO_MIN_EXTENSION_MARGIN_US                    (79)
17  #define SOC_ECB_KEY_LENGTH                (16)                       &bsol;**< ECB key length. */
18  #define SOC_ECB_CLEARTEXT_LENGTH          (16)                       &bsol;**< ECB cleartext length. */
19  #define SOC_ECB_CIPHERTEXT_LENGTH         (SOC_ECB_CLEARTEXT_LENGTH) &bsol;**< ECB ciphertext length. */
20  #define SD_EVT_IRQn                       (SWI2_IRQn)        &bsol;**< SoftDevice Event IRQ number. Used for both protocol events and SoC events. */
21  #define SD_EVT_IRQHandler                 (SWI2_IRQHandler)  &bsol;**< SoftDevice Event IRQ handler. Used for both protocol events and SoC events.
22                                                                         The default interrupt priority for this handler is set to 6 */
23  #define RADIO_NOTIFICATION_IRQn           (SWI1_IRQn)        &bsol;**< The radio notification IRQ number. */
24  #define RADIO_NOTIFICATION_IRQHandler     (SWI1_IRQHandler)  &bsol;**< The radio notification IRQ handler.
25                                                                         The default interrupt priority for this handler is set to 6 */
26  #define NRF_RADIO_LENGTH_MIN_US           (100)               &bsol;**< The shortest allowed radio timeslot, in microseconds. */
27  #define NRF_RADIO_LENGTH_MAX_US           (100000)            &bsol;**< The longest allowed radio timeslot, in microseconds. */
28  #define NRF_RADIO_DISTANCE_MAX_US         (128000000UL - 1UL) &bsol;**< The longest timeslot distance, in microseconds, allowed for the distance parameter (see @ref nrf_radio_request_normal_t) in the request. */
29  #define NRF_RADIO_EARLIEST_TIMEOUT_MAX_US (128000000UL - 1UL) &bsol;**< The longest timeout, in microseconds, allowed when requesting the earliest possible timeslot. */
30  #define NRF_RADIO_START_JITTER_US         (2)                 &bsol;**< The maximum jitter in @ref NRF_RADIO_CALLBACK_SIGNAL_TYPE_START relative to the requested start time. */
31  #define NRF_SOC_SD_PPI_CHANNELS_SD_DISABLED_MSK ((uint32_t)(0))
32  #define NRF_SOC_SD_PPI_CHANNELS_SD_ENABLED_MSK  ((uint32_t)( \
33        (1U << 17) \
34      | (1U << 18) \
35      | (1U << 19) \
36      | (1U << 20) \
37      | (1U << 21) \
38      | (1U << 22) \
39      | (1U << 23) \
40      | (1U << 24) \
41      | (1U << 25) \
42      | (1U << 26) \
43      | (1U << 27) \
44      | (1U << 28) \
45      | (1U << 29) \
46      | (1U << 30) \
47      | (1U << 31) \
48    ))
49  #define NRF_SOC_APP_PPI_CHANNELS_SD_DISABLED_MSK (~NRF_SOC_SD_PPI_CHANNELS_SD_DISABLED_MSK)
50  #define NRF_SOC_APP_PPI_CHANNELS_SD_ENABLED_MSK  (~NRF_SOC_SD_PPI_CHANNELS_SD_ENABLED_MSK)
51  #define NRF_SOC_SD_PPI_GROUPS_SD_DISABLED_MSK    ((uint32_t)(0))
52  #define NRF_SOC_SD_PPI_GROUPS_SD_ENABLED_MSK     ((uint32_t)( \
53        (1U << 4) \
54      | (1U << 5) \
55    ))
56  #define NRF_SOC_APP_PPI_GROUPS_SD_DISABLED_MSK   (~NRF_SOC_SD_PPI_GROUPS_SD_DISABLED_MSK)
57  #define NRF_SOC_APP_PPI_GROUPS_SD_ENABLED_MSK    (~NRF_SOC_SD_PPI_GROUPS_SD_ENABLED_MSK)
58  enum NRF_SOC_SVCS
59  {
60    SD_PPI_CHANNEL_ENABLE_GET   = SOC_SVC_BASE,
61    SD_PPI_CHANNEL_ENABLE_SET   = SOC_SVC_BASE + 1,
62    SD_PPI_CHANNEL_ENABLE_CLR   = SOC_SVC_BASE + 2,
63    SD_PPI_CHANNEL_ASSIGN       = SOC_SVC_BASE + 3,
64    SD_PPI_GROUP_TASK_ENABLE    = SOC_SVC_BASE + 4,
65    SD_PPI_GROUP_TASK_DISABLE   = SOC_SVC_BASE + 5,
66    SD_PPI_GROUP_ASSIGN         = SOC_SVC_BASE + 6,
67    SD_PPI_GROUP_GET            = SOC_SVC_BASE + 7,
68    SD_FLASH_PAGE_ERASE         = SOC_SVC_BASE + 8,
69    SD_FLASH_WRITE              = SOC_SVC_BASE + 9,
70    SD_PROTECTED_REGISTER_WRITE = SOC_SVC_BASE + 11,
71    SD_MUTEX_NEW                            = SOC_SVC_BASE_NOT_AVAILABLE,
72    SD_MUTEX_ACQUIRE                        = SOC_SVC_BASE_NOT_AVAILABLE + 1,
73    SD_MUTEX_RELEASE                        = SOC_SVC_BASE_NOT_AVAILABLE + 2,
74    SD_RAND_APPLICATION_POOL_CAPACITY_GET   = SOC_SVC_BASE_NOT_AVAILABLE + 3,
75    SD_RAND_APPLICATION_BYTES_AVAILABLE_GET = SOC_SVC_BASE_NOT_AVAILABLE + 4,
76    SD_RAND_APPLICATION_VECTOR_GET          = SOC_SVC_BASE_NOT_AVAILABLE + 5,
77    SD_POWER_MODE_SET                       = SOC_SVC_BASE_NOT_AVAILABLE + 6,
78    SD_POWER_SYSTEM_OFF                     = SOC_SVC_BASE_NOT_AVAILABLE + 7,
79    SD_POWER_RESET_REASON_GET               = SOC_SVC_BASE_NOT_AVAILABLE + 8,
80    SD_POWER_RESET_REASON_CLR               = SOC_SVC_BASE_NOT_AVAILABLE + 9,
81    SD_POWER_POF_ENABLE                     = SOC_SVC_BASE_NOT_AVAILABLE + 10,
82    SD_POWER_POF_THRESHOLD_SET              = SOC_SVC_BASE_NOT_AVAILABLE + 11,
83    SD_POWER_POF_THRESHOLDVDDH_SET          = SOC_SVC_BASE_NOT_AVAILABLE + 12,
84    SD_POWER_RAM_POWER_SET                  = SOC_SVC_BASE_NOT_AVAILABLE + 13,
85    SD_POWER_RAM_POWER_CLR                  = SOC_SVC_BASE_NOT_AVAILABLE + 14,
86    SD_POWER_RAM_POWER_GET                  = SOC_SVC_BASE_NOT_AVAILABLE + 15,
87    SD_POWER_GPREGRET_SET                   = SOC_SVC_BASE_NOT_AVAILABLE + 16,
88    SD_POWER_GPREGRET_CLR                   = SOC_SVC_BASE_NOT_AVAILABLE + 17,
89    SD_POWER_GPREGRET_GET                   = SOC_SVC_BASE_NOT_AVAILABLE + 18,
90    SD_POWER_DCDC_MODE_SET                  = SOC_SVC_BASE_NOT_AVAILABLE + 19,
91    SD_POWER_DCDC0_MODE_SET                 = SOC_SVC_BASE_NOT_AVAILABLE + 20,
92    SD_APP_EVT_WAIT                         = SOC_SVC_BASE_NOT_AVAILABLE + 21,
93    SD_CLOCK_HFCLK_REQUEST                  = SOC_SVC_BASE_NOT_AVAILABLE + 22,
94    SD_CLOCK_HFCLK_RELEASE                  = SOC_SVC_BASE_NOT_AVAILABLE + 23,
95    SD_CLOCK_HFCLK_IS_RUNNING               = SOC_SVC_BASE_NOT_AVAILABLE + 24,
96    SD_RADIO_NOTIFICATION_CFG_SET           = SOC_SVC_BASE_NOT_AVAILABLE + 25,
97    SD_ECB_BLOCK_ENCRYPT                    = SOC_SVC_BASE_NOT_AVAILABLE + 26,
98    SD_ECB_BLOCKS_ENCRYPT                   = SOC_SVC_BASE_NOT_AVAILABLE + 27,
99    SD_RADIO_SESSION_OPEN                   = SOC_SVC_BASE_NOT_AVAILABLE + 28,
100    SD_RADIO_SESSION_CLOSE                  = SOC_SVC_BASE_NOT_AVAILABLE + 29,
101    SD_RADIO_REQUEST                        = SOC_SVC_BASE_NOT_AVAILABLE + 30,
102    SD_EVT_GET                              = SOC_SVC_BASE_NOT_AVAILABLE + 31,
103    SD_TEMP_GET                             = SOC_SVC_BASE_NOT_AVAILABLE + 32,
104    SD_POWER_USBPWRRDY_ENABLE               = SOC_SVC_BASE_NOT_AVAILABLE + 33,
105    SD_POWER_USBDETECTED_ENABLE             = SOC_SVC_BASE_NOT_AVAILABLE + 34,
106    SD_POWER_USBREMOVED_ENABLE              = SOC_SVC_BASE_NOT_AVAILABLE + 35,
107    SD_POWER_USBREGSTATUS_GET               = SOC_SVC_BASE_NOT_AVAILABLE + 36,
108    SVC_SOC_LAST                            = SOC_SVC_BASE_NOT_AVAILABLE + 37
109  };
110  enum NRF_MUTEX_VALUES
111  {
112    NRF_MUTEX_FREE,
113    NRF_MUTEX_TAKEN
114  };
115  enum NRF_POWER_MODES
116  {
117    NRF_POWER_MODE_CONSTLAT,  &bsol;**< Constant latency mode. See power management in the reference manual. */
118    NRF_POWER_MODE_LOWPWR     &bsol;**< Low power mode. See power management in the reference manual. */
119  };
120  enum NRF_POWER_THRESHOLDS
121  {
122    NRF_POWER_THRESHOLD_V17 = 4UL, &bsol;**< 1.7 Volts power failure threshold. */
123    NRF_POWER_THRESHOLD_V18,       &bsol;**< 1.8 Volts power failure threshold. */
124    NRF_POWER_THRESHOLD_V19,       &bsol;**< 1.9 Volts power failure threshold. */
125    NRF_POWER_THRESHOLD_V20,       &bsol;**< 2.0 Volts power failure threshold. */
126    NRF_POWER_THRESHOLD_V21,       &bsol;**< 2.1 Volts power failure threshold. */
127    NRF_POWER_THRESHOLD_V22,       &bsol;**< 2.2 Volts power failure threshold. */
128    NRF_POWER_THRESHOLD_V23,       &bsol;**< 2.3 Volts power failure threshold. */
129    NRF_POWER_THRESHOLD_V24,       &bsol;**< 2.4 Volts power failure threshold. */
130    NRF_POWER_THRESHOLD_V25,       &bsol;**< 2.5 Volts power failure threshold. */
131    NRF_POWER_THRESHOLD_V26,       &bsol;**< 2.6 Volts power failure threshold. */
132    NRF_POWER_THRESHOLD_V27,       &bsol;**< 2.7 Volts power failure threshold. */
133    NRF_POWER_THRESHOLD_V28        &bsol;**< 2.8 Volts power failure threshold. */
134  };
135  enum NRF_POWER_THRESHOLDVDDHS
136  {
137    NRF_POWER_THRESHOLDVDDH_V27,       &bsol;**< 2.7 Volts power failure threshold. */
138    NRF_POWER_THRESHOLDVDDH_V28,       &bsol;**< 2.8 Volts power failure threshold. */
139    NRF_POWER_THRESHOLDVDDH_V29,       &bsol;**< 2.9 Volts power failure threshold. */
140    NRF_POWER_THRESHOLDVDDH_V30,       &bsol;**< 3.0 Volts power failure threshold. */
141    NRF_POWER_THRESHOLDVDDH_V31,       &bsol;**< 3.1 Volts power failure threshold. */
142    NRF_POWER_THRESHOLDVDDH_V32,       &bsol;**< 3.2 Volts power failure threshold. */
143    NRF_POWER_THRESHOLDVDDH_V33,       &bsol;**< 3.3 Volts power failure threshold. */
144    NRF_POWER_THRESHOLDVDDH_V34,       &bsol;**< 3.4 Volts power failure threshold. */
145    NRF_POWER_THRESHOLDVDDH_V35,       &bsol;**< 3.5 Volts power failure threshold. */
146    NRF_POWER_THRESHOLDVDDH_V36,       &bsol;**< 3.6 Volts power failure threshold. */
147    NRF_POWER_THRESHOLDVDDH_V37,       &bsol;**< 3.7 Volts power failure threshold. */
148    NRF_POWER_THRESHOLDVDDH_V38,       &bsol;**< 3.8 Volts power failure threshold. */
149    NRF_POWER_THRESHOLDVDDH_V39,       &bsol;**< 3.9 Volts power failure threshold. */
150    NRF_POWER_THRESHOLDVDDH_V40,       &bsol;**< 4.0 Volts power failure threshold. */
151    NRF_POWER_THRESHOLDVDDH_V41,       &bsol;**< 4.1 Volts power failure threshold. */
152    NRF_POWER_THRESHOLDVDDH_V42        &bsol;**< 4.2 Volts power failure threshold. */
153  };
154  enum NRF_POWER_DCDC_MODES
155  {
156    NRF_POWER_DCDC_DISABLE,          &bsol;**< The DCDC is disabled. */
157    NRF_POWER_DCDC_ENABLE            &bsol;**< The DCDC is enabled.  */
158  };
159  enum NRF_RADIO_NOTIFICATION_DISTANCES
160  {
161    NRF_RADIO_NOTIFICATION_DISTANCE_NONE = 0, &bsol;**< The event does not have a notification. */
162    NRF_RADIO_NOTIFICATION_DISTANCE_800US,    &bsol;**< The distance from the active notification to start of radio activity. */
163    NRF_RADIO_NOTIFICATION_DISTANCE_1740US,   &bsol;**< The distance from the active notification to start of radio activity. */
164    NRF_RADIO_NOTIFICATION_DISTANCE_2680US,   &bsol;**< The distance from the active notification to start of radio activity. */
165    NRF_RADIO_NOTIFICATION_DISTANCE_3620US,   &bsol;**< The distance from the active notification to start of radio activity. */
166    NRF_RADIO_NOTIFICATION_DISTANCE_4560US,   &bsol;**< The distance from the active notification to start of radio activity. */
167    NRF_RADIO_NOTIFICATION_DISTANCE_5500US    &bsol;**< The distance from the active notification to start of radio activity. */
168  };
169  enum NRF_RADIO_NOTIFICATION_TYPES
170  {
171    NRF_RADIO_NOTIFICATION_TYPE_NONE = 0,        &bsol;**< The event does not have a radio notification signal. */
172    NRF_RADIO_NOTIFICATION_TYPE_INT_ON_ACTIVE,   &bsol;**< Using interrupt for notification when the radio will be enabled. */
173    NRF_RADIO_NOTIFICATION_TYPE_INT_ON_INACTIVE, &bsol;**< Using interrupt for notification when the radio has been disabled. */
174    NRF_RADIO_NOTIFICATION_TYPE_INT_ON_BOTH,     &bsol;**< Using interrupt for notification both when the radio will be enabled and disabled. */
175  };
176  enum NRF_RADIO_CALLBACK_SIGNAL_TYPE
177  {
178    NRF_RADIO_CALLBACK_SIGNAL_TYPE_START,             &bsol;**< This signal indicates the start of the radio timeslot. */
179    NRF_RADIO_CALLBACK_SIGNAL_TYPE_TIMER0,            &bsol;**< This signal indicates the NRF_TIMER0 interrupt. */
180    NRF_RADIO_CALLBACK_SIGNAL_TYPE_RADIO,             &bsol;**< This signal indicates the NRF_RADIO interrupt. */
181    NRF_RADIO_CALLBACK_SIGNAL_TYPE_EXTEND_FAILED,     &bsol;**< This signal indicates extend action failed. */
182    NRF_RADIO_CALLBACK_SIGNAL_TYPE_EXTEND_SUCCEEDED   &bsol;**< This signal indicates extend action succeeded. */
183  };
184  enum NRF_RADIO_SIGNAL_CALLBACK_ACTION
185  {
186    NRF_RADIO_SIGNAL_CALLBACK_ACTION_NONE,            &bsol;**< Return without action. */
187    NRF_RADIO_SIGNAL_CALLBACK_ACTION_EXTEND,          &bsol;**< Request an extension of the current
188                                                           timeslot. Maximum execution time for this action:
189                                                           @ref NRF_RADIO_MAX_EXTENSION_PROCESSING_TIME_US.
190                                                           This action must be started at least
191                                                           @ref NRF_RADIO_MIN_EXTENSION_MARGIN_US before
192                                                           the end of the timeslot. */
193    NRF_RADIO_SIGNAL_CALLBACK_ACTION_END,             &bsol;**< End the current radio timeslot. */
194    NRF_RADIO_SIGNAL_CALLBACK_ACTION_REQUEST_AND_END  &bsol;**< Request a new radio timeslot and end the current timeslot. */
195  };
196  enum NRF_RADIO_HFCLK_CFG
197  {
198    NRF_RADIO_HFCLK_CFG_XTAL_GUARANTEED, &bsol;**< The SoftDevice will guarantee that the high frequency clock source is the
199                                             external crystal for the whole duration of the timeslot. This should be the
200                                             preferred option for events that use the radio or require high timing accuracy.
201                                             @note The SoftDevice will automatically turn on and off the external crystal,
<span onclick='openModal()' class='match'>202                                             at the beginning and end of the timeslot, respectively. The crystal may also
203                                             intentionally be left running after the timeslot, in cases where it is needed
204                                             by the SoftDevice shortly after the end of the timeslot. */
205    NRF_RADIO_HFCLK_CFG_NO_GUARANTEE    &bsol;**< This configuration allows for earlier and tighter scheduling of timeslots.
206                                             The RC oscillator may be the clock source in part or for the whole duration of the timeslot.
207                                             The RC oscillator's accuracy must therefore be taken into consideration.
</span>208                                             @note If the application will use the radio peripheral in timeslots with this configuration,
209                                             it must make sure that the crystal is running and stable before starting the radio. */
210  };
211  enum NRF_RADIO_PRIORITY
212  {
213    NRF_RADIO_PRIORITY_HIGH,                          &bsol;**< High (equal priority as the normal connection priority of the SoftDevice stack(s)). */
214    NRF_RADIO_PRIORITY_NORMAL,                        &bsol;**< Normal (equal priority as the priority of secondary activities of the SoftDevice stack(s)). */
215  };
216  enum NRF_RADIO_REQUEST_TYPE
217  {
218    NRF_RADIO_REQ_TYPE_EARLIEST,                      &bsol;**< Request radio timeslot as early as possible. This should always be used for the first request in a session. */
219    NRF_RADIO_REQ_TYPE_NORMAL                         &bsol;**< Normal radio timeslot request. */
220  };
221  enum NRF_SOC_EVTS
222  {
223    NRF_EVT_HFCLKSTARTED,                         &bsol;**< Event indicating that the HFCLK has started. */
224    NRF_EVT_POWER_FAILURE_WARNING,                &bsol;**< Event indicating that a power failure warning has occurred. */
225    NRF_EVT_FLASH_OPERATION_SUCCESS,              &bsol;**< Event indicating that the ongoing flash operation has completed successfully. */
226    NRF_EVT_FLASH_OPERATION_ERROR,                &bsol;**< Event indicating that the ongoing flash operation has timed out with an error. */
227    NRF_EVT_RADIO_BLOCKED,                        &bsol;**< Event indicating that a radio timeslot was blocked. */
228    NRF_EVT_RADIO_CANCELED,                       &bsol;**< Event indicating that a radio timeslot was canceled by SoftDevice. */
229    NRF_EVT_RADIO_SIGNAL_CALLBACK_INVALID_RETURN, &bsol;**< Event indicating that a radio timeslot signal callback handler return was invalid. */
230    NRF_EVT_RADIO_SESSION_IDLE,                   &bsol;**< Event indicating that a radio timeslot session is idle. */
231    NRF_EVT_RADIO_SESSION_CLOSED,                 &bsol;**< Event indicating that a radio timeslot session is closed. */
232    NRF_EVT_POWER_USB_POWER_READY,                &bsol;**< Event indicating that a USB 3.3 V supply is ready. */
233    NRF_EVT_POWER_USB_DETECTED,                   &bsol;**< Event indicating that voltage supply is detected on VBUS. */
234    NRF_EVT_POWER_USB_REMOVED,                    &bsol;**< Event indicating that voltage supply is removed from VBUS. */
235    NRF_EVT_NUMBER_OF_EVTS
236  };
237  typedef volatile uint8_t nrf_mutex_t;
238  typedef struct
239  {
240    uint8_t       hfclk;                              &bsol;**< High frequency clock source, see @ref NRF_RADIO_HFCLK_CFG. */
241    uint8_t       priority;                           &bsol;**< The radio timeslot priority, see @ref NRF_RADIO_PRIORITY. */
242    uint32_t      length_us;                          &bsol;**< The radio timeslot length (in the range 100 to 100,000] microseconds). */
243    uint32_t      timeout_us;                         &bsol;**< Longest acceptable delay until the start of the requested timeslot (up to @ref NRF_RADIO_EARLIEST_TIMEOUT_MAX_US microseconds). */
244  } nrf_radio_request_earliest_t;
245  typedef struct
246  {
247    uint8_t       hfclk;                              &bsol;**< High frequency clock source, see @ref NRF_RADIO_HFCLK_CFG. */
248    uint8_t       priority;                           &bsol;**< The radio timeslot priority, see @ref NRF_RADIO_PRIORITY. */
249    uint32_t      distance_us;                        &bsol;**< Distance from the start of the previous radio timeslot (up to @ref NRF_RADIO_DISTANCE_MAX_US microseconds). */
250    uint32_t      length_us;                          &bsol;**< The radio timeslot length (in the range [100..100,000] microseconds). */
251  } nrf_radio_request_normal_t;
252  typedef struct
253  {
254    uint8_t                         request_type;     &bsol;**< Type of request, see @ref NRF_RADIO_REQUEST_TYPE. */
255    union
256    {
257      nrf_radio_request_earliest_t  earliest;         &bsol;**< Parameters for requesting a radio timeslot as early as possible. */
258      nrf_radio_request_normal_t    normal;           &bsol;**< Parameters for requesting a normal radio timeslot. */
259    } params;                                         &bsol;**< Parameter union. */
260  } nrf_radio_request_t;
261  typedef struct
262  {
263    uint8_t               callback_action;            &bsol;**< The action requested by the application when returning from the signal callback, see @ref NRF_RADIO_SIGNAL_CALLBACK_ACTION. */
264    union
265    {
266      struct
267      {
268        nrf_radio_request_t * p_next;                 &bsol;**< The request parameters for the next radio timeslot. */
269      } request;                                      &bsol;**< Additional parameters for return_code @ref NRF_RADIO_SIGNAL_CALLBACK_ACTION_REQUEST_AND_END. */
270      struct
271      {
272        uint32_t              length_us;              &bsol;**< Requested extension of the radio timeslot duration (microseconds) (for minimum time see @ref NRF_RADIO_MINIMUM_TIMESLOT_LENGTH_EXTENSION_TIME_US). */
273      } extend;                                       &bsol;**< Additional parameters for return_code @ref NRF_RADIO_SIGNAL_CALLBACK_ACTION_EXTEND. */
274    } params;                                         &bsol;**< Parameter union. */
275  } nrf_radio_signal_callback_return_param_t;
276  typedef nrf_radio_signal_callback_return_param_t * (*nrf_radio_signal_callback_t) (uint8_t signal_type);
277  typedef uint8_t soc_ecb_key_t[SOC_ECB_KEY_LENGTH];                &bsol;**< Encryption key type. */
278  typedef uint8_t soc_ecb_cleartext_t[SOC_ECB_CLEARTEXT_LENGTH];    &bsol;**< Cleartext data type. */
279  typedef uint8_t soc_ecb_ciphertext_t[SOC_ECB_CIPHERTEXT_LENGTH];  &bsol;**< Ciphertext data type. */
280  typedef struct
281  {
282    soc_ecb_key_t        key;            &bsol;**< Encryption key. */
283    soc_ecb_cleartext_t  cleartext;      &bsol;**< Cleartext data. */
284    soc_ecb_ciphertext_t ciphertext;     &bsol;**< Ciphertext data. */
285  } nrf_ecb_hal_data_t;
286  typedef struct
287  {
288    soc_ecb_key_t const *       p_key;           &bsol;**< Pointer to the Encryption key. */
289    soc_ecb_cleartext_t const * p_cleartext;     &bsol;**< Pointer to the Cleartext data. */
290    soc_ecb_ciphertext_t *      p_ciphertext;    &bsol;**< Pointer to the Ciphertext data. */
291  } nrf_ecb_hal_data_block_t;
292  SVCALL(SD_MUTEX_NEW, uint32_t, sd_mutex_new(nrf_mutex_t * p_mutex));
293  SVCALL(SD_MUTEX_ACQUIRE, uint32_t, sd_mutex_acquire(nrf_mutex_t * p_mutex));
294  SVCALL(SD_MUTEX_RELEASE, uint32_t, sd_mutex_release(nrf_mutex_t * p_mutex));
295  SVCALL(SD_RAND_APPLICATION_POOL_CAPACITY_GET, uint32_t, sd_rand_application_pool_capacity_get(uint8_t * p_pool_capacity));
296  SVCALL(SD_RAND_APPLICATION_BYTES_AVAILABLE_GET, uint32_t, sd_rand_application_bytes_available_get(uint8_t * p_bytes_available));
297  SVCALL(SD_RAND_APPLICATION_VECTOR_GET, uint32_t, sd_rand_application_vector_get(uint8_t * p_buff, uint8_t length));
298  SVCALL(SD_POWER_RESET_REASON_GET, uint32_t, sd_power_reset_reason_get(uint32_t * p_reset_reason));
299  SVCALL(SD_POWER_RESET_REASON_CLR, uint32_t, sd_power_reset_reason_clr(uint32_t reset_reason_clr_msk));
300  SVCALL(SD_POWER_MODE_SET, uint32_t, sd_power_mode_set(uint8_t power_mode));
301  SVCALL(SD_POWER_SYSTEM_OFF, uint32_t, sd_power_system_off(void));
302  SVCALL(SD_POWER_POF_ENABLE, uint32_t, sd_power_pof_enable(uint8_t pof_enable));
303  SVCALL(SD_POWER_USBPWRRDY_ENABLE, uint32_t, sd_power_usbpwrrdy_enable(uint8_t usbpwrrdy_enable));
304  SVCALL(SD_POWER_USBDETECTED_ENABLE, uint32_t, sd_power_usbdetected_enable(uint8_t usbdetected_enable));
305  SVCALL(SD_POWER_USBREMOVED_ENABLE, uint32_t, sd_power_usbremoved_enable(uint8_t usbremoved_enable));
306  SVCALL(SD_POWER_USBREGSTATUS_GET, uint32_t, sd_power_usbregstatus_get(uint32_t * usbregstatus));
307  SVCALL(SD_POWER_POF_THRESHOLD_SET, uint32_t, sd_power_pof_threshold_set(uint8_t threshold));
308  SVCALL(SD_POWER_POF_THRESHOLDVDDH_SET, uint32_t, sd_power_pof_thresholdvddh_set(uint8_t threshold));
309  SVCALL(SD_POWER_RAM_POWER_SET, uint32_t, sd_power_ram_power_set(uint8_t index, uint32_t ram_powerset));
310  SVCALL(SD_POWER_RAM_POWER_CLR, uint32_t, sd_power_ram_power_clr(uint8_t index, uint32_t ram_powerclr));
311  SVCALL(SD_POWER_RAM_POWER_GET, uint32_t, sd_power_ram_power_get(uint8_t index, uint32_t * p_ram_power));
312  SVCALL(SD_POWER_GPREGRET_SET, uint32_t, sd_power_gpregret_set(uint32_t gpregret_id, uint32_t gpregret_msk));
313  SVCALL(SD_POWER_GPREGRET_CLR, uint32_t, sd_power_gpregret_clr(uint32_t gpregret_id, uint32_t gpregret_msk));
314  SVCALL(SD_POWER_GPREGRET_GET, uint32_t, sd_power_gpregret_get(uint32_t gpregret_id, uint32_t *p_gpregret));
315  SVCALL(SD_POWER_DCDC_MODE_SET, uint32_t, sd_power_dcdc_mode_set(uint8_t dcdc_mode));
316  SVCALL(SD_POWER_DCDC0_MODE_SET, uint32_t, sd_power_dcdc0_mode_set(uint8_t dcdc_mode));
317  SVCALL(SD_CLOCK_HFCLK_REQUEST, uint32_t, sd_clock_hfclk_request(void));
318  SVCALL(SD_CLOCK_HFCLK_RELEASE, uint32_t, sd_clock_hfclk_release(void));
319  SVCALL(SD_CLOCK_HFCLK_IS_RUNNING, uint32_t, sd_clock_hfclk_is_running(uint32_t * p_is_running));
320  SVCALL(SD_APP_EVT_WAIT, uint32_t, sd_app_evt_wait(void));
321  SVCALL(SD_PPI_CHANNEL_ENABLE_GET, uint32_t, sd_ppi_channel_enable_get(uint32_t * p_channel_enable));
322  SVCALL(SD_PPI_CHANNEL_ENABLE_SET, uint32_t, sd_ppi_channel_enable_set(uint32_t channel_enable_set_msk));
323  SVCALL(SD_PPI_CHANNEL_ENABLE_CLR, uint32_t, sd_ppi_channel_enable_clr(uint32_t channel_enable_clr_msk));
324  SVCALL(SD_PPI_CHANNEL_ASSIGN, uint32_t, sd_ppi_channel_assign(uint8_t channel_num, const volatile void * evt_endpoint, const volatile void * task_endpoint));
325  SVCALL(SD_PPI_GROUP_TASK_ENABLE, uint32_t, sd_ppi_group_task_enable(uint8_t group_num));
326  SVCALL(SD_PPI_GROUP_TASK_DISABLE, uint32_t, sd_ppi_group_task_disable(uint8_t group_num));
327  SVCALL(SD_PPI_GROUP_ASSIGN, uint32_t, sd_ppi_group_assign(uint8_t group_num, uint32_t channel_msk));
328  SVCALL(SD_PPI_GROUP_GET, uint32_t, sd_ppi_group_get(uint8_t group_num, uint32_t * p_channel_msk));
329  SVCALL(SD_RADIO_NOTIFICATION_CFG_SET, uint32_t, sd_radio_notification_cfg_set(uint8_t type, uint8_t distance));
330  SVCALL(SD_ECB_BLOCK_ENCRYPT, uint32_t, sd_ecb_block_encrypt(nrf_ecb_hal_data_t * p_ecb_data));
331  SVCALL(SD_ECB_BLOCKS_ENCRYPT, uint32_t, sd_ecb_blocks_encrypt(uint8_t block_count, nrf_ecb_hal_data_block_t * p_data_blocks));
332  SVCALL(SD_EVT_GET, uint32_t, sd_evt_get(uint32_t * p_evt_id));
333  SVCALL(SD_TEMP_GET, uint32_t, sd_temp_get(int32_t * p_temp));
334  SVCALL(SD_FLASH_WRITE, uint32_t, sd_flash_write(uint32_t * p_dst, uint32_t const * p_src, uint32_t size));
335  SVCALL(SD_FLASH_PAGE_ERASE, uint32_t, sd_flash_page_erase(uint32_t page_number));
336   SVCALL(SD_RADIO_SESSION_OPEN, uint32_t, sd_radio_session_open(nrf_radio_signal_callback_t p_radio_signal_callback));
337   SVCALL(SD_RADIO_SESSION_CLOSE, uint32_t, sd_radio_session_close(void));
338   SVCALL(SD_RADIO_REQUEST, uint32_t, sd_radio_request(nrf_radio_request_t const * p_request));
339  SVCALL(SD_PROTECTED_REGISTER_WRITE, uint32_t, sd_protected_register_write(volatile uint32_t * p_register, uint32_t value));
340  #ifdef __cplusplus
341  }
342  #endif
343  #endif 
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from Adafruit_nRF52_Arduino-MDEwOlJlcG9zaXRvcnk3NDM1NDcyOQ==-flat-nrf_soc.h</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from Adafruit_nRF52_Arduino-MDEwOlJlcG9zaXRvcnk3NDM1NDcyOQ==-flat-nrf_soc_3.h</div>
                </div>
                <div class="column column_space"><pre><code>178                                             at the beginning and end of the timeslot, respectively. The crystal may also
179                                             intentionally be left running after the timeslot, in cases where it is needed
180                                             by the SoftDevice shortly after the end of the timeslot. */
181    NRF_RADIO_HFCLK_CFG_NO_GUARANTEE    &bsol;**< This configuration allows for earlier and tighter scheduling of timeslots.
182                                             The RC oscillator may be the clock source in part or for the whole duration of the timeslot.
183                                             The RC oscillator's accuracy must therefore be taken into consideration.
</pre></code></div>
                <div class="column column_space"><pre><code>202                                             at the beginning and end of the timeslot, respectively. The crystal may also
203                                             intentionally be left running after the timeslot, in cases where it is needed
204                                             by the SoftDevice shortly after the end of the timeslot. */
205    NRF_RADIO_HFCLK_CFG_NO_GUARANTEE    &bsol;**< This configuration allows for earlier and tighter scheduling of timeslots.
206                                             The RC oscillator may be the clock source in part or for the whole duration of the timeslot.
207                                             The RC oscillator's accuracy must therefore be taken into consideration.
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    