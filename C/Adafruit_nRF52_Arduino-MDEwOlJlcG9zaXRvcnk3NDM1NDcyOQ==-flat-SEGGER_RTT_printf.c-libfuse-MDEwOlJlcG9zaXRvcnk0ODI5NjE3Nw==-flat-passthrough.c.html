
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 1.7640573318632855%, Tokens: 8, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>Adafruit_nRF52_Arduino-MDEwOlJlcG9zaXRvcnk3NDM1NDcyOQ==-flat-SEGGER_RTT_printf.c</h3>
            <pre><code>1  #include "SEGGER_RTT.h"
2  #include "SEGGER_RTT_Conf.h"
3  #ifndef SEGGER_RTT_PRINTF_BUFFER_SIZE
4    #define SEGGER_RTT_PRINTF_BUFFER_SIZE (64)
5  #endif
6  #include <stdlib.h>
7  #include <stdarg.h>
8  #define FORMAT_FLAG_LEFT_JUSTIFY   (1u << 0)
9  #define FORMAT_FLAG_PAD_ZERO       (1u << 1)
10  #define FORMAT_FLAG_PRINT_SIGN     (1u << 2)
11  #define FORMAT_FLAG_ALTERNATE      (1u << 3)
12  typedef struct {
13    char*     pBuffer;
14    unsigned  BufferSize;
15    unsigned  Cnt;
16    int   ReturnValue;
17    unsigned RTTBufferIndex;
18  } SEGGER_RTT_PRINTF_DESC;
19  static void _StoreChar(SEGGER_RTT_PRINTF_DESC * p, char c) {
20    unsigned Cnt;
21    Cnt = p->Cnt;
22    if ((Cnt + 1u) <= p->BufferSize) {
23      *(p->pBuffer + Cnt) = c;
24      p->Cnt = Cnt + 1u;
25      p->ReturnValue++;
26    }
<span onclick='openModal()' class='match'>27    if (p->Cnt == p->BufferSize) {
28      if (SEGGER_RTT_Write(p->RTTBufferIndex, p->pBuffer, p->Cnt) != p->Cnt) {
29        p->ReturnValue = -1;
30      } else {
31        p->Cnt = 0u;
</span>32      }
33    }
34  }
35  static void _PrintUnsigned(SEGGER_RTT_PRINTF_DESC * pBufferDesc, unsigned v, unsigned Base, unsigned NumDigits, unsigned FieldWidth, unsigned FormatFlags) {
36    static const char _aV2C[16] = {'0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F' };
37    unsigned Div;
38    unsigned Digit;
39    unsigned Number;
40    unsigned Width;
41    char c;
42    Number = v;
43    Digit = 1u;
44    Width = 1u;
45    while (Number >= Base) {
46      Number = (Number / Base);
47      Width++;
48    }
49    if (NumDigits > Width) {
50      Width = NumDigits;
51    }
52    if ((FormatFlags & FORMAT_FLAG_LEFT_JUSTIFY) == 0u) {
53      if (FieldWidth != 0u) {
54        if (((FormatFlags & FORMAT_FLAG_PAD_ZERO) == FORMAT_FLAG_PAD_ZERO) && (NumDigits == 0u)) {
55          c = '0';
56        } else {
57          c = ' ';
58        }
59        while ((FieldWidth != 0u) && (Width < FieldWidth)) {
60          FieldWidth--;
61          _StoreChar(pBufferDesc, c);
62          if (pBufferDesc->ReturnValue < 0) {
63            break;
64          }
65        }
66      }
67    }
68    if (pBufferDesc->ReturnValue >= 0) {
69      while (1) {
70        if (NumDigits > 1u) {       
71          NumDigits--;
72        } else {
73          Div = v / Digit;
74          if (Div < Base) {        
75            break;
76          }
77        }
78        Digit *= Base;
79      }
80      do {
81        Div = v / Digit;
82        v -= Div * Digit;
83        _StoreChar(pBufferDesc, _aV2C[Div]);
84        if (pBufferDesc->ReturnValue < 0) {
85          break;
86        }
87        Digit /= Base;
88      } while (Digit);
89      if ((FormatFlags & FORMAT_FLAG_LEFT_JUSTIFY) == FORMAT_FLAG_LEFT_JUSTIFY) {
90        if (FieldWidth != 0u) {
91          while ((FieldWidth != 0u) && (Width < FieldWidth)) {
92            FieldWidth--;
93            _StoreChar(pBufferDesc, ' ');
94            if (pBufferDesc->ReturnValue < 0) {
95              break;
96            }
97          }
98        }
99      }
100    }
101  }
102  static void _PrintInt(SEGGER_RTT_PRINTF_DESC * pBufferDesc, int v, unsigned Base, unsigned NumDigits, unsigned FieldWidth, unsigned FormatFlags) {
103    unsigned Width;
104    int Number;
105    Number = (v < 0) ? -v : v;
106    Width = 1u;
107    while (Number >= (int)Base) {
108      Number = (Number / (int)Base);
109      Width++;
110    }
111    if (NumDigits > Width) {
112      Width = NumDigits;
113    }
114    if ((FieldWidth > 0u) && ((v < 0) || ((FormatFlags & FORMAT_FLAG_PRINT_SIGN) == FORMAT_FLAG_PRINT_SIGN))) {
115      FieldWidth--;
116    }
117    if ((((FormatFlags & FORMAT_FLAG_PAD_ZERO) == 0u) || (NumDigits != 0u)) && ((FormatFlags & FORMAT_FLAG_LEFT_JUSTIFY) == 0u)) {
118      if (FieldWidth != 0u) {
119        while ((FieldWidth != 0u) && (Width < FieldWidth)) {
120          FieldWidth--;
121          _StoreChar(pBufferDesc, ' ');
122          if (pBufferDesc->ReturnValue < 0) {
123            break;
124          }
125        }
126      }
127    }
128    if (pBufferDesc->ReturnValue >= 0) {
129      if (v < 0) {
130        v = -v;
131        _StoreChar(pBufferDesc, '-');
132      } else if ((FormatFlags & FORMAT_FLAG_PRINT_SIGN) == FORMAT_FLAG_PRINT_SIGN) {
133        _StoreChar(pBufferDesc, '+');
134      } else {
135      }
136      if (pBufferDesc->ReturnValue >= 0) {
137        if (((FormatFlags & FORMAT_FLAG_PAD_ZERO) == FORMAT_FLAG_PAD_ZERO) && ((FormatFlags & FORMAT_FLAG_LEFT_JUSTIFY) == 0u) && (NumDigits == 0u)) {
138          if (FieldWidth != 0u) {
139            while ((FieldWidth != 0u) && (Width < FieldWidth)) {
140              FieldWidth--;
141              _StoreChar(pBufferDesc, '0');
142              if (pBufferDesc->ReturnValue < 0) {
143                break;
144              }
145            }
146          }
147        }
148        if (pBufferDesc->ReturnValue >= 0) {
149          _PrintUnsigned(pBufferDesc, (unsigned)v, Base, NumDigits, FieldWidth, FormatFlags);
150        }
151      }
152    }
153  }
154  int SEGGER_RTT_vprintf(unsigned BufferIndex, const char * sFormat, va_list * pParamList) {
155    char c;
156    SEGGER_RTT_PRINTF_DESC BufferDesc;
157    int v;
158    unsigned NumDigits;
159    unsigned FormatFlags;
160    unsigned FieldWidth;
161    char acBuffer[SEGGER_RTT_PRINTF_BUFFER_SIZE];
162    BufferDesc.pBuffer        = acBuffer;
163    BufferDesc.BufferSize     = SEGGER_RTT_PRINTF_BUFFER_SIZE;
164    BufferDesc.Cnt            = 0u;
165    BufferDesc.RTTBufferIndex = BufferIndex;
166    BufferDesc.ReturnValue    = 0;
167    do {
168      c = *sFormat;
169      sFormat++;
170      if (c == 0u) {
171        break;
172      }
173      if (c == '%') {
174        FormatFlags = 0u;
175        v = 1;
176        do {
177          c = *sFormat;
178          switch (c) {
179          case '-': FormatFlags |= FORMAT_FLAG_LEFT_JUSTIFY; sFormat++; break;
180          case '0': FormatFlags |= FORMAT_FLAG_PAD_ZERO;     sFormat++; break;
181          case '+': FormatFlags |= FORMAT_FLAG_PRINT_SIGN;   sFormat++; break;
182          case '#': FormatFlags |= FORMAT_FLAG_ALTERNATE;    sFormat++; break;
183          default:  v = 0; break;
184          }
185        } while (v);
186        FieldWidth = 0u;
187        do {
188          c = *sFormat;
189          if ((c < '0') || (c > '9')) {
190            break;
191          }
192          sFormat++;
193          FieldWidth = (FieldWidth * 10u) + ((unsigned)c - '0');
194        } while (1);
195        NumDigits = 0u;
196        c = *sFormat;
197        if (c == '.') {
198          sFormat++;
199          do {
200            c = *sFormat;
201            if ((c < '0') || (c > '9')) {
202              break;
203            }
204            sFormat++;
205            NumDigits = NumDigits * 10u + ((unsigned)c - '0');
206          } while (1);
207        }
208        c = *sFormat;
209        do {
210          if ((c == 'l') || (c == 'h')) {
211            sFormat++;
212            c = *sFormat;
213          } else {
214            break;
215          }
216        } while (1);
217        switch (c) {
218        case 'c': {
219          char c0;
220          v = va_arg(*pParamList, int);
221          c0 = (char)v;
222          _StoreChar(&BufferDesc, c0);
223          break;
224        }
225        case 'd':
226          v = va_arg(*pParamList, int);
227          _PrintInt(&BufferDesc, v, 10u, NumDigits, FieldWidth, FormatFlags);
228          break;
229        case 'u':
230          v = va_arg(*pParamList, int);
231          _PrintUnsigned(&BufferDesc, (unsigned)v, 10u, NumDigits, FieldWidth, FormatFlags);
232          break;
233        case 'x':
234        case 'X':
235          v = va_arg(*pParamList, int);
236          _PrintUnsigned(&BufferDesc, (unsigned)v, 16u, NumDigits, FieldWidth, FormatFlags);
237          break;
238        case 's':
239          {
240            const char * s = va_arg(*pParamList, const char *);
241            do {
242              c = *s;
243              s++;
244              if (c == '\0') {
245                break;
246              }
247             _StoreChar(&BufferDesc, c);
248            } while (BufferDesc.ReturnValue >= 0);
249          }
250          break;
251        case 'p':
252          v = va_arg(*pParamList, int);
253          _PrintUnsigned(&BufferDesc, (unsigned)v, 16u, 8u, 8u, 0u);
254          break;
255        case '%':
256          _StoreChar(&BufferDesc, '%');
257          break;
258        default:
259          break;
260        }
261        sFormat++;
262      } else {
263        _StoreChar(&BufferDesc, c);
264      }
265    } while (BufferDesc.ReturnValue >= 0);
266    if (BufferDesc.ReturnValue > 0) {
267      if (BufferDesc.Cnt != 0u) {
268        SEGGER_RTT_Write(BufferIndex, acBuffer, BufferDesc.Cnt);
269      }
270      BufferDesc.ReturnValue += (int)BufferDesc.Cnt;
271    }
272    return BufferDesc.ReturnValue;
273  }
274  int SEGGER_RTT_printf(unsigned BufferIndex, const char * sFormat, ...) {
275    int r;
276    va_list ParamList;
277    va_start(ParamList, sFormat);
278    r = SEGGER_RTT_vprintf(BufferIndex, sFormat, &ParamList);
279    va_end(ParamList);
280    return r;
281  }
</code></pre>
        </div>
        <div class="column">
            <h3>libfuse-MDEwOlJlcG9zaXRvcnk0ODI5NjE3Nw==-flat-passthrough.c</h3>
            <pre><code>1  #define FUSE_USE_VERSION 31
2  #define _GNU_SOURCE
3  #ifdef linux
4  #define _XOPEN_SOURCE 700
5  #endif
6  #include <fuse.h>
7  #include <stdio.h>
8  #include <string.h>
9  #include <unistd.h>
10  #include <fcntl.h>
11  #include <sys/stat.h>
12  #include <dirent.h>
13  #include <errno.h>
14  #ifdef __FreeBSD__
15  #include <sys/socket.h>
16  #include <sys/un.h>
17  #endif
18  #include <sys/time.h>
19  #ifdef HAVE_SETXATTR
20  #include <sys/xattr.h>
21  #endif
22  #include "passthrough_helpers.h"
23  static int fill_dir_plus = 0;
24  static void *xmp_init(struct fuse_conn_info *conn,
25  		      struct fuse_config *cfg)
26  {
27  	(void) conn;
28  	cfg->use_ino = 1;
29  	cfg->entry_timeout = 0;
30  	cfg->attr_timeout = 0;
31  	cfg->negative_timeout = 0;
32  	return NULL;
33  }
34  static int xmp_getattr(const char *path, struct stat *stbuf,
35  		       struct fuse_file_info *fi)
36  {
37  	(void) fi;
38  	int res;
39  	res = lstat(path, stbuf);
40  	if (res == -1)
41  		return -errno;
42  	return 0;
43  }
44  static int xmp_access(const char *path, int mask)
45  {
46  	int res;
47  	res = access(path, mask);
48  	if (res == -1)
49  		return -errno;
50  	return 0;
51  }
52  static int xmp_readlink(const char *path, char *buf, size_t size)
53  {
54  	int res;
55  	res = readlink(path, buf, size - 1);
56  	if (res == -1)
57  		return -errno;
58  	buf[res] = '\0';
59  	return 0;
60  }
61  static int xmp_readdir(const char *path, void *buf, fuse_fill_dir_t filler,
62  		       off_t offset, struct fuse_file_info *fi,
63  		       enum fuse_readdir_flags flags)
64  {
65  	DIR *dp;
66  	struct dirent *de;
67  	(void) offset;
68  	(void) fi;
69  	(void) flags;
70  	dp = opendir(path);
71  	if (dp == NULL)
72  		return -errno;
73  	while ((de = readdir(dp)) != NULL) {
74  		struct stat st;
75  		memset(&st, 0, sizeof(st));
76  		st.st_ino = de->d_ino;
77  		st.st_mode = de->d_type << 12;
78  		if (filler(buf, de->d_name, &st, 0, fill_dir_plus))
79  			break;
80  	}
81  	closedir(dp);
82  	return 0;
83  }
84  static int xmp_mknod(const char *path, mode_t mode, dev_t rdev)
85  {
86  	int res;
87  	res = mknod_wrapper(AT_FDCWD, path, NULL, mode, rdev);
88  	if (res == -1)
89  		return -errno;
90  	return 0;
91  }
92  static int xmp_mkdir(const char *path, mode_t mode)
93  {
94  	int res;
95  	res = mkdir(path, mode);
96  	if (res == -1)
97  		return -errno;
98  	return 0;
99  }
100  static int xmp_unlink(const char *path)
101  {
102  	int res;
103  	res = unlink(path);
104  	if (res == -1)
105  		return -errno;
106  	return 0;
107  }
108  static int xmp_rmdir(const char *path)
109  {
110  	int res;
111  	res = rmdir(path);
112  	if (res == -1)
113  		return -errno;
114  	return 0;
115  }
116  static int xmp_symlink(const char *from, const char *to)
117  {
118  	int res;
119  	res = symlink(from, to);
120  	if (res == -1)
121  		return -errno;
122  	return 0;
123  }
124  static int xmp_rename(const char *from, const char *to, unsigned int flags)
125  {
126  	int res;
127  	if (flags)
128  		return -EINVAL;
129  	res = rename(from, to);
130  	if (res == -1)
131  		return -errno;
132  	return 0;
133  }
134  static int xmp_link(const char *from, const char *to)
135  {
136  	int res;
137  	res = link(from, to);
138  	if (res == -1)
139  		return -errno;
140  	return 0;
141  }
142  static int xmp_chmod(const char *path, mode_t mode,
143  		     struct fuse_file_info *fi)
144  {
145  	(void) fi;
146  	int res;
147  	res = chmod(path, mode);
148  	if (res == -1)
149  		return -errno;
150  	return 0;
151  }
152  static int xmp_chown(const char *path, uid_t uid, gid_t gid,
153  		     struct fuse_file_info *fi)
154  {
155  	(void) fi;
156  	int res;
157  	res = lchown(path, uid, gid);
158  	if (res == -1)
159  		return -errno;
160  	return 0;
161  }
162  static int xmp_truncate(const char *path, off_t size,
163  			struct fuse_file_info *fi)
164  {
165  	int res;
166  	if (fi != NULL)
167  		res = ftruncate(fi->fh, size);
168  	else
169  		res = truncate(path, size);
170  	if (res == -1)
171  		return -errno;
172  	return 0;
173  }
174  #ifdef HAVE_UTIMENSAT
175  static int xmp_utimens(const char *path, const struct timespec ts[2],
176  		       struct fuse_file_info *fi)
177  {
178  	(void) fi;
179  	int res;
180  	res = utimensat(0, path, ts, AT_SYMLINK_NOFOLLOW);
181  	if (res == -1)
182  		return -errno;
183  	return 0;
184  }
185  #endif
186  static int xmp_create(const char *path, mode_t mode,
187  		      struct fuse_file_info *fi)
188  {
189  	int res;
190  	res = open(path, fi->flags, mode);
191  	if (res == -1)
192  		return -errno;
193  	fi->fh = res;
194  	return 0;
195  }
196  static int xmp_open(const char *path, struct fuse_file_info *fi)
197  {
198  	int res;
199  	res = open(path, fi->flags);
200  	if (res == -1)
201  		return -errno;
202  	fi->fh = res;
203  	return 0;
204  }
205  static int xmp_read(const char *path, char *buf, size_t size, off_t offset,
206  		    struct fuse_file_info *fi)
207  {
208  	int fd;
209  	int res;
210  	if(fi == NULL)
211  		fd = open(path, O_RDONLY);
212  	else
213  		fd = fi->fh;
214  	if (fd == -1)
215  		return -errno;
216  	res = pread(fd, buf, size, offset);
217  	if (res == -1)
218  		res = -errno;
219  	if(fi == NULL)
220  		close(fd);
221  	return res;
222  }
223  static int xmp_write(const char *path, const char *buf, size_t size,
224  		     off_t offset, struct fuse_file_info *fi)
225  {
226  	int fd;
227  	int res;
228  	(void) fi;
229  	if(fi == NULL)
230  		fd = open(path, O_WRONLY);
231  	else
232  		fd = fi->fh;
233  	if (fd == -1)
234  		return -errno;
235  	res = pwrite(fd, buf, size, offset);
236  	if (res == -1)
237  		res = -errno;
238  	if(fi == NULL)
239  		close(fd);
240  	return res;
241  }
242  static int xmp_statfs(const char *path, struct statvfs *stbuf)
243  {
244  	int res;
245  	res = statvfs(path, stbuf);
246  	if (res == -1)
247  		return -errno;
248  	return 0;
249  }
250  static int xmp_release(const char *path, struct fuse_file_info *fi)
251  {
252  	(void) path;
253  	close(fi->fh);
254  	return 0;
255  }
256  static int xmp_fsync(const char *path, int isdatasync,
257  		     struct fuse_file_info *fi)
258  {
259  	(void) path;
260  	(void) isdatasync;
261  	(void) fi;
262  	return 0;
263  }
264  #ifdef HAVE_POSIX_FALLOCATE
265  static int xmp_fallocate(const char *path, int mode,
266  			off_t offset, off_t length, struct fuse_file_info *fi)
267  {
268  	int fd;
269  	int res;
270  	(void) fi;
271  	if (mode)
272  		return -EOPNOTSUPP;
273  	if(fi == NULL)
274  		fd = open(path, O_WRONLY);
275  	else
276  		fd = fi->fh;
277  	if (fd == -1)
278  		return -errno;
279  	res = -posix_fallocate(fd, offset, length);
280  	if(fi == NULL)
281  		close(fd);
282  	return res;
283  }
284  #endif
285  #ifdef HAVE_SETXATTR
286  static int xmp_setxattr(const char *path, const char *name, const char *value,
287  			size_t size, int flags)
288  {
289  	int res = lsetxattr(path, name, value, size, flags);
290  	if (res == -1)
291  		return -errno;
292  	return 0;
293  }
294  static int xmp_getxattr(const char *path, const char *name, char *value,
295  			size_t size)
296  {
297  	int res = lgetxattr(path, name, value, size);
298  	if (res == -1)
299  		return -errno;
300  	return res;
301  }
302  static int xmp_listxattr(const char *path, char *list, size_t size)
303  {
304  	int res = llistxattr(path, list, size);
305  	if (res == -1)
306  		return -errno;
307  	return res;
308  }
309  static int xmp_removexattr(const char *path, const char *name)
310  {
311  	int res = lremovexattr(path, name);
312  	if (res == -1)
313  		return -errno;
314  	return 0;
315  }
316  #endif &bsol;* HAVE_SETXATTR */
317  #ifdef HAVE_COPY_FILE_RANGE
318  static ssize_t xmp_copy_file_range(const char *path_in,
319  				   struct fuse_file_info *fi_in,
320  				   off_t offset_in, const char *path_out,
321  				   struct fuse_file_info *fi_out,
322  				   off_t offset_out, size_t len, int flags)
323  {
324  	int fd_in, fd_out;
325  	ssize_t res;
326  	if(fi_in == NULL)
327  		fd_in = open(path_in, O_RDONLY);
328  	else
329  		fd_in = fi_in->fh;
330  	if (fd_in == -1)
331  		return -errno;
332  	if(fi_out == NULL)
333  		fd_out = open(path_out, O_WRONLY);
334  	else
335  		fd_out = fi_out->fh;
336  	if (fd_out == -1) {
337  		close(fd_in);
338  		return -errno;
339  	}
340  	res = copy_file_range(fd_in, &offset_in, fd_out, &offset_out, len,
341  			      flags);
342  	if (res == -1)
343  		res = -errno;
344  	if (fi_out == NULL)
345  		close(fd_out);
346  	if (fi_in == NULL)
347  		close(fd_in);
348  	return res;
349  }
350  #endif
351  static off_t xmp_lseek(const char *path, off_t off, int whence, struct fuse_file_info *fi)
352  {
353  	int fd;
354  	off_t res;
355  	if (fi == NULL)
356  		fd = open(path, O_RDONLY);
357  	else
358  		fd = fi->fh;
359  	if (fd == -1)
360  		return -errno;
361  	res = lseek(fd, off, whence);
362  	if (res == -1)
363  		res = -errno;
364  	if (fi == NULL)
365  		close(fd);
366  	return res;
367  }
368  static const struct fuse_operations xmp_oper = {
369  	.init           = xmp_init,
370  	.getattr	= xmp_getattr,
371  	.access		= xmp_access,
372  	.readlink	= xmp_readlink,
373  	.readdir	= xmp_readdir,
374  	.mknod		= xmp_mknod,
375  	.mkdir		= xmp_mkdir,
376  	.symlink	= xmp_symlink,
377  	.unlink		= xmp_unlink,
378  	.rmdir		= xmp_rmdir,
379  	.rename		= xmp_rename,
380  	.link		= xmp_link,
381  	.chmod		= xmp_chmod,
382  	.chown		= xmp_chown,
383  	.truncate	= xmp_truncate,
384  #ifdef HAVE_UTIMENSAT
385  	.utimens	= xmp_utimens,
386  #endif
387  	.open		= xmp_open,
388  	.create 	= xmp_create,
389  	.read		= xmp_read,
390  	.write		= xmp_write,
391  	.statfs		= xmp_statfs,
392  	.release	= xmp_release,
393  	.fsync		= xmp_fsync,
394  #ifdef HAVE_POSIX_FALLOCATE
395  	.fallocate	= xmp_fallocate,
396  #endif
397  #ifdef HAVE_SETXATTR
398  	.setxattr	= xmp_setxattr,
399  	.getxattr	= xmp_getxattr,
400  	.listxattr	= xmp_listxattr,
401  	.removexattr	= xmp_removexattr,
402  #endif
403  #ifdef HAVE_COPY_FILE_RANGE
404  	.copy_file_range = xmp_copy_file_range,
405  #endif
406  	.lseek		= xmp_lseek,
407  };
408  int main(int argc, char *argv[])
409  {
410  	enum { MAX_ARGS = 10 };
411  	int i,new_argc;
412  	char *new_argv[MAX_ARGS];
413  	umask(0);
<span onclick='openModal()' class='match'>414  	for (i=0, new_argc=0; (i<argc) && (new_argc<MAX_ARGS); i++) {
415  		if (!strcmp(argv[i], "--plus")) {
416  			fill_dir_plus = FUSE_FILL_DIR_PLUS;
417  		} else {
418  			new_argv[new_argc++] = argv[i];
</span>419  		}
420  	}
421  	return fuse_main(new_argc, new_argv, &xmp_oper, NULL);
422  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from Adafruit_nRF52_Arduino-MDEwOlJlcG9zaXRvcnk3NDM1NDcyOQ==-flat-SEGGER_RTT_printf.c</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from libfuse-MDEwOlJlcG9zaXRvcnk0ODI5NjE3Nw==-flat-passthrough.c</div>
                </div>
                <div class="column column_space"><pre><code>27    if (p->Cnt == p->BufferSize) {
28      if (SEGGER_RTT_Write(p->RTTBufferIndex, p->pBuffer, p->Cnt) != p->Cnt) {
29        p->ReturnValue = -1;
30      } else {
31        p->Cnt = 0u;
</pre></code></div>
                <div class="column column_space"><pre><code>414  	for (i=0, new_argc=0; (i<argc) && (new_argc<MAX_ARGS); i++) {
415  		if (!strcmp(argv[i], "--plus")) {
416  			fill_dir_plus = FUSE_FILL_DIR_PLUS;
417  		} else {
418  			new_argv[new_argc++] = argv[i];
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    