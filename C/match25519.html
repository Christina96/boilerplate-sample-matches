<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for replicate.c &amp; niftiload.c</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for replicate.c &amp; niftiload.c
      </h3>
<h1 align="center">
        4.0%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>replicate.c (12.264151%)<th>niftiload.c (2.3941069%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(172-188)<td><a href="#" name="0">(567-578)</a><td align="center"><font color="#ff0000">13</font>
</td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>replicate.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 #ifdef HAVE_CONFIG_H
2 #include &lt;config.h&gt;
3 #include &lt;vips/intl.h&gt;
4 #include &lt;stdio.h&gt;
5 #include &lt;string.h&gt;
6 #include &lt;stdlib.h&gt;
7 #include &lt;vips/vips.h&gt;
8 #include &lt;vips/internal.h&gt;
9 #include &lt;vips/debug.h&gt;
10 #include "pconversion.h"
11 typedef struct _VipsReplicate {
12 	VipsConversion parent_instance;
13 	VipsImage *in;
14 	int across;
15 	int down;
16 } VipsReplicate;
17 typedef VipsConversionClass VipsReplicateClass;
18 G_DEFINE_TYPE( VipsReplicate, vips_replicate, VIPS_TYPE_CONVERSION );
19 static int
20 vips_replicate_gen( VipsRegion *or, void *seq, void *a, void *b, 
21 	gboolean *stop )
22 {
23 	VipsRegion *ir = (VipsRegion *) seq;
24 	VipsImage *in = (VipsImage *) a;
25 	VipsRect *r = &amp;or-&gt;valid;
26 	int twidth = in-&gt;Xsize;
27 	int theight = in-&gt;Ysize;
28 	int x, y;
29 	VipsRect tile;
30 	int xs = (r-&gt;left / twidth) * twidth;
31 	int ys = (r-&gt;top / theight) * theight;
32 	tile.left = xs;
33 	tile.top = ys;
34 	tile.width = twidth;
35 	tile.height = theight;
36 	if( vips_rect_includesrect( &amp;tile, r ) ) {
37 		VipsRect irect;
38 		irect = *r;
39 		irect.left -= xs;
40 		irect.top -= ys;
41 		if( vips_region_prepare( ir, &amp;irect ) )
42 			return( -1 );
43 		if( vips_region_region( or, ir, r, irect.left, irect.top ) )
44 			return( -1 );
45 		return( 0 );
46 	}
47 	for( y = ys; y &lt; VIPS_RECT_BOTTOM( r ); y += theight )
48 		for( x = xs; x &lt; VIPS_RECT_RIGHT( r ); x += twidth ) {
49 			VipsRect paint;
50 			tile.left = x;
51 			tile.top = y;
52 			tile.width = twidth;
53 			tile.height = theight;
54 			vips_rect_intersectrect( &amp;tile, r, &amp;paint );
55 			paint.left -= x;
56 			paint.top -= y;
57 			g_assert( !vips_rect_isempty( &amp;paint ) );
58 			if( vips_region_prepare_to( ir, or, &amp;paint,
59 				paint.left + x,
60 				paint.top + y ) )
61 				return( -1 );
62 		}
63 	return( 0 );
64 }
65 static int
66 vips_replicate_build( VipsObject *object )
67 {
68 	VipsConversion *conversion = VIPS_CONVERSION( object );
69 	VipsReplicate *replicate = (VipsReplicate *) object;
70 	if( VIPS_OBJECT_CLASS( vips_replicate_parent_class )-&gt;build( object ) )
71 		return( -1 );
72 	if( vips_image_pio_input( replicate-&gt;in ) )
73 		return( -1 );
74 	if( vips_image_pipelinev( conversion-&gt;out, 
75 		VIPS_DEMAND_STYLE_SMALLTILE, replicate-&gt;in, NULL ) )
76 		return( -1 );
77 <a name="0"></a>	conversion-&gt;out-&gt;Xsize *= replicate-&gt;across;
78 	conversion-&gt;out-&gt;Ysize *= replicate-&gt;down;
79 <font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>	if( vips_image_generate( conversion-&gt;out,
80 		vips_start_one, vips_replicate_gen, vips_stop_one, 
81 		replicate-&gt;in, replicate ) )
82 		return( -1 );
83 	return( 0 );
84 }
85 static void
86 vips_replicate_class_init( VipsReplicateClass *class )
87 {
88 	GObjectClass *gobject_class = G_OBJECT_CLASS( class );
89 	VipsObjectClass *vobject_class = VIPS_OBJECT_CLASS( class );
90 	VIPS_DEBUG_MSG( "vips_replicate_class_init\n" );
91 	gobject_class-&gt;set_property = vips_object_set_property;</b></font>
92 	gobject_class-&gt;get_property = vips_object_get_property;
93 	vobject_class-&gt;nickname = "replicate";
94 	vobject_class-&gt;description = _( "replicate an image" );
95 	vobject_class-&gt;build = vips_replicate_build;
96 	VIPS_ARG_IMAGE( class, "in", 0, 
97 		_( "Input" ), 
98 		_( "Input image" ),
99 		VIPS_ARGUMENT_REQUIRED_INPUT,
100 		G_STRUCT_OFFSET( VipsReplicate, in ) );
101 	VIPS_ARG_INT( class, "across", 4, 
102 		_( "Across" ), 
103 		_( "Repeat this many times horizontally" ),
104 		VIPS_ARGUMENT_REQUIRED_INPUT,
105 		G_STRUCT_OFFSET( VipsReplicate, across ),
106 		1, 1000000, 1 );
107 	VIPS_ARG_INT( class, "down", 5, 
108 		_( "Down" ), 
109 		_( "Repeat this many times vertically" ),
110 		VIPS_ARGUMENT_REQUIRED_INPUT,
111 		G_STRUCT_OFFSET( VipsReplicate, down ),
112 		1, 1000000, 1 );
113 }
114 static void
115 vips_replicate_init( VipsReplicate *replicate )
116 {
117 }
118 int
119 vips_replicate( VipsImage *in, VipsImage **out, int across, int down, ... )
120 {
121 	va_list ap;
122 	int result;
123 	va_start( ap, down );
124 	result = vips_call_split( "replicate", ap, in, out, across, down );
125 	va_end( ap );
126 	return( result );
127 }
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>niftiload.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 #ifdef HAVE_CONFIG_H
2 #include &lt;config.h&gt;
3 #include &lt;vips/intl.h&gt;
4 #include &lt;stdio.h&gt;
5 #include &lt;stdlib.h&gt;
6 #include &lt;string.h&gt;
7 #include &lt;vips/vips.h&gt;
8 #include &lt;vips/debug.h&gt;
9 #include &lt;vips/internal.h&gt;
10 #ifdef HAVE_NIFTI
11 #include &lt;nifti1_io.h&gt;
12 #include "pforeign.h"
13 typedef struct _VipsForeignLoadNifti {
14 	VipsForeignLoad parent_object;
15 	VipsSource *source;
16 	const char *filename;
17 	nifti_image *nim;
18 	VipsImage *memory;
19 } VipsForeignLoadNifti;
20 typedef VipsForeignLoadClass VipsForeignLoadNiftiClass;
21 G_DEFINE_ABSTRACT_TYPE( VipsForeignLoadNifti, vips_foreign_load_nifti, 
22 	VIPS_TYPE_FOREIGN_LOAD );
23 static void
24 vips_foreign_load_nifti_dispose( GObject *gobject )
25 {
26 	VipsForeignLoadNifti *nifti = (VipsForeignLoadNifti *) gobject;
27 	VIPS_UNREF( nifti-&gt;source );
28 	VIPS_UNREF( nifti-&gt;memory );
29 	VIPS_FREEF( nifti_image_free, nifti-&gt;nim );
30 	G_OBJECT_CLASS( vips_foreign_load_nifti_parent_class )-&gt;
31 		dispose( gobject );
32 }
33 static int
34 vips_foreign_load_nifti_build( VipsObject *object )
35 {
36 	VipsObjectClass *class = VIPS_OBJECT_GET_CLASS( object );
37 	VipsForeignLoadNifti *nifti = (VipsForeignLoadNifti *) object;
38 	if( nifti-&gt;source ) {
39 		nifti-&gt;filename = vips_connection_filename( VIPS_CONNECTION( 
40 			nifti-&gt;source ) );
41 		if( !nifti-&gt;filename ) {
42 			vips_error( class-&gt;nickname, "%s", 
43 				_( "no filename available" ) );
44 			return( -1 );
45 		}
46 	}
47 	if( VIPS_OBJECT_CLASS( vips_foreign_load_nifti_parent_class )-&gt;
48 		build( object ) )
49 		return( -1 );
50 	return( 0 );
51 }
52 typedef struct _VipsForeignDT2Vips {
53 	int datatype;
54 	VipsBandFormat fmt;
55 } VipsForeignDT2Vips ;
56 static VipsForeignDT2Vips vips_foreign_nifti_DT2Vips[] = {
57 	{ DT_UINT8, VIPS_FORMAT_UCHAR },
58 	{ DT_INT8, VIPS_FORMAT_CHAR },
59 	{ DT_UINT16, VIPS_FORMAT_USHORT },
60 	{ DT_INT16, VIPS_FORMAT_SHORT },
61 	{ DT_UINT32, VIPS_FORMAT_UINT },
62 	{ DT_INT32, VIPS_FORMAT_INT },
63 	{ DT_FLOAT32, VIPS_FORMAT_FLOAT },
64 	{ DT_FLOAT64, VIPS_FORMAT_DOUBLE },
65 	{ DT_COMPLEX64, VIPS_FORMAT_COMPLEX },
66 	{ DT_COMPLEX128, VIPS_FORMAT_DPCOMPLEX },
67 	{ DT_RGB, VIPS_FORMAT_UCHAR },
68 	{ DT_RGBA32, VIPS_FORMAT_UCHAR }
69 };
70 VipsBandFormat
71 vips__foreign_nifti_datatype2BandFmt( int datatype )
72 {
73 	int i;
74 	for( i = 0; i &lt; VIPS_NUMBER( vips_foreign_nifti_DT2Vips ); i++ )
75 		if( vips_foreign_nifti_DT2Vips[i].datatype == datatype )
76 			return( vips_foreign_nifti_DT2Vips[i].fmt );
77 	return( VIPS_FORMAT_NOTSET );
78 }
79 int
80 vips__foreign_nifti_BandFmt2datatype( VipsBandFormat fmt )
81 {
82 	int i;
83 	for( i = 0; i &lt; VIPS_NUMBER( vips_foreign_nifti_DT2Vips ); i++ )
84 		if( vips_foreign_nifti_DT2Vips[i].fmt == fmt )
85 			return( vips_foreign_nifti_DT2Vips[i].datatype );
86 	return( -1 );
87 }
88 typedef struct _VipsForeignNiftiFields {
89 	char *name;
90 	GType type;
91 	glong offset;
92 } VipsForeignNiftiFields;
93 static VipsForeignNiftiFields vips_foreign_nifti_fields[] = {
94 	{ "ndim", G_TYPE_INT, G_STRUCT_OFFSET( nifti_image, ndim ) }, 
95 	{ "nx", G_TYPE_INT, G_STRUCT_OFFSET( nifti_image, nx ) }, 
96 	{ "ny", G_TYPE_INT, G_STRUCT_OFFSET( nifti_image, ny ) }, 
97 	{ "nz", G_TYPE_INT, G_STRUCT_OFFSET( nifti_image, nz ) }, 
98 	{ "nt", G_TYPE_INT, G_STRUCT_OFFSET( nifti_image, nt ) }, 
99 	{ "nu", G_TYPE_INT, G_STRUCT_OFFSET( nifti_image, nu ) }, 
100 	{ "nv", G_TYPE_INT, G_STRUCT_OFFSET( nifti_image, nv ) }, 
101 	{ "nw", G_TYPE_INT, G_STRUCT_OFFSET( nifti_image, nw ) }, 
102 	{ "dx", G_TYPE_DOUBLE, G_STRUCT_OFFSET( nifti_image, dx ) }, 
103 	{ "dy", G_TYPE_DOUBLE, G_STRUCT_OFFSET( nifti_image, dy ) }, 
104 	{ "dz", G_TYPE_DOUBLE, G_STRUCT_OFFSET( nifti_image, dz ) }, 
105 	{ "dt", G_TYPE_DOUBLE, G_STRUCT_OFFSET( nifti_image, dt ) }, 
106 	{ "du", G_TYPE_DOUBLE, G_STRUCT_OFFSET( nifti_image, du ) }, 
107 	{ "dv", G_TYPE_DOUBLE, G_STRUCT_OFFSET( nifti_image, dv ) }, 
108 	{ "dw", G_TYPE_DOUBLE, G_STRUCT_OFFSET( nifti_image, dw ) }, 
109 	{ "scl_slope", G_TYPE_DOUBLE, 
110 		G_STRUCT_OFFSET( nifti_image, scl_slope ) }, 
111 	{ "scl_inter", G_TYPE_DOUBLE, 
112 		G_STRUCT_OFFSET( nifti_image, scl_inter ) }, 
113 	{ "cal_min", G_TYPE_DOUBLE, 
114 		G_STRUCT_OFFSET( nifti_image, cal_min ) }, 
115 	{ "cal_max", G_TYPE_DOUBLE, 
116 		G_STRUCT_OFFSET( nifti_image, cal_max ) }, 
117 	{ "qform_code", G_TYPE_INT, 
118 		G_STRUCT_OFFSET( nifti_image, qform_code ) }, 
119 	{ "sform_code", G_TYPE_INT, 
120 		G_STRUCT_OFFSET( nifti_image, sform_code ) }, 
121 	{ "freq_dim", G_TYPE_INT, 
122 		G_STRUCT_OFFSET( nifti_image, freq_dim ) }, 
123 	{ "phase_dim", G_TYPE_INT, 
124 		G_STRUCT_OFFSET( nifti_image, phase_dim ) }, 
125 	{ "slice_dim", G_TYPE_INT, 
126 		G_STRUCT_OFFSET( nifti_image, slice_dim ) }, 
127 	{ "slice_code", G_TYPE_INT, 
128 		G_STRUCT_OFFSET( nifti_image, slice_code ) }, 
129 	{ "slice_start", G_TYPE_INT, 
130 		G_STRUCT_OFFSET( nifti_image, slice_start ) }, 
131 	{ "slice_end", G_TYPE_INT, 
132 		G_STRUCT_OFFSET( nifti_image, slice_end ) }, 
133 	{ "slice_duration", G_TYPE_DOUBLE, 
134 		G_STRUCT_OFFSET( nifti_image, slice_duration ) }, 
135 	{ "quatern_b", G_TYPE_DOUBLE, 
136 		G_STRUCT_OFFSET( nifti_image, quatern_b ) }, 
137 	{ "quatern_c", G_TYPE_DOUBLE, 
138 		G_STRUCT_OFFSET( nifti_image, quatern_c ) }, 
139 	{ "quatern_d", G_TYPE_DOUBLE, 
140 		G_STRUCT_OFFSET( nifti_image, quatern_d ) }, 
141 	{ "qoffset_x", G_TYPE_DOUBLE, 
142 		G_STRUCT_OFFSET( nifti_image, qoffset_x ) }, 
143 	{ "qoffset_y", G_TYPE_DOUBLE, 
144 		G_STRUCT_OFFSET( nifti_image, qoffset_y ) }, 
145 	{ "qoffset_z", G_TYPE_DOUBLE, 
146 		G_STRUCT_OFFSET( nifti_image, qoffset_z ) }, 
147 	{ "qfac", G_TYPE_DOUBLE, 
148 		G_STRUCT_OFFSET( nifti_image, qfac ) }, 
149 	{ "sto_xyz00", G_TYPE_DOUBLE, 
150 		G_STRUCT_OFFSET( nifti_image, sto_xyz.m[0][0] ) }, 
151 	{ "sto_xyz01", G_TYPE_DOUBLE, 
152 		G_STRUCT_OFFSET( nifti_image, sto_xyz.m[0][1] ) }, 
153 	{ "sto_xyz02", G_TYPE_DOUBLE, 
154 		G_STRUCT_OFFSET( nifti_image, sto_xyz.m[0][2] ) }, 
155 	{ "sto_xyz03", G_TYPE_DOUBLE, 
156 		G_STRUCT_OFFSET( nifti_image, sto_xyz.m[0][3] ) }, 
157 	{ "sto_xyz10", G_TYPE_DOUBLE, 
158 		G_STRUCT_OFFSET( nifti_image, sto_xyz.m[1][0] ) }, 
159 	{ "sto_xyz11", G_TYPE_DOUBLE, 
160 		G_STRUCT_OFFSET( nifti_image, sto_xyz.m[1][1] ) }, 
161 	{ "sto_xyz12", G_TYPE_DOUBLE, 
162 		G_STRUCT_OFFSET( nifti_image, sto_xyz.m[1][2] ) }, 
163 	{ "sto_xyz13", G_TYPE_DOUBLE, 
164 		G_STRUCT_OFFSET( nifti_image, sto_xyz.m[1][3] ) }, 
165 	{ "sto_xyz20", G_TYPE_DOUBLE, 
166 		G_STRUCT_OFFSET( nifti_image, sto_xyz.m[2][0] ) }, 
167 	{ "sto_xyz21", G_TYPE_DOUBLE, 
168 		G_STRUCT_OFFSET( nifti_image, sto_xyz.m[2][1] ) }, 
169 	{ "sto_xyz22", G_TYPE_DOUBLE, 
170 		G_STRUCT_OFFSET( nifti_image, sto_xyz.m[2][2] ) }, 
171 	{ "sto_xyz23", G_TYPE_DOUBLE, 
172 		G_STRUCT_OFFSET( nifti_image, sto_xyz.m[2][3] ) }, 
173 	{ "sto_xyz30", G_TYPE_DOUBLE, 
174 		G_STRUCT_OFFSET( nifti_image, sto_xyz.m[3][0] ) }, 
175 	{ "sto_xyz31", G_TYPE_DOUBLE, 
176 		G_STRUCT_OFFSET( nifti_image, sto_xyz.m[3][1] ) }, 
177 	{ "sto_xyz32", G_TYPE_DOUBLE, 
178 		G_STRUCT_OFFSET( nifti_image, sto_xyz.m[3][2] ) }, 
179 	{ "sto_xyz33", G_TYPE_DOUBLE, 
180 		G_STRUCT_OFFSET( nifti_image, sto_xyz.m[3][3] ) }, 
181 	{ "toffset", G_TYPE_DOUBLE, 
182 		G_STRUCT_OFFSET( nifti_image, toffset ) }, 
183 	{ "xyz_units", G_TYPE_INT, 
184 		G_STRUCT_OFFSET( nifti_image, xyz_units ) }, 
185 	{ "time_units", G_TYPE_INT, 
186 		G_STRUCT_OFFSET( nifti_image, time_units ) }, 
187 	{ "nifti_type", G_TYPE_INT, 
188 		G_STRUCT_OFFSET( nifti_image, nifti_type ) }, 
189 	{ "intent_code", G_TYPE_INT, 
190 		G_STRUCT_OFFSET( nifti_image, intent_code ) }, 
191 	{ "intent_p1", G_TYPE_DOUBLE, 
192 		G_STRUCT_OFFSET( nifti_image, intent_p1 ) }, 
193 	{ "intent_p2", G_TYPE_DOUBLE, 
194 		G_STRUCT_OFFSET( nifti_image, intent_p2 ) }, 
195 	{ "intent_p3", G_TYPE_DOUBLE, 
196 		G_STRUCT_OFFSET( nifti_image, intent_p3 ) }, 
197 };
198 void *
199 vips__foreign_nifti_map( VipsNiftiMapFn fn, void *a, void *b )
200 {
201 	int i;
202 	void *result;
203 	for( i = 0; i &lt; VIPS_NUMBER( vips_foreign_nifti_fields ); i++ ) {
204 		GValue value = { 0 };
205 		g_value_init( &amp;value, vips_foreign_nifti_fields[i].type );
206 		result = fn( vips_foreign_nifti_fields[i].name, &amp;value,
207 			vips_foreign_nifti_fields[i].offset, a, b );
208 		g_value_unset( &amp;value );
209 		if( result )
210 			return( result );
211 	}
212 	return( NULL );
213 }
214 static void
215 vips_gvalue_read( GValue *value, void *p )
216 {
217 	switch( G_VALUE_TYPE( value ) ) {
218 	case G_TYPE_INT:
219 		g_value_set_int( value, *((int *) p) );
220 		break;
221 	case G_TYPE_DOUBLE:
222 		g_value_set_double( value, *((float *) p) );
223 		break;
224 	default:
225 		g_warning( "vips_gvalue_read: unsupported GType %s", 
226 			g_type_name( G_VALUE_TYPE( value ) ) );
227 	}
228 }
229 static void *
230 vips_foreign_load_nifti_set( const char *name, GValue *value, glong offset,
231 	void *a, void *b )
232 {
233 	nifti_image *nim = (nifti_image *) a;
234 	VipsImage *out = VIPS_IMAGE( b );
235 	char vips_name[256];
236 	vips_gvalue_read( value, (gpointer) nim + offset );
237 	vips_snprintf( vips_name, 256, "nifti-%s", name );
238 	vips_image_set( out, vips_name, value );
239 	return( NULL );
240 }
241 static int
242 vips_foreign_load_nifti_set_header( VipsForeignLoadNifti *nifti,
243 	nifti_image *nim, VipsImage *out )
244 {
245 	VipsObjectClass *class = VIPS_OBJECT_GET_CLASS( nifti );
246 	guint width;
247 	guint height;
248 	guint bands;
249 	VipsBandFormat fmt;
250 	double xres;
251 	double yres;
252 	int i;
253 	char txt[256];
254 	if( nim-&gt;ndim &lt; 1 ||
255 		nim-&gt;ndim &gt; 7 ) {
256 		vips_error( class-&gt;nickname, 
257 			_( "%d-dimensional images not supported" ), 
258 			nim-&gt;ndim ); 
259 		return( 0 );
260 	}
261 	for( i = 1; i &lt; 8 &amp;&amp; i &lt; nim-&gt;ndim + 1; i++ ) {
262 		if( nim-&gt;dim[i] &lt;= 0 ) {
263 			vips_error( class-&gt;nickname, 
264 				"%s", _( "invalid dimension" ) ); 
265 			return( 0 );
266 		}
267 		if( nim-&gt;dim[i] &gt; 1 &amp;&amp; 
268 			nim-&gt;pixdim[i] == 0 ) {
269 			vips_error( class-&gt;nickname, 
270 				"%s", _( "invalid resolution" ) ); 
271 			return( 0 );
272 		}
273 	}
274 	bands = 1;
275 	width = (guint) nim-&gt;nx;
276 	height = (guint) nim-&gt;ny;
277 	for( i = 3; i &lt; 8 &amp;&amp; i &lt; nim-&gt;ndim + 1; i++ )
278 		if( !g_uint_checked_mul( &amp;height, height, nim-&gt;dim[i] ) ) {
279 			vips_error( class-&gt;nickname, 
280 				"%s", _( "dimension overflow" ) ); 
281 			return( 0 );
282 		}
283 	if( height &gt; INT_MAX ) {
284 		vips_error( class-&gt;nickname, "%s", _( "dimension overflow" ) ); 
285 		return( 0 );
286 	}
287 	fmt = vips__foreign_nifti_datatype2BandFmt( nim-&gt;datatype );
288 	if( fmt == VIPS_FORMAT_NOTSET ) { 
289 		vips_error( class-&gt;nickname, 
290 			_( "datatype %d not supported" ), nim-&gt;datatype );
291 		return( -1 );
292 	}
293 	if( nim-&gt;datatype == DT_RGB )
294 		bands = 3;
295 	if( nim-&gt;datatype == DT_RGBA32 )
296 		bands = 4;
297 	xres = 1.0;
298 	yres = 1.0;
299 	if( nim-&gt;nz == 1 ||
300 		nim-&gt;dz == nim-&gt;dy ) 
301 		switch( nim-&gt;xyz_units ) {
302 		case NIFTI_UNITS_METER:
303 			xres = 1000.0 / nim-&gt;dx; 
304 			yres = 1000.0 / nim-&gt;dy; 
305 			break; 
306 		case NIFTI_UNITS_MM:
307 			xres = 1.0 / nim-&gt;dx; 
308 			yres = 1.0 / nim-&gt;dy; 
309 			break;
310 		case NIFTI_UNITS_MICRON:
311 			xres = 1.0 / (1000.0 * nim-&gt;dx); 
312 			yres = 1.0 / (1000.0 * nim-&gt;dy); 
313 			break;
314 		default:
315 			break;
316 		}
317 #ifdef DEBUG
318 	printf( "get_vips_properties: width = %d\n", width );
319 	printf( "get_vips_properties: height = %d\n", height );
320 	printf( "get_vips_properties: bands = %d\n", bands );
321 	printf( "get_vips_properties: fmt = %d\n", fmt );
322 	vips_image_pipelinev( out, VIPS_DEMAND_STYLE_SMALLTILE, NULL );
323 	vips_image_init_fields( out,
324 		width, height, bands, fmt, 
325 		VIPS_CODING_NONE, 
326 		bands == 1 ? 
327 			VIPS_INTERPRETATION_B_W : VIPS_INTERPRETATION_sRGB, 
328 		xres, yres );
329 	if( vips__foreign_nifti_map( vips_foreign_load_nifti_set, nim, out ) )
330 		return( -1 ); 
331 	vips_strncpy( txt, nim-&gt;intent_name, 17 );
332 	vips_image_set_string( out, "nifti-intent_name", txt );
333 	vips_strncpy( txt, nim-&gt;descrip, 81 );
334 	vips_image_set_string( out, "nifti-descrip", txt );
335 	for( i = 0; i &lt; nim-&gt;num_ext; i++ ) {
336 		nifti1_extension *ext = &amp;nim-&gt;ext_list[i];
337 		vips_snprintf( txt, 256, "nifti-ext-%d-%d", i, ext-&gt;ecode );
338 		vips_image_set_blob_copy( out, txt, ext-&gt;edata, ext-&gt;esize );
339 	}
340 	vips_image_set_int( out, VIPS_META_PAGE_HEIGHT, nim-&gt;ny );
341 	return( 0 );
342 }
343 static int
344 vips_foreign_load_nifti_header( VipsForeignLoad *load )
345 {
346 	VipsObjectClass *class = VIPS_OBJECT_GET_CLASS( load );
347 	VipsForeignLoadNifti *nifti = (VipsForeignLoadNifti *) load;
348 	if( !(nifti-&gt;nim = nifti_image_read( nifti-&gt;filename, FALSE )) ) { 
349 		vips_error( class-&gt;nickname, 
350 			"%s", _( "unable to read NIFTI header" ) );
351 		return( 0 );
352 	}
353 	if( vips_foreign_load_nifti_set_header( nifti, 
354 		nifti-&gt;nim, load-&gt;out ) ) {
355 		return( -1 );
356 	}
357 	VIPS_SETSTR( load-&gt;out-&gt;filename, nifti-&gt;filename );
358 	return( 0 );
359 }
360 static int
361 vips_foreign_load_nifti_load( VipsForeignLoad *load )
362 {
363 	VipsObjectClass *class = VIPS_OBJECT_GET_CLASS( load );
364 	VipsForeignLoadNifti *nifti = (VipsForeignLoadNifti *) load;
365 #ifdef DEBUG
366 	printf( "vips_foreign_load_nifti_load: loading image\n" );
367 	if( nifti_image_load( nifti-&gt;nim ) ) {
368 		vips_error( class-&gt;nickname, 
369 			"%s", _( "unable to load NIFTI file" ) );
370 		return( -1 );
371 	}
372 	if( !(nifti-&gt;memory = vips_image_new_from_memory( 
373 		nifti-&gt;nim-&gt;data, VIPS_IMAGE_SIZEOF_IMAGE( load-&gt;out ),
374 		load-&gt;out-&gt;Xsize, load-&gt;out-&gt;Ysize, 
375 <a name="0"></a>		load-&gt;out-&gt;Bands, load-&gt;out-&gt;BandFmt )) ) 
376 		return( -1 );
377 <font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>	if( vips_image_write( nifti-&gt;memory, load-&gt;real ) )
378 		return( -1 );
379 	return( 0 );
380 }
381 static void
382 vips_foreign_load_nifti_class_init( VipsForeignLoadNiftiClass *class )
383 {
384 	GObjectClass *gobject_class = G_OBJECT_CLASS( class );
385 	VipsObjectClass *object_class = (VipsObjectClass *) class;
386 	VipsForeignClass *foreign_class = (VipsForeignClass *) class;</b></font>
387 	VipsForeignLoadClass *load_class = (VipsForeignLoadClass *) class;
388 	gobject_class-&gt;dispose = vips_foreign_load_nifti_dispose;
389 	gobject_class-&gt;set_property = vips_object_set_property;
390 	gobject_class-&gt;get_property = vips_object_get_property;
391 	object_class-&gt;nickname = "niftiload_base";
392 	object_class-&gt;description = _( "load a NIFTI image" );
393 	object_class-&gt;build = vips_foreign_load_nifti_build;
394 	foreign_class-&gt;priority = -50;
395 	load_class-&gt;header = vips_foreign_load_nifti_header;
396 	load_class-&gt;load = vips_foreign_load_nifti_load;
397 }
398 static void
399 vips_foreign_load_nifti_init( VipsForeignLoadNifti *nifti )
400 {
401 }
402 typedef struct _VipsForeignLoadNiftiFile {
403 	VipsForeignLoadNifti parent_object;
404 	char *filename; 
405 } VipsForeignLoadNiftiFile;
406 typedef VipsForeignLoadNiftiClass VipsForeignLoadNiftiFileClass;
407 G_DEFINE_TYPE( VipsForeignLoadNiftiFile, vips_foreign_load_nifti_file, 
408 	vips_foreign_load_nifti_get_type() );
409 static int
410 vips_foreign_load_nifti_file_build( VipsObject *object )
411 {
412 	VipsForeignLoadNifti *nifti = (VipsForeignLoadNifti *) object;
413 	VipsForeignLoadNiftiFile *file = (VipsForeignLoadNiftiFile *) object;
414 	if( file-&gt;filename &amp;&amp;
415 		!(nifti-&gt;source = 
416 			vips_source_new_from_file( file-&gt;filename )) )
417 		return( -1 );
418 	if( VIPS_OBJECT_CLASS( vips_foreign_load_nifti_file_parent_class )-&gt;
419 		build( object ) )
420 		return( -1 );
421 	return( 0 );
422 }
423 const char *vips_foreign_nifti_suffs[] = { 
424 	".nii", ".nii.gz", 
425 	".hdr", ".hdr.gz", 
426 	".img", ".img.gz", 
427 	".nia", ".nia.gz", 
428 	NULL 
429 };
430 static int
431 vips_foreign_load_nifti_is_a( const char *filename )
432 {
433 	char *hfile;
434 	znzFile fp;
435 	nifti_1_header nhdr;
436 	if( !(hfile = nifti_findhdrname( filename )) )
437 		return( 0 );
438 	fp = znzopen( hfile, "rb", nifti_is_gzfile( hfile ));
439 	if( znz_isnull( fp ) ) { 
440 		free( hfile );
441 		return( 0 );
442 	}
443 	free( hfile );
444 	(void) znzread( &amp;nhdr, 1, sizeof( nhdr ), fp );
445 	znzclose( fp );
446 	if( nifti_hdr_looks_good( &amp;nhdr ) ) 
447 		return( 1 );
448 	swap_nifti_header( &amp;nhdr, FALSE );
449 	if( nifti_hdr_looks_good( &amp;nhdr ) ) 
450 		return( 1 );
451 	return( 0 );
452 }
453 static void
454 vips_foreign_load_nifti_file_class_init( 
455 	VipsForeignLoadNiftiFileClass *class )
456 {
457 	GObjectClass *gobject_class = G_OBJECT_CLASS( class );
458 	VipsObjectClass *object_class = (VipsObjectClass *) class;
459 	VipsForeignClass *foreign_class = (VipsForeignClass *) class;
460 	VipsForeignLoadClass *load_class = (VipsForeignLoadClass *) class;
461 	gobject_class-&gt;set_property = vips_object_set_property;
462 	gobject_class-&gt;get_property = vips_object_get_property;
463 	object_class-&gt;nickname = "niftiload";
464 	object_class-&gt;description = _( "load NIfTI volume" );
465 	object_class-&gt;build = vips_foreign_load_nifti_file_build;
466 	foreign_class-&gt;suffs = vips_foreign_nifti_suffs;
467 	load_class-&gt;is_a = vips_foreign_load_nifti_is_a;
468 	VIPS_ARG_STRING( class, "filename", 1, 
469 		_( "Filename" ),
470 		_( "Filename to load from" ),
471 		VIPS_ARGUMENT_REQUIRED_INPUT, 
472 		G_STRUCT_OFFSET( VipsForeignLoadNiftiFile, filename ),
473 		NULL );
474 }
475 static void
476 vips_foreign_load_nifti_file_init( VipsForeignLoadNiftiFile *nifti )
477 {
478 }
479 typedef struct _VipsForeignLoadNiftiSource {
480 	VipsForeignLoadNifti parent_object;
481 	VipsSource *source;
482 } VipsForeignLoadNiftiSource;
483 typedef VipsForeignLoadNiftiClass VipsForeignLoadNiftiSourceClass;
484 G_DEFINE_TYPE( VipsForeignLoadNiftiSource, vips_foreign_load_nifti_source, 
485 	vips_foreign_load_nifti_get_type() );
486 static int
487 vips_foreign_load_nifti_source_build( VipsObject *object )
488 {
489 	VipsForeignLoadNifti *nifti = (VipsForeignLoadNifti *) object;
490 	VipsForeignLoadNiftiSource *source = 
491 		(VipsForeignLoadNiftiSource *) object;
492 	if( source-&gt;source ) {
493 		nifti-&gt;source = source-&gt;source;
494 		g_object_ref( nifti-&gt;source );
495 	}
496 	if( VIPS_OBJECT_CLASS( 
497 		vips_foreign_load_nifti_source_parent_class )-&gt;
498 			build( object ) )
499 		return( -1 );
500 	return( 0 );
501 }
502 static gboolean
503 vips_foreign_load_nifti_source_is_a_source( VipsSource *source )
504 {
505 	const char *filename;
506 	return( (filename = 
507 		vips_connection_filename( VIPS_CONNECTION( source ) )) &amp;&amp;
508 		vips_foreign_load_nifti_is_a( filename ) );
509 }
510 static void
511 vips_foreign_load_nifti_source_class_init( 
512 	VipsForeignLoadNiftiSourceClass *class )
513 {
514 	GObjectClass *gobject_class = G_OBJECT_CLASS( class );
515 	VipsObjectClass *object_class = (VipsObjectClass *) class;
516 	VipsForeignLoadClass *load_class = (VipsForeignLoadClass *) class;
517 	gobject_class-&gt;set_property = vips_object_set_property;
518 	gobject_class-&gt;get_property = vips_object_get_property;
519 	object_class-&gt;nickname = "niftiload_source";
520 	object_class-&gt;description = _( "load NIfTI volumes" );
521 	object_class-&gt;build = vips_foreign_load_nifti_source_build;
522 	load_class-&gt;is_a_source = 
523 		vips_foreign_load_nifti_source_is_a_source;
524 	VIPS_ARG_OBJECT( class, "source", 1,
525 		_( "Source" ),
526 		_( "Source to load from" ),
527 		VIPS_ARGUMENT_REQUIRED_INPUT, 
528 		G_STRUCT_OFFSET( VipsForeignLoadNiftiSource, source ),
529 		VIPS_TYPE_SOURCE );
530 }
531 static void
532 vips_foreign_load_nifti_source_init( 
533 	VipsForeignLoadNiftiSource *nifti )
534 {
535 }
536 int
537 vips_niftiload( const char *filename, VipsImage **out, ... )
538 {
539 	va_list ap;
540 	int result;
541 	va_start( ap, out );
542 	result = vips_call_split( "niftiload", ap, filename, out );
543 	va_end( ap );
544 	return( result );
545 }
546 int
547 vips_niftiload_source( VipsSource *source, VipsImage **out, ... )
548 {
549 	va_list ap;
550 	int result;
551 	va_start( ap, out );
552 	result = vips_call_split( "niftiload_source", ap, source, out );
553 	va_end( ap );
554 	return( result );
555 }
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
