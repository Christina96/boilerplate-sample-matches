<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for util.c &amp; image.c</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for util.c &amp; image.c
      </h3>
<h1 align="center">
        1.9%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>util.c (2.0953758%)<th>image.c (1.8091079%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(838-853)<td><a href="#" name="0">(2556-2576)</a><td align="center"><font color="#ff0000">16</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(1475-1508)<td><a href="#" name="1">(1721-1732)</a><td align="center"><font color="#cf0000">13</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>util.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 #ifdef HAVE_CONFIG_H
2 #include &lt;config.h&gt;
3 #include &lt;vips/intl.h&gt;
4 #include &lt;stdio.h&gt;
5 #include &lt;stdlib.h&gt;
6 #include &lt;string.h&gt;
7 #include &lt;ctype.h&gt;
8 #include &lt;errno.h&gt;
9 #include &lt;sys/types.h&gt;
10 #include &lt;sys/stat.h&gt;
11 #ifdef HAVE_UNISTD_H
12 #include &lt;unistd.h&gt;
13 #ifdef HAVE_IO_H
14 #include &lt;io.h&gt;
15 #include &lt;fcntl.h&gt;
16 #include &lt;vips/vips.h&gt;
17 #include &lt;vips/debug.h&gt;
18 #include &lt;vips/internal.h&gt;
19 #ifdef G_OS_WIN32
20 #include &lt;windows.h&gt;
21 #define MAX_BUF (100000)
22 #if defined(G_PLATFORM_WIN32) || defined(G_WITH_CYGWIN)
23 #ifndef O_BINARY
24 #ifdef _O_BINARY
25 #define O_BINARY _O_BINARY
26 #ifdef O_BINARY
27 #define BINARYIZE(M) ((M) | O_BINARY)
28 #define BINARYIZE(M) (M)
29 #define MODE_WRITE BINARYIZE (O_WRONLY | O_CREAT | O_TRUNC)
30 #define MODE_READWRITE BINARYIZE (O_RDWR)
31 #define MODE_READONLY BINARYIZE (O_RDONLY)
32 gboolean
33 vips_slist_equal( GSList *l1, GSList *l2 )
34 {
35 	while( l1 &amp;&amp; l2 ) {
36 		if( l1-&gt;data != l2-&gt;data )
37 			return( FALSE );
38 		l1 = l1-&gt;next;
39 		l2 = l2-&gt;next;
40 	}
41 	if( l1 || l2 )
42 		return( FALSE );
43 	return( TRUE );
44 }
45 void *
46 vips_slist_map2( GSList *list, VipsSListMap2Fn fn, void *a, void *b )
47 {
48 	GSList *copy;
49 	GSList *i;
50 	void *result;
51 	copy = g_slist_copy( list );
52 	result = NULL;
53 	for( i = copy; i &amp;&amp; !(result = fn( i-&gt;data, a, b )); i = i-&gt;next ) 
54 		;
55 	g_slist_free( copy );
56 	return( result );
57 }
58 void *
59 vips_slist_map2_rev( GSList *list, VipsSListMap2Fn fn, void *a, void *b )
60 {
61 	GSList *copy;
62 	GSList *i;
63 	void *result;
64 	copy = g_slist_copy( list );
65 	copy = g_slist_reverse( copy );
66 	result = NULL;
67 	for( i = copy; i &amp;&amp; !(result = fn( i-&gt;data, a, b )); i = i-&gt;next ) 
68 		;
69 	g_slist_free( copy );
70 	return( result );
71 }
72 void *
73 vips_slist_map4( GSList *list, 
74 	VipsSListMap4Fn fn, void *a, void *b, void *c, void *d )
75 {
76 	GSList *copy;
77 	GSList *i;
78 	void *result;
79 	copy = g_slist_copy( list );
80 	result = NULL;
81 	for( i = copy; 
82 		i &amp;&amp; !(result = fn( i-&gt;data, a, b, c, d )); i = i-&gt;next ) 
83 		;
84 	g_slist_free( copy );
85 	return( result );
86 }
87 void *
88 vips_slist_fold2( GSList *list, void *start, 
89 	VipsSListFold2Fn fn, void *a, void *b )
90 {
91         void *c;
92         GSList *this, *next;
93         for( c = start, this = list; this; this = next ) {
94                 next = this-&gt;next;
95                 if( !(c = fn( this-&gt;data, c, a, b )) )
96 			return( NULL );
97         }
98         return( c );
99 }
100 GSList *
101 vips_slist_filter( GSList *list, VipsSListMap2Fn fn, void *a, void *b )
102 {
103 	GSList *tmp;
104 	GSList *prev;
105 	prev = NULL;
106 	tmp = list;
107 	while( tmp ) {
108 		if( fn( tmp-&gt;data, a, b ) ) {
109 			GSList *next = tmp-&gt;next;
110 			if( prev )
111 				prev-&gt;next = next;
112 			if( list == tmp )
113 				list = next;
114 			tmp-&gt;next = NULL;
115 			g_slist_free( tmp );
116 			tmp = next;
117 		}
118 		else {
119 			prev = tmp;
120 			tmp = tmp-&gt;next;
121 		}
122 	}
123 	return( list );
124 }
125 static void
126 vips_slist_free_all_cb( void * thing, void * dummy )
127 {
128 	g_free( thing );
129 }
130 void
131 vips_slist_free_all( GSList *list )
132 {
133 	g_slist_foreach( list, vips_slist_free_all_cb, NULL );
134 	g_slist_free( list );
135 }
136 void *
137 vips_map_equal( void *a, void *b )
138 {
139 	if( a == b )
140 		return( a );
141 	return( NULL );
142 }
143 typedef struct {
144 	void *a;
145 	void *b;
146 	VipsSListMap2Fn fn;
147 	void *result;
148 } Pair;
149 static gboolean
150 vips_hash_table_predicate( const char *key, void *value, Pair *pair )
151 {
152 	return( (pair-&gt;result = pair-&gt;fn( value, pair-&gt;a, pair-&gt;b )) != NULL );
153 }
154 void *
155 vips_hash_table_map( GHashTable *hash, VipsSListMap2Fn fn, void *a, void *b )
156 {
157 	Pair pair;
158 	pair.a = a;
159 	pair.b = b;
160 	pair.fn = fn;
161 	pair.result = NULL;
162 	g_hash_table_find( hash, (GHRFunc) vips_hash_table_predicate, &amp;pair ); 
163 	return( pair.result );
164 }
165 char *
166 vips_strncpy( char *dest, const char *src, int n )
167 {
168         int i;
169         g_assert( n &gt; 0 );
170         for( i = 0; i &lt; n - 1; i++ )
171                 if( !(dest[i] = src[i]) )
172                         break;
173         dest[i] = '\0';
174         return( dest );
175 }
176 char *
177 vips_strrstr( const char *haystack, const char *needle )
178 {
179 	int haystack_len = strlen( haystack );
180 	int needle_len = strlen( needle );
181 	int i;
182 	for( i = haystack_len - needle_len; i &gt;= 0; i-- )
183 		if( strncmp( needle, haystack + i, needle_len ) == 0 )
184 			return( (char *) haystack + i );
185 	return( NULL );
186 }
187 gboolean
188 vips_ispostfix( const char *a, const char *b )
189 {	
190 	int m = strlen( a );
191 	int n = strlen( b );
192 	if( n &gt; m )
193 		return( FALSE );
194 	return( strcmp( a + m - n, b ) == 0 );
195 }
196 gboolean
197 vips_iscasepostfix( const char *a, const char *b )
198 {	
199 	int m = strlen( a );
200 	int n = strlen( b );
201 	if( n &gt; m )
202 		return( FALSE );
203 	return( g_ascii_strcasecmp( a + m - n, b ) == 0 );
204 }
205 gboolean
206 vips_isprefix( const char *a, const char *b )
207 {
208 	int i;
209 	for( i = 0; a[i] &amp;&amp; b[i]; i++ )
210 		if( a[i] != b[i] )
211 			return( FALSE );
212 	if( a[i] &amp;&amp; !b[i] )
213 		return( FALSE );
214 	return( TRUE );
215 }
216 static size_t
217 strcspne( const char *s, const char *reject )
218 {
219 	size_t skip;
220 	if( strchr( reject, '\\' ) )
221 		return( strcspn( s, reject ) );
222 	skip = 0;
223 	for(;;) { 
224 		skip += strcspn( s + skip, reject );
225 		if( skip == 0 ||
226 			!s[skip] ||
227 			s[skip - 1] != '\\' )
228 			break;
229 		skip += 1;
230 	}
231 	return( skip );
232 }
233 char *
234 vips_break_token( char *str, const char *brk )
235 {
236         char *p;
237         char *q;
238         if( !str || 
239 		!*str )
240                 return( NULL );
241         p = str + strspn( str, brk );
242         if( !*p ) 
243 		return( NULL );
244         p += strcspne( p, brk );
245         if( *p ) {
246                 *p++ = '\0';
247                 p += strspn( p, brk );
248         }
249 	for( q = strchr( str, '\\' ); q &amp;&amp; *q; q = strchr( q, '\\' ) ) {
250 		memmove( q, q + 1, strlen( q ) );
251 		q += 1;
252 	}
253         return( p );
254 }
255 int
256 vips_vsnprintf( char *str, size_t size, const char *format, va_list ap )
257 {
258 #ifdef HAVE_VSNPRINTF
259 	return( vsnprintf( str, size, format, ap ) );
260 	int n;
261 	static char buf[MAX_BUF];
262 	if( size &gt; MAX_BUF )
263 		vips_error_exit( "panic: buffer overflow "
264 			"(request to write %lu bytes to buffer of %d bytes)",
265 			(unsigned long) size, MAX_BUF );
266 	n = vsprintf( buf, format, ap );
267 	if( n &gt; MAX_BUF )
268 		vips_error_exit( "panic: buffer overflow "
269 			"(%d bytes written to buffer of %d bytes)",
270 			n, MAX_BUF );
271 	vips_strncpy( str, buf, size );
272 	return( n );
273 }
274 int
275 vips_snprintf( char *str, size_t size, const char *format, ... )
276 {
277 	va_list ap;
278 	int n;
279 	va_start( ap, format );
280 	n = vips_vsnprintf( str, size, format, ap );
281 	va_end( ap );
282 	return( n );
283 }
284 int
285 vips_filename_suffix_match( const char *path, const char *suffixes[] )
286 {
287 	char *basename;
288 	char *q;
289 	int result;
290 	const char **p;
291 	basename = g_path_get_basename( path );
292 	if( (q = (char *) vips__find_rightmost_brackets( basename )) ) 
293 		*q = '\0';
294 	result = 0;
295 	for( p = suffixes; *p; p++ ) 
296 		if( vips_iscasepostfix( basename, *p ) ) {
297 			result = 1;
298 			break;
299 		}
300 	g_free( basename );
301 	return( result );
302 }
303 gint64
304 vips_file_length( int fd )
305 {
306 #ifdef G_OS_WIN32
307 	struct _stati64 st;
308 	if( _fstati64( fd, &amp;st ) == -1 ) {
309 	struct stat st;
310 	if( fstat( fd, &amp;st ) == -1 ) {
311 		vips_error_system( errno, "vips_file_length", 
312 			"%s", _( "unable to get file stats" ) );
313 		return( -1 );
314 	}
315 	return( st.st_size );
316 }
317 int
318 vips__write( int fd, const void *buf, size_t count )
319 {
320 	do {
321 		size_t nwritten = write( fd, buf, count );
322 		if( nwritten == (size_t) -1 ) {
323                         vips_error_system( errno, "vips__write", 
324 				"%s", _( "write failed" ) );
325                         return( -1 ); 
326 		}
327 		buf = (void *) ((char *) buf + nwritten);
328 		count -= nwritten;
329 	} while( count &gt; 0 );
330 	return( 0 );
331 }
332 #ifdef G_OS_WIN32
333 void
334 vips__set_create_time( int fd )
335 {
336 	HANDLE handle;
337 	SYSTEMTIME st;
338 	FILETIME ft;
339 	if( (handle = (HANDLE) _get_osfhandle( fd )) == INVALID_HANDLE_VALUE )
340 		return;
341 	GetSystemTime( &amp;st );
342 	SystemTimeToFileTime( &amp;st, &amp;ft );
343 	SetFileTime( handle, &amp;ft, &amp;ft, &amp;ft );
344 }
345 int
346 vips__open( const char *filename, int flags, int mode )
347 {
348 	int fd;
349 	if( g_file_test( filename, G_FILE_TEST_IS_DIR ) ) {
350 		errno = EISDIR;
351 		return( -1 );
352 	}
353 	fd = g_open( filename, flags, mode );
354 #ifdef G_OS_WIN32
355 	if( mode &amp; O_CREAT )
356 		vips__set_create_time( fd ); 
357 	return( fd );
358 }
359 int 
360 vips__open_read( const char *filename )
361 {
362 	return( vips__open( filename, MODE_READONLY, 0 ) );
363 }
364 FILE *
365 vips__fopen( const char *filename, const char *mode )
366 {
367 	FILE *fp;
368 	fp = g_fopen( filename, mode );
369 #ifdef G_OS_WIN32
370 	if( mode[0] == 'w' )
371 		vips__set_create_time( _fileno( fp ) ); 
372 	return( fp );
373 }
374 static gboolean 
375 filename_hasdir( const char *filename )
376 {
377 	char *dirname;
378 	gboolean hasdir;
379 	dirname = g_path_get_dirname( filename );
380 	hasdir = (strcmp( dirname, "." ) != 0);
381 	g_free( dirname );
382 	return( hasdir );
383 }
384 FILE *
385 vips__file_open_read( const char *filename, const char *fallback_dir, 
386 	gboolean text_mode )
387 {
388 	char *mode;
389 	FILE *fp;
390 #if defined(G_PLATFORM_WIN32) || defined(G_WITH_CYGWIN)
391 	if( text_mode )
392 		mode = "r";
393 	else
394 		mode = "rb";
395 	mode = "r";
396 	if( (fp = vips__fopen( filename, mode )) )
397 		return( fp );
398 	if( fallback_dir &amp;&amp; 
399 		!filename_hasdir( filename ) ) {
400 		char *path;
401 		path = g_build_filename( fallback_dir, filename, NULL );
402 	        fp = vips__fopen( path, mode );
403 		g_free( path );
404 		if( fp )
405 			return( fp );
406 	}
407 	vips_error_system( errno, "vips__file_open_read", 
408 		_( "unable to open file \"%s\" for reading" ), filename );
409 	return( NULL );
410 }
411 FILE *
412 vips__file_open_write( const char *filename, gboolean text_mode )
413 {
414 	char *mode;
415 	FILE *fp;
416 #if defined(G_PLATFORM_WIN32) || defined(G_WITH_CYGWIN)
417 	if( text_mode )
418 		mode = "w";
419 	else
420 		mode = "wb";
421 	mode = "w";
422         if( !(fp = vips__fopen( filename, mode )) ) {
423 		vips_error_system( errno, "vips__file_open_write", 
424 			_( "unable to open file \"%s\" for writing" ), 
425 			filename );
426 		return( NULL );
427 	}
428 	return( fp );
429 }
430 char *
431 vips__file_read( FILE *fp, const char *filename, size_t *length_out )
432 {
433         gint64 len;
434 	size_t read;
435         char *str;
436 	len = vips_file_length( fileno( fp ) ); 
437 	if( len &gt; 1024 * 1024 * 1024 ) {
438                 vips_error( "vips__file_read", 
439 			_( "\"%s\" too long" ), filename );
440                 return( NULL );
441         }
442 	if( len == -1 ) {
443 		int size;
444 		str = NULL;
445 		len = 0;
446 		size = 0;
447 		do {
448 			char *str2;
449 			size += 1024;
450 			if( size &gt; 1024 * 1024 * 1024 ||
451 				!(str2 = realloc( str, size )) ) {
452 				free( str ); 
453 				vips_error( "vips__file_read", 
454 					"%s", _( "out of memory" ) );
455 				return( NULL );
456 			}
457 			str = str2;
458 			read = fread( str + len, sizeof( char ), 
459 				(size - len - 1) / sizeof( char ),
460 				fp );
461 			len += read;
462 		} while( !feof( fp ) );
463 #ifdef DEBUG
464 		printf( "read %ld bytes from unseekable stream\n", len );
465 	}
466 	else {
467 		if( !(str = vips_malloc( NULL, len + 1 )) )
468 			return( NULL );
469 		rewind( fp );
470 		read = fread( str, sizeof( char ), (size_t) len, fp );
471 		if( read != (size_t) len ) {
472 			g_free( str );
473 			vips_error( "vips__file_read", 
474 				_( "error reading from file \"%s\"" ), 
475 				filename );
476 			return( NULL );
477 		}
478 	}
479 	str[len] = '\0';
480 	if( length_out )
481 		*length_out = len;
482         return( str );
483 }
484 char *
485 <font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>vips__file_read_name( const char *filename, const char *fallback_dir, 
486 	size_t *length_out )
487 {
488 	FILE *fp;
489 	char *buffer;
490         if( !(fp = vips__file_open_read( filename, fallback_dir, FALSE )) ) 
491 		return( NULL );
492 	if( !(buffer = vips__file_read( fp, filename, length_out )) ) {
493 		fclose( fp );
494 		return( NULL );
495 	}
496 	fclose( fp );
497 	return( buffer );
498 }</b></font>
499 int
500 vips__file_write( void *data, size_t size, size_t nmemb, FILE *stream )
501 {
502 	size_t n;
503 	if( !data ) 
504 		return( 0 );
505 	if( (n = fwrite( data, size, nmemb, stream )) != nmemb ) {
506 		vips_error_system( errno, "vips__file_write", 
507 			_( "write error (%zd out of %zd blocks written)" ),
508 			n, nmemb );
509 		return( -1 );
510 	}
511 	return( 0 );
512 }
513 gint64
514 vips__get_bytes( const char *filename, unsigned char buf[], gint64 len )
515 {
516 	int fd;
517 	gint64 bytes_read;
518 	if( (fd = vips__open_read( filename )) == -1 )
519 		return( 0 );
520 	bytes_read = read( fd, buf, len );
521 	close( fd );
522 	return( bytes_read );
523 }
524 int
525 vips__fgetc( FILE *fp )
526 {
527 	int ch;
528 	ch = fgetc( fp );
529 	if( ch == '\r' ) {
530 		ch = fgetc( fp );
531 		if( ch != '\n' ) {
532 			ungetc( ch, fp );
533 			ch = '\r';
534 		}
535 	}
536 	return( ch ); 
537 }
538 static GValue *
539 vips__gvalue_new( GType type )
540 {
541 	GValue *value;
542 	value = g_new0( GValue, 1 );
543 	g_value_init( value, type );
544 	return( value );
545 }
546 static GValue *
547 vips__gvalue_copy( GValue *value )
548 {
549 	GValue *value_copy;
550 	value_copy = vips__gvalue_new( G_VALUE_TYPE( value ) );
551 	g_value_copy( value, value_copy );
552 	return( value_copy );
553 }
554 static void
555 vips__gvalue_free( GValue *value, void *user_data )
556 {
557 	g_value_unset( value );
558 	g_free( value );
559 }
560 GValue *
561 vips__gvalue_ref_string_new( const char *text )
562 {
563 	GValue *value;
564 	value = vips__gvalue_new( VIPS_TYPE_REF_STRING );
565 	vips_value_set_ref_string( value, text );
566 	return( value );
567 }
568 void
569 vips__gslist_gvalue_free( GSList *list )
570 {
571 	g_slist_foreach( list, (GFunc) vips__gvalue_free, NULL );
572 	g_slist_free( list );
573 }
574 GSList *
575 vips__gslist_gvalue_copy( const GSList *list )
576 {
577 	GSList *copy;
578 	const GSList *p;
579 	copy = NULL;
580 	for( p = list; p; p = p-&gt;next ) 
581 		copy = g_slist_prepend( copy, 
582 			vips__gvalue_copy( (GValue *) p-&gt;data ) );
583 	copy = g_slist_reverse( copy );
584 	return( copy );
585 }
586 GSList *
587 vips__gslist_gvalue_merge( GSList *a, const GSList *b )
588 {
589 	const GSList *i, *j;
590 	GSList *tail;
591 	tail = NULL;
592 	for( i = b; i; i = i-&gt;next ) {
593 		GValue *value = (GValue *) i-&gt;data;
594 		g_assert( G_VALUE_TYPE( value ) == VIPS_TYPE_REF_STRING );
595 		for( j = a; j; j = j-&gt;next ) {
596 			GValue *value2 = (GValue *) j-&gt;data;
597 			g_assert( G_VALUE_TYPE( value2 ) == 
598 				VIPS_TYPE_REF_STRING );
599 			if( vips_value_get_ref_string( value, NULL ) ==
600 				vips_value_get_ref_string( value2, NULL ) )
601 				break;
602 		}
603 		if( !j )
604 			tail = g_slist_prepend( tail, 
605 				vips__gvalue_copy( value ) );
606 	}
607 	a = g_slist_concat( a, g_slist_reverse( tail ) );
608 	return( a );
609 }
610 char *
611 vips__gslist_gvalue_get( const GSList *list )
612 {
613 	const GSList *p;
614 	size_t length;
615 	char *all;
616 	char *q;
617 	length = 0;
618 	for( p = list; p; p = p-&gt;next ) {
619 		GValue *value = (GValue *) p-&gt;data;
620 		size_t l2;
621 		g_assert( G_VALUE_TYPE( value ) == VIPS_TYPE_REF_STRING );
622 		(void) vips_value_get_ref_string( value, &amp;l2 );
623 		length += l2 + 1;
624 	}
625 	if( length == 0 )
626 		return( NULL );
627 	g_assert( length &lt; 10 * 1024 * 1024 );
628 	if( !(all = vips_malloc( NULL, length + 1 )) )
629 		return( NULL );
630 	q = all;
631 	for( p = list; p; p = p-&gt;next ) {
632 		GValue *value = (GValue *) p-&gt;data;
633 		size_t l2;
634 		strcpy( q, vips_value_get_ref_string( value, &amp;l2 ) );
635 		q += l2;
636 		strcpy( q, "\n" );
637 		q += 1;
638 	}
639 	g_assert( (size_t) (q - all) == length );
640 	return( all );
641 }
642 gint64
643 vips__seek_no_error( int fd, gint64 pos, int whence )
644 {
645 	gint64 new_pos;
646 #ifdef G_OS_WIN32
647 	new_pos = _lseeki64( fd, pos, whence );
648 	new_pos = lseek( fd, pos, whence );
649 	return( new_pos );
650 }
651 gint64
652 vips__seek( int fd, gint64 pos, int whence )
653 {
654 	gint64 new_pos;
655 	if( (new_pos = vips__seek_no_error( fd, pos, whence )) == -1 ) {
656 		vips_error_system( errno, "vips__seek", 
657 			"%s", _( "unable to seek" ) );
658 		return( -1 );
659 	}
660 	return( new_pos );
661 }
662 int
663 vips__ftruncate( int fd, gint64 pos )
664 {
665 #ifdef G_OS_WIN32
666 {
667 	HANDLE hFile = (HANDLE) _get_osfhandle( fd );
668 	if( vips__seek( fd, pos, SEEK_SET ) == -1 )
669 		return( -1 );
670 	if( !SetEndOfFile( hFile ) ) {
671                 vips_error_system( GetLastError(), "vips__ftruncate", 
672 			"%s", _( "unable to truncate" ) );
673 		return( -1 );
674 	}
675 }
676 	if( ftruncate( fd, pos ) ) {
677 		vips_error_system( errno, "vips__ftruncate", 
678 			"%s", _( "unable to truncate" ) );
679 		return( -1 );
680 	}
681 	return( 0 );
682 }
683 gboolean
684 vips_existsf( const char *name, ... )
685 {
686         va_list ap;
687 	char *path; 
688         gboolean result; 
689         va_start( ap, name );
690 	path = g_strdup_vprintf( name, ap ); 
691         va_end( ap );
692 	result = g_file_test( path, G_FILE_TEST_EXISTS );
693 	g_free( path ); 
694 	return( result ); 
695 }
696 gboolean
697 vips_isdirf( const char *name, ... )
698 {
699         va_list ap;
700 	char *path; 
701         gboolean result; 
702         va_start( ap, name );
703 	path = g_strdup_vprintf( name, ap ); 
704         va_end( ap );
705 	result = g_file_test( path, G_FILE_TEST_IS_DIR );
706 	g_free( path ); 
707 	return( result ); 
708 }
709 int
710 vips_mkdirf( const char *name, ... )
711 {
712         va_list ap;
713 	char *path; 
714         va_start( ap, name );
715 	path = g_strdup_vprintf( name, ap ); 
716         va_end( ap );
717 	if( g_mkdir( path, 0755 ) ) { 
718 		vips_error( "mkdirf", 
719 			_( "unable to create directory \"%s\", %s" ), 
720 			path, strerror( errno ) );
721 		g_free( path ); 
722                 return( -1 );
723 	}
724 	g_free( path ); 
725         return( 0 );
726 }
727 int
728 vips_rmdirf( const char *name, ... )
729 {
730         va_list ap;
731 	char *path; 
732         va_start( ap, name );
733 	path = g_strdup_vprintf( name, ap ); 
734         va_end( ap );
735 	if( g_rmdir( path ) ) { 
736 		vips_error( "rmdir", 
737 			_( "unable to remove directory \"%s\", %s" ), 
738 			path, strerror( errno ) );
739 		g_free( path ); 
740                 return( -1 );
741 	}
742 	g_free( path ); 
743         return( 0 );
744 }
745 int
746 vips_rename( const char *old_name, const char *new_name )
747 {
748 	if( g_rename( old_name, new_name ) ) { 
749 		vips_error( "rename", 
750 			_( "unable to rename file \"%s\" as \"%s\", %s" ), 
751 			old_name, new_name, strerror( errno ) );
752                 return( -1 );
753 	}
754         return( 0 );
755 }
756 void
757 vips__chomp( char *str )
758 {
759 	char *p;
760 	for( p = str + strlen( str ); p &gt; str &amp;&amp; isspace( p[-1] ); p-- )
761 		p[-1] = '\0';
762 }
763 const char *
764 vips__token_get( const char *p, VipsToken *token, char *string, int size )
765 {
766 	const char *q;
767 	int ch;
768 	int n;
769 	int i;
770 	if( !p )
771 		return( NULL );
772         p += strspn( p, " \t\n\r" );
773 	if( !p[0] )
774 		return( NULL );
775 	switch( (ch = p[0]) ) {
776 	case '[':
777 		*token = VIPS_TOKEN_LEFT;
778 		p += 1;
779 		break;
780 	case ']':
781 		*token = VIPS_TOKEN_RIGHT;
782 		p += 1;
783 		break;
784 	case '=':
785 		*token = VIPS_TOKEN_EQUALS;
786 		p += 1;
787 		break;
788 	case ',':
789 		*token = VIPS_TOKEN_COMMA;
790 		p += 1;
791 		break;
792 	case '"':
793 	case '\'':
794 		*token = VIPS_TOKEN_STRING;
795 		do {
796 			if( (q = strchr( p + 1, ch )) )
797 				n = q - p + 1;
798 			else
799 				n = strlen( p + 1 );
800 			i = VIPS_MIN( n, size );
801 			vips_strncpy( string, p + 1, i );
802 			if( p[n + 1] == ch &amp;&amp; p[n] == '\\' &amp;&amp; i == n )
803 				string[i - 1] = ch;
804 			string += i;
805 			size -= i;
806 			p += n + 1;
807 		} while( p[0] &amp;&amp; p[-1] == '\\' );
808 		p += 1;
809 		break;
810 	default:
811 		*token = VIPS_TOKEN_STRING;
812 		q = p + strcspn( p, "[]=," );
813 		i = VIPS_MIN( q - p, size );
814 		vips_strncpy( string, p, i + 1 );
815 		p = q;
816 		if( i != size ) 
817 			while( i &gt; 0 &amp;&amp; isspace( string[i - 1] ) ) {
818 				string[i - 1] = '\0';
819 				i--;
820 			}
821 		break;
822 	}
823 	return( p );
824 }
825 const char *
826 vips__token_must( const char *p, VipsToken *token, 
827 	char *string, int size )
828 {
829 	if( !(p = vips__token_get( p, token, string, size )) ) {
830 		vips_error( "get_token", 
831 			"%s", _( "unexpected end of string" ) );
832 		return( NULL );
833 	}
834 	return( p );
835 }
836 const char *
837 vips__token_need( const char *p, VipsToken need_token, 
838 	char *string, int size )
839 {
840 	VipsToken token;
841 	if( !(p = vips__token_must( p, &amp;token, string, size )) ) 
842 		return( NULL );
843 	if( token != need_token ) {
844 		vips_error( "get_token", _( "expected %s, saw %s" ), 
845 			vips_enum_nick( VIPS_TYPE_TOKEN, need_token ),
846 			vips_enum_nick( VIPS_TYPE_TOKEN, token ) );
847 		return( NULL );
848 	}
849 	return( p );
850 }
851 const char *
852 vips__token_segment( const char *p, VipsToken *token, 
853 	char *string, int size )
854 {
855 	const char *q;
856 	if( !(q = vips__token_must( p, token, string, size )) )
857 		return( NULL ); 
858 	if( *token == VIPS_TOKEN_STRING &amp;&amp;
859 		q[0] == '[' ) {
860 		VipsToken sub_token;
861 		char sub_string[VIPS_PATH_MAX];
862 		int depth;
863 		int i; 
864 		depth = 0;
865 		do {
866 			if( !(q = vips__token_must( q, &amp;sub_token, 
867 				sub_string, VIPS_PATH_MAX )) )
868 				return( NULL ); 
869 			switch( sub_token ) {
870 			case VIPS_TOKEN_LEFT:
871 				depth += 1;
872 				break;
873 			case VIPS_TOKEN_RIGHT:
874 				depth -= 1;
875 				break;
876 			default:
877 				break;
878 			}
879 		} while( !(sub_token == VIPS_TOKEN_RIGHT &amp;&amp; depth == 0) );
880 		i = VIPS_MIN( q - p, size );
881 		vips_strncpy( string, p, i + 1 );
882 	}
883 	return( q ); 
884 }
885 const char *
886 vips__token_segment_need( const char *p, VipsToken need_token, 
887 	char *string, int size )
888 {
889 <a name="1"></a>	VipsToken token;
890 	if( !(p = vips__token_segment( p, &amp;token, string, size )) ) 
891 <font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>		return( NULL );
892 	if( token != need_token ) {
893 		vips_error( "get_token", _( "expected %s, saw %s" ), 
894 			vips_enum_nick( VIPS_TYPE_TOKEN, need_token ),
895 			vips_enum_nick( VIPS_TYPE_TOKEN, token ) );
896 		return( NULL );
897 	}
898 	return( p );
899 }
900 #define MAX_TOKENS (1000)
901 const char *
902 vips__find_rightmost_brackets( const char *p )
903 {</b></font>
904 	const char *start[MAX_TOKENS + 1];
905 	VipsToken tokens[MAX_TOKENS];
906 	char str[VIPS_PATH_MAX];
907 	int n, i;
908 	int nest;
909 	start[0] = p;
910 	for( n = 0; 
911 		n &lt; MAX_TOKENS &amp;&amp;
912 		(p = vips__token_get( start[n], &amp;tokens[n], 
913 			str, VIPS_PATH_MAX )); 
914 		n++, start[n] = p )
915 		;
916 	if( n &gt;= MAX_TOKENS )
917 		return( NULL );
918 	if( n == 0 ||
919 		tokens[n - 1] != VIPS_TOKEN_RIGHT ) 
920 		return( NULL );
921 	nest = 0;
922 	for( i = n - 1; i &gt;= 0; i-- ) {
923 		if( tokens[i] == VIPS_TOKEN_RIGHT )
924 			nest += 1;
925 		else if( tokens[i] == VIPS_TOKEN_LEFT )
926 			nest -= 1;
927 		if( nest == 0 )
928 			break;
929 	}
930 	if( nest != 0 )
931 		return( NULL );
932 	return( start[i] );
933 }
934 void
935 vips__filename_split8( const char *name, char *filename, char *option_string )
936 {
937 	char *p;
938 	vips_strncpy( filename, name, VIPS_PATH_MAX );
939 	if( (p = (char *) vips__find_rightmost_brackets( filename )) ) {
940 		vips_strncpy( option_string, p, VIPS_PATH_MAX );
941 		*p = '\0';
942 	}
943 	else
944 		vips_strncpy( option_string, "", VIPS_PATH_MAX );
945 }
946 int
947 vips_ispoweroftwo( int p )
948 {
949 	int i, n;
950 	for( i = 0, n = 0; p; i++, p &gt;&gt;= 1 )
951 		if( p &amp; 1 )
952 			n++;
953 	if( n == 1 )
954 		return( i );
955 	else
956 		return( 0 );
957 }
958 int
959 vips_amiMSBfirst( void )
960 {
961 #if G_BYTE_ORDER == G_BIG_ENDIAN
962 	return( 1 );
963 #elif G_BYTE_ORDER == G_LITTLE_ENDIAN
964 	return( 0 );
965 #else
966 #error "Byte order not recognised"
967 #endif
968 }
969 static const char *
970 vips__temp_dir( void )
971 {
972 	const char *tmpd;
973 	if( !(tmpd = g_getenv( "TMPDIR" )) ) {
974 #ifdef G_OS_WIN32
975 		static gboolean done = FALSE;
976 		static char buf[256];
977 		if( !done ) {
978 			if( !GetTempPath( 256, buf ) )
979 				strcpy( buf, "C:\\temp" );
980 		}
981 		tmpd = buf;
982 		tmpd = "/tmp";
983 	}
984 	return( tmpd );
985 }
986 char *
987 vips__temp_name( const char *format )
988 {
989 	static int global_serial = 0;
990 	char file[FILENAME_MAX];
991 	char file2[FILENAME_MAX];
992 	char *name;
993 	int serial = g_atomic_int_add( &amp;global_serial, 1 );
994 	vips_snprintf( file, FILENAME_MAX, "vips-%d-%u", 
995 		serial, g_random_int() );
996 	vips_snprintf( file2, FILENAME_MAX, format, file );
997 	name = g_build_filename( vips__temp_dir(), file2, NULL );
998 	return( name );
999 }
1000 void
1001 vips__change_suffix( const char *name, char *out, int mx,
1002         const char *new, const char **olds, int nolds )
1003 {
1004         char *p;
1005         int i;
1006 	int len;
1007         vips_strncpy( out, name, mx );
1008         while( (p = strrchr( out, '.' )) ) {
1009                 for( i = 0; i &lt; nolds; i++ )
1010                         if( g_ascii_strcasecmp( p, olds[i] ) == 0 ) {
1011                                 *p = '\0';
1012                                 break;
1013                         }
1014                 if( *p )
1015                         break;
1016         }
1017 	len = strlen( out );
1018 	vips_strncpy( out + len, new, mx - len );
1019 }
1020 typedef struct {
1021 	const char unit;
1022 	int multiplier;
1023 } Unit;
1024 guint64
1025 vips__parse_size( const char *size_string )
1026 {
1027 	static Unit units[] = {
1028 		{ 'k', 1024 },
1029 		{ 'm', 1024 * 1024 },
1030 		{ 'g', 1024 * 1024 * 1024 }
1031 	};
1032 	guint64 size;
1033 	int n;
1034 	int i;
1035 	char *unit;
1036 	unit = g_strdup( size_string );
1037 	n = sscanf( size_string, "%d %s", &amp;i, unit );
1038 	size = i;
1039 	if( n &gt; 1 ) {
1040 		int j;
1041 		for( j = 0; j &lt; VIPS_NUMBER( units ); j++ )
1042 			if( tolower( unit[0] ) == units[j].unit ) {
1043 				size *= units[j].multiplier;
1044 				break;
1045 			}
1046 	}
1047 	g_free( unit );
1048 	VIPS_DEBUG_MSG( "parse_size: parsed \"%s\" as %" G_GUINT64_FORMAT "\n", 
1049 		size_string, size );
1050 	return( size );
1051 }
1052 const char *
1053 vips_enum_string( GType enm, int v )
1054 {
1055 	GEnumValue *value;
1056 	if( !(value = g_enum_get_value( g_type_class_ref( enm ), v )) )
1057 		return( "(null)" );
1058 	return( value-&gt;value_name );
1059 }
1060 const char *
1061 vips_enum_nick( GType enm, int v )
1062 {
1063 	GEnumValue *value;
1064 	if( !(value = g_enum_get_value( g_type_class_ref( enm ), v )) )
1065 		return( "(null)" );
1066 	return( value-&gt;value_nick );
1067 }
1068 int
1069 vips_enum_from_nick( const char *domain, GType type, const char *nick )
1070 {
1071 	GTypeClass *class;
1072 	GEnumClass *genum;
1073 	GEnumValue *enum_value;
1074 	int i;
1075 	char str[1000];
1076 	VipsBuf buf = VIPS_BUF_STATIC( str );
1077 	if( !(class = g_type_class_ref( type )) ) {
1078 		vips_error( domain, "%s", _( "no such enum type" ) ); 
1079 		return( -1 );
1080 	}
1081 	genum = G_ENUM_CLASS( class );
1082 	if( (enum_value = g_enum_get_value_by_name( genum, nick )) ) 
1083 		return( enum_value-&gt;value );
1084 	if( (enum_value = g_enum_get_value_by_nick( genum, nick )) ) 
1085 		return( enum_value-&gt;value );
1086 	for( i = 0; i &lt; genum-&gt;n_values - 1; i++ ) {
1087 		if( i &gt; 0 )
1088 			vips_buf_appends( &amp;buf, ", " );
1089 		vips_buf_appends( &amp;buf, genum-&gt;values[i].value_nick );
1090 	}
1091 	vips_error( domain, _( "enum '%s' has no member '%s', " 
1092 		"should be one of: %s" ),
1093 		g_type_name( type ), nick, vips_buf_all( &amp;buf ) );
1094 	return( -1 );
1095 }
1096 int
1097 vips_flags_from_nick( const char *domain, GType type, const char *nick )
1098 {
1099 	GTypeClass *class;
1100 	GFlagsClass *gflags;
1101 	GFlagsValue *flags_value;
1102 	int i;
1103 	char str[1000];
1104 	VipsBuf buf = VIPS_BUF_STATIC( str );
1105 	if( !(class = g_type_class_ref( type )) ) {
1106 		vips_error( domain, "%s", _( "no such flag type" ) ); 
1107 		return( -1 );
1108 	}
1109 	gflags = G_FLAGS_CLASS( class );
1110 	if( (flags_value = g_flags_get_value_by_name( gflags, nick )) ) 
1111 		return( flags_value-&gt;value );
1112 	if( (flags_value = g_flags_get_value_by_nick( gflags, nick )) ) 
1113 		return( flags_value-&gt;value );
1114 	for( i = 0; i &lt; gflags-&gt;n_values; i++ ) {
1115 		if( i &gt; 0 )
1116 			vips_buf_appends( &amp;buf, ", " );
1117 		vips_buf_appends( &amp;buf, gflags-&gt;values[i].value_nick );
1118 	}
1119 	vips_error( domain, _( "flags '%s' has no member '%s', " 
1120 		"should be one of: %s" ),
1121 		g_type_name( type ), nick, vips_buf_all( &amp;buf ) );
1122 	return( -1 );
1123 }
1124 int
1125 vips__substitute( char *buf, size_t len, char *sub )
1126 {
1127 	size_t buflen = strlen( buf ); 
1128 	size_t sublen = strlen( sub ); 
1129 	int lowest_n;
1130 	char *sub_start;
1131 	char *p;
1132 	char *sub_end;
1133 	size_t before_len, marker_len, after_len, final_len;
1134 	g_assert( buflen &lt; len ); 
1135 	lowest_n = -1;
1136 	sub_start = NULL;
1137 	sub_end = NULL;
1138 	for( p = buf; (p = strchr( p, '%' )); p++ )  
1139 		if( isdigit( p[1] ) ) {
1140 			char *q;
1141 			for( q = p + 1; isdigit( *q ); q++ )
1142 				;
1143 			if( q[0] == 's' ) {
1144 				int n;
1145 				n = atoi( p + 1 );
1146 				if( lowest_n == -1 ||
1147 					n &lt; lowest_n ) {
1148 					lowest_n = n;
1149 					sub_start = p;
1150 					sub_end = q + 1;
1151 				}
1152 			}
1153 		}
1154 	if( !sub_start ) 
1155 		for( p = buf; (p = strchr( p, '%' )); p++ )  
1156 			if( p[1] == 's' ) {
1157 				sub_start = p;
1158 				sub_end = p + 2;
1159 				break;
1160 			}
1161 	if( !sub_start ) 
1162 		return( -1 ); 
1163 	before_len = sub_start - buf;
1164 	marker_len = sub_end - sub_start;
1165 	after_len = buflen - (before_len + marker_len);
1166 	final_len = before_len + sublen + after_len + 1;
1167 	if( final_len &gt; len )  
1168 		return( -1 ); 
1169 	memmove( buf + before_len + sublen, buf + before_len + marker_len, 
1170 		after_len + 1 );  
1171 	memmove( buf + before_len, sub, sublen ); 
1172 	return( 0 ); 
1173 }
1174 char *
1175 vips_realpath( const char *path ) 
1176 {
1177 	char *real;
1178 	if( !g_path_is_absolute( path ) ) {
1179 		char *cwd;
1180 		cwd = g_get_current_dir();
1181 		real = g_build_filename( cwd, path, NULL );
1182 		g_free( cwd );
1183 	}
1184 	else
1185 		real = g_strdup( path );
1186 	return( real );
1187 }
1188 guint32
1189 vips__random( guint32 seed )
1190 {
1191 	return( 1103515245u * seed + 12345 );
1192 }
1193 guint32 
1194 vips__random_add( guint32 seed, int value )
1195 {
1196 	seed = ((2166136261u ^ seed) * 16777619u) ^ value;
1197 	return( vips__random( seed ) ); 
1198 }
1199 static void *
1200 vips_icc_dir_once( void *null )
1201 {
1202 #ifdef G_OS_WIN32
1203 	wchar_t wwindowsdir[MAX_PATH];
1204 	if( GetWindowsDirectoryW( wwindowsdir, G_N_ELEMENTS( wwindowsdir ) ) ) {
1205 		char *windowsdir;
1206 		if( (windowsdir = g_utf16_to_utf8( wwindowsdir, 
1207 			-1, NULL, NULL, NULL)) ) {
1208 			gchar *full_path;
1209 			full_path = g_build_filename( windowsdir, 
1210 				"system32", "spool", "drivers", "color", NULL );
1211 			g_free( windowsdir );
1212 			return( (void *) full_path );
1213 		}
1214 	}
1215 	return( (void *) VIPS_ICC_DIR );
1216 }
1217 const char *
1218 vips__icc_dir( void )
1219 {
1220 	static GOnce once = G_ONCE_INIT;
1221 	return( (const char *) g_once( &amp;once, 
1222 		vips_icc_dir_once, NULL ) );
1223 }
1224 #ifdef G_OS_WIN32
1225 static HMODULE vips__dll = NULL;
1226 #ifdef DLL_EXPORT
1227 BOOL WINAPI
1228 DllMain( HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpvReserved )
1229 {
1230 	if( fdwReason == DLL_PROCESS_ATTACH )
1231 		vips__dll = hinstDLL;
1232 	return( TRUE );
1233 }
1234 #endif
1235 static void *
1236 vips__windows_prefix_once( void *null )
1237 {
1238 	char *prefix;
1239 #ifdef G_OS_WIN32
1240 	prefix = g_win32_get_package_installation_directory_of_module( 
1241 		vips__dll );
1242         prefix = (char *) g_getenv( "VIPSHOME" );
1243 	return( (void *) prefix ); 
1244 }
1245 const char *
1246 vips__windows_prefix( void )
1247 {
1248 	static GOnce once = G_ONCE_INIT;
1249 	return( (const char *) g_once( &amp;once, 
1250 		vips__windows_prefix_once, NULL ) );
1251 }
1252 char *
1253 vips__get_iso8601( void )
1254 {
1255 	char *date;
1256 #ifdef HAVE_DATE_TIME_FORMAT_ISO8601
1257 {
1258 	GDateTime *now;
1259 	now = g_date_time_new_now_local();
1260 	date = g_date_time_format_iso8601( now );
1261 	g_date_time_unref( now );
1262 }
1263 {
1264 	GTimeVal now;
1265 	g_get_current_time( &amp;now );
1266 	date = g_time_val_to_iso8601( &amp;now ); 
1267 }
1268 	return( date );
1269 }
1270 int
1271 vips_strtod( const char *str, double *out )
1272 {
1273 	const char *p;
1274 	*out = 0;
1275 	for( p = str; *p; p++ )
1276 		if( isdigit( *p ) )
1277 			break;
1278 	if( !*p ) 
1279 		return( -1 );
1280 	*out = g_ascii_strtod( str, NULL );
1281 	if( errno ) 
1282 		return( -1 );
1283 	return( 0 );
1284 }
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>image.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 #ifdef HAVE_CONFIG_H
2 #include &lt;config.h&gt;
3 #include &lt;vips/intl.h&gt;
4 #include &lt;stdio.h&gt;
5 #include &lt;stdlib.h&gt;
6 #include &lt;string.h&gt;
7 #ifdef HAVE_UNISTD_H
8 #include &lt;unistd.h&gt;
9 #include &lt;ctype.h&gt;
10 #include &lt;vips/vips.h&gt;
11 #include &lt;vips/internal.h&gt;
12 #include &lt;vips/debug.h&gt;
13 enum {
14 	SIG_PREEVAL,		
15 	SIG_EVAL,		
16 	SIG_POSTEVAL,		
17 	SIG_WRITTEN,		
18 	SIG_INVALIDATE,		
19 	SIG_MINIMISE,		
20 	SIG_LAST
21 };
22 int vips__progress = 0;
23 char *vips__disc_threshold = NULL;
24 static GMutex *vips__minimise_lock = NULL;
25 static guint vips_image_signals[SIG_LAST] = { 0 };
26 G_DEFINE_TYPE( VipsImage, vips_image, VIPS_TYPE_OBJECT );
27 void
28 vips_progress_set( gboolean progress )
29 {
30 	vips__progress = progress;
31 }
32 static void
33 vips_image_delete( VipsImage *image )
34 {
35 	if( image-&gt;delete_on_close ) {
36 		g_assert( image-&gt;delete_on_close_filename );
37 		VIPS_DEBUG_MSG( "vips_image_delete: removing temp %s\n", 
38 				image-&gt;delete_on_close_filename );
39 		g_unlink( image-&gt;delete_on_close_filename );
40 		VIPS_FREE( image-&gt;delete_on_close_filename );
41 		image-&gt;delete_on_close = FALSE;
42 	}
43 }
44 static void
45 vips_image_finalize( GObject *gobject )
46 {
47 	VipsImage *image = VIPS_IMAGE( gobject );
48 	VIPS_DEBUG_MSG( "vips_image_finalize: %p\n", gobject );
49 	g_assert( !image-&gt;regions );
50 	g_assert( !image-&gt;windows );
51 	image-&gt;start_fn = NULL;
52 	image-&gt;generate_fn = NULL;
53 	image-&gt;stop_fn = NULL;
54 	image-&gt;client1 = NULL;
55 	image-&gt;client2 = NULL;
56 	vips__link_break_all( image );
57 	if( image-&gt;time ) {
58 		VIPS_FREEF( g_timer_destroy, image-&gt;time-&gt;start );
59 		VIPS_FREE( image-&gt;time );
60 	}
61 	if( image-&gt;data ) {
62 		if( image-&gt;dtype == VIPS_IMAGE_SETBUF ) {
63 			VIPS_DEBUG_MSG( "vips_image_finalize: "
64 				"freeing buffer\n" );
65 			vips_tracked_free( image-&gt;data );
66 			image-&gt;dtype = VIPS_IMAGE_NONE;
67 		}
68 		image-&gt;data = NULL;
69 	}
70 	vips_image_delete( image );
71 	VIPS_FREEF( vips_g_mutex_free, image-&gt;sslock );
72 	VIPS_FREE( image-&gt;Hist );
73 	VIPS_FREEF( vips__gslist_gvalue_free, image-&gt;history_list );
74 	vips__meta_destroy( image );
75 	G_OBJECT_CLASS( vips_image_parent_class )-&gt;finalize( gobject );
76 }
77 static void
78 vips_image_dispose( GObject *gobject )
79 {
80 	VipsImage *image = VIPS_IMAGE( gobject );
81 	VIPS_DEBUG_MSG( "vips_image_dispose: %p\n", gobject );
82 #ifdef DEBUG_LEAK
83 {
84 	VipsImagePixels *pixels = g_object_get_qdata( G_OBJECT( image ), 
85 		vips__image_pixels_quark ); 
86 	if( pixels &amp;&amp;
87 		pixels-&gt;tpels ) {
88 		int compute_percent = 100.0 * pixels-&gt;npels / pixels-&gt;tpels;
89 		if( compute_percent &gt; 100 ) 
90 			printf( "vips_image_dispose: %s %s computed %d%%\n", 
91 				image-&gt;filename, 
92 				pixels-&gt;nickname, 
93 				compute_percent );
94 	}
95 }
96 	vips_object_preclose( VIPS_OBJECT( gobject ) );
97 	if( image-&gt;baseaddr ) {
98 		VIPS_DEBUG_MSG( "vips_image_dispose: unmapping file\n" );
99 		vips__munmap( image-&gt;baseaddr, image-&gt;length );
100 		image-&gt;baseaddr = NULL;
101 		image-&gt;length = 0;
102 		image-&gt;data = NULL;
103 	}
104 	if( image-&gt;fd != -1 ) {
105 		VIPS_DEBUG_MSG( "vips_image_dispose: closing output file\n" );
106 		if( vips_tracked_close( image-&gt;fd ) == -1 ) 
107 			vips_error( "VipsImage", 
108 				"%s", _( "unable to close fd" ) );
109 		image-&gt;fd = -1;
110 	}
111 	G_OBJECT_CLASS( vips_image_parent_class )-&gt;dispose( gobject );
112 }
113 static VipsObject *
114 vips_image_new_from_file_object( const char *string )
115 {
116 	VipsImage *image;
117 	vips_check_init();
118 	image = VIPS_IMAGE( g_object_new( VIPS_TYPE_IMAGE, NULL ) );
119 	g_object_set( image,
120 		"filename", string,
121 		"mode", "r",
122 		NULL );
123 	return( VIPS_OBJECT( image ) );
124 }
125 static void
126 vips_image_to_string( VipsObject *object, VipsBuf *buf )
127 {
128 	VipsImage *image = VIPS_IMAGE( object );
129 	vips_buf_appends( buf, image-&gt;filename );
130 }
131 static int 
132 vips_image_write_object( VipsObject *object, const char *string )
133 {
134 	return( vips_image_write_to_file( VIPS_IMAGE( object ), string, 
135 		NULL ) );
136 }
137 static void *
138 print_field_fn( VipsImage *image, const char *field, GValue *value, void *a )
139 {
140 	VipsBuf *buf = (VipsBuf *) a;
141 	vips_buf_appendf( buf, "%s: ", field );
142 	vips_buf_appendgv( buf, value );
143 	vips_buf_appendf( buf, "\n" );
144 	return( NULL );
145 }
146 static void
147 vips_image_dump( VipsObject *object, VipsBuf *buf )
148 {
149 	VipsImage *image = VIPS_IMAGE( object );
150 	vips_buf_appendf( buf, 
151 		ngettext( 
152 			"%dx%d %s, %d band, %s", 
153 			"%dx%d %s, %d bands, %s", 
154 			vips_image_get_bands( image ) ),
155 		vips_image_get_width( image ),
156 		vips_image_get_height( image ),
157 		vips_enum_nick( VIPS_TYPE_BAND_FORMAT, 
158 			vips_image_get_format( image ) ),
159 		vips_image_get_bands( image ),
160 		vips_enum_nick( VIPS_TYPE_INTERPRETATION, 
161 			vips_image_get_interpretation( image ) ) );
162 	vips_buf_appendf( buf, ", %s", 
163 		vips_enum_nick( VIPS_TYPE_IMAGE_TYPE, image-&gt;dtype ) );
164 	VIPS_OBJECT_CLASS( vips_image_parent_class )-&gt;dump( object, buf );
165 	vips_buf_appendf( buf, "\n" );
166 	(void) vips_image_map( image, print_field_fn, (void *) buf );
167 	vips_buf_appendf( buf, "Hist: %s", vips_image_get_history( image ) );
168 }
169 static void
170 vips_image_summary( VipsObject *object, VipsBuf *buf )
171 {
172 	VipsImage *image = VIPS_IMAGE( object );
173 	const char *p;
174 	vips_buf_appendf( buf, "%dx%d",
175 		vips_image_get_width( image ), vips_image_get_height( image ) );
176 	if( vips_image_get_coding( image ) == VIPS_CODING_NONE ) {
177 		vips_buf_appendf( buf, 
178 			ngettext( 
179 				" %s, %d band, %s", 
180 				" %s, %d bands, %s", 
181 				vips_image_get_bands( image ) ),
182 			vips_enum_nick( VIPS_TYPE_BAND_FORMAT, 
183 				vips_image_get_format( image ) ),
184 			vips_image_get_bands( image ),
185 			vips_enum_nick( VIPS_TYPE_INTERPRETATION, 
186 				vips_image_get_interpretation( image ) ) );
187 	}
188 	else {
189 		vips_buf_appendf( buf, ", %s",
190 			vips_enum_nick( VIPS_TYPE_CODING, 
191 				vips_image_get_coding( image ) ) );
192 	}
193 	if( vips_image_get_typeof( image, VIPS_META_LOADER ) &amp;&amp;
194 		!vips_image_get_string( image, VIPS_META_LOADER, &amp;p ) ) 
195 		vips_buf_appendf( buf, ", %s", p );
196 	VIPS_OBJECT_CLASS( vips_image_parent_class )-&gt;summary( object, buf );
197 }
198 static void *
199 vips_image_sanity_upstream( VipsImage *up, VipsImage *down, void *b )
200 {
201 	if( !g_slist_find( up-&gt;downstream, down ) ||
202 		!g_slist_find( down-&gt;upstream, up ) )
203 		return( up );
204 	return( NULL );
205 }
206 static void *
207 vips_image_sanity_downstream( VipsImage *down, VipsImage *up, void *b )
208 {
209 	return( vips_image_sanity_upstream( up, down, b ) );
210 }
211 static void
212 vips_image_sanity( VipsObject *object, VipsBuf *buf )
213 {
214 	VipsImage *image = VIPS_IMAGE( object );
215 	if( image-&gt;Xsize != 0 ||
216 		image-&gt;Ysize != 0 ||
217 		image-&gt;Bands != 0 ) {
218 		if( image-&gt;Xsize &lt;= 0 || 
219 			image-&gt;Ysize &lt;= 0 || 
220 			image-&gt;Bands &lt;= 0 ) 
221 			vips_buf_appends( buf, "bad dimensions\n" );
222 		if( image-&gt;BandFmt &lt; -1 || 
223 			image-&gt;BandFmt &gt; VIPS_FORMAT_DPCOMPLEX ||
224 			(image-&gt;Coding != -1 &amp;&amp;
225 				image-&gt;Coding != VIPS_CODING_NONE &amp;&amp; 
226 				image-&gt;Coding != VIPS_CODING_LABQ &amp;&amp;
227 				image-&gt;Coding != VIPS_CODING_RAD) ||
228 			image-&gt;Type &gt;= VIPS_INTERPRETATION_LAST ||
229 			image-&gt;dtype &gt; VIPS_IMAGE_PARTIAL || 
230 			image-&gt;dhint &gt; VIPS_DEMAND_STYLE_ANY ) 
231 			vips_buf_appends( buf, "bad enum\n" );
232 		if( image-&gt;Xres &lt; 0 || 
233 			image-&gt;Yres &lt; 0 ) 
234 			vips_buf_appends( buf, "bad resolution\n" );
235 	}
236 	g_mutex_lock( vips__global_lock );
237 	if( vips_slist_map2( image-&gt;upstream, 
238 		(VipsSListMap2Fn) vips_image_sanity_upstream, image, NULL ) )
239 		vips_buf_appends( buf, "upstream broken\n" );
240 	if( vips_slist_map2( image-&gt;downstream, 
241 		(VipsSListMap2Fn) vips_image_sanity_downstream, image, NULL ) )
242 		vips_buf_appends( buf, "downstream broken\n" );
243 	g_mutex_unlock( vips__global_lock );
244 	VIPS_OBJECT_CLASS( vips_image_parent_class )-&gt;sanity( object, buf );
245 }
246 static void
247 vips_image_rewind( VipsObject *object )
248 {
249 	VipsImage *image = VIPS_IMAGE( object );
250 	char *filename;
251 	char *mode;
252 	filename = g_strdup( vips_image_get_filename( image ) );
253 	mode = g_strdup( vips_image_get_mode( image ) );
254 	VIPS_OBJECT_CLASS( vips_image_parent_class )-&gt;rewind( object );
255 	g_assert( image-&gt;filename == NULL );
256 	g_assert( image-&gt;mode == NULL );
257 	image-&gt;filename = filename;
258 	image-&gt;mode = mode;
259 }
260 static void
261 vips_image_save_cb( VipsImage *image, int *result, void *data )
262 {
263 	if( vips_foreign_save( image, image-&gt;filename, NULL ) )
264 		*result = -1;
265 }
266 static void
267 vips_image_preeval_cb( VipsImage *image, VipsProgress *progress, int *last )
268 {
269 	int tile_width; 
270 	int tile_height; 
271 	int n_lines;
272 	*last = -1;
273 	vips_get_tile_size( image, 
274 		&amp;tile_width, &amp;tile_height, &amp;n_lines );
275 	printf( _( "%s %s: %d x %d pixels, %d threads, %d x %d tiles, "
276 		"%d lines in buffer" ),
277 		vips_get_prgname(), image-&gt;filename,
278 		image-&gt;Xsize, image-&gt;Ysize,
279 		vips_concurrency_get(),
280 		tile_width, tile_height, n_lines );
281 	printf( "\n" );
282 }
283 static void
284 vips_image_eval_cb( VipsImage *image, VipsProgress *progress, int *last )
285 {
286 	if( progress-&gt;percent != *last ) {
287 		printf( _( "%s %s: %d%% complete" ), 
288 			vips_get_prgname(), image-&gt;filename, 
289 			progress-&gt;percent );
290 		printf( "\r" ); 
291 		fflush( stdout );
292 		*last = progress-&gt;percent;
293 	}
294 }
295 static void
296 vips_image_posteval_cb( VipsImage *image, VipsProgress *progress, void *data )
297 {
298 	printf( _( "%s %s: done in %.3gs          \n" ), 
299 		vips_get_prgname(), image-&gt;filename, 
300 		g_timer_elapsed( progress-&gt;start, NULL ) );
301 }
302 static void
303 vips_image_add_progress( VipsImage *image )
304 {
305 	if( vips__progress || 
306 		g_getenv( "VIPS_PROGRESS" )
307 #if ENABLE_DEPRECATED
308 		|| g_getenv( "IM_PROGRESS" )
309 #endif
310 		) {
311 		int *last = VIPS_NEW( image, int );
312 		g_signal_connect( image, "preeval", 
313 			G_CALLBACK( vips_image_preeval_cb ), last );
314 		g_signal_connect( image, "eval", 
315 			G_CALLBACK( vips_image_eval_cb ), last );
316 		g_signal_connect( image, "posteval", 
317 			G_CALLBACK( vips_image_posteval_cb ), NULL );
318 		vips_image_set_progress( image, TRUE );
319 	}
320 }
321 static int
322 vips_image_build( VipsObject *object )
323 {
324 	VipsImage *image = VIPS_IMAGE( object );
325 	const char *filename = image-&gt;filename;
326 	const char *mode = image-&gt;mode;
327 	guint32 magic;
328 	guint64 sizeof_image;
329 	VIPS_DEBUG_MSG( "vips_image_build: %p\n", image );
330 	if( VIPS_OBJECT_CLASS( vips_image_parent_class )-&gt;build( object ) )
331 		return( -1 );
332 	switch( mode[0] ) {
333         case 'v':
334 		if( vips_image_open_input( image ) )
335 			return( -1 );
336 		break;
337         case 'r':
338 		if( (magic = vips__file_magic( filename )) ) {
339 			if( GUINT_FROM_BE( magic ) == image-&gt;magic ) {
340 				if( vips_image_open_input( image ) )
341 					return( -1 );
342 			}
343 			else {
344 				VipsImage *t; 
345 				VipsImage *t2;
346 				if( !(t = vips_image_new_mode( filename, 
347 					"v" )) )
348 					return( -1 );
349 				if( vips_byteswap( t, &amp;t2, NULL ) ) {
350 					g_object_unref( t );
351 					return( -1 );
352 				}
353 				g_object_unref( t );
354 				image-&gt;dtype = VIPS_IMAGE_PARTIAL;
355 				if( vips_image_write( t2, image ) ) {
356 					g_object_unref( t2 );
357 					return( -1 );
358 				}
359 				g_object_unref( t2 );
360 			}
361 		}
362 		else {
363 			VipsImage *t;
364 			if( mode[1] == 's' ) {
365 				if( vips_foreign_load( filename, &amp;t, 
366 					"access", VIPS_ACCESS_SEQUENTIAL,
367 					NULL ) )
368 					return( -1 );
369 			}
370 			else {
371 				if( vips_foreign_load( filename, &amp;t, NULL ) )
372 					return( -1 );
373 			}
374 			image-&gt;dtype = VIPS_IMAGE_PARTIAL;
375 			if( vips_image_write( t, image ) ) {
376 				g_object_unref( t );
377 				return( -1 );
378 			}
379 			g_object_unref( t );
380 		}
381         	break;
382 	case 'w':
383 {
384 		const char *file_op;
385 		g_assert( g_type_from_name( "VipsForeignSaveVips" ) );
386 		if( !(file_op = vips_foreign_find_save( filename )) )
387 			return( -1 );
388 		if( vips_isprefix( "VipsForeignSaveVips", file_op ) )
389 			image-&gt;dtype = VIPS_IMAGE_OPENOUT;
390 		else {
391 			image-&gt;dtype = VIPS_IMAGE_PARTIAL;
392 			g_signal_connect( image, "written", 
393 				G_CALLBACK( vips_image_save_cb ), 
394 				NULL );
395 		}
396 }
397         	break;
398         case 't':
399 		image-&gt;dtype = VIPS_IMAGE_SETBUF;
400 		image-&gt;dhint = VIPS_DEMAND_STYLE_ANY;
401                 break;
402         case 'p':
403 		image-&gt;dtype = VIPS_IMAGE_PARTIAL;
404                 break;
405 	case 'a':
406 		if( (image-&gt;fd = vips__open_image_read( filename )) == -1 ) 
407 			return( -1 );
408 		image-&gt;dtype = VIPS_IMAGE_OPENIN;
409 		image-&gt;dhint = VIPS_DEMAND_STYLE_THINSTRIP;
410 		if( image-&gt;Bands == 1 )
411 			image-&gt;Type = VIPS_INTERPRETATION_B_W;
412 		else if( image-&gt;Bands == 3 )
413 			image-&gt;Type = VIPS_INTERPRETATION_sRGB;
414 		else 
415 			image-&gt;Type = VIPS_INTERPRETATION_MULTIBAND;
416 		if( (image-&gt;file_length = vips_file_length( image-&gt;fd )) == -1 )
417 			return( -1 );
418 		sizeof_image = VIPS_IMAGE_SIZEOF_IMAGE( image ) + 
419 			image-&gt;sizeof_header;
420 		if( image-&gt;file_length &lt; sizeof_image ) {
421 			vips_error( "VipsImage", 
422 				_( "unable to open \"%s\", file too short" ), 
423 				image-&gt;filename );
424 			return( -1 );
425 		}
426 		if( image-&gt;file_length &gt; sizeof_image ) 
427 			g_warning( _( "%s is longer than expected" ),
428 				image-&gt;filename );
429 		break;
430 	case 'm':
431 		if( image-&gt;Bands == 1 )
432 			image-&gt;Type = VIPS_INTERPRETATION_B_W;
433 		else if( image-&gt;Bands == 3 )
434 			image-&gt;Type = VIPS_INTERPRETATION_sRGB;
435 		else 
436 			image-&gt;Type = VIPS_INTERPRETATION_MULTIBAND;
437 		image-&gt;dtype = VIPS_IMAGE_SETBUF_FOREIGN;
438 		image-&gt;dhint = VIPS_DEMAND_STYLE_ANY;
439 		break;
440 	default:
441 		vips_error( "VipsImage", _( "bad mode \"%s\"" ), mode );
442 		return( -1 );
443         }
444 	vips_image_add_progress( image );
445 	return( 0 );
446 }
447 static void *
448 vips_image_real_invalidate_cb( VipsRegion *reg, void *a, void *b )
449 {
450 	vips_region_invalidate( reg );
451 	return( NULL );
452 }
453 static void 
454 vips_image_real_invalidate( VipsImage *image, void *data )
455 {
456 	VIPS_DEBUG_MSG( "vips_image_real_invalidate: %p\n", image );
457 	VIPS_GATE_START( "vips_image_real_invalidate: wait" );
458 	g_mutex_lock( image-&gt;sslock );
459 	VIPS_GATE_STOP( "vips_image_real_invalidate: wait" );
460 	(void) vips_slist_map2( image-&gt;regions,
461 		(VipsSListMap2Fn) vips_image_real_invalidate_cb, NULL, NULL );
462 	g_mutex_unlock( image-&gt;sslock );
463 }
464 static void 
465 vips_image_real_minimise( VipsImage *image, void *data )
466 {
467 	VIPS_DEBUG_MSG( "vips_image_real_minimise: %p\n", image );
468 }
469 static void 
470 vips_image_real_written( VipsImage *image, int *result, void *data )
471 {
472 	VIPS_DEBUG_MSG( "vips_image_real_written: %p\n", image );
473 	if( image-&gt;dtype == VIPS_IMAGE_OPENOUT &amp;&amp;
474 		vips__writehist( image ) ) 
475 		*result = -1;
476 }
477 static void
478 vips_image_class_init( VipsImageClass *class )
479 {
480 	GObjectClass *gobject_class = G_OBJECT_CLASS( class );
481 	VipsObjectClass *vobject_class = VIPS_OBJECT_CLASS( class );
482 	VIPS_DEBUG_MSG( "vips_image_class_init:\n" );
483 	vips_check_init(); 
484 	gobject_class-&gt;finalize = vips_image_finalize;
485 	gobject_class-&gt;dispose = vips_image_dispose;
486 	gobject_class-&gt;set_property = vips_object_set_property;
487 	gobject_class-&gt;get_property = vips_object_get_property;
488 	vobject_class-&gt;new_from_string = vips_image_new_from_file_object;
489 	vobject_class-&gt;to_string = vips_image_to_string;
490 	vobject_class-&gt;output_needs_arg = TRUE;
491 	vobject_class-&gt;output_to_arg = vips_image_write_object;
492 	vobject_class-&gt;nickname = "image";
493 	vobject_class-&gt;description = _( "image class" );
494 	vobject_class-&gt;dump = vips_image_dump;
495 	vobject_class-&gt;summary = vips_image_summary;
496 	vobject_class-&gt;sanity = vips_image_sanity;
497 	vobject_class-&gt;rewind = vips_image_rewind;
498 	vobject_class-&gt;build = vips_image_build;
499 	class-&gt;invalidate = vips_image_real_invalidate;
500 	class-&gt;written = vips_image_real_written;
501 	class-&gt;minimise = vips_image_real_minimise;
502 	VIPS_ARG_INT( class, "width", 2, 
503 		_( "Width" ), 
504 		_( "Image width in pixels" ),
505 		VIPS_ARGUMENT_SET_ALWAYS,
506 		G_STRUCT_OFFSET( VipsImage, Xsize ),
507 		1, VIPS_MAX_COORD, 1 );
508 	VIPS_ARG_INT( class, "height", 3, 
509 		_( "Height" ), 
510 		_( "Image height in pixels" ),
511 		VIPS_ARGUMENT_SET_ALWAYS,
512 		G_STRUCT_OFFSET( VipsImage, Ysize ),
513 		1, VIPS_MAX_COORD, 1 );
514 	VIPS_ARG_INT( class, "bands", 4, 
515 		_( "Bands" ), 
516 		_( "Number of bands in image" ),
517 		VIPS_ARGUMENT_SET_ALWAYS,
518 		G_STRUCT_OFFSET( VipsImage, Bands ),
519 		1, VIPS_MAX_COORD, 1 );
520 	VIPS_ARG_ENUM( class, "format", 5, 
521 		_( "Format" ), 
522 		_( "Pixel format in image" ),
523 		VIPS_ARGUMENT_SET_ALWAYS,
524 		G_STRUCT_OFFSET( VipsImage, BandFmt ),
525 		VIPS_TYPE_BAND_FORMAT, VIPS_FORMAT_UCHAR ); 
526 	VIPS_ARG_ENUM( class, "coding", 6, 
527 		_( "Coding" ), 
528 		_( "Pixel coding" ),
529 		VIPS_ARGUMENT_SET_ALWAYS,
530 		G_STRUCT_OFFSET( VipsImage, Coding ),
531 		VIPS_TYPE_CODING, VIPS_CODING_NONE ); 
532 	VIPS_ARG_ENUM( class, "interpretation", 7, 
533 		_( "Interpretation" ), 
534 		_( "Pixel interpretation" ),
535 		VIPS_ARGUMENT_SET_ALWAYS,
536 		G_STRUCT_OFFSET( VipsImage, Type ),
537 		VIPS_TYPE_INTERPRETATION, VIPS_INTERPRETATION_MULTIBAND ); 
538 	VIPS_ARG_DOUBLE( class, "xres", 8, 
539 		_( "Xres" ), 
540 		_( "Horizontal resolution in pixels/mm" ),
541 		VIPS_ARGUMENT_SET_ALWAYS,
542 		G_STRUCT_OFFSET( VipsImage, Xres ),
543 		-0.0, 1000000, 0 );
544 	VIPS_ARG_DOUBLE( class, "yres", 9, 
545 		_( "Yres" ), 
546 		_( "Vertical resolution in pixels/mm" ),
547 		VIPS_ARGUMENT_SET_ALWAYS,
548 		G_STRUCT_OFFSET( VipsImage, Yres ),
549 		-0.0, 1000000, 0 );
550 	VIPS_ARG_INT( class, "xoffset", 10, 
551 		_( "Xoffset" ), 
552 		_( "Horizontal offset of origin" ),
553 		VIPS_ARGUMENT_SET_ALWAYS,
554 		G_STRUCT_OFFSET( VipsImage, Xoffset ),
555 		-VIPS_MAX_COORD, VIPS_MAX_COORD, 0 );
556 	VIPS_ARG_INT( class, "yoffset", 11, 
557 		_( "Yoffset" ), 
558 		_( "Vertical offset of origin" ),
559 		VIPS_ARGUMENT_SET_ALWAYS,
560 		G_STRUCT_OFFSET( VipsImage, Yoffset ),
561 		-VIPS_MAX_COORD, VIPS_MAX_COORD, 0 );
562 	VIPS_ARG_STRING( class, "filename", 12, 
563 		_( "Filename" ),
564 		_( "Image filename" ),
565 		VIPS_ARGUMENT_SET_ONCE | VIPS_ARGUMENT_CONSTRUCT, 
566 		G_STRUCT_OFFSET( VipsImage, filename ),
567 		NULL );
568 	VIPS_ARG_STRING( class, "mode", 13, 
569 		_( "Mode" ),
570 		_( "Open mode" ),
571 		VIPS_ARGUMENT_SET_ONCE | VIPS_ARGUMENT_CONSTRUCT, 
572 		G_STRUCT_OFFSET( VipsImage, mode ),
573 		"p" );
574 	VIPS_ARG_BOOL( class, "kill", 14, 
575 		_( "Kill" ),
576 		_( "Block evaluation on this image" ),
577 		VIPS_ARGUMENT_SET_ALWAYS, 
578 		G_STRUCT_OFFSET( VipsImage, kill ),
579 		FALSE );
580 	VIPS_ARG_ENUM( class, "demand", 15, 
581 		_( "Demand style" ), 
582 		_( "Preferred demand style for this image" ),
583 		VIPS_ARGUMENT_CONSTRUCT,
584 		G_STRUCT_OFFSET( VipsImage, dhint ),
585 		VIPS_TYPE_DEMAND_STYLE, VIPS_DEMAND_STYLE_SMALLTILE );
586 	VIPS_ARG_UINT64( class, "sizeof_header", 16, 
587 		_( "Size of header" ), 
588 		_( "Offset in bytes from start of file" ),
589 		VIPS_ARGUMENT_SET_ONCE | VIPS_ARGUMENT_CONSTRUCT, 
590 		G_STRUCT_OFFSET( VipsImage, sizeof_header ),
591 		0, 1000000000, VIPS_SIZEOF_HEADER );
592 	VIPS_ARG_POINTER( class, "foreign_buffer", 17, 
593 		_( "Foreign buffer" ),
594 		_( "Pointer to foreign pixels" ),
595 		VIPS_ARGUMENT_SET_ONCE | VIPS_ARGUMENT_CONSTRUCT, 
596 		G_STRUCT_OFFSET( VipsImage, data ) );
597 	vips_image_signals[SIG_PREEVAL] = g_signal_new( "preeval",
598 		G_TYPE_FROM_CLASS( class ),
599 		G_SIGNAL_RUN_LAST,
600 		G_STRUCT_OFFSET( VipsImageClass, preeval ), 
601 		NULL, NULL,
602 		g_cclosure_marshal_VOID__POINTER,
603 		G_TYPE_NONE, 1,
604 		G_TYPE_POINTER );
605 	vips_image_signals[SIG_EVAL] = g_signal_new( "eval",
606 		G_TYPE_FROM_CLASS( class ),
607 		G_SIGNAL_RUN_LAST,
608 		G_STRUCT_OFFSET( VipsImageClass, eval ), 
609 		NULL, NULL,
610 		g_cclosure_marshal_VOID__POINTER,
611 		G_TYPE_NONE, 1,
612 		G_TYPE_POINTER );
613 	vips_image_signals[SIG_POSTEVAL] = g_signal_new( "posteval",
614 		G_TYPE_FROM_CLASS( class ),
615 		G_SIGNAL_RUN_LAST,
616 		G_STRUCT_OFFSET( VipsImageClass, posteval ), 
617 		NULL, NULL,
618 		g_cclosure_marshal_VOID__POINTER,
619 		G_TYPE_NONE, 1,
620 		G_TYPE_POINTER );
621 	vips_image_signals[SIG_WRITTEN] = g_signal_new( "written",
622 		G_TYPE_FROM_CLASS( class ),
623 		G_SIGNAL_RUN_LAST | G_SIGNAL_ACTION,
624 		G_STRUCT_OFFSET( VipsImageClass, written ), 
625 		NULL, NULL,
626 		g_cclosure_marshal_VOID__POINTER,
627 		G_TYPE_NONE, 1,
628 		G_TYPE_POINTER );
629 	vips_image_signals[SIG_INVALIDATE] = g_signal_new( "invalidate",
630 		G_TYPE_FROM_CLASS( class ),
631 		G_SIGNAL_RUN_LAST | G_SIGNAL_ACTION,
632 		G_STRUCT_OFFSET( VipsImageClass, invalidate ), 
633 		NULL, NULL,
634 		g_cclosure_marshal_VOID__VOID,
635 		G_TYPE_NONE, 0 );
636 	vips_image_signals[SIG_MINIMISE] = g_signal_new( "minimise",
637 		G_TYPE_FROM_CLASS( class ),
638 		G_SIGNAL_RUN_LAST | G_SIGNAL_ACTION,
639 		G_STRUCT_OFFSET( VipsImageClass, minimise ), 
640 		NULL, NULL,
641 		g_cclosure_marshal_VOID__VOID,
642 		G_TYPE_NONE, 0 );
643 	vips__minimise_lock = vips_g_mutex_new();
644 }
645 static void
646 vips_image_init( VipsImage *image )
647 {
648 	VIPS_DEBUG_MSG( "vips_image_init: %p\n", image );
649 	image-&gt;magic = vips_amiMSBfirst() ? VIPS_MAGIC_SPARC : VIPS_MAGIC_INTEL;
650 	image-&gt;Xsize = 1;
651 	image-&gt;Ysize = 1;
652 	image-&gt;Bands = 1;
653 	image-&gt;Xres = 1.0;
654 	image-&gt;Yres = 1.0;
655 	image-&gt;fd = -1;				image-&gt;sslock = vips_g_mutex_new();
656 	image-&gt;sizeof_header = VIPS_SIZEOF_HEADER;
657 	image-&gt;mode = g_strdup( "p" );
658 #ifdef DEBUG_LEAK
659 	g_object_set_qdata_full( G_OBJECT( image ), vips__image_pixels_quark, 
660 		g_new0( VipsImagePixels, 1 ), (GDestroyNotify) g_free ); 
661 }
662 int
663 vips_image_written( VipsImage *image )
664 {
665 	int result;
666 	VIPS_DEBUG_MSG( "vips_image_written: %p\n", image );
667 	result = 0;
668 	g_signal_emit( image, vips_image_signals[SIG_WRITTEN], 0, &amp;result );
669 	return( result );
670 }
671 void
672 vips_image_invalidate( VipsImage *image )
673 {
674 	VIPS_DEBUG_MSG( "vips_image_invalidate: %p\n", image );
675 	g_signal_emit( image, vips_image_signals[SIG_INVALIDATE], 0 );
676 }
677 static void *
678 vips_image_invalidate_all_cb( VipsImage *image, void *a, void *b )
679 {
680 	vips_image_invalidate( image );
681 	return( NULL );
682 }
683 void
684 vips_image_invalidate_all( VipsImage *image )
685 {
686 	VIPS_DEBUG_MSG( "vips_image_invalidate_all: %p\n", image );
687 	(void) vips__link_map( image, FALSE,
688 		(VipsSListMap2Fn) vips_image_invalidate_all_cb, NULL, NULL );
689 }
690 void
691 vips_image_minimise( VipsImage *image )
692 {
693 	VIPS_DEBUG_MSG( "vips_image_minimise: %p\n", image );
694 	g_signal_emit( image, vips_image_signals[SIG_MINIMISE], 0 );
695 }
696 static void *
697 vips_image_minimise_all_cb( VipsImage *image, void *a, void *b )
698 {
699 	vips_image_minimise( image );
700 	return( NULL );
701 }
702 void 
703 vips_image_minimise_all( VipsImage *image )
704 {
705 	g_mutex_lock( vips__minimise_lock );
706 	(void) vips__link_map( image, TRUE,
707 		(VipsSListMap2Fn) vips_image_minimise_all_cb, NULL, NULL );
708 	g_mutex_unlock( vips__minimise_lock );
709 }
710 gboolean
711 vips_image_is_sequential( VipsImage *image )
712 {
713 	return( vips_image_get_typeof( image, VIPS_META_SEQUENTIAL ) );
714 }
715 static int
716 vips_progress_add( VipsImage *image )
717 {
718 	VipsProgress *progress;
719 	VIPS_DEBUG_MSG( "vips_progress_add: %p\n", image );
720 	if( !(progress = image-&gt;time) ) {
721 		if( !(image-&gt;time = VIPS_NEW( NULL, VipsProgress )) )
722 			return( -1 );
723 		progress = image-&gt;time;
724 		progress-&gt;im = image;
725 		progress-&gt;start = NULL;
726 	}
727 	if( !progress-&gt;start )
728 		progress-&gt;start = g_timer_new();
729 	g_timer_start( progress-&gt;start );
730 	progress-&gt;run = 0;
731 	progress-&gt;eta = 0;
732 	progress-&gt;tpels = VIPS_IMAGE_N_PELS( image );
733 	progress-&gt;npels = 0;
734 	progress-&gt;percent = 0;
735 	return( 0 );
736 }
737 static void
738 vips_progress_update( VipsProgress *progress, guint64 processed )
739 {
740 	float prop;
741 	VIPS_DEBUG_MSG( "vips_progress_update: %p\n", progress );
742 	g_assert( progress );
743 	progress-&gt;run = g_timer_elapsed( progress-&gt;start, NULL );
744 	progress-&gt;npels = processed;
745 	prop = (float) progress-&gt;npels / (float) progress-&gt;tpels;
746 	progress-&gt;percent = 100 * prop;
747 	if( prop &gt; 0.1 ) 
748 		progress-&gt;eta = (1.0 / prop) * progress-&gt;run - progress-&gt;run;
749 }
750 void
751 vips_image_preeval( VipsImage *image )
752 {
753 	if( image-&gt;progress_signal ) {
754 		VIPS_DEBUG_MSG( "vips_image_preeval: %p\n", image );
755 		g_assert( vips_object_sanity( 
756 			VIPS_OBJECT( image-&gt;progress_signal ) ) );
757 		(void) vips_progress_add( image );
758 		(void) vips_progress_add( image-&gt;progress_signal );
759 		if( !vips_image_get_typeof( image, "hide-progress" ) )
760 			g_signal_emit( image-&gt;progress_signal, 
761 				vips_image_signals[SIG_PREEVAL], 0, 
762 				image-&gt;time );
763 	}
764 }
765 void
766 vips_image_eval( VipsImage *image, guint64 processed )
767 {
768 	if( image-&gt;progress_signal &amp;&amp;
769 		image-&gt;time ) {
770 		VIPS_DEBUG_MSG( "vips_image_eval: %p\n", image );
771 		g_assert( vips_object_sanity( 
772 			VIPS_OBJECT( image-&gt;progress_signal ) ) );
773 		vips_progress_update( image-&gt;time, processed );
774 		if( image-&gt;progress_signal-&gt;time != image-&gt;time )
775 			vips_progress_update( image-&gt;progress_signal-&gt;time, 
776 				processed );
777 		if( !vips_image_get_typeof( image, "hide-progress" ) )
778 			g_signal_emit( image-&gt;progress_signal, 
779 				vips_image_signals[SIG_EVAL], 0, 
780 				image-&gt;time );
781 	}
782 }
783 void
784 vips_image_posteval( VipsImage *image )
785 {
786 	if( image-&gt;progress_signal &amp;&amp;
787 		image-&gt;progress_signal-&gt;time ) { 
788 		VIPS_DEBUG_MSG( "vips_image_posteval: %p\n", image );
789 		g_assert( vips_object_sanity( 
790 			VIPS_OBJECT( image-&gt;progress_signal ) ) );
791 		if( !vips_image_get_typeof( image, "hide-progress" ) )
792 			g_signal_emit( image-&gt;progress_signal, 
793 				vips_image_signals[SIG_POSTEVAL], 0, 
794 				image-&gt;time );
795 	}
796 }
797 void
798 vips_image_set_progress( VipsImage *image, gboolean progress )
799 {
800 	if( progress &amp;&amp; 
801 		!image-&gt;progress_signal ) {
802 		VIPS_DEBUG_MSG( "vips_image_set_progress: %p %s\n", 
803 			image, image-&gt;filename );
804 		image-&gt;progress_signal = image;
805 	}
806 	else if( !progress )
807 		image-&gt;progress_signal = NULL;
808 }
809 gboolean
810 vips_image_iskilled( VipsImage *image )
811 {
812 	gboolean kill;
813 	kill = image-&gt;kill;
814 	if( image-&gt;kill ) {
815 		VIPS_DEBUG_MSG( "vips_image_iskilled: %s (%p) killed\n", 
816 			image-&gt;filename, image );
817 		vips_error( "VipsImage", 
818 			_( "killed for image \"%s\"" ), image-&gt;filename );
819 		vips_image_set_kill( image, FALSE );
820 	}
821 	return( kill );
822 }
823 void
824 vips_image_set_kill( VipsImage *image, gboolean kill )
825 {
826 	if( image-&gt;kill != kill ) 
827 		VIPS_DEBUG_MSG( "vips_image_set_kill: %s (%p) %d\n", 
828 			image-&gt;filename, image, kill );
829 	image-&gt;kill = kill;
830 }
831 void
832 vips_image_temp_name( char *name, int size )
833 {
834 	static int global_serial = 0;
835 	int serial = g_atomic_int_add( &amp;global_serial, 1 );
836 	vips_snprintf( name, size, "temp-%d", serial );
837 }
838 VipsImage *
839 vips_image_new( void )
840 {
841 	VipsImage *image;
842 	char filename[26];
843 	vips_check_init();
844 	vips_image_temp_name( filename, sizeof( filename ) );
845 	image = VIPS_IMAGE( g_object_new( VIPS_TYPE_IMAGE, NULL ) );
846 <a name="1"></a>	g_object_set( image,
847 		"filename", filename,
848 		"mode", "p",
849 <font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>		NULL );
850 	if( vips_object_build( VIPS_OBJECT( image ) ) ) {
851 		VIPS_UNREF( image );
852 		return( NULL );
853 	}
854 	return( image ); 
855 }
856 VipsImage *
857 vips_image_new_mode( const char *filename, const char *mode )
858 {</b></font>
859 	VipsImage *image;
860 	g_assert( filename );
861 	g_assert( mode );
862 	vips_check_init();
863 	image = VIPS_IMAGE( g_object_new( VIPS_TYPE_IMAGE, NULL ) );
864 	g_object_set( image,
865 		"filename", filename,
866 		"mode", mode,
867 		NULL );
868 	if( vips_object_build( VIPS_OBJECT( image ) ) ) {
869 		VIPS_UNREF( image );
870 		return( NULL );
871 	}
872 	return( image ); 
873 }
874 VipsImage *
875 vips_image_new_memory( void )
876 {
877 	char filename[26];
878 	vips_image_temp_name( filename, sizeof( filename ) );
879 	return( vips_image_new_mode( filename, "t" ) );
880 }
881 VipsImage *
882 vips_image_memory( void )
883 {
884 	return( vips_image_new_memory() ); 
885 }
886 char *
887 vips_filename_get_filename( const char *vips_filename )
888 {
889 	char filename[VIPS_PATH_MAX];
890 	char options[VIPS_PATH_MAX];
891 	vips__filename_split8( vips_filename, filename, options ); 
892 	return( g_strdup( filename ) );
893 }
894 char *
895 vips_filename_get_options( const char *vips_filename )
896 {
897 	char filename[VIPS_PATH_MAX];
898 	char options[VIPS_PATH_MAX];
899 	vips__filename_split8( vips_filename, filename, options ); 
900 	return( g_strdup( options ) );
901 }
902 VipsImage *
903 vips_image_new_from_file( const char *name, ... )
904 {
905 	char filename[VIPS_PATH_MAX];
906 	char option_string[VIPS_PATH_MAX];
907 	const char *operation_name;
908 	va_list ap;
909 	int result;
910 	VipsImage *out;
911 	vips_check_init();
912 	vips__filename_split8( name, filename, option_string );
913 	if( !(operation_name = vips_foreign_find_load( filename )) )
914 		return( NULL );
915 	va_start( ap, name );
916 	result = vips_call_split_option_string( operation_name, 
917 		option_string, ap, filename, &amp;out );
918 	va_end( ap );
919 	if( result )
920 		return( NULL ); 
921 	return( out );
922 }
923 VipsImage *
924 vips_image_new_from_file_RW( const char *filename )
925 {
926 	return( vips_image_new_mode( filename, "rw" ) ); 
927 }
928 VipsImage *
929 vips_image_new_from_file_raw( const char *filename, 
930 	int xsize, int ysize, int bands, guint64 offset )
931 {
932 	VipsImage *image;
933 	vips_check_init();
934 	image = VIPS_IMAGE( g_object_new( VIPS_TYPE_IMAGE, NULL ) );
935 	g_object_set( image,
936 		"filename", filename,
937 		"mode", "a",
938 		"width", xsize,
939 		"height", ysize,
940 		"bands", bands,
941 		"sizeof_header", offset,
942 		NULL );
943 	if( vips_object_build( VIPS_OBJECT( image ) ) ) {
944 		VIPS_UNREF( image );
945 		return( NULL );
946 	}
947 	return( image );
948 }
949 VipsImage *
950 vips_image_new_from_memory( const void *data, size_t size,
951 	int width, int height, int bands, VipsBandFormat format )
952 {
953 	VipsImage *image;
954 	char filename[26];
955 	vips_check_init();
956 	vips_image_temp_name( filename, sizeof( filename ) );
957 	image = VIPS_IMAGE( g_object_new( VIPS_TYPE_IMAGE, NULL ) );
958 	g_object_set( image,
959 		"filename", filename,
960 		"mode", "m",
961 		"foreign_buffer", data,
962 		"width", width,
963 		"height", height,
964 		"bands", bands,
965 		"format", format,
966 		NULL );
967 	if( vips_object_build( VIPS_OBJECT( image ) ) ) {
968 		VIPS_UNREF( image );
969 		return( NULL );
970 	}
971 	if( size &lt; VIPS_IMAGE_SIZEOF_IMAGE( image ) ) {
972 		vips_error( "VipsImage",
973 			_( "memory area too small --- "
974 				"should be %" G_GINT64_FORMAT " bytes, "
975 				"you passed %zd" ),
976 			VIPS_IMAGE_SIZEOF_IMAGE( image ), size ); 
977 		VIPS_UNREF( image );
978 		return( NULL );
979 	}
980 	return( image );
981 }
982 static void
983 vips_image_new_from_memory_copy_cb( VipsImage *image, void *data_copy )
984 {
985 	vips_tracked_free( data_copy );
986 }
987 VipsImage *
988 vips_image_new_from_memory_copy( const void *data, size_t size,
989 	int width, int height, int bands, VipsBandFormat format )
990 {
991 	void *data_copy;
992 	VipsImage *image;
993 	vips_check_init();
994 	if( !(data_copy = vips_tracked_malloc( size )) )
995 		return( NULL );
996 	memcpy( data_copy, data, size );
997 	if( !(image = vips_image_new_from_memory( data_copy, size, 
998 		width, height, bands, format )) ) {
999 		vips_tracked_free( data_copy );
1000 		return( NULL );
1001 	}
1002 	g_signal_connect( image, "close", 
1003 		G_CALLBACK( vips_image_new_from_memory_copy_cb ), data_copy );
1004 	return( image );
1005 }
1006 VipsImage *
1007 vips_image_new_from_buffer( const void *buf, size_t len, 
1008 	const char *option_string, ... )
1009 {
1010 	const char *operation_name;
1011 	va_list ap;
1012 	int result;
1013 	VipsImage *out;
1014 	VipsBlob *blob;
1015 	vips_check_init();
1016 	if( !(operation_name = 
1017 		vips_foreign_find_load_buffer( buf, len )) )
1018 		return( NULL );
1019 	blob = vips_blob_new( NULL, buf, len );
1020 	va_start( ap, option_string );
1021 	result = vips_call_split_option_string( operation_name,
1022 		option_string, ap, blob, &amp;out );
1023 	va_end( ap );
1024 	vips_area_unref( VIPS_AREA( blob ) );
1025 	if( result )
1026 		return( NULL );
1027 	return( out ); 
1028 }
1029 VipsImage *
1030 vips_image_new_from_source( VipsSource *source, 
1031 	const char *option_string, ... )
1032 {
1033 	const char *filename = 
1034 		vips_connection_filename( VIPS_CONNECTION( source ) );
1035 	const char *operation_name;
1036 	va_list ap;
1037 	int result;
1038 	VipsImage *out;
1039 	vips_check_init();
1040 	vips_error_freeze();
1041 	operation_name = vips_foreign_find_load_source( source );
1042 	vips_error_thaw();
1043         if( operation_name ) { 
1044 		va_start( ap, option_string );
1045 		result = vips_call_split_option_string( operation_name,
1046 			option_string, ap, source, &amp;out );
1047 		va_end( ap );
1048 	}
1049 	else if( filename ) {
1050 		if( !(operation_name = vips_foreign_find_load( filename )) )
1051 			return( NULL );
1052 		va_start( ap, option_string );
1053 		result = vips_call_split_option_string( operation_name, 
1054 			option_string, ap, filename, &amp;out );
1055 		va_end( ap );
1056 	}
1057 	else if( vips_source_is_mappable( source ) ) {
1058 		VipsBlob *blob;
1059 		const void *buf;
1060 		size_t len;
1061 		if( !(blob = vips_source_map_blob( source )) )
1062 			return( NULL );
1063 		buf = vips_blob_get( blob, &amp;len );
1064 		if( !(operation_name = 
1065 			vips_foreign_find_load_buffer( buf, len )) ) {
1066 			vips_area_unref( VIPS_AREA( blob ) );
1067 			return( NULL );
1068 		}
1069                 va_start( ap, option_string );
1070                 result = vips_call_split_option_string( operation_name,
1071                         option_string, ap, blob, &amp;out );
1072                 va_end( ap );
1073 		vips_area_unref( VIPS_AREA( blob ) );
1074 	}
1075 	else {
1076 		vips_error( "VipsImage",
1077 			"%s", _( "unable to load source" ) );
1078 		result = -1;
1079 	}
1080         if( result )
1081                 return( NULL );
1082         return( out );
1083 }
1084 VipsImage *
1085 vips_image_new_matrix( int width, int height )
1086 {
1087 	VipsImage *image;
1088 	vips_check_init();
1089 	image = VIPS_IMAGE( g_object_new( VIPS_TYPE_IMAGE, NULL ) );
1090 	g_object_set( image,
1091 		"filename", "vips_image_new_matrix",
1092 		"mode", "t",
1093 		"width", width,
1094 		"height", height,
1095 		"bands", 1,
1096 		"format", VIPS_FORMAT_DOUBLE,
1097 		"interpretation", VIPS_INTERPRETATION_MATRIX,
1098 		NULL );
1099 	if( vips_object_build( VIPS_OBJECT( image ) ) ) {
1100 		VIPS_UNREF( image );
1101 		return( NULL );
1102 	}
1103 	if( vips_image_write_prepare( image ) ) {
1104 		g_object_unref( image );
1105 		return( NULL );
1106 	}
1107 	return( image );
1108 }
1109 VipsImage *
1110 vips_image_new_matrixv( int width, int height, ... )
1111 {
1112 	va_list ap;
1113 	VipsImage *matrix;
1114 	int x, y;
1115 	vips_check_init();
1116 	matrix = vips_image_new_matrix( width, height ); 
1117 	va_start( ap, height );
1118 	for( y = 0; y &lt; height; y++ )
1119 		for( x = 0; x &lt; width; x++ )
1120 			*VIPS_MATRIX( matrix, x, y ) = va_arg( ap, double );
1121 	va_end( ap );
1122 	return( matrix ); 
1123 }
1124 VipsImage *
1125 vips_image_new_matrix_from_array( int width, int height, 
1126 	const double *array, int size )
1127 {
1128 	VipsImage *matrix;
1129 	int x, y;
1130 	int i;
1131 	if( size != width * height ) {
1132 		vips_error( "VipsImage",
1133 			_( "bad array length --- should be %d, you passed %d" ),
1134 			width * height, size );
1135 		return( NULL );
1136 	}
1137 	vips_check_init();
1138 	matrix = vips_image_new_matrix( width, height ); 
1139 	i = 0;
1140 	for( y = 0; y &lt; height; y++ )
1141 		for( x = 0; x &lt; width; x++ )
1142 			*VIPS_MATRIX( matrix, x, y ) = array[i++];
1143 	return( matrix ); 
1144 }
1145 VipsImage *
1146 vips_image_matrix_from_array( int width, int height, 
1147 	const double *array, int size )
1148 {
1149 	return( vips_image_new_matrix_from_array( width, height, 
1150 		array, size ) ); 
1151 }
1152 VipsImage *
1153 vips_image_new_from_image( VipsImage *image, const double *c, int n )
1154 {
1155 	VipsObject *scope = (VipsObject *) vips_image_new();
1156 	VipsImage **t = (VipsImage **) vips_object_local_array( scope, 5 );
1157 	double *ones;
1158 	int i;
1159 	VipsImage *result;
1160 	if( !(ones = VIPS_ARRAY( scope, n, double )) ) {
1161 		g_object_unref( scope );
1162 		return( NULL );
1163 	}
1164 	for( i = 0; i &lt; n; i++ )
1165 		ones[i] = 1.0;
1166 	if( vips_black( &amp;t[0], 1, 1, NULL ) ||
1167 		vips_linear( t[0], &amp;t[1], ones, (double *) c, n, NULL ) ||
1168 		vips_cast( t[1], &amp;t[2], image-&gt;BandFmt, NULL ) ||
1169 		vips_embed( t[2], &amp;t[3], 0, 0, image-&gt;Xsize, image-&gt;Ysize,
1170 			"extend", VIPS_EXTEND_COPY, NULL ) ||
1171 		vips_copy( t[3], &amp;t[4], 
1172 			"interpretation", image-&gt;Type,
1173 			"xres", image-&gt;Xres,
1174 			"yres", image-&gt;Yres,
1175 			"xoffset", image-&gt;Xoffset,
1176 			"yoffset", image-&gt;Yoffset,
1177 			NULL ) ) {
1178 		g_object_unref( scope );
1179 		return( NULL );
1180 	}
1181 	result = t[4];
1182 	g_object_ref( result );
1183 	g_object_unref( scope );
1184 	return( result ); 
1185 }
1186 VipsImage *
1187 vips_image_new_from_image1( VipsImage *image, double c )
1188 {
1189 	return( vips_image_new_from_image( image, (const double *) &amp;c, 1 ) );
1190 }
1191 void
1192 vips_image_set_delete_on_close( VipsImage *image, gboolean delete_on_close )
1193 {
1194 	VIPS_DEBUG_MSG( "vips_image_set_delete_on_close: %d %s\n", 
1195 			delete_on_close, image-&gt;filename );
1196 	image-&gt;delete_on_close = delete_on_close;
1197 	VIPS_FREE( image-&gt;delete_on_close_filename );
1198 	if( delete_on_close ) 
1199 		VIPS_SETSTR( image-&gt;delete_on_close_filename, image-&gt;filename );
1200 }
1201 guint64
1202 vips_get_disc_threshold( void )
1203 {
1204 	static gboolean done = FALSE;
1205 	static guint64 threshold;
1206 	if( !done ) {
1207 		const char *env;
1208 		done = TRUE;
1209 		threshold = 100 * 1024 * 1024;
1210 		if( (env = g_getenv( "VIPS_DISC_THRESHOLD" ))
1211 #if ENABLE_DEPRECATED
1212 			|| (env = g_getenv( "IM_DISC_THRESHOLD" ))
1213 #endif
1214 		  )
1215 			threshold = vips__parse_size( env );
1216 		if( vips__disc_threshold ) 
1217 			threshold = vips__parse_size( vips__disc_threshold );
1218 #ifdef DEBUG
1219 		printf( "vips_get_disc_threshold: %zd bytes\n", threshold );
1220 	}
1221 	return( threshold );
1222 }
1223 VipsImage *
1224 <font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>vips_image_new_temp_file( const char *format )
1225 {
1226 	char *name;
1227 	VipsImage *image;
1228 	vips_check_init();
1229 	if( !(name = vips__temp_name( format )) )
1230 		return( NULL );
1231 	if( !(image = vips_image_new_mode( name, "w" )) ) {
1232 		g_free( name );
1233 		return( NULL );
1234 	}
1235 	g_free( name );
1236 	vips_image_set_delete_on_close( image, TRUE );
1237 	return( image );
1238 }</b></font>
1239 static int
1240 vips_image_write_gen( VipsRegion *or, 
1241 	void *seq, void *a, void *b, gboolean *stop )
1242 {
1243 	VipsRegion *ir = (VipsRegion *) seq;
1244 	VipsRect *r = &amp;or-&gt;valid;
1245 	if( vips_region_prepare( ir, r ) ||
1246 		vips_region_region( or, ir, r, r-&gt;left, r-&gt;top ) )
1247 		return( -1 );
1248 	return( 0 );
1249 }
1250 int
1251 vips_image_write( VipsImage *image, VipsImage *out )
1252 {
1253 	g_object_ref( image );
1254 	if( vips_image_pio_input( image ) || 
1255 		vips_image_pipelinev( out, 
1256 			VIPS_DEMAND_STYLE_THINSTRIP, image, NULL ) ) {
1257 		g_object_unref( image );
1258 		return( -1 );
1259 	}
1260 	if( vips_image_generate( out,
1261 		vips_start_one, vips_image_write_gen, vips_stop_one, 
1262 		image, NULL ) ) {
1263 		g_object_unref( image );
1264 		return( -1 );
1265 	}
1266 	if( vips_image_ispartial( out ) ) { 
1267 		vips_object_local( out, image );
1268 	}
1269 	else {
1270 		vips__reorder_clear( out );
1271 		vips__link_break_all( out );
1272 		g_object_unref( image );
1273 	}
1274 	return( 0 );
1275 }
1276 int
1277 vips_image_write_to_file( VipsImage *image, const char *name, ... )
1278 {
1279 	char filename[VIPS_PATH_MAX];
1280 	char option_string[VIPS_PATH_MAX];
1281 	const char *operation_name;
1282 	va_list ap;
1283 	int result;
1284 	vips__filename_split8( name, filename, option_string );
1285 	vips_error_freeze();
1286 	operation_name = vips_foreign_find_save_target( filename );
1287 	vips_error_thaw();
1288 	if( operation_name ) {
1289 		VipsTarget *target;
1290 		if( !(target = vips_target_new_to_file( filename )) )
1291 			return( -1 );
1292 		va_start( ap, name );
1293 		result = vips_call_split_option_string( operation_name, 
1294 			option_string, ap, image, target );
1295 		va_end( ap );
1296 		VIPS_UNREF( target );
1297 	}
1298 	else if( (operation_name = vips_foreign_find_save( filename )) ) {
1299 		va_start( ap, name );
1300 		result = vips_call_split_option_string( operation_name, 
1301 			option_string, ap, image, filename );
1302 		va_end( ap );
1303 	}
1304 	else
1305 		return( -1 );
1306 	return( result );
1307 }
1308 int
1309 vips_image_write_to_buffer( VipsImage *in, 
1310 	const char *suffix, void **buf, size_t *size, 
1311 	... )
1312 {
1313 	char filename[VIPS_PATH_MAX];
1314 	char option_string[VIPS_PATH_MAX];
1315 	const char *operation_name;
1316 	VipsBlob *blob;
1317 	va_list ap;
1318 	int result;
1319 	vips__filename_split8( suffix, filename, option_string );
1320 	if( (operation_name = vips_foreign_find_save_target( filename )) ) {
1321 		VipsTarget *target;
1322 		if( !(target = vips_target_new_to_memory()) )
1323 			return( -1 );
1324 		va_start( ap, size );
1325 		result = vips_call_split_option_string( operation_name, 
1326 			option_string, ap, in, target );
1327 		va_end( ap );
1328 		if( result ) {
1329 			VIPS_UNREF( target );
1330 			return( -1 );
1331 		}
1332 		g_object_get( target, "blob", &amp;blob, NULL );
1333 		VIPS_UNREF( target );
1334 	}
1335 	else if( (operation_name = 
1336 		vips_foreign_find_save_buffer( filename )) ) {
1337 		va_start( ap, size );
1338 		result = vips_call_split_option_string( operation_name, 
1339 			option_string, ap, in, &amp;blob );
1340 		va_end( ap );
1341 		if( result )
1342 			return( -1 );
1343 	}
1344 	else
1345 		return( -1 );
1346 	*buf = NULL;
1347 	if( size ) 
1348 		*size = 0;
1349 	if( blob ) { 
1350 		if( buf ) {
1351 			*buf = VIPS_AREA( blob )-&gt;data;
1352 			VIPS_AREA( blob )-&gt;free_fn = NULL;
1353 		}
1354 		if( size ) 
1355 			*size = VIPS_AREA( blob )-&gt;length;
1356 		vips_area_unref( VIPS_AREA( blob ) );
1357 	}
1358 	return( 0 );
1359 }
1360 int
1361 vips_image_write_to_target( VipsImage *in, 
1362 	const char *suffix, VipsTarget *target, ... )
1363 {
1364 	char filename[VIPS_PATH_MAX];
1365 	char option_string[VIPS_PATH_MAX];
1366 	const char *operation_name;
1367 	va_list ap;
1368 	int result;
1369 	vips__filename_split8( suffix, filename, option_string );
1370 	if( !(operation_name = vips_foreign_find_save_target( filename )) )
1371 		return( -1 );
1372 	va_start( ap, target );
1373 	result = vips_call_split_option_string( operation_name, option_string, 
1374 		ap, in, target );
1375 	va_end( ap );
1376 	if( result )
1377 		return( -1 );
1378 	return( 0 );
1379 }
1380 void *
1381 vips_image_write_to_memory( VipsImage *in, size_t *size_out )
1382 {
1383 	void *buf;
1384 	size_t size;
1385 	VipsImage *x;
1386 	size = VIPS_IMAGE_SIZEOF_IMAGE( in );
1387 	if( !(buf = g_try_malloc( size )) ) {
1388 		vips_error( "vips_image_write_to_memory", 
1389 			_( "out of memory --- size == %dMB" ), 
1390 			(int) (size / (1024.0 * 1024.0))  );
1391 		g_warning( _( "out of memory --- size == %dMB" ), 
1392 			(int) (size / (1024.0 * 1024.0))  );
1393 		return( NULL );
1394 	}
1395 	x = vips_image_new_from_memory( buf, size,
1396 		in-&gt;Xsize, in-&gt;Ysize, in-&gt;Bands, in-&gt;BandFmt );
1397 	if( vips_image_write( in, x ) ) {
1398 		g_object_unref( x );
1399 		g_free( buf ); 
1400 		return( NULL ); 
1401 	}
1402 	g_object_unref( x );
1403 	if( size_out )
1404 		*size_out = size;
1405 	return( buf ); 
1406 }
1407 int
1408 vips_image_decode( VipsImage *in, VipsImage **out )
1409 {
1410 	if( in-&gt;Coding == VIPS_CODING_LABQ ) {
1411 		if( vips_LabQ2Lab( in, out, NULL ) )
1412 			return( -1 );
1413 	} 
1414 	else if( in-&gt;Coding == VIPS_CODING_RAD ) {
1415 		if( vips_rad2float( in, out, NULL ) )
1416 			return( -1 );
1417 	}
1418 	else {
1419 		if( vips_copy( in, out, NULL ) )
1420 			return( -1 );
1421 	}
1422 	return( 0 );
1423 }
1424 int
1425 vips_image_decode_predict( VipsImage *in, 
1426 	int *out_bands, VipsBandFormat *out_format )
1427 {
1428 	VipsBandFormat format;
1429 	int bands; 
1430 	if( in-&gt;Coding == VIPS_CODING_LABQ ) {
1431 		bands = 3;
1432 		format = VIPS_FORMAT_FLOAT;
1433 	}
1434 	else if( in-&gt;Coding == VIPS_CODING_RAD ) {
1435 		bands = 3;
1436 		format = VIPS_FORMAT_FLOAT;
1437 	}
1438 	else {
1439 		bands = in-&gt;Bands;
1440 		format = in-&gt;BandFmt;
1441 	}
1442 	if( out_bands )
1443 		*out_bands = bands;
1444 	if( out_format )
1445 		*out_format = format;
1446 	return( 0 );
1447 }
1448 int
1449 vips_image_encode( VipsImage *in, VipsImage **out, VipsCoding coding )
1450 {
1451 	if( coding == VIPS_CODING_LABQ ) {
1452 		if( vips_Lab2LabQ( in, out, NULL ) )
1453 			return( -1 );
1454 	} 
1455 	else if( coding == VIPS_CODING_RAD ) {
1456 		if( vips_float2rad( in, out, NULL ) )
1457 			return( -1 );
1458 	}
1459 	else {
1460 		if( vips_copy( in, out, NULL ) )
1461 			return( -1 );
1462 	}
1463 	return( 0 );
1464 }
1465 gboolean
1466 vips_image_isMSBfirst( VipsImage *image )
1467 {	
1468 	if( image-&gt;magic == VIPS_MAGIC_SPARC )
1469 		return( 1 );
1470 	else
1471 		return( 0 );
1472 }
1473 gboolean 
1474 vips_image_isfile( VipsImage *image )
1475 {
1476 	switch( image-&gt;dtype ) {
1477 	case VIPS_IMAGE_MMAPIN:
1478 	case VIPS_IMAGE_MMAPINRW:
1479 	case VIPS_IMAGE_OPENOUT:
1480 	case VIPS_IMAGE_OPENIN:
1481 		return( 1 );
1482 	case VIPS_IMAGE_PARTIAL:
1483 	case VIPS_IMAGE_SETBUF:
1484 	case VIPS_IMAGE_SETBUF_FOREIGN:
1485 	case VIPS_IMAGE_NONE:
1486 		return( 0 );
1487 	default:
1488 		g_assert( FALSE ); 
1489 		return( 0 );
1490 	}
1491 }
1492 gboolean 
1493 vips_image_ispartial( VipsImage *image )
1494 {
1495 	if( image-&gt;dtype == VIPS_IMAGE_PARTIAL )
1496 		return( 1 );
1497 	else
1498 		return( 0 );
1499 }
1500 gboolean
1501 vips_image_hasalpha( VipsImage *image )
1502 {
1503 	switch( image-&gt;Type ) { 
1504 	case VIPS_INTERPRETATION_B_W:
1505 	case VIPS_INTERPRETATION_GREY16:
1506 		return( image-&gt;Bands &gt; 1 ); 
1507 	case VIPS_INTERPRETATION_RGB:
1508 	case VIPS_INTERPRETATION_CMC:
1509 	case VIPS_INTERPRETATION_LCH:
1510 	case VIPS_INTERPRETATION_LABS:
1511 	case VIPS_INTERPRETATION_sRGB:
1512 	case VIPS_INTERPRETATION_YXY:
1513 	case VIPS_INTERPRETATION_XYZ:
1514 	case VIPS_INTERPRETATION_LAB:
1515 	case VIPS_INTERPRETATION_RGB16:
1516 	case VIPS_INTERPRETATION_scRGB:
1517 	case VIPS_INTERPRETATION_HSV:
1518 		return( image-&gt;Bands &gt; 3 ); 
1519 	case VIPS_INTERPRETATION_CMYK:
1520 		return( image-&gt;Bands &gt; 4 ); 
1521 	default:
1522 		return( FALSE ); 
1523 	}
1524 }
1525 int
1526 vips_image_write_prepare( VipsImage *image )
1527 {
1528 	g_assert( vips_object_sanity( VIPS_OBJECT( image ) ) );
1529 	if( image-&gt;Xsize &lt;= 0 || 
1530 		image-&gt;Ysize &lt;= 0 || 
1531 		image-&gt;Bands &lt;= 0 ) {
1532 		vips_error( "VipsImage", "%s", _( "bad dimensions" ) );
1533 		return( -1 );
1534 	}
1535 	image-&gt;Bbits = vips_format_sizeof( image-&gt;BandFmt ) &lt;&lt; 3;
1536 	if( image-&gt;dtype == VIPS_IMAGE_PARTIAL ) {
1537 		VIPS_DEBUG_MSG( "vips_image_write_prepare: "
1538 			"old-style output for %s\n", image-&gt;filename );
1539 		image-&gt;dtype = VIPS_IMAGE_SETBUF;
1540 	}
1541 	switch( image-&gt;dtype ) {
1542 	case VIPS_IMAGE_MMAPINRW:
1543 	case VIPS_IMAGE_SETBUF_FOREIGN:
1544 		break;
1545 	case VIPS_IMAGE_SETBUF:
1546 		if( !image-&gt;data &amp;&amp; 
1547 			!(image-&gt;data = vips_tracked_malloc( 
1548 				VIPS_IMAGE_SIZEOF_IMAGE( image ))) ) 
1549 			return( -1 );
1550 		break;
1551 	case VIPS_IMAGE_OPENOUT:
1552 		if( vips_image_open_output( image ) )
1553 			return( -1 );
1554 		break;
1555 	default:
1556 		vips_error( "VipsImage", "%s", _( "bad image descriptor" ) );
1557 		return( -1 );
1558 	}
1559 	return( 0 );
1560 }
1561 int
1562 vips_image_write_line( VipsImage *image, int ypos, VipsPel *linebuffer )
1563 {	
1564 	int linesize = VIPS_IMAGE_SIZEOF_LINE( image );
1565 	if( ypos == 0 ) {
1566 		if( vips__image_wio_output( image ) )
1567 			return( -1 );
1568 		vips_image_set_kill( image, FALSE );
1569 		vips_image_write_prepare( image );
1570 		vips_image_preeval( image );
1571 	}
1572 	switch( image-&gt;dtype ) {
1573 	case VIPS_IMAGE_SETBUF:
1574 	case VIPS_IMAGE_SETBUF_FOREIGN:
1575 		memcpy( VIPS_IMAGE_ADDR( image, 0, ypos ), 
1576 			linebuffer, linesize );
1577 		break;
1578 	case VIPS_IMAGE_OPENOUT:
1579 		if( vips__write( image-&gt;fd, linebuffer, linesize ) )
1580 			return( -1 );
1581 		break;
1582 	default:
1583 		vips_error( "VipsImage", 
1584 			_( "unable to output to a %s image" ),
1585 			vips_enum_string( VIPS_TYPE_IMAGE_TYPE, 
1586 				image-&gt;dtype ) );
1587 		return( -1 );
1588 	}
1589 	vips_image_eval( image, ypos * image-&gt;Xsize );
1590 	if( vips_image_iskilled( image ) )
1591 		return( -1 );
1592 	if( ypos == image-&gt;Ysize - 1 ) {
1593 		vips_image_posteval( image );
1594 		if( vips_image_written( image ) )
1595 			return( -1 );
1596 	}
1597 	return( 0 );
1598 }
1599 static int
1600 vips_image_rewind_output( VipsImage *image ) 
1601 {
1602 	int fd;
1603 	g_assert( image-&gt;dtype == VIPS_IMAGE_OPENOUT );
1604 #ifdef DEBUG_IO
1605 	printf( "vips_image_rewind_output: %s\n", image-&gt;filename );
1606 	fd = image-&gt;fd;
1607 	image-&gt;fd = -1;
1608 	vips_object_rewind( VIPS_OBJECT( image ) );
1609 	image-&gt;fd = fd;
1610 	g_object_set( image,
1611 		"mode", "v",
1612 		NULL );
1613 	if( vips_object_build( VIPS_OBJECT( image ) ) ) {
1614 		vips_error( "VipsImage", 
1615 			_( "auto-rewind for %s failed" ),
1616 			image-&gt;filename );
1617 		return( -1 );
1618 	}
1619 	vips_image_delete( image );
1620 	return( 0 );
1621 }
1622 VipsImage *
1623 vips_image_copy_memory( VipsImage *image )
1624 {
1625 	VipsImage *new;
1626 	switch( image-&gt;dtype ) {
1627 	case VIPS_IMAGE_SETBUF:
1628 	case VIPS_IMAGE_SETBUF_FOREIGN:
1629 	case VIPS_IMAGE_MMAPIN:
1630 	case VIPS_IMAGE_MMAPINRW:
1631 		new = image;
1632 		g_object_ref( new );
1633 		break;
1634 	case VIPS_IMAGE_OPENOUT:
1635 	case VIPS_IMAGE_OPENIN:
1636 	case VIPS_IMAGE_PARTIAL:
1637 		new = vips_image_new_memory();
1638 		if( vips_image_write( image, new ) ) {
1639 			g_object_unref( new );
1640 			return( NULL ); 
1641 		}
1642 		break;
1643 	default:
1644 		vips_error( "vips_image_copy_memory", 
1645 			"%s", _( "image not readable" ) );
1646 		return( NULL );
1647 	}
1648 	return( new );
1649 }
1650 int
1651 vips_image_wio_input( VipsImage *image )
1652 {	
1653 	VipsImage *t1;
1654 	g_assert( vips_object_sanity( VIPS_OBJECT( image ) ) );
1655 #ifdef DEBUG_IO
1656 	printf( "vips_image_wio_input: wio input for %s\n", 
1657 		image-&gt;filename );
1658 	switch( image-&gt;dtype ) {
1659 	case VIPS_IMAGE_SETBUF:
1660 	case VIPS_IMAGE_SETBUF_FOREIGN:
1661 		if( !image-&gt;data ) {
1662 			vips_error( "vips_image_wio_input", 
1663 				"%s", _( "no image data" ) );
1664 			return( -1 );
1665 		}
1666 		break;
1667 	case VIPS_IMAGE_MMAPIN:
1668 	case VIPS_IMAGE_MMAPINRW:
1669 		break;
1670 	case VIPS_IMAGE_PARTIAL:
1671 #ifdef DEBUG_IO
1672 		printf( "vips_image_wio_input: "
1673 			"converting partial image to WIO\n" );
1674 		t1 = vips_image_new_memory();
1675 		if( vips_image_write( image, t1 ) ) {
1676 			g_object_unref( t1 );
1677 			return( -1 );
1678 		}
1679 		image-&gt;dtype = VIPS_IMAGE_SETBUF;
1680 		image-&gt;data = t1-&gt;data; 
1681 		t1-&gt;data = NULL;
1682 		g_object_unref( t1 );
1683 		image-&gt;start_fn = NULL;
1684 		image-&gt;generate_fn = NULL;
1685 		image-&gt;stop_fn = NULL;
1686 		image-&gt;client1 = NULL;
1687 		image-&gt;client2 = NULL;
1688 		if( image-&gt;regions ) 
1689 			g_warning( "rewinding image with active regions" ); 
1690 		break;
1691 	case VIPS_IMAGE_OPENIN:
1692 #ifdef DEBUG_IO
1693 		printf( "vips_image_wio_input: "
1694 			"converting openin image for wio input\n" );
1695 		if( vips_mapfile( image ) ) 
1696 			return( -1 );
1697 		image-&gt;data = (VipsPel *) image-&gt;baseaddr + 
1698 			image-&gt;sizeof_header;
1699 		image-&gt;dtype = VIPS_IMAGE_MMAPIN;
1700 		break;
1701 	case VIPS_IMAGE_OPENOUT:
1702 		if( vips_image_rewind_output( image ) ||
1703 			vips_image_wio_input( image ) ) 
1704 			return( -1 );
1705 		break;
1706 	default:
1707 		vips_error( "vips_image_wio_input", 
1708 			"%s", _( "image not readable" ) );
1709 		return( -1 );
1710 	}
1711 	return( 0 );
1712 }
1713 int 
1714 vips__image_wio_output( VipsImage *image )
1715 {
1716 #ifdef DEBUG_IO
1717 	printf( "vips__image_wio_output: WIO output for %s\n", 
1718 		image-&gt;filename );
1719 	switch( image-&gt;dtype ) {
1720 	case VIPS_IMAGE_PARTIAL:
1721 		if( image-&gt;generate_fn ) {
1722 			vips_error( "vips__image_wio_output", 
1723 				"%s", _( "image already written" ) );
1724 			return( -1 );
1725 		}
1726 		image-&gt;dtype = VIPS_IMAGE_SETBUF;
1727 		break;
1728 	case VIPS_IMAGE_SETBUF:
1729 	case VIPS_IMAGE_OPENOUT:
1730 	case VIPS_IMAGE_SETBUF_FOREIGN:
1731 		break;
1732 	default:
1733 		vips_error( "vips__image_wio_output", 
1734 			"%s", _( "image not writeable" ) );
1735 		return( -1 );
1736 	}
1737 	return( 0 );
1738 }
1739 int
1740 vips_image_inplace( VipsImage *image )
1741 {
1742 	if( vips_image_wio_input( image ) ) 
1743 		return( -1 );
1744 	switch( image-&gt;dtype ) {
1745 	case VIPS_IMAGE_SETBUF:
1746 	case VIPS_IMAGE_SETBUF_FOREIGN:
1747 	case VIPS_IMAGE_MMAPINRW:
1748 		break;
1749 	case VIPS_IMAGE_MMAPIN:
1750 		if( vips_remapfilerw( image ) )
1751 			return( -1 );
1752 		break;
1753 	default:
1754 		vips_error( "vips_image_inplace", 
1755 			"%s", _( "bad file type" ) );
1756 		return( -1 );
1757 	}
1758 	vips_image_invalidate_all( image ); 
1759 	return( 0 );
1760 }
1761 int
1762 vips_image_pio_input( VipsImage *image )
1763 {
1764 	g_assert( vips_object_sanity( VIPS_OBJECT( image ) ) );
1765 #ifdef DEBUG_IO
1766 	printf( "vips_image_pio_input: enabling partial input for %s\n", 
1767 		image-&gt;filename );
1768 	switch( image-&gt;dtype ) {
1769 	case VIPS_IMAGE_SETBUF:
1770 	case VIPS_IMAGE_SETBUF_FOREIGN:
1771 		if( !image-&gt;data ) {
1772 			vips_error( "vips_image_pio_input", 
1773 				"%s", _( "no image data" ) );
1774 			return( -1 );
1775 		}
1776 		image-&gt;start_fn = NULL;
1777 		image-&gt;generate_fn = NULL;
1778 		image-&gt;stop_fn = NULL;
1779 		break;
1780 	case VIPS_IMAGE_PARTIAL:
1781 		if( !image-&gt;generate_fn ) {
1782 			vips_error( "vips_image_pio_input", 
1783 				"%s", _( "no image data" ) );
1784 			return( -1 );
1785 		}
1786 		break;
1787 	case VIPS_IMAGE_MMAPIN:
1788 	case VIPS_IMAGE_MMAPINRW:
1789 	case VIPS_IMAGE_OPENIN:
1790 		break;
1791 	case VIPS_IMAGE_OPENOUT:
1792 		if( vips_image_rewind_output( image ) )
1793 			return( -1 );
1794 		break;
1795 	default:
1796 		vips_error( "vips_image_pio_input", 
1797 			"%s", _( "image not readable" ) );
1798 		return( -1 );
1799 	}
1800 	return( 0 );
1801 }
1802 int 
1803 vips_image_pio_output( VipsImage *image )
1804 {
1805 #ifdef DEBUG_IO
1806 	printf( "vips_image_pio_output: enabling partial output for %s\n", 
1807 		image-&gt;filename );
1808 	switch( image-&gt;dtype ) {
1809 	case VIPS_IMAGE_SETBUF:
1810 		if( image-&gt;data ) {
1811 			vips_error( "vips_image_pio_output", 
1812 				"%s", _( "image already written" ) );
1813 			return( -1 );
1814 		}
1815 		break;
1816 	case VIPS_IMAGE_PARTIAL:
1817 		if( image-&gt;generate_fn ) {
1818 			vips_error( "vips_image_pio_output", 
1819 				"%s", _( "image already written" ) );
1820 			return( -1 );
1821 		}
1822 		break;
1823 	case VIPS_IMAGE_OPENOUT:
1824 	case VIPS_IMAGE_SETBUF_FOREIGN:
1825 		break;
1826 	default:
1827 		vips_error( "vips_image_pio_output", 
1828 			"%s", _( "image not writeable" ) );
1829 		return( -1 );
1830 	}
1831 	return( 0 );
1832 }
1833 gboolean
1834 vips_band_format_isint( VipsBandFormat format )
1835 {
1836 	switch( format ) {
1837 	case VIPS_FORMAT_UCHAR:
1838 	case VIPS_FORMAT_CHAR:
1839 	case VIPS_FORMAT_USHORT:
1840 	case VIPS_FORMAT_SHORT:
1841 	case VIPS_FORMAT_UINT:
1842 	case VIPS_FORMAT_INT:
1843 		return( TRUE );
1844 	case VIPS_FORMAT_FLOAT:
1845 	case VIPS_FORMAT_DOUBLE:	
1846 	case VIPS_FORMAT_COMPLEX:
1847 	case VIPS_FORMAT_DPCOMPLEX:	
1848 		return( FALSE );
1849 	default:
1850 		g_assert_not_reached();
1851 		return( FALSE );
1852 	}
1853 }
1854 gboolean
1855 vips_band_format_isuint( VipsBandFormat format )
1856 {
1857 	switch( format ) {
1858 	case VIPS_FORMAT_UCHAR:
1859 	case VIPS_FORMAT_USHORT:
1860 	case VIPS_FORMAT_UINT:
1861 		return( TRUE );
1862 	case VIPS_FORMAT_INT:
1863 	case VIPS_FORMAT_SHORT:
1864 	case VIPS_FORMAT_CHAR:
1865 	case VIPS_FORMAT_FLOAT:
1866 	case VIPS_FORMAT_DOUBLE:	
1867 	case VIPS_FORMAT_COMPLEX:
1868 	case VIPS_FORMAT_DPCOMPLEX:	
1869 		return( FALSE );
1870 	default:
1871 		g_assert_not_reached();
1872 		return( FALSE );
1873 	}
1874 }
1875 gboolean
1876 vips_band_format_is8bit( VipsBandFormat format )
1877 {
1878 	switch( format ) {
1879 	case VIPS_FORMAT_UCHAR:
1880 	case VIPS_FORMAT_CHAR:
1881 		return( TRUE );
1882 	case VIPS_FORMAT_USHORT:
1883 	case VIPS_FORMAT_SHORT:
1884 	case VIPS_FORMAT_UINT:
1885 	case VIPS_FORMAT_INT:
1886 	case VIPS_FORMAT_FLOAT:
1887 	case VIPS_FORMAT_DOUBLE:
1888 	case VIPS_FORMAT_COMPLEX:
1889 	case VIPS_FORMAT_DPCOMPLEX:
1890 		return( FALSE );
1891 	default:
1892 		g_assert_not_reached();
1893 		return( FALSE );
1894 	}
1895 }
1896 gboolean
1897 vips_band_format_isfloat( VipsBandFormat format )
1898 {
1899 	switch( format ) {
1900 	case VIPS_FORMAT_FLOAT:
1901 	case VIPS_FORMAT_DOUBLE:	
1902 		return( TRUE );
1903 	case VIPS_FORMAT_UCHAR:
1904 	case VIPS_FORMAT_CHAR:
1905 	case VIPS_FORMAT_USHORT:
1906 	case VIPS_FORMAT_SHORT:
1907 	case VIPS_FORMAT_UINT:
1908 	case VIPS_FORMAT_INT:
1909 	case VIPS_FORMAT_COMPLEX:
1910 	case VIPS_FORMAT_DPCOMPLEX:	
1911 		return( FALSE );
1912 	default:
1913 		g_assert_not_reached();
1914 		return( FALSE );
1915 	}
1916 }
1917 gboolean
1918 vips_band_format_iscomplex( VipsBandFormat format )
1919 {
1920 	switch( format ) {
1921 	case VIPS_FORMAT_COMPLEX:
1922 	case VIPS_FORMAT_DPCOMPLEX:	
1923 		return( TRUE );
1924 	case VIPS_FORMAT_UCHAR:
1925 	case VIPS_FORMAT_CHAR:
1926 	case VIPS_FORMAT_USHORT:
1927 	case VIPS_FORMAT_SHORT:
1928 	case VIPS_FORMAT_UINT:
1929 	case VIPS_FORMAT_INT:
1930 	case VIPS_FORMAT_FLOAT:
1931 	case VIPS_FORMAT_DOUBLE:	
1932 		return( FALSE );
1933 	default:
1934 		g_assert_not_reached();
1935 		return( FALSE );
1936 	}
1937 }
1938 void
1939 vips_image_free_buffer( VipsImage *image, void *buffer )
1940 {
1941 	free( buffer );
1942 }
1943 int
1944 vips__view_image( VipsImage *image )
1945 {
1946 	VipsArrayImage *array; 
1947 	int result;
1948 	array = vips_array_image_new( &amp;image, 1 );
1949 	result = vips_system( "nip2 %s", 
1950 		"in", array, 
1951 		"in-format", "%s.v", 
1952 		NULL ); 
1953 	vips_area_unref( VIPS_AREA( array ) );
1954 	return( result ); 
1955 }
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
