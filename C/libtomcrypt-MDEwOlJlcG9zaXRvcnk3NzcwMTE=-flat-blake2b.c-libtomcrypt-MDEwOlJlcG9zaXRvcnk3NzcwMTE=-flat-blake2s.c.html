
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 15, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>libtomcrypt-MDEwOlJlcG9zaXRvcnk3NzcwMTE=-flat-blake2b.c</h3>
            <pre><code>1  #include "tomcrypt_private.h"
2  #ifdef LTC_BLAKE2B
3  enum blake2b_constant {
4     BLAKE2B_BLOCKBYTES = 128,
5     BLAKE2B_OUTBYTES = 64,
6     BLAKE2B_KEYBYTES = 64,
7     BLAKE2B_SALTBYTES = 16,
8     BLAKE2B_PERSONALBYTES = 16,
9     BLAKE2B_PARAM_SIZE = 64
10  };
11  enum {
12     O_DIGEST_LENGTH = 0,
13     O_KEY_LENGTH = 1,
14     O_FANOUT = 2,
15     O_DEPTH = 3,
16     O_LEAF_LENGTH = 4,
17     O_NODE_OFFSET = 8,
18     O_XOF_LENGTH = 12,
19     O_NODE_DEPTH = 16,
20     O_INNER_LENGTH = 17,
21     O_RESERVED = 18,
22     O_SALT = 32,
23     O_PERSONAL = 48
24  };
25  const struct ltc_hash_descriptor blake2b_160_desc =
26  {
27      "blake2b-160",
28      25,
29      20,
30      128,
31      { 1, 3, 6, 1, 4, 1, 1722, 12, 2, 1, 5 },
32      11,
33      &blake2b_160_init,
34      &blake2b_process,
35      &blake2b_done,
36      &blake2b_160_test,
37      NULL
38  };
39  const struct ltc_hash_descriptor blake2b_256_desc =
40  {
41      "blake2b-256",
42      26,
43      32,
44      128,
45      { 1, 3, 6, 1, 4, 1, 1722, 12, 2, 1, 8 },
46      11,
47      &blake2b_256_init,
48      &blake2b_process,
49      &blake2b_done,
50      &blake2b_256_test,
51      NULL
52  };
53  const struct ltc_hash_descriptor blake2b_384_desc =
54  {
55      "blake2b-384",
56      27,
57      48,
58      128,
59      { 1, 3, 6, 1, 4, 1, 1722, 12, 2, 1, 12 },
60      11,
61      &blake2b_384_init,
62      &blake2b_process,
63      &blake2b_done,
64      &blake2b_384_test,
65      NULL
66  };
67  const struct ltc_hash_descriptor blake2b_512_desc =
68  {
69      "blake2b-512",
70      28,
71      64,
72      128,
73      { 1, 3, 6, 1, 4, 1, 1722, 12, 2, 1, 16 },
74      11,
75      &blake2b_512_init,
76      &blake2b_process,
77      &blake2b_done,
78      &blake2b_512_test,
79      NULL
80  };
81  static const ulong64 blake2b_IV[8] =
82  {
83    CONST64(0x6a09e667f3bcc908), CONST64(0xbb67ae8584caa73b),
84    CONST64(0x3c6ef372fe94f82b), CONST64(0xa54ff53a5f1d36f1),
85    CONST64(0x510e527fade682d1), CONST64(0x9b05688c2b3e6c1f),
86    CONST64(0x1f83d9abfb41bd6b), CONST64(0x5be0cd19137e2179)
87  };
88  static const unsigned char blake2b_sigma[12][16] =
89  {
90    {  0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15 } ,
91    { 14, 10,  4,  8,  9, 15, 13,  6,  1, 12,  0,  2, 11,  7,  5,  3 } ,
92    { 11,  8, 12,  0,  5,  2, 15, 13, 10, 14,  3,  6,  7,  1,  9,  4 } ,
93    {  7,  9,  3,  1, 13, 12, 11, 14,  2,  6,  5, 10,  4,  0, 15,  8 } ,
94    {  9,  0,  5,  7,  2,  4, 10, 15, 14,  1, 11, 12,  6,  8,  3, 13 } ,
95    {  2, 12,  6, 10,  0, 11,  8,  3,  4, 13,  7,  5, 15, 14,  1,  9 } ,
96    { 12,  5,  1, 15, 14, 13,  4, 10,  0,  7,  6,  3,  9,  2,  8, 11 } ,
97    { 13, 11,  7, 14, 12,  1,  3,  9,  5,  0, 15,  4,  8,  6,  2, 10 } ,
98    {  6, 15, 14,  9, 11,  3,  0,  8, 12,  2, 13,  7,  1,  4, 10,  5 } ,
99    { 10,  2,  8,  4,  7,  6,  1,  5, 15, 11,  9, 14,  3, 12, 13 , 0 } ,
100    {  0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15 } ,
101    { 14, 10,  4,  8,  9, 15, 13,  6,  1, 12,  0,  2, 11,  7,  5,  3 }
102  };
103  static void s_blake2b_set_lastnode(hash_state *md) { md->blake2b.f[1] = CONST64(0xffffffffffffffff); }
104  static int s_blake2b_is_lastblock(const hash_state *md) { return md->blake2b.f[0] != 0; }
105  static void s_blake2b_set_lastblock(hash_state *md)
106  {
107     if (md->blake2b.last_node) {
108        s_blake2b_set_lastnode(md);
109     }
110     md->blake2b.f[0] = CONST64(0xffffffffffffffff);
111  }
112  static void s_blake2b_increment_counter(hash_state *md, ulong64 inc)
113  {
114     md->blake2b.t[0] += inc;
115     if (md->blake2b.t[0] < inc) md->blake2b.t[1]++;
116  }
117  static void s_blake2b_init0(hash_state *md)
118  {
119     unsigned long i;
120     XMEMSET(&md->blake2b, 0, sizeof(md->blake2b));
121     for (i = 0; i < 8; ++i) {
<span onclick='openModal()' class='match'>122        md->blake2b.h[i] = blake2b_IV[i];
123     }
124  }
</span>125  static int s_blake2b_init_param(hash_state *md, const unsigned char *P)
126  {
127     unsigned long i;
128     s_blake2b_init0(md);
129     for (i = 0; i < 8; ++i) {
130        ulong64 tmp;
131        LOAD64L(tmp, P + i * 8);
132        md->blake2b.h[i] ^= tmp;
133     }
134     md->blake2b.outlen = P[O_DIGEST_LENGTH];
135     return CRYPT_OK;
136  }
137  int blake2b_init(hash_state *md, unsigned long outlen, const unsigned char *key, unsigned long keylen)
138  {
139     unsigned char P[BLAKE2B_PARAM_SIZE];
140     int err;
141     LTC_ARGCHK(md != NULL);
142     if ((!outlen) || (outlen > BLAKE2B_OUTBYTES)) {
143        return CRYPT_INVALID_ARG;
144     }
145     if ((key && !keylen) || (keylen && !key) || (keylen > BLAKE2B_KEYBYTES)) {
146        return CRYPT_INVALID_ARG;
147     }
148     XMEMSET(P, 0, sizeof(P));
149     P[O_DIGEST_LENGTH] = (unsigned char)outlen;
150     P[O_KEY_LENGTH] = (unsigned char)keylen;
151     P[O_FANOUT] = 1;
152     P[O_DEPTH] = 1;
153     err = s_blake2b_init_param(md, P);
154     if (err != CRYPT_OK) return err;
155     if (key) {
156        unsigned char block[BLAKE2B_BLOCKBYTES];
157        XMEMSET(block, 0, BLAKE2B_BLOCKBYTES);
158        XMEMCPY(block, key, keylen);
159        blake2b_process(md, block, BLAKE2B_BLOCKBYTES);
160  #ifdef LTC_CLEAN_STACK
161        zeromem(block, sizeof(block));
162  #endif
163     }
164     return CRYPT_OK;
165  }
166  int blake2b_160_init(hash_state *md) { return blake2b_init(md, 20, NULL, 0); }
167  int blake2b_256_init(hash_state *md) { return blake2b_init(md, 32, NULL, 0); }
168  int blake2b_384_init(hash_state *md) { return blake2b_init(md, 48, NULL, 0); }
169  int blake2b_512_init(hash_state *md) { return blake2b_init(md, 64, NULL, 0); }
170  #define G(r, i, a, b, c, d)                                                                                            \
171     do {                                                                                                                \
172        a = a + b + m[blake2b_sigma[r][2 * i + 0]];                                                                      \
173        d = ROR64(d ^ a, 32);                                                                                            \
174        c = c + d;                                                                                                       \
175        b = ROR64(b ^ c, 24);                                                                                            \
176        a = a + b + m[blake2b_sigma[r][2 * i + 1]];                                                                      \
177        d = ROR64(d ^ a, 16);                                                                                            \
178        c = c + d;                                                                                                       \
179        b = ROR64(b ^ c, 63);                                                                                            \
180     } while (0)
181  #define ROUND(r)                                                                                                       \
182     do {                                                                                                                \
183        G(r, 0, v[0], v[4], v[8], v[12]);                                                                                \
184        G(r, 1, v[1], v[5], v[9], v[13]);                                                                                \
185        G(r, 2, v[2], v[6], v[10], v[14]);                                                                               \
186        G(r, 3, v[3], v[7], v[11], v[15]);                                                                               \
187        G(r, 4, v[0], v[5], v[10], v[15]);                                                                               \
188        G(r, 5, v[1], v[6], v[11], v[12]);                                                                               \
189        G(r, 6, v[2], v[7], v[8], v[13]);                                                                                \
190        G(r, 7, v[3], v[4], v[9], v[14]);                                                                                \
191     } while (0)
192  #ifdef LTC_CLEAN_STACK
193  static int ss_blake2b_compress(hash_state *md, const unsigned char *buf)
194  #else
195  static int s_blake2b_compress(hash_state *md, const unsigned char *buf)
196  #endif
197  {
198     ulong64 m[16];
199     ulong64 v[16];
200     unsigned long i;
201     for (i = 0; i < 16; ++i) {
202        LOAD64L(m[i], buf + i * sizeof(m[i]));
203     }
204     for (i = 0; i < 8; ++i) {
205        v[i] = md->blake2b.h[i];
206     }
207     v[8] = blake2b_IV[0];
208     v[9] = blake2b_IV[1];
209     v[10] = blake2b_IV[2];
210     v[11] = blake2b_IV[3];
211     v[12] = blake2b_IV[4] ^ md->blake2b.t[0];
212     v[13] = blake2b_IV[5] ^ md->blake2b.t[1];
213     v[14] = blake2b_IV[6] ^ md->blake2b.f[0];
214     v[15] = blake2b_IV[7] ^ md->blake2b.f[1];
215     ROUND(0);
216     ROUND(1);
217     ROUND(2);
218     ROUND(3);
219     ROUND(4);
220     ROUND(5);
221     ROUND(6);
222     ROUND(7);
223     ROUND(8);
224     ROUND(9);
225     ROUND(10);
226     ROUND(11);
227     for (i = 0; i < 8; ++i) {
228        md->blake2b.h[i] = md->blake2b.h[i] ^ v[i] ^ v[i + 8];
229     }
230     return CRYPT_OK;
231  }
232  #undef G
233  #undef ROUND
234  #ifdef LTC_CLEAN_STACK
235  static int s_blake2b_compress(hash_state *md, const unsigned char *buf)
236  {
237     int err;
238     err = ss_blake2b_compress(md, buf);
239     burn_stack(sizeof(ulong64) * 32 + sizeof(unsigned long));
240     return err;
241  }
242  #endif
243  int blake2b_process(hash_state *md, const unsigned char *in, unsigned long inlen)
244  {
245     LTC_ARGCHK(md != NULL);
246     LTC_ARGCHK(in != NULL);
247     if (md->blake2b.curlen > sizeof(md->blake2b.buf)) {
248        return CRYPT_INVALID_ARG;
249     }
250     if (inlen > 0) {
251        unsigned long left = md->blake2b.curlen;
252        unsigned long fill = BLAKE2B_BLOCKBYTES - left;
253        if (inlen > fill) {
254           md->blake2b.curlen = 0;
255           XMEMCPY(md->blake2b.buf + (left % sizeof(md->blake2b.buf)), in, fill); &bsol;* Fill buffer */
256           s_blake2b_increment_counter(md, BLAKE2B_BLOCKBYTES);
257           s_blake2b_compress(md, md->blake2b.buf); &bsol;* Compress */
258           in += fill;
259           inlen -= fill;
260           while (inlen > BLAKE2B_BLOCKBYTES) {
261              s_blake2b_increment_counter(md, BLAKE2B_BLOCKBYTES);
262              s_blake2b_compress(md, in);
263              in += BLAKE2B_BLOCKBYTES;
264              inlen -= BLAKE2B_BLOCKBYTES;
265           }
266        }
267        XMEMCPY(md->blake2b.buf + md->blake2b.curlen, in, inlen);
268        md->blake2b.curlen += inlen;
269     }
270     return CRYPT_OK;
271  }
272  int blake2b_done(hash_state *md, unsigned char *out)
273  {
274     unsigned char buffer[BLAKE2B_OUTBYTES] = { 0 };
275     unsigned long i;
276     LTC_ARGCHK(md != NULL);
277     LTC_ARGCHK(out != NULL);
278     if (s_blake2b_is_lastblock(md)) {
279        return CRYPT_ERROR;
280     }
281     s_blake2b_increment_counter(md, md->blake2b.curlen);
282     s_blake2b_set_lastblock(md);
283     XMEMSET(md->blake2b.buf + md->blake2b.curlen, 0, BLAKE2B_BLOCKBYTES - md->blake2b.curlen); &bsol;* Padding */
284     s_blake2b_compress(md, md->blake2b.buf);
285     for (i = 0; i < 8; ++i) { &bsol;* Output full hash to temp buffer */
286        STORE64L(md->blake2b.h[i], buffer + i * 8);
287     }
288     XMEMCPY(out, buffer, md->blake2b.outlen);
289     zeromem(md, sizeof(hash_state));
290  #ifdef LTC_CLEAN_STACK
291     zeromem(buffer, sizeof(buffer));
292  #endif
293     return CRYPT_OK;
294  }
295  int blake2b_512_test(void)
296  {
297  #ifndef LTC_TEST
298     return CRYPT_NOP;
299  #else
300     static const struct {
301        const char *msg;
302        unsigned char hash[64];
303    } tests[] = {
304      { "",
305        { 0x78, 0x6a, 0x02, 0xf7, 0x42, 0x01, 0x59, 0x03,
306          0xc6, 0xc6, 0xfd, 0x85, 0x25, 0x52, 0xd2, 0x72,
307          0x91, 0x2f, 0x47, 0x40, 0xe1, 0x58, 0x47, 0x61,
308          0x8a, 0x86, 0xe2, 0x17, 0xf7, 0x1f, 0x54, 0x19,
309          0xd2, 0x5e, 0x10, 0x31, 0xaf, 0xee, 0x58, 0x53,
310          0x13, 0x89, 0x64, 0x44, 0x93, 0x4e, 0xb0, 0x4b,
311          0x90, 0x3a, 0x68, 0x5b, 0x14, 0x48, 0xb7, 0x55,
312          0xd5, 0x6f, 0x70, 0x1a, 0xfe, 0x9b, 0xe2, 0xce } },
313      { "abc",
314        { 0xba, 0x80, 0xa5, 0x3f, 0x98, 0x1c, 0x4d, 0x0d,
315          0x6a, 0x27, 0x97, 0xb6, 0x9f, 0x12, 0xf6, 0xe9,
316          0x4c, 0x21, 0x2f, 0x14, 0x68, 0x5a, 0xc4, 0xb7,
317          0x4b, 0x12, 0xbb, 0x6f, 0xdb, 0xff, 0xa2, 0xd1,
318          0x7d, 0x87, 0xc5, 0x39, 0x2a, 0xab, 0x79, 0x2d,
319          0xc2, 0x52, 0xd5, 0xde, 0x45, 0x33, 0xcc, 0x95,
320          0x18, 0xd3, 0x8a, 0xa8, 0xdb, 0xf1, 0x92, 0x5a,
321          0xb9, 0x23, 0x86, 0xed, 0xd4, 0x00, 0x99, 0x23 } },
322      { NULL, { 0 } }
323    };
324     int i;
325     unsigned char tmp[64];
326     hash_state md;
327     for (i = 0; tests[i].msg != NULL; i++) {
328        blake2b_512_init(&md);
329        blake2b_process(&md, (unsigned char *)tests[i].msg, (unsigned long)XSTRLEN(tests[i].msg));
330        blake2b_done(&md, tmp);
331        if (compare_testvector(tmp, sizeof(tmp), tests[i].hash, sizeof(tests[i].hash), "BLAKE2B_512", i)) {
332           return CRYPT_FAIL_TESTVECTOR;
333        }
334     }
335     return CRYPT_OK;
336  #endif
337  }
338  int blake2b_384_test(void)
339  {
340  #ifndef LTC_TEST
341     return CRYPT_NOP;
342  #else
343     static const struct {
344        const char *msg;
345        unsigned char hash[48];
346    } tests[] = {
347      { "",
348        { 0xb3, 0x28, 0x11, 0x42, 0x33, 0x77, 0xf5, 0x2d,
349          0x78, 0x62, 0x28, 0x6e, 0xe1, 0xa7, 0x2e, 0xe5,
350          0x40, 0x52, 0x43, 0x80, 0xfd, 0xa1, 0x72, 0x4a,
351          0x6f, 0x25, 0xd7, 0x97, 0x8c, 0x6f, 0xd3, 0x24,
352          0x4a, 0x6c, 0xaf, 0x04, 0x98, 0x81, 0x26, 0x73,
353          0xc5, 0xe0, 0x5e, 0xf5, 0x83, 0x82, 0x51, 0x00 } },
354      { "abc",
355        { 0x6f, 0x56, 0xa8, 0x2c, 0x8e, 0x7e, 0xf5, 0x26,
356          0xdf, 0xe1, 0x82, 0xeb, 0x52, 0x12, 0xf7, 0xdb,
357          0x9d, 0xf1, 0x31, 0x7e, 0x57, 0x81, 0x5d, 0xbd,
358          0xa4, 0x60, 0x83, 0xfc, 0x30, 0xf5, 0x4e, 0xe6,
359          0xc6, 0x6b, 0xa8, 0x3b, 0xe6, 0x4b, 0x30, 0x2d,
360          0x7c, 0xba, 0x6c, 0xe1, 0x5b, 0xb5, 0x56, 0xf4 } },
361      { NULL, { 0 } }
362    };
363     int i;
364     unsigned char tmp[48];
365     hash_state md;
366     for (i = 0; tests[i].msg != NULL; i++) {
367        blake2b_384_init(&md);
368        blake2b_process(&md, (unsigned char *)tests[i].msg, (unsigned long)XSTRLEN(tests[i].msg));
369        blake2b_done(&md, tmp);
370        if (compare_testvector(tmp, sizeof(tmp), tests[i].hash, sizeof(tests[i].hash), "BLAKE2B_384", i)) {
371           return CRYPT_FAIL_TESTVECTOR;
372        }
373     }
374     return CRYPT_OK;
375  #endif
376  }
377  int blake2b_256_test(void)
378  {
379  #ifndef LTC_TEST
380     return CRYPT_NOP;
381  #else
382     static const struct {
383        const char *msg;
384        unsigned char hash[32];
385    } tests[] = {
386      { "",
387        { 0x0e, 0x57, 0x51, 0xc0, 0x26, 0xe5, 0x43, 0xb2,
388          0xe8, 0xab, 0x2e, 0xb0, 0x60, 0x99, 0xda, 0xa1,
389          0xd1, 0xe5, 0xdf, 0x47, 0x77, 0x8f, 0x77, 0x87,
390          0xfa, 0xab, 0x45, 0xcd, 0xf1, 0x2f, 0xe3, 0xa8 } },
391      { "abc",
392        { 0xbd, 0xdd, 0x81, 0x3c, 0x63, 0x42, 0x39, 0x72,
393          0x31, 0x71, 0xef, 0x3f, 0xee, 0x98, 0x57, 0x9b,
394          0x94, 0x96, 0x4e, 0x3b, 0xb1, 0xcb, 0x3e, 0x42,
395          0x72, 0x62, 0xc8, 0xc0, 0x68, 0xd5, 0x23, 0x19 } },
396      { "12345678901234567890123456789012345678901234567890"
397        "12345678901234567890123456789012345678901234567890"
398        "12345678901234567890123456789012345678901234567890"
399        "12345678901234567890123456789012345678901234567890"
400        "12345678901234567890123456789012345678901234567890"
401        "12345678901234567890123456789012345678901234567890",
402        { 0x0f, 0x6e, 0x01, 0x8d, 0x38, 0xd6, 0x3f, 0x08,
403          0x4d, 0x58, 0xe3, 0x0c, 0x90, 0xfb, 0xa2, 0x41,
404          0x5f, 0xca, 0x17, 0xfa, 0x66, 0x26, 0x49, 0xf3,
405          0x8a, 0x30, 0x41, 0x7c, 0x57, 0xcd, 0xa8, 0x14 } },
406      { NULL, { 0 } }
407    };
408     int i;
409     unsigned char tmp[32];
410     hash_state md;
411     for (i = 0; tests[i].msg != NULL; i++) {
412        blake2b_256_init(&md);
413        blake2b_process(&md, (unsigned char *)tests[i].msg, (unsigned long)XSTRLEN(tests[i].msg));
414        blake2b_done(&md, tmp);
415        if (compare_testvector(tmp, sizeof(tmp), tests[i].hash, sizeof(tests[i].hash), "BLAKE2B_256", i)) {
416           return CRYPT_FAIL_TESTVECTOR;
417        }
418     }
419     return CRYPT_OK;
420  #endif
421  }
422  int blake2b_160_test(void)
423  {
424  #ifndef LTC_TEST
425     return CRYPT_NOP;
426  #else
427     static const struct {
428        const char *msg;
429        unsigned char hash[20];
430    } tests[] = {
431      { "",
432        { 0x33, 0x45, 0x52, 0x4a, 0xbf, 0x6b, 0xbe, 0x18,
433          0x09, 0x44, 0x92, 0x24, 0xb5, 0x97, 0x2c, 0x41,
434          0x79, 0x0b, 0x6c, 0xf2 } },
435      { "abc",
436        { 0x38, 0x42, 0x64, 0xf6, 0x76, 0xf3, 0x95, 0x36,
437          0x84, 0x05, 0x23, 0xf2, 0x84, 0x92, 0x1c, 0xdc,
438          0x68, 0xb6, 0x84, 0x6b } },
439      { NULL, { 0 } }
440    };
441     int i;
442     unsigned char tmp[20];
443     hash_state md;
444     for (i = 0; tests[i].msg != NULL; i++) {
445        blake2b_160_init(&md);
446        blake2b_process(&md, (unsigned char *)tests[i].msg, (unsigned long)XSTRLEN(tests[i].msg));
447        blake2b_done(&md, tmp);
448        if (compare_testvector(tmp, sizeof(tmp), tests[i].hash, sizeof(tests[i].hash), "BLAKE2B_160", i)) {
449           return CRYPT_FAIL_TESTVECTOR;
450        }
451     }
452     return CRYPT_OK;
453  #endif
454  }
455  #endif
</code></pre>
        </div>
        <div class="column">
            <h3>libtomcrypt-MDEwOlJlcG9zaXRvcnk3NzcwMTE=-flat-blake2s.c</h3>
            <pre><code>1  #include "tomcrypt_private.h"
2  #ifdef LTC_BLAKE2S
3  enum blake2s_constant {
4     BLAKE2S_BLOCKBYTES = 64,
5     BLAKE2S_OUTBYTES = 32,
6     BLAKE2S_KEYBYTES = 32,
7     BLAKE2S_SALTBYTES = 8,
8     BLAKE2S_PERSONALBYTES = 8,
9     BLAKE2S_PARAM_SIZE = 32
10  };
11  enum {
12     O_DIGEST_LENGTH = 0,
13     O_KEY_LENGTH = 1,
14     O_FANOUT = 2,
15     O_DEPTH = 3,
16     O_LEAF_LENGTH = 4,
17     O_NODE_OFFSET = 8,
18     O_XOF_LENGTH = 12,
19     O_NODE_DEPTH = 14,
20     O_INNER_LENGTH = 15,
21     O_SALT = 16,
22     O_PERSONAL = 24
23  };
24  const struct ltc_hash_descriptor blake2s_128_desc =
25  {
26      "blake2s-128",
27      21,
28      16,
29      64,
30      { 1, 3, 6, 1, 4, 1, 1722, 12, 2, 2, 4 },
31      11,
32      &blake2s_128_init,
33      &blake2s_process,
34      &blake2s_done,
35      &blake2s_128_test,
36      NULL
37  };
38  const struct ltc_hash_descriptor blake2s_160_desc =
39  {
40      "blake2s-160",
41      22,
42      20,
43      64,
44      { 1, 3, 6, 1, 4, 1, 1722, 12, 2, 2, 5 },
45      11,
46      &blake2s_160_init,
47      &blake2s_process,
48      &blake2s_done,
49      &blake2s_160_test,
50      NULL
51  };
52  const struct ltc_hash_descriptor blake2s_224_desc =
53  {
54      "blake2s-224",
55      23,
56      28,
57      64,
58      { 1, 3, 6, 1, 4, 1, 1722, 12, 2, 2, 7 },
59      11,
60      &blake2s_224_init,
61      &blake2s_process,
62      &blake2s_done,
63      &blake2s_224_test,
64      NULL
65  };
66  const struct ltc_hash_descriptor blake2s_256_desc =
67  {
68      "blake2s-256",
69      24,
70      32,
71      64,
72      { 1, 3, 6, 1, 4, 1, 1722, 12, 2, 2, 8 },
73      11,
74      &blake2s_256_init,
75      &blake2s_process,
76      &blake2s_done,
77      &blake2s_256_test,
78      NULL
79  };
80  static const ulong32 blake2s_IV[8] = {
81      0x6A09E667UL, 0xBB67AE85UL, 0x3C6EF372UL, 0xA54FF53AUL,
82      0x510E527FUL, 0x9B05688CUL, 0x1F83D9ABUL, 0x5BE0CD19UL
83  };
84  static const unsigned char blake2s_sigma[10][16] = {
85      { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15 },
86      { 14, 10, 4, 8, 9, 15, 13, 6, 1, 12, 0, 2, 11, 7, 5, 3 },
87      { 11, 8, 12, 0, 5, 2, 15, 13, 10, 14, 3, 6, 7, 1, 9, 4 },
88      { 7, 9, 3, 1, 13, 12, 11, 14, 2, 6, 5, 10, 4, 0, 15, 8 },
89      { 9, 0, 5, 7, 2, 4, 10, 15, 14, 1, 11, 12, 6, 8, 3, 13 },
90      { 2, 12, 6, 10, 0, 11, 8, 3, 4, 13, 7, 5, 15, 14, 1, 9 },
91      { 12, 5, 1, 15, 14, 13, 4, 10, 0, 7, 6, 3, 9, 2, 8, 11 },
92      { 13, 11, 7, 14, 12, 1, 3, 9, 5, 0, 15, 4, 8, 6, 2, 10 },
93      { 6, 15, 14, 9, 11, 3, 0, 8, 12, 2, 13, 7, 1, 4, 10, 5 },
94      { 10, 2, 8, 4, 7, 6, 1, 5, 15, 11, 9, 14, 3, 12, 13, 0 },
95  };
96  static void s_blake2s_set_lastnode(hash_state *md) { md->blake2s.f[1] = 0xffffffffUL; }
97  static int s_blake2s_is_lastblock(const hash_state *md) { return md->blake2s.f[0] != 0; }
98  static void s_blake2s_set_lastblock(hash_state *md)
99  {
100     if (md->blake2s.last_node) {
101        s_blake2s_set_lastnode(md);
102     }
103     md->blake2s.f[0] = 0xffffffffUL;
104  }
105  static void s_blake2s_increment_counter(hash_state *md, const ulong32 inc)
106  {
107     md->blake2s.t[0] += inc;
108     if (md->blake2s.t[0] < inc) md->blake2s.t[1]++;
109  }
110  static int s_blake2s_init0(hash_state *md)
111  {
112     int i;
113     XMEMSET(&md->blake2s, 0, sizeof(struct blake2s_state));
114     for (i = 0; i < 8; ++i) {
<span onclick='openModal()' class='match'>115        md->blake2s.h[i] = blake2s_IV[i];
116     }
117     return CRYPT_OK;
</span>118  }
119  static int s_blake2s_init_param(hash_state *md, const unsigned char *P)
120  {
121     unsigned long i;
122     s_blake2s_init0(md);
123     for (i = 0; i < 8; ++i) {
124        ulong32 tmp;
125        LOAD32L(tmp, P + i * 4);
126        md->blake2s.h[i] ^= tmp;
127     }
128     md->blake2s.outlen = P[O_DIGEST_LENGTH];
129     return CRYPT_OK;
130  }
131  int blake2s_init(hash_state *md, unsigned long outlen, const unsigned char *key, unsigned long keylen)
132  {
133     unsigned char P[BLAKE2S_PARAM_SIZE];
134     int err;
135     LTC_ARGCHK(md != NULL);
136     if ((!outlen) || (outlen > BLAKE2S_OUTBYTES)) {
137        return CRYPT_INVALID_ARG;
138     }
139     if ((key && !keylen) || (keylen && !key) || (keylen > BLAKE2S_KEYBYTES)) {
140        return CRYPT_INVALID_ARG;
141     }
142     XMEMSET(P, 0, sizeof(P));
143     P[O_DIGEST_LENGTH] = (unsigned char)outlen;
144     P[O_KEY_LENGTH] = (unsigned char)keylen;
145     P[O_FANOUT] = 1;
146     P[O_DEPTH] = 1;
147     err = s_blake2s_init_param(md, P);
148     if (err != CRYPT_OK) return err;
149     if (key) {
150        unsigned char block[BLAKE2S_BLOCKBYTES];
151        XMEMSET(block, 0, BLAKE2S_BLOCKBYTES);
152        XMEMCPY(block, key, keylen);
153        blake2s_process(md, block, BLAKE2S_BLOCKBYTES);
154  #ifdef LTC_CLEAN_STACK
155        zeromem(block, sizeof(block));
156  #endif
157     }
158     return CRYPT_OK;
159  }
160  int blake2s_128_init(hash_state *md) { return blake2s_init(md, 16, NULL, 0); }
161  int blake2s_160_init(hash_state *md) { return blake2s_init(md, 20, NULL, 0); }
162  int blake2s_224_init(hash_state *md) { return blake2s_init(md, 28, NULL, 0); }
163  int blake2s_256_init(hash_state *md) { return blake2s_init(md, 32, NULL, 0); }
164  #define G(r, i, a, b, c, d)                                                                                            \
165     do {                                                                                                                \
166        a = a + b + m[blake2s_sigma[r][2 * i + 0]];                                                                      \
167        d = ROR(d ^ a, 16);                                                                                              \
168        c = c + d;                                                                                                       \
169        b = ROR(b ^ c, 12);                                                                                              \
170        a = a + b + m[blake2s_sigma[r][2 * i + 1]];                                                                      \
171        d = ROR(d ^ a, 8);                                                                                               \
172        c = c + d;                                                                                                       \
173        b = ROR(b ^ c, 7);                                                                                               \
174     } while (0)
175  #define ROUND(r)                                                                                                       \
176     do {                                                                                                                \
177        G(r, 0, v[0], v[4], v[8], v[12]);                                                                                \
178        G(r, 1, v[1], v[5], v[9], v[13]);                                                                                \
179        G(r, 2, v[2], v[6], v[10], v[14]);                                                                               \
180        G(r, 3, v[3], v[7], v[11], v[15]);                                                                               \
181        G(r, 4, v[0], v[5], v[10], v[15]);                                                                               \
182        G(r, 5, v[1], v[6], v[11], v[12]);                                                                               \
183        G(r, 6, v[2], v[7], v[8], v[13]);                                                                                \
184        G(r, 7, v[3], v[4], v[9], v[14]);                                                                                \
185     } while (0)
186  #ifdef LTC_CLEAN_STACK
187  static int ss_blake2s_compress(hash_state *md, const unsigned char *buf)
188  #else
189  static int s_blake2s_compress(hash_state *md, const unsigned char *buf)
190  #endif
191  {
192     unsigned long i;
193     ulong32 m[16];
194     ulong32 v[16];
195     for (i = 0; i < 16; ++i) {
196        LOAD32L(m[i], buf + i * sizeof(m[i]));
197     }
198     for (i = 0; i < 8; ++i) {
199        v[i] = md->blake2s.h[i];
200     }
201     v[8] = blake2s_IV[0];
202     v[9] = blake2s_IV[1];
203     v[10] = blake2s_IV[2];
204     v[11] = blake2s_IV[3];
205     v[12] = md->blake2s.t[0] ^ blake2s_IV[4];
206     v[13] = md->blake2s.t[1] ^ blake2s_IV[5];
207     v[14] = md->blake2s.f[0] ^ blake2s_IV[6];
208     v[15] = md->blake2s.f[1] ^ blake2s_IV[7];
209     ROUND(0);
210     ROUND(1);
211     ROUND(2);
212     ROUND(3);
213     ROUND(4);
214     ROUND(5);
215     ROUND(6);
216     ROUND(7);
217     ROUND(8);
218     ROUND(9);
219     for (i = 0; i < 8; ++i) {
220        md->blake2s.h[i] = md->blake2s.h[i] ^ v[i] ^ v[i + 8];
221     }
222     return CRYPT_OK;
223  }
224  #undef G
225  #undef ROUND
226  #ifdef LTC_CLEAN_STACK
227  static int s_blake2s_compress(hash_state *md, const unsigned char *buf)
228  {
229     int err;
230     err = ss_blake2s_compress(md, buf);
231     burn_stack(sizeof(ulong32) * (32) + sizeof(unsigned long));
232     return err;
233  }
234  #endif
235  int blake2s_process(hash_state *md, const unsigned char *in, unsigned long inlen)
236  {
237     LTC_ARGCHK(md != NULL);
238     LTC_ARGCHK(in != NULL);
239     if (md->blake2s.curlen > sizeof(md->blake2s.buf)) {
240        return CRYPT_INVALID_ARG;
241     }
242     if (inlen > 0) {
243        unsigned long left = md->blake2s.curlen;
244        unsigned long fill = BLAKE2S_BLOCKBYTES - left;
245        if (inlen > fill) {
246           md->blake2s.curlen = 0;
247           XMEMCPY(md->blake2s.buf + (left % sizeof(md->blake2s.buf)), in, fill); &bsol;* Fill buffer */
248           s_blake2s_increment_counter(md, BLAKE2S_BLOCKBYTES);
249           s_blake2s_compress(md, md->blake2s.buf); &bsol;* Compress */
250           in += fill;
251           inlen -= fill;
252           while (inlen > BLAKE2S_BLOCKBYTES) {
253              s_blake2s_increment_counter(md, BLAKE2S_BLOCKBYTES);
254              s_blake2s_compress(md, in);
255              in += BLAKE2S_BLOCKBYTES;
256              inlen -= BLAKE2S_BLOCKBYTES;
257           }
258        }
259        XMEMCPY(md->blake2s.buf + md->blake2s.curlen, in, inlen);
260        md->blake2s.curlen += inlen;
261     }
262     return CRYPT_OK;
263  }
264  int blake2s_done(hash_state *md, unsigned char *out)
265  {
266     unsigned char buffer[BLAKE2S_OUTBYTES] = { 0 };
267     unsigned long i;
268     LTC_ARGCHK(md != NULL);
269     LTC_ARGCHK(out != NULL);
270     if (s_blake2s_is_lastblock(md)) {
271        return CRYPT_ERROR;
272     }
273     s_blake2s_increment_counter(md, md->blake2s.curlen);
274     s_blake2s_set_lastblock(md);
275     XMEMSET(md->blake2s.buf + md->blake2s.curlen, 0, BLAKE2S_BLOCKBYTES - md->blake2s.curlen); &bsol;* Padding */
276     s_blake2s_compress(md, md->blake2s.buf);
277     for (i = 0; i < 8; ++i) { &bsol;* Output full hash to temp buffer */
278        STORE32L(md->blake2s.h[i], buffer + i * 4);
279     }
280     XMEMCPY(out, buffer, md->blake2s.outlen);
281     zeromem(md, sizeof(hash_state));
282  #ifdef LTC_CLEAN_STACK
283     zeromem(buffer, sizeof(buffer));
284  #endif
285     return CRYPT_OK;
286  }
287  int blake2s_256_test(void)
288  {
289  #ifndef LTC_TEST
290     return CRYPT_NOP;
291  #else
292     static const struct {
293        const char *msg;
294        unsigned char hash[32];
295    } tests[] = {
296      { "",
297        { 0x69, 0x21, 0x7a, 0x30, 0x79, 0x90, 0x80, 0x94,
298          0xe1, 0x11, 0x21, 0xd0, 0x42, 0x35, 0x4a, 0x7c,
299          0x1f, 0x55, 0xb6, 0x48, 0x2c, 0xa1, 0xa5, 0x1e,
300          0x1b, 0x25, 0x0d, 0xfd, 0x1e, 0xd0, 0xee, 0xf9 } },
301      { "abc",
302        { 0x50, 0x8c, 0x5e, 0x8c, 0x32, 0x7c, 0x14, 0xe2,
303          0xe1, 0xa7, 0x2b, 0xa3, 0x4e, 0xeb, 0x45, 0x2f,
304          0x37, 0x45, 0x8b, 0x20, 0x9e, 0xd6, 0x3a, 0x29,
305          0x4d, 0x99, 0x9b, 0x4c, 0x86, 0x67, 0x59, 0x82 } },
306      { "12345678901234567890123456789012345678901234567890"
307        "12345678901234567890123456789012345678901234567890"
308        "12345678901234567890123456789012345678901234567890"
309        "12345678901234567890123456789012345678901234567890"
310        "12345678901234567890123456789012345678901234567890"
311        "12345678901234567890123456789012345678901234567890",
312        { 0xa3, 0x78, 0x8b, 0x5b, 0x59, 0xee, 0xe4, 0x41,
313          0x95, 0x23, 0x58, 0x00, 0xa4, 0xf9, 0xfa, 0x41,
314          0x86, 0x0c, 0x7b, 0x1c, 0x35, 0xa2, 0x42, 0x70,
315          0x50, 0x80, 0x79, 0x56, 0xe3, 0xbe, 0x31, 0x74 } },
316      { NULL, { 0 } }
317    };
318     int i;
319     unsigned char tmp[32];
320     hash_state md;
321     for (i = 0; tests[i].msg != NULL; i++) {
322        blake2s_256_init(&md);
323        blake2s_process(&md, (unsigned char *)tests[i].msg, (unsigned long)XSTRLEN(tests[i].msg));
324        blake2s_done(&md, tmp);
325        if (compare_testvector(tmp, sizeof(tmp), tests[i].hash, sizeof(tests[i].hash), "BLAKE2S_256", i)) {
326           return CRYPT_FAIL_TESTVECTOR;
327        }
328     }
329     return CRYPT_OK;
330  #endif
331  }
332  int blake2s_224_test(void)
333  {
334  #ifndef LTC_TEST
335     return CRYPT_NOP;
336  #else
337     static const struct {
338        const char *msg;
339        unsigned char hash[28];
340    } tests[] = {
341      { "",
342        { 0x1f, 0xa1, 0x29, 0x1e, 0x65, 0x24, 0x8b, 0x37,
343          0xb3, 0x43, 0x34, 0x75, 0xb2, 0xa0, 0xdd, 0x63,
344          0xd5, 0x4a, 0x11, 0xec, 0xc4, 0xe3, 0xe0, 0x34,
345          0xe7, 0xbc, 0x1e, 0xf4 } },
346      { "abc",
347        { 0x0b, 0x03, 0x3f, 0xc2, 0x26, 0xdf, 0x7a, 0xbd,
348          0xe2, 0x9f, 0x67, 0xa0, 0x5d, 0x3d, 0xc6, 0x2c,
349          0xf2, 0x71, 0xef, 0x3d, 0xfe, 0xa4, 0xd3, 0x87,
350          0x40, 0x7f, 0xbd, 0x55 } },
351      { NULL, { 0 } }
352    };
353     int i;
354     unsigned char tmp[28];
355     hash_state md;
356     for (i = 0; tests[i].msg != NULL; i++) {
357        blake2s_224_init(&md);
358        blake2s_process(&md, (unsigned char *)tests[i].msg, (unsigned long)XSTRLEN(tests[i].msg));
359        blake2s_done(&md, tmp);
360        if (compare_testvector(tmp, sizeof(tmp), tests[i].hash, sizeof(tests[i].hash), "BLAKE2S_224", i)) {
361           return CRYPT_FAIL_TESTVECTOR;
362        }
363     }
364     return CRYPT_OK;
365  #endif
366  }
367  int blake2s_160_test(void)
368  {
369  #ifndef LTC_TEST
370     return CRYPT_NOP;
371  #else
372     static const struct {
373        const char *msg;
374        unsigned char hash[20];
375    } tests[] = {
376      { "",
377        { 0x35, 0x4c, 0x9c, 0x33, 0xf7, 0x35, 0x96, 0x24,
378          0x18, 0xbd, 0xac, 0xb9, 0x47, 0x98, 0x73, 0x42,
379          0x9c, 0x34, 0x91, 0x6f} },
380      { "abc",
381        { 0x5a, 0xe3, 0xb9, 0x9b, 0xe2, 0x9b, 0x01, 0x83,
382          0x4c, 0x3b, 0x50, 0x85, 0x21, 0xed, 0xe6, 0x04,
383          0x38, 0xf8, 0xde, 0x17 } },
384      { NULL, { 0 } }
385    };
386     int i;
387     unsigned char tmp[20];
388     hash_state md;
389     for (i = 0; tests[i].msg != NULL; i++) {
390        blake2s_160_init(&md);
391        blake2s_process(&md, (unsigned char *)tests[i].msg, (unsigned long)XSTRLEN(tests[i].msg));
392        blake2s_done(&md, tmp);
393        if (compare_testvector(tmp, sizeof(tmp), tests[i].hash, sizeof(tests[i].hash), "BLAKE2S_160", i)) {
394           return CRYPT_FAIL_TESTVECTOR;
395        }
396     }
397     return CRYPT_OK;
398  #endif
399  }
400  int blake2s_128_test(void)
401  {
402  #ifndef LTC_TEST
403     return CRYPT_NOP;
404  #else
405     static const struct {
406        const char *msg;
407        unsigned char hash[16];
408    } tests[] = {
409      { "",
410        { 0x64, 0x55, 0x0d, 0x6f, 0xfe, 0x2c, 0x0a, 0x01,
411          0xa1, 0x4a, 0xba, 0x1e, 0xad, 0xe0, 0x20, 0x0c } },
412      { "abc",
413        { 0xaa, 0x49, 0x38, 0x11, 0x9b, 0x1d, 0xc7, 0xb8,
414          0x7c, 0xba, 0xd0, 0xff, 0xd2, 0x00, 0xd0, 0xae } },
415      { NULL, { 0 } }
416    };
417     int i;
418     unsigned char tmp[16];
419     hash_state md;
420     for (i = 0; tests[i].msg != NULL; i++) {
421        blake2s_128_init(&md);
422        blake2s_process(&md, (unsigned char *)tests[i].msg, (unsigned long)XSTRLEN(tests[i].msg));
423        blake2s_done(&md, tmp);
424        if (compare_testvector(tmp, sizeof(tmp), tests[i].hash, sizeof(tests[i].hash), "BLAKE2S_128", i)) {
425           return CRYPT_FAIL_TESTVECTOR;
426        }
427     }
428     return CRYPT_OK;
429  #endif
430  }
431  #endif
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from libtomcrypt-MDEwOlJlcG9zaXRvcnk3NzcwMTE=-flat-blake2b.c</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from libtomcrypt-MDEwOlJlcG9zaXRvcnk3NzcwMTE=-flat-blake2s.c</div>
                </div>
                <div class="column column_space"><pre><code>122        md->blake2b.h[i] = blake2b_IV[i];
123     }
124  }
</pre></code></div>
                <div class="column column_space"><pre><code>115        md->blake2s.h[i] = blake2s_IV[i];
116     }
117     return CRYPT_OK;
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    