
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 18, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>redis-MDEwOlJlcG9zaXRvcnkxMDgxMTA3MDY=-flat-prof_inlines_b.h</h3>
            <pre><code>1  #ifndef JEMALLOC_INTERNAL_PROF_INLINES_B_H
2  #define JEMALLOC_INTERNAL_PROF_INLINES_B_H
3  #include "jemalloc/internal/safety_check.h"
4  #include "jemalloc/internal/sz.h"
5  JEMALLOC_ALWAYS_INLINE bool
6  prof_gdump_get_unlocked(void) {
7  	return prof_gdump_val;
8  }
9  JEMALLOC_ALWAYS_INLINE prof_tdata_t *
10  prof_tdata_get(tsd_t *tsd, bool create) {
11  	prof_tdata_t *tdata;
12  	cassert(config_prof);
13  	tdata = tsd_prof_tdata_get(tsd);
14  	if (create) {
15  		if (unlikely(tdata == NULL)) {
16  			if (tsd_nominal(tsd)) {
17  				tdata = prof_tdata_init(tsd);
18  				tsd_prof_tdata_set(tsd, tdata);
19  			}
20  		} else if (unlikely(tdata->expired)) {
21  			tdata = prof_tdata_reinit(tsd, tdata);
22  			tsd_prof_tdata_set(tsd, tdata);
23  		}
24  		assert(tdata == NULL || tdata->attached);
25  	}
26  	return tdata;
27  }
28  JEMALLOC_ALWAYS_INLINE prof_tctx_t *
29  prof_tctx_get(tsdn_t *tsdn, const void *ptr, alloc_ctx_t *alloc_ctx) {
30  	cassert(config_prof);
31  	assert(ptr != NULL);
32  	return arena_prof_tctx_get(tsdn, ptr, alloc_ctx);
33  }
34  JEMALLOC_ALWAYS_INLINE void
35  prof_tctx_set(tsdn_t *tsdn, const void *ptr, size_t usize,
36      alloc_ctx_t *alloc_ctx, prof_tctx_t *tctx) {
37  	cassert(config_prof);
38  	assert(ptr != NULL);
39  	arena_prof_tctx_set(tsdn, ptr, usize, alloc_ctx, tctx);
40  }
41  JEMALLOC_ALWAYS_INLINE void
42  prof_tctx_reset(tsdn_t *tsdn, const void *ptr, prof_tctx_t *tctx) {
43  	cassert(config_prof);
44  	assert(ptr != NULL);
45  	arena_prof_tctx_reset(tsdn, ptr, tctx);
46  }
47  JEMALLOC_ALWAYS_INLINE nstime_t
48  prof_alloc_time_get(tsdn_t *tsdn, const void *ptr, alloc_ctx_t *alloc_ctx) {
49  	cassert(config_prof);
50  	assert(ptr != NULL);
51  	return arena_prof_alloc_time_get(tsdn, ptr, alloc_ctx);
52  }
53  JEMALLOC_ALWAYS_INLINE void
54  prof_alloc_time_set(tsdn_t *tsdn, const void *ptr, alloc_ctx_t *alloc_ctx,
55      nstime_t t) {
56  	cassert(config_prof);
<span onclick='openModal()' class='match'>57  	assert(ptr != NULL);
58  	arena_prof_alloc_time_set(tsdn, ptr, alloc_ctx, t);
59  }
</span>60  JEMALLOC_ALWAYS_INLINE bool
61  prof_sample_check(tsd_t *tsd, size_t usize, bool update) {
62  	ssize_t check = update ? 0 : usize;
63  	int64_t bytes_until_sample = tsd_bytes_until_sample_get(tsd);
64  	if (update) {
65  		bytes_until_sample -= usize;
66  		if (tsd_nominal(tsd)) {
67  			tsd_bytes_until_sample_set(tsd, bytes_until_sample);
68  		}
69  	}
70  	if (likely(bytes_until_sample >= check)) {
71  		return true;
72  	}
73  	return false;
74  }
75  JEMALLOC_ALWAYS_INLINE bool
76  prof_sample_accum_update(tsd_t *tsd, size_t usize, bool update,
77  			 prof_tdata_t **tdata_out) {
78  	prof_tdata_t *tdata;
79  	cassert(config_prof);
80  	if (likely(prof_sample_check(tsd, usize, update))) {
81  		return true;
82  	}
83  	bool booted = tsd_prof_tdata_get(tsd);
84  	tdata = prof_tdata_get(tsd, true);
85  	if (unlikely((uintptr_t)tdata <= (uintptr_t)PROF_TDATA_STATE_MAX)) {
86  		tdata = NULL;
87  	}
88  	if (tdata_out != NULL) {
89  		*tdata_out = tdata;
90  	}
91  	if (unlikely(tdata == NULL)) {
92  		return true;
93  	}
94  	if (!booted && prof_sample_check(tsd, usize, update)) {
95  		return true;
96  	}
97  	if (tsd_reentrancy_level_get(tsd) > 0) {
98  		return true;
99  	}
100  	if (update) {
101  		prof_sample_threshold_update(tdata);
102  	}
103  	return !tdata->active;
104  }
105  JEMALLOC_ALWAYS_INLINE prof_tctx_t *
106  prof_alloc_prep(tsd_t *tsd, size_t usize, bool prof_active, bool update) {
107  	prof_tctx_t *ret;
108  	prof_tdata_t *tdata;
109  	prof_bt_t bt;
110  	assert(usize == sz_s2u(usize));
111  	if (!prof_active || likely(prof_sample_accum_update(tsd, usize, update,
112  	    &tdata))) {
113  		ret = (prof_tctx_t *)(uintptr_t)1U;
114  	} else {
115  		bt_init(&bt, tdata->vec);
116  		prof_backtrace(&bt);
117  		ret = prof_lookup(tsd, &bt);
118  	}
119  	return ret;
120  }
121  JEMALLOC_ALWAYS_INLINE void
122  prof_malloc(tsdn_t *tsdn, const void *ptr, size_t usize, alloc_ctx_t *alloc_ctx,
123      prof_tctx_t *tctx) {
124  	cassert(config_prof);
125  	assert(ptr != NULL);
126  	assert(usize == isalloc(tsdn, ptr));
127  	if (unlikely((uintptr_t)tctx > (uintptr_t)1U)) {
128  		prof_malloc_sample_object(tsdn, ptr, usize, tctx);
129  	} else {
130  		prof_tctx_set(tsdn, ptr, usize, alloc_ctx,
131  		    (prof_tctx_t *)(uintptr_t)1U);
132  	}
133  }
134  JEMALLOC_ALWAYS_INLINE void
135  prof_realloc(tsd_t *tsd, const void *ptr, size_t usize, prof_tctx_t *tctx,
136      bool prof_active, bool updated, const void *old_ptr, size_t old_usize,
137      prof_tctx_t *old_tctx) {
138  	bool sampled, old_sampled, moved;
139  	cassert(config_prof);
140  	assert(ptr != NULL || (uintptr_t)tctx <= (uintptr_t)1U);
141  	if (prof_active && !updated && ptr != NULL) {
142  		assert(usize == isalloc(tsd_tsdn(tsd), ptr));
143  		if (prof_sample_accum_update(tsd, usize, true, NULL)) {
144  			prof_alloc_rollback(tsd, tctx, true);
145  			tctx = (prof_tctx_t *)(uintptr_t)1U;
146  		}
147  	}
148  	sampled = ((uintptr_t)tctx > (uintptr_t)1U);
149  	old_sampled = ((uintptr_t)old_tctx > (uintptr_t)1U);
150  	moved = (ptr != old_ptr);
151  	if (unlikely(sampled)) {
152  		prof_malloc_sample_object(tsd_tsdn(tsd), ptr, usize, tctx);
153  	} else if (moved) {
154  		prof_tctx_set(tsd_tsdn(tsd), ptr, usize, NULL,
155  		    (prof_tctx_t *)(uintptr_t)1U);
156  	} else if (unlikely(old_sampled)) {
157  		prof_tctx_reset(tsd_tsdn(tsd), ptr, tctx);
158  	} else {
159  		assert((uintptr_t)prof_tctx_get(tsd_tsdn(tsd), ptr, NULL) ==
160  		    (uintptr_t)1U);
161  	}
162  	if (unlikely(old_sampled)) {
163  		prof_free_sampled_object(tsd, ptr, old_usize, old_tctx);
164  	}
165  }
166  JEMALLOC_ALWAYS_INLINE void
167  prof_free(tsd_t *tsd, const void *ptr, size_t usize, alloc_ctx_t *alloc_ctx) {
168  	prof_tctx_t *tctx = prof_tctx_get(tsd_tsdn(tsd), ptr, alloc_ctx);
169  	cassert(config_prof);
170  	assert(usize == isalloc(tsd_tsdn(tsd), ptr));
171  	if (unlikely((uintptr_t)tctx > (uintptr_t)1U)) {
172  		prof_free_sampled_object(tsd, ptr, usize, tctx);
173  	}
174  }
175  #endif &bsol;* JEMALLOC_INTERNAL_PROF_INLINES_B_H */
</code></pre>
        </div>
        <div class="column">
            <h3>libtomcrypt-MDEwOlJlcG9zaXRvcnk3NzcwMTE=-flat-gmp_desc.c</h3>
            <pre><code>1  #define DESC_DEF_ONLY
2  #include "tomcrypt_private.h"
3  #ifdef GMP_DESC
4  #include <stdio.h>
5  #include <gmp.h>
6  static int init(void **a)
7  {
8     LTC_ARGCHK(a != NULL);
9     *a = XCALLOC(1, sizeof(__mpz_struct));
10     if (*a == NULL) {
11        return CRYPT_MEM;
12     }
13     mpz_init(((__mpz_struct *)*a));
14     return CRYPT_OK;
15  }
16  static void deinit(void *a)
17  {
18     LTC_ARGCHKVD(a != NULL);
19     mpz_clear(a);
20     XFREE(a);
21  }
22  static int neg(void *a, void *b)
23  {
24     LTC_ARGCHK(a != NULL);
25     LTC_ARGCHK(b != NULL);
26     mpz_neg(b, a);
27     return CRYPT_OK;
28  }
29  static int copy(void *a, void *b)
30  {
31     LTC_ARGCHK(a != NULL);
32     LTC_ARGCHK(b != NULL);
33     mpz_set(b, a);
34     return CRYPT_OK;
35  }
36  static int init_copy(void **a, void *b)
37  {
38     if (init(a) != CRYPT_OK) {
39        return CRYPT_MEM;
40     }
41     return copy(b, *a);
42  }
43  static int set_int(void *a, ltc_mp_digit b)
44  {
45     LTC_ARGCHK(a != NULL);
46     mpz_set_ui(((__mpz_struct *)a), b);
47     return CRYPT_OK;
48  }
49  static unsigned long get_int(void *a)
50  {
51     LTC_ARGCHK(a != NULL);
52     return mpz_get_ui(a);
53  }
54  static ltc_mp_digit get_digit(void *a, int n)
55  {
56     LTC_ARGCHK(a != NULL);
57     return mpz_getlimbn(a, n);
58  }
59  static int get_digit_count(void *a)
60  {
61     LTC_ARGCHK(a != NULL);
62     return mpz_size(a);
63  }
64  static int compare(void *a, void *b)
65  {
66     int ret;
67     LTC_ARGCHK(a != NULL);
68     LTC_ARGCHK(b != NULL);
69     ret = mpz_cmp(a, b);
70     if (ret < 0) {
71        return LTC_MP_LT;
72     } else if (ret > 0) {
73        return LTC_MP_GT;
74     } else {
75        return LTC_MP_EQ;
76     }
77  }
78  static int compare_d(void *a, ltc_mp_digit b)
79  {
80     int ret;
81     LTC_ARGCHK(a != NULL);
82     ret = mpz_cmp_ui(((__mpz_struct *)a), b);
83     if (ret < 0) {
84        return LTC_MP_LT;
85     } else if (ret > 0) {
86        return LTC_MP_GT;
87     } else {
88        return LTC_MP_EQ;
89     }
90  }
91  static int count_bits(void *a)
92  {
93     LTC_ARGCHK(a != NULL);
94     return mpz_sizeinbase(a, 2);
95  }
96  static int count_lsb_bits(void *a)
97  {
98     LTC_ARGCHK(a != NULL);
99     return mpz_scan1(a, 0);
100  }
101  static int twoexpt(void *a, int n)
102  {
103     LTC_ARGCHK(a != NULL);
104     mpz_set_ui(a, 0);
105     mpz_setbit(a, n);
106     return CRYPT_OK;
107  }
108  static const char rmap[] = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz+/";
109  static int read_radix(void *a, const char *b, int radix)
110  {
111     int ret;
112     LTC_ARGCHK(a != NULL);
113     LTC_ARGCHK(b != NULL);
114     if (radix == 64) {
115        char c, *tmp, *q;
116        const char *p;
117        int i;
118        tmp = XMALLOC (1 + 2 * XSTRLEN (b));
119        if (tmp == NULL) {
120           return CRYPT_MEM;
121        }
122        p = b;
123        q = tmp;
124        while ((c = *p++) != 0) {
125           for (i = 0; i < 64; i++) {
126              if (c == rmap[i])
127                 break;
128           }
129           if (i == 64) {
130              XFREE (tmp);
131              return CRYPT_ERROR;
132           }
133           *q++ = '0' + (i / 8);
134           *q++ = '0' + (i % 8);
135        }
136        *q = 0;
137        ret = mpz_set_str(a, tmp, 8);
138        XFREE (tmp);
139     } else {
140        ret = mpz_set_str(a, b, radix);
141     }
142     return (ret == 0 ? CRYPT_OK : CRYPT_ERROR);
143  }
144  static int write_radix(void *a, char *b, int radix)
145  {
146     LTC_ARGCHK(a != NULL);
147     LTC_ARGCHK(b != NULL);
148     if (radix >= 11 && radix <= 36)
149        radix = -radix;
150     mpz_get_str(b, radix, a);
151     return CRYPT_OK;
152  }
153  static unsigned long unsigned_size(void *a)
154  {
155     unsigned long t;
156     LTC_ARGCHK(a != NULL);
157     t = mpz_sizeinbase(a, 2);
158     if (mpz_cmp_ui(((__mpz_struct *)a), 0) == 0) return 0;
159     return (t>>3) + ((t&7)?1:0);
160  }
161  static int unsigned_write(void *a, unsigned char *b)
162  {
163     LTC_ARGCHK(a != NULL);
164     LTC_ARGCHK(b != NULL);
165     mpz_export(b, NULL, 1, 1, 1, 0, ((__mpz_struct*)a));
166     return CRYPT_OK;
167  }
168  static int unsigned_read(void *a, unsigned char *b, unsigned long len)
169  {
170     LTC_ARGCHK(a != NULL);
171     LTC_ARGCHK(b != NULL);
172     mpz_import(a, len, 1, 1, 1, 0, b);
173     return CRYPT_OK;
174  }
175  static int add(void *a, void *b, void *c)
176  {
177     LTC_ARGCHK(a != NULL);
178     LTC_ARGCHK(b != NULL);
179     LTC_ARGCHK(c != NULL);
180     mpz_add(c, a, b);
181     return CRYPT_OK;
182  }
183  static int addi(void *a, ltc_mp_digit b, void *c)
184  {
185     LTC_ARGCHK(a != NULL);
186     LTC_ARGCHK(c != NULL);
187     mpz_add_ui(c, a, b);
188     return CRYPT_OK;
189  }
190  static int sub(void *a, void *b, void *c)
191  {
192     LTC_ARGCHK(a != NULL);
193     LTC_ARGCHK(b != NULL);
194     LTC_ARGCHK(c != NULL);
195     mpz_sub(c, a, b);
196     return CRYPT_OK;
197  }
198  static int subi(void *a, ltc_mp_digit b, void *c)
199  {
200     LTC_ARGCHK(a != NULL);
201     LTC_ARGCHK(c != NULL);
202     mpz_sub_ui(c, a, b);
203     return CRYPT_OK;
204  }
205  static int mul(void *a, void *b, void *c)
206  {
207     LTC_ARGCHK(a != NULL);
208     LTC_ARGCHK(b != NULL);
209     LTC_ARGCHK(c != NULL);
210     mpz_mul(c, a, b);
211     return CRYPT_OK;
212  }
213  static int muli(void *a, ltc_mp_digit b, void *c)
214  {
215     LTC_ARGCHK(a != NULL);
216     LTC_ARGCHK(c != NULL);
217     mpz_mul_ui(c, a, b);
218     return CRYPT_OK;
219  }
220  static int sqr(void *a, void *b)
221  {
222     LTC_ARGCHK(a != NULL);
223     LTC_ARGCHK(b != NULL);
224     mpz_mul(b, a, a);
225     return CRYPT_OK;
226  }
227  static int sqrtmod_prime(void *n, void *prime, void *ret)
228  {
229     int res, legendre, i;
230     mpz_t t1, C, Q, S, Z, M, T, R, two;
231     LTC_ARGCHK(n     != NULL);
232     LTC_ARGCHK(prime != NULL);
233     LTC_ARGCHK(ret   != NULL);
234     if (mpz_cmp_ui(((__mpz_struct *)n), 0) == 0) {
235        mpz_set_ui(ret, 0);
236        return CRYPT_OK;
237     }
238     if (mpz_cmp_ui(((__mpz_struct *)prime), 2) == 0)     return CRYPT_ERROR; &bsol;* prime must be odd */
239     legendre = mpz_legendre(n, prime);
240     if (legendre == -1)                                  return CRYPT_ERROR; &bsol;* quadratic non-residue mod prime */
241     mpz_init(t1); mpz_init(C); mpz_init(Q);
242     mpz_init(S);  mpz_init(Z); mpz_init(M);
243     mpz_init(T);  mpz_init(R); mpz_init(two);
244     i = mpz_mod_ui(t1, prime, 4); &bsol;* t1 is ignored here */
245     if (i == 3) {
246        mpz_add_ui(t1, prime, 1);
247        mpz_fdiv_q_2exp(t1, t1, 2);
248        mpz_powm(ret, n, t1, prime);
249        res = CRYPT_OK;
250        goto cleanup;
251     }
252     mpz_set(Q, prime);
253     mpz_sub_ui(Q, Q, 1);
254     mpz_set_ui(S, 0);
255     while (mpz_even_p(Q)) {
256        mpz_fdiv_q_2exp(Q, Q, 1);
257        mpz_add_ui(S, S, 1);
258     }
259     mpz_set_ui(Z, 2);
260     while(1) {
261        legendre = mpz_legendre(Z, prime);
262        if (legendre == -1) break;
263        mpz_add_ui(Z, Z, 1);
264     }
265     mpz_powm(C, Z, Q, prime);
266     mpz_add_ui(t1, Q, 1);
267     mpz_fdiv_q_2exp(t1, t1, 1);
268     mpz_powm(R, n, t1, prime);
269     mpz_powm(T, n, Q, prime);
270     mpz_set(M, S);
271     mpz_set_ui(two, 2);
272     while (1) {
273        mpz_set(t1, T);
274        i = 0;
275        while (1) {
276           if (mpz_cmp_ui(((__mpz_struct *)t1), 1) == 0) break;
277           mpz_powm(t1, t1, two, prime);
278           i++;
279        }
280        if (i == 0) {
281           mpz_set(ret, R);
282           res = CRYPT_OK;
283           goto cleanup;
284        }
285        mpz_sub_ui(t1, M, i);
286        mpz_sub_ui(t1, t1, 1);
287        mpz_powm(t1, two, t1, prime);
288        mpz_powm(t1, C, t1, prime);
289        mpz_mul(C, t1, t1);
290        mpz_mod(C, C, prime);
291        mpz_mul(R, R, t1);
292        mpz_mod(R, R, prime);
293        mpz_mul(T, T, C);
294        mpz_mod(T, T, prime);
295        mpz_set_ui(M, i);
296     }
297  cleanup:
298     mpz_clear(t1); mpz_clear(C); mpz_clear(Q);
299     mpz_clear(S);  mpz_clear(Z); mpz_clear(M);
300     mpz_clear(T);  mpz_clear(R); mpz_clear(two);
301     return res;
302  }
303  static int divide(void *a, void *b, void *c, void *d)
304  {
305     mpz_t tmp;
306     LTC_ARGCHK(a != NULL);
307     LTC_ARGCHK(b != NULL);
308     if (c != NULL) {
309        mpz_init(tmp);
310        mpz_divexact(tmp, a, b);
311     }
312     if (d != NULL) {
313        mpz_mod(d, a, b);
314     }
315     if (c != NULL) {
316        mpz_set(c, tmp);
317        mpz_clear(tmp);
318     }
319     return CRYPT_OK;
320  }
321  static int div_2(void *a, void *b)
322  {
323     LTC_ARGCHK(a != NULL);
324     LTC_ARGCHK(b != NULL);
325     mpz_divexact_ui(b, a, 2);
326     return CRYPT_OK;
327  }
328  static int modi(void *a, ltc_mp_digit b, ltc_mp_digit *c)
329  {
330     LTC_ARGCHK(a != NULL);
331     LTC_ARGCHK(c != NULL);
332     *c = mpz_fdiv_ui(a, b);
333     return CRYPT_OK;
334  }
335  static int gcd(void *a, void *b, void *c)
336  {
337     LTC_ARGCHK(a != NULL);
338     LTC_ARGCHK(b != NULL);
339     LTC_ARGCHK(c != NULL);
340     mpz_gcd(c, a, b);
341     return CRYPT_OK;
342  }
343  static int lcm(void *a, void *b, void *c)
344  {
345     LTC_ARGCHK(a != NULL);
346     LTC_ARGCHK(b != NULL);
347     LTC_ARGCHK(c != NULL);
348     mpz_lcm(c, a, b);
349     return CRYPT_OK;
350  }
351  static int addmod(void *a, void *b, void *c, void *d)
352  {
353     LTC_ARGCHK(a != NULL);
354     LTC_ARGCHK(b != NULL);
355     LTC_ARGCHK(c != NULL);
356     LTC_ARGCHK(d != NULL);
357     mpz_add(d, a, b);
358     mpz_mod(d, d, c);
359     return CRYPT_OK;
360  }
361  static int submod(void *a, void *b, void *c, void *d)
362  {
363     LTC_ARGCHK(a != NULL);
364     LTC_ARGCHK(b != NULL);
365     LTC_ARGCHK(c != NULL);
366     LTC_ARGCHK(d != NULL);
367     mpz_sub(d, a, b);
368     mpz_mod(d, d, c);
369     return CRYPT_OK;
370  }
371  static int mulmod(void *a, void *b, void *c, void *d)
372  {
373     LTC_ARGCHK(a != NULL);
374     LTC_ARGCHK(b != NULL);
375     LTC_ARGCHK(c != NULL);
376     LTC_ARGCHK(d != NULL);
377     mpz_mul(d, a, b);
378     mpz_mod(d, d, c);
379     return CRYPT_OK;
380  }
381  static int sqrmod(void *a, void *b, void *c)
382  {
383     LTC_ARGCHK(a != NULL);
384     LTC_ARGCHK(b != NULL);
385     LTC_ARGCHK(c != NULL);
386     mpz_mul(c, a, a);
387     mpz_mod(c, c, b);
388     return CRYPT_OK;
389  }
390  static int invmod(void *a, void *b, void *c)
391  {
392     LTC_ARGCHK(a != NULL);
393     LTC_ARGCHK(b != NULL);
394     LTC_ARGCHK(c != NULL);
395     mpz_invert(c, a, b);
396     return CRYPT_OK;
397  }
398  static int montgomery_setup(void *a, void **b)
399  {
400     LTC_ARGCHK(a != NULL);
401     LTC_ARGCHK(b != NULL);
402     *b = (void *)1;
403     return CRYPT_OK;
404  }
405  static int montgomery_normalization(void *a, void *b)
406  {
407     LTC_ARGCHK(a != NULL);
408     LTC_ARGCHK(b != NULL);
409     mpz_set_ui(a, 1);
410     return CRYPT_OK;
411  }
412  static int montgomery_reduce(void *a, void *b, void *c)
413  {
414     LTC_ARGCHK(a != NULL);
415     LTC_ARGCHK(b != NULL);
416     LTC_ARGCHK(c != NULL);
417     mpz_mod(a, a, b);
418     return CRYPT_OK;
419  }
420  static void montgomery_deinit(void *a)
421  {
422    LTC_UNUSED_PARAM(a);
423  }
424  static int exptmod(void *a, void *b, void *c, void *d)
425  {
426     LTC_ARGCHK(a != NULL);
427     LTC_ARGCHK(b != NULL);
428     LTC_ARGCHK(c != NULL);
<span onclick='openModal()' class='match'>429     LTC_ARGCHK(d != NULL);
430     mpz_powm(d, a, b, c);
431     return CRYPT_OK;
</span>432  }
433  static int isprime(void *a, int b, int *c)
434  {
435     LTC_ARGCHK(a != NULL);
436     LTC_ARGCHK(c != NULL);
437     if (b == 0) {
438         b = LTC_MILLER_RABIN_REPS;
439     } &bsol;* if */
440     *c = mpz_probab_prime_p(a, b) > 0 ? LTC_MP_YES : LTC_MP_NO;
441     return CRYPT_OK;
442  }
443  static int set_rand(void *a, int size)
444  {
445     LTC_ARGCHK(a != NULL);
446     mpz_random(a, size);
447     return CRYPT_OK;
448  }
449  const ltc_math_descriptor gmp_desc = {
450     "GNU MP",
451     sizeof(mp_limb_t) * CHAR_BIT - GMP_NAIL_BITS,
452     &init,
453     &init_copy,
454     &deinit,
455     &neg,
456     &copy,
457     &set_int,
458     &get_int,
459     &get_digit,
460     &get_digit_count,
461     &compare,
462     &compare_d,
463     &count_bits,
464     &count_lsb_bits,
465     &twoexpt,
466     &read_radix,
467     &write_radix,
468     &unsigned_size,
469     &unsigned_write,
470     &unsigned_read,
471     &add,
472     &addi,
473     &sub,
474     &subi,
475     &mul,
476     &muli,
477     &sqr,
478     &sqrtmod_prime,
479     &divide,
480     &div_2,
481     &modi,
482     &gcd,
483     &lcm,
484     &mulmod,
485     &sqrmod,
486     &invmod,
487     &montgomery_setup,
488     &montgomery_normalization,
489     &montgomery_reduce,
490     &montgomery_deinit,
491     &exptmod,
492     &isprime,
493  #ifdef LTC_MECC
494  #ifdef LTC_MECC_FP
495     &ltc_ecc_fp_mulmod,
496  #else
497     &ltc_ecc_mulmod,
498  #endif &bsol;* LTC_MECC_FP */
499     &ltc_ecc_projective_add_point,
500     &ltc_ecc_projective_dbl_point,
501     &ltc_ecc_map,
502  #ifdef LTC_ECC_SHAMIR
503  #ifdef LTC_MECC_FP
504     &ltc_ecc_fp_mul2add,
505  #else
506     &ltc_ecc_mul2add,
507  #endif &bsol;* LTC_MECC_FP */
508  #else
509     NULL,
510  #endif &bsol;* LTC_ECC_SHAMIR */
511  #else
512     NULL, NULL, NULL, NULL, NULL,
513  #endif &bsol;* LTC_MECC */
514  #ifdef LTC_MRSA
515     &rsa_make_key,
516     &rsa_exptmod,
517  #else
518     NULL, NULL,
519  #endif
520     &addmod,
521     &submod,
522     &set_rand,
523  };
524  #endif
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from redis-MDEwOlJlcG9zaXRvcnkxMDgxMTA3MDY=-flat-prof_inlines_b.h</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from libtomcrypt-MDEwOlJlcG9zaXRvcnk3NzcwMTE=-flat-gmp_desc.c</div>
                </div>
                <div class="column column_space"><pre><code>57  	assert(ptr != NULL);
58  	arena_prof_alloc_time_set(tsdn, ptr, alloc_ctx, t);
59  }
</pre></code></div>
                <div class="column column_space"><pre><code>429     LTC_ARGCHK(d != NULL);
430     mpz_powm(d, a, b, c);
431     return CRYPT_OK;
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    