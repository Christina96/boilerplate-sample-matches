
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 56, <button onclick='openModal()' class='match'>CODE CLONE</button></h2>
        <div class="column">
            <h3>xmrig-MDEwOlJlcG9zaXRvcnk4ODMyNzQwNg==-flat-CryptoNight_x86.h</h3>
            <pre><code>1  #ifndef XMRIG_CRYPTONIGHT_X86_H
2  #define XMRIG_CRYPTONIGHT_X86_H
3  #ifdef __GNUC__
4  #   include &lt;x86intrin.h&gt;
5  #else
6  #   include &lt;intrin.h&gt;
7  #   define __restrict__ __restrict
8  #endif
9  #include &quot;backend/cpu/Cpu.h&quot;
10  #include &quot;base/crypto/keccak.h&quot;
11  #include &quot;crypto/cn/CnAlgo.h&quot;
12  #include &quot;crypto/cn/CryptoNight_monero.h&quot;
13  #include &quot;crypto/cn/CryptoNight.h&quot;
14  #include &quot;crypto/cn/soft_aes.h&quot;
15  #ifdef XMRIG_VAES
16  #   include &quot;crypto/cn/CryptoNight_x86_vaes.h&quot;
17  #endif
18  extern &quot;C&quot;
19  {
20  #include &quot;crypto/cn/c_groestl.h&quot;
21  #include &quot;crypto/cn/c_blake256.h&quot;
22  #include &quot;crypto/cn/c_jh.h&quot;
23  #include &quot;crypto/cn/c_skein.h&quot;
24  }
25  static inline void do_blake_hash(const uint8_t *input, size_t len, uint8_t *output) {
26      blake256_hash(output, input, len);
27  }
28  static inline void do_groestl_hash(const uint8_t *input, size_t len, uint8_t *output) {
29      groestl(input, len * 8, output);
30  }
31  static inline void do_jh_hash(const uint8_t *input, size_t len, uint8_t *output) {
32      jh_hash(32 * 8, input, 8 * len, output);
33  }
34  static inline void do_skein_hash(const uint8_t *input, size_t len, uint8_t *output) {
35      xmr_skein(input, output);
36  }
37  void (* const extra_hashes[4])(const uint8_t *, size_t, uint8_t *) = {do_blake_hash, do_groestl_hash, do_jh_hash, do_skein_hash};
38  #if (defined(__i386__) || defined(_M_IX86)) &amp;&amp; !(defined(__clang__) &amp;&amp; defined(__clang_major__) &amp;&amp; (__clang_major__ &gt;= 15))
39  static inline int64_t _mm_cvtsi128_si64(__m128i a)
40  {
41      return ((uint64_t)(uint32_t)_mm_cvtsi128_si32(a) | ((uint64_t)(uint32_t)_mm_cvtsi128_si32(_mm_srli_si128(a, 4)) &lt;&lt; 32));
42  }
43  static inline __m128i _mm_cvtsi64_si128(int64_t a) {
44      return _mm_set_epi64x(0, a);
45  }
46  #endif
47  static inline __m128i sl_xor(__m128i tmp1)
48  {
49      __m128i tmp4;
50      tmp4 = _mm_slli_si128(tmp1, 0x04);
51      tmp1 = _mm_xor_si128(tmp1, tmp4);
52      tmp4 = _mm_slli_si128(tmp4, 0x04);
53      tmp1 = _mm_xor_si128(tmp1, tmp4);
54      tmp4 = _mm_slli_si128(tmp4, 0x04);
55      tmp1 = _mm_xor_si128(tmp1, tmp4);
56      return tmp1;
57  }
58  template&lt;uint8_t rcon&gt;
59  static inline void aes_genkey_sub(__m128i* xout0, __m128i* xout2)
60  {
61      __m128i xout1 = _mm_aeskeygenassist_si128(*xout2, rcon);
62      xout1  = _mm_shuffle_epi32(xout1, 0xFF); 
63      *xout0 = sl_xor(*xout0);
64      *xout0 = _mm_xor_si128(*xout0, xout1);
65      xout1  = _mm_aeskeygenassist_si128(*xout0, 0x00);
66      xout1  = _mm_shuffle_epi32(xout1, 0xAA); 
67      *xout2 = sl_xor(*xout2);
68      *xout2 = _mm_xor_si128(*xout2, xout1);
69  }
70  template&lt;uint8_t rcon&gt;
71  static inline void soft_aes_genkey_sub(__m128i* xout0, __m128i* xout2)
72  {
73      __m128i xout1 = soft_aeskeygenassist&lt;rcon&gt;(*xout2);
74      xout1  = _mm_shuffle_epi32(xout1, 0xFF); 
75      *xout0 = sl_xor(*xout0);
76      *xout0 = _mm_xor_si128(*xout0, xout1);
77      xout1  = soft_aeskeygenassist&lt;0x00&gt;(*xout0);
78      xout1  = _mm_shuffle_epi32(xout1, 0xAA); 
79      *xout2 = sl_xor(*xout2);
80      *xout2 = _mm_xor_si128(*xout2, xout1);
81  }
82  template&lt;bool SOFT_AES&gt;
83  static inline void aes_genkey(const __m128i* memory, __m128i* k0, __m128i* k1, __m128i* k2, __m128i* k3, __m128i* k4, __m128i* k5, __m128i* k6, __m128i* k7, __m128i* k8, __m128i* k9)
84  {
85      __m128i xout0 = _mm_load_si128(memory);
86      __m128i xout2 = _mm_load_si128(memory + 1);
87      *k0 = xout0;
88      *k1 = xout2;
89      SOFT_AES ? soft_aes_genkey_sub&lt;0x01&gt;(&amp;xout0, &amp;xout2) : aes_genkey_sub&lt;0x01&gt;(&amp;xout0, &amp;xout2);
90      *k2 = xout0;
91      *k3 = xout2;
92      SOFT_AES ? soft_aes_genkey_sub&lt;0x02&gt;(&amp;xout0, &amp;xout2) : aes_genkey_sub&lt;0x02&gt;(&amp;xout0, &amp;xout2);
93      *k4 = xout0;
94      *k5 = xout2;
95      SOFT_AES ? soft_aes_genkey_sub&lt;0x04&gt;(&amp;xout0, &amp;xout2) : aes_genkey_sub&lt;0x04&gt;(&amp;xout0, &amp;xout2);
96      *k6 = xout0;
97      *k7 = xout2;
98      SOFT_AES ? soft_aes_genkey_sub&lt;0x08&gt;(&amp;xout0, &amp;xout2) : aes_genkey_sub&lt;0x08&gt;(&amp;xout0, &amp;xout2);
99      *k8 = xout0;
100      *k9 = xout2;
101  }
102  static FORCEINLINE void soft_aesenc(void* __restrict ptr, const void* __restrict key, const uint32_t* __restrict t)
103  {
104      uint32_t x0 = ((const uint32_t*)(ptr))[0];
105      uint32_t x1 = ((const uint32_t*)(ptr))[1];
106      uint32_t x2 = ((const uint32_t*)(ptr))[2];
107      uint32_t x3 = ((const uint32_t*)(ptr))[3];
108      uint32_t y0 = t[x0 &amp; 0xff]; x0 &gt;&gt;= 8;
109      uint32_t y1 = t[x1 &amp; 0xff]; x1 &gt;&gt;= 8;
110      uint32_t y2 = t[x2 &amp; 0xff]; x2 &gt;&gt;= 8;
111      uint32_t y3 = t[x3 &amp; 0xff]; x3 &gt;&gt;= 8;
112      t += 256;
113      y0 ^= t[x1 &amp; 0xff]; x1 &gt;&gt;= 8;
114      y1 ^= t[x2 &amp; 0xff]; x2 &gt;&gt;= 8;
115      y2 ^= t[x3 &amp; 0xff]; x3 &gt;&gt;= 8;
116      y3 ^= t[x0 &amp; 0xff]; x0 &gt;&gt;= 8;
117      t += 256;
118      y0 ^= t[x2 &amp; 0xff]; x2 &gt;&gt;= 8;
119      y1 ^= t[x3 &amp; 0xff]; x3 &gt;&gt;= 8;
120      y2 ^= t[x0 &amp; 0xff]; x0 &gt;&gt;= 8;
121      y3 ^= t[x1 &amp; 0xff]; x1 &gt;&gt;= 8;
122      t += 256;
123      y0 ^= t[x3];
124      y1 ^= t[x0];
125      y2 ^= t[x1];
126      y3 ^= t[x2];
127      ((uint32_t*)ptr)[0] = y0 ^ ((uint32_t*)key)[0];
128      ((uint32_t*)ptr)[1] = y1 ^ ((uint32_t*)key)[1];
129      ((uint32_t*)ptr)[2] = y2 ^ ((uint32_t*)key)[2];
130      ((uint32_t*)ptr)[3] = y3 ^ ((uint32_t*)key)[3];
131  }
132  static FORCEINLINE __m128i soft_aesenc(const void* __restrict ptr, const __m128i key, const uint32_t* __restrict t)
133  {
134      uint32_t x0 = ((const uint32_t*)(ptr))[0];
135      uint32_t x1 = ((const uint32_t*)(ptr))[1];
136      uint32_t x2 = ((const uint32_t*)(ptr))[2];
137      uint32_t x3 = ((const uint32_t*)(ptr))[3];
138      uint32_t y0 = t[x0 &amp; 0xff]; x0 &gt;&gt;= 8;
139      uint32_t y1 = t[x1 &amp; 0xff]; x1 &gt;&gt;= 8;
140      uint32_t y2 = t[x2 &amp; 0xff]; x2 &gt;&gt;= 8;
141      uint32_t y3 = t[x3 &amp; 0xff]; x3 &gt;&gt;= 8;
142      t += 256;
143      y0 ^= t[x1 &amp; 0xff]; x1 &gt;&gt;= 8;
144      y1 ^= t[x2 &amp; 0xff]; x2 &gt;&gt;= 8;
145      y2 ^= t[x3 &amp; 0xff]; x3 &gt;&gt;= 8;
146      y3 ^= t[x0 &amp; 0xff]; x0 &gt;&gt;= 8;
<span onclick='openModal()' class='match'>147      t += 256;
148      y0 ^= t[x2 &amp; 0xff]; x2 &gt;&gt;= 8;
149      y1 ^= t[x3 &amp; 0xff]; x3 &gt;&gt;= 8;
150      y2 ^= t[x0 &amp; 0xff]; x0 &gt;&gt;= 8;
151      y3 ^= t[x1 &amp; 0xff]; x1 &gt;&gt;= 8;
152      y0 ^= t[x3 + 256];
</span>153      y1 ^= t[x0 + 256];
154      y2 ^= t[x1 + 256];
155      y3 ^= t[x2 + 256];
156      return _mm_xor_si128(_mm_set_epi32(y3, y2, y1, y0), key);
157  }
158  template&lt;bool SOFT_AES&gt;
159  void aes_round(__m128i key, __m128i* x0, __m128i* x1, __m128i* x2, __m128i* x3, __m128i* x4, __m128i* x5, __m128i* x6, __m128i* x7);
160  template&lt;&gt;
161  NOINLINE void aes_round&lt;true&gt;(__m128i key, __m128i* x0, __m128i* x1, __m128i* x2, __m128i* x3, __m128i* x4, __m128i* x5, __m128i* x6, __m128i* x7)
162  {
163      *x0 = soft_aesenc((uint32_t*)x0, key, (const uint32_t*)saes_table);
164      *x1 = soft_aesenc((uint32_t*)x1, key, (const uint32_t*)saes_table);
165      *x2 = soft_aesenc((uint32_t*)x2, key, (const uint32_t*)saes_table);
166      *x3 = soft_aesenc((uint32_t*)x3, key, (const uint32_t*)saes_table);
167      *x4 = soft_aesenc((uint32_t*)x4, key, (const uint32_t*)saes_table);
168      *x5 = soft_aesenc((uint32_t*)x5, key, (const uint32_t*)saes_table);
169      *x6 = soft_aesenc((uint32_t*)x6, key, (const uint32_t*)saes_table);
170      *x7 = soft_aesenc((uint32_t*)x7, key, (const uint32_t*)saes_table);
171  }
172  template&lt;&gt;
173  FORCEINLINE void aes_round&lt;false&gt;(__m128i key, __m128i* x0, __m128i* x1, __m128i* x2, __m128i* x3, __m128i* x4, __m128i* x5, __m128i* x6, __m128i* x7)
174  {
175      *x0 = _mm_aesenc_si128(*x0, key);
176      *x1 = _mm_aesenc_si128(*x1, key);
177      *x2 = _mm_aesenc_si128(*x2, key);
178      *x3 = _mm_aesenc_si128(*x3, key);
179      *x4 = _mm_aesenc_si128(*x4, key);
180      *x5 = _mm_aesenc_si128(*x5, key);
181      *x6 = _mm_aesenc_si128(*x6, key);
182      *x7 = _mm_aesenc_si128(*x7, key);
183  }
184  inline void mix_and_propagate(__m128i&amp; x0, __m128i&amp; x1, __m128i&amp; x2, __m128i&amp; x3, __m128i&amp; x4, __m128i&amp; x5, __m128i&amp; x6, __m128i&amp; x7)
185  {
186      __m128i tmp0 = x0;
187      x0 = _mm_xor_si128(x0, x1);
188      x1 = _mm_xor_si128(x1, x2);
189      x2 = _mm_xor_si128(x2, x3);
190      x3 = _mm_xor_si128(x3, x4);
191      x4 = _mm_xor_si128(x4, x5);
192      x5 = _mm_xor_si128(x5, x6);
193      x6 = _mm_xor_si128(x6, x7);
194      x7 = _mm_xor_si128(x7, tmp0);
195  }
196  namespace xmrig {
197  template&lt;int interleave&gt;
198  static inline constexpr uint64_t interleaved_index(uint64_t k)
199  {
200      return ((k &amp; ~63ULL) &lt;&lt; interleave) | (k &amp; 63);
201  }
202  template&lt;&gt;
203  inline constexpr uint64_t interleaved_index&lt;0&gt;(uint64_t k)
204  {
205      return k;
206  }
207  template&lt;Algorithm::Id ALGO, bool SOFT_AES, int interleave&gt;
208  static NOINLINE void cn_explode_scratchpad(cryptonight_ctx *ctx)
209  {
210      constexpr CnAlgo&lt;ALGO&gt; props;
211  #   ifdef XMRIG_VAES
212      if (!SOFT_AES &amp;&amp; !props.isHeavy() &amp;&amp; cn_vaes_enabled) {
213          cn_explode_scratchpad_vaes(ctx, props.memory(), props.half_mem());
214          return;
215      }
216  #   endif
217      constexpr size_t N = (props.memory() / sizeof(__m128i)) / (props.half_mem() ? 2 : 1);
218      __m128i xin0, xin1, xin2, xin3, xin4, xin5, xin6, xin7;
219      __m128i k0, k1, k2, k3, k4, k5, k6, k7, k8, k9;
220      const __m128i* input = reinterpret_cast&lt;const __m128i*&gt;(ctx-&gt;state);
221      __m128i* output = reinterpret_cast&lt;__m128i*&gt;(ctx-&gt;memory);
222      aes_genkey&lt;SOFT_AES&gt;(input, &amp;k0, &amp;k1, &amp;k2, &amp;k3, &amp;k4, &amp;k5, &amp;k6, &amp;k7, &amp;k8, &amp;k9);
223      if (props.half_mem() &amp;&amp; !ctx-&gt;first_half) {
224          const __m128i* p = reinterpret_cast&lt;const __m128i*&gt;(ctx-&gt;save_state);
225          xin0 = _mm_load_si128(p + 0);
226          xin1 = _mm_load_si128(p + 1);
227          xin2 = _mm_load_si128(p + 2);
228          xin3 = _mm_load_si128(p + 3);
229          xin4 = _mm_load_si128(p + 4);
230          xin5 = _mm_load_si128(p + 5);
231          xin6 = _mm_load_si128(p + 6);
232          xin7 = _mm_load_si128(p + 7);
233      }
234      else {
235          xin0 = _mm_load_si128(input + 4);
236          xin1 = _mm_load_si128(input + 5);
237          xin2 = _mm_load_si128(input + 6);
238          xin3 = _mm_load_si128(input + 7);
239          xin4 = _mm_load_si128(input + 8);
240          xin5 = _mm_load_si128(input + 9);
241          xin6 = _mm_load_si128(input + 10);
242          xin7 = _mm_load_si128(input + 11);
243      }
244      if (props.isHeavy()) {
245          for (size_t i = 0; i &lt; 16; i++) {
246              aes_round&lt;SOFT_AES&gt;(k0, &amp;xin0, &amp;xin1, &amp;xin2, &amp;xin3, &amp;xin4, &amp;xin5, &amp;xin6, &amp;xin7);
247              aes_round&lt;SOFT_AES&gt;(k1, &amp;xin0, &amp;xin1, &amp;xin2, &amp;xin3, &amp;xin4, &amp;xin5, &amp;xin6, &amp;xin7);
248              aes_round&lt;SOFT_AES&gt;(k2, &amp;xin0, &amp;xin1, &amp;xin2, &amp;xin3, &amp;xin4, &amp;xin5, &amp;xin6, &amp;xin7);
249              aes_round&lt;SOFT_AES&gt;(k3, &amp;xin0, &amp;xin1, &amp;xin2, &amp;xin3, &amp;xin4, &amp;xin5, &amp;xin6, &amp;xin7);
250              aes_round&lt;SOFT_AES&gt;(k4, &amp;xin0, &amp;xin1, &amp;xin2, &amp;xin3, &amp;xin4, &amp;xin5, &amp;xin6, &amp;xin7);
251              aes_round&lt;SOFT_AES&gt;(k5, &amp;xin0, &amp;xin1, &amp;xin2, &amp;xin3, &amp;xin4, &amp;xin5, &amp;xin6, &amp;xin7);
252              aes_round&lt;SOFT_AES&gt;(k6, &amp;xin0, &amp;xin1, &amp;xin2, &amp;xin3, &amp;xin4, &amp;xin5, &amp;xin6, &amp;xin7);
253              aes_round&lt;SOFT_AES&gt;(k7, &amp;xin0, &amp;xin1, &amp;xin2, &amp;xin3, &amp;xin4, &amp;xin5, &amp;xin6, &amp;xin7);
254              aes_round&lt;SOFT_AES&gt;(k8, &amp;xin0, &amp;xin1, &amp;xin2, &amp;xin3, &amp;xin4, &amp;xin5, &amp;xin6, &amp;xin7);
255              aes_round&lt;SOFT_AES&gt;(k9, &amp;xin0, &amp;xin1, &amp;xin2, &amp;xin3, &amp;xin4, &amp;xin5, &amp;xin6, &amp;xin7);
256              mix_and_propagate(xin0, xin1, xin2, xin3, xin4, xin5, xin6, xin7);
257          }
258      }
259      constexpr int output_increment = (64 &lt;&lt; interleave) / sizeof(__m128i);
260      constexpr int prefetch_dist = 2048 / sizeof(__m128i);
261      __m128i* e = output + (N &lt;&lt; interleave) - prefetch_dist;
262      __m128i* prefetch_ptr = output + prefetch_dist;
263      for (int i = 0; i &lt; 2; ++i) {
264          do {
265              _mm_prefetch((const char*)(prefetch_ptr), _MM_HINT_T0);
266              _mm_prefetch((const char*)(prefetch_ptr + output_increment), _MM_HINT_T0);
267              aes_round&lt;SOFT_AES&gt;(k0, &amp;xin0, &amp;xin1, &amp;xin2, &amp;xin3, &amp;xin4, &amp;xin5, &amp;xin6, &amp;xin7);
268              aes_round&lt;SOFT_AES&gt;(k1, &amp;xin0, &amp;xin1, &amp;xin2, &amp;xin3, &amp;xin4, &amp;xin5, &amp;xin6, &amp;xin7);
269              aes_round&lt;SOFT_AES&gt;(k2, &amp;xin0, &amp;xin1, &amp;xin2, &amp;xin3, &amp;xin4, &amp;xin5, &amp;xin6, &amp;xin7);
270              aes_round&lt;SOFT_AES&gt;(k3, &amp;xin0, &amp;xin1, &amp;xin2, &amp;xin3, &amp;xin4, &amp;xin5, &amp;xin6, &amp;xin7);
271              aes_round&lt;SOFT_AES&gt;(k4, &amp;xin0, &amp;xin1, &amp;xin2, &amp;xin3, &amp;xin4, &amp;xin5, &amp;xin6, &amp;xin7);
272              aes_round&lt;SOFT_AES&gt;(k5, &amp;xin0, &amp;xin1, &amp;xin2, &amp;xin3, &amp;xin4, &amp;xin5, &amp;xin6, &amp;xin7);
273              aes_round&lt;SOFT_AES&gt;(k6, &amp;xin0, &amp;xin1, &amp;xin2, &amp;xin3, &amp;xin4, &amp;xin5, &amp;xin6, &amp;xin7);
274              aes_round&lt;SOFT_AES&gt;(k7, &amp;xin0, &amp;xin1, &amp;xin2, &amp;xin3, &amp;xin4, &amp;xin5, &amp;xin6, &amp;xin7);
275              aes_round&lt;SOFT_AES&gt;(k8, &amp;xin0, &amp;xin1, &amp;xin2, &amp;xin3, &amp;xin4, &amp;xin5, &amp;xin6, &amp;xin7);
276              aes_round&lt;SOFT_AES&gt;(k9, &amp;xin0, &amp;xin1, &amp;xin2, &amp;xin3, &amp;xin4, &amp;xin5, &amp;xin6, &amp;xin7);
277              _mm_store_si128(output + 0, xin0);
278              _mm_store_si128(output + 1, xin1);
279              _mm_store_si128(output + 2, xin2);
280              _mm_store_si128(output + 3, xin3);
281              _mm_store_si128(output + output_increment + 0, xin4);
282              _mm_store_si128(output + output_increment + 1, xin5);
283              _mm_store_si128(output + output_increment + 2, xin6);
284              _mm_store_si128(output + output_increment + 3, xin7);
285              output += output_increment * 2;
286              prefetch_ptr += output_increment * 2;
287          } while (output &lt; e);
288          e += prefetch_dist;
289          prefetch_ptr = output;
290      }
291      if (props.half_mem() &amp;&amp; ctx-&gt;first_half) {
292           __m128i* p = reinterpret_cast&lt;__m128i*&gt;(ctx-&gt;save_state);
293          _mm_store_si128(p + 0, xin0);
294          _mm_store_si128(p + 1, xin1);
295          _mm_store_si128(p + 2, xin2);
296          _mm_store_si128(p + 3, xin3);
297          _mm_store_si128(p + 4, xin4);
298          _mm_store_si128(p + 5, xin5);
299          _mm_store_si128(p + 6, xin6);
300          _mm_store_si128(p + 7, xin7);
301      }
302  }
303  template&lt;Algorithm::Id ALGO, bool SOFT_AES, int interleave&gt;
304  static NOINLINE void cn_implode_scratchpad(cryptonight_ctx *ctx)
305  {
306      constexpr CnAlgo&lt;ALGO&gt; props;
307  #   ifdef XMRIG_VAES
308      if (!SOFT_AES &amp;&amp; !props.isHeavy() &amp;&amp; cn_vaes_enabled) {
309          cn_implode_scratchpad_vaes(ctx, props.memory(), props.half_mem());
310          return;
311      }
312  #   endif
313      constexpr bool IS_HEAVY = props.isHeavy();
314      constexpr size_t N = (props.memory() / sizeof(__m128i)) / (props.half_mem() ? 2 : 1);
315      __m128i xout0, xout1, xout2, xout3, xout4, xout5, xout6, xout7;
316      __m128i k0, k1, k2, k3, k4, k5, k6, k7, k8, k9;
317      const __m128i *input = reinterpret_cast&lt;const __m128i*&gt;(ctx-&gt;memory);
318      __m128i *output = reinterpret_cast&lt;__m128i*&gt;(ctx-&gt;state);
319      aes_genkey&lt;SOFT_AES&gt;(output + 2, &amp;k0, &amp;k1, &amp;k2, &amp;k3, &amp;k4, &amp;k5, &amp;k6, &amp;k7, &amp;k8, &amp;k9);
320      xout0 = _mm_load_si128(output + 4);
321      xout1 = _mm_load_si128(output + 5);
322      xout2 = _mm_load_si128(output + 6);
323      xout3 = _mm_load_si128(output + 7);
324      xout4 = _mm_load_si128(output + 8);
325      xout5 = _mm_load_si128(output + 9);
326      xout6 = _mm_load_si128(output + 10);
327      xout7 = _mm_load_si128(output + 11);
328      const __m128i* input_begin = input;
329      for (size_t part = 0; part &lt; (props.half_mem() ? 2 : 1); ++part) {
330          if (props.half_mem() &amp;&amp; (part == 1)) {
331              input = input_begin;
332              ctx-&gt;first_half = false;
333              cn_explode_scratchpad&lt;ALGO, SOFT_AES, interleave&gt;(ctx);
334          }
335          for (size_t i = 0; i &lt; N;) {
336              xout0 = _mm_xor_si128(_mm_load_si128(input + 0), xout0);
337              xout1 = _mm_xor_si128(_mm_load_si128(input + 1), xout1);
338              xout2 = _mm_xor_si128(_mm_load_si128(input + 2), xout2);
339              xout3 = _mm_xor_si128(_mm_load_si128(input + 3), xout3);
340              constexpr int input_increment = (64 &lt;&lt; interleave) / sizeof(__m128i);
341              xout4 = _mm_xor_si128(_mm_load_si128(input + input_increment + 0), xout4);
342              xout5 = _mm_xor_si128(_mm_load_si128(input + input_increment + 1), xout5);
343              xout6 = _mm_xor_si128(_mm_load_si128(input + input_increment + 2), xout6);
344              xout7 = _mm_xor_si128(_mm_load_si128(input + input_increment + 3), xout7);
345              input += input_increment * 2;
346              i += 8;
347              if (i &lt; N) {
348                  _mm_prefetch((const char*)(input), _MM_HINT_T0);
349                  _mm_prefetch((const char*)(input + input_increment), _MM_HINT_T0);
350              }
351              aes_round&lt;SOFT_AES&gt;(k0, &amp;xout0, &amp;xout1, &amp;xout2, &amp;xout3, &amp;xout4, &amp;xout5, &amp;xout6, &amp;xout7);
352              aes_round&lt;SOFT_AES&gt;(k1, &amp;xout0, &amp;xout1, &amp;xout2, &amp;xout3, &amp;xout4, &amp;xout5, &amp;xout6, &amp;xout7);
353              aes_round&lt;SOFT_AES&gt;(k2, &amp;xout0, &amp;xout1, &amp;xout2, &amp;xout3, &amp;xout4, &amp;xout5, &amp;xout6, &amp;xout7);
354              aes_round&lt;SOFT_AES&gt;(k3, &amp;xout0, &amp;xout1, &amp;xout2, &amp;xout3, &amp;xout4, &amp;xout5, &amp;xout6, &amp;xout7);
355              aes_round&lt;SOFT_AES&gt;(k4, &amp;xout0, &amp;xout1, &amp;xout2, &amp;xout3, &amp;xout4, &amp;xout5, &amp;xout6, &amp;xout7);
356              aes_round&lt;SOFT_AES&gt;(k5, &amp;xout0, &amp;xout1, &amp;xout2, &amp;xout3, &amp;xout4, &amp;xout5, &amp;xout6, &amp;xout7);
357              aes_round&lt;SOFT_AES&gt;(k6, &amp;xout0, &amp;xout1, &amp;xout2, &amp;xout3, &amp;xout4, &amp;xout5, &amp;xout6, &amp;xout7);
358              aes_round&lt;SOFT_AES&gt;(k7, &amp;xout0, &amp;xout1, &amp;xout2, &amp;xout3, &amp;xout4, &amp;xout5, &amp;xout6, &amp;xout7);
359              aes_round&lt;SOFT_AES&gt;(k8, &amp;xout0, &amp;xout1, &amp;xout2, &amp;xout3, &amp;xout4, &amp;xout5, &amp;xout6, &amp;xout7);
360              aes_round&lt;SOFT_AES&gt;(k9, &amp;xout0, &amp;xout1, &amp;xout2, &amp;xout3, &amp;xout4, &amp;xout5, &amp;xout6, &amp;xout7);
361              if (IS_HEAVY) {
362                  mix_and_propagate(xout0, xout1, xout2, xout3, xout4, xout5, xout6, xout7);
363              }
364          }
365      }
366      if (IS_HEAVY) {
367          input = input_begin;
368          for (size_t i = 0; i &lt; N;) {
369              xout0 = _mm_xor_si128(_mm_load_si128(input + 0), xout0);
370              xout1 = _mm_xor_si128(_mm_load_si128(input + 1), xout1);
371              xout2 = _mm_xor_si128(_mm_load_si128(input + 2), xout2);
372              xout3 = _mm_xor_si128(_mm_load_si128(input + 3), xout3);
373              input += (64 &lt;&lt; interleave) / sizeof(__m128i);
374              xout4 = _mm_xor_si128(_mm_load_si128(input + 0), xout4);
375              xout5 = _mm_xor_si128(_mm_load_si128(input + 1), xout5);
376              xout6 = _mm_xor_si128(_mm_load_si128(input + 2), xout6);
377              xout7 = _mm_xor_si128(_mm_load_si128(input + 3), xout7);
378              input += (64 &lt;&lt; interleave) / sizeof(__m128i);
379              i += 8;
380              if ((interleave &gt; 0) &amp;&amp; (i &lt; props.memory() / sizeof(__m128i))) {
381                  _mm_prefetch((const char*)(input), _MM_HINT_T0);
382                  _mm_prefetch((const char*)(input + (64 &lt;&lt; interleave) / sizeof(__m128i)), _MM_HINT_T0);
383              }
384              aes_round&lt;SOFT_AES&gt;(k0, &amp;xout0, &amp;xout1, &amp;xout2, &amp;xout3, &amp;xout4, &amp;xout5, &amp;xout6, &amp;xout7);
385              aes_round&lt;SOFT_AES&gt;(k1, &amp;xout0, &amp;xout1, &amp;xout2, &amp;xout3, &amp;xout4, &amp;xout5, &amp;xout6, &amp;xout7);
386              aes_round&lt;SOFT_AES&gt;(k2, &amp;xout0, &amp;xout1, &amp;xout2, &amp;xout3, &amp;xout4, &amp;xout5, &amp;xout6, &amp;xout7);
387              aes_round&lt;SOFT_AES&gt;(k3, &amp;xout0, &amp;xout1, &amp;xout2, &amp;xout3, &amp;xout4, &amp;xout5, &amp;xout6, &amp;xout7);
388              aes_round&lt;SOFT_AES&gt;(k4, &amp;xout0, &amp;xout1, &amp;xout2, &amp;xout3, &amp;xout4, &amp;xout5, &amp;xout6, &amp;xout7);
389              aes_round&lt;SOFT_AES&gt;(k5, &amp;xout0, &amp;xout1, &amp;xout2, &amp;xout3, &amp;xout4, &amp;xout5, &amp;xout6, &amp;xout7);
390              aes_round&lt;SOFT_AES&gt;(k6, &amp;xout0, &amp;xout1, &amp;xout2, &amp;xout3, &amp;xout4, &amp;xout5, &amp;xout6, &amp;xout7);
391              aes_round&lt;SOFT_AES&gt;(k7, &amp;xout0, &amp;xout1, &amp;xout2, &amp;xout3, &amp;xout4, &amp;xout5, &amp;xout6, &amp;xout7);
392              aes_round&lt;SOFT_AES&gt;(k8, &amp;xout0, &amp;xout1, &amp;xout2, &amp;xout3, &amp;xout4, &amp;xout5, &amp;xout6, &amp;xout7);
393              aes_round&lt;SOFT_AES&gt;(k9, &amp;xout0, &amp;xout1, &amp;xout2, &amp;xout3, &amp;xout4, &amp;xout5, &amp;xout6, &amp;xout7);
394              mix_and_propagate(xout0, xout1, xout2, xout3, xout4, xout5, xout6, xout7);
395          }
396          for (size_t i = 0; i &lt; 16; i++) {
397              aes_round&lt;SOFT_AES&gt;(k0, &amp;xout0, &amp;xout1, &amp;xout2, &amp;xout3, &amp;xout4, &amp;xout5, &amp;xout6, &amp;xout7);
398              aes_round&lt;SOFT_AES&gt;(k1, &amp;xout0, &amp;xout1, &amp;xout2, &amp;xout3, &amp;xout4, &amp;xout5, &amp;xout6, &amp;xout7);
399              aes_round&lt;SOFT_AES&gt;(k2, &amp;xout0, &amp;xout1, &amp;xout2, &amp;xout3, &amp;xout4, &amp;xout5, &amp;xout6, &amp;xout7);
400              aes_round&lt;SOFT_AES&gt;(k3, &amp;xout0, &amp;xout1, &amp;xout2, &amp;xout3, &amp;xout4, &amp;xout5, &amp;xout6, &amp;xout7);
401              aes_round&lt;SOFT_AES&gt;(k4, &amp;xout0, &amp;xout1, &amp;xout2, &amp;xout3, &amp;xout4, &amp;xout5, &amp;xout6, &amp;xout7);
402              aes_round&lt;SOFT_AES&gt;(k5, &amp;xout0, &amp;xout1, &amp;xout2, &amp;xout3, &amp;xout4, &amp;xout5, &amp;xout6, &amp;xout7);
403              aes_round&lt;SOFT_AES&gt;(k6, &amp;xout0, &amp;xout1, &amp;xout2, &amp;xout3, &amp;xout4, &amp;xout5, &amp;xout6, &amp;xout7);
404              aes_round&lt;SOFT_AES&gt;(k7, &amp;xout0, &amp;xout1, &amp;xout2, &amp;xout3, &amp;xout4, &amp;xout5, &amp;xout6, &amp;xout7);
405              aes_round&lt;SOFT_AES&gt;(k8, &amp;xout0, &amp;xout1, &amp;xout2, &amp;xout3, &amp;xout4, &amp;xout5, &amp;xout6, &amp;xout7);
406              aes_round&lt;SOFT_AES&gt;(k9, &amp;xout0, &amp;xout1, &amp;xout2, &amp;xout3, &amp;xout4, &amp;xout5, &amp;xout6, &amp;xout7);
407              mix_and_propagate(xout0, xout1, xout2, xout3, xout4, xout5, xout6, xout7);
408          }
409      }
410      _mm_store_si128(output + 4, xout0);
411      _mm_store_si128(output + 5, xout1);
412      _mm_store_si128(output + 6, xout2);
413      _mm_store_si128(output + 7, xout3);
414      _mm_store_si128(output + 8, xout4);
415      _mm_store_si128(output + 9, xout5);
416      _mm_store_si128(output + 10, xout6);
417      _mm_store_si128(output + 11, xout7);
418  }
419  } &amp;bsol;* namespace xmrig */
420  static inline __m128i aes_round_tweak_div(const __m128i &amp;in, const __m128i &amp;key)
421  {
422      alignas(16) uint32_t k[4];
423      alignas(16) uint32_t x[4];
424      _mm_store_si128((__m128i*) k, key);
425      _mm_store_si128((__m128i*) x, _mm_xor_si128(in, _mm_set_epi64x(0xffffffffffffffff, 0xffffffffffffffff)));
426      #define BYTE(p, i) ((unsigned char*)&amp;x[p])[i]
427      k[0] ^= saes_table[0][BYTE(0, 0)] ^ saes_table[1][BYTE(1, 1)] ^ saes_table[2][BYTE(2, 2)] ^ saes_table[3][BYTE(3, 3)];
428      x[0] ^= k[0];
429      k[1] ^= saes_table[0][BYTE(1, 0)] ^ saes_table[1][BYTE(2, 1)] ^ saes_table[2][BYTE(3, 2)] ^ saes_table[3][BYTE(0, 3)];
430      x[1] ^= k[1];
431      k[2] ^= saes_table[0][BYTE(2, 0)] ^ saes_table[1][BYTE(3, 1)] ^ saes_table[2][BYTE(0, 2)] ^ saes_table[3][BYTE(1, 3)];
432      x[2] ^= k[2];
433      k[3] ^= saes_table[0][BYTE(3, 0)] ^ saes_table[1][BYTE(0, 1)] ^ saes_table[2][BYTE(1, 2)] ^ saes_table[3][BYTE(2, 3)];
434      #undef BYTE
435      return _mm_load_si128((__m128i*)k);
436  }
437  static inline __m128i int_sqrt_v2(const uint64_t n0)
438  {
439      __m128d x = _mm_castsi128_pd(_mm_add_epi64(_mm_cvtsi64_si128(n0 &gt;&gt; 12), _mm_set_epi64x(0, 1023ULL &lt;&lt; 52)));
440      x = _mm_sqrt_sd(_mm_setzero_pd(), x);
441      uint64_t r = static_cast&lt;uint64_t&gt;(_mm_cvtsi128_si64(_mm_castpd_si128(x)));
442      const uint64_t s = r &gt;&gt; 20;
443      r &gt;&gt;= 19;
444      uint64_t x2 = (s - (1022ULL &lt;&lt; 32)) * (r - s - (1022ULL &lt;&lt; 32) + 1);
445  #   if (defined(_MSC_VER) || __GNUC__ &gt; 7 || (__GNUC__ == 7 &amp;&amp; __GNUC_MINOR__ &gt; 1)) &amp;&amp; (defined(__x86_64__) || defined(_M_AMD64))
446      _addcarry_u64(_subborrow_u64(0, x2, n0, (unsigned long long int*)&amp;x2), r, 0, (unsigned long long int*)&amp;r);
447  #   else
448      if (x2 &lt; n0) ++r;
449  #   endif
450      return _mm_cvtsi64_si128(r);
451  }
452  void v4_soft_aes_compile_code(const V4_Instruction *code, int code_size, void *machine_code, xmrig::Assembly ASM);
453  alignas(64) static const uint32_t tweak1_table[256] = { 268435456,0,268435456,0,268435456,0,268435456,0,268435456,0,268435456,0,268435456,0,268435456,0,805306368,0,805306368,0,805306368,0,805306368,0,805306368,0,805306368,0,805306368,0,805306368,0,268435456,268435456,268435456,268435456,268435456,268435456,268435456,268435456,268435456,268435456,268435456,268435456,268435456,268435456,268435456,268435456,805306368,268435456,805306368,268435456,805306368,268435456,805306368,268435456,805306368,268435456,805306368,268435456,805306368,268435456,805306368,268435456,268435456,0,268435456,0,268435456,0,268435456,0,268435456,0,268435456,0,268435456,0,268435456,0,805306368,0,805306368,0,805306368,0,805306368,0,805306368,0,805306368,0,805306368,0,805306368,0,268435456,268435456,268435456,268435456,268435456,268435456,268435456,268435456,268435456,268435456,268435456,268435456,268435456,268435456,268435456,268435456,805306368,268435456,805306368,268435456,805306368,268435456,805306368,268435456,805306368,268435456,805306368,268435456,805306368,268435456,805306368,268435456,268435456,0,268435456,0,268435456,0,268435456,0,268435456,0,268435456,0,268435456,0,268435456,0,805306368,0,805306368,0,805306368,0,805306368,0,805306368,0,805306368,0,805306368,0,805306368,0,268435456,268435456,268435456,268435456,268435456,268435456,268435456,268435456,268435456,268435456,268435456,268435456,268435456,268435456,268435456,268435456,805306368,268435456,805306368,268435456,805306368,268435456,805306368,268435456,805306368,268435456,805306368,268435456,805306368,268435456,805306368,268435456,268435456,0,268435456,0,268435456,0,268435456,0,268435456,0,268435456,0,268435456,0,268435456,0,805306368,0,805306368,0,805306368,0,805306368,0,805306368,0,805306368,0,805306368,0,805306368,0,268435456,268435456,268435456,268435456,268435456,268435456,268435456,268435456,268435456,268435456,268435456,268435456,268435456,268435456,268435456,268435456,805306368,268435456,805306368,268435456,805306368,268435456,805306368,268435456,805306368,268435456,805306368,268435456,805306368,268435456,805306368,268435456 };
454  namespace xmrig {
455  template&lt;Algorithm::Id ALGO&gt;
456  static inline void cryptonight_monero_tweak(uint64_t *mem_out, const uint8_t *l, uint64_t idx, __m128i ax0, __m128i bx0, __m128i bx1, __m128i&amp; cx)
457  {
458      constexpr CnAlgo&lt;ALGO&gt; props;
459      if (props.base() == Algorithm::CN_2) {
460          VARIANT2_SHUFFLE(l, idx, ax0, bx0, bx1, cx, (((ALGO == Algorithm::CN_RWZ) || (ALGO == Algorithm::CN_UPX2)) ? 1 : 0));
461          _mm_store_si128(reinterpret_cast&lt;__m128i *&gt;(mem_out), _mm_xor_si128(bx0, cx));
462      } else {
463          __m128i tmp = _mm_xor_si128(bx0, cx);
464          mem_out[0] = _mm_cvtsi128_si64(tmp);
465          tmp = _mm_castps_si128(_mm_movehl_ps(_mm_castsi128_ps(tmp), _mm_castsi128_ps(tmp)));
466          uint64_t vh = _mm_cvtsi128_si64(tmp);
467          mem_out[1] = vh ^ tweak1_table[static_cast&lt;uint32_t&gt;(vh) &gt;&gt; 24];
468      }
469  }
470  static inline void cryptonight_conceal_tweak(__m128i&amp; cx, __m128&amp; conc_var)
471  {
472      __m128 r = _mm_add_ps(_mm_cvtepi32_ps(cx), conc_var);
473      r = _mm_mul_ps(r, _mm_mul_ps(r, r));
474      r = _mm_and_ps(_mm_castsi128_ps(_mm_set1_epi32(0x807FFFFF)), r);
475      r = _mm_or_ps(_mm_castsi128_ps(_mm_set1_epi32(0x40000000)), r);
476      __m128 c_old = conc_var;
477      conc_var = _mm_add_ps(conc_var, r);
478      c_old = _mm_and_ps(_mm_castsi128_ps(_mm_set1_epi32(0x807FFFFF)), c_old);
479      c_old = _mm_or_ps(_mm_castsi128_ps(_mm_set1_epi32(0x40000000)), c_old);
480      __m128 nc = _mm_mul_ps(c_old, _mm_set1_ps(536870880.0f));
481      cx = _mm_xor_si128(cx, _mm_cvttps_epi32(nc));
482  }
483  #ifdef XMRIG_FEATURE_ASM
484  template&lt;Algorithm::Id ALGO&gt;
485  static void cryptonight_single_hash_gr_sse41(const uint8_t* __restrict__ input, size_t size, uint8_t* __restrict__ output, cryptonight_ctx** __restrict__ ctx, uint64_t height);
486  #endif
487  template&lt;Algorithm::Id ALGO, bool SOFT_AES, int interleave&gt;
488  inline void cryptonight_single_hash(const uint8_t *__restrict__ input, size_t size, uint8_t *__restrict__ output, cryptonight_ctx **__restrict__ ctx, uint64_t height)
489  {
490  #   ifdef XMRIG_FEATURE_ASM
491      if (!SOFT_AES) {
492          switch (ALGO) {
493          case Algorithm::CN_GR_0:
494          case Algorithm::CN_GR_1:
495          case Algorithm::CN_GR_2:
496          case Algorithm::CN_GR_3:
497          case Algorithm::CN_GR_4:
498          case Algorithm::CN_GR_5:
499              if (cn_sse41_enabled) {
500                  cryptonight_single_hash_gr_sse41&lt;ALGO&gt;(input, size, output, ctx, height);
501                  return;
502              }
503              break;
504          default:
505              break;
506          }
507      }
508  #   endif
509      constexpr CnAlgo&lt;ALGO&gt; props;
510      constexpr size_t MASK        = props.mask();
511      constexpr Algorithm::Id BASE = props.base();
512  #   ifdef XMRIG_ALGO_CN_HEAVY
513      constexpr bool IS_CN_HEAVY_TUBE = ALGO == Algorithm::CN_HEAVY_TUBE;
514  #   else
515      constexpr bool IS_CN_HEAVY_TUBE = false;
516  #   endif
517      if (BASE == Algorithm::CN_1 &amp;&amp; size &lt; 43) {
518          memset(output, 0, 32);
519          return;
520      }
521      keccak(input, size, ctx[0]-&gt;state);
522      if (props.half_mem()) {
523          ctx[0]-&gt;first_half = true;
524      }
525      cn_explode_scratchpad&lt;ALGO, SOFT_AES, interleave&gt;(ctx[0]);
526      uint64_t *h0 = reinterpret_cast&lt;uint64_t*&gt;(ctx[0]-&gt;state);
527      uint8_t *l0   = ctx[0]-&gt;memory;
528  #   ifdef XMRIG_FEATURE_ASM
529      if (SOFT_AES &amp;&amp; props.isR()) {
530          if (!ctx[0]-&gt;generated_code_data.match(ALGO, height)) {
531              V4_Instruction code[256];
532              const int code_size = v4_random_math_init&lt;ALGO&gt;(code, height);
533              if (ALGO == Algorithm::CN_R) {
534                  v4_soft_aes_compile_code(code, code_size, reinterpret_cast&lt;void*&gt;(ctx[0]-&gt;generated_code), Assembly::NONE);
535              }
536              ctx[0]-&gt;generated_code_data = { ALGO, height };
537          }
538          ctx[0]-&gt;saes_table = reinterpret_cast&lt;const uint32_t*&gt;(saes_table);
539          ctx[0]-&gt;generated_code(ctx);
540      } else {
541  #   endif
542      VARIANT1_INIT(0);
543      VARIANT2_INIT(0);
544      VARIANT2_SET_ROUNDING_MODE();
545      VARIANT4_RANDOM_MATH_INIT(0);
546      uint64_t al0  = h0[0] ^ h0[4];
547      uint64_t ah0  = h0[1] ^ h0[5];
548      uint64_t idx0 = al0;
549      __m128i bx0   = _mm_set_epi64x(static_cast&lt;int64_t&gt;(h0[3] ^ h0[7]), static_cast&lt;int64_t&gt;(h0[2] ^ h0[6]));
550      __m128i bx1   = _mm_set_epi64x(static_cast&lt;int64_t&gt;(h0[9] ^ h0[11]), static_cast&lt;int64_t&gt;(h0[8] ^ h0[10]));
551      __m128 conc_var;
552      if (ALGO == Algorithm::CN_CCX) {
553          conc_var = _mm_setzero_ps();
554          RESTORE_ROUNDING_MODE();
555      }
556      for (size_t i = 0; i &lt; props.iterations(); i++) {
557          __m128i cx;
558          if (IS_CN_HEAVY_TUBE || !SOFT_AES) {
559              cx = _mm_load_si128(reinterpret_cast&lt;const __m128i *&gt;(&amp;l0[interleaved_index&lt;interleave&gt;(idx0 &amp; MASK)]));
560              if (ALGO == Algorithm::CN_CCX) {
561                  cryptonight_conceal_tweak(cx, conc_var);
562              }
563          }
564          const __m128i ax0 = _mm_set_epi64x(static_cast&lt;int64_t&gt;(ah0), static_cast&lt;int64_t&gt;(al0));
565          if (IS_CN_HEAVY_TUBE) {
566              cx = aes_round_tweak_div(cx, ax0);
567          }
568          else if (SOFT_AES) {
569              if (ALGO == Algorithm::CN_CCX) {
570                  cx = _mm_load_si128(reinterpret_cast&lt;const __m128i*&gt;(&amp;l0[interleaved_index&lt;interleave&gt;(idx0 &amp; MASK)]));
571                  cryptonight_conceal_tweak(cx, conc_var);
572                  cx = soft_aesenc(&amp;cx, ax0, reinterpret_cast&lt;const uint32_t*&gt;(saes_table));
573              }
574              else {
575                  cx = soft_aesenc(&amp;l0[interleaved_index&lt;interleave&gt;(idx0 &amp; MASK)], ax0, reinterpret_cast&lt;const uint32_t*&gt;(saes_table));
576              }
577          }
578          else {
579              cx = _mm_aesenc_si128(cx, ax0);
580          }
581          if (BASE == Algorithm::CN_1 || BASE == Algorithm::CN_2) {
582              cryptonight_monero_tweak&lt;ALGO&gt;(reinterpret_cast&lt;uint64_t*&gt;(&amp;l0[interleaved_index&lt;interleave&gt;(idx0 &amp; MASK)]), l0, idx0 &amp; MASK, ax0, bx0, bx1, cx);
583          } else {
584              _mm_store_si128(reinterpret_cast&lt;__m128i *&gt;(&amp;l0[interleaved_index&lt;interleave&gt;(idx0 &amp; MASK)]), _mm_xor_si128(bx0, cx));
585          }
586          idx0 = static_cast&lt;uint64_t&gt;(_mm_cvtsi128_si64(cx));
587          uint64_t hi, lo, cl, ch;
588          cl = (reinterpret_cast&lt;uint64_t*&gt;(&amp;l0[interleaved_index&lt;interleave&gt;(idx0 &amp; MASK)]))[0];
589          ch = (reinterpret_cast&lt;uint64_t*&gt;(&amp;l0[interleaved_index&lt;interleave&gt;(idx0 &amp; MASK)]))[1];
590          if (BASE == Algorithm::CN_2) {
591              if (props.isR()) {
592                  VARIANT4_RANDOM_MATH(0, al0, ah0, cl, bx0, bx1);
593                  if (ALGO == Algorithm::CN_R) {
594                      al0 ^= r0[2] | (static_cast&lt;uint64_t&gt;(r0[3]) &lt;&lt; 32);
595                      ah0 ^= r0[0] | (static_cast&lt;uint64_t&gt;(r0[1]) &lt;&lt; 32);
596                  }
597              } else {
598                  VARIANT2_INTEGER_MATH(0, cl, cx);
599              }
600          }
601          lo = __umul128(idx0, cl, &amp;hi);
602          if (BASE == Algorithm::CN_2) {
603              if (ALGO == Algorithm::CN_R) {
604                  VARIANT2_SHUFFLE(l0, idx0 &amp; MASK, ax0, bx0, bx1, cx, 0);
605              } else {
606                  VARIANT2_SHUFFLE2(l0, idx0 &amp; MASK, ax0, bx0, bx1, hi, lo, (((ALGO == Algorithm::CN_RWZ) || (ALGO == Algorithm::CN_UPX2)) ? 1 : 0));
607              }
608          }
609          al0 += hi;
610          ah0 += lo;
611          reinterpret_cast&lt;uint64_t*&gt;(&amp;l0[interleaved_index&lt;interleave&gt;(idx0 &amp; MASK)])[0] = al0;
612          if (IS_CN_HEAVY_TUBE || ALGO == Algorithm::CN_RTO) {
613              reinterpret_cast&lt;uint64_t*&gt;(&amp;l0[interleaved_index&lt;interleave&gt;(idx0 &amp; MASK)])[1] = ah0 ^ tweak1_2_0 ^ al0;
614          } else if (BASE == Algorithm::CN_1) {
615              reinterpret_cast&lt;uint64_t*&gt;(&amp;l0[interleaved_index&lt;interleave&gt;(idx0 &amp; MASK)])[1] = ah0 ^ tweak1_2_0;
616          } else {
617              reinterpret_cast&lt;uint64_t*&gt;(&amp;l0[interleaved_index&lt;interleave&gt;(idx0 &amp; MASK)])[1] = ah0;
618          }
619          al0 ^= cl;
620          ah0 ^= ch;
621          idx0 = al0;
622  #       ifdef XMRIG_ALGO_CN_HEAVY
623          if (props.isHeavy()) {
624              int64_t n = ((int64_t*)&amp;l0[interleaved_index&lt;interleave&gt;(idx0 &amp; MASK)])[0];
625              int64_t d = ((int32_t*)&amp;l0[interleaved_index&lt;interleave&gt;(idx0 &amp; MASK)])[2];
626              int64_t d5;
627  #           if defined(_MSC_VER) || (defined(__GNUC__) &amp;&amp; (__GNUC__ == 8)) || !defined(XMRIG_64_BIT)
628              d5 = d | 5;
629  #           else
630              asm(&quot;mov %1, %0\n\tor $5, %0&quot; : &quot;=r&quot;(d5) : &quot;r&quot;(d));
631  #           endif
632              int64_t q = n / d5;
633              ((int64_t*)&amp;l0[interleaved_index&lt;interleave&gt;(idx0 &amp; MASK)])[0] = n ^ q;
634              if (ALGO == Algorithm::CN_HEAVY_XHV) {
635                  d = ~d;
636              }
637              idx0 = d ^ q;
638          }
639  #       endif
640          if (BASE == Algorithm::CN_2) {
641              bx1 = bx0;
642          }
643          bx0 = cx;
644      }
645  #   ifdef XMRIG_FEATURE_ASM
646      }
647  #   endif
648      cn_implode_scratchpad&lt;ALGO, SOFT_AES, interleave&gt;(ctx[0]);
649      keccakf(h0, 24);
650      extra_hashes[ctx[0]-&gt;state[0] &amp; 3](ctx[0]-&gt;state, 200, output);
651  }
652  } &amp;bsol;* namespace xmrig */
653  #ifdef XMRIG_FEATURE_ASM
654  extern &quot;C&quot; void cnv1_single_mainloop_asm(cryptonight_ctx * *ctx);
655  extern &quot;C&quot; void cnv1_double_mainloop_asm(cryptonight_ctx **ctx);
656  extern &quot;C&quot; void cnv1_quad_mainloop_asm(cryptonight_ctx **ctx);
657  extern &quot;C&quot; void cnv2_mainloop_ivybridge_asm(cryptonight_ctx **ctx);
658  extern &quot;C&quot; void cnv2_mainloop_ryzen_asm(cryptonight_ctx **ctx);
659  extern &quot;C&quot; void cnv2_mainloop_bulldozer_asm(cryptonight_ctx **ctx);
660  extern &quot;C&quot; void cnv2_double_mainloop_sandybridge_asm(cryptonight_ctx **ctx);
661  extern &quot;C&quot; void cnv2_rwz_mainloop_asm(cryptonight_ctx **ctx);
662  extern &quot;C&quot; void cnv2_rwz_double_mainloop_asm(cryptonight_ctx **ctx);
663  extern &quot;C&quot; void cnv2_upx_double_mainloop_zen3_asm(cryptonight_ctx **ctx);
664  namespace xmrig {
665  typedef void (*cn_mainloop_fun)(cryptonight_ctx **ctx);
666  extern cn_mainloop_fun cn_half_mainloop_ivybridge_asm;
667  extern cn_mainloop_fun cn_half_mainloop_ryzen_asm;
668  extern cn_mainloop_fun cn_half_mainloop_bulldozer_asm;
669  extern cn_mainloop_fun cn_half_double_mainloop_sandybridge_asm;
670  extern cn_mainloop_fun cn_trtl_mainloop_ivybridge_asm;
671  extern cn_mainloop_fun cn_trtl_mainloop_ryzen_asm;
672  extern cn_mainloop_fun cn_trtl_mainloop_bulldozer_asm;
673  extern cn_mainloop_fun cn_trtl_double_mainloop_sandybridge_asm;
674  extern cn_mainloop_fun cn_tlo_mainloop_ivybridge_asm;
675  extern cn_mainloop_fun cn_tlo_mainloop_ryzen_asm;
676  extern cn_mainloop_fun cn_tlo_mainloop_bulldozer_asm;
677  extern cn_mainloop_fun cn_tlo_double_mainloop_sandybridge_asm;
678  extern cn_mainloop_fun cn_zls_mainloop_ivybridge_asm;
679  extern cn_mainloop_fun cn_zls_mainloop_ryzen_asm;
680  extern cn_mainloop_fun cn_zls_mainloop_bulldozer_asm;
681  extern cn_mainloop_fun cn_zls_double_mainloop_sandybridge_asm;
682  extern cn_mainloop_fun cn_double_mainloop_ivybridge_asm;
683  extern cn_mainloop_fun cn_double_mainloop_ryzen_asm;
684  extern cn_mainloop_fun cn_double_mainloop_bulldozer_asm;
685  extern cn_mainloop_fun cn_double_double_mainloop_sandybridge_asm;
686  extern cn_mainloop_fun cn_upx2_mainloop_asm;
687  extern cn_mainloop_fun cn_upx2_double_mainloop_asm;
688  extern cn_mainloop_fun cn_gr0_single_mainloop_asm;
689  extern cn_mainloop_fun cn_gr1_single_mainloop_asm;
690  extern cn_mainloop_fun cn_gr2_single_mainloop_asm;
691  extern cn_mainloop_fun cn_gr3_single_mainloop_asm;
692  extern cn_mainloop_fun cn_gr4_single_mainloop_asm;
693  extern cn_mainloop_fun cn_gr5_single_mainloop_asm;
694  extern cn_mainloop_fun cn_gr0_double_mainloop_asm;
695  extern cn_mainloop_fun cn_gr1_double_mainloop_asm;
696  extern cn_mainloop_fun cn_gr2_double_mainloop_asm;
697  extern cn_mainloop_fun cn_gr3_double_mainloop_asm;
698  extern cn_mainloop_fun cn_gr4_double_mainloop_asm;
699  extern cn_mainloop_fun cn_gr5_double_mainloop_asm;
700  extern cn_mainloop_fun cn_gr0_quad_mainloop_asm;
701  extern cn_mainloop_fun cn_gr1_quad_mainloop_asm;
702  extern cn_mainloop_fun cn_gr2_quad_mainloop_asm;
703  extern cn_mainloop_fun cn_gr3_quad_mainloop_asm;
704  extern cn_mainloop_fun cn_gr4_quad_mainloop_asm;
705  extern cn_mainloop_fun cn_gr5_quad_mainloop_asm;
706  } 
707  void v4_compile_code(const V4_Instruction* code, int code_size, void* machine_code, xmrig::Assembly ASM);
708  void v4_compile_code_double(const V4_Instruction* code, int code_size, void* machine_code, xmrig::Assembly ASM);
709  template&lt;xmrig::Algorithm::Id ALGO&gt;
710  void cn_r_compile_code(const V4_Instruction* code, int code_size, void* machine_code, xmrig::Assembly ASM)
711  {
712      v4_compile_code(code, code_size, machine_code, ASM);
713  }
714  template&lt;xmrig::Algorithm::Id ALGO&gt;
715  void cn_r_compile_code_double(const V4_Instruction* code, int code_size, void* machine_code, xmrig::Assembly ASM)
716  {
717      v4_compile_code_double(code, code_size, machine_code, ASM);
718  }
719  namespace xmrig {
720  template&lt;Algorithm::Id ALGO, Assembly::Id ASM&gt;
721  inline void cryptonight_single_hash_asm(const uint8_t *__restrict__ input, size_t size, uint8_t *__restrict__ output, cryptonight_ctx **__restrict__ ctx, uint64_t height)
722  {
723      constexpr CnAlgo&lt;ALGO&gt; props;
724      if (props.isR() &amp;&amp; !ctx[0]-&gt;generated_code_data.match(ALGO, height)) {
725          V4_Instruction code[256];
726          const int code_size = v4_random_math_init&lt;ALGO&gt;(code, height);
727          cn_r_compile_code&lt;ALGO&gt;(code, code_size, reinterpret_cast&lt;void*&gt;(ctx[0]-&gt;generated_code), ASM);
728          ctx[0]-&gt;generated_code_data = { ALGO, height };
729      }
730      keccak(input, size, ctx[0]-&gt;state);
731      if (props.half_mem()) {
732          ctx[0]-&gt;first_half = true;
733      }
734      cn_explode_scratchpad&lt;ALGO, false, 0&gt;(ctx[0]);
735      if (ALGO == Algorithm::CN_2) {
736          if (ASM == Assembly::INTEL) {
737              cnv2_mainloop_ivybridge_asm(ctx);
738          }
739          else if (ASM == Assembly::RYZEN) {
740              cnv2_mainloop_ryzen_asm(ctx);
741          }
742          else {
743              cnv2_mainloop_bulldozer_asm(ctx);
744          }
745      }
746      else if (ALGO == Algorithm::CN_HALF) {
747          if (ASM == Assembly::INTEL) {
748              cn_half_mainloop_ivybridge_asm(ctx);
749          }
750          else if (ASM == Assembly::RYZEN) {
751              cn_half_mainloop_ryzen_asm(ctx);
752          }
753          else {
754              cn_half_mainloop_bulldozer_asm(ctx);
755          }
756      }
757  #   ifdef XMRIG_ALGO_CN_PICO
758      else if (ALGO == Algorithm::CN_PICO_0) {
759          if (ASM == Assembly::INTEL) {
760              cn_trtl_mainloop_ivybridge_asm(ctx);
761          }
762          else if (ASM == Assembly::RYZEN) {
763              cn_trtl_mainloop_ryzen_asm(ctx);
764          }
765          else {
766              cn_trtl_mainloop_bulldozer_asm(ctx);
767          }
768      }
769      else if (ALGO == Algorithm::CN_PICO_TLO) {
770          if (ASM == Assembly::INTEL) {
771              cn_tlo_mainloop_ivybridge_asm(ctx);
772          }
773          else if (ASM == Assembly::RYZEN) {
774              cn_tlo_mainloop_ryzen_asm(ctx);
775          }
776          else {
777              cn_tlo_mainloop_bulldozer_asm(ctx);
778          }
779      }
780  #   endif
781      else if (ALGO == Algorithm::CN_RWZ) {
782          cnv2_rwz_mainloop_asm(ctx);
783      }
784      else if (ALGO == Algorithm::CN_ZLS) {
785          if (ASM == Assembly::INTEL) {
786              cn_zls_mainloop_ivybridge_asm(ctx);
787          }
788          else if (ASM == Assembly::RYZEN) {
789              cn_zls_mainloop_ryzen_asm(ctx);
790          }
791          else {
792              cn_zls_mainloop_bulldozer_asm(ctx);
793          }
794      }
795      else if (ALGO == Algorithm::CN_DOUBLE) {
796          if (ASM == Assembly::INTEL) {
797              cn_double_mainloop_ivybridge_asm(ctx);
798          }
799          else if (ASM == Assembly::RYZEN) {
800              cn_double_mainloop_ryzen_asm(ctx);
801          }
802          else {
803              cn_double_mainloop_bulldozer_asm(ctx);
804          }
805      }
806  #   ifdef XMRIG_ALGO_CN_FEMTO
807      else if (ALGO == Algorithm::CN_UPX2) {
808          cn_upx2_mainloop_asm(ctx);
809      }
810  #   endif
811      else if (props.isR()) {
812          ctx[0]-&gt;generated_code(ctx);
813      }
814      cn_implode_scratchpad&lt;ALGO, false, 0&gt;(ctx[0]);
815      keccakf(reinterpret_cast&lt;uint64_t*&gt;(ctx[0]-&gt;state), 24);
816      extra_hashes[ctx[0]-&gt;state[0] &amp; 3](ctx[0]-&gt;state, 200, output);
817  }
818  template&lt;Algorithm::Id ALGO, Assembly::Id ASM&gt;
819  inline void cryptonight_double_hash_asm(const uint8_t *__restrict__ input, size_t size, uint8_t *__restrict__ output, cryptonight_ctx **__restrict__ ctx, uint64_t height)
820  {
821      constexpr CnAlgo&lt;ALGO&gt; props;
822      if (props.isR() &amp;&amp; !ctx[0]-&gt;generated_code_data.match(ALGO, height)) {
823          V4_Instruction code[256];
824          const int code_size = v4_random_math_init&lt;ALGO&gt;(code, height);
825          cn_r_compile_code_double&lt;ALGO&gt;(code, code_size, reinterpret_cast&lt;void*&gt;(ctx[0]-&gt;generated_code), ASM);
826          ctx[0]-&gt;generated_code_data = { ALGO, height };
827      }
828      keccak(input,        size, ctx[0]-&gt;state);
829      keccak(input + size, size, ctx[1]-&gt;state);
830      if (props.half_mem()) {
831          ctx[0]-&gt;first_half = true;
832          ctx[1]-&gt;first_half = true;
833      }
834  #   ifdef XMRIG_VAES
835      if (!props.isHeavy() &amp;&amp; cn_vaes_enabled) {
836          cn_explode_scratchpad_vaes_double(ctx[0], ctx[1], props.memory(), props.half_mem());
837      }
838      else
839  #   endif
840      {
841          cn_explode_scratchpad&lt;ALGO, false, 0&gt;(ctx[0]);
842          cn_explode_scratchpad&lt;ALGO, false, 0&gt;(ctx[1]);
843      }
844      if (ALGO == Algorithm::CN_2) {
845          cnv2_double_mainloop_sandybridge_asm(ctx);
846      }
847      else if (ALGO == Algorithm::CN_HALF) {
848          cn_half_double_mainloop_sandybridge_asm(ctx);
849      }
850  #   ifdef XMRIG_ALGO_CN_PICO
851      else if (ALGO == Algorithm::CN_PICO_0) {
852          cn_trtl_double_mainloop_sandybridge_asm(ctx);
853      }
854      else if (ALGO == Algorithm::CN_PICO_TLO) {
855          cn_tlo_double_mainloop_sandybridge_asm(ctx);
856      }
857  #   endif
858  #   ifdef XMRIG_ALGO_CN_FEMTO
859      else if (ALGO == Algorithm::CN_UPX2) {
860          if (Cpu::info()-&gt;arch() == ICpuInfo::ARCH_ZEN3) {
861              cnv2_upx_double_mainloop_zen3_asm(ctx);
862          }
863          else {
864              cn_upx2_double_mainloop_asm(ctx);
865          }
866      }
867  #   endif
868      else if (ALGO == Algorithm::CN_RWZ) {
869          cnv2_rwz_double_mainloop_asm(ctx);
870      }
871      else if (ALGO == Algorithm::CN_ZLS) {
872          cn_zls_double_mainloop_sandybridge_asm(ctx);
873      }
874      else if (ALGO == Algorithm::CN_DOUBLE) {
875          cn_double_double_mainloop_sandybridge_asm(ctx);
876      }
877      else if (props.isR()) {
878          ctx[0]-&gt;generated_code(ctx);
879      }
880  #   ifdef XMRIG_VAES
881      if (!props.isHeavy() &amp;&amp; cn_vaes_enabled) {
882          cn_implode_scratchpad_vaes_double(ctx[0], ctx[1], props.memory(), props.half_mem());
883      }
884      else
885  #   endif
886      {
887          cn_implode_scratchpad&lt;ALGO, false, 0&gt;(ctx[0]);
888          cn_implode_scratchpad&lt;ALGO, false, 0&gt;(ctx[1]);
889      }
890      keccakf(reinterpret_cast&lt;uint64_t*&gt;(ctx[0]-&gt;state), 24);
891      keccakf(reinterpret_cast&lt;uint64_t*&gt;(ctx[1]-&gt;state), 24);
892      extra_hashes[ctx[0]-&gt;state[0] &amp; 3](ctx[0]-&gt;state, 200, output);
893      extra_hashes[ctx[1]-&gt;state[0] &amp; 3](ctx[1]-&gt;state, 200, output + 32);
894  }
895  } &amp;bsol;* namespace xmrig */
896  #endif
897  namespace xmrig {
898  #ifdef XMRIG_FEATURE_ASM
899  template&lt;Algorithm::Id ALGO&gt;
900  static NOINLINE void cryptonight_single_hash_gr_sse41(const uint8_t* __restrict__ input, size_t size, uint8_t* __restrict__ output, cryptonight_ctx** __restrict__ ctx, uint64_t height)
901  {
902      constexpr CnAlgo&lt;ALGO&gt; props;
903      constexpr Algorithm::Id BASE = props.base();
904      if (BASE == Algorithm::CN_1 &amp;&amp; size &lt; 43) {
905          memset(output, 0, 32);
906          return;
907      }
908      keccak(input, size, ctx[0]-&gt;state);
909      if (props.half_mem()) {
910          ctx[0]-&gt;first_half = true;
911      }
912      cn_explode_scratchpad&lt;ALGO, false, 0&gt;(ctx[0]);
913      VARIANT1_INIT(0);
914      ctx[0]-&gt;tweak1_2 = tweak1_2_0;
915      ctx[0]-&gt;tweak1_table = tweak1_table;
916      if (ALGO == Algorithm::CN_GR_0) cn_gr0_single_mainloop_asm(ctx);
917      if (ALGO == Algorithm::CN_GR_1) cn_gr1_single_mainloop_asm(ctx);
918      if (ALGO == Algorithm::CN_GR_2) cn_gr2_single_mainloop_asm(ctx);
919      if (ALGO == Algorithm::CN_GR_3) cn_gr3_single_mainloop_asm(ctx);
920      if (ALGO == Algorithm::CN_GR_4) cn_gr4_single_mainloop_asm(ctx);
921      if (ALGO == Algorithm::CN_GR_5) cn_gr5_single_mainloop_asm(ctx);
922      cn_implode_scratchpad&lt;ALGO, false, 0&gt;(ctx[0]);
923      keccakf(reinterpret_cast&lt;uint64_t*&gt;(ctx[0]-&gt;state), 24);
924      extra_hashes[ctx[0]-&gt;state[0] &amp; 3](ctx[0]-&gt;state, 200, output);
925  }
926  template&lt;Algorithm::Id ALGO&gt;
927  static NOINLINE void cryptonight_double_hash_gr_sse41(const uint8_t *__restrict__ input, size_t size, uint8_t *__restrict__ output, cryptonight_ctx **__restrict__ ctx, uint64_t height)
928  {
929      constexpr CnAlgo&lt;ALGO&gt; props;
930      constexpr Algorithm::Id BASE = props.base();
931      if (BASE == Algorithm::CN_1 &amp;&amp; size &lt; 43) {
932          memset(output, 0, 64);
933          return;
934      }
935      keccak(input,        size, ctx[0]-&gt;state);
936      keccak(input + size, size, ctx[1]-&gt;state);
937      if (props.half_mem()) {
938          ctx[0]-&gt;first_half = true;
939          ctx[1]-&gt;first_half = true;
940      }
941  #   ifdef XMRIG_VAES
942      if (!props.isHeavy() &amp;&amp; cn_vaes_enabled) {
943          cn_explode_scratchpad_vaes_double(ctx[0], ctx[1], props.memory(), props.half_mem());
944      }
945      else
946  #   endif
947      {
948          cn_explode_scratchpad&lt;ALGO, false, 0&gt;(ctx[0]);
949          cn_explode_scratchpad&lt;ALGO, false, 0&gt;(ctx[1]);
950      }
951      VARIANT1_INIT(0);
952      VARIANT1_INIT(1);
953      ctx[0]-&gt;tweak1_2 = tweak1_2_0;
954      ctx[1]-&gt;tweak1_2 = tweak1_2_1;
955      ctx[0]-&gt;tweak1_table = tweak1_table;
956      if (ALGO == Algorithm::CN_GR_0) cn_gr0_double_mainloop_asm(ctx);
957      if (ALGO == Algorithm::CN_GR_1) cn_gr1_double_mainloop_asm(ctx);
958      if (ALGO == Algorithm::CN_GR_2) cn_gr2_double_mainloop_asm(ctx);
959      if (ALGO == Algorithm::CN_GR_3) cn_gr3_double_mainloop_asm(ctx);
960      if (ALGO == Algorithm::CN_GR_4) cn_gr4_double_mainloop_asm(ctx);
961      if (ALGO == Algorithm::CN_GR_5) cn_gr5_double_mainloop_asm(ctx);
962  #   ifdef XMRIG_VAES
963      if (!props.isHeavy() &amp;&amp; cn_vaes_enabled) {
964          cn_implode_scratchpad_vaes_double(ctx[0], ctx[1], props.memory(), props.half_mem());
965      }
966      else
967  #   endif
968      {
969          cn_implode_scratchpad&lt;ALGO, false, 0&gt;(ctx[0]);
970          cn_implode_scratchpad&lt;ALGO, false, 0&gt;(ctx[1]);
971      }
972      keccakf(reinterpret_cast&lt;uint64_t*&gt;(ctx[0]-&gt;state), 24);
973      keccakf(reinterpret_cast&lt;uint64_t*&gt;(ctx[1]-&gt;state), 24);
974      extra_hashes[ctx[0]-&gt;state[0] &amp; 3](ctx[0]-&gt;state, 200, output);
975      extra_hashes[ctx[1]-&gt;state[0] &amp; 3](ctx[1]-&gt;state, 200, output + 32);
976  }
977  #endif
978  template&lt;Algorithm::Id ALGO, bool SOFT_AES&gt;
979  inline void cryptonight_double_hash(const uint8_t *__restrict__ input, size_t size, uint8_t *__restrict__ output, cryptonight_ctx **__restrict__ ctx, uint64_t height)
980  {
981  #   ifdef XMRIG_FEATURE_ASM
982      if (!SOFT_AES) {
983          switch (ALGO) {
984          case Algorithm::CN_GR_0:
985          case Algorithm::CN_GR_1:
986          case Algorithm::CN_GR_2:
987          case Algorithm::CN_GR_3:
988          case Algorithm::CN_GR_4:
989          case Algorithm::CN_GR_5:
990              if (cn_sse41_enabled) {
991                  cryptonight_double_hash_gr_sse41&lt;ALGO&gt;(input, size, output, ctx, height);
992                  return;
993              }
994              break;
995          default:
996              break;
997          }
998      }
999  #   endif
1000      constexpr CnAlgo&lt;ALGO&gt; props;
1001      constexpr size_t MASK        = props.mask();
1002      constexpr Algorithm::Id BASE = props.base();
1003  #   ifdef XMRIG_ALGO_CN_HEAVY
1004      constexpr bool IS_CN_HEAVY_TUBE = ALGO == Algorithm::CN_HEAVY_TUBE;
1005  #   else
1006      constexpr bool IS_CN_HEAVY_TUBE = false;
1007  #   endif
1008      if (BASE == Algorithm::CN_1 &amp;&amp; size &lt; 43) {
1009          memset(output, 0, 64);
1010          return;
1011      }
1012      keccak(input,        size, ctx[0]-&gt;state);
1013      keccak(input + size, size, ctx[1]-&gt;state);
1014      uint8_t *l0  = ctx[0]-&gt;memory;
1015      uint8_t *l1  = ctx[1]-&gt;memory;
1016      uint64_t *h0 = reinterpret_cast&lt;uint64_t*&gt;(ctx[0]-&gt;state);
1017      uint64_t *h1 = reinterpret_cast&lt;uint64_t*&gt;(ctx[1]-&gt;state);
1018      VARIANT1_INIT(0);
1019      VARIANT1_INIT(1);
1020      VARIANT2_INIT(0);
1021      VARIANT2_INIT(1);
1022      VARIANT2_SET_ROUNDING_MODE();
1023      VARIANT4_RANDOM_MATH_INIT(0);
1024      VARIANT4_RANDOM_MATH_INIT(1);
1025      if (props.half_mem()) {
1026          ctx[0]-&gt;first_half = true;
1027          ctx[1]-&gt;first_half = true;
1028      }
1029  #   ifdef XMRIG_VAES
1030      if (!SOFT_AES &amp;&amp; !props.isHeavy() &amp;&amp; cn_vaes_enabled) {
1031          cn_explode_scratchpad_vaes_double(ctx[0], ctx[1], props.memory(), props.half_mem());
1032      }
1033      else
1034  #   endif
1035      {
1036          cn_explode_scratchpad&lt;ALGO, SOFT_AES, 0&gt;(ctx[0]);
1037          cn_explode_scratchpad&lt;ALGO, SOFT_AES, 0&gt;(ctx[1]);
1038      }
1039      uint64_t al0 = h0[0] ^ h0[4];
1040      uint64_t al1 = h1[0] ^ h1[4];
1041      uint64_t ah0 = h0[1] ^ h0[5];
1042      uint64_t ah1 = h1[1] ^ h1[5];
1043      __m128i bx00 = _mm_set_epi64x(h0[3] ^ h0[7], h0[2] ^ h0[6]);
1044      __m128i bx01 = _mm_set_epi64x(h0[9] ^ h0[11], h0[8] ^ h0[10]);
1045      __m128i bx10 = _mm_set_epi64x(h1[3] ^ h1[7], h1[2] ^ h1[6]);
1046      __m128i bx11 = _mm_set_epi64x(h1[9] ^ h1[11], h1[8] ^ h1[10]);
1047      __m128 conc_var0, conc_var1;
1048      if (ALGO == Algorithm::CN_CCX) {
1049          conc_var0 = _mm_setzero_ps();
1050          conc_var1 = _mm_setzero_ps();
1051          RESTORE_ROUNDING_MODE();
1052      }
1053      uint64_t idx0 = al0;
1054      uint64_t idx1 = al1;
1055      for (size_t i = 0; i &lt; props.iterations(); i++) {
1056          __m128i cx0, cx1;
1057          if (IS_CN_HEAVY_TUBE || !SOFT_AES) {
1058              cx0 = _mm_load_si128(reinterpret_cast&lt;const __m128i *&gt;(&amp;l0[idx0 &amp; MASK]));
1059              cx1 = _mm_load_si128(reinterpret_cast&lt;const __m128i *&gt;(&amp;l1[idx1 &amp; MASK]));
1060              if (ALGO == Algorithm::CN_CCX) {
1061                  cryptonight_conceal_tweak(cx0, conc_var0);
1062                  cryptonight_conceal_tweak(cx1, conc_var1);
1063              }
1064          }
1065          const __m128i ax0 = _mm_set_epi64x(ah0, al0);
1066          const __m128i ax1 = _mm_set_epi64x(ah1, al1);
1067          if (IS_CN_HEAVY_TUBE) {
1068              cx0 = aes_round_tweak_div(cx0, ax0);
1069              cx1 = aes_round_tweak_div(cx1, ax1);
1070          }
1071          else if (SOFT_AES) {
1072              if (ALGO == Algorithm::CN_CCX) {
1073                  cx0 = _mm_load_si128(reinterpret_cast&lt;const __m128i*&gt;(&amp;l0[idx0 &amp; MASK]));
1074                  cx1 = _mm_load_si128(reinterpret_cast&lt;const __m128i*&gt;(&amp;l1[idx1 &amp; MASK]));
1075                  cryptonight_conceal_tweak(cx0, conc_var0);
1076                  cryptonight_conceal_tweak(cx1, conc_var1);
1077                  cx0 = soft_aesenc(&amp;cx0, ax0, reinterpret_cast&lt;const uint32_t*&gt;(saes_table));
1078                  cx1 = soft_aesenc(&amp;cx1, ax1, reinterpret_cast&lt;const uint32_t*&gt;(saes_table));
1079              }
1080              else {
1081                  cx0 = soft_aesenc(&amp;l0[idx0 &amp; MASK], ax0, reinterpret_cast&lt;const uint32_t*&gt;(saes_table));
1082                  cx1 = soft_aesenc(&amp;l1[idx1 &amp; MASK], ax1, reinterpret_cast&lt;const uint32_t*&gt;(saes_table));
1083              }
1084          }
1085          else {
1086              cx0 = _mm_aesenc_si128(cx0, ax0);
1087              cx1 = _mm_aesenc_si128(cx1, ax1);
1088          }
1089          if (BASE == Algorithm::CN_1 || BASE == Algorithm::CN_2) {
1090              cryptonight_monero_tweak&lt;ALGO&gt;((uint64_t*)&amp;l0[idx0 &amp; MASK], l0, idx0 &amp; MASK, ax0, bx00, bx01, cx0);
1091              cryptonight_monero_tweak&lt;ALGO&gt;((uint64_t*)&amp;l1[idx1 &amp; MASK], l1, idx1 &amp; MASK, ax1, bx10, bx11, cx1);
1092          } else {
1093              _mm_store_si128((__m128i *) &amp;l0[idx0 &amp; MASK], _mm_xor_si128(bx00, cx0));
1094              _mm_store_si128((__m128i *) &amp;l1[idx1 &amp; MASK], _mm_xor_si128(bx10, cx1));
1095          }
1096          idx0 = _mm_cvtsi128_si64(cx0);
1097          idx1 = _mm_cvtsi128_si64(cx1);
1098          uint64_t hi, lo, cl, ch;
1099          cl = ((uint64_t*) &amp;l0[idx0 &amp; MASK])[0];
1100          ch = ((uint64_t*) &amp;l0[idx0 &amp; MASK])[1];
1101          if (BASE == Algorithm::CN_2) {
1102              if (props.isR()) {
1103                  VARIANT4_RANDOM_MATH(0, al0, ah0, cl, bx00, bx01);
1104                  if (ALGO == Algorithm::CN_R) {
1105                      al0 ^= r0[2] | ((uint64_t)(r0[3]) &lt;&lt; 32);
1106                      ah0 ^= r0[0] | ((uint64_t)(r0[1]) &lt;&lt; 32);
1107                  }
1108              } else {
1109                  VARIANT2_INTEGER_MATH(0, cl, cx0);
1110              }
1111          }
1112          lo = __umul128(idx0, cl, &amp;hi);
1113          if (BASE == Algorithm::CN_2) {
1114              if (ALGO == Algorithm::CN_R) {
1115                  VARIANT2_SHUFFLE(l0, idx0 &amp; MASK, ax0, bx00, bx01, cx0, 0);
1116              } else {
1117                  VARIANT2_SHUFFLE2(l0, idx0 &amp; MASK, ax0, bx00, bx01, hi, lo, (((ALGO == Algorithm::CN_RWZ) || (ALGO == Algorithm::CN_UPX2)) ? 1 : 0));
1118              }
1119          }
1120          al0 += hi;
1121          ah0 += lo;
1122          ((uint64_t*)&amp;l0[idx0 &amp; MASK])[0] = al0;
1123          if (IS_CN_HEAVY_TUBE || ALGO == Algorithm::CN_RTO) {
1124              ((uint64_t*) &amp;l0[idx0 &amp; MASK])[1] = ah0 ^ tweak1_2_0 ^ al0;
1125          } else if (BASE == Algorithm::CN_1) {
1126              ((uint64_t*) &amp;l0[idx0 &amp; MASK])[1] = ah0 ^ tweak1_2_0;
1127          } else {
1128              ((uint64_t*) &amp;l0[idx0 &amp; MASK])[1] = ah0;
1129          }
1130          al0 ^= cl;
1131          ah0 ^= ch;
1132          idx0 = al0;
1133  #       ifdef XMRIG_ALGO_CN_HEAVY
1134          if (props.isHeavy()) {
1135              int64_t n = ((int64_t*)&amp;l0[idx0 &amp; MASK])[0];
1136              int32_t d = ((int32_t*)&amp;l0[idx0 &amp; MASK])[2];
1137              int64_t q = n / (d | 0x5);
1138              ((int64_t*)&amp;l0[idx0 &amp; MASK])[0] = n ^ q;
1139              if (ALGO == Algorithm::CN_HEAVY_XHV) {
1140                  d = ~d;
1141              }
1142              idx0 = d ^ q;
1143          }
1144  #       endif
1145          cl = ((uint64_t*) &amp;l1[idx1 &amp; MASK])[0];
1146          ch = ((uint64_t*) &amp;l1[idx1 &amp; MASK])[1];
1147          if (BASE == Algorithm::CN_2) {
1148              if (props.isR()) {
1149                  VARIANT4_RANDOM_MATH(1, al1, ah1, cl, bx10, bx11);
1150                  if (ALGO == Algorithm::CN_R) {
1151                      al1 ^= r1[2] | ((uint64_t)(r1[3]) &lt;&lt; 32);
1152                      ah1 ^= r1[0] | ((uint64_t)(r1[1]) &lt;&lt; 32);
1153                  }
1154              } else {
1155                  VARIANT2_INTEGER_MATH(1, cl, cx1);
1156              }
1157          }
1158          lo = __umul128(idx1, cl, &amp;hi);
1159          if (BASE == Algorithm::CN_2) {
1160              if (ALGO == Algorithm::CN_R) {
1161                  VARIANT2_SHUFFLE(l1, idx1 &amp; MASK, ax1, bx10, bx11, cx1, 0);
1162              } else {
1163                  VARIANT2_SHUFFLE2(l1, idx1 &amp; MASK, ax1, bx10, bx11, hi, lo, (((ALGO == Algorithm::CN_RWZ) || (ALGO == Algorithm::CN_UPX2)) ? 1 : 0));
1164              }
1165          }
1166          al1 += hi;
1167          ah1 += lo;
1168          ((uint64_t*)&amp;l1[idx1 &amp; MASK])[0] = al1;
1169          if (IS_CN_HEAVY_TUBE || ALGO == Algorithm::CN_RTO) {
1170              ((uint64_t*)&amp;l1[idx1 &amp; MASK])[1] = ah1 ^ tweak1_2_1 ^ al1;
1171          } else if (BASE == Algorithm::CN_1) {
1172              ((uint64_t*)&amp;l1[idx1 &amp; MASK])[1] = ah1 ^ tweak1_2_1;
1173          } else {
1174              ((uint64_t*)&amp;l1[idx1 &amp; MASK])[1] = ah1;
1175          }
1176          al1 ^= cl;
1177          ah1 ^= ch;
1178          idx1 = al1;
1179  #       ifdef XMRIG_ALGO_CN_HEAVY
1180          if (props.isHeavy()) {
1181              int64_t n = ((int64_t*)&amp;l1[idx1 &amp; MASK])[0];
1182              int32_t d = ((int32_t*)&amp;l1[idx1 &amp; MASK])[2];
1183              int64_t q = n / (d | 0x5);
1184              ((int64_t*)&amp;l1[idx1 &amp; MASK])[0] = n ^ q;
1185              if (ALGO == Algorithm::CN_HEAVY_XHV) {
1186                  d = ~d;
1187              }
1188              idx1 = d ^ q;
1189          }
1190  #       endif
1191          if (BASE == Algorithm::CN_2) {
1192              bx01 = bx00;
1193              bx11 = bx10;
1194          }
1195          bx00 = cx0;
1196          bx10 = cx1;
1197      }
1198  #   ifdef XMRIG_VAES
1199      if (!SOFT_AES &amp;&amp; !props.isHeavy() &amp;&amp; cn_vaes_enabled) {
1200          cn_implode_scratchpad_vaes_double(ctx[0], ctx[1], props.memory(), props.half_mem());
1201      }
1202      else
1203  #   endif
1204      {
1205          cn_implode_scratchpad&lt;ALGO, SOFT_AES, 0&gt;(ctx[0]);
1206          cn_implode_scratchpad&lt;ALGO, SOFT_AES, 0&gt;(ctx[1]);
1207      }
1208      keccakf(h0, 24);
1209      keccakf(h1, 24);
1210      extra_hashes[ctx[0]-&gt;state[0] &amp; 3](ctx[0]-&gt;state, 200, output);
1211      extra_hashes[ctx[1]-&gt;state[0] &amp; 3](ctx[1]-&gt;state, 200, output + 32);
1212  }
1213  #ifdef XMRIG_FEATURE_ASM
1214  template&lt;Algorithm::Id ALGO&gt;
1215  static NOINLINE void cryptonight_quad_hash_gr_sse41(const uint8_t* __restrict__ input, size_t size, uint8_t* __restrict__ output, cryptonight_ctx** __restrict__ ctx, uint64_t height)
1216  {
1217      constexpr CnAlgo&lt;ALGO&gt; props;
1218      constexpr Algorithm::Id BASE = props.base();
1219      if (BASE == Algorithm::CN_1 &amp;&amp; size &lt; 43) {
1220          memset(output, 0, 32 * 4);
1221          return;
1222      }
1223      keccak(input + size * 0, size, ctx[0]-&gt;state);
1224      keccak(input + size * 1, size, ctx[1]-&gt;state);
1225      keccak(input + size * 2, size, ctx[2]-&gt;state);
1226      keccak(input + size * 3, size, ctx[3]-&gt;state);
1227      if (props.half_mem()) {
1228          ctx[0]-&gt;first_half = true;
1229          ctx[1]-&gt;first_half = true;
1230          ctx[2]-&gt;first_half = true;
1231          ctx[3]-&gt;first_half = true;
1232      }
1233  #   ifdef XMRIG_VAES
1234      if (!props.isHeavy() &amp;&amp; cn_vaes_enabled) {
1235          cn_explode_scratchpad_vaes_double(ctx[0], ctx[1], props.memory(), props.half_mem());
1236          cn_explode_scratchpad_vaes_double(ctx[2], ctx[3], props.memory(), props.half_mem());
1237      }
1238      else
1239  #   endif
1240      {
1241          cn_explode_scratchpad&lt;ALGO, false, 0&gt;(ctx[0]);
1242          cn_explode_scratchpad&lt;ALGO, false, 0&gt;(ctx[1]);
1243          cn_explode_scratchpad&lt;ALGO, false, 0&gt;(ctx[2]);
1244          cn_explode_scratchpad&lt;ALGO, false, 0&gt;(ctx[3]);
1245      }
1246      VARIANT1_INIT(0); ctx[0]-&gt;tweak1_2 = tweak1_2_0;
1247      VARIANT1_INIT(1); ctx[1]-&gt;tweak1_2 = tweak1_2_1;
1248      VARIANT1_INIT(2); ctx[2]-&gt;tweak1_2 = tweak1_2_2;
1249      VARIANT1_INIT(3); ctx[3]-&gt;tweak1_2 = tweak1_2_3;
1250      ctx[0]-&gt;tweak1_table = tweak1_table;
1251      if (ALGO == Algorithm::CN_GR_0) cn_gr0_quad_mainloop_asm(ctx);
1252      if (ALGO == Algorithm::CN_GR_1) cn_gr1_quad_mainloop_asm(ctx);
1253      if (ALGO == Algorithm::CN_GR_2) cn_gr2_quad_mainloop_asm(ctx);
1254      if (ALGO == Algorithm::CN_GR_3) cn_gr3_quad_mainloop_asm(ctx);
1255      if (ALGO == Algorithm::CN_GR_4) cn_gr4_quad_mainloop_asm(ctx);
1256      if (ALGO == Algorithm::CN_GR_5) cn_gr5_quad_mainloop_asm(ctx);
1257  #   ifdef XMRIG_VAES
1258      if (!props.isHeavy() &amp;&amp; cn_vaes_enabled) {
1259          cn_implode_scratchpad_vaes_double(ctx[0], ctx[1], props.memory(), props.half_mem());
1260          cn_implode_scratchpad_vaes_double(ctx[2], ctx[3], props.memory(), props.half_mem());
1261      }
1262      else
1263  #   endif
1264      {
1265          cn_implode_scratchpad&lt;ALGO, false, 0&gt;(ctx[0]);
1266          cn_implode_scratchpad&lt;ALGO, false, 0&gt;(ctx[1]);
1267          cn_implode_scratchpad&lt;ALGO, false, 0&gt;(ctx[2]);
1268          cn_implode_scratchpad&lt;ALGO, false, 0&gt;(ctx[3]);
1269      }
1270      keccakf(reinterpret_cast&lt;uint64_t*&gt;(ctx[0]-&gt;state), 24);
1271      keccakf(reinterpret_cast&lt;uint64_t*&gt;(ctx[1]-&gt;state), 24);
1272      keccakf(reinterpret_cast&lt;uint64_t*&gt;(ctx[2]-&gt;state), 24);
1273      keccakf(reinterpret_cast&lt;uint64_t*&gt;(ctx[3]-&gt;state), 24);
1274      extra_hashes[ctx[0]-&gt;state[0] &amp; 3](ctx[0]-&gt;state, 200, output);
1275      extra_hashes[ctx[1]-&gt;state[0] &amp; 3](ctx[1]-&gt;state, 200, output + 32);
1276      extra_hashes[ctx[2]-&gt;state[0] &amp; 3](ctx[2]-&gt;state, 200, output + 64);
1277      extra_hashes[ctx[3]-&gt;state[0] &amp; 3](ctx[3]-&gt;state, 200, output + 96);
1278  }
1279  #endif
1280  #define CN_STEP1(a, b0, b1, c, l, ptr, idx, conc_var) \
1281      ptr = reinterpret_cast&lt;__m128i*&gt;(&amp;l[idx &amp; MASK]); \
1282      c = _mm_load_si128(ptr);                          \
1283      if (ALGO == Algorithm::CN_CCX) {                  \
1284          cryptonight_conceal_tweak(c, conc_var);       \
1285      }
1286  #define CN_STEP2(a, b0, b1, c, l, ptr, idx)                                             \
1287      if (IS_CN_HEAVY_TUBE) {                                                             \
1288          c = aes_round_tweak_div(c, a);                                                  \
1289      }                                                                                   \
1290      else if (SOFT_AES) {                                                                \
1291          c = soft_aesenc(&amp;c, a, (const uint32_t*)saes_table);                            \
1292      } else {                                                                            \
1293          c = _mm_aesenc_si128(c, a);                                                     \
1294      }                                                                                   \
1295                                                                                          \
1296      if (BASE == Algorithm::CN_1 || BASE == Algorithm::CN_2) {                           \
1297          cryptonight_monero_tweak&lt;ALGO&gt;((uint64_t*)ptr, l, idx &amp; MASK, a, b0, b1, c);    \
1298      } else {                                                                            \
1299          _mm_store_si128(ptr, _mm_xor_si128(b0, c));                                     \
1300      }
1301  #define CN_STEP3(part, a, b0, b1, c, l, ptr, idx)     \
1302      idx = _mm_cvtsi128_si64(c);                       \
1303      ptr = reinterpret_cast&lt;__m128i*&gt;(&amp;l[idx &amp; MASK]); \
1304      uint64_t cl##part = ((uint64_t*)ptr)[0];          \
1305      uint64_t ch##part = ((uint64_t*)ptr)[1];
1306  #define CN_STEP4(part, a, b0, b1, c, l, mc, ptr, idx)                                                       \
1307      uint64_t al##part, ah##part;                                                                            \
1308      if (BASE == Algorithm::CN_2) {                                                                          \
1309          if (props.isR()) {                                                                                  \
1310              al##part = _mm_cvtsi128_si64(a);                                                                \
1311              ah##part = _mm_cvtsi128_si64(_mm_srli_si128(a, 8));                                             \
1312              VARIANT4_RANDOM_MATH(part, al##part, ah##part, cl##part, b0, b1);                               \
1313              if (ALGO == Algorithm::CN_R) {                                                                  \
1314                  al##part ^= r##part[2] | ((uint64_t)(r##part[3]) &lt;&lt; 32);                                    \
1315                  ah##part ^= r##part[0] | ((uint64_t)(r##part[1]) &lt;&lt; 32);                                    \
1316              }                                                                                               \
1317          } else {                                                                                            \
1318              VARIANT2_INTEGER_MATH(part, cl##part, c);                                                       \
1319          }                                                                                                   \
1320      }                                                                                                       \
1321      lo = __umul128(idx, cl##part, &amp;hi);                                                                     \
1322      if (BASE == Algorithm::CN_2) {                                                                          \
1323          if (ALGO == Algorithm::CN_R) {                                                                      \
1324              VARIANT2_SHUFFLE(l, idx &amp; MASK, a, b0, b1, c, 0);                                               \
1325          } else {                                                                                            \
1326              VARIANT2_SHUFFLE2(l, idx &amp; MASK, a, b0, b1, hi, lo, (((ALGO == Algorithm::CN_RWZ) || (ALGO == Algorithm::CN_UPX2)) ? 1 : 0)); \
1327          }                                                                                                   \
1328      }                                                                                                       \
1329      if (ALGO == Algorithm::CN_R) {                                                                          \
1330          a = _mm_set_epi64x(ah##part, al##part);                                                             \
1331      }                                                                                                       \
1332      a = _mm_add_epi64(a, _mm_set_epi64x(lo, hi));                                                           \
1333                                                                                                              \
1334      if (BASE == Algorithm::CN_1) {                                                                          \
1335          _mm_store_si128(ptr, _mm_xor_si128(a, mc));                                                         \
1336                                                                                                              \
1337          if (IS_CN_HEAVY_TUBE || ALGO == Algorithm::CN_RTO) {                                                \
1338              ((uint64_t*)ptr)[1] ^= ((uint64_t*)ptr)[0];                                                     \
1339          }                                                                                                   \
1340      } else {                                                                                                \
1341          _mm_store_si128(ptr, a);                                                                            \
1342      }                                                                                                       \
1343                                                                                                              \
1344      a = _mm_xor_si128(a, _mm_set_epi64x(ch##part, cl##part));                                               \
1345      idx = _mm_cvtsi128_si64(a);                                                                             \
1346      if (props.isHeavy()) {                                                                                  \
1347          int64_t n = ((int64_t*)&amp;l[idx &amp; MASK])[0];                                                          \
1348          int32_t d = ((int32_t*)&amp;l[idx &amp; MASK])[2];                                                          \
1349          int64_t q = n / (d | 0x5);                                                                          \
1350          ((int64_t*)&amp;l[idx &amp; MASK])[0] = n ^ q;                                                              \
1351          if (IS_CN_HEAVY_XHV) {                                                                              \
1352              d = ~d;                                                                                         \
1353          }                                                                                                   \
1354                                                                                                              \
1355          idx = d ^ q;                                                                                        \
1356      }                                                                                                       \
1357      if (BASE == Algorithm::CN_2) {                                                                          \
1358          b1 = b0;                                                                                            \
1359      }                                                                                                       \
1360      b0 = c;
1361  #define CONST_INIT(ctx, n)                                                                       \
1362      __m128i mc##n;                                                                               \
1363      __m128i division_result_xmm_##n;                                                             \
1364      __m128i sqrt_result_xmm_##n;                                                                 \
1365      if (BASE == Algorithm::CN_1) {                                                               \
1366          mc##n = _mm_set_epi64x(*reinterpret_cast&lt;const uint64_t*&gt;(input + n * size + 35) ^       \
1367                                 *(reinterpret_cast&lt;const uint64_t*&gt;((ctx)-&gt;state) + 24), 0);      \
1368      }                                                                                            \
1369      if (BASE == Algorithm::CN_2) {                                                               \
1370          division_result_xmm_##n = _mm_cvtsi64_si128(h##n[12]);                                   \
1371          sqrt_result_xmm_##n = _mm_cvtsi64_si128(h##n[13]);                                       \
1372      }                                                                                            \
1373      __m128i ax##n = _mm_set_epi64x(h##n[1] ^ h##n[5], h##n[0] ^ h##n[4]);                        \
1374      __m128i bx##n##0 = _mm_set_epi64x(h##n[3] ^ h##n[7], h##n[2] ^ h##n[6]);                     \
1375      __m128i bx##n##1 = _mm_set_epi64x(h##n[9] ^ h##n[11], h##n[8] ^ h##n[10]);                   \
1376      __m128i cx##n = _mm_setzero_si128();                                                         \
1377      __m128 conc_var##n;                                                                          \
1378      if (ALGO == Algorithm::CN_CCX) {                                                             \
1379          conc_var##n = _mm_setzero_ps();                                                          \
1380      }                                                                                            \
1381      VARIANT4_RANDOM_MATH_INIT(n);
1382  template&lt;Algorithm::Id ALGO, bool SOFT_AES&gt;
1383  inline void cryptonight_triple_hash(const uint8_t *__restrict__ input, size_t size, uint8_t *__restrict__ output, cryptonight_ctx **__restrict__ ctx, uint64_t height)
1384  {
1385      constexpr CnAlgo&lt;ALGO&gt; props;
1386      constexpr size_t MASK        = props.mask();
1387      constexpr Algorithm::Id BASE = props.base();
1388  #   ifdef XMRIG_ALGO_CN_HEAVY
1389      constexpr bool IS_CN_HEAVY_TUBE = ALGO == Algorithm::CN_HEAVY_TUBE;
1390      constexpr bool IS_CN_HEAVY_XHV  = ALGO == Algorithm::CN_HEAVY_XHV;
1391  #   else
1392      constexpr bool IS_CN_HEAVY_TUBE = false;
1393      constexpr bool IS_CN_HEAVY_XHV  = false;
1394  #   endif
1395      if (BASE == Algorithm::CN_1 &amp;&amp; size &lt; 43) {
1396          memset(output, 0, 32 * 3);
1397          return;
1398      }
1399      for (size_t i = 0; i &lt; 3; i++) {
1400          keccak(input + size * i, size, ctx[i]-&gt;state);
1401          if (props.half_mem()) {
1402              ctx[i]-&gt;first_half = true;
1403          }
1404          cn_explode_scratchpad&lt;ALGO, SOFT_AES, 0&gt;(ctx[i]);
1405      }
1406      uint8_t* l0  = ctx[0]-&gt;memory;
1407      uint8_t* l1  = ctx[1]-&gt;memory;
1408      uint8_t* l2  = ctx[2]-&gt;memory;
1409      uint64_t* h0 = reinterpret_cast&lt;uint64_t*&gt;(ctx[0]-&gt;state);
1410      uint64_t* h1 = reinterpret_cast&lt;uint64_t*&gt;(ctx[1]-&gt;state);
1411      uint64_t* h2 = reinterpret_cast&lt;uint64_t*&gt;(ctx[2]-&gt;state);
1412      CONST_INIT(ctx[0], 0);
1413      CONST_INIT(ctx[1], 1);
1414      CONST_INIT(ctx[2], 2);
1415      VARIANT2_SET_ROUNDING_MODE();
1416      if (ALGO == Algorithm::CN_CCX) {
1417          RESTORE_ROUNDING_MODE();
1418      }
1419      uint64_t idx0, idx1, idx2;
1420      idx0 = _mm_cvtsi128_si64(ax0);
1421      idx1 = _mm_cvtsi128_si64(ax1);
1422      idx2 = _mm_cvtsi128_si64(ax2);
1423      for (size_t i = 0; i &lt; props.iterations(); i++) {
1424          uint64_t hi, lo;
1425          __m128i *ptr0, *ptr1, *ptr2;
1426          CN_STEP1(ax0, bx00, bx01, cx0, l0, ptr0, idx0, conc_var0);
1427          CN_STEP1(ax1, bx10, bx11, cx1, l1, ptr1, idx1, conc_var1);
1428          CN_STEP1(ax2, bx20, bx21, cx2, l2, ptr2, idx2, conc_var2);
1429          CN_STEP2(ax0, bx00, bx01, cx0, l0, ptr0, idx0);
1430          CN_STEP2(ax1, bx10, bx11, cx1, l1, ptr1, idx1);
1431          CN_STEP2(ax2, bx20, bx21, cx2, l2, ptr2, idx2);
1432          CN_STEP3(0, ax0, bx00, bx01, cx0, l0, ptr0, idx0);
1433          CN_STEP3(1, ax1, bx10, bx11, cx1, l1, ptr1, idx1);
1434          CN_STEP3(2, ax2, bx20, bx21, cx2, l2, ptr2, idx2);
1435          CN_STEP4(0, ax0, bx00, bx01, cx0, l0, mc0, ptr0, idx0);
1436          CN_STEP4(1, ax1, bx10, bx11, cx1, l1, mc1, ptr1, idx1);
1437          CN_STEP4(2, ax2, bx20, bx21, cx2, l2, mc2, ptr2, idx2);
1438      }
1439      for (size_t i = 0; i &lt; 3; i++) {
1440          cn_implode_scratchpad&lt;ALGO, SOFT_AES, 0&gt;(ctx[i]);
1441          keccakf(reinterpret_cast&lt;uint64_t*&gt;(ctx[i]-&gt;state), 24);
1442          extra_hashes[ctx[i]-&gt;state[0] &amp; 3](ctx[i]-&gt;state, 200, output + 32 * i);
1443      }
1444  }
1445  template&lt;Algorithm::Id ALGO, bool SOFT_AES&gt;
1446  inline void cryptonight_quad_hash(const uint8_t *__restrict__ input, size_t size, uint8_t *__restrict__ output, cryptonight_ctx **__restrict__ ctx, uint64_t height)
1447  {
1448  #   ifdef XMRIG_FEATURE_ASM
1449      if (!SOFT_AES) {
1450          switch (ALGO) {
1451          case Algorithm::CN_GR_0:
1452          case Algorithm::CN_GR_1:
1453          case Algorithm::CN_GR_2:
1454          case Algorithm::CN_GR_3:
1455          case Algorithm::CN_GR_4:
1456          case Algorithm::CN_GR_5:
1457              if (cn_sse41_enabled) {
1458                  cryptonight_quad_hash_gr_sse41&lt;ALGO&gt;(input, size, output, ctx, height);
1459                  return;
1460              }
1461              break;
1462          default:
1463              break;
1464          }
1465      }
1466  #   endif
1467      constexpr CnAlgo&lt;ALGO&gt; props;
1468      constexpr size_t MASK        = props.mask();
1469      constexpr Algorithm::Id BASE = props.base();
1470  #   ifdef XMRIG_ALGO_CN_HEAVY
1471      constexpr bool IS_CN_HEAVY_TUBE = ALGO == Algorithm::CN_HEAVY_TUBE;
1472      constexpr bool IS_CN_HEAVY_XHV  = ALGO == Algorithm::CN_HEAVY_XHV;
1473  #   else
1474      constexpr bool IS_CN_HEAVY_TUBE = false;
1475      constexpr bool IS_CN_HEAVY_XHV  = false;
1476  #   endif
1477      if (BASE == Algorithm::CN_1 &amp;&amp; size &lt; 43) {
1478          memset(output, 0, 32 * 4);
1479          return;
1480      }
1481      for (size_t i = 0; i &lt; 4; i++) {
1482          keccak(input + size * i, size, ctx[i]-&gt;state);
1483          if (props.half_mem()) {
1484              ctx[i]-&gt;first_half = true;
1485          }
1486      }
1487  #   ifdef XMRIG_VAES
1488      if (!SOFT_AES &amp;&amp; !props.isHeavy() &amp;&amp; cn_vaes_enabled) {
1489          cn_explode_scratchpad_vaes_double(ctx[0], ctx[1], props.memory(), props.half_mem());
1490          cn_explode_scratchpad_vaes_double(ctx[2], ctx[3], props.memory(), props.half_mem());
1491      }
1492      else
1493  #   endif
1494      {
1495          cn_explode_scratchpad&lt;ALGO, SOFT_AES, 0&gt;(ctx[0]);
1496          cn_explode_scratchpad&lt;ALGO, SOFT_AES, 0&gt;(ctx[1]);
1497          cn_explode_scratchpad&lt;ALGO, SOFT_AES, 0&gt;(ctx[2]);
1498          cn_explode_scratchpad&lt;ALGO, SOFT_AES, 0&gt;(ctx[3]);
1499      }
1500      uint8_t* l0  = ctx[0]-&gt;memory;
1501      uint8_t* l1  = ctx[1]-&gt;memory;
1502      uint8_t* l2  = ctx[2]-&gt;memory;
1503      uint8_t* l3  = ctx[3]-&gt;memory;
1504      uint64_t* h0 = reinterpret_cast&lt;uint64_t*&gt;(ctx[0]-&gt;state);
1505      uint64_t* h1 = reinterpret_cast&lt;uint64_t*&gt;(ctx[1]-&gt;state);
1506      uint64_t* h2 = reinterpret_cast&lt;uint64_t*&gt;(ctx[2]-&gt;state);
1507      uint64_t* h3 = reinterpret_cast&lt;uint64_t*&gt;(ctx[3]-&gt;state);
1508      CONST_INIT(ctx[0], 0);
1509      CONST_INIT(ctx[1], 1);
1510      CONST_INIT(ctx[2], 2);
1511      CONST_INIT(ctx[3], 3);
1512      VARIANT2_SET_ROUNDING_MODE();
1513      if (ALGO == Algorithm::CN_CCX) {
1514          RESTORE_ROUNDING_MODE();
1515      }
1516      uint64_t idx0, idx1, idx2, idx3;
1517      idx0 = _mm_cvtsi128_si64(ax0);
1518      idx1 = _mm_cvtsi128_si64(ax1);
1519      idx2 = _mm_cvtsi128_si64(ax2);
1520      idx3 = _mm_cvtsi128_si64(ax3);
1521      for (size_t i = 0; i &lt; props.iterations(); i++) {
1522          uint64_t hi, lo;
1523          __m128i *ptr0, *ptr1, *ptr2, *ptr3;
1524          CN_STEP1(ax0, bx00, bx01, cx0, l0, ptr0, idx0, conc_var0);
1525          CN_STEP1(ax1, bx10, bx11, cx1, l1, ptr1, idx1, conc_var1);
1526          CN_STEP1(ax2, bx20, bx21, cx2, l2, ptr2, idx2, conc_var2);
1527          CN_STEP1(ax3, bx30, bx31, cx3, l3, ptr3, idx3, conc_var3);
1528          CN_STEP2(ax0, bx00, bx01, cx0, l0, ptr0, idx0);
1529          CN_STEP2(ax1, bx10, bx11, cx1, l1, ptr1, idx1);
1530          CN_STEP2(ax2, bx20, bx21, cx2, l2, ptr2, idx2);
1531          CN_STEP2(ax3, bx30, bx31, cx3, l3, ptr3, idx3);
1532          CN_STEP3(0, ax0, bx00, bx01, cx0, l0, ptr0, idx0);
1533          CN_STEP3(1, ax1, bx10, bx11, cx1, l1, ptr1, idx1);
1534          CN_STEP3(2, ax2, bx20, bx21, cx2, l2, ptr2, idx2);
1535          CN_STEP3(3, ax3, bx30, bx31, cx3, l3, ptr3, idx3);
1536          CN_STEP4(0, ax0, bx00, bx01, cx0, l0, mc0, ptr0, idx0);
1537          CN_STEP4(1, ax1, bx10, bx11, cx1, l1, mc1, ptr1, idx1);
1538          CN_STEP4(2, ax2, bx20, bx21, cx2, l2, mc2, ptr2, idx2);
1539          CN_STEP4(3, ax3, bx30, bx31, cx3, l3, mc3, ptr3, idx3);
1540      }
1541  #   ifdef XMRIG_VAES
1542      if (!SOFT_AES &amp;&amp; !props.isHeavy() &amp;&amp; cn_vaes_enabled) {
1543          cn_implode_scratchpad_vaes_double(ctx[0], ctx[1], props.memory(), props.half_mem());
1544          cn_implode_scratchpad_vaes_double(ctx[2], ctx[3], props.memory(), props.half_mem());
1545      }
1546      else
1547  #   endif
1548      {
1549          cn_implode_scratchpad&lt;ALGO, SOFT_AES, 0&gt;(ctx[0]);
1550          cn_implode_scratchpad&lt;ALGO, SOFT_AES, 0&gt;(ctx[1]);
1551          cn_implode_scratchpad&lt;ALGO, SOFT_AES, 0&gt;(ctx[2]);
1552          cn_implode_scratchpad&lt;ALGO, SOFT_AES, 0&gt;(ctx[3]);
1553      }
1554      for (size_t i = 0; i &lt; 4; i++) {
1555          keccakf(reinterpret_cast&lt;uint64_t*&gt;(ctx[i]-&gt;state), 24);
1556          extra_hashes[ctx[i]-&gt;state[0] &amp; 3](ctx[i]-&gt;state, 200, output + 32 * i);
1557      }
1558  }
1559  template&lt;Algorithm::Id ALGO, bool SOFT_AES&gt;
1560  inline void cryptonight_penta_hash(const uint8_t *__restrict__ input, size_t size, uint8_t *__restrict__ output, cryptonight_ctx **__restrict__ ctx, uint64_t height)
1561  {
1562      constexpr CnAlgo&lt;ALGO&gt; props;
1563      constexpr size_t MASK        = props.mask();
1564      constexpr Algorithm::Id BASE = props.base();
1565  #   ifdef XMRIG_ALGO_CN_HEAVY
1566      constexpr bool IS_CN_HEAVY_TUBE = ALGO == Algorithm::CN_HEAVY_TUBE;
1567      constexpr bool IS_CN_HEAVY_XHV  = ALGO == Algorithm::CN_HEAVY_XHV;
1568  #   else
1569      constexpr bool IS_CN_HEAVY_TUBE = false;
1570      constexpr bool IS_CN_HEAVY_XHV  = false;
1571  #   endif
1572      if (BASE == Algorithm::CN_1 &amp;&amp; size &lt; 43) {
1573          memset(output, 0, 32 * 5);
1574          return;
1575      }
1576      for (size_t i = 0; i &lt; 5; i++) {
1577          keccak(input + size * i, size, ctx[i]-&gt;state);
1578          if (props.half_mem()) {
1579              ctx[i]-&gt;first_half = true;
1580          }
1581          cn_explode_scratchpad&lt;ALGO, SOFT_AES, 0&gt;(ctx[i]);
1582      }
1583      uint8_t* l0  = ctx[0]-&gt;memory;
1584      uint8_t* l1  = ctx[1]-&gt;memory;
1585      uint8_t* l2  = ctx[2]-&gt;memory;
1586      uint8_t* l3  = ctx[3]-&gt;memory;
1587      uint8_t* l4  = ctx[4]-&gt;memory;
1588      uint64_t* h0 = reinterpret_cast&lt;uint64_t*&gt;(ctx[0]-&gt;state);
1589      uint64_t* h1 = reinterpret_cast&lt;uint64_t*&gt;(ctx[1]-&gt;state);
1590      uint64_t* h2 = reinterpret_cast&lt;uint64_t*&gt;(ctx[2]-&gt;state);
1591      uint64_t* h3 = reinterpret_cast&lt;uint64_t*&gt;(ctx[3]-&gt;state);
1592      uint64_t* h4 = reinterpret_cast&lt;uint64_t*&gt;(ctx[4]-&gt;state);
1593      CONST_INIT(ctx[0], 0);
1594      CONST_INIT(ctx[1], 1);
1595      CONST_INIT(ctx[2], 2);
1596      CONST_INIT(ctx[3], 3);
1597      CONST_INIT(ctx[4], 4);
1598      VARIANT2_SET_ROUNDING_MODE();
1599      if (ALGO == Algorithm::CN_CCX) {
1600          RESTORE_ROUNDING_MODE();
1601      }
1602      uint64_t idx0, idx1, idx2, idx3, idx4;
1603      idx0 = _mm_cvtsi128_si64(ax0);
1604      idx1 = _mm_cvtsi128_si64(ax1);
1605      idx2 = _mm_cvtsi128_si64(ax2);
1606      idx3 = _mm_cvtsi128_si64(ax3);
1607      idx4 = _mm_cvtsi128_si64(ax4);
1608      for (size_t i = 0; i &lt; props.iterations(); i++) {
1609          uint64_t hi, lo;
1610          __m128i *ptr0, *ptr1, *ptr2, *ptr3, *ptr4;
1611          CN_STEP1(ax0, bx00, bx01, cx0, l0, ptr0, idx0, conc_var0);
1612          CN_STEP1(ax1, bx10, bx11, cx1, l1, ptr1, idx1, conc_var1);
1613          CN_STEP1(ax2, bx20, bx21, cx2, l2, ptr2, idx2, conc_var2);
1614          CN_STEP1(ax3, bx30, bx31, cx3, l3, ptr3, idx3, conc_var3);
1615          CN_STEP1(ax4, bx40, bx41, cx4, l4, ptr4, idx4, conc_var4);
1616          CN_STEP2(ax0, bx00, bx01, cx0, l0, ptr0, idx0);
1617          CN_STEP2(ax1, bx10, bx11, cx1, l1, ptr1, idx1);
1618          CN_STEP2(ax2, bx20, bx21, cx2, l2, ptr2, idx2);
1619          CN_STEP2(ax3, bx30, bx31, cx3, l3, ptr3, idx3);
1620          CN_STEP2(ax4, bx40, bx41, cx4, l4, ptr4, idx4);
1621          CN_STEP3(0, ax0, bx00, bx01, cx0, l0, ptr0, idx0);
1622          CN_STEP3(1, ax1, bx10, bx11, cx1, l1, ptr1, idx1);
1623          CN_STEP3(2, ax2, bx20, bx21, cx2, l2, ptr2, idx2);
1624          CN_STEP3(3, ax3, bx30, bx31, cx3, l3, ptr3, idx3);
1625          CN_STEP3(4, ax4, bx40, bx41, cx4, l4, ptr4, idx4);
1626          CN_STEP4(0, ax0, bx00, bx01, cx0, l0, mc0, ptr0, idx0);
1627          CN_STEP4(1, ax1, bx10, bx11, cx1, l1, mc1, ptr1, idx1);
1628          CN_STEP4(2, ax2, bx20, bx21, cx2, l2, mc2, ptr2, idx2);
1629          CN_STEP4(3, ax3, bx30, bx31, cx3, l3, mc3, ptr3, idx3);
1630          CN_STEP4(4, ax4, bx40, bx41, cx4, l4, mc4, ptr4, idx4);
1631      }
1632      for (size_t i = 0; i &lt; 5; i++) {
1633          cn_implode_scratchpad&lt;ALGO, SOFT_AES, 0&gt;(ctx[i]);
1634          keccakf(reinterpret_cast&lt;uint64_t*&gt;(ctx[i]-&gt;state), 24);
1635          extra_hashes[ctx[i]-&gt;state[0] &amp; 3](ctx[i]-&gt;state, 200, output + 32 * i);
1636      }
1637  }
1638  } &amp;bsol;* namespace xmrig */
1639  #endif &amp;bsol;* XMRIG_CRYPTONIGHT_X86_H */
</code></pre>
        </div>
        <div class="column">
            <h3>xmrig-MDEwOlJlcG9zaXRvcnk4ODMyNzQwNg==-flat-CryptoNight_x86.h</h3>
            <pre><code>1  #ifndef XMRIG_CRYPTONIGHT_X86_H
2  #define XMRIG_CRYPTONIGHT_X86_H
3  #ifdef __GNUC__
4  #   include &lt;x86intrin.h&gt;
5  #else
6  #   include &lt;intrin.h&gt;
7  #   define __restrict__ __restrict
8  #endif
9  #include &quot;backend/cpu/Cpu.h&quot;
10  #include &quot;base/crypto/keccak.h&quot;
11  #include &quot;crypto/cn/CnAlgo.h&quot;
12  #include &quot;crypto/cn/CryptoNight_monero.h&quot;
13  #include &quot;crypto/cn/CryptoNight.h&quot;
14  #include &quot;crypto/cn/soft_aes.h&quot;
15  #ifdef XMRIG_VAES
16  #   include &quot;crypto/cn/CryptoNight_x86_vaes.h&quot;
17  #endif
18  extern &quot;C&quot;
19  {
20  #include &quot;crypto/cn/c_groestl.h&quot;
21  #include &quot;crypto/cn/c_blake256.h&quot;
22  #include &quot;crypto/cn/c_jh.h&quot;
23  #include &quot;crypto/cn/c_skein.h&quot;
24  }
25  static inline void do_blake_hash(const uint8_t *input, size_t len, uint8_t *output) {
26      blake256_hash(output, input, len);
27  }
28  static inline void do_groestl_hash(const uint8_t *input, size_t len, uint8_t *output) {
29      groestl(input, len * 8, output);
30  }
31  static inline void do_jh_hash(const uint8_t *input, size_t len, uint8_t *output) {
32      jh_hash(32 * 8, input, 8 * len, output);
33  }
34  static inline void do_skein_hash(const uint8_t *input, size_t len, uint8_t *output) {
35      xmr_skein(input, output);
36  }
37  void (* const extra_hashes[4])(const uint8_t *, size_t, uint8_t *) = {do_blake_hash, do_groestl_hash, do_jh_hash, do_skein_hash};
38  #if (defined(__i386__) || defined(_M_IX86)) &amp;&amp; !(defined(__clang__) &amp;&amp; defined(__clang_major__) &amp;&amp; (__clang_major__ &gt;= 15))
39  static inline int64_t _mm_cvtsi128_si64(__m128i a)
40  {
41      return ((uint64_t)(uint32_t)_mm_cvtsi128_si32(a) | ((uint64_t)(uint32_t)_mm_cvtsi128_si32(_mm_srli_si128(a, 4)) &lt;&lt; 32));
42  }
43  static inline __m128i _mm_cvtsi64_si128(int64_t a) {
44      return _mm_set_epi64x(0, a);
45  }
46  #endif
47  static inline __m128i sl_xor(__m128i tmp1)
48  {
49      __m128i tmp4;
50      tmp4 = _mm_slli_si128(tmp1, 0x04);
51      tmp1 = _mm_xor_si128(tmp1, tmp4);
52      tmp4 = _mm_slli_si128(tmp4, 0x04);
53      tmp1 = _mm_xor_si128(tmp1, tmp4);
54      tmp4 = _mm_slli_si128(tmp4, 0x04);
55      tmp1 = _mm_xor_si128(tmp1, tmp4);
56      return tmp1;
57  }
58  template&lt;uint8_t rcon&gt;
59  static inline void aes_genkey_sub(__m128i* xout0, __m128i* xout2)
60  {
61      __m128i xout1 = _mm_aeskeygenassist_si128(*xout2, rcon);
62      xout1  = _mm_shuffle_epi32(xout1, 0xFF); 
63      *xout0 = sl_xor(*xout0);
64      *xout0 = _mm_xor_si128(*xout0, xout1);
65      xout1  = _mm_aeskeygenassist_si128(*xout0, 0x00);
66      xout1  = _mm_shuffle_epi32(xout1, 0xAA); 
67      *xout2 = sl_xor(*xout2);
68      *xout2 = _mm_xor_si128(*xout2, xout1);
69  }
70  template&lt;uint8_t rcon&gt;
71  static inline void soft_aes_genkey_sub(__m128i* xout0, __m128i* xout2)
72  {
73      __m128i xout1 = soft_aeskeygenassist&lt;rcon&gt;(*xout2);
74      xout1  = _mm_shuffle_epi32(xout1, 0xFF); 
75      *xout0 = sl_xor(*xout0);
76      *xout0 = _mm_xor_si128(*xout0, xout1);
77      xout1  = soft_aeskeygenassist&lt;0x00&gt;(*xout0);
78      xout1  = _mm_shuffle_epi32(xout1, 0xAA); 
79      *xout2 = sl_xor(*xout2);
80      *xout2 = _mm_xor_si128(*xout2, xout1);
81  }
82  template&lt;bool SOFT_AES&gt;
83  static inline void aes_genkey(const __m128i* memory, __m128i* k0, __m128i* k1, __m128i* k2, __m128i* k3, __m128i* k4, __m128i* k5, __m128i* k6, __m128i* k7, __m128i* k8, __m128i* k9)
84  {
85      __m128i xout0 = _mm_load_si128(memory);
86      __m128i xout2 = _mm_load_si128(memory + 1);
87      *k0 = xout0;
88      *k1 = xout2;
89      SOFT_AES ? soft_aes_genkey_sub&lt;0x01&gt;(&amp;xout0, &amp;xout2) : aes_genkey_sub&lt;0x01&gt;(&amp;xout0, &amp;xout2);
90      *k2 = xout0;
91      *k3 = xout2;
92      SOFT_AES ? soft_aes_genkey_sub&lt;0x02&gt;(&amp;xout0, &amp;xout2) : aes_genkey_sub&lt;0x02&gt;(&amp;xout0, &amp;xout2);
93      *k4 = xout0;
94      *k5 = xout2;
95      SOFT_AES ? soft_aes_genkey_sub&lt;0x04&gt;(&amp;xout0, &amp;xout2) : aes_genkey_sub&lt;0x04&gt;(&amp;xout0, &amp;xout2);
96      *k6 = xout0;
97      *k7 = xout2;
98      SOFT_AES ? soft_aes_genkey_sub&lt;0x08&gt;(&amp;xout0, &amp;xout2) : aes_genkey_sub&lt;0x08&gt;(&amp;xout0, &amp;xout2);
99      *k8 = xout0;
100      *k9 = xout2;
101  }
102  static FORCEINLINE void soft_aesenc(void* __restrict ptr, const void* __restrict key, const uint32_t* __restrict t)
103  {
104      uint32_t x0 = ((const uint32_t*)(ptr))[0];
105      uint32_t x1 = ((const uint32_t*)(ptr))[1];
106      uint32_t x2 = ((const uint32_t*)(ptr))[2];
107      uint32_t x3 = ((const uint32_t*)(ptr))[3];
108      uint32_t y0 = t[x0 &amp; 0xff]; x0 &gt;&gt;= 8;
109      uint32_t y1 = t[x1 &amp; 0xff]; x1 &gt;&gt;= 8;
110      uint32_t y2 = t[x2 &amp; 0xff]; x2 &gt;&gt;= 8;
111      uint32_t y3 = t[x3 &amp; 0xff]; x3 &gt;&gt;= 8;
112      t += 256;
113      y0 ^= t[x1 &amp; 0xff]; x1 &gt;&gt;= 8;
114      y1 ^= t[x2 &amp; 0xff]; x2 &gt;&gt;= 8;
115      y2 ^= t[x3 &amp; 0xff]; x3 &gt;&gt;= 8;
116      y3 ^= t[x0 &amp; 0xff]; x0 &gt;&gt;= 8;
117      t += 256;
118      y0 ^= t[x2 &amp; 0xff]; x2 &gt;&gt;= 8;
119      y1 ^= t[x3 &amp; 0xff]; x3 &gt;&gt;= 8;
120      y2 ^= t[x0 &amp; 0xff]; x0 &gt;&gt;= 8;
121      y3 ^= t[x1 &amp; 0xff]; x1 &gt;&gt;= 8;
122      t += 256;
123      y0 ^= t[x3];
124      y1 ^= t[x0];
125      y2 ^= t[x1];
126      y3 ^= t[x2];
127      ((uint32_t*)ptr)[0] = y0 ^ ((uint32_t*)key)[0];
128      ((uint32_t*)ptr)[1] = y1 ^ ((uint32_t*)key)[1];
129      ((uint32_t*)ptr)[2] = y2 ^ ((uint32_t*)key)[2];
130      ((uint32_t*)ptr)[3] = y3 ^ ((uint32_t*)key)[3];
131  }
132  static FORCEINLINE __m128i soft_aesenc(const void* __restrict ptr, const __m128i key, const uint32_t* __restrict t)
133  {
134      uint32_t x0 = ((const uint32_t*)(ptr))[0];
135      uint32_t x1 = ((const uint32_t*)(ptr))[1];
136      uint32_t x2 = ((const uint32_t*)(ptr))[2];
137      uint32_t x3 = ((const uint32_t*)(ptr))[3];
138      uint32_t y0 = t[x0 &amp; 0xff]; x0 &gt;&gt;= 8;
139      uint32_t y1 = t[x1 &amp; 0xff]; x1 &gt;&gt;= 8;
140      uint32_t y2 = t[x2 &amp; 0xff]; x2 &gt;&gt;= 8;
141      uint32_t y3 = t[x3 &amp; 0xff]; x3 &gt;&gt;= 8;
<span onclick='openModal()' class='match'>142      t += 256;
143      y0 ^= t[x1 &amp; 0xff]; x1 &gt;&gt;= 8;
144      y1 ^= t[x2 &amp; 0xff]; x2 &gt;&gt;= 8;
145      y2 ^= t[x3 &amp; 0xff]; x3 &gt;&gt;= 8;
146      y3 ^= t[x0 &amp; 0xff]; x0 &gt;&gt;= 8;
147      t += 256;
</span>148      y0 ^= t[x2 &amp; 0xff]; x2 &gt;&gt;= 8;
149      y1 ^= t[x3 &amp; 0xff]; x3 &gt;&gt;= 8;
150      y2 ^= t[x0 &amp; 0xff]; x0 &gt;&gt;= 8;
151      y3 ^= t[x1 &amp; 0xff]; x1 &gt;&gt;= 8;
152      y0 ^= t[x3 + 256];
153      y1 ^= t[x0 + 256];
154      y2 ^= t[x1 + 256];
155      y3 ^= t[x2 + 256];
156      return _mm_xor_si128(_mm_set_epi32(y3, y2, y1, y0), key);
157  }
158  template&lt;bool SOFT_AES&gt;
159  void aes_round(__m128i key, __m128i* x0, __m128i* x1, __m128i* x2, __m128i* x3, __m128i* x4, __m128i* x5, __m128i* x6, __m128i* x7);
160  template&lt;&gt;
161  NOINLINE void aes_round&lt;true&gt;(__m128i key, __m128i* x0, __m128i* x1, __m128i* x2, __m128i* x3, __m128i* x4, __m128i* x5, __m128i* x6, __m128i* x7)
162  {
163      *x0 = soft_aesenc((uint32_t*)x0, key, (const uint32_t*)saes_table);
164      *x1 = soft_aesenc((uint32_t*)x1, key, (const uint32_t*)saes_table);
165      *x2 = soft_aesenc((uint32_t*)x2, key, (const uint32_t*)saes_table);
166      *x3 = soft_aesenc((uint32_t*)x3, key, (const uint32_t*)saes_table);
167      *x4 = soft_aesenc((uint32_t*)x4, key, (const uint32_t*)saes_table);
168      *x5 = soft_aesenc((uint32_t*)x5, key, (const uint32_t*)saes_table);
169      *x6 = soft_aesenc((uint32_t*)x6, key, (const uint32_t*)saes_table);
170      *x7 = soft_aesenc((uint32_t*)x7, key, (const uint32_t*)saes_table);
171  }
172  template&lt;&gt;
173  FORCEINLINE void aes_round&lt;false&gt;(__m128i key, __m128i* x0, __m128i* x1, __m128i* x2, __m128i* x3, __m128i* x4, __m128i* x5, __m128i* x6, __m128i* x7)
174  {
175      *x0 = _mm_aesenc_si128(*x0, key);
176      *x1 = _mm_aesenc_si128(*x1, key);
177      *x2 = _mm_aesenc_si128(*x2, key);
178      *x3 = _mm_aesenc_si128(*x3, key);
179      *x4 = _mm_aesenc_si128(*x4, key);
180      *x5 = _mm_aesenc_si128(*x5, key);
181      *x6 = _mm_aesenc_si128(*x6, key);
182      *x7 = _mm_aesenc_si128(*x7, key);
183  }
184  inline void mix_and_propagate(__m128i&amp; x0, __m128i&amp; x1, __m128i&amp; x2, __m128i&amp; x3, __m128i&amp; x4, __m128i&amp; x5, __m128i&amp; x6, __m128i&amp; x7)
185  {
186      __m128i tmp0 = x0;
187      x0 = _mm_xor_si128(x0, x1);
188      x1 = _mm_xor_si128(x1, x2);
189      x2 = _mm_xor_si128(x2, x3);
190      x3 = _mm_xor_si128(x3, x4);
191      x4 = _mm_xor_si128(x4, x5);
192      x5 = _mm_xor_si128(x5, x6);
193      x6 = _mm_xor_si128(x6, x7);
194      x7 = _mm_xor_si128(x7, tmp0);
195  }
196  namespace xmrig {
197  template&lt;int interleave&gt;
198  static inline constexpr uint64_t interleaved_index(uint64_t k)
199  {
200      return ((k &amp; ~63ULL) &lt;&lt; interleave) | (k &amp; 63);
201  }
202  template&lt;&gt;
203  inline constexpr uint64_t interleaved_index&lt;0&gt;(uint64_t k)
204  {
205      return k;
206  }
207  template&lt;Algorithm::Id ALGO, bool SOFT_AES, int interleave&gt;
208  static NOINLINE void cn_explode_scratchpad(cryptonight_ctx *ctx)
209  {
210      constexpr CnAlgo&lt;ALGO&gt; props;
211  #   ifdef XMRIG_VAES
212      if (!SOFT_AES &amp;&amp; !props.isHeavy() &amp;&amp; cn_vaes_enabled) {
213          cn_explode_scratchpad_vaes(ctx, props.memory(), props.half_mem());
214          return;
215      }
216  #   endif
217      constexpr size_t N = (props.memory() / sizeof(__m128i)) / (props.half_mem() ? 2 : 1);
218      __m128i xin0, xin1, xin2, xin3, xin4, xin5, xin6, xin7;
219      __m128i k0, k1, k2, k3, k4, k5, k6, k7, k8, k9;
220      const __m128i* input = reinterpret_cast&lt;const __m128i*&gt;(ctx-&gt;state);
221      __m128i* output = reinterpret_cast&lt;__m128i*&gt;(ctx-&gt;memory);
222      aes_genkey&lt;SOFT_AES&gt;(input, &amp;k0, &amp;k1, &amp;k2, &amp;k3, &amp;k4, &amp;k5, &amp;k6, &amp;k7, &amp;k8, &amp;k9);
223      if (props.half_mem() &amp;&amp; !ctx-&gt;first_half) {
224          const __m128i* p = reinterpret_cast&lt;const __m128i*&gt;(ctx-&gt;save_state);
225          xin0 = _mm_load_si128(p + 0);
226          xin1 = _mm_load_si128(p + 1);
227          xin2 = _mm_load_si128(p + 2);
228          xin3 = _mm_load_si128(p + 3);
229          xin4 = _mm_load_si128(p + 4);
230          xin5 = _mm_load_si128(p + 5);
231          xin6 = _mm_load_si128(p + 6);
232          xin7 = _mm_load_si128(p + 7);
233      }
234      else {
235          xin0 = _mm_load_si128(input + 4);
236          xin1 = _mm_load_si128(input + 5);
237          xin2 = _mm_load_si128(input + 6);
238          xin3 = _mm_load_si128(input + 7);
239          xin4 = _mm_load_si128(input + 8);
240          xin5 = _mm_load_si128(input + 9);
241          xin6 = _mm_load_si128(input + 10);
242          xin7 = _mm_load_si128(input + 11);
243      }
244      if (props.isHeavy()) {
245          for (size_t i = 0; i &lt; 16; i++) {
246              aes_round&lt;SOFT_AES&gt;(k0, &amp;xin0, &amp;xin1, &amp;xin2, &amp;xin3, &amp;xin4, &amp;xin5, &amp;xin6, &amp;xin7);
247              aes_round&lt;SOFT_AES&gt;(k1, &amp;xin0, &amp;xin1, &amp;xin2, &amp;xin3, &amp;xin4, &amp;xin5, &amp;xin6, &amp;xin7);
248              aes_round&lt;SOFT_AES&gt;(k2, &amp;xin0, &amp;xin1, &amp;xin2, &amp;xin3, &amp;xin4, &amp;xin5, &amp;xin6, &amp;xin7);
249              aes_round&lt;SOFT_AES&gt;(k3, &amp;xin0, &amp;xin1, &amp;xin2, &amp;xin3, &amp;xin4, &amp;xin5, &amp;xin6, &amp;xin7);
250              aes_round&lt;SOFT_AES&gt;(k4, &amp;xin0, &amp;xin1, &amp;xin2, &amp;xin3, &amp;xin4, &amp;xin5, &amp;xin6, &amp;xin7);
251              aes_round&lt;SOFT_AES&gt;(k5, &amp;xin0, &amp;xin1, &amp;xin2, &amp;xin3, &amp;xin4, &amp;xin5, &amp;xin6, &amp;xin7);
252              aes_round&lt;SOFT_AES&gt;(k6, &amp;xin0, &amp;xin1, &amp;xin2, &amp;xin3, &amp;xin4, &amp;xin5, &amp;xin6, &amp;xin7);
253              aes_round&lt;SOFT_AES&gt;(k7, &amp;xin0, &amp;xin1, &amp;xin2, &amp;xin3, &amp;xin4, &amp;xin5, &amp;xin6, &amp;xin7);
254              aes_round&lt;SOFT_AES&gt;(k8, &amp;xin0, &amp;xin1, &amp;xin2, &amp;xin3, &amp;xin4, &amp;xin5, &amp;xin6, &amp;xin7);
255              aes_round&lt;SOFT_AES&gt;(k9, &amp;xin0, &amp;xin1, &amp;xin2, &amp;xin3, &amp;xin4, &amp;xin5, &amp;xin6, &amp;xin7);
256              mix_and_propagate(xin0, xin1, xin2, xin3, xin4, xin5, xin6, xin7);
257          }
258      }
259      constexpr int output_increment = (64 &lt;&lt; interleave) / sizeof(__m128i);
260      constexpr int prefetch_dist = 2048 / sizeof(__m128i);
261      __m128i* e = output + (N &lt;&lt; interleave) - prefetch_dist;
262      __m128i* prefetch_ptr = output + prefetch_dist;
263      for (int i = 0; i &lt; 2; ++i) {
264          do {
265              _mm_prefetch((const char*)(prefetch_ptr), _MM_HINT_T0);
266              _mm_prefetch((const char*)(prefetch_ptr + output_increment), _MM_HINT_T0);
267              aes_round&lt;SOFT_AES&gt;(k0, &amp;xin0, &amp;xin1, &amp;xin2, &amp;xin3, &amp;xin4, &amp;xin5, &amp;xin6, &amp;xin7);
268              aes_round&lt;SOFT_AES&gt;(k1, &amp;xin0, &amp;xin1, &amp;xin2, &amp;xin3, &amp;xin4, &amp;xin5, &amp;xin6, &amp;xin7);
269              aes_round&lt;SOFT_AES&gt;(k2, &amp;xin0, &amp;xin1, &amp;xin2, &amp;xin3, &amp;xin4, &amp;xin5, &amp;xin6, &amp;xin7);
270              aes_round&lt;SOFT_AES&gt;(k3, &amp;xin0, &amp;xin1, &amp;xin2, &amp;xin3, &amp;xin4, &amp;xin5, &amp;xin6, &amp;xin7);
271              aes_round&lt;SOFT_AES&gt;(k4, &amp;xin0, &amp;xin1, &amp;xin2, &amp;xin3, &amp;xin4, &amp;xin5, &amp;xin6, &amp;xin7);
272              aes_round&lt;SOFT_AES&gt;(k5, &amp;xin0, &amp;xin1, &amp;xin2, &amp;xin3, &amp;xin4, &amp;xin5, &amp;xin6, &amp;xin7);
273              aes_round&lt;SOFT_AES&gt;(k6, &amp;xin0, &amp;xin1, &amp;xin2, &amp;xin3, &amp;xin4, &amp;xin5, &amp;xin6, &amp;xin7);
274              aes_round&lt;SOFT_AES&gt;(k7, &amp;xin0, &amp;xin1, &amp;xin2, &amp;xin3, &amp;xin4, &amp;xin5, &amp;xin6, &amp;xin7);
275              aes_round&lt;SOFT_AES&gt;(k8, &amp;xin0, &amp;xin1, &amp;xin2, &amp;xin3, &amp;xin4, &amp;xin5, &amp;xin6, &amp;xin7);
276              aes_round&lt;SOFT_AES&gt;(k9, &amp;xin0, &amp;xin1, &amp;xin2, &amp;xin3, &amp;xin4, &amp;xin5, &amp;xin6, &amp;xin7);
277              _mm_store_si128(output + 0, xin0);
278              _mm_store_si128(output + 1, xin1);
279              _mm_store_si128(output + 2, xin2);
280              _mm_store_si128(output + 3, xin3);
281              _mm_store_si128(output + output_increment + 0, xin4);
282              _mm_store_si128(output + output_increment + 1, xin5);
283              _mm_store_si128(output + output_increment + 2, xin6);
284              _mm_store_si128(output + output_increment + 3, xin7);
285              output += output_increment * 2;
286              prefetch_ptr += output_increment * 2;
287          } while (output &lt; e);
288          e += prefetch_dist;
289          prefetch_ptr = output;
290      }
291      if (props.half_mem() &amp;&amp; ctx-&gt;first_half) {
292           __m128i* p = reinterpret_cast&lt;__m128i*&gt;(ctx-&gt;save_state);
293          _mm_store_si128(p + 0, xin0);
294          _mm_store_si128(p + 1, xin1);
295          _mm_store_si128(p + 2, xin2);
296          _mm_store_si128(p + 3, xin3);
297          _mm_store_si128(p + 4, xin4);
298          _mm_store_si128(p + 5, xin5);
299          _mm_store_si128(p + 6, xin6);
300          _mm_store_si128(p + 7, xin7);
301      }
302  }
303  template&lt;Algorithm::Id ALGO, bool SOFT_AES, int interleave&gt;
304  static NOINLINE void cn_implode_scratchpad(cryptonight_ctx *ctx)
305  {
306      constexpr CnAlgo&lt;ALGO&gt; props;
307  #   ifdef XMRIG_VAES
308      if (!SOFT_AES &amp;&amp; !props.isHeavy() &amp;&amp; cn_vaes_enabled) {
309          cn_implode_scratchpad_vaes(ctx, props.memory(), props.half_mem());
310          return;
311      }
312  #   endif
313      constexpr bool IS_HEAVY = props.isHeavy();
314      constexpr size_t N = (props.memory() / sizeof(__m128i)) / (props.half_mem() ? 2 : 1);
315      __m128i xout0, xout1, xout2, xout3, xout4, xout5, xout6, xout7;
316      __m128i k0, k1, k2, k3, k4, k5, k6, k7, k8, k9;
317      const __m128i *input = reinterpret_cast&lt;const __m128i*&gt;(ctx-&gt;memory);
318      __m128i *output = reinterpret_cast&lt;__m128i*&gt;(ctx-&gt;state);
319      aes_genkey&lt;SOFT_AES&gt;(output + 2, &amp;k0, &amp;k1, &amp;k2, &amp;k3, &amp;k4, &amp;k5, &amp;k6, &amp;k7, &amp;k8, &amp;k9);
320      xout0 = _mm_load_si128(output + 4);
321      xout1 = _mm_load_si128(output + 5);
322      xout2 = _mm_load_si128(output + 6);
323      xout3 = _mm_load_si128(output + 7);
324      xout4 = _mm_load_si128(output + 8);
325      xout5 = _mm_load_si128(output + 9);
326      xout6 = _mm_load_si128(output + 10);
327      xout7 = _mm_load_si128(output + 11);
328      const __m128i* input_begin = input;
329      for (size_t part = 0; part &lt; (props.half_mem() ? 2 : 1); ++part) {
330          if (props.half_mem() &amp;&amp; (part == 1)) {
331              input = input_begin;
332              ctx-&gt;first_half = false;
333              cn_explode_scratchpad&lt;ALGO, SOFT_AES, interleave&gt;(ctx);
334          }
335          for (size_t i = 0; i &lt; N;) {
336              xout0 = _mm_xor_si128(_mm_load_si128(input + 0), xout0);
337              xout1 = _mm_xor_si128(_mm_load_si128(input + 1), xout1);
338              xout2 = _mm_xor_si128(_mm_load_si128(input + 2), xout2);
339              xout3 = _mm_xor_si128(_mm_load_si128(input + 3), xout3);
340              constexpr int input_increment = (64 &lt;&lt; interleave) / sizeof(__m128i);
341              xout4 = _mm_xor_si128(_mm_load_si128(input + input_increment + 0), xout4);
342              xout5 = _mm_xor_si128(_mm_load_si128(input + input_increment + 1), xout5);
343              xout6 = _mm_xor_si128(_mm_load_si128(input + input_increment + 2), xout6);
344              xout7 = _mm_xor_si128(_mm_load_si128(input + input_increment + 3), xout7);
345              input += input_increment * 2;
346              i += 8;
347              if (i &lt; N) {
348                  _mm_prefetch((const char*)(input), _MM_HINT_T0);
349                  _mm_prefetch((const char*)(input + input_increment), _MM_HINT_T0);
350              }
351              aes_round&lt;SOFT_AES&gt;(k0, &amp;xout0, &amp;xout1, &amp;xout2, &amp;xout3, &amp;xout4, &amp;xout5, &amp;xout6, &amp;xout7);
352              aes_round&lt;SOFT_AES&gt;(k1, &amp;xout0, &amp;xout1, &amp;xout2, &amp;xout3, &amp;xout4, &amp;xout5, &amp;xout6, &amp;xout7);
353              aes_round&lt;SOFT_AES&gt;(k2, &amp;xout0, &amp;xout1, &amp;xout2, &amp;xout3, &amp;xout4, &amp;xout5, &amp;xout6, &amp;xout7);
354              aes_round&lt;SOFT_AES&gt;(k3, &amp;xout0, &amp;xout1, &amp;xout2, &amp;xout3, &amp;xout4, &amp;xout5, &amp;xout6, &amp;xout7);
355              aes_round&lt;SOFT_AES&gt;(k4, &amp;xout0, &amp;xout1, &amp;xout2, &amp;xout3, &amp;xout4, &amp;xout5, &amp;xout6, &amp;xout7);
356              aes_round&lt;SOFT_AES&gt;(k5, &amp;xout0, &amp;xout1, &amp;xout2, &amp;xout3, &amp;xout4, &amp;xout5, &amp;xout6, &amp;xout7);
357              aes_round&lt;SOFT_AES&gt;(k6, &amp;xout0, &amp;xout1, &amp;xout2, &amp;xout3, &amp;xout4, &amp;xout5, &amp;xout6, &amp;xout7);
358              aes_round&lt;SOFT_AES&gt;(k7, &amp;xout0, &amp;xout1, &amp;xout2, &amp;xout3, &amp;xout4, &amp;xout5, &amp;xout6, &amp;xout7);
359              aes_round&lt;SOFT_AES&gt;(k8, &amp;xout0, &amp;xout1, &amp;xout2, &amp;xout3, &amp;xout4, &amp;xout5, &amp;xout6, &amp;xout7);
360              aes_round&lt;SOFT_AES&gt;(k9, &amp;xout0, &amp;xout1, &amp;xout2, &amp;xout3, &amp;xout4, &amp;xout5, &amp;xout6, &amp;xout7);
361              if (IS_HEAVY) {
362                  mix_and_propagate(xout0, xout1, xout2, xout3, xout4, xout5, xout6, xout7);
363              }
364          }
365      }
366      if (IS_HEAVY) {
367          input = input_begin;
368          for (size_t i = 0; i &lt; N;) {
369              xout0 = _mm_xor_si128(_mm_load_si128(input + 0), xout0);
370              xout1 = _mm_xor_si128(_mm_load_si128(input + 1), xout1);
371              xout2 = _mm_xor_si128(_mm_load_si128(input + 2), xout2);
372              xout3 = _mm_xor_si128(_mm_load_si128(input + 3), xout3);
373              input += (64 &lt;&lt; interleave) / sizeof(__m128i);
374              xout4 = _mm_xor_si128(_mm_load_si128(input + 0), xout4);
375              xout5 = _mm_xor_si128(_mm_load_si128(input + 1), xout5);
376              xout6 = _mm_xor_si128(_mm_load_si128(input + 2), xout6);
377              xout7 = _mm_xor_si128(_mm_load_si128(input + 3), xout7);
378              input += (64 &lt;&lt; interleave) / sizeof(__m128i);
379              i += 8;
380              if ((interleave &gt; 0) &amp;&amp; (i &lt; props.memory() / sizeof(__m128i))) {
381                  _mm_prefetch((const char*)(input), _MM_HINT_T0);
382                  _mm_prefetch((const char*)(input + (64 &lt;&lt; interleave) / sizeof(__m128i)), _MM_HINT_T0);
383              }
384              aes_round&lt;SOFT_AES&gt;(k0, &amp;xout0, &amp;xout1, &amp;xout2, &amp;xout3, &amp;xout4, &amp;xout5, &amp;xout6, &amp;xout7);
385              aes_round&lt;SOFT_AES&gt;(k1, &amp;xout0, &amp;xout1, &amp;xout2, &amp;xout3, &amp;xout4, &amp;xout5, &amp;xout6, &amp;xout7);
386              aes_round&lt;SOFT_AES&gt;(k2, &amp;xout0, &amp;xout1, &amp;xout2, &amp;xout3, &amp;xout4, &amp;xout5, &amp;xout6, &amp;xout7);
387              aes_round&lt;SOFT_AES&gt;(k3, &amp;xout0, &amp;xout1, &amp;xout2, &amp;xout3, &amp;xout4, &amp;xout5, &amp;xout6, &amp;xout7);
388              aes_round&lt;SOFT_AES&gt;(k4, &amp;xout0, &amp;xout1, &amp;xout2, &amp;xout3, &amp;xout4, &amp;xout5, &amp;xout6, &amp;xout7);
389              aes_round&lt;SOFT_AES&gt;(k5, &amp;xout0, &amp;xout1, &amp;xout2, &amp;xout3, &amp;xout4, &amp;xout5, &amp;xout6, &amp;xout7);
390              aes_round&lt;SOFT_AES&gt;(k6, &amp;xout0, &amp;xout1, &amp;xout2, &amp;xout3, &amp;xout4, &amp;xout5, &amp;xout6, &amp;xout7);
391              aes_round&lt;SOFT_AES&gt;(k7, &amp;xout0, &amp;xout1, &amp;xout2, &amp;xout3, &amp;xout4, &amp;xout5, &amp;xout6, &amp;xout7);
392              aes_round&lt;SOFT_AES&gt;(k8, &amp;xout0, &amp;xout1, &amp;xout2, &amp;xout3, &amp;xout4, &amp;xout5, &amp;xout6, &amp;xout7);
393              aes_round&lt;SOFT_AES&gt;(k9, &amp;xout0, &amp;xout1, &amp;xout2, &amp;xout3, &amp;xout4, &amp;xout5, &amp;xout6, &amp;xout7);
394              mix_and_propagate(xout0, xout1, xout2, xout3, xout4, xout5, xout6, xout7);
395          }
396          for (size_t i = 0; i &lt; 16; i++) {
397              aes_round&lt;SOFT_AES&gt;(k0, &amp;xout0, &amp;xout1, &amp;xout2, &amp;xout3, &amp;xout4, &amp;xout5, &amp;xout6, &amp;xout7);
398              aes_round&lt;SOFT_AES&gt;(k1, &amp;xout0, &amp;xout1, &amp;xout2, &amp;xout3, &amp;xout4, &amp;xout5, &amp;xout6, &amp;xout7);
399              aes_round&lt;SOFT_AES&gt;(k2, &amp;xout0, &amp;xout1, &amp;xout2, &amp;xout3, &amp;xout4, &amp;xout5, &amp;xout6, &amp;xout7);
400              aes_round&lt;SOFT_AES&gt;(k3, &amp;xout0, &amp;xout1, &amp;xout2, &amp;xout3, &amp;xout4, &amp;xout5, &amp;xout6, &amp;xout7);
401              aes_round&lt;SOFT_AES&gt;(k4, &amp;xout0, &amp;xout1, &amp;xout2, &amp;xout3, &amp;xout4, &amp;xout5, &amp;xout6, &amp;xout7);
402              aes_round&lt;SOFT_AES&gt;(k5, &amp;xout0, &amp;xout1, &amp;xout2, &amp;xout3, &amp;xout4, &amp;xout5, &amp;xout6, &amp;xout7);
403              aes_round&lt;SOFT_AES&gt;(k6, &amp;xout0, &amp;xout1, &amp;xout2, &amp;xout3, &amp;xout4, &amp;xout5, &amp;xout6, &amp;xout7);
404              aes_round&lt;SOFT_AES&gt;(k7, &amp;xout0, &amp;xout1, &amp;xout2, &amp;xout3, &amp;xout4, &amp;xout5, &amp;xout6, &amp;xout7);
405              aes_round&lt;SOFT_AES&gt;(k8, &amp;xout0, &amp;xout1, &amp;xout2, &amp;xout3, &amp;xout4, &amp;xout5, &amp;xout6, &amp;xout7);
406              aes_round&lt;SOFT_AES&gt;(k9, &amp;xout0, &amp;xout1, &amp;xout2, &amp;xout3, &amp;xout4, &amp;xout5, &amp;xout6, &amp;xout7);
407              mix_and_propagate(xout0, xout1, xout2, xout3, xout4, xout5, xout6, xout7);
408          }
409      }
410      _mm_store_si128(output + 4, xout0);
411      _mm_store_si128(output + 5, xout1);
412      _mm_store_si128(output + 6, xout2);
413      _mm_store_si128(output + 7, xout3);
414      _mm_store_si128(output + 8, xout4);
415      _mm_store_si128(output + 9, xout5);
416      _mm_store_si128(output + 10, xout6);
417      _mm_store_si128(output + 11, xout7);
418  }
419  } &amp;bsol;* namespace xmrig */
420  static inline __m128i aes_round_tweak_div(const __m128i &amp;in, const __m128i &amp;key)
421  {
422      alignas(16) uint32_t k[4];
423      alignas(16) uint32_t x[4];
424      _mm_store_si128((__m128i*) k, key);
425      _mm_store_si128((__m128i*) x, _mm_xor_si128(in, _mm_set_epi64x(0xffffffffffffffff, 0xffffffffffffffff)));
426      #define BYTE(p, i) ((unsigned char*)&amp;x[p])[i]
427      k[0] ^= saes_table[0][BYTE(0, 0)] ^ saes_table[1][BYTE(1, 1)] ^ saes_table[2][BYTE(2, 2)] ^ saes_table[3][BYTE(3, 3)];
428      x[0] ^= k[0];
429      k[1] ^= saes_table[0][BYTE(1, 0)] ^ saes_table[1][BYTE(2, 1)] ^ saes_table[2][BYTE(3, 2)] ^ saes_table[3][BYTE(0, 3)];
430      x[1] ^= k[1];
431      k[2] ^= saes_table[0][BYTE(2, 0)] ^ saes_table[1][BYTE(3, 1)] ^ saes_table[2][BYTE(0, 2)] ^ saes_table[3][BYTE(1, 3)];
432      x[2] ^= k[2];
433      k[3] ^= saes_table[0][BYTE(3, 0)] ^ saes_table[1][BYTE(0, 1)] ^ saes_table[2][BYTE(1, 2)] ^ saes_table[3][BYTE(2, 3)];
434      #undef BYTE
435      return _mm_load_si128((__m128i*)k);
436  }
437  static inline __m128i int_sqrt_v2(const uint64_t n0)
438  {
439      __m128d x = _mm_castsi128_pd(_mm_add_epi64(_mm_cvtsi64_si128(n0 &gt;&gt; 12), _mm_set_epi64x(0, 1023ULL &lt;&lt; 52)));
440      x = _mm_sqrt_sd(_mm_setzero_pd(), x);
441      uint64_t r = static_cast&lt;uint64_t&gt;(_mm_cvtsi128_si64(_mm_castpd_si128(x)));
442      const uint64_t s = r &gt;&gt; 20;
443      r &gt;&gt;= 19;
444      uint64_t x2 = (s - (1022ULL &lt;&lt; 32)) * (r - s - (1022ULL &lt;&lt; 32) + 1);
445  #   if (defined(_MSC_VER) || __GNUC__ &gt; 7 || (__GNUC__ == 7 &amp;&amp; __GNUC_MINOR__ &gt; 1)) &amp;&amp; (defined(__x86_64__) || defined(_M_AMD64))
446      _addcarry_u64(_subborrow_u64(0, x2, n0, (unsigned long long int*)&amp;x2), r, 0, (unsigned long long int*)&amp;r);
447  #   else
448      if (x2 &lt; n0) ++r;
449  #   endif
450      return _mm_cvtsi64_si128(r);
451  }
452  void v4_soft_aes_compile_code(const V4_Instruction *code, int code_size, void *machine_code, xmrig::Assembly ASM);
453  alignas(64) static const uint32_t tweak1_table[256] = { 268435456,0,268435456,0,268435456,0,268435456,0,268435456,0,268435456,0,268435456,0,268435456,0,805306368,0,805306368,0,805306368,0,805306368,0,805306368,0,805306368,0,805306368,0,805306368,0,268435456,268435456,268435456,268435456,268435456,268435456,268435456,268435456,268435456,268435456,268435456,268435456,268435456,268435456,268435456,268435456,805306368,268435456,805306368,268435456,805306368,268435456,805306368,268435456,805306368,268435456,805306368,268435456,805306368,268435456,805306368,268435456,268435456,0,268435456,0,268435456,0,268435456,0,268435456,0,268435456,0,268435456,0,268435456,0,805306368,0,805306368,0,805306368,0,805306368,0,805306368,0,805306368,0,805306368,0,805306368,0,268435456,268435456,268435456,268435456,268435456,268435456,268435456,268435456,268435456,268435456,268435456,268435456,268435456,268435456,268435456,268435456,805306368,268435456,805306368,268435456,805306368,268435456,805306368,268435456,805306368,268435456,805306368,268435456,805306368,268435456,805306368,268435456,268435456,0,268435456,0,268435456,0,268435456,0,268435456,0,268435456,0,268435456,0,268435456,0,805306368,0,805306368,0,805306368,0,805306368,0,805306368,0,805306368,0,805306368,0,805306368,0,268435456,268435456,268435456,268435456,268435456,268435456,268435456,268435456,268435456,268435456,268435456,268435456,268435456,268435456,268435456,268435456,805306368,268435456,805306368,268435456,805306368,268435456,805306368,268435456,805306368,268435456,805306368,268435456,805306368,268435456,805306368,268435456,268435456,0,268435456,0,268435456,0,268435456,0,268435456,0,268435456,0,268435456,0,268435456,0,805306368,0,805306368,0,805306368,0,805306368,0,805306368,0,805306368,0,805306368,0,805306368,0,268435456,268435456,268435456,268435456,268435456,268435456,268435456,268435456,268435456,268435456,268435456,268435456,268435456,268435456,268435456,268435456,805306368,268435456,805306368,268435456,805306368,268435456,805306368,268435456,805306368,268435456,805306368,268435456,805306368,268435456,805306368,268435456 };
454  namespace xmrig {
455  template&lt;Algorithm::Id ALGO&gt;
456  static inline void cryptonight_monero_tweak(uint64_t *mem_out, const uint8_t *l, uint64_t idx, __m128i ax0, __m128i bx0, __m128i bx1, __m128i&amp; cx)
457  {
458      constexpr CnAlgo&lt;ALGO&gt; props;
459      if (props.base() == Algorithm::CN_2) {
460          VARIANT2_SHUFFLE(l, idx, ax0, bx0, bx1, cx, (((ALGO == Algorithm::CN_RWZ) || (ALGO == Algorithm::CN_UPX2)) ? 1 : 0));
461          _mm_store_si128(reinterpret_cast&lt;__m128i *&gt;(mem_out), _mm_xor_si128(bx0, cx));
462      } else {
463          __m128i tmp = _mm_xor_si128(bx0, cx);
464          mem_out[0] = _mm_cvtsi128_si64(tmp);
465          tmp = _mm_castps_si128(_mm_movehl_ps(_mm_castsi128_ps(tmp), _mm_castsi128_ps(tmp)));
466          uint64_t vh = _mm_cvtsi128_si64(tmp);
467          mem_out[1] = vh ^ tweak1_table[static_cast&lt;uint32_t&gt;(vh) &gt;&gt; 24];
468      }
469  }
470  static inline void cryptonight_conceal_tweak(__m128i&amp; cx, __m128&amp; conc_var)
471  {
472      __m128 r = _mm_add_ps(_mm_cvtepi32_ps(cx), conc_var);
473      r = _mm_mul_ps(r, _mm_mul_ps(r, r));
474      r = _mm_and_ps(_mm_castsi128_ps(_mm_set1_epi32(0x807FFFFF)), r);
475      r = _mm_or_ps(_mm_castsi128_ps(_mm_set1_epi32(0x40000000)), r);
476      __m128 c_old = conc_var;
477      conc_var = _mm_add_ps(conc_var, r);
478      c_old = _mm_and_ps(_mm_castsi128_ps(_mm_set1_epi32(0x807FFFFF)), c_old);
479      c_old = _mm_or_ps(_mm_castsi128_ps(_mm_set1_epi32(0x40000000)), c_old);
480      __m128 nc = _mm_mul_ps(c_old, _mm_set1_ps(536870880.0f));
481      cx = _mm_xor_si128(cx, _mm_cvttps_epi32(nc));
482  }
483  #ifdef XMRIG_FEATURE_ASM
484  template&lt;Algorithm::Id ALGO&gt;
485  static void cryptonight_single_hash_gr_sse41(const uint8_t* __restrict__ input, size_t size, uint8_t* __restrict__ output, cryptonight_ctx** __restrict__ ctx, uint64_t height);
486  #endif
487  template&lt;Algorithm::Id ALGO, bool SOFT_AES, int interleave&gt;
488  inline void cryptonight_single_hash(const uint8_t *__restrict__ input, size_t size, uint8_t *__restrict__ output, cryptonight_ctx **__restrict__ ctx, uint64_t height)
489  {
490  #   ifdef XMRIG_FEATURE_ASM
491      if (!SOFT_AES) {
492          switch (ALGO) {
493          case Algorithm::CN_GR_0:
494          case Algorithm::CN_GR_1:
495          case Algorithm::CN_GR_2:
496          case Algorithm::CN_GR_3:
497          case Algorithm::CN_GR_4:
498          case Algorithm::CN_GR_5:
499              if (cn_sse41_enabled) {
500                  cryptonight_single_hash_gr_sse41&lt;ALGO&gt;(input, size, output, ctx, height);
501                  return;
502              }
503              break;
504          default:
505              break;
506          }
507      }
508  #   endif
509      constexpr CnAlgo&lt;ALGO&gt; props;
510      constexpr size_t MASK        = props.mask();
511      constexpr Algorithm::Id BASE = props.base();
512  #   ifdef XMRIG_ALGO_CN_HEAVY
513      constexpr bool IS_CN_HEAVY_TUBE = ALGO == Algorithm::CN_HEAVY_TUBE;
514  #   else
515      constexpr bool IS_CN_HEAVY_TUBE = false;
516  #   endif
517      if (BASE == Algorithm::CN_1 &amp;&amp; size &lt; 43) {
518          memset(output, 0, 32);
519          return;
520      }
521      keccak(input, size, ctx[0]-&gt;state);
522      if (props.half_mem()) {
523          ctx[0]-&gt;first_half = true;
524      }
525      cn_explode_scratchpad&lt;ALGO, SOFT_AES, interleave&gt;(ctx[0]);
526      uint64_t *h0 = reinterpret_cast&lt;uint64_t*&gt;(ctx[0]-&gt;state);
527      uint8_t *l0   = ctx[0]-&gt;memory;
528  #   ifdef XMRIG_FEATURE_ASM
529      if (SOFT_AES &amp;&amp; props.isR()) {
530          if (!ctx[0]-&gt;generated_code_data.match(ALGO, height)) {
531              V4_Instruction code[256];
532              const int code_size = v4_random_math_init&lt;ALGO&gt;(code, height);
533              if (ALGO == Algorithm::CN_R) {
534                  v4_soft_aes_compile_code(code, code_size, reinterpret_cast&lt;void*&gt;(ctx[0]-&gt;generated_code), Assembly::NONE);
535              }
536              ctx[0]-&gt;generated_code_data = { ALGO, height };
537          }
538          ctx[0]-&gt;saes_table = reinterpret_cast&lt;const uint32_t*&gt;(saes_table);
539          ctx[0]-&gt;generated_code(ctx);
540      } else {
541  #   endif
542      VARIANT1_INIT(0);
543      VARIANT2_INIT(0);
544      VARIANT2_SET_ROUNDING_MODE();
545      VARIANT4_RANDOM_MATH_INIT(0);
546      uint64_t al0  = h0[0] ^ h0[4];
547      uint64_t ah0  = h0[1] ^ h0[5];
548      uint64_t idx0 = al0;
549      __m128i bx0   = _mm_set_epi64x(static_cast&lt;int64_t&gt;(h0[3] ^ h0[7]), static_cast&lt;int64_t&gt;(h0[2] ^ h0[6]));
550      __m128i bx1   = _mm_set_epi64x(static_cast&lt;int64_t&gt;(h0[9] ^ h0[11]), static_cast&lt;int64_t&gt;(h0[8] ^ h0[10]));
551      __m128 conc_var;
552      if (ALGO == Algorithm::CN_CCX) {
553          conc_var = _mm_setzero_ps();
554          RESTORE_ROUNDING_MODE();
555      }
556      for (size_t i = 0; i &lt; props.iterations(); i++) {
557          __m128i cx;
558          if (IS_CN_HEAVY_TUBE || !SOFT_AES) {
559              cx = _mm_load_si128(reinterpret_cast&lt;const __m128i *&gt;(&amp;l0[interleaved_index&lt;interleave&gt;(idx0 &amp; MASK)]));
560              if (ALGO == Algorithm::CN_CCX) {
561                  cryptonight_conceal_tweak(cx, conc_var);
562              }
563          }
564          const __m128i ax0 = _mm_set_epi64x(static_cast&lt;int64_t&gt;(ah0), static_cast&lt;int64_t&gt;(al0));
565          if (IS_CN_HEAVY_TUBE) {
566              cx = aes_round_tweak_div(cx, ax0);
567          }
568          else if (SOFT_AES) {
569              if (ALGO == Algorithm::CN_CCX) {
570                  cx = _mm_load_si128(reinterpret_cast&lt;const __m128i*&gt;(&amp;l0[interleaved_index&lt;interleave&gt;(idx0 &amp; MASK)]));
571                  cryptonight_conceal_tweak(cx, conc_var);
572                  cx = soft_aesenc(&amp;cx, ax0, reinterpret_cast&lt;const uint32_t*&gt;(saes_table));
573              }
574              else {
575                  cx = soft_aesenc(&amp;l0[interleaved_index&lt;interleave&gt;(idx0 &amp; MASK)], ax0, reinterpret_cast&lt;const uint32_t*&gt;(saes_table));
576              }
577          }
578          else {
579              cx = _mm_aesenc_si128(cx, ax0);
580          }
581          if (BASE == Algorithm::CN_1 || BASE == Algorithm::CN_2) {
582              cryptonight_monero_tweak&lt;ALGO&gt;(reinterpret_cast&lt;uint64_t*&gt;(&amp;l0[interleaved_index&lt;interleave&gt;(idx0 &amp; MASK)]), l0, idx0 &amp; MASK, ax0, bx0, bx1, cx);
583          } else {
584              _mm_store_si128(reinterpret_cast&lt;__m128i *&gt;(&amp;l0[interleaved_index&lt;interleave&gt;(idx0 &amp; MASK)]), _mm_xor_si128(bx0, cx));
585          }
586          idx0 = static_cast&lt;uint64_t&gt;(_mm_cvtsi128_si64(cx));
587          uint64_t hi, lo, cl, ch;
588          cl = (reinterpret_cast&lt;uint64_t*&gt;(&amp;l0[interleaved_index&lt;interleave&gt;(idx0 &amp; MASK)]))[0];
589          ch = (reinterpret_cast&lt;uint64_t*&gt;(&amp;l0[interleaved_index&lt;interleave&gt;(idx0 &amp; MASK)]))[1];
590          if (BASE == Algorithm::CN_2) {
591              if (props.isR()) {
592                  VARIANT4_RANDOM_MATH(0, al0, ah0, cl, bx0, bx1);
593                  if (ALGO == Algorithm::CN_R) {
594                      al0 ^= r0[2] | (static_cast&lt;uint64_t&gt;(r0[3]) &lt;&lt; 32);
595                      ah0 ^= r0[0] | (static_cast&lt;uint64_t&gt;(r0[1]) &lt;&lt; 32);
596                  }
597              } else {
598                  VARIANT2_INTEGER_MATH(0, cl, cx);
599              }
600          }
601          lo = __umul128(idx0, cl, &amp;hi);
602          if (BASE == Algorithm::CN_2) {
603              if (ALGO == Algorithm::CN_R) {
604                  VARIANT2_SHUFFLE(l0, idx0 &amp; MASK, ax0, bx0, bx1, cx, 0);
605              } else {
606                  VARIANT2_SHUFFLE2(l0, idx0 &amp; MASK, ax0, bx0, bx1, hi, lo, (((ALGO == Algorithm::CN_RWZ) || (ALGO == Algorithm::CN_UPX2)) ? 1 : 0));
607              }
608          }
609          al0 += hi;
610          ah0 += lo;
611          reinterpret_cast&lt;uint64_t*&gt;(&amp;l0[interleaved_index&lt;interleave&gt;(idx0 &amp; MASK)])[0] = al0;
612          if (IS_CN_HEAVY_TUBE || ALGO == Algorithm::CN_RTO) {
613              reinterpret_cast&lt;uint64_t*&gt;(&amp;l0[interleaved_index&lt;interleave&gt;(idx0 &amp; MASK)])[1] = ah0 ^ tweak1_2_0 ^ al0;
614          } else if (BASE == Algorithm::CN_1) {
615              reinterpret_cast&lt;uint64_t*&gt;(&amp;l0[interleaved_index&lt;interleave&gt;(idx0 &amp; MASK)])[1] = ah0 ^ tweak1_2_0;
616          } else {
617              reinterpret_cast&lt;uint64_t*&gt;(&amp;l0[interleaved_index&lt;interleave&gt;(idx0 &amp; MASK)])[1] = ah0;
618          }
619          al0 ^= cl;
620          ah0 ^= ch;
621          idx0 = al0;
622  #       ifdef XMRIG_ALGO_CN_HEAVY
623          if (props.isHeavy()) {
624              int64_t n = ((int64_t*)&amp;l0[interleaved_index&lt;interleave&gt;(idx0 &amp; MASK)])[0];
625              int64_t d = ((int32_t*)&amp;l0[interleaved_index&lt;interleave&gt;(idx0 &amp; MASK)])[2];
626              int64_t d5;
627  #           if defined(_MSC_VER) || (defined(__GNUC__) &amp;&amp; (__GNUC__ == 8)) || !defined(XMRIG_64_BIT)
628              d5 = d | 5;
629  #           else
630              asm(&quot;mov %1, %0\n\tor $5, %0&quot; : &quot;=r&quot;(d5) : &quot;r&quot;(d));
631  #           endif
632              int64_t q = n / d5;
633              ((int64_t*)&amp;l0[interleaved_index&lt;interleave&gt;(idx0 &amp; MASK)])[0] = n ^ q;
634              if (ALGO == Algorithm::CN_HEAVY_XHV) {
635                  d = ~d;
636              }
637              idx0 = d ^ q;
638          }
639  #       endif
640          if (BASE == Algorithm::CN_2) {
641              bx1 = bx0;
642          }
643          bx0 = cx;
644      }
645  #   ifdef XMRIG_FEATURE_ASM
646      }
647  #   endif
648      cn_implode_scratchpad&lt;ALGO, SOFT_AES, interleave&gt;(ctx[0]);
649      keccakf(h0, 24);
650      extra_hashes[ctx[0]-&gt;state[0] &amp; 3](ctx[0]-&gt;state, 200, output);
651  }
652  } &amp;bsol;* namespace xmrig */
653  #ifdef XMRIG_FEATURE_ASM
654  extern &quot;C&quot; void cnv1_single_mainloop_asm(cryptonight_ctx * *ctx);
655  extern &quot;C&quot; void cnv1_double_mainloop_asm(cryptonight_ctx **ctx);
656  extern &quot;C&quot; void cnv1_quad_mainloop_asm(cryptonight_ctx **ctx);
657  extern &quot;C&quot; void cnv2_mainloop_ivybridge_asm(cryptonight_ctx **ctx);
658  extern &quot;C&quot; void cnv2_mainloop_ryzen_asm(cryptonight_ctx **ctx);
659  extern &quot;C&quot; void cnv2_mainloop_bulldozer_asm(cryptonight_ctx **ctx);
660  extern &quot;C&quot; void cnv2_double_mainloop_sandybridge_asm(cryptonight_ctx **ctx);
661  extern &quot;C&quot; void cnv2_rwz_mainloop_asm(cryptonight_ctx **ctx);
662  extern &quot;C&quot; void cnv2_rwz_double_mainloop_asm(cryptonight_ctx **ctx);
663  extern &quot;C&quot; void cnv2_upx_double_mainloop_zen3_asm(cryptonight_ctx **ctx);
664  namespace xmrig {
665  typedef void (*cn_mainloop_fun)(cryptonight_ctx **ctx);
666  extern cn_mainloop_fun cn_half_mainloop_ivybridge_asm;
667  extern cn_mainloop_fun cn_half_mainloop_ryzen_asm;
668  extern cn_mainloop_fun cn_half_mainloop_bulldozer_asm;
669  extern cn_mainloop_fun cn_half_double_mainloop_sandybridge_asm;
670  extern cn_mainloop_fun cn_trtl_mainloop_ivybridge_asm;
671  extern cn_mainloop_fun cn_trtl_mainloop_ryzen_asm;
672  extern cn_mainloop_fun cn_trtl_mainloop_bulldozer_asm;
673  extern cn_mainloop_fun cn_trtl_double_mainloop_sandybridge_asm;
674  extern cn_mainloop_fun cn_tlo_mainloop_ivybridge_asm;
675  extern cn_mainloop_fun cn_tlo_mainloop_ryzen_asm;
676  extern cn_mainloop_fun cn_tlo_mainloop_bulldozer_asm;
677  extern cn_mainloop_fun cn_tlo_double_mainloop_sandybridge_asm;
678  extern cn_mainloop_fun cn_zls_mainloop_ivybridge_asm;
679  extern cn_mainloop_fun cn_zls_mainloop_ryzen_asm;
680  extern cn_mainloop_fun cn_zls_mainloop_bulldozer_asm;
681  extern cn_mainloop_fun cn_zls_double_mainloop_sandybridge_asm;
682  extern cn_mainloop_fun cn_double_mainloop_ivybridge_asm;
683  extern cn_mainloop_fun cn_double_mainloop_ryzen_asm;
684  extern cn_mainloop_fun cn_double_mainloop_bulldozer_asm;
685  extern cn_mainloop_fun cn_double_double_mainloop_sandybridge_asm;
686  extern cn_mainloop_fun cn_upx2_mainloop_asm;
687  extern cn_mainloop_fun cn_upx2_double_mainloop_asm;
688  extern cn_mainloop_fun cn_gr0_single_mainloop_asm;
689  extern cn_mainloop_fun cn_gr1_single_mainloop_asm;
690  extern cn_mainloop_fun cn_gr2_single_mainloop_asm;
691  extern cn_mainloop_fun cn_gr3_single_mainloop_asm;
692  extern cn_mainloop_fun cn_gr4_single_mainloop_asm;
693  extern cn_mainloop_fun cn_gr5_single_mainloop_asm;
694  extern cn_mainloop_fun cn_gr0_double_mainloop_asm;
695  extern cn_mainloop_fun cn_gr1_double_mainloop_asm;
696  extern cn_mainloop_fun cn_gr2_double_mainloop_asm;
697  extern cn_mainloop_fun cn_gr3_double_mainloop_asm;
698  extern cn_mainloop_fun cn_gr4_double_mainloop_asm;
699  extern cn_mainloop_fun cn_gr5_double_mainloop_asm;
700  extern cn_mainloop_fun cn_gr0_quad_mainloop_asm;
701  extern cn_mainloop_fun cn_gr1_quad_mainloop_asm;
702  extern cn_mainloop_fun cn_gr2_quad_mainloop_asm;
703  extern cn_mainloop_fun cn_gr3_quad_mainloop_asm;
704  extern cn_mainloop_fun cn_gr4_quad_mainloop_asm;
705  extern cn_mainloop_fun cn_gr5_quad_mainloop_asm;
706  } 
707  void v4_compile_code(const V4_Instruction* code, int code_size, void* machine_code, xmrig::Assembly ASM);
708  void v4_compile_code_double(const V4_Instruction* code, int code_size, void* machine_code, xmrig::Assembly ASM);
709  template&lt;xmrig::Algorithm::Id ALGO&gt;
710  void cn_r_compile_code(const V4_Instruction* code, int code_size, void* machine_code, xmrig::Assembly ASM)
711  {
712      v4_compile_code(code, code_size, machine_code, ASM);
713  }
714  template&lt;xmrig::Algorithm::Id ALGO&gt;
715  void cn_r_compile_code_double(const V4_Instruction* code, int code_size, void* machine_code, xmrig::Assembly ASM)
716  {
717      v4_compile_code_double(code, code_size, machine_code, ASM);
718  }
719  namespace xmrig {
720  template&lt;Algorithm::Id ALGO, Assembly::Id ASM&gt;
721  inline void cryptonight_single_hash_asm(const uint8_t *__restrict__ input, size_t size, uint8_t *__restrict__ output, cryptonight_ctx **__restrict__ ctx, uint64_t height)
722  {
723      constexpr CnAlgo&lt;ALGO&gt; props;
724      if (props.isR() &amp;&amp; !ctx[0]-&gt;generated_code_data.match(ALGO, height)) {
725          V4_Instruction code[256];
726          const int code_size = v4_random_math_init&lt;ALGO&gt;(code, height);
727          cn_r_compile_code&lt;ALGO&gt;(code, code_size, reinterpret_cast&lt;void*&gt;(ctx[0]-&gt;generated_code), ASM);
728          ctx[0]-&gt;generated_code_data = { ALGO, height };
729      }
730      keccak(input, size, ctx[0]-&gt;state);
731      if (props.half_mem()) {
732          ctx[0]-&gt;first_half = true;
733      }
734      cn_explode_scratchpad&lt;ALGO, false, 0&gt;(ctx[0]);
735      if (ALGO == Algorithm::CN_2) {
736          if (ASM == Assembly::INTEL) {
737              cnv2_mainloop_ivybridge_asm(ctx);
738          }
739          else if (ASM == Assembly::RYZEN) {
740              cnv2_mainloop_ryzen_asm(ctx);
741          }
742          else {
743              cnv2_mainloop_bulldozer_asm(ctx);
744          }
745      }
746      else if (ALGO == Algorithm::CN_HALF) {
747          if (ASM == Assembly::INTEL) {
748              cn_half_mainloop_ivybridge_asm(ctx);
749          }
750          else if (ASM == Assembly::RYZEN) {
751              cn_half_mainloop_ryzen_asm(ctx);
752          }
753          else {
754              cn_half_mainloop_bulldozer_asm(ctx);
755          }
756      }
757  #   ifdef XMRIG_ALGO_CN_PICO
758      else if (ALGO == Algorithm::CN_PICO_0) {
759          if (ASM == Assembly::INTEL) {
760              cn_trtl_mainloop_ivybridge_asm(ctx);
761          }
762          else if (ASM == Assembly::RYZEN) {
763              cn_trtl_mainloop_ryzen_asm(ctx);
764          }
765          else {
766              cn_trtl_mainloop_bulldozer_asm(ctx);
767          }
768      }
769      else if (ALGO == Algorithm::CN_PICO_TLO) {
770          if (ASM == Assembly::INTEL) {
771              cn_tlo_mainloop_ivybridge_asm(ctx);
772          }
773          else if (ASM == Assembly::RYZEN) {
774              cn_tlo_mainloop_ryzen_asm(ctx);
775          }
776          else {
777              cn_tlo_mainloop_bulldozer_asm(ctx);
778          }
779      }
780  #   endif
781      else if (ALGO == Algorithm::CN_RWZ) {
782          cnv2_rwz_mainloop_asm(ctx);
783      }
784      else if (ALGO == Algorithm::CN_ZLS) {
785          if (ASM == Assembly::INTEL) {
786              cn_zls_mainloop_ivybridge_asm(ctx);
787          }
788          else if (ASM == Assembly::RYZEN) {
789              cn_zls_mainloop_ryzen_asm(ctx);
790          }
791          else {
792              cn_zls_mainloop_bulldozer_asm(ctx);
793          }
794      }
795      else if (ALGO == Algorithm::CN_DOUBLE) {
796          if (ASM == Assembly::INTEL) {
797              cn_double_mainloop_ivybridge_asm(ctx);
798          }
799          else if (ASM == Assembly::RYZEN) {
800              cn_double_mainloop_ryzen_asm(ctx);
801          }
802          else {
803              cn_double_mainloop_bulldozer_asm(ctx);
804          }
805      }
806  #   ifdef XMRIG_ALGO_CN_FEMTO
807      else if (ALGO == Algorithm::CN_UPX2) {
808          cn_upx2_mainloop_asm(ctx);
809      }
810  #   endif
811      else if (props.isR()) {
812          ctx[0]-&gt;generated_code(ctx);
813      }
814      cn_implode_scratchpad&lt;ALGO, false, 0&gt;(ctx[0]);
815      keccakf(reinterpret_cast&lt;uint64_t*&gt;(ctx[0]-&gt;state), 24);
816      extra_hashes[ctx[0]-&gt;state[0] &amp; 3](ctx[0]-&gt;state, 200, output);
817  }
818  template&lt;Algorithm::Id ALGO, Assembly::Id ASM&gt;
819  inline void cryptonight_double_hash_asm(const uint8_t *__restrict__ input, size_t size, uint8_t *__restrict__ output, cryptonight_ctx **__restrict__ ctx, uint64_t height)
820  {
821      constexpr CnAlgo&lt;ALGO&gt; props;
822      if (props.isR() &amp;&amp; !ctx[0]-&gt;generated_code_data.match(ALGO, height)) {
823          V4_Instruction code[256];
824          const int code_size = v4_random_math_init&lt;ALGO&gt;(code, height);
825          cn_r_compile_code_double&lt;ALGO&gt;(code, code_size, reinterpret_cast&lt;void*&gt;(ctx[0]-&gt;generated_code), ASM);
826          ctx[0]-&gt;generated_code_data = { ALGO, height };
827      }
828      keccak(input,        size, ctx[0]-&gt;state);
829      keccak(input + size, size, ctx[1]-&gt;state);
830      if (props.half_mem()) {
831          ctx[0]-&gt;first_half = true;
832          ctx[1]-&gt;first_half = true;
833      }
834  #   ifdef XMRIG_VAES
835      if (!props.isHeavy() &amp;&amp; cn_vaes_enabled) {
836          cn_explode_scratchpad_vaes_double(ctx[0], ctx[1], props.memory(), props.half_mem());
837      }
838      else
839  #   endif
840      {
841          cn_explode_scratchpad&lt;ALGO, false, 0&gt;(ctx[0]);
842          cn_explode_scratchpad&lt;ALGO, false, 0&gt;(ctx[1]);
843      }
844      if (ALGO == Algorithm::CN_2) {
845          cnv2_double_mainloop_sandybridge_asm(ctx);
846      }
847      else if (ALGO == Algorithm::CN_HALF) {
848          cn_half_double_mainloop_sandybridge_asm(ctx);
849      }
850  #   ifdef XMRIG_ALGO_CN_PICO
851      else if (ALGO == Algorithm::CN_PICO_0) {
852          cn_trtl_double_mainloop_sandybridge_asm(ctx);
853      }
854      else if (ALGO == Algorithm::CN_PICO_TLO) {
855          cn_tlo_double_mainloop_sandybridge_asm(ctx);
856      }
857  #   endif
858  #   ifdef XMRIG_ALGO_CN_FEMTO
859      else if (ALGO == Algorithm::CN_UPX2) {
860          if (Cpu::info()-&gt;arch() == ICpuInfo::ARCH_ZEN3) {
861              cnv2_upx_double_mainloop_zen3_asm(ctx);
862          }
863          else {
864              cn_upx2_double_mainloop_asm(ctx);
865          }
866      }
867  #   endif
868      else if (ALGO == Algorithm::CN_RWZ) {
869          cnv2_rwz_double_mainloop_asm(ctx);
870      }
871      else if (ALGO == Algorithm::CN_ZLS) {
872          cn_zls_double_mainloop_sandybridge_asm(ctx);
873      }
874      else if (ALGO == Algorithm::CN_DOUBLE) {
875          cn_double_double_mainloop_sandybridge_asm(ctx);
876      }
877      else if (props.isR()) {
878          ctx[0]-&gt;generated_code(ctx);
879      }
880  #   ifdef XMRIG_VAES
881      if (!props.isHeavy() &amp;&amp; cn_vaes_enabled) {
882          cn_implode_scratchpad_vaes_double(ctx[0], ctx[1], props.memory(), props.half_mem());
883      }
884      else
885  #   endif
886      {
887          cn_implode_scratchpad&lt;ALGO, false, 0&gt;(ctx[0]);
888          cn_implode_scratchpad&lt;ALGO, false, 0&gt;(ctx[1]);
889      }
890      keccakf(reinterpret_cast&lt;uint64_t*&gt;(ctx[0]-&gt;state), 24);
891      keccakf(reinterpret_cast&lt;uint64_t*&gt;(ctx[1]-&gt;state), 24);
892      extra_hashes[ctx[0]-&gt;state[0] &amp; 3](ctx[0]-&gt;state, 200, output);
893      extra_hashes[ctx[1]-&gt;state[0] &amp; 3](ctx[1]-&gt;state, 200, output + 32);
894  }
895  } &amp;bsol;* namespace xmrig */
896  #endif
897  namespace xmrig {
898  #ifdef XMRIG_FEATURE_ASM
899  template&lt;Algorithm::Id ALGO&gt;
900  static NOINLINE void cryptonight_single_hash_gr_sse41(const uint8_t* __restrict__ input, size_t size, uint8_t* __restrict__ output, cryptonight_ctx** __restrict__ ctx, uint64_t height)
901  {
902      constexpr CnAlgo&lt;ALGO&gt; props;
903      constexpr Algorithm::Id BASE = props.base();
904      if (BASE == Algorithm::CN_1 &amp;&amp; size &lt; 43) {
905          memset(output, 0, 32);
906          return;
907      }
908      keccak(input, size, ctx[0]-&gt;state);
909      if (props.half_mem()) {
910          ctx[0]-&gt;first_half = true;
911      }
912      cn_explode_scratchpad&lt;ALGO, false, 0&gt;(ctx[0]);
913      VARIANT1_INIT(0);
914      ctx[0]-&gt;tweak1_2 = tweak1_2_0;
915      ctx[0]-&gt;tweak1_table = tweak1_table;
916      if (ALGO == Algorithm::CN_GR_0) cn_gr0_single_mainloop_asm(ctx);
917      if (ALGO == Algorithm::CN_GR_1) cn_gr1_single_mainloop_asm(ctx);
918      if (ALGO == Algorithm::CN_GR_2) cn_gr2_single_mainloop_asm(ctx);
919      if (ALGO == Algorithm::CN_GR_3) cn_gr3_single_mainloop_asm(ctx);
920      if (ALGO == Algorithm::CN_GR_4) cn_gr4_single_mainloop_asm(ctx);
921      if (ALGO == Algorithm::CN_GR_5) cn_gr5_single_mainloop_asm(ctx);
922      cn_implode_scratchpad&lt;ALGO, false, 0&gt;(ctx[0]);
923      keccakf(reinterpret_cast&lt;uint64_t*&gt;(ctx[0]-&gt;state), 24);
924      extra_hashes[ctx[0]-&gt;state[0] &amp; 3](ctx[0]-&gt;state, 200, output);
925  }
926  template&lt;Algorithm::Id ALGO&gt;
927  static NOINLINE void cryptonight_double_hash_gr_sse41(const uint8_t *__restrict__ input, size_t size, uint8_t *__restrict__ output, cryptonight_ctx **__restrict__ ctx, uint64_t height)
928  {
929      constexpr CnAlgo&lt;ALGO&gt; props;
930      constexpr Algorithm::Id BASE = props.base();
931      if (BASE == Algorithm::CN_1 &amp;&amp; size &lt; 43) {
932          memset(output, 0, 64);
933          return;
934      }
935      keccak(input,        size, ctx[0]-&gt;state);
936      keccak(input + size, size, ctx[1]-&gt;state);
937      if (props.half_mem()) {
938          ctx[0]-&gt;first_half = true;
939          ctx[1]-&gt;first_half = true;
940      }
941  #   ifdef XMRIG_VAES
942      if (!props.isHeavy() &amp;&amp; cn_vaes_enabled) {
943          cn_explode_scratchpad_vaes_double(ctx[0], ctx[1], props.memory(), props.half_mem());
944      }
945      else
946  #   endif
947      {
948          cn_explode_scratchpad&lt;ALGO, false, 0&gt;(ctx[0]);
949          cn_explode_scratchpad&lt;ALGO, false, 0&gt;(ctx[1]);
950      }
951      VARIANT1_INIT(0);
952      VARIANT1_INIT(1);
953      ctx[0]-&gt;tweak1_2 = tweak1_2_0;
954      ctx[1]-&gt;tweak1_2 = tweak1_2_1;
955      ctx[0]-&gt;tweak1_table = tweak1_table;
956      if (ALGO == Algorithm::CN_GR_0) cn_gr0_double_mainloop_asm(ctx);
957      if (ALGO == Algorithm::CN_GR_1) cn_gr1_double_mainloop_asm(ctx);
958      if (ALGO == Algorithm::CN_GR_2) cn_gr2_double_mainloop_asm(ctx);
959      if (ALGO == Algorithm::CN_GR_3) cn_gr3_double_mainloop_asm(ctx);
960      if (ALGO == Algorithm::CN_GR_4) cn_gr4_double_mainloop_asm(ctx);
961      if (ALGO == Algorithm::CN_GR_5) cn_gr5_double_mainloop_asm(ctx);
962  #   ifdef XMRIG_VAES
963      if (!props.isHeavy() &amp;&amp; cn_vaes_enabled) {
964          cn_implode_scratchpad_vaes_double(ctx[0], ctx[1], props.memory(), props.half_mem());
965      }
966      else
967  #   endif
968      {
969          cn_implode_scratchpad&lt;ALGO, false, 0&gt;(ctx[0]);
970          cn_implode_scratchpad&lt;ALGO, false, 0&gt;(ctx[1]);
971      }
972      keccakf(reinterpret_cast&lt;uint64_t*&gt;(ctx[0]-&gt;state), 24);
973      keccakf(reinterpret_cast&lt;uint64_t*&gt;(ctx[1]-&gt;state), 24);
974      extra_hashes[ctx[0]-&gt;state[0] &amp; 3](ctx[0]-&gt;state, 200, output);
975      extra_hashes[ctx[1]-&gt;state[0] &amp; 3](ctx[1]-&gt;state, 200, output + 32);
976  }
977  #endif
978  template&lt;Algorithm::Id ALGO, bool SOFT_AES&gt;
979  inline void cryptonight_double_hash(const uint8_t *__restrict__ input, size_t size, uint8_t *__restrict__ output, cryptonight_ctx **__restrict__ ctx, uint64_t height)
980  {
981  #   ifdef XMRIG_FEATURE_ASM
982      if (!SOFT_AES) {
983          switch (ALGO) {
984          case Algorithm::CN_GR_0:
985          case Algorithm::CN_GR_1:
986          case Algorithm::CN_GR_2:
987          case Algorithm::CN_GR_3:
988          case Algorithm::CN_GR_4:
989          case Algorithm::CN_GR_5:
990              if (cn_sse41_enabled) {
991                  cryptonight_double_hash_gr_sse41&lt;ALGO&gt;(input, size, output, ctx, height);
992                  return;
993              }
994              break;
995          default:
996              break;
997          }
998      }
999  #   endif
1000      constexpr CnAlgo&lt;ALGO&gt; props;
1001      constexpr size_t MASK        = props.mask();
1002      constexpr Algorithm::Id BASE = props.base();
1003  #   ifdef XMRIG_ALGO_CN_HEAVY
1004      constexpr bool IS_CN_HEAVY_TUBE = ALGO == Algorithm::CN_HEAVY_TUBE;
1005  #   else
1006      constexpr bool IS_CN_HEAVY_TUBE = false;
1007  #   endif
1008      if (BASE == Algorithm::CN_1 &amp;&amp; size &lt; 43) {
1009          memset(output, 0, 64);
1010          return;
1011      }
1012      keccak(input,        size, ctx[0]-&gt;state);
1013      keccak(input + size, size, ctx[1]-&gt;state);
1014      uint8_t *l0  = ctx[0]-&gt;memory;
1015      uint8_t *l1  = ctx[1]-&gt;memory;
1016      uint64_t *h0 = reinterpret_cast&lt;uint64_t*&gt;(ctx[0]-&gt;state);
1017      uint64_t *h1 = reinterpret_cast&lt;uint64_t*&gt;(ctx[1]-&gt;state);
1018      VARIANT1_INIT(0);
1019      VARIANT1_INIT(1);
1020      VARIANT2_INIT(0);
1021      VARIANT2_INIT(1);
1022      VARIANT2_SET_ROUNDING_MODE();
1023      VARIANT4_RANDOM_MATH_INIT(0);
1024      VARIANT4_RANDOM_MATH_INIT(1);
1025      if (props.half_mem()) {
1026          ctx[0]-&gt;first_half = true;
1027          ctx[1]-&gt;first_half = true;
1028      }
1029  #   ifdef XMRIG_VAES
1030      if (!SOFT_AES &amp;&amp; !props.isHeavy() &amp;&amp; cn_vaes_enabled) {
1031          cn_explode_scratchpad_vaes_double(ctx[0], ctx[1], props.memory(), props.half_mem());
1032      }
1033      else
1034  #   endif
1035      {
1036          cn_explode_scratchpad&lt;ALGO, SOFT_AES, 0&gt;(ctx[0]);
1037          cn_explode_scratchpad&lt;ALGO, SOFT_AES, 0&gt;(ctx[1]);
1038      }
1039      uint64_t al0 = h0[0] ^ h0[4];
1040      uint64_t al1 = h1[0] ^ h1[4];
1041      uint64_t ah0 = h0[1] ^ h0[5];
1042      uint64_t ah1 = h1[1] ^ h1[5];
1043      __m128i bx00 = _mm_set_epi64x(h0[3] ^ h0[7], h0[2] ^ h0[6]);
1044      __m128i bx01 = _mm_set_epi64x(h0[9] ^ h0[11], h0[8] ^ h0[10]);
1045      __m128i bx10 = _mm_set_epi64x(h1[3] ^ h1[7], h1[2] ^ h1[6]);
1046      __m128i bx11 = _mm_set_epi64x(h1[9] ^ h1[11], h1[8] ^ h1[10]);
1047      __m128 conc_var0, conc_var1;
1048      if (ALGO == Algorithm::CN_CCX) {
1049          conc_var0 = _mm_setzero_ps();
1050          conc_var1 = _mm_setzero_ps();
1051          RESTORE_ROUNDING_MODE();
1052      }
1053      uint64_t idx0 = al0;
1054      uint64_t idx1 = al1;
1055      for (size_t i = 0; i &lt; props.iterations(); i++) {
1056          __m128i cx0, cx1;
1057          if (IS_CN_HEAVY_TUBE || !SOFT_AES) {
1058              cx0 = _mm_load_si128(reinterpret_cast&lt;const __m128i *&gt;(&amp;l0[idx0 &amp; MASK]));
1059              cx1 = _mm_load_si128(reinterpret_cast&lt;const __m128i *&gt;(&amp;l1[idx1 &amp; MASK]));
1060              if (ALGO == Algorithm::CN_CCX) {
1061                  cryptonight_conceal_tweak(cx0, conc_var0);
1062                  cryptonight_conceal_tweak(cx1, conc_var1);
1063              }
1064          }
1065          const __m128i ax0 = _mm_set_epi64x(ah0, al0);
1066          const __m128i ax1 = _mm_set_epi64x(ah1, al1);
1067          if (IS_CN_HEAVY_TUBE) {
1068              cx0 = aes_round_tweak_div(cx0, ax0);
1069              cx1 = aes_round_tweak_div(cx1, ax1);
1070          }
1071          else if (SOFT_AES) {
1072              if (ALGO == Algorithm::CN_CCX) {
1073                  cx0 = _mm_load_si128(reinterpret_cast&lt;const __m128i*&gt;(&amp;l0[idx0 &amp; MASK]));
1074                  cx1 = _mm_load_si128(reinterpret_cast&lt;const __m128i*&gt;(&amp;l1[idx1 &amp; MASK]));
1075                  cryptonight_conceal_tweak(cx0, conc_var0);
1076                  cryptonight_conceal_tweak(cx1, conc_var1);
1077                  cx0 = soft_aesenc(&amp;cx0, ax0, reinterpret_cast&lt;const uint32_t*&gt;(saes_table));
1078                  cx1 = soft_aesenc(&amp;cx1, ax1, reinterpret_cast&lt;const uint32_t*&gt;(saes_table));
1079              }
1080              else {
1081                  cx0 = soft_aesenc(&amp;l0[idx0 &amp; MASK], ax0, reinterpret_cast&lt;const uint32_t*&gt;(saes_table));
1082                  cx1 = soft_aesenc(&amp;l1[idx1 &amp; MASK], ax1, reinterpret_cast&lt;const uint32_t*&gt;(saes_table));
1083              }
1084          }
1085          else {
1086              cx0 = _mm_aesenc_si128(cx0, ax0);
1087              cx1 = _mm_aesenc_si128(cx1, ax1);
1088          }
1089          if (BASE == Algorithm::CN_1 || BASE == Algorithm::CN_2) {
1090              cryptonight_monero_tweak&lt;ALGO&gt;((uint64_t*)&amp;l0[idx0 &amp; MASK], l0, idx0 &amp; MASK, ax0, bx00, bx01, cx0);
1091              cryptonight_monero_tweak&lt;ALGO&gt;((uint64_t*)&amp;l1[idx1 &amp; MASK], l1, idx1 &amp; MASK, ax1, bx10, bx11, cx1);
1092          } else {
1093              _mm_store_si128((__m128i *) &amp;l0[idx0 &amp; MASK], _mm_xor_si128(bx00, cx0));
1094              _mm_store_si128((__m128i *) &amp;l1[idx1 &amp; MASK], _mm_xor_si128(bx10, cx1));
1095          }
1096          idx0 = _mm_cvtsi128_si64(cx0);
1097          idx1 = _mm_cvtsi128_si64(cx1);
1098          uint64_t hi, lo, cl, ch;
1099          cl = ((uint64_t*) &amp;l0[idx0 &amp; MASK])[0];
1100          ch = ((uint64_t*) &amp;l0[idx0 &amp; MASK])[1];
1101          if (BASE == Algorithm::CN_2) {
1102              if (props.isR()) {
1103                  VARIANT4_RANDOM_MATH(0, al0, ah0, cl, bx00, bx01);
1104                  if (ALGO == Algorithm::CN_R) {
1105                      al0 ^= r0[2] | ((uint64_t)(r0[3]) &lt;&lt; 32);
1106                      ah0 ^= r0[0] | ((uint64_t)(r0[1]) &lt;&lt; 32);
1107                  }
1108              } else {
1109                  VARIANT2_INTEGER_MATH(0, cl, cx0);
1110              }
1111          }
1112          lo = __umul128(idx0, cl, &amp;hi);
1113          if (BASE == Algorithm::CN_2) {
1114              if (ALGO == Algorithm::CN_R) {
1115                  VARIANT2_SHUFFLE(l0, idx0 &amp; MASK, ax0, bx00, bx01, cx0, 0);
1116              } else {
1117                  VARIANT2_SHUFFLE2(l0, idx0 &amp; MASK, ax0, bx00, bx01, hi, lo, (((ALGO == Algorithm::CN_RWZ) || (ALGO == Algorithm::CN_UPX2)) ? 1 : 0));
1118              }
1119          }
1120          al0 += hi;
1121          ah0 += lo;
1122          ((uint64_t*)&amp;l0[idx0 &amp; MASK])[0] = al0;
1123          if (IS_CN_HEAVY_TUBE || ALGO == Algorithm::CN_RTO) {
1124              ((uint64_t*) &amp;l0[idx0 &amp; MASK])[1] = ah0 ^ tweak1_2_0 ^ al0;
1125          } else if (BASE == Algorithm::CN_1) {
1126              ((uint64_t*) &amp;l0[idx0 &amp; MASK])[1] = ah0 ^ tweak1_2_0;
1127          } else {
1128              ((uint64_t*) &amp;l0[idx0 &amp; MASK])[1] = ah0;
1129          }
1130          al0 ^= cl;
1131          ah0 ^= ch;
1132          idx0 = al0;
1133  #       ifdef XMRIG_ALGO_CN_HEAVY
1134          if (props.isHeavy()) {
1135              int64_t n = ((int64_t*)&amp;l0[idx0 &amp; MASK])[0];
1136              int32_t d = ((int32_t*)&amp;l0[idx0 &amp; MASK])[2];
1137              int64_t q = n / (d | 0x5);
1138              ((int64_t*)&amp;l0[idx0 &amp; MASK])[0] = n ^ q;
1139              if (ALGO == Algorithm::CN_HEAVY_XHV) {
1140                  d = ~d;
1141              }
1142              idx0 = d ^ q;
1143          }
1144  #       endif
1145          cl = ((uint64_t*) &amp;l1[idx1 &amp; MASK])[0];
1146          ch = ((uint64_t*) &amp;l1[idx1 &amp; MASK])[1];
1147          if (BASE == Algorithm::CN_2) {
1148              if (props.isR()) {
1149                  VARIANT4_RANDOM_MATH(1, al1, ah1, cl, bx10, bx11);
1150                  if (ALGO == Algorithm::CN_R) {
1151                      al1 ^= r1[2] | ((uint64_t)(r1[3]) &lt;&lt; 32);
1152                      ah1 ^= r1[0] | ((uint64_t)(r1[1]) &lt;&lt; 32);
1153                  }
1154              } else {
1155                  VARIANT2_INTEGER_MATH(1, cl, cx1);
1156              }
1157          }
1158          lo = __umul128(idx1, cl, &amp;hi);
1159          if (BASE == Algorithm::CN_2) {
1160              if (ALGO == Algorithm::CN_R) {
1161                  VARIANT2_SHUFFLE(l1, idx1 &amp; MASK, ax1, bx10, bx11, cx1, 0);
1162              } else {
1163                  VARIANT2_SHUFFLE2(l1, idx1 &amp; MASK, ax1, bx10, bx11, hi, lo, (((ALGO == Algorithm::CN_RWZ) || (ALGO == Algorithm::CN_UPX2)) ? 1 : 0));
1164              }
1165          }
1166          al1 += hi;
1167          ah1 += lo;
1168          ((uint64_t*)&amp;l1[idx1 &amp; MASK])[0] = al1;
1169          if (IS_CN_HEAVY_TUBE || ALGO == Algorithm::CN_RTO) {
1170              ((uint64_t*)&amp;l1[idx1 &amp; MASK])[1] = ah1 ^ tweak1_2_1 ^ al1;
1171          } else if (BASE == Algorithm::CN_1) {
1172              ((uint64_t*)&amp;l1[idx1 &amp; MASK])[1] = ah1 ^ tweak1_2_1;
1173          } else {
1174              ((uint64_t*)&amp;l1[idx1 &amp; MASK])[1] = ah1;
1175          }
1176          al1 ^= cl;
1177          ah1 ^= ch;
1178          idx1 = al1;
1179  #       ifdef XMRIG_ALGO_CN_HEAVY
1180          if (props.isHeavy()) {
1181              int64_t n = ((int64_t*)&amp;l1[idx1 &amp; MASK])[0];
1182              int32_t d = ((int32_t*)&amp;l1[idx1 &amp; MASK])[2];
1183              int64_t q = n / (d | 0x5);
1184              ((int64_t*)&amp;l1[idx1 &amp; MASK])[0] = n ^ q;
1185              if (ALGO == Algorithm::CN_HEAVY_XHV) {
1186                  d = ~d;
1187              }
1188              idx1 = d ^ q;
1189          }
1190  #       endif
1191          if (BASE == Algorithm::CN_2) {
1192              bx01 = bx00;
1193              bx11 = bx10;
1194          }
1195          bx00 = cx0;
1196          bx10 = cx1;
1197      }
1198  #   ifdef XMRIG_VAES
1199      if (!SOFT_AES &amp;&amp; !props.isHeavy() &amp;&amp; cn_vaes_enabled) {
1200          cn_implode_scratchpad_vaes_double(ctx[0], ctx[1], props.memory(), props.half_mem());
1201      }
1202      else
1203  #   endif
1204      {
1205          cn_implode_scratchpad&lt;ALGO, SOFT_AES, 0&gt;(ctx[0]);
1206          cn_implode_scratchpad&lt;ALGO, SOFT_AES, 0&gt;(ctx[1]);
1207      }
1208      keccakf(h0, 24);
1209      keccakf(h1, 24);
1210      extra_hashes[ctx[0]-&gt;state[0] &amp; 3](ctx[0]-&gt;state, 200, output);
1211      extra_hashes[ctx[1]-&gt;state[0] &amp; 3](ctx[1]-&gt;state, 200, output + 32);
1212  }
1213  #ifdef XMRIG_FEATURE_ASM
1214  template&lt;Algorithm::Id ALGO&gt;
1215  static NOINLINE void cryptonight_quad_hash_gr_sse41(const uint8_t* __restrict__ input, size_t size, uint8_t* __restrict__ output, cryptonight_ctx** __restrict__ ctx, uint64_t height)
1216  {
1217      constexpr CnAlgo&lt;ALGO&gt; props;
1218      constexpr Algorithm::Id BASE = props.base();
1219      if (BASE == Algorithm::CN_1 &amp;&amp; size &lt; 43) {
1220          memset(output, 0, 32 * 4);
1221          return;
1222      }
1223      keccak(input + size * 0, size, ctx[0]-&gt;state);
1224      keccak(input + size * 1, size, ctx[1]-&gt;state);
1225      keccak(input + size * 2, size, ctx[2]-&gt;state);
1226      keccak(input + size * 3, size, ctx[3]-&gt;state);
1227      if (props.half_mem()) {
1228          ctx[0]-&gt;first_half = true;
1229          ctx[1]-&gt;first_half = true;
1230          ctx[2]-&gt;first_half = true;
1231          ctx[3]-&gt;first_half = true;
1232      }
1233  #   ifdef XMRIG_VAES
1234      if (!props.isHeavy() &amp;&amp; cn_vaes_enabled) {
1235          cn_explode_scratchpad_vaes_double(ctx[0], ctx[1], props.memory(), props.half_mem());
1236          cn_explode_scratchpad_vaes_double(ctx[2], ctx[3], props.memory(), props.half_mem());
1237      }
1238      else
1239  #   endif
1240      {
1241          cn_explode_scratchpad&lt;ALGO, false, 0&gt;(ctx[0]);
1242          cn_explode_scratchpad&lt;ALGO, false, 0&gt;(ctx[1]);
1243          cn_explode_scratchpad&lt;ALGO, false, 0&gt;(ctx[2]);
1244          cn_explode_scratchpad&lt;ALGO, false, 0&gt;(ctx[3]);
1245      }
1246      VARIANT1_INIT(0); ctx[0]-&gt;tweak1_2 = tweak1_2_0;
1247      VARIANT1_INIT(1); ctx[1]-&gt;tweak1_2 = tweak1_2_1;
1248      VARIANT1_INIT(2); ctx[2]-&gt;tweak1_2 = tweak1_2_2;
1249      VARIANT1_INIT(3); ctx[3]-&gt;tweak1_2 = tweak1_2_3;
1250      ctx[0]-&gt;tweak1_table = tweak1_table;
1251      if (ALGO == Algorithm::CN_GR_0) cn_gr0_quad_mainloop_asm(ctx);
1252      if (ALGO == Algorithm::CN_GR_1) cn_gr1_quad_mainloop_asm(ctx);
1253      if (ALGO == Algorithm::CN_GR_2) cn_gr2_quad_mainloop_asm(ctx);
1254      if (ALGO == Algorithm::CN_GR_3) cn_gr3_quad_mainloop_asm(ctx);
1255      if (ALGO == Algorithm::CN_GR_4) cn_gr4_quad_mainloop_asm(ctx);
1256      if (ALGO == Algorithm::CN_GR_5) cn_gr5_quad_mainloop_asm(ctx);
1257  #   ifdef XMRIG_VAES
1258      if (!props.isHeavy() &amp;&amp; cn_vaes_enabled) {
1259          cn_implode_scratchpad_vaes_double(ctx[0], ctx[1], props.memory(), props.half_mem());
1260          cn_implode_scratchpad_vaes_double(ctx[2], ctx[3], props.memory(), props.half_mem());
1261      }
1262      else
1263  #   endif
1264      {
1265          cn_implode_scratchpad&lt;ALGO, false, 0&gt;(ctx[0]);
1266          cn_implode_scratchpad&lt;ALGO, false, 0&gt;(ctx[1]);
1267          cn_implode_scratchpad&lt;ALGO, false, 0&gt;(ctx[2]);
1268          cn_implode_scratchpad&lt;ALGO, false, 0&gt;(ctx[3]);
1269      }
1270      keccakf(reinterpret_cast&lt;uint64_t*&gt;(ctx[0]-&gt;state), 24);
1271      keccakf(reinterpret_cast&lt;uint64_t*&gt;(ctx[1]-&gt;state), 24);
1272      keccakf(reinterpret_cast&lt;uint64_t*&gt;(ctx[2]-&gt;state), 24);
1273      keccakf(reinterpret_cast&lt;uint64_t*&gt;(ctx[3]-&gt;state), 24);
1274      extra_hashes[ctx[0]-&gt;state[0] &amp; 3](ctx[0]-&gt;state, 200, output);
1275      extra_hashes[ctx[1]-&gt;state[0] &amp; 3](ctx[1]-&gt;state, 200, output + 32);
1276      extra_hashes[ctx[2]-&gt;state[0] &amp; 3](ctx[2]-&gt;state, 200, output + 64);
1277      extra_hashes[ctx[3]-&gt;state[0] &amp; 3](ctx[3]-&gt;state, 200, output + 96);
1278  }
1279  #endif
1280  #define CN_STEP1(a, b0, b1, c, l, ptr, idx, conc_var) \
1281      ptr = reinterpret_cast&lt;__m128i*&gt;(&amp;l[idx &amp; MASK]); \
1282      c = _mm_load_si128(ptr);                          \
1283      if (ALGO == Algorithm::CN_CCX) {                  \
1284          cryptonight_conceal_tweak(c, conc_var);       \
1285      }
1286  #define CN_STEP2(a, b0, b1, c, l, ptr, idx)                                             \
1287      if (IS_CN_HEAVY_TUBE) {                                                             \
1288          c = aes_round_tweak_div(c, a);                                                  \
1289      }                                                                                   \
1290      else if (SOFT_AES) {                                                                \
1291          c = soft_aesenc(&amp;c, a, (const uint32_t*)saes_table);                            \
1292      } else {                                                                            \
1293          c = _mm_aesenc_si128(c, a);                                                     \
1294      }                                                                                   \
1295                                                                                          \
1296      if (BASE == Algorithm::CN_1 || BASE == Algorithm::CN_2) {                           \
1297          cryptonight_monero_tweak&lt;ALGO&gt;((uint64_t*)ptr, l, idx &amp; MASK, a, b0, b1, c);    \
1298      } else {                                                                            \
1299          _mm_store_si128(ptr, _mm_xor_si128(b0, c));                                     \
1300      }
1301  #define CN_STEP3(part, a, b0, b1, c, l, ptr, idx)     \
1302      idx = _mm_cvtsi128_si64(c);                       \
1303      ptr = reinterpret_cast&lt;__m128i*&gt;(&amp;l[idx &amp; MASK]); \
1304      uint64_t cl##part = ((uint64_t*)ptr)[0];          \
1305      uint64_t ch##part = ((uint64_t*)ptr)[1];
1306  #define CN_STEP4(part, a, b0, b1, c, l, mc, ptr, idx)                                                       \
1307      uint64_t al##part, ah##part;                                                                            \
1308      if (BASE == Algorithm::CN_2) {                                                                          \
1309          if (props.isR()) {                                                                                  \
1310              al##part = _mm_cvtsi128_si64(a);                                                                \
1311              ah##part = _mm_cvtsi128_si64(_mm_srli_si128(a, 8));                                             \
1312              VARIANT4_RANDOM_MATH(part, al##part, ah##part, cl##part, b0, b1);                               \
1313              if (ALGO == Algorithm::CN_R) {                                                                  \
1314                  al##part ^= r##part[2] | ((uint64_t)(r##part[3]) &lt;&lt; 32);                                    \
1315                  ah##part ^= r##part[0] | ((uint64_t)(r##part[1]) &lt;&lt; 32);                                    \
1316              }                                                                                               \
1317          } else {                                                                                            \
1318              VARIANT2_INTEGER_MATH(part, cl##part, c);                                                       \
1319          }                                                                                                   \
1320      }                                                                                                       \
1321      lo = __umul128(idx, cl##part, &amp;hi);                                                                     \
1322      if (BASE == Algorithm::CN_2) {                                                                          \
1323          if (ALGO == Algorithm::CN_R) {                                                                      \
1324              VARIANT2_SHUFFLE(l, idx &amp; MASK, a, b0, b1, c, 0);                                               \
1325          } else {                                                                                            \
1326              VARIANT2_SHUFFLE2(l, idx &amp; MASK, a, b0, b1, hi, lo, (((ALGO == Algorithm::CN_RWZ) || (ALGO == Algorithm::CN_UPX2)) ? 1 : 0)); \
1327          }                                                                                                   \
1328      }                                                                                                       \
1329      if (ALGO == Algorithm::CN_R) {                                                                          \
1330          a = _mm_set_epi64x(ah##part, al##part);                                                             \
1331      }                                                                                                       \
1332      a = _mm_add_epi64(a, _mm_set_epi64x(lo, hi));                                                           \
1333                                                                                                              \
1334      if (BASE == Algorithm::CN_1) {                                                                          \
1335          _mm_store_si128(ptr, _mm_xor_si128(a, mc));                                                         \
1336                                                                                                              \
1337          if (IS_CN_HEAVY_TUBE || ALGO == Algorithm::CN_RTO) {                                                \
1338              ((uint64_t*)ptr)[1] ^= ((uint64_t*)ptr)[0];                                                     \
1339          }                                                                                                   \
1340      } else {                                                                                                \
1341          _mm_store_si128(ptr, a);                                                                            \
1342      }                                                                                                       \
1343                                                                                                              \
1344      a = _mm_xor_si128(a, _mm_set_epi64x(ch##part, cl##part));                                               \
1345      idx = _mm_cvtsi128_si64(a);                                                                             \
1346      if (props.isHeavy()) {                                                                                  \
1347          int64_t n = ((int64_t*)&amp;l[idx &amp; MASK])[0];                                                          \
1348          int32_t d = ((int32_t*)&amp;l[idx &amp; MASK])[2];                                                          \
1349          int64_t q = n / (d | 0x5);                                                                          \
1350          ((int64_t*)&amp;l[idx &amp; MASK])[0] = n ^ q;                                                              \
1351          if (IS_CN_HEAVY_XHV) {                                                                              \
1352              d = ~d;                                                                                         \
1353          }                                                                                                   \
1354                                                                                                              \
1355          idx = d ^ q;                                                                                        \
1356      }                                                                                                       \
1357      if (BASE == Algorithm::CN_2) {                                                                          \
1358          b1 = b0;                                                                                            \
1359      }                                                                                                       \
1360      b0 = c;
1361  #define CONST_INIT(ctx, n)                                                                       \
1362      __m128i mc##n;                                                                               \
1363      __m128i division_result_xmm_##n;                                                             \
1364      __m128i sqrt_result_xmm_##n;                                                                 \
1365      if (BASE == Algorithm::CN_1) {                                                               \
1366          mc##n = _mm_set_epi64x(*reinterpret_cast&lt;const uint64_t*&gt;(input + n * size + 35) ^       \
1367                                 *(reinterpret_cast&lt;const uint64_t*&gt;((ctx)-&gt;state) + 24), 0);      \
1368      }                                                                                            \
1369      if (BASE == Algorithm::CN_2) {                                                               \
1370          division_result_xmm_##n = _mm_cvtsi64_si128(h##n[12]);                                   \
1371          sqrt_result_xmm_##n = _mm_cvtsi64_si128(h##n[13]);                                       \
1372      }                                                                                            \
1373      __m128i ax##n = _mm_set_epi64x(h##n[1] ^ h##n[5], h##n[0] ^ h##n[4]);                        \
1374      __m128i bx##n##0 = _mm_set_epi64x(h##n[3] ^ h##n[7], h##n[2] ^ h##n[6]);                     \
1375      __m128i bx##n##1 = _mm_set_epi64x(h##n[9] ^ h##n[11], h##n[8] ^ h##n[10]);                   \
1376      __m128i cx##n = _mm_setzero_si128();                                                         \
1377      __m128 conc_var##n;                                                                          \
1378      if (ALGO == Algorithm::CN_CCX) {                                                             \
1379          conc_var##n = _mm_setzero_ps();                                                          \
1380      }                                                                                            \
1381      VARIANT4_RANDOM_MATH_INIT(n);
1382  template&lt;Algorithm::Id ALGO, bool SOFT_AES&gt;
1383  inline void cryptonight_triple_hash(const uint8_t *__restrict__ input, size_t size, uint8_t *__restrict__ output, cryptonight_ctx **__restrict__ ctx, uint64_t height)
1384  {
1385      constexpr CnAlgo&lt;ALGO&gt; props;
1386      constexpr size_t MASK        = props.mask();
1387      constexpr Algorithm::Id BASE = props.base();
1388  #   ifdef XMRIG_ALGO_CN_HEAVY
1389      constexpr bool IS_CN_HEAVY_TUBE = ALGO == Algorithm::CN_HEAVY_TUBE;
1390      constexpr bool IS_CN_HEAVY_XHV  = ALGO == Algorithm::CN_HEAVY_XHV;
1391  #   else
1392      constexpr bool IS_CN_HEAVY_TUBE = false;
1393      constexpr bool IS_CN_HEAVY_XHV  = false;
1394  #   endif
1395      if (BASE == Algorithm::CN_1 &amp;&amp; size &lt; 43) {
1396          memset(output, 0, 32 * 3);
1397          return;
1398      }
1399      for (size_t i = 0; i &lt; 3; i++) {
1400          keccak(input + size * i, size, ctx[i]-&gt;state);
1401          if (props.half_mem()) {
1402              ctx[i]-&gt;first_half = true;
1403          }
1404          cn_explode_scratchpad&lt;ALGO, SOFT_AES, 0&gt;(ctx[i]);
1405      }
1406      uint8_t* l0  = ctx[0]-&gt;memory;
1407      uint8_t* l1  = ctx[1]-&gt;memory;
1408      uint8_t* l2  = ctx[2]-&gt;memory;
1409      uint64_t* h0 = reinterpret_cast&lt;uint64_t*&gt;(ctx[0]-&gt;state);
1410      uint64_t* h1 = reinterpret_cast&lt;uint64_t*&gt;(ctx[1]-&gt;state);
1411      uint64_t* h2 = reinterpret_cast&lt;uint64_t*&gt;(ctx[2]-&gt;state);
1412      CONST_INIT(ctx[0], 0);
1413      CONST_INIT(ctx[1], 1);
1414      CONST_INIT(ctx[2], 2);
1415      VARIANT2_SET_ROUNDING_MODE();
1416      if (ALGO == Algorithm::CN_CCX) {
1417          RESTORE_ROUNDING_MODE();
1418      }
1419      uint64_t idx0, idx1, idx2;
1420      idx0 = _mm_cvtsi128_si64(ax0);
1421      idx1 = _mm_cvtsi128_si64(ax1);
1422      idx2 = _mm_cvtsi128_si64(ax2);
1423      for (size_t i = 0; i &lt; props.iterations(); i++) {
1424          uint64_t hi, lo;
1425          __m128i *ptr0, *ptr1, *ptr2;
1426          CN_STEP1(ax0, bx00, bx01, cx0, l0, ptr0, idx0, conc_var0);
1427          CN_STEP1(ax1, bx10, bx11, cx1, l1, ptr1, idx1, conc_var1);
1428          CN_STEP1(ax2, bx20, bx21, cx2, l2, ptr2, idx2, conc_var2);
1429          CN_STEP2(ax0, bx00, bx01, cx0, l0, ptr0, idx0);
1430          CN_STEP2(ax1, bx10, bx11, cx1, l1, ptr1, idx1);
1431          CN_STEP2(ax2, bx20, bx21, cx2, l2, ptr2, idx2);
1432          CN_STEP3(0, ax0, bx00, bx01, cx0, l0, ptr0, idx0);
1433          CN_STEP3(1, ax1, bx10, bx11, cx1, l1, ptr1, idx1);
1434          CN_STEP3(2, ax2, bx20, bx21, cx2, l2, ptr2, idx2);
1435          CN_STEP4(0, ax0, bx00, bx01, cx0, l0, mc0, ptr0, idx0);
1436          CN_STEP4(1, ax1, bx10, bx11, cx1, l1, mc1, ptr1, idx1);
1437          CN_STEP4(2, ax2, bx20, bx21, cx2, l2, mc2, ptr2, idx2);
1438      }
1439      for (size_t i = 0; i &lt; 3; i++) {
1440          cn_implode_scratchpad&lt;ALGO, SOFT_AES, 0&gt;(ctx[i]);
1441          keccakf(reinterpret_cast&lt;uint64_t*&gt;(ctx[i]-&gt;state), 24);
1442          extra_hashes[ctx[i]-&gt;state[0] &amp; 3](ctx[i]-&gt;state, 200, output + 32 * i);
1443      }
1444  }
1445  template&lt;Algorithm::Id ALGO, bool SOFT_AES&gt;
1446  inline void cryptonight_quad_hash(const uint8_t *__restrict__ input, size_t size, uint8_t *__restrict__ output, cryptonight_ctx **__restrict__ ctx, uint64_t height)
1447  {
1448  #   ifdef XMRIG_FEATURE_ASM
1449      if (!SOFT_AES) {
1450          switch (ALGO) {
1451          case Algorithm::CN_GR_0:
1452          case Algorithm::CN_GR_1:
1453          case Algorithm::CN_GR_2:
1454          case Algorithm::CN_GR_3:
1455          case Algorithm::CN_GR_4:
1456          case Algorithm::CN_GR_5:
1457              if (cn_sse41_enabled) {
1458                  cryptonight_quad_hash_gr_sse41&lt;ALGO&gt;(input, size, output, ctx, height);
1459                  return;
1460              }
1461              break;
1462          default:
1463              break;
1464          }
1465      }
1466  #   endif
1467      constexpr CnAlgo&lt;ALGO&gt; props;
1468      constexpr size_t MASK        = props.mask();
1469      constexpr Algorithm::Id BASE = props.base();
1470  #   ifdef XMRIG_ALGO_CN_HEAVY
1471      constexpr bool IS_CN_HEAVY_TUBE = ALGO == Algorithm::CN_HEAVY_TUBE;
1472      constexpr bool IS_CN_HEAVY_XHV  = ALGO == Algorithm::CN_HEAVY_XHV;
1473  #   else
1474      constexpr bool IS_CN_HEAVY_TUBE = false;
1475      constexpr bool IS_CN_HEAVY_XHV  = false;
1476  #   endif
1477      if (BASE == Algorithm::CN_1 &amp;&amp; size &lt; 43) {
1478          memset(output, 0, 32 * 4);
1479          return;
1480      }
1481      for (size_t i = 0; i &lt; 4; i++) {
1482          keccak(input + size * i, size, ctx[i]-&gt;state);
1483          if (props.half_mem()) {
1484              ctx[i]-&gt;first_half = true;
1485          }
1486      }
1487  #   ifdef XMRIG_VAES
1488      if (!SOFT_AES &amp;&amp; !props.isHeavy() &amp;&amp; cn_vaes_enabled) {
1489          cn_explode_scratchpad_vaes_double(ctx[0], ctx[1], props.memory(), props.half_mem());
1490          cn_explode_scratchpad_vaes_double(ctx[2], ctx[3], props.memory(), props.half_mem());
1491      }
1492      else
1493  #   endif
1494      {
1495          cn_explode_scratchpad&lt;ALGO, SOFT_AES, 0&gt;(ctx[0]);
1496          cn_explode_scratchpad&lt;ALGO, SOFT_AES, 0&gt;(ctx[1]);
1497          cn_explode_scratchpad&lt;ALGO, SOFT_AES, 0&gt;(ctx[2]);
1498          cn_explode_scratchpad&lt;ALGO, SOFT_AES, 0&gt;(ctx[3]);
1499      }
1500      uint8_t* l0  = ctx[0]-&gt;memory;
1501      uint8_t* l1  = ctx[1]-&gt;memory;
1502      uint8_t* l2  = ctx[2]-&gt;memory;
1503      uint8_t* l3  = ctx[3]-&gt;memory;
1504      uint64_t* h0 = reinterpret_cast&lt;uint64_t*&gt;(ctx[0]-&gt;state);
1505      uint64_t* h1 = reinterpret_cast&lt;uint64_t*&gt;(ctx[1]-&gt;state);
1506      uint64_t* h2 = reinterpret_cast&lt;uint64_t*&gt;(ctx[2]-&gt;state);
1507      uint64_t* h3 = reinterpret_cast&lt;uint64_t*&gt;(ctx[3]-&gt;state);
1508      CONST_INIT(ctx[0], 0);
1509      CONST_INIT(ctx[1], 1);
1510      CONST_INIT(ctx[2], 2);
1511      CONST_INIT(ctx[3], 3);
1512      VARIANT2_SET_ROUNDING_MODE();
1513      if (ALGO == Algorithm::CN_CCX) {
1514          RESTORE_ROUNDING_MODE();
1515      }
1516      uint64_t idx0, idx1, idx2, idx3;
1517      idx0 = _mm_cvtsi128_si64(ax0);
1518      idx1 = _mm_cvtsi128_si64(ax1);
1519      idx2 = _mm_cvtsi128_si64(ax2);
1520      idx3 = _mm_cvtsi128_si64(ax3);
1521      for (size_t i = 0; i &lt; props.iterations(); i++) {
1522          uint64_t hi, lo;
1523          __m128i *ptr0, *ptr1, *ptr2, *ptr3;
1524          CN_STEP1(ax0, bx00, bx01, cx0, l0, ptr0, idx0, conc_var0);
1525          CN_STEP1(ax1, bx10, bx11, cx1, l1, ptr1, idx1, conc_var1);
1526          CN_STEP1(ax2, bx20, bx21, cx2, l2, ptr2, idx2, conc_var2);
1527          CN_STEP1(ax3, bx30, bx31, cx3, l3, ptr3, idx3, conc_var3);
1528          CN_STEP2(ax0, bx00, bx01, cx0, l0, ptr0, idx0);
1529          CN_STEP2(ax1, bx10, bx11, cx1, l1, ptr1, idx1);
1530          CN_STEP2(ax2, bx20, bx21, cx2, l2, ptr2, idx2);
1531          CN_STEP2(ax3, bx30, bx31, cx3, l3, ptr3, idx3);
1532          CN_STEP3(0, ax0, bx00, bx01, cx0, l0, ptr0, idx0);
1533          CN_STEP3(1, ax1, bx10, bx11, cx1, l1, ptr1, idx1);
1534          CN_STEP3(2, ax2, bx20, bx21, cx2, l2, ptr2, idx2);
1535          CN_STEP3(3, ax3, bx30, bx31, cx3, l3, ptr3, idx3);
1536          CN_STEP4(0, ax0, bx00, bx01, cx0, l0, mc0, ptr0, idx0);
1537          CN_STEP4(1, ax1, bx10, bx11, cx1, l1, mc1, ptr1, idx1);
1538          CN_STEP4(2, ax2, bx20, bx21, cx2, l2, mc2, ptr2, idx2);
1539          CN_STEP4(3, ax3, bx30, bx31, cx3, l3, mc3, ptr3, idx3);
1540      }
1541  #   ifdef XMRIG_VAES
1542      if (!SOFT_AES &amp;&amp; !props.isHeavy() &amp;&amp; cn_vaes_enabled) {
1543          cn_implode_scratchpad_vaes_double(ctx[0], ctx[1], props.memory(), props.half_mem());
1544          cn_implode_scratchpad_vaes_double(ctx[2], ctx[3], props.memory(), props.half_mem());
1545      }
1546      else
1547  #   endif
1548      {
1549          cn_implode_scratchpad&lt;ALGO, SOFT_AES, 0&gt;(ctx[0]);
1550          cn_implode_scratchpad&lt;ALGO, SOFT_AES, 0&gt;(ctx[1]);
1551          cn_implode_scratchpad&lt;ALGO, SOFT_AES, 0&gt;(ctx[2]);
1552          cn_implode_scratchpad&lt;ALGO, SOFT_AES, 0&gt;(ctx[3]);
1553      }
1554      for (size_t i = 0; i &lt; 4; i++) {
1555          keccakf(reinterpret_cast&lt;uint64_t*&gt;(ctx[i]-&gt;state), 24);
1556          extra_hashes[ctx[i]-&gt;state[0] &amp; 3](ctx[i]-&gt;state, 200, output + 32 * i);
1557      }
1558  }
1559  template&lt;Algorithm::Id ALGO, bool SOFT_AES&gt;
1560  inline void cryptonight_penta_hash(const uint8_t *__restrict__ input, size_t size, uint8_t *__restrict__ output, cryptonight_ctx **__restrict__ ctx, uint64_t height)
1561  {
1562      constexpr CnAlgo&lt;ALGO&gt; props;
1563      constexpr size_t MASK        = props.mask();
1564      constexpr Algorithm::Id BASE = props.base();
1565  #   ifdef XMRIG_ALGO_CN_HEAVY
1566      constexpr bool IS_CN_HEAVY_TUBE = ALGO == Algorithm::CN_HEAVY_TUBE;
1567      constexpr bool IS_CN_HEAVY_XHV  = ALGO == Algorithm::CN_HEAVY_XHV;
1568  #   else
1569      constexpr bool IS_CN_HEAVY_TUBE = false;
1570      constexpr bool IS_CN_HEAVY_XHV  = false;
1571  #   endif
1572      if (BASE == Algorithm::CN_1 &amp;&amp; size &lt; 43) {
1573          memset(output, 0, 32 * 5);
1574          return;
1575      }
1576      for (size_t i = 0; i &lt; 5; i++) {
1577          keccak(input + size * i, size, ctx[i]-&gt;state);
1578          if (props.half_mem()) {
1579              ctx[i]-&gt;first_half = true;
1580          }
1581          cn_explode_scratchpad&lt;ALGO, SOFT_AES, 0&gt;(ctx[i]);
1582      }
1583      uint8_t* l0  = ctx[0]-&gt;memory;
1584      uint8_t* l1  = ctx[1]-&gt;memory;
1585      uint8_t* l2  = ctx[2]-&gt;memory;
1586      uint8_t* l3  = ctx[3]-&gt;memory;
1587      uint8_t* l4  = ctx[4]-&gt;memory;
1588      uint64_t* h0 = reinterpret_cast&lt;uint64_t*&gt;(ctx[0]-&gt;state);
1589      uint64_t* h1 = reinterpret_cast&lt;uint64_t*&gt;(ctx[1]-&gt;state);
1590      uint64_t* h2 = reinterpret_cast&lt;uint64_t*&gt;(ctx[2]-&gt;state);
1591      uint64_t* h3 = reinterpret_cast&lt;uint64_t*&gt;(ctx[3]-&gt;state);
1592      uint64_t* h4 = reinterpret_cast&lt;uint64_t*&gt;(ctx[4]-&gt;state);
1593      CONST_INIT(ctx[0], 0);
1594      CONST_INIT(ctx[1], 1);
1595      CONST_INIT(ctx[2], 2);
1596      CONST_INIT(ctx[3], 3);
1597      CONST_INIT(ctx[4], 4);
1598      VARIANT2_SET_ROUNDING_MODE();
1599      if (ALGO == Algorithm::CN_CCX) {
1600          RESTORE_ROUNDING_MODE();
1601      }
1602      uint64_t idx0, idx1, idx2, idx3, idx4;
1603      idx0 = _mm_cvtsi128_si64(ax0);
1604      idx1 = _mm_cvtsi128_si64(ax1);
1605      idx2 = _mm_cvtsi128_si64(ax2);
1606      idx3 = _mm_cvtsi128_si64(ax3);
1607      idx4 = _mm_cvtsi128_si64(ax4);
1608      for (size_t i = 0; i &lt; props.iterations(); i++) {
1609          uint64_t hi, lo;
1610          __m128i *ptr0, *ptr1, *ptr2, *ptr3, *ptr4;
1611          CN_STEP1(ax0, bx00, bx01, cx0, l0, ptr0, idx0, conc_var0);
1612          CN_STEP1(ax1, bx10, bx11, cx1, l1, ptr1, idx1, conc_var1);
1613          CN_STEP1(ax2, bx20, bx21, cx2, l2, ptr2, idx2, conc_var2);
1614          CN_STEP1(ax3, bx30, bx31, cx3, l3, ptr3, idx3, conc_var3);
1615          CN_STEP1(ax4, bx40, bx41, cx4, l4, ptr4, idx4, conc_var4);
1616          CN_STEP2(ax0, bx00, bx01, cx0, l0, ptr0, idx0);
1617          CN_STEP2(ax1, bx10, bx11, cx1, l1, ptr1, idx1);
1618          CN_STEP2(ax2, bx20, bx21, cx2, l2, ptr2, idx2);
1619          CN_STEP2(ax3, bx30, bx31, cx3, l3, ptr3, idx3);
1620          CN_STEP2(ax4, bx40, bx41, cx4, l4, ptr4, idx4);
1621          CN_STEP3(0, ax0, bx00, bx01, cx0, l0, ptr0, idx0);
1622          CN_STEP3(1, ax1, bx10, bx11, cx1, l1, ptr1, idx1);
1623          CN_STEP3(2, ax2, bx20, bx21, cx2, l2, ptr2, idx2);
1624          CN_STEP3(3, ax3, bx30, bx31, cx3, l3, ptr3, idx3);
1625          CN_STEP3(4, ax4, bx40, bx41, cx4, l4, ptr4, idx4);
1626          CN_STEP4(0, ax0, bx00, bx01, cx0, l0, mc0, ptr0, idx0);
1627          CN_STEP4(1, ax1, bx10, bx11, cx1, l1, mc1, ptr1, idx1);
1628          CN_STEP4(2, ax2, bx20, bx21, cx2, l2, mc2, ptr2, idx2);
1629          CN_STEP4(3, ax3, bx30, bx31, cx3, l3, mc3, ptr3, idx3);
1630          CN_STEP4(4, ax4, bx40, bx41, cx4, l4, mc4, ptr4, idx4);
1631      }
1632      for (size_t i = 0; i &lt; 5; i++) {
1633          cn_implode_scratchpad&lt;ALGO, SOFT_AES, 0&gt;(ctx[i]);
1634          keccakf(reinterpret_cast&lt;uint64_t*&gt;(ctx[i]-&gt;state), 24);
1635          extra_hashes[ctx[i]-&gt;state[0] &amp; 3](ctx[i]-&gt;state, 200, output + 32 * i);
1636      }
1637  }
1638  } &amp;bsol;* namespace xmrig */
1639  #endif &amp;bsol;* XMRIG_CRYPTONIGHT_X86_H */
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from xmrig-MDEwOlJlcG9zaXRvcnk4ODMyNzQwNg==-flat-CryptoNight_x86.h</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from xmrig-MDEwOlJlcG9zaXRvcnk4ODMyNzQwNg==-flat-CryptoNight_x86.h</div>
                </div>
                <div class="column column_space"><pre><code>147      t += 256;
148      y0 ^= t[x2 &amp; 0xff]; x2 &gt;&gt;= 8;
149      y1 ^= t[x3 &amp; 0xff]; x3 &gt;&gt;= 8;
150      y2 ^= t[x0 &amp; 0xff]; x0 &gt;&gt;= 8;
151      y3 ^= t[x1 &amp; 0xff]; x1 &gt;&gt;= 8;
152      y0 ^= t[x3 + 256];
</pre></code></div>
                <div class="column column_space"><pre><code>142      t += 256;
143      y0 ^= t[x1 &amp; 0xff]; x1 &gt;&gt;= 8;
144      y1 ^= t[x2 &amp; 0xff]; x2 &gt;&gt;= 8;
145      y2 ^= t[x3 &amp; 0xff]; x3 &gt;&gt;= 8;
146      y3 ^= t[x0 &amp; 0xff]; x0 &gt;&gt;= 8;
147      t += 256;
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    