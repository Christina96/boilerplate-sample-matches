
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 2.4413145539906105%, Tokens: 8</h2>
        <div class="column">
            <h3>fftw3-MDEwOlJlcG9zaXRvcnk4ODQzMzg4-flat-redft00e-r2hc.c</h3>
            <pre><code>1  #include "reodft/reodft.h"
2  typedef struct {
3       solver super;
4  } S;
5  typedef struct {
6       plan_rdft super;
7       plan *cld;
8       twid *td;
9       INT is, os;
10       INT n;
11       INT vl;
12       INT ivs, ovs;
13  } P;
14  static void apply(const plan *ego_, R *I, R *O)
15  {
16       const P *ego = (const P *) ego_;
17       INT is = ego->is, os = ego->os;
18       INT i, n = ego->n;
19       INT iv, vl = ego->vl;
20       INT ivs = ego->ivs, ovs = ego->ovs;
21       R *W = ego->td->W;
22       R *buf;
23       E csum;
24       buf = (R *) MALLOC(sizeof(R) * n, BUFFERS);
25       for (iv = 0; iv < vl; ++iv, I += ivs, O += ovs) {
26  	  buf[0] = I[0] + I[is * n];
27  	  csum = I[0] - I[is * n];
28  	  for (i = 1; i < n - i; ++i) {
29  	       E a, b, apb, amb;
30  	       a = I[is * i];
31  	       b = I[is * (n - i)];
32  	       csum += W[2*i] * (amb = K(2.0)*(a - b));
33  	       amb = W[2*i+1] * amb;
34  	       apb = (a + b);
35  	       buf[i] = apb - amb;
36  	       buf[n - i] = apb + amb;
37  	  }
38  	  if (i == n - i) {
39  	       buf[i] = K(2.0) * I[is * i];
40  	  }
41  	  {
42  	       plan_rdft *cld = (plan_rdft *) ego->cld;
43  	       cld->apply((plan *) cld, buf, buf);
44  	  }
45  	  O[0] = buf[0];
46  	  O[os] = csum;
47  	  for (i = 1; i + i < n; ++i) {
48  	       INT k = i + i;
49  	       O[os * k] = buf[i];
50  	       O[os * (k + 1)] = O[os * (k - 1)] - buf[n - i];
51  	  }
52  	  if (i + i == n) {
53  	       O[os * n] = buf[i];
54  	  }
55       }
56       X(ifree)(buf);
57  }
58  static void awake(plan *ego_, enum wakefulness wakefulness)
59  {
60       P *ego = (P *) ego_;
<span onclick='openModal()' class='match'>61       static const tw_instr redft00e_tw[] = {
62            { TW_COS, 0, 1 },
63            { TW_SIN, 0, 1 },
64            { TW_NEXT, 1, 0 }
</span>65       };
66       X(plan_awake)(ego->cld, wakefulness);
67       X(twiddle_awake)(wakefulness,
68  		      &ego->td, redft00e_tw, 2*ego->n, 1, (ego->n+1)/2);
69  }
70  static void destroy(plan *ego_)
71  {
72       P *ego = (P *) ego_;
73       X(plan_destroy_internal)(ego->cld);
74  }
75  static void print(const plan *ego_, printer *p)
76  {
77       const P *ego = (const P *) ego_;
78       p->print(p, "(redft00e-r2hc-%D%v%(%p%))", ego->n + 1, ego->vl, ego->cld);
79  }
80  static int applicable0(const solver *ego_, const problem *p_)
81  {
82       const problem_rdft *p = (const problem_rdft *) p_;
83       UNUSED(ego_);
84       return (1
85  	     && p->sz->rnk == 1
86  	     && p->vecsz->rnk <= 1
87  	     && p->kind[0] == REDFT00
88  	     && p->sz->dims[0].n > 1  &bsol;* n == 1 is not well-defined */
89  	  );
90  }
91  static int applicable(const solver *ego, const problem *p, const planner *plnr)
92  {
93       return (!NO_SLOWP(plnr) && applicable0(ego, p));
94  }
95  static plan *mkplan(const solver *ego_, const problem *p_, planner *plnr)
96  {
97       P *pln;
98       const problem_rdft *p;
99       plan *cld;
100       R *buf;
101       INT n;
102       opcnt ops;
103       static const plan_adt padt = {
104  	  X(rdft_solve), awake, print, destroy
105       };
106       if (!applicable(ego_, p_, plnr))
107            return (plan *)0;
108       p = (const problem_rdft *) p_;
109       n = p->sz->dims[0].n - 1;
110       A(n > 0);
111       buf = (R *) MALLOC(sizeof(R) * n, BUFFERS);
112       cld = X(mkplan_d)(plnr, X(mkproblem_rdft_1_d)(X(mktensor_1d)(n, 1, 1), 
113  						   X(mktensor_0d)(), 
114  						   buf, buf, R2HC));
115       X(ifree)(buf);
116       if (!cld)
117            return (plan *)0;
118       pln = MKPLAN_RDFT(P, &padt, apply);
119       pln->n = n;
120       pln->is = p->sz->dims[0].is;
121       pln->os = p->sz->dims[0].os;
122       pln->cld = cld;
123       pln->td = 0;
124       X(tensor_tornk1)(p->vecsz, &pln->vl, &pln->ivs, &pln->ovs);
125       X(ops_zero)(&ops);
126       ops.other = 8 + (n-1)/2 * 11 + (1 - n % 2) * 5;
127       ops.add = 2 + (n-1)/2 * 5;
128       ops.mul = (n-1)/2 * 3 + (1 - n % 2) * 1;
129       X(ops_zero)(&pln->super.super.ops);
130       X(ops_madd2)(pln->vl, &ops, &pln->super.super.ops);
131       X(ops_madd2)(pln->vl, &cld->ops, &pln->super.super.ops);
132       return &(pln->super.super);
133  }
134  static solver *mksolver(void)
135  {
136       static const solver_adt sadt = { PROBLEM_RDFT, mkplan, 0 };
137       S *slv = MKSOLVER(S, &sadt);
138       return &(slv->super);
139  }
140  void X(redft00e_r2hc_register)(planner *p)
141  {
142       REGISTER_SOLVER(p, mksolver());
143  }
</code></pre>
        </div>
        <div class="column">
            <h3>xmrig-MDEwOlJlcG9zaXRvcnk4ODMyNzQwNg==-flat-reader.h</h3>
            <pre><code>1  #ifndef RAPIDJSON_READER_H_
2  #define RAPIDJSON_READER_H_
3  #include "allocators.h"
4  #include "stream.h"
5  #include "encodedstream.h"
6  #include "internal/clzll.h"
7  #include "internal/meta.h"
8  #include "internal/stack.h"
9  #include "internal/strtod.h"
10  #include <limits>
11  #if defined(RAPIDJSON_SIMD) && defined(_MSC_VER)
12  #include <intrin.h>
13  #pragma intrinsic(_BitScanForward)
14  #endif
15  #ifdef RAPIDJSON_SSE42
16  #include <nmmintrin.h>
17  #elif defined(RAPIDJSON_SSE2)
18  #include <emmintrin.h>
19  #elif defined(RAPIDJSON_NEON)
20  #include <arm_neon.h>
21  #endif
22  #ifdef __clang__
23  RAPIDJSON_DIAG_PUSH
24  RAPIDJSON_DIAG_OFF(old-style-cast)
25  RAPIDJSON_DIAG_OFF(padded)
26  RAPIDJSON_DIAG_OFF(switch-enum)
27  #elif defined(_MSC_VER)
28  RAPIDJSON_DIAG_PUSH
29  RAPIDJSON_DIAG_OFF(4127)  
30  RAPIDJSON_DIAG_OFF(4702)  
31  #endif
32  #ifdef __GNUC__
33  RAPIDJSON_DIAG_PUSH
34  RAPIDJSON_DIAG_OFF(effc++)
35  #endif
36  #define RAPIDJSON_NOTHING &bsol;* deliberately empty */
37  #ifndef RAPIDJSON_PARSE_ERROR_EARLY_RETURN
38  #define RAPIDJSON_PARSE_ERROR_EARLY_RETURN(value) \
39      RAPIDJSON_MULTILINEMACRO_BEGIN \
40      if (RAPIDJSON_UNLIKELY(HasParseError())) { return value; } \
41      RAPIDJSON_MULTILINEMACRO_END
42  #endif
43  #define RAPIDJSON_PARSE_ERROR_EARLY_RETURN_VOID \
44      RAPIDJSON_PARSE_ERROR_EARLY_RETURN(RAPIDJSON_NOTHING)
45  #ifndef RAPIDJSON_PARSE_ERROR_NORETURN
46  #define RAPIDJSON_PARSE_ERROR_NORETURN(parseErrorCode, offset) \
47      RAPIDJSON_MULTILINEMACRO_BEGIN \
48      RAPIDJSON_ASSERT(!HasParseError()); &bsol;* Error can only be assigned once */ \
49      SetParseError(parseErrorCode, offset); \
50      RAPIDJSON_MULTILINEMACRO_END
51  #endif
52  #ifndef RAPIDJSON_PARSE_ERROR
53  #define RAPIDJSON_PARSE_ERROR(parseErrorCode, offset) \
54      RAPIDJSON_MULTILINEMACRO_BEGIN \
55      RAPIDJSON_PARSE_ERROR_NORETURN(parseErrorCode, offset); \
56      RAPIDJSON_PARSE_ERROR_EARLY_RETURN_VOID; \
57      RAPIDJSON_MULTILINEMACRO_END
58  #endif
59  #include "error/error.h" 
60  RAPIDJSON_NAMESPACE_BEGIN
61  #ifndef RAPIDJSON_PARSE_DEFAULT_FLAGS
62  #define RAPIDJSON_PARSE_DEFAULT_FLAGS kParseNoFlags
63  #endif
64  enum ParseFlag {
65      kParseNoFlags = 0,              
66      kParseInsituFlag = 1,           
67      kParseValidateEncodingFlag = 2, 
68      kParseIterativeFlag = 4,        
69      kParseStopWhenDoneFlag = 8,     
70      kParseFullPrecisionFlag = 16,   
71      kParseCommentsFlag = 32,        
72      kParseNumbersAsStringsFlag = 64,    
73      kParseTrailingCommasFlag = 128, 
74      kParseNanAndInfFlag = 256,      
75      kParseEscapedApostropheFlag = 512,  
76      kParseDefaultFlags = RAPIDJSON_PARSE_DEFAULT_FLAGS  
77  };
78  template<typename Encoding = UTF8<>, typename Derived = void>
79  struct BaseReaderHandler {
80      typedef typename Encoding::Ch Ch;
81      typedef typename internal::SelectIf<internal::IsSame<Derived, void>, BaseReaderHandler, Derived>::Type Override;
82      bool Default() { return true; }
83      bool Null() { return static_cast<Override&>(*this).Default(); }
84      bool Bool(bool) { return static_cast<Override&>(*this).Default(); }
85      bool Int(int) { return static_cast<Override&>(*this).Default(); }
86      bool Uint(unsigned) { return static_cast<Override&>(*this).Default(); }
87      bool Int64(int64_t) { return static_cast<Override&>(*this).Default(); }
88      bool Uint64(uint64_t) { return static_cast<Override&>(*this).Default(); }
89      bool Double(double) { return static_cast<Override&>(*this).Default(); }
90      bool RawNumber(const Ch* str, SizeType len, bool copy) { return static_cast<Override&>(*this).String(str, len, copy); }
91      bool String(const Ch*, SizeType, bool) { return static_cast<Override&>(*this).Default(); }
92      bool StartObject() { return static_cast<Override&>(*this).Default(); }
93      bool Key(const Ch* str, SizeType len, bool copy) { return static_cast<Override&>(*this).String(str, len, copy); }
94      bool EndObject(SizeType) { return static_cast<Override&>(*this).Default(); }
95      bool StartArray() { return static_cast<Override&>(*this).Default(); }
96      bool EndArray(SizeType) { return static_cast<Override&>(*this).Default(); }
97  };
98  namespace internal {
99  template<typename Stream, int = StreamTraits<Stream>::copyOptimization>
100  class StreamLocalCopy;
101  template<typename Stream>
102  class StreamLocalCopy<Stream, 1> {
103  public:
104      StreamLocalCopy(Stream& original) : s(original), original_(original) {}
105      ~StreamLocalCopy() { original_ = s; }
106      Stream s;
107  private:
108      StreamLocalCopy& operator=(const StreamLocalCopy&) &bsol;* = delete */;
109      Stream& original_;
110  };
111  template<typename Stream>
112  class StreamLocalCopy<Stream, 0> {
113  public:
114      StreamLocalCopy(Stream& original) : s(original) {}
115      Stream& s;
116  private:
117      StreamLocalCopy& operator=(const StreamLocalCopy&) &bsol;* = delete */;
118  };
119  } 
120  template<typename InputStream>
121  void SkipWhitespace(InputStream& is) {
122      internal::StreamLocalCopy<InputStream> copy(is);
123      InputStream& s(copy.s);
124      typename InputStream::Ch c;
125      while ((c = s.Peek()) == ' ' || c == '\n' || c == '\r' || c == '\t')
126          s.Take();
127  }
128  inline const char* SkipWhitespace(const char* p, const char* end) {
129      while (p != end && (*p == ' ' || *p == '\n' || *p == '\r' || *p == '\t'))
130          ++p;
131      return p;
132  }
133  #ifdef RAPIDJSON_SSE42
134  inline const char *SkipWhitespace_SIMD(const char* p) {
135      if (*p == ' ' || *p == '\n' || *p == '\r' || *p == '\t')
136          ++p;
137      else
138          return p;
139      const char* nextAligned = reinterpret_cast<const char*>((reinterpret_cast<size_t>(p) + 15) & static_cast<size_t>(~15));
140      while (p != nextAligned)
141          if (*p == ' ' || *p == '\n' || *p == '\r' || *p == '\t')
142              ++p;
143          else
144              return p;
145      static const char whitespace[16] = " \n\r\t";
146      const __m128i w = _mm_loadu_si128(reinterpret_cast<const __m128i *>(&whitespace[0]));
147      for (;; p += 16) {
148          const __m128i s = _mm_load_si128(reinterpret_cast<const __m128i *>(p));
149          const int r = _mm_cmpistri(w, s, _SIDD_UBYTE_OPS | _SIDD_CMP_EQUAL_ANY | _SIDD_LEAST_SIGNIFICANT | _SIDD_NEGATIVE_POLARITY);
150          if (r != 16)    
151              return p + r;
152      }
153  }
154  inline const char *SkipWhitespace_SIMD(const char* p, const char* end) {
155      if (p != end && (*p == ' ' || *p == '\n' || *p == '\r' || *p == '\t'))
156          ++p;
157      else
158          return p;
159      static const char whitespace[16] = " \n\r\t";
160      const __m128i w = _mm_loadu_si128(reinterpret_cast<const __m128i *>(&whitespace[0]));
161      for (; p <= end - 16; p += 16) {
162          const __m128i s = _mm_loadu_si128(reinterpret_cast<const __m128i *>(p));
163          const int r = _mm_cmpistri(w, s, _SIDD_UBYTE_OPS | _SIDD_CMP_EQUAL_ANY | _SIDD_LEAST_SIGNIFICANT | _SIDD_NEGATIVE_POLARITY);
164          if (r != 16)    
165              return p + r;
166      }
167      return SkipWhitespace(p, end);
168  }
169  #elif defined(RAPIDJSON_SSE2)
170  inline const char *SkipWhitespace_SIMD(const char* p) {
171      if (*p == ' ' || *p == '\n' || *p == '\r' || *p == '\t')
172          ++p;
173      else
174          return p;
175      const char* nextAligned = reinterpret_cast<const char*>((reinterpret_cast<size_t>(p) + 15) & static_cast<size_t>(~15));
176      while (p != nextAligned)
177          if (*p == ' ' || *p == '\n' || *p == '\r' || *p == '\t')
178              ++p;
179          else
180              return p;
181      #define C16(c) { c, c, c, c, c, c, c, c, c, c, c, c, c, c, c, c }
182      static const char whitespaces[4][16] = { C16(' '), C16('\n'), C16('\r'), C16('\t') };
183      #undef C16
184      const __m128i w0 = _mm_loadu_si128(reinterpret_cast<const __m128i *>(&whitespaces[0][0]));
185      const __m128i w1 = _mm_loadu_si128(reinterpret_cast<const __m128i *>(&whitespaces[1][0]));
186      const __m128i w2 = _mm_loadu_si128(reinterpret_cast<const __m128i *>(&whitespaces[2][0]));
187      const __m128i w3 = _mm_loadu_si128(reinterpret_cast<const __m128i *>(&whitespaces[3][0]));
188      for (;; p += 16) {
189          const __m128i s = _mm_load_si128(reinterpret_cast<const __m128i *>(p));
190          __m128i x = _mm_cmpeq_epi8(s, w0);
191          x = _mm_or_si128(x, _mm_cmpeq_epi8(s, w1));
192          x = _mm_or_si128(x, _mm_cmpeq_epi8(s, w2));
193          x = _mm_or_si128(x, _mm_cmpeq_epi8(s, w3));
194          unsigned short r = static_cast<unsigned short>(~_mm_movemask_epi8(x));
195          if (r != 0) {   
196  #ifdef _MSC_VER         
197              unsigned long offset;
198              _BitScanForward(&offset, r);
199              return p + offset;
200  #else
201              return p + __builtin_ffs(r) - 1;
202  #endif
203          }
204      }
205  }
206  inline const char *SkipWhitespace_SIMD(const char* p, const char* end) {
207      if (p != end && (*p == ' ' || *p == '\n' || *p == '\r' || *p == '\t'))
208          ++p;
209      else
210          return p;
211      #define C16(c) { c, c, c, c, c, c, c, c, c, c, c, c, c, c, c, c }
212      static const char whitespaces[4][16] = { C16(' '), C16('\n'), C16('\r'), C16('\t') };
213      #undef C16
214      const __m128i w0 = _mm_loadu_si128(reinterpret_cast<const __m128i *>(&whitespaces[0][0]));
215      const __m128i w1 = _mm_loadu_si128(reinterpret_cast<const __m128i *>(&whitespaces[1][0]));
216      const __m128i w2 = _mm_loadu_si128(reinterpret_cast<const __m128i *>(&whitespaces[2][0]));
217      const __m128i w3 = _mm_loadu_si128(reinterpret_cast<const __m128i *>(&whitespaces[3][0]));
218      for (; p <= end - 16; p += 16) {
219          const __m128i s = _mm_loadu_si128(reinterpret_cast<const __m128i *>(p));
220          __m128i x = _mm_cmpeq_epi8(s, w0);
221          x = _mm_or_si128(x, _mm_cmpeq_epi8(s, w1));
222          x = _mm_or_si128(x, _mm_cmpeq_epi8(s, w2));
223          x = _mm_or_si128(x, _mm_cmpeq_epi8(s, w3));
224          unsigned short r = static_cast<unsigned short>(~_mm_movemask_epi8(x));
225          if (r != 0) {   
226  #ifdef _MSC_VER         
227              unsigned long offset;
228              _BitScanForward(&offset, r);
229              return p + offset;
230  #else
231              return p + __builtin_ffs(r) - 1;
232  #endif
233          }
234      }
235      return SkipWhitespace(p, end);
236  }
237  #elif defined(RAPIDJSON_NEON)
238  inline const char *SkipWhitespace_SIMD(const char* p) {
239      if (*p == ' ' || *p == '\n' || *p == '\r' || *p == '\t')
240          ++p;
241      else
242          return p;
243      const char* nextAligned = reinterpret_cast<const char*>((reinterpret_cast<size_t>(p) + 15) & static_cast<size_t>(~15));
244      while (p != nextAligned)
245          if (*p == ' ' || *p == '\n' || *p == '\r' || *p == '\t')
246              ++p;
247          else
248              return p;
249      const uint8x16_t w0 = vmovq_n_u8(' ');
250      const uint8x16_t w1 = vmovq_n_u8('\n');
251      const uint8x16_t w2 = vmovq_n_u8('\r');
252      const uint8x16_t w3 = vmovq_n_u8('\t');
253      for (;; p += 16) {
254          const uint8x16_t s = vld1q_u8(reinterpret_cast<const uint8_t *>(p));
255          uint8x16_t x = vceqq_u8(s, w0);
256          x = vorrq_u8(x, vceqq_u8(s, w1));
257          x = vorrq_u8(x, vceqq_u8(s, w2));
258          x = vorrq_u8(x, vceqq_u8(s, w3));
259          x = vmvnq_u8(x);                       
260          x = vrev64q_u8(x);                     
261          uint64_t low = vgetq_lane_u64(vreinterpretq_u64_u8(x), 0);   
262          uint64_t high = vgetq_lane_u64(vreinterpretq_u64_u8(x), 1);  
263          if (low == 0) {
264              if (high != 0) {
265                  uint32_t lz = internal::clzll(high);
266                  return p + 8 + (lz >> 3);
267              }
268          } else {
269              uint32_t lz = internal::clzll(low);
270              return p + (lz >> 3);
271          }
272      }
273  }
274  inline const char *SkipWhitespace_SIMD(const char* p, const char* end) {
275      if (p != end && (*p == ' ' || *p == '\n' || *p == '\r' || *p == '\t'))
276          ++p;
277      else
278          return p;
279      const uint8x16_t w0 = vmovq_n_u8(' ');
280      const uint8x16_t w1 = vmovq_n_u8('\n');
281      const uint8x16_t w2 = vmovq_n_u8('\r');
282      const uint8x16_t w3 = vmovq_n_u8('\t');
283      for (; p <= end - 16; p += 16) {
284          const uint8x16_t s = vld1q_u8(reinterpret_cast<const uint8_t *>(p));
285          uint8x16_t x = vceqq_u8(s, w0);
286          x = vorrq_u8(x, vceqq_u8(s, w1));
287          x = vorrq_u8(x, vceqq_u8(s, w2));
288          x = vorrq_u8(x, vceqq_u8(s, w3));
289          x = vmvnq_u8(x);                       
290          x = vrev64q_u8(x);                     
291          uint64_t low = vgetq_lane_u64(vreinterpretq_u64_u8(x), 0);   
292          uint64_t high = vgetq_lane_u64(vreinterpretq_u64_u8(x), 1);  
293          if (low == 0) {
294              if (high != 0) {
295                  uint32_t lz = internal::clzll(high);
296                  return p + 8 + (lz >> 3);
297              }
298          } else {
299              uint32_t lz = internal::clzll(low);
300              return p + (lz >> 3);
301          }
302      }
303      return SkipWhitespace(p, end);
304  }
305  #endif 
306  #ifdef RAPIDJSON_SIMD
307  template<> inline void SkipWhitespace(InsituStringStream& is) {
308      is.src_ = const_cast<char*>(SkipWhitespace_SIMD(is.src_));
309  }
310  template<> inline void SkipWhitespace(StringStream& is) {
311      is.src_ = SkipWhitespace_SIMD(is.src_);
312  }
313  template<> inline void SkipWhitespace(EncodedInputStream<UTF8<>, MemoryStream>& is) {
314      is.is_.src_ = SkipWhitespace_SIMD(is.is_.src_, is.is_.end_);
315  }
316  #endif 
317  template <typename SourceEncoding, typename TargetEncoding, typename StackAllocator = CrtAllocator>
318  class GenericReader {
319  public:
320      typedef typename SourceEncoding::Ch Ch; 
321      GenericReader(StackAllocator* stackAllocator = 0, size_t stackCapacity = kDefaultStackCapacity) :
322          stack_(stackAllocator, stackCapacity), parseResult_(), state_(IterativeParsingStartState) {}
323      template <unsigned parseFlags, typename InputStream, typename Handler>
324      ParseResult Parse(InputStream& is, Handler& handler) {
325          if (parseFlags & kParseIterativeFlag)
326              return IterativeParse<parseFlags>(is, handler);
327          parseResult_.Clear();
328          ClearStackOnExit scope(*this);
329          SkipWhitespaceAndComments<parseFlags>(is);
330          RAPIDJSON_PARSE_ERROR_EARLY_RETURN(parseResult_);
331          if (RAPIDJSON_UNLIKELY(is.Peek() == '\0')) {
332              RAPIDJSON_PARSE_ERROR_NORETURN(kParseErrorDocumentEmpty, is.Tell());
333              RAPIDJSON_PARSE_ERROR_EARLY_RETURN(parseResult_);
334          }
335          else {
336              ParseValue<parseFlags>(is, handler);
337              RAPIDJSON_PARSE_ERROR_EARLY_RETURN(parseResult_);
338              if (!(parseFlags & kParseStopWhenDoneFlag)) {
339                  SkipWhitespaceAndComments<parseFlags>(is);
340                  RAPIDJSON_PARSE_ERROR_EARLY_RETURN(parseResult_);
341                  if (RAPIDJSON_UNLIKELY(is.Peek() != '\0')) {
342                      RAPIDJSON_PARSE_ERROR_NORETURN(kParseErrorDocumentRootNotSingular, is.Tell());
343                      RAPIDJSON_PARSE_ERROR_EARLY_RETURN(parseResult_);
344                  }
345              }
346          }
347          return parseResult_;
348      }
349      template <typename InputStream, typename Handler>
350      ParseResult Parse(InputStream& is, Handler& handler) {
351          return Parse<kParseDefaultFlags>(is, handler);
352      }
353      void IterativeParseInit() {
354          parseResult_.Clear();
355          state_ = IterativeParsingStartState;
356      }
357      template <unsigned parseFlags, typename InputStream, typename Handler>
358      bool IterativeParseNext(InputStream& is, Handler& handler) {
359          while (RAPIDJSON_LIKELY(is.Peek() != '\0')) {
360              SkipWhitespaceAndComments<parseFlags>(is);
361              Token t = Tokenize(is.Peek());
362              IterativeParsingState n = Predict(state_, t);
363              IterativeParsingState d = Transit<parseFlags>(state_, t, n, is, handler);
364              if (RAPIDJSON_UNLIKELY(IsIterativeParsingCompleteState(d))) {
365                  if (d == IterativeParsingErrorState) {
366                      HandleError(state_, is);
367                      return false;
368                  }
369                  RAPIDJSON_ASSERT(d == IterativeParsingFinishState);
370                  state_ = d;
371                  if (!(parseFlags & kParseStopWhenDoneFlag)) {
372                      SkipWhitespaceAndComments<parseFlags>(is);
373                      if (is.Peek() != '\0') {
374                          HandleError(state_, is);
375                          return false;
376                      }
377                  }
378                  return true;
379              }
380              state_ = d;
381              if (!IsIterativeParsingDelimiterState(n))
382                  return true;
383          }
384          stack_.Clear();
385          if (state_ != IterativeParsingFinishState) {
386              HandleError(state_, is);
387              return false;
388          }
389          return true;
390      }
391      RAPIDJSON_FORCEINLINE bool IterativeParseComplete() const {
392          return IsIterativeParsingCompleteState(state_);
393      }
394      bool HasParseError() const { return parseResult_.IsError(); }
395      ParseErrorCode GetParseErrorCode() const { return parseResult_.Code(); }
396      size_t GetErrorOffset() const { return parseResult_.Offset(); }
397  protected:
398      void SetParseError(ParseErrorCode code, size_t offset) { parseResult_.Set(code, offset); }
399  private:
400      GenericReader(const GenericReader&);
401      GenericReader& operator=(const GenericReader&);
402      void ClearStack() { stack_.Clear(); }
403      struct ClearStackOnExit {
404          explicit ClearStackOnExit(GenericReader& r) : r_(r) {}
405          ~ClearStackOnExit() { r_.ClearStack(); }
406      private:
407          GenericReader& r_;
408          ClearStackOnExit(const ClearStackOnExit&);
409          ClearStackOnExit& operator=(const ClearStackOnExit&);
410      };
411      template<unsigned parseFlags, typename InputStream>
412      void SkipWhitespaceAndComments(InputStream& is) {
413          SkipWhitespace(is);
414          if (parseFlags & kParseCommentsFlag) {
415              while (RAPIDJSON_UNLIKELY(Consume(is, '/'))) {
416                  if (Consume(is, '*')) {
417                      while (true) {
418                          if (RAPIDJSON_UNLIKELY(is.Peek() == '\0'))
419                              RAPIDJSON_PARSE_ERROR(kParseErrorUnspecificSyntaxError, is.Tell());
420                          else if (Consume(is, '*')) {
421                              if (Consume(is, '/'))
422                                  break;
423                          }
424                          else
425                              is.Take();
426                      }
427                  }
428                  else if (RAPIDJSON_LIKELY(Consume(is, '/')))
429                      while (is.Peek() != '\0' && is.Take() != '\n') {}
430                  else
431                      RAPIDJSON_PARSE_ERROR(kParseErrorUnspecificSyntaxError, is.Tell());
432                  SkipWhitespace(is);
433              }
434          }
435      }
436      template<unsigned parseFlags, typename InputStream, typename Handler>
437      void ParseObject(InputStream& is, Handler& handler) {
438          RAPIDJSON_ASSERT(is.Peek() == '{');
439          is.Take();  
440          if (RAPIDJSON_UNLIKELY(!handler.StartObject()))
441              RAPIDJSON_PARSE_ERROR(kParseErrorTermination, is.Tell());
442          SkipWhitespaceAndComments<parseFlags>(is);
443          RAPIDJSON_PARSE_ERROR_EARLY_RETURN_VOID;
444          if (Consume(is, '}')) {
445              if (RAPIDJSON_UNLIKELY(!handler.EndObject(0)))  
446                  RAPIDJSON_PARSE_ERROR(kParseErrorTermination, is.Tell());
447              return;
448          }
449          for (SizeType memberCount = 0;;) {
450              if (RAPIDJSON_UNLIKELY(is.Peek() != '"'))
451                  RAPIDJSON_PARSE_ERROR(kParseErrorObjectMissName, is.Tell());
452              ParseString<parseFlags>(is, handler, true);
453              RAPIDJSON_PARSE_ERROR_EARLY_RETURN_VOID;
454              SkipWhitespaceAndComments<parseFlags>(is);
455              RAPIDJSON_PARSE_ERROR_EARLY_RETURN_VOID;
456              if (RAPIDJSON_UNLIKELY(!Consume(is, ':')))
457                  RAPIDJSON_PARSE_ERROR(kParseErrorObjectMissColon, is.Tell());
458              SkipWhitespaceAndComments<parseFlags>(is);
459              RAPIDJSON_PARSE_ERROR_EARLY_RETURN_VOID;
460              ParseValue<parseFlags>(is, handler);
461              RAPIDJSON_PARSE_ERROR_EARLY_RETURN_VOID;
462              SkipWhitespaceAndComments<parseFlags>(is);
463              RAPIDJSON_PARSE_ERROR_EARLY_RETURN_VOID;
464              ++memberCount;
465              switch (is.Peek()) {
466                  case ',':
467                      is.Take();
468                      SkipWhitespaceAndComments<parseFlags>(is);
469                      RAPIDJSON_PARSE_ERROR_EARLY_RETURN_VOID;
470                      break;
471                  case '}':
472                      is.Take();
473                      if (RAPIDJSON_UNLIKELY(!handler.EndObject(memberCount)))
474                          RAPIDJSON_PARSE_ERROR(kParseErrorTermination, is.Tell());
475                      return;
476                  default:
477                      RAPIDJSON_PARSE_ERROR(kParseErrorObjectMissCommaOrCurlyBracket, is.Tell()); break; 
478              }
479              if (parseFlags & kParseTrailingCommasFlag) {
480                  if (is.Peek() == '}') {
481                      if (RAPIDJSON_UNLIKELY(!handler.EndObject(memberCount)))
482                          RAPIDJSON_PARSE_ERROR(kParseErrorTermination, is.Tell());
483                      is.Take();
484                      return;
485                  }
486              }
487          }
488      }
489      template<unsigned parseFlags, typename InputStream, typename Handler>
490      void ParseArray(InputStream& is, Handler& handler) {
491          RAPIDJSON_ASSERT(is.Peek() == '[');
492          is.Take();  
493          if (RAPIDJSON_UNLIKELY(!handler.StartArray()))
494              RAPIDJSON_PARSE_ERROR(kParseErrorTermination, is.Tell());
495          SkipWhitespaceAndComments<parseFlags>(is);
496          RAPIDJSON_PARSE_ERROR_EARLY_RETURN_VOID;
497          if (Consume(is, ']')) {
498              if (RAPIDJSON_UNLIKELY(!handler.EndArray(0))) 
499                  RAPIDJSON_PARSE_ERROR(kParseErrorTermination, is.Tell());
500              return;
501          }
502          for (SizeType elementCount = 0;;) {
503              ParseValue<parseFlags>(is, handler);
504              RAPIDJSON_PARSE_ERROR_EARLY_RETURN_VOID;
505              ++elementCount;
506              SkipWhitespaceAndComments<parseFlags>(is);
507              RAPIDJSON_PARSE_ERROR_EARLY_RETURN_VOID;
508              if (Consume(is, ',')) {
509                  SkipWhitespaceAndComments<parseFlags>(is);
510                  RAPIDJSON_PARSE_ERROR_EARLY_RETURN_VOID;
511              }
512              else if (Consume(is, ']')) {
513                  if (RAPIDJSON_UNLIKELY(!handler.EndArray(elementCount)))
514                      RAPIDJSON_PARSE_ERROR(kParseErrorTermination, is.Tell());
515                  return;
516              }
517              else
518                  RAPIDJSON_PARSE_ERROR(kParseErrorArrayMissCommaOrSquareBracket, is.Tell());
519              if (parseFlags & kParseTrailingCommasFlag) {
520                  if (is.Peek() == ']') {
521                      if (RAPIDJSON_UNLIKELY(!handler.EndArray(elementCount)))
522                          RAPIDJSON_PARSE_ERROR(kParseErrorTermination, is.Tell());
523                      is.Take();
524                      return;
525                  }
526              }
527          }
528      }
529      template<unsigned parseFlags, typename InputStream, typename Handler>
530      void ParseNull(InputStream& is, Handler& handler) {
531          RAPIDJSON_ASSERT(is.Peek() == 'n');
532          is.Take();
533          if (RAPIDJSON_LIKELY(Consume(is, 'u') && Consume(is, 'l') && Consume(is, 'l'))) {
534              if (RAPIDJSON_UNLIKELY(!handler.Null()))
535                  RAPIDJSON_PARSE_ERROR(kParseErrorTermination, is.Tell());
536          }
537          else
538              RAPIDJSON_PARSE_ERROR(kParseErrorValueInvalid, is.Tell());
539      }
540      template<unsigned parseFlags, typename InputStream, typename Handler>
541      void ParseTrue(InputStream& is, Handler& handler) {
542          RAPIDJSON_ASSERT(is.Peek() == 't');
543          is.Take();
544          if (RAPIDJSON_LIKELY(Consume(is, 'r') && Consume(is, 'u') && Consume(is, 'e'))) {
545              if (RAPIDJSON_UNLIKELY(!handler.Bool(true)))
546                  RAPIDJSON_PARSE_ERROR(kParseErrorTermination, is.Tell());
547          }
548          else
549              RAPIDJSON_PARSE_ERROR(kParseErrorValueInvalid, is.Tell());
550      }
551      template<unsigned parseFlags, typename InputStream, typename Handler>
552      void ParseFalse(InputStream& is, Handler& handler) {
553          RAPIDJSON_ASSERT(is.Peek() == 'f');
554          is.Take();
555          if (RAPIDJSON_LIKELY(Consume(is, 'a') && Consume(is, 'l') && Consume(is, 's') && Consume(is, 'e'))) {
556              if (RAPIDJSON_UNLIKELY(!handler.Bool(false)))
557                  RAPIDJSON_PARSE_ERROR(kParseErrorTermination, is.Tell());
558          }
559          else
560              RAPIDJSON_PARSE_ERROR(kParseErrorValueInvalid, is.Tell());
561      }
562      template<typename InputStream>
563      RAPIDJSON_FORCEINLINE static bool Consume(InputStream& is, typename InputStream::Ch expect) {
564          if (RAPIDJSON_LIKELY(is.Peek() == expect)) {
565              is.Take();
566              return true;
567          }
568          else
569              return false;
570      }
571      template<typename InputStream>
572      unsigned ParseHex4(InputStream& is, size_t escapeOffset) {
573          unsigned codepoint = 0;
574          for (int i = 0; i < 4; i++) {
575              Ch c = is.Peek();
576              codepoint <<= 4;
577              codepoint += static_cast<unsigned>(c);
578              if (c >= '0' && c <= '9')
579                  codepoint -= '0';
580              else if (c >= 'A' && c <= 'F')
581                  codepoint -= 'A' - 10;
582              else if (c >= 'a' && c <= 'f')
583                  codepoint -= 'a' - 10;
584              else {
585                  RAPIDJSON_PARSE_ERROR_NORETURN(kParseErrorStringUnicodeEscapeInvalidHex, escapeOffset);
586                  RAPIDJSON_PARSE_ERROR_EARLY_RETURN(0);
587              }
588              is.Take();
589          }
590          return codepoint;
591      }
592      template <typename CharType>
593      class StackStream {
594      public:
595          typedef CharType Ch;
596          StackStream(internal::Stack<StackAllocator>& stack) : stack_(stack), length_(0) {}
597          RAPIDJSON_FORCEINLINE void Put(Ch c) {
598              *stack_.template Push<Ch>() = c;
599              ++length_;
600          }
601          RAPIDJSON_FORCEINLINE void* Push(SizeType count) {
602              length_ += count;
603              return stack_.template Push<Ch>(count);
604          }
605          size_t Length() const { return length_; }
606          Ch* Pop() {
607              return stack_.template Pop<Ch>(length_);
608          }
609      private:
610          StackStream(const StackStream&);
611          StackStream& operator=(const StackStream&);
612          internal::Stack<StackAllocator>& stack_;
613          SizeType length_;
614      };
615      template<unsigned parseFlags, typename InputStream, typename Handler>
616      void ParseString(InputStream& is, Handler& handler, bool isKey = false) {
617          internal::StreamLocalCopy<InputStream> copy(is);
618          InputStream& s(copy.s);
619          RAPIDJSON_ASSERT(s.Peek() == '\"');
620          s.Take();  
621          bool success = false;
622          if (parseFlags & kParseInsituFlag) {
623              typename InputStream::Ch *head = s.PutBegin();
624              ParseStringToStream<parseFlags, SourceEncoding, SourceEncoding>(s, s);
625              RAPIDJSON_PARSE_ERROR_EARLY_RETURN_VOID;
626              size_t length = s.PutEnd(head) - 1;
627              RAPIDJSON_ASSERT(length <= 0xFFFFFFFF);
628              const typename TargetEncoding::Ch* const str = reinterpret_cast<typename TargetEncoding::Ch*>(head);
629              success = (isKey ? handler.Key(str, SizeType(length), false) : handler.String(str, SizeType(length), false));
630          }
631          else {
632              StackStream<typename TargetEncoding::Ch> stackStream(stack_);
633              ParseStringToStream<parseFlags, SourceEncoding, TargetEncoding>(s, stackStream);
634              RAPIDJSON_PARSE_ERROR_EARLY_RETURN_VOID;
635              SizeType length = static_cast<SizeType>(stackStream.Length()) - 1;
636              const typename TargetEncoding::Ch* const str = stackStream.Pop();
637              success = (isKey ? handler.Key(str, length, true) : handler.String(str, length, true));
638          }
639          if (RAPIDJSON_UNLIKELY(!success))
640              RAPIDJSON_PARSE_ERROR(kParseErrorTermination, s.Tell());
641      }
642      template<unsigned parseFlags, typename SEncoding, typename TEncoding, typename InputStream, typename OutputStream>
643      RAPIDJSON_FORCEINLINE void ParseStringToStream(InputStream& is, OutputStream& os) {
644  #define Z16 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
645          static const char escape[256] = {
646              Z16, Z16, 0, 0,'\"', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, '/',
647              Z16, Z16, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,'\\', 0, 0, 0,
648              0, 0,'\b', 0, 0, 0,'\f', 0, 0, 0, 0, 0, 0, 0,'\n', 0,
649              0, 0,'\r', 0,'\t', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
650              Z16, Z16, Z16, Z16, Z16, Z16, Z16, Z16
651          };
652  #undef Z16
653          for (;;) {
654              if (!(parseFlags & kParseValidateEncodingFlag))
655                  ScanCopyUnescapedString(is, os);
656              Ch c = is.Peek();
657              if (RAPIDJSON_UNLIKELY(c == '\\')) {    
658                  size_t escapeOffset = is.Tell();    
659                  is.Take();
660                  Ch e = is.Peek();
661                  if ((sizeof(Ch) == 1 || unsigned(e) < 256) && RAPIDJSON_LIKELY(escape[static_cast<unsigned char>(e)])) {
662                      is.Take();
663                      os.Put(static_cast<typename TEncoding::Ch>(escape[static_cast<unsigned char>(e)]));
664                  }
665                  else if ((parseFlags & kParseEscapedApostropheFlag) && RAPIDJSON_LIKELY(e == '\'')) { 
666                      is.Take();
667                      os.Put('\'');
668                  }
669                  else if (RAPIDJSON_LIKELY(e == 'u')) {    
670                      is.Take();
671                      unsigned codepoint = ParseHex4(is, escapeOffset);
672                      RAPIDJSON_PARSE_ERROR_EARLY_RETURN_VOID;
673                      if (RAPIDJSON_UNLIKELY(codepoint >= 0xD800 && codepoint <= 0xDFFF)) {
674                          if (RAPIDJSON_LIKELY(codepoint <= 0xDBFF)) {
675                              if (RAPIDJSON_UNLIKELY(!Consume(is, '\\') || !Consume(is, 'u')))
676                                  RAPIDJSON_PARSE_ERROR(kParseErrorStringUnicodeSurrogateInvalid, escapeOffset);
677                              unsigned codepoint2 = ParseHex4(is, escapeOffset);
678                              RAPIDJSON_PARSE_ERROR_EARLY_RETURN_VOID;
679                              if (RAPIDJSON_UNLIKELY(codepoint2 < 0xDC00 || codepoint2 > 0xDFFF))
680                                  RAPIDJSON_PARSE_ERROR(kParseErrorStringUnicodeSurrogateInvalid, escapeOffset);
681                              codepoint = (((codepoint - 0xD800) << 10) | (codepoint2 - 0xDC00)) + 0x10000;
682                          }
683                          else
684                          {
685                              RAPIDJSON_PARSE_ERROR(kParseErrorStringUnicodeSurrogateInvalid, escapeOffset);
686                          }
687                      }
688                      TEncoding::Encode(os, codepoint);
689                  }
690                  else
691                      RAPIDJSON_PARSE_ERROR(kParseErrorStringEscapeInvalid, escapeOffset);
692              }
693              else if (RAPIDJSON_UNLIKELY(c == '"')) {    
694                  is.Take();
695                  os.Put('\0');   
696                  return;
697              }
698              else if (RAPIDJSON_UNLIKELY(static_cast<unsigned>(c) < 0x20)) { 
699                  if (c == '\0')
700                      RAPIDJSON_PARSE_ERROR(kParseErrorStringMissQuotationMark, is.Tell());
701                  else
702                      RAPIDJSON_PARSE_ERROR(kParseErrorStringInvalidEncoding, is.Tell());
703              }
704              else {
705                  size_t offset = is.Tell();
706                  if (RAPIDJSON_UNLIKELY((parseFlags & kParseValidateEncodingFlag ?
707                      !Transcoder<SEncoding, TEncoding>::Validate(is, os) :
708                      !Transcoder<SEncoding, TEncoding>::Transcode(is, os))))
709                      RAPIDJSON_PARSE_ERROR(kParseErrorStringInvalidEncoding, offset);
710              }
711          }
712      }
713      template<typename InputStream, typename OutputStream>
714      static RAPIDJSON_FORCEINLINE void ScanCopyUnescapedString(InputStream&, OutputStream&) {
715      }
716  #if defined(RAPIDJSON_SSE2) || defined(RAPIDJSON_SSE42)
717      static RAPIDJSON_FORCEINLINE void ScanCopyUnescapedString(StringStream& is, StackStream<char>& os) {
718          const char* p = is.src_;
719          const char* nextAligned = reinterpret_cast<const char*>((reinterpret_cast<size_t>(p) + 15) & static_cast<size_t>(~15));
720          while (p != nextAligned)
721              if (RAPIDJSON_UNLIKELY(*p == '\"') || RAPIDJSON_UNLIKELY(*p == '\\') || RAPIDJSON_UNLIKELY(static_cast<unsigned>(*p) < 0x20)) {
722                  is.src_ = p;
723                  return;
724              }
725              else
726                  os.Put(*p++);
727          static const char dquote[16] = { '\"', '\"', '\"', '\"', '\"', '\"', '\"', '\"', '\"', '\"', '\"', '\"', '\"', '\"', '\"', '\"' };
728          static const char bslash[16] = { '\\', '\\', '\\', '\\', '\\', '\\', '\\', '\\', '\\', '\\', '\\', '\\', '\\', '\\', '\\', '\\' };
729          static const char space[16]  = { 0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F };
730          const __m128i dq = _mm_loadu_si128(reinterpret_cast<const __m128i *>(&dquote[0]));
731          const __m128i bs = _mm_loadu_si128(reinterpret_cast<const __m128i *>(&bslash[0]));
732          const __m128i sp = _mm_loadu_si128(reinterpret_cast<const __m128i *>(&space[0]));
733          for (;; p += 16) {
734              const __m128i s = _mm_load_si128(reinterpret_cast<const __m128i *>(p));
735              const __m128i t1 = _mm_cmpeq_epi8(s, dq);
736              const __m128i t2 = _mm_cmpeq_epi8(s, bs);
737              const __m128i t3 = _mm_cmpeq_epi8(_mm_max_epu8(s, sp), sp); 
738              const __m128i x = _mm_or_si128(_mm_or_si128(t1, t2), t3);
739              unsigned short r = static_cast<unsigned short>(_mm_movemask_epi8(x));
740              if (RAPIDJSON_UNLIKELY(r != 0)) {   
741                  SizeType length;
742      #ifdef _MSC_VER         
743                  unsigned long offset;
744                  _BitScanForward(&offset, r);
745                  length = offset;
746      #else
747                  length = static_cast<SizeType>(__builtin_ffs(r) - 1);
748      #endif
749                  if (length != 0) {
750                      char* q = reinterpret_cast<char*>(os.Push(length));
751                      for (size_t i = 0; i < length; i++)
752                          q[i] = p[i];
753                      p += length;
754                  }
755                  break;
756              }
757              _mm_storeu_si128(reinterpret_cast<__m128i *>(os.Push(16)), s);
758          }
759          is.src_ = p;
760      }
761      static RAPIDJSON_FORCEINLINE void ScanCopyUnescapedString(InsituStringStream& is, InsituStringStream& os) {
762          RAPIDJSON_ASSERT(&is == &os);
763          (void)os;
764          if (is.src_ == is.dst_) {
765              SkipUnescapedString(is);
766              return;
767          }
768          char* p = is.src_;
769          char *q = is.dst_;
770          const char* nextAligned = reinterpret_cast<const char*>((reinterpret_cast<size_t>(p) + 15) & static_cast<size_t>(~15));
771          while (p != nextAligned)
772              if (RAPIDJSON_UNLIKELY(*p == '\"') || RAPIDJSON_UNLIKELY(*p == '\\') || RAPIDJSON_UNLIKELY(static_cast<unsigned>(*p) < 0x20)) {
773                  is.src_ = p;
774                  is.dst_ = q;
775                  return;
776              }
777              else
778                  *q++ = *p++;
779          static const char dquote[16] = { '\"', '\"', '\"', '\"', '\"', '\"', '\"', '\"', '\"', '\"', '\"', '\"', '\"', '\"', '\"', '\"' };
780          static const char bslash[16] = { '\\', '\\', '\\', '\\', '\\', '\\', '\\', '\\', '\\', '\\', '\\', '\\', '\\', '\\', '\\', '\\' };
781          static const char space[16] = { 0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F };
782          const __m128i dq = _mm_loadu_si128(reinterpret_cast<const __m128i *>(&dquote[0]));
783          const __m128i bs = _mm_loadu_si128(reinterpret_cast<const __m128i *>(&bslash[0]));
784          const __m128i sp = _mm_loadu_si128(reinterpret_cast<const __m128i *>(&space[0]));
785          for (;; p += 16, q += 16) {
786              const __m128i s = _mm_load_si128(reinterpret_cast<const __m128i *>(p));
787              const __m128i t1 = _mm_cmpeq_epi8(s, dq);
788              const __m128i t2 = _mm_cmpeq_epi8(s, bs);
789              const __m128i t3 = _mm_cmpeq_epi8(_mm_max_epu8(s, sp), sp); 
790              const __m128i x = _mm_or_si128(_mm_or_si128(t1, t2), t3);
791              unsigned short r = static_cast<unsigned short>(_mm_movemask_epi8(x));
792              if (RAPIDJSON_UNLIKELY(r != 0)) {   
793                  size_t length;
794  #ifdef _MSC_VER         
795                  unsigned long offset;
796                  _BitScanForward(&offset, r);
797                  length = offset;
798  #else
799                  length = static_cast<size_t>(__builtin_ffs(r) - 1);
800  #endif
801                  for (const char* pend = p + length; p != pend; )
802                      *q++ = *p++;
803                  break;
804              }
805              _mm_storeu_si128(reinterpret_cast<__m128i *>(q), s);
806          }
807          is.src_ = p;
808          is.dst_ = q;
809      }
810      static RAPIDJSON_FORCEINLINE void SkipUnescapedString(InsituStringStream& is) {
811          RAPIDJSON_ASSERT(is.src_ == is.dst_);
812          char* p = is.src_;
813          const char* nextAligned = reinterpret_cast<const char*>((reinterpret_cast<size_t>(p) + 15) & static_cast<size_t>(~15));
814          for (; p != nextAligned; p++)
815              if (RAPIDJSON_UNLIKELY(*p == '\"') || RAPIDJSON_UNLIKELY(*p == '\\') || RAPIDJSON_UNLIKELY(static_cast<unsigned>(*p) < 0x20)) {
816                  is.src_ = is.dst_ = p;
817                  return;
818              }
819          static const char dquote[16] = { '\"', '\"', '\"', '\"', '\"', '\"', '\"', '\"', '\"', '\"', '\"', '\"', '\"', '\"', '\"', '\"' };
820          static const char bslash[16] = { '\\', '\\', '\\', '\\', '\\', '\\', '\\', '\\', '\\', '\\', '\\', '\\', '\\', '\\', '\\', '\\' };
821          static const char space[16] = { 0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F };
822          const __m128i dq = _mm_loadu_si128(reinterpret_cast<const __m128i *>(&dquote[0]));
823          const __m128i bs = _mm_loadu_si128(reinterpret_cast<const __m128i *>(&bslash[0]));
824          const __m128i sp = _mm_loadu_si128(reinterpret_cast<const __m128i *>(&space[0]));
825          for (;; p += 16) {
826              const __m128i s = _mm_load_si128(reinterpret_cast<const __m128i *>(p));
827              const __m128i t1 = _mm_cmpeq_epi8(s, dq);
828              const __m128i t2 = _mm_cmpeq_epi8(s, bs);
829              const __m128i t3 = _mm_cmpeq_epi8(_mm_max_epu8(s, sp), sp); 
830              const __m128i x = _mm_or_si128(_mm_or_si128(t1, t2), t3);
831              unsigned short r = static_cast<unsigned short>(_mm_movemask_epi8(x));
832              if (RAPIDJSON_UNLIKELY(r != 0)) {   
833                  size_t length;
834  #ifdef _MSC_VER         
835                  unsigned long offset;
836                  _BitScanForward(&offset, r);
837                  length = offset;
838  #else
839                  length = static_cast<size_t>(__builtin_ffs(r) - 1);
840  #endif
841                  p += length;
842                  break;
843              }
844          }
845          is.src_ = is.dst_ = p;
846      }
847  #elif defined(RAPIDJSON_NEON)
848      static RAPIDJSON_FORCEINLINE void ScanCopyUnescapedString(StringStream& is, StackStream<char>& os) {
849          const char* p = is.src_;
850          const char* nextAligned = reinterpret_cast<const char*>((reinterpret_cast<size_t>(p) + 15) & static_cast<size_t>(~15));
851          while (p != nextAligned)
852              if (RAPIDJSON_UNLIKELY(*p == '\"') || RAPIDJSON_UNLIKELY(*p == '\\') || RAPIDJSON_UNLIKELY(static_cast<unsigned>(*p) < 0x20)) {
853                  is.src_ = p;
854                  return;
855              }
856              else
857                  os.Put(*p++);
858          const uint8x16_t s0 = vmovq_n_u8('"');
859          const uint8x16_t s1 = vmovq_n_u8('\\');
860          const uint8x16_t s2 = vmovq_n_u8('\b');
861          const uint8x16_t s3 = vmovq_n_u8(32);
862          for (;; p += 16) {
863              const uint8x16_t s = vld1q_u8(reinterpret_cast<const uint8_t *>(p));
864              uint8x16_t x = vceqq_u8(s, s0);
865              x = vorrq_u8(x, vceqq_u8(s, s1));
866              x = vorrq_u8(x, vceqq_u8(s, s2));
867              x = vorrq_u8(x, vcltq_u8(s, s3));
868              x = vrev64q_u8(x);                     
869              uint64_t low = vgetq_lane_u64(vreinterpretq_u64_u8(x), 0);   
870              uint64_t high = vgetq_lane_u64(vreinterpretq_u64_u8(x), 1);  
871              SizeType length = 0;
872              bool escaped = false;
873              if (low == 0) {
874                  if (high != 0) {
875                      uint32_t lz = internal::clzll(high);
876                      length = 8 + (lz >> 3);
877                      escaped = true;
878                  }
879              } else {
880                  uint32_t lz = internal::clzll(low);
881                  length = lz >> 3;
882                  escaped = true;
883              }
884              if (RAPIDJSON_UNLIKELY(escaped)) {   
885                  if (length != 0) {
886                      char* q = reinterpret_cast<char*>(os.Push(length));
887                      for (size_t i = 0; i < length; i++)
888                          q[i] = p[i];
889                      p += length;
890                  }
891                  break;
892              }
893              vst1q_u8(reinterpret_cast<uint8_t *>(os.Push(16)), s);
894          }
895          is.src_ = p;
896      }
897      static RAPIDJSON_FORCEINLINE void ScanCopyUnescapedString(InsituStringStream& is, InsituStringStream& os) {
898          RAPIDJSON_ASSERT(&is == &os);
899          (void)os;
900          if (is.src_ == is.dst_) {
901              SkipUnescapedString(is);
902              return;
903          }
904          char* p = is.src_;
905          char *q = is.dst_;
906          const char* nextAligned = reinterpret_cast<const char*>((reinterpret_cast<size_t>(p) + 15) & static_cast<size_t>(~15));
907          while (p != nextAligned)
908              if (RAPIDJSON_UNLIKELY(*p == '\"') || RAPIDJSON_UNLIKELY(*p == '\\') || RAPIDJSON_UNLIKELY(static_cast<unsigned>(*p) < 0x20)) {
909                  is.src_ = p;
910                  is.dst_ = q;
911                  return;
912              }
913              else
914                  *q++ = *p++;
915          const uint8x16_t s0 = vmovq_n_u8('"');
916          const uint8x16_t s1 = vmovq_n_u8('\\');
917          const uint8x16_t s2 = vmovq_n_u8('\b');
918          const uint8x16_t s3 = vmovq_n_u8(32);
919          for (;; p += 16, q += 16) {
920              const uint8x16_t s = vld1q_u8(reinterpret_cast<uint8_t *>(p));
921              uint8x16_t x = vceqq_u8(s, s0);
922              x = vorrq_u8(x, vceqq_u8(s, s1));
923              x = vorrq_u8(x, vceqq_u8(s, s2));
924              x = vorrq_u8(x, vcltq_u8(s, s3));
925              x = vrev64q_u8(x);                     
926              uint64_t low = vgetq_lane_u64(vreinterpretq_u64_u8(x), 0);   
927              uint64_t high = vgetq_lane_u64(vreinterpretq_u64_u8(x), 1);  
928              SizeType length = 0;
929              bool escaped = false;
930              if (low == 0) {
931                  if (high != 0) {
932                      uint32_t lz = internal::clzll(high);
933                      length = 8 + (lz >> 3);
934                      escaped = true;
935                  }
936              } else {
937                  uint32_t lz = internal::clzll(low);
938                  length = lz >> 3;
939                  escaped = true;
940              }
941              if (RAPIDJSON_UNLIKELY(escaped)) {   
942                  for (const char* pend = p + length; p != pend; ) {
943                      *q++ = *p++;
944                  }
945                  break;
946              }
947              vst1q_u8(reinterpret_cast<uint8_t *>(q), s);
948          }
949          is.src_ = p;
950          is.dst_ = q;
951      }
952      static RAPIDJSON_FORCEINLINE void SkipUnescapedString(InsituStringStream& is) {
953          RAPIDJSON_ASSERT(is.src_ == is.dst_);
954          char* p = is.src_;
955          const char* nextAligned = reinterpret_cast<const char*>((reinterpret_cast<size_t>(p) + 15) & static_cast<size_t>(~15));
956          for (; p != nextAligned; p++)
957              if (RAPIDJSON_UNLIKELY(*p == '\"') || RAPIDJSON_UNLIKELY(*p == '\\') || RAPIDJSON_UNLIKELY(static_cast<unsigned>(*p) < 0x20)) {
958                  is.src_ = is.dst_ = p;
959                  return;
960              }
961          const uint8x16_t s0 = vmovq_n_u8('"');
962          const uint8x16_t s1 = vmovq_n_u8('\\');
963          const uint8x16_t s2 = vmovq_n_u8('\b');
964          const uint8x16_t s3 = vmovq_n_u8(32);
965          for (;; p += 16) {
966              const uint8x16_t s = vld1q_u8(reinterpret_cast<uint8_t *>(p));
967              uint8x16_t x = vceqq_u8(s, s0);
968              x = vorrq_u8(x, vceqq_u8(s, s1));
969              x = vorrq_u8(x, vceqq_u8(s, s2));
970              x = vorrq_u8(x, vcltq_u8(s, s3));
971              x = vrev64q_u8(x);                     
972              uint64_t low = vgetq_lane_u64(vreinterpretq_u64_u8(x), 0);   
973              uint64_t high = vgetq_lane_u64(vreinterpretq_u64_u8(x), 1);  
974              if (low == 0) {
975                  if (high != 0) {
976                      uint32_t lz = internal::clzll(high);
977                      p += 8 + (lz >> 3);
978                      break;
979                  }
980              } else {
981                  uint32_t lz = internal::clzll(low);
982                  p += lz >> 3;
983                  break;
984              }
985          }
986          is.src_ = is.dst_ = p;
987      }
988  #endif 
989      template<typename InputStream, typename StackCharacter, bool backup, bool pushOnTake>
990      class NumberStream;
991      template<typename InputStream, typename StackCharacter>
992      class NumberStream<InputStream, StackCharacter, false, false> {
993      public:
994          typedef typename InputStream::Ch Ch;
995          NumberStream(GenericReader& reader, InputStream& s) : is(s) { (void)reader;  }
996          RAPIDJSON_FORCEINLINE Ch Peek() const { return is.Peek(); }
997          RAPIDJSON_FORCEINLINE Ch TakePush() { return is.Take(); }
998          RAPIDJSON_FORCEINLINE Ch Take() { return is.Take(); }
999          RAPIDJSON_FORCEINLINE void Push(char) {}
1000          size_t Tell() { return is.Tell(); }
1001          size_t Length() { return 0; }
1002          const StackCharacter* Pop() { return 0; }
1003      protected:
1004          NumberStream& operator=(const NumberStream&);
1005          InputStream& is;
1006      };
1007      template<typename InputStream, typename StackCharacter>
1008      class NumberStream<InputStream, StackCharacter, true, false> : public NumberStream<InputStream, StackCharacter, false, false> {
1009          typedef NumberStream<InputStream, StackCharacter, false, false> Base;
1010      public:
1011          NumberStream(GenericReader& reader, InputStream& is) : Base(reader, is), stackStream(reader.stack_) {}
1012          RAPIDJSON_FORCEINLINE Ch TakePush() {
1013              stackStream.Put(static_cast<StackCharacter>(Base::is.Peek()));
1014              return Base::is.Take();
1015          }
1016          RAPIDJSON_FORCEINLINE void Push(StackCharacter c) {
1017              stackStream.Put(c);
1018          }
1019          size_t Length() { return stackStream.Length(); }
1020          const StackCharacter* Pop() {
1021              stackStream.Put('\0');
1022              return stackStream.Pop();
1023          }
1024      private:
1025          StackStream<StackCharacter> stackStream;
1026      };
1027      template<typename InputStream, typename StackCharacter>
1028      class NumberStream<InputStream, StackCharacter, true, true> : public NumberStream<InputStream, StackCharacter, true, false> {
1029          typedef NumberStream<InputStream, StackCharacter, true, false> Base;
1030      public:
1031          NumberStream(GenericReader& reader, InputStream& is) : Base(reader, is) {}
1032          RAPIDJSON_FORCEINLINE Ch Take() { return Base::TakePush(); }
1033      };
1034      template<unsigned parseFlags, typename InputStream, typename Handler>
1035      void ParseNumber(InputStream& is, Handler& handler) {
1036          typedef typename internal::SelectIf<internal::BoolType<(parseFlags & kParseNumbersAsStringsFlag) != 0>, typename TargetEncoding::Ch, char>::Type NumberCharacter;
1037          internal::StreamLocalCopy<InputStream> copy(is);
1038          NumberStream<InputStream, NumberCharacter,
1039              ((parseFlags & kParseNumbersAsStringsFlag) != 0) ?
1040                  ((parseFlags & kParseInsituFlag) == 0) :
1041                  ((parseFlags & kParseFullPrecisionFlag) != 0),
1042              (parseFlags & kParseNumbersAsStringsFlag) != 0 &&
1043                  (parseFlags & kParseInsituFlag) == 0> s(*this, copy.s);
1044          size_t startOffset = s.Tell();
1045          double d = 0.0;
1046          bool useNanOrInf = false;
1047          bool minus = Consume(s, '-');
1048          unsigned i = 0;
1049          uint64_t i64 = 0;
1050          bool use64bit = false;
1051          int significandDigit = 0;
1052          if (RAPIDJSON_UNLIKELY(s.Peek() == '0')) {
1053              i = 0;
1054              s.TakePush();
1055          }
1056          else if (RAPIDJSON_LIKELY(s.Peek() >= '1' && s.Peek() <= '9')) {
1057              i = static_cast<unsigned>(s.TakePush() - '0');
1058              if (minus)
1059                  while (RAPIDJSON_LIKELY(s.Peek() >= '0' && s.Peek() <= '9')) {
1060                      if (RAPIDJSON_UNLIKELY(i >= 214748364)) { 
1061                          if (RAPIDJSON_LIKELY(i != 214748364 || s.Peek() > '8')) {
1062                              i64 = i;
1063                              use64bit = true;
1064                              break;
1065                          }
1066                      }
1067                      i = i * 10 + static_cast<unsigned>(s.TakePush() - '0');
1068                      significandDigit++;
1069                  }
1070              else
1071                  while (RAPIDJSON_LIKELY(s.Peek() >= '0' && s.Peek() <= '9')) {
1072                      if (RAPIDJSON_UNLIKELY(i >= 429496729)) { 
1073                          if (RAPIDJSON_LIKELY(i != 429496729 || s.Peek() > '5')) {
1074                              i64 = i;
1075                              use64bit = true;
1076                              break;
1077                          }
1078                      }
1079                      i = i * 10 + static_cast<unsigned>(s.TakePush() - '0');
1080                      significandDigit++;
1081                  }
1082          }
1083          else if ((parseFlags & kParseNanAndInfFlag) && RAPIDJSON_LIKELY((s.Peek() == 'I' || s.Peek() == 'N'))) {
1084              if (Consume(s, 'N')) {
1085                  if (Consume(s, 'a') && Consume(s, 'N')) {
1086                      d = std::numeric_limits<double>::quiet_NaN();
1087                      useNanOrInf = true;
1088                  }
1089              }
1090              else if (RAPIDJSON_LIKELY(Consume(s, 'I'))) {
1091                  if (Consume(s, 'n') && Consume(s, 'f')) {
1092                      d = (minus ? -std::numeric_limits<double>::infinity() : std::numeric_limits<double>::infinity());
1093                      useNanOrInf = true;
1094                      if (RAPIDJSON_UNLIKELY(s.Peek() == 'i' && !(Consume(s, 'i') && Consume(s, 'n')
1095                                                                  && Consume(s, 'i') && Consume(s, 't') && Consume(s, 'y')))) {
1096                          RAPIDJSON_PARSE_ERROR(kParseErrorValueInvalid, s.Tell());
1097                      }
1098                  }
1099              }
1100              if (RAPIDJSON_UNLIKELY(!useNanOrInf)) {
1101                  RAPIDJSON_PARSE_ERROR(kParseErrorValueInvalid, s.Tell());
1102              }
1103          }
1104          else
1105              RAPIDJSON_PARSE_ERROR(kParseErrorValueInvalid, s.Tell());
1106          bool useDouble = false;
1107          if (use64bit) {
1108              if (minus)
1109                  while (RAPIDJSON_LIKELY(s.Peek() >= '0' && s.Peek() <= '9')) {
1110                       if (RAPIDJSON_UNLIKELY(i64 >= RAPIDJSON_UINT64_C2(0x0CCCCCCC, 0xCCCCCCCC))) 
1111                          if (RAPIDJSON_LIKELY(i64 != RAPIDJSON_UINT64_C2(0x0CCCCCCC, 0xCCCCCCCC) || s.Peek() > '8')) {
1112                              d = static_cast<double>(i64);
1113                              useDouble = true;
1114                              break;
1115                          }
1116                      i64 = i64 * 10 + static_cast<unsigned>(s.TakePush() - '0');
1117                      significandDigit++;
1118                  }
1119              else
1120                  while (RAPIDJSON_LIKELY(s.Peek() >= '0' && s.Peek() <= '9')) {
1121                      if (RAPIDJSON_UNLIKELY(i64 >= RAPIDJSON_UINT64_C2(0x19999999, 0x99999999))) 
1122                          if (RAPIDJSON_LIKELY(i64 != RAPIDJSON_UINT64_C2(0x19999999, 0x99999999) || s.Peek() > '5')) {
1123                              d = static_cast<double>(i64);
1124                              useDouble = true;
1125                              break;
1126                          }
1127                      i64 = i64 * 10 + static_cast<unsigned>(s.TakePush() - '0');
1128                      significandDigit++;
1129                  }
1130          }
1131          if (useDouble) {
1132              while (RAPIDJSON_LIKELY(s.Peek() >= '0' && s.Peek() <= '9')) {
1133                  d = d * 10 + (s.TakePush() - '0');
1134              }
1135          }
1136          int expFrac = 0;
1137          size_t decimalPosition;
1138          if (Consume(s, '.')) {
1139              decimalPosition = s.Length();
1140              if (RAPIDJSON_UNLIKELY(!(s.Peek() >= '0' && s.Peek() <= '9')))
1141                  RAPIDJSON_PARSE_ERROR(kParseErrorNumberMissFraction, s.Tell());
1142              if (!useDouble) {
1143  #if RAPIDJSON_64BIT
1144                  if (!use64bit)
1145                      i64 = i;
1146                  while (RAPIDJSON_LIKELY(s.Peek() >= '0' && s.Peek() <= '9')) {
1147                      if (i64 > RAPIDJSON_UINT64_C2(0x1FFFFF, 0xFFFFFFFF)) 
1148                          break;
1149                      else {
1150                          i64 = i64 * 10 + static_cast<unsigned>(s.TakePush() - '0');
1151                          --expFrac;
1152                          if (i64 != 0)
1153                              significandDigit++;
1154                      }
1155                  }
1156                  d = static_cast<double>(i64);
1157  #else
1158                  d = static_cast<double>(use64bit ? i64 : i);
1159  #endif
1160                  useDouble = true;
1161              }
1162              while (RAPIDJSON_LIKELY(s.Peek() >= '0' && s.Peek() <= '9')) {
1163                  if (significandDigit < 17) {
1164                      d = d * 10.0 + (s.TakePush() - '0');
1165                      --expFrac;
1166                      if (RAPIDJSON_LIKELY(d > 0.0))
1167                          significandDigit++;
1168                  }
1169                  else
1170                      s.TakePush();
1171              }
1172          }
1173          else
1174              decimalPosition = s.Length(); 
1175          int exp = 0;
1176          if (Consume(s, 'e') || Consume(s, 'E')) {
1177              if (!useDouble) {
1178                  d = static_cast<double>(use64bit ? i64 : i);
1179                  useDouble = true;
1180              }
1181              bool expMinus = false;
1182              if (Consume(s, '+'))
1183                  ;
1184              else if (Consume(s, '-'))
1185                  expMinus = true;
1186              if (RAPIDJSON_LIKELY(s.Peek() >= '0' && s.Peek() <= '9')) {
1187                  exp = static_cast<int>(s.Take() - '0');
1188                  if (expMinus) {
1189                      RAPIDJSON_ASSERT(expFrac <= 0);
1190                      int maxExp = (expFrac + 2147483639) / 10;
1191                      while (RAPIDJSON_LIKELY(s.Peek() >= '0' && s.Peek() <= '9')) {
1192                          exp = exp * 10 + static_cast<int>(s.Take() - '0');
1193                          if (RAPIDJSON_UNLIKELY(exp > maxExp)) {
1194                              while (RAPIDJSON_UNLIKELY(s.Peek() >= '0' && s.Peek() <= '9'))  
1195                                  s.Take();
1196                          }
1197                      }
1198                  }
1199                  else {  
1200                      int maxExp = 308 - expFrac;
1201                      while (RAPIDJSON_LIKELY(s.Peek() >= '0' && s.Peek() <= '9')) {
1202                          exp = exp * 10 + static_cast<int>(s.Take() - '0');
1203                          if (RAPIDJSON_UNLIKELY(exp > maxExp))
1204                              RAPIDJSON_PARSE_ERROR(kParseErrorNumberTooBig, startOffset);
1205                      }
1206                  }
1207              }
1208              else
1209                  RAPIDJSON_PARSE_ERROR(kParseErrorNumberMissExponent, s.Tell());
1210              if (expMinus)
1211                  exp = -exp;
1212          }
1213          bool cont = true;
1214          if (parseFlags & kParseNumbersAsStringsFlag) {
1215              if (parseFlags & kParseInsituFlag) {
1216                  s.Pop();  
1217                  typename InputStream::Ch* head = is.PutBegin();
1218                  const size_t length = s.Tell() - startOffset;
1219                  RAPIDJSON_ASSERT(length <= 0xFFFFFFFF);
1220                  const typename TargetEncoding::Ch* const str = reinterpret_cast<typename TargetEncoding::Ch*>(head);
1221                  cont = handler.RawNumber(str, SizeType(length), false);
1222              }
1223              else {
1224                  SizeType numCharsToCopy = static_cast<SizeType>(s.Length());
1225                  GenericStringStream<UTF8<NumberCharacter>> srcStream(s.Pop());
1226                  StackStream<typename TargetEncoding::Ch> dstStream(stack_);
1227                  while (numCharsToCopy--) {
1228                      Transcoder<UTF8<typename TargetEncoding::Ch>, TargetEncoding>::Transcode(srcStream, dstStream);
1229                  }
1230                  dstStream.Put('\0');
1231                  const typename TargetEncoding::Ch* str = dstStream.Pop();
1232                  const SizeType length = static_cast<SizeType>(dstStream.Length()) - 1;
1233                  cont = handler.RawNumber(str, SizeType(length), true);
1234              }
1235          }
1236          else {
1237             size_t length = s.Length();
1238             const NumberCharacter* decimal = s.Pop();  
1239             if (useDouble) {
1240                 int p = exp + expFrac;
1241                 if (parseFlags & kParseFullPrecisionFlag)
1242                     d = internal::StrtodFullPrecision(d, p, decimal, length, decimalPosition, exp);
1243                 else
1244                     d = internal::StrtodNormalPrecision(d, p);
1245                 if (d > (std::numeric_limits<double>::max)()) {
1246                     RAPIDJSON_PARSE_ERROR(kParseErrorNumberTooBig, startOffset);
1247                 }
1248                 cont = handler.Double(minus ? -d : d);
1249             }
1250             else if (useNanOrInf) {
1251                 cont = handler.Double(d);
1252             }
1253             else {
1254                 if (use64bit) {
1255                     if (minus)
1256                         cont = handler.Int64(static_cast<int64_t>(~i64 + 1));
1257                     else
1258                         cont = handler.Uint64(i64);
1259                 }
1260                 else {
1261                     if (minus)
1262                         cont = handler.Int(static_cast<int32_t>(~i + 1));
1263                     else
1264                         cont = handler.Uint(i);
1265                 }
1266             }
1267          }
1268          if (RAPIDJSON_UNLIKELY(!cont))
1269              RAPIDJSON_PARSE_ERROR(kParseErrorTermination, startOffset);
1270      }
1271      template<unsigned parseFlags, typename InputStream, typename Handler>
1272      void ParseValue(InputStream& is, Handler& handler) {
1273          switch (is.Peek()) {
1274              case 'n': ParseNull  <parseFlags>(is, handler); break;
1275              case 't': ParseTrue  <parseFlags>(is, handler); break;
1276              case 'f': ParseFalse <parseFlags>(is, handler); break;
1277              case '"': ParseString<parseFlags>(is, handler); break;
1278              case '{': ParseObject<parseFlags>(is, handler); break;
1279              case '[': ParseArray <parseFlags>(is, handler); break;
1280              default :
1281                        ParseNumber<parseFlags>(is, handler);
1282                        break;
1283          }
1284      }
1285      enum IterativeParsingState {
1286          IterativeParsingFinishState = 0, 
1287          IterativeParsingErrorState,      
1288          IterativeParsingStartState,
1289          IterativeParsingObjectInitialState,
1290          IterativeParsingMemberKeyState,
1291          IterativeParsingMemberValueState,
1292          IterativeParsingObjectFinishState,
1293          IterativeParsingArrayInitialState,
1294          IterativeParsingElementState,
1295          IterativeParsingArrayFinishState,
1296          IterativeParsingValueState,
1297          IterativeParsingElementDelimiterState,
1298          IterativeParsingMemberDelimiterState,
1299          IterativeParsingKeyValueDelimiterState,
1300          cIterativeParsingStateCount
1301      };
1302      enum Token {
1303          LeftBracketToken = 0,
1304          RightBracketToken,
1305          LeftCurlyBracketToken,
1306          RightCurlyBracketToken,
1307          CommaToken,
1308          ColonToken,
1309          StringToken,
1310          FalseToken,
1311          TrueToken,
1312          NullToken,
1313          NumberToken,
1314          kTokenCount
1315      };
1316      RAPIDJSON_FORCEINLINE Token Tokenize(Ch c) const {
1317  #define N NumberToken
1318  #define N16 N,N,N,N,N,N,N,N,N,N,N,N,N,N,N,N
1319          static const unsigned char tokenMap[256] = {
1320              N16, 
1321              N16, 
1322              N, N, StringToken, N, N, N, N, N, N, N, N, N, CommaToken, N, N, N, 
1323              N, N, N, N, N, N, N, N, N, N, ColonToken, N, N, N, N, N, 
1324              N16, 
1325              N, N, N, N, N, N, N, N, N, N, N, LeftBracketToken, N, RightBracketToken, N, N, 
1326              N, N, N, N, N, N, FalseToken, N, N, N, N, N, N, N, NullToken, N, 
1327              N, N, N, N, TrueToken, N, N, N, N, N, N, LeftCurlyBracketToken, N, RightCurlyBracketToken, N, N, 
1328              N16, N16, N16, N16, N16, N16, N16, N16 
1329          };
1330  #undef N
1331  #undef N16
1332          if (sizeof(Ch) == 1 || static_cast<unsigned>(c) < 256)
1333              return static_cast<Token>(tokenMap[static_cast<unsigned char>(c)]);
1334          else
1335              return NumberToken;
1336      }
1337      RAPIDJSON_FORCEINLINE IterativeParsingState Predict(IterativeParsingState state, Token token) const {
<span onclick='openModal()' class='match'>1338          static const char G[cIterativeParsingStateCount][kTokenCount] = {
1339              {
1340                  IterativeParsingErrorState, IterativeParsingErrorState, IterativeParsingErrorState, IterativeParsingErrorState, IterativeParsingErrorState,
1341                  IterativeParsingErrorState, IterativeParsingErrorState, IterativeParsingErrorState, IterativeParsingErrorState, IterativeParsingErrorState,
1342                  IterativeParsingErrorState
1343              },
1344              {
1345                  IterativeParsingErrorState, IterativeParsingErrorState, IterativeParsingErrorState, IterativeParsingErrorState, IterativeParsingErrorState,
1346                  IterativeParsingErrorState, IterativeParsingErrorState, IterativeParsingErrorState, IterativeParsingErrorState, IterativeParsingErrorState,
1347                  IterativeParsingErrorState
1348              },
1349              {
1350                  IterativeParsingArrayInitialState,  
1351                  IterativeParsingErrorState,         
1352                  IterativeParsingObjectInitialState, 
1353                  IterativeParsingErrorState,         
1354                  IterativeParsingErrorState,         
1355                  IterativeParsingErrorState,         
1356                  IterativeParsingValueState,         
1357                  IterativeParsingValueState,         
1358                  IterativeParsingValueState,         
1359                  IterativeParsingValueState,         
1360                  IterativeParsingValueState          
1361              },
</span>1362              {
1363                  IterativeParsingErrorState,         
1364                  IterativeParsingErrorState,         
1365                  IterativeParsingErrorState,         
1366                  IterativeParsingObjectFinishState,  
1367                  IterativeParsingErrorState,         
1368                  IterativeParsingErrorState,         
1369                  IterativeParsingMemberKeyState,     
1370                  IterativeParsingErrorState,         
1371                  IterativeParsingErrorState,         
1372                  IterativeParsingErrorState,         
1373                  IterativeParsingErrorState          
1374              },
1375              {
1376                  IterativeParsingErrorState,             
1377                  IterativeParsingErrorState,             
1378                  IterativeParsingErrorState,             
1379                  IterativeParsingErrorState,             
1380                  IterativeParsingErrorState,             
1381                  IterativeParsingKeyValueDelimiterState, 
1382                  IterativeParsingErrorState,             
1383                  IterativeParsingErrorState,             
1384                  IterativeParsingErrorState,             
1385                  IterativeParsingErrorState,             
1386                  IterativeParsingErrorState              
1387              },
1388              {
1389                  IterativeParsingErrorState,             
1390                  IterativeParsingErrorState,             
1391                  IterativeParsingErrorState,             
1392                  IterativeParsingObjectFinishState,      
1393                  IterativeParsingMemberDelimiterState,   
1394                  IterativeParsingErrorState,             
1395                  IterativeParsingErrorState,             
1396                  IterativeParsingErrorState,             
1397                  IterativeParsingErrorState,             
1398                  IterativeParsingErrorState,             
1399                  IterativeParsingErrorState              
1400              },
1401              {
1402                  IterativeParsingErrorState, IterativeParsingErrorState, IterativeParsingErrorState, IterativeParsingErrorState, IterativeParsingErrorState,
1403                  IterativeParsingErrorState, IterativeParsingErrorState, IterativeParsingErrorState, IterativeParsingErrorState, IterativeParsingErrorState,
1404                  IterativeParsingErrorState
1405              },
1406              {
1407                  IterativeParsingArrayInitialState,      
1408                  IterativeParsingArrayFinishState,       
1409                  IterativeParsingObjectInitialState,     
1410                  IterativeParsingErrorState,             
1411                  IterativeParsingErrorState,             
1412                  IterativeParsingErrorState,             
1413                  IterativeParsingElementState,           
1414                  IterativeParsingElementState,           
1415                  IterativeParsingElementState,           
1416                  IterativeParsingElementState,           
1417                  IterativeParsingElementState            
1418              },
1419              {
1420                  IterativeParsingErrorState,             
1421                  IterativeParsingArrayFinishState,       
1422                  IterativeParsingErrorState,             
1423                  IterativeParsingErrorState,             
1424                  IterativeParsingElementDelimiterState,  
1425                  IterativeParsingErrorState,             
1426                  IterativeParsingErrorState,             
1427                  IterativeParsingErrorState,             
1428                  IterativeParsingErrorState,             
1429                  IterativeParsingErrorState,             
1430                  IterativeParsingErrorState              
1431              },
1432              {
1433                  IterativeParsingErrorState, IterativeParsingErrorState, IterativeParsingErrorState, IterativeParsingErrorState, IterativeParsingErrorState,
1434                  IterativeParsingErrorState, IterativeParsingErrorState, IterativeParsingErrorState, IterativeParsingErrorState, IterativeParsingErrorState,
1435                  IterativeParsingErrorState
1436              },
1437              {
1438                  IterativeParsingErrorState, IterativeParsingErrorState, IterativeParsingErrorState, IterativeParsingErrorState, IterativeParsingErrorState,
1439                  IterativeParsingErrorState, IterativeParsingErrorState, IterativeParsingErrorState, IterativeParsingErrorState, IterativeParsingErrorState,
1440                  IterativeParsingErrorState
1441              },
1442              {
1443                  IterativeParsingArrayInitialState,      
1444                  IterativeParsingArrayFinishState,       
1445                  IterativeParsingObjectInitialState,     
1446                  IterativeParsingErrorState,             
1447                  IterativeParsingErrorState,             
1448                  IterativeParsingErrorState,             
1449                  IterativeParsingElementState,           
1450                  IterativeParsingElementState,           
1451                  IterativeParsingElementState,           
1452                  IterativeParsingElementState,           
1453                  IterativeParsingElementState            
1454              },
1455              {
1456                  IterativeParsingErrorState,         
1457                  IterativeParsingErrorState,         
1458                  IterativeParsingErrorState,         
1459                  IterativeParsingObjectFinishState,  
1460                  IterativeParsingErrorState,         
1461                  IterativeParsingErrorState,         
1462                  IterativeParsingMemberKeyState,     
1463                  IterativeParsingErrorState,         
1464                  IterativeParsingErrorState,         
1465                  IterativeParsingErrorState,         
1466                  IterativeParsingErrorState          
1467              },
1468              {
1469                  IterativeParsingArrayInitialState,      
1470                  IterativeParsingErrorState,             
1471                  IterativeParsingObjectInitialState,     
1472                  IterativeParsingErrorState,             
1473                  IterativeParsingErrorState,             
1474                  IterativeParsingErrorState,             
1475                  IterativeParsingMemberValueState,       
1476                  IterativeParsingMemberValueState,       
1477                  IterativeParsingMemberValueState,       
1478                  IterativeParsingMemberValueState,       
1479                  IterativeParsingMemberValueState        
1480              },
1481          }; 
1482          return static_cast<IterativeParsingState>(G[state][token]);
1483      }
1484      template <unsigned parseFlags, typename InputStream, typename Handler>
1485      RAPIDJSON_FORCEINLINE IterativeParsingState Transit(IterativeParsingState src, Token token, IterativeParsingState dst, InputStream& is, Handler& handler) {
1486          (void)token;
1487          switch (dst) {
1488          case IterativeParsingErrorState:
1489              return dst;
1490          case IterativeParsingObjectInitialState:
1491          case IterativeParsingArrayInitialState:
1492          {
1493              IterativeParsingState n = src;
1494              if (src == IterativeParsingArrayInitialState || src == IterativeParsingElementDelimiterState)
1495                  n = IterativeParsingElementState;
1496              else if (src == IterativeParsingKeyValueDelimiterState)
1497                  n = IterativeParsingMemberValueState;
1498              *stack_.template Push<SizeType>(1) = n;
1499              *stack_.template Push<SizeType>(1) = 0;
1500              bool hr = (dst == IterativeParsingObjectInitialState) ? handler.StartObject() : handler.StartArray();
1501              if (!hr) {
1502                  RAPIDJSON_PARSE_ERROR_NORETURN(kParseErrorTermination, is.Tell());
1503                  return IterativeParsingErrorState;
1504              }
1505              else {
1506                  is.Take();
1507                  return dst;
1508              }
1509          }
1510          case IterativeParsingMemberKeyState:
1511              ParseString<parseFlags>(is, handler, true);
1512              if (HasParseError())
1513                  return IterativeParsingErrorState;
1514              else
1515                  return dst;
1516          case IterativeParsingKeyValueDelimiterState:
1517              RAPIDJSON_ASSERT(token == ColonToken);
1518              is.Take();
1519              return dst;
1520          case IterativeParsingMemberValueState:
1521              ParseValue<parseFlags>(is, handler);
1522              if (HasParseError()) {
1523                  return IterativeParsingErrorState;
1524              }
1525              return dst;
1526          case IterativeParsingElementState:
1527              ParseValue<parseFlags>(is, handler);
1528              if (HasParseError()) {
1529                  return IterativeParsingErrorState;
1530              }
1531              return dst;
1532          case IterativeParsingMemberDelimiterState:
1533          case IterativeParsingElementDelimiterState:
1534              is.Take();
1535              *stack_.template Top<SizeType>() = *stack_.template Top<SizeType>() + 1;
1536              return dst;
1537          case IterativeParsingObjectFinishState:
1538          {
1539              if (!(parseFlags & kParseTrailingCommasFlag) && src == IterativeParsingMemberDelimiterState) {
1540                  RAPIDJSON_PARSE_ERROR_NORETURN(kParseErrorObjectMissName, is.Tell());
1541                  return IterativeParsingErrorState;
1542              }
1543              SizeType c = *stack_.template Pop<SizeType>(1);
1544              if (src == IterativeParsingMemberValueState)
1545                  ++c;
1546              IterativeParsingState n = static_cast<IterativeParsingState>(*stack_.template Pop<SizeType>(1));
1547              if (n == IterativeParsingStartState)
1548                  n = IterativeParsingFinishState;
1549              bool hr = handler.EndObject(c);
1550              if (!hr) {
1551                  RAPIDJSON_PARSE_ERROR_NORETURN(kParseErrorTermination, is.Tell());
1552                  return IterativeParsingErrorState;
1553              }
1554              else {
1555                  is.Take();
1556                  return n;
1557              }
1558          }
1559          case IterativeParsingArrayFinishState:
1560          {
1561              if (!(parseFlags & kParseTrailingCommasFlag) && src == IterativeParsingElementDelimiterState) {
1562                  RAPIDJSON_PARSE_ERROR_NORETURN(kParseErrorValueInvalid, is.Tell());
1563                  return IterativeParsingErrorState;
1564              }
1565              SizeType c = *stack_.template Pop<SizeType>(1);
1566              if (src == IterativeParsingElementState)
1567                  ++c;
1568              IterativeParsingState n = static_cast<IterativeParsingState>(*stack_.template Pop<SizeType>(1));
1569              if (n == IterativeParsingStartState)
1570                  n = IterativeParsingFinishState;
1571              bool hr = handler.EndArray(c);
1572              if (!hr) {
1573                  RAPIDJSON_PARSE_ERROR_NORETURN(kParseErrorTermination, is.Tell());
1574                  return IterativeParsingErrorState;
1575              }
1576              else {
1577                  is.Take();
1578                  return n;
1579              }
1580          }
1581          default:
1582              RAPIDJSON_ASSERT(dst == IterativeParsingValueState);
1583              ParseValue<parseFlags>(is, handler);
1584              if (HasParseError()) {
1585                  return IterativeParsingErrorState;
1586              }
1587              return IterativeParsingFinishState;
1588          }
1589      }
1590      template <typename InputStream>
1591      void HandleError(IterativeParsingState src, InputStream& is) {
1592          if (HasParseError()) {
1593              return;
1594          }
1595          switch (src) {
1596          case IterativeParsingStartState:            RAPIDJSON_PARSE_ERROR(kParseErrorDocumentEmpty, is.Tell()); return;
1597          case IterativeParsingFinishState:           RAPIDJSON_PARSE_ERROR(kParseErrorDocumentRootNotSingular, is.Tell()); return;
1598          case IterativeParsingObjectInitialState:
1599          case IterativeParsingMemberDelimiterState:  RAPIDJSON_PARSE_ERROR(kParseErrorObjectMissName, is.Tell()); return;
1600          case IterativeParsingMemberKeyState:        RAPIDJSON_PARSE_ERROR(kParseErrorObjectMissColon, is.Tell()); return;
1601          case IterativeParsingMemberValueState:      RAPIDJSON_PARSE_ERROR(kParseErrorObjectMissCommaOrCurlyBracket, is.Tell()); return;
1602          case IterativeParsingKeyValueDelimiterState:
1603          case IterativeParsingArrayInitialState:
1604          case IterativeParsingElementDelimiterState: RAPIDJSON_PARSE_ERROR(kParseErrorValueInvalid, is.Tell()); return;
1605          default: RAPIDJSON_ASSERT(src == IterativeParsingElementState); RAPIDJSON_PARSE_ERROR(kParseErrorArrayMissCommaOrSquareBracket, is.Tell()); return;
1606          }
1607      }
1608      RAPIDJSON_FORCEINLINE bool IsIterativeParsingDelimiterState(IterativeParsingState s) const {
1609          return s >= IterativeParsingElementDelimiterState;
1610      }
1611      RAPIDJSON_FORCEINLINE bool IsIterativeParsingCompleteState(IterativeParsingState s) const {
1612          return s <= IterativeParsingErrorState;
1613      }
1614      template <unsigned parseFlags, typename InputStream, typename Handler>
1615      ParseResult IterativeParse(InputStream& is, Handler& handler) {
1616          parseResult_.Clear();
1617          ClearStackOnExit scope(*this);
1618          IterativeParsingState state = IterativeParsingStartState;
1619          SkipWhitespaceAndComments<parseFlags>(is);
1620          RAPIDJSON_PARSE_ERROR_EARLY_RETURN(parseResult_);
1621          while (is.Peek() != '\0') {
1622              Token t = Tokenize(is.Peek());
1623              IterativeParsingState n = Predict(state, t);
1624              IterativeParsingState d = Transit<parseFlags>(state, t, n, is, handler);
1625              if (d == IterativeParsingErrorState) {
1626                  HandleError(state, is);
1627                  break;
1628              }
1629              state = d;
1630              if ((parseFlags & kParseStopWhenDoneFlag) && state == IterativeParsingFinishState)
1631                  break;
1632              SkipWhitespaceAndComments<parseFlags>(is);
1633              RAPIDJSON_PARSE_ERROR_EARLY_RETURN(parseResult_);
1634          }
1635          if (state != IterativeParsingFinishState)
1636              HandleError(state, is);
1637          return parseResult_;
1638      }
1639      static const size_t kDefaultStackCapacity = 256;    
1640      internal::Stack<StackAllocator> stack_;  
1641      ParseResult parseResult_;
1642      IterativeParsingState state_;
1643  }; 
1644  typedef GenericReader<UTF8<>, UTF8<> > Reader;
1645  RAPIDJSON_NAMESPACE_END
1646  #if defined(__clang__) || defined(_MSC_VER)
1647  RAPIDJSON_DIAG_POP
1648  #endif
1649  #ifdef __GNUC__
1650  RAPIDJSON_DIAG_POP
1651  #endif
1652  #endif 
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from fftw3-MDEwOlJlcG9zaXRvcnk4ODQzMzg4-flat-redft00e-r2hc.c</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from xmrig-MDEwOlJlcG9zaXRvcnk4ODMyNzQwNg==-flat-reader.h</div>
                </div>
                <div class="column column_space"><pre><code>61       static const tw_instr redft00e_tw[] = {
62            { TW_COS, 0, 1 },
63            { TW_SIN, 0, 1 },
64            { TW_NEXT, 1, 0 }
</pre></code></div>
                <div class="column column_space"><pre><code>1338          static const char G[cIterativeParsingStateCount][kTokenCount] = {
1339              {
1340                  IterativeParsingErrorState, IterativeParsingErrorState, IterativeParsingErrorState, IterativeParsingErrorState, IterativeParsingErrorState,
1341                  IterativeParsingErrorState, IterativeParsingErrorState, IterativeParsingErrorState, IterativeParsingErrorState, IterativeParsingErrorState,
1342                  IterativeParsingErrorState
1343              },
1344              {
1345                  IterativeParsingErrorState, IterativeParsingErrorState, IterativeParsingErrorState, IterativeParsingErrorState, IterativeParsingErrorState,
1346                  IterativeParsingErrorState, IterativeParsingErrorState, IterativeParsingErrorState, IterativeParsingErrorState, IterativeParsingErrorState,
1347                  IterativeParsingErrorState
1348              },
1349              {
1350                  IterativeParsingArrayInitialState,  
1351                  IterativeParsingErrorState,         
1352                  IterativeParsingObjectInitialState, 
1353                  IterativeParsingErrorState,         
1354                  IterativeParsingErrorState,         
1355                  IterativeParsingErrorState,         
1356                  IterativeParsingValueState,         
1357                  IterativeParsingValueState,         
1358                  IterativeParsingValueState,         
1359                  IterativeParsingValueState,         
1360                  IterativeParsingValueState          
1361              },
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    