
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 16, <button onclick='openModal()' class='match'>CODE CLONE</button></h2>
        <div class="column">
            <h3>libfuse-MDEwOlJlcG9zaXRvcnk0ODI5NjE3Nw==-flat-test_syscalls.c</h3>
            <pre><code>1  #define _GNU_SOURCE
2  #include &quot;fuse_config.h&quot;
3  #include &lt;stdio.h&gt;
4  #include &lt;stdlib.h&gt;
5  #include &lt;stdarg.h&gt;
6  #include &lt;string.h&gt;
7  #include &lt;unistd.h&gt;
8  #include &lt;fcntl.h&gt;
9  #include &lt;dirent.h&gt;
10  #include &lt;utime.h&gt;
11  #include &lt;errno.h&gt;
12  #include &lt;assert.h&gt;
13  #include &lt;sys/socket.h&gt;
14  #include &lt;sys/types.h&gt;
15  #include &lt;sys/stat.h&gt;
16  #include &lt;sys/un.h&gt;
17  #ifndef ALLPERMS
18  # define ALLPERMS (S_ISUID|S_ISGID|S_ISVTX|S_IRWXU|S_IRWXG|S_IRWXO)&amp;bsol;* 07777 */
19  #endif
20  static const char *basepath;
21  static const char *basepath_r;
22  static char testfile[1024];
23  static char testfile2[1024];
24  static char testdir[1024];
25  static char testdir2[1024];
26  static char testsock[1024];
27  static char subfile[1280];
28  static char testfile_r[1024];
29  static char testfile2_r[1024];
30  static char testdir_r[1024];
31  static char testdir2_r[1024];
32  static char subfile_r[1280];
33  static char testname[256];
34  static char testdata[] = &quot;abcdefghijklmnopqrstuvwxyz&quot;;
35  static char testdata2[] = &quot;1234567890-=qwertyuiop[]\asdfghjkl;&#x27;zxcvbnm,./&quot;;
36  static const char *testdir_files[] = { &quot;f1&quot;, &quot;f2&quot;, NULL};
37  static long seekdir_offsets[4];
38  static char zerodata[4096];
39  static int testdatalen = sizeof(testdata) - 1;
40  static int testdata2len = sizeof(testdata2) - 1;
41  static unsigned int testnum = 0;
42  static unsigned int select_test = 0;
43  static unsigned int skip_test = 0;
44  static unsigned int unlinked_test = 0;
45  #define MAX_ENTRIES 1024
46  #define MAX_TESTS 100
47  static struct test {
48  	int fd;
49  	struct stat stat;
50  } tests[MAX_TESTS];
51  static void test_perror(const char *func, const char *msg)
52  {
53  	fprintf(stderr, &quot;%s %s() - %s: %s\n&quot;, testname, func, msg,
54  		strerror(errno));
55  }
56  static void test_error(const char *func, const char *msg, ...)
57  	__attribute__ ((format (printf, 2, 3)));
58  static void __start_test(const char *fmt, ...)
59  	__attribute__ ((format (printf, 1, 2)));
60  static void test_error(const char *func, const char *msg, ...)
61  {
62  	va_list ap;
63  	fprintf(stderr, &quot;%s %s() - &quot;, testname, func);
64  	va_start(ap, msg);
65  	vfprintf(stderr, msg, ap);
66  	va_end(ap);
67  	fprintf(stderr, &quot;\n&quot;);
68  }
69  static int is_dot_or_dotdot(const char *name) {
70      return name[0] == &#x27;.&#x27; &amp;&amp;
71             (name[1] == &#x27;\0&#x27; || (name[1] == &#x27;.&#x27; &amp;&amp; name[2] == &#x27;\0&#x27;));
72  }
73  static void success(void)
74  {
75  	fprintf(stderr, &quot;%s OK\n&quot;, testname);
76  }
77  #define this_test (&amp;tests[testnum-1])
78  #define next_test (&amp;tests[testnum])
79  static void __start_test(const char *fmt, ...)
80  {
81  	unsigned int n;
82  	va_list ap;
83  	n = sprintf(testname, &quot;%3i [&quot;, testnum);
84  	va_start(ap, fmt);
85  	n += vsprintf(testname + n, fmt, ap);
86  	va_end(ap);
87  	sprintf(testname + n, &quot;]&quot;);
88  	sprintf(testfile, &quot;%s/testfile.%d&quot;, basepath, testnum);
89  	sprintf(testfile_r, &quot;%s/testfile.%d&quot;, basepath_r, testnum);
90  	if (testnum &gt; MAX_TESTS) {
91  		fprintf(stderr, &quot;%s - too many tests\n&quot;, testname);
92  		exit(1);
93  	}
94  	this_test-&gt;fd = -1;
95  }
96  #define start_test(msg, args...) { \
97  	testnum++; \
98  	if ((select_test &amp;&amp; testnum != select_test) || \
99  	    (testnum == skip_test)) { \
100  		return 0; \
101  	} \
102  	__start_test(msg, ##args);		\
103  }
104  #define PERROR(msg) test_perror(__FUNCTION__, msg)
105  #define ERROR(msg, args...) test_error(__FUNCTION__, msg, ##args)
106  #define ARRAY_SIZE(arr) (sizeof(arr) / sizeof((arr)[0]))
107  static int st_check_size(struct stat *st, int len)
108  {
109  	if (st-&gt;st_size != len) {
110  		ERROR(&quot;length %u instead of %u&quot;, (int) st-&gt;st_size,
111  		      (int) len);
112  		return -1;
113  	}
114  	return 0;
115  }
116  static int check_size(const char *path, int len)
117  {
118  	struct stat stbuf;
119  	int res = stat(path, &amp;stbuf);
120  	if (res == -1) {
121  		PERROR(&quot;stat&quot;);
122  		return -1;
123  	}
124  	return st_check_size(&amp;stbuf, len);
125  }
126  static int check_testfile_size(const char *path, int len)
127  {
128  	this_test-&gt;stat.st_size = len;
129  	return check_size(path, len);
130  }
131  static int st_check_type(struct stat *st, mode_t type)
132  {
133  	if ((st-&gt;st_mode &amp; S_IFMT) != type) {
134  		ERROR(&quot;type 0%o instead of 0%o&quot;, st-&gt;st_mode &amp; S_IFMT, type);
135  		return -1;
136  	}
137  	return 0;
138  }
139  static int check_type(const char *path, mode_t type)
140  {
141  	struct stat stbuf;
142  	int res = lstat(path, &amp;stbuf);
143  	if (res == -1) {
144  		PERROR(&quot;lstat&quot;);
145  		return -1;
146  	}
147  	return st_check_type(&amp;stbuf, type);
148  }
149  static int st_check_mode(struct stat *st, mode_t mode)
150  {
151  	if ((st-&gt;st_mode &amp; ALLPERMS) != mode) {
152  		ERROR(&quot;mode 0%o instead of 0%o&quot;, st-&gt;st_mode &amp; ALLPERMS,
153  		      mode);
154  		return -1;
155  	}
156  	return 0;
157  }
158  static int check_mode(const char *path, mode_t mode)
159  {
160  	struct stat stbuf;
161  	int res = lstat(path, &amp;stbuf);
162  	if (res == -1) {
163  		PERROR(&quot;lstat&quot;);
164  		return -1;
165  	}
166  	return st_check_mode(&amp;stbuf, mode);
167  }
168  static int check_testfile_mode(const char *path, mode_t mode)
169  {
170  	this_test-&gt;stat.st_mode &amp;= ~ALLPERMS;
171  	this_test-&gt;stat.st_mode |= mode;
172  	return check_mode(path, mode);
173  }
174  static int check_times(const char *path, time_t atime, time_t mtime)
175  {
176  	int err = 0;
177  	struct stat stbuf;
178  	int res = lstat(path, &amp;stbuf);
179  	if (res == -1) {
180  		PERROR(&quot;lstat&quot;);
181  		return -1;
182  	}
183  	if (stbuf.st_atime != atime) {
184  		ERROR(&quot;atime %li instead of %li&quot;, stbuf.st_atime, atime);
185  		err--;
186  	}
187  	if (stbuf.st_mtime != mtime) {
188  		ERROR(&quot;mtime %li instead of %li&quot;, stbuf.st_mtime, mtime);
189  		err--;
190  	}
191  	if (err)
192  		return -1;
193  	return 0;
194  }
195  #if 0
196  static int fcheck_times(int fd, time_t atime, time_t mtime)
197  {
198  	int err = 0;
199  	struct stat stbuf;
200  	int res = fstat(fd, &amp;stbuf);
201  	if (res == -1) {
202  		PERROR(&quot;fstat&quot;);
203  		return -1;
204  	}
205  	if (stbuf.st_atime != atime) {
206  		ERROR(&quot;atime %li instead of %li&quot;, stbuf.st_atime, atime);
207  		err--;
208  	}
209  	if (stbuf.st_mtime != mtime) {
210  		ERROR(&quot;mtime %li instead of %li&quot;, stbuf.st_mtime, mtime);
211  		err--;
212  	}
213  	if (err)
214  		return -1;
215  	return 0;
216  }
217  #endif
218  static int st_check_nlink(struct stat *st, nlink_t nlink)
219  {
220  	if (st-&gt;st_nlink != nlink) {
221  		ERROR(&quot;nlink %li instead of %li&quot;, (long) st-&gt;st_nlink,
222  		      (long) nlink);
223  		return -1;
224  	}
225  	return 0;
226  }
227  static int check_nlink(const char *path, nlink_t nlink)
228  {
229  	struct stat stbuf;
230  	int res = lstat(path, &amp;stbuf);
231  	if (res == -1) {
232  		PERROR(&quot;lstat&quot;);
233  		return -1;
234  	}
235  	return st_check_nlink(&amp;stbuf, nlink);
236  }
237  static int fcheck_stat(int fd, int flags, struct stat *st)
238  {
239  	struct stat stbuf;
240  	int res = fstat(fd, &amp;stbuf);
241  	if (res == -1) {
242  		if (flags &amp; O_PATH) {
243  			if (errno == ESTALE || errno == EIO ||
244  			    errno == ENOENT || errno == EBADF)
245  				return 0;
246  		}
247  		PERROR(&quot;fstat&quot;);
248  		return -1;
249  	}
250  	int err = 0;
251  	err += st_check_type(&amp;stbuf, st-&gt;st_mode &amp; S_IFMT);
252  	err += st_check_mode(&amp;stbuf, st-&gt;st_mode &amp; ALLPERMS);
253  	err += st_check_size(&amp;stbuf, st-&gt;st_size);
254  	err += st_check_nlink(&amp;stbuf, st-&gt;st_nlink);
255  	return err;
256  }
257  static int check_nonexist(const char *path)
258  {
259  	struct stat stbuf;
260  	int res = lstat(path, &amp;stbuf);
261  	if (res == 0) {
262  		ERROR(&quot;file should not exist&quot;);
263  		return -1;
264  	}
265  	if (errno != ENOENT) {
266  		ERROR(&quot;file should not exist: %s&quot;, strerror(errno));
267  		return -1;
268  	}
269  	return 0;
270  }
271  static int check_buffer(const char *buf, const char *data, unsigned len)
272  {
273  	if (memcmp(buf, data, len) != 0) {
274  		ERROR(&quot;data mismatch&quot;);
275  		return -1;
276  	}
277  	return 0;
278  }
279  static int check_data(const char *path, const char *data, int offset,
280  		      unsigned len)
281  {
282  	char buf[4096];
283  	int res;
284  	int fd = open(path, O_RDONLY);
285  	if (fd == -1) {
286  		PERROR(&quot;open&quot;);
287  		return -1;
288  	}
289  	if (lseek(fd, offset, SEEK_SET) == (off_t) -1) {
290  		PERROR(&quot;lseek&quot;);
291  		close(fd);
292  		return -1;
293  	}
294  	while (len) {
295  		int rdlen = len &lt; sizeof(buf) ? len : sizeof(buf);
296  		res = read(fd, buf, rdlen);
297  		if (res == -1) {
298  			PERROR(&quot;read&quot;);
299  			close(fd);
300  			return -1;
301  		}
302  		if (res != rdlen) {
303  			ERROR(&quot;short read: %u instead of %u&quot;, res, rdlen);
304  			close(fd);
305  			return -1;
306  		}
307  		if (check_buffer(buf, data, rdlen) != 0) {
308  			close(fd);
309  			return -1;
310  		}
311  		data += rdlen;
312  		len -= rdlen;
313  	}
314  	res = close(fd);
315  	if (res == -1) {
316  		PERROR(&quot;close&quot;);
317  		return -1;
318  	}
319  	return 0;
320  }
321  static int fcheck_data(int fd, const char *data, int offset,
322  		       unsigned len)
323  {
324  	char buf[4096];
325  	int res;
326  	if (lseek(fd, offset, SEEK_SET) == (off_t) -1) {
327  		PERROR(&quot;lseek&quot;);
328  		return -1;
329  	}
330  	while (len) {
331  		int rdlen = len &lt; sizeof(buf) ? len : sizeof(buf);
332  		res = read(fd, buf, rdlen);
333  		if (res == -1) {
334  			PERROR(&quot;read&quot;);
335  			return -1;
336  		}
337  		if (res != rdlen) {
338  			ERROR(&quot;short read: %u instead of %u&quot;, res, rdlen);
339  			return -1;
340  		}
341  		if (check_buffer(buf, data, rdlen) != 0) {
342  			return -1;
343  		}
344  		data += rdlen;
345  		len -= rdlen;
346  	}
347  	return 0;
348  }
349  static int check_dir_contents(const char *path, const char **contents)
350  {
351  	int i;
352  	int res;
353  	int err = 0;
354  	int found[MAX_ENTRIES];
355  	const char *cont[MAX_ENTRIES];
356  	DIR *dp;
357  	for (i = 0; contents[i]; i++) {
358  		assert(i &lt; MAX_ENTRIES - 3);
359  		found[i] = 0;
360  		cont[i] = contents[i];
361  	}
362  	cont[i] = NULL;
363  	dp = opendir(path);
364  	if (dp == NULL) {
365  		PERROR(&quot;opendir&quot;);
366  		return -1;
367  	}
368  	memset(found, 0, sizeof(found));
369  	while(1) {
370  		struct dirent *de;
371  		errno = 0;
372  		de = readdir(dp);
373  		if (de == NULL) {
374  			if (errno) {
375  				PERROR(&quot;readdir&quot;);
376  				closedir(dp);
377  				return -1;
378  			}
379  			break;
380  		}
381  		if (is_dot_or_dotdot(de-&gt;d_name))
382  			continue;
383  		for (i = 0; cont[i] != NULL; i++) {
384  			assert(i &lt; MAX_ENTRIES);
385  			if (strcmp(cont[i], de-&gt;d_name) == 0) {
386  				if (found[i]) {
387  					ERROR(&quot;duplicate entry &lt;%s&gt;&quot;,
388  					      de-&gt;d_name);
389  					err--;
390  				} else
391  					found[i] = 1;
392  				break;
393  			}
394  		}
395  		if (!cont[i]) {
396  			ERROR(&quot;unexpected entry &lt;%s&gt;&quot;, de-&gt;d_name);
397  			err --;
398  		}
399  	}
400  	for (i = 0; cont[i] != NULL; i++) {
401  		if (!found[i]) {
402  			ERROR(&quot;missing entry &lt;%s&gt;&quot;, cont[i]);
403  			err--;
404  		}
405  	}
406  	res = closedir(dp);
407  	if (res == -1) {
408  		PERROR(&quot;closedir&quot;);
409  		return -1;
410  	}
411  	if (err)
412  		return -1;
413  	return 0;
414  }
415  static int create_file(const char *path, const char *data, int len)
416  {
417  	int res;
418  	int fd;
419  	unlink(path);
420  	fd = creat(path, 0644);
421  	if (fd == -1) {
422  		PERROR(&quot;creat&quot;);
423  		return -1;
424  	}
425  	if (len) {
426  		res = write(fd, data, len);
427  		if (res == -1) {
428  			PERROR(&quot;write&quot;);
429  			close(fd);
430  			return -1;
431  		}
432  		if (res != len) {
433  			ERROR(&quot;write is short: %u instead of %u&quot;, res, len);
434  			close(fd);
435  			return -1;
436  		}
437  	}
438  	res = close(fd);
439  	if (res == -1) {
440  		PERROR(&quot;close&quot;);
441  		return -1;
442  	}
443  	res = check_type(path, S_IFREG);
444  	if (res == -1)
445  		return -1;
446  	res = check_mode(path, 0644);
447  	if (res == -1)
448  		return -1;
449  	res = check_nlink(path, 1);
450  	if (res == -1)
451  		return -1;
452  	res = check_size(path, len);
453  	if (res == -1)
454  		return -1;
455  	if (len) {
456  		res = check_data(path, data, 0, len);
457  		if (res == -1)
458  			return -1;
459  	}
460  	return 0;
461  }
462  static int create_path_fd(const char *path, const char *data, int len)
463  {
464  	int path_fd;
465  	int res;
466  	res = create_file(path, data, len);
467  	if (res == -1)
468  		return -1;
469  	path_fd = open(path, O_PATH);
470  	if (path_fd == -1)
471  		PERROR(&quot;open(O_PATH)&quot;);
472  	return path_fd;
473  }
474  static int create_testfile(const char *path, const char *data, int len)
475  {
476  	struct test *t = this_test;
477  	struct stat *st = &amp;t-&gt;stat;
478  	int res, fd;
479  	if (t-&gt;fd &gt; 0) {
480  		ERROR(&quot;testfile already created&quot;);
481  		return -1;
482  	}
483  	fd = create_path_fd(path, data, len);
484  	if (fd == -1)
485  		return -1;
486  	t-&gt;fd = fd;
487  	res = fstat(fd, st);
488  	if (res == -1) {
489  		PERROR(&quot;fstat&quot;);
490  		return -1;
491  	}
492  	return 0;
493  }
494  static int check_unlinked_testfile(int fd)
495  {
496  	struct stat *st = &amp;this_test-&gt;stat;
497  	st-&gt;st_nlink = 0;
498  	return fcheck_stat(fd, O_PATH, st);
499  }
500  static int check_unlinked_testfiles(void)
501  {
502  	int fd;
503  	int res, err = 0;
504  	int num = testnum;
505  	if (!unlinked_test)
506  		return 0;
507  	testnum = 0;
508  	while (testnum &lt; num) {
509  		fd = next_test-&gt;fd;
510  		start_test(&quot;check_unlinked_testfile&quot;);
511  		if (fd == -1)
512  			continue;
513  		err += check_unlinked_testfile(fd);
514  		res = close(fd);
515  		if (res == -1) {
516  			PERROR(&quot;close(test_fd)&quot;);
517  			err--;
518  		}
519  	}
520  	if (err) {
521  		fprintf(stderr, &quot;%i unlinked testfile checks failed\n&quot;, -err);
522  		return 1;
523  	}
524  	return err;
525  }
526  static int cleanup_dir(const char *path, const char **dir_files, int quiet)
527  {
528  	int i;
529  	int err = 0;
530  	for (i = 0; dir_files[i]; i++) {
531  		int res;
532  		char fpath[1280];
533  		sprintf(fpath, &quot;%s/%s&quot;, path, dir_files[i]);
534  		res = unlink(fpath);
535  		if (res == -1 &amp;&amp; !quiet) {
536  			PERROR(&quot;unlink&quot;);
537  			err --;
538  		}
539  	}
540  	if (err)
541  		return -1;
542  	return 0;
543  }
544  static int create_dir(const char *path, const char **dir_files)
545  {
546  	int res;
547  	int i;
548  	rmdir(path);
549  	res = mkdir(path, 0755);
550  	if (res == -1) {
551  		PERROR(&quot;mkdir&quot;);
552  		return -1;
553  	}
554  	res = check_type(path, S_IFDIR);
555  	if (res == -1)
556  		return -1;
557  	res = check_mode(path, 0755);
558  	if (res == -1)
559  		return -1;
560  	for (i = 0; dir_files[i]; i++) {
561  		char fpath[1280];
562  		sprintf(fpath, &quot;%s/%s&quot;, path, dir_files[i]);
563  		res = create_file(fpath, &quot;&quot;, 0);
564  		if (res == -1) {
565  			cleanup_dir(path, dir_files, 1);
566  			return -1;
567  		}
568  	}
569  	res = check_dir_contents(path, dir_files);
570  	if (res == -1) {
571  		cleanup_dir(path, dir_files, 1);
572  		return -1;
573  	}
574  	return 0;
575  }
576  static int test_truncate(int len)
577  {
578  	const char *data = testdata;
579  	int datalen = testdatalen;
580  	int res;
581  	start_test(&quot;truncate(%u)&quot;, (int) len);
582  	res = create_testfile(testfile, data, datalen);
583  	if (res == -1)
584  		return -1;
585  	res = truncate(testfile, len);
586  	if (res == -1) {
587  		PERROR(&quot;truncate&quot;);
588  		return -1;
589  	}
590  	res = check_testfile_size(testfile, len);
591  	if (res == -1)
592  		return -1;
593  	if (len &gt; 0) {
594  		if (len &lt;= datalen) {
595  			res = check_data(testfile, data, 0, len);
596  			if (res == -1)
597  				return -1;
598  		} else {
599  			res = check_data(testfile, data, 0, datalen);
600  			if (res == -1)
601  				return -1;
602  			res = check_data(testfile, zerodata, datalen,
603  					 len - datalen);
604  			if (res == -1)
605  				return -1;
606  		}
607  	}
608  	res = unlink(testfile);
609  	if (res == -1) {
610  		PERROR(&quot;unlink&quot;);
611  		return -1;
612  	}
613  	res = check_nonexist(testfile);
614  	if (res == -1)
615  		return -1;
616  	success();
617  	return 0;
618  }
619  static int test_ftruncate(int len, int mode)
620  {
621  	const char *data = testdata;
622  	int datalen = testdatalen;
623  	int res;
624  	int fd;
625  	start_test(&quot;ftruncate(%u) mode: 0%03o&quot;, len, mode);
626  	res = create_testfile(testfile, data, datalen);
627  	if (res == -1)
628  		return -1;
629  	fd = open(testfile, O_WRONLY);
630  	if (fd == -1) {
631  		PERROR(&quot;open&quot;);
632  		return -1;
633  	}
634  	res = fchmod(fd, mode);
635  	if (res == -1) {
636  		PERROR(&quot;fchmod&quot;);
637  		close(fd);
638  		return -1;
639  	}
640  	res = check_testfile_mode(testfile, mode);
641  	if (res == -1) {
642  		close(fd);
643  		return -1;
644  	}
645  	res = ftruncate(fd, len);
646  	if (res == -1) {
647  		PERROR(&quot;ftruncate&quot;);
648  		close(fd);
649  		return -1;
650  	}
651  	close(fd);
652  	res = check_testfile_size(testfile, len);
653  	if (res == -1)
654  		return -1;
655  	if (len &gt; 0) {
656  		if (len &lt;= datalen) {
657  			res = check_data(testfile, data, 0, len);
658  			if (res == -1)
659  				return -1;
660  		} else {
661  			res = check_data(testfile, data, 0, datalen);
662  			if (res == -1)
663  				return -1;
664  			res = check_data(testfile, zerodata, datalen,
665  					 len - datalen);
666  			if (res == -1)
667  				return -1;
668  		}
669  	}
670  	res = unlink(testfile);
671  	if (res == -1) {
672  		PERROR(&quot;unlink&quot;);
673  		return -1;
674  	}
675  	res = check_nonexist(testfile);
676  	if (res == -1)
677  		return -1;
678  	success();
679  	return 0;
680  }
681  static int test_seekdir(void)
682  {
683  	int i;
684  	int res;
685  	DIR *dp;
686  	struct dirent *de;
687  	start_test(&quot;seekdir&quot;);
688  	res = create_dir(testdir, testdir_files);
689  	if (res == -1)
690  		return res;
691  	dp = opendir(testdir);
692  	if (dp == NULL) {
693  		PERROR(&quot;opendir&quot;);
694  		return -1;
695  	}
696  	for (i = 0; i &lt; ARRAY_SIZE(seekdir_offsets); i++) {
697  		seekdir_offsets[i] = telldir(dp);
698  		errno = 0;
699  		de = readdir(dp);
700  		if (de == NULL) {
701  			if (errno) {
702  				PERROR(&quot;readdir&quot;);
703  				goto fail;
704  			}
705  			break;
706  		}
707  	}
708  	while (de)
709  		de = readdir(dp);
710  	for (i--; i &gt;= 0; i--) {
711  		seekdir(dp, seekdir_offsets[i]);
712  		de = readdir(dp);
713  		if (de == NULL) {
714  			ERROR(&quot;Unexpected end of directory after seekdir()&quot;);
715  			goto fail;
716  		}
717  	}
718  	closedir(dp);
719  	res = cleanup_dir(testdir, testdir_files, 0);
720  	if (!res)
721  		success();
722  	return res;
723  fail:
724  	closedir(dp);
725  	cleanup_dir(testdir, testdir_files, 1);
726  	return -1;
727  }
728  #ifdef HAVE_COPY_FILE_RANGE
729  static int test_copy_file_range(void)
730  {
731  	const char *data = testdata;
732  	int datalen = testdatalen;
733  	int err = 0;
734  	int res;
735  	int fd_in, fd_out;
736  	off_t pos_in = 0, pos_out = 0;
737  	start_test(&quot;copy_file_range&quot;);
738  	unlink(testfile);
739  	fd_in = open(testfile, O_CREAT | O_RDWR, 0644);
740  	if (fd_in == -1) {
741  		PERROR(&quot;creat&quot;);
742  		return -1;
743  	}
744  	res = write(fd_in, data, datalen);
745  	if (res == -1) {
746  		PERROR(&quot;write&quot;);
747  		close(fd_in);
748  		return -1;
749  	}
750  	if (res != datalen) {
751  		ERROR(&quot;write is short: %u instead of %u&quot;, res, datalen);
752  		close(fd_in);
753  		return -1;
754  	}
755  	unlink(testfile2);
756  	fd_out = creat(testfile2, 0644);
757  	if (fd_out == -1) {
758  		PERROR(&quot;creat&quot;);
759  		close(fd_in);
760  		return -1;
761  	}
762  	res = copy_file_range(fd_in, &amp;pos_in, fd_out, &amp;pos_out, datalen, 0);
763  	if (res == -1) {
764  		PERROR(&quot;copy_file_range&quot;);
765  		close(fd_in);
766  		close(fd_out);
767  		return -1;
768  	}
769  	if (res != datalen) {
770  		ERROR(&quot;copy is short: %u instead of %u&quot;, res, datalen);
771  		close(fd_in);
772  		close(fd_out);
773  		return -1;
774  	}
775  	res = close(fd_in);
776  	if (res == -1) {
777  		PERROR(&quot;close&quot;);
778  		close(fd_out);
779  		return -1;
780  	}
781  	res = close(fd_out);
782  	if (res == -1) {
783  		PERROR(&quot;close&quot;);
784  		return -1;
785  	}
786  	err = check_data(testfile2, data, 0, datalen);
787  	res = unlink(testfile);
788  	if (res == -1) {
789  		PERROR(&quot;unlink&quot;);
790  		return -1;
791  	}
792  	res = check_nonexist(testfile);
793  	if (res == -1)
794  		return -1;
795  	if (err)
796  		return -1;
797  	res = unlink(testfile2);
798  	if (res == -1) {
799  		PERROR(&quot;unlink&quot;);
800  		return -1;
801  	}
802  	res = check_nonexist(testfile2);
803  	if (res == -1)
804  		return -1;
805  	if (err)
806  		return -1;
807  	success();
808  	return 0;
809  }
810  #else
811  static int test_copy_file_range(void)
812  {
813  	return 0;
814  }
815  #endif
816  static int test_utime(void)
817  {
818  	struct utimbuf utm;
819  	time_t atime = 987631200;
820  	time_t mtime = 123116400;
821  	int res;
822  	start_test(&quot;utime&quot;);
823  	res = create_testfile(testfile, NULL, 0);
824  	if (res == -1)
825  		return -1;
826  	utm.actime = atime;
827  	utm.modtime = mtime;
828  	res = utime(testfile, &amp;utm);
829  	if (res == -1) {
830  		PERROR(&quot;utime&quot;);
831  		return -1;
832  	}
833  	res = check_times(testfile, atime, mtime);
834  	if (res == -1) {
835  		return -1;
836  	}
837  	res = unlink(testfile);
838  	if (res == -1) {
839  		PERROR(&quot;unlink&quot;);
840  		return -1;
841  	}
842  	res = check_nonexist(testfile);
843  	if (res == -1)
844  		return -1;
845  	success();
846  	return 0;
847  }
848  static int test_create(void)
849  {
850  	const char *data = testdata;
851  	int datalen = testdatalen;
852  	int err = 0;
<span onclick='openModal()' class='match'>853  	int res;
854  	int fd;
855  	start_test(&quot;create&quot;);
856  	unlink(testfile);
857  	fd = creat(testfile, 0644);
</span>858  	if (fd == -1) {
859  		PERROR(&quot;creat&quot;);
860  		return -1;
861  	}
862  	res = write(fd, data, datalen);
863  	if (res == -1) {
864  		PERROR(&quot;write&quot;);
865  		close(fd);
866  		return -1;
867  	}
868  	if (res != datalen) {
869  		ERROR(&quot;write is short: %u instead of %u&quot;, res, datalen);
870  		close(fd);
871  		return -1;
872  	}
873  	res = close(fd);
874  	if (res == -1) {
875  		PERROR(&quot;close&quot;);
876  		return -1;
877  	}
878  	res = check_type(testfile, S_IFREG);
879  	if (res == -1)
880  		return -1;
881  	err += check_mode(testfile, 0644);
882  	err += check_nlink(testfile, 1);
883  	err += check_size(testfile, datalen);
884  	err += check_data(testfile, data, 0, datalen);
885  	res = unlink(testfile);
886  	if (res == -1) {
887  		PERROR(&quot;unlink&quot;);
888  		return -1;
889  	}
890  	res = check_nonexist(testfile);
891  	if (res == -1)
892  		return -1;
893  	if (err)
894  		return -1;
895  	success();
896  	return 0;
897  }
898  static int test_create_unlink(void)
899  {
900  	const char *data = testdata;
901  	int datalen = testdatalen;
902  	int err = 0;
903  	int res;
904  	int fd;
905  	start_test(&quot;create+unlink&quot;);
906  	unlink(testfile);
907  	fd = open(testfile, O_CREAT | O_RDWR | O_TRUNC, 0644);
908  	if (fd == -1) {
909  		PERROR(&quot;creat&quot;);
910  		return -1;
911  	}
912  	res = unlink(testfile);
913  	if (res == -1) {
914  		PERROR(&quot;unlink&quot;);
915  		close(fd);
916  		return -1;
917  	}
918  	res = check_nonexist(testfile);
919  	if (res == -1) {
920  		close(fd);
921  		return -1;
922  	}
923  	res = write(fd, data, datalen);
924  	if (res == -1) {
925  		PERROR(&quot;write&quot;);
926  		close(fd);
927  		return -1;
928  	}
929  	if (res != datalen) {
930  		ERROR(&quot;write is short: %u instead of %u&quot;, res, datalen);
931  		close(fd);
932  		return -1;
933  	}
934  	struct stat st = {
935  		.st_mode = S_IFREG | 0644,
936  		.st_size = datalen,
937  	};
938  	err = fcheck_stat(fd, O_RDWR, &amp;st);
939  	err += fcheck_data(fd, data, 0, datalen);
940  	res = close(fd);
941  	if (res == -1) {
942  		PERROR(&quot;close&quot;);
943  		err--;
944  	}
945  	if (err)
946  		return -1;
947  	success();
948  	return 0;
949  }
950  #ifndef __FreeBSD__
951  static int test_mknod(void)
952  {
953  	int err = 0;
954  	int res;
955  	start_test(&quot;mknod&quot;);
956  	unlink(testfile);
957  	res = mknod(testfile, 0644, 0);
958  	if (res == -1) {
959  		PERROR(&quot;mknod&quot;);
960  		return -1;
961  	}
962  	res = check_type(testfile, S_IFREG);
963  	if (res == -1)
964  		return -1;
965  	err += check_mode(testfile, 0644);
966  	err += check_nlink(testfile, 1);
967  	err += check_size(testfile, 0);
968  	res = unlink(testfile);
969  	if (res == -1) {
970  		PERROR(&quot;unlink&quot;);
971  		return -1;
972  	}
973  	res = check_nonexist(testfile);
974  	if (res == -1)
975  		return -1;
976  	if (err)
977  		return -1;
978  	success();
979  	return 0;
980  }
981  #endif
982  #define test_open(exist, flags, mode)  do_test_open(exist, flags, #flags, mode)
983  static int do_test_open(int exist, int flags, const char *flags_str, int mode)
984  {
985  	char buf[4096];
986  	const char *data = testdata;
987  	int datalen = testdatalen;
988  	unsigned currlen = 0;
989  	int err = 0;
990  	int res;
991  	int fd;
992  	off_t off;
993  	start_test(&quot;open(%s, %s, 0%03o)&quot;, exist ? &quot;+&quot; : &quot;-&quot;, flags_str, mode);
994  	unlink(testfile);
995  	if (exist) {
996  		res = create_file(testfile_r, testdata2, testdata2len);
997  		if (res == -1)
998  			return -1;
999  		currlen = testdata2len;
1000  	}
1001  	fd = open(testfile, flags, mode);
1002  	if ((flags &amp; O_CREAT) &amp;&amp; (flags &amp; O_EXCL) &amp;&amp; exist) {
1003  		if (fd != -1) {
1004  			ERROR(&quot;open should have failed&quot;);
1005  			close(fd);
1006  			return -1;
1007  		} else if (errno == EEXIST)
1008  			goto succ;
1009  	}
1010  	if (!(flags &amp; O_CREAT) &amp;&amp; !exist) {
1011  		if (fd != -1) {
1012  			ERROR(&quot;open should have failed&quot;);
1013  			close(fd);
1014  			return -1;
1015  		} else if (errno == ENOENT)
1016  			goto succ;
1017  	}
1018  	if (fd == -1) {
1019  		PERROR(&quot;open&quot;);
1020  		return -1;
1021  	}
1022  	if (flags &amp; O_TRUNC)
1023  		currlen = 0;
1024  	err += check_type(testfile, S_IFREG);
1025  	if (exist)
1026  		err += check_mode(testfile, 0644);
1027  	else
1028  		err += check_mode(testfile, mode);
1029  	err += check_nlink(testfile, 1);
1030  	err += check_size(testfile, currlen);
1031  	if (exist &amp;&amp; !(flags &amp; O_TRUNC) &amp;&amp; (mode &amp; S_IRUSR))
1032  		err += check_data(testfile, testdata2, 0, testdata2len);
1033  	res = write(fd, data, datalen);
1034  	if ((flags &amp; O_ACCMODE) != O_RDONLY) {
1035  		if (res == -1) {
1036  			PERROR(&quot;write&quot;);
1037  			err --;
1038  		} else if (res != datalen) {
1039  			ERROR(&quot;write is short: %u instead of %u&quot;, res, datalen);
1040  			err --;
1041  		} else {
1042  			if (datalen &gt; (int) currlen)
1043  				currlen = datalen;
1044  			err += check_size(testfile, currlen);
1045  			if (mode &amp; S_IRUSR) {
1046  				err += check_data(testfile, data, 0, datalen);
1047  				if (exist &amp;&amp; !(flags &amp; O_TRUNC) &amp;&amp;
1048  				    testdata2len &gt; datalen)
1049  					err += check_data(testfile,
1050  							  testdata2 + datalen,
1051  							  datalen,
1052  							  testdata2len - datalen);
1053  			}
1054  		}
1055  	} else {
1056  		if (res != -1) {
1057  			ERROR(&quot;write should have failed&quot;);
1058  			err --;
1059  		} else if (errno != EBADF) {
1060  			PERROR(&quot;write&quot;);
1061  			err --;
1062  		}
1063  	}
1064  	off = lseek(fd, SEEK_SET, 0);
1065  	if (off == (off_t) -1) {
1066  		PERROR(&quot;lseek&quot;);
1067  		err--;
1068  	} else if (off != 0) {
1069  		ERROR(&quot;offset should have returned 0&quot;);
1070  		err --;
1071  	}
1072  	res = read(fd, buf, sizeof(buf));
1073  	if ((flags &amp; O_ACCMODE) != O_WRONLY) {
1074  		if (res == -1) {
1075  			PERROR(&quot;read&quot;);
1076  			err--;
1077  		} else {
1078  			int readsize =
1079  				currlen &lt; sizeof(buf) ? currlen : sizeof(buf);
1080  			if (res != readsize) {
1081  				ERROR(&quot;read is short: %i instead of %u&quot;,
1082  				      res, readsize);
1083  				err--;
1084  			} else {
1085  				if ((flags &amp; O_ACCMODE) != O_RDONLY) {
1086  					err += check_buffer(buf, data, datalen);
1087  					if (exist &amp;&amp; !(flags &amp; O_TRUNC) &amp;&amp;
1088  					    testdata2len &gt; datalen)
1089  						err += check_buffer(buf + datalen,
1090  								    testdata2 + datalen,
1091  								    testdata2len - datalen);
1092  				} else if (exist)
1093  					err += check_buffer(buf, testdata2,
1094  							    testdata2len);
1095  			}
1096  		}
1097  	} else {
1098  		if (res != -1) {
1099  			ERROR(&quot;read should have failed&quot;);
1100  			err --;
1101  		} else if (errno != EBADF) {
1102  			PERROR(&quot;read&quot;);
1103  			err --;
1104  		}
1105  	}
1106  	res = close(fd);
1107  	if (res == -1) {
1108  		PERROR(&quot;close&quot;);
1109  		return -1;
1110  	}
1111  	res = unlink(testfile);
1112  	if (res == -1) {
1113  		PERROR(&quot;unlink&quot;);
1114  		return -1;
1115  	}
1116  	res = check_nonexist(testfile);
1117  	if (res == -1)
1118  		return -1;
1119  	res = check_nonexist(testfile_r);
1120  	if (res == -1)
1121  		return -1;
1122  	if (err)
1123  		return -1;
1124  succ:
1125  	success();
1126  	return 0;
1127  }
1128  #define test_open_acc(flags, mode, err)	 \
1129  	do_test_open_acc(flags, #flags, mode, err)
1130  static int do_test_open_acc(int flags, const char *flags_str, int mode, int err)
1131  {
1132  	const char *data = testdata;
1133  	int datalen = testdatalen;
1134  	int res;
1135  	int fd;
1136  	start_test(&quot;open_acc(%s) mode: 0%03o message: &#x27;%s&#x27;&quot;, flags_str, mode,
1137  		   strerror(err));
1138  	unlink(testfile);
1139  	res = create_testfile(testfile, data, datalen);
1140  	if (res == -1)
1141  		return -1;
1142  	res = chmod(testfile, mode);
1143  	if (res == -1) {
1144  		PERROR(&quot;chmod&quot;);
1145  		return -1;
1146  	}
1147  	res = check_testfile_mode(testfile, mode);
1148  	if (res == -1)
1149  		return -1;
1150  	fd = open(testfile, flags);
1151  	if (fd == -1) {
1152  		if (err != errno) {
1153  			PERROR(&quot;open&quot;);
1154  			return -1;
1155  		}
1156  	} else {
1157  		if (err) {
1158  			ERROR(&quot;open should have failed&quot;);
1159  			close(fd);
1160  			return -1;
1161  		}
1162  		close(fd);
1163  	}
1164  	res = unlink(testfile);
1165  	if (res == -1) {
1166  		PERROR(&quot;unlink&quot;);
1167  		return -1;
1168  	}
1169  	res = check_nonexist(testfile);
1170  	if (res == -1)
1171  		return -1;
1172  	res = check_nonexist(testfile_r);
1173  	if (res == -1)
1174  		return -1;
1175  	success();
1176  	return 0;
1177  }
1178  static int test_symlink(void)
1179  {
1180  	char buf[1024];
1181  	const char *data = testdata;
1182  	int datalen = testdatalen;
1183  	int linklen = strlen(testfile);
1184  	int err = 0;
1185  	int res;
1186  	start_test(&quot;symlink&quot;);
1187  	res = create_testfile(testfile, data, datalen);
1188  	if (res == -1)
1189  		return -1;
1190  	unlink(testfile2);
1191  	res = symlink(testfile, testfile2);
1192  	if (res == -1) {
1193  		PERROR(&quot;symlink&quot;);
1194  		return -1;
1195  	}
1196  	res = check_type(testfile2, S_IFLNK);
1197  	if (res == -1)
1198  		return -1;
1199  	err += check_mode(testfile2, 0777);
1200  	err += check_nlink(testfile2, 1);
1201  	res = readlink(testfile2, buf, sizeof(buf));
1202  	if (res == -1) {
1203  		PERROR(&quot;readlink&quot;);
1204  		err--;
1205  	}
1206  	if (res != linklen) {
1207  		ERROR(&quot;short readlink: %u instead of %u&quot;, res, linklen);
1208  		err--;
1209  	}
1210  	if (memcmp(buf, testfile, linklen) != 0) {
1211  		ERROR(&quot;link mismatch&quot;);
1212  		err--;
1213  	}
1214  	err += check_size(testfile2, datalen);
1215  	err += check_data(testfile2, data, 0, datalen);
1216  	res = unlink(testfile2);
1217  	if (res == -1) {
1218  		PERROR(&quot;unlink&quot;);
1219  		return -1;
1220  	}
1221  	res = check_nonexist(testfile2);
1222  	if (res == -1)
1223  		return -1;
1224  	if (err)
1225  		return -1;
1226  	res = unlink(testfile);
1227  	if (res == -1) {
1228  		PERROR(&quot;unlink&quot;);
1229  		return -1;
1230  	}
1231  	res = check_nonexist(testfile);
1232  	if (res == -1)
1233  		return -1;
1234  	success();
1235  	return 0;
1236  }
1237  static int test_link(void)
1238  {
1239  	const char *data = testdata;
1240  	int datalen = testdatalen;
1241  	int err = 0;
1242  	int res;
1243  	start_test(&quot;link&quot;);
1244  	res = create_testfile(testfile, data, datalen);
1245  	if (res == -1)
1246  		return -1;
1247  	unlink(testfile2);
1248  	res = link(testfile, testfile2);
1249  	if (res == -1) {
1250  		PERROR(&quot;link&quot;);
1251  		return -1;
1252  	}
1253  	res = check_type(testfile2, S_IFREG);
1254  	if (res == -1)
1255  		return -1;
1256  	err += check_mode(testfile2, 0644);
1257  	err += check_nlink(testfile2, 2);
1258  	err += check_size(testfile2, datalen);
1259  	err += check_data(testfile2, data, 0, datalen);
1260  	res = unlink(testfile);
1261  	if (res == -1) {
1262  		PERROR(&quot;unlink&quot;);
1263  		return -1;
1264  	}
1265  	res = check_nonexist(testfile);
1266  	if (res == -1)
1267  		return -1;
1268  	err += check_nlink(testfile2, 1);
1269  	res = unlink(testfile2);
1270  	if (res == -1) {
1271  		PERROR(&quot;unlink&quot;);
1272  		return -1;
1273  	}
1274  	res = check_nonexist(testfile2);
1275  	if (res == -1)
1276  		return -1;
1277  	if (err)
1278  		return -1;
1279  	success();
1280  	return 0;
1281  }
1282  static int test_link2(void)
1283  {
1284  	const char *data = testdata;
1285  	int datalen = testdatalen;
1286  	int err = 0;
1287  	int res;
1288  	start_test(&quot;link-unlink-link&quot;);
1289  	res = create_testfile(testfile, data, datalen);
1290  	if (res == -1)
1291  		return -1;
1292  	unlink(testfile2);
1293  	res = link(testfile, testfile2);
1294  	if (res == -1) {
1295  		PERROR(&quot;link&quot;);
1296  		return -1;
1297  	}
1298  	res = unlink(testfile);
1299  	if (res == -1) {
1300  		PERROR(&quot;unlink&quot;);
1301  		return -1;
1302  	}
1303  	res = check_nonexist(testfile);
1304  	if (res == -1)
1305  		return -1;
1306  	res = link(testfile2, testfile);
1307  	if (res == -1) {
1308  		PERROR(&quot;link&quot;);
1309  	}
1310  	res = check_type(testfile, S_IFREG);
1311  	if (res == -1)
1312  		return -1;
1313  	err += check_mode(testfile, 0644);
1314  	err += check_nlink(testfile, 2);
1315  	err += check_size(testfile, datalen);
1316  	err += check_data(testfile, data, 0, datalen);
1317  	res = unlink(testfile2);
1318  	if (res == -1) {
1319  		PERROR(&quot;unlink&quot;);
1320  		return -1;
1321  	}
1322  	err += check_nlink(testfile, 1);
1323  	res = unlink(testfile);
1324  	if (res == -1) {
1325  		PERROR(&quot;unlink&quot;);
1326  		return -1;
1327  	}
1328  	res = check_nonexist(testfile);
1329  	if (res == -1)
1330  		return -1;
1331  	if (err)
1332  		return -1;
1333  	success();
1334  	return 0;
1335  }
1336  static int test_rename_file(void)
1337  {
1338  	const char *data = testdata;
1339  	int datalen = testdatalen;
1340  	int err = 0;
1341  	int res;
1342  	start_test(&quot;rename file&quot;);
1343  	res = create_testfile(testfile, data, datalen);
1344  	if (res == -1)
1345  		return -1;
1346  	unlink(testfile2);
1347  	res = rename(testfile, testfile2);
1348  	if (res == -1) {
1349  		PERROR(&quot;rename&quot;);
1350  		return -1;
1351  	}
1352  	res = check_nonexist(testfile);
1353  	if (res == -1)
1354  		return -1;
1355  	res = check_type(testfile2, S_IFREG);
1356  	if (res == -1)
1357  		return -1;
1358  	err += check_mode(testfile2, 0644);
1359  	err += check_nlink(testfile2, 1);
1360  	err += check_size(testfile2, datalen);
1361  	err += check_data(testfile2, data, 0, datalen);
1362  	res = unlink(testfile2);
1363  	if (res == -1) {
1364  		PERROR(&quot;unlink&quot;);
1365  		return -1;
1366  	}
1367  	res = check_nonexist(testfile2);
1368  	if (res == -1)
1369  		return -1;
1370  	if (err)
1371  		return -1;
1372  	success();
1373  	return 0;
1374  }
1375  static int test_rename_dir(void)
1376  {
1377  	int err = 0;
1378  	int res;
1379  	start_test(&quot;rename dir&quot;);
1380  	res = create_dir(testdir, testdir_files);
1381  	if (res == -1)
1382  		return -1;
1383  	rmdir(testdir2);
1384  	res = rename(testdir, testdir2);
1385  	if (res == -1) {
1386  		PERROR(&quot;rename&quot;);
1387  		cleanup_dir(testdir, testdir_files, 1);
1388  		return -1;
1389  	}
1390  	res = check_nonexist(testdir);
1391  	if (res == -1) {
1392  		cleanup_dir(testdir, testdir_files, 1);
1393  		return -1;
1394  	}
1395  	res = check_type(testdir2, S_IFDIR);
1396  	if (res == -1) {
1397  		cleanup_dir(testdir2, testdir_files, 1);
1398  		return -1;
1399  	}
1400  	err += check_mode(testdir2, 0755);
1401  	err += check_dir_contents(testdir2, testdir_files);
1402  	err += cleanup_dir(testdir2, testdir_files, 0);
1403  	res = rmdir(testdir2);
1404  	if (res == -1) {
1405  		PERROR(&quot;rmdir&quot;);
1406  		return -1;
1407  	}
1408  	res = check_nonexist(testdir2);
1409  	if (res == -1)
1410  		return -1;
1411  	if (err)
1412  		return -1;
1413  	success();
1414  	return 0;
1415  }
1416  static int test_rename_dir_loop(void)
1417  {
1418  #define PATH(p)		(snprintf(path, sizeof path, &quot;%s/%s&quot;, testdir, p), path)
1419  #define PATH2(p)	(snprintf(path2, sizeof path2, &quot;%s/%s&quot;, testdir, p), path2)
1420  	char path[1280], path2[1280];
1421  	int err = 0;
1422  	int res;
1423  	start_test(&quot;rename dir loop&quot;);
1424  	res = create_dir(testdir, testdir_files);
1425  	if (res == -1)
1426  		return -1;
1427  	res = mkdir(PATH(&quot;a&quot;), 0755);
1428  	if (res == -1) {
1429  		PERROR(&quot;mkdir&quot;);
1430  		goto fail;
1431  	}
1432  	res = rename(PATH(&quot;a&quot;), PATH2(&quot;a&quot;));
1433  	if (res == -1) {
1434  		PERROR(&quot;rename&quot;);
1435  		goto fail;
1436  	}
1437  	errno = 0;
1438  	res = rename(PATH(&quot;a&quot;), PATH2(&quot;a/b&quot;));
1439  	if (res == 0 || errno != EINVAL) {
1440  		PERROR(&quot;rename&quot;);
1441  		goto fail;
1442  	}
1443  	res = mkdir(PATH(&quot;a/b&quot;), 0755);
1444  	if (res == -1) {
1445  		PERROR(&quot;mkdir&quot;);
1446  		goto fail;
1447  	}
1448  	res = mkdir(PATH(&quot;a/b/c&quot;), 0755);
1449  	if (res == -1) {
1450  		PERROR(&quot;mkdir&quot;);
1451  		goto fail;
1452  	}
1453  	errno = 0;
1454  	res = rename(PATH(&quot;a&quot;), PATH2(&quot;a/b/c&quot;));
1455  	if (res == 0 || errno != EINVAL) {
1456  		PERROR(&quot;rename&quot;);
1457  		goto fail;
1458  	}
1459  	errno = 0;
1460  	res = rename(PATH(&quot;a&quot;), PATH2(&quot;a/b/c/a&quot;));
1461  	if (res == 0 || errno != EINVAL) {
1462  		PERROR(&quot;rename&quot;);
1463  		goto fail;
1464  	}
1465  	errno = 0;
1466  	res = rename(PATH(&quot;a/b/c&quot;), PATH2(&quot;a&quot;));
1467  	if (res == 0 || errno != ENOTEMPTY) {
1468  		PERROR(&quot;rename&quot;);
1469  		goto fail;
1470  	}
1471  	res = open(PATH(&quot;a/foo&quot;), O_CREAT, 0644);
1472  	if (res == -1) {
1473  		PERROR(&quot;open&quot;);
1474  		goto fail;
1475  	}
1476  	close(res);
1477  	res = rename(PATH(&quot;a/foo&quot;), PATH2(&quot;a/bar&quot;));
1478  	if (res == -1) {
1479  		PERROR(&quot;rename&quot;);
1480  		goto fail;
1481  	}
1482  	res = rename(PATH(&quot;a/bar&quot;), PATH2(&quot;a/foo&quot;));
1483  	if (res == -1) {
1484  		PERROR(&quot;rename&quot;);
1485  		goto fail;
1486  	}
1487  	res = rename(PATH(&quot;a/foo&quot;), PATH2(&quot;a/b/bar&quot;));
1488  	if (res == -1) {
1489  		PERROR(&quot;rename&quot;);
1490  		goto fail;
1491  	}
1492  	res = rename(PATH(&quot;a/b/bar&quot;), PATH2(&quot;a/foo&quot;));
1493  	if (res == -1) {
1494  		PERROR(&quot;rename&quot;);
1495  		goto fail;
1496  	}
1497  	res = rename(PATH(&quot;a/foo&quot;), PATH2(&quot;a/b/c/bar&quot;));
1498  	if (res == -1) {
1499  		PERROR(&quot;rename&quot;);
1500  		goto fail;
1501  	}
1502  	res = rename(PATH(&quot;a/b/c/bar&quot;), PATH2(&quot;a/foo&quot;));
1503  	if (res == -1) {
1504  		PERROR(&quot;rename&quot;);
1505  		goto fail;
1506  	}
1507  	res = open(PATH(&quot;a/bar&quot;), O_CREAT, 0644);
1508  	if (res == -1) {
1509  		PERROR(&quot;open&quot;);
1510  		goto fail;
1511  	}
1512  	close(res);
1513  	res = rename(PATH(&quot;a/foo&quot;), PATH2(&quot;a/bar&quot;));
1514  	if (res == -1) {
1515  		PERROR(&quot;rename&quot;);
1516  		goto fail;
1517  	}
1518  	unlink(PATH(&quot;a/bar&quot;));
1519  	res = rename(PATH(&quot;a/b&quot;), PATH2(&quot;a/d&quot;));
1520  	if (res == -1) {
1521  		PERROR(&quot;rename&quot;);
1522  		goto fail;
1523  	}
1524  	res = rename(PATH(&quot;a/d&quot;), PATH2(&quot;a/b&quot;));
1525  	if (res == -1) {
1526  		PERROR(&quot;rename&quot;);
1527  		goto fail;
1528  	}
1529  	res = mkdir(PATH(&quot;a/d&quot;), 0755);
1530  	if (res == -1) {
1531  		PERROR(&quot;mkdir&quot;);
1532  		goto fail;
1533  	}
1534  	res = rename(PATH(&quot;a/b&quot;), PATH2(&quot;a/d&quot;));
1535  	if (res == -1) {
1536  		PERROR(&quot;rename&quot;);
1537  		goto fail;
1538  	}
1539  	res = rename(PATH(&quot;a/d&quot;), PATH2(&quot;a/b&quot;));
1540  	if (res == -1) {
1541  		PERROR(&quot;rename&quot;);
1542  		goto fail;
1543  	}
1544  	res = mkdir(PATH(&quot;a/d&quot;), 0755);
1545  	if (res == -1) {
1546  		PERROR(&quot;mkdir&quot;);
1547  		goto fail;
1548  	}
1549  	res = mkdir(PATH(&quot;a/d/e&quot;), 0755);
1550  	if (res == -1) {
1551  		PERROR(&quot;mkdir&quot;);
1552  		goto fail;
1553  	}
1554  	errno = 0;
1555  	res = rename(PATH(&quot;a/b&quot;), PATH2(&quot;a/d&quot;));
1556  	if (res == 0 || (errno != ENOTEMPTY &amp;&amp; errno != EEXIST)) {
1557  		PERROR(&quot;rename&quot;);
1558  		goto fail;
1559  	}
1560  	rmdir(PATH(&quot;a/d/e&quot;));
1561  	rmdir(PATH(&quot;a/d&quot;));
1562   	rmdir(PATH(&quot;a/b/c&quot;));
1563  	rmdir(PATH(&quot;a/b&quot;));
1564  	rmdir(PATH(&quot;a&quot;));
1565  	err += cleanup_dir(testdir, testdir_files, 0);
1566  	res = rmdir(testdir);
1567  	if (res == -1) {
1568  		PERROR(&quot;rmdir&quot;);
1569  		goto fail;
1570  	}
1571  	res = check_nonexist(testdir);
1572  	if (res == -1)
1573  		return -1;
1574  	if (err)
1575  		return -1;
1576  	success();
1577  	return 0;
1578  fail:
1579  	unlink(PATH(&quot;a/bar&quot;));
1580  	rmdir(PATH(&quot;a/d/e&quot;));
1581  	rmdir(PATH(&quot;a/d&quot;));
1582   	rmdir(PATH(&quot;a/b/c&quot;));
1583  	rmdir(PATH(&quot;a/b&quot;));
1584  	rmdir(PATH(&quot;a&quot;));
1585  	cleanup_dir(testdir, testdir_files, 1);
1586  	rmdir(testdir);
1587  	return -1;
1588  #undef PATH2
1589  #undef PATH
1590  }
1591  #ifndef __FreeBSD__
1592  static int test_mkfifo(void)
1593  {
1594  	int res;
1595  	int err = 0;
1596  	start_test(&quot;mkfifo&quot;);
1597  	unlink(testfile);
1598  	res = mkfifo(testfile, 0644);
1599  	if (res == -1) {
1600  		PERROR(&quot;mkfifo&quot;);
1601  		return -1;
1602  	}
1603  	res = check_type(testfile, S_IFIFO);
1604  	if (res == -1)
1605  		return -1;
1606  	err += check_mode(testfile, 0644);
1607  	err += check_nlink(testfile, 1);
1608  	res = unlink(testfile);
1609  	if (res == -1) {
1610  		PERROR(&quot;unlink&quot;);
1611  		return -1;
1612  	}
1613  	res = check_nonexist(testfile);
1614  	if (res == -1)
1615  		return -1;
1616  	if (err)
1617  		return -1;
1618  	success();
1619  	return 0;
1620  }
1621  #endif
1622  static int test_mkdir(void)
1623  {
1624  	int res;
1625  	int err = 0;
1626  	const char *dir_contents[] = {NULL};
1627  	start_test(&quot;mkdir&quot;);
1628  	rmdir(testdir);
1629  	res = mkdir(testdir, 0755);
1630  	if (res == -1) {
1631  		PERROR(&quot;mkdir&quot;);
1632  		return -1;
1633  	}
1634  	res = check_type(testdir, S_IFDIR);
1635  	if (res == -1)
1636  		return -1;
1637  	err += check_mode(testdir, 0755);
1638  	err += check_dir_contents(testdir, dir_contents);
1639  	res = rmdir(testdir);
1640  	if (res == -1) {
1641  		PERROR(&quot;rmdir&quot;);
1642  		return -1;
1643  	}
1644  	res = check_nonexist(testdir);
1645  	if (res == -1)
1646  		return -1;
1647  	if (err)
1648  		return -1;
1649  	success();
1650  	return 0;
1651  }
1652  static int test_socket(void)
1653  {
1654  	struct sockaddr_un su;
1655  	int fd;
1656  	int res;
1657  	int err = 0;
1658      const size_t test_sock_len = strlen(testsock) + 1;
1659  	start_test(&quot;socket&quot;);
1660  	if (test_sock_len &gt; sizeof(su.sun_path)) {
1661  		fprintf(stderr, &quot;Need to shorten mount point by %zu chars\n&quot;,
1662  			strlen(testsock) + 1 - sizeof(su.sun_path));
1663  		return -1;
1664  	}
1665  	unlink(testsock);
1666  	fd = socket(AF_UNIX, SOCK_STREAM, 0);
1667  	if (fd &lt; 0) {
1668  		PERROR(&quot;socket&quot;);
1669  		return -1;
1670  	}
1671  	su.sun_family = AF_UNIX;
1672  	strncpy(su.sun_path, testsock, test_sock_len);
1673  	su.sun_path[sizeof(su.sun_path) - 1] = &#x27;\0&#x27;;
1674  	res = bind(fd, (struct sockaddr*)&amp;su, sizeof(su));
1675  	if (res == -1) {
1676  		PERROR(&quot;bind&quot;);
1677  		return -1;
1678  	}
1679  	res = check_type(testsock, S_IFSOCK);
1680  	if (res == -1) {
1681  		close(fd);
1682  		return -1;
1683  	}
1684  	err += check_nlink(testsock, 1);
1685  	close(fd);
1686  	res = unlink(testsock);
1687  	if (res == -1) {
1688  		PERROR(&quot;unlink&quot;);
1689  		return -1;
1690  	}
1691  	res = check_nonexist(testsock);
1692  	if (res == -1)
1693  		return -1;
1694  	if (err)
1695  		return -1;
1696  	success();
1697  	return 0;
1698  }
1699  #define test_create_ro_dir(flags)	 \
1700  	do_test_create_ro_dir(flags, #flags)
1701  static int do_test_create_ro_dir(int flags, const char *flags_str)
1702  {
1703  	int res;
1704  	int err = 0;
1705  	int fd;
1706  	start_test(&quot;open(%s) in read-only directory&quot;, flags_str);
1707  	rmdir(testdir);
1708  	res = mkdir(testdir, 0555);
1709  	if (res == -1) {
1710  		PERROR(&quot;mkdir&quot;);
1711  		return -1;
1712  	}
1713  	fd = open(subfile, flags, 0644);
1714  	if (fd != -1) {
1715  		close(fd);
1716  		unlink(subfile);
1717  		ERROR(&quot;open should have failed&quot;);
1718  		err--;
1719  	} else {
1720  		res = check_nonexist(subfile);
1721  		if (res == -1)
1722  			err--;
1723  	}
1724  	unlink(subfile);
1725  	res = rmdir(testdir);
1726  	if (res == -1) {
1727  		PERROR(&quot;rmdir&quot;);
1728  		return -1;
1729  	}
1730  	res = check_nonexist(testdir);
1731  	if (res == -1)
1732  		return -1;
1733  	if (err)
1734  		return -1;
1735  	success();
1736  	return 0;
1737  }
1738  int main(int argc, char *argv[])
1739  {
1740  	int err = 0;
1741  	int a;
1742  	int is_root;
1743  	umask(0);
1744  	if (argc &lt; 2 || argc &gt; 4) {
1745  		fprintf(stderr, &quot;usage: %s testdir [:realdir] [[-]test#] [-u]\n&quot;, argv[0]);
1746  		return 1;
1747  	}
1748  	basepath = argv[1];
1749  	basepath_r = basepath;
1750  	for (a = 2; a &lt; argc; a++) {
1751  		char *endptr;
1752  		char *arg = argv[a];
1753  		if (arg[0] == &#x27;:&#x27;) {
1754  			basepath_r = arg + 1;
1755  		} else {
1756  			if (arg[0] == &#x27;-&#x27;) {
1757  				arg++;
1758  				if (arg[0] == &#x27;u&#x27;) {
1759  					unlinked_test = 1;
1760  					endptr = arg + 1;
1761  				} else {
1762  					skip_test = strtoul(arg, &amp;endptr, 10);
1763  				}
1764  			} else {
1765  				select_test = strtoul(arg, &amp;endptr, 10);
1766  			}
1767  			if (arg[0] == &#x27;\0&#x27; || *endptr != &#x27;\0&#x27;) {
1768  				fprintf(stderr, &quot;invalid option: &#x27;%s&#x27;\n&quot;, argv[a]);
1769  				return 1;
1770  			}
1771  		}
1772  	}
1773  	assert(strlen(basepath) &lt; 512);
1774  	assert(strlen(basepath_r) &lt; 512);
1775  	if (basepath[0] != &#x27;/&#x27;) {
1776  		fprintf(stderr, &quot;testdir must be an absolute path\n&quot;);
1777  		return 1;
1778  	}
1779  	sprintf(testfile, &quot;%s/testfile&quot;, basepath);
1780  	sprintf(testfile2, &quot;%s/testfile2&quot;, basepath);
1781  	sprintf(testdir, &quot;%s/testdir&quot;, basepath);
1782  	sprintf(testdir2, &quot;%s/testdir2&quot;, basepath);
1783  	sprintf(subfile, &quot;%s/subfile&quot;, testdir2);
1784  	sprintf(testsock, &quot;%s/testsock&quot;, basepath);
1785  	sprintf(testfile_r, &quot;%s/testfile&quot;, basepath_r);
1786  	sprintf(testfile2_r, &quot;%s/testfile2&quot;, basepath_r);
1787  	sprintf(testdir_r, &quot;%s/testdir&quot;, basepath_r);
1788  	sprintf(testdir2_r, &quot;%s/testdir2&quot;, basepath_r);
1789  	sprintf(subfile_r, &quot;%s/subfile&quot;, testdir2_r);
1790  	is_root = (geteuid() == 0);
1791  	err += test_create();
1792  	err += test_create_unlink();
1793  	err += test_symlink();
1794  	err += test_link();
1795  	err += test_link2();
1796  #ifndef __FreeBSD__	
1797  	err += test_mknod();
1798  	err += test_mkfifo();
1799  #endif
1800  	err += test_mkdir();
1801  	err += test_rename_file();
1802  	err += test_rename_dir();
1803  	err += test_rename_dir_loop();
1804  	err += test_seekdir();
1805  	err += test_socket();
1806  	err += test_utime();
1807  	err += test_truncate(0);
1808  	err += test_truncate(testdatalen / 2);
1809  	err += test_truncate(testdatalen);
1810  	err += test_truncate(testdatalen + 100);
1811  	err += test_ftruncate(0, 0600);
1812  	err += test_ftruncate(testdatalen / 2, 0600);
1813  	err += test_ftruncate(testdatalen, 0600);
1814  	err += test_ftruncate(testdatalen + 100, 0600);
1815  	err += test_ftruncate(0, 0400);
1816  	err += test_ftruncate(0, 0200);
1817  	err += test_ftruncate(0, 0000);
1818  	err += test_open(0, O_RDONLY, 0);
1819  	err += test_open(1, O_RDONLY, 0);
1820  	err += test_open(1, O_RDWR, 0);
1821  	err += test_open(1, O_WRONLY, 0);
1822  	err += test_open(0, O_RDWR | O_CREAT, 0600);
1823  	err += test_open(1, O_RDWR | O_CREAT, 0600);
1824  	err += test_open(0, O_RDWR | O_CREAT | O_TRUNC, 0600);
1825  	err += test_open(1, O_RDWR | O_CREAT | O_TRUNC, 0600);
1826  	err += test_open(0, O_RDONLY | O_CREAT, 0600);
1827  	err += test_open(0, O_RDONLY | O_CREAT, 0400);
1828  	err += test_open(0, O_RDONLY | O_CREAT, 0200);
1829  	err += test_open(0, O_RDONLY | O_CREAT, 0000);
1830  	err += test_open(0, O_WRONLY | O_CREAT, 0600);
1831  	err += test_open(0, O_WRONLY | O_CREAT, 0400);
1832  	err += test_open(0, O_WRONLY | O_CREAT, 0200);
1833  	err += test_open(0, O_WRONLY | O_CREAT, 0000);
1834  	err += test_open(0, O_RDWR | O_CREAT, 0400);
1835  	err += test_open(0, O_RDWR | O_CREAT, 0200);
1836  	err += test_open(0, O_RDWR | O_CREAT, 0000);
1837  	err += test_open(0, O_RDWR | O_CREAT | O_EXCL, 0600);
1838  	err += test_open(1, O_RDWR | O_CREAT | O_EXCL, 0600);
1839  	err += test_open(0, O_RDWR | O_CREAT | O_EXCL, 0000);
1840  	err += test_open(1, O_RDWR | O_CREAT | O_EXCL, 0000);
1841  	err += test_open_acc(O_RDONLY, 0600, 0);
1842  	err += test_open_acc(O_WRONLY, 0600, 0);
1843  	err += test_open_acc(O_RDWR,   0600, 0);
1844  	err += test_open_acc(O_RDONLY, 0400, 0);
1845  	err += test_open_acc(O_WRONLY, 0200, 0);
1846  	if(!is_root) {
1847  		err += test_open_acc(O_RDONLY | O_TRUNC, 0400, EACCES);
1848  		err += test_open_acc(O_WRONLY, 0400, EACCES);
1849  		err += test_open_acc(O_RDWR,   0400, EACCES);
1850  		err += test_open_acc(O_RDONLY, 0200, EACCES);
1851  		err += test_open_acc(O_RDWR,   0200, EACCES);
1852  		err += test_open_acc(O_RDONLY, 0000, EACCES);
1853  		err += test_open_acc(O_WRONLY, 0000, EACCES);
1854  		err += test_open_acc(O_RDWR,   0000, EACCES);
1855  	}
1856  	err += test_create_ro_dir(O_CREAT);
1857  	err += test_create_ro_dir(O_CREAT | O_EXCL);
1858  	err += test_create_ro_dir(O_CREAT | O_WRONLY);
1859  	err += test_create_ro_dir(O_CREAT | O_TRUNC);
1860  	err += test_copy_file_range();
1861  	unlink(testfile2);
1862  	unlink(testsock);
1863  	rmdir(testdir);
1864  	rmdir(testdir2);
1865  	if (err) {
1866  		fprintf(stderr, &quot;%i tests failed\n&quot;, -err);
1867  		return 1;
1868  	}
1869  	return check_unlinked_testfiles();
1870  }
</code></pre>
        </div>
        <div class="column">
            <h3>libfuse-MDEwOlJlcG9zaXRvcnk0ODI5NjE3Nw==-flat-test_syscalls.c</h3>
            <pre><code>1  #define _GNU_SOURCE
2  #include &quot;fuse_config.h&quot;
3  #include &lt;stdio.h&gt;
4  #include &lt;stdlib.h&gt;
5  #include &lt;stdarg.h&gt;
6  #include &lt;string.h&gt;
7  #include &lt;unistd.h&gt;
8  #include &lt;fcntl.h&gt;
9  #include &lt;dirent.h&gt;
10  #include &lt;utime.h&gt;
11  #include &lt;errno.h&gt;
12  #include &lt;assert.h&gt;
13  #include &lt;sys/socket.h&gt;
14  #include &lt;sys/types.h&gt;
15  #include &lt;sys/stat.h&gt;
16  #include &lt;sys/un.h&gt;
17  #ifndef ALLPERMS
18  # define ALLPERMS (S_ISUID|S_ISGID|S_ISVTX|S_IRWXU|S_IRWXG|S_IRWXO)&amp;bsol;* 07777 */
19  #endif
20  static const char *basepath;
21  static const char *basepath_r;
22  static char testfile[1024];
23  static char testfile2[1024];
24  static char testdir[1024];
25  static char testdir2[1024];
26  static char testsock[1024];
27  static char subfile[1280];
28  static char testfile_r[1024];
29  static char testfile2_r[1024];
30  static char testdir_r[1024];
31  static char testdir2_r[1024];
32  static char subfile_r[1280];
33  static char testname[256];
34  static char testdata[] = &quot;abcdefghijklmnopqrstuvwxyz&quot;;
35  static char testdata2[] = &quot;1234567890-=qwertyuiop[]\asdfghjkl;&#x27;zxcvbnm,./&quot;;
36  static const char *testdir_files[] = { &quot;f1&quot;, &quot;f2&quot;, NULL};
37  static long seekdir_offsets[4];
38  static char zerodata[4096];
39  static int testdatalen = sizeof(testdata) - 1;
40  static int testdata2len = sizeof(testdata2) - 1;
41  static unsigned int testnum = 0;
42  static unsigned int select_test = 0;
43  static unsigned int skip_test = 0;
44  static unsigned int unlinked_test = 0;
45  #define MAX_ENTRIES 1024
46  #define MAX_TESTS 100
47  static struct test {
48  	int fd;
49  	struct stat stat;
50  } tests[MAX_TESTS];
51  static void test_perror(const char *func, const char *msg)
52  {
53  	fprintf(stderr, &quot;%s %s() - %s: %s\n&quot;, testname, func, msg,
54  		strerror(errno));
55  }
56  static void test_error(const char *func, const char *msg, ...)
57  	__attribute__ ((format (printf, 2, 3)));
58  static void __start_test(const char *fmt, ...)
59  	__attribute__ ((format (printf, 1, 2)));
60  static void test_error(const char *func, const char *msg, ...)
61  {
62  	va_list ap;
63  	fprintf(stderr, &quot;%s %s() - &quot;, testname, func);
64  	va_start(ap, msg);
65  	vfprintf(stderr, msg, ap);
66  	va_end(ap);
67  	fprintf(stderr, &quot;\n&quot;);
68  }
69  static int is_dot_or_dotdot(const char *name) {
70      return name[0] == &#x27;.&#x27; &amp;&amp;
71             (name[1] == &#x27;\0&#x27; || (name[1] == &#x27;.&#x27; &amp;&amp; name[2] == &#x27;\0&#x27;));
72  }
73  static void success(void)
74  {
75  	fprintf(stderr, &quot;%s OK\n&quot;, testname);
76  }
77  #define this_test (&amp;tests[testnum-1])
78  #define next_test (&amp;tests[testnum])
79  static void __start_test(const char *fmt, ...)
80  {
81  	unsigned int n;
82  	va_list ap;
83  	n = sprintf(testname, &quot;%3i [&quot;, testnum);
84  	va_start(ap, fmt);
85  	n += vsprintf(testname + n, fmt, ap);
86  	va_end(ap);
87  	sprintf(testname + n, &quot;]&quot;);
88  	sprintf(testfile, &quot;%s/testfile.%d&quot;, basepath, testnum);
89  	sprintf(testfile_r, &quot;%s/testfile.%d&quot;, basepath_r, testnum);
90  	if (testnum &gt; MAX_TESTS) {
91  		fprintf(stderr, &quot;%s - too many tests\n&quot;, testname);
92  		exit(1);
93  	}
94  	this_test-&gt;fd = -1;
95  }
96  #define start_test(msg, args...) { \
97  	testnum++; \
98  	if ((select_test &amp;&amp; testnum != select_test) || \
99  	    (testnum == skip_test)) { \
100  		return 0; \
101  	} \
102  	__start_test(msg, ##args);		\
103  }
104  #define PERROR(msg) test_perror(__FUNCTION__, msg)
105  #define ERROR(msg, args...) test_error(__FUNCTION__, msg, ##args)
106  #define ARRAY_SIZE(arr) (sizeof(arr) / sizeof((arr)[0]))
107  static int st_check_size(struct stat *st, int len)
108  {
109  	if (st-&gt;st_size != len) {
110  		ERROR(&quot;length %u instead of %u&quot;, (int) st-&gt;st_size,
111  		      (int) len);
112  		return -1;
113  	}
114  	return 0;
115  }
116  static int check_size(const char *path, int len)
117  {
118  	struct stat stbuf;
119  	int res = stat(path, &amp;stbuf);
120  	if (res == -1) {
121  		PERROR(&quot;stat&quot;);
122  		return -1;
123  	}
124  	return st_check_size(&amp;stbuf, len);
125  }
126  static int check_testfile_size(const char *path, int len)
127  {
128  	this_test-&gt;stat.st_size = len;
129  	return check_size(path, len);
130  }
131  static int st_check_type(struct stat *st, mode_t type)
132  {
133  	if ((st-&gt;st_mode &amp; S_IFMT) != type) {
134  		ERROR(&quot;type 0%o instead of 0%o&quot;, st-&gt;st_mode &amp; S_IFMT, type);
135  		return -1;
136  	}
137  	return 0;
138  }
139  static int check_type(const char *path, mode_t type)
140  {
141  	struct stat stbuf;
142  	int res = lstat(path, &amp;stbuf);
143  	if (res == -1) {
144  		PERROR(&quot;lstat&quot;);
145  		return -1;
146  	}
147  	return st_check_type(&amp;stbuf, type);
148  }
149  static int st_check_mode(struct stat *st, mode_t mode)
150  {
151  	if ((st-&gt;st_mode &amp; ALLPERMS) != mode) {
152  		ERROR(&quot;mode 0%o instead of 0%o&quot;, st-&gt;st_mode &amp; ALLPERMS,
153  		      mode);
154  		return -1;
155  	}
156  	return 0;
157  }
158  static int check_mode(const char *path, mode_t mode)
159  {
160  	struct stat stbuf;
161  	int res = lstat(path, &amp;stbuf);
162  	if (res == -1) {
163  		PERROR(&quot;lstat&quot;);
164  		return -1;
165  	}
166  	return st_check_mode(&amp;stbuf, mode);
167  }
168  static int check_testfile_mode(const char *path, mode_t mode)
169  {
170  	this_test-&gt;stat.st_mode &amp;= ~ALLPERMS;
171  	this_test-&gt;stat.st_mode |= mode;
172  	return check_mode(path, mode);
173  }
174  static int check_times(const char *path, time_t atime, time_t mtime)
175  {
176  	int err = 0;
177  	struct stat stbuf;
178  	int res = lstat(path, &amp;stbuf);
179  	if (res == -1) {
180  		PERROR(&quot;lstat&quot;);
181  		return -1;
182  	}
183  	if (stbuf.st_atime != atime) {
184  		ERROR(&quot;atime %li instead of %li&quot;, stbuf.st_atime, atime);
185  		err--;
186  	}
187  	if (stbuf.st_mtime != mtime) {
188  		ERROR(&quot;mtime %li instead of %li&quot;, stbuf.st_mtime, mtime);
189  		err--;
190  	}
191  	if (err)
192  		return -1;
193  	return 0;
194  }
195  #if 0
196  static int fcheck_times(int fd, time_t atime, time_t mtime)
197  {
198  	int err = 0;
199  	struct stat stbuf;
200  	int res = fstat(fd, &amp;stbuf);
201  	if (res == -1) {
202  		PERROR(&quot;fstat&quot;);
203  		return -1;
204  	}
205  	if (stbuf.st_atime != atime) {
206  		ERROR(&quot;atime %li instead of %li&quot;, stbuf.st_atime, atime);
207  		err--;
208  	}
209  	if (stbuf.st_mtime != mtime) {
210  		ERROR(&quot;mtime %li instead of %li&quot;, stbuf.st_mtime, mtime);
211  		err--;
212  	}
213  	if (err)
214  		return -1;
215  	return 0;
216  }
217  #endif
218  static int st_check_nlink(struct stat *st, nlink_t nlink)
219  {
220  	if (st-&gt;st_nlink != nlink) {
221  		ERROR(&quot;nlink %li instead of %li&quot;, (long) st-&gt;st_nlink,
222  		      (long) nlink);
223  		return -1;
224  	}
225  	return 0;
226  }
227  static int check_nlink(const char *path, nlink_t nlink)
228  {
229  	struct stat stbuf;
230  	int res = lstat(path, &amp;stbuf);
231  	if (res == -1) {
232  		PERROR(&quot;lstat&quot;);
233  		return -1;
234  	}
235  	return st_check_nlink(&amp;stbuf, nlink);
236  }
237  static int fcheck_stat(int fd, int flags, struct stat *st)
238  {
239  	struct stat stbuf;
240  	int res = fstat(fd, &amp;stbuf);
241  	if (res == -1) {
242  		if (flags &amp; O_PATH) {
243  			if (errno == ESTALE || errno == EIO ||
244  			    errno == ENOENT || errno == EBADF)
245  				return 0;
246  		}
247  		PERROR(&quot;fstat&quot;);
248  		return -1;
249  	}
250  	int err = 0;
251  	err += st_check_type(&amp;stbuf, st-&gt;st_mode &amp; S_IFMT);
252  	err += st_check_mode(&amp;stbuf, st-&gt;st_mode &amp; ALLPERMS);
253  	err += st_check_size(&amp;stbuf, st-&gt;st_size);
254  	err += st_check_nlink(&amp;stbuf, st-&gt;st_nlink);
255  	return err;
256  }
257  static int check_nonexist(const char *path)
258  {
259  	struct stat stbuf;
260  	int res = lstat(path, &amp;stbuf);
261  	if (res == 0) {
262  		ERROR(&quot;file should not exist&quot;);
263  		return -1;
264  	}
265  	if (errno != ENOENT) {
266  		ERROR(&quot;file should not exist: %s&quot;, strerror(errno));
267  		return -1;
268  	}
269  	return 0;
270  }
271  static int check_buffer(const char *buf, const char *data, unsigned len)
272  {
273  	if (memcmp(buf, data, len) != 0) {
274  		ERROR(&quot;data mismatch&quot;);
275  		return -1;
276  	}
277  	return 0;
278  }
279  static int check_data(const char *path, const char *data, int offset,
280  		      unsigned len)
281  {
282  	char buf[4096];
283  	int res;
284  	int fd = open(path, O_RDONLY);
285  	if (fd == -1) {
286  		PERROR(&quot;open&quot;);
287  		return -1;
288  	}
289  	if (lseek(fd, offset, SEEK_SET) == (off_t) -1) {
290  		PERROR(&quot;lseek&quot;);
291  		close(fd);
292  		return -1;
293  	}
294  	while (len) {
295  		int rdlen = len &lt; sizeof(buf) ? len : sizeof(buf);
296  		res = read(fd, buf, rdlen);
297  		if (res == -1) {
298  			PERROR(&quot;read&quot;);
299  			close(fd);
300  			return -1;
301  		}
302  		if (res != rdlen) {
303  			ERROR(&quot;short read: %u instead of %u&quot;, res, rdlen);
304  			close(fd);
305  			return -1;
306  		}
307  		if (check_buffer(buf, data, rdlen) != 0) {
308  			close(fd);
309  			return -1;
310  		}
311  		data += rdlen;
312  		len -= rdlen;
313  	}
314  	res = close(fd);
315  	if (res == -1) {
316  		PERROR(&quot;close&quot;);
317  		return -1;
318  	}
319  	return 0;
320  }
321  static int fcheck_data(int fd, const char *data, int offset,
322  		       unsigned len)
323  {
324  	char buf[4096];
325  	int res;
326  	if (lseek(fd, offset, SEEK_SET) == (off_t) -1) {
327  		PERROR(&quot;lseek&quot;);
328  		return -1;
329  	}
330  	while (len) {
331  		int rdlen = len &lt; sizeof(buf) ? len : sizeof(buf);
332  		res = read(fd, buf, rdlen);
333  		if (res == -1) {
334  			PERROR(&quot;read&quot;);
335  			return -1;
336  		}
337  		if (res != rdlen) {
338  			ERROR(&quot;short read: %u instead of %u&quot;, res, rdlen);
339  			return -1;
340  		}
341  		if (check_buffer(buf, data, rdlen) != 0) {
342  			return -1;
343  		}
344  		data += rdlen;
345  		len -= rdlen;
346  	}
347  	return 0;
348  }
349  static int check_dir_contents(const char *path, const char **contents)
350  {
351  	int i;
352  	int res;
353  	int err = 0;
354  	int found[MAX_ENTRIES];
355  	const char *cont[MAX_ENTRIES];
356  	DIR *dp;
357  	for (i = 0; contents[i]; i++) {
358  		assert(i &lt; MAX_ENTRIES - 3);
359  		found[i] = 0;
360  		cont[i] = contents[i];
361  	}
362  	cont[i] = NULL;
363  	dp = opendir(path);
364  	if (dp == NULL) {
365  		PERROR(&quot;opendir&quot;);
366  		return -1;
367  	}
368  	memset(found, 0, sizeof(found));
369  	while(1) {
370  		struct dirent *de;
371  		errno = 0;
372  		de = readdir(dp);
373  		if (de == NULL) {
374  			if (errno) {
375  				PERROR(&quot;readdir&quot;);
376  				closedir(dp);
377  				return -1;
378  			}
379  			break;
380  		}
381  		if (is_dot_or_dotdot(de-&gt;d_name))
382  			continue;
383  		for (i = 0; cont[i] != NULL; i++) {
384  			assert(i &lt; MAX_ENTRIES);
385  			if (strcmp(cont[i], de-&gt;d_name) == 0) {
386  				if (found[i]) {
387  					ERROR(&quot;duplicate entry &lt;%s&gt;&quot;,
388  					      de-&gt;d_name);
389  					err--;
390  				} else
391  					found[i] = 1;
392  				break;
393  			}
394  		}
395  		if (!cont[i]) {
396  			ERROR(&quot;unexpected entry &lt;%s&gt;&quot;, de-&gt;d_name);
397  			err --;
398  		}
399  	}
400  	for (i = 0; cont[i] != NULL; i++) {
401  		if (!found[i]) {
402  			ERROR(&quot;missing entry &lt;%s&gt;&quot;, cont[i]);
403  			err--;
404  		}
405  	}
406  	res = closedir(dp);
407  	if (res == -1) {
408  		PERROR(&quot;closedir&quot;);
409  		return -1;
410  	}
411  	if (err)
412  		return -1;
413  	return 0;
414  }
415  static int create_file(const char *path, const char *data, int len)
416  {
417  	int res;
418  	int fd;
419  	unlink(path);
420  	fd = creat(path, 0644);
421  	if (fd == -1) {
422  		PERROR(&quot;creat&quot;);
423  		return -1;
424  	}
425  	if (len) {
426  		res = write(fd, data, len);
427  		if (res == -1) {
428  			PERROR(&quot;write&quot;);
429  			close(fd);
430  			return -1;
431  		}
432  		if (res != len) {
433  			ERROR(&quot;write is short: %u instead of %u&quot;, res, len);
434  			close(fd);
435  			return -1;
436  		}
437  	}
438  	res = close(fd);
439  	if (res == -1) {
440  		PERROR(&quot;close&quot;);
441  		return -1;
442  	}
443  	res = check_type(path, S_IFREG);
444  	if (res == -1)
445  		return -1;
446  	res = check_mode(path, 0644);
447  	if (res == -1)
448  		return -1;
449  	res = check_nlink(path, 1);
450  	if (res == -1)
451  		return -1;
452  	res = check_size(path, len);
453  	if (res == -1)
454  		return -1;
455  	if (len) {
456  		res = check_data(path, data, 0, len);
457  		if (res == -1)
458  			return -1;
459  	}
460  	return 0;
461  }
462  static int create_path_fd(const char *path, const char *data, int len)
463  {
464  	int path_fd;
465  	int res;
466  	res = create_file(path, data, len);
467  	if (res == -1)
468  		return -1;
469  	path_fd = open(path, O_PATH);
470  	if (path_fd == -1)
471  		PERROR(&quot;open(O_PATH)&quot;);
472  	return path_fd;
473  }
474  static int create_testfile(const char *path, const char *data, int len)
475  {
476  	struct test *t = this_test;
477  	struct stat *st = &amp;t-&gt;stat;
478  	int res, fd;
479  	if (t-&gt;fd &gt; 0) {
480  		ERROR(&quot;testfile already created&quot;);
481  		return -1;
482  	}
483  	fd = create_path_fd(path, data, len);
484  	if (fd == -1)
485  		return -1;
486  	t-&gt;fd = fd;
487  	res = fstat(fd, st);
488  	if (res == -1) {
489  		PERROR(&quot;fstat&quot;);
490  		return -1;
491  	}
492  	return 0;
493  }
494  static int check_unlinked_testfile(int fd)
495  {
496  	struct stat *st = &amp;this_test-&gt;stat;
497  	st-&gt;st_nlink = 0;
498  	return fcheck_stat(fd, O_PATH, st);
499  }
500  static int check_unlinked_testfiles(void)
501  {
502  	int fd;
503  	int res, err = 0;
504  	int num = testnum;
505  	if (!unlinked_test)
506  		return 0;
507  	testnum = 0;
508  	while (testnum &lt; num) {
509  		fd = next_test-&gt;fd;
510  		start_test(&quot;check_unlinked_testfile&quot;);
511  		if (fd == -1)
512  			continue;
513  		err += check_unlinked_testfile(fd);
514  		res = close(fd);
515  		if (res == -1) {
516  			PERROR(&quot;close(test_fd)&quot;);
517  			err--;
518  		}
519  	}
520  	if (err) {
521  		fprintf(stderr, &quot;%i unlinked testfile checks failed\n&quot;, -err);
522  		return 1;
523  	}
524  	return err;
525  }
526  static int cleanup_dir(const char *path, const char **dir_files, int quiet)
527  {
528  	int i;
529  	int err = 0;
530  	for (i = 0; dir_files[i]; i++) {
531  		int res;
532  		char fpath[1280];
533  		sprintf(fpath, &quot;%s/%s&quot;, path, dir_files[i]);
534  		res = unlink(fpath);
535  		if (res == -1 &amp;&amp; !quiet) {
536  			PERROR(&quot;unlink&quot;);
537  			err --;
538  		}
539  	}
540  	if (err)
541  		return -1;
542  	return 0;
543  }
544  static int create_dir(const char *path, const char **dir_files)
545  {
546  	int res;
547  	int i;
548  	rmdir(path);
549  	res = mkdir(path, 0755);
550  	if (res == -1) {
551  		PERROR(&quot;mkdir&quot;);
552  		return -1;
553  	}
554  	res = check_type(path, S_IFDIR);
555  	if (res == -1)
556  		return -1;
557  	res = check_mode(path, 0755);
558  	if (res == -1)
559  		return -1;
560  	for (i = 0; dir_files[i]; i++) {
561  		char fpath[1280];
562  		sprintf(fpath, &quot;%s/%s&quot;, path, dir_files[i]);
563  		res = create_file(fpath, &quot;&quot;, 0);
564  		if (res == -1) {
565  			cleanup_dir(path, dir_files, 1);
566  			return -1;
567  		}
568  	}
569  	res = check_dir_contents(path, dir_files);
570  	if (res == -1) {
571  		cleanup_dir(path, dir_files, 1);
572  		return -1;
573  	}
574  	return 0;
575  }
576  static int test_truncate(int len)
577  {
578  	const char *data = testdata;
579  	int datalen = testdatalen;
580  	int res;
581  	start_test(&quot;truncate(%u)&quot;, (int) len);
582  	res = create_testfile(testfile, data, datalen);
583  	if (res == -1)
584  		return -1;
585  	res = truncate(testfile, len);
586  	if (res == -1) {
587  		PERROR(&quot;truncate&quot;);
588  		return -1;
589  	}
590  	res = check_testfile_size(testfile, len);
591  	if (res == -1)
592  		return -1;
593  	if (len &gt; 0) {
594  		if (len &lt;= datalen) {
595  			res = check_data(testfile, data, 0, len);
596  			if (res == -1)
597  				return -1;
598  		} else {
599  			res = check_data(testfile, data, 0, datalen);
600  			if (res == -1)
601  				return -1;
602  			res = check_data(testfile, zerodata, datalen,
603  					 len - datalen);
604  			if (res == -1)
605  				return -1;
606  		}
607  	}
608  	res = unlink(testfile);
609  	if (res == -1) {
610  		PERROR(&quot;unlink&quot;);
611  		return -1;
612  	}
613  	res = check_nonexist(testfile);
614  	if (res == -1)
615  		return -1;
616  	success();
617  	return 0;
618  }
619  static int test_ftruncate(int len, int mode)
620  {
621  	const char *data = testdata;
622  	int datalen = testdatalen;
623  	int res;
624  	int fd;
625  	start_test(&quot;ftruncate(%u) mode: 0%03o&quot;, len, mode);
626  	res = create_testfile(testfile, data, datalen);
627  	if (res == -1)
628  		return -1;
629  	fd = open(testfile, O_WRONLY);
630  	if (fd == -1) {
631  		PERROR(&quot;open&quot;);
632  		return -1;
633  	}
634  	res = fchmod(fd, mode);
635  	if (res == -1) {
636  		PERROR(&quot;fchmod&quot;);
637  		close(fd);
638  		return -1;
639  	}
640  	res = check_testfile_mode(testfile, mode);
641  	if (res == -1) {
642  		close(fd);
643  		return -1;
644  	}
645  	res = ftruncate(fd, len);
646  	if (res == -1) {
647  		PERROR(&quot;ftruncate&quot;);
648  		close(fd);
649  		return -1;
650  	}
651  	close(fd);
652  	res = check_testfile_size(testfile, len);
653  	if (res == -1)
654  		return -1;
655  	if (len &gt; 0) {
656  		if (len &lt;= datalen) {
657  			res = check_data(testfile, data, 0, len);
658  			if (res == -1)
659  				return -1;
660  		} else {
661  			res = check_data(testfile, data, 0, datalen);
662  			if (res == -1)
663  				return -1;
664  			res = check_data(testfile, zerodata, datalen,
665  					 len - datalen);
666  			if (res == -1)
667  				return -1;
668  		}
669  	}
670  	res = unlink(testfile);
671  	if (res == -1) {
672  		PERROR(&quot;unlink&quot;);
673  		return -1;
674  	}
675  	res = check_nonexist(testfile);
676  	if (res == -1)
677  		return -1;
678  	success();
679  	return 0;
680  }
681  static int test_seekdir(void)
682  {
683  	int i;
684  	int res;
685  	DIR *dp;
686  	struct dirent *de;
687  	start_test(&quot;seekdir&quot;);
688  	res = create_dir(testdir, testdir_files);
689  	if (res == -1)
690  		return res;
691  	dp = opendir(testdir);
692  	if (dp == NULL) {
693  		PERROR(&quot;opendir&quot;);
694  		return -1;
695  	}
696  	for (i = 0; i &lt; ARRAY_SIZE(seekdir_offsets); i++) {
697  		seekdir_offsets[i] = telldir(dp);
698  		errno = 0;
699  		de = readdir(dp);
700  		if (de == NULL) {
701  			if (errno) {
702  				PERROR(&quot;readdir&quot;);
703  				goto fail;
704  			}
705  			break;
706  		}
707  	}
708  	while (de)
709  		de = readdir(dp);
710  	for (i--; i &gt;= 0; i--) {
711  		seekdir(dp, seekdir_offsets[i]);
712  		de = readdir(dp);
713  		if (de == NULL) {
714  			ERROR(&quot;Unexpected end of directory after seekdir()&quot;);
715  			goto fail;
716  		}
717  	}
718  	closedir(dp);
719  	res = cleanup_dir(testdir, testdir_files, 0);
720  	if (!res)
721  		success();
722  	return res;
723  fail:
724  	closedir(dp);
725  	cleanup_dir(testdir, testdir_files, 1);
726  	return -1;
727  }
728  #ifdef HAVE_COPY_FILE_RANGE
729  static int test_copy_file_range(void)
730  {
731  	const char *data = testdata;
732  	int datalen = testdatalen;
733  	int err = 0;
734  	int res;
735  	int fd_in, fd_out;
736  	off_t pos_in = 0, pos_out = 0;
737  	start_test(&quot;copy_file_range&quot;);
738  	unlink(testfile);
739  	fd_in = open(testfile, O_CREAT | O_RDWR, 0644);
740  	if (fd_in == -1) {
741  		PERROR(&quot;creat&quot;);
742  		return -1;
743  	}
744  	res = write(fd_in, data, datalen);
745  	if (res == -1) {
746  		PERROR(&quot;write&quot;);
747  		close(fd_in);
748  		return -1;
749  	}
750  	if (res != datalen) {
751  		ERROR(&quot;write is short: %u instead of %u&quot;, res, datalen);
752  		close(fd_in);
753  		return -1;
754  	}
755  	unlink(testfile2);
756  	fd_out = creat(testfile2, 0644);
757  	if (fd_out == -1) {
758  		PERROR(&quot;creat&quot;);
759  		close(fd_in);
760  		return -1;
761  	}
762  	res = copy_file_range(fd_in, &amp;pos_in, fd_out, &amp;pos_out, datalen, 0);
763  	if (res == -1) {
764  		PERROR(&quot;copy_file_range&quot;);
765  		close(fd_in);
766  		close(fd_out);
767  		return -1;
768  	}
769  	if (res != datalen) {
770  		ERROR(&quot;copy is short: %u instead of %u&quot;, res, datalen);
771  		close(fd_in);
772  		close(fd_out);
773  		return -1;
774  	}
775  	res = close(fd_in);
776  	if (res == -1) {
777  		PERROR(&quot;close&quot;);
778  		close(fd_out);
779  		return -1;
780  	}
781  	res = close(fd_out);
782  	if (res == -1) {
783  		PERROR(&quot;close&quot;);
784  		return -1;
785  	}
786  	err = check_data(testfile2, data, 0, datalen);
787  	res = unlink(testfile);
788  	if (res == -1) {
789  		PERROR(&quot;unlink&quot;);
790  		return -1;
791  	}
792  	res = check_nonexist(testfile);
793  	if (res == -1)
794  		return -1;
795  	if (err)
796  		return -1;
797  	res = unlink(testfile2);
798  	if (res == -1) {
799  		PERROR(&quot;unlink&quot;);
800  		return -1;
801  	}
802  	res = check_nonexist(testfile2);
803  	if (res == -1)
804  		return -1;
805  	if (err)
806  		return -1;
807  	success();
808  	return 0;
809  }
810  #else
811  static int test_copy_file_range(void)
812  {
813  	return 0;
814  }
815  #endif
816  static int test_utime(void)
817  {
818  	struct utimbuf utm;
819  	time_t atime = 987631200;
820  	time_t mtime = 123116400;
821  	int res;
822  	start_test(&quot;utime&quot;);
823  	res = create_testfile(testfile, NULL, 0);
824  	if (res == -1)
825  		return -1;
826  	utm.actime = atime;
827  	utm.modtime = mtime;
828  	res = utime(testfile, &amp;utm);
829  	if (res == -1) {
830  		PERROR(&quot;utime&quot;);
831  		return -1;
832  	}
833  	res = check_times(testfile, atime, mtime);
834  	if (res == -1) {
835  		return -1;
836  	}
837  	res = unlink(testfile);
838  	if (res == -1) {
839  		PERROR(&quot;unlink&quot;);
840  		return -1;
841  	}
842  	res = check_nonexist(testfile);
843  	if (res == -1)
844  		return -1;
845  	success();
846  	return 0;
847  }
848  static int test_create(void)
849  {
850  	const char *data = testdata;
851  	int datalen = testdatalen;
852  	int err = 0;
853  	int res;
854  	int fd;
855  	start_test(&quot;create&quot;);
856  	unlink(testfile);
857  	fd = creat(testfile, 0644);
858  	if (fd == -1) {
859  		PERROR(&quot;creat&quot;);
860  		return -1;
861  	}
862  	res = write(fd, data, datalen);
863  	if (res == -1) {
864  		PERROR(&quot;write&quot;);
865  		close(fd);
866  		return -1;
867  	}
868  	if (res != datalen) {
869  		ERROR(&quot;write is short: %u instead of %u&quot;, res, datalen);
870  		close(fd);
871  		return -1;
872  	}
873  	res = close(fd);
874  	if (res == -1) {
875  		PERROR(&quot;close&quot;);
876  		return -1;
877  	}
878  	res = check_type(testfile, S_IFREG);
879  	if (res == -1)
880  		return -1;
881  	err += check_mode(testfile, 0644);
882  	err += check_nlink(testfile, 1);
883  	err += check_size(testfile, datalen);
884  	err += check_data(testfile, data, 0, datalen);
885  	res = unlink(testfile);
886  	if (res == -1) {
887  		PERROR(&quot;unlink&quot;);
888  		return -1;
889  	}
890  	res = check_nonexist(testfile);
891  	if (res == -1)
892  		return -1;
893  	if (err)
894  		return -1;
895  	success();
896  	return 0;
897  }
898  static int test_create_unlink(void)
899  {
900  	const char *data = testdata;
901  	int datalen = testdatalen;
902  	int err = 0;
<span onclick='openModal()' class='match'>903  	int res;
904  	int fd;
905  	start_test(&quot;create+unlink&quot;);
906  	unlink(testfile);
907  	fd = open(testfile, O_CREAT | O_RDWR | O_TRUNC, 0644);
</span>908  	if (fd == -1) {
909  		PERROR(&quot;creat&quot;);
910  		return -1;
911  	}
912  	res = unlink(testfile);
913  	if (res == -1) {
914  		PERROR(&quot;unlink&quot;);
915  		close(fd);
916  		return -1;
917  	}
918  	res = check_nonexist(testfile);
919  	if (res == -1) {
920  		close(fd);
921  		return -1;
922  	}
923  	res = write(fd, data, datalen);
924  	if (res == -1) {
925  		PERROR(&quot;write&quot;);
926  		close(fd);
927  		return -1;
928  	}
929  	if (res != datalen) {
930  		ERROR(&quot;write is short: %u instead of %u&quot;, res, datalen);
931  		close(fd);
932  		return -1;
933  	}
934  	struct stat st = {
935  		.st_mode = S_IFREG | 0644,
936  		.st_size = datalen,
937  	};
938  	err = fcheck_stat(fd, O_RDWR, &amp;st);
939  	err += fcheck_data(fd, data, 0, datalen);
940  	res = close(fd);
941  	if (res == -1) {
942  		PERROR(&quot;close&quot;);
943  		err--;
944  	}
945  	if (err)
946  		return -1;
947  	success();
948  	return 0;
949  }
950  #ifndef __FreeBSD__
951  static int test_mknod(void)
952  {
953  	int err = 0;
954  	int res;
955  	start_test(&quot;mknod&quot;);
956  	unlink(testfile);
957  	res = mknod(testfile, 0644, 0);
958  	if (res == -1) {
959  		PERROR(&quot;mknod&quot;);
960  		return -1;
961  	}
962  	res = check_type(testfile, S_IFREG);
963  	if (res == -1)
964  		return -1;
965  	err += check_mode(testfile, 0644);
966  	err += check_nlink(testfile, 1);
967  	err += check_size(testfile, 0);
968  	res = unlink(testfile);
969  	if (res == -1) {
970  		PERROR(&quot;unlink&quot;);
971  		return -1;
972  	}
973  	res = check_nonexist(testfile);
974  	if (res == -1)
975  		return -1;
976  	if (err)
977  		return -1;
978  	success();
979  	return 0;
980  }
981  #endif
982  #define test_open(exist, flags, mode)  do_test_open(exist, flags, #flags, mode)
983  static int do_test_open(int exist, int flags, const char *flags_str, int mode)
984  {
985  	char buf[4096];
986  	const char *data = testdata;
987  	int datalen = testdatalen;
988  	unsigned currlen = 0;
989  	int err = 0;
990  	int res;
991  	int fd;
992  	off_t off;
993  	start_test(&quot;open(%s, %s, 0%03o)&quot;, exist ? &quot;+&quot; : &quot;-&quot;, flags_str, mode);
994  	unlink(testfile);
995  	if (exist) {
996  		res = create_file(testfile_r, testdata2, testdata2len);
997  		if (res == -1)
998  			return -1;
999  		currlen = testdata2len;
1000  	}
1001  	fd = open(testfile, flags, mode);
1002  	if ((flags &amp; O_CREAT) &amp;&amp; (flags &amp; O_EXCL) &amp;&amp; exist) {
1003  		if (fd != -1) {
1004  			ERROR(&quot;open should have failed&quot;);
1005  			close(fd);
1006  			return -1;
1007  		} else if (errno == EEXIST)
1008  			goto succ;
1009  	}
1010  	if (!(flags &amp; O_CREAT) &amp;&amp; !exist) {
1011  		if (fd != -1) {
1012  			ERROR(&quot;open should have failed&quot;);
1013  			close(fd);
1014  			return -1;
1015  		} else if (errno == ENOENT)
1016  			goto succ;
1017  	}
1018  	if (fd == -1) {
1019  		PERROR(&quot;open&quot;);
1020  		return -1;
1021  	}
1022  	if (flags &amp; O_TRUNC)
1023  		currlen = 0;
1024  	err += check_type(testfile, S_IFREG);
1025  	if (exist)
1026  		err += check_mode(testfile, 0644);
1027  	else
1028  		err += check_mode(testfile, mode);
1029  	err += check_nlink(testfile, 1);
1030  	err += check_size(testfile, currlen);
1031  	if (exist &amp;&amp; !(flags &amp; O_TRUNC) &amp;&amp; (mode &amp; S_IRUSR))
1032  		err += check_data(testfile, testdata2, 0, testdata2len);
1033  	res = write(fd, data, datalen);
1034  	if ((flags &amp; O_ACCMODE) != O_RDONLY) {
1035  		if (res == -1) {
1036  			PERROR(&quot;write&quot;);
1037  			err --;
1038  		} else if (res != datalen) {
1039  			ERROR(&quot;write is short: %u instead of %u&quot;, res, datalen);
1040  			err --;
1041  		} else {
1042  			if (datalen &gt; (int) currlen)
1043  				currlen = datalen;
1044  			err += check_size(testfile, currlen);
1045  			if (mode &amp; S_IRUSR) {
1046  				err += check_data(testfile, data, 0, datalen);
1047  				if (exist &amp;&amp; !(flags &amp; O_TRUNC) &amp;&amp;
1048  				    testdata2len &gt; datalen)
1049  					err += check_data(testfile,
1050  							  testdata2 + datalen,
1051  							  datalen,
1052  							  testdata2len - datalen);
1053  			}
1054  		}
1055  	} else {
1056  		if (res != -1) {
1057  			ERROR(&quot;write should have failed&quot;);
1058  			err --;
1059  		} else if (errno != EBADF) {
1060  			PERROR(&quot;write&quot;);
1061  			err --;
1062  		}
1063  	}
1064  	off = lseek(fd, SEEK_SET, 0);
1065  	if (off == (off_t) -1) {
1066  		PERROR(&quot;lseek&quot;);
1067  		err--;
1068  	} else if (off != 0) {
1069  		ERROR(&quot;offset should have returned 0&quot;);
1070  		err --;
1071  	}
1072  	res = read(fd, buf, sizeof(buf));
1073  	if ((flags &amp; O_ACCMODE) != O_WRONLY) {
1074  		if (res == -1) {
1075  			PERROR(&quot;read&quot;);
1076  			err--;
1077  		} else {
1078  			int readsize =
1079  				currlen &lt; sizeof(buf) ? currlen : sizeof(buf);
1080  			if (res != readsize) {
1081  				ERROR(&quot;read is short: %i instead of %u&quot;,
1082  				      res, readsize);
1083  				err--;
1084  			} else {
1085  				if ((flags &amp; O_ACCMODE) != O_RDONLY) {
1086  					err += check_buffer(buf, data, datalen);
1087  					if (exist &amp;&amp; !(flags &amp; O_TRUNC) &amp;&amp;
1088  					    testdata2len &gt; datalen)
1089  						err += check_buffer(buf + datalen,
1090  								    testdata2 + datalen,
1091  								    testdata2len - datalen);
1092  				} else if (exist)
1093  					err += check_buffer(buf, testdata2,
1094  							    testdata2len);
1095  			}
1096  		}
1097  	} else {
1098  		if (res != -1) {
1099  			ERROR(&quot;read should have failed&quot;);
1100  			err --;
1101  		} else if (errno != EBADF) {
1102  			PERROR(&quot;read&quot;);
1103  			err --;
1104  		}
1105  	}
1106  	res = close(fd);
1107  	if (res == -1) {
1108  		PERROR(&quot;close&quot;);
1109  		return -1;
1110  	}
1111  	res = unlink(testfile);
1112  	if (res == -1) {
1113  		PERROR(&quot;unlink&quot;);
1114  		return -1;
1115  	}
1116  	res = check_nonexist(testfile);
1117  	if (res == -1)
1118  		return -1;
1119  	res = check_nonexist(testfile_r);
1120  	if (res == -1)
1121  		return -1;
1122  	if (err)
1123  		return -1;
1124  succ:
1125  	success();
1126  	return 0;
1127  }
1128  #define test_open_acc(flags, mode, err)	 \
1129  	do_test_open_acc(flags, #flags, mode, err)
1130  static int do_test_open_acc(int flags, const char *flags_str, int mode, int err)
1131  {
1132  	const char *data = testdata;
1133  	int datalen = testdatalen;
1134  	int res;
1135  	int fd;
1136  	start_test(&quot;open_acc(%s) mode: 0%03o message: &#x27;%s&#x27;&quot;, flags_str, mode,
1137  		   strerror(err));
1138  	unlink(testfile);
1139  	res = create_testfile(testfile, data, datalen);
1140  	if (res == -1)
1141  		return -1;
1142  	res = chmod(testfile, mode);
1143  	if (res == -1) {
1144  		PERROR(&quot;chmod&quot;);
1145  		return -1;
1146  	}
1147  	res = check_testfile_mode(testfile, mode);
1148  	if (res == -1)
1149  		return -1;
1150  	fd = open(testfile, flags);
1151  	if (fd == -1) {
1152  		if (err != errno) {
1153  			PERROR(&quot;open&quot;);
1154  			return -1;
1155  		}
1156  	} else {
1157  		if (err) {
1158  			ERROR(&quot;open should have failed&quot;);
1159  			close(fd);
1160  			return -1;
1161  		}
1162  		close(fd);
1163  	}
1164  	res = unlink(testfile);
1165  	if (res == -1) {
1166  		PERROR(&quot;unlink&quot;);
1167  		return -1;
1168  	}
1169  	res = check_nonexist(testfile);
1170  	if (res == -1)
1171  		return -1;
1172  	res = check_nonexist(testfile_r);
1173  	if (res == -1)
1174  		return -1;
1175  	success();
1176  	return 0;
1177  }
1178  static int test_symlink(void)
1179  {
1180  	char buf[1024];
1181  	const char *data = testdata;
1182  	int datalen = testdatalen;
1183  	int linklen = strlen(testfile);
1184  	int err = 0;
1185  	int res;
1186  	start_test(&quot;symlink&quot;);
1187  	res = create_testfile(testfile, data, datalen);
1188  	if (res == -1)
1189  		return -1;
1190  	unlink(testfile2);
1191  	res = symlink(testfile, testfile2);
1192  	if (res == -1) {
1193  		PERROR(&quot;symlink&quot;);
1194  		return -1;
1195  	}
1196  	res = check_type(testfile2, S_IFLNK);
1197  	if (res == -1)
1198  		return -1;
1199  	err += check_mode(testfile2, 0777);
1200  	err += check_nlink(testfile2, 1);
1201  	res = readlink(testfile2, buf, sizeof(buf));
1202  	if (res == -1) {
1203  		PERROR(&quot;readlink&quot;);
1204  		err--;
1205  	}
1206  	if (res != linklen) {
1207  		ERROR(&quot;short readlink: %u instead of %u&quot;, res, linklen);
1208  		err--;
1209  	}
1210  	if (memcmp(buf, testfile, linklen) != 0) {
1211  		ERROR(&quot;link mismatch&quot;);
1212  		err--;
1213  	}
1214  	err += check_size(testfile2, datalen);
1215  	err += check_data(testfile2, data, 0, datalen);
1216  	res = unlink(testfile2);
1217  	if (res == -1) {
1218  		PERROR(&quot;unlink&quot;);
1219  		return -1;
1220  	}
1221  	res = check_nonexist(testfile2);
1222  	if (res == -1)
1223  		return -1;
1224  	if (err)
1225  		return -1;
1226  	res = unlink(testfile);
1227  	if (res == -1) {
1228  		PERROR(&quot;unlink&quot;);
1229  		return -1;
1230  	}
1231  	res = check_nonexist(testfile);
1232  	if (res == -1)
1233  		return -1;
1234  	success();
1235  	return 0;
1236  }
1237  static int test_link(void)
1238  {
1239  	const char *data = testdata;
1240  	int datalen = testdatalen;
1241  	int err = 0;
1242  	int res;
1243  	start_test(&quot;link&quot;);
1244  	res = create_testfile(testfile, data, datalen);
1245  	if (res == -1)
1246  		return -1;
1247  	unlink(testfile2);
1248  	res = link(testfile, testfile2);
1249  	if (res == -1) {
1250  		PERROR(&quot;link&quot;);
1251  		return -1;
1252  	}
1253  	res = check_type(testfile2, S_IFREG);
1254  	if (res == -1)
1255  		return -1;
1256  	err += check_mode(testfile2, 0644);
1257  	err += check_nlink(testfile2, 2);
1258  	err += check_size(testfile2, datalen);
1259  	err += check_data(testfile2, data, 0, datalen);
1260  	res = unlink(testfile);
1261  	if (res == -1) {
1262  		PERROR(&quot;unlink&quot;);
1263  		return -1;
1264  	}
1265  	res = check_nonexist(testfile);
1266  	if (res == -1)
1267  		return -1;
1268  	err += check_nlink(testfile2, 1);
1269  	res = unlink(testfile2);
1270  	if (res == -1) {
1271  		PERROR(&quot;unlink&quot;);
1272  		return -1;
1273  	}
1274  	res = check_nonexist(testfile2);
1275  	if (res == -1)
1276  		return -1;
1277  	if (err)
1278  		return -1;
1279  	success();
1280  	return 0;
1281  }
1282  static int test_link2(void)
1283  {
1284  	const char *data = testdata;
1285  	int datalen = testdatalen;
1286  	int err = 0;
1287  	int res;
1288  	start_test(&quot;link-unlink-link&quot;);
1289  	res = create_testfile(testfile, data, datalen);
1290  	if (res == -1)
1291  		return -1;
1292  	unlink(testfile2);
1293  	res = link(testfile, testfile2);
1294  	if (res == -1) {
1295  		PERROR(&quot;link&quot;);
1296  		return -1;
1297  	}
1298  	res = unlink(testfile);
1299  	if (res == -1) {
1300  		PERROR(&quot;unlink&quot;);
1301  		return -1;
1302  	}
1303  	res = check_nonexist(testfile);
1304  	if (res == -1)
1305  		return -1;
1306  	res = link(testfile2, testfile);
1307  	if (res == -1) {
1308  		PERROR(&quot;link&quot;);
1309  	}
1310  	res = check_type(testfile, S_IFREG);
1311  	if (res == -1)
1312  		return -1;
1313  	err += check_mode(testfile, 0644);
1314  	err += check_nlink(testfile, 2);
1315  	err += check_size(testfile, datalen);
1316  	err += check_data(testfile, data, 0, datalen);
1317  	res = unlink(testfile2);
1318  	if (res == -1) {
1319  		PERROR(&quot;unlink&quot;);
1320  		return -1;
1321  	}
1322  	err += check_nlink(testfile, 1);
1323  	res = unlink(testfile);
1324  	if (res == -1) {
1325  		PERROR(&quot;unlink&quot;);
1326  		return -1;
1327  	}
1328  	res = check_nonexist(testfile);
1329  	if (res == -1)
1330  		return -1;
1331  	if (err)
1332  		return -1;
1333  	success();
1334  	return 0;
1335  }
1336  static int test_rename_file(void)
1337  {
1338  	const char *data = testdata;
1339  	int datalen = testdatalen;
1340  	int err = 0;
1341  	int res;
1342  	start_test(&quot;rename file&quot;);
1343  	res = create_testfile(testfile, data, datalen);
1344  	if (res == -1)
1345  		return -1;
1346  	unlink(testfile2);
1347  	res = rename(testfile, testfile2);
1348  	if (res == -1) {
1349  		PERROR(&quot;rename&quot;);
1350  		return -1;
1351  	}
1352  	res = check_nonexist(testfile);
1353  	if (res == -1)
1354  		return -1;
1355  	res = check_type(testfile2, S_IFREG);
1356  	if (res == -1)
1357  		return -1;
1358  	err += check_mode(testfile2, 0644);
1359  	err += check_nlink(testfile2, 1);
1360  	err += check_size(testfile2, datalen);
1361  	err += check_data(testfile2, data, 0, datalen);
1362  	res = unlink(testfile2);
1363  	if (res == -1) {
1364  		PERROR(&quot;unlink&quot;);
1365  		return -1;
1366  	}
1367  	res = check_nonexist(testfile2);
1368  	if (res == -1)
1369  		return -1;
1370  	if (err)
1371  		return -1;
1372  	success();
1373  	return 0;
1374  }
1375  static int test_rename_dir(void)
1376  {
1377  	int err = 0;
1378  	int res;
1379  	start_test(&quot;rename dir&quot;);
1380  	res = create_dir(testdir, testdir_files);
1381  	if (res == -1)
1382  		return -1;
1383  	rmdir(testdir2);
1384  	res = rename(testdir, testdir2);
1385  	if (res == -1) {
1386  		PERROR(&quot;rename&quot;);
1387  		cleanup_dir(testdir, testdir_files, 1);
1388  		return -1;
1389  	}
1390  	res = check_nonexist(testdir);
1391  	if (res == -1) {
1392  		cleanup_dir(testdir, testdir_files, 1);
1393  		return -1;
1394  	}
1395  	res = check_type(testdir2, S_IFDIR);
1396  	if (res == -1) {
1397  		cleanup_dir(testdir2, testdir_files, 1);
1398  		return -1;
1399  	}
1400  	err += check_mode(testdir2, 0755);
1401  	err += check_dir_contents(testdir2, testdir_files);
1402  	err += cleanup_dir(testdir2, testdir_files, 0);
1403  	res = rmdir(testdir2);
1404  	if (res == -1) {
1405  		PERROR(&quot;rmdir&quot;);
1406  		return -1;
1407  	}
1408  	res = check_nonexist(testdir2);
1409  	if (res == -1)
1410  		return -1;
1411  	if (err)
1412  		return -1;
1413  	success();
1414  	return 0;
1415  }
1416  static int test_rename_dir_loop(void)
1417  {
1418  #define PATH(p)		(snprintf(path, sizeof path, &quot;%s/%s&quot;, testdir, p), path)
1419  #define PATH2(p)	(snprintf(path2, sizeof path2, &quot;%s/%s&quot;, testdir, p), path2)
1420  	char path[1280], path2[1280];
1421  	int err = 0;
1422  	int res;
1423  	start_test(&quot;rename dir loop&quot;);
1424  	res = create_dir(testdir, testdir_files);
1425  	if (res == -1)
1426  		return -1;
1427  	res = mkdir(PATH(&quot;a&quot;), 0755);
1428  	if (res == -1) {
1429  		PERROR(&quot;mkdir&quot;);
1430  		goto fail;
1431  	}
1432  	res = rename(PATH(&quot;a&quot;), PATH2(&quot;a&quot;));
1433  	if (res == -1) {
1434  		PERROR(&quot;rename&quot;);
1435  		goto fail;
1436  	}
1437  	errno = 0;
1438  	res = rename(PATH(&quot;a&quot;), PATH2(&quot;a/b&quot;));
1439  	if (res == 0 || errno != EINVAL) {
1440  		PERROR(&quot;rename&quot;);
1441  		goto fail;
1442  	}
1443  	res = mkdir(PATH(&quot;a/b&quot;), 0755);
1444  	if (res == -1) {
1445  		PERROR(&quot;mkdir&quot;);
1446  		goto fail;
1447  	}
1448  	res = mkdir(PATH(&quot;a/b/c&quot;), 0755);
1449  	if (res == -1) {
1450  		PERROR(&quot;mkdir&quot;);
1451  		goto fail;
1452  	}
1453  	errno = 0;
1454  	res = rename(PATH(&quot;a&quot;), PATH2(&quot;a/b/c&quot;));
1455  	if (res == 0 || errno != EINVAL) {
1456  		PERROR(&quot;rename&quot;);
1457  		goto fail;
1458  	}
1459  	errno = 0;
1460  	res = rename(PATH(&quot;a&quot;), PATH2(&quot;a/b/c/a&quot;));
1461  	if (res == 0 || errno != EINVAL) {
1462  		PERROR(&quot;rename&quot;);
1463  		goto fail;
1464  	}
1465  	errno = 0;
1466  	res = rename(PATH(&quot;a/b/c&quot;), PATH2(&quot;a&quot;));
1467  	if (res == 0 || errno != ENOTEMPTY) {
1468  		PERROR(&quot;rename&quot;);
1469  		goto fail;
1470  	}
1471  	res = open(PATH(&quot;a/foo&quot;), O_CREAT, 0644);
1472  	if (res == -1) {
1473  		PERROR(&quot;open&quot;);
1474  		goto fail;
1475  	}
1476  	close(res);
1477  	res = rename(PATH(&quot;a/foo&quot;), PATH2(&quot;a/bar&quot;));
1478  	if (res == -1) {
1479  		PERROR(&quot;rename&quot;);
1480  		goto fail;
1481  	}
1482  	res = rename(PATH(&quot;a/bar&quot;), PATH2(&quot;a/foo&quot;));
1483  	if (res == -1) {
1484  		PERROR(&quot;rename&quot;);
1485  		goto fail;
1486  	}
1487  	res = rename(PATH(&quot;a/foo&quot;), PATH2(&quot;a/b/bar&quot;));
1488  	if (res == -1) {
1489  		PERROR(&quot;rename&quot;);
1490  		goto fail;
1491  	}
1492  	res = rename(PATH(&quot;a/b/bar&quot;), PATH2(&quot;a/foo&quot;));
1493  	if (res == -1) {
1494  		PERROR(&quot;rename&quot;);
1495  		goto fail;
1496  	}
1497  	res = rename(PATH(&quot;a/foo&quot;), PATH2(&quot;a/b/c/bar&quot;));
1498  	if (res == -1) {
1499  		PERROR(&quot;rename&quot;);
1500  		goto fail;
1501  	}
1502  	res = rename(PATH(&quot;a/b/c/bar&quot;), PATH2(&quot;a/foo&quot;));
1503  	if (res == -1) {
1504  		PERROR(&quot;rename&quot;);
1505  		goto fail;
1506  	}
1507  	res = open(PATH(&quot;a/bar&quot;), O_CREAT, 0644);
1508  	if (res == -1) {
1509  		PERROR(&quot;open&quot;);
1510  		goto fail;
1511  	}
1512  	close(res);
1513  	res = rename(PATH(&quot;a/foo&quot;), PATH2(&quot;a/bar&quot;));
1514  	if (res == -1) {
1515  		PERROR(&quot;rename&quot;);
1516  		goto fail;
1517  	}
1518  	unlink(PATH(&quot;a/bar&quot;));
1519  	res = rename(PATH(&quot;a/b&quot;), PATH2(&quot;a/d&quot;));
1520  	if (res == -1) {
1521  		PERROR(&quot;rename&quot;);
1522  		goto fail;
1523  	}
1524  	res = rename(PATH(&quot;a/d&quot;), PATH2(&quot;a/b&quot;));
1525  	if (res == -1) {
1526  		PERROR(&quot;rename&quot;);
1527  		goto fail;
1528  	}
1529  	res = mkdir(PATH(&quot;a/d&quot;), 0755);
1530  	if (res == -1) {
1531  		PERROR(&quot;mkdir&quot;);
1532  		goto fail;
1533  	}
1534  	res = rename(PATH(&quot;a/b&quot;), PATH2(&quot;a/d&quot;));
1535  	if (res == -1) {
1536  		PERROR(&quot;rename&quot;);
1537  		goto fail;
1538  	}
1539  	res = rename(PATH(&quot;a/d&quot;), PATH2(&quot;a/b&quot;));
1540  	if (res == -1) {
1541  		PERROR(&quot;rename&quot;);
1542  		goto fail;
1543  	}
1544  	res = mkdir(PATH(&quot;a/d&quot;), 0755);
1545  	if (res == -1) {
1546  		PERROR(&quot;mkdir&quot;);
1547  		goto fail;
1548  	}
1549  	res = mkdir(PATH(&quot;a/d/e&quot;), 0755);
1550  	if (res == -1) {
1551  		PERROR(&quot;mkdir&quot;);
1552  		goto fail;
1553  	}
1554  	errno = 0;
1555  	res = rename(PATH(&quot;a/b&quot;), PATH2(&quot;a/d&quot;));
1556  	if (res == 0 || (errno != ENOTEMPTY &amp;&amp; errno != EEXIST)) {
1557  		PERROR(&quot;rename&quot;);
1558  		goto fail;
1559  	}
1560  	rmdir(PATH(&quot;a/d/e&quot;));
1561  	rmdir(PATH(&quot;a/d&quot;));
1562   	rmdir(PATH(&quot;a/b/c&quot;));
1563  	rmdir(PATH(&quot;a/b&quot;));
1564  	rmdir(PATH(&quot;a&quot;));
1565  	err += cleanup_dir(testdir, testdir_files, 0);
1566  	res = rmdir(testdir);
1567  	if (res == -1) {
1568  		PERROR(&quot;rmdir&quot;);
1569  		goto fail;
1570  	}
1571  	res = check_nonexist(testdir);
1572  	if (res == -1)
1573  		return -1;
1574  	if (err)
1575  		return -1;
1576  	success();
1577  	return 0;
1578  fail:
1579  	unlink(PATH(&quot;a/bar&quot;));
1580  	rmdir(PATH(&quot;a/d/e&quot;));
1581  	rmdir(PATH(&quot;a/d&quot;));
1582   	rmdir(PATH(&quot;a/b/c&quot;));
1583  	rmdir(PATH(&quot;a/b&quot;));
1584  	rmdir(PATH(&quot;a&quot;));
1585  	cleanup_dir(testdir, testdir_files, 1);
1586  	rmdir(testdir);
1587  	return -1;
1588  #undef PATH2
1589  #undef PATH
1590  }
1591  #ifndef __FreeBSD__
1592  static int test_mkfifo(void)
1593  {
1594  	int res;
1595  	int err = 0;
1596  	start_test(&quot;mkfifo&quot;);
1597  	unlink(testfile);
1598  	res = mkfifo(testfile, 0644);
1599  	if (res == -1) {
1600  		PERROR(&quot;mkfifo&quot;);
1601  		return -1;
1602  	}
1603  	res = check_type(testfile, S_IFIFO);
1604  	if (res == -1)
1605  		return -1;
1606  	err += check_mode(testfile, 0644);
1607  	err += check_nlink(testfile, 1);
1608  	res = unlink(testfile);
1609  	if (res == -1) {
1610  		PERROR(&quot;unlink&quot;);
1611  		return -1;
1612  	}
1613  	res = check_nonexist(testfile);
1614  	if (res == -1)
1615  		return -1;
1616  	if (err)
1617  		return -1;
1618  	success();
1619  	return 0;
1620  }
1621  #endif
1622  static int test_mkdir(void)
1623  {
1624  	int res;
1625  	int err = 0;
1626  	const char *dir_contents[] = {NULL};
1627  	start_test(&quot;mkdir&quot;);
1628  	rmdir(testdir);
1629  	res = mkdir(testdir, 0755);
1630  	if (res == -1) {
1631  		PERROR(&quot;mkdir&quot;);
1632  		return -1;
1633  	}
1634  	res = check_type(testdir, S_IFDIR);
1635  	if (res == -1)
1636  		return -1;
1637  	err += check_mode(testdir, 0755);
1638  	err += check_dir_contents(testdir, dir_contents);
1639  	res = rmdir(testdir);
1640  	if (res == -1) {
1641  		PERROR(&quot;rmdir&quot;);
1642  		return -1;
1643  	}
1644  	res = check_nonexist(testdir);
1645  	if (res == -1)
1646  		return -1;
1647  	if (err)
1648  		return -1;
1649  	success();
1650  	return 0;
1651  }
1652  static int test_socket(void)
1653  {
1654  	struct sockaddr_un su;
1655  	int fd;
1656  	int res;
1657  	int err = 0;
1658      const size_t test_sock_len = strlen(testsock) + 1;
1659  	start_test(&quot;socket&quot;);
1660  	if (test_sock_len &gt; sizeof(su.sun_path)) {
1661  		fprintf(stderr, &quot;Need to shorten mount point by %zu chars\n&quot;,
1662  			strlen(testsock) + 1 - sizeof(su.sun_path));
1663  		return -1;
1664  	}
1665  	unlink(testsock);
1666  	fd = socket(AF_UNIX, SOCK_STREAM, 0);
1667  	if (fd &lt; 0) {
1668  		PERROR(&quot;socket&quot;);
1669  		return -1;
1670  	}
1671  	su.sun_family = AF_UNIX;
1672  	strncpy(su.sun_path, testsock, test_sock_len);
1673  	su.sun_path[sizeof(su.sun_path) - 1] = &#x27;\0&#x27;;
1674  	res = bind(fd, (struct sockaddr*)&amp;su, sizeof(su));
1675  	if (res == -1) {
1676  		PERROR(&quot;bind&quot;);
1677  		return -1;
1678  	}
1679  	res = check_type(testsock, S_IFSOCK);
1680  	if (res == -1) {
1681  		close(fd);
1682  		return -1;
1683  	}
1684  	err += check_nlink(testsock, 1);
1685  	close(fd);
1686  	res = unlink(testsock);
1687  	if (res == -1) {
1688  		PERROR(&quot;unlink&quot;);
1689  		return -1;
1690  	}
1691  	res = check_nonexist(testsock);
1692  	if (res == -1)
1693  		return -1;
1694  	if (err)
1695  		return -1;
1696  	success();
1697  	return 0;
1698  }
1699  #define test_create_ro_dir(flags)	 \
1700  	do_test_create_ro_dir(flags, #flags)
1701  static int do_test_create_ro_dir(int flags, const char *flags_str)
1702  {
1703  	int res;
1704  	int err = 0;
1705  	int fd;
1706  	start_test(&quot;open(%s) in read-only directory&quot;, flags_str);
1707  	rmdir(testdir);
1708  	res = mkdir(testdir, 0555);
1709  	if (res == -1) {
1710  		PERROR(&quot;mkdir&quot;);
1711  		return -1;
1712  	}
1713  	fd = open(subfile, flags, 0644);
1714  	if (fd != -1) {
1715  		close(fd);
1716  		unlink(subfile);
1717  		ERROR(&quot;open should have failed&quot;);
1718  		err--;
1719  	} else {
1720  		res = check_nonexist(subfile);
1721  		if (res == -1)
1722  			err--;
1723  	}
1724  	unlink(subfile);
1725  	res = rmdir(testdir);
1726  	if (res == -1) {
1727  		PERROR(&quot;rmdir&quot;);
1728  		return -1;
1729  	}
1730  	res = check_nonexist(testdir);
1731  	if (res == -1)
1732  		return -1;
1733  	if (err)
1734  		return -1;
1735  	success();
1736  	return 0;
1737  }
1738  int main(int argc, char *argv[])
1739  {
1740  	int err = 0;
1741  	int a;
1742  	int is_root;
1743  	umask(0);
1744  	if (argc &lt; 2 || argc &gt; 4) {
1745  		fprintf(stderr, &quot;usage: %s testdir [:realdir] [[-]test#] [-u]\n&quot;, argv[0]);
1746  		return 1;
1747  	}
1748  	basepath = argv[1];
1749  	basepath_r = basepath;
1750  	for (a = 2; a &lt; argc; a++) {
1751  		char *endptr;
1752  		char *arg = argv[a];
1753  		if (arg[0] == &#x27;:&#x27;) {
1754  			basepath_r = arg + 1;
1755  		} else {
1756  			if (arg[0] == &#x27;-&#x27;) {
1757  				arg++;
1758  				if (arg[0] == &#x27;u&#x27;) {
1759  					unlinked_test = 1;
1760  					endptr = arg + 1;
1761  				} else {
1762  					skip_test = strtoul(arg, &amp;endptr, 10);
1763  				}
1764  			} else {
1765  				select_test = strtoul(arg, &amp;endptr, 10);
1766  			}
1767  			if (arg[0] == &#x27;\0&#x27; || *endptr != &#x27;\0&#x27;) {
1768  				fprintf(stderr, &quot;invalid option: &#x27;%s&#x27;\n&quot;, argv[a]);
1769  				return 1;
1770  			}
1771  		}
1772  	}
1773  	assert(strlen(basepath) &lt; 512);
1774  	assert(strlen(basepath_r) &lt; 512);
1775  	if (basepath[0] != &#x27;/&#x27;) {
1776  		fprintf(stderr, &quot;testdir must be an absolute path\n&quot;);
1777  		return 1;
1778  	}
1779  	sprintf(testfile, &quot;%s/testfile&quot;, basepath);
1780  	sprintf(testfile2, &quot;%s/testfile2&quot;, basepath);
1781  	sprintf(testdir, &quot;%s/testdir&quot;, basepath);
1782  	sprintf(testdir2, &quot;%s/testdir2&quot;, basepath);
1783  	sprintf(subfile, &quot;%s/subfile&quot;, testdir2);
1784  	sprintf(testsock, &quot;%s/testsock&quot;, basepath);
1785  	sprintf(testfile_r, &quot;%s/testfile&quot;, basepath_r);
1786  	sprintf(testfile2_r, &quot;%s/testfile2&quot;, basepath_r);
1787  	sprintf(testdir_r, &quot;%s/testdir&quot;, basepath_r);
1788  	sprintf(testdir2_r, &quot;%s/testdir2&quot;, basepath_r);
1789  	sprintf(subfile_r, &quot;%s/subfile&quot;, testdir2_r);
1790  	is_root = (geteuid() == 0);
1791  	err += test_create();
1792  	err += test_create_unlink();
1793  	err += test_symlink();
1794  	err += test_link();
1795  	err += test_link2();
1796  #ifndef __FreeBSD__	
1797  	err += test_mknod();
1798  	err += test_mkfifo();
1799  #endif
1800  	err += test_mkdir();
1801  	err += test_rename_file();
1802  	err += test_rename_dir();
1803  	err += test_rename_dir_loop();
1804  	err += test_seekdir();
1805  	err += test_socket();
1806  	err += test_utime();
1807  	err += test_truncate(0);
1808  	err += test_truncate(testdatalen / 2);
1809  	err += test_truncate(testdatalen);
1810  	err += test_truncate(testdatalen + 100);
1811  	err += test_ftruncate(0, 0600);
1812  	err += test_ftruncate(testdatalen / 2, 0600);
1813  	err += test_ftruncate(testdatalen, 0600);
1814  	err += test_ftruncate(testdatalen + 100, 0600);
1815  	err += test_ftruncate(0, 0400);
1816  	err += test_ftruncate(0, 0200);
1817  	err += test_ftruncate(0, 0000);
1818  	err += test_open(0, O_RDONLY, 0);
1819  	err += test_open(1, O_RDONLY, 0);
1820  	err += test_open(1, O_RDWR, 0);
1821  	err += test_open(1, O_WRONLY, 0);
1822  	err += test_open(0, O_RDWR | O_CREAT, 0600);
1823  	err += test_open(1, O_RDWR | O_CREAT, 0600);
1824  	err += test_open(0, O_RDWR | O_CREAT | O_TRUNC, 0600);
1825  	err += test_open(1, O_RDWR | O_CREAT | O_TRUNC, 0600);
1826  	err += test_open(0, O_RDONLY | O_CREAT, 0600);
1827  	err += test_open(0, O_RDONLY | O_CREAT, 0400);
1828  	err += test_open(0, O_RDONLY | O_CREAT, 0200);
1829  	err += test_open(0, O_RDONLY | O_CREAT, 0000);
1830  	err += test_open(0, O_WRONLY | O_CREAT, 0600);
1831  	err += test_open(0, O_WRONLY | O_CREAT, 0400);
1832  	err += test_open(0, O_WRONLY | O_CREAT, 0200);
1833  	err += test_open(0, O_WRONLY | O_CREAT, 0000);
1834  	err += test_open(0, O_RDWR | O_CREAT, 0400);
1835  	err += test_open(0, O_RDWR | O_CREAT, 0200);
1836  	err += test_open(0, O_RDWR | O_CREAT, 0000);
1837  	err += test_open(0, O_RDWR | O_CREAT | O_EXCL, 0600);
1838  	err += test_open(1, O_RDWR | O_CREAT | O_EXCL, 0600);
1839  	err += test_open(0, O_RDWR | O_CREAT | O_EXCL, 0000);
1840  	err += test_open(1, O_RDWR | O_CREAT | O_EXCL, 0000);
1841  	err += test_open_acc(O_RDONLY, 0600, 0);
1842  	err += test_open_acc(O_WRONLY, 0600, 0);
1843  	err += test_open_acc(O_RDWR,   0600, 0);
1844  	err += test_open_acc(O_RDONLY, 0400, 0);
1845  	err += test_open_acc(O_WRONLY, 0200, 0);
1846  	if(!is_root) {
1847  		err += test_open_acc(O_RDONLY | O_TRUNC, 0400, EACCES);
1848  		err += test_open_acc(O_WRONLY, 0400, EACCES);
1849  		err += test_open_acc(O_RDWR,   0400, EACCES);
1850  		err += test_open_acc(O_RDONLY, 0200, EACCES);
1851  		err += test_open_acc(O_RDWR,   0200, EACCES);
1852  		err += test_open_acc(O_RDONLY, 0000, EACCES);
1853  		err += test_open_acc(O_WRONLY, 0000, EACCES);
1854  		err += test_open_acc(O_RDWR,   0000, EACCES);
1855  	}
1856  	err += test_create_ro_dir(O_CREAT);
1857  	err += test_create_ro_dir(O_CREAT | O_EXCL);
1858  	err += test_create_ro_dir(O_CREAT | O_WRONLY);
1859  	err += test_create_ro_dir(O_CREAT | O_TRUNC);
1860  	err += test_copy_file_range();
1861  	unlink(testfile2);
1862  	unlink(testsock);
1863  	rmdir(testdir);
1864  	rmdir(testdir2);
1865  	if (err) {
1866  		fprintf(stderr, &quot;%i tests failed\n&quot;, -err);
1867  		return 1;
1868  	}
1869  	return check_unlinked_testfiles();
1870  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from libfuse-MDEwOlJlcG9zaXRvcnk0ODI5NjE3Nw==-flat-test_syscalls.c</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from libfuse-MDEwOlJlcG9zaXRvcnk0ODI5NjE3Nw==-flat-test_syscalls.c</div>
                </div>
                <div class="column column_space"><pre><code>853  	int res;
854  	int fd;
855  	start_test(&quot;create&quot;);
856  	unlink(testfile);
857  	fd = creat(testfile, 0644);
</pre></code></div>
                <div class="column column_space"><pre><code>903  	int res;
904  	int fd;
905  	start_test(&quot;create+unlink&quot;);
906  	unlink(testfile);
907  	fd = open(testfile, O_CREAT | O_RDWR | O_TRUNC, 0644);
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    