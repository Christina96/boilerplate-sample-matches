
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 59, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>Adafruit_nRF52_Arduino-MDEwOlJlcG9zaXRvcnk3NDM1NDcyOQ==-flat-nrfx_gpiote.c</h3>
            <pre><code>1  #include <nrfx.h>
2  #if NRFX_CHECK(NRFX_GPIOTE_ENABLED)
3  #include <nrfx_gpiote.h>
4  #include "nrf_bitmask.h"
5  #include <string.h>
6  #define NRFX_LOG_MODULE GPIOTE
7  #include <nrfx_log.h>
8  #define FORBIDDEN_HANDLER_ADDRESS ((nrfx_gpiote_evt_handler_t)UINT32_MAX)
9  #define PIN_NOT_USED              (-1)
10  #define PIN_USED                  (-2)
11  #define NO_CHANNELS               (-1)
12  #define POLARITY_FIELD_POS        (6)
13  #define POLARITY_FIELD_MASK       (0xC0)
14  NRFX_STATIC_ASSERT(NUMBER_OF_PINS <= (1 << POLARITY_FIELD_POS));
15  typedef struct
16  {
17      nrfx_gpiote_evt_handler_t handlers[GPIOTE_CH_NUM + NRFX_GPIOTE_CONFIG_NUM_OF_LOW_POWER_EVENTS];
18      int8_t                    pin_assignments[NUMBER_OF_PINS];
19      int8_t                    port_handlers_pins[NRFX_GPIOTE_CONFIG_NUM_OF_LOW_POWER_EVENTS];
20      uint8_t                   configured_pins[((NUMBER_OF_PINS)+7) / 8];
21      nrfx_drv_state_t          state;
22  } gpiote_control_block_t;
23  static gpiote_control_block_t m_cb;
24  static bool pin_in_use(uint32_t pin)
25  {
26      return (m_cb.pin_assignments[pin] != PIN_NOT_USED);
27  }
28  static bool pin_in_use_as_non_task_out(uint32_t pin)
29  {
30      return (m_cb.pin_assignments[pin] == PIN_USED);
31  }
32  static bool pin_in_use_by_te(uint32_t pin)
33  {
34      return (m_cb.pin_assignments[pin] >= 0 && m_cb.pin_assignments[pin] < GPIOTE_CH_NUM) ?
35              true : false;
36  }
37  static bool pin_in_use_by_port(uint32_t pin)
38  {
39      return (m_cb.pin_assignments[pin] >= GPIOTE_CH_NUM);
40  }
41  static bool pin_in_use_by_gpiote(uint32_t pin)
42  {
43      return (m_cb.pin_assignments[pin] >= 0);
44  }
45  static void pin_in_use_by_te_set(uint32_t                  pin,
46                                   uint32_t                  channel_id,
47                                   nrfx_gpiote_evt_handler_t handler,
48                                   bool                      is_channel)
49  {
50      m_cb.pin_assignments[pin] = channel_id;
51      m_cb.handlers[channel_id] = handler;
52      if (!is_channel)
53      {
54          m_cb.port_handlers_pins[channel_id - GPIOTE_CH_NUM] = (int8_t)pin;
55      }
56  }
57  static void pin_in_use_set(uint32_t pin)
58  {
59      m_cb.pin_assignments[pin] = PIN_USED;
60  }
61  static void pin_in_use_clear(uint32_t pin)
62  {
63      m_cb.pin_assignments[pin] = PIN_NOT_USED;
64  }
65  static void pin_configured_set(uint32_t pin)
66  {
67      nrf_bitmask_bit_set(pin, m_cb.configured_pins);
68  }
69  static void pin_configured_clear(uint32_t pin)
70  {
71      nrf_bitmask_bit_clear(pin, m_cb.configured_pins);
72  }
73  static bool pin_configured_check(uint32_t pin)
74  {
75      return 0 != nrf_bitmask_bit_is_set(pin, m_cb.configured_pins);
76  }
77  static int8_t channel_port_get(uint32_t pin)
78  {
79      return m_cb.pin_assignments[pin];
80  }
81  static nrfx_gpiote_evt_handler_t channel_handler_get(uint32_t channel)
82  {
83      return m_cb.handlers[channel];
84  }
85  static nrfx_gpiote_pin_t port_handler_pin_get(uint32_t handler_idx)
86  {
87      uint8_t pin_and_polarity = (uint8_t)m_cb.port_handlers_pins[handler_idx];
88      return (nrfx_gpiote_pin_t)(pin_and_polarity & ~POLARITY_FIELD_MASK);
89  }
90  static nrf_gpiote_polarity_t port_handler_polarity_get(uint32_t handler_idx)
91  {
92      uint8_t pin_and_polarity = (uint8_t)m_cb.port_handlers_pins[handler_idx];
93      return (nrf_gpiote_polarity_t)((pin_and_polarity & POLARITY_FIELD_MASK) >> POLARITY_FIELD_POS);
94  }
95  static int8_t channel_port_alloc(uint32_t pin, nrfx_gpiote_evt_handler_t handler, bool channel)
96  {
97      int8_t   channel_id = NO_CHANNELS;
98      uint32_t i;
99      uint32_t start_idx = channel ? 0 : GPIOTE_CH_NUM;
100      uint32_t end_idx   =
101          channel ? GPIOTE_CH_NUM : (GPIOTE_CH_NUM + NRFX_GPIOTE_CONFIG_NUM_OF_LOW_POWER_EVENTS);
102      for (i = start_idx; i < end_idx; i++)
103      {
104          if (m_cb.handlers[i] == FORBIDDEN_HANDLER_ADDRESS)
105          {
106              pin_in_use_by_te_set(pin, i, handler, channel);
107              channel_id = i;
108              break;
109          }
110      }
111      return channel_id;
112  }
113  static void channel_free(uint8_t channel_id)
114  {
115      m_cb.handlers[channel_id] = FORBIDDEN_HANDLER_ADDRESS;
116      if (channel_id >= GPIOTE_CH_NUM)
117      {
118          m_cb.port_handlers_pins[channel_id - GPIOTE_CH_NUM] = (int8_t)PIN_NOT_USED;
119      }
120  }
121  nrfx_err_t nrfx_gpiote_init(uint8_t interrupt_priority)
122  {
123      nrfx_err_t err_code;
124      if (m_cb.state != NRFX_DRV_STATE_UNINITIALIZED)
125      {
126          err_code = NRFX_ERROR_INVALID_STATE;
127          NRFX_LOG_WARNING("Function: %s, error code: %s.",
128                           __func__,
129                           NRFX_LOG_ERROR_STRING_GET(err_code));
130          return err_code;
131      }
132      uint8_t i;
133      for (i = 0; i < NUMBER_OF_PINS; i++)
134      {
135          pin_in_use_clear(i);
136      }
137      for (i = 0; i < (GPIOTE_CH_NUM + NRFX_GPIOTE_CONFIG_NUM_OF_LOW_POWER_EVENTS); i++)
138      {
139          channel_free(i);
140      }
141      memset(m_cb.configured_pins, 0, sizeof(m_cb.configured_pins));
142      NRFX_IRQ_PRIORITY_SET(nrfx_get_irq_number(NRF_GPIOTE), interrupt_priority);
143      NRFX_IRQ_ENABLE(nrfx_get_irq_number(NRF_GPIOTE));
144      nrf_gpiote_event_clear(NRF_GPIOTE, NRF_GPIOTE_EVENT_PORT);
145      nrf_gpiote_int_enable(NRF_GPIOTE, GPIOTE_INTENSET_PORT_Msk);
146      m_cb.state = NRFX_DRV_STATE_INITIALIZED;
147      err_code = NRFX_SUCCESS;
148      NRFX_LOG_INFO("Function: %s, error code: %s.", __func__, NRFX_LOG_ERROR_STRING_GET(err_code));
149      return err_code;
150  }
151  bool nrfx_gpiote_is_init(void)
152  {
153      return (m_cb.state != NRFX_DRV_STATE_UNINITIALIZED) ? true : false;
154  }
155  void nrfx_gpiote_uninit(void)
156  {
157      NRFX_ASSERT(m_cb.state != NRFX_DRV_STATE_UNINITIALIZED);
158      uint32_t i;
159      for (i = 0; i < NUMBER_OF_PINS; i++)
160      {
161          if (pin_in_use_as_non_task_out(i))
162          {
163              nrfx_gpiote_out_uninit(i);
164          }
165          else if ( pin_in_use_by_gpiote(i))
166          {
167              nrfx_gpiote_in_uninit(i);
168          }
169      }
170      m_cb.state = NRFX_DRV_STATE_UNINITIALIZED;
171      NRFX_LOG_INFO("Uninitialized.");
172  }
173  nrfx_err_t nrfx_gpiote_out_init(nrfx_gpiote_pin_t                pin,
174                                  nrfx_gpiote_out_config_t const * p_config)
175  {
176      NRFX_ASSERT(pin < NUMBER_OF_PINS);
177      NRFX_ASSERT(m_cb.state == NRFX_DRV_STATE_INITIALIZED);
178      NRFX_ASSERT(p_config);
179      nrfx_err_t err_code = NRFX_SUCCESS;
180      if (pin_in_use(pin))
181      {
182          err_code = NRFX_ERROR_BUSY;
183      }
184      else
185      {
186          if (p_config->task_pin)
187          {
188              int8_t channel = channel_port_alloc(pin, NULL, true);
189              if (channel != NO_CHANNELS)
190              {
191                  nrf_gpiote_task_configure(NRF_GPIOTE,
192                                            (uint32_t)channel,
193                                            pin,
194                                            p_config->action,
195                                            p_config->init_state);
196              }
197              else
198              {
199                  err_code = NRFX_ERROR_NO_MEM;
200              }
201          }
202          else
203          {
204              pin_in_use_set(pin);
205          }
206          if (err_code == NRFX_SUCCESS)
207          {
208              if (p_config->init_state == NRF_GPIOTE_INITIAL_VALUE_HIGH)
209              {
210                  nrf_gpio_pin_set(pin);
211              }
212              else
213              {
214                  nrf_gpio_pin_clear(pin);
215              }
216              nrf_gpio_cfg_output(pin);
217              pin_configured_set(pin);
218          }
219      }
220      NRFX_LOG_INFO("Function: %s, error code: %s.", __func__, NRFX_LOG_ERROR_STRING_GET(err_code));
221      return err_code;
222  }
223  void nrfx_gpiote_out_uninit(nrfx_gpiote_pin_t pin)
224  {
225      NRFX_ASSERT(pin < NUMBER_OF_PINS);
226      NRFX_ASSERT(pin_in_use(pin));
227      if (pin_in_use_by_te(pin))
228      {
229          channel_free((uint8_t)channel_port_get(pin));
230          nrf_gpiote_te_default(NRF_GPIOTE, (uint32_t)channel_port_get(pin));
231      }
232      pin_in_use_clear(pin);
233      if (pin_configured_check(pin))
234      {
235          nrf_gpio_cfg_default(pin);
236          pin_configured_clear(pin);
237      }
238  }
239  void nrfx_gpiote_out_set(nrfx_gpiote_pin_t pin)
240  {
241      NRFX_ASSERT(pin < NUMBER_OF_PINS);
242      NRFX_ASSERT(pin_in_use(pin));
243      NRFX_ASSERT(!pin_in_use_by_te(pin));
244      nrf_gpio_pin_set(pin);
245  }
246  void nrfx_gpiote_out_clear(nrfx_gpiote_pin_t pin)
247  {
248      NRFX_ASSERT(pin < NUMBER_OF_PINS);
249      NRFX_ASSERT(pin_in_use(pin));
250      NRFX_ASSERT(!pin_in_use_by_te(pin));
251      nrf_gpio_pin_clear(pin);
252  }
253  void nrfx_gpiote_out_toggle(nrfx_gpiote_pin_t pin)
254  {
255      NRFX_ASSERT(pin < NUMBER_OF_PINS);
256      NRFX_ASSERT(pin_in_use(pin));
257      NRFX_ASSERT(!pin_in_use_by_te(pin));
258      nrf_gpio_pin_toggle(pin);
259  }
260  void nrfx_gpiote_out_task_enable(nrfx_gpiote_pin_t pin)
261  {
262      NRFX_ASSERT(pin < NUMBER_OF_PINS);
263      NRFX_ASSERT(pin_in_use(pin));
264      NRFX_ASSERT(pin_in_use_by_te(pin));
265      nrf_gpiote_task_enable(NRF_GPIOTE, (uint32_t)m_cb.pin_assignments[pin]);
266  }
267  void nrfx_gpiote_out_task_disable(nrfx_gpiote_pin_t pin)
268  {
269      NRFX_ASSERT(pin < NUMBER_OF_PINS);
270      NRFX_ASSERT(pin_in_use(pin));
271      NRFX_ASSERT(pin_in_use_by_te(pin));
272      nrf_gpiote_task_disable(NRF_GPIOTE, (uint32_t)m_cb.pin_assignments[pin]);
273  }
274  nrf_gpiote_task_t nrfx_gpiote_out_task_get(nrfx_gpiote_pin_t pin)
275  {
276      NRFX_ASSERT(pin < NUMBER_OF_PINS);
277      NRFX_ASSERT(pin_in_use_by_te(pin));
278      return  nrf_gpiote_out_task_get((uint8_t)channel_port_get(pin));
279  }
280  uint32_t nrfx_gpiote_out_task_addr_get(nrfx_gpiote_pin_t pin)
281  {
282      nrf_gpiote_task_t task = nrfx_gpiote_out_task_get(pin);
283      return nrf_gpiote_task_address_get(NRF_GPIOTE, task);
284  }
285  #if defined(GPIOTE_FEATURE_SET_PRESENT)
<span onclick='openModal()' class='match'>286  nrf_gpiote_task_t nrfx_gpiote_set_task_get(nrfx_gpiote_pin_t pin)
287  {
288      NRFX_ASSERT(pin < NUMBER_OF_PINS);
289      NRFX_ASSERT(pin_in_use_by_te(pin));
290      return nrf_gpiote_set_task_get((uint8_t)channel_port_get(pin));
291  }
292  uint32_t nrfx_gpiote_set_task_addr_get(nrfx_gpiote_pin_t pin)
293  {
294      nrf_gpiote_task_t task = nrfx_gpiote_set_task_get(pin);
295      return nrf_gpiote_task_address_get(NRF_GPIOTE, task);
296  }
297  #endif 
</span>298  #if defined(GPIOTE_FEATURE_CLR_PRESENT)
299  nrf_gpiote_task_t nrfx_gpiote_clr_task_get(nrfx_gpiote_pin_t pin)
300  {
301      NRFX_ASSERT(pin < NUMBER_OF_PINS);
302      NRFX_ASSERT(pin_in_use_by_te(pin));
303      return nrf_gpiote_clr_task_get((uint8_t)channel_port_get(pin));
304  }
305  uint32_t nrfx_gpiote_clr_task_addr_get(nrfx_gpiote_pin_t pin)
306  {
307      nrf_gpiote_task_t task = nrfx_gpiote_clr_task_get(pin);
308      return nrf_gpiote_task_address_get(NRF_GPIOTE, task);
309  }
310  #endif 
311  void nrfx_gpiote_out_task_force(nrfx_gpiote_pin_t pin, uint8_t state)
312  {
313      NRFX_ASSERT(pin < NUMBER_OF_PINS);
314      NRFX_ASSERT(pin_in_use(pin));
315      NRFX_ASSERT(pin_in_use_by_te(pin));
316      nrf_gpiote_outinit_t init_val =
317          state ? NRF_GPIOTE_INITIAL_VALUE_HIGH : NRF_GPIOTE_INITIAL_VALUE_LOW;
318      nrf_gpiote_task_force(NRF_GPIOTE, (uint32_t)m_cb.pin_assignments[pin], init_val);
319  }
320  void nrfx_gpiote_out_task_trigger(nrfx_gpiote_pin_t pin)
321  {
322      NRFX_ASSERT(pin < NUMBER_OF_PINS);
323      NRFX_ASSERT(pin_in_use(pin));
324      NRFX_ASSERT(pin_in_use_by_te(pin));
325      nrf_gpiote_task_t task = nrf_gpiote_out_task_get((uint8_t)channel_port_get(pin));
326      nrf_gpiote_task_trigger(NRF_GPIOTE, task);
327  }
328  #if defined(GPIOTE_FEATURE_SET_PRESENT)
329  void nrfx_gpiote_set_task_trigger(nrfx_gpiote_pin_t pin)
330  {
331      NRFX_ASSERT(pin < NUMBER_OF_PINS);
332      NRFX_ASSERT(pin_in_use(pin));
333      NRFX_ASSERT(pin_in_use_by_te(pin));
334      nrf_gpiote_task_t task = nrf_gpiote_set_task_get((uint8_t)channel_port_get(pin));
335      nrf_gpiote_task_trigger(NRF_GPIOTE, task);
336  }
337  #endif 
338  #if  defined(GPIOTE_FEATURE_CLR_PRESENT)
339  void nrfx_gpiote_clr_task_trigger(nrfx_gpiote_pin_t pin)
340  {
341      NRFX_ASSERT(pin < NUMBER_OF_PINS);
342      NRFX_ASSERT(pin_in_use(pin));
343      NRFX_ASSERT(pin_in_use_by_te(pin));
344      nrf_gpiote_task_t task = nrf_gpiote_clr_task_get((uint8_t)channel_port_get(pin));
345      nrf_gpiote_task_trigger(NRF_GPIOTE, task);
346  }
347  #endif 
348  nrfx_err_t nrfx_gpiote_in_init(nrfx_gpiote_pin_t               pin,
349                                 nrfx_gpiote_in_config_t const * p_config,
350                                 nrfx_gpiote_evt_handler_t       evt_handler)
351  {
352      NRFX_ASSERT(pin < NUMBER_OF_PINS);
353      NRFX_ASSERT(m_cb.state == NRFX_DRV_STATE_INITIALIZED);
354      NRFX_ASSERT(p_config);
355      nrfx_err_t err_code = NRFX_SUCCESS;
356      if (pin_in_use_by_gpiote(pin))
357      {
358          err_code = NRFX_ERROR_BUSY;
359      }
360      else
361      {
362          int8_t channel = channel_port_alloc(pin, evt_handler, p_config->hi_accuracy);
363          if (channel != NO_CHANNELS)
364          {
365              if (!p_config->skip_gpio_setup)
366              {
367                  if (p_config->is_watcher)
368                  {
369                      nrf_gpio_cfg_watcher(pin);
370                  }
371                  else
372                  {
373                      nrf_gpio_cfg_input(pin, p_config->pull);
374                  }
375                  pin_configured_set(pin);
376              }
377              if (p_config->hi_accuracy)
378              {
379                  nrf_gpiote_event_configure(NRF_GPIOTE, (uint32_t)channel, pin, p_config->sense);
380              }
381              else
382              {
383                  m_cb.port_handlers_pins[channel - GPIOTE_CH_NUM] |= (p_config->sense) <<
384                                                                      POLARITY_FIELD_POS;
385              }
386          }
387          else
388          {
389              err_code = NRFX_ERROR_NO_MEM;
390          }
391      }
392      NRFX_LOG_INFO("Function: %s, error code: %s.", __func__, NRFX_LOG_ERROR_STRING_GET(err_code));
393      return err_code;
394  }
395  void nrfx_gpiote_in_event_enable(nrfx_gpiote_pin_t pin, bool int_enable)
396  {
397      NRFX_ASSERT(pin < NUMBER_OF_PINS);
398      NRFX_ASSERT(pin_in_use_by_gpiote(pin));
399      if (pin_in_use_by_port(pin))
400      {
401          nrf_gpiote_polarity_t polarity =
402              port_handler_polarity_get(channel_port_get(pin) - GPIOTE_CH_NUM);
403          nrf_gpio_pin_sense_t sense;
404          if (polarity == NRF_GPIOTE_POLARITY_TOGGLE)
405          {
406              sense = (nrf_gpio_pin_read(pin)) ?
407                      NRF_GPIO_PIN_SENSE_LOW : NRF_GPIO_PIN_SENSE_HIGH;
408          }
409          else
410          {
411              sense = (polarity == NRF_GPIOTE_POLARITY_LOTOHI) ?
412                      NRF_GPIO_PIN_SENSE_HIGH : NRF_GPIO_PIN_SENSE_LOW;
413          }
414          nrf_gpio_cfg_sense_set(pin, sense);
415      }
416      else if (pin_in_use_by_te(pin))
417      {
418          int32_t            channel = (int32_t)channel_port_get(pin);
419          nrf_gpiote_event_t event   = nrf_gpiote_in_event_get((uint8_t)channel);
420          nrf_gpiote_event_enable(NRF_GPIOTE, (uint32_t)channel);
421          nrf_gpiote_event_clear(NRF_GPIOTE, event);
422          if (int_enable)
423          {
424              nrfx_gpiote_evt_handler_t handler = channel_handler_get((uint32_t)channel_port_get(pin));
425              if (handler)
426              {
427                  nrf_gpiote_int_enable(NRF_GPIOTE, 1 << channel);
428              }
429          }
430      }
431  }
432  void nrfx_gpiote_in_event_disable(nrfx_gpiote_pin_t pin)
433  {
434      NRFX_ASSERT(pin < NUMBER_OF_PINS);
435      NRFX_ASSERT(pin_in_use_by_gpiote(pin));
436      if (pin_in_use_by_port(pin))
437      {
438          nrf_gpio_cfg_sense_set(pin, NRF_GPIO_PIN_NOSENSE);
439      }
440      else if (pin_in_use_by_te(pin))
441      {
442          int32_t channel = (int32_t)channel_port_get(pin);
443          nrf_gpiote_event_disable(NRF_GPIOTE, (uint32_t)channel);
444          nrf_gpiote_int_disable(NRF_GPIOTE, 1 << channel);
445      }
446  }
447  void nrfx_gpiote_in_uninit(nrfx_gpiote_pin_t pin)
448  {
449      NRFX_ASSERT(pin < NUMBER_OF_PINS);
450      NRFX_ASSERT(pin_in_use_by_gpiote(pin));
451      nrfx_gpiote_in_event_disable(pin);
452      if (pin_in_use_by_te(pin))
453      {
454          nrf_gpiote_te_default(NRF_GPIOTE, (uint32_t)channel_port_get(pin));
455      }
456      if (pin_configured_check(pin))
457      {
458          nrf_gpio_cfg_default(pin);
459          pin_configured_clear(pin);
460      }
461      channel_free((uint8_t)channel_port_get(pin));
462      pin_in_use_clear(pin);
463  }
464  bool nrfx_gpiote_in_is_set(nrfx_gpiote_pin_t pin)
465  {
466      NRFX_ASSERT(pin < NUMBER_OF_PINS);
467      return nrf_gpio_pin_read(pin) ? true : false;
468  }
469  nrf_gpiote_event_t nrfx_gpiote_in_event_get(nrfx_gpiote_pin_t pin)
470  {
471      NRFX_ASSERT(pin < NUMBER_OF_PINS);
472      NRFX_ASSERT(pin_in_use_by_port(pin) || pin_in_use_by_te(pin));
473      if (pin_in_use_by_te(pin))
474      {
475          return nrf_gpiote_in_event_get((uint8_t)channel_port_get(pin));
476      }
477      return NRF_GPIOTE_EVENT_PORT;
478  }
479  uint32_t nrfx_gpiote_in_event_addr_get(nrfx_gpiote_pin_t pin)
480  {
481      nrf_gpiote_event_t event = nrfx_gpiote_in_event_get(pin);
482      return nrf_gpiote_event_address_get(NRF_GPIOTE, event);
483  }
484  #if defined(NRF_GPIO_LATCH_PRESENT)
485  static bool latch_pending_read_and_check(uint32_t * latch)
486  {
487      nrf_gpio_latches_read_and_clear(0, GPIO_COUNT, latch);
488      for (uint32_t port_idx = 0; port_idx < GPIO_COUNT; port_idx++)
489      {
490          if (latch[port_idx])
491          {
492              return true;
493          }
494      }
495      return false;
496  }
497  static void port_event_handle(uint32_t * latch)
498  {
499      do {
500          for (uint32_t i = 0; i < NRFX_GPIOTE_CONFIG_NUM_OF_LOW_POWER_EVENTS; i++)
501          {
502              if (m_cb.port_handlers_pins[i] == PIN_NOT_USED)
503              {
504                  continue;
505              }
506              nrfx_gpiote_pin_t pin = port_handler_pin_get(i);
507              if (nrf_bitmask_bit_is_set(pin, latch))
508              {
509                  nrf_gpiote_polarity_t polarity = port_handler_polarity_get(i);
510                  nrf_gpio_pin_sense_t sense     = nrf_gpio_pin_sense_get(pin);
511                  NRFX_LOG_DEBUG("PORT event for pin: %d, polarity: %d.", pin, polarity);
512                  nrf_gpio_pin_sense_t next_sense =
513                      (sense == NRF_GPIO_PIN_SENSE_HIGH) ? NRF_GPIO_PIN_SENSE_LOW :
514                                                           NRF_GPIO_PIN_SENSE_HIGH;
515                  nrf_gpio_cfg_sense_set(pin, next_sense);
516                  nrf_gpio_pin_latch_clear(pin);
517                  nrfx_gpiote_evt_handler_t handler =
518                      channel_handler_get((uint32_t)channel_port_get(pin));
519                  if (handler &&
520                      ((polarity == NRF_GPIOTE_POLARITY_TOGGLE) ||
521                       (sense == NRF_GPIO_PIN_SENSE_HIGH && polarity == NRF_GPIOTE_POLARITY_LOTOHI) ||
522                       (sense == NRF_GPIO_PIN_SENSE_LOW && polarity == NRF_GPIOTE_POLARITY_HITOLO)))
523                  {
524                      handler(pin, polarity);
525                  }
526              }
527          }
528      } while (latch_pending_read_and_check(latch));
529  }
530  #else
531  static bool input_read_and_check(uint32_t * input, uint32_t * pins_to_check)
532  {
533      bool process_inputs_again;
534      uint32_t new_input[GPIO_COUNT];
535      nrf_gpio_ports_read(0, GPIO_COUNT, new_input);
536      process_inputs_again = false;
537      for (uint32_t port_idx = 0; port_idx < GPIO_COUNT; port_idx++)
538      {
539          uint32_t input_diff = input[port_idx] ^ new_input[port_idx];
540          input[port_idx] = new_input[port_idx];
541          if (input_diff)
542          {
543              pins_to_check[port_idx] = input_diff;
544              process_inputs_again = true;
545          }
546          else
547          {
548              pins_to_check[port_idx] = 0;
549          }
550      }
551      return process_inputs_again;
552  }
553  static void port_event_handle(uint32_t * input)
554  {
555      uint32_t pins_to_check[GPIO_COUNT];
556      for (uint32_t port_idx = 0; port_idx < GPIO_COUNT; port_idx++)
557      {
558          pins_to_check[port_idx] = 0xFFFFFFFF;
559      }
560      do {
561          for (uint32_t i = 0; i < NRFX_GPIOTE_CONFIG_NUM_OF_LOW_POWER_EVENTS; i++)
562          {
563              if (m_cb.port_handlers_pins[i] == PIN_NOT_USED)
564              {
565                  continue;
566              }
567              nrfx_gpiote_pin_t pin = port_handler_pin_get(i);
568              if (nrf_bitmask_bit_is_set(pin, pins_to_check))
569              {
570                  nrf_gpiote_polarity_t polarity = port_handler_polarity_get(i);
571                  nrf_gpio_pin_sense_t sense     = nrf_gpio_pin_sense_get(pin);
572                  bool pin_state                 = nrf_bitmask_bit_is_set(pin, input);
573                  if ((pin_state && (sense == NRF_GPIO_PIN_SENSE_HIGH)) ||
574                      (!pin_state && (sense == NRF_GPIO_PIN_SENSE_LOW)) )
575                  {
576                      NRFX_LOG_DEBUG("PORT event for pin: %d, polarity: %d.", pin, polarity);
577                      nrf_gpio_pin_sense_t next_sense =
578                          (sense == NRF_GPIO_PIN_SENSE_HIGH) ? NRF_GPIO_PIN_SENSE_LOW :
579                                                               NRF_GPIO_PIN_SENSE_HIGH;
580                      nrf_gpio_cfg_sense_set(pin, next_sense);
581                      nrfx_gpiote_evt_handler_t handler =
582                          channel_handler_get((uint32_t)channel_port_get(pin));
583                      if (handler &&
584                          ((polarity == NRF_GPIOTE_POLARITY_TOGGLE) ||
585                           (sense == NRF_GPIO_PIN_SENSE_HIGH &&
586                            polarity == NRF_GPIOTE_POLARITY_LOTOHI) ||
587                           (sense == NRF_GPIO_PIN_SENSE_LOW &&
588                            polarity == NRF_GPIOTE_POLARITY_HITOLO)))
589                      {
590                          handler(pin, polarity);
591                      }
592                  }
593              }
594          }
595      } while (input_read_and_check(input, pins_to_check));
596  }
597  #endif 
598  void nrfx_gpiote_irq_handler(void)
599  {
600      uint32_t status            = 0;
601      uint32_t input[GPIO_COUNT] = {0};
602      uint32_t            i;
603      nrf_gpiote_event_t event = NRF_GPIOTE_EVENT_IN_0;
604      uint32_t            mask  = (uint32_t)NRF_GPIOTE_INT_IN0_MASK;
605      for (i = 0; i < GPIOTE_CH_NUM; i++)
606      {
607          if (nrf_gpiote_event_check(NRF_GPIOTE, event) &&
608              nrf_gpiote_int_enable_check(NRF_GPIOTE, mask))
609          {
610              nrf_gpiote_event_clear(NRF_GPIOTE, event);
611              status |= mask;
612          }
613          mask <<= 1;
614          event = (nrf_gpiote_event_t)((uint32_t)event + sizeof(uint32_t));
615      }
616      if (nrf_gpiote_event_check(NRF_GPIOTE, NRF_GPIOTE_EVENT_PORT))
617      {
618          nrf_gpiote_event_clear(NRF_GPIOTE, NRF_GPIOTE_EVENT_PORT);
619          status |= (uint32_t)NRF_GPIOTE_INT_PORT_MASK;
620  #if defined(NRF_GPIO_LATCH_PRESENT)
621          nrf_gpio_latches_read_and_clear(0, GPIO_COUNT, input);
622  #else
623          nrf_gpio_ports_read(0, GPIO_COUNT, input);
624  #endif
625      }
626      if (status & NRF_GPIOTE_INT_IN_MASK)
627      {
628          mask = (uint32_t)NRF_GPIOTE_INT_IN0_MASK;
629          for (i = 0; i < GPIOTE_CH_NUM; i++)
630          {
631              if (mask & status)
632              {
633                  nrfx_gpiote_pin_t pin = nrf_gpiote_event_pin_get(NRF_GPIOTE, i);
634                  NRFX_LOG_DEBUG("Event in number: %d.", i);
635                  nrf_gpiote_polarity_t polarity = nrf_gpiote_event_polarity_get(NRF_GPIOTE, i);
636                  nrfx_gpiote_evt_handler_t handler  = channel_handler_get(i);
637                  NRFX_LOG_DEBUG("Pin: %d, polarity: %d.", pin, polarity);
638                  if (handler)
639                  {
640                      handler(pin, polarity);
641                  }
642              }
643              mask <<= 1;
644          }
645      }
646      if (status & (uint32_t)NRF_GPIOTE_INT_PORT_MASK)
647      {
648          port_event_handle(input);
649      }
650  }
651  #endif 
</code></pre>
        </div>
        <div class="column">
            <h3>Adafruit_nRF52_Arduino-MDEwOlJlcG9zaXRvcnk3NDM1NDcyOQ==-flat-nrfx_gpiote.c</h3>
            <pre><code>1  #include <nrfx.h>
2  #if NRFX_CHECK(NRFX_GPIOTE_ENABLED)
3  #include <nrfx_gpiote.h>
4  #include "nrf_bitmask.h"
5  #include <string.h>
6  #define NRFX_LOG_MODULE GPIOTE
7  #include <nrfx_log.h>
8  #define FORBIDDEN_HANDLER_ADDRESS ((nrfx_gpiote_evt_handler_t)UINT32_MAX)
9  #define PIN_NOT_USED              (-1)
10  #define PIN_USED                  (-2)
11  #define NO_CHANNELS               (-1)
12  #define POLARITY_FIELD_POS        (6)
13  #define POLARITY_FIELD_MASK       (0xC0)
14  NRFX_STATIC_ASSERT(NUMBER_OF_PINS <= (1 << POLARITY_FIELD_POS));
15  typedef struct
16  {
17      nrfx_gpiote_evt_handler_t handlers[GPIOTE_CH_NUM + NRFX_GPIOTE_CONFIG_NUM_OF_LOW_POWER_EVENTS];
18      int8_t                    pin_assignments[NUMBER_OF_PINS];
19      int8_t                    port_handlers_pins[NRFX_GPIOTE_CONFIG_NUM_OF_LOW_POWER_EVENTS];
20      uint8_t                   configured_pins[((NUMBER_OF_PINS)+7) / 8];
21      nrfx_drv_state_t          state;
22  } gpiote_control_block_t;
23  static gpiote_control_block_t m_cb;
24  static bool pin_in_use(uint32_t pin)
25  {
26      return (m_cb.pin_assignments[pin] != PIN_NOT_USED);
27  }
28  static bool pin_in_use_as_non_task_out(uint32_t pin)
29  {
30      return (m_cb.pin_assignments[pin] == PIN_USED);
31  }
32  static bool pin_in_use_by_te(uint32_t pin)
33  {
34      return (m_cb.pin_assignments[pin] >= 0 && m_cb.pin_assignments[pin] < GPIOTE_CH_NUM) ?
35              true : false;
36  }
37  static bool pin_in_use_by_port(uint32_t pin)
38  {
39      return (m_cb.pin_assignments[pin] >= GPIOTE_CH_NUM);
40  }
41  static bool pin_in_use_by_gpiote(uint32_t pin)
42  {
43      return (m_cb.pin_assignments[pin] >= 0);
44  }
45  static void pin_in_use_by_te_set(uint32_t                  pin,
46                                   uint32_t                  channel_id,
47                                   nrfx_gpiote_evt_handler_t handler,
48                                   bool                      is_channel)
49  {
50      m_cb.pin_assignments[pin] = channel_id;
51      m_cb.handlers[channel_id] = handler;
52      if (!is_channel)
53      {
54          m_cb.port_handlers_pins[channel_id - GPIOTE_CH_NUM] = (int8_t)pin;
55      }
56  }
57  static void pin_in_use_set(uint32_t pin)
58  {
59      m_cb.pin_assignments[pin] = PIN_USED;
60  }
61  static void pin_in_use_clear(uint32_t pin)
62  {
63      m_cb.pin_assignments[pin] = PIN_NOT_USED;
64  }
65  static void pin_configured_set(uint32_t pin)
66  {
67      nrf_bitmask_bit_set(pin, m_cb.configured_pins);
68  }
69  static void pin_configured_clear(uint32_t pin)
70  {
71      nrf_bitmask_bit_clear(pin, m_cb.configured_pins);
72  }
73  static bool pin_configured_check(uint32_t pin)
74  {
75      return 0 != nrf_bitmask_bit_is_set(pin, m_cb.configured_pins);
76  }
77  static int8_t channel_port_get(uint32_t pin)
78  {
79      return m_cb.pin_assignments[pin];
80  }
81  static nrfx_gpiote_evt_handler_t channel_handler_get(uint32_t channel)
82  {
83      return m_cb.handlers[channel];
84  }
85  static nrfx_gpiote_pin_t port_handler_pin_get(uint32_t handler_idx)
86  {
87      uint8_t pin_and_polarity = (uint8_t)m_cb.port_handlers_pins[handler_idx];
88      return (nrfx_gpiote_pin_t)(pin_and_polarity & ~POLARITY_FIELD_MASK);
89  }
90  static nrf_gpiote_polarity_t port_handler_polarity_get(uint32_t handler_idx)
91  {
92      uint8_t pin_and_polarity = (uint8_t)m_cb.port_handlers_pins[handler_idx];
93      return (nrf_gpiote_polarity_t)((pin_and_polarity & POLARITY_FIELD_MASK) >> POLARITY_FIELD_POS);
94  }
95  static int8_t channel_port_alloc(uint32_t pin, nrfx_gpiote_evt_handler_t handler, bool channel)
96  {
97      int8_t   channel_id = NO_CHANNELS;
98      uint32_t i;
99      uint32_t start_idx = channel ? 0 : GPIOTE_CH_NUM;
100      uint32_t end_idx   =
101          channel ? GPIOTE_CH_NUM : (GPIOTE_CH_NUM + NRFX_GPIOTE_CONFIG_NUM_OF_LOW_POWER_EVENTS);
102      for (i = start_idx; i < end_idx; i++)
103      {
104          if (m_cb.handlers[i] == FORBIDDEN_HANDLER_ADDRESS)
105          {
106              pin_in_use_by_te_set(pin, i, handler, channel);
107              channel_id = i;
108              break;
109          }
110      }
111      return channel_id;
112  }
113  static void channel_free(uint8_t channel_id)
114  {
115      m_cb.handlers[channel_id] = FORBIDDEN_HANDLER_ADDRESS;
116      if (channel_id >= GPIOTE_CH_NUM)
117      {
118          m_cb.port_handlers_pins[channel_id - GPIOTE_CH_NUM] = (int8_t)PIN_NOT_USED;
119      }
120  }
121  nrfx_err_t nrfx_gpiote_init(uint8_t interrupt_priority)
122  {
123      nrfx_err_t err_code;
124      if (m_cb.state != NRFX_DRV_STATE_UNINITIALIZED)
125      {
126          err_code = NRFX_ERROR_INVALID_STATE;
127          NRFX_LOG_WARNING("Function: %s, error code: %s.",
128                           __func__,
129                           NRFX_LOG_ERROR_STRING_GET(err_code));
130          return err_code;
131      }
132      uint8_t i;
133      for (i = 0; i < NUMBER_OF_PINS; i++)
134      {
135          pin_in_use_clear(i);
136      }
137      for (i = 0; i < (GPIOTE_CH_NUM + NRFX_GPIOTE_CONFIG_NUM_OF_LOW_POWER_EVENTS); i++)
138      {
139          channel_free(i);
140      }
141      memset(m_cb.configured_pins, 0, sizeof(m_cb.configured_pins));
142      NRFX_IRQ_PRIORITY_SET(nrfx_get_irq_number(NRF_GPIOTE), interrupt_priority);
143      NRFX_IRQ_ENABLE(nrfx_get_irq_number(NRF_GPIOTE));
144      nrf_gpiote_event_clear(NRF_GPIOTE, NRF_GPIOTE_EVENT_PORT);
145      nrf_gpiote_int_enable(NRF_GPIOTE, GPIOTE_INTENSET_PORT_Msk);
146      m_cb.state = NRFX_DRV_STATE_INITIALIZED;
147      err_code = NRFX_SUCCESS;
148      NRFX_LOG_INFO("Function: %s, error code: %s.", __func__, NRFX_LOG_ERROR_STRING_GET(err_code));
149      return err_code;
150  }
151  bool nrfx_gpiote_is_init(void)
152  {
153      return (m_cb.state != NRFX_DRV_STATE_UNINITIALIZED) ? true : false;
154  }
155  void nrfx_gpiote_uninit(void)
156  {
157      NRFX_ASSERT(m_cb.state != NRFX_DRV_STATE_UNINITIALIZED);
158      uint32_t i;
159      for (i = 0; i < NUMBER_OF_PINS; i++)
160      {
161          if (pin_in_use_as_non_task_out(i))
162          {
163              nrfx_gpiote_out_uninit(i);
164          }
165          else if ( pin_in_use_by_gpiote(i))
166          {
167              nrfx_gpiote_in_uninit(i);
168          }
169      }
170      m_cb.state = NRFX_DRV_STATE_UNINITIALIZED;
171      NRFX_LOG_INFO("Uninitialized.");
172  }
173  nrfx_err_t nrfx_gpiote_out_init(nrfx_gpiote_pin_t                pin,
174                                  nrfx_gpiote_out_config_t const * p_config)
175  {
176      NRFX_ASSERT(pin < NUMBER_OF_PINS);
177      NRFX_ASSERT(m_cb.state == NRFX_DRV_STATE_INITIALIZED);
178      NRFX_ASSERT(p_config);
179      nrfx_err_t err_code = NRFX_SUCCESS;
180      if (pin_in_use(pin))
181      {
182          err_code = NRFX_ERROR_BUSY;
183      }
184      else
185      {
186          if (p_config->task_pin)
187          {
188              int8_t channel = channel_port_alloc(pin, NULL, true);
189              if (channel != NO_CHANNELS)
190              {
191                  nrf_gpiote_task_configure(NRF_GPIOTE,
192                                            (uint32_t)channel,
193                                            pin,
194                                            p_config->action,
195                                            p_config->init_state);
196              }
197              else
198              {
199                  err_code = NRFX_ERROR_NO_MEM;
200              }
201          }
202          else
203          {
204              pin_in_use_set(pin);
205          }
206          if (err_code == NRFX_SUCCESS)
207          {
208              if (p_config->init_state == NRF_GPIOTE_INITIAL_VALUE_HIGH)
209              {
210                  nrf_gpio_pin_set(pin);
211              }
212              else
213              {
214                  nrf_gpio_pin_clear(pin);
215              }
216              nrf_gpio_cfg_output(pin);
217              pin_configured_set(pin);
218          }
219      }
220      NRFX_LOG_INFO("Function: %s, error code: %s.", __func__, NRFX_LOG_ERROR_STRING_GET(err_code));
221      return err_code;
222  }
223  void nrfx_gpiote_out_uninit(nrfx_gpiote_pin_t pin)
224  {
225      NRFX_ASSERT(pin < NUMBER_OF_PINS);
226      NRFX_ASSERT(pin_in_use(pin));
227      if (pin_in_use_by_te(pin))
228      {
229          channel_free((uint8_t)channel_port_get(pin));
230          nrf_gpiote_te_default(NRF_GPIOTE, (uint32_t)channel_port_get(pin));
231      }
232      pin_in_use_clear(pin);
233      if (pin_configured_check(pin))
234      {
235          nrf_gpio_cfg_default(pin);
236          pin_configured_clear(pin);
237      }
238  }
239  void nrfx_gpiote_out_set(nrfx_gpiote_pin_t pin)
240  {
241      NRFX_ASSERT(pin < NUMBER_OF_PINS);
242      NRFX_ASSERT(pin_in_use(pin));
243      NRFX_ASSERT(!pin_in_use_by_te(pin));
244      nrf_gpio_pin_set(pin);
245  }
246  void nrfx_gpiote_out_clear(nrfx_gpiote_pin_t pin)
247  {
248      NRFX_ASSERT(pin < NUMBER_OF_PINS);
249      NRFX_ASSERT(pin_in_use(pin));
250      NRFX_ASSERT(!pin_in_use_by_te(pin));
251      nrf_gpio_pin_clear(pin);
252  }
253  void nrfx_gpiote_out_toggle(nrfx_gpiote_pin_t pin)
254  {
255      NRFX_ASSERT(pin < NUMBER_OF_PINS);
256      NRFX_ASSERT(pin_in_use(pin));
257      NRFX_ASSERT(!pin_in_use_by_te(pin));
258      nrf_gpio_pin_toggle(pin);
259  }
260  void nrfx_gpiote_out_task_enable(nrfx_gpiote_pin_t pin)
261  {
262      NRFX_ASSERT(pin < NUMBER_OF_PINS);
263      NRFX_ASSERT(pin_in_use(pin));
264      NRFX_ASSERT(pin_in_use_by_te(pin));
265      nrf_gpiote_task_enable(NRF_GPIOTE, (uint32_t)m_cb.pin_assignments[pin]);
266  }
267  void nrfx_gpiote_out_task_disable(nrfx_gpiote_pin_t pin)
268  {
269      NRFX_ASSERT(pin < NUMBER_OF_PINS);
270      NRFX_ASSERT(pin_in_use(pin));
271      NRFX_ASSERT(pin_in_use_by_te(pin));
272      nrf_gpiote_task_disable(NRF_GPIOTE, (uint32_t)m_cb.pin_assignments[pin]);
273  }
274  nrf_gpiote_task_t nrfx_gpiote_out_task_get(nrfx_gpiote_pin_t pin)
275  {
276      NRFX_ASSERT(pin < NUMBER_OF_PINS);
277      NRFX_ASSERT(pin_in_use_by_te(pin));
278      return  nrf_gpiote_out_task_get((uint8_t)channel_port_get(pin));
279  }
280  uint32_t nrfx_gpiote_out_task_addr_get(nrfx_gpiote_pin_t pin)
281  {
282      nrf_gpiote_task_t task = nrfx_gpiote_out_task_get(pin);
283      return nrf_gpiote_task_address_get(NRF_GPIOTE, task);
284  }
285  #if defined(GPIOTE_FEATURE_SET_PRESENT)
286  nrf_gpiote_task_t nrfx_gpiote_set_task_get(nrfx_gpiote_pin_t pin)
287  {
288      NRFX_ASSERT(pin < NUMBER_OF_PINS);
289      NRFX_ASSERT(pin_in_use_by_te(pin));
290      return nrf_gpiote_set_task_get((uint8_t)channel_port_get(pin));
291  }
292  uint32_t nrfx_gpiote_set_task_addr_get(nrfx_gpiote_pin_t pin)
293  {
294      nrf_gpiote_task_t task = nrfx_gpiote_set_task_get(pin);
295      return nrf_gpiote_task_address_get(NRF_GPIOTE, task);
296  }
297  #endif 
298  #if defined(GPIOTE_FEATURE_CLR_PRESENT)
<span onclick='openModal()' class='match'>299  nrf_gpiote_task_t nrfx_gpiote_clr_task_get(nrfx_gpiote_pin_t pin)
300  {
301      NRFX_ASSERT(pin < NUMBER_OF_PINS);
302      NRFX_ASSERT(pin_in_use_by_te(pin));
303      return nrf_gpiote_clr_task_get((uint8_t)channel_port_get(pin));
304  }
305  uint32_t nrfx_gpiote_clr_task_addr_get(nrfx_gpiote_pin_t pin)
306  {
307      nrf_gpiote_task_t task = nrfx_gpiote_clr_task_get(pin);
308      return nrf_gpiote_task_address_get(NRF_GPIOTE, task);
309  }
310  #endif 
</span>311  void nrfx_gpiote_out_task_force(nrfx_gpiote_pin_t pin, uint8_t state)
312  {
313      NRFX_ASSERT(pin < NUMBER_OF_PINS);
314      NRFX_ASSERT(pin_in_use(pin));
315      NRFX_ASSERT(pin_in_use_by_te(pin));
316      nrf_gpiote_outinit_t init_val =
317          state ? NRF_GPIOTE_INITIAL_VALUE_HIGH : NRF_GPIOTE_INITIAL_VALUE_LOW;
318      nrf_gpiote_task_force(NRF_GPIOTE, (uint32_t)m_cb.pin_assignments[pin], init_val);
319  }
320  void nrfx_gpiote_out_task_trigger(nrfx_gpiote_pin_t pin)
321  {
322      NRFX_ASSERT(pin < NUMBER_OF_PINS);
323      NRFX_ASSERT(pin_in_use(pin));
324      NRFX_ASSERT(pin_in_use_by_te(pin));
325      nrf_gpiote_task_t task = nrf_gpiote_out_task_get((uint8_t)channel_port_get(pin));
326      nrf_gpiote_task_trigger(NRF_GPIOTE, task);
327  }
328  #if defined(GPIOTE_FEATURE_SET_PRESENT)
329  void nrfx_gpiote_set_task_trigger(nrfx_gpiote_pin_t pin)
330  {
331      NRFX_ASSERT(pin < NUMBER_OF_PINS);
332      NRFX_ASSERT(pin_in_use(pin));
333      NRFX_ASSERT(pin_in_use_by_te(pin));
334      nrf_gpiote_task_t task = nrf_gpiote_set_task_get((uint8_t)channel_port_get(pin));
335      nrf_gpiote_task_trigger(NRF_GPIOTE, task);
336  }
337  #endif 
338  #if  defined(GPIOTE_FEATURE_CLR_PRESENT)
339  void nrfx_gpiote_clr_task_trigger(nrfx_gpiote_pin_t pin)
340  {
341      NRFX_ASSERT(pin < NUMBER_OF_PINS);
342      NRFX_ASSERT(pin_in_use(pin));
343      NRFX_ASSERT(pin_in_use_by_te(pin));
344      nrf_gpiote_task_t task = nrf_gpiote_clr_task_get((uint8_t)channel_port_get(pin));
345      nrf_gpiote_task_trigger(NRF_GPIOTE, task);
346  }
347  #endif 
348  nrfx_err_t nrfx_gpiote_in_init(nrfx_gpiote_pin_t               pin,
349                                 nrfx_gpiote_in_config_t const * p_config,
350                                 nrfx_gpiote_evt_handler_t       evt_handler)
351  {
352      NRFX_ASSERT(pin < NUMBER_OF_PINS);
353      NRFX_ASSERT(m_cb.state == NRFX_DRV_STATE_INITIALIZED);
354      NRFX_ASSERT(p_config);
355      nrfx_err_t err_code = NRFX_SUCCESS;
356      if (pin_in_use_by_gpiote(pin))
357      {
358          err_code = NRFX_ERROR_BUSY;
359      }
360      else
361      {
362          int8_t channel = channel_port_alloc(pin, evt_handler, p_config->hi_accuracy);
363          if (channel != NO_CHANNELS)
364          {
365              if (!p_config->skip_gpio_setup)
366              {
367                  if (p_config->is_watcher)
368                  {
369                      nrf_gpio_cfg_watcher(pin);
370                  }
371                  else
372                  {
373                      nrf_gpio_cfg_input(pin, p_config->pull);
374                  }
375                  pin_configured_set(pin);
376              }
377              if (p_config->hi_accuracy)
378              {
379                  nrf_gpiote_event_configure(NRF_GPIOTE, (uint32_t)channel, pin, p_config->sense);
380              }
381              else
382              {
383                  m_cb.port_handlers_pins[channel - GPIOTE_CH_NUM] |= (p_config->sense) <<
384                                                                      POLARITY_FIELD_POS;
385              }
386          }
387          else
388          {
389              err_code = NRFX_ERROR_NO_MEM;
390          }
391      }
392      NRFX_LOG_INFO("Function: %s, error code: %s.", __func__, NRFX_LOG_ERROR_STRING_GET(err_code));
393      return err_code;
394  }
395  void nrfx_gpiote_in_event_enable(nrfx_gpiote_pin_t pin, bool int_enable)
396  {
397      NRFX_ASSERT(pin < NUMBER_OF_PINS);
398      NRFX_ASSERT(pin_in_use_by_gpiote(pin));
399      if (pin_in_use_by_port(pin))
400      {
401          nrf_gpiote_polarity_t polarity =
402              port_handler_polarity_get(channel_port_get(pin) - GPIOTE_CH_NUM);
403          nrf_gpio_pin_sense_t sense;
404          if (polarity == NRF_GPIOTE_POLARITY_TOGGLE)
405          {
406              sense = (nrf_gpio_pin_read(pin)) ?
407                      NRF_GPIO_PIN_SENSE_LOW : NRF_GPIO_PIN_SENSE_HIGH;
408          }
409          else
410          {
411              sense = (polarity == NRF_GPIOTE_POLARITY_LOTOHI) ?
412                      NRF_GPIO_PIN_SENSE_HIGH : NRF_GPIO_PIN_SENSE_LOW;
413          }
414          nrf_gpio_cfg_sense_set(pin, sense);
415      }
416      else if (pin_in_use_by_te(pin))
417      {
418          int32_t            channel = (int32_t)channel_port_get(pin);
419          nrf_gpiote_event_t event   = nrf_gpiote_in_event_get((uint8_t)channel);
420          nrf_gpiote_event_enable(NRF_GPIOTE, (uint32_t)channel);
421          nrf_gpiote_event_clear(NRF_GPIOTE, event);
422          if (int_enable)
423          {
424              nrfx_gpiote_evt_handler_t handler = channel_handler_get((uint32_t)channel_port_get(pin));
425              if (handler)
426              {
427                  nrf_gpiote_int_enable(NRF_GPIOTE, 1 << channel);
428              }
429          }
430      }
431  }
432  void nrfx_gpiote_in_event_disable(nrfx_gpiote_pin_t pin)
433  {
434      NRFX_ASSERT(pin < NUMBER_OF_PINS);
435      NRFX_ASSERT(pin_in_use_by_gpiote(pin));
436      if (pin_in_use_by_port(pin))
437      {
438          nrf_gpio_cfg_sense_set(pin, NRF_GPIO_PIN_NOSENSE);
439      }
440      else if (pin_in_use_by_te(pin))
441      {
442          int32_t channel = (int32_t)channel_port_get(pin);
443          nrf_gpiote_event_disable(NRF_GPIOTE, (uint32_t)channel);
444          nrf_gpiote_int_disable(NRF_GPIOTE, 1 << channel);
445      }
446  }
447  void nrfx_gpiote_in_uninit(nrfx_gpiote_pin_t pin)
448  {
449      NRFX_ASSERT(pin < NUMBER_OF_PINS);
450      NRFX_ASSERT(pin_in_use_by_gpiote(pin));
451      nrfx_gpiote_in_event_disable(pin);
452      if (pin_in_use_by_te(pin))
453      {
454          nrf_gpiote_te_default(NRF_GPIOTE, (uint32_t)channel_port_get(pin));
455      }
456      if (pin_configured_check(pin))
457      {
458          nrf_gpio_cfg_default(pin);
459          pin_configured_clear(pin);
460      }
461      channel_free((uint8_t)channel_port_get(pin));
462      pin_in_use_clear(pin);
463  }
464  bool nrfx_gpiote_in_is_set(nrfx_gpiote_pin_t pin)
465  {
466      NRFX_ASSERT(pin < NUMBER_OF_PINS);
467      return nrf_gpio_pin_read(pin) ? true : false;
468  }
469  nrf_gpiote_event_t nrfx_gpiote_in_event_get(nrfx_gpiote_pin_t pin)
470  {
471      NRFX_ASSERT(pin < NUMBER_OF_PINS);
472      NRFX_ASSERT(pin_in_use_by_port(pin) || pin_in_use_by_te(pin));
473      if (pin_in_use_by_te(pin))
474      {
475          return nrf_gpiote_in_event_get((uint8_t)channel_port_get(pin));
476      }
477      return NRF_GPIOTE_EVENT_PORT;
478  }
479  uint32_t nrfx_gpiote_in_event_addr_get(nrfx_gpiote_pin_t pin)
480  {
481      nrf_gpiote_event_t event = nrfx_gpiote_in_event_get(pin);
482      return nrf_gpiote_event_address_get(NRF_GPIOTE, event);
483  }
484  #if defined(NRF_GPIO_LATCH_PRESENT)
485  static bool latch_pending_read_and_check(uint32_t * latch)
486  {
487      nrf_gpio_latches_read_and_clear(0, GPIO_COUNT, latch);
488      for (uint32_t port_idx = 0; port_idx < GPIO_COUNT; port_idx++)
489      {
490          if (latch[port_idx])
491          {
492              return true;
493          }
494      }
495      return false;
496  }
497  static void port_event_handle(uint32_t * latch)
498  {
499      do {
500          for (uint32_t i = 0; i < NRFX_GPIOTE_CONFIG_NUM_OF_LOW_POWER_EVENTS; i++)
501          {
502              if (m_cb.port_handlers_pins[i] == PIN_NOT_USED)
503              {
504                  continue;
505              }
506              nrfx_gpiote_pin_t pin = port_handler_pin_get(i);
507              if (nrf_bitmask_bit_is_set(pin, latch))
508              {
509                  nrf_gpiote_polarity_t polarity = port_handler_polarity_get(i);
510                  nrf_gpio_pin_sense_t sense     = nrf_gpio_pin_sense_get(pin);
511                  NRFX_LOG_DEBUG("PORT event for pin: %d, polarity: %d.", pin, polarity);
512                  nrf_gpio_pin_sense_t next_sense =
513                      (sense == NRF_GPIO_PIN_SENSE_HIGH) ? NRF_GPIO_PIN_SENSE_LOW :
514                                                           NRF_GPIO_PIN_SENSE_HIGH;
515                  nrf_gpio_cfg_sense_set(pin, next_sense);
516                  nrf_gpio_pin_latch_clear(pin);
517                  nrfx_gpiote_evt_handler_t handler =
518                      channel_handler_get((uint32_t)channel_port_get(pin));
519                  if (handler &&
520                      ((polarity == NRF_GPIOTE_POLARITY_TOGGLE) ||
521                       (sense == NRF_GPIO_PIN_SENSE_HIGH && polarity == NRF_GPIOTE_POLARITY_LOTOHI) ||
522                       (sense == NRF_GPIO_PIN_SENSE_LOW && polarity == NRF_GPIOTE_POLARITY_HITOLO)))
523                  {
524                      handler(pin, polarity);
525                  }
526              }
527          }
528      } while (latch_pending_read_and_check(latch));
529  }
530  #else
531  static bool input_read_and_check(uint32_t * input, uint32_t * pins_to_check)
532  {
533      bool process_inputs_again;
534      uint32_t new_input[GPIO_COUNT];
535      nrf_gpio_ports_read(0, GPIO_COUNT, new_input);
536      process_inputs_again = false;
537      for (uint32_t port_idx = 0; port_idx < GPIO_COUNT; port_idx++)
538      {
539          uint32_t input_diff = input[port_idx] ^ new_input[port_idx];
540          input[port_idx] = new_input[port_idx];
541          if (input_diff)
542          {
543              pins_to_check[port_idx] = input_diff;
544              process_inputs_again = true;
545          }
546          else
547          {
548              pins_to_check[port_idx] = 0;
549          }
550      }
551      return process_inputs_again;
552  }
553  static void port_event_handle(uint32_t * input)
554  {
555      uint32_t pins_to_check[GPIO_COUNT];
556      for (uint32_t port_idx = 0; port_idx < GPIO_COUNT; port_idx++)
557      {
558          pins_to_check[port_idx] = 0xFFFFFFFF;
559      }
560      do {
561          for (uint32_t i = 0; i < NRFX_GPIOTE_CONFIG_NUM_OF_LOW_POWER_EVENTS; i++)
562          {
563              if (m_cb.port_handlers_pins[i] == PIN_NOT_USED)
564              {
565                  continue;
566              }
567              nrfx_gpiote_pin_t pin = port_handler_pin_get(i);
568              if (nrf_bitmask_bit_is_set(pin, pins_to_check))
569              {
570                  nrf_gpiote_polarity_t polarity = port_handler_polarity_get(i);
571                  nrf_gpio_pin_sense_t sense     = nrf_gpio_pin_sense_get(pin);
572                  bool pin_state                 = nrf_bitmask_bit_is_set(pin, input);
573                  if ((pin_state && (sense == NRF_GPIO_PIN_SENSE_HIGH)) ||
574                      (!pin_state && (sense == NRF_GPIO_PIN_SENSE_LOW)) )
575                  {
576                      NRFX_LOG_DEBUG("PORT event for pin: %d, polarity: %d.", pin, polarity);
577                      nrf_gpio_pin_sense_t next_sense =
578                          (sense == NRF_GPIO_PIN_SENSE_HIGH) ? NRF_GPIO_PIN_SENSE_LOW :
579                                                               NRF_GPIO_PIN_SENSE_HIGH;
580                      nrf_gpio_cfg_sense_set(pin, next_sense);
581                      nrfx_gpiote_evt_handler_t handler =
582                          channel_handler_get((uint32_t)channel_port_get(pin));
583                      if (handler &&
584                          ((polarity == NRF_GPIOTE_POLARITY_TOGGLE) ||
585                           (sense == NRF_GPIO_PIN_SENSE_HIGH &&
586                            polarity == NRF_GPIOTE_POLARITY_LOTOHI) ||
587                           (sense == NRF_GPIO_PIN_SENSE_LOW &&
588                            polarity == NRF_GPIOTE_POLARITY_HITOLO)))
589                      {
590                          handler(pin, polarity);
591                      }
592                  }
593              }
594          }
595      } while (input_read_and_check(input, pins_to_check));
596  }
597  #endif 
598  void nrfx_gpiote_irq_handler(void)
599  {
600      uint32_t status            = 0;
601      uint32_t input[GPIO_COUNT] = {0};
602      uint32_t            i;
603      nrf_gpiote_event_t event = NRF_GPIOTE_EVENT_IN_0;
604      uint32_t            mask  = (uint32_t)NRF_GPIOTE_INT_IN0_MASK;
605      for (i = 0; i < GPIOTE_CH_NUM; i++)
606      {
607          if (nrf_gpiote_event_check(NRF_GPIOTE, event) &&
608              nrf_gpiote_int_enable_check(NRF_GPIOTE, mask))
609          {
610              nrf_gpiote_event_clear(NRF_GPIOTE, event);
611              status |= mask;
612          }
613          mask <<= 1;
614          event = (nrf_gpiote_event_t)((uint32_t)event + sizeof(uint32_t));
615      }
616      if (nrf_gpiote_event_check(NRF_GPIOTE, NRF_GPIOTE_EVENT_PORT))
617      {
618          nrf_gpiote_event_clear(NRF_GPIOTE, NRF_GPIOTE_EVENT_PORT);
619          status |= (uint32_t)NRF_GPIOTE_INT_PORT_MASK;
620  #if defined(NRF_GPIO_LATCH_PRESENT)
621          nrf_gpio_latches_read_and_clear(0, GPIO_COUNT, input);
622  #else
623          nrf_gpio_ports_read(0, GPIO_COUNT, input);
624  #endif
625      }
626      if (status & NRF_GPIOTE_INT_IN_MASK)
627      {
628          mask = (uint32_t)NRF_GPIOTE_INT_IN0_MASK;
629          for (i = 0; i < GPIOTE_CH_NUM; i++)
630          {
631              if (mask & status)
632              {
633                  nrfx_gpiote_pin_t pin = nrf_gpiote_event_pin_get(NRF_GPIOTE, i);
634                  NRFX_LOG_DEBUG("Event in number: %d.", i);
635                  nrf_gpiote_polarity_t polarity = nrf_gpiote_event_polarity_get(NRF_GPIOTE, i);
636                  nrfx_gpiote_evt_handler_t handler  = channel_handler_get(i);
637                  NRFX_LOG_DEBUG("Pin: %d, polarity: %d.", pin, polarity);
638                  if (handler)
639                  {
640                      handler(pin, polarity);
641                  }
642              }
643              mask <<= 1;
644          }
645      }
646      if (status & (uint32_t)NRF_GPIOTE_INT_PORT_MASK)
647      {
648          port_event_handle(input);
649      }
650  }
651  #endif 
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from Adafruit_nRF52_Arduino-MDEwOlJlcG9zaXRvcnk3NDM1NDcyOQ==-flat-nrfx_gpiote.c</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from Adafruit_nRF52_Arduino-MDEwOlJlcG9zaXRvcnk3NDM1NDcyOQ==-flat-nrfx_gpiote.c</div>
                </div>
                <div class="column column_space"><pre><code>286  nrf_gpiote_task_t nrfx_gpiote_set_task_get(nrfx_gpiote_pin_t pin)
287  {
288      NRFX_ASSERT(pin < NUMBER_OF_PINS);
289      NRFX_ASSERT(pin_in_use_by_te(pin));
290      return nrf_gpiote_set_task_get((uint8_t)channel_port_get(pin));
291  }
292  uint32_t nrfx_gpiote_set_task_addr_get(nrfx_gpiote_pin_t pin)
293  {
294      nrf_gpiote_task_t task = nrfx_gpiote_set_task_get(pin);
295      return nrf_gpiote_task_address_get(NRF_GPIOTE, task);
296  }
297  #endif 
</pre></code></div>
                <div class="column column_space"><pre><code>299  nrf_gpiote_task_t nrfx_gpiote_clr_task_get(nrfx_gpiote_pin_t pin)
300  {
301      NRFX_ASSERT(pin < NUMBER_OF_PINS);
302      NRFX_ASSERT(pin_in_use_by_te(pin));
303      return nrf_gpiote_clr_task_get((uint8_t)channel_port_get(pin));
304  }
305  uint32_t nrfx_gpiote_clr_task_addr_get(nrfx_gpiote_pin_t pin)
306  {
307      nrf_gpiote_task_t task = nrfx_gpiote_clr_task_get(pin);
308      return nrf_gpiote_task_address_get(NRF_GPIOTE, task);
309  }
310  #endif 
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    