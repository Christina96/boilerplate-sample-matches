
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 89, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>libpcap-MDEwOlJlcG9zaXRvcnk5NDM1ODg3-flat-capturetest.c</h3>
            <pre><code>1  #include "varattrs.h"
2  #ifndef lint
3  static const char copyright[] _U_ =
4      "@(#) Copyright (c) 1988, 1989, 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1997, 2000\n\
5  The Regents of the University of California.  All rights reserved.\n";
6  #endif
7  #include <stdio.h>
8  #include <stdlib.h>
9  #include <string.h>
10  #include <stdarg.h>
11  #include <limits.h>
12  #ifdef _WIN32
13    #include "getopt.h"
14  #else
15    #include <unistd.h>
16  #endif
17  #include <errno.h>
18  #ifndef _WIN32
19    #include <signal.h>
20  #endif
21  #include <sys/types.h>
22  #include <pcap.h>
23  #include "pcap/funcattrs.h"
24  #ifdef _WIN32
25    #include "portability.h"
26  #endif
27  static char *program_name;
28  static void countme(u_char *, const struct pcap_pkthdr *, const u_char *);
29  static void PCAP_NORETURN usage(void);
30  static void PCAP_NORETURN error(const char *, ...) PCAP_PRINTFLIKE(1, 2);
31  static void warning(const char *, ...) PCAP_PRINTFLIKE(1, 2);
32  static char *copy_argv(char **);
33  static pcap_t *pd;
34  #ifndef _WIN32
35  static int breaksigint = 0;
36  #endif
37  #ifndef _WIN32
38  static void
39  sigint_handler(int signum _U_)
40  {
41  	if (breaksigint)
42  		pcap_breakloop(pd);
43  }
44  #endif
45  #ifdef _WIN32
46  #define B_OPTION	""
47  #define R_OPTION	""
48  #define S_OPTION	""
49  #else
50  #define B_OPTION	"b"
51  #define R_OPTION	"r"
52  #define S_OPTION	"s"
53  #endif
54  #define COMMAND_OPTIONS	B_OPTION "i:mn" R_OPTION S_OPTION "t:"
55  #define USAGE_OPTIONS	"-" B_OPTION "mn" R_OPTION S_OPTION
56  int
57  main(int argc, char **argv)
58  {
59  	register int op;
60  	register char *cp, *cmdbuf, *device;
61  	long longarg;
62  	char *p;
63  	int timeout = 1000;
64  	int immediate = 0;
65  	int nonblock = 0;
66  #ifndef _WIN32
67  	int sigrestart = 0;
68  	int catchsigint = 0;
69  #endif
70  	pcap_if_t *devlist;
71  	bpf_u_int32 localnet, netmask;
72  	struct bpf_program fcode;
73  	char ebuf[PCAP_ERRBUF_SIZE];
74  	int status;
75  	int packet_count;
76  	device = NULL;
77  	if ((cp = strrchr(argv[0], '/')) != NULL)
78  		program_name = cp + 1;
79  	else
80  		program_name = argv[0];
81  	opterr = 0;
82  	while ((op = getopt(argc, argv, COMMAND_OPTIONS)) != -1) {
83  		switch (op) {
84  #ifndef _WIN32
85  		case 'b':
86  			breaksigint = 1;
87  			break;
88  #endif
89  		case 'i':
90  			device = optarg;
91  			break;
92  		case 'm':
93  			immediate = 1;
94  			break;
95  		case 'n':
96  			nonblock = 1;
97  			break;
98  #ifndef _WIN32
99  		case 'r':
100  			sigrestart = 1;
101  			break;
102  		case 's':
103  			catchsigint = 1;
104  			break;
105  #endif
106  		case 't':
107  			longarg = strtol(optarg, &p, 10);
108  			if (p == optarg || *p != '\0') {
109  				error("Timeout value \"%s\" is not a number",
110  				    optarg);
111  			}
112  			if (longarg < 0) {
113  				error("Timeout value %ld is negative", longarg);
114  			}
115  			if (longarg > INT_MAX) {
116  				error("Timeout value %ld is too large (> %d)",
117  				    longarg, INT_MAX);
118  			}
119  			timeout = (int)longarg;
120  			break;
121  		default:
122  			usage();
123  		}
124  	}
125  	if (device == NULL) {
126  		if (pcap_findalldevs(&devlist, ebuf) == -1)
127  			error("%s", ebuf);
128  		if (devlist == NULL)
129  			error("no interfaces available for capture");
130  		device = strdup(devlist->name);
131  		pcap_freealldevs(devlist);
132  	}
133  	*ebuf = '\0';
134  #ifndef _WIN32
135  	if (catchsigint) {
136  		struct sigaction action;
137  		action.sa_handler = sigint_handler;
138  		sigemptyset(&action.sa_mask);
139  		action.sa_flags = sigrestart ? SA_RESTART : 0;
140  		if (sigaction(SIGINT, &action, NULL) == -1)
141  			error("Can't catch SIGINT: %s\n",
142  			    strerror(errno));
143  	}
144  #endif
145  	pd = pcap_create(device, ebuf);
146  	if (pd == NULL)
147  		error("%s", ebuf);
148  	status = pcap_set_snaplen(pd, 65535);
149  	if (status != 0)
150  		error("%s: pcap_set_snaplen failed: %s",
151  			    device, pcap_statustostr(status));
152  	if (immediate) {
153  		status = pcap_set_immediate_mode(pd, 1);
154  		if (status != 0)
155  			error("%s: pcap_set_immediate_mode failed: %s",
156  			    device, pcap_statustostr(status));
157  	}
158  	status = pcap_set_timeout(pd, timeout);
159  	if (status != 0)
160  		error("%s: pcap_set_timeout failed: %s",
161  		    device, pcap_statustostr(status));
162  	status = pcap_activate(pd);
163  	if (status < 0) {
164  		error("%s: %s\n(%s)", device,
165  		    pcap_statustostr(status), pcap_geterr(pd));
166  	} else if (status > 0) {
167  		warning("%s: %s\n(%s)", device,
168  		    pcap_statustostr(status), pcap_geterr(pd));
169  	}
170  	if (pcap_lookupnet(device, &localnet, &netmask, ebuf) < 0) {
171  		localnet = 0;
172  		netmask = 0;
173  		warning("%s", ebuf);
174  	}
175  	cmdbuf = copy_argv(&argv[optind]);
176  	if (pcap_compile(pd, &fcode, cmdbuf, 1, netmask) < 0)
177  		error("%s", pcap_geterr(pd));
178  	if (pcap_setfilter(pd, &fcode) < 0)
179  		error("%s", pcap_geterr(pd));
180  	if (pcap_setnonblock(pd, nonblock, ebuf) == -1)
181  		error("pcap_setnonblock failed: %s", ebuf);
182  	printf("Listening on %s\n", device);
183  	for (;;) {
184  		packet_count = 0;
185  		status = pcap_dispatch(pd, -1, countme,
186  		    (u_char *)&packet_count);
187  		if (status < 0)
188  			break;
189  		if (status != 0) {
190  			printf("%d packets seen, %d packets counted after pcap_dispatch returns\n",
191  			    status, packet_count);
<span onclick='openModal()' class='match'>192  			struct pcap_stat ps;
193  			pcap_stats(pd, &ps);
194  			printf("%d ps_recv, %d ps_drop, %d ps_ifdrop\n",
195  			    ps.ps_recv, ps.ps_drop, ps.ps_ifdrop);
196  		}
197  	}
198  	if (status == -2) {
199  		putchar('\n');
200  		printf("Broken out of loop from SIGINT handler\n");
201  	}
202  	(void)fflush(stdout);
203  	if (status == -1) {
204  		(void)fprintf(stderr, "%s: pcap_dispatch: %s\n",
205  		    program_name, pcap_geterr(pd));
206  	}
207  	pcap_close(pd);
208  	pcap_freecode(&fcode);
</span>209  	free(cmdbuf);
210  	exit(status == -1 ? 1 : 0);
211  }
212  static void
213  countme(u_char *user, const struct pcap_pkthdr *h _U_, const u_char *sp _U_)
214  {
215  	int *counterp = (int *)user;
216  	(*counterp)++;
217  }
218  static void
219  usage(void)
220  {
221  	(void)fprintf(stderr, "Usage: %s [ " USAGE_OPTIONS " ] [ -i interface ] [ -t timeout] [expression]\n",
222  	    program_name);
223  	exit(1);
224  }
225  static void
226  error(const char *fmt, ...)
227  {
228  	va_list ap;
229  	(void)fprintf(stderr, "%s: ", program_name);
230  	va_start(ap, fmt);
231  	(void)vfprintf(stderr, fmt, ap);
232  	va_end(ap);
233  	if (*fmt) {
234  		fmt += strlen(fmt);
235  		if (fmt[-1] != '\n')
236  			(void)fputc('\n', stderr);
237  	}
238  	exit(1);
239  }
240  static void
241  warning(const char *fmt, ...)
242  {
243  	va_list ap;
244  	(void)fprintf(stderr, "%s: WARNING: ", program_name);
245  	va_start(ap, fmt);
246  	(void)vfprintf(stderr, fmt, ap);
247  	va_end(ap);
248  	if (*fmt) {
249  		fmt += strlen(fmt);
250  		if (fmt[-1] != '\n')
251  			(void)fputc('\n', stderr);
252  	}
253  }
254  static char *
255  copy_argv(register char **argv)
256  {
257  	register char **p;
258  	register size_t len = 0;
259  	char *buf;
260  	char *src, *dst;
261  	p = argv;
262  	if (*p == 0)
263  		return 0;
264  	while (*p)
265  		len += strlen(*p++) + 1;
266  	buf = (char *)malloc(len);
267  	if (buf == NULL)
268  		error("copy_argv: malloc");
269  	p = argv;
270  	dst = buf;
271  	while ((src = *p++) != NULL) {
272  		while ((*dst++ = *src++) != '\0')
273  			;
274  		dst[-1] = ' ';
275  	}
276  	dst[-1] = '\0';
277  	return buf;
278  }
</code></pre>
        </div>
        <div class="column">
            <h3>libpcap-MDEwOlJlcG9zaXRvcnk5NDM1ODg3-flat-capturetest.c</h3>
            <pre><code>1  #include "varattrs.h"
2  #ifndef lint
3  static const char copyright[] _U_ =
4      "@(#) Copyright (c) 1988, 1989, 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1997, 2000\n\
5  The Regents of the University of California.  All rights reserved.\n";
6  #endif
7  #include <stdio.h>
8  #include <stdlib.h>
9  #include <string.h>
10  #include <stdarg.h>
11  #include <limits.h>
12  #ifdef _WIN32
13    #include "getopt.h"
14  #else
15    #include <unistd.h>
16  #endif
17  #include <errno.h>
18  #ifndef _WIN32
19    #include <signal.h>
20  #endif
21  #include <sys/types.h>
22  #include <pcap.h>
23  #include "pcap/funcattrs.h"
24  #ifdef _WIN32
25    #include "portability.h"
26  #endif
27  static char *program_name;
28  static void countme(u_char *, const struct pcap_pkthdr *, const u_char *);
29  static void PCAP_NORETURN usage(void);
30  static void PCAP_NORETURN error(const char *, ...) PCAP_PRINTFLIKE(1, 2);
31  static void warning(const char *, ...) PCAP_PRINTFLIKE(1, 2);
32  static char *copy_argv(char **);
33  static pcap_t *pd;
34  #ifndef _WIN32
35  static int breaksigint = 0;
36  #endif
37  #ifndef _WIN32
38  static void
39  sigint_handler(int signum _U_)
40  {
41  	if (breaksigint)
42  		pcap_breakloop(pd);
43  }
44  #endif
45  #ifdef _WIN32
46  #define B_OPTION	""
47  #define R_OPTION	""
48  #define S_OPTION	""
49  #else
50  #define B_OPTION	"b"
51  #define R_OPTION	"r"
52  #define S_OPTION	"s"
53  #endif
54  #define COMMAND_OPTIONS	B_OPTION "i:mn" R_OPTION S_OPTION "t:"
55  #define USAGE_OPTIONS	"-" B_OPTION "mn" R_OPTION S_OPTION
56  int
57  main(int argc, char **argv)
58  {
59  	register int op;
60  	register char *cp, *cmdbuf, *device;
61  	long longarg;
62  	char *p;
63  	int timeout = 1000;
64  	int immediate = 0;
65  	int nonblock = 0;
66  #ifndef _WIN32
67  	int sigrestart = 0;
68  	int catchsigint = 0;
69  #endif
70  	pcap_if_t *devlist;
71  	bpf_u_int32 localnet, netmask;
72  	struct bpf_program fcode;
73  	char ebuf[PCAP_ERRBUF_SIZE];
74  	int status;
75  	int packet_count;
76  	device = NULL;
77  	if ((cp = strrchr(argv[0], '/')) != NULL)
78  		program_name = cp + 1;
79  	else
80  		program_name = argv[0];
81  	opterr = 0;
82  	while ((op = getopt(argc, argv, COMMAND_OPTIONS)) != -1) {
83  		switch (op) {
84  #ifndef _WIN32
85  		case 'b':
86  			breaksigint = 1;
87  			break;
88  #endif
89  		case 'i':
90  			device = optarg;
91  			break;
92  		case 'm':
93  			immediate = 1;
94  			break;
95  		case 'n':
96  			nonblock = 1;
97  			break;
98  #ifndef _WIN32
99  		case 'r':
100  			sigrestart = 1;
101  			break;
102  		case 's':
103  			catchsigint = 1;
104  			break;
105  #endif
106  		case 't':
107  			longarg = strtol(optarg, &p, 10);
108  			if (p == optarg || *p != '\0') {
109  				error("Timeout value \"%s\" is not a number",
110  				    optarg);
111  			}
112  			if (longarg < 0) {
113  				error("Timeout value %ld is negative", longarg);
114  			}
115  			if (longarg > INT_MAX) {
116  				error("Timeout value %ld is too large (> %d)",
117  				    longarg, INT_MAX);
118  			}
119  			timeout = (int)longarg;
120  			break;
121  		default:
122  			usage();
123  		}
124  	}
125  	if (device == NULL) {
126  		if (pcap_findalldevs(&devlist, ebuf) == -1)
127  			error("%s", ebuf);
128  		if (devlist == NULL)
129  			error("no interfaces available for capture");
130  		device = strdup(devlist->name);
131  		pcap_freealldevs(devlist);
132  	}
133  	*ebuf = '\0';
134  #ifndef _WIN32
135  	if (catchsigint) {
136  		struct sigaction action;
137  		action.sa_handler = sigint_handler;
138  		sigemptyset(&action.sa_mask);
139  		action.sa_flags = sigrestart ? SA_RESTART : 0;
140  		if (sigaction(SIGINT, &action, NULL) == -1)
141  			error("Can't catch SIGINT: %s\n",
142  			    strerror(errno));
143  	}
144  #endif
145  	pd = pcap_create(device, ebuf);
146  	if (pd == NULL)
147  		error("%s", ebuf);
148  	status = pcap_set_snaplen(pd, 65535);
149  	if (status != 0)
150  		error("%s: pcap_set_snaplen failed: %s",
151  			    device, pcap_statustostr(status));
152  	if (immediate) {
153  		status = pcap_set_immediate_mode(pd, 1);
154  		if (status != 0)
155  			error("%s: pcap_set_immediate_mode failed: %s",
156  			    device, pcap_statustostr(status));
157  	}
158  	status = pcap_set_timeout(pd, timeout);
159  	if (status != 0)
160  		error("%s: pcap_set_timeout failed: %s",
161  		    device, pcap_statustostr(status));
162  	status = pcap_activate(pd);
163  	if (status < 0) {
164  		error("%s: %s\n(%s)", device,
165  		    pcap_statustostr(status), pcap_geterr(pd));
166  	} else if (status > 0) {
167  		warning("%s: %s\n(%s)", device,
168  		    pcap_statustostr(status), pcap_geterr(pd));
169  	}
170  	if (pcap_lookupnet(device, &localnet, &netmask, ebuf) < 0) {
171  		localnet = 0;
172  		netmask = 0;
173  		warning("%s", ebuf);
174  	}
175  	cmdbuf = copy_argv(&argv[optind]);
176  	if (pcap_compile(pd, &fcode, cmdbuf, 1, netmask) < 0)
177  		error("%s", pcap_geterr(pd));
178  	if (pcap_setfilter(pd, &fcode) < 0)
179  		error("%s", pcap_geterr(pd));
180  	if (pcap_setnonblock(pd, nonblock, ebuf) == -1)
181  		error("pcap_setnonblock failed: %s", ebuf);
182  	printf("Listening on %s\n", device);
183  	for (;;) {
184  		packet_count = 0;
185  		status = pcap_dispatch(pd, -1, countme,
186  		    (u_char *)&packet_count);
187  		if (status < 0)
188  			break;
189  		if (status != 0) {
190  			printf("%d packets seen, %d packets counted after pcap_dispatch returns\n",
191  			    status, packet_count);
<span onclick='openModal()' class='match'>192  			struct pcap_stat ps;
193  			pcap_stats(pd, &ps);
194  			printf("%d ps_recv, %d ps_drop, %d ps_ifdrop\n",
195  			    ps.ps_recv, ps.ps_drop, ps.ps_ifdrop);
196  		}
197  	}
198  	if (status == -2) {
199  		putchar('\n');
200  		printf("Broken out of loop from SIGINT handler\n");
201  	}
202  	(void)fflush(stdout);
203  	if (status == -1) {
204  		(void)fprintf(stderr, "%s: pcap_dispatch: %s\n",
205  		    program_name, pcap_geterr(pd));
206  	}
207  	pcap_close(pd);
208  	pcap_freecode(&fcode);
</span>209  	free(cmdbuf);
210  	exit(status == -1 ? 1 : 0);
211  }
212  static void
213  countme(u_char *user, const struct pcap_pkthdr *h _U_, const u_char *sp _U_)
214  {
215  	int *counterp = (int *)user;
216  	(*counterp)++;
217  }
218  static void
219  usage(void)
220  {
221  	(void)fprintf(stderr, "Usage: %s [ " USAGE_OPTIONS " ] [ -i interface ] [ -t timeout] [expression]\n",
222  	    program_name);
223  	exit(1);
224  }
225  static void
226  error(const char *fmt, ...)
227  {
228  	va_list ap;
229  	(void)fprintf(stderr, "%s: ", program_name);
230  	va_start(ap, fmt);
231  	(void)vfprintf(stderr, fmt, ap);
232  	va_end(ap);
233  	if (*fmt) {
234  		fmt += strlen(fmt);
235  		if (fmt[-1] != '\n')
236  			(void)fputc('\n', stderr);
237  	}
238  	exit(1);
239  }
240  static void
241  warning(const char *fmt, ...)
242  {
243  	va_list ap;
244  	(void)fprintf(stderr, "%s: WARNING: ", program_name);
245  	va_start(ap, fmt);
246  	(void)vfprintf(stderr, fmt, ap);
247  	va_end(ap);
248  	if (*fmt) {
249  		fmt += strlen(fmt);
250  		if (fmt[-1] != '\n')
251  			(void)fputc('\n', stderr);
252  	}
253  }
254  static char *
255  copy_argv(register char **argv)
256  {
257  	register char **p;
258  	register size_t len = 0;
259  	char *buf;
260  	char *src, *dst;
261  	p = argv;
262  	if (*p == 0)
263  		return 0;
264  	while (*p)
265  		len += strlen(*p++) + 1;
266  	buf = (char *)malloc(len);
267  	if (buf == NULL)
268  		error("copy_argv: malloc");
269  	p = argv;
270  	dst = buf;
271  	while ((src = *p++) != NULL) {
272  		while ((*dst++ = *src++) != '\0')
273  			;
274  		dst[-1] = ' ';
275  	}
276  	dst[-1] = '\0';
277  	return buf;
278  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from libpcap-MDEwOlJlcG9zaXRvcnk5NDM1ODg3-flat-capturetest.c</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from libpcap-MDEwOlJlcG9zaXRvcnk5NDM1ODg3-flat-capturetest.c</div>
                </div>
                <div class="column column_space"><pre><code>192  			struct pcap_stat ps;
193  			pcap_stats(pd, &ps);
194  			printf("%d ps_recv, %d ps_drop, %d ps_ifdrop\n",
195  			    ps.ps_recv, ps.ps_drop, ps.ps_ifdrop);
196  		}
197  	}
198  	if (status == -2) {
199  		putchar('\n');
200  		printf("Broken out of loop from SIGINT handler\n");
201  	}
202  	(void)fflush(stdout);
203  	if (status == -1) {
204  		(void)fprintf(stderr, "%s: pcap_dispatch: %s\n",
205  		    program_name, pcap_geterr(pd));
206  	}
207  	pcap_close(pd);
208  	pcap_freecode(&fcode);
</pre></code></div>
                <div class="column column_space"><pre><code>192  			struct pcap_stat ps;
193  			pcap_stats(pd, &ps);
194  			printf("%d ps_recv, %d ps_drop, %d ps_ifdrop\n",
195  			    ps.ps_recv, ps.ps_drop, ps.ps_ifdrop);
196  		}
197  	}
198  	if (status == -2) {
199  		putchar('\n');
200  		printf("Broken out of loop from SIGINT handler\n");
201  	}
202  	(void)fflush(stdout);
203  	if (status == -1) {
204  		(void)fprintf(stderr, "%s: pcap_dispatch: %s\n",
205  		    program_name, pcap_geterr(pd));
206  	}
207  	pcap_close(pd);
208  	pcap_freecode(&fcode);
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    