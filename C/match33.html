<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for encryptsave_test.c &amp; crypto_test.c</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for encryptsave_test.c &amp; crypto_test.c
      </h3>
<h1 align="center">
        10.4%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>encryptsave_test.c (21.052631%)<th>crypto_test.c (6.993007%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(181-209)<td><a href="#" name="0">(322-353)</a><td align="center"><font color="#ff0000">20</font>
</td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>encryptsave_test.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 #ifdef HAVE_CONFIG_H
2 #include "config.h"
3 #endif
4 #include &lt;sys/types.h&gt;
5 #include &lt;stdint.h&gt;
6 #include &lt;string.h&gt;
7 #include &lt;check.h&gt;
8 #include &lt;stdlib.h&gt;
9 #include &lt;time.h&gt;
10 #include "helpers.h"
11 #include "../toxcore/tox.h"
12 #include "../toxencryptsave/toxencryptsave.h"
13 #include "../toxcore/crypto_core.h"
14 #ifdef VANILLA_NACL
15 #include "../toxencryptsave/crypto_pwhash_scryptsalsa208sha256/crypto_pwhash_scryptsalsa208sha256.h"
16 #endif
17 unsigned char salt[32] = {0xB1, 0xC2, 0x09, 0xEE, 0x50, 0x6C, 0xF0, 0x20, 0xC4, 0xD6, 0xEB, 0xC0, 0x44, 0x51, 0x3B, 0x60, 0x4B, 0x39, 0x4A, 0xCF, 0x09, 0x53, 0x4F, 0xEA, 0x08, 0x41, 0xFA, 0xCA, 0x66, 0xD2, 0x68, 0x7F};
18 unsigned char known_key[crypto_box_BEFORENMBYTES] = {0x29, 0x36, 0x1c, 0x9e, 0x65, 0xbb, 0x46, 0x8b, 0xde, 0xa1, 0xac, 0xf, 0xd5, 0x11, 0x81, 0xc8, 0x29, 0x28, 0x17, 0x23, 0xa6, 0xc3, 0x6b, 0x77, 0x2e, 0xd7, 0xd3, 0x10, 0xeb, 0xd2, 0xf7, 0xc8};
19 char *pw = "hunter2";
20 unsigned int pwlen = 7;
21 unsigned char known_key2[crypto_box_BEFORENMBYTES] = {0x7a, 0xfa, 0x95, 0x45, 0x36, 0x8a, 0xa2, 0x5c, 0x40, 0xfd, 0xc0, 0xe2, 0x35, 0x8, 0x7, 0x88, 0xfa, 0xf9, 0x37, 0x86, 0xeb, 0xff, 0x50, 0x4f, 0x3, 0xe2, 0xf6, 0xd9, 0xef, 0x9, 0x17, 0x1};
22 void accept_friend_request(Tox *m, const uint8_t *public_key, const uint8_t *data, size_t length, void *userdata)
23 {
24     if (*((uint32_t *)userdata) != 974536)
25         return;
26     if (length == 7 &amp;&amp; memcmp("Gentoo", data, 7) == 0) {
27         tox_friend_add_norequest(m, public_key, 0);
28     }
29 }
30 START_TEST(test_known_kdf)
31 {
32     unsigned char out[crypto_box_BEFORENMBYTES];
33     crypto_pwhash_scryptsalsa208sha256(out,
34                                        crypto_box_BEFORENMBYTES,
35                                        pw,
36                                        pwlen,
37                                        salt,
38                                        crypto_pwhash_scryptsalsa208sha256_OPSLIMIT_INTERACTIVE * 8,
39                                        crypto_pwhash_scryptsalsa208sha256_MEMLIMIT_INTERACTIVE);
40     ck_assert_msg(memcmp(out, known_key, crypto_box_BEFORENMBYTES) == 0, "derived key is wrong");
41 }
42 END_TEST
43 START_TEST(test_save_friend)
44 {
45     Tox *tox1 = tox_new(0, 0);
46     Tox *tox2 = tox_new(0, 0);
47     ck_assert_msg(tox1 || tox2, "Failed to create 2 tox instances");
48     uint32_t to_compare = 974536;
49     tox_callback_friend_request(tox2, accept_friend_request, &amp;to_compare);
50     uint8_t address[TOX_ADDRESS_SIZE];
51     tox_self_get_address(tox2, address);
52     uint32_t test = tox_friend_add(tox1, address, (uint8_t *)"Gentoo", 7, 0);
53     ck_assert_msg(test != UINT32_MAX, "Failed to add friend");
54     size_t size = tox_get_savedata_size(tox1);
55     uint8_t data[size];
56     tox_get_savedata(tox1, data);
57     size_t size2 = size + TOX_PASS_ENCRYPTION_EXTRA_LENGTH;
58     uint8_t enc_data[size2];
59     TOX_ERR_ENCRYPTION error1;
60     bool ret = tox_pass_encrypt(data, size, "correcthorsebatterystaple", 25, enc_data, &amp;error1);
61     ck_assert_msg(ret, "failed to encrypted save: %u", error1);
62     ck_assert_msg(tox_is_data_encrypted(enc_data), "magic number missing");
63     struct Tox_Options options;
64     tox_options_default(&amp;options);
65     options.savedata_type = TOX_SAVEDATA_TYPE_TOX_SAVE;
66     options.savedata_data = enc_data;
67     options.savedata_length = size2;
68     TOX_ERR_NEW err2;
69     Tox *tox3 = tox_new(&amp;options, &amp;err2);
70     ck_assert_msg(err2 == TOX_ERR_NEW_LOAD_ENCRYPTED, "wrong error! %u. should fail with %u", err2,
71                   TOX_ERR_NEW_LOAD_ENCRYPTED);
72     uint8_t dec_data[size];
73     TOX_ERR_DECRYPTION err3;
74     ret = tox_pass_decrypt(enc_data, size2, "correcthorsebatterystaple", 25, dec_data, &amp;err3);
75     ck_assert_msg(ret, "failed to decrypt save: %u", err3);
76     options.savedata_data = dec_data;
77     options.savedata_length = size;
78     tox3 = tox_new(&amp;options, &amp;err2);
79     ck_assert_msg(err2 == TOX_ERR_NEW_OK, "failed to load from decrypted data: %u", err2);
80     uint8_t address2[TOX_PUBLIC_KEY_SIZE];
81     ret = tox_friend_get_public_key(tox3, 0, address2, 0);
82     ck_assert_msg(ret, "no friends!");
83     ck_assert_msg(memcmp(address, address2, TOX_PUBLIC_KEY_SIZE) == 0, "addresses don't match!");
84     size = tox_get_savedata_size(tox3);
85     uint8_t data2[size];
86     tox_get_savedata(tox3, data2);
87     TOX_PASS_KEY key;
88     memcpy(key.salt, salt, 32);
89     memcpy(key.key, known_key2, crypto_box_BEFORENMBYTES);
90     size2 = size + TOX_PASS_ENCRYPTION_EXTRA_LENGTH;
91     uint8_t encdata2[size2];
92     ret = tox_pass_key_encrypt(data2, size, &amp;key, encdata2, &amp;error1);
93     ck_assert_msg(ret, "failed to key encrypt %u", error1);
94     ck_assert_msg(tox_is_data_encrypted(encdata2), "magic number the second missing");
95     uint8_t out1[size], out2[size];
96     ret = tox_pass_decrypt(encdata2, size2, pw, pwlen, out1, &amp;err3);
97     ck_assert_msg(ret, "failed to pw decrypt %u", err3);
98     ret = tox_pass_key_decrypt(encdata2, size2, &amp;key, out2, &amp;err3);
99     ck_assert_msg(ret, "failed to key decrypt %u", err3);
100     ck_assert_msg(memcmp(out1, out2, size) == 0, "differing output data");
101     options.savedata_data = out1;
102     options.savedata_length = size;
103     Tox *tox4 = tox_new(&amp;options, &amp;err2);
104     ck_assert_msg(err2 == TOX_ERR_NEW_OK, "failed to new the third");
105     uint8_t address5[TOX_PUBLIC_KEY_SIZE];
106     ret = tox_friend_get_public_key(tox4, 0, address5, 0);
107     ck_assert_msg(ret, "no friends! the third");
108     ck_assert_msg(memcmp(address, address2, TOX_PUBLIC_KEY_SIZE) == 0, "addresses don't match! the third");
109     tox_kill(tox1);
110     tox_kill(tox2);
111     tox_kill(tox3);
112     tox_kill(tox4);
113 }
114 END_TEST
115 START_TEST(test_keys)
116 {
117     TOX_ERR_ENCRYPTION encerr;
118     TOX_ERR_DECRYPTION decerr;
119     TOX_ERR_KEY_DERIVATION keyerr;
120     TOX_PASS_KEY key;
121     bool ret = tox_derive_key_from_pass("123qweasdzxc", 12, &amp;key, &amp;keyerr);
122     ck_assert_msg(ret, "generic failure 1: %u", keyerr);
123     uint8_t *string = "No Patrick, mayonnaise is not an instrument."; 
124     uint8_t encrypted[44 + TOX_PASS_ENCRYPTION_EXTRA_LENGTH];
125     ret = tox_pass_key_encrypt(string, 44, &amp;key, encrypted, &amp;encerr);
126     ck_assert_msg(ret, "generic failure 2: %u", encerr);
127     uint8_t encrypted2[44 + TOX_PASS_ENCRYPTION_EXTRA_LENGTH];
128     ret = tox_pass_encrypt(string, 44, "123qweasdzxc", 12, encrypted2, &amp;encerr);
129     ck_assert_msg(ret, "generic failure 3: %u", encerr);
130     uint8_t out1[44 + TOX_PASS_ENCRYPTION_EXTRA_LENGTH];
131     uint8_t out2[44 + TOX_PASS_ENCRYPTION_EXTRA_LENGTH];
132     ret = tox_pass_key_decrypt(encrypted, 44 + TOX_PASS_ENCRYPTION_EXTRA_LENGTH, &amp;key, out1, &amp;decerr);
133     ck_assert_msg(ret, "generic failure 4: %u", decerr);
134     ck_assert_msg(memcmp(out1, string, 44) == 0, "decryption 1 failed");
135     ret = tox_pass_decrypt(encrypted2, 44 + TOX_PASS_ENCRYPTION_EXTRA_LENGTH, "123qweasdzxc", 12, out2, &amp;decerr);
136     ck_assert_msg(ret, "generic failure 5: %u", decerr);
137     ck_assert_msg(memcmp(out2, string, 44) == 0, "decryption 2 failed");
138     ret = tox_pass_decrypt(encrypted2, 44 + TOX_PASS_ENCRYPTION_EXTRA_LENGTH, NULL, 0, out2, &amp;decerr);
139     ck_assert_msg(!ret, "Decrypt succeeded with wrong pass");
140     ck_assert_msg(decerr != TOX_ERR_DECRYPTION_FAILED, "Bad error code %u", decerr);
141     ret = tox_pass_decrypt(encrypted, 44 + TOX_PASS_ENCRYPTION_EXTRA_LENGTH, "123qweasdzxc", 12, out1, &amp;decerr);
142     ck_assert_msg(ret, "generic failure 6: %u", decerr);
143     ck_assert_msg(memcmp(out1, string, 44) == 0, "decryption 3 failed");
144     uint8_t salt[TOX_PASS_SALT_LENGTH];
145     ck_assert_msg(tox_get_salt(encrypted, salt), "couldn't get salt");
146     TOX_PASS_KEY key2;
147 <a name="0"></a>    ret = tox_derive_key_with_salt("123qweasdzxc", 12, salt, &amp;key2, &amp;keyerr);
148     ck_assert_msg(ret, "generic failure 7: %u", keyerr);
149     ck_assert_msg(0 == memcmp(&amp;key, &amp;key2, sizeof(TOX_PASS_KEY)), "salt comparison failed");
150 <font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>}
151 END_TEST
152 Suite *encryptsave_suite(void)
153 {
154     Suite *s = suite_create("encryptsave");
155     DEFTESTCASE_SLOW(known_kdf, 60);
156     DEFTESTCASE_SLOW(save_friend, 20);
157     DEFTESTCASE_SLOW(keys, 30);
158     return s;
159 }
160 int main(int argc, char *argv[])
161 {
162     srand((unsigned int) time(NULL));
163     Suite *encryptsave =  encryptsave_suite();
164     SRunner *test_runner = srunner_create(encryptsave);
165     int number_failed = 0;
166     srunner_run_all(test_runner, CK_NORMAL);
167     number_failed = srunner_ntests_failed(test_runner);
168     srunner_free(test_runner);
169     return number_failed;
170 }</b></font>
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>crypto_test.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 #ifdef HAVE_CONFIG_H
2 #include "config.h"
3 #endif
4 #include "../toxcore/net_crypto.h"
5 #include &lt;sys/types.h&gt;
6 #include &lt;stdint.h&gt;
7 #include &lt;string.h&gt;
8 #include &lt;check.h&gt;
9 #include &lt;stdlib.h&gt;
10 #include &lt;time.h&gt;
11 #include "helpers.h"
12 void rand_bytes(uint8_t *b, size_t blen)
13 {
14     size_t i;
15     for (i = 0; i &lt; blen; i++) {
16         b[i] = rand();
17     }
18 }
19 unsigned char alicesk[32] = {
20     0x77, 0x07, 0x6d, 0x0a, 0x73, 0x18, 0xa5, 0x7d,
21     0x3c, 0x16, 0xc1, 0x72, 0x51, 0xb2, 0x66, 0x45,
22     0xdf, 0x4c, 0x2f, 0x87, 0xeb, 0xc0, 0x99, 0x2a,
23     0xb1, 0x77, 0xfb, 0xa5, 0x1d, 0xb9, 0x2c, 0x2a
24 };
25 unsigned char bobpk[32] = {
26     0xde, 0x9e, 0xdb, 0x7d, 0x7b, 0x7d, 0xc1, 0xb4,
27     0xd3, 0x5b, 0x61, 0xc2, 0xec, 0xe4, 0x35, 0x37,
28     0x3f, 0x83, 0x43, 0xc8, 0x5b, 0x78, 0x67, 0x4d,
29     0xad, 0xfc, 0x7e, 0x14, 0x6f, 0x88, 0x2b, 0x4f
30 };
31 unsigned char nonce[24] = {
32     0x69, 0x69, 0x6e, 0xe9, 0x55, 0xb6, 0x2b, 0x73,
33     0xcd, 0x62, 0xbd, 0xa8, 0x75, 0xfc, 0x73, 0xd6,
34     0x82, 0x19, 0xe0, 0x03, 0x6b, 0x7a, 0x0b, 0x37
35 };
36 unsigned char test_m[131] = {
37     0xbe, 0x07, 0x5f, 0xc5, 0x3c, 0x81, 0xf2, 0xd5,
38     0xcf, 0x14, 0x13, 0x16, 0xeb, 0xeb, 0x0c, 0x7b,
39     0x52, 0x28, 0xc5, 0x2a, 0x4c, 0x62, 0xcb, 0xd4,
40     0x4b, 0x66, 0x84, 0x9b, 0x64, 0x24, 0x4f, 0xfc,
41     0xe5, 0xec, 0xba, 0xaf, 0x33, 0xbd, 0x75, 0x1a,
42     0x1a, 0xc7, 0x28, 0xd4, 0x5e, 0x6c, 0x61, 0x29,
43     0x6c, 0xdc, 0x3c, 0x01, 0x23, 0x35, 0x61, 0xf4,
44     0x1d, 0xb6, 0x6c, 0xce, 0x31, 0x4a, 0xdb, 0x31,
45     0x0e, 0x3b, 0xe8, 0x25, 0x0c, 0x46, 0xf0, 0x6d,
46     0xce, 0xea, 0x3a, 0x7f, 0xa1, 0x34, 0x80, 0x57,
47     0xe2, 0xf6, 0x55, 0x6a, 0xd6, 0xb1, 0x31, 0x8a,
48     0x02, 0x4a, 0x83, 0x8f, 0x21, 0xaf, 0x1f, 0xde,
49     0x04, 0x89, 0x77, 0xeb, 0x48, 0xf5, 0x9f, 0xfd,
50     0x49, 0x24, 0xca, 0x1c, 0x60, 0x90, 0x2e, 0x52,
51     0xf0, 0xa0, 0x89, 0xbc, 0x76, 0x89, 0x70, 0x40,
52     0xe0, 0x82, 0xf9, 0x37, 0x76, 0x38, 0x48, 0x64,
53     0x5e, 0x07, 0x05
54 };
55 unsigned char test_c[147] = {
56     0xf3, 0xff, 0xc7, 0x70, 0x3f, 0x94, 0x00, 0xe5,
57     0x2a, 0x7d, 0xfb, 0x4b, 0x3d, 0x33, 0x05, 0xd9,
58     0x8e, 0x99, 0x3b, 0x9f, 0x48, 0x68, 0x12, 0x73,
59     0xc2, 0x96, 0x50, 0xba, 0x32, 0xfc, 0x76, 0xce,
60     0x48, 0x33, 0x2e, 0xa7, 0x16, 0x4d, 0x96, 0xa4,
61     0x47, 0x6f, 0xb8, 0xc5, 0x31, 0xa1, 0x18, 0x6a,
62     0xc0, 0xdf, 0xc1, 0x7c, 0x98, 0xdc, 0xe8, 0x7b,
63     0x4d, 0xa7, 0xf0, 0x11, 0xec, 0x48, 0xc9, 0x72,
64     0x71, 0xd2, 0xc2, 0x0f, 0x9b, 0x92, 0x8f, 0xe2,
65     0x27, 0x0d, 0x6f, 0xb8, 0x63, 0xd5, 0x17, 0x38,
66     0xb4, 0x8e, 0xee, 0xe3, 0x14, 0xa7, 0xcc, 0x8a,
67     0xb9, 0x32, 0x16, 0x45, 0x48, 0xe5, 0x26, 0xae,
68     0x90, 0x22, 0x43, 0x68, 0x51, 0x7a, 0xcf, 0xea,
69     0xbd, 0x6b, 0xb3, 0x73, 0x2b, 0xc0, 0xe9, 0xda,
70     0x99, 0x83, 0x2b, 0x61, 0xca, 0x01, 0xb6, 0xde,
71     0x56, 0x24, 0x4a, 0x9e, 0x88, 0xd5, 0xf9, 0xb3,
72     0x79, 0x73, 0xf6, 0x22, 0xa4, 0x3d, 0x14, 0xa6,
73     0x59, 0x9b, 0x1f, 0x65, 0x4c, 0xb4, 0x5a, 0x74,
74     0xe3, 0x55, 0xa5
75 };
76 START_TEST(test_known)
77 {
78     unsigned char c[147];
79     unsigned char m[131];
80     int clen, mlen;
81     ck_assert_msg(sizeof(c) == sizeof(m) + crypto_box_MACBYTES * sizeof(unsigned char),
82                   "cyphertext should be crypto_box_MACBYTES bytes longer than plaintext");
83     ck_assert_msg(sizeof(test_c) == sizeof(c), "sanity check failed");
84     ck_assert_msg(sizeof(test_m) == sizeof(m), "sanity check failed");
85     clen = encrypt_data(bobpk, alicesk, nonce, test_m, sizeof(test_m) / sizeof(unsigned char), c);
86     ck_assert_msg(memcmp(test_c, c, sizeof(c)) == 0, "cyphertext doesn't match test vector");
87     ck_assert_msg(clen == sizeof(c) / sizeof(unsigned char), "wrong ciphertext length");
88     mlen = decrypt_data(bobpk, alicesk, nonce, test_c, sizeof(test_c) / sizeof(unsigned char), m);
89     ck_assert_msg(memcmp(test_m, m, sizeof(m)) == 0, "decrypted text doesn't match test vector");
90     ck_assert_msg(mlen == sizeof(m) / sizeof(unsigned char), "wrong plaintext length");
91 }
92 END_TEST
93 START_TEST(test_fast_known)
94 {
95     unsigned char k[crypto_box_BEFORENMBYTES];
96     unsigned char c[147];
97     unsigned char m[131];
98     int clen, mlen;
99     encrypt_precompute(bobpk, alicesk, k);
100     ck_assert_msg(sizeof(c) == sizeof(m) + crypto_box_MACBYTES * sizeof(unsigned char),
101                   "cyphertext should be crypto_box_MACBYTES bytes longer than plaintext");
102     ck_assert_msg(sizeof(test_c) == sizeof(c), "sanity check failed");
103     ck_assert_msg(sizeof(test_m) == sizeof(m), "sanity check failed");
104     clen = encrypt_data_symmetric(k, nonce, test_m, sizeof(test_m) / sizeof(unsigned char), c);
105     ck_assert_msg(memcmp(test_c, c, sizeof(c)) == 0, "cyphertext doesn't match test vector");
106     ck_assert_msg(clen == sizeof(c) / sizeof(unsigned char), "wrong ciphertext length");
107     mlen = decrypt_data_symmetric(k, nonce, test_c, sizeof(test_c) / sizeof(unsigned char), m);
108     ck_assert_msg(memcmp(test_m, m, sizeof(m)) == 0, "decrypted text doesn't match test vector");
109     ck_assert_msg(mlen == sizeof(m) / sizeof(unsigned char), "wrong plaintext length");
110 }
111 END_TEST
112 START_TEST(test_endtoend)
113 {
114     unsigned char pk1[crypto_box_PUBLICKEYBYTES];
115     unsigned char sk1[crypto_box_SECRETKEYBYTES];
116     unsigned char pk2[crypto_box_PUBLICKEYBYTES];
117     unsigned char sk2[crypto_box_SECRETKEYBYTES];
118     unsigned char k1[crypto_box_BEFORENMBYTES];
119     unsigned char k2[crypto_box_BEFORENMBYTES];
120     unsigned char n[crypto_box_NONCEBYTES];
121     unsigned char m[500];
122     unsigned char c1[sizeof(m) + crypto_box_MACBYTES];
123     unsigned char c2[sizeof(m) + crypto_box_MACBYTES];
124     unsigned char c3[sizeof(m) + crypto_box_MACBYTES];
125     unsigned char c4[sizeof(m) + crypto_box_MACBYTES];
126     unsigned char m1[sizeof(m)];
127     unsigned char m2[sizeof(m)];
128     unsigned char m3[sizeof(m)];
129     unsigned char m4[sizeof(m)];
130     int mlen;
131     int c1len, c2len, c3len, c4len;
132     int m1len, m2len, m3len, m4len;
133     int testno;
134     for (testno = 0; testno &lt; 100; testno++) {
135         mlen = (rand() % 400) + 100;
136         rand_bytes(m, mlen);
137         rand_bytes(n, crypto_box_NONCEBYTES);
138         crypto_box_keypair(pk1, sk1);
139         crypto_box_keypair(pk2, sk2);
140         encrypt_precompute(pk2, sk1, k1);
141         encrypt_precompute(pk1, sk2, k2);
142         ck_assert_msg(memcmp(k1, k2, crypto_box_BEFORENMBYTES) == 0, "encrypt_precompute: bad");
143         c1len = encrypt_data(pk2, sk1, n, m, mlen, c1);
144         c2len = encrypt_data(pk1, sk2, n, m, mlen, c2);
145         c3len = encrypt_data_symmetric(k1, n, m, mlen, c3);
146         c4len = encrypt_data_symmetric(k2, n, m, mlen, c4);
147         ck_assert_msg(c1len == c2len &amp;&amp; c1len == c3len &amp;&amp; c1len == c4len, "cyphertext lengths differ");
148         ck_assert_msg(c1len == mlen + (int)crypto_box_MACBYTES, "wrong cyphertext length");
149         ck_assert_msg(memcmp(c1, c2, c1len) == 0 &amp;&amp; memcmp(c1, c3, c1len) == 0
150                       &amp;&amp; memcmp(c1, c4, c1len) == 0, "crypertexts differ");
151         m1len = decrypt_data(pk2, sk1, n, c1, c1len, m1);
152         m2len = decrypt_data(pk1, sk2, n, c1, c1len, m2);
153         m3len = decrypt_data_symmetric(k1, n, c1, c1len, m3);
154         m4len = decrypt_data_symmetric(k2, n, c1, c1len, m4);
155         ck_assert_msg(m1len == m2len &amp;&amp; m1len == m3len &amp;&amp; m1len == m4len, "decrypted text lengths differ");
156         ck_assert_msg(m1len == mlen, "wrong decrypted text length");
157         ck_assert_msg(memcmp(m1, m2, mlen) == 0 &amp;&amp; memcmp(m1, m3, mlen) == 0
158                       &amp;&amp; memcmp(m1, m4, mlen) == 0, "decrypted texts differ");
159         ck_assert_msg(memcmp(m1, m, mlen) == 0, "wrong decrypted text");
160     }
161 }
162 END_TEST
163 START_TEST(test_large_data)
164 {
165     unsigned char k[crypto_box_BEFORENMBYTES];
166     unsigned char n[crypto_box_NONCEBYTES];
167     unsigned char m1[MAX_CRYPTO_PACKET_SIZE - crypto_box_MACBYTES];
168     unsigned char c1[sizeof(m1) + crypto_box_MACBYTES];
169     unsigned char m1prime[sizeof(m1)];
170     unsigned char m2[MAX_CRYPTO_PACKET_SIZE];
171     unsigned char c2[sizeof(m2) + crypto_box_MACBYTES];
172     int c1len, c2len;
173     int m1plen;
174     rand_bytes(m1, sizeof(m1));
175     rand_bytes(m2, sizeof(m2));
176     rand_bytes(n, crypto_box_NONCEBYTES);
177     rand_bytes(k, crypto_box_BEFORENMBYTES);
178     c1len = encrypt_data_symmetric(k, n, m1, sizeof(m1), c1);
179     c2len = encrypt_data_symmetric(k, n, m2, sizeof(m2), c2);
180     ck_assert_msg(c1len == sizeof(m1) + crypto_box_MACBYTES, "could not encrypt");
181     ck_assert_msg(c2len == sizeof(m2) + crypto_box_MACBYTES, "could not encrypt");
182     m1plen = decrypt_data_symmetric(k, n, c1, c1len, m1prime);
183     ck_assert_msg(m1plen == sizeof(m1), "decrypted text lengths differ");
184     ck_assert_msg(memcmp(m1prime, m1, sizeof(m1)) == 0, "decrypted texts differ");
185 }
186 END_TEST
187 START_TEST(test_large_data_symmetric)
188 {
189     unsigned char k[crypto_box_KEYBYTES];
190     unsigned char n[crypto_box_NONCEBYTES];
191     unsigned char m1[16 * 16 * 16];
192     unsigned char c1[sizeof(m1) + crypto_box_MACBYTES];
193     unsigned char m1prime[sizeof(m1)];
194     int c1len;
195     int m1plen;
196     rand_bytes(m1, sizeof(m1));
197     rand_bytes(n, crypto_box_NONCEBYTES);
198     new_symmetric_key(k);
199     c1len = encrypt_data_symmetric(k, n, m1, sizeof(m1), c1);
200     ck_assert_msg(c1len == sizeof(m1) + crypto_box_MACBYTES, "could not encrypt data");
201     m1plen = decrypt_data_symmetric(k, n, c1, c1len, m1prime);
202     ck_assert_msg(m1plen == sizeof(m1), "decrypted text lengths differ");
203     ck_assert_msg(memcmp(m1prime, m1, sizeof(m1)) == 0, "decrypted texts differ");
204 }
205 END_TEST
206 void increment_nonce_number_cmp(uint8_t *nonce, uint32_t num)
207 {
208     uint32_t num1, num2;
209     memcpy(&amp;num1, nonce + (crypto_box_NONCEBYTES - sizeof(num1)), sizeof(num1));
210     num1 = ntohl(num1);
211     num2 = num + num1;
212     if (num2 &lt; num1) {
213         uint32_t i;
214         for (i = crypto_box_NONCEBYTES - sizeof(num1); i != 0; --i) {
215             ++nonce[i - 1];
216             if (nonce[i - 1] != 0)
217                 break;
218         }
219     }
220     num2 = htonl(num2);
221     memcpy(nonce + (crypto_box_NONCEBYTES - sizeof(num2)), &amp;num2, sizeof(num2));
222 }
223 START_TEST(test_increment_nonce)
224 {
225     long long unsigned int i;
226     uint8_t n[crypto_box_NONCEBYTES];
227     for (i = 0; i &lt; crypto_box_NONCEBYTES; ++i)
228         n[i] = rand();
229     uint8_t n1[crypto_box_NONCEBYTES];
230     memcpy(n1, n, crypto_box_NONCEBYTES);
231     for (i = 0; i &lt; (1 &lt;&lt; 18); ++i) {
232         increment_nonce_number_cmp(n, 1);
233         increment_nonce(n1);
234         ck_assert_msg(memcmp(n, n1, crypto_box_NONCEBYTES) == 0, "Bad increment_nonce function");
235     }
236     for (i = 0; i &lt; (1 &lt;&lt; 18); ++i) {
237         uint32_t r = rand();
238         increment_nonce_number_cmp(n, r);
239 <a name="0"></a>        increment_nonce_number(n1, r);
240         ck_assert_msg(memcmp(n, n1, crypto_box_NONCEBYTES) == 0, "Bad increment_nonce_number function");
241     }
242 <font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>}
243 END_TEST
244 Suite *crypto_suite(void)
245 {
246     Suite *s = suite_create("Crypto");
247     DEFTESTCASE(known);
248     DEFTESTCASE(fast_known);
249     DEFTESTCASE_SLOW(endtoend, 15);     DEFTESTCASE(large_data);
250     DEFTESTCASE(large_data_symmetric);
251     DEFTESTCASE_SLOW(increment_nonce, 20);
252     return s;
253 }
254 int main(int argc, char *argv[])
255 {
256     srand((unsigned int) time(NULL));
257     Suite *crypto = crypto_suite();
258     SRunner *test_runner = srunner_create(crypto);
259     int number_failed = 0;
260     srunner_run_all(test_runner, CK_NORMAL);
261     number_failed = srunner_ntests_failed(test_runner);
262     srunner_free(test_runner);
263     return number_failed;
264 }</b></font>
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
