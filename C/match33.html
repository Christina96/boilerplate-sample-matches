<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML><HEAD><TITLE>Matches for encryptsave_test.c & crypto_test.c</TITLE>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
</HEAD>
<body>
  <div style="align-items: center; display: flex; justify-content: space-around;">
    <div>
      <h3 align="center">
Matches for encryptsave_test.c & crypto_test.c
      </h3>
      <h1 align="center">
        10.4%
      </h1>
      <center>
        <a href="index.html" target="_top">
          INDEX
        </a>
        <span>-</span>
        <a href="help-en.html" target="_top">
          HELP
        </a>
      </center>
    </div>
    <div>
<TABLE BORDER="1" CELLSPACING="0" BGCOLOR="#d0d0d0">
<TR><TH><TH>encryptsave_test.c (21.052631%)<TH>crypto_test.c (6.993007%)<TH>Tokens
<TR><TD BGCOLOR="#0000ff"><FONT COLOR="#0000ff">-</FONT><TD><A HREF="javascript:ZweiFrames('match33-0.html#0',2,'match33-1.html#0',3)" NAME="0">(181-209)<TD><A HREF="javascript:ZweiFrames('match33-0.html#0',2,'match33-1.html#0',3)" NAME="0">(322-353)</A><TD ALIGN=center><FONT COLOR="#ff0000">20</FONT>
</TABLE>
    </div>
  </div>
  <hr>
  <div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>encryptsave_test.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
#ifdef HAVE_CONFIG_H
#include &quot;config.h&quot;
#endif

#include &lt;sys/types.h&gt;
#include &lt;stdint.h&gt;
#include &lt;string.h&gt;
#include &lt;check.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;time.h&gt;

#include &quot;helpers.h&quot;

#include &quot;../toxcore/tox.h&quot;

#include &quot;../toxencryptsave/toxencryptsave.h&quot;
#include &quot;../toxcore/crypto_core.h&quot;
#ifdef VANILLA_NACL
#include &quot;../toxencryptsave/crypto_pwhash_scryptsalsa208sha256/crypto_pwhash_scryptsalsa208sha256.h&quot;
#endif

unsigned char salt[32] = {0xB1, 0xC2, 0x09, 0xEE, 0x50, 0x6C, 0xF0, 0x20, 0xC4, 0xD6, 0xEB, 0xC0, 0x44, 0x51, 0x3B, 0x60, 0x4B, 0x39, 0x4A, 0xCF, 0x09, 0x53, 0x4F, 0xEA, 0x08, 0x41, 0xFA, 0xCA, 0x66, 0xD2, 0x68, 0x7F};
unsigned char known_key[crypto_box_BEFORENMBYTES] = {0x29, 0x36, 0x1c, 0x9e, 0x65, 0xbb, 0x46, 0x8b, 0xde, 0xa1, 0xac, 0xf, 0xd5, 0x11, 0x81, 0xc8, 0x29, 0x28, 0x17, 0x23, 0xa6, 0xc3, 0x6b, 0x77, 0x2e, 0xd7, 0xd3, 0x10, 0xeb, 0xd2, 0xf7, 0xc8};
char *pw = &quot;hunter2&quot;;
unsigned int pwlen = 7;

unsigned char known_key2[crypto_box_BEFORENMBYTES] = {0x7a, 0xfa, 0x95, 0x45, 0x36, 0x8a, 0xa2, 0x5c, 0x40, 0xfd, 0xc0, 0xe2, 0x35, 0x8, 0x7, 0x88, 0xfa, 0xf9, 0x37, 0x86, 0xeb, 0xff, 0x50, 0x4f, 0x3, 0xe2, 0xf6, 0xd9, 0xef, 0x9, 0x17, 0x1};
// same as above, except standard opslimit instead of extra ops limit for test_known_kdf, and hash pw before kdf for compat

/* cause I'm shameless */
void accept_friend_request(Tox *m, const uint8_t *public_key, const uint8_t *data, size_t length, void *userdata)
{
    if (*((uint32_t *)userdata) != 974536)
        return;

    if (length == 7 &amp;&amp; memcmp(&quot;Gentoo&quot;, data, 7) == 0) {
        tox_friend_add_norequest(m, public_key, 0);
    }
}

START_TEST(test_known_kdf)
{
    unsigned char out[crypto_box_BEFORENMBYTES];
    crypto_pwhash_scryptsalsa208sha256(out,
                                       crypto_box_BEFORENMBYTES,
                                       pw,
                                       pwlen,
                                       salt,
                                       crypto_pwhash_scryptsalsa208sha256_OPSLIMIT_INTERACTIVE * 8,
                                       crypto_pwhash_scryptsalsa208sha256_MEMLIMIT_INTERACTIVE);
    ck_assert_msg(memcmp(out, known_key, crypto_box_BEFORENMBYTES) == 0, &quot;derived key is wrong&quot;);
}
END_TEST

START_TEST(test_save_friend)
{
    Tox *tox1 = tox_new(0, 0);
    Tox *tox2 = tox_new(0, 0);
    ck_assert_msg(tox1 || tox2, &quot;Failed to create 2 tox instances&quot;);
    uint32_t to_compare = 974536;
    tox_callback_friend_request(tox2, accept_friend_request, &amp;to_compare);
    uint8_t address[TOX_ADDRESS_SIZE];
    tox_self_get_address(tox2, address);
    uint32_t test = tox_friend_add(tox1, address, (uint8_t *)&quot;Gentoo&quot;, 7, 0);
    ck_assert_msg(test != UINT32_MAX, &quot;Failed to add friend&quot;);

    size_t size = tox_get_savedata_size(tox1);
    uint8_t data[size];
    tox_get_savedata(tox1, data);
    size_t size2 = size + TOX_PASS_ENCRYPTION_EXTRA_LENGTH;
    uint8_t enc_data[size2];
    TOX_ERR_ENCRYPTION error1;
    bool ret = tox_pass_encrypt(data, size, &quot;correcthorsebatterystaple&quot;, 25, enc_data, &amp;error1);
    ck_assert_msg(ret, &quot;failed to encrypted save: %u&quot;, error1);
    ck_assert_msg(tox_is_data_encrypted(enc_data), &quot;magic number missing&quot;);

    struct Tox_Options options;
    tox_options_default(&amp;options);
    options.savedata_type = TOX_SAVEDATA_TYPE_TOX_SAVE;
    options.savedata_data = enc_data;
    options.savedata_length = size2;

    TOX_ERR_NEW err2;
    Tox *tox3 = tox_new(&amp;options, &amp;err2);
    ck_assert_msg(err2 == TOX_ERR_NEW_LOAD_ENCRYPTED, &quot;wrong error! %u. should fail with %u&quot;, err2,
                  TOX_ERR_NEW_LOAD_ENCRYPTED);
    uint8_t dec_data[size];
    TOX_ERR_DECRYPTION err3;
    ret = tox_pass_decrypt(enc_data, size2, &quot;correcthorsebatterystaple&quot;, 25, dec_data, &amp;err3);
    ck_assert_msg(ret, &quot;failed to decrypt save: %u&quot;, err3);
    options.savedata_data = dec_data;
    options.savedata_length = size;
    tox3 = tox_new(&amp;options, &amp;err2);
    ck_assert_msg(err2 == TOX_ERR_NEW_OK, &quot;failed to load from decrypted data: %u&quot;, err2);
    uint8_t address2[TOX_PUBLIC_KEY_SIZE];
    ret = tox_friend_get_public_key(tox3, 0, address2, 0);
    ck_assert_msg(ret, &quot;no friends!&quot;);
    ck_assert_msg(memcmp(address, address2, TOX_PUBLIC_KEY_SIZE) == 0, &quot;addresses don't match!&quot;);

    size = tox_get_savedata_size(tox3);
    uint8_t data2[size];
    tox_get_savedata(tox3, data2);
    TOX_PASS_KEY key;
    memcpy(key.salt, salt, 32);
    memcpy(key.key, known_key2, crypto_box_BEFORENMBYTES);
    size2 = size + TOX_PASS_ENCRYPTION_EXTRA_LENGTH;
    uint8_t encdata2[size2];
    ret = tox_pass_key_encrypt(data2, size, &amp;key, encdata2, &amp;error1);
    ck_assert_msg(ret, &quot;failed to key encrypt %u&quot;, error1);
    ck_assert_msg(tox_is_data_encrypted(encdata2), &quot;magic number the second missing&quot;);

    uint8_t out1[size], out2[size];
    ret = tox_pass_decrypt(encdata2, size2, pw, pwlen, out1, &amp;err3);
    ck_assert_msg(ret, &quot;failed to pw decrypt %u&quot;, err3);
    ret = tox_pass_key_decrypt(encdata2, size2, &amp;key, out2, &amp;err3);
    ck_assert_msg(ret, &quot;failed to key decrypt %u&quot;, err3);
    ck_assert_msg(memcmp(out1, out2, size) == 0, &quot;differing output data&quot;);

    // and now with the code in use (I only bothered with manually to debug this, and it seems a waste
    // to remove the manual check now that it's there)
    options.savedata_data = out1;
    options.savedata_length = size;
    Tox *tox4 = tox_new(&amp;options, &amp;err2);
    ck_assert_msg(err2 == TOX_ERR_NEW_OK, &quot;failed to new the third&quot;);
    uint8_t address5[TOX_PUBLIC_KEY_SIZE];
    ret = tox_friend_get_public_key(tox4, 0, address5, 0);
    ck_assert_msg(ret, &quot;no friends! the third&quot;);
    ck_assert_msg(memcmp(address, address2, TOX_PUBLIC_KEY_SIZE) == 0, &quot;addresses don't match! the third&quot;);

    tox_kill(tox1);
    tox_kill(tox2);
    tox_kill(tox3);
    tox_kill(tox4);
}
END_TEST

START_TEST(test_keys)
{
    TOX_ERR_ENCRYPTION encerr;
    TOX_ERR_DECRYPTION decerr;
    TOX_ERR_KEY_DERIVATION keyerr;
    TOX_PASS_KEY key;
    bool ret = tox_derive_key_from_pass(&quot;123qweasdzxc&quot;, 12, &amp;key, &amp;keyerr);
    ck_assert_msg(ret, &quot;generic failure 1: %u&quot;, keyerr);
    uint8_t *string = &quot;No Patrick, mayonnaise is not an instrument.&quot;; // 44

    uint8_t encrypted[44 + TOX_PASS_ENCRYPTION_EXTRA_LENGTH];
    ret = tox_pass_key_encrypt(string, 44, &amp;key, encrypted, &amp;encerr);
    ck_assert_msg(ret, &quot;generic failure 2: %u&quot;, encerr);

    uint8_t encrypted2[44 + TOX_PASS_ENCRYPTION_EXTRA_LENGTH];
    ret = tox_pass_encrypt(string, 44, &quot;123qweasdzxc&quot;, 12, encrypted2, &amp;encerr);
    ck_assert_msg(ret, &quot;generic failure 3: %u&quot;, encerr);

    uint8_t out1[44 + TOX_PASS_ENCRYPTION_EXTRA_LENGTH];
    uint8_t out2[44 + TOX_PASS_ENCRYPTION_EXTRA_LENGTH];

    ret = tox_pass_key_decrypt(encrypted, 44 + TOX_PASS_ENCRYPTION_EXTRA_LENGTH, &amp;key, out1, &amp;decerr);
    ck_assert_msg(ret, &quot;generic failure 4: %u&quot;, decerr);
    ck_assert_msg(memcmp(out1, string, 44) == 0, &quot;decryption 1 failed&quot;);

    ret = tox_pass_decrypt(encrypted2, 44 + TOX_PASS_ENCRYPTION_EXTRA_LENGTH, &quot;123qweasdzxc&quot;, 12, out2, &amp;decerr);
    ck_assert_msg(ret, &quot;generic failure 5: %u&quot;, decerr);
    ck_assert_msg(memcmp(out2, string, 44) == 0, &quot;decryption 2 failed&quot;);

    ret = tox_pass_decrypt(encrypted2, 44 + TOX_PASS_ENCRYPTION_EXTRA_LENGTH, NULL, 0, out2, &amp;decerr);
    ck_assert_msg(!ret, &quot;Decrypt succeeded with wrong pass&quot;);
    ck_assert_msg(decerr != TOX_ERR_DECRYPTION_FAILED, &quot;Bad error code %u&quot;, decerr);

    // test that pass_decrypt can decrypt things from pass_key_encrypt
    ret = tox_pass_decrypt(encrypted, 44 + TOX_PASS_ENCRYPTION_EXTRA_LENGTH, &quot;123qweasdzxc&quot;, 12, out1, &amp;decerr);
    ck_assert_msg(ret, &quot;generic failure 6: %u&quot;, decerr);
    ck_assert_msg(memcmp(out1, string, 44) == 0, &quot;decryption 3 failed&quot;);

    uint8_t salt[TOX_PASS_SALT_LENGTH];
    ck_assert_msg(tox_get_salt(encrypted, salt), &quot;couldn't get salt&quot;);
    TOX_PASS_KEY key2;
<A NAME="0"></A>    ret = tox_derive_key_with_salt(&quot;123qweasdzxc&quot;, 12, salt, &amp;key2, &amp;keyerr);
    ck_assert_msg(ret, &quot;generic failure 7: %u&quot;, keyerr);
    ck_assert_msg(0 == memcmp(&amp;key, &amp;key2, sizeof(TOX_PASS_KEY)), &quot;salt comparison failed&quot;);
<FONT color="#0000ff"><A HREF="javascript:ZweiFrames('match33-1.html#0',3,'match33-top.html#0',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>}
END_TEST

Suite *encryptsave_suite(void)
{
    Suite *s = suite_create(&quot;encryptsave&quot;);

    DEFTESTCASE_SLOW(known_kdf, 60);
    DEFTESTCASE_SLOW(save_friend, 20);
    DEFTESTCASE_SLOW(keys, 30);

    return s;
}

int main(int argc, char *argv[])
{
    srand((unsigned int) time(NULL));

    Suite *encryptsave =  encryptsave_suite();
    SRunner *test_runner = srunner_create(encryptsave);

    int number_failed = 0;
    srunner_run_all(test_runner, CK_NORMAL);
    number_failed = srunner_ntests_failed(test_runner);

    srunner_free(test_runner);

    return number_failed;
}</B></FONT>

</PRE>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>crypto_test.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
#ifdef HAVE_CONFIG_H
#include &quot;config.h&quot;
#endif

#include &quot;../toxcore/net_crypto.h&quot;
#include &lt;sys/types.h&gt;
#include &lt;stdint.h&gt;
#include &lt;string.h&gt;
#include &lt;check.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;time.h&gt;

#include &quot;helpers.h&quot;

void rand_bytes(uint8_t *b, size_t blen)
{
    size_t i;

    for (i = 0; i &lt; blen; i++) {
        b[i] = rand();
    }
}

// These test vectors are from libsodium's test suite

unsigned char alicesk[32] = {
    0x77, 0x07, 0x6d, 0x0a, 0x73, 0x18, 0xa5, 0x7d,
    0x3c, 0x16, 0xc1, 0x72, 0x51, 0xb2, 0x66, 0x45,
    0xdf, 0x4c, 0x2f, 0x87, 0xeb, 0xc0, 0x99, 0x2a,
    0xb1, 0x77, 0xfb, 0xa5, 0x1d, 0xb9, 0x2c, 0x2a
};

unsigned char bobpk[32] = {
    0xde, 0x9e, 0xdb, 0x7d, 0x7b, 0x7d, 0xc1, 0xb4,
    0xd3, 0x5b, 0x61, 0xc2, 0xec, 0xe4, 0x35, 0x37,
    0x3f, 0x83, 0x43, 0xc8, 0x5b, 0x78, 0x67, 0x4d,
    0xad, 0xfc, 0x7e, 0x14, 0x6f, 0x88, 0x2b, 0x4f
};

unsigned char nonce[24] = {
    0x69, 0x69, 0x6e, 0xe9, 0x55, 0xb6, 0x2b, 0x73,
    0xcd, 0x62, 0xbd, 0xa8, 0x75, 0xfc, 0x73, 0xd6,
    0x82, 0x19, 0xe0, 0x03, 0x6b, 0x7a, 0x0b, 0x37
};

unsigned char test_m[131] = {
    0xbe, 0x07, 0x5f, 0xc5, 0x3c, 0x81, 0xf2, 0xd5,
    0xcf, 0x14, 0x13, 0x16, 0xeb, 0xeb, 0x0c, 0x7b,
    0x52, 0x28, 0xc5, 0x2a, 0x4c, 0x62, 0xcb, 0xd4,
    0x4b, 0x66, 0x84, 0x9b, 0x64, 0x24, 0x4f, 0xfc,
    0xe5, 0xec, 0xba, 0xaf, 0x33, 0xbd, 0x75, 0x1a,
    0x1a, 0xc7, 0x28, 0xd4, 0x5e, 0x6c, 0x61, 0x29,
    0x6c, 0xdc, 0x3c, 0x01, 0x23, 0x35, 0x61, 0xf4,
    0x1d, 0xb6, 0x6c, 0xce, 0x31, 0x4a, 0xdb, 0x31,
    0x0e, 0x3b, 0xe8, 0x25, 0x0c, 0x46, 0xf0, 0x6d,
    0xce, 0xea, 0x3a, 0x7f, 0xa1, 0x34, 0x80, 0x57,
    0xe2, 0xf6, 0x55, 0x6a, 0xd6, 0xb1, 0x31, 0x8a,
    0x02, 0x4a, 0x83, 0x8f, 0x21, 0xaf, 0x1f, 0xde,
    0x04, 0x89, 0x77, 0xeb, 0x48, 0xf5, 0x9f, 0xfd,
    0x49, 0x24, 0xca, 0x1c, 0x60, 0x90, 0x2e, 0x52,
    0xf0, 0xa0, 0x89, 0xbc, 0x76, 0x89, 0x70, 0x40,
    0xe0, 0x82, 0xf9, 0x37, 0x76, 0x38, 0x48, 0x64,
    0x5e, 0x07, 0x05
};

unsigned char test_c[147] = {
    0xf3, 0xff, 0xc7, 0x70, 0x3f, 0x94, 0x00, 0xe5,
    0x2a, 0x7d, 0xfb, 0x4b, 0x3d, 0x33, 0x05, 0xd9,
    0x8e, 0x99, 0x3b, 0x9f, 0x48, 0x68, 0x12, 0x73,
    0xc2, 0x96, 0x50, 0xba, 0x32, 0xfc, 0x76, 0xce,
    0x48, 0x33, 0x2e, 0xa7, 0x16, 0x4d, 0x96, 0xa4,
    0x47, 0x6f, 0xb8, 0xc5, 0x31, 0xa1, 0x18, 0x6a,
    0xc0, 0xdf, 0xc1, 0x7c, 0x98, 0xdc, 0xe8, 0x7b,
    0x4d, 0xa7, 0xf0, 0x11, 0xec, 0x48, 0xc9, 0x72,
    0x71, 0xd2, 0xc2, 0x0f, 0x9b, 0x92, 0x8f, 0xe2,
    0x27, 0x0d, 0x6f, 0xb8, 0x63, 0xd5, 0x17, 0x38,
    0xb4, 0x8e, 0xee, 0xe3, 0x14, 0xa7, 0xcc, 0x8a,
    0xb9, 0x32, 0x16, 0x45, 0x48, 0xe5, 0x26, 0xae,
    0x90, 0x22, 0x43, 0x68, 0x51, 0x7a, 0xcf, 0xea,
    0xbd, 0x6b, 0xb3, 0x73, 0x2b, 0xc0, 0xe9, 0xda,
    0x99, 0x83, 0x2b, 0x61, 0xca, 0x01, 0xb6, 0xde,
    0x56, 0x24, 0x4a, 0x9e, 0x88, 0xd5, 0xf9, 0xb3,
    0x79, 0x73, 0xf6, 0x22, 0xa4, 0x3d, 0x14, 0xa6,
    0x59, 0x9b, 0x1f, 0x65, 0x4c, 0xb4, 0x5a, 0x74,
    0xe3, 0x55, 0xa5
};

START_TEST(test_known)
{
    unsigned char c[147];
    unsigned char m[131];
    int clen, mlen;

    ck_assert_msg(sizeof(c) == sizeof(m) + crypto_box_MACBYTES * sizeof(unsigned char),
                  &quot;cyphertext should be crypto_box_MACBYTES bytes longer than plaintext&quot;);
    ck_assert_msg(sizeof(test_c) == sizeof(c), &quot;sanity check failed&quot;);
    ck_assert_msg(sizeof(test_m) == sizeof(m), &quot;sanity check failed&quot;);

    clen = encrypt_data(bobpk, alicesk, nonce, test_m, sizeof(test_m) / sizeof(unsigned char), c);

    ck_assert_msg(memcmp(test_c, c, sizeof(c)) == 0, &quot;cyphertext doesn't match test vector&quot;);
    ck_assert_msg(clen == sizeof(c) / sizeof(unsigned char), &quot;wrong ciphertext length&quot;);

    mlen = decrypt_data(bobpk, alicesk, nonce, test_c, sizeof(test_c) / sizeof(unsigned char), m);

    ck_assert_msg(memcmp(test_m, m, sizeof(m)) == 0, &quot;decrypted text doesn't match test vector&quot;);
    ck_assert_msg(mlen == sizeof(m) / sizeof(unsigned char), &quot;wrong plaintext length&quot;);
}
END_TEST

START_TEST(test_fast_known)
{
    unsigned char k[crypto_box_BEFORENMBYTES];
    unsigned char c[147];
    unsigned char m[131];
    int clen, mlen;

    encrypt_precompute(bobpk, alicesk, k);

    ck_assert_msg(sizeof(c) == sizeof(m) + crypto_box_MACBYTES * sizeof(unsigned char),
                  &quot;cyphertext should be crypto_box_MACBYTES bytes longer than plaintext&quot;);
    ck_assert_msg(sizeof(test_c) == sizeof(c), &quot;sanity check failed&quot;);
    ck_assert_msg(sizeof(test_m) == sizeof(m), &quot;sanity check failed&quot;);

    clen = encrypt_data_symmetric(k, nonce, test_m, sizeof(test_m) / sizeof(unsigned char), c);

    ck_assert_msg(memcmp(test_c, c, sizeof(c)) == 0, &quot;cyphertext doesn't match test vector&quot;);
    ck_assert_msg(clen == sizeof(c) / sizeof(unsigned char), &quot;wrong ciphertext length&quot;);

    mlen = decrypt_data_symmetric(k, nonce, test_c, sizeof(test_c) / sizeof(unsigned char), m);

    ck_assert_msg(memcmp(test_m, m, sizeof(m)) == 0, &quot;decrypted text doesn't match test vector&quot;);
    ck_assert_msg(mlen == sizeof(m) / sizeof(unsigned char), &quot;wrong plaintext length&quot;);

}
END_TEST

START_TEST(test_endtoend)
{
    unsigned char pk1[crypto_box_PUBLICKEYBYTES];
    unsigned char sk1[crypto_box_SECRETKEYBYTES];
    unsigned char pk2[crypto_box_PUBLICKEYBYTES];
    unsigned char sk2[crypto_box_SECRETKEYBYTES];
    unsigned char k1[crypto_box_BEFORENMBYTES];
    unsigned char k2[crypto_box_BEFORENMBYTES];

    unsigned char n[crypto_box_NONCEBYTES];

    unsigned char m[500];
    unsigned char c1[sizeof(m) + crypto_box_MACBYTES];
    unsigned char c2[sizeof(m) + crypto_box_MACBYTES];
    unsigned char c3[sizeof(m) + crypto_box_MACBYTES];
    unsigned char c4[sizeof(m) + crypto_box_MACBYTES];
    unsigned char m1[sizeof(m)];
    unsigned char m2[sizeof(m)];
    unsigned char m3[sizeof(m)];
    unsigned char m4[sizeof(m)];

    int mlen;
    int c1len, c2len, c3len, c4len;
    int m1len, m2len, m3len, m4len;

    int testno;

    // Test 100 random messages and keypairs
    for (testno = 0; testno &lt; 100; testno++) {
        //Generate random message (random length from 100 to 500)
        mlen = (rand() % 400) + 100;
        rand_bytes(m, mlen);
        rand_bytes(n, crypto_box_NONCEBYTES);

        //Generate keypairs
        crypto_box_keypair(pk1, sk1);
        crypto_box_keypair(pk2, sk2);

        //Precompute shared keys
        encrypt_precompute(pk2, sk1, k1);
        encrypt_precompute(pk1, sk2, k2);

        ck_assert_msg(memcmp(k1, k2, crypto_box_BEFORENMBYTES) == 0, &quot;encrypt_precompute: bad&quot;);

        //Encrypt all four ways
        c1len = encrypt_data(pk2, sk1, n, m, mlen, c1);
        c2len = encrypt_data(pk1, sk2, n, m, mlen, c2);
        c3len = encrypt_data_symmetric(k1, n, m, mlen, c3);
        c4len = encrypt_data_symmetric(k2, n, m, mlen, c4);

        ck_assert_msg(c1len == c2len &amp;&amp; c1len == c3len &amp;&amp; c1len == c4len, &quot;cyphertext lengths differ&quot;);
        ck_assert_msg(c1len == mlen + (int)crypto_box_MACBYTES, &quot;wrong cyphertext length&quot;);
        ck_assert_msg(memcmp(c1, c2, c1len) == 0 &amp;&amp; memcmp(c1, c3, c1len) == 0
                      &amp;&amp; memcmp(c1, c4, c1len) == 0, &quot;crypertexts differ&quot;);

        //Decrypt all four ways
        m1len = decrypt_data(pk2, sk1, n, c1, c1len, m1);
        m2len = decrypt_data(pk1, sk2, n, c1, c1len, m2);
        m3len = decrypt_data_symmetric(k1, n, c1, c1len, m3);
        m4len = decrypt_data_symmetric(k2, n, c1, c1len, m4);

        ck_assert_msg(m1len == m2len &amp;&amp; m1len == m3len &amp;&amp; m1len == m4len, &quot;decrypted text lengths differ&quot;);
        ck_assert_msg(m1len == mlen, &quot;wrong decrypted text length&quot;);
        ck_assert_msg(memcmp(m1, m2, mlen) == 0 &amp;&amp; memcmp(m1, m3, mlen) == 0
                      &amp;&amp; memcmp(m1, m4, mlen) == 0, &quot;decrypted texts differ&quot;);
        ck_assert_msg(memcmp(m1, m, mlen) == 0, &quot;wrong decrypted text&quot;);
    }
}
END_TEST

START_TEST(test_large_data)
{
    unsigned char k[crypto_box_BEFORENMBYTES];

    unsigned char n[crypto_box_NONCEBYTES];

    unsigned char m1[MAX_CRYPTO_PACKET_SIZE - crypto_box_MACBYTES];
    unsigned char c1[sizeof(m1) + crypto_box_MACBYTES];
    unsigned char m1prime[sizeof(m1)];

    unsigned char m2[MAX_CRYPTO_PACKET_SIZE];
    unsigned char c2[sizeof(m2) + crypto_box_MACBYTES];

    int c1len, c2len;
    int m1plen;

    //Generate random messages
    rand_bytes(m1, sizeof(m1));
    rand_bytes(m2, sizeof(m2));
    rand_bytes(n, crypto_box_NONCEBYTES);

    //Generate key
    rand_bytes(k, crypto_box_BEFORENMBYTES);

    c1len = encrypt_data_symmetric(k, n, m1, sizeof(m1), c1);
    c2len = encrypt_data_symmetric(k, n, m2, sizeof(m2), c2);

    ck_assert_msg(c1len == sizeof(m1) + crypto_box_MACBYTES, &quot;could not encrypt&quot;);
    ck_assert_msg(c2len == sizeof(m2) + crypto_box_MACBYTES, &quot;could not encrypt&quot;);

    m1plen = decrypt_data_symmetric(k, n, c1, c1len, m1prime);

    ck_assert_msg(m1plen == sizeof(m1), &quot;decrypted text lengths differ&quot;);
    ck_assert_msg(memcmp(m1prime, m1, sizeof(m1)) == 0, &quot;decrypted texts differ&quot;);
}
END_TEST

START_TEST(test_large_data_symmetric)
{
    unsigned char k[crypto_box_KEYBYTES];

    unsigned char n[crypto_box_NONCEBYTES];

    unsigned char m1[16 * 16 * 16];
    unsigned char c1[sizeof(m1) + crypto_box_MACBYTES];
    unsigned char m1prime[sizeof(m1)];

    int c1len;
    int m1plen;

    //Generate random messages
    rand_bytes(m1, sizeof(m1));
    rand_bytes(n, crypto_box_NONCEBYTES);

    //Generate key
    new_symmetric_key(k);

    c1len = encrypt_data_symmetric(k, n, m1, sizeof(m1), c1);
    ck_assert_msg(c1len == sizeof(m1) + crypto_box_MACBYTES, &quot;could not encrypt data&quot;);

    m1plen = decrypt_data_symmetric(k, n, c1, c1len, m1prime);

    ck_assert_msg(m1plen == sizeof(m1), &quot;decrypted text lengths differ&quot;);
    ck_assert_msg(memcmp(m1prime, m1, sizeof(m1)) == 0, &quot;decrypted texts differ&quot;);
}
END_TEST

void increment_nonce_number_cmp(uint8_t *nonce, uint32_t num)
{
    uint32_t num1, num2;
    memcpy(&amp;num1, nonce + (crypto_box_NONCEBYTES - sizeof(num1)), sizeof(num1));
    num1 = ntohl(num1);
    num2 = num + num1;

    if (num2 &lt; num1) {
        uint32_t i;

        for (i = crypto_box_NONCEBYTES - sizeof(num1); i != 0; --i) {
            ++nonce[i - 1];

            if (nonce[i - 1] != 0)
                break;
        }
    }

    num2 = htonl(num2);
    memcpy(nonce + (crypto_box_NONCEBYTES - sizeof(num2)), &amp;num2, sizeof(num2));
}

START_TEST(test_increment_nonce)
{
    long long unsigned int i;

    uint8_t n[crypto_box_NONCEBYTES];

    for (i = 0; i &lt; crypto_box_NONCEBYTES; ++i)
        n[i] = rand();

    uint8_t n1[crypto_box_NONCEBYTES];

    memcpy(n1, n, crypto_box_NONCEBYTES);

    for (i = 0; i &lt; (1 &lt;&lt; 18); ++i) {
        increment_nonce_number_cmp(n, 1);
        increment_nonce(n1);
        ck_assert_msg(memcmp(n, n1, crypto_box_NONCEBYTES) == 0, &quot;Bad increment_nonce function&quot;);
    }

    for (i = 0; i &lt; (1 &lt;&lt; 18); ++i) {
        uint32_t r = rand();
        increment_nonce_number_cmp(n, r);
<A NAME="0"></A>        increment_nonce_number(n1, r);
        ck_assert_msg(memcmp(n, n1, crypto_box_NONCEBYTES) == 0, &quot;Bad increment_nonce_number function&quot;);
    }
<FONT color="#0000ff"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match33-0.html#0',2,'match33-top.html#0',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>}
END_TEST

Suite *crypto_suite(void)
{
    Suite *s = suite_create(&quot;Crypto&quot;);

    DEFTESTCASE(known);
    DEFTESTCASE(fast_known);
    DEFTESTCASE_SLOW(endtoend, 15); /* waiting up to 15 seconds */
    DEFTESTCASE(large_data);
    DEFTESTCASE(large_data_symmetric);
    DEFTESTCASE_SLOW(increment_nonce, 20);

    return s;
}

int main(int argc, char *argv[])
{
    srand((unsigned int) time(NULL));

    Suite *crypto = crypto_suite();
    SRunner *test_runner = srunner_create(crypto);
    int number_failed = 0;

    srunner_run_all(test_runner, CK_NORMAL);
    number_failed = srunner_ntests_failed(test_runner);

    srunner_free(test_runner);

    return number_failed;
}</B></FONT>
</PRE>
</div>
  </div>
</body>
</html>
