<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for rainerscript.c &amp; omstdout.c</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for rainerscript.c &amp; omstdout.c
      </h3>
<h1 align="center">
        0.4%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>rainerscript.c (0.21245302%)<th>omstdout.c (6.372549%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(72-79)<td><a href="#" name="0">(80-87)</a><td align="center"><font color="#ff0000">13</font>
</td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>rainerscript.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 #include "config.h"
2 #include &lt;stdio.h&gt;
3 #include &lt;stdlib.h&gt;
4 #include &lt;string.h&gt;
5 #include &lt;ctype.h&gt;
6 #include &lt;glob.h&gt;
7 #include &lt;errno.h&gt;
8 #include &lt;pwd.h&gt;
9 #include &lt;grp.h&gt;
10 #include &lt;unistd.h&gt;
11 #include &lt;sys/stat.h&gt;
12 #include &lt;sys/types.h&gt;
13 #include &lt;libestr.h&gt;
14 #include &lt;time.h&gt;
15 #include "rsyslog.h"
16 #include "rainerscript.h"
17 #include "conf.h"
18 #include "parserif.h"
19 #include "parse.h"
20 #include "rsconf.h"
21 #include "grammar.h"
22 #include "queue.h"
23 #include "srUtils.h"
24 #include "regexp.h"
25 #include "datetime.h"
26 #include "obj.h"
27 #include "modules.h"
28 #include "ruleset.h"
29 #include "msg.h"
30 #include "wti.h"
31 #include "unicode-helper.h"
32 #include "errmsg.h"
33 PRAGMA_INGORE_Wswitch_enum
34 DEFobjCurrIf(obj)
35 DEFobjCurrIf(regexp)
36 DEFobjCurrIf(datetime)
37 struct cnfexpr* cnfexprOptimize(struct cnfexpr *expr);
38 static void cnfstmtOptimizePRIFilt(struct cnfstmt *stmt);
39 static void cnfarrayPrint(struct cnfarray *ar, int indent);
40 struct cnffunc * cnffuncNew_prifilt(int fac);
41 <a name="0"></a>
42 static struct cnfparamdescr incpdescr[] = {
43 	{ "file", eCmdHdlrString, 0 },
44 <font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>	{ "text", eCmdHdlrString, 0 },
45 	{ "mode", eCmdHdlrGetWord, 0 }
46 };
47 static struct cnfparamblk incpblk =
48 	{ CNFPARAMBLK_VERSION,
49 	  sizeof(incpdescr)/sizeof(struct cnfparamdescr),
50 	  incpdescr
51 	};</b></font>
52 static const char *
53 tokenToString(const int token)
54 {
55 	const char *tokstr;
56 	static char tokbuf[512];
57 	switch(token) {
58 	case NAME: tokstr = "NAME"; break;
59 	case FUNC: tokstr = "FUNC"; break;
60 	case BEGINOBJ: tokstr ="BEGINOBJ"; break;
61 	case ENDOBJ: tokstr ="ENDOBJ"; break;
62 	case BEGIN_ACTION: tokstr ="BEGIN_ACTION"; break;
63 	case BEGIN_PROPERTY: tokstr ="BEGIN_PROPERTY"; break;
64 	case BEGIN_CONSTANT: tokstr ="BEGIN_CONSTANT"; break;
65 	case BEGIN_TPL: tokstr ="BEGIN_TPL"; break;
66 	case BEGIN_RULESET: tokstr ="BEGIN_RULESET"; break;
67 	case STOP: tokstr ="STOP"; break;
68 	case SET: tokstr ="SET"; break;
69 	case UNSET: tokstr ="UNSET"; break;
70 	case CONTINUE: tokstr ="CONTINUE"; break;
71 	case CALL: tokstr ="CALL"; break;
72 	case LEGACY_ACTION: tokstr ="LEGACY_ACTION"; break;
73 	case LEGACY_RULESET: tokstr ="LEGACY_RULESET"; break;
74 	case PRIFILT: tokstr ="PRIFILT"; break;
75 	case PROPFILT: tokstr ="PROPFILT"; break;
76 	case IF: tokstr ="IF"; break;
77 	case THEN: tokstr ="THEN"; break;
78 	case ELSE: tokstr ="ELSE"; break;
79 	case OR: tokstr ="OR"; break;
80 	case AND: tokstr ="AND"; break;
81 	case NOT: tokstr ="NOT"; break;
82 	case VAR: tokstr ="VAR"; break;
83 	case STRING: tokstr ="STRING"; break;
84 	case NUMBER: tokstr ="NUMBER"; break;
85 	case CMP_EQ: tokstr ="CMP_EQ"; break;
86 	case CMP_NE: tokstr ="CMP_NE"; break;
87 	case CMP_LE: tokstr ="CMP_LE"; break;
88 	case CMP_GE: tokstr ="CMP_GE"; break;
89 	case CMP_LT: tokstr ="CMP_LT"; break;
90 	case CMP_GT: tokstr ="CMP_GT"; break;
91 	case CMP_CONTAINS: tokstr ="CMP_CONTAINS"; break;
92 	case CMP_CONTAINSI: tokstr ="CMP_CONTAINSI"; break;
93 	case CMP_STARTSWITH: tokstr ="CMP_STARTSWITH"; break;
94 	case CMP_STARTSWITHI: tokstr ="CMP_STARTSWITHI"; break;
95 	case UMINUS: tokstr ="UMINUS"; break;
96 	case '&amp;': tokstr ="&amp;"; break;
97 	case '+': tokstr ="+"; break;
98 	case '-': tokstr ="-"; break;
99 	case '*': tokstr ="*"; break;
100 	case '/': tokstr ="/"; break;
101 	case '%': tokstr ="%"; break;
102 	case 'M': tokstr ="M"; break;
103 	case 'N': tokstr ="N"; break;
104 	case 'S': tokstr ="S"; break;
105 	case 'V': tokstr ="V"; break;
106 	case 'F': tokstr ="F"; break;
107 	case 'A': tokstr ="A"; break;
108 	case S_FUNC_EXISTS: tokstr ="exists()"; break;
109 	default: snprintf(tokbuf, sizeof(tokbuf), "%c[%d]", token, token);
110 		 tokstr = tokbuf; break;
111 	}
112 	return tokstr;
113 }
114 const char*
115 getFIOPName(const unsigned iFIOP)
116 {
117 	const char *pRet;
118 	switch(iFIOP) {
119 		case FIOP_CONTAINS:
120 			pRet = "contains";
121 			break;
122 		case FIOP_ISEQUAL:
123 			pRet = "isequal";
124 			break;
125 		case FIOP_STARTSWITH:
126 			pRet = "startswith";
127 			break;
128 		case FIOP_REGEX:
129 			pRet = "regex";
130 			break;
131 		case FIOP_EREREGEX:
132 			pRet = "ereregex";
133 			break;
134 		case FIOP_ISEMPTY:
135 			pRet = "isempty";
136 			break;
137 		default:
138 			pRet = "NOP";
139 			break;
140 	}
141 	return pRet;
142 }
143 const char*
144 cnfFiltType2str(const enum cnfFiltType filttype)
145 {
146 	switch(filttype) {
147 	case CNFFILT_NONE:
148 		return("filter:none");
149 	case CNFFILT_PRI:
150 		return("filter:pri");
151 	case CNFFILT_PROP:
152 		return("filter:prop");
153 	case CNFFILT_SCRIPT:
154 		return("filter:script");
155 	default:
156 		return("error:invalid_filter_type");		}
157 }
158 const char*
159 cnfobjType2str(const enum cnfobjType ot)
160 {
161 	switch(ot) {
162 	case CNFOBJ_ACTION:
163 		return "action";
164 		break;
165 	case CNFOBJ_RULESET:
166 		return "ruleset";
167 		break;
168 	case CNFOBJ_GLOBAL:
169 		return "global";
170 		break;
171 	case CNFOBJ_INPUT:
172 		return "input";
173 		break;
174 	case CNFOBJ_MODULE:
175 		return "module";
176 		break;
177 	case CNFOBJ_TPL:
178 		return "template";
179 		break;
180 	case CNFOBJ_PROPERTY:
181 		return "property";
182 		break;
183 	case CNFOBJ_CONSTANT:
184 		return "constant";
185 		break;
186 	case CNFOBJ_MAINQ:
187 		return "main_queue";
188 	case CNFOBJ_LOOKUP_TABLE:
189 		return "lookup_table";
190 	case CNFOBJ_PARSER:
191 		return "parser";
192 		break;
193 	case CNFOBJ_TIMEZONE:
194 		return "timezone";
195 		break;
196 	case CNFOBJ_DYN_STATS:
197 		return "dyn_stats";
198 		break;
199 	case CNFOBJ_PERCTILE_STATS:
200 		return "perctile_stats";
201 		break;
202 	default:return "error: invalid cnfobjType";
203 	}
204 }
205 static rsRetVal
206 DecodePropFilter(uchar *pline, struct cnfstmt *stmt)
207 {
208 	rsParsObj *pPars = NULL;
209 	cstr_t *pCSCompOp = NULL;
210 	cstr_t *pCSPropName = NULL;
211 	int iOffset; 	DEFiRet;
212 	assert(pline != NULL);
213 	DBGPRINTF("Decoding property-based filter '%s'\n", pline);
214 	if((iRet = rsParsConstructFromSz(&amp;pPars, pline+1)) != RS_RET_OK) {
215 		parser_errmsg("error %d constructing parser object", iRet);
216 		FINALIZE;
217 	}
218 	iRet = parsDelimCStr(pPars, &amp;pCSPropName, ',', 1, 1, 1);
219 	if(iRet != RS_RET_OK) {
220 		parser_errmsg("error %d parsing filter property", iRet);
221 		FINALIZE;
222 	}
223 	CHKiRet(msgPropDescrFill(&amp;stmt-&gt;d.s_propfilt.prop, cstrGetSzStrNoNULL(pCSPropName),
224 		cstrLen(pCSPropName)));
225 	iRet = parsDelimCStr(pPars, &amp;pCSCompOp, ',', 1, 1, 1);
226 	if(iRet != RS_RET_OK) {
227 		parser_errmsg("error %d compare operation property - ignoring selector", iRet);
228 		FINALIZE;
229 	}
230 	if(rsCStrLen(pCSCompOp) &gt; 0) {
231 		if(*rsCStrGetBufBeg(pCSCompOp) == '!') {
232 			stmt-&gt;d.s_propfilt.isNegated = 1;
233 			iOffset = 1; 		} else {
234 			stmt-&gt;d.s_propfilt.isNegated = 0;
235 			iOffset = 0;
236 		}
237 	} else {
238 		stmt-&gt;d.s_propfilt.isNegated = 0;
239 		iOffset = 0;
240 	}
241 	if(!rsCStrOffsetSzStrCmp(pCSCompOp, iOffset, (uchar*) "contains", 8)) {
242 		stmt-&gt;d.s_propfilt.operation = FIOP_CONTAINS;
243 	} else if(!rsCStrOffsetSzStrCmp(pCSCompOp, iOffset, (uchar*) "isequal", 7)) {
244 		stmt-&gt;d.s_propfilt.operation = FIOP_ISEQUAL;
245 	} else if(!rsCStrOffsetSzStrCmp(pCSCompOp, iOffset, (uchar*) "isempty", 7)) {
246 		stmt-&gt;d.s_propfilt.operation = FIOP_ISEMPTY;
247 	} else if(!rsCStrOffsetSzStrCmp(pCSCompOp, iOffset, (uchar*) "startswith", 10)) {
248 		stmt-&gt;d.s_propfilt.operation = FIOP_STARTSWITH;
249 	} else if(!rsCStrOffsetSzStrCmp(pCSCompOp, iOffset, (unsigned char*) "regex", 5)) {
250 		stmt-&gt;d.s_propfilt.operation = FIOP_REGEX;
251 	} else if(!rsCStrOffsetSzStrCmp(pCSCompOp, iOffset, (unsigned char*) "ereregex", 8)) {
252 		stmt-&gt;d.s_propfilt.operation = FIOP_EREREGEX;
253 	} else {
254 		parser_errmsg("error: invalid compare operation '%s'",
255 		           (char*) rsCStrGetSzStrNoNULL(pCSCompOp));
256 		ABORT_FINALIZE(RS_RET_ERR);
257 	}
258 	if(stmt-&gt;d.s_propfilt.operation != FIOP_ISEMPTY) {
259 		iRet = parsQuotedCStr(pPars, &amp;stmt-&gt;d.s_propfilt.pCSCompValue);
260 		if(iRet != RS_RET_OK) {
261 			parser_errmsg("error %d compare value property", iRet);
262 			FINALIZE;
263 		}
264 	}
265 finalize_it:
266 	if(pPars != NULL)
267 		rsParsDestruct(pPars);
268 	if(pCSCompOp != NULL)
269 		rsCStrDestruct(&amp;pCSCompOp);
270 	if(pCSPropName != NULL)
271 		cstrDestruct(&amp;pCSPropName);
272 	RETiRet;
273 }
274 static void
275 prifiltInvert(struct funcData_prifilt *__restrict__ const prifilt)
276 {
277 	int i;
278 	for(i = 0 ; i &lt; LOG_NFACILITIES+1 ; ++i) {
279 		prifilt-&gt;pmask[i] = ~prifilt-&gt;pmask[i];
280 	}
281 }
282 static void
283 prifiltSetSeverity(struct funcData_prifilt *prifilt, int sev, int mode)
284 {
285 	static int lessthanmasks[] = { 0x00, 0x01, 0x03, 0x07, 0x0f, 0x1f, 0x3f, 0x7f, 0xff };
286 	int i;
287 	for(i = 0 ; i &lt; LOG_NFACILITIES+1 ; ++i) {
288 		if(mode == CMP_EQ || mode == CMP_NE)
289 			prifilt-&gt;pmask[i] = 1 &lt;&lt; sev;
290 		else if(mode == CMP_LT)
291 			prifilt-&gt;pmask[i] = lessthanmasks[sev];
292 		else if(mode == CMP_LE)
293 			prifilt-&gt;pmask[i] = lessthanmasks[sev+1];
294 		else if(mode == CMP_GT)
295 			prifilt-&gt;pmask[i] = ~lessthanmasks[sev+1];
296 		else if(mode == CMP_GE)
297 			prifilt-&gt;pmask[i] = ~lessthanmasks[sev];
298 		else
299 			DBGPRINTF("prifiltSetSeverity: program error, invalid mode %s\n",
300 				  tokenToString(mode));
301 	}
302 	if(mode == CMP_NE)
303 		prifiltInvert(prifilt);
304 }
305 static void
306 prifiltSetFacility(struct funcData_prifilt *__restrict__ const prifilt, const int fac, const int mode)
307 {
308 	int i;
309 	memset(prifilt-&gt;pmask, 0, sizeof(prifilt-&gt;pmask));
310 	switch(mode) {
311 	case CMP_EQ:
312 		prifilt-&gt;pmask[fac] = TABLE_ALLPRI;
313 		break;
314 	case CMP_NE:
315 		prifilt-&gt;pmask[fac] = TABLE_ALLPRI;
316 		prifiltInvert(prifilt);
317 		break;
318 	case CMP_LT:
319 		for(i = 0 ; i &lt; fac ; ++i)
320 			prifilt-&gt;pmask[i] = TABLE_ALLPRI;
321 		break;
322 	case CMP_LE:
323 		for(i = 0 ; i &lt; fac+1 ; ++i)
324 			prifilt-&gt;pmask[i] = TABLE_ALLPRI;
325 		break;
326 	case CMP_GE:
327 		for(i = fac ; i &lt; LOG_NFACILITIES+1 ; ++i)
328 			prifilt-&gt;pmask[i] = TABLE_ALLPRI;
329 		break;
330 	case CMP_GT:
331 		for(i = fac+1 ; i &lt; LOG_NFACILITIES+1 ; ++i)
332 			prifilt-&gt;pmask[i] = TABLE_ALLPRI;
333 		break;
334 	default:break;
335 	}
336 }
337 static void
338 prifiltCombine(struct funcData_prifilt *__restrict__ const prifilt,
339 	       struct funcData_prifilt *__restrict__ const prifilt2,
340 	       const int mode)
341 {
342 	int i;
343 	for(i = 0 ; i &lt; LOG_NFACILITIES+1 ; ++i) {
344 		if(mode == AND)
345 			prifilt-&gt;pmask[i] = prifilt-&gt;pmask[i] &amp; prifilt2-&gt;pmask[i];
346 		else
347 			prifilt-&gt;pmask[i] = prifilt-&gt;pmask[i] | prifilt2-&gt;pmask[i];
348 	}
349 }
350 void
351 readConfFile(FILE * const fp, es_str_t **str)
352 {
353 	char ln[10240];
354 	char buf[512];
355 	int lenBuf;
356 	int bWriteLineno = 0;
357 	int len, i;
358 	int start;		int bContLine = 0;
359 	int lineno = 0;
360 	*str = es_newStr(4096);
361 	while(fgets(ln, sizeof(ln), fp) != NULL) {
362 		++lineno;
363 		if(bWriteLineno) {
364 			bWriteLineno = 0;
365 			lenBuf = sprintf(buf, "PreprocFileLineNumber(%d)\n", lineno);
366 			es_addBuf(str, buf, lenBuf);
367 		}
368 		len = strlen(ln);
369 		if(bContLine) {
370 			for(start = 0 ; start &lt; len &amp;&amp; isspace(ln[start]) ; ++start)
371 		} else {
372 			start = 0;
373 		}
374 		for(i = len - 1 ; i &gt;= start &amp;&amp; isspace(ln[i]) ; --i)
375 		if(i &gt;= 0) {
376 			if(ln[i] == '\\') {
377 				--i;
378 				bContLine = 1;
379 			} else {
380 				if(bContLine) 					bWriteLineno = 1;
381 				bContLine = 0;
382 			}
383 			es_addBuf(str, ln+start, i+1 - start);
384 		}
385 		if(!bContLine)
386 			es_addChar(str, '\n');
387 	}
388 	es_addChar(str, '\0');
389 	es_addChar(str, '\0');
390 }
391 static int
392 qs_arrcmp(const void *s1, const void *s2)
393 {
394 	return es_strcmp(*((es_str_t**)s1), *((es_str_t**)s2));
395 }
396 struct objlst*
397 objlstNew(struct cnfobj *o)
398 {
399 	struct objlst *lst;
400 	if((lst = malloc(sizeof(struct objlst))) != NULL) {
401 		lst-&gt;next = NULL;
402 		lst-&gt;obj = o;
403 	}
404 cnfobjPrint(o);
405 	return lst;
406 }
407 struct objlst*
408 objlstAdd(struct objlst *root, struct cnfobj *o)
409 {
410 	struct objlst *l;
411 	struct objlst *newl;
412 	newl = objlstNew(o);
413 	if(root == 0) {
414 		root = newl;
415 	} else { 		for(l = root ; l-&gt;next != NULL ; l = l-&gt;next)
416 			;
417 		l-&gt;next = newl;
418 	}
419 	return root;
420 }
421 struct cnfstmt*
422 scriptAddStmt(struct cnfstmt *root, struct cnfstmt *s)
423 {
424 	struct cnfstmt *l;
425 	if(root == NULL) {
426 		root = s;
427 	} else { 		for(l = root ; l-&gt;next != NULL ; l = l-&gt;next)
428 			;
429 		l-&gt;next = s;
430 	}
431 	return root;
432 }
433 void
434 objlstDestruct(struct objlst *lst)
435 {
436 	struct objlst *toDel;
437 	while(lst != NULL) {
438 		toDel = lst;
439 		lst = lst-&gt;next;
440 		cnfobjDestruct(toDel-&gt;obj);
441 		free(toDel);
442 	}
443 }
444 void
445 objlstPrint(struct objlst *lst)
446 {
447 	dbgprintf("objlst %p:\n", lst);
448 	while(lst != NULL) {
449 		cnfobjPrint(lst-&gt;obj);
450 		lst = lst-&gt;next;
451 	}
452 }
453 struct nvlst* ATTR_NONNULL(1)
454 nvlstNewStr(es_str_t *const value)
455 {
456 	struct nvlst *lst;
457 	if((lst = malloc(sizeof(struct nvlst))) != NULL) {
458 		lst-&gt;next = NULL;
459 		lst-&gt;val.datatype = 'S';
460 		lst-&gt;val.d.estr = value;
461 		lst-&gt;bUsed = 0;
462 	}
463 	return lst;
464 }
465 struct nvlst* ATTR_NONNULL(1)
466 nvlstNewStrBackticks(es_str_t *const value)
467 {
468 	es_str_t *val = NULL;
469 	const char *realval;
470 	char *const param = es_str2cstr(value, NULL);
471 	if(param == NULL)
472 		goto done;
473 	if(strncmp(param, "echo $", sizeof("echo $")-1) != 0) {
474 		parser_errmsg("invalid backtick parameter `%s` currently "
475 			"only `echo $&lt;var&gt;` is supported - replaced by "
476 			"empty strong (\"\")", param);
477 		realval = NULL;
478 	} else {
479 		size_t i;
480 		const size_t len = strlen(param);
481 		for(i = len - 1 ; isspace(param[i]) ; --i) {
482 			; 		}
483 		if(i &gt; 6 &amp;&amp; i &lt; len - 1) {
484 			param[i+1] = '\0';
485 		}
486 		realval = getenv(param+6);
487 	}
488 	free((void*)param);
489 	if(realval == NULL) {
490 		realval = "";
491 	}
492 	val = es_newStrFromCStr(realval, strlen(realval));
493 	es_deleteStr(value);
494 done:
495 	return (val == NULL) ? NULL : nvlstNewStr(val);
496 }
497 struct nvlst*
498 nvlstNewArray(struct cnfarray *ar)
499 {
500 	struct nvlst *lst;
501 	if((lst = malloc(sizeof(struct nvlst))) != NULL) {
502 		lst-&gt;next = NULL;
503 		lst-&gt;val.datatype = 'A';
504 		lst-&gt;val.d.ar = ar;
505 		lst-&gt;bUsed = 0;
506 	}
507 	return lst;
508 }
509 struct nvlst*
510 nvlstSetName(struct nvlst *lst, es_str_t *name)
511 {
512 	lst-&gt;name = name;
513 	return lst;
514 }
515 void
516 nvlstDestruct(struct nvlst *lst)
517 {
518 	struct nvlst *toDel;
519 	while(lst != NULL) {
520 		toDel = lst;
521 		lst = lst-&gt;next;
522 		es_deleteStr(toDel-&gt;name);
523 		varDelete(&amp;toDel-&gt;val);
524 		free(toDel);
525 	}
526 }
527 void
528 nvlstPrint(struct nvlst *lst)
529 {
530 	char *name, *value;
531 	dbgprintf("nvlst %p:\n", lst);
532 	while(lst != NULL) {
533 		name = es_str2cstr(lst-&gt;name, NULL);
534 		switch(lst-&gt;val.datatype) {
535 		case 'A':
536 			dbgprintf("\tname: '%s':\n", name);
537 			cnfarrayPrint(lst-&gt;val.d.ar, 5);
538 			break;
539 		case 'S':
540 			value = es_str2cstr(lst-&gt;val.d.estr, NULL);
541 			dbgprintf("\tname: '%s', value '%s'\n", name, value);
542 			free(value);
543 			break;
544 		default:dbgprintf("nvlstPrint: unknown type '%s'\n",
545 				tokenToString(lst-&gt;val.datatype));
546 			break;
547 		}
548 		free(name);
549 		lst = lst-&gt;next;
550 	}
551 }
552 struct nvlst*
553 nvlstFindName(struct nvlst *lst, es_str_t *name)
554 {
555 	while(lst != NULL &amp;&amp; es_strcmp(lst-&gt;name, name))
556 		lst = lst-&gt;next;
557 	return lst;
558 }
559 static struct nvlst*
560 nvlstFindNameCStr(struct nvlst *lst, const char *const __restrict__ name)
561 {
562 	es_size_t lenName = strlen(name);
563 	while(lst != NULL &amp;&amp; es_strcasebufcmp(lst-&gt;name, (uchar*)name, lenName))
564 		lst = lst-&gt;next;
565 	return lst;
566 }
567 int nvlstChkDisabled(struct nvlst *lst)
568 {
569 	struct nvlst *valnode;
570 	if((valnode = nvlstFindNameCStr(lst, "config.enabled")) != NULL) {
571 		valnode-&gt;bUsed = 1;
572 		if(es_strbufcmp(valnode-&gt;val.d.estr, (unsigned char*) "on", 2)) {
573 			return 1;
574 		}
575 	}
576 	return 0;
577 }
578 static void
579 nvlstChkDupes(struct nvlst *lst)
580 {
581 	char *cstr;
582 	while(lst != NULL) {
583 		if(nvlstFindName(lst-&gt;next, lst-&gt;name) != NULL) {
584 			cstr = es_str2cstr(lst-&gt;name, NULL);
585 			parser_errmsg("duplicate parameter '%s' -- "
586 			  "interpretation is ambiguous, one value "
587 			  "will be randomly selected. Fix this problem.",
588 			  cstr);
589 			free(cstr);
590 		}
591 		lst = lst-&gt;next;
592 	}
593 }
594 void
595 nvlstChkUnused(struct nvlst *lst)
596 {
597 	char *cstr;
598 	while(lst != NULL) {
599 		if(!lst-&gt;bUsed) {
600 			cstr = es_str2cstr(lst-&gt;name, NULL);
601 			parser_errmsg("parameter '%s' not known -- "
602 			  "typo in config file?",
603 			  cstr);
604 			free(cstr);
605 		}
606 		lst = lst-&gt;next;
607 	}
608 }
609 static int
610 doGetSize(struct nvlst *valnode, struct cnfparamdescr *param,
611 	  struct cnfparamvals *val)
612 {
613 	unsigned char *c;
614 	es_size_t i;
615 	long long n;
616 	int r;
617 	c = es_getBufAddr(valnode-&gt;val.d.estr);
618 	n = 0;
619 	i = 0;
620 	while(i &lt; es_strlen(valnode-&gt;val.d.estr) &amp;&amp; isdigit(*c)) {
621 		n = 10 * n + *c - '0';
622 		++i;
623 		++c;
624 	}
625 	if(i &lt; es_strlen(valnode-&gt;val.d.estr)) {
626 		++i;
627 		switch(*c) {
628 		case 'k': n *= 1024; break;
629 		case 'm': n *= 1024 * 1024; break;
630 		case 'g': n *= 1024 * 1024 * 1024; break;
631 		case 't': n *= (int64) 1024 * 1024 * 1024 * 1024; break; 		case 'p': n *= (int64) 1024 * 1024 * 1024 * 1024 * 1024; break; 		case 'e': n *= (int64) 1024 * 1024 * 1024 * 1024 * 1024 * 1024; break; 		case 'K': n *= 1000; break;
632 	        case 'M': n *= 1000000; break;
633 		case 'G': n *= 1000000000; break;
634 		case 'T': n *= (int64) 1000       * 1000000000; break; 		case 'P': n *= (int64) 1000000    * 1000000000; break; 		case 'E': n *= (int64) 1000000000 * 1000000000; break; 		default: --i; break; 		}
635 	}
636 	if(i == es_strlen(valnode-&gt;val.d.estr)) {
637 		val-&gt;val.datatype = 'N';
638 		val-&gt;val.d.n = n;
639 		r = 1;
640 	} else {
641 		parser_errmsg("parameter '%s' does not contain a valid size",
642 			      param-&gt;name);
643 		r = 0;
644 	}
645 	return r;
646 }
647 static int
648 doGetBinary(struct nvlst *valnode, struct cnfparamdescr *param,
649 	  struct cnfparamvals *val)
650 {
651 	int r = 1;
652 	val-&gt;val.datatype = 'N';
653 	if(!es_strbufcmp(valnode-&gt;val.d.estr, (unsigned char*) "on", 2)) {
654 		val-&gt;val.d.n = 1;
655 	} else if(!es_strbufcmp(valnode-&gt;val.d.estr, (unsigned char*) "off", 3)) {
656 		val-&gt;val.d.n = 0;
657 	} else {
658 		parser_errmsg("parameter '%s' must be \"on\" or \"off\" but "
659 		  "is neither. Results unpredictable.", param-&gt;name);
660 		val-&gt;val.d.n = 0;
661 		r = 0;
662 	}
663 	return r;
664 }
665 static int
666 doGetQueueType(struct nvlst *valnode, struct cnfparamdescr *param,
667 	  struct cnfparamvals *val)
668 {
669 	char *cstr;
670 	int r = 1;
671 	if(!es_strcasebufcmp(valnode-&gt;val.d.estr, (uchar*)"fixedarray", 10)) {
672 		val-&gt;val.d.n = QUEUETYPE_FIXED_ARRAY;
673 	} else if(!es_strcasebufcmp(valnode-&gt;val.d.estr, (uchar*)"linkedlist", 10)) {
674 		val-&gt;val.d.n = QUEUETYPE_LINKEDLIST;
675 	} else if(!es_strcasebufcmp(valnode-&gt;val.d.estr, (uchar*)"disk", 4)) {
676 		val-&gt;val.d.n = QUEUETYPE_DISK;
677 	} else if(!es_strcasebufcmp(valnode-&gt;val.d.estr, (uchar*)"direct", 6)) {
678 		val-&gt;val.d.n = QUEUETYPE_DIRECT;
679 	} else {
680 		cstr = es_str2cstr(valnode-&gt;val.d.estr, NULL);
681 		parser_errmsg("param '%s': unknown queue type: '%s'",
682 			      param-&gt;name, cstr);
683 		free(cstr);
684 		r = 0;
685 	}
686 	val-&gt;val.datatype = 'N';
687 	return r;
688 }
689 static int
690 doGetFileCreateMode(struct nvlst *valnode, struct cnfparamdescr *param,
691 	  struct cnfparamvals *val)
692 {
693 	int fmtOK = 0;
694 	char *cstr;
695 	uchar *c;
696 	const int len_val = es_strlen(valnode-&gt;val.d.estr);
697 	if(len_val &gt;= 4) {
698 		c = es_getBufAddr(valnode-&gt;val.d.estr);
699 		if(    (c[0] == '0')
700 		    &amp;&amp; (c[1] &gt;= '0' &amp;&amp; c[1] &lt;= '7')
701 		    &amp;&amp; (c[2] &gt;= '0' &amp;&amp; c[2] &lt;= '7')
702 		    &amp;&amp; (c[3] &gt;= '0' &amp;&amp; c[3] &lt;= '7')  )  {
703 			if(len_val == 5) {
704 				if(c[4] &gt;= '0' &amp;&amp; c[4] &lt;= '7') {
705 					fmtOK = 1;
706 				}
707 			} else {
708 				fmtOK = 1;
709 			}
710 		}
711 	}
712 	if(fmtOK) {
713 		val-&gt;val.datatype = 'N';
714 		val-&gt;val.d.n = (c[1]-'0') * 64 + (c[2]-'0') * 8 + (c[3]-'0');
715 		if(len_val == 5) {
716 			val-&gt;val.d.n  = val-&gt;val.d.n * 8 + (c[4]-'0');
717 		}
718 	} else {
719 		cstr = es_str2cstr(valnode-&gt;val.d.estr, NULL);
720 		parser_errmsg("file modes need to be specified as "
721 		  "4- or 5-digit octal numbers starting with '0' -"
722 		  "parameter '%s=\"%s\"' is not a file mode",
723 		param-&gt;name, cstr);
724 		free(cstr);
725 	}
726 	return fmtOK;
727 }
728 static int
729 doGetGID(struct nvlst *valnode, struct cnfparamdescr *param,
730 	  struct cnfparamvals *val)
731 {
732 	char *cstr;
733 	int r;
734 	struct group *resultBuf = NULL;
735 	struct group wrkBuf;
736 	char *stringBuf = NULL;
737 	size_t bufSize = 1024;
738 	int e;
739 	cstr = es_str2cstr(valnode-&gt;val.d.estr, NULL);
740 	do {
741 		char *p;
742 		bufSize *= 2;
743 		p = realloc(stringBuf, bufSize);
744 		if(!p) {
745 			e = ENOMEM;
746 			break;
747 		}
748 		stringBuf = p;
749 		e = getgrnam_r(cstr, &amp;wrkBuf, stringBuf, bufSize, &amp;resultBuf);
750 	} while(!resultBuf &amp;&amp; (e == ERANGE));
751 	if(resultBuf == NULL) {
752 		if(e != 0) {
753 			if(loadConf-&gt;globals.abortOnIDResolutionFail) {
754 				fprintf(stderr, "parameter '%s': error to "
755 				"obtaining group id for '%s'", param-&gt;name, cstr);
756 				exit(1); 			} else {
757 				LogError(e, RS_RET_ERR, "parameter '%s': error to "
758 					"obtaining group id for '%s'", param-&gt;name, cstr);
759 			}
760 		}
761 		parser_errmsg("parameter '%s': ID for group %s could not "
762 		  "be found", param-&gt;name, cstr);
763 		r = 0;
764 	} else {
765 		val-&gt;val.datatype = 'N';
766 		val-&gt;val.d.n = resultBuf-&gt;gr_gid;
767 		DBGPRINTF("param '%s': uid %d obtained for group '%s'\n",
768 		   param-&gt;name, (int) resultBuf-&gt;gr_gid, cstr);
769 		r = 1;
770 	}
771 	free(stringBuf);
772 	free(cstr);
773 	return r;
774 }
775 static int
776 doGetUID(struct nvlst *valnode, struct cnfparamdescr *param,
777 	  struct cnfparamvals *val)
778 {
779 	char *cstr;
780 	int r;
781 	struct passwd *resultBuf;
782 	struct passwd wrkBuf;
783 	char stringBuf[2048]; 	char errStr[1024];
784 	cstr = es_str2cstr(valnode-&gt;val.d.estr, NULL);
785 	const int err_no = getpwnam_r(cstr, &amp;wrkBuf, stringBuf, sizeof(stringBuf), &amp;resultBuf);
786 	if(resultBuf == NULL) {
787 		rs_strerror_r((err_no == 0) ? ENOENT : errno, errStr, sizeof(errStr));
788 		if(loadConf-&gt;globals.abortOnIDResolutionFail) {
789 			fprintf(stderr, "parameter '%s': ID for user '%s' could not "
790 			  "be found: %s", param-&gt;name, cstr, errStr);
791 			exit(1); 		} else {
792 			LogError(err_no, RS_RET_ERR, "parameter '%s': ID for user '%s' could not "
793 			  "be found: %s", param-&gt;name, cstr, errStr);
794 			parser_errmsg("parameter '%s': ID for user '%s' could not "
795 			  "be found: %s", param-&gt;name, cstr, errStr);
796 		}
797 		r = 0;
798 	} else {
799 		val-&gt;val.datatype = 'N';
800 		val-&gt;val.d.n = resultBuf-&gt;pw_uid;
801 		DBGPRINTF("param '%s': uid %d obtained for user '%s'\n",
802 		   param-&gt;name, (int) resultBuf-&gt;pw_uid, cstr);
803 		r = 1;
804 	}
805 	free(cstr);
806 	return r;
807 }
808 static int
809 doGetInt(struct nvlst *valnode, struct cnfparamdescr *param,
810 	  struct cnfparamvals *val)
811 {
812 	long long n;
813 	int bSuccess;
814 	n = es_str2num(valnode-&gt;val.d.estr, &amp;bSuccess);
815 	if(!bSuccess) {
816 		parser_errmsg("parameter '%s' is not a proper number",
817 		  param-&gt;name);
818 	}
819 	val-&gt;val.datatype = 'N';
820 	val-&gt;val.d.n = n;
821 	return bSuccess;
822 }
823 static int
824 doGetNonNegInt(struct nvlst *valnode, struct cnfparamdescr *param,
825 	  struct cnfparamvals *val)
826 {
827 	int bSuccess;
828 	if((bSuccess = doGetInt(valnode, param, val))) {
829 		if(val-&gt;val.d.n &lt; 0) {
830 			parser_errmsg("parameter '%s' cannot be less than zero (was %lld)",
831 			  param-&gt;name, val-&gt;val.d.n);
832 			bSuccess = 0;
833 		}
834 	}
835 	return bSuccess;
836 }
837 static int
838 doGetPositiveInt(struct nvlst *valnode, struct cnfparamdescr *param,
839 	  struct cnfparamvals *val)
840 {
841 	int bSuccess;
842 	if((bSuccess = doGetInt(valnode, param, val))) {
843 		if(val-&gt;val.d.n &lt; 1) {
844 			parser_errmsg("parameter '%s' cannot be less than one (was %lld)",
845 			  param-&gt;name, val-&gt;val.d.n);
846 			bSuccess = 0;
847 		}
848 	}
849 	return bSuccess;
850 }
851 static int
852 doGetWord(struct nvlst *valnode, struct cnfparamdescr *param,
853 	  struct cnfparamvals *val)
854 {
855 	es_size_t i;
856 	int r = 1;
857 	unsigned char *c;
858 	val-&gt;val.datatype = 'S';
859 	val-&gt;val.d.estr = es_newStr(32);
860 	c = es_getBufAddr(valnode-&gt;val.d.estr);
861 	for(i = 0 ; i &lt; es_strlen(valnode-&gt;val.d.estr) &amp;&amp; !isspace(c[i]) ; ++i) {
862 		es_addChar(&amp;val-&gt;val.d.estr, c[i]);
863 	}
864 	if(i != es_strlen(valnode-&gt;val.d.estr)) {
865 		parser_errmsg("parameter '%s' contains whitespace, which is not "
866 		  "permitted",
867 		  param-&gt;name);
868 		r = 0;
869 	}
870 	return r;
871 }
872 static int
873 doGetArray(struct nvlst *valnode, struct cnfparamdescr *param,
874 	  struct cnfparamvals *val)
875 {
876 	int r = 1;
877 	switch(valnode-&gt;val.datatype) {
878 	case 'S':
879 		val-&gt;val.datatype = 'A';
880 		val-&gt;val.d.ar = cnfarrayNew(es_strdup(valnode-&gt;val.d.estr));
881 		break;
882 	case 'A':
883 		val-&gt;val.datatype = 'A';
884 		val-&gt;val.d.ar = cnfarrayDup(valnode-&gt;val.d.ar);
885 		break;
886 	default:parser_errmsg("parameter '%s' must be an array, but is a "
887 			"different datatype", param-&gt;name);
888 		r = 0;
889 		break;
890 	}
891 	return r;
892 }
893 static int
894 doGetChar(struct nvlst *valnode, struct cnfparamdescr *param,
895 	  struct cnfparamvals *val)
896 {
897 	int r = 1;
898 	if(es_strlen(valnode-&gt;val.d.estr) != 1) {
899 		parser_errmsg("parameter '%s' must contain exactly one character "
900 		  "but contains %d - cannot be processed",
901 		  param-&gt;name, es_strlen(valnode-&gt;val.d.estr));
902 		r = 0;
903 	}
904 	val-&gt;val.datatype = 'S';
905 	val-&gt;val.d.estr = es_strdup(valnode-&gt;val.d.estr);
906 	return r;
907 }
908 static int
909 nvlstGetParam(struct nvlst *valnode, struct cnfparamdescr *param,
910 	       struct cnfparamvals *val)
911 {
912 	uchar *cstr;
913 	int r;
914 	DBGPRINTF("nvlstGetParam: name '%s', type %d, valnode-&gt;bUsed %d\n",
915 		  param-&gt;name, (int) param-&gt;type, valnode-&gt;bUsed);
916 	if(valnode-&gt;val.datatype != 'S' &amp;&amp; param-&gt;type != eCmdHdlrArray) {
917 		parser_errmsg("parameter '%s' is not a string, which is not "
918 		  "permitted",
919 		  param-&gt;name);
920 		r = 0;
921 		goto done;
922 	}
923 	valnode-&gt;bUsed = 1;
924 	val-&gt;bUsed = 1;
925 	switch(param-&gt;type) {
926 	case eCmdHdlrQueueType:
927 		r = doGetQueueType(valnode, param, val);
928 		break;
929 	case eCmdHdlrUID:
930 		r = doGetUID(valnode, param, val);
931 		break;
932 	case eCmdHdlrGID:
933 		r = doGetGID(valnode, param, val);
934 		break;
935 	case eCmdHdlrBinary:
936 		r = doGetBinary(valnode, param, val);
937 		break;
938 	case eCmdHdlrFileCreateMode:
939 		r = doGetFileCreateMode(valnode, param, val);
940 		break;
941 	case eCmdHdlrInt:
942 		r = doGetInt(valnode, param, val);
943 		break;
944 	case eCmdHdlrNonNegInt:
945 		r = doGetNonNegInt(valnode, param, val);
946 		break;
947 	case eCmdHdlrPositiveInt:
948 		r = doGetPositiveInt(valnode, param, val);
949 		break;
950 	case eCmdHdlrSize:
951 		r = doGetSize(valnode, param, val);
952 		break;
953 	case eCmdHdlrGetChar:
954 		r = doGetChar(valnode, param, val);
955 		break;
956 	case eCmdHdlrFacility:
957 		cstr = (uchar*) es_str2cstr(valnode-&gt;val.d.estr, NULL);
958 		val-&gt;val.datatype = 'N';
959 		val-&gt;val.d.n = decodeSyslogName(cstr, syslogFacNames);
960 		free(cstr);
961 		r = 1;
962 		break;
963 	case eCmdHdlrSeverity:
964 		cstr = (uchar*) es_str2cstr(valnode-&gt;val.d.estr, NULL);
965 		val-&gt;val.datatype = 'N';
966 		val-&gt;val.d.n = decodeSyslogName(cstr, syslogPriNames);
967 		free(cstr);
968 		r = 1;
969 		break;
970 	case eCmdHdlrGetWord:
971 		r = doGetWord(valnode, param, val);
972 		break;
973 	case eCmdHdlrString:
974 		val-&gt;val.datatype = 'S';
975 		val-&gt;val.d.estr = es_strdup(valnode-&gt;val.d.estr);
976 		r = 1;
977 		break;
978 	case eCmdHdlrArray:
979 		r = doGetArray(valnode, param, val);
980 		break;
981 	case eCmdHdlrGoneAway:
982 		parser_errmsg("parameter '%s' is no longer supported",
983 			      param-&gt;name);
984 		r = 1; 		break;
985 	default:
986 		DBGPRINTF("error: invalid param type\n");
987 		r = 0;
988 		break;
989 	}
990 done:	return r;
991 }
992 struct cnfparamvals* ATTR_NONNULL(2)
993 nvlstGetParams(struct nvlst *lst, struct cnfparamblk *params,
994 	       struct cnfparamvals *vals)
995 {
996 #ifndef __clang_analyzer__ 	int i;
997 	int bValsWasNULL;
998 	int bInError = 0;
999 	struct nvlst *valnode;
1000 	struct cnfparamdescr *param;
1001 	if(params-&gt;version != CNFPARAMBLK_VERSION) {
1002 		DBGPRINTF("nvlstGetParams: invalid param block version "
1003 			  "%d, expected %d\n",
1004 			  params-&gt;version, CNFPARAMBLK_VERSION);
1005 		return NULL;
1006 	}
1007 	if(vals == NULL) {
1008 		bValsWasNULL = 1;
1009 		if((vals = calloc(params-&gt;nParams,
1010 				  sizeof(struct cnfparamvals))) == NULL)
1011 			return NULL;
1012 	} else {
1013 		bValsWasNULL = 0;
1014 	}
1015 	for(i = 0 ; i &lt; params-&gt;nParams ; ++i) {
1016 		param = params-&gt;descr + i;
1017 		if((valnode = nvlstFindNameCStr(lst, param-&gt;name)) == NULL) {
1018 			if(param-&gt;flags &amp; CNFPARAM_REQUIRED) {
1019 				parser_errmsg("parameter '%s' required but not specified - "
1020 				  "fix config", param-&gt;name);
1021 				bInError = 1;
1022 			}
1023 			continue;
1024 		}
1025 		if(param-&gt;flags &amp; CNFPARAM_DEPRECATED) {
1026 			parser_errmsg("parameter '%s' deprecated but accepted, consider "
1027 			  "removing or replacing it", param-&gt;name);
1028 		}
1029 		if(vals[i].bUsed) {
1030 			parser_errmsg("parameter '%s' specified more than once - "
1031 			  "one instance is ignored. Fix config", param-&gt;name);
1032 			continue;
1033 		}
1034 		if(!nvlstGetParam(valnode, param, vals + i)) {
1035 			bInError = 1;
1036 		}
1037 	}
1038 	if(bInError) {
1039 		if(bValsWasNULL)
1040 			cnfparamvalsDestruct(vals, params);
1041 		vals = NULL;
1042 	}
1043 	return vals;
1044 #else
1045 	return NULL;
1046 #endif
1047 }
1048 int
1049 cnfparamvalsIsSet(struct cnfparamblk *params, struct cnfparamvals *vals)
1050 {
1051 	int i;
1052 	if(vals == NULL)
1053 		return 0;
1054 	if(params-&gt;version != CNFPARAMBLK_VERSION) {
1055 		DBGPRINTF("nvlstGetParams: invalid param block version "
1056 			  "%d, expected %d\n",
1057 			  params-&gt;version, CNFPARAMBLK_VERSION);
1058 		return 0;
1059 	}
1060 	for(i = 0 ; i &lt; params-&gt;nParams ; ++i) {
1061 		if(vals[i].bUsed)
1062 			return 1;
1063 	}
1064 	return 0;
1065 }
1066 void
1067 cnfparamsPrint(const struct cnfparamblk *params, const struct cnfparamvals *vals)
1068 {
1069 	int i;
1070 	char *cstr;
1071 	if(!Debug)
1072 		return;
1073 	for(i = 0 ; i &lt; params-&gt;nParams ; ++i) {
1074 		dbgprintf("%s: ", params-&gt;descr[i].name);
1075 		if(vals[i].bUsed) {
1076 			switch(vals[i].val.datatype) {
1077 			case 'S':
1078 				cstr = es_str2cstr(vals[i].val.d.estr, NULL);
1079 				dbgprintf(" '%s'", cstr);
1080 				free(cstr);
1081 				break;
1082 			case 'A':
1083 				cnfarrayPrint(vals[i].val.d.ar, 0);
1084 				break;
1085 			case 'N':
1086 				dbgprintf("%lld", vals[i].val.d.n);
1087 				break;
1088 			default:
1089 				dbgprintf("(unsupported datatype %c)",
1090 					  vals[i].val.datatype);
1091 			}
1092 		} else {
1093 			dbgprintf("(unset)");
1094 		}
1095 		dbgprintf("\n");
1096 	}
1097 }
1098 struct cnfobj*
1099 cnfobjNew(enum cnfobjType objType, struct nvlst *lst)
1100 {
1101 	struct cnfobj *o;
1102 	if((o = malloc(sizeof(struct cnfobj))) != NULL) {
1103 		nvlstChkDupes(lst);
1104 		o-&gt;objType = objType;
1105 		o-&gt;nvlst = lst;
1106 		o-&gt;subobjs = NULL;
1107 		o-&gt;script = NULL;
1108 	}
1109 	return o;
1110 }
1111 void
1112 cnfobjDestruct(struct cnfobj *o)
1113 {
1114 	if(o != NULL) {
1115 		nvlstDestruct(o-&gt;nvlst);
1116 		objlstDestruct(o-&gt;subobjs);
1117 		free(o);
1118 	}
1119 }
1120 void
1121 cnfobjPrint(struct cnfobj *o)
1122 {
1123 	dbgprintf("obj: '%s'\n", cnfobjType2str(o-&gt;objType));
1124 	nvlstPrint(o-&gt;nvlst);
1125 }
1126 struct cnfexpr*
1127 cnfexprNew(unsigned nodetype, struct cnfexpr *l, struct cnfexpr *r)
1128 {
1129 	struct cnfexpr *expr;
1130 	if(nodetype == 'M' &amp;&amp; r-&gt;nodetype == 'N') {
1131 		((struct cnfnumval*)r)-&gt;val *= -1;
1132 		expr = r;
1133 		goto done;
1134 	}
1135 	if((expr = malloc(sizeof(struct cnfexpr))) != NULL) {
1136 		expr-&gt;nodetype = nodetype;
1137 		expr-&gt;l = l;
1138 		expr-&gt;r = r;
1139 	}
1140 done:
1141 	return expr;
1142 }
1143 static int64_t
1144 str2num(es_str_t *s, int *bSuccess)
1145 {
1146 	size_t i;
1147 	int neg;
1148 	int64_t num = 0;
1149 	const uchar *const c = es_getBufAddr(s);
1150 	if(s-&gt;lenStr == 0) {
1151 		DBGPRINTF("rainerscript: str2num: strlen == 0; invalid input (no string)\n");
1152 		if(bSuccess != NULL) {
1153 			*bSuccess = 1;
1154 		}
1155 		goto done;
1156 	}
1157 	if(c[0] == '-') {
1158 		neg = -1;
1159 		i = 1;
1160 	} else {
1161 		neg = 1;
1162 		i = 0;
1163 	}
1164 	while(i &lt; s-&gt;lenStr &amp;&amp; isdigit(c[i])) {
1165 		num = num * 10 + c[i] - '0';
1166 		++i;
1167 	}
1168 	num *= neg;
1169 	if(bSuccess != NULL)
1170 		*bSuccess = (i == s-&gt;lenStr) ? 1 : 0;
1171 done:
1172 	return num;
1173 }
1174 long long
1175 var2Number(struct svar *r, int *bSuccess)
1176 {
1177 	long long n = 0;
1178 	if(r-&gt;datatype == 'S') {
1179 		n = str2num(r-&gt;d.estr, bSuccess);
1180 	} else {
1181 		if(r-&gt;datatype == 'J') {
1182 			n = (r-&gt;d.json == NULL) ? 0 : json_object_get_int64(r-&gt;d.json);
1183 		} else {
1184 			n = r-&gt;d.n;
1185 		}
1186 		if(bSuccess != NULL)
1187 			*bSuccess = 1;
1188 	}
1189 	return n;
1190 }
1191 static es_str_t *
1192 var2String(struct svar *__restrict__ const r, int *__restrict__ const bMustFree)
1193 {
1194 	es_str_t *estr;
1195 	const char *cstr;
1196 	rs_size_t lenstr;
1197 	if(r-&gt;datatype == 'N') {
1198 		*bMustFree = 1;
1199 		estr = es_newStrFromNumber(r-&gt;d.n);
1200 	} else if(r-&gt;datatype == 'J') {
1201 		*bMustFree = 1;
1202 		if(r-&gt;d.json == NULL) {
1203 			cstr = "",
1204 			lenstr = 0;
1205 		} else {
1206 			cstr = (char*)json_object_get_string(r-&gt;d.json);
1207 			lenstr = strlen(cstr);
1208 		}
1209 		estr = es_newStrFromCStr(cstr, lenstr);
1210 	} else {
1211 		*bMustFree = 0;
1212 		estr = r-&gt;d.estr;
1213 	}
1214 	return estr;
1215 }
1216 uchar*
1217 var2CString(struct svar *__restrict__ const r, int *__restrict__ const bMustFree)
1218 {
1219 	uchar *cstr;
1220 	es_str_t *estr;
1221 	estr = var2String(r, bMustFree);
1222 	cstr = (uchar*) es_str2cstr(estr, NULL);
1223 	if(*bMustFree)
1224 		es_deleteStr(estr);
1225 	*bMustFree = 1;
1226 	return cstr;
1227 }
1228 int SKIP_NOTHING = 0x0;
1229 int SKIP_STRING = 0x1;
1230 static void
1231 varFreeMembersSelectively(const struct svar *r, const int skipMask)
1232 {
1233 	if(r-&gt;datatype == 'J') {
1234 		json_object_put(r-&gt;d.json);
1235 	} else if( !(skipMask &amp; SKIP_STRING) &amp;&amp; (r-&gt;datatype == 'S')) {
1236 		es_deleteStr(r-&gt;d.estr);
1237 	}
1238 }
1239 void
1240 varFreeMembers(const struct svar *r)
1241 {
1242 	varFreeMembersSelectively(r, SKIP_NOTHING);
1243 }
1244 static rsRetVal
1245 doExtractFieldByChar(uchar *str, uchar delim, const int matchnbr, uchar **resstr)
1246 {
1247 	int iCurrFld;
1248 	int allocLen;
1249 	int iLen;
1250 	uchar *pBuf;
1251 	uchar *pFld;
1252 	uchar *pFldEnd;
1253 	DEFiRet;
1254 	iCurrFld = 1;
1255 	pFld = str;
1256 	while(*pFld &amp;&amp; iCurrFld &lt; matchnbr) {
1257 		while(*pFld &amp;&amp; (uchar) *pFld != delim)
1258 			++pFld; 		if(*pFld == delim) {
1259 			++pFld; 			++iCurrFld;
1260 		}
1261 	}
1262 	DBGPRINTF("field() field requested %d, field found %d\n", matchnbr, iCurrFld);
1263 	if(iCurrFld == matchnbr) {
1264 		pFldEnd = pFld;
1265 		while(*pFldEnd &amp;&amp; *pFldEnd != delim)
1266 			++pFldEnd;
1267 		iLen = pFldEnd - pFld + 1; 		allocLen = iLen + 1;
1268 #		ifdef VALGRIND
1269 		allocLen += (3 - (iLen % 4));
1270 #		endif
1271 		CHKmalloc(pBuf = malloc(allocLen));
1272 		memcpy(pBuf, pFld, iLen);
1273 		pBuf[iLen] = '\0'; 		*resstr = pBuf;
1274 	} else {
1275 		ABORT_FINALIZE(RS_RET_FIELD_NOT_FOUND);
1276 	}
1277 finalize_it:
1278 	RETiRet;
1279 }
1280 static rsRetVal
1281 doExtractFieldByStr(uchar *str, char *delim, const rs_size_t lenDelim, const int matchnbr, uchar **resstr)
1282 {
1283 	int iCurrFld;
1284 	int iLen;
1285 	uchar *pBuf;
1286 	uchar *pFld;
1287 	uchar *pFldEnd;
1288 	DEFiRet;
1289 	if (str == NULL || delim == NULL)
1290 		ABORT_FINALIZE(RS_RET_FIELD_NOT_FOUND);
1291 	iCurrFld = 1;
1292 	pFld = str;
1293 	while(pFld != NULL &amp;&amp; iCurrFld &lt; matchnbr) {
1294 		if((pFld = (uchar*) strstr((char*)pFld, delim)) != NULL) {
1295 			pFld += lenDelim;
1296 			++iCurrFld;
1297 		}
1298 	}
1299 	DBGPRINTF("field() field requested %d, field found %d\n", matchnbr, iCurrFld);
1300 	if(iCurrFld == matchnbr) {
1301 		pFldEnd = (uchar*) strstr((char*)pFld, delim);
1302 		if(pFldEnd == NULL) {
1303 			iLen = strlen((char*) pFld);
1304 			iLen = pFldEnd - pFld;
1305 		}
1306 		CHKmalloc(pBuf = malloc(iLen + 1));
1307 		memcpy(pBuf, pFld, iLen);
1308 		pBuf[iLen] = '\0'; 		*resstr = pBuf;
1309 	} else {
1310 		ABORT_FINALIZE(RS_RET_FIELD_NOT_FOUND);
1311 	}
1312 finalize_it:
1313 	RETiRet;
1314 }
1315 static void
1316 doFunc_re_extract(struct cnffunc *func, struct svar *ret, void* usrptr, wti_t *const pWti)
1317 {
1318 	size_t submatchnbr;
1319 	short matchnbr;
1320 	regmatch_t pmatch[50];
1321 	int bMustFree;
1322 	es_str_t *estr = NULL; 	char *str;
1323 	struct svar r[CNFFUNC_MAX_ARGS];
1324 	int iLenBuf;
1325 	unsigned iOffs;
1326 	short iTry = 0;
1327 	uchar bFound = 0;
1328 	iOffs = 0;
1329 	sbool bHadNoMatch = 0;
1330 	cnfexprEval(func-&gt;expr[0], &amp;r[0], usrptr, pWti);
1331 	cnfexprEval(func-&gt;expr[2], &amp;r[2], usrptr, pWti);
1332 	cnfexprEval(func-&gt;expr[3], &amp;r[3], usrptr, pWti);
1333 	str = (char*) var2CString(&amp;r[0], &amp;bMustFree);
1334 	matchnbr = (short) var2Number(&amp;r[2], NULL);
1335 	submatchnbr = (size_t) var2Number(&amp;r[3], NULL);
1336 	if(submatchnbr &gt;= sizeof(pmatch)/sizeof(regmatch_t)) {
1337 		DBGPRINTF("re_extract() submatch %zd is too large\n", submatchnbr);
1338 		bHadNoMatch = 1;
1339 		goto finalize_it;
1340 	}
1341 	while(!bFound) {
1342 		int iREstat;
1343 		iREstat = regexp.regexec(func-&gt;funcdata, (char*)(str + iOffs),
1344 					 submatchnbr+1, pmatch, 0);
1345 		DBGPRINTF("re_extract: regexec return is %d\n", iREstat);
1346 		if(iREstat == 0) {
1347 			if(pmatch[0].rm_so == -1) {
1348 				DBGPRINTF("oops ... start offset of successful regexec is -1\n");
1349 				break;
1350 			}
1351 			if(iTry == matchnbr) {
1352 				bFound = 1;
1353 			} else {
1354 				DBGPRINTF("re_extract: regex found at offset %d, new offset %d, tries %d\n",
1355 					  iOffs, (int) (iOffs + pmatch[0].rm_eo), iTry);
1356 				iOffs += pmatch[0].rm_eo;
1357 				++iTry;
1358 			}
1359 		} else {
1360 			break;
1361 		}
1362 	}
1363 	DBGPRINTF("re_extract: regex: end search, found %d\n", bFound);
1364 	if(!bFound) {
1365 		bHadNoMatch = 1;
1366 		goto finalize_it;
1367 	} else {
1368 		if(pmatch[submatchnbr].rm_so == -1) {
1369 			bHadNoMatch = 1;
1370 			goto finalize_it;
1371 		}
1372 		iLenBuf = pmatch[submatchnbr].rm_eo - pmatch[submatchnbr].rm_so;
1373 		estr = es_newStrFromBuf(str + iOffs + pmatch[submatchnbr].rm_so,
1374 					iLenBuf);
1375 	}
1376 finalize_it:
1377 	if(bMustFree) free(str);
1378 	varFreeMembers(&amp;r[0]);
1379 	varFreeMembers(&amp;r[2]);
1380 	varFreeMembers(&amp;r[3]);
1381 	if(bHadNoMatch) {
1382 		cnfexprEval(func-&gt;expr[4], &amp;r[4], usrptr, pWti);
1383 		estr = var2String(&amp;r[4], &amp;bMustFree);
1384 		varFreeMembersSelectively(&amp;r[4], SKIP_STRING);
1385 	}
1386 	ret-&gt;datatype = 'S';
1387 	ret-&gt;d.estr = estr;
1388 	return;
1389 }
1390 static void
1391 doFunc_exec_template(struct cnffunc *__restrict__ const func,
1392 	struct svar *__restrict__ const ret,
1393 	void *const usrptr,
1394 	wti_t *const pWti __attribute__((unused)))
1395 {
1396 	smsg_t *const pMsg = (smsg_t*) usrptr;
1397 	rsRetVal localRet;
1398 	actWrkrIParams_t iparam;
1399 	wtiInitIParam(&amp;iparam);
1400 	localRet = tplToString(func-&gt;funcdata, pMsg, &amp;iparam, NULL);
1401 	if(localRet == RS_RET_OK) {
1402 		ret-&gt;d.estr = es_newStrFromCStr((char*)iparam.param, iparam.lenStr);
1403 	} else {
1404 		ret-&gt;d.estr = es_newStrFromCStr("", 0);
1405 	}
1406 	ret-&gt;datatype = 'S';
1407 	free(iparam.param);
1408 	return;
1409 }
1410 static es_str_t*
1411 doFuncReplace(struct svar *__restrict__ const operandVal, struct svar *__restrict__ const findVal,
1412 		struct svar *__restrict__ const replaceWithVal) {
1413 	int freeOperand, freeFind, freeReplacement;
1414 	es_str_t *str = var2String(operandVal, &amp;freeOperand);
1415 	es_str_t *findStr = var2String(findVal, &amp;freeFind);
1416 	es_str_t *replaceWithStr = var2String(replaceWithVal, &amp;freeReplacement);
1417 	uchar *find = es_getBufAddr(findStr);
1418 	uchar *replaceWith = es_getBufAddr(replaceWithStr);
1419 	uint lfind = es_strlen(findStr);
1420 	uint lReplaceWith = es_strlen(replaceWithStr);
1421 	uint lSrc = es_strlen(str);
1422 	uint lDst = 0;
1423 	uchar* src_buff = es_getBufAddr(str);
1424 	uint i, j;
1425 	for(i = j = 0; i &lt;= lSrc; i++, lDst++) {
1426 		if (j == lfind) {
1427 			lDst = lDst - lfind + lReplaceWith;
1428 			j = 0;
1429 		}
1430 		if (i == lSrc) break;
1431 		if (src_buff[i] == find[j]) {
1432 			j++;
1433 		} else if (j &gt; 0) {
1434 			i -= (j - 1);
1435 			lDst -= (j - 1);
1436 			j = 0;
1437 		}
1438 	}
1439 	es_str_t *res = es_newStr(lDst);
1440 	unsigned char* dest = es_getBufAddr(res);
1441 	uint k, s;
1442 	for(i = j = s = 0; i &lt;= lSrc; i++, s++) {
1443 		if (j == lfind) {
1444 		s -= j;
1445 		for (k = 0; k &lt; lReplaceWith; k++, s++) dest[s] = replaceWith[k];
1446 			j = 0;
1447 		}
1448 		if (i == lSrc) break;
1449 		if (src_buff[i] == find[j]) {
1450 			j++;
1451 		} else {
1452 			if (j &gt; 0) {
1453 				i -= j;
1454 				s -= j;
1455 				j = 0;
1456 			}
1457 			dest[s] = src_buff[i];
1458 		}
1459 	}
1460 	if (j &gt; 0) {
1461 		for (k = 1; k &lt;= j; k++) dest[s - k] = src_buff[i - k];
1462 	}
1463 	res-&gt;lenStr = lDst;
1464 	if(freeOperand) es_deleteStr(str);
1465 	if(freeFind) es_deleteStr(findStr);
1466 	if(freeReplacement) es_deleteStr(replaceWithStr);
1467 	return res;
1468 }
1469 static void ATTR_NONNULL()
1470 doFunc_parse_json(struct cnffunc *__restrict__ const func,
1471 	struct svar *__restrict__ const ret,
1472 	void *const usrptr,
1473 	wti_t *const pWti)
1474 {
1475 	struct svar srcVal[2];
1476 	int bMustFree;
1477 	int bMustFree2;
1478 	smsg_t *const pMsg = (smsg_t*)usrptr;
1479 	cnfexprEval(func-&gt;expr[0], &amp;srcVal[0], usrptr, pWti);
1480 	cnfexprEval(func-&gt;expr[1], &amp;srcVal[1], usrptr, pWti);
1481 	char *jsontext = (char*) var2CString(&amp;srcVal[0], &amp;bMustFree);
1482 	char *container = (char*) var2CString(&amp;srcVal[1], &amp;bMustFree2);
1483 	struct json_object *json;
1484 	int retVal;
1485 	assert(jsontext != NULL);
1486 	assert(container != NULL);
1487 	assert(pMsg != NULL);
1488 	struct json_tokener *const tokener = json_tokener_new();
1489 	if(tokener == NULL) {
1490 		retVal = 1;
1491 		goto finalize_it;
1492 	}
1493 	json = json_tokener_parse_ex(tokener, jsontext, strlen(jsontext));
1494 	if(json == NULL) {
1495 		retVal = RS_SCRIPT_EINVAL;
1496 	} else {
1497 		size_t off = (*container == '$') ? 1 : 0;
1498 		msgAddJSON(pMsg, (uchar*)container+off, json, 0, 0);
1499 		retVal = RS_SCRIPT_EOK;
1500 	}
1501 	wtiSetScriptErrno(pWti, retVal);
1502 	json_tokener_free(tokener);
1503 finalize_it:
1504 	ret-&gt;datatype = 'N';
1505 	ret-&gt;d.n = retVal;
1506 	if(bMustFree) {
1507 		free(jsontext);
1508 	}
1509 	if(bMustFree2) {
1510 		free(container);
1511 	}
1512 	varFreeMembers(&amp;srcVal[0]);
1513 	varFreeMembers(&amp;srcVal[1]);
1514 }
1515 static void ATTR_NONNULL()
1516 doFunc_get_property(struct cnffunc *__restrict__ const func,
1517 	struct svar *__restrict__ const ret,
1518 	void *const usrptr,
1519 	wti_t *const pWti)
1520 {
1521 	int retVal = RS_SCRIPT_EOK;
1522 	int bMustFree = 0;
1523 	char *expr = NULL;
1524 	struct svar srcVal[2] = {{.d={0}, .datatype=0}};
1525 	struct json_object *json = NULL;
1526 	if (func-&gt;expr[0]-&gt;nodetype == 'S') {
1527 		retVal = RS_SCRIPT_EINVAL;
1528 		FINALIZE;
1529 	}
1530 	cnfexprEval(func-&gt;expr[0], &amp;srcVal[0], usrptr, pWti);
1531 	cnfexprEval(func-&gt;expr[1], &amp;srcVal[1], usrptr, pWti);
1532 	DBGPRINTF("srcval[0] datatype: %c\n", srcVal[0].datatype);
1533 	DBGPRINTF("srcval[1] datatype: %c\n", srcVal[1].datatype);
1534 	switch (srcVal[0].datatype) {
1535 		case 'J': {
1536 			json = srcVal[0].d.json;
1537 			break;
1538 		}
1539 		case 'S': {
1540 			ret-&gt;d.estr = es_strdup(srcVal[0].d.estr);
1541 			ret-&gt;datatype = 'S';
1542 			FINALIZE;
1543 			break;
1544 		}
1545 		default: {
1546 			ret-&gt;d.estr = es_newStrFromCStr("", 1);
1547 			ret-&gt;datatype = 'S';
1548 			FINALIZE;
1549 			break;
1550 		}
1551 	}
1552 	switch (json_object_get_type(json)) {
1553 		case json_type_object: {
1554 			expr = (char*) var2CString(&amp;srcVal[1], &amp;bMustFree);
1555 			if (expr &amp;&amp; expr[0] == '\0') {
1556 				ret-&gt;d.json = json_object_get(json);
1557 				ret-&gt;datatype = 'J';
1558 				break;
1559 			}
1560 			if (expr &amp;&amp; !json_object_object_get_ex(json, (char*)expr, &amp;ret-&gt;d.json)) {
1561 					retVal = RS_SCRIPT_EINVAL;
1562 					FINALIZE;
1563 			}
1564 			if (ret-&gt;d.json) {
1565 				ret-&gt;d.json = json_object_get(ret-&gt;d.json);
1566 				ret-&gt;datatype = 'J';
1567 			} else {
1568 				ret-&gt;d.estr = es_newStrFromCStr("", 1);
1569 				ret-&gt;datatype = 'S';
1570 			}
1571 			break;
1572 		}
1573 		case json_type_array: {
1574 			int success = 0;
1575 			long long index = var2Number(&amp;srcVal[1], &amp;success);
1576 			if (!success || index &lt; 0 || (size_t)index &gt;= sizeof(size_t)) {
1577 				retVal = RS_SCRIPT_EINVAL;
1578 				FINALIZE;
1579 			}
1580 			ret-&gt;d.json = json_object_array_get_idx(json, index);
1581 			if (ret-&gt;d.json) {
1582 				ret-&gt;d.json = json_object_get(ret-&gt;d.json);
1583 				ret-&gt;datatype = 'J';
1584 			} else {
1585 				ret-&gt;d.estr = es_newStrFromCStr("", 1);
1586 				ret-&gt;datatype = 'S';
1587 			}
1588 			break;
1589 		}
1590 		case json_type_boolean:
1591 		case json_type_int: {
1592 			ret-&gt;d.n = json_object_get_int64(json);
1593 			ret-&gt;datatype = 'N';
1594 			break;
1595 		}
1596 		case json_type_double: {
1597 			ret-&gt;d.n = json_object_get_double(json);
1598 			ret-&gt;datatype = 'N';
1599 			break;
1600 		}
1601 		case json_type_string: {
1602 			ret-&gt;d.estr = es_newStrFromCStr(json_object_get_string(json), json_object_get_string_len(json));
1603 			ret-&gt;datatype = 'S';
1604 			break;
1605 		}
1606 		case json_type_null: {
1607 			ret-&gt;datatype = 'S';
1608 			ret-&gt;d.estr = es_newStrFromCStr("", 1);
1609 			break;
1610 		}
1611 		default:
1612 			LogError(0, RS_RET_INTERNAL_ERROR,
1613 				"Warning - unhandled json type(%d) !!!!\n", json_object_get_type(json));
1614 			retVal = RS_SCRIPT_EINVAL;
1615 			break;
1616 	}
1617 finalize_it:
1618 	wtiSetScriptErrno(pWti, retVal);
1619 	if (retVal != RS_SCRIPT_EOK) {
1620 		ret-&gt;datatype = 'S';
1621 		ret-&gt;d.estr = es_newStrFromCStr("", 1);
1622 	}
1623 	if (bMustFree) {
1624 		free(expr);
1625 	}
1626 	varFreeMembers(&amp;srcVal[0]);
1627 	varFreeMembers(&amp;srcVal[1]);
1628 }
1629 static void ATTR_NONNULL()
1630 doFunct_RandomGen(struct cnffunc *__restrict__ const func,
1631 	struct svar *__restrict__ const ret,
1632 	void *__restrict__ const usrptr,
1633 	wti_t *__restrict__ const pWti)
1634 {
1635 	int success = 0;
1636 	struct svar srcVal;
1637 	long long retVal;
1638 	long int x;
1639 	cnfexprEval(func-&gt;expr[0], &amp;srcVal, usrptr, pWti);
1640 	long long max = var2Number(&amp;srcVal, &amp;success);
1641 	if (! success) {
1642 		DBGPRINTF("rainerscript: random(max) didn't get a valid 'max' limit, defaulting random-number "
1643 			"value to 0");
1644 		retVal = 0;
1645 		goto done;
1646 	}
1647 	if(max == 0) {
1648 		DBGPRINTF("rainerscript: random(max) invalid, 'max' is zero, , defaulting random-number value to 0");
1649 		retVal = 0;
1650 		goto done;
1651 	}
1652 	x = labs(randomNumber());
1653 	if (max &gt; MAX_RANDOM_NUMBER) {
1654 		DBGPRINTF("rainerscript: desired random-number range [0 - %lld] "
1655 			"is wider than supported limit of [0 - %d)\n",
1656 			max, MAX_RANDOM_NUMBER);
1657 	}
1658 	retVal = (x % max);
1659 done:
1660 	ret-&gt;d.n = retVal;
1661 	ret-&gt;datatype = 'N';
1662 	varFreeMembers(&amp;srcVal);
1663 }
1664 static void ATTR_NONNULL()
1665 doFunct_LTrim(struct cnffunc *__restrict__ const func,
1666 	struct svar *__restrict__ const ret,
1667 	void *__restrict__ const usrptr,
1668 	wti_t *__restrict__ const pWti)
1669 {
1670 	struct svar srcVal;
1671 	int bMustFree;
1672 	cnfexprEval(func-&gt;expr[0], &amp;srcVal, usrptr, pWti);
1673 	char *str = (char*)var2CString(&amp;srcVal, &amp;bMustFree);
1674 	const int len = strlen(str);
1675 	int i;
1676 	es_str_t *estr = NULL;
1677 	for(i = 0; i &lt; len; i++) {
1678 		if(str[i] != ' ') {
1679 			break;
1680 		}
1681 	}
1682 	estr = es_newStrFromCStr(str + i, len - i);
1683 	ret-&gt;d.estr = estr;
1684 	ret-&gt;datatype = 'S';
1685 	varFreeMembers(&amp;srcVal);
1686 	if(bMustFree)
1687 		free(str);
1688 }
1689 static void ATTR_NONNULL()
1690 doFunct_RTrim(struct cnffunc *__restrict__ const func,
1691 	struct svar *__restrict__ const ret,
1692 	void *__restrict__ const usrptr,
1693 	wti_t *__restrict__ const pWti)
1694 {
1695 	struct svar srcVal;
1696 	int bMustFree;
1697 	cnfexprEval(func-&gt;expr[0], &amp;srcVal, usrptr, pWti);
1698 	char *str = (char*)var2CString(&amp;srcVal, &amp;bMustFree);
1699 	int len = strlen(str);
1700 	int i;
1701 	es_str_t *estr = NULL;
1702 	for(i = (len - 1); i &gt; 0; i--) {
1703 		if(str[i] != ' ') {
1704 			break;
1705 		}
1706 	}
1707 	if(i &gt; 0 || str[0] != ' ') {
1708 		estr = es_newStrFromCStr(str, (i + 1));
1709 	} else {
1710 		estr = es_newStr(1);
1711 	}
1712 	ret-&gt;d.estr = estr;
1713 	ret-&gt;datatype = 'S';
1714 	varFreeMembers(&amp;srcVal);
1715 	if(bMustFree)
1716 		free(str);
1717 }
1718 static void ATTR_NONNULL()
1719 doFunct_Getenv(struct cnffunc *__restrict__ const func,
1720 	struct svar *__restrict__ const ret,
1721 	void *__restrict__ const usrptr,
1722 	wti_t *__restrict__ const pWti)
1723 {
1724 	struct svar srcVal;
1725 	char *envvar;
1726 	es_str_t *estr;
1727 	char *str;
1728 	int bMustFree;
1729 	cnfexprEval(func-&gt;expr[0], &amp;srcVal, usrptr, pWti);
1730 	estr = var2String(&amp;srcVal, &amp;bMustFree);
1731 	str = (char*) es_str2cstr(estr, NULL);
1732 	envvar = getenv(str);
1733 	if(envvar == NULL) {
1734 		ret-&gt;d.estr = es_newStr(0);
1735 	} else {
1736 		ret-&gt;d.estr = es_newStrFromCStr(envvar, strlen(envvar));
1737 	}
1738 	ret-&gt;datatype = 'S';
1739 	if(bMustFree) {
1740 		es_deleteStr(estr);
1741 	}
1742 	varFreeMembers(&amp;srcVal);
1743 	free(str);
1744 }
1745 static void ATTR_NONNULL()
1746 doFunct_ToLower(struct cnffunc *__restrict__ const func,
1747 	struct svar *__restrict__ const ret,
1748 	void *__restrict__ const usrptr,
1749 	wti_t *__restrict__ const pWti)
1750 {
1751 	struct svar srcVal;
1752 	es_str_t *estr;
1753 	int bMustFree;
1754 	cnfexprEval(func-&gt;expr[0], &amp;srcVal, usrptr, pWti);
1755 	estr = var2String(&amp;srcVal, &amp;bMustFree);
1756 	if(!bMustFree) {		estr = es_strdup(estr);
1757 	}
1758 	es_tolower(estr);
1759 	ret-&gt;datatype = 'S';
1760 	ret-&gt;d.estr = estr;
1761 	varFreeMembers(&amp;srcVal);
1762 }
1763 static void ATTR_NONNULL()
1764 doFunct_CStr(struct cnffunc *__restrict__ const func,
1765 	struct svar *__restrict__ const ret,
1766 	void *__restrict__ const usrptr,
1767 	wti_t *__restrict__ const pWti)
1768 {
1769 	struct svar srcVal;
1770 	es_str_t *estr;
1771 	int bMustFree;
1772 	cnfexprEval(func-&gt;expr[0], &amp;srcVal, usrptr, pWti);
1773 	estr = var2String(&amp;srcVal, &amp;bMustFree);
1774 	if(!bMustFree) 		estr = es_strdup(estr);
1775 	ret-&gt;datatype = 'S';
1776 	ret-&gt;d.estr = estr;
1777 	varFreeMembers(&amp;srcVal);
1778 }
1779 static void ATTR_NONNULL()
1780 doFunct_CNum(struct cnffunc *__restrict__ const func,
1781 	struct svar *__restrict__ const ret,
1782 	void *__restrict__ const usrptr,
1783 	wti_t *__restrict__ const pWti)
1784 {
1785 	struct svar srcVal;
1786 	if(func-&gt;expr[0]-&gt;nodetype == 'N') {
1787 		ret-&gt;d.n = ((struct cnfnumval*)func-&gt;expr[0])-&gt;val;
1788 	} else if(func-&gt;expr[0]-&gt;nodetype == 'S') {
1789 		ret-&gt;d.n = es_str2num(((struct cnfstringval*) func-&gt;expr[0])-&gt;estr,
1790 				      NULL);
1791 	} else {
1792 		cnfexprEval(func-&gt;expr[0], &amp;srcVal, usrptr, pWti);
1793 		ret-&gt;d.n = var2Number(&amp;srcVal, NULL);
1794 		varFreeMembers(&amp;srcVal);
1795 	}
1796 	ret-&gt;datatype = 'N';
1797 	DBGPRINTF("JSONorString: cnum node type %c result %d\n", func-&gt;expr[0]-&gt;nodetype, (int) ret-&gt;d.n);
1798 }
1799 static void ATTR_NONNULL()
1800 doFunct_ReMatch(struct cnffunc *__restrict__ const func,
1801 	struct svar *__restrict__ const ret,
1802 	void *__restrict__ const usrptr,
1803 	wti_t *__restrict__ const pWti)
1804 {
1805 	struct svar srcVal;
1806 	int bMustFree;
1807 	char *str;
1808 	int retval;
1809 	cnfexprEval(func-&gt;expr[0], &amp;srcVal, usrptr, pWti);
1810 	str = (char*) var2CString(&amp;srcVal, &amp;bMustFree);
1811 	retval = regexp.regexec(func-&gt;funcdata, str, 0, NULL, 0);
1812 	if(retval == 0)
1813 		ret-&gt;d.n = 1;
1814 	else {
1815 		ret-&gt;d.n = 0;
1816 		if(retval != REG_NOMATCH) {
1817 			DBGPRINTF("re_match: regexec returned error %d\n", retval);
1818 		}
1819 	}
1820 	ret-&gt;datatype = 'N';
1821 	if(bMustFree) {
1822 		free(str);
1823 	}
1824 	varFreeMembers(&amp;srcVal);
1825 }
1826 static void ATTR_NONNULL()
1827 doFunct_Ipv42num(struct cnffunc *__restrict__ const func,
1828 	struct svar *__restrict__ const ret,
1829 	void *__restrict__ const usrptr,
1830 	wti_t *__restrict__ const pWti)
1831 {
1832 	struct svar srcVal;
1833 	int bMustFree;
1834 	char *str;
1835 	cnfexprEval(func-&gt;expr[0], &amp;srcVal, usrptr, pWti);
1836 	str = (char*)var2CString(&amp;srcVal, &amp;bMustFree);
1837 	unsigned num[4] = {0, 0, 0, 0};
1838 	long long value = -1;
1839 	size_t len = strlen(str);
1840 	int cyc = 0;
1841 	int prevdot = 0;
1842 	int startblank = 0;
1843 	int endblank = 0;
1844 	DBGPRINTF("rainerscript: (ipv42num) arg: '%s'\n", str);
1845 	for(unsigned int i = 0 ; i &lt; len ; i++) {
1846 		switch(str[i]){
1847 		case '0':
1848 		case '1':
1849 		case '2':
1850 		case '3':
1851 		case '4':
1852 		case '5':
1853 		case '6':
1854 		case '7':
1855 		case '8':
1856 		case '9':
1857 			if(endblank == 1){
1858 				DBGPRINTF("rainerscript: (ipv42num) error: wrong IP-Address format "
1859 					"(invalid space(1))\n");
1860 				goto done;
1861 			}
1862 			prevdot = 0;
1863 			startblank = 0;
1864 			DBGPRINTF("rainerscript: (ipv42num) cycle: %d\n", cyc);
1865 			num[cyc] = num[cyc]*10+(str[i]-'0');
1866 			break;
1867 		case ' ':
1868 			prevdot = 0;
1869 			if(i == 0 || startblank == 1){
1870 				startblank = 1;
1871 				break;
1872 			}
1873 			else{
1874 				endblank = 1;
1875 				break;
1876 			}
1877 		case '.':
1878 			if(endblank == 1){
1879 				DBGPRINTF("rainerscript: (ipv42num) error: wrong IP-Address format "
1880 					"(inalid space(2))\n");
1881 				goto done;
1882 			}
1883 			startblank = 0;
1884 			if(prevdot == 1){
1885 				DBGPRINTF("rainerscript: (ipv42num) error: wrong IP-Address format "
1886 					"(two dots after one another)\n");
1887 				goto done;
1888 			}
1889 			prevdot = 1;
1890 			cyc++;
1891 			if(cyc &gt; 3){
1892 				DBGPRINTF("rainerscript: (ipv42num) error: wrong IP-Address format "
1893 					"(too many dots)\n");
1894 				goto done;
1895 			}
1896 			break;
1897 		default:
1898 			DBGPRINTF("rainerscript: (ipv42num) error: wrong IP-Address format (invalid charakter)\n");
1899 			goto done;
1900 		}
1901 	}
1902 	if(cyc != 3){
1903 		DBGPRINTF("rainerscript: (ipv42num) error: wrong IP-Address format (wrong number of dots)\n");
1904 		goto done;
1905 	}
1906 	value = num[0]*256*256*256+num[1]*256*256+num[2]*256+num[3];
1907 done:
1908 	DBGPRINTF("rainerscript: (ipv42num): return value:'%lld'\n",value);
1909 	ret-&gt;datatype = 'N';
1910 	ret-&gt;d.n = value;
1911 	varFreeMembers(&amp;srcVal);
1912 	if(bMustFree)
1913 		free(str);
1914 }
1915 static void ATTR_NONNULL()
1916 doFunct_Int2Hex(struct cnffunc *__restrict__ const func,
1917 	struct svar *__restrict__ const ret,
1918 	void *__restrict__ const usrptr,
1919 	wti_t *__restrict__ const pWti)
1920 {
1921 	struct svar srcVal;
1922 	int success = 0;
1923 	char str[18];
1924 	es_str_t* estr = NULL;
1925 	cnfexprEval(func-&gt;expr[0], &amp;srcVal, usrptr, pWti);
1926 	long long num = var2Number(&amp;srcVal, &amp;success);
1927 	if (!success) {
1928 		DBGPRINTF("rainerscript: (int2hex) couldn't access number\n");
1929 		estr = es_newStrFromCStr("NAN", strlen("NAN"));
1930 		goto done;
1931 	}
1932 	snprintf(str, 18, "%llx", num);
1933 	estr = es_newStrFromCStr(str, strlen(str));
1934 done:
1935 	ret-&gt;d.estr = estr;
1936 	ret-&gt;datatype = 'S';
1937 	varFreeMembers(&amp;srcVal);
1938 }
1939 static void ATTR_NONNULL()
1940 doFunct_Replace(struct cnffunc *__restrict__ const func,
1941 	struct svar *__restrict__ const ret,
1942 	void *__restrict__ const usrptr,
1943 	wti_t *__restrict__ const pWti)
1944 {
1945 	struct svar srcVal[3];
1946 	cnfexprEval(func-&gt;expr[0], &amp;srcVal[0], usrptr, pWti);
1947 	cnfexprEval(func-&gt;expr[1], &amp;srcVal[1], usrptr, pWti);
1948 	cnfexprEval(func-&gt;expr[2], &amp;srcVal[2], usrptr, pWti);
1949 	ret-&gt;d.estr = doFuncReplace(&amp;srcVal[0], &amp;srcVal[1], &amp;srcVal[2]);
1950 	ret-&gt;datatype = 'S';
1951 	varFreeMembers(&amp;srcVal[0]);
1952 	varFreeMembers(&amp;srcVal[1]);
1953 	varFreeMembers(&amp;srcVal[2]);
1954 }
1955 static void ATTR_NONNULL()
1956 doFunct_Wrap(struct cnffunc *__restrict__ const func,
1957 	struct svar *__restrict__ const ret,
1958 	void *__restrict__ const usrptr,
1959 	wti_t *__restrict__ const pWti)
1960 {
1961 	struct svar sourceVal;
1962 	struct svar wrapperVal;
1963 	struct svar escaperVal;
1964 	int freeSource, freeWrapper;
1965 	es_str_t *sourceStr;
1966 	cnfexprEval(func-&gt;expr[0], &amp;sourceVal, usrptr, pWti);
1967 	cnfexprEval(func-&gt;expr[1], &amp;wrapperVal, usrptr, pWti);
1968 	if(func-&gt;nParams == 3) {
1969 		cnfexprEval(func-&gt;expr[2], &amp;escaperVal, usrptr, pWti);
1970 		sourceStr = doFuncReplace(&amp;sourceVal, &amp;wrapperVal, &amp;escaperVal);
1971 		freeSource = 1;
1972 	} else {
1973 		sourceStr = var2String(&amp;sourceVal, &amp;freeSource);
1974 	}
1975 	es_str_t *wrapperStr = var2String(&amp;wrapperVal, &amp;freeWrapper);
1976 	uchar *src = es_getBufAddr(sourceStr);
1977 	uchar *wrapper = es_getBufAddr(wrapperStr);
1978 	uint lWrapper = es_strlen(wrapperStr);
1979 	uint lSrc = es_strlen(sourceStr);
1980 	uint totalLen = lSrc + 2 * lWrapper;
1981 	es_str_t *res = es_newStr(totalLen);
1982 	uchar* resBuf = es_getBufAddr(res);
1983 	memcpy(resBuf, wrapper, lWrapper);
1984 	memcpy(resBuf + lWrapper, src, lSrc);
1985 	memcpy(resBuf + lSrc + lWrapper, wrapper, lWrapper);
1986 	res-&gt;lenStr = totalLen;
1987 	if (freeSource) {
1988 		es_deleteStr(sourceStr);
1989 	}
1990 	if (freeWrapper) {
1991 		es_deleteStr(wrapperStr);
1992 	}
1993 	ret-&gt;d.estr = res;
1994 	ret-&gt;datatype = 'S';
1995 	varFreeMembers(&amp;sourceVal);
1996 	varFreeMembers(&amp;wrapperVal);
1997 	if(func-&gt;nParams == 3) varFreeMembers(&amp;escaperVal);
1998 }
1999 static void ATTR_NONNULL()
2000 doFunct_StrLen(struct cnffunc *__restrict__ const func,
2001 	struct svar *__restrict__ const ret,
2002 	void *__restrict__ const usrptr,
2003 	wti_t *__restrict__ const pWti)
2004 {
2005 	struct svar srcVal;
2006 	int bMustFree;
2007 	es_str_t *estr;
2008 	if(func-&gt;expr[0]-&gt;nodetype == 'S') {
2009 		ret-&gt;d.n = es_strlen(((struct cnfstringval*) func-&gt;expr[0])-&gt;estr);
2010 	} else {
2011 		cnfexprEval(func-&gt;expr[0], &amp;srcVal, usrptr, pWti);
2012 		estr = var2String(&amp;srcVal, &amp;bMustFree);
2013 		ret-&gt;d.n = es_strlen(estr);
2014 		if(bMustFree) {
2015 			es_deleteStr(estr);
2016 		}
2017 		varFreeMembers(&amp;srcVal);
2018 	}
2019 	ret-&gt;datatype = 'N';
2020 }
2021 static void ATTR_NONNULL()
2022 doFunct_Substring(struct cnffunc *__restrict__ const func,
2023 	struct svar *__restrict__ const ret,
2024 	void *__restrict__ const usrptr,
2025 	wti_t *__restrict__ const pWti)
2026 {    //TODO: generalize parameter getter? jgerhards, 2018-02-26
2027 	int bMustFree;
2028 	struct svar srcVal[3];
2029 	cnfexprEval(func-&gt;expr[0], &amp;srcVal[0], usrptr, pWti);
2030 	cnfexprEval(func-&gt;expr[1], &amp;srcVal[1], usrptr, pWti);
2031 	cnfexprEval(func-&gt;expr[2], &amp;srcVal[2], usrptr, pWti);
2032 	es_str_t *es = var2String(&amp;srcVal[0], &amp;bMustFree);
2033 	const int start = var2Number(&amp;srcVal[1], NULL);
2034 	const int subStrLen = var2Number(&amp;srcVal[2], NULL);
2035 	ret-&gt;datatype = 'S';
2036 	ret-&gt;d.estr = es_newStrFromSubStr(es, (es_size_t)start, (es_size_t)subStrLen);
2037 	if(bMustFree) es_deleteStr(es);
2038 	varFreeMembers(&amp;srcVal[0]);
2039 	varFreeMembers(&amp;srcVal[1]);
2040 	varFreeMembers(&amp;srcVal[2]);
2041 }
2042 static void ATTR_NONNULL()
2043 doFunct_Field(struct cnffunc *__restrict__ const func,
2044 	struct svar *__restrict__ const ret,
2045 	void *__restrict__ const usrptr,
2046 	wti_t *__restrict__ const pWti)
2047 {
2048 	struct svar srcVal[3];
2049 	int bMustFree;
2050 	char *str;
2051 	uchar *resStr;
2052 	int matchnbr;
2053 	int delim;
2054 	rsRetVal localRet;
2055 	cnfexprEval(func-&gt;expr[0], &amp;srcVal[0], usrptr, pWti);
2056 	cnfexprEval(func-&gt;expr[1], &amp;srcVal[1], usrptr, pWti);
2057 	cnfexprEval(func-&gt;expr[2], &amp;srcVal[2], usrptr, pWti);
2058 	str = (char*) var2CString(&amp;srcVal[0], &amp;bMustFree);
2059 	matchnbr = var2Number(&amp;srcVal[2], NULL);
2060 	if(srcVal[1].datatype == 'S') {
2061 		char *delimstr;
2062 		delimstr = (char*) es_str2cstr(srcVal[1].d.estr, NULL);
2063 		localRet = doExtractFieldByStr((uchar*)str, delimstr, es_strlen(srcVal[1].d.estr),
2064 						matchnbr, &amp;resStr);
2065 		free(delimstr);
2066 	} else {
2067 		delim = var2Number(&amp;srcVal[1], NULL);
2068 		localRet = doExtractFieldByChar((uchar*)str, (char) delim, matchnbr, &amp;resStr);
2069 	}
2070 	if(localRet == RS_RET_OK) {
2071 		ret-&gt;d.estr = es_newStrFromCStr((char*)resStr, strlen((char*)resStr));
2072 		free(resStr);
2073 	} else if(localRet == RS_RET_FIELD_NOT_FOUND) {
2074 		ret-&gt;d.estr = es_newStrFromCStr("***FIELD NOT FOUND***",
2075 				sizeof("***FIELD NOT FOUND***")-1);
2076 	} else {
2077 		ret-&gt;d.estr = es_newStrFromCStr("***ERROR in field() FUNCTION***",
2078 				sizeof("***ERROR in field() FUNCTION***")-1);
2079 	}
2080 	ret-&gt;datatype = 'S';
2081 	if(bMustFree) free(str);
2082 	varFreeMembers(&amp;srcVal[0]);
2083 	varFreeMembers(&amp;srcVal[1]);
2084 	varFreeMembers(&amp;srcVal[2]);
2085 }
2086 static void ATTR_NONNULL()
2087 doFunct_Prifilt(struct cnffunc *__restrict__ const func,
2088 	struct svar *__restrict__ const ret,
2089 	void *__restrict__ const usrptr,
2090 	wti_t *const pWti __attribute__((unused)))
2091 {
2092 	struct funcData_prifilt *pPrifilt;
2093 	pPrifilt = (struct funcData_prifilt*) func-&gt;funcdata;
2094 	if( (pPrifilt-&gt;pmask[((smsg_t*)usrptr)-&gt;iFacility] == TABLE_NOPRI) ||
2095 	   ((pPrifilt-&gt;pmask[((smsg_t*)usrptr)-&gt;iFacility]
2096 		    &amp; (1&lt;&lt;((smsg_t*)usrptr)-&gt;iSeverity)) == 0) )
2097 		ret-&gt;d.n = 0;
2098 	else
2099 		ret-&gt;d.n = 1;
2100 	ret-&gt;datatype = 'N';
2101 }
2102 static void ATTR_NONNULL()
2103 doFunct_Lookup(struct cnffunc *__restrict__ const func,
2104 	struct svar *__restrict__ const ret,
2105 	void *__restrict__ const usrptr,
2106 	wti_t *__restrict__ const pWti)
2107 {
2108 	struct svar srcVal;
2109 	lookup_key_t key;
2110 	uint8_t lookup_key_type;
2111 	lookup_ref_t *lookup_table_ref;
2112 	lookup_t *lookup_table;
2113 	int bMustFree;
2114 	ret-&gt;datatype = 'S';
2115 	if(func-&gt;funcdata == NULL) {
2116 		ret-&gt;d.estr = es_newStrFromCStr("TABLE-NOT-FOUND", sizeof("TABLE-NOT-FOUND")-1);
2117 		return;
2118 	}
2119 	cnfexprEval(func-&gt;expr[1], &amp;srcVal, usrptr, pWti);
2120 	lookup_table_ref = (lookup_ref_t*) func-&gt;funcdata;
2121 	pthread_rwlock_rdlock(&amp;lookup_table_ref-&gt;rwlock);
2122 	lookup_table = lookup_table_ref-&gt;self;
2123 	if (lookup_table != NULL) {
2124 		lookup_key_type = lookup_table-&gt;key_type;
2125 		bMustFree = 0;
2126 		if (lookup_key_type == LOOKUP_KEY_TYPE_STRING) {
2127 			key.k_str = (uchar*) var2CString(&amp;srcVal, &amp;bMustFree);
2128 		} else if (lookup_key_type == LOOKUP_KEY_TYPE_UINT) {
2129 			key.k_uint = var2Number(&amp;srcVal, NULL);
2130 		} else {
2131 			DBGPRINTF("program error in %s:%d: lookup_key_type unknown\n",
2132 				__FILE__, __LINE__);
2133 			key.k_uint = 0;
2134 		}
2135 		ret-&gt;d.estr = lookupKey((lookup_ref_t*)func-&gt;funcdata, key);
2136 		if(bMustFree) {
2137 			free(key.k_str);
2138 		}
2139 	} else {
2140 		ret-&gt;d.estr = es_newStrFromCStr("", 1);
2141 	}
2142 	pthread_rwlock_unlock(&amp;lookup_table_ref-&gt;rwlock);
2143 	varFreeMembers(&amp;srcVal);
2144 }
2145 static void ATTR_NONNULL()
2146 doFunct_DynInc(struct cnffunc *__restrict__ const func,
2147 	struct svar *__restrict__ const ret,
2148 	void *__restrict__ const usrptr,
2149 	wti_t *__restrict__ const pWti)
2150 {
2151 	struct svar srcVal;
2152 	int bMustFree;
2153 	char *str;
2154 	ret-&gt;datatype = 'N';
2155 	if(func-&gt;funcdata == NULL) {
2156 		ret-&gt;d.n = -1;
2157 		return;
2158 	}
2159 	cnfexprEval(func-&gt;expr[1], &amp;srcVal, usrptr, pWti);
2160 	str = (char*) var2CString(&amp;srcVal, &amp;bMustFree);
2161 	ret-&gt;d.n = dynstats_inc(func-&gt;funcdata, (uchar*)str);
2162 	if(bMustFree) free(str);
2163 	varFreeMembers(&amp;srcVal);
2164 }
2165 static void ATTR_NONNULL()
2166 doFunct_FormatTime(struct cnffunc *__restrict__ const func,
2167 	struct svar *__restrict__ const ret,
2168 	void *__restrict__ const usrptr,
2169 	wti_t *__restrict__ const pWti)
2170 {
2171 	struct svar srcVal[2];
2172 	int bMustFree;
2173 	char *str;
2174 	int retval;
2175 	long long unixtime;
2176 	const int resMax = 64;
2177 	char   result[resMax];
2178 	char  *formatstr = NULL;
2179 	cnfexprEval(func-&gt;expr[0], &amp;srcVal[0], usrptr, pWti);
2180 	cnfexprEval(func-&gt;expr[1], &amp;srcVal[1], usrptr, pWti);
2181 	unixtime = var2Number(&amp;srcVal[0], &amp;retval);
2182 	if (sizeof(time_t) == sizeof(int)) {
2183 		if (unixtime &lt; INT_MIN || unixtime &gt; INT_MAX) {
2184 			LogMsg(
2185 				0, RS_RET_VAL_OUT_OF_RANGE, LOG_WARNING,
2186 				"Timestamp value %lld is out of range for this system (time_t is "
2187 				"32bits)!\n", unixtime
2188 			);
2189 			retval = 0;
2190 		}
2191 	}
2192 	str = (char*) var2CString(&amp;srcVal[0], &amp;bMustFree);
2193 	formatstr = (char*) es_str2cstr(srcVal[1].d.estr, NULL);
2194 	ret-&gt;datatype = 'S';
2195 	if (objUse(datetime, CORE_COMPONENT) != RS_RET_OK) {
2196 		ret-&gt;d.estr = es_newStr(0);
2197 	} else {
2198 		if (!retval || datetime.formatUnixTimeFromTime_t(unixtime, formatstr, result, resMax) == -1) {
2199 			strncpy(result, str, resMax);
2200 			result[resMax - 1] = '\0';
2201 		}
2202 		ret-&gt;d.estr = es_newStrFromCStr(result, strlen(result));
2203 	}
2204 	if (bMustFree) {
2205 		free(str);
2206 	}
2207 	free(formatstr);
2208 	varFreeMembers(&amp;srcVal[0]);
2209 	varFreeMembers(&amp;srcVal[1]);
2210 }
2211 static int
2212 estimateYear(int cy, int cm, int im) {
2213 	im += 12;
2214 	if ((im - cm) == 1) {
2215 		if (cm == 12 &amp;&amp; im == 13)
2216 			return cy + 1;
2217 	}
2218 	if ((im - cm) &gt; 13)
2219 		return cy - 1;
2220 	return cy;
2221 }
2222 static void ATTR_NONNULL()
2223 doFunct_ParseTime(struct cnffunc *__restrict__ const func,
2224 	struct svar *__restrict__ const ret,
2225 	void *__restrict__ const usrptr,
2226 	wti_t *__restrict__ const pWti)
2227 {
2228 	struct svar srcVal;
2229 	int bMustFree;
2230 	cnfexprEval(func-&gt;expr[0], &amp;srcVal, usrptr, pWti);
2231 	char *str = (char*) var2CString(&amp;srcVal, &amp;bMustFree);
2232 	ret-&gt;datatype = 'N';
2233 	ret-&gt;d.n = 0;
2234 	wtiSetScriptErrno(pWti, RS_SCRIPT_EOK);
2235 	if (objUse(datetime, CORE_COMPONENT) == RS_RET_OK) {
2236 		struct syslogTime s;
2237 		int len = strlen(str);
2238 		uchar *pszTS = (uchar*) str;
2239 		memset(&amp;s, 0, sizeof(struct syslogTime));
2240 		if (datetime.ParseTIMESTAMP3339(&amp;s, (uchar**) &amp;pszTS, &amp;len) == RS_RET_OK) {
2241 			ret-&gt;d.n = datetime.syslogTime2time_t(&amp;s);
2242 			DBGPRINTF("parse_time: RFC3339 format found\n");
2243 		} else if (datetime.ParseTIMESTAMP3164(&amp;s, (uchar**) &amp;pszTS, &amp;len,
2244 			NO_PARSE3164_TZSTRING, NO_PERMIT_YEAR_AFTER_TIME) == RS_RET_OK) {
2245 			time_t t = time(NULL);
2246 			struct tm tm;
2247 			gmtime_r(&amp;t, &amp;tm); 			s.year = estimateYear(tm.tm_year + 1900, tm.tm_mon + 1, s.month);
2248 			ret-&gt;d.n = datetime.syslogTime2time_t(&amp;s);
2249 			DBGPRINTF("parse_time: RFC3164 format found\n");
2250 		} else {
2251 			DBGPRINTF("parse_time: no valid format found\n");
2252 			wtiSetScriptErrno(pWti, RS_SCRIPT_EINVAL);
2253 		}
2254 	}
2255 	if(bMustFree) {
2256 		free(str);
2257 	}
2258 	varFreeMembers(&amp;srcVal);
2259 }
2260 static int ATTR_NONNULL(1,3,4)
2261 doFunc_is_time(const char *__restrict__ const str,
2262 	const char *__restrict__ const fmt,
2263 	struct svar *__restrict__ const r,
2264 	wti_t *pWti) {
2265 	assert(str != NULL);
2266 	assert(r != NULL);
2267 	assert(pWti != NULL);
2268 	int ret = 0;
2269 	wtiSetScriptErrno(pWti, RS_SCRIPT_EOK);
2270 	if (objUse(datetime, CORE_COMPONENT) == RS_RET_OK) {
2271 		struct syslogTime s;
2272 		int len = strlen(str);
2273 		uchar *pszTS = (uchar*) str;
2274 		int numFormats  = 3;
2275 		dateTimeFormat_t formats[] = { DATE_RFC3164, DATE_RFC3339, DATE_UNIX };
2276 		dateTimeFormat_t pf[] = { DATE_INVALID };
2277 		dateTimeFormat_t *p  = formats;
2278 		if (fmt != NULL) {
2279 			numFormats = 1;
2280 			*pf = getDateTimeFormatFromStr(fmt);
2281 			p = pf;
2282 		}
2283 		for (int i = 0; i &lt; numFormats; i++) {
2284 			dateTimeFormat_t f = p[i];
2285 			if (f == DATE_RFC3339) {
2286 				if (datetime.ParseTIMESTAMP3339(&amp;s, (uchar**) &amp;pszTS, &amp;len) == RS_RET_OK) {
2287 					DBGPRINTF("is_time: RFC3339 format found.\n");
2288 					ret = 1;
2289 					break;
2290 				}
2291 			} else if (f == DATE_RFC3164) {
2292 				if (datetime.ParseTIMESTAMP3164(&amp;s, (uchar**) &amp;pszTS, &amp;len,
2293 					NO_PARSE3164_TZSTRING, NO_PERMIT_YEAR_AFTER_TIME) == RS_RET_OK) {
2294 					DBGPRINTF("is_time: RFC3164 format found.\n");
2295 					ret = 1;
2296 					break;
2297 				}
2298 			} else if (f == DATE_UNIX) {
2299 				int result;
2300 				var2Number(r, &amp;result);
2301 				if (result) {
2302 					DBGPRINTF("is_time: UNIX format found.\n");
2303 					ret = 1;
2304 					break;
2305 				}
2306 			} else {
2307 				DBGPRINTF("is_time: %s is not a valid date/time format specifier!\n", fmt);
2308 				break;
2309 			}
2310 		}
2311 	}
2312 	if (ret == 0) {
2313 		DBGPRINTF("is_time: Invalid date-time string: %s.\n", str);
2314 		wtiSetScriptErrno(pWti, RS_SCRIPT_EINVAL);
2315 	}
2316 	return ret;
2317 }
2318 static void ATTR_NONNULL()
2319 doFunct_IsTime(struct cnffunc *__restrict__ const func,
2320 	struct svar *__restrict__ const ret,
2321 	void *__restrict__ const usrptr,
2322 	wti_t *__restrict__ const pWti)
2323 {
2324 	struct svar srcVal[2];
2325 	int bMustFree;
2326 	int bMustFree2;
2327 	char *fmt = NULL;
2328 	cnfexprEval(func-&gt;expr[0], &amp;srcVal[0], usrptr, pWti);
2329 	char *str = (char*) var2CString(&amp;srcVal[0], &amp;bMustFree);
2330 	bMustFree2 = 0;
2331 	if(func-&gt;nParams == 2) {
2332 		cnfexprEval(func-&gt;expr[1], &amp;srcVal[1], usrptr, pWti);
2333 		fmt = (char*) var2CString(&amp;srcVal[1], &amp;bMustFree2);
2334 	}
2335 	ret-&gt;datatype = 'N';
2336 	ret-&gt;d.n = doFunc_is_time(str, fmt, &amp;srcVal[0], pWti);
2337 	if(bMustFree) {
2338 		free(str);
2339 	}
2340 	if(bMustFree2) {
2341 		free(fmt);
2342 	}
2343 	varFreeMembers(&amp;srcVal[0]);
2344 	if(func-&gt;nParams == 2) {
2345 		varFreeMembers(&amp;srcVal[1]);
2346 	}
2347 }
2348 static void ATTR_NONNULL()
2349 doFunct_ScriptError(struct cnffunc *const func __attribute__((unused)),
2350 	struct svar *__restrict__ const ret,
2351 	void *const usrptr __attribute__((unused)),
2352 	wti_t *__restrict__ const pWti)
2353 {
2354 	ret-&gt;datatype = 'N';
2355 	ret-&gt;d.n = wtiGetScriptErrno(pWti);
2356 	DBGPRINTF("script_error() is %d\n", (int) ret-&gt;d.n);
2357 }
2358 static void ATTR_NONNULL()
2359 doFunct_PreviousActionSuspended(struct cnffunc *const func __attribute__((unused)),
2360 	struct svar *__restrict__ const ret,
2361 	void *const usrptr __attribute__((unused)),
2362 	wti_t *__restrict__ const pWti)
2363 {
2364 	ret-&gt;datatype = 'N';
2365 	ret-&gt;d.n = wtiGetPrevWasSuspended(pWti);
2366 	DBGPRINTF("previous_action_suspended() is %d\n", (int) ret-&gt;d.n);
2367 }
2368 static void ATTR_NONNULL()
2369 doFunct_num2ipv4(struct cnffunc *__restrict__ const func,
2370 	struct svar *__restrict__ const ret,
2371 	void *__restrict__ const usrptr,
2372 	wti_t *__restrict__ const pWti)
2373 {
2374 	struct svar srcVal;
2375 	cnfexprEval(func-&gt;expr[0], &amp;srcVal, usrptr, pWti);
2376 	int success = 0;
2377 	long long num = var2Number(&amp;srcVal, &amp;success);
2378 	varFreeMembers(&amp;srcVal);
2379 	int numip[4];
2380 	char str[16];
2381 	size_t len;
2382 	DBGPRINTF("rainrescript: (num2ipv4) var2Number output: '%lld\n'", num);
2383 	if (! success) {
2384 		DBGPRINTF("rainerscript: (num2ipv4) couldn't access number\n");
2385 		len = snprintf(str, 16, "-1");
2386 		goto done;
2387 	}
2388 	if(num &lt; 0 || num &gt; 4294967295) {
2389 		DBGPRINTF("rainerscript: (num2ipv4) invalid number(too big/negative); does "
2390 			"not represent IPv4 address\n");
2391 		len = snprintf(str, 16, "-1");
2392 		goto done;
2393 	}
2394 	for(int i = 0 ; i &lt; 4 ; i++){
2395 		numip[i] = num % 256;
2396 		num = num / 256;
2397 	}
2398 	DBGPRINTF("rainerscript: (num2ipv4) Numbers: 1:'%d' 2:'%d' 3:'%d' 4:'%d'\n",
2399 		numip[0], numip[1], numip[2], numip[3]);
2400 	len = snprintf(str, 16, "%d.%d.%d.%d", numip[3], numip[2], numip[1], numip[0]);
2401 done:
2402 	DBGPRINTF("rainerscript: (num2ipv4) ipv4-Address: %s, length: %zu\n", str, len);
2403 	ret-&gt;d.estr = es_newStrFromCStr(str, len);
2404 	ret-&gt;datatype = 'S';
2405 }
2406 static void ATTR_NONNULL()
2407 doFuncCall(struct cnffunc *__restrict__ const func, struct svar *__restrict__ const ret,
2408 	void *__restrict__ const usrptr,
2409 	wti_t *__restrict__ const pWti)
2410 {
2411 	if(Debug) {
2412 		char *fname = es_str2cstr(func-&gt;fname, NULL);
2413 		DBGPRINTF("rainerscript: executing function id %s\n", fname);
2414 		free(fname);
2415 	}
2416 	if(func-&gt;fPtr == NULL) {
2417 		char *fname = es_str2cstr(func-&gt;fname, NULL);
2418 		LogError(0, RS_RET_INTERNAL_ERROR,
2419 			"rainerscript: internal error: NULL pointer for function named '%s'\n",
2420 			fname);
2421 		free(fname);
2422 		ret-&gt;datatype = 'N';
2423 		ret-&gt;d.n = 0;
2424 	} else {
2425 		func-&gt;fPtr(func, ret, usrptr, pWti);
2426 	}
2427 }
2428 static int ATTR_NONNULL()
2429 evalFuncExists(struct cnffuncexists *__restrict__ const fexists, void *__restrict__ const usrptr)
2430 {
2431 	int r = 0;
2432 	rsRetVal localRet;
2433 	if(fexists-&gt;prop.id == PROP_CEE        ||
2434 	   fexists-&gt;prop.id == PROP_LOCAL_VAR  ||
2435 	   fexists-&gt;prop.id == PROP_GLOBAL_VAR   ) {
2436 		localRet = msgCheckVarExists((smsg_t*)usrptr, &amp;fexists-&gt;prop);
2437 		if(localRet == RS_RET_OK) {
2438 			r = 1;
2439 		}
2440 	}
2441 	return r;
2442 }
2443 static void
2444 evalVar(struct cnfvar *__restrict__ const var, void *__restrict__ const usrptr,
2445 	struct svar *__restrict__ const ret)
2446 {
2447 	rs_size_t propLen;
2448 	uchar *pszProp = NULL;
2449 	unsigned short bMustBeFreed = 0;
2450 	rsRetVal localRet;
2451 	struct json_object *json;
2452 	uchar *cstr;
2453 	if(var-&gt;prop.id == PROP_CEE        ||
2454 	   var-&gt;prop.id == PROP_LOCAL_VAR  ||
2455 	   var-&gt;prop.id == PROP_GLOBAL_VAR   ) {
2456 		localRet = msgGetJSONPropJSONorString((smsg_t*)usrptr, &amp;var-&gt;prop, &amp;json, &amp;cstr);
2457 		if(json != NULL) {
2458 			assert(cstr == NULL);
2459 			ret-&gt;datatype = 'J';
2460 			ret-&gt;d.json = (localRet == RS_RET_OK) ? json : NULL;
2461 			DBGPRINTF("rainerscript: (json) var %d:%s: '%s'\n",
2462 				var-&gt;prop.id, var-&gt;prop.name,
2463 			  (ret-&gt;d.json == NULL) ? "" : json_object_get_string(ret-&gt;d.json));
2464 		} else { 			DBGPRINTF("rainerscript: (json/string) var %d: '%s'\n", var-&gt;prop.id, cstr);
2465 			ret-&gt;datatype = 'S';
2466 			ret-&gt;d.estr = (localRet != RS_RET_OK || cstr == NULL) ?
2467 					  es_newStr(1)
2468 					: es_newStrFromCStr((char*) cstr, strlen((char*) cstr));
2469 			free(cstr);
2470 		}
2471 	} else {
2472 		ret-&gt;datatype = 'S';
2473 		pszProp = (uchar*) MsgGetProp((smsg_t*)usrptr, NULL, &amp;var-&gt;prop, &amp;propLen, &amp;bMustBeFreed, NULL);
2474 		ret-&gt;d.estr = es_newStrFromCStr((char*)pszProp, propLen);
2475 		DBGPRINTF("rainerscript: (string) var %d: '%s'\n", var-&gt;prop.id, pszProp);
2476 		if(bMustBeFreed)
2477 			free(pszProp);
2478 	}
2479 }
2480 static int
2481 evalStrArrayCmp(es_str_t *const estr_l,
2482 		const struct cnfarray *__restrict__ const ar,
2483 		const int cmpop)
2484 {
2485 	int i;
2486 	int r = 0;
2487 	es_str_t **res;
2488 	if(cmpop == CMP_EQ) {
2489 		res = bsearch(&amp;estr_l, ar-&gt;arr, ar-&gt;nmemb, sizeof(es_str_t*), qs_arrcmp);
2490 		r = res != NULL;
2491 	} else if(cmpop == CMP_NE) {
2492 		res = bsearch(&amp;estr_l, ar-&gt;arr, ar-&gt;nmemb, sizeof(es_str_t*), qs_arrcmp);
2493 		r = res == NULL;
2494 	} else {
2495 		for(i = 0 ; (r == 0) &amp;&amp; (i &lt; ar-&gt;nmemb) ; ++i) {
2496 			switch(cmpop) {
2497 			case CMP_STARTSWITH:
2498 				r = es_strncmp(estr_l, ar-&gt;arr[i], es_strlen(ar-&gt;arr[i])) == 0;
2499 				break;
2500 			case CMP_STARTSWITHI:
2501 				r = es_strncasecmp(estr_l, ar-&gt;arr[i], es_strlen(ar-&gt;arr[i])) == 0;
2502 				break;
2503 			case CMP_CONTAINS:
2504 				r = es_strContains(estr_l, ar-&gt;arr[i]) != -1;
2505 				break;
2506 			case CMP_CONTAINSI:
2507 				r = es_strCaseContains(estr_l, ar-&gt;arr[i]) != -1;
2508 				break;
2509 			}
2510 		}
2511 	}
2512 	return r;
2513 }
2514 #define FREE_BOTH_RET \
2515 		varFreeMembers(&amp;r); \
2516 		varFreeMembers(&amp;l)
2517 #define COMP_NUM_BINOP(x) \
2518 	cnfexprEval(expr-&gt;l, &amp;l, usrptr, pWti); \
2519 	cnfexprEval(expr-&gt;r, &amp;r, usrptr, pWti); \
2520 	ret-&gt;datatype = 'N'; \
2521 	ret-&gt;d.n = var2Number(&amp;l, &amp;convok_l) x var2Number(&amp;r, &amp;convok_r); \
2522 	FREE_BOTH_RET
2523 #define COMP_NUM_BINOP_DIV(x) \
2524 	cnfexprEval(expr-&gt;l, &amp;l, usrptr, pWti); \
2525 	cnfexprEval(expr-&gt;r, &amp;r, usrptr, pWti); \
2526 	ret-&gt;datatype = 'N'; \
2527 	if((ret-&gt;d.n = var2Number(&amp;r, &amp;convok_r)) == 0) { \
2528 	} else { \
2529 		ret-&gt;d.n = var2Number(&amp;l, &amp;convok_l) x ret-&gt;d.n; \
2530 	} \
2531 	FREE_BOTH_RET
2532 #define PREP_TWO_STRINGS \
2533 		cnfexprEval(expr-&gt;l, &amp;l, usrptr, pWti); \
2534 		estr_l = var2String(&amp;l, &amp;bMustFree2); \
2535 		if(expr-&gt;r-&gt;nodetype == 'S') { \
2536 			estr_r = ((struct cnfstringval*)expr-&gt;r)-&gt;estr;\
2537 			bMustFree = 0; \
2538 		} else if(expr-&gt;r-&gt;nodetype != 'A') { \
2539 			cnfexprEval(expr-&gt;r, &amp;r, usrptr, pWti); \
2540 			estr_r = var2String(&amp;r, &amp;bMustFree); \
2541 		} else { \
2542 			estr_r = NULL; \
2543 		}
2544 #define FREE_TWO_STRINGS \
2545 		if(bMustFree) es_deleteStr(estr_r);  \
2546 		if(expr-&gt;r-&gt;nodetype != 'S' &amp;&amp; expr-&gt;r-&gt;nodetype != 'A') varFreeMembers(&amp;r); \
2547 		if(bMustFree2) es_deleteStr(estr_l);  \
2548 		varFreeMembers(&amp;l)
2549 static int eval_strcmp_like(const struct cnfexpr *__restrict__ const expr,
2550 	void *__restrict__ const usrptr,
2551 	wti_t *__restrict__ const pWti)
2552 {
2553 	es_str_t *__restrict__ estr_r, *__restrict__ estr_l;
2554 	int bMustFree, bMustFree2;
2555 	int64_t n_r, n_l;
2556 	int convok_r, convok_l;
2557 	struct svar r, l; 	int ret;
2558 	cnfexprEval(expr-&gt;l, &amp;l, usrptr, pWti);
2559 	cnfexprEval(expr-&gt;r, &amp;r, usrptr, pWti);
2560 	n_l = var2Number(&amp;l, &amp;convok_l);
2561 	if(convok_l) {
2562 		n_r = var2Number(&amp;r, &amp;convok_r);
2563 	}
2564 	if(convok_l &amp;&amp; convok_r) {
2565 		ret = n_l - n_r;
2566 	} else {
2567 		estr_l = var2String(&amp;l, &amp;bMustFree);
2568 		estr_r = var2String(&amp;r, &amp;bMustFree2);
2569 		ret = es_strcmp(estr_l, estr_r);
2570 		if(bMustFree) es_deleteStr(estr_l);
2571 		if(bMustFree2) es_deleteStr(estr_r);
2572 	}
2573 	FREE_BOTH_RET;
2574 	return ret;
2575 }
2576 void ATTR_NONNULL()
2577 cnfexprEval(const struct cnfexpr *__restrict__ const expr,
2578 	struct svar *__restrict__ const ret,
2579 	void *__restrict__ const usrptr,
2580 	wti_t *__restrict__ const pWti)
2581 {
2582 	struct svar r, l; 	es_str_t *__restrict__ estr_r, *__restrict__ estr_l;
2583 	int convok_r, convok_l;
2584 	int bMustFree, bMustFree2;
2585 	long long n_r, n_l;
2586 	DBGPRINTF("eval expr %p, type '%s'\n", expr, tokenToString(expr-&gt;nodetype));
2587 	switch(expr-&gt;nodetype) {
2588 	case CMP_EQ:
2589 		cnfexprEval(expr-&gt;l, &amp;l, usrptr, pWti);
2590 		ret-&gt;datatype = 'N';
2591 		if(l.datatype == 'S') {
2592 			if(expr-&gt;r-&gt;nodetype == 'S') {
2593 			} else if(expr-&gt;r-&gt;nodetype == 'A') {
2594 				ret-&gt;d.n = evalStrArrayCmp(l.d.estr,  (struct cnfarray*) expr-&gt;r, CMP_EQ);
2595 			} else {
2596 				cnfexprEval(expr-&gt;r, &amp;r, usrptr, pWti);
2597 				if(r.datatype == 'S') {
2598 				} else {
2599 					n_l = var2Number(&amp;l, &amp;convok_l);
2600 					if(convok_l) {
2601 					} else {
2602 						estr_r = var2String(&amp;r, &amp;bMustFree);
2603 						if(bMustFree) es_deleteStr(estr_r);
2604 					}
2605 				}
2606 				varFreeMembers(&amp;r);
2607 			}
2608 		} else if(l.datatype == 'J') {
2609 			estr_l = var2String(&amp;l, &amp;bMustFree);
2610 			if(expr-&gt;r-&gt;nodetype == 'S') {
2611 			} else if(expr-&gt;r-&gt;nodetype == 'A') {
2612 				ret-&gt;d.n = evalStrArrayCmp(estr_l,  (struct cnfarray*) expr-&gt;r, CMP_EQ);
2613 			} else {
2614 				cnfexprEval(expr-&gt;r, &amp;r, usrptr, pWti);
2615 				if(r.datatype == 'S') {
2616 				} else {
2617 					n_l = var2Number(&amp;l, &amp;convok_l);
2618 					if(convok_l) {
2619 					} else {
2620 						estr_r = var2String(&amp;r, &amp;bMustFree2);
2621 						if(bMustFree2) es_deleteStr(estr_r);
2622 					}
2623 				}
2624 				varFreeMembers(&amp;r);
2625 			}
2626 			if(bMustFree) es_deleteStr(estr_l);
2627 		} else {
2628 			cnfexprEval(expr-&gt;r, &amp;r, usrptr, pWti);
2629 			if(r.datatype == 'S') {
2630 				n_r = var2Number(&amp;r, &amp;convok_r);
2631 				if(convok_r) {
2632 				} else {
2633 					estr_l = var2String(&amp;l, &amp;bMustFree);
2634 					if(bMustFree) es_deleteStr(estr_l);
2635 				}
2636 			} else {
2637 			}
2638 			varFreeMembers(&amp;r);
2639 		}
2640 		varFreeMembers(&amp;l);
2641 		break;
2642 	case CMP_NE:
2643 		cnfexprEval(expr-&gt;l, &amp;l, usrptr, pWti);
2644 		cnfexprEval(expr-&gt;r, &amp;r, usrptr, pWti);
2645 		ret-&gt;datatype = 'N';
2646 		if(l.datatype == 'S') {
2647 			if(expr-&gt;r-&gt;nodetype == 'S') {
2648 			} else if(expr-&gt;r-&gt;nodetype == 'A') {
2649 				ret-&gt;d.n = evalStrArrayCmp(l.d.estr,  (struct cnfarray*) expr-&gt;r, CMP_NE);
2650 			} else {
2651 				if(r.datatype == 'S') {
2652 				} else {
2653 					n_l = var2Number(&amp;l, &amp;convok_l);
2654 					if(convok_l) {
2655 					} else {
2656 						estr_r = var2String(&amp;r, &amp;bMustFree);
2657 						if(bMustFree) es_deleteStr(estr_r);
2658 					}
2659 				}
2660 			}
2661 		} else if(l.datatype == 'J') {
2662 			estr_l = var2String(&amp;l, &amp;bMustFree);
2663 			if(r.datatype == 'S') {
2664 			} else {
2665 				n_l = var2Number(&amp;l, &amp;convok_l);
2666 				if(convok_l) {
2667 				} else {
2668 					estr_r = var2String(&amp;r, &amp;bMustFree2);
2669 					if(bMustFree2) es_deleteStr(estr_r);
2670 				}
2671 			}
2672 			if(bMustFree) es_deleteStr(estr_l);
2673 		} else {
2674 			if(r.datatype == 'S') {
2675 				n_r = var2Number(&amp;r, &amp;convok_r);
2676 				if(convok_r) {
2677 				} else {
2678 					estr_l = var2String(&amp;l, &amp;bMustFree);
2679 					if(bMustFree) es_deleteStr(estr_l);
2680 				}
2681 			} else {
2682 			}
2683 		}
2684 		FREE_BOTH_RET;
2685 		break;
2686 	case CMP_LE:
2687 		ret-&gt;datatype = 'N';
2688 		ret-&gt;d.n = eval_strcmp_like(expr, usrptr, pWti) &lt;= 0;
2689 		break;
2690 	case CMP_GE:
2691 		ret-&gt;datatype = 'N';
2692 		ret-&gt;d.n = eval_strcmp_like(expr, usrptr, pWti) &gt;= 0;
2693 		break;
2694 	case CMP_LT:
2695 		ret-&gt;datatype = 'N';
2696 		ret-&gt;d.n = eval_strcmp_like(expr, usrptr, pWti) &lt; 0;
2697 		break;
2698 	case CMP_GT:
2699 		ret-&gt;datatype = 'N';
2700 		ret-&gt;d.n = eval_strcmp_like(expr, usrptr, pWti) &gt; 0;
2701 		break;
2702 	case CMP_STARTSWITH:
2703 		PREP_TWO_STRINGS;
2704 		ret-&gt;datatype = 'N';
2705 		if(expr-&gt;r-&gt;nodetype == 'A') {
2706 			ret-&gt;d.n = evalStrArrayCmp(estr_l,  (struct cnfarray*) expr-&gt;r, CMP_STARTSWITH);
2707 			bMustFree = 0;
2708 		} else {
2709 			ret-&gt;d.n = es_strncmp(estr_l, estr_r, estr_r-&gt;lenStr) == 0;
2710 		}
2711 		FREE_TWO_STRINGS;
2712 		break;
2713 	case CMP_STARTSWITHI:
2714 		PREP_TWO_STRINGS;
2715 		ret-&gt;datatype = 'N';
2716 		if(expr-&gt;r-&gt;nodetype == 'A') {
2717 			ret-&gt;d.n = evalStrArrayCmp(estr_l,  (struct cnfarray*) expr-&gt;r, CMP_STARTSWITHI);
2718 			bMustFree = 0;
2719 		} else {
2720 			ret-&gt;d.n = es_strncasecmp(estr_l, estr_r, estr_r-&gt;lenStr) == 0;
2721 		}
2722 		FREE_TWO_STRINGS;
2723 		break;
2724 	case CMP_CONTAINS:
2725 		PREP_TWO_STRINGS;
2726 		ret-&gt;datatype = 'N';
2727 		if(expr-&gt;r-&gt;nodetype == 'A') {
2728 			ret-&gt;d.n = evalStrArrayCmp(estr_l,  (struct cnfarray*) expr-&gt;r, CMP_CONTAINS);
2729 			bMustFree = 0;
2730 		} else {
2731 			ret-&gt;d.n = es_strContains(estr_l, estr_r) != -1;
2732 		}
2733 		FREE_TWO_STRINGS;
2734 		break;
2735 	case CMP_CONTAINSI:
2736 		PREP_TWO_STRINGS;
2737 		ret-&gt;datatype = 'N';
2738 		if(expr-&gt;r-&gt;nodetype == 'A') {
2739 			ret-&gt;d.n = evalStrArrayCmp(estr_l,  (struct cnfarray*) expr-&gt;r, CMP_CONTAINSI);
2740 			bMustFree = 0;
2741 		} else {
2742 			ret-&gt;d.n = es_strCaseContains(estr_l, estr_r) != -1;
2743 		}
2744 		FREE_TWO_STRINGS;
2745 		break;
2746 	case OR:
2747 		cnfexprEval(expr-&gt;l, &amp;l, usrptr, pWti);
2748 		ret-&gt;datatype = 'N';
2749 		if(var2Number(&amp;l, &amp;convok_l)) {
2750 			ret-&gt;d.n = 1ll;
2751 		} else {
2752 			cnfexprEval(expr-&gt;r, &amp;r, usrptr, pWti);
2753 			if(var2Number(&amp;r, &amp;convok_r))
2754 				ret-&gt;d.n = 1ll;
2755 			else
2756 				ret-&gt;d.n = 0ll;
2757 			varFreeMembers(&amp;r);
2758 		}
2759 		varFreeMembers(&amp;l);
2760 		break;
2761 	case AND:
2762 		cnfexprEval(expr-&gt;l, &amp;l, usrptr, pWti);
2763 		ret-&gt;datatype = 'N';
2764 		if(var2Number(&amp;l, &amp;convok_l)) {
2765 			cnfexprEval(expr-&gt;r, &amp;r, usrptr, pWti);
2766 			if(var2Number(&amp;r, &amp;convok_r))
2767 				ret-&gt;d.n = 1ll;
2768 			else
2769 				ret-&gt;d.n = 0ll;
2770 			varFreeMembers(&amp;r);
2771 		} else {
2772 			ret-&gt;d.n = 0ll;
2773 		}
2774 		varFreeMembers(&amp;l);
2775 		break;
2776 	case NOT:
2777 		cnfexprEval(expr-&gt;r, &amp;r, usrptr, pWti);
2778 		ret-&gt;datatype = 'N';
2779 		ret-&gt;d.n = !var2Number(&amp;r, &amp;convok_r);
2780 		varFreeMembers(&amp;r);
2781 		break;
2782 	case 'N':
2783 		ret-&gt;datatype = 'N';
2784 		ret-&gt;d.n = ((struct cnfnumval*)expr)-&gt;val;
2785 		break;
2786 	case 'S':
2787 		ret-&gt;datatype = 'S';
2788 		ret-&gt;d.estr = es_strdup(((struct cnfstringval*)expr)-&gt;estr);
2789 		break;
2790 	case 'A':
2791 		ret-&gt;datatype = 'S';
2792 		ret-&gt;d.estr = es_strdup(((struct cnfarray*)expr)-&gt;arr[0]);
2793 		break;
2794 	case 'V':
2795 		evalVar((struct cnfvar*)expr, usrptr, ret);
2796 		break;
2797 	case '&amp;':
2798 		PREP_TWO_STRINGS;
2799 		if(expr-&gt;r-&gt;nodetype == 'A') {
2800 			estr_r = ((struct cnfarray*)expr-&gt;r)-&gt;arr[0];
2801 			bMustFree = 0;
2802 		}
2803 		ret-&gt;datatype = 'S';
2804 		ret-&gt;d.estr = es_strdup(estr_l);
2805 		es_addStr(&amp;ret-&gt;d.estr, estr_r);
2806 		FREE_TWO_STRINGS;
2807 		break;
2808 	case '+':
2809 		COMP_NUM_BINOP(+);
2810 		break;
2811 	case '-':
2812 		COMP_NUM_BINOP(-);
2813 		break;
2814 	case '*':
2815 		COMP_NUM_BINOP(*);
2816 		break;
2817 	case '/':
2818 		COMP_NUM_BINOP_DIV(/);
2819 		break;
2820 	case '%':
2821 		COMP_NUM_BINOP_DIV(%);
2822 		break;
2823 	case 'M':
2824 		cnfexprEval(expr-&gt;r, &amp;r, usrptr, pWti);
2825 		ret-&gt;datatype = 'N';
2826 		ret-&gt;d.n = -var2Number(&amp;r, &amp;convok_r);
2827 		varFreeMembers(&amp;r);
2828 		break;
2829 	case 'F':
2830 		doFuncCall((struct cnffunc*) expr, ret, usrptr, pWti);
2831 		break;
2832 	case S_FUNC_EXISTS:
2833 		ret-&gt;datatype = 'N';
2834 		ret-&gt;d.n = evalFuncExists((struct cnffuncexists*) expr, usrptr);
2835 		break;
2836 	default:
2837 		ret-&gt;datatype = 'N';
2838 		ret-&gt;d.n = 0ll;
2839 		DBGPRINTF("eval error: unknown nodetype %u['%c']\n",
2840 			(unsigned) expr-&gt;nodetype, (char) expr-&gt;nodetype);
2841 		assert(0); 		break;
2842 	}
2843 	DBGPRINTF("eval expr %p, return datatype '%c':%d\n", expr, ret-&gt;datatype,
2844 		(ret-&gt;datatype == 'N') ? (int)ret-&gt;d.n: 0);
2845 }
2846 void
2847 cnfarrayContentDestruct(struct cnfarray *ar)
2848 {
2849 	unsigned short i;
2850 	for(i = 0 ; i &lt; ar-&gt;nmemb ; ++i) {
2851 		es_deleteStr(ar-&gt;arr[i]);
2852 	}
2853 	free(ar-&gt;arr);
2854 }
2855 static void
2856 regex_destruct(struct cnffunc *func) {
2857 	if(func-&gt;funcdata != NULL) {
2858 		regexp.regfree(func-&gt;funcdata);
2859 	}
2860 }
2861 static rsRetVal
2862 initFunc_dyn_stats(struct cnffunc *func)
2863 {
2864 	uchar *cstr = NULL;
2865 	DEFiRet;
2866 	func-&gt;destructable_funcdata = 0;
2867 	if(func-&gt;nParams != 2) {
2868 		parser_errmsg("rsyslog logic error in line %d of file %s\n",
2869 					  __LINE__, __FILE__);
2870 		FINALIZE;
2871 	}
2872 	func-&gt;funcdata = NULL;
2873 	if(func-&gt;expr[0]-&gt;nodetype != 'S') {
2874 		parser_errmsg("dyn-stats bucket-name (param 1) of dyn-stats manipulating "
2875 		"functions like dyn_inc must be a constant string");
2876 		FINALIZE;
2877 	}
2878 	cstr = (uchar*)es_str2cstr(((struct cnfstringval*) func-&gt;expr[0])-&gt;estr, NULL);
2879 	if((func-&gt;funcdata = dynstats_findBucket(cstr)) == NULL) {
2880 		parser_errmsg("dyn-stats bucket '%s' not found", cstr);
2881 		FINALIZE;
2882 	}
2883 finalize_it:
2884 	free(cstr);
2885 	RETiRet;
2886 }
2887 static rsRetVal
2888 initFunc_perctile_obs(struct cnffunc *func)
2889 {
2890 	uchar *cstr = NULL;
2891 	DEFiRet;
2892 	func-&gt;destructable_funcdata = 0;
2893 	if (func-&gt;nParams != 3) {
2894 		parser_errmsg("rsyslog logic error in line %d of file %s\n",
2895 					  __LINE__, __FILE__);
2896 		FINALIZE;
2897 	}
2898 	func-&gt;funcdata = NULL;
2899 	if (func-&gt;expr[0]-&gt;nodetype != 'S') {
2900 		parser_errmsg("percentile-stats bucket-name (param 1) of perctile-stats manipulating "
2901 		"functions like percentile_observe must be a constant string");
2902 		FINALIZE;
2903 	}
2904 	cstr = (uchar*) es_str2cstr(((struct cnfstringval*) func-&gt;expr[0])-&gt;estr, NULL);
2905 	if ( (func-&gt;funcdata = perctile_findBucket(cstr)) == NULL) {
2906 		parser_errmsg("perctile-stats bucket '%s' not found", cstr);
2907 		FINALIZE;
2908 	}
2909 finalize_it:
2910 	free(cstr);
2911 	RETiRet;
2912 }
2913 static void ATTR_NONNULL()
2914 doFunc_percentile_obs(struct cnffunc *__restrict__ const func,
2915 	struct svar *__restrict__ const ret,
2916 	void *__restrict__ const usrptr,
2917 	wti_t *__restrict__ const pWti)
2918 {
2919 	uchar *cstr = NULL;
2920 	struct svar srcVal;
2921 	int bMustFree;
2922 	ret-&gt;datatype = 'N';
2923 	if(func-&gt;funcdata == NULL) {
2924 		ret-&gt;d.n = -1;
2925 		return;
2926 	}
2927 	cnfexprEval(func-&gt;expr[1], &amp;srcVal, usrptr, pWti);
2928 	cstr = (uchar*) var2CString(&amp;srcVal, &amp;bMustFree);
2929 	int success = 0;
2930 	struct svar srcVal2;
2931 	long long retVal;
2932 	cnfexprEval(func-&gt;expr[2], &amp;srcVal2, usrptr, pWti);
2933 	long long val = var2Number(&amp;srcVal2, &amp;success);
2934 	if (!success) {
2935 		char *cstr2 = es_str2cstr(srcVal2.d.estr, NULL);
2936 		parser_errmsg("rainerscript: percentile_obs - didn't get a valid number: %s\n", cstr2);
2937 		free(cstr2);
2938 		retVal = 0;
2939 		FINALIZE;
2940 	}
2941 	retVal = perctile_obs(func-&gt;funcdata, cstr, val);
2942 finalize_it:
2943 	if (bMustFree) {
2944 		free(cstr);
2945 	}
2946 	varFreeMembers(&amp;srcVal);
2947 	varFreeMembers(&amp;srcVal2);
2948 	ret-&gt;d.n = retVal;
2949 	ret-&gt;datatype = 'N';
2950 }
2951 static rsRetVal
2952 initFunc_re_match_generic(struct cnffunc *const func, const unsigned flags)
2953 {
2954 	rsRetVal localRet;
2955 	char *regex = NULL;
2956 	regex_t *re;
2957 	DEFiRet;
2958 	if(func-&gt;nParams &lt; 2) {
2959 		parser_errmsg("rsyslog logic error in line %d of file %s\n",
2960 			__LINE__, __FILE__);
2961 		FINALIZE;
2962 	}
2963 	func-&gt;funcdata = NULL;
2964 	if(func-&gt;expr[1]-&gt;nodetype != 'S') {
2965 		parser_errmsg("param 2 of re_match/extract() must be a constant string");
2966 		FINALIZE;
2967 	}
2968 	CHKmalloc(re = malloc(sizeof(regex_t)));
2969 	func-&gt;funcdata = re;
2970 	regex = es_str2cstr(((struct cnfstringval*) func-&gt;expr[1])-&gt;estr, NULL);
2971 	if((localRet = objUse(regexp, LM_REGEXP_FILENAME)) == RS_RET_OK) {
2972 		int errcode;
2973 		if((errcode = regexp.regcomp(re, (char*) regex, REG_EXTENDED | flags)) != 0) {
2974 			char errbuff[512];
2975 			regexp.regerror(errcode, re, errbuff, sizeof(errbuff));
2976 			parser_errmsg("cannot compile regex '%s': %s", regex, errbuff);
2977 			ABORT_FINALIZE(RS_RET_ERR);
2978 		}
2979 	} else { 		parser_errmsg("could not load regex support - regex ignored");
2980 		ABORT_FINALIZE(localRet);
2981 	}
2982 finalize_it:
2983 	free(regex);
2984 	RETiRet;
2985 }
2986 static rsRetVal
2987 initFunc_re_match(struct cnffunc *func)
2988 {
2989 	return initFunc_re_match_generic(func, 0);
2990 }
2991 static rsRetVal
2992 initFunc_re_match_i(struct cnffunc *func)
2993 {
2994 	return initFunc_re_match_generic(func, REG_ICASE);
2995 }
2996 static rsRetVal
2997 initFunc_exec_template(struct cnffunc *func)
2998 {
2999 	char *tplName = NULL;
3000 	DEFiRet;
3001 	func-&gt;destructable_funcdata = 0;
3002 	if(func-&gt;nParams != 1) {
3003 		parser_errmsg("rsyslog logic error in line %d of file %s\n",
3004 			__LINE__, __FILE__);
3005 		FINALIZE;
3006 	}
3007 	if(func-&gt;expr[0]-&gt;nodetype != 'S') {
3008 		parser_errmsg("exec_template(): param 1 must be a constant string");
3009 		FINALIZE;
3010 	}
3011 	tplName = es_str2cstr(((struct cnfstringval*) func-&gt;expr[0])-&gt;estr, NULL);
3012 	func-&gt;funcdata = tplFind(loadConf, tplName, strlen(tplName));
3013 	if(func-&gt;funcdata == NULL) {
3014 		parser_errmsg("exec_template(): template '%s' could not be found", tplName);
3015 		FINALIZE;
3016 	}
3017 finalize_it:
3018 	free(tplName);
3019 	RETiRet;
3020 }
3021 static rsRetVal
3022 initFunc_prifilt(struct cnffunc *func)
3023 {
3024 	struct funcData_prifilt *pData;
3025 	uchar *cstr;
3026 	DEFiRet;
3027 	if(func-&gt;nParams != 1) {
3028 		parser_errmsg("rsyslog logic error in line %d of file %s\n",
3029 			__LINE__, __FILE__);
3030 		FINALIZE;
3031 	}
3032 	func-&gt;funcdata = NULL;
3033 	if(func-&gt;expr[0]-&gt;nodetype != 'S') {
3034 		parser_errmsg("param 1 of prifilt() must be a constant string");
3035 		FINALIZE;
3036 	}
3037 	CHKmalloc(pData = calloc(1, sizeof(struct funcData_prifilt)));
3038 	func-&gt;funcdata = pData;
3039 	cstr = (uchar*)es_str2cstr(((struct cnfstringval*) func-&gt;expr[0])-&gt;estr, NULL);
3040 	CHKiRet(DecodePRIFilter(cstr, pData-&gt;pmask));
3041 	free(cstr);
3042 finalize_it:
3043 	RETiRet;
3044 }
3045 static rsRetVal
3046 resolveLookupTable(struct cnffunc *func)
3047 {
3048 	uchar *cstr = NULL;
3049 	char *fn_name = NULL;
3050 	DEFiRet;
3051 	func-&gt;destructable_funcdata = 0;
3052 		parser_errmsg("rsyslog logic error in line %d of file %s\n",
3053 			__LINE__, __FILE__);
3054 		FINALIZE;
3055 	}
3056 	CHKmalloc(fn_name = es_str2cstr(func-&gt;fname, NULL));
3057 	func-&gt;funcdata = NULL;
3058 	if(func-&gt;expr[0]-&gt;nodetype != 'S') {
3059 		parser_errmsg("table name (param 1) of %s() must be a constant string", fn_name);
3060 		FINALIZE;
3061 	}
3062 	CHKmalloc(cstr = (uchar*)es_str2cstr(((struct cnfstringval*) func-&gt;expr[0])-&gt;estr, NULL));
3063 	if((func-&gt;funcdata = lookupFindTable(cstr)) == NULL) {
3064 		parser_errmsg("lookup table '%s' not found (used in function: %s)", cstr, fn_name);
3065 		FINALIZE;
3066 	}
3067 finalize_it:
3068 	free(cstr);
3069 	free(fn_name);
3070 	RETiRet;
3071 }
3072 struct modListNode {
3073 	int version;
3074 	struct scriptFunct *modFcts;
3075 	struct modListNode *next;
3076 };
3077 static struct modListNode *modListRoot = NULL;
3078 static struct modListNode *modListLast = NULL;
3079 static struct scriptFunct functions[] = {
3080 	{"strlen", 1, 1, doFunct_StrLen, NULL, NULL},
3081 	{"getenv", 1, 1, doFunct_Getenv, NULL, NULL},
3082 	{"num2ipv4", 1, 1, doFunct_num2ipv4, NULL, NULL},
3083 	{"int2hex", 1, 1, doFunct_Int2Hex, NULL, NULL},
3084 	{"substring", 3, 3, doFunct_Substring, NULL, NULL},
3085 	{"ltrim", 1, 1, doFunct_LTrim, NULL, NULL},
3086 	{"rtrim", 1, 1, doFunct_RTrim, NULL, NULL},
3087 	{"tolower", 1, 1, doFunct_ToLower, NULL, NULL},
3088 	{"cstr", 1, 1, doFunct_CStr, NULL, NULL},
3089 	{"cnum", 1, 1, doFunct_CNum, NULL, NULL},
3090 	{"ip42num", 1, 1, doFunct_Ipv42num, NULL, NULL},
3091 	{"ipv42num", 1, 1, doFunct_Ipv42num, NULL, NULL},
3092 	{"re_match", 2, 2, doFunct_ReMatch, initFunc_re_match, regex_destruct},
3093 	{"re_match_i", 2, 2, doFunct_ReMatch, initFunc_re_match_i, regex_destruct},
3094 	{"re_extract", 5, 5, doFunc_re_extract, initFunc_re_match, regex_destruct},
3095 	{"re_extract_i", 5, 5, doFunc_re_extract, initFunc_re_match_i, regex_destruct},
3096 	{"field", 3, 3, doFunct_Field, NULL, NULL},
3097 	{"exec_template", 1, 1, doFunc_exec_template, initFunc_exec_template, NULL},
3098 	{"prifilt", 1, 1, doFunct_Prifilt, initFunc_prifilt, NULL},
3099 	{"lookup", 2, 2, doFunct_Lookup, resolveLookupTable, NULL},
3100 	{"dyn_inc", 2, 2, doFunct_DynInc, initFunc_dyn_stats, NULL},
3101 	{"percentile_observe", 3, 3, doFunc_percentile_obs, initFunc_perctile_obs, NULL},
3102 	{"replace", 3, 3, doFunct_Replace, NULL, NULL},
3103 	{"wrap", 2, 3, doFunct_Wrap, NULL, NULL},
3104 	{"random", 1, 1, doFunct_RandomGen, NULL, NULL},
3105 	{"format_time", 2, 2, doFunct_FormatTime, NULL, NULL},
3106 	{"parse_time", 1, 1, doFunct_ParseTime, NULL, NULL},
3107 	{"is_time", 1, 2, doFunct_IsTime, NULL, NULL},
3108 	{"parse_json", 2, 2, doFunc_parse_json, NULL, NULL},
3109 	{"get_property", 2, 2, doFunc_get_property, NULL, NULL},
3110 	{"script_error", 0, 0, doFunct_ScriptError, NULL, NULL},
3111 	{"previous_action_suspended", 0, 0, doFunct_PreviousActionSuspended, NULL, NULL},
3112 	{NULL, 0, 0, NULL, NULL, NULL} //last element to check end of array
3113 };
3114 static rscriptFuncPtr ATTR_NONNULL()
3115 extractFuncPtr(const struct scriptFunct *const funct, const unsigned int nParams)
3116 {
3117 	rscriptFuncPtr retPtr = NULL;
3118 	if(funct-&gt;minParams == funct-&gt;maxParams) {
3119 		if(nParams == funct-&gt;maxParams) {
3120 			retPtr = funct-&gt;fPtr;
3121 		} else {
3122 			parser_errmsg("number of parameters for %s() must be %hu but is %d.",
3123 				funct-&gt;fname, funct-&gt;maxParams, nParams);
3124 		}
3125 	} else {
3126 		if(nParams &lt; funct-&gt;minParams) {
3127 			parser_errmsg("number of parameters for %s() must be at least %hu but is %d.",
3128 				funct-&gt;fname, funct-&gt;minParams, nParams);
3129 		} else if(nParams &gt; funct-&gt;maxParams) {
3130 			parser_errmsg("number of parameters for %s() must be at most %hu but is %d.",
3131 				funct-&gt;fname, funct-&gt;maxParams, nParams);
3132 		} else {
3133 			retPtr = funct-&gt;fPtr;
3134 		}
3135 	}
3136 	return retPtr;
3137 }
3138 static struct scriptFunct* ATTR_NONNULL()
3139 searchFunctArray(const char *const fname, struct scriptFunct *functArray)
3140 {
3141 	struct scriptFunct *retPtr = NULL;
3142 	int i = 0;
3143 	while(functArray[i].fname != NULL) {
3144 		if(!strcmp(fname, functArray[i].fname)){
3145 			retPtr = functArray + i;
3146 			goto done;
3147 		}
3148 		i++;
3149 	}
3150 done:
3151 	return retPtr;
3152 }
3153 static struct scriptFunct* ATTR_NONNULL()
3154 searchModList(const char *const fname)
3155 {
3156 	struct modListNode *modListCurr = modListRoot;
3157 	struct scriptFunct *foundFunct;
3158 	do {
3159 		foundFunct = searchFunctArray(fname, modListCurr-&gt;modFcts);
3160 		if(foundFunct != NULL) {
3161 			return foundFunct;
3162 		}
3163 		modListCurr = modListCurr-&gt;next;
3164 	} while(modListCurr != NULL);
3165 	return NULL;
3166 }
3167 static void
3168 cnffuncDestruct(struct cnffunc *func)
3169 {
3170 	unsigned short i;
3171 	for(i = 0 ; i &lt; func-&gt;nParams ; ++i) {
3172 		cnfexprDestruct(func-&gt;expr[i]);
3173 	}
3174 	char *cstr = es_str2cstr(func-&gt;fname, NULL);
3175 	struct scriptFunct *foundFunc = searchModList(cstr);
3176 	free(cstr);
3177 	if(foundFunc-&gt;destruct != NULL) {
3178 		foundFunc-&gt;destruct(func);
3179 	}
3180 	if(func-&gt;destructable_funcdata) {
3181 		free(func-&gt;funcdata);
3182 	}
3183 	free(func-&gt;fname);
3184 }
3185 void
3186 cnfexprDestruct(struct cnfexpr *__restrict__ const expr)
3187 {
3188 	if(expr == NULL) {
3189 		DBGPRINTF("cnfexprDestruct got NULL ptr - valid, so doing nothing\n");
3190 		return;
3191 	}
3192 	DBGPRINTF("cnfexprDestruct expr %p, type '%s'\n", expr, tokenToString(expr-&gt;nodetype));
3193 	switch(expr-&gt;nodetype) {
3194 	case CMP_NE:
3195 	case CMP_EQ:
3196 	case CMP_LE:
3197 	case CMP_GE:
3198 	case CMP_LT:
3199 	case CMP_GT:
3200 	case CMP_STARTSWITH:
3201 	case CMP_STARTSWITHI:
3202 	case CMP_CONTAINS:
3203 	case CMP_CONTAINSI:
3204 	case OR:
3205 	case AND:
3206 	case '&amp;':
3207 	case '+':
3208 	case '-':
3209 	case '*':
3210 	case '/':
3211 	case '%': 		cnfexprDestruct(expr-&gt;l);
3212 		cnfexprDestruct(expr-&gt;r);
3213 		break;
3214 	case NOT:
3215 	case 'M': 		cnfexprDestruct(expr-&gt;r);
3216 		break;
3217 	case 'N':
3218 		break;
3219 	case 'S':
3220 		es_deleteStr(((struct cnfstringval*)expr)-&gt;estr);
3221 		break;
3222 	case 'V':
3223 		free(((struct cnfvar*)expr)-&gt;name);
3224 		msgPropDescrDestruct(&amp;(((struct cnfvar*)expr)-&gt;prop));
3225 		break;
3226 	case 'F':
3227 		cnffuncDestruct((struct cnffunc*)expr);
3228 		break;
3229 	case 'A':
3230 		cnfarrayContentDestruct((struct cnfarray*)expr);
3231 		break;
3232 	default:break;
3233 	}
3234 	free(expr);
3235 }
3236 int
3237 cnfexprEvalBool(struct cnfexpr *__restrict__ const expr, void *__restrict__ const usrptr, wti_t *const pWti)
3238 {
3239 	int convok;
3240 	struct svar ret;
3241 	cnfexprEval(expr, &amp;ret, usrptr, pWti);
3242 	int retVal = var2Number(&amp;ret, &amp;convok);
3243 	varFreeMembers(&amp;ret);
3244 	return retVal;
3245 }
3246 struct json_object*
3247 cnfexprEvalCollection(struct cnfexpr *__restrict__ const expr, void *__restrict__ const usrptr, wti_t *const pWti)
3248 {
3249 	struct svar ret;
3250 	void *retptr;
3251 	cnfexprEval(expr, &amp;ret, usrptr, pWti);
3252 	if(ret.datatype == 'J') {
3253 	} else {
3254 		retptr = NULL;
3255 		varFreeMembers(&amp;ret); 	}
3256 	return retptr;
3257 }
3258 static void
3259 doIndent(int indent)
3260 {
3261 	int i;
3262 	for(i = 0 ; i &lt; indent ; ++i)
3263 		dbgprintf("  ");
3264 }
3265 static void
3266 pmaskPrint(uchar *pmask, int indent)
3267 {
3268 	int i;
3269 	doIndent(indent);
3270 	dbgprintf("pmask: ");
3271 	for (i = 0; i &lt;= LOG_NFACILITIES; i++)
3272 		if (pmask[i] == TABLE_NOPRI)
3273 			dbgprintf(" X ");
3274 		else
3275 			dbgprintf("%2X ", pmask[i]);
3276 	dbgprintf("\n");
3277 }
3278 static void
3279 cnfarrayPrint(struct cnfarray *ar, int indent)
3280 {
3281 	int i;
3282 	doIndent(indent); dbgprintf("ARRAY:\n");
3283 	for(i = 0 ; i &lt; ar-&gt;nmemb ; ++i) {
3284 		doIndent(indent+1);
3285 		cstrPrint("string '", ar-&gt;arr[i]);
3286 		dbgprintf("'\n");
3287 	}
3288 }
3289 void
3290 cnfexprPrint(struct cnfexpr *expr, int indent)
3291 {
3292 	struct cnffunc *func;
3293 	char *fname;
3294 	int i;
3295 	switch(expr-&gt;nodetype) {
3296 	case CMP_EQ:
3297 		cnfexprPrint(expr-&gt;l, indent+1);
3298 		doIndent(indent);
3299 		dbgprintf("==\n");
3300 		cnfexprPrint(expr-&gt;r, indent+1);
3301 		break;
3302 	case CMP_NE:
3303 		cnfexprPrint(expr-&gt;l, indent+1);
3304 		doIndent(indent);
3305 		dbgprintf("!=\n");
3306 		cnfexprPrint(expr-&gt;r, indent+1);
3307 		break;
3308 	case CMP_LE:
3309 		cnfexprPrint(expr-&gt;l, indent+1);
3310 		doIndent(indent);
3311 		dbgprintf("&lt;=\n");
3312 		cnfexprPrint(expr-&gt;r, indent+1);
3313 		break;
3314 	case CMP_GE:
3315 		cnfexprPrint(expr-&gt;l, indent+1);
3316 		doIndent(indent);
3317 		dbgprintf("&gt;=\n");
3318 		cnfexprPrint(expr-&gt;r, indent+1);
3319 		break;
3320 	case CMP_LT:
3321 		cnfexprPrint(expr-&gt;l, indent+1);
3322 		doIndent(indent);
3323 		dbgprintf("&lt;\n");
3324 		cnfexprPrint(expr-&gt;r, indent+1);
3325 		break;
3326 	case CMP_GT:
3327 		cnfexprPrint(expr-&gt;l, indent+1);
3328 		doIndent(indent);
3329 		dbgprintf("&gt;\n");
3330 		cnfexprPrint(expr-&gt;r, indent+1);
3331 		break;
3332 	case CMP_CONTAINS:
3333 		cnfexprPrint(expr-&gt;l, indent+1);
3334 		doIndent(indent);
3335 		dbgprintf("CONTAINS\n");
3336 		cnfexprPrint(expr-&gt;r, indent+1);
3337 		break;
3338 	case CMP_CONTAINSI:
3339 		cnfexprPrint(expr-&gt;l, indent+1);
3340 		doIndent(indent);
3341 		dbgprintf("CONTAINS_I\n");
3342 		cnfexprPrint(expr-&gt;r, indent+1);
3343 		break;
3344 	case CMP_STARTSWITH:
3345 		cnfexprPrint(expr-&gt;l, indent+1);
3346 		doIndent(indent);
3347 		dbgprintf("STARTSWITH\n");
3348 		cnfexprPrint(expr-&gt;r, indent+1);
3349 		break;
3350 	case CMP_STARTSWITHI:
3351 		cnfexprPrint(expr-&gt;l, indent+1);
3352 		doIndent(indent);
3353 		dbgprintf("STARTSWITH_I\n");
3354 		cnfexprPrint(expr-&gt;r, indent+1);
3355 		break;
3356 	case OR:
3357 		cnfexprPrint(expr-&gt;l, indent+1);
3358 		doIndent(indent);
3359 		dbgprintf("OR\n");
3360 		cnfexprPrint(expr-&gt;r, indent+1);
3361 		break;
3362 	case AND:
3363 		cnfexprPrint(expr-&gt;l, indent+1);
3364 		doIndent(indent);
3365 		dbgprintf("AND\n");
3366 		cnfexprPrint(expr-&gt;r, indent+1);
3367 		break;
3368 	case NOT:
3369 		doIndent(indent);
3370 		dbgprintf("NOT\n");
3371 		cnfexprPrint(expr-&gt;r, indent+1);
3372 		break;
3373 	case S_FUNC_EXISTS:
3374 		doIndent(indent);
3375 		dbgprintf("exists(%s)\n", ((struct cnffuncexists*)expr)-&gt;varname);
3376 		break;
3377 	case 'S':
3378 		doIndent(indent);
3379 		cstrPrint("string '", ((struct cnfstringval*)expr)-&gt;estr);
3380 		dbgprintf("'\n");
3381 		break;
3382 	case 'A':
3383 		cnfarrayPrint((struct cnfarray*)expr, indent);
3384 		break;
3385 	case 'N':
3386 		doIndent(indent);
3387 		dbgprintf("%lld\n", ((struct cnfnumval*)expr)-&gt;val);
3388 		break;
3389 	case 'V':
3390 		doIndent(indent);
3391 		dbgprintf("var '%s'\n", ((struct cnfvar*)expr)-&gt;name);
3392 		break;
3393 	case 'F':
3394 		doIndent(indent);
3395 		func = (struct cnffunc*) expr;
3396 		cstrPrint("function '", func-&gt;fname);
3397 		fname = es_str2cstr(func-&gt;fname, NULL);
3398 		dbgprintf("' (name:%s, params:%hu)\n", fname, func-&gt;nParams);
3399 		free(fname);
3400 		if(func-&gt;fPtr == doFunct_Prifilt) {
3401 			struct funcData_prifilt *pD;
3402 			pD = (struct funcData_prifilt*) func-&gt;funcdata;
3403 			pmaskPrint(pD-&gt;pmask, indent+1);
3404 		}
3405 		for(i = 0 ; i &lt; func-&gt;nParams ; ++i) {
3406 			cnfexprPrint(func-&gt;expr[i], indent+1);
3407 		}
3408 		break;
3409 	case '&amp;':
3410 	case '+':
3411 	case '-':
3412 	case '*':
3413 	case '/':
3414 	case '%':
3415 	case 'M':
3416 		if(expr-&gt;l != NULL)
3417 			cnfexprPrint(expr-&gt;l, indent+1);
3418 		doIndent(indent);
3419 		dbgprintf("%c\n", (char) expr-&gt;nodetype);
3420 		cnfexprPrint(expr-&gt;r, indent+1);
3421 		break;
3422 	default:
3423 		dbgprintf("error: unknown nodetype %u['%c']\n",
3424 			(unsigned) expr-&gt;nodetype, (char) expr-&gt;nodetype);
3425 		assert(0); 		break;
3426 	}
3427 }
3428 void
3429 cnfstmtPrintOnly(struct cnfstmt *stmt, int indent, sbool subtree)
3430 {
3431 	char *cstr;
3432 	switch(stmt-&gt;nodetype) {
3433 	case S_NOP:
3434 		doIndent(indent); dbgprintf("NOP\n");
3435 		break;
3436 	case S_STOP:
3437 		doIndent(indent); dbgprintf("STOP\n");
3438 		break;
3439 	case S_CALL:
3440 		cstr = es_str2cstr(stmt-&gt;d.s_call.name, NULL);
3441 		doIndent(indent); dbgprintf("CALL [%s, queue:%d]\n", cstr,
3442 			stmt-&gt;d.s_call.ruleset == NULL ? 0 : 1);
3443 		free(cstr);
3444 		break;
3445 	case S_CALL_INDIRECT:
3446 		doIndent(indent); dbgprintf("CALL_INDIRECT\n");
3447 		cnfexprPrint(stmt-&gt;d.s_call_ind.expr, indent+1);
3448 		break;
3449 	case S_ACT:
3450 		doIndent(indent); dbgprintf("ACTION %d [%s:%s]\n", stmt-&gt;d.act-&gt;iActionNbr,
3451 			modGetName(stmt-&gt;d.act-&gt;pMod), stmt-&gt;printable);
3452 		break;
3453 	case S_IF:
3454 		doIndent(indent); dbgprintf("IF\n");
3455 		cnfexprPrint(stmt-&gt;d.s_if.expr, indent+1);
3456 		if(subtree) {
3457 			doIndent(indent); dbgprintf("THEN\n");
3458 			cnfstmtPrint(stmt-&gt;d.s_if.t_then, indent+1);
3459 			if(stmt-&gt;d.s_if.t_else != NULL) {
3460 				doIndent(indent); dbgprintf("ELSE\n");
3461 				cnfstmtPrint(stmt-&gt;d.s_if.t_else, indent+1);
3462 			}
3463 			doIndent(indent); dbgprintf("END IF\n");
3464 		}
3465 		break;
3466 	case S_FOREACH:
3467 		doIndent(indent); dbgprintf("FOREACH %s IN\n", stmt-&gt;d.s_foreach.iter-&gt;var);
3468 		cnfexprPrint(stmt-&gt;d.s_foreach.iter-&gt;collection, indent+1);
3469 		if(subtree) {
3470 			doIndent(indent); dbgprintf("DO\n");
3471 			cnfstmtPrint(stmt-&gt;d.s_foreach.body, indent+1);
3472 			doIndent(indent); dbgprintf("END FOREACH\n");
3473 		}
3474 		break;
3475 	case S_SET:
3476 		doIndent(indent); dbgprintf("SET %s =\n",
3477 				  stmt-&gt;d.s_set.varname);
3478 		cnfexprPrint(stmt-&gt;d.s_set.expr, indent+1);
3479 		doIndent(indent); dbgprintf("END SET\n");
3480 		break;
3481 	case S_UNSET:
3482 		doIndent(indent); dbgprintf("UNSET %s\n",
3483 				  stmt-&gt;d.s_unset.varname);
3484 		break;
3485 	case S_RELOAD_LOOKUP_TABLE:
3486 		doIndent(indent);
3487 		dbgprintf("RELOAD_LOOKUP_TABLE table(%s) (stub with '%s' on error)",
3488 			stmt-&gt;d.s_reload_lookup_table.table_name,
3489 			stmt-&gt;d.s_reload_lookup_table.stub_value);
3490 		break;
3491 	case S_PRIFILT:
3492 		doIndent(indent); dbgprintf("PRIFILT '%s'\n", stmt-&gt;printable);
3493 		pmaskPrint(stmt-&gt;d.s_prifilt.pmask, indent);
3494 		if(subtree) {
3495 			cnfstmtPrint(stmt-&gt;d.s_prifilt.t_then, indent+1);
3496 			if(stmt-&gt;d.s_prifilt.t_else != NULL) {
3497 				doIndent(indent); dbgprintf("ELSE\n");
3498 				cnfstmtPrint(stmt-&gt;d.s_prifilt.t_else, indent+1);
3499 			}
3500 			doIndent(indent); dbgprintf("END PRIFILT\n");
3501 		}
3502 		break;
3503 	case S_PROPFILT:
3504 		doIndent(indent); dbgprintf("PROPFILT\n");
3505 		doIndent(indent); dbgprintf("\tProperty.: '%s'\n",
3506 			propIDToName(stmt-&gt;d.s_propfilt.prop.id));
3507 		if(stmt-&gt;d.s_propfilt.prop.id == PROP_CEE ||
3508 		   stmt-&gt;d.s_propfilt.prop.id == PROP_LOCAL_VAR ||
3509 		   stmt-&gt;d.s_propfilt.prop.id == PROP_GLOBAL_VAR) {
3510 			doIndent(indent);
3511 			dbgprintf("\tCEE-Prop.: '%s'\n", stmt-&gt;d.s_propfilt.prop.name);
3512 		}
3513 		doIndent(indent); dbgprintf("\tOperation: ");
3514 		if(stmt-&gt;d.s_propfilt.isNegated)
3515 			dbgprintf("NOT ");
3516 		dbgprintf("'%s'\n", getFIOPName(stmt-&gt;d.s_propfilt.operation));
3517 		if(stmt-&gt;d.s_propfilt.pCSCompValue != NULL) {
3518 			doIndent(indent); dbgprintf("\tValue....: '%s'\n",
3519 			       rsCStrGetSzStrNoNULL(stmt-&gt;d.s_propfilt.pCSCompValue));
3520 		}
3521 		if(subtree) {
3522 			doIndent(indent); dbgprintf("THEN\n");
3523 			cnfstmtPrint(stmt-&gt;d.s_propfilt.t_then, indent+1);
3524 			doIndent(indent); dbgprintf("END PROPFILT\n");
3525 		}
3526 		break;
3527 	default:
3528 		dbgprintf("error: unknown stmt type %u\n",
3529 			(unsigned) stmt-&gt;nodetype);
3530 		break;
3531 	}
3532 }
3533 void
3534 cnfstmtPrint(struct cnfstmt *root, int indent)
3535 {
3536 	struct cnfstmt *stmt;
3537 	for(stmt = root ; stmt != NULL ; stmt = stmt-&gt;next) {
3538 		cnfstmtPrintOnly(stmt, indent, 1);
3539 	}
3540 }
3541 struct cnfnumval*
3542 cnfnumvalNew(const long long val)
3543 {
3544 	struct cnfnumval *numval;
3545 	if((numval = malloc(sizeof(struct cnfnumval))) != NULL) {
3546 		numval-&gt;nodetype = 'N';
3547 		numval-&gt;val = val;
3548 	}
3549 	return numval;
3550 }
3551 struct cnfstringval*
3552 cnfstringvalNew(es_str_t *const estr)
3553 {
3554 	struct cnfstringval *strval;
3555 	if((strval = malloc(sizeof(struct cnfstringval))) != NULL) {
3556 		strval-&gt;nodetype = 'S';
3557 		strval-&gt;estr = estr;
3558 	}
3559 	return strval;
3560 }
3561 struct cnfarray*
3562 cnfarrayNew(es_str_t *val)
3563 {
3564 	struct cnfarray *ar;
3565 	if((ar = malloc(sizeof(struct cnfarray))) != NULL) {
3566 		ar-&gt;nodetype = 'A';
3567 		ar-&gt;nmemb = 1;
3568 		if((ar-&gt;arr = malloc(sizeof(es_str_t*))) == NULL) {
3569 			free(ar);
3570 			ar = NULL;
3571 			goto done;
3572 		}
3573 		ar-&gt;arr[0] = val;
3574 	}
3575 done:	return ar;
3576 }
3577 struct cnfarray*
3578 cnfarrayAdd(struct cnfarray *__restrict__ const ar, es_str_t *__restrict__ val)
3579 {
3580 	es_str_t **newptr;
3581 	if((newptr = realloc(ar-&gt;arr, (ar-&gt;nmemb+1)*sizeof(es_str_t*))) == NULL) {
3582 		DBGPRINTF("cnfarrayAdd: realloc failed, item ignored, ar-&gt;arr=%p\n", ar-&gt;arr);
3583 		goto done;
3584 	} else {
3585 		ar-&gt;arr = newptr;
3586 		ar-&gt;arr[ar-&gt;nmemb] = val;
3587 		ar-&gt;nmemb++;
3588 	}
3589 done:	return ar;
3590 }
3591 struct cnfarray*
3592 cnfarrayDup(struct cnfarray *old)
3593 {
3594 	int i;
3595 	struct cnfarray *ar;
3596 	ar = cnfarrayNew(es_strdup(old-&gt;arr[0]));
3597 	for(i = 1 ; i &lt; old-&gt;nmemb ; ++i) {
3598 		cnfarrayAdd(ar, es_strdup(old-&gt;arr[i]));
3599 	}
3600 	return ar;
3601 }
3602 struct cnfvar*
3603 cnfvarNew(char *name)
3604 {
3605 	struct cnfvar *var;
3606 	if((var = malloc(sizeof(struct cnfvar))) != NULL) {
3607 		var-&gt;nodetype = 'V';
3608 		var-&gt;name = name;
3609 		msgPropDescrFill(&amp;var-&gt;prop, (uchar*)var-&gt;name, strlen(var-&gt;name));
3610 	}
3611 	return var;
3612 }
3613 struct cnfstmt *
3614 cnfstmtNew(unsigned s_type)
3615 {
3616 	struct cnfstmt* cnfstmt;
3617 	if((cnfstmt = malloc(sizeof(struct cnfstmt))) != NULL) {
3618 		cnfstmt-&gt;nodetype = s_type;
3619 		cnfstmt-&gt;printable = NULL;
3620 		cnfstmt-&gt;next = NULL;
3621 	}
3622 	return cnfstmt;
3623 }
3624 static void
3625 cnfstmtDisable(struct cnfstmt *cnfstmt)
3626 {
3627 	cnfstmt-&gt;nodetype = S_NOP;
3628 }
3629 void cnfstmtDestructLst(struct cnfstmt *root);
3630 static void cnfIteratorDestruct(struct cnfitr *itr);
3631 static void
3632 cnfstmtDestruct(struct cnfstmt *stmt)
3633 {
3634 	switch(stmt-&gt;nodetype) {
3635 	case S_NOP:
3636 	case S_STOP:
3637 		break;
3638 	case S_CALL:
3639 		es_deleteStr(stmt-&gt;d.s_call.name);
3640 		break;
3641 	case S_CALL_INDIRECT:
3642 		cnfexprDestruct(stmt-&gt;d.s_call_ind.expr);
3643 		break;
3644 	case S_ACT:
3645 		actionDestruct(stmt-&gt;d.act);
3646 		break;
3647 	case S_IF:
3648 		cnfexprDestruct(stmt-&gt;d.s_if.expr);
3649 		if(stmt-&gt;d.s_if.t_then != NULL) {
3650 			cnfstmtDestructLst(stmt-&gt;d.s_if.t_then);
3651 		}
3652 		if(stmt-&gt;d.s_if.t_else != NULL) {
3653 			cnfstmtDestructLst(stmt-&gt;d.s_if.t_else);
3654 		}
3655 		break;
3656 	case S_FOREACH:
3657 		cnfIteratorDestruct(stmt-&gt;d.s_foreach.iter);
3658 		cnfstmtDestructLst(stmt-&gt;d.s_foreach.body);
3659 		break;
3660 	case S_SET:
3661 		free(stmt-&gt;d.s_set.varname);
3662 		cnfexprDestruct(stmt-&gt;d.s_set.expr);
3663 		break;
3664 	case S_UNSET:
3665 		free(stmt-&gt;d.s_set.varname);
3666 		break;
3667 	case S_PRIFILT:
3668 		cnfstmtDestructLst(stmt-&gt;d.s_prifilt.t_then);
3669 		cnfstmtDestructLst(stmt-&gt;d.s_prifilt.t_else);
3670 		break;
3671 	case S_PROPFILT:
3672 		msgPropDescrDestruct(&amp;stmt-&gt;d.s_propfilt.prop);
3673 		if(stmt-&gt;d.s_propfilt.regex_cache != NULL)
3674 			rsCStrRegexDestruct(&amp;stmt-&gt;d.s_propfilt.regex_cache);
3675 		if(stmt-&gt;d.s_propfilt.pCSCompValue != NULL)
3676 			cstrDestruct(&amp;stmt-&gt;d.s_propfilt.pCSCompValue);
3677 		cnfstmtDestructLst(stmt-&gt;d.s_propfilt.t_then);
3678 		break;
3679 	case S_RELOAD_LOOKUP_TABLE:
3680 		if (stmt-&gt;d.s_reload_lookup_table.table_name != NULL) {
3681 				free(stmt-&gt;d.s_reload_lookup_table.table_name);
3682 		}
3683 		if (stmt-&gt;d.s_reload_lookup_table.stub_value != NULL) {
3684 				free(stmt-&gt;d.s_reload_lookup_table.stub_value);
3685 		}
3686 		break;
3687 	default:
3688 		DBGPRINTF("error: unknown stmt type during destruct %u\n",
3689 			(unsigned) stmt-&gt;nodetype);
3690 		break;
3691 	}
3692 	free(stmt-&gt;printable);
3693 	free(stmt);
3694 }
3695 void
3696 cnfstmtDestructLst(struct cnfstmt *root)
3697 {
3698 	struct cnfstmt *stmt, *todel;
3699 	for(stmt = root ; stmt != NULL ; ) {
3700 		todel = stmt;
3701 		stmt = stmt-&gt;next;
3702 		cnfstmtDestruct(todel);
3703 	}
3704 }
3705 struct cnfitr *
3706 cnfNewIterator(char *var, struct cnfexpr *collection)
3707 {
3708 	struct cnfitr* itr;
3709 	if ((itr = malloc(sizeof(struct cnfitr))) != NULL) {
3710 		itr-&gt;var = var;
3711 		itr-&gt;collection = collection;
3712 	}
3713 	return itr;
3714 }
3715 static void
3716 cnfIteratorDestruct(struct cnfitr *itr)
3717 {
3718 	free(itr-&gt;var);
3719 	if(itr-&gt;collection != NULL)
3720 		cnfexprDestruct(itr-&gt;collection);
3721 	free(itr);
3722 }
3723 struct cnfstmt *
3724 cnfstmtNewSet(char *var, struct cnfexpr *expr, int force_reset)
3725 {
3726 	propid_t propid;
3727 	struct cnfstmt* cnfstmt;
3728 	if((cnfstmt = cnfstmtNew(S_SET)) != NULL) {
3729 		if(propNameToID((uchar *)var, &amp;propid) == RS_RET_OK
3730 		   &amp;&amp; (   propid == PROP_CEE
3731 		       || propid == PROP_LOCAL_VAR
3732 		       || propid == PROP_GLOBAL_VAR)
3733 		   ) {
3734 			cnfstmt-&gt;d.s_set.varname = (uchar*) var;
3735 			cnfstmt-&gt;d.s_set.expr = expr;
3736 			cnfstmt-&gt;d.s_set.force_reset = force_reset;
3737 		} else {
3738 			parser_errmsg("invalid variable '%s' in set statement.", var);
3739 			free(var);
3740 			cnfstmtDisable(cnfstmt);
3741 		}
3742 	}
3743 	return cnfstmt;
3744 }
3745 struct cnfstmt *
3746 cnfstmtNewCall(es_str_t *name)
3747 {
3748 	struct cnfstmt* cnfstmt;
3749 	if((cnfstmt = cnfstmtNew(S_CALL)) != NULL) {
3750 		cnfstmt-&gt;d.s_call.name = name;
3751 		cnfstmt-&gt;d.s_call.ruleset = NULL;
3752 	}
3753 	return cnfstmt;
3754 }
3755 struct cnfstmt *
3756 cnfstmtNewReloadLookupTable(struct cnffparamlst *fparams)
3757 {
3758 	int nParams;
3759 	struct cnffparamlst *param, *nxt;
3760 	struct cnfstmt* cnfstmt;
3761 	uint8_t failed = 0;
3762 	if((cnfstmt = cnfstmtNew(S_RELOAD_LOOKUP_TABLE)) != NULL) {
3763 		nParams = 0;
3764 		for(param = fparams ; param != NULL ; param = param-&gt;next) {
3765 			++nParams;
3766 		}
3767 		cnfstmt-&gt;d.s_reload_lookup_table.table_name = cnfstmt-&gt;d.s_reload_lookup_table.stub_value = NULL;
3768 		switch(nParams) {
3769 		case 2:
3770 			param = fparams-&gt;next;
3771 			if (param-&gt;expr-&gt;nodetype != 'S') {
3772 				parser_errmsg("statement ignored: reload_lookup_table(table_name, "
3773 					"optional:stub_value_in_case_reload_fails) "
3774 					"expects a litteral string for second argument\n");
3775 				failed = 1;
3776 			}
3777 			if ((cnfstmt-&gt;d.s_reload_lookup_table.stub_value =
3778 			(uchar*) es_str2cstr(((struct cnfstringval*)param-&gt;expr)-&gt;estr, NULL)) == NULL) {
3779 				parser_errmsg("statement ignored: reload_lookup_table statement "
3780 				"failed to allocate memory for lookup-table stub-value\n");
3781 				failed = 1;
3782 			}
3783 			CASE_FALLTHROUGH
3784 		case 1:
3785 			param = fparams;
3786 			if (param-&gt;expr-&gt;nodetype != 'S') {
3787 				parser_errmsg("statement ignored: reload_lookup_table(table_name, "
3788 					"optional:stub_value_in_case_reload_fails) "
3789 				 	"expects a litteral string for first argument\n");
3790 				failed = 1;
3791 			}
3792 			if ((cnfstmt-&gt;d.s_reload_lookup_table.table_name =
3793 			(uchar*) es_str2cstr(((struct cnfstringval*)param-&gt;expr)-&gt;estr, NULL)) == NULL) {
3794 				parser_errmsg("statement ignored: reload_lookup_table statement "
3795 				"failed to allocate memory for lookup-table name\n");
3796 				failed = 1;
3797 			}
3798 			break;
3799 		default:
3800 			parser_errmsg("statement ignored: reload_lookup_table(table_name, optional:"
3801 				"stub_value_in_case_reload_fails) "
3802 				"expected 1 or 2 arguments, but found '%d'\n", nParams);
3803 			failed = 1;
3804 		}
3805 	}
3806 	param = fparams;
3807 	while(param != NULL) {
3808 		nxt = param-&gt;next;
3809 		if (param-&gt;expr != NULL) cnfexprDestruct(param-&gt;expr);
3810 		free(param);
3811 		param = nxt;
3812 	}
3813 	if (failed) {
3814 		cnfstmt-&gt;nodetype = S_NOP;
3815 		if (cnfstmt-&gt;d.s_reload_lookup_table.table_name != NULL) {
3816 			free(cnfstmt-&gt;d.s_reload_lookup_table.table_name);
3817 		}
3818 		if (cnfstmt-&gt;d.s_reload_lookup_table.stub_value != NULL) {
3819 			free(cnfstmt-&gt;d.s_reload_lookup_table.stub_value);
3820 		}
3821 	}
3822 	return cnfstmt;
3823 }
3824 struct cnfstmt *
3825 cnfstmtNewUnset(char *var)
3826 {
3827 	propid_t propid;
3828 	struct cnfstmt* cnfstmt;
3829 	if((cnfstmt = cnfstmtNew(S_UNSET)) != NULL) {
3830 		if(propNameToID((uchar *)var, &amp;propid) == RS_RET_OK
3831 		   &amp;&amp; (   propid == PROP_CEE
3832 		       || propid == PROP_LOCAL_VAR
3833 		       || propid == PROP_GLOBAL_VAR)
3834 		   ) {
3835 			cnfstmt-&gt;d.s_unset.varname = (uchar*) var;
3836 		} else {
3837 			parser_errmsg("invalid variable '%s' in unset statement.", var);
3838 			free(var);
3839 			cnfstmtDisable(cnfstmt);
3840 		}
3841 	}
3842 	return cnfstmt;
3843 }
3844 struct cnfstmt *
3845 cnfstmtNewContinue(void)
3846 {
3847 	return cnfstmtNew(S_NOP);
3848 }
3849 struct cnfstmt *
3850 cnfstmtNewPRIFILT(char *prifilt, struct cnfstmt *t_then)
3851 {
3852 	struct cnfstmt* cnfstmt;
3853 	if((cnfstmt = cnfstmtNew(S_PRIFILT)) != NULL) {
3854 		cnfstmt-&gt;printable = (uchar*)prifilt;
3855 		cnfstmt-&gt;d.s_prifilt.t_then = t_then;
3856 		cnfstmt-&gt;d.s_prifilt.t_else = NULL;
3857 		DecodePRIFilter((uchar*)prifilt, cnfstmt-&gt;d.s_prifilt.pmask);
3858 	}
3859 	return cnfstmt;
3860 }
3861 struct cnfstmt *
3862 cnfstmtNewPROPFILT(char *propfilt, struct cnfstmt *t_then)
3863 {
3864 	struct cnfstmt* cnfstmt;
3865 	if((cnfstmt = cnfstmtNew(S_PROPFILT)) != NULL) {
3866 		cnfstmt-&gt;printable = (uchar*)propfilt;
3867 		cnfstmt-&gt;d.s_propfilt.t_then = t_then;
3868 		cnfstmt-&gt;d.s_propfilt.regex_cache = NULL;
3869 		cnfstmt-&gt;d.s_propfilt.pCSCompValue = NULL;
3870 		if(DecodePropFilter((uchar*)propfilt, cnfstmt) != RS_RET_OK) {
3871 			cnfstmt-&gt;nodetype = S_NOP; 			cnfstmtDestructLst(t_then); 		}
3872 	}
3873 	return cnfstmt;
3874 }
3875 struct cnfstmt *
3876 cnfstmtNewAct(struct nvlst *lst)
3877 {
3878 	struct cnfstmt* cnfstmt;
3879 	char namebuf[256];
3880 	rsRetVal localRet;
3881 	if((cnfstmt = cnfstmtNew(S_ACT)) == NULL) {
3882 		goto done;
3883 	}
3884 	if (nvlstChkDisabled(lst)) {
3885 		dbgprintf("action disabled by configuration\n");
3886 		cnfstmt-&gt;nodetype = S_NOP;
3887 	}
3888 	localRet = actionNewInst(lst, &amp;cnfstmt-&gt;d.act);
3889 	if(localRet == RS_RET_OK_WARN) {
3890 		parser_errmsg("warnings occurred in file '%s' around line %d",
3891 			      cnfcurrfn, yylineno);
3892 	} else if(localRet != RS_RET_OK) {
3893 		parser_errmsg("errors occurred in file '%s' around line %d",
3894 			      cnfcurrfn, yylineno);
3895 		cnfstmt-&gt;nodetype = S_NOP; 		goto done;
3896 	}
3897 	snprintf(namebuf, sizeof(namebuf)-1, "action(type=\"%s\" ...)",
3898 		 modGetName(cnfstmt-&gt;d.act-&gt;pMod));
3899 	namebuf[255] = '\0'; 	cnfstmt-&gt;printable = (uchar*)strdup(namebuf);
3900 	nvlstChkUnused(lst);
3901 	nvlstDestruct(lst);
3902 done:	return cnfstmt;
3903 }
3904 struct cnfstmt *
3905 cnfstmtNewLegaAct(char *actline)
3906 {
3907 	struct cnfstmt* cnfstmt;
3908 	rsRetVal localRet;
3909 	if((cnfstmt = cnfstmtNew(S_ACT)) == NULL)
3910 		goto done;
3911 	cnfstmt-&gt;printable = (uchar*)strdup((char*)actline);
3912 	localRet = cflineDoAction(loadConf, (uchar**)&amp;actline, &amp;cnfstmt-&gt;d.act);
3913 	if(localRet != RS_RET_OK) {
3914 		parser_errmsg("%s occurred in file '%s' around line %d",
3915 			      (localRet == RS_RET_OK_WARN) ? "warnings" : "errors",
3916 			      cnfcurrfn, yylineno);
3917 		if(localRet != RS_RET_OK_WARN) {
3918 			cnfstmt-&gt;nodetype = S_NOP; 			goto done;
3919 		}
3920 	}
3921 done:	return cnfstmt;
3922 }
3923 static int
3924 getConstNumber(struct cnfexpr *expr, long long *l, long long *r)
3925 {
3926 	int ret = 0;
3927 	cnfexprOptimize(expr-&gt;l);
3928 	cnfexprOptimize(expr-&gt;r);
3929 	if(expr-&gt;l-&gt;nodetype == 'N') {
3930 		if(expr-&gt;r-&gt;nodetype == 'N') {
3931 			ret = 1;
3932 			*l = ((struct cnfnumval*)expr-&gt;l)-&gt;val;
3933 			*r = ((struct cnfnumval*)expr-&gt;r)-&gt;val;
3934 			cnfexprDestruct(expr-&gt;l);
3935 			cnfexprDestruct(expr-&gt;r);
3936 		} else if(expr-&gt;r-&gt;nodetype == 'S') {
3937 			ret = 1;
3938 			*l = ((struct cnfnumval*)expr-&gt;l)-&gt;val;
3939 			*r = es_str2num(((struct cnfstringval*)expr-&gt;r)-&gt;estr, NULL);
3940 			cnfexprDestruct(expr-&gt;l);
3941 			cnfexprDestruct(expr-&gt;r);
3942 		}
3943 	} else if(expr-&gt;l-&gt;nodetype == 'S') {
3944 		if(expr-&gt;r-&gt;nodetype == 'N') {
3945 			ret = 1;
3946 			*l = es_str2num(((struct cnfstringval*)expr-&gt;l)-&gt;estr, NULL);
3947 			*r = ((struct cnfnumval*)expr-&gt;r)-&gt;val;
3948 			cnfexprDestruct(expr-&gt;l);
3949 			cnfexprDestruct(expr-&gt;r);
3950 		} else if(expr-&gt;r-&gt;nodetype == 'S') {
3951 			ret = 1;
3952 			*l = es_str2num(((struct cnfstringval*)expr-&gt;l)-&gt;estr, NULL);
3953 			*r = es_str2num(((struct cnfstringval*)expr-&gt;r)-&gt;estr, NULL);
3954 			cnfexprDestruct(expr-&gt;l);
3955 			cnfexprDestruct(expr-&gt;r);
3956 		}
3957 	}
3958 	return ret;
3959 }
3960 static void
3961 constFoldConcat(struct cnfexpr *expr)
3962 {
3963 	es_str_t *estr;
3964 	cnfexprOptimize(expr-&gt;l);
3965 	cnfexprOptimize(expr-&gt;r);
3966 	if(expr-&gt;l-&gt;nodetype == 'S') {
3967 		if(expr-&gt;r-&gt;nodetype == 'S') {
3968 			estr = ((struct cnfstringval*)expr-&gt;l)-&gt;estr;
3969 			((struct cnfstringval*)expr-&gt;l)-&gt;estr = NULL;
3970 			es_addStr(&amp;estr, ((struct cnfstringval*)expr-&gt;r)-&gt;estr);
3971 			cnfexprDestruct(expr-&gt;l);
3972 			cnfexprDestruct(expr-&gt;r);
3973 			expr-&gt;nodetype = 'S';
3974 			((struct cnfstringval*)expr)-&gt;estr = estr;
3975 		} else if(expr-&gt;r-&gt;nodetype == 'N') {
3976 			es_str_t *numstr;
3977 			estr = ((struct cnfstringval*)expr-&gt;l)-&gt;estr;
3978 			((struct cnfstringval*)expr-&gt;l)-&gt;estr = NULL;
3979 			numstr = es_newStrFromNumber(((struct cnfnumval*)expr-&gt;r)-&gt;val);
3980 			es_addStr(&amp;estr, numstr);
3981 			es_deleteStr(numstr);
3982 			cnfexprDestruct(expr-&gt;l);
3983 			cnfexprDestruct(expr-&gt;r);
3984 			expr-&gt;nodetype = 'S';
3985 			((struct cnfstringval*)expr)-&gt;estr = estr;
3986 		}
3987 	} else if(expr-&gt;l-&gt;nodetype == 'N') {
3988 		if(expr-&gt;r-&gt;nodetype == 'S') {
3989 			estr = es_newStrFromNumber(((struct cnfnumval*)expr-&gt;l)-&gt;val);
3990 			es_addStr(&amp;estr, ((struct cnfstringval*)expr-&gt;r)-&gt;estr);
3991 			cnfexprDestruct(expr-&gt;l);
3992 			cnfexprDestruct(expr-&gt;r);
3993 			expr-&gt;nodetype = 'S';
3994 			((struct cnfstringval*)expr)-&gt;estr = estr;
3995 		} else if(expr-&gt;r-&gt;nodetype == 'N') {
3996 			es_str_t *numstr;
3997 			estr = es_newStrFromNumber(((struct cnfnumval*)expr-&gt;l)-&gt;val);
3998 			numstr = es_newStrFromNumber(((struct cnfnumval*)expr-&gt;r)-&gt;val);
3999 			es_addStr(&amp;estr, numstr);
4000 			es_deleteStr(numstr);
4001 			cnfexprDestruct(expr-&gt;l);
4002 			cnfexprDestruct(expr-&gt;r);
4003 			expr-&gt;nodetype = 'S';
4004 			((struct cnfstringval*)expr)-&gt;estr = estr;
4005 		}
4006 	}
4007 }
4008 static struct cnfexpr*
4009 cnfexprOptimize_CMP_severity_facility(struct cnfexpr *expr)
4010 {
4011 	struct cnffunc *func;
4012 	if(expr-&gt;l-&gt;nodetype != 'V')
4013 		FINALIZE;
4014 	if(!strcmp("syslogseverity", ((struct cnfvar*)expr-&gt;l)-&gt;name)) {
4015 		if(expr-&gt;r-&gt;nodetype == 'N') {
4016 			int sev = (int) ((struct cnfnumval*)expr-&gt;r)-&gt;val;
4017 			if(sev &gt;= 0 &amp;&amp; sev &lt;= 7) {
4018 				DBGPRINTF("optimizer: change comparison OP to FUNC prifilt()\n");
4019 				func = cnffuncNew_prifilt(0); 				prifiltSetSeverity(func-&gt;funcdata, sev, expr-&gt;nodetype);
4020 				cnfexprDestruct(expr);
4021 				expr = (struct cnfexpr*) func;
4022 			} else {
4023 				parser_errmsg("invalid syslogseverity %d, expression will always "
4024 					      "evaluate to FALSE", sev);
4025 			}
4026 		}
4027 	} else if(!strcmp("syslogfacility", ((struct cnfvar*)expr-&gt;l)-&gt;name)) {
4028 		if(expr-&gt;r-&gt;nodetype == 'N') {
4029 			int fac = (int) ((struct cnfnumval*)expr-&gt;r)-&gt;val;
4030 			if(fac &gt;= 0 &amp;&amp; fac &lt;= 24) {
4031 				DBGPRINTF("optimizer: change comparison OP to FUNC prifilt()\n");
4032 				func = cnffuncNew_prifilt(0); 				prifiltSetFacility(func-&gt;funcdata, fac, expr-&gt;nodetype);
4033 				cnfexprDestruct(expr);
4034 				expr = (struct cnfexpr*) func;
4035 			} else {
4036 				parser_errmsg("invalid syslogfacility %d, expression will always "
4037 					      "evaluate to FALSE", fac);
4038 			}
4039 		}
4040 	}
4041 finalize_it:
4042 	return expr;
4043 }
4044 static struct cnfexpr*
4045 cnfexprOptimize_CMP_var(struct cnfexpr *expr)
4046 {
4047 	struct cnffunc *func;
4048 	if(!strcmp("syslogfacility-text", ((struct cnfvar*)expr-&gt;l)-&gt;name)) {
4049 		if(expr-&gt;r-&gt;nodetype == 'S') {
4050 			char *cstr = es_str2cstr(((struct cnfstringval*)expr-&gt;r)-&gt;estr, NULL);
4051 			int fac = decodeSyslogName((uchar*)cstr, syslogFacNames);
4052 			if(fac == -1) {
4053 				parser_errmsg("invalid facility '%s', expression will always "
4054 					      "evaluate to FALSE", cstr);
4055 			} else {
4056 				DBGPRINTF("optimizer: change comparison OP to FUNC prifilt()\n");
4057 				func = cnffuncNew_prifilt(fac);
4058 				if(expr-&gt;nodetype == CMP_NE)
4059 					prifiltInvert(func-&gt;funcdata);
4060 				cnfexprDestruct(expr);
4061 				expr = (struct cnfexpr*) func;
4062 			}
4063 			free(cstr);
4064 		}
4065 	} else if(!strcmp("syslogseverity-text", ((struct cnfvar*)expr-&gt;l)-&gt;name)) {
4066 		if(expr-&gt;r-&gt;nodetype == 'S') {
4067 			char *cstr = es_str2cstr(((struct cnfstringval*)expr-&gt;r)-&gt;estr, NULL);
4068 			int sev = decodeSyslogName((uchar*)cstr, syslogPriNames);
4069 			if(sev == -1) {
4070 				parser_errmsg("invalid syslogseverity '%s', expression will always "
4071 					      "evaluate to FALSE", cstr);
4072 			} else {
4073 				DBGPRINTF("optimizer: change comparison OP to FUNC prifilt()\n");
4074 				func = cnffuncNew_prifilt(0);
4075 				prifiltSetSeverity(func-&gt;funcdata, sev, expr-&gt;nodetype);
4076 				cnfexprDestruct(expr);
4077 				expr = (struct cnfexpr*) func;
4078 			}
4079 			free(cstr);
4080 		}
4081 	} else {
4082 		expr = cnfexprOptimize_CMP_severity_facility(expr);
4083 	}
4084 	return expr;
4085 }
4086 static struct cnfexpr*
4087 cnfexprOptimize_NOT(struct cnfexpr *expr)
4088 {
4089 	struct cnffunc *func;
4090 	if(expr-&gt;r-&gt;nodetype == 'F') {
4091 		func = (struct cnffunc *)expr-&gt;r;
4092 		if(func-&gt;fPtr == doFunct_Prifilt) {
4093 			DBGPRINTF("optimize NOT prifilt() to inverted prifilt()\n");
4094 			expr-&gt;r = NULL;
4095 			cnfexprDestruct(expr);
4096 			prifiltInvert(func-&gt;funcdata);
4097 			expr = (struct cnfexpr*) func;
4098 		}
4099 	}
4100 	return expr;
4101 }
4102 static struct cnfexpr*
4103 cnfexprOptimize_AND_OR(struct cnfexpr *expr)
4104 {
4105 	struct cnffunc *funcl, *funcr;
4106 	if(expr-&gt;l-&gt;nodetype == 'F') {
4107 		if(expr-&gt;r-&gt;nodetype == 'F') {
4108 			funcl = (struct cnffunc *)expr-&gt;l;
4109 			funcr = (struct cnffunc *)expr-&gt;r;
4110 			if(funcl-&gt;fPtr == doFunct_Prifilt &amp;&amp; funcr-&gt;fPtr == doFunct_Prifilt) {
4111 				DBGPRINTF("optimize combine AND/OR prifilt()\n");
4112 				expr-&gt;l = NULL;
4113 				prifiltCombine(funcl-&gt;funcdata, funcr-&gt;funcdata, expr-&gt;nodetype);
4114 				cnfexprDestruct(expr);
4115 				expr = (struct cnfexpr*) funcl;
4116 			}
4117 		}
4118 	}
4119 	return expr;
4120 }
4121 static inline void
4122 cnfexprOptimize_CMPEQ_arr(struct cnfarray *arr)
4123 {
4124 	DBGPRINTF("optimizer: sorting array of %d members for CMP_EQ/NEQ comparison\n", arr-&gt;nmemb);
4125 	qsort(arr-&gt;arr, arr-&gt;nmemb, sizeof(es_str_t*), qs_arrcmp);
4126 }
4127 struct cnfexpr*
4128 cnfexprOptimize(struct cnfexpr *expr)
4129 {
4130 	long long ln, rn;
4131 	struct cnfexpr *exprswap;
4132 	DBGPRINTF("optimize expr %p, type '%s'\n", expr, tokenToString(expr-&gt;nodetype));
4133 	switch(expr-&gt;nodetype) {
4134 	case '&amp;':
4135 		constFoldConcat(expr);
4136 		break;
4137 	case '+':
4138 		if(getConstNumber(expr, &amp;ln, &amp;rn))  {
4139 			expr-&gt;nodetype = 'N';
4140 			((struct cnfnumval*)expr)-&gt;val = ln + rn;
4141 		}
4142 		break;
4143 	case '-':
4144 		if(getConstNumber(expr, &amp;ln, &amp;rn))  {
4145 			expr-&gt;nodetype = 'N';
4146 			((struct cnfnumval*)expr)-&gt;val = ln - rn;
4147 		}
4148 		break;
4149 	case '*':
4150 		if(getConstNumber(expr, &amp;ln, &amp;rn))  {
4151 			expr-&gt;nodetype = 'N';
4152 			((struct cnfnumval*)expr)-&gt;val = ln * rn;
4153 		}
4154 		break;
4155 	case '/':
4156 		if(getConstNumber(expr, &amp;ln, &amp;rn))  {
4157 			expr-&gt;nodetype = 'N';
4158 			if(rn == 0) {
4159 				((struct cnfnumval*)expr)-&gt;val = 0;
4160 			} else {
4161 				((struct cnfnumval*)expr)-&gt;val = ln / rn;
4162 			}
4163 		}
4164 		break;
4165 	case '%':
4166 		if(getConstNumber(expr, &amp;ln, &amp;rn))  {
4167 			expr-&gt;nodetype = 'N';
4168 			if(rn == 0) {
4169 				((struct cnfnumval*)expr)-&gt;val = 0;
4170 			} else {
4171 				((struct cnfnumval*)expr)-&gt;val = ln % rn;
4172 			}
4173 		}
4174 		break;
4175 	case CMP_NE:
4176 	case CMP_EQ:
4177 		expr-&gt;l = cnfexprOptimize(expr-&gt;l);
4178 		expr-&gt;r = cnfexprOptimize(expr-&gt;r);
4179 		if(expr-&gt;l-&gt;nodetype == 'A') {
4180 			if(expr-&gt;r-&gt;nodetype == 'A') {
4181 				parser_errmsg("warning: '==' or '&lt;&gt;' "
4182 				  "comparison of two constant string "
4183 				  "arrays makes no sense");
4184 			} else { 				exprswap = expr-&gt;l;
4185 				expr-&gt;l = expr-&gt;r;
4186 				expr-&gt;r = exprswap;
4187 			}
4188 		}
4189 		if(expr-&gt;r-&gt;nodetype == 'A') {
4190 			cnfexprOptimize_CMPEQ_arr((struct cnfarray *)expr-&gt;r);
4191 		}
4192 		if(expr-&gt;l-&gt;nodetype == 'V') {
4193 			expr = cnfexprOptimize_CMP_var(expr);
4194 		}
4195 		break;
4196 	case CMP_LE:
4197 	case CMP_GE:
4198 	case CMP_LT:
4199 	case CMP_GT:
4200 		expr-&gt;l = cnfexprOptimize(expr-&gt;l);
4201 		expr-&gt;r = cnfexprOptimize(expr-&gt;r);
4202 		expr = cnfexprOptimize_CMP_severity_facility(expr);
4203 		break;
4204 	case CMP_CONTAINS:
4205 	case CMP_CONTAINSI:
4206 	case CMP_STARTSWITH:
4207 	case CMP_STARTSWITHI:
4208 		expr-&gt;l = cnfexprOptimize(expr-&gt;l);
4209 		expr-&gt;r = cnfexprOptimize(expr-&gt;r);
4210 		break;
4211 	case AND:
4212 	case OR:
4213 		expr-&gt;l = cnfexprOptimize(expr-&gt;l);
4214 		expr-&gt;r = cnfexprOptimize(expr-&gt;r);
4215 		expr = cnfexprOptimize_AND_OR(expr);
4216 		break;
4217 	case NOT:
4218 		expr-&gt;r = cnfexprOptimize(expr-&gt;r);
4219 		expr = cnfexprOptimize_NOT(expr);
4220 		break;
4221 	default:		break;
4222 	}
4223 	return expr;
4224 }
4225 static struct cnfstmt *
4226 removeNOPs(struct cnfstmt *const root)
4227 {
4228 	struct cnfstmt *stmt, *toDel, *prevstmt = NULL;
4229 	struct cnfstmt *newRoot = NULL;
4230 	if(root == NULL) goto done;
4231 	stmt = root;
4232 	while(stmt != NULL) {
4233 		if(stmt-&gt;nodetype == S_NOP) {
4234 			if(prevstmt != NULL)
4235 				prevstmt-&gt;next = NULL;
4236 			toDel = stmt;
4237 			stmt = stmt-&gt;next;
4238 			cnfstmtDestruct(toDel);
4239 		} else {
4240 			if(newRoot == NULL)
4241 				newRoot = stmt;
4242 			if(prevstmt != NULL)
4243 				prevstmt-&gt;next = stmt;
4244 			prevstmt = stmt;
4245 			stmt = stmt-&gt;next;
4246 		}
4247 	}
4248 done:	return newRoot;
4249 }
4250 static void
4251 cnfstmtOptimizeForeach(struct cnfstmt *stmt)
4252 {
4253 	stmt-&gt;d.s_foreach.iter-&gt;collection = cnfexprOptimize(stmt-&gt;d.s_foreach.iter-&gt;collection);
4254 	stmt-&gt;d.s_foreach.body = cnfstmtOptimize(stmt-&gt;d.s_foreach.body);
4255 }
4256 static void
4257 cnfstmtOptimizeIf(struct cnfstmt *stmt)
4258 {
4259 	struct cnfstmt *t_then, *t_else;
4260 	struct cnfexpr *expr;
4261 	struct cnffunc *func;
4262 	struct funcData_prifilt *prifilt;
4263 	assert(stmt-&gt;nodetype == S_IF);
4264 	expr = stmt-&gt;d.s_if.expr = cnfexprOptimize(stmt-&gt;d.s_if.expr);
4265 	stmt-&gt;d.s_if.t_then = cnfstmtOptimize(stmt-&gt;d.s_if.t_then);
4266 	stmt-&gt;d.s_if.t_else = cnfstmtOptimize(stmt-&gt;d.s_if.t_else);
4267 	if(stmt-&gt;d.s_if.t_then == NULL &amp;&amp; stmt-&gt;d.s_if.t_else == NULL) {
4268 		DBGPRINTF("optimizer: if with both empty then and else - remove\n");
4269 		cnfexprDestruct(stmt-&gt;d.s_if.expr);
4270 		stmt-&gt;nodetype = S_NOP;
4271 		goto done;
4272 	}
4273 	assert(stmt-&gt;nodetype == S_IF);
4274 	if(stmt-&gt;d.s_if.expr-&gt;nodetype == 'F') {
4275 		func = (struct cnffunc*)expr;
4276 		   if(func-&gt;fPtr == doFunct_Prifilt) {
4277 			DBGPRINTF("optimizer: change IF to PRIFILT\n");
4278 			t_then = stmt-&gt;d.s_if.t_then;
4279 			t_else = stmt-&gt;d.s_if.t_else;
4280 			stmt-&gt;nodetype = S_PRIFILT;
4281 			prifilt = (struct funcData_prifilt*) func-&gt;funcdata;
4282 			memcpy(stmt-&gt;d.s_prifilt.pmask, prifilt-&gt;pmask,
4283 				sizeof(prifilt-&gt;pmask));
4284 			stmt-&gt;d.s_prifilt.t_then = t_then;
4285 			stmt-&gt;d.s_prifilt.t_else = t_else;
4286 			if(func-&gt;nParams == 0)
4287 				stmt-&gt;printable = (uchar*)strdup("[Optimizer Result]");
4288 			else
4289 				stmt-&gt;printable = (uchar*)
4290 					es_str2cstr(((struct cnfstringval*)func-&gt;expr[0])-&gt;estr, NULL);
4291 			cnfexprDestruct(expr);
4292 			cnfstmtOptimizePRIFilt(stmt);
4293 		}
4294 	}
4295 done:	return;
4296 }
4297 static void
4298 cnfstmtOptimizeAct(struct cnfstmt *stmt)
4299 {
4300 	action_t *pAct;
4301 	pAct = stmt-&gt;d.act;
4302 	if(!strcmp((char*)modGetName(pAct-&gt;pMod), "builtin:omdiscard")) {
4303 		DBGPRINTF("optimizer: replacing omdiscard by STOP\n");
4304 		actionDestruct(stmt-&gt;d.act);
4305 		stmt-&gt;nodetype = S_STOP;
4306 	}
4307 }
4308 static void
4309 cnfstmtOptimizePRIFilt(struct cnfstmt *stmt)
4310 {
4311 	int i;
4312 	int isAlways = 1;
4313 	struct cnfstmt *subroot, *last;
4314 	stmt-&gt;d.s_prifilt.t_then = cnfstmtOptimize(stmt-&gt;d.s_prifilt.t_then);
4315 	for(i = 0; i &lt;= LOG_NFACILITIES; i++)
4316 		if(stmt-&gt;d.s_prifilt.pmask[i] != 0xff) {
4317 			isAlways = 0;
4318 			break;
4319 		}
4320 	if(!isAlways)
4321 		goto done;
4322 	DBGPRINTF("optimizer: removing always-true PRIFILT %p\n", stmt);
4323 	if(stmt-&gt;d.s_prifilt.t_else != NULL) {
4324 		parser_errmsg("error: always-true PRI filter has else part!\n");
4325 		cnfstmtDestructLst(stmt-&gt;d.s_prifilt.t_else);
4326 	}
4327 	free(stmt-&gt;printable);
4328 	stmt-&gt;printable = NULL;
4329 	subroot = stmt-&gt;d.s_prifilt.t_then;
4330 	if(subroot == NULL) {
4331 		 stmt-&gt;nodetype = S_NOP;
4332 		 goto done;
4333 	}
4334 	for(last = subroot ; last-&gt;next != NULL ; last = last-&gt;next)
4335 	last-&gt;next = stmt-&gt;next;
4336 	memcpy(stmt, subroot, sizeof(struct cnfstmt));
4337 	free(subroot);
4338 done:	return;
4339 }
4340 static void
4341 cnfstmtOptimizeReloadLookupTable(struct cnfstmt *stmt) {
4342 	if((stmt-&gt;d.s_reload_lookup_table.table = lookupFindTable(stmt-&gt;d.s_reload_lookup_table.table_name))
4343 	== NULL) {
4344 		parser_errmsg("lookup table '%s' not found\n", stmt-&gt;d.s_reload_lookup_table.table_name);
4345 	}
4346 }
4347 static void
4348 cnfstmtOptimizeCall(struct cnfstmt *stmt)
4349 {
4350 	ruleset_t *pRuleset;
4351 	rsRetVal localRet;
4352 	uchar *rsName;
4353 	rsName = (uchar*) es_str2cstr(stmt-&gt;d.s_call.name, NULL);
4354 	localRet = rulesetGetRuleset(loadConf, &amp;pRuleset, rsName);
4355 	if(localRet != RS_RET_OK) {
4356 		parser_errmsg("ruleset '%s' cannot be found\n", rsName);
4357 		es_deleteStr(stmt-&gt;d.s_call.name);
4358 		stmt-&gt;nodetype = S_NOP;
4359 		goto done;
4360 	}
4361 	DBGPRINTF("CALL obtained ruleset ptr %p for ruleset '%s' [hasQueue:%d]\n",
4362 		  pRuleset, rsName, rulesetHasQueue(pRuleset));
4363 	if(rulesetHasQueue(pRuleset)) {
4364 		stmt-&gt;d.s_call.ruleset = pRuleset;
4365 	} else {
4366 		stmt-&gt;d.s_call.ruleset = NULL;
4367 		stmt-&gt;d.s_call.stmt = pRuleset-&gt;root;
4368 	}
4369 done:
4370 	free(rsName);
4371 	return;
4372 }
4373 struct cnfstmt *
4374 cnfstmtOptimize(struct cnfstmt *root)
4375 {
4376 	struct cnfstmt *stmt;
4377 	if(root == NULL) goto done;
4378 	for(stmt = root ; stmt != NULL ; stmt = stmt-&gt;next) {
4379 		DBGPRINTF("optimizing cnfstmt type %d\n", (int) stmt-&gt;nodetype);
4380 		switch(stmt-&gt;nodetype) {
4381 		case S_IF:
4382 			cnfstmtOptimizeIf(stmt);
4383 			break;
4384 		case S_FOREACH:
4385 			cnfstmtOptimizeForeach(stmt);
4386 			break;
4387 		case S_PRIFILT:
4388 			cnfstmtOptimizePRIFilt(stmt);
4389 			break;
4390 		case S_PROPFILT:
4391 			stmt-&gt;d.s_propfilt.t_then = cnfstmtOptimize(stmt-&gt;d.s_propfilt.t_then);
4392 			break;
4393 		case S_SET:
4394 			stmt-&gt;d.s_set.expr = cnfexprOptimize(stmt-&gt;d.s_set.expr);
4395 			break;
4396 		case S_ACT:
4397 			cnfstmtOptimizeAct(stmt);
4398 			break;
4399 		case S_CALL:
4400 			cnfstmtOptimizeCall(stmt);
4401 			break;
4402 		case S_CALL_INDIRECT:
4403 			stmt-&gt;d.s_call_ind.expr = cnfexprOptimize(stmt-&gt;d.s_call_ind.expr);
4404 			break;
4405 		case S_STOP:
4406 			if(stmt-&gt;next != NULL)
4407 				parser_warnmsg("STOP is followed by unreachable statements!\n");
4408 			break;
4409 		case S_UNSET: 			break;
4410 		case S_RELOAD_LOOKUP_TABLE:
4411 			cnfstmtOptimizeReloadLookupTable(stmt);
4412 			break;
4413 		case S_NOP:
4414 			dbgprintf("optimizer error: we see a NOP, how come?");
4415 			break;
4416 		default:
4417 			LogError(0, RS_RET_INTERNAL_ERROR,
4418 				"internal error: unknown stmt type %u during optimizer run\n",
4419 				(unsigned) stmt-&gt;nodetype);
4420 			break;
4421 		}
4422 	}
4423 	root = removeNOPs(root);
4424 done:	return root;
4425 }
4426 struct cnffparamlst *
4427 cnffparamlstNew(struct cnfexpr *expr, struct cnffparamlst *next)
4428 {
4429 	struct cnffparamlst* lst;
4430 	if((lst = malloc(sizeof(struct cnffparamlst))) != NULL) {
4431 		lst-&gt;nodetype = 'P';
4432 		lst-&gt;expr = expr;
4433 		lst-&gt;next = next;
4434 	}
4435 	return lst;
4436 }
4437 static rscriptFuncPtr
4438 funcName2Ptr(char *const fname, const unsigned short nParams)
4439 {
4440 	struct scriptFunct *foundFunc = searchModList(fname);
4441 	if(foundFunc == NULL) {
4442 		parser_errmsg("function '%s' not found", fname);
4443 		return NULL;
4444 	} else {
4445 		return extractFuncPtr(foundFunc, nParams);
4446 	}
4447 }
4448 rsRetVal
4449 addMod2List(const int __attribute__((unused)) version, struct scriptFunct *functArray)
4450 {
4451 	DEFiRet;
4452 	int i;
4453 	struct modListNode *newNode;
4454 	CHKmalloc(newNode = (struct modListNode*) malloc(sizeof(struct modListNode)));
4455 	newNode-&gt;version = 1;
4456 	newNode-&gt;next = NULL;
4457 	i = 0;
4458 	while(functArray[i].fname != NULL) {
4459 		if(searchModList(functArray[i].fname) != NULL) {
4460 			parser_errmsg("function %s defined multiple times, second time will be ignored",
4461 				functArray[i].fname);
4462 		}
4463 	i++;
4464 	}
4465 	newNode-&gt;modFcts = functArray;
4466 	modListLast-&gt;next = newNode;
4467 	modListLast = newNode;
4468 finalize_it:
4469 	RETiRet;
4470 }
4471 struct cnffunc *
4472 cnffuncNew(es_str_t *fname, struct cnffparamlst* paramlst)
4473 {
4474 	struct cnffunc* func;
4475 	struct cnffparamlst *param, *toDel;
4476 	unsigned short i;
4477 	unsigned short nParams;
4478 	char *cstr;
4479 	nParams = 0;
4480 	for(param = paramlst ; param != NULL ; param = param-&gt;next)
4481 		++nParams;
4482 	if((func = malloc(sizeof(struct cnffunc) + (nParams * sizeof(struct cnfexp*))))
4483 	   != NULL) {
4484 		func-&gt;nodetype = 'F';
4485 		func-&gt;fname = fname;
4486 		func-&gt;nParams = nParams;
4487 		func-&gt;funcdata = NULL;
4488 		func-&gt;destructable_funcdata = 1;
4489 		cstr = es_str2cstr(fname, NULL);
4490 		func-&gt;fPtr = funcName2Ptr(cstr, nParams);
4491 		if (func-&gt;fPtr == NULL) {
4492 			parser_errmsg("Invalid function %s", cstr);
4493 		}
4494 		param = paramlst;
4495 		for(i = 0 ; i &lt; nParams ; ++i) {
4496 			func-&gt;expr[i] = param-&gt;expr;
4497 			toDel = param;
4498 			param = param-&gt;next;
4499 			free(toDel);
4500 		}
4501 		struct scriptFunct *foundFunc = searchModList(cstr);
4502 		if(foundFunc-&gt;initFunc != NULL) {
4503 			foundFunc-&gt;initFunc(func);
4504 		}
4505 		free(cstr);
4506 	}
4507 	return func;
4508 }
4509 struct cnffunc *
4510 cnffuncNew_prifilt(int fac)
4511 {
4512 	struct cnffunc* func;
4513 	fac &gt;&gt;= 3;
4514 	if (fac &gt;= LOG_NFACILITIES + 1 || fac &lt; 0)
4515 		return NULL;
4516 	if((func = malloc(sizeof(struct cnffunc))) != NULL) {
4517 		if ((func-&gt;funcdata = calloc(1, sizeof(struct funcData_prifilt))) == NULL) {
4518 			free(func);
4519 			return NULL;
4520 		}
4521 		func-&gt;nodetype = 'F';
4522 		func-&gt;fname = es_newStrFromCStr("prifilt", sizeof("prifilt")-1);
4523 		func-&gt;nParams = 0;
4524 		func-&gt;fPtr = doFunct_Prifilt;
4525 		func-&gt;destructable_funcdata = 1;
4526 		((struct funcData_prifilt *)func-&gt;funcdata)-&gt;pmask[fac] = TABLE_ALLPRI;
4527 	}
4528 	return func;
4529 }
4530 struct cnffuncexists * ATTR_NONNULL()
4531 cnffuncexistsNew(const char *const varname)
4532 {
4533 	struct cnffuncexists* f_exists;
4534 	if((f_exists = malloc(sizeof(struct cnffuncexists))) != NULL) {
4535 		f_exists-&gt;nodetype = S_FUNC_EXISTS;
4536 		f_exists-&gt;varname = varname;
4537 		msgPropDescrFill(&amp;f_exists-&gt;prop, (uchar*)varname, strlen(varname));
4538 	}
4539 	return f_exists;
4540 }
4541 int ATTR_NONNULL()
4542 cnfDoInclude(const char *const name, const int optional)
4543 {
4544 	char *cfgFile;
4545 	const char *finalName;
4546 	int i;
4547 	int result;
4548 	glob_t cfgFiles;
4549 	int ret = 0;
4550 	struct stat fileInfo;
4551 	char errStr[1024];
4552 	char nameBuf[MAXFNAME+1];
4553 	char cwdBuf[MAXFNAME+1];
4554 	DBGPRINTF("cnfDoInclude: file: '%s', optional: %d\n", name, optional);
4555 	finalName = name;
4556 	if(stat(name, &amp;fileInfo) == 0) {
4557 		if(S_ISDIR(fileInfo.st_mode)) {
4558 			snprintf(nameBuf, sizeof(nameBuf), "%s*", name);
4559 			finalName = nameBuf;
4560 		}
4561 	}
4562 	#ifdef HAVE_GLOB_NOMAGIC
4563 		result = glob(finalName, GLOB_MARK | GLOB_NOMAGIC, NULL, &amp;cfgFiles);
4564 		if(result == GLOB_NOMATCH) {
4565 	#else
4566 		result = glob(finalName, GLOB_MARK, NULL, &amp;cfgFiles);
4567 		if(result == GLOB_NOMATCH &amp;&amp; containsGlobWildcard((char*)finalName)) {
4568 	#endif 		goto done;
4569 	}
4570 	if(result == GLOB_NOSPACE || result == GLOB_ABORTED) {
4571 		if(optional == 0) {
4572 			rs_strerror_r(errno, errStr, sizeof(errStr));
4573 			if(getcwd(cwdBuf, sizeof(cwdBuf)) == NULL)
4574 				strcpy(cwdBuf, "??getcwd() failed??");
4575 			parser_errmsg("error accessing config file or directory '%s' "
4576 				"[cwd:%s]: %s", finalName, cwdBuf, errStr);
4577 			ret = 1;
4578 		}
4579 		goto done;
4580 	}
4581 	for(i = cfgFiles.gl_pathc - 1; i &gt;= 0 ; i--) {
4582 		cfgFile = cfgFiles.gl_pathv[i];
4583 		if(stat(cfgFile, &amp;fileInfo) != 0) {
4584 			if(optional == 0) {
4585 				rs_strerror_r(errno, errStr, sizeof(errStr));
4586 				if(getcwd(cwdBuf, sizeof(cwdBuf)) == NULL)
4587 					strcpy(cwdBuf, "??getcwd() failed??");
4588 				parser_errmsg("error accessing config file or directory '%s' "
4589 					"[cwd: %s]: %s", cfgFile, cwdBuf, errStr);
4590 				ret = 1;
4591 			}
4592 			goto done;
4593 		}
4594 		if(S_ISREG(fileInfo.st_mode)) { 			DBGPRINTF("requested to include config file '%s'\n", cfgFile);
4595 			cnfSetLexFile(cfgFile);
4596 		} else if(S_ISDIR(fileInfo.st_mode)) { 			DBGPRINTF("requested to include directory '%s'\n", cfgFile);
4597 			cnfDoInclude(cfgFile, optional);
4598 		} else {
4599 			DBGPRINTF("warning: unable to process IncludeConfig directive '%s'\n", cfgFile);
4600 		}
4601 	}
4602 done:
4603 	globfree(&amp;cfgFiles);
4604 	return ret;
4605 }
4606 void
4607 includeProcessCnf(struct nvlst *const lst)
4608 {
4609 	struct cnfparamvals *pvals = NULL;
4610 	const char *inc_file = NULL;
4611 	const char *text = NULL;
4612 	int optional = 0;
4613 	int abort_if_missing = 0;
4614 	int i;
4615 	if(lst == NULL) {
4616 		parser_errmsg("include() must have either 'file' or 'text' "
4617 			"parameter - ignored");
4618 		goto done;
4619 	}
4620 	if (nvlstChkDisabled(lst)) {
4621 		DBGPRINTF("include statement disabled\n");
4622 		goto done;
4623 	}
4624 	pvals = nvlstGetParams(lst, &amp;incpblk, NULL);
4625 	if(pvals == NULL) {
4626 		goto done;
4627 	}
4628 	DBGPRINTF("include param blk after includeProcessCnf:\n");
4629 	cnfparamsPrint(&amp;incpblk, pvals);
4630 	for(i = 0 ; i &lt; incpblk.nParams ; ++i) {
4631 		if(!pvals[i].bUsed) {
4632 			continue;
4633 		}
4634 		if(!strcmp(incpblk.descr[i].name, "file")) {
4635 			inc_file = es_str2cstr(pvals[i].val.d.estr, NULL);
4636 		} else if(!strcmp(incpblk.descr[i].name, "text")) {
4637 			text = es_str2cstr(pvals[i].val.d.estr, NULL);
4638 		} else if(!strcmp(incpblk.descr[i].name, "mode")) {
4639 			char *const md = es_str2cstr(pvals[i].val.d.estr, NULL);
4640 			if(!strcmp(md, "abort-if-missing")) {
4641 				optional = 0;
4642 				abort_if_missing = 1;
4643 			} else if(!strcmp(md, "required")) {
4644 				optional = 0;
4645 			} else if(!strcmp(md, "optional")) {
4646 				optional = 1;
4647 			} else {
4648 				parser_errmsg("invalid 'mode' parameter: '%s' - ignored", md);
4649 			}
4650 			free((void*)md);
4651 		} else {
4652 			LogError(0, RS_RET_INTERNAL_ERROR,
4653 				"rainerscript/include: program error, non-handled inclpblk "
4654 				"param '%s' in includeProcessCnf()", incpblk.descr[i].name);
4655 		}
4656 	}
4657 	if(text != NULL &amp;&amp; inc_file != NULL) {
4658 		parser_errmsg("include() must have either 'file' or 'text' "
4659 			"parameter, but both are set - ignored");
4660 		goto done;
4661 	}
4662 	if(inc_file != NULL) {
4663 		if(cnfDoInclude(inc_file, optional) != 0 &amp;&amp; abort_if_missing) {
4664 			fprintf(stderr, "include file '%s' mode is set to abort-if-missing "
4665 				"and the file is indeed missing - thus aborting rsyslog\n",
4666 				inc_file);
4667 			exit(1); 		}
4668 	} else if(text != NULL) {
4669 		es_str_t *estr = es_newStrFromCStr((char*)text, strlen(text));
4670 		es_addChar(&amp;estr, '\0');
4671 		es_addChar(&amp;estr, '\0');
4672 		cnfAddConfigBuffer(estr, "text");
4673 	} else {
4674 		parser_errmsg("include must have either 'file' or 'text' "
4675 			"parameter - ignored");
4676 		goto done;
4677 	}
4678 done:
4679 	free((void*)text);
4680 	free((void*)inc_file);
4681 	nvlstDestruct(lst);
4682 	if(pvals != NULL)
4683 		cnfparamvalsDestruct(pvals, &amp;incpblk);
4684 	return;
4685 }
4686 void
4687 varDelete(const struct svar *v)
4688 {
4689 	switch(v-&gt;datatype) {
4690 	case 'S':
4691 	case 'J':
4692 		varFreeMembers(v);
4693 		break;
4694 	case 'A':
4695 		cnfarrayContentDestruct(v-&gt;d.ar);
4696 		free(v-&gt;d.ar);
4697 		break;
4698 	default:break;
4699 	}
4700 }
4701 void
4702 cnfparamvalsDestruct(const struct cnfparamvals *paramvals, const struct cnfparamblk *blk)
4703 {
4704 	int i;
4705 	if(paramvals == NULL)
4706 		return;
4707 	for(i = 0 ; i &lt; blk-&gt;nParams ; ++i) {
4708 		if(paramvals[i].bUsed) {
4709 			varDelete(&amp;paramvals[i].val);
4710 		}
4711 	}
4712 	free((void*)paramvals);
4713 }
4714 int
4715 cnfparamGetIdx(struct cnfparamblk *params, const char *name)
4716 {
4717 	int i;
4718 	for(i = 0 ; i &lt; params-&gt;nParams ; ++i)
4719 		if(!strcmp(params-&gt;descr[i].name, name))
4720 			break;
4721 	if(i == params-&gt;nParams)
4722 		i = -1; 	return i;
4723 }
4724 void
4725 cstrPrint(const char *text, es_str_t *estr)
4726 {
4727 	char *str;
4728 	str = es_str2cstr(estr, NULL);
4729 	dbgprintf("%s%s", text, str);
4730 	free(str);
4731 }
4732 char *
4733 rmLeadingSpace(char *s)
4734 {
4735 	char *p;
4736 	for(p = s ; *p &amp;&amp; isspace(*p) ; ++p)
4737 		;
4738 	return(p);
4739 }
4740 rsRetVal
4741 initRainerscript(void)
4742 {
4743 	DEFiRet;
4744 	CHKmalloc(modListRoot = (struct modListNode*) malloc(sizeof(struct modListNode)));
4745 	modListRoot-&gt;version = 1;
4746 	modListRoot-&gt;modFcts = functions;
4747 	modListRoot-&gt;next = NULL;
4748 	modListLast = modListRoot;
4749 	iRet = objGetObjInterface(&amp;obj);
4750 finalize_it:
4751 	RETiRet;
4752 }
4753 static inline int
4754 isodigit(uchar c)
4755 {
4756 	return(c &gt;= '0' &amp;&amp; c &lt;= '7');
4757 }
4758 static int
4759 hexDigitVal(char c)
4760 {
4761 	int r;
4762 	if(c &lt; 'A')
4763 		r = c - '0';
4764 	else if(c &lt; 'a')
4765 		r = c - 'A' + 10;
4766 	else
4767 		r = c - 'a' + 10;
4768 	return r;
4769 }
4770 static void
4771 doUnescape(unsigned char *c, int len, int *iSrc, int iDst)
4772 {
4773 	if(c[*iSrc] == '\\') {
4774 		if(++(*iSrc) == len) {
4775 			c[iDst] = '\\';
4776 		}
4777 		switch(c[*iSrc]) {
4778 		case 'a':
4779 			c[iDst] = '\007';
4780 			break;
4781 		case 'b':
4782 			c[iDst] = '\b';
4783 			break;
4784 		case 'f':
4785 			c[iDst] = '\014';
4786 			break;
4787 		case 'n':
4788 			c[iDst] = '\n';
4789 			break;
4790 		case 'r':
4791 			c[iDst] = '\r';
4792 			break;
4793 		case 't':
4794 			c[iDst] = '\t';
4795 			break;
4796 		case '\'':
4797 			c[iDst] = '\'';
4798 			break;
4799 		case '"':
4800 			c[iDst] = '"';
4801 			break;
4802 		case '?':
4803 			c[iDst] = '?';
4804 			break;
4805 		case '$':
4806 			c[iDst] = '$';
4807 			break;
4808 		case '\\':
4809 			c[iDst] = '\\';
4810 			break;
4811 		case 'x':
4812 			if(    (*iSrc)+2 &gt;= len
4813 			   || !isxdigit(c[(*iSrc)+1])
4814 			   || !isxdigit(c[(*iSrc)+2])) {
4815 				c[iDst] = '\\';
4816 				--(*iSrc);
4817 			}
4818 			c[iDst] = (hexDigitVal(c[(*iSrc)+1]) &lt;&lt; 4) +
4819 				  hexDigitVal(c[(*iSrc)+2]);
4820 			*iSrc += 2;
4821 			break;
4822 		case '0': 		case '1':
4823 		case '2':
4824 		case '3':
4825 		case '4':
4826 		case '5':
4827 		case '6':
4828 		case '7':
4829 			if(    (*iSrc)+2 &gt;= len
4830 			   || !isodigit(c[(*iSrc)+1])
4831 			   || !isodigit(c[(*iSrc)+2])) {
4832 				c[iDst] = '\\';
4833 				--(*iSrc);
4834 			}
4835 			c[iDst] = ((c[(*iSrc)  ] - '0') &lt;&lt; 6) +
4836 			          ((c[(*iSrc)+1] - '0') &lt;&lt; 3) +
4837 			          ( c[(*iSrc)+2] - '0');
4838 			*iSrc += 2;
4839 			break;
4840 		default:
4841 			c[iDst] = '?';
4842 			break;
4843 		}
4844 	} else {
4845 		c[iDst] = c[*iSrc];
4846 	}
4847 }
4848 void
4849 unescapeStr(uchar *s, int len)
4850 {
4851 	int iSrc, iDst;
4852 	assert(s != NULL);
4853 	iSrc = 0;
4854 	while(iSrc &lt; len &amp;&amp; s[iSrc] != '\\')
4855 		++iSrc;
4856 	if(iSrc != len) {
4857 		iDst = iSrc;
4858 		while(iSrc &lt; len) {
4859 			doUnescape(s, len, &amp;iSrc, iDst);
4860 			++iSrc;
4861 			++iDst;
4862 		}
4863 		s[iDst] = '\0';
4864 	}
4865 }
4866 const char *
4867 tokenval2str(const int tok)
4868 {
4869 	if(tok &lt; 256) return "";
4870 	switch(tok) {
4871 	case NAME: return "NAME";
4872 	case FUNC: return "FUNC";
4873 	case BEGINOBJ: return "BEGINOBJ";
4874 	case ENDOBJ: return "ENDOBJ";
4875 	case BEGIN_ACTION: return "BEGIN_ACTION";
4876 	case BEGIN_PROPERTY: return "BEGIN_PROPERTY";
4877 	case BEGIN_CONSTANT: return "BEGIN_CONSTANT";
4878 	case BEGIN_TPL: return "BEGIN_TPL";
4879 	case BEGIN_INCLUDE: return "BEGIN_INCLUDE";
4880 	case BEGIN_RULESET: return "BEGIN_RULESET";
4881 	case STOP: return "STOP";
4882 	case SET: return "SET";
4883 	case UNSET: return "UNSET";
4884 	case CONTINUE: return "CONTINUE";
4885 	case CALL: return "CALL";
4886 	case LEGACY_ACTION: return "LEGACY_ACTION";
4887 	case LEGACY_RULESET: return "LEGACY_RULESET";
4888 	case PRIFILT: return "PRIFILT";
4889 	case PROPFILT: return "PROPFILT";
4890 	case BSD_TAG_SELECTOR: return "BSD_TAG_SELECTOR";
4891 	case BSD_HOST_SELECTOR: return "BSD_HOST_SELECTOR";
4892 	case IF: return "IF";
4893 	case THEN: return "THEN";
4894 	case ELSE: return "ELSE";
4895 	case OR: return "OR";
4896 	case AND: return "AND";
4897 	case NOT: return "NOT";
4898 	case VAR: return "VAR";
4899 	case STRING: return "STRING";
4900 	case NUMBER: return "NUMBER";
4901 	case CMP_EQ: return "CMP_EQ";
4902 	case CMP_NE: return "CMP_NE";
4903 	case CMP_LE: return "CMP_LE";
4904 	case CMP_GE: return "CMP_GE";
4905 	case CMP_LT: return "CMP_LT";
4906 	case CMP_GT: return "CMP_GT";
4907 	case CMP_CONTAINS: return "CMP_CONTAINS";
4908 	case CMP_CONTAINSI: return "CMP_CONTAINSI";
4909 	case CMP_STARTSWITH: return "CMP_STARTSWITH";
4910 	case CMP_STARTSWITHI: return "CMP_STARTSWITHI";
4911 	case UMINUS: return "UMINUS";
4912 	default: return "UNKNOWN TOKEN";
4913 	}
4914 }
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>omstdout.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 #include "config.h"
2 #include "rsyslog.h"
3 #include &lt;stdio.h&gt;
4 #include &lt;stdarg.h&gt;
5 #include &lt;stdlib.h&gt;
6 #include &lt;string.h&gt;
7 #include &lt;assert.h&gt;
8 #include &lt;signal.h&gt;
9 #include &lt;errno.h&gt;
10 #include &lt;unistd.h&gt;
11 #include "conf.h"
12 #include "syslogd-types.h"
13 #include "srUtils.h"
14 #include "template.h"
15 #include "module-template.h"
16 #include "errmsg.h"
17 #include "cfsysline.h"
18 MODULE_TYPE_OUTPUT
19 MODULE_TYPE_NOKEEP
20 MODULE_CNFNAME("omstdout")
21 static rsRetVal resetConfigVariables(uchar __attribute__((unused)) *pp, void __attribute__((unused)) *pVal);
22 DEF_OMOD_STATIC_DATA
23 typedef struct _instanceData {
24 	uchar *templateName;
25 } instanceData;
26 typedef struct wrkrInstanceData {
27 	instanceData *pData;
28 } wrkrInstanceData_t;
29 typedef struct configSettings_s {
30 	int bUseArrayInterface;			int bEnsureLFEnding;
31 	int templateName;
32 } configSettings_t;
33 static configSettings_t cs;
34 <a name="0"></a>static struct cnfparamdescr actpdescr[] = {
35 <font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>	{ "ensurelfending", eCmdHdlrBinary, 0 },
36 	{ "template", eCmdHdlrGetWord, 0 }
37 };
38 static struct cnfparamblk actpblk =
39 	{ CNFPARAMBLK_VERSION,
40 	  sizeof(actpdescr)/sizeof(struct cnfparamdescr),
41 	  actpdescr
42 	};</b></font>
43 struct modConfData_s {
44 	rsconf_t *pConf;	};
45 static modConfData_t *loadModConf = NULL;static modConfData_t *runModConf = NULL;
46 BEGINinitConfVars		CODESTARTinitConfVars
47 	resetConfigVariables(NULL, NULL);
48 ENDinitConfVars
49 BEGINcreateInstance
50 CODESTARTcreateInstance
51 ENDcreateInstance
52 BEGINcreateWrkrInstance
53 CODESTARTcreateWrkrInstance
54 ENDcreateWrkrInstance
55 BEGINbeginCnfLoad
56 CODESTARTbeginCnfLoad
57 	loadModConf = pModConf;
58 	pModConf-&gt;pConf = pConf;
59 ENDbeginCnfLoad
60 BEGINendCnfLoad
61 CODESTARTendCnfLoad
62 	loadModConf = NULL; ENDendCnfLoad
63 BEGINcheckCnf
64 CODESTARTcheckCnf
65 ENDcheckCnf
66 BEGINactivateCnf
67 CODESTARTactivateCnf
68 	runModConf = pModConf;
69 ENDactivateCnf
70 BEGINfreeCnf
71 CODESTARTfreeCnf
72 ENDfreeCnf
73 BEGINisCompatibleWithFeature
74 CODESTARTisCompatibleWithFeature
75 	if(eFeat == sFEATURERepeatedMsgReduction)
76 		iRet = RS_RET_OK;
77 ENDisCompatibleWithFeature
78 BEGINfreeInstance
79 CODESTARTfreeInstance
80 ENDfreeInstance
81 BEGINfreeWrkrInstance
82 CODESTARTfreeWrkrInstance
83 ENDfreeWrkrInstance
84 BEGINdbgPrintInstInfo
85 CODESTARTdbgPrintInstInfo
86 	dbgprintf("omstdout\n");
87 	dbgprintf("\tensureLFEnding='%d'\n", pData-&gt;bEnsureLFEnding);
88 	dbgprintf("\ttemplate='%s'\n", pData-&gt;templateName);
89 ENDdbgPrintInstInfo
90 BEGINtryResume
91 CODESTARTtryResume
92 ENDtryResume
93 BEGINdoAction
94 	char **szParams;
95 	char *toWrite;
96 	int iParamVal;
97 	int iParam;
98 	int iBuf;
99 	char szBuf[65564];
100 	size_t len;
101 	int r;
102 CODESTARTdoAction
103 dbgprintf("omstdout: in doAction\n");
104 	if(pWrkrData-&gt;pData-&gt;bUseArrayInterface) {
105 dbgprintf("omstdout: in ArrayInterface\n");
106 		szParams = (char**)(void*) (ppString[0]);
107 		iParam = 0;
108 		iBuf = 0;
109 		while(szParams[iParam] != NULL &amp;&amp; iBuf &lt; (int)sizeof(szBuf)-1) {
110 			if(iParam &gt; 0)
111 				szBuf[iBuf++] = ','; 			iParamVal = 0;
112 			while(szParams[iParam][iParamVal] != '\0' &amp;&amp; iBuf &lt; (int) sizeof(szBuf)-1) {
113 				szBuf[iBuf++] = szParams[iParam][iParamVal++];
114 			}
115 			++iParam;
116 		}
117 		szBuf[iBuf] = '\0';
118 		toWrite = szBuf;
119 	} else {
120 dbgprintf("omstdout: in else\n");
121 		toWrite = (char*) ppString[0];
122 	}
123 	len = strlen(toWrite);
124 dbgprintf("omstdout: len: %d, toWrite: %s\n", (int) len, toWrite);
125 	if((r = write(1, toWrite, len)) != (int) len) { 		DBGPRINTF("omstdout: error %d writing to stdout[%zd]: %s\n",
126 			r, len, toWrite);
127 	}
128 	if(pWrkrData-&gt;pData-&gt;bEnsureLFEnding &amp;&amp; toWrite[len-1] != '\n') {
129 		if((r = write(1, "\n", 1)) != 1) { 			DBGPRINTF("omstdout: error %d writing \\n to stdout\n",
130 				r);
131 		}
132 	}
133 ENDdoAction
134 static void
135 setInstParamDefaults(instanceData *pData)
136 {
137 	pData-&gt;bEnsureLFEnding = 1;
138 	pData-&gt;templateName = (uchar*) "RSYSLOG_FileFormat";
139 	pData-&gt;bUseArrayInterface = 0;
140 }
141 BEGINnewActInst
142 	struct cnfparamvals *pvals;
143 	int i;
144 	int bDestructPValsOnExit;
145 	uchar *tplToUse;
146 CODESTARTnewActInst
147 	DBGPRINTF("newActInst (omstdout)\n");
148 	bDestructPValsOnExit = 0;
149 	pvals = nvlstGetParams(lst, &amp;actpblk, NULL);
150 	if(pvals == NULL) {
151 		LogError(0, RS_RET_MISSING_CNFPARAMS, "omstdout: error reading "
152 				"config parameters");
153 		ABORT_FINALIZE(RS_RET_MISSING_CNFPARAMS);
154 	}
155 	bDestructPValsOnExit = 1;
156 	if(Debug) {
157 		dbgprintf("action param blk in omstdout:\n");
158 		cnfparamsPrint(&amp;actpblk, pvals);
159 	}
160 	CHKiRet(createInstance(&amp;pData));
161 	setInstParamDefaults(pData);
162 	for(i = 0 ; i &lt; actpblk.nParams ; ++i) {
163 		if(!pvals[i].bUsed) {
164 			continue;
165 		} else if(!strcmp(actpblk.descr[i].name, "ensurelfending")) {
166 			pData-&gt;bEnsureLFEnding = (int) pvals[i].val.d.n;
167 		} else if(!strcmp(actpblk.descr[i].name, "template")) {
168 			pData-&gt;templateName = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
169 		} else {
170 			DBGPRINTF("omstdout: program error, non-handled "
171 			  "param '%s'\n", actpblk.descr[i].name);
172 		}
173 	}
174 	CODE_STD_STRING_REQUESTnewActInst(1)
175 	tplToUse = (uchar*) strdup((pData-&gt;templateName == NULL) ? "RSYSLOG_FileFormat" : (char *)pData-&gt;templateName);
176 	CHKiRet(OMSRsetEntry(*ppOMSR, 0, tplToUse, OMSR_NO_RQD_TPL_OPTS));
177 CODE_STD_FINALIZERnewActInst
178 	if(bDestructPValsOnExit)
179 		cnfparamvalsDestruct(pvals, &amp;actpblk);
180 ENDnewActInst
181 BEGINparseSelectorAct
182 	int iTplOpts;
183 CODESTARTparseSelectorAct
184 CODE_STD_STRING_REQUESTparseSelectorAct(1)
185 	if(strncmp((char*) p, ":omstdout:", sizeof(":omstdout:") - 1)) {
186 		ABORT_FINALIZE(RS_RET_CONFLINE_UNPROCESSED);
187 	}
188 	p += sizeof(":omstdout:") - 1; 	CHKiRet(createInstance(&amp;pData));
189 	if(*(p-1) == ';')
190 		--p;
191 	iTplOpts = (cs.bUseArrayInterface == 0) ? 0 : OMSR_TPL_AS_ARRAY;
192 	CHKiRet(cflineParseTemplateName(&amp;p, *ppOMSR, 0, iTplOpts, (uchar*) "RSYSLOG_FileFormat"));
193 	pData-&gt;bUseArrayInterface = cs.bUseArrayInterface;
194 	pData-&gt;bEnsureLFEnding = cs.bEnsureLFEnding;
195 CODE_STD_FINALIZERparseSelectorAct
196 ENDparseSelectorAct
197 BEGINmodExit
198 CODESTARTmodExit
199 ENDmodExit
200 BEGINqueryEtryPt
201 CODESTARTqueryEtryPt
202 CODEqueryEtryPt_STD_OMOD_QUERIES
203 CODEqueryEtryPt_STD_OMOD8_QUERIES
204 CODEqueryEtryPt_STD_CONF2_CNFNAME_QUERIES
205 CODEqueryEtryPt_STD_CONF2_QUERIES
206 CODEqueryEtryPt_STD_CONF2_OMOD_QUERIES
207 ENDqueryEtryPt
208 static rsRetVal resetConfigVariables(uchar __attribute__((unused)) *pp, void __attribute__((unused)) *pVal)
209 {
210 	DEFiRet;
211 	cs.bUseArrayInterface = 0;
212 	cs.bEnsureLFEnding = 1;
213 	RETiRet;
214 }
215 BEGINmodInit()
216 	rsRetVal localRet;
217 	rsRetVal (*pomsrGetSupportedTplOpts)(unsigned long *pOpts);
218 	unsigned long opts;
219 	int bArrayPassingSupported;		CODESTARTmodInit
220 INITLegCnfVars
221 	*ipIFVersProvided = CURR_MOD_IF_VERSION; CODEmodInit_QueryRegCFSLineHdlr
222 	bArrayPassingSupported = 0;
223 	localRet = pHostQueryEtryPt((uchar*)"OMSRgetSupportedTplOpts", &amp;pomsrGetSupportedTplOpts);
224 	if(localRet == RS_RET_OK) {
225 		CHKiRet((*pomsrGetSupportedTplOpts)(&amp;opts));
226 		if(opts &amp; OMSR_TPL_AS_ARRAY)
227 			bArrayPassingSupported = 1;
228 	} else if(localRet != RS_RET_ENTRY_POINT_NOT_FOUND) {
229 		ABORT_FINALIZE(localRet); 	}
230 	DBGPRINTF("omstdout: array-passing is %ssupported by rsyslog core.\n", bArrayPassingSupported ? "" : "not ");
231 	if(bArrayPassingSupported) {
232 		CHKiRet(omsdRegCFSLineHdlr((uchar *)"actionomstdoutarrayinterface", 0, eCmdHdlrBinary, NULL,
233 			                   &amp;cs.bUseArrayInterface, STD_LOADABLE_MODULE_ID));
234 	}
235 	CHKiRet(omsdRegCFSLineHdlr((uchar *)"actionomstdoutensurelfending", 0, eCmdHdlrBinary, NULL,
236 				   &amp;cs.bEnsureLFEnding, STD_LOADABLE_MODULE_ID));
237 	CHKiRet(omsdRegCFSLineHdlr((uchar *)"resetconfigvariables", 1, eCmdHdlrCustomHandler,
238 				    resetConfigVariables, NULL, STD_LOADABLE_MODULE_ID));
239 ENDmodInit
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
