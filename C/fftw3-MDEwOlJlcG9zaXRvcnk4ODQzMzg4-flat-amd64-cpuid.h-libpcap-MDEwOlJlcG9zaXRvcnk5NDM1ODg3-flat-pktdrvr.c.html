
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 2.137767220902613%, Tokens: 9, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>fftw3-MDEwOlJlcG9zaXRvcnk4ODQzMzg4-flat-amd64-cpuid.h</h3>
            <pre><code>1  #ifdef _MSC_VER
2  #ifndef inline
3  #define inline __inline
4  #endif
5  #endif
6  #ifdef _MSC_VER
7  #include <intrin.h>
8  #if (_MSC_VER >= 1600) && !defined(__INTEL_COMPILER)
9  #include <immintrin.h>
10  #endif
11  #endif
12  static inline void
13  cpuid_all(int level, int ecxval, int *eax, int *ebx, int *ecx, int *edx)
14  {
15  #    ifdef _MSC_VER
16      int CPUInfo[4];
17  #if (_MSC_VER > 1500) || (_MSC_VER == 1500 & _MSC_FULL_VER >= 150030729)
18      __cpuidex(CPUInfo, level, ecxval);
19  #else
20      __cpuid(CPUInfo, level);
21  #endif
<span onclick='openModal()' class='match'>22      *eax = CPUInfo[0];
23      *ebx = CPUInfo[1];
24      *ecx = CPUInfo[2];
25      *edx = CPUInfo[3];
26  #    else
27      *eax = level;
28      *ecx = ecxval;
29      *ebx = 0;
30      *edx = 0;
31      __asm__ ("cpuid            \n\t"
32               : "+a" (*eax), "+b" (*ebx), "+c" (*ecx), "+d" (*edx));
33  #    endif
34  }
</span>35  static inline int cpuid_ecx(int op)
36  {
37  #    ifdef _MSC_VER
38  #    ifdef __INTEL_COMPILER
39       int result;
40       _asm {
41  	  push rbx
42            mov eax,op
43            cpuid
44            mov result,ecx
45            pop rbx
46       }
47       return result;
48  #    else
49       int cpu_info[4];
50       __cpuid(cpu_info,op);
51       return cpu_info[2];
52  #    endif
53  #    else
54       int eax, ecx = 0, edx;
55       __asm__("pushq %%rbx\n\tcpuid\n\tpopq %%rbx"
56  	     : "=a" (eax), "+c" (ecx), "=d" (edx)
57  	     : "a" (op));
58       return ecx;
59  #    endif
60  }
61  static inline int cpuid_ebx(int op)
62  {
63  #    ifdef _MSC_VER
64  #    ifdef __INTEL_COMPILER
65       int result;
66       _asm {
67            push rbx
68            mov eax,op
69            cpuid
70            mov result,ebx
71            pop rbx
72       }
73       return result;
74  #    else
75       int cpu_info[4];
76       __cpuid(cpu_info,op);
77       return cpu_info[1];
78  #    endif
79  #    else
80       int eax, ecx = 0, edx;
81       __asm__("pushq %%rbx\n\tcpuid\nmov %%ebx,%%ecx\n\tpopq %%rbx"
82               : "=a" (eax), "+c" (ecx), "=d" (edx)
83               : "a" (op));
84       return ecx;
85  #    endif
86  }
87  static inline int xgetbv_eax(int op)
88  {
89  #    ifdef _MSC_VER
90  #    ifdef __INTEL_COMPILER
91       int veax, vedx;
92       _asm {
93            mov ecx,op
94            xgetbv
95            mov veax,eax
96            mov vedx,edx
97       }
98       return veax;
99  #    else
100  #    if defined(_MSC_VER) && (_MSC_VER >= 1600)
101       unsigned __int64 result;
102       result = _xgetbv(op);
103       return (int)result;
104  #    else
105  #    error "Need at least Visual Studio 10 SP1 for AVX support"
106  #    endif
107  #    endif
108  #    else
109       int eax, edx;
110       __asm__ (".byte 0x0f, 0x01, 0xd0" : "=a"(eax), "=d"(edx) : "c" (op));
111       return eax;
112  #endif
113  }
</code></pre>
        </div>
        <div class="column">
            <h3>libpcap-MDEwOlJlcG9zaXRvcnk5NDM1ODg3-flat-pktdrvr.c</h3>
            <pre><code>1  #include <stdio.h>
2  #include <stdlib.h>
3  #include <string.h>
4  #include <dos.h>
5  #include "pcap-dos.h"
6  #include "pcap-int.h"
7  #include "msdos/pktdrvr.h"
8  #if (DOSX)
9  #define NUM_RX_BUF  32      &bsol;* # of buffers in Rx FIFO queue */
10  #else
11  #define NUM_RX_BUF  10
12  #endif
13  #define DIM(x)   (sizeof((x)) / sizeof(x[0]))
14  #define PUTS(s)  do {                                           \
15                     if (!pktInfo.quiet)                          \
16                        pktInfo.error ?                           \
17                          printf ("%s: %s\n", s, pktInfo.error) : \
18                          printf ("%s\n", pktInfo.error = s);     \
19                   } while (0)
20  #if defined(__HIGHC__)
21    extern UINT _mwenv;
22  #elif defined(__DJGPP__)
23    #include <stddef.h>
24    #include <dpmi.h>
25    #include <go32.h>
26    #include <pc.h>
27    #include <sys/farptr.h>
28  #elif defined(__WATCOMC__)
29    #include <i86.h>
30    #include <stddef.h>
31    extern char _Extender;
32  #else
33    extern void far PktReceiver (void);
34  #endif
35  #if (DOSX & (DJGPP|DOS4GW))
36    #include <sys/pack_on.h>
37    struct DPMI_regs {
38           DWORD  r_di;
39           DWORD  r_si;
40           DWORD  r_bp;
41           DWORD  reserved;
42           DWORD  r_bx;
43           DWORD  r_dx;
44           DWORD  r_cx;
45           DWORD  r_ax;
46           WORD   r_flags;
47           WORD   r_es, r_ds, r_fs, r_gs;
48           WORD   r_ip, r_cs, r_sp, r_ss;
49         };
50    typedef struct  {          &bsol;* must match data/code in pkt_rx1.s */
51            WORD       _rxOutOfs;
52            WORD       _rxInOfs;
53            DWORD      _pktDrop;
54            BYTE       _pktTemp [20];
55            TX_ELEMENT _pktTxBuf[1];
56            RX_ELEMENT _pktRxBuf[NUM_RX_BUF];
57            WORD       _dummy[2];        &bsol;* screenSeg,newInOffset */
58            BYTE       _fanChars[4];
59            WORD       _fanIndex;
60            BYTE       _PktReceiver[15]; &bsol;* starts on a paragraph (16byte) */
61          } PktRealStub;
62    #include <sys/pack_off.h>
63    static BYTE real_stub_array [] = {
64           #include "pkt_stub.inc"       &bsol;* generated opcode array */
65         };
66    #define rxOutOfs      offsetof (PktRealStub,_rxOutOfs)
67    #define rxInOfs       offsetof (PktRealStub,_rxInOfs)
68    #define PktReceiver   offsetof (PktRealStub,_PktReceiver [para_skip])
69    #define pktDrop       offsetof (PktRealStub,_pktDrop)
70    #define pktTemp       offsetof (PktRealStub,_pktTemp)
71    #define pktTxBuf      offsetof (PktRealStub,_pktTxBuf)
72    #define FIRST_RX_BUF  offsetof (PktRealStub,_pktRxBuf [0])
73    #define LAST_RX_BUF   offsetof (PktRealStub,_pktRxBuf [NUM_RX_BUF-1])
74  #else
75    extern WORD       rxOutOfs;    &bsol;* offsets into pktRxBuf FIFO queue   */
76    extern WORD       rxInOfs;
77    extern DWORD      pktDrop;     &bsol;* # packets dropped in PktReceiver() */
78    extern BYTE       pktRxEnd;    &bsol;* marks the end of r-mode code/data  */
79    extern RX_ELEMENT pktRxBuf [NUM_RX_BUF];       &bsol;* PktDrvr Rx buffers */
80    extern TX_ELEMENT pktTxBuf;                    &bsol;* PktDrvr Tx buffer  */
81    extern char       pktTemp[20];                 &bsol;* PktDrvr temp area  */
82    #define FIRST_RX_BUF (WORD) &pktRxBuf [0]
83    #define LAST_RX_BUF  (WORD) &pktRxBuf [NUM_RX_BUF-1]
84  #endif
85  #ifdef __BORLANDC__           &bsol;* Use Borland's inline functions */
86    #define memcpy  __memcpy__
87    #define memcmp  __memcmp__
88    #define memset  __memset__
89  #endif
90  #if (DOSX & PHARLAP)
91    extern void PktReceiver (void);     &bsol;* in pkt_rx0.asm */
92    static int  RealCopy    (ULONG, ULONG, REALPTR*, FARPTR*, USHORT*);
93    #undef  FP_SEG
94    #undef  FP_OFF
95    #define FP_OFF(x)     ((WORD)(x))
96    #define FP_SEG(x)     ((WORD)(realBase >> 16))
97    #define DOS_ADDR(s,o) (((DWORD)(s) << 16) + (WORD)(o))
98    #define r_ax          eax
99    #define r_bx          ebx
100    #define r_dx          edx
101    #define r_cx          ecx
102    #define r_si          esi
103    #define r_di          edi
104    #define r_ds          ds
105    #define r_es          es
106    LOCAL FARPTR          protBase;
107    LOCAL REALPTR         realBase;
108    LOCAL WORD            realSeg;   &bsol;* DOS para-address of allocated area */
109    LOCAL SWI_REGS        reg;
110    static WORD _far *rxOutOfsFp, *rxInOfsFp;
111  #elif (DOSX & DJGPP)
112    static _go32_dpmi_seginfo rm_mem;
113    static __dpmi_regs        reg;
114    static DWORD              realBase;
115    static int                para_skip = 0;
116    #define DOS_ADDR(s,o)     (((WORD)(s) << 4) + (o))
117    #define r_ax              x.ax
118    #define r_bx              x.bx
119    #define r_dx              x.dx
120    #define r_cx              x.cx
121    #define r_si              x.si
122    #define r_di              x.di
123    #define r_ds              x.ds
124    #define r_es              x.es
125  #elif (DOSX & DOS4GW)
126    LOCAL struct DPMI_regs    reg;
127    LOCAL WORD                rm_base_seg, rm_base_sel;
128    LOCAL DWORD               realBase;
129    LOCAL int                 para_skip = 0;
130    LOCAL DWORD dpmi_get_real_vector (int intr);
131    LOCAL WORD  dpmi_real_malloc     (int size, WORD *selector);
132    LOCAL void  dpmi_real_free       (WORD selector);
133    #define DOS_ADDR(s,o) (((DWORD)(s) << 4) + (WORD)(o))
134  #else              &bsol;* real-mode Borland etc. */
135    static struct  {
136           WORD r_ax, r_bx, r_cx, r_dx, r_bp;
137           WORD r_si, r_di, r_ds, r_es, r_flags;
138         } reg;
139  #endif
140  #ifdef __HIGHC__
141    #pragma Alias (pktDrop,    "_pktDrop")
142    #pragma Alias (pktRxBuf,   "_pktRxBuf")
143    #pragma Alias (pktTxBuf,   "_pktTxBuf")
144    #pragma Alias (pktTemp,    "_pktTemp")
145    #pragma Alias (rxOutOfs,   "_rxOutOfs")
146    #pragma Alias (rxInOfs,    "_rxInOfs")
147    #pragma Alias (pktRxEnd,   "_pktRxEnd")
148    #pragma Alias (PktReceiver,"_PktReceiver")
149  #endif
150  PUBLIC PKT_STAT    pktStat;    &bsol;* statistics for packets    */
151  PUBLIC PKT_INFO    pktInfo;    &bsol;* packet-driver information */
152  PUBLIC PKT_RX_MODE receiveMode  = PDRX_DIRECT;
153  PUBLIC ETHER       myAddress    = {   0,  0,  0,  0,  0,  0 };
154  PUBLIC ETHER       ethBroadcast = { 255,255,255,255,255,255 };
155  LOCAL  struct {             &bsol;* internal statistics */
156         DWORD  tooSmall;     &bsol;* size < ETH_MIN */
157         DWORD  tooLarge;     &bsol;* size > ETH_MAX */
158         DWORD  badSync;      &bsol;* count_1 != count_2 */
159         DWORD  wrongHandle;  &bsol;* upcall to wrong handle */
160       } intStat;
161  PUBLIC const char *PktGetErrorStr (int errNum)
162  {
163    static const char *errStr[] = {
164                      "",
165                      "Invalid handle number",
166                      "No interfaces of specified class found",
167                      "No interfaces of specified type found",
168                      "No interfaces of specified number found",
169                      "Bad packet type specified",
170                      "Interface does not support multicast",
171                      "Packet driver cannot terminate",
172                      "Invalid receiver mode specified",
173                      "Insufficient memory space",
174                      "Type previously accessed, and not released",
175                      "Command out of range, or not implemented",
176                      "Cannot send packet (usually hardware error)",
177                      "Cannot change hardware address ( > 1 handle open)",
178                      "Hardware address has bad length or format",
179                      "Cannot reset interface (more than 1 handle open)",
180                      "Bad Check-sum",
181                      "Bad size",
182                      "Bad sync" ,
183                      "Source hit"
184                    };
185    if (errNum < 0 || errNum >= DIM(errStr))
186       return ("Unknown driver error.");
187    return (errStr [errNum]);
188  }
189  PUBLIC const char *PktGetClassName (WORD class)
190  {
191    switch (class)
192    {
193      case PD_ETHER:
194           return ("DIX-Ether");
195      case PD_PRONET10:
196           return ("ProNET-10");
197      case PD_IEEE8025:
198           return ("IEEE 802.5");
199      case PD_OMNINET:
200           return ("OmniNet");
201      case PD_APPLETALK:
202           return ("AppleTalk");
203      case PD_SLIP:
204           return ("SLIP");
205      case PD_STARTLAN:
206           return ("StartLAN");
207      case PD_ARCNET:
208           return ("ArcNet");
209      case PD_AX25:
210           return ("AX.25");
211      case PD_KISS:
212           return ("KISS");
213      case PD_IEEE8023_2:
214           return ("IEEE 802.3 w/802.2 hdr");
215      case PD_FDDI8022:
216           return ("FDDI w/802.2 hdr");
217      case PD_X25:
218           return ("X.25");
219      case PD_LANstar:
220           return ("LANstar");
221      case PD_PPP:
222           return ("PPP");
223      default:
224           return ("unknown");
225    }
226  }
227  PUBLIC char const *PktRXmodeStr (PKT_RX_MODE mode)
228  {
229    static const char *modeStr [] = {
230                      "Receiver turned off",
231                      "Receive only directly addressed packets",
232                      "Receive direct & broadcast packets",
233                      "Receive direct,broadcast and limited multicast packets",
234                      "Receive direct,broadcast and all multicast packets",
235                      "Receive all packets (promiscuouos mode)"
236                    };
237    if (mode > DIM(modeStr))
238       return ("??");
239    return (modeStr [mode-1]);
240  }
241  LOCAL __inline BOOL PktInterrupt (void)
242  {
243    BOOL okay;
244  #if (DOSX & PHARLAP)
245    _dx_real_int ((UINT)pktInfo.intr, &reg);
246    okay = ((reg.flags & 1) == 0);  &bsol;* OK if carry clear */
247  #elif (DOSX & DJGPP)
248    __dpmi_int ((int)pktInfo.intr, &reg);
249    okay = ((reg.x.flags & 1) == 0);
250  #elif (DOSX & DOS4GW)
251    union  REGS  r;
252    struct SREGS s;
253    memset (&r, 0, sizeof(r));
254    segread (&s);
255    r.w.ax  = 0x300;
256    r.x.ebx = pktInfo.intr;
257    r.w.cx  = 0;
258    s.es    = FP_SEG (&reg);
259    r.x.edi = FP_OFF (&reg);
260    reg.r_flags = 0;
261    reg.r_ss = reg.r_sp = 0;     &bsol;* DPMI host provides stack */
262    int386x (0x31, &r, &r, &s);
263    okay = (!r.w.cflag);
264  #else
265    reg.r_flags = 0;
266    intr (pktInfo.intr, (struct REGPACK*)&reg);
267    okay = ((reg.r_flags & 1) == 0);
268  #endif
269    if (okay)
270         pktInfo.error = NULL;
271    else pktInfo.error = PktGetErrorStr (reg.r_dx >> 8);
272    return (okay);
273  }
274  PUBLIC BOOL PktSearchDriver (void)
275  {
276    BYTE intr  = 0x20;
277    BOOL found = FALSE;
278    while (!found && intr < 0xFF)
279    {
280      static char str[12];                 &bsol;* 3 + strlen("PKT DRVR") */
281      static char pktStr[9] = "PKT DRVR";  &bsol;* ASCIIZ string at ofs 3 */
282      DWORD  rp;                           &bsol;* in interrupt  routine  */
283  #if (DOSX & PHARLAP)
284      _dx_rmiv_get (intr, &rp);
285      ReadRealMem (&str, (REALPTR)rp, sizeof(str));
286  #elif (DOSX & DJGPP)
287      __dpmi_raddr realAdr;
288      __dpmi_get_real_mode_interrupt_vector (intr, &realAdr);
289      rp = (realAdr.segment << 4) + realAdr.offset16;
290      dosmemget (rp, sizeof(str), &str);
291  #elif (DOSX & DOS4GW)
292      rp = dpmi_get_real_vector (intr);
293      memcpy (&str, (void*)rp, sizeof(str));
294  #else
295      _fmemcpy (&str, getvect(intr), sizeof(str));
296  #endif
297      found = memcmp (&str[3],&pktStr,sizeof(pktStr)) == 0;
298      intr++;
299    }
300    pktInfo.intr = (found ? intr-1 : 0);
301    return (found);
302  }
303  static BOOL PktSetAccess (void)
304  {
305    reg.r_ax = 0x0200 + pktInfo.class;
306    reg.r_bx = 0xFFFF;
307    reg.r_dx = 0;
308    reg.r_cx = 0;
309  #if (DOSX & PHARLAP)
310    reg.ds  = 0;
311    reg.esi = 0;
312    reg.es  = RP_SEG (realBase);
313    reg.edi = (WORD) &PktReceiver;
314  #elif (DOSX & DJGPP)
315    reg.x.ds = 0;
316    reg.x.si = 0;
317    reg.x.es = rm_mem.rm_segment;
318    reg.x.di = PktReceiver;
319  #elif (DOSX & DOS4GW)
320    reg.r_ds = 0;
321    reg.r_si = 0;
322    reg.r_es = rm_base_seg;
323    reg.r_di = PktReceiver;
324  #else
325    reg.r_ds = 0;
326    reg.r_si = 0;
327    reg.r_es = FP_SEG (&PktReceiver);
328    reg.r_di = FP_OFF (&PktReceiver);
329  #endif
330    if (!PktInterrupt())
331       return (FALSE);
332    pktInfo.handle = reg.r_ax;
333    return (TRUE);
334  }
335  PUBLIC BOOL PktReleaseHandle (WORD handle)
336  {
337    reg.r_ax = 0x0300;
338    reg.r_bx = handle;
339    return PktInterrupt();
340  }
341  PUBLIC BOOL PktTransmit (const void *eth, int len)
342  {
343    if (len > ETH_MTU)
344       return (FALSE);
345    reg.r_ax = 0x0400;             &bsol;* Function 4, send pkt */
346    reg.r_cx = len;                &bsol;* total size of frame  */
347  #if (DOSX & DJGPP)
348    dosmemput (eth, len, realBase+pktTxBuf);
349    reg.x.ds = rm_mem.rm_segment;  &bsol;* DOS data segment and */
350    reg.x.si = pktTxBuf;           &bsol;* DOS offset to buffer */
351  #elif (DOSX & DOS4GW)
352    memcpy ((void*)(realBase+pktTxBuf), eth, len);
353    reg.r_ds = rm_base_seg;
354    reg.r_si = pktTxBuf;
355  #elif (DOSX & PHARLAP)
356    memcpy (&pktTxBuf, eth, len);
357    reg.r_ds = FP_SEG (&pktTxBuf);
358    reg.r_si = FP_OFF (&pktTxBuf);
359  #else
360    reg.r_ds = FP_SEG (eth);
361    reg.r_si = FP_OFF (eth);
362  #endif
363    return PktInterrupt();
364  }
365  #if (DOSX & (DJGPP|DOS4GW))
366  LOCAL __inline BOOL CheckElement (RX_ELEMENT *rx)
367  #else
368  LOCAL __inline BOOL CheckElement (RX_ELEMENT _far *rx)
369  #endif
370  {
371    WORD count_1, count_2;
372    if (rx->handle != pktInfo.handle)
373    {
374      pktInfo.error = "Wrong handle";
375      intStat.wrongHandle++;
376      PktReleaseHandle (rx->handle);
377      return (FALSE);
378    }
379    count_1 = rx->firstCount;
380    count_2 = rx->secondCount;
381    if (count_1 != count_2)
382    {
383      pktInfo.error = "Bad sync";
384      intStat.badSync++;
385      return (FALSE);
386    }
387    if (count_1 > ETH_MAX)
388    {
389      pktInfo.error = "Large esize";
390      intStat.tooLarge++;
391      return (FALSE);
392    }
393  #if 0
394    if (count_1 < ETH_MIN)
395    {
396      pktInfo.error = "Small esize";
397      intStat.tooSmall++;
398      return (FALSE);
399    }
400  #endif
401    return (TRUE);
402  }
403  PUBLIC BOOL PktTerminHandle (WORD handle)
404  {
405    reg.r_ax = 0x0500;
406    reg.r_bx = handle;
407    return PktInterrupt();
408  }
409  PUBLIC BOOL PktResetInterface (WORD handle)
410  {
411    reg.r_ax = 0x0700;
412    reg.r_bx = handle;
413    return PktInterrupt();
414  }
415  PUBLIC BOOL PktSetReceiverMode (PKT_RX_MODE mode)
416  {
417    if (pktInfo.class == PD_SLIP || pktInfo.class == PD_PPP)
418       return (TRUE);
419    reg.r_ax = 0x1400;
420    reg.r_bx = pktInfo.handle;
421    reg.r_cx = (WORD)mode;
422    if (!PktInterrupt())
423       return (FALSE);
424    receiveMode = mode;
425    return (TRUE);
426  }
427  PUBLIC BOOL PktGetReceiverMode (PKT_RX_MODE *mode)
428  {
429    reg.r_ax = 0x1500;
430    reg.r_bx = pktInfo.handle;
431    if (!PktInterrupt())
432       return (FALSE);
433    *mode = reg.r_ax;
434    return (TRUE);
435  }
436  static PKT_STAT initialStat;         &bsol;* statistics at startup */
437  static BOOL     resetStat = FALSE;   &bsol;* statistics reset ? */
438  PUBLIC BOOL PktGetStatistics (WORD handle)
439  {
440    reg.r_ax = 0x1800;
441    reg.r_bx = handle;
442    if (!PktInterrupt())
443       return (FALSE);
444  #if (DOSX & PHARLAP)
445    ReadRealMem (&pktStat, DOS_ADDR(reg.ds,reg.esi), sizeof(pktStat));
446  #elif (DOSX & DJGPP)
447    dosmemget (DOS_ADDR(reg.x.ds,reg.x.si), sizeof(pktStat), &pktStat);
448  #elif (DOSX & DOS4GW)
449    memcpy (&pktStat, (void*)DOS_ADDR(reg.r_ds,reg.r_si), sizeof(pktStat));
450  #else
451    _fmemcpy (&pktStat, MK_FP(reg.r_ds,reg.r_si), sizeof(pktStat));
452  #endif
453    return (TRUE);
454  }
455  PUBLIC BOOL PktSessStatistics (WORD handle)
456  {
457    if (!PktGetStatistics(pktInfo.handle))
458       return (FALSE);
459    if (resetStat)
460    {
<span onclick='openModal()' class='match'>461      pktStat.inPackets  -= initialStat.inPackets;
462      pktStat.outPackets -= initialStat.outPackets;
463      pktStat.inBytes    -= initialStat.inBytes;
464      pktStat.outBytes   -= initialStat.outBytes;
465      pktStat.inErrors   -= initialStat.inErrors;
466      pktStat.outErrors  -= initialStat.outErrors;
467      pktStat.outErrors  -= initialStat.outErrors;
468      pktStat.lost       -= initialStat.lost;
469    }
</span>470    return (TRUE);
471  }
472  PUBLIC BOOL PktResetStatistics (WORD handle)
473  {
474    if (!PktGetStatistics(pktInfo.handle))
475       return (FALSE);
476    memcpy (&initialStat, &pktStat, sizeof(initialStat));
477    resetStat = TRUE;
478    return (TRUE);
479  }
480  PUBLIC BOOL PktGetAddress (ETHER *addr)
481  {
482    reg.r_ax = 0x0600;
483    reg.r_bx = pktInfo.handle;
484    reg.r_cx = sizeof (*addr);
485  #if (DOSX & DJGPP)
486    reg.x.es = rm_mem.rm_segment;
487    reg.x.di = pktTemp;
488  #elif (DOSX & DOS4GW)
489    reg.r_es = rm_base_seg;
490    reg.r_di = pktTemp;
491  #else
492    reg.r_es = FP_SEG (&pktTemp);
493    reg.r_di = FP_OFF (&pktTemp);  &bsol;* ES:DI = address for result */
494  #endif
495    if (!PktInterrupt())
496       return (FALSE);
497  #if (DOSX & PHARLAP)
498    ReadRealMem (addr, realBase + (WORD)&pktTemp, sizeof(*addr));
499  #elif (DOSX & DJGPP)
500    dosmemget (realBase+pktTemp, sizeof(*addr), addr);
501  #elif (DOSX & DOS4GW)
502    memcpy (addr, (void*)(realBase+pktTemp), sizeof(*addr));
503  #else
504    memcpy ((void*)addr, &pktTemp, sizeof(*addr));
505  #endif
506    return (TRUE);
507  }
508  PUBLIC BOOL PktSetAddress (const ETHER *addr)
509  {
510  #if (DOSX & PHARLAP)
511    WriteRealMem (realBase + (WORD)&pktTemp, (void*)addr, sizeof(*addr));
512  #elif (DOSX & DJGPP)
513    dosmemput (addr, sizeof(*addr), realBase+pktTemp);
514  #elif (DOSX & DOS4GW)
515    memcpy ((void*)(realBase+pktTemp), addr, sizeof(*addr));
516  #else
517    memcpy (&pktTemp, (void*)addr, sizeof(*addr));
518  #endif
519    reg.r_ax = 0x1900;
520    reg.r_cx = sizeof (*addr);      &bsol;* address length       */
521  #if (DOSX & DJGPP)
522    reg.x.es = rm_mem.rm_segment;   &bsol;* DOS offset to param  */
523    reg.x.di = pktTemp;             &bsol;* DOS segment to param */
524  #elif (DOSX & DOS4GW)
525    reg.r_es = rm_base_seg;
526    reg.r_di = pktTemp;
527  #else
528    reg.r_es = FP_SEG (&pktTemp);
529    reg.r_di = FP_OFF (&pktTemp);
530  #endif
531    return PktInterrupt();
532  }
533  PUBLIC BOOL PktGetDriverInfo (void)
534  {
535    pktInfo.majVer = 0;
536    pktInfo.minVer = 0;
537    memset (&pktInfo.name, 0, sizeof(pktInfo.name));
538    reg.r_ax = 0x01FF;
539    reg.r_bx = 0;
540    if (!PktInterrupt())
541       return (FALSE);
542    pktInfo.number = reg.r_cx & 0xFF;
543    pktInfo.class  = reg.r_cx >> 8;
544  #if 0
545    pktInfo.minVer = reg.r_bx % 10;
546    pktInfo.majVer = reg.r_bx / 10;
547  #else
548    pktInfo.majVer = reg.r_bx;  
549  #endif
550    pktInfo.funcs  = reg.r_ax & 0xFF;
551    pktInfo.type   = reg.r_dx & 0xFF;
552  #if (DOSX & PHARLAP)
553    ReadRealMem (&pktInfo.name, DOS_ADDR(reg.ds,reg.esi), sizeof(pktInfo.name));
554  #elif (DOSX & DJGPP)
555    dosmemget (DOS_ADDR(reg.x.ds,reg.x.si), sizeof(pktInfo.name), &pktInfo.name);
556  #elif (DOSX & DOS4GW)
557    memcpy (&pktInfo.name, (void*)DOS_ADDR(reg.r_ds,reg.r_si), sizeof(pktInfo.name));
558  #else
559    _fmemcpy (&pktInfo.name, MK_FP(reg.r_ds,reg.r_si), sizeof(pktInfo.name));
560  #endif
561    return (TRUE);
562  }
563  PUBLIC BOOL PktGetDriverParam (void)
564  {
565    reg.r_ax = 0x0A00;
566    if (!PktInterrupt())
567       return (FALSE);
568  #if (DOSX & PHARLAP)
569    ReadRealMem (&pktInfo.majVer, DOS_ADDR(reg.es,reg.edi), PKT_PARAM_SIZE);
570  #elif (DOSX & DJGPP)
571    dosmemget (DOS_ADDR(reg.x.es,reg.x.di), PKT_PARAM_SIZE, &pktInfo.majVer);
572  #elif (DOSX & DOS4GW)
573    memcpy (&pktInfo.majVer, (void*)DOS_ADDR(reg.r_es,reg.r_di), PKT_PARAM_SIZE);
574  #else
575    _fmemcpy (&pktInfo.majVer, MK_FP(reg.r_es,reg.r_di), PKT_PARAM_SIZE);
576  #endif
577    return (TRUE);
578  }
579  #if (DOSX & PHARLAP)
580    PUBLIC int PktReceive (BYTE *buf, int max)
581    {
582      WORD inOfs  = *rxInOfsFp;
583      WORD outOfs = *rxOutOfsFp;
584      if (outOfs != inOfs)
585      {
586        RX_ELEMENT _far *head = (RX_ELEMENT _far*)(protBase+outOfs);
587        int size, len = max;
588        if (CheckElement(head))
589        {
590          size = min (head->firstCount, sizeof(RX_ELEMENT));
591          len  = min (size, max);
592          _fmemcpy (buf, &head->destin, len);
593        }
594        else
595          size = -1;
596        outOfs += sizeof (RX_ELEMENT);
597        if (outOfs > LAST_RX_BUF)
598            outOfs = FIRST_RX_BUF;
599        *rxOutOfsFp = outOfs;
600        return (size);
601      }
602      return (0);
603    }
604    PUBLIC void PktQueueBusy (BOOL busy)
605    {
606      *rxOutOfsFp = busy ? (*rxInOfsFp + sizeof(RX_ELEMENT)) : *rxInOfsFp;
607      if (*rxOutOfsFp > LAST_RX_BUF)
608          *rxOutOfsFp = FIRST_RX_BUF;
609      *(DWORD _far*)(protBase + (WORD)&pktDrop) = 0;
610    }
611    PUBLIC WORD PktBuffersUsed (void)
612    {
613      WORD inOfs  = *rxInOfsFp;
614      WORD outOfs = *rxOutOfsFp;
615      if (inOfs >= outOfs)
616         return (inOfs - outOfs) / sizeof(RX_ELEMENT);
617      return (NUM_RX_BUF - (outOfs - inOfs) / sizeof(RX_ELEMENT));
618    }
619    PUBLIC DWORD PktRxDropped (void)
620    {
621      return (*(DWORD _far*)(protBase + (WORD)&pktDrop));
622    }
623  #elif (DOSX & DJGPP)
624    PUBLIC int PktReceive (BYTE *buf, int max)
625    {
626      WORD ofs = _farpeekw (_dos_ds, realBase+rxOutOfs);
627      if (ofs != _farpeekw (_dos_ds, realBase+rxInOfs))
628      {
629        RX_ELEMENT head;
630        int  size, len = max;
631        head.firstCount  = _farpeekw (_dos_ds, realBase+ofs);
632        head.secondCount = _farpeekw (_dos_ds, realBase+ofs+2);
633        head.handle      = _farpeekw (_dos_ds, realBase+ofs+4);
634        if (CheckElement(&head))
635        {
636          size = min (head.firstCount, sizeof(RX_ELEMENT));
637          len  = min (size, max);
638          dosmemget (realBase+ofs+6, len, buf);
639        }
640        else
641          size = -1;
642        ofs += sizeof (RX_ELEMENT);
643        if (ofs > LAST_RX_BUF)
644             _farpokew (_dos_ds, realBase+rxOutOfs, FIRST_RX_BUF);
645        else _farpokew (_dos_ds, realBase+rxOutOfs, ofs);
646        return (size);
647      }
648      return (0);
649    }
650    PUBLIC void PktQueueBusy (BOOL busy)
651    {
652      WORD ofs;
653      disable();
654      ofs = _farpeekw (_dos_ds, realBase+rxInOfs);
655      if (busy)
656         ofs += sizeof (RX_ELEMENT);
657      if (ofs > LAST_RX_BUF)
658           _farpokew (_dos_ds, realBase+rxOutOfs, FIRST_RX_BUF);
659      else _farpokew (_dos_ds, realBase+rxOutOfs, ofs);
660      _farpokel (_dos_ds, realBase+pktDrop, 0UL);
661      enable();
662    }
663    PUBLIC WORD PktBuffersUsed (void)
664    {
665      WORD inOfs, outOfs;
666      disable();
667      inOfs  = _farpeekw (_dos_ds, realBase+rxInOfs);
668      outOfs = _farpeekw (_dos_ds, realBase+rxOutOfs);
669      enable();
670      if (inOfs >= outOfs)
671         return (inOfs - outOfs) / sizeof(RX_ELEMENT);
672      return (NUM_RX_BUF - (outOfs - inOfs) / sizeof(RX_ELEMENT));
673    }
674    PUBLIC DWORD PktRxDropped (void)
675    {
676      return _farpeekl (_dos_ds, realBase+pktDrop);
677    }
678  #elif (DOSX & DOS4GW)
679    PUBLIC int PktReceive (BYTE *buf, int max)
680    {
681      WORD ofs = *(WORD*) (realBase+rxOutOfs);
682      if (ofs != *(WORD*) (realBase+rxInOfs))
683      {
684        RX_ELEMENT head;
685        int  size, len = max;
686        head.firstCount  = *(WORD*) (realBase+ofs);
687        head.secondCount = *(WORD*) (realBase+ofs+2);
688        head.handle      = *(WORD*) (realBase+ofs+4);
689        if (CheckElement(&head))
690        {
691          size = min (head.firstCount, sizeof(RX_ELEMENT));
692          len  = min (size, max);
693          memcpy (buf, (const void*)(realBase+ofs+6), len);
694        }
695        else
696          size = -1;
697        ofs += sizeof (RX_ELEMENT);
698        if (ofs > LAST_RX_BUF)
699             *(WORD*) (realBase+rxOutOfs) = FIRST_RX_BUF;
700        else *(WORD*) (realBase+rxOutOfs) = ofs;
701        return (size);
702      }
703      return (0);
704    }
705    PUBLIC void PktQueueBusy (BOOL busy)
706    {
707      WORD ofs;
708      _disable();
709      ofs = *(WORD*) (realBase+rxInOfs);
710      if (busy)
711         ofs += sizeof (RX_ELEMENT);
712      if (ofs > LAST_RX_BUF)
713           *(WORD*) (realBase+rxOutOfs) = FIRST_RX_BUF;
714      else *(WORD*) (realBase+rxOutOfs) = ofs;
715      *(DWORD*) (realBase+pktDrop) = 0UL;
716      _enable();
717    }
718    PUBLIC WORD PktBuffersUsed (void)
719    {
720      WORD inOfs, outOfs;
721      _disable();
722      inOfs  = *(WORD*) (realBase+rxInOfs);
723      outOfs = *(WORD*) (realBase+rxOutOfs);
724      _enable();
725      if (inOfs >= outOfs)
726         return (inOfs - outOfs) / sizeof(RX_ELEMENT);
727      return (NUM_RX_BUF - (outOfs - inOfs) / sizeof(RX_ELEMENT));
728    }
729    PUBLIC DWORD PktRxDropped (void)
730    {
731      return *(DWORD*) (realBase+pktDrop);
732    }
733  #else     &bsol;* real-mode small/large model */
734    PUBLIC int PktReceive (BYTE *buf, int max)
735    {
736      if (rxOutOfs != rxInOfs)
737      {
738        RX_ELEMENT far *head = (RX_ELEMENT far*) MK_FP (_DS,rxOutOfs);
739        int  size, len = max;
740        if (CheckElement(head))
741        {
742          size = min (head->firstCount, sizeof(RX_ELEMENT));
743          len  = min (size, max);
744          _fmemcpy (buf, &head->destin, len);
745        }
746        else
747          size = -1;
748        rxOutOfs += sizeof (RX_ELEMENT);
749        if (rxOutOfs > LAST_RX_BUF)
750            rxOutOfs = FIRST_RX_BUF;
751        return (size);
752      }
753      return (0);
754    }
755    PUBLIC void PktQueueBusy (BOOL busy)
756    {
757      rxOutOfs = busy ? (rxInOfs + sizeof(RX_ELEMENT)) : rxInOfs;
758      if (rxOutOfs > LAST_RX_BUF)
759          rxOutOfs = FIRST_RX_BUF;
760      pktDrop = 0L;
761    }
762    PUBLIC WORD PktBuffersUsed (void)
763    {
764      WORD inOfs  = rxInOfs;
765      WORD outOfs = rxOutOfs;
766      if (inOfs >= outOfs)
767         return ((inOfs - outOfs) / sizeof(RX_ELEMENT));
768      return (NUM_RX_BUF - (outOfs - inOfs) / sizeof(RX_ELEMENT));
769    }
770    PUBLIC DWORD PktRxDropped (void)
771    {
772      return (pktDrop);
773    }
774  #endif
775  LOCAL __inline void PktFreeMem (void)
776  {
777  #if (DOSX & PHARLAP)
778    if (realSeg)
779    {
780      _dx_real_free (realSeg);
781      realSeg = 0;
782    }
783  #elif (DOSX & DJGPP)
784    if (rm_mem.rm_segment)
785    {
786      unsigned ofs;  &bsol;* clear the DOS-mem to prevent further upcalls */
787      for (ofs = 0; ofs < 16 * rm_mem.size / 4; ofs += 4)
788         _farpokel (_dos_ds, realBase + ofs, 0);
789      _go32_dpmi_free_dos_memory (&rm_mem);
790      rm_mem.rm_segment = 0;
791    }
792  #elif (DOSX & DOS4GW)
793    if (rm_base_sel)
794    {
795      dpmi_real_free (rm_base_sel);
796      rm_base_sel = 0;
797    }
798  #endif
799  }
800  PUBLIC BOOL PktExitDriver (void)
801  {
802    if (pktInfo.handle)
803    {
804      if (!PktSetReceiverMode(PDRX_BROADCAST))
805         PUTS ("Error restoring receiver mode.");
806      if (!PktReleaseHandle(pktInfo.handle))
807         PUTS ("Error releasing PKT-DRVR handle.");
808      PktFreeMem();
809      pktInfo.handle = 0;
810    }
811    if (pcap_pkt_debug >= 1)
812       printf ("Internal stats: too-small %lu, too-large %lu, bad-sync %lu, "
813               "wrong-handle %lu\n",
814               intStat.tooSmall, intStat.tooLarge,
815               intStat.badSync, intStat.wrongHandle);
816    return (TRUE);
817  }
818  #if (DOSX & (DJGPP|DOS4GW))
819  static void dump_pkt_stub (void)
820  {
821    int i;
822    fprintf (stderr, "PktReceiver %lu, pkt_stub[PktReceiver] =\n",
823             PktReceiver);
824    for (i = 0; i < 15; i++)
825        fprintf (stderr, "%02X, ", real_stub_array[i+PktReceiver]);
826    fputs ("\n", stderr);
827  }
828  #endif
829  PUBLIC BOOL PktInitDriver (PKT_RX_MODE mode)
830  {
831    PKT_RX_MODE rxMode;
832    BOOL   writeInfo = (pcap_pkt_debug >= 3);
833    pktInfo.quiet = (pcap_pkt_debug < 3);
834  #if (DOSX & PHARLAP) && defined(__HIGHC__)
835    if (_mwenv != 2)
836    {
837      fprintf (stderr, "Only Pharlap DOS extender supported.\n");
838      return (FALSE);
839    }
840  #endif
841  #if (DOSX & PHARLAP) && defined(__WATCOMC__)
842    if (_Extender != 1)
843    {
844      fprintf (stderr, "Only DOS4GW style extenders supported.\n");
845      return (FALSE);
846    }
847  #endif
848    if (!PktSearchDriver())
849    {
850      PUTS ("Packet driver not found.");
851      PktFreeMem();
852      return (FALSE);
853    }
854    if (!PktGetDriverInfo())
855    {
856      PUTS ("Error getting pkt-drvr information.");
857      PktFreeMem();
858      return (FALSE);
859    }
860  #if (DOSX & PHARLAP)
861    if (RealCopy((ULONG)&rxOutOfs, (ULONG)&pktRxEnd,
862                 &realBase, &protBase, (USHORT*)&realSeg))
863    {
864      rxOutOfsFp  = (WORD _far *) (protBase + (WORD) &rxOutOfs);
865      rxInOfsFp   = (WORD _far *) (protBase + (WORD) &rxInOfs);
866      *rxOutOfsFp = FIRST_RX_BUF;
867      *rxInOfsFp  = FIRST_RX_BUF;
868    }
869    else
870    {
871      PUTS ("Cannot allocate real-mode stub.");
872      return (FALSE);
873    }
874  #elif (DOSX & (DJGPP|DOS4GW))
875    if (sizeof(real_stub_array) > 0xFFFF)
876    {
877      fprintf (stderr, "`real_stub_array[]' too big.\n");
878      return (FALSE);
879    }
880  #if (DOSX & DJGPP)
881    rm_mem.size = (sizeof(real_stub_array) + 15) / 16;
882    if (_go32_dpmi_allocate_dos_memory(&rm_mem) || rm_mem.rm_offset != 0)
883    {
884      PUTS ("real-mode init failed.");
885      return (FALSE);
886    }
887    realBase = (rm_mem.rm_segment << 4);
888    dosmemput (&real_stub_array, sizeof(real_stub_array), realBase);
889    _farpokel (_dos_ds, realBase+rxOutOfs, FIRST_RX_BUF);
890    _farpokel (_dos_ds, realBase+rxInOfs,  FIRST_RX_BUF);
891  #elif (DOSX & DOS4GW)
892    rm_base_seg = dpmi_real_malloc (sizeof(real_stub_array), &rm_base_sel);
893    if (!rm_base_seg)
894    {
895      PUTS ("real-mode init failed.");
896      return (FALSE);
897    }
898    realBase = (rm_base_seg << 4);
899    memcpy ((void*)realBase, &real_stub_array, sizeof(real_stub_array));
900    *(WORD*) (realBase+rxOutOfs) = FIRST_RX_BUF;
901    *(WORD*) (realBase+rxInOfs)  = FIRST_RX_BUF;
902  #endif
903    {
904      int pushf = PktReceiver;
905      while (real_stub_array[pushf++] != 0x9C &&    &bsol;* pushf */
906             real_stub_array[pushf]   != 0xFA)      &bsol;* cli   */
907      {
908        if (++para_skip > 16)
909        {
910          fprintf (stderr, "Something wrong with `pkt_stub.inc'.\n");
911          para_skip = 0;
912          dump_pkt_stub();
913          return (FALSE);
914        }
915      }
916      if (*(WORD*)(real_stub_array + offsetof(PktRealStub,_dummy)) != 0xB800)
917      {
918        fprintf (stderr, "`real_stub_array[]' is misaligned.\n");
919        return (FALSE);
920      }
921    }
922    if (pcap_pkt_debug > 2)
923        dump_pkt_stub();
924  #else
925    rxOutOfs = FIRST_RX_BUF;
926    rxInOfs  = FIRST_RX_BUF;
927  #endif
928    if (!PktSetAccess())
929    {
930      PUTS ("Error setting pkt-drvr access.");
931      PktFreeMem();
932      return (FALSE);
933    }
934    if (!PktGetAddress(&myAddress))
935    {
936      PUTS ("Error fetching adapter address.");
937      PktFreeMem();
938      return (FALSE);
939    }
940    if (!PktSetReceiverMode(mode))
941    {
942      PUTS ("Error setting receiver mode.");
943      PktFreeMem();
944      return (FALSE);
945    }
946    if (!PktGetReceiverMode(&rxMode))
947    {
948      PUTS ("Error getting receiver mode.");
949      PktFreeMem();
950      return (FALSE);
951    }
952    if (writeInfo)
953       printf ("Pkt-driver information:\n"
954               "  Version  : %d.%d\n"
955               "  Name     : %.15s\n"
956               "  Class    : %u (%s)\n"
957               "  Type     : %u\n"
958               "  Number   : %u\n"
959               "  Funcs    : %u\n"
960               "  Intr     : %Xh\n"
961               "  Handle   : %u\n"
962               "  Extended : %s\n"
963               "  Hi-perf  : %s\n"
964               "  RX mode  : %s\n"
965               "  Eth-addr : %02X:%02X:%02X:%02X:%02X:%02X\n",
966               pktInfo.majVer, pktInfo.minVer, pktInfo.name,
967               pktInfo.class,  PktGetClassName(pktInfo.class),
968               pktInfo.type,   pktInfo.number,
969               pktInfo.funcs,  pktInfo.intr,   pktInfo.handle,
970               pktInfo.funcs == 2 || pktInfo.funcs == 6 ? "Yes" : "No",
971               pktInfo.funcs == 5 || pktInfo.funcs == 6 ? "Yes" : "No",
972               PktRXmodeStr(rxMode),
973               myAddress[0], myAddress[1], myAddress[2],
974               myAddress[3], myAddress[4], myAddress[5]);
975  #if defined(DEBUG) && (DOSX & PHARLAP)
976    if (writeInfo)
977    {
978      DWORD    rAdr = realBase + (WORD)&PktReceiver;
979      unsigned sel, ofs;
980      printf ("\nReceiver at   %04X:%04X\n", RP_SEG(rAdr),    RP_OFF(rAdr));
981      printf ("Realbase    = %04X:%04X\n",   RP_SEG(realBase),RP_OFF(realBase));
982      sel = _FP_SEG (protBase);
983      ofs = _FP_OFF (protBase);
984      printf ("Protbase    = %04X:%08X\n", sel,ofs);
985      printf ("RealSeg     = %04X\n", realSeg);
986      sel = _FP_SEG (rxOutOfsFp);
987      ofs = _FP_OFF (rxOutOfsFp);
988      printf ("rxOutOfsFp  = %04X:%08X\n", sel,ofs);
989      sel = _FP_SEG (rxInOfsFp);
990      ofs = _FP_OFF (rxInOfsFp);
991      printf ("rxInOfsFp   = %04X:%08X\n", sel,ofs);
992      printf ("Ready: *rxOutOfsFp = %04X *rxInOfsFp = %04X\n",
993              *rxOutOfsFp, *rxInOfsFp);
994      PktQueueBusy (TRUE);
995      printf ("Busy:  *rxOutOfsFp = %04X *rxInOfsFp = %04X\n",
996              *rxOutOfsFp, *rxInOfsFp);
997    }
998  #endif
999    memset (&pktStat, 0, sizeof(pktStat));  &bsol;* clear statistics */
1000    PktQueueBusy (TRUE);
1001    return (TRUE);
1002  }
1003  #if (DOSX & DOS4GW)
1004  LOCAL DWORD dpmi_get_real_vector (int intr)
1005  {
1006    union REGS r;
1007    r.x.eax = 0x200;
1008    r.x.ebx = (DWORD) intr;
1009    int386 (0x31, &r, &r);
1010    return ((r.w.cx << 4) + r.w.dx);
1011  }
1012  LOCAL WORD dpmi_real_malloc (int size, WORD *selector)
1013  {
1014    union REGS r;
1015    r.x.eax = 0x0100;             &bsol;* DPMI allocate DOS memory */
1016    r.x.ebx = (size + 15) / 16;   &bsol;* Number of paragraphs requested */
1017    int386 (0x31, &r, &r);
1018    if (r.w.cflag & 1)
1019       return (0);
1020    *selector = r.w.dx;
1021    return (r.w.ax);              &bsol;* Return segment address */
1022  }
1023  LOCAL void dpmi_real_free (WORD selector)
1024  {
1025    union REGS r;
1026    r.x.eax = 0x101;              &bsol;* DPMI free DOS memory */
1027    r.x.ebx = selector;           &bsol;* Selector to free */
1028    int386 (0x31, &r, &r);
1029  }
1030  #endif
1031  #if defined(DOSX) && (DOSX & PHARLAP)
1032  int RealCopy (ULONG    start_offs,
1033                ULONG    end_offs,
1034                REALPTR *real_basep,
1035                FARPTR  *prot_basep,
1036                USHORT  *rmem_adrp)
1037  {
1038    ULONG   rm_base;    &bsol;* base real mode para addr for accessing */
1039    UCHAR  *source;     &bsol;* source pointer for copy                */
1040    FARPTR  destin;     &bsol;* destination pointer for copy           */
1041    ULONG   len;        &bsol;* number of bytes to copy                */
1042    ULONG   temp;
1043    USHORT  stemp;
1044    if (start_offs >= end_offs || end_offs > 0x10000)
1045       return (FALSE);
1046    start_offs &= ~15;
1047    end_offs = (15 + (end_offs << 4)) >> 4;
1048    len = ((end_offs - start_offs) + 15) >> 4;
1049    if (_dx_real_above(len, rmem_adrp, &stemp) != _DOSE_NONE)
1050    {
1051      if (_dx_cmem_usage(0, 0, &temp, &temp) != _DOSE_NONE)
1052         return (FALSE);
1053      if (_dx_real_above(len, rmem_adrp, &stemp) != _DOSE_NONE)
1054         *rmem_adrp = 0;
1055      if (_dx_cmem_usage(0, 1, &temp, &temp) != _DOSE_NONE)
1056      {
1057        if (*rmem_adrp != 0)
1058           _dx_real_free (*rmem_adrp);
1059        return (FALSE);
1060      }
1061      if (*rmem_adrp == 0)
1062         return (FALSE);
1063    }
1064    rm_base = ((ULONG) *rmem_adrp) - (start_offs >> 4);
1065    RP_SET (*real_basep, 0, rm_base);
1066    FP_SET (*prot_basep, rm_base << 4, SS_DOSMEM);
1067    source = (UCHAR *) start_offs;
1068    destin = *prot_basep;
1069    FP_SET (destin, FP_OFF(*prot_basep) + start_offs, FP_SEL(*prot_basep));
1070    len = end_offs - start_offs;
1071    WriteFarMem (destin, source, len);
1072    return (TRUE);
1073  }
1074  #endif &bsol;* DOSX && (DOSX & PHARLAP) */
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from fftw3-MDEwOlJlcG9zaXRvcnk4ODQzMzg4-flat-amd64-cpuid.h</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from libpcap-MDEwOlJlcG9zaXRvcnk5NDM1ODg3-flat-pktdrvr.c</div>
                </div>
                <div class="column column_space"><pre><code>22      *eax = CPUInfo[0];
23      *ebx = CPUInfo[1];
24      *ecx = CPUInfo[2];
25      *edx = CPUInfo[3];
26  #    else
27      *eax = level;
28      *ecx = ecxval;
29      *ebx = 0;
30      *edx = 0;
31      __asm__ ("cpuid            \n\t"
32               : "+a" (*eax), "+b" (*ebx), "+c" (*ecx), "+d" (*edx));
33  #    endif
34  }
</pre></code></div>
                <div class="column column_space"><pre><code>461      pktStat.inPackets  -= initialStat.inPackets;
462      pktStat.outPackets -= initialStat.outPackets;
463      pktStat.inBytes    -= initialStat.inBytes;
464      pktStat.outBytes   -= initialStat.outBytes;
465      pktStat.inErrors   -= initialStat.inErrors;
466      pktStat.outErrors  -= initialStat.outErrors;
467      pktStat.outErrors  -= initialStat.outErrors;
468      pktStat.lost       -= initialStat.lost;
469    }
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    