
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 5.186880244088482%, Tokens: 8</h2>
        <div class="column">
            <h3>fftw3-MDEwOlJlcG9zaXRvcnk4ODQzMzg4-flat-trigtest.c</h3>
            <pre><code>1  #include <math.h>
2  #include <stdio.h>
3  #include <stdlib.h>
4  #ifndef USE_PARI
5  #define USE_PARI 1
6  #endif
7  typedef double trigreal;
8  #  define COS cos
9  #  define SIN sin
10  #  define TAN tan
11  #  define KTRIG(x) (x)
12  static const trigreal MYK2PI =
13      KTRIG(6.2831853071795864769252867665590057683943388);
14  #ifdef REALLY_ACCURATE
15  extern double fma (double X, double Y, double Z);
16  static void dbmul(double a, double b, double *x, double *dx)
17  {
18       *x = a * b; 
19       *dx = fma(a, b, -*x);
20  }
21  static void dbdiv(double a, double b, double *x, double *dx)
22  {
23       *x = a / b;
24       *dx = fma(-*x, b, a) / b;
25  }
26  static double by2pi(double m, double n)
27  {
28       static const double rpi2 =
29  	  6.28318530717958623199592693708837032318115234375;
30       static const double rpi2r = 
31  	  2.44929359829470635445213186455000211641949889184e-16;
32       double x, y, z, dx, dy, dz;
33       dbmul(rpi2, m, &x, &dx);      &bsol;* x + dx = rpi2 * m, exactly */
34       dbmul(rpi2r, m, &y, &dy);     &bsol;* x + dx = rpi2r * m, exactly */
35       y += dx;
36       dx = y + dy;
37       dbdiv(x, n, &y, &dy);      &bsol;* y + dy = x / n */
38       dbdiv(dx, n, &z, &dz);     &bsol;* z + dz = dx / n */
39       return ((z + dy) + dz) + y;
40  }
41  #else
42  static const trigreal K2PI =
43      KTRIG(6.2831853071795864769252867665590057683943388);
44  #define by2pi(m, n) ((K2PI * (m)) / (n))
45  #endif
46  static trigreal sin2pi0(trigreal m, trigreal n);
47  static trigreal cos2pi0(trigreal m, trigreal n)
48  {
49       if (m < 0) return cos2pi0(-m, n);
50       if (m > n * 0.5) return cos2pi0(n - m, n);
51       if (m > n * 0.25) return -sin2pi0(m - n * 0.25, n);
52       if (m > n * 0.125) return sin2pi0(n * 0.25 - m, n);
53       return COS(by2pi(m, n));
54  }
55  static trigreal sin2pi0(trigreal m, trigreal n)
56  {
57       if (m < 0) return -sin2pi0(-m, n);
58       if (m > n * 0.5) return -sin2pi0(n - m, n);
59       if (m > n * 0.25) return cos2pi0(m - n * 0.25, n);
60       if (m > n * 0.125) return cos2pi0(n * 0.25 - m, n);
61       return SIN(by2pi(m, n));
62  }
63  trigreal cos2pi(int m, int n)
64  {
65       return cos2pi0((trigreal)m, (trigreal)n);
66  }
67  trigreal sin2pi(int m, int n)
68  {
69       return sin2pi0((trigreal)m, (trigreal)n);
70  }
71  trigreal tan2pi(int m, int n)
72  {
73       trigreal dm = m, dn = n;
74       return TAN(by2pi(dm, dn));
75  }
76  trigreal naive_sin2pi(int m, int n)
77  {
78       return SIN(MYK2PI * ((trigreal) m / (trigreal) n));
79  }
80  trigreal naive_cos2pi(int m, int n)
81  {
82       return COS(MYK2PI * ((trigreal) m / (trigreal) n));
83  }
84  #if USE_PARI
85  #include <pari/pari.h>
86  long prec = 25;
87  double ck(long m, long n, double (*cf) (int, int), GEN(*gf) (GEN, long))
88  {
89       GEN gv, gcval, err, arg;
90       double cerr, cval;
<span onclick='openModal()' class='match'>91       long ltop = avma;
92       arg = mulsr(2L * m, divrs(gpi, n));
93       setlg(arg, prec);
94       gv = gf(arg, prec);
95       cval = cf(m, n);
96       gcval = dbltor(cval);
97       err = gsub(gcval, gv);
98       cerr = rtodbl(err);
99       avma = ltop;
</span>100       return cerr;
101  }
102  #else
103  double ck(long m, long n, double (*cf) (int, int), 
104  	  long double(*gf) (long double))
105  {
106       long double l2pi = 6.2831853071795864769252867665590057683943388L;
107       return cf(m, n) - gf(l2pi * (long double)m / (long double)n);
108  }
109  #define gsin sinl
110  #define gcos cosl
111  #endif
112  int main(int argc, char *argv[])
113  {
114       long nmin, nmax;
115       long n, m;
116  #if USE_PARI
117       pari_init(500000, 2);
118       mppi(prec);
119  #endif
120       if (argc > 1)
121  	  nmin = atoi(argv[1]);
122       else
123  	  nmin = 1024;
124       if (argc > 2)
125  	  nmax = atoi(argv[2]);
126       else
127  	  nmax = nmin;
128       for (n = nmin; n <= nmax; ++n) {
129  	  double maxe = 0.0, nmaxe = 0.0;;
130  	  for (m = 0; m < n; ++m) {
131  	       double e;
132  	       e = ck(m, n, sin2pi, gsin); if (e > maxe) maxe = e;
133  	       e = ck(m, n, cos2pi, gcos); if (e > maxe) maxe = e;
134  	       e = ck(m, n, naive_sin2pi, gsin); if (e > nmaxe) nmaxe = e;
135  	       e = ck(m, n, naive_cos2pi, gcos); if (e > nmaxe) nmaxe = e;
136  	  }
137  	  printf("%ld %g %g\n", n, maxe, nmaxe);
138       }
139       return 0;
140  }
</code></pre>
        </div>
        <div class="column">
            <h3>PINRemoteImage-MDEwOlJlcG9zaXRvcnkzOTUzNzEwMw==-flat-dec_sse2.c</h3>
            <pre><code>1  #include "src/dsp/dsp.h"
2  #if defined(WEBP_USE_SSE2)
3  #if !defined(USE_TRANSFORM_AC3)
4  #define USE_TRANSFORM_AC3 0   
5  #endif
6  #include <emmintrin.h>
7  #include "src/dsp/common_sse2.h"
8  #include "src/dec/vp8i_dec.h"
9  #include "src/utils/utils.h"
10  static void Transform_SSE2(const int16_t* in, uint8_t* dst, int do_two) {
11    const __m128i k1 = _mm_set1_epi16(20091);
12    const __m128i k2 = _mm_set1_epi16(-30068);
13    __m128i T0, T1, T2, T3;
14    __m128i in0, in1, in2, in3;
15    {
16      in0 = _mm_loadl_epi64((const __m128i*)&in[0]);
17      in1 = _mm_loadl_epi64((const __m128i*)&in[4]);
18      in2 = _mm_loadl_epi64((const __m128i*)&in[8]);
19      in3 = _mm_loadl_epi64((const __m128i*)&in[12]);
20      if (do_two) {
21        const __m128i inB0 = _mm_loadl_epi64((const __m128i*)&in[16]);
22        const __m128i inB1 = _mm_loadl_epi64((const __m128i*)&in[20]);
23        const __m128i inB2 = _mm_loadl_epi64((const __m128i*)&in[24]);
24        const __m128i inB3 = _mm_loadl_epi64((const __m128i*)&in[28]);
25        in0 = _mm_unpacklo_epi64(in0, inB0);
26        in1 = _mm_unpacklo_epi64(in1, inB1);
27        in2 = _mm_unpacklo_epi64(in2, inB2);
28        in3 = _mm_unpacklo_epi64(in3, inB3);
29      }
30    }
31    {
32      const __m128i a = _mm_add_epi16(in0, in2);
33      const __m128i b = _mm_sub_epi16(in0, in2);
34      const __m128i c1 = _mm_mulhi_epi16(in1, k2);
35      const __m128i c2 = _mm_mulhi_epi16(in3, k1);
36      const __m128i c3 = _mm_sub_epi16(in1, in3);
37      const __m128i c4 = _mm_sub_epi16(c1, c2);
38      const __m128i c = _mm_add_epi16(c3, c4);
39      const __m128i d1 = _mm_mulhi_epi16(in1, k1);
40      const __m128i d2 = _mm_mulhi_epi16(in3, k2);
41      const __m128i d3 = _mm_add_epi16(in1, in3);
42      const __m128i d4 = _mm_add_epi16(d1, d2);
43      const __m128i d = _mm_add_epi16(d3, d4);
44      const __m128i tmp0 = _mm_add_epi16(a, d);
45      const __m128i tmp1 = _mm_add_epi16(b, c);
46      const __m128i tmp2 = _mm_sub_epi16(b, c);
47      const __m128i tmp3 = _mm_sub_epi16(a, d);
48      VP8Transpose_2_4x4_16b(&tmp0, &tmp1, &tmp2, &tmp3, &T0, &T1, &T2, &T3);
49    }
50    {
51      const __m128i four = _mm_set1_epi16(4);
52      const __m128i dc = _mm_add_epi16(T0, four);
53      const __m128i a =  _mm_add_epi16(dc, T2);
54      const __m128i b =  _mm_sub_epi16(dc, T2);
55      const __m128i c1 = _mm_mulhi_epi16(T1, k2);
56      const __m128i c2 = _mm_mulhi_epi16(T3, k1);
57      const __m128i c3 = _mm_sub_epi16(T1, T3);
58      const __m128i c4 = _mm_sub_epi16(c1, c2);
59      const __m128i c = _mm_add_epi16(c3, c4);
60      const __m128i d1 = _mm_mulhi_epi16(T1, k1);
61      const __m128i d2 = _mm_mulhi_epi16(T3, k2);
62      const __m128i d3 = _mm_add_epi16(T1, T3);
63      const __m128i d4 = _mm_add_epi16(d1, d2);
64      const __m128i d = _mm_add_epi16(d3, d4);
65      const __m128i tmp0 = _mm_add_epi16(a, d);
66      const __m128i tmp1 = _mm_add_epi16(b, c);
67      const __m128i tmp2 = _mm_sub_epi16(b, c);
68      const __m128i tmp3 = _mm_sub_epi16(a, d);
69      const __m128i shifted0 = _mm_srai_epi16(tmp0, 3);
70      const __m128i shifted1 = _mm_srai_epi16(tmp1, 3);
71      const __m128i shifted2 = _mm_srai_epi16(tmp2, 3);
72      const __m128i shifted3 = _mm_srai_epi16(tmp3, 3);
73      VP8Transpose_2_4x4_16b(&shifted0, &shifted1, &shifted2, &shifted3, &T0, &T1,
74                             &T2, &T3);
75    }
76    {
77      const __m128i zero = _mm_setzero_si128();
78      __m128i dst0, dst1, dst2, dst3;
79      if (do_two) {
80        dst0 = _mm_loadl_epi64((__m128i*)(dst + 0 * BPS));
81        dst1 = _mm_loadl_epi64((__m128i*)(dst + 1 * BPS));
82        dst2 = _mm_loadl_epi64((__m128i*)(dst + 2 * BPS));
83        dst3 = _mm_loadl_epi64((__m128i*)(dst + 3 * BPS));
84      } else {
85        dst0 = _mm_cvtsi32_si128(WebPMemToUint32(dst + 0 * BPS));
86        dst1 = _mm_cvtsi32_si128(WebPMemToUint32(dst + 1 * BPS));
87        dst2 = _mm_cvtsi32_si128(WebPMemToUint32(dst + 2 * BPS));
88        dst3 = _mm_cvtsi32_si128(WebPMemToUint32(dst + 3 * BPS));
89      }
<span onclick='openModal()' class='match'>90      dst0 = _mm_unpacklo_epi8(dst0, zero);
91      dst1 = _mm_unpacklo_epi8(dst1, zero);
92      dst2 = _mm_unpacklo_epi8(dst2, zero);
93      dst3 = _mm_unpacklo_epi8(dst3, zero);
94      dst0 = _mm_add_epi16(dst0, T0);
95      dst1 = _mm_add_epi16(dst1, T1);
96      dst2 = _mm_add_epi16(dst2, T2);
97      dst3 = _mm_add_epi16(dst3, T3);
</span>98      dst0 = _mm_packus_epi16(dst0, dst0);
99      dst1 = _mm_packus_epi16(dst1, dst1);
100      dst2 = _mm_packus_epi16(dst2, dst2);
101      dst3 = _mm_packus_epi16(dst3, dst3);
102      if (do_two) {
103        _mm_storel_epi64((__m128i*)(dst + 0 * BPS), dst0);
104        _mm_storel_epi64((__m128i*)(dst + 1 * BPS), dst1);
105        _mm_storel_epi64((__m128i*)(dst + 2 * BPS), dst2);
106        _mm_storel_epi64((__m128i*)(dst + 3 * BPS), dst3);
107      } else {
108        WebPUint32ToMem(dst + 0 * BPS, _mm_cvtsi128_si32(dst0));
109        WebPUint32ToMem(dst + 1 * BPS, _mm_cvtsi128_si32(dst1));
110        WebPUint32ToMem(dst + 2 * BPS, _mm_cvtsi128_si32(dst2));
111        WebPUint32ToMem(dst + 3 * BPS, _mm_cvtsi128_si32(dst3));
112      }
113    }
114  }
115  #if (USE_TRANSFORM_AC3 == 1)
116  #define MUL(a, b) (((a) * (b)) >> 16)
117  static void TransformAC3(const int16_t* in, uint8_t* dst) {
118    static const int kC1 = 20091 + (1 << 16);
119    static const int kC2 = 35468;
120    const __m128i A = _mm_set1_epi16(in[0] + 4);
121    const __m128i c4 = _mm_set1_epi16(MUL(in[4], kC2));
122    const __m128i d4 = _mm_set1_epi16(MUL(in[4], kC1));
123    const int c1 = MUL(in[1], kC2);
124    const int d1 = MUL(in[1], kC1);
125    const __m128i CD = _mm_set_epi16(0, 0, 0, 0, -d1, -c1, c1, d1);
126    const __m128i B = _mm_adds_epi16(A, CD);
127    const __m128i m0 = _mm_adds_epi16(B, d4);
128    const __m128i m1 = _mm_adds_epi16(B, c4);
129    const __m128i m2 = _mm_subs_epi16(B, c4);
130    const __m128i m3 = _mm_subs_epi16(B, d4);
131    const __m128i zero = _mm_setzero_si128();
132    __m128i dst0 = _mm_cvtsi32_si128(WebPMemToUint32(dst + 0 * BPS));
133    __m128i dst1 = _mm_cvtsi32_si128(WebPMemToUint32(dst + 1 * BPS));
134    __m128i dst2 = _mm_cvtsi32_si128(WebPMemToUint32(dst + 2 * BPS));
135    __m128i dst3 = _mm_cvtsi32_si128(WebPMemToUint32(dst + 3 * BPS));
136    dst0 = _mm_unpacklo_epi8(dst0, zero);
137    dst1 = _mm_unpacklo_epi8(dst1, zero);
138    dst2 = _mm_unpacklo_epi8(dst2, zero);
139    dst3 = _mm_unpacklo_epi8(dst3, zero);
140    dst0 = _mm_adds_epi16(dst0, _mm_srai_epi16(m0, 3));
141    dst1 = _mm_adds_epi16(dst1, _mm_srai_epi16(m1, 3));
142    dst2 = _mm_adds_epi16(dst2, _mm_srai_epi16(m2, 3));
143    dst3 = _mm_adds_epi16(dst3, _mm_srai_epi16(m3, 3));
144    dst0 = _mm_packus_epi16(dst0, dst0);
145    dst1 = _mm_packus_epi16(dst1, dst1);
146    dst2 = _mm_packus_epi16(dst2, dst2);
147    dst3 = _mm_packus_epi16(dst3, dst3);
148    WebPUint32ToMem(dst + 0 * BPS, _mm_cvtsi128_si32(dst0));
149    WebPUint32ToMem(dst + 1 * BPS, _mm_cvtsi128_si32(dst1));
150    WebPUint32ToMem(dst + 2 * BPS, _mm_cvtsi128_si32(dst2));
151    WebPUint32ToMem(dst + 3 * BPS, _mm_cvtsi128_si32(dst3));
152  }
153  #undef MUL
154  #endif   
155  #define MM_ABS(p, q)  _mm_or_si128(                                            \
156      _mm_subs_epu8((q), (p)),                                                   \
157      _mm_subs_epu8((p), (q)))
158  static WEBP_INLINE void SignedShift8b_SSE2(__m128i* const x) {
159    const __m128i zero = _mm_setzero_si128();
160    const __m128i lo_0 = _mm_unpacklo_epi8(zero, *x);
161    const __m128i hi_0 = _mm_unpackhi_epi8(zero, *x);
162    const __m128i lo_1 = _mm_srai_epi16(lo_0, 3 + 8);
163    const __m128i hi_1 = _mm_srai_epi16(hi_0, 3 + 8);
164    *x = _mm_packs_epi16(lo_1, hi_1);
165  }
166  #define FLIP_SIGN_BIT2(a, b) {                                                 \
167    (a) = _mm_xor_si128(a, sign_bit);                                            \
168    (b) = _mm_xor_si128(b, sign_bit);                                            \
169  }
170  #define FLIP_SIGN_BIT4(a, b, c, d) {                                           \
171    FLIP_SIGN_BIT2(a, b);                                                        \
172    FLIP_SIGN_BIT2(c, d);                                                        \
173  }
174  static WEBP_INLINE void GetNotHEV_SSE2(const __m128i* const p1,
175                                         const __m128i* const p0,
176                                         const __m128i* const q0,
177                                         const __m128i* const q1,
178                                         int hev_thresh, __m128i* const not_hev) {
179    const __m128i zero = _mm_setzero_si128();
180    const __m128i t_1 = MM_ABS(*p1, *p0);
181    const __m128i t_2 = MM_ABS(*q1, *q0);
182    const __m128i h = _mm_set1_epi8(hev_thresh);
183    const __m128i t_max = _mm_max_epu8(t_1, t_2);
184    const __m128i t_max_h = _mm_subs_epu8(t_max, h);
185    *not_hev = _mm_cmpeq_epi8(t_max_h, zero);  
186  }
187  static WEBP_INLINE void GetBaseDelta_SSE2(const __m128i* const p1,
188                                            const __m128i* const p0,
189                                            const __m128i* const q0,
190                                            const __m128i* const q1,
191                                            __m128i* const delta) {
192    const __m128i p1_q1 = _mm_subs_epi8(*p1, *q1);   
193    const __m128i q0_p0 = _mm_subs_epi8(*q0, *p0);   
194    const __m128i s1 = _mm_adds_epi8(p1_q1, q0_p0);  
195    const __m128i s2 = _mm_adds_epi8(q0_p0, s1);     
196    const __m128i s3 = _mm_adds_epi8(q0_p0, s2);     
197    *delta = s3;
198  }
199  static WEBP_INLINE void DoSimpleFilter_SSE2(__m128i* const p0,
200                                              __m128i* const q0,
201                                              const __m128i* const fl) {
202    const __m128i k3 = _mm_set1_epi8(3);
203    const __m128i k4 = _mm_set1_epi8(4);
204    __m128i v3 = _mm_adds_epi8(*fl, k3);
205    __m128i v4 = _mm_adds_epi8(*fl, k4);
206    SignedShift8b_SSE2(&v4);             
207    SignedShift8b_SSE2(&v3);             
208    *q0 = _mm_subs_epi8(*q0, v4);        
209    *p0 = _mm_adds_epi8(*p0, v3);        
210  }
211  static WEBP_INLINE void Update2Pixels_SSE2(__m128i* const pi, __m128i* const qi,
212                                             const __m128i* const a0_lo,
213                                             const __m128i* const a0_hi) {
214    const __m128i a1_lo = _mm_srai_epi16(*a0_lo, 7);
215    const __m128i a1_hi = _mm_srai_epi16(*a0_hi, 7);
216    const __m128i delta = _mm_packs_epi16(a1_lo, a1_hi);
217    const __m128i sign_bit = _mm_set1_epi8((char)0x80);
218    *pi = _mm_adds_epi8(*pi, delta);
219    *qi = _mm_subs_epi8(*qi, delta);
220    FLIP_SIGN_BIT2(*pi, *qi);
221  }
222  static WEBP_INLINE void NeedsFilter_SSE2(const __m128i* const p1,
223                                           const __m128i* const p0,
224                                           const __m128i* const q0,
225                                           const __m128i* const q1,
226                                           int thresh, __m128i* const mask) {
227    const __m128i m_thresh = _mm_set1_epi8((char)thresh);
228    const __m128i t1 = MM_ABS(*p1, *q1);        
229    const __m128i kFE = _mm_set1_epi8((char)0xFE);
230    const __m128i t2 = _mm_and_si128(t1, kFE);  
231    const __m128i t3 = _mm_srli_epi16(t2, 1);   
232    const __m128i t4 = MM_ABS(*p0, *q0);        
233    const __m128i t5 = _mm_adds_epu8(t4, t4);   
234    const __m128i t6 = _mm_adds_epu8(t5, t3);   
235    const __m128i t7 = _mm_subs_epu8(t6, m_thresh);  
236    *mask = _mm_cmpeq_epi8(t7, _mm_setzero_si128());
237  }
238  static WEBP_INLINE void DoFilter2_SSE2(__m128i* const p1, __m128i* const p0,
239                                         __m128i* const q0, __m128i* const q1,
240                                         int thresh) {
241    __m128i a, mask;
242    const __m128i sign_bit = _mm_set1_epi8((char)0x80);
243    const __m128i p1s = _mm_xor_si128(*p1, sign_bit);
244    const __m128i q1s = _mm_xor_si128(*q1, sign_bit);
245    NeedsFilter_SSE2(p1, p0, q0, q1, thresh, &mask);
246    FLIP_SIGN_BIT2(*p0, *q0);
247    GetBaseDelta_SSE2(&p1s, p0, q0, &q1s, &a);
248    a = _mm_and_si128(a, mask);     
249    DoSimpleFilter_SSE2(p0, q0, &a);
250    FLIP_SIGN_BIT2(*p0, *q0);
251  }
252  static WEBP_INLINE void DoFilter4_SSE2(__m128i* const p1, __m128i* const p0,
253                                         __m128i* const q0, __m128i* const q1,
254                                         const __m128i* const mask,
255                                         int hev_thresh) {
256    const __m128i zero = _mm_setzero_si128();
257    const __m128i sign_bit = _mm_set1_epi8((char)0x80);
258    const __m128i k64 = _mm_set1_epi8(64);
259    const __m128i k3 = _mm_set1_epi8(3);
260    const __m128i k4 = _mm_set1_epi8(4);
261    __m128i not_hev;
262    __m128i t1, t2, t3;
263    GetNotHEV_SSE2(p1, p0, q0, q1, hev_thresh, &not_hev);
264    FLIP_SIGN_BIT4(*p1, *p0, *q0, *q1);
265    t1 = _mm_subs_epi8(*p1, *q1);        
266    t1 = _mm_andnot_si128(not_hev, t1);  
267    t2 = _mm_subs_epi8(*q0, *p0);        
268    t1 = _mm_adds_epi8(t1, t2);          
269    t1 = _mm_adds_epi8(t1, t2);          
270    t1 = _mm_adds_epi8(t1, t2);          
271    t1 = _mm_and_si128(t1, *mask);       
272    t2 = _mm_adds_epi8(t1, k3);        
273    t3 = _mm_adds_epi8(t1, k4);        
274    SignedShift8b_SSE2(&t2);           
275    SignedShift8b_SSE2(&t3);           
276    *p0 = _mm_adds_epi8(*p0, t2);      
277    *q0 = _mm_subs_epi8(*q0, t3);      
278    FLIP_SIGN_BIT2(*p0, *q0);
279    t2 = _mm_add_epi8(t3, sign_bit);
280    t3 = _mm_avg_epu8(t2, zero);
281    t3 = _mm_sub_epi8(t3, k64);
282    t3 = _mm_and_si128(not_hev, t3);   
283    *q1 = _mm_subs_epi8(*q1, t3);      
284    *p1 = _mm_adds_epi8(*p1, t3);      
285    FLIP_SIGN_BIT2(*p1, *q1);
286  }
287  static WEBP_INLINE void DoFilter6_SSE2(__m128i* const p2, __m128i* const p1,
288                                         __m128i* const p0, __m128i* const q0,
289                                         __m128i* const q1, __m128i* const q2,
290                                         const __m128i* const mask,
291                                         int hev_thresh) {
292    const __m128i zero = _mm_setzero_si128();
293    const __m128i sign_bit = _mm_set1_epi8((char)0x80);
294    __m128i a, not_hev;
295    GetNotHEV_SSE2(p1, p0, q0, q1, hev_thresh, &not_hev);
296    FLIP_SIGN_BIT4(*p1, *p0, *q0, *q1);
297    FLIP_SIGN_BIT2(*p2, *q2);
298    GetBaseDelta_SSE2(p1, p0, q0, q1, &a);
299    { 
300      const __m128i m = _mm_andnot_si128(not_hev, *mask);
301      const __m128i f = _mm_and_si128(a, m);
302      DoSimpleFilter_SSE2(p0, q0, &f);
303    }
304    { 
305      const __m128i k9 = _mm_set1_epi16(0x0900);
306      const __m128i k63 = _mm_set1_epi16(63);
307      const __m128i m = _mm_and_si128(not_hev, *mask);
308      const __m128i f = _mm_and_si128(a, m);
309      const __m128i f_lo = _mm_unpacklo_epi8(zero, f);
310      const __m128i f_hi = _mm_unpackhi_epi8(zero, f);
311      const __m128i f9_lo = _mm_mulhi_epi16(f_lo, k9);    
312      const __m128i f9_hi = _mm_mulhi_epi16(f_hi, k9);    
313      const __m128i a2_lo = _mm_add_epi16(f9_lo, k63);    
314      const __m128i a2_hi = _mm_add_epi16(f9_hi, k63);    
315      const __m128i a1_lo = _mm_add_epi16(a2_lo, f9_lo);  
316      const __m128i a1_hi = _mm_add_epi16(a2_hi, f9_hi);  
317      const __m128i a0_lo = _mm_add_epi16(a1_lo, f9_lo);  
318      const __m128i a0_hi = _mm_add_epi16(a1_hi, f9_hi);  
319      Update2Pixels_SSE2(p2, q2, &a2_lo, &a2_hi);
320      Update2Pixels_SSE2(p1, q1, &a1_lo, &a1_hi);
321      Update2Pixels_SSE2(p0, q0, &a0_lo, &a0_hi);
322    }
323  }
324  static WEBP_INLINE void Load8x4_SSE2(const uint8_t* const b, int stride,
325                                       __m128i* const p, __m128i* const q) {
326    const __m128i A0 = _mm_set_epi32(
327        WebPMemToUint32(&b[6 * stride]), WebPMemToUint32(&b[2 * stride]),
328        WebPMemToUint32(&b[4 * stride]), WebPMemToUint32(&b[0 * stride]));
329    const __m128i A1 = _mm_set_epi32(
330        WebPMemToUint32(&b[7 * stride]), WebPMemToUint32(&b[3 * stride]),
331        WebPMemToUint32(&b[5 * stride]), WebPMemToUint32(&b[1 * stride]));
332    const __m128i B0 = _mm_unpacklo_epi8(A0, A1);
333    const __m128i B1 = _mm_unpackhi_epi8(A0, A1);
334    const __m128i C0 = _mm_unpacklo_epi16(B0, B1);
335    const __m128i C1 = _mm_unpackhi_epi16(B0, B1);
336    *p = _mm_unpacklo_epi32(C0, C1);
337    *q = _mm_unpackhi_epi32(C0, C1);
338  }
339  static WEBP_INLINE void Load16x4_SSE2(const uint8_t* const r0,
340                                        const uint8_t* const r8,
341                                        int stride,
342                                        __m128i* const p1, __m128i* const p0,
343                                        __m128i* const q0, __m128i* const q1) {
344    Load8x4_SSE2(r0, stride, p1, q0);
345    Load8x4_SSE2(r8, stride, p0, q1);
346    {
347      const __m128i t1 = *p1;
348      const __m128i t2 = *q0;
349      *p1 = _mm_unpacklo_epi64(t1, *p0);
350      *p0 = _mm_unpackhi_epi64(t1, *p0);
351      *q0 = _mm_unpacklo_epi64(t2, *q1);
352      *q1 = _mm_unpackhi_epi64(t2, *q1);
353    }
354  }
355  static WEBP_INLINE void Store4x4_SSE2(__m128i* const x,
356                                        uint8_t* dst, int stride) {
357    int i;
358    for (i = 0; i < 4; ++i, dst += stride) {
359      WebPUint32ToMem(dst, _mm_cvtsi128_si32(*x));
360      *x = _mm_srli_si128(*x, 4);
361    }
362  }
363  static WEBP_INLINE void Store16x4_SSE2(const __m128i* const p1,
364                                         const __m128i* const p0,
365                                         const __m128i* const q0,
366                                         const __m128i* const q1,
367                                         uint8_t* r0, uint8_t* r8,
368                                         int stride) {
369    __m128i t1, p1_s, p0_s, q0_s, q1_s;
370    t1 = *p0;
371    p0_s = _mm_unpacklo_epi8(*p1, t1);
372    p1_s = _mm_unpackhi_epi8(*p1, t1);
373    t1 = *q0;
374    q0_s = _mm_unpacklo_epi8(t1, *q1);
375    q1_s = _mm_unpackhi_epi8(t1, *q1);
376    t1 = p0_s;
377    p0_s = _mm_unpacklo_epi16(t1, q0_s);
378    q0_s = _mm_unpackhi_epi16(t1, q0_s);
379    t1 = p1_s;
380    p1_s = _mm_unpacklo_epi16(t1, q1_s);
381    q1_s = _mm_unpackhi_epi16(t1, q1_s);
382    Store4x4_SSE2(&p0_s, r0, stride);
383    r0 += 4 * stride;
384    Store4x4_SSE2(&q0_s, r0, stride);
385    Store4x4_SSE2(&p1_s, r8, stride);
386    r8 += 4 * stride;
387    Store4x4_SSE2(&q1_s, r8, stride);
388  }
389  static void SimpleVFilter16_SSE2(uint8_t* p, int stride, int thresh) {
390    __m128i p1 = _mm_loadu_si128((__m128i*)&p[-2 * stride]);
391    __m128i p0 = _mm_loadu_si128((__m128i*)&p[-stride]);
392    __m128i q0 = _mm_loadu_si128((__m128i*)&p[0]);
393    __m128i q1 = _mm_loadu_si128((__m128i*)&p[stride]);
394    DoFilter2_SSE2(&p1, &p0, &q0, &q1, thresh);
395    _mm_storeu_si128((__m128i*)&p[-stride], p0);
396    _mm_storeu_si128((__m128i*)&p[0], q0);
397  }
398  static void SimpleHFilter16_SSE2(uint8_t* p, int stride, int thresh) {
399    __m128i p1, p0, q0, q1;
400    p -= 2;  
401    Load16x4_SSE2(p, p + 8 * stride, stride, &p1, &p0, &q0, &q1);
402    DoFilter2_SSE2(&p1, &p0, &q0, &q1, thresh);
403    Store16x4_SSE2(&p1, &p0, &q0, &q1, p, p + 8 * stride, stride);
404  }
405  static void SimpleVFilter16i_SSE2(uint8_t* p, int stride, int thresh) {
406    int k;
407    for (k = 3; k > 0; --k) {
408      p += 4 * stride;
409      SimpleVFilter16_SSE2(p, stride, thresh);
410    }
411  }
412  static void SimpleHFilter16i_SSE2(uint8_t* p, int stride, int thresh) {
413    int k;
414    for (k = 3; k > 0; --k) {
415      p += 4;
416      SimpleHFilter16_SSE2(p, stride, thresh);
417    }
418  }
419  #define MAX_DIFF1(p3, p2, p1, p0, m) do {                                      \
420    (m) = MM_ABS(p1, p0);                                                        \
421    (m) = _mm_max_epu8(m, MM_ABS(p3, p2));                                       \
422    (m) = _mm_max_epu8(m, MM_ABS(p2, p1));                                       \
423  } while (0)
424  #define MAX_DIFF2(p3, p2, p1, p0, m) do {                                      \
425    (m) = _mm_max_epu8(m, MM_ABS(p1, p0));                                       \
426    (m) = _mm_max_epu8(m, MM_ABS(p3, p2));                                       \
427    (m) = _mm_max_epu8(m, MM_ABS(p2, p1));                                       \
428  } while (0)
429  #define LOAD_H_EDGES4(p, stride, e1, e2, e3, e4) {                             \
430    (e1) = _mm_loadu_si128((__m128i*)&(p)[0 * (stride)]);                        \
431    (e2) = _mm_loadu_si128((__m128i*)&(p)[1 * (stride)]);                        \
432    (e3) = _mm_loadu_si128((__m128i*)&(p)[2 * (stride)]);                        \
433    (e4) = _mm_loadu_si128((__m128i*)&(p)[3 * (stride)]);                        \
434  }
435  #define LOADUV_H_EDGE(p, u, v, stride) do {                                    \
436    const __m128i U = _mm_loadl_epi64((__m128i*)&(u)[(stride)]);                 \
437    const __m128i V = _mm_loadl_epi64((__m128i*)&(v)[(stride)]);                 \
438    (p) = _mm_unpacklo_epi64(U, V);                                              \
439  } while (0)
440  #define LOADUV_H_EDGES4(u, v, stride, e1, e2, e3, e4) {                        \
441    LOADUV_H_EDGE(e1, u, v, 0 * (stride));                                       \
442    LOADUV_H_EDGE(e2, u, v, 1 * (stride));                                       \
443    LOADUV_H_EDGE(e3, u, v, 2 * (stride));                                       \
444    LOADUV_H_EDGE(e4, u, v, 3 * (stride));                                       \
445  }
446  #define STOREUV(p, u, v, stride) {                                             \
447    _mm_storel_epi64((__m128i*)&(u)[(stride)], p);                               \
448    (p) = _mm_srli_si128(p, 8);                                                  \
449    _mm_storel_epi64((__m128i*)&(v)[(stride)], p);                               \
450  }
451  static WEBP_INLINE void ComplexMask_SSE2(const __m128i* const p1,
452                                           const __m128i* const p0,
453                                           const __m128i* const q0,
454                                           const __m128i* const q1,
455                                           int thresh, int ithresh,
456                                           __m128i* const mask) {
457    const __m128i it = _mm_set1_epi8(ithresh);
458    const __m128i diff = _mm_subs_epu8(*mask, it);
459    const __m128i thresh_mask = _mm_cmpeq_epi8(diff, _mm_setzero_si128());
460    __m128i filter_mask;
461    NeedsFilter_SSE2(p1, p0, q0, q1, thresh, &filter_mask);
462    *mask = _mm_and_si128(thresh_mask, filter_mask);
463  }
464  static void VFilter16_SSE2(uint8_t* p, int stride,
465                             int thresh, int ithresh, int hev_thresh) {
466    __m128i t1;
467    __m128i mask;
468    __m128i p2, p1, p0, q0, q1, q2;
469    LOAD_H_EDGES4(p - 4 * stride, stride, t1, p2, p1, p0);
470    MAX_DIFF1(t1, p2, p1, p0, mask);
471    LOAD_H_EDGES4(p, stride, q0, q1, q2, t1);
472    MAX_DIFF2(t1, q2, q1, q0, mask);
473    ComplexMask_SSE2(&p1, &p0, &q0, &q1, thresh, ithresh, &mask);
474    DoFilter6_SSE2(&p2, &p1, &p0, &q0, &q1, &q2, &mask, hev_thresh);
475    _mm_storeu_si128((__m128i*)&p[-3 * stride], p2);
476    _mm_storeu_si128((__m128i*)&p[-2 * stride], p1);
477    _mm_storeu_si128((__m128i*)&p[-1 * stride], p0);
478    _mm_storeu_si128((__m128i*)&p[+0 * stride], q0);
479    _mm_storeu_si128((__m128i*)&p[+1 * stride], q1);
480    _mm_storeu_si128((__m128i*)&p[+2 * stride], q2);
481  }
482  static void HFilter16_SSE2(uint8_t* p, int stride,
483                             int thresh, int ithresh, int hev_thresh) {
484    __m128i mask;
485    __m128i p3, p2, p1, p0, q0, q1, q2, q3;
486    uint8_t* const b = p - 4;
487    Load16x4_SSE2(b, b + 8 * stride, stride, &p3, &p2, &p1, &p0);
488    MAX_DIFF1(p3, p2, p1, p0, mask);
489    Load16x4_SSE2(p, p + 8 * stride, stride, &q0, &q1, &q2, &q3);
490    MAX_DIFF2(q3, q2, q1, q0, mask);
491    ComplexMask_SSE2(&p1, &p0, &q0, &q1, thresh, ithresh, &mask);
492    DoFilter6_SSE2(&p2, &p1, &p0, &q0, &q1, &q2, &mask, hev_thresh);
493    Store16x4_SSE2(&p3, &p2, &p1, &p0, b, b + 8 * stride, stride);
494    Store16x4_SSE2(&q0, &q1, &q2, &q3, p, p + 8 * stride, stride);
495  }
496  static void VFilter16i_SSE2(uint8_t* p, int stride,
497                              int thresh, int ithresh, int hev_thresh) {
498    int k;
499    __m128i p3, p2, p1, p0;   
500    LOAD_H_EDGES4(p, stride, p3, p2, p1, p0);  
501    for (k = 3; k > 0; --k) {
502      __m128i mask, tmp1, tmp2;
503      uint8_t* const b = p + 2 * stride;   
504      p += 4 * stride;
505      MAX_DIFF1(p3, p2, p1, p0, mask);   
506      LOAD_H_EDGES4(p, stride, p3, p2, tmp1, tmp2);
507      MAX_DIFF2(p3, p2, tmp1, tmp2, mask);
508      ComplexMask_SSE2(&p1, &p0, &p3, &p2, thresh, ithresh, &mask);
509      DoFilter4_SSE2(&p1, &p0, &p3, &p2, &mask, hev_thresh);
510      _mm_storeu_si128((__m128i*)&b[0 * stride], p1);
511      _mm_storeu_si128((__m128i*)&b[1 * stride], p0);
512      _mm_storeu_si128((__m128i*)&b[2 * stride], p3);
513      _mm_storeu_si128((__m128i*)&b[3 * stride], p2);
514      p1 = tmp1;
515      p0 = tmp2;
516    }
517  }
518  static void HFilter16i_SSE2(uint8_t* p, int stride,
519                              int thresh, int ithresh, int hev_thresh) {
520    int k;
521    __m128i p3, p2, p1, p0;   
522    Load16x4_SSE2(p, p + 8 * stride, stride, &p3, &p2, &p1, &p0);  
523    for (k = 3; k > 0; --k) {
524      __m128i mask, tmp1, tmp2;
525      uint8_t* const b = p + 2;   
526      p += 4;  
527      MAX_DIFF1(p3, p2, p1, p0, mask);   
528      Load16x4_SSE2(p, p + 8 * stride, stride, &p3, &p2, &tmp1, &tmp2);
529      MAX_DIFF2(p3, p2, tmp1, tmp2, mask);
530      ComplexMask_SSE2(&p1, &p0, &p3, &p2, thresh, ithresh, &mask);
531      DoFilter4_SSE2(&p1, &p0, &p3, &p2, &mask, hev_thresh);
532      Store16x4_SSE2(&p1, &p0, &p3, &p2, b, b + 8 * stride, stride);
533      p1 = tmp1;
534      p0 = tmp2;
535    }
536  }
537  static void VFilter8_SSE2(uint8_t* u, uint8_t* v, int stride,
538                            int thresh, int ithresh, int hev_thresh) {
539    __m128i mask;
540    __m128i t1, p2, p1, p0, q0, q1, q2;
541    LOADUV_H_EDGES4(u - 4 * stride, v - 4 * stride, stride, t1, p2, p1, p0);
542    MAX_DIFF1(t1, p2, p1, p0, mask);
543    LOADUV_H_EDGES4(u, v, stride, q0, q1, q2, t1);
544    MAX_DIFF2(t1, q2, q1, q0, mask);
545    ComplexMask_SSE2(&p1, &p0, &q0, &q1, thresh, ithresh, &mask);
546    DoFilter6_SSE2(&p2, &p1, &p0, &q0, &q1, &q2, &mask, hev_thresh);
547    STOREUV(p2, u, v, -3 * stride);
548    STOREUV(p1, u, v, -2 * stride);
549    STOREUV(p0, u, v, -1 * stride);
550    STOREUV(q0, u, v, 0 * stride);
551    STOREUV(q1, u, v, 1 * stride);
552    STOREUV(q2, u, v, 2 * stride);
553  }
554  static void HFilter8_SSE2(uint8_t* u, uint8_t* v, int stride,
555                            int thresh, int ithresh, int hev_thresh) {
556    __m128i mask;
557    __m128i p3, p2, p1, p0, q0, q1, q2, q3;
558    uint8_t* const tu = u - 4;
559    uint8_t* const tv = v - 4;
560    Load16x4_SSE2(tu, tv, stride, &p3, &p2, &p1, &p0);
561    MAX_DIFF1(p3, p2, p1, p0, mask);
562    Load16x4_SSE2(u, v, stride, &q0, &q1, &q2, &q3);
563    MAX_DIFF2(q3, q2, q1, q0, mask);
564    ComplexMask_SSE2(&p1, &p0, &q0, &q1, thresh, ithresh, &mask);
565    DoFilter6_SSE2(&p2, &p1, &p0, &q0, &q1, &q2, &mask, hev_thresh);
566    Store16x4_SSE2(&p3, &p2, &p1, &p0, tu, tv, stride);
567    Store16x4_SSE2(&q0, &q1, &q2, &q3, u, v, stride);
568  }
569  static void VFilter8i_SSE2(uint8_t* u, uint8_t* v, int stride,
570                             int thresh, int ithresh, int hev_thresh) {
571    __m128i mask;
572    __m128i t1, t2, p1, p0, q0, q1;
573    LOADUV_H_EDGES4(u, v, stride, t2, t1, p1, p0);
574    MAX_DIFF1(t2, t1, p1, p0, mask);
575    u += 4 * stride;
576    v += 4 * stride;
577    LOADUV_H_EDGES4(u, v, stride, q0, q1, t1, t2);
578    MAX_DIFF2(t2, t1, q1, q0, mask);
579    ComplexMask_SSE2(&p1, &p0, &q0, &q1, thresh, ithresh, &mask);
580    DoFilter4_SSE2(&p1, &p0, &q0, &q1, &mask, hev_thresh);
581    STOREUV(p1, u, v, -2 * stride);
582    STOREUV(p0, u, v, -1 * stride);
583    STOREUV(q0, u, v, 0 * stride);
584    STOREUV(q1, u, v, 1 * stride);
585  }
586  static void HFilter8i_SSE2(uint8_t* u, uint8_t* v, int stride,
587                             int thresh, int ithresh, int hev_thresh) {
588    __m128i mask;
589    __m128i t1, t2, p1, p0, q0, q1;
590    Load16x4_SSE2(u, v, stride, &t2, &t1, &p1, &p0);   
591    MAX_DIFF1(t2, t1, p1, p0, mask);
592    u += 4;  
593    v += 4;
594    Load16x4_SSE2(u, v, stride, &q0, &q1, &t1, &t2);  
595    MAX_DIFF2(t2, t1, q1, q0, mask);
596    ComplexMask_SSE2(&p1, &p0, &q0, &q1, thresh, ithresh, &mask);
597    DoFilter4_SSE2(&p1, &p0, &q0, &q1, &mask, hev_thresh);
598    u -= 2;  
599    v -= 2;
600    Store16x4_SSE2(&p1, &p0, &q0, &q1, u, v, stride);
601  }
602  #define DST(x, y) dst[(x) + (y) * BPS]
603  #define AVG3(a, b, c) (((a) + 2 * (b) + (c) + 2) >> 2)
604  static void VE4_SSE2(uint8_t* dst) {    
605    const __m128i one = _mm_set1_epi8(1);
606    const __m128i ABCDEFGH = _mm_loadl_epi64((__m128i*)(dst - BPS - 1));
607    const __m128i BCDEFGH0 = _mm_srli_si128(ABCDEFGH, 1);
608    const __m128i CDEFGH00 = _mm_srli_si128(ABCDEFGH, 2);
609    const __m128i a = _mm_avg_epu8(ABCDEFGH, CDEFGH00);
610    const __m128i lsb = _mm_and_si128(_mm_xor_si128(ABCDEFGH, CDEFGH00), one);
611    const __m128i b = _mm_subs_epu8(a, lsb);
612    const __m128i avg = _mm_avg_epu8(b, BCDEFGH0);
613    const uint32_t vals = _mm_cvtsi128_si32(avg);
614    int i;
615    for (i = 0; i < 4; ++i) {
616      WebPUint32ToMem(dst + i * BPS, vals);
617    }
618  }
619  static void LD4_SSE2(uint8_t* dst) {   
620    const __m128i one = _mm_set1_epi8(1);
621    const __m128i ABCDEFGH = _mm_loadl_epi64((__m128i*)(dst - BPS));
622    const __m128i BCDEFGH0 = _mm_srli_si128(ABCDEFGH, 1);
623    const __m128i CDEFGH00 = _mm_srli_si128(ABCDEFGH, 2);
624    const __m128i CDEFGHH0 = _mm_insert_epi16(CDEFGH00, dst[-BPS + 7], 3);
625    const __m128i avg1 = _mm_avg_epu8(ABCDEFGH, CDEFGHH0);
626    const __m128i lsb = _mm_and_si128(_mm_xor_si128(ABCDEFGH, CDEFGHH0), one);
627    const __m128i avg2 = _mm_subs_epu8(avg1, lsb);
628    const __m128i abcdefg = _mm_avg_epu8(avg2, BCDEFGH0);
629    WebPUint32ToMem(dst + 0 * BPS, _mm_cvtsi128_si32(               abcdefg    ));
630    WebPUint32ToMem(dst + 1 * BPS, _mm_cvtsi128_si32(_mm_srli_si128(abcdefg, 1)));
631    WebPUint32ToMem(dst + 2 * BPS, _mm_cvtsi128_si32(_mm_srli_si128(abcdefg, 2)));
632    WebPUint32ToMem(dst + 3 * BPS, _mm_cvtsi128_si32(_mm_srli_si128(abcdefg, 3)));
633  }
634  static void VR4_SSE2(uint8_t* dst) {   
635    const __m128i one = _mm_set1_epi8(1);
636    const int I = dst[-1 + 0 * BPS];
637    const int J = dst[-1 + 1 * BPS];
638    const int K = dst[-1 + 2 * BPS];
639    const int X = dst[-1 - BPS];
640    const __m128i XABCD = _mm_loadl_epi64((__m128i*)(dst - BPS - 1));
641    const __m128i ABCD0 = _mm_srli_si128(XABCD, 1);
642    const __m128i abcd = _mm_avg_epu8(XABCD, ABCD0);
643    const __m128i _XABCD = _mm_slli_si128(XABCD, 1);
644    const __m128i IXABCD = _mm_insert_epi16(_XABCD, (short)(I | (X << 8)), 0);
645    const __m128i avg1 = _mm_avg_epu8(IXABCD, ABCD0);
646    const __m128i lsb = _mm_and_si128(_mm_xor_si128(IXABCD, ABCD0), one);
647    const __m128i avg2 = _mm_subs_epu8(avg1, lsb);
648    const __m128i efgh = _mm_avg_epu8(avg2, XABCD);
649    WebPUint32ToMem(dst + 0 * BPS, _mm_cvtsi128_si32(               abcd    ));
650    WebPUint32ToMem(dst + 1 * BPS, _mm_cvtsi128_si32(               efgh    ));
651    WebPUint32ToMem(dst + 2 * BPS, _mm_cvtsi128_si32(_mm_slli_si128(abcd, 1)));
652    WebPUint32ToMem(dst + 3 * BPS, _mm_cvtsi128_si32(_mm_slli_si128(efgh, 1)));
653    DST(0, 2) = AVG3(J, I, X);
654    DST(0, 3) = AVG3(K, J, I);
655  }
656  static void VL4_SSE2(uint8_t* dst) {   
657    const __m128i one = _mm_set1_epi8(1);
658    const __m128i ABCDEFGH = _mm_loadl_epi64((__m128i*)(dst - BPS));
659    const __m128i BCDEFGH_ = _mm_srli_si128(ABCDEFGH, 1);
660    const __m128i CDEFGH__ = _mm_srli_si128(ABCDEFGH, 2);
661    const __m128i avg1 = _mm_avg_epu8(ABCDEFGH, BCDEFGH_);
662    const __m128i avg2 = _mm_avg_epu8(CDEFGH__, BCDEFGH_);
663    const __m128i avg3 = _mm_avg_epu8(avg1, avg2);
664    const __m128i lsb1 = _mm_and_si128(_mm_xor_si128(avg1, avg2), one);
665    const __m128i ab = _mm_xor_si128(ABCDEFGH, BCDEFGH_);
666    const __m128i bc = _mm_xor_si128(CDEFGH__, BCDEFGH_);
667    const __m128i abbc = _mm_or_si128(ab, bc);
668    const __m128i lsb2 = _mm_and_si128(abbc, lsb1);
669    const __m128i avg4 = _mm_subs_epu8(avg3, lsb2);
670    const uint32_t extra_out = _mm_cvtsi128_si32(_mm_srli_si128(avg4, 4));
671    WebPUint32ToMem(dst + 0 * BPS, _mm_cvtsi128_si32(               avg1    ));
672    WebPUint32ToMem(dst + 1 * BPS, _mm_cvtsi128_si32(               avg4    ));
673    WebPUint32ToMem(dst + 2 * BPS, _mm_cvtsi128_si32(_mm_srli_si128(avg1, 1)));
674    WebPUint32ToMem(dst + 3 * BPS, _mm_cvtsi128_si32(_mm_srli_si128(avg4, 1)));
675    DST(3, 2) = (extra_out >> 0) & 0xff;
676    DST(3, 3) = (extra_out >> 8) & 0xff;
677  }
678  static void RD4_SSE2(uint8_t* dst) {   
679    const __m128i one = _mm_set1_epi8(1);
680    const __m128i XABCD = _mm_loadl_epi64((__m128i*)(dst - BPS - 1));
681    const __m128i ____XABCD = _mm_slli_si128(XABCD, 4);
682    const uint32_t I = dst[-1 + 0 * BPS];
683    const uint32_t J = dst[-1 + 1 * BPS];
684    const uint32_t K = dst[-1 + 2 * BPS];
685    const uint32_t L = dst[-1 + 3 * BPS];
686    const __m128i LKJI_____ =
687        _mm_cvtsi32_si128(L | (K << 8) | (J << 16) | (I << 24));
688    const __m128i LKJIXABCD = _mm_or_si128(LKJI_____, ____XABCD);
689    const __m128i KJIXABCD_ = _mm_srli_si128(LKJIXABCD, 1);
690    const __m128i JIXABCD__ = _mm_srli_si128(LKJIXABCD, 2);
691    const __m128i avg1 = _mm_avg_epu8(JIXABCD__, LKJIXABCD);
692    const __m128i lsb = _mm_and_si128(_mm_xor_si128(JIXABCD__, LKJIXABCD), one);
693    const __m128i avg2 = _mm_subs_epu8(avg1, lsb);
694    const __m128i abcdefg = _mm_avg_epu8(avg2, KJIXABCD_);
695    WebPUint32ToMem(dst + 3 * BPS, _mm_cvtsi128_si32(               abcdefg    ));
696    WebPUint32ToMem(dst + 2 * BPS, _mm_cvtsi128_si32(_mm_srli_si128(abcdefg, 1)));
697    WebPUint32ToMem(dst + 1 * BPS, _mm_cvtsi128_si32(_mm_srli_si128(abcdefg, 2)));
698    WebPUint32ToMem(dst + 0 * BPS, _mm_cvtsi128_si32(_mm_srli_si128(abcdefg, 3)));
699  }
700  #undef DST
701  #undef AVG3
702  static WEBP_INLINE void TrueMotion_SSE2(uint8_t* dst, int size) {
703    const uint8_t* top = dst - BPS;
704    const __m128i zero = _mm_setzero_si128();
705    int y;
706    if (size == 4) {
707      const __m128i top_values = _mm_cvtsi32_si128(WebPMemToUint32(top));
708      const __m128i top_base = _mm_unpacklo_epi8(top_values, zero);
709      for (y = 0; y < 4; ++y, dst += BPS) {
710        const int val = dst[-1] - top[-1];
711        const __m128i base = _mm_set1_epi16(val);
712        const __m128i out = _mm_packus_epi16(_mm_add_epi16(base, top_base), zero);
713        WebPUint32ToMem(dst, _mm_cvtsi128_si32(out));
714      }
715    } else if (size == 8) {
716      const __m128i top_values = _mm_loadl_epi64((const __m128i*)top);
717      const __m128i top_base = _mm_unpacklo_epi8(top_values, zero);
718      for (y = 0; y < 8; ++y, dst += BPS) {
719        const int val = dst[-1] - top[-1];
720        const __m128i base = _mm_set1_epi16(val);
721        const __m128i out = _mm_packus_epi16(_mm_add_epi16(base, top_base), zero);
722        _mm_storel_epi64((__m128i*)dst, out);
723      }
724    } else {
725      const __m128i top_values = _mm_loadu_si128((const __m128i*)top);
726      const __m128i top_base_0 = _mm_unpacklo_epi8(top_values, zero);
727      const __m128i top_base_1 = _mm_unpackhi_epi8(top_values, zero);
728      for (y = 0; y < 16; ++y, dst += BPS) {
729        const int val = dst[-1] - top[-1];
730        const __m128i base = _mm_set1_epi16(val);
731        const __m128i out_0 = _mm_add_epi16(base, top_base_0);
732        const __m128i out_1 = _mm_add_epi16(base, top_base_1);
733        const __m128i out = _mm_packus_epi16(out_0, out_1);
734        _mm_storeu_si128((__m128i*)dst, out);
735      }
736    }
737  }
738  static void TM4_SSE2(uint8_t* dst)   { TrueMotion_SSE2(dst, 4); }
739  static void TM8uv_SSE2(uint8_t* dst) { TrueMotion_SSE2(dst, 8); }
740  static void TM16_SSE2(uint8_t* dst)  { TrueMotion_SSE2(dst, 16); }
741  static void VE16_SSE2(uint8_t* dst) {
742    const __m128i top = _mm_loadu_si128((const __m128i*)(dst - BPS));
743    int j;
744    for (j = 0; j < 16; ++j) {
745      _mm_storeu_si128((__m128i*)(dst + j * BPS), top);
746    }
747  }
748  static void HE16_SSE2(uint8_t* dst) {     
749    int j;
750    for (j = 16; j > 0; --j) {
751      const __m128i values = _mm_set1_epi8(dst[-1]);
752      _mm_storeu_si128((__m128i*)dst, values);
753      dst += BPS;
754    }
755  }
756  static WEBP_INLINE void Put16_SSE2(uint8_t v, uint8_t* dst) {
757    int j;
758    const __m128i values = _mm_set1_epi8(v);
759    for (j = 0; j < 16; ++j) {
760      _mm_storeu_si128((__m128i*)(dst + j * BPS), values);
761    }
762  }
763  static void DC16_SSE2(uint8_t* dst) {  
764    const __m128i zero = _mm_setzero_si128();
765    const __m128i top = _mm_loadu_si128((const __m128i*)(dst - BPS));
766    const __m128i sad8x2 = _mm_sad_epu8(top, zero);
767    const __m128i sum = _mm_add_epi16(sad8x2, _mm_shuffle_epi32(sad8x2, 2));
768    int left = 0;
769    int j;
770    for (j = 0; j < 16; ++j) {
771      left += dst[-1 + j * BPS];
772    }
773    {
774      const int DC = _mm_cvtsi128_si32(sum) + left + 16;
775      Put16_SSE2(DC >> 5, dst);
776    }
777  }
778  static void DC16NoTop_SSE2(uint8_t* dst) {  
779    int DC = 8;
780    int j;
781    for (j = 0; j < 16; ++j) {
782      DC += dst[-1 + j * BPS];
783    }
784    Put16_SSE2(DC >> 4, dst);
785  }
786  static void DC16NoLeft_SSE2(uint8_t* dst) {  
787    const __m128i zero = _mm_setzero_si128();
788    const __m128i top = _mm_loadu_si128((const __m128i*)(dst - BPS));
789    const __m128i sad8x2 = _mm_sad_epu8(top, zero);
790    const __m128i sum = _mm_add_epi16(sad8x2, _mm_shuffle_epi32(sad8x2, 2));
791    const int DC = _mm_cvtsi128_si32(sum) + 8;
792    Put16_SSE2(DC >> 4, dst);
793  }
794  static void DC16NoTopLeft_SSE2(uint8_t* dst) {  
795    Put16_SSE2(0x80, dst);
796  }
797  static void VE8uv_SSE2(uint8_t* dst) {    
798    int j;
799    const __m128i top = _mm_loadl_epi64((const __m128i*)(dst - BPS));
800    for (j = 0; j < 8; ++j) {
801      _mm_storel_epi64((__m128i*)(dst + j * BPS), top);
802    }
803  }
804  static WEBP_INLINE void Put8x8uv_SSE2(uint8_t v, uint8_t* dst) {
805    int j;
806    const __m128i values = _mm_set1_epi8(v);
807    for (j = 0; j < 8; ++j) {
808      _mm_storel_epi64((__m128i*)(dst + j * BPS), values);
809    }
810  }
811  static void DC8uv_SSE2(uint8_t* dst) {     
812    const __m128i zero = _mm_setzero_si128();
813    const __m128i top = _mm_loadl_epi64((const __m128i*)(dst - BPS));
814    const __m128i sum = _mm_sad_epu8(top, zero);
815    int left = 0;
816    int j;
817    for (j = 0; j < 8; ++j) {
818      left += dst[-1 + j * BPS];
819    }
820    {
821      const int DC = _mm_cvtsi128_si32(sum) + left + 8;
822      Put8x8uv_SSE2(DC >> 4, dst);
823    }
824  }
825  static void DC8uvNoLeft_SSE2(uint8_t* dst) {   
826    const __m128i zero = _mm_setzero_si128();
827    const __m128i top = _mm_loadl_epi64((const __m128i*)(dst - BPS));
828    const __m128i sum = _mm_sad_epu8(top, zero);
829    const int DC = _mm_cvtsi128_si32(sum) + 4;
830    Put8x8uv_SSE2(DC >> 3, dst);
831  }
832  static void DC8uvNoTop_SSE2(uint8_t* dst) {  
833    int dc0 = 4;
834    int i;
835    for (i = 0; i < 8; ++i) {
836      dc0 += dst[-1 + i * BPS];
837    }
838    Put8x8uv_SSE2(dc0 >> 3, dst);
839  }
840  static void DC8uvNoTopLeft_SSE2(uint8_t* dst) {    
841    Put8x8uv_SSE2(0x80, dst);
842  }
843  extern void VP8DspInitSSE2(void);
844  WEBP_TSAN_IGNORE_FUNCTION void VP8DspInitSSE2(void) {
845    VP8Transform = Transform_SSE2;
846  #if (USE_TRANSFORM_AC3 == 1)
847    VP8TransformAC3 = TransformAC3_SSE2;
848  #endif
849    VP8VFilter16 = VFilter16_SSE2;
850    VP8HFilter16 = HFilter16_SSE2;
851    VP8VFilter8 = VFilter8_SSE2;
852    VP8HFilter8 = HFilter8_SSE2;
853    VP8VFilter16i = VFilter16i_SSE2;
854    VP8HFilter16i = HFilter16i_SSE2;
855    VP8VFilter8i = VFilter8i_SSE2;
856    VP8HFilter8i = HFilter8i_SSE2;
857    VP8SimpleVFilter16 = SimpleVFilter16_SSE2;
858    VP8SimpleHFilter16 = SimpleHFilter16_SSE2;
859    VP8SimpleVFilter16i = SimpleVFilter16i_SSE2;
860    VP8SimpleHFilter16i = SimpleHFilter16i_SSE2;
861    VP8PredLuma4[1] = TM4_SSE2;
862    VP8PredLuma4[2] = VE4_SSE2;
863    VP8PredLuma4[4] = RD4_SSE2;
864    VP8PredLuma4[5] = VR4_SSE2;
865    VP8PredLuma4[6] = LD4_SSE2;
866    VP8PredLuma4[7] = VL4_SSE2;
867    VP8PredLuma16[0] = DC16_SSE2;
868    VP8PredLuma16[1] = TM16_SSE2;
869    VP8PredLuma16[2] = VE16_SSE2;
870    VP8PredLuma16[3] = HE16_SSE2;
871    VP8PredLuma16[4] = DC16NoTop_SSE2;
872    VP8PredLuma16[5] = DC16NoLeft_SSE2;
873    VP8PredLuma16[6] = DC16NoTopLeft_SSE2;
874    VP8PredChroma8[0] = DC8uv_SSE2;
875    VP8PredChroma8[1] = TM8uv_SSE2;
876    VP8PredChroma8[2] = VE8uv_SSE2;
877    VP8PredChroma8[4] = DC8uvNoTop_SSE2;
878    VP8PredChroma8[5] = DC8uvNoLeft_SSE2;
879    VP8PredChroma8[6] = DC8uvNoTopLeft_SSE2;
880  }
881  #else  
882  WEBP_DSP_INIT_STUB(VP8DspInitSSE2)
883  #endif  
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from fftw3-MDEwOlJlcG9zaXRvcnk4ODQzMzg4-flat-trigtest.c</div>
                <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from PINRemoteImage-MDEwOlJlcG9zaXRvcnkzOTUzNzEwMw==-flat-dec_sse2.c</div>
                <div class="column column_space"><pre><code>91       long ltop = avma;
92       arg = mulsr(2L * m, divrs(gpi, n));
93       setlg(arg, prec);
94       gv = gf(arg, prec);
95       cval = cf(m, n);
96       gcval = dbltor(cval);
97       err = gsub(gcval, gv);
98       cerr = rtodbl(err);
99       avma = ltop;
</pre></code></div>
                <div class="column column_space"><pre><code>90      dst0 = _mm_unpacklo_epi8(dst0, zero);
91      dst1 = _mm_unpacklo_epi8(dst1, zero);
92      dst2 = _mm_unpacklo_epi8(dst2, zero);
93      dst3 = _mm_unpacklo_epi8(dst3, zero);
94      dst0 = _mm_add_epi16(dst0, T0);
95      dst1 = _mm_add_epi16(dst1, T1);
96      dst2 = _mm_add_epi16(dst2, T2);
97      dst3 = _mm_add_epi16(dst3, T3);
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    