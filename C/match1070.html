<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html><head><title>Matches for inf-discovery-avahi.c &amp; inf-gtk-browser-store.c</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for inf-discovery-avahi.c &amp; inf-gtk-browser-store.c
      </h3>
<h1 align="center">
        10.0%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>inf-discovery-avahi.c (12.694878%)<th>inf-gtk-browser-store.c (8.321168%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(1212-1235)<td><a href="#" name="0">(1137-1162)</a><td align="center"><font color="#ff0000">17</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(1254-1279)<td><a href="#" name="1">(1163-1188)</a><td align="center"><font color="#e10000">15</font>
<tr onclick='openModal("#980517")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#980517"><font color="#980517">-</font><td><a href="#" name="2">(1120-1141)<td><a href="#" name="2">(1083-1097)</a><td align="center"><font color="#e10000">15</font>
<tr onclick='openModal("#53858b")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#53858b"><font color="#53858b">-</font><td><a href="#" name="3">(100-145)<td><a href="#" name="3">(66-95)</a><td align="center"><font color="#e10000">15</font>
<tr onclick='openModal("#6cc417")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#6cc417"><font color="#6cc417">-</font><td><a href="#" name="4">(1165-1177)<td><a href="#" name="4">(1122-1134)</a><td align="center"><font color="#d20000">14</font>
<tr onclick='openModal("#151b8d")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#151b8d"><font color="#151b8d">-</font><td><a href="#" name="5">(1094-1115)<td><a href="#" name="5">(2252-2266)</a><td align="center"><font color="#d20000">14</font>
<tr onclick='openModal("#8c8774")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#8c8774"><font color="#8c8774">-</font><td><a href="#" name="6">(925-945)<td><a href="#" name="6">(330-353)</a><td align="center"><font color="#b40000">12</font>
<tr onclick='openModal("#38a4a5")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#38a4a5"><font color="#38a4a5">-</font><td><a href="#" name="7">(775-801)<td><a href="#" name="7">(215-245)</a><td align="center"><font color="#b40000">12</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>inf-discovery-avahi.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
/* libinfinity - a GObject-based infinote implementation
 * Copyright (C) 2007-2015 Armin Burgmeier &lt;armin@arbur.net&gt;
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston,
 * MA 02110-1301, USA.
 */

/**
 * SECTION:inf-discovery-avahi
 * @short_description: Service Discovery via Avahi
 * @include: libinfinity/common/inf-discovery-avahi.h
 * @see_also: #InfDiscovery, #InfLocalPublisher
 *
 * #InfDiscoveryAvahi implements the #InfDiscovery and #InfLocalPublisher
 * interfaces on top of avahi. It resolves services to client-side
 * #InfXmppConnection&lt;!-- --&gt;s.
 *
 * This class is only available if the macro
 * &lt;literal&gt;LIBINFINITY_HAVE_AVAHI&lt;/literal&gt; is defined.
 */

#include &lt;libinfinity/common/inf-discovery-avahi.h&gt;
#include &lt;libinfinity/common/inf-discovery.h&gt;
#include &lt;libinfinity/common/inf-local-publisher.h&gt;
#include &lt;libinfinity/inf-i18n.h&gt;
#include &lt;libinfinity/inf-config.h&gt; /* LIBINFINITY_HAVE_AVAHI */

#ifdef LIBINFINITY_HAVE_AVAHI

#include &lt;avahi-client/client.h&gt;
#include &lt;avahi-client/lookup.h&gt;
#include &lt;avahi-client/publish.h&gt;
#include &lt;avahi-common/watch.h&gt;
#include &lt;avahi-common/malloc.h&gt;
#include &lt;avahi-common/timeval.h&gt;
#include &lt;avahi-common/alternative.h&gt;
#include &lt;avahi-common/error.h&gt;

#include &lt;sys/socket.h&gt; /* Required by FreeBSD, see #430 */
#include &lt;net/if.h&gt; /* For if_indextoname */
#include &lt;string.h&gt;

struct AvahiWatch {
  InfDiscoveryAvahi* avahi;
  InfIoWatch* watch;

  InfNativeSocket socket;
  AvahiWatchEvent occurred_events;

  AvahiWatchCallback callback;
  void* userdata;
};

struct AvahiTimeout {
  InfDiscoveryAvahi* avahi;
  InfIoTimeout* timeout;
  AvahiTimeoutCallback callback;
  void* userdata;
};

typedef struct _InfDiscoveryAvahiInfoResolv InfDiscoveryAvahiInfoResolv;
struct _InfDiscoveryAvahiInfoResolv {
  InfDiscoveryResolvCompleteFunc complete_func;
  gpointer user_data;
};

struct _InfDiscoveryInfo {
  gchar* service_name;
  /* pointing to InfDiscoveryAvahiDiscoverInfo.type: */
  const gchar* service_type;
  gchar* domain;

  AvahiIfIndex interface;
  AvahiProtocol protocol;

  AvahiServiceResolver* service_resolver;
  InfXmppConnection* resolved;

  GSList* resolv;
};

struct _InfLocalPublisherItem {
  gchar* type;
  char* name;
<a name="3"></a>  guint port;

  AvahiEntryGroup* entry_group;
<font color="#53858b"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>};

typedef struct _InfDiscoveryAvahiDiscoverInfo InfDiscoveryAvahiDiscoverInfo;
struct _InfDiscoveryAvahiDiscoverInfo {
  gchar* type; /* also used as key in hash table */
  AvahiServiceBrowser* service_browser;
  GSList* discovered;
};

typedef struct _InfDiscoveryAvahiPrivate InfDiscoveryAvahiPrivate;
struct _InfDiscoveryAvahiPrivate {
  AvahiPoll poll;

  InfIo* io;
  InfXmppManager* xmpp_manager;
  InfXmppConnectionSecurityPolicy security_policy;
  InfKeepalive keepalive;

  InfCertificateCredentials* creds;
  InfSaslContext* sasl_context;
  gchar* sasl_mechanisms;

  AvahiClient* client;

  GSList* published;
  GHashTable* discovered; /* type -&gt; InfDiscoveryAvahiDiscoverInfo */
};

enum {
  PROP_0,

  /* construct only */
  PROP_XMPP_MANAGER,
  PROP_IO,

  /* read/write */
  PROP_CREDENTIALS,
  PROP_SASL_CONTEXT,
  PROP_SASL_MECHANISMS,
  PROP_SECURITY_POLICY,
  PROP_KEEPALIVE
};

#define INF_DISCOVERY_AVAHI_PRIVATE(obj) (G_TYPE_INSTANCE_GET_PRIVATE((obj), INF_TYPE_DISCOVERY_AVAHI, InfDiscoveryAvahiPrivate))

static GQuark inf_discovery_avahi_error_quark;</b></font>

static void inf_discovery_avahi_discovery_iface_init(InfDiscoveryInterface* iface);
static void inf_discovery_avahi_local_publisher_iface_init(InfLocalPublisherInterface* iface);
G_DEFINE_TYPE_WITH_CODE(InfDiscoveryAvahi, inf_discovery_avahi, G_TYPE_OBJECT,
  G_ADD_PRIVATE(InfDiscoveryAvahi)
  G_IMPLEMENT_INTERFACE(INF_TYPE_DISCOVERY, inf_discovery_avahi_discovery_iface_init)
  G_IMPLEMENT_INTERFACE(INF_TYPE_LOCAL_PUBLISHER, inf_discovery_avahi_local_publisher_iface_init))

/*
 * Destroy notification callbacks
 */

static void
inf_discovery_avahi_discovery_info_resolved_destroy_cb(gpointer user_data,
                                                       GObject* object)
{
  InfDiscoveryInfo* info;
  info = (InfDiscoveryInfo*)user_data;

  /* Connection has gone, next time we resolve this discovery we cannot use
   * the cached connection anymore. */
  info-&gt;resolved = NULL;
}

static void
inf_discovery_avahi_info_resolv_complete(InfDiscoveryInfo* info)
{
  GSList* item;
  InfDiscoveryAvahiInfoResolv* resolv;

  g_assert(info-&gt;resolved != NULL);

  for(item = info-&gt;resolv; item != NULL; item = g_slist_next(item))
  {
    resolv = (InfDiscoveryAvahiInfoResolv*)item-&gt;data;

    resolv-&gt;complete_func(
      info,
      INF_XML_CONNECTION(info-&gt;resolved),
      NULL,
      resolv-&gt;user_data
    );

    g_slice_free(InfDiscoveryAvahiInfoResolv, resolv);
  }

  g_slist_free(info-&gt;resolv);
  info-&gt;resolv = NULL;
}

static void
inf_discovery_avahi_info_resolv_error(InfDiscoveryInfo* info,
                                      const GError* error)
{
  GSList* item;
  InfDiscoveryAvahiInfoResolv* resolv;

  for(item = info-&gt;resolv; item != NULL; item = g_slist_next(item))
  {
    resolv = (InfDiscoveryAvahiInfoResolv*)item-&gt;data;

    resolv-&gt;complete_func(info, NULL, error, resolv-&gt;user_data);
    g_slice_free(InfDiscoveryAvahiInfoResolv, resolv);
  }

  g_slist_free(info-&gt;resolv);
  info-&gt;resolv = NULL;
}

static void
inf_discovery_avahi_discovery_info_free(InfDiscoveryInfo* info)
{
  g_free(info-&gt;service_name);
  g_free(info-&gt;domain);
  
  if(info-&gt;service_resolver != NULL)
    avahi_service_resolver_free(info-&gt;service_resolver);

  if(info-&gt;resolved != NULL)
  {
    g_object_weak_unref(
      G_OBJECT(info-&gt;resolved),
      inf_discovery_avahi_discovery_info_resolved_destroy_cb,
      info
    );
  }

  /* TODO: Get an error from somewhere. If the avahi daemon goes down,
   * all InfDiscoveryInfos are discarded, but it would be nice to show a
   * correct error message for pending resolvs. */
  inf_discovery_avahi_info_resolv_error(info, NULL);

  g_slist_free(info-&gt;resolv);
  g_slice_free(InfDiscoveryInfo, info);
}

static void
inf_discovery_avahi_publisher_item_free(gpointer data)
{
  InfLocalPublisherItem* item;
  item = (InfLocalPublisherItem*)data;

  if(item-&gt;entry_group != NULL)
    avahi_entry_group_free(item-&gt;entry_group);

  g_free(item-&gt;type);
  avahi_free(item-&gt;name);
  g_slice_free(InfLocalPublisherItem, item);
}

static void
inf_discovery_avahi_discover_info_free(gpointer data)
{
  InfDiscoveryAvahiDiscoverInfo* info;
  GSList* item;

  info = (InfDiscoveryAvahiDiscoverInfo*)data;
  for(item = info-&gt;discovered; item != NULL; item = g_slist_next(item))
    inf_discovery_avahi_discovery_info_free((InfDiscoveryInfo*)item-&gt;data);

  if(info-&gt;service_browser != NULL)
    avahi_service_browser_free(info-&gt;service_browser);

  g_slist_free(info-&gt;discovered);
  g_free(info-&gt;type);
  g_slice_free(InfDiscoveryAvahiDiscoverInfo, info);
}

/*
 * Avahi callbacks and utilities
 */

static void
inf_discovery_avahi_service_resolver_callback(AvahiServiceResolver* resolver,
                                              AvahiIfIndex interface,
                                              AvahiProtocol protocol,
                                              AvahiResolverEvent event,
                                              const char* name,
                                              const char* type,
                                              const char* domain,
                                              const char* host_name,
                                              const AvahiAddress* address,
                                              uint16_t port,
                                              AvahiStringList* txt,
                                              AvahiLookupResultFlags flags,
                                              void* userdata)
{
  InfDiscoveryAvahi* avahi;
  InfDiscoveryAvahiPrivate* priv;
  InfDiscoveryAvahiDiscoverInfo* info;
  InfDiscoveryInfo* discovery_info;
  GSList* item;

  InfIpAddress* inf_addr;
  InfTcpConnection* tcp;
  InfXmppConnection* xmpp;
  InfXmlConnectionStatus status;
  GError* error;
  
  avahi = INF_DISCOVERY_AVAHI(userdata);
  priv = INF_DISCOVERY_AVAHI_PRIVATE(avahi);
  info = g_hash_table_lookup(priv-&gt;discovered, type);

  g_assert(info != NULL);

  /* Lookup discovery info for this service resolver */
  for(item = info-&gt;discovered; item != NULL; item = g_slist_next(item))
  {
    discovery_info = (InfDiscoveryInfo*)item-&gt;data;
    if(discovery_info-&gt;service_resolver == resolver)
      break;
  }

  /* If there was no discovery_info, we should have deleted the service
   * resolver before this callback could happen. */
  g_assert(item != NULL);

  /* There is no need to create a service resolver if this is
   * already resolved. */
  g_assert(discovery_info-&gt;resolved == NULL);

  /* So that the callbacks can recreate the resolver by resolving this
   * info again: */
  discovery_info-&gt;service_resolver = NULL;

  switch(event)
  {
  case AVAHI_RESOLVER_FOUND:
    switch(address-&gt;proto)
    {
    case AVAHI_PROTO_INET:
      inf_addr = inf_ip_address_new_raw4(address-&gt;data.ipv4.address);
      break;
    case AVAHI_PROTO_INET6:
      inf_addr = inf_ip_address_new_raw6(address-&gt;data.ipv6.address);
      break;
    default:
      g_assert_not_reached();
      break;
    }

    xmpp = inf_xmpp_manager_lookup_connection_by_address(
      priv-&gt;xmpp_manager,
      inf_addr,
      port
    );

    if(xmpp == NULL)
    {
      tcp = inf_tcp_connection_new(priv-&gt;io, inf_addr, port);

      g_object_set(
        G_OBJECT(tcp),
        "device-index", discovery_info-&gt;interface,
        NULL
      );

      error = NULL;
      if(!inf_tcp_connection_set_keepalive(tcp, &amp;priv-&gt;keepalive, &amp;error) ||
         !inf_tcp_connection_open(tcp, &amp;error))
      {
        inf_discovery_avahi_info_resolv_error(discovery_info, error);
        g_error_free(error);

        g_object_unref(tcp);
      }
      else
      {
        xmpp = inf_xmpp_connection_new(
          tcp,
          INF_XMPP_CONNECTION_CLIENT,
          NULL,
          host_name,
          priv-&gt;security_policy,
          priv-&gt;creds,
          priv-&gt;sasl_context,
          priv-&gt;sasl_context == NULL ? NULL : priv-&gt;sasl_mechanisms
        );

        g_object_unref(tcp);

        inf_xmpp_manager_add_connection(priv-&gt;xmpp_manager, xmpp);

        discovery_info-&gt;resolved = xmpp;

        g_object_weak_ref(
          G_OBJECT(xmpp),
          inf_discovery_avahi_discovery_info_resolved_destroy_cb,
          discovery_info
        );

        inf_discovery_avahi_info_resolv_complete(discovery_info);

        g_object_unref(xmpp);
      }
    }
    else
    {
      discovery_info-&gt;resolved = xmpp;

      g_object_weak_ref(
        G_OBJECT(xmpp),
        inf_discovery_avahi_discovery_info_resolved_destroy_cb,
        discovery_info
      );

      g_object_get(G_OBJECT(xmpp), "status", &amp;status, NULL);

      /* TODO: There is similar code in inf_discovery_avahi_resolve; should
       * probably go into an extra function. */
      if(status == INF_XML_CONNECTION_CLOSING)
      {
        /* TODO: That's a bit a sad case here. We should wait for the
         * connection being closed, and then reopen it: */
        inf_discovery_avahi_info_resolv_error(discovery_info, NULL);
      }
      else if(status == INF_XML_CONNECTION_CLOSED)
      {
        error = NULL;
        if(!inf_xml_connection_open(INF_XML_CONNECTION(xmpp), &amp;error))
        {
          inf_discovery_avahi_info_resolv_error(discovery_info, error);
          g_error_free(error);
        }
        else
        {
          inf_discovery_avahi_info_resolv_complete(discovery_info);
        }
      }
      else
      {
        inf_discovery_avahi_info_resolv_complete(discovery_info);
      }
    }
    
    inf_ip_address_free(inf_addr);
    break;
  case AVAHI_RESOLVER_FAILURE:
    error = NULL;

    g_set_error_literal(
      &amp;error,
      inf_discovery_avahi_error_quark,
      avahi_client_errno(avahi_service_resolver_get_client(resolver)),
      avahi_strerror(
        avahi_client_errno(avahi_service_resolver_get_client(resolver))
      )
    );

    inf_discovery_avahi_info_resolv_error(discovery_info, error);

    g_error_free(error);
    break;
  }

  avahi_service_resolver_free(resolver);
}

static void
inf_discovery_avahi_perform_undiscover(InfDiscoveryAvahi* avahi,
                                       InfDiscoveryAvahiDiscoverInfo* info);

static void
inf_discovery_avahi_perform_unpublish_item(InfLocalPublisherItem* item);

static void
inf_discovery_avahi_service_browser_callback(AvahiServiceBrowser* browser,
                                             AvahiIfIndex interface,
                                             AvahiProtocol protocol,
                                             AvahiBrowserEvent event,
                                             const char* name,
                                             const char* type,
                                             const char* domain,
                                             AvahiLookupResultFlags flags,
                                             void* userdata)
{
  InfDiscoveryAvahi* avahi;
  InfDiscoveryAvahiPrivate* priv;
  InfDiscoveryAvahiDiscoverInfo* info;
  InfDiscoveryInfo* discovery_info;
  GSList* item;

  avahi = INF_DISCOVERY_AVAHI(userdata);
  priv = INF_DISCOVERY_AVAHI_PRIVATE(avahi);
  info = g_hash_table_lookup(priv-&gt;discovered, type);
  g_assert(info != NULL);

  switch(event)
  {
  case AVAHI_BROWSER_NEW:
    /* Ignore what we published ourselves */
    if((flags &amp; AVAHI_LOOKUP_RESULT_OUR_OWN) == 0)
    {
      discovery_info = g_slice_new(InfDiscoveryInfo);
      discovery_info-&gt;service_name = g_strdup(name);
      discovery_info-&gt;service_type = info-&gt;type;
      discovery_info-&gt;domain = g_strdup(domain);
      discovery_info-&gt;interface = interface;
      discovery_info-&gt;protocol = protocol;

      discovery_info-&gt;service_resolver = NULL;
      discovery_info-&gt;resolved = NULL;
      discovery_info-&gt;resolv = NULL;

      info-&gt;discovered = g_slist_prepend(info-&gt;discovered, discovery_info);
      inf_discovery_discovered(INF_DISCOVERY(avahi), discovery_info);
    }

    break;
  case AVAHI_BROWSER_REMOVE:
    for(item = info-&gt;discovered; item != NULL; item = g_slist_next(item))
    {
      discovery_info = (InfDiscoveryInfo*)item-&gt;data;
      g_assert(strcmp(discovery_info-&gt;service_type, type) == 0);

      /* TODO: Do we need to compare domain? */
      if(strcmp(discovery_info-&gt;service_name, name) == 0 &amp;&amp;
         discovery_info-&gt;interface == interface &amp;&amp;
         discovery_info-&gt;protocol == protocol)
      {
        inf_discovery_undiscovered(INF_DISCOVERY(avahi), discovery_info);
        info-&gt;discovered = g_slist_remove(info-&gt;discovered, discovery_info);
        inf_discovery_avahi_discovery_info_free(discovery_info);
        break;
      }
    }

    break;
  case AVAHI_BROWSER_CACHE_EXHAUSTED:
    /* Ignore */
    break;
  case AVAHI_BROWSER_ALL_FOR_NOW:
    /* Ignore */
    break;
  case AVAHI_BROWSER_FAILURE:
    g_warning(
      _("Avahi service browser is in failure state. Services of type '%s' "
        "are no longer discovered.\n\nThe failure was: %s\n"),
      info-&gt;type,
      avahi_strerror(
        avahi_client_errno(avahi_service_browser_get_client(browser))
      )
    );

    inf_discovery_avahi_perform_undiscover(avahi, info);
    break;
  default:
    g_assert_not_reached();
    break;
  }
}

static void
inf_discovery_avahi_entry_group_add_service(InfLocalPublisherItem* item)
{
  char* new_name;
  int res;

  do
  {
    res = avahi_entry_group_add_service(
      item-&gt;entry_group,
      AVAHI_IF_UNSPEC,
      AVAHI_PROTO_UNSPEC,
      0,
      item-&gt;name,
      item-&gt;type,
      NULL,
      NULL,
      item-&gt;port,
      NULL
    );

    if(res != AVAHI_ERR_COLLISION) break;

    new_name = avahi_alternative_service_name(item-&gt;name);
    avahi_free(item-&gt;name);
    item-&gt;name = new_name;
  } while(1);

  if(res != 0)
  {
    g_warning(
      "Failed to publish service \"%s\" via avahi: %s",
      item-&gt;name,
      avahi_strerror(res)
    );
  }
}

static void
inf_discovery_avahi_entry_group_callback(AvahiEntryGroup* group,
                                         AvahiEntryGroupState state,
                                         void* userdata)
{
  InfLocalPublisherItem* item;
  char* new_name;

  item = (InfLocalPublisherItem*)userdata;

  switch(state)
  {
  case AVAHI_ENTRY_GROUP_UNCOMMITED:
    /* Not yet committed */
    break;
  case AVAHI_ENTRY_GROUP_REGISTERING:
    /* This is currently being registered */
    break;
  case AVAHI_ENTRY_GROUP_ESTABLISHED:
    /* The service is published */
    break;
  case AVAHI_ENTRY_GROUP_COLLISION:
    /* There was a name collision, choose a new name */
    new_name = avahi_alternative_service_name(item-&gt;name);
    avahi_free(item-&gt;name);
    item-&gt;name = new_name;

    avahi_entry_group_reset(item-&gt;entry_group);
    inf_discovery_avahi_entry_group_add_service(item);
    avahi_entry_group_commit(item-&gt;entry_group);
    break;
  case AVAHI_ENTRY_GROUP_FAILURE:
    g_warning(
      _("Avahi entry group is in failure state. The service '%s' of type "
        "'%s' is no longer published.\n\nThe failure was: %s\n"),
      item-&gt;name,
      item-&gt;type,
      avahi_strerror(avahi_client_errno(avahi_entry_group_get_client(group)))
    );

    /* There was a failure, remove entry group */
    inf_discovery_avahi_perform_unpublish_item(item);
    break;
  default:
    g_assert_not_reached();
    break;
  }
}

static void
inf_discovery_avahi_perform_publish_item(InfDiscoveryAvahi* avahi,
                                         InfLocalPublisherItem* item)
{
  InfDiscoveryAvahiPrivate* priv;

  priv = INF_DISCOVERY_AVAHI_PRIVATE(avahi);

  if(item-&gt;entry_group == NULL)
  {
    /* TODO: Error handling if one of these calls fail */
    item-&gt;entry_group = avahi_entry_group_new(
      priv-&gt;client,
      inf_discovery_avahi_entry_group_callback,
      item
    );

    inf_discovery_avahi_entry_group_add_service(item);

    avahi_entry_group_commit(item-&gt;entry_group);
  }
}

static void
inf_discovery_avahi_perform_unpublish_item(InfLocalPublisherItem* item)
{
  if(item-&gt;entry_group != NULL)
  {
    avahi_entry_group_free(item-&gt;entry_group);
    item-&gt;entry_group = NULL;
  }
}

static void
inf_discovery_avahi_perform_publish_all(InfDiscoveryAvahi* avahi)
{
  InfDiscoveryAvahiPrivate* priv;
  GSList* item;

  priv = INF_DISCOVERY_AVAHI_PRIVATE(avahi);

  for(item = priv-&gt;published; item != NULL; item = g_slist_next(item))
  {
    inf_discovery_avahi_perform_publish_item(
      avahi,
      (InfLocalPublisherItem*)item-&gt;data
    );
  }
}

static void
inf_discovery_avahi_perform_unpublish_all(InfDiscoveryAvahi* avahi)
{
  InfDiscoveryAvahiPrivate* priv;
  GSList* item;

  priv = INF_DISCOVERY_AVAHI_PRIVATE(avahi);

  for(item = priv-&gt;published; item != NULL; item = g_slist_next(item))
  {
    inf_discovery_avahi_perform_unpublish_item(
      (InfLocalPublisherItem*)item-&gt;data
    );
  }
}

static void
inf_discovery_avahi_perform_discover(InfDiscoveryAvahi* avahi,
                                     InfDiscoveryAvahiDiscoverInfo* info)
{
  InfDiscoveryAvahiPrivate* priv;
  priv = INF_DISCOVERY_AVAHI_PRIVATE(avahi);

  if(info-&gt;service_browser == NULL)
  {
    info-&gt;service_browser = avahi_service_browser_new(
      priv-&gt;client,
      AVAHI_IF_UNSPEC,
      AVAHI_PROTO_UNSPEC,
      info-&gt;type,
      NULL,
      0,
      inf_discovery_avahi_service_browser_callback,
      avahi
    );
  }
}

static void
inf_discovery_avahi_perform_undiscover(InfDiscoveryAvahi* avahi,
                                       InfDiscoveryAvahiDiscoverInfo* info)
{
  /* Remove discovered infos, these might no longer be valid. They are
   * rediscovered when inf_discovery_avahi_perform_discover() is called 
   * again. */
  InfDiscoveryInfo* discovery_info;
  GSList* next;

  for(; info-&gt;discovered != NULL; info-&gt;discovered = next)
  {
    next = info-&gt;discovered-&gt;next;
    discovery_info = (InfDiscoveryInfo*)info-&gt;discovered-&gt;data;

    inf_discovery_undiscovered(INF_DISCOVERY(avahi), discovery_info);
    inf_discovery_avahi_discovery_info_free(discovery_info);

    info-&gt;discovered = g_slist_delete_link(
      info-&gt;discovered,
      info-&gt;discovered
    );
  }

  if(info-&gt;service_browser != NULL)
  {
    avahi_service_browser_free(info-&gt;service_browser);
    info-&gt;service_browser = NULL;
  }
}

static void
inf_discovery_avahi_perform_discover_all_foreach_func(gpointer key,
                                                      gpointer value,
                                                      gpointer user_data)
{
  inf_discovery_avahi_perform_discover(
    INF_DISCOVERY_AVAHI(user_data),
    (InfDiscoveryAvahiDiscoverInfo*)value
<a name="7"></a>  );
}

<font color="#38a4a5"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>static void
inf_discovery_avahi_perform_undiscover_all_foreach_func(gpointer key,
                                                        gpointer value,
                                                        gpointer user_data)
{
  inf_discovery_avahi_perform_undiscover(
    INF_DISCOVERY_AVAHI(user_data),
    (InfDiscoveryAvahiDiscoverInfo*)value
  );
}

static void
inf_discovery_avahi_perform_discover_all(InfDiscoveryAvahi* avahi)
{
  InfDiscoveryAvahiPrivate* priv;
  priv = INF_DISCOVERY_AVAHI_PRIVATE(avahi);

  g_hash_table_foreach(
    priv-&gt;discovered,
    inf_discovery_avahi_perform_discover_all_foreach_func,
    avahi
  );
}

static void
inf_discovery_avahi_perform_undiscover_all(InfDiscoveryAvahi* avahi)
{</b></font>
  InfDiscoveryAvahiPrivate* priv;
  priv = INF_DISCOVERY_AVAHI_PRIVATE(avahi);

  g_hash_table_foreach(
    priv-&gt;discovered,
    inf_discovery_avahi_perform_undiscover_all_foreach_func,
    avahi
  );
}

/* Required by inf_discovery_avahi_create_client() */
static void
inf_discovery_avahi_client_callback(AvahiClient* client,
                                    AvahiClientState state,
                                    void* userdata);

static void
inf_discovery_avahi_create_client(InfDiscoveryAvahi* discovery)
{
  InfDiscoveryAvahiPrivate* priv;
  int error;

  priv = INF_DISCOVERY_AVAHI_PRIVATE(discovery);

  priv-&gt;client = avahi_client_new(
    &amp;priv-&gt;poll,
    AVAHI_CLIENT_NO_FAIL,
    inf_discovery_avahi_client_callback,
    discovery,
    &amp;error
  );

  /* This still seems to happen sometimes, even though we pass
   * AVAHI_CLIENT_NO_FAIL */
  if(priv-&gt;client == NULL)
  {
    g_warning(_
      ("Failed to start Avahi client. Service discovery or publishing "
       "will not be possible.\n\nThe occurred failure was: %s"),
      avahi_strerror(error)
    );
  }
}

static void
inf_discovery_avahi_client_callback(AvahiClient* client,
                                    AvahiClientState state,
                                    void* userdata)
{
  InfDiscoveryAvahi* avahi;
  InfDiscoveryAvahiPrivate* priv;

  avahi = INF_DISCOVERY_AVAHI(userdata);
  priv = INF_DISCOVERY_AVAHI_PRIVATE(avahi);

  switch(state)
  {
  case AVAHI_CLIENT_S_COLLISION:
    /* TODO: What to do in that case. Should we handle this as an error,
     * i.e. withdraw service browsers and entry groups? */
    break;
  case AVAHI_CLIENT_S_REGISTERING:
    /* Wait for client to become running */
    break;
  case AVAHI_CLIENT_S_RUNNING:
    /* Discovery and publish when running */
    inf_discovery_avahi_perform_publish_all(avahi);
    inf_discovery_avahi_perform_discover_all(avahi);
    break;
  case AVAHI_CLIENT_FAILURE:
    inf_discovery_avahi_perform_unpublish_all(avahi);
    inf_discovery_avahi_perform_undiscover_all(avahi);

    if(avahi_client_errno(client) != AVAHI_ERR_DISCONNECTED)
    {
      inf_discovery_avahi_create_client(avahi);
    }
    else
    {
      g_warning(
        _("Avahi client is in failure state. Service discovery or "
          "publishing is no longer possible.\n\nThe occurred failure "
          "was: %s\n"),
        avahi_strerror(avahi_client_errno(client))
      );
    }
  case AVAHI_CLIENT_CONNECTING:
    /* Wait for connection */
    break;
  default:
    g_assert_not_reached();
    break;
  }
}

/*
 * AvahiPoll implementation
 */

static AvahiWatchEvent
inf_discovery_avahi_from_io_event(InfIoEvent event)
{
  AvahiWatchEvent res;

  res = 0;
  if(event &amp; INF_IO_INCOMING) res |= AVAHI_WATCH_IN;
  if(event &amp; INF_IO_OUTGOING) res |= AVAHI_WATCH_OUT;
  if(event &amp; INF_IO_ERROR) res |= AVAHI_WATCH_ERR;

  return res;
}

static InfIoEvent
inf_discovery_avahi_to_io_event(AvahiWatchEvent event)
{
  InfIoEvent res;

  res = 0;
  if(event &amp; AVAHI_WATCH_IN) res |= INF_IO_INCOMING;
  if(event &amp; AVAHI_WATCH_OUT) res |= INF_IO_OUTGOING;
<a name="6"></a>  if(event &amp; (AVAHI_WATCH_ERR | AVAHI_WATCH_HUP)) res |= INF_IO_ERROR;

  return res;
<font color="#8c8774"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>}

static void
inf_discovery_avahi_watch_cb(InfNativeSocket* socket,
                             InfIoEvent event,
                             gpointer user_data)
{
  AvahiWatch* watch;
  watch = (AvahiWatch*)user_data;

  watch-&gt;occurred_events = inf_discovery_avahi_from_io_event(event);
  watch-&gt;callback(watch, *socket, watch-&gt;occurred_events, watch-&gt;userdata);
}

static void
inf_discovery_avahi_timeout_cb(gpointer user_data)
{
  AvahiTimeout* timeout;
  timeout = (AvahiTimeout*)user_data;

  timeout-&gt;timeout = NULL;</b></font>
  timeout-&gt;callback(timeout, timeout-&gt;userdata);
}

static AvahiWatch*
inf_discovery_avahi_watch_new(const AvahiPoll* api,
                              int fd,
                              AvahiWatchEvent event,
                              AvahiWatchCallback callback,
                              void* userdata)
{
  InfDiscoveryAvahi* avahi;
  InfDiscoveryAvahiPrivate* priv;
  AvahiWatch* watch;

  avahi = INF_DISCOVERY_AVAHI(api-&gt;userdata);
  priv = INF_DISCOVERY_AVAHI_PRIVATE(avahi);
  watch = g_slice_new(AvahiWatch);

  watch-&gt;avahi = avahi;
  watch-&gt;socket = fd;
  watch-&gt;occurred_events = 0;
  watch-&gt;callback = callback;
  watch-&gt;userdata = userdata;

  watch-&gt;watch = inf_io_add_watch(
    priv-&gt;io,
    &amp;watch-&gt;socket,
    inf_discovery_avahi_to_io_event(event),
    inf_discovery_avahi_watch_cb,
    watch,
    NULL
  );

  return watch;
}

static void
inf_discovery_avahi_watch_update(AvahiWatch* watch,
                                 AvahiWatchEvent event)
{
  InfDiscoveryAvahiPrivate* priv;
  priv = INF_DISCOVERY_AVAHI_PRIVATE(watch-&gt;avahi);

  inf_io_update_watch(
    priv-&gt;io,
    watch-&gt;watch,
    inf_discovery_avahi_to_io_event(event)
  );
}

static AvahiWatchEvent
inf_discovery_avahi_watch_get_events(AvahiWatch* watch)
{
  return watch-&gt;occurred_events;
}

static void
inf_discovery_avahi_watch_free(AvahiWatch* watch)
{
  InfDiscoveryAvahiPrivate* priv;
  priv = INF_DISCOVERY_AVAHI_PRIVATE(watch-&gt;avahi);

  inf_io_remove_watch(priv-&gt;io, watch-&gt;watch);
  g_slice_free(AvahiWatch, watch);
}

static AvahiTimeout*
inf_discovery_avahi_timeout_new(const AvahiPoll* api,
                                const struct timeval* tv,
                                AvahiTimeoutCallback callback,
                                void* userdata)
{
  InfDiscoveryAvahi* avahi;
  InfDiscoveryAvahiPrivate* priv;
  AvahiTimeout* timeout;
  AvahiUsec usec;

  avahi = INF_DISCOVERY_AVAHI(api-&gt;userdata);
  priv = INF_DISCOVERY_AVAHI_PRIVATE(avahi);
  timeout = g_slice_new(AvahiTimeout);

  timeout-&gt;avahi = avahi;
  timeout-&gt;callback = callback;
  timeout-&gt;userdata = userdata;

  if(tv != NULL)
  {
    /* Timeout in the past is triggered instantly */
    usec = avahi_age(tv);
    if(usec &gt; 0) usec = 0;

    timeout-&gt;timeout = inf_io_add_timeout(
      priv-&gt;io,
      ((-usec) + 500) / 1000,
      inf_discovery_avahi_timeout_cb,
      timeout,
      NULL
    );
  }
  else
  {
    timeout-&gt;timeout = NULL;
  }

  return timeout;
}

static void
inf_discovery_avahi_timeout_update(AvahiTimeout* timeout,
                                   const struct timeval* tv)
{
  InfDiscoveryAvahiPrivate* priv;
  AvahiUsec usec;
  priv = INF_DISCOVERY_AVAHI_PRIVATE(timeout-&gt;avahi);

  if(timeout-&gt;timeout != NULL)
    inf_io_remove_timeout(priv-&gt;io, timeout-&gt;timeout);

  if(tv != NULL)
  {
    /* Timeout in the past is triggered instantly */
    usec = avahi_age(tv);
    if(usec &gt; 0) usec = 0;

    timeout-&gt;timeout = inf_io_add_timeout(
      priv-&gt;io,
      ((-usec) + 500) / 1000,
      inf_discovery_avahi_timeout_cb,
      timeout,
      NULL
    );
  }
  else
  {
    timeout-&gt;timeout = NULL;
  }
}

static void
inf_discovery_avahi_timeout_free(AvahiTimeout* timeout)
{
  InfDiscoveryAvahiPrivate* priv;
  priv = INF_DISCOVERY_AVAHI_PRIVATE(timeout-&gt;avahi);

  if(timeout-&gt;timeout != NULL)
<a name="5"></a>    inf_io_remove_timeout(priv-&gt;io, timeout-&gt;timeout);

  g_slice_free(AvahiTimeout, timeout);
<font color="#151b8d"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>}

/*
 * GObject overrides
 */

static void
inf_discovery_avahi_init(InfDiscoveryAvahi* avahi)
{
  InfDiscoveryAvahiPrivate* priv;
  priv = INF_DISCOVERY_AVAHI_PRIVATE(avahi);
  
  priv-&gt;poll.userdata = avahi;
  priv-&gt;poll.watch_new = inf_discovery_avahi_watch_new;
  priv-&gt;poll.watch_update = inf_discovery_avahi_watch_update;
  priv-&gt;poll.watch_get_events = inf_discovery_avahi_watch_get_events;
  priv-&gt;poll.watch_free = inf_discovery_avahi_watch_free;
  priv-&gt;poll.timeout_new = inf_discovery_avahi_timeout_new;
  priv-&gt;poll.timeout_update = inf_discovery_avahi_timeout_update;
  priv-&gt;poll.timeout_free = inf_discovery_avahi_timeout_free;

  priv-&gt;io = NULL;</b></font>
  priv-&gt;xmpp_manager = NULL;
<a name="2"></a>  priv-&gt;security_policy = INF_XMPP_CONNECTION_SECURITY_BOTH_PREFER_TLS;
  priv-&gt;keepalive.mask = 0;
  priv-&gt;creds = NULL;
<font color="#980517"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>  priv-&gt;sasl_context = NULL;
  priv-&gt;sasl_mechanisms = NULL;

  priv-&gt;client = NULL;
  priv-&gt;published = NULL;

  priv-&gt;discovered = g_hash_table_new_full(
    g_str_hash,
    g_str_equal,
    NULL, /* key is owned by value */
    inf_discovery_avahi_discover_info_free
  );
}

static void
inf_discovery_avahi_constructed(GObject* object)
{
  InfDiscoveryAvahiPrivate* priv;
  
  G_OBJECT_CLASS(inf_discovery_avahi_parent_class)-&gt;constructed(object);

  priv = INF_DISCOVERY_AVAHI_PRIVATE(object);</b></font>

  /* Must have been set as construct only property */
  g_assert(priv-&gt;io != NULL);

  inf_discovery_avahi_create_client(INF_DISCOVERY_AVAHI(object));
}

static void
inf_discovery_avahi_dispose(GObject* object)
{
  InfDiscoveryAvahi* avahi;
  InfDiscoveryAvahiPrivate* priv;
  GSList* item;

  avahi = INF_DISCOVERY_AVAHI(object);
  priv = INF_DISCOVERY_AVAHI_PRIVATE(avahi);

  g_hash_table_destroy(priv-&gt;discovered);
  priv-&gt;discovered = NULL;

<a name="4"></a>  for(item = priv-&gt;published; item != NULL; item = g_slist_next(item))
    inf_discovery_avahi_publisher_item_free(item-&gt;data);
  g_slist_free(priv-&gt;published);
<font color="#6cc417"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>  priv-&gt;published = NULL;

  if(priv-&gt;client != NULL)
  {
    avahi_client_free(priv-&gt;client);
    priv-&gt;client = NULL;
  }

  if(priv-&gt;xmpp_manager != NULL)
  {
    g_object_unref(G_OBJECT(priv-&gt;xmpp_manager));
    priv-&gt;xmpp_manager = NULL;
  }</b></font>

  if(priv-&gt;creds != NULL)
  {
    inf_certificate_credentials_unref(priv-&gt;creds);
    priv-&gt;creds = NULL;
  }
  
  if(priv-&gt;sasl_context != NULL)
  {
    inf_sasl_context_unref(priv-&gt;sasl_context);
    priv-&gt;sasl_context = NULL;
  }

  if(priv-&gt;io != NULL)
  {
    g_object_unref(G_OBJECT(priv-&gt;io));
    priv-&gt;io = NULL;
  }

  G_OBJECT_CLASS(inf_discovery_avahi_parent_class)-&gt;dispose(object);
}

static void
inf_discovery_avahi_finalize(GObject* object)
{
  InfDiscoveryAvahi* avahi;
  InfDiscoveryAvahiPrivate* priv;

  avahi = INF_DISCOVERY_AVAHI(object);
  priv = INF_DISCOVERY_AVAHI_PRIVATE(avahi);

<a name="0"></a>  g_free(priv-&gt;sasl_mechanisms);

  G_OBJECT_CLASS(inf_discovery_avahi_parent_class)-&gt;finalize(object);
<font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>}

static void
inf_discovery_avahi_set_property(GObject* object,
                                 guint prop_id,
                                 const GValue* value,
                                 GParamSpec* pspec)
{
  InfDiscoveryAvahi* avahi;
  InfDiscoveryAvahiPrivate* priv;

  avahi = INF_DISCOVERY_AVAHI(object);
  priv = INF_DISCOVERY_AVAHI_PRIVATE(avahi);

  switch(prop_id)
  {
  case PROP_IO:
    g_assert(priv-&gt;io == NULL); /* construct only */
    priv-&gt;io = INF_IO(g_value_dup_object(value));
    break;
  case PROP_XMPP_MANAGER:
    g_assert(priv-&gt;xmpp_manager == NULL); /* construct only */
    priv-&gt;xmpp_manager = INF_XMPP_MANAGER(g_value_dup_object(value));
    break;</b></font>
  case PROP_CREDENTIALS:
    if(priv-&gt;creds != NULL) inf_certificate_credentials_unref(priv-&gt;creds);
    priv-&gt;creds = (InfCertificateCredentials*)g_value_dup_boxed(value);
    break;
  case PROP_SASL_CONTEXT:
    priv-&gt;sasl_context = (InfSaslContext*)g_value_dup_boxed(value);
    break;
  case PROP_SASL_MECHANISMS:
    g_free(priv-&gt;sasl_mechanisms);
    priv-&gt;sasl_mechanisms = g_value_dup_string(value);
    break;
  case PROP_SECURITY_POLICY:
    priv-&gt;security_policy = g_value_get_enum(value);
    break;
  case PROP_KEEPALIVE:
<a name="1"></a>    g_assert(g_value_get_boxed(value) != NULL);
    priv-&gt;keepalive = *(const InfKeepalive*)g_value_get_boxed(value);
    break;
<font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>  default:
    G_OBJECT_WARN_INVALID_PROPERTY_ID(object, prop_id, pspec);
    break;
  }
}

static void
inf_discovery_avahi_get_property(GObject* object,
                                 guint prop_id,
                                 GValue* value,
                                 GParamSpec* pspec)
{
  InfDiscoveryAvahi* avahi;
  InfDiscoveryAvahiPrivate* priv;

  avahi = INF_DISCOVERY_AVAHI(object);
  priv = INF_DISCOVERY_AVAHI_PRIVATE(avahi);

  switch(prop_id)
  {
  case PROP_IO:
    g_value_set_object(value, G_OBJECT(priv-&gt;io));
    break;
  case PROP_XMPP_MANAGER:
    g_value_set_object(value, G_OBJECT(priv-&gt;xmpp_manager));
    break;</b></font>
  case PROP_CREDENTIALS:
    g_value_set_boxed(value, priv-&gt;creds);
    break;
  case PROP_SASL_CONTEXT:
    g_value_set_boxed(value, priv-&gt;sasl_context);
    break;
  case PROP_SASL_MECHANISMS:
    g_value_set_string(value, priv-&gt;sasl_mechanisms);
    break;
  case PROP_SECURITY_POLICY:
    g_value_set_enum(value, priv-&gt;security_policy);
    break;
  case PROP_KEEPALIVE:
    g_value_set_boxed(value, &amp;priv-&gt;keepalive);
    break;
  default:
    G_OBJECT_WARN_INVALID_PROPERTY_ID(object, prop_id, pspec);
    break;
  }
}

/*
 * InfDiscovery implementation.
 */

static void
inf_discovery_avahi_discover(InfDiscovery* discovery,
                             const gchar* type)
{
  InfDiscoveryAvahiPrivate* priv;
  InfDiscoveryAvahiDiscoverInfo* info;

  priv = INF_DISCOVERY_AVAHI_PRIVATE(discovery);
  info = g_hash_table_lookup(priv-&gt;discovered, type);

  if(info == NULL)
  {
    info = g_slice_new(InfDiscoveryAvahiDiscoverInfo);

    info-&gt;type = g_strdup(type);
    info-&gt;service_browser = NULL;
    info-&gt;discovered = NULL;
    g_hash_table_insert(priv-&gt;discovered, info-&gt;type, info);

    if(priv-&gt;client != NULL &amp;&amp;
       avahi_client_get_state(priv-&gt;client) == AVAHI_CLIENT_S_RUNNING)
    {
      inf_discovery_avahi_perform_discover(
        INF_DISCOVERY_AVAHI(discovery),
        info
      );
    }
  }
}

static GSList*
inf_discovery_avahi_get_discovered(InfDiscovery* discovery,
                                   const gchar* type)
{
  InfDiscoveryAvahiPrivate* priv;
  InfDiscoveryAvahiDiscoverInfo* info;

  priv = INF_DISCOVERY_AVAHI_PRIVATE(discovery);
  info = g_hash_table_lookup(priv-&gt;discovered, type);
  if(info == NULL) return NULL;

  return g_slist_copy(info-&gt;discovered);
}

static void
inf_discovery_avahi_resolve(InfDiscovery* discovery,
                            InfDiscoveryInfo* info,
                            InfDiscoveryResolvCompleteFunc complete_func,
                            gpointer user_data)
{
  InfDiscoveryAvahiPrivate* priv;
  InfDiscoveryAvahiInfoResolv* resolv;
  InfXmlConnectionStatus status;
  int errno;
  GError* error;

  priv = INF_DISCOVERY_AVAHI_PRIVATE(discovery);
  g_assert(priv-&gt;client != NULL);
  g_assert(avahi_client_get_state(priv-&gt;client) == AVAHI_CLIENT_S_RUNNING);

  if(info-&gt;resolved != NULL)
  {
    g_object_get(G_OBJECT(info-&gt;resolved), "status", &amp;status, NULL);

    switch(status)
    {
    case INF_XML_CONNECTION_CLOSED:
      error = NULL;
      if(!inf_xml_connection_open(INF_XML_CONNECTION(info-&gt;resolved), &amp;error))
      {
        complete_func(info, NULL, error, user_data);
        g_error_free(error);
      }
      else
      {
        complete_func(
          info,
          INF_XML_CONNECTION(info-&gt;resolved),
          NULL,
          user_data
        );
      }

      break;
    case INF_XML_CONNECTION_CLOSING:
      /* TODO: We should add ourselves to the resolver list, and wait for
       * the connection being closed and reopen it afterwards. */
      complete_func(info, NULL, NULL, user_data);
      break;
    case INF_XML_CONNECTION_OPENING:
    case INF_XML_CONNECTION_OPEN:
      complete_func(
        info,
        INF_XML_CONNECTION(info-&gt;resolved),
        NULL,
        user_data
      );

      break;
    default:
      g_assert_not_reached();
      break;
    }
  }
  else
  {
    resolv = g_slice_new(InfDiscoveryAvahiInfoResolv);
    resolv-&gt;complete_func = complete_func;
    resolv-&gt;user_data = user_data;
    info-&gt;resolv = g_slist_prepend(info-&gt;resolv, resolv);

    if(info-&gt;service_resolver == NULL)
    {
      info-&gt;service_resolver = avahi_service_resolver_new(
        priv-&gt;client,
        info-&gt;interface,
        info-&gt;protocol,
        info-&gt;service_name,
        info-&gt;service_type,
        info-&gt;domain,
        AVAHI_PROTO_UNSPEC,
        0,
        inf_discovery_avahi_service_resolver_callback,
        discovery
      );

      if(info-&gt;service_resolver == NULL)
      {
        error = NULL;

        errno = avahi_client_errno(
          avahi_service_resolver_get_client(info-&gt;service_resolver)
        );

        g_set_error_literal(
          &amp;error,
          inf_discovery_avahi_error_quark,
          errno,
          avahi_strerror(errno)
        );

        inf_discovery_avahi_info_resolv_error(info, error);
        g_error_free(error);
      }
    }
  }
}

static gchar*
inf_discovery_avahi_info_get_service_name(InfDiscovery* discovery,
                                          InfDiscoveryInfo* info)
{
  char device_name[IF_NAMESIZE];
  if(if_indextoname(info-&gt;interface, device_name) == NULL)
    return NULL;

  return g_strdup_printf(
    info-&gt;protocol == AVAHI_PROTO_INET ?
    /* Translators: This is "&lt;Service Name&gt; (via &lt;Network Interface&gt; on
     * &lt;address family&gt;)", for example "ck (via eth0 on IPv4)". */
      _("%s (via %s on IPv4)") :
      _("%s (via %s on IPv6)"),
    info-&gt;service_name,
    device_name
  );
}

static const gchar*
inf_discovery_avahi_info_get_service_type(InfDiscovery* discovery,
                                          InfDiscoveryInfo* info)
{
  return info-&gt;service_type;
}

static InfLocalPublisherItem*
inf_discovery_avahi_publish(InfLocalPublisher* publisher,
                            const gchar* type,
                            const gchar* name,
                            guint port)
{
  InfDiscoveryAvahiPrivate* priv;
  InfLocalPublisherItem* item;

  priv = INF_DISCOVERY_AVAHI_PRIVATE(publisher);
  item = g_slice_new(InfLocalPublisherItem);

  item-&gt;type = g_strdup(type);
  item-&gt;name = avahi_strdup(name);
  item-&gt;port = port;
  item-&gt;entry_group = NULL;
  priv-&gt;published = g_slist_prepend(priv-&gt;published, item);

  if(priv-&gt;client != NULL &amp;&amp;
     avahi_client_get_state(priv-&gt;client) == AVAHI_CLIENT_S_RUNNING)
  {
    inf_discovery_avahi_perform_publish_item(
      INF_DISCOVERY_AVAHI(publisher),
      item
    );
  }

  return item;
}

static void
inf_discovery_avahi_unpublish(InfLocalPublisher* publisher,
                              InfLocalPublisherItem* item)
{
  InfDiscoveryAvahiPrivate* priv;
  priv = INF_DISCOVERY_AVAHI_PRIVATE(publisher);

  g_assert(g_slist_find(priv-&gt;published, item) != NULL);

  inf_discovery_avahi_publisher_item_free(item);
  priv-&gt;published = g_slist_remove(priv-&gt;published, item);
}

/*
 * Gype registration.
 */

static void
inf_discovery_avahi_class_init(InfDiscoveryAvahiClass* avahi_class)
{
  GObjectClass* object_class;
  object_class = G_OBJECT_CLASS(avahi_class);

  object_class-&gt;constructed = inf_discovery_avahi_constructed;
  object_class-&gt;dispose = inf_discovery_avahi_dispose;
  object_class-&gt;finalize = inf_discovery_avahi_finalize;
  object_class-&gt;set_property = inf_discovery_avahi_set_property;
  object_class-&gt;get_property = inf_discovery_avahi_get_property;

  inf_discovery_avahi_error_quark = g_quark_from_static_string(
    "INF_DISCOVERY_AVAHI_ERROR"
  );

  g_object_class_install_property(
    object_class,
    PROP_IO,
    g_param_spec_object(
      "io",
      "IO",
      "The IO object used for watching sockets and timeouts",
      INF_TYPE_IO,
      G_PARAM_READWRITE | G_PARAM_CONSTRUCT_ONLY
    )
  );

  g_object_class_install_property(
    object_class,
    PROP_XMPP_MANAGER,
    g_param_spec_object(
      "xmpp-manager",
      "XMPP manager",
      "The XMPP manager to register resolved XMPP connections",
      INF_TYPE_XMPP_MANAGER,
      G_PARAM_READWRITE | G_PARAM_CONSTRUCT_ONLY
    )
  );

  g_object_class_install_property(
    object_class,
    PROP_CREDENTIALS,
    g_param_spec_boxed(
      "credentials",
      "Certificate credentials",
      "The GnuTLS certificate credentials used for encrypting XMPP streams",
      INF_TYPE_CERTIFICATE_CREDENTIALS,
      G_PARAM_READWRITE
    )
  );

  g_object_class_install_property(
    object_class,
    PROP_SASL_CONTEXT,
    g_param_spec_boxed(
      "sasl-context",
      "SASL context",
      "The SASL context used for authentication",
      INF_TYPE_SASL_CONTEXT,
      G_PARAM_READWRITE
    )
  );

  g_object_class_install_property(
    object_class,
    PROP_SASL_MECHANISMS,
    g_param_spec_string(
      "sasl-mechanisms",
      "SASL mechanisms",
      "The accepted SASL mechanisms for authentication",
      NULL,
      G_PARAM_READWRITE
    )
  );

  g_object_class_install_property(
    object_class,
    PROP_SECURITY_POLICY,
    g_param_spec_enum(
      "security-policy",
      "Security policy",
      "How to decide whether to use TLS",
      INF_TYPE_XMPP_CONNECTION_SECURITY_POLICY,
      INF_XMPP_CONNECTION_SECURITY_BOTH_PREFER_TLS,
      G_PARAM_READWRITE
    )
  );

  g_object_class_install_property(
    object_class,
    PROP_KEEPALIVE,
    g_param_spec_boxed(
      "keepalive",
      "Keepalive",
      "The keepalive settings for new connections",
      INF_TYPE_KEEPALIVE,
      G_PARAM_READWRITE
    )
  );
}

static void
inf_discovery_avahi_discovery_iface_init(InfDiscoveryInterface* iface)
{
  iface-&gt;discover = inf_discovery_avahi_discover;
  iface-&gt;get_discovered = inf_discovery_avahi_get_discovered;
  iface-&gt;resolve = inf_discovery_avahi_resolve;
  iface-&gt;info_get_service_name = inf_discovery_avahi_info_get_service_name;
  iface-&gt;info_get_service_type = inf_discovery_avahi_info_get_service_type;
  iface-&gt;discovered = NULL;
  iface-&gt;undiscovered = NULL;
}

static void
inf_discovery_avahi_local_publisher_iface_init(
  InfLocalPublisherInterface* iface)
{
  iface-&gt;publish = inf_discovery_avahi_publish;
  iface-&gt;unpublish = inf_discovery_avahi_unpublish;
}

/*
 * Public API.
 */

/**
 * inf_discovery_avahi_new: (constructor)
 * @io: A #InfIo object used for watching sockets and timeouts.
 * @manager: A #InfXmppManager.
 * @creds: The certificate credentials used for GnuTLS encryption.
 * @sasl_context: A SASL context used for authentication.
 * @sasl_mechanisms: A whitespace-separated list of accepted SASL mechanisms,
 * or %NULL.
 *
 * Created a new #InfDiscoveryAvahi object which can be used to publish and
 * discovery Infinote services on the local network. When resolving a
 * #InfDiscoveryInfo (which means obtaining a #InfXmlConnection for the
 * discovered service) a new #InfXmppConnection needs to be created if there
 * is not already one for the destination host in @manager. Such
 * connections are created with the @creds and @sasl_context parameters.
 * These may be %NULL in which case #InfXmppConnection uses builtin
 * credentials or a builtin context, respectively.
 *
 * If this #InfDiscoveryAvahi is not used to discover services but only to
 * publish any, then @creds, @sasl_context and @sasl_mechanisms are ignored
 * and can safely set to be %NULL.
 *
 * @sasl_mechanisms specifies allowed mechanisms used for authentication with
 * the server. It can be %NULL, in which case all available mechanisms are
 * accepted.
 *
 * Return Value: (transfer full): A new #InfDiscoveryAvahi.
 **/
InfDiscoveryAvahi*
inf_discovery_avahi_new(InfIo* io,
                        InfXmppManager* manager,
                        InfCertificateCredentials* creds,
                        InfSaslContext* sasl_context,
                        const gchar* sasl_mechanisms)
{
  GObject* object;

  g_return_val_if_fail(INF_IS_IO(io), NULL);
  g_return_val_if_fail(INF_IS_XMPP_MANAGER(manager), NULL);

  object = g_object_new(
    INF_TYPE_DISCOVERY_AVAHI,
    "io", io,
    "xmpp-manager", manager,
    "credentials", creds,
    "sasl-context", sasl_context,
    "sasl-mechanisms", sasl_mechanisms,
    NULL
  );

  return INF_DISCOVERY_AVAHI(object);
}

/**
 * inf_discovery_avahi_set_security_policy:
 * @discovery: A #InfDiscoveryAvahi.
 * @plcy: The new security policy.
 *
 * Sets the #InfXmppConnectionSecurityPolicy for newly created
 * #InfXmppConnection&lt;!-- --&gt;s. It does not affect already existing
 * connections.
 */
void
inf_discovery_avahi_set_security_policy(InfDiscoveryAvahi* discovery,
                                        InfXmppConnectionSecurityPolicy plcy)
{
  g_return_if_fail(INF_IS_DISCOVERY_AVAHI(discovery));
  INF_DISCOVERY_AVAHI_PRIVATE(discovery)-&gt;security_policy = plcy;
}

/**
 * inf_discovery_avahi_get_security_policy:
 * @discovery: A #InfDiscoveryAvahi.
 *
 * Returns the current security policy used for new
 * #InfXmppConnection&lt;!-- --&gt;s.
 *
 * Returns: The current security policy.
 */
InfXmppConnectionSecurityPolicy
inf_discovery_avahi_get_security_policy(InfDiscoveryAvahi* discovery)
{
  g_return_val_if_fail(
    INF_IS_DISCOVERY_AVAHI(discovery),
    INF_XMPP_CONNECTION_SECURITY_BOTH_PREFER_TLS
  );

  return INF_DISCOVERY_AVAHI_PRIVATE(discovery)-&gt;security_policy;
}

/**
 * inf_discovery_avahi_set_keepalive:
 * @discovery: A #InfDiscoveryAvahi.
 * @keepalive: The new keepalive configuration.
 *
 * Sets the keepalive settings for newly created connections. It does not
 * affect already existing connections.
 */
void
inf_discovery_avahi_set_keepalive(InfDiscoveryAvahi* discovery,
                                  const InfKeepalive* keepalive)
{
  g_return_if_fail(INF_IS_DISCOVERY_AVAHI(discovery));
  g_return_if_fail(keepalive != NULL);

  INF_DISCOVERY_AVAHI_PRIVATE(discovery)-&gt;keepalive = *keepalive;
}

/**
 * inf_discovery_avahi_get_keepalive:
 * @discovery: A #InfDiscoveryAvahi.
 *
 * Returns the keepalive settings that will be used for new connections.
 *
 * Returns: A #InfKeepalive set for new connections, owned by @discovery.
 */
const InfKeepalive*
inf_discovery_avahi_get_keepalive(InfDiscoveryAvahi* discovery)
{
  g_return_val_if_fail(INF_IS_DISCOVERY_AVAHI(discovery), NULL);
  return &amp;INF_DISCOVERY_AVAHI_PRIVATE(discovery)-&gt;keepalive;
}

#endif /* LIBINFINITY_HAVE_AVAHI */

/* vim:set et sw=2 ts=2: */
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>inf-gtk-browser-store.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
/* libinfinity - a GObject-based infinote implementation
 * Copyright (C) 2007-2015 Armin Burgmeier &lt;armin@arbur.net&gt;
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston,
 * MA 02110-1301, USA.
 */

#include &lt;libinfgtk/inf-gtk-browser-store.h&gt;
#include &lt;libinfgtk/inf-gtk-browser-model.h&gt;
#include &lt;libinfinity/client/infc-browser.h&gt;
#include &lt;libinfinity/inf-i18n.h&gt;
#include &lt;libinfinity/inf-signals.h&gt;

#include &lt;gtk/gtk.h&gt;

/* The three pointers in GtkTreeIter are used as follows:
 *
 * user_data holds a pointer to the GtkTreeModelItem the iter points to.
 * user_data2 holds the node_id field of the InfBrowserIter, or 0 if the
 * iter points to the toplevel node.
 * user_data3 holds the node field of the InfcBrowser, or NULL if the iter
 * points to the toplevel node. Note that it does not hold the root node of
 * the item's browser (if present) because the iter should remain valid when
 * the browser is removed (we set GTK_TREE_MODEL_ITERS_PERSIST).
 */

typedef struct _InfGtkBrowserStoreItem InfGtkBrowserStoreItem;
struct _InfGtkBrowserStoreItem {
  gchar* name;
  InfDiscovery* discovery;
  InfDiscoveryInfo* info;

  InfBrowser* browser;

  /* Browser node which is currently to be removed. This is required since
   * when node-removed is emitted in InfcBrowser the node is still present,
   * but we need to make sure that the GtkTreeModel functions do as if it
   * wasn't present anymore. */
  gpointer missing;

  /* Running requests */
  GSList* requests;
  /* Saved node errors (during exploration/subscription) */
  GHashTable* node_errors;

  /* TODO: Determine status at run-time? */
  InfGtkBrowserModelStatus status;

  /* Error on toplevel item */
  GError* error;
<a name="3"></a>
  /* Link */
  InfGtkBrowserStoreItem* next;
<font color="#53858b"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>};

typedef struct _InfGtkBrowserStoreRequestData InfGtkBrowserStoreRequestData;
struct _InfGtkBrowserStoreRequestData {
  InfGtkBrowserStore* store;
  InfGtkBrowserStoreItem* item;
};

typedef struct _InfGtkBrowserStorePrivate InfGtkBrowserStorePrivate;
struct _InfGtkBrowserStorePrivate {
  gint stamp;

  InfIo* io;
  InfCommunicationManager* communication_manager;

  GSList* discoveries;
  InfGtkBrowserStoreItem* first_item;
  InfGtkBrowserStoreItem* last_item;
};

enum {
  PROP_0,

  PROP_IO,
  PROP_COMMUNICATION_MANAGER
};

#define INF_GTK_BROWSER_STORE_PRIVATE(obj) (G_TYPE_INSTANCE_GET_PRIVATE((obj), INF_GTK_TYPE_BROWSER_STORE, InfGtkBrowserStorePrivate))

static void inf_gtk_browser_store_tree_model_iface_init(GtkTreeModelIface* iface);</b></font>
static void inf_gtk_browser_store_browser_model_iface_init(InfGtkBrowserModelInterface* iface);
G_DEFINE_TYPE_WITH_CODE(InfGtkBrowserStore, inf_gtk_browser_store, G_TYPE_OBJECT,
  G_ADD_PRIVATE(InfGtkBrowserStore)
  G_IMPLEMENT_INTERFACE(GTK_TYPE_TREE_MODEL, inf_gtk_browser_store_tree_model_iface_init)
  G_IMPLEMENT_INTERFACE(INF_GTK_TYPE_BROWSER_MODEL, inf_gtk_browser_store_browser_model_iface_init))

/*
 * Utility functions
 */

static InfGtkBrowserStoreItem*
inf_gtk_browser_store_find_item_by_connection(InfGtkBrowserStore* store,
                                              InfXmlConnection* connection)
{
  InfGtkBrowserStorePrivate* priv;
  InfGtkBrowserStoreItem* item;
  InfcBrowser* browser;

  priv = INF_GTK_BROWSER_STORE_PRIVATE(store);

  for(item = priv-&gt;first_item; item != NULL; item = item-&gt;next)
  {
    if(item-&gt;browser != NULL &amp;&amp; INFC_IS_BROWSER(item-&gt;browser))
    {
      browser = INFC_BROWSER(item-&gt;browser);
      if(infc_browser_get_connection(browser) == connection)
        return item;
    }
  }

  return NULL;
}

static InfGtkBrowserStoreItem*
inf_gtk_browser_store_find_item_by_browser(InfGtkBrowserStore* store,
                                           InfBrowser* browser)
{
  InfGtkBrowserStorePrivate* priv;
  InfGtkBrowserStoreItem* item;

  priv = INF_GTK_BROWSER_STORE_PRIVATE(store);

  for(item = priv-&gt;first_item; item != NULL; item = item-&gt;next)
    if(item-&gt;browser != NULL)
      if(item-&gt;browser == browser)
        return item;

  return NULL;
}

static InfGtkBrowserStoreItem*
inf_gtk_browser_store_find_item_by_discovery_info(InfGtkBrowserStore* store,
                                                  InfDiscoveryInfo* info)
{
  InfGtkBrowserStorePrivate* priv;
  InfGtkBrowserStoreItem* item;

  priv = INF_GTK_BROWSER_STORE_PRIVATE(store);

  for(item = priv-&gt;first_item; item != NULL; item = item-&gt;next)
    if(item-&gt;info != NULL)
      if(item-&gt;info == info)
        return item;

  return NULL;
}

/*
 * Callback declarations
 */

static void
inf_gtk_browser_store_browser_notify_status_cb(GObject* object,
                                               GParamSpec* pspec,
                                               gpointer user_data);

static void
inf_gtk_browser_store_browser_error_cb(InfBrowser* browser,
                                       const GError* error,
                                       gpointer user_data);

static void
inf_gtk_browser_store_node_added_cb(InfBrowser* browser,
                                    InfBrowserIter* iter,
                                    InfRequest* request,
                                    gpointer user_data);

static void
inf_gtk_browser_store_node_removed_cb(InfBrowser* browser,
                                      InfBrowserIter* iter,
                                      InfRequest* request,
                                      gpointer user_data);

static void
inf_gtk_browser_store_begin_request_explore_node_cb(InfBrowser* browser,
                                                    InfBrowserIter* iter,
                                                    InfRequest* request,
                                                    gpointer user_data);

static void
inf_gtk_browser_store_begin_request_subscribe_session_cb(InfBrowser* browser,
                                                         InfBrowserIter* iter,
                                                         InfRequest* request,
                                                         gpointer user_data);

static void
inf_gtk_browser_store_request_finished_cb(InfRequest* request,
                                          const InfRequestResult* result,
                                          const GError* error,
                                          gpointer user_data);

static void
inf_gtk_browser_store_request_unrefed_func(gpointer data,
                                           GObject* where_the_object_was);

/*
<a name="7"></a> * InfGtkBrowserStoreItem handling
 */

<font color="#38a4a5"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>static void
inf_gtk_browser_store_request_data_free(gpointer data,
                                        GClosure* closure)
{
  g_slice_free(InfGtkBrowserStoreRequestData, data);
}

static void
inf_gtk_browser_store_item_request_remove(InfGtkBrowserStoreItem* item,
                                          InfRequest* request)
{
  g_object_weak_unref(
    G_OBJECT(request),
    inf_gtk_browser_store_request_unrefed_func,
    item
  );

  inf_signal_handlers_disconnect_by_func(
    G_OBJECT(request),
    G_CALLBACK(inf_gtk_browser_store_request_finished_cb),
    item
  );

  item-&gt;requests = g_slist_remove(item-&gt;requests, request);
}

static void
inf_gtk_browser_store_item_request_add(InfGtkBrowserStore* store,
                                       InfGtkBrowserStoreItem* item,
                                       InfRequest* request)
{</b></font>
  InfGtkBrowserStoreRequestData* data;

  g_assert(g_slist_find(item-&gt;requests, request) == NULL);
  item-&gt;requests = g_slist_prepend(item-&gt;requests, request);

  data = g_slice_new(InfGtkBrowserStoreRequestData);
  data-&gt;store = store;
  data-&gt;item = item;

  g_signal_connect_data(
    G_OBJECT(request),
    "finished",
    G_CALLBACK(inf_gtk_browser_store_request_finished_cb),
    data,
    inf_gtk_browser_store_request_data_free,
    0
  );
  
  g_object_weak_ref(
    G_OBJECT(request),
    inf_gtk_browser_store_request_unrefed_func,
    item
  );
}

static void
inf_gtk_browser_store_request_finished_cb(InfRequest* request,
                                          const InfRequestResult* result,
                                          const GError* error,
                                          gpointer user_data)
{
  InfGtkBrowserStoreRequestData* data;
  InfGtkBrowserStorePrivate* priv;
  InfBrowserIter request_iter;
  gboolean node_exists;
  GtkTreeIter tree_iter;
  GtkTreePath* path;

  data = (InfGtkBrowserStoreRequestData*)user_data;
  priv = INF_GTK_BROWSER_STORE_PRIVATE(data-&gt;store);

  g_assert(g_slist_find(data-&gt;item-&gt;requests, request) != NULL);
  g_assert(data-&gt;item-&gt;browser != NULL);

  /* request can be a explore-node or subscribe-session request */

  /* TODO: Also remove the request from the store when
   * it has properly finished? */
  if(error != NULL)
  {
    node_exists = inf_browser_iter_from_request(
      data-&gt;item-&gt;browser,
      request,
      &amp;request_iter
    );

    inf_gtk_browser_store_item_request_remove(data-&gt;item, request);

    /* Ignore if node has been removed in the meanwhile */
    if(G_LIKELY(node_exists))
    {
      /* Replace previous error */
      g_hash_table_insert(
        data-&gt;item-&gt;node_errors,
        GUINT_TO_POINTER(request_iter.node_id),
        g_error_copy(error)
      );

      tree_iter.stamp = priv-&gt;stamp;
      tree_iter.user_data = data-&gt;item;
      tree_iter.user_data2 = GUINT_TO_POINTER(request_iter.node_id);

      /* Set NULL for root node because it also refers to the store item as
       * such if no browser is set. */
      if(request_iter.node_id == 0)
        tree_iter.user_data3 = NULL;
      else
        tree_iter.user_data3 = request_iter.node;

      path = gtk_tree_model_get_path(GTK_TREE_MODEL(data-&gt;store), &amp;tree_iter);
      gtk_tree_model_row_changed(GTK_TREE_MODEL(data-&gt;store), path, &amp;tree_iter);
<a name="6"></a>      gtk_tree_path_free(path);
    }
  }
<font color="#8c8774"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>}

static void
inf_gtk_browser_store_request_unrefed_func(gpointer data,
                                           GObject* where_the_object_was)
{
  InfGtkBrowserStoreItem* item;
  item = (InfGtkBrowserStoreItem*)data;

  /* No need to further unregister */
  item-&gt;requests = g_slist_remove(item-&gt;requests, where_the_object_was);
}

static void
inf_gtk_browser_store_item_set_browser(InfGtkBrowserStore* store,
                                       InfGtkBrowserStoreItem* item,
                                       GtkTreePath* path,
                                       InfBrowser* browser)
{
  GtkTreeIter tree_iter;
  InfGtkBrowserStorePrivate* priv;

  priv = INF_GTK_BROWSER_STORE_PRIVATE(store);
  tree_iter.stamp = priv-&gt;stamp;</b></font>
  tree_iter.user_data = item;
  tree_iter.user_data2 = GUINT_TO_POINTER(0);
  tree_iter.user_data3 = NULL;

  /* The default signal handler sets the browser in the item and makes the
   * necessary TreeModel notifications. See
   * inf_gtk_browser_store_browser_model_set_browser(). */
  inf_gtk_browser_model_set_browser(
    INF_GTK_BROWSER_MODEL(store),
    path,
    &amp;tree_iter,
    item-&gt;browser,
    browser
  );
}

/* takes ownership of name */
static InfGtkBrowserStoreItem*
inf_gtk_browser_store_add_item_by_browser(InfGtkBrowserStore* store,
                                          InfDiscovery* discovery,
                                          InfDiscoveryInfo* info,
                                          InfBrowser* browser,
                                          gchar* name)
{
  InfGtkBrowserStorePrivate* priv;
  InfGtkBrowserStoreItem* item;
  InfGtkBrowserStoreItem* cur;
  GtkTreePath* path;
  GtkTreeIter iter;
  guint index;

  g_assert(
    browser == NULL ||
    inf_gtk_browser_store_find_item_by_browser(store, browser) == NULL
  );

  priv = INF_GTK_BROWSER_STORE_PRIVATE(store);
  item = g_slice_new(InfGtkBrowserStoreItem);
  item-&gt;name = name;
  item-&gt;discovery = discovery;
  item-&gt;info = info;
  item-&gt;status = INF_GTK_BROWSER_MODEL_DISCONNECTED;
  if(discovery != NULL &amp;&amp; info != NULL)
    item-&gt;status = INF_GTK_BROWSER_MODEL_DISCOVERED;
  item-&gt;browser = NULL;
  item-&gt;missing = NULL;
  item-&gt;node_errors = g_hash_table_new_full(
    NULL,
    NULL,
    NULL,
    (GDestroyNotify)g_error_free
  );
  item-&gt;requests = NULL;
  item-&gt;error = NULL;
  item-&gt;next = NULL;
  
  index = 0;
  for(cur = priv-&gt;first_item; cur != NULL; cur = cur-&gt;next)
    ++ index;

  /* Link */
  if(priv-&gt;first_item == NULL)
  {
    priv-&gt;first_item = item;
    priv-&gt;last_item = item;
  }
  else
  {
    priv-&gt;last_item-&gt;next = item;
    priv-&gt;last_item = item;
  }

  path = gtk_tree_path_new_from_indices(index, -1);
  iter.stamp = priv-&gt;stamp;
  iter.user_data = item;
  iter.user_data2 = GUINT_TO_POINTER(0);
  iter.user_data3 = NULL;

  gtk_tree_model_row_inserted(GTK_TREE_MODEL(store), path, &amp;iter);

  if(browser != NULL)
    inf_gtk_browser_store_item_set_browser(store, item, path, browser);

  gtk_tree_path_free(path);
  return item;
}


/* takes ownership of name */
static InfGtkBrowserStoreItem*
inf_gtk_browser_store_add_item_by_connection(InfGtkBrowserStore* store,
                                             InfDiscovery* discovery,
                                             InfDiscoveryInfo* info,
                                             InfXmlConnection* connection,
                                             gchar* name)
{
  InfGtkBrowserStorePrivate* priv;
  InfcBrowser* browser;
  InfGtkBrowserStoreItem* item;

  g_assert(
    connection == NULL ||
    inf_gtk_browser_store_find_item_by_connection(store, connection) == NULL
  );

  priv = INF_GTK_BROWSER_STORE_PRIVATE(store);
  browser = NULL;

  if(connection != NULL)
  {
    browser = infc_browser_new(
      priv-&gt;io,
      priv-&gt;communication_manager,
      connection
    );

    /* The connection is not set if the browser could not find a "central"
     * method for the connection's network. I don't think this can happen. */
    if(infc_browser_get_connection(browser) == NULL)
    {
      g_object_unref(browser);
      g_free(name);
      return NULL;
    }
  }

  item = inf_gtk_browser_store_add_item_by_browser(
    store,
    discovery,
    info,
    INF_BROWSER(browser),
    name
  );

  if(browser != NULL)
    g_object_unref(browser);

  return item;
}

static void
inf_gtk_browser_store_remove_item(InfGtkBrowserStore* store,
                                  InfGtkBrowserStoreItem* item)
{
  InfGtkBrowserStorePrivate* priv;
  InfGtkBrowserStoreItem* prev;
  InfGtkBrowserStoreItem* cur;
  GtkTreePath* path;
  guint index;

  priv = INF_GTK_BROWSER_STORE_PRIVATE(store);

  /* Determine index of item, to build a tree path to it */
  prev = NULL;
  index = 0;

  for(cur = priv-&gt;first_item; cur != NULL; cur = cur-&gt;next)
  {
    if(cur == item)
      break;

    prev = cur;
    ++ index;
  }

  /* Item was present in list */
  g_assert(cur != NULL);

  path = gtk_tree_path_new_from_indices(index, -1);

  /* Note we need to reset the browser before we unlink because
   * inf_gtk_browser_store_item_set_browser() requires item still being
   * linked for change notifications. */
  /* TODO: This is a bit cumbersome. A better way might be to be able for
   * the iter parameter to be NULL to indicate that an entry with
   * its browser has been deleted. However, this would still need to do
   * lots of the unregistration that is now happening in
   * inf_gtk_browser_store_item_set_browser(). */
  if(item-&gt;browser != NULL)
  {
    inf_gtk_browser_store_item_set_browser(store, item, path, NULL);
    g_assert(item-&gt;browser == NULL); /* Default handler must run */
  }

  /* Unlink */
  if(prev == NULL)
    priv-&gt;first_item = item-&gt;next;
  else
    prev-&gt;next = item-&gt;next;

  if(item-&gt;next == NULL)
    priv-&gt;last_item = prev;

  g_assert(cur != NULL);

  gtk_tree_model_row_deleted(GTK_TREE_MODEL(store), path);
  gtk_tree_path_free(path);

  if(item-&gt;error != NULL)
    g_error_free(item-&gt;error);

  g_hash_table_unref(item-&gt;node_errors);
  g_free(item-&gt;name);
  g_slice_free(InfGtkBrowserStoreItem, item);
}

/*
 * Callbacks and signal handlers
 */

static void
inf_gtk_browser_store_discovered_cb(InfDiscovery* discovery,
                                    InfDiscoveryInfo* info,
                                    gpointer user_data)
{
  inf_gtk_browser_store_add_item_by_browser(
    INF_GTK_BROWSER_STORE(user_data),
    discovery,
    info,
    NULL,
    inf_discovery_info_get_service_name(discovery, info)
  );
}

static void
inf_gtk_browser_store_undiscovered_cb(InfDiscovery* discovery,
                                      InfDiscoveryInfo* info,
                                      gpointer user_data)
{
  InfGtkBrowserStore* store;
  InfGtkBrowserStoreItem* item;

  store = INF_GTK_BROWSER_STORE(user_data);
  item = inf_gtk_browser_store_find_item_by_discovery_info(store, info);

  /* If, after a discovery resove we see that there is already an item for
   * that connection, then we remove the discovery item, and use the other
   * item instead. In that case, item can be NULL here. */
  if(item != NULL)
  {
    if(item-&gt;browser == NULL)
    {
      inf_gtk_browser_store_remove_item(store, item);
    }
    else
    {
      g_assert(item-&gt;status != INF_GTK_BROWSER_MODEL_DISCOVERED &amp;&amp;
               item-&gt;status != INF_GTK_BROWSER_MODEL_RESOLVING);

      item-&gt;discovery = NULL;
      item-&gt;info = NULL;
    }
  }
}

static void
inf_gtk_browser_store_browser_error_cb(InfBrowser* browser,
                                       const GError* error,
                                       gpointer user_data)
{
  InfGtkBrowserStore* store;
  InfGtkBrowserStoreItem* item;
  InfGtkBrowserStorePrivate* priv;
  GtkTreeIter iter;
  GtkTreePath* path;

  store = INF_GTK_BROWSER_STORE(user_data);
  priv = INF_GTK_BROWSER_STORE_PRIVATE(store);
  item = inf_gtk_browser_store_find_item_by_browser(store, browser);
  g_assert(item != NULL);

  /* Overwrite previous error */
  if(item-&gt;error != NULL)
    g_error_free(item-&gt;error);

  item-&gt;error = g_error_copy(error);
  /* Don't set error state, this could be a non-fatal error */

  /* Notify */
  iter.stamp = priv-&gt;stamp;
  iter.user_data = item;
  iter.user_data2 = GUINT_TO_POINTER(0);
  iter.user_data3 = NULL;

  path = gtk_tree_model_get_path(GTK_TREE_MODEL(store), &amp;iter);
  gtk_tree_model_row_changed(GTK_TREE_MODEL(store), path, &amp;iter);
  gtk_tree_path_free(path);
}

static void
inf_gtk_browser_store_browser_notify_status_cb(GObject* object,
                                               GParamSpec* pspec,
                                               gpointer user_data)
{
  InfGtkBrowserStore* store;
  InfGtkBrowserStorePrivate* priv;
  InfBrowser* browser;
  InfBrowserStatus status;
  InfGtkBrowserStoreItem* item;
  GtkTreeIter iter;
  GtkTreePath* path;

  store = INF_GTK_BROWSER_STORE(user_data);
  priv = INF_GTK_BROWSER_STORE_PRIVATE(user_data);  
  browser = INF_BROWSER(object);
  item = inf_gtk_browser_store_find_item_by_browser(store, browser);

  g_assert(item != NULL);

  iter.stamp = priv-&gt;stamp;
  iter.user_data = item;
  iter.user_data2 = GUINT_TO_POINTER(0);
  iter.user_data3 = NULL;

  path = gtk_tree_model_get_path(GTK_TREE_MODEL(store), &amp;iter);
  g_object_get(G_OBJECT(browser), "status", &amp;status, NULL);

  switch(status)
  {
  case INF_BROWSER_CLOSED:
    /* TODO: Do we want to go to disconnected state when error is not set? */
    item-&gt;status = INF_GTK_BROWSER_MODEL_ERROR;

    /* Set a "Disconnected" error if there is not already one set by
     * inf_gtk_browser_store_connection_error_cb() that has a more
     * meaningful error message. */
    if(item-&gt;error == NULL)
    {
      item-&gt;error = g_error_new_literal(
        g_quark_from_static_string("INF_GTK_BROWSER_STORE_ERROR"),
        0,
        _("Disconnected")
      );
    }

    gtk_tree_model_row_changed(GTK_TREE_MODEL(store), path, &amp;iter);
    break;
  case INF_BROWSER_OPENING:
    if(item-&gt;error != NULL) g_error_free(item-&gt;error);
    item-&gt;error = NULL;
    item-&gt;status = INF_GTK_BROWSER_MODEL_CONNECTING;
    gtk_tree_model_row_changed(GTK_TREE_MODEL(store), path, &amp;iter);
    break;
  case INF_BROWSER_OPEN:
    if(item-&gt;error != NULL) g_error_free(item-&gt;error);
    item-&gt;error = NULL;
    item-&gt;status = INF_GTK_BROWSER_MODEL_CONNECTED;
    gtk_tree_model_row_changed(GTK_TREE_MODEL(store), path, &amp;iter);
    break;
  default:
    g_assert_not_reached();
    break;
  }

  gtk_tree_path_free(path);
}

static void
inf_gtk_browser_store_node_added_cb(InfBrowser* browser,
                                    InfBrowserIter* iter,
                                    InfRequest* request,
                                    gpointer user_data)
{
  InfGtkBrowserStore* store;
  InfGtkBrowserStorePrivate* priv;
  InfGtkBrowserStoreItem* item;
  GtkTreeIter tree_iter;
  GtkTreePath* path;

  InfBrowserIter test_iter;
  gboolean test_result;

  store = INF_GTK_BROWSER_STORE(user_data);
  priv = INF_GTK_BROWSER_STORE_PRIVATE(store);
  item = inf_gtk_browser_store_find_item_by_browser(store, browser);

  tree_iter.stamp = priv-&gt;stamp;
  tree_iter.user_data = item;
  tree_iter.user_data2 = GUINT_TO_POINTER(iter-&gt;node_id);
  tree_iter.user_data3 = iter-&gt;node;

  if(iter-&gt;node_id != 0)
  {
    path = gtk_tree_model_get_path(GTK_TREE_MODEL(store), &amp;tree_iter);
    gtk_tree_model_row_inserted(GTK_TREE_MODEL(store), path, &amp;tree_iter);

    /* If iter is the only node within its parent, we need to emit the
     * row-has-child-toggled signal. */
    test_iter = *iter;
    test_result = inf_browser_get_parent(browser, &amp;test_iter);
    g_assert(test_result == TRUE);

    /* Let tree_iter point to parent row for possible notification */
    tree_iter.user_data2 = GUINT_TO_POINTER(test_iter.node_id);

    /* Also adjust path */
    gtk_tree_path_up(path);

    if(test_iter.node_id == 0)
      tree_iter.user_data3 = NULL;
    else
      tree_iter.user_data3 = test_iter.node;

    test_result = inf_browser_get_child(browser, &amp;test_iter);
    g_assert(test_result == TRUE);

    if(inf_browser_get_next(browser, &amp;test_iter) == FALSE)
    {
      gtk_tree_model_row_has_child_toggled(
        GTK_TREE_MODEL(store),
        path,
        &amp;tree_iter
      );
    }

    gtk_tree_path_free(path);
  }
}

static void
inf_gtk_browser_store_node_removed_cb(InfBrowser* browser,
                                      InfBrowserIter* iter,
                                      InfRequest* request,
                                      gpointer user_data)
{
  InfGtkBrowserStore* store;
  InfGtkBrowserStorePrivate* priv;
  InfGtkBrowserStoreItem* item;
  GtkTreeIter tree_iter;
  GtkTreePath* path;
  InfBrowserIter test_iter;
  gboolean test_result;

  store = INF_GTK_BROWSER_STORE(user_data);
  priv = INF_GTK_BROWSER_STORE_PRIVATE(store);
  item = inf_gtk_browser_store_find_item_by_browser(store, browser);

  g_assert(item-&gt;missing == NULL);

  tree_iter.stamp = priv-&gt;stamp;
  tree_iter.user_data = item;
  tree_iter.user_data2 = GUINT_TO_POINTER(iter-&gt;node_id);
  tree_iter.user_data3 = iter-&gt;node;

  path = gtk_tree_model_get_path(GTK_TREE_MODEL(store), &amp;tree_iter);

  /* This is a small hack to have the item removed from the tree
   * model before it is removed from the InfcBrowser. */

  item-&gt;missing = iter-&gt;node;

  if(iter-&gt;node_id != 0)
  {
    gtk_tree_model_row_deleted(GTK_TREE_MODEL(store), path);

  /* TODO: Remove requests and node errors from nodes below the removed one */

    /* Note that at this point removed node is still in the browser. We have
     * to emit row-has-child-toggled if it is the only one in its
     * subdirectory. */
    test_iter = *iter;
    test_result = inf_browser_get_parent(browser, &amp;test_iter);
    g_assert(test_result == TRUE);

    /* Let tree_iter point to parent row for possible notification */
    tree_iter.user_data2 = GUINT_TO_POINTER(test_iter.node_id);

    /* Also adjust path */
    gtk_tree_path_up(path);

    if(test_iter.node_id == 0)
      tree_iter.user_data3 = NULL;
    else
      tree_iter.user_data3 = test_iter.node;

    test_result = inf_browser_get_child(browser, &amp;test_iter);
    g_assert(test_result == TRUE);

    if(inf_browser_get_next(browser, &amp;test_iter) == FALSE)
    {
      gtk_tree_model_row_has_child_toggled(
        GTK_TREE_MODEL(store),
        path,
        &amp;tree_iter
      );
    }
  }
  else
  {
    /* The root node was removed. We don't remove the node from the
     * GtkTreeModel because it still represents the InfBrowser. Remove
     * all the children, however. */
    if(inf_browser_get_explored(browser, iter))
    {
      test_iter = *iter;
      test_result = inf_browser_get_child(browser, &amp;test_iter);
      gtk_tree_path_down(path);

      do
      {
        gtk_tree_model_row_deleted(GTK_TREE_MODEL(store), path);
      } while(inf_browser_get_next(browser, &amp;test_iter));

      if(test_result == TRUE)
      {
        gtk_tree_path_up(path);
        gtk_tree_model_row_has_child_toggled(
          GTK_TREE_MODEL(store),
          path,
          &amp;tree_iter
        );
      }
    }
  }

  item-&gt;missing = NULL;
  gtk_tree_path_free(path);
}

static void
inf_gtk_browser_store_begin_request_explore_node_cb(InfBrowser* browser,
                                                    InfBrowserIter* iter,
                                                    InfRequest* request,
                                                    gpointer user_data)
{
  InfGtkBrowserStore* store;
  InfGtkBrowserStoreItem* item;

  store = INF_GTK_BROWSER_STORE(user_data);
  item = inf_gtk_browser_store_find_item_by_browser(store, browser);

  inf_gtk_browser_store_item_request_add(store, item, request);
}

static void
inf_gtk_browser_store_begin_request_subscribe_session_cb(InfBrowser* browser,
                                                         InfBrowserIter* iter,
                                                         InfRequest* request,
                                                         gpointer user_data)
{
  InfGtkBrowserStore* store;
  InfGtkBrowserStoreItem* item;

  /* should not be a chat session, because chat session
   * has type subscribe-chat */
  g_assert(iter != NULL);

  store = INF_GTK_BROWSER_STORE(user_data);
  item = inf_gtk_browser_store_find_item_by_browser(store, browser);

  inf_gtk_browser_store_item_request_add(store, item, request);
}

static void
inf_gtk_browser_store_resolv_complete_func(InfDiscoveryInfo* info,
                                           InfXmlConnection* connection,
                                           const GError* error,
                                           gpointer user_data)
{
  InfGtkBrowserStore* store;
  InfGtkBrowserStorePrivate* priv;
  InfGtkBrowserStoreItem* new_item;
  InfGtkBrowserStoreItem* old_item;
  GtkTreeIter tree_iter;
  GtkTreePath* path;
  InfcBrowser* browser;

  InfGtkBrowserStoreItem* cur;
  InfGtkBrowserStoreItem* prev;
  InfGtkBrowserStoreItem* prev_new;
  InfGtkBrowserStoreItem* prev_old;
  gint* order;
  guint count;
  guint new_pos;
  guint old_pos;
  guint i;

  store = INF_GTK_BROWSER_STORE(user_data);
  priv = INF_GTK_BROWSER_STORE_PRIVATE(store);
  new_item = inf_gtk_browser_store_find_item_by_discovery_info(store, info);
  g_assert(new_item != NULL);
  g_assert(new_item-&gt;status == INF_GTK_BROWSER_MODEL_RESOLVING);

  tree_iter.stamp = priv-&gt;stamp;
  tree_iter.user_data = new_item;
  tree_iter.user_data2 = GUINT_TO_POINTER(0);
  tree_iter.user_data3 = NULL;

  if(error != NULL)
  {
    new_item-&gt;status = INF_GTK_BROWSER_MODEL_ERROR;
    new_item-&gt;error = g_error_copy(error);

    path = gtk_tree_model_get_path(GTK_TREE_MODEL(store), &amp;tree_iter);
    gtk_tree_model_row_changed(GTK_TREE_MODEL(store), path, &amp;tree_iter);
    gtk_tree_path_free(path);
  }
  else
  {
    old_item =
      inf_gtk_browser_store_find_item_by_connection(store, connection);

    if(old_item != NULL)
    {
      g_assert(old_item != new_item);

      /* There is already an item with the same connection. This is perhaps
       * from another discovery or was inserted directly. We remove the
       * current item and move the existing one to the place of it. */

      count = 0;
      prev = NULL;

      for(cur = priv-&gt;first_item; cur != NULL; cur = cur-&gt;next)
      {
        if(cur == old_item) { old_pos = count; prev_old = prev; }
        if(cur == new_item) { new_pos = count; prev_new = prev; }
        ++ count;
        prev = cur;
      }

      inf_gtk_browser_store_remove_item(store, new_item);
      if(old_pos &gt; new_pos) -- old_pos;
      else -- new_pos;
      -- count;

      /* Reorder list if the two items were not adjacent */
      if(new_pos != old_pos)
      {
        /* old item is last element, but it is moved elsewhere */
        if(old_item-&gt;next == NULL)
          priv-&gt;last_item = prev_old;

        /* Unlink old_item */
        if(prev_old != NULL)
          prev_old-&gt;next = old_item-&gt;next;
        else
          priv-&gt;first_item = old_item-&gt;next;

        /* Relink */
        old_item-&gt;next = prev_new-&gt;next;

        if(prev_new != NULL)
          prev_new-&gt;next = old_item;
        else
          priv-&gt;first_item = old_item;

        /* old_item has been moved to end of list */
        if(old_item-&gt;next == NULL)
          priv-&gt;last_item = old_item;

        order = g_malloc(sizeof(gint) * count);
        if(new_pos &lt; old_pos)
        {
          for(i = 0; i &lt; new_pos; ++ i)
            order[i] = i;
          order[new_pos] = old_pos;
          for(i = new_pos + 1; i &lt;= old_pos; ++ i)
            order[i] = i - 1;
          for(i = old_pos + 1; i &lt; count; ++ i)
            order[i] = i;
        }
        else
        {
          for(i = 0; i &lt; old_pos; ++ i)
            order[i] = i;
          for(i = old_pos; i &lt; new_pos; ++ i)
            order[i] = i + 1;
          order[new_pos] = old_pos;
          for(i = new_pos + 1; i &lt; count; ++ i)
            order[i] = i;
        }

        path = gtk_tree_path_new();
        gtk_tree_model_rows_reordered(
          GTK_TREE_MODEL(store),
          path,
          NULL,
          order
        );
        gtk_tree_path_free(path);

        /* TODO: Perhaps we should emit a signal so that the view can
         * highlight and scroll to the existing item. And also so that it can
         * over initial root exploration. */

        g_free(order);
      }
    }
    else
    {
      path = gtk_tree_model_get_path(GTK_TREE_MODEL(store), &amp;tree_iter);

      browser = infc_browser_new(
        priv-&gt;io,
        priv-&gt;communication_manager,
        connection
      );

      /* The connection is not set if the browser could not find a "central"
       * method for the connection's network. */
      /* TODO: Set error */
      if(infc_browser_get_connection(browser) != NULL)
      {
        inf_gtk_browser_store_item_set_browser(
          store,
          new_item,
          path,
          INF_BROWSER(browser)
        );
      }

      g_object_unref(G_OBJECT(browser));
      gtk_tree_path_free(path);
    }
  }
}

/*
 * GObject overrides
 */

static void
inf_gtk_browser_store_init(InfGtkBrowserStore* store)
{
  InfGtkBrowserStorePrivate* priv;
<a name="2"></a>  priv = INF_GTK_BROWSER_STORE_PRIVATE(store);

  priv-&gt;stamp = g_random_int();
<font color="#980517"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>  priv-&gt;io = NULL;
  priv-&gt;communication_manager = NULL;
  priv-&gt;discoveries = NULL;
  priv-&gt;first_item = NULL;
  priv-&gt;last_item = NULL;
}

static void
inf_gtk_browser_store_dispose(GObject* object)
{
  InfGtkBrowserStore* store;
  InfGtkBrowserStorePrivate* priv;
  GSList* item;

  store = INF_GTK_BROWSER_STORE(object);</b></font>
  priv = INF_GTK_BROWSER_STORE_PRIVATE(store);

  while(priv-&gt;first_item != NULL)
    inf_gtk_browser_store_remove_item(store, priv-&gt;first_item);
  g_assert(priv-&gt;last_item == NULL);

  for(item = priv-&gt;discoveries; item != NULL; item = g_slist_next(item))
  {
    inf_signal_handlers_disconnect_by_func(
      G_OBJECT(item-&gt;data),
      G_CALLBACK(inf_gtk_browser_store_discovered_cb),
      store
    );

    inf_signal_handlers_disconnect_by_func(
      G_OBJECT(item-&gt;data),
      G_CALLBACK(inf_gtk_browser_store_undiscovered_cb),
      store
    );

    g_object_unref(G_OBJECT(item-&gt;data));
<a name="4"></a>  }

  g_slist_free(priv-&gt;discoveries);
<font color="#6cc417"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>  priv-&gt;discoveries = NULL;

  if(priv-&gt;communication_manager != NULL)
  {
    g_object_unref(priv-&gt;communication_manager);
    priv-&gt;communication_manager = NULL;
  }

  if(priv-&gt;io != NULL)
  {
    g_object_unref(G_OBJECT(priv-&gt;io));
    priv-&gt;io = NULL;
<a name="0"></a>  }</b></font>

  G_OBJECT_CLASS(inf_gtk_browser_store_parent_class)-&gt;dispose(object);
<font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>}

static void
inf_gtk_browser_store_set_property(GObject* object,
                                   guint prop_id,
                                   const GValue* value,
                                   GParamSpec* pspec)
{
  InfGtkBrowserStore* store;
  InfGtkBrowserStorePrivate* priv;

  store = INF_GTK_BROWSER_STORE(object);
  priv = INF_GTK_BROWSER_STORE_PRIVATE(store);

  switch(prop_id)
  {
  case PROP_IO:
    g_assert(priv-&gt;io == NULL); /* construct only */
    priv-&gt;io = INF_IO(g_value_dup_object(value));
    break;
  case PROP_COMMUNICATION_MANAGER: 
    g_assert(priv-&gt;communication_manager == NULL); /* construct only */
    priv-&gt;communication_manager =
<a name="1"></a>      INF_COMMUNICATION_MANAGER(g_value_dup_object(value));

    break;</b></font>
<font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>  default:
    G_OBJECT_WARN_INVALID_PROPERTY_ID(object, prop_id, pspec);
    break;
  }
}

static void
inf_gtk_browser_store_get_property(GObject* object,
                                   guint prop_id,
                                   GValue* value,
                                   GParamSpec* pspec)
{
  InfGtkBrowserStore* store;
  InfGtkBrowserStorePrivate* priv;

  store = INF_GTK_BROWSER_STORE(object);
  priv = INF_GTK_BROWSER_STORE_PRIVATE(store);

  switch(prop_id)
  {
  case PROP_IO:
    g_value_set_object(value, priv-&gt;io);
    break;
  case PROP_COMMUNICATION_MANAGER:
    g_value_set_object(value, priv-&gt;communication_manager);
    break;</b></font>
  default:
    G_OBJECT_WARN_INVALID_PROPERTY_ID(object, prop_id, pspec);
    break;
  }
}

/*
 * GtkTreeModel implementation
 */

static GtkTreeModelFlags
inf_gtk_browser_store_tree_model_get_flags(GtkTreeModel* model)
{
  return GTK_TREE_MODEL_ITERS_PERSIST;
}

static gint
inf_gtk_browser_store_tree_model_get_n_columns(GtkTreeModel* model)
{
  return INF_GTK_BROWSER_MODEL_NUM_COLS;
}

static GType
inf_gtk_browser_store_tree_model_get_column_type(GtkTreeModel* model,
                                                 gint index)
{
  switch(index)
  {
  case INF_GTK_BROWSER_MODEL_COL_DISCOVERY_INFO:
    return G_TYPE_POINTER;
  case INF_GTK_BROWSER_MODEL_COL_DISCOVERY:
    return INF_TYPE_DISCOVERY;
  case INF_GTK_BROWSER_MODEL_COL_BROWSER:
    return INFC_TYPE_BROWSER;
  case INF_GTK_BROWSER_MODEL_COL_STATUS:
    return INF_GTK_TYPE_BROWSER_MODEL_STATUS;
  case INF_GTK_BROWSER_MODEL_COL_NAME:
    return G_TYPE_STRING;
  case INF_GTK_BROWSER_MODEL_COL_ERROR:
    return G_TYPE_POINTER;
  case INF_GTK_BROWSER_MODEL_COL_NODE:
    return INF_TYPE_BROWSER_ITER;
  default:
    g_assert_not_reached();
    return G_TYPE_INVALID;
  }
}

static gboolean
inf_gtk_browser_store_tree_model_get_iter(GtkTreeModel* model,
                                          GtkTreeIter* iter,
                                          GtkTreePath* path)
{
  InfGtkBrowserStorePrivate* priv;
  InfGtkBrowserStoreItem* item;
  InfBrowserIter browser_iter;
  gint* indices;

  guint i;
  guint n;

  priv = INF_GTK_BROWSER_STORE_PRIVATE(model);
  if(gtk_tree_path_get_depth(path) == 0) return FALSE;

  indices = gtk_tree_path_get_indices(path);
  n = indices[0];

  i = 0;
  for(item = priv-&gt;first_item; item != NULL &amp;&amp; i &lt; n; item = item-&gt;next)
    ++i;

  if(item == NULL) return FALSE;

  /* Depth 1 */
  if(gtk_tree_path_get_depth(path) == 1)
  {
    iter-&gt;stamp = priv-&gt;stamp;
    iter-&gt;user_data = item;
    iter-&gt;user_data2 = GUINT_TO_POINTER(0);
    iter-&gt;user_data3 = NULL;
    return TRUE;
  }

  if(item-&gt;browser == NULL) return FALSE;
  inf_browser_get_root(item-&gt;browser, &amp;browser_iter);

  for(n = 1; n &lt; (guint)gtk_tree_path_get_depth(path); ++ n)
  {
    if(inf_browser_get_explored(item-&gt;browser, &amp;browser_iter) == FALSE)
      return FALSE;

    if(inf_browser_get_child(item-&gt;browser, &amp;browser_iter) == FALSE)
      return FALSE;

    /* skip missing */
    if(browser_iter.node == item-&gt;missing)
      ++indices[n];

    for(i = 0; i &lt; (guint)indices[n]; ++ i)
    {
      if(inf_browser_get_next(item-&gt;browser, &amp;browser_iter) == FALSE)
        return FALSE;

      /* skip missing */
      if(browser_iter.node == item-&gt;missing)
        ++indices[n];
    }
  }

  iter-&gt;stamp = priv-&gt;stamp;
  iter-&gt;user_data = item;
  iter-&gt;user_data2 = GUINT_TO_POINTER(browser_iter.node_id);
  iter-&gt;user_data3 = browser_iter.node;
  return TRUE;
}

/* TODO: We can also use gtk_tree_path_prepend_index and do tail
 * recursion. We should find out which is faster. */
static void
inf_gtk_browser_store_tree_model_get_path_impl(InfGtkBrowserStore* store,
                                               InfGtkBrowserStoreItem* item,
                                               InfBrowserIter* iter,
                                               GtkTreePath* path)
{
  InfGtkBrowserStorePrivate* priv;
  InfBrowserIter cur_iter;
  InfGtkBrowserStoreItem* cur;
  gboolean result;
  guint n;

  cur_iter = *iter;
  if(inf_browser_get_parent(item-&gt;browser, &amp;cur_iter) == FALSE)
  {
    priv = INF_GTK_BROWSER_STORE_PRIVATE(store);

    /* We are on top level, but still need to find the item index */
    n = 0;
    for(cur = priv-&gt;first_item; cur != item; cur = cur-&gt;next)
      ++n;

    gtk_tree_path_append_index(path, n);
  }
  else
  {
    inf_gtk_browser_store_tree_model_get_path_impl(
      store,
      item,
      &amp;cur_iter,
      path
    );

    result = inf_browser_get_child(item-&gt;browser, &amp;cur_iter);
    g_assert(result == TRUE);

    /* skip missing */
    if(cur_iter.node == item-&gt;missing)
    {
      result = inf_browser_get_next(item-&gt;browser, &amp;cur_iter);
      g_assert(result == TRUE);
    }

    n = 0;
    while(cur_iter.node_id != iter-&gt;node_id)
    {
      result = inf_browser_get_next(item-&gt;browser, &amp;cur_iter);
      g_assert(result == TRUE);

      /* skip missing */
      if(cur_iter.node == item-&gt;missing)
      {
        result = inf_browser_get_next(item-&gt;browser, &amp;cur_iter);
        g_assert(result == TRUE);
      }

      ++n;
    }

    gtk_tree_path_append_index(path, n);
  }
}

static GtkTreePath*
inf_gtk_browser_store_tree_model_get_path(GtkTreeModel* model,
                                          GtkTreeIter* iter)
{
  InfGtkBrowserStorePrivate* priv;
  InfGtkBrowserStoreItem* item;
  InfGtkBrowserStoreItem* cur;
  GtkTreePath* path;
  InfBrowserIter browser_iter;
  guint n;

  priv = INF_GTK_BROWSER_STORE_PRIVATE(model);
  g_assert(iter-&gt;stamp == priv-&gt;stamp);
  g_assert(iter-&gt;user_data != NULL);

  item = (InfGtkBrowserStoreItem*)iter-&gt;user_data;

  path = gtk_tree_path_new();
  browser_iter.node_id = GPOINTER_TO_UINT(iter-&gt;user_data2);
  browser_iter.node = iter-&gt;user_data3;

  if(browser_iter.node != NULL)
  {
    g_assert(item-&gt;browser != NULL);

    inf_gtk_browser_store_tree_model_get_path_impl(
      INF_GTK_BROWSER_STORE(model),
      item,
      &amp;browser_iter,
      path
    );
  }
  else
  {
    /* toplevel */
    n = 0;
    for(cur = priv-&gt;first_item; cur != item; cur = cur-&gt;next)
      ++n;

    gtk_tree_path_append_index(path, n);
  }

  return path;
}

static void
inf_gtk_browser_store_tree_model_get_value(GtkTreeModel* model,
                                           GtkTreeIter* iter,
                                           gint column,
                                           GValue* value)
{
  InfGtkBrowserStorePrivate* priv;
  InfGtkBrowserStoreItem* item;
  InfBrowserIter browser_iter;
  InfBrowserStatus browser_status;
  GError* error;

  priv = INF_GTK_BROWSER_STORE_PRIVATE(model);
  g_assert(iter-&gt;stamp == priv-&gt;stamp);

  item = (InfGtkBrowserStoreItem*)iter-&gt;user_data;
  browser_iter.node_id = GPOINTER_TO_UINT(iter-&gt;user_data2);
  browser_iter.node = iter-&gt;user_data3;

  /* If this iterator is the missing one, then it must be the root node,
   * otherwise this function must not have been called; it would have
   * been called on a non-existing entry. */
  g_assert(
    item-&gt;missing == NULL || browser_iter.node_id == 0 ||
    browser_iter.node != item-&gt;missing
  );

  switch(column)
  {
  case INF_GTK_BROWSER_MODEL_COL_DISCOVERY_INFO:
    g_value_init(value, G_TYPE_POINTER);
    g_value_set_pointer(value, item-&gt;info);
    break;
  case INF_GTK_BROWSER_MODEL_COL_DISCOVERY:
    g_value_init(value, G_TYPE_OBJECT);
    g_value_set_object(value, item-&gt;discovery);
    break;
  case INF_GTK_BROWSER_MODEL_COL_BROWSER:
    g_value_init(value, INF_TYPE_BROWSER);
    g_value_set_object(value, G_OBJECT(item-&gt;browser));
    break;
  case INF_GTK_BROWSER_MODEL_COL_STATUS:
    g_assert(browser_iter.node == NULL); /* only toplevel */
    g_value_init(value, INF_GTK_TYPE_BROWSER_MODEL_STATUS);
    g_value_set_enum(value, item-&gt;status);
    break;
  case INF_GTK_BROWSER_MODEL_COL_NAME:
    g_value_init(value, G_TYPE_STRING);
    if(browser_iter.node == NULL)
    {
      g_value_set_string(value, item-&gt;name);
    }
    else
    {
      g_value_set_string(
        value,
        inf_browser_get_node_name(INF_BROWSER(item-&gt;browser), &amp;browser_iter)
      );
    }
    break;
  case INF_GTK_BROWSER_MODEL_COL_ERROR:
    if(browser_iter.node == NULL)
    {
      /* toplevel */
      if(item-&gt;error != NULL)
      {
        /* not a node related error, perhaps connection error */
        error = item-&gt;error;
      }
      else if(item-&gt;browser != NULL)
      {
        /* error on root node */
        g_object_get(
          G_OBJECT(item-&gt;browser),
          "status",
          &amp;browser_status,
          NULL
        );

        if(browser_status == INF_BROWSER_OPEN)
        {
          inf_browser_get_root(item-&gt;browser, &amp;browser_iter);
          error = g_hash_table_lookup(
            item-&gt;node_errors,
            GUINT_TO_POINTER(browser_iter.node_id)
          );
        }
        else
        {
          /* Browser exists but is closed, but there is no connection error
           * set: no error */
          error = NULL;
        }
      }
      else
      {
        /* Neither error nor browser set: no error */
        error = NULL;
      }
    }
    else
    {
      g_assert(item-&gt;browser != NULL);

      g_object_get(G_OBJECT(item-&gt;browser), "status", &amp;browser_status, NULL);
      g_assert(browser_status == INF_BROWSER_OPEN);

      error = g_hash_table_lookup(
        item-&gt;node_errors,
        GUINT_TO_POINTER(browser_iter.node_id)
      );
    }

    g_value_init(value, G_TYPE_POINTER);
    g_value_set_pointer(value, error);
    break;
  case INF_GTK_BROWSER_MODEL_COL_NODE:
    g_assert(item-&gt;browser != NULL);

    g_object_get(G_OBJECT(item-&gt;browser), "status", &amp;browser_status, NULL);
    g_assert(browser_status == INF_BROWSER_OPEN);

    if(browser_iter.node == NULL)
      inf_browser_get_root(item-&gt;browser, &amp;browser_iter);

    g_value_init(value, INF_TYPE_BROWSER_ITER);
    g_value_set_boxed(value, &amp;browser_iter);
    break;
  default:
    g_assert_not_reached();
    break;
  }
}

static gboolean
inf_gtk_browser_store_tree_model_iter_next(GtkTreeModel* model,
                                           GtkTreeIter* iter)
{
  InfGtkBrowserStorePrivate* priv;
  InfGtkBrowserStoreItem* item;
  InfBrowserIter browser_iter;

  priv = INF_GTK_BROWSER_STORE_PRIVATE(model);
  g_assert(iter-&gt;stamp == priv-&gt;stamp);

  item = (InfGtkBrowserStoreItem*)iter-&gt;user_data;
  browser_iter.node_id = GPOINTER_TO_UINT(iter-&gt;user_data2);
  browser_iter.node = iter-&gt;user_data3;

  if(browser_iter.node == NULL)
  {
    if(item-&gt;next == NULL)
      return FALSE;

    iter-&gt;user_data = item-&gt;next;
    return TRUE;
  }
  else
  {
    g_assert(browser_iter.node != item-&gt;missing);

    if(inf_browser_get_next(item-&gt;browser, &amp;browser_iter) == FALSE)
      return FALSE;

    /* skip missing */
    if(browser_iter.node == item-&gt;missing)
      if(inf_browser_get_next(item-&gt;browser, &amp;browser_iter) == FALSE)
        return FALSE;

    iter-&gt;user_data2 = GUINT_TO_POINTER(browser_iter.node_id);
    iter-&gt;user_data3 = browser_iter.node;
    return TRUE;
  }
}

static gboolean
inf_gtk_browser_store_tree_model_iter_children(GtkTreeModel* model,
                                               GtkTreeIter* iter,
                                               GtkTreeIter* parent)
{
  InfGtkBrowserStorePrivate* priv;
  InfGtkBrowserStoreItem* item;
  InfBrowserStatus browser_status;
  InfBrowserIter browser_iter;

  priv = INF_GTK_BROWSER_STORE_PRIVATE(model);

  if(parent == NULL)
  {
    if(priv-&gt;first_item == NULL)
      return FALSE;

    iter-&gt;stamp = priv-&gt;stamp;
    iter-&gt;user_data = priv-&gt;first_item;
    iter-&gt;user_data2 = GUINT_TO_POINTER(0);
    iter-&gt;user_data3 = NULL;
    return TRUE;
  }
  else
  {
    g_assert(parent-&gt;stamp == priv-&gt;stamp);

    item = (InfGtkBrowserStoreItem*)parent-&gt;user_data;
    if(item-&gt;browser == NULL)
      return FALSE;

    g_object_get(G_OBJECT(item-&gt;browser), "status", &amp;browser_status, NULL);
    if(browser_status != INF_BROWSER_OPEN)
      return FALSE;

    browser_iter.node_id = GPOINTER_TO_UINT(parent-&gt;user_data2);
    if(browser_iter.node_id == 0)
      inf_browser_get_root(item-&gt;browser, &amp;browser_iter);
    else
      browser_iter.node = parent-&gt;user_data3;

    /* If this iterator is the missing one, then it must be the root node,
     * otherwise this function must not have been called; it would have
     * been called on a non-existing entry. */
    g_assert(
      item-&gt;missing == NULL || browser_iter.node_id == 0 ||
      browser_iter.node != item-&gt;missing
    );

    if(item-&gt;missing != NULL &amp;&amp; browser_iter.node == item-&gt;missing)
      return FALSE;

    if(!inf_browser_is_subdirectory(item-&gt;browser, &amp;browser_iter))
      return FALSE;

    if(!inf_browser_get_explored(item-&gt;browser, &amp;browser_iter))
      return FALSE;

    if(!inf_browser_get_child(item-&gt;browser, &amp;browser_iter))
      return FALSE;

    if(browser_iter.node == item-&gt;missing)
      if(!inf_browser_get_next(item-&gt;browser, &amp;browser_iter))
        return FALSE;

    iter-&gt;stamp = priv-&gt;stamp;
    iter-&gt;user_data = item;
    iter-&gt;user_data2 = GUINT_TO_POINTER(browser_iter.node_id);
    iter-&gt;user_data3 = browser_iter.node;
    return TRUE;
  }
}

static gboolean
inf_gtk_browser_store_tree_model_iter_has_child(GtkTreeModel* model,
                                                GtkTreeIter* iter)
{
  InfGtkBrowserStorePrivate* priv;
  InfGtkBrowserStoreItem* item;
  InfBrowserStatus status;
  InfBrowserIter browser_iter;

  priv = INF_GTK_BROWSER_STORE_PRIVATE(model);
  g_assert(iter-&gt;stamp == priv-&gt;stamp);

  item = (InfGtkBrowserStoreItem*)iter-&gt;user_data;
  if(item-&gt;browser == NULL) return FALSE;

  browser_iter.node_id = GPOINTER_TO_UINT(iter-&gt;user_data2);
  browser_iter.node = iter-&gt;user_data3;

  g_object_get(G_OBJECT(item-&gt;browser), "status", &amp;status, NULL);
  if(status != INF_BROWSER_OPEN)
    return FALSE;

  if(browser_iter.node == NULL)
    inf_browser_get_root(item-&gt;browser, &amp;browser_iter);

  /* If this iterator is the missing one, then it must be the root node,
   * otherwise this function must not have been called; it would have
   * been called on a non-existing entry. */
  g_assert(
    item-&gt;missing == NULL || browser_iter.node_id == 0 ||
    browser_iter.node != item-&gt;missing
  );

  if(item-&gt;missing != NULL &amp;&amp; browser_iter.node == item-&gt;missing)
    return FALSE;

  if(inf_browser_is_subdirectory(item-&gt;browser, &amp;browser_iter) == FALSE)
    return FALSE;

  if(inf_browser_get_explored(item-&gt;browser, &amp;browser_iter) == FALSE)
    return FALSE;

  if(!inf_browser_get_child(item-&gt;browser, &amp;browser_iter))
    return FALSE;

  if(browser_iter.node == item-&gt;missing)
    if(!inf_browser_get_next(item-&gt;browser, &amp;browser_iter))
      return FALSE;

  return TRUE;
}

static gint
inf_gtk_browser_store_tree_model_iter_n_children(GtkTreeModel* model,
                                                 GtkTreeIter* iter)
{
  InfGtkBrowserStorePrivate* priv;
  InfGtkBrowserStoreItem* item;
  InfGtkBrowserStoreItem* cur;
  InfBrowserIter browser_iter;
  gboolean result;
  guint n;

  priv = INF_GTK_BROWSER_STORE_PRIVATE(model);
  g_assert(iter == NULL || iter-&gt;stamp == priv-&gt;stamp);

  if(iter == NULL)
  {
    n = 0;
    for(cur = priv-&gt;first_item; cur != NULL; cur = cur-&gt;next)
      ++n;

    return n;
  }
  else
  {
    item = (InfGtkBrowserStoreItem*)iter-&gt;user_data;
    browser_iter.node_id = GPOINTER_TO_UINT(iter-&gt;user_data2);
    browser_iter.node = iter-&gt;user_data3;

    if(browser_iter.node == NULL)
      inf_browser_get_root(item-&gt;browser, &amp;browser_iter);

    /* If this iterator is the missing one, then it must be the root node,
     * otherwise this function must not have been called; it would have
     * been called on a non-existing entry. */
    g_assert(
      item-&gt;missing == NULL || browser_iter.node_id == 0 ||
      browser_iter.node != item-&gt;missing
    );

    if(item-&gt;missing != NULL &amp;&amp; browser_iter.node == item-&gt;missing)
      return 0;

    n = 0;
    for(result = inf_browser_get_child(item-&gt;browser, &amp;browser_iter);
        result == TRUE;
        result = inf_browser_get_next(item-&gt;browser, &amp;browser_iter))
    {
      if(browser_iter.node != item-&gt;missing)
        ++n;
    }

    return n;
  }
}

static gboolean
inf_gtk_browser_store_tree_model_iter_nth_child(GtkTreeModel* model,
                                                GtkTreeIter* iter,
                                                GtkTreeIter* parent,
                                                gint n)
{
  InfGtkBrowserStorePrivate* priv;
  InfGtkBrowserStoreItem* item;
  InfGtkBrowserStoreItem* cur;
  InfBrowserIter browser_iter;
  guint i;

  priv = INF_GTK_BROWSER_STORE_PRIVATE(model);

  if(parent == NULL)
  {
    cur = priv-&gt;first_item;
    if(cur == NULL) return FALSE;

    for(i = 0; i &lt; (guint)n; ++ i)
    {
      cur = cur-&gt;next;
      if(cur == NULL) return FALSE;
    }

    iter-&gt;stamp = priv-&gt;stamp;
    iter-&gt;user_data = cur;
    iter-&gt;user_data2 = GUINT_TO_POINTER(0);
    iter-&gt;user_data3 = NULL;
    return TRUE;
  }
  else
  {
    g_assert(parent-&gt;stamp == priv-&gt;stamp);

    item = (InfGtkBrowserStoreItem*)parent-&gt;user_data;
    browser_iter.node_id = GPOINTER_TO_UINT(parent-&gt;user_data2);

    if(browser_iter.node_id == 0)
      inf_browser_get_root(item-&gt;browser, &amp;browser_iter);
    else
      browser_iter.node = parent-&gt;user_data3;

    /* If this iterator is the missing one, then it must be the root node,
     * otherwise this function must not have been called; it would have
     * been called on a non-existing entry. */
    g_assert(
      item-&gt;missing == NULL || browser_iter.node_id == 0 ||
      browser_iter.node != item-&gt;missing
    );

    if(item-&gt;missing != NULL &amp;&amp; browser_iter.node == item-&gt;missing)
      return FALSE;

    if(inf_browser_get_explored(item-&gt;browser, &amp;browser_iter) == FALSE)
      return FALSE;

    if(inf_browser_get_child(item-&gt;browser, &amp;browser_iter) == FALSE)
      return FALSE;

    /* skip missing */
    if(browser_iter.node == item-&gt;missing)
      ++n;

    for(i = 0; i &lt; (guint)n; ++ i)
    {
      if(inf_browser_get_next(item-&gt;browser, &amp;browser_iter) == FALSE)
        return FALSE;

      if(browser_iter.node == item-&gt;missing)
        ++n;
    }

    iter-&gt;stamp = priv-&gt;stamp;
    iter-&gt;user_data = item;
    iter-&gt;user_data2 = GUINT_TO_POINTER(browser_iter.node_id);
    iter-&gt;user_data3 = browser_iter.node;
    return TRUE;
  }
}

static gboolean
inf_gtk_browser_store_tree_model_iter_parent(GtkTreeModel* model,
                                             GtkTreeIter* iter,
                                             GtkTreeIter* child)
{
  InfGtkBrowserStorePrivate* priv;
  InfGtkBrowserStoreItem* item;
  InfBrowserIter browser_iter;
  gboolean result;

  priv = INF_GTK_BROWSER_STORE_PRIVATE(model);
  g_assert(child-&gt;stamp == priv-&gt;stamp);

  item = (InfGtkBrowserStoreItem*)child-&gt;user_data;
  browser_iter.node_id = GPOINTER_TO_UINT(child-&gt;user_data2);
  browser_iter.node = child-&gt;user_data3;

  if(browser_iter.node == NULL)
    return FALSE;

  g_assert(browser_iter.node != item-&gt;missing);

  result = inf_browser_get_parent(item-&gt;browser, &amp;browser_iter);
  g_assert(result == TRUE);
  g_assert(browser_iter.node != item-&gt;missing);

  iter-&gt;stamp = priv-&gt;stamp;
  iter-&gt;user_data = item;
  iter-&gt;user_data2 = GUINT_TO_POINTER(browser_iter.node_id);
  iter-&gt;user_data3 = browser_iter.node;

  /* Root node */
  if(browser_iter.node_id == 0)
    iter-&gt;user_data3 = NULL;

  return TRUE;
}

/*
 * InfGtkBrowserModel implementation.
 */

static void
inf_gtk_browser_store_browser_model_set_browser(InfGtkBrowserModel* model,
                                                GtkTreePath* path,
                                                GtkTreeIter* tree_iter,
                                                InfBrowser* old_browser,
                                                InfBrowser* new_browser)
{
  InfGtkBrowserStorePrivate* priv;
  InfGtkBrowserStoreItem* item;

  InfBrowserIter iter;
  guint n;
  gboolean had_children;
  InfBrowserStatus status;

  priv = INF_GTK_BROWSER_STORE_PRIVATE(model);
  had_children = FALSE;

  item = (InfGtkBrowserStoreItem*)tree_iter-&gt;user_data;
  /* cannot set browser in non-toplevel entries */
  g_assert(tree_iter-&gt;user_data3 == NULL);

  if(item-&gt;browser != NULL)
  {
    g_assert(item-&gt;browser == old_browser);
    g_object_get(G_OBJECT(item-&gt;browser), "status", &amp;status, NULL);
    if(status == INF_BROWSER_OPEN)
    {
      /* Notify about deleted rows. Notify in reverse order so that indexing
       * continues to work. Remember whether we had children to emit
       * row-has-child-toggled later. */
      inf_browser_get_root(item-&gt;browser, &amp;iter);
      if(inf_browser_get_explored(item-&gt;browser, &amp;iter) &amp;&amp;
         inf_browser_get_child(item-&gt;browser, &amp;iter))
      {
        n = 1;
        while(inf_browser_get_next(item-&gt;browser, &amp;iter))
          ++ n;

        gtk_tree_path_append_index(path, n);

        for(; n &gt; 0; -- n)
        {
          had_children = TRUE;
          gtk_tree_path_prev(path);
          gtk_tree_model_row_deleted(GTK_TREE_MODEL(model), path);
        }

        gtk_tree_path_up(path);
      }
    }

    while(item-&gt;requests != NULL)
      inf_gtk_browser_store_item_request_remove(item, item-&gt;requests-&gt;data);

    g_hash_table_remove_all(item-&gt;node_errors);

    inf_signal_handlers_disconnect_by_func(
      G_OBJECT(item-&gt;browser),
      G_CALLBACK(inf_gtk_browser_store_browser_error_cb),
      model
    );

    inf_signal_handlers_disconnect_by_func(
      G_OBJECT(item-&gt;browser),
      G_CALLBACK(inf_gtk_browser_store_browser_notify_status_cb),
      model
    );

    inf_signal_handlers_disconnect_by_func(
      G_OBJECT(item-&gt;browser),
      G_CALLBACK(inf_gtk_browser_store_node_added_cb),
      model
    );

    inf_signal_handlers_disconnect_by_func(
      G_OBJECT(item-&gt;browser),
      G_CALLBACK(inf_gtk_browser_store_node_removed_cb),
      model
    );

    inf_signal_handlers_disconnect_by_func(
      G_OBJECT(item-&gt;browser),
      G_CALLBACK(inf_gtk_browser_store_begin_request_explore_node_cb),
      model
    );

    inf_signal_handlers_disconnect_by_func(
      G_OBJECT(item-&gt;browser),
      G_CALLBACK(inf_gtk_browser_store_begin_request_subscribe_session_cb),
      model
    );

    g_object_unref(G_OBJECT(item-&gt;browser));
  }

  /* Reset browser for emitting row-has-child-toggled */
  item-&gt;browser = NULL;
  if(had_children)
  {
    gtk_tree_model_row_has_child_toggled(
      GTK_TREE_MODEL(model),
      path,
      tree_iter
    );
  }

  /* Set up new browser */
  item-&gt;browser = new_browser;

  if(new_browser != NULL)
  {
    g_object_ref(new_browser);

    g_signal_connect(
      G_OBJECT(item-&gt;browser),
      "error",
      G_CALLBACK(inf_gtk_browser_store_browser_error_cb),
      model
    );
      
    g_signal_connect(
      G_OBJECT(item-&gt;browser),
      "notify::status",
      G_CALLBACK(inf_gtk_browser_store_browser_notify_status_cb),
      model
    );

    g_signal_connect_after(
      G_OBJECT(item-&gt;browser),
      "node-added",
      G_CALLBACK(inf_gtk_browser_store_node_added_cb),
      model
    );

    g_signal_connect_after(
      G_OBJECT(item-&gt;browser),
      "node-removed",
      G_CALLBACK(inf_gtk_browser_store_node_removed_cb),
      model
    );

    g_signal_connect_after(
      G_OBJECT(item-&gt;browser),
      "begin-request::explore-node",
      G_CALLBACK(inf_gtk_browser_store_begin_request_explore_node_cb),
      model
    );

    g_signal_connect_after(
      G_OBJECT(item-&gt;browser),
      "begin-request::subscribe-session",
      G_CALLBACK(inf_gtk_browser_store_begin_request_subscribe_session_cb),
      model
    );

    /* TODO: Walk browser for requests */
  }

  /* Set status to invalid if there aren't any connection information anymore.
   * Keep the item if an error is set, so it can be displayed. */
  if(item-&gt;browser == NULL &amp;&amp; item-&gt;info == NULL &amp;&amp;
     (item-&gt;error == NULL || item-&gt;status != INF_GTK_BROWSER_MODEL_ERROR))
  {
    /* This can happen when an API call leads to a browser being unset */
    /* Clear non-fatal error */
    g_assert(item-&gt;status != INF_GTK_BROWSER_MODEL_ERROR);
    if(item-&gt;error != NULL)
    {
      g_error_free(item-&gt;error);
      item-&gt;error = NULL;
    }

    item-&gt;status = INF_GTK_BROWSER_MODEL_INVALID;
  }
  else if(item-&gt;status != INF_GTK_BROWSER_MODEL_ERROR)
  {
    /* Set item status according to browser status if there is no
     * error set. */
    if(item-&gt;browser != NULL)
    {
      g_object_get(G_OBJECT(item-&gt;browser), "status", &amp;status, NULL);
      switch(status)
      {
      case INF_BROWSER_CLOSED:
        item-&gt;status = INF_GTK_BROWSER_MODEL_DISCONNECTED;
        break;
      case INF_BROWSER_OPENING:
        item-&gt;status = INF_GTK_BROWSER_MODEL_CONNECTING;
        break;
      case INF_BROWSER_OPEN:
        item-&gt;status = INF_GTK_BROWSER_MODEL_CONNECTED;
        break;
      default:
        g_assert_not_reached();
        break;
      }
    }
    else
    {
      /* No browser available. Discovery needs to be set now, otherwise
       * we would have set the status to invalid above. */
      g_assert(item-&gt;info != NULL);
      item-&gt;status = INF_GTK_BROWSER_MODEL_DISCOVERED;
    }
  }
  else
  {
    /* Error needs to be set in error status */
    g_assert(item-&gt;error != NULL);
  }

  /* TODO: Emit row_inserted for the whole tree in browser, and
   * row-has-child-toggled where appropriate. */
  gtk_tree_model_row_changed(GTK_TREE_MODEL(model), path, tree_iter);

  if(item-&gt;browser != NULL &amp;&amp; item-&gt;status == INF_GTK_BROWSER_MODEL_CONNECTED)
  {
    inf_browser_get_root(item-&gt;browser, &amp;iter);
    if(inf_browser_get_explored(item-&gt;browser, &amp;iter) &amp;&amp;
       inf_browser_get_child(item-&gt;browser, &amp;iter))
    {
      gtk_tree_model_row_has_child_toggled(
        GTK_TREE_MODEL(model),
        path,
        tree_iter
      );
    }
  }
}

static void
inf_gtk_browser_store_browser_model_resolve(InfGtkBrowserModel* model,
                                            InfDiscovery* discovery,
                                            InfDiscoveryInfo* info)
{
  InfGtkBrowserStorePrivate* priv;
  InfGtkBrowserStoreItem* item;
  GtkTreeIter tree_iter;
  GtkTreePath* path;

  g_assert(INF_GTK_IS_BROWSER_STORE(model));

  priv = INF_GTK_BROWSER_STORE_PRIVATE(model);
  item = inf_gtk_browser_store_find_item_by_discovery_info(
    INF_GTK_BROWSER_STORE(model),
    info
  );

  g_assert(item != NULL);
  g_assert(
    item-&gt;status == INF_GTK_BROWSER_MODEL_DISCOVERED ||
    item-&gt;status == INF_GTK_BROWSER_MODEL_ERROR
  );

  if(item-&gt;status == INF_GTK_BROWSER_MODEL_ERROR)
  {
    g_assert(item-&gt;error != NULL);
    g_error_free(item-&gt;error);
    item-&gt;error = NULL;

    item-&gt;status = INF_GTK_BROWSER_MODEL_RESOLVING;
  }
  else
  {
    item-&gt;status = INF_GTK_BROWSER_MODEL_RESOLVING;
  }

  tree_iter.stamp = priv-&gt;stamp;
  tree_iter.user_data = item;
  tree_iter.user_data2 = GUINT_TO_POINTER(0);
  tree_iter.user_data3 = NULL;

  path = gtk_tree_model_get_path(GTK_TREE_MODEL(model), &amp;tree_iter);
  gtk_tree_model_row_changed(GTK_TREE_MODEL(model), path, &amp;tree_iter);
  gtk_tree_path_free(path);

  inf_discovery_resolve(
    discovery,
    info,
    inf_gtk_browser_store_resolv_complete_func,
    model
  );
}

static gboolean
inf_gtk_browser_store_browser_iter_to_tree_iter(InfGtkBrowserModel* model,
                                                InfBrowser* browser,
                                                const InfBrowserIter* iter,
                                                GtkTreeIter* tree_iter)
{
  InfGtkBrowserStorePrivate* priv;
  InfGtkBrowserStoreItem* item;

  g_assert(INF_GTK_IS_BROWSER_STORE(model));

  priv = INF_GTK_BROWSER_STORE_PRIVATE(model);
  item = inf_gtk_browser_store_find_item_by_browser(
    INF_GTK_BROWSER_STORE(model),
    browser
  );
  if(item == NULL || (iter != NULL &amp;&amp; item-&gt;missing == iter-&gt;node))
    return FALSE;

  tree_iter-&gt;stamp = priv-&gt;stamp;
  tree_iter-&gt;user_data = item;

  if(iter != NULL &amp;&amp; iter-&gt;node_id != 0)
  {
    tree_iter-&gt;user_data2 = GUINT_TO_POINTER(iter-&gt;node_id);
    tree_iter-&gt;user_data3 = iter-&gt;node;
  }
  else
  {
    /* Root node */
    tree_iter-&gt;user_data2 = 0;
    tree_iter-&gt;user_data3 = NULL;
  }

  return TRUE;
}

/*
 * GType registration
 */

static void
inf_gtk_browser_store_class_init(InfGtkBrowserStoreClass* browser_store_class)
{
  GObjectClass* object_class;
  object_class = G_OBJECT_CLASS(browser_store_class);

  object_class-&gt;dispose = inf_gtk_browser_store_dispose;
  object_class-&gt;set_property = inf_gtk_browser_store_set_property;
  object_class-&gt;get_property = inf_gtk_browser_store_get_property;

  g_object_class_install_property(
    object_class,
    PROP_IO,
    g_param_spec_object(
      "io",
      "IO",
      "The IO object used for the created browsers to schedule timeouts",
      INF_TYPE_IO,
      G_PARAM_READWRITE | G_PARAM_CONSTRUCT_ONLY
    )
  );

  g_object_class_install_property(
    object_class,
    PROP_COMMUNICATION_MANAGER,
    g_param_spec_object(
      "communication-manager",
      "Communication manager", 
      "The communication manager used for browsing remote directories",
      INF_COMMUNICATION_TYPE_MANAGER,
<a name="5"></a>      G_PARAM_READWRITE | G_PARAM_CONSTRUCT_ONLY
    )
  );
<font color="#151b8d"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>}

static void
inf_gtk_browser_store_tree_model_iface_init(GtkTreeModelIface* iface)
{
  iface-&gt;get_flags = inf_gtk_browser_store_tree_model_get_flags;
  iface-&gt;get_n_columns = inf_gtk_browser_store_tree_model_get_n_columns;
  iface-&gt;get_column_type = inf_gtk_browser_store_tree_model_get_column_type;
  iface-&gt;get_iter = inf_gtk_browser_store_tree_model_get_iter;
  iface-&gt;get_path = inf_gtk_browser_store_tree_model_get_path;
  iface-&gt;get_value = inf_gtk_browser_store_tree_model_get_value;
  iface-&gt;iter_next = inf_gtk_browser_store_tree_model_iter_next;
  iface-&gt;iter_children = inf_gtk_browser_store_tree_model_iter_children;
  iface-&gt;iter_has_child = inf_gtk_browser_store_tree_model_iter_has_child;
  iface-&gt;iter_n_children = inf_gtk_browser_store_tree_model_iter_n_children;</b></font>
  iface-&gt;iter_nth_child = inf_gtk_browser_store_tree_model_iter_nth_child;
  iface-&gt;iter_parent = inf_gtk_browser_store_tree_model_iter_parent;
}

static void
inf_gtk_browser_store_browser_model_iface_init(
  InfGtkBrowserModelInterface* iface)
{
  iface-&gt;set_browser = inf_gtk_browser_store_browser_model_set_browser;
  iface-&gt;resolve = inf_gtk_browser_store_browser_model_resolve;
  /* inf_gtk_browser_store_browser_model_browser_iter_to_tree_iter would be
   * consistent, but a _bit_ too long to fit properly into 80 chars ;) */
  iface-&gt;browser_iter_to_tree_iter =
    inf_gtk_browser_store_browser_iter_to_tree_iter;
}

/*
 * Public API.
 */

/**
 * inf_gtk_browser_store_new: (constructor)
 * @io: A #InfIo object for the created #InfcBrowser to schedule timeouts.
 * @comm_manager: The #InfCommunicationManager with which to explore
 * remote directories.
 *
 * Creates a new #InfGtkBrowserStore.
 *
 * Returns: (transfer full): A new #InfGtkBrowserStore.
 **/
InfGtkBrowserStore*
inf_gtk_browser_store_new(InfIo* io,
                          InfCommunicationManager* comm_manager)
{
  GObject* object;

  object = g_object_new(
    INF_GTK_TYPE_BROWSER_STORE,
    "io", io,
    "communication-manager", comm_manager,
    NULL
  );

  return INF_GTK_BROWSER_STORE(object);
}

/**
 * inf_gtk_browser_store_add_discovery:
 * @store: A #InfGtkBrowserStore.
 * @discovery: A #InfDiscovery not yet added to @model.
 *
 * Adds @discovery to @model. The model will then show up discovered
 * servers.
 **/
void
inf_gtk_browser_store_add_discovery(InfGtkBrowserStore* store,
                                    InfDiscovery* discovery)
{
  InfGtkBrowserStorePrivate* priv;
  GSList* discovered;
  GSList* item;
  InfDiscoveryInfo* info;

  g_return_if_fail(INF_GTK_IS_BROWSER_STORE(store));
  g_return_if_fail(INF_IS_DISCOVERY(discovery));

  priv = INF_GTK_BROWSER_STORE_PRIVATE(store);
  g_return_if_fail(g_slist_find(priv-&gt;discoveries, discovery) == NULL);

  g_object_ref(G_OBJECT(discovery));
  priv-&gt;discoveries = g_slist_prepend(priv-&gt;discoveries, discovery);

  g_signal_connect(
    G_OBJECT(discovery),
    "discovered",
    G_CALLBACK(inf_gtk_browser_store_discovered_cb),
    store
  );

  g_signal_connect(
    G_OBJECT(discovery),
    "undiscovered",
    G_CALLBACK(inf_gtk_browser_store_undiscovered_cb),
    store
  );

  discovered = inf_discovery_get_discovered(discovery, "_infinote._tcp");
  for(item = discovered; item != NULL; item = g_slist_next(item))
  {
    info = (InfDiscoveryInfo*)item-&gt;data;

    inf_gtk_browser_store_add_item_by_browser(
      store,
      discovery,
      info,
      NULL,
      inf_discovery_info_get_service_name(discovery, info)
    );
  }
  g_slist_free(discovered);

  inf_discovery_discover(discovery, "_infinote._tcp");
}

/**
 * inf_gtk_browser_store_add_connection:
 * @store: A #InfGtkBrowserStore.
 * @connection: A #InfXmlConnection.
 * @name: (allow-none): Name for the item, or %NULL.
 *
 * This function adds a connection to the @store. @store will show up
 * an item for the connection if there is not already one. This allows to
 * browse the explored parts of the directory of the remote site. If @name
 * is %NULL, then the #InfXmlConnection:remote-id of the connection will be
 * used.
 *
 * The return value is the #InfBrowser for the added connection, or an
 * existing browser for the connection, if there is any.
 *
 * Returns: (transfer none): An #InfBrowser for the new connection.
 **/
InfBrowser*
inf_gtk_browser_store_add_connection(InfGtkBrowserStore* store,
                                     InfXmlConnection* connection,
                                     const gchar* name)
{
  InfGtkBrowserStorePrivate* priv;
  InfGtkBrowserStoreItem* item;
  gchar* remote_id;

  g_return_val_if_fail(INF_GTK_IS_BROWSER_STORE(store), NULL);
  g_return_val_if_fail(INF_IS_XML_CONNECTION(connection), NULL);

  priv = INF_GTK_BROWSER_STORE_PRIVATE(store);
  item = inf_gtk_browser_store_find_item_by_connection(store, connection);

  if(item == NULL)
  {
    if(name == NULL)
    {
      g_object_get(G_OBJECT(connection), "remote-id", &amp;remote_id, NULL);

      item = inf_gtk_browser_store_add_item_by_connection(
        store,
        NULL,
        NULL,
        connection,
        remote_id
      );
    }
    else
    {
      item = inf_gtk_browser_store_add_item_by_connection(
        store,
        NULL,
        NULL,
        connection,
        g_strdup(name)
      );
    }
  }

  return item-&gt;browser;
}

/**
 * inf_gtk_browser_store_add_browser:
 * @store: A #InfGtkBrowserStore.
 * @browser: A #InfBrowser.
 * @name: Name for the item.
 *
 * This function adds a browser to the @store. @store will show up
 * an item for the browser if there is not already one. This allows to
 * browse the explored part of the browser. The @name parameter must not be
 * %NULL.
 **/
void
inf_gtk_browser_store_add_browser(InfGtkBrowserStore* store,
                                  InfBrowser* browser,
                                  const gchar* name)
{
  InfGtkBrowserStorePrivate* priv;
  InfGtkBrowserStoreItem* item;

  g_return_if_fail(INF_GTK_IS_BROWSER_STORE(store));
  g_return_if_fail(INF_IS_BROWSER(browser));
  g_return_if_fail(name != NULL);

  priv = INF_GTK_BROWSER_STORE_PRIVATE(store);
  item = inf_gtk_browser_store_find_item_by_browser(store, browser);

  if(item == NULL)
  {
    inf_gtk_browser_store_add_item_by_browser(
      store,
      NULL,
      NULL,
      browser,
      g_strdup(name)
    );
  }
}

/**
 * inf_gtk_browser_store_remove_browser:
 * @store: A #InfGtkBrowserStore
 * @browser: A #InfBrowser contained in @store.
 *
 * This function removes the entry for the given browser from @store.
 */
void
inf_gtk_browser_store_remove_browser(InfGtkBrowserStore* store,
                                     InfBrowser* browser)
{
  InfGtkBrowserStoreItem* item;

  g_return_if_fail(INF_GTK_IS_BROWSER_STORE(store));
  g_return_if_fail(INF_IS_BROWSER(browser));

  item = inf_gtk_browser_store_find_item_by_browser(store, browser);
  g_return_if_fail(item != NULL);

  inf_gtk_browser_store_remove_item (store, item);
}

/**
 * inf_gtk_browser_store_remove_connection:
 * @store: A #InfGtkBrowserStore.
 * @connection: A #InfXmlConnection contained in @store.
 *
 * This function removes the entry for the given connection from @store.
 */
void
inf_gtk_browser_store_remove_connection(InfGtkBrowserStore* store,
                                        InfXmlConnection* connection)
{
  InfGtkBrowserStoreItem* item;

  g_return_if_fail(INF_GTK_IS_BROWSER_STORE(store));
  g_return_if_fail(INF_IS_XML_CONNECTION(connection));

  item = inf_gtk_browser_store_find_item_by_connection(store, connection);
  g_return_if_fail(item != NULL);

  inf_gtk_browser_store_remove_item (store, item);
}

/**
 * inf_gtk_browser_store_clear_connection_error:
 * @store: A #InfGtkBrowserStore.
 * @connection: A #InfXmlConnection contained in @store.
 *
 * This function clears the error for the entry which belongs to the given
 * connection.
 */
void
inf_gtk_browser_store_clear_connection_error(InfGtkBrowserStore* store,
                                             InfXmlConnection* connection)
{
  InfGtkBrowserStoreItem* item;
  InfBrowserStatus status;
  GtkTreeIter iter;
  GtkTreePath* path;

  g_return_if_fail(INF_GTK_IS_BROWSER_STORE(store));
  g_return_if_fail(INF_IS_XML_CONNECTION(connection));

  item = inf_gtk_browser_store_find_item_by_connection(store, connection);
  g_return_if_fail(item != NULL);

  if(item-&gt;status == INF_GTK_BROWSER_MODEL_ERROR)
  {
    g_assert(item-&gt;error != NULL);

    g_error_free(item-&gt;error);
    item-&gt;error = NULL;

    if(item-&gt;browser != NULL)
    {
      g_object_get(G_OBJECT(item-&gt;browser), "status", &amp;status, NULL);
      switch(status)
      {
      case INF_BROWSER_CLOSED:
        item-&gt;status = INF_GTK_BROWSER_MODEL_DISCONNECTED;
        break;
      case INF_BROWSER_OPENING:
        item-&gt;status = INF_GTK_BROWSER_MODEL_CONNECTING;
        break;
      case INF_BROWSER_OPEN:
        item-&gt;status = INF_GTK_BROWSER_MODEL_CONNECTED;
        break;
      default:
        g_assert_not_reached();
        break;
      }
    }
    else if(item-&gt;info != NULL)
    {
      item-&gt;status = INF_GTK_BROWSER_MODEL_DISCOVERED;
    }
    else
    {
      g_assert_not_reached();
    }

    iter.stamp = INF_GTK_BROWSER_STORE_PRIVATE(store)-&gt;stamp;
    iter.user_data = item;
    iter.user_data2 = GUINT_TO_POINTER(0);
    iter.user_data3 = NULL;

    path = gtk_tree_model_get_path(GTK_TREE_MODEL(store), &amp;iter);
    gtk_tree_model_row_changed(GTK_TREE_MODEL(store), path, &amp;iter);
    gtk_tree_path_free (path);
  }
}

/**
 * inf_gtk_browser_store_set_connection_name:
 * @store: A #InfGtkBrowserStore.
 * @connection: A #InfXmlConnection contained in @store.
 * @name: The new name to set for the connection.
 *
 * This function sets the name of @connection.
 **/
void
inf_gtk_browser_store_set_connection_name(InfGtkBrowserStore* store,
                                          InfXmlConnection* connection,
                                          const gchar* name)
{
  InfGtkBrowserStoreItem* item;
  GtkTreeIter iter;
  GtkTreePath* path;

  g_return_if_fail(INF_GTK_IS_BROWSER_STORE(store));
  g_return_if_fail(INF_IS_XML_CONNECTION(connection));
  g_return_if_fail(name != NULL);

  item = inf_gtk_browser_store_find_item_by_connection(store, connection);
  g_return_if_fail(item != NULL);

  g_free (item-&gt;name);
  item-&gt;name = g_strdup(name);

  iter.stamp = INF_GTK_BROWSER_STORE_PRIVATE(store)-&gt;stamp;
  iter.user_data = item;
  iter.user_data2 = GUINT_TO_POINTER(0);
  iter.user_data3 = NULL;

  path = gtk_tree_model_get_path(GTK_TREE_MODEL(store), &amp;iter);
  gtk_tree_model_row_changed(GTK_TREE_MODEL(store), path, &amp;iter);
  gtk_tree_path_free(path);
}

/* vim:set et sw=2 ts=2: */
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
