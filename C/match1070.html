<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for inf-discovery-avahi.c &amp; inf-gtk-browser-store.c</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for inf-discovery-avahi.c &amp; inf-gtk-browser-store.c
      </h3>
<h1 align="center">
        10.0%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>inf-discovery-avahi.c (12.694878%)<th>inf-gtk-browser-store.c (8.321168%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(1212-1235)<td><a href="#" name="0">(1137-1162)</a><td align="center"><font color="#ff0000">17</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(1254-1279)<td><a href="#" name="1">(1163-1188)</a><td align="center"><font color="#e10000">15</font>
<tr onclick='openModal("#980517")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#980517"><font color="#980517">-</font><td><a href="#" name="2">(1120-1141)<td><a href="#" name="2">(1083-1097)</a><td align="center"><font color="#e10000">15</font>
<tr onclick='openModal("#53858b")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#53858b"><font color="#53858b">-</font><td><a href="#" name="3">(100-145)<td><a href="#" name="3">(66-95)</a><td align="center"><font color="#e10000">15</font>
<tr onclick='openModal("#6cc417")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#6cc417"><font color="#6cc417">-</font><td><a href="#" name="4">(1165-1177)<td><a href="#" name="4">(1122-1134)</a><td align="center"><font color="#d20000">14</font>
<tr onclick='openModal("#151b8d")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#151b8d"><font color="#151b8d">-</font><td><a href="#" name="5">(1094-1115)<td><a href="#" name="5">(2252-2266)</a><td align="center"><font color="#d20000">14</font>
<tr onclick='openModal("#8c8774")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#8c8774"><font color="#8c8774">-</font><td><a href="#" name="6">(925-945)<td><a href="#" name="6">(330-353)</a><td align="center"><font color="#b40000">12</font>
<tr onclick='openModal("#38a4a5")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#38a4a5"><font color="#38a4a5">-</font><td><a href="#" name="7">(775-801)<td><a href="#" name="7">(215-245)</a><td align="center"><font color="#b40000">12</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>inf-discovery-avahi.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 #include &lt;libinfinity/common/inf-discovery-avahi.h&gt;
2 #include &lt;libinfinity/common/inf-discovery.h&gt;
3 #include &lt;libinfinity/common/inf-local-publisher.h&gt;
4 #include &lt;libinfinity/inf-i18n.h&gt;
5 #include &lt;libinfinity/inf-config.h&gt; 
6 #ifdef LIBINFINITY_HAVE_AVAHI
7 #include &lt;avahi-client/client.h&gt;
8 #include &lt;avahi-client/lookup.h&gt;
9 #include &lt;avahi-client/publish.h&gt;
10 #include &lt;avahi-common/watch.h&gt;
11 #include &lt;avahi-common/malloc.h&gt;
12 #include &lt;avahi-common/timeval.h&gt;
13 #include &lt;avahi-common/alternative.h&gt;
14 #include &lt;avahi-common/error.h&gt;
15 #include &lt;sys/socket.h&gt; #include &lt;net/if.h&gt; #include &lt;string.h&gt;
16 struct AvahiWatch {
17   InfDiscoveryAvahi* avahi;
18   InfIoWatch* watch;
19   InfNativeSocket socket;
20   AvahiWatchEvent occurred_events;
21   AvahiWatchCallback callback;
22   void* userdata;
23 };
24 struct AvahiTimeout {
25   InfDiscoveryAvahi* avahi;
26   InfIoTimeout* timeout;
27   AvahiTimeoutCallback callback;
28   void* userdata;
29 };
30 typedef struct _InfDiscoveryAvahiInfoResolv InfDiscoveryAvahiInfoResolv;
31 struct _InfDiscoveryAvahiInfoResolv {
32   InfDiscoveryResolvCompleteFunc complete_func;
33   gpointer user_data;
34 };
35 struct _InfDiscoveryInfo {
36   gchar* service_name;
37   const gchar* service_type;
38   gchar* domain;
39   AvahiIfIndex interface;
40   AvahiProtocol protocol;
41   AvahiServiceResolver* service_resolver;
42   InfXmppConnection* resolved;
43   GSList* resolv;
44 };
45 struct _InfLocalPublisherItem {
46   gchar* type;
47   char* name;
48 <a name="3"></a>  guint port;
49   AvahiEntryGroup* entry_group;
50 <font color="#53858b"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>};
51 typedef struct _InfDiscoveryAvahiDiscoverInfo InfDiscoveryAvahiDiscoverInfo;
52 struct _InfDiscoveryAvahiDiscoverInfo {
53   gchar* type;   AvahiServiceBrowser* service_browser;
54   GSList* discovered;
55 };
56 typedef struct _InfDiscoveryAvahiPrivate InfDiscoveryAvahiPrivate;
57 struct _InfDiscoveryAvahiPrivate {
58   AvahiPoll poll;
59   InfIo* io;
60   InfXmppManager* xmpp_manager;
61   InfXmppConnectionSecurityPolicy security_policy;
62   InfKeepalive keepalive;
63   InfCertificateCredentials* creds;
64   InfSaslContext* sasl_context;
65   gchar* sasl_mechanisms;
66   AvahiClient* client;
67   GSList* published;
68   GHashTable* discovered; };
69 enum {
70   PROP_0,
71   PROP_XMPP_MANAGER,
72   PROP_IO,
73   PROP_CREDENTIALS,
74   PROP_SASL_CONTEXT,
75   PROP_SASL_MECHANISMS,
76   PROP_SECURITY_POLICY,
77   PROP_KEEPALIVE
78 };
79 #define INF_DISCOVERY_AVAHI_PRIVATE(obj) (G_TYPE_INSTANCE_GET_PRIVATE((obj), INF_TYPE_DISCOVERY_AVAHI, InfDiscoveryAvahiPrivate))
80 static GQuark inf_discovery_avahi_error_quark;</b></font>
81 static void inf_discovery_avahi_discovery_iface_init(InfDiscoveryInterface* iface);
82 static void inf_discovery_avahi_local_publisher_iface_init(InfLocalPublisherInterface* iface);
83 G_DEFINE_TYPE_WITH_CODE(InfDiscoveryAvahi, inf_discovery_avahi, G_TYPE_OBJECT,
84   G_ADD_PRIVATE(InfDiscoveryAvahi)
85   G_IMPLEMENT_INTERFACE(INF_TYPE_DISCOVERY, inf_discovery_avahi_discovery_iface_init)
86   G_IMPLEMENT_INTERFACE(INF_TYPE_LOCAL_PUBLISHER, inf_discovery_avahi_local_publisher_iface_init))
87 static void
88 inf_discovery_avahi_discovery_info_resolved_destroy_cb(gpointer user_data,
89                                                        GObject* object)
90 {
91   InfDiscoveryInfo* info;
92   info = (InfDiscoveryInfo*)user_data;
93   info-&gt;resolved = NULL;
94 }
95 static void
96 inf_discovery_avahi_info_resolv_complete(InfDiscoveryInfo* info)
97 {
98   GSList* item;
99   InfDiscoveryAvahiInfoResolv* resolv;
100   g_assert(info-&gt;resolved != NULL);
101   for(item = info-&gt;resolv; item != NULL; item = g_slist_next(item))
102   {
103     resolv = (InfDiscoveryAvahiInfoResolv*)item-&gt;data;
104     resolv-&gt;complete_func(
105       info,
106       INF_XML_CONNECTION(info-&gt;resolved),
107       NULL,
108       resolv-&gt;user_data
109     );
110     g_slice_free(InfDiscoveryAvahiInfoResolv, resolv);
111   }
112   g_slist_free(info-&gt;resolv);
113   info-&gt;resolv = NULL;
114 }
115 static void
116 inf_discovery_avahi_info_resolv_error(InfDiscoveryInfo* info,
117                                       const GError* error)
118 {
119   GSList* item;
120   InfDiscoveryAvahiInfoResolv* resolv;
121   for(item = info-&gt;resolv; item != NULL; item = g_slist_next(item))
122   {
123     resolv = (InfDiscoveryAvahiInfoResolv*)item-&gt;data;
124     resolv-&gt;complete_func(info, NULL, error, resolv-&gt;user_data);
125     g_slice_free(InfDiscoveryAvahiInfoResolv, resolv);
126   }
127   g_slist_free(info-&gt;resolv);
128   info-&gt;resolv = NULL;
129 }
130 static void
131 inf_discovery_avahi_discovery_info_free(InfDiscoveryInfo* info)
132 {
133   g_free(info-&gt;service_name);
134   g_free(info-&gt;domain);
135   if(info-&gt;service_resolver != NULL)
136     avahi_service_resolver_free(info-&gt;service_resolver);
137   if(info-&gt;resolved != NULL)
138   {
139     g_object_weak_unref(
140       G_OBJECT(info-&gt;resolved),
141       inf_discovery_avahi_discovery_info_resolved_destroy_cb,
142       info
143     );
144   }
145   inf_discovery_avahi_info_resolv_error(info, NULL);
146   g_slist_free(info-&gt;resolv);
147   g_slice_free(InfDiscoveryInfo, info);
148 }
149 static void
150 inf_discovery_avahi_publisher_item_free(gpointer data)
151 {
152   InfLocalPublisherItem* item;
153   item = (InfLocalPublisherItem*)data;
154   if(item-&gt;entry_group != NULL)
155     avahi_entry_group_free(item-&gt;entry_group);
156   g_free(item-&gt;type);
157   avahi_free(item-&gt;name);
158   g_slice_free(InfLocalPublisherItem, item);
159 }
160 static void
161 inf_discovery_avahi_discover_info_free(gpointer data)
162 {
163   InfDiscoveryAvahiDiscoverInfo* info;
164   GSList* item;
165   info = (InfDiscoveryAvahiDiscoverInfo*)data;
166   for(item = info-&gt;discovered; item != NULL; item = g_slist_next(item))
167     inf_discovery_avahi_discovery_info_free((InfDiscoveryInfo*)item-&gt;data);
168   if(info-&gt;service_browser != NULL)
169     avahi_service_browser_free(info-&gt;service_browser);
170   g_slist_free(info-&gt;discovered);
171   g_free(info-&gt;type);
172   g_slice_free(InfDiscoveryAvahiDiscoverInfo, info);
173 }
174 static void
175 inf_discovery_avahi_service_resolver_callback(AvahiServiceResolver* resolver,
176                                               AvahiIfIndex interface,
177                                               AvahiProtocol protocol,
178                                               AvahiResolverEvent event,
179                                               const char* name,
180                                               const char* type,
181                                               const char* domain,
182                                               const char* host_name,
183                                               const AvahiAddress* address,
184                                               uint16_t port,
185                                               AvahiStringList* txt,
186                                               AvahiLookupResultFlags flags,
187                                               void* userdata)
188 {
189   InfDiscoveryAvahi* avahi;
190   InfDiscoveryAvahiPrivate* priv;
191   InfDiscoveryAvahiDiscoverInfo* info;
192   InfDiscoveryInfo* discovery_info;
193   GSList* item;
194   InfIpAddress* inf_addr;
195   InfTcpConnection* tcp;
196   InfXmppConnection* xmpp;
197   InfXmlConnectionStatus status;
198   GError* error;
199   avahi = INF_DISCOVERY_AVAHI(userdata);
200   priv = INF_DISCOVERY_AVAHI_PRIVATE(avahi);
201   info = g_hash_table_lookup(priv-&gt;discovered, type);
202   g_assert(info != NULL);
203   for(item = info-&gt;discovered; item != NULL; item = g_slist_next(item))
204   {
205     discovery_info = (InfDiscoveryInfo*)item-&gt;data;
206     if(discovery_info-&gt;service_resolver == resolver)
207       break;
208   }
209   g_assert(item != NULL);
210   g_assert(discovery_info-&gt;resolved == NULL);
211   discovery_info-&gt;service_resolver = NULL;
212   switch(event)
213   {
214   case AVAHI_RESOLVER_FOUND:
215     switch(address-&gt;proto)
216     {
217     case AVAHI_PROTO_INET:
218       inf_addr = inf_ip_address_new_raw4(address-&gt;data.ipv4.address);
219       break;
220     case AVAHI_PROTO_INET6:
221       inf_addr = inf_ip_address_new_raw6(address-&gt;data.ipv6.address);
222       break;
223     default:
224       g_assert_not_reached();
225       break;
226     }
227     xmpp = inf_xmpp_manager_lookup_connection_by_address(
228       priv-&gt;xmpp_manager,
229       inf_addr,
230       port
231     );
232     if(xmpp == NULL)
233     {
234       tcp = inf_tcp_connection_new(priv-&gt;io, inf_addr, port);
235       g_object_set(
236         G_OBJECT(tcp),
237         "device-index", discovery_info-&gt;interface,
238         NULL
239       );
240       error = NULL;
241       if(!inf_tcp_connection_set_keepalive(tcp, &amp;priv-&gt;keepalive, &amp;error) ||
242          !inf_tcp_connection_open(tcp, &amp;error))
243       {
244         inf_discovery_avahi_info_resolv_error(discovery_info, error);
245         g_error_free(error);
246         g_object_unref(tcp);
247       }
248       else
249       {
250         xmpp = inf_xmpp_connection_new(
251           tcp,
252           INF_XMPP_CONNECTION_CLIENT,
253           NULL,
254           host_name,
255           priv-&gt;security_policy,
256           priv-&gt;creds,
257           priv-&gt;sasl_context,
258           priv-&gt;sasl_context == NULL ? NULL : priv-&gt;sasl_mechanisms
259         );
260         g_object_unref(tcp);
261         inf_xmpp_manager_add_connection(priv-&gt;xmpp_manager, xmpp);
262         discovery_info-&gt;resolved = xmpp;
263         g_object_weak_ref(
264           G_OBJECT(xmpp),
265           inf_discovery_avahi_discovery_info_resolved_destroy_cb,
266           discovery_info
267         );
268         inf_discovery_avahi_info_resolv_complete(discovery_info);
269         g_object_unref(xmpp);
270       }
271     }
272     else
273     {
274       discovery_info-&gt;resolved = xmpp;
275       g_object_weak_ref(
276         G_OBJECT(xmpp),
277         inf_discovery_avahi_discovery_info_resolved_destroy_cb,
278         discovery_info
279       );
280       g_object_get(G_OBJECT(xmpp), "status", &amp;status, NULL);
281       if(status == INF_XML_CONNECTION_CLOSING)
282       {
283         inf_discovery_avahi_info_resolv_error(discovery_info, NULL);
284       }
285       else if(status == INF_XML_CONNECTION_CLOSED)
286       {
287         error = NULL;
288         if(!inf_xml_connection_open(INF_XML_CONNECTION(xmpp), &amp;error))
289         {
290           inf_discovery_avahi_info_resolv_error(discovery_info, error);
291           g_error_free(error);
292         }
293         else
294         {
295           inf_discovery_avahi_info_resolv_complete(discovery_info);
296         }
297       }
298       else
299       {
300         inf_discovery_avahi_info_resolv_complete(discovery_info);
301       }
302     }
303     inf_ip_address_free(inf_addr);
304     break;
305   case AVAHI_RESOLVER_FAILURE:
306     error = NULL;
307     g_set_error_literal(
308       &amp;error,
309       inf_discovery_avahi_error_quark,
310       avahi_client_errno(avahi_service_resolver_get_client(resolver)),
311       avahi_strerror(
312         avahi_client_errno(avahi_service_resolver_get_client(resolver))
313       )
314     );
315     inf_discovery_avahi_info_resolv_error(discovery_info, error);
316     g_error_free(error);
317     break;
318   }
319   avahi_service_resolver_free(resolver);
320 }
321 static void
322 inf_discovery_avahi_perform_undiscover(InfDiscoveryAvahi* avahi,
323                                        InfDiscoveryAvahiDiscoverInfo* info);
324 static void
325 inf_discovery_avahi_perform_unpublish_item(InfLocalPublisherItem* item);
326 static void
327 inf_discovery_avahi_service_browser_callback(AvahiServiceBrowser* browser,
328                                              AvahiIfIndex interface,
329                                              AvahiProtocol protocol,
330                                              AvahiBrowserEvent event,
331                                              const char* name,
332                                              const char* type,
333                                              const char* domain,
334                                              AvahiLookupResultFlags flags,
335                                              void* userdata)
336 {
337   InfDiscoveryAvahi* avahi;
338   InfDiscoveryAvahiPrivate* priv;
339   InfDiscoveryAvahiDiscoverInfo* info;
340   InfDiscoveryInfo* discovery_info;
341   GSList* item;
342   avahi = INF_DISCOVERY_AVAHI(userdata);
343   priv = INF_DISCOVERY_AVAHI_PRIVATE(avahi);
344   info = g_hash_table_lookup(priv-&gt;discovered, type);
345   g_assert(info != NULL);
346   switch(event)
347   {
348   case AVAHI_BROWSER_NEW:
349     if((flags &amp; AVAHI_LOOKUP_RESULT_OUR_OWN) == 0)
350     {
351       discovery_info = g_slice_new(InfDiscoveryInfo);
352       discovery_info-&gt;service_name = g_strdup(name);
353       discovery_info-&gt;service_type = info-&gt;type;
354       discovery_info-&gt;domain = g_strdup(domain);
355       discovery_info-&gt;interface = interface;
356       discovery_info-&gt;protocol = protocol;
357       discovery_info-&gt;service_resolver = NULL;
358       discovery_info-&gt;resolved = NULL;
359       discovery_info-&gt;resolv = NULL;
360       info-&gt;discovered = g_slist_prepend(info-&gt;discovered, discovery_info);
361       inf_discovery_discovered(INF_DISCOVERY(avahi), discovery_info);
362     }
363     break;
364   case AVAHI_BROWSER_REMOVE:
365     for(item = info-&gt;discovered; item != NULL; item = g_slist_next(item))
366     {
367       discovery_info = (InfDiscoveryInfo*)item-&gt;data;
368       g_assert(strcmp(discovery_info-&gt;service_type, type) == 0);
369       if(strcmp(discovery_info-&gt;service_name, name) == 0 &amp;&amp;
370          discovery_info-&gt;interface == interface &amp;&amp;
371          discovery_info-&gt;protocol == protocol)
372       {
373         inf_discovery_undiscovered(INF_DISCOVERY(avahi), discovery_info);
374         info-&gt;discovered = g_slist_remove(info-&gt;discovered, discovery_info);
375         inf_discovery_avahi_discovery_info_free(discovery_info);
376         break;
377       }
378     }
379     break;
380   case AVAHI_BROWSER_CACHE_EXHAUSTED:
381     break;
382   case AVAHI_BROWSER_ALL_FOR_NOW:
383     break;
384   case AVAHI_BROWSER_FAILURE:
385     g_warning(
386       _("Avahi service browser is in failure state. Services of type '%s' "
387         "are no longer discovered.\n\nThe failure was: %s\n"),
388       info-&gt;type,
389       avahi_strerror(
390         avahi_client_errno(avahi_service_browser_get_client(browser))
391       )
392     );
393     inf_discovery_avahi_perform_undiscover(avahi, info);
394     break;
395   default:
396     g_assert_not_reached();
397     break;
398   }
399 }
400 static void
401 inf_discovery_avahi_entry_group_add_service(InfLocalPublisherItem* item)
402 {
403   char* new_name;
404   int res;
405   do
406   {
407     res = avahi_entry_group_add_service(
408       item-&gt;entry_group,
409       AVAHI_IF_UNSPEC,
410       AVAHI_PROTO_UNSPEC,
411       0,
412       item-&gt;name,
413       item-&gt;type,
414       NULL,
415       NULL,
416       item-&gt;port,
417       NULL
418     );
419     if(res != AVAHI_ERR_COLLISION) break;
420     new_name = avahi_alternative_service_name(item-&gt;name);
421     avahi_free(item-&gt;name);
422     item-&gt;name = new_name;
423   } while(1);
424   if(res != 0)
425   {
426     g_warning(
427       "Failed to publish service \"%s\" via avahi: %s",
428       item-&gt;name,
429       avahi_strerror(res)
430     );
431   }
432 }
433 static void
434 inf_discovery_avahi_entry_group_callback(AvahiEntryGroup* group,
435                                          AvahiEntryGroupState state,
436                                          void* userdata)
437 {
438   InfLocalPublisherItem* item;
439   char* new_name;
440   item = (InfLocalPublisherItem*)userdata;
441   switch(state)
442   {
443   case AVAHI_ENTRY_GROUP_UNCOMMITED:
444     break;
445   case AVAHI_ENTRY_GROUP_REGISTERING:
446     break;
447   case AVAHI_ENTRY_GROUP_ESTABLISHED:
448     break;
449   case AVAHI_ENTRY_GROUP_COLLISION:
450     new_name = avahi_alternative_service_name(item-&gt;name);
451     avahi_free(item-&gt;name);
452     item-&gt;name = new_name;
453     avahi_entry_group_reset(item-&gt;entry_group);
454     inf_discovery_avahi_entry_group_add_service(item);
455     avahi_entry_group_commit(item-&gt;entry_group);
456     break;
457   case AVAHI_ENTRY_GROUP_FAILURE:
458     g_warning(
459       _("Avahi entry group is in failure state. The service '%s' of type "
460         "'%s' is no longer published.\n\nThe failure was: %s\n"),
461       item-&gt;name,
462       item-&gt;type,
463       avahi_strerror(avahi_client_errno(avahi_entry_group_get_client(group)))
464     );
465     inf_discovery_avahi_perform_unpublish_item(item);
466     break;
467   default:
468     g_assert_not_reached();
469     break;
470   }
471 }
472 static void
473 inf_discovery_avahi_perform_publish_item(InfDiscoveryAvahi* avahi,
474                                          InfLocalPublisherItem* item)
475 {
476   InfDiscoveryAvahiPrivate* priv;
477   priv = INF_DISCOVERY_AVAHI_PRIVATE(avahi);
478   if(item-&gt;entry_group == NULL)
479   {
480     item-&gt;entry_group = avahi_entry_group_new(
481       priv-&gt;client,
482       inf_discovery_avahi_entry_group_callback,
483       item
484     );
485     inf_discovery_avahi_entry_group_add_service(item);
486     avahi_entry_group_commit(item-&gt;entry_group);
487   }
488 }
489 static void
490 inf_discovery_avahi_perform_unpublish_item(InfLocalPublisherItem* item)
491 {
492   if(item-&gt;entry_group != NULL)
493   {
494     avahi_entry_group_free(item-&gt;entry_group);
495     item-&gt;entry_group = NULL;
496   }
497 }
498 static void
499 inf_discovery_avahi_perform_publish_all(InfDiscoveryAvahi* avahi)
500 {
501   InfDiscoveryAvahiPrivate* priv;
502   GSList* item;
503   priv = INF_DISCOVERY_AVAHI_PRIVATE(avahi);
504   for(item = priv-&gt;published; item != NULL; item = g_slist_next(item))
505   {
506     inf_discovery_avahi_perform_publish_item(
507       avahi,
508       (InfLocalPublisherItem*)item-&gt;data
509     );
510   }
511 }
512 static void
513 inf_discovery_avahi_perform_unpublish_all(InfDiscoveryAvahi* avahi)
514 {
515   InfDiscoveryAvahiPrivate* priv;
516   GSList* item;
517   priv = INF_DISCOVERY_AVAHI_PRIVATE(avahi);
518   for(item = priv-&gt;published; item != NULL; item = g_slist_next(item))
519   {
520     inf_discovery_avahi_perform_unpublish_item(
521       (InfLocalPublisherItem*)item-&gt;data
522     );
523   }
524 }
525 static void
526 inf_discovery_avahi_perform_discover(InfDiscoveryAvahi* avahi,
527                                      InfDiscoveryAvahiDiscoverInfo* info)
528 {
529   InfDiscoveryAvahiPrivate* priv;
530   priv = INF_DISCOVERY_AVAHI_PRIVATE(avahi);
531   if(info-&gt;service_browser == NULL)
532   {
533     info-&gt;service_browser = avahi_service_browser_new(
534       priv-&gt;client,
535       AVAHI_IF_UNSPEC,
536       AVAHI_PROTO_UNSPEC,
537       info-&gt;type,
538       NULL,
539       0,
540       inf_discovery_avahi_service_browser_callback,
541       avahi
542     );
543   }
544 }
545 static void
546 inf_discovery_avahi_perform_undiscover(InfDiscoveryAvahi* avahi,
547                                        InfDiscoveryAvahiDiscoverInfo* info)
548 {
549   InfDiscoveryInfo* discovery_info;
550   GSList* next;
551   for(; info-&gt;discovered != NULL; info-&gt;discovered = next)
552   {
553     next = info-&gt;discovered-&gt;next;
554     discovery_info = (InfDiscoveryInfo*)info-&gt;discovered-&gt;data;
555     inf_discovery_undiscovered(INF_DISCOVERY(avahi), discovery_info);
556     inf_discovery_avahi_discovery_info_free(discovery_info);
557     info-&gt;discovered = g_slist_delete_link(
558       info-&gt;discovered,
559       info-&gt;discovered
560     );
561   }
562   if(info-&gt;service_browser != NULL)
563   {
564     avahi_service_browser_free(info-&gt;service_browser);
565     info-&gt;service_browser = NULL;
566   }
567 }
568 static void
569 inf_discovery_avahi_perform_discover_all_foreach_func(gpointer key,
570                                                       gpointer value,
571                                                       gpointer user_data)
572 {
573   inf_discovery_avahi_perform_discover(
574     INF_DISCOVERY_AVAHI(user_data),
575     (InfDiscoveryAvahiDiscoverInfo*)value
576 <a name="7"></a>  );
577 }
578 <font color="#38a4a5"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>static void
579 inf_discovery_avahi_perform_undiscover_all_foreach_func(gpointer key,
580                                                         gpointer value,
581                                                         gpointer user_data)
582 {
583   inf_discovery_avahi_perform_undiscover(
584     INF_DISCOVERY_AVAHI(user_data),
585     (InfDiscoveryAvahiDiscoverInfo*)value
586   );
587 }
588 static void
589 inf_discovery_avahi_perform_discover_all(InfDiscoveryAvahi* avahi)
590 {
591   InfDiscoveryAvahiPrivate* priv;
592   priv = INF_DISCOVERY_AVAHI_PRIVATE(avahi);
593   g_hash_table_foreach(
594     priv-&gt;discovered,
595     inf_discovery_avahi_perform_discover_all_foreach_func,
596     avahi
597   );
598 }
599 static void
600 inf_discovery_avahi_perform_undiscover_all(InfDiscoveryAvahi* avahi)
601 {</b></font>
602   InfDiscoveryAvahiPrivate* priv;
603   priv = INF_DISCOVERY_AVAHI_PRIVATE(avahi);
604   g_hash_table_foreach(
605     priv-&gt;discovered,
606     inf_discovery_avahi_perform_undiscover_all_foreach_func,
607     avahi
608   );
609 }
610 static void
611 inf_discovery_avahi_client_callback(AvahiClient* client,
612                                     AvahiClientState state,
613                                     void* userdata);
614 static void
615 inf_discovery_avahi_create_client(InfDiscoveryAvahi* discovery)
616 {
617   InfDiscoveryAvahiPrivate* priv;
618   int error;
619   priv = INF_DISCOVERY_AVAHI_PRIVATE(discovery);
620   priv-&gt;client = avahi_client_new(
621     &amp;priv-&gt;poll,
622     AVAHI_CLIENT_NO_FAIL,
623     inf_discovery_avahi_client_callback,
624     discovery,
625     &amp;error
626   );
627   if(priv-&gt;client == NULL)
628   {
629     g_warning(_
630       ("Failed to start Avahi client. Service discovery or publishing "
631        "will not be possible.\n\nThe occurred failure was: %s"),
632       avahi_strerror(error)
633     );
634   }
635 }
636 static void
637 inf_discovery_avahi_client_callback(AvahiClient* client,
638                                     AvahiClientState state,
639                                     void* userdata)
640 {
641   InfDiscoveryAvahi* avahi;
642   InfDiscoveryAvahiPrivate* priv;
643   avahi = INF_DISCOVERY_AVAHI(userdata);
644   priv = INF_DISCOVERY_AVAHI_PRIVATE(avahi);
645   switch(state)
646   {
647   case AVAHI_CLIENT_S_COLLISION:
648     break;
649   case AVAHI_CLIENT_S_REGISTERING:
650     break;
651   case AVAHI_CLIENT_S_RUNNING:
652     inf_discovery_avahi_perform_publish_all(avahi);
653     inf_discovery_avahi_perform_discover_all(avahi);
654     break;
655   case AVAHI_CLIENT_FAILURE:
656     inf_discovery_avahi_perform_unpublish_all(avahi);
657     inf_discovery_avahi_perform_undiscover_all(avahi);
658     if(avahi_client_errno(client) != AVAHI_ERR_DISCONNECTED)
659     {
660       inf_discovery_avahi_create_client(avahi);
661     }
662     else
663     {
664       g_warning(
665         _("Avahi client is in failure state. Service discovery or "
666           "publishing is no longer possible.\n\nThe occurred failure "
667           "was: %s\n"),
668         avahi_strerror(avahi_client_errno(client))
669       );
670     }
671   case AVAHI_CLIENT_CONNECTING:
672     break;
673   default:
674     g_assert_not_reached();
675     break;
676   }
677 }
678 static AvahiWatchEvent
679 inf_discovery_avahi_from_io_event(InfIoEvent event)
680 {
681   AvahiWatchEvent res;
682   res = 0;
683   if(event &amp; INF_IO_INCOMING) res |= AVAHI_WATCH_IN;
684   if(event &amp; INF_IO_OUTGOING) res |= AVAHI_WATCH_OUT;
685   if(event &amp; INF_IO_ERROR) res |= AVAHI_WATCH_ERR;
686   return res;
687 }
688 static InfIoEvent
689 inf_discovery_avahi_to_io_event(AvahiWatchEvent event)
690 {
691   InfIoEvent res;
692   res = 0;
693   if(event &amp; AVAHI_WATCH_IN) res |= INF_IO_INCOMING;
694   if(event &amp; AVAHI_WATCH_OUT) res |= INF_IO_OUTGOING;
695 <a name="6"></a>  if(event &amp; (AVAHI_WATCH_ERR | AVAHI_WATCH_HUP)) res |= INF_IO_ERROR;
696   return res;
697 <font color="#8c8774"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>}
698 static void
699 inf_discovery_avahi_watch_cb(InfNativeSocket* socket,
700                              InfIoEvent event,
701                              gpointer user_data)
702 {
703   AvahiWatch* watch;
704   watch = (AvahiWatch*)user_data;
705   watch-&gt;occurred_events = inf_discovery_avahi_from_io_event(event);
706   watch-&gt;callback(watch, *socket, watch-&gt;occurred_events, watch-&gt;userdata);
707 }
708 static void
709 inf_discovery_avahi_timeout_cb(gpointer user_data)
710 {
711   AvahiTimeout* timeout;
712   timeout = (AvahiTimeout*)user_data;
713   timeout-&gt;timeout = NULL;</b></font>
714   timeout-&gt;callback(timeout, timeout-&gt;userdata);
715 }
716 static AvahiWatch*
717 inf_discovery_avahi_watch_new(const AvahiPoll* api,
718                               int fd,
719                               AvahiWatchEvent event,
720                               AvahiWatchCallback callback,
721                               void* userdata)
722 {
723   InfDiscoveryAvahi* avahi;
724   InfDiscoveryAvahiPrivate* priv;
725   AvahiWatch* watch;
726   avahi = INF_DISCOVERY_AVAHI(api-&gt;userdata);
727   priv = INF_DISCOVERY_AVAHI_PRIVATE(avahi);
728   watch = g_slice_new(AvahiWatch);
729   watch-&gt;avahi = avahi;
730   watch-&gt;socket = fd;
731   watch-&gt;occurred_events = 0;
732   watch-&gt;callback = callback;
733   watch-&gt;userdata = userdata;
734   watch-&gt;watch = inf_io_add_watch(
735     priv-&gt;io,
736     &amp;watch-&gt;socket,
737     inf_discovery_avahi_to_io_event(event),
738     inf_discovery_avahi_watch_cb,
739     watch,
740     NULL
741   );
742   return watch;
743 }
744 static void
745 inf_discovery_avahi_watch_update(AvahiWatch* watch,
746                                  AvahiWatchEvent event)
747 {
748   InfDiscoveryAvahiPrivate* priv;
749   priv = INF_DISCOVERY_AVAHI_PRIVATE(watch-&gt;avahi);
750   inf_io_update_watch(
751     priv-&gt;io,
752     watch-&gt;watch,
753     inf_discovery_avahi_to_io_event(event)
754   );
755 }
756 static AvahiWatchEvent
757 inf_discovery_avahi_watch_get_events(AvahiWatch* watch)
758 {
759   return watch-&gt;occurred_events;
760 }
761 static void
762 inf_discovery_avahi_watch_free(AvahiWatch* watch)
763 {
764   InfDiscoveryAvahiPrivate* priv;
765   priv = INF_DISCOVERY_AVAHI_PRIVATE(watch-&gt;avahi);
766   inf_io_remove_watch(priv-&gt;io, watch-&gt;watch);
767   g_slice_free(AvahiWatch, watch);
768 }
769 static AvahiTimeout*
770 inf_discovery_avahi_timeout_new(const AvahiPoll* api,
771                                 const struct timeval* tv,
772                                 AvahiTimeoutCallback callback,
773                                 void* userdata)
774 {
775   InfDiscoveryAvahi* avahi;
776   InfDiscoveryAvahiPrivate* priv;
777   AvahiTimeout* timeout;
778   AvahiUsec usec;
779   avahi = INF_DISCOVERY_AVAHI(api-&gt;userdata);
780   priv = INF_DISCOVERY_AVAHI_PRIVATE(avahi);
781   timeout = g_slice_new(AvahiTimeout);
782   timeout-&gt;avahi = avahi;
783   timeout-&gt;callback = callback;
784   timeout-&gt;userdata = userdata;
785   if(tv != NULL)
786   {
787     usec = avahi_age(tv);
788     if(usec &gt; 0) usec = 0;
789     timeout-&gt;timeout = inf_io_add_timeout(
790       priv-&gt;io,
791       ((-usec) + 500) / 1000,
792       inf_discovery_avahi_timeout_cb,
793       timeout,
794       NULL
795     );
796   }
797   else
798   {
799     timeout-&gt;timeout = NULL;
800   }
801   return timeout;
802 }
803 static void
804 inf_discovery_avahi_timeout_update(AvahiTimeout* timeout,
805                                    const struct timeval* tv)
806 {
807   InfDiscoveryAvahiPrivate* priv;
808   AvahiUsec usec;
809   priv = INF_DISCOVERY_AVAHI_PRIVATE(timeout-&gt;avahi);
810   if(timeout-&gt;timeout != NULL)
811     inf_io_remove_timeout(priv-&gt;io, timeout-&gt;timeout);
812   if(tv != NULL)
813   {
814     usec = avahi_age(tv);
815     if(usec &gt; 0) usec = 0;
816     timeout-&gt;timeout = inf_io_add_timeout(
817       priv-&gt;io,
818       ((-usec) + 500) / 1000,
819       inf_discovery_avahi_timeout_cb,
820       timeout,
821       NULL
822     );
823   }
824   else
825   {
826     timeout-&gt;timeout = NULL;
827   }
828 }
829 static void
830 inf_discovery_avahi_timeout_free(AvahiTimeout* timeout)
831 {
832   InfDiscoveryAvahiPrivate* priv;
833   priv = INF_DISCOVERY_AVAHI_PRIVATE(timeout-&gt;avahi);
834   if(timeout-&gt;timeout != NULL)
835 <a name="5"></a>    inf_io_remove_timeout(priv-&gt;io, timeout-&gt;timeout);
836   g_slice_free(AvahiTimeout, timeout);
837 <font color="#151b8d"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>}
838 static void
839 inf_discovery_avahi_init(InfDiscoveryAvahi* avahi)
840 {
841   InfDiscoveryAvahiPrivate* priv;
842   priv = INF_DISCOVERY_AVAHI_PRIVATE(avahi);
843   priv-&gt;poll.userdata = avahi;
844   priv-&gt;poll.watch_new = inf_discovery_avahi_watch_new;
845   priv-&gt;poll.watch_update = inf_discovery_avahi_watch_update;
846   priv-&gt;poll.watch_get_events = inf_discovery_avahi_watch_get_events;
847   priv-&gt;poll.watch_free = inf_discovery_avahi_watch_free;
848   priv-&gt;poll.timeout_new = inf_discovery_avahi_timeout_new;
849   priv-&gt;poll.timeout_update = inf_discovery_avahi_timeout_update;
850   priv-&gt;poll.timeout_free = inf_discovery_avahi_timeout_free;
851   priv-&gt;io = NULL;</b></font>
852   priv-&gt;xmpp_manager = NULL;
853 <a name="2"></a>  priv-&gt;security_policy = INF_XMPP_CONNECTION_SECURITY_BOTH_PREFER_TLS;
854   priv-&gt;keepalive.mask = 0;
855   priv-&gt;creds = NULL;
856 <font color="#980517"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>  priv-&gt;sasl_context = NULL;
857   priv-&gt;sasl_mechanisms = NULL;
858   priv-&gt;client = NULL;
859   priv-&gt;published = NULL;
860   priv-&gt;discovered = g_hash_table_new_full(
861     g_str_hash,
862     g_str_equal,
863     NULL,     inf_discovery_avahi_discover_info_free
864   );
865 }
866 static void
867 inf_discovery_avahi_constructed(GObject* object)
868 {
869   InfDiscoveryAvahiPrivate* priv;
870   G_OBJECT_CLASS(inf_discovery_avahi_parent_class)-&gt;constructed(object);
871   priv = INF_DISCOVERY_AVAHI_PRIVATE(object);</b></font>
872   g_assert(priv-&gt;io != NULL);
873   inf_discovery_avahi_create_client(INF_DISCOVERY_AVAHI(object));
874 }
875 static void
876 inf_discovery_avahi_dispose(GObject* object)
877 {
878   InfDiscoveryAvahi* avahi;
879   InfDiscoveryAvahiPrivate* priv;
880   GSList* item;
881   avahi = INF_DISCOVERY_AVAHI(object);
882   priv = INF_DISCOVERY_AVAHI_PRIVATE(avahi);
883   g_hash_table_destroy(priv-&gt;discovered);
884   priv-&gt;discovered = NULL;
885 <a name="4"></a>  for(item = priv-&gt;published; item != NULL; item = g_slist_next(item))
886     inf_discovery_avahi_publisher_item_free(item-&gt;data);
887   g_slist_free(priv-&gt;published);
888 <font color="#6cc417"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>  priv-&gt;published = NULL;
889   if(priv-&gt;client != NULL)
890   {
891     avahi_client_free(priv-&gt;client);
892     priv-&gt;client = NULL;
893   }
894   if(priv-&gt;xmpp_manager != NULL)
895   {
896     g_object_unref(G_OBJECT(priv-&gt;xmpp_manager));
897     priv-&gt;xmpp_manager = NULL;
898   }</b></font>
899   if(priv-&gt;creds != NULL)
900   {
901     inf_certificate_credentials_unref(priv-&gt;creds);
902     priv-&gt;creds = NULL;
903   }
904   if(priv-&gt;sasl_context != NULL)
905   {
906     inf_sasl_context_unref(priv-&gt;sasl_context);
907     priv-&gt;sasl_context = NULL;
908   }
909   if(priv-&gt;io != NULL)
910   {
911     g_object_unref(G_OBJECT(priv-&gt;io));
912     priv-&gt;io = NULL;
913   }
914   G_OBJECT_CLASS(inf_discovery_avahi_parent_class)-&gt;dispose(object);
915 }
916 static void
917 inf_discovery_avahi_finalize(GObject* object)
918 {
919   InfDiscoveryAvahi* avahi;
920   InfDiscoveryAvahiPrivate* priv;
921   avahi = INF_DISCOVERY_AVAHI(object);
922   priv = INF_DISCOVERY_AVAHI_PRIVATE(avahi);
923 <a name="0"></a>  g_free(priv-&gt;sasl_mechanisms);
924   G_OBJECT_CLASS(inf_discovery_avahi_parent_class)-&gt;finalize(object);
925 <font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>}
926 static void
927 inf_discovery_avahi_set_property(GObject* object,
928                                  guint prop_id,
929                                  const GValue* value,
930                                  GParamSpec* pspec)
931 {
932   InfDiscoveryAvahi* avahi;
933   InfDiscoveryAvahiPrivate* priv;
934   avahi = INF_DISCOVERY_AVAHI(object);
935   priv = INF_DISCOVERY_AVAHI_PRIVATE(avahi);
936   switch(prop_id)
937   {
938   case PROP_IO:
939     g_assert(priv-&gt;io == NULL);     priv-&gt;io = INF_IO(g_value_dup_object(value));
940     break;
941   case PROP_XMPP_MANAGER:
942     g_assert(priv-&gt;xmpp_manager == NULL);     priv-&gt;xmpp_manager = INF_XMPP_MANAGER(g_value_dup_object(value));
943     break;</b></font>
944   case PROP_CREDENTIALS:
945     if(priv-&gt;creds != NULL) inf_certificate_credentials_unref(priv-&gt;creds);
946     priv-&gt;creds = (InfCertificateCredentials*)g_value_dup_boxed(value);
947     break;
948   case PROP_SASL_CONTEXT:
949     priv-&gt;sasl_context = (InfSaslContext*)g_value_dup_boxed(value);
950     break;
951   case PROP_SASL_MECHANISMS:
952     g_free(priv-&gt;sasl_mechanisms);
953     priv-&gt;sasl_mechanisms = g_value_dup_string(value);
954     break;
955   case PROP_SECURITY_POLICY:
956     priv-&gt;security_policy = g_value_get_enum(value);
957     break;
958   case PROP_KEEPALIVE:
959 <a name="1"></a>    g_assert(g_value_get_boxed(value) != NULL);
960     priv-&gt;keepalive = *(const InfKeepalive*)g_value_get_boxed(value);
961     break;
962 <font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>  default:
963     G_OBJECT_WARN_INVALID_PROPERTY_ID(object, prop_id, pspec);
964     break;
965   }
966 }
967 static void
968 inf_discovery_avahi_get_property(GObject* object,
969                                  guint prop_id,
970                                  GValue* value,
971                                  GParamSpec* pspec)
972 {
973   InfDiscoveryAvahi* avahi;
974   InfDiscoveryAvahiPrivate* priv;
975   avahi = INF_DISCOVERY_AVAHI(object);
976   priv = INF_DISCOVERY_AVAHI_PRIVATE(avahi);
977   switch(prop_id)
978   {
979   case PROP_IO:
980     g_value_set_object(value, G_OBJECT(priv-&gt;io));
981     break;
982   case PROP_XMPP_MANAGER:
983     g_value_set_object(value, G_OBJECT(priv-&gt;xmpp_manager));
984     break;</b></font>
985   case PROP_CREDENTIALS:
986     g_value_set_boxed(value, priv-&gt;creds);
987     break;
988   case PROP_SASL_CONTEXT:
989     g_value_set_boxed(value, priv-&gt;sasl_context);
990     break;
991   case PROP_SASL_MECHANISMS:
992     g_value_set_string(value, priv-&gt;sasl_mechanisms);
993     break;
994   case PROP_SECURITY_POLICY:
995     g_value_set_enum(value, priv-&gt;security_policy);
996     break;
997   case PROP_KEEPALIVE:
998     g_value_set_boxed(value, &amp;priv-&gt;keepalive);
999     break;
1000   default:
1001     G_OBJECT_WARN_INVALID_PROPERTY_ID(object, prop_id, pspec);
1002     break;
1003   }
1004 }
1005 static void
1006 inf_discovery_avahi_discover(InfDiscovery* discovery,
1007                              const gchar* type)
1008 {
1009   InfDiscoveryAvahiPrivate* priv;
1010   InfDiscoveryAvahiDiscoverInfo* info;
1011   priv = INF_DISCOVERY_AVAHI_PRIVATE(discovery);
1012   info = g_hash_table_lookup(priv-&gt;discovered, type);
1013   if(info == NULL)
1014   {
1015     info = g_slice_new(InfDiscoveryAvahiDiscoverInfo);
1016     info-&gt;type = g_strdup(type);
1017     info-&gt;service_browser = NULL;
1018     info-&gt;discovered = NULL;
1019     g_hash_table_insert(priv-&gt;discovered, info-&gt;type, info);
1020     if(priv-&gt;client != NULL &amp;&amp;
1021        avahi_client_get_state(priv-&gt;client) == AVAHI_CLIENT_S_RUNNING)
1022     {
1023       inf_discovery_avahi_perform_discover(
1024         INF_DISCOVERY_AVAHI(discovery),
1025         info
1026       );
1027     }
1028   }
1029 }
1030 static GSList*
1031 inf_discovery_avahi_get_discovered(InfDiscovery* discovery,
1032                                    const gchar* type)
1033 {
1034   InfDiscoveryAvahiPrivate* priv;
1035   InfDiscoveryAvahiDiscoverInfo* info;
1036   priv = INF_DISCOVERY_AVAHI_PRIVATE(discovery);
1037   info = g_hash_table_lookup(priv-&gt;discovered, type);
1038   if(info == NULL) return NULL;
1039   return g_slist_copy(info-&gt;discovered);
1040 }
1041 static void
1042 inf_discovery_avahi_resolve(InfDiscovery* discovery,
1043                             InfDiscoveryInfo* info,
1044                             InfDiscoveryResolvCompleteFunc complete_func,
1045                             gpointer user_data)
1046 {
1047   InfDiscoveryAvahiPrivate* priv;
1048   InfDiscoveryAvahiInfoResolv* resolv;
1049   InfXmlConnectionStatus status;
1050   int errno;
1051   GError* error;
1052   priv = INF_DISCOVERY_AVAHI_PRIVATE(discovery);
1053   g_assert(priv-&gt;client != NULL);
1054   g_assert(avahi_client_get_state(priv-&gt;client) == AVAHI_CLIENT_S_RUNNING);
1055   if(info-&gt;resolved != NULL)
1056   {
1057     g_object_get(G_OBJECT(info-&gt;resolved), "status", &amp;status, NULL);
1058     switch(status)
1059     {
1060     case INF_XML_CONNECTION_CLOSED:
1061       error = NULL;
1062       if(!inf_xml_connection_open(INF_XML_CONNECTION(info-&gt;resolved), &amp;error))
1063       {
1064         complete_func(info, NULL, error, user_data);
1065         g_error_free(error);
1066       }
1067       else
1068       {
1069         complete_func(
1070           info,
1071           INF_XML_CONNECTION(info-&gt;resolved),
1072           NULL,
1073           user_data
1074         );
1075       }
1076       break;
1077     case INF_XML_CONNECTION_CLOSING:
1078       complete_func(info, NULL, NULL, user_data);
1079       break;
1080     case INF_XML_CONNECTION_OPENING:
1081     case INF_XML_CONNECTION_OPEN:
1082       complete_func(
1083         info,
1084         INF_XML_CONNECTION(info-&gt;resolved),
1085         NULL,
1086         user_data
1087       );
1088       break;
1089     default:
1090       g_assert_not_reached();
1091       break;
1092     }
1093   }
1094   else
1095   {
1096     resolv = g_slice_new(InfDiscoveryAvahiInfoResolv);
1097     resolv-&gt;complete_func = complete_func;
1098     resolv-&gt;user_data = user_data;
1099     info-&gt;resolv = g_slist_prepend(info-&gt;resolv, resolv);
1100     if(info-&gt;service_resolver == NULL)
1101     {
1102       info-&gt;service_resolver = avahi_service_resolver_new(
1103         priv-&gt;client,
1104         info-&gt;interface,
1105         info-&gt;protocol,
1106         info-&gt;service_name,
1107         info-&gt;service_type,
1108         info-&gt;domain,
1109         AVAHI_PROTO_UNSPEC,
1110         0,
1111         inf_discovery_avahi_service_resolver_callback,
1112         discovery
1113       );
1114       if(info-&gt;service_resolver == NULL)
1115       {
1116         error = NULL;
1117         errno = avahi_client_errno(
1118           avahi_service_resolver_get_client(info-&gt;service_resolver)
1119         );
1120         g_set_error_literal(
1121           &amp;error,
1122           inf_discovery_avahi_error_quark,
1123           errno,
1124           avahi_strerror(errno)
1125         );
1126         inf_discovery_avahi_info_resolv_error(info, error);
1127         g_error_free(error);
1128       }
1129     }
1130   }
1131 }
1132 static gchar*
1133 inf_discovery_avahi_info_get_service_name(InfDiscovery* discovery,
1134                                           InfDiscoveryInfo* info)
1135 {
1136   char device_name[IF_NAMESIZE];
1137   if(if_indextoname(info-&gt;interface, device_name) == NULL)
1138     return NULL;
1139   return g_strdup_printf(
1140     info-&gt;protocol == AVAHI_PROTO_INET ?
1141       _("%s (via %s on IPv4)") :
1142       _("%s (via %s on IPv6)"),
1143     info-&gt;service_name,
1144     device_name
1145   );
1146 }
1147 static const gchar*
1148 inf_discovery_avahi_info_get_service_type(InfDiscovery* discovery,
1149                                           InfDiscoveryInfo* info)
1150 {
1151   return info-&gt;service_type;
1152 }
1153 static InfLocalPublisherItem*
1154 inf_discovery_avahi_publish(InfLocalPublisher* publisher,
1155                             const gchar* type,
1156                             const gchar* name,
1157                             guint port)
1158 {
1159   InfDiscoveryAvahiPrivate* priv;
1160   InfLocalPublisherItem* item;
1161   priv = INF_DISCOVERY_AVAHI_PRIVATE(publisher);
1162   item = g_slice_new(InfLocalPublisherItem);
1163   item-&gt;type = g_strdup(type);
1164   item-&gt;name = avahi_strdup(name);
1165   item-&gt;port = port;
1166   item-&gt;entry_group = NULL;
1167   priv-&gt;published = g_slist_prepend(priv-&gt;published, item);
1168   if(priv-&gt;client != NULL &amp;&amp;
1169      avahi_client_get_state(priv-&gt;client) == AVAHI_CLIENT_S_RUNNING)
1170   {
1171     inf_discovery_avahi_perform_publish_item(
1172       INF_DISCOVERY_AVAHI(publisher),
1173       item
1174     );
1175   }
1176   return item;
1177 }
1178 static void
1179 inf_discovery_avahi_unpublish(InfLocalPublisher* publisher,
1180                               InfLocalPublisherItem* item)
1181 {
1182   InfDiscoveryAvahiPrivate* priv;
1183   priv = INF_DISCOVERY_AVAHI_PRIVATE(publisher);
1184   g_assert(g_slist_find(priv-&gt;published, item) != NULL);
1185   inf_discovery_avahi_publisher_item_free(item);
1186   priv-&gt;published = g_slist_remove(priv-&gt;published, item);
1187 }
1188 static void
1189 inf_discovery_avahi_class_init(InfDiscoveryAvahiClass* avahi_class)
1190 {
1191   GObjectClass* object_class;
1192   object_class = G_OBJECT_CLASS(avahi_class);
1193   object_class-&gt;constructed = inf_discovery_avahi_constructed;
1194   object_class-&gt;dispose = inf_discovery_avahi_dispose;
1195   object_class-&gt;finalize = inf_discovery_avahi_finalize;
1196   object_class-&gt;set_property = inf_discovery_avahi_set_property;
1197   object_class-&gt;get_property = inf_discovery_avahi_get_property;
1198   inf_discovery_avahi_error_quark = g_quark_from_static_string(
1199     "INF_DISCOVERY_AVAHI_ERROR"
1200   );
1201   g_object_class_install_property(
1202     object_class,
1203     PROP_IO,
1204     g_param_spec_object(
1205       "io",
1206       "IO",
1207       "The IO object used for watching sockets and timeouts",
1208       INF_TYPE_IO,
1209       G_PARAM_READWRITE | G_PARAM_CONSTRUCT_ONLY
1210     )
1211   );
1212   g_object_class_install_property(
1213     object_class,
1214     PROP_XMPP_MANAGER,
1215     g_param_spec_object(
1216       "xmpp-manager",
1217       "XMPP manager",
1218       "The XMPP manager to register resolved XMPP connections",
1219       INF_TYPE_XMPP_MANAGER,
1220       G_PARAM_READWRITE | G_PARAM_CONSTRUCT_ONLY
1221     )
1222   );
1223   g_object_class_install_property(
1224     object_class,
1225     PROP_CREDENTIALS,
1226     g_param_spec_boxed(
1227       "credentials",
1228       "Certificate credentials",
1229       "The GnuTLS certificate credentials used for encrypting XMPP streams",
1230       INF_TYPE_CERTIFICATE_CREDENTIALS,
1231       G_PARAM_READWRITE
1232     )
1233   );
1234   g_object_class_install_property(
1235     object_class,
1236     PROP_SASL_CONTEXT,
1237     g_param_spec_boxed(
1238       "sasl-context",
1239       "SASL context",
1240       "The SASL context used for authentication",
1241       INF_TYPE_SASL_CONTEXT,
1242       G_PARAM_READWRITE
1243     )
1244   );
1245   g_object_class_install_property(
1246     object_class,
1247     PROP_SASL_MECHANISMS,
1248     g_param_spec_string(
1249       "sasl-mechanisms",
1250       "SASL mechanisms",
1251       "The accepted SASL mechanisms for authentication",
1252       NULL,
1253       G_PARAM_READWRITE
1254     )
1255   );
1256   g_object_class_install_property(
1257     object_class,
1258     PROP_SECURITY_POLICY,
1259     g_param_spec_enum(
1260       "security-policy",
1261       "Security policy",
1262       "How to decide whether to use TLS",
1263       INF_TYPE_XMPP_CONNECTION_SECURITY_POLICY,
1264       INF_XMPP_CONNECTION_SECURITY_BOTH_PREFER_TLS,
1265       G_PARAM_READWRITE
1266     )
1267   );
1268   g_object_class_install_property(
1269     object_class,
1270     PROP_KEEPALIVE,
1271     g_param_spec_boxed(
1272       "keepalive",
1273       "Keepalive",
1274       "The keepalive settings for new connections",
1275       INF_TYPE_KEEPALIVE,
1276       G_PARAM_READWRITE
1277     )
1278   );
1279 }
1280 static void
1281 inf_discovery_avahi_discovery_iface_init(InfDiscoveryInterface* iface)
1282 {
1283   iface-&gt;discover = inf_discovery_avahi_discover;
1284   iface-&gt;get_discovered = inf_discovery_avahi_get_discovered;
1285   iface-&gt;resolve = inf_discovery_avahi_resolve;
1286   iface-&gt;info_get_service_name = inf_discovery_avahi_info_get_service_name;
1287   iface-&gt;info_get_service_type = inf_discovery_avahi_info_get_service_type;
1288   iface-&gt;discovered = NULL;
1289   iface-&gt;undiscovered = NULL;
1290 }
1291 static void
1292 inf_discovery_avahi_local_publisher_iface_init(
1293   InfLocalPublisherInterface* iface)
1294 {
1295   iface-&gt;publish = inf_discovery_avahi_publish;
1296   iface-&gt;unpublish = inf_discovery_avahi_unpublish;
1297 }
1298 InfDiscoveryAvahi*
1299 inf_discovery_avahi_new(InfIo* io,
1300                         InfXmppManager* manager,
1301                         InfCertificateCredentials* creds,
1302                         InfSaslContext* sasl_context,
1303                         const gchar* sasl_mechanisms)
1304 {
1305   GObject* object;
1306   g_return_val_if_fail(INF_IS_IO(io), NULL);
1307   g_return_val_if_fail(INF_IS_XMPP_MANAGER(manager), NULL);
1308   object = g_object_new(
1309     INF_TYPE_DISCOVERY_AVAHI,
1310     "io", io,
1311     "xmpp-manager", manager,
1312     "credentials", creds,
1313     "sasl-context", sasl_context,
1314     "sasl-mechanisms", sasl_mechanisms,
1315     NULL
1316   );
1317   return INF_DISCOVERY_AVAHI(object);
1318 }
1319 void
1320 inf_discovery_avahi_set_security_policy(InfDiscoveryAvahi* discovery,
1321                                         InfXmppConnectionSecurityPolicy plcy)
1322 {
1323   g_return_if_fail(INF_IS_DISCOVERY_AVAHI(discovery));
1324   INF_DISCOVERY_AVAHI_PRIVATE(discovery)-&gt;security_policy = plcy;
1325 }
1326 InfXmppConnectionSecurityPolicy
1327 inf_discovery_avahi_get_security_policy(InfDiscoveryAvahi* discovery)
1328 {
1329   g_return_val_if_fail(
1330     INF_IS_DISCOVERY_AVAHI(discovery),
1331     INF_XMPP_CONNECTION_SECURITY_BOTH_PREFER_TLS
1332   );
1333   return INF_DISCOVERY_AVAHI_PRIVATE(discovery)-&gt;security_policy;
1334 }
1335 void
1336 inf_discovery_avahi_set_keepalive(InfDiscoveryAvahi* discovery,
1337                                   const InfKeepalive* keepalive)
1338 {
1339   g_return_if_fail(INF_IS_DISCOVERY_AVAHI(discovery));
1340   g_return_if_fail(keepalive != NULL);
1341   INF_DISCOVERY_AVAHI_PRIVATE(discovery)-&gt;keepalive = *keepalive;
1342 }
1343 const InfKeepalive*
1344 inf_discovery_avahi_get_keepalive(InfDiscoveryAvahi* discovery)
1345 {
1346   g_return_val_if_fail(INF_IS_DISCOVERY_AVAHI(discovery), NULL);
1347   return &amp;INF_DISCOVERY_AVAHI_PRIVATE(discovery)-&gt;keepalive;
1348 }
1349 #endif 
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>inf-gtk-browser-store.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 #include &lt;libinfgtk/inf-gtk-browser-store.h&gt;
2 #include &lt;libinfgtk/inf-gtk-browser-model.h&gt;
3 #include &lt;libinfinity/client/infc-browser.h&gt;
4 #include &lt;libinfinity/inf-i18n.h&gt;
5 #include &lt;libinfinity/inf-signals.h&gt;
6 #include &lt;gtk/gtk.h&gt;
7 typedef struct _InfGtkBrowserStoreItem InfGtkBrowserStoreItem;
8 struct _InfGtkBrowserStoreItem {
9   gchar* name;
10   InfDiscovery* discovery;
11   InfDiscoveryInfo* info;
12   InfBrowser* browser;
13   gpointer missing;
14   GSList* requests;
15   GHashTable* node_errors;
16   InfGtkBrowserModelStatus status;
17   GError* error;
18 <a name="3"></a>
19   InfGtkBrowserStoreItem* next;
20 <font color="#53858b"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>};
21 typedef struct _InfGtkBrowserStoreRequestData InfGtkBrowserStoreRequestData;
22 struct _InfGtkBrowserStoreRequestData {
23   InfGtkBrowserStore* store;
24   InfGtkBrowserStoreItem* item;
25 };
26 typedef struct _InfGtkBrowserStorePrivate InfGtkBrowserStorePrivate;
27 struct _InfGtkBrowserStorePrivate {
28   gint stamp;
29   InfIo* io;
30   InfCommunicationManager* communication_manager;
31   GSList* discoveries;
32   InfGtkBrowserStoreItem* first_item;
33   InfGtkBrowserStoreItem* last_item;
34 };
35 enum {
36   PROP_0,
37   PROP_IO,
38   PROP_COMMUNICATION_MANAGER
39 };
40 #define INF_GTK_BROWSER_STORE_PRIVATE(obj) (G_TYPE_INSTANCE_GET_PRIVATE((obj), INF_GTK_TYPE_BROWSER_STORE, InfGtkBrowserStorePrivate))
41 static void inf_gtk_browser_store_tree_model_iface_init(GtkTreeModelIface* iface);</b></font>
42 static void inf_gtk_browser_store_browser_model_iface_init(InfGtkBrowserModelInterface* iface);
43 G_DEFINE_TYPE_WITH_CODE(InfGtkBrowserStore, inf_gtk_browser_store, G_TYPE_OBJECT,
44   G_ADD_PRIVATE(InfGtkBrowserStore)
45   G_IMPLEMENT_INTERFACE(GTK_TYPE_TREE_MODEL, inf_gtk_browser_store_tree_model_iface_init)
46   G_IMPLEMENT_INTERFACE(INF_GTK_TYPE_BROWSER_MODEL, inf_gtk_browser_store_browser_model_iface_init))
47 static InfGtkBrowserStoreItem*
48 inf_gtk_browser_store_find_item_by_connection(InfGtkBrowserStore* store,
49                                               InfXmlConnection* connection)
50 {
51   InfGtkBrowserStorePrivate* priv;
52   InfGtkBrowserStoreItem* item;
53   InfcBrowser* browser;
54   priv = INF_GTK_BROWSER_STORE_PRIVATE(store);
55   for(item = priv-&gt;first_item; item != NULL; item = item-&gt;next)
56   {
57     if(item-&gt;browser != NULL &amp;&amp; INFC_IS_BROWSER(item-&gt;browser))
58     {
59       browser = INFC_BROWSER(item-&gt;browser);
60       if(infc_browser_get_connection(browser) == connection)
61         return item;
62     }
63   }
64   return NULL;
65 }
66 static InfGtkBrowserStoreItem*
67 inf_gtk_browser_store_find_item_by_browser(InfGtkBrowserStore* store,
68                                            InfBrowser* browser)
69 {
70   InfGtkBrowserStorePrivate* priv;
71   InfGtkBrowserStoreItem* item;
72   priv = INF_GTK_BROWSER_STORE_PRIVATE(store);
73   for(item = priv-&gt;first_item; item != NULL; item = item-&gt;next)
74     if(item-&gt;browser != NULL)
75       if(item-&gt;browser == browser)
76         return item;
77   return NULL;
78 }
79 static InfGtkBrowserStoreItem*
80 inf_gtk_browser_store_find_item_by_discovery_info(InfGtkBrowserStore* store,
81                                                   InfDiscoveryInfo* info)
82 {
83   InfGtkBrowserStorePrivate* priv;
84   InfGtkBrowserStoreItem* item;
85   priv = INF_GTK_BROWSER_STORE_PRIVATE(store);
86   for(item = priv-&gt;first_item; item != NULL; item = item-&gt;next)
87     if(item-&gt;info != NULL)
88       if(item-&gt;info == info)
89         return item;
90   return NULL;
91 }
92 static void
93 inf_gtk_browser_store_browser_notify_status_cb(GObject* object,
94                                                GParamSpec* pspec,
95                                                gpointer user_data);
96 static void
97 inf_gtk_browser_store_browser_error_cb(InfBrowser* browser,
98                                        const GError* error,
99                                        gpointer user_data);
100 static void
101 inf_gtk_browser_store_node_added_cb(InfBrowser* browser,
102                                     InfBrowserIter* iter,
103                                     InfRequest* request,
104                                     gpointer user_data);
105 static void
106 inf_gtk_browser_store_node_removed_cb(InfBrowser* browser,
107                                       InfBrowserIter* iter,
108                                       InfRequest* request,
109                                       gpointer user_data);
110 static void
111 inf_gtk_browser_store_begin_request_explore_node_cb(InfBrowser* browser,
112                                                     InfBrowserIter* iter,
113                                                     InfRequest* request,
114                                                     gpointer user_data);
115 static void
116 inf_gtk_browser_store_begin_request_subscribe_session_cb(InfBrowser* browser,
117                                                          InfBrowserIter* iter,
118                                                          InfRequest* request,
119                                                          gpointer user_data);
120 static void
121 inf_gtk_browser_store_request_finished_cb(InfRequest* request,
122                                           const InfRequestResult* result,
123                                           const GError* error,
124                                           gpointer user_data);
125 static void
126 inf_gtk_browser_store_request_unrefed_func(gpointer data,
127                                            GObject* where_the_object_was);
128 <font color="#38a4a5"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>static void
129 inf_gtk_browser_store_request_data_free(gpointer data,
130                                         GClosure* closure)
131 {
132   g_slice_free(InfGtkBrowserStoreRequestData, data);
133 }
134 static void
135 inf_gtk_browser_store_item_request_remove(InfGtkBrowserStoreItem* item,
136                                           InfRequest* request)
137 {
138   g_object_weak_unref(
139     G_OBJECT(request),
140     inf_gtk_browser_store_request_unrefed_func,
141     item
142   );
143   inf_signal_handlers_disconnect_by_func(
144     G_OBJECT(request),
145     G_CALLBACK(inf_gtk_browser_store_request_finished_cb),
146     item
147   );
148   item-&gt;requests = g_slist_remove(item-&gt;requests, request);
149 }
150 static void
151 inf_gtk_browser_store_item_request_add(InfGtkBrowserStore* store,
152                                        InfGtkBrowserStoreItem* item,
153                                        InfRequest* request)
154 {</b></font>
155   InfGtkBrowserStoreRequestData* data;
156   g_assert(g_slist_find(item-&gt;requests, request) == NULL);
157   item-&gt;requests = g_slist_prepend(item-&gt;requests, request);
158   data = g_slice_new(InfGtkBrowserStoreRequestData);
159   data-&gt;store = store;
160   data-&gt;item = item;
161   g_signal_connect_data(
162     G_OBJECT(request),
163     "finished",
164     G_CALLBACK(inf_gtk_browser_store_request_finished_cb),
165     data,
166     inf_gtk_browser_store_request_data_free,
167     0
168   );
169   g_object_weak_ref(
170     G_OBJECT(request),
171     inf_gtk_browser_store_request_unrefed_func,
172     item
173   );
174 }
175 static void
176 inf_gtk_browser_store_request_finished_cb(InfRequest* request,
177                                           const InfRequestResult* result,
178                                           const GError* error,
179                                           gpointer user_data)
180 {
181   InfGtkBrowserStoreRequestData* data;
182   InfGtkBrowserStorePrivate* priv;
183   InfBrowserIter request_iter;
184   gboolean node_exists;
185   GtkTreeIter tree_iter;
186   GtkTreePath* path;
187   data = (InfGtkBrowserStoreRequestData*)user_data;
188   priv = INF_GTK_BROWSER_STORE_PRIVATE(data-&gt;store);
189   g_assert(g_slist_find(data-&gt;item-&gt;requests, request) != NULL);
190   g_assert(data-&gt;item-&gt;browser != NULL);
191   if(error != NULL)
192   {
193     node_exists = inf_browser_iter_from_request(
194       data-&gt;item-&gt;browser,
195       request,
196       &amp;request_iter
197     );
198     inf_gtk_browser_store_item_request_remove(data-&gt;item, request);
199     if(G_LIKELY(node_exists))
200     {
201       g_hash_table_insert(
202         data-&gt;item-&gt;node_errors,
203         GUINT_TO_POINTER(request_iter.node_id),
204         g_error_copy(error)
205       );
206       tree_iter.stamp = priv-&gt;stamp;
207       tree_iter.user_data = data-&gt;item;
208       tree_iter.user_data2 = GUINT_TO_POINTER(request_iter.node_id);
209       if(request_iter.node_id == 0)
210         tree_iter.user_data3 = NULL;
211       else
212         tree_iter.user_data3 = request_iter.node;
213       path = gtk_tree_model_get_path(GTK_TREE_MODEL(data-&gt;store), &amp;tree_iter);
214       gtk_tree_model_row_changed(GTK_TREE_MODEL(data-&gt;store), path, &amp;tree_iter);
215 <a name="6"></a>      gtk_tree_path_free(path);
216     }
217   }
218 <font color="#8c8774"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>}
219 static void
220 inf_gtk_browser_store_request_unrefed_func(gpointer data,
221                                            GObject* where_the_object_was)
222 {
223   InfGtkBrowserStoreItem* item;
224   item = (InfGtkBrowserStoreItem*)data;
225   item-&gt;requests = g_slist_remove(item-&gt;requests, where_the_object_was);
226 }
227 static void
228 inf_gtk_browser_store_item_set_browser(InfGtkBrowserStore* store,
229                                        InfGtkBrowserStoreItem* item,
230                                        GtkTreePath* path,
231                                        InfBrowser* browser)
232 {
233   GtkTreeIter tree_iter;
234   InfGtkBrowserStorePrivate* priv;
235   priv = INF_GTK_BROWSER_STORE_PRIVATE(store);
236   tree_iter.stamp = priv-&gt;stamp;</b></font>
237   tree_iter.user_data = item;
238   tree_iter.user_data2 = GUINT_TO_POINTER(0);
239   tree_iter.user_data3 = NULL;
240   inf_gtk_browser_model_set_browser(
241     INF_GTK_BROWSER_MODEL(store),
242     path,
243     &amp;tree_iter,
244     item-&gt;browser,
245     browser
246   );
247 }
248 static InfGtkBrowserStoreItem*
249 inf_gtk_browser_store_add_item_by_browser(InfGtkBrowserStore* store,
250                                           InfDiscovery* discovery,
251                                           InfDiscoveryInfo* info,
252                                           InfBrowser* browser,
253                                           gchar* name)
254 {
255   InfGtkBrowserStorePrivate* priv;
256   InfGtkBrowserStoreItem* item;
257   InfGtkBrowserStoreItem* cur;
258   GtkTreePath* path;
259   GtkTreeIter iter;
260   guint index;
261   g_assert(
262     browser == NULL ||
263     inf_gtk_browser_store_find_item_by_browser(store, browser) == NULL
264   );
265   priv = INF_GTK_BROWSER_STORE_PRIVATE(store);
266   item = g_slice_new(InfGtkBrowserStoreItem);
267   item-&gt;name = name;
268   item-&gt;discovery = discovery;
269   item-&gt;info = info;
270   item-&gt;status = INF_GTK_BROWSER_MODEL_DISCONNECTED;
271   if(discovery != NULL &amp;&amp; info != NULL)
272     item-&gt;status = INF_GTK_BROWSER_MODEL_DISCOVERED;
273   item-&gt;browser = NULL;
274   item-&gt;missing = NULL;
275   item-&gt;node_errors = g_hash_table_new_full(
276     NULL,
277     NULL,
278     NULL,
279     (GDestroyNotify)g_error_free
280   );
281   item-&gt;requests = NULL;
282   item-&gt;error = NULL;
283   item-&gt;next = NULL;
284   index = 0;
285   for(cur = priv-&gt;first_item; cur != NULL; cur = cur-&gt;next)
286     ++ index;
287   if(priv-&gt;first_item == NULL)
288   {
289     priv-&gt;first_item = item;
290     priv-&gt;last_item = item;
291   }
292   else
293   {
294     priv-&gt;last_item-&gt;next = item;
295     priv-&gt;last_item = item;
296   }
297   path = gtk_tree_path_new_from_indices(index, -1);
298   iter.stamp = priv-&gt;stamp;
299   iter.user_data = item;
300   iter.user_data2 = GUINT_TO_POINTER(0);
301   iter.user_data3 = NULL;
302   gtk_tree_model_row_inserted(GTK_TREE_MODEL(store), path, &amp;iter);
303   if(browser != NULL)
304     inf_gtk_browser_store_item_set_browser(store, item, path, browser);
305   gtk_tree_path_free(path);
306   return item;
307 }
308 static InfGtkBrowserStoreItem*
309 inf_gtk_browser_store_add_item_by_connection(InfGtkBrowserStore* store,
310                                              InfDiscovery* discovery,
311                                              InfDiscoveryInfo* info,
312                                              InfXmlConnection* connection,
313                                              gchar* name)
314 {
315   InfGtkBrowserStorePrivate* priv;
316   InfcBrowser* browser;
317   InfGtkBrowserStoreItem* item;
318   g_assert(
319     connection == NULL ||
320     inf_gtk_browser_store_find_item_by_connection(store, connection) == NULL
321   );
322   priv = INF_GTK_BROWSER_STORE_PRIVATE(store);
323   browser = NULL;
324   if(connection != NULL)
325   {
326     browser = infc_browser_new(
327       priv-&gt;io,
328       priv-&gt;communication_manager,
329       connection
330     );
331     if(infc_browser_get_connection(browser) == NULL)
332     {
333       g_object_unref(browser);
334       g_free(name);
335       return NULL;
336     }
337   }
338   item = inf_gtk_browser_store_add_item_by_browser(
339     store,
340     discovery,
341     info,
342     INF_BROWSER(browser),
343     name
344   );
345   if(browser != NULL)
346     g_object_unref(browser);
347   return item;
348 }
349 static void
350 inf_gtk_browser_store_remove_item(InfGtkBrowserStore* store,
351                                   InfGtkBrowserStoreItem* item)
352 {
353   InfGtkBrowserStorePrivate* priv;
354   InfGtkBrowserStoreItem* prev;
355   InfGtkBrowserStoreItem* cur;
356   GtkTreePath* path;
357   guint index;
358   priv = INF_GTK_BROWSER_STORE_PRIVATE(store);
359   prev = NULL;
360   index = 0;
361   for(cur = priv-&gt;first_item; cur != NULL; cur = cur-&gt;next)
362   {
363     if(cur == item)
364       break;
365     prev = cur;
366     ++ index;
367   }
368   g_assert(cur != NULL);
369   path = gtk_tree_path_new_from_indices(index, -1);
370   if(item-&gt;browser != NULL)
371   {
372     inf_gtk_browser_store_item_set_browser(store, item, path, NULL);
373     g_assert(item-&gt;browser == NULL);   }
374   if(prev == NULL)
375     priv-&gt;first_item = item-&gt;next;
376   else
377     prev-&gt;next = item-&gt;next;
378   if(item-&gt;next == NULL)
379     priv-&gt;last_item = prev;
380   g_assert(cur != NULL);
381   gtk_tree_model_row_deleted(GTK_TREE_MODEL(store), path);
382   gtk_tree_path_free(path);
383   if(item-&gt;error != NULL)
384     g_error_free(item-&gt;error);
385   g_hash_table_unref(item-&gt;node_errors);
386   g_free(item-&gt;name);
387   g_slice_free(InfGtkBrowserStoreItem, item);
388 }
389 static void
390 inf_gtk_browser_store_discovered_cb(InfDiscovery* discovery,
391                                     InfDiscoveryInfo* info,
392                                     gpointer user_data)
393 {
394   inf_gtk_browser_store_add_item_by_browser(
395     INF_GTK_BROWSER_STORE(user_data),
396     discovery,
397     info,
398     NULL,
399     inf_discovery_info_get_service_name(discovery, info)
400   );
401 }
402 static void
403 inf_gtk_browser_store_undiscovered_cb(InfDiscovery* discovery,
404                                       InfDiscoveryInfo* info,
405                                       gpointer user_data)
406 {
407   InfGtkBrowserStore* store;
408   InfGtkBrowserStoreItem* item;
409   store = INF_GTK_BROWSER_STORE(user_data);
410   item = inf_gtk_browser_store_find_item_by_discovery_info(store, info);
411   if(item != NULL)
412   {
413     if(item-&gt;browser == NULL)
414     {
415       inf_gtk_browser_store_remove_item(store, item);
416     }
417     else
418     {
419       g_assert(item-&gt;status != INF_GTK_BROWSER_MODEL_DISCOVERED &amp;&amp;
420                item-&gt;status != INF_GTK_BROWSER_MODEL_RESOLVING);
421       item-&gt;discovery = NULL;
422       item-&gt;info = NULL;
423     }
424   }
425 }
426 static void
427 inf_gtk_browser_store_browser_error_cb(InfBrowser* browser,
428                                        const GError* error,
429                                        gpointer user_data)
430 {
431   InfGtkBrowserStore* store;
432   InfGtkBrowserStoreItem* item;
433   InfGtkBrowserStorePrivate* priv;
434   GtkTreeIter iter;
435   GtkTreePath* path;
436   store = INF_GTK_BROWSER_STORE(user_data);
437   priv = INF_GTK_BROWSER_STORE_PRIVATE(store);
438   item = inf_gtk_browser_store_find_item_by_browser(store, browser);
439   g_assert(item != NULL);
440   if(item-&gt;error != NULL)
441     g_error_free(item-&gt;error);
442   item-&gt;error = g_error_copy(error);
443   iter.stamp = priv-&gt;stamp;
444   iter.user_data = item;
445   iter.user_data2 = GUINT_TO_POINTER(0);
446   iter.user_data3 = NULL;
447   path = gtk_tree_model_get_path(GTK_TREE_MODEL(store), &amp;iter);
448   gtk_tree_model_row_changed(GTK_TREE_MODEL(store), path, &amp;iter);
449   gtk_tree_path_free(path);
450 }
451 static void
452 inf_gtk_browser_store_browser_notify_status_cb(GObject* object,
453                                                GParamSpec* pspec,
454                                                gpointer user_data)
455 {
456   InfGtkBrowserStore* store;
457   InfGtkBrowserStorePrivate* priv;
458   InfBrowser* browser;
459   InfBrowserStatus status;
460   InfGtkBrowserStoreItem* item;
461   GtkTreeIter iter;
462   GtkTreePath* path;
463   store = INF_GTK_BROWSER_STORE(user_data);
464   priv = INF_GTK_BROWSER_STORE_PRIVATE(user_data);  
465   browser = INF_BROWSER(object);
466   item = inf_gtk_browser_store_find_item_by_browser(store, browser);
467   g_assert(item != NULL);
468   iter.stamp = priv-&gt;stamp;
469   iter.user_data = item;
470   iter.user_data2 = GUINT_TO_POINTER(0);
471   iter.user_data3 = NULL;
472   path = gtk_tree_model_get_path(GTK_TREE_MODEL(store), &amp;iter);
473   g_object_get(G_OBJECT(browser), "status", &amp;status, NULL);
474   switch(status)
475   {
476   case INF_BROWSER_CLOSED:
477     item-&gt;status = INF_GTK_BROWSER_MODEL_ERROR;
478     if(item-&gt;error == NULL)
479     {
480       item-&gt;error = g_error_new_literal(
481         g_quark_from_static_string("INF_GTK_BROWSER_STORE_ERROR"),
482         0,
483         _("Disconnected")
484       );
485     }
486     gtk_tree_model_row_changed(GTK_TREE_MODEL(store), path, &amp;iter);
487     break;
488   case INF_BROWSER_OPENING:
489     if(item-&gt;error != NULL) g_error_free(item-&gt;error);
490     item-&gt;error = NULL;
491     item-&gt;status = INF_GTK_BROWSER_MODEL_CONNECTING;
492     gtk_tree_model_row_changed(GTK_TREE_MODEL(store), path, &amp;iter);
493     break;
494   case INF_BROWSER_OPEN:
495     if(item-&gt;error != NULL) g_error_free(item-&gt;error);
496     item-&gt;error = NULL;
497     item-&gt;status = INF_GTK_BROWSER_MODEL_CONNECTED;
498     gtk_tree_model_row_changed(GTK_TREE_MODEL(store), path, &amp;iter);
499     break;
500   default:
501     g_assert_not_reached();
502     break;
503   }
504   gtk_tree_path_free(path);
505 }
506 static void
507 inf_gtk_browser_store_node_added_cb(InfBrowser* browser,
508                                     InfBrowserIter* iter,
509                                     InfRequest* request,
510                                     gpointer user_data)
511 {
512   InfGtkBrowserStore* store;
513   InfGtkBrowserStorePrivate* priv;
514   InfGtkBrowserStoreItem* item;
515   GtkTreeIter tree_iter;
516   GtkTreePath* path;
517   InfBrowserIter test_iter;
518   gboolean test_result;
519   store = INF_GTK_BROWSER_STORE(user_data);
520   priv = INF_GTK_BROWSER_STORE_PRIVATE(store);
521   item = inf_gtk_browser_store_find_item_by_browser(store, browser);
522   tree_iter.stamp = priv-&gt;stamp;
523   tree_iter.user_data = item;
524   tree_iter.user_data2 = GUINT_TO_POINTER(iter-&gt;node_id);
525   tree_iter.user_data3 = iter-&gt;node;
526   if(iter-&gt;node_id != 0)
527   {
528     path = gtk_tree_model_get_path(GTK_TREE_MODEL(store), &amp;tree_iter);
529     gtk_tree_model_row_inserted(GTK_TREE_MODEL(store), path, &amp;tree_iter);
530     test_iter = *iter;
531     test_result = inf_browser_get_parent(browser, &amp;test_iter);
532     g_assert(test_result == TRUE);
533     tree_iter.user_data2 = GUINT_TO_POINTER(test_iter.node_id);
534     gtk_tree_path_up(path);
535     if(test_iter.node_id == 0)
536       tree_iter.user_data3 = NULL;
537     else
538       tree_iter.user_data3 = test_iter.node;
539     test_result = inf_browser_get_child(browser, &amp;test_iter);
540     g_assert(test_result == TRUE);
541     if(inf_browser_get_next(browser, &amp;test_iter) == FALSE)
542     {
543       gtk_tree_model_row_has_child_toggled(
544         GTK_TREE_MODEL(store),
545         path,
546         &amp;tree_iter
547       );
548     }
549     gtk_tree_path_free(path);
550   }
551 }
552 static void
553 inf_gtk_browser_store_node_removed_cb(InfBrowser* browser,
554                                       InfBrowserIter* iter,
555                                       InfRequest* request,
556                                       gpointer user_data)
557 {
558   InfGtkBrowserStore* store;
559   InfGtkBrowserStorePrivate* priv;
560   InfGtkBrowserStoreItem* item;
561   GtkTreeIter tree_iter;
562   GtkTreePath* path;
563   InfBrowserIter test_iter;
564   gboolean test_result;
565   store = INF_GTK_BROWSER_STORE(user_data);
566   priv = INF_GTK_BROWSER_STORE_PRIVATE(store);
567   item = inf_gtk_browser_store_find_item_by_browser(store, browser);
568   g_assert(item-&gt;missing == NULL);
569   tree_iter.stamp = priv-&gt;stamp;
570   tree_iter.user_data = item;
571   tree_iter.user_data2 = GUINT_TO_POINTER(iter-&gt;node_id);
572   tree_iter.user_data3 = iter-&gt;node;
573   path = gtk_tree_model_get_path(GTK_TREE_MODEL(store), &amp;tree_iter);
574   item-&gt;missing = iter-&gt;node;
575   if(iter-&gt;node_id != 0)
576   {
577     gtk_tree_model_row_deleted(GTK_TREE_MODEL(store), path);
578     test_iter = *iter;
579     test_result = inf_browser_get_parent(browser, &amp;test_iter);
580     g_assert(test_result == TRUE);
581     tree_iter.user_data2 = GUINT_TO_POINTER(test_iter.node_id);
582     gtk_tree_path_up(path);
583     if(test_iter.node_id == 0)
584       tree_iter.user_data3 = NULL;
585     else
586       tree_iter.user_data3 = test_iter.node;
587     test_result = inf_browser_get_child(browser, &amp;test_iter);
588     g_assert(test_result == TRUE);
589     if(inf_browser_get_next(browser, &amp;test_iter) == FALSE)
590     {
591       gtk_tree_model_row_has_child_toggled(
592         GTK_TREE_MODEL(store),
593         path,
594         &amp;tree_iter
595       );
596     }
597   }
598   else
599   {
600     if(inf_browser_get_explored(browser, iter))
601     {
602       test_iter = *iter;
603       test_result = inf_browser_get_child(browser, &amp;test_iter);
604       gtk_tree_path_down(path);
605       do
606       {
607         gtk_tree_model_row_deleted(GTK_TREE_MODEL(store), path);
608       } while(inf_browser_get_next(browser, &amp;test_iter));
609       if(test_result == TRUE)
610       {
611         gtk_tree_path_up(path);
612         gtk_tree_model_row_has_child_toggled(
613           GTK_TREE_MODEL(store),
614           path,
615           &amp;tree_iter
616         );
617       }
618     }
619   }
620   item-&gt;missing = NULL;
621   gtk_tree_path_free(path);
622 }
623 static void
624 inf_gtk_browser_store_begin_request_explore_node_cb(InfBrowser* browser,
625                                                     InfBrowserIter* iter,
626                                                     InfRequest* request,
627                                                     gpointer user_data)
628 {
629   InfGtkBrowserStore* store;
630   InfGtkBrowserStoreItem* item;
631   store = INF_GTK_BROWSER_STORE(user_data);
632   item = inf_gtk_browser_store_find_item_by_browser(store, browser);
633   inf_gtk_browser_store_item_request_add(store, item, request);
634 }
635 static void
636 inf_gtk_browser_store_begin_request_subscribe_session_cb(InfBrowser* browser,
637                                                          InfBrowserIter* iter,
638                                                          InfRequest* request,
639                                                          gpointer user_data)
640 {
641   InfGtkBrowserStore* store;
642   InfGtkBrowserStoreItem* item;
643   g_assert(iter != NULL);
644   store = INF_GTK_BROWSER_STORE(user_data);
645   item = inf_gtk_browser_store_find_item_by_browser(store, browser);
646   inf_gtk_browser_store_item_request_add(store, item, request);
647 }
648 static void
649 inf_gtk_browser_store_resolv_complete_func(InfDiscoveryInfo* info,
650                                            InfXmlConnection* connection,
651                                            const GError* error,
652                                            gpointer user_data)
653 {
654   InfGtkBrowserStore* store;
655   InfGtkBrowserStorePrivate* priv;
656   InfGtkBrowserStoreItem* new_item;
657   InfGtkBrowserStoreItem* old_item;
658   GtkTreeIter tree_iter;
659   GtkTreePath* path;
660   InfcBrowser* browser;
661   InfGtkBrowserStoreItem* cur;
662   InfGtkBrowserStoreItem* prev;
663   InfGtkBrowserStoreItem* prev_new;
664   InfGtkBrowserStoreItem* prev_old;
665   gint* order;
666   guint count;
667   guint new_pos;
668   guint old_pos;
669   guint i;
670   store = INF_GTK_BROWSER_STORE(user_data);
671   priv = INF_GTK_BROWSER_STORE_PRIVATE(store);
672   new_item = inf_gtk_browser_store_find_item_by_discovery_info(store, info);
673   g_assert(new_item != NULL);
674   g_assert(new_item-&gt;status == INF_GTK_BROWSER_MODEL_RESOLVING);
675   tree_iter.stamp = priv-&gt;stamp;
676   tree_iter.user_data = new_item;
677   tree_iter.user_data2 = GUINT_TO_POINTER(0);
678   tree_iter.user_data3 = NULL;
679   if(error != NULL)
680   {
681     new_item-&gt;status = INF_GTK_BROWSER_MODEL_ERROR;
682     new_item-&gt;error = g_error_copy(error);
683     path = gtk_tree_model_get_path(GTK_TREE_MODEL(store), &amp;tree_iter);
684     gtk_tree_model_row_changed(GTK_TREE_MODEL(store), path, &amp;tree_iter);
685     gtk_tree_path_free(path);
686   }
687   else
688   {
689     old_item =
690       inf_gtk_browser_store_find_item_by_connection(store, connection);
691     if(old_item != NULL)
692     {
693       g_assert(old_item != new_item);
694       count = 0;
695       prev = NULL;
696       for(cur = priv-&gt;first_item; cur != NULL; cur = cur-&gt;next)
697       {
698         if(cur == old_item) { old_pos = count; prev_old = prev; }
699         if(cur == new_item) { new_pos = count; prev_new = prev; }
700         ++ count;
701         prev = cur;
702       }
703       inf_gtk_browser_store_remove_item(store, new_item);
704       if(old_pos &gt; new_pos) -- old_pos;
705       else -- new_pos;
706       -- count;
707       if(new_pos != old_pos)
708       {
709         if(old_item-&gt;next == NULL)
710           priv-&gt;last_item = prev_old;
711         if(prev_old != NULL)
712           prev_old-&gt;next = old_item-&gt;next;
713         else
714           priv-&gt;first_item = old_item-&gt;next;
715         old_item-&gt;next = prev_new-&gt;next;
716         if(prev_new != NULL)
717           prev_new-&gt;next = old_item;
718         else
719           priv-&gt;first_item = old_item;
720         if(old_item-&gt;next == NULL)
721           priv-&gt;last_item = old_item;
722         order = g_malloc(sizeof(gint) * count);
723         if(new_pos &lt; old_pos)
724         {
725           for(i = 0; i &lt; new_pos; ++ i)
726             order[i] = i;
727           order[new_pos] = old_pos;
728           for(i = new_pos + 1; i &lt;= old_pos; ++ i)
729             order[i] = i - 1;
730           for(i = old_pos + 1; i &lt; count; ++ i)
731             order[i] = i;
732         }
733         else
734         {
735           for(i = 0; i &lt; old_pos; ++ i)
736             order[i] = i;
737           for(i = old_pos; i &lt; new_pos; ++ i)
738             order[i] = i + 1;
739           order[new_pos] = old_pos;
740           for(i = new_pos + 1; i &lt; count; ++ i)
741             order[i] = i;
742         }
743         path = gtk_tree_path_new();
744         gtk_tree_model_rows_reordered(
745           GTK_TREE_MODEL(store),
746           path,
747           NULL,
748           order
749         );
750         gtk_tree_path_free(path);
751         g_free(order);
752       }
753     }
754     else
755     {
756       path = gtk_tree_model_get_path(GTK_TREE_MODEL(store), &amp;tree_iter);
757       browser = infc_browser_new(
758         priv-&gt;io,
759         priv-&gt;communication_manager,
760         connection
761       );
762       if(infc_browser_get_connection(browser) != NULL)
763       {
764         inf_gtk_browser_store_item_set_browser(
765           store,
766           new_item,
767           path,
768           INF_BROWSER(browser)
769         );
770       }
771       g_object_unref(G_OBJECT(browser));
772       gtk_tree_path_free(path);
773     }
774   }
775 }
776 static void
777 inf_gtk_browser_store_init(InfGtkBrowserStore* store)
778 {
779   InfGtkBrowserStorePrivate* priv;
780 <a name="2"></a>  priv = INF_GTK_BROWSER_STORE_PRIVATE(store);
781   priv-&gt;stamp = g_random_int();
782 <font color="#980517"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>  priv-&gt;io = NULL;
783   priv-&gt;communication_manager = NULL;
784   priv-&gt;discoveries = NULL;
785   priv-&gt;first_item = NULL;
786   priv-&gt;last_item = NULL;
787 }
788 static void
789 inf_gtk_browser_store_dispose(GObject* object)
790 {
791   InfGtkBrowserStore* store;
792   InfGtkBrowserStorePrivate* priv;
793   GSList* item;
794   store = INF_GTK_BROWSER_STORE(object);</b></font>
795   priv = INF_GTK_BROWSER_STORE_PRIVATE(store);
796   while(priv-&gt;first_item != NULL)
797     inf_gtk_browser_store_remove_item(store, priv-&gt;first_item);
798   g_assert(priv-&gt;last_item == NULL);
799   for(item = priv-&gt;discoveries; item != NULL; item = g_slist_next(item))
800   {
801     inf_signal_handlers_disconnect_by_func(
802       G_OBJECT(item-&gt;data),
803       G_CALLBACK(inf_gtk_browser_store_discovered_cb),
804       store
805     );
806     inf_signal_handlers_disconnect_by_func(
807       G_OBJECT(item-&gt;data),
808       G_CALLBACK(inf_gtk_browser_store_undiscovered_cb),
809       store
810     );
811     g_object_unref(G_OBJECT(item-&gt;data));
812 <a name="4"></a>  }
813   g_slist_free(priv-&gt;discoveries);
814 <font color="#6cc417"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>  priv-&gt;discoveries = NULL;
815   if(priv-&gt;communication_manager != NULL)
816   {
817     g_object_unref(priv-&gt;communication_manager);
818     priv-&gt;communication_manager = NULL;
819   }
820   if(priv-&gt;io != NULL)
821   {
822     g_object_unref(G_OBJECT(priv-&gt;io));
823     priv-&gt;io = NULL;
824 <a name="0"></a>  }</b></font>
825   G_OBJECT_CLASS(inf_gtk_browser_store_parent_class)-&gt;dispose(object);
826 <font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>}
827 static void
828 inf_gtk_browser_store_set_property(GObject* object,
829                                    guint prop_id,
830                                    const GValue* value,
831                                    GParamSpec* pspec)
832 {
833   InfGtkBrowserStore* store;
834   InfGtkBrowserStorePrivate* priv;
835   store = INF_GTK_BROWSER_STORE(object);
836   priv = INF_GTK_BROWSER_STORE_PRIVATE(store);
837   switch(prop_id)
838   {
839   case PROP_IO:
840     g_assert(priv-&gt;io == NULL);     priv-&gt;io = INF_IO(g_value_dup_object(value));
841     break;
842   case PROP_COMMUNICATION_MANAGER: 
843     g_assert(priv-&gt;communication_manager == NULL);     priv-&gt;communication_manager =
844 <a name="1"></a>      INF_COMMUNICATION_MANAGER(g_value_dup_object(value));
845     break;</b></font>
846 <font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>  default:
847     G_OBJECT_WARN_INVALID_PROPERTY_ID(object, prop_id, pspec);
848     break;
849   }
850 }
851 static void
852 inf_gtk_browser_store_get_property(GObject* object,
853                                    guint prop_id,
854                                    GValue* value,
855                                    GParamSpec* pspec)
856 {
857   InfGtkBrowserStore* store;
858   InfGtkBrowserStorePrivate* priv;
859   store = INF_GTK_BROWSER_STORE(object);
860   priv = INF_GTK_BROWSER_STORE_PRIVATE(store);
861   switch(prop_id)
862   {
863   case PROP_IO:
864     g_value_set_object(value, priv-&gt;io);
865     break;
866   case PROP_COMMUNICATION_MANAGER:
867     g_value_set_object(value, priv-&gt;communication_manager);
868     break;</b></font>
869   default:
870     G_OBJECT_WARN_INVALID_PROPERTY_ID(object, prop_id, pspec);
871     break;
872   }
873 }
874 static GtkTreeModelFlags
875 inf_gtk_browser_store_tree_model_get_flags(GtkTreeModel* model)
876 {
877   return GTK_TREE_MODEL_ITERS_PERSIST;
878 }
879 static gint
880 inf_gtk_browser_store_tree_model_get_n_columns(GtkTreeModel* model)
881 {
882   return INF_GTK_BROWSER_MODEL_NUM_COLS;
883 }
884 static GType
885 inf_gtk_browser_store_tree_model_get_column_type(GtkTreeModel* model,
886                                                  gint index)
887 {
888   switch(index)
889   {
890   case INF_GTK_BROWSER_MODEL_COL_DISCOVERY_INFO:
891     return G_TYPE_POINTER;
892   case INF_GTK_BROWSER_MODEL_COL_DISCOVERY:
893     return INF_TYPE_DISCOVERY;
894   case INF_GTK_BROWSER_MODEL_COL_BROWSER:
895     return INFC_TYPE_BROWSER;
896   case INF_GTK_BROWSER_MODEL_COL_STATUS:
897     return INF_GTK_TYPE_BROWSER_MODEL_STATUS;
898   case INF_GTK_BROWSER_MODEL_COL_NAME:
899     return G_TYPE_STRING;
900   case INF_GTK_BROWSER_MODEL_COL_ERROR:
901     return G_TYPE_POINTER;
902   case INF_GTK_BROWSER_MODEL_COL_NODE:
903     return INF_TYPE_BROWSER_ITER;
904   default:
905     g_assert_not_reached();
906     return G_TYPE_INVALID;
907   }
908 }
909 static gboolean
910 inf_gtk_browser_store_tree_model_get_iter(GtkTreeModel* model,
911                                           GtkTreeIter* iter,
912                                           GtkTreePath* path)
913 {
914   InfGtkBrowserStorePrivate* priv;
915   InfGtkBrowserStoreItem* item;
916   InfBrowserIter browser_iter;
917   gint* indices;
918   guint i;
919   guint n;
920   priv = INF_GTK_BROWSER_STORE_PRIVATE(model);
921   if(gtk_tree_path_get_depth(path) == 0) return FALSE;
922   indices = gtk_tree_path_get_indices(path);
923   n = indices[0];
924   i = 0;
925   for(item = priv-&gt;first_item; item != NULL &amp;&amp; i &lt; n; item = item-&gt;next)
926     ++i;
927   if(item == NULL) return FALSE;
928   if(gtk_tree_path_get_depth(path) == 1)
929   {
930     iter-&gt;stamp = priv-&gt;stamp;
931     iter-&gt;user_data = item;
932     iter-&gt;user_data2 = GUINT_TO_POINTER(0);
933     iter-&gt;user_data3 = NULL;
934     return TRUE;
935   }
936   if(item-&gt;browser == NULL) return FALSE;
937   inf_browser_get_root(item-&gt;browser, &amp;browser_iter);
938   for(n = 1; n &lt; (guint)gtk_tree_path_get_depth(path); ++ n)
939   {
940     if(inf_browser_get_explored(item-&gt;browser, &amp;browser_iter) == FALSE)
941       return FALSE;
942     if(inf_browser_get_child(item-&gt;browser, &amp;browser_iter) == FALSE)
943       return FALSE;
944     if(browser_iter.node == item-&gt;missing)
945       ++indices[n];
946     for(i = 0; i &lt; (guint)indices[n]; ++ i)
947     {
948       if(inf_browser_get_next(item-&gt;browser, &amp;browser_iter) == FALSE)
949         return FALSE;
950       if(browser_iter.node == item-&gt;missing)
951         ++indices[n];
952     }
953   }
954   iter-&gt;stamp = priv-&gt;stamp;
955   iter-&gt;user_data = item;
956   iter-&gt;user_data2 = GUINT_TO_POINTER(browser_iter.node_id);
957   iter-&gt;user_data3 = browser_iter.node;
958   return TRUE;
959 }
960 static void
961 inf_gtk_browser_store_tree_model_get_path_impl(InfGtkBrowserStore* store,
962                                                InfGtkBrowserStoreItem* item,
963                                                InfBrowserIter* iter,
964                                                GtkTreePath* path)
965 {
966   InfGtkBrowserStorePrivate* priv;
967   InfBrowserIter cur_iter;
968   InfGtkBrowserStoreItem* cur;
969   gboolean result;
970   guint n;
971   cur_iter = *iter;
972   if(inf_browser_get_parent(item-&gt;browser, &amp;cur_iter) == FALSE)
973   {
974     priv = INF_GTK_BROWSER_STORE_PRIVATE(store);
975     n = 0;
976     for(cur = priv-&gt;first_item; cur != item; cur = cur-&gt;next)
977       ++n;
978     gtk_tree_path_append_index(path, n);
979   }
980   else
981   {
982     inf_gtk_browser_store_tree_model_get_path_impl(
983       store,
984       item,
985       &amp;cur_iter,
986       path
987     );
988     result = inf_browser_get_child(item-&gt;browser, &amp;cur_iter);
989     g_assert(result == TRUE);
990     if(cur_iter.node == item-&gt;missing)
991     {
992       result = inf_browser_get_next(item-&gt;browser, &amp;cur_iter);
993       g_assert(result == TRUE);
994     }
995     n = 0;
996     while(cur_iter.node_id != iter-&gt;node_id)
997     {
998       result = inf_browser_get_next(item-&gt;browser, &amp;cur_iter);
999       g_assert(result == TRUE);
1000       if(cur_iter.node == item-&gt;missing)
1001       {
1002         result = inf_browser_get_next(item-&gt;browser, &amp;cur_iter);
1003         g_assert(result == TRUE);
1004       }
1005       ++n;
1006     }
1007     gtk_tree_path_append_index(path, n);
1008   }
1009 }
1010 static GtkTreePath*
1011 inf_gtk_browser_store_tree_model_get_path(GtkTreeModel* model,
1012                                           GtkTreeIter* iter)
1013 {
1014   InfGtkBrowserStorePrivate* priv;
1015   InfGtkBrowserStoreItem* item;
1016   InfGtkBrowserStoreItem* cur;
1017   GtkTreePath* path;
1018   InfBrowserIter browser_iter;
1019   guint n;
1020   priv = INF_GTK_BROWSER_STORE_PRIVATE(model);
1021   g_assert(iter-&gt;stamp == priv-&gt;stamp);
1022   g_assert(iter-&gt;user_data != NULL);
1023   item = (InfGtkBrowserStoreItem*)iter-&gt;user_data;
1024   path = gtk_tree_path_new();
1025   browser_iter.node_id = GPOINTER_TO_UINT(iter-&gt;user_data2);
1026   browser_iter.node = iter-&gt;user_data3;
1027   if(browser_iter.node != NULL)
1028   {
1029     g_assert(item-&gt;browser != NULL);
1030     inf_gtk_browser_store_tree_model_get_path_impl(
1031       INF_GTK_BROWSER_STORE(model),
1032       item,
1033       &amp;browser_iter,
1034       path
1035     );
1036   }
1037   else
1038   {
1039     n = 0;
1040     for(cur = priv-&gt;first_item; cur != item; cur = cur-&gt;next)
1041       ++n;
1042     gtk_tree_path_append_index(path, n);
1043   }
1044   return path;
1045 }
1046 static void
1047 inf_gtk_browser_store_tree_model_get_value(GtkTreeModel* model,
1048                                            GtkTreeIter* iter,
1049                                            gint column,
1050                                            GValue* value)
1051 {
1052   InfGtkBrowserStorePrivate* priv;
1053   InfGtkBrowserStoreItem* item;
1054   InfBrowserIter browser_iter;
1055   InfBrowserStatus browser_status;
1056   GError* error;
1057   priv = INF_GTK_BROWSER_STORE_PRIVATE(model);
1058   g_assert(iter-&gt;stamp == priv-&gt;stamp);
1059   item = (InfGtkBrowserStoreItem*)iter-&gt;user_data;
1060   browser_iter.node_id = GPOINTER_TO_UINT(iter-&gt;user_data2);
1061   browser_iter.node = iter-&gt;user_data3;
1062   g_assert(
1063     item-&gt;missing == NULL || browser_iter.node_id == 0 ||
1064     browser_iter.node != item-&gt;missing
1065   );
1066   switch(column)
1067   {
1068   case INF_GTK_BROWSER_MODEL_COL_DISCOVERY_INFO:
1069     g_value_init(value, G_TYPE_POINTER);
1070     g_value_set_pointer(value, item-&gt;info);
1071     break;
1072   case INF_GTK_BROWSER_MODEL_COL_DISCOVERY:
1073     g_value_init(value, G_TYPE_OBJECT);
1074     g_value_set_object(value, item-&gt;discovery);
1075     break;
1076   case INF_GTK_BROWSER_MODEL_COL_BROWSER:
1077     g_value_init(value, INF_TYPE_BROWSER);
1078     g_value_set_object(value, G_OBJECT(item-&gt;browser));
1079     break;
1080   case INF_GTK_BROWSER_MODEL_COL_STATUS:
1081     g_assert(browser_iter.node == NULL);     g_value_init(value, INF_GTK_TYPE_BROWSER_MODEL_STATUS);
1082     g_value_set_enum(value, item-&gt;status);
1083     break;
1084   case INF_GTK_BROWSER_MODEL_COL_NAME:
1085     g_value_init(value, G_TYPE_STRING);
1086     if(browser_iter.node == NULL)
1087     {
1088       g_value_set_string(value, item-&gt;name);
1089     }
1090     else
1091     {
1092       g_value_set_string(
1093         value,
1094         inf_browser_get_node_name(INF_BROWSER(item-&gt;browser), &amp;browser_iter)
1095       );
1096     }
1097     break;
1098   case INF_GTK_BROWSER_MODEL_COL_ERROR:
1099     if(browser_iter.node == NULL)
1100     {
1101       if(item-&gt;error != NULL)
1102       {
1103         error = item-&gt;error;
1104       }
1105       else if(item-&gt;browser != NULL)
1106       {
1107         g_object_get(
1108           G_OBJECT(item-&gt;browser),
1109           "status",
1110           &amp;browser_status,
1111           NULL
1112         );
1113         if(browser_status == INF_BROWSER_OPEN)
1114         {
1115           inf_browser_get_root(item-&gt;browser, &amp;browser_iter);
1116           error = g_hash_table_lookup(
1117             item-&gt;node_errors,
1118             GUINT_TO_POINTER(browser_iter.node_id)
1119           );
1120         }
1121         else
1122         {
1123           error = NULL;
1124         }
1125       }
1126       else
1127       {
1128         error = NULL;
1129       }
1130     }
1131     else
1132     {
1133       g_assert(item-&gt;browser != NULL);
1134       g_object_get(G_OBJECT(item-&gt;browser), "status", &amp;browser_status, NULL);
1135       g_assert(browser_status == INF_BROWSER_OPEN);
1136       error = g_hash_table_lookup(
1137         item-&gt;node_errors,
1138         GUINT_TO_POINTER(browser_iter.node_id)
1139       );
1140     }
1141     g_value_init(value, G_TYPE_POINTER);
1142     g_value_set_pointer(value, error);
1143     break;
1144   case INF_GTK_BROWSER_MODEL_COL_NODE:
1145     g_assert(item-&gt;browser != NULL);
1146     g_object_get(G_OBJECT(item-&gt;browser), "status", &amp;browser_status, NULL);
1147     g_assert(browser_status == INF_BROWSER_OPEN);
1148     if(browser_iter.node == NULL)
1149       inf_browser_get_root(item-&gt;browser, &amp;browser_iter);
1150     g_value_init(value, INF_TYPE_BROWSER_ITER);
1151     g_value_set_boxed(value, &amp;browser_iter);
1152     break;
1153   default:
1154     g_assert_not_reached();
1155     break;
1156   }
1157 }
1158 static gboolean
1159 inf_gtk_browser_store_tree_model_iter_next(GtkTreeModel* model,
1160                                            GtkTreeIter* iter)
1161 {
1162   InfGtkBrowserStorePrivate* priv;
1163   InfGtkBrowserStoreItem* item;
1164   InfBrowserIter browser_iter;
1165   priv = INF_GTK_BROWSER_STORE_PRIVATE(model);
1166   g_assert(iter-&gt;stamp == priv-&gt;stamp);
1167   item = (InfGtkBrowserStoreItem*)iter-&gt;user_data;
1168   browser_iter.node_id = GPOINTER_TO_UINT(iter-&gt;user_data2);
1169   browser_iter.node = iter-&gt;user_data3;
1170   if(browser_iter.node == NULL)
1171   {
1172     if(item-&gt;next == NULL)
1173       return FALSE;
1174     iter-&gt;user_data = item-&gt;next;
1175     return TRUE;
1176   }
1177   else
1178   {
1179     g_assert(browser_iter.node != item-&gt;missing);
1180     if(inf_browser_get_next(item-&gt;browser, &amp;browser_iter) == FALSE)
1181       return FALSE;
1182     if(browser_iter.node == item-&gt;missing)
1183       if(inf_browser_get_next(item-&gt;browser, &amp;browser_iter) == FALSE)
1184         return FALSE;
1185     iter-&gt;user_data2 = GUINT_TO_POINTER(browser_iter.node_id);
1186     iter-&gt;user_data3 = browser_iter.node;
1187     return TRUE;
1188   }
1189 }
1190 static gboolean
1191 inf_gtk_browser_store_tree_model_iter_children(GtkTreeModel* model,
1192                                                GtkTreeIter* iter,
1193                                                GtkTreeIter* parent)
1194 {
1195   InfGtkBrowserStorePrivate* priv;
1196   InfGtkBrowserStoreItem* item;
1197   InfBrowserStatus browser_status;
1198   InfBrowserIter browser_iter;
1199   priv = INF_GTK_BROWSER_STORE_PRIVATE(model);
1200   if(parent == NULL)
1201   {
1202     if(priv-&gt;first_item == NULL)
1203       return FALSE;
1204     iter-&gt;stamp = priv-&gt;stamp;
1205     iter-&gt;user_data = priv-&gt;first_item;
1206     iter-&gt;user_data2 = GUINT_TO_POINTER(0);
1207     iter-&gt;user_data3 = NULL;
1208     return TRUE;
1209   }
1210   else
1211   {
1212     g_assert(parent-&gt;stamp == priv-&gt;stamp);
1213     item = (InfGtkBrowserStoreItem*)parent-&gt;user_data;
1214     if(item-&gt;browser == NULL)
1215       return FALSE;
1216     g_object_get(G_OBJECT(item-&gt;browser), "status", &amp;browser_status, NULL);
1217     if(browser_status != INF_BROWSER_OPEN)
1218       return FALSE;
1219     browser_iter.node_id = GPOINTER_TO_UINT(parent-&gt;user_data2);
1220     if(browser_iter.node_id == 0)
1221       inf_browser_get_root(item-&gt;browser, &amp;browser_iter);
1222     else
1223       browser_iter.node = parent-&gt;user_data3;
1224     g_assert(
1225       item-&gt;missing == NULL || browser_iter.node_id == 0 ||
1226       browser_iter.node != item-&gt;missing
1227     );
1228     if(item-&gt;missing != NULL &amp;&amp; browser_iter.node == item-&gt;missing)
1229       return FALSE;
1230     if(!inf_browser_is_subdirectory(item-&gt;browser, &amp;browser_iter))
1231       return FALSE;
1232     if(!inf_browser_get_explored(item-&gt;browser, &amp;browser_iter))
1233       return FALSE;
1234     if(!inf_browser_get_child(item-&gt;browser, &amp;browser_iter))
1235       return FALSE;
1236     if(browser_iter.node == item-&gt;missing)
1237       if(!inf_browser_get_next(item-&gt;browser, &amp;browser_iter))
1238         return FALSE;
1239     iter-&gt;stamp = priv-&gt;stamp;
1240     iter-&gt;user_data = item;
1241     iter-&gt;user_data2 = GUINT_TO_POINTER(browser_iter.node_id);
1242     iter-&gt;user_data3 = browser_iter.node;
1243     return TRUE;
1244   }
1245 }
1246 static gboolean
1247 inf_gtk_browser_store_tree_model_iter_has_child(GtkTreeModel* model,
1248                                                 GtkTreeIter* iter)
1249 {
1250   InfGtkBrowserStorePrivate* priv;
1251   InfGtkBrowserStoreItem* item;
1252   InfBrowserStatus status;
1253   InfBrowserIter browser_iter;
1254   priv = INF_GTK_BROWSER_STORE_PRIVATE(model);
1255   g_assert(iter-&gt;stamp == priv-&gt;stamp);
1256   item = (InfGtkBrowserStoreItem*)iter-&gt;user_data;
1257   if(item-&gt;browser == NULL) return FALSE;
1258   browser_iter.node_id = GPOINTER_TO_UINT(iter-&gt;user_data2);
1259   browser_iter.node = iter-&gt;user_data3;
1260   g_object_get(G_OBJECT(item-&gt;browser), "status", &amp;status, NULL);
1261   if(status != INF_BROWSER_OPEN)
1262     return FALSE;
1263   if(browser_iter.node == NULL)
1264     inf_browser_get_root(item-&gt;browser, &amp;browser_iter);
1265   g_assert(
1266     item-&gt;missing == NULL || browser_iter.node_id == 0 ||
1267     browser_iter.node != item-&gt;missing
1268   );
1269   if(item-&gt;missing != NULL &amp;&amp; browser_iter.node == item-&gt;missing)
1270     return FALSE;
1271   if(inf_browser_is_subdirectory(item-&gt;browser, &amp;browser_iter) == FALSE)
1272     return FALSE;
1273   if(inf_browser_get_explored(item-&gt;browser, &amp;browser_iter) == FALSE)
1274     return FALSE;
1275   if(!inf_browser_get_child(item-&gt;browser, &amp;browser_iter))
1276     return FALSE;
1277   if(browser_iter.node == item-&gt;missing)
1278     if(!inf_browser_get_next(item-&gt;browser, &amp;browser_iter))
1279       return FALSE;
1280   return TRUE;
1281 }
1282 static gint
1283 inf_gtk_browser_store_tree_model_iter_n_children(GtkTreeModel* model,
1284                                                  GtkTreeIter* iter)
1285 {
1286   InfGtkBrowserStorePrivate* priv;
1287   InfGtkBrowserStoreItem* item;
1288   InfGtkBrowserStoreItem* cur;
1289   InfBrowserIter browser_iter;
1290   gboolean result;
1291   guint n;
1292   priv = INF_GTK_BROWSER_STORE_PRIVATE(model);
1293   g_assert(iter == NULL || iter-&gt;stamp == priv-&gt;stamp);
1294   if(iter == NULL)
1295   {
1296     n = 0;
1297     for(cur = priv-&gt;first_item; cur != NULL; cur = cur-&gt;next)
1298       ++n;
1299     return n;
1300   }
1301   else
1302   {
1303     item = (InfGtkBrowserStoreItem*)iter-&gt;user_data;
1304     browser_iter.node_id = GPOINTER_TO_UINT(iter-&gt;user_data2);
1305     browser_iter.node = iter-&gt;user_data3;
1306     if(browser_iter.node == NULL)
1307       inf_browser_get_root(item-&gt;browser, &amp;browser_iter);
1308     g_assert(
1309       item-&gt;missing == NULL || browser_iter.node_id == 0 ||
1310       browser_iter.node != item-&gt;missing
1311     );
1312     if(item-&gt;missing != NULL &amp;&amp; browser_iter.node == item-&gt;missing)
1313       return 0;
1314     n = 0;
1315     for(result = inf_browser_get_child(item-&gt;browser, &amp;browser_iter);
1316         result == TRUE;
1317         result = inf_browser_get_next(item-&gt;browser, &amp;browser_iter))
1318     {
1319       if(browser_iter.node != item-&gt;missing)
1320         ++n;
1321     }
1322     return n;
1323   }
1324 }
1325 static gboolean
1326 inf_gtk_browser_store_tree_model_iter_nth_child(GtkTreeModel* model,
1327                                                 GtkTreeIter* iter,
1328                                                 GtkTreeIter* parent,
1329                                                 gint n)
1330 {
1331   InfGtkBrowserStorePrivate* priv;
1332   InfGtkBrowserStoreItem* item;
1333   InfGtkBrowserStoreItem* cur;
1334   InfBrowserIter browser_iter;
1335   guint i;
1336   priv = INF_GTK_BROWSER_STORE_PRIVATE(model);
1337   if(parent == NULL)
1338   {
1339     cur = priv-&gt;first_item;
1340     if(cur == NULL) return FALSE;
1341     for(i = 0; i &lt; (guint)n; ++ i)
1342     {
1343       cur = cur-&gt;next;
1344       if(cur == NULL) return FALSE;
1345     }
1346     iter-&gt;stamp = priv-&gt;stamp;
1347     iter-&gt;user_data = cur;
1348     iter-&gt;user_data2 = GUINT_TO_POINTER(0);
1349     iter-&gt;user_data3 = NULL;
1350     return TRUE;
1351   }
1352   else
1353   {
1354     g_assert(parent-&gt;stamp == priv-&gt;stamp);
1355     item = (InfGtkBrowserStoreItem*)parent-&gt;user_data;
1356     browser_iter.node_id = GPOINTER_TO_UINT(parent-&gt;user_data2);
1357     if(browser_iter.node_id == 0)
1358       inf_browser_get_root(item-&gt;browser, &amp;browser_iter);
1359     else
1360       browser_iter.node = parent-&gt;user_data3;
1361     g_assert(
1362       item-&gt;missing == NULL || browser_iter.node_id == 0 ||
1363       browser_iter.node != item-&gt;missing
1364     );
1365     if(item-&gt;missing != NULL &amp;&amp; browser_iter.node == item-&gt;missing)
1366       return FALSE;
1367     if(inf_browser_get_explored(item-&gt;browser, &amp;browser_iter) == FALSE)
1368       return FALSE;
1369     if(inf_browser_get_child(item-&gt;browser, &amp;browser_iter) == FALSE)
1370       return FALSE;
1371     if(browser_iter.node == item-&gt;missing)
1372       ++n;
1373     for(i = 0; i &lt; (guint)n; ++ i)
1374     {
1375       if(inf_browser_get_next(item-&gt;browser, &amp;browser_iter) == FALSE)
1376         return FALSE;
1377       if(browser_iter.node == item-&gt;missing)
1378         ++n;
1379     }
1380     iter-&gt;stamp = priv-&gt;stamp;
1381     iter-&gt;user_data = item;
1382     iter-&gt;user_data2 = GUINT_TO_POINTER(browser_iter.node_id);
1383     iter-&gt;user_data3 = browser_iter.node;
1384     return TRUE;
1385   }
1386 }
1387 static gboolean
1388 inf_gtk_browser_store_tree_model_iter_parent(GtkTreeModel* model,
1389                                              GtkTreeIter* iter,
1390                                              GtkTreeIter* child)
1391 {
1392   InfGtkBrowserStorePrivate* priv;
1393   InfGtkBrowserStoreItem* item;
1394   InfBrowserIter browser_iter;
1395   gboolean result;
1396   priv = INF_GTK_BROWSER_STORE_PRIVATE(model);
1397   g_assert(child-&gt;stamp == priv-&gt;stamp);
1398   item = (InfGtkBrowserStoreItem*)child-&gt;user_data;
1399   browser_iter.node_id = GPOINTER_TO_UINT(child-&gt;user_data2);
1400   browser_iter.node = child-&gt;user_data3;
1401   if(browser_iter.node == NULL)
1402     return FALSE;
1403   g_assert(browser_iter.node != item-&gt;missing);
1404   result = inf_browser_get_parent(item-&gt;browser, &amp;browser_iter);
1405   g_assert(result == TRUE);
1406   g_assert(browser_iter.node != item-&gt;missing);
1407   iter-&gt;stamp = priv-&gt;stamp;
1408   iter-&gt;user_data = item;
1409   iter-&gt;user_data2 = GUINT_TO_POINTER(browser_iter.node_id);
1410   iter-&gt;user_data3 = browser_iter.node;
1411   if(browser_iter.node_id == 0)
1412     iter-&gt;user_data3 = NULL;
1413   return TRUE;
1414 }
1415 static void
1416 inf_gtk_browser_store_browser_model_set_browser(InfGtkBrowserModel* model,
1417                                                 GtkTreePath* path,
1418                                                 GtkTreeIter* tree_iter,
1419                                                 InfBrowser* old_browser,
1420                                                 InfBrowser* new_browser)
1421 {
1422   InfGtkBrowserStorePrivate* priv;
1423   InfGtkBrowserStoreItem* item;
1424   InfBrowserIter iter;
1425   guint n;
1426   gboolean had_children;
1427   InfBrowserStatus status;
1428   priv = INF_GTK_BROWSER_STORE_PRIVATE(model);
1429   had_children = FALSE;
1430   item = (InfGtkBrowserStoreItem*)tree_iter-&gt;user_data;
1431   g_assert(tree_iter-&gt;user_data3 == NULL);
1432   if(item-&gt;browser != NULL)
1433   {
1434     g_assert(item-&gt;browser == old_browser);
1435     g_object_get(G_OBJECT(item-&gt;browser), "status", &amp;status, NULL);
1436     if(status == INF_BROWSER_OPEN)
1437     {
1438       inf_browser_get_root(item-&gt;browser, &amp;iter);
1439       if(inf_browser_get_explored(item-&gt;browser, &amp;iter) &amp;&amp;
1440          inf_browser_get_child(item-&gt;browser, &amp;iter))
1441       {
1442         n = 1;
1443         while(inf_browser_get_next(item-&gt;browser, &amp;iter))
1444           ++ n;
1445         gtk_tree_path_append_index(path, n);
1446         for(; n &gt; 0; -- n)
1447         {
1448           had_children = TRUE;
1449           gtk_tree_path_prev(path);
1450           gtk_tree_model_row_deleted(GTK_TREE_MODEL(model), path);
1451         }
1452         gtk_tree_path_up(path);
1453       }
1454     }
1455     while(item-&gt;requests != NULL)
1456       inf_gtk_browser_store_item_request_remove(item, item-&gt;requests-&gt;data);
1457     g_hash_table_remove_all(item-&gt;node_errors);
1458     inf_signal_handlers_disconnect_by_func(
1459       G_OBJECT(item-&gt;browser),
1460       G_CALLBACK(inf_gtk_browser_store_browser_error_cb),
1461       model
1462     );
1463     inf_signal_handlers_disconnect_by_func(
1464       G_OBJECT(item-&gt;browser),
1465       G_CALLBACK(inf_gtk_browser_store_browser_notify_status_cb),
1466       model
1467     );
1468     inf_signal_handlers_disconnect_by_func(
1469       G_OBJECT(item-&gt;browser),
1470       G_CALLBACK(inf_gtk_browser_store_node_added_cb),
1471       model
1472     );
1473     inf_signal_handlers_disconnect_by_func(
1474       G_OBJECT(item-&gt;browser),
1475       G_CALLBACK(inf_gtk_browser_store_node_removed_cb),
1476       model
1477     );
1478     inf_signal_handlers_disconnect_by_func(
1479       G_OBJECT(item-&gt;browser),
1480       G_CALLBACK(inf_gtk_browser_store_begin_request_explore_node_cb),
1481       model
1482     );
1483     inf_signal_handlers_disconnect_by_func(
1484       G_OBJECT(item-&gt;browser),
1485       G_CALLBACK(inf_gtk_browser_store_begin_request_subscribe_session_cb),
1486       model
1487     );
1488     g_object_unref(G_OBJECT(item-&gt;browser));
1489   }
1490   item-&gt;browser = NULL;
1491   if(had_children)
1492   {
1493     gtk_tree_model_row_has_child_toggled(
1494       GTK_TREE_MODEL(model),
1495       path,
1496       tree_iter
1497     );
1498   }
1499   item-&gt;browser = new_browser;
1500   if(new_browser != NULL)
1501   {
1502     g_object_ref(new_browser);
1503     g_signal_connect(
1504       G_OBJECT(item-&gt;browser),
1505       "error",
1506       G_CALLBACK(inf_gtk_browser_store_browser_error_cb),
1507       model
1508     );
1509     g_signal_connect(
1510       G_OBJECT(item-&gt;browser),
1511       "notify::status",
1512       G_CALLBACK(inf_gtk_browser_store_browser_notify_status_cb),
1513       model
1514     );
1515     g_signal_connect_after(
1516       G_OBJECT(item-&gt;browser),
1517       "node-added",
1518       G_CALLBACK(inf_gtk_browser_store_node_added_cb),
1519       model
1520     );
1521     g_signal_connect_after(
1522       G_OBJECT(item-&gt;browser),
1523       "node-removed",
1524       G_CALLBACK(inf_gtk_browser_store_node_removed_cb),
1525       model
1526     );
1527     g_signal_connect_after(
1528       G_OBJECT(item-&gt;browser),
1529       "begin-request::explore-node",
1530       G_CALLBACK(inf_gtk_browser_store_begin_request_explore_node_cb),
1531       model
1532     );
1533     g_signal_connect_after(
1534       G_OBJECT(item-&gt;browser),
1535       "begin-request::subscribe-session",
1536       G_CALLBACK(inf_gtk_browser_store_begin_request_subscribe_session_cb),
1537       model
1538     );
1539   }
1540   if(item-&gt;browser == NULL &amp;&amp; item-&gt;info == NULL &amp;&amp;
1541      (item-&gt;error == NULL || item-&gt;status != INF_GTK_BROWSER_MODEL_ERROR))
1542   {
1543     g_assert(item-&gt;status != INF_GTK_BROWSER_MODEL_ERROR);
1544     if(item-&gt;error != NULL)
1545     {
1546       g_error_free(item-&gt;error);
1547       item-&gt;error = NULL;
1548     }
1549     item-&gt;status = INF_GTK_BROWSER_MODEL_INVALID;
1550   }
1551   else if(item-&gt;status != INF_GTK_BROWSER_MODEL_ERROR)
1552   {
1553     if(item-&gt;browser != NULL)
1554     {
1555       g_object_get(G_OBJECT(item-&gt;browser), "status", &amp;status, NULL);
1556       switch(status)
1557       {
1558       case INF_BROWSER_CLOSED:
1559         item-&gt;status = INF_GTK_BROWSER_MODEL_DISCONNECTED;
1560         break;
1561       case INF_BROWSER_OPENING:
1562         item-&gt;status = INF_GTK_BROWSER_MODEL_CONNECTING;
1563         break;
1564       case INF_BROWSER_OPEN:
1565         item-&gt;status = INF_GTK_BROWSER_MODEL_CONNECTED;
1566         break;
1567       default:
1568         g_assert_not_reached();
1569         break;
1570       }
1571     }
1572     else
1573     {
1574       g_assert(item-&gt;info != NULL);
1575       item-&gt;status = INF_GTK_BROWSER_MODEL_DISCOVERED;
1576     }
1577   }
1578   else
1579   {
1580     g_assert(item-&gt;error != NULL);
1581   }
1582   gtk_tree_model_row_changed(GTK_TREE_MODEL(model), path, tree_iter);
1583   if(item-&gt;browser != NULL &amp;&amp; item-&gt;status == INF_GTK_BROWSER_MODEL_CONNECTED)
1584   {
1585     inf_browser_get_root(item-&gt;browser, &amp;iter);
1586     if(inf_browser_get_explored(item-&gt;browser, &amp;iter) &amp;&amp;
1587        inf_browser_get_child(item-&gt;browser, &amp;iter))
1588     {
1589       gtk_tree_model_row_has_child_toggled(
1590         GTK_TREE_MODEL(model),
1591         path,
1592         tree_iter
1593       );
1594     }
1595   }
1596 }
1597 static void
1598 inf_gtk_browser_store_browser_model_resolve(InfGtkBrowserModel* model,
1599                                             InfDiscovery* discovery,
1600                                             InfDiscoveryInfo* info)
1601 {
1602   InfGtkBrowserStorePrivate* priv;
1603   InfGtkBrowserStoreItem* item;
1604   GtkTreeIter tree_iter;
1605   GtkTreePath* path;
1606   g_assert(INF_GTK_IS_BROWSER_STORE(model));
1607   priv = INF_GTK_BROWSER_STORE_PRIVATE(model);
1608   item = inf_gtk_browser_store_find_item_by_discovery_info(
1609     INF_GTK_BROWSER_STORE(model),
1610     info
1611   );
1612   g_assert(item != NULL);
1613   g_assert(
1614     item-&gt;status == INF_GTK_BROWSER_MODEL_DISCOVERED ||
1615     item-&gt;status == INF_GTK_BROWSER_MODEL_ERROR
1616   );
1617   if(item-&gt;status == INF_GTK_BROWSER_MODEL_ERROR)
1618   {
1619     g_assert(item-&gt;error != NULL);
1620     g_error_free(item-&gt;error);
1621     item-&gt;error = NULL;
1622     item-&gt;status = INF_GTK_BROWSER_MODEL_RESOLVING;
1623   }
1624   else
1625   {
1626     item-&gt;status = INF_GTK_BROWSER_MODEL_RESOLVING;
1627   }
1628   tree_iter.stamp = priv-&gt;stamp;
1629   tree_iter.user_data = item;
1630   tree_iter.user_data2 = GUINT_TO_POINTER(0);
1631   tree_iter.user_data3 = NULL;
1632   path = gtk_tree_model_get_path(GTK_TREE_MODEL(model), &amp;tree_iter);
1633   gtk_tree_model_row_changed(GTK_TREE_MODEL(model), path, &amp;tree_iter);
1634   gtk_tree_path_free(path);
1635   inf_discovery_resolve(
1636     discovery,
1637     info,
1638     inf_gtk_browser_store_resolv_complete_func,
1639     model
1640   );
1641 }
1642 static gboolean
1643 inf_gtk_browser_store_browser_iter_to_tree_iter(InfGtkBrowserModel* model,
1644                                                 InfBrowser* browser,
1645                                                 const InfBrowserIter* iter,
1646                                                 GtkTreeIter* tree_iter)
1647 {
1648   InfGtkBrowserStorePrivate* priv;
1649   InfGtkBrowserStoreItem* item;
1650   g_assert(INF_GTK_IS_BROWSER_STORE(model));
1651   priv = INF_GTK_BROWSER_STORE_PRIVATE(model);
1652   item = inf_gtk_browser_store_find_item_by_browser(
1653     INF_GTK_BROWSER_STORE(model),
1654     browser
1655   );
1656   if(item == NULL || (iter != NULL &amp;&amp; item-&gt;missing == iter-&gt;node))
1657     return FALSE;
1658   tree_iter-&gt;stamp = priv-&gt;stamp;
1659   tree_iter-&gt;user_data = item;
1660   if(iter != NULL &amp;&amp; iter-&gt;node_id != 0)
1661   {
1662     tree_iter-&gt;user_data2 = GUINT_TO_POINTER(iter-&gt;node_id);
1663     tree_iter-&gt;user_data3 = iter-&gt;node;
1664   }
1665   else
1666   {
1667     tree_iter-&gt;user_data2 = 0;
1668     tree_iter-&gt;user_data3 = NULL;
1669   }
1670   return TRUE;
1671 }
1672 static void
1673 inf_gtk_browser_store_class_init(InfGtkBrowserStoreClass* browser_store_class)
1674 {
1675   GObjectClass* object_class;
1676   object_class = G_OBJECT_CLASS(browser_store_class);
1677   object_class-&gt;dispose = inf_gtk_browser_store_dispose;
1678   object_class-&gt;set_property = inf_gtk_browser_store_set_property;
1679   object_class-&gt;get_property = inf_gtk_browser_store_get_property;
1680   g_object_class_install_property(
1681     object_class,
1682     PROP_IO,
1683     g_param_spec_object(
1684       "io",
1685       "IO",
1686       "The IO object used for the created browsers to schedule timeouts",
1687       INF_TYPE_IO,
1688       G_PARAM_READWRITE | G_PARAM_CONSTRUCT_ONLY
1689     )
1690   );
1691   g_object_class_install_property(
1692     object_class,
1693     PROP_COMMUNICATION_MANAGER,
1694     g_param_spec_object(
1695       "communication-manager",
1696       "Communication manager", 
1697       "The communication manager used for browsing remote directories",
1698       INF_COMMUNICATION_TYPE_MANAGER,
1699 <a name="5"></a>      G_PARAM_READWRITE | G_PARAM_CONSTRUCT_ONLY
1700     )
1701   );
1702 <font color="#151b8d"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>}
1703 static void
1704 inf_gtk_browser_store_tree_model_iface_init(GtkTreeModelIface* iface)
1705 {
1706   iface-&gt;get_flags = inf_gtk_browser_store_tree_model_get_flags;
1707   iface-&gt;get_n_columns = inf_gtk_browser_store_tree_model_get_n_columns;
1708   iface-&gt;get_column_type = inf_gtk_browser_store_tree_model_get_column_type;
1709   iface-&gt;get_iter = inf_gtk_browser_store_tree_model_get_iter;
1710   iface-&gt;get_path = inf_gtk_browser_store_tree_model_get_path;
1711   iface-&gt;get_value = inf_gtk_browser_store_tree_model_get_value;
1712   iface-&gt;iter_next = inf_gtk_browser_store_tree_model_iter_next;
1713   iface-&gt;iter_children = inf_gtk_browser_store_tree_model_iter_children;
1714   iface-&gt;iter_has_child = inf_gtk_browser_store_tree_model_iter_has_child;
1715   iface-&gt;iter_n_children = inf_gtk_browser_store_tree_model_iter_n_children;</b></font>
1716   iface-&gt;iter_nth_child = inf_gtk_browser_store_tree_model_iter_nth_child;
1717   iface-&gt;iter_parent = inf_gtk_browser_store_tree_model_iter_parent;
1718 }
1719 static void
1720 inf_gtk_browser_store_browser_model_iface_init(
1721   InfGtkBrowserModelInterface* iface)
1722 {
1723   iface-&gt;set_browser = inf_gtk_browser_store_browser_model_set_browser;
1724   iface-&gt;resolve = inf_gtk_browser_store_browser_model_resolve;
1725   iface-&gt;browser_iter_to_tree_iter =
1726     inf_gtk_browser_store_browser_iter_to_tree_iter;
1727 }
1728 InfGtkBrowserStore*
1729 inf_gtk_browser_store_new(InfIo* io,
1730                           InfCommunicationManager* comm_manager)
1731 {
1732   GObject* object;
1733   object = g_object_new(
1734     INF_GTK_TYPE_BROWSER_STORE,
1735     "io", io,
1736     "communication-manager", comm_manager,
1737     NULL
1738   );
1739   return INF_GTK_BROWSER_STORE(object);
1740 }
1741 void
1742 inf_gtk_browser_store_add_discovery(InfGtkBrowserStore* store,
1743                                     InfDiscovery* discovery)
1744 {
1745   InfGtkBrowserStorePrivate* priv;
1746   GSList* discovered;
1747   GSList* item;
1748   InfDiscoveryInfo* info;
1749   g_return_if_fail(INF_GTK_IS_BROWSER_STORE(store));
1750   g_return_if_fail(INF_IS_DISCOVERY(discovery));
1751   priv = INF_GTK_BROWSER_STORE_PRIVATE(store);
1752   g_return_if_fail(g_slist_find(priv-&gt;discoveries, discovery) == NULL);
1753   g_object_ref(G_OBJECT(discovery));
1754   priv-&gt;discoveries = g_slist_prepend(priv-&gt;discoveries, discovery);
1755   g_signal_connect(
1756     G_OBJECT(discovery),
1757     "discovered",
1758     G_CALLBACK(inf_gtk_browser_store_discovered_cb),
1759     store
1760   );
1761   g_signal_connect(
1762     G_OBJECT(discovery),
1763     "undiscovered",
1764     G_CALLBACK(inf_gtk_browser_store_undiscovered_cb),
1765     store
1766   );
1767   discovered = inf_discovery_get_discovered(discovery, "_infinote._tcp");
1768   for(item = discovered; item != NULL; item = g_slist_next(item))
1769   {
1770     info = (InfDiscoveryInfo*)item-&gt;data;
1771     inf_gtk_browser_store_add_item_by_browser(
1772       store,
1773       discovery,
1774       info,
1775       NULL,
1776       inf_discovery_info_get_service_name(discovery, info)
1777     );
1778   }
1779   g_slist_free(discovered);
1780   inf_discovery_discover(discovery, "_infinote._tcp");
1781 }
1782 InfBrowser*
1783 inf_gtk_browser_store_add_connection(InfGtkBrowserStore* store,
1784                                      InfXmlConnection* connection,
1785                                      const gchar* name)
1786 {
1787   InfGtkBrowserStorePrivate* priv;
1788   InfGtkBrowserStoreItem* item;
1789   gchar* remote_id;
1790   g_return_val_if_fail(INF_GTK_IS_BROWSER_STORE(store), NULL);
1791   g_return_val_if_fail(INF_IS_XML_CONNECTION(connection), NULL);
1792   priv = INF_GTK_BROWSER_STORE_PRIVATE(store);
1793   item = inf_gtk_browser_store_find_item_by_connection(store, connection);
1794   if(item == NULL)
1795   {
1796     if(name == NULL)
1797     {
1798       g_object_get(G_OBJECT(connection), "remote-id", &amp;remote_id, NULL);
1799       item = inf_gtk_browser_store_add_item_by_connection(
1800         store,
1801         NULL,
1802         NULL,
1803         connection,
1804         remote_id
1805       );
1806     }
1807     else
1808     {
1809       item = inf_gtk_browser_store_add_item_by_connection(
1810         store,
1811         NULL,
1812         NULL,
1813         connection,
1814         g_strdup(name)
1815       );
1816     }
1817   }
1818   return item-&gt;browser;
1819 }
1820 void
1821 inf_gtk_browser_store_add_browser(InfGtkBrowserStore* store,
1822                                   InfBrowser* browser,
1823                                   const gchar* name)
1824 {
1825   InfGtkBrowserStorePrivate* priv;
1826   InfGtkBrowserStoreItem* item;
1827   g_return_if_fail(INF_GTK_IS_BROWSER_STORE(store));
1828   g_return_if_fail(INF_IS_BROWSER(browser));
1829   g_return_if_fail(name != NULL);
1830   priv = INF_GTK_BROWSER_STORE_PRIVATE(store);
1831   item = inf_gtk_browser_store_find_item_by_browser(store, browser);
1832   if(item == NULL)
1833   {
1834     inf_gtk_browser_store_add_item_by_browser(
1835       store,
1836       NULL,
1837       NULL,
1838       browser,
1839       g_strdup(name)
1840     );
1841   }
1842 }
1843 void
1844 inf_gtk_browser_store_remove_browser(InfGtkBrowserStore* store,
1845                                      InfBrowser* browser)
1846 {
1847   InfGtkBrowserStoreItem* item;
1848   g_return_if_fail(INF_GTK_IS_BROWSER_STORE(store));
1849   g_return_if_fail(INF_IS_BROWSER(browser));
1850   item = inf_gtk_browser_store_find_item_by_browser(store, browser);
1851   g_return_if_fail(item != NULL);
1852   inf_gtk_browser_store_remove_item (store, item);
1853 }
1854 void
1855 inf_gtk_browser_store_remove_connection(InfGtkBrowserStore* store,
1856                                         InfXmlConnection* connection)
1857 {
1858   InfGtkBrowserStoreItem* item;
1859   g_return_if_fail(INF_GTK_IS_BROWSER_STORE(store));
1860   g_return_if_fail(INF_IS_XML_CONNECTION(connection));
1861   item = inf_gtk_browser_store_find_item_by_connection(store, connection);
1862   g_return_if_fail(item != NULL);
1863   inf_gtk_browser_store_remove_item (store, item);
1864 }
1865 void
1866 inf_gtk_browser_store_clear_connection_error(InfGtkBrowserStore* store,
1867                                              InfXmlConnection* connection)
1868 {
1869   InfGtkBrowserStoreItem* item;
1870   InfBrowserStatus status;
1871   GtkTreeIter iter;
1872   GtkTreePath* path;
1873   g_return_if_fail(INF_GTK_IS_BROWSER_STORE(store));
1874   g_return_if_fail(INF_IS_XML_CONNECTION(connection));
1875   item = inf_gtk_browser_store_find_item_by_connection(store, connection);
1876   g_return_if_fail(item != NULL);
1877   if(item-&gt;status == INF_GTK_BROWSER_MODEL_ERROR)
1878   {
1879     g_assert(item-&gt;error != NULL);
1880     g_error_free(item-&gt;error);
1881     item-&gt;error = NULL;
1882     if(item-&gt;browser != NULL)
1883     {
1884       g_object_get(G_OBJECT(item-&gt;browser), "status", &amp;status, NULL);
1885       switch(status)
1886       {
1887       case INF_BROWSER_CLOSED:
1888         item-&gt;status = INF_GTK_BROWSER_MODEL_DISCONNECTED;
1889         break;
1890       case INF_BROWSER_OPENING:
1891         item-&gt;status = INF_GTK_BROWSER_MODEL_CONNECTING;
1892         break;
1893       case INF_BROWSER_OPEN:
1894         item-&gt;status = INF_GTK_BROWSER_MODEL_CONNECTED;
1895         break;
1896       default:
1897         g_assert_not_reached();
1898         break;
1899       }
1900     }
1901     else if(item-&gt;info != NULL)
1902     {
1903       item-&gt;status = INF_GTK_BROWSER_MODEL_DISCOVERED;
1904     }
1905     else
1906     {
1907       g_assert_not_reached();
1908     }
1909     iter.stamp = INF_GTK_BROWSER_STORE_PRIVATE(store)-&gt;stamp;
1910     iter.user_data = item;
1911     iter.user_data2 = GUINT_TO_POINTER(0);
1912     iter.user_data3 = NULL;
1913     path = gtk_tree_model_get_path(GTK_TREE_MODEL(store), &amp;iter);
1914     gtk_tree_model_row_changed(GTK_TREE_MODEL(store), path, &amp;iter);
1915     gtk_tree_path_free (path);
1916   }
1917 }
1918 void
1919 inf_gtk_browser_store_set_connection_name(InfGtkBrowserStore* store,
1920                                           InfXmlConnection* connection,
1921                                           const gchar* name)
1922 {
1923   InfGtkBrowserStoreItem* item;
1924   GtkTreeIter iter;
1925   GtkTreePath* path;
1926   g_return_if_fail(INF_GTK_IS_BROWSER_STORE(store));
1927   g_return_if_fail(INF_IS_XML_CONNECTION(connection));
1928   g_return_if_fail(name != NULL);
1929   item = inf_gtk_browser_store_find_item_by_connection(store, connection);
1930   g_return_if_fail(item != NULL);
1931   g_free (item-&gt;name);
1932   item-&gt;name = g_strdup(name);
1933   iter.stamp = INF_GTK_BROWSER_STORE_PRIVATE(store)-&gt;stamp;
1934   iter.user_data = item;
1935   iter.user_data2 = GUINT_TO_POINTER(0);
1936   iter.user_data3 = NULL;
1937   path = gtk_tree_model_get_path(GTK_TREE_MODEL(store), &amp;iter);
1938   gtk_tree_model_row_changed(GTK_TREE_MODEL(store), path, &amp;iter);
1939   gtk_tree_path_free(path);
1940 }
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
