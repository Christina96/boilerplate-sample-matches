
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 16, <button onclick='openModal()' class='match'>CODE CLONE</button></h2>
        <div class="column">
            <h3>PINRemoteImage-MDEwOlJlcG9zaXRvcnkzOTUzNzEwMw==-flat-webpmux.c</h3>
            <pre><code>1  #ifdef HAVE_CONFIG_H
2  #include &quot;webp/config.h&quot;
3  #endif
4  #include &lt;assert.h&gt;
5  #include &lt;stdio.h&gt;
6  #include &lt;stdlib.h&gt;
7  #include &lt;string.h&gt;
8  #include &quot;webp/decode.h&quot;
9  #include &quot;webp/mux.h&quot;
10  #include &quot;../examples/example_util.h&quot;
11  #include &quot;../imageio/imageio_util.h&quot;
12  #include &quot;./unicode.h&quot;
13  typedef enum {
14    NIL_ACTION = 0,
15    ACTION_GET,
16    ACTION_SET,
17    ACTION_STRIP,
18    ACTION_INFO,
19    ACTION_HELP,
20    ACTION_DURATION
21  } ActionType;
22  typedef enum {
23    NIL_SUBTYPE = 0,
24    SUBTYPE_ANMF,
25    SUBTYPE_LOOP,
26    SUBTYPE_BGCOLOR
27  } FeatureSubType;
28  typedef struct {
29    FeatureSubType subtype_;
30    const char* filename_;
31    const char* params_;
32  } FeatureArg;
33  typedef enum {
34    NIL_FEATURE = 0,
35    FEATURE_EXIF,
36    FEATURE_XMP,
37    FEATURE_ICCP,
38    FEATURE_ANMF,
39    FEATURE_DURATION,
40    LAST_FEATURE
41  } FeatureType;
42  static const char* const kFourccList[LAST_FEATURE] = {
43    NULL, &quot;EXIF&quot;, &quot;XMP &quot;, &quot;ICCP&quot;, &quot;ANMF&quot;
44  };
45  static const char* const kDescriptions[LAST_FEATURE] = {
46    NULL, &quot;EXIF metadata&quot;, &quot;XMP metadata&quot;, &quot;ICC profile&quot;,
47    &quot;Animation frame&quot;
48  };
49  typedef struct {
50    CommandLineArguments cmd_args_;
51    ActionType action_type_;
52    const char* input_;
53    const char* output_;
54    FeatureType type_;
55    FeatureArg* args_;
56    int arg_count_;
57  } Config;
58  static int CountOccurrences(const CommandLineArguments* const args,
59                              const char* const arg) {
60    int i;
61    int num_occurences = 0;
62    for (i = 0; i &lt; args-&gt;argc_; ++i) {
63      if (!strcmp(args-&gt;argv_[i], arg)) {
64        ++num_occurences;
65      }
66    }
67    return num_occurences;
68  }
69  static const char* const kErrorMessages[-WEBP_MUX_NOT_ENOUGH_DATA + 1] = {
70    &quot;WEBP_MUX_NOT_FOUND&quot;, &quot;WEBP_MUX_INVALID_ARGUMENT&quot;, &quot;WEBP_MUX_BAD_DATA&quot;,
71    &quot;WEBP_MUX_MEMORY_ERROR&quot;, &quot;WEBP_MUX_NOT_ENOUGH_DATA&quot;
72  };
73  static const char* ErrorString(WebPMuxError err) {
74    assert(err &lt;= WEBP_MUX_NOT_FOUND &amp;&amp; err &gt;= WEBP_MUX_NOT_ENOUGH_DATA);
75    return kErrorMessages[-err];
76  }
77  #define RETURN_IF_ERROR(ERR_MSG)                                     \
78    if (err != WEBP_MUX_OK) {                                          \
79      fprintf(stderr, ERR_MSG);                                        \
80      return err;                                                      \
81    }
82  #define RETURN_IF_ERROR3(ERR_MSG, FORMAT_STR1, FORMAT_STR2)          \
83    if (err != WEBP_MUX_OK) {                                          \
84      fprintf(stderr, ERR_MSG, FORMAT_STR1, FORMAT_STR2);              \
85      return err;                                                      \
86    }
87  #define ERROR_GOTO1(ERR_MSG, LABEL)                                  \
88    do {                                                               \
89      fprintf(stderr, ERR_MSG);                                        \
90      ok = 0;                                                          \
91      goto LABEL;                                                      \
92    } while (0)
93  #define ERROR_GOTO2(ERR_MSG, FORMAT_STR, LABEL)                      \
94    do {                                                               \
95      fprintf(stderr, ERR_MSG, FORMAT_STR);                            \
96      ok = 0;                                                          \
97      goto LABEL;                                                      \
98    } while (0)
99  #define ERROR_GOTO3(ERR_MSG, FORMAT_STR1, FORMAT_STR2, LABEL)        \
100    do {                                                               \
101      fprintf(stderr, ERR_MSG, FORMAT_STR1, FORMAT_STR2);              \
102      ok = 0;                                                          \
103      goto LABEL;                                                      \
104    } while (0)
105  static WebPMuxError DisplayInfo(const WebPMux* mux) {
106    int width, height;
107    uint32_t flag;
108    WebPMuxError err = WebPMuxGetCanvasSize(mux, &amp;width, &amp;height);
<span onclick='openModal()' class='match'>109    assert(err == WEBP_MUX_OK);  
110    printf(&quot;Canvas size: %d x %d\n&quot;, width, height);
111    err = WebPMuxGetFeatures(mux, &amp;flag);
</span>112    RETURN_IF_ERROR(&quot;Failed to retrieve features\n&quot;);
113    if (flag == 0) {
114      printf(&quot;No features present.\n&quot;);
115      return err;
116    }
117    printf(&quot;Features present:&quot;);
118    if (flag &amp; ANIMATION_FLAG) printf(&quot; animation&quot;);
119    if (flag &amp; ICCP_FLAG)      printf(&quot; ICC profile&quot;);
120    if (flag &amp; EXIF_FLAG)      printf(&quot; EXIF metadata&quot;);
121    if (flag &amp; XMP_FLAG)       printf(&quot; XMP metadata&quot;);
122    if (flag &amp; ALPHA_FLAG)     printf(&quot; transparency&quot;);
123    printf(&quot;\n&quot;);
124    if (flag &amp; ANIMATION_FLAG) {
125      const WebPChunkId id = WEBP_CHUNK_ANMF;
126      const char* const type_str = &quot;frame&quot;;
127      int nFrames;
128      WebPMuxAnimParams params;
129      err = WebPMuxGetAnimationParams(mux, &amp;params);
130      assert(err == WEBP_MUX_OK);
131      printf(&quot;Background color : 0x%.8X  Loop Count : %d\n&quot;,
132             params.bgcolor, params.loop_count);
133      err = WebPMuxNumChunks(mux, id, &amp;nFrames);
134      assert(err == WEBP_MUX_OK);
135      printf(&quot;Number of %ss: %d\n&quot;, type_str, nFrames);
136      if (nFrames &gt; 0) {
137        int i;
138        printf(&quot;No.: width height alpha x_offset y_offset &quot;);
139        printf(&quot;duration   dispose blend &quot;);
140        printf(&quot;image_size  compression\n&quot;);
141        for (i = 1; i &lt;= nFrames; i++) {
142          WebPMuxFrameInfo frame;
143          err = WebPMuxGetFrame(mux, i, &amp;frame);
144          if (err == WEBP_MUX_OK) {
145            WebPBitstreamFeatures features;
146            const VP8StatusCode status = WebPGetFeatures(
147                frame.bitstream.bytes, frame.bitstream.size, &amp;features);
148            assert(status == VP8_STATUS_OK);  
149            (void)status;
150            printf(&quot;%3d: %5d %5d %5s %8d %8d &quot;, i, features.width,
151                   features.height, features.has_alpha ? &quot;yes&quot; : &quot;no&quot;,
152                   frame.x_offset, frame.y_offset);
153            {
154              const char* const dispose =
155                  (frame.dispose_method == WEBP_MUX_DISPOSE_NONE) ? &quot;none&quot;
156                                                                  : &quot;background&quot;;
157              const char* const blend =
158                  (frame.blend_method == WEBP_MUX_BLEND) ? &quot;yes&quot; : &quot;no&quot;;
159              printf(&quot;%8d %10s %5s &quot;, frame.duration, dispose, blend);
160            }
161            printf(&quot;%10d %11s\n&quot;, (int)frame.bitstream.size,
162                   (features.format == 1) ? &quot;lossy&quot; :
163                   (features.format == 2) ? &quot;lossless&quot; :
164                                            &quot;undefined&quot;);
165          }
166          WebPDataClear(&amp;frame.bitstream);
167          RETURN_IF_ERROR3(&quot;Failed to retrieve %s#%d\n&quot;, type_str, i);
168        }
169      }
170    }
171    if (flag &amp; ICCP_FLAG) {
172      WebPData icc_profile;
173      err = WebPMuxGetChunk(mux, &quot;ICCP&quot;, &amp;icc_profile);
174      assert(err == WEBP_MUX_OK);
175      printf(&quot;Size of the ICC profile data: %d\n&quot;, (int)icc_profile.size);
176    }
177    if (flag &amp; EXIF_FLAG) {
178      WebPData exif;
179      err = WebPMuxGetChunk(mux, &quot;EXIF&quot;, &amp;exif);
180      assert(err == WEBP_MUX_OK);
181      printf(&quot;Size of the EXIF metadata: %d\n&quot;, (int)exif.size);
182    }
183    if (flag &amp; XMP_FLAG) {
184      WebPData xmp;
185      err = WebPMuxGetChunk(mux, &quot;XMP &quot;, &amp;xmp);
186      assert(err == WEBP_MUX_OK);
187      printf(&quot;Size of the XMP metadata: %d\n&quot;, (int)xmp.size);
188    }
189    if ((flag &amp; ALPHA_FLAG) &amp;&amp; !(flag &amp; ANIMATION_FLAG)) {
190      WebPMuxFrameInfo image;
191      err = WebPMuxGetFrame(mux, 1, &amp;image);
192      if (err == WEBP_MUX_OK) {
193        printf(&quot;Size of the image (with alpha): %d\n&quot;, (int)image.bitstream.size);
194      }
195      WebPDataClear(&amp;image.bitstream);
196      RETURN_IF_ERROR(&quot;Failed to retrieve the image\n&quot;);
197    }
198    return WEBP_MUX_OK;
199  }
200  static void PrintHelp(void) {
201    printf(&quot;Usage: webpmux -get GET_OPTIONS INPUT -o OUTPUT\n&quot;);
202    printf(&quot;       webpmux -set SET_OPTIONS INPUT -o OUTPUT\n&quot;);
203    printf(&quot;       webpmux -duration DURATION_OPTIONS [-duration ...]\n&quot;);
204    printf(&quot;               INPUT -o OUTPUT\n&quot;);
205    printf(&quot;       webpmux -strip STRIP_OPTIONS INPUT -o OUTPUT\n&quot;);
206    printf(&quot;       webpmux -frame FRAME_OPTIONS [-frame...] [-loop LOOP_COUNT]&quot;
207           &quot;\n&quot;);
208    printf(&quot;               [-bgcolor BACKGROUND_COLOR] -o OUTPUT\n&quot;);
209    printf(&quot;       webpmux -info INPUT\n&quot;);
210    printf(&quot;       webpmux [-h|-help]\n&quot;);
211    printf(&quot;       webpmux -version\n&quot;);
212    printf(&quot;       webpmux argument_file_name\n&quot;);
213    printf(&quot;\n&quot;);
214    printf(&quot;GET_OPTIONS:\n&quot;);
215    printf(&quot; Extract relevant data:\n&quot;);
216    printf(&quot;   icc       get ICC profile\n&quot;);
217    printf(&quot;   exif      get EXIF metadata\n&quot;);
218    printf(&quot;   xmp       get XMP metadata\n&quot;);
219    printf(&quot;   frame n   get nth frame\n&quot;);
220    printf(&quot;\n&quot;);
221    printf(&quot;SET_OPTIONS:\n&quot;);
222    printf(&quot; Set color profile/metadata:\n&quot;);
223    printf(&quot;   icc  file.icc     set ICC profile\n&quot;);
224    printf(&quot;   exif file.exif    set EXIF metadata\n&quot;);
225    printf(&quot;   xmp  file.xmp     set XMP metadata\n&quot;);
226    printf(&quot;   where:    &#x27;file.icc&#x27; contains the ICC profile to be set,\n&quot;);
227    printf(&quot;             &#x27;file.exif&#x27; contains the EXIF metadata to be set\n&quot;);
228    printf(&quot;             &#x27;file.xmp&#x27; contains the XMP metadata to be set\n&quot;);
229    printf(&quot;\n&quot;);
230    printf(&quot;DURATION_OPTIONS:\n&quot;);
231    printf(&quot; Set duration of selected frames:\n&quot;);
232    printf(&quot;   duration            set duration for each frames\n&quot;);
233    printf(&quot;   duration,frame      set duration of a particular frame\n&quot;);
234    printf(&quot;   duration,start,end  set duration of frames in the\n&quot;);
235    printf(&quot;                        interval [start,end])\n&quot;);
236    printf(&quot;   where: &#x27;duration&#x27; is the duration in milliseconds\n&quot;);
237    printf(&quot;          &#x27;start&#x27; is the start frame index\n&quot;);
238    printf(&quot;          &#x27;end&#x27; is the inclusive end frame index\n&quot;);
239    printf(&quot;           The special &#x27;end&#x27; value &#x27;0&#x27; means: last frame.\n&quot;);
240    printf(&quot;\n&quot;);
241    printf(&quot;STRIP_OPTIONS:\n&quot;);
242    printf(&quot; Strip color profile/metadata:\n&quot;);
243    printf(&quot;   icc       strip ICC profile\n&quot;);
244    printf(&quot;   exif      strip EXIF metadata\n&quot;);
245    printf(&quot;   xmp       strip XMP metadata\n&quot;);
246    printf(&quot;\n&quot;);
247    printf(&quot;FRAME_OPTIONS(i):\n&quot;);
248    printf(&quot; Create animation:\n&quot;);
249    printf(&quot;   file_i +di+[xi+yi[+mi[bi]]]\n&quot;);
250    printf(&quot;   where:    &#x27;file_i&#x27; is the i&#x27;th animation frame (WebP format),\n&quot;);
251    printf(&quot;             &#x27;di&#x27; is the pause duration before next frame,\n&quot;);
252    printf(&quot;             &#x27;xi&#x27;,&#x27;yi&#x27; specify the image offset for this frame,\n&quot;);
253    printf(&quot;             &#x27;mi&#x27; is the dispose method for this frame (0 or 1),\n&quot;);
254    printf(&quot;             &#x27;bi&#x27; is the blending method for this frame (+b or -b)&quot;
255           &quot;\n&quot;);
256    printf(&quot;\n&quot;);
257    printf(&quot;LOOP_COUNT:\n&quot;);
258    printf(&quot; Number of times to repeat the animation.\n&quot;);
259    printf(&quot; Valid range is 0 to 65535 [Default: 0 (infinite)].\n&quot;);
260    printf(&quot;\n&quot;);
261    printf(&quot;BACKGROUND_COLOR:\n&quot;);
262    printf(&quot; Background color of the canvas.\n&quot;);
263    printf(&quot;  A,R,G,B\n&quot;);
264    printf(&quot;  where:    &#x27;A&#x27;, &#x27;R&#x27;, &#x27;G&#x27; and &#x27;B&#x27; are integers in the range 0 to 255 &quot;
265           &quot;specifying\n&quot;);
266    printf(&quot;            the Alpha, Red, Green and Blue component values &quot;
267           &quot;respectively\n&quot;);
268    printf(&quot;            [Default: 255,255,255,255]\n&quot;);
269    printf(&quot;\nINPUT &amp; OUTPUT are in WebP format.\n&quot;);
270    printf(&quot;\nNote: The nature of EXIF, XMP and ICC data is not checked&quot;);
271    printf(&quot; and is assumed to be\nvalid.\n&quot;);
272    printf(&quot;\nNote: if a single file name is passed as the argument, the &quot;
273           &quot;arguments will be\n&quot;);
274    printf(&quot;tokenized from this file. The file name must not start with &quot;
275           &quot;the character &#x27;-&#x27;.\n&quot;);
276  }
277  static void WarnAboutOddOffset(const WebPMuxFrameInfo* const info) {
278    if ((info-&gt;x_offset | info-&gt;y_offset) &amp; 1) {
279      fprintf(stderr, &quot;Warning: odd offsets will be snapped to even values&quot;
280              &quot; (%d, %d) -&gt; (%d, %d)\n&quot;, info-&gt;x_offset, info-&gt;y_offset,
281              info-&gt;x_offset &amp; ~1, info-&gt;y_offset &amp; ~1);
282    }
283  }
284  static int CreateMux(const char* const filename, WebPMux** mux) {
285    WebPData bitstream;
286    assert(mux != NULL);
287    if (!ExUtilReadFileToWebPData(filename, &amp;bitstream)) return 0;
288    *mux = WebPMuxCreate(&amp;bitstream, 1);
289    WebPDataClear(&amp;bitstream);
290    if (*mux != NULL) return 1;
291    WFPRINTF(stderr, &quot;Failed to create mux object from file %s.\n&quot;,
292             (const W_CHAR*)filename);
293    return 0;
294  }
295  static int WriteData(const char* filename, const WebPData* const webpdata) {
296    int ok = 0;
297    FILE* fout = WSTRCMP(filename, &quot;-&quot;) ? WFOPEN(filename, &quot;wb&quot;)
298                                        : ImgIoUtilSetBinaryMode(stdout);
299    if (fout == NULL) {
300      WFPRINTF(stderr, &quot;Error opening output WebP file %s!\n&quot;,
301               (const W_CHAR*)filename);
302      return 0;
303    }
304    if (fwrite(webpdata-&gt;bytes, webpdata-&gt;size, 1, fout) != 1) {
305      WFPRINTF(stderr, &quot;Error writing file %s!\n&quot;, (const W_CHAR*)filename);
306    } else {
307      WFPRINTF(stderr, &quot;Saved file %s (%d bytes)\n&quot;,
308               (const W_CHAR*)filename, (int)webpdata-&gt;size);
309      ok = 1;
310    }
311    if (fout != stdout) fclose(fout);
312    return ok;
313  }
314  static int WriteWebP(WebPMux* const mux, const char* filename) {
315    int ok;
316    WebPData webp_data;
317    const WebPMuxError err = WebPMuxAssemble(mux, &amp;webp_data);
318    if (err != WEBP_MUX_OK) {
319      fprintf(stderr, &quot;Error (%s) assembling the WebP file.\n&quot;, ErrorString(err));
320      return 0;
321    }
322    ok = WriteData(filename, &amp;webp_data);
323    WebPDataClear(&amp;webp_data);
324    return ok;
325  }
326  static WebPMux* DuplicateMuxHeader(const WebPMux* const mux) {
327    WebPMux* new_mux = WebPMuxNew();
328    WebPMuxAnimParams p;
329    WebPMuxError err;
330    int i;
331    int ok = 1;
332    if (new_mux == NULL) return NULL;
333    err = WebPMuxGetAnimationParams(mux, &amp;p);
334    if (err == WEBP_MUX_OK) {
335      err = WebPMuxSetAnimationParams(new_mux, &amp;p);
336      if (err != WEBP_MUX_OK) {
337        ERROR_GOTO2(&quot;Error (%s) handling animation params.\n&quot;,
338                    ErrorString(err), End);
339      }
340    } else {
341    }
342    for (i = 1; i &lt;= 3; ++i) {
343      WebPData metadata;
344      err = WebPMuxGetChunk(mux, kFourccList[i], &amp;metadata);
345      if (err == WEBP_MUX_OK &amp;&amp; metadata.size &gt; 0) {
346        err = WebPMuxSetChunk(new_mux, kFourccList[i], &amp;metadata, 1);
347        if (err != WEBP_MUX_OK) {
348          ERROR_GOTO1(&quot;Error transferring metadata in DuplicateMux().&quot;, End);
349        }
350      }
351    }
352   End:
353    if (!ok) {
354      WebPMuxDelete(new_mux);
355      new_mux = NULL;
356    }
357    return new_mux;
358  }
359  static int ParseFrameArgs(const char* args, WebPMuxFrameInfo* const info) {
360    int dispose_method, dummy;
361    char plus_minus, blend_method;
362    const int num_args = sscanf(args, &quot;+%d+%d+%d+%d%c%c+%d&quot;, &amp;info-&gt;duration,
363                                &amp;info-&gt;x_offset, &amp;info-&gt;y_offset, &amp;dispose_method,
364                                &amp;plus_minus, &amp;blend_method, &amp;dummy);
365    switch (num_args) {
366      case 1:
367        info-&gt;x_offset = info-&gt;y_offset = 0;  
368      case 3:
369        dispose_method = 0;  
370      case 4:
371        plus_minus = &#x27;+&#x27;;
372        blend_method = &#x27;b&#x27;;  
373      case 6:
374        break;
375      case 2:
376      case 5:
377      default:
378        return 0;
379    }
380    WarnAboutOddOffset(info);
381    info-&gt;dispose_method = (WebPMuxAnimDispose)dispose_method;
382    if (blend_method != &#x27;b&#x27;) return 0;
383    if (plus_minus != &#x27;-&#x27; &amp;&amp; plus_minus != &#x27;+&#x27;) return 0;
384    info-&gt;blend_method =
385        (plus_minus == &#x27;+&#x27;) ? WEBP_MUX_BLEND : WEBP_MUX_NO_BLEND;
386    return 1;
387  }
388  static int ParseBgcolorArgs(const char* args, uint32_t* const bgcolor) {
389    uint32_t a, r, g, b;
390    if (sscanf(args, &quot;%u,%u,%u,%u&quot;, &amp;a, &amp;r, &amp;g, &amp;b) != 4) return 0;
391    if (a &gt;= 256 || r &gt;= 256 || g &gt;= 256 || b &gt;= 256) return 0;
392    *bgcolor = (a &lt;&lt; 24) | (r &lt;&lt; 16) | (g &lt;&lt; 8) | (b &lt;&lt; 0);
393    return 1;
394  }
395  static void DeleteConfig(Config* const config) {
396    if (config != NULL) {
397      free(config-&gt;args_);
398      ExUtilDeleteCommandLineArguments(&amp;config-&gt;cmd_args_);
399      memset(config, 0, sizeof(*config));
400    }
401  }
402  static int ValidateCommandLine(const CommandLineArguments* const cmd_args,
403                                 int* num_feature_args) {
404    int num_frame_args;
405    int num_loop_args;
406    int num_bgcolor_args;
407    int num_durations_args;
408    int ok = 1;
409    assert(num_feature_args != NULL);
410    *num_feature_args = 0;
411    if (CountOccurrences(cmd_args, &quot;-get&quot;) &gt; 1) {
412      ERROR_GOTO1(&quot;ERROR: Multiple &#x27;-get&#x27; arguments specified.\n&quot;, ErrValidate);
413    }
414    if (CountOccurrences(cmd_args, &quot;-set&quot;) &gt; 1) {
415      ERROR_GOTO1(&quot;ERROR: Multiple &#x27;-set&#x27; arguments specified.\n&quot;, ErrValidate);
416    }
417    if (CountOccurrences(cmd_args, &quot;-strip&quot;) &gt; 1) {
418      ERROR_GOTO1(&quot;ERROR: Multiple &#x27;-strip&#x27; arguments specified.\n&quot;, ErrValidate);
419    }
420    if (CountOccurrences(cmd_args, &quot;-info&quot;) &gt; 1) {
421      ERROR_GOTO1(&quot;ERROR: Multiple &#x27;-info&#x27; arguments specified.\n&quot;, ErrValidate);
422    }
423    if (CountOccurrences(cmd_args, &quot;-o&quot;) &gt; 1) {
424      ERROR_GOTO1(&quot;ERROR: Multiple output files specified.\n&quot;, ErrValidate);
425    }
426    num_frame_args = CountOccurrences(cmd_args, &quot;-frame&quot;);
427    num_loop_args = CountOccurrences(cmd_args, &quot;-loop&quot;);
428    num_bgcolor_args = CountOccurrences(cmd_args, &quot;-bgcolor&quot;);
429    num_durations_args = CountOccurrences(cmd_args, &quot;-duration&quot;);
430    if (num_loop_args &gt; 1) {
431      ERROR_GOTO1(&quot;ERROR: Multiple loop counts specified.\n&quot;, ErrValidate);
432    }
433    if (num_bgcolor_args &gt; 1) {
434      ERROR_GOTO1(&quot;ERROR: Multiple background colors specified.\n&quot;, ErrValidate);
435    }
436    if ((num_frame_args == 0) &amp;&amp; (num_loop_args + num_bgcolor_args &gt; 0)) {
437      ERROR_GOTO1(&quot;ERROR: Loop count and background color are relevant only in &quot;
438                  &quot;case of animation.\n&quot;, ErrValidate);
439    }
440    if (num_durations_args &gt; 0 &amp;&amp; num_frame_args != 0) {
441      ERROR_GOTO1(&quot;ERROR: Can not combine -duration and -frame commands.\n&quot;,
442                  ErrValidate);
443    }
444    assert(ok == 1);
445    if (num_durations_args &gt; 0) {
446      *num_feature_args = num_durations_args;
447    } else if (num_frame_args == 0) {
448      *num_feature_args = 1;
449    } else {
450      *num_feature_args = num_frame_args + num_loop_args + num_bgcolor_args;
451    }
452   ErrValidate:
453    return ok;
454  }
455  #define ACTION_IS_NIL (config-&gt;action_type_ == NIL_ACTION)
456  #define FEATURETYPE_IS_NIL (config-&gt;type_ == NIL_FEATURE)
457  #define CHECK_NUM_ARGS_AT_LEAST(NUM, LABEL)                              \
458    if (argc &lt; i + (NUM)) {                                                \
459      fprintf(stderr, &quot;ERROR: Too few arguments for &#x27;%s&#x27;.\n&quot;, argv[i]);    \
460      goto LABEL;                                                          \
461    }
462  #define CHECK_NUM_ARGS_AT_MOST(NUM, LABEL)                               \
463    if (argc &gt; i + (NUM)) {                                                \
464      fprintf(stderr, &quot;ERROR: Too many arguments for &#x27;%s&#x27;.\n&quot;, argv[i]);   \
465      goto LABEL;                                                          \
466    }
467  #define CHECK_NUM_ARGS_EXACTLY(NUM, LABEL)                               \
468    CHECK_NUM_ARGS_AT_LEAST(NUM, LABEL);                                   \
469    CHECK_NUM_ARGS_AT_MOST(NUM, LABEL);
470  static int ParseCommandLine(Config* config, const W_CHAR** const unicode_argv) {
471    int i = 0;
472    int feature_arg_index = 0;
473    int ok = 1;
474    int argc = config-&gt;cmd_args_.argc_;
475    const char* const* argv = config-&gt;cmd_args_.argv_;
476    const char* const* wargv =
477        (unicode_argv != NULL) ? (const char**)(unicode_argv + 1) : argv;
478    while (i &lt; argc) {
479      FeatureArg* const arg = &amp;config-&gt;args_[feature_arg_index];
480      if (argv[i][0] == &#x27;-&#x27;) {  
481        if (!strcmp(argv[i], &quot;-set&quot;)) {
482          if (ACTION_IS_NIL) {
483            config-&gt;action_type_ = ACTION_SET;
484          } else {
485            ERROR_GOTO1(&quot;ERROR: Multiple actions specified.\n&quot;, ErrParse);
486          }
487          ++i;
488        } else if (!strcmp(argv[i], &quot;-duration&quot;)) {
489          CHECK_NUM_ARGS_AT_LEAST(2, ErrParse);
490          if (ACTION_IS_NIL || config-&gt;action_type_ == ACTION_DURATION) {
491            config-&gt;action_type_ = ACTION_DURATION;
492          } else {
493            ERROR_GOTO1(&quot;ERROR: Multiple actions specified.\n&quot;, ErrParse);
494          }
495          if (FEATURETYPE_IS_NIL || config-&gt;type_ == FEATURE_DURATION) {
496            config-&gt;type_ = FEATURE_DURATION;
497          } else {
498            ERROR_GOTO1(&quot;ERROR: Multiple features specified.\n&quot;, ErrParse);
499          }
500          arg-&gt;params_ = argv[i + 1];
501          ++feature_arg_index;
502          i += 2;
503        } else if (!strcmp(argv[i], &quot;-get&quot;)) {
504          if (ACTION_IS_NIL) {
505            config-&gt;action_type_ = ACTION_GET;
506          } else {
507            ERROR_GOTO1(&quot;ERROR: Multiple actions specified.\n&quot;, ErrParse);
508          }
509          ++i;
510        } else if (!strcmp(argv[i], &quot;-strip&quot;)) {
511          if (ACTION_IS_NIL) {
512            config-&gt;action_type_ = ACTION_STRIP;
513            config-&gt;arg_count_ = 0;
514          } else {
515            ERROR_GOTO1(&quot;ERROR: Multiple actions specified.\n&quot;, ErrParse);
516          }
517          ++i;
518        } else if (!strcmp(argv[i], &quot;-frame&quot;)) {
519          CHECK_NUM_ARGS_AT_LEAST(3, ErrParse);
520          if (ACTION_IS_NIL || config-&gt;action_type_ == ACTION_SET) {
521            config-&gt;action_type_ = ACTION_SET;
522          } else {
523            ERROR_GOTO1(&quot;ERROR: Multiple actions specified.\n&quot;, ErrParse);
524          }
525          if (FEATURETYPE_IS_NIL || config-&gt;type_ == FEATURE_ANMF) {
526            config-&gt;type_ = FEATURE_ANMF;
527          } else {
528            ERROR_GOTO1(&quot;ERROR: Multiple features specified.\n&quot;, ErrParse);
529          }
530          arg-&gt;subtype_ = SUBTYPE_ANMF;
531          arg-&gt;filename_ = argv[i + 1];
532          arg-&gt;params_ = argv[i + 2];
533          ++feature_arg_index;
534          i += 3;
535        } else if (!strcmp(argv[i], &quot;-loop&quot;) || !strcmp(argv[i], &quot;-bgcolor&quot;)) {
536          CHECK_NUM_ARGS_AT_LEAST(2, ErrParse);
537          if (ACTION_IS_NIL || config-&gt;action_type_ == ACTION_SET) {
538            config-&gt;action_type_ = ACTION_SET;
539          } else {
540            ERROR_GOTO1(&quot;ERROR: Multiple actions specified.\n&quot;, ErrParse);
541          }
542          if (FEATURETYPE_IS_NIL || config-&gt;type_ == FEATURE_ANMF) {
543            config-&gt;type_ = FEATURE_ANMF;
544          } else {
545            ERROR_GOTO1(&quot;ERROR: Multiple features specified.\n&quot;, ErrParse);
546          }
547          arg-&gt;subtype_ =
548              !strcmp(argv[i], &quot;-loop&quot;) ? SUBTYPE_LOOP : SUBTYPE_BGCOLOR;
549          arg-&gt;params_ = argv[i + 1];
550          ++feature_arg_index;
551          i += 2;
552        } else if (!strcmp(argv[i], &quot;-o&quot;)) {
553          CHECK_NUM_ARGS_AT_LEAST(2, ErrParse);
554          config-&gt;output_ = wargv[i + 1];
555          i += 2;
556        } else if (!strcmp(argv[i], &quot;-info&quot;)) {
557          CHECK_NUM_ARGS_EXACTLY(2, ErrParse);
558          if (config-&gt;action_type_ != NIL_ACTION) {
559            ERROR_GOTO1(&quot;ERROR: Multiple actions specified.\n&quot;, ErrParse);
560          } else {
561            config-&gt;action_type_ = ACTION_INFO;
562            config-&gt;arg_count_ = 0;
563            config-&gt;input_ = wargv[i + 1];
564          }
565          i += 2;
566        } else if (!strcmp(argv[i], &quot;-h&quot;) || !strcmp(argv[i], &quot;-help&quot;)) {
567          PrintHelp();
568          DeleteConfig(config);
569          LOCAL_FREE((W_CHAR** const)unicode_argv);
570          exit(0);
571        } else if (!strcmp(argv[i], &quot;-version&quot;)) {
572          const int version = WebPGetMuxVersion();
573          printf(&quot;%d.%d.%d\n&quot;,
574                 (version &gt;&gt; 16) &amp; 0xff, (version &gt;&gt; 8) &amp; 0xff, version &amp; 0xff);
575          DeleteConfig(config);
576          LOCAL_FREE((W_CHAR** const)unicode_argv);
577          exit(0);
578        } else if (!strcmp(argv[i], &quot;--&quot;)) {
579          if (i &lt; argc - 1) {
580            ++i;
581            if (config-&gt;input_ == NULL) {
582              config-&gt;input_ = wargv[i];
583            } else {
584              ERROR_GOTO2(&quot;ERROR at &#x27;%s&#x27;: Multiple input files specified.\n&quot;,
585                          argv[i], ErrParse);
586            }
587          }
588          break;
589        } else {
590          ERROR_GOTO2(&quot;ERROR: Unknown option: &#x27;%s&#x27;.\n&quot;, argv[i], ErrParse);
591        }
592      } else {  
593        if (ACTION_IS_NIL) {
594          ERROR_GOTO1(&quot;ERROR: Action must be specified before other arguments.\n&quot;,
595                      ErrParse);
596        }
597        if (!strcmp(argv[i], &quot;icc&quot;) || !strcmp(argv[i], &quot;exif&quot;) ||
598            !strcmp(argv[i], &quot;xmp&quot;)) {
599          if (FEATURETYPE_IS_NIL) {
600            config-&gt;type_ = (!strcmp(argv[i], &quot;icc&quot;)) ? FEATURE_ICCP :
601                (!strcmp(argv[i], &quot;exif&quot;)) ? FEATURE_EXIF : FEATURE_XMP;
602          } else {
603            ERROR_GOTO1(&quot;ERROR: Multiple features specified.\n&quot;, ErrParse);
604          }
605          if (config-&gt;action_type_ == ACTION_SET) {
606            CHECK_NUM_ARGS_AT_LEAST(2, ErrParse);
607            arg-&gt;filename_ = wargv[i + 1];
608            ++feature_arg_index;
609            i += 2;
610          } else {
611            ++i;
612          }
613        } else if (!strcmp(argv[i], &quot;frame&quot;) &amp;&amp;
614                   (config-&gt;action_type_ == ACTION_GET)) {
615          CHECK_NUM_ARGS_AT_LEAST(2, ErrParse);
616          config-&gt;type_ = FEATURE_ANMF;
617          arg-&gt;params_ = argv[i + 1];
618          ++feature_arg_index;
619          i += 2;
620        } else {  
621          if (config-&gt;input_ == NULL) {
622            config-&gt;input_ = wargv[i];
623          } else {
624            ERROR_GOTO2(&quot;ERROR at &#x27;%s&#x27;: Multiple input files specified.\n&quot;,
625                        argv[i], ErrParse);
626          }
627          ++i;
628        }
629      }
630    }
631   ErrParse:
632    return ok;
633  }
634  static int ValidateConfig(Config* const config) {
635    int ok = 1;
636    if (ACTION_IS_NIL) {
637      ERROR_GOTO1(&quot;ERROR: No action specified.\n&quot;, ErrValidate2);
638    }
639    if (FEATURETYPE_IS_NIL &amp;&amp; config-&gt;action_type_ != ACTION_INFO) {
640      ERROR_GOTO1(&quot;ERROR: No feature specified.\n&quot;, ErrValidate2);
641    }
642    if (config-&gt;input_ == NULL) {
643      if (config-&gt;action_type_ != ACTION_SET) {
644        ERROR_GOTO1(&quot;ERROR: No input file specified.\n&quot;, ErrValidate2);
645      } else if (config-&gt;type_ != FEATURE_ANMF) {
646        ERROR_GOTO1(&quot;ERROR: No input file specified.\n&quot;, ErrValidate2);
647      }
648    }
649    if (config-&gt;output_ == NULL &amp;&amp; config-&gt;action_type_ != ACTION_INFO) {
650      ERROR_GOTO1(&quot;ERROR: No output file specified.\n&quot;, ErrValidate2);
651    }
652   ErrValidate2:
653    return ok;
654  }
655  static int InitializeConfig(int argc, const char* argv[], Config* const config,
656                              const W_CHAR** const unicode_argv) {
657    int num_feature_args = 0;
658    int ok;
659    memset(config, 0, sizeof(*config));
660    ok = ExUtilInitCommandLineArguments(argc, argv, &amp;config-&gt;cmd_args_);
661    if (!ok) return 0;
662    if (!ValidateCommandLine(&amp;config-&gt;cmd_args_, &amp;num_feature_args)) {
663      ERROR_GOTO1(&quot;Exiting due to command-line parsing error.\n&quot;, Err1);
664    }
665    config-&gt;arg_count_ = num_feature_args;
666    config-&gt;args_ = (FeatureArg*)calloc(num_feature_args, sizeof(*config-&gt;args_));
667    if (config-&gt;args_ == NULL) {
668      ERROR_GOTO1(&quot;ERROR: Memory allocation error.\n&quot;, Err1);
669    }
670    if (!ParseCommandLine(config, unicode_argv) || !ValidateConfig(config)) {
671      ERROR_GOTO1(&quot;Exiting due to command-line parsing error.\n&quot;, Err1);
672    }
673   Err1:
674    return ok;
675  }
676  #undef ACTION_IS_NIL
677  #undef FEATURETYPE_IS_NIL
678  #undef CHECK_NUM_ARGS_AT_LEAST
679  #undef CHECK_NUM_ARGS_AT_MOST
680  #undef CHECK_NUM_ARGS_EXACTLY
681  static int GetFrame(const WebPMux* mux, const Config* config) {
682    WebPMuxError err = WEBP_MUX_OK;
683    WebPMux* mux_single = NULL;
684    int num = 0;
685    int ok = 1;
686    int parse_error = 0;
687    const WebPChunkId id = WEBP_CHUNK_ANMF;
688    WebPMuxFrameInfo info;
689    WebPDataInit(&amp;info.bitstream);
690    num = ExUtilGetInt(config-&gt;args_[0].params_, 10, &amp;parse_error);
691    if (num &lt; 0) {
692      ERROR_GOTO1(&quot;ERROR: Frame/Fragment index must be non-negative.\n&quot;, ErrGet);
693    }
694    if (parse_error) goto ErrGet;
695    err = WebPMuxGetFrame(mux, num, &amp;info);
696    if (err == WEBP_MUX_OK &amp;&amp; info.id != id) err = WEBP_MUX_NOT_FOUND;
697    if (err != WEBP_MUX_OK) {
698      ERROR_GOTO3(&quot;ERROR (%s): Could not get frame %d.\n&quot;,
699                  ErrorString(err), num, ErrGet);
700    }
701    mux_single = WebPMuxNew();
702    if (mux_single == NULL) {
703      err = WEBP_MUX_MEMORY_ERROR;
704      ERROR_GOTO2(&quot;ERROR (%s): Could not allocate a mux object.\n&quot;,
705                  ErrorString(err), ErrGet);
706    }
707    err = WebPMuxSetImage(mux_single, &amp;info.bitstream, 1);
708    if (err != WEBP_MUX_OK) {
709      ERROR_GOTO2(&quot;ERROR (%s): Could not create single image mux object.\n&quot;,
710                  ErrorString(err), ErrGet);
711    }
712    ok = WriteWebP(mux_single, config-&gt;output_);
713   ErrGet:
714    WebPDataClear(&amp;info.bitstream);
715    WebPMuxDelete(mux_single);
716    return ok &amp;&amp; !parse_error;
717  }
718  static int Process(const Config* config) {
719    WebPMux* mux = NULL;
720    WebPData chunk;
721    WebPMuxError err = WEBP_MUX_OK;
722    int ok = 1;
723    switch (config-&gt;action_type_) {
724      case ACTION_GET: {
725        ok = CreateMux(config-&gt;input_, &amp;mux);
726        if (!ok) goto Err2;
727        switch (config-&gt;type_) {
728          case FEATURE_ANMF:
729            ok = GetFrame(mux, config);
730            break;
731          case FEATURE_ICCP:
732          case FEATURE_EXIF:
733          case FEATURE_XMP:
734            err = WebPMuxGetChunk(mux, kFourccList[config-&gt;type_], &amp;chunk);
735            if (err != WEBP_MUX_OK) {
736              ERROR_GOTO3(&quot;ERROR (%s): Could not get the %s.\n&quot;,
737                          ErrorString(err), kDescriptions[config-&gt;type_], Err2);
738            }
739            ok = WriteData(config-&gt;output_, &amp;chunk);
740            break;
741          default:
742            ERROR_GOTO1(&quot;ERROR: Invalid feature for action &#x27;get&#x27;.\n&quot;, Err2);
743            break;
744        }
745        break;
746      }
747      case ACTION_SET: {
748        switch (config-&gt;type_) {
749          case FEATURE_ANMF: {
750            int i;
751            WebPMuxAnimParams params = { 0xFFFFFFFF, 0 };
752            mux = WebPMuxNew();
753            if (mux == NULL) {
754              ERROR_GOTO2(&quot;ERROR (%s): Could not allocate a mux object.\n&quot;,
755                          ErrorString(WEBP_MUX_MEMORY_ERROR), Err2);
756            }
757            for (i = 0; i &lt; config-&gt;arg_count_; ++i) {
758              switch (config-&gt;args_[i].subtype_) {
759                case SUBTYPE_BGCOLOR: {
760                  uint32_t bgcolor;
761                  ok = ParseBgcolorArgs(config-&gt;args_[i].params_, &amp;bgcolor);
762                  if (!ok) {
763                    ERROR_GOTO1(&quot;ERROR: Could not parse the background color \n&quot;,
764                                Err2);
765                  }
766                  params.bgcolor = bgcolor;
767                  break;
768                }
769                case SUBTYPE_LOOP: {
770                  int parse_error = 0;
771                  const int loop_count =
772                      ExUtilGetInt(config-&gt;args_[i].params_, 10, &amp;parse_error);
773                  if (loop_count &lt; 0 || loop_count &gt; 65535) {
774                    ERROR_GOTO1(&quot;ERROR: Loop count must be in the range 0 to &quot;
775                                &quot;65535.\n&quot;, Err2);
776                  }
777                  ok = !parse_error;
778                  if (!ok) goto Err2;
779                  params.loop_count = loop_count;
780                  break;
781                }
782                case SUBTYPE_ANMF: {
783                  WebPMuxFrameInfo frame;
784                  frame.id = WEBP_CHUNK_ANMF;
785                  ok = ExUtilReadFileToWebPData(config-&gt;args_[i].filename_,
786                                                &amp;frame.bitstream);
787                  if (!ok) goto Err2;
788                  ok = ParseFrameArgs(config-&gt;args_[i].params_, &amp;frame);
789                  if (!ok) {
790                    WebPDataClear(&amp;frame.bitstream);
791                    ERROR_GOTO1(&quot;ERROR: Could not parse frame properties.\n&quot;,
792                                Err2);
793                  }
794                  err = WebPMuxPushFrame(mux, &amp;frame, 1);
795                  WebPDataClear(&amp;frame.bitstream);
796                  if (err != WEBP_MUX_OK) {
797                    ERROR_GOTO3(&quot;ERROR (%s): Could not add a frame at index %d.&quot;
798                                &quot;\n&quot;, ErrorString(err), i, Err2);
799                  }
800                  break;
801                }
802                default: {
803                  ERROR_GOTO1(&quot;ERROR: Invalid subtype for &#x27;frame&#x27;&quot;, Err2);
804                  break;
805                }
806              }
807            }
808            err = WebPMuxSetAnimationParams(mux, &amp;params);
809            if (err != WEBP_MUX_OK) {
810              ERROR_GOTO2(&quot;ERROR (%s): Could not set animation parameters.\n&quot;,
811                          ErrorString(err), Err2);
812            }
813            break;
814          }
815          case FEATURE_ICCP:
816          case FEATURE_EXIF:
817          case FEATURE_XMP: {
818            ok = CreateMux(config-&gt;input_, &amp;mux);
819            if (!ok) goto Err2;
820            ok = ExUtilReadFileToWebPData(config-&gt;args_[0].filename_, &amp;chunk);
821            if (!ok) goto Err2;
822            err = WebPMuxSetChunk(mux, kFourccList[config-&gt;type_], &amp;chunk, 1);
823            free((void*)chunk.bytes);
824            if (err != WEBP_MUX_OK) {
825              ERROR_GOTO3(&quot;ERROR (%s): Could not set the %s.\n&quot;,
826                          ErrorString(err), kDescriptions[config-&gt;type_], Err2);
827            }
828            break;
829          }
830          default: {
831            ERROR_GOTO1(&quot;ERROR: Invalid feature for action &#x27;set&#x27;.\n&quot;, Err2);
832            break;
833          }
834        }
835        ok = WriteWebP(mux, config-&gt;output_);
836        break;
837      }
838      case ACTION_DURATION: {
839        int num_frames;
840        ok = CreateMux(config-&gt;input_, &amp;mux);
841        if (!ok) goto Err2;
842        err = WebPMuxNumChunks(mux, WEBP_CHUNK_ANMF, &amp;num_frames);
843        ok = (err == WEBP_MUX_OK);
844        if (!ok) {
845          ERROR_GOTO1(&quot;ERROR: can not parse the number of frames.\n&quot;, Err2);
846        }
847        if (num_frames == 0) {
848          fprintf(stderr, &quot;Doesn&#x27;t look like the source is animated. &quot;
849                          &quot;Skipping duration setting.\n&quot;);
850          ok = WriteWebP(mux, config-&gt;output_);
851          if (!ok) goto Err2;
852        } else {
853          int i;
854          int* durations = NULL;
855          WebPMux* new_mux = DuplicateMuxHeader(mux);
856          if (new_mux == NULL) goto Err2;
857          durations = (int*)WebPMalloc((size_t)num_frames * sizeof(*durations));
858          if (durations == NULL) goto Err2;
859          for (i = 0; i &lt; num_frames; ++i) durations[i] = -1;
860          for (i = 0; i &lt; config-&gt;arg_count_; ++i) {
861            int k;
862            int args[3];
863            int duration, start, end;
864            const int nb_args = ExUtilGetInts(config-&gt;args_[i].params_,
865                                              10, 3, args);
866            ok = (nb_args &gt;= 1);
867            if (!ok) goto Err3;
868            duration = args[0];
869            if (duration &lt; 0) {
870              ERROR_GOTO1(&quot;ERROR: duration must be strictly positive.\n&quot;, Err3);
871            }
872            if (nb_args == 1) {   
873              start = 1;
874              end = num_frames;
875            } else {
876              start = args[1];
877              if (start &lt;= 0) {
878                start = 1;
879              } else if (start &gt; num_frames) {
880                start = num_frames;
881              }
882              end = (nb_args &gt;= 3) ? args[2] : start;
883              if (end == 0 || end &gt; num_frames) end = num_frames;
884            }
885            for (k = start; k &lt;= end; ++k) {
886              assert(k &gt;= 1 &amp;&amp; k &lt;= num_frames);
887              durations[k - 1] = duration;
888            }
889          }
890          for (i = 1; i &lt;= num_frames; ++i) {
891            WebPMuxFrameInfo frame;
892            err = WebPMuxGetFrame(mux, i, &amp;frame);
893            if (err != WEBP_MUX_OK || frame.id != WEBP_CHUNK_ANMF) {
894              ERROR_GOTO2(&quot;ERROR: can not retrieve frame #%d.\n&quot;, i, Err3);
895            }
896            if (durations[i - 1] &gt;= 0) frame.duration = durations[i - 1];
897            err = WebPMuxPushFrame(new_mux, &amp;frame, 1);
898            if (err != WEBP_MUX_OK) {
899              ERROR_GOTO2(&quot;ERROR: error push frame data #%d\n&quot;, i, Err3);
900            }
901            WebPDataClear(&amp;frame.bitstream);
902          }
903          WebPMuxDelete(mux);
904          ok = WriteWebP(new_mux, config-&gt;output_);
905          mux = new_mux;  
906          new_mux = NULL;
907   Err3:
908          WebPFree(durations);
909          WebPMuxDelete(new_mux);
910          if (!ok) goto Err2;
911        }
912        break;
913      }
914      case ACTION_STRIP: {
915        ok = CreateMux(config-&gt;input_, &amp;mux);
916        if (!ok) goto Err2;
917        if (config-&gt;type_ == FEATURE_ICCP || config-&gt;type_ == FEATURE_EXIF ||
918            config-&gt;type_ == FEATURE_XMP) {
919          err = WebPMuxDeleteChunk(mux, kFourccList[config-&gt;type_]);
920          if (err != WEBP_MUX_OK) {
921            ERROR_GOTO3(&quot;ERROR (%s): Could not strip the %s.\n&quot;,
922                        ErrorString(err), kDescriptions[config-&gt;type_], Err2);
923          }
924        } else {
925          ERROR_GOTO1(&quot;ERROR: Invalid feature for action &#x27;strip&#x27;.\n&quot;, Err2);
926          break;
927        }
928        ok = WriteWebP(mux, config-&gt;output_);
929        break;
930      }
931      case ACTION_INFO: {
932        ok = CreateMux(config-&gt;input_, &amp;mux);
933        if (!ok) goto Err2;
934        ok = (DisplayInfo(mux) == WEBP_MUX_OK);
935        break;
936      }
937      default: {
938        assert(0);  
939        break;
940      }
941    }
942   Err2:
943    WebPMuxDelete(mux);
944    return ok;
945  }
946  int main(int argc, const char* argv[]) {
947    Config config;
948    int ok;
949    INIT_WARGV(argc, argv);
950    ok = InitializeConfig(argc - 1, argv + 1, &amp;config, GET_WARGV_OR_NULL());
951    if (ok) {
952      ok = Process(&amp;config);
953    } else {
954      PrintHelp();
955    }
956    DeleteConfig(&amp;config);
957    FREE_WARGV_AND_RETURN(!ok);
958  }
</code></pre>
        </div>
        <div class="column">
            <h3>PINRemoteImage-MDEwOlJlcG9zaXRvcnkzOTUzNzEwMw==-flat-webpmux.c</h3>
            <pre><code>1  #ifdef HAVE_CONFIG_H
2  #include &quot;webp/config.h&quot;
3  #endif
4  #include &lt;assert.h&gt;
5  #include &lt;stdio.h&gt;
6  #include &lt;stdlib.h&gt;
7  #include &lt;string.h&gt;
8  #include &quot;webp/decode.h&quot;
9  #include &quot;webp/mux.h&quot;
10  #include &quot;../examples/example_util.h&quot;
11  #include &quot;../imageio/imageio_util.h&quot;
12  #include &quot;./unicode.h&quot;
13  typedef enum {
14    NIL_ACTION = 0,
15    ACTION_GET,
16    ACTION_SET,
17    ACTION_STRIP,
18    ACTION_INFO,
19    ACTION_HELP,
20    ACTION_DURATION
21  } ActionType;
22  typedef enum {
23    NIL_SUBTYPE = 0,
24    SUBTYPE_ANMF,
25    SUBTYPE_LOOP,
26    SUBTYPE_BGCOLOR
27  } FeatureSubType;
28  typedef struct {
29    FeatureSubType subtype_;
30    const char* filename_;
31    const char* params_;
32  } FeatureArg;
33  typedef enum {
34    NIL_FEATURE = 0,
35    FEATURE_EXIF,
36    FEATURE_XMP,
37    FEATURE_ICCP,
38    FEATURE_ANMF,
39    FEATURE_DURATION,
40    LAST_FEATURE
41  } FeatureType;
42  static const char* const kFourccList[LAST_FEATURE] = {
43    NULL, &quot;EXIF&quot;, &quot;XMP &quot;, &quot;ICCP&quot;, &quot;ANMF&quot;
44  };
45  static const char* const kDescriptions[LAST_FEATURE] = {
46    NULL, &quot;EXIF metadata&quot;, &quot;XMP metadata&quot;, &quot;ICC profile&quot;,
47    &quot;Animation frame&quot;
48  };
49  typedef struct {
50    CommandLineArguments cmd_args_;
51    ActionType action_type_;
52    const char* input_;
53    const char* output_;
54    FeatureType type_;
55    FeatureArg* args_;
56    int arg_count_;
57  } Config;
58  static int CountOccurrences(const CommandLineArguments* const args,
59                              const char* const arg) {
60    int i;
61    int num_occurences = 0;
62    for (i = 0; i &lt; args-&gt;argc_; ++i) {
63      if (!strcmp(args-&gt;argv_[i], arg)) {
64        ++num_occurences;
65      }
66    }
67    return num_occurences;
68  }
69  static const char* const kErrorMessages[-WEBP_MUX_NOT_ENOUGH_DATA + 1] = {
70    &quot;WEBP_MUX_NOT_FOUND&quot;, &quot;WEBP_MUX_INVALID_ARGUMENT&quot;, &quot;WEBP_MUX_BAD_DATA&quot;,
71    &quot;WEBP_MUX_MEMORY_ERROR&quot;, &quot;WEBP_MUX_NOT_ENOUGH_DATA&quot;
72  };
73  static const char* ErrorString(WebPMuxError err) {
74    assert(err &lt;= WEBP_MUX_NOT_FOUND &amp;&amp; err &gt;= WEBP_MUX_NOT_ENOUGH_DATA);
75    return kErrorMessages[-err];
76  }
77  #define RETURN_IF_ERROR(ERR_MSG)                                     \
78    if (err != WEBP_MUX_OK) {                                          \
79      fprintf(stderr, ERR_MSG);                                        \
80      return err;                                                      \
81    }
82  #define RETURN_IF_ERROR3(ERR_MSG, FORMAT_STR1, FORMAT_STR2)          \
83    if (err != WEBP_MUX_OK) {                                          \
84      fprintf(stderr, ERR_MSG, FORMAT_STR1, FORMAT_STR2);              \
85      return err;                                                      \
86    }
87  #define ERROR_GOTO1(ERR_MSG, LABEL)                                  \
88    do {                                                               \
89      fprintf(stderr, ERR_MSG);                                        \
90      ok = 0;                                                          \
91      goto LABEL;                                                      \
92    } while (0)
93  #define ERROR_GOTO2(ERR_MSG, FORMAT_STR, LABEL)                      \
94    do {                                                               \
95      fprintf(stderr, ERR_MSG, FORMAT_STR);                            \
96      ok = 0;                                                          \
97      goto LABEL;                                                      \
98    } while (0)
99  #define ERROR_GOTO3(ERR_MSG, FORMAT_STR1, FORMAT_STR2, LABEL)        \
100    do {                                                               \
101      fprintf(stderr, ERR_MSG, FORMAT_STR1, FORMAT_STR2);              \
102      ok = 0;                                                          \
103      goto LABEL;                                                      \
104    } while (0)
105  static WebPMuxError DisplayInfo(const WebPMux* mux) {
106    int width, height;
107    uint32_t flag;
108    WebPMuxError err = WebPMuxGetCanvasSize(mux, &amp;width, &amp;height);
109    assert(err == WEBP_MUX_OK);  
110    printf(&quot;Canvas size: %d x %d\n&quot;, width, height);
111    err = WebPMuxGetFeatures(mux, &amp;flag);
112    RETURN_IF_ERROR(&quot;Failed to retrieve features\n&quot;);
113    if (flag == 0) {
114      printf(&quot;No features present.\n&quot;);
115      return err;
116    }
117    printf(&quot;Features present:&quot;);
118    if (flag &amp; ANIMATION_FLAG) printf(&quot; animation&quot;);
119    if (flag &amp; ICCP_FLAG)      printf(&quot; ICC profile&quot;);
120    if (flag &amp; EXIF_FLAG)      printf(&quot; EXIF metadata&quot;);
121    if (flag &amp; XMP_FLAG)       printf(&quot; XMP metadata&quot;);
122    if (flag &amp; ALPHA_FLAG)     printf(&quot; transparency&quot;);
123    printf(&quot;\n&quot;);
124    if (flag &amp; ANIMATION_FLAG) {
125      const WebPChunkId id = WEBP_CHUNK_ANMF;
126      const char* const type_str = &quot;frame&quot;;
127      int nFrames;
128      WebPMuxAnimParams params;
129      err = WebPMuxGetAnimationParams(mux, &amp;params);
130      assert(err == WEBP_MUX_OK);
131      printf(&quot;Background color : 0x%.8X  Loop Count : %d\n&quot;,
132             params.bgcolor, params.loop_count);
133      err = WebPMuxNumChunks(mux, id, &amp;nFrames);
<span onclick='openModal()' class='match'>134      assert(err == WEBP_MUX_OK);
135      printf(&quot;Number of %ss: %d\n&quot;, type_str, nFrames);
136      if (nFrames &gt; 0) {
</span>137        int i;
138        printf(&quot;No.: width height alpha x_offset y_offset &quot;);
139        printf(&quot;duration   dispose blend &quot;);
140        printf(&quot;image_size  compression\n&quot;);
141        for (i = 1; i &lt;= nFrames; i++) {
142          WebPMuxFrameInfo frame;
143          err = WebPMuxGetFrame(mux, i, &amp;frame);
144          if (err == WEBP_MUX_OK) {
145            WebPBitstreamFeatures features;
146            const VP8StatusCode status = WebPGetFeatures(
147                frame.bitstream.bytes, frame.bitstream.size, &amp;features);
148            assert(status == VP8_STATUS_OK);  
149            (void)status;
150            printf(&quot;%3d: %5d %5d %5s %8d %8d &quot;, i, features.width,
151                   features.height, features.has_alpha ? &quot;yes&quot; : &quot;no&quot;,
152                   frame.x_offset, frame.y_offset);
153            {
154              const char* const dispose =
155                  (frame.dispose_method == WEBP_MUX_DISPOSE_NONE) ? &quot;none&quot;
156                                                                  : &quot;background&quot;;
157              const char* const blend =
158                  (frame.blend_method == WEBP_MUX_BLEND) ? &quot;yes&quot; : &quot;no&quot;;
159              printf(&quot;%8d %10s %5s &quot;, frame.duration, dispose, blend);
160            }
161            printf(&quot;%10d %11s\n&quot;, (int)frame.bitstream.size,
162                   (features.format == 1) ? &quot;lossy&quot; :
163                   (features.format == 2) ? &quot;lossless&quot; :
164                                            &quot;undefined&quot;);
165          }
166          WebPDataClear(&amp;frame.bitstream);
167          RETURN_IF_ERROR3(&quot;Failed to retrieve %s#%d\n&quot;, type_str, i);
168        }
169      }
170    }
171    if (flag &amp; ICCP_FLAG) {
172      WebPData icc_profile;
173      err = WebPMuxGetChunk(mux, &quot;ICCP&quot;, &amp;icc_profile);
174      assert(err == WEBP_MUX_OK);
175      printf(&quot;Size of the ICC profile data: %d\n&quot;, (int)icc_profile.size);
176    }
177    if (flag &amp; EXIF_FLAG) {
178      WebPData exif;
179      err = WebPMuxGetChunk(mux, &quot;EXIF&quot;, &amp;exif);
180      assert(err == WEBP_MUX_OK);
181      printf(&quot;Size of the EXIF metadata: %d\n&quot;, (int)exif.size);
182    }
183    if (flag &amp; XMP_FLAG) {
184      WebPData xmp;
185      err = WebPMuxGetChunk(mux, &quot;XMP &quot;, &amp;xmp);
186      assert(err == WEBP_MUX_OK);
187      printf(&quot;Size of the XMP metadata: %d\n&quot;, (int)xmp.size);
188    }
189    if ((flag &amp; ALPHA_FLAG) &amp;&amp; !(flag &amp; ANIMATION_FLAG)) {
190      WebPMuxFrameInfo image;
191      err = WebPMuxGetFrame(mux, 1, &amp;image);
192      if (err == WEBP_MUX_OK) {
193        printf(&quot;Size of the image (with alpha): %d\n&quot;, (int)image.bitstream.size);
194      }
195      WebPDataClear(&amp;image.bitstream);
196      RETURN_IF_ERROR(&quot;Failed to retrieve the image\n&quot;);
197    }
198    return WEBP_MUX_OK;
199  }
200  static void PrintHelp(void) {
201    printf(&quot;Usage: webpmux -get GET_OPTIONS INPUT -o OUTPUT\n&quot;);
202    printf(&quot;       webpmux -set SET_OPTIONS INPUT -o OUTPUT\n&quot;);
203    printf(&quot;       webpmux -duration DURATION_OPTIONS [-duration ...]\n&quot;);
204    printf(&quot;               INPUT -o OUTPUT\n&quot;);
205    printf(&quot;       webpmux -strip STRIP_OPTIONS INPUT -o OUTPUT\n&quot;);
206    printf(&quot;       webpmux -frame FRAME_OPTIONS [-frame...] [-loop LOOP_COUNT]&quot;
207           &quot;\n&quot;);
208    printf(&quot;               [-bgcolor BACKGROUND_COLOR] -o OUTPUT\n&quot;);
209    printf(&quot;       webpmux -info INPUT\n&quot;);
210    printf(&quot;       webpmux [-h|-help]\n&quot;);
211    printf(&quot;       webpmux -version\n&quot;);
212    printf(&quot;       webpmux argument_file_name\n&quot;);
213    printf(&quot;\n&quot;);
214    printf(&quot;GET_OPTIONS:\n&quot;);
215    printf(&quot; Extract relevant data:\n&quot;);
216    printf(&quot;   icc       get ICC profile\n&quot;);
217    printf(&quot;   exif      get EXIF metadata\n&quot;);
218    printf(&quot;   xmp       get XMP metadata\n&quot;);
219    printf(&quot;   frame n   get nth frame\n&quot;);
220    printf(&quot;\n&quot;);
221    printf(&quot;SET_OPTIONS:\n&quot;);
222    printf(&quot; Set color profile/metadata:\n&quot;);
223    printf(&quot;   icc  file.icc     set ICC profile\n&quot;);
224    printf(&quot;   exif file.exif    set EXIF metadata\n&quot;);
225    printf(&quot;   xmp  file.xmp     set XMP metadata\n&quot;);
226    printf(&quot;   where:    &#x27;file.icc&#x27; contains the ICC profile to be set,\n&quot;);
227    printf(&quot;             &#x27;file.exif&#x27; contains the EXIF metadata to be set\n&quot;);
228    printf(&quot;             &#x27;file.xmp&#x27; contains the XMP metadata to be set\n&quot;);
229    printf(&quot;\n&quot;);
230    printf(&quot;DURATION_OPTIONS:\n&quot;);
231    printf(&quot; Set duration of selected frames:\n&quot;);
232    printf(&quot;   duration            set duration for each frames\n&quot;);
233    printf(&quot;   duration,frame      set duration of a particular frame\n&quot;);
234    printf(&quot;   duration,start,end  set duration of frames in the\n&quot;);
235    printf(&quot;                        interval [start,end])\n&quot;);
236    printf(&quot;   where: &#x27;duration&#x27; is the duration in milliseconds\n&quot;);
237    printf(&quot;          &#x27;start&#x27; is the start frame index\n&quot;);
238    printf(&quot;          &#x27;end&#x27; is the inclusive end frame index\n&quot;);
239    printf(&quot;           The special &#x27;end&#x27; value &#x27;0&#x27; means: last frame.\n&quot;);
240    printf(&quot;\n&quot;);
241    printf(&quot;STRIP_OPTIONS:\n&quot;);
242    printf(&quot; Strip color profile/metadata:\n&quot;);
243    printf(&quot;   icc       strip ICC profile\n&quot;);
244    printf(&quot;   exif      strip EXIF metadata\n&quot;);
245    printf(&quot;   xmp       strip XMP metadata\n&quot;);
246    printf(&quot;\n&quot;);
247    printf(&quot;FRAME_OPTIONS(i):\n&quot;);
248    printf(&quot; Create animation:\n&quot;);
249    printf(&quot;   file_i +di+[xi+yi[+mi[bi]]]\n&quot;);
250    printf(&quot;   where:    &#x27;file_i&#x27; is the i&#x27;th animation frame (WebP format),\n&quot;);
251    printf(&quot;             &#x27;di&#x27; is the pause duration before next frame,\n&quot;);
252    printf(&quot;             &#x27;xi&#x27;,&#x27;yi&#x27; specify the image offset for this frame,\n&quot;);
253    printf(&quot;             &#x27;mi&#x27; is the dispose method for this frame (0 or 1),\n&quot;);
254    printf(&quot;             &#x27;bi&#x27; is the blending method for this frame (+b or -b)&quot;
255           &quot;\n&quot;);
256    printf(&quot;\n&quot;);
257    printf(&quot;LOOP_COUNT:\n&quot;);
258    printf(&quot; Number of times to repeat the animation.\n&quot;);
259    printf(&quot; Valid range is 0 to 65535 [Default: 0 (infinite)].\n&quot;);
260    printf(&quot;\n&quot;);
261    printf(&quot;BACKGROUND_COLOR:\n&quot;);
262    printf(&quot; Background color of the canvas.\n&quot;);
263    printf(&quot;  A,R,G,B\n&quot;);
264    printf(&quot;  where:    &#x27;A&#x27;, &#x27;R&#x27;, &#x27;G&#x27; and &#x27;B&#x27; are integers in the range 0 to 255 &quot;
265           &quot;specifying\n&quot;);
266    printf(&quot;            the Alpha, Red, Green and Blue component values &quot;
267           &quot;respectively\n&quot;);
268    printf(&quot;            [Default: 255,255,255,255]\n&quot;);
269    printf(&quot;\nINPUT &amp; OUTPUT are in WebP format.\n&quot;);
270    printf(&quot;\nNote: The nature of EXIF, XMP and ICC data is not checked&quot;);
271    printf(&quot; and is assumed to be\nvalid.\n&quot;);
272    printf(&quot;\nNote: if a single file name is passed as the argument, the &quot;
273           &quot;arguments will be\n&quot;);
274    printf(&quot;tokenized from this file. The file name must not start with &quot;
275           &quot;the character &#x27;-&#x27;.\n&quot;);
276  }
277  static void WarnAboutOddOffset(const WebPMuxFrameInfo* const info) {
278    if ((info-&gt;x_offset | info-&gt;y_offset) &amp; 1) {
279      fprintf(stderr, &quot;Warning: odd offsets will be snapped to even values&quot;
280              &quot; (%d, %d) -&gt; (%d, %d)\n&quot;, info-&gt;x_offset, info-&gt;y_offset,
281              info-&gt;x_offset &amp; ~1, info-&gt;y_offset &amp; ~1);
282    }
283  }
284  static int CreateMux(const char* const filename, WebPMux** mux) {
285    WebPData bitstream;
286    assert(mux != NULL);
287    if (!ExUtilReadFileToWebPData(filename, &amp;bitstream)) return 0;
288    *mux = WebPMuxCreate(&amp;bitstream, 1);
289    WebPDataClear(&amp;bitstream);
290    if (*mux != NULL) return 1;
291    WFPRINTF(stderr, &quot;Failed to create mux object from file %s.\n&quot;,
292             (const W_CHAR*)filename);
293    return 0;
294  }
295  static int WriteData(const char* filename, const WebPData* const webpdata) {
296    int ok = 0;
297    FILE* fout = WSTRCMP(filename, &quot;-&quot;) ? WFOPEN(filename, &quot;wb&quot;)
298                                        : ImgIoUtilSetBinaryMode(stdout);
299    if (fout == NULL) {
300      WFPRINTF(stderr, &quot;Error opening output WebP file %s!\n&quot;,
301               (const W_CHAR*)filename);
302      return 0;
303    }
304    if (fwrite(webpdata-&gt;bytes, webpdata-&gt;size, 1, fout) != 1) {
305      WFPRINTF(stderr, &quot;Error writing file %s!\n&quot;, (const W_CHAR*)filename);
306    } else {
307      WFPRINTF(stderr, &quot;Saved file %s (%d bytes)\n&quot;,
308               (const W_CHAR*)filename, (int)webpdata-&gt;size);
309      ok = 1;
310    }
311    if (fout != stdout) fclose(fout);
312    return ok;
313  }
314  static int WriteWebP(WebPMux* const mux, const char* filename) {
315    int ok;
316    WebPData webp_data;
317    const WebPMuxError err = WebPMuxAssemble(mux, &amp;webp_data);
318    if (err != WEBP_MUX_OK) {
319      fprintf(stderr, &quot;Error (%s) assembling the WebP file.\n&quot;, ErrorString(err));
320      return 0;
321    }
322    ok = WriteData(filename, &amp;webp_data);
323    WebPDataClear(&amp;webp_data);
324    return ok;
325  }
326  static WebPMux* DuplicateMuxHeader(const WebPMux* const mux) {
327    WebPMux* new_mux = WebPMuxNew();
328    WebPMuxAnimParams p;
329    WebPMuxError err;
330    int i;
331    int ok = 1;
332    if (new_mux == NULL) return NULL;
333    err = WebPMuxGetAnimationParams(mux, &amp;p);
334    if (err == WEBP_MUX_OK) {
335      err = WebPMuxSetAnimationParams(new_mux, &amp;p);
336      if (err != WEBP_MUX_OK) {
337        ERROR_GOTO2(&quot;Error (%s) handling animation params.\n&quot;,
338                    ErrorString(err), End);
339      }
340    } else {
341    }
342    for (i = 1; i &lt;= 3; ++i) {
343      WebPData metadata;
344      err = WebPMuxGetChunk(mux, kFourccList[i], &amp;metadata);
345      if (err == WEBP_MUX_OK &amp;&amp; metadata.size &gt; 0) {
346        err = WebPMuxSetChunk(new_mux, kFourccList[i], &amp;metadata, 1);
347        if (err != WEBP_MUX_OK) {
348          ERROR_GOTO1(&quot;Error transferring metadata in DuplicateMux().&quot;, End);
349        }
350      }
351    }
352   End:
353    if (!ok) {
354      WebPMuxDelete(new_mux);
355      new_mux = NULL;
356    }
357    return new_mux;
358  }
359  static int ParseFrameArgs(const char* args, WebPMuxFrameInfo* const info) {
360    int dispose_method, dummy;
361    char plus_minus, blend_method;
362    const int num_args = sscanf(args, &quot;+%d+%d+%d+%d%c%c+%d&quot;, &amp;info-&gt;duration,
363                                &amp;info-&gt;x_offset, &amp;info-&gt;y_offset, &amp;dispose_method,
364                                &amp;plus_minus, &amp;blend_method, &amp;dummy);
365    switch (num_args) {
366      case 1:
367        info-&gt;x_offset = info-&gt;y_offset = 0;  
368      case 3:
369        dispose_method = 0;  
370      case 4:
371        plus_minus = &#x27;+&#x27;;
372        blend_method = &#x27;b&#x27;;  
373      case 6:
374        break;
375      case 2:
376      case 5:
377      default:
378        return 0;
379    }
380    WarnAboutOddOffset(info);
381    info-&gt;dispose_method = (WebPMuxAnimDispose)dispose_method;
382    if (blend_method != &#x27;b&#x27;) return 0;
383    if (plus_minus != &#x27;-&#x27; &amp;&amp; plus_minus != &#x27;+&#x27;) return 0;
384    info-&gt;blend_method =
385        (plus_minus == &#x27;+&#x27;) ? WEBP_MUX_BLEND : WEBP_MUX_NO_BLEND;
386    return 1;
387  }
388  static int ParseBgcolorArgs(const char* args, uint32_t* const bgcolor) {
389    uint32_t a, r, g, b;
390    if (sscanf(args, &quot;%u,%u,%u,%u&quot;, &amp;a, &amp;r, &amp;g, &amp;b) != 4) return 0;
391    if (a &gt;= 256 || r &gt;= 256 || g &gt;= 256 || b &gt;= 256) return 0;
392    *bgcolor = (a &lt;&lt; 24) | (r &lt;&lt; 16) | (g &lt;&lt; 8) | (b &lt;&lt; 0);
393    return 1;
394  }
395  static void DeleteConfig(Config* const config) {
396    if (config != NULL) {
397      free(config-&gt;args_);
398      ExUtilDeleteCommandLineArguments(&amp;config-&gt;cmd_args_);
399      memset(config, 0, sizeof(*config));
400    }
401  }
402  static int ValidateCommandLine(const CommandLineArguments* const cmd_args,
403                                 int* num_feature_args) {
404    int num_frame_args;
405    int num_loop_args;
406    int num_bgcolor_args;
407    int num_durations_args;
408    int ok = 1;
409    assert(num_feature_args != NULL);
410    *num_feature_args = 0;
411    if (CountOccurrences(cmd_args, &quot;-get&quot;) &gt; 1) {
412      ERROR_GOTO1(&quot;ERROR: Multiple &#x27;-get&#x27; arguments specified.\n&quot;, ErrValidate);
413    }
414    if (CountOccurrences(cmd_args, &quot;-set&quot;) &gt; 1) {
415      ERROR_GOTO1(&quot;ERROR: Multiple &#x27;-set&#x27; arguments specified.\n&quot;, ErrValidate);
416    }
417    if (CountOccurrences(cmd_args, &quot;-strip&quot;) &gt; 1) {
418      ERROR_GOTO1(&quot;ERROR: Multiple &#x27;-strip&#x27; arguments specified.\n&quot;, ErrValidate);
419    }
420    if (CountOccurrences(cmd_args, &quot;-info&quot;) &gt; 1) {
421      ERROR_GOTO1(&quot;ERROR: Multiple &#x27;-info&#x27; arguments specified.\n&quot;, ErrValidate);
422    }
423    if (CountOccurrences(cmd_args, &quot;-o&quot;) &gt; 1) {
424      ERROR_GOTO1(&quot;ERROR: Multiple output files specified.\n&quot;, ErrValidate);
425    }
426    num_frame_args = CountOccurrences(cmd_args, &quot;-frame&quot;);
427    num_loop_args = CountOccurrences(cmd_args, &quot;-loop&quot;);
428    num_bgcolor_args = CountOccurrences(cmd_args, &quot;-bgcolor&quot;);
429    num_durations_args = CountOccurrences(cmd_args, &quot;-duration&quot;);
430    if (num_loop_args &gt; 1) {
431      ERROR_GOTO1(&quot;ERROR: Multiple loop counts specified.\n&quot;, ErrValidate);
432    }
433    if (num_bgcolor_args &gt; 1) {
434      ERROR_GOTO1(&quot;ERROR: Multiple background colors specified.\n&quot;, ErrValidate);
435    }
436    if ((num_frame_args == 0) &amp;&amp; (num_loop_args + num_bgcolor_args &gt; 0)) {
437      ERROR_GOTO1(&quot;ERROR: Loop count and background color are relevant only in &quot;
438                  &quot;case of animation.\n&quot;, ErrValidate);
439    }
440    if (num_durations_args &gt; 0 &amp;&amp; num_frame_args != 0) {
441      ERROR_GOTO1(&quot;ERROR: Can not combine -duration and -frame commands.\n&quot;,
442                  ErrValidate);
443    }
444    assert(ok == 1);
445    if (num_durations_args &gt; 0) {
446      *num_feature_args = num_durations_args;
447    } else if (num_frame_args == 0) {
448      *num_feature_args = 1;
449    } else {
450      *num_feature_args = num_frame_args + num_loop_args + num_bgcolor_args;
451    }
452   ErrValidate:
453    return ok;
454  }
455  #define ACTION_IS_NIL (config-&gt;action_type_ == NIL_ACTION)
456  #define FEATURETYPE_IS_NIL (config-&gt;type_ == NIL_FEATURE)
457  #define CHECK_NUM_ARGS_AT_LEAST(NUM, LABEL)                              \
458    if (argc &lt; i + (NUM)) {                                                \
459      fprintf(stderr, &quot;ERROR: Too few arguments for &#x27;%s&#x27;.\n&quot;, argv[i]);    \
460      goto LABEL;                                                          \
461    }
462  #define CHECK_NUM_ARGS_AT_MOST(NUM, LABEL)                               \
463    if (argc &gt; i + (NUM)) {                                                \
464      fprintf(stderr, &quot;ERROR: Too many arguments for &#x27;%s&#x27;.\n&quot;, argv[i]);   \
465      goto LABEL;                                                          \
466    }
467  #define CHECK_NUM_ARGS_EXACTLY(NUM, LABEL)                               \
468    CHECK_NUM_ARGS_AT_LEAST(NUM, LABEL);                                   \
469    CHECK_NUM_ARGS_AT_MOST(NUM, LABEL);
470  static int ParseCommandLine(Config* config, const W_CHAR** const unicode_argv) {
471    int i = 0;
472    int feature_arg_index = 0;
473    int ok = 1;
474    int argc = config-&gt;cmd_args_.argc_;
475    const char* const* argv = config-&gt;cmd_args_.argv_;
476    const char* const* wargv =
477        (unicode_argv != NULL) ? (const char**)(unicode_argv + 1) : argv;
478    while (i &lt; argc) {
479      FeatureArg* const arg = &amp;config-&gt;args_[feature_arg_index];
480      if (argv[i][0] == &#x27;-&#x27;) {  
481        if (!strcmp(argv[i], &quot;-set&quot;)) {
482          if (ACTION_IS_NIL) {
483            config-&gt;action_type_ = ACTION_SET;
484          } else {
485            ERROR_GOTO1(&quot;ERROR: Multiple actions specified.\n&quot;, ErrParse);
486          }
487          ++i;
488        } else if (!strcmp(argv[i], &quot;-duration&quot;)) {
489          CHECK_NUM_ARGS_AT_LEAST(2, ErrParse);
490          if (ACTION_IS_NIL || config-&gt;action_type_ == ACTION_DURATION) {
491            config-&gt;action_type_ = ACTION_DURATION;
492          } else {
493            ERROR_GOTO1(&quot;ERROR: Multiple actions specified.\n&quot;, ErrParse);
494          }
495          if (FEATURETYPE_IS_NIL || config-&gt;type_ == FEATURE_DURATION) {
496            config-&gt;type_ = FEATURE_DURATION;
497          } else {
498            ERROR_GOTO1(&quot;ERROR: Multiple features specified.\n&quot;, ErrParse);
499          }
500          arg-&gt;params_ = argv[i + 1];
501          ++feature_arg_index;
502          i += 2;
503        } else if (!strcmp(argv[i], &quot;-get&quot;)) {
504          if (ACTION_IS_NIL) {
505            config-&gt;action_type_ = ACTION_GET;
506          } else {
507            ERROR_GOTO1(&quot;ERROR: Multiple actions specified.\n&quot;, ErrParse);
508          }
509          ++i;
510        } else if (!strcmp(argv[i], &quot;-strip&quot;)) {
511          if (ACTION_IS_NIL) {
512            config-&gt;action_type_ = ACTION_STRIP;
513            config-&gt;arg_count_ = 0;
514          } else {
515            ERROR_GOTO1(&quot;ERROR: Multiple actions specified.\n&quot;, ErrParse);
516          }
517          ++i;
518        } else if (!strcmp(argv[i], &quot;-frame&quot;)) {
519          CHECK_NUM_ARGS_AT_LEAST(3, ErrParse);
520          if (ACTION_IS_NIL || config-&gt;action_type_ == ACTION_SET) {
521            config-&gt;action_type_ = ACTION_SET;
522          } else {
523            ERROR_GOTO1(&quot;ERROR: Multiple actions specified.\n&quot;, ErrParse);
524          }
525          if (FEATURETYPE_IS_NIL || config-&gt;type_ == FEATURE_ANMF) {
526            config-&gt;type_ = FEATURE_ANMF;
527          } else {
528            ERROR_GOTO1(&quot;ERROR: Multiple features specified.\n&quot;, ErrParse);
529          }
530          arg-&gt;subtype_ = SUBTYPE_ANMF;
531          arg-&gt;filename_ = argv[i + 1];
532          arg-&gt;params_ = argv[i + 2];
533          ++feature_arg_index;
534          i += 3;
535        } else if (!strcmp(argv[i], &quot;-loop&quot;) || !strcmp(argv[i], &quot;-bgcolor&quot;)) {
536          CHECK_NUM_ARGS_AT_LEAST(2, ErrParse);
537          if (ACTION_IS_NIL || config-&gt;action_type_ == ACTION_SET) {
538            config-&gt;action_type_ = ACTION_SET;
539          } else {
540            ERROR_GOTO1(&quot;ERROR: Multiple actions specified.\n&quot;, ErrParse);
541          }
542          if (FEATURETYPE_IS_NIL || config-&gt;type_ == FEATURE_ANMF) {
543            config-&gt;type_ = FEATURE_ANMF;
544          } else {
545            ERROR_GOTO1(&quot;ERROR: Multiple features specified.\n&quot;, ErrParse);
546          }
547          arg-&gt;subtype_ =
548              !strcmp(argv[i], &quot;-loop&quot;) ? SUBTYPE_LOOP : SUBTYPE_BGCOLOR;
549          arg-&gt;params_ = argv[i + 1];
550          ++feature_arg_index;
551          i += 2;
552        } else if (!strcmp(argv[i], &quot;-o&quot;)) {
553          CHECK_NUM_ARGS_AT_LEAST(2, ErrParse);
554          config-&gt;output_ = wargv[i + 1];
555          i += 2;
556        } else if (!strcmp(argv[i], &quot;-info&quot;)) {
557          CHECK_NUM_ARGS_EXACTLY(2, ErrParse);
558          if (config-&gt;action_type_ != NIL_ACTION) {
559            ERROR_GOTO1(&quot;ERROR: Multiple actions specified.\n&quot;, ErrParse);
560          } else {
561            config-&gt;action_type_ = ACTION_INFO;
562            config-&gt;arg_count_ = 0;
563            config-&gt;input_ = wargv[i + 1];
564          }
565          i += 2;
566        } else if (!strcmp(argv[i], &quot;-h&quot;) || !strcmp(argv[i], &quot;-help&quot;)) {
567          PrintHelp();
568          DeleteConfig(config);
569          LOCAL_FREE((W_CHAR** const)unicode_argv);
570          exit(0);
571        } else if (!strcmp(argv[i], &quot;-version&quot;)) {
572          const int version = WebPGetMuxVersion();
573          printf(&quot;%d.%d.%d\n&quot;,
574                 (version &gt;&gt; 16) &amp; 0xff, (version &gt;&gt; 8) &amp; 0xff, version &amp; 0xff);
575          DeleteConfig(config);
576          LOCAL_FREE((W_CHAR** const)unicode_argv);
577          exit(0);
578        } else if (!strcmp(argv[i], &quot;--&quot;)) {
579          if (i &lt; argc - 1) {
580            ++i;
581            if (config-&gt;input_ == NULL) {
582              config-&gt;input_ = wargv[i];
583            } else {
584              ERROR_GOTO2(&quot;ERROR at &#x27;%s&#x27;: Multiple input files specified.\n&quot;,
585                          argv[i], ErrParse);
586            }
587          }
588          break;
589        } else {
590          ERROR_GOTO2(&quot;ERROR: Unknown option: &#x27;%s&#x27;.\n&quot;, argv[i], ErrParse);
591        }
592      } else {  
593        if (ACTION_IS_NIL) {
594          ERROR_GOTO1(&quot;ERROR: Action must be specified before other arguments.\n&quot;,
595                      ErrParse);
596        }
597        if (!strcmp(argv[i], &quot;icc&quot;) || !strcmp(argv[i], &quot;exif&quot;) ||
598            !strcmp(argv[i], &quot;xmp&quot;)) {
599          if (FEATURETYPE_IS_NIL) {
600            config-&gt;type_ = (!strcmp(argv[i], &quot;icc&quot;)) ? FEATURE_ICCP :
601                (!strcmp(argv[i], &quot;exif&quot;)) ? FEATURE_EXIF : FEATURE_XMP;
602          } else {
603            ERROR_GOTO1(&quot;ERROR: Multiple features specified.\n&quot;, ErrParse);
604          }
605          if (config-&gt;action_type_ == ACTION_SET) {
606            CHECK_NUM_ARGS_AT_LEAST(2, ErrParse);
607            arg-&gt;filename_ = wargv[i + 1];
608            ++feature_arg_index;
609            i += 2;
610          } else {
611            ++i;
612          }
613        } else if (!strcmp(argv[i], &quot;frame&quot;) &amp;&amp;
614                   (config-&gt;action_type_ == ACTION_GET)) {
615          CHECK_NUM_ARGS_AT_LEAST(2, ErrParse);
616          config-&gt;type_ = FEATURE_ANMF;
617          arg-&gt;params_ = argv[i + 1];
618          ++feature_arg_index;
619          i += 2;
620        } else {  
621          if (config-&gt;input_ == NULL) {
622            config-&gt;input_ = wargv[i];
623          } else {
624            ERROR_GOTO2(&quot;ERROR at &#x27;%s&#x27;: Multiple input files specified.\n&quot;,
625                        argv[i], ErrParse);
626          }
627          ++i;
628        }
629      }
630    }
631   ErrParse:
632    return ok;
633  }
634  static int ValidateConfig(Config* const config) {
635    int ok = 1;
636    if (ACTION_IS_NIL) {
637      ERROR_GOTO1(&quot;ERROR: No action specified.\n&quot;, ErrValidate2);
638    }
639    if (FEATURETYPE_IS_NIL &amp;&amp; config-&gt;action_type_ != ACTION_INFO) {
640      ERROR_GOTO1(&quot;ERROR: No feature specified.\n&quot;, ErrValidate2);
641    }
642    if (config-&gt;input_ == NULL) {
643      if (config-&gt;action_type_ != ACTION_SET) {
644        ERROR_GOTO1(&quot;ERROR: No input file specified.\n&quot;, ErrValidate2);
645      } else if (config-&gt;type_ != FEATURE_ANMF) {
646        ERROR_GOTO1(&quot;ERROR: No input file specified.\n&quot;, ErrValidate2);
647      }
648    }
649    if (config-&gt;output_ == NULL &amp;&amp; config-&gt;action_type_ != ACTION_INFO) {
650      ERROR_GOTO1(&quot;ERROR: No output file specified.\n&quot;, ErrValidate2);
651    }
652   ErrValidate2:
653    return ok;
654  }
655  static int InitializeConfig(int argc, const char* argv[], Config* const config,
656                              const W_CHAR** const unicode_argv) {
657    int num_feature_args = 0;
658    int ok;
659    memset(config, 0, sizeof(*config));
660    ok = ExUtilInitCommandLineArguments(argc, argv, &amp;config-&gt;cmd_args_);
661    if (!ok) return 0;
662    if (!ValidateCommandLine(&amp;config-&gt;cmd_args_, &amp;num_feature_args)) {
663      ERROR_GOTO1(&quot;Exiting due to command-line parsing error.\n&quot;, Err1);
664    }
665    config-&gt;arg_count_ = num_feature_args;
666    config-&gt;args_ = (FeatureArg*)calloc(num_feature_args, sizeof(*config-&gt;args_));
667    if (config-&gt;args_ == NULL) {
668      ERROR_GOTO1(&quot;ERROR: Memory allocation error.\n&quot;, Err1);
669    }
670    if (!ParseCommandLine(config, unicode_argv) || !ValidateConfig(config)) {
671      ERROR_GOTO1(&quot;Exiting due to command-line parsing error.\n&quot;, Err1);
672    }
673   Err1:
674    return ok;
675  }
676  #undef ACTION_IS_NIL
677  #undef FEATURETYPE_IS_NIL
678  #undef CHECK_NUM_ARGS_AT_LEAST
679  #undef CHECK_NUM_ARGS_AT_MOST
680  #undef CHECK_NUM_ARGS_EXACTLY
681  static int GetFrame(const WebPMux* mux, const Config* config) {
682    WebPMuxError err = WEBP_MUX_OK;
683    WebPMux* mux_single = NULL;
684    int num = 0;
685    int ok = 1;
686    int parse_error = 0;
687    const WebPChunkId id = WEBP_CHUNK_ANMF;
688    WebPMuxFrameInfo info;
689    WebPDataInit(&amp;info.bitstream);
690    num = ExUtilGetInt(config-&gt;args_[0].params_, 10, &amp;parse_error);
691    if (num &lt; 0) {
692      ERROR_GOTO1(&quot;ERROR: Frame/Fragment index must be non-negative.\n&quot;, ErrGet);
693    }
694    if (parse_error) goto ErrGet;
695    err = WebPMuxGetFrame(mux, num, &amp;info);
696    if (err == WEBP_MUX_OK &amp;&amp; info.id != id) err = WEBP_MUX_NOT_FOUND;
697    if (err != WEBP_MUX_OK) {
698      ERROR_GOTO3(&quot;ERROR (%s): Could not get frame %d.\n&quot;,
699                  ErrorString(err), num, ErrGet);
700    }
701    mux_single = WebPMuxNew();
702    if (mux_single == NULL) {
703      err = WEBP_MUX_MEMORY_ERROR;
704      ERROR_GOTO2(&quot;ERROR (%s): Could not allocate a mux object.\n&quot;,
705                  ErrorString(err), ErrGet);
706    }
707    err = WebPMuxSetImage(mux_single, &amp;info.bitstream, 1);
708    if (err != WEBP_MUX_OK) {
709      ERROR_GOTO2(&quot;ERROR (%s): Could not create single image mux object.\n&quot;,
710                  ErrorString(err), ErrGet);
711    }
712    ok = WriteWebP(mux_single, config-&gt;output_);
713   ErrGet:
714    WebPDataClear(&amp;info.bitstream);
715    WebPMuxDelete(mux_single);
716    return ok &amp;&amp; !parse_error;
717  }
718  static int Process(const Config* config) {
719    WebPMux* mux = NULL;
720    WebPData chunk;
721    WebPMuxError err = WEBP_MUX_OK;
722    int ok = 1;
723    switch (config-&gt;action_type_) {
724      case ACTION_GET: {
725        ok = CreateMux(config-&gt;input_, &amp;mux);
726        if (!ok) goto Err2;
727        switch (config-&gt;type_) {
728          case FEATURE_ANMF:
729            ok = GetFrame(mux, config);
730            break;
731          case FEATURE_ICCP:
732          case FEATURE_EXIF:
733          case FEATURE_XMP:
734            err = WebPMuxGetChunk(mux, kFourccList[config-&gt;type_], &amp;chunk);
735            if (err != WEBP_MUX_OK) {
736              ERROR_GOTO3(&quot;ERROR (%s): Could not get the %s.\n&quot;,
737                          ErrorString(err), kDescriptions[config-&gt;type_], Err2);
738            }
739            ok = WriteData(config-&gt;output_, &amp;chunk);
740            break;
741          default:
742            ERROR_GOTO1(&quot;ERROR: Invalid feature for action &#x27;get&#x27;.\n&quot;, Err2);
743            break;
744        }
745        break;
746      }
747      case ACTION_SET: {
748        switch (config-&gt;type_) {
749          case FEATURE_ANMF: {
750            int i;
751            WebPMuxAnimParams params = { 0xFFFFFFFF, 0 };
752            mux = WebPMuxNew();
753            if (mux == NULL) {
754              ERROR_GOTO2(&quot;ERROR (%s): Could not allocate a mux object.\n&quot;,
755                          ErrorString(WEBP_MUX_MEMORY_ERROR), Err2);
756            }
757            for (i = 0; i &lt; config-&gt;arg_count_; ++i) {
758              switch (config-&gt;args_[i].subtype_) {
759                case SUBTYPE_BGCOLOR: {
760                  uint32_t bgcolor;
761                  ok = ParseBgcolorArgs(config-&gt;args_[i].params_, &amp;bgcolor);
762                  if (!ok) {
763                    ERROR_GOTO1(&quot;ERROR: Could not parse the background color \n&quot;,
764                                Err2);
765                  }
766                  params.bgcolor = bgcolor;
767                  break;
768                }
769                case SUBTYPE_LOOP: {
770                  int parse_error = 0;
771                  const int loop_count =
772                      ExUtilGetInt(config-&gt;args_[i].params_, 10, &amp;parse_error);
773                  if (loop_count &lt; 0 || loop_count &gt; 65535) {
774                    ERROR_GOTO1(&quot;ERROR: Loop count must be in the range 0 to &quot;
775                                &quot;65535.\n&quot;, Err2);
776                  }
777                  ok = !parse_error;
778                  if (!ok) goto Err2;
779                  params.loop_count = loop_count;
780                  break;
781                }
782                case SUBTYPE_ANMF: {
783                  WebPMuxFrameInfo frame;
784                  frame.id = WEBP_CHUNK_ANMF;
785                  ok = ExUtilReadFileToWebPData(config-&gt;args_[i].filename_,
786                                                &amp;frame.bitstream);
787                  if (!ok) goto Err2;
788                  ok = ParseFrameArgs(config-&gt;args_[i].params_, &amp;frame);
789                  if (!ok) {
790                    WebPDataClear(&amp;frame.bitstream);
791                    ERROR_GOTO1(&quot;ERROR: Could not parse frame properties.\n&quot;,
792                                Err2);
793                  }
794                  err = WebPMuxPushFrame(mux, &amp;frame, 1);
795                  WebPDataClear(&amp;frame.bitstream);
796                  if (err != WEBP_MUX_OK) {
797                    ERROR_GOTO3(&quot;ERROR (%s): Could not add a frame at index %d.&quot;
798                                &quot;\n&quot;, ErrorString(err), i, Err2);
799                  }
800                  break;
801                }
802                default: {
803                  ERROR_GOTO1(&quot;ERROR: Invalid subtype for &#x27;frame&#x27;&quot;, Err2);
804                  break;
805                }
806              }
807            }
808            err = WebPMuxSetAnimationParams(mux, &amp;params);
809            if (err != WEBP_MUX_OK) {
810              ERROR_GOTO2(&quot;ERROR (%s): Could not set animation parameters.\n&quot;,
811                          ErrorString(err), Err2);
812            }
813            break;
814          }
815          case FEATURE_ICCP:
816          case FEATURE_EXIF:
817          case FEATURE_XMP: {
818            ok = CreateMux(config-&gt;input_, &amp;mux);
819            if (!ok) goto Err2;
820            ok = ExUtilReadFileToWebPData(config-&gt;args_[0].filename_, &amp;chunk);
821            if (!ok) goto Err2;
822            err = WebPMuxSetChunk(mux, kFourccList[config-&gt;type_], &amp;chunk, 1);
823            free((void*)chunk.bytes);
824            if (err != WEBP_MUX_OK) {
825              ERROR_GOTO3(&quot;ERROR (%s): Could not set the %s.\n&quot;,
826                          ErrorString(err), kDescriptions[config-&gt;type_], Err2);
827            }
828            break;
829          }
830          default: {
831            ERROR_GOTO1(&quot;ERROR: Invalid feature for action &#x27;set&#x27;.\n&quot;, Err2);
832            break;
833          }
834        }
835        ok = WriteWebP(mux, config-&gt;output_);
836        break;
837      }
838      case ACTION_DURATION: {
839        int num_frames;
840        ok = CreateMux(config-&gt;input_, &amp;mux);
841        if (!ok) goto Err2;
842        err = WebPMuxNumChunks(mux, WEBP_CHUNK_ANMF, &amp;num_frames);
843        ok = (err == WEBP_MUX_OK);
844        if (!ok) {
845          ERROR_GOTO1(&quot;ERROR: can not parse the number of frames.\n&quot;, Err2);
846        }
847        if (num_frames == 0) {
848          fprintf(stderr, &quot;Doesn&#x27;t look like the source is animated. &quot;
849                          &quot;Skipping duration setting.\n&quot;);
850          ok = WriteWebP(mux, config-&gt;output_);
851          if (!ok) goto Err2;
852        } else {
853          int i;
854          int* durations = NULL;
855          WebPMux* new_mux = DuplicateMuxHeader(mux);
856          if (new_mux == NULL) goto Err2;
857          durations = (int*)WebPMalloc((size_t)num_frames * sizeof(*durations));
858          if (durations == NULL) goto Err2;
859          for (i = 0; i &lt; num_frames; ++i) durations[i] = -1;
860          for (i = 0; i &lt; config-&gt;arg_count_; ++i) {
861            int k;
862            int args[3];
863            int duration, start, end;
864            const int nb_args = ExUtilGetInts(config-&gt;args_[i].params_,
865                                              10, 3, args);
866            ok = (nb_args &gt;= 1);
867            if (!ok) goto Err3;
868            duration = args[0];
869            if (duration &lt; 0) {
870              ERROR_GOTO1(&quot;ERROR: duration must be strictly positive.\n&quot;, Err3);
871            }
872            if (nb_args == 1) {   
873              start = 1;
874              end = num_frames;
875            } else {
876              start = args[1];
877              if (start &lt;= 0) {
878                start = 1;
879              } else if (start &gt; num_frames) {
880                start = num_frames;
881              }
882              end = (nb_args &gt;= 3) ? args[2] : start;
883              if (end == 0 || end &gt; num_frames) end = num_frames;
884            }
885            for (k = start; k &lt;= end; ++k) {
886              assert(k &gt;= 1 &amp;&amp; k &lt;= num_frames);
887              durations[k - 1] = duration;
888            }
889          }
890          for (i = 1; i &lt;= num_frames; ++i) {
891            WebPMuxFrameInfo frame;
892            err = WebPMuxGetFrame(mux, i, &amp;frame);
893            if (err != WEBP_MUX_OK || frame.id != WEBP_CHUNK_ANMF) {
894              ERROR_GOTO2(&quot;ERROR: can not retrieve frame #%d.\n&quot;, i, Err3);
895            }
896            if (durations[i - 1] &gt;= 0) frame.duration = durations[i - 1];
897            err = WebPMuxPushFrame(new_mux, &amp;frame, 1);
898            if (err != WEBP_MUX_OK) {
899              ERROR_GOTO2(&quot;ERROR: error push frame data #%d\n&quot;, i, Err3);
900            }
901            WebPDataClear(&amp;frame.bitstream);
902          }
903          WebPMuxDelete(mux);
904          ok = WriteWebP(new_mux, config-&gt;output_);
905          mux = new_mux;  
906          new_mux = NULL;
907   Err3:
908          WebPFree(durations);
909          WebPMuxDelete(new_mux);
910          if (!ok) goto Err2;
911        }
912        break;
913      }
914      case ACTION_STRIP: {
915        ok = CreateMux(config-&gt;input_, &amp;mux);
916        if (!ok) goto Err2;
917        if (config-&gt;type_ == FEATURE_ICCP || config-&gt;type_ == FEATURE_EXIF ||
918            config-&gt;type_ == FEATURE_XMP) {
919          err = WebPMuxDeleteChunk(mux, kFourccList[config-&gt;type_]);
920          if (err != WEBP_MUX_OK) {
921            ERROR_GOTO3(&quot;ERROR (%s): Could not strip the %s.\n&quot;,
922                        ErrorString(err), kDescriptions[config-&gt;type_], Err2);
923          }
924        } else {
925          ERROR_GOTO1(&quot;ERROR: Invalid feature for action &#x27;strip&#x27;.\n&quot;, Err2);
926          break;
927        }
928        ok = WriteWebP(mux, config-&gt;output_);
929        break;
930      }
931      case ACTION_INFO: {
932        ok = CreateMux(config-&gt;input_, &amp;mux);
933        if (!ok) goto Err2;
934        ok = (DisplayInfo(mux) == WEBP_MUX_OK);
935        break;
936      }
937      default: {
938        assert(0);  
939        break;
940      }
941    }
942   Err2:
943    WebPMuxDelete(mux);
944    return ok;
945  }
946  int main(int argc, const char* argv[]) {
947    Config config;
948    int ok;
949    INIT_WARGV(argc, argv);
950    ok = InitializeConfig(argc - 1, argv + 1, &amp;config, GET_WARGV_OR_NULL());
951    if (ok) {
952      ok = Process(&amp;config);
953    } else {
954      PrintHelp();
955    }
956    DeleteConfig(&amp;config);
957    FREE_WARGV_AND_RETURN(!ok);
958  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from PINRemoteImage-MDEwOlJlcG9zaXRvcnkzOTUzNzEwMw==-flat-webpmux.c</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from PINRemoteImage-MDEwOlJlcG9zaXRvcnkzOTUzNzEwMw==-flat-webpmux.c</div>
                </div>
                <div class="column column_space"><pre><code>109    assert(err == WEBP_MUX_OK);  
110    printf(&quot;Canvas size: %d x %d\n&quot;, width, height);
111    err = WebPMuxGetFeatures(mux, &amp;flag);
</pre></code></div>
                <div class="column column_space"><pre><code>134      assert(err == WEBP_MUX_OK);
135      printf(&quot;Number of %ss: %d\n&quot;, type_str, nFrames);
136      if (nFrames &gt; 0) {
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    