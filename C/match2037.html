<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML><HEAD><TITLE>Matches for inf-text-gtk-buffer.c & inf-gtk-permissions-dialog.c</TITLE>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
</HEAD>
<body>
  <div style="align-items: center; display: flex; justify-content: space-around;">
    <div>
      <h3 align="center">
Matches for inf-text-gtk-buffer.c & inf-gtk-permissions-dialog.c
      </h3>
      <h1 align="center">
        5.0%
      </h1>
      <center>
        <a href="index.html" target="_top">
          INDEX
        </a>
        <span>-</span>
        <a href="help-en.html" target="_top">
          HELP
        </a>
      </center>
    </div>
    <div>
<TABLE BORDER="1" CELLSPACING="0" BGCOLOR="#d0d0d0">
<TR><TH><TH>inf-text-gtk-buffer.c (5.8884296%)<TH>inf-gtk-permissions-dialog.c (4.344512%)<TH>Tokens
<TR><TD BGCOLOR="#0000ff"><FONT COLOR="#0000ff">-</FONT><TD><A HREF="javascript:ZweiFrames('match2037-0.html#0',2,'match2037-1.html#0',3)" NAME="0">(1436-1462)<TD><A HREF="javascript:ZweiFrames('match2037-0.html#0',2,'match2037-1.html#0',3)" NAME="0">(2778-2804)</A><TD ALIGN=center><FONT COLOR="#ff0000">16</FONT>
<TR><TD BGCOLOR="#f63526"><FONT COLOR="#f63526">-</FONT><TD><A HREF="javascript:ZweiFrames('match2037-0.html#1',2,'match2037-1.html#1',3)" NAME="1">(82-129)<TD><A HREF="javascript:ZweiFrames('match2037-0.html#1',2,'match2037-1.html#1',3)" NAME="1">(55-119)</A><TD ALIGN=center><FONT COLOR="#ef0000">15</FONT>
<TR><TD BGCOLOR="#980517"><FONT COLOR="#980517">-</FONT><TD><A HREF="javascript:ZweiFrames('match2037-0.html#2',2,'match2037-1.html#2',3)" NAME="2">(1370-1393)<TD><A HREF="javascript:ZweiFrames('match2037-0.html#2',2,'match2037-1.html#2',3)" NAME="2">(2747-2769)</A><TD ALIGN=center><FONT COLOR="#cf0000">13</FONT>
<TR><TD BGCOLOR="#53858b"><FONT COLOR="#53858b">-</FONT><TD><A HREF="javascript:ZweiFrames('match2037-0.html#3',2,'match2037-1.html#3',3)" NAME="3">(1259-1327)<TD><A HREF="javascript:ZweiFrames('match2037-0.html#3',2,'match2037-1.html#3',3)" NAME="3">(1770-1799)</A><TD ALIGN=center><FONT COLOR="#cf0000">13</FONT>
</TABLE>
    </div>
  </div>
  <hr>
  <div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>inf-text-gtk-buffer.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
/* libinfinity - a GObject-based infinote implementation
 * Copyright (C) 2007-2015 Armin Burgmeier &lt;armin@arbur.net&gt;
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston,
 * MA 02110-1301, USA.
 */

/**
 * SECTION:inf-text-gtk-buffer
 * @title: InfTextGtkBuffer
 * @short_description: Synchronizing a text session with a #GtkTextBuffer
 * @include: libinftextgtk/inf-text-gtk-buffer.h
 * @see_also: #InfTextBuffer
 * @stability: Unstable
 *
 * #InfTextGtkBuffer is an implementation of the #InfTextBuffer interface. It
 * can therefore be used as a backend for #InfTextSession&lt;!-- --&gt;s to store
 * their text. The buffer is implemented by using a #GtkTextBuffer as
 * storage. This way the text document can be displayed using a #GtkTextView
 * such that only one copy of the text is held in memory, which is used both
 * by the user interface toolkit and the text synchronization functionality.
 *
 * If external changes are made to the #GtkTextBuffer, for example by a user
 * typing into a #GtkTextView, then the text is synchronized to other
 * participants of the session. For this purpose,
 * inf_text_gtk_buffer_set_active_user() should be called with a user that
 * was previously joined into the session using inf_session_proxy_join_user().
 * If there is no local user in the session, no modifications to the buffer
 * must be made because they cannot be synchronized to other participants.
 *
 * This class also takes care of setting background colors for the text to
 * indicate which user wrote what text, by adding corresponding
 * #GtkTextTag&lt;!-- --&gt;s to the document. The function
 * inf_text_gtk_buffer_set_show_user_colors() to turn on or off the colored
 * background. Even if background coloring is turned off, the text is still
 * tagged according to the authorship, so that coloring can be turned on at a
 * later point or so that the authorship can still be queried for other means,
 * such as in a &quot;blame&quot; kind of functionality.
 */

#include &lt;libinftextgtk/inf-text-gtk-buffer.h&gt;
#include &lt;libinftext/inf-text-buffer.h&gt;

#include &lt;libinfinity/inf-signals.h&gt;

#include &lt;string.h&gt; /* for strlen() */

struct _InfTextBufferIter {
  GtkTextIter begin;
  GtkTextIter end;
  InfTextUser* user;
};

typedef struct _InfTextGtkBufferRecord InfTextGtkBufferRecord;
struct _InfTextGtkBufferRecord {
  gboolean insert;
  guint char_count;
  guint position;
  InfTextChunk* chunk;
  gboolean applied;
  InfTextGtkBufferRecord* next;
};

typedef struct _InfTextGtkBufferUserTags InfTextGtkBufferUserTags;
struct _InfTextGtkBufferUserTags {
  InfTextGtkBuffer* buffer;
<A NAME="1"></A>  InfTextUser* user;
  GtkTextTag* colored_tag;
  GtkTextTag* colorless_tag;
<FONT color="#f63526"><A HREF="javascript:ZweiFrames('match2037-1.html#1',3,'match2037-top.html#1',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>};

typedef struct _InfTextGtkBufferTagRemove InfTextGtkBufferTagRemove;
struct _InfTextGtkBufferTagRemove {
  GtkTextBuffer* buffer;
  GtkTextIter begin_iter;
  GtkTextIter end_iter;
  InfTextGtkBufferUserTags* ignore_tags;
};

typedef struct _InfTextGtkBufferPrivate InfTextGtkBufferPrivate;
struct _InfTextGtkBufferPrivate {
  GtkTextBuffer* buffer;
  InfUserTable* user_table;
  GHashTable* user_tags;

  InfTextGtkBufferRecord* record;

  gboolean show_user_colors;

  InfTextUser* active_user;
  gboolean wake_on_cursor_movement;

  gdouble saturation;
  gdouble value;
  gdouble alpha;
};

enum {
  PROP_0,

  PROP_BUFFER,
  PROP_USER_TABLE,
  PROP_ACTIVE_USER,
  PROP_WAKE_ON_CURSOR_MOVEMENT,
  PROP_SHOW_USER_COLORS,

  PROP_SATURATION,
  PROP_VALUE,
  PROP_ALPHA,

  /* overriden */
  PROP_MODIFIED
};

#define INF_TEXT_GTK_BUFFER_PRIVATE(obj) (G_TYPE_INSTANCE_GET_PRIVATE((obj), INF_TEXT_GTK_TYPE_BUFFER, InfTextGtkBufferPrivate))

static GQuark inf_text_gtk_buffer_tag_user_quark;</B></FONT>

static void inf_text_gtk_buffer_buffer_iface_init(InfBufferInterface* iface);
static void inf_text_gtk_buffer_text_buffer_iface_init(InfTextBufferInterface* iface);
G_DEFINE_TYPE_WITH_CODE(InfTextGtkBuffer, inf_text_gtk_buffer, G_TYPE_OBJECT,
  G_ADD_PRIVATE(InfTextGtkBuffer)
  G_IMPLEMENT_INTERFACE(INF_TYPE_BUFFER, inf_text_gtk_buffer_buffer_iface_init)
  G_IMPLEMENT_INTERFACE(INF_TEXT_TYPE_BUFFER, inf_text_gtk_buffer_text_buffer_iface_init))

static void
inf_text_gtk_update_tag_color(InfTextGtkBuffer* buffer,
                              GtkTextTag* tag,
                              InfTextUser* user)
{
  InfTextGtkBufferPrivate* priv;
  gdouble hue;
  gdouble saturation;
  gdouble value;
  GdkRGBA rgba;

  priv = INF_TEXT_GTK_BUFFER_PRIVATE(buffer);

  hue = inf_text_user_get_hue(user);
  saturation = priv-&gt;saturation;
  value = priv-&gt;value;

  gtk_hsv_to_rgb(hue, saturation, value, &amp;rgba.red, &amp;rgba.green, &amp;rgba.blue);
  rgba.alpha = priv-&gt;alpha;

  g_object_set(G_OBJECT(tag), &quot;background-rgba&quot;, &amp;rgba, NULL);
}

static void
inf_text_gtk_user_notify_hue_cb(GObject* object,
                                GParamSpec* pspec,
                                gpointer user_data)
{
  InfTextGtkBuffer* buffer;
  InfTextGtkBufferPrivate* priv;
  guint user_id;
  InfTextGtkBufferUserTags* tags;

  buffer = INF_TEXT_GTK_BUFFER(user_data);
  priv = INF_TEXT_GTK_BUFFER_PRIVATE(buffer);
  user_id = inf_user_get_id(INF_USER(object));
  tags = g_hash_table_lookup(priv-&gt;user_tags, GUINT_TO_POINTER(user_id));
  g_assert(tags != NULL &amp;&amp; tags-&gt;colored_tag != NULL);

  inf_text_gtk_update_tag_color(
    buffer,
    tags-&gt;colored_tag,
    INF_TEXT_USER(object)
  );
}

static void
inf_text_gtk_buffer_user_tags_free(gpointer user_tags)
{
  InfTextGtkBufferUserTags* tags;
  tags = (InfTextGtkBufferUserTags*)user_tags;

  if(tags-&gt;colored_tag)
  {
    inf_signal_handlers_disconnect_by_func(
      tags-&gt;user,
      G_CALLBACK(inf_text_gtk_user_notify_hue_cb),
      tags-&gt;buffer
    );

    g_object_unref(tags-&gt;colored_tag);
  }

  if(tags-&gt;colorless_tag)
    g_object_unref(tags-&gt;colorless_tag);
  g_slice_free(InfTextGtkBufferUserTags, tags);
}

static InfTextGtkBufferUserTags*
inf_text_gtk_buffer_get_user_tags(InfTextGtkBuffer* buffer,
                                  guint user_id)
{
  InfTextGtkBufferPrivate* priv;
  InfTextGtkBufferUserTags* tags;
  InfUser* user;

  priv = INF_TEXT_GTK_BUFFER_PRIVATE(buffer);

  if(user_id == 0)
    return NULL;

  tags = g_hash_table_lookup(priv-&gt;user_tags, GUINT_TO_POINTER(user_id));

  if(tags != NULL)
  {
    return tags;
  }
  else
  {
    user = inf_user_table_lookup_user_by_id(priv-&gt;user_table, user_id);
    g_assert(INF_TEXT_IS_USER(user));

    tags = g_slice_new(InfTextGtkBufferUserTags);
    tags-&gt;buffer = buffer;
    tags-&gt;user = INF_TEXT_USER(user);
    tags-&gt;colored_tag = NULL;
    tags-&gt;colorless_tag = NULL;
    g_hash_table_insert(priv-&gt;user_tags, GUINT_TO_POINTER(user_id), tags);
    return tags;
  }
}

static GtkTextTag*
inf_text_gtk_buffer_get_user_tag(InfTextGtkBuffer* buffer,
                                 InfTextGtkBufferUserTags* user_tags,
                                 gboolean colored)
{
  InfTextGtkBufferPrivate* priv;
  GtkTextTagTable* table;
  GtkTextTag** tag;
  gchar* tag_name;
  guint user_id;
  const gchar* colorstr;

  priv = INF_TEXT_GTK_BUFFER_PRIVATE(buffer);
  tag = colored ? &amp;user_tags-&gt;colored_tag : &amp;user_tags-&gt;colorless_tag;
  if(*tag != NULL) return *tag;

  user_id = 0;
  if(user_tags-&gt;user != NULL)
    user_id = inf_user_get_id(INF_USER(user_tags-&gt;user));
  colorstr = colored ? &quot;colored&quot; : &quot;colorless&quot;;

  tag_name = g_strdup_printf(&quot;inftextgtk-user-%s-%u&quot;, colorstr, user_id);
  *tag = gtk_text_tag_new(tag_name);
  g_free(tag_name);

  table = gtk_text_buffer_get_tag_table(priv-&gt;buffer);
  gtk_text_tag_table_add(table, *tag);

  /* Set lowest priority for author tags, so GtkSourceView's bracket
   * matching highlight tags and highlight of FIXME and such in comments is
   * shown instead of the user color. */
  gtk_text_tag_set_priority(*tag, 0);

  g_object_set_qdata(
    G_OBJECT(*tag),
    inf_text_gtk_buffer_tag_user_quark,
    user_tags-&gt;user
  );

  if(colored)
  {
    g_signal_connect(
      G_OBJECT(user_tags-&gt;user),
      &quot;notify::hue&quot;,
      G_CALLBACK(inf_text_gtk_user_notify_hue_cb),
      buffer
    );

    inf_text_gtk_update_tag_color(buffer, *tag, user_tags-&gt;user);
  }

  return *tag;
}

static InfTextUser*
inf_text_gtk_buffer_author_from_tag(GtkTextTag* tag)
{
  gpointer author_ptr;

  author_ptr = g_object_get_qdata(
    G_OBJECT(tag),
    inf_text_gtk_buffer_tag_user_quark
  );

  return INF_TEXT_USER(author_ptr);
}

static InfTextUser*
inf_text_gtk_buffer_iter_list_contains_author_tag(GSList* tag_list)
{
  GSList* item;
  InfTextUser* author;

  for(item = tag_list; item != NULL; item = g_slist_next(item))
  {
    author = inf_text_gtk_buffer_author_from_tag(GTK_TEXT_TAG(item-&gt;data));
    if(author != NULL) return author;
  }

  return NULL;
}

static InfTextUser*
inf_text_gtk_buffer_iter_get_author(GtkTextIter* location)
{
  GSList* tag_list;
  InfTextUser* author;

  tag_list = gtk_text_iter_get_tags(location);
  author = inf_text_gtk_buffer_iter_list_contains_author_tag(tag_list);
  g_slist_free(tag_list);

  return author;
}

static gboolean
inf_text_gtk_buffer_iter_is_author_toggle(const GtkTextIter* iter,
                                          InfTextUser** toggled_on,
                                          InfTextUser** toggled_off)
{
  GSList* tag_list;
  InfTextUser* author_on;
  InfTextUser* author_off;

  tag_list = gtk_text_iter_get_toggled_tags(iter, TRUE);
  author_on = inf_text_gtk_buffer_iter_list_contains_author_tag(tag_list);
  g_slist_free(tag_list);

  /* We need to check both the tags that are toggled on and the tags that
   * are toggled off at this point, because text that is not written by
   * anyone specific (author NULL) does not count as author tag. */
  if(author_on == NULL || toggled_off != NULL)
  {
    tag_list = gtk_text_iter_get_toggled_tags(iter, FALSE);
    author_off = inf_text_gtk_buffer_iter_list_contains_author_tag(tag_list);
    g_slist_free(tag_list);
  }

  if(author_on == NULL &amp;&amp; author_off == NULL)
    if(!gtk_text_iter_is_start(iter) &amp;&amp; !gtk_text_iter_is_end(iter))
      return FALSE;

  if(toggled_on) *toggled_on = author_on;
  if(toggled_off) *toggled_off = author_off;
  return TRUE;
}

static void
inf_text_gtk_buffer_iter_next_author_toggle(GtkTextIter* iter,
                                            InfTextUser** user_on,
                                            InfTextUser** user_off)
{
  gboolean is_author_toggle;

  do
  {
    gtk_text_iter_forward_to_tag_toggle(iter, NULL);

    is_author_toggle = inf_text_gtk_buffer_iter_is_author_toggle(
      iter,
      user_on,
      user_off
    );
  } while(!is_author_toggle);
}

static void
inf_text_gtk_buffer_iter_prev_author_toggle(GtkTextIter* iter,
                                            InfTextUser** user_on,
                                            InfTextUser** user_off)
{
  gboolean is_author_toggle;

  do
  {
    gtk_text_iter_backward_to_tag_toggle(iter, NULL);

    is_author_toggle = inf_text_gtk_buffer_iter_is_author_toggle(
      iter,
      user_on,
      user_off
    );
  } while(!is_author_toggle);
}

static void
inf_text_gtk_buffer_ensure_author_tags_priority_foreach_func(GtkTextTag* tag,
                                                             gpointer data)
{
  InfTextUser* author;
  author = inf_text_gtk_buffer_author_from_tag(tag);

  if(author != NULL)
    gtk_text_tag_set_priority(tag, 0);
}

static void
inf_text_gtk_buffer_update_user_color_tag_table_foreach_func(GtkTextTag* tag,
                                                             gpointer data)
{
  InfTextGtkBuffer* buffer;
  InfTextGtkBufferPrivate* priv;
  InfTextUser* author;

  buffer = INF_TEXT_GTK_BUFFER(data);
  priv = INF_TEXT_GTK_BUFFER_PRIVATE(buffer);
  author = inf_text_gtk_buffer_author_from_tag(tag);

  if(author != NULL)
    inf_text_gtk_update_tag_color(buffer, tag, author);
}

/* Required by inf_text_gtk_buffer_record_signal() and
 * inf_text_gtk_buffer_mark_set_cb() */
static void
inf_text_gtk_buffer_active_user_selection_changed_cb(InfTextUser* user,
                                                     guint position,
                                                     gint length,
                                                     gboolean by_request,
                                                     gpointer user_data);

/* Required by inf_text_gtk_buffer_record_signal() and
 * inf_text_gtk_buffer_mark_set_cb() */
static void
inf_text_gtk_buffer_active_user_notify_status_cb(GObject* object,
                                                 GParamSpec* pspec,
                                                 gpointer user_data);

static void
inf_text_gtk_buffer_apply_tag_cb(GtkTextBuffer* gtk_buffer,
                                 GtkTextTag* tag,
                                 GtkTextIter* start,
                                 GtkTextIter* end,
                                 gpointer user_data)
{
  /* Don't allow author tags to be applied by default. GTK+ seems to do this
   * when copy+pasting text from the text buffer itself, but we want to make
   * sure that a given segment of text has always a unique author set. */
  if(inf_text_gtk_buffer_author_from_tag(tag) != NULL)
    g_signal_stop_emission_by_name(G_OBJECT(gtk_buffer), &quot;apply-tag&quot;);
}

static void
inf_text_gtk_buffer_buffer_insert_text_tag_table_foreach_func(GtkTextTag* tag,
                                                              gpointer data)
{
  InfTextGtkBufferTagRemove* tag_remove;
  tag_remove = (InfTextGtkBufferTagRemove*)data;

  if(tag_remove-&gt;ignore_tags == NULL ||
     (tag != tag_remove-&gt;ignore_tags-&gt;colored_tag &amp;&amp;
      tag != tag_remove-&gt;ignore_tags-&gt;colorless_tag))
  {
    gtk_text_buffer_remove_tag(
      tag_remove-&gt;buffer,
      tag,
      &amp;tag_remove-&gt;begin_iter,
      &amp;tag_remove-&gt;end_iter
    );
  }
}

/* Record tracking:
 * This is to allow and correctly handle nested emissions of GtkTextBuffer's
 * insert-text/delete-range signals. The text-inserted and text-erased
 * signals of InfTextBuffer need to be emitted right after the operation was
 * applied to the buffer which is why we need some bookkeeping here. */

#ifndef G_DISABLE_ASSERT
/* Check whether the top record has been applied correctly to the buffer */
static gboolean
inf_text_gtk_buffer_record_check(InfTextGtkBuffer* buffer,
                                 InfTextGtkBufferRecord* record)
{
  InfTextGtkBufferPrivate* priv;
  InfTextChunk* chunk;
  guint text_len;
  guint buf_len;
  gpointer buf_text;
  gpointer chunk_text;
  gsize buf_bytes;
  gsize chunk_bytes;
  int result;

  priv = INF_TEXT_GTK_BUFFER_PRIVATE(buffer);

  text_len = inf_text_chunk_get_length(record-&gt;chunk);
  buf_len = gtk_text_buffer_get_char_count(priv-&gt;buffer);

  /* We can only check insertions */
  if(record-&gt;insert)
  {
    if(record-&gt;char_count + text_len != buf_len)
      return FALSE;
    if(record-&gt;position + text_len &gt; buf_len)
      return FALSE;

    chunk = inf_text_buffer_get_slice(
      INF_TEXT_BUFFER(buffer),
      record-&gt;position,
      text_len
    );

    buf_text = inf_text_chunk_get_text(record-&gt;chunk, &amp;buf_bytes);
    chunk_text = inf_text_chunk_get_text(chunk, &amp;chunk_bytes);
    inf_text_chunk_free(chunk);

    if(buf_bytes == chunk_bytes)
      result = memcmp(buf_text, chunk_text, buf_bytes);
    else
      result = -1;

    g_free(buf_text);
    g_free(chunk_text);
    
    if(result != 0) return FALSE;
  }
  else
  {
    if(text_len &gt; record-&gt;char_count)
      return FALSE;
    if(record-&gt;char_count - text_len != buf_len)
      return FALSE;
  }

  return TRUE;
}
#endif

static void
inf_text_gtk_buffer_record_transform(InfTextGtkBufferRecord* record,
                                     InfTextGtkBufferRecord* against)
{
  guint record_len;
  guint against_len;

  /* What we do here is common sense; in fact this depends on how
   * insert-text/delete-range signal handlers do revalidation of iters if
   * they insert/erase text themselves. We rely on them doing it exactly
   * this way currently, otherwise we cannot identify new/erased text to
   * emit text-inserted/text-erased for, resulting in new/erased text not
   * being transmitted to remote users, in turn resulting in lost session
   * consistency. This is why the inf_text_gtk_buffer_record_check()
   * check will fail if this happens. */
  g_assert(record-&gt;applied == FALSE);
  g_assert(against-&gt;applied == TRUE);

  record_len = inf_text_chunk_get_length(record-&gt;chunk);
  against_len = inf_text_chunk_get_length(against-&gt;chunk);

  if(record-&gt;insert &amp;&amp; against-&gt;insert)
  {
    if(record-&gt;position &gt;= against-&gt;position)
      record-&gt;position += against_len;
  }
  else if(record-&gt;insert &amp;&amp; !against-&gt;insert)
  {
    if(record-&gt;position &gt;= against-&gt;position + against_len)
      record-&gt;position -= against_len;
    else if(record-&gt;position &gt;= against-&gt;position)
      record-&gt;position = against-&gt;position;
  }
  else if(!record-&gt;insert &amp;&amp; against-&gt;insert)
  {
    if(record-&gt;position &gt;= against-&gt;position)
    {
      record-&gt;position += against-&gt;position;
    }
    else if(record-&gt;position &lt; against-&gt;position &amp;&amp;
            record-&gt;position + record_len &gt; against-&gt;position)
    {
      /* Add text right into deletion range... */
      inf_text_chunk_insert_chunk(
        record-&gt;chunk,
        against-&gt;position - record-&gt;position,
        against-&gt;chunk
      );
    }
  }
  else if(!record-&gt;insert &amp;&amp; !against-&gt;insert)
  {
    if(against-&gt;position + against_len &lt;= record-&gt;position + record_len)
    {
      record-&gt;position -= against_len;
    }
    else if(against-&gt;position + against_len &gt; record-&gt;position &amp;&amp;
            against-&gt;position + against_len &lt;= record-&gt;position + record_len)
    {
      record-&gt;position = against-&gt;position;
      inf_text_chunk_erase(
        record-&gt;chunk,
        0,
        against-&gt;position + against_len - record-&gt;position
      );
    }
    else if(against-&gt;position &lt;= record-&gt;position &amp;&amp;
            against-&gt;position + against_len &gt;= record-&gt;position + record_len)
    {
      record-&gt;position = against-&gt;position;
      inf_text_chunk_erase(
        record-&gt;chunk,
        0,
        inf_text_chunk_get_length(record-&gt;chunk)
      );
    }
    else if(against-&gt;position &gt;= record-&gt;position &amp;&amp;
            against-&gt;position + against_len &lt;= record-&gt;position + record_len)
    {
      inf_text_chunk_erase(
        record-&gt;chunk,
        against-&gt;position - record-&gt;position,
        inf_text_chunk_get_length(against-&gt;chunk)
      );
    }
    else if(against-&gt;position &gt;= record-&gt;position &amp;&amp;
            against-&gt;position + against_len &gt;= record-&gt;position + record_len)
    {
      inf_text_chunk_erase(
        record-&gt;chunk,
        against-&gt;position - record-&gt;position,
        record-&gt;position + record_len - against-&gt;position
      );
    }
  }

  /* Revalidate char count */
  if(against-&gt;insert)
  {
    record-&gt;char_count += against_len;
  }
  else
  {
    g_assert(record-&gt;char_count &gt;= against_len);
    record-&gt;char_count -= against_len;
  }
}

static void
inf_text_gtk_buffer_record_signal(InfTextGtkBuffer* buffer,
                                  InfTextGtkBufferRecord* record)
{
  InfTextGtkBufferPrivate* priv;
  InfTextGtkBufferRecord* rec;
  InfTextGtkBufferTagRemove tag_remove;
  GtkTextTag* tag;

  priv = INF_TEXT_GTK_BUFFER_PRIVATE(buffer);

  g_assert(priv-&gt;active_user != NULL);
  g_assert(record-&gt;applied == FALSE);

  g_assert(inf_text_gtk_buffer_record_check(buffer, record));

  record-&gt;applied = TRUE;
  for(rec = record-&gt;next; rec != NULL; rec = rec-&gt;next)
    if(!rec-&gt;applied)
      inf_text_gtk_buffer_record_transform(rec-&gt;next, record);

  if(record-&gt;insert)
  {
    /* Allow author tag changes within this function: */
    inf_signal_handlers_block_by_func(
      G_OBJECT(priv-&gt;buffer),
      G_CALLBACK(inf_text_gtk_buffer_apply_tag_cb),
      buffer
    );

    /* Tag the inserted text with the user's color */
    tag_remove.buffer = priv-&gt;buffer;

    tag_remove.ignore_tags = inf_text_gtk_buffer_get_user_tags(
      buffer,
      inf_user_get_id(INF_USER(priv-&gt;active_user))
    );
    g_assert(tag_remove.ignore_tags != NULL);

    tag = inf_text_gtk_buffer_get_user_tag(
      buffer,
      tag_remove.ignore_tags,
      priv-&gt;show_user_colors
    );

    /* Remove other user tags, if any */
    gtk_text_buffer_get_iter_at_offset(
      priv-&gt;buffer,
      &amp;tag_remove.begin_iter,
      record-&gt;position
    );

    gtk_text_buffer_get_iter_at_offset(
      priv-&gt;buffer,
      &amp;tag_remove.end_iter,
      record-&gt;position + inf_text_chunk_get_length(record-&gt;chunk)
    );

    gtk_text_tag_table_foreach(
      gtk_text_buffer_get_tag_table(tag_remove.buffer),
      inf_text_gtk_buffer_buffer_insert_text_tag_table_foreach_func,
      &amp;tag_remove
    );

    /* Apply tag for this particular user */
    gtk_text_buffer_apply_tag(
      priv-&gt;buffer,
      tag,
      &amp;tag_remove.begin_iter,
      &amp;tag_remove.end_iter
    );

    /* Allow author tag changes within this function: */
    inf_signal_handlers_unblock_by_func(
      G_OBJECT(priv-&gt;buffer),
      G_CALLBACK(inf_text_gtk_buffer_apply_tag_cb),
      buffer
    );
  }

  /* Block the notify_status signal handler of the active user. That signal
   * handler syncs the cursor position of the user to the insertion mark of
   * the TextBuffer when the user becomes active again. However, when we
   * insert or erase text, then this will be updated anyway. */
  inf_signal_handlers_block_by_func(
    G_OBJECT(priv-&gt;active_user),
    G_CALLBACK(inf_text_gtk_buffer_active_user_notify_status_cb),
    buffer
  );

  /* Block selection-changed of active user. This would try to resync the 
   * buffer markers, but GtkTextBuffer already did this for us. */
  inf_signal_handlers_block_by_func(
    G_OBJECT(priv-&gt;active_user),
    G_CALLBACK(inf_text_gtk_buffer_active_user_selection_changed_cb),
    buffer
  );

  if(record-&gt;insert)
  {
    inf_text_buffer_text_inserted(
      INF_TEXT_BUFFER(buffer),
      record-&gt;position,
      record-&gt;chunk,
      INF_USER(priv-&gt;active_user)
    );
  }
  else
  {
    inf_text_buffer_text_erased(
      INF_TEXT_BUFFER(buffer),
      record-&gt;position,
      record-&gt;chunk,
      INF_USER(priv-&gt;active_user)
    );
  }

  inf_signal_handlers_unblock_by_func(
    G_OBJECT(priv-&gt;active_user),
    G_CALLBACK(inf_text_gtk_buffer_active_user_notify_status_cb),
    buffer
  );

  inf_signal_handlers_unblock_by_func(
    G_OBJECT(priv-&gt;active_user),
    G_CALLBACK(inf_text_gtk_buffer_active_user_selection_changed_cb),
    buffer
  );
}

static void
inf_text_gtk_buffer_push_record(InfTextGtkBuffer* buffer,
                                gboolean insert,
                                guint position,
                                InfTextChunk* chunk)
{
  InfTextGtkBufferPrivate* priv;
  InfTextGtkBufferRecord* rec;

  priv = INF_TEXT_GTK_BUFFER_PRIVATE(buffer);

  rec = priv-&gt;record;

  priv-&gt;record = g_slice_new(InfTextGtkBufferRecord);
  priv-&gt;record-&gt;insert = insert;
  priv-&gt;record-&gt;char_count = gtk_text_buffer_get_char_count(priv-&gt;buffer);
  priv-&gt;record-&gt;position = position;
  priv-&gt;record-&gt;chunk = chunk;
  priv-&gt;record-&gt;applied = FALSE;
  priv-&gt;record-&gt;next = rec;

  /* It is enough to check whether the top record was applied to the buffer,
   * since, for previous records we would have been notified in a previous
   * callback already. */
  if(rec != NULL &amp;&amp; rec-&gt;applied == FALSE)
  {
    /* If char count differs then the previous record has already been applied
     * (that is the default handler ran but not our after handler, so
     * probably another after handler inserted new text). */
    /* TODO: This does not work if length of record is zero */
    if(rec-&gt;char_count != (guint)gtk_text_buffer_get_char_count(priv-&gt;buffer))
    {
      /* This record has been applied already, so signal. */
      inf_text_gtk_buffer_record_signal(buffer, rec);

#ifndef G_ASSERT_DISABLED
      /* Outer records would already have been signalled by previous signal
       * handler invocations if they were applied. */
      for(; rec != NULL; rec = rec-&gt;next)
      {
        g_assert(
          rec-&gt;applied == TRUE ||
          rec-&gt;char_count ==
            (guint)gtk_text_buffer_get_char_count(priv-&gt;buffer)
        );
      }
#endif
    }
  }
}

static void
inf_text_gtk_buffer_pop_record(InfTextGtkBuffer* buffer)
{
  InfTextGtkBufferPrivate* priv;
  InfTextGtkBufferRecord* rec;
  guint char_count;
  guint length;

  priv = INF_TEXT_GTK_BUFFER_PRIVATE(buffer);

  g_assert(priv-&gt;record != NULL);
  if(!priv-&gt;record-&gt;applied)
  {
    length = inf_text_chunk_get_length(priv-&gt;record-&gt;chunk);
    char_count = gtk_text_buffer_get_char_count(priv-&gt;buffer);

    if(priv-&gt;record-&gt;insert)
    {
      g_assert(priv-&gt;record-&gt;char_count + length == char_count);
    }
    else
    {
      g_assert(priv-&gt;record-&gt;char_count &gt;= length);
      g_assert(priv-&gt;record-&gt;char_count - length == char_count);
    }

    /* Signal application */
    inf_text_gtk_buffer_record_signal(buffer, priv-&gt;record);
  }

  rec = priv-&gt;record;
  priv-&gt;record = rec-&gt;next;

  inf_text_chunk_free(rec-&gt;chunk);
  g_slice_free(InfTextGtkBufferRecord, rec);
}

static void
inf_text_gtk_buffer_insert_text_cb_before(GtkTextBuffer* gtk_buffer,
                                          GtkTextIter* location,
                                          gchar* text,
                                          gint len,
                                          gpointer user_data)
{
  InfTextGtkBuffer* buffer;
  InfTextGtkBufferPrivate* priv;
  InfTextChunk* chunk;

  buffer = INF_TEXT_GTK_BUFFER(user_data);
  priv = INF_TEXT_GTK_BUFFER_PRIVATE(buffer);

  g_assert(priv-&gt;active_user != NULL);
  chunk = inf_text_chunk_new(&quot;UTF-8&quot;);

  inf_text_chunk_insert_text(
    chunk,
    0,
    text,
    len,
    g_utf8_strlen(text, len),
    inf_user_get_id(INF_USER(priv-&gt;active_user))
  );

  inf_text_gtk_buffer_push_record(
    buffer,
    TRUE,
    gtk_text_iter_get_offset(location),
    chunk
  );
}

static void
inf_text_gtk_buffer_insert_text_cb_after(GtkTextBuffer* gtk_buffer,
                                         GtkTextIter* location,
                                         gchar* text,
                                         gint len,
                                         gpointer user_data)
{
  InfTextGtkBuffer* buffer;
  InfTextGtkBufferPrivate* priv;
  gpointer rec_text;
  gsize bytes;

  buffer = INF_TEXT_GTK_BUFFER(user_data);
  priv = INF_TEXT_GTK_BUFFER_PRIVATE(buffer);

  g_assert(priv-&gt;record != NULL);
  g_assert(priv-&gt;record-&gt;insert == TRUE);

#ifndef G_ASSERT_DISABLED
  if(priv-&gt;record-&gt;applied == FALSE)
  {
    g_assert(
      priv-&gt;record-&gt;position +
        inf_text_chunk_get_length(priv-&gt;record-&gt;chunk) ==
      (guint)gtk_text_iter_get_offset(location)
    );

    rec_text = inf_text_chunk_get_text(priv-&gt;record-&gt;chunk, &amp;bytes);
    g_assert(bytes == (gsize)len);
    g_assert(memcmp(text, rec_text, bytes) == 0);
    g_free(rec_text);
  }
#endif

  inf_text_gtk_buffer_pop_record(buffer);
}

static void
inf_text_gtk_buffer_delete_range_cb_before(GtkTextBuffer* gtk_buffer,
                                           GtkTextIter* begin,
                                           GtkTextIter* end,
                                           gpointer user_data)
{
  InfTextGtkBuffer* buffer;
  InfTextGtkBufferPrivate* priv;
  guint begin_offset;
  guint end_offset;
  InfTextChunk* chunk;

  buffer = INF_TEXT_GTK_BUFFER(user_data);
  priv = INF_TEXT_GTK_BUFFER_PRIVATE(buffer);

  begin_offset = gtk_text_iter_get_offset(begin);
  end_offset = gtk_text_iter_get_offset(end);

  chunk = inf_text_buffer_get_slice(
    INF_TEXT_BUFFER(buffer),
    begin_offset,
    end_offset - begin_offset
  );

  inf_text_gtk_buffer_push_record(buffer, FALSE, begin_offset, chunk);
}

static void
inf_text_gtk_buffer_delete_range_cb_after(GtkTextBuffer* gtk_buffer,
                                          GtkTextIter* begin,
                                          GtkTextIter* end,
                                          gpointer user_data)
{
  InfTextGtkBuffer* buffer;
  InfTextGtkBufferPrivate* priv;

  buffer = INF_TEXT_GTK_BUFFER(user_data);
  priv = INF_TEXT_GTK_BUFFER_PRIVATE(buffer);
  
  g_assert(priv-&gt;record != NULL);
  g_assert(priv-&gt;record-&gt;insert == FALSE);
  
  g_assert(priv-&gt;record-&gt;applied == TRUE ||
           priv-&gt;record-&gt;position == (guint)gtk_text_iter_get_offset(begin));

  inf_text_gtk_buffer_pop_record(buffer);
}

static void
inf_text_gtk_buffer_mark_set_cb(GtkTextBuffer* gtk_buffer,
                                GtkTextIter* location,
                                GtkTextMark* mark,
                                gpointer user_data)
{
  InfTextGtkBuffer* buffer;
  InfTextGtkBufferPrivate* priv;
  GtkTextMark* insert_mark;
  GtkTextMark* sel_mark;
  GtkTextIter insert_iter;
  GtkTextIter sel_iter;

  guint offset;
  int sel;

  buffer = INF_TEXT_GTK_BUFFER(user_data);
  priv = INF_TEXT_GTK_BUFFER_PRIVATE(buffer);

  insert_mark = gtk_text_buffer_get_insert(gtk_buffer);
  sel_mark = gtk_text_buffer_get_selection_bound(gtk_buffer);

  if( (mark == insert_mark || mark == sel_mark) &amp;&amp; priv-&gt;active_user != NULL)
  {
    /* Don't send status updates for inactive users as these would make it
     * active. Instead, we send one update when the user becomes active
     * again. */
    if(inf_user_get_status(INF_USER(priv-&gt;active_user)) == INF_USER_ACTIVE ||
       priv-&gt;wake_on_cursor_movement == TRUE)
    {
      gtk_text_buffer_get_iter_at_mark(gtk_buffer, &amp;insert_iter, insert_mark);
      gtk_text_buffer_get_iter_at_mark(gtk_buffer, &amp;sel_iter, sel_mark);

      offset = gtk_text_iter_get_offset(&amp;insert_iter);
      sel = gtk_text_iter_get_offset(&amp;sel_iter) - offset;

      if(inf_text_user_get_caret_position(priv-&gt;active_user) != offset ||
         inf_text_user_get_selection_length(priv-&gt;active_user) != sel)
      {
        /* Block the notify_status signal handler of the active user. That
         * signal handler syncs the cursor position of the user to the
         * insertion mark of the TextBuffer when the user becomes active
         * again. However, when we move the cursor, then this will be updated
         * anyway. */
        inf_signal_handlers_block_by_func(
          G_OBJECT(priv-&gt;active_user),
          G_CALLBACK(inf_text_gtk_buffer_active_user_notify_status_cb),
          buffer
        );

        inf_signal_handlers_block_by_func(
          G_OBJECT(priv-&gt;active_user),
          G_CALLBACK(inf_text_gtk_buffer_active_user_selection_changed_cb),
          buffer
        );

        inf_text_user_set_selection(priv-&gt;active_user, offset, sel, TRUE);

        inf_signal_handlers_unblock_by_func(
          G_OBJECT(priv-&gt;active_user),
          G_CALLBACK(inf_text_gtk_buffer_active_user_notify_status_cb),
          buffer
        );

        inf_signal_handlers_unblock_by_func(
          G_OBJECT(priv-&gt;active_user),
          G_CALLBACK(inf_text_gtk_buffer_active_user_selection_changed_cb),
          buffer
        );
      }
    }
  }
}

static void
inf_text_gtk_buffer_active_user_notify_status_cb(GObject* object,
                                                 GParamSpec* pspec,
                                                 gpointer user_data)
{
  InfTextGtkBuffer* buffer;
  InfTextGtkBufferPrivate* priv;
  GtkTextMark* insert_mark;
  GtkTextMark* sel_mark;
  GtkTextIter insert_iter;
  GtkTextIter sel_iter;
  guint offset;
  int sel;

  buffer = INF_TEXT_GTK_BUFFER(user_data);
  priv = INF_TEXT_GTK_BUFFER_PRIVATE(buffer);

  g_assert(INF_TEXT_USER(object) == priv-&gt;active_user);

  switch(inf_user_get_status(INF_USER(object)))
  {
  case INF_USER_ACTIVE:
    /* User became active: Sync user selection and the insertion mark of the
     * TextBuffer. They can get out of sync while the user is inactive, and
     * wake-on-cursor-movement is FALSE. For example text can be selected in
     * an inactive document, and then the user decides to select something
     * else, erasing the previous selection. */

    insert_mark = gtk_text_buffer_get_insert(priv-&gt;buffer);
    sel_mark = gtk_text_buffer_get_selection_bound(priv-&gt;buffer);

    gtk_text_buffer_get_iter_at_mark(priv-&gt;buffer, &amp;insert_iter, insert_mark);
    gtk_text_buffer_get_iter_at_mark(priv-&gt;buffer, &amp;sel_iter, sel_mark);

    offset = gtk_text_iter_get_offset(&amp;insert_iter);
    sel = gtk_text_iter_get_offset(&amp;sel_iter) - offset;

    if(inf_text_user_get_caret_position(priv-&gt;active_user) != offset ||
       inf_text_user_get_selection_length(priv-&gt;active_user) != sel)
    {
      inf_signal_handlers_block_by_func(
        G_OBJECT(priv-&gt;active_user),
        G_CALLBACK(inf_text_gtk_buffer_active_user_selection_changed_cb),
        buffer
      );

      inf_text_user_set_selection(priv-&gt;active_user, offset, sel, TRUE);

      inf_signal_handlers_unblock_by_func(
        G_OBJECT(priv-&gt;active_user),
        G_CALLBACK(inf_text_gtk_buffer_active_user_selection_changed_cb),
        buffer
      );
    }

    break;
  case INF_USER_UNAVAILABLE:
    /* TODO: Do we want to unset the active-user automatically here? */
    break;
  default:
    /* Not of interest. */
    break;
  }
}

static void
inf_text_gtk_buffer_active_user_selection_changed_cb(InfTextUser* user,
                                                     guint position,
                                                     gint selection_length,
                                                     gboolean by_request,
                                                     gpointer user_data)
{
  InfTextGtkBuffer* buffer;
  InfTextGtkBufferPrivate* priv;
  GtkTextIter insert;
  GtkTextIter selection_bound;

  buffer = INF_TEXT_GTK_BUFFER(user_data);
  priv = INF_TEXT_GTK_BUFFER_PRIVATE(buffer);

  inf_signal_handlers_block_by_func(
    G_OBJECT(priv-&gt;buffer),
    G_CALLBACK(inf_text_gtk_buffer_mark_set_cb),
    buffer
  );

  gtk_text_buffer_get_iter_at_offset(priv-&gt;buffer, &amp;insert, position);

  gtk_text_buffer_get_iter_at_offset(
    priv-&gt;buffer,
    &amp;selection_bound,
    position + selection_length
  );

  gtk_text_buffer_select_range(priv-&gt;buffer, &amp;insert, &amp;selection_bound);

  inf_signal_handlers_unblock_by_func(
    G_OBJECT(priv-&gt;buffer),
    G_CALLBACK(inf_text_gtk_buffer_mark_set_cb),
    buffer
  );
}

static void
inf_text_gtk_buffer_modified_changed_cb(GtkTextBuffer* buffer,
                                        gpointer user_data)
{
  g_object_notify(G_OBJECT(user_data), &quot;modified&quot;);
}

static void
inf_text_gtk_buffer_set_modified(InfTextGtkBuffer* buffer,
                                 gboolean modified)
{
  InfTextGtkBufferPrivate* priv;
  priv = INF_TEXT_GTK_BUFFER_PRIVATE(buffer);

  if(priv-&gt;buffer != NULL)
  {
    inf_signal_handlers_block_by_func(
      G_OBJECT(priv-&gt;buffer),
      G_CALLBACK(inf_text_gtk_buffer_modified_changed_cb),
      buffer
    );

    gtk_text_buffer_set_modified(priv-&gt;buffer, modified);

    inf_signal_handlers_unblock_by_func(
      G_OBJECT(priv-&gt;buffer),
      G_CALLBACK(inf_text_gtk_buffer_modified_changed_cb),
      buffer
    );

    g_object_notify(G_OBJECT(buffer), &quot;modified&quot;);
  }
}

static void
inf_text_gtk_buffer_set_buffer(InfTextGtkBuffer* buffer,
                               GtkTextBuffer* gtk_buffer)
{
  InfTextGtkBufferPrivate* priv;
  priv = INF_TEXT_GTK_BUFFER_PRIVATE(buffer);

  if(priv-&gt;buffer != NULL)
  {
    inf_signal_handlers_disconnect_by_func(
      G_OBJECT(priv-&gt;buffer),
      G_CALLBACK(inf_text_gtk_buffer_apply_tag_cb),
      buffer
    );

    inf_signal_handlers_disconnect_by_func(
      G_OBJECT(priv-&gt;buffer),
      G_CALLBACK(inf_text_gtk_buffer_insert_text_cb_before),
      buffer
    );

    inf_signal_handlers_disconnect_by_func(
      G_OBJECT(priv-&gt;buffer),
      G_CALLBACK(inf_text_gtk_buffer_insert_text_cb_after),
      buffer
    );

    inf_signal_handlers_disconnect_by_func(
      G_OBJECT(priv-&gt;buffer),
      G_CALLBACK(inf_text_gtk_buffer_delete_range_cb_before),
      buffer
    );

    inf_signal_handlers_disconnect_by_func(
      G_OBJECT(priv-&gt;buffer),
      G_CALLBACK(inf_text_gtk_buffer_delete_range_cb_after),
      buffer
    );

    inf_signal_handlers_disconnect_by_func(
      G_OBJECT(priv-&gt;buffer),
      G_CALLBACK(inf_text_gtk_buffer_mark_set_cb),
      buffer
    );

    inf_signal_handlers_disconnect_by_func(
      G_OBJECT(priv-&gt;buffer),
      G_CALLBACK(inf_text_gtk_buffer_modified_changed_cb),
      buffer
    );

<A NAME="3"></A>    g_object_unref(G_OBJECT(priv-&gt;buffer));
  }

<FONT color="#53858b"><A HREF="javascript:ZweiFrames('match2037-1.html#3',3,'match2037-top.html#3',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>  priv-&gt;buffer = gtk_buffer;

  if(gtk_buffer != NULL)
  {
    g_object_ref(G_OBJECT(gtk_buffer));

    g_signal_connect(
      G_OBJECT(gtk_buffer),
      &quot;apply-tag&quot;,
      G_CALLBACK(inf_text_gtk_buffer_apply_tag_cb),
      buffer
    );

    g_signal_connect(
      G_OBJECT(gtk_buffer),
      &quot;insert-text&quot;,
      G_CALLBACK(inf_text_gtk_buffer_insert_text_cb_before),
      buffer
    );

    g_signal_connect_after(
      G_OBJECT(gtk_buffer),
      &quot;insert-text&quot;,
      G_CALLBACK(inf_text_gtk_buffer_insert_text_cb_after),
      buffer
    );

    g_signal_connect(
      G_OBJECT(gtk_buffer),
      &quot;delete-range&quot;,
      G_CALLBACK(inf_text_gtk_buffer_delete_range_cb_before),
      buffer
    );

    g_signal_connect_after(
      G_OBJECT(gtk_buffer),
      &quot;delete-range&quot;,
      G_CALLBACK(inf_text_gtk_buffer_delete_range_cb_after),
      buffer
    );

    g_signal_connect_after(
      G_OBJECT(gtk_buffer),
      &quot;mark-set&quot;,
      G_CALLBACK(inf_text_gtk_buffer_mark_set_cb),
      buffer
    );

    g_signal_connect_after(
      G_OBJECT(gtk_buffer),
      &quot;modified-changed&quot;,
      G_CALLBACK(inf_text_gtk_buffer_modified_changed_cb),
      buffer
    );
  }

  g_object_notify(G_OBJECT(buffer), &quot;buffer&quot;);

  /* TODO: Notify modified, if it changed */
}

static void
inf_text_gtk_buffer_init(InfTextGtkBuffer* buffer)
{
  InfTextGtkBufferPrivate* priv;
  priv = INF_TEXT_GTK_BUFFER_PRIVATE(buffer);

  priv-&gt;buffer = NULL;
  priv-&gt;user_table = NULL;</B></FONT>

  priv-&gt;user_tags = g_hash_table_new_full(
    NULL,
    NULL,
    NULL,
    inf_text_gtk_buffer_user_tags_free
  );

  priv-&gt;show_user_colors = TRUE;

  priv-&gt;active_user = NULL;
  priv-&gt;wake_on_cursor_movement = FALSE;

  priv-&gt;saturation = 0.35;
  priv-&gt;value = 1.0;
  priv-&gt;alpha = 1.0;
}

static void
inf_text_gtk_buffer_dispose(GObject* object)
{
  InfTextGtkBuffer* buffer;
  InfTextGtkBufferPrivate* priv;

  buffer = INF_TEXT_GTK_BUFFER(object);
  priv = INF_TEXT_GTK_BUFFER_PRIVATE(buffer);

  g_hash_table_remove_all(priv-&gt;user_tags);

  inf_text_gtk_buffer_set_buffer(buffer, NULL);
  inf_text_gtk_buffer_set_active_user(buffer, NULL);
  g_object_unref(priv-&gt;user_table);

  G_OBJECT_CLASS(inf_text_gtk_buffer_parent_class)-&gt;dispose(object);
}

static void
inf_text_gtk_buffer_finalize(GObject* object)
{
<A NAME="2"></A>  InfTextGtkBuffer* buffer;
  InfTextGtkBufferPrivate* priv;

<FONT color="#980517"><A HREF="javascript:ZweiFrames('match2037-1.html#2',3,'match2037-top.html#2',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>  buffer = INF_TEXT_GTK_BUFFER(object);
  priv = INF_TEXT_GTK_BUFFER_PRIVATE(buffer);

  g_hash_table_unref(priv-&gt;user_tags);

  G_OBJECT_CLASS(inf_text_gtk_buffer_parent_class)-&gt;finalize(object);
}

static void
inf_text_gtk_buffer_set_property(GObject* object,
                                 guint prop_id,
                                 const GValue* value,
                                 GParamSpec* pspec)
{
  InfTextGtkBuffer* buffer;
  InfTextGtkBufferPrivate* priv;

  buffer = INF_TEXT_GTK_BUFFER(object);
  priv = INF_TEXT_GTK_BUFFER_PRIVATE(buffer);

  switch(prop_id)
  {
  case PROP_BUFFER:
    g_assert(priv-&gt;buffer == NULL); /* construct only */</B></FONT>
    inf_text_gtk_buffer_set_buffer(
      buffer,
      GTK_TEXT_BUFFER(g_value_get_object(value))
    );

    break;
  case PROP_USER_TABLE:
    g_assert(priv-&gt;user_table == NULL); /* construct/only */
    priv-&gt;user_table = INF_USER_TABLE(g_value_dup_object(value));
    break;
  case PROP_ACTIVE_USER:
    inf_text_gtk_buffer_set_active_user(
      buffer,
      INF_TEXT_USER(g_value_get_object(value))
    );

    break;
  case PROP_WAKE_ON_CURSOR_MOVEMENT:
    priv-&gt;wake_on_cursor_movement = g_value_get_boolean(value);
    break;
  case PROP_SHOW_USER_COLORS:
    priv-&gt;show_user_colors = g_value_get_boolean(value);
    break;
  case PROP_MODIFIED:
    inf_text_gtk_buffer_set_modified(buffer, g_value_get_boolean(value));
    break;
  case PROP_SATURATION:
    inf_text_gtk_buffer_set_saturation_value(
      buffer,
      g_value_get_double(value),
      priv-&gt;value
    );
    break;
  case PROP_VALUE:
    inf_text_gtk_buffer_set_saturation_value(
      buffer,
      priv-&gt;saturation,
      g_value_get_double(value)
    );
<A NAME="0"></A>    break;
  case PROP_ALPHA:
    inf_text_gtk_buffer_set_fade(buffer, g_value_get_double(value));
<FONT color="#0000ff"><A HREF="javascript:ZweiFrames('match2037-1.html#0',3,'match2037-top.html#0',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>    break;
  default:
    G_OBJECT_WARN_INVALID_PROPERTY_ID(object, prop_id, pspec);
    break;
  }
}

static void
inf_text_gtk_buffer_get_property(GObject* object,
                                 guint prop_id,
                                 GValue* value,
                                 GParamSpec* pspec)
{
  InfTextGtkBuffer* buffer;
  InfTextGtkBufferPrivate* priv;

  buffer = INF_TEXT_GTK_BUFFER(object);
  priv = INF_TEXT_GTK_BUFFER_PRIVATE(buffer);

  switch(prop_id)
  {
  case PROP_BUFFER:
    g_value_set_object(value, G_OBJECT(priv-&gt;buffer));
    break;
  case PROP_USER_TABLE:
    g_value_set_object(value, G_OBJECT(priv-&gt;user_table));
    break;</B></FONT>
  case PROP_ACTIVE_USER:
    g_value_set_object(value, G_OBJECT(priv-&gt;active_user));
    break;
  case PROP_WAKE_ON_CURSOR_MOVEMENT:
    g_value_set_boolean(value, priv-&gt;wake_on_cursor_movement);
    break;
  case PROP_SHOW_USER_COLORS:
    g_value_set_boolean(value, priv-&gt;show_user_colors);
    break;
  case PROP_MODIFIED:
    if(priv-&gt;buffer != NULL)
      g_value_set_boolean(value, gtk_text_buffer_get_modified(priv-&gt;buffer));
    else
      g_value_set_boolean(value, FALSE);

    break;
  case PROP_SATURATION:
    g_value_set_double(value, priv-&gt;saturation);
    break;
  case PROP_VALUE:
    g_value_set_double(value, priv-&gt;value);
    break;
  case PROP_ALPHA:
    g_value_set_double(value, priv-&gt;alpha);
    break;
  default:
    G_OBJECT_WARN_INVALID_PROPERTY_ID(object, prop_id, pspec);
    break;
  }
}

static gboolean
inf_text_gtk_buffer_buffer_get_modified(InfBuffer* buffer)
{
  InfTextGtkBuffer* gtk_buffer;
  InfTextGtkBufferPrivate* priv;

  gtk_buffer = INF_TEXT_GTK_BUFFER(buffer);
  priv = INF_TEXT_GTK_BUFFER_PRIVATE(gtk_buffer);

  if(priv-&gt;buffer != NULL)
    return gtk_text_buffer_get_modified(priv-&gt;buffer);
  else
    return FALSE;
}

static void
inf_text_gtk_buffer_buffer_set_modified(InfBuffer* buffer,
                                        gboolean modified)
{
  inf_text_gtk_buffer_set_modified(INF_TEXT_GTK_BUFFER(buffer), modified);
}

static const gchar*
inf_text_gtk_buffer_buffer_get_encoding(InfTextBuffer* buffer)
{
  return &quot;UTF-8&quot;;
}

static guint
inf_text_gtk_buffer_get_length(InfTextBuffer* buffer)
{
  InfTextGtkBufferPrivate* priv;
  priv = INF_TEXT_GTK_BUFFER_PRIVATE(buffer);
  return gtk_text_buffer_get_char_count(priv-&gt;buffer);
}

static InfTextChunk*
inf_text_gtk_buffer_buffer_get_slice(InfTextBuffer* buffer,
                                     guint pos,
                                     guint len)
{
  InfTextGtkBufferPrivate* priv;
  GtkTextIter begin;
  GtkTextIter iter;
  InfTextChunk* result;
  guint remaining;

  guint size;
  InfTextUser* author;
  gchar* text;

  priv = INF_TEXT_GTK_BUFFER_PRIVATE(buffer);
  gtk_text_buffer_get_iter_at_offset(priv-&gt;buffer, &amp;iter, pos);
  result = inf_text_chunk_new(&quot;UTF-8&quot;);
  remaining = len;

  while(remaining &gt; 0)
  {
    /* This indicates invalid length */
    g_assert(gtk_text_iter_is_end(&amp;iter) == FALSE);

    begin = iter;
    inf_text_gtk_buffer_iter_next_author_toggle(&amp;iter, NULL, &amp;author);

    size = gtk_text_iter_get_offset(&amp;iter) - gtk_text_iter_get_offset(&amp;begin);

    /* Not the whole segment if region to slice ends before segment end */
    if(size &gt; remaining)
    {
      size = remaining;
      iter = begin;
      gtk_text_iter_forward_chars(&amp;iter, size);
    }

    text = gtk_text_buffer_get_slice(priv-&gt;buffer, &amp;begin, &amp;iter, TRUE);

    /* TODO: Faster inf_text_chunk_append that optionally eats text */
    inf_text_chunk_insert_text(
      result,
      len - remaining,
      text,
      strlen(text), /* I hate strlen. GTK+ should tell us how many bytes. */
      size,
      (author == NULL) ? 0 : inf_user_get_id(INF_USER(author))
    );

    remaining -= size;
    g_free(text);
  }

  return result;
}

static void
inf_text_gtk_buffer_buffer_insert_text(InfTextBuffer* buffer,
                                       guint pos,
                                       InfTextChunk* chunk,
                                       InfUser* user)
{
  InfTextGtkBufferPrivate* priv;
  InfTextChunkIter chunk_iter;
  InfTextGtkBufferTagRemove tag_remove;
  GtkTextTag* tag;

  GtkTextMark* mark;
  GtkTextIter insert_iter;
  gboolean insert_at_cursor;
  gboolean insert_at_selection_bound;

  priv = INF_TEXT_GTK_BUFFER_PRIVATE(buffer);
  tag_remove.buffer = priv-&gt;buffer;

  /* This would have to be handled separately, but I think this is unlikely
   * to happen anyway. If it does happen then we would again need to rely on
   * iterator revalidation to happen in the way we expect it. */
  g_assert(priv-&gt;record == NULL);

  /* Allow author tag changes within this function: */
  inf_signal_handlers_block_by_func(
    G_OBJECT(priv-&gt;buffer),
    G_CALLBACK(inf_text_gtk_buffer_apply_tag_cb),
    buffer
  );

  inf_signal_handlers_block_by_func(
    G_OBJECT(priv-&gt;buffer),
    G_CALLBACK(inf_text_gtk_buffer_insert_text_cb_before),
    buffer
  );

  inf_signal_handlers_block_by_func(
    G_OBJECT(priv-&gt;buffer),
    G_CALLBACK(inf_text_gtk_buffer_insert_text_cb_after),
    buffer
  );

  if(inf_text_chunk_iter_init_begin(chunk, &amp;chunk_iter))
  {
    gtk_text_buffer_get_iter_at_offset(
      priv-&gt;buffer,
      &amp;tag_remove.end_iter,
      pos
    );

    do
    {
      tag_remove.ignore_tags = inf_text_gtk_buffer_get_user_tags(
        INF_TEXT_GTK_BUFFER(buffer),
        inf_text_chunk_iter_get_author(&amp;chunk_iter)
      );

      if(tag_remove.ignore_tags)
      {
        tag = inf_text_gtk_buffer_get_user_tag(
          INF_TEXT_GTK_BUFFER(buffer),
          tag_remove.ignore_tags,
          priv-&gt;show_user_colors
        );
      }
      else
      {
        tag = NULL;
      }

      gtk_text_buffer_insert_with_tags(
        tag_remove.buffer,
        &amp;tag_remove.end_iter,
        inf_text_chunk_iter_get_text(&amp;chunk_iter),
        inf_text_chunk_iter_get_bytes(&amp;chunk_iter),
        tag,
        NULL
      );

      /* Remove other user tags. If we inserted the new text within another
       * user's text, GtkTextBuffer automatically applies that tag to the
       * new text. */

      /* TODO: We could probably look for the tag that we have to remove
       * before inserting text, to optimize this a bit. */
      tag_remove.begin_iter = tag_remove.end_iter;
      gtk_text_iter_backward_chars(
        &amp;tag_remove.begin_iter,
        inf_text_chunk_iter_get_length(&amp;chunk_iter)
      );

      gtk_text_tag_table_foreach(
        gtk_text_buffer_get_tag_table(tag_remove.buffer),
        inf_text_gtk_buffer_buffer_insert_text_tag_table_foreach_func,
        &amp;tag_remove
      );
    } while(inf_text_chunk_iter_next(&amp;chunk_iter));

    /* Fix left gravity of own cursor on remote insert */

    /* TODO: We could also do this by simply resyncing the text buffer marks
     * to the active user's caret and selection properties. But then we
     * wouldn't have left gravtiy if no active user was present. */
    if(user != INF_USER(priv-&gt;active_user) || user == NULL)
    {
      mark = gtk_text_buffer_get_insert(priv-&gt;buffer);
      gtk_text_buffer_get_iter_at_mark(priv-&gt;buffer, &amp;insert_iter, mark);

      if(gtk_text_iter_equal(&amp;insert_iter, &amp;tag_remove.end_iter))
        insert_at_cursor = TRUE;
      else
        insert_at_cursor = FALSE;

      mark = gtk_text_buffer_get_selection_bound(priv-&gt;buffer);
      gtk_text_buffer_get_iter_at_mark(priv-&gt;buffer, &amp;insert_iter, mark);

      if(gtk_text_iter_equal(&amp;insert_iter, &amp;tag_remove.end_iter))
        insert_at_selection_bound = TRUE;
      else
        insert_at_selection_bound = FALSE;

      if(insert_at_cursor || insert_at_selection_bound)
      {
        inf_signal_handlers_block_by_func(
          G_OBJECT(priv-&gt;buffer),
          G_CALLBACK(inf_text_gtk_buffer_mark_set_cb),
          buffer
        );

        gtk_text_iter_backward_chars(
          &amp;tag_remove.end_iter,
          inf_text_chunk_get_length(chunk)
        );

        if(insert_at_cursor)
        {
          gtk_text_buffer_move_mark(
            priv-&gt;buffer,
            gtk_text_buffer_get_insert(priv-&gt;buffer),
            &amp;tag_remove.end_iter
          );
        }

        if(insert_at_selection_bound)
        {
          gtk_text_buffer_move_mark(
            priv-&gt;buffer,
            gtk_text_buffer_get_selection_bound(priv-&gt;buffer),
            &amp;tag_remove.end_iter
          );
        }

        inf_signal_handlers_unblock_by_func(
          G_OBJECT(priv-&gt;buffer),
          G_CALLBACK(inf_text_gtk_buffer_mark_set_cb),
          buffer
        );
      }
    }
  }

  inf_signal_handlers_unblock_by_func(
    G_OBJECT(priv-&gt;buffer),
    G_CALLBACK(inf_text_gtk_buffer_apply_tag_cb),
    buffer
  );

  inf_signal_handlers_unblock_by_func(
    G_OBJECT(priv-&gt;buffer),
    G_CALLBACK(inf_text_gtk_buffer_insert_text_cb_before),
    buffer
  );

  inf_signal_handlers_unblock_by_func(
    G_OBJECT(priv-&gt;buffer),
    G_CALLBACK(inf_text_gtk_buffer_insert_text_cb_after),
    buffer
  );

  inf_text_buffer_text_inserted(buffer, pos, chunk, user);
}

static void
inf_text_gtk_buffer_buffer_erase_text(InfTextBuffer* buffer,
                                      guint pos,
                                      guint len,
                                      InfUser* user)
{
  InfTextGtkBufferPrivate* priv;
  InfTextChunk* chunk;

  GtkTextIter begin;
  GtkTextIter end;

  priv = INF_TEXT_GTK_BUFFER_PRIVATE(buffer);

  /* This would have to be handled separately, but I think this is unlikely
   * to happen anyway. If it does happen then we would again need to rely on
   * iterator revalidation to happen in the way we expect it. */
  g_assert(priv-&gt;record == NULL);

  chunk = inf_text_buffer_get_slice(buffer, pos, len);

  gtk_text_buffer_get_iter_at_offset(priv-&gt;buffer, &amp;begin, pos);
  gtk_text_buffer_get_iter_at_offset(priv-&gt;buffer, &amp;end, pos + len);

  inf_signal_handlers_block_by_func(
    G_OBJECT(priv-&gt;buffer),
    G_CALLBACK(inf_text_gtk_buffer_delete_range_cb_before),
    buffer
  );

  inf_signal_handlers_block_by_func(
    G_OBJECT(priv-&gt;buffer),
    G_CALLBACK(inf_text_gtk_buffer_delete_range_cb_after),
    buffer
  );

  gtk_text_buffer_delete(priv-&gt;buffer, &amp;begin, &amp;end);

  inf_signal_handlers_unblock_by_func(
    G_OBJECT(priv-&gt;buffer),
    G_CALLBACK(inf_text_gtk_buffer_delete_range_cb_before),
    buffer
  );

  inf_signal_handlers_unblock_by_func(
    G_OBJECT(priv-&gt;buffer),
    G_CALLBACK(inf_text_gtk_buffer_delete_range_cb_after),
    buffer
  );

  inf_text_buffer_text_erased(buffer, pos, chunk, user);
  inf_text_chunk_free(chunk);
}

static InfTextBufferIter*
inf_text_gtk_buffer_buffer_create_begin_iter(InfTextBuffer* buffer)
{
  InfTextGtkBufferPrivate* priv;
  InfTextBufferIter* iter;

  priv = INF_TEXT_GTK_BUFFER_PRIVATE(buffer);

  if(gtk_text_buffer_get_char_count(priv-&gt;buffer) == 0)
  {
    return NULL;
  }
  else
  {
    iter = g_slice_new(InfTextBufferIter);
    gtk_text_buffer_get_start_iter(priv-&gt;buffer, &amp;iter-&gt;begin);

    iter-&gt;end = iter-&gt;begin;
    inf_text_gtk_buffer_iter_next_author_toggle(
      &amp;iter-&gt;end,
      NULL,
      &amp;iter-&gt;user
    );

    return iter;
  }
}

static InfTextBufferIter*
inf_text_gtk_buffer_buffer_create_end_iter(InfTextBuffer* buffer)
{
  InfTextGtkBufferPrivate* priv;
  InfTextBufferIter* iter;

  priv = INF_TEXT_GTK_BUFFER_PRIVATE(buffer);

  if(gtk_text_buffer_get_char_count(priv-&gt;buffer) == 0)
  {
    return NULL;
  }
  else
  {
    iter = g_slice_new(InfTextBufferIter);
    gtk_text_buffer_get_end_iter(priv-&gt;buffer, &amp;iter-&gt;end);

    iter-&gt;begin = iter-&gt;end;
    inf_text_gtk_buffer_iter_prev_author_toggle(
      &amp;iter-&gt;begin,
      &amp;iter-&gt;user,
      NULL
    );

    return iter;
  }
}

static void
inf_text_gtk_buffer_buffer_destroy_iter(InfTextBuffer* buffer,
                                        InfTextBufferIter* iter)
{
  g_slice_free(InfTextBufferIter, iter);
}

static gboolean
inf_text_gtk_buffer_buffer_iter_next(InfTextBuffer* buffer,
                                     InfTextBufferIter* iter)
{
  if(gtk_text_iter_is_end(&amp;iter-&gt;end))
    return FALSE;

  iter-&gt;begin = iter-&gt;end;
  inf_text_gtk_buffer_iter_next_author_toggle(&amp;iter-&gt;end, NULL, &amp;iter-&gt;user);
  return TRUE;
}

static gboolean
inf_text_gtk_buffer_buffer_iter_prev(InfTextBuffer* buffer,
                                     InfTextBufferIter* iter)
{
  if(gtk_text_iter_is_start(&amp;iter-&gt;begin))
    return FALSE;

  iter-&gt;end = iter-&gt;begin;
  inf_text_gtk_buffer_iter_prev_author_toggle(
    &amp;iter-&gt;begin,
    &amp;iter-&gt;user,
    NULL
  );

  return TRUE;
}

static gpointer
inf_text_gtk_buffer_buffer_iter_get_text(InfTextBuffer* buffer,
                                         InfTextBufferIter* iter)
{
  InfTextGtkBufferPrivate* priv;
  priv = INF_TEXT_GTK_BUFFER_PRIVATE(buffer);

  return gtk_text_buffer_get_slice(
    priv-&gt;buffer,
    &amp;iter-&gt;begin,
    &amp;iter-&gt;end,
    TRUE
  );
}

static guint
inf_text_gtk_buffer_buffer_iter_get_offset(InfTextBuffer* buffer,
                                           InfTextBufferIter* iter)
{
  return gtk_text_iter_get_offset(&amp;iter-&gt;begin);
}

static guint
inf_text_gtk_buffer_buffer_iter_get_length(InfTextBuffer* buffer,
                                           InfTextBufferIter* iter)
{
  return gtk_text_iter_get_offset(&amp;iter-&gt;end) -
    gtk_text_iter_get_offset(&amp;iter-&gt;begin);
}

static gsize
inf_text_gtk_buffer_buffer_iter_get_bytes(InfTextBuffer* buffer,
                                          InfTextBufferIter* iter)
{
  GtkTextIter walk;
  gsize bytes;
  guint remaining;
  guint end;

  guint line_chars;
  guint line_bytes;
  gboolean result;

  walk = iter-&gt;begin;
  bytes = 0;
  remaining = gtk_text_iter_get_offset(&amp;iter-&gt;end) -
    gtk_text_iter_get_offset(&amp;walk);
  end = gtk_text_iter_get_offset(&amp;iter-&gt;end);

  while(remaining &gt; 0)
  {
    line_chars = gtk_text_iter_get_chars_in_line(&amp;walk) -
      gtk_text_iter_get_line_offset(&amp;walk);

    if(line_chars + gtk_text_iter_get_offset(&amp;walk) &lt;= end)
    {
      /* Need whole line */
      line_bytes = gtk_text_iter_get_bytes_in_line(&amp;walk) -
        gtk_text_iter_get_line_index(&amp;walk);

      remaining -= line_chars;
      bytes += line_bytes;

      result = gtk_text_iter_forward_line(&amp;walk);
      /* We cannot be in last line, because the end iterator would have to
       * be past the last line then. */
      g_assert(remaining == 0 || result == TRUE);
    }
    else
    {
      /* End iterator is in this line */
      line_bytes = gtk_text_iter_get_line_index(&amp;iter-&gt;end) -
        gtk_text_iter_get_line_index(&amp;walk);

      remaining = 0;
      bytes += line_bytes;
    }
  }

  return bytes;
}

static guint
inf_text_gtk_buffer_buffer_iter_get_author(InfTextBuffer* buffer,
                                           InfTextBufferIter* iter)
{
  return (iter-&gt;user == NULL) ? 0 : inf_user_get_id(INF_USER(iter-&gt;user));
}

static void
inf_text_gtk_buffer_class_init(InfTextGtkBufferClass* text_gtk_buffer_class)
{
  GObjectClass* object_class;
  object_class = G_OBJECT_CLASS(text_gtk_buffer_class);

  object_class-&gt;dispose = inf_text_gtk_buffer_dispose;
  object_class-&gt;finalize = inf_text_gtk_buffer_finalize;
  object_class-&gt;set_property = inf_text_gtk_buffer_set_property;
  object_class-&gt;get_property = inf_text_gtk_buffer_get_property;

  inf_text_gtk_buffer_tag_user_quark = g_quark_from_static_string(
    &quot;inf-text-gtk-buffer-tag-user&quot;
  );

  g_object_class_install_property(
    object_class,
    PROP_BUFFER,
    g_param_spec_object(
      &quot;buffer&quot;,
      &quot;Buffer&quot;,
      &quot;The underlaying GtkTextBuffer&quot;,
      GTK_TYPE_TEXT_BUFFER,
      G_PARAM_READWRITE | G_PARAM_CONSTRUCT_ONLY
    )
  );

  g_object_class_install_property(
    object_class,
    PROP_USER_TABLE,
    g_param_spec_object(
      &quot;user-table&quot;,
      &quot;User table&quot;,
      &quot;A user table of the participating users&quot;,
      INF_TYPE_USER_TABLE,
      G_PARAM_READWRITE | G_PARAM_CONSTRUCT_ONLY
    )
  );

  g_object_class_install_property(
    object_class,
    PROP_ACTIVE_USER,
    g_param_spec_object(
      &quot;active-user&quot;,
      &quot;Active user&quot;,
      &quot;The user currently inserting text locally&quot;,
      INF_TEXT_TYPE_USER,
      G_PARAM_READWRITE
    )
  );

  g_object_class_install_property(
    object_class,
    PROP_WAKE_ON_CURSOR_MOVEMENT,
    g_param_spec_boolean(
      &quot;wake-on-cursor-movement&quot;,
      &quot;Wake on cursor movement&quot;,
      &quot;Whether to make inactive users active when the insertion mark in the &quot;
      &quot;TextBuffer moves&quot;,
      FALSE,
      G_PARAM_READWRITE
    )
  );

  g_object_class_install_property(
    object_class,
    PROP_SHOW_USER_COLORS,
    g_param_spec_boolean(
      &quot;show-user-colors&quot;,
      &quot;Show user colors&quot;,
      &quot;Whether to show user colors initially for newly written text&quot;,
      TRUE,
      G_PARAM_READWRITE
    )
  );

  g_object_class_install_property(
    object_class,
    PROP_SATURATION,
    g_param_spec_double(
      &quot;saturation&quot;,
      &quot;Saturation&quot;,
      &quot;Saturation of user colors in a HSV color model&quot;,
      0.0,
      1.0,
      0.35,
      G_PARAM_READWRITE
    )
  );

  g_object_class_install_property(
    object_class,
    PROP_VALUE,
    g_param_spec_double(
      &quot;value&quot;,
      &quot;Value&quot;,
      &quot;Value of user colors in a HSV color model&quot;,
      0.0,
      1.0,
      1.0,
      G_PARAM_READWRITE
    )
  );

  g_object_class_install_property(
    object_class,
    PROP_VALUE,
    g_param_spec_double(
      &quot;alpha&quot;,
      &quot;Alpha&quot;,
      &quot;The translucency of the user color&quot;,
      0.0,
      1.0,
      1.0,
      G_PARAM_READWRITE
    )
  );

  g_object_class_override_property(object_class, PROP_MODIFIED, &quot;modified&quot;);
}

static void
inf_text_gtk_buffer_buffer_iface_init(InfBufferInterface* iface)
{
  iface-&gt;get_modified = inf_text_gtk_buffer_buffer_get_modified;
  iface-&gt;set_modified = inf_text_gtk_buffer_buffer_set_modified;
}

static void
inf_text_gtk_buffer_text_buffer_iface_init(InfTextBufferInterface* iface)
{
  iface-&gt;get_encoding = inf_text_gtk_buffer_buffer_get_encoding;
  iface-&gt;get_length = inf_text_gtk_buffer_get_length;
  iface-&gt;get_slice = inf_text_gtk_buffer_buffer_get_slice;
  iface-&gt;insert_text = inf_text_gtk_buffer_buffer_insert_text;
  iface-&gt;erase_text = inf_text_gtk_buffer_buffer_erase_text;
  iface-&gt;create_begin_iter = inf_text_gtk_buffer_buffer_create_begin_iter;
  iface-&gt;create_end_iter = inf_text_gtk_buffer_buffer_create_end_iter;
  iface-&gt;destroy_iter = inf_text_gtk_buffer_buffer_destroy_iter;
  iface-&gt;iter_next = inf_text_gtk_buffer_buffer_iter_next;
  iface-&gt;iter_prev = inf_text_gtk_buffer_buffer_iter_prev;
  iface-&gt;iter_get_text = inf_text_gtk_buffer_buffer_iter_get_text;
  iface-&gt;iter_get_offset = inf_text_gtk_buffer_buffer_iter_get_offset;
  iface-&gt;iter_get_length = inf_text_gtk_buffer_buffer_iter_get_length;
  iface-&gt;iter_get_bytes = inf_text_gtk_buffer_buffer_iter_get_bytes;
  iface-&gt;iter_get_author = inf_text_gtk_buffer_buffer_iter_get_author;
  iface-&gt;text_inserted = NULL;
  iface-&gt;text_erased = NULL;
}

/**
 * inf_text_gtk_buffer_new: (constructor)
 * @buffer: The underlaying #GtkTextBuffer.
 * @user_table: The #InfUserTable containing the participating users.
 *
 * Creates a new #InfTextGtkBuffer wrapping @buffer. It implements the
 * #InfTextBuffer interface by using @buffer to store the text. User colors
 * are read from the users from @user_table.
 *
 * Returns: (transfer full): A #InfTextGtkBuffer.
 **/
InfTextGtkBuffer*
inf_text_gtk_buffer_new(GtkTextBuffer* buffer,
                        InfUserTable* user_table)
{
  GObject* object;

  g_return_val_if_fail(GTK_IS_TEXT_BUFFER(buffer), NULL);
  g_return_val_if_fail(INF_IS_USER_TABLE(user_table), NULL);

  object = g_object_new(
    INF_TEXT_GTK_TYPE_BUFFER,
    &quot;buffer&quot;, buffer,
    &quot;user-table&quot;, user_table,
    NULL
  );

  return INF_TEXT_GTK_BUFFER(object);
}

/**
 * inf_text_gtk_buffer_get_text_buffer:
 * @buffer: A #InfTextGtkBuffer.
 *
 * Returns the underlaying #GtkTextBuffer.
 *
 * Returns: (transfer none): A #GtkTextBuffer.
 **/
GtkTextBuffer*
inf_text_gtk_buffer_get_text_buffer(InfTextGtkBuffer* buffer)
{
  g_return_val_if_fail(INF_TEXT_GTK_IS_BUFFER(buffer), NULL);
  return INF_TEXT_GTK_BUFFER_PRIVATE(buffer)-&gt;buffer;
}

/**
 * inf_text_gtk_buffer_set_active_user:
 * @buffer: A #InfTextGtkBuffer.
 * @user: (allow-none): A #InfTextUser, or %NULL.
 *
 * Sets the active user for @buffer. The active user is the user by which
 * edits not issued through the #InfTextBuffer interface are performed (for
 * example, edits by the user when the underlaying buffer is displayed in
 * a #GtkTextView).
 *
 * Note that such modifications should not be performed when no active user is
 * set. Note also the active user must be available and have the
 * %INF_USER_LOCAL flag set.
 **/
void
inf_text_gtk_buffer_set_active_user(InfTextGtkBuffer* buffer,
                                    InfTextUser* user)
{
  InfTextGtkBufferPrivate* priv;

  g_return_if_fail(INF_TEXT_GTK_IS_BUFFER(buffer));
  g_return_if_fail(user == NULL || INF_TEXT_IS_USER(user));
  
  g_return_if_fail(
    user == NULL ||
    (inf_user_get_flags(INF_USER(user)) &amp; INF_USER_LOCAL) != 0
  );

  g_return_if_fail(
    user == NULL ||
    inf_user_get_status(INF_USER(user)) != INF_USER_UNAVAILABLE
  );

  priv = INF_TEXT_GTK_BUFFER_PRIVATE(buffer);

  if(priv-&gt;active_user != NULL)
  {
    inf_signal_handlers_disconnect_by_func(
      G_OBJECT(priv-&gt;active_user),
      G_CALLBACK(inf_text_gtk_buffer_active_user_notify_status_cb),
      buffer
    );

    inf_signal_handlers_disconnect_by_func(
      G_OBJECT(priv-&gt;active_user),
      G_CALLBACK(inf_text_gtk_buffer_active_user_selection_changed_cb),
      buffer
    );

    g_object_unref(G_OBJECT(priv-&gt;active_user));
  }

  priv-&gt;active_user = user;

  if(user != NULL)
  {
    /* TODO: Set cursor and selection of new user */

    g_object_ref(G_OBJECT(user));

    g_signal_connect(
      G_OBJECT(user),
      &quot;notify::status&quot;,
      G_CALLBACK(inf_text_gtk_buffer_active_user_notify_status_cb),
      buffer
    );

    g_signal_connect(
      G_OBJECT(user),
      &quot;selection-changed&quot;,
      G_CALLBACK(inf_text_gtk_buffer_active_user_selection_changed_cb),
      buffer
    );
  }

  g_object_notify(G_OBJECT(buffer), &quot;active-user&quot;);
}

/**
 * inf_text_gtk_buffer_get_active_user:
 * @buffer: A #InfTextGtkBuffer.
 *
 * Returns the current active user for @buffer.
 *
 * Returns: (transfer none) (allow-none): A #InfTextUser.
 **/
InfTextUser*
inf_text_gtk_buffer_get_active_user(InfTextGtkBuffer* buffer)
{
  g_return_val_if_fail(INF_TEXT_GTK_IS_BUFFER(buffer), NULL);
  return INF_TEXT_GTK_BUFFER_PRIVATE(buffer)-&gt;active_user;
}

/**
 * inf_text_gtk_buffer_get_author:
 * @buffer: A #InfTextGtkBuffer.
 * @location: A #GtkTextIter which is not the end iterator.
 *
 * Returns the #InfTextUser which wrote the character at @location. If there
 * is no such user, then %NULL is returned.
 *
 * Returns: (transfer none) (allow-none): A #InfTextUser, or %NULL.
 */
InfTextUser*
inf_text_gtk_buffer_get_author(InfTextGtkBuffer* buffer,
                               GtkTextIter* location)
{
  InfTextGtkBufferPrivate* priv;

  g_return_val_if_fail(INF_TEXT_GTK_IS_BUFFER(buffer), NULL);

  g_return_val_if_fail(
    location != NULL &amp;&amp; !gtk_text_iter_is_end(location),
    NULL
  );

  priv = INF_TEXT_GTK_BUFFER_PRIVATE(buffer);
  return inf_text_gtk_buffer_iter_get_author(location);
}

/**
 * inf_text_gtk_buffer_get_user_for_tag:
 * @buffer: A #InfTextGtkBuffer.
 * @tag: A #GtkTextTag from @buffer's underlying #GtkTextBuffer's tag table.
 *
 * If @tag is an author tag, i.e. used by @buffer to mark text that a certain
 * user has written, then this function returns the #InfTextUser whose text is
 * marked by @tag. If @tag is not an author tag then the function returns
 * %NULL.
 *
 * Returns: (transfer none) (allow-none): A #InfTextUser, or %NULL.
 */
InfTextUser*
inf_text_gtk_buffer_get_user_for_tag(InfTextGtkBuffer* buffer,
                                     GtkTextTag* tag)
{
  g_return_val_if_fail(INF_TEXT_GTK_IS_BUFFER(buffer), NULL);
  g_return_val_if_fail(GTK_IS_TEXT_TAG(tag), NULL);

  return inf_text_gtk_buffer_author_from_tag(tag);
}

/**
 * inf_text_gtk_buffer_is_author_toggle:
 * @buffer: A #InfTextGtkBuffer.
 * @iter: A #GtkTextIter pointing into @buffer's underlying #GtkTextBuffer.
 * @user_on: (out) (allow-none): A location to store a #InfTextUser, or %NULL.
 * @user_off: (out) (allow-none): Another location to store a #InfTextUser,
 * or %NULL.
 *
 * This function returns %TRUE if the author of the text in @buffer changes
 * at @iter, or %FALSE otherwise. If it returns %TRUE, then the user who
 * authored the text to the right hand side of @iter is stored in @user_on (if
 * non-%NULL) and the author of the text to the left hand side of @iter is
 * stored in @user_off (if non-%NULL). Both can also be set to %NULL if there
 * is unowned text in the buffer or if @iter is at the start or end of the
 * buffer.
 *
 * Returns: Whether text attribution changes at @iter.
 */
gboolean
inf_text_gtk_buffer_is_author_toggle(InfTextGtkBuffer* buffer,
                                     const GtkTextIter* iter,
                                     InfTextUser** user_on,
                                     InfTextUser** user_off)
{
  g_return_val_if_fail(INF_TEXT_GTK_IS_BUFFER(buffer), FALSE);
  g_return_val_if_fail(iter != NULL, FALSE);

  return inf_text_gtk_buffer_iter_is_author_toggle(
    iter,
    user_on,
    user_off
  );
}

/**
 * inf_text_gtk_buffer_forward_to_author_toggle:
 * @buffer: A #InfTextGtkBuffer.
 * @iter: A #GtkTextIter pointing into @buffer's underlying #GtkTextBuffer.
 * @user_on: (out) (allow-none): A location to store a #InfTextUser, or %NULL.
 * @user_off: (out) (allow-none): Another location to store a #InfTextUser,
 * or %NULL.
 *
 * Moves @iter to the next point in @buffer's underlying #GtkTextBuffer where
 * the text has been written by another user. If @iter points to the end of
 * the buffer, then the function does nothing and returns %FALSE. Otherwise
 * it returns %TRUE and sets @user_on to the user which has written the text
 * on the right hand side of the location @iter has been moved to (if
 * non-%NULL) and @user_off to the user which has written the left hand side
 * of the location @iter has been moved to.
 *
 * Returns: %TRUE if @iter was moved, or %FALSE otherwise.
 */
gboolean
inf_text_gtk_buffer_forward_to_author_toggle(InfTextGtkBuffer* buffer,
                                             GtkTextIter* iter,
                                             InfTextUser** user_on,
                                             InfTextUser** user_off)
{
  g_return_val_if_fail(INF_TEXT_GTK_IS_BUFFER(buffer), FALSE);
  g_return_val_if_fail(iter != NULL, FALSE);

  if(gtk_text_iter_is_end(iter))
    return FALSE;

  inf_text_gtk_buffer_iter_next_author_toggle(iter, user_on, user_off);
  return TRUE;
}

/**
 * inf_text_gtk_buffer_backward_to_author_toggle:
 * @buffer: A #InfTextGtkBuffer.
 * @iter: A #GtkTextIter pointing into @buffer's underlying #GtkTextBuffer.
 * @user_on: (out) (allow-none): A location to store a #InfTextUser, or %NULL.
 * @user_off: (out) (allow-none): Another location to store a #InfTextUser,
 * or %NULL.
 *
 * Moves @iter to the previous point in @buffer's underlying #GtkTextBuffer
 * where the text has been written by another user. If @iter points to the
 * beginning of the buffer, then the function does nothing and returns %FALSE.
 * Otherwise it returns %TRUE and sets @user_on to the user which has written
 * the text on the right hand side of the location @iter has been moved to (if
 * non-%NULL) and @user_off to the user which has written the left hand side
 * of the location @iter has been moved to.
 *
 * Returns: %TRUE if @iter was moved, or %FALSE otherwise.
 */
gboolean
inf_text_gtk_buffer_backward_to_author_toggle(InfTextGtkBuffer* buffer,
                                              GtkTextIter* iter,
                                              InfTextUser** user_on,
                                              InfTextUser** user_off)
{
  g_return_val_if_fail(INF_TEXT_GTK_IS_BUFFER(buffer), FALSE);
  g_return_val_if_fail(iter != NULL, FALSE);

  if(gtk_text_iter_is_start(iter))
    return FALSE;

  inf_text_gtk_buffer_iter_prev_author_toggle(iter, user_on, user_off);
  return TRUE;
}

/**
 * inf_text_gtk_buffer_set_wake_on_cursor_movement:
 * @buffer: A #InfTextGtkBuffer.
 * @wake: Whether to make inactive users active on cursor movement.
 *
 * This function spcecifies whether movement of the insertion point or
 * selection bound of the underlying text buffer causes the active user
 * (see inf_text_gtk_buffer_set_active_user()) to become active when its
 * status is %INF_USER_INACTIVE.
 *
 * If @wake is %TRUE, then the user status changes to %INF_USER_ACTIVE
 * in that case. If @wake is %FALSE, then the user status stays
 * %INF_USER_INACTIVE, and its caret-position and selection-length
 * properties will be no longer be synchronized to the buffer marks until
 * the user is set active again.
 */

void
inf_text_gtk_buffer_set_wake_on_cursor_movement(InfTextGtkBuffer* buffer,
                                                gboolean wake)
{
  g_return_if_fail(INF_TEXT_GTK_IS_BUFFER(buffer));
  INF_TEXT_GTK_BUFFER_PRIVATE(buffer)-&gt;wake_on_cursor_movement = wake;
  g_object_notify(G_OBJECT(buffer), &quot;wake-on-cursor-movement&quot;);
}

/**
 * inf_text_gtk_buffer_get_wake_on_cursor_movement:
 * @buffer: A #InfTextGtkBuffer.
 *
 * Returns whether movement of the insertion point or selection bound of the
 * underlying text buffer causes whether the active user (see
 * inf_text_gtk_buffer_set_active_user()) to become active when its status
 * is %INF_USER_INACTIVE. See also
 * inf_text_gtk_buffer_set_wake_on_cursor_movement().
 *
 * Returns: Whether to make inactive users active when the insertion mark
 * is moved.
 */
gboolean
inf_text_gtk_buffer_get_wake_on_cursor_movement(InfTextGtkBuffer* buffer)
{
  g_return_val_if_fail(INF_TEXT_GTK_IS_BUFFER(buffer), FALSE);
  return INF_TEXT_GTK_BUFFER_PRIVATE(buffer)-&gt;wake_on_cursor_movement;
}

/**
 * inf_text_gtk_buffer_ensure_author_tags_priority:
 * @buffer: A #InfTextGtkBuffer.
 *
 * Ensures that all author tags have the lowest priority of all tags in the
 * underlying #GtkTextBuffer's tag table. Normally you do not need to use
 * this function if you do not set the priority for your tags explicitely.
 * However, if you do (or are forced to do, because you are using a library
 * that does this, such as GtkSourceView), then you can call this function
 * afterwards to make sure all the user tags have the lowest priority.
 */
void
inf_text_gtk_buffer_ensure_author_tags_priority(InfTextGtkBuffer* buffer)
{
  InfTextGtkBufferPrivate* priv;
  GtkTextTagTable* tag_table;

  g_return_if_fail(INF_TEXT_GTK_IS_BUFFER(buffer));

  priv = INF_TEXT_GTK_BUFFER_PRIVATE(buffer);
  tag_table = gtk_text_buffer_get_tag_table(priv-&gt;buffer);
  gtk_text_tag_table_foreach(
    tag_table,
    inf_text_gtk_buffer_ensure_author_tags_priority_foreach_func,
    buffer
  );
}

/**
 * inf_text_gtk_buffer_set_saturation_value:
 * @buffer: A #InfTextGtkBuffer.
 * @saturation: Saturation to use for user colors.
 * @value: Value to use for user colors.
 *
 * Sets the saturation and value to use for user colors in a HSV color model.
 * The hue is defined by each user's individual color. The reason why S and V
 * are set locally the same for all users is that they can be adjusted
 * depending on one's theme: Dark themes want dark user colors, bright themes
 * want bright ones.
 */
void
inf_text_gtk_buffer_set_saturation_value(InfTextGtkBuffer* buffer,
                                         gdouble saturation,
                                         gdouble value)
{
  InfTextGtkBufferPrivate* priv;
  GtkTextTagTable* tag_table;

  g_return_if_fail(INF_TEXT_GTK_IS_BUFFER(buffer));
  g_return_if_fail(saturation &gt;= 0.0 &amp;&amp; saturation &lt;= 1.0);
  g_return_if_fail(value &gt;= 0.0 &amp;&amp; value &lt;= 1.0);

  priv = INF_TEXT_GTK_BUFFER_PRIVATE(buffer);

  if(saturation == priv-&gt;saturation &amp;&amp; value == priv-&gt;value)
    return;

  g_object_freeze_notify(G_OBJECT(buffer));
  if(saturation != priv-&gt;saturation)
  {
    priv-&gt;saturation = saturation;
    g_object_notify(G_OBJECT(buffer), &quot;saturation&quot;);
  }

  if(value != priv-&gt;value)
  {
    priv-&gt;value = value;
    g_object_notify(G_OBJECT(buffer), &quot;value&quot;);
  }

  tag_table = gtk_text_buffer_get_tag_table(priv-&gt;buffer);
  gtk_text_tag_table_foreach(
    tag_table,
    inf_text_gtk_buffer_update_user_color_tag_table_foreach_func,
    buffer
  );
  g_object_thaw_notify(G_OBJECT(buffer));
}

/**
 * inf_text_gtk_buffer_set_fade:
 * @buffer: A #InfTextGtkBuffer.
 * @alpha: An alpha value between 0.0 and 1.0.
 *
 * This functions can be used to show the user background color with limited
 * intensity, such that the background of the #GtkTextView showing the buffer
 * partly shines through.
 *
 * An @alpha value of 1.0 means to fully show the user background color, a
 * value of 0.0 means to show the given background color. Values inbetween
 * interpolate linearly between the two colors in RGB color space.
 *
 * The default value for @alpha is 1.0.
 */
void
inf_text_gtk_buffer_set_fade(InfTextGtkBuffer* buffer,
                             gdouble alpha)
{
  InfTextGtkBufferPrivate* priv;
  GtkTextTagTable* tag_table;

  g_return_if_fail(INF_TEXT_GTK_IS_BUFFER(buffer));
  g_return_if_fail(alpha &gt;= 0.0 &amp;&amp; alpha &lt;= 1.0);

  priv = INF_TEXT_GTK_BUFFER_PRIVATE(buffer);

  g_object_freeze_notify(G_OBJECT(buffer));
  if(alpha != priv-&gt;alpha)
  {
    priv-&gt;alpha = alpha;
    g_object_notify(G_OBJECT(buffer), &quot;alpha&quot;);
  }

  tag_table = gtk_text_buffer_get_tag_table(priv-&gt;buffer);

  gtk_text_tag_table_foreach(
    tag_table,
    inf_text_gtk_buffer_update_user_color_tag_table_foreach_func,
    buffer
  );

  g_object_thaw_notify(G_OBJECT(buffer));
}

/**
 * inf_text_gtk_buffer_get_saturation:
 * @buffer: A #InfTextGtkBuffer.
 *
 * Returns the saturation part of the HSV user color.
 *
 * Returns: The saturation used for user colors.
 */
gdouble
inf_text_gtk_buffer_get_saturation(InfTextGtkBuffer* buffer)
{
  g_return_val_if_fail(INF_TEXT_GTK_IS_BUFFER(buffer), 0.0);
  return INF_TEXT_GTK_BUFFER_PRIVATE(buffer)-&gt;saturation;
}

/**
 * inf_text_gtk_buffer_get_value:
 * @buffer: A #InfTextGtkBuffer.
 *
 * Returns the value part of the HSV user color.
 *
 * Returns: The value used for user colors.
 */
gdouble
inf_text_gtk_buffer_get_value(InfTextGtkBuffer* buffer)
{
  g_return_val_if_fail(INF_TEXT_GTK_IS_BUFFER(buffer), 0.0);
  return INF_TEXT_GTK_BUFFER_PRIVATE(buffer)-&gt;value;
}

/**
 * inf_text_gtk_buffer_set_show_user_colors:
 * @buffer: A #InfTextGtkBuffer.
 * @show: Whether to show user colors or not.
 *
 * If @show is %TRUE (the default), then the user color is used as background
 * for newly written text by that user. Otherwise, newly written text has no
 * background color.
 *
 * Note that this setting is for newly written text only. If you want to show
 * or hide user colors for existing text use
 * inf_text_gtk_buffer_show_user_colors().
 */
void
inf_text_gtk_buffer_set_show_user_colors(InfTextGtkBuffer* buffer,
                                         gboolean show)
{
  g_return_if_fail(INF_TEXT_GTK_IS_BUFFER(buffer));
  INF_TEXT_GTK_BUFFER_PRIVATE(buffer)-&gt;show_user_colors = show;
  g_object_notify(G_OBJECT(buffer), &quot;show-user-colors&quot;);
}

/**
 * inf_text_gtk_buffer_get_show_user_colors:
 * @buffer: A #InfTextGtkBuffer.
 *
 * Returns whether newly written text is attributed with the author's user
 * color or not.
 *
 * Returns: %TRUE if user color is applied to newly written text, or %FALSE
 * otherwise.
 */
gboolean
inf_text_gtk_buffer_get_show_user_colors(InfTextGtkBuffer* buffer)
{
  g_return_val_if_fail(INF_TEXT_GTK_IS_BUFFER(buffer), FALSE);
  return INF_TEXT_GTK_BUFFER_PRIVATE(buffer)-&gt;show_user_colors;
}

/**
 * inf_text_gtk_buffer_show_user_colors:
 * @buffer: A #InfTextGtkBuffer.
 * @show: Whether to show or hide user colors.
 * @start: (in) (transfer none): Beginning of the range for which to show
 * or hide user colors.
 * @end: (in) (transfer none): End of the range for which to show or hide
 * user colors.
 *
 * If @show is %FALSE, then don't show user colors (which user wrote what
 * text) as the background of the text, in the range from @start to @end.
 * If @show is %TRUE, show user colors if they have previously been hidden
 * via a call to this function with @show being %FALSE.
 */
void
inf_text_gtk_buffer_show_user_colors(InfTextGtkBuffer* buffer,
                                     gboolean show,
                                     GtkTextIter* start,
                                     GtkTextIter* end)
{
  InfTextGtkBufferPrivate* priv;
  GtkTextIter iter;
  GtkTextIter prev;
  InfTextUser* user;
  InfTextGtkBufferUserTags* tags;
  GtkTextTag* hide_tag;
  GtkTextTag* show_tag;

  g_return_if_fail(INF_TEXT_GTK_IS_BUFFER(buffer));
  g_return_if_fail(start != NULL);
  g_return_if_fail(end != NULL);

  priv = INF_TEXT_GTK_BUFFER_PRIVATE(buffer);
  iter = *start;
  prev = iter;

  while(!gtk_text_iter_equal(&amp;iter, end))
  {
    inf_text_gtk_buffer_iter_next_author_toggle(&amp;iter, NULL, &amp;user);
    if(gtk_text_iter_compare(&amp;iter, end) &gt; 0)
      iter = *end;

    if(user != NULL)
    {
      tags = g_hash_table_lookup(
        priv-&gt;user_tags,
        GUINT_TO_POINTER(inf_user_get_id(INF_USER(user)))
      );
      g_assert(tags != NULL);

      if(show)
      {
        hide_tag = inf_text_gtk_buffer_get_user_tag(buffer, tags, FALSE);
        show_tag = inf_text_gtk_buffer_get_user_tag(buffer, tags, TRUE);
      }
      else
      {
        hide_tag = inf_text_gtk_buffer_get_user_tag(buffer, tags, TRUE);
        show_tag = inf_text_gtk_buffer_get_user_tag(buffer, tags, FALSE);
      }

      inf_signal_handlers_block_by_func(
        priv-&gt;buffer,
        G_CALLBACK(inf_text_gtk_buffer_apply_tag_cb),
        buffer
      );

      gtk_text_buffer_remove_tag(priv-&gt;buffer, hide_tag, &amp;prev, &amp;iter);
      gtk_text_buffer_apply_tag(priv-&gt;buffer, show_tag, &amp;prev, &amp;iter);

      inf_signal_handlers_unblock_by_func(
        priv-&gt;buffer,
        G_CALLBACK(inf_text_gtk_buffer_apply_tag_cb),
        buffer
      );
    }

    prev = iter;
  }
}

/* vim:set et sw=2 ts=2: */
</PRE>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>inf-gtk-permissions-dialog.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
/* libinfinity - a GObject-based infinote implementation
 * Copyright (C) 2007-2015 Armin Burgmeier &lt;armin@arbur.net&gt;
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston,
 * MA 02110-1301, USA.
 */

/**
 * SECTION:inf-gtk-permissions-dialog
 * @title: InfGtkPermissionsDialog
 * @short_description: A dialog to view and modify the ACL of a directory
 * node
 * @include: libinfgtk/inf-gtk-permissions-dialog.h
 * @stability: Unstable
 *
 * #InfGtkPermissionsDialog is a dialog widget which allows to view and
 * modify the ACL of a node in a infinote directory. It shows a list of all
 * available users and allows the permissions for each of them to be changed,
 * using a #InfGtkAclSheetView widget.
 *
 * If the &quot;can-query-acl&quot; permission is not granted for the local user, the
 * dialog only shows the permissions for the default user and the local user.
 * The dialog also comes with a status text to inform the user why certain
 * functionality is not available.
 *
 * The dialog class reacts to changes to the ACL in real time, and also if the
 * node that is being monitored is removed.
 **/

#include &lt;libinfgtk/inf-gtk-permissions-dialog.h&gt;
#include &lt;libinfgtk/inf-gtk-acl-sheet-view.h&gt;
#include &lt;libinfinity/common/inf-request-result.h&gt;
#include &lt;libinfinity/common/inf-error.h&gt;
#include &lt;libinfinity/inf-i18n.h&gt;
#include &lt;libinfinity/inf-signals.h&gt;
#include &lt;gdk/gdkkeysyms.h&gt;

#include &lt;string.h&gt;

<A NAME="1"></A>enum {
  INF_GTK_PERMISSIONS_DIALOG_COLUMN_ID = 0,
  INF_GTK_PERMISSIONS_DIALOG_COLUMN_NAME = 1
<FONT color="#f63526"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match2037-0.html#1',2,'match2037-top.html#1',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>};

typedef struct _InfGtkPermissionsDialogPendingSheet
  InfGtkPermissionsDialogPendingSheet;
struct _InfGtkPermissionsDialogPendingSheet {
  InfGtkPermissionsDialog* dialog;
  GtkTreeRowReference* row;
  InfAclSheet sheet;
  InfAclAccountId last_combo_changed_id;
  InfRequest* lookup_request;
};

typedef struct _InfGtkPermissionsDialogPrivate InfGtkPermissionsDialogPrivate;
struct _InfGtkPermissionsDialogPrivate {
  InfBrowser* browser;
  InfBrowserIter browser_iter;

  GtkListStore* account_store;

  /* If accounts is NULL, then the account list is not available. Note that we
   * only need the account list when the user adds a new sheet, to present her
   * the available users to choose from. If the list is not available, we
   * perform a reverse lookup. */
  InfRequest* query_acl_account_list_request;
  gboolean account_list_queried;
  InfAclAccount* accounts;
  guint n_accounts;

  InfRequest* query_acl_request;
  GSList* set_acl_requests;
  GSList* remove_acl_account_requests;
  GSList* lookup_acl_account_requests;

  GSList* pending_sheets;

  GtkMenu* popup_menu;
  InfAclAccountId popup_account;

  GtkWidget* status_text;
  GtkWidget* tree_view;
  GtkWidget* sheet_view;

  GtkWidget* add_button;
  GtkWidget* remove_button;

  GtkCellRenderer* renderer;
};

enum {
  PROP_0,

  PROP_BROWSER,
  PROP_BROWSER_ITER
};

#define INF_GTK_PERMISSIONS_DIALOG_PRIVATE(obj) (G_TYPE_INSTANCE_GET_PRIVATE((obj), INF_GTK_TYPE_PERMISSIONS_DIALOG, InfGtkPermissionsDialogPrivate))

G_DEFINE_TYPE_WITH_CODE(InfGtkPermissionsDialog, inf_gtk_permissions_dialog, GTK_TYPE_DIALOG,
  G_ADD_PRIVATE(InfGtkPermissionsDialog))

/*
 * Private functionality
 */

static void</B></FONT>
inf_gtk_permissions_dialog_update(InfGtkPermissionsDialog* dialog,
                                  const GError* error);

static void
inf_gtk_permissions_dialog_update_sheet(InfGtkPermissionsDialog* dialog);

static gboolean
inf_gtk_permissions_dialog_find_account(InfGtkPermissionsDialog* dialog,
                                        InfAclAccountId account,
                                        GtkTreeIter* out_iter)
{
  InfGtkPermissionsDialogPrivate* priv;
  gpointer row_account_id;
  GtkTreeModel* model;
  GtkTreeIter iter;

  priv = INF_GTK_PERMISSIONS_DIALOG_PRIVATE(dialog);
  model = GTK_TREE_MODEL(priv-&gt;account_store);

  if(gtk_tree_model_get_iter_first(model, &amp;iter))
  {
    do
    {
      gtk_tree_model_get(
        model,
        &amp;iter,
        INF_GTK_PERMISSIONS_DIALOG_COLUMN_ID,
        &amp;row_account_id,
        -1
      );

      if(row_account_id == INF_ACL_ACCOUNT_ID_TO_POINTER(account))
      {
        if(out_iter != NULL)
          *out_iter = iter;
        return TRUE;
      }
    } while(gtk_tree_model_iter_next(model, &amp;iter));
  }

  return FALSE;
}

static InfGtkPermissionsDialogPendingSheet*
inf_gtk_permissions_dialog_find_pending_sheet(InfGtkPermissionsDialog* dialog,
                                              GtkTreeIter* iter)
{
  InfGtkPermissionsDialogPrivate* priv;
  GtkTreeModel* model;
  GtkTreePath* path;
  GSList* item;
  InfGtkPermissionsDialogPendingSheet* pending;
  GtkTreePath* pending_path;

  priv = INF_GTK_PERMISSIONS_DIALOG_PRIVATE(dialog);
  model = GTK_TREE_MODEL(priv-&gt;account_store);

  path = gtk_tree_model_get_path(model, iter);
  for(item = priv-&gt;pending_sheets; item != NULL; item = item-&gt;next)
  {
    pending = (InfGtkPermissionsDialogPendingSheet*)item-&gt;data;
    pending_path = gtk_tree_row_reference_get_path(pending-&gt;row);
    g_assert(pending_path != NULL);

    if(gtk_tree_path_compare(path, pending_path) == 0)
    {
      gtk_tree_path_free(path);
      gtk_tree_path_free(pending_path);
      return pending;
    }

    gtk_tree_path_free(pending_path);
  }

  gtk_tree_path_free(path);
  return NULL;
}

static void
inf_gtk_permissions_dialog_set_acl_finished_cb(InfRequest* request,
                                               const InfRequestResult* result,
                                               const GError* error,
                                               gpointer user_data)
{
  InfGtkPermissionsDialog* dialog;
  InfGtkPermissionsDialogPrivate* priv;

  dialog = INF_GTK_PERMISSIONS_DIALOG(user_data);
  priv = INF_GTK_PERMISSIONS_DIALOG_PRIVATE(dialog);

  if(error != NULL)
  {
    /* Show the error message */
    inf_gtk_permissions_dialog_update(dialog, error);

    /* Reset sheet to what we had before making the request */
    inf_gtk_permissions_dialog_update_sheet(dialog);
  }

  if(g_slist_find(priv-&gt;set_acl_requests, request) != NULL)
  {
    priv-&gt;set_acl_requests = g_slist_remove(priv-&gt;set_acl_requests, request);
    g_object_unref(request);
  }
}

static void
inf_gtk_permissions_dialog_selection_changed_cb(GtkTreeSelection* selection,
                                                gpointer user_data)
{
  InfGtkPermissionsDialog* dialog;
  dialog = INF_GTK_PERMISSIONS_DIALOG(user_data);

  /* Update the sheet that is displayed */
  inf_gtk_permissions_dialog_update_sheet(dialog);

  /* Also update the account list itself -- if the previously selected entry
   * does not have any permissions set, for example because the user set
   * everything to default, then remove the account from the account list. */
  inf_gtk_permissions_dialog_update(dialog, NULL);
}

static void
inf_gtk_permissions_dialog_sheet_changed_cb(InfGtkAclSheetView* sheet_view,
                                            gpointer user_data)
{
  InfGtkPermissionsDialog* dialog;
  InfGtkPermissionsDialogPrivate* priv;
  const InfAclSheet* sheet;
  InfAclSheetSet sheet_set;
  InfRequest* request;

  GtkTreeSelection* selection;
  gboolean has_selection;
  GtkTreeIter iter;
  InfGtkPermissionsDialogPendingSheet* pending;

  dialog = INF_GTK_PERMISSIONS_DIALOG(user_data);
  priv = INF_GTK_PERMISSIONS_DIALOG_PRIVATE(dialog);

  sheet = inf_gtk_acl_sheet_view_get_sheet(
    INF_GTK_ACL_SHEET_VIEW(priv-&gt;sheet_view)
  );

  /* This can be NULL during destruction, when the sheet view is reset. */
  if(sheet != NULL)
  {
    /* If the sheet does not have an ID set, the lookup is still in progress.
     * In that case, we run the ACL setting once we have looked up the ID. */
    if(sheet-&gt;account != 0)
    {
      sheet_set.own_sheets = NULL;
      sheet_set.sheets = sheet;
      sheet_set.n_sheets = 1;

      request = inf_browser_set_acl(
        priv-&gt;browser,
        &amp;priv-&gt;browser_iter,
        &amp;sheet_set,
        inf_gtk_permissions_dialog_set_acl_finished_cb,
        dialog
      );

      if(request != NULL)
      {
        priv-&gt;set_acl_requests =
          g_slist_prepend(priv-&gt;set_acl_requests, request);
        g_object_ref(request);
      }
    }
    else
    {
      /* Must be a pending sheet */
      selection = gtk_tree_view_get_selection(GTK_TREE_VIEW(priv-&gt;tree_view));
      has_selection = gtk_tree_selection_get_selected(selection, NULL, &amp;iter);
      g_assert(has_selection);

      pending = inf_gtk_permissions_dialog_find_pending_sheet(dialog, &amp;iter);
      g_assert(pending != NULL);

      pending-&gt;sheet = *sheet;
    }
  }
}

static int
inf_gtk_permissions_dialog_account_sort_func(GtkTreeModel* model,
                                             GtkTreeIter* a,
                                             GtkTreeIter* b,
                                             gpointer user_data)
{
  InfGtkPermissionsDialog* dialog;
  InfGtkPermissionsDialogPrivate* priv;

  InfAclAccountId default_id;
  gpointer account_a_id_ptr;
  gpointer account_b_id_ptr;
  InfAclAccountId account_a_id;
  InfAclAccountId account_b_id;
  const gchar* account_a_id_str;
  const gchar* account_b_id_str;
  gchar* account_a_name;
  gchar* account_b_name;

  int result;

  dialog = INF_GTK_PERMISSIONS_DIALOG(user_data);
  priv = INF_GTK_PERMISSIONS_DIALOG_PRIVATE(dialog);

  gtk_tree_model_get(
    model,
    a,
    INF_GTK_PERMISSIONS_DIALOG_COLUMN_ID, &amp;account_a_id_ptr,
    INF_GTK_PERMISSIONS_DIALOG_COLUMN_NAME, &amp;account_a_name,
    -1
  );

  gtk_tree_model_get(
    model,
    b,
    INF_GTK_PERMISSIONS_DIALOG_COLUMN_ID, &amp;account_b_id_ptr,
    INF_GTK_PERMISSIONS_DIALOG_COLUMN_NAME, &amp;account_b_name,
    -1
  );

  account_a_id = INF_ACL_ACCOUNT_POINTER_TO_ID(account_a_id_ptr);
  account_b_id = INF_ACL_ACCOUNT_POINTER_TO_ID(account_b_id_ptr);
  account_a_id_str = inf_acl_account_id_to_string(account_a_id);
  account_b_id_str = inf_acl_account_id_to_string(account_b_id);

  /* default sorts before anything */
  default_id = inf_acl_account_id_from_string(&quot;default&quot;);
  if(account_a_id == default_id)
  {
    if(account_b_id == default_id)
      result = 0;
    else
      result = -1;
  }
  else if(account_b_id == default_id)
  {
    result = 1;
  }
  /* Next, accounts with user name and ID sort before accounts without
   * one of the two*/
  else if(account_a_name != NULL &amp;&amp; account_a_id != 0)
  {
    if(account_b_name != NULL &amp;&amp; account_b_id != 0)
      result = g_utf8_collate(account_a_name, account_b_name);
    else
      result = -1;
  }
  else if(account_b_name != NULL &amp;&amp; account_b_id != 0)
  {
    result = 1;
  }
  /* Next, accounts with ID but no user name are preferred. Such accounts
   * have a lookup pending, but the sheet is synchronized. */
  else if(account_a_name == NULL &amp;&amp; account_a_id != 0)
  {
    if(account_b_name == NULL &amp;&amp; account_b_id != 0)
      result = g_utf8_collate(account_a_id_str, account_b_id_str);
    else
      result = -1;
  }
  else if(account_b_name == NULL &amp;&amp; account_b_id != 0)
  {
    result = 1;
  }
  /* Next, accounts with user name but no ID. These are recently added
   * entries, and the ID lookup is still in progress. The sheets are
   * not yet synchronized. If the ID lookup fails, the entry is removed. */
  else if(account_a_name != NULL &amp;&amp; account_a_id == 0)
  {
    if(account_b_name != NULL &amp;&amp; account_b_id == 0)
      result = g_utf8_collate(account_a_name, account_b_name);
    else
      result = -1;
  }
  else if(account_b_name != NULL &amp;&amp; account_b_id == 0)
  {
    result = 1;
  }
  /* Now, it would mean that both A and B do have neither ID nor name
   * set. This cannot be, since this can only happen with newly created
   * entries, but these entries get a name set immediately. */
  else
  {
    g_assert_not_reached();
    result = 0;
  }

  g_free(account_a_name);
  g_free(account_b_name);
  return result;
}

static void
inf_gtk_permissions_dialog_lookup_by_name_finished_cb(
  InfRequest* request,
  const InfRequestResult* result,
  const GError* error,
  gpointer user_data);

static void
inf_gtk_permissions_dialog_remove_pending_sheet(
  InfGtkPermissionsDialog* dialog,
  InfGtkPermissionsDialogPendingSheet* pending)
{
  InfGtkPermissionsDialogPrivate* priv;
  GtkTreePath* path;
  GtkTreeIter iter;
  gboolean has_iter;

  priv = INF_GTK_PERMISSIONS_DIALOG_PRIVATE(dialog);

  if(pending-&gt;lookup_request != NULL)
  {
    inf_signal_handlers_disconnect_by_func(
      G_OBJECT(pending-&gt;lookup_request),
      G_CALLBACK(inf_gtk_permissions_dialog_lookup_by_name_finished_cb),
      pending
    );

    g_object_unref(pending-&gt;lookup_request);
  }

  /* Remove sheet from the list, so that when gtk_list_store_remove() causes
   * an update (due to the tree selection changing), there is no invalid
   * pending sheet in the list anymore. */
  priv-&gt;pending_sheets = g_slist_remove(priv-&gt;pending_sheets, pending);

  /* Remove the entry from the list, except the pending sheet was realized,
   * i.e. the ID was looked up. */
  if(pending-&gt;row != NULL)
  {
    path = gtk_tree_row_reference_get_path(pending-&gt;row);
    g_assert(path != NULL);

    has_iter = gtk_tree_model_get_iter(
      GTK_TREE_MODEL(priv-&gt;account_store),
      &amp;iter,
      path
    );

    g_assert(has_iter == TRUE);

    gtk_list_store_remove(priv-&gt;account_store, &amp;iter);
    gtk_tree_path_free(path);

    gtk_tree_row_reference_free(pending-&gt;row);
  }

  g_slice_free(InfGtkPermissionsDialogPendingSheet, pending);
}

static void
inf_gtk_permissions_dialog_realize_pending_sheet(
  InfGtkPermissionsDialog* dialog,
  InfGtkPermissionsDialogPendingSheet* pending,
  InfAclAccountId id,
  const gchar* name)
{
  InfGtkPermissionsDialogPrivate* priv;
  GtkTreeIter iter;
  GtkTreePath* path;
  gboolean has_iter;

  InfAclSheet pending_sheet;
  InfAclSheetSet sheet_set;
  InfRequest* request;

  priv = INF_GTK_PERMISSIONS_DIALOG_PRIVATE(dialog);

  pending_sheet = pending-&gt;sheet;
  pending_sheet.account = id;

  if(inf_gtk_permissions_dialog_find_account(dialog, id, &amp;iter))
  {
    /* An entry with that ID exists already. Don't try to merge it with the
     * pending sheet here, but just discard the pending sheet. */
    path = gtk_tree_model_get_path(
      GTK_TREE_MODEL(priv-&gt;account_store),
      &amp;iter
    );

    /* When selecting the already existing entry, block the
     * selection-changed handler, so that it does not already cause an
     * update of the dialog. We do the update after we have also removed
     * the pending sheet */
    inf_signal_handlers_block_by_func(
      G_OBJECT(gtk_tree_view_get_selection(GTK_TREE_VIEW(priv-&gt;tree_view))),
      G_CALLBACK(inf_gtk_permissions_dialog_selection_changed_cb),
      dialog
    );

    gtk_tree_view_set_cursor(
      GTK_TREE_VIEW(priv-&gt;tree_view),
      path,
      gtk_tree_view_get_column(GTK_TREE_VIEW(priv-&gt;tree_view), 0),
      FALSE
    );

    inf_gtk_permissions_dialog_remove_pending_sheet(dialog, pending);

    inf_signal_handlers_unblock_by_func(
      G_OBJECT(gtk_tree_view_get_selection(GTK_TREE_VIEW(priv-&gt;tree_view))),
      G_CALLBACK(inf_gtk_permissions_dialog_selection_changed_cb),
      dialog
    );

    gtk_tree_path_free(path);

    /* Update currently displayed sheet, since we have changed the selection
     * with blocked selection-changed signal handler */
    inf_gtk_permissions_dialog_update_sheet(dialog);
  }
  else
  {
    path = gtk_tree_row_reference_get_path(pending-&gt;row);
    g_assert(path != NULL);

    has_iter  = gtk_tree_model_get_iter(
      GTK_TREE_MODEL(priv-&gt;account_store),
      &amp;iter,
      path
    );

    g_assert(has_iter == TRUE);

    /* Set the entry in the list store */
    gtk_list_store_set(
      priv-&gt;account_store,
      &amp;iter,
      INF_GTK_PERMISSIONS_DIALOG_COLUMN_ID, INF_ACL_ACCOUNT_ID_TO_POINTER(id),
      INF_GTK_PERMISSIONS_DIALOG_COLUMN_NAME, name,
      -1
    );

    /* Remove the pending item. Free the tree row reference before, so that
     * inf_gtk_permissions_dialog_remove_pending_sheet does not remove the
     * realized entry from the list store. */
    gtk_tree_row_reference_free(pending-&gt;row);
    pending-&gt;row = NULL;

    inf_gtk_permissions_dialog_remove_pending_sheet(dialog, pending);

    /* Set the realized sheet on the sheet view. This is important, so that
     * when the sheet view emits its changed signal, the account ID is no
     * longer set to 0. */
    inf_signal_handlers_block_by_func(
      G_OBJECT(priv-&gt;sheet_view),
      G_CALLBACK(inf_gtk_permissions_dialog_sheet_changed_cb),
      dialog
    );

    inf_gtk_acl_sheet_view_set_sheet(
      INF_GTK_ACL_SHEET_VIEW(priv-&gt;sheet_view),
      &amp;pending_sheet
    );

    inf_signal_handlers_unblock_by_func(
      G_OBJECT(priv-&gt;sheet_view),
      G_CALLBACK(inf_gtk_permissions_dialog_sheet_changed_cb),
      dialog
    );

    /* If there are alreay options set, then set the corresponding ACL. Note
     * that in principle our &quot;changed&quot; signal handler would do that, but we
     * have blocked it above. This allows us to reduce network traffic when the
     * mask is empty. */
    if(!inf_acl_mask_empty(&amp;pending_sheet.mask))
    {
      sheet_set.own_sheets = NULL;
      sheet_set.sheets = &amp;pending_sheet;
      sheet_set.n_sheets = 1;

      request = inf_browser_set_acl(
        priv-&gt;browser,
        &amp;priv-&gt;browser_iter,
        &amp;sheet_set,
        inf_gtk_permissions_dialog_set_acl_finished_cb,
        dialog
      );

      if(request != NULL)
      {
        priv-&gt;set_acl_requests =
          g_slist_prepend(priv-&gt;set_acl_requests, request);
        g_object_ref(request);
      }
    }

    /* Update the widget itself, since the add and remove buttons might
     * change their sensitivity after the realization. */
    inf_gtk_permissions_dialog_update(dialog, NULL);
  }
}

static void
inf_gtk_permissions_dialog_lookup_by_name_finished_cb(
  InfRequest* request,
  const InfRequestResult* result,
  const GError* error,
  gpointer user_data)
{
  InfGtkPermissionsDialogPendingSheet* pending;
  InfGtkPermissionsDialog* dialog;
  InfGtkPermissionsDialogPrivate* priv;
  const InfAclAccount* accounts;
  guint n_accounts;

  pending = (InfGtkPermissionsDialogPendingSheet*)user_data;
  dialog = pending-&gt;dialog;
  priv = INF_GTK_PERMISSIONS_DIALOG_PRIVATE(dialog);

  if(pending-&gt;lookup_request != NULL)
  {
    g_object_unref(pending-&gt;lookup_request);
    pending-&gt;lookup_request = NULL;
  }

  if(error != NULL)
  {
    g_warning(&quot;Failed to reverse lookup: %s&quot;, error-&gt;message);
    inf_gtk_permissions_dialog_remove_pending_sheet(dialog, pending);
  }
  else
  {
    inf_request_result_get_lookup_acl_accounts(
      result,
      NULL,
      &amp;accounts,
      &amp;n_accounts
    );

    if(n_accounts &gt; 0)
    {
      /* There is at least one user with the given name. If there are more,
       * we cannot distinguish between them, so just take the first */
      if(n_accounts &gt; 1)
      {
        g_warning(
          &quot;Multiple accounts with the same name \&quot;%s\&quot;&quot;,
          accounts[0].name
        );
      }

      inf_gtk_permissions_dialog_realize_pending_sheet(
        dialog,
        pending,
        accounts[0].id,
        accounts[0].name
      );
    }
    else
    {
      /* There is no user with this name */
      inf_gtk_permissions_dialog_remove_pending_sheet(dialog, pending);
    }
  }
}

static void
inf_gtk_permissions_dialog_lookup_acl_accounts_finished_cb(
  InfRequest* request,
  const InfRequestResult* result,
  const GError* error,
  gpointer user_data);

static void
inf_gtk_permissions_dialog_remove_lookup_acl_accounts_request(
  InfGtkPermissionsDialog* dialog,
  InfRequest* request)
{
  InfGtkPermissionsDialogPrivate* priv;
  priv = INF_GTK_PERMISSIONS_DIALOG_PRIVATE(dialog);

  inf_signal_handlers_disconnect_by_func(
    request,
    G_CALLBACK(inf_gtk_permissions_dialog_lookup_acl_accounts_finished_cb),
    dialog
  );

  /* Can finish instantly */
  if(g_slist_find(priv-&gt;lookup_acl_account_requests, request) != NULL)
  {
    priv-&gt;lookup_acl_account_requests =
      g_slist_remove(priv-&gt;lookup_acl_account_requests, request);

    g_object_unref(request);
  }
}

static void
inf_gtk_permissions_dialog_lookup_acl_accounts_finished_cb(
  InfRequest* request,
  const InfRequestResult* result,
  const GError* error,
  gpointer user_data)
{
  InfGtkPermissionsDialog* dialog;
  InfGtkPermissionsDialogPrivate* priv;
  const InfAclAccount* accounts;
  guint n_accounts;
  guint i;
  GtkTreeIter iter;
  InfAclAccountId account_id;

  dialog = INF_GTK_PERMISSIONS_DIALOG(user_data);
  priv = INF_GTK_PERMISSIONS_DIALOG_PRIVATE(dialog);

  if(error != NULL)
  {
    /* TODO: Should we show this in the dialog? */
    g_warning(&quot;Failed to look up accounts: %s\n&quot;, error-&gt;message);
  }
  else
  {
    inf_request_result_get_lookup_acl_accounts(
      result,
      NULL,
      &amp;accounts,
      &amp;n_accounts
    );

    for(i = 0; i &lt; n_accounts; ++i)
    {
      if(accounts[i].name != NULL)
      {
        account_id = accounts[i].id;
        if(inf_gtk_permissions_dialog_find_account(dialog, account_id, &amp;iter))
        {
          gtk_list_store_set(
            GTK_LIST_STORE(priv-&gt;account_store),
            &amp;iter,
            INF_GTK_PERMISSIONS_DIALOG_COLUMN_NAME,
            accounts[i].name,
            -1
          );
        }
      }
    }
  }

  inf_gtk_permissions_dialog_remove_lookup_acl_accounts_request(
    dialog,
    request
  );
}

static void
inf_gtk_permissions_dialog_fill_account_list(InfGtkPermissionsDialog* dialog,
                                             const InfAclAccountId* ids,
                                             guint n_ids)
{
  InfGtkPermissionsDialogPrivate* priv;
  GtkTreeModel* model;
  gboolean* have_accounts;
  GtkTreeIter iter;
  gpointer account_id_ptr;
  InfAclAccountId account_id;
  gboolean has_row;
  guint i, j;

  InfAclAccountId* lookup_ids;
  guint n_lookup_ids;
  guint lookup_index;
  const gchar* new_account_name;

  InfAclMask perms;
  const InfAclAccount* default_account;
  const InfAclAccount* local_account;
  InfRequest* request;

  priv = INF_GTK_PERMISSIONS_DIALOG_PRIVATE(dialog);
  model = GTK_TREE_MODEL(priv-&gt;account_store);

  /* Remove all accounts that are not present in the given account list.
   * Flag accounts that we have found, and then add all the un-flagged ones.
   * This way we keep the overlapping accounts in the list, which should
   * provide a smooth user experience, for example when an item in the list
   * is selected it is not removed and re-added. */
  have_accounts = g_malloc(n_ids * sizeof(gboolean));
  for(i = 0; i &lt; n_ids; ++i)
    have_accounts[i] = FALSE;
  n_lookup_ids = n_ids;

  has_row = gtk_tree_model_get_iter_first(model, &amp;iter);
  while(has_row)
  {
    gtk_tree_model_get(
      model,
      &amp;iter,
      INF_GTK_PERMISSIONS_DIALOG_COLUMN_ID,
      &amp;account_id_ptr,
      -1
    );
    
    account_id = INF_ACL_ACCOUNT_POINTER_TO_ID(account_id_ptr);

    if(account_id == 0)
    {
      /* This is a pending account, keep it */
      has_row = gtk_tree_model_iter_next(model, &amp;iter);
    }
    else
    {
      for(i = 0; i &lt; n_ids; ++i)
        if(account_id == ids[i])
          break;

      if(i &lt; n_ids)
      {
        have_accounts[i] = TRUE;
        has_row = gtk_tree_model_iter_next(model, &amp;iter);

        g_assert(n_lookup_ids &gt; 0);
        --n_lookup_ids;
      }
      else
      {
        inf_signal_handlers_block_by_func(
          gtk_tree_view_get_selection(GTK_TREE_VIEW(priv-&gt;tree_view)),
          G_CALLBACK(inf_gtk_permissions_dialog_selection_changed_cb),
          dialog
        );

        has_row = gtk_list_store_remove(priv-&gt;account_store, &amp;iter);

        inf_signal_handlers_unblock_by_func(
          gtk_tree_view_get_selection(GTK_TREE_VIEW(priv-&gt;tree_view)),
          G_CALLBACK(inf_gtk_permissions_dialog_selection_changed_cb),
          dialog
        );
      }
    }
  }

  if(n_lookup_ids &gt; 0)
    lookup_ids = g_malloc(sizeof(InfAclAccountId) * n_lookup_ids);
  lookup_index = 0;

  default_account = inf_browser_get_acl_default_account(priv-&gt;browser);
  local_account = inf_browser_get_acl_local_account(priv-&gt;browser);

  for(i = 0; i &lt; n_ids; ++i)
  {
    if(!have_accounts[i])
    {
      if(ids[i] == default_account-&gt;id)
      {
        new_account_name = default_account-&gt;name;
      }
      else if(local_account != NULL &amp;&amp; ids[i] == local_account-&gt;id)
      {
        new_account_name = local_account-&gt;name;
      }
      else
      {
        /* If we have queried the account list, lookup the account in the
         * queried list. */
        new_account_name = NULL;
        for(j = 0; j &lt; priv-&gt;n_accounts; ++j)
        {
          if(priv-&gt;accounts[j].id == ids[i])
          {
            new_account_name = priv-&gt;accounts[j].name;
            break;
          }
        }
      }

      gtk_list_store_insert_with_values(
        priv-&gt;account_store,
        NULL,
        -1,
        INF_GTK_PERMISSIONS_DIALOG_COLUMN_ID,
        INF_ACL_ACCOUNT_ID_TO_POINTER(ids[i]),
        INF_GTK_PERMISSIONS_DIALOG_COLUMN_NAME,
        new_account_name,
        -1
      );

      /* If we don't know the account name, we need to look it up. */
      if(new_account_name == NULL &amp;&amp; ids[i] != default_account-&gt;id)
        lookup_ids[lookup_index++] = ids[i];
    }
  }

  /* Lookup accounts with unknown name, if we can. */
  if(lookup_index &gt; 0)
  {
    g_assert(lookup_index &lt;= n_lookup_ids);

    inf_acl_mask_set1(&amp;perms, INF_ACL_CAN_QUERY_ACCOUNT_LIST);

    inf_browser_check_acl(
      priv-&gt;browser,
      &amp;priv-&gt;browser_iter,
      local_account ? local_account-&gt;id : 0,
      &amp;perms,
      &amp;perms
    );

    if(inf_acl_mask_has(&amp;perms, INF_ACL_CAN_QUERY_ACCOUNT_LIST))
    {
      request = inf_browser_lookup_acl_accounts(
        priv-&gt;browser,
        lookup_ids,
        lookup_index,
        inf_gtk_permissions_dialog_lookup_acl_accounts_finished_cb,
        dialog
      );

      if(request != NULL)
      {
        g_object_ref(request);

        priv-&gt;lookup_acl_account_requests = g_slist_prepend(
          priv-&gt;lookup_acl_account_requests,
          request
        );
      }
    }
  }

  if(n_lookup_ids &gt; 0)
    g_free(lookup_ids);
  g_free(have_accounts);
}

static void
inf_gtk_permissions_dialog_update_sheet(InfGtkPermissionsDialog* dialog)
{
  InfGtkPermissionsDialogPrivate* priv;
  GtkTreeSelection* selection;

  GtkTreeModel* model;
  GtkTreeIter iter;
  gpointer account_id_ptr;
  InfAclAccountId account_id;
  InfAclAccountId default_id;
  const InfAclSheetSet* sheet_set;
  const InfAclSheet* sheet;
  InfAclSheet default_sheet;
  InfAclMask show_mask;
  InfAclMask neg_mask;

  InfGtkPermissionsDialogPendingSheet* pending;
  InfBrowserIter test_iter;

  priv = INF_GTK_PERMISSIONS_DIALOG_PRIVATE(dialog);
  selection = gtk_tree_view_get_selection(GTK_TREE_VIEW(priv-&gt;tree_view));

  inf_signal_handlers_block_by_func(
    G_OBJECT(priv-&gt;sheet_view),
    G_CALLBACK(inf_gtk_permissions_dialog_sheet_changed_cb),
    dialog
  );

  if(!gtk_tree_selection_get_selected(selection, &amp;model, &amp;iter))
  {
    inf_gtk_acl_sheet_view_set_sheet(
      INF_GTK_ACL_SHEET_VIEW(priv-&gt;sheet_view),
      NULL
    );

    account_id = 0;
  }
  else
  {
    gtk_tree_model_get(
      model,
      &amp;iter,
      INF_GTK_PERMISSIONS_DIALOG_COLUMN_ID,
      &amp;account_id_ptr,
      -1
    );

    account_id = INF_ACL_ACCOUNT_POINTER_TO_ID(account_id_ptr);

    if(account_id != 0)
    {
      sheet = NULL;
      sheet_set = inf_browser_get_acl(priv-&gt;browser, &amp;priv-&gt;browser_iter);
      if(sheet_set != NULL)
      {
        sheet = inf_acl_sheet_set_find_const_sheet(sheet_set, account_id);
      }
    }
    else
    {
      /* It is (must be) a pending sheet */
      pending = inf_gtk_permissions_dialog_find_pending_sheet(dialog, &amp;iter);
      g_assert(pending != NULL);

      sheet = &amp;pending-&gt;sheet;
    }

    if(sheet != NULL)
    {
      inf_gtk_acl_sheet_view_set_sheet(
        INF_GTK_ACL_SHEET_VIEW(priv-&gt;sheet_view),
        sheet
      );
    }
    else
    {
      /* No sheet: set default sheet (all permissions masked out) */
      default_sheet.account = account_id;
      inf_acl_mask_clear(&amp;default_sheet.mask);
      inf_acl_mask_clear(&amp;default_sheet.perms);

      inf_gtk_acl_sheet_view_set_sheet(
        INF_GTK_ACL_SHEET_VIEW(priv-&gt;sheet_view),
        &amp;default_sheet
      );
    }
  }

  /* Block default column if this is the default sheet of the root node */
  test_iter = priv-&gt;browser_iter;
  show_mask = INF_ACL_MASK_ALL;
  if(!inf_browser_get_parent(priv-&gt;browser, &amp;test_iter))
  {
    /* This is the root node. Block default column if this is the default
     * account. */
    default_id = inf_acl_account_id_from_string(&quot;default&quot;);

    if(account_id == default_id)
    {
      inf_gtk_acl_sheet_view_set_show_default(
        INF_GTK_ACL_SHEET_VIEW(priv-&gt;sheet_view),
        FALSE
      );
    }
    else
    {
      inf_gtk_acl_sheet_view_set_show_default(
        INF_GTK_ACL_SHEET_VIEW(priv-&gt;sheet_view),
        TRUE
      );
    }
  }
  else
  {
    /* This is a leaf node. Show the default column, and block non-root
     * permissions. */
    inf_gtk_acl_sheet_view_set_show_default(
      INF_GTK_ACL_SHEET_VIEW(priv-&gt;sheet_view),
      TRUE
    );

    /* Remove root-only permissions */
    inf_acl_mask_neg(&amp;INF_ACL_MASK_ROOT, &amp;neg_mask);
    inf_acl_mask_and(&amp;show_mask, &amp;neg_mask, &amp;show_mask);
  }

  /* If the node is a subdirectory, we don't hide the permissions that
   * only work for leaf nodes, since they are applied to all leaf nodes in
   * the subdirectory, unless overridden. */
  if(!inf_browser_is_subdirectory(priv-&gt;browser, &amp;priv-&gt;browser_iter))
  {
    inf_acl_mask_neg(&amp;INF_ACL_MASK_SUBDIRECTORY, &amp;neg_mask);
    inf_acl_mask_and(&amp;show_mask, &amp;neg_mask, &amp;show_mask);
  }

  inf_gtk_acl_sheet_view_set_permission_mask(
    INF_GTK_ACL_SHEET_VIEW(priv-&gt;sheet_view),
    &amp;show_mask
  );

  inf_signal_handlers_unblock_by_func(
    G_OBJECT(priv-&gt;sheet_view),
    G_CALLBACK(inf_gtk_permissions_dialog_sheet_changed_cb),
    dialog
  );
}

static void
inf_gtk_permissions_dialog_node_removed_cb(InfBrowser* browser,
                                           const InfBrowserIter* iter,
                                           InfRequest* request,
                                           gpointer user_data)
{
  InfGtkPermissionsDialog* dialog;
  InfGtkPermissionsDialogPrivate* priv;

  dialog = INF_GTK_PERMISSIONS_DIALOG(user_data);
  priv = INF_GTK_PERMISSIONS_DIALOG_PRIVATE(dialog);

  if(inf_browser_is_ancestor(browser, iter, &amp;priv-&gt;browser_iter))
    inf_gtk_permissions_dialog_set_node(dialog, NULL, NULL);
}

static void
inf_gtk_permissions_dialog_acl_account_added_cb(InfBrowser* browser,
                                                const InfAclAccount* account,
                                                InfRequest* request,
                                                gpointer user_data)
{
  InfGtkPermissionsDialog* dialog;
  InfGtkPermissionsDialogPrivate* priv;

  dialog = INF_GTK_PERMISSIONS_DIALOG(user_data);
  priv = INF_GTK_PERMISSIONS_DIALOG_PRIVATE(dialog);

  /* Add the new user to the user list. Note that this is also called when
   * the given user was updated, in which case we need to call row_changed,
   * since its name might have changed. */
  if(account-&gt;id != 0 &amp;&amp; account-&gt;name != NULL &amp;&amp; priv-&gt;accounts != NULL)
  {
    priv-&gt;accounts = g_realloc(
      priv-&gt;accounts,
      (priv-&gt;n_accounts + 1) * sizeof(InfAclAccount)
    );

    priv-&gt;accounts[priv-&gt;n_accounts].id = account-&gt;id;
    priv-&gt;accounts[priv-&gt;n_accounts].name = g_strdup(account-&gt;name);
    ++priv-&gt;n_accounts;

    /* Need to update because the add button sensitivity might change */
    inf_gtk_permissions_dialog_update(dialog, NULL);
  }
}

static void
inf_gtk_permissions_dialog_acl_account_removed_cb(InfBrowser* browser,
                                                  const InfAclAccount* account,
                                                  InfRequest* request,
                                                  gpointer user_data)
{
  InfGtkPermissionsDialog* dialog;
  InfGtkPermissionsDialogPrivate* priv;
  gboolean have_account;
  GtkTreeIter iter;
  guint i;

  dialog = INF_GTK_PERMISSIONS_DIALOG(user_data);
  priv = INF_GTK_PERMISSIONS_DIALOG_PRIVATE(dialog);

  g_assert(account-&gt;id != 0);

  if(priv-&gt;popup_menu != NULL &amp;&amp; account-&gt;id == priv-&gt;popup_account)
    gtk_menu_popdown(priv-&gt;popup_menu);

  g_assert(priv-&gt;popup_menu == NULL);
  g_assert(priv-&gt;popup_account == 0);

  /* The account should not be in the list anymore, since all ACL sheets for
   * this account should have been removed first. However, it can happen when
   * the removed account is selected, and therefore not removed when the ACL
   * update is notified. Therefore, we remove the entry here even if it is
   * selected, since the account no longer exists. */
  have_account =
    inf_gtk_permissions_dialog_find_account(dialog, account-&gt;id, &amp;iter);
  if(have_account == TRUE)
  {
    /* It is important that we block this signal handler here, otherwise
     * the selection might be changed while we delete the currently selected
     * account, which can trigger an update and iteration in the list store
     * while the call to gtk_list_store_remove() has not yet completed. */
    inf_signal_handlers_block_by_func(
      gtk_tree_view_get_selection(GTK_TREE_VIEW(priv-&gt;tree_view)),
      G_CALLBACK(inf_gtk_permissions_dialog_selection_changed_cb),
      dialog
    );

    gtk_list_store_remove(priv-&gt;account_store, &amp;iter);

    inf_signal_handlers_unblock_by_func(
      gtk_tree_view_get_selection(GTK_TREE_VIEW(priv-&gt;tree_view)),
      G_CALLBACK(inf_gtk_permissions_dialog_selection_changed_cb),
      dialog
    );

    inf_gtk_permissions_dialog_update_sheet(dialog);
  }

  /* Update account list */
  if(priv-&gt;accounts != NULL)
  {
    for(i = 0; i &lt; priv-&gt;n_accounts; ++i)
    {
      if(priv-&gt;accounts[i].id == account-&gt;id)
      {
        priv-&gt;accounts[i] = priv-&gt;accounts[priv-&gt;n_accounts - 1];
        --priv-&gt;n_accounts;

        priv-&gt;accounts = g_realloc(
          priv-&gt;accounts,
          sizeof(InfAclAccount) * priv-&gt;n_accounts
        );

        break;
      }
    }
  }

  /* Need to update because the add button sensitivity might change, and
   * the selected account might change. */
  inf_gtk_permissions_dialog_update(dialog, NULL);
}

static void
inf_gtk_permissions_dialog_acl_changed_cb(InfBrowser* browser,
                                          const InfBrowserIter* iter,
                                          const InfAclSheetSet* sheet_set,
                                          InfRequest* request,
                                          gpointer user_data)
{
  InfGtkPermissionsDialog* dialog;
  InfGtkPermissionsDialogPrivate* priv;

  dialog = INF_GTK_PERMISSIONS_DIALOG(user_data);
  priv = INF_GTK_PERMISSIONS_DIALOG_PRIVATE(dialog);

  /* If the node we are currently viewing had its ACL changed, show the
   * new ACL. */
  if(iter-&gt;node == priv-&gt;browser_iter.node)
    inf_gtk_permissions_dialog_update_sheet(dialog);

  /* If the node or one of its ancestors had their ACL changed, update the
   * view, since we might have been granted or revoked rights to see the
   * user list or the ACL for this node, or the non-default ACL sheets
   * have changed. */
  if(inf_browser_is_ancestor(browser, iter, &amp;priv-&gt;browser_iter))
    inf_gtk_permissions_dialog_update(dialog, NULL);
}

static void
inf_gtk_permissions_dialog_renderer_editing_started_cb(GtkCellRenderer* r,
                                                       GtkCellEditable* edit,
                                                       const gchar* path,
                                                       gpointer user_data)
{
  /* In the editing_canceled signal handler, we need to know the path of the
   * cell that was edited. However, it does not provide a path parameter.
   * Therefore, store the path here in the cell renderer.
   *
   * Normally, we could simply query the selected row, however the row can
   * be deselected without the editing actually being cancelled, for example
   * when focusing another widget. */
  g_object_set_data_full(
    G_OBJECT(r),
    &quot;inf-gtk-permissions-dialog-path&quot;,
    g_strdup(path),
    g_free
  );
}

static void
inf_gtk_permissions_dialog_renderer_editing_canceled_cb(GtkCellRenderer* r,
                                                        gpointer user_data)
{
  InfGtkPermissionsDialog* dialog;
  InfGtkPermissionsDialogPrivate* priv;
  gchar* path_str;
  GtkTreePath* path;
  GtkTreeIter iter;
  gboolean has_selected;
  InfGtkPermissionsDialogPendingSheet* pending;

  dialog = INF_GTK_PERMISSIONS_DIALOG(user_data);
  priv = INF_GTK_PERMISSIONS_DIALOG_PRIVATE(dialog);

  /* Remove the editing facility of the cell renderer */
  g_object_set(
    G_OBJECT(priv-&gt;renderer),
    &quot;model&quot;, NULL,
    &quot;editable&quot;, FALSE,
    NULL
  );

  path_str = g_object_steal_data(
    G_OBJECT(r),
    &quot;inf-gtk-permissions-dialog-path&quot;
  );

  /* Remove the pending sheet */
  path = gtk_tree_path_new_from_string(path_str);
  g_free(path_str);

  has_selected = gtk_tree_model_get_iter(
    GTK_TREE_MODEL(priv-&gt;account_store),
    &amp;iter,
    path
  );

  g_assert(has_selected == TRUE);

  pending = inf_gtk_permissions_dialog_find_pending_sheet(dialog, &amp;iter);
  g_assert(pending != NULL);

  inf_gtk_permissions_dialog_remove_pending_sheet(dialog, pending);
}

static void
inf_gtk_permissions_dialog_renderer_changed_cb(GtkCellRendererCombo* combo,
                                               const gchar* path_str,
                                               GtkTreeIter* combo_iter,
                                               gpointer user_data)
{
  InfGtkPermissionsDialog* dialog;
  InfGtkPermissionsDialogPrivate* priv;
  GtkTreePath* path;
  GtkTreeIter view_iter;
  gboolean has_path;
  InfGtkPermissionsDialogPendingSheet* pending;
  GtkTreeModel* model;
  gpointer id_ptr;

  dialog = INF_GTK_PERMISSIONS_DIALOG(user_data);
  priv = INF_GTK_PERMISSIONS_DIALOG_PRIVATE(dialog);

  path = gtk_tree_path_new_from_string(path_str);

  has_path = gtk_tree_model_get_iter(
    GTK_TREE_MODEL(priv-&gt;account_store),
    &amp;view_iter,
    path
  );

  g_assert(has_path);
  gtk_tree_path_free(path);

  pending = inf_gtk_permissions_dialog_find_pending_sheet(dialog, &amp;view_iter);
  g_assert(pending != NULL);

  g_object_get(G_OBJECT(combo), &quot;model&quot;, &amp;model, NULL);
  g_assert(model != NULL);

  gtk_tree_model_get(
    model,
    combo_iter,
    INF_GTK_PERMISSIONS_DIALOG_COLUMN_ID,
    &amp;id_ptr,
    -1
  );

  pending-&gt;last_combo_changed_id = INF_ACL_ACCOUNT_POINTER_TO_ID(id_ptr);
  g_object_unref(model);
}

static void
inf_gtk_permissions_dialog_renderer_edited_cb(GtkCellRendererCombo* renderer,
                                              const gchar* path_str,
                                              const gchar* text,
                                              gpointer user_data)
{
  InfGtkPermissionsDialog* dialog;
  InfGtkPermissionsDialogPrivate* priv;
  gchar* path_str_obj;
  GtkTreePath* path;
  gboolean has_path;
  GtkTreeIter view_iter;
  InfGtkPermissionsDialogPendingSheet* pending;
  GtkTreeModel* model;
  InfRequest* request;

  dialog = INF_GTK_PERMISSIONS_DIALOG(user_data);
  priv = INF_GTK_PERMISSIONS_DIALOG_PRIVATE(dialog);

  path_str_obj = g_object_steal_data(
    G_OBJECT(renderer),
    &quot;inf-gtk-permissions-dialog-path&quot;
  );

  g_assert(strcmp(path_str_obj, path_str) == 0);
  g_free(path_str_obj);

  path = gtk_tree_path_new_from_string(path_str);

  has_path = gtk_tree_model_get_iter(
    GTK_TREE_MODEL(priv-&gt;account_store),
    &amp;view_iter,
    path
  );

  g_assert(has_path);
  gtk_tree_path_free(path);

  pending = inf_gtk_permissions_dialog_find_pending_sheet(dialog, &amp;view_iter);
  g_assert(pending != NULL);

  /* If we selected a user with the combo box, find the corresponding ID */
  g_object_get(G_OBJECT(renderer), &quot;model&quot;, &amp;model, NULL);

  /* Remove the editing facility of the cell renderer */
  g_object_set(
    G_OBJECT(priv-&gt;renderer),
    &quot;model&quot;, NULL,
    &quot;editable&quot;, FALSE,
    NULL
  );

  g_assert(model != NULL);

  if(gtk_tree_model_iter_n_children(model, NULL) &gt; 0)
  {
    g_assert(pending-&gt;last_combo_changed_id != 0);

    inf_gtk_permissions_dialog_realize_pending_sheet(
      dialog,
      pending,
      pending-&gt;last_combo_changed_id,
      text
    );
  }
  else
  {
    /* While we don't have an ID, set a name to show in the list */
    gtk_list_store_set(
      priv-&gt;account_store,
      &amp;view_iter,
      INF_GTK_PERMISSIONS_DIALOG_COLUMN_NAME,
      text,
      -1
    );

    /* Make a reverse lookup for the ID */
    request = inf_browser_lookup_acl_account_by_name(
      priv-&gt;browser,
      text,
      inf_gtk_permissions_dialog_lookup_by_name_finished_cb,
      pending
    );

    if(request != NULL)
    {
      pending-&gt;lookup_request = request;
      g_object_ref(request);
    }
  }

  g_object_unref(model);
}

static void
inf_gtk_permissions_dialog_add_clicked_cb(GtkButton* button,
                                          gpointer user_data)
{
  InfGtkPermissionsDialog* dialog;
  InfGtkPermissionsDialogPrivate* priv;
  GtkTreeIter new_iter;
  GtkTreePath* new_path;
  InfGtkPermissionsDialogPendingSheet* pending;

  GtkListStore* store;
  const InfAclSheetSet* sheet_set;
  const InfAclSheet* sheet;
  guint i;

  dialog = INF_GTK_PERMISSIONS_DIALOG(user_data);
  priv = INF_GTK_PERMISSIONS_DIALOG_PRIVATE(dialog);

  /* If we are currently naming another pending sheet, then stop editing
   * that. */
  gtk_cell_renderer_stop_editing(priv-&gt;renderer, TRUE);

  /* Insert a new entry without values */
  gtk_list_store_insert_with_values(
    priv-&gt;account_store,
    &amp;new_iter,
    -1,
    INF_GTK_PERMISSIONS_DIALOG_COLUMN_ID,
    0,
    INF_GTK_PERMISSIONS_DIALOG_COLUMN_NAME,
    NULL,
    -1
  );

  new_path = gtk_tree_model_get_path(
    GTK_TREE_MODEL(priv-&gt;account_store),
    &amp;new_iter
  );

  pending = g_slice_new(InfGtkPermissionsDialogPendingSheet);

  pending-&gt;dialog = dialog;
  pending-&gt;row = gtk_tree_row_reference_new(
    GTK_TREE_MODEL(priv-&gt;account_store),
    new_path
  );

  pending-&gt;sheet.account = 0;
  inf_acl_mask_clear(&amp;pending-&gt;sheet.mask);
  inf_acl_mask_clear(&amp;pending-&gt;sheet.perms);

  pending-&gt;last_combo_changed_id = 0;
  pending-&gt;lookup_request = NULL;

  priv-&gt;pending_sheets = g_slist_prepend(priv-&gt;pending_sheets, pending);

  /* Prepare the cell renderer editing */
  store = gtk_list_store_new(2, G_TYPE_POINTER, G_TYPE_STRING);
  g_object_set(
    G_OBJECT(priv-&gt;renderer),
    &quot;model&quot;, store,
    &quot;editable&quot;, TRUE,
    &quot;text-column&quot;, INF_GTK_PERMISSIONS_DIALOG_COLUMN_NAME,
    NULL
  );

  /* TODO: If there are more than, say 25 accounts (should be configurable),
   * then use a free edit instead, and add a GtkEntryCompletion with all the
   * accounts, and perform a lookup-by-name in our cached list first. */
  if(priv-&gt;accounts != NULL)
  {
    /* Create a list of possible accounts */
    g_object_set(G_OBJECT(priv-&gt;renderer), &quot;has-entry&quot;, FALSE, NULL);
    sheet_set = inf_browser_get_acl(priv-&gt;browser, &amp;priv-&gt;browser_iter);

    for(i = 0; i &lt; priv-&gt;n_accounts; ++i)
    {
      /* Skip the default user */
      if(priv-&gt;accounts[i].name != NULL)
      {
        sheet = NULL;

        if(sheet_set != NULL)
        {
          sheet = inf_acl_sheet_set_find_const_sheet(
            sheet_set,
            priv-&gt;accounts[i].id
          );
        }

        if(sheet == NULL)
        {
          gtk_list_store_insert_with_values(
            store,
            NULL,
            -1,
            INF_GTK_PERMISSIONS_DIALOG_COLUMN_ID,
            priv-&gt;accounts[i].id,
            INF_GTK_PERMISSIONS_DIALOG_COLUMN_NAME,
            priv-&gt;accounts[i].name,
            -1
          );
        }
      }
    }

    /* Otherwise the add button would not be set to sensitive */
    g_assert(gtk_tree_model_iter_n_children(GTK_TREE_MODEL(store), NULL) &gt; 0);
  }
  else
  {
    /* Free editing. Note that we still need to set an (empty) model,
     * otherwise the editing widget cannot be set by GtkCellRendererCombo.
     * We could use GtkCellRendererText instead, but then we would need to
     * juggle around with two cell renderers. */
    g_object_set(G_OBJECT(priv-&gt;renderer), &quot;has-entry&quot;, TRUE, NULL);
  }

  /* Sort the name list */
  gtk_tree_sortable_set_sort_column_id(
    GTK_TREE_SORTABLE(store),
    INF_GTK_PERMISSIONS_DIALOG_COLUMN_NAME,
    GTK_SORT_ASCENDING
  );

  gtk_tree_sortable_set_sort_func(
    GTK_TREE_SORTABLE(store),
    INF_GTK_PERMISSIONS_DIALOG_COLUMN_NAME,
    inf_gtk_permissions_dialog_account_sort_func,
    dialog,
    NULL
  );

  g_object_unref(store);

  /* Before we present the editing to the user, just select the row. This
   * runs our signal handler for the selection change, which might remove a
   * row from the list, which would close down the editing again. */
  gtk_tree_selection_select_path(
    gtk_tree_view_get_selection(GTK_TREE_VIEW(priv-&gt;tree_view)),
    new_path
  );

  /* Obtain the path from the row reference, in case the list store was
   * altered by the selection change. */
  gtk_tree_path_free(new_path);
  new_path = gtk_tree_row_reference_get_path(pending-&gt;row);

  gtk_tree_view_set_cursor(
    GTK_TREE_VIEW(priv-&gt;tree_view),
    new_path,
    gtk_tree_view_get_column(GTK_TREE_VIEW(priv-&gt;tree_view), 0),
    TRUE
  );

  gtk_tree_path_free(new_path);
}

static void
inf_gtk_permissions_dialog_remove_clicked_cb(GtkButton* button,
                                             gpointer user_data)
{
  InfGtkPermissionsDialog* dialog;
  InfGtkPermissionsDialogPrivate* priv;
  GtkTreeSelection* selection;
  GtkTreeIter selected_iter;
  gpointer selected_id_ptr;
  InfAclAccountId selected_id;
  InfGtkPermissionsDialogPendingSheet* pending;
  const InfAclSheetSet* sheet_set;
  InfAclSheet set_sheet;
  InfAclSheetSet set_sheet_set;
  guint i;
  InfRequest* request;
  GtkTreeIter move_iter;
  gboolean could_move;

  dialog = INF_GTK_PERMISSIONS_DIALOG(user_data);
  priv = INF_GTK_PERMISSIONS_DIALOG_PRIVATE(dialog);

  selection = gtk_tree_view_get_selection(GTK_TREE_VIEW(priv-&gt;tree_view));
  if(!gtk_tree_selection_get_selected(selection, NULL, &amp;selected_iter))
    return;

  gtk_tree_model_get(
    GTK_TREE_MODEL(priv-&gt;account_store),
    &amp;selected_iter,
    INF_GTK_PERMISSIONS_DIALOG_COLUMN_ID,
    &amp;selected_id_ptr,
    -1
  );

  selected_id = INF_ACL_ACCOUNT_POINTER_TO_ID(selected_id_ptr);
  sheet_set = inf_browser_get_acl(priv-&gt;browser, &amp;priv-&gt;browser_iter);

  if(selected_id == 0)
  {
    /* This is a pending sheet */
    pending = inf_gtk_permissions_dialog_find_pending_sheet(
      dialog,
      &amp;selected_iter
    );

    g_assert(pending != NULL);
    inf_gtk_permissions_dialog_remove_pending_sheet(dialog, pending);
  }
  else if(sheet_set == NULL || sheet_set-&gt;n_sheets == 0)
  {
    /* It can be that the entry is only kept in the list because it is still
     * selected, even though the sheet set is empty. In that case, simply
     * remove the entry from the list. */
    gtk_list_store_remove(priv-&gt;account_store, &amp;selected_iter);
  }
  else
  {
    /* Mask-out all entries */
    set_sheet.account = selected_id;
    inf_acl_mask_clear(&amp;set_sheet.mask);
    inf_acl_mask_clear(&amp;set_sheet.perms);
    
    set_sheet_set.n_sheets = 1;
    set_sheet_set.own_sheets = NULL;
    set_sheet_set.sheets = &amp;set_sheet;

    request = inf_browser_set_acl(
      priv-&gt;browser,
      &amp;priv-&gt;browser_iter,
      &amp;set_sheet_set,
      inf_gtk_permissions_dialog_set_acl_finished_cb,
      dialog
    );

    if(request != NULL)
    {
      priv-&gt;set_acl_requests =
        g_slist_prepend(priv-&gt;set_acl_requests, request);
      g_object_ref(request);
    }

    /* At this point, the ACL might either have been changed instantly or not.
     * In both cases, the selected item should not have been removed from the
     * list store, and our iterator is still valid.
     *
     * In any case, we need to change the selection to a different item,
     * otherwise, once the request finishes, the currently selected entry
     * would not be removed. Note that there must be at least one other item,
     * because the default entry is always shown and the default entry cannot
     * be removed. */
    move_iter = selected_iter;
    could_move = gtk_tree_model_iter_next(
      GTK_TREE_MODEL(priv-&gt;account_store),
      &amp;move_iter
    );

    if(!could_move)
    {
      move_iter = selected_iter;

      could_move = gtk_tree_model_iter_previous(
        GTK_TREE_MODEL(priv-&gt;account_store),
        &amp;move_iter
      );
    }

    g_assert(could_move);

    gtk_tree_selection_select_iter(
      GTK_TREE_SELECTION(selection),
      &amp;move_iter
    );
  }
}

static void
inf_gtk_permissions_dialog_remove_acl_account_finished_cb(
  InfRequest* request,
  const InfRequestResult* result,
  const GError* error,
  gpointer user_data);

static void
inf_gtk_permissions_dialog_remove_remove_acl_account_request(
  InfGtkPermissionsDialog* dialog,
  InfRequest* request)
{
  InfGtkPermissionsDialogPrivate* priv;
  priv = INF_GTK_PERMISSIONS_DIALOG_PRIVATE(dialog);

  g_assert(g_slist_find(priv-&gt;remove_acl_account_requests, request) != NULL);

  g_signal_handlers_disconnect_by_func(
    request,
    G_CALLBACK(inf_gtk_permissions_dialog_remove_acl_account_finished_cb),
    dialog
  );

  priv-&gt;remove_acl_account_requests =
    g_slist_remove(priv-&gt;remove_acl_account_requests, request);

  g_object_unref(request);
}

static void
inf_gtk_permissions_dialog_remove_acl_account_finished_cb(
  InfRequest* request,
  const InfRequestResult* result,
  const GError* error,
  gpointer user_data)
<A NAME="3"></A>{
  InfGtkPermissionsDialog* dialog;

<FONT color="#53858b"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match2037-0.html#3',2,'match2037-top.html#3',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>  dialog = INF_GTK_PERMISSIONS_DIALOG(user_data);

  /* TODO: Should we show this error to the user inside the dialog, or
   * with a message dialog? */
  if(error != NULL)
  {
    g_warning(&quot;Failed to remove account: %s\n&quot;, error-&gt;message);
  }

  inf_gtk_permissions_dialog_remove_remove_acl_account_request(
    dialog,
    request
  );
}

static void
inf_gtk_permissions_dialog_popup_delete_account_cb(GtkMenuItem* item,
                                                   gpointer user_data)
{
  InfGtkPermissionsDialog* dialog;
  InfGtkPermissionsDialogPrivate* priv;
  InfRequest* request;

  dialog = INF_GTK_PERMISSIONS_DIALOG(user_data);
  priv = INF_GTK_PERMISSIONS_DIALOG_PRIVATE(dialog);

  g_assert(priv-&gt;popup_menu != NULL);
  g_assert(priv-&gt;popup_account != 0);

  request = inf_browser_remove_acl_account(</B></FONT>
    priv-&gt;browser,
    priv-&gt;popup_account,
    inf_gtk_permissions_dialog_remove_acl_account_finished_cb,
    dialog
  );

  if(request != NULL)
  {
    g_object_ref(request);

    priv-&gt;remove_acl_account_requests = g_slist_prepend(
      priv-&gt;remove_acl_account_requests,
      request
    );
  }
}

/* TODO: The popup handling code should be shared between this class and
 * InfGtkBrowserView. */

static gboolean
inf_gtk_permissions_dialog_populate_popup(InfGtkPermissionsDialog* dialog,
                                          GtkMenu* menu)
{
  InfGtkPermissionsDialogPrivate* priv;
  GtkWidget* item;

  InfBrowserIter root;
  InfAclMask perms;

  guint n_accounts;
  InfAclAccountId default_id;
  const InfAclAccount* local_account;
  const InfAclAccount** accounts;
  gpointer account_id_ptr;
  InfAclAccountId account_id;
  GtkTreeSelection* selection;
  GtkTreeIter iter;

  priv = INF_GTK_PERMISSIONS_DIALOG_PRIVATE(dialog);
  g_assert(priv-&gt;popup_menu == NULL);

  /* Make sure that we have permissions to remove accounts */
  inf_browser_get_root(priv-&gt;browser, &amp;root);
  inf_acl_mask_set1(&amp;perms, INF_ACL_CAN_REMOVE_ACCOUNT);
  local_account = inf_browser_get_acl_local_account(priv-&gt;browser);

  inf_browser_check_acl(
    priv-&gt;browser,
    &amp;root,
    local_account ? local_account-&gt;id : 0,
    &amp;perms,
    &amp;perms
  );

  if(!inf_acl_mask_has(&amp;perms, INF_ACL_CAN_REMOVE_ACCOUNT))
    return FALSE;

  /* Make sure the selected account is not the default account or a
   * pending account. */
  selection = gtk_tree_view_get_selection(GTK_TREE_VIEW(priv-&gt;tree_view));
  if(!gtk_tree_selection_get_selected(selection, NULL, &amp;iter))
    return FALSE;

  gtk_tree_model_get(
    GTK_TREE_MODEL(priv-&gt;account_store),
    &amp;iter,
    INF_GTK_PERMISSIONS_DIALOG_COLUMN_ID,
    &amp;account_id_ptr,
    -1
  );

  account_id = INF_ACL_ACCOUNT_POINTER_TO_ID(account_id_ptr);

  default_id = inf_acl_account_id_from_string(&quot;default&quot;);
  if(account_id == 0 || account_id == default_id)
    return FALSE;
 
  /* Then, show a menu item to remove an account. */
  item = gtk_menu_item_new_with_mnemonic(_(&quot;_Delete Account&quot;));

  g_signal_connect(
    G_OBJECT(item),
    &quot;activate&quot;,
    G_CALLBACK(inf_gtk_permissions_dialog_popup_delete_account_cb),
    dialog
  );

  gtk_widget_show(item);
  gtk_menu_shell_append(GTK_MENU_SHELL(menu), item);

  /* TODO: These two items need to be added for popdown and stuff,
   * popup_menu needs to be maintained and tracked. */
  priv-&gt;popup_menu = menu;
  priv-&gt;popup_account = INF_ACL_ACCOUNT_POINTER_TO_ID(account_id);

  return TRUE;
}

static void
inf_gtk_permissions_dialog_popup_menu_detach_func(GtkWidget* attach_widget,
                                                  GtkMenu* menu)
{
}

static void
inf_gtk_permissions_dialog_popup_menu_position_func(GtkMenu* menu,
                                                    gint* x,
                                                    gint* y,
                                                    gboolean* push_in,
                                                    gpointer user_data)
{
  InfGtkPermissionsDialog* dialog;
  InfGtkPermissionsDialogPrivate* priv;
  GdkWindow* bin_window;
  GdkScreen* screen;
  GtkRequisition menu_req;
  GdkRectangle monitor;
  gint monitor_num;
  gint orig_x;
  gint orig_y;
  gint height;

  GtkTreeSelection* selection;
  GtkTreeModel* model;
  GtkTreeIter selected_iter;
  GtkTreePath* selected_path;
  GdkRectangle cell_area;

  dialog = INF_GTK_PERMISSIONS_DIALOG(user_data);
  priv = INF_GTK_PERMISSIONS_DIALOG_PRIVATE(dialog);

  /* Place menu below currently selected row */

  bin_window = gtk_tree_view_get_bin_window(GTK_TREE_VIEW(priv-&gt;tree_view));
  gdk_window_get_origin(bin_window, &amp;orig_x, &amp;orig_y);

  screen = gtk_widget_get_screen(GTK_WIDGET(priv-&gt;tree_view));
  monitor_num = gdk_screen_get_monitor_at_window(screen, bin_window);
  if(monitor_num &lt; 0) monitor_num = 0;
  gtk_menu_set_monitor(menu, monitor_num);

  gdk_screen_get_monitor_geometry(screen, monitor_num, &amp;monitor);
  gtk_widget_get_preferred_size(GTK_WIDGET(menu), NULL, &amp;menu_req);

  height = gdk_window_get_height(bin_window);

  selection = gtk_tree_view_get_selection(GTK_TREE_VIEW(priv-&gt;tree_view));
  gtk_tree_selection_get_selected(selection, &amp;model, &amp;selected_iter);
  selected_path = gtk_tree_model_get_path(model, &amp;selected_iter);
  gtk_tree_view_get_cell_area(
    GTK_TREE_VIEW(priv-&gt;tree_view),
    selected_path,
    gtk_tree_view_get_column(GTK_TREE_VIEW(priv-&gt;tree_view), 0),
    &amp;cell_area
  );
  gtk_tree_path_free(selected_path);

  g_assert(cell_area.height &gt; 0);

  if(gtk_widget_get_direction(GTK_WIDGET(priv-&gt;tree_view)) ==
     GTK_TEXT_DIR_LTR)
  {
    *x = orig_x + cell_area.x + cell_area.width - menu_req.width;
  }
  else
  {
    *x = orig_x + cell_area.x;
  }

  *y = orig_y + cell_area.y + cell_area.height;

  /* Keep within widget */
  if(*y &lt; orig_y)
    *y = orig_y;
  if(*y &gt; orig_y + height)
    *y = orig_y + height;

  /* Keep on screen */
  if(*y + menu_req.height &gt; monitor.y + monitor.height)
    *y = monitor.y + monitor.height - menu_req.height;
  if(*y &lt; monitor.y)
    *y = monitor.y;

  *push_in = FALSE;
}

static void
inf_gtk_permissions_dialog_popup_selection_done_cb(GtkMenu* menu,
                                                   gpointer user_data)
{
  InfGtkPermissionsDialog* dialog;
  InfGtkPermissionsDialogPrivate* priv;

  dialog = INF_GTK_PERMISSIONS_DIALOG(user_data);
  priv = INF_GTK_PERMISSIONS_DIALOG_PRIVATE(dialog);

  g_assert(priv-&gt;popup_menu != NULL);
  
  priv-&gt;popup_menu = NULL;
  priv-&gt;popup_account = 0;
}

static gboolean
inf_gtk_permissions_dialog_show_popup(InfGtkPermissionsDialog* dialog,
                                      guint button, /* 0 if triggered by keyboard */
                                      guint32 time)
{
  InfGtkPermissionsDialogPrivate* priv;
  GtkWidget* menu;
  gboolean result;

  priv = INF_GTK_PERMISSIONS_DIALOG_PRIVATE(dialog);

  menu = gtk_menu_new();

  g_signal_connect(
    G_OBJECT(menu),
    &quot;selection-done&quot;,
    G_CALLBACK(inf_gtk_permissions_dialog_popup_selection_done_cb),
    dialog
  );

  gtk_menu_attach_to_widget(
    GTK_MENU(menu),
    GTK_WIDGET(priv-&gt;tree_view),
    inf_gtk_permissions_dialog_popup_menu_detach_func
  );

  if(inf_gtk_permissions_dialog_populate_popup(dialog, GTK_MENU(menu)))
  {
    result = TRUE;

    if(button)
    {
      gtk_menu_popup(GTK_MENU(menu), NULL, NULL, NULL, NULL, button, time);
    }
    else
    {
      gtk_menu_popup(
        GTK_MENU(menu),
        NULL,
        NULL,
        inf_gtk_permissions_dialog_popup_menu_position_func,
        priv-&gt;tree_view,
        button,
        time
      );

      gtk_menu_shell_select_first(GTK_MENU_SHELL(menu), FALSE);
    }
  }
  else
  {
    result = FALSE;
    gtk_widget_destroy(menu);
  }

  return result;
}

static gboolean
inf_gtk_permissions_dialog_button_press_event_cb(GtkWidget* treeview,
                                                 GdkEventButton* event,
                                                 gpointer user_data)
{
  InfGtkPermissionsDialog* dialog;
  GtkTreePath* path;
  gboolean has_path;

  dialog = INF_GTK_PERMISSIONS_DIALOG(user_data);

  if(event-&gt;button == 3 &amp;&amp;
     event-&gt;window == gtk_tree_view_get_bin_window(GTK_TREE_VIEW(treeview)))
  {
    has_path = gtk_tree_view_get_path_at_pos(
      GTK_TREE_VIEW(treeview),
      event-&gt;x,
      event-&gt;y,
      &amp;path,
      NULL,
      NULL,
      NULL
    );

    if(has_path)
    {
      gtk_tree_selection_select_path(
        gtk_tree_view_get_selection(GTK_TREE_VIEW(treeview)),
        path
      );

      gtk_tree_path_free(path);

      return inf_gtk_permissions_dialog_show_popup(
        dialog,
        event-&gt;button,
        event-&gt;time
      );
    }
  }

  return FALSE;
}

static gboolean
inf_gtk_permissions_dialog_key_press_event_cb(GtkWidget* treeview,
                                              GdkEventKey* event,
                                              gpointer user_data)
{
  InfGtkPermissionsDialog* dialog;
  GtkTreeSelection* selection;
  GtkTreeIter iter;

  dialog = INF_GTK_PERMISSIONS_DIALOG(user_data);

  if(event-&gt;keyval == GDK_KEY_Menu)
  {
    selection = gtk_tree_view_get_selection(GTK_TREE_VIEW(treeview));
    if(gtk_tree_selection_get_selected(selection, NULL, &amp;iter))
    {
      return inf_gtk_permissions_dialog_show_popup(dialog, 0, event-&gt;time);
    }
  }

  return FALSE;
}

static void
inf_gtk_permissions_dialog_name_data_func(GtkTreeViewColumn* column,
                                          GtkCellRenderer* cell,
                                          GtkTreeModel* model,
                                          GtkTreeIter* iter,
                                          gpointer user_data)
{
  gpointer account_id_ptr;
  InfAclAccountId account_id;
  const gchar* account_id_str;
  InfAclAccountId default_id;
  gchar* account_name;
  gchar* str;

  gtk_tree_model_get(
    model,
    iter,
    INF_GTK_PERMISSIONS_DIALOG_COLUMN_ID, &amp;account_id_ptr,
    INF_GTK_PERMISSIONS_DIALOG_COLUMN_NAME, &amp;account_name,
    -1
  );

  account_id = INF_ACL_ACCOUNT_POINTER_TO_ID(account_id_ptr);
  account_id_str = inf_acl_account_id_to_string(account_id);

  if(account_name != NULL)
  {
    g_object_set(G_OBJECT(cell), &quot;text&quot;, account_name, NULL);
  }
  else if(account_id_str != NULL)
  {
    str = g_strdup_printf(&quot;&lt;%s&gt;&quot;, account_id_str);
    g_object_set(G_OBJECT(cell), &quot;text&quot;, str, NULL);
    g_free(str);
  }
  else
  {
    g_object_set(G_OBJECT(cell), &quot;text&quot;, &quot;&quot;, NULL);
  }

  /* Set red foreground color if either ID or name is missing, meaning we are
   * still looking them up, or that some information is denied from us by
   * the server. */
  default_id = inf_acl_account_id_from_string(&quot;default&quot;);
  if( (account_id == 0 || account_name == NULL) &amp;&amp; account_id != default_id)
    g_object_set(G_OBJECT(cell), &quot;foreground&quot;, &quot;red&quot;, NULL);
  else
    g_object_set(G_OBJECT(cell), &quot;foreground-set&quot;, FALSE, NULL);

  g_free(account_name);
}

static void
inf_gtk_permissions_dialog_query_acl_account_list_finished_cb(
  InfRequest* request,
  const InfRequestResult* res,
  const GError* error,
  gpointer user_data)
{
  InfGtkPermissionsDialog* dialog;
  InfGtkPermissionsDialogPrivate* priv;
  const InfAclAccount* accounts;
  guint n_accounts;
  guint i;

  InfAclAccountId account_id;
  GtkTreeIter iter;

  dialog = INF_GTK_PERMISSIONS_DIALOG(user_data);
  priv = INF_GTK_PERMISSIONS_DIALOG_PRIVATE(dialog);

  priv-&gt;query_acl_account_list_request = NULL;
  priv-&gt;account_list_queried = TRUE;

  if(error != NULL)
  {
    if(error-&gt;domain != inf_directory_error_quark() ||
       error-&gt;code != INF_DIRECTORY_ERROR_OPERATION_UNSUPPORTED)
    {
      g_warning(&quot;Error while querying account list: %s\n&quot;, error-&gt;message);
    }
  }
  else
  {
    inf_request_result_get_query_acl_account_list(
      res,
      NULL,
      &amp;accounts,
      &amp;n_accounts,
      NULL
    );

    /* Update user names from local account cache */
    for(i = 0; i &lt; n_accounts; ++i)
    {
      if(accounts[i].name != NULL)
      {
        account_id = accounts[i].id;
        if(inf_gtk_permissions_dialog_find_account(dialog, account_id, &amp;iter))
        {
          gtk_list_store_set(
            GTK_LIST_STORE(priv-&gt;account_store),
            &amp;iter,
            INF_GTK_PERMISSIONS_DIALOG_COLUMN_NAME,
            accounts[i].name,
            -1
          );
        }
      }
    }

    /* Update local account cache */
    for(i = 0; i &lt; priv-&gt;n_accounts; ++i)
      g_free(priv-&gt;accounts[i].name);

    priv-&gt;accounts = g_realloc(
      priv-&gt;accounts,
      n_accounts * sizeof(InfAclAccount)
    );

    for(i = 0; i &lt; n_accounts; ++i)
    {
      priv-&gt;accounts[i].id = accounts[i].id;
      priv-&gt;accounts[i].name = g_strdup(accounts[i].name);
    }

    priv-&gt;n_accounts = n_accounts;
  }
}

static void
inf_gtk_permissions_dialog_query_acl_finished_cb(InfRequest* request,
                                                 const InfRequestResult* res,
                                                 const GError* error,
                                                 gpointer user_data)
{
  InfGtkPermissionsDialog* dialog;
  InfGtkPermissionsDialogPrivate* priv;

  dialog = INF_GTK_PERMISSIONS_DIALOG(user_data);
  priv = INF_GTK_PERMISSIONS_DIALOG_PRIVATE(dialog);

  priv-&gt;query_acl_request = NULL;
  inf_gtk_permissions_dialog_update(dialog, error);
}

static void
inf_gtk_permissions_dialog_update(InfGtkPermissionsDialog* dialog,
                                  const GError* error)
{
  InfGtkPermissionsDialogPrivate* priv;
  gchar* path;
  gchar* title;

  InfAclMask perms;

  GArray* accounts;
  const InfAclAccount* local_account;
  const InfAclSheetSet* sheet_set;
  gboolean has_default;
  InfAclAccountId default_id;
  guint i;

  GtkTreeSelection* selection;
  GtkTreeIter selected_iter;
  gpointer selected_id_ptr;
  GtkTreePath* selected_path;
  InfAclAccountId selected_id;
  gboolean has_selected;
  GSList* item;
  InfGtkPermissionsDialogPendingSheet* pending;
  GtkTreePath* pending_path;

  const gchar* query_acl_str;
  const gchar* set_acl_str;
  gchar* error_str;
  gchar* str;

  priv = INF_GTK_PERMISSIONS_DIALOG_PRIVATE(dialog);

  /* Reset all widgets if no node is set */
  if(priv-&gt;browser == NULL)
  {
    gtk_list_store_clear(priv-&gt;account_store);
    gtk_label_set_text(GTK_LABEL(priv-&gt;status_text), _(&quot;No node selected&quot;));
    return;
  }

  /* Set the dialog title */
  path = inf_browser_get_path(priv-&gt;browser, &amp;priv-&gt;browser_iter);
  title = g_strdup_printf(_(&quot;Permissions for %s&quot;), path);
  gtk_window_set_title(GTK_WINDOW(dialog), title);
  g_free(path);
  g_free(title);

  inf_acl_mask_set1(&amp;perms, INF_ACL_CAN_QUERY_ACCOUNT_LIST);
  inf_acl_mask_or1(&amp;perms, INF_ACL_CAN_QUERY_ACL);
  inf_acl_mask_or1(&amp;perms, INF_ACL_CAN_SET_ACL);
  local_account = inf_browser_get_acl_local_account(priv-&gt;browser);

  inf_browser_check_acl(
    priv-&gt;browser,
    &amp;priv-&gt;browser_iter,
    local_account ? local_account-&gt;id : 0,
    &amp;perms,
    &amp;perms
  );

  /* Request account list */
  if(priv-&gt;query_acl_account_list_request == NULL &amp;&amp;
     priv-&gt;account_list_queried == FALSE)
  {
    if(inf_acl_mask_has(&amp;perms, INF_ACL_CAN_QUERY_ACCOUNT_LIST) &amp;&amp;
       inf_acl_mask_has(&amp;perms, INF_ACL_CAN_SET_ACL))
    {
      priv-&gt;query_acl_account_list_request = inf_browser_get_pending_request(
        priv-&gt;browser,
        NULL,
        &quot;query-acl-account-list&quot;
      );

      if(priv-&gt;query_acl_account_list_request == NULL)
      {
        priv-&gt;query_acl_account_list_request =
          inf_browser_query_acl_account_list(
            priv-&gt;browser,
            inf_gtk_permissions_dialog_query_acl_account_list_finished_cb,
            dialog
          );
      }
      else
      {
        g_signal_connect(
          G_OBJECT(priv-&gt;query_acl_account_list_request),
          &quot;finished&quot;,
          G_CALLBACK(
            inf_gtk_permissions_dialog_query_acl_account_list_finished_cb
          ),
          dialog
        );
      }
    }
  }

  /* Request ACL */
  if(!inf_browser_has_acl(priv-&gt;browser, &amp;priv-&gt;browser_iter, 0))
  {
    if(inf_acl_mask_has(&amp;perms, INF_ACL_CAN_QUERY_ACL) &amp;&amp;
       priv-&gt;query_acl_request == NULL &amp;&amp; error == NULL)
    {
      priv-&gt;query_acl_request = inf_browser_get_pending_request(
        priv-&gt;browser,
        &amp;priv-&gt;browser_iter,
        &quot;query-acl&quot;
      );

      if(priv-&gt;query_acl_request == NULL)
      {
        priv-&gt;query_acl_request = inf_browser_query_acl(
          priv-&gt;browser,
          &amp;priv-&gt;browser_iter,
          inf_gtk_permissions_dialog_query_acl_finished_cb,
          dialog
        );
      }
      else
      {
        g_signal_connect(
          G_OBJECT(priv-&gt;query_acl_request),
          &quot;finished&quot;,
          G_CALLBACK(inf_gtk_permissions_dialog_query_acl_finished_cb),
          dialog
        );
      }
    }
  }

  /* Fill the account list widget. If an account is currently selected,
   * keep it there until the selection changes, even if does not show
   * up in the ACL sheet (anymore). */
  accounts = g_array_new(FALSE, FALSE, sizeof(InfAclAccountId));
  sheet_set = inf_browser_get_acl(priv-&gt;browser, &amp;priv-&gt;browser_iter);
  default_id = inf_acl_account_id_from_string(&quot;default&quot;);

  selected_id = 0;
  selected_path = NULL;
  selection = gtk_tree_view_get_selection(GTK_TREE_VIEW(priv-&gt;tree_view));
  if(gtk_tree_selection_get_selected(selection, NULL, &amp;selected_iter))
  {
    gtk_tree_model_get(
      GTK_TREE_MODEL(priv-&gt;account_store),
      &amp;selected_iter,
      INF_GTK_PERMISSIONS_DIALOG_COLUMN_ID,
      &amp;selected_id_ptr,
      -1
    );

    selected_id = INF_ACL_ACCOUNT_POINTER_TO_ID(selected_id_ptr);

    selected_path = gtk_tree_model_get_path(
      GTK_TREE_MODEL(priv-&gt;account_store),
      &amp;selected_iter
    );
  }

  has_default = FALSE;
  has_selected = FALSE;
  if(sheet_set != NULL)
  {
    for(i = 0; i &lt; sheet_set-&gt;n_sheets; ++i)
    {
      g_array_append_val(accounts, sheet_set-&gt;sheets[i].account);
      if(sheet_set-&gt;sheets[i].account == default_id)
        has_default = TRUE;
      if(sheet_set-&gt;sheets[i].account == selected_id)
        has_selected = TRUE;
    }
  }

  if(has_default == FALSE)
    g_array_append_val(accounts, default_id);
  if(selected_id != 0 &amp;&amp; selected_id != default_id &amp;&amp; has_selected == FALSE)
    g_array_append_val(accounts, selected_id);

  /* Remove all non-selected pending sheets that have an empty mask */
  for(item = priv-&gt;pending_sheets; item != NULL; item = item-&gt;next)
  {
    pending = (InfGtkPermissionsDialogPendingSheet*)item-&gt;data;
    if(inf_acl_mask_empty(&amp;pending-&gt;sheet.mask))
    {
      pending_path = gtk_tree_row_reference_get_path(pending-&gt;row);
      g_assert(pending_path != NULL);

      if(selected_path == NULL ||
         gtk_tree_path_compare(pending_path, selected_path) != 0)
      {
        gtk_tree_path_free(pending_path);
        inf_gtk_permissions_dialog_remove_pending_sheet(dialog, pending);
        break;
      }

      gtk_tree_path_free(pending_path);
    }
  }

  if(selected_path != NULL)
    gtk_tree_path_free(selected_path);

  /* Note that this might remove rows, and therefore
   * invalidate selected_path */
  inf_gtk_permissions_dialog_fill_account_list(
    dialog,
    (InfAclAccountId*)accounts-&gt;data,
    accounts-&gt;len
  );

  /* Set editability of the sheet view */
  if(!inf_acl_mask_has(&amp;perms, INF_ACL_CAN_SET_ACL) ||
     !inf_browser_has_acl(priv-&gt;browser, &amp;priv-&gt;browser_iter, 0))
  {
    inf_gtk_acl_sheet_view_set_editable(
      INF_GTK_ACL_SHEET_VIEW(priv-&gt;sheet_view),
      FALSE
    );

    gtk_widget_set_sensitive(priv-&gt;add_button, FALSE);
    gtk_widget_set_sensitive(priv-&gt;remove_button, FALSE);

    set_acl_str = _(&quot;Permission is &lt;b&gt;not granted&lt;/b&gt; to modify the permission list. It is read-only.&quot;);
  }
  else
  {
    inf_gtk_acl_sheet_view_set_editable(
      INF_GTK_ACL_SHEET_VIEW(priv-&gt;sheet_view),
      TRUE
    );

    /* Set add button to sensitive if:
     * we don't have user list OR
     * we have user list and not all users exist already in the sheet */
    if(priv-&gt;accounts == NULL || accounts-&gt;len &lt; priv-&gt;n_accounts)
      gtk_widget_set_sensitive(priv-&gt;add_button, TRUE);
    else
      gtk_widget_set_sensitive(priv-&gt;add_button, FALSE);

    /* Set remove button to sensitive if something other than the
     * default account is selected. */
    if(selected_id != default_id)
      gtk_widget_set_sensitive(priv-&gt;remove_button, TRUE);
    else
      gtk_widget_set_sensitive(priv-&gt;remove_button, FALSE);

    set_acl_str = _(&quot;Permission is &lt;b&gt;granted&lt;/b&gt; to modify the permission list.&quot;);
  }

  g_array_free(accounts, TRUE);

  /* Update status text */
  error_str = NULL;
  if(error != NULL)
  {
    error_str = g_markup_printf_escaped(
      _(&quot;&lt;b&gt;Server Error:&lt;/b&gt; %s&quot;),
      error-&gt;message
    );

    query_acl_str = error_str;
  }
  else if(priv-&gt;query_acl_request != NULL)
  {
    query_acl_str = _(&quot;Querying current permissions for &quot;
                      &quot;this node from the server...&quot;);
  }
  else if(!inf_acl_mask_has(&amp;perms, INF_ACL_CAN_QUERY_ACL) &amp;&amp;
          !inf_browser_has_acl(priv-&gt;browser, &amp;priv-&gt;browser_iter, 0))
  {
    query_acl_str = _(&quot;Permission is &lt;b&gt;not granted&lt;/b&gt; to query the &quot;
                      &quot;permission list for this node from the server. &quot;
                      &quot;Showing only default permissions and permissions &quot;
                      &quot;for the own account.&quot;);
  }
  else
  {
    query_acl_str = _(&quot;Permissions are &lt;b&gt;granted&lt;/b&gt; to query the full &quot;
                      &quot;permission list from the server. &quot;
                      &quot;Showing all permissions.&quot;);
  }

  str = g_strdup_printf(&quot;%s\n\n%s&quot;, query_acl_str, set_acl_str);
  g_free(error_str);

  gtk_label_set_markup(GTK_LABEL(priv-&gt;status_text), str);
  g_free(str);
}

static void
inf_gtk_permissions_dialog_register(InfGtkPermissionsDialog* dialog)
{
  InfGtkPermissionsDialogPrivate* priv;
  priv = INF_GTK_PERMISSIONS_DIALOG_PRIVATE(dialog);

  g_assert(priv-&gt;browser != NULL);

  g_signal_connect(
    priv-&gt;browser,
    &quot;node-removed&quot;,
    G_CALLBACK(inf_gtk_permissions_dialog_node_removed_cb),
    dialog
  );

  g_signal_connect(
    priv-&gt;browser,
    &quot;acl-account-added&quot;,
    G_CALLBACK(inf_gtk_permissions_dialog_acl_account_added_cb),
    dialog
  );

  g_signal_connect(
    priv-&gt;browser,
    &quot;acl-account-removed&quot;,
    G_CALLBACK(inf_gtk_permissions_dialog_acl_account_removed_cb),
    dialog
  );

  g_signal_connect(
    priv-&gt;browser,
    &quot;acl-changed&quot;,
    G_CALLBACK(inf_gtk_permissions_dialog_acl_changed_cb),
    dialog
  );
}

static void
inf_gtk_permissions_dialog_unregister(InfGtkPermissionsDialog* dialog)
{
  InfGtkPermissionsDialogPrivate* priv;
  priv = INF_GTK_PERMISSIONS_DIALOG_PRIVATE(dialog);

  g_assert(priv-&gt;browser != NULL);

  inf_signal_handlers_disconnect_by_func(
    priv-&gt;browser,
    G_CALLBACK(inf_gtk_permissions_dialog_node_removed_cb),
    dialog
  );

  inf_signal_handlers_disconnect_by_func(
    priv-&gt;browser,
    G_CALLBACK(inf_gtk_permissions_dialog_acl_account_added_cb),
    dialog
  );

  inf_signal_handlers_disconnect_by_func(
    priv-&gt;browser,
    G_CALLBACK(inf_gtk_permissions_dialog_acl_account_removed_cb),
    dialog
  );

  inf_signal_handlers_disconnect_by_func(
    priv-&gt;browser,
    G_CALLBACK(inf_gtk_permissions_dialog_acl_changed_cb),
    dialog
  );
}

/*
 * GObject virtual functions
 */

static void
inf_gtk_permissions_dialog_init(InfGtkPermissionsDialog* dialog)
{
  InfGtkPermissionsDialogPrivate* priv;
  priv = INF_GTK_PERMISSIONS_DIALOG_PRIVATE(dialog);

  priv-&gt;query_acl_account_list_request = NULL;
  priv-&gt;account_list_queried = FALSE;
  priv-&gt;accounts = NULL;
  priv-&gt;n_accounts = 0;

  priv-&gt;query_acl_request = NULL;
  priv-&gt;set_acl_requests = NULL;
  priv-&gt;remove_acl_account_requests = NULL;
  priv-&gt;lookup_acl_account_requests = NULL;

  priv-&gt;pending_sheets = NULL;

  priv-&gt;popup_menu = NULL;
  priv-&gt;popup_account = 0;

  gtk_widget_init_template(GTK_WIDGET(dialog));

  gtk_tree_sortable_set_sort_column_id(
    GTK_TREE_SORTABLE(priv-&gt;account_store),
    INF_GTK_PERMISSIONS_DIALOG_COLUMN_NAME,
    GTK_SORT_ASCENDING
  );

  gtk_tree_sortable_set_sort_func(
    GTK_TREE_SORTABLE(priv-&gt;account_store),
    INF_GTK_PERMISSIONS_DIALOG_COLUMN_NAME,
    inf_gtk_permissions_dialog_account_sort_func,
    dialog,
    NULL
  );

  gtk_tree_view_column_set_cell_data_func(
    gtk_tree_view_get_column(GTK_TREE_VIEW(priv-&gt;tree_view), 0),
    priv-&gt;renderer,
    inf_gtk_permissions_dialog_name_data_func,
    NULL,
    NULL
  );
}

static void
inf_gtk_permissions_dialog_constructed(GObject* object)
{
  InfGtkPermissionsDialogPrivate* priv;

  G_OBJECT_CLASS(inf_gtk_permissions_dialog_parent_class)-&gt;constructed(
    object
  );

  priv = INF_GTK_PERMISSIONS_DIALOG_PRIVATE(object);

  inf_gtk_permissions_dialog_update(
    INF_GTK_PERMISSIONS_DIALOG(object),
    NULL
  );
}

static void
inf_gtk_permissions_dialog_dispose(GObject* object)
{
  InfGtkPermissionsDialog* dialog;
  InfGtkPermissionsDialogPrivate* priv;

  dialog = INF_GTK_PERMISSIONS_DIALOG(object);
  priv = INF_GTK_PERMISSIONS_DIALOG_PRIVATE(dialog);

  while(priv-&gt;remove_acl_account_requests != NULL)
  {
    inf_gtk_permissions_dialog_remove_remove_acl_account_request(
      dialog,
      priv-&gt;remove_acl_account_requests-&gt;data
    );
  }

  while(priv-&gt;lookup_acl_account_requests != NULL)
  {
    inf_gtk_permissions_dialog_remove_lookup_acl_accounts_request(
      dialog,
      priv-&gt;lookup_acl_account_requests-&gt;data
    );
  }

  if(priv-&gt;browser != NULL)
  {
    inf_gtk_permissions_dialog_set_node(dialog, NULL, NULL);
  }

  g_assert(priv-&gt;set_acl_requests == NULL);
  g_assert(priv-&gt;pending_sheets == NULL);

  G_OBJECT_CLASS(inf_gtk_permissions_dialog_parent_class)-&gt;dispose(object);
}


static void
inf_gtk_permissions_dialog_finalize(GObject* object)
{
  InfGtkPermissionsDialog* dialog;
  InfGtkPermissionsDialogPrivate* priv;
  guint i;

<A NAME="2"></A>  dialog = INF_GTK_PERMISSIONS_DIALOG(object);
  priv = INF_GTK_PERMISSIONS_DIALOG_PRIVATE(dialog);

<FONT color="#980517"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match2037-0.html#2',2,'match2037-top.html#2',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>  for(i = 0; i &lt; priv-&gt;n_accounts; ++i)
    g_free(priv-&gt;accounts[i].name);
  g_free(priv-&gt;accounts);

  G_OBJECT_CLASS(inf_gtk_permissions_dialog_parent_class)-&gt;finalize(object);
}

static void
inf_gtk_permissions_dialog_set_property(GObject* object,
                                        guint prop_id,
                                        const GValue* value,
                                        GParamSpec* pspec)
{
  InfGtkPermissionsDialog* dialog;
  InfGtkPermissionsDialogPrivate* priv;

  dialog = INF_GTK_PERMISSIONS_DIALOG(object);
  priv = INF_GTK_PERMISSIONS_DIALOG_PRIVATE(dialog);

  switch(prop_id)
  {
  case PROP_BROWSER:
    g_assert(priv-&gt;browser == NULL); /* construct only */</B></FONT>
    priv-&gt;browser = INF_BROWSER(g_value_dup_object(value));

    if(priv-&gt;browser != NULL)
      inf_gtk_permissions_dialog_register(dialog);

<A NAME="0"></A>    break;
  case PROP_BROWSER_ITER:
    priv-&gt;browser_iter = *(InfBrowserIter*)g_value_get_boxed(value);
<FONT color="#0000ff"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match2037-0.html#0',2,'match2037-top.html#0',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>    break;
  default:
    G_OBJECT_WARN_INVALID_PROPERTY_ID(object, prop_id, pspec);
    break;
  }
}

static void
inf_gtk_permissions_dialog_get_property(GObject* object,
                                        guint prop_id,
                                        GValue* value,
                                        GParamSpec* pspec)
{
  InfGtkPermissionsDialog* dialog;
  InfGtkPermissionsDialogPrivate* priv;

  dialog = INF_GTK_PERMISSIONS_DIALOG(object);
  priv = INF_GTK_PERMISSIONS_DIALOG_PRIVATE(dialog);

  switch(prop_id)
  {
  case PROP_BROWSER:
    g_value_set_object(value, priv-&gt;browser);
    break;
  case PROP_BROWSER_ITER:
    g_value_set_boxed(value, &amp;priv-&gt;browser_iter);
    break;</B></FONT>
  default:
    G_OBJECT_WARN_INVALID_PROPERTY_ID(object, prop_id, pspec);
    break;
  }
}

/*
 * GType registration
 */

static void
inf_gtk_permissions_dialog_class_init(
  InfGtkPermissionsDialogClass* permissions_dialog_class)
{
  GObjectClass* object_class;
  object_class = G_OBJECT_CLASS(permissions_dialog_class);

  object_class-&gt;constructed = inf_gtk_permissions_dialog_constructed;
  object_class-&gt;dispose = inf_gtk_permissions_dialog_dispose;
  object_class-&gt;finalize = inf_gtk_permissions_dialog_finalize;
  object_class-&gt;set_property = inf_gtk_permissions_dialog_set_property;
  object_class-&gt;get_property = inf_gtk_permissions_dialog_get_property;

  gtk_widget_class_set_template_from_resource(
    GTK_WIDGET_CLASS(object_class),
    &quot;/de/0x539/libinfgtk/ui/infgtkpermissionsdialog.ui&quot;
  );

  gtk_widget_class_bind_template_child_private(
    GTK_WIDGET_CLASS(object_class),
    InfGtkPermissionsDialog,
    account_store
  );

  gtk_widget_class_bind_template_child_private(
    GTK_WIDGET_CLASS(object_class),
    InfGtkPermissionsDialog,
    status_text
  );

  gtk_widget_class_bind_template_child_private(
    GTK_WIDGET_CLASS(object_class),
    InfGtkPermissionsDialog,
    tree_view
  );

  gtk_widget_class_bind_template_child_private(
    GTK_WIDGET_CLASS(object_class),
    InfGtkPermissionsDialog,
    sheet_view
  );

  gtk_widget_class_bind_template_child_private(
    GTK_WIDGET_CLASS(object_class),
    InfGtkPermissionsDialog,
    add_button
  );

  gtk_widget_class_bind_template_child_private(
    GTK_WIDGET_CLASS(object_class),
    InfGtkPermissionsDialog,
    remove_button
  );

  gtk_widget_class_bind_template_child_private(
    GTK_WIDGET_CLASS(object_class),
    InfGtkPermissionsDialog,
    renderer
  );

  gtk_widget_class_bind_template_callback(
    GTK_WIDGET_CLASS(object_class),
    inf_gtk_permissions_dialog_key_press_event_cb
  );

  gtk_widget_class_bind_template_callback(
    GTK_WIDGET_CLASS(object_class),
    inf_gtk_permissions_dialog_button_press_event_cb
  );

  gtk_widget_class_bind_template_callback(
    GTK_WIDGET_CLASS(object_class),
    inf_gtk_permissions_dialog_selection_changed_cb
  );

  gtk_widget_class_bind_template_callback(
    GTK_WIDGET_CLASS(object_class),
    inf_gtk_permissions_dialog_renderer_editing_started_cb
  );

  gtk_widget_class_bind_template_callback(
    GTK_WIDGET_CLASS(object_class),
    inf_gtk_permissions_dialog_renderer_editing_canceled_cb
  );

  gtk_widget_class_bind_template_callback(
    GTK_WIDGET_CLASS(object_class),
    inf_gtk_permissions_dialog_renderer_edited_cb
  );

  gtk_widget_class_bind_template_callback(
    GTK_WIDGET_CLASS(object_class),
    inf_gtk_permissions_dialog_renderer_changed_cb
  );

  gtk_widget_class_bind_template_callback(
    GTK_WIDGET_CLASS(object_class),
    inf_gtk_permissions_dialog_add_clicked_cb
  );

  gtk_widget_class_bind_template_callback(
    GTK_WIDGET_CLASS(object_class),
    inf_gtk_permissions_dialog_remove_clicked_cb
  );

  gtk_widget_class_bind_template_callback(
    GTK_WIDGET_CLASS(object_class),
    inf_gtk_permissions_dialog_sheet_changed_cb
  );

  g_object_class_install_property(
    object_class,
    PROP_BROWSER,
    g_param_spec_object(
      &quot;browser&quot;,
      &quot;Browser&quot;,
      &quot;The browser with the node for which to show the permissions&quot;,
      INF_TYPE_BROWSER,
      G_PARAM_READWRITE | G_PARAM_CONSTRUCT_ONLY
    )
  );

  g_object_class_install_property(
    object_class,
    PROP_BROWSER_ITER,
    g_param_spec_boxed(
      &quot;browser-iter&quot;,
      &quot;Browser Iter&quot;,
      &quot;An iterator pointing to the node inside the browser for which to show &quot;
      &quot;the permissions&quot;,
      INF_TYPE_BROWSER_ITER,
      G_PARAM_READWRITE | G_PARAM_CONSTRUCT_ONLY
    )
  );
}

/*
 * Public API.
 */

/**
 * inf_gtk_permissions_dialog_new: (constructor)
 * @parent: Parent #GtkWindow of the dialog.
 * @dialog_flags: Flags for the dialog, see #GtkDialogFlags.
 * @browser: (allow-none): The #InfBrowser containing the node to show
 * permissions for, or %NULL.
 * @iter: (allow-none): An iterator pointing to the node to show permissions
 * for, or %NULL.
 *
 * Creates a new #InfGtkPermissionsDialog, showing the ACL for the node
 * @iter points to inside @browser. If @browser is %NULL, @iter must be %NULL,
 * too. In that case no permissions are shown, and the node to be shown can
 * be set later with inf_gtk_permissions_dialog_set_node().
 *
 * Returns: (transfer full): A new #InfGtkPermissionsDialog. Free with
 * gtk_widget_destroy() when no longer needed.
 */
InfGtkPermissionsDialog*
inf_gtk_permissions_dialog_new(GtkWindow* parent,
                               GtkDialogFlags dialog_flags,
                               InfBrowser* browser,
                               const InfBrowserIter* iter)
{
  GObject* object;

  g_return_val_if_fail(parent == NULL || GTK_IS_WINDOW(parent), NULL);
  g_return_val_if_fail(browser == NULL || INF_IS_BROWSER(browser), NULL);
  g_return_val_if_fail(browser == NULL || iter != NULL, NULL);

  object = g_object_new(
    INF_GTK_TYPE_PERMISSIONS_DIALOG,
    &quot;browser&quot;, browser,
    &quot;browser-iter&quot;, iter,
    NULL
  );

  if(dialog_flags &amp; GTK_DIALOG_MODAL)
    gtk_window_set_modal(GTK_WINDOW(object), TRUE);

  if(dialog_flags &amp; GTK_DIALOG_DESTROY_WITH_PARENT)
    gtk_window_set_destroy_with_parent(GTK_WINDOW(object), TRUE);

  gtk_window_set_transient_for(GTK_WINDOW(object), parent);
  return INF_GTK_PERMISSIONS_DIALOG(object);
}

/**
 * inf_gtk_permissions_dialog_set_node:
 * @dialog: A #InfGtkPermissionsDialog.
 * @browser: (allow-none): The #InfBrowser containing the node to show
 * permissions for, or %NULL.
 * @iter: (allow-none): An iterator pointing to the node to show permissions
 * for, or %NULL.
 *
 * Changes the node the dialog shows permissions for. To unset the node, both
 * @browser and @iter should be %NULL.
 */
void
inf_gtk_permissions_dialog_set_node(InfGtkPermissionsDialog* dialog,
                                    InfBrowser* browser,
                                    const InfBrowserIter* iter)
{
  InfGtkPermissionsDialogPrivate* priv;
  GSList* item;
  guint i;

  g_return_if_fail(INF_GTK_IS_PERMISSIONS_DIALOG(dialog));
  g_return_if_fail(browser == NULL || INF_IS_BROWSER(browser));
  g_return_if_fail((browser == NULL) == (iter == NULL));

  priv = INF_GTK_PERMISSIONS_DIALOG_PRIVATE(dialog);

  if(priv-&gt;popup_menu != NULL)
    gtk_menu_popdown(priv-&gt;popup_menu);

  if(priv-&gt;browser != NULL)
  {
    if(priv-&gt;query_acl_account_list_request != NULL)
    {
      inf_signal_handlers_disconnect_by_func(
        priv-&gt;query_acl_account_list_request,
        G_CALLBACK(
          inf_gtk_permissions_dialog_query_acl_account_list_finished_cb
        ),
        dialog
      );
      
      priv-&gt;query_acl_account_list_request = NULL;
    }

    if(priv-&gt;query_acl_request != NULL)
    {
      inf_signal_handlers_disconnect_by_func(
        priv-&gt;query_acl_request,
        G_CALLBACK(inf_gtk_permissions_dialog_query_acl_finished_cb),
        dialog
      );

      priv-&gt;query_acl_request = NULL;
    }

    for(item = priv-&gt;set_acl_requests; item != NULL; item = item-&gt;next)
    {
      inf_signal_handlers_disconnect_by_func(
        G_OBJECT(item-&gt;data),
        G_CALLBACK(inf_gtk_permissions_dialog_set_acl_finished_cb),
        dialog
      );

      g_object_unref(item-&gt;data);
    }

    g_slist_free(priv-&gt;set_acl_requests);
    priv-&gt;set_acl_requests = NULL;

    while(priv-&gt;pending_sheets != NULL)
    {
      inf_gtk_permissions_dialog_remove_pending_sheet(
        dialog,
        priv-&gt;pending_sheets-&gt;data
      );
    }
  }

  for(i = 0; i &lt; priv-&gt;n_accounts; ++i)
    g_free(priv-&gt;accounts[i].name);
  g_free(priv-&gt;accounts);
  priv-&gt;accounts = NULL;
  priv-&gt;n_accounts = 0;

  /* While clearing the list store, block the selection changed callback of
   * the treeview, otherwise it would cause
   * inf_gtk_permissions_dialog_update() to be called, which would fill the
   * tree view again while it is being cleared. We issue one update at the
   * end of the node change. */
  inf_signal_handlers_block_by_func(
    gtk_tree_view_get_selection(GTK_TREE_VIEW(priv-&gt;tree_view)),
    G_CALLBACK(inf_gtk_permissions_dialog_selection_changed_cb),
    dialog
  );

  gtk_list_store_clear(priv-&gt;account_store);

  inf_signal_handlers_unblock_by_func(
    gtk_tree_view_get_selection(GTK_TREE_VIEW(priv-&gt;tree_view)),
    G_CALLBACK(inf_gtk_permissions_dialog_selection_changed_cb),
    dialog
  );

  if(priv-&gt;browser != browser)
  {
    if(priv-&gt;browser != NULL)
    {
      inf_gtk_permissions_dialog_unregister(dialog);
      g_object_unref(priv-&gt;browser);
    }

    priv-&gt;browser = browser;
    if(iter != NULL)
      priv-&gt;browser_iter = *iter;

    if(priv-&gt;browser != NULL)
    {
      g_object_ref(priv-&gt;browser);
      inf_gtk_permissions_dialog_register(dialog);
    }

    g_object_notify(G_OBJECT(dialog), &quot;browser&quot;);
    g_object_notify(G_OBJECT(dialog), &quot;browser-iter&quot;);
  }

  inf_gtk_permissions_dialog_update(dialog, NULL);
}

/* vim:set et sw=2 ts=2: */
</PRE>
</div>
  </div>
</body>
</html>
