<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for inf-text-gtk-buffer.c &amp; inf-gtk-permissions-dialog.c</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for inf-text-gtk-buffer.c &amp; inf-gtk-permissions-dialog.c
      </h3>
<h1 align="center">
        5.0%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>inf-text-gtk-buffer.c (5.8884296%)<th>inf-gtk-permissions-dialog.c (4.344512%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(1436-1462)<td><a href="#" name="0">(2778-2804)</a><td align="center"><font color="#ff0000">16</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(82-129)<td><a href="#" name="1">(55-119)</a><td align="center"><font color="#ef0000">15</font>
<tr onclick='openModal("#980517")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#980517"><font color="#980517">-</font><td><a href="#" name="2">(1370-1393)<td><a href="#" name="2">(2747-2769)</a><td align="center"><font color="#cf0000">13</font>
<tr onclick='openModal("#53858b")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#53858b"><font color="#53858b">-</font><td><a href="#" name="3">(1259-1327)<td><a href="#" name="3">(1770-1799)</a><td align="center"><font color="#cf0000">13</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>inf-text-gtk-buffer.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 #include &lt;libinftextgtk/inf-text-gtk-buffer.h&gt;
2 #include &lt;libinftext/inf-text-buffer.h&gt;
3 #include &lt;libinfinity/inf-signals.h&gt;
4 #include &lt;string.h&gt; 
5 struct _InfTextBufferIter {
6   GtkTextIter begin;
7   GtkTextIter end;
8   InfTextUser* user;
9 };
10 typedef struct _InfTextGtkBufferRecord InfTextGtkBufferRecord;
11 struct _InfTextGtkBufferRecord {
12   gboolean insert;
13   guint char_count;
14   guint position;
15   InfTextChunk* chunk;
16   gboolean applied;
17   InfTextGtkBufferRecord* next;
18 };
19 typedef struct _InfTextGtkBufferUserTags InfTextGtkBufferUserTags;
20 struct _InfTextGtkBufferUserTags {
21   InfTextGtkBuffer* buffer;
22 <a name="1"></a>  InfTextUser* user;
23   GtkTextTag* colored_tag;
24   GtkTextTag* colorless_tag;
25 <font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>};
26 typedef struct _InfTextGtkBufferTagRemove InfTextGtkBufferTagRemove;
27 struct _InfTextGtkBufferTagRemove {
28   GtkTextBuffer* buffer;
29   GtkTextIter begin_iter;
30   GtkTextIter end_iter;
31   InfTextGtkBufferUserTags* ignore_tags;
32 };
33 typedef struct _InfTextGtkBufferPrivate InfTextGtkBufferPrivate;
34 struct _InfTextGtkBufferPrivate {
35   GtkTextBuffer* buffer;
36   InfUserTable* user_table;
37   GHashTable* user_tags;
38   InfTextGtkBufferRecord* record;
39   gboolean show_user_colors;
40   InfTextUser* active_user;
41   gboolean wake_on_cursor_movement;
42   gdouble saturation;
43   gdouble value;
44   gdouble alpha;
45 };
46 enum {
47   PROP_0,
48   PROP_BUFFER,
49   PROP_USER_TABLE,
50   PROP_ACTIVE_USER,
51   PROP_WAKE_ON_CURSOR_MOVEMENT,
52   PROP_SHOW_USER_COLORS,
53   PROP_SATURATION,
54   PROP_VALUE,
55   PROP_ALPHA,
56   PROP_MODIFIED
57 };
58 #define INF_TEXT_GTK_BUFFER_PRIVATE(obj) (G_TYPE_INSTANCE_GET_PRIVATE((obj), INF_TEXT_GTK_TYPE_BUFFER, InfTextGtkBufferPrivate))
59 static GQuark inf_text_gtk_buffer_tag_user_quark;</b></font>
60 static void inf_text_gtk_buffer_buffer_iface_init(InfBufferInterface* iface);
61 static void inf_text_gtk_buffer_text_buffer_iface_init(InfTextBufferInterface* iface);
62 G_DEFINE_TYPE_WITH_CODE(InfTextGtkBuffer, inf_text_gtk_buffer, G_TYPE_OBJECT,
63   G_ADD_PRIVATE(InfTextGtkBuffer)
64   G_IMPLEMENT_INTERFACE(INF_TYPE_BUFFER, inf_text_gtk_buffer_buffer_iface_init)
65   G_IMPLEMENT_INTERFACE(INF_TEXT_TYPE_BUFFER, inf_text_gtk_buffer_text_buffer_iface_init))
66 static void
67 inf_text_gtk_update_tag_color(InfTextGtkBuffer* buffer,
68                               GtkTextTag* tag,
69                               InfTextUser* user)
70 {
71   InfTextGtkBufferPrivate* priv;
72   gdouble hue;
73   gdouble saturation;
74   gdouble value;
75   GdkRGBA rgba;
76   priv = INF_TEXT_GTK_BUFFER_PRIVATE(buffer);
77   hue = inf_text_user_get_hue(user);
78   saturation = priv-&gt;saturation;
79   value = priv-&gt;value;
80   gtk_hsv_to_rgb(hue, saturation, value, &amp;rgba.red, &amp;rgba.green, &amp;rgba.blue);
81   rgba.alpha = priv-&gt;alpha;
82   g_object_set(G_OBJECT(tag), "background-rgba", &amp;rgba, NULL);
83 }
84 static void
85 inf_text_gtk_user_notify_hue_cb(GObject* object,
86                                 GParamSpec* pspec,
87                                 gpointer user_data)
88 {
89   InfTextGtkBuffer* buffer;
90   InfTextGtkBufferPrivate* priv;
91   guint user_id;
92   InfTextGtkBufferUserTags* tags;
93   buffer = INF_TEXT_GTK_BUFFER(user_data);
94   priv = INF_TEXT_GTK_BUFFER_PRIVATE(buffer);
95   user_id = inf_user_get_id(INF_USER(object));
96   tags = g_hash_table_lookup(priv-&gt;user_tags, GUINT_TO_POINTER(user_id));
97   g_assert(tags != NULL &amp;&amp; tags-&gt;colored_tag != NULL);
98   inf_text_gtk_update_tag_color(
99     buffer,
100     tags-&gt;colored_tag,
101     INF_TEXT_USER(object)
102   );
103 }
104 static void
105 inf_text_gtk_buffer_user_tags_free(gpointer user_tags)
106 {
107   InfTextGtkBufferUserTags* tags;
108   tags = (InfTextGtkBufferUserTags*)user_tags;
109   if(tags-&gt;colored_tag)
110   {
111     inf_signal_handlers_disconnect_by_func(
112       tags-&gt;user,
113       G_CALLBACK(inf_text_gtk_user_notify_hue_cb),
114       tags-&gt;buffer
115     );
116     g_object_unref(tags-&gt;colored_tag);
117   }
118   if(tags-&gt;colorless_tag)
119     g_object_unref(tags-&gt;colorless_tag);
120   g_slice_free(InfTextGtkBufferUserTags, tags);
121 }
122 static InfTextGtkBufferUserTags*
123 inf_text_gtk_buffer_get_user_tags(InfTextGtkBuffer* buffer,
124                                   guint user_id)
125 {
126   InfTextGtkBufferPrivate* priv;
127   InfTextGtkBufferUserTags* tags;
128   InfUser* user;
129   priv = INF_TEXT_GTK_BUFFER_PRIVATE(buffer);
130   if(user_id == 0)
131     return NULL;
132   tags = g_hash_table_lookup(priv-&gt;user_tags, GUINT_TO_POINTER(user_id));
133   if(tags != NULL)
134   {
135     return tags;
136   }
137   else
138   {
139     user = inf_user_table_lookup_user_by_id(priv-&gt;user_table, user_id);
140     g_assert(INF_TEXT_IS_USER(user));
141     tags = g_slice_new(InfTextGtkBufferUserTags);
142     tags-&gt;buffer = buffer;
143     tags-&gt;user = INF_TEXT_USER(user);
144     tags-&gt;colored_tag = NULL;
145     tags-&gt;colorless_tag = NULL;
146     g_hash_table_insert(priv-&gt;user_tags, GUINT_TO_POINTER(user_id), tags);
147     return tags;
148   }
149 }
150 static GtkTextTag*
151 inf_text_gtk_buffer_get_user_tag(InfTextGtkBuffer* buffer,
152                                  InfTextGtkBufferUserTags* user_tags,
153                                  gboolean colored)
154 {
155   InfTextGtkBufferPrivate* priv;
156   GtkTextTagTable* table;
157   GtkTextTag** tag;
158   gchar* tag_name;
159   guint user_id;
160   const gchar* colorstr;
161   priv = INF_TEXT_GTK_BUFFER_PRIVATE(buffer);
162   tag = colored ? &amp;user_tags-&gt;colored_tag : &amp;user_tags-&gt;colorless_tag;
163   if(*tag != NULL) return *tag;
164   user_id = 0;
165   if(user_tags-&gt;user != NULL)
166     user_id = inf_user_get_id(INF_USER(user_tags-&gt;user));
167   colorstr = colored ? "colored" : "colorless";
168   tag_name = g_strdup_printf("inftextgtk-user-%s-%u", colorstr, user_id);
169   *tag = gtk_text_tag_new(tag_name);
170   g_free(tag_name);
171   table = gtk_text_buffer_get_tag_table(priv-&gt;buffer);
172   gtk_text_tag_table_add(table, *tag);
173   gtk_text_tag_set_priority(*tag, 0);
174   g_object_set_qdata(
175     G_OBJECT(*tag),
176     inf_text_gtk_buffer_tag_user_quark,
177     user_tags-&gt;user
178   );
179   if(colored)
180   {
181     g_signal_connect(
182       G_OBJECT(user_tags-&gt;user),
183       "notify::hue",
184       G_CALLBACK(inf_text_gtk_user_notify_hue_cb),
185       buffer
186     );
187     inf_text_gtk_update_tag_color(buffer, *tag, user_tags-&gt;user);
188   }
189   return *tag;
190 }
191 static InfTextUser*
192 inf_text_gtk_buffer_author_from_tag(GtkTextTag* tag)
193 {
194   gpointer author_ptr;
195   author_ptr = g_object_get_qdata(
196     G_OBJECT(tag),
197     inf_text_gtk_buffer_tag_user_quark
198   );
199   return INF_TEXT_USER(author_ptr);
200 }
201 static InfTextUser*
202 inf_text_gtk_buffer_iter_list_contains_author_tag(GSList* tag_list)
203 {
204   GSList* item;
205   InfTextUser* author;
206   for(item = tag_list; item != NULL; item = g_slist_next(item))
207   {
208     author = inf_text_gtk_buffer_author_from_tag(GTK_TEXT_TAG(item-&gt;data));
209     if(author != NULL) return author;
210   }
211   return NULL;
212 }
213 static InfTextUser*
214 inf_text_gtk_buffer_iter_get_author(GtkTextIter* location)
215 {
216   GSList* tag_list;
217   InfTextUser* author;
218   tag_list = gtk_text_iter_get_tags(location);
219   author = inf_text_gtk_buffer_iter_list_contains_author_tag(tag_list);
220   g_slist_free(tag_list);
221   return author;
222 }
223 static gboolean
224 inf_text_gtk_buffer_iter_is_author_toggle(const GtkTextIter* iter,
225                                           InfTextUser** toggled_on,
226                                           InfTextUser** toggled_off)
227 {
228   GSList* tag_list;
229   InfTextUser* author_on;
230   InfTextUser* author_off;
231   tag_list = gtk_text_iter_get_toggled_tags(iter, TRUE);
232   author_on = inf_text_gtk_buffer_iter_list_contains_author_tag(tag_list);
233   g_slist_free(tag_list);
234   if(author_on == NULL || toggled_off != NULL)
235   {
236     tag_list = gtk_text_iter_get_toggled_tags(iter, FALSE);
237     author_off = inf_text_gtk_buffer_iter_list_contains_author_tag(tag_list);
238     g_slist_free(tag_list);
239   }
240   if(author_on == NULL &amp;&amp; author_off == NULL)
241     if(!gtk_text_iter_is_start(iter) &amp;&amp; !gtk_text_iter_is_end(iter))
242       return FALSE;
243   if(toggled_on) *toggled_on = author_on;
244   if(toggled_off) *toggled_off = author_off;
245   return TRUE;
246 }
247 static void
248 inf_text_gtk_buffer_iter_next_author_toggle(GtkTextIter* iter,
249                                             InfTextUser** user_on,
250                                             InfTextUser** user_off)
251 {
252   gboolean is_author_toggle;
253   do
254   {
255     gtk_text_iter_forward_to_tag_toggle(iter, NULL);
256     is_author_toggle = inf_text_gtk_buffer_iter_is_author_toggle(
257       iter,
258       user_on,
259       user_off
260     );
261   } while(!is_author_toggle);
262 }
263 static void
264 inf_text_gtk_buffer_iter_prev_author_toggle(GtkTextIter* iter,
265                                             InfTextUser** user_on,
266                                             InfTextUser** user_off)
267 {
268   gboolean is_author_toggle;
269   do
270   {
271     gtk_text_iter_backward_to_tag_toggle(iter, NULL);
272     is_author_toggle = inf_text_gtk_buffer_iter_is_author_toggle(
273       iter,
274       user_on,
275       user_off
276     );
277   } while(!is_author_toggle);
278 }
279 static void
280 inf_text_gtk_buffer_ensure_author_tags_priority_foreach_func(GtkTextTag* tag,
281                                                              gpointer data)
282 {
283   InfTextUser* author;
284   author = inf_text_gtk_buffer_author_from_tag(tag);
285   if(author != NULL)
286     gtk_text_tag_set_priority(tag, 0);
287 }
288 static void
289 inf_text_gtk_buffer_update_user_color_tag_table_foreach_func(GtkTextTag* tag,
290                                                              gpointer data)
291 {
292   InfTextGtkBuffer* buffer;
293   InfTextGtkBufferPrivate* priv;
294   InfTextUser* author;
295   buffer = INF_TEXT_GTK_BUFFER(data);
296   priv = INF_TEXT_GTK_BUFFER_PRIVATE(buffer);
297   author = inf_text_gtk_buffer_author_from_tag(tag);
298   if(author != NULL)
299     inf_text_gtk_update_tag_color(buffer, tag, author);
300 }
301 static void
302 inf_text_gtk_buffer_active_user_selection_changed_cb(InfTextUser* user,
303                                                      guint position,
304                                                      gint length,
305                                                      gboolean by_request,
306                                                      gpointer user_data);
307 static void
308 inf_text_gtk_buffer_active_user_notify_status_cb(GObject* object,
309                                                  GParamSpec* pspec,
310                                                  gpointer user_data);
311 static void
312 inf_text_gtk_buffer_apply_tag_cb(GtkTextBuffer* gtk_buffer,
313                                  GtkTextTag* tag,
314                                  GtkTextIter* start,
315                                  GtkTextIter* end,
316                                  gpointer user_data)
317 {
318   if(inf_text_gtk_buffer_author_from_tag(tag) != NULL)
319     g_signal_stop_emission_by_name(G_OBJECT(gtk_buffer), "apply-tag");
320 }
321 static void
322 inf_text_gtk_buffer_buffer_insert_text_tag_table_foreach_func(GtkTextTag* tag,
323                                                               gpointer data)
324 {
325   InfTextGtkBufferTagRemove* tag_remove;
326   tag_remove = (InfTextGtkBufferTagRemove*)data;
327   if(tag_remove-&gt;ignore_tags == NULL ||
328      (tag != tag_remove-&gt;ignore_tags-&gt;colored_tag &amp;&amp;
329       tag != tag_remove-&gt;ignore_tags-&gt;colorless_tag))
330   {
331     gtk_text_buffer_remove_tag(
332       tag_remove-&gt;buffer,
333       tag,
334       &amp;tag_remove-&gt;begin_iter,
335       &amp;tag_remove-&gt;end_iter
336     );
337   }
338 }
339 #ifndef G_DISABLE_ASSERT
340 static gboolean
341 inf_text_gtk_buffer_record_check(InfTextGtkBuffer* buffer,
342                                  InfTextGtkBufferRecord* record)
343 {
344   InfTextGtkBufferPrivate* priv;
345   InfTextChunk* chunk;
346   guint text_len;
347   guint buf_len;
348   gpointer buf_text;
349   gpointer chunk_text;
350   gsize buf_bytes;
351   gsize chunk_bytes;
352   int result;
353   priv = INF_TEXT_GTK_BUFFER_PRIVATE(buffer);
354   text_len = inf_text_chunk_get_length(record-&gt;chunk);
355   buf_len = gtk_text_buffer_get_char_count(priv-&gt;buffer);
356   if(record-&gt;insert)
357   {
358     if(record-&gt;char_count + text_len != buf_len)
359       return FALSE;
360     if(record-&gt;position + text_len &gt; buf_len)
361       return FALSE;
362     chunk = inf_text_buffer_get_slice(
363       INF_TEXT_BUFFER(buffer),
364       record-&gt;position,
365       text_len
366     );
367     buf_text = inf_text_chunk_get_text(record-&gt;chunk, &amp;buf_bytes);
368     chunk_text = inf_text_chunk_get_text(chunk, &amp;chunk_bytes);
369     inf_text_chunk_free(chunk);
370     if(buf_bytes == chunk_bytes)
371       result = memcmp(buf_text, chunk_text, buf_bytes);
372     else
373       result = -1;
374     g_free(buf_text);
375     g_free(chunk_text);
376     if(result != 0) return FALSE;
377   }
378   else
379   {
380     if(text_len &gt; record-&gt;char_count)
381       return FALSE;
382     if(record-&gt;char_count - text_len != buf_len)
383       return FALSE;
384   }
385   return TRUE;
386 }
387 #endif
388 static void
389 inf_text_gtk_buffer_record_transform(InfTextGtkBufferRecord* record,
390                                      InfTextGtkBufferRecord* against)
391 {
392   guint record_len;
393   guint against_len;
394   g_assert(record-&gt;applied == FALSE);
395   g_assert(against-&gt;applied == TRUE);
396   record_len = inf_text_chunk_get_length(record-&gt;chunk);
397   against_len = inf_text_chunk_get_length(against-&gt;chunk);
398   if(record-&gt;insert &amp;&amp; against-&gt;insert)
399   {
400     if(record-&gt;position &gt;= against-&gt;position)
401       record-&gt;position += against_len;
402   }
403   else if(record-&gt;insert &amp;&amp; !against-&gt;insert)
404   {
405     if(record-&gt;position &gt;= against-&gt;position + against_len)
406       record-&gt;position -= against_len;
407     else if(record-&gt;position &gt;= against-&gt;position)
408       record-&gt;position = against-&gt;position;
409   }
410   else if(!record-&gt;insert &amp;&amp; against-&gt;insert)
411   {
412     if(record-&gt;position &gt;= against-&gt;position)
413     {
414       record-&gt;position += against-&gt;position;
415     }
416     else if(record-&gt;position &lt; against-&gt;position &amp;&amp;
417             record-&gt;position + record_len &gt; against-&gt;position)
418     {
419       inf_text_chunk_insert_chunk(
420         record-&gt;chunk,
421         against-&gt;position - record-&gt;position,
422         against-&gt;chunk
423       );
424     }
425   }
426   else if(!record-&gt;insert &amp;&amp; !against-&gt;insert)
427   {
428     if(against-&gt;position + against_len &lt;= record-&gt;position + record_len)
429     {
430       record-&gt;position -= against_len;
431     }
432     else if(against-&gt;position + against_len &gt; record-&gt;position &amp;&amp;
433             against-&gt;position + against_len &lt;= record-&gt;position + record_len)
434     {
435       record-&gt;position = against-&gt;position;
436       inf_text_chunk_erase(
437         record-&gt;chunk,
438         0,
439         against-&gt;position + against_len - record-&gt;position
440       );
441     }
442     else if(against-&gt;position &lt;= record-&gt;position &amp;&amp;
443             against-&gt;position + against_len &gt;= record-&gt;position + record_len)
444     {
445       record-&gt;position = against-&gt;position;
446       inf_text_chunk_erase(
447         record-&gt;chunk,
448         0,
449         inf_text_chunk_get_length(record-&gt;chunk)
450       );
451     }
452     else if(against-&gt;position &gt;= record-&gt;position &amp;&amp;
453             against-&gt;position + against_len &lt;= record-&gt;position + record_len)
454     {
455       inf_text_chunk_erase(
456         record-&gt;chunk,
457         against-&gt;position - record-&gt;position,
458         inf_text_chunk_get_length(against-&gt;chunk)
459       );
460     }
461     else if(against-&gt;position &gt;= record-&gt;position &amp;&amp;
462             against-&gt;position + against_len &gt;= record-&gt;position + record_len)
463     {
464       inf_text_chunk_erase(
465         record-&gt;chunk,
466         against-&gt;position - record-&gt;position,
467         record-&gt;position + record_len - against-&gt;position
468       );
469     }
470   }
471   if(against-&gt;insert)
472   {
473     record-&gt;char_count += against_len;
474   }
475   else
476   {
477     g_assert(record-&gt;char_count &gt;= against_len);
478     record-&gt;char_count -= against_len;
479   }
480 }
481 static void
482 inf_text_gtk_buffer_record_signal(InfTextGtkBuffer* buffer,
483                                   InfTextGtkBufferRecord* record)
484 {
485   InfTextGtkBufferPrivate* priv;
486   InfTextGtkBufferRecord* rec;
487   InfTextGtkBufferTagRemove tag_remove;
488   GtkTextTag* tag;
489   priv = INF_TEXT_GTK_BUFFER_PRIVATE(buffer);
490   g_assert(priv-&gt;active_user != NULL);
491   g_assert(record-&gt;applied == FALSE);
492   g_assert(inf_text_gtk_buffer_record_check(buffer, record));
493   record-&gt;applied = TRUE;
494   for(rec = record-&gt;next; rec != NULL; rec = rec-&gt;next)
495     if(!rec-&gt;applied)
496       inf_text_gtk_buffer_record_transform(rec-&gt;next, record);
497   if(record-&gt;insert)
498   {
499     inf_signal_handlers_block_by_func(
500       G_OBJECT(priv-&gt;buffer),
501       G_CALLBACK(inf_text_gtk_buffer_apply_tag_cb),
502       buffer
503     );
504     tag_remove.buffer = priv-&gt;buffer;
505     tag_remove.ignore_tags = inf_text_gtk_buffer_get_user_tags(
506       buffer,
507       inf_user_get_id(INF_USER(priv-&gt;active_user))
508     );
509     g_assert(tag_remove.ignore_tags != NULL);
510     tag = inf_text_gtk_buffer_get_user_tag(
511       buffer,
512       tag_remove.ignore_tags,
513       priv-&gt;show_user_colors
514     );
515     gtk_text_buffer_get_iter_at_offset(
516       priv-&gt;buffer,
517       &amp;tag_remove.begin_iter,
518       record-&gt;position
519     );
520     gtk_text_buffer_get_iter_at_offset(
521       priv-&gt;buffer,
522       &amp;tag_remove.end_iter,
523       record-&gt;position + inf_text_chunk_get_length(record-&gt;chunk)
524     );
525     gtk_text_tag_table_foreach(
526       gtk_text_buffer_get_tag_table(tag_remove.buffer),
527       inf_text_gtk_buffer_buffer_insert_text_tag_table_foreach_func,
528       &amp;tag_remove
529     );
530     gtk_text_buffer_apply_tag(
531       priv-&gt;buffer,
532       tag,
533       &amp;tag_remove.begin_iter,
534       &amp;tag_remove.end_iter
535     );
536     inf_signal_handlers_unblock_by_func(
537       G_OBJECT(priv-&gt;buffer),
538       G_CALLBACK(inf_text_gtk_buffer_apply_tag_cb),
539       buffer
540     );
541   }
542   inf_signal_handlers_block_by_func(
543     G_OBJECT(priv-&gt;active_user),
544     G_CALLBACK(inf_text_gtk_buffer_active_user_notify_status_cb),
545     buffer
546   );
547   inf_signal_handlers_block_by_func(
548     G_OBJECT(priv-&gt;active_user),
549     G_CALLBACK(inf_text_gtk_buffer_active_user_selection_changed_cb),
550     buffer
551   );
552   if(record-&gt;insert)
553   {
554     inf_text_buffer_text_inserted(
555       INF_TEXT_BUFFER(buffer),
556       record-&gt;position,
557       record-&gt;chunk,
558       INF_USER(priv-&gt;active_user)
559     );
560   }
561   else
562   {
563     inf_text_buffer_text_erased(
564       INF_TEXT_BUFFER(buffer),
565       record-&gt;position,
566       record-&gt;chunk,
567       INF_USER(priv-&gt;active_user)
568     );
569   }
570   inf_signal_handlers_unblock_by_func(
571     G_OBJECT(priv-&gt;active_user),
572     G_CALLBACK(inf_text_gtk_buffer_active_user_notify_status_cb),
573     buffer
574   );
575   inf_signal_handlers_unblock_by_func(
576     G_OBJECT(priv-&gt;active_user),
577     G_CALLBACK(inf_text_gtk_buffer_active_user_selection_changed_cb),
578     buffer
579   );
580 }
581 static void
582 inf_text_gtk_buffer_push_record(InfTextGtkBuffer* buffer,
583                                 gboolean insert,
584                                 guint position,
585                                 InfTextChunk* chunk)
586 {
587   InfTextGtkBufferPrivate* priv;
588   InfTextGtkBufferRecord* rec;
589   priv = INF_TEXT_GTK_BUFFER_PRIVATE(buffer);
590   rec = priv-&gt;record;
591   priv-&gt;record = g_slice_new(InfTextGtkBufferRecord);
592   priv-&gt;record-&gt;insert = insert;
593   priv-&gt;record-&gt;char_count = gtk_text_buffer_get_char_count(priv-&gt;buffer);
594   priv-&gt;record-&gt;position = position;
595   priv-&gt;record-&gt;chunk = chunk;
596   priv-&gt;record-&gt;applied = FALSE;
597   priv-&gt;record-&gt;next = rec;
598   if(rec != NULL &amp;&amp; rec-&gt;applied == FALSE)
599   {
600     if(rec-&gt;char_count != (guint)gtk_text_buffer_get_char_count(priv-&gt;buffer))
601     {
602       inf_text_gtk_buffer_record_signal(buffer, rec);
603 #ifndef G_ASSERT_DISABLED
604       for(; rec != NULL; rec = rec-&gt;next)
605       {
606         g_assert(
607           rec-&gt;applied == TRUE ||
608           rec-&gt;char_count ==
609             (guint)gtk_text_buffer_get_char_count(priv-&gt;buffer)
610         );
611       }
612 #endif
613     }
614   }
615 }
616 static void
617 inf_text_gtk_buffer_pop_record(InfTextGtkBuffer* buffer)
618 {
619   InfTextGtkBufferPrivate* priv;
620   InfTextGtkBufferRecord* rec;
621   guint char_count;
622   guint length;
623   priv = INF_TEXT_GTK_BUFFER_PRIVATE(buffer);
624   g_assert(priv-&gt;record != NULL);
625   if(!priv-&gt;record-&gt;applied)
626   {
627     length = inf_text_chunk_get_length(priv-&gt;record-&gt;chunk);
628     char_count = gtk_text_buffer_get_char_count(priv-&gt;buffer);
629     if(priv-&gt;record-&gt;insert)
630     {
631       g_assert(priv-&gt;record-&gt;char_count + length == char_count);
632     }
633     else
634     {
635       g_assert(priv-&gt;record-&gt;char_count &gt;= length);
636       g_assert(priv-&gt;record-&gt;char_count - length == char_count);
637     }
638     inf_text_gtk_buffer_record_signal(buffer, priv-&gt;record);
639   }
640   rec = priv-&gt;record;
641   priv-&gt;record = rec-&gt;next;
642   inf_text_chunk_free(rec-&gt;chunk);
643   g_slice_free(InfTextGtkBufferRecord, rec);
644 }
645 static void
646 inf_text_gtk_buffer_insert_text_cb_before(GtkTextBuffer* gtk_buffer,
647                                           GtkTextIter* location,
648                                           gchar* text,
649                                           gint len,
650                                           gpointer user_data)
651 {
652   InfTextGtkBuffer* buffer;
653   InfTextGtkBufferPrivate* priv;
654   InfTextChunk* chunk;
655   buffer = INF_TEXT_GTK_BUFFER(user_data);
656   priv = INF_TEXT_GTK_BUFFER_PRIVATE(buffer);
657   g_assert(priv-&gt;active_user != NULL);
658   chunk = inf_text_chunk_new("UTF-8");
659   inf_text_chunk_insert_text(
660     chunk,
661     0,
662     text,
663     len,
664     g_utf8_strlen(text, len),
665     inf_user_get_id(INF_USER(priv-&gt;active_user))
666   );
667   inf_text_gtk_buffer_push_record(
668     buffer,
669     TRUE,
670     gtk_text_iter_get_offset(location),
671     chunk
672   );
673 }
674 static void
675 inf_text_gtk_buffer_insert_text_cb_after(GtkTextBuffer* gtk_buffer,
676                                          GtkTextIter* location,
677                                          gchar* text,
678                                          gint len,
679                                          gpointer user_data)
680 {
681   InfTextGtkBuffer* buffer;
682   InfTextGtkBufferPrivate* priv;
683   gpointer rec_text;
684   gsize bytes;
685   buffer = INF_TEXT_GTK_BUFFER(user_data);
686   priv = INF_TEXT_GTK_BUFFER_PRIVATE(buffer);
687   g_assert(priv-&gt;record != NULL);
688   g_assert(priv-&gt;record-&gt;insert == TRUE);
689 #ifndef G_ASSERT_DISABLED
690   if(priv-&gt;record-&gt;applied == FALSE)
691   {
692     g_assert(
693       priv-&gt;record-&gt;position +
694         inf_text_chunk_get_length(priv-&gt;record-&gt;chunk) ==
695       (guint)gtk_text_iter_get_offset(location)
696     );
697     rec_text = inf_text_chunk_get_text(priv-&gt;record-&gt;chunk, &amp;bytes);
698     g_assert(bytes == (gsize)len);
699     g_assert(memcmp(text, rec_text, bytes) == 0);
700     g_free(rec_text);
701   }
702 #endif
703   inf_text_gtk_buffer_pop_record(buffer);
704 }
705 static void
706 inf_text_gtk_buffer_delete_range_cb_before(GtkTextBuffer* gtk_buffer,
707                                            GtkTextIter* begin,
708                                            GtkTextIter* end,
709                                            gpointer user_data)
710 {
711   InfTextGtkBuffer* buffer;
712   InfTextGtkBufferPrivate* priv;
713   guint begin_offset;
714   guint end_offset;
715   InfTextChunk* chunk;
716   buffer = INF_TEXT_GTK_BUFFER(user_data);
717   priv = INF_TEXT_GTK_BUFFER_PRIVATE(buffer);
718   begin_offset = gtk_text_iter_get_offset(begin);
719   end_offset = gtk_text_iter_get_offset(end);
720   chunk = inf_text_buffer_get_slice(
721     INF_TEXT_BUFFER(buffer),
722     begin_offset,
723     end_offset - begin_offset
724   );
725   inf_text_gtk_buffer_push_record(buffer, FALSE, begin_offset, chunk);
726 }
727 static void
728 inf_text_gtk_buffer_delete_range_cb_after(GtkTextBuffer* gtk_buffer,
729                                           GtkTextIter* begin,
730                                           GtkTextIter* end,
731                                           gpointer user_data)
732 {
733   InfTextGtkBuffer* buffer;
734   InfTextGtkBufferPrivate* priv;
735   buffer = INF_TEXT_GTK_BUFFER(user_data);
736   priv = INF_TEXT_GTK_BUFFER_PRIVATE(buffer);
737   g_assert(priv-&gt;record != NULL);
738   g_assert(priv-&gt;record-&gt;insert == FALSE);
739   g_assert(priv-&gt;record-&gt;applied == TRUE ||
740            priv-&gt;record-&gt;position == (guint)gtk_text_iter_get_offset(begin));
741   inf_text_gtk_buffer_pop_record(buffer);
742 }
743 static void
744 inf_text_gtk_buffer_mark_set_cb(GtkTextBuffer* gtk_buffer,
745                                 GtkTextIter* location,
746                                 GtkTextMark* mark,
747                                 gpointer user_data)
748 {
749   InfTextGtkBuffer* buffer;
750   InfTextGtkBufferPrivate* priv;
751   GtkTextMark* insert_mark;
752   GtkTextMark* sel_mark;
753   GtkTextIter insert_iter;
754   GtkTextIter sel_iter;
755   guint offset;
756   int sel;
757   buffer = INF_TEXT_GTK_BUFFER(user_data);
758   priv = INF_TEXT_GTK_BUFFER_PRIVATE(buffer);
759   insert_mark = gtk_text_buffer_get_insert(gtk_buffer);
760   sel_mark = gtk_text_buffer_get_selection_bound(gtk_buffer);
761   if( (mark == insert_mark || mark == sel_mark) &amp;&amp; priv-&gt;active_user != NULL)
762   {
763     if(inf_user_get_status(INF_USER(priv-&gt;active_user)) == INF_USER_ACTIVE ||
764        priv-&gt;wake_on_cursor_movement == TRUE)
765     {
766       gtk_text_buffer_get_iter_at_mark(gtk_buffer, &amp;insert_iter, insert_mark);
767       gtk_text_buffer_get_iter_at_mark(gtk_buffer, &amp;sel_iter, sel_mark);
768       offset = gtk_text_iter_get_offset(&amp;insert_iter);
769       sel = gtk_text_iter_get_offset(&amp;sel_iter) - offset;
770       if(inf_text_user_get_caret_position(priv-&gt;active_user) != offset ||
771          inf_text_user_get_selection_length(priv-&gt;active_user) != sel)
772       {
773         inf_signal_handlers_block_by_func(
774           G_OBJECT(priv-&gt;active_user),
775           G_CALLBACK(inf_text_gtk_buffer_active_user_notify_status_cb),
776           buffer
777         );
778         inf_signal_handlers_block_by_func(
779           G_OBJECT(priv-&gt;active_user),
780           G_CALLBACK(inf_text_gtk_buffer_active_user_selection_changed_cb),
781           buffer
782         );
783         inf_text_user_set_selection(priv-&gt;active_user, offset, sel, TRUE);
784         inf_signal_handlers_unblock_by_func(
785           G_OBJECT(priv-&gt;active_user),
786           G_CALLBACK(inf_text_gtk_buffer_active_user_notify_status_cb),
787           buffer
788         );
789         inf_signal_handlers_unblock_by_func(
790           G_OBJECT(priv-&gt;active_user),
791           G_CALLBACK(inf_text_gtk_buffer_active_user_selection_changed_cb),
792           buffer
793         );
794       }
795     }
796   }
797 }
798 static void
799 inf_text_gtk_buffer_active_user_notify_status_cb(GObject* object,
800                                                  GParamSpec* pspec,
801                                                  gpointer user_data)
802 {
803   InfTextGtkBuffer* buffer;
804   InfTextGtkBufferPrivate* priv;
805   GtkTextMark* insert_mark;
806   GtkTextMark* sel_mark;
807   GtkTextIter insert_iter;
808   GtkTextIter sel_iter;
809   guint offset;
810   int sel;
811   buffer = INF_TEXT_GTK_BUFFER(user_data);
812   priv = INF_TEXT_GTK_BUFFER_PRIVATE(buffer);
813   g_assert(INF_TEXT_USER(object) == priv-&gt;active_user);
814   switch(inf_user_get_status(INF_USER(object)))
815   {
816   case INF_USER_ACTIVE:
817     insert_mark = gtk_text_buffer_get_insert(priv-&gt;buffer);
818     sel_mark = gtk_text_buffer_get_selection_bound(priv-&gt;buffer);
819     gtk_text_buffer_get_iter_at_mark(priv-&gt;buffer, &amp;insert_iter, insert_mark);
820     gtk_text_buffer_get_iter_at_mark(priv-&gt;buffer, &amp;sel_iter, sel_mark);
821     offset = gtk_text_iter_get_offset(&amp;insert_iter);
822     sel = gtk_text_iter_get_offset(&amp;sel_iter) - offset;
823     if(inf_text_user_get_caret_position(priv-&gt;active_user) != offset ||
824        inf_text_user_get_selection_length(priv-&gt;active_user) != sel)
825     {
826       inf_signal_handlers_block_by_func(
827         G_OBJECT(priv-&gt;active_user),
828         G_CALLBACK(inf_text_gtk_buffer_active_user_selection_changed_cb),
829         buffer
830       );
831       inf_text_user_set_selection(priv-&gt;active_user, offset, sel, TRUE);
832       inf_signal_handlers_unblock_by_func(
833         G_OBJECT(priv-&gt;active_user),
834         G_CALLBACK(inf_text_gtk_buffer_active_user_selection_changed_cb),
835         buffer
836       );
837     }
838     break;
839   case INF_USER_UNAVAILABLE:
840     break;
841   default:
842     break;
843   }
844 }
845 static void
846 inf_text_gtk_buffer_active_user_selection_changed_cb(InfTextUser* user,
847                                                      guint position,
848                                                      gint selection_length,
849                                                      gboolean by_request,
850                                                      gpointer user_data)
851 {
852   InfTextGtkBuffer* buffer;
853   InfTextGtkBufferPrivate* priv;
854   GtkTextIter insert;
855   GtkTextIter selection_bound;
856   buffer = INF_TEXT_GTK_BUFFER(user_data);
857   priv = INF_TEXT_GTK_BUFFER_PRIVATE(buffer);
858   inf_signal_handlers_block_by_func(
859     G_OBJECT(priv-&gt;buffer),
860     G_CALLBACK(inf_text_gtk_buffer_mark_set_cb),
861     buffer
862   );
863   gtk_text_buffer_get_iter_at_offset(priv-&gt;buffer, &amp;insert, position);
864   gtk_text_buffer_get_iter_at_offset(
865     priv-&gt;buffer,
866     &amp;selection_bound,
867     position + selection_length
868   );
869   gtk_text_buffer_select_range(priv-&gt;buffer, &amp;insert, &amp;selection_bound);
870   inf_signal_handlers_unblock_by_func(
871     G_OBJECT(priv-&gt;buffer),
872     G_CALLBACK(inf_text_gtk_buffer_mark_set_cb),
873     buffer
874   );
875 }
876 static void
877 inf_text_gtk_buffer_modified_changed_cb(GtkTextBuffer* buffer,
878                                         gpointer user_data)
879 {
880   g_object_notify(G_OBJECT(user_data), "modified");
881 }
882 static void
883 inf_text_gtk_buffer_set_modified(InfTextGtkBuffer* buffer,
884                                  gboolean modified)
885 {
886   InfTextGtkBufferPrivate* priv;
887   priv = INF_TEXT_GTK_BUFFER_PRIVATE(buffer);
888   if(priv-&gt;buffer != NULL)
889   {
890     inf_signal_handlers_block_by_func(
891       G_OBJECT(priv-&gt;buffer),
892       G_CALLBACK(inf_text_gtk_buffer_modified_changed_cb),
893       buffer
894     );
895     gtk_text_buffer_set_modified(priv-&gt;buffer, modified);
896     inf_signal_handlers_unblock_by_func(
897       G_OBJECT(priv-&gt;buffer),
898       G_CALLBACK(inf_text_gtk_buffer_modified_changed_cb),
899       buffer
900     );
901     g_object_notify(G_OBJECT(buffer), "modified");
902   }
903 }
904 static void
905 inf_text_gtk_buffer_set_buffer(InfTextGtkBuffer* buffer,
906                                GtkTextBuffer* gtk_buffer)
907 {
908   InfTextGtkBufferPrivate* priv;
909   priv = INF_TEXT_GTK_BUFFER_PRIVATE(buffer);
910   if(priv-&gt;buffer != NULL)
911   {
912     inf_signal_handlers_disconnect_by_func(
913       G_OBJECT(priv-&gt;buffer),
914       G_CALLBACK(inf_text_gtk_buffer_apply_tag_cb),
915       buffer
916     );
917     inf_signal_handlers_disconnect_by_func(
918       G_OBJECT(priv-&gt;buffer),
919       G_CALLBACK(inf_text_gtk_buffer_insert_text_cb_before),
920       buffer
921     );
922     inf_signal_handlers_disconnect_by_func(
923       G_OBJECT(priv-&gt;buffer),
924       G_CALLBACK(inf_text_gtk_buffer_insert_text_cb_after),
925       buffer
926     );
927     inf_signal_handlers_disconnect_by_func(
928       G_OBJECT(priv-&gt;buffer),
929       G_CALLBACK(inf_text_gtk_buffer_delete_range_cb_before),
930       buffer
931     );
932     inf_signal_handlers_disconnect_by_func(
933       G_OBJECT(priv-&gt;buffer),
934       G_CALLBACK(inf_text_gtk_buffer_delete_range_cb_after),
935       buffer
936     );
937     inf_signal_handlers_disconnect_by_func(
938       G_OBJECT(priv-&gt;buffer),
939       G_CALLBACK(inf_text_gtk_buffer_mark_set_cb),
940       buffer
941     );
942     inf_signal_handlers_disconnect_by_func(
943       G_OBJECT(priv-&gt;buffer),
944       G_CALLBACK(inf_text_gtk_buffer_modified_changed_cb),
945       buffer
946     );
947 <a name="3"></a>    g_object_unref(G_OBJECT(priv-&gt;buffer));
948   }
949 <font color="#53858b"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>  priv-&gt;buffer = gtk_buffer;
950   if(gtk_buffer != NULL)
951   {
952     g_object_ref(G_OBJECT(gtk_buffer));
953     g_signal_connect(
954       G_OBJECT(gtk_buffer),
955       "apply-tag",
956       G_CALLBACK(inf_text_gtk_buffer_apply_tag_cb),
957       buffer
958     );
959     g_signal_connect(
960       G_OBJECT(gtk_buffer),
961       "insert-text",
962       G_CALLBACK(inf_text_gtk_buffer_insert_text_cb_before),
963       buffer
964     );
965     g_signal_connect_after(
966       G_OBJECT(gtk_buffer),
967       "insert-text",
968       G_CALLBACK(inf_text_gtk_buffer_insert_text_cb_after),
969       buffer
970     );
971     g_signal_connect(
972       G_OBJECT(gtk_buffer),
973       "delete-range",
974       G_CALLBACK(inf_text_gtk_buffer_delete_range_cb_before),
975       buffer
976     );
977     g_signal_connect_after(
978       G_OBJECT(gtk_buffer),
979       "delete-range",
980       G_CALLBACK(inf_text_gtk_buffer_delete_range_cb_after),
981       buffer
982     );
983     g_signal_connect_after(
984       G_OBJECT(gtk_buffer),
985       "mark-set",
986       G_CALLBACK(inf_text_gtk_buffer_mark_set_cb),
987       buffer
988     );
989     g_signal_connect_after(
990       G_OBJECT(gtk_buffer),
991       "modified-changed",
992       G_CALLBACK(inf_text_gtk_buffer_modified_changed_cb),
993       buffer
994     );
995   }
996   g_object_notify(G_OBJECT(buffer), "buffer");
997 }
998 static void
999 inf_text_gtk_buffer_init(InfTextGtkBuffer* buffer)
1000 {
1001   InfTextGtkBufferPrivate* priv;
1002   priv = INF_TEXT_GTK_BUFFER_PRIVATE(buffer);
1003   priv-&gt;buffer = NULL;
1004   priv-&gt;user_table = NULL;</b></font>
1005   priv-&gt;user_tags = g_hash_table_new_full(
1006     NULL,
1007     NULL,
1008     NULL,
1009     inf_text_gtk_buffer_user_tags_free
1010   );
1011   priv-&gt;show_user_colors = TRUE;
1012   priv-&gt;active_user = NULL;
1013   priv-&gt;wake_on_cursor_movement = FALSE;
1014   priv-&gt;saturation = 0.35;
1015   priv-&gt;value = 1.0;
1016   priv-&gt;alpha = 1.0;
1017 }
1018 static void
1019 inf_text_gtk_buffer_dispose(GObject* object)
1020 {
1021   InfTextGtkBuffer* buffer;
1022   InfTextGtkBufferPrivate* priv;
1023   buffer = INF_TEXT_GTK_BUFFER(object);
1024   priv = INF_TEXT_GTK_BUFFER_PRIVATE(buffer);
1025   g_hash_table_remove_all(priv-&gt;user_tags);
1026   inf_text_gtk_buffer_set_buffer(buffer, NULL);
1027   inf_text_gtk_buffer_set_active_user(buffer, NULL);
1028   g_object_unref(priv-&gt;user_table);
1029   G_OBJECT_CLASS(inf_text_gtk_buffer_parent_class)-&gt;dispose(object);
1030 }
1031 static void
1032 inf_text_gtk_buffer_finalize(GObject* object)
1033 {
1034 <a name="2"></a>  InfTextGtkBuffer* buffer;
1035   InfTextGtkBufferPrivate* priv;
1036 <font color="#980517"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>  buffer = INF_TEXT_GTK_BUFFER(object);
1037   priv = INF_TEXT_GTK_BUFFER_PRIVATE(buffer);
1038   g_hash_table_unref(priv-&gt;user_tags);
1039   G_OBJECT_CLASS(inf_text_gtk_buffer_parent_class)-&gt;finalize(object);
1040 }
1041 static void
1042 inf_text_gtk_buffer_set_property(GObject* object,
1043                                  guint prop_id,
1044                                  const GValue* value,
1045                                  GParamSpec* pspec)
1046 {
1047   InfTextGtkBuffer* buffer;
1048   InfTextGtkBufferPrivate* priv;
1049   buffer = INF_TEXT_GTK_BUFFER(object);
1050   priv = INF_TEXT_GTK_BUFFER_PRIVATE(buffer);
1051   switch(prop_id)
1052   {
1053   case PROP_BUFFER:
1054     g_assert(priv-&gt;buffer == NULL);     inf_text_gtk_buffer_set_buffer(
1055       buffer,
1056       GTK_TEXT_BUFFER(g_value_get_object(value))
1057     );
1058     break;
1059   case PROP_USER_TABLE:
1060     g_assert(priv-&gt;user_table == NULL);     priv-&gt;user_table = INF_USER_TABLE(g_value_dup_object(value));
1061     break;
1062   case PROP_ACTIVE_USER:
1063     inf_text_gtk_buffer_set_active_user(
1064       buffer,
1065       INF_TEXT_USER(g_value_get_object(value))
1066     );
1067     break;
1068   case PROP_WAKE_ON_CURSOR_MOVEMENT:
1069     priv-&gt;wake_on_cursor_movement = g_value_get_boolean(value);
1070     break;
1071   case PROP_SHOW_USER_COLORS:
1072     priv-&gt;show_user_colors = g_value_get_boolean(value);
1073     break;
1074   case PROP_MODIFIED:
1075     inf_text_gtk_buffer_set_modified(buffer, g_value_get_boolean(value));
1076     break;
1077   case PROP_SATURATION:
1078     inf_text_gtk_buffer_set_saturation_value(
1079       buffer,
1080       g_value_get_double(value),
1081       priv-&gt;value
1082     );
1083     break;
1084   case PROP_VALUE:
1085     inf_text_gtk_buffer_set_saturation_value(
1086       buffer,
1087       priv-&gt;saturation,
1088       g_value_get_double(value)
1089     );
1090 <a name="0"></a>    break;
1091   case PROP_ALPHA:
1092     inf_text_gtk_buffer_set_fade(buffer, g_value_get_double(value));
1093 <font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>    break;
1094   default:
1095     G_OBJECT_WARN_INVALID_PROPERTY_ID(object, prop_id, pspec);
1096     break;
1097   }
1098 }
1099 static void
1100 inf_text_gtk_buffer_get_property(GObject* object,
1101                                  guint prop_id,
1102                                  GValue* value,
1103                                  GParamSpec* pspec)
1104 {
1105   InfTextGtkBuffer* buffer;
1106   InfTextGtkBufferPrivate* priv;
1107   buffer = INF_TEXT_GTK_BUFFER(object);
1108   priv = INF_TEXT_GTK_BUFFER_PRIVATE(buffer);
1109   switch(prop_id)
1110   {
1111   case PROP_BUFFER:
1112     g_value_set_object(value, G_OBJECT(priv-&gt;buffer));
1113     break;
1114   case PROP_USER_TABLE:
1115     g_value_set_object(value, G_OBJECT(priv-&gt;user_table));
1116     break;</b></font>
1117   case PROP_ACTIVE_USER:
1118     g_value_set_object(value, G_OBJECT(priv-&gt;active_user));
1119     break;
1120   case PROP_WAKE_ON_CURSOR_MOVEMENT:
1121     g_value_set_boolean(value, priv-&gt;wake_on_cursor_movement);
1122     break;
1123   case PROP_SHOW_USER_COLORS:
1124     g_value_set_boolean(value, priv-&gt;show_user_colors);
1125     break;
1126   case PROP_MODIFIED:
1127     if(priv-&gt;buffer != NULL)
1128       g_value_set_boolean(value, gtk_text_buffer_get_modified(priv-&gt;buffer));
1129     else
1130       g_value_set_boolean(value, FALSE);
1131     break;
1132   case PROP_SATURATION:
1133     g_value_set_double(value, priv-&gt;saturation);
1134     break;
1135   case PROP_VALUE:
1136     g_value_set_double(value, priv-&gt;value);
1137     break;
1138   case PROP_ALPHA:
1139     g_value_set_double(value, priv-&gt;alpha);
1140     break;
1141   default:
1142     G_OBJECT_WARN_INVALID_PROPERTY_ID(object, prop_id, pspec);
1143     break;
1144   }
1145 }
1146 static gboolean
1147 inf_text_gtk_buffer_buffer_get_modified(InfBuffer* buffer)
1148 {
1149   InfTextGtkBuffer* gtk_buffer;
1150   InfTextGtkBufferPrivate* priv;
1151   gtk_buffer = INF_TEXT_GTK_BUFFER(buffer);
1152   priv = INF_TEXT_GTK_BUFFER_PRIVATE(gtk_buffer);
1153   if(priv-&gt;buffer != NULL)
1154     return gtk_text_buffer_get_modified(priv-&gt;buffer);
1155   else
1156     return FALSE;
1157 }
1158 static void
1159 inf_text_gtk_buffer_buffer_set_modified(InfBuffer* buffer,
1160                                         gboolean modified)
1161 {
1162   inf_text_gtk_buffer_set_modified(INF_TEXT_GTK_BUFFER(buffer), modified);
1163 }
1164 static const gchar*
1165 inf_text_gtk_buffer_buffer_get_encoding(InfTextBuffer* buffer)
1166 {
1167   return "UTF-8";
1168 }
1169 static guint
1170 inf_text_gtk_buffer_get_length(InfTextBuffer* buffer)
1171 {
1172   InfTextGtkBufferPrivate* priv;
1173   priv = INF_TEXT_GTK_BUFFER_PRIVATE(buffer);
1174   return gtk_text_buffer_get_char_count(priv-&gt;buffer);
1175 }
1176 static InfTextChunk*
1177 inf_text_gtk_buffer_buffer_get_slice(InfTextBuffer* buffer,
1178                                      guint pos,
1179                                      guint len)
1180 {
1181   InfTextGtkBufferPrivate* priv;
1182   GtkTextIter begin;
1183   GtkTextIter iter;
1184   InfTextChunk* result;
1185   guint remaining;
1186   guint size;
1187   InfTextUser* author;
1188   gchar* text;
1189   priv = INF_TEXT_GTK_BUFFER_PRIVATE(buffer);
1190   gtk_text_buffer_get_iter_at_offset(priv-&gt;buffer, &amp;iter, pos);
1191   result = inf_text_chunk_new("UTF-8");
1192   remaining = len;
1193   while(remaining &gt; 0)
1194   {
1195     g_assert(gtk_text_iter_is_end(&amp;iter) == FALSE);
1196     begin = iter;
1197     inf_text_gtk_buffer_iter_next_author_toggle(&amp;iter, NULL, &amp;author);
1198     size = gtk_text_iter_get_offset(&amp;iter) - gtk_text_iter_get_offset(&amp;begin);
1199     if(size &gt; remaining)
1200     {
1201       size = remaining;
1202       iter = begin;
1203       gtk_text_iter_forward_chars(&amp;iter, size);
1204     }
1205     text = gtk_text_buffer_get_slice(priv-&gt;buffer, &amp;begin, &amp;iter, TRUE);
1206     inf_text_chunk_insert_text(
1207       result,
1208       len - remaining,
1209       text,
1210       strlen(text),       size,
1211       (author == NULL) ? 0 : inf_user_get_id(INF_USER(author))
1212     );
1213     remaining -= size;
1214     g_free(text);
1215   }
1216   return result;
1217 }
1218 static void
1219 inf_text_gtk_buffer_buffer_insert_text(InfTextBuffer* buffer,
1220                                        guint pos,
1221                                        InfTextChunk* chunk,
1222                                        InfUser* user)
1223 {
1224   InfTextGtkBufferPrivate* priv;
1225   InfTextChunkIter chunk_iter;
1226   InfTextGtkBufferTagRemove tag_remove;
1227   GtkTextTag* tag;
1228   GtkTextMark* mark;
1229   GtkTextIter insert_iter;
1230   gboolean insert_at_cursor;
1231   gboolean insert_at_selection_bound;
1232   priv = INF_TEXT_GTK_BUFFER_PRIVATE(buffer);
1233   tag_remove.buffer = priv-&gt;buffer;
1234   g_assert(priv-&gt;record == NULL);
1235   inf_signal_handlers_block_by_func(
1236     G_OBJECT(priv-&gt;buffer),
1237     G_CALLBACK(inf_text_gtk_buffer_apply_tag_cb),
1238     buffer
1239   );
1240   inf_signal_handlers_block_by_func(
1241     G_OBJECT(priv-&gt;buffer),
1242     G_CALLBACK(inf_text_gtk_buffer_insert_text_cb_before),
1243     buffer
1244   );
1245   inf_signal_handlers_block_by_func(
1246     G_OBJECT(priv-&gt;buffer),
1247     G_CALLBACK(inf_text_gtk_buffer_insert_text_cb_after),
1248     buffer
1249   );
1250   if(inf_text_chunk_iter_init_begin(chunk, &amp;chunk_iter))
1251   {
1252     gtk_text_buffer_get_iter_at_offset(
1253       priv-&gt;buffer,
1254       &amp;tag_remove.end_iter,
1255       pos
1256     );
1257     do
1258     {
1259       tag_remove.ignore_tags = inf_text_gtk_buffer_get_user_tags(
1260         INF_TEXT_GTK_BUFFER(buffer),
1261         inf_text_chunk_iter_get_author(&amp;chunk_iter)
1262       );
1263       if(tag_remove.ignore_tags)
1264       {
1265         tag = inf_text_gtk_buffer_get_user_tag(
1266           INF_TEXT_GTK_BUFFER(buffer),
1267           tag_remove.ignore_tags,
1268           priv-&gt;show_user_colors
1269         );
1270       }
1271       else
1272       {
1273         tag = NULL;
1274       }
1275       gtk_text_buffer_insert_with_tags(
1276         tag_remove.buffer,
1277         &amp;tag_remove.end_iter,
1278         inf_text_chunk_iter_get_text(&amp;chunk_iter),
1279         inf_text_chunk_iter_get_bytes(&amp;chunk_iter),
1280         tag,
1281         NULL
1282       );
1283       tag_remove.begin_iter = tag_remove.end_iter;
1284       gtk_text_iter_backward_chars(
1285         &amp;tag_remove.begin_iter,
1286         inf_text_chunk_iter_get_length(&amp;chunk_iter)
1287       );
1288       gtk_text_tag_table_foreach(
1289         gtk_text_buffer_get_tag_table(tag_remove.buffer),
1290         inf_text_gtk_buffer_buffer_insert_text_tag_table_foreach_func,
1291         &amp;tag_remove
1292       );
1293     } while(inf_text_chunk_iter_next(&amp;chunk_iter));
1294     if(user != INF_USER(priv-&gt;active_user) || user == NULL)
1295     {
1296       mark = gtk_text_buffer_get_insert(priv-&gt;buffer);
1297       gtk_text_buffer_get_iter_at_mark(priv-&gt;buffer, &amp;insert_iter, mark);
1298       if(gtk_text_iter_equal(&amp;insert_iter, &amp;tag_remove.end_iter))
1299         insert_at_cursor = TRUE;
1300       else
1301         insert_at_cursor = FALSE;
1302       mark = gtk_text_buffer_get_selection_bound(priv-&gt;buffer);
1303       gtk_text_buffer_get_iter_at_mark(priv-&gt;buffer, &amp;insert_iter, mark);
1304       if(gtk_text_iter_equal(&amp;insert_iter, &amp;tag_remove.end_iter))
1305         insert_at_selection_bound = TRUE;
1306       else
1307         insert_at_selection_bound = FALSE;
1308       if(insert_at_cursor || insert_at_selection_bound)
1309       {
1310         inf_signal_handlers_block_by_func(
1311           G_OBJECT(priv-&gt;buffer),
1312           G_CALLBACK(inf_text_gtk_buffer_mark_set_cb),
1313           buffer
1314         );
1315         gtk_text_iter_backward_chars(
1316           &amp;tag_remove.end_iter,
1317           inf_text_chunk_get_length(chunk)
1318         );
1319         if(insert_at_cursor)
1320         {
1321           gtk_text_buffer_move_mark(
1322             priv-&gt;buffer,
1323             gtk_text_buffer_get_insert(priv-&gt;buffer),
1324             &amp;tag_remove.end_iter
1325           );
1326         }
1327         if(insert_at_selection_bound)
1328         {
1329           gtk_text_buffer_move_mark(
1330             priv-&gt;buffer,
1331             gtk_text_buffer_get_selection_bound(priv-&gt;buffer),
1332             &amp;tag_remove.end_iter
1333           );
1334         }
1335         inf_signal_handlers_unblock_by_func(
1336           G_OBJECT(priv-&gt;buffer),
1337           G_CALLBACK(inf_text_gtk_buffer_mark_set_cb),
1338           buffer
1339         );
1340       }
1341     }
1342   }
1343   inf_signal_handlers_unblock_by_func(
1344     G_OBJECT(priv-&gt;buffer),
1345     G_CALLBACK(inf_text_gtk_buffer_apply_tag_cb),
1346     buffer
1347   );
1348   inf_signal_handlers_unblock_by_func(
1349     G_OBJECT(priv-&gt;buffer),
1350     G_CALLBACK(inf_text_gtk_buffer_insert_text_cb_before),
1351     buffer
1352   );
1353   inf_signal_handlers_unblock_by_func(
1354     G_OBJECT(priv-&gt;buffer),
1355     G_CALLBACK(inf_text_gtk_buffer_insert_text_cb_after),
1356     buffer
1357   );
1358   inf_text_buffer_text_inserted(buffer, pos, chunk, user);
1359 }
1360 static void
1361 inf_text_gtk_buffer_buffer_erase_text(InfTextBuffer* buffer,
1362                                       guint pos,
1363                                       guint len,
1364                                       InfUser* user)
1365 {
1366   InfTextGtkBufferPrivate* priv;
1367   InfTextChunk* chunk;
1368   GtkTextIter begin;
1369   GtkTextIter end;
1370   priv = INF_TEXT_GTK_BUFFER_PRIVATE(buffer);
1371   g_assert(priv-&gt;record == NULL);
1372   chunk = inf_text_buffer_get_slice(buffer, pos, len);
1373   gtk_text_buffer_get_iter_at_offset(priv-&gt;buffer, &amp;begin, pos);
1374   gtk_text_buffer_get_iter_at_offset(priv-&gt;buffer, &amp;end, pos + len);
1375   inf_signal_handlers_block_by_func(
1376     G_OBJECT(priv-&gt;buffer),
1377     G_CALLBACK(inf_text_gtk_buffer_delete_range_cb_before),
1378     buffer
1379   );
1380   inf_signal_handlers_block_by_func(
1381     G_OBJECT(priv-&gt;buffer),
1382     G_CALLBACK(inf_text_gtk_buffer_delete_range_cb_after),
1383     buffer
1384   );
1385   gtk_text_buffer_delete(priv-&gt;buffer, &amp;begin, &amp;end);
1386   inf_signal_handlers_unblock_by_func(
1387     G_OBJECT(priv-&gt;buffer),
1388     G_CALLBACK(inf_text_gtk_buffer_delete_range_cb_before),
1389     buffer
1390   );
1391   inf_signal_handlers_unblock_by_func(
1392     G_OBJECT(priv-&gt;buffer),
1393     G_CALLBACK(inf_text_gtk_buffer_delete_range_cb_after),
1394     buffer
1395   );
1396   inf_text_buffer_text_erased(buffer, pos, chunk, user);
1397   inf_text_chunk_free(chunk);
1398 }
1399 static InfTextBufferIter*
1400 inf_text_gtk_buffer_buffer_create_begin_iter(InfTextBuffer* buffer)
1401 {
1402   InfTextGtkBufferPrivate* priv;
1403   InfTextBufferIter* iter;
1404   priv = INF_TEXT_GTK_BUFFER_PRIVATE(buffer);
1405   if(gtk_text_buffer_get_char_count(priv-&gt;buffer) == 0)
1406   {
1407     return NULL;
1408   }
1409   else
1410   {
1411     iter = g_slice_new(InfTextBufferIter);
1412     gtk_text_buffer_get_start_iter(priv-&gt;buffer, &amp;iter-&gt;begin);
1413     iter-&gt;end = iter-&gt;begin;
1414     inf_text_gtk_buffer_iter_next_author_toggle(
1415       &amp;iter-&gt;end,
1416       NULL,
1417       &amp;iter-&gt;user
1418     );
1419     return iter;
1420   }
1421 }
1422 static InfTextBufferIter*
1423 inf_text_gtk_buffer_buffer_create_end_iter(InfTextBuffer* buffer)
1424 {
1425   InfTextGtkBufferPrivate* priv;
1426   InfTextBufferIter* iter;
1427   priv = INF_TEXT_GTK_BUFFER_PRIVATE(buffer);
1428   if(gtk_text_buffer_get_char_count(priv-&gt;buffer) == 0)
1429   {
1430     return NULL;
1431   }
1432   else
1433   {
1434     iter = g_slice_new(InfTextBufferIter);
1435     gtk_text_buffer_get_end_iter(priv-&gt;buffer, &amp;iter-&gt;end);
1436     iter-&gt;begin = iter-&gt;end;
1437     inf_text_gtk_buffer_iter_prev_author_toggle(
1438       &amp;iter-&gt;begin,
1439       &amp;iter-&gt;user,
1440       NULL
1441     );
1442     return iter;
1443   }
1444 }
1445 static void
1446 inf_text_gtk_buffer_buffer_destroy_iter(InfTextBuffer* buffer,
1447                                         InfTextBufferIter* iter)
1448 {
1449   g_slice_free(InfTextBufferIter, iter);
1450 }
1451 static gboolean
1452 inf_text_gtk_buffer_buffer_iter_next(InfTextBuffer* buffer,
1453                                      InfTextBufferIter* iter)
1454 {
1455   if(gtk_text_iter_is_end(&amp;iter-&gt;end))
1456     return FALSE;
1457   iter-&gt;begin = iter-&gt;end;
1458   inf_text_gtk_buffer_iter_next_author_toggle(&amp;iter-&gt;end, NULL, &amp;iter-&gt;user);
1459   return TRUE;
1460 }
1461 static gboolean
1462 inf_text_gtk_buffer_buffer_iter_prev(InfTextBuffer* buffer,
1463                                      InfTextBufferIter* iter)
1464 {
1465   if(gtk_text_iter_is_start(&amp;iter-&gt;begin))
1466     return FALSE;
1467   iter-&gt;end = iter-&gt;begin;
1468   inf_text_gtk_buffer_iter_prev_author_toggle(
1469     &amp;iter-&gt;begin,
1470     &amp;iter-&gt;user,
1471     NULL
1472   );
1473   return TRUE;
1474 }
1475 static gpointer
1476 inf_text_gtk_buffer_buffer_iter_get_text(InfTextBuffer* buffer,
1477                                          InfTextBufferIter* iter)
1478 {
1479   InfTextGtkBufferPrivate* priv;
1480   priv = INF_TEXT_GTK_BUFFER_PRIVATE(buffer);
1481   return gtk_text_buffer_get_slice(
1482     priv-&gt;buffer,
1483     &amp;iter-&gt;begin,
1484     &amp;iter-&gt;end,
1485     TRUE
1486   );
1487 }
1488 static guint
1489 inf_text_gtk_buffer_buffer_iter_get_offset(InfTextBuffer* buffer,
1490                                            InfTextBufferIter* iter)
1491 {
1492   return gtk_text_iter_get_offset(&amp;iter-&gt;begin);
1493 }
1494 static guint
1495 inf_text_gtk_buffer_buffer_iter_get_length(InfTextBuffer* buffer,
1496                                            InfTextBufferIter* iter)
1497 {
1498   return gtk_text_iter_get_offset(&amp;iter-&gt;end) -
1499     gtk_text_iter_get_offset(&amp;iter-&gt;begin);
1500 }
1501 static gsize
1502 inf_text_gtk_buffer_buffer_iter_get_bytes(InfTextBuffer* buffer,
1503                                           InfTextBufferIter* iter)
1504 {
1505   GtkTextIter walk;
1506   gsize bytes;
1507   guint remaining;
1508   guint end;
1509   guint line_chars;
1510   guint line_bytes;
1511   gboolean result;
1512   walk = iter-&gt;begin;
1513   bytes = 0;
1514   remaining = gtk_text_iter_get_offset(&amp;iter-&gt;end) -
1515     gtk_text_iter_get_offset(&amp;walk);
1516   end = gtk_text_iter_get_offset(&amp;iter-&gt;end);
1517   while(remaining &gt; 0)
1518   {
1519     line_chars = gtk_text_iter_get_chars_in_line(&amp;walk) -
1520       gtk_text_iter_get_line_offset(&amp;walk);
1521     if(line_chars + gtk_text_iter_get_offset(&amp;walk) &lt;= end)
1522     {
1523       line_bytes = gtk_text_iter_get_bytes_in_line(&amp;walk) -
1524         gtk_text_iter_get_line_index(&amp;walk);
1525       remaining -= line_chars;
1526       bytes += line_bytes;
1527       result = gtk_text_iter_forward_line(&amp;walk);
1528       g_assert(remaining == 0 || result == TRUE);
1529     }
1530     else
1531     {
1532       line_bytes = gtk_text_iter_get_line_index(&amp;iter-&gt;end) -
1533         gtk_text_iter_get_line_index(&amp;walk);
1534       remaining = 0;
1535       bytes += line_bytes;
1536     }
1537   }
1538   return bytes;
1539 }
1540 static guint
1541 inf_text_gtk_buffer_buffer_iter_get_author(InfTextBuffer* buffer,
1542                                            InfTextBufferIter* iter)
1543 {
1544   return (iter-&gt;user == NULL) ? 0 : inf_user_get_id(INF_USER(iter-&gt;user));
1545 }
1546 static void
1547 inf_text_gtk_buffer_class_init(InfTextGtkBufferClass* text_gtk_buffer_class)
1548 {
1549   GObjectClass* object_class;
1550   object_class = G_OBJECT_CLASS(text_gtk_buffer_class);
1551   object_class-&gt;dispose = inf_text_gtk_buffer_dispose;
1552   object_class-&gt;finalize = inf_text_gtk_buffer_finalize;
1553   object_class-&gt;set_property = inf_text_gtk_buffer_set_property;
1554   object_class-&gt;get_property = inf_text_gtk_buffer_get_property;
1555   inf_text_gtk_buffer_tag_user_quark = g_quark_from_static_string(
1556     "inf-text-gtk-buffer-tag-user"
1557   );
1558   g_object_class_install_property(
1559     object_class,
1560     PROP_BUFFER,
1561     g_param_spec_object(
1562       "buffer",
1563       "Buffer",
1564       "The underlaying GtkTextBuffer",
1565       GTK_TYPE_TEXT_BUFFER,
1566       G_PARAM_READWRITE | G_PARAM_CONSTRUCT_ONLY
1567     )
1568   );
1569   g_object_class_install_property(
1570     object_class,
1571     PROP_USER_TABLE,
1572     g_param_spec_object(
1573       "user-table",
1574       "User table",
1575       "A user table of the participating users",
1576       INF_TYPE_USER_TABLE,
1577       G_PARAM_READWRITE | G_PARAM_CONSTRUCT_ONLY
1578     )
1579   );
1580   g_object_class_install_property(
1581     object_class,
1582     PROP_ACTIVE_USER,
1583     g_param_spec_object(
1584       "active-user",
1585       "Active user",
1586       "The user currently inserting text locally",
1587       INF_TEXT_TYPE_USER,
1588       G_PARAM_READWRITE
1589     )
1590   );
1591   g_object_class_install_property(
1592     object_class,
1593     PROP_WAKE_ON_CURSOR_MOVEMENT,
1594     g_param_spec_boolean(
1595       "wake-on-cursor-movement",
1596       "Wake on cursor movement",
1597       "Whether to make inactive users active when the insertion mark in the "
1598       "TextBuffer moves",
1599       FALSE,
1600       G_PARAM_READWRITE
1601     )
1602   );
1603   g_object_class_install_property(
1604     object_class,
1605     PROP_SHOW_USER_COLORS,
1606     g_param_spec_boolean(
1607       "show-user-colors",
1608       "Show user colors",
1609       "Whether to show user colors initially for newly written text",
1610       TRUE,
1611       G_PARAM_READWRITE
1612     )
1613   );
1614   g_object_class_install_property(
1615     object_class,
1616     PROP_SATURATION,
1617     g_param_spec_double(
1618       "saturation",
1619       "Saturation",
1620       "Saturation of user colors in a HSV color model",
1621       0.0,
1622       1.0,
1623       0.35,
1624       G_PARAM_READWRITE
1625     )
1626   );
1627   g_object_class_install_property(
1628     object_class,
1629     PROP_VALUE,
1630     g_param_spec_double(
1631       "value",
1632       "Value",
1633       "Value of user colors in a HSV color model",
1634       0.0,
1635       1.0,
1636       1.0,
1637       G_PARAM_READWRITE
1638     )
1639   );
1640   g_object_class_install_property(
1641     object_class,
1642     PROP_VALUE,
1643     g_param_spec_double(
1644       "alpha",
1645       "Alpha",
1646       "The translucency of the user color",
1647       0.0,
1648       1.0,
1649       1.0,
1650       G_PARAM_READWRITE
1651     )
1652   );
1653   g_object_class_override_property(object_class, PROP_MODIFIED, "modified");
1654 }
1655 static void
1656 inf_text_gtk_buffer_buffer_iface_init(InfBufferInterface* iface)
1657 {
1658   iface-&gt;get_modified = inf_text_gtk_buffer_buffer_get_modified;
1659   iface-&gt;set_modified = inf_text_gtk_buffer_buffer_set_modified;
1660 }
1661 static void
1662 inf_text_gtk_buffer_text_buffer_iface_init(InfTextBufferInterface* iface)
1663 {
1664   iface-&gt;get_encoding = inf_text_gtk_buffer_buffer_get_encoding;
1665   iface-&gt;get_length = inf_text_gtk_buffer_get_length;
1666   iface-&gt;get_slice = inf_text_gtk_buffer_buffer_get_slice;
1667   iface-&gt;insert_text = inf_text_gtk_buffer_buffer_insert_text;
1668   iface-&gt;erase_text = inf_text_gtk_buffer_buffer_erase_text;
1669   iface-&gt;create_begin_iter = inf_text_gtk_buffer_buffer_create_begin_iter;
1670   iface-&gt;create_end_iter = inf_text_gtk_buffer_buffer_create_end_iter;
1671   iface-&gt;destroy_iter = inf_text_gtk_buffer_buffer_destroy_iter;
1672   iface-&gt;iter_next = inf_text_gtk_buffer_buffer_iter_next;
1673   iface-&gt;iter_prev = inf_text_gtk_buffer_buffer_iter_prev;
1674   iface-&gt;iter_get_text = inf_text_gtk_buffer_buffer_iter_get_text;
1675   iface-&gt;iter_get_offset = inf_text_gtk_buffer_buffer_iter_get_offset;
1676   iface-&gt;iter_get_length = inf_text_gtk_buffer_buffer_iter_get_length;
1677   iface-&gt;iter_get_bytes = inf_text_gtk_buffer_buffer_iter_get_bytes;
1678   iface-&gt;iter_get_author = inf_text_gtk_buffer_buffer_iter_get_author;
1679   iface-&gt;text_inserted = NULL;
1680   iface-&gt;text_erased = NULL;
1681 }
1682 InfTextGtkBuffer*
1683 inf_text_gtk_buffer_new(GtkTextBuffer* buffer,
1684                         InfUserTable* user_table)
1685 {
1686   GObject* object;
1687   g_return_val_if_fail(GTK_IS_TEXT_BUFFER(buffer), NULL);
1688   g_return_val_if_fail(INF_IS_USER_TABLE(user_table), NULL);
1689   object = g_object_new(
1690     INF_TEXT_GTK_TYPE_BUFFER,
1691     "buffer", buffer,
1692     "user-table", user_table,
1693     NULL
1694   );
1695   return INF_TEXT_GTK_BUFFER(object);
1696 }
1697 GtkTextBuffer*
1698 inf_text_gtk_buffer_get_text_buffer(InfTextGtkBuffer* buffer)
1699 {
1700   g_return_val_if_fail(INF_TEXT_GTK_IS_BUFFER(buffer), NULL);
1701   return INF_TEXT_GTK_BUFFER_PRIVATE(buffer)-&gt;buffer;
1702 }
1703 void
1704 inf_text_gtk_buffer_set_active_user(InfTextGtkBuffer* buffer,
1705                                     InfTextUser* user)
1706 {
1707   InfTextGtkBufferPrivate* priv;
1708   g_return_if_fail(INF_TEXT_GTK_IS_BUFFER(buffer));
1709   g_return_if_fail(user == NULL || INF_TEXT_IS_USER(user));
1710   g_return_if_fail(
1711     user == NULL ||
1712     (inf_user_get_flags(INF_USER(user)) &amp; INF_USER_LOCAL) != 0
1713   );
1714   g_return_if_fail(
1715     user == NULL ||
1716     inf_user_get_status(INF_USER(user)) != INF_USER_UNAVAILABLE
1717   );
1718   priv = INF_TEXT_GTK_BUFFER_PRIVATE(buffer);
1719   if(priv-&gt;active_user != NULL)
1720   {
1721     inf_signal_handlers_disconnect_by_func(
1722       G_OBJECT(priv-&gt;active_user),
1723       G_CALLBACK(inf_text_gtk_buffer_active_user_notify_status_cb),
1724       buffer
1725     );
1726     inf_signal_handlers_disconnect_by_func(
1727       G_OBJECT(priv-&gt;active_user),
1728       G_CALLBACK(inf_text_gtk_buffer_active_user_selection_changed_cb),
1729       buffer
1730     );
1731     g_object_unref(G_OBJECT(priv-&gt;active_user));
1732   }
1733   priv-&gt;active_user = user;
1734   if(user != NULL)
1735   {
1736     g_object_ref(G_OBJECT(user));
1737     g_signal_connect(
1738       G_OBJECT(user),
1739       "notify::status",
1740       G_CALLBACK(inf_text_gtk_buffer_active_user_notify_status_cb),
1741       buffer
1742     );
1743     g_signal_connect(
1744       G_OBJECT(user),
1745       "selection-changed",
1746       G_CALLBACK(inf_text_gtk_buffer_active_user_selection_changed_cb),
1747       buffer
1748     );
1749   }
1750   g_object_notify(G_OBJECT(buffer), "active-user");
1751 }
1752 InfTextUser*
1753 inf_text_gtk_buffer_get_active_user(InfTextGtkBuffer* buffer)
1754 {
1755   g_return_val_if_fail(INF_TEXT_GTK_IS_BUFFER(buffer), NULL);
1756   return INF_TEXT_GTK_BUFFER_PRIVATE(buffer)-&gt;active_user;
1757 }
1758 InfTextUser*
1759 inf_text_gtk_buffer_get_author(InfTextGtkBuffer* buffer,
1760                                GtkTextIter* location)
1761 {
1762   InfTextGtkBufferPrivate* priv;
1763   g_return_val_if_fail(INF_TEXT_GTK_IS_BUFFER(buffer), NULL);
1764   g_return_val_if_fail(
1765     location != NULL &amp;&amp; !gtk_text_iter_is_end(location),
1766     NULL
1767   );
1768   priv = INF_TEXT_GTK_BUFFER_PRIVATE(buffer);
1769   return inf_text_gtk_buffer_iter_get_author(location);
1770 }
1771 InfTextUser*
1772 inf_text_gtk_buffer_get_user_for_tag(InfTextGtkBuffer* buffer,
1773                                      GtkTextTag* tag)
1774 {
1775   g_return_val_if_fail(INF_TEXT_GTK_IS_BUFFER(buffer), NULL);
1776   g_return_val_if_fail(GTK_IS_TEXT_TAG(tag), NULL);
1777   return inf_text_gtk_buffer_author_from_tag(tag);
1778 }
1779 gboolean
1780 inf_text_gtk_buffer_is_author_toggle(InfTextGtkBuffer* buffer,
1781                                      const GtkTextIter* iter,
1782                                      InfTextUser** user_on,
1783                                      InfTextUser** user_off)
1784 {
1785   g_return_val_if_fail(INF_TEXT_GTK_IS_BUFFER(buffer), FALSE);
1786   g_return_val_if_fail(iter != NULL, FALSE);
1787   return inf_text_gtk_buffer_iter_is_author_toggle(
1788     iter,
1789     user_on,
1790     user_off
1791   );
1792 }
1793 gboolean
1794 inf_text_gtk_buffer_forward_to_author_toggle(InfTextGtkBuffer* buffer,
1795                                              GtkTextIter* iter,
1796                                              InfTextUser** user_on,
1797                                              InfTextUser** user_off)
1798 {
1799   g_return_val_if_fail(INF_TEXT_GTK_IS_BUFFER(buffer), FALSE);
1800   g_return_val_if_fail(iter != NULL, FALSE);
1801   if(gtk_text_iter_is_end(iter))
1802     return FALSE;
1803   inf_text_gtk_buffer_iter_next_author_toggle(iter, user_on, user_off);
1804   return TRUE;
1805 }
1806 gboolean
1807 inf_text_gtk_buffer_backward_to_author_toggle(InfTextGtkBuffer* buffer,
1808                                               GtkTextIter* iter,
1809                                               InfTextUser** user_on,
1810                                               InfTextUser** user_off)
1811 {
1812   g_return_val_if_fail(INF_TEXT_GTK_IS_BUFFER(buffer), FALSE);
1813   g_return_val_if_fail(iter != NULL, FALSE);
1814   if(gtk_text_iter_is_start(iter))
1815     return FALSE;
1816   inf_text_gtk_buffer_iter_prev_author_toggle(iter, user_on, user_off);
1817   return TRUE;
1818 }
1819 void
1820 inf_text_gtk_buffer_set_wake_on_cursor_movement(InfTextGtkBuffer* buffer,
1821                                                 gboolean wake)
1822 {
1823   g_return_if_fail(INF_TEXT_GTK_IS_BUFFER(buffer));
1824   INF_TEXT_GTK_BUFFER_PRIVATE(buffer)-&gt;wake_on_cursor_movement = wake;
1825   g_object_notify(G_OBJECT(buffer), "wake-on-cursor-movement");
1826 }
1827 gboolean
1828 inf_text_gtk_buffer_get_wake_on_cursor_movement(InfTextGtkBuffer* buffer)
1829 {
1830   g_return_val_if_fail(INF_TEXT_GTK_IS_BUFFER(buffer), FALSE);
1831   return INF_TEXT_GTK_BUFFER_PRIVATE(buffer)-&gt;wake_on_cursor_movement;
1832 }
1833 void
1834 inf_text_gtk_buffer_ensure_author_tags_priority(InfTextGtkBuffer* buffer)
1835 {
1836   InfTextGtkBufferPrivate* priv;
1837   GtkTextTagTable* tag_table;
1838   g_return_if_fail(INF_TEXT_GTK_IS_BUFFER(buffer));
1839   priv = INF_TEXT_GTK_BUFFER_PRIVATE(buffer);
1840   tag_table = gtk_text_buffer_get_tag_table(priv-&gt;buffer);
1841   gtk_text_tag_table_foreach(
1842     tag_table,
1843     inf_text_gtk_buffer_ensure_author_tags_priority_foreach_func,
1844     buffer
1845   );
1846 }
1847 void
1848 inf_text_gtk_buffer_set_saturation_value(InfTextGtkBuffer* buffer,
1849                                          gdouble saturation,
1850                                          gdouble value)
1851 {
1852   InfTextGtkBufferPrivate* priv;
1853   GtkTextTagTable* tag_table;
1854   g_return_if_fail(INF_TEXT_GTK_IS_BUFFER(buffer));
1855   g_return_if_fail(saturation &gt;= 0.0 &amp;&amp; saturation &lt;= 1.0);
1856   g_return_if_fail(value &gt;= 0.0 &amp;&amp; value &lt;= 1.0);
1857   priv = INF_TEXT_GTK_BUFFER_PRIVATE(buffer);
1858   if(saturation == priv-&gt;saturation &amp;&amp; value == priv-&gt;value)
1859     return;
1860   g_object_freeze_notify(G_OBJECT(buffer));
1861   if(saturation != priv-&gt;saturation)
1862   {
1863     priv-&gt;saturation = saturation;
1864     g_object_notify(G_OBJECT(buffer), "saturation");
1865   }
1866   if(value != priv-&gt;value)
1867   {
1868     priv-&gt;value = value;
1869     g_object_notify(G_OBJECT(buffer), "value");
1870   }
1871   tag_table = gtk_text_buffer_get_tag_table(priv-&gt;buffer);
1872   gtk_text_tag_table_foreach(
1873     tag_table,
1874     inf_text_gtk_buffer_update_user_color_tag_table_foreach_func,
1875     buffer
1876   );
1877   g_object_thaw_notify(G_OBJECT(buffer));
1878 }
1879 void
1880 inf_text_gtk_buffer_set_fade(InfTextGtkBuffer* buffer,
1881                              gdouble alpha)
1882 {
1883   InfTextGtkBufferPrivate* priv;
1884   GtkTextTagTable* tag_table;
1885   g_return_if_fail(INF_TEXT_GTK_IS_BUFFER(buffer));
1886   g_return_if_fail(alpha &gt;= 0.0 &amp;&amp; alpha &lt;= 1.0);
1887   priv = INF_TEXT_GTK_BUFFER_PRIVATE(buffer);
1888   g_object_freeze_notify(G_OBJECT(buffer));
1889   if(alpha != priv-&gt;alpha)
1890   {
1891     priv-&gt;alpha = alpha;
1892     g_object_notify(G_OBJECT(buffer), "alpha");
1893   }
1894   tag_table = gtk_text_buffer_get_tag_table(priv-&gt;buffer);
1895   gtk_text_tag_table_foreach(
1896     tag_table,
1897     inf_text_gtk_buffer_update_user_color_tag_table_foreach_func,
1898     buffer
1899   );
1900   g_object_thaw_notify(G_OBJECT(buffer));
1901 }
1902 gdouble
1903 inf_text_gtk_buffer_get_saturation(InfTextGtkBuffer* buffer)
1904 {
1905   g_return_val_if_fail(INF_TEXT_GTK_IS_BUFFER(buffer), 0.0);
1906   return INF_TEXT_GTK_BUFFER_PRIVATE(buffer)-&gt;saturation;
1907 }
1908 gdouble
1909 inf_text_gtk_buffer_get_value(InfTextGtkBuffer* buffer)
1910 {
1911   g_return_val_if_fail(INF_TEXT_GTK_IS_BUFFER(buffer), 0.0);
1912   return INF_TEXT_GTK_BUFFER_PRIVATE(buffer)-&gt;value;
1913 }
1914 void
1915 inf_text_gtk_buffer_set_show_user_colors(InfTextGtkBuffer* buffer,
1916                                          gboolean show)
1917 {
1918   g_return_if_fail(INF_TEXT_GTK_IS_BUFFER(buffer));
1919   INF_TEXT_GTK_BUFFER_PRIVATE(buffer)-&gt;show_user_colors = show;
1920   g_object_notify(G_OBJECT(buffer), "show-user-colors");
1921 }
1922 gboolean
1923 inf_text_gtk_buffer_get_show_user_colors(InfTextGtkBuffer* buffer)
1924 {
1925   g_return_val_if_fail(INF_TEXT_GTK_IS_BUFFER(buffer), FALSE);
1926   return INF_TEXT_GTK_BUFFER_PRIVATE(buffer)-&gt;show_user_colors;
1927 }
1928 void
1929 inf_text_gtk_buffer_show_user_colors(InfTextGtkBuffer* buffer,
1930                                      gboolean show,
1931                                      GtkTextIter* start,
1932                                      GtkTextIter* end)
1933 {
1934   InfTextGtkBufferPrivate* priv;
1935   GtkTextIter iter;
1936   GtkTextIter prev;
1937   InfTextUser* user;
1938   InfTextGtkBufferUserTags* tags;
1939   GtkTextTag* hide_tag;
1940   GtkTextTag* show_tag;
1941   g_return_if_fail(INF_TEXT_GTK_IS_BUFFER(buffer));
1942   g_return_if_fail(start != NULL);
1943   g_return_if_fail(end != NULL);
1944   priv = INF_TEXT_GTK_BUFFER_PRIVATE(buffer);
1945   iter = *start;
1946   prev = iter;
1947   while(!gtk_text_iter_equal(&amp;iter, end))
1948   {
1949     inf_text_gtk_buffer_iter_next_author_toggle(&amp;iter, NULL, &amp;user);
1950     if(gtk_text_iter_compare(&amp;iter, end) &gt; 0)
1951       iter = *end;
1952     if(user != NULL)
1953     {
1954       tags = g_hash_table_lookup(
1955         priv-&gt;user_tags,
1956         GUINT_TO_POINTER(inf_user_get_id(INF_USER(user)))
1957       );
1958       g_assert(tags != NULL);
1959       if(show)
1960       {
1961         hide_tag = inf_text_gtk_buffer_get_user_tag(buffer, tags, FALSE);
1962         show_tag = inf_text_gtk_buffer_get_user_tag(buffer, tags, TRUE);
1963       }
1964       else
1965       {
1966         hide_tag = inf_text_gtk_buffer_get_user_tag(buffer, tags, TRUE);
1967         show_tag = inf_text_gtk_buffer_get_user_tag(buffer, tags, FALSE);
1968       }
1969       inf_signal_handlers_block_by_func(
1970         priv-&gt;buffer,
1971         G_CALLBACK(inf_text_gtk_buffer_apply_tag_cb),
1972         buffer
1973       );
1974       gtk_text_buffer_remove_tag(priv-&gt;buffer, hide_tag, &amp;prev, &amp;iter);
1975       gtk_text_buffer_apply_tag(priv-&gt;buffer, show_tag, &amp;prev, &amp;iter);
1976       inf_signal_handlers_unblock_by_func(
1977         priv-&gt;buffer,
1978         G_CALLBACK(inf_text_gtk_buffer_apply_tag_cb),
1979         buffer
1980       );
1981     }
1982     prev = iter;
1983   }
1984 }
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>inf-gtk-permissions-dialog.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 #include &lt;libinfgtk/inf-gtk-permissions-dialog.h&gt;
2 #include &lt;libinfgtk/inf-gtk-acl-sheet-view.h&gt;
3 #include &lt;libinfinity/common/inf-request-result.h&gt;
4 #include &lt;libinfinity/common/inf-error.h&gt;
5 #include &lt;libinfinity/inf-i18n.h&gt;
6 #include &lt;libinfinity/inf-signals.h&gt;
7 #include &lt;gdk/gdkkeysyms.h&gt;
8 #include &lt;string.h&gt;
9 <a name="1"></a>enum {
10   INF_GTK_PERMISSIONS_DIALOG_COLUMN_ID = 0,
11   INF_GTK_PERMISSIONS_DIALOG_COLUMN_NAME = 1
12 <font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>};
13 typedef struct _InfGtkPermissionsDialogPendingSheet
14   InfGtkPermissionsDialogPendingSheet;
15 struct _InfGtkPermissionsDialogPendingSheet {
16   InfGtkPermissionsDialog* dialog;
17   GtkTreeRowReference* row;
18   InfAclSheet sheet;
19   InfAclAccountId last_combo_changed_id;
20   InfRequest* lookup_request;
21 };
22 typedef struct _InfGtkPermissionsDialogPrivate InfGtkPermissionsDialogPrivate;
23 struct _InfGtkPermissionsDialogPrivate {
24   InfBrowser* browser;
25   InfBrowserIter browser_iter;
26   GtkListStore* account_store;
27   InfRequest* query_acl_account_list_request;
28   gboolean account_list_queried;
29   InfAclAccount* accounts;
30   guint n_accounts;
31   InfRequest* query_acl_request;
32   GSList* set_acl_requests;
33   GSList* remove_acl_account_requests;
34   GSList* lookup_acl_account_requests;
35   GSList* pending_sheets;
36   GtkMenu* popup_menu;
37   InfAclAccountId popup_account;
38   GtkWidget* status_text;
39   GtkWidget* tree_view;
40   GtkWidget* sheet_view;
41   GtkWidget* add_button;
42   GtkWidget* remove_button;
43   GtkCellRenderer* renderer;
44 };
45 enum {
46   PROP_0,
47   PROP_BROWSER,
48   PROP_BROWSER_ITER
49 };
50 #define INF_GTK_PERMISSIONS_DIALOG_PRIVATE(obj) (G_TYPE_INSTANCE_GET_PRIVATE((obj), INF_GTK_TYPE_PERMISSIONS_DIALOG, InfGtkPermissionsDialogPrivate))
51 G_DEFINE_TYPE_WITH_CODE(InfGtkPermissionsDialog, inf_gtk_permissions_dialog, GTK_TYPE_DIALOG,
52   G_ADD_PRIVATE(InfGtkPermissionsDialog))
53 static void</b></font>
54 inf_gtk_permissions_dialog_update(InfGtkPermissionsDialog* dialog,
55                                   const GError* error);
56 static void
57 inf_gtk_permissions_dialog_update_sheet(InfGtkPermissionsDialog* dialog);
58 static gboolean
59 inf_gtk_permissions_dialog_find_account(InfGtkPermissionsDialog* dialog,
60                                         InfAclAccountId account,
61                                         GtkTreeIter* out_iter)
62 {
63   InfGtkPermissionsDialogPrivate* priv;
64   gpointer row_account_id;
65   GtkTreeModel* model;
66   GtkTreeIter iter;
67   priv = INF_GTK_PERMISSIONS_DIALOG_PRIVATE(dialog);
68   model = GTK_TREE_MODEL(priv-&gt;account_store);
69   if(gtk_tree_model_get_iter_first(model, &amp;iter))
70   {
71     do
72     {
73       gtk_tree_model_get(
74         model,
75         &amp;iter,
76         INF_GTK_PERMISSIONS_DIALOG_COLUMN_ID,
77         &amp;row_account_id,
78         -1
79       );
80       if(row_account_id == INF_ACL_ACCOUNT_ID_TO_POINTER(account))
81       {
82         if(out_iter != NULL)
83           *out_iter = iter;
84         return TRUE;
85       }
86     } while(gtk_tree_model_iter_next(model, &amp;iter));
87   }
88   return FALSE;
89 }
90 static InfGtkPermissionsDialogPendingSheet*
91 inf_gtk_permissions_dialog_find_pending_sheet(InfGtkPermissionsDialog* dialog,
92                                               GtkTreeIter* iter)
93 {
94   InfGtkPermissionsDialogPrivate* priv;
95   GtkTreeModel* model;
96   GtkTreePath* path;
97   GSList* item;
98   InfGtkPermissionsDialogPendingSheet* pending;
99   GtkTreePath* pending_path;
100   priv = INF_GTK_PERMISSIONS_DIALOG_PRIVATE(dialog);
101   model = GTK_TREE_MODEL(priv-&gt;account_store);
102   path = gtk_tree_model_get_path(model, iter);
103   for(item = priv-&gt;pending_sheets; item != NULL; item = item-&gt;next)
104   {
105     pending = (InfGtkPermissionsDialogPendingSheet*)item-&gt;data;
106     pending_path = gtk_tree_row_reference_get_path(pending-&gt;row);
107     g_assert(pending_path != NULL);
108     if(gtk_tree_path_compare(path, pending_path) == 0)
109     {
110       gtk_tree_path_free(path);
111       gtk_tree_path_free(pending_path);
112       return pending;
113     }
114     gtk_tree_path_free(pending_path);
115   }
116   gtk_tree_path_free(path);
117   return NULL;
118 }
119 static void
120 inf_gtk_permissions_dialog_set_acl_finished_cb(InfRequest* request,
121                                                const InfRequestResult* result,
122                                                const GError* error,
123                                                gpointer user_data)
124 {
125   InfGtkPermissionsDialog* dialog;
126   InfGtkPermissionsDialogPrivate* priv;
127   dialog = INF_GTK_PERMISSIONS_DIALOG(user_data);
128   priv = INF_GTK_PERMISSIONS_DIALOG_PRIVATE(dialog);
129   if(error != NULL)
130   {
131     inf_gtk_permissions_dialog_update(dialog, error);
132     inf_gtk_permissions_dialog_update_sheet(dialog);
133   }
134   if(g_slist_find(priv-&gt;set_acl_requests, request) != NULL)
135   {
136     priv-&gt;set_acl_requests = g_slist_remove(priv-&gt;set_acl_requests, request);
137     g_object_unref(request);
138   }
139 }
140 static void
141 inf_gtk_permissions_dialog_selection_changed_cb(GtkTreeSelection* selection,
142                                                 gpointer user_data)
143 {
144   InfGtkPermissionsDialog* dialog;
145   dialog = INF_GTK_PERMISSIONS_DIALOG(user_data);
146   inf_gtk_permissions_dialog_update_sheet(dialog);
147   inf_gtk_permissions_dialog_update(dialog, NULL);
148 }
149 static void
150 inf_gtk_permissions_dialog_sheet_changed_cb(InfGtkAclSheetView* sheet_view,
151                                             gpointer user_data)
152 {
153   InfGtkPermissionsDialog* dialog;
154   InfGtkPermissionsDialogPrivate* priv;
155   const InfAclSheet* sheet;
156   InfAclSheetSet sheet_set;
157   InfRequest* request;
158   GtkTreeSelection* selection;
159   gboolean has_selection;
160   GtkTreeIter iter;
161   InfGtkPermissionsDialogPendingSheet* pending;
162   dialog = INF_GTK_PERMISSIONS_DIALOG(user_data);
163   priv = INF_GTK_PERMISSIONS_DIALOG_PRIVATE(dialog);
164   sheet = inf_gtk_acl_sheet_view_get_sheet(
165     INF_GTK_ACL_SHEET_VIEW(priv-&gt;sheet_view)
166   );
167   if(sheet != NULL)
168   {
169     if(sheet-&gt;account != 0)
170     {
171       sheet_set.own_sheets = NULL;
172       sheet_set.sheets = sheet;
173       sheet_set.n_sheets = 1;
174       request = inf_browser_set_acl(
175         priv-&gt;browser,
176         &amp;priv-&gt;browser_iter,
177         &amp;sheet_set,
178         inf_gtk_permissions_dialog_set_acl_finished_cb,
179         dialog
180       );
181       if(request != NULL)
182       {
183         priv-&gt;set_acl_requests =
184           g_slist_prepend(priv-&gt;set_acl_requests, request);
185         g_object_ref(request);
186       }
187     }
188     else
189     {
190       selection = gtk_tree_view_get_selection(GTK_TREE_VIEW(priv-&gt;tree_view));
191       has_selection = gtk_tree_selection_get_selected(selection, NULL, &amp;iter);
192       g_assert(has_selection);
193       pending = inf_gtk_permissions_dialog_find_pending_sheet(dialog, &amp;iter);
194       g_assert(pending != NULL);
195       pending-&gt;sheet = *sheet;
196     }
197   }
198 }
199 static int
200 inf_gtk_permissions_dialog_account_sort_func(GtkTreeModel* model,
201                                              GtkTreeIter* a,
202                                              GtkTreeIter* b,
203                                              gpointer user_data)
204 {
205   InfGtkPermissionsDialog* dialog;
206   InfGtkPermissionsDialogPrivate* priv;
207   InfAclAccountId default_id;
208   gpointer account_a_id_ptr;
209   gpointer account_b_id_ptr;
210   InfAclAccountId account_a_id;
211   InfAclAccountId account_b_id;
212   const gchar* account_a_id_str;
213   const gchar* account_b_id_str;
214   gchar* account_a_name;
215   gchar* account_b_name;
216   int result;
217   dialog = INF_GTK_PERMISSIONS_DIALOG(user_data);
218   priv = INF_GTK_PERMISSIONS_DIALOG_PRIVATE(dialog);
219   gtk_tree_model_get(
220     model,
221     a,
222     INF_GTK_PERMISSIONS_DIALOG_COLUMN_ID, &amp;account_a_id_ptr,
223     INF_GTK_PERMISSIONS_DIALOG_COLUMN_NAME, &amp;account_a_name,
224     -1
225   );
226   gtk_tree_model_get(
227     model,
228     b,
229     INF_GTK_PERMISSIONS_DIALOG_COLUMN_ID, &amp;account_b_id_ptr,
230     INF_GTK_PERMISSIONS_DIALOG_COLUMN_NAME, &amp;account_b_name,
231     -1
232   );
233   account_a_id = INF_ACL_ACCOUNT_POINTER_TO_ID(account_a_id_ptr);
234   account_b_id = INF_ACL_ACCOUNT_POINTER_TO_ID(account_b_id_ptr);
235   account_a_id_str = inf_acl_account_id_to_string(account_a_id);
236   account_b_id_str = inf_acl_account_id_to_string(account_b_id);
237   default_id = inf_acl_account_id_from_string("default");
238   if(account_a_id == default_id)
239   {
240     if(account_b_id == default_id)
241       result = 0;
242     else
243       result = -1;
244   }
245   else if(account_b_id == default_id)
246   {
247     result = 1;
248   }
249   else if(account_a_name != NULL &amp;&amp; account_a_id != 0)
250   {
251     if(account_b_name != NULL &amp;&amp; account_b_id != 0)
252       result = g_utf8_collate(account_a_name, account_b_name);
253     else
254       result = -1;
255   }
256   else if(account_b_name != NULL &amp;&amp; account_b_id != 0)
257   {
258     result = 1;
259   }
260   else if(account_a_name == NULL &amp;&amp; account_a_id != 0)
261   {
262     if(account_b_name == NULL &amp;&amp; account_b_id != 0)
263       result = g_utf8_collate(account_a_id_str, account_b_id_str);
264     else
265       result = -1;
266   }
267   else if(account_b_name == NULL &amp;&amp; account_b_id != 0)
268   {
269     result = 1;
270   }
271   else if(account_a_name != NULL &amp;&amp; account_a_id == 0)
272   {
273     if(account_b_name != NULL &amp;&amp; account_b_id == 0)
274       result = g_utf8_collate(account_a_name, account_b_name);
275     else
276       result = -1;
277   }
278   else if(account_b_name != NULL &amp;&amp; account_b_id == 0)
279   {
280     result = 1;
281   }
282   else
283   {
284     g_assert_not_reached();
285     result = 0;
286   }
287   g_free(account_a_name);
288   g_free(account_b_name);
289   return result;
290 }
291 static void
292 inf_gtk_permissions_dialog_lookup_by_name_finished_cb(
293   InfRequest* request,
294   const InfRequestResult* result,
295   const GError* error,
296   gpointer user_data);
297 static void
298 inf_gtk_permissions_dialog_remove_pending_sheet(
299   InfGtkPermissionsDialog* dialog,
300   InfGtkPermissionsDialogPendingSheet* pending)
301 {
302   InfGtkPermissionsDialogPrivate* priv;
303   GtkTreePath* path;
304   GtkTreeIter iter;
305   gboolean has_iter;
306   priv = INF_GTK_PERMISSIONS_DIALOG_PRIVATE(dialog);
307   if(pending-&gt;lookup_request != NULL)
308   {
309     inf_signal_handlers_disconnect_by_func(
310       G_OBJECT(pending-&gt;lookup_request),
311       G_CALLBACK(inf_gtk_permissions_dialog_lookup_by_name_finished_cb),
312       pending
313     );
314     g_object_unref(pending-&gt;lookup_request);
315   }
316   priv-&gt;pending_sheets = g_slist_remove(priv-&gt;pending_sheets, pending);
317   if(pending-&gt;row != NULL)
318   {
319     path = gtk_tree_row_reference_get_path(pending-&gt;row);
320     g_assert(path != NULL);
321     has_iter = gtk_tree_model_get_iter(
322       GTK_TREE_MODEL(priv-&gt;account_store),
323       &amp;iter,
324       path
325     );
326     g_assert(has_iter == TRUE);
327     gtk_list_store_remove(priv-&gt;account_store, &amp;iter);
328     gtk_tree_path_free(path);
329     gtk_tree_row_reference_free(pending-&gt;row);
330   }
331   g_slice_free(InfGtkPermissionsDialogPendingSheet, pending);
332 }
333 static void
334 inf_gtk_permissions_dialog_realize_pending_sheet(
335   InfGtkPermissionsDialog* dialog,
336   InfGtkPermissionsDialogPendingSheet* pending,
337   InfAclAccountId id,
338   const gchar* name)
339 {
340   InfGtkPermissionsDialogPrivate* priv;
341   GtkTreeIter iter;
342   GtkTreePath* path;
343   gboolean has_iter;
344   InfAclSheet pending_sheet;
345   InfAclSheetSet sheet_set;
346   InfRequest* request;
347   priv = INF_GTK_PERMISSIONS_DIALOG_PRIVATE(dialog);
348   pending_sheet = pending-&gt;sheet;
349   pending_sheet.account = id;
350   if(inf_gtk_permissions_dialog_find_account(dialog, id, &amp;iter))
351   {
352     path = gtk_tree_model_get_path(
353       GTK_TREE_MODEL(priv-&gt;account_store),
354       &amp;iter
355     );
356     inf_signal_handlers_block_by_func(
357       G_OBJECT(gtk_tree_view_get_selection(GTK_TREE_VIEW(priv-&gt;tree_view))),
358       G_CALLBACK(inf_gtk_permissions_dialog_selection_changed_cb),
359       dialog
360     );
361     gtk_tree_view_set_cursor(
362       GTK_TREE_VIEW(priv-&gt;tree_view),
363       path,
364       gtk_tree_view_get_column(GTK_TREE_VIEW(priv-&gt;tree_view), 0),
365       FALSE
366     );
367     inf_gtk_permissions_dialog_remove_pending_sheet(dialog, pending);
368     inf_signal_handlers_unblock_by_func(
369       G_OBJECT(gtk_tree_view_get_selection(GTK_TREE_VIEW(priv-&gt;tree_view))),
370       G_CALLBACK(inf_gtk_permissions_dialog_selection_changed_cb),
371       dialog
372     );
373     gtk_tree_path_free(path);
374     inf_gtk_permissions_dialog_update_sheet(dialog);
375   }
376   else
377   {
378     path = gtk_tree_row_reference_get_path(pending-&gt;row);
379     g_assert(path != NULL);
380     has_iter  = gtk_tree_model_get_iter(
381       GTK_TREE_MODEL(priv-&gt;account_store),
382       &amp;iter,
383       path
384     );
385     g_assert(has_iter == TRUE);
386     gtk_list_store_set(
387       priv-&gt;account_store,
388       &amp;iter,
389       INF_GTK_PERMISSIONS_DIALOG_COLUMN_ID, INF_ACL_ACCOUNT_ID_TO_POINTER(id),
390       INF_GTK_PERMISSIONS_DIALOG_COLUMN_NAME, name,
391       -1
392     );
393     gtk_tree_row_reference_free(pending-&gt;row);
394     pending-&gt;row = NULL;
395     inf_gtk_permissions_dialog_remove_pending_sheet(dialog, pending);
396     inf_signal_handlers_block_by_func(
397       G_OBJECT(priv-&gt;sheet_view),
398       G_CALLBACK(inf_gtk_permissions_dialog_sheet_changed_cb),
399       dialog
400     );
401     inf_gtk_acl_sheet_view_set_sheet(
402       INF_GTK_ACL_SHEET_VIEW(priv-&gt;sheet_view),
403       &amp;pending_sheet
404     );
405     inf_signal_handlers_unblock_by_func(
406       G_OBJECT(priv-&gt;sheet_view),
407       G_CALLBACK(inf_gtk_permissions_dialog_sheet_changed_cb),
408       dialog
409     );
410     if(!inf_acl_mask_empty(&amp;pending_sheet.mask))
411     {
412       sheet_set.own_sheets = NULL;
413       sheet_set.sheets = &amp;pending_sheet;
414       sheet_set.n_sheets = 1;
415       request = inf_browser_set_acl(
416         priv-&gt;browser,
417         &amp;priv-&gt;browser_iter,
418         &amp;sheet_set,
419         inf_gtk_permissions_dialog_set_acl_finished_cb,
420         dialog
421       );
422       if(request != NULL)
423       {
424         priv-&gt;set_acl_requests =
425           g_slist_prepend(priv-&gt;set_acl_requests, request);
426         g_object_ref(request);
427       }
428     }
429     inf_gtk_permissions_dialog_update(dialog, NULL);
430   }
431 }
432 static void
433 inf_gtk_permissions_dialog_lookup_by_name_finished_cb(
434   InfRequest* request,
435   const InfRequestResult* result,
436   const GError* error,
437   gpointer user_data)
438 {
439   InfGtkPermissionsDialogPendingSheet* pending;
440   InfGtkPermissionsDialog* dialog;
441   InfGtkPermissionsDialogPrivate* priv;
442   const InfAclAccount* accounts;
443   guint n_accounts;
444   pending = (InfGtkPermissionsDialogPendingSheet*)user_data;
445   dialog = pending-&gt;dialog;
446   priv = INF_GTK_PERMISSIONS_DIALOG_PRIVATE(dialog);
447   if(pending-&gt;lookup_request != NULL)
448   {
449     g_object_unref(pending-&gt;lookup_request);
450     pending-&gt;lookup_request = NULL;
451   }
452   if(error != NULL)
453   {
454     g_warning("Failed to reverse lookup: %s", error-&gt;message);
455     inf_gtk_permissions_dialog_remove_pending_sheet(dialog, pending);
456   }
457   else
458   {
459     inf_request_result_get_lookup_acl_accounts(
460       result,
461       NULL,
462       &amp;accounts,
463       &amp;n_accounts
464     );
465     if(n_accounts &gt; 0)
466     {
467       if(n_accounts &gt; 1)
468       {
469         g_warning(
470           "Multiple accounts with the same name \"%s\"",
471           accounts[0].name
472         );
473       }
474       inf_gtk_permissions_dialog_realize_pending_sheet(
475         dialog,
476         pending,
477         accounts[0].id,
478         accounts[0].name
479       );
480     }
481     else
482     {
483       inf_gtk_permissions_dialog_remove_pending_sheet(dialog, pending);
484     }
485   }
486 }
487 static void
488 inf_gtk_permissions_dialog_lookup_acl_accounts_finished_cb(
489   InfRequest* request,
490   const InfRequestResult* result,
491   const GError* error,
492   gpointer user_data);
493 static void
494 inf_gtk_permissions_dialog_remove_lookup_acl_accounts_request(
495   InfGtkPermissionsDialog* dialog,
496   InfRequest* request)
497 {
498   InfGtkPermissionsDialogPrivate* priv;
499   priv = INF_GTK_PERMISSIONS_DIALOG_PRIVATE(dialog);
500   inf_signal_handlers_disconnect_by_func(
501     request,
502     G_CALLBACK(inf_gtk_permissions_dialog_lookup_acl_accounts_finished_cb),
503     dialog
504   );
505   if(g_slist_find(priv-&gt;lookup_acl_account_requests, request) != NULL)
506   {
507     priv-&gt;lookup_acl_account_requests =
508       g_slist_remove(priv-&gt;lookup_acl_account_requests, request);
509     g_object_unref(request);
510   }
511 }
512 static void
513 inf_gtk_permissions_dialog_lookup_acl_accounts_finished_cb(
514   InfRequest* request,
515   const InfRequestResult* result,
516   const GError* error,
517   gpointer user_data)
518 {
519   InfGtkPermissionsDialog* dialog;
520   InfGtkPermissionsDialogPrivate* priv;
521   const InfAclAccount* accounts;
522   guint n_accounts;
523   guint i;
524   GtkTreeIter iter;
525   InfAclAccountId account_id;
526   dialog = INF_GTK_PERMISSIONS_DIALOG(user_data);
527   priv = INF_GTK_PERMISSIONS_DIALOG_PRIVATE(dialog);
528   if(error != NULL)
529   {
530     g_warning("Failed to look up accounts: %s\n", error-&gt;message);
531   }
532   else
533   {
534     inf_request_result_get_lookup_acl_accounts(
535       result,
536       NULL,
537       &amp;accounts,
538       &amp;n_accounts
539     );
540     for(i = 0; i &lt; n_accounts; ++i)
541     {
542       if(accounts[i].name != NULL)
543       {
544         account_id = accounts[i].id;
545         if(inf_gtk_permissions_dialog_find_account(dialog, account_id, &amp;iter))
546         {
547           gtk_list_store_set(
548             GTK_LIST_STORE(priv-&gt;account_store),
549             &amp;iter,
550             INF_GTK_PERMISSIONS_DIALOG_COLUMN_NAME,
551             accounts[i].name,
552             -1
553           );
554         }
555       }
556     }
557   }
558   inf_gtk_permissions_dialog_remove_lookup_acl_accounts_request(
559     dialog,
560     request
561   );
562 }
563 static void
564 inf_gtk_permissions_dialog_fill_account_list(InfGtkPermissionsDialog* dialog,
565                                              const InfAclAccountId* ids,
566                                              guint n_ids)
567 {
568   InfGtkPermissionsDialogPrivate* priv;
569   GtkTreeModel* model;
570   gboolean* have_accounts;
571   GtkTreeIter iter;
572   gpointer account_id_ptr;
573   InfAclAccountId account_id;
574   gboolean has_row;
575   guint i, j;
576   InfAclAccountId* lookup_ids;
577   guint n_lookup_ids;
578   guint lookup_index;
579   const gchar* new_account_name;
580   InfAclMask perms;
581   const InfAclAccount* default_account;
582   const InfAclAccount* local_account;
583   InfRequest* request;
584   priv = INF_GTK_PERMISSIONS_DIALOG_PRIVATE(dialog);
585   model = GTK_TREE_MODEL(priv-&gt;account_store);
586   have_accounts = g_malloc(n_ids * sizeof(gboolean));
587   for(i = 0; i &lt; n_ids; ++i)
588     have_accounts[i] = FALSE;
589   n_lookup_ids = n_ids;
590   has_row = gtk_tree_model_get_iter_first(model, &amp;iter);
591   while(has_row)
592   {
593     gtk_tree_model_get(
594       model,
595       &amp;iter,
596       INF_GTK_PERMISSIONS_DIALOG_COLUMN_ID,
597       &amp;account_id_ptr,
598       -1
599     );
600     account_id = INF_ACL_ACCOUNT_POINTER_TO_ID(account_id_ptr);
601     if(account_id == 0)
602     {
603       has_row = gtk_tree_model_iter_next(model, &amp;iter);
604     }
605     else
606     {
607       for(i = 0; i &lt; n_ids; ++i)
608         if(account_id == ids[i])
609           break;
610       if(i &lt; n_ids)
611       {
612         have_accounts[i] = TRUE;
613         has_row = gtk_tree_model_iter_next(model, &amp;iter);
614         g_assert(n_lookup_ids &gt; 0);
615         --n_lookup_ids;
616       }
617       else
618       {
619         inf_signal_handlers_block_by_func(
620           gtk_tree_view_get_selection(GTK_TREE_VIEW(priv-&gt;tree_view)),
621           G_CALLBACK(inf_gtk_permissions_dialog_selection_changed_cb),
622           dialog
623         );
624         has_row = gtk_list_store_remove(priv-&gt;account_store, &amp;iter);
625         inf_signal_handlers_unblock_by_func(
626           gtk_tree_view_get_selection(GTK_TREE_VIEW(priv-&gt;tree_view)),
627           G_CALLBACK(inf_gtk_permissions_dialog_selection_changed_cb),
628           dialog
629         );
630       }
631     }
632   }
633   if(n_lookup_ids &gt; 0)
634     lookup_ids = g_malloc(sizeof(InfAclAccountId) * n_lookup_ids);
635   lookup_index = 0;
636   default_account = inf_browser_get_acl_default_account(priv-&gt;browser);
637   local_account = inf_browser_get_acl_local_account(priv-&gt;browser);
638   for(i = 0; i &lt; n_ids; ++i)
639   {
640     if(!have_accounts[i])
641     {
642       if(ids[i] == default_account-&gt;id)
643       {
644         new_account_name = default_account-&gt;name;
645       }
646       else if(local_account != NULL &amp;&amp; ids[i] == local_account-&gt;id)
647       {
648         new_account_name = local_account-&gt;name;
649       }
650       else
651       {
652         new_account_name = NULL;
653         for(j = 0; j &lt; priv-&gt;n_accounts; ++j)
654         {
655           if(priv-&gt;accounts[j].id == ids[i])
656           {
657             new_account_name = priv-&gt;accounts[j].name;
658             break;
659           }
660         }
661       }
662       gtk_list_store_insert_with_values(
663         priv-&gt;account_store,
664         NULL,
665         -1,
666         INF_GTK_PERMISSIONS_DIALOG_COLUMN_ID,
667         INF_ACL_ACCOUNT_ID_TO_POINTER(ids[i]),
668         INF_GTK_PERMISSIONS_DIALOG_COLUMN_NAME,
669         new_account_name,
670         -1
671       );
672       if(new_account_name == NULL &amp;&amp; ids[i] != default_account-&gt;id)
673         lookup_ids[lookup_index++] = ids[i];
674     }
675   }
676   if(lookup_index &gt; 0)
677   {
678     g_assert(lookup_index &lt;= n_lookup_ids);
679     inf_acl_mask_set1(&amp;perms, INF_ACL_CAN_QUERY_ACCOUNT_LIST);
680     inf_browser_check_acl(
681       priv-&gt;browser,
682       &amp;priv-&gt;browser_iter,
683       local_account ? local_account-&gt;id : 0,
684       &amp;perms,
685       &amp;perms
686     );
687     if(inf_acl_mask_has(&amp;perms, INF_ACL_CAN_QUERY_ACCOUNT_LIST))
688     {
689       request = inf_browser_lookup_acl_accounts(
690         priv-&gt;browser,
691         lookup_ids,
692         lookup_index,
693         inf_gtk_permissions_dialog_lookup_acl_accounts_finished_cb,
694         dialog
695       );
696       if(request != NULL)
697       {
698         g_object_ref(request);
699         priv-&gt;lookup_acl_account_requests = g_slist_prepend(
700           priv-&gt;lookup_acl_account_requests,
701           request
702         );
703       }
704     }
705   }
706   if(n_lookup_ids &gt; 0)
707     g_free(lookup_ids);
708   g_free(have_accounts);
709 }
710 static void
711 inf_gtk_permissions_dialog_update_sheet(InfGtkPermissionsDialog* dialog)
712 {
713   InfGtkPermissionsDialogPrivate* priv;
714   GtkTreeSelection* selection;
715   GtkTreeModel* model;
716   GtkTreeIter iter;
717   gpointer account_id_ptr;
718   InfAclAccountId account_id;
719   InfAclAccountId default_id;
720   const InfAclSheetSet* sheet_set;
721   const InfAclSheet* sheet;
722   InfAclSheet default_sheet;
723   InfAclMask show_mask;
724   InfAclMask neg_mask;
725   InfGtkPermissionsDialogPendingSheet* pending;
726   InfBrowserIter test_iter;
727   priv = INF_GTK_PERMISSIONS_DIALOG_PRIVATE(dialog);
728   selection = gtk_tree_view_get_selection(GTK_TREE_VIEW(priv-&gt;tree_view));
729   inf_signal_handlers_block_by_func(
730     G_OBJECT(priv-&gt;sheet_view),
731     G_CALLBACK(inf_gtk_permissions_dialog_sheet_changed_cb),
732     dialog
733   );
734   if(!gtk_tree_selection_get_selected(selection, &amp;model, &amp;iter))
735   {
736     inf_gtk_acl_sheet_view_set_sheet(
737       INF_GTK_ACL_SHEET_VIEW(priv-&gt;sheet_view),
738       NULL
739     );
740     account_id = 0;
741   }
742   else
743   {
744     gtk_tree_model_get(
745       model,
746       &amp;iter,
747       INF_GTK_PERMISSIONS_DIALOG_COLUMN_ID,
748       &amp;account_id_ptr,
749       -1
750     );
751     account_id = INF_ACL_ACCOUNT_POINTER_TO_ID(account_id_ptr);
752     if(account_id != 0)
753     {
754       sheet = NULL;
755       sheet_set = inf_browser_get_acl(priv-&gt;browser, &amp;priv-&gt;browser_iter);
756       if(sheet_set != NULL)
757       {
758         sheet = inf_acl_sheet_set_find_const_sheet(sheet_set, account_id);
759       }
760     }
761     else
762     {
763       pending = inf_gtk_permissions_dialog_find_pending_sheet(dialog, &amp;iter);
764       g_assert(pending != NULL);
765       sheet = &amp;pending-&gt;sheet;
766     }
767     if(sheet != NULL)
768     {
769       inf_gtk_acl_sheet_view_set_sheet(
770         INF_GTK_ACL_SHEET_VIEW(priv-&gt;sheet_view),
771         sheet
772       );
773     }
774     else
775     {
776       default_sheet.account = account_id;
777       inf_acl_mask_clear(&amp;default_sheet.mask);
778       inf_acl_mask_clear(&amp;default_sheet.perms);
779       inf_gtk_acl_sheet_view_set_sheet(
780         INF_GTK_ACL_SHEET_VIEW(priv-&gt;sheet_view),
781         &amp;default_sheet
782       );
783     }
784   }
785   test_iter = priv-&gt;browser_iter;
786   show_mask = INF_ACL_MASK_ALL;
787   if(!inf_browser_get_parent(priv-&gt;browser, &amp;test_iter))
788   {
789     default_id = inf_acl_account_id_from_string("default");
790     if(account_id == default_id)
791     {
792       inf_gtk_acl_sheet_view_set_show_default(
793         INF_GTK_ACL_SHEET_VIEW(priv-&gt;sheet_view),
794         FALSE
795       );
796     }
797     else
798     {
799       inf_gtk_acl_sheet_view_set_show_default(
800         INF_GTK_ACL_SHEET_VIEW(priv-&gt;sheet_view),
801         TRUE
802       );
803     }
804   }
805   else
806   {
807     inf_gtk_acl_sheet_view_set_show_default(
808       INF_GTK_ACL_SHEET_VIEW(priv-&gt;sheet_view),
809       TRUE
810     );
811     inf_acl_mask_neg(&amp;INF_ACL_MASK_ROOT, &amp;neg_mask);
812     inf_acl_mask_and(&amp;show_mask, &amp;neg_mask, &amp;show_mask);
813   }
814   if(!inf_browser_is_subdirectory(priv-&gt;browser, &amp;priv-&gt;browser_iter))
815   {
816     inf_acl_mask_neg(&amp;INF_ACL_MASK_SUBDIRECTORY, &amp;neg_mask);
817     inf_acl_mask_and(&amp;show_mask, &amp;neg_mask, &amp;show_mask);
818   }
819   inf_gtk_acl_sheet_view_set_permission_mask(
820     INF_GTK_ACL_SHEET_VIEW(priv-&gt;sheet_view),
821     &amp;show_mask
822   );
823   inf_signal_handlers_unblock_by_func(
824     G_OBJECT(priv-&gt;sheet_view),
825     G_CALLBACK(inf_gtk_permissions_dialog_sheet_changed_cb),
826     dialog
827   );
828 }
829 static void
830 inf_gtk_permissions_dialog_node_removed_cb(InfBrowser* browser,
831                                            const InfBrowserIter* iter,
832                                            InfRequest* request,
833                                            gpointer user_data)
834 {
835   InfGtkPermissionsDialog* dialog;
836   InfGtkPermissionsDialogPrivate* priv;
837   dialog = INF_GTK_PERMISSIONS_DIALOG(user_data);
838   priv = INF_GTK_PERMISSIONS_DIALOG_PRIVATE(dialog);
839   if(inf_browser_is_ancestor(browser, iter, &amp;priv-&gt;browser_iter))
840     inf_gtk_permissions_dialog_set_node(dialog, NULL, NULL);
841 }
842 static void
843 inf_gtk_permissions_dialog_acl_account_added_cb(InfBrowser* browser,
844                                                 const InfAclAccount* account,
845                                                 InfRequest* request,
846                                                 gpointer user_data)
847 {
848   InfGtkPermissionsDialog* dialog;
849   InfGtkPermissionsDialogPrivate* priv;
850   dialog = INF_GTK_PERMISSIONS_DIALOG(user_data);
851   priv = INF_GTK_PERMISSIONS_DIALOG_PRIVATE(dialog);
852   if(account-&gt;id != 0 &amp;&amp; account-&gt;name != NULL &amp;&amp; priv-&gt;accounts != NULL)
853   {
854     priv-&gt;accounts = g_realloc(
855       priv-&gt;accounts,
856       (priv-&gt;n_accounts + 1) * sizeof(InfAclAccount)
857     );
858     priv-&gt;accounts[priv-&gt;n_accounts].id = account-&gt;id;
859     priv-&gt;accounts[priv-&gt;n_accounts].name = g_strdup(account-&gt;name);
860     ++priv-&gt;n_accounts;
861     inf_gtk_permissions_dialog_update(dialog, NULL);
862   }
863 }
864 static void
865 inf_gtk_permissions_dialog_acl_account_removed_cb(InfBrowser* browser,
866                                                   const InfAclAccount* account,
867                                                   InfRequest* request,
868                                                   gpointer user_data)
869 {
870   InfGtkPermissionsDialog* dialog;
871   InfGtkPermissionsDialogPrivate* priv;
872   gboolean have_account;
873   GtkTreeIter iter;
874   guint i;
875   dialog = INF_GTK_PERMISSIONS_DIALOG(user_data);
876   priv = INF_GTK_PERMISSIONS_DIALOG_PRIVATE(dialog);
877   g_assert(account-&gt;id != 0);
878   if(priv-&gt;popup_menu != NULL &amp;&amp; account-&gt;id == priv-&gt;popup_account)
879     gtk_menu_popdown(priv-&gt;popup_menu);
880   g_assert(priv-&gt;popup_menu == NULL);
881   g_assert(priv-&gt;popup_account == 0);
882   have_account =
883     inf_gtk_permissions_dialog_find_account(dialog, account-&gt;id, &amp;iter);
884   if(have_account == TRUE)
885   {
886     inf_signal_handlers_block_by_func(
887       gtk_tree_view_get_selection(GTK_TREE_VIEW(priv-&gt;tree_view)),
888       G_CALLBACK(inf_gtk_permissions_dialog_selection_changed_cb),
889       dialog
890     );
891     gtk_list_store_remove(priv-&gt;account_store, &amp;iter);
892     inf_signal_handlers_unblock_by_func(
893       gtk_tree_view_get_selection(GTK_TREE_VIEW(priv-&gt;tree_view)),
894       G_CALLBACK(inf_gtk_permissions_dialog_selection_changed_cb),
895       dialog
896     );
897     inf_gtk_permissions_dialog_update_sheet(dialog);
898   }
899   if(priv-&gt;accounts != NULL)
900   {
901     for(i = 0; i &lt; priv-&gt;n_accounts; ++i)
902     {
903       if(priv-&gt;accounts[i].id == account-&gt;id)
904       {
905         priv-&gt;accounts[i] = priv-&gt;accounts[priv-&gt;n_accounts - 1];
906         --priv-&gt;n_accounts;
907         priv-&gt;accounts = g_realloc(
908           priv-&gt;accounts,
909           sizeof(InfAclAccount) * priv-&gt;n_accounts
910         );
911         break;
912       }
913     }
914   }
915   inf_gtk_permissions_dialog_update(dialog, NULL);
916 }
917 static void
918 inf_gtk_permissions_dialog_acl_changed_cb(InfBrowser* browser,
919                                           const InfBrowserIter* iter,
920                                           const InfAclSheetSet* sheet_set,
921                                           InfRequest* request,
922                                           gpointer user_data)
923 {
924   InfGtkPermissionsDialog* dialog;
925   InfGtkPermissionsDialogPrivate* priv;
926   dialog = INF_GTK_PERMISSIONS_DIALOG(user_data);
927   priv = INF_GTK_PERMISSIONS_DIALOG_PRIVATE(dialog);
928   if(iter-&gt;node == priv-&gt;browser_iter.node)
929     inf_gtk_permissions_dialog_update_sheet(dialog);
930   if(inf_browser_is_ancestor(browser, iter, &amp;priv-&gt;browser_iter))
931     inf_gtk_permissions_dialog_update(dialog, NULL);
932 }
933 static void
934 inf_gtk_permissions_dialog_renderer_editing_started_cb(GtkCellRenderer* r,
935                                                        GtkCellEditable* edit,
936                                                        const gchar* path,
937                                                        gpointer user_data)
938 {
939   g_object_set_data_full(
940     G_OBJECT(r),
941     "inf-gtk-permissions-dialog-path",
942     g_strdup(path),
943     g_free
944   );
945 }
946 static void
947 inf_gtk_permissions_dialog_renderer_editing_canceled_cb(GtkCellRenderer* r,
948                                                         gpointer user_data)
949 {
950   InfGtkPermissionsDialog* dialog;
951   InfGtkPermissionsDialogPrivate* priv;
952   gchar* path_str;
953   GtkTreePath* path;
954   GtkTreeIter iter;
955   gboolean has_selected;
956   InfGtkPermissionsDialogPendingSheet* pending;
957   dialog = INF_GTK_PERMISSIONS_DIALOG(user_data);
958   priv = INF_GTK_PERMISSIONS_DIALOG_PRIVATE(dialog);
959   g_object_set(
960     G_OBJECT(priv-&gt;renderer),
961     "model", NULL,
962     "editable", FALSE,
963     NULL
964   );
965   path_str = g_object_steal_data(
966     G_OBJECT(r),
967     "inf-gtk-permissions-dialog-path"
968   );
969   path = gtk_tree_path_new_from_string(path_str);
970   g_free(path_str);
971   has_selected = gtk_tree_model_get_iter(
972     GTK_TREE_MODEL(priv-&gt;account_store),
973     &amp;iter,
974     path
975   );
976   g_assert(has_selected == TRUE);
977   pending = inf_gtk_permissions_dialog_find_pending_sheet(dialog, &amp;iter);
978   g_assert(pending != NULL);
979   inf_gtk_permissions_dialog_remove_pending_sheet(dialog, pending);
980 }
981 static void
982 inf_gtk_permissions_dialog_renderer_changed_cb(GtkCellRendererCombo* combo,
983                                                const gchar* path_str,
984                                                GtkTreeIter* combo_iter,
985                                                gpointer user_data)
986 {
987   InfGtkPermissionsDialog* dialog;
988   InfGtkPermissionsDialogPrivate* priv;
989   GtkTreePath* path;
990   GtkTreeIter view_iter;
991   gboolean has_path;
992   InfGtkPermissionsDialogPendingSheet* pending;
993   GtkTreeModel* model;
994   gpointer id_ptr;
995   dialog = INF_GTK_PERMISSIONS_DIALOG(user_data);
996   priv = INF_GTK_PERMISSIONS_DIALOG_PRIVATE(dialog);
997   path = gtk_tree_path_new_from_string(path_str);
998   has_path = gtk_tree_model_get_iter(
999     GTK_TREE_MODEL(priv-&gt;account_store),
1000     &amp;view_iter,
1001     path
1002   );
1003   g_assert(has_path);
1004   gtk_tree_path_free(path);
1005   pending = inf_gtk_permissions_dialog_find_pending_sheet(dialog, &amp;view_iter);
1006   g_assert(pending != NULL);
1007   g_object_get(G_OBJECT(combo), "model", &amp;model, NULL);
1008   g_assert(model != NULL);
1009   gtk_tree_model_get(
1010     model,
1011     combo_iter,
1012     INF_GTK_PERMISSIONS_DIALOG_COLUMN_ID,
1013     &amp;id_ptr,
1014     -1
1015   );
1016   pending-&gt;last_combo_changed_id = INF_ACL_ACCOUNT_POINTER_TO_ID(id_ptr);
1017   g_object_unref(model);
1018 }
1019 static void
1020 inf_gtk_permissions_dialog_renderer_edited_cb(GtkCellRendererCombo* renderer,
1021                                               const gchar* path_str,
1022                                               const gchar* text,
1023                                               gpointer user_data)
1024 {
1025   InfGtkPermissionsDialog* dialog;
1026   InfGtkPermissionsDialogPrivate* priv;
1027   gchar* path_str_obj;
1028   GtkTreePath* path;
1029   gboolean has_path;
1030   GtkTreeIter view_iter;
1031   InfGtkPermissionsDialogPendingSheet* pending;
1032   GtkTreeModel* model;
1033   InfRequest* request;
1034   dialog = INF_GTK_PERMISSIONS_DIALOG(user_data);
1035   priv = INF_GTK_PERMISSIONS_DIALOG_PRIVATE(dialog);
1036   path_str_obj = g_object_steal_data(
1037     G_OBJECT(renderer),
1038     "inf-gtk-permissions-dialog-path"
1039   );
1040   g_assert(strcmp(path_str_obj, path_str) == 0);
1041   g_free(path_str_obj);
1042   path = gtk_tree_path_new_from_string(path_str);
1043   has_path = gtk_tree_model_get_iter(
1044     GTK_TREE_MODEL(priv-&gt;account_store),
1045     &amp;view_iter,
1046     path
1047   );
1048   g_assert(has_path);
1049   gtk_tree_path_free(path);
1050   pending = inf_gtk_permissions_dialog_find_pending_sheet(dialog, &amp;view_iter);
1051   g_assert(pending != NULL);
1052   g_object_get(G_OBJECT(renderer), "model", &amp;model, NULL);
1053   g_object_set(
1054     G_OBJECT(priv-&gt;renderer),
1055     "model", NULL,
1056     "editable", FALSE,
1057     NULL
1058   );
1059   g_assert(model != NULL);
1060   if(gtk_tree_model_iter_n_children(model, NULL) &gt; 0)
1061   {
1062     g_assert(pending-&gt;last_combo_changed_id != 0);
1063     inf_gtk_permissions_dialog_realize_pending_sheet(
1064       dialog,
1065       pending,
1066       pending-&gt;last_combo_changed_id,
1067       text
1068     );
1069   }
1070   else
1071   {
1072     gtk_list_store_set(
1073       priv-&gt;account_store,
1074       &amp;view_iter,
1075       INF_GTK_PERMISSIONS_DIALOG_COLUMN_NAME,
1076       text,
1077       -1
1078     );
1079     request = inf_browser_lookup_acl_account_by_name(
1080       priv-&gt;browser,
1081       text,
1082       inf_gtk_permissions_dialog_lookup_by_name_finished_cb,
1083       pending
1084     );
1085     if(request != NULL)
1086     {
1087       pending-&gt;lookup_request = request;
1088       g_object_ref(request);
1089     }
1090   }
1091   g_object_unref(model);
1092 }
1093 static void
1094 inf_gtk_permissions_dialog_add_clicked_cb(GtkButton* button,
1095                                           gpointer user_data)
1096 {
1097   InfGtkPermissionsDialog* dialog;
1098   InfGtkPermissionsDialogPrivate* priv;
1099   GtkTreeIter new_iter;
1100   GtkTreePath* new_path;
1101   InfGtkPermissionsDialogPendingSheet* pending;
1102   GtkListStore* store;
1103   const InfAclSheetSet* sheet_set;
1104   const InfAclSheet* sheet;
1105   guint i;
1106   dialog = INF_GTK_PERMISSIONS_DIALOG(user_data);
1107   priv = INF_GTK_PERMISSIONS_DIALOG_PRIVATE(dialog);
1108   gtk_cell_renderer_stop_editing(priv-&gt;renderer, TRUE);
1109   gtk_list_store_insert_with_values(
1110     priv-&gt;account_store,
1111     &amp;new_iter,
1112     -1,
1113     INF_GTK_PERMISSIONS_DIALOG_COLUMN_ID,
1114     0,
1115     INF_GTK_PERMISSIONS_DIALOG_COLUMN_NAME,
1116     NULL,
1117     -1
1118   );
1119   new_path = gtk_tree_model_get_path(
1120     GTK_TREE_MODEL(priv-&gt;account_store),
1121     &amp;new_iter
1122   );
1123   pending = g_slice_new(InfGtkPermissionsDialogPendingSheet);
1124   pending-&gt;dialog = dialog;
1125   pending-&gt;row = gtk_tree_row_reference_new(
1126     GTK_TREE_MODEL(priv-&gt;account_store),
1127     new_path
1128   );
1129   pending-&gt;sheet.account = 0;
1130   inf_acl_mask_clear(&amp;pending-&gt;sheet.mask);
1131   inf_acl_mask_clear(&amp;pending-&gt;sheet.perms);
1132   pending-&gt;last_combo_changed_id = 0;
1133   pending-&gt;lookup_request = NULL;
1134   priv-&gt;pending_sheets = g_slist_prepend(priv-&gt;pending_sheets, pending);
1135   store = gtk_list_store_new(2, G_TYPE_POINTER, G_TYPE_STRING);
1136   g_object_set(
1137     G_OBJECT(priv-&gt;renderer),
1138     "model", store,
1139     "editable", TRUE,
1140     "text-column", INF_GTK_PERMISSIONS_DIALOG_COLUMN_NAME,
1141     NULL
1142   );
1143   if(priv-&gt;accounts != NULL)
1144   {
1145     g_object_set(G_OBJECT(priv-&gt;renderer), "has-entry", FALSE, NULL);
1146     sheet_set = inf_browser_get_acl(priv-&gt;browser, &amp;priv-&gt;browser_iter);
1147     for(i = 0; i &lt; priv-&gt;n_accounts; ++i)
1148     {
1149       if(priv-&gt;accounts[i].name != NULL)
1150       {
1151         sheet = NULL;
1152         if(sheet_set != NULL)
1153         {
1154           sheet = inf_acl_sheet_set_find_const_sheet(
1155             sheet_set,
1156             priv-&gt;accounts[i].id
1157           );
1158         }
1159         if(sheet == NULL)
1160         {
1161           gtk_list_store_insert_with_values(
1162             store,
1163             NULL,
1164             -1,
1165             INF_GTK_PERMISSIONS_DIALOG_COLUMN_ID,
1166             priv-&gt;accounts[i].id,
1167             INF_GTK_PERMISSIONS_DIALOG_COLUMN_NAME,
1168             priv-&gt;accounts[i].name,
1169             -1
1170           );
1171         }
1172       }
1173     }
1174     g_assert(gtk_tree_model_iter_n_children(GTK_TREE_MODEL(store), NULL) &gt; 0);
1175   }
1176   else
1177   {
1178     g_object_set(G_OBJECT(priv-&gt;renderer), "has-entry", TRUE, NULL);
1179   }
1180   gtk_tree_sortable_set_sort_column_id(
1181     GTK_TREE_SORTABLE(store),
1182     INF_GTK_PERMISSIONS_DIALOG_COLUMN_NAME,
1183     GTK_SORT_ASCENDING
1184   );
1185   gtk_tree_sortable_set_sort_func(
1186     GTK_TREE_SORTABLE(store),
1187     INF_GTK_PERMISSIONS_DIALOG_COLUMN_NAME,
1188     inf_gtk_permissions_dialog_account_sort_func,
1189     dialog,
1190     NULL
1191   );
1192   g_object_unref(store);
1193   gtk_tree_selection_select_path(
1194     gtk_tree_view_get_selection(GTK_TREE_VIEW(priv-&gt;tree_view)),
1195     new_path
1196   );
1197   gtk_tree_path_free(new_path);
1198   new_path = gtk_tree_row_reference_get_path(pending-&gt;row);
1199   gtk_tree_view_set_cursor(
1200     GTK_TREE_VIEW(priv-&gt;tree_view),
1201     new_path,
1202     gtk_tree_view_get_column(GTK_TREE_VIEW(priv-&gt;tree_view), 0),
1203     TRUE
1204   );
1205   gtk_tree_path_free(new_path);
1206 }
1207 static void
1208 inf_gtk_permissions_dialog_remove_clicked_cb(GtkButton* button,
1209                                              gpointer user_data)
1210 {
1211   InfGtkPermissionsDialog* dialog;
1212   InfGtkPermissionsDialogPrivate* priv;
1213   GtkTreeSelection* selection;
1214   GtkTreeIter selected_iter;
1215   gpointer selected_id_ptr;
1216   InfAclAccountId selected_id;
1217   InfGtkPermissionsDialogPendingSheet* pending;
1218   const InfAclSheetSet* sheet_set;
1219   InfAclSheet set_sheet;
1220   InfAclSheetSet set_sheet_set;
1221   guint i;
1222   InfRequest* request;
1223   GtkTreeIter move_iter;
1224   gboolean could_move;
1225   dialog = INF_GTK_PERMISSIONS_DIALOG(user_data);
1226   priv = INF_GTK_PERMISSIONS_DIALOG_PRIVATE(dialog);
1227   selection = gtk_tree_view_get_selection(GTK_TREE_VIEW(priv-&gt;tree_view));
1228   if(!gtk_tree_selection_get_selected(selection, NULL, &amp;selected_iter))
1229     return;
1230   gtk_tree_model_get(
1231     GTK_TREE_MODEL(priv-&gt;account_store),
1232     &amp;selected_iter,
1233     INF_GTK_PERMISSIONS_DIALOG_COLUMN_ID,
1234     &amp;selected_id_ptr,
1235     -1
1236   );
1237   selected_id = INF_ACL_ACCOUNT_POINTER_TO_ID(selected_id_ptr);
1238   sheet_set = inf_browser_get_acl(priv-&gt;browser, &amp;priv-&gt;browser_iter);
1239   if(selected_id == 0)
1240   {
1241     pending = inf_gtk_permissions_dialog_find_pending_sheet(
1242       dialog,
1243       &amp;selected_iter
1244     );
1245     g_assert(pending != NULL);
1246     inf_gtk_permissions_dialog_remove_pending_sheet(dialog, pending);
1247   }
1248   else if(sheet_set == NULL || sheet_set-&gt;n_sheets == 0)
1249   {
1250     gtk_list_store_remove(priv-&gt;account_store, &amp;selected_iter);
1251   }
1252   else
1253   {
1254     set_sheet.account = selected_id;
1255     inf_acl_mask_clear(&amp;set_sheet.mask);
1256     inf_acl_mask_clear(&amp;set_sheet.perms);
1257     set_sheet_set.n_sheets = 1;
1258     set_sheet_set.own_sheets = NULL;
1259     set_sheet_set.sheets = &amp;set_sheet;
1260     request = inf_browser_set_acl(
1261       priv-&gt;browser,
1262       &amp;priv-&gt;browser_iter,
1263       &amp;set_sheet_set,
1264       inf_gtk_permissions_dialog_set_acl_finished_cb,
1265       dialog
1266     );
1267     if(request != NULL)
1268     {
1269       priv-&gt;set_acl_requests =
1270         g_slist_prepend(priv-&gt;set_acl_requests, request);
1271       g_object_ref(request);
1272     }
1273     move_iter = selected_iter;
1274     could_move = gtk_tree_model_iter_next(
1275       GTK_TREE_MODEL(priv-&gt;account_store),
1276       &amp;move_iter
1277     );
1278     if(!could_move)
1279     {
1280       move_iter = selected_iter;
1281       could_move = gtk_tree_model_iter_previous(
1282         GTK_TREE_MODEL(priv-&gt;account_store),
1283         &amp;move_iter
1284       );
1285     }
1286     g_assert(could_move);
1287     gtk_tree_selection_select_iter(
1288       GTK_TREE_SELECTION(selection),
1289       &amp;move_iter
1290     );
1291   }
1292 }
1293 static void
1294 inf_gtk_permissions_dialog_remove_acl_account_finished_cb(
1295   InfRequest* request,
1296   const InfRequestResult* result,
1297   const GError* error,
1298   gpointer user_data);
1299 static void
1300 inf_gtk_permissions_dialog_remove_remove_acl_account_request(
1301   InfGtkPermissionsDialog* dialog,
1302   InfRequest* request)
1303 {
1304   InfGtkPermissionsDialogPrivate* priv;
1305   priv = INF_GTK_PERMISSIONS_DIALOG_PRIVATE(dialog);
1306   g_assert(g_slist_find(priv-&gt;remove_acl_account_requests, request) != NULL);
1307   g_signal_handlers_disconnect_by_func(
1308     request,
1309     G_CALLBACK(inf_gtk_permissions_dialog_remove_acl_account_finished_cb),
1310     dialog
1311   );
1312   priv-&gt;remove_acl_account_requests =
1313     g_slist_remove(priv-&gt;remove_acl_account_requests, request);
1314   g_object_unref(request);
1315 }
1316 static void
1317 inf_gtk_permissions_dialog_remove_acl_account_finished_cb(
1318   InfRequest* request,
1319   const InfRequestResult* result,
1320   const GError* error,
1321   gpointer user_data)
1322 <a name="3"></a>{
1323   InfGtkPermissionsDialog* dialog;
1324 <font color="#53858b"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>  dialog = INF_GTK_PERMISSIONS_DIALOG(user_data);
1325   if(error != NULL)
1326   {
1327     g_warning("Failed to remove account: %s\n", error-&gt;message);
1328   }
1329   inf_gtk_permissions_dialog_remove_remove_acl_account_request(
1330     dialog,
1331     request
1332   );
1333 }
1334 static void
1335 inf_gtk_permissions_dialog_popup_delete_account_cb(GtkMenuItem* item,
1336                                                    gpointer user_data)
1337 {
1338   InfGtkPermissionsDialog* dialog;
1339   InfGtkPermissionsDialogPrivate* priv;
1340   InfRequest* request;
1341   dialog = INF_GTK_PERMISSIONS_DIALOG(user_data);
1342   priv = INF_GTK_PERMISSIONS_DIALOG_PRIVATE(dialog);
1343   g_assert(priv-&gt;popup_menu != NULL);
1344   g_assert(priv-&gt;popup_account != 0);
1345   request = inf_browser_remove_acl_account(</b></font>
1346     priv-&gt;browser,
1347     priv-&gt;popup_account,
1348     inf_gtk_permissions_dialog_remove_acl_account_finished_cb,
1349     dialog
1350   );
1351   if(request != NULL)
1352   {
1353     g_object_ref(request);
1354     priv-&gt;remove_acl_account_requests = g_slist_prepend(
1355       priv-&gt;remove_acl_account_requests,
1356       request
1357     );
1358   }
1359 }
1360 static gboolean
1361 inf_gtk_permissions_dialog_populate_popup(InfGtkPermissionsDialog* dialog,
1362                                           GtkMenu* menu)
1363 {
1364   InfGtkPermissionsDialogPrivate* priv;
1365   GtkWidget* item;
1366   InfBrowserIter root;
1367   InfAclMask perms;
1368   guint n_accounts;
1369   InfAclAccountId default_id;
1370   const InfAclAccount* local_account;
1371   const InfAclAccount** accounts;
1372   gpointer account_id_ptr;
1373   InfAclAccountId account_id;
1374   GtkTreeSelection* selection;
1375   GtkTreeIter iter;
1376   priv = INF_GTK_PERMISSIONS_DIALOG_PRIVATE(dialog);
1377   g_assert(priv-&gt;popup_menu == NULL);
1378   inf_browser_get_root(priv-&gt;browser, &amp;root);
1379   inf_acl_mask_set1(&amp;perms, INF_ACL_CAN_REMOVE_ACCOUNT);
1380   local_account = inf_browser_get_acl_local_account(priv-&gt;browser);
1381   inf_browser_check_acl(
1382     priv-&gt;browser,
1383     &amp;root,
1384     local_account ? local_account-&gt;id : 0,
1385     &amp;perms,
1386     &amp;perms
1387   );
1388   if(!inf_acl_mask_has(&amp;perms, INF_ACL_CAN_REMOVE_ACCOUNT))
1389     return FALSE;
1390   selection = gtk_tree_view_get_selection(GTK_TREE_VIEW(priv-&gt;tree_view));
1391   if(!gtk_tree_selection_get_selected(selection, NULL, &amp;iter))
1392     return FALSE;
1393   gtk_tree_model_get(
1394     GTK_TREE_MODEL(priv-&gt;account_store),
1395     &amp;iter,
1396     INF_GTK_PERMISSIONS_DIALOG_COLUMN_ID,
1397     &amp;account_id_ptr,
1398     -1
1399   );
1400   account_id = INF_ACL_ACCOUNT_POINTER_TO_ID(account_id_ptr);
1401   default_id = inf_acl_account_id_from_string("default");
1402   if(account_id == 0 || account_id == default_id)
1403     return FALSE;
1404   item = gtk_menu_item_new_with_mnemonic(_("_Delete Account"));
1405   g_signal_connect(
1406     G_OBJECT(item),
1407     "activate",
1408     G_CALLBACK(inf_gtk_permissions_dialog_popup_delete_account_cb),
1409     dialog
1410   );
1411   gtk_widget_show(item);
1412   gtk_menu_shell_append(GTK_MENU_SHELL(menu), item);
1413   priv-&gt;popup_menu = menu;
1414   priv-&gt;popup_account = INF_ACL_ACCOUNT_POINTER_TO_ID(account_id);
1415   return TRUE;
1416 }
1417 static void
1418 inf_gtk_permissions_dialog_popup_menu_detach_func(GtkWidget* attach_widget,
1419                                                   GtkMenu* menu)
1420 {
1421 }
1422 static void
1423 inf_gtk_permissions_dialog_popup_menu_position_func(GtkMenu* menu,
1424                                                     gint* x,
1425                                                     gint* y,
1426                                                     gboolean* push_in,
1427                                                     gpointer user_data)
1428 {
1429   InfGtkPermissionsDialog* dialog;
1430   InfGtkPermissionsDialogPrivate* priv;
1431   GdkWindow* bin_window;
1432   GdkScreen* screen;
1433   GtkRequisition menu_req;
1434   GdkRectangle monitor;
1435   gint monitor_num;
1436   gint orig_x;
1437   gint orig_y;
1438   gint height;
1439   GtkTreeSelection* selection;
1440   GtkTreeModel* model;
1441   GtkTreeIter selected_iter;
1442   GtkTreePath* selected_path;
1443   GdkRectangle cell_area;
1444   dialog = INF_GTK_PERMISSIONS_DIALOG(user_data);
1445   priv = INF_GTK_PERMISSIONS_DIALOG_PRIVATE(dialog);
1446   bin_window = gtk_tree_view_get_bin_window(GTK_TREE_VIEW(priv-&gt;tree_view));
1447   gdk_window_get_origin(bin_window, &amp;orig_x, &amp;orig_y);
1448   screen = gtk_widget_get_screen(GTK_WIDGET(priv-&gt;tree_view));
1449   monitor_num = gdk_screen_get_monitor_at_window(screen, bin_window);
1450   if(monitor_num &lt; 0) monitor_num = 0;
1451   gtk_menu_set_monitor(menu, monitor_num);
1452   gdk_screen_get_monitor_geometry(screen, monitor_num, &amp;monitor);
1453   gtk_widget_get_preferred_size(GTK_WIDGET(menu), NULL, &amp;menu_req);
1454   height = gdk_window_get_height(bin_window);
1455   selection = gtk_tree_view_get_selection(GTK_TREE_VIEW(priv-&gt;tree_view));
1456   gtk_tree_selection_get_selected(selection, &amp;model, &amp;selected_iter);
1457   selected_path = gtk_tree_model_get_path(model, &amp;selected_iter);
1458   gtk_tree_view_get_cell_area(
1459     GTK_TREE_VIEW(priv-&gt;tree_view),
1460     selected_path,
1461     gtk_tree_view_get_column(GTK_TREE_VIEW(priv-&gt;tree_view), 0),
1462     &amp;cell_area
1463   );
1464   gtk_tree_path_free(selected_path);
1465   g_assert(cell_area.height &gt; 0);
1466   if(gtk_widget_get_direction(GTK_WIDGET(priv-&gt;tree_view)) ==
1467      GTK_TEXT_DIR_LTR)
1468   {
1469     *x = orig_x + cell_area.x + cell_area.width - menu_req.width;
1470   }
1471   else
1472   {
1473     *x = orig_x + cell_area.x;
1474   }
1475   *y = orig_y + cell_area.y + cell_area.height;
1476   if(*y &lt; orig_y)
1477     *y = orig_y;
1478   if(*y &gt; orig_y + height)
1479     *y = orig_y + height;
1480   if(*y + menu_req.height &gt; monitor.y + monitor.height)
1481     *y = monitor.y + monitor.height - menu_req.height;
1482   if(*y &lt; monitor.y)
1483     *y = monitor.y;
1484   *push_in = FALSE;
1485 }
1486 static void
1487 inf_gtk_permissions_dialog_popup_selection_done_cb(GtkMenu* menu,
1488                                                    gpointer user_data)
1489 {
1490   InfGtkPermissionsDialog* dialog;
1491   InfGtkPermissionsDialogPrivate* priv;
1492   dialog = INF_GTK_PERMISSIONS_DIALOG(user_data);
1493   priv = INF_GTK_PERMISSIONS_DIALOG_PRIVATE(dialog);
1494   g_assert(priv-&gt;popup_menu != NULL);
1495   priv-&gt;popup_menu = NULL;
1496   priv-&gt;popup_account = 0;
1497 }
1498 static gboolean
1499 inf_gtk_permissions_dialog_show_popup(InfGtkPermissionsDialog* dialog,
1500                                       guint button,                                       guint32 time)
1501 {
1502   InfGtkPermissionsDialogPrivate* priv;
1503   GtkWidget* menu;
1504   gboolean result;
1505   priv = INF_GTK_PERMISSIONS_DIALOG_PRIVATE(dialog);
1506   menu = gtk_menu_new();
1507   g_signal_connect(
1508     G_OBJECT(menu),
1509     "selection-done",
1510     G_CALLBACK(inf_gtk_permissions_dialog_popup_selection_done_cb),
1511     dialog
1512   );
1513   gtk_menu_attach_to_widget(
1514     GTK_MENU(menu),
1515     GTK_WIDGET(priv-&gt;tree_view),
1516     inf_gtk_permissions_dialog_popup_menu_detach_func
1517   );
1518   if(inf_gtk_permissions_dialog_populate_popup(dialog, GTK_MENU(menu)))
1519   {
1520     result = TRUE;
1521     if(button)
1522     {
1523       gtk_menu_popup(GTK_MENU(menu), NULL, NULL, NULL, NULL, button, time);
1524     }
1525     else
1526     {
1527       gtk_menu_popup(
1528         GTK_MENU(menu),
1529         NULL,
1530         NULL,
1531         inf_gtk_permissions_dialog_popup_menu_position_func,
1532         priv-&gt;tree_view,
1533         button,
1534         time
1535       );
1536       gtk_menu_shell_select_first(GTK_MENU_SHELL(menu), FALSE);
1537     }
1538   }
1539   else
1540   {
1541     result = FALSE;
1542     gtk_widget_destroy(menu);
1543   }
1544   return result;
1545 }
1546 static gboolean
1547 inf_gtk_permissions_dialog_button_press_event_cb(GtkWidget* treeview,
1548                                                  GdkEventButton* event,
1549                                                  gpointer user_data)
1550 {
1551   InfGtkPermissionsDialog* dialog;
1552   GtkTreePath* path;
1553   gboolean has_path;
1554   dialog = INF_GTK_PERMISSIONS_DIALOG(user_data);
1555   if(event-&gt;button == 3 &amp;&amp;
1556      event-&gt;window == gtk_tree_view_get_bin_window(GTK_TREE_VIEW(treeview)))
1557   {
1558     has_path = gtk_tree_view_get_path_at_pos(
1559       GTK_TREE_VIEW(treeview),
1560       event-&gt;x,
1561       event-&gt;y,
1562       &amp;path,
1563       NULL,
1564       NULL,
1565       NULL
1566     );
1567     if(has_path)
1568     {
1569       gtk_tree_selection_select_path(
1570         gtk_tree_view_get_selection(GTK_TREE_VIEW(treeview)),
1571         path
1572       );
1573       gtk_tree_path_free(path);
1574       return inf_gtk_permissions_dialog_show_popup(
1575         dialog,
1576         event-&gt;button,
1577         event-&gt;time
1578       );
1579     }
1580   }
1581   return FALSE;
1582 }
1583 static gboolean
1584 inf_gtk_permissions_dialog_key_press_event_cb(GtkWidget* treeview,
1585                                               GdkEventKey* event,
1586                                               gpointer user_data)
1587 {
1588   InfGtkPermissionsDialog* dialog;
1589   GtkTreeSelection* selection;
1590   GtkTreeIter iter;
1591   dialog = INF_GTK_PERMISSIONS_DIALOG(user_data);
1592   if(event-&gt;keyval == GDK_KEY_Menu)
1593   {
1594     selection = gtk_tree_view_get_selection(GTK_TREE_VIEW(treeview));
1595     if(gtk_tree_selection_get_selected(selection, NULL, &amp;iter))
1596     {
1597       return inf_gtk_permissions_dialog_show_popup(dialog, 0, event-&gt;time);
1598     }
1599   }
1600   return FALSE;
1601 }
1602 static void
1603 inf_gtk_permissions_dialog_name_data_func(GtkTreeViewColumn* column,
1604                                           GtkCellRenderer* cell,
1605                                           GtkTreeModel* model,
1606                                           GtkTreeIter* iter,
1607                                           gpointer user_data)
1608 {
1609   gpointer account_id_ptr;
1610   InfAclAccountId account_id;
1611   const gchar* account_id_str;
1612   InfAclAccountId default_id;
1613   gchar* account_name;
1614   gchar* str;
1615   gtk_tree_model_get(
1616     model,
1617     iter,
1618     INF_GTK_PERMISSIONS_DIALOG_COLUMN_ID, &amp;account_id_ptr,
1619     INF_GTK_PERMISSIONS_DIALOG_COLUMN_NAME, &amp;account_name,
1620     -1
1621   );
1622   account_id = INF_ACL_ACCOUNT_POINTER_TO_ID(account_id_ptr);
1623   account_id_str = inf_acl_account_id_to_string(account_id);
1624   if(account_name != NULL)
1625   {
1626     g_object_set(G_OBJECT(cell), "text", account_name, NULL);
1627   }
1628   else if(account_id_str != NULL)
1629   {
1630     str = g_strdup_printf("&lt;%s&gt;", account_id_str);
1631     g_object_set(G_OBJECT(cell), "text", str, NULL);
1632     g_free(str);
1633   }
1634   else
1635   {
1636     g_object_set(G_OBJECT(cell), "text", "", NULL);
1637   }
1638   default_id = inf_acl_account_id_from_string("default");
1639   if( (account_id == 0 || account_name == NULL) &amp;&amp; account_id != default_id)
1640     g_object_set(G_OBJECT(cell), "foreground", "red", NULL);
1641   else
1642     g_object_set(G_OBJECT(cell), "foreground-set", FALSE, NULL);
1643   g_free(account_name);
1644 }
1645 static void
1646 inf_gtk_permissions_dialog_query_acl_account_list_finished_cb(
1647   InfRequest* request,
1648   const InfRequestResult* res,
1649   const GError* error,
1650   gpointer user_data)
1651 {
1652   InfGtkPermissionsDialog* dialog;
1653   InfGtkPermissionsDialogPrivate* priv;
1654   const InfAclAccount* accounts;
1655   guint n_accounts;
1656   guint i;
1657   InfAclAccountId account_id;
1658   GtkTreeIter iter;
1659   dialog = INF_GTK_PERMISSIONS_DIALOG(user_data);
1660   priv = INF_GTK_PERMISSIONS_DIALOG_PRIVATE(dialog);
1661   priv-&gt;query_acl_account_list_request = NULL;
1662   priv-&gt;account_list_queried = TRUE;
1663   if(error != NULL)
1664   {
1665     if(error-&gt;domain != inf_directory_error_quark() ||
1666        error-&gt;code != INF_DIRECTORY_ERROR_OPERATION_UNSUPPORTED)
1667     {
1668       g_warning("Error while querying account list: %s\n", error-&gt;message);
1669     }
1670   }
1671   else
1672   {
1673     inf_request_result_get_query_acl_account_list(
1674       res,
1675       NULL,
1676       &amp;accounts,
1677       &amp;n_accounts,
1678       NULL
1679     );
1680     for(i = 0; i &lt; n_accounts; ++i)
1681     {
1682       if(accounts[i].name != NULL)
1683       {
1684         account_id = accounts[i].id;
1685         if(inf_gtk_permissions_dialog_find_account(dialog, account_id, &amp;iter))
1686         {
1687           gtk_list_store_set(
1688             GTK_LIST_STORE(priv-&gt;account_store),
1689             &amp;iter,
1690             INF_GTK_PERMISSIONS_DIALOG_COLUMN_NAME,
1691             accounts[i].name,
1692             -1
1693           );
1694         }
1695       }
1696     }
1697     for(i = 0; i &lt; priv-&gt;n_accounts; ++i)
1698       g_free(priv-&gt;accounts[i].name);
1699     priv-&gt;accounts = g_realloc(
1700       priv-&gt;accounts,
1701       n_accounts * sizeof(InfAclAccount)
1702     );
1703     for(i = 0; i &lt; n_accounts; ++i)
1704     {
1705       priv-&gt;accounts[i].id = accounts[i].id;
1706       priv-&gt;accounts[i].name = g_strdup(accounts[i].name);
1707     }
1708     priv-&gt;n_accounts = n_accounts;
1709   }
1710 }
1711 static void
1712 inf_gtk_permissions_dialog_query_acl_finished_cb(InfRequest* request,
1713                                                  const InfRequestResult* res,
1714                                                  const GError* error,
1715                                                  gpointer user_data)
1716 {
1717   InfGtkPermissionsDialog* dialog;
1718   InfGtkPermissionsDialogPrivate* priv;
1719   dialog = INF_GTK_PERMISSIONS_DIALOG(user_data);
1720   priv = INF_GTK_PERMISSIONS_DIALOG_PRIVATE(dialog);
1721   priv-&gt;query_acl_request = NULL;
1722   inf_gtk_permissions_dialog_update(dialog, error);
1723 }
1724 static void
1725 inf_gtk_permissions_dialog_update(InfGtkPermissionsDialog* dialog,
1726                                   const GError* error)
1727 {
1728   InfGtkPermissionsDialogPrivate* priv;
1729   gchar* path;
1730   gchar* title;
1731   InfAclMask perms;
1732   GArray* accounts;
1733   const InfAclAccount* local_account;
1734   const InfAclSheetSet* sheet_set;
1735   gboolean has_default;
1736   InfAclAccountId default_id;
1737   guint i;
1738   GtkTreeSelection* selection;
1739   GtkTreeIter selected_iter;
1740   gpointer selected_id_ptr;
1741   GtkTreePath* selected_path;
1742   InfAclAccountId selected_id;
1743   gboolean has_selected;
1744   GSList* item;
1745   InfGtkPermissionsDialogPendingSheet* pending;
1746   GtkTreePath* pending_path;
1747   const gchar* query_acl_str;
1748   const gchar* set_acl_str;
1749   gchar* error_str;
1750   gchar* str;
1751   priv = INF_GTK_PERMISSIONS_DIALOG_PRIVATE(dialog);
1752   if(priv-&gt;browser == NULL)
1753   {
1754     gtk_list_store_clear(priv-&gt;account_store);
1755     gtk_label_set_text(GTK_LABEL(priv-&gt;status_text), _("No node selected"));
1756     return;
1757   }
1758   path = inf_browser_get_path(priv-&gt;browser, &amp;priv-&gt;browser_iter);
1759   title = g_strdup_printf(_("Permissions for %s"), path);
1760   gtk_window_set_title(GTK_WINDOW(dialog), title);
1761   g_free(path);
1762   g_free(title);
1763   inf_acl_mask_set1(&amp;perms, INF_ACL_CAN_QUERY_ACCOUNT_LIST);
1764   inf_acl_mask_or1(&amp;perms, INF_ACL_CAN_QUERY_ACL);
1765   inf_acl_mask_or1(&amp;perms, INF_ACL_CAN_SET_ACL);
1766   local_account = inf_browser_get_acl_local_account(priv-&gt;browser);
1767   inf_browser_check_acl(
1768     priv-&gt;browser,
1769     &amp;priv-&gt;browser_iter,
1770     local_account ? local_account-&gt;id : 0,
1771     &amp;perms,
1772     &amp;perms
1773   );
1774   if(priv-&gt;query_acl_account_list_request == NULL &amp;&amp;
1775      priv-&gt;account_list_queried == FALSE)
1776   {
1777     if(inf_acl_mask_has(&amp;perms, INF_ACL_CAN_QUERY_ACCOUNT_LIST) &amp;&amp;
1778        inf_acl_mask_has(&amp;perms, INF_ACL_CAN_SET_ACL))
1779     {
1780       priv-&gt;query_acl_account_list_request = inf_browser_get_pending_request(
1781         priv-&gt;browser,
1782         NULL,
1783         "query-acl-account-list"
1784       );
1785       if(priv-&gt;query_acl_account_list_request == NULL)
1786       {
1787         priv-&gt;query_acl_account_list_request =
1788           inf_browser_query_acl_account_list(
1789             priv-&gt;browser,
1790             inf_gtk_permissions_dialog_query_acl_account_list_finished_cb,
1791             dialog
1792           );
1793       }
1794       else
1795       {
1796         g_signal_connect(
1797           G_OBJECT(priv-&gt;query_acl_account_list_request),
1798           "finished",
1799           G_CALLBACK(
1800             inf_gtk_permissions_dialog_query_acl_account_list_finished_cb
1801           ),
1802           dialog
1803         );
1804       }
1805     }
1806   }
1807   if(!inf_browser_has_acl(priv-&gt;browser, &amp;priv-&gt;browser_iter, 0))
1808   {
1809     if(inf_acl_mask_has(&amp;perms, INF_ACL_CAN_QUERY_ACL) &amp;&amp;
1810        priv-&gt;query_acl_request == NULL &amp;&amp; error == NULL)
1811     {
1812       priv-&gt;query_acl_request = inf_browser_get_pending_request(
1813         priv-&gt;browser,
1814         &amp;priv-&gt;browser_iter,
1815         "query-acl"
1816       );
1817       if(priv-&gt;query_acl_request == NULL)
1818       {
1819         priv-&gt;query_acl_request = inf_browser_query_acl(
1820           priv-&gt;browser,
1821           &amp;priv-&gt;browser_iter,
1822           inf_gtk_permissions_dialog_query_acl_finished_cb,
1823           dialog
1824         );
1825       }
1826       else
1827       {
1828         g_signal_connect(
1829           G_OBJECT(priv-&gt;query_acl_request),
1830           "finished",
1831           G_CALLBACK(inf_gtk_permissions_dialog_query_acl_finished_cb),
1832           dialog
1833         );
1834       }
1835     }
1836   }
1837   accounts = g_array_new(FALSE, FALSE, sizeof(InfAclAccountId));
1838   sheet_set = inf_browser_get_acl(priv-&gt;browser, &amp;priv-&gt;browser_iter);
1839   default_id = inf_acl_account_id_from_string("default");
1840   selected_id = 0;
1841   selected_path = NULL;
1842   selection = gtk_tree_view_get_selection(GTK_TREE_VIEW(priv-&gt;tree_view));
1843   if(gtk_tree_selection_get_selected(selection, NULL, &amp;selected_iter))
1844   {
1845     gtk_tree_model_get(
1846       GTK_TREE_MODEL(priv-&gt;account_store),
1847       &amp;selected_iter,
1848       INF_GTK_PERMISSIONS_DIALOG_COLUMN_ID,
1849       &amp;selected_id_ptr,
1850       -1
1851     );
1852     selected_id = INF_ACL_ACCOUNT_POINTER_TO_ID(selected_id_ptr);
1853     selected_path = gtk_tree_model_get_path(
1854       GTK_TREE_MODEL(priv-&gt;account_store),
1855       &amp;selected_iter
1856     );
1857   }
1858   has_default = FALSE;
1859   has_selected = FALSE;
1860   if(sheet_set != NULL)
1861   {
1862     for(i = 0; i &lt; sheet_set-&gt;n_sheets; ++i)
1863     {
1864       g_array_append_val(accounts, sheet_set-&gt;sheets[i].account);
1865       if(sheet_set-&gt;sheets[i].account == default_id)
1866         has_default = TRUE;
1867       if(sheet_set-&gt;sheets[i].account == selected_id)
1868         has_selected = TRUE;
1869     }
1870   }
1871   if(has_default == FALSE)
1872     g_array_append_val(accounts, default_id);
1873   if(selected_id != 0 &amp;&amp; selected_id != default_id &amp;&amp; has_selected == FALSE)
1874     g_array_append_val(accounts, selected_id);
1875   for(item = priv-&gt;pending_sheets; item != NULL; item = item-&gt;next)
1876   {
1877     pending = (InfGtkPermissionsDialogPendingSheet*)item-&gt;data;
1878     if(inf_acl_mask_empty(&amp;pending-&gt;sheet.mask))
1879     {
1880       pending_path = gtk_tree_row_reference_get_path(pending-&gt;row);
1881       g_assert(pending_path != NULL);
1882       if(selected_path == NULL ||
1883          gtk_tree_path_compare(pending_path, selected_path) != 0)
1884       {
1885         gtk_tree_path_free(pending_path);
1886         inf_gtk_permissions_dialog_remove_pending_sheet(dialog, pending);
1887         break;
1888       }
1889       gtk_tree_path_free(pending_path);
1890     }
1891   }
1892   if(selected_path != NULL)
1893     gtk_tree_path_free(selected_path);
1894   inf_gtk_permissions_dialog_fill_account_list(
1895     dialog,
1896     (InfAclAccountId*)accounts-&gt;data,
1897     accounts-&gt;len
1898   );
1899   if(!inf_acl_mask_has(&amp;perms, INF_ACL_CAN_SET_ACL) ||
1900      !inf_browser_has_acl(priv-&gt;browser, &amp;priv-&gt;browser_iter, 0))
1901   {
1902     inf_gtk_acl_sheet_view_set_editable(
1903       INF_GTK_ACL_SHEET_VIEW(priv-&gt;sheet_view),
1904       FALSE
1905     );
1906     gtk_widget_set_sensitive(priv-&gt;add_button, FALSE);
1907     gtk_widget_set_sensitive(priv-&gt;remove_button, FALSE);
1908     set_acl_str = _("Permission is &lt;b&gt;not granted&lt;/b&gt; to modify the permission list. It is read-only.");
1909   }
1910   else
1911   {
1912     inf_gtk_acl_sheet_view_set_editable(
1913       INF_GTK_ACL_SHEET_VIEW(priv-&gt;sheet_view),
1914       TRUE
1915     );
1916     if(priv-&gt;accounts == NULL || accounts-&gt;len &lt; priv-&gt;n_accounts)
1917       gtk_widget_set_sensitive(priv-&gt;add_button, TRUE);
1918     else
1919       gtk_widget_set_sensitive(priv-&gt;add_button, FALSE);
1920     if(selected_id != default_id)
1921       gtk_widget_set_sensitive(priv-&gt;remove_button, TRUE);
1922     else
1923       gtk_widget_set_sensitive(priv-&gt;remove_button, FALSE);
1924     set_acl_str = _("Permission is &lt;b&gt;granted&lt;/b&gt; to modify the permission list.");
1925   }
1926   g_array_free(accounts, TRUE);
1927   error_str = NULL;
1928   if(error != NULL)
1929   {
1930     error_str = g_markup_printf_escaped(
1931       _("&lt;b&gt;Server Error:&lt;/b&gt; %s"),
1932       error-&gt;message
1933     );
1934     query_acl_str = error_str;
1935   }
1936   else if(priv-&gt;query_acl_request != NULL)
1937   {
1938     query_acl_str = _("Querying current permissions for "
1939                       "this node from the server...");
1940   }
1941   else if(!inf_acl_mask_has(&amp;perms, INF_ACL_CAN_QUERY_ACL) &amp;&amp;
1942           !inf_browser_has_acl(priv-&gt;browser, &amp;priv-&gt;browser_iter, 0))
1943   {
1944     query_acl_str = _("Permission is &lt;b&gt;not granted&lt;/b&gt; to query the "
1945                       "permission list for this node from the server. "
1946                       "Showing only default permissions and permissions "
1947                       "for the own account.");
1948   }
1949   else
1950   {
1951     query_acl_str = _("Permissions are &lt;b&gt;granted&lt;/b&gt; to query the full "
1952                       "permission list from the server. "
1953                       "Showing all permissions.");
1954   }
1955   str = g_strdup_printf("%s\n\n%s", query_acl_str, set_acl_str);
1956   g_free(error_str);
1957   gtk_label_set_markup(GTK_LABEL(priv-&gt;status_text), str);
1958   g_free(str);
1959 }
1960 static void
1961 inf_gtk_permissions_dialog_register(InfGtkPermissionsDialog* dialog)
1962 {
1963   InfGtkPermissionsDialogPrivate* priv;
1964   priv = INF_GTK_PERMISSIONS_DIALOG_PRIVATE(dialog);
1965   g_assert(priv-&gt;browser != NULL);
1966   g_signal_connect(
1967     priv-&gt;browser,
1968     "node-removed",
1969     G_CALLBACK(inf_gtk_permissions_dialog_node_removed_cb),
1970     dialog
1971   );
1972   g_signal_connect(
1973     priv-&gt;browser,
1974     "acl-account-added",
1975     G_CALLBACK(inf_gtk_permissions_dialog_acl_account_added_cb),
1976     dialog
1977   );
1978   g_signal_connect(
1979     priv-&gt;browser,
1980     "acl-account-removed",
1981     G_CALLBACK(inf_gtk_permissions_dialog_acl_account_removed_cb),
1982     dialog
1983   );
1984   g_signal_connect(
1985     priv-&gt;browser,
1986     "acl-changed",
1987     G_CALLBACK(inf_gtk_permissions_dialog_acl_changed_cb),
1988     dialog
1989   );
1990 }
1991 static void
1992 inf_gtk_permissions_dialog_unregister(InfGtkPermissionsDialog* dialog)
1993 {
1994   InfGtkPermissionsDialogPrivate* priv;
1995   priv = INF_GTK_PERMISSIONS_DIALOG_PRIVATE(dialog);
1996   g_assert(priv-&gt;browser != NULL);
1997   inf_signal_handlers_disconnect_by_func(
1998     priv-&gt;browser,
1999     G_CALLBACK(inf_gtk_permissions_dialog_node_removed_cb),
2000     dialog
2001   );
2002   inf_signal_handlers_disconnect_by_func(
2003     priv-&gt;browser,
2004     G_CALLBACK(inf_gtk_permissions_dialog_acl_account_added_cb),
2005     dialog
2006   );
2007   inf_signal_handlers_disconnect_by_func(
2008     priv-&gt;browser,
2009     G_CALLBACK(inf_gtk_permissions_dialog_acl_account_removed_cb),
2010     dialog
2011   );
2012   inf_signal_handlers_disconnect_by_func(
2013     priv-&gt;browser,
2014     G_CALLBACK(inf_gtk_permissions_dialog_acl_changed_cb),
2015     dialog
2016   );
2017 }
2018 static void
2019 inf_gtk_permissions_dialog_init(InfGtkPermissionsDialog* dialog)
2020 {
2021   InfGtkPermissionsDialogPrivate* priv;
2022   priv = INF_GTK_PERMISSIONS_DIALOG_PRIVATE(dialog);
2023   priv-&gt;query_acl_account_list_request = NULL;
2024   priv-&gt;account_list_queried = FALSE;
2025   priv-&gt;accounts = NULL;
2026   priv-&gt;n_accounts = 0;
2027   priv-&gt;query_acl_request = NULL;
2028   priv-&gt;set_acl_requests = NULL;
2029   priv-&gt;remove_acl_account_requests = NULL;
2030   priv-&gt;lookup_acl_account_requests = NULL;
2031   priv-&gt;pending_sheets = NULL;
2032   priv-&gt;popup_menu = NULL;
2033   priv-&gt;popup_account = 0;
2034   gtk_widget_init_template(GTK_WIDGET(dialog));
2035   gtk_tree_sortable_set_sort_column_id(
2036     GTK_TREE_SORTABLE(priv-&gt;account_store),
2037     INF_GTK_PERMISSIONS_DIALOG_COLUMN_NAME,
2038     GTK_SORT_ASCENDING
2039   );
2040   gtk_tree_sortable_set_sort_func(
2041     GTK_TREE_SORTABLE(priv-&gt;account_store),
2042     INF_GTK_PERMISSIONS_DIALOG_COLUMN_NAME,
2043     inf_gtk_permissions_dialog_account_sort_func,
2044     dialog,
2045     NULL
2046   );
2047   gtk_tree_view_column_set_cell_data_func(
2048     gtk_tree_view_get_column(GTK_TREE_VIEW(priv-&gt;tree_view), 0),
2049     priv-&gt;renderer,
2050     inf_gtk_permissions_dialog_name_data_func,
2051     NULL,
2052     NULL
2053   );
2054 }
2055 static void
2056 inf_gtk_permissions_dialog_constructed(GObject* object)
2057 {
2058   InfGtkPermissionsDialogPrivate* priv;
2059   G_OBJECT_CLASS(inf_gtk_permissions_dialog_parent_class)-&gt;constructed(
2060     object
2061   );
2062   priv = INF_GTK_PERMISSIONS_DIALOG_PRIVATE(object);
2063   inf_gtk_permissions_dialog_update(
2064     INF_GTK_PERMISSIONS_DIALOG(object),
2065     NULL
2066   );
2067 }
2068 static void
2069 inf_gtk_permissions_dialog_dispose(GObject* object)
2070 {
2071   InfGtkPermissionsDialog* dialog;
2072   InfGtkPermissionsDialogPrivate* priv;
2073   dialog = INF_GTK_PERMISSIONS_DIALOG(object);
2074   priv = INF_GTK_PERMISSIONS_DIALOG_PRIVATE(dialog);
2075   while(priv-&gt;remove_acl_account_requests != NULL)
2076   {
2077     inf_gtk_permissions_dialog_remove_remove_acl_account_request(
2078       dialog,
2079       priv-&gt;remove_acl_account_requests-&gt;data
2080     );
2081   }
2082   while(priv-&gt;lookup_acl_account_requests != NULL)
2083   {
2084     inf_gtk_permissions_dialog_remove_lookup_acl_accounts_request(
2085       dialog,
2086       priv-&gt;lookup_acl_account_requests-&gt;data
2087     );
2088   }
2089   if(priv-&gt;browser != NULL)
2090   {
2091     inf_gtk_permissions_dialog_set_node(dialog, NULL, NULL);
2092   }
2093   g_assert(priv-&gt;set_acl_requests == NULL);
2094   g_assert(priv-&gt;pending_sheets == NULL);
2095   G_OBJECT_CLASS(inf_gtk_permissions_dialog_parent_class)-&gt;dispose(object);
2096 }
2097 static void
2098 inf_gtk_permissions_dialog_finalize(GObject* object)
2099 {
2100   InfGtkPermissionsDialog* dialog;
2101   InfGtkPermissionsDialogPrivate* priv;
2102   guint i;
2103 <a name="2"></a>  dialog = INF_GTK_PERMISSIONS_DIALOG(object);
2104   priv = INF_GTK_PERMISSIONS_DIALOG_PRIVATE(dialog);
2105 <font color="#980517"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>  for(i = 0; i &lt; priv-&gt;n_accounts; ++i)
2106     g_free(priv-&gt;accounts[i].name);
2107   g_free(priv-&gt;accounts);
2108   G_OBJECT_CLASS(inf_gtk_permissions_dialog_parent_class)-&gt;finalize(object);
2109 }
2110 static void
2111 inf_gtk_permissions_dialog_set_property(GObject* object,
2112                                         guint prop_id,
2113                                         const GValue* value,
2114                                         GParamSpec* pspec)
2115 {
2116   InfGtkPermissionsDialog* dialog;
2117   InfGtkPermissionsDialogPrivate* priv;
2118   dialog = INF_GTK_PERMISSIONS_DIALOG(object);
2119   priv = INF_GTK_PERMISSIONS_DIALOG_PRIVATE(dialog);
2120   switch(prop_id)
2121   {
2122   case PROP_BROWSER:
2123     g_assert(priv-&gt;browser == NULL);     priv-&gt;browser = INF_BROWSER(g_value_dup_object(value));
2124     if(priv-&gt;browser != NULL)
2125       inf_gtk_permissions_dialog_register(dialog);
2126 <a name="0"></a>    break;
2127   case PROP_BROWSER_ITER:
2128     priv-&gt;browser_iter = *(InfBrowserIter*)g_value_get_boxed(value);
2129 <font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>    break;
2130   default:
2131     G_OBJECT_WARN_INVALID_PROPERTY_ID(object, prop_id, pspec);
2132     break;
2133   }
2134 }
2135 static void
2136 inf_gtk_permissions_dialog_get_property(GObject* object,
2137                                         guint prop_id,
2138                                         GValue* value,
2139                                         GParamSpec* pspec)
2140 {
2141   InfGtkPermissionsDialog* dialog;
2142   InfGtkPermissionsDialogPrivate* priv;
2143   dialog = INF_GTK_PERMISSIONS_DIALOG(object);
2144   priv = INF_GTK_PERMISSIONS_DIALOG_PRIVATE(dialog);
2145   switch(prop_id)
2146   {
2147   case PROP_BROWSER:
2148     g_value_set_object(value, priv-&gt;browser);
2149     break;
2150   case PROP_BROWSER_ITER:
2151     g_value_set_boxed(value, &amp;priv-&gt;browser_iter);
2152     break;</b></font>
2153   default:
2154     G_OBJECT_WARN_INVALID_PROPERTY_ID(object, prop_id, pspec);
2155     break;
2156   }
2157 }
2158 static void
2159 inf_gtk_permissions_dialog_class_init(
2160   InfGtkPermissionsDialogClass* permissions_dialog_class)
2161 {
2162   GObjectClass* object_class;
2163   object_class = G_OBJECT_CLASS(permissions_dialog_class);
2164   object_class-&gt;constructed = inf_gtk_permissions_dialog_constructed;
2165   object_class-&gt;dispose = inf_gtk_permissions_dialog_dispose;
2166   object_class-&gt;finalize = inf_gtk_permissions_dialog_finalize;
2167   object_class-&gt;set_property = inf_gtk_permissions_dialog_set_property;
2168   object_class-&gt;get_property = inf_gtk_permissions_dialog_get_property;
2169   gtk_widget_class_set_template_from_resource(
2170     GTK_WIDGET_CLASS(object_class),
2171     "/de/0x539/libinfgtk/ui/infgtkpermissionsdialog.ui"
2172   );
2173   gtk_widget_class_bind_template_child_private(
2174     GTK_WIDGET_CLASS(object_class),
2175     InfGtkPermissionsDialog,
2176     account_store
2177   );
2178   gtk_widget_class_bind_template_child_private(
2179     GTK_WIDGET_CLASS(object_class),
2180     InfGtkPermissionsDialog,
2181     status_text
2182   );
2183   gtk_widget_class_bind_template_child_private(
2184     GTK_WIDGET_CLASS(object_class),
2185     InfGtkPermissionsDialog,
2186     tree_view
2187   );
2188   gtk_widget_class_bind_template_child_private(
2189     GTK_WIDGET_CLASS(object_class),
2190     InfGtkPermissionsDialog,
2191     sheet_view
2192   );
2193   gtk_widget_class_bind_template_child_private(
2194     GTK_WIDGET_CLASS(object_class),
2195     InfGtkPermissionsDialog,
2196     add_button
2197   );
2198   gtk_widget_class_bind_template_child_private(
2199     GTK_WIDGET_CLASS(object_class),
2200     InfGtkPermissionsDialog,
2201     remove_button
2202   );
2203   gtk_widget_class_bind_template_child_private(
2204     GTK_WIDGET_CLASS(object_class),
2205     InfGtkPermissionsDialog,
2206     renderer
2207   );
2208   gtk_widget_class_bind_template_callback(
2209     GTK_WIDGET_CLASS(object_class),
2210     inf_gtk_permissions_dialog_key_press_event_cb
2211   );
2212   gtk_widget_class_bind_template_callback(
2213     GTK_WIDGET_CLASS(object_class),
2214     inf_gtk_permissions_dialog_button_press_event_cb
2215   );
2216   gtk_widget_class_bind_template_callback(
2217     GTK_WIDGET_CLASS(object_class),
2218     inf_gtk_permissions_dialog_selection_changed_cb
2219   );
2220   gtk_widget_class_bind_template_callback(
2221     GTK_WIDGET_CLASS(object_class),
2222     inf_gtk_permissions_dialog_renderer_editing_started_cb
2223   );
2224   gtk_widget_class_bind_template_callback(
2225     GTK_WIDGET_CLASS(object_class),
2226     inf_gtk_permissions_dialog_renderer_editing_canceled_cb
2227   );
2228   gtk_widget_class_bind_template_callback(
2229     GTK_WIDGET_CLASS(object_class),
2230     inf_gtk_permissions_dialog_renderer_edited_cb
2231   );
2232   gtk_widget_class_bind_template_callback(
2233     GTK_WIDGET_CLASS(object_class),
2234     inf_gtk_permissions_dialog_renderer_changed_cb
2235   );
2236   gtk_widget_class_bind_template_callback(
2237     GTK_WIDGET_CLASS(object_class),
2238     inf_gtk_permissions_dialog_add_clicked_cb
2239   );
2240   gtk_widget_class_bind_template_callback(
2241     GTK_WIDGET_CLASS(object_class),
2242     inf_gtk_permissions_dialog_remove_clicked_cb
2243   );
2244   gtk_widget_class_bind_template_callback(
2245     GTK_WIDGET_CLASS(object_class),
2246     inf_gtk_permissions_dialog_sheet_changed_cb
2247   );
2248   g_object_class_install_property(
2249     object_class,
2250     PROP_BROWSER,
2251     g_param_spec_object(
2252       "browser",
2253       "Browser",
2254       "The browser with the node for which to show the permissions",
2255       INF_TYPE_BROWSER,
2256       G_PARAM_READWRITE | G_PARAM_CONSTRUCT_ONLY
2257     )
2258   );
2259   g_object_class_install_property(
2260     object_class,
2261     PROP_BROWSER_ITER,
2262     g_param_spec_boxed(
2263       "browser-iter",
2264       "Browser Iter",
2265       "An iterator pointing to the node inside the browser for which to show "
2266       "the permissions",
2267       INF_TYPE_BROWSER_ITER,
2268       G_PARAM_READWRITE | G_PARAM_CONSTRUCT_ONLY
2269     )
2270   );
2271 }
2272 InfGtkPermissionsDialog*
2273 inf_gtk_permissions_dialog_new(GtkWindow* parent,
2274                                GtkDialogFlags dialog_flags,
2275                                InfBrowser* browser,
2276                                const InfBrowserIter* iter)
2277 {
2278   GObject* object;
2279   g_return_val_if_fail(parent == NULL || GTK_IS_WINDOW(parent), NULL);
2280   g_return_val_if_fail(browser == NULL || INF_IS_BROWSER(browser), NULL);
2281   g_return_val_if_fail(browser == NULL || iter != NULL, NULL);
2282   object = g_object_new(
2283     INF_GTK_TYPE_PERMISSIONS_DIALOG,
2284     "browser", browser,
2285     "browser-iter", iter,
2286     NULL
2287   );
2288   if(dialog_flags &amp; GTK_DIALOG_MODAL)
2289     gtk_window_set_modal(GTK_WINDOW(object), TRUE);
2290   if(dialog_flags &amp; GTK_DIALOG_DESTROY_WITH_PARENT)
2291     gtk_window_set_destroy_with_parent(GTK_WINDOW(object), TRUE);
2292   gtk_window_set_transient_for(GTK_WINDOW(object), parent);
2293   return INF_GTK_PERMISSIONS_DIALOG(object);
2294 }
2295 void
2296 inf_gtk_permissions_dialog_set_node(InfGtkPermissionsDialog* dialog,
2297                                     InfBrowser* browser,
2298                                     const InfBrowserIter* iter)
2299 {
2300   InfGtkPermissionsDialogPrivate* priv;
2301   GSList* item;
2302   guint i;
2303   g_return_if_fail(INF_GTK_IS_PERMISSIONS_DIALOG(dialog));
2304   g_return_if_fail(browser == NULL || INF_IS_BROWSER(browser));
2305   g_return_if_fail((browser == NULL) == (iter == NULL));
2306   priv = INF_GTK_PERMISSIONS_DIALOG_PRIVATE(dialog);
2307   if(priv-&gt;popup_menu != NULL)
2308     gtk_menu_popdown(priv-&gt;popup_menu);
2309   if(priv-&gt;browser != NULL)
2310   {
2311     if(priv-&gt;query_acl_account_list_request != NULL)
2312     {
2313       inf_signal_handlers_disconnect_by_func(
2314         priv-&gt;query_acl_account_list_request,
2315         G_CALLBACK(
2316           inf_gtk_permissions_dialog_query_acl_account_list_finished_cb
2317         ),
2318         dialog
2319       );
2320       priv-&gt;query_acl_account_list_request = NULL;
2321     }
2322     if(priv-&gt;query_acl_request != NULL)
2323     {
2324       inf_signal_handlers_disconnect_by_func(
2325         priv-&gt;query_acl_request,
2326         G_CALLBACK(inf_gtk_permissions_dialog_query_acl_finished_cb),
2327         dialog
2328       );
2329       priv-&gt;query_acl_request = NULL;
2330     }
2331     for(item = priv-&gt;set_acl_requests; item != NULL; item = item-&gt;next)
2332     {
2333       inf_signal_handlers_disconnect_by_func(
2334         G_OBJECT(item-&gt;data),
2335         G_CALLBACK(inf_gtk_permissions_dialog_set_acl_finished_cb),
2336         dialog
2337       );
2338       g_object_unref(item-&gt;data);
2339     }
2340     g_slist_free(priv-&gt;set_acl_requests);
2341     priv-&gt;set_acl_requests = NULL;
2342     while(priv-&gt;pending_sheets != NULL)
2343     {
2344       inf_gtk_permissions_dialog_remove_pending_sheet(
2345         dialog,
2346         priv-&gt;pending_sheets-&gt;data
2347       );
2348     }
2349   }
2350   for(i = 0; i &lt; priv-&gt;n_accounts; ++i)
2351     g_free(priv-&gt;accounts[i].name);
2352   g_free(priv-&gt;accounts);
2353   priv-&gt;accounts = NULL;
2354   priv-&gt;n_accounts = 0;
2355   inf_signal_handlers_block_by_func(
2356     gtk_tree_view_get_selection(GTK_TREE_VIEW(priv-&gt;tree_view)),
2357     G_CALLBACK(inf_gtk_permissions_dialog_selection_changed_cb),
2358     dialog
2359   );
2360   gtk_list_store_clear(priv-&gt;account_store);
2361   inf_signal_handlers_unblock_by_func(
2362     gtk_tree_view_get_selection(GTK_TREE_VIEW(priv-&gt;tree_view)),
2363     G_CALLBACK(inf_gtk_permissions_dialog_selection_changed_cb),
2364     dialog
2365   );
2366   if(priv-&gt;browser != browser)
2367   {
2368     if(priv-&gt;browser != NULL)
2369     {
2370       inf_gtk_permissions_dialog_unregister(dialog);
2371       g_object_unref(priv-&gt;browser);
2372     }
2373     priv-&gt;browser = browser;
2374     if(iter != NULL)
2375       priv-&gt;browser_iter = *iter;
2376     if(priv-&gt;browser != NULL)
2377     {
2378       g_object_ref(priv-&gt;browser);
2379       inf_gtk_permissions_dialog_register(dialog);
2380     }
2381     g_object_notify(G_OBJECT(dialog), "browser");
2382     g_object_notify(G_OBJECT(dialog), "browser-iter");
2383   }
2384   inf_gtk_permissions_dialog_update(dialog, NULL);
2385 }
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
