
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 2.3564064801178204%, Tokens: 8, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>libtomcrypt-MDEwOlJlcG9zaXRvcnk3NzcwMTE=-flat-openssl-enc.c</h3>
            <pre><code>1  #include <tomcrypt.h>
2  #ifndef LTC_RIJNDAEL
3  #error Cannot compile this demo; Rijndael (AES) required
4  #endif
5  #ifndef LTC_CBC_MODE
6  #error Cannot compile this demo; CBC mode required
7  #endif
8  #ifndef LTC_PKCS_5
9  #error Cannot compile this demo; PKCS5 required
10  #endif
11  #ifndef LTC_RNG_GET_BYTES
12  #error Cannot compile this demo; random generator required
13  #endif
14  #ifndef LTC_MD5
15  #error Cannot compile this demo; MD5 required
16  #endif
17  #define OPENSSL_ITERATIONS 1
18  #define KEY_LENGTH (256>>3)
19  #define IV_LENGTH (128>>3)
20  #define SALT_LENGTH 8
21  static char salt_header[] = { 'S', 'a', 'l', 't', 'e', 'd', '_', '_' };
22  #include <errno.h>
23  #include <stdio.h>
24  #include <string.h>
25  union paddable {
26     unsigned char unpad[1024];
27     unsigned char pad[1024+MAXBLOCKSIZE];
28  };
29  void barf(const char *pname, const char *err)
30  {
31     printf("Usage: %s <enc|dec> infile outfile passphrase [salt]\n", pname);
32     printf("\n");
33     printf("       # encrypts infile->outfile, random salt\n");
34     printf("       %s enc infile outfile \"passphrase\"\n", pname);
35     printf("\n");
36     printf("       # encrypts infile->outfile, salt from cmdline\n");
37     printf("       %s enc infile outfile pass 0123456789abcdef\n", pname);
38     printf("\n");
39     printf("       # decrypts infile->outfile, pulls salt from infile\n");
40     printf("       %s dec infile outfile pass\n", pname);
41     printf("\n");
42     printf("       # decrypts infile->outfile, salt specified\n");
43     printf("       # (don't try to read the salt from infile)\n");
44     printf("       %s dec infile outfile pass 0123456789abcdef"
45            "\n", pname);
46     printf("\n");
47     printf("Application Error: %s\n", err);
48     if(errno)
49        perror("     System Error");
50     exit(-1);
51  }
52  int parse_hex_salt(unsigned char *in, unsigned char *out)
53  {
54     int idx;
55     for(idx=0; idx<SALT_LENGTH; idx++)
56        if(sscanf((char*)in+idx*2, "%02hhx", out+idx) != 1)
57           return CRYPT_ERROR;
58     return CRYPT_OK;
59  }
60  int parse_openssl_header(FILE *in, unsigned char *out)
61  {
62     unsigned char tmp[SALT_LENGTH];
63     if(fread(tmp, 1, sizeof(tmp), in) != sizeof(tmp))
64        return CRYPT_ERROR;
65     if(memcmp(tmp, salt_header, sizeof(tmp)))
66        return CRYPT_ERROR;
67     if(fread(tmp, 1, sizeof(tmp), in) != sizeof(tmp))
68        return CRYPT_ERROR;
69     memcpy(out, tmp, sizeof(tmp));
70     return CRYPT_OK;
71  }
72  void dump_bytes(unsigned char *in, unsigned long len)
73  {
74     unsigned long idx;
75     for(idx=0; idx<len; idx++)
76        printf("%02hhX", *(in+idx));
77  }
78  static size_t s_pkcs7_pad(union paddable *buf, size_t nb, int block_length,
79                   int is_padding)
80  {
81     unsigned long length;
82     if(is_padding) {
83        length = sizeof(buf->pad);
84        if (padding_pad(buf->pad, nb, &length, block_length) != CRYPT_OK)
85           return 0;
86        return length;
87     } else {
88        length = nb;
89        if (padding_depad(buf->pad, &length, 0) != CRYPT_OK)
90           return 0;
91        return length;
92     }
93  }
94  int do_crypt(FILE *infd, FILE *outfd, unsigned char *key, unsigned char *iv,
95               int encrypt)
96  {
97     union paddable inbuf, outbuf;
98     int cipher, ret;
99     symmetric_CBC cbc;
100     size_t nb;
101     cipher = register_cipher(&aes_desc);
102     if(cipher == -1)
103        return CRYPT_INVALID_CIPHER;
104     ret = cbc_start(cipher, iv, key, KEY_LENGTH, 0, &cbc);
105     if( ret != CRYPT_OK )
106        return -1;
107     do {
108        nb = fread(inbuf.unpad, 1, sizeof(inbuf.unpad), infd);
109        if(!nb)
110           return encrypt ? CRYPT_OK : CRYPT_ERROR;
111        if(ferror(infd))
112           return CRYPT_ERROR;
113        if(encrypt) {
114           if(feof(infd))
115              nb = s_pkcs7_pad(&inbuf, nb,
116                             aes_desc.block_length, 1);
117           ret = cbc_encrypt(inbuf.pad, outbuf.pad, nb, &cbc);
118           if(ret != CRYPT_OK)
119              return ret;
120        } else {
121           ret = cbc_decrypt(inbuf.unpad, outbuf.unpad, nb, &cbc);
122           if( ret != CRYPT_OK )
123              return ret;
124           if(feof(infd))
125              nb = s_pkcs7_pad(&outbuf, nb,
126                             aes_desc.block_length, 0);
127           if(nb == 0)
128              return CRYPT_ERROR;
129        }
130        if(fwrite(outbuf.unpad, 1, nb, outfd) != nb)
131           return CRYPT_ERROR;
132     } while(!feof(infd));
133     cbc_done(&cbc);
134     return CRYPT_OK;
135  }
136  #define BARF(a) { \
137     if(infd) fclose(infd); \
138     if(outfd) { fclose(outfd); remove(argv[3]); } \
139     barf(argv[0], a); \
140  }
141  int main(int argc, char *argv[]) {
142     unsigned char salt[SALT_LENGTH];
<span onclick='openModal()' class='match'>143     FILE *infd = NULL, *outfd = NULL;
144     int encrypt = -1;
145     int hash = -1;
146     int ret;
</span>147     unsigned char keyiv[KEY_LENGTH + IV_LENGTH];
148     unsigned long keyivlen = (KEY_LENGTH + IV_LENGTH);
149     unsigned char *key, *iv;
150     if(argc < 5 || argc > 6)
151        BARF("Invalid number of arguments");
152     if     (!strncmp(argv[1], "enc", 3))
153        encrypt = 1;
154     else if(!strncmp(argv[1], "dec", 3))
155        encrypt = 0;
156     else
157        BARF("Bad command name");
158     infd = fopen(argv[2], "rb");
159     if(infd == NULL)
160        BARF("Could not open infile");
161     outfd = fopen(argv[3], "wb");
162     if(outfd == NULL)
163        BARF("Could not open outfile");
164     if(argc == 6) {
165        if(parse_hex_salt((unsigned char*) argv[5], salt) != CRYPT_OK)
166           BARF("Bad user-specified salt");
167     } else if(!strncmp(argv[1], "enc", 3)) {
168        if(rng_get_bytes(salt, sizeof(salt), NULL) != sizeof(salt))
169           BARF("Not enough random data");
170     } else {
171        if(parse_openssl_header(infd, salt) != CRYPT_OK)
172           BARF("Invalid OpenSSL header in infile");
173     }
174     hash = register_hash(&md5_desc);
175     if(hash == -1)
176        BARF("Could not register MD5 hash");
177     zeromem(keyiv, sizeof(keyiv));
178     key = keyiv + 0;      &bsol;* key comes first */
179     iv = keyiv + KEY_LENGTH;   &bsol;* iv comes next */
180     ret = pkcs_5_alg1_openssl((unsigned char*)argv[4], XSTRLEN(argv[4]), salt,
181                               OPENSSL_ITERATIONS, hash, keyiv, &keyivlen );
182     if(ret != CRYPT_OK)
183        BARF("Could not derive key/iv from passphrase");
184     printf("salt="); dump_bytes(salt, sizeof(salt)); printf("\n");
185     printf("key=");  dump_bytes(key, KEY_LENGTH);    printf("\n");
186     printf("iv =");  dump_bytes(iv,  IV_LENGTH );    printf("\n");
187     if(!strncmp(argv[1], "enc", 3)) {
188        if(fwrite(salt_header, 1, sizeof(salt_header), outfd) !=
189           sizeof(salt_header) )
190           BARF("Error writing salt header to outfile");
191        if(fwrite(salt, 1, sizeof(salt), outfd) != sizeof(salt))
192           BARF("Error writing salt to outfile");
193     }
194     if(do_crypt(infd, outfd, key, iv, encrypt) != CRYPT_OK)
195        BARF("Error during crypt operation");
196     fclose(infd); fclose(outfd);
197     return 0;
198  }
</code></pre>
        </div>
        <div class="column">
            <h3>PINRemoteImage-MDEwOlJlcG9zaXRvcnkzOTUzNzEwMw==-flat-get_disto.c</h3>
            <pre><code>1  #include <assert.h>
2  #include <stdio.h>
3  #include <stdlib.h>
4  #include <string.h>
5  #include "webp/encode.h"
6  #include "imageio/image_dec.h"
7  #include "imageio/imageio_util.h"
8  #include "../examples/unicode.h"
9  static size_t ReadPicture(const char* const filename, WebPPicture* const pic,
10                            int keep_alpha) {
11    const uint8_t* data = NULL;
12    size_t data_size = 0;
13    WebPImageReader reader = NULL;
14    int ok = ImgIoUtilReadFile(filename, &data, &data_size);
15    if (!ok) goto End;
16    pic->use_argb = 1;  
17  #ifdef HAVE_WINCODEC_H
18    ok = ReadPictureWithWIC(filename, pic, keep_alpha, NULL);
19    if (ok) goto End;
20  #endif
21    reader = WebPGuessImageReader(data, data_size);
22    ok = reader(data, data_size, pic, keep_alpha, NULL);
23   End:
24    if (!ok) {
25      WFPRINTF(stderr, "Error! Could not process file %s\n",
26               (const W_CHAR*)filename);
27    }
28    free((void*)data);
29    return ok ? data_size : 0;
30  }
31  static void RescalePlane(uint8_t* plane, int width, int height,
32                           int x_stride, int y_stride, int max) {
33    const uint32_t factor = (max > 0) ? (255u << 16) / max : 0;
34    int x, y;
35    for (y = 0; y < height; ++y) {
36      uint8_t* const ptr = plane + y * y_stride;
37      for (x = 0; x < width * x_stride; x += x_stride) {
38        const uint32_t diff = (ptr[x] * factor + (1 << 15)) >> 16;
39        ptr[x] = diff;
40      }
41    }
42  }
43  static int DiffScaleChannel(uint8_t* src1, int stride1,
44                              const uint8_t* src2, int stride2,
45                              int x_stride, int w, int h, int do_scaling) {
46    int x, y;
47    int max = 0;
48    for (y = 0; y < h; ++y) {
49      uint8_t* const ptr1 = src1 + y * stride1;
50      const uint8_t* const ptr2 = src2 + y * stride2;
51      for (x = 0; x < w * x_stride; x += x_stride) {
52        const int diff = abs(ptr1[x] - ptr2[x]);
53        if (diff > max) max = diff;
54        ptr1[x] = diff;
55      }
56    }
57    if (do_scaling) RescalePlane(src1, w, h, x_stride, stride1, max);
58    return max;
59  }
60  #define SSIM_KERNEL 3   
61  typedef struct {
62    uint32_t w;              
63    uint32_t xm, ym;         
64    uint32_t xxm, xym, yym;  
65  } DistoStats;
66  static const uint32_t kWeight[2 * SSIM_KERNEL + 1] = { 1, 2, 3, 4, 3, 2, 1 };
67  static WEBP_INLINE double SSIMCalculation(const DistoStats* const stats) {
68    const uint32_t N = stats->w;
69    const uint32_t w2 =  N * N;
70    const uint32_t C1 = 20 * w2;
71    const uint32_t C2 = 60 * w2;
72    const uint32_t C3 = 8 * 8 * w2;   
73    const uint64_t xmxm = (uint64_t)stats->xm * stats->xm;
74    const uint64_t ymym = (uint64_t)stats->ym * stats->ym;
75    if (xmxm + ymym >= C3) {
76      const int64_t xmym = (int64_t)stats->xm * stats->ym;
77      const int64_t sxy = (int64_t)stats->xym * N - xmym;    
78      const uint64_t sxx = (uint64_t)stats->xxm * N - xmxm;
79      const uint64_t syy = (uint64_t)stats->yym * N - ymym;
80      const uint64_t num_S = (2 * (uint64_t)(sxy < 0 ? 0 : sxy) + C2) >> 8;
81      const uint64_t den_S = (sxx + syy + C2) >> 8;
82      const uint64_t fnum = (2 * xmym + C1) * num_S;
83      const uint64_t fden = (xmxm + ymym + C1) * den_S;
84      const double r = (double)fnum / fden;
85      assert(r >= 0. && r <= 1.0);
86      return r;
87    }
88    return 1.;   
89  }
90  static double SSIMGetClipped(const uint8_t* src1, int stride1,
91                               const uint8_t* src2, int stride2,
92                               int xo, int yo, int W, int H) {
93    DistoStats stats = { 0, 0, 0, 0, 0, 0 };
94    const int ymin = (yo - SSIM_KERNEL < 0) ? 0 : yo - SSIM_KERNEL;
95    const int ymax = (yo + SSIM_KERNEL > H - 1) ? H - 1 : yo + SSIM_KERNEL;
96    const int xmin = (xo - SSIM_KERNEL < 0) ? 0 : xo - SSIM_KERNEL;
97    const int xmax = (xo + SSIM_KERNEL > W - 1) ? W - 1 : xo + SSIM_KERNEL;
98    int x, y;
99    src1 += ymin * stride1;
100    src2 += ymin * stride2;
101    for (y = ymin; y <= ymax; ++y, src1 += stride1, src2 += stride2) {
102      for (x = xmin; x <= xmax; ++x) {
103        const uint32_t w = kWeight[SSIM_KERNEL + x - xo]
104                         * kWeight[SSIM_KERNEL + y - yo];
105        const uint32_t s1 = src1[x];
106        const uint32_t s2 = src2[x];
107        stats.w   += w;
108        stats.xm  += w * s1;
109        stats.ym  += w * s2;
110        stats.xxm += w * s1 * s1;
111        stats.xym += w * s1 * s2;
112        stats.yym += w * s2 * s2;
113      }
114    }
115    return SSIMCalculation(&stats);
116  }
117  static int SSIMScaleChannel(uint8_t* src1, int stride1,
118                              const uint8_t* src2, int stride2,
119                              int x_stride, int w, int h, int do_scaling) {
120    int x, y;
121    int max = 0;
122    uint8_t* const plane1 = (uint8_t*)malloc(2 * w * h * sizeof(*plane1));
123    uint8_t* const plane2 = plane1 + w * h;
124    if (plane1 == NULL) return -1;
125    for (y = 0; y < h; ++y) {
126      for (x = 0; x < w; ++x) {
127        plane1[x + y * w] = src1[x * x_stride + y * stride1];
128        plane2[x + y * w] = src2[x * x_stride + y * stride2];
129      }
130    }
131    for (y = 0; y < h; ++y) {
132      for (x = 0; x < w; ++x) {
133        const double ssim = SSIMGetClipped(plane1, w, plane2, w, x, y, w, h);
134        int diff = (int)(255 * (1. - ssim));
135        if (diff < 0) {
136          diff = 0;
137        } else if (diff > max) {
138          max = diff;
139        }
140        src1[x * x_stride + y * stride1] = (diff > 255) ? 255u : (uint8_t)diff;
141      }
142    }
143    free(plane1);
144    if (do_scaling) RescalePlane(src1, w, h, x_stride, stride1, max);
145    return max;
146  }
147  static void ConvertToGray(WebPPicture* const pic) {
148    int x, y;
149    assert(pic != NULL);
150    assert(pic->use_argb);
151    for (y = 0; y < pic->height; ++y) {
152      uint32_t* const row = &pic->argb[y * pic->argb_stride];
153      for (x = 0; x < pic->width; ++x) {
154        const uint32_t argb = row[x];
155        const uint32_t r = (argb >> 16) & 0xff;
156        const uint32_t g = (argb >>  8) & 0xff;
157        const uint32_t b = (argb >>  0) & 0xff;
158        const uint32_t Y = (uint32_t)(0.2126 * r + 0.7152 * g + 0.0722 * b + .5);
159        row[x] = (argb & 0xff000000u) | (Y * 0x010101u);
160      }
161    }
162  }
163  static void Help(void) {
164    fprintf(stderr,
165            "Usage: get_disto [-ssim][-psnr][-alpha] compressed.webp orig.webp\n"
166            "  -ssim ..... print SSIM distortion\n"
167            "  -psnr ..... print PSNR distortion (default)\n"
168            "  -alpha .... preserve alpha plane\n"
169            "  -h ........ this message\n"
170            "  -o <file> . save the diff map as a WebP lossless file\n"
171            "  -scale .... scale the difference map to fit [0..255] range\n"
172            "  -gray ..... use grayscale for difference map (-scale)\n"
173            " Also handles PNG, JPG and TIFF files, in addition to WebP.\n");
174  }
175  int main(int argc, const char* argv[]) {
176    WebPPicture pic1, pic2;
177    size_t size1 = 0, size2 = 0;
178    int ret = 1;
179    float disto[5];
<span onclick='openModal()' class='match'>180    int type = 0;
181    int c;
182    int help = 0;
183    int keep_alpha = 0;
184    int scale = 0;
</span>185    int use_gray = 0;
186    const char* name1 = NULL;
187    const char* name2 = NULL;
188    const char* output = NULL;
189    INIT_WARGV(argc, argv);
190    if (!WebPPictureInit(&pic1) || !WebPPictureInit(&pic2)) {
191      fprintf(stderr, "Can't init pictures\n");
192      FREE_WARGV_AND_RETURN(1);
193    }
194    for (c = 1; c < argc; ++c) {
195      if (!strcmp(argv[c], "-ssim")) {
196        type = 1;
197      } else if (!strcmp(argv[c], "-psnr")) {
198        type = 0;
199      } else if (!strcmp(argv[c], "-alpha")) {
200        keep_alpha = 1;
201      } else if (!strcmp(argv[c], "-scale")) {
202        scale = 1;
203      } else if (!strcmp(argv[c], "-gray")) {
204        use_gray = 1;
205      } else if (!strcmp(argv[c], "-h")) {
206        help = 1;
207        ret = 0;
208      } else if (!strcmp(argv[c], "-o")) {
209        if (++c == argc) {
210          fprintf(stderr, "missing file name after %s option.\n", argv[c - 1]);
211          goto End;
212        }
213        output = (const char*)GET_WARGV(argv, c);
214      } else if (name1 == NULL) {
215        name1 = (const char*)GET_WARGV(argv, c);
216      } else {
217        name2 = (const char*)GET_WARGV(argv, c);
218      }
219    }
220    if (help || name1 == NULL || name2 == NULL) {
221      if (!help) {
222        fprintf(stderr, "Error: missing arguments.\n");
223      }
224      Help();
225      goto End;
226    }
227    size1 = ReadPicture(name1, &pic1, 1);
228    size2 = ReadPicture(name2, &pic2, 1);
229    if (size1 == 0 || size2 == 0) goto End;
230    if (!keep_alpha) {
231      WebPBlendAlpha(&pic1, 0x00000000);
232      WebPBlendAlpha(&pic2, 0x00000000);
233    }
234    if (!WebPPictureDistortion(&pic1, &pic2, type, disto)) {
235      fprintf(stderr, "Error while computing the distortion.\n");
236      goto End;
237    }
238    printf("%u %.2f    %.2f %.2f %.2f %.2f [ %.2f bpp ]\n",
239           (unsigned int)size1,
240           disto[4], disto[0], disto[1], disto[2], disto[3],
241           8.f * size1 / pic1.width / pic1.height);
242    if (output != NULL) {
243      uint8_t* data = NULL;
244      size_t data_size = 0;
245      if (pic1.use_argb != pic2.use_argb) {
246        fprintf(stderr, "Pictures are not in the same argb format. "
247                        "Can't save the difference map.\n");
248        goto End;
249      }
250      if (pic1.use_argb) {
251        int n;
252        fprintf(stderr, "max differences per channel: ");
253        for (n = 0; n < 3; ++n) {    
254          const int range = (type == 1) ?
255            SSIMScaleChannel((uint8_t*)pic1.argb + n, pic1.argb_stride * 4,
256                             (const uint8_t*)pic2.argb + n, pic2.argb_stride * 4,
257                             4, pic1.width, pic1.height, scale) :
258            DiffScaleChannel((uint8_t*)pic1.argb + n, pic1.argb_stride * 4,
259                             (const uint8_t*)pic2.argb + n, pic2.argb_stride * 4,
260                             4, pic1.width, pic1.height, scale);
261          if (range < 0) fprintf(stderr, "\nError computing diff map\n");
262          fprintf(stderr, "[%d]", range);
263        }
264        fprintf(stderr, "\n");
265        if (use_gray) ConvertToGray(&pic1);
266      } else {
267        fprintf(stderr, "Can only compute the difference map in ARGB format.\n");
268        goto End;
269      }
270  #if !defined(WEBP_REDUCE_CSP)
271      data_size = WebPEncodeLosslessBGRA((const uint8_t*)pic1.argb,
272                                         pic1.width, pic1.height,
273                                         pic1.argb_stride * 4,
274                                         &data);
275      if (data_size == 0) {
276        fprintf(stderr, "Error during lossless encoding.\n");
277        goto End;
278      }
279      ret = ImgIoUtilWriteFile(output, data, data_size) ? 0 : 1;
280      WebPFree(data);
281      if (ret) goto End;
282  #else
283      (void)data;
284      (void)data_size;
285      fprintf(stderr, "Cannot save the difference map. Please recompile "
286                      "without the WEBP_REDUCE_CSP flag.\n");
287  #endif  
288    }
289    ret = 0;
290   End:
291    WebPPictureFree(&pic1);
292    WebPPictureFree(&pic2);
293    FREE_WARGV_AND_RETURN(ret);
294  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from libtomcrypt-MDEwOlJlcG9zaXRvcnk3NzcwMTE=-flat-openssl-enc.c</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from PINRemoteImage-MDEwOlJlcG9zaXRvcnkzOTUzNzEwMw==-flat-get_disto.c</div>
                </div>
                <div class="column column_space"><pre><code>143     FILE *infd = NULL, *outfd = NULL;
144     int encrypt = -1;
145     int hash = -1;
146     int ret;
</pre></code></div>
                <div class="column column_space"><pre><code>180    int type = 0;
181    int c;
182    int help = 0;
183    int keep_alpha = 0;
184    int scale = 0;
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    