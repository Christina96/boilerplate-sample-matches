<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for rawload.c &amp; pdfiumload.c</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for rawload.c &amp; pdfiumload.c
      </h3>
<h1 align="center">
        6.1%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>rawload.c (22.5%)<th>pdfiumload.c (3.5856574%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(112-129)<td><a href="#" name="0">(840-859)</a><td align="center"><font color="#ff0000">18</font>
</td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>rawload.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
#ifdef HAVE_CONFIG_H
#include &lt;config.h&gt;
#include &lt;vips/intl.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;vips/vips.h&gt;
#include &lt;vips/internal.h&gt;
typedef struct _VipsForeignLoadRaw {
	VipsForeignLoad parent_object;
	char *filename;
	int width;
	int height;
	int bands;
	guint64 offset;
	VipsBandFormat format;
	VipsInterpretation interpretation;
} VipsForeignLoadRaw;
typedef VipsForeignLoadClass VipsForeignLoadRawClass;
G_DEFINE_TYPE( VipsForeignLoadRaw, vips_foreign_load_raw, 
	VIPS_TYPE_FOREIGN_LOAD );
static VipsForeignFlags
vips_foreign_load_raw_get_flags( VipsForeignLoad *load )
{
	return( VIPS_FOREIGN_PARTIAL );
}
static VipsForeignFlags
vips_foreign_load_raw_get_flags_filename( const char *filename )
{
	return( VIPS_FOREIGN_PARTIAL );
}
static int
vips_foreign_load_raw_header( VipsForeignLoad *load )
{
	VipsForeignLoadRaw *raw = (VipsForeignLoadRaw *) load;
	VipsImage *out;
	VipsImage *x;
	if( !(out = vips_image_new_from_file_raw( raw-&gt;filename, 
		raw-&gt;width, raw-&gt;height, 
		vips_format_sizeof_unsafe( raw-&gt;format ) * raw-&gt;bands,
		raw-&gt;offset )) )
		return( -1 );
	if( vips_copy( out, &amp;x,
		"interpretation", raw-&gt;interpretation,
		"format", raw-&gt;format,
		"bands", raw-&gt;bands,
		NULL ) ) {
		g_object_unref( out );
		return( -1 );
	}
	g_object_unref( out );
	out = x;
	g_object_get( load, "out", &amp;x, NULL ); 
	g_object_unref( x );
	g_object_unref( x );
<a name="0"></a>
	g_object_set( load, "out", out, NULL ); 
<font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>	return( 0 );
}
static void
vips_foreign_load_raw_class_init( VipsForeignLoadRawClass *class )
{
	GObjectClass *gobject_class = G_OBJECT_CLASS( class );
	VipsObjectClass *object_class = (VipsObjectClass *) class;
	VipsForeignLoadClass *load_class = (VipsForeignLoadClass *) class;
	gobject_class-&gt;set_property = vips_object_set_property;
	gobject_class-&gt;get_property = vips_object_get_property;
	object_class-&gt;nickname = "rawload";
	object_class-&gt;description = _( "load raw data from a file" );
	load_class-&gt;get_flags = vips_foreign_load_raw_get_flags;
	load_class-&gt;get_flags_filename = </b></font>
		vips_foreign_load_raw_get_flags_filename;
	load_class-&gt;header = vips_foreign_load_raw_header;
	VIPS_ARG_STRING( class, "filename", 1, 
		_( "Filename" ),
		_( "Filename to load from" ),
		VIPS_ARGUMENT_REQUIRED_INPUT, 
		G_STRUCT_OFFSET( VipsForeignLoadRaw, filename ),
		NULL );
	VIPS_ARG_INT( class, "width", 20, 
		_( "Width" ), 
		_( "Image width in pixels" ),
		VIPS_ARGUMENT_REQUIRED_INPUT,
		G_STRUCT_OFFSET( VipsForeignLoadRaw, width ),
		0, VIPS_MAX_COORD, 0 );
	VIPS_ARG_INT( class, "height", 21, 
		_( "Height" ), 
		_( "Image height in pixels" ),
		VIPS_ARGUMENT_REQUIRED_INPUT,
		G_STRUCT_OFFSET( VipsForeignLoadRaw, height ),
		0, VIPS_MAX_COORD, 0 );
	VIPS_ARG_INT( class, "bands", 22, 
		_( "Bands" ), 
		_( "Number of bands in image" ),
		VIPS_ARGUMENT_REQUIRED_INPUT,
		G_STRUCT_OFFSET( VipsForeignLoadRaw, bands ),
		0, VIPS_MAX_COORD, 0 );
	VIPS_ARG_UINT64( class, "offset", 23, 
		_( "Size of header" ), 
		_( "Offset in bytes from start of file" ),
		VIPS_ARGUMENT_OPTIONAL_INPUT,
		G_STRUCT_OFFSET( VipsForeignLoadRaw, offset ),
		0, 100000000000, 0 );
	VIPS_ARG_ENUM( class, "format", 24, 
		_( "Format" ), 
		_( "Pixel format in image" ),
		VIPS_ARGUMENT_OPTIONAL_INPUT,
		G_STRUCT_OFFSET( VipsForeignLoadRaw, format ),
		VIPS_TYPE_BAND_FORMAT, VIPS_FORMAT_UCHAR ); 
	VIPS_ARG_ENUM( class, "interpretation", 25, 
		_( "Interpretation" ), 
		_( "Pixel interpretation" ),
		VIPS_ARGUMENT_OPTIONAL_INPUT,
		G_STRUCT_OFFSET( VipsForeignLoadRaw, interpretation ),
		VIPS_TYPE_INTERPRETATION, VIPS_INTERPRETATION_MULTIBAND ); 
}
static void
vips_foreign_load_raw_init( VipsForeignLoadRaw *raw )
{
	raw-&gt;format = VIPS_FORMAT_UCHAR;
	raw-&gt;interpretation = VIPS_INTERPRETATION_MULTIBAND;
}
int
vips_rawload( const char *filename, VipsImage **out, 
	int width, int height, int bands, ... )
{
	va_list ap;
	int result;
	va_start( ap, bands );
	result = vips_call_split( "rawload", ap, 
		filename, out, width, height, bands );
	va_end( ap );
	return( result );
}
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>pdfiumload.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
#ifdef HAVE_CONFIG_H
#include &lt;config.h&gt;
#include &lt;vips/intl.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;errno.h&gt;
#include &lt;vips/vips.h&gt;
#include &lt;vips/buf.h&gt;
#include &lt;vips/internal.h&gt;
#include "pforeign.h"
#ifdef HAVE_PDFIUM
#include &lt;fpdfview.h&gt;
#include &lt;fpdf_doc.h&gt;
typedef struct _VipsForeignLoadPdf {
	VipsForeignLoad parent_object;
	VipsSource *source;
	int page_no;
	int n; 
	double dpi;
	double scale;
	VipsArrayDouble *background;
	FPDF_FILEACCESS file_access;
	FPDF_DOCUMENT doc;
	FPDF_PAGE page;
	int current_page;
	int n_pages;
	VipsRect image;
	VipsRect *pages;
	VipsPel *ink;
} VipsForeignLoadPdf;
typedef VipsForeignLoadClass VipsForeignLoadPdfClass;
G_DEFINE_ABSTRACT_TYPE( VipsForeignLoadPdf, vips_foreign_load_pdf, 
	VIPS_TYPE_FOREIGN_LOAD );
static char *vips_pdfium_errors[] = {
	"no error",
	"unknown error",
	"file not found or could not be opened",
	"file not in PDF format or corrupted",
	"password required or incorrect password",
	"unsupported security scheme",
	"page not found or content error"
};
static GMutex *vips_pdfium_mutex = NULL;
static void
vips_pdfium_error( void )
{
	int err = FPDF_GetLastError();
	if( err &gt;= 0 &amp;&amp; 
		err &lt; VIPS_NUMBER( vips_pdfium_errors ) )
		vips_error( "pdfload", "%s", _( vips_pdfium_errors[err] ) );
	else
		vips_error( "pdfload", "%s", _( "unknown error" ) ); 
}
static void
vips_foreign_load_pdf_close( VipsForeignLoadPdf *pdf )
{
	g_mutex_lock( vips_pdfium_mutex );
	VIPS_FREEF( FPDF_ClosePage, pdf-&gt;page ); 
	VIPS_FREEF( FPDF_CloseDocument, pdf-&gt;doc ); 
	VIPS_UNREF( pdf-&gt;source );
	g_mutex_unlock( vips_pdfium_mutex );
}
static void
vips_foreign_load_pdf_dispose( GObject *gobject )
{
	VipsForeignLoadPdf *pdf = (VipsForeignLoadPdf *) gobject;
	vips_foreign_load_pdf_close( pdf ); 
	G_OBJECT_CLASS( vips_foreign_load_pdf_parent_class )-&gt;
		dispose( gobject );
}
static void *
vips_pdfium_init_cb( void *dummy )
{
	FPDF_LIBRARY_CONFIG config;
	config.version = 2;
	config.m_pUserFontPaths = NULL;
	config.m_pIsolate = NULL;
	config.m_v8EmbedderSlot = 0;
	FPDF_InitLibraryWithConfig( &amp;config );
	return( NULL );
}
static gboolean
vips_pdfium_GetBlock( void *param, 
	unsigned long position, unsigned char *pBuf, unsigned long size )
{
	VipsForeignLoadPdf *pdf = (VipsForeignLoadPdf *) param;
	g_assert( size &gt; 0 );
	g_assert( position &gt;= 0 );
	g_assert( position + size &lt;= pdf-&gt;file_access.m_FileLen );
	if( vips_source_seek( pdf-&gt;source, position, SEEK_SET ) &lt; 0 )
		return( FALSE );
	while( size &gt; 0 ) {
		size_t n_read;
		if( (n_read = vips_source_read( pdf-&gt;source, pBuf, size )) &lt; 0 )
			return( FALSE );
		pBuf += n_read;
		size -= n_read;
	}
	return( TRUE );
}
static int
vips_foreign_load_pdf_build( VipsObject *object )
{
	static GOnce once = G_ONCE_INIT;
	VipsForeignLoadPdf *pdf = (VipsForeignLoadPdf *) object;
	VipsObjectClass *class = VIPS_OBJECT_GET_CLASS( pdf );
	gint64 length;
	VIPS_ONCE( &amp;once, vips_pdfium_init_cb, NULL );
	if( !vips_object_argument_isset( object, "scale" ) )
		pdf-&gt;scale = pdf-&gt;dpi / 72.0;
	if( pdf-&gt;source ) { 
		if( (length = vips_source_length( pdf-&gt;source )) &lt;= 0 )
			return( -1 );
		if( length &gt; 1 &lt;&lt; 30 ) {
			vips_error( class-&gt;nickname, 
				_( "%s: too large for pdfium" ),
				vips_connection_nick( 
					VIPS_CONNECTION( pdf-&gt;source ) ) );
			return( -1 );
		}
		pdf-&gt;file_access.m_FileLen = length;
		pdf-&gt;file_access.m_GetBlock = vips_pdfium_GetBlock;
		pdf-&gt;file_access.m_Param = pdf;
		g_mutex_lock( vips_pdfium_mutex );
		if( !(pdf-&gt;doc = FPDF_LoadCustomDocument( &amp;pdf-&gt;file_access, 
			NULL )) ) {
			g_mutex_unlock( vips_pdfium_mutex );
			vips_pdfium_error();
			vips_error( "pdfload", 
				_( "%s: unable to load" ), 
				vips_connection_nick( 
					VIPS_CONNECTION( pdf-&gt;source ) ) );
			return( -1 ); 
		}
		g_mutex_unlock( vips_pdfium_mutex );
	}
	if( VIPS_OBJECT_CLASS( vips_foreign_load_pdf_parent_class )-&gt;
		build( object ) )
		return( -1 );
	return( 0 );
}
static VipsForeignFlags
vips_foreign_load_pdf_get_flags_filename( const char *filename )
{
	return( VIPS_FOREIGN_PARTIAL );
}
static VipsForeignFlags
vips_foreign_load_pdf_get_flags( VipsForeignLoad *load )
{
	return( VIPS_FOREIGN_PARTIAL );
}
static int
vips_foreign_load_pdf_get_page( VipsForeignLoadPdf *pdf, int page_no )
{
	if( pdf-&gt;current_page != page_no ) { 
		VipsObjectClass *class = VIPS_OBJECT_GET_CLASS( pdf );
		g_mutex_lock( vips_pdfium_mutex );
		VIPS_FREEF( FPDF_ClosePage, pdf-&gt;page ); 
		pdf-&gt;current_page = -1;
#ifdef DEBUG
		printf( "vips_foreign_load_pdf_get_page: %d\n", page_no );
		if( !(pdf-&gt;page = FPDF_LoadPage( pdf-&gt;doc, page_no )) ) {
			g_mutex_unlock( vips_pdfium_mutex );
			vips_pdfium_error();
			vips_error( class-&gt;nickname, 
				_( "unable to load page %d" ), page_no );
			return( -1 ); 
		}
		pdf-&gt;current_page = page_no;
		g_mutex_unlock( vips_pdfium_mutex );
	}
	return( 0 );
}
typedef struct _VipsForeignLoadPdfMetadata {
	char *tag;			char *field;		} VipsForeignLoadPdfMetadata;
static VipsForeignLoadPdfMetadata vips_foreign_load_pdf_metadata[] = {
	{ "Title", "pdf-title" },
	{ "Author", "pdf-author" },
	{ "Subject", "pdf-subject" },
	{ "Keywords", "pdf-keywords" },
	{ "Creator", "pdf-creator" },
	{ "Producer", "pdf-producer" },
};
static int n_metadata = VIPS_NUMBER( vips_foreign_load_pdf_metadata );
static int
vips_foreign_load_pdf_set_image( VipsForeignLoadPdf *pdf, VipsImage *out )
{
	int i;
	double res;
#ifdef DEBUG
	printf( "vips_foreign_load_pdf_set_image: %p\n", pdf );
        if( vips_image_pipelinev( out, VIPS_DEMAND_STYLE_FATSTRIP, NULL ) )
		return( -1 );
	vips_image_set_int( out, "pdf-n_pages", pdf-&gt;n_pages ); 
	vips_image_set_int( out, VIPS_META_N_PAGES, pdf-&gt;n_pages ); 
	g_mutex_lock( vips_pdfium_mutex );
	for( i = 0; i &lt; n_metadata; i++ ) {
		VipsForeignLoadPdfMetadata *metadata = 
			&amp;vips_foreign_load_pdf_metadata[i];
		char text[1024];
		int len;
		len = FPDF_GetMetaText( pdf-&gt;doc, metadata-&gt;tag, text, 1024 );
		if( len &gt; 0 ) { 
			char *str;
			if( (str = g_utf16_to_utf8( (gunichar2 *) text, len, 
				NULL, NULL, NULL )) ) {
				vips_image_set_string( out, 
					metadata-&gt;field, str ); 
				g_free( str );
			}
		}
	}
	g_mutex_unlock( vips_pdfium_mutex );
	res = pdf-&gt;dpi / 25.4;
	vips_image_init_fields( out, 
		pdf-&gt;image.width, pdf-&gt;image.height, 
		4, VIPS_FORMAT_UCHAR,
		VIPS_CODING_NONE, VIPS_INTERPRETATION_sRGB, res, res );
	return( 0 );
}
static int
vips_foreign_load_pdf_header( VipsForeignLoad *load )
{
	VipsObjectClass *class = VIPS_OBJECT_GET_CLASS( load );
	VipsForeignLoadPdf *pdf = (VipsForeignLoadPdf *) load;
	int top;
	int i;
#ifdef DEBUG
	printf( "vips_foreign_load_pdf_header: %p\n", pdf );
	g_mutex_lock( vips_pdfium_mutex );
	pdf-&gt;n_pages = FPDF_GetPageCount( pdf-&gt;doc );
	g_mutex_unlock( vips_pdfium_mutex );
	if( pdf-&gt;n == -1 )
		pdf-&gt;n = pdf-&gt;n_pages - pdf-&gt;page_no;
	if( pdf-&gt;page_no + pdf-&gt;n &gt; pdf-&gt;n_pages ||
		pdf-&gt;page_no &lt; 0 ||
		pdf-&gt;n &lt;= 0 ) {
		vips_error( class-&gt;nickname, "%s", _( "pages out of range" ) );
		return( -1 ); 
	}
	if( !(pdf-&gt;pages = VIPS_ARRAY( pdf, pdf-&gt;n, VipsRect )) )
		return( -1 ); 
	top = 0;
	pdf-&gt;image.left = 0;
	pdf-&gt;image.top = 0;
	pdf-&gt;image.width = 0;
	pdf-&gt;image.height = 0;
	for( i = 0; i &lt; pdf-&gt;n; i++ ) {
		if( vips_foreign_load_pdf_get_page( pdf, pdf-&gt;page_no + i ) )
			return( -1 );
		pdf-&gt;pages[i].left = 0;
		pdf-&gt;pages[i].top = top;
		pdf-&gt;pages[i].width = VIPS_RINT( 
			FPDF_GetPageWidth( pdf-&gt;page ) * pdf-&gt;scale );
		pdf-&gt;pages[i].height = VIPS_RINT( 
			FPDF_GetPageHeight( pdf-&gt;page ) * pdf-&gt;scale );
		if( pdf-&gt;pages[i].width &gt; pdf-&gt;image.width )
			pdf-&gt;image.width = pdf-&gt;pages[i].width;
		pdf-&gt;image.height += pdf-&gt;pages[i].height;
		top += pdf-&gt;pages[i].height;
	}
	for( i = 1; i &lt; pdf-&gt;n; i++ ) 
		if( pdf-&gt;pages[i].height != pdf-&gt;pages[0].height )
			break;
	if( vips_object_argument_isset( VIPS_OBJECT( pdf ), "n" ) )
		vips_image_set_int( load-&gt;out, 
			VIPS_META_PAGE_HEIGHT, pdf-&gt;pages[0].height );
	vips_foreign_load_pdf_set_image( pdf, load-&gt;out ); 
	if( !(pdf-&gt;ink = vips__vector_to_ink( class-&gt;nickname, 
		load-&gt;out, 
		VIPS_AREA( pdf-&gt;background )-&gt;data, NULL, 
		VIPS_AREA( pdf-&gt;background )-&gt;n )) )
		return( -1 );
	return( 0 );
}
static void
vips_foreign_load_pdf_minimise( VipsObject *object, VipsForeignLoadPdf *pdf )
{
	vips_source_minimise( pdf-&gt;source );
}
static int
vips_foreign_load_pdf_generate( VipsRegion *or, 
	void *seq, void *a, void *b, gboolean *stop )
{
	VipsForeignLoadPdf *pdf = (VipsForeignLoadPdf *) a;
	VipsRect *r = &amp;or-&gt;valid;
	int top;
	int i;
	int y;
	vips_region_paint_pel( or, r, pdf-&gt;ink ); 
	for( i = 0; i &lt; pdf-&gt;n; i++ )
		if( VIPS_RECT_BOTTOM( &amp;pdf-&gt;pages[i] ) &gt; r-&gt;top )
			break;
	top = r-&gt;top; 
	while( top &lt; VIPS_RECT_BOTTOM( r ) ) {
		VipsRect rect;
		FPDF_BITMAP bitmap;
		vips_rect_intersectrect( r, &amp;pdf-&gt;pages[i], &amp;rect );
		if( vips_foreign_load_pdf_get_page( pdf, pdf-&gt;page_no + i ) )
			return( -1 ); 
		g_mutex_lock( vips_pdfium_mutex );
		bitmap = FPDFBitmap_CreateEx( rect.width, rect.height, 4, 
			VIPS_REGION_ADDR( or, rect.left, rect.top ), 
			VIPS_REGION_LSKIP( or ) );  
		FPDF_RenderPageBitmap( bitmap, pdf-&gt;page, 
			0, 0, rect.width, rect.height,
			0, 0 ); 
		FPDFBitmap_Destroy( bitmap ); 
		g_mutex_unlock( vips_pdfium_mutex );
		top += rect.height;
		i += 1;
	}
	for( y = 0; y &lt; r-&gt;height; y++ )
		vips__bgra2rgba( 
			(guint32 *) VIPS_REGION_ADDR( or, r-&gt;left, r-&gt;top + y ),
			r-&gt;width );
	return( 0 ); 
}
static int
vips_foreign_load_pdf_load( VipsForeignLoad *load )
{
	VipsForeignLoadPdf *pdf = (VipsForeignLoadPdf *) load;
	VipsImage **t = (VipsImage **) 
		vips_object_local_array( (VipsObject *) load, 2 );
#ifdef DEBUG
	printf( "vips_foreign_load_pdf_load: %p\n", pdf );
	t[0] = vips_image_new(); 
	g_signal_connect( t[0], "minimise", 
		G_CALLBACK( vips_foreign_load_pdf_minimise ), pdf ); 
	vips_foreign_load_pdf_set_image( pdf, t[0] ); 
	if( vips_image_generate( t[0], 
		NULL, vips_foreign_load_pdf_generate, NULL, pdf, NULL ) )
		return( -1 );
	if( vips_linecache( t[0], &amp;t[1],
		"tile_height", pdf-&gt;pages[0].height, 
		NULL ) ) 
		return( -1 );
	if( vips_image_write( t[1], load-&gt;real ) ) 
		return( -1 );
	return( 0 );
}
static void *
vips_foreign_load_pdf_once_init( void *client )
{
	vips_pdfium_mutex = vips_g_mutex_new();
	return( NULL );
}
static void
vips_foreign_load_pdf_class_init( VipsForeignLoadPdfClass *class )
{
	static GOnce once = G_ONCE_INIT;
	GObjectClass *gobject_class = G_OBJECT_CLASS( class );
	VipsObjectClass *object_class = (VipsObjectClass *) class;
	VipsForeignLoadClass *load_class = (VipsForeignLoadClass *) class;
	VIPS_ONCE( &amp;once, vips_foreign_load_pdf_once_init, NULL );
	gobject_class-&gt;dispose = vips_foreign_load_pdf_dispose;
	gobject_class-&gt;set_property = vips_object_set_property;
	gobject_class-&gt;get_property = vips_object_get_property;
	object_class-&gt;nickname = "pdfload_base";
	object_class-&gt;description = _( "load PDF with PDFium" );
	object_class-&gt;build = vips_foreign_load_pdf_build;
	load_class-&gt;get_flags_filename = 
		vips_foreign_load_pdf_get_flags_filename;
	load_class-&gt;get_flags = vips_foreign_load_pdf_get_flags;
	load_class-&gt;header = vips_foreign_load_pdf_header;
	load_class-&gt;load = vips_foreign_load_pdf_load;
	VIPS_ARG_INT( class, "page", 10,
		_( "Page" ),
		_( "Load this page from the file" ),
		VIPS_ARGUMENT_OPTIONAL_INPUT,
		G_STRUCT_OFFSET( VipsForeignLoadPdf, page_no ),
		0, 100000, 0 );
	VIPS_ARG_INT( class, "n", 11,
		_( "n" ),
		_( "Load this many pages" ),
		VIPS_ARGUMENT_OPTIONAL_INPUT,
		G_STRUCT_OFFSET( VipsForeignLoadPdf, n ),
		-1, 100000, 1 );
	VIPS_ARG_DOUBLE( class, "dpi", 12,
		_( "DPI" ),
		_( "Render at this DPI" ),
		VIPS_ARGUMENT_OPTIONAL_INPUT,
		G_STRUCT_OFFSET( VipsForeignLoadPdf, dpi ),
		0.001, 100000.0, 72.0 );
	VIPS_ARG_DOUBLE( class, "scale", 13,
		_( "Scale" ),
		_( "Scale output by this factor" ),
		VIPS_ARGUMENT_OPTIONAL_INPUT,
		G_STRUCT_OFFSET( VipsForeignLoadPdf, scale ),
		0.001, 100000.0, 1.0 );
	VIPS_ARG_BOXED( class, "background", 14, 
		_( "Background" ), 
		_( "Background value" ),
		VIPS_ARGUMENT_OPTIONAL_INPUT,
		G_STRUCT_OFFSET( VipsForeignLoadPdf, background ),
		VIPS_TYPE_ARRAY_DOUBLE );
}
static void
vips_foreign_load_pdf_init( VipsForeignLoadPdf *pdf )
{
	pdf-&gt;dpi = 72.0;
	pdf-&gt;scale = 1.0;
	pdf-&gt;n = 1;
	pdf-&gt;current_page = -1;
	pdf-&gt;background = vips_array_double_newv( 1, 255.0 );
}
typedef struct _VipsForeignLoadPdfFile {
	VipsForeignLoadPdf parent_object;
	char *filename; 
} VipsForeignLoadPdfFile;
typedef VipsForeignLoadPdfClass VipsForeignLoadPdfFileClass;
G_DEFINE_TYPE( VipsForeignLoadPdfFile, vips_foreign_load_pdf_file, 
	vips_foreign_load_pdf_get_type() );
static int
vips_foreign_load_pdf_file_header( VipsForeignLoad *load )
{
	VipsForeignLoadPdfFile *file = (VipsForeignLoadPdfFile *) load;
	VIPS_SETSTR( load-&gt;out-&gt;filename, file-&gt;filename );
	return( VIPS_FOREIGN_LOAD_CLASS(
		vips_foreign_load_pdf_file_parent_class )-&gt;header( load ) );
}
static const char *vips_foreign_pdf_suffs[] = {
	".pdf",
	NULL
};
static int
vips_foreign_load_pdf_file_build( VipsObject *object )
{
	VipsForeignLoadPdf *pdf = (VipsForeignLoadPdf *) object;
	VipsForeignLoadPdfFile *file = (VipsForeignLoadPdfFile *) pdf;
#ifdef DEBUG
	printf( "vips_foreign_load_pdf_file_build: %s\n", file-&gt;filename );
	if( file-&gt;filename &amp;&amp;
		!(pdf-&gt;source = vips_source_new_from_file( file-&gt;filename )) )
		return( -1 );
	return( VIPS_OBJECT_CLASS( vips_foreign_load_pdf_file_parent_class )-&gt;
		build( object ) );
}
static gboolean
vips_foreign_load_pdf_is_a_buffer( const void *buf, size_t len )
{
	const guchar *str = (const guchar *) buf;
	if( len &gt;= 4 &amp;&amp;
		str[0] == '%' &amp;&amp; 
		str[1] == 'P' &amp;&amp;
		str[2] == 'D' &amp;&amp;
		str[3] == 'F' )
		return( 1 );
	return( 0 );
}
static gboolean
vips_foreign_load_pdf_is_a( const char *filename )
{
	unsigned char buf[4];
	if( vips__get_bytes( filename, buf, 4 ) == 4 &amp;&amp;
		vips_foreign_load_pdf_is_a_buffer( buf, 4 ) )
		return( 1 );
	return( 0 );
}
static void
vips_foreign_load_pdf_file_class_init( 
	VipsForeignLoadPdfFileClass *class )
{
	GObjectClass *gobject_class = G_OBJECT_CLASS( class );
	VipsObjectClass *object_class = (VipsObjectClass *) class;
	VipsForeignClass *foreign_class = (VipsForeignClass *) class;
	VipsForeignLoadClass *load_class = (VipsForeignLoadClass *) class;
	gobject_class-&gt;set_property = vips_object_set_property;
	gobject_class-&gt;get_property = vips_object_get_property;
	object_class-&gt;nickname = "pdfload";
	object_class-&gt;description = _( "load PDF from file" );
	object_class-&gt;build = vips_foreign_load_pdf_file_build;
	foreign_class-&gt;suffs = vips_foreign_pdf_suffs;
	load_class-&gt;is_a = vips_foreign_load_pdf_is_a;
	load_class-&gt;header = vips_foreign_load_pdf_file_header;
	VIPS_ARG_STRING( class, "filename", 1, 
		_( "Filename" ),
		_( "Filename to load from" ),
		VIPS_ARGUMENT_REQUIRED_INPUT, 
		G_STRUCT_OFFSET( VipsForeignLoadPdfFile, filename ),
		NULL );
}
static void
vips_foreign_load_pdf_file_init( VipsForeignLoadPdfFile *file )
{
}
typedef struct _VipsForeignLoadPdfBuffer {
	VipsForeignLoadPdf parent_object;
	VipsArea *buf;
} VipsForeignLoadPdfBuffer;
typedef VipsForeignLoadPdfClass VipsForeignLoadPdfBufferClass;
G_DEFINE_TYPE( VipsForeignLoadPdfBuffer, vips_foreign_load_pdf_buffer, 
	vips_foreign_load_pdf_get_type() );
static int
vips_foreign_load_pdf_buffer_build( VipsObject *object )
{
	VipsForeignLoadPdf *pdf = (VipsForeignLoadPdf *) object;
	VipsForeignLoadPdfBuffer *buffer = (VipsForeignLoadPdfBuffer *) pdf;
	if( buffer-&gt;buf &amp;&amp;
		!(pdf-&gt;source = vips_source_new_from_memory( 
			VIPS_AREA( buffer-&gt;buf )-&gt;data, 
<a name="0"></a>			VIPS_AREA( buffer-&gt;buf )-&gt;length )) )
		return( -1 );
<font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>	return( VIPS_OBJECT_CLASS( vips_foreign_load_pdf_buffer_parent_class )-&gt;
		build( object ) );
}
static void
vips_foreign_load_pdf_buffer_class_init( 
	VipsForeignLoadPdfBufferClass *class )
{
	GObjectClass *gobject_class = G_OBJECT_CLASS( class );
	VipsObjectClass *object_class = (VipsObjectClass *) class;
	VipsForeignLoadClass *load_class = (VipsForeignLoadClass *) class;
	gobject_class-&gt;set_property = vips_object_set_property;
	gobject_class-&gt;get_property = vips_object_get_property;
	object_class-&gt;nickname = "pdfload_buffer";
	object_class-&gt;description = _( "load PDF from buffer" );
	object_class-&gt;build = vips_foreign_load_pdf_buffer_build;
	load_class-&gt;is_a_buffer = vips_foreign_load_pdf_is_a_buffer;</b></font>
	VIPS_ARG_BOXED( class, "buffer", 1, 
		_( "Buffer" ),
		_( "Buffer to load from" ),
		VIPS_ARGUMENT_REQUIRED_INPUT, 
		G_STRUCT_OFFSET( VipsForeignLoadPdfBuffer, buf ),
		VIPS_TYPE_BLOB );
}
static void
vips_foreign_load_pdf_buffer_init( VipsForeignLoadPdfBuffer *buffer )
{
}
typedef struct _VipsForeignLoadPdfSource {
	VipsForeignLoadPdf parent_object;
	VipsSource *source;
} VipsForeignLoadPdfSource;
typedef VipsForeignLoadPdfClass VipsForeignLoadPdfSourceClass;
G_DEFINE_TYPE( VipsForeignLoadPdfSource, vips_foreign_load_pdf_source, 
	vips_foreign_load_pdf_get_type() );
static int
vips_foreign_load_pdf_source_build( VipsObject *object )
{
	VipsForeignLoadPdf *pdf = (VipsForeignLoadPdf *) object;
	VipsForeignLoadPdfSource *source = (VipsForeignLoadPdfSource *) pdf;
	if( source-&gt;source ) {
		pdf-&gt;source = source-&gt;source;
		g_object_ref( pdf-&gt;source );
	}
	return( VIPS_OBJECT_CLASS( vips_foreign_load_pdf_source_parent_class )-&gt;
		build( object ) );
}
static gboolean
vips_foreign_load_pdf_source_is_a_source( VipsSource *source )
{
	const unsigned char *p;
	return( (p = vips_source_sniff( source, 4 )) &amp;&amp;
		p[0] == '%' &amp;&amp; 
		p[1] == 'P' &amp;&amp;
		p[2] == 'D' &amp;&amp;
		p[3] == 'F' );
}
static void
vips_foreign_load_pdf_source_class_init( 
	VipsForeignLoadPdfSourceClass *class )
{
	GObjectClass *gobject_class = G_OBJECT_CLASS( class );
	VipsObjectClass *object_class = (VipsObjectClass *) class;
	VipsForeignLoadClass *load_class = (VipsForeignLoadClass *) class;
	gobject_class-&gt;set_property = vips_object_set_property;
	gobject_class-&gt;get_property = vips_object_get_property;
	object_class-&gt;nickname = "pdfload_source";
	object_class-&gt;description = _( "load PDF from source" );
	object_class-&gt;build = vips_foreign_load_pdf_source_build;
	load_class-&gt;is_a_source = vips_foreign_load_pdf_source_is_a_source;
	VIPS_ARG_OBJECT( class, "source", 1,
		_( "Source" ),
		_( "Source to load from" ),
		VIPS_ARGUMENT_REQUIRED_INPUT, 
		G_STRUCT_OFFSET( VipsForeignLoadPdfSource, source ),
		VIPS_TYPE_SOURCE );
}
static void
vips_foreign_load_pdf_source_init( VipsForeignLoadPdfSource *source )
{
}
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
