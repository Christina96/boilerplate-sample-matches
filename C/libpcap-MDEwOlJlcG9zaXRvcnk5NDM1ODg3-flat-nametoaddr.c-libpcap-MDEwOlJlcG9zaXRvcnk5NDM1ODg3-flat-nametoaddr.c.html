
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 18, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>libpcap-MDEwOlJlcG9zaXRvcnk5NDM1ODg3-flat-nametoaddr.c</h3>
            <pre><code>1  #ifdef HAVE_CONFIG_H
2  #include <config.h>
3  #endif
4  #ifdef _WIN32
5    #include <winsock2.h>
6    #include <ws2tcpip.h>
7    #ifdef INET6
8      #include <wspiapi.h>
9    #endif &bsol;* INET6 */
10  #else &bsol;* _WIN32 */
11    #include <sys/param.h>
12    #include <sys/types.h>
13    #include <sys/socket.h>
14    #include <sys/time.h>
15    #include <netinet/in.h>
16    #ifdef HAVE_ETHER_HOSTTON
17      #if defined(NET_ETHERNET_H_DECLARES_ETHER_HOSTTON)
18        #include <net/ethernet.h>
19      #elif defined(NETINET_ETHER_H_DECLARES_ETHER_HOSTTON)
20        #include <netinet/ether.h>
21      #elif defined(SYS_ETHERNET_H_DECLARES_ETHER_HOSTTON)
22        #include <sys/ethernet.h>
23      #elif defined(ARPA_INET_H_DECLARES_ETHER_HOSTTON)
24        #include <arpa/inet.h>
25      #elif defined(NETINET_IF_ETHER_H_DECLARES_ETHER_HOSTTON)
26        #define NEED_NETINET_IF_ETHER_H
27      #else
28        #ifdef HAVE_STRUCT_ETHER_ADDR
29          #define NEED_NETINET_IF_ETHER_H
30        #else &bsol;* HAVE_STRUCT_ETHER_ADDR */
31  	struct ether_addr {
32  		unsigned char ether_addr_octet[6];
33  	};
34        #endif &bsol;* HAVE_STRUCT_ETHER_ADDR */
35      #endif &bsol;* what declares ether_hostton() */
36      #ifdef NEED_NETINET_IF_ETHER_H
37        #include <net/if.h>	&bsol;* Needed on some platforms */
38        #include <netinet/in.h>	&bsol;* Needed on some platforms */
39        #include <netinet/if_ether.h>
40      #endif &bsol;* NEED_NETINET_IF_ETHER_H */
41      #ifndef HAVE_DECL_ETHER_HOSTTON
42        extern int ether_hostton(const char *, struct ether_addr *);
43      #endif &bsol;* !defined(HAVE_DECL_ETHER_HOSTTON) */
44    #endif &bsol;* HAVE_ETHER_HOSTTON */
45    #include <arpa/inet.h>
46    #include <netdb.h>
47  #endif &bsol;* _WIN32 */
48  #include <errno.h>
49  #include <stdlib.h>
50  #include <string.h>
51  #include <stdio.h>
52  #include "pcap-int.h"
53  #include "diag-control.h"
54  #include "gencode.h"
55  #include <pcap/namedb.h>
56  #include "nametoaddr.h"
57  #include "thread-local.h"
58  #ifdef HAVE_OS_PROTO_H
59  #include "os-proto.h"
60  #endif
61  #ifndef NTOHL
62  #define NTOHL(x) (x) = ntohl(x)
63  #define NTOHS(x) (x) = ntohs(x)
64  #endif
65  bpf_u_int32 **
66  pcap_nametoaddr(const char *name)
67  {
68  #ifndef h_addr
69  	static bpf_u_int32 *hlist[2];
70  #endif
71  	bpf_u_int32 **p;
72  	struct hostent *hp;
73  DIAG_OFF_DEPRECATION
74  	if ((hp = gethostbyname(name)) != NULL) {
75  DIAG_ON_DEPRECATION
76  #ifndef h_addr
77  		hlist[0] = (bpf_u_int32 *)hp->h_addr;
78  		NTOHL(hp->h_addr);
79  		return hlist;
80  #else
81  		for (p = (bpf_u_int32 **)hp->h_addr_list; *p; ++p)
82  			NTOHL(**p);
83  		return (bpf_u_int32 **)hp->h_addr_list;
84  #endif
85  	}
86  	else
87  		return 0;
88  }
89  struct addrinfo *
90  pcap_nametoaddrinfo(const char *name)
91  {
92  	struct addrinfo hints, *res;
93  	int error;
94  	memset(&hints, 0, sizeof(hints));
95  	hints.ai_family = PF_UNSPEC;
96  	hints.ai_socktype = SOCK_STREAM;	&bsol;*not really*/
97  	hints.ai_protocol = IPPROTO_TCP;	&bsol;*not really*/
98  	error = getaddrinfo(name, NULL, &hints, &res);
99  	if (error)
100  		return NULL;
101  	else
102  		return res;
103  }
104  #if defined(_WIN32) || defined(__CYGWIN__)
105  bpf_u_int32
106  pcap_nametonetaddr(const char *name _U_)
107  {
108  	return 0;
109  }
110  #else &bsol;* _WIN32 */
111  bpf_u_int32
112  pcap_nametonetaddr(const char *name)
113  {
114  	struct netent *np;
115    #if defined(HAVE_LINUX_GETNETBYNAME_R)
<span onclick='openModal()' class='match'>116  	struct netent result_buf;
117  	char buf[1024];	&bsol;* arbitrary size */
118  	int h_errnoval;
</span>119  	int err;
120  	np = NULL;
121  	err = getnetbyname_r(name, &result_buf, buf, sizeof buf, &np,
122  	    &h_errnoval);
123  	if (err != 0) {
124  		return 0;
125  	}
126    #elif defined(HAVE_SOLARIS_IRIX_GETNETBYNAME_R)
127  	struct netent result_buf;
128  	char buf[1024];	&bsol;* arbitrary size */
129  	np = getnetbyname_r(name, &result_buf, buf, (int)sizeof buf);
130    #elif defined(HAVE_AIX_GETNETBYNAME_R)
131  	struct netent result_buf;
132  	struct netent_data net_data;
133  	if (getnetbyname_r(name, &result_buf, &net_data) == -1)
134  		np = NULL;
135  	else
136  		np = &result_buf;
137    #else
138  	np = getnetbyname(name);
139    #endif
140  	if (np != NULL)
141  		return np->n_net;
142  	else
143  		return 0;
144  }
145  #endif &bsol;* _WIN32 */
146  int
147  pcap_nametoport(const char *name, int *port, int *proto)
148  {
149  	struct addrinfo hints, *res, *ai;
150  	int error;
151  	struct sockaddr_in *in4;
152  #ifdef INET6
153  	struct sockaddr_in6 *in6;
154  #endif
155  	int tcp_port = -1;
156  	int udp_port = -1;
157  	memset(&hints, 0, sizeof(hints));
158  	hints.ai_family = PF_UNSPEC;
159  	hints.ai_socktype = SOCK_STREAM;
160  	hints.ai_protocol = IPPROTO_TCP;
161  	error = getaddrinfo(NULL, name, &hints, &res);
162  	if (error != 0) {
163  		if (error != EAI_NONAME &&
164  		    error != EAI_SERVICE) {
165  			return 0;
166  		}
167  	} else {
168  		for (ai = res; ai != NULL; ai = ai->ai_next) {
169  			if (ai->ai_addr != NULL) {
170  				if (ai->ai_addr->sa_family == AF_INET) {
171  					in4 = (struct sockaddr_in *)ai->ai_addr;
172  					tcp_port = ntohs(in4->sin_port);
173  					break;
174  				}
175  #ifdef INET6
176  				if (ai->ai_addr->sa_family == AF_INET6) {
177  					in6 = (struct sockaddr_in6 *)ai->ai_addr;
178  					tcp_port = ntohs(in6->sin6_port);
179  					break;
180  				}
181  #endif
182  			}
183  		}
184  		freeaddrinfo(res);
185  	}
186  	memset(&hints, 0, sizeof(hints));
187  	hints.ai_family = PF_UNSPEC;
188  	hints.ai_socktype = SOCK_DGRAM;
189  	hints.ai_protocol = IPPROTO_UDP;
190  	error = getaddrinfo(NULL, name, &hints, &res);
191  	if (error != 0) {
192  		if (error != EAI_NONAME &&
193  		    error != EAI_SERVICE) {
194  			return 0;
195  		}
196  	} else {
197  		for (ai = res; ai != NULL; ai = ai->ai_next) {
198  			if (ai->ai_addr != NULL) {
199  				if (ai->ai_addr->sa_family == AF_INET) {
200  					in4 = (struct sockaddr_in *)ai->ai_addr;
201  					udp_port = ntohs(in4->sin_port);
202  					break;
203  				}
204  #ifdef INET6
205  				if (ai->ai_addr->sa_family == AF_INET6) {
206  					in6 = (struct sockaddr_in6 *)ai->ai_addr;
207  					udp_port = ntohs(in6->sin6_port);
208  					break;
209  				}
210  #endif
211  			}
212  		}
213  		freeaddrinfo(res);
214  	}
215  	if (tcp_port >= 0) {
216  		*port = tcp_port;
217  		*proto = IPPROTO_TCP;
218  		if (udp_port >= 0) {
219  			if (udp_port == tcp_port)
220  				*proto = PROTO_UNDEF;
221  #ifdef notdef
222  			else
223  				warning("ambiguous port %s in /etc/services",
224  					name);
225  #endif
226  		}
227  		return 1;
228  	}
229  	if (udp_port >= 0) {
230  		*port = udp_port;
231  		*proto = IPPROTO_UDP;
232  		return 1;
233  	}
234  #if defined(ultrix) || defined(__osf__)
235  	if (strcmp(name, "nfs") == 0) {
236  		*port = 2049;
237  		*proto = PROTO_UNDEF;
238  		return 1;
239  	}
240  #endif
241  	return 0;
242  }
243  int
244  pcap_nametoportrange(const char *name, int *port1, int *port2, int *proto)
245  {
246  	char *off, *cpy;
247  	int save_proto;
248  	if ((cpy = strdup(name)) == NULL)
249  		return 0;
250  	if ((off = strchr(cpy, '-')) == NULL) {
251  		free(cpy);
252  		return 0;
253  	}
254  	*off = '\0';
255  	if (pcap_nametoport(cpy, port1, proto) == 0) {
256  		free(cpy);
257  		return 0;
258  	}
259  	save_proto = *proto;
260  	if (pcap_nametoport(off + 1, port2, proto) == 0) {
261  		free(cpy);
262  		return 0;
263  	}
264  	free(cpy);
265  	if (*proto != save_proto)
266  		*proto = PROTO_UNDEF;
267  	return 1;
268  }
269  int
270  pcap_nametoproto(const char *str)
271  {
272  	struct protoent *p;
273    #if defined(HAVE_LINUX_GETNETBYNAME_R)
274  	struct protoent result_buf;
275  	char buf[1024];	&bsol;* arbitrary size */
276  	int err;
277  	err = getprotobyname_r(str, &result_buf, buf, sizeof buf, &p);
278  	if (err != 0) {
279  		return 0;
280  	}
281    #elif defined(HAVE_SOLARIS_IRIX_GETNETBYNAME_R)
282  	struct protoent result_buf;
283  	char buf[1024];	&bsol;* arbitrary size */
284  	p = getprotobyname_r(str, &result_buf, buf, (int)sizeof buf);
285    #elif defined(HAVE_AIX_GETNETBYNAME_R)
286  	struct protoent result_buf;
287  	struct protoent_data proto_data;
288  	if (getprotobyname_r(str, &result_buf, &proto_data) == -1)
289  		p = NULL;
290  	else
291  		p = &result_buf;
292    #else
293  	p = getprotobyname(str);
294    #endif
295  	if (p != 0)
296  		return p->p_proto;
297  	else
298  		return PROTO_UNDEF;
299  }
300  #include "ethertype.h"
301  struct eproto {
302  	const char *s;
303  	u_short p;
304  };
305  PCAP_API struct eproto eproto_db[];
306  PCAP_API_DEF struct eproto eproto_db[] = {
307  	{ "aarp", ETHERTYPE_AARP },
308  	{ "arp", ETHERTYPE_ARP },
309  	{ "atalk", ETHERTYPE_ATALK },
310  	{ "decnet", ETHERTYPE_DN },
311  	{ "ip", ETHERTYPE_IP },
312  #ifdef INET6
313  	{ "ip6", ETHERTYPE_IPV6 },
314  #endif
315  	{ "lat", ETHERTYPE_LAT },
316  	{ "loopback", ETHERTYPE_LOOPBACK },
317  	{ "mopdl", ETHERTYPE_MOPDL },
318  	{ "moprc", ETHERTYPE_MOPRC },
319  	{ "rarp", ETHERTYPE_REVARP },
320  	{ "sca", ETHERTYPE_SCA },
321  	{ (char *)0, 0 }
322  };
323  int
324  pcap_nametoeproto(const char *s)
325  {
326  	struct eproto *p = eproto_db;
327  	while (p->s != 0) {
328  		if (strcmp(p->s, s) == 0)
329  			return p->p;
330  		p += 1;
331  	}
332  	return PROTO_UNDEF;
333  }
334  #include "llc.h"
335  static struct eproto llc_db[] = {
336  	{ "iso", LLCSAP_ISONS },
337  	{ "stp", LLCSAP_8021D },
338  	{ "ipx", LLCSAP_IPX },
339  	{ "netbeui", LLCSAP_NETBEUI },
340  	{ (char *)0, 0 }
341  };
342  int
343  pcap_nametollc(const char *s)
344  {
345  	struct eproto *p = llc_db;
346  	while (p->s != 0) {
347  		if (strcmp(p->s, s) == 0)
348  			return p->p;
349  		p += 1;
350  	}
351  	return PROTO_UNDEF;
352  }
353  static inline u_char
354  xdtoi(u_char c)
355  {
356  	if (c >= '0' && c <= '9')
357  		return (u_char)(c - '0');
358  	else if (c >= 'a' && c <= 'f')
359  		return (u_char)(c - 'a' + 10);
360  	else
361  		return (u_char)(c - 'A' + 10);
362  }
363  int
364  __pcap_atoin(const char *s, bpf_u_int32 *addr)
365  {
366  	u_int n;
367  	int len;
368  	*addr = 0;
369  	len = 0;
370  	for (;;) {
371  		n = 0;
372  		while (*s && *s != '.') {
373  			if (n > 25) {
374  				return -1;
375  			}
376  			n = n * 10 + *s++ - '0';
377  		}
378  		if (n > 255)
379  			return -1;
380  		*addr <<= 8;
381  		*addr |= n & 0xff;
382  		len += 8;
383  		if (*s == '\0')
384  			return len;
385  		++s;
386  	}
387  }
388  int
389  __pcap_atodn(const char *s, bpf_u_int32 *addr)
390  {
391  #define AREASHIFT 10
392  #define AREAMASK 0176000
393  #define NODEMASK 01777
394  	u_int node = 0, area = 0;
395  	enum {
396  		START,
397  		AREA,
398  		DOT,
399  		NODE,
400  		INVALID
401  	} fsm_state = START;
402  	while (*s) {
403  		switch (fsm_state) {
404  		case START:
405  			if (PCAP_ISDIGIT(*s)) {
406  				area = *s - '0';
407  				fsm_state = AREA;
408  				break;
409  			}
410  			fsm_state = INVALID;
411  			break;
412  		case AREA:
413  			if (*s == '.') {
414  				fsm_state = DOT;
415  				break;
416  			}
417  			if (PCAP_ISDIGIT(*s)) {
418  				area = area * 10 + *s - '0';
419  				if (area <= AREAMASK >> AREASHIFT)
420  					break;
421  			}
422  			fsm_state = INVALID;
423  			break;
424  		case DOT:
425  			if (PCAP_ISDIGIT(*s)) {
426  				node = *s - '0';
427  				fsm_state = NODE;
428  				break;
429  			}
430  			fsm_state = INVALID;
431  			break;
432  		case NODE:
433  			if (PCAP_ISDIGIT(*s)) {
434  				node = node * 10 + *s - '0';
435  				if (node <= NODEMASK)
436  					break;
437  			}
438  			fsm_state = INVALID;
439  			break;
440  		case INVALID:
441  			return 0;
442  		} &bsol;* switch */
443  		s++;
444  	} &bsol;* while */
445  	if (fsm_state != NODE)
446  		return 0;
447  	*addr = area << AREASHIFT | node;
448  	return(32);
449  }
450  u_char *
451  pcap_ether_aton(const char *s)
452  {
453  	register u_char *ep, *e;
454  	register u_char d;
455  	e = ep = (u_char *)malloc(6);
456  	if (e == NULL)
457  		return (NULL);
458  	while (*s) {
459  		if (*s == ':' || *s == '.' || *s == '-')
460  			s += 1;
461  		d = xdtoi(*s++);
462  		if (PCAP_ISXDIGIT(*s)) {
463  			d <<= 4;
464  			d |= xdtoi(*s++);
465  		}
466  		*ep++ = d;
467  	}
468  	return (e);
469  }
470  #ifndef HAVE_ETHER_HOSTTON
471  u_char *
472  pcap_ether_hostton(const char *name)
473  {
474  	register struct pcap_etherent *ep;
475  	register u_char *ap;
476  	static thread_local FILE *fp = NULL;
477  	static thread_local int init = 0;
478  	if (!init) {
479  		fp = fopen(PCAP_ETHERS_FILE, "r");
480  		++init;
481  		if (fp == NULL)
482  			return (NULL);
483  	} else if (fp == NULL)
484  		return (NULL);
485  	else
486  		rewind(fp);
487  	while ((ep = pcap_next_etherent(fp)) != NULL) {
488  		if (strcmp(ep->name, name) == 0) {
489  			ap = (u_char *)malloc(6);
490  			if (ap != NULL) {
491  				memcpy(ap, ep->addr, 6);
492  				return (ap);
493  			}
494  			break;
495  		}
496  	}
497  	return (NULL);
498  }
499  #else
500  u_char *
501  pcap_ether_hostton(const char *name)
502  {
503  	register u_char *ap;
504  	u_char a[6];
505  	char namebuf[1024];
506  	pcap_strlcpy(namebuf, name, sizeof(namebuf));
507  	ap = NULL;
508  	if (ether_hostton(namebuf, (struct ether_addr *)a) == 0) {
509  		ap = (u_char *)malloc(6);
510  		if (ap != NULL)
511  			memcpy((char *)ap, (char *)a, 6);
512  	}
513  	return (ap);
514  }
515  #endif
</code></pre>
        </div>
        <div class="column">
            <h3>libpcap-MDEwOlJlcG9zaXRvcnk5NDM1ODg3-flat-nametoaddr.c</h3>
            <pre><code>1  #ifdef HAVE_CONFIG_H
2  #include <config.h>
3  #endif
4  #ifdef _WIN32
5    #include <winsock2.h>
6    #include <ws2tcpip.h>
7    #ifdef INET6
8      #include <wspiapi.h>
9    #endif &bsol;* INET6 */
10  #else &bsol;* _WIN32 */
11    #include <sys/param.h>
12    #include <sys/types.h>
13    #include <sys/socket.h>
14    #include <sys/time.h>
15    #include <netinet/in.h>
16    #ifdef HAVE_ETHER_HOSTTON
17      #if defined(NET_ETHERNET_H_DECLARES_ETHER_HOSTTON)
18        #include <net/ethernet.h>
19      #elif defined(NETINET_ETHER_H_DECLARES_ETHER_HOSTTON)
20        #include <netinet/ether.h>
21      #elif defined(SYS_ETHERNET_H_DECLARES_ETHER_HOSTTON)
22        #include <sys/ethernet.h>
23      #elif defined(ARPA_INET_H_DECLARES_ETHER_HOSTTON)
24        #include <arpa/inet.h>
25      #elif defined(NETINET_IF_ETHER_H_DECLARES_ETHER_HOSTTON)
26        #define NEED_NETINET_IF_ETHER_H
27      #else
28        #ifdef HAVE_STRUCT_ETHER_ADDR
29          #define NEED_NETINET_IF_ETHER_H
30        #else &bsol;* HAVE_STRUCT_ETHER_ADDR */
31  	struct ether_addr {
32  		unsigned char ether_addr_octet[6];
33  	};
34        #endif &bsol;* HAVE_STRUCT_ETHER_ADDR */
35      #endif &bsol;* what declares ether_hostton() */
36      #ifdef NEED_NETINET_IF_ETHER_H
37        #include <net/if.h>	&bsol;* Needed on some platforms */
38        #include <netinet/in.h>	&bsol;* Needed on some platforms */
39        #include <netinet/if_ether.h>
40      #endif &bsol;* NEED_NETINET_IF_ETHER_H */
41      #ifndef HAVE_DECL_ETHER_HOSTTON
42        extern int ether_hostton(const char *, struct ether_addr *);
43      #endif &bsol;* !defined(HAVE_DECL_ETHER_HOSTTON) */
44    #endif &bsol;* HAVE_ETHER_HOSTTON */
45    #include <arpa/inet.h>
46    #include <netdb.h>
47  #endif &bsol;* _WIN32 */
48  #include <errno.h>
49  #include <stdlib.h>
50  #include <string.h>
51  #include <stdio.h>
52  #include "pcap-int.h"
53  #include "diag-control.h"
54  #include "gencode.h"
55  #include <pcap/namedb.h>
56  #include "nametoaddr.h"
57  #include "thread-local.h"
58  #ifdef HAVE_OS_PROTO_H
59  #include "os-proto.h"
60  #endif
61  #ifndef NTOHL
62  #define NTOHL(x) (x) = ntohl(x)
63  #define NTOHS(x) (x) = ntohs(x)
64  #endif
65  bpf_u_int32 **
66  pcap_nametoaddr(const char *name)
67  {
68  #ifndef h_addr
69  	static bpf_u_int32 *hlist[2];
70  #endif
71  	bpf_u_int32 **p;
72  	struct hostent *hp;
73  DIAG_OFF_DEPRECATION
74  	if ((hp = gethostbyname(name)) != NULL) {
75  DIAG_ON_DEPRECATION
76  #ifndef h_addr
77  		hlist[0] = (bpf_u_int32 *)hp->h_addr;
78  		NTOHL(hp->h_addr);
79  		return hlist;
80  #else
81  		for (p = (bpf_u_int32 **)hp->h_addr_list; *p; ++p)
82  			NTOHL(**p);
83  		return (bpf_u_int32 **)hp->h_addr_list;
84  #endif
85  	}
86  	else
87  		return 0;
88  }
89  struct addrinfo *
90  pcap_nametoaddrinfo(const char *name)
91  {
92  	struct addrinfo hints, *res;
93  	int error;
94  	memset(&hints, 0, sizeof(hints));
95  	hints.ai_family = PF_UNSPEC;
96  	hints.ai_socktype = SOCK_STREAM;	&bsol;*not really*/
97  	hints.ai_protocol = IPPROTO_TCP;	&bsol;*not really*/
98  	error = getaddrinfo(name, NULL, &hints, &res);
99  	if (error)
100  		return NULL;
101  	else
102  		return res;
103  }
104  #if defined(_WIN32) || defined(__CYGWIN__)
105  bpf_u_int32
106  pcap_nametonetaddr(const char *name _U_)
107  {
108  	return 0;
109  }
110  #else &bsol;* _WIN32 */
111  bpf_u_int32
112  pcap_nametonetaddr(const char *name)
113  {
114  	struct netent *np;
115    #if defined(HAVE_LINUX_GETNETBYNAME_R)
116  	struct netent result_buf;
117  	char buf[1024];	&bsol;* arbitrary size */
118  	int h_errnoval;
119  	int err;
120  	np = NULL;
121  	err = getnetbyname_r(name, &result_buf, buf, sizeof buf, &np,
122  	    &h_errnoval);
123  	if (err != 0) {
124  		return 0;
125  	}
126    #elif defined(HAVE_SOLARIS_IRIX_GETNETBYNAME_R)
127  	struct netent result_buf;
128  	char buf[1024];	&bsol;* arbitrary size */
129  	np = getnetbyname_r(name, &result_buf, buf, (int)sizeof buf);
130    #elif defined(HAVE_AIX_GETNETBYNAME_R)
131  	struct netent result_buf;
132  	struct netent_data net_data;
133  	if (getnetbyname_r(name, &result_buf, &net_data) == -1)
134  		np = NULL;
135  	else
136  		np = &result_buf;
137    #else
138  	np = getnetbyname(name);
139    #endif
140  	if (np != NULL)
141  		return np->n_net;
142  	else
143  		return 0;
144  }
145  #endif &bsol;* _WIN32 */
146  int
147  pcap_nametoport(const char *name, int *port, int *proto)
148  {
149  	struct addrinfo hints, *res, *ai;
150  	int error;
151  	struct sockaddr_in *in4;
152  #ifdef INET6
153  	struct sockaddr_in6 *in6;
154  #endif
155  	int tcp_port = -1;
156  	int udp_port = -1;
157  	memset(&hints, 0, sizeof(hints));
158  	hints.ai_family = PF_UNSPEC;
159  	hints.ai_socktype = SOCK_STREAM;
160  	hints.ai_protocol = IPPROTO_TCP;
161  	error = getaddrinfo(NULL, name, &hints, &res);
162  	if (error != 0) {
163  		if (error != EAI_NONAME &&
164  		    error != EAI_SERVICE) {
165  			return 0;
166  		}
167  	} else {
168  		for (ai = res; ai != NULL; ai = ai->ai_next) {
169  			if (ai->ai_addr != NULL) {
170  				if (ai->ai_addr->sa_family == AF_INET) {
171  					in4 = (struct sockaddr_in *)ai->ai_addr;
172  					tcp_port = ntohs(in4->sin_port);
173  					break;
174  				}
175  #ifdef INET6
176  				if (ai->ai_addr->sa_family == AF_INET6) {
177  					in6 = (struct sockaddr_in6 *)ai->ai_addr;
178  					tcp_port = ntohs(in6->sin6_port);
179  					break;
180  				}
181  #endif
182  			}
183  		}
184  		freeaddrinfo(res);
185  	}
186  	memset(&hints, 0, sizeof(hints));
187  	hints.ai_family = PF_UNSPEC;
188  	hints.ai_socktype = SOCK_DGRAM;
189  	hints.ai_protocol = IPPROTO_UDP;
190  	error = getaddrinfo(NULL, name, &hints, &res);
191  	if (error != 0) {
192  		if (error != EAI_NONAME &&
193  		    error != EAI_SERVICE) {
194  			return 0;
195  		}
196  	} else {
197  		for (ai = res; ai != NULL; ai = ai->ai_next) {
198  			if (ai->ai_addr != NULL) {
199  				if (ai->ai_addr->sa_family == AF_INET) {
200  					in4 = (struct sockaddr_in *)ai->ai_addr;
201  					udp_port = ntohs(in4->sin_port);
202  					break;
203  				}
204  #ifdef INET6
205  				if (ai->ai_addr->sa_family == AF_INET6) {
206  					in6 = (struct sockaddr_in6 *)ai->ai_addr;
207  					udp_port = ntohs(in6->sin6_port);
208  					break;
209  				}
210  #endif
211  			}
212  		}
213  		freeaddrinfo(res);
214  	}
215  	if (tcp_port >= 0) {
216  		*port = tcp_port;
217  		*proto = IPPROTO_TCP;
218  		if (udp_port >= 0) {
219  			if (udp_port == tcp_port)
220  				*proto = PROTO_UNDEF;
221  #ifdef notdef
222  			else
223  				warning("ambiguous port %s in /etc/services",
224  					name);
225  #endif
226  		}
227  		return 1;
228  	}
229  	if (udp_port >= 0) {
230  		*port = udp_port;
231  		*proto = IPPROTO_UDP;
232  		return 1;
233  	}
234  #if defined(ultrix) || defined(__osf__)
235  	if (strcmp(name, "nfs") == 0) {
236  		*port = 2049;
237  		*proto = PROTO_UNDEF;
238  		return 1;
239  	}
240  #endif
241  	return 0;
242  }
243  int
244  pcap_nametoportrange(const char *name, int *port1, int *port2, int *proto)
245  {
246  	char *off, *cpy;
247  	int save_proto;
248  	if ((cpy = strdup(name)) == NULL)
249  		return 0;
250  	if ((off = strchr(cpy, '-')) == NULL) {
251  		free(cpy);
252  		return 0;
253  	}
254  	*off = '\0';
255  	if (pcap_nametoport(cpy, port1, proto) == 0) {
256  		free(cpy);
257  		return 0;
258  	}
259  	save_proto = *proto;
260  	if (pcap_nametoport(off + 1, port2, proto) == 0) {
261  		free(cpy);
262  		return 0;
263  	}
264  	free(cpy);
265  	if (*proto != save_proto)
266  		*proto = PROTO_UNDEF;
267  	return 1;
268  }
269  int
270  pcap_nametoproto(const char *str)
271  {
272  	struct protoent *p;
273    #if defined(HAVE_LINUX_GETNETBYNAME_R)
<span onclick='openModal()' class='match'>274  	struct protoent result_buf;
275  	char buf[1024];	&bsol;* arbitrary size */
276  	int err;
</span>277  	err = getprotobyname_r(str, &result_buf, buf, sizeof buf, &p);
278  	if (err != 0) {
279  		return 0;
280  	}
281    #elif defined(HAVE_SOLARIS_IRIX_GETNETBYNAME_R)
282  	struct protoent result_buf;
283  	char buf[1024];	&bsol;* arbitrary size */
284  	p = getprotobyname_r(str, &result_buf, buf, (int)sizeof buf);
285    #elif defined(HAVE_AIX_GETNETBYNAME_R)
286  	struct protoent result_buf;
287  	struct protoent_data proto_data;
288  	if (getprotobyname_r(str, &result_buf, &proto_data) == -1)
289  		p = NULL;
290  	else
291  		p = &result_buf;
292    #else
293  	p = getprotobyname(str);
294    #endif
295  	if (p != 0)
296  		return p->p_proto;
297  	else
298  		return PROTO_UNDEF;
299  }
300  #include "ethertype.h"
301  struct eproto {
302  	const char *s;
303  	u_short p;
304  };
305  PCAP_API struct eproto eproto_db[];
306  PCAP_API_DEF struct eproto eproto_db[] = {
307  	{ "aarp", ETHERTYPE_AARP },
308  	{ "arp", ETHERTYPE_ARP },
309  	{ "atalk", ETHERTYPE_ATALK },
310  	{ "decnet", ETHERTYPE_DN },
311  	{ "ip", ETHERTYPE_IP },
312  #ifdef INET6
313  	{ "ip6", ETHERTYPE_IPV6 },
314  #endif
315  	{ "lat", ETHERTYPE_LAT },
316  	{ "loopback", ETHERTYPE_LOOPBACK },
317  	{ "mopdl", ETHERTYPE_MOPDL },
318  	{ "moprc", ETHERTYPE_MOPRC },
319  	{ "rarp", ETHERTYPE_REVARP },
320  	{ "sca", ETHERTYPE_SCA },
321  	{ (char *)0, 0 }
322  };
323  int
324  pcap_nametoeproto(const char *s)
325  {
326  	struct eproto *p = eproto_db;
327  	while (p->s != 0) {
328  		if (strcmp(p->s, s) == 0)
329  			return p->p;
330  		p += 1;
331  	}
332  	return PROTO_UNDEF;
333  }
334  #include "llc.h"
335  static struct eproto llc_db[] = {
336  	{ "iso", LLCSAP_ISONS },
337  	{ "stp", LLCSAP_8021D },
338  	{ "ipx", LLCSAP_IPX },
339  	{ "netbeui", LLCSAP_NETBEUI },
340  	{ (char *)0, 0 }
341  };
342  int
343  pcap_nametollc(const char *s)
344  {
345  	struct eproto *p = llc_db;
346  	while (p->s != 0) {
347  		if (strcmp(p->s, s) == 0)
348  			return p->p;
349  		p += 1;
350  	}
351  	return PROTO_UNDEF;
352  }
353  static inline u_char
354  xdtoi(u_char c)
355  {
356  	if (c >= '0' && c <= '9')
357  		return (u_char)(c - '0');
358  	else if (c >= 'a' && c <= 'f')
359  		return (u_char)(c - 'a' + 10);
360  	else
361  		return (u_char)(c - 'A' + 10);
362  }
363  int
364  __pcap_atoin(const char *s, bpf_u_int32 *addr)
365  {
366  	u_int n;
367  	int len;
368  	*addr = 0;
369  	len = 0;
370  	for (;;) {
371  		n = 0;
372  		while (*s && *s != '.') {
373  			if (n > 25) {
374  				return -1;
375  			}
376  			n = n * 10 + *s++ - '0';
377  		}
378  		if (n > 255)
379  			return -1;
380  		*addr <<= 8;
381  		*addr |= n & 0xff;
382  		len += 8;
383  		if (*s == '\0')
384  			return len;
385  		++s;
386  	}
387  }
388  int
389  __pcap_atodn(const char *s, bpf_u_int32 *addr)
390  {
391  #define AREASHIFT 10
392  #define AREAMASK 0176000
393  #define NODEMASK 01777
394  	u_int node = 0, area = 0;
395  	enum {
396  		START,
397  		AREA,
398  		DOT,
399  		NODE,
400  		INVALID
401  	} fsm_state = START;
402  	while (*s) {
403  		switch (fsm_state) {
404  		case START:
405  			if (PCAP_ISDIGIT(*s)) {
406  				area = *s - '0';
407  				fsm_state = AREA;
408  				break;
409  			}
410  			fsm_state = INVALID;
411  			break;
412  		case AREA:
413  			if (*s == '.') {
414  				fsm_state = DOT;
415  				break;
416  			}
417  			if (PCAP_ISDIGIT(*s)) {
418  				area = area * 10 + *s - '0';
419  				if (area <= AREAMASK >> AREASHIFT)
420  					break;
421  			}
422  			fsm_state = INVALID;
423  			break;
424  		case DOT:
425  			if (PCAP_ISDIGIT(*s)) {
426  				node = *s - '0';
427  				fsm_state = NODE;
428  				break;
429  			}
430  			fsm_state = INVALID;
431  			break;
432  		case NODE:
433  			if (PCAP_ISDIGIT(*s)) {
434  				node = node * 10 + *s - '0';
435  				if (node <= NODEMASK)
436  					break;
437  			}
438  			fsm_state = INVALID;
439  			break;
440  		case INVALID:
441  			return 0;
442  		} &bsol;* switch */
443  		s++;
444  	} &bsol;* while */
445  	if (fsm_state != NODE)
446  		return 0;
447  	*addr = area << AREASHIFT | node;
448  	return(32);
449  }
450  u_char *
451  pcap_ether_aton(const char *s)
452  {
453  	register u_char *ep, *e;
454  	register u_char d;
455  	e = ep = (u_char *)malloc(6);
456  	if (e == NULL)
457  		return (NULL);
458  	while (*s) {
459  		if (*s == ':' || *s == '.' || *s == '-')
460  			s += 1;
461  		d = xdtoi(*s++);
462  		if (PCAP_ISXDIGIT(*s)) {
463  			d <<= 4;
464  			d |= xdtoi(*s++);
465  		}
466  		*ep++ = d;
467  	}
468  	return (e);
469  }
470  #ifndef HAVE_ETHER_HOSTTON
471  u_char *
472  pcap_ether_hostton(const char *name)
473  {
474  	register struct pcap_etherent *ep;
475  	register u_char *ap;
476  	static thread_local FILE *fp = NULL;
477  	static thread_local int init = 0;
478  	if (!init) {
479  		fp = fopen(PCAP_ETHERS_FILE, "r");
480  		++init;
481  		if (fp == NULL)
482  			return (NULL);
483  	} else if (fp == NULL)
484  		return (NULL);
485  	else
486  		rewind(fp);
487  	while ((ep = pcap_next_etherent(fp)) != NULL) {
488  		if (strcmp(ep->name, name) == 0) {
489  			ap = (u_char *)malloc(6);
490  			if (ap != NULL) {
491  				memcpy(ap, ep->addr, 6);
492  				return (ap);
493  			}
494  			break;
495  		}
496  	}
497  	return (NULL);
498  }
499  #else
500  u_char *
501  pcap_ether_hostton(const char *name)
502  {
503  	register u_char *ap;
504  	u_char a[6];
505  	char namebuf[1024];
506  	pcap_strlcpy(namebuf, name, sizeof(namebuf));
507  	ap = NULL;
508  	if (ether_hostton(namebuf, (struct ether_addr *)a) == 0) {
509  		ap = (u_char *)malloc(6);
510  		if (ap != NULL)
511  			memcpy((char *)ap, (char *)a, 6);
512  	}
513  	return (ap);
514  }
515  #endif
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from libpcap-MDEwOlJlcG9zaXRvcnk5NDM1ODg3-flat-nametoaddr.c</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from libpcap-MDEwOlJlcG9zaXRvcnk5NDM1ODg3-flat-nametoaddr.c</div>
                </div>
                <div class="column column_space"><pre><code>116  	struct netent result_buf;
117  	char buf[1024];	&bsol;* arbitrary size */
118  	int h_errnoval;
</pre></code></div>
                <div class="column column_space"><pre><code>274  	struct protoent result_buf;
275  	char buf[1024];	&bsol;* arbitrary size */
276  	int err;
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    