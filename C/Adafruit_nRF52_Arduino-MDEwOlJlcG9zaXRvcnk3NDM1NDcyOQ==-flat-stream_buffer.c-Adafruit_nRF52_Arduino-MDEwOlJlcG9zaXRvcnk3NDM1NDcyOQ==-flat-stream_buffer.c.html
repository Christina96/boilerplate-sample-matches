
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 47, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>Adafruit_nRF52_Arduino-MDEwOlJlcG9zaXRvcnk3NDM1NDcyOQ==-flat-stream_buffer.c</h3>
            <pre><code>1  #include <stdint.h>
2  #include <string.h>
3  #define MPU_WRAPPERS_INCLUDED_FROM_API_FILE
4  #include "FreeRTOS.h"
5  #include "task.h"
6  #include "stream_buffer.h"
7  #if( configUSE_TASK_NOTIFICATIONS != 1 )
8  	#error configUSE_TASK_NOTIFICATIONS must be set to 1 to build stream_buffer.c
9  #endif
10  #undef MPU_WRAPPERS_INCLUDED_FROM_API_FILE &bsol;*lint !e961 !e750. */
11  #ifndef sbRECEIVE_COMPLETED
12  	#define sbRECEIVE_COMPLETED( pxStreamBuffer )										\
13  		vTaskSuspendAll();																\
14  		{																				\
15  			if( ( pxStreamBuffer )->xTaskWaitingToSend != NULL )						\
16  			{																			\
17  				( void ) xTaskNotify( ( pxStreamBuffer )->xTaskWaitingToSend,			\
18  									  ( uint32_t ) 0,									\
19  									  eNoAction );										\
20  				( pxStreamBuffer )->xTaskWaitingToSend = NULL;							\
21  			}																			\
22  		}																				\
23  		( void ) xTaskResumeAll();
24  #endif &bsol;* sbRECEIVE_COMPLETED */
25  #ifndef sbRECEIVE_COMPLETED_FROM_ISR
26  	#define sbRECEIVE_COMPLETED_FROM_ISR( pxStreamBuffer,								\
27  										  pxHigherPriorityTaskWoken )					\
28  	{																					\
29  	UBaseType_t uxSavedInterruptStatus;													\
30  																						\
31  		uxSavedInterruptStatus = ( UBaseType_t ) portSET_INTERRUPT_MASK_FROM_ISR();		\
32  		{																				\
33  			if( ( pxStreamBuffer )->xTaskWaitingToSend != NULL )						\
34  			{																			\
35  				( void ) xTaskNotifyFromISR( ( pxStreamBuffer )->xTaskWaitingToSend,	\
36  											 ( uint32_t ) 0,							\
37  											 eNoAction,									\
38  											 pxHigherPriorityTaskWoken );				\
39  				( pxStreamBuffer )->xTaskWaitingToSend = NULL;							\
40  			}																			\
41  		}																				\
42  		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );					\
43  	}
44  #endif &bsol;* sbRECEIVE_COMPLETED_FROM_ISR */
45  #ifndef sbSEND_COMPLETED
46  	#define sbSEND_COMPLETED( pxStreamBuffer )											\
47  		vTaskSuspendAll();																\
48  		{																				\
49  			if( ( pxStreamBuffer )->xTaskWaitingToReceive != NULL )						\
50  			{																			\
51  				( void ) xTaskNotify( ( pxStreamBuffer )->xTaskWaitingToReceive,		\
52  									  ( uint32_t ) 0,									\
53  									  eNoAction );										\
54  				( pxStreamBuffer )->xTaskWaitingToReceive = NULL;						\
55  			}																			\
56  		}																				\
57  		( void ) xTaskResumeAll();
58  #endif &bsol;* sbSEND_COMPLETED */
59  #ifndef sbSEND_COMPLETE_FROM_ISR
60  	#define sbSEND_COMPLETE_FROM_ISR( pxStreamBuffer, pxHigherPriorityTaskWoken )		\
61  	{																					\
62  	UBaseType_t uxSavedInterruptStatus;													\
63  																						\
64  		uxSavedInterruptStatus = ( UBaseType_t ) portSET_INTERRUPT_MASK_FROM_ISR();		\
65  		{																				\
66  			if( ( pxStreamBuffer )->xTaskWaitingToReceive != NULL )						\
67  			{																			\
68  				( void ) xTaskNotifyFromISR( ( pxStreamBuffer )->xTaskWaitingToReceive,	\
69  											 ( uint32_t ) 0,							\
70  											 eNoAction,									\
71  											 pxHigherPriorityTaskWoken );				\
72  				( pxStreamBuffer )->xTaskWaitingToReceive = NULL;						\
73  			}																			\
74  		}																				\
75  		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );					\
76  	}
77  #endif &bsol;* sbSEND_COMPLETE_FROM_ISR */
78  #define sbBYTES_TO_STORE_MESSAGE_LENGTH ( sizeof( size_t ) )
79  #define sbFLAGS_IS_MESSAGE_BUFFER		( ( uint8_t ) 1 ) &bsol;* Set if the stream buffer was created as a message buffer, in which case it holds discrete messages rather than a stream. */
80  #define sbFLAGS_IS_STATICALLY_ALLOCATED ( ( uint8_t ) 2 ) &bsol;* Set if the stream buffer was created using statically allocated memory. */
81  typedef struct xSTREAM_BUFFER &bsol;*lint !e9058 Style convention uses tag. */
82  {
83  	volatile size_t xTail;				&bsol;* Index to the next item to read within the buffer. */
84  	volatile size_t xHead;				&bsol;* Index to the next item to write within the buffer. */
85  	size_t xLength;						&bsol;* The length of the buffer pointed to by pucBuffer. */
86  	size_t xTriggerLevelBytes;			&bsol;* The number of bytes that must be in the stream buffer before a task that is waiting for data is unblocked. */
87  	volatile TaskHandle_t xTaskWaitingToReceive; &bsol;* Holds the handle of a task waiting for data, or NULL if no tasks are waiting. */
88  	volatile TaskHandle_t xTaskWaitingToSend;	&bsol;* Holds the handle of a task waiting to send data to a message buffer that is full. */
89  	uint8_t *pucBuffer;					&bsol;* Points to the buffer itself - that is - the RAM that stores the data passed through the buffer. */
90  	uint8_t ucFlags;
91  	#if ( configUSE_TRACE_FACILITY == 1 )
92  		UBaseType_t uxStreamBufferNumber;		&bsol;* Used for tracing purposes. */
93  	#endif
94  } StreamBuffer_t;
95  static size_t prvBytesInBuffer( const StreamBuffer_t * const pxStreamBuffer ) PRIVILEGED_FUNCTION;
96  static size_t prvWriteBytesToBuffer( StreamBuffer_t * const pxStreamBuffer, const uint8_t *pucData, size_t xCount ) PRIVILEGED_FUNCTION;
97  static size_t prvReadMessageFromBuffer( StreamBuffer_t *pxStreamBuffer,
98  										void *pvRxData,
99  										size_t xBufferLengthBytes,
100  										size_t xBytesAvailable,
101  										size_t xBytesToStoreMessageLength ) PRIVILEGED_FUNCTION;
102  static size_t prvWriteMessageToBuffer(  StreamBuffer_t * const pxStreamBuffer,
103  										const void * pvTxData,
104  										size_t xDataLengthBytes,
105  										size_t xSpace,
106  										size_t xRequiredSpace ) PRIVILEGED_FUNCTION;
107  static size_t prvReadBytesFromBuffer( StreamBuffer_t *pxStreamBuffer,
108  									  uint8_t *pucData,
109  									  size_t xMaxCount,
110  									  size_t xBytesAvailable ); PRIVILEGED_FUNCTION
111  static void prvInitialiseNewStreamBuffer( StreamBuffer_t * const pxStreamBuffer,
112  										  uint8_t * const pucBuffer,
113  										  size_t xBufferSizeBytes,
114  										  size_t xTriggerLevelBytes,
115  										  BaseType_t xIsMessageBuffer ) PRIVILEGED_FUNCTION;
116  #if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )
117  	StreamBufferHandle_t xStreamBufferGenericCreate( size_t xBufferSizeBytes, size_t xTriggerLevelBytes, BaseType_t xIsMessageBuffer )
118  	{
119  	uint8_t *pucAllocatedMemory;
120  		configASSERT( xBufferSizeBytes > sbBYTES_TO_STORE_MESSAGE_LENGTH );
121  		configASSERT( xTriggerLevelBytes <= xBufferSizeBytes );
122  		if( xTriggerLevelBytes == ( size_t ) 0 )
123  		{
124  			xTriggerLevelBytes = ( size_t ) 1; &bsol;*lint !e9044 Parameter modified to ensure it doesn't have a dangerous value. */
125  		}
126  		xBufferSizeBytes++;
127  		pucAllocatedMemory = ( uint8_t * ) pvPortMalloc( xBufferSizeBytes + sizeof( StreamBuffer_t ) ); &bsol;*lint !e9079 malloc() only returns void*. */
128  		if( pucAllocatedMemory != NULL )
129  		{
130  			prvInitialiseNewStreamBuffer( ( StreamBuffer_t * ) pucAllocatedMemory, &bsol;* Structure at the start of the allocated memory. */ &bsol;*lint !e9087 Safe cast as allocated memory is aligned. */ &bsol;*lint !e826 Area is not too small and alignment is guaranteed provided malloc() behaves as expected and returns aligned buffer. */
131  										   pucAllocatedMemory + sizeof( StreamBuffer_t ),  &bsol;* Storage area follows. */ &bsol;*lint !e9016 Indexing past structure valid for uint8_t pointer, also storage area has no alignment requirement. */
132  										   xBufferSizeBytes,
133  										   xTriggerLevelBytes,
134  										   xIsMessageBuffer );
135  			traceSTREAM_BUFFER_CREATE( ( ( StreamBuffer_t * ) pucAllocatedMemory ), xIsMessageBuffer );
136  		}
137  		else
138  		{
139  			traceSTREAM_BUFFER_CREATE_FAILED( xIsMessageBuffer );
140  		}
141  		return ( StreamBufferHandle_t * ) pucAllocatedMemory; &bsol;*lint !e9087 !e826 Safe cast as allocated memory is aligned. */
142  	}
143  #endif &bsol;* configSUPPORT_DYNAMIC_ALLOCATION */
144  #if( configSUPPORT_STATIC_ALLOCATION == 1 )
145  	StreamBufferHandle_t xStreamBufferGenericCreateStatic( size_t xBufferSizeBytes,
146  														   size_t xTriggerLevelBytes,
147  														   BaseType_t xIsMessageBuffer,
148  														   uint8_t * const pucStreamBufferStorageArea,
149  														   StaticStreamBuffer_t * const pxStaticStreamBuffer )
150  	{
151  	StreamBuffer_t * const pxStreamBuffer = ( StreamBuffer_t * ) pxStaticStreamBuffer; &bsol;*lint !e740 !e9087 Safe cast as StaticStreamBuffer_t is opaque Streambuffer_t. */
152  	StreamBufferHandle_t xReturn;
153  		configASSERT( pucStreamBufferStorageArea );
154  		configASSERT( pxStaticStreamBuffer );
155  		configASSERT( xTriggerLevelBytes <= xBufferSizeBytes );
156  		if( xTriggerLevelBytes == ( size_t ) 0 )
157  		{
158  			xTriggerLevelBytes = ( size_t ) 1; &bsol;*lint !e9044 Function parameter deliberately modified to ensure it is in range. */
159  		}
160  		configASSERT( xBufferSizeBytes > sbBYTES_TO_STORE_MESSAGE_LENGTH );
161  		#if( configASSERT_DEFINED == 1 )
162  		{
163  			volatile size_t xSize = sizeof( StaticStreamBuffer_t );
164  			configASSERT( xSize == sizeof( StreamBuffer_t ) );
165  		}
166  		#endif &bsol;* configASSERT_DEFINED */
167  		if( ( pucStreamBufferStorageArea != NULL ) && ( pxStaticStreamBuffer != NULL ) )
168  		{
169  			prvInitialiseNewStreamBuffer( pxStreamBuffer,
170  										  pucStreamBufferStorageArea,
171  										  xBufferSizeBytes,
172  										  xTriggerLevelBytes,
173  										  xIsMessageBuffer );
174  			pxStreamBuffer->ucFlags |= sbFLAGS_IS_STATICALLY_ALLOCATED;
175  			traceSTREAM_BUFFER_CREATE( pxStreamBuffer, xIsMessageBuffer );
176  			xReturn = ( StreamBufferHandle_t ) pxStaticStreamBuffer; &bsol;*lint !e9087 Data hiding requires cast to opaque type. */
177  		}
178  		else
179  		{
180  			xReturn = NULL;
181  			traceSTREAM_BUFFER_CREATE_STATIC_FAILED( xReturn, xIsMessageBuffer );
182  		}
183  		return xReturn;
184  	}
185  #endif &bsol;* ( configSUPPORT_STATIC_ALLOCATION == 1 ) */
186  void vStreamBufferDelete( StreamBufferHandle_t xStreamBuffer )
187  {
188  StreamBuffer_t * pxStreamBuffer = ( StreamBuffer_t * ) xStreamBuffer; &bsol;*lint !e9087 !e9079 Safe cast as StreamBufferHandle_t is opaque Streambuffer_t. */
189  	configASSERT( pxStreamBuffer );
190  	traceSTREAM_BUFFER_DELETE( xStreamBuffer );
191  	if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_STATICALLY_ALLOCATED ) == ( uint8_t ) pdFALSE )
192  	{
193  		#if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )
194  		{
195  			vPortFree( ( void * ) pxStreamBuffer ); &bsol;*lint !e9087 Standard free() semantics require void *, plus pxStreamBuffer was allocated by pvPortMalloc(). */
196  		}
197  		#else
198  		{
199  			configASSERT( xStreamBuffer == ( StreamBufferHandle_t ) ~0 );
200  		}
201  		#endif
202  	}
203  	else
204  	{
205  		memset( pxStreamBuffer, 0x00, sizeof( StreamBuffer_t ) );
206  	}
207  }
208  BaseType_t xStreamBufferReset( StreamBufferHandle_t xStreamBuffer )
209  {
210  StreamBuffer_t * const pxStreamBuffer = ( StreamBuffer_t * ) xStreamBuffer; &bsol;*lint !e9087 !e9079 Safe cast as StreamBufferHandle_t is opaque Streambuffer_t. */
211  BaseType_t xReturn = pdFAIL, xIsMessageBuffer;
212  #if( configUSE_TRACE_FACILITY == 1 )
213  	UBaseType_t uxStreamBufferNumber;
214  #endif
215  	configASSERT( pxStreamBuffer );
216  	#if( configUSE_TRACE_FACILITY == 1 )
217  	{
218  		uxStreamBufferNumber = pxStreamBuffer->uxStreamBufferNumber;
219  	}
220  	#endif
221  	if( pxStreamBuffer->xTaskWaitingToReceive == NULL )
222  	{
223  		if( pxStreamBuffer->xTaskWaitingToSend == NULL )
224  		{
225  			if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) != ( uint8_t ) 0 )
226  			{
227  				xIsMessageBuffer = pdTRUE;
228  			}
229  			else
230  			{
231  				xIsMessageBuffer = pdFALSE;
232  			}
233  			prvInitialiseNewStreamBuffer( pxStreamBuffer,
234  										  pxStreamBuffer->pucBuffer,
235  										  pxStreamBuffer->xLength,
236  										  pxStreamBuffer->xTriggerLevelBytes,
237  										  xIsMessageBuffer );
238  			xReturn = pdPASS;
239  			#if( configUSE_TRACE_FACILITY == 1 )
240  			{
241  				pxStreamBuffer->uxStreamBufferNumber = uxStreamBufferNumber;
242  			}
243  			#endif
244  			traceSTREAM_BUFFER_RESET( xStreamBuffer );
245  		}
246  	}
247  	return xReturn;
248  }
249  BaseType_t xStreamBufferSetTriggerLevel( StreamBufferHandle_t xStreamBuffer, size_t xTriggerLevel )
250  {
251  StreamBuffer_t * const pxStreamBuffer = ( StreamBuffer_t * ) xStreamBuffer; &bsol;*lint !e9087 !e9079 Safe cast as StreamBufferHandle_t is opaque Streambuffer_t. */
252  BaseType_t xReturn;
253  	configASSERT( pxStreamBuffer );
254  	if( xTriggerLevel == ( size_t ) 0 )
255  	{
256  		xTriggerLevel = ( size_t ) 1; &bsol;*lint !e9044 Parameter modified to ensure it doesn't have a dangerous value. */
257  	}
258  	if( xTriggerLevel <= pxStreamBuffer->xLength )
259  	{
260  		pxStreamBuffer->xTriggerLevelBytes = xTriggerLevel;
261  		xReturn = pdPASS;
262  	}
263  	else
264  	{
265  		xReturn = pdFALSE;
266  	}
267  	return xReturn;
268  }
269  size_t xStreamBufferSpacesAvailable( StreamBufferHandle_t xStreamBuffer )
270  {
271  const StreamBuffer_t * const pxStreamBuffer = ( StreamBuffer_t * ) xStreamBuffer; &bsol;*lint !e9087 !e9079 Safe cast as StreamBufferHandle_t is opaque Streambuffer_t. */
272  size_t xSpace;
273  	configASSERT( pxStreamBuffer );
274  	xSpace = pxStreamBuffer->xLength + pxStreamBuffer->xTail;
275  	xSpace -= pxStreamBuffer->xHead;
276  	xSpace -= ( size_t ) 1;
277  	if( xSpace >= pxStreamBuffer->xLength )
278  	{
279  		xSpace -= pxStreamBuffer->xLength;
280  	}
281  	else
282  	{
283  		mtCOVERAGE_TEST_MARKER();
284  	}
285  	return xSpace;
286  }
287  size_t xStreamBufferBytesAvailable( StreamBufferHandle_t xStreamBuffer )
288  {
289  const StreamBuffer_t * const pxStreamBuffer = ( StreamBuffer_t * ) xStreamBuffer; &bsol;*lint !e9087 !e9079 Safe cast as StreamBufferHandle_t is opaque Streambuffer_t. */
290  size_t xReturn;
291  	configASSERT( pxStreamBuffer );
292  	xReturn = prvBytesInBuffer( pxStreamBuffer );
293  	return xReturn;
294  }
295  size_t xStreamBufferSend( StreamBufferHandle_t xStreamBuffer,
296  						  const void *pvTxData,
297  						  size_t xDataLengthBytes,
298  						  TickType_t xTicksToWait )
299  {
300  StreamBuffer_t * const pxStreamBuffer = ( StreamBuffer_t * ) xStreamBuffer; &bsol;*lint !e9087 !e9079 Safe cast as StreamBufferHandle_t is opaque Streambuffer_t. */
301  size_t xReturn, xSpace = 0;
302  size_t xRequiredSpace = xDataLengthBytes;
303  TimeOut_t xTimeOut;
304  	configASSERT( pvTxData );
305  	configASSERT( pxStreamBuffer );
306  	if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) != ( uint8_t ) 0 )
307  	{
308  		xRequiredSpace += sbBYTES_TO_STORE_MESSAGE_LENGTH;
309  	}
310  	else
311  	{
312  		mtCOVERAGE_TEST_MARKER();
313  	}
314  	if( xTicksToWait != ( TickType_t ) 0 )
315  	{
316  		vTaskSetTimeOutState( &xTimeOut );
317  		do
318  		{
319  			taskENTER_CRITICAL();
320  			{
321  				xSpace = xStreamBufferSpacesAvailable( pxStreamBuffer );
322  				if( xSpace < xRequiredSpace )
323  				{
324  					( void ) xTaskNotifyStateClear( NULL );
325  					configASSERT( pxStreamBuffer->xTaskWaitingToSend == NULL );
326  					pxStreamBuffer->xTaskWaitingToSend = xTaskGetCurrentTaskHandle();
327  				}
328  				else
329  				{
330  					taskEXIT_CRITICAL();
331  					break;
332  				}
333  			}
334  			taskEXIT_CRITICAL();
335  			traceBLOCKING_ON_STREAM_BUFFER_SEND( xStreamBuffer );
336  			( void ) xTaskNotifyWait( ( uint32_t ) 0, UINT32_MAX, NULL, xTicksToWait );
337  			pxStreamBuffer->xTaskWaitingToSend = NULL;
338  		} while( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE );
339  	}
340  	else
341  	{
342  		mtCOVERAGE_TEST_MARKER();
343  	}
344  	if( xSpace == ( size_t ) 0 )
345  	{
346  		xSpace = xStreamBufferSpacesAvailable( pxStreamBuffer );
347  	}
348  	else
349  	{
350  		mtCOVERAGE_TEST_MARKER();
351  	}
352  	xReturn = prvWriteMessageToBuffer( pxStreamBuffer, pvTxData, xDataLengthBytes, xSpace, xRequiredSpace );
353  	if( xReturn > ( size_t ) 0 )
354  	{
355  		traceSTREAM_BUFFER_SEND( xStreamBuffer, xReturn );
356  		if( prvBytesInBuffer( pxStreamBuffer ) >= pxStreamBuffer->xTriggerLevelBytes )
357  		{
358  			sbSEND_COMPLETED( pxStreamBuffer );
359  		}
360  		else
361  		{
362  			mtCOVERAGE_TEST_MARKER();
363  		}
364  	}
365  	else
366  	{
367  		mtCOVERAGE_TEST_MARKER();
368  		traceSTREAM_BUFFER_SEND_FAILED( xStreamBuffer );
369  	}
370  	return xReturn;
371  }
372  size_t xStreamBufferSendFromISR( StreamBufferHandle_t xStreamBuffer,
373  								 const void *pvTxData,
374  								 size_t xDataLengthBytes,
375  								 BaseType_t * const pxHigherPriorityTaskWoken )
376  {
377  StreamBuffer_t * const pxStreamBuffer = ( StreamBuffer_t * ) xStreamBuffer; &bsol;*lint !e9087 !e9079 Safe cast as StreamBufferHandle_t is opaque Streambuffer_t. */
378  size_t xReturn, xSpace;
379  size_t xRequiredSpace = xDataLengthBytes;
380  	configASSERT( pvTxData );
381  	configASSERT( pxStreamBuffer );
382  	if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) != ( uint8_t ) 0 )
383  	{
384  		xRequiredSpace += sbBYTES_TO_STORE_MESSAGE_LENGTH;
385  	}
386  	else
387  	{
388  		mtCOVERAGE_TEST_MARKER();
389  	}
390  	xSpace = xStreamBufferSpacesAvailable( pxStreamBuffer );
391  	xReturn = prvWriteMessageToBuffer( pxStreamBuffer, pvTxData, xDataLengthBytes, xSpace, xRequiredSpace );
392  	if( xReturn > ( size_t ) 0 )
393  	{
394  		if( prvBytesInBuffer( pxStreamBuffer ) >= pxStreamBuffer->xTriggerLevelBytes )
395  		{
396  			sbSEND_COMPLETE_FROM_ISR( pxStreamBuffer, pxHigherPriorityTaskWoken );
397  		}
398  		else
399  		{
400  			mtCOVERAGE_TEST_MARKER();
401  		}
402  	}
403  	else
404  	{
405  		mtCOVERAGE_TEST_MARKER();
406  	}
407  	traceSTREAM_BUFFER_SEND_FROM_ISR( xStreamBuffer, xReturn );
408  	return xReturn;
409  }
410  static size_t prvWriteMessageToBuffer( StreamBuffer_t * const pxStreamBuffer,
411  									   const void * pvTxData,
412  									   size_t xDataLengthBytes,
413  									   size_t xSpace,
414  									   size_t xRequiredSpace )
415  {
416  	BaseType_t xShouldWrite;
417  	size_t xReturn;
418  	if( xSpace == ( size_t ) 0 )
419  	{
420  		xShouldWrite = pdFALSE;
421  	}
422  	else if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) == ( uint8_t ) 0 )
423  	{
424  		xShouldWrite = pdTRUE;
425  		xDataLengthBytes = configMIN( xDataLengthBytes, xSpace ); &bsol;*lint !e9044 Function parameter modified to ensure it is capped to available space. */
426  	}
427  	else if( xSpace >= xRequiredSpace )
428  	{
429  		xShouldWrite = pdTRUE;
430  		( void ) prvWriteBytesToBuffer( pxStreamBuffer, ( const uint8_t * ) &( xDataLengthBytes ), sbBYTES_TO_STORE_MESSAGE_LENGTH );
431  	}
432  	else
433  	{
434  		xShouldWrite = pdFALSE;
435  	}
436  	if( xShouldWrite != pdFALSE )
437  	{
438  		xReturn = prvWriteBytesToBuffer( pxStreamBuffer, ( const uint8_t * ) pvTxData, xDataLengthBytes ); &bsol;*lint !e9079 Storage buffer is implemented as uint8_t for ease of sizing, alighment and access. */
439  	}
440  	else
441  	{
442  		xReturn = 0;
443  	}
444  	return xReturn;
445  }
446  size_t xStreamBufferReceive( StreamBufferHandle_t xStreamBuffer,
447  							 void *pvRxData,
448  							 size_t xBufferLengthBytes,
449  							 TickType_t xTicksToWait )
450  {
451  StreamBuffer_t * const pxStreamBuffer = ( StreamBuffer_t * ) xStreamBuffer; &bsol;*lint !e9087 !e9079 Safe cast as StreamBufferHandle_t is opaque Streambuffer_t. */
452  size_t xReceivedLength = 0, xBytesAvailable, xBytesToStoreMessageLength;
453  	configASSERT( pvRxData );
454  	configASSERT( pxStreamBuffer );
455  	if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) != ( uint8_t ) 0 )
456  	{
457  		xBytesToStoreMessageLength = sbBYTES_TO_STORE_MESSAGE_LENGTH;
458  	}
459  	else
460  	{
461  		xBytesToStoreMessageLength = 0;
462  	}
463  	if( xTicksToWait != ( TickType_t ) 0 )
464  	{
465  		taskENTER_CRITICAL();
466  		{
467  			xBytesAvailable = prvBytesInBuffer( pxStreamBuffer );
468  			if( xBytesAvailable <= xBytesToStoreMessageLength )
469  			{
470  				( void ) xTaskNotifyStateClear( NULL );
471  				configASSERT( pxStreamBuffer->xTaskWaitingToReceive == NULL );
472  				pxStreamBuffer->xTaskWaitingToReceive = xTaskGetCurrentTaskHandle();
473  			}
474  			else
475  			{
476  				mtCOVERAGE_TEST_MARKER();
477  			}
478  		}
479  		taskEXIT_CRITICAL();
480  		if( xBytesAvailable <= xBytesToStoreMessageLength )
481  		{
482  			traceBLOCKING_ON_STREAM_BUFFER_RECEIVE( xStreamBuffer );
483  			( void ) xTaskNotifyWait( ( uint32_t ) 0, UINT32_MAX, NULL, xTicksToWait );
484  			pxStreamBuffer->xTaskWaitingToReceive = NULL;
485  			xBytesAvailable = prvBytesInBuffer( pxStreamBuffer );
486  		}
487  		else
488  		{
489  			mtCOVERAGE_TEST_MARKER();
490  		}
491  	}
492  	else
493  	{
494  		xBytesAvailable = prvBytesInBuffer( pxStreamBuffer );
495  	}
496  	if( xBytesAvailable > xBytesToStoreMessageLength )
497  	{
498  		xReceivedLength = prvReadMessageFromBuffer( pxStreamBuffer, pvRxData, xBufferLengthBytes, xBytesAvailable, xBytesToStoreMessageLength );
499  		if( xReceivedLength != ( size_t ) 0 )
500  		{
501  			traceSTREAM_BUFFER_RECEIVE( xStreamBuffer, xReceivedLength );
502  			sbRECEIVE_COMPLETED( pxStreamBuffer );
503  		}
504  		else
505  		{
506  			mtCOVERAGE_TEST_MARKER();
507  		}
508  	}
509  	else
510  	{
511  		traceSTREAM_BUFFER_RECEIVE_FAILED( xStreamBuffer );
512  		mtCOVERAGE_TEST_MARKER();
513  	}
514  	return xReceivedLength;
515  }
516  size_t xStreamBufferReceiveFromISR( StreamBufferHandle_t xStreamBuffer,
517  									void *pvRxData,
518  									size_t xBufferLengthBytes,
519  									BaseType_t * const pxHigherPriorityTaskWoken )
520  {
521  StreamBuffer_t * const pxStreamBuffer = ( StreamBuffer_t * ) xStreamBuffer; &bsol;*lint !e9087 !e9079 Safe cast as StreamBufferHandle_t is opaque Streambuffer_t. */
<span onclick='openModal()' class='match'>522  size_t xReceivedLength = 0, xBytesAvailable, xBytesToStoreMessageLength;
523  	configASSERT( pvRxData );
524  	configASSERT( pxStreamBuffer );
525  	if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) != ( uint8_t ) 0 )
526  	{
527  		xBytesToStoreMessageLength = sbBYTES_TO_STORE_MESSAGE_LENGTH;
528  	}
529  	else
530  	{
531  		xBytesToStoreMessageLength = 0;
532  	}
533  	xBytesAvailable = prvBytesInBuffer( pxStreamBuffer );
</span>534  	if( xBytesAvailable > xBytesToStoreMessageLength )
535  	{
536  		xReceivedLength = prvReadMessageFromBuffer( pxStreamBuffer, pvRxData, xBufferLengthBytes, xBytesAvailable, xBytesToStoreMessageLength );
537  		if( xReceivedLength != ( size_t ) 0 )
538  		{
539  			sbRECEIVE_COMPLETED_FROM_ISR( pxStreamBuffer, pxHigherPriorityTaskWoken );
540  		}
541  		else
542  		{
543  			mtCOVERAGE_TEST_MARKER();
544  		}
545  	}
546  	else
547  	{
548  		mtCOVERAGE_TEST_MARKER();
549  	}
550  	traceSTREAM_BUFFER_RECEIVE_FROM_ISR( xStreamBuffer, xReceivedLength );
551  	return xReceivedLength;
552  }
553  static size_t prvReadMessageFromBuffer( StreamBuffer_t *pxStreamBuffer,
554  										void *pvRxData,
555  										size_t xBufferLengthBytes,
556  										size_t xBytesAvailable,
557  										size_t xBytesToStoreMessageLength )
558  {
559  size_t xOriginalTail, xReceivedLength, xNextMessageLength;
560  	if( xBytesToStoreMessageLength != ( size_t ) 0 )
561  	{
562  		xOriginalTail = pxStreamBuffer->xTail;
563  		( void ) prvReadBytesFromBuffer( pxStreamBuffer, ( uint8_t * ) &xNextMessageLength, xBytesToStoreMessageLength, xBytesAvailable );
564  		xBytesAvailable -= xBytesToStoreMessageLength;
565  		if( xNextMessageLength > xBufferLengthBytes )
566  		{
567  			pxStreamBuffer->xTail = xOriginalTail;
568  			xNextMessageLength = 0;
569  		}
570  		else
571  		{
572  			mtCOVERAGE_TEST_MARKER();
573  		}
574  	}
575  	else
576  	{
577  		xNextMessageLength = xBufferLengthBytes;
578  	}
579  	xReceivedLength = prvReadBytesFromBuffer( pxStreamBuffer, ( uint8_t * ) pvRxData, xNextMessageLength, xBytesAvailable ); &bsol;*lint !e9079 Data storage area is implemented as uint8_t array for ease of sizing, indexing and alignment. */
580  	return xReceivedLength;
581  }
582  BaseType_t xStreamBufferIsEmpty( StreamBufferHandle_t xStreamBuffer )
583  {
584  const StreamBuffer_t * const pxStreamBuffer = ( StreamBuffer_t * ) xStreamBuffer; &bsol;*lint !e9087 !e9079 Safe cast as StreamBufferHandle_t is opaque Streambuffer_t. */
585  BaseType_t xReturn;
586  size_t xTail;
587  	configASSERT( pxStreamBuffer );
588  	xTail = pxStreamBuffer->xTail;
589  	if( pxStreamBuffer->xHead == xTail )
590  	{
591  		xReturn = pdTRUE;
592  	}
593  	else
594  	{
595  		xReturn = pdFALSE;
596  	}
597  	return xReturn;
598  }
599  BaseType_t xStreamBufferIsFull( StreamBufferHandle_t xStreamBuffer )
600  {
601  BaseType_t xReturn;
602  size_t xBytesToStoreMessageLength;
603  const StreamBuffer_t * const pxStreamBuffer = ( StreamBuffer_t * ) xStreamBuffer; &bsol;*lint !e9087 !e9079 Safe cast as StreamBufferHandle_t is opaque Streambuffer_t. */
604  	configASSERT( pxStreamBuffer );
605  	if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) != ( uint8_t ) 0 )
606  	{
607  		xBytesToStoreMessageLength = sbBYTES_TO_STORE_MESSAGE_LENGTH;
608  	}
609  	else
610  	{
611  		xBytesToStoreMessageLength = 0;
612  	}
613  	if( xStreamBufferSpacesAvailable( xStreamBuffer ) <= xBytesToStoreMessageLength )
614  	{
615  		xReturn = pdTRUE;
616  	}
617  	else
618  	{
619  		xReturn = pdFALSE;
620  	}
621  	return xReturn;
622  }
623  BaseType_t xStreamBufferSendCompletedFromISR( StreamBufferHandle_t xStreamBuffer, BaseType_t *pxHigherPriorityTaskWoken )
624  {
625  StreamBuffer_t * const pxStreamBuffer = ( StreamBuffer_t * ) xStreamBuffer; &bsol;*lint !e9087 !e9079 Safe cast as StreamBufferHandle_t is opaque Streambuffer_t. */
626  BaseType_t xReturn;
627  UBaseType_t uxSavedInterruptStatus;
628  	configASSERT( pxStreamBuffer );
629  	uxSavedInterruptStatus = ( UBaseType_t ) portSET_INTERRUPT_MASK_FROM_ISR();
630  	{
631  		if( ( pxStreamBuffer )->xTaskWaitingToReceive != NULL )
632  		{
633  			( void ) xTaskNotifyFromISR( ( pxStreamBuffer )->xTaskWaitingToReceive,
634  										 ( uint32_t ) 0,
635  										 eNoAction,
636  										 pxHigherPriorityTaskWoken );
637  			( pxStreamBuffer )->xTaskWaitingToReceive = NULL;
638  			xReturn = pdTRUE;
639  		}
640  		else
641  		{
642  			xReturn = pdFALSE;
643  		}
644  	}
645  	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
646  	return xReturn;
647  }
648  BaseType_t xStreamBufferReceiveCompletedFromISR( StreamBufferHandle_t xStreamBuffer, BaseType_t *pxHigherPriorityTaskWoken )
649  {
650  StreamBuffer_t * const pxStreamBuffer = ( StreamBuffer_t * ) xStreamBuffer; &bsol;*lint !e9087 !e9079 Safe cast as StreamBufferHandle_t is opaque Streambuffer_t. */
651  BaseType_t xReturn;
652  UBaseType_t uxSavedInterruptStatus;
653  	configASSERT( pxStreamBuffer );
654  	uxSavedInterruptStatus = ( UBaseType_t ) portSET_INTERRUPT_MASK_FROM_ISR();
655  	{
656  		if( ( pxStreamBuffer )->xTaskWaitingToSend != NULL )
657  		{
658  			( void ) xTaskNotifyFromISR( ( pxStreamBuffer )->xTaskWaitingToSend,
659  										 ( uint32_t ) 0,
660  										 eNoAction,
661  										 pxHigherPriorityTaskWoken );
662  			( pxStreamBuffer )->xTaskWaitingToSend = NULL;
663  			xReturn = pdTRUE;
664  		}
665  		else
666  		{
667  			xReturn = pdFALSE;
668  		}
669  	}
670  	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
671  	return xReturn;
672  }
673  static size_t prvWriteBytesToBuffer( StreamBuffer_t * const pxStreamBuffer, const uint8_t *pucData, size_t xCount )
674  {
675  size_t xNextHead, xFirstLength;
676  	configASSERT( xCount > ( size_t ) 0 );
677  	xNextHead = pxStreamBuffer->xHead;
678  	xFirstLength = configMIN( pxStreamBuffer->xLength - xNextHead, xCount );
679  	configASSERT( ( xNextHead + xFirstLength ) <= pxStreamBuffer->xLength );
680  	memcpy( ( void* ) ( &( pxStreamBuffer->pucBuffer[ xNextHead ] ) ), ( const void * ) pucData, xFirstLength ); &bsol;*lint !e9087 memcpy() requires void *. */
681  	if( xCount > xFirstLength )
682  	{
683  		configASSERT( ( xCount - xFirstLength ) <= pxStreamBuffer->xLength );
684  		memcpy( ( void * ) pxStreamBuffer->pucBuffer, ( const void * ) &( pucData[ xFirstLength ] ), xCount - xFirstLength ); &bsol;*lint !e9087 memcpy() requires void *. */
685  	}
686  	else
687  	{
688  		mtCOVERAGE_TEST_MARKER();
689  	}
690  	xNextHead += xCount;
691  	if( xNextHead >= pxStreamBuffer->xLength )
692  	{
693  		xNextHead -= pxStreamBuffer->xLength;
694  	}
695  	else
696  	{
697  		mtCOVERAGE_TEST_MARKER();
698  	}
699  	pxStreamBuffer->xHead = xNextHead;
700  	return xCount;
701  }
702  static size_t prvReadBytesFromBuffer( StreamBuffer_t *pxStreamBuffer, uint8_t *pucData, size_t xMaxCount, size_t xBytesAvailable )
703  {
704  size_t xCount, xFirstLength, xNextTail;
705  	xCount = configMIN( xBytesAvailable, xMaxCount );
706  	if( xCount > ( size_t ) 0 )
707  	{
708  		xNextTail = pxStreamBuffer->xTail;
709  		xFirstLength = configMIN( pxStreamBuffer->xLength - xNextTail, xCount );
710  		configASSERT( xFirstLength <= xMaxCount );
711  		configASSERT( ( xNextTail + xFirstLength ) <= pxStreamBuffer->xLength );
712  		memcpy( ( void * ) pucData, ( const void * ) &( pxStreamBuffer->pucBuffer[ xNextTail ] ), xFirstLength ); &bsol;*lint !e9087 memcpy() requires void *. */
713  		if( xCount > xFirstLength )
714  		{
715  			configASSERT( xCount <= xMaxCount );
716  			memcpy( ( void * ) &( pucData[ xFirstLength ] ), ( void * ) ( pxStreamBuffer->pucBuffer ), xCount - xFirstLength ); &bsol;*lint !e9087 memcpy() requires void *. */
717  		}
718  		else
719  		{
720  			mtCOVERAGE_TEST_MARKER();
721  		}
722  		xNextTail += xCount;
723  		if( xNextTail >= pxStreamBuffer->xLength )
724  		{
725  			xNextTail -= pxStreamBuffer->xLength;
726  		}
727  		pxStreamBuffer->xTail = xNextTail;
728  	}
729  	else
730  	{
731  		mtCOVERAGE_TEST_MARKER();
732  	}
733  	return xCount;
734  }
735  static size_t prvBytesInBuffer( const StreamBuffer_t * const pxStreamBuffer )
736  {
737  size_t xCount;
738  	xCount = pxStreamBuffer->xLength + pxStreamBuffer->xHead;
739  	xCount -= pxStreamBuffer->xTail;
740  	if ( xCount >= pxStreamBuffer->xLength )
741  	{
742  		xCount -= pxStreamBuffer->xLength;
743  	}
744  	else
745  	{
746  		mtCOVERAGE_TEST_MARKER();
747  	}
748  	return xCount;
749  }
750  static void prvInitialiseNewStreamBuffer( StreamBuffer_t * const pxStreamBuffer,
751  										  uint8_t * const pucBuffer,
752  										  size_t xBufferSizeBytes,
753  										  size_t xTriggerLevelBytes,
754  										  BaseType_t xIsMessageBuffer )
755  {
756  	#if( configASSERT_DEFINED == 1 )
757  	{
758  		const BaseType_t xWriteValue = 0x55;
759  		configASSERT( memset( pucBuffer, ( int ) xWriteValue, xBufferSizeBytes ) == pucBuffer );
760  	}
761  	#endif
762  	memset( ( void * ) pxStreamBuffer, 0x00, sizeof( StreamBuffer_t ) ); &bsol;*lint !e9087 memset() requires void *. */
763  	pxStreamBuffer->pucBuffer = pucBuffer;
764  	pxStreamBuffer->xLength = xBufferSizeBytes;
765  	pxStreamBuffer->xTriggerLevelBytes = xTriggerLevelBytes;
766  	if( xIsMessageBuffer != pdFALSE )
767  	{
768  		pxStreamBuffer->ucFlags |= sbFLAGS_IS_MESSAGE_BUFFER;
769  	}
770  }
771  #if ( configUSE_TRACE_FACILITY == 1 )
772  	UBaseType_t uxStreamBufferGetStreamBufferNumber( StreamBufferHandle_t xStreamBuffer )
773  	{
774  		return ( ( StreamBuffer_t * ) xStreamBuffer )->uxStreamBufferNumber;
775  	}
776  #endif &bsol;* configUSE_TRACE_FACILITY */
777  #if ( configUSE_TRACE_FACILITY == 1 )
778  	void vStreamBufferSetStreamBufferNumber( StreamBufferHandle_t xStreamBuffer, UBaseType_t uxStreamBufferNumber )
779  	{
780  		( ( StreamBuffer_t * ) xStreamBuffer )->uxStreamBufferNumber = uxStreamBufferNumber;
781  	}
782  #endif &bsol;* configUSE_TRACE_FACILITY */
783  #if ( configUSE_TRACE_FACILITY == 1 )
784  	uint8_t ucStreamBufferGetStreamBufferType( StreamBufferHandle_t xStreamBuffer )
785  	{
786  		return ( ( StreamBuffer_t * )xStreamBuffer )->ucFlags | sbFLAGS_IS_MESSAGE_BUFFER;
787  	}
788  #endif &bsol;* configUSE_TRACE_FACILITY */
</code></pre>
        </div>
        <div class="column">
            <h3>Adafruit_nRF52_Arduino-MDEwOlJlcG9zaXRvcnk3NDM1NDcyOQ==-flat-stream_buffer.c</h3>
            <pre><code>1  #include <stdint.h>
2  #include <string.h>
3  #define MPU_WRAPPERS_INCLUDED_FROM_API_FILE
4  #include "FreeRTOS.h"
5  #include "task.h"
6  #include "stream_buffer.h"
7  #if( configUSE_TASK_NOTIFICATIONS != 1 )
8  	#error configUSE_TASK_NOTIFICATIONS must be set to 1 to build stream_buffer.c
9  #endif
10  #undef MPU_WRAPPERS_INCLUDED_FROM_API_FILE &bsol;*lint !e961 !e750. */
11  #ifndef sbRECEIVE_COMPLETED
12  	#define sbRECEIVE_COMPLETED( pxStreamBuffer )										\
13  		vTaskSuspendAll();																\
14  		{																				\
15  			if( ( pxStreamBuffer )->xTaskWaitingToSend != NULL )						\
16  			{																			\
17  				( void ) xTaskNotify( ( pxStreamBuffer )->xTaskWaitingToSend,			\
18  									  ( uint32_t ) 0,									\
19  									  eNoAction );										\
20  				( pxStreamBuffer )->xTaskWaitingToSend = NULL;							\
21  			}																			\
22  		}																				\
23  		( void ) xTaskResumeAll();
24  #endif &bsol;* sbRECEIVE_COMPLETED */
25  #ifndef sbRECEIVE_COMPLETED_FROM_ISR
26  	#define sbRECEIVE_COMPLETED_FROM_ISR( pxStreamBuffer,								\
27  										  pxHigherPriorityTaskWoken )					\
28  	{																					\
29  	UBaseType_t uxSavedInterruptStatus;													\
30  																						\
31  		uxSavedInterruptStatus = ( UBaseType_t ) portSET_INTERRUPT_MASK_FROM_ISR();		\
32  		{																				\
33  			if( ( pxStreamBuffer )->xTaskWaitingToSend != NULL )						\
34  			{																			\
35  				( void ) xTaskNotifyFromISR( ( pxStreamBuffer )->xTaskWaitingToSend,	\
36  											 ( uint32_t ) 0,							\
37  											 eNoAction,									\
38  											 pxHigherPriorityTaskWoken );				\
39  				( pxStreamBuffer )->xTaskWaitingToSend = NULL;							\
40  			}																			\
41  		}																				\
42  		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );					\
43  	}
44  #endif &bsol;* sbRECEIVE_COMPLETED_FROM_ISR */
45  #ifndef sbSEND_COMPLETED
46  	#define sbSEND_COMPLETED( pxStreamBuffer )											\
47  		vTaskSuspendAll();																\
48  		{																				\
49  			if( ( pxStreamBuffer )->xTaskWaitingToReceive != NULL )						\
50  			{																			\
51  				( void ) xTaskNotify( ( pxStreamBuffer )->xTaskWaitingToReceive,		\
52  									  ( uint32_t ) 0,									\
53  									  eNoAction );										\
54  				( pxStreamBuffer )->xTaskWaitingToReceive = NULL;						\
55  			}																			\
56  		}																				\
57  		( void ) xTaskResumeAll();
58  #endif &bsol;* sbSEND_COMPLETED */
59  #ifndef sbSEND_COMPLETE_FROM_ISR
60  	#define sbSEND_COMPLETE_FROM_ISR( pxStreamBuffer, pxHigherPriorityTaskWoken )		\
61  	{																					\
62  	UBaseType_t uxSavedInterruptStatus;													\
63  																						\
64  		uxSavedInterruptStatus = ( UBaseType_t ) portSET_INTERRUPT_MASK_FROM_ISR();		\
65  		{																				\
66  			if( ( pxStreamBuffer )->xTaskWaitingToReceive != NULL )						\
67  			{																			\
68  				( void ) xTaskNotifyFromISR( ( pxStreamBuffer )->xTaskWaitingToReceive,	\
69  											 ( uint32_t ) 0,							\
70  											 eNoAction,									\
71  											 pxHigherPriorityTaskWoken );				\
72  				( pxStreamBuffer )->xTaskWaitingToReceive = NULL;						\
73  			}																			\
74  		}																				\
75  		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );					\
76  	}
77  #endif &bsol;* sbSEND_COMPLETE_FROM_ISR */
78  #define sbBYTES_TO_STORE_MESSAGE_LENGTH ( sizeof( size_t ) )
79  #define sbFLAGS_IS_MESSAGE_BUFFER		( ( uint8_t ) 1 ) &bsol;* Set if the stream buffer was created as a message buffer, in which case it holds discrete messages rather than a stream. */
80  #define sbFLAGS_IS_STATICALLY_ALLOCATED ( ( uint8_t ) 2 ) &bsol;* Set if the stream buffer was created using statically allocated memory. */
81  typedef struct xSTREAM_BUFFER &bsol;*lint !e9058 Style convention uses tag. */
82  {
83  	volatile size_t xTail;				&bsol;* Index to the next item to read within the buffer. */
84  	volatile size_t xHead;				&bsol;* Index to the next item to write within the buffer. */
85  	size_t xLength;						&bsol;* The length of the buffer pointed to by pucBuffer. */
86  	size_t xTriggerLevelBytes;			&bsol;* The number of bytes that must be in the stream buffer before a task that is waiting for data is unblocked. */
87  	volatile TaskHandle_t xTaskWaitingToReceive; &bsol;* Holds the handle of a task waiting for data, or NULL if no tasks are waiting. */
88  	volatile TaskHandle_t xTaskWaitingToSend;	&bsol;* Holds the handle of a task waiting to send data to a message buffer that is full. */
89  	uint8_t *pucBuffer;					&bsol;* Points to the buffer itself - that is - the RAM that stores the data passed through the buffer. */
90  	uint8_t ucFlags;
91  	#if ( configUSE_TRACE_FACILITY == 1 )
92  		UBaseType_t uxStreamBufferNumber;		&bsol;* Used for tracing purposes. */
93  	#endif
94  } StreamBuffer_t;
95  static size_t prvBytesInBuffer( const StreamBuffer_t * const pxStreamBuffer ) PRIVILEGED_FUNCTION;
96  static size_t prvWriteBytesToBuffer( StreamBuffer_t * const pxStreamBuffer, const uint8_t *pucData, size_t xCount ) PRIVILEGED_FUNCTION;
97  static size_t prvReadMessageFromBuffer( StreamBuffer_t *pxStreamBuffer,
98  										void *pvRxData,
99  										size_t xBufferLengthBytes,
100  										size_t xBytesAvailable,
101  										size_t xBytesToStoreMessageLength ) PRIVILEGED_FUNCTION;
102  static size_t prvWriteMessageToBuffer(  StreamBuffer_t * const pxStreamBuffer,
103  										const void * pvTxData,
104  										size_t xDataLengthBytes,
105  										size_t xSpace,
106  										size_t xRequiredSpace ) PRIVILEGED_FUNCTION;
107  static size_t prvReadBytesFromBuffer( StreamBuffer_t *pxStreamBuffer,
108  									  uint8_t *pucData,
109  									  size_t xMaxCount,
110  									  size_t xBytesAvailable ); PRIVILEGED_FUNCTION
111  static void prvInitialiseNewStreamBuffer( StreamBuffer_t * const pxStreamBuffer,
112  										  uint8_t * const pucBuffer,
113  										  size_t xBufferSizeBytes,
114  										  size_t xTriggerLevelBytes,
115  										  BaseType_t xIsMessageBuffer ) PRIVILEGED_FUNCTION;
116  #if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )
117  	StreamBufferHandle_t xStreamBufferGenericCreate( size_t xBufferSizeBytes, size_t xTriggerLevelBytes, BaseType_t xIsMessageBuffer )
118  	{
119  	uint8_t *pucAllocatedMemory;
120  		configASSERT( xBufferSizeBytes > sbBYTES_TO_STORE_MESSAGE_LENGTH );
121  		configASSERT( xTriggerLevelBytes <= xBufferSizeBytes );
122  		if( xTriggerLevelBytes == ( size_t ) 0 )
123  		{
124  			xTriggerLevelBytes = ( size_t ) 1; &bsol;*lint !e9044 Parameter modified to ensure it doesn't have a dangerous value. */
125  		}
126  		xBufferSizeBytes++;
127  		pucAllocatedMemory = ( uint8_t * ) pvPortMalloc( xBufferSizeBytes + sizeof( StreamBuffer_t ) ); &bsol;*lint !e9079 malloc() only returns void*. */
128  		if( pucAllocatedMemory != NULL )
129  		{
130  			prvInitialiseNewStreamBuffer( ( StreamBuffer_t * ) pucAllocatedMemory, &bsol;* Structure at the start of the allocated memory. */ &bsol;*lint !e9087 Safe cast as allocated memory is aligned. */ &bsol;*lint !e826 Area is not too small and alignment is guaranteed provided malloc() behaves as expected and returns aligned buffer. */
131  										   pucAllocatedMemory + sizeof( StreamBuffer_t ),  &bsol;* Storage area follows. */ &bsol;*lint !e9016 Indexing past structure valid for uint8_t pointer, also storage area has no alignment requirement. */
132  										   xBufferSizeBytes,
133  										   xTriggerLevelBytes,
134  										   xIsMessageBuffer );
135  			traceSTREAM_BUFFER_CREATE( ( ( StreamBuffer_t * ) pucAllocatedMemory ), xIsMessageBuffer );
136  		}
137  		else
138  		{
139  			traceSTREAM_BUFFER_CREATE_FAILED( xIsMessageBuffer );
140  		}
141  		return ( StreamBufferHandle_t * ) pucAllocatedMemory; &bsol;*lint !e9087 !e826 Safe cast as allocated memory is aligned. */
142  	}
143  #endif &bsol;* configSUPPORT_DYNAMIC_ALLOCATION */
144  #if( configSUPPORT_STATIC_ALLOCATION == 1 )
145  	StreamBufferHandle_t xStreamBufferGenericCreateStatic( size_t xBufferSizeBytes,
146  														   size_t xTriggerLevelBytes,
147  														   BaseType_t xIsMessageBuffer,
148  														   uint8_t * const pucStreamBufferStorageArea,
149  														   StaticStreamBuffer_t * const pxStaticStreamBuffer )
150  	{
151  	StreamBuffer_t * const pxStreamBuffer = ( StreamBuffer_t * ) pxStaticStreamBuffer; &bsol;*lint !e740 !e9087 Safe cast as StaticStreamBuffer_t is opaque Streambuffer_t. */
152  	StreamBufferHandle_t xReturn;
153  		configASSERT( pucStreamBufferStorageArea );
154  		configASSERT( pxStaticStreamBuffer );
155  		configASSERT( xTriggerLevelBytes <= xBufferSizeBytes );
156  		if( xTriggerLevelBytes == ( size_t ) 0 )
157  		{
158  			xTriggerLevelBytes = ( size_t ) 1; &bsol;*lint !e9044 Function parameter deliberately modified to ensure it is in range. */
159  		}
160  		configASSERT( xBufferSizeBytes > sbBYTES_TO_STORE_MESSAGE_LENGTH );
161  		#if( configASSERT_DEFINED == 1 )
162  		{
163  			volatile size_t xSize = sizeof( StaticStreamBuffer_t );
164  			configASSERT( xSize == sizeof( StreamBuffer_t ) );
165  		}
166  		#endif &bsol;* configASSERT_DEFINED */
167  		if( ( pucStreamBufferStorageArea != NULL ) && ( pxStaticStreamBuffer != NULL ) )
168  		{
169  			prvInitialiseNewStreamBuffer( pxStreamBuffer,
170  										  pucStreamBufferStorageArea,
171  										  xBufferSizeBytes,
172  										  xTriggerLevelBytes,
173  										  xIsMessageBuffer );
174  			pxStreamBuffer->ucFlags |= sbFLAGS_IS_STATICALLY_ALLOCATED;
175  			traceSTREAM_BUFFER_CREATE( pxStreamBuffer, xIsMessageBuffer );
176  			xReturn = ( StreamBufferHandle_t ) pxStaticStreamBuffer; &bsol;*lint !e9087 Data hiding requires cast to opaque type. */
177  		}
178  		else
179  		{
180  			xReturn = NULL;
181  			traceSTREAM_BUFFER_CREATE_STATIC_FAILED( xReturn, xIsMessageBuffer );
182  		}
183  		return xReturn;
184  	}
185  #endif &bsol;* ( configSUPPORT_STATIC_ALLOCATION == 1 ) */
186  void vStreamBufferDelete( StreamBufferHandle_t xStreamBuffer )
187  {
188  StreamBuffer_t * pxStreamBuffer = ( StreamBuffer_t * ) xStreamBuffer; &bsol;*lint !e9087 !e9079 Safe cast as StreamBufferHandle_t is opaque Streambuffer_t. */
189  	configASSERT( pxStreamBuffer );
190  	traceSTREAM_BUFFER_DELETE( xStreamBuffer );
191  	if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_STATICALLY_ALLOCATED ) == ( uint8_t ) pdFALSE )
192  	{
193  		#if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )
194  		{
195  			vPortFree( ( void * ) pxStreamBuffer ); &bsol;*lint !e9087 Standard free() semantics require void *, plus pxStreamBuffer was allocated by pvPortMalloc(). */
196  		}
197  		#else
198  		{
199  			configASSERT( xStreamBuffer == ( StreamBufferHandle_t ) ~0 );
200  		}
201  		#endif
202  	}
203  	else
204  	{
205  		memset( pxStreamBuffer, 0x00, sizeof( StreamBuffer_t ) );
206  	}
207  }
208  BaseType_t xStreamBufferReset( StreamBufferHandle_t xStreamBuffer )
209  {
210  StreamBuffer_t * const pxStreamBuffer = ( StreamBuffer_t * ) xStreamBuffer; &bsol;*lint !e9087 !e9079 Safe cast as StreamBufferHandle_t is opaque Streambuffer_t. */
211  BaseType_t xReturn = pdFAIL, xIsMessageBuffer;
212  #if( configUSE_TRACE_FACILITY == 1 )
213  	UBaseType_t uxStreamBufferNumber;
214  #endif
215  	configASSERT( pxStreamBuffer );
216  	#if( configUSE_TRACE_FACILITY == 1 )
217  	{
218  		uxStreamBufferNumber = pxStreamBuffer->uxStreamBufferNumber;
219  	}
220  	#endif
221  	if( pxStreamBuffer->xTaskWaitingToReceive == NULL )
222  	{
223  		if( pxStreamBuffer->xTaskWaitingToSend == NULL )
224  		{
225  			if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) != ( uint8_t ) 0 )
226  			{
227  				xIsMessageBuffer = pdTRUE;
228  			}
229  			else
230  			{
231  				xIsMessageBuffer = pdFALSE;
232  			}
233  			prvInitialiseNewStreamBuffer( pxStreamBuffer,
234  										  pxStreamBuffer->pucBuffer,
235  										  pxStreamBuffer->xLength,
236  										  pxStreamBuffer->xTriggerLevelBytes,
237  										  xIsMessageBuffer );
238  			xReturn = pdPASS;
239  			#if( configUSE_TRACE_FACILITY == 1 )
240  			{
241  				pxStreamBuffer->uxStreamBufferNumber = uxStreamBufferNumber;
242  			}
243  			#endif
244  			traceSTREAM_BUFFER_RESET( xStreamBuffer );
245  		}
246  	}
247  	return xReturn;
248  }
249  BaseType_t xStreamBufferSetTriggerLevel( StreamBufferHandle_t xStreamBuffer, size_t xTriggerLevel )
250  {
251  StreamBuffer_t * const pxStreamBuffer = ( StreamBuffer_t * ) xStreamBuffer; &bsol;*lint !e9087 !e9079 Safe cast as StreamBufferHandle_t is opaque Streambuffer_t. */
252  BaseType_t xReturn;
253  	configASSERT( pxStreamBuffer );
254  	if( xTriggerLevel == ( size_t ) 0 )
255  	{
256  		xTriggerLevel = ( size_t ) 1; &bsol;*lint !e9044 Parameter modified to ensure it doesn't have a dangerous value. */
257  	}
258  	if( xTriggerLevel <= pxStreamBuffer->xLength )
259  	{
260  		pxStreamBuffer->xTriggerLevelBytes = xTriggerLevel;
261  		xReturn = pdPASS;
262  	}
263  	else
264  	{
265  		xReturn = pdFALSE;
266  	}
267  	return xReturn;
268  }
269  size_t xStreamBufferSpacesAvailable( StreamBufferHandle_t xStreamBuffer )
270  {
271  const StreamBuffer_t * const pxStreamBuffer = ( StreamBuffer_t * ) xStreamBuffer; &bsol;*lint !e9087 !e9079 Safe cast as StreamBufferHandle_t is opaque Streambuffer_t. */
272  size_t xSpace;
273  	configASSERT( pxStreamBuffer );
274  	xSpace = pxStreamBuffer->xLength + pxStreamBuffer->xTail;
275  	xSpace -= pxStreamBuffer->xHead;
276  	xSpace -= ( size_t ) 1;
277  	if( xSpace >= pxStreamBuffer->xLength )
278  	{
279  		xSpace -= pxStreamBuffer->xLength;
280  	}
281  	else
282  	{
283  		mtCOVERAGE_TEST_MARKER();
284  	}
285  	return xSpace;
286  }
287  size_t xStreamBufferBytesAvailable( StreamBufferHandle_t xStreamBuffer )
288  {
289  const StreamBuffer_t * const pxStreamBuffer = ( StreamBuffer_t * ) xStreamBuffer; &bsol;*lint !e9087 !e9079 Safe cast as StreamBufferHandle_t is opaque Streambuffer_t. */
290  size_t xReturn;
291  	configASSERT( pxStreamBuffer );
292  	xReturn = prvBytesInBuffer( pxStreamBuffer );
293  	return xReturn;
294  }
295  size_t xStreamBufferSend( StreamBufferHandle_t xStreamBuffer,
296  						  const void *pvTxData,
297  						  size_t xDataLengthBytes,
298  						  TickType_t xTicksToWait )
299  {
300  StreamBuffer_t * const pxStreamBuffer = ( StreamBuffer_t * ) xStreamBuffer; &bsol;*lint !e9087 !e9079 Safe cast as StreamBufferHandle_t is opaque Streambuffer_t. */
301  size_t xReturn, xSpace = 0;
302  size_t xRequiredSpace = xDataLengthBytes;
303  TimeOut_t xTimeOut;
304  	configASSERT( pvTxData );
305  	configASSERT( pxStreamBuffer );
306  	if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) != ( uint8_t ) 0 )
307  	{
308  		xRequiredSpace += sbBYTES_TO_STORE_MESSAGE_LENGTH;
309  	}
310  	else
311  	{
312  		mtCOVERAGE_TEST_MARKER();
313  	}
314  	if( xTicksToWait != ( TickType_t ) 0 )
315  	{
316  		vTaskSetTimeOutState( &xTimeOut );
317  		do
318  		{
319  			taskENTER_CRITICAL();
320  			{
321  				xSpace = xStreamBufferSpacesAvailable( pxStreamBuffer );
322  				if( xSpace < xRequiredSpace )
323  				{
324  					( void ) xTaskNotifyStateClear( NULL );
325  					configASSERT( pxStreamBuffer->xTaskWaitingToSend == NULL );
326  					pxStreamBuffer->xTaskWaitingToSend = xTaskGetCurrentTaskHandle();
327  				}
328  				else
329  				{
330  					taskEXIT_CRITICAL();
331  					break;
332  				}
333  			}
334  			taskEXIT_CRITICAL();
335  			traceBLOCKING_ON_STREAM_BUFFER_SEND( xStreamBuffer );
336  			( void ) xTaskNotifyWait( ( uint32_t ) 0, UINT32_MAX, NULL, xTicksToWait );
337  			pxStreamBuffer->xTaskWaitingToSend = NULL;
338  		} while( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE );
339  	}
340  	else
341  	{
342  		mtCOVERAGE_TEST_MARKER();
343  	}
344  	if( xSpace == ( size_t ) 0 )
345  	{
346  		xSpace = xStreamBufferSpacesAvailable( pxStreamBuffer );
347  	}
348  	else
349  	{
350  		mtCOVERAGE_TEST_MARKER();
351  	}
352  	xReturn = prvWriteMessageToBuffer( pxStreamBuffer, pvTxData, xDataLengthBytes, xSpace, xRequiredSpace );
353  	if( xReturn > ( size_t ) 0 )
354  	{
355  		traceSTREAM_BUFFER_SEND( xStreamBuffer, xReturn );
356  		if( prvBytesInBuffer( pxStreamBuffer ) >= pxStreamBuffer->xTriggerLevelBytes )
357  		{
358  			sbSEND_COMPLETED( pxStreamBuffer );
359  		}
360  		else
361  		{
362  			mtCOVERAGE_TEST_MARKER();
363  		}
364  	}
365  	else
366  	{
367  		mtCOVERAGE_TEST_MARKER();
368  		traceSTREAM_BUFFER_SEND_FAILED( xStreamBuffer );
369  	}
370  	return xReturn;
371  }
372  size_t xStreamBufferSendFromISR( StreamBufferHandle_t xStreamBuffer,
373  								 const void *pvTxData,
374  								 size_t xDataLengthBytes,
375  								 BaseType_t * const pxHigherPriorityTaskWoken )
376  {
377  StreamBuffer_t * const pxStreamBuffer = ( StreamBuffer_t * ) xStreamBuffer; &bsol;*lint !e9087 !e9079 Safe cast as StreamBufferHandle_t is opaque Streambuffer_t. */
378  size_t xReturn, xSpace;
379  size_t xRequiredSpace = xDataLengthBytes;
380  	configASSERT( pvTxData );
381  	configASSERT( pxStreamBuffer );
382  	if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) != ( uint8_t ) 0 )
383  	{
384  		xRequiredSpace += sbBYTES_TO_STORE_MESSAGE_LENGTH;
385  	}
386  	else
387  	{
388  		mtCOVERAGE_TEST_MARKER();
389  	}
390  	xSpace = xStreamBufferSpacesAvailable( pxStreamBuffer );
391  	xReturn = prvWriteMessageToBuffer( pxStreamBuffer, pvTxData, xDataLengthBytes, xSpace, xRequiredSpace );
392  	if( xReturn > ( size_t ) 0 )
393  	{
394  		if( prvBytesInBuffer( pxStreamBuffer ) >= pxStreamBuffer->xTriggerLevelBytes )
395  		{
396  			sbSEND_COMPLETE_FROM_ISR( pxStreamBuffer, pxHigherPriorityTaskWoken );
397  		}
398  		else
399  		{
400  			mtCOVERAGE_TEST_MARKER();
401  		}
402  	}
403  	else
404  	{
405  		mtCOVERAGE_TEST_MARKER();
406  	}
407  	traceSTREAM_BUFFER_SEND_FROM_ISR( xStreamBuffer, xReturn );
408  	return xReturn;
409  }
410  static size_t prvWriteMessageToBuffer( StreamBuffer_t * const pxStreamBuffer,
411  									   const void * pvTxData,
412  									   size_t xDataLengthBytes,
413  									   size_t xSpace,
414  									   size_t xRequiredSpace )
415  {
416  	BaseType_t xShouldWrite;
417  	size_t xReturn;
418  	if( xSpace == ( size_t ) 0 )
419  	{
420  		xShouldWrite = pdFALSE;
421  	}
422  	else if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) == ( uint8_t ) 0 )
423  	{
424  		xShouldWrite = pdTRUE;
425  		xDataLengthBytes = configMIN( xDataLengthBytes, xSpace ); &bsol;*lint !e9044 Function parameter modified to ensure it is capped to available space. */
426  	}
427  	else if( xSpace >= xRequiredSpace )
428  	{
429  		xShouldWrite = pdTRUE;
430  		( void ) prvWriteBytesToBuffer( pxStreamBuffer, ( const uint8_t * ) &( xDataLengthBytes ), sbBYTES_TO_STORE_MESSAGE_LENGTH );
431  	}
432  	else
433  	{
434  		xShouldWrite = pdFALSE;
435  	}
436  	if( xShouldWrite != pdFALSE )
437  	{
438  		xReturn = prvWriteBytesToBuffer( pxStreamBuffer, ( const uint8_t * ) pvTxData, xDataLengthBytes ); &bsol;*lint !e9079 Storage buffer is implemented as uint8_t for ease of sizing, alighment and access. */
439  	}
440  	else
441  	{
442  		xReturn = 0;
443  	}
444  	return xReturn;
445  }
446  size_t xStreamBufferReceive( StreamBufferHandle_t xStreamBuffer,
447  							 void *pvRxData,
448  							 size_t xBufferLengthBytes,
449  							 TickType_t xTicksToWait )
450  {
451  StreamBuffer_t * const pxStreamBuffer = ( StreamBuffer_t * ) xStreamBuffer; &bsol;*lint !e9087 !e9079 Safe cast as StreamBufferHandle_t is opaque Streambuffer_t. */
<span onclick='openModal()' class='match'>452  size_t xReceivedLength = 0, xBytesAvailable, xBytesToStoreMessageLength;
453  	configASSERT( pvRxData );
454  	configASSERT( pxStreamBuffer );
455  	if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) != ( uint8_t ) 0 )
456  	{
457  		xBytesToStoreMessageLength = sbBYTES_TO_STORE_MESSAGE_LENGTH;
458  	}
459  	else
460  	{
461  		xBytesToStoreMessageLength = 0;
462  	}
463  	if( xTicksToWait != ( TickType_t ) 0 )
</span>464  	{
465  		taskENTER_CRITICAL();
466  		{
467  			xBytesAvailable = prvBytesInBuffer( pxStreamBuffer );
468  			if( xBytesAvailable <= xBytesToStoreMessageLength )
469  			{
470  				( void ) xTaskNotifyStateClear( NULL );
471  				configASSERT( pxStreamBuffer->xTaskWaitingToReceive == NULL );
472  				pxStreamBuffer->xTaskWaitingToReceive = xTaskGetCurrentTaskHandle();
473  			}
474  			else
475  			{
476  				mtCOVERAGE_TEST_MARKER();
477  			}
478  		}
479  		taskEXIT_CRITICAL();
480  		if( xBytesAvailable <= xBytesToStoreMessageLength )
481  		{
482  			traceBLOCKING_ON_STREAM_BUFFER_RECEIVE( xStreamBuffer );
483  			( void ) xTaskNotifyWait( ( uint32_t ) 0, UINT32_MAX, NULL, xTicksToWait );
484  			pxStreamBuffer->xTaskWaitingToReceive = NULL;
485  			xBytesAvailable = prvBytesInBuffer( pxStreamBuffer );
486  		}
487  		else
488  		{
489  			mtCOVERAGE_TEST_MARKER();
490  		}
491  	}
492  	else
493  	{
494  		xBytesAvailable = prvBytesInBuffer( pxStreamBuffer );
495  	}
496  	if( xBytesAvailable > xBytesToStoreMessageLength )
497  	{
498  		xReceivedLength = prvReadMessageFromBuffer( pxStreamBuffer, pvRxData, xBufferLengthBytes, xBytesAvailable, xBytesToStoreMessageLength );
499  		if( xReceivedLength != ( size_t ) 0 )
500  		{
501  			traceSTREAM_BUFFER_RECEIVE( xStreamBuffer, xReceivedLength );
502  			sbRECEIVE_COMPLETED( pxStreamBuffer );
503  		}
504  		else
505  		{
506  			mtCOVERAGE_TEST_MARKER();
507  		}
508  	}
509  	else
510  	{
511  		traceSTREAM_BUFFER_RECEIVE_FAILED( xStreamBuffer );
512  		mtCOVERAGE_TEST_MARKER();
513  	}
514  	return xReceivedLength;
515  }
516  size_t xStreamBufferReceiveFromISR( StreamBufferHandle_t xStreamBuffer,
517  									void *pvRxData,
518  									size_t xBufferLengthBytes,
519  									BaseType_t * const pxHigherPriorityTaskWoken )
520  {
521  StreamBuffer_t * const pxStreamBuffer = ( StreamBuffer_t * ) xStreamBuffer; &bsol;*lint !e9087 !e9079 Safe cast as StreamBufferHandle_t is opaque Streambuffer_t. */
522  size_t xReceivedLength = 0, xBytesAvailable, xBytesToStoreMessageLength;
523  	configASSERT( pvRxData );
524  	configASSERT( pxStreamBuffer );
525  	if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) != ( uint8_t ) 0 )
526  	{
527  		xBytesToStoreMessageLength = sbBYTES_TO_STORE_MESSAGE_LENGTH;
528  	}
529  	else
530  	{
531  		xBytesToStoreMessageLength = 0;
532  	}
533  	xBytesAvailable = prvBytesInBuffer( pxStreamBuffer );
534  	if( xBytesAvailable > xBytesToStoreMessageLength )
535  	{
536  		xReceivedLength = prvReadMessageFromBuffer( pxStreamBuffer, pvRxData, xBufferLengthBytes, xBytesAvailable, xBytesToStoreMessageLength );
537  		if( xReceivedLength != ( size_t ) 0 )
538  		{
539  			sbRECEIVE_COMPLETED_FROM_ISR( pxStreamBuffer, pxHigherPriorityTaskWoken );
540  		}
541  		else
542  		{
543  			mtCOVERAGE_TEST_MARKER();
544  		}
545  	}
546  	else
547  	{
548  		mtCOVERAGE_TEST_MARKER();
549  	}
550  	traceSTREAM_BUFFER_RECEIVE_FROM_ISR( xStreamBuffer, xReceivedLength );
551  	return xReceivedLength;
552  }
553  static size_t prvReadMessageFromBuffer( StreamBuffer_t *pxStreamBuffer,
554  										void *pvRxData,
555  										size_t xBufferLengthBytes,
556  										size_t xBytesAvailable,
557  										size_t xBytesToStoreMessageLength )
558  {
559  size_t xOriginalTail, xReceivedLength, xNextMessageLength;
560  	if( xBytesToStoreMessageLength != ( size_t ) 0 )
561  	{
562  		xOriginalTail = pxStreamBuffer->xTail;
563  		( void ) prvReadBytesFromBuffer( pxStreamBuffer, ( uint8_t * ) &xNextMessageLength, xBytesToStoreMessageLength, xBytesAvailable );
564  		xBytesAvailable -= xBytesToStoreMessageLength;
565  		if( xNextMessageLength > xBufferLengthBytes )
566  		{
567  			pxStreamBuffer->xTail = xOriginalTail;
568  			xNextMessageLength = 0;
569  		}
570  		else
571  		{
572  			mtCOVERAGE_TEST_MARKER();
573  		}
574  	}
575  	else
576  	{
577  		xNextMessageLength = xBufferLengthBytes;
578  	}
579  	xReceivedLength = prvReadBytesFromBuffer( pxStreamBuffer, ( uint8_t * ) pvRxData, xNextMessageLength, xBytesAvailable ); &bsol;*lint !e9079 Data storage area is implemented as uint8_t array for ease of sizing, indexing and alignment. */
580  	return xReceivedLength;
581  }
582  BaseType_t xStreamBufferIsEmpty( StreamBufferHandle_t xStreamBuffer )
583  {
584  const StreamBuffer_t * const pxStreamBuffer = ( StreamBuffer_t * ) xStreamBuffer; &bsol;*lint !e9087 !e9079 Safe cast as StreamBufferHandle_t is opaque Streambuffer_t. */
585  BaseType_t xReturn;
586  size_t xTail;
587  	configASSERT( pxStreamBuffer );
588  	xTail = pxStreamBuffer->xTail;
589  	if( pxStreamBuffer->xHead == xTail )
590  	{
591  		xReturn = pdTRUE;
592  	}
593  	else
594  	{
595  		xReturn = pdFALSE;
596  	}
597  	return xReturn;
598  }
599  BaseType_t xStreamBufferIsFull( StreamBufferHandle_t xStreamBuffer )
600  {
601  BaseType_t xReturn;
602  size_t xBytesToStoreMessageLength;
603  const StreamBuffer_t * const pxStreamBuffer = ( StreamBuffer_t * ) xStreamBuffer; &bsol;*lint !e9087 !e9079 Safe cast as StreamBufferHandle_t is opaque Streambuffer_t. */
604  	configASSERT( pxStreamBuffer );
605  	if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) != ( uint8_t ) 0 )
606  	{
607  		xBytesToStoreMessageLength = sbBYTES_TO_STORE_MESSAGE_LENGTH;
608  	}
609  	else
610  	{
611  		xBytesToStoreMessageLength = 0;
612  	}
613  	if( xStreamBufferSpacesAvailable( xStreamBuffer ) <= xBytesToStoreMessageLength )
614  	{
615  		xReturn = pdTRUE;
616  	}
617  	else
618  	{
619  		xReturn = pdFALSE;
620  	}
621  	return xReturn;
622  }
623  BaseType_t xStreamBufferSendCompletedFromISR( StreamBufferHandle_t xStreamBuffer, BaseType_t *pxHigherPriorityTaskWoken )
624  {
625  StreamBuffer_t * const pxStreamBuffer = ( StreamBuffer_t * ) xStreamBuffer; &bsol;*lint !e9087 !e9079 Safe cast as StreamBufferHandle_t is opaque Streambuffer_t. */
626  BaseType_t xReturn;
627  UBaseType_t uxSavedInterruptStatus;
628  	configASSERT( pxStreamBuffer );
629  	uxSavedInterruptStatus = ( UBaseType_t ) portSET_INTERRUPT_MASK_FROM_ISR();
630  	{
631  		if( ( pxStreamBuffer )->xTaskWaitingToReceive != NULL )
632  		{
633  			( void ) xTaskNotifyFromISR( ( pxStreamBuffer )->xTaskWaitingToReceive,
634  										 ( uint32_t ) 0,
635  										 eNoAction,
636  										 pxHigherPriorityTaskWoken );
637  			( pxStreamBuffer )->xTaskWaitingToReceive = NULL;
638  			xReturn = pdTRUE;
639  		}
640  		else
641  		{
642  			xReturn = pdFALSE;
643  		}
644  	}
645  	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
646  	return xReturn;
647  }
648  BaseType_t xStreamBufferReceiveCompletedFromISR( StreamBufferHandle_t xStreamBuffer, BaseType_t *pxHigherPriorityTaskWoken )
649  {
650  StreamBuffer_t * const pxStreamBuffer = ( StreamBuffer_t * ) xStreamBuffer; &bsol;*lint !e9087 !e9079 Safe cast as StreamBufferHandle_t is opaque Streambuffer_t. */
651  BaseType_t xReturn;
652  UBaseType_t uxSavedInterruptStatus;
653  	configASSERT( pxStreamBuffer );
654  	uxSavedInterruptStatus = ( UBaseType_t ) portSET_INTERRUPT_MASK_FROM_ISR();
655  	{
656  		if( ( pxStreamBuffer )->xTaskWaitingToSend != NULL )
657  		{
658  			( void ) xTaskNotifyFromISR( ( pxStreamBuffer )->xTaskWaitingToSend,
659  										 ( uint32_t ) 0,
660  										 eNoAction,
661  										 pxHigherPriorityTaskWoken );
662  			( pxStreamBuffer )->xTaskWaitingToSend = NULL;
663  			xReturn = pdTRUE;
664  		}
665  		else
666  		{
667  			xReturn = pdFALSE;
668  		}
669  	}
670  	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
671  	return xReturn;
672  }
673  static size_t prvWriteBytesToBuffer( StreamBuffer_t * const pxStreamBuffer, const uint8_t *pucData, size_t xCount )
674  {
675  size_t xNextHead, xFirstLength;
676  	configASSERT( xCount > ( size_t ) 0 );
677  	xNextHead = pxStreamBuffer->xHead;
678  	xFirstLength = configMIN( pxStreamBuffer->xLength - xNextHead, xCount );
679  	configASSERT( ( xNextHead + xFirstLength ) <= pxStreamBuffer->xLength );
680  	memcpy( ( void* ) ( &( pxStreamBuffer->pucBuffer[ xNextHead ] ) ), ( const void * ) pucData, xFirstLength ); &bsol;*lint !e9087 memcpy() requires void *. */
681  	if( xCount > xFirstLength )
682  	{
683  		configASSERT( ( xCount - xFirstLength ) <= pxStreamBuffer->xLength );
684  		memcpy( ( void * ) pxStreamBuffer->pucBuffer, ( const void * ) &( pucData[ xFirstLength ] ), xCount - xFirstLength ); &bsol;*lint !e9087 memcpy() requires void *. */
685  	}
686  	else
687  	{
688  		mtCOVERAGE_TEST_MARKER();
689  	}
690  	xNextHead += xCount;
691  	if( xNextHead >= pxStreamBuffer->xLength )
692  	{
693  		xNextHead -= pxStreamBuffer->xLength;
694  	}
695  	else
696  	{
697  		mtCOVERAGE_TEST_MARKER();
698  	}
699  	pxStreamBuffer->xHead = xNextHead;
700  	return xCount;
701  }
702  static size_t prvReadBytesFromBuffer( StreamBuffer_t *pxStreamBuffer, uint8_t *pucData, size_t xMaxCount, size_t xBytesAvailable )
703  {
704  size_t xCount, xFirstLength, xNextTail;
705  	xCount = configMIN( xBytesAvailable, xMaxCount );
706  	if( xCount > ( size_t ) 0 )
707  	{
708  		xNextTail = pxStreamBuffer->xTail;
709  		xFirstLength = configMIN( pxStreamBuffer->xLength - xNextTail, xCount );
710  		configASSERT( xFirstLength <= xMaxCount );
711  		configASSERT( ( xNextTail + xFirstLength ) <= pxStreamBuffer->xLength );
712  		memcpy( ( void * ) pucData, ( const void * ) &( pxStreamBuffer->pucBuffer[ xNextTail ] ), xFirstLength ); &bsol;*lint !e9087 memcpy() requires void *. */
713  		if( xCount > xFirstLength )
714  		{
715  			configASSERT( xCount <= xMaxCount );
716  			memcpy( ( void * ) &( pucData[ xFirstLength ] ), ( void * ) ( pxStreamBuffer->pucBuffer ), xCount - xFirstLength ); &bsol;*lint !e9087 memcpy() requires void *. */
717  		}
718  		else
719  		{
720  			mtCOVERAGE_TEST_MARKER();
721  		}
722  		xNextTail += xCount;
723  		if( xNextTail >= pxStreamBuffer->xLength )
724  		{
725  			xNextTail -= pxStreamBuffer->xLength;
726  		}
727  		pxStreamBuffer->xTail = xNextTail;
728  	}
729  	else
730  	{
731  		mtCOVERAGE_TEST_MARKER();
732  	}
733  	return xCount;
734  }
735  static size_t prvBytesInBuffer( const StreamBuffer_t * const pxStreamBuffer )
736  {
737  size_t xCount;
738  	xCount = pxStreamBuffer->xLength + pxStreamBuffer->xHead;
739  	xCount -= pxStreamBuffer->xTail;
740  	if ( xCount >= pxStreamBuffer->xLength )
741  	{
742  		xCount -= pxStreamBuffer->xLength;
743  	}
744  	else
745  	{
746  		mtCOVERAGE_TEST_MARKER();
747  	}
748  	return xCount;
749  }
750  static void prvInitialiseNewStreamBuffer( StreamBuffer_t * const pxStreamBuffer,
751  										  uint8_t * const pucBuffer,
752  										  size_t xBufferSizeBytes,
753  										  size_t xTriggerLevelBytes,
754  										  BaseType_t xIsMessageBuffer )
755  {
756  	#if( configASSERT_DEFINED == 1 )
757  	{
758  		const BaseType_t xWriteValue = 0x55;
759  		configASSERT( memset( pucBuffer, ( int ) xWriteValue, xBufferSizeBytes ) == pucBuffer );
760  	}
761  	#endif
762  	memset( ( void * ) pxStreamBuffer, 0x00, sizeof( StreamBuffer_t ) ); &bsol;*lint !e9087 memset() requires void *. */
763  	pxStreamBuffer->pucBuffer = pucBuffer;
764  	pxStreamBuffer->xLength = xBufferSizeBytes;
765  	pxStreamBuffer->xTriggerLevelBytes = xTriggerLevelBytes;
766  	if( xIsMessageBuffer != pdFALSE )
767  	{
768  		pxStreamBuffer->ucFlags |= sbFLAGS_IS_MESSAGE_BUFFER;
769  	}
770  }
771  #if ( configUSE_TRACE_FACILITY == 1 )
772  	UBaseType_t uxStreamBufferGetStreamBufferNumber( StreamBufferHandle_t xStreamBuffer )
773  	{
774  		return ( ( StreamBuffer_t * ) xStreamBuffer )->uxStreamBufferNumber;
775  	}
776  #endif &bsol;* configUSE_TRACE_FACILITY */
777  #if ( configUSE_TRACE_FACILITY == 1 )
778  	void vStreamBufferSetStreamBufferNumber( StreamBufferHandle_t xStreamBuffer, UBaseType_t uxStreamBufferNumber )
779  	{
780  		( ( StreamBuffer_t * ) xStreamBuffer )->uxStreamBufferNumber = uxStreamBufferNumber;
781  	}
782  #endif &bsol;* configUSE_TRACE_FACILITY */
783  #if ( configUSE_TRACE_FACILITY == 1 )
784  	uint8_t ucStreamBufferGetStreamBufferType( StreamBufferHandle_t xStreamBuffer )
785  	{
786  		return ( ( StreamBuffer_t * )xStreamBuffer )->ucFlags | sbFLAGS_IS_MESSAGE_BUFFER;
787  	}
788  #endif &bsol;* configUSE_TRACE_FACILITY */
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from Adafruit_nRF52_Arduino-MDEwOlJlcG9zaXRvcnk3NDM1NDcyOQ==-flat-stream_buffer.c</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from Adafruit_nRF52_Arduino-MDEwOlJlcG9zaXRvcnk3NDM1NDcyOQ==-flat-stream_buffer.c</div>
                </div>
                <div class="column column_space"><pre><code>522  size_t xReceivedLength = 0, xBytesAvailable, xBytesToStoreMessageLength;
523  	configASSERT( pvRxData );
524  	configASSERT( pxStreamBuffer );
525  	if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) != ( uint8_t ) 0 )
526  	{
527  		xBytesToStoreMessageLength = sbBYTES_TO_STORE_MESSAGE_LENGTH;
528  	}
529  	else
530  	{
531  		xBytesToStoreMessageLength = 0;
532  	}
533  	xBytesAvailable = prvBytesInBuffer( pxStreamBuffer );
</pre></code></div>
                <div class="column column_space"><pre><code>452  size_t xReceivedLength = 0, xBytesAvailable, xBytesToStoreMessageLength;
453  	configASSERT( pvRxData );
454  	configASSERT( pxStreamBuffer );
455  	if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) != ( uint8_t ) 0 )
456  	{
457  		xBytesToStoreMessageLength = sbBYTES_TO_STORE_MESSAGE_LENGTH;
458  	}
459  	else
460  	{
461  		xBytesToStoreMessageLength = 0;
462  	}
463  	if( xTicksToWait != ( TickType_t ) 0 )
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    