<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for complex.c &amp; dzsave.c</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for complex.c &amp; dzsave.c
      </h3>
<h1 align="center">
        4.6%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>complex.c (10.714286%)<th>dzsave.c (2.970297%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(245-269)<td><a href="#" name="0">(2728-2748)</a><td align="center"><font color="#ff0000">14</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(957-970)<td><a href="#" name="1">(2640-2652)</a><td align="center"><font color="#ec0000">13</font>
<tr onclick='openModal("#980517")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#980517"><font color="#980517">-</font><td><a href="#" name="2">(532-541)<td><a href="#" name="2">(2410-2418)</a><td align="center"><font color="#da0000">12</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>complex.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 #ifdef HAVE_CONFIG_H
2 #include &lt;config.h&gt;
3 #include &lt;vips/intl.h&gt;
4 #include &lt;stdio.h&gt;
5 #include &lt;stdlib.h&gt;
6 #include &lt;math.h&gt;
7 #include &lt;vips/vips.h&gt;
8 #include "unary.h"
9 #include "binary.h"
10 typedef struct _VipsComplex {
11 	VipsUnary parent_instance;
12 	VipsOperationComplex cmplx;
13 } VipsComplex;
14 typedef VipsUnaryClass VipsComplexClass;
15 G_DEFINE_TYPE( VipsComplex, vips_complex, VIPS_TYPE_UNARY );
16 #define LOOP( IN, OUT, OP ) { \
17 	IN * restrict p = (IN *) in[0]; \
18 	OUT * restrict q = (OUT *) out; \
19 	\
20 	for( x = 0; x &lt; sz; x++ ) { \
21 		OP( q, p[x], 0.0 ); \
22 		\
23 		q += 2; \
24 	} \
25 }
26 #define CLOOP( IN, OUT, OP ) { \
27 	IN * restrict p = (IN *) in[0]; \
28 	OUT * restrict q = (OUT *) out; \
29 	\
30 	for( x = 0; x &lt; sz; x++ ) { \
31 		OP( q, p[0], p[1] ); \
32 		\
33 		p += 2; \
34 		q += 2; \
35 	} \
36 }
37 #define SWITCH( OP ) \
38 	switch( vips_image_get_format( im ) ) { \
39 	case VIPS_FORMAT_UCHAR: \
40 		LOOP( unsigned char, float, OP ); break; \
41 	case VIPS_FORMAT_CHAR: \
42 		LOOP( signed char, float, OP ); break; \
43 	case VIPS_FORMAT_USHORT: \
44 		LOOP( unsigned short, float, OP ); break; \
45 	case VIPS_FORMAT_SHORT: \
46 		LOOP( signed short, float, OP ); break; \
47 	case VIPS_FORMAT_UINT: \
48 		LOOP( unsigned int, float, OP ); break; \
49 	case VIPS_FORMAT_INT: \
50 		LOOP( signed int, float, OP ); break; \
51 	case VIPS_FORMAT_FLOAT: \
52 		LOOP( float, float, OP ); break; \
53 	case VIPS_FORMAT_DOUBLE: \
54 		LOOP( double, double, OP ); break;\
55 	case VIPS_FORMAT_COMPLEX: \
56 		CLOOP( float, float, OP ); break; \
57 	case VIPS_FORMAT_DPCOMPLEX: \
58 		CLOOP( double, double, OP ); break;\
59  	\
60 	default: \
61 		g_assert_not_reached(); \
62 	} 
63 static double
64 vips_complex_hypot( double a, double b )
65 {
66 	double d;
67 #ifdef HAVE_HYPOT
68 	d = hypot( a, b ); 
69 #else
70 	d = sqrt( a * a + b * b );
71 #endif
72 	return( d ); 
73 }
74 static double
75 vips_complex_atan2( double a, double b )
76 {
77 	double h;
78 #ifdef HAVE_ATAN2
79 	h = VIPS_DEG( atan2( b, a ) );
80 	if( h &lt; 0.0 )
81 		h += 360;
82 #else
83 	h = vips_col_ab2h( a, b ); 
84 #endif 
85 	return( h ); 
86 }
87 #define POLAR( Q, X, Y ) { \
88 	double re = (X); \
89 	double im = (Y); \
90 	double am, ph; \
91 	\
92 	am = vips_complex_hypot( re, im ); \
93 	ph = vips_complex_atan2( re, im ); \
94 	\
95 	Q[0] = am; \
96 	Q[1] = ph; \
97 } 
98 #define RECT( Q, X, Y ) { \
99 	double am = (X); \
100 	double ph = (Y); \
101 	double re, im; \
102 	\
103 	re = am * cos( VIPS_RAD( ph ) ); \
104 	im = am * sin( VIPS_RAD( ph ) ); \
105 	\
106 	Q[0] = re; \
107 	Q[1] = im; \
108 }
109 #define CONJ( Q, X, Y ) { \
110 	double re = (X); \
111 	double im = (Y); \
112 	\
113 	im *= -1; \
114 	\
115 	Q[0] = re; \
116 	Q[1] = im; \
117 }
118 static void
119 vips_complex_buffer( VipsArithmetic *arithmetic, 
120 	VipsPel *out, VipsPel **in, int width )
121 {
122 	VipsComplex *cmplx = (VipsComplex *) arithmetic;
123 	VipsImage *im = arithmetic-&gt;ready[0];
124 	const int sz = width * vips_image_get_bands( im );
125 	int x;
126 	switch( cmplx-&gt;cmplx ) {
127 	case VIPS_OPERATION_COMPLEX_POLAR:	SWITCH( POLAR ); break;
128 	case VIPS_OPERATION_COMPLEX_RECT: 	SWITCH( RECT ); break;
129 	case VIPS_OPERATION_COMPLEX_CONJ: 	SWITCH( CONJ ); break;
130 	default:
131 		g_assert_not_reached();
132 	}
133 }
134 #define UC VIPS_FORMAT_UCHAR
135 #define C VIPS_FORMAT_CHAR
136 #define US VIPS_FORMAT_USHORT
137 #define S VIPS_FORMAT_SHORT
138 #define UI VIPS_FORMAT_UINT
139 #define I VIPS_FORMAT_INT
140 #define F VIPS_FORMAT_FLOAT
141 #define X VIPS_FORMAT_COMPLEX
142 #define D VIPS_FORMAT_DOUBLE
143 #define DX VIPS_FORMAT_DPCOMPLEX
144 static const VipsBandFormat vips_complex_format_table[10] = {
145    X,  X,  X,  X,  X,  X,  X,  X,  DX, DX 
146 };
147 static void
148 <a name="0"></a>vips_complex_class_init( VipsComplexClass *class )
149 {
150 	GObjectClass *gobject_class = G_OBJECT_CLASS( class );
151 <font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>	VipsObjectClass *object_class = (VipsObjectClass *) class;
152 	VipsArithmeticClass *aclass = VIPS_ARITHMETIC_CLASS( class );
153 	gobject_class-&gt;set_property = vips_object_set_property;
154 	gobject_class-&gt;get_property = vips_object_get_property;
155 	object_class-&gt;nickname = "complex";
156 	object_class-&gt;description = 
157 		_( "perform a complex operation on an image" );
158 	aclass-&gt;process_line = vips_complex_buffer;
159 	vips_arithmetic_set_format_table( aclass, vips_complex_format_table ); 
160 	VIPS_ARG_ENUM( class, "cmplx", 200, 
161 		_( "Operation" ), 
162 		_( "complex to perform" ),
163 		VIPS_ARGUMENT_REQUIRED_INPUT,
164 		G_STRUCT_OFFSET( VipsComplex, cmplx ),
165 		VIPS_TYPE_OPERATION_COMPLEX, VIPS_OPERATION_COMPLEX_POLAR ); 
166 }
167 static void
168 vips_complex_init( VipsComplex *cmplx )
169 {</b></font>
170 }
171 static int
172 vips_complexv( VipsImage *in, VipsImage **out, 
173 	VipsOperationComplex cmplx, va_list ap )
174 {
175 	return( vips_call_split( "complex", ap, in, out, cmplx ) );
176 }
177 int
178 vips_complex( VipsImage *in, VipsImage **out, VipsOperationComplex cmplx, ... )
179 {
180 	va_list ap;
181 	int result;
182 	va_start( ap, cmplx );
183 	result = vips_complexv( in, out, cmplx, ap );
184 	va_end( ap );
185 	return( result );
186 }
187 int
188 vips_polar( VipsImage *in, VipsImage **out, ... )
189 {
190 	va_list ap;
191 	int result;
192 	va_start( ap, out );
193 	result = vips_complexv( in, out, VIPS_OPERATION_COMPLEX_POLAR, ap );
194 	va_end( ap );
195 	return( result );
196 }
197 int
198 vips_rect( VipsImage *in, VipsImage **out, ... )
199 {
200 	va_list ap;
201 	int result;
202 	va_start( ap, out );
203 	result = vips_complexv( in, out, VIPS_OPERATION_COMPLEX_RECT, ap );
204 	va_end( ap );
205 	return( result );
206 }
207 int
208 vips_conj( VipsImage *in, VipsImage **out, ... )
209 {
210 	va_list ap;
211 	int result;
212 	va_start( ap, out );
213 	result = vips_complexv( in, out, VIPS_OPERATION_COMPLEX_CONJ, ap );
214 	va_end( ap );
215 	return( result );
216 }
217 typedef struct _VipsComplex2 {
218 	VipsBinary parent_instance;
219 	VipsOperationComplex2 cmplx;
220 } VipsComplex2;
221 typedef VipsBinaryClass VipsComplex2Class;
222 G_DEFINE_TYPE( VipsComplex2, vips_complex2, VIPS_TYPE_BINARY );
223 #define LOOP2( IN, OUT, OP ) { \
224 	IN *p1 = (IN *) in[0]; \
225 	IN *p2 = (IN *) in[1]; \
226 	OUT *q = (OUT *) out; \
227 	\
228 	for( x = 0; x &lt; sz; x++ ) { \
229 		OP( q, p1[x], 0.0, p2[x], 0.0 ); \
230 		\
231 		q += 2; \
232 	} \
233 }
234 #define CLOOP2( IN, OUT, OP ) { \
235 	IN *p1 = (IN *) in[0]; \
236 	IN *p2 = (IN *) in[1]; \
237 	OUT *q = (OUT *) out; \
238 	\
239 	for( x = 0; x &lt; sz; x++ ) { \
240 		OP( q, p1[0], p1[1], p2[0], p2[1] ); \
241 		\
242 		p1 += 2; \
243 		p2 += 2; \
244 		q += 2; \
245 	} \
246 }
247 #define SWITCH2( OP ) \
248 	switch( vips_image_get_format( im ) ) { \
249 	case VIPS_FORMAT_UCHAR: \
250 		LOOP2( unsigned char, float, OP ); break; \
251 	case VIPS_FORMAT_CHAR: \
252 		LOOP2( signed char, float, OP ); break; \
253 	case VIPS_FORMAT_USHORT: \
254 		LOOP2( unsigned short, float, OP ); break; \
255 	case VIPS_FORMAT_SHORT: \
256 		LOOP2( signed short, float, OP ); break; \
257 	case VIPS_FORMAT_UINT: \
258 		LOOP2( unsigned int, float, OP ); break; \
259 	case VIPS_FORMAT_INT: \
260 		LOOP2( signed int, float, OP ); break; \
261 	case VIPS_FORMAT_FLOAT: \
262 		LOOP2( float, float, OP ); break; \
263 	case VIPS_FORMAT_DOUBLE: \
264 		LOOP2( double, double, OP ); break;\
265 	case VIPS_FORMAT_COMPLEX: \
266 		CLOOP2( float, float, OP ); break; \
267 	case VIPS_FORMAT_DPCOMPLEX: \
268 		CLOOP2( double, double, OP ); break;\
269  	\
270 	default: \
271 		g_assert_not_reached(); \
272 	} 
273 #define USE_MODARG_DIV
274 #ifdef USE_MODARG_DIV
275 #define CROSS( Q, X1, Y1, X2, Y2 ) { \
276 	if( ((X1) == 0.0 &amp;&amp; (Y1) == 0.0) || \
277 		((X2) == 0.0 &amp;&amp; (Y2) == 0.0) ) { \
278 		Q[0] = 0.0; \
279 		Q[1] = 0.0; \
280 	} \
281 	else { \
282 		double arg = atan2( X2, X1 ) - atan2( Y2, Y1 ); \
283 		\
284 		Q[0] = cos( arg ); \
285 		Q[1] = sin( arg ); \
286 	} \
287 }
288 #else 
289 #define CROSS( Q, X1, Y1, X2, Y2 ) { \
290 	if( ((X1) == 0.0 &amp;&amp; (Y1) == 0.0) || \
291 		((X2) == 0.0 &amp;&amp; (Y2) == 0.0) ) { \
292 		Q[0] = 0.0; \
293 		Q[1] = 0.0; \
294 	} \
295 	else if( ABS( Y1 ) &gt; ABS( Y2 ) ) { \
296 		double a = Y2 / Y1; \
297 		double b = Y1 + Y2 * a; \
298 		double re = (X1 + X2 * a) / b; \
299 		double im = (X2 - X1 * a) / b; \
300 		double mod = vips__hypot( re, im ); \
301 		\
302 		Q[0] = re / mod; \
303 		Q[1] = im / mod; \
304 	} \
305 	else { \
306 		double a = Y1 / Y2; \
307 		double b = Y2 + Y1 * a; \
308 		double re = (X1 * a + X2) / b; \
309 		double im = (X2 * a - X1) / b; \
310 		double mod = vips__hypot( re, im ); \
311 		\
312 		Q[0] = re / mod; \
313 		Q[1] = im / mod; \
314 	} \
315 }
316 #endif 
317 static void
318 vips_complex2_buffer( VipsArithmetic *arithmetic, 
319 	VipsPel *out, VipsPel **in, int width )
320 {
321 	VipsComplex2 *cmplx = (VipsComplex2 *) arithmetic;
322 	VipsImage *im = arithmetic-&gt;ready[0];
323 	const int sz = width * vips_image_get_bands( im );
324 	int x;
325 	switch( cmplx-&gt;cmplx ) {
326 	case VIPS_OPERATION_COMPLEX2_CROSS_PHASE:	
327 		SWITCH2( CROSS ); 
328 		break;
329 	default:
330 		g_assert_not_reached();
331 	}
332 }
333 #define UC VIPS_FORMAT_UCHAR
334 #define C VIPS_FORMAT_CHAR
335 #define US VIPS_FORMAT_USHORT
336 #define S VIPS_FORMAT_SHORT
337 #define UI VIPS_FORMAT_UINT
338 #define I VIPS_FORMAT_INT
339 #define F VIPS_FORMAT_FLOAT
340 #define X VIPS_FORMAT_COMPLEX
341 #define D VIPS_FORMAT_DOUBLE
342 #define DX VIPS_FORMAT_DPCOMPLEX
343 <a name="2"></a>static const VipsBandFormat vips_complex2_format_table[10] = {
344    X,  X,  X,  X,  X,  X,  X,  X,  DX, DX 
345 <font color="#980517"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>};
346 static void
347 vips_complex2_class_init( VipsComplex2Class *class )
348 {
349 	GObjectClass *gobject_class = G_OBJECT_CLASS( class );
350 	VipsObjectClass *object_class = (VipsObjectClass *) class;
351 	VipsArithmeticClass *aclass = VIPS_ARITHMETIC_CLASS( class );
352 	gobject_class-&gt;set_property = vips_object_set_property;</b></font>
353 	gobject_class-&gt;get_property = vips_object_get_property;
354 	object_class-&gt;nickname = "complex2";
355 	object_class-&gt;description = 
356 		_( "complex binary operations on two images" );
357 	aclass-&gt;process_line = vips_complex2_buffer;
358 	vips_arithmetic_set_format_table( aclass, vips_complex2_format_table ); 
359 	VIPS_ARG_ENUM( class, "cmplx", 200, 
360 		_( "Operation" ), 
361 		_( "binary complex operation to perform" ),
362 		VIPS_ARGUMENT_REQUIRED_INPUT,
363 		G_STRUCT_OFFSET( VipsComplex2, cmplx ),
364 		VIPS_TYPE_OPERATION_COMPLEX2, 
365 			VIPS_OPERATION_COMPLEX2_CROSS_PHASE ); 
366 }
367 static void
368 vips_complex2_init( VipsComplex2 *cmplx )
369 {
370 }
371 static int
372 vips_complex2v( VipsImage *left, VipsImage *right, VipsImage **out, 
373 	VipsOperationComplex2 cmplx, va_list ap )
374 {
375 	return( vips_call_split( "complex2", ap, left, right, out, cmplx ) );
376 }
377 int
378 vips_complex2( VipsImage *left, VipsImage *right, VipsImage **out, 
379 	VipsOperationComplex2 cmplx, ... )
380 {
381 	va_list ap;
382 	int result;
383 	va_start( ap, cmplx );
384 	result = vips_complex2v( left, right, out, cmplx, ap );
385 	va_end( ap );
386 	return( result );
387 }
388 int
389 vips_cross_phase( VipsImage *left, VipsImage *right, VipsImage **out, ... )
390 {
391 	va_list ap;
392 	int result;
393 	va_start( ap, out );
394 	result = vips_complex2v( left, right, out, 
395 		VIPS_OPERATION_COMPLEX2_CROSS_PHASE, ap );
396 	va_end( ap );
397 	return( result );
398 }
399 typedef struct _VipsComplexget {
400 	VipsUnary parent_instance;
401 	VipsOperationComplexget get;
402 } VipsComplexget;
403 typedef VipsUnaryClass VipsComplexgetClass;
404 G_DEFINE_TYPE( VipsComplexget, vips_complexget, VIPS_TYPE_UNARY );
405 static int
406 vips_complexget_build( VipsObject *object )
407 {
408 	VipsUnary *unary = (VipsUnary *) object;
409 	VipsComplexget *complexget = (VipsComplexget *) object;
410 	if( unary-&gt;in &amp;&amp;
411 		!vips_band_format_iscomplex( unary-&gt;in-&gt;BandFmt ) &amp;&amp;
412 		complexget-&gt;get == VIPS_OPERATION_COMPLEXGET_REAL ) 
413 		return( vips_unary_copy( unary ) ); 
414 	if( VIPS_OBJECT_CLASS( vips_complexget_parent_class )-&gt;build( object ) )
415 		return( -1 );
416 	return( 0 );
417 }
418 #define GETLOOP( TYPE, OP ) { \
419 	TYPE *p __attribute__ ((unused)) = (TYPE *) in[0]; \
420 	TYPE *q = (TYPE *) out; \
421 	\
422 	for( x = 0; x &lt; sz; x++ ) { \
423 		OP( q[x], p[x], 0.0 ); \
424 	} \
425 }
426 #define CGETLOOP( TYPE, OP ) { \
427 	TYPE *p __attribute__ ((unused)) = (TYPE *) in[0]; \
428 	TYPE *q = (TYPE *) out; \
429 	\
430 	for( x = 0; x &lt; sz; x++ ) { \
431 		OP( q[x], p[0], p[1] ); \
432 		\
433 		p += 2; \
434 	} \
435 }
436 #define GETSWITCH( OP ) \
437 	switch( vips_image_get_format( im ) ) { \
438 	case VIPS_FORMAT_UCHAR: \
439 		GETLOOP( unsigned char, OP ); break; \
440 	case VIPS_FORMAT_CHAR: \
441 		GETLOOP( signed char, OP ); break; \
442 	case VIPS_FORMAT_USHORT: \
443 		GETLOOP( unsigned short, OP ); break; \
444 	case VIPS_FORMAT_SHORT: \
445 		GETLOOP( signed short, OP ); break; \
446 	case VIPS_FORMAT_UINT: \
447 		GETLOOP( unsigned int, OP ); break; \
448 	case VIPS_FORMAT_INT: \
449 		GETLOOP( signed int, OP ); break; \
450 	case VIPS_FORMAT_FLOAT: \
451 		GETLOOP( float, OP ); break; \
452 	case VIPS_FORMAT_DOUBLE: \
453 		GETLOOP( double, OP ); break;\
454 	case VIPS_FORMAT_COMPLEX: \
455 		CGETLOOP( float, OP ); break; \
456 	case VIPS_FORMAT_DPCOMPLEX: \
457 		CGETLOOP( double, OP ); break;\
458  	\
459 	default: \
460 		g_assert_not_reached(); \
461 	} 
462 #define REAL( Q, X, Y ) { \
463 	Q = X; \
464 } 
465 #define IMAG( Q, X, Y ) { \
466 	Q = Y; \
467 } 
468 static void
469 vips_complexget_buffer( VipsArithmetic *arithmetic, 
470 	VipsPel *out, VipsPel **in, int width )
471 {
472 	VipsComplexget *complexget = (VipsComplexget *) arithmetic;
473 	VipsImage *im = arithmetic-&gt;ready[0];
474 	const int sz = width * vips_image_get_bands( im );
475 	int x;
476 	switch( complexget-&gt;get ) {
477 	case VIPS_OPERATION_COMPLEXGET_REAL:	GETSWITCH( REAL ); break;
478 	case VIPS_OPERATION_COMPLEXGET_IMAG:	GETSWITCH( IMAG ); break;
479 	default:
480 		g_assert_not_reached();
481 	}
482 }
483 #define UC VIPS_FORMAT_UCHAR
484 #define C VIPS_FORMAT_CHAR
485 #define US VIPS_FORMAT_USHORT
486 #define S VIPS_FORMAT_SHORT
487 #define UI VIPS_FORMAT_UINT
488 #define I VIPS_FORMAT_INT
489 #define F VIPS_FORMAT_FLOAT
490 #define X VIPS_FORMAT_COMPLEX
491 #define D VIPS_FORMAT_DOUBLE
492 #define DX VIPS_FORMAT_DPCOMPLEX
493 static const VipsBandFormat vips_complexget_format_table[10] = {
494    UC, C,  US, S,  UI, I,  F,  F,  D,  D
495 };
496 static void
497 vips_complexget_class_init( VipsComplexgetClass *class )
498 {
499 	GObjectClass *gobject_class = G_OBJECT_CLASS( class );
500 	VipsObjectClass *object_class = (VipsObjectClass *) class;
501 	VipsArithmeticClass *aclass = VIPS_ARITHMETIC_CLASS( class );
502 	gobject_class-&gt;set_property = vips_object_set_property;
503 	gobject_class-&gt;get_property = vips_object_get_property;
504 	object_class-&gt;nickname = "complexget";
505 	object_class-&gt;description = _( "get a component from a complex image" );
506 	object_class-&gt;build = vips_complexget_build;
507 	aclass-&gt;process_line = vips_complexget_buffer;
508 	vips_arithmetic_set_format_table( aclass, 
509 		vips_complexget_format_table ); 
510 	VIPS_ARG_ENUM( class, "get", 200, 
511 		_( "Operation" ), 
512 		_( "complex to perform" ),
513 		VIPS_ARGUMENT_REQUIRED_INPUT,
514 		G_STRUCT_OFFSET( VipsComplexget, get ),
515 		VIPS_TYPE_OPERATION_COMPLEXGET, 
516 			VIPS_OPERATION_COMPLEXGET_REAL ); 
517 }
518 static void
519 vips_complexget_init( VipsComplexget *complexget )
520 {
521 }
522 static int
523 vips_complexgetv( VipsImage *in, VipsImage **out, 
524 	VipsOperationComplexget get, va_list ap )
525 {
526 	return( vips_call_split( "complexget", ap, in, out, get ) );
527 }
528 int
529 vips_complexget( VipsImage *in, VipsImage **out, 
530 	VipsOperationComplexget get, ... )
531 {
532 	va_list ap;
533 	int result;
534 	va_start( ap, get );
535 	result = vips_complexgetv( in, out, get, ap );
536 	va_end( ap );
537 	return( result );
538 }
539 int
540 vips_real( VipsImage *in, VipsImage **out, ... )
541 {
542 	va_list ap;
543 	int result;
544 	va_start( ap, out );
545 	result = vips_complexgetv( in, out, 
546 		VIPS_OPERATION_COMPLEXGET_REAL, ap );
547 	va_end( ap );
548 	return( result );
549 }
550 int
551 vips_imag( VipsImage *in, VipsImage **out, ... )
552 {
553 	va_list ap;
554 	int result;
555 	va_start( ap, out );
556 	result = vips_complexgetv( in, out, 
557 		VIPS_OPERATION_COMPLEXGET_IMAG, ap );
558 	va_end( ap );
559 	return( result );
560 }
561 typedef VipsBinary VipsComplexform;
562 typedef VipsBinaryClass VipsComplexformClass;
563 G_DEFINE_TYPE( VipsComplexform, vips_complexform, VIPS_TYPE_BINARY );
564 static int
565 vips_complexform_build( VipsObject *object )
566 {
567 	VipsObjectClass *class = VIPS_OBJECT_GET_CLASS( object );
568 	VipsBinary *binary = (VipsBinary *) object;
569 	if( binary-&gt;left &amp;&amp;
570 		vips_check_noncomplex( class-&gt;nickname, binary-&gt;left ) )
571 		return( -1 );
572 	if( binary-&gt;right &amp;&amp;
573 		vips_check_noncomplex( class-&gt;nickname, binary-&gt;right ) )
574 		return( -1 );
575 	if( VIPS_OBJECT_CLASS( vips_complexform_parent_class )-&gt;
576 		build( object ) )
577 		return( -1 );
578 	return( 0 );
579 }
580 #define CFORM( IN, OUT ) { \
581 	IN *left = (IN *) in[0]; \
582 	IN *right = (IN *) in[1]; \
583 	OUT *q = (OUT *) out; \
584 	\
585 	for( x = 0; x &lt; sz; x++ ) { \
586 		q[0] = left[x]; \
587 		q[1] = right[x]; \
588 		\
589 		q += 2; \
590 	} \
591 }
592 static void
593 vips_complexform_buffer( VipsArithmetic *arithmetic, 
594 	VipsPel *out, VipsPel **in, int width )
595 {
596 	VipsImage *im = arithmetic-&gt;ready[0];
597 	const int sz = width * vips_image_get_bands( im );
598 	int x;
599         switch( vips_image_get_format( im ) ) {
600         case VIPS_FORMAT_UCHAR:	
601 		CFORM( unsigned char, float ); break; 
602         case VIPS_FORMAT_CHAR: 	
603 		CFORM( signed char, float ); break; 
604         case VIPS_FORMAT_USHORT:
605 		CFORM( unsigned short, float ); break; 
606         case VIPS_FORMAT_SHORT:	
607 		CFORM( signed short, float ); break; 
608         case VIPS_FORMAT_UINT: 	
609 		CFORM( unsigned int, float ); break; 
610         case VIPS_FORMAT_INT: 	
611 		CFORM( signed int, float ); break; 
612         case VIPS_FORMAT_FLOAT:	
613 		CFORM( float, float ); break; 
614         case VIPS_FORMAT_DOUBLE: 
615 		CFORM( double, double ); break;
616         default:
617 		g_assert_not_reached();
618         }
619 }
620 #define UC VIPS_FORMAT_UCHAR
621 #define C VIPS_FORMAT_CHAR
622 #define US VIPS_FORMAT_USHORT
623 #define S VIPS_FORMAT_SHORT
624 #define UI VIPS_FORMAT_UINT
625 #define I VIPS_FORMAT_INT
626 #define F VIPS_FORMAT_FLOAT
627 #define X VIPS_FORMAT_COMPLEX
628 #define D VIPS_FORMAT_DOUBLE
629 #define DX VIPS_FORMAT_DPCOMPLEX
630 <a name="1"></a>static int vips_complexform_format_table[10] = {
631    X,  X,  X,  X,  X,  X, X, X, DX,DX
632 <font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>};
633 static void
634 vips_complexform_class_init( VipsComplexformClass *class )
635 {
636 	VipsObjectClass *object_class = (VipsObjectClass *) class;
637 	VipsArithmeticClass *aclass = VIPS_ARITHMETIC_CLASS( class );
638 	object_class-&gt;nickname = "complexform";
639 	object_class-&gt;description = 
640 		_( "form a complex image from two real images" );
641 	object_class-&gt;build = vips_complexform_build;
642 	aclass-&gt;process_line = vips_complexform_buffer;</b></font>
643 	vips_arithmetic_set_format_table( aclass, 
644 		vips_complexform_format_table ); 
645 }
646 static void
647 vips_complexform_init( VipsComplexform *complexform )
648 {
649 }
650 int
651 vips_complexform( VipsImage *left, VipsImage *right, VipsImage **out, ... )
652 {
653 	va_list ap;
654 	int result;
655 	va_start( ap, out );
656 	result = vips_call_split( "complexform", ap, left, right, out );
657 	va_end( ap );
658 	return( result );
659 }
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>dzsave.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 #ifdef HAVE_CONFIG_H
2 #include &lt;config.h&gt;
3 #include &lt;vips/intl.h&gt;
4 #include &lt;stdio.h&gt;
5 #include &lt;stdlib.h&gt;
6 #include &lt;string.h&gt;
7 #include &lt;vips/vips.h&gt;
8 #include &lt;vips/internal.h&gt;
9 #ifdef HAVE_GSF
10 #pragma GCC diagnostic push
11 #pragma GCC diagnostic ignored "-Wdeprecated-declarations"
12 #include &lt;gsf/gsf.h&gt;
13 #pragma GCC diagnostic pop
14 typedef struct _VipsGsfDirectory { 
15 	struct _VipsGsfDirectory *parent;
16 	char *name;
17 	GSList *children;
18 	GsfOutput *out;
19         GsfOutput *container;
20 	size_t file_count;
21 	size_t filename_lengths;
22 	gint deflate_level;
23 } VipsGsfDirectory; 
24 static void *vips_gsf_tree_close( VipsGsfDirectory *tree );
25 static void *
26 vips_gsf_tree_close_cb( void *item, void *a, void *b )
27 {
28 	VipsGsfDirectory *tree = (VipsGsfDirectory *) item;
29 	return( vips_gsf_tree_close( tree ) );
30 }
31 static void *
32 vips_gsf_tree_close( VipsGsfDirectory *tree )
33 {
34 	vips_slist_map2( tree-&gt;children, vips_gsf_tree_close_cb, NULL, NULL );
35 	if( tree-&gt;out ) {
36 		if( !gsf_output_is_closed( tree-&gt;out ) &amp;&amp;
37 			!gsf_output_close( tree-&gt;out ) ) {
38 			vips_error( "vips_gsf", 
39 				"%s", _( "unable to close stream" ) ); 
40 			return( tree );
41 		}
42 		VIPS_UNREF( tree-&gt;out );
43 	}
44 	if( tree-&gt;container ) { 
45 		if( !gsf_output_is_closed( tree-&gt;container ) &amp;&amp; 
46 			!gsf_output_close( tree-&gt;container ) ) {
47 			vips_error( "vips_gsf", 
48 				"%s", _( "unable to close stream" ) ); 
49 			return( tree );
50 		}
51 		VIPS_UNREF( tree-&gt;container );
52 	}
53 	VIPS_FREEF( g_slist_free, tree-&gt;children );
54 	VIPS_FREE( tree-&gt;name );
55 	VIPS_FREE( tree );
56 	return( NULL ); 
57 }
58 static VipsGsfDirectory *
59 vips_gsf_tree_new( GsfOutput *out, gint deflate_level )
60 {
61 	VipsGsfDirectory *tree = g_new( VipsGsfDirectory, 1 );
62 	tree-&gt;parent = NULL;
63 	tree-&gt;name = NULL;
64 	tree-&gt;children = NULL;
65 	tree-&gt;out = out;
66 	tree-&gt;container = NULL;
67 	tree-&gt;file_count = 0;
68 	tree-&gt;filename_lengths = 0;
69 	tree-&gt;deflate_level = deflate_level;
70 	return( tree ); 
71 }
72 static void *
73 vips_gsf_child_by_name_sub( VipsGsfDirectory *dir, const char *name, void *b )
74 {
75 	if( strcmp( dir-&gt;name, name ) == 0 )
76 		return( dir );
77 	return( NULL ); 
78 }
79 static VipsGsfDirectory *
80 vips_gsf_child_by_name( VipsGsfDirectory *dir, const char *name )
81 {
82 	return( vips_slist_map2( dir-&gt;children, 
83 		(VipsSListMap2Fn) vips_gsf_child_by_name_sub, 
84 		(char *) name, NULL ) );
85 }
86 static VipsGsfDirectory *
87 vips_gsf_dir_new( VipsGsfDirectory *parent, const char *name )
88 {
89 	VipsGsfDirectory *dir = g_new( VipsGsfDirectory, 1 );
90 	g_assert( !vips_gsf_child_by_name( parent, name ) ); 
91 	dir-&gt;parent = parent;
92 	dir-&gt;name = g_strdup( name );
93 	dir-&gt;children = NULL;
94 	dir-&gt;container = NULL;
95 	dir-&gt;file_count = 0;
96 	dir-&gt;filename_lengths = 0;
97 	dir-&gt;deflate_level = parent-&gt;deflate_level;
98 	if( GSF_IS_OUTFILE_ZIP( parent-&gt;out ) )
99 		dir-&gt;out = gsf_outfile_new_child_full( 
100 			(GsfOutfile *) parent-&gt;out, 
101 			name, TRUE,
102 			"compression-level", GSF_ZIP_STORED,
103 			NULL );
104 	else
105 		dir-&gt;out = gsf_outfile_new_child( 
106 			(GsfOutfile *) parent-&gt;out, 
107 			name, TRUE ); 
108 	g_assert( dir-&gt;out ); 
109 	parent-&gt;children = g_slist_prepend( parent-&gt;children, dir ); 
110 	return( dir ); 
111 }
112 static GsfOutput *
113 vips_gsf_path( VipsGsfDirectory *tree, const char *name, ... )
114 {
115 	va_list ap;
116 	VipsGsfDirectory *dir;
117 	VipsGsfDirectory *child;
118 	char *dir_name;
119 	GsfOutput *obj;
120 	tree-&gt;file_count += 1;
121 	tree-&gt;filename_lengths += 
122 		strlen( tree-&gt;out-&gt;name ) + strlen( name ) + 1;
123 	dir = tree; 
124 	va_start( ap, name );
125 	while( (dir_name = va_arg( ap, char * )) ) {
126 		if( (child = vips_gsf_child_by_name( dir, dir_name )) )
127 			dir = child;
128 		else 
129 			dir = vips_gsf_dir_new( dir, dir_name );
130 		tree-&gt;filename_lengths += strlen( dir_name ) + 1;
131 	}
132 	va_end( ap );
133 	if( GSF_IS_OUTFILE_ZIP( dir-&gt;out ) ) {
134 		if( dir-&gt;deflate_level == 0 )
135 			obj = gsf_outfile_new_child_full(
136 				(GsfOutfile *) dir-&gt;out,
137 				name, FALSE,
138 				"compression-level", GSF_ZIP_STORED,
139 				NULL );
140 		else if( dir-&gt;deflate_level == -1 )
141 			obj = gsf_outfile_new_child_full(
142 				(GsfOutfile *) dir-&gt;out,
143 				name, FALSE,
144 				"compression-level", GSF_ZIP_DEFLATED,
145 				NULL );
146 		else
147 			obj = gsf_outfile_new_child_full(
148 				(GsfOutfile *) dir-&gt;out,
149 				name, FALSE,
150 				"compression-level", GSF_ZIP_DEFLATED,
151 				"deflate-level", dir-&gt;deflate_level,
152 				NULL );
153 	}
154 	else
155 		obj = gsf_outfile_new_child( (GsfOutfile *) dir-&gt;out,
156 			name, FALSE ); 
157 	return( obj ); 
158 }
159 typedef struct _VipsForeignSaveDz VipsForeignSaveDz;
160 typedef struct _Layer Layer;
161 struct _Layer {
162 	VipsForeignSaveDz *dz;
163 	int width;
164 	int height;
165 	int tiles_across;
166 	int tiles_down;
167 	VipsRect real_pixels; 
168 	VipsImage *image;
169 	int y;
170 	int write_y;
171 	VipsRegion *strip;			VipsRegion *copy;		
172 	int sub;				int n;				
173 	Layer *below;				Layer *above;			};
174 struct _VipsForeignSaveDz {
175 	VipsForeignSave parent_object;
176 	char *suffix;
177 	int overlap;
178 	int tile_size;
179 	VipsForeignDzLayout layout;
180 	VipsForeignDzDepth depth;
181 	gboolean centre;
182 	gboolean properties;
183 	VipsAngle angle;
184 	VipsForeignDzContainer container; 
185 	int compression;
186 	VipsRegionShrink region_shrink;
187 	int skip_blanks;
188 	gboolean no_strip;
189 	char *id;
190 	int tile_margin;
191 	int tile_step;
192 	Layer *layer;			
193 	int tile_count;
194 	VipsGsfDirectory *tree;
195 	GsfOutput *out;
196 	char *basename; 
197 	char *dirname; 
198 	char *tempdir;
199 	char *root_name; 
200 	char *file_suffix;
201 	size_t bytes_written;
202 	VipsPel *ink;
203 };
204 typedef VipsForeignSaveClass VipsForeignSaveDzClass;
205 G_DEFINE_ABSTRACT_TYPE( VipsForeignSaveDz, vips_foreign_save_dz, 
206 	VIPS_TYPE_FOREIGN_SAVE );
207 static gboolean
208 iszip( VipsForeignDzContainer container )
209 {
210 	switch( container ) {
211 	case VIPS_FOREIGN_DZ_CONTAINER_ZIP:
212 	case VIPS_FOREIGN_DZ_CONTAINER_SZI:
213 		return( TRUE );
214 	default:
215 		return( FALSE );
216 	}
217 }
218 #define VIPS_ZIP_FIXED_LH_SIZE (30 + 29)
219 #define VIPS_ZIP_FIXED_CD_SIZE (46 + 9)
220 #define VIPS_ZIP_EOCD_SIZE 22
221 #ifndef HAVE_GSF_ZIP64
222 static size_t
223 estimate_zip_size( VipsForeignSaveDz *dz )
224 {
225 	size_t estimated_zip_size = dz-&gt;bytes_written +
226 		dz-&gt;tree-&gt;file_count * VIPS_ZIP_FIXED_LH_SIZE +
227 		dz-&gt;tree-&gt;filename_lengths +
228 		dz-&gt;tree-&gt;file_count * VIPS_ZIP_FIXED_CD_SIZE +
229 		dz-&gt;tree-&gt;filename_lengths +
230 		VIPS_ZIP_EOCD_SIZE;
231 #ifdef DEBUG_VERBOSE
232 	printf( "estimate_zip_size: %zd\n", estimated_zip_size );
233 	return( estimated_zip_size );
234 }
235 static int
236 write_image( VipsForeignSaveDz *dz,
237 	GsfOutput *out, VipsImage *image, const char *format )
238 {
239 	VipsObjectClass *class = VIPS_OBJECT_GET_CLASS( dz );
240 	VipsImage *t;
241 	void *buf;
242 	size_t len;
243 	if( vips_copy( image, &amp;t, NULL ) ) 
244 		return( -1 );
245 	vips_image_set_int( t, "hide-progress", 1 );
246 	if( vips_image_write_to_buffer( t, format, &amp;buf, &amp;len,
247 		"strip", !dz-&gt;no_strip,
248 		NULL ) ) {
249 		VIPS_UNREF( t );
250 		return( -1 );
251 	}
252 	VIPS_UNREF( t );
253 	g_mutex_lock( vips__global_lock );
254 	if( !gsf_output_write( out, len, buf ) ) {
255 		gsf_output_close( out );
256 		g_mutex_unlock( vips__global_lock );
257 		g_free( buf );
258 		vips_error( class-&gt;nickname,
259 			"%s", gsf_output_error( out )-&gt;message );
260 		return( -1 );
261 	}
262 	dz-&gt;bytes_written += len;
263 	gsf_output_close( out );
264 #ifndef HAVE_GSF_ZIP64
265 	if( iszip( dz-&gt;container ) ) {
266 		if( dz-&gt;tree-&gt;file_count + 3 &gt;= (unsigned int) USHRT_MAX ) {
267 			g_mutex_unlock( vips__global_lock );
268 			vips_error( class-&gt;nickname,
269 				"%s", _( "too many files in zip" ) );
270 			return( -1 );
271 		}
272 		if( estimate_zip_size( dz ) &gt; (size_t) UINT_MAX - 16384) {
273 			g_mutex_unlock( vips__global_lock );
274 			vips_error( class-&gt;nickname,
275 				"%s", _( "output file too large" ) ); 
276 			return( -1 ); 
277 		}
278 	}
279 	g_mutex_unlock( vips__global_lock );
280 	g_free( buf );
281 	return( 0 );
282 }
283 static void
284 layer_free( Layer *layer )
285 {
286 	VIPS_FREEF( g_object_unref, layer-&gt;strip );
287 	VIPS_FREEF( g_object_unref, layer-&gt;copy );
288 	VIPS_FREEF( g_object_unref, layer-&gt;image );
289 	VIPS_FREEF( layer_free, layer-&gt;below ); 
290 }
291 static void
292 vips_foreign_save_dz_dispose( GObject *gobject )
293 {
294 	VipsForeignSaveDz *dz = (VipsForeignSaveDz *) gobject;
295 	VIPS_FREEF( layer_free, dz-&gt;layer );
296 	VIPS_FREEF( vips_gsf_tree_close,  dz-&gt;tree );
297 	VIPS_FREEF( g_object_unref, dz-&gt;out );
298 	VIPS_FREE( dz-&gt;basename );
299 	VIPS_FREE( dz-&gt;dirname );
300 	VIPS_FREE( dz-&gt;tempdir );
301 	VIPS_FREE( dz-&gt;root_name );
302 	VIPS_FREE( dz-&gt;file_suffix );
303 	G_OBJECT_CLASS( vips_foreign_save_dz_parent_class )-&gt;
304 		dispose( gobject );
305 }
306 static Layer *
307 pyramid_build( VipsForeignSaveDz *dz, Layer *above, 
308 	int width, int height, VipsRect *real_pixels )
309 {
310 	VipsForeignSave *save = VIPS_FOREIGN_SAVE( dz );
311 	Layer *layer = VIPS_NEW( dz, Layer );
312 	VipsRect strip;
313 	int limit; 
314 	layer-&gt;dz = dz;
315 	layer-&gt;width = width;
316 	layer-&gt;height = height;
317 	layer-&gt;tiles_across = VIPS_ROUND_UP( width, dz-&gt;tile_step ) / 
318 		dz-&gt;tile_step;
319 	layer-&gt;tiles_down = VIPS_ROUND_UP( height, dz-&gt;tile_step ) / 
320 		dz-&gt;tile_step;
321 	layer-&gt;real_pixels = *real_pixels; 
322 	layer-&gt;image = NULL;
323 	layer-&gt;strip = NULL;
324 	layer-&gt;copy = NULL;
325 	if( !above )
326 		layer-&gt;sub = 1;	
327 	else
328 		layer-&gt;sub = above-&gt;sub * 2;
329 	layer-&gt;below = NULL;
330 	layer-&gt;above = above;
331 	layer-&gt;image = vips_image_new();
332 	if( vips_image_pipelinev( layer-&gt;image, 
333 		VIPS_DEMAND_STYLE_ANY, save-&gt;ready, NULL ) ) {
334 		layer_free( layer );
335 		return( NULL );
336 	}
337 	layer-&gt;image-&gt;Xsize = width + (width &amp; 1);
338 	layer-&gt;image-&gt;Ysize = height + (height &amp; 1);
339 	layer-&gt;strip = vips_region_new( layer-&gt;image );
340 	layer-&gt;copy = vips_region_new( layer-&gt;image );
341 	vips__region_no_ownership( layer-&gt;strip );
342 	vips__region_no_ownership( layer-&gt;copy );
343 	layer-&gt;y = 0;
344 	layer-&gt;write_y = 0;
345 	strip.left = 0;
346 	strip.top = 0;
347 	strip.width = layer-&gt;image-&gt;Xsize;
348 	strip.height = dz-&gt;tile_size + dz-&gt;tile_margin;
349 	if( (strip.height &amp; 1) == 1 )
350 		strip.height += 1;
351 	if( vips_region_buffer( layer-&gt;strip, &amp;strip ) ) {
352 		layer_free( layer );
353 		return( NULL );
354 	}
355 	switch( dz-&gt;depth ) {
356 	case VIPS_FOREIGN_DZ_DEPTH_ONEPIXEL:
357 		limit = 1;
358 		break;
359 	case VIPS_FOREIGN_DZ_DEPTH_ONETILE:
360 		limit = dz-&gt;tile_size;
361 		break;
362 	case VIPS_FOREIGN_DZ_DEPTH_ONE:
363 		limit = VIPS_MAX( width, height );
364 		break;
365 	default:
366 		g_assert_not_reached();
367 		limit = 1;
368 	}
369 	if( width &gt; limit || 
370 		height &gt; limit ) {
371 		VipsRect halfrect;
372 		halfrect.left = real_pixels-&gt;left / 2;
373 		halfrect.top = real_pixels-&gt;top / 2;
374 		halfrect.width = (VIPS_RECT_RIGHT( real_pixels ) + 1) / 2 - 
375 			halfrect.left;
376 		halfrect.height = (VIPS_RECT_BOTTOM( real_pixels ) + 1) / 2 - 
377 			halfrect.top;
378 		if( !(layer-&gt;below = pyramid_build( dz, layer, 
379 			(width + 1) / 2, (height + 1) / 2,
380 			&amp;halfrect )) ) { 
381 			layer_free( layer );
382 			return( NULL );
383 		}
384 		layer-&gt;n = layer-&gt;below-&gt;n + 1;
385 	}
386 	else
387 		layer-&gt;n = 0;
388 #ifdef DEBUG
389 	printf( "pyramid_build:\n" );
390 	printf( "\tn = %d\n", layer-&gt;n );
391 	printf( "\twidth = %d, height = %d\n", width, height );
392 	printf( "\tXsize = %d, Ysize = %d\n", 
393 		layer-&gt;image-&gt;Xsize, layer-&gt;image-&gt;Ysize );
394 	printf( "\ttiles_across = %d, tiles_down = %d\n", 
395 		layer-&gt;tiles_across, layer-&gt;tiles_down ); 
396 	printf( "\treal_pixels.left = %d, real_pixels.top = %d\n", 
397 		real_pixels-&gt;left, real_pixels-&gt;top ); 
398 	printf( "\treal_pixels.width = %d, real_pixels.height = %d\n", 
399 		real_pixels-&gt;width, real_pixels-&gt;height ); 
400 	return( layer );
401 }
402 static int
403 write_dzi( VipsForeignSaveDz *dz )
404 {
405 	GsfOutput *out;
406 	char buf[VIPS_PATH_MAX];
407 	char *p;
408 	vips_snprintf( buf, VIPS_PATH_MAX, "%s.dzi", dz-&gt;basename );
409 	out = vips_gsf_path( dz-&gt;tree, buf, NULL ); 
410 	vips_snprintf( buf, VIPS_PATH_MAX, "%s", dz-&gt;suffix + 1 );
411 	if( (p = (char *) vips__find_rightmost_brackets( buf )) )
412 		*p = '\0';
413 	gsf_output_printf( out, "&lt;?xml "
414 		"version=\"1.0\" encoding=\"UTF-8\"?&gt;\n" ); 
415 	gsf_output_printf( out, "&lt;Image "
416 		"xmlns=\"http://schemas.microsoft.com/deepzoom/2008\"\n" );
417 	gsf_output_printf( out, "  Format=\"%s\"\n", buf );
418 	gsf_output_printf( out, "  Overlap=\"%d\"\n", dz-&gt;overlap );
419 	gsf_output_printf( out, "  TileSize=\"%d\"\n", dz-&gt;tile_size );
420 	gsf_output_printf( out, "  &gt;\n" ); 
421 	gsf_output_printf( out, "  &lt;Size \n" );
422 	gsf_output_printf( out, "    Height=\"%d\"\n", dz-&gt;layer-&gt;height );
423 	gsf_output_printf( out, "    Width=\"%d\"\n", dz-&gt;layer-&gt;width );
424 	gsf_output_printf( out, "  /&gt;\n" ); 
425 	gsf_output_printf( out, "&lt;/Image&gt;\n" );
426 	(void) gsf_output_close( out );
427 	g_object_unref( out );
428 	return( 0 );
429 }
430 static int
431 write_properties( VipsForeignSaveDz *dz )
432 {
433 	GsfOutput *out;
434 	out = vips_gsf_path( dz-&gt;tree, "ImageProperties.xml", NULL ); 
435 	gsf_output_printf( out, "&lt;IMAGE_PROPERTIES "
436 		"WIDTH=\"%d\" HEIGHT=\"%d\" NUMTILES=\"%d\" "
437 		"NUMIMAGES=\"1\" VERSION=\"1.8\" TILESIZE=\"%d\" /&gt;\n",
438 		dz-&gt;layer-&gt;width,
439 		dz-&gt;layer-&gt;height,
440 		dz-&gt;tile_count,
441 		dz-&gt;tile_size );
442 	(void) gsf_output_close( out );
443 	g_object_unref( out );
444 	return( 0 );
445 }
446 static int
447 write_blank( VipsForeignSaveDz *dz )
448 {
449 	VipsForeignSave *save = (VipsForeignSave *) dz;
450 	VipsImage *x, *t;
451 	int n;
452 	VipsArea *ones;
453 	double *d;
454 	double *bg;
455 	int i;
456 	GsfOutput *out; 
457 	bg = (double *) vips_area_get_data( VIPS_AREA( save-&gt;background ), 
458 		NULL, &amp;n, NULL, NULL );
459 	if( vips_black( &amp;x, dz-&gt;tile_size, dz-&gt;tile_size, "bands", n, NULL ) ) 
460 		return( -1 );
461 	ones = vips_area_new_array( G_TYPE_DOUBLE, sizeof( double ), n );
462 	d = (double *) vips_area_get_data( ones, NULL, NULL, NULL, NULL );
463 	for( i = 0; i &lt; n; i++ )
464 		d[i] = 1.0; 
465 	if( vips_linear( x, &amp;t, d, bg, n, NULL ) ) {
466 		vips_area_unref( ones );
467 		g_object_unref( x );
468 		return( -1 );
469 	}
470 	vips_area_unref( ones );
471 	g_object_unref( x );
472 	x = t;
473 	out = vips_gsf_path( dz-&gt;tree, "blank.png", NULL ); 
474 	if( write_image( dz, out, x, ".png" ) ) {
475 		g_object_unref( out );
476 		g_object_unref( x );
477 		return( -1 );
478 	}
479 	g_object_unref( out );
480 	g_object_unref( x );
481 	return( 0 );
482 }
483 static int
484 write_json( VipsForeignSaveDz *dz )
485 {
486 	const char *name = dz-&gt;basename ? dz-&gt;basename : "untitled";
487 	const char *suffix = dz-&gt;file_suffix[0] == '.' ? 
488 		dz-&gt;file_suffix + 1 : dz-&gt;file_suffix;
489 	GsfOutput *out;
490 	int i;
491 	out = vips_gsf_path( dz-&gt;tree, "info.json", NULL ); 
492 	gsf_output_printf( out, 
493 		"{\n"
494 		"  \"@context\": \"http://iiif.io/api/image/2/context.json\",\n"
495 		"  \"@id\": \"%s/%s\",\n" 
496 		"  \"profile\": [\n"
497 		"    \"http://iiif.io/api/image/2/level0.json\",\n"
498 		"    {\n" 
499 		"      \"formats\": [\n"
500 		"        \"%s\"\n"
501 		"      ],\n"
502 		"      \"qualities\": [\n"
503 		"        \"default\"\n"
504 		"      ]\n"
505 		"    }\n"
506 		"  ],\n"
507 		"  \"protocol\": \"http://iiif.io/api/image\",\n", 
508 		dz-&gt;id ? dz-&gt;id : "https://example.com/iiif",
509 		name, 
510 		suffix );
511 	gsf_output_printf( out, 
512 		"  \"tiles\": [\n"
513 		"    {\n"
514 		"      \"scaleFactors\": [\n" );
515 	for( i = 0; i &lt; dz-&gt;layer-&gt;n; i++ ) {
516 		gsf_output_printf( out, 
517 			"        %d",
518 				1 &lt;&lt; i );
519 		if( i != dz-&gt;layer-&gt;n - 1 )
520 			gsf_output_printf( out, "," );
521 		gsf_output_printf( out, "\n" );
522 	}
523 	gsf_output_printf( out, 
524 		"      ],\n"
525 		"      \"width\": %d\n"
526 		"    }\n"
527 		"  ],\n", dz-&gt;tile_size );
528 	gsf_output_printf( out, 
529 		"  \"width\": %d,\n"
530 		"  \"height\": %d\n", 
531 			dz-&gt;layer-&gt;width,
532 			dz-&gt;layer-&gt;height );
533 	gsf_output_printf( out, 
534 		"}\n" );
535 	(void) gsf_output_close( out );
536 	g_object_unref( out );
537 	return( 0 );
538 }
539 static int
540 write_vips_meta( VipsForeignSaveDz *dz )
541 {
542 	VipsForeignSave *save = (VipsForeignSave *) dz;
543 	char *dump;
544 	GsfOutput *out;
545 	if( !(dump = vips__xml_properties( save-&gt;ready )) )
546                 return( -1 );
547 	if( dz-&gt;layout == VIPS_FOREIGN_DZ_LAYOUT_DZ )
548 		out = vips_gsf_path( dz-&gt;tree, 
549 			"vips-properties.xml", dz-&gt;root_name, NULL );
550 	else
551 		out = vips_gsf_path( dz-&gt;tree, "vips-properties.xml", NULL );
552 	gsf_output_write( out, strlen( dump ), (guchar *) dump ); 
553 	(void) gsf_output_close( out );
554 	g_object_unref( out );
555 	g_free( dump );
556 	return( 0 );
557 }
558 static void
559 build_scan_property( VipsDbuf *dbuf, VipsImage *image, 
560 	const char *vips_name, const char *szi_name )
561 {
562 	const char *str;
563 	GValue value = { 0 };
564 	GValue save_value = { 0 };
565 	GType type;
566 	if( !vips_image_get_typeof( image, vips_name ) )
567 		return;
568 	if( vips_image_get( image, vips_name, &amp;value ) )
569 		return;
570 	type = G_VALUE_TYPE( &amp;value );
571 	if( !g_value_type_transformable( type, VIPS_TYPE_SAVE_STRING ) ) {
572 		g_value_unset( &amp;value );
573 		return;
574 	}
575 	g_value_init( &amp;save_value, VIPS_TYPE_SAVE_STRING );
576 	if( !g_value_transform( &amp;value, &amp;save_value ) ) {
577 		g_value_unset( &amp;value );
578 		return;
579 	}
580 	g_value_unset( &amp;value );
581 	if( !(str = vips_value_get_save_string( &amp;save_value )) ) {
582 		g_value_unset( &amp;save_value );
583 		return;
584 	}
585 	if( !g_utf8_validate( str, -1, NULL ) ) {
586 		g_value_unset( &amp;save_value );
587 		return;
588 	}
589 	vips_dbuf_writef( dbuf, "    &lt;property&gt;\n" );
590 	vips_dbuf_writef( dbuf, "      &lt;name&gt;" );
591 	vips_dbuf_write_amp( dbuf, szi_name );
592 	vips_dbuf_writef( dbuf, "&lt;/name&gt;\n" );
593 	vips_dbuf_writef( dbuf, "      &lt;value type=\"%s\"&gt;",
594 		g_type_name( type )  );
595 	vips_dbuf_write_amp( dbuf, str );
596 	vips_dbuf_writef( dbuf, "&lt;/value&gt;\n" );
597 	vips_dbuf_writef( dbuf, "    &lt;/property&gt;\n" );
598 	g_value_unset( &amp;save_value );
599 }
600 static char *scan_property_names[][2] = {
601 	{ "openslide.vendor", "Vendor" },
602 	{ "openslide.objective-power", "ObjectiveMagnification" },
603 	{ "openslide.mpp-x", "MicronsPerPixelX" },
604 	{ "openslide.mpp-y", "MicronsPerPixelY" },
605 	{ "width", "ImageWidth" },
606 	{ "height", "ImageHeight" }
607 };
608 char *
609 build_scan_properties( VipsImage *image )
610 {
611 	VipsDbuf dbuf;
612 	char *date;
613 	int i;
614 	date = vips__get_iso8601();
615 	vips_dbuf_init( &amp;dbuf );
616 	vips_dbuf_writef( &amp;dbuf, "&lt;?xml version=\"1.0\"?&gt;\n" ); 
617 	vips_dbuf_writef( &amp;dbuf, "&lt;image xmlns=\"http://www.pathozoom.com/szi\""
618 		" date=\"%s\" version=\"1.0\"&gt;\n", date );
619 	vips_dbuf_writef( &amp;dbuf, "  &lt;properties&gt;\n" );  
620 	g_free( date ); 
621 	for( i = 0; i &lt; VIPS_NUMBER( scan_property_names ); i++ )
622 		build_scan_property( &amp;dbuf, image,
623 			scan_property_names[i][0],
624 			scan_property_names[i][1] );
625 	vips_dbuf_writef( &amp;dbuf, "  &lt;/properties&gt;\n" );
626 	vips_dbuf_writef( &amp;dbuf, "&lt;/image&gt;\n" );
627 	return( (char *) vips_dbuf_steal( &amp;dbuf, NULL ) ); 
628 }
629 static int
630 write_scan_properties( VipsForeignSaveDz *dz )
631 {
632 	VipsForeignSave *save = (VipsForeignSave *) dz;
633 	char *dump;
634 	GsfOutput *out;
635 	if( !(dump = build_scan_properties( save-&gt;ready )) )
636                 return( -1 );
637 	out = vips_gsf_path( dz-&gt;tree, "scan-properties.xml", NULL );
638 	gsf_output_write( out, strlen( dump ), (guchar *) dump );
639 	(void) gsf_output_close( out );
640 	g_object_unref( out );
641 	g_free( dump );
642 	return( 0 );
643 }
644 static void *
645 write_associated_images( VipsImage *image,
646 	const char *field, GValue *value, void *a )
647 {
648 	VipsForeignSaveDz *dz = (VipsForeignSaveDz *) a;
649 	if( vips_isprefix( "openslide.associated.", field ) ) {
650 		VipsImage *associated;
651 		const char *p;
652 		const char *q;
653 		GsfOutput *out;
654 		char buf[VIPS_PATH_MAX];
655 		p = field + strlen( "openslide.associated." );
656 		if( (q = strrchr( p, '/' )) )
657 			p = q + 1;
658 		if( vips_image_get_image( image, field, &amp;associated ) )
659 			return( image );
660 		vips_snprintf( buf, VIPS_PATH_MAX, "%s.jpg", p );
661 		out = vips_gsf_path( dz-&gt;tree, buf, "associated_images", NULL );
662 		if( write_image( dz, out, associated, ".jpg" ) ) {
663 			g_object_unref( out );
664 			g_object_unref( associated );
665 			return( image );
666 		}
667 		g_object_unref( out );
668 		g_object_unref( associated );
669 	}
670 	return( NULL );
671 }
672 static int
673 write_associated( VipsForeignSaveDz *dz )
674 {
675 	VipsForeignSave *save = (VipsForeignSave *) dz;
676 	if( vips_image_map( save-&gt;ready, write_associated_images, dz ) )
677 		return( -1 );
678 	return( 0 );
679 }
680 typedef struct _Strip {
681 	Layer *layer; 
682 	VipsImage *image;
683 	int x;
684 } Strip;
685 static void
686 strip_free( Strip *strip )
687 {
688 	g_object_unref( strip-&gt;image );
689 }
690 static void
691 strip_init( Strip *strip, Layer *layer )
692 {
693 	VipsForeignSaveDz *dz = layer-&gt;dz;
694 	VipsRect line, image;
695 	strip-&gt;layer = layer;
696 	strip-&gt;image = NULL;
697 	strip-&gt;x = 0;
698 	image.left = 0;
699 	image.top = 0;
700 	image.width = layer-&gt;image-&gt;Xsize;
701 	image.height = layer-&gt;height;
702 	line.left = 0;
703 	line.top = layer-&gt;y;
704 	line.width = image.width;
705 	line.height = dz-&gt;tile_size;
706 	vips_rect_marginadjust( &amp;line, dz-&gt;tile_margin );
707 	vips_rect_intersectrect( &amp;image, &amp;line, &amp;line );
708 	if( !(strip-&gt;image = vips_image_new_from_memory( 
709 		VIPS_REGION_ADDR( layer-&gt;strip, 0, line.top ),
710 		VIPS_IMAGE_SIZEOF_LINE( layer-&gt;image ) * line.height,
711 		line.width, line.height, 
712 		layer-&gt;image-&gt;Bands, layer-&gt;image-&gt;BandFmt )) ) {
713 		strip_free( strip );
714 		return;
715 	}
716 	if( vips__image_meta_copy( strip-&gt;image, layer-&gt;image ) ) {
717 		strip_free( strip );
718 		return;
719 	}
720 	strip-&gt;image-&gt;Type = layer-&gt;image-&gt;Type;
721 }
722 static int
723 strip_allocate( VipsThreadState *state, void *a, gboolean *stop )
724 {
725 	Strip *strip = (Strip *) a;
726 	Layer *layer = strip-&gt;layer;
727 	VipsForeignSaveDz *dz = layer-&gt;dz;
728 	VipsRect image;
729 #ifdef DEBUG_VERBOSE
730 	printf( "strip_allocate\n" );
731 	if( strip-&gt;x / dz-&gt;tile_step &gt;= layer-&gt;tiles_across ) {
732 		*stop = TRUE;
733 #ifdef DEBUG_VERBOSE
734 		printf( "strip_allocate: done\n" );
735 		return( 0 );
736 	}
737 	image.left = 0;
738 	image.top = 0;
739 	image.width = layer-&gt;width;
740 	image.height = layer-&gt;height;
741 	state-&gt;pos.left = strip-&gt;x;
742 	state-&gt;pos.top = layer-&gt;y;
743 	state-&gt;pos.width = dz-&gt;tile_size;
744 	state-&gt;pos.height = dz-&gt;tile_size;
745 	vips_rect_marginadjust( &amp;state-&gt;pos, dz-&gt;tile_margin );
746 	vips_rect_intersectrect( &amp;image, &amp;state-&gt;pos, &amp;state-&gt;pos );
747 	state-&gt;x = strip-&gt;x;
748 	state-&gt;y = layer-&gt;y;
749 	strip-&gt;x += dz-&gt;tile_step;
750 	return( 0 );
751 }
752 static GsfOutput *
753 tile_name( Layer *layer, int x, int y )
754 {
755 	VipsForeignSaveDz *dz = layer-&gt;dz;
756 	VipsForeignSave *save = (VipsForeignSave *) dz;
757 	GsfOutput *out; 
758 	char name[VIPS_PATH_MAX];
759 	char dirname[VIPS_PATH_MAX];
760 	char dirname2[VIPS_PATH_MAX];
761 	Layer *p;
762 	int n;
763 	switch( dz-&gt;layout ) {
764 	case VIPS_FOREIGN_DZ_LAYOUT_DZ:
765 		vips_snprintf( dirname, VIPS_PATH_MAX, "%d", layer-&gt;n );
766 		vips_snprintf( name, VIPS_PATH_MAX, 
767 			"%d_%d%s", x, y, dz-&gt;file_suffix );
768 		out = vips_gsf_path( dz-&gt;tree, name, 
769 			dz-&gt;root_name, dirname, NULL );
770 		break;
771 	case VIPS_FOREIGN_DZ_LAYOUT_ZOOMIFY:
772 		n = 0;
773 		for( p = layer-&gt;below; p; p = p-&gt;below )
774 			n += p-&gt;tiles_across * p-&gt;tiles_down;
775 		n += y * layer-&gt;tiles_across + x;
776 		vips_snprintf( dirname, VIPS_PATH_MAX, "TileGroup%d", n / 256 );
777 		vips_snprintf( name, VIPS_PATH_MAX, 
778 			"%d-%d-%d%s", layer-&gt;n, x, y, dz-&gt;file_suffix );
779 		dz-&gt;tile_count += 1;
780 		out = vips_gsf_path( dz-&gt;tree, name, dirname, NULL );
781 		break;
782 	case VIPS_FOREIGN_DZ_LAYOUT_GOOGLE:
783 		vips_snprintf( dirname, VIPS_PATH_MAX, "%d", layer-&gt;n );
784 		vips_snprintf( dirname2, VIPS_PATH_MAX, "%d", y );
785 		vips_snprintf( name, VIPS_PATH_MAX, 
786 			"%d%s", x, dz-&gt;file_suffix );
787 		out = vips_gsf_path( dz-&gt;tree, name, dirname, dirname2, NULL );
788 		break;
789 	case VIPS_FOREIGN_DZ_LAYOUT_IIIF:
790 {
791 		int left = x * dz-&gt;tile_size * layer-&gt;sub;
792 		int top = y * dz-&gt;tile_size * layer-&gt;sub;
793 		int width = VIPS_MIN( dz-&gt;tile_size * layer-&gt;sub, 
794 			save-&gt;ready-&gt;Xsize - left );
795 		int height = VIPS_MIN( dz-&gt;tile_size * layer-&gt;sub, 
796 			save-&gt;ready-&gt;Ysize - top );
797 		int size = VIPS_MIN( dz-&gt;tile_size, 
798 			layer-&gt;width - x * dz-&gt;tile_size );
799 		vips_snprintf( dirname, VIPS_PATH_MAX, "%d,%d,%d,%d",
800 			left, top, width, height );
801 		vips_snprintf( dirname2, VIPS_PATH_MAX, "%d,", size );
802 		vips_snprintf( name, VIPS_PATH_MAX, "default%s", 
803 			dz-&gt;file_suffix );
804 		out = vips_gsf_path( dz-&gt;tree, 
805 			name, dirname, dirname2, "0", NULL );
806 }
807 		break;
808 	default:
809 		g_assert_not_reached();
810 		out = NULL;
811 	}
812 #ifdef DEBUG_VERBOSE
813 	printf( "tile_name: writing to %s\n", name );
814 	return( out );
815 }
816 static gboolean
817 tile_equal( VipsImage *image, int threshold, VipsPel * restrict ink )
818 {
819 	const int bytes = VIPS_IMAGE_SIZEOF_PEL( image );
820 	VipsRect rect;
821 	VipsRegion *region;
822 	int x, y, b;
823 	region = vips_region_new( image ); 
824 	rect.left = 0;
825 	rect.top = 0;
826 	rect.width = image-&gt;Xsize;
827 	rect.height = image-&gt;Ysize;
828 	if( vips_region_prepare( region, &amp;rect ) ) {
829 		g_object_unref( region );
830 		return( FALSE ); 
831 	}
832 	for( y = 0; y &lt; image-&gt;Ysize; y++ ) {
833 		VipsPel * restrict p = VIPS_REGION_ADDR( region, 0, y ); 
834 		for( x = 0; x &lt; image-&gt;Xsize; x++ ) {
835 			for( b = 0; b &lt; bytes; b++ ) 
836 				if( VIPS_ABS( p[b] - ink[b] ) &gt; threshold ) {
837 					g_object_unref( region );
838 					return( FALSE ); 
839 				}
840 			p += bytes;
841 		}
842 	}
843 	g_object_unref( region );
844 	return( TRUE );
845 }
846 static int
847 strip_work( VipsThreadState *state, void *a )
848 {
849 	Strip *strip = (Strip *) a;
850 	Layer *layer = strip-&gt;layer;
851 	VipsForeignSaveDz *dz = layer-&gt;dz;
852 	VipsForeignSave *save = (VipsForeignSave *) dz;
853 	VipsImage *x;
854 	VipsImage *t;
855 	GsfOutput *out; 
856 #ifdef DEBUG_VERBOSE
857 	printf( "strip_work\n" );
858 	if( dz-&gt;centre ) {
859 		VipsRect tile; 
860 		tile.left = state-&gt;x;
861 		tile.top = state-&gt;y;
862 		tile.width = dz-&gt;tile_size;
863 		tile.height = dz-&gt;tile_size;
864 		if( !vips_rect_overlapsrect( &amp;tile, &amp;layer-&gt;real_pixels ) ) {
865 #ifdef DEBUG_VERBOSE
866 			printf( "strip_work: skipping tile %d x %d\n", 
867 				state-&gt;x / dz-&gt;tile_size, 
868 				state-&gt;y / dz-&gt;tile_size ); 
869 			return( 0 ); 
870 		}
871 	}
872 	g_assert( vips_object_sanity( VIPS_OBJECT( strip-&gt;image ) ) );
873 	if( vips_extract_area( strip-&gt;image, &amp;x, 
874 		state-&gt;pos.left, 0, 
875 		state-&gt;pos.width, state-&gt;pos.height, NULL ) ) 
876 		return( -1 );
877 	if( dz-&gt;skip_blanks &gt;= 0 &amp;&amp;
878 		tile_equal( x, dz-&gt;skip_blanks, dz-&gt;ink ) ) { 
879 		g_object_unref( x );
880 #ifdef DEBUG_VERBOSE
881 		printf( "strip_work: skipping blank tile %d x %d\n", 
882 			state-&gt;x / dz-&gt;tile_size, 
883 			state-&gt;y / dz-&gt;tile_size ); 
884 		return( 0 ); 
885 	}
886 	if( dz-&gt;layout == VIPS_FOREIGN_DZ_LAYOUT_GOOGLE ) {
887 		if( vips_embed( x, &amp;t, 0, 0, dz-&gt;tile_size, dz-&gt;tile_size,
888 			"background", save-&gt;background,
889 			NULL ) ) {
890 			g_object_unref( x );
891 			return( -1 );
892 		}
893 		g_object_unref( x );
894 		x = t;
895 	}
896 	g_mutex_lock( vips__global_lock );
897 	out = tile_name( layer, 
898 		state-&gt;x / dz-&gt;tile_step, state-&gt;y / dz-&gt;tile_step );
899 	g_mutex_unlock( vips__global_lock );
900 	if( write_image( dz, out, x, dz-&gt;suffix ) ) {
901 		g_object_unref( out );
902 		g_object_unref( x );
903 		return( -1 );
904 	}
905 	g_object_unref( out );
906 	g_object_unref( x );
907 #ifdef DEBUG_VERBOSE
908 	printf( "strip_work: success\n" );
909 	return( 0 );
910 }
911 static int
912 strip_save( Layer *layer )
913 {
914 	Strip strip;
915 #ifdef DEBUG
916 	printf( "strip_save: n = %d, y = %d\n", layer-&gt;n, layer-&gt;y );
917 	strip_init( &amp;strip, layer );
918 	if( vips_threadpool_run( strip.image, 
919 		vips_thread_state_new, strip_allocate, strip_work, NULL, 
920 		&amp;strip ) ) {
921 		strip_free( &amp;strip );
922 		return( -1 );
923 	}
924 	strip_free( &amp;strip );
925 #ifdef DEBUG
926 	printf( "strip_save: success\n" ); 
927 	return( 0 );
928 }
929 static void
930 layer_generate_extras( Layer *layer )
931 {
932 	VipsRegion *strip = layer-&gt;strip;
933 	g_assert( strip-&gt;valid.width == layer-&gt;image-&gt;Xsize );
934 	if( layer-&gt;width &lt; layer-&gt;image-&gt;Xsize ) {
935 		int ps = VIPS_IMAGE_SIZEOF_PEL( strip-&gt;im );
936 		int b, y;
937 		for( y = 0; y &lt; strip-&gt;valid.height; y++ ) {
938 			VipsPel *p = VIPS_REGION_ADDR( strip, 
939 				layer-&gt;width - 1, strip-&gt;valid.top + y );
940 			VipsPel *q = p + ps;
941 			for( b = 0; b &lt; ps; b++ )
942 				q[b] = p[b];
943 		}
944 	}
945 	if( layer-&gt;height &lt; layer-&gt;image-&gt;Ysize ) {
946 		VipsRect last;
947 		last.left = 0;
948 		last.top = layer-&gt;image-&gt;Ysize - 2;
949 		last.width = layer-&gt;image-&gt;Xsize;
950 		last.height = 2;
951 		vips_rect_intersectrect( &amp;last, &amp;strip-&gt;valid, &amp;last );
952 		if( last.height == 2 ) {
953 			last.height = 1;
954 			vips_region_copy( strip, strip, &amp;last, 
955 				0, last.top + 1 );
956 		}
957 	}
958 }
959 static int strip_arrived( Layer *layer );
960 static int
961 strip_shrink( Layer *layer )
962 {
963 	Layer *below = layer-&gt;below;
964 	VipsRegion *from = layer-&gt;strip;
965 	VipsRegion *to = below-&gt;strip;
966 	VipsForeignSaveDz *dz = layer-&gt;dz;
967 	VipsRegionShrink region_shrink = dz-&gt;region_shrink;
968 	VipsRect target;
969 	VipsRect source;
970 #ifdef DEBUG
971 	printf( "strip_shrink: %d lines in layer %d to layer %d\n", 
972 		from-&gt;valid.height, layer-&gt;n, below-&gt;n ); 
973 	layer_generate_extras( layer );
974 	for(;;) {
975 		target.left = 0;
976 		target.top = below-&gt;write_y;
977 		target.width = below-&gt;image-&gt;Xsize;
978 		target.height = to-&gt;valid.height;
979 		vips_rect_intersectrect( &amp;target, &amp;to-&gt;valid, &amp;target );
980 		source.left = target.left * 2;
981 		source.top = target.top * 2;
982 		source.width = target.width * 2;
983 		source.height = target.height * 2;
984 		vips_rect_intersectrect( &amp;source, &amp;from-&gt;valid, &amp;source );
985 		target.left = source.left / 2;
986 		target.top = source.top / 2;
987 		target.width = source.width / 2;
988 		target.height = source.height / 2;
989 		if( vips_rect_isempty( &amp;target ) )
990 			break;
991 		(void) vips_region_shrink_method( from, to, 
992 			&amp;target, region_shrink );
993 		below-&gt;write_y += target.height;
994 		if( below-&gt;write_y == VIPS_RECT_BOTTOM( &amp;to-&gt;valid ) ||
995 			below-&gt;write_y == below-&gt;height ) {
996 			if( strip_arrived( below ) )
997 				return( -1 );
998 		}
999 	}
1000 	return( 0 );
1001 }
1002 static int
1003 strip_arrived( Layer *layer )
1004 {
1005 	VipsForeignSaveDz *dz = layer-&gt;dz;
1006 	VipsRect new_strip;
1007 	VipsRect overlap;
1008 	VipsRect image_area;
1009 #ifdef DEBUG
1010 	printf( "strip_arrived: layer %d, strip at %d, height %d\n", 
1011 		layer-&gt;n, layer-&gt;y, layer-&gt;strip-&gt;valid.height ); 
1012 	if( strip_save( layer ) )
1013 		return( -1 );
1014 	if( layer-&gt;below &amp;&amp;
1015 		strip_shrink( layer ) )
1016 		return( -1 );
1017 	layer-&gt;y += dz-&gt;tile_step;
1018 	new_strip.left = 0;
1019 	new_strip.top = layer-&gt;y - dz-&gt;tile_margin;
1020 	new_strip.width = layer-&gt;image-&gt;Xsize;
1021 	new_strip.height = dz-&gt;tile_size + 2 * dz-&gt;tile_margin;
1022 	image_area.left = 0;
1023 	image_area.top = 0;
1024 	image_area.width = layer-&gt;image-&gt;Xsize;
1025 	image_area.height = layer-&gt;image-&gt;Ysize;
1026 	vips_rect_intersectrect( &amp;new_strip, &amp;image_area, &amp;new_strip ); 
1027 	if( (new_strip.height &amp; 1) == 1 )
1028 		new_strip.height += 1;
1029 	if( VIPS_RECT_BOTTOM( &amp;new_strip ) == layer-&gt;height )
1030 		new_strip.height = layer-&gt;image-&gt;Ysize - new_strip.top;
1031 	vips_rect_intersectrect( &amp;new_strip, &amp;layer-&gt;strip-&gt;valid, &amp;overlap );
1032 	if( !vips_rect_isempty( &amp;overlap ) ) {
1033 		if( vips_region_buffer( layer-&gt;copy, &amp;overlap ) )
1034 			return( -1 );
1035 		vips_region_copy( layer-&gt;strip, layer-&gt;copy, 
1036 			&amp;overlap, overlap.left, overlap.top );
1037 	}
1038 	if( !vips_rect_isempty( &amp;new_strip ) ) {
1039 		if( vips_region_buffer( layer-&gt;strip, &amp;new_strip ) )
1040 			return( -1 );
1041 		if( !vips_rect_isempty( &amp;overlap ) ) 
1042 			vips_region_copy( layer-&gt;copy, layer-&gt;strip, 
1043 				&amp;overlap, overlap.left, overlap.top );
1044 	}
1045 	return( 0 );
1046 }
1047 static int
1048 strip_flush( Layer *layer )
1049 {
1050 	if( layer-&gt;y &lt; layer-&gt;height )
1051 		if( strip_save( layer ) )
1052 			return( -1 );
1053 	if( layer-&gt;below )
1054 		if( strip_flush( layer-&gt;below ) )
1055 			return( -1 );
1056 	return( 0 );
1057 }
1058 static int
1059 pyramid_strip( VipsRegion *region, VipsRect *area, void *a )
1060 {
1061 	VipsForeignSaveDz *dz = (VipsForeignSaveDz *) a;
1062 	Layer *layer = dz-&gt;layer;
1063 #ifdef DEBUG
1064 	printf( "pyramid_strip: strip at %d, height %d\n", 
1065 		area-&gt;top, area-&gt;height );
1066 	for(;;) {
1067 		VipsRect *to = &amp;layer-&gt;strip-&gt;valid;
1068 		VipsRect target;
1069 		target.left = 0;
1070 		target.top = layer-&gt;write_y;
1071 		target.width = layer-&gt;image-&gt;Xsize;
1072 		target.height = to-&gt;height;
1073 		vips_rect_intersectrect( &amp;target, to, &amp;target );
1074 		vips_rect_intersectrect( &amp;target, area, &amp;target );
1075 		if( vips_rect_isempty( &amp;target ) ) 
1076 			break;
1077 		vips_region_copy( region, layer-&gt;strip, 
1078 			&amp;target, target.left, target.top );
1079 		layer-&gt;write_y += target.height;
1080 		if( layer-&gt;write_y == VIPS_RECT_BOTTOM( to ) ||
1081 			layer-&gt;write_y == layer-&gt;height ) {
1082 			if( strip_arrived( layer ) ) 
1083 				return( -1 );
1084 		}
1085 	}
1086 	if( layer-&gt;write_y == layer-&gt;height ) {
1087 #ifdef DEBUG
1088 		printf( "pyramid_strip: flushing ..\n" ); 
1089 		if( strip_flush( layer ) )
1090 			return( -1 );
1091 	}
1092 	return( 0 );
1093 }
1094 static int
1095 vips_foreign_save_dz_build( VipsObject *object )
1096 {
1097 	VipsForeignSave *save = (VipsForeignSave *) object;
1098 	VipsForeignSaveDz *dz = (VipsForeignSaveDz *) object;
1099 	VipsObjectClass *class = VIPS_OBJECT_GET_CLASS( dz ); 
1100 	VipsRect real_pixels; 
1101 	if( dz-&gt;layout == VIPS_FOREIGN_DZ_LAYOUT_ZOOMIFY ||
1102 		dz-&gt;layout == VIPS_FOREIGN_DZ_LAYOUT_GOOGLE ||
1103 		dz-&gt;layout == VIPS_FOREIGN_DZ_LAYOUT_IIIF ) {
1104 		if( !vips_object_argument_isset( object, "overlap" ) )
1105 			dz-&gt;overlap = 0;
1106 		if( !vips_object_argument_isset( object, "suffix" ) )
1107 			VIPS_SETSTR( dz-&gt;suffix, ".jpg" );
1108 	}
1109 	if( dz-&gt;layout == VIPS_FOREIGN_DZ_LAYOUT_ZOOMIFY ||
1110 		dz-&gt;layout == VIPS_FOREIGN_DZ_LAYOUT_GOOGLE ) {
1111 		if( !vips_object_argument_isset( object, "tile_size" ) )
1112 			dz-&gt;tile_size = 256;
1113 	}
1114 	if( dz-&gt;layout == VIPS_FOREIGN_DZ_LAYOUT_IIIF ) {
1115 		if( !vips_object_argument_isset( object, "tile_size" ) )
1116 			dz-&gt;tile_size = 512;
1117 	}
1118 	if( dz-&gt;layout == VIPS_FOREIGN_DZ_LAYOUT_GOOGLE &amp;&amp;
1119 		!vips_object_argument_isset( object, "skip_blanks" ) )
1120 		dz-&gt;skip_blanks = 5;
1121 	if( dz-&gt;layout == VIPS_FOREIGN_DZ_LAYOUT_DZ ) { 
1122 		dz-&gt;tile_margin = dz-&gt;overlap;
1123 		dz-&gt;tile_step = dz-&gt;tile_size; 
1124 	}
1125 	else {
1126 		dz-&gt;tile_margin = 0;
1127 		dz-&gt;tile_step = dz-&gt;tile_size - dz-&gt;overlap;
1128 	}
1129 	if( dz-&gt;tile_step &lt;= 0 ) {
1130 		vips_error( "dzsave", "%s", _( "overlap too large" ) );
1131 		return( -1 );
1132 	}
1133 	if( !vips_object_argument_isset( object, "background" ) ) {
1134 		VipsArrayDouble *background; 
1135 		background = vips_array_double_newv( 1, 255.0 );
1136 		g_object_set( object, "background", background, NULL );
1137 		vips_area_unref( VIPS_AREA( background ) ); 
1138 	}
1139 	if( dz-&gt;layout == VIPS_FOREIGN_DZ_LAYOUT_DZ ) {
1140 		if( !vips_object_argument_isset( object, "depth" ) )
1141 			dz-&gt;depth = VIPS_FOREIGN_DZ_DEPTH_ONEPIXEL;
1142 	}
1143 	else
1144 		if( !vips_object_argument_isset( object, "depth" ) )
1145 			dz-&gt;depth = VIPS_FOREIGN_DZ_DEPTH_ONETILE;
1146 	if( VIPS_OBJECT_CLASS( vips_foreign_save_dz_parent_class )-&gt;
1147 		build( object ) )
1148 		return( -1 );
1149 {
1150 	VipsImage *z;
1151 	if( vips_rot( save-&gt;ready, &amp;z, dz-&gt;angle, NULL ) )
1152 		return( -1 );
1153 	VIPS_UNREF( save-&gt;ready );
1154 	save-&gt;ready = z;
1155 }
1156 	if( dz-&gt;skip_blanks &gt;= 0 ) {
1157 		if( !(dz-&gt;ink = vips__vector_to_ink( 
1158 			class-&gt;nickname, save-&gt;ready,
1159 			VIPS_AREA( save-&gt;background )-&gt;data, NULL, 
1160 			VIPS_AREA( save-&gt;background )-&gt;n )) )
1161 			return( -1 );
1162 	}
1163 	real_pixels.left = 0;
1164 	real_pixels.top = 0;
1165 	real_pixels.width = save-&gt;ready-&gt;Xsize;
1166 	real_pixels.height = save-&gt;ready-&gt;Ysize;
1167 	if( dz-&gt;layout == VIPS_FOREIGN_DZ_LAYOUT_GOOGLE &amp;&amp;
1168 		dz-&gt;centre ) {
1169 		VipsImage *z;
1170 		Layer *layer;
1171 		int n_layers;
1172 		int size;
1173 		if( !(layer = pyramid_build( dz, NULL, 
1174 			save-&gt;ready-&gt;Xsize, save-&gt;ready-&gt;Ysize,
1175 			&amp;real_pixels )) )
1176 			return( -1 );
1177 		n_layers = layer-&gt;n;
1178 		g_assert( n_layers &lt; 30 );
1179 		layer_free( layer );
1180 		size = dz-&gt;tile_size * (1 &lt;&lt; n_layers);
1181 		real_pixels.left = (size - save-&gt;ready-&gt;Xsize) / 2;
1182 		real_pixels.top = (size - save-&gt;ready-&gt;Ysize) / 2;
1183 		if( vips_embed( save-&gt;ready, &amp;z, 
1184 			real_pixels.left, real_pixels.top,
1185 			size, size,
1186 			"background", save-&gt;background,
1187 			NULL ) ) 
1188 			return( -1 );
1189 		VIPS_UNREF( save-&gt;ready );
1190 		save-&gt;ready = z;
1191 #ifdef DEBUG
1192 		printf( "centre: centring within a %d x %d image\n", 
1193 			size, size );
1194 	}
1195 #ifdef DEBUG
1196 	printf( "vips_foreign_save_dz_build: tile_size == %d\n", 
1197 		dz-&gt;tile_size );
1198 	printf( "vips_foreign_save_dz_build: overlap == %d\n", 
1199 		dz-&gt;overlap );
1200 	printf( "vips_foreign_save_dz_build: tile_margin == %d\n", 
1201 		dz-&gt;tile_margin );
1202 	printf( "vips_foreign_save_dz_build: tile_step == %d\n", 
1203 		dz-&gt;tile_step );
1204 	if( !(dz-&gt;layer = pyramid_build( dz, NULL, 
1205 		save-&gt;ready-&gt;Xsize, save-&gt;ready-&gt;Ysize, &amp;real_pixels )) )
1206 		return( -1 );
1207 	if( dz-&gt;layout == VIPS_FOREIGN_DZ_LAYOUT_DZ )
1208 		dz-&gt;root_name = g_strdup_printf( "%s_files", dz-&gt;basename );
1209 	else
1210 		dz-&gt;root_name = g_strdup( dz-&gt;basename );
1211 {
1212 	char filename[VIPS_PATH_MAX];
1213 	char option_string[VIPS_PATH_MAX];
1214 	vips__filename_split8( dz-&gt;suffix, filename, option_string );
1215 	dz-&gt;file_suffix = g_strdup( filename ); 
1216 }
1217 	if( dz-&gt;layout == VIPS_FOREIGN_DZ_LAYOUT_DZ &amp;&amp;
1218 		dz-&gt;container == VIPS_FOREIGN_DZ_CONTAINER_FS &amp;&amp;
1219 		dz-&gt;dirname &amp;&amp;
1220 		vips_existsf( "%s/%s_files", dz-&gt;dirname, dz-&gt;basename ) ) {
1221 		vips_error( "dzsave", 
1222 			_( "output directory %s/%s_files exists" ),
1223 			dz-&gt;dirname, dz-&gt;basename );
1224 		return( -1 ); 
1225 	}
1226 	switch( dz-&gt;container ) {
1227 	case VIPS_FOREIGN_DZ_CONTAINER_FS:
1228 		if( dz-&gt;layout == VIPS_FOREIGN_DZ_LAYOUT_DZ ) {
1229 			char name[VIPS_PATH_MAX];
1230 			int fd;
1231 			GsfOutput *out;
1232 			GError *error = NULL;
1233 			vips_snprintf( name, VIPS_PATH_MAX, "%s-XXXXXX", 
1234 				dz-&gt;basename ); 
1235 			dz-&gt;tempdir = g_build_filename( dz-&gt;dirname, 
1236 				name, NULL );
1237 			if( (fd = g_mkstemp( dz-&gt;tempdir )) == -1 ) {
1238 				vips_error(  class-&gt;nickname,
1239 					_( "unable to make temporary file %s" ),
1240 					dz-&gt;tempdir );
1241 				return( -1 );
1242 			}
1243 			close( fd );
1244 			g_unlink( dz-&gt;tempdir );
1245 			if( !(out = (GsfOutput *) 
1246 				gsf_outfile_stdio_new( dz-&gt;tempdir, 
1247 					&amp;error )) ) {
1248 				vips_g_error( &amp;error );
1249 				return( -1 );
1250 			}
1251 			dz-&gt;tree = vips_gsf_tree_new( out, 0 );
1252 		}
1253 		else { 
1254 			GsfOutput *out;
1255 			GError *error = NULL;
1256 			char name[VIPS_PATH_MAX];
1257 			vips_snprintf( name, VIPS_PATH_MAX, "%s/%s", 
1258 				dz-&gt;dirname, dz-&gt;basename ); 
1259 			if( !(out = (GsfOutput *) 
1260 				gsf_outfile_stdio_new( name, &amp;error )) ) {
1261 				vips_g_error( &amp;error );
1262 				return( -1 );
1263 			}
1264 			dz-&gt;tree = vips_gsf_tree_new( out, 0 );
1265 		}
1266 		break;
1267 	case VIPS_FOREIGN_DZ_CONTAINER_ZIP:
1268 	case VIPS_FOREIGN_DZ_CONTAINER_SZI:
1269 {
1270 		GsfOutput *zip;
1271 		GsfOutput *out2;
1272 		GError *error = NULL;
1273 		char name[VIPS_PATH_MAX];
1274 		if( dz-&gt;dirname ) { 
1275 			const char *suffix =
1276 				dz-&gt;container == VIPS_FOREIGN_DZ_CONTAINER_SZI ?
1277 					"szi" : "zip";
1278 			vips_snprintf( name, VIPS_PATH_MAX, "%s/%s.%s",
1279 				dz-&gt;dirname, dz-&gt;basename, suffix );
1280 			if( !(dz-&gt;out =
1281 				gsf_output_stdio_new( name, &amp;error )) ) {
1282 				vips_g_error( &amp;error );
1283 				return( -1 );
1284 			}
1285 		}
1286 		else
1287 			dz-&gt;out = gsf_output_memory_new();
1288 		if( !(zip = (GsfOutput *) 
1289 			gsf_outfile_zip_new( dz-&gt;out, &amp;error )) ) {
1290 			vips_g_error( &amp;error );
1291 			return( -1 );
1292 		}
1293 		out2 = gsf_outfile_new_child_full( (GsfOutfile *) zip, 
1294 			dz-&gt;basename, TRUE,
1295 			"compression-level", GSF_ZIP_STORED, 
1296 			NULL );
1297 #ifndef HAVE_GSF_DEFLATE_LEVEL
1298 		if( dz-&gt;compression &gt; 0 ) {
1299 			g_warning( "%s", 
1300 				_( "deflate-level not supported by libgsf, "
1301 				"using default compression" ) ); 
1302 			dz-&gt;compression = -1;
1303 		}
1304 		dz-&gt;tree = vips_gsf_tree_new( out2, dz-&gt;compression );
1305 		dz-&gt;tree-&gt;container = zip; 
1306 }
1307 		break;
1308 	default:
1309 		g_assert_not_reached();
1310 	}
1311 	if( vips_sink_disc( save-&gt;ready, pyramid_strip, dz ) )
1312 		return( -1 );
1313 	switch( dz-&gt;layout ) {
1314 	case VIPS_FOREIGN_DZ_LAYOUT_DZ:
1315 		if( write_dzi( dz ) )
1316 			return( -1 );
1317 		break;
1318 	case VIPS_FOREIGN_DZ_LAYOUT_ZOOMIFY:
1319 		if( write_properties( dz ) )
1320 			return( -1 );
1321 		break;
1322 	case VIPS_FOREIGN_DZ_LAYOUT_GOOGLE:
1323 		if( write_blank( dz ) )
1324 			return( -1 );
1325 		break;
1326 	case VIPS_FOREIGN_DZ_LAYOUT_IIIF:
1327 		if( write_json( dz ) )
1328 			return( -1 );
1329 		break;
1330 	default:
1331 		g_assert_not_reached();
1332 	}
1333 	if( dz-&gt;properties &amp;&amp;
1334 		write_vips_meta( dz ) )
1335 		return( -1 );
1336 	if( dz-&gt;container == VIPS_FOREIGN_DZ_CONTAINER_SZI &amp;&amp;
1337 		write_scan_properties( dz ) )
1338 		return( -1 );
1339 	if( dz-&gt;container == VIPS_FOREIGN_DZ_CONTAINER_SZI &amp;&amp;
1340 		write_associated( dz ) )
1341 		return( -1 );
1342 	if( dz-&gt;layout == VIPS_FOREIGN_DZ_LAYOUT_DZ &amp;&amp;
1343 		dz-&gt;container == VIPS_FOREIGN_DZ_CONTAINER_FS ) { 
1344 		char old_name[VIPS_PATH_MAX];
1345 		char new_name[VIPS_PATH_MAX];
1346 		vips_snprintf( old_name, VIPS_PATH_MAX, "%s/%s.dzi", 
1347 			dz-&gt;tempdir, dz-&gt;basename );
1348 		vips_snprintf( new_name, VIPS_PATH_MAX, "%s/%s.dzi", 
1349 			dz-&gt;dirname, dz-&gt;basename );
1350 		if( vips_rename( old_name, new_name ) )
1351 			return( -1 ); 
1352 		vips_snprintf( old_name, VIPS_PATH_MAX, "%s/%s_files", 
1353 			dz-&gt;tempdir, dz-&gt;basename );
1354 		vips_snprintf( new_name, VIPS_PATH_MAX, "%s/%s_files", 
1355 			dz-&gt;dirname, dz-&gt;basename );
1356 		if( vips_rename( old_name, new_name ) )
1357 			return( -1 ); 
1358 		if( vips_rmdirf( "%s", dz-&gt;tempdir ) )
1359 			return( -1 ); 
1360 	}
1361 	if( vips_gsf_tree_close( dz-&gt;tree ) )
1362 		return( -1 ); 
1363 	dz-&gt;tree = NULL; 
1364 	if( iszip( dz-&gt;container ) &amp;&amp;
1365 		dz-&gt;dirname != NULL ) 
1366 		VIPS_FREEF( g_object_unref, dz-&gt;out );
1367 	return( 0 );
1368 }
1369 #define UC VIPS_FORMAT_UCHAR
1370 #define C VIPS_FORMAT_CHAR
1371 #define US VIPS_FORMAT_USHORT
1372 #define S VIPS_FORMAT_SHORT
1373 #define UI VIPS_FORMAT_UINT
1374 #define I VIPS_FORMAT_INT
1375 #define F VIPS_FORMAT_FLOAT
1376 #define X VIPS_FORMAT_COMPLEX
1377 #define D VIPS_FORMAT_DOUBLE
1378 #define DX VIPS_FORMAT_DPCOMPLEX
1379 static int bandfmt_dz[10] = {
1380 <a name="2"></a>   UC, C,  US, S,  UI, I,  F,  F,  D,  D
1381 };
1382 <font color="#980517"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>static const char *dz_suffs[] = { ".dz", NULL };
1383 static void
1384 vips_foreign_save_dz_class_init( VipsForeignSaveDzClass *class )
1385 {
1386 	GObjectClass *gobject_class = G_OBJECT_CLASS( class );
1387 	VipsObjectClass *object_class = (VipsObjectClass *) class;
1388 	VipsForeignClass *foreign_class = (VipsForeignClass *) class;
1389 	VipsForeignSaveClass *save_class = (VipsForeignSaveClass *) class;</b></font>
1390 	gobject_class-&gt;dispose = vips_foreign_save_dz_dispose;
1391 	gobject_class-&gt;set_property = vips_object_set_property;
1392 	gobject_class-&gt;get_property = vips_object_get_property;
1393 	object_class-&gt;nickname = "dzsave_base";
1394 	object_class-&gt;description = _( "save image to deep zoom format" );
1395 	object_class-&gt;build = vips_foreign_save_dz_build;
1396 	foreign_class-&gt;suffs = dz_suffs;
1397 	save_class-&gt;saveable = VIPS_SAVEABLE_ANY;
1398 	save_class-&gt;format_table = bandfmt_dz;
1399 	save_class-&gt;coding[VIPS_CODING_LABQ] = TRUE;
1400 	VIPS_ARG_STRING( class, "basename", 2, 
1401 		_( "Base name" ),
1402 		_( "Base name to save to" ),
1403 		VIPS_ARGUMENT_OPTIONAL_INPUT,
1404 		G_STRUCT_OFFSET( VipsForeignSaveDz, basename ),
1405 		NULL );
1406 	VIPS_ARG_ENUM( class, "layout", 8, 
1407 		_( "Layout" ), 
1408 		_( "Directory layout" ),
1409 		VIPS_ARGUMENT_OPTIONAL_INPUT,
1410 		G_STRUCT_OFFSET( VipsForeignSaveDz, layout ),
1411 		VIPS_TYPE_FOREIGN_DZ_LAYOUT, VIPS_FOREIGN_DZ_LAYOUT_DZ ); 
1412 	VIPS_ARG_STRING( class, "suffix", 9, 
1413 		_( "suffix" ), 
1414 		_( "Filename suffix for tiles" ),
1415 		VIPS_ARGUMENT_OPTIONAL_INPUT,
1416 		G_STRUCT_OFFSET( VipsForeignSaveDz, suffix ),
1417 		".jpeg" );
1418 	VIPS_ARG_INT( class, "overlap", 10, 
1419 		_( "Overlap" ), 
1420 		_( "Tile overlap in pixels" ),
1421 		VIPS_ARGUMENT_OPTIONAL_INPUT,
1422 		G_STRUCT_OFFSET( VipsForeignSaveDz, overlap ),
1423 		0, 8192, 1 );
1424 	VIPS_ARG_INT( class, "tile_size", 11, 
1425 		_( "Tile size" ), 
1426 		_( "Tile size in pixels" ),
1427 		VIPS_ARGUMENT_OPTIONAL_INPUT,
1428 		G_STRUCT_OFFSET( VipsForeignSaveDz, tile_size ),
1429 		1, 8192, 254 );
1430 	VIPS_ARG_ENUM( class, "depth", 13, 
1431 		_( "Depth" ), 
1432 		_( "Pyramid depth" ),
1433 		VIPS_ARGUMENT_OPTIONAL_INPUT,
1434 		G_STRUCT_OFFSET( VipsForeignSaveDz, depth ),
1435 		VIPS_TYPE_FOREIGN_DZ_DEPTH, VIPS_FOREIGN_DZ_DEPTH_ONEPIXEL ); 
1436 	VIPS_ARG_BOOL( class, "centre", 13, 
1437 		_( "Center" ), 
1438 		_( "Center image in tile" ),
1439 		VIPS_ARGUMENT_OPTIONAL_INPUT,
1440 		G_STRUCT_OFFSET( VipsForeignSaveDz, centre ),
1441 		FALSE );
1442 	VIPS_ARG_ENUM( class, "angle", 14, 
1443 		_( "Angle" ), 
1444 		_( "Rotate image during save" ),
1445 		VIPS_ARGUMENT_OPTIONAL_INPUT,
1446 		G_STRUCT_OFFSET( VipsForeignSaveDz, angle ),
1447 		VIPS_TYPE_ANGLE, VIPS_ANGLE_D0 ); 
1448 	VIPS_ARG_ENUM( class, "container", 15, 
1449 		_( "Container" ), 
1450 		_( "Pyramid container type" ),
1451 		VIPS_ARGUMENT_OPTIONAL_INPUT,
1452 		G_STRUCT_OFFSET( VipsForeignSaveDz, container ),
1453 		VIPS_TYPE_FOREIGN_DZ_CONTAINER, VIPS_FOREIGN_DZ_CONTAINER_FS ); 
1454 	VIPS_ARG_BOOL( class, "properties", 16, 
1455 		_( "Properties" ), 
1456 		_( "Write a properties file to the output directory" ),
1457 		VIPS_ARGUMENT_OPTIONAL_INPUT,
1458 		G_STRUCT_OFFSET( VipsForeignSaveDz, properties ),
1459 		FALSE );
1460 	VIPS_ARG_INT( class, "compression", 17, 
1461 		_( "Compression" ), 
1462 		_( "ZIP deflate compression level" ),
1463 		VIPS_ARGUMENT_OPTIONAL_INPUT,
1464 		G_STRUCT_OFFSET( VipsForeignSaveDz, compression ),
1465 		-1, 9, 0 );
1466 	VIPS_ARG_ENUM( class, "region_shrink", 18, 
1467 		_( "Region shrink" ), 
1468 		_( "Method to shrink regions" ),
1469 		VIPS_ARGUMENT_OPTIONAL_INPUT,
1470 		G_STRUCT_OFFSET( VipsForeignSaveDz, region_shrink ),
1471 		VIPS_TYPE_REGION_SHRINK, VIPS_REGION_SHRINK_MEAN ); 
1472 	VIPS_ARG_INT( class, "skip_blanks", 19, 
1473 		_( "Skip blanks" ), 
1474 		_( "Skip tiles which are nearly equal to the background" ),
1475 		VIPS_ARGUMENT_OPTIONAL_INPUT,
1476 		G_STRUCT_OFFSET( VipsForeignSaveDz, skip_blanks ),
1477 		-1, 65535, -1 );
1478 	VIPS_ARG_BOOL( class, "no_strip", 20, 
1479 		_( "No strip" ), 
1480 		_( "Don't strip tile metadata" ),
1481 		VIPS_ARGUMENT_OPTIONAL_INPUT,
1482 		G_STRUCT_OFFSET( VipsForeignSaveDz, no_strip ),
1483 		FALSE );
1484 	VIPS_ARG_STRING( class, "id", 21, 
1485 		_( "id" ), 
1486 		_( "Resource ID" ),
1487 		VIPS_ARGUMENT_OPTIONAL_INPUT,
1488 		G_STRUCT_OFFSET( VipsForeignSaveDz, id ),
1489 		"https://example.com/iiif" );
1490 	VIPS_ARG_STRING( class, "dirname", 1, 
1491 		_( "Directory name" ),
1492 		_( "Directory name to save to" ),
1493 		VIPS_ARGUMENT_OPTIONAL_INPUT | VIPS_ARGUMENT_DEPRECATED,
1494 		G_STRUCT_OFFSET( VipsForeignSaveDz, dirname ),
1495 		NULL );
1496 	VIPS_ARG_INT( class, "tile_width", 12, 
1497 		_( "Tile width" ), 
1498 		_( "Tile width in pixels" ),
1499 		VIPS_ARGUMENT_OPTIONAL_INPUT | VIPS_ARGUMENT_DEPRECATED,
1500 		G_STRUCT_OFFSET( VipsForeignSaveDz, tile_size ),
1501 		1, 8192, 254 );
1502 	VIPS_ARG_INT( class, "tile_height", 12, 
1503 		_( "Tile height" ), 
1504 		_( "Tile height in pixels" ),
1505 		VIPS_ARGUMENT_OPTIONAL_INPUT | VIPS_ARGUMENT_DEPRECATED,
1506 		G_STRUCT_OFFSET( VipsForeignSaveDz, tile_size ),
1507 		1, 8192, 254 );
1508 }
1509 static void
1510 vips_foreign_save_dz_init( VipsForeignSaveDz *dz )
1511 {
1512 	VIPS_SETSTR( dz-&gt;suffix, ".jpeg" );
1513 	dz-&gt;layout = VIPS_FOREIGN_DZ_LAYOUT_DZ; 
1514 	dz-&gt;overlap = 1;
1515 	dz-&gt;tile_size = 254;
1516 	dz-&gt;tile_count = 0;
1517 	dz-&gt;depth = VIPS_FOREIGN_DZ_DEPTH_ONEPIXEL; 
1518 	dz-&gt;angle = VIPS_ANGLE_D0; 
1519 	dz-&gt;container = VIPS_FOREIGN_DZ_CONTAINER_FS; 
1520 	dz-&gt;compression = 0;
1521 	dz-&gt;region_shrink = VIPS_REGION_SHRINK_MEAN;
1522 	dz-&gt;skip_blanks = -1;
1523 }
1524 typedef struct _VipsForeignSaveDzFile {
1525 	VipsForeignSaveDz parent_object;
1526 	char *filename; 
1527 } VipsForeignSaveDzFile;
1528 typedef VipsForeignSaveDzClass VipsForeignSaveDzFileClass;
1529 G_DEFINE_TYPE( VipsForeignSaveDzFile, vips_foreign_save_dz_file, 
1530 	vips_foreign_save_dz_get_type() );
1531 static int
1532 vips_foreign_save_dz_file_build( VipsObject *object )
1533 {
1534 	VipsForeignSaveDz *dz = (VipsForeignSaveDz *) object;
1535 	VipsForeignSaveDzFile *file = (VipsForeignSaveDzFile *) object;
1536 	char *p;
1537 	if( !vips_object_argument_isset( object, "basename" ) ) 
1538 		dz-&gt;basename = g_path_get_basename( file-&gt;filename ); 
1539 	if( !vips_object_argument_isset( object, "dirname" ) ) 
1540 		dz-&gt;dirname = g_path_get_dirname( file-&gt;filename ); 
1541 	if( (p = (char *) vips__find_rightmost_brackets( dz-&gt;basename )) )
1542 		*p = '\0';
1543 	if( (p = strrchr( dz-&gt;basename, '.' )) ) {
1544 		if( !vips_object_argument_isset( object, "container" ) ) {
1545 			if( strcasecmp( p + 1, "zip" ) == 0 )
1546 				dz-&gt;container = VIPS_FOREIGN_DZ_CONTAINER_ZIP;
1547 			if( strcasecmp( p + 1, "szi" ) == 0 ) 
1548 				dz-&gt;container = VIPS_FOREIGN_DZ_CONTAINER_SZI;
1549 		}
1550 		if( g_ascii_strcasecmp( p + 1, "zip" ) == 0 ||
1551 			g_ascii_strcasecmp( p + 1, "szi" ) == 0 || 
1552 			g_ascii_strcasecmp( p + 1, "dz" ) == 0 )
1553 			*p = '\0';
1554 	}
1555 	if( VIPS_OBJECT_CLASS( vips_foreign_save_dz_file_parent_class )-&gt;
1556 		build( object ) )
1557 <a name="1"></a>		return( -1 );
1558 	return( 0 );
1559 <font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>}
1560 static void
1561 vips_foreign_save_dz_file_class_init( VipsForeignSaveDzFileClass *class )
1562 {
1563 	GObjectClass *gobject_class = G_OBJECT_CLASS( class );
1564 	VipsObjectClass *object_class = (VipsObjectClass *) class;
1565 	gobject_class-&gt;set_property = vips_object_set_property;
1566 	gobject_class-&gt;get_property = vips_object_get_property;
1567 	object_class-&gt;nickname = "dzsave";
1568 	object_class-&gt;description = _( "save image to deepzoom file" );</b></font>
1569 	object_class-&gt;build = vips_foreign_save_dz_file_build;
1570 	VIPS_ARG_STRING( class, "filename", 1, 
1571 		_( "Filename" ),
1572 		_( "Filename to save to" ),
1573 		VIPS_ARGUMENT_REQUIRED_INPUT, 
1574 		G_STRUCT_OFFSET( VipsForeignSaveDzFile, filename ),
1575 		NULL );
1576 }
1577 static void
1578 vips_foreign_save_dz_file_init( VipsForeignSaveDzFile *file )
1579 {
1580 }
1581 typedef struct _VipsForeignSaveDzBuffer {
1582 	VipsForeignSaveDz parent_object;
1583 	VipsArea *buf;
1584 } VipsForeignSaveDzBuffer;
1585 typedef VipsForeignSaveDzClass VipsForeignSaveDzBufferClass;
1586 G_DEFINE_TYPE( VipsForeignSaveDzBuffer, vips_foreign_save_dz_buffer, 
1587 	vips_foreign_save_dz_get_type() );
1588 static int
1589 vips_foreign_save_dz_buffer_build( VipsObject *object )
1590 {
1591 	VipsForeignSaveDz *dz = (VipsForeignSaveDz *) object;
1592 	void *obuf;
1593 	size_t olen;
1594 	VipsBlob *blob;
1595 	if( !vips_object_argument_isset( object, "basename" ) ) 
1596 		dz-&gt;basename = g_strdup( "untitled" ); 
1597 	if( VIPS_OBJECT_CLASS( vips_foreign_save_dz_buffer_parent_class )-&gt;
1598 		build( object ) )
1599 		return( -1 );
1600 	g_assert( GSF_IS_OUTPUT_MEMORY( dz-&gt;out ) );
1601 	olen = gsf_output_size( GSF_OUTPUT( dz-&gt;out ) ); 
1602 	if( !(obuf = g_try_malloc( olen )) ) {
1603 		vips_error( "vips_tracked", 
1604 			_( "out of memory --- size == %dMB" ), 
1605 			(int) (olen / (1024.0 * 1024.0))  );
1606 		return( -1 );
1607 	}
1608 	memcpy( obuf, 
1609 		gsf_output_memory_get_bytes( GSF_OUTPUT_MEMORY( dz-&gt;out ) ),
1610 		olen ); 
1611 	blob = vips_blob_new( (VipsCallbackFn) vips_area_free_cb, obuf, olen );
1612 	g_object_set( object, "buffer", blob, NULL );
1613 	vips_area_unref( VIPS_AREA( blob ) );
1614 	return( 0 );
1615 }
1616 <a name="0"></a>static void
1617 vips_foreign_save_dz_buffer_class_init( VipsForeignSaveDzBufferClass *class )
1618 {
1619 <font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>	GObjectClass *gobject_class = G_OBJECT_CLASS( class );
1620 	VipsObjectClass *object_class = (VipsObjectClass *) class;
1621 	gobject_class-&gt;set_property = vips_object_set_property;
1622 	gobject_class-&gt;get_property = vips_object_get_property;
1623 	object_class-&gt;nickname = "dzsave_buffer";
1624 	object_class-&gt;description = _( "save image to dz buffer" );
1625 	object_class-&gt;build = vips_foreign_save_dz_buffer_build;
1626 	VIPS_ARG_BOXED( class, "buffer", 1, 
1627 		_( "Buffer" ),
1628 		_( "Buffer to save to" ),
1629 		VIPS_ARGUMENT_REQUIRED_OUTPUT, 
1630 		G_STRUCT_OFFSET( VipsForeignSaveDzBuffer, buf ),
1631 		VIPS_TYPE_BLOB );
1632 }
1633 static void
1634 vips_foreign_save_dz_buffer_init( VipsForeignSaveDzBuffer *buffer )
1635 {</b></font>
1636 	VipsForeignSaveDz *dz = (VipsForeignSaveDz *) buffer;
1637 	dz-&gt;container = VIPS_FOREIGN_DZ_CONTAINER_ZIP;
1638 }
1639 int
1640 vips_dzsave( VipsImage *in, const char *name, ... )
1641 {
1642 	va_list ap;
1643 	int result;
1644 	va_start( ap, name );
1645 	result = vips_call_split( "dzsave", ap, in, name ); 
1646 	va_end( ap );
1647 	return( result );
1648 }
1649 int
1650 vips_dzsave_buffer( VipsImage *in, void **buf, size_t *len, ... )
1651 {
1652 	va_list ap;
1653 	VipsArea *area;
1654 	int result;
1655 	area = NULL; 
1656 	va_start( ap, len );
1657 	result = vips_call_split( "dzsave_buffer", ap, in, &amp;area );
1658 	va_end( ap );
1659 	if( !result &amp;&amp;
1660 		area ) { 
1661 		if( buf ) {
1662 			*buf = area-&gt;data;
1663 			area-&gt;free_fn = NULL;
1664 		}
1665 		if( len ) 
1666 			*len = area-&gt;length;
1667 		vips_area_unref( area );
1668 	}
1669 	return( result );
1670 }
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
