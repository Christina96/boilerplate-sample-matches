
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 16, <button onclick='openModal()' class='match'>CODE CLONE</button></h2>
        <div class="column">
            <h3>libpcap-MDEwOlJlcG9zaXRvcnk5NDM1ODg3-flat-pcap-tc.c</h3>
            <pre><code>1  #ifdef HAVE_CONFIG_H
2  #include &lt;config.h&gt;
3  #endif
4  #include &lt;pcap.h&gt;
5  #include &lt;pcap-int.h&gt;
6  #include &quot;pcap-tc.h&quot;
7  #include &lt;malloc.h&gt;
8  #include &lt;memory.h&gt;
9  #include &lt;string.h&gt;
10  #include &lt;errno.h&gt;
11  #ifdef _WIN32
12  #include &lt;tchar.h&gt;
13  #endif
14  typedef TC_STATUS	(TC_CALLCONV *TcFcnQueryPortList)			(PTC_PORT *ppPorts, PULONG pLength);
15  typedef TC_STATUS	(TC_CALLCONV *TcFcnFreePortList)			(TC_PORT *pPorts);
16  typedef PCHAR		(TC_CALLCONV *TcFcnStatusGetString)			(TC_STATUS status);
17  typedef PCHAR		(TC_CALLCONV *TcFcnPortGetName)				(TC_PORT port);
18  typedef PCHAR		(TC_CALLCONV *TcFcnPortGetDescription)		(TC_PORT port);
19  typedef TC_STATUS	(TC_CALLCONV *TcFcnInstanceOpenByName)		(PCHAR name, PTC_INSTANCE pInstance);
20  typedef TC_STATUS	(TC_CALLCONV *TcFcnInstanceClose)			(TC_INSTANCE instance);
21  typedef TC_STATUS	(TC_CALLCONV *TcFcnInstanceSetFeature)		(TC_INSTANCE instance, ULONG feature, ULONG value);
22  typedef TC_STATUS	(TC_CALLCONV *TcFcnInstanceQueryFeature)	(TC_INSTANCE instance, ULONG feature, PULONG pValue);
23  typedef TC_STATUS	(TC_CALLCONV *TcFcnInstanceReceivePackets)	(TC_INSTANCE instance, PTC_PACKETS_BUFFER pBuffer);
24  typedef HANDLE		(TC_CALLCONV *TcFcnInstanceGetReceiveWaitHandle) (TC_INSTANCE instance);
25  typedef TC_STATUS	(TC_CALLCONV *TcFcnInstanceTransmitPackets)	(TC_INSTANCE instance, TC_PACKETS_BUFFER pBuffer);
26  typedef TC_STATUS	(TC_CALLCONV *TcFcnInstanceQueryStatistics)	(TC_INSTANCE instance, PTC_STATISTICS pStatistics);
27  typedef TC_STATUS	(TC_CALLCONV *TcFcnPacketsBufferCreate)		(ULONG size, PTC_PACKETS_BUFFER pBuffer);
28  typedef VOID		(TC_CALLCONV *TcFcnPacketsBufferDestroy)	(TC_PACKETS_BUFFER buffer);
29  typedef TC_STATUS	(TC_CALLCONV *TcFcnPacketsBufferQueryNextPacket)(TC_PACKETS_BUFFER buffer, PTC_PACKET_HEADER pHeader, PVOID *ppData);
30  typedef TC_STATUS	(TC_CALLCONV *TcFcnPacketsBufferCommitNextPacket)(TC_PACKETS_BUFFER buffer, PTC_PACKET_HEADER pHeader, PVOID pData);
31  typedef VOID		(TC_CALLCONV *TcFcnStatisticsDestroy)		(TC_STATISTICS statistics);
32  typedef TC_STATUS	(TC_CALLCONV *TcFcnStatisticsUpdate)		(TC_STATISTICS statistics);
33  typedef TC_STATUS	(TC_CALLCONV *TcFcnStatisticsQueryValue)	(TC_STATISTICS statistics, ULONG counterId, PULONGLONG pValue);
34  typedef enum LONG
35  {
36  	TC_API_UNLOADED = 0,
37  	TC_API_LOADED,
38  	TC_API_CANNOT_LOAD,
39  	TC_API_LOADING
40  }
41  	TC_API_LOAD_STATUS;
42  typedef struct _TC_FUNCTIONS
43  {
44  	TC_API_LOAD_STATUS			LoadStatus;
45  #ifdef _WIN32
46  	HMODULE						hTcApiDllHandle;
47  #endif
48  	TcFcnQueryPortList			QueryPortList;
49  	TcFcnFreePortList			FreePortList;
50  	TcFcnStatusGetString		StatusGetString;
51  	TcFcnPortGetName			PortGetName;
52  	TcFcnPortGetDescription		PortGetDescription;
53  	TcFcnInstanceOpenByName		InstanceOpenByName;
54  	TcFcnInstanceClose			InstanceClose;
55  	TcFcnInstanceSetFeature		InstanceSetFeature;
56  	TcFcnInstanceQueryFeature	InstanceQueryFeature;
57  	TcFcnInstanceReceivePackets	InstanceReceivePackets;
58  #ifdef _WIN32
59  	TcFcnInstanceGetReceiveWaitHandle InstanceGetReceiveWaitHandle;
60  #endif
61  	TcFcnInstanceTransmitPackets InstanceTransmitPackets;
62  	TcFcnInstanceQueryStatistics InstanceQueryStatistics;
63  	TcFcnPacketsBufferCreate	PacketsBufferCreate;
64  	TcFcnPacketsBufferDestroy	PacketsBufferDestroy;
65  	TcFcnPacketsBufferQueryNextPacket	PacketsBufferQueryNextPacket;
66  	TcFcnPacketsBufferCommitNextPacket  PacketsBufferCommitNextPacket;
67  	TcFcnStatisticsDestroy		StatisticsDestroy;
68  	TcFcnStatisticsUpdate		StatisticsUpdate;
69  	TcFcnStatisticsQueryValue	StatisticsQueryValue;
70  }
71  	TC_FUNCTIONS;
72  static pcap_if_t* TcCreatePcapIfFromPort(TC_PORT port);
73  static int TcSetDatalink(pcap_t *p, int dlt);
74  static int TcGetNonBlock(pcap_t *p);
75  static int TcSetNonBlock(pcap_t *p, int nonblock);
76  static void TcCleanup(pcap_t *p);
77  static int TcInject(pcap_t *p, const void *buf, int size);
78  static int TcRead(pcap_t *p, int cnt, pcap_handler callback, u_char *user);
79  static int TcStats(pcap_t *p, struct pcap_stat *ps);
80  #ifdef _WIN32
81  static struct pcap_stat *TcStatsEx(pcap_t *p, int *pcap_stat_size);
82  static int TcSetBuff(pcap_t *p, int dim);
83  static int TcSetMode(pcap_t *p, int mode);
84  static int TcSetMinToCopy(pcap_t *p, int size);
85  static HANDLE TcGetReceiveWaitHandle(pcap_t *p);
86  static int TcOidGetRequest(pcap_t *p, bpf_u_int32 oid, void *data, size_t *lenp);
87  static int TcOidSetRequest(pcap_t *p, bpf_u_int32 oid, const void *data, size_t *lenp);
88  static u_int TcSendqueueTransmit(pcap_t *p, pcap_send_queue *queue, int sync);
89  static int TcSetUserBuffer(pcap_t *p, int size);
90  static int TcLiveDump(pcap_t *p, char *filename, int maxsize, int maxpacks);
91  static int TcLiveDumpEnded(pcap_t *p, int sync);
92  static PAirpcapHandle TcGetAirPcapHandle(pcap_t *p);
93  #endif
94  #ifdef _WIN32
95  TC_FUNCTIONS g_TcFunctions =
96  {
97  	TC_API_UNLOADED, &amp;bsol;* LoadStatus */
98  	NULL,  &amp;bsol;* hTcApiDllHandle */
99  	NULL,  &amp;bsol;* QueryPortList */
100  	NULL,  &amp;bsol;* FreePortList */
101  	NULL,  &amp;bsol;* StatusGetString */
102  	NULL,  &amp;bsol;* PortGetName */
103  	NULL,  &amp;bsol;* PortGetDescription */
104  	NULL,  &amp;bsol;* InstanceOpenByName */
105  	NULL,  &amp;bsol;* InstanceClose */
106  	NULL,  &amp;bsol;* InstanceSetFeature */
107  	NULL,  &amp;bsol;* InstanceQueryFeature */
108  	NULL,  &amp;bsol;* InstanceReceivePackets */
109  	NULL,  &amp;bsol;* InstanceGetReceiveWaitHandle */
110  	NULL,  &amp;bsol;* InstanceTransmitPackets */
111  	NULL,  &amp;bsol;* InstanceQueryStatistics */
112  	NULL,  &amp;bsol;* PacketsBufferCreate */
113  	NULL,  &amp;bsol;* PacketsBufferDestroy */
114  	NULL,  &amp;bsol;* PacketsBufferQueryNextPacket */
115  	NULL,  &amp;bsol;* PacketsBufferCommitNextPacket */
116  	NULL,  &amp;bsol;* StatisticsDestroy */
117  	NULL,  &amp;bsol;* StatisticsUpdate */
118  	NULL  &amp;bsol;* StatisticsQueryValue */
119  };
120  #else
121  TC_FUNCTIONS g_TcFunctions =
122  {
123  	TC_API_LOADED, &amp;bsol;* LoadStatus */
124  	TcQueryPortList,
125  	TcFreePortList,
126  	TcStatusGetString,
127  	TcPortGetName,
128  	TcPortGetDescription,
129  	TcInstanceOpenByName,
130  	TcInstanceClose,
131  	TcInstanceSetFeature,
132  	TcInstanceQueryFeature,
133  	TcInstanceReceivePackets,
134  #ifdef _WIN32
135  	TcInstanceGetReceiveWaitHandle,
136  #endif
137  	TcInstanceTransmitPackets,
138  	TcInstanceQueryStatistics,
139  	TcPacketsBufferCreate,
140  	TcPacketsBufferDestroy,
141  	TcPacketsBufferQueryNextPacket,
142  	TcPacketsBufferCommitNextPacket,
143  	TcStatisticsDestroy,
144  	TcStatisticsUpdate,
145  	TcStatisticsQueryValue,
146  };
147  #endif
148  #define MAX_TC_PACKET_SIZE	9500
149  #pragma pack(push, 1)
150  #define PPH_PH_FLAG_PADDING	((UCHAR)0x01)
151  #define PPH_PH_VERSION		((UCHAR)0x00)
152  typedef struct _PPI_PACKET_HEADER
153  {
154  	UCHAR	PphVersion;
155  	UCHAR	PphFlags;
156  	USHORT	PphLength;
157  	ULONG	PphDlt;
158  }
159  	PPI_PACKET_HEADER, *PPPI_PACKET_HEADER;
160  typedef struct _PPI_FIELD_HEADER
161  {
162  	USHORT PfhType;
163  	USHORT PfhLength;
164  }
165  	PPI_FIELD_HEADER, *PPPI_FIELD_HEADER;
166  #define		PPI_FIELD_TYPE_AGGREGATION_EXTENSION	((UCHAR)0x08)
167  typedef struct _PPI_FIELD_AGGREGATION_EXTENSION
168  {
169  	ULONG		InterfaceId;
170  }
171  	PPI_FIELD_AGGREGATION_EXTENSION, *PPPI_FIELD_AGGREGATION_EXTENSION;
172  #define		PPI_FIELD_TYPE_802_3_EXTENSION			((UCHAR)0x09)
173  #define PPI_FLD_802_3_EXT_FLAG_FCS_PRESENT			((ULONG)0x00000001)
174  typedef struct _PPI_FIELD_802_3_EXTENSION
175  {
176  	ULONG		Flags;
177  	ULONG		Errors;
178  }
179  	PPI_FIELD_802_3_EXTENSION, *PPPI_FIELD_802_3_EXTENSION;
180  typedef struct _PPI_HEADER
181  {
182  	PPI_PACKET_HEADER PacketHeader;
183  	PPI_FIELD_HEADER  AggregationFieldHeader;
184  	PPI_FIELD_AGGREGATION_EXTENSION AggregationField;
185  	PPI_FIELD_HEADER  Dot3FieldHeader;
186  	PPI_FIELD_802_3_EXTENSION Dot3Field;
187  }
188  	PPI_HEADER, *PPPI_HEADER;
189  #pragma pack(pop)
190  #ifdef _WIN32
191  TC_API_LOAD_STATUS LoadTcFunctions(void)
192  {
193  	TC_API_LOAD_STATUS currentStatus;
194  	do
195  	{
196  		currentStatus = InterlockedCompareExchange((LONG*)&amp;g_TcFunctions.LoadStatus, TC_API_LOADING, TC_API_UNLOADED);
197  		while(currentStatus == TC_API_LOADING)
198  		{
199  			currentStatus = InterlockedCompareExchange((LONG*)&amp;g_TcFunctions.LoadStatus, TC_API_LOADING, TC_API_LOADING);
200  			Sleep(10);
201  		}
202  		if(currentStatus  == TC_API_LOADED)
203  		{
204  			return TC_API_LOADED;
205  		}
206  		if (currentStatus == TC_API_CANNOT_LOAD)
207  		{
208  			return TC_API_CANNOT_LOAD;
209  		}
210  		currentStatus = TC_API_CANNOT_LOAD;
211  		g_TcFunctions.hTcApiDllHandle = pcap_load_code(&quot;TcApi.dll&quot;);
212  		if (g_TcFunctions.hTcApiDllHandle == NULL)	break;
213  		g_TcFunctions.QueryPortList			= (TcFcnQueryPortList)			pcap_find_function(g_TcFunctions.hTcApiDllHandle, &quot;TcQueryPortList&quot;);
214  		g_TcFunctions.FreePortList			= (TcFcnFreePortList)			pcap_find_function(g_TcFunctions.hTcApiDllHandle, &quot;TcFreePortList&quot;);
215  		g_TcFunctions.StatusGetString			= (TcFcnStatusGetString)		pcap_find_function(g_TcFunctions.hTcApiDllHandle, &quot;TcStatusGetString&quot;);
216  		g_TcFunctions.PortGetName			= (TcFcnPortGetName)			pcap_find_function(g_TcFunctions.hTcApiDllHandle, &quot;TcPortGetName&quot;);
217  		g_TcFunctions.PortGetDescription		= (TcFcnPortGetDescription)		pcap_find_function(g_TcFunctions.hTcApiDllHandle, &quot;TcPortGetDescription&quot;);
218  		g_TcFunctions.InstanceOpenByName		= (TcFcnInstanceOpenByName)		pcap_find_function(g_TcFunctions.hTcApiDllHandle, &quot;TcInstanceOpenByName&quot;);
219  		g_TcFunctions.InstanceClose			= (TcFcnInstanceClose)			pcap_find_function(g_TcFunctions.hTcApiDllHandle, &quot;TcInstanceClose&quot;);
220  		g_TcFunctions.InstanceSetFeature		= (TcFcnInstanceSetFeature)		pcap_find_function(g_TcFunctions.hTcApiDllHandle, &quot;TcInstanceSetFeature&quot;);
221  		g_TcFunctions.InstanceQueryFeature		= (TcFcnInstanceQueryFeature)	pcap_find_function(g_TcFunctions.hTcApiDllHandle, &quot;TcInstanceQueryFeature&quot;);
222  		g_TcFunctions.InstanceReceivePackets		= (TcFcnInstanceReceivePackets)	pcap_find_function(g_TcFunctions.hTcApiDllHandle, &quot;TcInstanceReceivePackets&quot;);
223  		g_TcFunctions.InstanceGetReceiveWaitHandle	= (TcFcnInstanceGetReceiveWaitHandle)pcap_find_function(g_TcFunctions.hTcApiDllHandle, &quot;TcInstanceGetReceiveWaitHandle&quot;);
224  		g_TcFunctions.InstanceTransmitPackets		= (TcFcnInstanceTransmitPackets)pcap_find_function(g_TcFunctions.hTcApiDllHandle, &quot;TcInstanceTransmitPackets&quot;);
225  		g_TcFunctions.InstanceQueryStatistics		= (TcFcnInstanceQueryStatistics)pcap_find_function(g_TcFunctions.hTcApiDllHandle, &quot;TcInstanceQueryStatistics&quot;);
226  		g_TcFunctions.PacketsBufferCreate		= (TcFcnPacketsBufferCreate)	pcap_find_function(g_TcFunctions.hTcApiDllHandle, &quot;TcPacketsBufferCreate&quot;);
227  		g_TcFunctions.PacketsBufferDestroy		= (TcFcnPacketsBufferDestroy)	pcap_find_function(g_TcFunctions.hTcApiDllHandle, &quot;TcPacketsBufferDestroy&quot;);
228  		g_TcFunctions.PacketsBufferQueryNextPacket	= (TcFcnPacketsBufferQueryNextPacket)pcap_find_function(g_TcFunctions.hTcApiDllHandle, &quot;TcPacketsBufferQueryNextPacket&quot;);
229  		g_TcFunctions.PacketsBufferCommitNextPacket	= (TcFcnPacketsBufferCommitNextPacket)pcap_find_function(g_TcFunctions.hTcApiDllHandle, &quot;TcPacketsBufferCommitNextPacket&quot;);
230  		g_TcFunctions.StatisticsDestroy			= (TcFcnStatisticsDestroy)		pcap_find_function(g_TcFunctions.hTcApiDllHandle, &quot;TcStatisticsDestroy&quot;);
231  		g_TcFunctions.StatisticsUpdate			= (TcFcnStatisticsUpdate)		pcap_find_function(g_TcFunctions.hTcApiDllHandle, &quot;TcStatisticsUpdate&quot;);
232  		g_TcFunctions.StatisticsQueryValue		= (TcFcnStatisticsQueryValue)	pcap_find_function(g_TcFunctions.hTcApiDllHandle, &quot;TcStatisticsQueryValue&quot;);
233  		if (   g_TcFunctions.QueryPortList == NULL
234  			|| g_TcFunctions.FreePortList == NULL
235  			|| g_TcFunctions.StatusGetString == NULL
236  			|| g_TcFunctions.PortGetName == NULL
237  			|| g_TcFunctions.PortGetDescription == NULL
238  			|| g_TcFunctions.InstanceOpenByName == NULL
239  			|| g_TcFunctions.InstanceClose == NULL
240  			|| g_TcFunctions.InstanceSetFeature	 == NULL
241  			|| g_TcFunctions.InstanceQueryFeature == NULL
242  			|| g_TcFunctions.InstanceReceivePackets == NULL
243  			|| g_TcFunctions.InstanceGetReceiveWaitHandle == NULL
244  			|| g_TcFunctions.InstanceTransmitPackets == NULL
245  			|| g_TcFunctions.InstanceQueryStatistics == NULL
246  			|| g_TcFunctions.PacketsBufferCreate == NULL
247  			|| g_TcFunctions.PacketsBufferDestroy == NULL
248  			|| g_TcFunctions.PacketsBufferQueryNextPacket == NULL
249  			|| g_TcFunctions.PacketsBufferCommitNextPacket == NULL
250  			|| g_TcFunctions.StatisticsDestroy == NULL
251  			|| g_TcFunctions.StatisticsUpdate == NULL
252  			|| g_TcFunctions.StatisticsQueryValue == NULL
253  		)
254  		{
255  			break;
256  		}
257  		currentStatus = TC_API_LOADED;
258  	}while(FALSE);
259  	if (currentStatus != TC_API_LOADED)
260  	{
261  		if (g_TcFunctions.hTcApiDllHandle != NULL)
262  		{
263  			FreeLibrary(g_TcFunctions.hTcApiDllHandle);
264  			g_TcFunctions.hTcApiDllHandle = NULL;
265  		}
266  	}
267  	InterlockedExchange((LONG*)&amp;g_TcFunctions.LoadStatus, currentStatus);
268  	return currentStatus;
269  }
270  #else
271  TC_API_LOAD_STATUS LoadTcFunctions(void)
272  {
273  	return TC_API_LOADED;
274  }
275  #endif
276  struct pcap_tc {
277  	TC_INSTANCE TcInstance;
278  	TC_PACKETS_BUFFER TcPacketsBuffer;
279  	ULONG TcAcceptedCount;
280  	u_char *PpiPacket;
281  };
282  int
283  TcFindAllDevs(pcap_if_list_t *devlist, char *errbuf)
284  {
285  	TC_API_LOAD_STATUS loadStatus;
286  	ULONG numPorts;
287  	PTC_PORT pPorts = NULL;
288  	TC_STATUS status;
289  	int result = 0;
290  	pcap_if_t *dev;
291  	ULONG i;
292  	do
293  	{
294  		loadStatus = LoadTcFunctions();
295  		if (loadStatus != TC_API_LOADED)
296  		{
297  			result = 0;
298  			break;
299  		}
300  		status = g_TcFunctions.QueryPortList(&amp;pPorts, &amp;numPorts);
301  		if (status != TC_SUCCESS)
302  		{
303  			result = 0;
304  			break;
305  		}
306  		for (i = 0; i &lt; numPorts; i++)
307  		{
308  			dev = TcCreatePcapIfFromPort(pPorts[i]);
309  			if (dev != NULL)
310  				pcap_add_dev(devlist, dev-&gt;name, dev-&gt;flags, dev-&gt;description, errbuf);
311  		}
312  		if (numPorts &gt; 0)
313  		{
314  			status = g_TcFunctions.FreePortList(pPorts);
315  		}
316  	}while(FALSE);
317  	return result;
318  }
319  static pcap_if_t* TcCreatePcapIfFromPort(TC_PORT port)
320  {
321  	CHAR *name;
322  	CHAR *description;
323  	pcap_if_t *newIf = NULL;
324  	newIf = (pcap_if_t*)malloc(sizeof(*newIf));
325  	if (newIf == NULL)
326  	{
327  		return NULL;
328  	}
329  	memset(newIf, 0, sizeof(*newIf));
330  	name = g_TcFunctions.PortGetName(port);
331  	description = g_TcFunctions.PortGetDescription(port);
332  	newIf-&gt;name = (char*)malloc(strlen(name) + 1);
333  	if (newIf-&gt;name == NULL)
334  	{
335  		free(newIf);
336  		return NULL;
337  	}
338  	newIf-&gt;description = (char*)malloc(strlen(description) + 1);
<span onclick='openModal()' class='match'>339  	if (newIf-&gt;description == NULL)
340  	{
341  		free(newIf-&gt;name);
342  		free(newIf);
</span>343  		return NULL;
344  	}
345  	strcpy(newIf-&gt;name, name);
346  	strcpy(newIf-&gt;description, description);
347  	newIf-&gt;addresses = NULL;
348  	newIf-&gt;next = NULL;
349  	newIf-&gt;flags = 0;
350  	return newIf;
351  }
352  static int
353  TcActivate(pcap_t *p)
354  {
355  	struct pcap_tc *pt = p-&gt;priv;
356  	TC_STATUS status;
357  	ULONG timeout;
358  	PPPI_HEADER pPpiHeader;
359  	if (p-&gt;opt.rfmon)
360  	{
361  		return PCAP_ERROR_RFMON_NOTSUP;
362  	}
363  	pt-&gt;PpiPacket = malloc(sizeof(PPI_HEADER) + MAX_TC_PACKET_SIZE);
364  	if (pt-&gt;PpiPacket == NULL)
365  	{
366  		snprintf(p-&gt;errbuf, PCAP_ERRBUF_SIZE, &quot;Error allocating memory&quot;);
367  		return PCAP_ERROR;
368  	}
369  	if (p-&gt;snapshot &lt;= 0 || p-&gt;snapshot &gt; MAXIMUM_SNAPLEN)
370  		p-&gt;snapshot = MAXIMUM_SNAPLEN;
371  	pPpiHeader = (PPPI_HEADER)pt-&gt;PpiPacket;
372  	pPpiHeader-&gt;PacketHeader.PphDlt = DLT_EN10MB;
373  	pPpiHeader-&gt;PacketHeader.PphLength = sizeof(PPI_HEADER);
374  	pPpiHeader-&gt;PacketHeader.PphFlags = 0;
375  	pPpiHeader-&gt;PacketHeader.PphVersion = 0;
376  	pPpiHeader-&gt;AggregationFieldHeader.PfhLength = sizeof(PPI_FIELD_AGGREGATION_EXTENSION);
377  	pPpiHeader-&gt;AggregationFieldHeader.PfhType = PPI_FIELD_TYPE_AGGREGATION_EXTENSION;
378  	pPpiHeader-&gt;Dot3FieldHeader.PfhLength = sizeof(PPI_FIELD_802_3_EXTENSION);
379  	pPpiHeader-&gt;Dot3FieldHeader.PfhType = PPI_FIELD_TYPE_802_3_EXTENSION;
380  	status = g_TcFunctions.InstanceOpenByName(p-&gt;opt.device, &amp;pt-&gt;TcInstance);
381  	if (status != TC_SUCCESS)
382  	{
383  		snprintf(p-&gt;errbuf, PCAP_ERRBUF_SIZE, &quot;Error opening TurboCap adapter: %s&quot;, g_TcFunctions.StatusGetString(status));
384  		return PCAP_ERROR;
385  	}
386  	p-&gt;linktype = DLT_EN10MB;
387  	p-&gt;dlt_list = (u_int *) malloc(sizeof(u_int) * 2);
388  	if (p-&gt;dlt_list == NULL)
389  	{
390  		snprintf(p-&gt;errbuf, PCAP_ERRBUF_SIZE, &quot;Error allocating memory&quot;);
391  		return PCAP_ERROR;
392  	}
393  	p-&gt;dlt_list[0] = DLT_EN10MB;
394  	p-&gt;dlt_list[1] = DLT_PPI;
395  	p-&gt;dlt_count = 2;
396  	status = g_TcFunctions.InstanceSetFeature(pt-&gt;TcInstance, TC_INST_FT_RX_STATUS, 1);
397  	if (status != TC_SUCCESS)
398  	{
399  		snprintf(p-&gt;errbuf, PCAP_ERRBUF_SIZE,&quot;Error enabling reception on a TurboCap instance: %s&quot;, g_TcFunctions.StatusGetString(status));
400  		goto bad;
401  	}
402  	status = g_TcFunctions.InstanceSetFeature(pt-&gt;TcInstance, TC_INST_FT_TX_STATUS, 1);
403  	p-&gt;inject_op = TcInject;
404  	if (p-&gt;opt.timeout == 0)
405  	{
406  		timeout = 0xFFFFFFFF;
407  	}
408  	else
409  	if (p-&gt;opt.timeout &lt; 0)
410  	{
411  		timeout = 10;
412  	}
413  	else
414  	{
415  		timeout = p-&gt;opt.timeout;
416  	}
417  	status = g_TcFunctions.InstanceSetFeature(pt-&gt;TcInstance, TC_INST_FT_READ_TIMEOUT, timeout);
418  	if (status != TC_SUCCESS)
419  	{
420  		snprintf(p-&gt;errbuf, PCAP_ERRBUF_SIZE,&quot;Error setting the read timeout a TurboCap instance: %s&quot;, g_TcFunctions.StatusGetString(status));
421  		goto bad;
422  	}
423  	p-&gt;read_op = TcRead;
424  	p-&gt;setfilter_op = pcap_install_bpf_program;
425  	p-&gt;setdirection_op = NULL;	&amp;bsol;* Not implemented. */
426  	p-&gt;set_datalink_op = TcSetDatalink;
427  	p-&gt;getnonblock_op = TcGetNonBlock;
428  	p-&gt;setnonblock_op = TcSetNonBlock;
429  	p-&gt;stats_op = TcStats;
430  #ifdef _WIN32
431  	p-&gt;stats_ex_op = TcStatsEx;
432  	p-&gt;setbuff_op = TcSetBuff;
433  	p-&gt;setmode_op = TcSetMode;
434  	p-&gt;setmintocopy_op = TcSetMinToCopy;
435  	p-&gt;getevent_op = TcGetReceiveWaitHandle;
436  	p-&gt;oid_get_request_op = TcOidGetRequest;
437  	p-&gt;oid_set_request_op = TcOidSetRequest;
438  	p-&gt;sendqueue_transmit_op = TcSendqueueTransmit;
439  	p-&gt;setuserbuffer_op = TcSetUserBuffer;
440  	p-&gt;live_dump_op = TcLiveDump;
441  	p-&gt;live_dump_ended_op = TcLiveDumpEnded;
442  	p-&gt;get_airpcap_handle_op = TcGetAirPcapHandle;
443  #else
444  	p-&gt;selectable_fd = -1;
445  #endif
446  	p-&gt;cleanup_op = TcCleanup;
447  	return 0;
448  bad:
449  	TcCleanup(p);
450  	return PCAP_ERROR;
451  }
452  pcap_t *
453  TcCreate(const char *device, char *ebuf, int *is_ours)
454  {
455  	ULONG numPorts;
456  	PTC_PORT pPorts = NULL;
457  	TC_STATUS status;
458  	int is_tc;
459  	ULONG i;
460  	pcap_t *p;
461  	if (LoadTcFunctions() != TC_API_LOADED)
462  	{
463  		*is_ours = 0;
464  		return NULL;
465  	}
466  	status = g_TcFunctions.QueryPortList(&amp;pPorts, &amp;numPorts);
467  	if (status != TC_SUCCESS)
468  	{
469  		*is_ours = 0;
470  		return NULL;
471  	}
472  	is_tc = FALSE;
473  	for (i = 0; i &lt; numPorts; i++)
474  	{
475  		if (strcmp(g_TcFunctions.PortGetName(pPorts[i]), device) == 0)
476  		{
477  			is_tc = TRUE;
478  			break;
479  		}
480  	}
481  	if (numPorts &gt; 0)
482  	{
483  		(void)g_TcFunctions.FreePortList(pPorts);
484  	}
485  	if (!is_tc)
486  	{
487  		*is_ours = 0;
488  		return NULL;
489  	}
490  	*is_ours = 1;
491  	p = PCAP_CREATE_COMMON(ebuf, struct pcap_tc);
492  	if (p == NULL)
493  		return NULL;
494  	p-&gt;activate_op = TcActivate;
495  	p-&gt;getnonblock_op = TcGetNonBlock;
496  	p-&gt;setnonblock_op = TcSetNonBlock;
497  	return p;
498  }
499  static int TcSetDatalink(pcap_t *p, int dlt)
500  {
501  	return 0;
502  }
503  static int TcGetNonBlock(pcap_t *p)
504  {
505  	snprintf(p-&gt;errbuf, PCAP_ERRBUF_SIZE,
506  	    &quot;Non-blocking mode isn&#x27;t supported for TurboCap ports&quot;);
507  	return -1;
508  }
509  static int TcSetNonBlock(pcap_t *p, int nonblock)
510  {
511  	snprintf(p-&gt;errbuf, PCAP_ERRBUF_SIZE,
512  	    &quot;Non-blocking mode isn&#x27;t supported for TurboCap ports&quot;);
513  	return -1;
514  }
515  static void TcCleanup(pcap_t *p)
516  {
517  	struct pcap_tc *pt = p-&gt;priv;
518  	if (pt-&gt;TcPacketsBuffer != NULL)
519  	{
520  		g_TcFunctions.PacketsBufferDestroy(pt-&gt;TcPacketsBuffer);
521  		pt-&gt;TcPacketsBuffer = NULL;
522  	}
523  	if (pt-&gt;TcInstance != NULL)
524  	{
525  		g_TcFunctions.InstanceClose(pt-&gt;TcInstance);
526  		pt-&gt;TcInstance = NULL;
527  	}
528  	if (pt-&gt;PpiPacket != NULL)
529  	{
530  		free(pt-&gt;PpiPacket);
531  		pt-&gt;PpiPacket = NULL;
532  	}
533  	pcap_cleanup_live_common(p);
534  }
535  static int TcInject(pcap_t *p, const void *buf, int size)
536  {
537  	struct pcap_tc *pt = p-&gt;priv;
538  	TC_STATUS status;
539  	TC_PACKETS_BUFFER buffer;
540  	TC_PACKET_HEADER header;
541  	if (size &gt;= 0xFFFF)
542  	{
543  		snprintf(p-&gt;errbuf, PCAP_ERRBUF_SIZE, &quot;send error: the TurboCap API does not support packets larger than 64k&quot;);
544  		return -1;
545  	}
546  	status = g_TcFunctions.PacketsBufferCreate(sizeof(TC_PACKET_HEADER) + TC_ALIGN_USHORT_TO_64BIT((USHORT)size), &amp;buffer);
547  	if (status != TC_SUCCESS)
548  	{
549  		snprintf(p-&gt;errbuf, PCAP_ERRBUF_SIZE, &quot;send error: TcPacketsBufferCreate failure: %s (%08x)&quot;, g_TcFunctions.StatusGetString(status), status);
550  		return -1;
551  	}
552  	memset(&amp;header, 0, sizeof(header));
553  	header.Length = (USHORT)size;
554  	header.CapturedLength = header.Length;
555  	status = g_TcFunctions.PacketsBufferCommitNextPacket(buffer, &amp;header, (PVOID)buf);
556  	if (status == TC_SUCCESS)
557  	{
558  		status = g_TcFunctions.InstanceTransmitPackets(pt-&gt;TcInstance, buffer);
559  		if (status != TC_SUCCESS)
560  		{
561  			snprintf(p-&gt;errbuf, PCAP_ERRBUF_SIZE, &quot;send error: TcInstanceTransmitPackets failure: %s (%08x)&quot;, g_TcFunctions.StatusGetString(status), status);
562  		}
563  	}
564  	else
565  	{
566  		snprintf(p-&gt;errbuf, PCAP_ERRBUF_SIZE, &quot;send error: TcPacketsBufferCommitNextPacket failure: %s (%08x)&quot;, g_TcFunctions.StatusGetString(status), status);
567  	}
568  	g_TcFunctions.PacketsBufferDestroy(buffer);
569  	if (status != TC_SUCCESS)
570  	{
571  		return -1;
572  	}
573  	else
574  	{
575  		return 0;
576  	}
577  }
578  static int TcRead(pcap_t *p, int cnt, pcap_handler callback, u_char *user)
579  {
580  	struct pcap_tc *pt = p-&gt;priv;
581  	TC_STATUS status;
582  	int n = 0;
583  	if (p-&gt;break_loop)
584  	{
585  		p-&gt;break_loop = 0;
586  		return -2;
587  	}
588  	if (pt-&gt;TcPacketsBuffer == NULL)
589  	{
590  		status = g_TcFunctions.InstanceReceivePackets(pt-&gt;TcInstance, &amp;pt-&gt;TcPacketsBuffer);
591  		if (status != TC_SUCCESS)
592  		{
593  			snprintf(p-&gt;errbuf, PCAP_ERRBUF_SIZE, &quot;read error, TcInstanceReceivePackets failure: %s (%08x)&quot;, g_TcFunctions.StatusGetString(status), status);
594  			return -1;
595  		}
596  	}
597  	while (TRUE)
598  	{
599  		struct pcap_pkthdr hdr;
600  		TC_PACKET_HEADER tcHeader;
601  		PVOID data;
602  		ULONG filterResult;
603  		if (p-&gt;break_loop)
604  		{
605  			if (n == 0)
606  			{
607  				p-&gt;break_loop = 0;
608  				return -2;
609  			}
610  			else
611  			{
612  				return n;
613  			}
614  		}
615  		if (pt-&gt;TcPacketsBuffer == NULL)
616  		{
617  			break;
618  		}
619  		status = g_TcFunctions.PacketsBufferQueryNextPacket(pt-&gt;TcPacketsBuffer, &amp;tcHeader, &amp;data);
620  		if (status == TC_ERROR_END_OF_BUFFER)
621  		{
622  			g_TcFunctions.PacketsBufferDestroy(pt-&gt;TcPacketsBuffer);
623  			pt-&gt;TcPacketsBuffer = NULL;
624  			break;
625  		}
626  		if (status != TC_SUCCESS)
627  		{
628  			snprintf(p-&gt;errbuf, PCAP_ERRBUF_SIZE, &quot;read error, TcPacketsBufferQueryNextPacket failure: %s (%08x)&quot;, g_TcFunctions.StatusGetString(status), status);
629  			return -1;
630  		}
631  		if (p-&gt;fcode.bf_insns)
632  		{
633  			filterResult = pcap_filter(p-&gt;fcode.bf_insns, data, tcHeader.Length, tcHeader.CapturedLength);
634  			if (filterResult == 0)
635  			{
636  				continue;
637  			}
638  			if (filterResult &gt; tcHeader.CapturedLength)
639  			{
640  				filterResult = tcHeader.CapturedLength;
641  			}
642  		}
643  		else
644  		{
645  			filterResult = tcHeader.CapturedLength;
646  		}
647  		pt-&gt;TcAcceptedCount ++;
648  		hdr.ts.tv_sec = (bpf_u_int32)(tcHeader.Timestamp / (ULONGLONG)(1000  * 1000 * 1000));
649  		hdr.ts.tv_usec = (bpf_u_int32)((tcHeader.Timestamp % (ULONGLONG)(1000  * 1000 * 1000)) / 1000);
650  		if (p-&gt;linktype == DLT_EN10MB)
651  		{
652  			hdr.caplen = filterResult;
653  			hdr.len = tcHeader.Length;
654  			(*callback)(user, &amp;hdr, data);
655  		}
656  		else
657  		{
658  			PPPI_HEADER pPpiHeader = (PPPI_HEADER)pt-&gt;PpiPacket;
659  			PVOID data2 = pPpiHeader + 1;
660  			pPpiHeader-&gt;AggregationField.InterfaceId = TC_PH_FLAGS_RX_PORT_ID(tcHeader.Flags);
661  			pPpiHeader-&gt;Dot3Field.Errors = tcHeader.Errors;
662  			if (tcHeader.Flags &amp; TC_PH_FLAGS_CHECKSUM)
663  			{
664  				pPpiHeader-&gt;Dot3Field.Flags = PPI_FLD_802_3_EXT_FLAG_FCS_PRESENT;
665  			}
666  			else
667  			{
668  				pPpiHeader-&gt;Dot3Field.Flags = 0;
669  			}
670  			if (filterResult &lt;= MAX_TC_PACKET_SIZE)
671  			{
672  				memcpy(data2, data, filterResult);
673  				hdr.caplen = sizeof(PPI_HEADER) + filterResult;
674  				hdr.len = sizeof(PPI_HEADER) + tcHeader.Length;
675  			}
676  			else
677  			{
678  				memcpy(data2, data, MAX_TC_PACKET_SIZE);
679  				hdr.caplen = sizeof(PPI_HEADER) + MAX_TC_PACKET_SIZE;
680  				hdr.len = sizeof(PPI_HEADER) + tcHeader.Length;
681  			}
682  			(*callback)(user, &amp;hdr, pt-&gt;PpiPacket);
683  		}
684  		if (++n &gt;= cnt &amp;&amp; cnt &gt; 0)
685  		{
686  			return n;
687  		}
688  	}
689  	return n;
690  }
691  static int
692  TcStats(pcap_t *p, struct pcap_stat *ps)
693  {
694  	struct pcap_tc *pt = p-&gt;priv;
695  	TC_STATISTICS statistics;
696  	TC_STATUS status;
697  	ULONGLONG counter;
698  	struct pcap_stat s;
699  	status = g_TcFunctions.InstanceQueryStatistics(pt-&gt;TcInstance, &amp;statistics);
700  	if (status != TC_SUCCESS)
701  	{
702  		snprintf(p-&gt;errbuf, PCAP_ERRBUF_SIZE, &quot;TurboCap error in TcInstanceQueryStatistics: %s (%08x)&quot;, g_TcFunctions.StatusGetString(status), status);
703  		return -1;
704  	}
705  	memset(&amp;s, 0, sizeof(s));
706  	status = g_TcFunctions.StatisticsQueryValue(statistics, TC_COUNTER_INSTANCE_TOTAL_RX_PACKETS, &amp;counter);
707  	if (status != TC_SUCCESS)
708  	{
709  		snprintf(p-&gt;errbuf, PCAP_ERRBUF_SIZE, &quot;TurboCap error in TcStatisticsQueryValue: %s (%08x)&quot;, g_TcFunctions.StatusGetString(status), status);
710  		return -1;
711  	}
712  	if (counter &lt;= (ULONGLONG)0xFFFFFFFF)
713  	{
714  		s.ps_recv = (ULONG)counter;
715  	}
716  	else
717  	{
718  		s.ps_recv = 0xFFFFFFFF;
719  	}
720  	status = g_TcFunctions.StatisticsQueryValue(statistics, TC_COUNTER_INSTANCE_RX_DROPPED_PACKETS, &amp;counter);
721  	if (status != TC_SUCCESS)
722  	{
723  		snprintf(p-&gt;errbuf, PCAP_ERRBUF_SIZE, &quot;TurboCap error in TcStatisticsQueryValue: %s (%08x)&quot;, g_TcFunctions.StatusGetString(status), status);
724  		return -1;
725  	}
726  	if (counter &lt;= (ULONGLONG)0xFFFFFFFF)
727  	{
728  		s.ps_ifdrop = (ULONG)counter;
729  		s.ps_drop = (ULONG)counter;
730  	}
731  	else
732  	{
733  		s.ps_ifdrop = 0xFFFFFFFF;
734  		s.ps_drop = 0xFFFFFFFF;
735  	}
736  #if defined(_WIN32) &amp;&amp; defined(ENABLE_REMOTE)
737  	s.ps_capt = pt-&gt;TcAcceptedCount;
738  #endif
739  	*ps = s;
740  	return 0;
741  }
742  #ifdef _WIN32
743  static struct pcap_stat *
744  TcStatsEx(pcap_t *p, int *pcap_stat_size)
745  {
746  	struct pcap_tc *pt = p-&gt;priv;
747  	TC_STATISTICS statistics;
748  	TC_STATUS status;
749  	ULONGLONG counter;
750  	*pcap_stat_size = sizeof (p-&gt;stat);
751  	status = g_TcFunctions.InstanceQueryStatistics(pt-&gt;TcInstance, &amp;statistics);
752  	if (status != TC_SUCCESS)
753  	{
754  		snprintf(p-&gt;errbuf, PCAP_ERRBUF_SIZE, &quot;TurboCap error in TcInstanceQueryStatistics: %s (%08x)&quot;, g_TcFunctions.StatusGetString(status), status);
755  		return NULL;
756  	}
757  	memset(&amp;p-&gt;stat, 0, sizeof(p-&gt;stat));
758  	status = g_TcFunctions.StatisticsQueryValue(statistics, TC_COUNTER_INSTANCE_TOTAL_RX_PACKETS, &amp;counter);
759  	if (status != TC_SUCCESS)
760  	{
761  		snprintf(p-&gt;errbuf, PCAP_ERRBUF_SIZE, &quot;TurboCap error in TcStatisticsQueryValue: %s (%08x)&quot;, g_TcFunctions.StatusGetString(status), status);
762  		return NULL;
763  	}
764  	if (counter &lt;= (ULONGLONG)0xFFFFFFFF)
765  	{
766  		p-&gt;stat.ps_recv = (ULONG)counter;
767  	}
768  	else
769  	{
770  		p-&gt;stat.ps_recv = 0xFFFFFFFF;
771  	}
772  	status = g_TcFunctions.StatisticsQueryValue(statistics, TC_COUNTER_INSTANCE_RX_DROPPED_PACKETS, &amp;counter);
773  	if (status != TC_SUCCESS)
774  	{
775  		snprintf(p-&gt;errbuf, PCAP_ERRBUF_SIZE, &quot;TurboCap error in TcStatisticsQueryValue: %s (%08x)&quot;, g_TcFunctions.StatusGetString(status), status);
776  		return NULL;
777  	}
778  	if (counter &lt;= (ULONGLONG)0xFFFFFFFF)
779  	{
780  		p-&gt;stat.ps_ifdrop = (ULONG)counter;
781  		p-&gt;stat.ps_drop = (ULONG)counter;
782  	}
783  	else
784  	{
785  		p-&gt;stat.ps_ifdrop = 0xFFFFFFFF;
786  		p-&gt;stat.ps_drop = 0xFFFFFFFF;
787  	}
788  #if defined(_WIN32) &amp;&amp; defined(ENABLE_REMOTE)
789  	p-&gt;stat.ps_capt = pt-&gt;TcAcceptedCount;
790  #endif
791  	return &amp;p-&gt;stat;
792  }
793  static int
794  TcSetBuff(pcap_t *p, int dim)
795  {
796  	return 0;
797  }
798  static int
799  TcSetMode(pcap_t *p, int mode)
800  {
801  	if (mode != MODE_CAPT)
802  	{
803  		snprintf(p-&gt;errbuf, PCAP_ERRBUF_SIZE, &quot;Mode %d not supported by TurboCap devices. TurboCap only supports capture.&quot;, mode);
804  		return -1;
805  	}
806  	return 0;
807  }
808  static int
809  TcSetMinToCopy(pcap_t *p, int size)
810  {
811  	struct pcap_tc *pt = p-&gt;priv;
812  	TC_STATUS status;
813  	if (size &lt; 0)
814  	{
815  		snprintf(p-&gt;errbuf, PCAP_ERRBUF_SIZE, &quot;Mintocopy cannot be less than 0.&quot;);
816  		return -1;
817  	}
818  	status = g_TcFunctions.InstanceSetFeature(pt-&gt;TcInstance, TC_INST_FT_MINTOCOPY, (ULONG)size);
819  	if (status != TC_SUCCESS)
820  	{
821  		snprintf(p-&gt;errbuf, PCAP_ERRBUF_SIZE, &quot;TurboCap error setting the mintocopy: %s (%08x)&quot;, g_TcFunctions.StatusGetString(status), status);
822  	}
823  	return 0;
824  }
825  static HANDLE
826  TcGetReceiveWaitHandle(pcap_t *p)
827  {
828  	struct pcap_tc *pt = p-&gt;priv;
829  	return g_TcFunctions.InstanceGetReceiveWaitHandle(pt-&gt;TcInstance);
830  }
831  static int
832  TcOidGetRequest(pcap_t *p, bpf_u_int32 oid _U_, void *data _U_, size_t *lenp _U_)
833  {
834  	snprintf(p-&gt;errbuf, PCAP_ERRBUF_SIZE,
835  	    &quot;An OID get request cannot be performed on a TurboCap device&quot;);
836  	return PCAP_ERROR;
837  }
838  static int
839  TcOidSetRequest(pcap_t *p, bpf_u_int32 oid _U_, const void *data _U_,
840      size_t *lenp _U_)
841  {
842  	snprintf(p-&gt;errbuf, PCAP_ERRBUF_SIZE,
843  	    &quot;An OID set request cannot be performed on a TurboCap device&quot;);
844  	return PCAP_ERROR;
845  }
846  static u_int
847  TcSendqueueTransmit(pcap_t *p, pcap_send_queue *queue _U_, int sync _U_)
848  {
849  	snprintf(p-&gt;errbuf, PCAP_ERRBUF_SIZE,
850  	    &quot;Packets cannot be bulk transmitted on a TurboCap device&quot;);
851  	return 0;
852  }
853  static int
854  TcSetUserBuffer(pcap_t *p, int size _U_)
855  {
856  	snprintf(p-&gt;errbuf, PCAP_ERRBUF_SIZE,
857  	    &quot;The user buffer cannot be set on a TurboCap device&quot;);
858  	return -1;
859  }
860  static int
861  TcLiveDump(pcap_t *p, char *filename _U_, int maxsize _U_, int maxpacks _U_)
862  {
863  	snprintf(p-&gt;errbuf, PCAP_ERRBUF_SIZE,
864  	    &quot;Live packet dumping cannot be performed on a TurboCap device&quot;);
865  	return -1;
866  }
867  static int
868  TcLiveDumpEnded(pcap_t *p, int sync _U_)
869  {
870  	snprintf(p-&gt;errbuf, PCAP_ERRBUF_SIZE,
871  	    &quot;Live packet dumping cannot be performed on a TurboCap device&quot;);
872  	return -1;
873  }
874  static PAirpcapHandle
875  TcGetAirPcapHandle(pcap_t *p _U_)
876  {
877  	return NULL;
878  }
879  #endif
</code></pre>
        </div>
        <div class="column">
            <h3>Adafruit_nRF52_Arduino-MDEwOlJlcG9zaXRvcnk3NDM1NDcyOQ==-flat-tasks.c</h3>
            <pre><code>1  #include &lt;stdlib.h&gt;
2  #include &lt;string.h&gt;
3  #define MPU_WRAPPERS_INCLUDED_FROM_API_FILE
4  #include &quot;FreeRTOS.h&quot;
5  #include &quot;task.h&quot;
6  #include &quot;timers.h&quot;
7  #include &quot;stack_macros.h&quot;
8  #undef MPU_WRAPPERS_INCLUDED_FROM_API_FILE &amp;bsol;*lint !e961 !e750. */
9  #if ( configUSE_STATS_FORMATTING_FUNCTIONS == 1 )
10  	#include &lt;stdio.h&gt;
11  #endif &amp;bsol;* configUSE_STATS_FORMATTING_FUNCTIONS == 1 ) */
12  #if( configUSE_PREEMPTION == 0 )
13  	#define taskYIELD_IF_USING_PREEMPTION()
14  #else
15  	#define taskYIELD_IF_USING_PREEMPTION() portYIELD_WITHIN_API()
16  #endif
17  #define taskNOT_WAITING_NOTIFICATION	( ( uint8_t ) 0 )
18  #define taskWAITING_NOTIFICATION		( ( uint8_t ) 1 )
19  #define taskNOTIFICATION_RECEIVED		( ( uint8_t ) 2 )
20  #define tskSTACK_FILL_BYTE	( 0xa5U )
21  #define tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE	( ( configSUPPORT_STATIC_ALLOCATION == 1 ) &amp;&amp; ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) )
22  #define tskDYNAMICALLY_ALLOCATED_STACK_AND_TCB 		( ( uint8_t ) 0 )
23  #define tskSTATICALLY_ALLOCATED_STACK_ONLY 			( ( uint8_t ) 1 )
24  #define tskSTATICALLY_ALLOCATED_STACK_AND_TCB		( ( uint8_t ) 2 )
25  #if( ( configCHECK_FOR_STACK_OVERFLOW &gt; 1 ) || ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) )
26  	#define tskSET_NEW_STACKS_TO_KNOWN_VALUE	1
27  #else
28  	#define tskSET_NEW_STACKS_TO_KNOWN_VALUE	0
29  #endif
30  #define tskRUNNING_CHAR		( &#x27;X&#x27; )
31  #define tskBLOCKED_CHAR		( &#x27;B&#x27; )
32  #define tskREADY_CHAR		( &#x27;R&#x27; )
33  #define tskDELETED_CHAR		( &#x27;D&#x27; )
34  #define tskSUSPENDED_CHAR	( &#x27;S&#x27; )
35  #ifdef portREMOVE_STATIC_QUALIFIER
36  	#define static
37  #endif
38  #ifndef configIDLE_TASK_NAME
39  	#define configIDLE_TASK_NAME &quot;IDLE&quot;
40  #endif
41  #if ( configUSE_PORT_OPTIMISED_TASK_SELECTION == 0 )
42  	#define taskRECORD_READY_PRIORITY( uxPriority )														\
43  	{																									\
44  		if( ( uxPriority ) &gt; uxTopReadyPriority )														\
45  		{																								\
46  			uxTopReadyPriority = ( uxPriority );														\
47  		}																								\
48  	} &amp;bsol;* taskRECORD_READY_PRIORITY */
49  	#define taskSELECT_HIGHEST_PRIORITY_TASK()															\
50  	{																									\
51  	UBaseType_t uxTopPriority = uxTopReadyPriority;														\
52  																										\
53  										\
54  		while( listLIST_IS_EMPTY( &amp;( pxReadyTasksLists[ uxTopPriority ] ) ) )							\
55  		{																								\
56  			configASSERT( uxTopPriority );																\
57  			--uxTopPriority;																			\
58  		}																								\
59  																										\
60  											\
61  		listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &amp;( pxReadyTasksLists[ uxTopPriority ] ) );			\
62  		uxTopReadyPriority = uxTopPriority;																\
63  	} &amp;bsol;* taskSELECT_HIGHEST_PRIORITY_TASK */
64  	#define taskRESET_READY_PRIORITY( uxPriority )
65  	#define portRESET_READY_PRIORITY( uxPriority, uxTopReadyPriority )
66  #else &amp;bsol;* configUSE_PORT_OPTIMISED_TASK_SELECTION */
67  	#define taskRECORD_READY_PRIORITY( uxPriority )	portRECORD_READY_PRIORITY( uxPriority, uxTopReadyPriority )
68  	#define taskSELECT_HIGHEST_PRIORITY_TASK()														\
69  	{																								\
70  	UBaseType_t uxTopPriority;																		\
71  																									\
72  										\
73  		portGET_HIGHEST_PRIORITY( uxTopPriority, uxTopReadyPriority );								\
74  		configASSERT( listCURRENT_LIST_LENGTH( &amp;( pxReadyTasksLists[ uxTopPriority ] ) ) &gt; 0 );		\
75  		listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &amp;( pxReadyTasksLists[ uxTopPriority ] ) );		\
76  	} &amp;bsol;* taskSELECT_HIGHEST_PRIORITY_TASK() */
77  	#define taskRESET_READY_PRIORITY( uxPriority )														\
78  	{																									\
79  		if( listCURRENT_LIST_LENGTH( &amp;( pxReadyTasksLists[ ( uxPriority ) ] ) ) == ( UBaseType_t ) 0 )	\
80  		{																								\
81  			portRESET_READY_PRIORITY( ( uxPriority ), ( uxTopReadyPriority ) );							\
82  		}																								\
83  	}
84  #endif &amp;bsol;* configUSE_PORT_OPTIMISED_TASK_SELECTION */
85  #define taskSWITCH_DELAYED_LISTS()																	\
86  {																									\
87  	List_t *pxTemp;																					\
88  																									\
89  							\
90  	configASSERT( ( listLIST_IS_EMPTY( pxDelayedTaskList ) ) );										\
91  																									\
92  	pxTemp = pxDelayedTaskList;																		\
93  	pxDelayedTaskList = pxOverflowDelayedTaskList;													\
94  	pxOverflowDelayedTaskList = pxTemp;																\
95  	xNumOfOverflows++;																				\
96  	prvResetNextTaskUnblockTime();																	\
97  }
98  #define prvAddTaskToReadyList( pxTCB )																\
99  	traceMOVED_TASK_TO_READY_STATE( pxTCB );														\
100  	taskRECORD_READY_PRIORITY( ( pxTCB )-&gt;uxPriority );												\
101  	vListInsertEnd( &amp;( pxReadyTasksLists[ ( pxTCB )-&gt;uxPriority ] ), &amp;( ( pxTCB )-&gt;xStateListItem ) ); \
102  	tracePOST_MOVED_TASK_TO_READY_STATE( pxTCB )
103  #define prvReaddTaskToReadyList( pxTCB )															\
104  	traceREADDED_TASK_TO_READY_STATE( pxTCB );														\
105  	taskRECORD_READY_PRIORITY( ( pxTCB )-&gt;uxPriority );												\
106  	vListInsertEnd( &amp;( pxReadyTasksLists[ ( pxTCB )-&gt;uxPriority ] ), &amp;( ( pxTCB )-&gt;xStateListItem ) ); \
107  	tracePOST_MOVED_TASK_TO_READY_STATE( pxTCB )
108  #define prvGetTCBFromHandle( pxHandle ) ( ( ( pxHandle ) == NULL ) ? ( TCB_t * ) pxCurrentTCB : ( TCB_t * ) ( pxHandle ) )
109  #if( configUSE_16_BIT_TICKS == 1 )
110  	#define taskEVENT_LIST_ITEM_VALUE_IN_USE	0x8000U
111  #else
112  	#define taskEVENT_LIST_ITEM_VALUE_IN_USE	0x80000000UL
113  #endif
114  typedef struct tskTaskControlBlock
115  {
116  	volatile StackType_t	*pxTopOfStack;	&amp;bsol;*&lt; Points to the location of the last item placed on the tasks stack.  THIS MUST BE THE FIRST MEMBER OF THE TCB STRUCT. */
117  	#if ( portUSING_MPU_WRAPPERS == 1 )
118  		xMPU_SETTINGS	xMPUSettings;		&amp;bsol;*&lt; The MPU settings are defined as part of the port layer.  THIS MUST BE THE SECOND MEMBER OF THE TCB STRUCT. */
119  	#endif
120  	ListItem_t			xStateListItem;	&amp;bsol;*&lt; The list that the state list item of a task is reference from denotes the state of that task (Ready, Blocked, Suspended ). */
121  	ListItem_t			xEventListItem;		&amp;bsol;*&lt; Used to reference a task from an event list. */
122  	UBaseType_t			uxPriority;			&amp;bsol;*&lt; The priority of the task.  0 is the lowest priority. */
123  	StackType_t			*pxStack;			&amp;bsol;*&lt; Points to the start of the stack. */
124  	char				pcTaskName[ configMAX_TASK_NAME_LEN ];&amp;bsol;*&lt; Descriptive name given to the task when created.  Facilitates debugging only. */ &amp;bsol;*lint !e971 Unqualified char types are allowed for strings and single characters only. */
125  	#if ( ( portSTACK_GROWTH &gt; 0 ) || ( configRECORD_STACK_HIGH_ADDRESS == 1 ) )
126  		StackType_t		*pxEndOfStack;		&amp;bsol;*&lt; Points to the highest valid address for the stack. */
127  	#endif
128  	#if ( portCRITICAL_NESTING_IN_TCB == 1 )
129  		UBaseType_t		uxCriticalNesting;	&amp;bsol;*&lt; Holds the critical section nesting depth for ports that do not maintain their own count in the port layer. */
130  	#endif
131  	#if ( configUSE_TRACE_FACILITY == 1 )
132  		UBaseType_t		uxTCBNumber;		&amp;bsol;*&lt; Stores a number that increments each time a TCB is created.  It allows debuggers to determine when a task has been deleted and then recreated. */
133  		UBaseType_t		uxTaskNumber;		&amp;bsol;*&lt; Stores a number specifically for use by third party trace code. */
134  	#endif
135  	#if ( configUSE_MUTEXES == 1 )
136  		UBaseType_t		uxBasePriority;		&amp;bsol;*&lt; The priority last assigned to the task - used by the priority inheritance mechanism. */
137  		UBaseType_t		uxMutexesHeld;
138  	#endif
139  	#if ( configUSE_APPLICATION_TASK_TAG == 1 )
140  		TaskHookFunction_t pxTaskTag;
141  	#endif
142  	#if( configNUM_THREAD_LOCAL_STORAGE_POINTERS &gt; 0 )
143  		void			*pvThreadLocalStoragePointers[ configNUM_THREAD_LOCAL_STORAGE_POINTERS ];
144  	#endif
145  	#if( configGENERATE_RUN_TIME_STATS == 1 )
146  		uint32_t		ulRunTimeCounter;	&amp;bsol;*&lt; Stores the amount of time the task has spent in the Running state. */
147  	#endif
148  	#if ( configUSE_NEWLIB_REENTRANT == 1 )
149  		struct	_reent xNewLib_reent;
150  	#endif
151  	#if( configUSE_TASK_NOTIFICATIONS == 1 )
152  		volatile uint32_t ulNotifiedValue;
153  		volatile uint8_t ucNotifyState;
154  	#endif
155  	#if( tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE != 0 ) &amp;bsol;*lint !e731 Macro has been consolidated for readability reasons. */
156  		uint8_t	ucStaticallyAllocated; 		&amp;bsol;*&lt; Set to pdTRUE if the task is a statically allocated to ensure no attempt is made to free the memory. */
157  	#endif
158  	#if( INCLUDE_xTaskAbortDelay == 1 )
159  		uint8_t ucDelayAborted;
160  	#endif
161  } tskTCB;
162  typedef tskTCB TCB_t;
163  PRIVILEGED_DATA TCB_t * volatile pxCurrentTCB = NULL;
164  PRIVILEGED_DATA static List_t pxReadyTasksLists[ configMAX_PRIORITIES ];&amp;bsol;*&lt; Prioritised ready tasks. */
165  PRIVILEGED_DATA static List_t xDelayedTaskList1;						&amp;bsol;*&lt; Delayed tasks. */
166  PRIVILEGED_DATA static List_t xDelayedTaskList2;						&amp;bsol;*&lt; Delayed tasks (two lists are used - one for delays that have overflowed the current tick count. */
167  PRIVILEGED_DATA static List_t * volatile pxDelayedTaskList;				&amp;bsol;*&lt; Points to the delayed task list currently being used. */
168  PRIVILEGED_DATA static List_t * volatile pxOverflowDelayedTaskList;		&amp;bsol;*&lt; Points to the delayed task list currently being used to hold tasks that have overflowed the current tick count. */
169  PRIVILEGED_DATA static List_t xPendingReadyList;						&amp;bsol;*&lt; Tasks that have been readied while the scheduler was suspended.  They will be moved to the ready list when the scheduler is resumed. */
170  #if( INCLUDE_vTaskDelete == 1 )
171  	PRIVILEGED_DATA static List_t xTasksWaitingTermination;				&amp;bsol;*&lt; Tasks that have been deleted - but their memory not yet freed. */
172  	PRIVILEGED_DATA static volatile UBaseType_t uxDeletedTasksWaitingCleanUp = ( UBaseType_t ) 0U;
173  #endif
174  #if ( INCLUDE_vTaskSuspend == 1 )
175  	PRIVILEGED_DATA static List_t xSuspendedTaskList;					&amp;bsol;*&lt; Tasks that are currently suspended. */
176  #endif
177  PRIVILEGED_DATA static volatile UBaseType_t uxCurrentNumberOfTasks 	= ( UBaseType_t ) 0U;
178  PRIVILEGED_DATA static volatile TickType_t xTickCount 				= ( TickType_t ) configINITIAL_TICK_COUNT;
179  PRIVILEGED_DATA static volatile UBaseType_t uxTopReadyPriority 		= tskIDLE_PRIORITY;
180  PRIVILEGED_DATA static volatile BaseType_t xSchedulerRunning 		= pdFALSE;
181  PRIVILEGED_DATA static volatile UBaseType_t uxPendedTicks 			= ( UBaseType_t ) 0U;
182  PRIVILEGED_DATA static volatile BaseType_t xYieldPending 			= pdFALSE;
183  PRIVILEGED_DATA static volatile BaseType_t xNumOfOverflows 			= ( BaseType_t ) 0;
184  PRIVILEGED_DATA static UBaseType_t uxTaskNumber 					= ( UBaseType_t ) 0U;
185  PRIVILEGED_DATA static volatile TickType_t xNextTaskUnblockTime		= ( TickType_t ) 0U; &amp;bsol;* Initialised to portMAX_DELAY before the scheduler starts. */
186  PRIVILEGED_DATA static TaskHandle_t xIdleTaskHandle					= NULL;			&amp;bsol;*&lt; Holds the handle of the idle task.  The idle task is created automatically when the scheduler is started. */
187  PRIVILEGED_DATA static volatile UBaseType_t uxSchedulerSuspended	= ( UBaseType_t ) pdFALSE;
188  #if ( configGENERATE_RUN_TIME_STATS == 1 )
189  	PRIVILEGED_DATA static uint32_t ulTaskSwitchedInTime = 0UL;	&amp;bsol;*&lt; Holds the value of a timer/counter the last time a task was switched in. */
190  	PRIVILEGED_DATA static uint32_t ulTotalRunTime = 0UL;		&amp;bsol;*&lt; Holds the total amount of execution time as defined by the run time counter clock. */
191  #endif
192  #if(  configCHECK_FOR_STACK_OVERFLOW &gt; 0 )
193  	extern void vApplicationStackOverflowHook( TaskHandle_t xTask, char *pcTaskName );
194  #endif
195  #if( configUSE_TICK_HOOK &gt; 0 )
196  	extern void vApplicationTickHook( void );
197  #endif
198  #if( configSUPPORT_STATIC_ALLOCATION == 1 )
199  	extern void vApplicationGetIdleTaskMemory( StaticTask_t **ppxIdleTaskTCBBuffer, StackType_t **ppxIdleTaskStackBuffer, uint32_t *pulIdleTaskStackSize );
200  #endif
201  #if ( INCLUDE_vTaskSuspend == 1 )
202  	static BaseType_t prvTaskIsTaskSuspended( const TaskHandle_t xTask ) PRIVILEGED_FUNCTION;
203  #endif &amp;bsol;* INCLUDE_vTaskSuspend */
204  static void prvInitialiseTaskLists( void ) PRIVILEGED_FUNCTION;
205  static portTASK_FUNCTION_PROTO( prvIdleTask, pvParameters );
206  #if ( INCLUDE_vTaskDelete == 1 )
207  	static void prvDeleteTCB( TCB_t *pxTCB ) PRIVILEGED_FUNCTION;
208  #endif
209  static void prvCheckTasksWaitingTermination( void ) PRIVILEGED_FUNCTION;
210  static void prvAddCurrentTaskToDelayedList( TickType_t xTicksToWait, const BaseType_t xCanBlockIndefinitely ) PRIVILEGED_FUNCTION;
211  #if ( configUSE_TRACE_FACILITY == 1 )
212  	static UBaseType_t prvListTasksWithinSingleList( TaskStatus_t *pxTaskStatusArray, List_t *pxList, eTaskState eState ) PRIVILEGED_FUNCTION;
213  #endif
214  #if ( INCLUDE_xTaskGetHandle == 1 )
215  	static TCB_t *prvSearchForNameWithinSingleList( List_t *pxList, const char pcNameToQuery[] ) PRIVILEGED_FUNCTION;
216  #endif
217  #if ( ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) )
218  	static uint16_t prvTaskCheckFreeStackSpace( const uint8_t * pucStackByte ) PRIVILEGED_FUNCTION;
219  #endif
220  #if ( configUSE_TICKLESS_IDLE != 0 )
221  	static TickType_t prvGetExpectedIdleTime( void ) PRIVILEGED_FUNCTION;
222  #endif
223  static void prvResetNextTaskUnblockTime( void );
224  #if ( ( configUSE_TRACE_FACILITY == 1 ) &amp;&amp; ( configUSE_STATS_FORMATTING_FUNCTIONS &gt; 0 ) )
225  	static char *prvWriteNameToBuffer( char *pcBuffer, const char *pcTaskName ) PRIVILEGED_FUNCTION;
226  #endif
227  static void prvInitialiseNewTask( 	TaskFunction_t pxTaskCode,
228  									const char * const pcName, 		&amp;bsol;*lint !e971 Unqualified char types are allowed for strings and single characters only. */
229  									const uint32_t ulStackDepth,
230  									void * const pvParameters,
231  									UBaseType_t uxPriority,
232  									TaskHandle_t * const pxCreatedTask,
233  									TCB_t *pxNewTCB,
234  									const MemoryRegion_t * const xRegions ) PRIVILEGED_FUNCTION;
235  static void prvAddNewTaskToReadyList( TCB_t *pxNewTCB ) PRIVILEGED_FUNCTION;
236  #ifdef FREERTOS_TASKS_C_ADDITIONS_INIT
237  	static void freertos_tasks_c_additions_init( void ) PRIVILEGED_FUNCTION;
238  #endif
239  #if( configSUPPORT_STATIC_ALLOCATION == 1 )
240  	TaskHandle_t xTaskCreateStatic(	TaskFunction_t pxTaskCode,
241  									const char * const pcName,		&amp;bsol;*lint !e971 Unqualified char types are allowed for strings and single characters only. */
242  									const uint32_t ulStackDepth,
243  									void * const pvParameters,
244  									UBaseType_t uxPriority,
245  									StackType_t * const puxStackBuffer,
246  									StaticTask_t * const pxTaskBuffer )
247  	{
248  	TCB_t *pxNewTCB;
249  	TaskHandle_t xReturn;
250  		configASSERT( puxStackBuffer != NULL );
251  		configASSERT( pxTaskBuffer != NULL );
252  		#if( configASSERT_DEFINED == 1 )
253  		{
254  			volatile size_t xSize = sizeof( StaticTask_t );
255  			configASSERT( xSize == sizeof( TCB_t ) );
256  		}
257  		#endif &amp;bsol;* configASSERT_DEFINED */
258  		if( ( pxTaskBuffer != NULL ) &amp;&amp; ( puxStackBuffer != NULL ) )
259  		{
260  			pxNewTCB = ( TCB_t * ) pxTaskBuffer; &amp;bsol;*lint !e740 Unusual cast is ok as the structures are designed to have the same alignment, and the size is checked by an assert. */
261  			pxNewTCB-&gt;pxStack = ( StackType_t * ) puxStackBuffer;
262  			#if( tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE != 0 ) &amp;bsol;*lint !e731 Macro has been consolidated for readability reasons. */
263  			{
264  				pxNewTCB-&gt;ucStaticallyAllocated = tskSTATICALLY_ALLOCATED_STACK_AND_TCB;
265  			}
266  			#endif &amp;bsol;* configSUPPORT_DYNAMIC_ALLOCATION */
267  			prvInitialiseNewTask( pxTaskCode, pcName, ulStackDepth, pvParameters, uxPriority, &amp;xReturn, pxNewTCB, NULL );
268  			prvAddNewTaskToReadyList( pxNewTCB );
269  		}
270  		else
271  		{
272  			xReturn = NULL;
273  		}
274  		return xReturn;
275  	}
276  #endif &amp;bsol;* SUPPORT_STATIC_ALLOCATION */
277  #if( ( portUSING_MPU_WRAPPERS == 1 ) &amp;&amp; ( configSUPPORT_STATIC_ALLOCATION == 1 ) )
278  	BaseType_t xTaskCreateRestrictedStatic( const TaskParameters_t * const pxTaskDefinition, TaskHandle_t *pxCreatedTask )
279  	{
280  	TCB_t *pxNewTCB;
281  	BaseType_t xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
282  		configASSERT( pxTaskDefinition-&gt;puxStackBuffer != NULL );
283  		configASSERT( pxTaskDefinition-&gt;pxTaskBuffer != NULL );
284  		if( ( pxTaskDefinition-&gt;puxStackBuffer != NULL ) &amp;&amp; ( pxTaskDefinition-&gt;pxTaskBuffer != NULL ) )
285  		{
286  			pxNewTCB = ( TCB_t * ) pxTaskDefinition-&gt;pxTaskBuffer;
287  			pxNewTCB-&gt;pxStack = pxTaskDefinition-&gt;puxStackBuffer;
288  			#if( tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE != 0 )
289  			{
290  				pxNewTCB-&gt;ucStaticallyAllocated = tskSTATICALLY_ALLOCATED_STACK_AND_TCB;
291  			}
292  			#endif &amp;bsol;* configSUPPORT_DYNAMIC_ALLOCATION */
293  			prvInitialiseNewTask(	pxTaskDefinition-&gt;pvTaskCode,
294  									pxTaskDefinition-&gt;pcName,
295  									( uint32_t ) pxTaskDefinition-&gt;usStackDepth,
296  									pxTaskDefinition-&gt;pvParameters,
297  									pxTaskDefinition-&gt;uxPriority,
298  									pxCreatedTask, pxNewTCB,
299  									pxTaskDefinition-&gt;xRegions );
300  			prvAddNewTaskToReadyList( pxNewTCB );
301  			xReturn = pdPASS;
302  		}
303  		return xReturn;
304  	}
305  #endif &amp;bsol;* ( portUSING_MPU_WRAPPERS == 1 ) &amp;&amp; ( configSUPPORT_STATIC_ALLOCATION == 1 ) */
306  #if( ( portUSING_MPU_WRAPPERS == 1 ) &amp;&amp; ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) )
307  	BaseType_t xTaskCreateRestricted( const TaskParameters_t * const pxTaskDefinition, TaskHandle_t *pxCreatedTask )
308  	{
309  	TCB_t *pxNewTCB;
310  	BaseType_t xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
311  		configASSERT( pxTaskDefinition-&gt;puxStackBuffer );
312  		if( pxTaskDefinition-&gt;puxStackBuffer != NULL )
313  		{
314  			pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) );
315  			if( pxNewTCB != NULL )
316  			{
317  				pxNewTCB-&gt;pxStack = pxTaskDefinition-&gt;puxStackBuffer;
318  				#if( configSUPPORT_STATIC_ALLOCATION == 1 )
319  				{
320  					pxNewTCB-&gt;ucStaticallyAllocated = tskSTATICALLY_ALLOCATED_STACK_ONLY;
321  				}
322  				#endif
323  				prvInitialiseNewTask(	pxTaskDefinition-&gt;pvTaskCode,
324  										pxTaskDefinition-&gt;pcName,
325  										( uint32_t ) pxTaskDefinition-&gt;usStackDepth,
326  										pxTaskDefinition-&gt;pvParameters,
327  										pxTaskDefinition-&gt;uxPriority,
328  										pxCreatedTask, pxNewTCB,
329  										pxTaskDefinition-&gt;xRegions );
330  				prvAddNewTaskToReadyList( pxNewTCB );
331  				xReturn = pdPASS;
332  			}
333  		}
334  		return xReturn;
335  	}
336  #endif &amp;bsol;* portUSING_MPU_WRAPPERS */
337  #if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )
338  	BaseType_t xTaskCreate(	TaskFunction_t pxTaskCode,
339  							const char * const pcName,		&amp;bsol;*lint !e971 Unqualified char types are allowed for strings and single characters only. */
340  							const configSTACK_DEPTH_TYPE usStackDepth,
341  							void * const pvParameters,
342  							UBaseType_t uxPriority,
343  							TaskHandle_t * const pxCreatedTask )
344  	{
345  	TCB_t *pxNewTCB;
346  	BaseType_t xReturn;
347  		#if( portSTACK_GROWTH &gt; 0 )
348  		{
349  			pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) );
350  			if( pxNewTCB != NULL )
351  			{
352  				pxNewTCB-&gt;pxStack = ( StackType_t * ) pvPortMalloc( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ) ); &amp;bsol;*lint !e961 MISRA exception as the casts are only redundant for some ports. */
353  				if( pxNewTCB-&gt;pxStack == NULL )
354  				{
355  					vPortFree( pxNewTCB );
356  					pxNewTCB = NULL;
357  				}
358  			}
359  		}
360  		#else &amp;bsol;* portSTACK_GROWTH */
361  		{
362  		StackType_t *pxStack;
363  			pxStack = ( StackType_t * ) pvPortMalloc( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ) ); &amp;bsol;*lint !e961 MISRA exception as the casts are only redundant for some ports. */
364  			if( pxStack != NULL )
365  			{
366  				pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) ); &amp;bsol;*lint !e961 MISRA exception as the casts are only redundant for some paths. */
367  				if( pxNewTCB != NULL )
368  				{
369  					pxNewTCB-&gt;pxStack = pxStack;
370  				}
371  				else
372  				{
373  					vPortFree( pxStack );
374  				}
375  			}
376  			else
377  			{
378  				pxNewTCB = NULL;
379  			}
380  		}
381  		#endif &amp;bsol;* portSTACK_GROWTH */
382  		if( pxNewTCB != NULL )
383  		{
384  			#if( tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE != 0 ) &amp;bsol;*lint !e731 Macro has been consolidated for readability reasons. */
385  			{
386  				pxNewTCB-&gt;ucStaticallyAllocated = tskDYNAMICALLY_ALLOCATED_STACK_AND_TCB;
387  			}
388  			#endif &amp;bsol;* configSUPPORT_STATIC_ALLOCATION */
389  			prvInitialiseNewTask( pxTaskCode, pcName, ( uint32_t ) usStackDepth, pvParameters, uxPriority, pxCreatedTask, pxNewTCB, NULL );
390  			prvAddNewTaskToReadyList( pxNewTCB );
391  			xReturn = pdPASS;
392  		}
393  		else
394  		{
395  			xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
396  		}
397  		return xReturn;
398  	}
399  #endif &amp;bsol;* configSUPPORT_DYNAMIC_ALLOCATION */
400  static void prvInitialiseNewTask( 	TaskFunction_t pxTaskCode,
401  									const char * const pcName,		&amp;bsol;*lint !e971 Unqualified char types are allowed for strings and single characters only. */
402  									const uint32_t ulStackDepth,
403  									void * const pvParameters,
404  									UBaseType_t uxPriority,
405  									TaskHandle_t * const pxCreatedTask,
406  									TCB_t *pxNewTCB,
407  									const MemoryRegion_t * const xRegions )
408  {
409  StackType_t *pxTopOfStack;
410  UBaseType_t x;
411  	#if( portUSING_MPU_WRAPPERS == 1 )
412  		BaseType_t xRunPrivileged;
413  		if( ( uxPriority &amp; portPRIVILEGE_BIT ) != 0U )
414  		{
415  			xRunPrivileged = pdTRUE;
416  		}
417  		else
418  		{
419  			xRunPrivileged = pdFALSE;
420  		}
421  		uxPriority &amp;= ~portPRIVILEGE_BIT;
422  	#endif &amp;bsol;* portUSING_MPU_WRAPPERS == 1 */
423  	#if( tskSET_NEW_STACKS_TO_KNOWN_VALUE == 1 )
424  	{
425  		( void ) memset( pxNewTCB-&gt;pxStack, ( int ) tskSTACK_FILL_BYTE, ( size_t ) ulStackDepth * sizeof( StackType_t ) );
426  	}
427  	#endif &amp;bsol;* tskSET_NEW_STACKS_TO_KNOWN_VALUE */
428  	#if( portSTACK_GROWTH &lt; 0 )
429  	{
430  		pxTopOfStack = pxNewTCB-&gt;pxStack + ( ulStackDepth - ( uint32_t ) 1 );
431  		pxTopOfStack = ( StackType_t * ) ( ( ( portPOINTER_SIZE_TYPE ) pxTopOfStack ) &amp; ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) ); &amp;bsol;*lint !e923 MISRA exception.  Avoiding casts between pointers and integers is not practical.  Size differences accounted for using portPOINTER_SIZE_TYPE type. */
432  		configASSERT( ( ( ( portPOINTER_SIZE_TYPE ) pxTopOfStack &amp; ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) == 0UL ) );
433  		#if( configRECORD_STACK_HIGH_ADDRESS == 1 )
434  		{
435  			pxNewTCB-&gt;pxEndOfStack = pxTopOfStack;
436  		}
437  		#endif &amp;bsol;* configRECORD_STACK_HIGH_ADDRESS */
438  	}
439  	#else &amp;bsol;* portSTACK_GROWTH */
440  	{
441  		pxTopOfStack = pxNewTCB-&gt;pxStack;
442  		configASSERT( ( ( ( portPOINTER_SIZE_TYPE ) pxNewTCB-&gt;pxStack &amp; ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) == 0UL ) );
443  		pxNewTCB-&gt;pxEndOfStack = pxNewTCB-&gt;pxStack + ( ulStackDepth - ( uint32_t ) 1 );
444  	}
445  	#endif &amp;bsol;* portSTACK_GROWTH */
446  	for( x = ( UBaseType_t ) 0; x &lt; ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
447  	{
448  		pxNewTCB-&gt;pcTaskName[ x ] = pcName[ x ];
449  		if( pcName[ x ] == 0x00 )
450  		{
451  			break;
452  		}
453  		else
454  		{
455  			mtCOVERAGE_TEST_MARKER();
456  		}
457  	}
458  	pxNewTCB-&gt;pcTaskName[ configMAX_TASK_NAME_LEN - 1 ] = &#x27;\0&#x27;;
459  	if( uxPriority &gt;= ( UBaseType_t ) configMAX_PRIORITIES )
460  	{
461  		uxPriority = ( UBaseType_t ) configMAX_PRIORITIES - ( UBaseType_t ) 1U;
462  	}
463  	else
464  	{
465  		mtCOVERAGE_TEST_MARKER();
466  	}
467  	pxNewTCB-&gt;uxPriority = uxPriority;
468  	#if ( configUSE_MUTEXES == 1 )
469  	{
470  		pxNewTCB-&gt;uxBasePriority = uxPriority;
471  		pxNewTCB-&gt;uxMutexesHeld = 0;
472  	}
473  	#endif &amp;bsol;* configUSE_MUTEXES */
474  	vListInitialiseItem( &amp;( pxNewTCB-&gt;xStateListItem ) );
475  	vListInitialiseItem( &amp;( pxNewTCB-&gt;xEventListItem ) );
476  	listSET_LIST_ITEM_OWNER( &amp;( pxNewTCB-&gt;xStateListItem ), pxNewTCB );
477  	listSET_LIST_ITEM_VALUE( &amp;( pxNewTCB-&gt;xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriority ); &amp;bsol;*lint !e961 MISRA exception as the casts are only redundant for some ports. */
478  	listSET_LIST_ITEM_OWNER( &amp;( pxNewTCB-&gt;xEventListItem ), pxNewTCB );
479  	#if ( portCRITICAL_NESTING_IN_TCB == 1 )
480  	{
481  		pxNewTCB-&gt;uxCriticalNesting = ( UBaseType_t ) 0U;
482  	}
483  	#endif &amp;bsol;* portCRITICAL_NESTING_IN_TCB */
484  	#if ( configUSE_APPLICATION_TASK_TAG == 1 )
485  	{
486  		pxNewTCB-&gt;pxTaskTag = NULL;
487  	}
488  	#endif &amp;bsol;* configUSE_APPLICATION_TASK_TAG */
489  	#if ( configGENERATE_RUN_TIME_STATS == 1 )
490  	{
491  		pxNewTCB-&gt;ulRunTimeCounter = 0UL;
492  	}
493  	#endif &amp;bsol;* configGENERATE_RUN_TIME_STATS */
494  	#if ( portUSING_MPU_WRAPPERS == 1 )
495  	{
496  		vPortStoreTaskMPUSettings( &amp;( pxNewTCB-&gt;xMPUSettings ), xRegions, pxNewTCB-&gt;pxStack, ulStackDepth );
497  	}
498  	#else
499  	{
500  		( void ) xRegions;
501  	}
502  	#endif
503  	#if( configNUM_THREAD_LOCAL_STORAGE_POINTERS != 0 )
504  	{
505  		for( x = 0; x &lt; ( UBaseType_t ) configNUM_THREAD_LOCAL_STORAGE_POINTERS; x++ )
506  		{
507  			pxNewTCB-&gt;pvThreadLocalStoragePointers[ x ] = NULL;
508  		}
509  	}
510  	#endif
511  	#if ( configUSE_TASK_NOTIFICATIONS == 1 )
512  	{
513  		pxNewTCB-&gt;ulNotifiedValue = 0;
514  		pxNewTCB-&gt;ucNotifyState = taskNOT_WAITING_NOTIFICATION;
515  	}
516  	#endif
517  	#if ( configUSE_NEWLIB_REENTRANT == 1 )
518  	{
519  		_REENT_INIT_PTR( ( &amp;( pxNewTCB-&gt;xNewLib_reent ) ) );
520  	}
521  	#endif
522  	#if( INCLUDE_xTaskAbortDelay == 1 )
523  	{
524  		pxNewTCB-&gt;ucDelayAborted = pdFALSE;
525  	}
526  	#endif
527  	#if( portUSING_MPU_WRAPPERS == 1 )
528  	{
529  		pxNewTCB-&gt;pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged );
530  	}
531  	#else &amp;bsol;* portUSING_MPU_WRAPPERS */
532  	{
533  		pxNewTCB-&gt;pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
534  	}
535  	#endif &amp;bsol;* portUSING_MPU_WRAPPERS */
536  	if( ( void * ) pxCreatedTask != NULL )
537  	{
538  		*pxCreatedTask = ( TaskHandle_t ) pxNewTCB;
539  	}
540  	else
541  	{
542  		mtCOVERAGE_TEST_MARKER();
543  	}
544  }
545  static void prvAddNewTaskToReadyList( TCB_t *pxNewTCB )
546  {
547  	taskENTER_CRITICAL();
548  	{
549  		uxCurrentNumberOfTasks++;
550  		if( pxCurrentTCB == NULL )
551  		{
552  			pxCurrentTCB = pxNewTCB;
553  			if( uxCurrentNumberOfTasks == ( UBaseType_t ) 1 )
554  			{
555  				prvInitialiseTaskLists();
556  			}
557  			else
558  			{
559  				mtCOVERAGE_TEST_MARKER();
560  			}
561  		}
562  		else
563  		{
564  			if( xSchedulerRunning == pdFALSE )
565  			{
566  				if( pxCurrentTCB-&gt;uxPriority &lt;= pxNewTCB-&gt;uxPriority )
567  				{
568  					pxCurrentTCB = pxNewTCB;
569  				}
570  				else
571  				{
572  					mtCOVERAGE_TEST_MARKER();
573  				}
574  			}
575  			else
576  			{
577  				mtCOVERAGE_TEST_MARKER();
578  			}
579  		}
580  		uxTaskNumber++;
581  		#if ( configUSE_TRACE_FACILITY == 1 )
582  		{
583  			pxNewTCB-&gt;uxTCBNumber = uxTaskNumber;
584  		}
585  		#endif &amp;bsol;* configUSE_TRACE_FACILITY */
586  		traceTASK_CREATE( pxNewTCB );
587  		prvAddTaskToReadyList( pxNewTCB );
588  		portSETUP_TCB( pxNewTCB );
589  	}
590  	taskEXIT_CRITICAL();
591  	if( xSchedulerRunning != pdFALSE )
592  	{
593  		if( pxCurrentTCB-&gt;uxPriority &lt; pxNewTCB-&gt;uxPriority )
594  		{
595  			taskYIELD_IF_USING_PREEMPTION();
596  		}
597  		else
598  		{
599  			mtCOVERAGE_TEST_MARKER();
600  		}
601  	}
602  	else
603  	{
604  		mtCOVERAGE_TEST_MARKER();
605  	}
606  }
607  #if ( INCLUDE_vTaskDelete == 1 )
608  	void vTaskDelete( TaskHandle_t xTaskToDelete )
609  	{
610  	TCB_t *pxTCB;
611  		taskENTER_CRITICAL();
612  		{
613  			pxTCB = prvGetTCBFromHandle( xTaskToDelete );
614  			if( uxListRemove( &amp;( pxTCB-&gt;xStateListItem ) ) == ( UBaseType_t ) 0 )
615  			{
616  				taskRESET_READY_PRIORITY( pxTCB-&gt;uxPriority );
617  			}
618  			else
619  			{
620  				mtCOVERAGE_TEST_MARKER();
621  			}
622  			if( listLIST_ITEM_CONTAINER( &amp;( pxTCB-&gt;xEventListItem ) ) != NULL )
623  			{
624  				( void ) uxListRemove( &amp;( pxTCB-&gt;xEventListItem ) );
625  			}
626  			else
627  			{
628  				mtCOVERAGE_TEST_MARKER();
629  			}
630  			uxTaskNumber++;
631  			if( pxTCB == pxCurrentTCB )
632  			{
633  				vListInsertEnd( &amp;xTasksWaitingTermination, &amp;( pxTCB-&gt;xStateListItem ) );
634  				++uxDeletedTasksWaitingCleanUp;
635  				portPRE_TASK_DELETE_HOOK( pxTCB, &amp;xYieldPending );
636  			}
637  			else
638  			{
639  				--uxCurrentNumberOfTasks;
640  				prvDeleteTCB( pxTCB );
641  				prvResetNextTaskUnblockTime();
642  			}
643  			traceTASK_DELETE( pxTCB );
644  		}
645  		taskEXIT_CRITICAL();
646  		if( xSchedulerRunning != pdFALSE )
647  		{
648  			if( pxTCB == pxCurrentTCB )
649  			{
650  				configASSERT( uxSchedulerSuspended == 0 );
651  				portYIELD_WITHIN_API();
652  			}
653  			else
654  			{
655  				mtCOVERAGE_TEST_MARKER();
656  			}
657  		}
658  	}
659  #endif &amp;bsol;* INCLUDE_vTaskDelete */
660  #if ( INCLUDE_vTaskDelayUntil == 1 )
661  	void vTaskDelayUntil( TickType_t * const pxPreviousWakeTime, const TickType_t xTimeIncrement )
662  	{
663  	TickType_t xTimeToWake;
664  	BaseType_t xAlreadyYielded, xShouldDelay = pdFALSE;
665  		configASSERT( pxPreviousWakeTime );
666  		configASSERT( ( xTimeIncrement &gt; 0U ) );
667  		configASSERT( uxSchedulerSuspended == 0 );
668  		vTaskSuspendAll();
669  		{
670  			const TickType_t xConstTickCount = xTickCount;
671  			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
672  			if( xConstTickCount &lt; *pxPreviousWakeTime )
673  			{
674  				if( ( xTimeToWake &lt; *pxPreviousWakeTime ) &amp;&amp; ( xTimeToWake &gt; xConstTickCount ) )
675  				{
676  					xShouldDelay = pdTRUE;
677  				}
678  				else
679  				{
680  					mtCOVERAGE_TEST_MARKER();
681  				}
682  			}
683  			else
684  			{
685  				if( ( xTimeToWake &lt; *pxPreviousWakeTime ) || ( xTimeToWake &gt; xConstTickCount ) )
686  				{
687  					xShouldDelay = pdTRUE;
688  				}
689  				else
690  				{
691  					mtCOVERAGE_TEST_MARKER();
692  				}
693  			}
694  			*pxPreviousWakeTime = xTimeToWake;
695  			if( xShouldDelay != pdFALSE )
696  			{
697  				traceTASK_DELAY_UNTIL( xTimeToWake );
698  				prvAddCurrentTaskToDelayedList( xTimeToWake - xConstTickCount, pdFALSE );
699  			}
700  			else
701  			{
702  				mtCOVERAGE_TEST_MARKER();
703  			}
704  		}
705  		xAlreadyYielded = xTaskResumeAll();
706  		if( xAlreadyYielded == pdFALSE )
707  		{
708  			portYIELD_WITHIN_API();
709  		}
710  		else
711  		{
712  			mtCOVERAGE_TEST_MARKER();
713  		}
714  	}
715  #endif &amp;bsol;* INCLUDE_vTaskDelayUntil */
716  #if ( INCLUDE_vTaskDelay == 1 )
717  	void vTaskDelay( const TickType_t xTicksToDelay )
718  	{
719  	BaseType_t xAlreadyYielded = pdFALSE;
720  		if( xTicksToDelay &gt; ( TickType_t ) 0U )
721  		{
722  			configASSERT( uxSchedulerSuspended == 0 );
723  			vTaskSuspendAll();
724  			{
725  				traceTASK_DELAY();
726  				prvAddCurrentTaskToDelayedList( xTicksToDelay, pdFALSE );
727  			}
728  			xAlreadyYielded = xTaskResumeAll();
729  		}
730  		else
731  		{
732  			mtCOVERAGE_TEST_MARKER();
733  		}
734  		if( xAlreadyYielded == pdFALSE )
735  		{
736  			portYIELD_WITHIN_API();
737  		}
738  		else
739  		{
740  			mtCOVERAGE_TEST_MARKER();
741  		}
742  	}
743  #endif &amp;bsol;* INCLUDE_vTaskDelay */
744  #if( ( INCLUDE_eTaskGetState == 1 ) || ( configUSE_TRACE_FACILITY == 1 ) )
745  	eTaskState eTaskGetState( TaskHandle_t xTask )
746  	{
747  	eTaskState eReturn;
748  	List_t *pxStateList;
749  	const TCB_t * const pxTCB = ( TCB_t * ) xTask;
750  		configASSERT( pxTCB );
751  		if( pxTCB == pxCurrentTCB )
752  		{
753  			eReturn = eRunning;
754  		}
755  		else
756  		{
757  			taskENTER_CRITICAL();
758  			{
759  				pxStateList = ( List_t * ) listLIST_ITEM_CONTAINER( &amp;( pxTCB-&gt;xStateListItem ) );
760  			}
761  			taskEXIT_CRITICAL();
762  			if( ( pxStateList == pxDelayedTaskList ) || ( pxStateList == pxOverflowDelayedTaskList ) )
763  			{
764  				eReturn = eBlocked;
765  			}
766  			#if ( INCLUDE_vTaskSuspend == 1 )
767  				else if( pxStateList == &amp;xSuspendedTaskList )
768  				{
769  					if( listLIST_ITEM_CONTAINER( &amp;( pxTCB-&gt;xEventListItem ) ) == NULL )
770  					{
771  						eReturn = eSuspended;
772  					}
773  					else
774  					{
775  						eReturn = eBlocked;
776  					}
777  				}
778  			#endif
779  			#if ( INCLUDE_vTaskDelete == 1 )
780  				else if( ( pxStateList == &amp;xTasksWaitingTermination ) || ( pxStateList == NULL ) )
781  				{
782  					eReturn = eDeleted;
783  				}
784  			#endif
785  			else &amp;bsol;*lint !e525 Negative indentation is intended to make use of pre-processor clearer. */
786  			{
787  				eReturn = eReady;
788  			}
789  		}
790  		return eReturn;
791  	} &amp;bsol;*lint !e818 xTask cannot be a pointer to const because it is a typedef. */
792  #endif &amp;bsol;* INCLUDE_eTaskGetState */
793  #if ( INCLUDE_uxTaskPriorityGet == 1 )
794  	UBaseType_t uxTaskPriorityGet( TaskHandle_t xTask )
795  	{
796  	TCB_t *pxTCB;
797  	UBaseType_t uxReturn;
798  		taskENTER_CRITICAL();
799  		{
800  			pxTCB = prvGetTCBFromHandle( xTask );
801  			uxReturn = pxTCB-&gt;uxPriority;
802  		}
803  		taskEXIT_CRITICAL();
804  		return uxReturn;
805  	}
806  #endif &amp;bsol;* INCLUDE_uxTaskPriorityGet */
807  #if ( INCLUDE_uxTaskPriorityGet == 1 )
808  	UBaseType_t uxTaskPriorityGetFromISR( TaskHandle_t xTask )
809  	{
810  	TCB_t *pxTCB;
811  	UBaseType_t uxReturn, uxSavedInterruptState;
812  		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
813  		uxSavedInterruptState = portSET_INTERRUPT_MASK_FROM_ISR();
814  		{
815  			pxTCB = prvGetTCBFromHandle( xTask );
816  			uxReturn = pxTCB-&gt;uxPriority;
817  		}
818  		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptState );
819  		return uxReturn;
820  	}
821  #endif &amp;bsol;* INCLUDE_uxTaskPriorityGet */
822  #if ( INCLUDE_vTaskPrioritySet == 1 )
823  	void vTaskPrioritySet( TaskHandle_t xTask, UBaseType_t uxNewPriority )
824  	{
825  	TCB_t *pxTCB;
826  	UBaseType_t uxCurrentBasePriority, uxPriorityUsedOnEntry;
827  	BaseType_t xYieldRequired = pdFALSE;
828  		configASSERT( ( uxNewPriority &lt; configMAX_PRIORITIES ) );
829  		if( uxNewPriority &gt;= ( UBaseType_t ) configMAX_PRIORITIES )
830  		{
831  			uxNewPriority = ( UBaseType_t ) configMAX_PRIORITIES - ( UBaseType_t ) 1U;
832  		}
833  		else
834  		{
835  			mtCOVERAGE_TEST_MARKER();
836  		}
837  		taskENTER_CRITICAL();
838  		{
839  			pxTCB = prvGetTCBFromHandle( xTask );
840  			traceTASK_PRIORITY_SET( pxTCB, uxNewPriority );
841  			#if ( configUSE_MUTEXES == 1 )
842  			{
843  				uxCurrentBasePriority = pxTCB-&gt;uxBasePriority;
844  			}
845  			#else
846  			{
847  				uxCurrentBasePriority = pxTCB-&gt;uxPriority;
848  			}
849  			#endif
850  			if( uxCurrentBasePriority != uxNewPriority )
851  			{
852  				if( uxNewPriority &gt; uxCurrentBasePriority )
853  				{
854  					if( pxTCB != pxCurrentTCB )
855  					{
856  						if( uxNewPriority &gt;= pxCurrentTCB-&gt;uxPriority )
857  						{
858  							xYieldRequired = pdTRUE;
859  						}
860  						else
861  						{
862  							mtCOVERAGE_TEST_MARKER();
863  						}
864  					}
865  					else
866  					{
867  					}
868  				}
869  				else if( pxTCB == pxCurrentTCB )
870  				{
871  					xYieldRequired = pdTRUE;
872  				}
873  				else
874  				{
875  				}
876  				uxPriorityUsedOnEntry = pxTCB-&gt;uxPriority;
877  				#if ( configUSE_MUTEXES == 1 )
878  				{
879  					if( pxTCB-&gt;uxBasePriority == pxTCB-&gt;uxPriority )
880  					{
881  						pxTCB-&gt;uxPriority = uxNewPriority;
882  					}
883  					else
884  					{
885  						mtCOVERAGE_TEST_MARKER();
886  					}
887  					pxTCB-&gt;uxBasePriority = uxNewPriority;
888  				}
889  				#else
890  				{
891  					pxTCB-&gt;uxPriority = uxNewPriority;
892  				}
893  				#endif
894  				if( ( listGET_LIST_ITEM_VALUE( &amp;( pxTCB-&gt;xEventListItem ) ) &amp; taskEVENT_LIST_ITEM_VALUE_IN_USE ) == 0UL )
895  				{
896  					listSET_LIST_ITEM_VALUE( &amp;( pxTCB-&gt;xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxNewPriority ) ); &amp;bsol;*lint !e961 MISRA exception as the casts are only redundant for some ports. */
897  				}
898  				else
899  				{
900  					mtCOVERAGE_TEST_MARKER();
901  				}
902  				if( listIS_CONTAINED_WITHIN( &amp;( pxReadyTasksLists[ uxPriorityUsedOnEntry ] ), &amp;( pxTCB-&gt;xStateListItem ) ) != pdFALSE )
903  				{
904  					if( uxListRemove( &amp;( pxTCB-&gt;xStateListItem ) ) == ( UBaseType_t ) 0 )
905  					{
906  						portRESET_READY_PRIORITY( uxPriorityUsedOnEntry, uxTopReadyPriority );
907  					}
908  					else
909  					{
910  						mtCOVERAGE_TEST_MARKER();
911  					}
912  					prvReaddTaskToReadyList( pxTCB );
913  				}
914  				else
915  				{
916  					mtCOVERAGE_TEST_MARKER();
917  				}
918  				if( xYieldRequired != pdFALSE )
919  				{
920  					taskYIELD_IF_USING_PREEMPTION();
921  				}
922  				else
923  				{
924  					mtCOVERAGE_TEST_MARKER();
925  				}
926  				( void ) uxPriorityUsedOnEntry;
927  			}
928  		}
929  		taskEXIT_CRITICAL();
930  	}
931  #endif &amp;bsol;* INCLUDE_vTaskPrioritySet */
932  #if ( INCLUDE_vTaskSuspend == 1 )
933  	void vTaskSuspend( TaskHandle_t xTaskToSuspend )
934  	{
935  	TCB_t *pxTCB;
936  		taskENTER_CRITICAL();
937  		{
938  			pxTCB = prvGetTCBFromHandle( xTaskToSuspend );
939  			traceTASK_SUSPEND( pxTCB );
940  			if( uxListRemove( &amp;( pxTCB-&gt;xStateListItem ) ) == ( UBaseType_t ) 0 )
941  			{
942  				taskRESET_READY_PRIORITY( pxTCB-&gt;uxPriority );
943  			}
944  			else
945  			{
946  				mtCOVERAGE_TEST_MARKER();
947  			}
948  			if( listLIST_ITEM_CONTAINER( &amp;( pxTCB-&gt;xEventListItem ) ) != NULL )
949  			{
950  				( void ) uxListRemove( &amp;( pxTCB-&gt;xEventListItem ) );
951  			}
952  			else
953  			{
954  				mtCOVERAGE_TEST_MARKER();
955  			}
956  			traceMOVED_TASK_TO_SUSPENDED_LIST(pxTCB);
957  			vListInsertEnd( &amp;xSuspendedTaskList, &amp;( pxTCB-&gt;xStateListItem ) );
958  			#if( configUSE_TASK_NOTIFICATIONS == 1 )
959  			{
960  				if( pxTCB-&gt;ucNotifyState == taskWAITING_NOTIFICATION )
961  				{
962  					pxTCB-&gt;ucNotifyState = taskNOT_WAITING_NOTIFICATION;
963  				}
964  			}
965  			#endif
966  		}
967  		taskEXIT_CRITICAL();
968  		if( xSchedulerRunning != pdFALSE )
969  		{
970  			taskENTER_CRITICAL();
971  			{
972  				prvResetNextTaskUnblockTime();
973  			}
974  			taskEXIT_CRITICAL();
975  		}
976  		else
977  		{
978  			mtCOVERAGE_TEST_MARKER();
979  		}
980  		if( pxTCB == pxCurrentTCB )
981  		{
982  			if( xSchedulerRunning != pdFALSE )
983  			{
984  				configASSERT( uxSchedulerSuspended == 0 );
985  				portYIELD_WITHIN_API();
986  			}
987  			else
988  			{
989  				if( listCURRENT_LIST_LENGTH( &amp;xSuspendedTaskList ) == uxCurrentNumberOfTasks )
990  				{
991  					pxCurrentTCB = NULL;
992  				}
993  				else
994  				{
995  					vTaskSwitchContext();
996  				}
997  			}
998  		}
999  		else
1000  		{
1001  			mtCOVERAGE_TEST_MARKER();
1002  		}
1003  	}
1004  #endif &amp;bsol;* INCLUDE_vTaskSuspend */
1005  #if ( INCLUDE_vTaskSuspend == 1 )
1006  	static BaseType_t prvTaskIsTaskSuspended( const TaskHandle_t xTask )
1007  	{
1008  	BaseType_t xReturn = pdFALSE;
1009  	const TCB_t * const pxTCB = ( TCB_t * ) xTask;
1010  		configASSERT( xTask );
1011  		if( listIS_CONTAINED_WITHIN( &amp;xSuspendedTaskList, &amp;( pxTCB-&gt;xStateListItem ) ) != pdFALSE )
1012  		{
1013  			if( listIS_CONTAINED_WITHIN( &amp;xPendingReadyList, &amp;( pxTCB-&gt;xEventListItem ) ) == pdFALSE )
1014  			{
1015  				if( listIS_CONTAINED_WITHIN( NULL, &amp;( pxTCB-&gt;xEventListItem ) ) != pdFALSE ) &amp;bsol;*lint !e961.  The cast is only redundant when NULL is used. */
1016  				{
1017  					xReturn = pdTRUE;
1018  				}
1019  				else
1020  				{
1021  					mtCOVERAGE_TEST_MARKER();
1022  				}
1023  			}
1024  			else
1025  			{
1026  				mtCOVERAGE_TEST_MARKER();
1027  			}
1028  		}
1029  		else
1030  		{
1031  			mtCOVERAGE_TEST_MARKER();
1032  		}
1033  		return xReturn;
1034  	} &amp;bsol;*lint !e818 xTask cannot be a pointer to const because it is a typedef. */
1035  #endif &amp;bsol;* INCLUDE_vTaskSuspend */
1036  #if ( INCLUDE_vTaskSuspend == 1 )
1037  	void vTaskResume( TaskHandle_t xTaskToResume )
1038  	{
1039  	TCB_t * const pxTCB = ( TCB_t * ) xTaskToResume;
1040  		configASSERT( xTaskToResume );
1041  		if( ( pxTCB != NULL ) &amp;&amp; ( pxTCB != pxCurrentTCB ) )
1042  		{
1043  			taskENTER_CRITICAL();
1044  			{
1045  				if( prvTaskIsTaskSuspended( pxTCB ) != pdFALSE )
1046  				{
1047  					traceTASK_RESUME( pxTCB );
1048  					( void ) uxListRemove(  &amp;( pxTCB-&gt;xStateListItem ) );
1049  					prvAddTaskToReadyList( pxTCB );
1050  					if( pxTCB-&gt;uxPriority &gt;= pxCurrentTCB-&gt;uxPriority )
1051  					{
1052  						taskYIELD_IF_USING_PREEMPTION();
1053  					}
1054  					else
1055  					{
1056  						mtCOVERAGE_TEST_MARKER();
1057  					}
1058  				}
1059  				else
1060  				{
1061  					mtCOVERAGE_TEST_MARKER();
1062  				}
1063  			}
1064  			taskEXIT_CRITICAL();
1065  		}
1066  		else
1067  		{
1068  			mtCOVERAGE_TEST_MARKER();
1069  		}
1070  	}
1071  #endif &amp;bsol;* INCLUDE_vTaskSuspend */
1072  #if ( ( INCLUDE_xTaskResumeFromISR == 1 ) &amp;&amp; ( INCLUDE_vTaskSuspend == 1 ) )
1073  	BaseType_t xTaskResumeFromISR( TaskHandle_t xTaskToResume )
1074  	{
1075  	BaseType_t xYieldRequired = pdFALSE;
1076  	TCB_t * const pxTCB = ( TCB_t * ) xTaskToResume;
1077  	UBaseType_t uxSavedInterruptStatus;
1078  		configASSERT( xTaskToResume );
1079  		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
1080  		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
1081  		{
1082  			if( prvTaskIsTaskSuspended( pxTCB ) != pdFALSE )
1083  			{
1084  				traceTASK_RESUME_FROM_ISR( pxTCB );
1085  				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
1086  				{
1087  					if( pxTCB-&gt;uxPriority &gt;= pxCurrentTCB-&gt;uxPriority )
1088  					{
1089  						xYieldRequired = pdTRUE;
1090  					}
1091  					else
1092  					{
1093  						mtCOVERAGE_TEST_MARKER();
1094  					}
1095  					( void ) uxListRemove( &amp;( pxTCB-&gt;xStateListItem ) );
1096  					prvAddTaskToReadyList( pxTCB );
1097  				}
1098  				else
1099  				{
1100  					vListInsertEnd( &amp;( xPendingReadyList ), &amp;( pxTCB-&gt;xEventListItem ) );
1101  				}
1102  			}
1103  			else
1104  			{
1105  				mtCOVERAGE_TEST_MARKER();
1106  			}
1107  		}
1108  		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
1109  		return xYieldRequired;
1110  	}
1111  #endif &amp;bsol;* ( ( INCLUDE_xTaskResumeFromISR == 1 ) &amp;&amp; ( INCLUDE_vTaskSuspend == 1 ) ) */
1112  void vTaskStartScheduler( void )
1113  {
1114  BaseType_t xReturn;
1115  	#if( configSUPPORT_STATIC_ALLOCATION == 1 )
1116  	{
1117  		StaticTask_t *pxIdleTaskTCBBuffer = NULL;
1118  		StackType_t *pxIdleTaskStackBuffer = NULL;
1119  		uint32_t ulIdleTaskStackSize;
1120  		vApplicationGetIdleTaskMemory( &amp;pxIdleTaskTCBBuffer, &amp;pxIdleTaskStackBuffer, &amp;ulIdleTaskStackSize );
1121  		xIdleTaskHandle = xTaskCreateStatic(	prvIdleTask,
1122  												configIDLE_TASK_NAME,
1123  												ulIdleTaskStackSize,
1124  												( void * ) NULL, &amp;bsol;*lint !e961.  The cast is not redundant for all compilers. */
1125  												( tskIDLE_PRIORITY | portPRIVILEGE_BIT ),
1126  												pxIdleTaskStackBuffer,
1127  												pxIdleTaskTCBBuffer ); &amp;bsol;*lint !e961 MISRA exception, justified as it is not a redundant explicit cast to all supported compilers. */
1128  		if( xIdleTaskHandle != NULL )
1129  		{
1130  			xReturn = pdPASS;
1131  		}
1132  		else
1133  		{
1134  			xReturn = pdFAIL;
1135  		}
1136  	}
1137  	#else
1138  	{
1139  		xReturn = xTaskCreate(	prvIdleTask,
1140  								configIDLE_TASK_NAME,
1141  								configMINIMAL_STACK_SIZE,
1142  								( void * ) NULL,
1143  								( tskIDLE_PRIORITY | portPRIVILEGE_BIT ),
1144  								&amp;xIdleTaskHandle ); &amp;bsol;*lint !e961 MISRA exception, justified as it is not a redundant explicit cast to all supported compilers. */
1145  	}
1146  	#endif &amp;bsol;* configSUPPORT_STATIC_ALLOCATION */
1147  	#if ( configUSE_TIMERS == 1 )
1148  	{
1149  		if( xReturn == pdPASS )
1150  		{
1151  			xReturn = xTimerCreateTimerTask();
1152  		}
1153  		else
1154  		{
1155  			mtCOVERAGE_TEST_MARKER();
1156  		}
1157  	}
1158  	#endif &amp;bsol;* configUSE_TIMERS */
1159  	if( xReturn == pdPASS )
1160  	{
1161  		#ifdef FREERTOS_TASKS_C_ADDITIONS_INIT
1162  		{
1163  			freertos_tasks_c_additions_init();
1164  		}
1165  		#endif
1166  		portDISABLE_INTERRUPTS();
1167  		#if ( configUSE_NEWLIB_REENTRANT == 1 )
1168  		{
1169  			_impure_ptr = &amp;( pxCurrentTCB-&gt;xNewLib_reent );
1170  		}
1171  		#endif &amp;bsol;* configUSE_NEWLIB_REENTRANT */
1172  		xNextTaskUnblockTime = portMAX_DELAY;
1173  		xSchedulerRunning = pdTRUE;
1174  		xTickCount = ( TickType_t ) 0U;
1175  		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();
1176  		if( xPortStartScheduler() != pdFALSE )
1177  		{
1178  		}
1179  		else
1180  		{
1181  		}
1182  	}
1183  	else
1184  	{
1185  		configASSERT( xReturn != errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY );
1186  	}
1187  	( void ) xIdleTaskHandle;
1188  }
1189  void vTaskEndScheduler( void )
1190  {
1191  	portDISABLE_INTERRUPTS();
1192  	xSchedulerRunning = pdFALSE;
1193  	vPortEndScheduler();
1194  }
1195  void vTaskSuspendAll( void )
1196  {
1197  	++uxSchedulerSuspended;
1198  }
1199  #if ( configUSE_TICKLESS_IDLE != 0 )
1200  	static TickType_t prvGetExpectedIdleTime( void )
1201  	{
1202  	TickType_t xReturn;
1203  	UBaseType_t uxHigherPriorityReadyTasks = pdFALSE;
1204  		#if( configUSE_PORT_OPTIMISED_TASK_SELECTION == 0 )
1205  		{
1206  			if( uxTopReadyPriority &gt; tskIDLE_PRIORITY )
1207  			{
1208  				uxHigherPriorityReadyTasks = pdTRUE;
1209  			}
1210  		}
1211  		#else
1212  		{
1213  			const UBaseType_t uxLeastSignificantBit = ( UBaseType_t ) 0x01;
1214  			if( uxTopReadyPriority &gt; uxLeastSignificantBit )
1215  			{
1216  				uxHigherPriorityReadyTasks = pdTRUE;
1217  			}
1218  		}
1219  		#endif
1220  		if( pxCurrentTCB-&gt;uxPriority &gt; tskIDLE_PRIORITY )
1221  		{
1222  			xReturn = 0;
1223  		}
1224  		else if( listCURRENT_LIST_LENGTH( &amp;( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) &gt; 1 )
1225  		{
1226  			xReturn = 0;
1227  		}
1228  		else if( uxHigherPriorityReadyTasks != pdFALSE )
1229  		{
1230  			xReturn = 0;
1231  		}
1232  		else
1233  		{
1234  			xReturn = xNextTaskUnblockTime - xTickCount;
1235  		}
1236  		return xReturn;
1237  	}
1238  #endif &amp;bsol;* configUSE_TICKLESS_IDLE */
1239  BaseType_t xTaskResumeAll( void )
1240  {
1241  TCB_t *pxTCB = NULL;
1242  BaseType_t xAlreadyYielded = pdFALSE;
1243  	configASSERT( uxSchedulerSuspended );
1244  	taskENTER_CRITICAL();
1245  	{
1246  		--uxSchedulerSuspended;
1247  		if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
1248  		{
1249  			if( uxCurrentNumberOfTasks &gt; ( UBaseType_t ) 0U )
1250  			{
1251  				while( listLIST_IS_EMPTY( &amp;xPendingReadyList ) == pdFALSE )
1252  				{
1253  					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( ( &amp;xPendingReadyList ) );
1254  					( void ) uxListRemove( &amp;( pxTCB-&gt;xEventListItem ) );
1255  					( void ) uxListRemove( &amp;( pxTCB-&gt;xStateListItem ) );
1256  					prvAddTaskToReadyList( pxTCB );
1257  					if( pxTCB-&gt;uxPriority &gt;= pxCurrentTCB-&gt;uxPriority )
1258  					{
1259  						xYieldPending = pdTRUE;
1260  					}
1261  					else
1262  					{
1263  						mtCOVERAGE_TEST_MARKER();
1264  					}
1265  				}
1266  				if( pxTCB != NULL )
1267  				{
1268  					prvResetNextTaskUnblockTime();
1269  				}
1270  				{
1271  					UBaseType_t uxPendedCounts = uxPendedTicks; &amp;bsol;* Non-volatile copy. */
1272  					if( uxPendedCounts &gt; ( UBaseType_t ) 0U )
1273  					{
1274  						do
1275  						{
1276  							if( xTaskIncrementTick() != pdFALSE )
1277  							{
1278  								xYieldPending = pdTRUE;
1279  							}
1280  							else
1281  							{
1282  								mtCOVERAGE_TEST_MARKER();
1283  							}
1284  							--uxPendedCounts;
1285  						} while( uxPendedCounts &gt; ( UBaseType_t ) 0U );
1286  						uxPendedTicks = 0;
1287  					}
1288  					else
1289  					{
1290  						mtCOVERAGE_TEST_MARKER();
1291  					}
1292  				}
1293  				if( xYieldPending != pdFALSE )
1294  				{
1295  					#if( configUSE_PREEMPTION != 0 )
1296  					{
1297  						xAlreadyYielded = pdTRUE;
1298  					}
1299  					#endif
1300  					taskYIELD_IF_USING_PREEMPTION();
1301  				}
1302  				else
1303  				{
1304  					mtCOVERAGE_TEST_MARKER();
1305  				}
1306  			}
1307  		}
1308  		else
1309  		{
1310  			mtCOVERAGE_TEST_MARKER();
1311  		}
1312  	}
1313  	taskEXIT_CRITICAL();
1314  	return xAlreadyYielded;
1315  }
1316  TickType_t xTaskGetTickCount( void )
1317  {
1318  TickType_t xTicks;
1319  	portTICK_TYPE_ENTER_CRITICAL();
1320  	{
1321  		xTicks = xTickCount;
1322  	}
1323  	portTICK_TYPE_EXIT_CRITICAL();
1324  	return xTicks;
1325  }
1326  TickType_t xTaskGetTickCountFromISR( void )
1327  {
1328  TickType_t xReturn;
1329  UBaseType_t uxSavedInterruptStatus;
1330  	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
1331  	uxSavedInterruptStatus = portTICK_TYPE_SET_INTERRUPT_MASK_FROM_ISR();
1332  	{
1333  		xReturn = xTickCount;
1334  	}
1335  	portTICK_TYPE_CLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
1336  	return xReturn;
1337  }
1338  UBaseType_t uxTaskGetNumberOfTasks( void )
1339  {
1340  	return uxCurrentNumberOfTasks;
1341  }
1342  char *pcTaskGetName( TaskHandle_t xTaskToQuery ) &amp;bsol;*lint !e971 Unqualified char types are allowed for strings and single characters only. */
1343  {
1344  TCB_t *pxTCB;
1345  	pxTCB = prvGetTCBFromHandle( xTaskToQuery );
1346  	configASSERT( pxTCB );
1347  	return &amp;( pxTCB-&gt;pcTaskName[ 0 ] );
1348  }
1349  #if ( INCLUDE_xTaskGetHandle == 1 )
1350  	static TCB_t *prvSearchForNameWithinSingleList( List_t *pxList, const char pcNameToQuery[] )
1351  	{
1352  	TCB_t *pxNextTCB, *pxFirstTCB, *pxReturn = NULL;
1353  	UBaseType_t x;
1354  	char cNextChar;
1355  		if( listCURRENT_LIST_LENGTH( pxList ) &gt; ( UBaseType_t ) 0 )
1356  		{
1357  			listGET_OWNER_OF_NEXT_ENTRY( pxFirstTCB, pxList );
1358  			do
1359  			{
1360  				listGET_OWNER_OF_NEXT_ENTRY( pxNextTCB, pxList );
1361  				for( x = ( UBaseType_t ) 0; x &lt; ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
1362  				{
1363  					cNextChar = pxNextTCB-&gt;pcTaskName[ x ];
1364  					if( cNextChar != pcNameToQuery[ x ] )
1365  					{
1366  						break;
1367  					}
1368  					else if( cNextChar == 0x00 )
1369  					{
1370  						pxReturn = pxNextTCB;
1371  						break;
1372  					}
1373  					else
1374  					{
1375  						mtCOVERAGE_TEST_MARKER();
1376  					}
1377  				}
1378  				if( pxReturn != NULL )
1379  				{
1380  					break;
1381  				}
1382  			} while( pxNextTCB != pxFirstTCB );
1383  		}
1384  		else
1385  		{
1386  			mtCOVERAGE_TEST_MARKER();
1387  		}
1388  		return pxReturn;
1389  	}
1390  #endif &amp;bsol;* INCLUDE_xTaskGetHandle */
1391  #if ( INCLUDE_xTaskGetHandle == 1 )
1392  	TaskHandle_t xTaskGetHandle( const char *pcNameToQuery ) &amp;bsol;*lint !e971 Unqualified char types are allowed for strings and single characters only. */
1393  	{
1394  	UBaseType_t uxQueue = configMAX_PRIORITIES;
1395  	TCB_t* pxTCB;
1396  		configASSERT( strlen( pcNameToQuery ) &lt; configMAX_TASK_NAME_LEN );
1397  		vTaskSuspendAll();
1398  		{
1399  			do
1400  			{
1401  				uxQueue--;
1402  				pxTCB = prvSearchForNameWithinSingleList( ( List_t * ) &amp;( pxReadyTasksLists[ uxQueue ] ), pcNameToQuery );
1403  				if( pxTCB != NULL )
1404  				{
1405  					break;
1406  				}
1407  			} while( uxQueue &gt; ( UBaseType_t ) tskIDLE_PRIORITY ); &amp;bsol;*lint !e961 MISRA exception as the casts are only redundant for some ports. */
1408  			if( pxTCB == NULL )
1409  			{
1410  				pxTCB = prvSearchForNameWithinSingleList( ( List_t * ) pxDelayedTaskList, pcNameToQuery );
1411  			}
1412  			if( pxTCB == NULL )
1413  			{
1414  				pxTCB = prvSearchForNameWithinSingleList( ( List_t * ) pxOverflowDelayedTaskList, pcNameToQuery );
1415  			}
1416  			#if ( INCLUDE_vTaskSuspend == 1 )
1417  			{
1418  				if( pxTCB == NULL )
1419  				{
1420  					pxTCB = prvSearchForNameWithinSingleList( &amp;xSuspendedTaskList, pcNameToQuery );
1421  				}
1422  			}
1423  			#endif
1424  			#if( INCLUDE_vTaskDelete == 1 )
1425  			{
1426  				if( pxTCB == NULL )
1427  				{
1428  					pxTCB = prvSearchForNameWithinSingleList( &amp;xTasksWaitingTermination, pcNameToQuery );
1429  				}
1430  			}
1431  			#endif
1432  		}
1433  		( void ) xTaskResumeAll();
1434  		return ( TaskHandle_t ) pxTCB;
1435  	}
1436  #endif &amp;bsol;* INCLUDE_xTaskGetHandle */
1437  #if ( configUSE_TRACE_FACILITY == 1 )
1438  	UBaseType_t uxTaskGetSystemState( TaskStatus_t * const pxTaskStatusArray, const UBaseType_t uxArraySize, uint32_t * const pulTotalRunTime )
1439  	{
1440  	UBaseType_t uxTask = 0, uxQueue = configMAX_PRIORITIES;
1441  		vTaskSuspendAll();
1442  		{
1443  			if( uxArraySize &gt;= uxCurrentNumberOfTasks )
1444  			{
1445  				do
1446  				{
1447  					uxQueue--;
1448  					uxTask += prvListTasksWithinSingleList( &amp;( pxTaskStatusArray[ uxTask ] ), &amp;( pxReadyTasksLists[ uxQueue ] ), eReady );
1449  				} while( uxQueue &gt; ( UBaseType_t ) tskIDLE_PRIORITY ); &amp;bsol;*lint !e961 MISRA exception as the casts are only redundant for some ports. */
1450  				uxTask += prvListTasksWithinSingleList( &amp;( pxTaskStatusArray[ uxTask ] ), ( List_t * ) pxDelayedTaskList, eBlocked );
1451  				uxTask += prvListTasksWithinSingleList( &amp;( pxTaskStatusArray[ uxTask ] ), ( List_t * ) pxOverflowDelayedTaskList, eBlocked );
1452  				#if( INCLUDE_vTaskDelete == 1 )
1453  				{
1454  					uxTask += prvListTasksWithinSingleList( &amp;( pxTaskStatusArray[ uxTask ] ), &amp;xTasksWaitingTermination, eDeleted );
1455  				}
1456  				#endif
1457  				#if ( INCLUDE_vTaskSuspend == 1 )
1458  				{
1459  					uxTask += prvListTasksWithinSingleList( &amp;( pxTaskStatusArray[ uxTask ] ), &amp;xSuspendedTaskList, eSuspended );
1460  				}
1461  				#endif
1462  				#if ( configGENERATE_RUN_TIME_STATS == 1)
1463  				{
1464  					if( pulTotalRunTime != NULL )
1465  					{
1466  						#ifdef portALT_GET_RUN_TIME_COUNTER_VALUE
1467  							portALT_GET_RUN_TIME_COUNTER_VALUE( ( *pulTotalRunTime ) );
1468  						#else
1469  							*pulTotalRunTime = portGET_RUN_TIME_COUNTER_VALUE();
1470  						#endif
1471  					}
1472  				}
1473  				#else
1474  				{
1475  					if( pulTotalRunTime != NULL )
1476  					{
1477  						*pulTotalRunTime = 0;
1478  					}
1479  				}
1480  				#endif
1481  			}
1482  			else
1483  			{
1484  				mtCOVERAGE_TEST_MARKER();
1485  			}
1486  		}
1487  		( void ) xTaskResumeAll();
1488  		return uxTask;
1489  	}
1490  #endif &amp;bsol;* configUSE_TRACE_FACILITY */
1491  #if ( INCLUDE_xTaskGetIdleTaskHandle == 1 )
1492  	TaskHandle_t xTaskGetIdleTaskHandle( void )
1493  	{
1494  		configASSERT( ( xIdleTaskHandle != NULL ) );
1495  		return xIdleTaskHandle;
1496  	}
1497  #endif &amp;bsol;* INCLUDE_xTaskGetIdleTaskHandle */
1498  #if ( configUSE_TICKLESS_IDLE != 0 )
1499  	void vTaskStepTick( const TickType_t xTicksToJump )
1500  	{
1501  		configASSERT( ( xTickCount + xTicksToJump ) &lt;= xNextTaskUnblockTime );
1502  		xTickCount += xTicksToJump;
1503  		traceINCREASE_TICK_COUNT( xTicksToJump );
1504  	}
1505  #endif &amp;bsol;* configUSE_TICKLESS_IDLE */
1506  #if ( INCLUDE_xTaskAbortDelay == 1 )
1507  	BaseType_t xTaskAbortDelay( TaskHandle_t xTask )
1508  	{
1509  	TCB_t *pxTCB = ( TCB_t * ) xTask;
1510  	BaseType_t xReturn;
1511  		configASSERT( pxTCB );
1512  		vTaskSuspendAll();
1513  		{
1514  			if( eTaskGetState( xTask ) == eBlocked )
1515  			{
1516  				xReturn = pdPASS;
1517  				( void ) uxListRemove( &amp;( pxTCB-&gt;xStateListItem ) );
1518  				taskENTER_CRITICAL();
1519  				{
1520  					if( listLIST_ITEM_CONTAINER( &amp;( pxTCB-&gt;xEventListItem ) ) != NULL )
1521  					{
1522  						( void ) uxListRemove( &amp;( pxTCB-&gt;xEventListItem ) );
1523  						pxTCB-&gt;ucDelayAborted = pdTRUE;
1524  					}
1525  					else
1526  					{
1527  						mtCOVERAGE_TEST_MARKER();
1528  					}
1529  				}
1530  				taskEXIT_CRITICAL();
1531  				prvAddTaskToReadyList( pxTCB );
1532  				#if (  configUSE_PREEMPTION == 1 )
1533  				{
1534  					if( pxTCB-&gt;uxPriority &gt; pxCurrentTCB-&gt;uxPriority )
1535  					{
1536  						xYieldPending = pdTRUE;
1537  					}
1538  					else
1539  					{
1540  						mtCOVERAGE_TEST_MARKER();
1541  					}
1542  				}
1543  				#endif &amp;bsol;* configUSE_PREEMPTION */
1544  			}
1545  			else
1546  			{
1547  				xReturn = pdFAIL;
1548  			}
1549  		}
1550  		( void ) xTaskResumeAll();
1551  		return xReturn;
1552  	}
1553  #endif &amp;bsol;* INCLUDE_xTaskAbortDelay */
1554  BaseType_t xTaskIncrementTick( void )
1555  {
1556  TCB_t * pxTCB;
1557  TickType_t xItemValue;
1558  BaseType_t xSwitchRequired = pdFALSE;
1559  	traceTASK_INCREMENT_TICK( xTickCount );
1560  	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
1561  	{
1562  		const TickType_t xConstTickCount = xTickCount + ( TickType_t ) 1;
1563  		xTickCount = xConstTickCount;
1564  		if( xConstTickCount == ( TickType_t ) 0U ) &amp;bsol;*lint !e774 &#x27;if&#x27; does not always evaluate to false as it is looking for an overflow. */
1565  		{
1566  			taskSWITCH_DELAYED_LISTS();
1567  		}
1568  		else
1569  		{
1570  			mtCOVERAGE_TEST_MARKER();
1571  		}
1572  		if( xConstTickCount &gt;= xNextTaskUnblockTime )
1573  		{
1574  			for( ;; )
1575  			{
1576  				if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
1577  				{
1578  					xNextTaskUnblockTime = portMAX_DELAY; &amp;bsol;*lint !e961 MISRA exception as the casts are only redundant for some ports. */
1579  					break;
1580  				}
1581  				else
1582  				{
1583  					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
1584  					xItemValue = listGET_LIST_ITEM_VALUE( &amp;( pxTCB-&gt;xStateListItem ) );
1585  					if( xConstTickCount &lt; xItemValue )
1586  					{
1587  						xNextTaskUnblockTime = xItemValue;
1588  						break;
1589  					}
1590  					else
1591  					{
1592  						mtCOVERAGE_TEST_MARKER();
1593  					}
1594  					( void ) uxListRemove( &amp;( pxTCB-&gt;xStateListItem ) );
1595  					if( listLIST_ITEM_CONTAINER( &amp;( pxTCB-&gt;xEventListItem ) ) != NULL )
1596  					{
1597  						( void ) uxListRemove( &amp;( pxTCB-&gt;xEventListItem ) );
1598  					}
1599  					else
1600  					{
1601  						mtCOVERAGE_TEST_MARKER();
1602  					}
1603  					prvAddTaskToReadyList( pxTCB );
1604  					#if (  configUSE_PREEMPTION == 1 )
1605  					{
1606  						if( pxTCB-&gt;uxPriority &gt;= pxCurrentTCB-&gt;uxPriority )
1607  						{
1608  							xSwitchRequired = pdTRUE;
1609  						}
1610  						else
1611  						{
1612  							mtCOVERAGE_TEST_MARKER();
1613  						}
1614  					}
1615  					#endif &amp;bsol;* configUSE_PREEMPTION */
1616  				}
1617  			}
1618  		}
1619  		#if ( ( configUSE_PREEMPTION == 1 ) &amp;&amp; ( configUSE_TIME_SLICING == 1 ) )
1620  		{
1621  			if( listCURRENT_LIST_LENGTH( &amp;( pxReadyTasksLists[ pxCurrentTCB-&gt;uxPriority ] ) ) &gt; ( UBaseType_t ) 1 )
1622  			{
1623  				xSwitchRequired = pdTRUE;
1624  			}
1625  			else
1626  			{
1627  				mtCOVERAGE_TEST_MARKER();
1628  			}
1629  		}
1630  		#endif &amp;bsol;* ( ( configUSE_PREEMPTION == 1 ) &amp;&amp; ( configUSE_TIME_SLICING == 1 ) ) */
1631  		#if ( configUSE_TICK_HOOK == 1 )
1632  		{
1633  			if( uxPendedTicks == ( UBaseType_t ) 0U )
1634  			{
1635  				vApplicationTickHook();
1636  			}
1637  			else
1638  			{
1639  				mtCOVERAGE_TEST_MARKER();
1640  			}
1641  		}
1642  		#endif &amp;bsol;* configUSE_TICK_HOOK */
1643  	}
1644  	else
1645  	{
1646  		++uxPendedTicks;
1647  		#if ( configUSE_TICK_HOOK == 1 )
1648  		{
1649  			vApplicationTickHook();
1650  		}
1651  		#endif
1652  	}
1653  	#if ( configUSE_PREEMPTION == 1 )
1654  	{
1655  		if( xYieldPending != pdFALSE )
1656  		{
1657  			xSwitchRequired = pdTRUE;
1658  		}
1659  		else
1660  		{
1661  			mtCOVERAGE_TEST_MARKER();
1662  		}
1663  	}
1664  	#endif &amp;bsol;* configUSE_PREEMPTION */
1665  	return xSwitchRequired;
1666  }
1667  #if ( configUSE_APPLICATION_TASK_TAG == 1 )
1668  	void vTaskSetApplicationTaskTag( TaskHandle_t xTask, TaskHookFunction_t pxHookFunction )
1669  	{
1670  	TCB_t *xTCB;
1671  		if( xTask == NULL )
1672  		{
1673  			xTCB = ( TCB_t * ) pxCurrentTCB;
1674  		}
1675  		else
1676  		{
1677  			xTCB = ( TCB_t * ) xTask;
1678  		}
1679  		taskENTER_CRITICAL();
1680  			xTCB-&gt;pxTaskTag = pxHookFunction;
1681  		taskEXIT_CRITICAL();
1682  	}
1683  #endif &amp;bsol;* configUSE_APPLICATION_TASK_TAG */
1684  #if ( configUSE_APPLICATION_TASK_TAG == 1 )
1685  	TaskHookFunction_t xTaskGetApplicationTaskTag( TaskHandle_t xTask )
1686  	{
1687  	TCB_t *xTCB;
1688  	TaskHookFunction_t xReturn;
1689  		if( xTask == NULL )
1690  		{
1691  			xTCB = ( TCB_t * ) pxCurrentTCB;
1692  		}
1693  		else
1694  		{
1695  			xTCB = ( TCB_t * ) xTask;
1696  		}
1697  		taskENTER_CRITICAL();
1698  		{
1699  			xReturn = xTCB-&gt;pxTaskTag;
1700  		}
1701  		taskEXIT_CRITICAL();
1702  		return xReturn;
1703  	}
1704  #endif &amp;bsol;* configUSE_APPLICATION_TASK_TAG */
1705  #if ( configUSE_APPLICATION_TASK_TAG == 1 )
1706  	BaseType_t xTaskCallApplicationTaskHook( TaskHandle_t xTask, void *pvParameter )
1707  	{
1708  	TCB_t *xTCB;
1709  	BaseType_t xReturn;
1710  		if( xTask == NULL )
1711  		{
1712  			xTCB = ( TCB_t * ) pxCurrentTCB;
1713  		}
1714  		else
1715  		{
1716  			xTCB = ( TCB_t * ) xTask;
1717  		}
1718  		if( xTCB-&gt;pxTaskTag != NULL )
1719  		{
1720  			xReturn = xTCB-&gt;pxTaskTag( pvParameter );
1721  		}
1722  		else
1723  		{
1724  			xReturn = pdFAIL;
1725  		}
1726  		return xReturn;
1727  	}
1728  #endif &amp;bsol;* configUSE_APPLICATION_TASK_TAG */
1729  void vTaskSwitchContext( void )
1730  {
1731  	if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
1732  	{
1733  		xYieldPending = pdTRUE;
1734  	}
1735  	else
1736  	{
1737  		xYieldPending = pdFALSE;
1738  		traceTASK_SWITCHED_OUT();
1739  		#if ( configGENERATE_RUN_TIME_STATS == 1 )
1740  		{
1741  				#ifdef portALT_GET_RUN_TIME_COUNTER_VALUE
1742  					portALT_GET_RUN_TIME_COUNTER_VALUE( ulTotalRunTime );
1743  				#else
1744  					ulTotalRunTime = portGET_RUN_TIME_COUNTER_VALUE();
1745  				#endif
1746  				if( ulTotalRunTime &gt; ulTaskSwitchedInTime )
1747  				{
1748  					pxCurrentTCB-&gt;ulRunTimeCounter += ( ulTotalRunTime - ulTaskSwitchedInTime );
1749  				}
1750  				else
1751  				{
1752  					mtCOVERAGE_TEST_MARKER();
1753  				}
1754  				ulTaskSwitchedInTime = ulTotalRunTime;
1755  		}
1756  		#endif &amp;bsol;* configGENERATE_RUN_TIME_STATS */
1757  		taskCHECK_FOR_STACK_OVERFLOW();
1758  		taskSELECT_HIGHEST_PRIORITY_TASK();
1759  		traceTASK_SWITCHED_IN();
1760  		#if ( configUSE_NEWLIB_REENTRANT == 1 )
1761  		{
1762  			_impure_ptr = &amp;( pxCurrentTCB-&gt;xNewLib_reent );
1763  		}
1764  		#endif &amp;bsol;* configUSE_NEWLIB_REENTRANT */
1765  	}
1766  }
1767  void vTaskPlaceOnEventList( List_t * const pxEventList, const TickType_t xTicksToWait )
1768  {
1769  	configASSERT( pxEventList );
1770  	vListInsert( pxEventList, &amp;( pxCurrentTCB-&gt;xEventListItem ) );
1771  	prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
1772  }
1773  void vTaskPlaceOnUnorderedEventList( List_t * pxEventList, const TickType_t xItemValue, const TickType_t xTicksToWait )
1774  {
1775  	configASSERT( pxEventList );
1776  	configASSERT( uxSchedulerSuspended != 0 );
1777  	listSET_LIST_ITEM_VALUE( &amp;( pxCurrentTCB-&gt;xEventListItem ), xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
1778  	vListInsertEnd( pxEventList, &amp;( pxCurrentTCB-&gt;xEventListItem ) );
1779  	prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
1780  }
1781  #if( configUSE_TIMERS == 1 )
1782  	void vTaskPlaceOnEventListRestricted( List_t * const pxEventList, TickType_t xTicksToWait, const BaseType_t xWaitIndefinitely )
1783  	{
1784  		configASSERT( pxEventList );
1785  		vListInsertEnd( pxEventList, &amp;( pxCurrentTCB-&gt;xEventListItem ) );
1786  		if( xWaitIndefinitely != pdFALSE )
1787  		{
1788  			xTicksToWait = portMAX_DELAY;
1789  		}
1790  		traceTASK_DELAY_UNTIL( ( xTickCount + xTicksToWait ) );
1791  		prvAddCurrentTaskToDelayedList( xTicksToWait, xWaitIndefinitely );
1792  	}
1793  #endif &amp;bsol;* configUSE_TIMERS */
1794  BaseType_t xTaskRemoveFromEventList( const List_t * const pxEventList )
1795  {
1796  TCB_t *pxUnblockedTCB;
1797  BaseType_t xReturn;
1798  	pxUnblockedTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
1799  	configASSERT( pxUnblockedTCB );
1800  	( void ) uxListRemove( &amp;( pxUnblockedTCB-&gt;xEventListItem ) );
1801  	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
1802  	{
1803  		( void ) uxListRemove( &amp;( pxUnblockedTCB-&gt;xStateListItem ) );
1804  		prvAddTaskToReadyList( pxUnblockedTCB );
1805  	}
1806  	else
1807  	{
1808  		vListInsertEnd( &amp;( xPendingReadyList ), &amp;( pxUnblockedTCB-&gt;xEventListItem ) );
1809  	}
1810  	if( pxUnblockedTCB-&gt;uxPriority &gt; pxCurrentTCB-&gt;uxPriority )
1811  	{
1812  		xReturn = pdTRUE;
1813  		xYieldPending = pdTRUE;
1814  	}
1815  	else
1816  	{
1817  		xReturn = pdFALSE;
1818  	}
1819  	#if( configUSE_TICKLESS_IDLE != 0 )
1820  	{
1821  		prvResetNextTaskUnblockTime();
1822  	}
1823  	#endif
1824  	return xReturn;
1825  }
1826  void vTaskRemoveFromUnorderedEventList( ListItem_t * pxEventListItem, const TickType_t xItemValue )
1827  {
1828  TCB_t *pxUnblockedTCB;
1829  	configASSERT( uxSchedulerSuspended != pdFALSE );
1830  	listSET_LIST_ITEM_VALUE( pxEventListItem, xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
1831  	pxUnblockedTCB = ( TCB_t * ) listGET_LIST_ITEM_OWNER( pxEventListItem );
1832  	configASSERT( pxUnblockedTCB );
1833  	( void ) uxListRemove( pxEventListItem );
1834  	( void ) uxListRemove( &amp;( pxUnblockedTCB-&gt;xStateListItem ) );
1835  	prvAddTaskToReadyList( pxUnblockedTCB );
1836  	if( pxUnblockedTCB-&gt;uxPriority &gt; pxCurrentTCB-&gt;uxPriority )
1837  	{
1838  		xYieldPending = pdTRUE;
1839  	}
1840  }
1841  void vTaskSetTimeOutState( TimeOut_t * const pxTimeOut )
1842  {
1843  	configASSERT( pxTimeOut );
1844  	taskENTER_CRITICAL();
1845  	{
1846  		pxTimeOut-&gt;xOverflowCount = xNumOfOverflows;
1847  		pxTimeOut-&gt;xTimeOnEntering = xTickCount;
1848  	}
1849  	taskEXIT_CRITICAL();
1850  }
1851  void vTaskInternalSetTimeOutState( TimeOut_t * const pxTimeOut )
1852  {
1853  	pxTimeOut-&gt;xOverflowCount = xNumOfOverflows;
1854  	pxTimeOut-&gt;xTimeOnEntering = xTickCount;
1855  }
1856  BaseType_t xTaskCheckForTimeOut( TimeOut_t * const pxTimeOut, TickType_t * const pxTicksToWait )
1857  {
1858  BaseType_t xReturn;
1859  	configASSERT( pxTimeOut );
1860  	configASSERT( pxTicksToWait );
1861  	taskENTER_CRITICAL();
1862  	{
1863  		const TickType_t xConstTickCount = xTickCount;
1864  		const TickType_t xElapsedTime = xConstTickCount - pxTimeOut-&gt;xTimeOnEntering;
1865  		#if( INCLUDE_xTaskAbortDelay == 1 )
1866  			if( pxCurrentTCB-&gt;ucDelayAborted != pdFALSE )
1867  			{
1868  				pxCurrentTCB-&gt;ucDelayAborted = pdFALSE;
1869  				xReturn = pdTRUE;
1870  			}
1871  			else
1872  		#endif
1873  		#if ( INCLUDE_vTaskSuspend == 1 )
1874  			if( *pxTicksToWait == portMAX_DELAY )
1875  			{
1876  				xReturn = pdFALSE;
1877  			}
1878  			else
1879  		#endif
1880  		if( ( xNumOfOverflows != pxTimeOut-&gt;xOverflowCount ) &amp;&amp; ( xConstTickCount &gt;= pxTimeOut-&gt;xTimeOnEntering ) ) &amp;bsol;*lint !e525 Indentation preferred as is to make code within pre-processor directives clearer. */
1881  		{
1882  			xReturn = pdTRUE;
1883  		}
1884  		else if( xElapsedTime &lt; *pxTicksToWait ) &amp;bsol;*lint !e961 Explicit casting is only redundant with some compilers, whereas others require it to prevent integer conversion errors. */
1885  		{
1886  			*pxTicksToWait -= xElapsedTime;
1887  			vTaskInternalSetTimeOutState( pxTimeOut );
1888  			xReturn = pdFALSE;
1889  		}
1890  		else
1891  		{
1892  			*pxTicksToWait = 0;
1893  			xReturn = pdTRUE;
1894  		}
1895  	}
1896  	taskEXIT_CRITICAL();
1897  	return xReturn;
1898  }
1899  void vTaskMissedYield( void )
1900  {
1901  	xYieldPending = pdTRUE;
1902  }
1903  #if ( configUSE_TRACE_FACILITY == 1 )
1904  	UBaseType_t uxTaskGetTaskNumber( TaskHandle_t xTask )
1905  	{
1906  	UBaseType_t uxReturn;
1907  	TCB_t *pxTCB;
1908  		if( xTask != NULL )
1909  		{
1910  			pxTCB = ( TCB_t * ) xTask;
1911  			uxReturn = pxTCB-&gt;uxTaskNumber;
1912  		}
1913  		else
1914  		{
1915  			uxReturn = 0U;
1916  		}
1917  		return uxReturn;
1918  	}
1919  #endif &amp;bsol;* configUSE_TRACE_FACILITY */
1920  #if ( configUSE_TRACE_FACILITY == 1 )
1921  	void vTaskSetTaskNumber( TaskHandle_t xTask, const UBaseType_t uxHandle )
1922  	{
1923  	TCB_t *pxTCB;
1924  		if( xTask != NULL )
1925  		{
1926  			pxTCB = ( TCB_t * ) xTask;
1927  			pxTCB-&gt;uxTaskNumber = uxHandle;
1928  		}
1929  	}
1930  #endif &amp;bsol;* configUSE_TRACE_FACILITY */
1931  static portTASK_FUNCTION( prvIdleTask, pvParameters )
1932  {
1933  	( void ) pvParameters;
1934  	portTASK_CALLS_SECURE_FUNCTIONS();
1935  	for( ;; )
1936  	{
1937  		prvCheckTasksWaitingTermination();
1938  		#if ( configUSE_PREEMPTION == 0 )
1939  		{
1940  			taskYIELD();
1941  		}
1942  		#endif &amp;bsol;* configUSE_PREEMPTION */
1943  		#if ( ( configUSE_PREEMPTION == 1 ) &amp;&amp; ( configIDLE_SHOULD_YIELD == 1 ) )
1944  		{
1945  			if( listCURRENT_LIST_LENGTH( &amp;( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) &gt; ( UBaseType_t ) 1 )
1946  			{
1947  				taskYIELD();
1948  			}
1949  			else
1950  			{
1951  				mtCOVERAGE_TEST_MARKER();
1952  			}
1953  		}
1954  		#endif &amp;bsol;* ( ( configUSE_PREEMPTION == 1 ) &amp;&amp; ( configIDLE_SHOULD_YIELD == 1 ) ) */
1955  		#if ( configUSE_IDLE_HOOK == 1 )
1956  		{
1957  			extern void vApplicationIdleHook( void );
1958  			vApplicationIdleHook();
1959  		}
1960  		#endif &amp;bsol;* configUSE_IDLE_HOOK */
1961  		#if ( configUSE_TICKLESS_IDLE != 0 )
1962  		{
1963  		TickType_t xExpectedIdleTime;
1964  			xExpectedIdleTime = prvGetExpectedIdleTime();
1965  			if( xExpectedIdleTime &gt;= configEXPECTED_IDLE_TIME_BEFORE_SLEEP )
1966  			{
1967  				vTaskSuspendAll();
1968  				{
1969  					configASSERT( xNextTaskUnblockTime &gt;= xTickCount );
1970  					xExpectedIdleTime = prvGetExpectedIdleTime();
1971  					configPRE_SUPPRESS_TICKS_AND_SLEEP_PROCESSING( xExpectedIdleTime );
1972  					if( xExpectedIdleTime &gt;= configEXPECTED_IDLE_TIME_BEFORE_SLEEP )
1973  					{
1974  						traceLOW_POWER_IDLE_BEGIN();
1975  						portSUPPRESS_TICKS_AND_SLEEP( xExpectedIdleTime );
1976  						traceLOW_POWER_IDLE_END();
1977  					}
1978  					else
1979  					{
1980  						mtCOVERAGE_TEST_MARKER();
1981  					}
1982  				}
1983  				( void ) xTaskResumeAll();
1984  			}
1985  			else
1986  			{
1987  				mtCOVERAGE_TEST_MARKER();
1988  			}
1989  		}
1990  		#endif &amp;bsol;* configUSE_TICKLESS_IDLE */
1991  	}
1992  }
1993  #if( configUSE_TICKLESS_IDLE != 0 )
1994  	eSleepModeStatus eTaskConfirmSleepModeStatus( void )
1995  	{
1996  	const UBaseType_t uxNonApplicationTasks = 1;
1997  	eSleepModeStatus eReturn = eStandardSleep;
1998  		if( listCURRENT_LIST_LENGTH( &amp;xPendingReadyList ) != 0 )
1999  		{
2000  			eReturn = eAbortSleep;
2001  		}
2002  		else if( xYieldPending != pdFALSE )
2003  		{
2004  			eReturn = eAbortSleep;
2005  		}
2006  		else
2007  		{
2008  			if( listCURRENT_LIST_LENGTH( &amp;xSuspendedTaskList ) == ( uxCurrentNumberOfTasks - uxNonApplicationTasks ) )
2009  			{
2010  				eReturn = eNoTasksWaitingTimeout;
2011  			}
2012  			else
2013  			{
2014  				mtCOVERAGE_TEST_MARKER();
2015  			}
2016  		}
2017  		return eReturn;
2018  	}
2019  #endif &amp;bsol;* configUSE_TICKLESS_IDLE */
2020  #if ( configNUM_THREAD_LOCAL_STORAGE_POINTERS != 0 )
2021  	void vTaskSetThreadLocalStoragePointer( TaskHandle_t xTaskToSet, BaseType_t xIndex, void *pvValue )
2022  	{
2023  	TCB_t *pxTCB;
2024  		if( xIndex &lt; configNUM_THREAD_LOCAL_STORAGE_POINTERS )
2025  		{
2026  			pxTCB = prvGetTCBFromHandle( xTaskToSet );
2027  			pxTCB-&gt;pvThreadLocalStoragePointers[ xIndex ] = pvValue;
2028  		}
2029  	}
2030  #endif &amp;bsol;* configNUM_THREAD_LOCAL_STORAGE_POINTERS */
2031  #if ( configNUM_THREAD_LOCAL_STORAGE_POINTERS != 0 )
2032  	void *pvTaskGetThreadLocalStoragePointer( TaskHandle_t xTaskToQuery, BaseType_t xIndex )
2033  	{
2034  	void *pvReturn = NULL;
2035  	TCB_t *pxTCB;
2036  		if( xIndex &lt; configNUM_THREAD_LOCAL_STORAGE_POINTERS )
2037  		{
2038  			pxTCB = prvGetTCBFromHandle( xTaskToQuery );
2039  			pvReturn = pxTCB-&gt;pvThreadLocalStoragePointers[ xIndex ];
2040  		}
2041  		else
2042  		{
2043  			pvReturn = NULL;
2044  		}
2045  		return pvReturn;
2046  	}
2047  #endif &amp;bsol;* configNUM_THREAD_LOCAL_STORAGE_POINTERS */
2048  #if ( portUSING_MPU_WRAPPERS == 1 )
2049  	void vTaskAllocateMPURegions( TaskHandle_t xTaskToModify, const MemoryRegion_t * const xRegions )
2050  	{
2051  	TCB_t *pxTCB;
2052  		pxTCB = prvGetTCBFromHandle( xTaskToModify );
2053  		vPortStoreTaskMPUSettings( &amp;( pxTCB-&gt;xMPUSettings ), xRegions, NULL, 0 );
2054  	}
2055  #endif &amp;bsol;* portUSING_MPU_WRAPPERS */
2056  static void prvInitialiseTaskLists( void )
2057  {
2058  UBaseType_t uxPriority;
2059  	for( uxPriority = ( UBaseType_t ) 0U; uxPriority &lt; ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
2060  	{
2061  		vListInitialise( &amp;( pxReadyTasksLists[ uxPriority ] ) );
2062  	}
2063  	vListInitialise( &amp;xDelayedTaskList1 );
2064  	vListInitialise( &amp;xDelayedTaskList2 );
2065  	vListInitialise( &amp;xPendingReadyList );
2066  	#if ( INCLUDE_vTaskDelete == 1 )
2067  	{
2068  		vListInitialise( &amp;xTasksWaitingTermination );
2069  	}
2070  	#endif &amp;bsol;* INCLUDE_vTaskDelete */
2071  	#if ( INCLUDE_vTaskSuspend == 1 )
2072  	{
2073  		vListInitialise( &amp;xSuspendedTaskList );
2074  	}
2075  	#endif &amp;bsol;* INCLUDE_vTaskSuspend */
2076  	pxDelayedTaskList = &amp;xDelayedTaskList1;
2077  	pxOverflowDelayedTaskList = &amp;xDelayedTaskList2;
2078  }
2079  static void prvCheckTasksWaitingTermination( void )
2080  {
2081  	#if ( INCLUDE_vTaskDelete == 1 )
2082  	{
2083  		TCB_t *pxTCB;
2084  		while( uxDeletedTasksWaitingCleanUp &gt; ( UBaseType_t ) 0U )
2085  		{
2086  			taskENTER_CRITICAL();
2087  			{
2088  				pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( ( &amp;xTasksWaitingTermination ) );
2089  				( void ) uxListRemove( &amp;( pxTCB-&gt;xStateListItem ) );
2090  				--uxCurrentNumberOfTasks;
2091  				--uxDeletedTasksWaitingCleanUp;
2092  			}
2093  			taskEXIT_CRITICAL();
2094  			prvDeleteTCB( pxTCB );
2095  		}
2096  	}
2097  	#endif &amp;bsol;* INCLUDE_vTaskDelete */
2098  }
2099  #if( configUSE_TRACE_FACILITY == 1 )
2100  	void vTaskGetInfo( TaskHandle_t xTask, TaskStatus_t *pxTaskStatus, BaseType_t xGetFreeStackSpace, eTaskState eState )
2101  	{
2102  	TCB_t *pxTCB;
2103  		pxTCB = prvGetTCBFromHandle( xTask );
2104  		pxTaskStatus-&gt;xHandle = ( TaskHandle_t ) pxTCB;
2105  		pxTaskStatus-&gt;pcTaskName = ( const char * ) &amp;( pxTCB-&gt;pcTaskName [ 0 ] );
2106  		pxTaskStatus-&gt;uxCurrentPriority = pxTCB-&gt;uxPriority;
2107  		pxTaskStatus-&gt;pxStackBase = pxTCB-&gt;pxStack;
2108  		pxTaskStatus-&gt;xTaskNumber = pxTCB-&gt;uxTCBNumber;
2109  		#if ( configUSE_MUTEXES == 1 )
2110  		{
2111  			pxTaskStatus-&gt;uxBasePriority = pxTCB-&gt;uxBasePriority;
2112  		}
2113  		#else
2114  		{
2115  			pxTaskStatus-&gt;uxBasePriority = 0;
2116  		}
2117  		#endif
2118  		#if ( configGENERATE_RUN_TIME_STATS == 1 )
2119  		{
2120  			pxTaskStatus-&gt;ulRunTimeCounter = pxTCB-&gt;ulRunTimeCounter;
2121  		}
2122  		#else
2123  		{
2124  			pxTaskStatus-&gt;ulRunTimeCounter = 0;
2125  		}
2126  		#endif
2127  		if( eState != eInvalid )
2128  		{
2129  			if( pxTCB == pxCurrentTCB )
2130  			{
2131  				pxTaskStatus-&gt;eCurrentState = eRunning;
2132  			}
2133  			else
2134  			{
2135  				pxTaskStatus-&gt;eCurrentState = eState;
2136  				#if ( INCLUDE_vTaskSuspend == 1 )
2137  				{
2138  					if( eState == eSuspended )
2139  					{
2140  						vTaskSuspendAll();
2141  						{
2142  							if( listLIST_ITEM_CONTAINER( &amp;( pxTCB-&gt;xEventListItem ) ) != NULL )
2143  							{
2144  								pxTaskStatus-&gt;eCurrentState = eBlocked;
2145  							}
2146  						}
2147  						( void ) xTaskResumeAll();
2148  					}
2149  				}
2150  				#endif &amp;bsol;* INCLUDE_vTaskSuspend */
2151  			}
2152  		}
2153  		else
2154  		{
2155  			pxTaskStatus-&gt;eCurrentState = eTaskGetState( pxTCB );
2156  		}
2157  		if( xGetFreeStackSpace != pdFALSE )
2158  		{
2159  			#if ( portSTACK_GROWTH &gt; 0 )
2160  			{
2161  				pxTaskStatus-&gt;usStackHighWaterMark = prvTaskCheckFreeStackSpace( ( uint8_t * ) pxTCB-&gt;pxEndOfStack );
2162  			}
2163  			#else
2164  			{
2165  				pxTaskStatus-&gt;usStackHighWaterMark = prvTaskCheckFreeStackSpace( ( uint8_t * ) pxTCB-&gt;pxStack );
2166  			}
2167  			#endif
2168  		}
2169  		else
2170  		{
2171  			pxTaskStatus-&gt;usStackHighWaterMark = 0;
2172  		}
2173  	}
2174  #endif &amp;bsol;* configUSE_TRACE_FACILITY */
2175  #if ( configUSE_TRACE_FACILITY == 1 )
2176  	static UBaseType_t prvListTasksWithinSingleList( TaskStatus_t *pxTaskStatusArray, List_t *pxList, eTaskState eState )
2177  	{
2178  	configLIST_VOLATILE TCB_t *pxNextTCB, *pxFirstTCB;
2179  	UBaseType_t uxTask = 0;
2180  		if( listCURRENT_LIST_LENGTH( pxList ) &gt; ( UBaseType_t ) 0 )
2181  		{
2182  			listGET_OWNER_OF_NEXT_ENTRY( pxFirstTCB, pxList );
2183  			do
2184  			{
2185  				listGET_OWNER_OF_NEXT_ENTRY( pxNextTCB, pxList );
2186  				vTaskGetInfo( ( TaskHandle_t ) pxNextTCB, &amp;( pxTaskStatusArray[ uxTask ] ), pdTRUE, eState );
2187  				uxTask++;
2188  			} while( pxNextTCB != pxFirstTCB );
2189  		}
2190  		else
2191  		{
2192  			mtCOVERAGE_TEST_MARKER();
2193  		}
2194  		return uxTask;
2195  	}
2196  #endif &amp;bsol;* configUSE_TRACE_FACILITY */
2197  #if ( ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) )
2198  	static uint16_t prvTaskCheckFreeStackSpace( const uint8_t * pucStackByte )
2199  	{
2200  	uint32_t ulCount = 0U;
2201  		while( *pucStackByte == ( uint8_t ) tskSTACK_FILL_BYTE )
2202  		{
2203  			pucStackByte -= portSTACK_GROWTH;
2204  			ulCount++;
2205  		}
2206  		ulCount /= ( uint32_t ) sizeof( StackType_t ); &amp;bsol;*lint !e961 Casting is not redundant on smaller architectures. */
2207  		return ( uint16_t ) ulCount;
2208  	}
2209  #endif &amp;bsol;* ( ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) ) */
2210  #if ( INCLUDE_uxTaskGetStackHighWaterMark == 1 )
2211  	UBaseType_t uxTaskGetStackHighWaterMark( TaskHandle_t xTask )
2212  	{
2213  	TCB_t *pxTCB;
2214  	uint8_t *pucEndOfStack;
2215  	UBaseType_t uxReturn;
2216  		pxTCB = prvGetTCBFromHandle( xTask );
2217  		#if portSTACK_GROWTH &lt; 0
2218  		{
2219  			pucEndOfStack = ( uint8_t * ) pxTCB-&gt;pxStack;
2220  		}
2221  		#else
2222  		{
2223  			pucEndOfStack = ( uint8_t * ) pxTCB-&gt;pxEndOfStack;
2224  		}
2225  		#endif
2226  		uxReturn = ( UBaseType_t ) prvTaskCheckFreeStackSpace( pucEndOfStack );
2227  		return uxReturn;
2228  	}
2229  #endif &amp;bsol;* INCLUDE_uxTaskGetStackHighWaterMark */
2230  #if (INCLUDE_pxTaskGetStackStart == 1)
2231  	uint8_t* pxTaskGetStackStart( TaskHandle_t xTask)
2232  	{
2233  	    TCB_t *pxTCB;
2234  	    UBaseType_t uxReturn;
2235          (void)uxReturn;
2236  		pxTCB = prvGetTCBFromHandle( xTask );
2237  		return ( uint8_t * ) pxTCB-&gt;pxStack;
2238  	}
2239  #endif &amp;bsol;* INCLUDE_pxTaskGetStackStart */
2240  #if ( INCLUDE_vTaskDelete == 1 )
2241  	static void prvDeleteTCB( TCB_t *pxTCB )
2242  	{
2243  		portCLEAN_UP_TCB( pxTCB );
2244  		#if ( configUSE_NEWLIB_REENTRANT == 1 )
2245  		{
2246  			_reclaim_reent( &amp;( pxTCB-&gt;xNewLib_reent ) );
2247  		}
2248  		#endif &amp;bsol;* configUSE_NEWLIB_REENTRANT */
2249  		#if( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) &amp;&amp; ( configSUPPORT_STATIC_ALLOCATION == 0 ) &amp;&amp; ( portUSING_MPU_WRAPPERS == 0 ) )
2250  		{
2251  			vPortFree( pxTCB-&gt;pxStack );
2252  			vPortFree( pxTCB );
2253  		}
2254  		#elif( tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE != 0 ) &amp;bsol;*lint !e731 Macro has been consolidated for readability reasons. */
2255  		{
<span onclick='openModal()' class='match'>2256  			if( pxTCB-&gt;ucStaticallyAllocated == tskDYNAMICALLY_ALLOCATED_STACK_AND_TCB )
2257  			{
2258  				vPortFree( pxTCB-&gt;pxStack );
2259  				vPortFree( pxTCB );
</span>2260  			}
2261  			else if( pxTCB-&gt;ucStaticallyAllocated == tskSTATICALLY_ALLOCATED_STACK_ONLY )
2262  			{
2263  				vPortFree( pxTCB );
2264  			}
2265  			else
2266  			{
2267  				configASSERT( pxTCB-&gt;ucStaticallyAllocated == tskSTATICALLY_ALLOCATED_STACK_AND_TCB	);
2268  				mtCOVERAGE_TEST_MARKER();
2269  			}
2270  		}
2271  		#endif &amp;bsol;* configSUPPORT_DYNAMIC_ALLOCATION */
2272  	}
2273  #endif &amp;bsol;* INCLUDE_vTaskDelete */
2274  static void prvResetNextTaskUnblockTime( void )
2275  {
2276  TCB_t *pxTCB;
2277  	if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
2278  	{
2279  		xNextTaskUnblockTime = portMAX_DELAY;
2280  	}
2281  	else
2282  	{
2283  		( pxTCB ) = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
2284  		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &amp;( ( pxTCB )-&gt;xStateListItem ) );
2285  	}
2286  }
2287  #if ( ( INCLUDE_xTaskGetCurrentTaskHandle == 1 ) || ( configUSE_MUTEXES == 1 ) )
2288  	TaskHandle_t xTaskGetCurrentTaskHandle( void )
2289  	{
2290  	TaskHandle_t xReturn;
2291  		xReturn = pxCurrentTCB;
2292  		return xReturn;
2293  	}
2294  #endif &amp;bsol;* ( ( INCLUDE_xTaskGetCurrentTaskHandle == 1 ) || ( configUSE_MUTEXES == 1 ) ) */
2295  #if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )
2296  	BaseType_t xTaskGetSchedulerState( void )
2297  	{
2298  	BaseType_t xReturn;
2299  		if( xSchedulerRunning == pdFALSE )
2300  		{
2301  			xReturn = taskSCHEDULER_NOT_STARTED;
2302  		}
2303  		else
2304  		{
2305  			if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
2306  			{
2307  				xReturn = taskSCHEDULER_RUNNING;
2308  			}
2309  			else
2310  			{
2311  				xReturn = taskSCHEDULER_SUSPENDED;
2312  			}
2313  		}
2314  		return xReturn;
2315  	}
2316  #endif &amp;bsol;* ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) ) */
2317  #if ( configUSE_MUTEXES == 1 )
2318  	BaseType_t xTaskPriorityInherit( TaskHandle_t const pxMutexHolder )
2319  	{
2320  	TCB_t * const pxMutexHolderTCB = ( TCB_t * ) pxMutexHolder;
2321  	BaseType_t xReturn = pdFALSE;
2322  		if( pxMutexHolder != NULL )
2323  		{
2324  			if( pxMutexHolderTCB-&gt;uxPriority &lt; pxCurrentTCB-&gt;uxPriority )
2325  			{
2326  				if( ( listGET_LIST_ITEM_VALUE( &amp;( pxMutexHolderTCB-&gt;xEventListItem ) ) &amp; taskEVENT_LIST_ITEM_VALUE_IN_USE ) == 0UL )
2327  				{
2328  					listSET_LIST_ITEM_VALUE( &amp;( pxMutexHolderTCB-&gt;xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB-&gt;uxPriority ); &amp;bsol;*lint !e961 MISRA exception as the casts are only redundant for some ports. */
2329  				}
2330  				else
2331  				{
2332  					mtCOVERAGE_TEST_MARKER();
2333  				}
2334  				if( listIS_CONTAINED_WITHIN( &amp;( pxReadyTasksLists[ pxMutexHolderTCB-&gt;uxPriority ] ), &amp;( pxMutexHolderTCB-&gt;xStateListItem ) ) != pdFALSE )
2335  				{
2336  					if( uxListRemove( &amp;( pxMutexHolderTCB-&gt;xStateListItem ) ) == ( UBaseType_t ) 0 )
2337  					{
2338  						taskRESET_READY_PRIORITY( pxMutexHolderTCB-&gt;uxPriority );
2339  					}
2340  					else
2341  					{
2342  						mtCOVERAGE_TEST_MARKER();
2343  					}
2344  					pxMutexHolderTCB-&gt;uxPriority = pxCurrentTCB-&gt;uxPriority;
2345  					prvReaddTaskToReadyList( pxMutexHolderTCB );
2346  				}
2347  				else
2348  				{
2349  					pxMutexHolderTCB-&gt;uxPriority = pxCurrentTCB-&gt;uxPriority;
2350  				}
2351  				traceTASK_PRIORITY_INHERIT( pxMutexHolderTCB, pxCurrentTCB-&gt;uxPriority );
2352  				xReturn = pdTRUE;
2353  			}
2354  			else
2355  			{
2356  				if( pxMutexHolderTCB-&gt;uxBasePriority &lt; pxCurrentTCB-&gt;uxPriority )
2357  				{
2358  					xReturn = pdTRUE;
2359  				}
2360  				else
2361  				{
2362  					mtCOVERAGE_TEST_MARKER();
2363  				}
2364  			}
2365  		}
2366  		else
2367  		{
2368  			mtCOVERAGE_TEST_MARKER();
2369  		}
2370  		return xReturn;
2371  	}
2372  #endif &amp;bsol;* configUSE_MUTEXES */
2373  #if ( configUSE_MUTEXES == 1 )
2374  	BaseType_t xTaskPriorityDisinherit( TaskHandle_t const pxMutexHolder )
2375  	{
2376  	TCB_t * const pxTCB = ( TCB_t * ) pxMutexHolder;
2377  	BaseType_t xReturn = pdFALSE;
2378  		if( pxMutexHolder != NULL )
2379  		{
2380  			configASSERT( pxTCB == pxCurrentTCB );
2381  			configASSERT( pxTCB-&gt;uxMutexesHeld );
2382  			( pxTCB-&gt;uxMutexesHeld )--;
2383  			if( pxTCB-&gt;uxPriority != pxTCB-&gt;uxBasePriority )
2384  			{
2385  				if( pxTCB-&gt;uxMutexesHeld == ( UBaseType_t ) 0 )
2386  				{
2387  					if( uxListRemove( &amp;( pxTCB-&gt;xStateListItem ) ) == ( UBaseType_t ) 0 )
2388  					{
2389  						taskRESET_READY_PRIORITY( pxTCB-&gt;uxPriority );
2390  					}
2391  					else
2392  					{
2393  						mtCOVERAGE_TEST_MARKER();
2394  					}
2395  					traceTASK_PRIORITY_DISINHERIT( pxTCB, pxTCB-&gt;uxBasePriority );
2396  					pxTCB-&gt;uxPriority = pxTCB-&gt;uxBasePriority;
2397  					listSET_LIST_ITEM_VALUE( &amp;( pxTCB-&gt;xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxTCB-&gt;uxPriority ); &amp;bsol;*lint !e961 MISRA exception as the casts are only redundant for some ports. */
2398  					prvReaddTaskToReadyList( pxTCB );
2399  					xReturn = pdTRUE;
2400  				}
2401  				else
2402  				{
2403  					mtCOVERAGE_TEST_MARKER();
2404  				}
2405  			}
2406  			else
2407  			{
2408  				mtCOVERAGE_TEST_MARKER();
2409  			}
2410  		}
2411  		else
2412  		{
2413  			mtCOVERAGE_TEST_MARKER();
2414  		}
2415  		return xReturn;
2416  	}
2417  #endif &amp;bsol;* configUSE_MUTEXES */
2418  #if ( configUSE_MUTEXES == 1 )
2419  	void vTaskPriorityDisinheritAfterTimeout( TaskHandle_t const pxMutexHolder, UBaseType_t uxHighestPriorityWaitingTask )
2420  	{
2421  	TCB_t * const pxTCB = ( TCB_t * ) pxMutexHolder;
2422  	UBaseType_t uxPriorityUsedOnEntry, uxPriorityToUse;
2423  	const UBaseType_t uxOnlyOneMutexHeld = ( UBaseType_t ) 1;
2424  		if( pxMutexHolder != NULL )
2425  		{
2426  			configASSERT( pxTCB-&gt;uxMutexesHeld );
2427  			if( pxTCB-&gt;uxBasePriority &lt; uxHighestPriorityWaitingTask )
2428  			{
2429  				uxPriorityToUse = uxHighestPriorityWaitingTask;
2430  			}
2431  			else
2432  			{
2433  				uxPriorityToUse = pxTCB-&gt;uxBasePriority;
2434  			}
2435  			if( pxTCB-&gt;uxPriority != uxPriorityToUse )
2436  			{
2437  				if( pxTCB-&gt;uxMutexesHeld == uxOnlyOneMutexHeld )
2438  				{
2439  					configASSERT( pxTCB != pxCurrentTCB );
2440  					traceTASK_PRIORITY_DISINHERIT( pxTCB, pxTCB-&gt;uxBasePriority );
2441  					uxPriorityUsedOnEntry = pxTCB-&gt;uxPriority;
2442  					pxTCB-&gt;uxPriority = uxPriorityToUse;
2443  					if( ( listGET_LIST_ITEM_VALUE( &amp;( pxTCB-&gt;xEventListItem ) ) &amp; taskEVENT_LIST_ITEM_VALUE_IN_USE ) == 0UL )
2444  					{
2445  						listSET_LIST_ITEM_VALUE( &amp;( pxTCB-&gt;xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriorityToUse ); &amp;bsol;*lint !e961 MISRA exception as the casts are only redundant for some ports. */
2446  					}
2447  					else
2448  					{
2449  						mtCOVERAGE_TEST_MARKER();
2450  					}
2451  					if( listIS_CONTAINED_WITHIN( &amp;( pxReadyTasksLists[ uxPriorityUsedOnEntry ] ), &amp;( pxTCB-&gt;xStateListItem ) ) != pdFALSE )
2452  					{
2453  						if( uxListRemove( &amp;( pxTCB-&gt;xStateListItem ) ) == ( UBaseType_t ) 0 )
2454  						{
2455  							taskRESET_READY_PRIORITY( pxTCB-&gt;uxPriority );
2456  						}
2457  						else
2458  						{
2459  							mtCOVERAGE_TEST_MARKER();
2460  						}
2461  						prvAddTaskToReadyList( pxTCB );
2462  					}
2463  					else
2464  					{
2465  						mtCOVERAGE_TEST_MARKER();
2466  					}
2467  				}
2468  				else
2469  				{
2470  					mtCOVERAGE_TEST_MARKER();
2471  				}
2472  			}
2473  			else
2474  			{
2475  				mtCOVERAGE_TEST_MARKER();
2476  			}
2477  		}
2478  		else
2479  		{
2480  			mtCOVERAGE_TEST_MARKER();
2481  		}
2482  	}
2483  #endif &amp;bsol;* configUSE_MUTEXES */
2484  #if ( portCRITICAL_NESTING_IN_TCB == 1 )
2485  	void vTaskEnterCritical( void )
2486  	{
2487  		portDISABLE_INTERRUPTS();
2488  		if( xSchedulerRunning != pdFALSE )
2489  		{
2490  			( pxCurrentTCB-&gt;uxCriticalNesting )++;
2491  			if( pxCurrentTCB-&gt;uxCriticalNesting == 1 )
2492  			{
2493  				portASSERT_IF_IN_ISR();
2494  			}
2495  		}
2496  		else
2497  		{
2498  			mtCOVERAGE_TEST_MARKER();
2499  		}
2500  	}
2501  #endif &amp;bsol;* portCRITICAL_NESTING_IN_TCB */
2502  #if ( portCRITICAL_NESTING_IN_TCB == 1 )
2503  	void vTaskExitCritical( void )
2504  	{
2505  		if( xSchedulerRunning != pdFALSE )
2506  		{
2507  			if( pxCurrentTCB-&gt;uxCriticalNesting &gt; 0U )
2508  			{
2509  				( pxCurrentTCB-&gt;uxCriticalNesting )--;
2510  				if( pxCurrentTCB-&gt;uxCriticalNesting == 0U )
2511  				{
2512  					portENABLE_INTERRUPTS();
2513  				}
2514  				else
2515  				{
2516  					mtCOVERAGE_TEST_MARKER();
2517  				}
2518  			}
2519  			else
2520  			{
2521  				mtCOVERAGE_TEST_MARKER();
2522  			}
2523  		}
2524  		else
2525  		{
2526  			mtCOVERAGE_TEST_MARKER();
2527  		}
2528  	}
2529  #endif &amp;bsol;* portCRITICAL_NESTING_IN_TCB */
2530  #if ( ( configUSE_TRACE_FACILITY == 1 ) &amp;&amp; ( configUSE_STATS_FORMATTING_FUNCTIONS &gt; 0 ) )
2531  	static char *prvWriteNameToBuffer( char *pcBuffer, const char *pcTaskName )
2532  	{
2533  	size_t x;
2534  		strcpy( pcBuffer, pcTaskName );
2535  		for( x = strlen( pcBuffer ); x &lt; ( size_t ) ( configMAX_TASK_NAME_LEN - 1 ); x++ )
2536  		{
2537  			pcBuffer[ x ] = &#x27; &#x27;;
2538  		}
2539  		pcBuffer[ x ] = 0x00;
2540  		return &amp;( pcBuffer[ x ] );
2541  	}
2542  #endif &amp;bsol;* ( configUSE_TRACE_FACILITY == 1 ) &amp;&amp; ( configUSE_STATS_FORMATTING_FUNCTIONS &gt; 0 ) */
2543  #if ( ( configUSE_TRACE_FACILITY == 1 ) &amp;&amp; ( configUSE_STATS_FORMATTING_FUNCTIONS &gt; 0 ) &amp;&amp; ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) )
2544  	void vTaskList( char * pcWriteBuffer )
2545  	{
2546  	TaskStatus_t *pxTaskStatusArray;
2547  	volatile UBaseType_t uxArraySize, x;
2548  	char cStatus;
2549  		*pcWriteBuffer = 0x00;
2550  		uxArraySize = uxCurrentNumberOfTasks;
2551  		pxTaskStatusArray = pvPortMalloc( uxCurrentNumberOfTasks * sizeof( TaskStatus_t ) );
2552  		if( pxTaskStatusArray != NULL )
2553  		{
2554  			uxArraySize = uxTaskGetSystemState( pxTaskStatusArray, uxArraySize, NULL );
2555  			for( x = 0; x &lt; uxArraySize; x++ )
2556  			{
2557  				switch( pxTaskStatusArray[ x ].eCurrentState )
2558  				{
2559  					case eRunning:		cStatus = tskRUNNING_CHAR;
2560  										break;
2561  					case eReady:		cStatus = tskREADY_CHAR;
2562  										break;
2563  					case eBlocked:		cStatus = tskBLOCKED_CHAR;
2564  										break;
2565  					case eSuspended:	cStatus = tskSUSPENDED_CHAR;
2566  										break;
2567  					case eDeleted:		cStatus = tskDELETED_CHAR;
2568  										break;
2569  					default:			&amp;bsol;* Should not get here, but it is included
2570  										to prevent static checking errors. */
2571  										cStatus = 0x00;
2572  										break;
2573  				}
2574  				pcWriteBuffer = prvWriteNameToBuffer( pcWriteBuffer, pxTaskStatusArray[ x ].pcTaskName );
2575  				sprintf( pcWriteBuffer, &quot;\t%c\t%u\t%u\t%u\r\n&quot;, cStatus, ( unsigned int ) pxTaskStatusArray[ x ].uxCurrentPriority, ( unsigned int ) pxTaskStatusArray[ x ].usStackHighWaterMark, ( unsigned int ) pxTaskStatusArray[ x ].xTaskNumber );
2576  				pcWriteBuffer += strlen( pcWriteBuffer );
2577  			}
2578  			vPortFree( pxTaskStatusArray );
2579  		}
2580  		else
2581  		{
2582  			mtCOVERAGE_TEST_MARKER();
2583  		}
2584  	}
2585  #endif &amp;bsol;* ( ( configUSE_TRACE_FACILITY == 1 ) &amp;&amp; ( configUSE_STATS_FORMATTING_FUNCTIONS &gt; 0 ) &amp;&amp; ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) ) */
2586  #if ( ( configGENERATE_RUN_TIME_STATS == 1 ) &amp;&amp; ( configUSE_STATS_FORMATTING_FUNCTIONS &gt; 0 ) &amp;&amp; ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) )
2587  	void vTaskGetRunTimeStats( char *pcWriteBuffer )
2588  	{
2589  	TaskStatus_t *pxTaskStatusArray;
2590  	volatile UBaseType_t uxArraySize, x;
2591  	uint32_t ulTotalTime, ulStatsAsPercentage;
2592  		#if( configUSE_TRACE_FACILITY != 1 )
2593  		{
2594  			#error configUSE_TRACE_FACILITY must also be set to 1 in FreeRTOSConfig.h to use vTaskGetRunTimeStats().
2595  		}
2596  		#endif
2597  		*pcWriteBuffer = 0x00;
2598  		uxArraySize = uxCurrentNumberOfTasks;
2599  		pxTaskStatusArray = pvPortMalloc( uxCurrentNumberOfTasks * sizeof( TaskStatus_t ) );
2600  		if( pxTaskStatusArray != NULL )
2601  		{
2602  			uxArraySize = uxTaskGetSystemState( pxTaskStatusArray, uxArraySize, &amp;ulTotalTime );
2603  			ulTotalTime /= 100UL;
2604  			if( ulTotalTime &gt; 0 )
2605  			{
2606  				for( x = 0; x &lt; uxArraySize; x++ )
2607  				{
2608  					ulStatsAsPercentage = pxTaskStatusArray[ x ].ulRunTimeCounter / ulTotalTime;
2609  					pcWriteBuffer = prvWriteNameToBuffer( pcWriteBuffer, pxTaskStatusArray[ x ].pcTaskName );
2610  					if( ulStatsAsPercentage &gt; 0UL )
2611  					{
2612  						#ifdef portLU_PRINTF_SPECIFIER_REQUIRED
2613  						{
2614  							sprintf( pcWriteBuffer, &quot;\t%lu\t\t%lu%%\r\n&quot;, pxTaskStatusArray[ x ].ulRunTimeCounter, ulStatsAsPercentage );
2615  						}
2616  						#else
2617  						{
2618  							sprintf( pcWriteBuffer, &quot;\t%u\t\t%u%%\r\n&quot;, ( unsigned int ) pxTaskStatusArray[ x ].ulRunTimeCounter, ( unsigned int ) ulStatsAsPercentage );
2619  						}
2620  						#endif
2621  					}
2622  					else
2623  					{
2624  						#ifdef portLU_PRINTF_SPECIFIER_REQUIRED
2625  						{
2626  							sprintf( pcWriteBuffer, &quot;\t%lu\t\t&lt;1%%\r\n&quot;, pxTaskStatusArray[ x ].ulRunTimeCounter );
2627  						}
2628  						#else
2629  						{
2630  							sprintf( pcWriteBuffer, &quot;\t%u\t\t&lt;1%%\r\n&quot;, ( unsigned int ) pxTaskStatusArray[ x ].ulRunTimeCounter );
2631  						}
2632  						#endif
2633  					}
2634  					pcWriteBuffer += strlen( pcWriteBuffer );
2635  				}
2636  			}
2637  			else
2638  			{
2639  				mtCOVERAGE_TEST_MARKER();
2640  			}
2641  			vPortFree( pxTaskStatusArray );
2642  		}
2643  		else
2644  		{
2645  			mtCOVERAGE_TEST_MARKER();
2646  		}
2647  	}
2648  #endif &amp;bsol;* ( ( configGENERATE_RUN_TIME_STATS == 1 ) &amp;&amp; ( configUSE_STATS_FORMATTING_FUNCTIONS &gt; 0 ) &amp;&amp; ( configSUPPORT_STATIC_ALLOCATION == 1 ) ) */
2649  TickType_t uxTaskResetEventItemValue( void )
2650  {
2651  TickType_t uxReturn;
2652  	uxReturn = listGET_LIST_ITEM_VALUE( &amp;( pxCurrentTCB-&gt;xEventListItem ) );
2653  	listSET_LIST_ITEM_VALUE( &amp;( pxCurrentTCB-&gt;xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB-&gt;uxPriority ) ); &amp;bsol;*lint !e961 MISRA exception as the casts are only redundant for some ports. */
2654  	return uxReturn;
2655  }
2656  #if ( configUSE_MUTEXES == 1 )
2657  	void *pvTaskIncrementMutexHeldCount( void )
2658  	{
2659  		if( pxCurrentTCB != NULL )
2660  		{
2661  			( pxCurrentTCB-&gt;uxMutexesHeld )++;
2662  		}
2663  		return pxCurrentTCB;
2664  	}
2665  #endif &amp;bsol;* configUSE_MUTEXES */
2666  #if( configUSE_TASK_NOTIFICATIONS == 1 )
2667  	uint32_t ulTaskNotifyTake( BaseType_t xClearCountOnExit, TickType_t xTicksToWait )
2668  	{
2669  	uint32_t ulReturn;
2670  		taskENTER_CRITICAL();
2671  		{
2672  			if( pxCurrentTCB-&gt;ulNotifiedValue == 0UL )
2673  			{
2674  				pxCurrentTCB-&gt;ucNotifyState = taskWAITING_NOTIFICATION;
2675  				if( xTicksToWait &gt; ( TickType_t ) 0 )
2676  				{
2677  					prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
2678  					traceTASK_NOTIFY_TAKE_BLOCK();
2679  					portYIELD_WITHIN_API();
2680  				}
2681  				else
2682  				{
2683  					mtCOVERAGE_TEST_MARKER();
2684  				}
2685  			}
2686  			else
2687  			{
2688  				mtCOVERAGE_TEST_MARKER();
2689  			}
2690  		}
2691  		taskEXIT_CRITICAL();
2692  		taskENTER_CRITICAL();
2693  		{
2694  			traceTASK_NOTIFY_TAKE();
2695  			ulReturn = pxCurrentTCB-&gt;ulNotifiedValue;
2696  			if( ulReturn != 0UL )
2697  			{
2698  				if( xClearCountOnExit != pdFALSE )
2699  				{
2700  					pxCurrentTCB-&gt;ulNotifiedValue = 0UL;
2701  				}
2702  				else
2703  				{
2704  					pxCurrentTCB-&gt;ulNotifiedValue = ulReturn - ( uint32_t ) 1;
2705  				}
2706  			}
2707  			else
2708  			{
2709  				mtCOVERAGE_TEST_MARKER();
2710  			}
2711  			pxCurrentTCB-&gt;ucNotifyState = taskNOT_WAITING_NOTIFICATION;
2712  		}
2713  		taskEXIT_CRITICAL();
2714  		return ulReturn;
2715  	}
2716  #endif &amp;bsol;* configUSE_TASK_NOTIFICATIONS */
2717  #if( configUSE_TASK_NOTIFICATIONS == 1 )
2718  	BaseType_t xTaskNotifyWait( uint32_t ulBitsToClearOnEntry, uint32_t ulBitsToClearOnExit, uint32_t *pulNotificationValue, TickType_t xTicksToWait )
2719  	{
2720  	BaseType_t xReturn;
2721  		taskENTER_CRITICAL();
2722  		{
2723  			if( pxCurrentTCB-&gt;ucNotifyState != taskNOTIFICATION_RECEIVED )
2724  			{
2725  				pxCurrentTCB-&gt;ulNotifiedValue &amp;= ~ulBitsToClearOnEntry;
2726  				pxCurrentTCB-&gt;ucNotifyState = taskWAITING_NOTIFICATION;
2727  				if( xTicksToWait &gt; ( TickType_t ) 0 )
2728  				{
2729  					prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
2730  					traceTASK_NOTIFY_WAIT_BLOCK();
2731  					portYIELD_WITHIN_API();
2732  				}
2733  				else
2734  				{
2735  					mtCOVERAGE_TEST_MARKER();
2736  				}
2737  			}
2738  			else
2739  			{
2740  				mtCOVERAGE_TEST_MARKER();
2741  			}
2742  		}
2743  		taskEXIT_CRITICAL();
2744  		taskENTER_CRITICAL();
2745  		{
2746  			traceTASK_NOTIFY_WAIT();
2747  			if( pulNotificationValue != NULL )
2748  			{
2749  				*pulNotificationValue = pxCurrentTCB-&gt;ulNotifiedValue;
2750  			}
2751  			if( pxCurrentTCB-&gt;ucNotifyState != taskNOTIFICATION_RECEIVED )
2752  			{
2753  				xReturn = pdFALSE;
2754  			}
2755  			else
2756  			{
2757  				pxCurrentTCB-&gt;ulNotifiedValue &amp;= ~ulBitsToClearOnExit;
2758  				xReturn = pdTRUE;
2759  			}
2760  			pxCurrentTCB-&gt;ucNotifyState = taskNOT_WAITING_NOTIFICATION;
2761  		}
2762  		taskEXIT_CRITICAL();
2763  		return xReturn;
2764  	}
2765  #endif &amp;bsol;* configUSE_TASK_NOTIFICATIONS */
2766  #if( configUSE_TASK_NOTIFICATIONS == 1 )
2767  	BaseType_t xTaskGenericNotify( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t *pulPreviousNotificationValue )
2768  	{
2769  	TCB_t * pxTCB;
2770  	BaseType_t xReturn = pdPASS;
2771  	uint8_t ucOriginalNotifyState;
2772  		configASSERT( xTaskToNotify );
2773  		pxTCB = ( TCB_t * ) xTaskToNotify;
2774  		taskENTER_CRITICAL();
2775  		{
2776  			if( pulPreviousNotificationValue != NULL )
2777  			{
2778  				*pulPreviousNotificationValue = pxTCB-&gt;ulNotifiedValue;
2779  			}
2780  			ucOriginalNotifyState = pxTCB-&gt;ucNotifyState;
2781  			pxTCB-&gt;ucNotifyState = taskNOTIFICATION_RECEIVED;
2782  			switch( eAction )
2783  			{
2784  				case eSetBits	:
2785  					pxTCB-&gt;ulNotifiedValue |= ulValue;
2786  					break;
2787  				case eIncrement	:
2788  					( pxTCB-&gt;ulNotifiedValue )++;
2789  					break;
2790  				case eSetValueWithOverwrite	:
2791  					pxTCB-&gt;ulNotifiedValue = ulValue;
2792  					break;
2793  				case eSetValueWithoutOverwrite :
2794  					if( ucOriginalNotifyState != taskNOTIFICATION_RECEIVED )
2795  					{
2796  						pxTCB-&gt;ulNotifiedValue = ulValue;
2797  					}
2798  					else
2799  					{
2800  						xReturn = pdFAIL;
2801  					}
2802  					break;
2803  				case eNoAction:
2804  					break;
2805  			}
2806  			traceTASK_NOTIFY();
2807  			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
2808  			{
2809  				( void ) uxListRemove( &amp;( pxTCB-&gt;xStateListItem ) );
2810  				prvAddTaskToReadyList( pxTCB );
2811  				configASSERT( listLIST_ITEM_CONTAINER( &amp;( pxTCB-&gt;xEventListItem ) ) == NULL );
2812  				#if( configUSE_TICKLESS_IDLE != 0 )
2813  				{
2814  					prvResetNextTaskUnblockTime();
2815  				}
2816  				#endif
2817  				if( pxTCB-&gt;uxPriority &gt; pxCurrentTCB-&gt;uxPriority )
2818  				{
2819  					taskYIELD_IF_USING_PREEMPTION();
2820  				}
2821  				else
2822  				{
2823  					mtCOVERAGE_TEST_MARKER();
2824  				}
2825  			}
2826  			else
2827  			{
2828  				mtCOVERAGE_TEST_MARKER();
2829  			}
2830  		}
2831  		taskEXIT_CRITICAL();
2832  		return xReturn;
2833  	}
2834  #endif &amp;bsol;* configUSE_TASK_NOTIFICATIONS */
2835  #if( configUSE_TASK_NOTIFICATIONS == 1 )
2836  	BaseType_t xTaskGenericNotifyFromISR( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t *pulPreviousNotificationValue, BaseType_t *pxHigherPriorityTaskWoken )
2837  	{
2838  	TCB_t * pxTCB;
2839  	uint8_t ucOriginalNotifyState;
2840  	BaseType_t xReturn = pdPASS;
2841  	UBaseType_t uxSavedInterruptStatus;
2842  		configASSERT( xTaskToNotify );
2843  		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
2844  		pxTCB = ( TCB_t * ) xTaskToNotify;
2845  		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
2846  		{
2847  			if( pulPreviousNotificationValue != NULL )
2848  			{
2849  				*pulPreviousNotificationValue = pxTCB-&gt;ulNotifiedValue;
2850  			}
2851  			ucOriginalNotifyState = pxTCB-&gt;ucNotifyState;
2852  			pxTCB-&gt;ucNotifyState = taskNOTIFICATION_RECEIVED;
2853  			switch( eAction )
2854  			{
2855  				case eSetBits	:
2856  					pxTCB-&gt;ulNotifiedValue |= ulValue;
2857  					break;
2858  				case eIncrement	:
2859  					( pxTCB-&gt;ulNotifiedValue )++;
2860  					break;
2861  				case eSetValueWithOverwrite	:
2862  					pxTCB-&gt;ulNotifiedValue = ulValue;
2863  					break;
2864  				case eSetValueWithoutOverwrite :
2865  					if( ucOriginalNotifyState != taskNOTIFICATION_RECEIVED )
2866  					{
2867  						pxTCB-&gt;ulNotifiedValue = ulValue;
2868  					}
2869  					else
2870  					{
2871  						xReturn = pdFAIL;
2872  					}
2873  					break;
2874  				case eNoAction :
2875  					break;
2876  			}
2877  			traceTASK_NOTIFY_FROM_ISR();
2878  			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
2879  			{
2880  				configASSERT( listLIST_ITEM_CONTAINER( &amp;( pxTCB-&gt;xEventListItem ) ) == NULL );
2881  				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
2882  				{
2883  					( void ) uxListRemove( &amp;( pxTCB-&gt;xStateListItem ) );
2884  					prvAddTaskToReadyList( pxTCB );
2885  				}
2886  				else
2887  				{
2888  					vListInsertEnd( &amp;( xPendingReadyList ), &amp;( pxTCB-&gt;xEventListItem ) );
2889  				}
2890  				if( pxTCB-&gt;uxPriority &gt; pxCurrentTCB-&gt;uxPriority )
2891  				{
2892  					if( pxHigherPriorityTaskWoken != NULL )
2893  					{
2894  						*pxHigherPriorityTaskWoken = pdTRUE;
2895  					}
2896  					else
2897  					{
2898  						xYieldPending = pdTRUE;
2899  					}
2900  				}
2901  				else
2902  				{
2903  					mtCOVERAGE_TEST_MARKER();
2904  				}
2905  			}
2906  		}
2907  		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
2908  		return xReturn;
2909  	}
2910  #endif &amp;bsol;* configUSE_TASK_NOTIFICATIONS */
2911  #if( configUSE_TASK_NOTIFICATIONS == 1 )
2912  	void vTaskNotifyGiveFromISR( TaskHandle_t xTaskToNotify, BaseType_t *pxHigherPriorityTaskWoken )
2913  	{
2914  	TCB_t * pxTCB;
2915  	uint8_t ucOriginalNotifyState;
2916  	UBaseType_t uxSavedInterruptStatus;
2917  		configASSERT( xTaskToNotify );
2918  		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
2919  		pxTCB = ( TCB_t * ) xTaskToNotify;
2920  		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
2921  		{
2922  			ucOriginalNotifyState = pxTCB-&gt;ucNotifyState;
2923  			pxTCB-&gt;ucNotifyState = taskNOTIFICATION_RECEIVED;
2924  			( pxTCB-&gt;ulNotifiedValue )++;
2925  			traceTASK_NOTIFY_GIVE_FROM_ISR();
2926  			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
2927  			{
2928  				configASSERT( listLIST_ITEM_CONTAINER( &amp;( pxTCB-&gt;xEventListItem ) ) == NULL );
2929  				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
2930  				{
2931  					( void ) uxListRemove( &amp;( pxTCB-&gt;xStateListItem ) );
2932  					prvAddTaskToReadyList( pxTCB );
2933  				}
2934  				else
2935  				{
2936  					vListInsertEnd( &amp;( xPendingReadyList ), &amp;( pxTCB-&gt;xEventListItem ) );
2937  				}
2938  				if( pxTCB-&gt;uxPriority &gt; pxCurrentTCB-&gt;uxPriority )
2939  				{
2940  					if( pxHigherPriorityTaskWoken != NULL )
2941  					{
2942  						*pxHigherPriorityTaskWoken = pdTRUE;
2943  					}
2944  					else
2945  					{
2946  						xYieldPending = pdTRUE;
2947  					}
2948  				}
2949  				else
2950  				{
2951  					mtCOVERAGE_TEST_MARKER();
2952  				}
2953  			}
2954  		}
2955  		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
2956  	}
2957  #endif &amp;bsol;* configUSE_TASK_NOTIFICATIONS */
2958  #if( configUSE_TASK_NOTIFICATIONS == 1 )
2959  	BaseType_t xTaskNotifyStateClear( TaskHandle_t xTask )
2960  	{
2961  	TCB_t *pxTCB;
2962  	BaseType_t xReturn;
2963  		pxTCB = prvGetTCBFromHandle( xTask );
2964  		taskENTER_CRITICAL();
2965  		{
2966  			if( pxTCB-&gt;ucNotifyState == taskNOTIFICATION_RECEIVED )
2967  			{
2968  				pxTCB-&gt;ucNotifyState = taskNOT_WAITING_NOTIFICATION;
2969  				xReturn = pdPASS;
2970  			}
2971  			else
2972  			{
2973  				xReturn = pdFAIL;
2974  			}
2975  		}
2976  		taskEXIT_CRITICAL();
2977  		return xReturn;
2978  	}
2979  #endif &amp;bsol;* configUSE_TASK_NOTIFICATIONS */
2980  static void prvAddCurrentTaskToDelayedList( TickType_t xTicksToWait, const BaseType_t xCanBlockIndefinitely )
2981  {
2982  TickType_t xTimeToWake;
2983  const TickType_t xConstTickCount = xTickCount;
2984  	#if( INCLUDE_xTaskAbortDelay == 1 )
2985  	{
2986  		pxCurrentTCB-&gt;ucDelayAborted = pdFALSE;
2987  	}
2988  	#endif
2989  	if( uxListRemove( &amp;( pxCurrentTCB-&gt;xStateListItem ) ) == ( UBaseType_t ) 0 )
2990  	{
2991  		portRESET_READY_PRIORITY( pxCurrentTCB-&gt;uxPriority, uxTopReadyPriority );
2992  	}
2993  	else
2994  	{
2995  		mtCOVERAGE_TEST_MARKER();
2996  	}
2997  	#if ( INCLUDE_vTaskSuspend == 1 )
2998  	{
2999  		if( ( xTicksToWait == portMAX_DELAY ) &amp;&amp; ( xCanBlockIndefinitely != pdFALSE ) )
3000  		{
3001  			traceMOVED_TASK_TO_SUSPENDED_LIST(pxCurrentTCB);
3002  			vListInsertEnd( &amp;xSuspendedTaskList, &amp;( pxCurrentTCB-&gt;xStateListItem ) );
3003  		}
3004  		else
3005  		{
3006  			xTimeToWake = xConstTickCount + xTicksToWait;
3007  			listSET_LIST_ITEM_VALUE( &amp;( pxCurrentTCB-&gt;xStateListItem ), xTimeToWake );
3008  			if( xTimeToWake &lt; xConstTickCount )
3009  			{
3010  				traceMOVED_TASK_TO_OVERFLOW_DELAYED_LIST();
3011  				vListInsert( pxOverflowDelayedTaskList, &amp;( pxCurrentTCB-&gt;xStateListItem ) );
3012  			}
3013  			else
3014  			{
3015  				traceMOVED_TASK_TO_DELAYED_LIST();
3016  				vListInsert( pxDelayedTaskList, &amp;( pxCurrentTCB-&gt;xStateListItem ) );
3017  				if( xTimeToWake &lt; xNextTaskUnblockTime )
3018  				{
3019  					xNextTaskUnblockTime = xTimeToWake;
3020  				}
3021  				else
3022  				{
3023  					mtCOVERAGE_TEST_MARKER();
3024  				}
3025  			}
3026  		}
3027  	}
3028  	#else &amp;bsol;* INCLUDE_vTaskSuspend */
3029  	{
3030  		xTimeToWake = xConstTickCount + xTicksToWait;
3031  		listSET_LIST_ITEM_VALUE( &amp;( pxCurrentTCB-&gt;xStateListItem ), xTimeToWake );
3032  		if( xTimeToWake &lt; xConstTickCount )
3033  		{
3034  			traceMOVED_TASK_TO_OVERFLOW_DELAYED_LIST();
3035  			vListInsert( pxOverflowDelayedTaskList, &amp;( pxCurrentTCB-&gt;xStateListItem ) );
3036  		}
3037  		else
3038  		{
3039  			traceMOVED_TASK_TO_DELAYED_LIST();
3040  			vListInsert( pxDelayedTaskList, &amp;( pxCurrentTCB-&gt;xStateListItem ) );
3041  			if( xTimeToWake &lt; xNextTaskUnblockTime )
3042  			{
3043  				xNextTaskUnblockTime = xTimeToWake;
3044  			}
3045  			else
3046  			{
3047  				mtCOVERAGE_TEST_MARKER();
3048  			}
3049  		}
3050  		( void ) xCanBlockIndefinitely;
3051  	}
3052  	#endif &amp;bsol;* INCLUDE_vTaskSuspend */
3053  }
3054  #ifdef FREERTOS_MODULE_TEST
3055  	#include &quot;tasks_test_access_functions.h&quot;
3056  #endif
3057  #if( configINCLUDE_FREERTOS_TASK_C_ADDITIONS_H == 1 )
3058  	#include &quot;freertos_tasks_c_additions.h&quot;
3059  	static void freertos_tasks_c_additions_init( void )
3060  	{
3061  		#ifdef FREERTOS_TASKS_C_ADDITIONS_INIT
3062  			FREERTOS_TASKS_C_ADDITIONS_INIT();
3063  		#endif
3064  	}
3065  #endif
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from libpcap-MDEwOlJlcG9zaXRvcnk5NDM1ODg3-flat-pcap-tc.c</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from Adafruit_nRF52_Arduino-MDEwOlJlcG9zaXRvcnk3NDM1NDcyOQ==-flat-tasks.c</div>
                </div>
                <div class="column column_space"><pre><code>339  	if (newIf-&gt;description == NULL)
340  	{
341  		free(newIf-&gt;name);
342  		free(newIf);
</pre></code></div>
                <div class="column column_space"><pre><code>2256  			if( pxTCB-&gt;ucStaticallyAllocated == tskDYNAMICALLY_ALLOCATED_STACK_AND_TCB )
2257  			{
2258  				vPortFree( pxTCB-&gt;pxStack );
2259  				vPortFree( pxTCB );
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    