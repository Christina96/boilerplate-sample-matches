
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 21, <button onclick='openModal()' class='match'>CODE CLONE</button></h2>
        <div class="column">
            <h3>android-gpuimage-plus-MDEwOlJlcG9zaXRvcnk0NjU0NzQxNw==-flat-cgeCommonDefine.h</h3>
            <pre><code>1  &amp;bsol;*
2   * cgeCommonDefine.h
3   *
4   *  Created on: 2013-12-6
5   *      Author: Wang Yang
6   *        Mail: admin@wysaid.org
7   */
8  #ifndef _CGECOMMONDEFINE_H_
9  #define _CGECOMMONDEFINE_H_
10  #include &quot;cgeGlobal.h&quot;
11  #ifndef cgeCheckGLError
12  #ifdef CGE_LOG_ERROR
13  #define cgeCheckGLError(name) _cgeCheckGLError(name, __FILE__, __LINE__);
14  #else
15  #define cgeCheckGLError(name)
16  #endif
17  #endif
18  #ifndef _CGE_GET_MACRO_STRING_HELP
19  #define _CGE_GET_MACRO_STRING_HELP(x) #x
20  #endif
21  #ifndef CGE_GET_MACRO_STRING
22  #define CGE_GET_MACRO_STRING(x) _CGE_GET_MACRO_STRING_HELP(x)
23  #endif
24  #define CGE_FLOATCOMP0(x) (x &lt; 0.001f &amp;&amp; x &gt; -0.001f)
25  #define CGE_UNIFORM_MAX_LEN 32
26  #define CGE_DELETE(p) \
27      do                \
28      {                 \
29          delete p;     \
30          p = NULL;     \
31      } while (0)
32  #define CGE_DELETE_ARR(p) \
33      do                    \
34      {                     \
35          delete[] p;       \
36          p = NULL;         \
37      } while (0)
38  #define CGE_TEXTURE_INPUT_IMAGE_INDEX 0
39  #define CGE_TEXTURE_INPUT_IMAGE GL_TEXTURE0
40  #define CGE_TEXTURE_OUTPUT_IMAGE_INDEX 1
41  #define CGE_TEXTURE_OUTPUT_IMAGE GL_TEXTURE1
42  #define CGE_TEXTURE_START_INDEX 2
43  #define CGE_TEXTURE_START GL_TEXTURE2
44  #ifndef CGE_TEXTURE_PREMULTIPLIED
45  #define CGE_TEXTURE_PREMULTIPLIED 0
46  #endif
47  #ifdef _CGE_SHADER_VERSION_
48  #define CGE_GLES_ATTACH_STRING_L &quot;#version &quot; CGE_GET_MACRO_STRING(_CGE_SHADER_VERSION_) &quot;\n#ifdef GL_ES\nprecision lowp float;\n#endif\n&quot;
49  #define CGE_GLES_ATTACH_STRING_M &quot;#version &quot; CGE_GET_MACRO_STRING(_CGE_SHADER_VERSION_) &quot;\n#ifdef GL_ES\nprecision mediump float;\n#endif\n&quot;
50  #define CGE_GLES_ATTACH_STRING_H &quot;#version &quot; CGE_GET_MACRO_STRING(_CGE_SHADER_VERSION_) &quot;\n#ifdef GL_ES\nprecision highp float;\n#endif\n&quot;
51  #else
52  #define CGE_GLES_ATTACH_STRING_L &quot;#ifdef GL_ES\nprecision lowp float;\n#endif\n&quot;
53  #define CGE_GLES_ATTACH_STRING_M &quot;#ifdef GL_ES\nprecision mediump float;\n#endif\n&quot;
54  #define CGE_GLES_ATTACH_STRING_H &quot;#ifdef GL_ES\nprecision highp float;\n#endif\n&quot;
55  #endif
56  #if defined(_MSC_VER) &amp;&amp; _MSC_VER &lt; 1600
57  #define CGE_SHADER_STRING_PRECISION_L(string) CGE_GLES_ATTACH_STRING_L #string
58  #define CGE_SHADER_STRING_PRECISION_M(string) CGE_GLES_ATTACH_STRING_M #string
59  #define CGE_SHADER_STRING_PRECISION_H(string) CGE_GLES_ATTACH_STRING_H #string
60  #ifndef CGE_SHADER_STRING
61  #define CGE_SHADER_STRING(string) #string
62  #endif
63  #else
64  #define CGE_SHADER_STRING_PRECISION_L(...) CGE_GLES_ATTACH_STRING_L #__VA_ARGS__
65  #define CGE_SHADER_STRING_PRECISION_M(...) CGE_GLES_ATTACH_STRING_M #__VA_ARGS__
66  #define CGE_SHADER_STRING_PRECISION_H(...) CGE_GLES_ATTACH_STRING_H #__VA_ARGS__
67  #ifndef CGE_SHADER_STRING
68  #define CGE_SHADER_STRING(...) #__VA_ARGS__
69  #endif
70  #endif
71  #define CGE_COMMON_CREATE_FUNC(cls, funcName)         \
72      static inline cls* create()                       \
73      {                                                 \
74          cls* instance = new cls();                    \
75          if (!instance-&gt;funcName())                    \
76          {                                             \
77              delete instance;                          \
<span onclick='openModal()' class='match'>78              instance = nullptr;                       \
79              CGE_LOG_ERROR(&quot;create %s failed!&quot;, #cls); \
80          }                                             \
81          return instance;                              \
82      }
83  #define CGE_COMMON_CREATE_FUNC_WITH_PARAM(cls, funcName, paramName, ...) \
</span>84      static inline cls* create(paramName param __VA_ARGS__)               \
85      {                                                                    \
86          cls* instance = new cls();                                       \
87          if (!instance-&gt;funcName(param))                                  \
88          {                                                                \
89              delete instance;                                             \
90              instance = nullptr;                                          \
91              CGE_LOG_ERROR(&quot;create %s failed!&quot;, #cls);                    \
92          }                                                                \
93          return instance;                                                 \
94      }
95  #define CGE_ARRAY_LEN(x) (sizeof(x) / sizeof(*x))
96  #ifdef __cplusplus
97  template &lt;class T, int Len&gt;
98  static inline int cgeArrLen(const T (&amp;v)[Len])
99  {
100      return Len;
101  }
102  template &lt;typename T&gt;
103  static inline void cgeResetValue(T&amp; t)
104  {
105      t = T();
106  }
107  template &lt;typename T, typename... ARGS&gt;
108  static inline void cgeResetValue(T&amp; t, ARGS&amp;... args)
109  {
110      t = T();
111      cgeResetValue(args...);
112  }
113  #define CGE_DELETE_GL_OBJS(func, ...)    \
114      do                                   \
115      {                                    \
116          GLuint objs[] = { __VA_ARGS__ }; \
117          func(cgeArrLen(objs), objs);     \
118          cgeResetValue(__VA_ARGS__);      \
119      } while (0)
120  template &lt;class T&gt;
121  class CGEBlockLimit
122  {
123      CGEBlockLimit&amp; operator=(const CGEBlockLimit&amp; other) { return *this; }
124  public:
125      explicit CGEBlockLimit(const T&amp; _func) :
126          func(_func) {}
127      ~CGEBlockLimit() { func(); }
128  private:
129      const T&amp; func;
130  };
131  template &lt;class T&gt;
132  inline CGEBlockLimit&lt;const T&amp;&gt; ___cgeMakeBlockLimit(const T&amp; f)
133  {
134      return CGEBlockLimit&lt;const T&amp;&gt;(f);
135  }
136  #define __cgeMakeBlockLimit(ARG, ANYSIGN)            \
137      const auto&amp; ANYSIGN = ___cgeMakeBlockLimit(ARG); \
138      (void)ANYSIGN; 
139  #define _cgeMakeBlockLimit(ARG, VAR, LINE) __cgeMakeBlockLimit(ARG, VAR##LINE)
140  #define _cgeMakeBlockLimit_(ARG, VAR, LINE) _cgeMakeBlockLimit(ARG, VAR, LINE)
141  #define cgeMakeBlockLimit(...) _cgeMakeBlockLimit_(__VA_ARGS__, _blockVar, __LINE__)
142  namespace CGE
143  {
144  #ifndef CGE_MIN
145  template &lt;typename Type&gt;
146  inline Type CGE_MIN(Type a, Type b)
147  {
148      return a &lt; b ? a : b;
149  }
150  #endif
151  #ifndef CGE_MAX
152  template &lt;typename Type&gt;
153  inline Type CGE_MAX(Type a, Type b)
154  {
155      return a &gt; b ? a : b;
156  }
157  #endif
158  #ifndef CGE_MID
159  template &lt;typename Type&gt;
160  inline Type CGE_MID(Type n, Type vMin, Type vMax)
161  {
162      if (n &lt; vMin)
163          n = vMin;
164      else if (n &gt; vMax)
165          n = vMax;
166      return n;
167  }
168  #endif
169  #ifndef CGE_MIX
170  template &lt;typename OpType, typename MixType&gt;
171  inline auto CGE_MIX(OpType a, OpType b, MixType value) -&gt; decltype(a - a * value + b * value)
172  {
173      return a - a * value + b * value;
174  }
175  #endif
176  } 
177  extern &quot;C&quot;
178  {
179  #endif
180  typedef const char* const CGEConstString;
181  typedef enum CGEBufferFormat
182  {
183      CGE_FORMAT_RGB_INT8,
184      CGE_FORMAT_RGB_INT16,
185      CGE_FORMAT_RGB_FLOAT32,
186      CGE_FORMAT_RGBA_INT8,
187      CGE_FORMAT_RGBA_INT16,
188      CGE_FORMAT_RGBA_FLOAT32,
189  #ifdef GL_BGR
190      CGE_FORMAT_BGR_INT8,
191      CGE_FORMAT_BGR_INT16,
192      CGE_FORMAT_BGR_FLOAT32,
193  #endif
194  #ifdef GL_BGRA
195      CGE_FORMAT_BGRA_INT8,
196      CGE_FORMAT_BGRA_INT16,
197      CGE_FORMAT_BGRA_FLOAT32,
198  #endif
199  #ifdef GL_LUMINANCE
200      CGE_FORMAT_LUMINANCE, 
201  #endif
202  #ifdef GL_LUMINANCE_ALPHA
203      CGE_FORMAT_LUMINANCE_ALPHA, 
204  #endif
205  } CGEBufferFormat;
206  typedef enum CGETextureBlendMode
207  {
208      CGE_BLEND_MIX,      
209      CGE_BLEND_DISSOLVE, 
210      CGE_BLEND_DARKEN,       
211      CGE_BLEND_MULTIPLY,     
212      CGE_BLEND_COLORBURN,    
213      CGE_BLEND_LINEARBURN,   
214      CGE_BLEND_DARKER_COLOR, 
215      CGE_BLEND_LIGHTEN,      
216      CGE_BLEND_SCREEN,       
217      CGE_BLEND_COLORDODGE,   
218      CGE_BLEND_LINEARDODGE,  
219      CGE_BLEND_LIGHTERCOLOR, 
220      CGE_BLEND_OVERLAY,     
221      CGE_BLEND_SOFTLIGHT,   
222      CGE_BLEND_HARDLIGHT,   
223      CGE_BLEND_VIVIDLIGHT,  
224      CGE_BLEND_LINEARLIGHT, 
225      CGE_BLEND_PINLIGHT,    
226      CGE_BLEND_HARDMIX,     
227      CGE_BLEND_DIFFERENCE, 
228      CGE_BLEND_EXCLUDE,    
229      CGE_BLEND_SUBTRACT,   
230      CGE_BLEND_DIVIDE,     
231      CGE_BLEND_HUE,        
232      CGE_BLEND_SATURATION, 
233      CGE_BLEND_COLOR,      
234      CGE_BLEND_LUMINOSITY, 
235      CGE_BLEND_ADD,     
236      CGE_BLEND_ADDREV,  
237      CGE_BLEND_COLORBW, 
238      CGE_BLEND_TYPE_MAX_NUM 
239  } CGETextureBlendMode;
240  typedef enum CGEGlobalBlendMode
241  {
242      CGEGLOBAL_BLEND_NONE,
243      CGEGLOBAL_BLEND_ALPHA,
244      CGEGLOBAL_BLEND_ALPHA_SEPERATE,
245      CGEGLOBAL_BLEND_ADD,
246      CGEGLOBAL_BLEND_ADD_SEPARATE,
247      CGEGLOBAL_BLEND_ADD_SEPARATE_EXT, 
248      CGEGLOBAL_BLEND_MULTIPLY,
249      CGEGLOBAL_BLEND_MULTIPLY_SEPERATE,
250      CGEGLOBAL_BLEND_SCREEN,
251      CGEGLOBAL_BLEND_SCREEN_EXT,
252  } CGEGlobalBlendMode;
253  const char* cgeGetVersion();
254  void cgePrintGLString(const char*, GLenum);
255  bool _cgeCheckGLError(const char* name, const char* file, int line); 
256  void cgeSetGlobalBlendMode(const CGEGlobalBlendMode mode);
257  void cgeGetDataAndChannelByFormat(CGEBufferFormat fmt, GLenum* dataFmt, GLenum* channelFmt, GLint* channel);
258  #ifdef __cplusplus
259  const char* cgeGetBlendModeName(const CGETextureBlendMode mode, bool withChinese = false);
260  GLuint cgeGenTextureWithBuffer(const void* bufferData, GLint w, GLint h, GLenum channelFmt, GLenum dataFmt, GLint channels = 4, GLint bindID = 0, GLenum texFilter = GL_LINEAR, GLenum texWrap = GL_CLAMP_TO_EDGE);
261  #else
262  const char* cgeGetBlendModeName(const CGETextureBlendMode mode, bool withChinese);
263  GLuint cgeGenTextureWithBuffer(const void* bufferData, GLint w, GLint h, GLenum channelFmt, GLenum dataFmt, GLint channels, GLint bindID, GLenum texFilter, GLenum texWrap);
264  #endif
265  #ifdef __cplusplus
266  }
267  #endif
268  #endif &amp;bsol;* _CGECOMMONDEFINE_H_ */
</code></pre>
        </div>
        <div class="column">
            <h3>android-gpuimage-plus-MDEwOlJlcG9zaXRvcnk0NjU0NzQxNw==-flat-cgeCommonDefine.h</h3>
            <pre><code>1  &amp;bsol;*
2   * cgeCommonDefine.h
3   *
4   *  Created on: 2013-12-6
5   *      Author: Wang Yang
6   *        Mail: admin@wysaid.org
7   */
8  #ifndef _CGECOMMONDEFINE_H_
9  #define _CGECOMMONDEFINE_H_
10  #include &quot;cgeGlobal.h&quot;
11  #ifndef cgeCheckGLError
12  #ifdef CGE_LOG_ERROR
13  #define cgeCheckGLError(name) _cgeCheckGLError(name, __FILE__, __LINE__);
14  #else
15  #define cgeCheckGLError(name)
16  #endif
17  #endif
18  #ifndef _CGE_GET_MACRO_STRING_HELP
19  #define _CGE_GET_MACRO_STRING_HELP(x) #x
20  #endif
21  #ifndef CGE_GET_MACRO_STRING
22  #define CGE_GET_MACRO_STRING(x) _CGE_GET_MACRO_STRING_HELP(x)
23  #endif
24  #define CGE_FLOATCOMP0(x) (x &lt; 0.001f &amp;&amp; x &gt; -0.001f)
25  #define CGE_UNIFORM_MAX_LEN 32
26  #define CGE_DELETE(p) \
27      do                \
28      {                 \
29          delete p;     \
30          p = NULL;     \
31      } while (0)
32  #define CGE_DELETE_ARR(p) \
33      do                    \
34      {                     \
35          delete[] p;       \
36          p = NULL;         \
37      } while (0)
38  #define CGE_TEXTURE_INPUT_IMAGE_INDEX 0
39  #define CGE_TEXTURE_INPUT_IMAGE GL_TEXTURE0
40  #define CGE_TEXTURE_OUTPUT_IMAGE_INDEX 1
41  #define CGE_TEXTURE_OUTPUT_IMAGE GL_TEXTURE1
42  #define CGE_TEXTURE_START_INDEX 2
43  #define CGE_TEXTURE_START GL_TEXTURE2
44  #ifndef CGE_TEXTURE_PREMULTIPLIED
45  #define CGE_TEXTURE_PREMULTIPLIED 0
46  #endif
47  #ifdef _CGE_SHADER_VERSION_
48  #define CGE_GLES_ATTACH_STRING_L &quot;#version &quot; CGE_GET_MACRO_STRING(_CGE_SHADER_VERSION_) &quot;\n#ifdef GL_ES\nprecision lowp float;\n#endif\n&quot;
49  #define CGE_GLES_ATTACH_STRING_M &quot;#version &quot; CGE_GET_MACRO_STRING(_CGE_SHADER_VERSION_) &quot;\n#ifdef GL_ES\nprecision mediump float;\n#endif\n&quot;
50  #define CGE_GLES_ATTACH_STRING_H &quot;#version &quot; CGE_GET_MACRO_STRING(_CGE_SHADER_VERSION_) &quot;\n#ifdef GL_ES\nprecision highp float;\n#endif\n&quot;
51  #else
52  #define CGE_GLES_ATTACH_STRING_L &quot;#ifdef GL_ES\nprecision lowp float;\n#endif\n&quot;
53  #define CGE_GLES_ATTACH_STRING_M &quot;#ifdef GL_ES\nprecision mediump float;\n#endif\n&quot;
54  #define CGE_GLES_ATTACH_STRING_H &quot;#ifdef GL_ES\nprecision highp float;\n#endif\n&quot;
55  #endif
56  #if defined(_MSC_VER) &amp;&amp; _MSC_VER &lt; 1600
57  #define CGE_SHADER_STRING_PRECISION_L(string) CGE_GLES_ATTACH_STRING_L #string
58  #define CGE_SHADER_STRING_PRECISION_M(string) CGE_GLES_ATTACH_STRING_M #string
59  #define CGE_SHADER_STRING_PRECISION_H(string) CGE_GLES_ATTACH_STRING_H #string
60  #ifndef CGE_SHADER_STRING
61  #define CGE_SHADER_STRING(string) #string
62  #endif
63  #else
64  #define CGE_SHADER_STRING_PRECISION_L(...) CGE_GLES_ATTACH_STRING_L #__VA_ARGS__
65  #define CGE_SHADER_STRING_PRECISION_M(...) CGE_GLES_ATTACH_STRING_M #__VA_ARGS__
66  #define CGE_SHADER_STRING_PRECISION_H(...) CGE_GLES_ATTACH_STRING_H #__VA_ARGS__
67  #ifndef CGE_SHADER_STRING
68  #define CGE_SHADER_STRING(...) #__VA_ARGS__
69  #endif
70  #endif
71  #define CGE_COMMON_CREATE_FUNC(cls, funcName)         \
72      static inline cls* create()                       \
73      {                                                 \
74          cls* instance = new cls();                    \
75          if (!instance-&gt;funcName())                    \
76          {                                             \
77              delete instance;                          \
78              instance = nullptr;                       \
79              CGE_LOG_ERROR(&quot;create %s failed!&quot;, #cls); \
80          }                                             \
81          return instance;                              \
82      }
83  #define CGE_COMMON_CREATE_FUNC_WITH_PARAM(cls, funcName, paramName, ...) \
84      static inline cls* create(paramName param __VA_ARGS__)               \
85      {                                                                    \
86          cls* instance = new cls();                                       \
87          if (!instance-&gt;funcName(param))                                  \
88          {                                                                \
89              delete instance;                                             \
<span onclick='openModal()' class='match'>90              instance = nullptr;                                          \
91              CGE_LOG_ERROR(&quot;create %s failed!&quot;, #cls);                    \
92          }                                                                \
93          return instance;                                                 \
94      }
95  #define CGE_ARRAY_LEN(x) (sizeof(x) / sizeof(*x))
</span>96  #ifdef __cplusplus
97  template &lt;class T, int Len&gt;
98  static inline int cgeArrLen(const T (&amp;v)[Len])
99  {
100      return Len;
101  }
102  template &lt;typename T&gt;
103  static inline void cgeResetValue(T&amp; t)
104  {
105      t = T();
106  }
107  template &lt;typename T, typename... ARGS&gt;
108  static inline void cgeResetValue(T&amp; t, ARGS&amp;... args)
109  {
110      t = T();
111      cgeResetValue(args...);
112  }
113  #define CGE_DELETE_GL_OBJS(func, ...)    \
114      do                                   \
115      {                                    \
116          GLuint objs[] = { __VA_ARGS__ }; \
117          func(cgeArrLen(objs), objs);     \
118          cgeResetValue(__VA_ARGS__);      \
119      } while (0)
120  template &lt;class T&gt;
121  class CGEBlockLimit
122  {
123      CGEBlockLimit&amp; operator=(const CGEBlockLimit&amp; other) { return *this; }
124  public:
125      explicit CGEBlockLimit(const T&amp; _func) :
126          func(_func) {}
127      ~CGEBlockLimit() { func(); }
128  private:
129      const T&amp; func;
130  };
131  template &lt;class T&gt;
132  inline CGEBlockLimit&lt;const T&amp;&gt; ___cgeMakeBlockLimit(const T&amp; f)
133  {
134      return CGEBlockLimit&lt;const T&amp;&gt;(f);
135  }
136  #define __cgeMakeBlockLimit(ARG, ANYSIGN)            \
137      const auto&amp; ANYSIGN = ___cgeMakeBlockLimit(ARG); \
138      (void)ANYSIGN; 
139  #define _cgeMakeBlockLimit(ARG, VAR, LINE) __cgeMakeBlockLimit(ARG, VAR##LINE)
140  #define _cgeMakeBlockLimit_(ARG, VAR, LINE) _cgeMakeBlockLimit(ARG, VAR, LINE)
141  #define cgeMakeBlockLimit(...) _cgeMakeBlockLimit_(__VA_ARGS__, _blockVar, __LINE__)
142  namespace CGE
143  {
144  #ifndef CGE_MIN
145  template &lt;typename Type&gt;
146  inline Type CGE_MIN(Type a, Type b)
147  {
148      return a &lt; b ? a : b;
149  }
150  #endif
151  #ifndef CGE_MAX
152  template &lt;typename Type&gt;
153  inline Type CGE_MAX(Type a, Type b)
154  {
155      return a &gt; b ? a : b;
156  }
157  #endif
158  #ifndef CGE_MID
159  template &lt;typename Type&gt;
160  inline Type CGE_MID(Type n, Type vMin, Type vMax)
161  {
162      if (n &lt; vMin)
163          n = vMin;
164      else if (n &gt; vMax)
165          n = vMax;
166      return n;
167  }
168  #endif
169  #ifndef CGE_MIX
170  template &lt;typename OpType, typename MixType&gt;
171  inline auto CGE_MIX(OpType a, OpType b, MixType value) -&gt; decltype(a - a * value + b * value)
172  {
173      return a - a * value + b * value;
174  }
175  #endif
176  } 
177  extern &quot;C&quot;
178  {
179  #endif
180  typedef const char* const CGEConstString;
181  typedef enum CGEBufferFormat
182  {
183      CGE_FORMAT_RGB_INT8,
184      CGE_FORMAT_RGB_INT16,
185      CGE_FORMAT_RGB_FLOAT32,
186      CGE_FORMAT_RGBA_INT8,
187      CGE_FORMAT_RGBA_INT16,
188      CGE_FORMAT_RGBA_FLOAT32,
189  #ifdef GL_BGR
190      CGE_FORMAT_BGR_INT8,
191      CGE_FORMAT_BGR_INT16,
192      CGE_FORMAT_BGR_FLOAT32,
193  #endif
194  #ifdef GL_BGRA
195      CGE_FORMAT_BGRA_INT8,
196      CGE_FORMAT_BGRA_INT16,
197      CGE_FORMAT_BGRA_FLOAT32,
198  #endif
199  #ifdef GL_LUMINANCE
200      CGE_FORMAT_LUMINANCE, 
201  #endif
202  #ifdef GL_LUMINANCE_ALPHA
203      CGE_FORMAT_LUMINANCE_ALPHA, 
204  #endif
205  } CGEBufferFormat;
206  typedef enum CGETextureBlendMode
207  {
208      CGE_BLEND_MIX,      
209      CGE_BLEND_DISSOLVE, 
210      CGE_BLEND_DARKEN,       
211      CGE_BLEND_MULTIPLY,     
212      CGE_BLEND_COLORBURN,    
213      CGE_BLEND_LINEARBURN,   
214      CGE_BLEND_DARKER_COLOR, 
215      CGE_BLEND_LIGHTEN,      
216      CGE_BLEND_SCREEN,       
217      CGE_BLEND_COLORDODGE,   
218      CGE_BLEND_LINEARDODGE,  
219      CGE_BLEND_LIGHTERCOLOR, 
220      CGE_BLEND_OVERLAY,     
221      CGE_BLEND_SOFTLIGHT,   
222      CGE_BLEND_HARDLIGHT,   
223      CGE_BLEND_VIVIDLIGHT,  
224      CGE_BLEND_LINEARLIGHT, 
225      CGE_BLEND_PINLIGHT,    
226      CGE_BLEND_HARDMIX,     
227      CGE_BLEND_DIFFERENCE, 
228      CGE_BLEND_EXCLUDE,    
229      CGE_BLEND_SUBTRACT,   
230      CGE_BLEND_DIVIDE,     
231      CGE_BLEND_HUE,        
232      CGE_BLEND_SATURATION, 
233      CGE_BLEND_COLOR,      
234      CGE_BLEND_LUMINOSITY, 
235      CGE_BLEND_ADD,     
236      CGE_BLEND_ADDREV,  
237      CGE_BLEND_COLORBW, 
238      CGE_BLEND_TYPE_MAX_NUM 
239  } CGETextureBlendMode;
240  typedef enum CGEGlobalBlendMode
241  {
242      CGEGLOBAL_BLEND_NONE,
243      CGEGLOBAL_BLEND_ALPHA,
244      CGEGLOBAL_BLEND_ALPHA_SEPERATE,
245      CGEGLOBAL_BLEND_ADD,
246      CGEGLOBAL_BLEND_ADD_SEPARATE,
247      CGEGLOBAL_BLEND_ADD_SEPARATE_EXT, 
248      CGEGLOBAL_BLEND_MULTIPLY,
249      CGEGLOBAL_BLEND_MULTIPLY_SEPERATE,
250      CGEGLOBAL_BLEND_SCREEN,
251      CGEGLOBAL_BLEND_SCREEN_EXT,
252  } CGEGlobalBlendMode;
253  const char* cgeGetVersion();
254  void cgePrintGLString(const char*, GLenum);
255  bool _cgeCheckGLError(const char* name, const char* file, int line); 
256  void cgeSetGlobalBlendMode(const CGEGlobalBlendMode mode);
257  void cgeGetDataAndChannelByFormat(CGEBufferFormat fmt, GLenum* dataFmt, GLenum* channelFmt, GLint* channel);
258  #ifdef __cplusplus
259  const char* cgeGetBlendModeName(const CGETextureBlendMode mode, bool withChinese = false);
260  GLuint cgeGenTextureWithBuffer(const void* bufferData, GLint w, GLint h, GLenum channelFmt, GLenum dataFmt, GLint channels = 4, GLint bindID = 0, GLenum texFilter = GL_LINEAR, GLenum texWrap = GL_CLAMP_TO_EDGE);
261  #else
262  const char* cgeGetBlendModeName(const CGETextureBlendMode mode, bool withChinese);
263  GLuint cgeGenTextureWithBuffer(const void* bufferData, GLint w, GLint h, GLenum channelFmt, GLenum dataFmt, GLint channels, GLint bindID, GLenum texFilter, GLenum texWrap);
264  #endif
265  #ifdef __cplusplus
266  }
267  #endif
268  #endif &amp;bsol;* _CGECOMMONDEFINE_H_ */
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from android-gpuimage-plus-MDEwOlJlcG9zaXRvcnk0NjU0NzQxNw==-flat-cgeCommonDefine.h</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from android-gpuimage-plus-MDEwOlJlcG9zaXRvcnk0NjU0NzQxNw==-flat-cgeCommonDefine.h</div>
                </div>
                <div class="column column_space"><pre><code>78              instance = nullptr;                       \
79              CGE_LOG_ERROR(&quot;create %s failed!&quot;, #cls); \
80          }                                             \
81          return instance;                              \
82      }
83  #define CGE_COMMON_CREATE_FUNC_WITH_PARAM(cls, funcName, paramName, ...) \
</pre></code></div>
                <div class="column column_space"><pre><code>90              instance = nullptr;                                          \
91              CGE_LOG_ERROR(&quot;create %s failed!&quot;, #cls);                    \
92          }                                                                \
93          return instance;                                                 \
94      }
95  #define CGE_ARRAY_LEN(x) (sizeof(x) / sizeof(*x))
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    