
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 20.01527883880825%, Tokens: 12</h2>
        <div class="column">
            <h3>PINRemoteImage-MDEwOlJlcG9zaXRvcnkzOTUzNzEwMw==-flat-dec.c</h3>
            <pre><code>1  #include <assert.h>
2  #include "src/dsp/dsp.h"
3  #include "src/dec/vp8i_dec.h"
4  #include "src/utils/utils.h"
5  static WEBP_INLINE uint8_t clip_8b(int v) {
6    return (!(v & ~0xff)) ? v : (v < 0) ? 0 : 255;
7  }
8  #define STORE(x, y, v) \
9    dst[(x) + (y) * BPS] = clip_8b(dst[(x) + (y) * BPS] + ((v) >> 3))
10  #define STORE2(y, dc, d, c) do {    \
11    const int DC = (dc);              \
12    STORE(0, y, DC + (d));            \
13    STORE(1, y, DC + (c));            \
14    STORE(2, y, DC - (c));            \
15    STORE(3, y, DC - (d));            \
16  } while (0)
17  #define MUL1(a) ((((a) * 20091) >> 16) + (a))
18  #define MUL2(a) (((a) * 35468) >> 16)
19  #if !WEBP_NEON_OMIT_C_CODE
20  static void TransformOne_C(const int16_t* in, uint8_t* dst) {
21    int C[4 * 4], *tmp;
22    int i;
23    tmp = C;
24    for (i = 0; i < 4; ++i) {    
25      const int a = in[0] + in[8];    
26      const int b = in[0] - in[8];    
27      const int c = MUL2(in[4]) - MUL1(in[12]);   
28      const int d = MUL1(in[4]) + MUL2(in[12]);   
29      tmp[0] = a + d;   
30      tmp[1] = b + c;   
31      tmp[2] = b - c;   
32      tmp[3] = a - d;   
33      tmp += 4;
34      in++;
35    }
36    tmp = C;
37    for (i = 0; i < 4; ++i) {    
38      const int dc = tmp[0] + 4;
39      const int a =  dc +  tmp[8];
40      const int b =  dc -  tmp[8];
41      const int c = MUL2(tmp[4]) - MUL1(tmp[12]);
42      const int d = MUL1(tmp[4]) + MUL2(tmp[12]);
43      STORE(0, 0, a + d);
44      STORE(1, 0, b + c);
45      STORE(2, 0, b - c);
46      STORE(3, 0, a - d);
47      tmp++;
48      dst += BPS;
49    }
50  }
51  static void TransformAC3_C(const int16_t* in, uint8_t* dst) {
52    const int a = in[0] + 4;
53    const int c4 = MUL2(in[4]);
54    const int d4 = MUL1(in[4]);
55    const int c1 = MUL2(in[1]);
56    const int d1 = MUL1(in[1]);
57    STORE2(0, a + d4, d1, c1);
58    STORE2(1, a + c4, d1, c1);
59    STORE2(2, a - c4, d1, c1);
60    STORE2(3, a - d4, d1, c1);
61  }
62  #undef MUL1
63  #undef MUL2
64  #undef STORE2
65  static void TransformTwo_C(const int16_t* in, uint8_t* dst, int do_two) {
66    TransformOne_C(in, dst);
67    if (do_two) {
68      TransformOne_C(in + 16, dst + 4);
69    }
70  }
71  #endif  
72  static void TransformUV_C(const int16_t* in, uint8_t* dst) {
73    VP8Transform(in + 0 * 16, dst, 1);
74    VP8Transform(in + 2 * 16, dst + 4 * BPS, 1);
75  }
76  #if !WEBP_NEON_OMIT_C_CODE
77  static void TransformDC_C(const int16_t* in, uint8_t* dst) {
78    const int DC = in[0] + 4;
79    int i, j;
80    for (j = 0; j < 4; ++j) {
81      for (i = 0; i < 4; ++i) {
82        STORE(i, j, DC);
83      }
84    }
85  }
86  #endif  
87  static void TransformDCUV_C(const int16_t* in, uint8_t* dst) {
88    if (in[0 * 16]) VP8TransformDC(in + 0 * 16, dst);
89    if (in[1 * 16]) VP8TransformDC(in + 1 * 16, dst + 4);
90    if (in[2 * 16]) VP8TransformDC(in + 2 * 16, dst + 4 * BPS);
91    if (in[3 * 16]) VP8TransformDC(in + 3 * 16, dst + 4 * BPS + 4);
92  }
93  #undef STORE
94  #if !WEBP_NEON_OMIT_C_CODE
95  static void TransformWHT_C(const int16_t* in, int16_t* out) {
96    int tmp[16];
97    int i;
98    for (i = 0; i < 4; ++i) {
99      const int a0 = in[0 + i] + in[12 + i];
100      const int a1 = in[4 + i] + in[ 8 + i];
101      const int a2 = in[4 + i] - in[ 8 + i];
102      const int a3 = in[0 + i] - in[12 + i];
103      tmp[0  + i] = a0 + a1;
104      tmp[8  + i] = a0 - a1;
105      tmp[4  + i] = a3 + a2;
106      tmp[12 + i] = a3 - a2;
107    }
108    for (i = 0; i < 4; ++i) {
109      const int dc = tmp[0 + i * 4] + 3;    
110      const int a0 = dc             + tmp[3 + i * 4];
111      const int a1 = tmp[1 + i * 4] + tmp[2 + i * 4];
112      const int a2 = tmp[1 + i * 4] - tmp[2 + i * 4];
113      const int a3 = dc             - tmp[3 + i * 4];
114      out[ 0] = (a0 + a1) >> 3;
115      out[16] = (a3 + a2) >> 3;
116      out[32] = (a0 - a1) >> 3;
117      out[48] = (a3 - a2) >> 3;
118      out += 64;
119    }
120  }
121  #endif  
122  void (*VP8TransformWHT)(const int16_t* in, int16_t* out);
123  #define DST(x, y) dst[(x) + (y) * BPS]
124  #if !WEBP_NEON_OMIT_C_CODE
125  static WEBP_INLINE void TrueMotion(uint8_t* dst, int size) {
126    const uint8_t* top = dst - BPS;
127    const uint8_t* const clip0 = VP8kclip1 - top[-1];
128    int y;
129    for (y = 0; y < size; ++y) {
130      const uint8_t* const clip = clip0 + dst[-1];
131      int x;
132      for (x = 0; x < size; ++x) {
133        dst[x] = clip[top[x]];
134      }
135      dst += BPS;
136    }
137  }
138  static void TM4_C(uint8_t* dst)   { TrueMotion(dst, 4); }
139  static void TM8uv_C(uint8_t* dst) { TrueMotion(dst, 8); }
140  static void TM16_C(uint8_t* dst)  { TrueMotion(dst, 16); }
141  static void VE16_C(uint8_t* dst) {     
142    int j;
143    for (j = 0; j < 16; ++j) {
144      memcpy(dst + j * BPS, dst - BPS, 16);
145    }
146  }
147  static void HE16_C(uint8_t* dst) {     
148    int j;
149    for (j = 16; j > 0; --j) {
150      memset(dst, dst[-1], 16);
151      dst += BPS;
152    }
153  }
154  static WEBP_INLINE void Put16(int v, uint8_t* dst) {
155    int j;
156    for (j = 0; j < 16; ++j) {
157      memset(dst + j * BPS, v, 16);
158    }
159  }
160  static void DC16_C(uint8_t* dst) {    
161    int DC = 16;
162    int j;
163    for (j = 0; j < 16; ++j) {
164      DC += dst[-1 + j * BPS] + dst[j - BPS];
165    }
166    Put16(DC >> 5, dst);
167  }
168  static void DC16NoTop_C(uint8_t* dst) {   
169    int DC = 8;
170    int j;
171    for (j = 0; j < 16; ++j) {
172      DC += dst[-1 + j * BPS];
173    }
174    Put16(DC >> 4, dst);
175  }
176  static void DC16NoLeft_C(uint8_t* dst) {  
177    int DC = 8;
178    int i;
179    for (i = 0; i < 16; ++i) {
<span onclick='openModal()' class='match'>180      DC += dst[i - BPS];
181    }
182    Put16(DC >> 4, dst);
183  }
184  static void DC16NoTopLeft_C(uint8_t* dst) {  
185    Put16(0x80, dst);
186  }
187  #endif  
188  VP8PredFunc VP8PredLuma16[NUM_B_DC_MODES];
189  #define AVG3(a, b, c) ((uint8_t)(((a) + 2 * (b) + (c) + 2) >> 2))
190  #define AVG2(a, b) (((a) + (b) + 1) >> 1)
191  #if !WEBP_NEON_OMIT_C_CODE
192  static void VE4_C(uint8_t* dst) {    
193    const uint8_t* top = dst - BPS;
194    const uint8_t vals[4] = {
</span>195      AVG3(top[-1], top[0], top[1]),
196      AVG3(top[ 0], top[1], top[2]),
197      AVG3(top[ 1], top[2], top[3]),
198      AVG3(top[ 2], top[3], top[4])
199    };
200    int i;
201    for (i = 0; i < 4; ++i) {
202      memcpy(dst + i * BPS, vals, sizeof(vals));
203    }
204  }
205  #endif  
206  static void HE4_C(uint8_t* dst) {    
207    const int A = dst[-1 - BPS];
208    const int B = dst[-1];
209    const int C = dst[-1 + BPS];
210    const int D = dst[-1 + 2 * BPS];
211    const int E = dst[-1 + 3 * BPS];
212    WebPUint32ToMem(dst + 0 * BPS, 0x01010101U * AVG3(A, B, C));
213    WebPUint32ToMem(dst + 1 * BPS, 0x01010101U * AVG3(B, C, D));
214    WebPUint32ToMem(dst + 2 * BPS, 0x01010101U * AVG3(C, D, E));
215    WebPUint32ToMem(dst + 3 * BPS, 0x01010101U * AVG3(D, E, E));
216  }
217  #if !WEBP_NEON_OMIT_C_CODE
218  static void DC4_C(uint8_t* dst) {   
219    uint32_t dc = 4;
220    int i;
221    for (i = 0; i < 4; ++i) dc += dst[i - BPS] + dst[-1 + i * BPS];
222    dc >>= 3;
223    for (i = 0; i < 4; ++i) memset(dst + i * BPS, dc, 4);
224  }
225  static void RD4_C(uint8_t* dst) {   
226    const int I = dst[-1 + 0 * BPS];
227    const int J = dst[-1 + 1 * BPS];
228    const int K = dst[-1 + 2 * BPS];
229    const int L = dst[-1 + 3 * BPS];
230    const int X = dst[-1 - BPS];
231    const int A = dst[0 - BPS];
232    const int B = dst[1 - BPS];
233    const int C = dst[2 - BPS];
234    const int D = dst[3 - BPS];
235    DST(0, 3)                                     = AVG3(J, K, L);
236    DST(1, 3) = DST(0, 2)                         = AVG3(I, J, K);
237    DST(2, 3) = DST(1, 2) = DST(0, 1)             = AVG3(X, I, J);
238    DST(3, 3) = DST(2, 2) = DST(1, 1) = DST(0, 0) = AVG3(A, X, I);
239                DST(3, 2) = DST(2, 1) = DST(1, 0) = AVG3(B, A, X);
240                            DST(3, 1) = DST(2, 0) = AVG3(C, B, A);
241                                        DST(3, 0) = AVG3(D, C, B);
242  }
243  static void LD4_C(uint8_t* dst) {   
244    const int A = dst[0 - BPS];
245    const int B = dst[1 - BPS];
246    const int C = dst[2 - BPS];
247    const int D = dst[3 - BPS];
248    const int E = dst[4 - BPS];
249    const int F = dst[5 - BPS];
250    const int G = dst[6 - BPS];
251    const int H = dst[7 - BPS];
252    DST(0, 0)                                     = AVG3(A, B, C);
253    DST(1, 0) = DST(0, 1)                         = AVG3(B, C, D);
254    DST(2, 0) = DST(1, 1) = DST(0, 2)             = AVG3(C, D, E);
255    DST(3, 0) = DST(2, 1) = DST(1, 2) = DST(0, 3) = AVG3(D, E, F);
256                DST(3, 1) = DST(2, 2) = DST(1, 3) = AVG3(E, F, G);
257                            DST(3, 2) = DST(2, 3) = AVG3(F, G, H);
258                                        DST(3, 3) = AVG3(G, H, H);
259  }
260  #endif  
261  static void VR4_C(uint8_t* dst) {   
262    const int I = dst[-1 + 0 * BPS];
263    const int J = dst[-1 + 1 * BPS];
264    const int K = dst[-1 + 2 * BPS];
265    const int X = dst[-1 - BPS];
266    const int A = dst[0 - BPS];
267    const int B = dst[1 - BPS];
268    const int C = dst[2 - BPS];
269    const int D = dst[3 - BPS];
270    DST(0, 0) = DST(1, 2) = AVG2(X, A);
271    DST(1, 0) = DST(2, 2) = AVG2(A, B);
272    DST(2, 0) = DST(3, 2) = AVG2(B, C);
273    DST(3, 0)             = AVG2(C, D);
274    DST(0, 3) =             AVG3(K, J, I);
275    DST(0, 2) =             AVG3(J, I, X);
276    DST(0, 1) = DST(1, 3) = AVG3(I, X, A);
277    DST(1, 1) = DST(2, 3) = AVG3(X, A, B);
278    DST(2, 1) = DST(3, 3) = AVG3(A, B, C);
279    DST(3, 1) =             AVG3(B, C, D);
280  }
281  static void VL4_C(uint8_t* dst) {   
282    const int A = dst[0 - BPS];
283    const int B = dst[1 - BPS];
284    const int C = dst[2 - BPS];
285    const int D = dst[3 - BPS];
286    const int E = dst[4 - BPS];
287    const int F = dst[5 - BPS];
288    const int G = dst[6 - BPS];
289    const int H = dst[7 - BPS];
290    DST(0, 0) =             AVG2(A, B);
291    DST(1, 0) = DST(0, 2) = AVG2(B, C);
292    DST(2, 0) = DST(1, 2) = AVG2(C, D);
293    DST(3, 0) = DST(2, 2) = AVG2(D, E);
294    DST(0, 1) =             AVG3(A, B, C);
295    DST(1, 1) = DST(0, 3) = AVG3(B, C, D);
296    DST(2, 1) = DST(1, 3) = AVG3(C, D, E);
297    DST(3, 1) = DST(2, 3) = AVG3(D, E, F);
298                DST(3, 2) = AVG3(E, F, G);
299                DST(3, 3) = AVG3(F, G, H);
300  }
301  static void HU4_C(uint8_t* dst) {   
302    const int I = dst[-1 + 0 * BPS];
303    const int J = dst[-1 + 1 * BPS];
304    const int K = dst[-1 + 2 * BPS];
305    const int L = dst[-1 + 3 * BPS];
306    DST(0, 0) =             AVG2(I, J);
307    DST(2, 0) = DST(0, 1) = AVG2(J, K);
308    DST(2, 1) = DST(0, 2) = AVG2(K, L);
309    DST(1, 0) =             AVG3(I, J, K);
310    DST(3, 0) = DST(1, 1) = AVG3(J, K, L);
311    DST(3, 1) = DST(1, 2) = AVG3(K, L, L);
312    DST(3, 2) = DST(2, 2) =
313      DST(0, 3) = DST(1, 3) = DST(2, 3) = DST(3, 3) = L;
314  }
315  static void HD4_C(uint8_t* dst) {  
316    const int I = dst[-1 + 0 * BPS];
317    const int J = dst[-1 + 1 * BPS];
318    const int K = dst[-1 + 2 * BPS];
319    const int L = dst[-1 + 3 * BPS];
320    const int X = dst[-1 - BPS];
321    const int A = dst[0 - BPS];
322    const int B = dst[1 - BPS];
323    const int C = dst[2 - BPS];
324    DST(0, 0) = DST(2, 1) = AVG2(I, X);
325    DST(0, 1) = DST(2, 2) = AVG2(J, I);
326    DST(0, 2) = DST(2, 3) = AVG2(K, J);
327    DST(0, 3)             = AVG2(L, K);
328    DST(3, 0)             = AVG3(A, B, C);
329    DST(2, 0)             = AVG3(X, A, B);
330    DST(1, 0) = DST(3, 1) = AVG3(I, X, A);
331    DST(1, 1) = DST(3, 2) = AVG3(J, I, X);
332    DST(1, 2) = DST(3, 3) = AVG3(K, J, I);
333    DST(1, 3)             = AVG3(L, K, J);
334  }
335  #undef DST
336  #undef AVG3
337  #undef AVG2
338  VP8PredFunc VP8PredLuma4[NUM_BMODES];
339  #if !WEBP_NEON_OMIT_C_CODE
340  static void VE8uv_C(uint8_t* dst) {    
341    int j;
342    for (j = 0; j < 8; ++j) {
343      memcpy(dst + j * BPS, dst - BPS, 8);
344    }
345  }
346  static void HE8uv_C(uint8_t* dst) {    
347    int j;
348    for (j = 0; j < 8; ++j) {
349      memset(dst, dst[-1], 8);
350      dst += BPS;
351    }
352  }
353  static WEBP_INLINE void Put8x8uv(uint8_t value, uint8_t* dst) {
354    int j;
355    for (j = 0; j < 8; ++j) {
356      memset(dst + j * BPS, value, 8);
357    }
358  }
359  static void DC8uv_C(uint8_t* dst) {     
360    int dc0 = 8;
361    int i;
362    for (i = 0; i < 8; ++i) {
363      dc0 += dst[i - BPS] + dst[-1 + i * BPS];
364    }
365    Put8x8uv(dc0 >> 4, dst);
366  }
367  static void DC8uvNoLeft_C(uint8_t* dst) {   
368    int dc0 = 4;
369    int i;
370    for (i = 0; i < 8; ++i) {
371      dc0 += dst[i - BPS];
372    }
373    Put8x8uv(dc0 >> 3, dst);
374  }
375  static void DC8uvNoTop_C(uint8_t* dst) {  
376    int dc0 = 4;
377    int i;
378    for (i = 0; i < 8; ++i) {
379      dc0 += dst[-1 + i * BPS];
380    }
381    Put8x8uv(dc0 >> 3, dst);
382  }
383  static void DC8uvNoTopLeft_C(uint8_t* dst) {    
384    Put8x8uv(0x80, dst);
385  }
386  #endif  
387  VP8PredFunc VP8PredChroma8[NUM_B_DC_MODES];
388  #if !WEBP_NEON_OMIT_C_CODE || WEBP_NEON_WORK_AROUND_GCC
389  static WEBP_INLINE void DoFilter2_C(uint8_t* p, int step) {
390    const int p1 = p[-2*step], p0 = p[-step], q0 = p[0], q1 = p[step];
391    const int a = 3 * (q0 - p0) + VP8ksclip1[p1 - q1];  
392    const int a1 = VP8ksclip2[(a + 4) >> 3];            
393    const int a2 = VP8ksclip2[(a + 3) >> 3];
394    p[-step] = VP8kclip1[p0 + a2];
395    p[    0] = VP8kclip1[q0 - a1];
396  }
397  static WEBP_INLINE void DoFilter4_C(uint8_t* p, int step) {
398    const int p1 = p[-2*step], p0 = p[-step], q0 = p[0], q1 = p[step];
399    const int a = 3 * (q0 - p0);
400    const int a1 = VP8ksclip2[(a + 4) >> 3];
401    const int a2 = VP8ksclip2[(a + 3) >> 3];
402    const int a3 = (a1 + 1) >> 1;
403    p[-2*step] = VP8kclip1[p1 + a3];
404    p[-  step] = VP8kclip1[p0 + a2];
405    p[      0] = VP8kclip1[q0 - a1];
406    p[   step] = VP8kclip1[q1 - a3];
407  }
408  static WEBP_INLINE void DoFilter6_C(uint8_t* p, int step) {
409    const int p2 = p[-3*step], p1 = p[-2*step], p0 = p[-step];
410    const int q0 = p[0], q1 = p[step], q2 = p[2*step];
411    const int a = VP8ksclip1[3 * (q0 - p0) + VP8ksclip1[p1 - q1]];
412    const int a1 = (27 * a + 63) >> 7;  
413    const int a2 = (18 * a + 63) >> 7;  
414    const int a3 = (9  * a + 63) >> 7;  
415    p[-3*step] = VP8kclip1[p2 + a3];
416    p[-2*step] = VP8kclip1[p1 + a2];
417    p[-  step] = VP8kclip1[p0 + a1];
418    p[      0] = VP8kclip1[q0 - a1];
419    p[   step] = VP8kclip1[q1 - a2];
420    p[ 2*step] = VP8kclip1[q2 - a3];
421  }
422  static WEBP_INLINE int Hev(const uint8_t* p, int step, int thresh) {
423    const int p1 = p[-2*step], p0 = p[-step], q0 = p[0], q1 = p[step];
424    return (VP8kabs0[p1 - p0] > thresh) || (VP8kabs0[q1 - q0] > thresh);
425  }
426  #endif  
427  #if !WEBP_NEON_OMIT_C_CODE
428  static WEBP_INLINE int NeedsFilter_C(const uint8_t* p, int step, int t) {
429    const int p1 = p[-2 * step], p0 = p[-step], q0 = p[0], q1 = p[step];
430    return ((4 * VP8kabs0[p0 - q0] + VP8kabs0[p1 - q1]) <= t);
431  }
432  #endif  
433  #if !WEBP_NEON_OMIT_C_CODE || WEBP_NEON_WORK_AROUND_GCC
434  static WEBP_INLINE int NeedsFilter2_C(const uint8_t* p,
435                                        int step, int t, int it) {
436    const int p3 = p[-4 * step], p2 = p[-3 * step], p1 = p[-2 * step];
437    const int p0 = p[-step], q0 = p[0];
438    const int q1 = p[step], q2 = p[2 * step], q3 = p[3 * step];
439    if ((4 * VP8kabs0[p0 - q0] + VP8kabs0[p1 - q1]) > t) return 0;
440    return VP8kabs0[p3 - p2] <= it && VP8kabs0[p2 - p1] <= it &&
441           VP8kabs0[p1 - p0] <= it && VP8kabs0[q3 - q2] <= it &&
442           VP8kabs0[q2 - q1] <= it && VP8kabs0[q1 - q0] <= it;
443  }
444  #endif  
445  #if !WEBP_NEON_OMIT_C_CODE
446  static void SimpleVFilter16_C(uint8_t* p, int stride, int thresh) {
447    int i;
448    const int thresh2 = 2 * thresh + 1;
449    for (i = 0; i < 16; ++i) {
450      if (NeedsFilter_C(p + i, stride, thresh2)) {
451        DoFilter2_C(p + i, stride);
452      }
453    }
454  }
455  static void SimpleHFilter16_C(uint8_t* p, int stride, int thresh) {
456    int i;
457    const int thresh2 = 2 * thresh + 1;
458    for (i = 0; i < 16; ++i) {
459      if (NeedsFilter_C(p + i * stride, 1, thresh2)) {
460        DoFilter2_C(p + i * stride, 1);
461      }
462    }
463  }
464  static void SimpleVFilter16i_C(uint8_t* p, int stride, int thresh) {
465    int k;
466    for (k = 3; k > 0; --k) {
467      p += 4 * stride;
468      SimpleVFilter16_C(p, stride, thresh);
469    }
470  }
471  static void SimpleHFilter16i_C(uint8_t* p, int stride, int thresh) {
472    int k;
473    for (k = 3; k > 0; --k) {
474      p += 4;
475      SimpleHFilter16_C(p, stride, thresh);
476    }
477  }
478  #endif  
479  #if !WEBP_NEON_OMIT_C_CODE || WEBP_NEON_WORK_AROUND_GCC
480  static WEBP_INLINE void FilterLoop26_C(uint8_t* p,
481                                         int hstride, int vstride, int size,
482                                         int thresh, int ithresh,
483                                         int hev_thresh) {
484    const int thresh2 = 2 * thresh + 1;
485    while (size-- > 0) {
486      if (NeedsFilter2_C(p, hstride, thresh2, ithresh)) {
487        if (Hev(p, hstride, hev_thresh)) {
488          DoFilter2_C(p, hstride);
489        } else {
490          DoFilter6_C(p, hstride);
491        }
492      }
493      p += vstride;
494    }
495  }
496  static WEBP_INLINE void FilterLoop24_C(uint8_t* p,
497                                         int hstride, int vstride, int size,
498                                         int thresh, int ithresh,
499                                         int hev_thresh) {
500    const int thresh2 = 2 * thresh + 1;
501    while (size-- > 0) {
502      if (NeedsFilter2_C(p, hstride, thresh2, ithresh)) {
503        if (Hev(p, hstride, hev_thresh)) {
504          DoFilter2_C(p, hstride);
505        } else {
506          DoFilter4_C(p, hstride);
507        }
508      }
509      p += vstride;
510    }
511  }
512  #endif  
513  #if !WEBP_NEON_OMIT_C_CODE
514  static void VFilter16_C(uint8_t* p, int stride,
515                          int thresh, int ithresh, int hev_thresh) {
516    FilterLoop26_C(p, stride, 1, 16, thresh, ithresh, hev_thresh);
517  }
518  static void HFilter16_C(uint8_t* p, int stride,
519                          int thresh, int ithresh, int hev_thresh) {
520    FilterLoop26_C(p, 1, stride, 16, thresh, ithresh, hev_thresh);
521  }
522  static void VFilter16i_C(uint8_t* p, int stride,
523                           int thresh, int ithresh, int hev_thresh) {
524    int k;
525    for (k = 3; k > 0; --k) {
526      p += 4 * stride;
527      FilterLoop24_C(p, stride, 1, 16, thresh, ithresh, hev_thresh);
528    }
529  }
530  #endif  
531  #if !WEBP_NEON_OMIT_C_CODE || WEBP_NEON_WORK_AROUND_GCC
532  static void HFilter16i_C(uint8_t* p, int stride,
533                           int thresh, int ithresh, int hev_thresh) {
534    int k;
535    for (k = 3; k > 0; --k) {
536      p += 4;
537      FilterLoop24_C(p, 1, stride, 16, thresh, ithresh, hev_thresh);
538    }
539  }
540  #endif  
541  #if !WEBP_NEON_OMIT_C_CODE
542  static void VFilter8_C(uint8_t* u, uint8_t* v, int stride,
543                         int thresh, int ithresh, int hev_thresh) {
544    FilterLoop26_C(u, stride, 1, 8, thresh, ithresh, hev_thresh);
545    FilterLoop26_C(v, stride, 1, 8, thresh, ithresh, hev_thresh);
546  }
547  #endif  
548  #if !WEBP_NEON_OMIT_C_CODE || WEBP_NEON_WORK_AROUND_GCC
549  static void HFilter8_C(uint8_t* u, uint8_t* v, int stride,
550                         int thresh, int ithresh, int hev_thresh) {
551    FilterLoop26_C(u, 1, stride, 8, thresh, ithresh, hev_thresh);
552    FilterLoop26_C(v, 1, stride, 8, thresh, ithresh, hev_thresh);
553  }
554  #endif  
555  #if !WEBP_NEON_OMIT_C_CODE
556  static void VFilter8i_C(uint8_t* u, uint8_t* v, int stride,
557                          int thresh, int ithresh, int hev_thresh) {
558    FilterLoop24_C(u + 4 * stride, stride, 1, 8, thresh, ithresh, hev_thresh);
559    FilterLoop24_C(v + 4 * stride, stride, 1, 8, thresh, ithresh, hev_thresh);
560  }
561  #endif  
562  #if !WEBP_NEON_OMIT_C_CODE || WEBP_NEON_WORK_AROUND_GCC
563  static void HFilter8i_C(uint8_t* u, uint8_t* v, int stride,
564                          int thresh, int ithresh, int hev_thresh) {
565    FilterLoop24_C(u + 4, 1, stride, 8, thresh, ithresh, hev_thresh);
566    FilterLoop24_C(v + 4, 1, stride, 8, thresh, ithresh, hev_thresh);
567  }
568  #endif  
569  static void DitherCombine8x8_C(const uint8_t* dither, uint8_t* dst,
570                                 int dst_stride) {
571    int i, j;
572    for (j = 0; j < 8; ++j) {
573      for (i = 0; i < 8; ++i) {
574        const int delta0 = dither[i] - VP8_DITHER_AMP_CENTER;
575        const int delta1 =
576            (delta0 + VP8_DITHER_DESCALE_ROUNDER) >> VP8_DITHER_DESCALE;
577        dst[i] = clip_8b((int)dst[i] + delta1);
578      }
579      dst += dst_stride;
580      dither += 8;
581    }
582  }
583  VP8DecIdct2 VP8Transform;
584  VP8DecIdct VP8TransformAC3;
585  VP8DecIdct VP8TransformUV;
586  VP8DecIdct VP8TransformDC;
587  VP8DecIdct VP8TransformDCUV;
588  VP8LumaFilterFunc VP8VFilter16;
589  VP8LumaFilterFunc VP8HFilter16;
590  VP8ChromaFilterFunc VP8VFilter8;
591  VP8ChromaFilterFunc VP8HFilter8;
592  VP8LumaFilterFunc VP8VFilter16i;
593  VP8LumaFilterFunc VP8HFilter16i;
594  VP8ChromaFilterFunc VP8VFilter8i;
595  VP8ChromaFilterFunc VP8HFilter8i;
596  VP8SimpleFilterFunc VP8SimpleVFilter16;
597  VP8SimpleFilterFunc VP8SimpleHFilter16;
598  VP8SimpleFilterFunc VP8SimpleVFilter16i;
599  VP8SimpleFilterFunc VP8SimpleHFilter16i;
600  void (*VP8DitherCombine8x8)(const uint8_t* dither, uint8_t* dst,
601                              int dst_stride);
602  extern void VP8DspInitSSE2(void);
603  extern void VP8DspInitSSE41(void);
604  extern void VP8DspInitNEON(void);
605  extern void VP8DspInitMIPS32(void);
606  extern void VP8DspInitMIPSdspR2(void);
607  extern void VP8DspInitMSA(void);
608  WEBP_DSP_INIT_FUNC(VP8DspInit) {
609    VP8InitClipTables();
610  #if !WEBP_NEON_OMIT_C_CODE
611    VP8TransformWHT = TransformWHT_C;
612    VP8Transform = TransformTwo_C;
613    VP8TransformDC = TransformDC_C;
614    VP8TransformAC3 = TransformAC3_C;
615  #endif
616    VP8TransformUV = TransformUV_C;
617    VP8TransformDCUV = TransformDCUV_C;
618  #if !WEBP_NEON_OMIT_C_CODE
619    VP8VFilter16 = VFilter16_C;
620    VP8VFilter16i = VFilter16i_C;
621    VP8HFilter16 = HFilter16_C;
622    VP8VFilter8 = VFilter8_C;
623    VP8VFilter8i = VFilter8i_C;
624    VP8SimpleVFilter16 = SimpleVFilter16_C;
625    VP8SimpleHFilter16 = SimpleHFilter16_C;
626    VP8SimpleVFilter16i = SimpleVFilter16i_C;
627    VP8SimpleHFilter16i = SimpleHFilter16i_C;
628  #endif
629  #if !WEBP_NEON_OMIT_C_CODE || WEBP_NEON_WORK_AROUND_GCC
630    VP8HFilter16i = HFilter16i_C;
631    VP8HFilter8 = HFilter8_C;
632    VP8HFilter8i = HFilter8i_C;
633  #endif
634  #if !WEBP_NEON_OMIT_C_CODE
635    VP8PredLuma4[0] = DC4_C;
636    VP8PredLuma4[1] = TM4_C;
637    VP8PredLuma4[2] = VE4_C;
638    VP8PredLuma4[4] = RD4_C;
639    VP8PredLuma4[6] = LD4_C;
640  #endif
641    VP8PredLuma4[3] = HE4_C;
642    VP8PredLuma4[5] = VR4_C;
643    VP8PredLuma4[7] = VL4_C;
644    VP8PredLuma4[8] = HD4_C;
645    VP8PredLuma4[9] = HU4_C;
646  #if !WEBP_NEON_OMIT_C_CODE
647    VP8PredLuma16[0] = DC16_C;
648    VP8PredLuma16[1] = TM16_C;
649    VP8PredLuma16[2] = VE16_C;
650    VP8PredLuma16[3] = HE16_C;
651    VP8PredLuma16[4] = DC16NoTop_C;
652    VP8PredLuma16[5] = DC16NoLeft_C;
653    VP8PredLuma16[6] = DC16NoTopLeft_C;
654    VP8PredChroma8[0] = DC8uv_C;
655    VP8PredChroma8[1] = TM8uv_C;
656    VP8PredChroma8[2] = VE8uv_C;
657    VP8PredChroma8[3] = HE8uv_C;
658    VP8PredChroma8[4] = DC8uvNoTop_C;
659    VP8PredChroma8[5] = DC8uvNoLeft_C;
660    VP8PredChroma8[6] = DC8uvNoTopLeft_C;
661  #endif
662    VP8DitherCombine8x8 = DitherCombine8x8_C;
663    if (VP8GetCPUInfo != NULL) {
664  #if defined(WEBP_USE_SSE2)
665      if (VP8GetCPUInfo(kSSE2)) {
666        VP8DspInitSSE2();
667  #if defined(WEBP_USE_SSE41)
668        if (VP8GetCPUInfo(kSSE4_1)) {
669          VP8DspInitSSE41();
670        }
671  #endif
672      }
673  #endif
674  #if defined(WEBP_USE_MIPS32)
675      if (VP8GetCPUInfo(kMIPS32)) {
676        VP8DspInitMIPS32();
677      }
678  #endif
679  #if defined(WEBP_USE_MIPS_DSP_R2)
680      if (VP8GetCPUInfo(kMIPSdspR2)) {
681        VP8DspInitMIPSdspR2();
682      }
683  #endif
684  #if defined(WEBP_USE_MSA)
685      if (VP8GetCPUInfo(kMSA)) {
686        VP8DspInitMSA();
687      }
688  #endif
689    }
690  #if defined(WEBP_USE_NEON)
691    if (WEBP_NEON_OMIT_C_CODE ||
692        (VP8GetCPUInfo != NULL && VP8GetCPUInfo(kNEON))) {
693      VP8DspInitNEON();
694    }
695  #endif
696    assert(VP8TransformWHT != NULL);
697    assert(VP8Transform != NULL);
698    assert(VP8TransformDC != NULL);
699    assert(VP8TransformAC3 != NULL);
700    assert(VP8TransformUV != NULL);
701    assert(VP8TransformDCUV != NULL);
702    assert(VP8VFilter16 != NULL);
703    assert(VP8HFilter16 != NULL);
704    assert(VP8VFilter8 != NULL);
705    assert(VP8HFilter8 != NULL);
706    assert(VP8VFilter16i != NULL);
707    assert(VP8HFilter16i != NULL);
708    assert(VP8VFilter8i != NULL);
709    assert(VP8HFilter8i != NULL);
710    assert(VP8SimpleVFilter16 != NULL);
711    assert(VP8SimpleHFilter16 != NULL);
712    assert(VP8SimpleVFilter16i != NULL);
713    assert(VP8SimpleHFilter16i != NULL);
714    assert(VP8PredLuma4[0] != NULL);
715    assert(VP8PredLuma4[1] != NULL);
716    assert(VP8PredLuma4[2] != NULL);
717    assert(VP8PredLuma4[3] != NULL);
718    assert(VP8PredLuma4[4] != NULL);
719    assert(VP8PredLuma4[5] != NULL);
720    assert(VP8PredLuma4[6] != NULL);
721    assert(VP8PredLuma4[7] != NULL);
722    assert(VP8PredLuma4[8] != NULL);
723    assert(VP8PredLuma4[9] != NULL);
724    assert(VP8PredLuma16[0] != NULL);
725    assert(VP8PredLuma16[1] != NULL);
726    assert(VP8PredLuma16[2] != NULL);
727    assert(VP8PredLuma16[3] != NULL);
728    assert(VP8PredLuma16[4] != NULL);
729    assert(VP8PredLuma16[5] != NULL);
730    assert(VP8PredLuma16[6] != NULL);
731    assert(VP8PredChroma8[0] != NULL);
732    assert(VP8PredChroma8[1] != NULL);
733    assert(VP8PredChroma8[2] != NULL);
734    assert(VP8PredChroma8[3] != NULL);
735    assert(VP8PredChroma8[4] != NULL);
736    assert(VP8PredChroma8[5] != NULL);
737    assert(VP8PredChroma8[6] != NULL);
738    assert(VP8DitherCombine8x8 != NULL);
739  }
</code></pre>
        </div>
        <div class="column">
            <h3>PINRemoteImage-MDEwOlJlcG9zaXRvcnkzOTUzNzEwMw==-flat-dec_neon.c</h3>
            <pre><code>1  #include "src/dsp/dsp.h"
2  #if defined(WEBP_USE_NEON)
3  #include "src/dsp/neon.h"
4  #include "src/dec/vp8i_dec.h"
5  #if !defined(WORK_AROUND_GCC)
6  static WEBP_INLINE uint8x8x4_t Load4x8_NEON(const uint8_t* const src,
7                                              int stride) {
8    const uint8x8_t zero = vdup_n_u8(0);
9    uint8x8x4_t out;
10    INIT_VECTOR4(out, zero, zero, zero, zero);
11    out = vld4_lane_u8(src + 0 * stride, out, 0);
12    out = vld4_lane_u8(src + 1 * stride, out, 1);
13    out = vld4_lane_u8(src + 2 * stride, out, 2);
14    out = vld4_lane_u8(src + 3 * stride, out, 3);
15    out = vld4_lane_u8(src + 4 * stride, out, 4);
16    out = vld4_lane_u8(src + 5 * stride, out, 5);
17    out = vld4_lane_u8(src + 6 * stride, out, 6);
18    out = vld4_lane_u8(src + 7 * stride, out, 7);
19    return out;
20  }
21  static WEBP_INLINE void Load4x16_NEON(const uint8_t* const src, int stride,
22                                        uint8x16_t* const p1,
23                                        uint8x16_t* const p0,
24                                        uint8x16_t* const q0,
25                                        uint8x16_t* const q1) {
26    const uint8x8x4_t row0 = Load4x8_NEON(src - 2 + 0 * stride, stride);
27    const uint8x8x4_t row8 = Load4x8_NEON(src - 2 + 8 * stride, stride);
28    *p1 = vcombine_u8(row0.val[0], row8.val[0]);
29    *p0 = vcombine_u8(row0.val[1], row8.val[1]);
30    *q0 = vcombine_u8(row0.val[2], row8.val[2]);
31    *q1 = vcombine_u8(row0.val[3], row8.val[3]);
32  }
33  #else  
34  #define LOADQ_LANE_32b(VALUE, LANE) do {                             \
35    (VALUE) = vld1q_lane_u32((const uint32_t*)src, (VALUE), (LANE));   \
36    src += stride;                                                     \
37  } while (0)
38  static WEBP_INLINE void Load4x16_NEON(const uint8_t* src, int stride,
39                                        uint8x16_t* const p1,
40                                        uint8x16_t* const p0,
41                                        uint8x16_t* const q0,
42                                        uint8x16_t* const q1) {
43    const uint32x4_t zero = vdupq_n_u32(0);
44    uint32x4x4_t in;
45    INIT_VECTOR4(in, zero, zero, zero, zero);
46    src -= 2;
47    LOADQ_LANE_32b(in.val[0], 0);
48    LOADQ_LANE_32b(in.val[1], 0);
49    LOADQ_LANE_32b(in.val[2], 0);
50    LOADQ_LANE_32b(in.val[3], 0);
51    LOADQ_LANE_32b(in.val[0], 1);
52    LOADQ_LANE_32b(in.val[1], 1);
53    LOADQ_LANE_32b(in.val[2], 1);
54    LOADQ_LANE_32b(in.val[3], 1);
55    LOADQ_LANE_32b(in.val[0], 2);
56    LOADQ_LANE_32b(in.val[1], 2);
57    LOADQ_LANE_32b(in.val[2], 2);
58    LOADQ_LANE_32b(in.val[3], 2);
59    LOADQ_LANE_32b(in.val[0], 3);
60    LOADQ_LANE_32b(in.val[1], 3);
61    LOADQ_LANE_32b(in.val[2], 3);
62    LOADQ_LANE_32b(in.val[3], 3);
63    {
64      const uint8x16x2_t row01 = vtrnq_u8(vreinterpretq_u8_u32(in.val[0]),
65                                          vreinterpretq_u8_u32(in.val[1]));
66      const uint8x16x2_t row23 = vtrnq_u8(vreinterpretq_u8_u32(in.val[2]),
67                                          vreinterpretq_u8_u32(in.val[3]));
68      const uint16x8x2_t row02 = vtrnq_u16(vreinterpretq_u16_u8(row01.val[0]),
69                                           vreinterpretq_u16_u8(row23.val[0]));
70      const uint16x8x2_t row13 = vtrnq_u16(vreinterpretq_u16_u8(row01.val[1]),
71                                           vreinterpretq_u16_u8(row23.val[1]));
72      *p1 = vreinterpretq_u8_u16(row02.val[0]);
73      *p0 = vreinterpretq_u8_u16(row13.val[0]);
74      *q0 = vreinterpretq_u8_u16(row02.val[1]);
75      *q1 = vreinterpretq_u8_u16(row13.val[1]);
76    }
77  }
78  #undef LOADQ_LANE_32b
79  #endif  
80  static WEBP_INLINE void Load8x16_NEON(
81      const uint8_t* const src, int stride,
82      uint8x16_t* const p3, uint8x16_t* const p2, uint8x16_t* const p1,
83      uint8x16_t* const p0, uint8x16_t* const q0, uint8x16_t* const q1,
84      uint8x16_t* const q2, uint8x16_t* const q3) {
85    Load4x16_NEON(src - 2, stride, p3, p2, p1, p0);
86    Load4x16_NEON(src + 2, stride, q0, q1, q2, q3);
87  }
88  static WEBP_INLINE void Load16x4_NEON(const uint8_t* const src, int stride,
89                                        uint8x16_t* const p1,
90                                        uint8x16_t* const p0,
91                                        uint8x16_t* const q0,
92                                        uint8x16_t* const q1) {
93    *p1 = vld1q_u8(src - 2 * stride);
94    *p0 = vld1q_u8(src - 1 * stride);
95    *q0 = vld1q_u8(src + 0 * stride);
96    *q1 = vld1q_u8(src + 1 * stride);
97  }
98  static WEBP_INLINE void Load16x8_NEON(
99      const uint8_t* const src, int stride,
100      uint8x16_t* const p3, uint8x16_t* const p2, uint8x16_t* const p1,
101      uint8x16_t* const p0, uint8x16_t* const q0, uint8x16_t* const q1,
102      uint8x16_t* const q2, uint8x16_t* const q3) {
103    Load16x4_NEON(src - 2  * stride, stride, p3, p2, p1, p0);
104    Load16x4_NEON(src + 2  * stride, stride, q0, q1, q2, q3);
105  }
106  static WEBP_INLINE void Load8x8x2_NEON(
107      const uint8_t* const u, const uint8_t* const v, int stride,
108      uint8x16_t* const p3, uint8x16_t* const p2, uint8x16_t* const p1,
109      uint8x16_t* const p0, uint8x16_t* const q0, uint8x16_t* const q1,
110      uint8x16_t* const q2, uint8x16_t* const q3) {
111    *p3 = vcombine_u8(vld1_u8(u - 4 * stride), vld1_u8(v - 4 * stride));
112    *p2 = vcombine_u8(vld1_u8(u - 3 * stride), vld1_u8(v - 3 * stride));
113    *p1 = vcombine_u8(vld1_u8(u - 2 * stride), vld1_u8(v - 2 * stride));
114    *p0 = vcombine_u8(vld1_u8(u - 1 * stride), vld1_u8(v - 1 * stride));
115    *q0 = vcombine_u8(vld1_u8(u + 0 * stride), vld1_u8(v + 0 * stride));
116    *q1 = vcombine_u8(vld1_u8(u + 1 * stride), vld1_u8(v + 1 * stride));
117    *q2 = vcombine_u8(vld1_u8(u + 2 * stride), vld1_u8(v + 2 * stride));
118    *q3 = vcombine_u8(vld1_u8(u + 3 * stride), vld1_u8(v + 3 * stride));
119  }
120  #if !defined(WORK_AROUND_GCC)
121  #define LOAD_UV_8(ROW) \
122    vcombine_u8(vld1_u8(u - 4 + (ROW) * stride), vld1_u8(v - 4 + (ROW) * stride))
123  static WEBP_INLINE void Load8x8x2T_NEON(
124      const uint8_t* const u, const uint8_t* const v, int stride,
125      uint8x16_t* const p3, uint8x16_t* const p2, uint8x16_t* const p1,
126      uint8x16_t* const p0, uint8x16_t* const q0, uint8x16_t* const q1,
127      uint8x16_t* const q2, uint8x16_t* const q3) {
128    const uint8x16_t row0 = LOAD_UV_8(0);
129    const uint8x16_t row1 = LOAD_UV_8(1);
130    const uint8x16_t row2 = LOAD_UV_8(2);
131    const uint8x16_t row3 = LOAD_UV_8(3);
132    const uint8x16_t row4 = LOAD_UV_8(4);
133    const uint8x16_t row5 = LOAD_UV_8(5);
134    const uint8x16_t row6 = LOAD_UV_8(6);
135    const uint8x16_t row7 = LOAD_UV_8(7);
136    const uint8x16x2_t row01 = vtrnq_u8(row0, row1);  
137    const uint8x16x2_t row23 = vtrnq_u8(row2, row3);  
138    const uint8x16x2_t row45 = vtrnq_u8(row4, row5);  
139    const uint8x16x2_t row67 = vtrnq_u8(row6, row7);  
140    const uint16x8x2_t row02 = vtrnq_u16(vreinterpretq_u16_u8(row01.val[0]),
141                                         vreinterpretq_u16_u8(row23.val[0]));
142    const uint16x8x2_t row13 = vtrnq_u16(vreinterpretq_u16_u8(row01.val[1]),
143                                         vreinterpretq_u16_u8(row23.val[1]));
144    const uint16x8x2_t row46 = vtrnq_u16(vreinterpretq_u16_u8(row45.val[0]),
145                                         vreinterpretq_u16_u8(row67.val[0]));
146    const uint16x8x2_t row57 = vtrnq_u16(vreinterpretq_u16_u8(row45.val[1]),
147                                         vreinterpretq_u16_u8(row67.val[1]));
148    const uint32x4x2_t row04 = vtrnq_u32(vreinterpretq_u32_u16(row02.val[0]),
149                                         vreinterpretq_u32_u16(row46.val[0]));
150    const uint32x4x2_t row26 = vtrnq_u32(vreinterpretq_u32_u16(row02.val[1]),
151                                         vreinterpretq_u32_u16(row46.val[1]));
152    const uint32x4x2_t row15 = vtrnq_u32(vreinterpretq_u32_u16(row13.val[0]),
153                                         vreinterpretq_u32_u16(row57.val[0]));
154    const uint32x4x2_t row37 = vtrnq_u32(vreinterpretq_u32_u16(row13.val[1]),
155                                         vreinterpretq_u32_u16(row57.val[1]));
156    *p3 = vreinterpretq_u8_u32(row04.val[0]);
157    *p2 = vreinterpretq_u8_u32(row15.val[0]);
158    *p1 = vreinterpretq_u8_u32(row26.val[0]);
159    *p0 = vreinterpretq_u8_u32(row37.val[0]);
160    *q0 = vreinterpretq_u8_u32(row04.val[1]);
161    *q1 = vreinterpretq_u8_u32(row15.val[1]);
162    *q2 = vreinterpretq_u8_u32(row26.val[1]);
163    *q3 = vreinterpretq_u8_u32(row37.val[1]);
164  }
165  #undef LOAD_UV_8
166  #endif  
167  static WEBP_INLINE void Store2x8_NEON(const uint8x8x2_t v,
168                                        uint8_t* const dst, int stride) {
169    vst2_lane_u8(dst + 0 * stride, v, 0);
170    vst2_lane_u8(dst + 1 * stride, v, 1);
171    vst2_lane_u8(dst + 2 * stride, v, 2);
172    vst2_lane_u8(dst + 3 * stride, v, 3);
173    vst2_lane_u8(dst + 4 * stride, v, 4);
174    vst2_lane_u8(dst + 5 * stride, v, 5);
175    vst2_lane_u8(dst + 6 * stride, v, 6);
176    vst2_lane_u8(dst + 7 * stride, v, 7);
177  }
178  static WEBP_INLINE void Store2x16_NEON(const uint8x16_t p0, const uint8x16_t q0,
179                                         uint8_t* const dst, int stride) {
180    uint8x8x2_t lo, hi;
181    lo.val[0] = vget_low_u8(p0);
182    lo.val[1] = vget_low_u8(q0);
183    hi.val[0] = vget_high_u8(p0);
184    hi.val[1] = vget_high_u8(q0);
185    Store2x8_NEON(lo, dst - 1 + 0 * stride, stride);
186    Store2x8_NEON(hi, dst - 1 + 8 * stride, stride);
187  }
188  #if !defined(WORK_AROUND_GCC)
189  static WEBP_INLINE void Store4x8_NEON(const uint8x8x4_t v,
190                                        uint8_t* const dst, int stride) {
191    vst4_lane_u8(dst + 0 * stride, v, 0);
192    vst4_lane_u8(dst + 1 * stride, v, 1);
193    vst4_lane_u8(dst + 2 * stride, v, 2);
194    vst4_lane_u8(dst + 3 * stride, v, 3);
195    vst4_lane_u8(dst + 4 * stride, v, 4);
196    vst4_lane_u8(dst + 5 * stride, v, 5);
197    vst4_lane_u8(dst + 6 * stride, v, 6);
198    vst4_lane_u8(dst + 7 * stride, v, 7);
199  }
200  static WEBP_INLINE void Store4x16_NEON(const uint8x16_t p1, const uint8x16_t p0,
201                                         const uint8x16_t q0, const uint8x16_t q1,
202                                         uint8_t* const dst, int stride) {
203    uint8x8x4_t lo, hi;
204    INIT_VECTOR4(lo,
205                 vget_low_u8(p1), vget_low_u8(p0),
206                 vget_low_u8(q0), vget_low_u8(q1));
207    INIT_VECTOR4(hi,
208                 vget_high_u8(p1), vget_high_u8(p0),
209                 vget_high_u8(q0), vget_high_u8(q1));
210    Store4x8_NEON(lo, dst - 2 + 0 * stride, stride);
211    Store4x8_NEON(hi, dst - 2 + 8 * stride, stride);
212  }
213  #endif  
214  static WEBP_INLINE void Store16x2_NEON(const uint8x16_t p0, const uint8x16_t q0,
215                                         uint8_t* const dst, int stride) {
216    vst1q_u8(dst - stride, p0);
217    vst1q_u8(dst, q0);
218  }
219  static WEBP_INLINE void Store16x4_NEON(const uint8x16_t p1, const uint8x16_t p0,
220                                         const uint8x16_t q0, const uint8x16_t q1,
221                                         uint8_t* const dst, int stride) {
222    Store16x2_NEON(p1, p0, dst - stride, stride);
223    Store16x2_NEON(q0, q1, dst + stride, stride);
224  }
225  static WEBP_INLINE void Store8x2x2_NEON(const uint8x16_t p0,
226                                          const uint8x16_t q0,
227                                          uint8_t* const u, uint8_t* const v,
228                                          int stride) {
229    vst1_u8(u - stride, vget_low_u8(p0));
230    vst1_u8(u,          vget_low_u8(q0));
231    vst1_u8(v - stride, vget_high_u8(p0));
232    vst1_u8(v,          vget_high_u8(q0));
233  }
234  static WEBP_INLINE void Store8x4x2_NEON(const uint8x16_t p1,
235                                          const uint8x16_t p0,
236                                          const uint8x16_t q0,
237                                          const uint8x16_t q1,
238                                          uint8_t* const u, uint8_t* const v,
239                                          int stride) {
240    Store8x2x2_NEON(p1, p0, u - stride, v - stride, stride);
241    Store8x2x2_NEON(q0, q1, u + stride, v + stride, stride);
242  }
243  #if !defined(WORK_AROUND_GCC)
244  #define STORE6_LANE(DST, VAL0, VAL1, LANE) do {   \
245    vst3_lane_u8((DST) - 3, (VAL0), (LANE));        \
246    vst3_lane_u8((DST) + 0, (VAL1), (LANE));        \
247    (DST) += stride;                                \
248  } while (0)
249  static WEBP_INLINE void Store6x8x2_NEON(
250      const uint8x16_t p2, const uint8x16_t p1, const uint8x16_t p0,
251      const uint8x16_t q0, const uint8x16_t q1, const uint8x16_t q2,
252      uint8_t* u, uint8_t* v, int stride) {
253    uint8x8x3_t u0, u1, v0, v1;
254    INIT_VECTOR3(u0, vget_low_u8(p2), vget_low_u8(p1), vget_low_u8(p0));
255    INIT_VECTOR3(u1, vget_low_u8(q0), vget_low_u8(q1), vget_low_u8(q2));
256    INIT_VECTOR3(v0, vget_high_u8(p2), vget_high_u8(p1), vget_high_u8(p0));
257    INIT_VECTOR3(v1, vget_high_u8(q0), vget_high_u8(q1), vget_high_u8(q2));
258    STORE6_LANE(u, u0, u1, 0);
259    STORE6_LANE(u, u0, u1, 1);
260    STORE6_LANE(u, u0, u1, 2);
261    STORE6_LANE(u, u0, u1, 3);
262    STORE6_LANE(u, u0, u1, 4);
263    STORE6_LANE(u, u0, u1, 5);
264    STORE6_LANE(u, u0, u1, 6);
265    STORE6_LANE(u, u0, u1, 7);
266    STORE6_LANE(v, v0, v1, 0);
267    STORE6_LANE(v, v0, v1, 1);
268    STORE6_LANE(v, v0, v1, 2);
269    STORE6_LANE(v, v0, v1, 3);
270    STORE6_LANE(v, v0, v1, 4);
271    STORE6_LANE(v, v0, v1, 5);
272    STORE6_LANE(v, v0, v1, 6);
273    STORE6_LANE(v, v0, v1, 7);
274  }
275  #undef STORE6_LANE
276  static WEBP_INLINE void Store4x8x2_NEON(const uint8x16_t p1,
277                                          const uint8x16_t p0,
278                                          const uint8x16_t q0,
279                                          const uint8x16_t q1,
280                                          uint8_t* const u, uint8_t* const v,
281                                          int stride) {
282    uint8x8x4_t u0, v0;
283    INIT_VECTOR4(u0,
284                 vget_low_u8(p1), vget_low_u8(p0),
285                 vget_low_u8(q0), vget_low_u8(q1));
286    INIT_VECTOR4(v0,
287                 vget_high_u8(p1), vget_high_u8(p0),
288                 vget_high_u8(q0), vget_high_u8(q1));
289    vst4_lane_u8(u - 2 + 0 * stride, u0, 0);
290    vst4_lane_u8(u - 2 + 1 * stride, u0, 1);
291    vst4_lane_u8(u - 2 + 2 * stride, u0, 2);
292    vst4_lane_u8(u - 2 + 3 * stride, u0, 3);
293    vst4_lane_u8(u - 2 + 4 * stride, u0, 4);
294    vst4_lane_u8(u - 2 + 5 * stride, u0, 5);
295    vst4_lane_u8(u - 2 + 6 * stride, u0, 6);
296    vst4_lane_u8(u - 2 + 7 * stride, u0, 7);
297    vst4_lane_u8(v - 2 + 0 * stride, v0, 0);
298    vst4_lane_u8(v - 2 + 1 * stride, v0, 1);
299    vst4_lane_u8(v - 2 + 2 * stride, v0, 2);
300    vst4_lane_u8(v - 2 + 3 * stride, v0, 3);
301    vst4_lane_u8(v - 2 + 4 * stride, v0, 4);
302    vst4_lane_u8(v - 2 + 5 * stride, v0, 5);
303    vst4_lane_u8(v - 2 + 6 * stride, v0, 6);
304    vst4_lane_u8(v - 2 + 7 * stride, v0, 7);
305  }
306  #endif  
307  static WEBP_INLINE int16x8_t ConvertU8ToS16_NEON(uint8x8_t v) {
308    return vreinterpretq_s16_u16(vmovl_u8(v));
309  }
310  static WEBP_INLINE void SaturateAndStore4x4_NEON(uint8_t* const dst,
311                                                   const int16x8_t dst01,
312                                                   const int16x8_t dst23) {
313    const uint8x8_t dst01_u8 = vqmovun_s16(dst01);
314    const uint8x8_t dst23_u8 = vqmovun_s16(dst23);
315    vst1_lane_u32((uint32_t*)(dst + 0 * BPS), vreinterpret_u32_u8(dst01_u8), 0);
316    vst1_lane_u32((uint32_t*)(dst + 1 * BPS), vreinterpret_u32_u8(dst01_u8), 1);
317    vst1_lane_u32((uint32_t*)(dst + 2 * BPS), vreinterpret_u32_u8(dst23_u8), 0);
318    vst1_lane_u32((uint32_t*)(dst + 3 * BPS), vreinterpret_u32_u8(dst23_u8), 1);
319  }
320  static WEBP_INLINE void Add4x4_NEON(const int16x8_t row01,
321                                      const int16x8_t row23,
322                                      uint8_t* const dst) {
323    uint32x2_t dst01 = vdup_n_u32(0);
324    uint32x2_t dst23 = vdup_n_u32(0);
325    dst01 = vld1_lane_u32((uint32_t*)(dst + 0 * BPS), dst01, 0);
326    dst23 = vld1_lane_u32((uint32_t*)(dst + 2 * BPS), dst23, 0);
327    dst01 = vld1_lane_u32((uint32_t*)(dst + 1 * BPS), dst01, 1);
328    dst23 = vld1_lane_u32((uint32_t*)(dst + 3 * BPS), dst23, 1);
329    {
330      const int16x8_t dst01_s16 = ConvertU8ToS16_NEON(vreinterpret_u8_u32(dst01));
331      const int16x8_t dst23_s16 = ConvertU8ToS16_NEON(vreinterpret_u8_u32(dst23));
332      const int16x8_t out01 = vrsraq_n_s16(dst01_s16, row01, 3);
333      const int16x8_t out23 = vrsraq_n_s16(dst23_s16, row23, 3);
334      SaturateAndStore4x4_NEON(dst, out01, out23);
335    }
336  }
337  static uint8x16_t NeedsFilter_NEON(const uint8x16_t p1, const uint8x16_t p0,
338                                     const uint8x16_t q0, const uint8x16_t q1,
339                                     int thresh) {
340    const uint8x16_t thresh_v = vdupq_n_u8((uint8_t)thresh);
341    const uint8x16_t a_p0_q0 = vabdq_u8(p0, q0);               
342    const uint8x16_t a_p1_q1 = vabdq_u8(p1, q1);               
343    const uint8x16_t a_p0_q0_2 = vqaddq_u8(a_p0_q0, a_p0_q0);  
344    const uint8x16_t a_p1_q1_2 = vshrq_n_u8(a_p1_q1, 1);       
345    const uint8x16_t sum = vqaddq_u8(a_p0_q0_2, a_p1_q1_2);
346    const uint8x16_t mask = vcgeq_u8(thresh_v, sum);
347    return mask;
348  }
349  static int8x16_t FlipSign_NEON(const uint8x16_t v) {
350    const uint8x16_t sign_bit = vdupq_n_u8(0x80);
351    return vreinterpretq_s8_u8(veorq_u8(v, sign_bit));
352  }
353  static uint8x16_t FlipSignBack_NEON(const int8x16_t v) {
354    const int8x16_t sign_bit = vdupq_n_s8(0x80);
355    return vreinterpretq_u8_s8(veorq_s8(v, sign_bit));
356  }
357  static int8x16_t GetBaseDelta_NEON(const int8x16_t p1, const int8x16_t p0,
358                                     const int8x16_t q0, const int8x16_t q1) {
359    const int8x16_t q0_p0 = vqsubq_s8(q0, p0);      
360    const int8x16_t p1_q1 = vqsubq_s8(p1, q1);      
361    const int8x16_t s1 = vqaddq_s8(p1_q1, q0_p0);   
362    const int8x16_t s2 = vqaddq_s8(q0_p0, s1);      
363    const int8x16_t s3 = vqaddq_s8(q0_p0, s2);      
364    return s3;
365  }
366  static int8x16_t GetBaseDelta0_NEON(const int8x16_t p0, const int8x16_t q0) {
367    const int8x16_t q0_p0 = vqsubq_s8(q0, p0);      
368    const int8x16_t s1 = vqaddq_s8(q0_p0, q0_p0);   
369    const int8x16_t s2 = vqaddq_s8(q0_p0, s1);      
370    return s2;
371  }
372  static void ApplyFilter2NoFlip_NEON(const int8x16_t p0s, const int8x16_t q0s,
373                                      const int8x16_t delta,
374                                      int8x16_t* const op0,
375                                      int8x16_t* const oq0) {
376    const int8x16_t kCst3 = vdupq_n_s8(0x03);
377    const int8x16_t kCst4 = vdupq_n_s8(0x04);
378    const int8x16_t delta_p3 = vqaddq_s8(delta, kCst3);
379    const int8x16_t delta_p4 = vqaddq_s8(delta, kCst4);
380    const int8x16_t delta3 = vshrq_n_s8(delta_p3, 3);
381    const int8x16_t delta4 = vshrq_n_s8(delta_p4, 3);
382    *op0 = vqaddq_s8(p0s, delta3);
383    *oq0 = vqsubq_s8(q0s, delta4);
384  }
385  #if defined(WEBP_USE_INTRINSICS)
386  static void ApplyFilter2_NEON(const int8x16_t p0s, const int8x16_t q0s,
387                                const int8x16_t delta,
388                                uint8x16_t* const op0, uint8x16_t* const oq0) {
389    const int8x16_t kCst3 = vdupq_n_s8(0x03);
390    const int8x16_t kCst4 = vdupq_n_s8(0x04);
391    const int8x16_t delta_p3 = vqaddq_s8(delta, kCst3);
392    const int8x16_t delta_p4 = vqaddq_s8(delta, kCst4);
393    const int8x16_t delta3 = vshrq_n_s8(delta_p3, 3);
394    const int8x16_t delta4 = vshrq_n_s8(delta_p4, 3);
395    const int8x16_t sp0 = vqaddq_s8(p0s, delta3);
396    const int8x16_t sq0 = vqsubq_s8(q0s, delta4);
397    *op0 = FlipSignBack_NEON(sp0);
398    *oq0 = FlipSignBack_NEON(sq0);
399  }
400  static void DoFilter2_NEON(const uint8x16_t p1, const uint8x16_t p0,
401                             const uint8x16_t q0, const uint8x16_t q1,
402                             const uint8x16_t mask,
403                             uint8x16_t* const op0, uint8x16_t* const oq0) {
404    const int8x16_t p1s = FlipSign_NEON(p1);
405    const int8x16_t p0s = FlipSign_NEON(p0);
406    const int8x16_t q0s = FlipSign_NEON(q0);
407    const int8x16_t q1s = FlipSign_NEON(q1);
408    const int8x16_t delta0 = GetBaseDelta_NEON(p1s, p0s, q0s, q1s);
409    const int8x16_t delta1 = vandq_s8(delta0, vreinterpretq_s8_u8(mask));
410    ApplyFilter2_NEON(p0s, q0s, delta1, op0, oq0);
411  }
412  static void SimpleVFilter16_NEON(uint8_t* p, int stride, int thresh) {
413    uint8x16_t p1, p0, q0, q1, op0, oq0;
414    Load16x4_NEON(p, stride, &p1, &p0, &q0, &q1);
415    {
416      const uint8x16_t mask = NeedsFilter_NEON(p1, p0, q0, q1, thresh);
417      DoFilter2_NEON(p1, p0, q0, q1, mask, &op0, &oq0);
418    }
419    Store16x2_NEON(op0, oq0, p, stride);
420  }
421  static void SimpleHFilter16_NEON(uint8_t* p, int stride, int thresh) {
422    uint8x16_t p1, p0, q0, q1, oq0, op0;
423    Load4x16_NEON(p, stride, &p1, &p0, &q0, &q1);
424    {
425      const uint8x16_t mask = NeedsFilter_NEON(p1, p0, q0, q1, thresh);
426      DoFilter2_NEON(p1, p0, q0, q1, mask, &op0, &oq0);
427    }
428    Store2x16_NEON(op0, oq0, p, stride);
429  }
430  #else
431  #define LOAD8x4(c1, c2, c3, c4, b1, b2, stride)                                \
432    "vld4.8 {" #c1 "[0]," #c2 "[0]," #c3 "[0]," #c4 "[0]}," #b1 "," #stride "\n" \
433    "vld4.8 {" #c1 "[1]," #c2 "[1]," #c3 "[1]," #c4 "[1]}," #b2 "," #stride "\n" \
434    "vld4.8 {" #c1 "[2]," #c2 "[2]," #c3 "[2]," #c4 "[2]}," #b1 "," #stride "\n" \
435    "vld4.8 {" #c1 "[3]," #c2 "[3]," #c3 "[3]," #c4 "[3]}," #b2 "," #stride "\n" \
436    "vld4.8 {" #c1 "[4]," #c2 "[4]," #c3 "[4]," #c4 "[4]}," #b1 "," #stride "\n" \
437    "vld4.8 {" #c1 "[5]," #c2 "[5]," #c3 "[5]," #c4 "[5]}," #b2 "," #stride "\n" \
438    "vld4.8 {" #c1 "[6]," #c2 "[6]," #c3 "[6]," #c4 "[6]}," #b1 "," #stride "\n" \
439    "vld4.8 {" #c1 "[7]," #c2 "[7]," #c3 "[7]," #c4 "[7]}," #b2 "," #stride "\n"
440  #define STORE8x2(c1, c2, p, stride)                                            \
441    "vst2.8   {" #c1 "[0], " #c2 "[0]}," #p "," #stride " \n"                    \
442    "vst2.8   {" #c1 "[1], " #c2 "[1]}," #p "," #stride " \n"                    \
443    "vst2.8   {" #c1 "[2], " #c2 "[2]}," #p "," #stride " \n"                    \
444    "vst2.8   {" #c1 "[3], " #c2 "[3]}," #p "," #stride " \n"                    \
445    "vst2.8   {" #c1 "[4], " #c2 "[4]}," #p "," #stride " \n"                    \
446    "vst2.8   {" #c1 "[5], " #c2 "[5]}," #p "," #stride " \n"                    \
447    "vst2.8   {" #c1 "[6], " #c2 "[6]}," #p "," #stride " \n"                    \
448    "vst2.8   {" #c1 "[7], " #c2 "[7]}," #p "," #stride " \n"
449  #define QRegs "q0", "q1", "q2", "q3",                                          \
450                "q8", "q9", "q10", "q11", "q12", "q13", "q14", "q15"
451  #define FLIP_SIGN_BIT2(a, b, s)                                                \
452    "veor     " #a "," #a "," #s "               \n"                             \
453    "veor     " #b "," #b "," #s "               \n"                             \
454  
455  #define FLIP_SIGN_BIT4(a, b, c, d, s)                                          \
456    FLIP_SIGN_BIT2(a, b, s)                                                      \
457    FLIP_SIGN_BIT2(c, d, s)                                                      \
458  
459  #define NEEDS_FILTER(p1, p0, q0, q1, thresh, mask)                             \
460    "vabd.u8    q15," #p0 "," #q0 "         \n"  &bsol;* abs(p0 - q0) */              \
461    "vabd.u8    q14," #p1 "," #q1 "         \n"  &bsol;* abs(p1 - q1) */              \
462    "vqadd.u8   q15, q15, q15               \n"  &bsol;* abs(p0 - q0) * 2 */          \
463    "vshr.u8    q14, q14, #1                \n"  &bsol;* abs(p1 - q1) / 2 */          \
464    "vqadd.u8   q15, q15, q14     \n"  &bsol;* abs(p0 - q0) * 2 + abs(p1 - q1) / 2 */ \
465    "vdup.8     q14, " #thresh "            \n"                                  \
466    "vcge.u8   " #mask ", q14, q15          \n"  &bsol;* mask <= thresh */
467  #define GET_BASE_DELTA(p1, p0, q0, q1, o)                                      \
468    "vqsub.s8   q15," #q0 "," #p0 "         \n"  &bsol;* (q0 - p0) */                 \
469    "vqsub.s8  " #o "," #p1 "," #q1 "       \n"  &bsol;* (p1 - q1) */                 \
470    "vqadd.s8  " #o "," #o ", q15           \n"  &bsol;* (p1 - q1) + 1 * (p0 - q0) */ \
471    "vqadd.s8  " #o "," #o ", q15           \n"  &bsol;* (p1 - q1) + 2 * (p0 - q0) */ \
472    "vqadd.s8  " #o "," #o ", q15           \n"  &bsol;* (p1 - q1) + 3 * (p0 - q0) */
473  #define DO_SIMPLE_FILTER(p0, q0, fl)                                           \
474    "vmov.i8    q15, #0x03                  \n"                                  \
475    "vqadd.s8   q15, q15, " #fl "           \n"  &bsol;* filter1 = filter + 3 */      \
476    "vshr.s8    q15, q15, #3                \n"  &bsol;* filter1 >> 3 */              \
477    "vqadd.s8  " #p0 "," #p0 ", q15         \n"  &bsol;* p0 += filter1 */             \
478                                                                                 \
479    "vmov.i8    q15, #0x04                  \n"                                  \
480    "vqadd.s8   q15, q15, " #fl "           \n"  &bsol;* filter1 = filter + 4 */      \
481    "vshr.s8    q15, q15, #3                \n"  &bsol;* filter2 >> 3 */              \
482    "vqsub.s8  " #q0 "," #q0 ", q15         \n"  &bsol;* q0 -= filter2 */
483  #define DO_FILTER2(p1, p0, q0, q1, thresh)                                     \
484    NEEDS_FILTER(p1, p0, q0, q1, thresh, q9)     &bsol;* filter mask in q9 */         \
485    "vmov.i8    q10, #0x80                  \n"  &bsol;* sign bit */                  \
486    FLIP_SIGN_BIT4(p1, p0, q0, q1, q10)          &bsol;* convert to signed value */   \
487    GET_BASE_DELTA(p1, p0, q0, q1, q11)          &bsol;* get filter level  */         \
488    "vand       q9, q9, q11                 \n"  &bsol;* apply filter mask */         \
489    DO_SIMPLE_FILTER(p0, q0, q9)                 &bsol;* apply filter */              \
490    FLIP_SIGN_BIT2(p0, q0, q10)
491  static void SimpleVFilter16_NEON(uint8_t* p, int stride, int thresh) {
492    __asm__ volatile (
493      "sub        %[p], %[p], %[stride], lsl #1  \n"  
494      "vld1.u8    {q1}, [%[p]], %[stride]        \n"  
495      "vld1.u8    {q2}, [%[p]], %[stride]        \n"  
496      "vld1.u8    {q3}, [%[p]], %[stride]        \n"  
497      "vld1.u8    {q12}, [%[p]]                  \n"  
498      DO_FILTER2(q1, q2, q3, q12, %[thresh])
499      "sub        %[p], %[p], %[stride], lsl #1  \n"  
500      "vst1.u8    {q2}, [%[p]], %[stride]        \n"  
501      "vst1.u8    {q3}, [%[p]]                   \n"  
502      : [p] "+r"(p)
503      : [stride] "r"(stride), [thresh] "r"(thresh)
504      : "memory", QRegs
505    );
506  }
507  static void SimpleHFilter16_NEON(uint8_t* p, int stride, int thresh) {
508    __asm__ volatile (
509      "sub        r4, %[p], #2                   \n"  
510      "lsl        r6, %[stride], #1              \n"  
511      "add        r5, r4, %[stride]              \n"  
512      LOAD8x4(d2, d3, d4, d5, [r4], [r5], r6)
513      LOAD8x4(d24, d25, d26, d27, [r4], [r5], r6)
514      "vswp       d3, d24                        \n"  
515      "vswp       d5, d26                        \n"  
516      "vswp       q2, q12                        \n"  
517      DO_FILTER2(q1, q2, q12, q13, %[thresh])
518      "sub        %[p], %[p], #1                 \n"  
519      "vswp        d5, d24                       \n"
520      STORE8x2(d4, d5, [%[p]], %[stride])
521      STORE8x2(d24, d25, [%[p]], %[stride])
522      : [p] "+r"(p)
523      : [stride] "r"(stride), [thresh] "r"(thresh)
524      : "memory", "r4", "r5", "r6", QRegs
525    );
526  }
527  #undef LOAD8x4
528  #undef STORE8x2
529  #endif    
530  static void SimpleVFilter16i_NEON(uint8_t* p, int stride, int thresh) {
531    uint32_t k;
532    for (k = 3; k != 0; --k) {
533      p += 4 * stride;
534      SimpleVFilter16_NEON(p, stride, thresh);
535    }
536  }
537  static void SimpleHFilter16i_NEON(uint8_t* p, int stride, int thresh) {
538    uint32_t k;
539    for (k = 3; k != 0; --k) {
540      p += 4;
541      SimpleHFilter16_NEON(p, stride, thresh);
542    }
543  }
544  static uint8x16_t NeedsHev_NEON(const uint8x16_t p1, const uint8x16_t p0,
545                                  const uint8x16_t q0, const uint8x16_t q1,
546                                  int hev_thresh) {
547    const uint8x16_t hev_thresh_v = vdupq_n_u8((uint8_t)hev_thresh);
548    const uint8x16_t a_p1_p0 = vabdq_u8(p1, p0);  
549    const uint8x16_t a_q1_q0 = vabdq_u8(q1, q0);  
550    const uint8x16_t a_max = vmaxq_u8(a_p1_p0, a_q1_q0);
551    const uint8x16_t mask = vcgtq_u8(a_max, hev_thresh_v);
552    return mask;
553  }
554  static uint8x16_t NeedsFilter2_NEON(const uint8x16_t p3, const uint8x16_t p2,
555                                      const uint8x16_t p1, const uint8x16_t p0,
556                                      const uint8x16_t q0, const uint8x16_t q1,
557                                      const uint8x16_t q2, const uint8x16_t q3,
558                                      int ithresh, int thresh) {
559    const uint8x16_t ithresh_v = vdupq_n_u8((uint8_t)ithresh);
560    const uint8x16_t a_p3_p2 = vabdq_u8(p3, p2);  
561    const uint8x16_t a_p2_p1 = vabdq_u8(p2, p1);  
562    const uint8x16_t a_p1_p0 = vabdq_u8(p1, p0);  
563    const uint8x16_t a_q3_q2 = vabdq_u8(q3, q2);  
564    const uint8x16_t a_q2_q1 = vabdq_u8(q2, q1);  
565    const uint8x16_t a_q1_q0 = vabdq_u8(q1, q0);  
566    const uint8x16_t max1 = vmaxq_u8(a_p3_p2, a_p2_p1);
567    const uint8x16_t max2 = vmaxq_u8(a_p1_p0, a_q3_q2);
568    const uint8x16_t max3 = vmaxq_u8(a_q2_q1, a_q1_q0);
569    const uint8x16_t max12 = vmaxq_u8(max1, max2);
570    const uint8x16_t max123 = vmaxq_u8(max12, max3);
571    const uint8x16_t mask2 = vcgeq_u8(ithresh_v, max123);
572    const uint8x16_t mask1 = NeedsFilter_NEON(p1, p0, q0, q1, thresh);
573    const uint8x16_t mask = vandq_u8(mask1, mask2);
574    return mask;
575  }
576  static void ApplyFilter4_NEON(
577      const int8x16_t p1, const int8x16_t p0,
578      const int8x16_t q0, const int8x16_t q1,
579      const int8x16_t delta0,
580      uint8x16_t* const op1, uint8x16_t* const op0,
581      uint8x16_t* const oq0, uint8x16_t* const oq1) {
582    const int8x16_t kCst3 = vdupq_n_s8(0x03);
583    const int8x16_t kCst4 = vdupq_n_s8(0x04);
584    const int8x16_t delta1 = vqaddq_s8(delta0, kCst4);
585    const int8x16_t delta2 = vqaddq_s8(delta0, kCst3);
586    const int8x16_t a1 = vshrq_n_s8(delta1, 3);
587    const int8x16_t a2 = vshrq_n_s8(delta2, 3);
588    const int8x16_t a3 = vrshrq_n_s8(a1, 1);   
589    *op0 = FlipSignBack_NEON(vqaddq_s8(p0, a2));  
590    *oq0 = FlipSignBack_NEON(vqsubq_s8(q0, a1));  
591    *op1 = FlipSignBack_NEON(vqaddq_s8(p1, a3));  
592    *oq1 = FlipSignBack_NEON(vqsubq_s8(q1, a3));  
593  }
594  static void DoFilter4_NEON(
595      const uint8x16_t p1, const uint8x16_t p0,
596      const uint8x16_t q0, const uint8x16_t q1,
597      const uint8x16_t mask, const uint8x16_t hev_mask,
598      uint8x16_t* const op1, uint8x16_t* const op0,
599      uint8x16_t* const oq0, uint8x16_t* const oq1) {
600    const int8x16_t p1s = FlipSign_NEON(p1);
601    int8x16_t p0s = FlipSign_NEON(p0);
602    int8x16_t q0s = FlipSign_NEON(q0);
603    const int8x16_t q1s = FlipSign_NEON(q1);
604    const uint8x16_t simple_lf_mask = vandq_u8(mask, hev_mask);
605    {
606      const int8x16_t delta = GetBaseDelta_NEON(p1s, p0s, q0s, q1s);
607      const int8x16_t simple_lf_delta =
608          vandq_s8(delta, vreinterpretq_s8_u8(simple_lf_mask));
609      ApplyFilter2NoFlip_NEON(p0s, q0s, simple_lf_delta, &p0s, &q0s);
610    }
611    {
612      const int8x16_t delta0 = GetBaseDelta0_NEON(p0s, q0s);
613      const uint8x16_t complex_lf_mask = veorq_u8(simple_lf_mask, mask);
614      const int8x16_t complex_lf_delta =
615          vandq_s8(delta0, vreinterpretq_s8_u8(complex_lf_mask));
616      ApplyFilter4_NEON(p1s, p0s, q0s, q1s, complex_lf_delta, op1, op0, oq0, oq1);
617    }
618  }
619  static void ApplyFilter6_NEON(
620      const int8x16_t p2, const int8x16_t p1, const int8x16_t p0,
621      const int8x16_t q0, const int8x16_t q1, const int8x16_t q2,
622      const int8x16_t delta,
623      uint8x16_t* const op2, uint8x16_t* const op1, uint8x16_t* const op0,
624      uint8x16_t* const oq0, uint8x16_t* const oq1, uint8x16_t* const oq2) {
625    const int8x8_t delta_lo = vget_low_s8(delta);
626    const int8x8_t delta_hi = vget_high_s8(delta);
627    const int8x8_t kCst9 = vdup_n_s8(9);
628    const int16x8_t kCstm1 = vdupq_n_s16(-1);
629    const int8x8_t kCst18 = vdup_n_s8(18);
630    const int16x8_t S_lo = vmlal_s8(kCstm1, kCst9, delta_lo);  
631    const int16x8_t S_hi = vmlal_s8(kCstm1, kCst9, delta_hi);
632    const int16x8_t Z_lo = vmlal_s8(S_lo, kCst18, delta_lo);   
633    const int16x8_t Z_hi = vmlal_s8(S_hi, kCst18, delta_hi);
634    const int8x8_t a3_lo = vqrshrn_n_s16(S_lo, 7);   
635    const int8x8_t a3_hi = vqrshrn_n_s16(S_hi, 7);
636    const int8x8_t a2_lo = vqrshrn_n_s16(S_lo, 6);   
637    const int8x8_t a2_hi = vqrshrn_n_s16(S_hi, 6);
638    const int8x8_t a1_lo = vqrshrn_n_s16(Z_lo, 7);   
639    const int8x8_t a1_hi = vqrshrn_n_s16(Z_hi, 7);
640    const int8x16_t a1 = vcombine_s8(a1_lo, a1_hi);
641    const int8x16_t a2 = vcombine_s8(a2_lo, a2_hi);
642    const int8x16_t a3 = vcombine_s8(a3_lo, a3_hi);
643    *op0 = FlipSignBack_NEON(vqaddq_s8(p0, a1));  
644    *oq0 = FlipSignBack_NEON(vqsubq_s8(q0, a1));  
645    *oq1 = FlipSignBack_NEON(vqsubq_s8(q1, a2));  
646    *op1 = FlipSignBack_NEON(vqaddq_s8(p1, a2));  
647    *oq2 = FlipSignBack_NEON(vqsubq_s8(q2, a3));  
648    *op2 = FlipSignBack_NEON(vqaddq_s8(p2, a3));  
649  }
650  static void DoFilter6_NEON(
651      const uint8x16_t p2, const uint8x16_t p1, const uint8x16_t p0,
652      const uint8x16_t q0, const uint8x16_t q1, const uint8x16_t q2,
653      const uint8x16_t mask, const uint8x16_t hev_mask,
654      uint8x16_t* const op2, uint8x16_t* const op1, uint8x16_t* const op0,
655      uint8x16_t* const oq0, uint8x16_t* const oq1, uint8x16_t* const oq2) {
656    const int8x16_t p2s = FlipSign_NEON(p2);
657    const int8x16_t p1s = FlipSign_NEON(p1);
658    int8x16_t p0s = FlipSign_NEON(p0);
659    int8x16_t q0s = FlipSign_NEON(q0);
660    const int8x16_t q1s = FlipSign_NEON(q1);
661    const int8x16_t q2s = FlipSign_NEON(q2);
662    const uint8x16_t simple_lf_mask = vandq_u8(mask, hev_mask);
663    const int8x16_t delta0 = GetBaseDelta_NEON(p1s, p0s, q0s, q1s);
664    {
665      const int8x16_t simple_lf_delta =
666          vandq_s8(delta0, vreinterpretq_s8_u8(simple_lf_mask));
667      ApplyFilter2NoFlip_NEON(p0s, q0s, simple_lf_delta, &p0s, &q0s);
668    }
669    {
670      const uint8x16_t complex_lf_mask = veorq_u8(simple_lf_mask, mask);
671      const int8x16_t complex_lf_delta =
672          vandq_s8(delta0, vreinterpretq_s8_u8(complex_lf_mask));
673      ApplyFilter6_NEON(p2s, p1s, p0s, q0s, q1s, q2s, complex_lf_delta,
674                        op2, op1, op0, oq0, oq1, oq2);
675    }
676  }
677  static void VFilter16_NEON(uint8_t* p, int stride,
678                             int thresh, int ithresh, int hev_thresh) {
679    uint8x16_t p3, p2, p1, p0, q0, q1, q2, q3;
680    Load16x8_NEON(p, stride, &p3, &p2, &p1, &p0, &q0, &q1, &q2, &q3);
681    {
682      const uint8x16_t mask = NeedsFilter2_NEON(p3, p2, p1, p0, q0, q1, q2, q3,
683                                                ithresh, thresh);
684      const uint8x16_t hev_mask = NeedsHev_NEON(p1, p0, q0, q1, hev_thresh);
685      uint8x16_t op2, op1, op0, oq0, oq1, oq2;
686      DoFilter6_NEON(p2, p1, p0, q0, q1, q2, mask, hev_mask,
687                     &op2, &op1, &op0, &oq0, &oq1, &oq2);
688      Store16x2_NEON(op2, op1, p - 2 * stride, stride);
689      Store16x2_NEON(op0, oq0, p + 0 * stride, stride);
690      Store16x2_NEON(oq1, oq2, p + 2 * stride, stride);
691    }
692  }
693  static void HFilter16_NEON(uint8_t* p, int stride,
694                             int thresh, int ithresh, int hev_thresh) {
695    uint8x16_t p3, p2, p1, p0, q0, q1, q2, q3;
696    Load8x16_NEON(p, stride, &p3, &p2, &p1, &p0, &q0, &q1, &q2, &q3);
697    {
698      const uint8x16_t mask = NeedsFilter2_NEON(p3, p2, p1, p0, q0, q1, q2, q3,
699                                                ithresh, thresh);
700      const uint8x16_t hev_mask = NeedsHev_NEON(p1, p0, q0, q1, hev_thresh);
701      uint8x16_t op2, op1, op0, oq0, oq1, oq2;
702      DoFilter6_NEON(p2, p1, p0, q0, q1, q2, mask, hev_mask,
703                     &op2, &op1, &op0, &oq0, &oq1, &oq2);
704      Store2x16_NEON(op2, op1, p - 2, stride);
705      Store2x16_NEON(op0, oq0, p + 0, stride);
706      Store2x16_NEON(oq1, oq2, p + 2, stride);
707    }
708  }
709  static void VFilter16i_NEON(uint8_t* p, int stride,
710                              int thresh, int ithresh, int hev_thresh) {
711    uint32_t k;
712    uint8x16_t p3, p2, p1, p0;
713    Load16x4_NEON(p + 2  * stride, stride, &p3, &p2, &p1, &p0);
714    for (k = 3; k != 0; --k) {
715      uint8x16_t q0, q1, q2, q3;
716      p += 4 * stride;
717      Load16x4_NEON(p + 2  * stride, stride, &q0, &q1, &q2, &q3);
718      {
719        const uint8x16_t mask =
720            NeedsFilter2_NEON(p3, p2, p1, p0, q0, q1, q2, q3, ithresh, thresh);
721        const uint8x16_t hev_mask = NeedsHev_NEON(p1, p0, q0, q1, hev_thresh);
722        DoFilter4_NEON(p1, p0, q0, q1, mask, hev_mask, &p1, &p0, &p3, &p2);
723        Store16x4_NEON(p1, p0, p3, p2, p, stride);
724        p1 = q2;
725        p0 = q3;
726      }
727    }
728  }
729  #if !defined(WORK_AROUND_GCC)
730  static void HFilter16i_NEON(uint8_t* p, int stride,
731                              int thresh, int ithresh, int hev_thresh) {
732    uint32_t k;
733    uint8x16_t p3, p2, p1, p0;
734    Load4x16_NEON(p + 2, stride, &p3, &p2, &p1, &p0);
735    for (k = 3; k != 0; --k) {
736      uint8x16_t q0, q1, q2, q3;
737      p += 4;
738      Load4x16_NEON(p + 2, stride, &q0, &q1, &q2, &q3);
739      {
740        const uint8x16_t mask =
741            NeedsFilter2_NEON(p3, p2, p1, p0, q0, q1, q2, q3, ithresh, thresh);
742        const uint8x16_t hev_mask = NeedsHev_NEON(p1, p0, q0, q1, hev_thresh);
743        DoFilter4_NEON(p1, p0, q0, q1, mask, hev_mask, &p1, &p0, &p3, &p2);
744        Store4x16_NEON(p1, p0, p3, p2, p, stride);
745        p1 = q2;
746        p0 = q3;
747      }
748    }
749  }
750  #endif  
751  static void VFilter8_NEON(uint8_t* u, uint8_t* v, int stride,
752                            int thresh, int ithresh, int hev_thresh) {
753    uint8x16_t p3, p2, p1, p0, q0, q1, q2, q3;
754    Load8x8x2_NEON(u, v, stride, &p3, &p2, &p1, &p0, &q0, &q1, &q2, &q3);
755    {
756      const uint8x16_t mask = NeedsFilter2_NEON(p3, p2, p1, p0, q0, q1, q2, q3,
757                                                ithresh, thresh);
758      const uint8x16_t hev_mask = NeedsHev_NEON(p1, p0, q0, q1, hev_thresh);
759      uint8x16_t op2, op1, op0, oq0, oq1, oq2;
760      DoFilter6_NEON(p2, p1, p0, q0, q1, q2, mask, hev_mask,
761                     &op2, &op1, &op0, &oq0, &oq1, &oq2);
762      Store8x2x2_NEON(op2, op1, u - 2 * stride, v - 2 * stride, stride);
763      Store8x2x2_NEON(op0, oq0, u + 0 * stride, v + 0 * stride, stride);
764      Store8x2x2_NEON(oq1, oq2, u + 2 * stride, v + 2 * stride, stride);
765    }
766  }
767  static void VFilter8i_NEON(uint8_t* u, uint8_t* v, int stride,
768                             int thresh, int ithresh, int hev_thresh) {
769    uint8x16_t p3, p2, p1, p0, q0, q1, q2, q3;
770    u += 4 * stride;
771    v += 4 * stride;
772    Load8x8x2_NEON(u, v, stride, &p3, &p2, &p1, &p0, &q0, &q1, &q2, &q3);
773    {
774      const uint8x16_t mask = NeedsFilter2_NEON(p3, p2, p1, p0, q0, q1, q2, q3,
775                                                ithresh, thresh);
776      const uint8x16_t hev_mask = NeedsHev_NEON(p1, p0, q0, q1, hev_thresh);
777      uint8x16_t op1, op0, oq0, oq1;
778      DoFilter4_NEON(p1, p0, q0, q1, mask, hev_mask, &op1, &op0, &oq0, &oq1);
779      Store8x4x2_NEON(op1, op0, oq0, oq1, u, v, stride);
780    }
781  }
782  #if !defined(WORK_AROUND_GCC)
783  static void HFilter8_NEON(uint8_t* u, uint8_t* v, int stride,
784                            int thresh, int ithresh, int hev_thresh) {
785    uint8x16_t p3, p2, p1, p0, q0, q1, q2, q3;
786    Load8x8x2T_NEON(u, v, stride, &p3, &p2, &p1, &p0, &q0, &q1, &q2, &q3);
787    {
788      const uint8x16_t mask = NeedsFilter2_NEON(p3, p2, p1, p0, q0, q1, q2, q3,
789                                                ithresh, thresh);
790      const uint8x16_t hev_mask = NeedsHev_NEON(p1, p0, q0, q1, hev_thresh);
791      uint8x16_t op2, op1, op0, oq0, oq1, oq2;
792      DoFilter6_NEON(p2, p1, p0, q0, q1, q2, mask, hev_mask,
793                     &op2, &op1, &op0, &oq0, &oq1, &oq2);
794      Store6x8x2_NEON(op2, op1, op0, oq0, oq1, oq2, u, v, stride);
795    }
796  }
797  static void HFilter8i_NEON(uint8_t* u, uint8_t* v, int stride,
798                             int thresh, int ithresh, int hev_thresh) {
799    uint8x16_t p3, p2, p1, p0, q0, q1, q2, q3;
800    u += 4;
801    v += 4;
802    Load8x8x2T_NEON(u, v, stride, &p3, &p2, &p1, &p0, &q0, &q1, &q2, &q3);
803    {
804      const uint8x16_t mask = NeedsFilter2_NEON(p3, p2, p1, p0, q0, q1, q2, q3,
805                                                ithresh, thresh);
806      const uint8x16_t hev_mask = NeedsHev_NEON(p1, p0, q0, q1, hev_thresh);
807      uint8x16_t op1, op0, oq0, oq1;
808      DoFilter4_NEON(p1, p0, q0, q1, mask, hev_mask, &op1, &op0, &oq0, &oq1);
809      Store4x8x2_NEON(op1, op0, oq0, oq1, u, v, stride);
810    }
811  }
812  #endif  
813  static const int16_t kC1 = 20091;
814  static const int16_t kC2 = 17734;  
815  #if defined(WEBP_USE_INTRINSICS)
816  static WEBP_INLINE void Transpose8x2_NEON(const int16x8_t in0,
817                                            const int16x8_t in1,
818                                            int16x8x2_t* const out) {
819    const int16x8x2_t tmp0 = vzipq_s16(in0, in1);   
820    *out = vzipq_s16(tmp0.val[0], tmp0.val[1]);
821  }
822  static WEBP_INLINE void TransformPass_NEON(int16x8x2_t* const rows) {
823    const int16x8_t B1 =
824        vcombine_s16(vget_high_s16(rows->val[0]), vget_high_s16(rows->val[1]));
825    const int16x8_t C0 = vsraq_n_s16(B1, vqdmulhq_n_s16(B1, kC1), 1);
826    const int16x8_t C1 = vqdmulhq_n_s16(B1, kC2);
827    const int16x4_t a = vqadd_s16(vget_low_s16(rows->val[0]),
828                                  vget_low_s16(rows->val[1]));   
829    const int16x4_t b = vqsub_s16(vget_low_s16(rows->val[0]),
830                                  vget_low_s16(rows->val[1]));   
831    const int16x4_t c = vqsub_s16(vget_low_s16(C1), vget_high_s16(C0));
832    const int16x4_t d = vqadd_s16(vget_low_s16(C0), vget_high_s16(C1));
833    const int16x8_t D0 = vcombine_s16(a, b);      
834    const int16x8_t D1 = vcombine_s16(d, c);      
835    const int16x8_t E0 = vqaddq_s16(D0, D1);      
836    const int16x8_t E_tmp = vqsubq_s16(D0, D1);   
837    const int16x8_t E1 = vcombine_s16(vget_high_s16(E_tmp), vget_low_s16(E_tmp));
838    Transpose8x2_NEON(E0, E1, rows);
839  }
840  static void TransformOne_NEON(const int16_t* in, uint8_t* dst) {
841    int16x8x2_t rows;
842    INIT_VECTOR2(rows, vld1q_s16(in + 0), vld1q_s16(in + 8));
843    TransformPass_NEON(&rows);
844    TransformPass_NEON(&rows);
845    Add4x4_NEON(rows.val[0], rows.val[1], dst);
846  }
847  #else
848  static void TransformOne_NEON(const int16_t* in, uint8_t* dst) {
849    const int kBPS = BPS;
850    const int16_t constants[4] = { kC1, kC2, 0, 0 };
851    __asm__ volatile (
852      "vld1.16         {q1, q2}, [%[in]]           \n"
853      "vld1.16         {d0}, [%[constants]]        \n"
854      "vswp            d3, d4                      \n"
855      "vqdmulh.s16     q8, q2, d0[0]               \n"
856      "vqdmulh.s16     q9, q2, d0[1]               \n"
857      "vqadd.s16       d22, d2, d3                 \n"
858      "vqsub.s16       d23, d2, d3                 \n"
859      "vshr.s16        q8, q8, #1                  \n"
860      "vqadd.s16       q8, q2, q8                  \n"
861      "vqsub.s16       d20, d18, d17               \n"
862      "vqadd.s16       d21, d19, d16               \n"
863      "vqadd.s16       d2, d22, d21                \n"
864      "vqadd.s16       d3, d23, d20                \n"
865      "vqsub.s16       d4, d23, d20                \n"
866      "vqsub.s16       d5, d22, d21                \n"
867      "vzip.16         q1, q2                      \n"
868      "vzip.16         q1, q2                      \n"
869      "vswp            d3, d4                      \n"
870      "vqdmulh.s16     q8, q2, d0[0]               \n"
871      "vqdmulh.s16     q9, q2, d0[1]               \n"
872      "vqadd.s16       d22, d2, d3                 \n"
873      "vqsub.s16       d23, d2, d3                 \n"
874      "vshr.s16        q8, q8, #1                  \n"
875      "vqadd.s16       q8, q2, q8                  \n"
876      "vqsub.s16       d20, d18, d17               \n"
877      "vqadd.s16       d21, d19, d16               \n"
878      "vqadd.s16       d2, d22, d21                \n"
879      "vqadd.s16       d3, d23, d20                \n"
880      "vqsub.s16       d4, d23, d20                \n"
881      "vqsub.s16       d5, d22, d21                \n"
882      "vld1.32         d6[0], [%[dst]], %[kBPS]    \n"
883      "vld1.32         d6[1], [%[dst]], %[kBPS]    \n"
884      "vld1.32         d7[0], [%[dst]], %[kBPS]    \n"
885      "vld1.32         d7[1], [%[dst]], %[kBPS]    \n"
886      "sub         %[dst], %[dst], %[kBPS], lsl #2 \n"
887      "vrshr.s16       d2, d2, #3                  \n"
888      "vrshr.s16       d3, d3, #3                  \n"
889      "vrshr.s16       d4, d4, #3                  \n"
890      "vrshr.s16       d5, d5, #3                  \n"
891      "vzip.16         q1, q2                      \n"
892      "vzip.16         q1, q2                      \n"
893      "vmovl.u8        q8, d6                      \n"
894      "vmovl.u8        q9, d7                      \n"
895      "vqadd.s16       q1, q1, q8                  \n"
896      "vqadd.s16       q2, q2, q9                  \n"
897      "vqmovun.s16     d0, q1                      \n"
898      "vqmovun.s16     d1, q2                      \n"
899      "vst1.32         d0[0], [%[dst]], %[kBPS]    \n"
900      "vst1.32         d0[1], [%[dst]], %[kBPS]    \n"
901      "vst1.32         d1[0], [%[dst]], %[kBPS]    \n"
902      "vst1.32         d1[1], [%[dst]]             \n"
903      : [in] "+r"(in), [dst] "+r"(dst)  &bsol;* modified registers */
904      : [kBPS] "r"(kBPS), [constants] "r"(constants)  &bsol;* constants */
905      : "memory", "q0", "q1", "q2", "q8", "q9", "q10", "q11"  &bsol;* clobbered */
906    );
907  }
908  #endif    
909  static void TransformTwo_NEON(const int16_t* in, uint8_t* dst, int do_two) {
910    TransformOne_NEON(in, dst);
911    if (do_two) {
912      TransformOne_NEON(in + 16, dst + 4);
913    }
914  }
915  static void TransformDC_NEON(const int16_t* in, uint8_t* dst) {
916    const int16x8_t DC = vdupq_n_s16(in[0]);
917    Add4x4_NEON(DC, DC, dst);
918  }
919  #define STORE_WHT(dst, col, rows) do {                  \
920    *dst = vgetq_lane_s32(rows.val[0], col); (dst) += 16; \
921    *dst = vgetq_lane_s32(rows.val[1], col); (dst) += 16; \
922    *dst = vgetq_lane_s32(rows.val[2], col); (dst) += 16; \
923    *dst = vgetq_lane_s32(rows.val[3], col); (dst) += 16; \
924  } while (0)
925  static void TransformWHT_NEON(const int16_t* in, int16_t* out) {
926    int32x4x4_t tmp;
927    {
928      const int16x4_t in00_03 = vld1_s16(in + 0);
929      const int16x4_t in04_07 = vld1_s16(in + 4);
930      const int16x4_t in08_11 = vld1_s16(in + 8);
931      const int16x4_t in12_15 = vld1_s16(in + 12);
932      const int32x4_t a0 = vaddl_s16(in00_03, in12_15);  
933      const int32x4_t a1 = vaddl_s16(in04_07, in08_11);  
934      const int32x4_t a2 = vsubl_s16(in04_07, in08_11);  
935      const int32x4_t a3 = vsubl_s16(in00_03, in12_15);  
936      tmp.val[0] = vaddq_s32(a0, a1);
937      tmp.val[1] = vaddq_s32(a3, a2);
938      tmp.val[2] = vsubq_s32(a0, a1);
939      tmp.val[3] = vsubq_s32(a3, a2);
940      tmp = Transpose4x4_NEON(tmp);
941    }
942    {
943      const int32x4_t kCst3 = vdupq_n_s32(3);
944      const int32x4_t dc = vaddq_s32(tmp.val[0], kCst3);  
945      const int32x4_t a0 = vaddq_s32(dc, tmp.val[3]);
946      const int32x4_t a1 = vaddq_s32(tmp.val[1], tmp.val[2]);
947      const int32x4_t a2 = vsubq_s32(tmp.val[1], tmp.val[2]);
948      const int32x4_t a3 = vsubq_s32(dc, tmp.val[3]);
949      tmp.val[0] = vaddq_s32(a0, a1);
950      tmp.val[1] = vaddq_s32(a3, a2);
951      tmp.val[2] = vsubq_s32(a0, a1);
952      tmp.val[3] = vsubq_s32(a3, a2);
953      tmp.val[0] = vshrq_n_s32(tmp.val[0], 3);
954      tmp.val[1] = vshrq_n_s32(tmp.val[1], 3);
955      tmp.val[2] = vshrq_n_s32(tmp.val[2], 3);
956      tmp.val[3] = vshrq_n_s32(tmp.val[3], 3);
957      STORE_WHT(out, 0, tmp);
958      STORE_WHT(out, 1, tmp);
959      STORE_WHT(out, 2, tmp);
960      STORE_WHT(out, 3, tmp);
961    }
962  }
963  #undef STORE_WHT
964  #define MUL(a, b) (((a) * (b)) >> 16)
965  static void TransformAC3_NEON(const int16_t* in, uint8_t* dst) {
966    static const int kC1_full = 20091 + (1 << 16);
967    static const int kC2_full = 35468;
968    const int16x4_t A = vld1_dup_s16(in);
969    const int16x4_t c4 = vdup_n_s16(MUL(in[4], kC2_full));
970    const int16x4_t d4 = vdup_n_s16(MUL(in[4], kC1_full));
971    const int c1 = MUL(in[1], kC2_full);
972    const int d1 = MUL(in[1], kC1_full);
973    const uint64_t cd = (uint64_t)( d1 & 0xffff) <<  0 |
974                        (uint64_t)( c1 & 0xffff) << 16 |
975                        (uint64_t)(-c1 & 0xffff) << 32 |
976                        (uint64_t)(-d1 & 0xffff) << 48;
977    const int16x4_t CD = vcreate_s16(cd);
978    const int16x4_t B = vqadd_s16(A, CD);
979    const int16x8_t m0_m1 = vcombine_s16(vqadd_s16(B, d4), vqadd_s16(B, c4));
980    const int16x8_t m2_m3 = vcombine_s16(vqsub_s16(B, c4), vqsub_s16(B, d4));
981    Add4x4_NEON(m0_m1, m2_m3, dst);
982  }
983  #undef MUL
984  static void DC4_NEON(uint8_t* dst) {    
985    const uint8x8_t A = vld1_u8(dst - BPS);  
986    const uint16x4_t p0 = vpaddl_u8(A);  
987    const uint16x4_t p1 = vpadd_u16(p0, p0);
988    const uint16x8_t L0 = vmovl_u8(vld1_u8(dst + 0 * BPS - 1));
989    const uint16x8_t L1 = vmovl_u8(vld1_u8(dst + 1 * BPS - 1));
990    const uint16x8_t L2 = vmovl_u8(vld1_u8(dst + 2 * BPS - 1));
991    const uint16x8_t L3 = vmovl_u8(vld1_u8(dst + 3 * BPS - 1));
992    const uint16x8_t s0 = vaddq_u16(L0, L1);
993    const uint16x8_t s1 = vaddq_u16(L2, L3);
994    const uint16x8_t s01 = vaddq_u16(s0, s1);
995    const uint16x8_t sum = vaddq_u16(s01, vcombine_u16(p1, p1));
996    const uint8x8_t dc0 = vrshrn_n_u16(sum, 3);  
997    const uint8x8_t dc = vdup_lane_u8(dc0, 0);
998    int i;
999    for (i = 0; i < 4; ++i) {
1000      vst1_lane_u32((uint32_t*)(dst + i * BPS), vreinterpret_u32_u8(dc), 0);
1001    }
1002  }
1003  static WEBP_INLINE void TrueMotion_NEON(uint8_t* dst, int size) {
1004    const uint8x8_t TL = vld1_dup_u8(dst - BPS - 1);  
1005    const uint8x8_t T = vld1_u8(dst - BPS);  
1006    const int16x8_t d = vreinterpretq_s16_u16(vsubl_u8(T, TL));  
1007    int y;
1008    for (y = 0; y < size; y += 4) {
1009      const int16x8_t L0 = ConvertU8ToS16_NEON(vld1_dup_u8(dst + 0 * BPS - 1));
1010      const int16x8_t L1 = ConvertU8ToS16_NEON(vld1_dup_u8(dst + 1 * BPS - 1));
1011      const int16x8_t L2 = ConvertU8ToS16_NEON(vld1_dup_u8(dst + 2 * BPS - 1));
1012      const int16x8_t L3 = ConvertU8ToS16_NEON(vld1_dup_u8(dst + 3 * BPS - 1));
1013      const int16x8_t r0 = vaddq_s16(L0, d);  
1014      const int16x8_t r1 = vaddq_s16(L1, d);
1015      const int16x8_t r2 = vaddq_s16(L2, d);
1016      const int16x8_t r3 = vaddq_s16(L3, d);
1017      const uint32x2_t r0_u32 = vreinterpret_u32_u8(vqmovun_s16(r0));
1018      const uint32x2_t r1_u32 = vreinterpret_u32_u8(vqmovun_s16(r1));
1019      const uint32x2_t r2_u32 = vreinterpret_u32_u8(vqmovun_s16(r2));
1020      const uint32x2_t r3_u32 = vreinterpret_u32_u8(vqmovun_s16(r3));
1021      if (size == 4) {
1022        vst1_lane_u32((uint32_t*)(dst + 0 * BPS), r0_u32, 0);
1023        vst1_lane_u32((uint32_t*)(dst + 1 * BPS), r1_u32, 0);
1024        vst1_lane_u32((uint32_t*)(dst + 2 * BPS), r2_u32, 0);
1025        vst1_lane_u32((uint32_t*)(dst + 3 * BPS), r3_u32, 0);
1026      } else {
1027        vst1_u32((uint32_t*)(dst + 0 * BPS), r0_u32);
1028        vst1_u32((uint32_t*)(dst + 1 * BPS), r1_u32);
1029        vst1_u32((uint32_t*)(dst + 2 * BPS), r2_u32);
1030        vst1_u32((uint32_t*)(dst + 3 * BPS), r3_u32);
1031      }
<span onclick='openModal()' class='match'>1032      dst += 4 * BPS;
1033    }
1034  }
1035  static void TM4_NEON(uint8_t* dst) { TrueMotion_NEON(dst, 4); }
1036  static void VE4_NEON(uint8_t* dst) {    
1037    const uint64x1_t A0 = vreinterpret_u64_u8(vld1_u8(dst - BPS - 1));  
1038    const uint64x1_t A1 = vshr_n_u64(A0, 8);
</span>1039    const uint64x1_t A2 = vshr_n_u64(A0, 16);
1040    const uint8x8_t ABCDEFGH = vreinterpret_u8_u64(A0);
1041    const uint8x8_t BCDEFGH0 = vreinterpret_u8_u64(A1);
1042    const uint8x8_t CDEFGH00 = vreinterpret_u8_u64(A2);
1043    const uint8x8_t b = vhadd_u8(ABCDEFGH, CDEFGH00);
1044    const uint8x8_t avg = vrhadd_u8(b, BCDEFGH0);
1045    int i;
1046    for (i = 0; i < 4; ++i) {
1047      vst1_lane_u32((uint32_t*)(dst + i * BPS), vreinterpret_u32_u8(avg), 0);
1048    }
1049  }
1050  static void RD4_NEON(uint8_t* dst) {   
1051    const uint8x8_t XABCD_u8 = vld1_u8(dst - BPS - 1);
1052    const uint64x1_t XABCD = vreinterpret_u64_u8(XABCD_u8);
1053    const uint64x1_t ____XABC = vshl_n_u64(XABCD, 32);
1054    const uint32_t I = dst[-1 + 0 * BPS];
1055    const uint32_t J = dst[-1 + 1 * BPS];
1056    const uint32_t K = dst[-1 + 2 * BPS];
1057    const uint32_t L = dst[-1 + 3 * BPS];
1058    const uint64x1_t LKJI____ =
1059        vcreate_u64((uint64_t)L | (K << 8) | (J << 16) | (I << 24));
1060    const uint64x1_t LKJIXABC = vorr_u64(LKJI____, ____XABC);
1061    const uint8x8_t KJIXABC_ = vreinterpret_u8_u64(vshr_n_u64(LKJIXABC, 8));
1062    const uint8x8_t JIXABC__ = vreinterpret_u8_u64(vshr_n_u64(LKJIXABC, 16));
1063    const uint8_t D = vget_lane_u8(XABCD_u8, 4);
1064    const uint8x8_t JIXABCD_ = vset_lane_u8(D, JIXABC__, 6);
1065    const uint8x8_t LKJIXABC_u8 = vreinterpret_u8_u64(LKJIXABC);
1066    const uint8x8_t avg1 = vhadd_u8(JIXABCD_, LKJIXABC_u8);
1067    const uint8x8_t avg2 = vrhadd_u8(avg1, KJIXABC_);
1068    const uint64x1_t avg2_u64 = vreinterpret_u64_u8(avg2);
1069    const uint32x2_t r3 = vreinterpret_u32_u8(avg2);
1070    const uint32x2_t r2 = vreinterpret_u32_u64(vshr_n_u64(avg2_u64, 8));
1071    const uint32x2_t r1 = vreinterpret_u32_u64(vshr_n_u64(avg2_u64, 16));
1072    const uint32x2_t r0 = vreinterpret_u32_u64(vshr_n_u64(avg2_u64, 24));
1073    vst1_lane_u32((uint32_t*)(dst + 0 * BPS), r0, 0);
1074    vst1_lane_u32((uint32_t*)(dst + 1 * BPS), r1, 0);
1075    vst1_lane_u32((uint32_t*)(dst + 2 * BPS), r2, 0);
1076    vst1_lane_u32((uint32_t*)(dst + 3 * BPS), r3, 0);
1077  }
1078  static void LD4_NEON(uint8_t* dst) {    
1079    const uint8x8_t ABCDEFGH = vld1_u8(dst - BPS + 0);
1080    const uint8x8_t BCDEFGH0 = vld1_u8(dst - BPS + 1);
1081    const uint8x8_t CDEFGH00 = vld1_u8(dst - BPS + 2);
1082    const uint8x8_t CDEFGHH0 = vset_lane_u8(dst[-BPS + 7], CDEFGH00, 6);
1083    const uint8x8_t avg1 = vhadd_u8(ABCDEFGH, CDEFGHH0);
1084    const uint8x8_t avg2 = vrhadd_u8(avg1, BCDEFGH0);
1085    const uint64x1_t avg2_u64 = vreinterpret_u64_u8(avg2);
1086    const uint32x2_t r0 = vreinterpret_u32_u8(avg2);
1087    const uint32x2_t r1 = vreinterpret_u32_u64(vshr_n_u64(avg2_u64, 8));
1088    const uint32x2_t r2 = vreinterpret_u32_u64(vshr_n_u64(avg2_u64, 16));
1089    const uint32x2_t r3 = vreinterpret_u32_u64(vshr_n_u64(avg2_u64, 24));
1090    vst1_lane_u32((uint32_t*)(dst + 0 * BPS), r0, 0);
1091    vst1_lane_u32((uint32_t*)(dst + 1 * BPS), r1, 0);
1092    vst1_lane_u32((uint32_t*)(dst + 2 * BPS), r2, 0);
1093    vst1_lane_u32((uint32_t*)(dst + 3 * BPS), r3, 0);
1094  }
1095  static void VE8uv_NEON(uint8_t* dst) {    
1096    const uint8x8_t top = vld1_u8(dst - BPS);
1097    int j;
1098    for (j = 0; j < 8; ++j) {
1099      vst1_u8(dst + j * BPS, top);
1100    }
1101  }
1102  static void HE8uv_NEON(uint8_t* dst) {    
1103    int j;
1104    for (j = 0; j < 8; ++j) {
1105      const uint8x8_t left = vld1_dup_u8(dst - 1);
1106      vst1_u8(dst, left);
1107      dst += BPS;
1108    }
1109  }
1110  static WEBP_INLINE void DC8_NEON(uint8_t* dst, int do_top, int do_left) {
1111    uint16x8_t sum_top;
1112    uint16x8_t sum_left;
1113    uint8x8_t dc0;
1114    if (do_top) {
1115      const uint8x8_t A = vld1_u8(dst - BPS);  
1116  #if defined(__aarch64__)
1117      const uint16x8_t B = vmovl_u8(A);
1118      const uint16_t p2 = vaddvq_u16(B);
1119      sum_top = vdupq_n_u16(p2);
1120  #else
1121      const uint16x4_t p0 = vpaddl_u8(A);  
1122      const uint16x4_t p1 = vpadd_u16(p0, p0);
1123      const uint16x4_t p2 = vpadd_u16(p1, p1);
1124      sum_top = vcombine_u16(p2, p2);
1125  #endif
1126    }
1127    if (do_left) {
1128      const uint16x8_t L0 = vmovl_u8(vld1_u8(dst + 0 * BPS - 1));
1129      const uint16x8_t L1 = vmovl_u8(vld1_u8(dst + 1 * BPS - 1));
1130      const uint16x8_t L2 = vmovl_u8(vld1_u8(dst + 2 * BPS - 1));
1131      const uint16x8_t L3 = vmovl_u8(vld1_u8(dst + 3 * BPS - 1));
1132      const uint16x8_t L4 = vmovl_u8(vld1_u8(dst + 4 * BPS - 1));
1133      const uint16x8_t L5 = vmovl_u8(vld1_u8(dst + 5 * BPS - 1));
1134      const uint16x8_t L6 = vmovl_u8(vld1_u8(dst + 6 * BPS - 1));
1135      const uint16x8_t L7 = vmovl_u8(vld1_u8(dst + 7 * BPS - 1));
1136      const uint16x8_t s0 = vaddq_u16(L0, L1);
1137      const uint16x8_t s1 = vaddq_u16(L2, L3);
1138      const uint16x8_t s2 = vaddq_u16(L4, L5);
1139      const uint16x8_t s3 = vaddq_u16(L6, L7);
1140      const uint16x8_t s01 = vaddq_u16(s0, s1);
1141      const uint16x8_t s23 = vaddq_u16(s2, s3);
1142      sum_left = vaddq_u16(s01, s23);
1143    }
1144    if (do_top && do_left) {
1145      const uint16x8_t sum = vaddq_u16(sum_left, sum_top);
1146      dc0 = vrshrn_n_u16(sum, 4);
1147    } else if (do_top) {
1148      dc0 = vrshrn_n_u16(sum_top, 3);
1149    } else if (do_left) {
1150      dc0 = vrshrn_n_u16(sum_left, 3);
1151    } else {
1152      dc0 = vdup_n_u8(0x80);
1153    }
1154    {
1155      const uint8x8_t dc = vdup_lane_u8(dc0, 0);
1156      int i;
1157      for (i = 0; i < 8; ++i) {
1158        vst1_u32((uint32_t*)(dst + i * BPS), vreinterpret_u32_u8(dc));
1159      }
1160    }
1161  }
1162  static void DC8uv_NEON(uint8_t* dst) { DC8_NEON(dst, 1, 1); }
1163  static void DC8uvNoTop_NEON(uint8_t* dst) { DC8_NEON(dst, 0, 1); }
1164  static void DC8uvNoLeft_NEON(uint8_t* dst) { DC8_NEON(dst, 1, 0); }
1165  static void DC8uvNoTopLeft_NEON(uint8_t* dst) { DC8_NEON(dst, 0, 0); }
1166  static void TM8uv_NEON(uint8_t* dst) { TrueMotion_NEON(dst, 8); }
1167  static void VE16_NEON(uint8_t* dst) {     
1168    const uint8x16_t top = vld1q_u8(dst - BPS);
1169    int j;
1170    for (j = 0; j < 16; ++j) {
1171      vst1q_u8(dst + j * BPS, top);
1172    }
1173  }
1174  static void HE16_NEON(uint8_t* dst) {     
1175    int j;
1176    for (j = 0; j < 16; ++j) {
1177      const uint8x16_t left = vld1q_dup_u8(dst - 1);
1178      vst1q_u8(dst, left);
1179      dst += BPS;
1180    }
1181  }
1182  static WEBP_INLINE void DC16_NEON(uint8_t* dst, int do_top, int do_left) {
1183    uint16x8_t sum_top;
1184    uint16x8_t sum_left;
1185    uint8x8_t dc0;
1186    if (do_top) {
1187      const uint8x16_t A = vld1q_u8(dst - BPS);  
1188      const uint16x8_t p0 = vpaddlq_u8(A);  
1189      const uint16x4_t p1 = vadd_u16(vget_low_u16(p0), vget_high_u16(p0));
1190      const uint16x4_t p2 = vpadd_u16(p1, p1);
1191      const uint16x4_t p3 = vpadd_u16(p2, p2);
1192      sum_top = vcombine_u16(p3, p3);
1193    }
1194    if (do_left) {
1195      int i;
1196      sum_left = vdupq_n_u16(0);
1197      for (i = 0; i < 16; i += 8) {
1198        const uint16x8_t L0 = vmovl_u8(vld1_u8(dst + (i + 0) * BPS - 1));
1199        const uint16x8_t L1 = vmovl_u8(vld1_u8(dst + (i + 1) * BPS - 1));
1200        const uint16x8_t L2 = vmovl_u8(vld1_u8(dst + (i + 2) * BPS - 1));
1201        const uint16x8_t L3 = vmovl_u8(vld1_u8(dst + (i + 3) * BPS - 1));
1202        const uint16x8_t L4 = vmovl_u8(vld1_u8(dst + (i + 4) * BPS - 1));
1203        const uint16x8_t L5 = vmovl_u8(vld1_u8(dst + (i + 5) * BPS - 1));
1204        const uint16x8_t L6 = vmovl_u8(vld1_u8(dst + (i + 6) * BPS - 1));
1205        const uint16x8_t L7 = vmovl_u8(vld1_u8(dst + (i + 7) * BPS - 1));
1206        const uint16x8_t s0 = vaddq_u16(L0, L1);
1207        const uint16x8_t s1 = vaddq_u16(L2, L3);
1208        const uint16x8_t s2 = vaddq_u16(L4, L5);
1209        const uint16x8_t s3 = vaddq_u16(L6, L7);
1210        const uint16x8_t s01 = vaddq_u16(s0, s1);
1211        const uint16x8_t s23 = vaddq_u16(s2, s3);
1212        const uint16x8_t sum = vaddq_u16(s01, s23);
1213        sum_left = vaddq_u16(sum_left, sum);
1214      }
1215    }
1216    if (do_top && do_left) {
1217      const uint16x8_t sum = vaddq_u16(sum_left, sum_top);
1218      dc0 = vrshrn_n_u16(sum, 5);
1219    } else if (do_top) {
1220      dc0 = vrshrn_n_u16(sum_top, 4);
1221    } else if (do_left) {
1222      dc0 = vrshrn_n_u16(sum_left, 4);
1223    } else {
1224      dc0 = vdup_n_u8(0x80);
1225    }
1226    {
1227      const uint8x16_t dc = vdupq_lane_u8(dc0, 0);
1228      int i;
1229      for (i = 0; i < 16; ++i) {
1230        vst1q_u8(dst + i * BPS, dc);
1231      }
1232    }
1233  }
1234  static void DC16TopLeft_NEON(uint8_t* dst) { DC16_NEON(dst, 1, 1); }
1235  static void DC16NoTop_NEON(uint8_t* dst) { DC16_NEON(dst, 0, 1); }
1236  static void DC16NoLeft_NEON(uint8_t* dst) { DC16_NEON(dst, 1, 0); }
1237  static void DC16NoTopLeft_NEON(uint8_t* dst) { DC16_NEON(dst, 0, 0); }
1238  static void TM16_NEON(uint8_t* dst) {
1239    const uint8x8_t TL = vld1_dup_u8(dst - BPS - 1);  
1240    const uint8x16_t T = vld1q_u8(dst - BPS);  
1241    const int16x8_t d_lo = vreinterpretq_s16_u16(vsubl_u8(vget_low_u8(T), TL));
1242    const int16x8_t d_hi = vreinterpretq_s16_u16(vsubl_u8(vget_high_u8(T), TL));
1243    int y;
1244    for (y = 0; y < 16; y += 4) {
1245      const int16x8_t L0 = ConvertU8ToS16_NEON(vld1_dup_u8(dst + 0 * BPS - 1));
1246      const int16x8_t L1 = ConvertU8ToS16_NEON(vld1_dup_u8(dst + 1 * BPS - 1));
1247      const int16x8_t L2 = ConvertU8ToS16_NEON(vld1_dup_u8(dst + 2 * BPS - 1));
1248      const int16x8_t L3 = ConvertU8ToS16_NEON(vld1_dup_u8(dst + 3 * BPS - 1));
1249      const int16x8_t r0_lo = vaddq_s16(L0, d_lo);  
1250      const int16x8_t r1_lo = vaddq_s16(L1, d_lo);
1251      const int16x8_t r2_lo = vaddq_s16(L2, d_lo);
1252      const int16x8_t r3_lo = vaddq_s16(L3, d_lo);
1253      const int16x8_t r0_hi = vaddq_s16(L0, d_hi);
1254      const int16x8_t r1_hi = vaddq_s16(L1, d_hi);
1255      const int16x8_t r2_hi = vaddq_s16(L2, d_hi);
1256      const int16x8_t r3_hi = vaddq_s16(L3, d_hi);
1257      const uint8x16_t row0 = vcombine_u8(vqmovun_s16(r0_lo), vqmovun_s16(r0_hi));
1258      const uint8x16_t row1 = vcombine_u8(vqmovun_s16(r1_lo), vqmovun_s16(r1_hi));
1259      const uint8x16_t row2 = vcombine_u8(vqmovun_s16(r2_lo), vqmovun_s16(r2_hi));
1260      const uint8x16_t row3 = vcombine_u8(vqmovun_s16(r3_lo), vqmovun_s16(r3_hi));
1261      vst1q_u8(dst + 0 * BPS, row0);
1262      vst1q_u8(dst + 1 * BPS, row1);
1263      vst1q_u8(dst + 2 * BPS, row2);
1264      vst1q_u8(dst + 3 * BPS, row3);
1265      dst += 4 * BPS;
1266    }
1267  }
1268  extern void VP8DspInitNEON(void);
1269  WEBP_TSAN_IGNORE_FUNCTION void VP8DspInitNEON(void) {
1270    VP8Transform = TransformTwo_NEON;
1271    VP8TransformAC3 = TransformAC3_NEON;
1272    VP8TransformDC = TransformDC_NEON;
1273    VP8TransformWHT = TransformWHT_NEON;
1274    VP8VFilter16 = VFilter16_NEON;
1275    VP8VFilter16i = VFilter16i_NEON;
1276    VP8HFilter16 = HFilter16_NEON;
1277  #if !defined(WORK_AROUND_GCC)
1278    VP8HFilter16i = HFilter16i_NEON;
1279  #endif
1280    VP8VFilter8 = VFilter8_NEON;
1281    VP8VFilter8i = VFilter8i_NEON;
1282  #if !defined(WORK_AROUND_GCC)
1283    VP8HFilter8 = HFilter8_NEON;
1284    VP8HFilter8i = HFilter8i_NEON;
1285  #endif
1286    VP8SimpleVFilter16 = SimpleVFilter16_NEON;
1287    VP8SimpleHFilter16 = SimpleHFilter16_NEON;
1288    VP8SimpleVFilter16i = SimpleVFilter16i_NEON;
1289    VP8SimpleHFilter16i = SimpleHFilter16i_NEON;
1290    VP8PredLuma4[0] = DC4_NEON;
1291    VP8PredLuma4[1] = TM4_NEON;
1292    VP8PredLuma4[2] = VE4_NEON;
1293    VP8PredLuma4[4] = RD4_NEON;
1294    VP8PredLuma4[6] = LD4_NEON;
1295    VP8PredLuma16[0] = DC16TopLeft_NEON;
1296    VP8PredLuma16[1] = TM16_NEON;
1297    VP8PredLuma16[2] = VE16_NEON;
1298    VP8PredLuma16[3] = HE16_NEON;
1299    VP8PredLuma16[4] = DC16NoTop_NEON;
1300    VP8PredLuma16[5] = DC16NoLeft_NEON;
1301    VP8PredLuma16[6] = DC16NoTopLeft_NEON;
1302    VP8PredChroma8[0] = DC8uv_NEON;
1303    VP8PredChroma8[1] = TM8uv_NEON;
1304    VP8PredChroma8[2] = VE8uv_NEON;
1305    VP8PredChroma8[3] = HE8uv_NEON;
1306    VP8PredChroma8[4] = DC8uvNoTop_NEON;
1307    VP8PredChroma8[5] = DC8uvNoLeft_NEON;
1308    VP8PredChroma8[6] = DC8uvNoTopLeft_NEON;
1309  }
1310  #else  
1311  WEBP_DSP_INIT_STUB(VP8DspInitNEON)
1312  #endif  
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from PINRemoteImage-MDEwOlJlcG9zaXRvcnkzOTUzNzEwMw==-flat-dec.c</div>
                <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from PINRemoteImage-MDEwOlJlcG9zaXRvcnkzOTUzNzEwMw==-flat-dec_neon.c</div>
                <div class="column column_space"><pre><code>180      DC += dst[i - BPS];
181    }
182    Put16(DC >> 4, dst);
183  }
184  static void DC16NoTopLeft_C(uint8_t* dst) {  
185    Put16(0x80, dst);
186  }
187  #endif  
188  VP8PredFunc VP8PredLuma16[NUM_B_DC_MODES];
189  #define AVG3(a, b, c) ((uint8_t)(((a) + 2 * (b) + (c) + 2) >> 2))
190  #define AVG2(a, b) (((a) + (b) + 1) >> 1)
191  #if !WEBP_NEON_OMIT_C_CODE
192  static void VE4_C(uint8_t* dst) {    
193    const uint8_t* top = dst - BPS;
194    const uint8_t vals[4] = {
</pre></code></div>
                <div class="column column_space"><pre><code>1032      dst += 4 * BPS;
1033    }
1034  }
1035  static void TM4_NEON(uint8_t* dst) { TrueMotion_NEON(dst, 4); }
1036  static void VE4_NEON(uint8_t* dst) {    
1037    const uint64x1_t A0 = vreinterpret_u64_u8(vld1_u8(dst - BPS - 1));  
1038    const uint64x1_t A1 = vshr_n_u64(A0, 8);
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    