
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 32, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>Adafruit_nRF52_Arduino-MDEwOlJlcG9zaXRvcnk3NDM1NDcyOQ==-flat-nrf_ipc.h</h3>
            <pre><code>1  #ifndef NRF_IPC_H__
2  #define NRF_IPC_H__
3  #include <nrfx.h>
4  #ifdef __cplusplus
5  extern "C" {
6  #endif
7  typedef enum
8  {
9      NRF_IPC_TASK_SEND_0  = offsetof(NRF_IPC_Type, TASKS_SEND[0]),  
10      NRF_IPC_TASK_SEND_1  = offsetof(NRF_IPC_Type, TASKS_SEND[1]),  
11      NRF_IPC_TASK_SEND_2  = offsetof(NRF_IPC_Type, TASKS_SEND[2]),  
12      NRF_IPC_TASK_SEND_3  = offsetof(NRF_IPC_Type, TASKS_SEND[3]),  
13      NRF_IPC_TASK_SEND_4  = offsetof(NRF_IPC_Type, TASKS_SEND[4]),  
14      NRF_IPC_TASK_SEND_5  = offsetof(NRF_IPC_Type, TASKS_SEND[5]),  
15      NRF_IPC_TASK_SEND_6  = offsetof(NRF_IPC_Type, TASKS_SEND[6]),  
16      NRF_IPC_TASK_SEND_7  = offsetof(NRF_IPC_Type, TASKS_SEND[7]),  
17  #if (IPC_TASKS_NUM > 8) || defined(__NRFX_DOXYGEN__)
18      NRF_IPC_TASK_SEND_8  = offsetof(NRF_IPC_Type, TASKS_SEND[8]),  
19      NRF_IPC_TASK_SEND_9  = offsetof(NRF_IPC_Type, TASKS_SEND[9]),  
20      NRF_IPC_TASK_SEND_10 = offsetof(NRF_IPC_Type, TASKS_SEND[10]), 
21      NRF_IPC_TASK_SEND_11 = offsetof(NRF_IPC_Type, TASKS_SEND[11]), 
22      NRF_IPC_TASK_SEND_12 = offsetof(NRF_IPC_Type, TASKS_SEND[12]), 
23      NRF_IPC_TASK_SEND_13 = offsetof(NRF_IPC_Type, TASKS_SEND[13]), 
24      NRF_IPC_TASK_SEND_14 = offsetof(NRF_IPC_Type, TASKS_SEND[14]), 
25      NRF_IPC_TASK_SEND_15 = offsetof(NRF_IPC_Type, TASKS_SEND[15]), 
26  #endif 
27  } nrf_ipc_task_t;
28  typedef enum
29  {
30      NRF_IPC_EVENT_RECEIVE_0  = offsetof(NRF_IPC_Type, EVENTS_RECEIVE[0]),  
31      NRF_IPC_EVENT_RECEIVE_1  = offsetof(NRF_IPC_Type, EVENTS_RECEIVE[1]),  
32      NRF_IPC_EVENT_RECEIVE_2  = offsetof(NRF_IPC_Type, EVENTS_RECEIVE[2]),  
33      NRF_IPC_EVENT_RECEIVE_3  = offsetof(NRF_IPC_Type, EVENTS_RECEIVE[3]),  
34      NRF_IPC_EVENT_RECEIVE_4  = offsetof(NRF_IPC_Type, EVENTS_RECEIVE[4]),  
35      NRF_IPC_EVENT_RECEIVE_5  = offsetof(NRF_IPC_Type, EVENTS_RECEIVE[5]),  
36      NRF_IPC_EVENT_RECEIVE_6  = offsetof(NRF_IPC_Type, EVENTS_RECEIVE[6]),  
37      NRF_IPC_EVENT_RECEIVE_7  = offsetof(NRF_IPC_Type, EVENTS_RECEIVE[7]),  
38  #if (IPC_EVENTS_NUM > 8) || defined(__NRFX_DOXYGEN__)
39      NRF_IPC_EVENT_RECEIVE_8  = offsetof(NRF_IPC_Type, EVENTS_RECEIVE[8]),  
40      NRF_IPC_EVENT_RECEIVE_9  = offsetof(NRF_IPC_Type, EVENTS_RECEIVE[9]),  
41      NRF_IPC_EVENT_RECEIVE_10 = offsetof(NRF_IPC_Type, EVENTS_RECEIVE[10]), 
42      NRF_IPC_EVENT_RECEIVE_11 = offsetof(NRF_IPC_Type, EVENTS_RECEIVE[11]), 
43      NRF_IPC_EVENT_RECEIVE_12 = offsetof(NRF_IPC_Type, EVENTS_RECEIVE[12]), 
44      NRF_IPC_EVENT_RECEIVE_13 = offsetof(NRF_IPC_Type, EVENTS_RECEIVE[13]), 
45      NRF_IPC_EVENT_RECEIVE_14 = offsetof(NRF_IPC_Type, EVENTS_RECEIVE[14]), 
46      NRF_IPC_EVENT_RECEIVE_15 = offsetof(NRF_IPC_Type, EVENTS_RECEIVE[15]), 
47  #endif 
48  } nrf_ipc_event_t;
49  typedef enum
50  {
51      NRF_IPC_CHANNEL_0 = IPC_RECEIVE_CNF_CHEN0_Msk,   
52      NRF_IPC_CHANNEL_1 = IPC_RECEIVE_CNF_CHEN1_Msk,   
53      NRF_IPC_CHANNEL_2 = IPC_RECEIVE_CNF_CHEN2_Msk,   
54      NRF_IPC_CHANNEL_3 = IPC_RECEIVE_CNF_CHEN3_Msk,   
55      NRF_IPC_CHANNEL_4 = IPC_RECEIVE_CNF_CHEN4_Msk,   
56      NRF_IPC_CHANNEL_5 = IPC_RECEIVE_CNF_CHEN5_Msk,   
57      NRF_IPC_CHANNEL_6 = IPC_RECEIVE_CNF_CHEN6_Msk,   
58      NRF_IPC_CHANNEL_7 = IPC_RECEIVE_CNF_CHEN7_Msk,   
59  #if (IPC_CH_NUM > 8) || defined(__NRFX_DOXYGEN__)
60      NRF_IPC_CHANNEL_8  = IPC_RECEIVE_CNF_CHEN8_Msk,  
61      NRF_IPC_CHANNEL_9  = IPC_RECEIVE_CNF_CHEN9_Msk,  
62      NRF_IPC_CHANNEL_10 = IPC_RECEIVE_CNF_CHEN10_Msk, 
63      NRF_IPC_CHANNEL_11 = IPC_RECEIVE_CNF_CHEN11_Msk, 
64      NRF_IPC_CHANNEL_12 = IPC_RECEIVE_CNF_CHEN12_Msk, 
65      NRF_IPC_CHANNEL_13 = IPC_RECEIVE_CNF_CHEN13_Msk, 
66      NRF_IPC_CHANNEL_14 = IPC_RECEIVE_CNF_CHEN14_Msk, 
67      NRF_IPC_CHANNEL_15 = IPC_RECEIVE_CNF_CHEN15_Msk, 
68  #endif 
69  } nrf_ipc_channel_t;
70  typedef enum
71  {
72      NRF_IPC_INT_RECEIVE_0  = IPC_INTEN_RECEIVE0_Msk,  
73      NRF_IPC_INT_RECEIVE_1  = IPC_INTEN_RECEIVE1_Msk,  
74      NRF_IPC_INT_RECEIVE_2  = IPC_INTEN_RECEIVE2_Msk,  
75      NRF_IPC_INT_RECEIVE_3  = IPC_INTEN_RECEIVE3_Msk,  
76      NRF_IPC_INT_RECEIVE_4  = IPC_INTEN_RECEIVE4_Msk,  
77      NRF_IPC_INT_RECEIVE_5  = IPC_INTEN_RECEIVE5_Msk,  
78      NRF_IPC_INT_RECEIVE_6  = IPC_INTEN_RECEIVE6_Msk,  
79      NRF_IPC_INT_RECEIVE_7  = IPC_INTEN_RECEIVE7_Msk,  
80  #if (IPC_EVENTS_NUM > 8) || defined(__NRFX_DOXYGEN__)
81      NRF_IPC_INT_RECEIVE_8  = IPC_INTEN_RECEIVE8_Msk,  
82      NRF_IPC_INT_RECEIVE_9  = IPC_INTEN_RECEIVE9_Msk,  
83      NRF_IPC_INT_RECEIVE_10 = IPC_INTEN_RECEIVE10_Msk, 
84      NRF_IPC_INT_RECEIVE_11 = IPC_INTEN_RECEIVE11_Msk, 
85      NRF_IPC_INT_RECEIVE_12 = IPC_INTEN_RECEIVE12_Msk, 
86      NRF_IPC_INT_RECEIVE_13 = IPC_INTEN_RECEIVE13_Msk, 
87      NRF_IPC_INT_RECEIVE_14 = IPC_INTEN_RECEIVE14_Msk, 
88      NRF_IPC_INT_RECEIVE_15 = IPC_INTEN_RECEIVE15_Msk, 
89  #endif 
90  } nrf_ipc_int_mask_t;
91  NRF_STATIC_INLINE void nrf_ipc_task_trigger(NRF_IPC_Type * p_reg, nrf_ipc_task_t task);
92  NRF_STATIC_INLINE uint32_t nrf_ipc_task_address_get(NRF_IPC_Type const * p_reg,
93                                                      nrf_ipc_task_t       task);
94  NRF_STATIC_INLINE void nrf_ipc_event_clear(NRF_IPC_Type * p_reg, nrf_ipc_event_t event);
95  NRF_STATIC_INLINE bool nrf_ipc_event_check(NRF_IPC_Type const * p_reg, nrf_ipc_event_t event);
96  NRF_STATIC_INLINE uint32_t nrf_ipc_event_address_get(NRF_IPC_Type const * p_reg,
97                                                       nrf_ipc_event_t      event);
98  NRF_STATIC_INLINE void nrf_ipc_int_enable(NRF_IPC_Type * p_reg, uint32_t mask);
99  NRF_STATIC_INLINE void nrf_ipc_int_disable(NRF_IPC_Type * p_reg, uint32_t mask);
100  NRF_STATIC_INLINE uint32_t nrf_ipc_int_enable_check(NRF_IPC_Type const * p_reg, uint32_t mask);
101  NRF_STATIC_INLINE uint32_t nrf_ipc_int_pending_get(NRF_IPC_Type const * p_reg);
102  NRF_STATIC_INLINE void nrf_ipc_subscribe_set(NRF_IPC_Type * p_reg,
103                                               nrf_ipc_task_t task,
104                                               uint8_t        channel);
105  NRF_STATIC_INLINE void nrf_ipc_subscribe_clear(NRF_IPC_Type * p_reg, nrf_ipc_task_t task);
106  NRF_STATIC_INLINE void nrf_ipc_publish_set(NRF_IPC_Type *  p_reg,
107                                             nrf_ipc_event_t event,
108                                             uint8_t         channel);
109  NRF_STATIC_INLINE void nrf_ipc_publish_clear(NRF_IPC_Type * p_reg, nrf_ipc_event_t event);
110  NRF_STATIC_INLINE void nrf_ipc_send_config_set(NRF_IPC_Type * p_reg,
111                                                 uint8_t        index,
<span onclick='openModal()' class='match'>112                                                 uint32_t       channels_mask);
113  NRF_STATIC_INLINE uint32_t nrf_ipc_send_config_get(NRF_IPC_Type * const p_reg, uint8_t index);
114  NRF_STATIC_INLINE void nrf_ipc_receive_config_set(NRF_IPC_Type * p_reg,
115                                                    uint8_t        index,
116                                                    uint32_t       channels_mask);
117  NRF_STATIC_INLINE uint32_t nrf_ipc_receive_config_get(NRF_IPC_Type * const p_reg, uint8_t index);
</span>118  NRF_STATIC_INLINE void nrf_ipc_gpmem_set(NRF_IPC_Type * p_reg,
119                                           uint8_t        index,
120                                           uint32_t       data);
121  NRF_STATIC_INLINE uint32_t nrf_ipc_gpmem_get(NRF_IPC_Type const * p_reg, uint8_t index);
122  NRF_STATIC_INLINE nrf_ipc_task_t nrf_ipc_send_task_get(uint8_t index);
123  NRF_STATIC_INLINE nrf_ipc_event_t nrf_ipc_receive_event_get(uint8_t index);
124  #ifndef NRF_DECLARE_ONLY
125  NRF_STATIC_INLINE void nrf_ipc_task_trigger(NRF_IPC_Type * p_reg, nrf_ipc_task_t task)
126  {
127      *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
128  }
129  NRF_STATIC_INLINE uint32_t nrf_ipc_task_address_get(NRF_IPC_Type const * p_reg,
130                                                      nrf_ipc_task_t       task)
131  {
132      return ((uint32_t)p_reg + (uint32_t)task);
133  }
134  NRF_STATIC_INLINE void nrf_ipc_event_clear(NRF_IPC_Type * p_reg, nrf_ipc_event_t event)
135  {
136      *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
137  }
138  NRF_STATIC_INLINE bool nrf_ipc_event_check(NRF_IPC_Type const * p_reg, nrf_ipc_event_t event)
139  {
140      return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
141  }
142  NRF_STATIC_INLINE uint32_t nrf_ipc_event_address_get(NRF_IPC_Type const * p_reg,
143                                                       nrf_ipc_event_t      event)
144  {
145      return ((uint32_t)p_reg + (uint32_t)event);
146  }
147  NRF_STATIC_INLINE void nrf_ipc_int_enable(NRF_IPC_Type * p_reg, uint32_t mask)
148  {
149      p_reg->INTENSET = mask;
150  }
151  NRF_STATIC_INLINE void nrf_ipc_int_disable(NRF_IPC_Type * p_reg, uint32_t mask)
152  {
153      p_reg->INTENCLR = mask;
154  }
155  NRF_STATIC_INLINE uint32_t nrf_ipc_int_enable_check(NRF_IPC_Type const * p_reg, uint32_t mask)
156  {
157      return p_reg->INTENSET & mask;
158  }
159  NRF_STATIC_INLINE uint32_t nrf_ipc_int_pending_get(NRF_IPC_Type const * p_reg)
160  {
161      return p_reg->INTPEND;
162  }
163  NRF_STATIC_INLINE void nrf_ipc_subscribe_set(NRF_IPC_Type * p_reg,
164                                               nrf_ipc_task_t task,
165                                               uint8_t        channel)
166  {
167      *((volatile uint32_t *) ((uint8_t *) p_reg + (uint32_t) task + 0x80uL)) =
168              ((uint32_t)channel | IPC_SUBSCRIBE_SEND_EN_Msk);
169  }
170  NRF_STATIC_INLINE void nrf_ipc_subscribe_clear(NRF_IPC_Type * p_reg, nrf_ipc_task_t task)
171  {
172      *((volatile uint32_t *) ((uint8_t *) p_reg + (uint32_t) task + 0x80uL)) = 0;
173  }
174  NRF_STATIC_INLINE void nrf_ipc_publish_set(NRF_IPC_Type *  p_reg,
175                                             nrf_ipc_event_t event,
176                                             uint8_t         channel)
177  {
178      *((volatile uint32_t *) ((uint8_t *) p_reg + (uint32_t) event + 0x80uL)) =
179              ((uint32_t)channel | IPC_PUBLISH_RECEIVE_EN_Msk);
180  }
181  NRF_STATIC_INLINE void nrf_ipc_publish_clear(NRF_IPC_Type *  p_reg, nrf_ipc_event_t event)
182  {
183      *((volatile uint32_t *) ((uint8_t *) p_reg + (uint32_t) event + 0x80uL)) = 0;
184  }
185  NRF_STATIC_INLINE void nrf_ipc_send_config_set(NRF_IPC_Type * p_reg,
186                                                 uint8_t        index,
187                                                 uint32_t       channels_mask)
188  {
189      p_reg->SEND_CNF[index] = channels_mask;
190  }
191  NRF_STATIC_INLINE uint32_t nrf_ipc_send_config_get(NRF_IPC_Type * const p_reg, uint8_t index)
192  {
193      return p_reg->SEND_CNF[index];
194  }
195  NRF_STATIC_INLINE void nrf_ipc_receive_config_set(NRF_IPC_Type * p_reg,
196                                                    uint8_t        index,
197                                                    uint32_t       channels_mask)
198  {
199      p_reg->RECEIVE_CNF[index] = channels_mask;
200  }
201  NRF_STATIC_INLINE uint32_t nrf_ipc_receive_config_get(NRF_IPC_Type * const p_reg, uint8_t index)
202  {
203      return p_reg->RECEIVE_CNF[index];
204  }
205  NRF_STATIC_INLINE void nrf_ipc_gpmem_set(NRF_IPC_Type * p_reg,
206                                           uint8_t        index,
207                                           uint32_t       data)
208  {
209      NRFX_ASSERT(index < IPC_GPMEM_NUM);
210      p_reg->GPMEM[index] = data;
211  }
212  NRF_STATIC_INLINE uint32_t nrf_ipc_gpmem_get(NRF_IPC_Type const * p_reg,  uint8_t index)
213  {
214      NRFX_ASSERT(index < IPC_GPMEM_NUM);
215      return p_reg->GPMEM[index];
216  }
217  NRF_STATIC_INLINE nrf_ipc_task_t nrf_ipc_send_task_get(uint8_t index)
218  {
219      NRFX_ASSERT(index < IPC_CH_NUM);
220      return (nrf_ipc_task_t)(NRFX_OFFSETOF(NRF_IPC_Type, TASKS_SEND[index]));
221  }
222  NRF_STATIC_INLINE nrf_ipc_event_t nrf_ipc_receive_event_get(uint8_t index)
223  {
224      NRFX_ASSERT(index < IPC_CH_NUM);
225      return (nrf_ipc_event_t)(NRFX_OFFSETOF(NRF_IPC_Type, EVENTS_RECEIVE[index]));
226  }
227  #endif 
228  #ifdef __cplusplus
229  }
230  #endif
231  #endif 
</code></pre>
        </div>
        <div class="column">
            <h3>Adafruit_nRF52_Arduino-MDEwOlJlcG9zaXRvcnk3NDM1NDcyOQ==-flat-nrf_ipc.h</h3>
            <pre><code>1  #ifndef NRF_IPC_H__
2  #define NRF_IPC_H__
3  #include <nrfx.h>
4  #ifdef __cplusplus
5  extern "C" {
6  #endif
7  typedef enum
8  {
9      NRF_IPC_TASK_SEND_0  = offsetof(NRF_IPC_Type, TASKS_SEND[0]),  
10      NRF_IPC_TASK_SEND_1  = offsetof(NRF_IPC_Type, TASKS_SEND[1]),  
11      NRF_IPC_TASK_SEND_2  = offsetof(NRF_IPC_Type, TASKS_SEND[2]),  
12      NRF_IPC_TASK_SEND_3  = offsetof(NRF_IPC_Type, TASKS_SEND[3]),  
13      NRF_IPC_TASK_SEND_4  = offsetof(NRF_IPC_Type, TASKS_SEND[4]),  
14      NRF_IPC_TASK_SEND_5  = offsetof(NRF_IPC_Type, TASKS_SEND[5]),  
15      NRF_IPC_TASK_SEND_6  = offsetof(NRF_IPC_Type, TASKS_SEND[6]),  
16      NRF_IPC_TASK_SEND_7  = offsetof(NRF_IPC_Type, TASKS_SEND[7]),  
17  #if (IPC_TASKS_NUM > 8) || defined(__NRFX_DOXYGEN__)
18      NRF_IPC_TASK_SEND_8  = offsetof(NRF_IPC_Type, TASKS_SEND[8]),  
19      NRF_IPC_TASK_SEND_9  = offsetof(NRF_IPC_Type, TASKS_SEND[9]),  
20      NRF_IPC_TASK_SEND_10 = offsetof(NRF_IPC_Type, TASKS_SEND[10]), 
21      NRF_IPC_TASK_SEND_11 = offsetof(NRF_IPC_Type, TASKS_SEND[11]), 
22      NRF_IPC_TASK_SEND_12 = offsetof(NRF_IPC_Type, TASKS_SEND[12]), 
23      NRF_IPC_TASK_SEND_13 = offsetof(NRF_IPC_Type, TASKS_SEND[13]), 
24      NRF_IPC_TASK_SEND_14 = offsetof(NRF_IPC_Type, TASKS_SEND[14]), 
25      NRF_IPC_TASK_SEND_15 = offsetof(NRF_IPC_Type, TASKS_SEND[15]), 
26  #endif 
27  } nrf_ipc_task_t;
28  typedef enum
29  {
30      NRF_IPC_EVENT_RECEIVE_0  = offsetof(NRF_IPC_Type, EVENTS_RECEIVE[0]),  
31      NRF_IPC_EVENT_RECEIVE_1  = offsetof(NRF_IPC_Type, EVENTS_RECEIVE[1]),  
32      NRF_IPC_EVENT_RECEIVE_2  = offsetof(NRF_IPC_Type, EVENTS_RECEIVE[2]),  
33      NRF_IPC_EVENT_RECEIVE_3  = offsetof(NRF_IPC_Type, EVENTS_RECEIVE[3]),  
34      NRF_IPC_EVENT_RECEIVE_4  = offsetof(NRF_IPC_Type, EVENTS_RECEIVE[4]),  
35      NRF_IPC_EVENT_RECEIVE_5  = offsetof(NRF_IPC_Type, EVENTS_RECEIVE[5]),  
36      NRF_IPC_EVENT_RECEIVE_6  = offsetof(NRF_IPC_Type, EVENTS_RECEIVE[6]),  
37      NRF_IPC_EVENT_RECEIVE_7  = offsetof(NRF_IPC_Type, EVENTS_RECEIVE[7]),  
38  #if (IPC_EVENTS_NUM > 8) || defined(__NRFX_DOXYGEN__)
39      NRF_IPC_EVENT_RECEIVE_8  = offsetof(NRF_IPC_Type, EVENTS_RECEIVE[8]),  
40      NRF_IPC_EVENT_RECEIVE_9  = offsetof(NRF_IPC_Type, EVENTS_RECEIVE[9]),  
41      NRF_IPC_EVENT_RECEIVE_10 = offsetof(NRF_IPC_Type, EVENTS_RECEIVE[10]), 
42      NRF_IPC_EVENT_RECEIVE_11 = offsetof(NRF_IPC_Type, EVENTS_RECEIVE[11]), 
43      NRF_IPC_EVENT_RECEIVE_12 = offsetof(NRF_IPC_Type, EVENTS_RECEIVE[12]), 
44      NRF_IPC_EVENT_RECEIVE_13 = offsetof(NRF_IPC_Type, EVENTS_RECEIVE[13]), 
45      NRF_IPC_EVENT_RECEIVE_14 = offsetof(NRF_IPC_Type, EVENTS_RECEIVE[14]), 
46      NRF_IPC_EVENT_RECEIVE_15 = offsetof(NRF_IPC_Type, EVENTS_RECEIVE[15]), 
47  #endif 
48  } nrf_ipc_event_t;
49  typedef enum
50  {
51      NRF_IPC_CHANNEL_0 = IPC_RECEIVE_CNF_CHEN0_Msk,   
52      NRF_IPC_CHANNEL_1 = IPC_RECEIVE_CNF_CHEN1_Msk,   
53      NRF_IPC_CHANNEL_2 = IPC_RECEIVE_CNF_CHEN2_Msk,   
54      NRF_IPC_CHANNEL_3 = IPC_RECEIVE_CNF_CHEN3_Msk,   
55      NRF_IPC_CHANNEL_4 = IPC_RECEIVE_CNF_CHEN4_Msk,   
56      NRF_IPC_CHANNEL_5 = IPC_RECEIVE_CNF_CHEN5_Msk,   
57      NRF_IPC_CHANNEL_6 = IPC_RECEIVE_CNF_CHEN6_Msk,   
58      NRF_IPC_CHANNEL_7 = IPC_RECEIVE_CNF_CHEN7_Msk,   
59  #if (IPC_CH_NUM > 8) || defined(__NRFX_DOXYGEN__)
60      NRF_IPC_CHANNEL_8  = IPC_RECEIVE_CNF_CHEN8_Msk,  
61      NRF_IPC_CHANNEL_9  = IPC_RECEIVE_CNF_CHEN9_Msk,  
62      NRF_IPC_CHANNEL_10 = IPC_RECEIVE_CNF_CHEN10_Msk, 
63      NRF_IPC_CHANNEL_11 = IPC_RECEIVE_CNF_CHEN11_Msk, 
64      NRF_IPC_CHANNEL_12 = IPC_RECEIVE_CNF_CHEN12_Msk, 
65      NRF_IPC_CHANNEL_13 = IPC_RECEIVE_CNF_CHEN13_Msk, 
66      NRF_IPC_CHANNEL_14 = IPC_RECEIVE_CNF_CHEN14_Msk, 
67      NRF_IPC_CHANNEL_15 = IPC_RECEIVE_CNF_CHEN15_Msk, 
68  #endif 
69  } nrf_ipc_channel_t;
70  typedef enum
71  {
72      NRF_IPC_INT_RECEIVE_0  = IPC_INTEN_RECEIVE0_Msk,  
73      NRF_IPC_INT_RECEIVE_1  = IPC_INTEN_RECEIVE1_Msk,  
74      NRF_IPC_INT_RECEIVE_2  = IPC_INTEN_RECEIVE2_Msk,  
75      NRF_IPC_INT_RECEIVE_3  = IPC_INTEN_RECEIVE3_Msk,  
76      NRF_IPC_INT_RECEIVE_4  = IPC_INTEN_RECEIVE4_Msk,  
77      NRF_IPC_INT_RECEIVE_5  = IPC_INTEN_RECEIVE5_Msk,  
78      NRF_IPC_INT_RECEIVE_6  = IPC_INTEN_RECEIVE6_Msk,  
79      NRF_IPC_INT_RECEIVE_7  = IPC_INTEN_RECEIVE7_Msk,  
80  #if (IPC_EVENTS_NUM > 8) || defined(__NRFX_DOXYGEN__)
81      NRF_IPC_INT_RECEIVE_8  = IPC_INTEN_RECEIVE8_Msk,  
82      NRF_IPC_INT_RECEIVE_9  = IPC_INTEN_RECEIVE9_Msk,  
83      NRF_IPC_INT_RECEIVE_10 = IPC_INTEN_RECEIVE10_Msk, 
84      NRF_IPC_INT_RECEIVE_11 = IPC_INTEN_RECEIVE11_Msk, 
85      NRF_IPC_INT_RECEIVE_12 = IPC_INTEN_RECEIVE12_Msk, 
86      NRF_IPC_INT_RECEIVE_13 = IPC_INTEN_RECEIVE13_Msk, 
87      NRF_IPC_INT_RECEIVE_14 = IPC_INTEN_RECEIVE14_Msk, 
88      NRF_IPC_INT_RECEIVE_15 = IPC_INTEN_RECEIVE15_Msk, 
89  #endif 
90  } nrf_ipc_int_mask_t;
91  NRF_STATIC_INLINE void nrf_ipc_task_trigger(NRF_IPC_Type * p_reg, nrf_ipc_task_t task);
92  NRF_STATIC_INLINE uint32_t nrf_ipc_task_address_get(NRF_IPC_Type const * p_reg,
93                                                      nrf_ipc_task_t       task);
94  NRF_STATIC_INLINE void nrf_ipc_event_clear(NRF_IPC_Type * p_reg, nrf_ipc_event_t event);
95  NRF_STATIC_INLINE bool nrf_ipc_event_check(NRF_IPC_Type const * p_reg, nrf_ipc_event_t event);
96  NRF_STATIC_INLINE uint32_t nrf_ipc_event_address_get(NRF_IPC_Type const * p_reg,
97                                                       nrf_ipc_event_t      event);
98  NRF_STATIC_INLINE void nrf_ipc_int_enable(NRF_IPC_Type * p_reg, uint32_t mask);
99  NRF_STATIC_INLINE void nrf_ipc_int_disable(NRF_IPC_Type * p_reg, uint32_t mask);
100  NRF_STATIC_INLINE uint32_t nrf_ipc_int_enable_check(NRF_IPC_Type const * p_reg, uint32_t mask);
101  NRF_STATIC_INLINE uint32_t nrf_ipc_int_pending_get(NRF_IPC_Type const * p_reg);
102  NRF_STATIC_INLINE void nrf_ipc_subscribe_set(NRF_IPC_Type * p_reg,
103                                               nrf_ipc_task_t task,
104                                               uint8_t        channel);
105  NRF_STATIC_INLINE void nrf_ipc_subscribe_clear(NRF_IPC_Type * p_reg, nrf_ipc_task_t task);
106  NRF_STATIC_INLINE void nrf_ipc_publish_set(NRF_IPC_Type *  p_reg,
107                                             nrf_ipc_event_t event,
108                                             uint8_t         channel);
109  NRF_STATIC_INLINE void nrf_ipc_publish_clear(NRF_IPC_Type * p_reg, nrf_ipc_event_t event);
110  NRF_STATIC_INLINE void nrf_ipc_send_config_set(NRF_IPC_Type * p_reg,
111                                                 uint8_t        index,
<span onclick='openModal()' class='match'>112                                                 uint32_t       channels_mask);
113  NRF_STATIC_INLINE uint32_t nrf_ipc_send_config_get(NRF_IPC_Type * const p_reg, uint8_t index);
114  NRF_STATIC_INLINE void nrf_ipc_receive_config_set(NRF_IPC_Type * p_reg,
115                                                    uint8_t        index,
116                                                    uint32_t       channels_mask);
117  NRF_STATIC_INLINE uint32_t nrf_ipc_receive_config_get(NRF_IPC_Type * const p_reg, uint8_t index);
</span>118  NRF_STATIC_INLINE void nrf_ipc_gpmem_set(NRF_IPC_Type * p_reg,
119                                           uint8_t        index,
120                                           uint32_t       data);
121  NRF_STATIC_INLINE uint32_t nrf_ipc_gpmem_get(NRF_IPC_Type const * p_reg, uint8_t index);
122  NRF_STATIC_INLINE nrf_ipc_task_t nrf_ipc_send_task_get(uint8_t index);
123  NRF_STATIC_INLINE nrf_ipc_event_t nrf_ipc_receive_event_get(uint8_t index);
124  #ifndef NRF_DECLARE_ONLY
125  NRF_STATIC_INLINE void nrf_ipc_task_trigger(NRF_IPC_Type * p_reg, nrf_ipc_task_t task)
126  {
127      *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
128  }
129  NRF_STATIC_INLINE uint32_t nrf_ipc_task_address_get(NRF_IPC_Type const * p_reg,
130                                                      nrf_ipc_task_t       task)
131  {
132      return ((uint32_t)p_reg + (uint32_t)task);
133  }
134  NRF_STATIC_INLINE void nrf_ipc_event_clear(NRF_IPC_Type * p_reg, nrf_ipc_event_t event)
135  {
136      *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
137  }
138  NRF_STATIC_INLINE bool nrf_ipc_event_check(NRF_IPC_Type const * p_reg, nrf_ipc_event_t event)
139  {
140      return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
141  }
142  NRF_STATIC_INLINE uint32_t nrf_ipc_event_address_get(NRF_IPC_Type const * p_reg,
143                                                       nrf_ipc_event_t      event)
144  {
145      return ((uint32_t)p_reg + (uint32_t)event);
146  }
147  NRF_STATIC_INLINE void nrf_ipc_int_enable(NRF_IPC_Type * p_reg, uint32_t mask)
148  {
149      p_reg->INTENSET = mask;
150  }
151  NRF_STATIC_INLINE void nrf_ipc_int_disable(NRF_IPC_Type * p_reg, uint32_t mask)
152  {
153      p_reg->INTENCLR = mask;
154  }
155  NRF_STATIC_INLINE uint32_t nrf_ipc_int_enable_check(NRF_IPC_Type const * p_reg, uint32_t mask)
156  {
157      return p_reg->INTENSET & mask;
158  }
159  NRF_STATIC_INLINE uint32_t nrf_ipc_int_pending_get(NRF_IPC_Type const * p_reg)
160  {
161      return p_reg->INTPEND;
162  }
163  NRF_STATIC_INLINE void nrf_ipc_subscribe_set(NRF_IPC_Type * p_reg,
164                                               nrf_ipc_task_t task,
165                                               uint8_t        channel)
166  {
167      *((volatile uint32_t *) ((uint8_t *) p_reg + (uint32_t) task + 0x80uL)) =
168              ((uint32_t)channel | IPC_SUBSCRIBE_SEND_EN_Msk);
169  }
170  NRF_STATIC_INLINE void nrf_ipc_subscribe_clear(NRF_IPC_Type * p_reg, nrf_ipc_task_t task)
171  {
172      *((volatile uint32_t *) ((uint8_t *) p_reg + (uint32_t) task + 0x80uL)) = 0;
173  }
174  NRF_STATIC_INLINE void nrf_ipc_publish_set(NRF_IPC_Type *  p_reg,
175                                             nrf_ipc_event_t event,
176                                             uint8_t         channel)
177  {
178      *((volatile uint32_t *) ((uint8_t *) p_reg + (uint32_t) event + 0x80uL)) =
179              ((uint32_t)channel | IPC_PUBLISH_RECEIVE_EN_Msk);
180  }
181  NRF_STATIC_INLINE void nrf_ipc_publish_clear(NRF_IPC_Type *  p_reg, nrf_ipc_event_t event)
182  {
183      *((volatile uint32_t *) ((uint8_t *) p_reg + (uint32_t) event + 0x80uL)) = 0;
184  }
185  NRF_STATIC_INLINE void nrf_ipc_send_config_set(NRF_IPC_Type * p_reg,
186                                                 uint8_t        index,
187                                                 uint32_t       channels_mask)
188  {
189      p_reg->SEND_CNF[index] = channels_mask;
190  }
191  NRF_STATIC_INLINE uint32_t nrf_ipc_send_config_get(NRF_IPC_Type * const p_reg, uint8_t index)
192  {
193      return p_reg->SEND_CNF[index];
194  }
195  NRF_STATIC_INLINE void nrf_ipc_receive_config_set(NRF_IPC_Type * p_reg,
196                                                    uint8_t        index,
197                                                    uint32_t       channels_mask)
198  {
199      p_reg->RECEIVE_CNF[index] = channels_mask;
200  }
201  NRF_STATIC_INLINE uint32_t nrf_ipc_receive_config_get(NRF_IPC_Type * const p_reg, uint8_t index)
202  {
203      return p_reg->RECEIVE_CNF[index];
204  }
205  NRF_STATIC_INLINE void nrf_ipc_gpmem_set(NRF_IPC_Type * p_reg,
206                                           uint8_t        index,
207                                           uint32_t       data)
208  {
209      NRFX_ASSERT(index < IPC_GPMEM_NUM);
210      p_reg->GPMEM[index] = data;
211  }
212  NRF_STATIC_INLINE uint32_t nrf_ipc_gpmem_get(NRF_IPC_Type const * p_reg,  uint8_t index)
213  {
214      NRFX_ASSERT(index < IPC_GPMEM_NUM);
215      return p_reg->GPMEM[index];
216  }
217  NRF_STATIC_INLINE nrf_ipc_task_t nrf_ipc_send_task_get(uint8_t index)
218  {
219      NRFX_ASSERT(index < IPC_CH_NUM);
220      return (nrf_ipc_task_t)(NRFX_OFFSETOF(NRF_IPC_Type, TASKS_SEND[index]));
221  }
222  NRF_STATIC_INLINE nrf_ipc_event_t nrf_ipc_receive_event_get(uint8_t index)
223  {
224      NRFX_ASSERT(index < IPC_CH_NUM);
225      return (nrf_ipc_event_t)(NRFX_OFFSETOF(NRF_IPC_Type, EVENTS_RECEIVE[index]));
226  }
227  #endif 
228  #ifdef __cplusplus
229  }
230  #endif
231  #endif 
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from Adafruit_nRF52_Arduino-MDEwOlJlcG9zaXRvcnk3NDM1NDcyOQ==-flat-nrf_ipc.h</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from Adafruit_nRF52_Arduino-MDEwOlJlcG9zaXRvcnk3NDM1NDcyOQ==-flat-nrf_ipc.h</div>
                </div>
                <div class="column column_space"><pre><code>112                                                 uint32_t       channels_mask);
113  NRF_STATIC_INLINE uint32_t nrf_ipc_send_config_get(NRF_IPC_Type * const p_reg, uint8_t index);
114  NRF_STATIC_INLINE void nrf_ipc_receive_config_set(NRF_IPC_Type * p_reg,
115                                                    uint8_t        index,
116                                                    uint32_t       channels_mask);
117  NRF_STATIC_INLINE uint32_t nrf_ipc_receive_config_get(NRF_IPC_Type * const p_reg, uint8_t index);
</pre></code></div>
                <div class="column column_space"><pre><code>112                                                 uint32_t       channels_mask);
113  NRF_STATIC_INLINE uint32_t nrf_ipc_send_config_get(NRF_IPC_Type * const p_reg, uint8_t index);
114  NRF_STATIC_INLINE void nrf_ipc_receive_config_set(NRF_IPC_Type * p_reg,
115                                                    uint8_t        index,
116                                                    uint32_t       channels_mask);
117  NRF_STATIC_INLINE uint32_t nrf_ipc_receive_config_get(NRF_IPC_Type * const p_reg, uint8_t index);
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    