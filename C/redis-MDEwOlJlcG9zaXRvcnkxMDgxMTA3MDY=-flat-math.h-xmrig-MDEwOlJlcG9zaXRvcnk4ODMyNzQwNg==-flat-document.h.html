
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 2.9135642602784073%, Tokens: 11</h2>
        <div class="column">
            <h3>redis-MDEwOlJlcG9zaXRvcnkxMDgxMTA3MDY=-flat-math.h</h3>
            <pre><code>1  static inline double
2  ln_gamma(double x) {
3  	double f, z;
4  	assert(x > 0.0);
5  	if (x < 7.0) {
6  		f = 1.0;
7  		z = x;
8  		while (z < 7.0) {
9  			f *= z;
10  			z += 1.0;
11  		}
12  		x = z;
13  		f = -log(f);
14  	} else {
15  		f = 0.0;
16  	}
17  	z = 1.0 / (x * x);
18  	return f + (x-0.5) * log(x) - x + 0.918938533204673 +
19  	    (((-0.000595238095238 * z + 0.000793650793651) * z -
20  	    0.002777777777778) * z + 0.083333333333333) / x;
21  }
22  static inline double
23  i_gamma(double x, double p, double ln_gamma_p) {
24  	double acu, factor, oflo, gin, term, rn, a, b, an, dif;
25  	double pn[6];
26  	unsigned i;
27  	assert(p > 0.0);
28  	assert(x >= 0.0);
29  	if (x == 0.0) {
30  		return 0.0;
31  	}
32  	acu = 1.0e-10;
33  	oflo = 1.0e30;
34  	gin = 0.0;
35  	factor = exp(p * log(x) - x - ln_gamma_p);
36  	if (x <= 1.0 || x < p) {
37  		gin = 1.0;
38  		term = 1.0;
39  		rn = p;
40  		while (true) {
41  			rn += 1.0;
42  			term *= x / rn;
43  			gin += term;
44  			if (term <= acu) {
45  				gin *= factor / p;
46  				return gin;
47  			}
48  		}
49  	} else {
50  		a = 1.0 - p;
51  		b = a + x + 1.0;
52  		term = 0.0;
53  		pn[0] = 1.0;
54  		pn[1] = x;
55  		pn[2] = x + 1.0;
56  		pn[3] = x * b;
57  		gin = pn[2] / pn[3];
58  		while (true) {
59  			a += 1.0;
60  			b += 2.0;
61  			term += 1.0;
62  			an = a * term;
63  			for (i = 0; i < 2; i++) {
64  				pn[i+4] = b * pn[i+2] - an * pn[i];
65  			}
66  			if (pn[5] != 0.0) {
67  				rn = pn[4] / pn[5];
68  				dif = fabs(gin - rn);
69  				if (dif <= acu && dif <= acu * rn) {
70  					gin = 1.0 - factor * gin;
71  					return gin;
72  				}
73  				gin = rn;
74  			}
75  			for (i = 0; i < 4; i++) {
76  				pn[i] = pn[i+2];
77  			}
78  			if (fabs(pn[4]) >= oflo) {
79  				for (i = 0; i < 4; i++) {
80  					pn[i] /= oflo;
81  				}
82  			}
83  		}
84  	}
85  }
86  static inline double
87  pt_norm(double p) {
88  	double q, r, ret;
89  	assert(p > 0.0 && p < 1.0);
90  	q = p - 0.5;
91  	if (fabs(q) <= 0.425) {
92  		r = 0.180625 - q * q;
93  		return q * (((((((2.5090809287301226727e3 * r +
94  		    3.3430575583588128105e4) * r + 6.7265770927008700853e4) * r
95  		    + 4.5921953931549871457e4) * r + 1.3731693765509461125e4) *
96  		    r + 1.9715909503065514427e3) * r + 1.3314166789178437745e2)
97  		    * r + 3.3871328727963666080e0) /
98  		    (((((((5.2264952788528545610e3 * r +
99  		    2.8729085735721942674e4) * r + 3.9307895800092710610e4) * r
100  		    + 2.1213794301586595867e4) * r + 5.3941960214247511077e3) *
101  		    r + 6.8718700749205790830e2) * r + 4.2313330701600911252e1)
102  		    * r + 1.0);
103  	} else {
104  		if (q < 0.0) {
105  			r = p;
106  		} else {
107  			r = 1.0 - p;
108  		}
109  		assert(r > 0.0);
110  		r = sqrt(-log(r));
111  		if (r <= 5.0) {
112  			r -= 1.6;
113  			ret = ((((((((7.74545014278341407640e-4 * r +
114  			    2.27238449892691845833e-2) * r +
115  			    2.41780725177450611770e-1) * r +
116  			    1.27045825245236838258e0) * r +
117  			    3.64784832476320460504e0) * r +
118  			    5.76949722146069140550e0) * r +
119  			    4.63033784615654529590e0) * r +
120  			    1.42343711074968357734e0) /
121  			    (((((((1.05075007164441684324e-9 * r +
122  			    5.47593808499534494600e-4) * r +
123  			    1.51986665636164571966e-2)
124  			    * r + 1.48103976427480074590e-1) * r +
125  			    6.89767334985100004550e-1) * r +
126  			    1.67638483018380384940e0) * r +
127  			    2.05319162663775882187e0) * r + 1.0));
128  		} else {
129  			r -= 5.0;
130  			ret = ((((((((2.01033439929228813265e-7 * r +
131  			    2.71155556874348757815e-5) * r +
132  			    1.24266094738807843860e-3) * r +
133  			    2.65321895265761230930e-2) * r +
134  			    2.96560571828504891230e-1) * r +
135  			    1.78482653991729133580e0) * r +
136  			    5.46378491116411436990e0) * r +
137  			    6.65790464350110377720e0) /
138  			    (((((((2.04426310338993978564e-15 * r +
139  			    1.42151175831644588870e-7) * r +
140  			    1.84631831751005468180e-5) * r +
141  			    7.86869131145613259100e-4) * r +
142  			    1.48753612908506148525e-2) * r +
143  			    1.36929880922735805310e-1) * r +
144  			    5.99832206555887937690e-1)
145  			    * r + 1.0));
146  		}
147  		if (q < 0.0) {
148  			ret = -ret;
149  		}
150  		return ret;
151  	}
152  }
153  static inline double
154  pt_chi2(double p, double df, double ln_gamma_df_2) {
155  	double e, aa, xx, c, ch, a, q, p1, p2, t, x, b, s1, s2, s3, s4, s5, s6;
156  	unsigned i;
157  	assert(p >= 0.0 && p < 1.0);
158  	assert(df > 0.0);
159  	e = 5.0e-7;
160  	aa = 0.6931471805;
161  	xx = 0.5 * df;
162  	c = xx - 1.0;
163  	if (df < -1.24 * log(p)) {
164  		ch = pow(p * xx * exp(ln_gamma_df_2 + xx * aa), 1.0 / xx);
165  		if (ch - e < 0.0) {
166  			return ch;
167  		}
168  	} else {
169  		if (df > 0.32) {
170  			x = pt_norm(p);
171  			p1 = 0.222222 / df;
172  			ch = df * pow(x * sqrt(p1) + 1.0 - p1, 3.0);
173  			if (ch > 2.2 * df + 6.0) {
174  				ch = -2.0 * (log(1.0 - p) - c * log(0.5 * ch) +
175  				    ln_gamma_df_2);
176  			}
177  		} else {
178  			ch = 0.4;
179  			a = log(1.0 - p);
180  			while (true) {
181  				q = ch;
182  				p1 = 1.0 + ch * (4.67 + ch);
183  				p2 = ch * (6.73 + ch * (6.66 + ch));
184  				t = -0.5 + (4.67 + 2.0 * ch) / p1 - (6.73 + ch
185  				    * (13.32 + 3.0 * ch)) / p2;
186  				ch -= (1.0 - exp(a + ln_gamma_df_2 + 0.5 * ch +
187  				    c * aa) * p2 / p1) / t;
188  				if (fabs(q / ch - 1.0) - 0.01 <= 0.0) {
189  					break;
190  				}
191  			}
192  		}
193  	}
194  	for (i = 0; i < 20; i++) {
195  		q = ch;
196  		p1 = 0.5 * ch;
197  		if (p1 < 0.0) {
198  			return -1.0;
199  		}
<span onclick='openModal()' class='match'>200  		p2 = p - i_gamma(p1, xx, ln_gamma_df_2);
201  		t = p2 * exp(xx * aa + ln_gamma_df_2 + p1 - c * log(ch));
202  		b = t / ch;
203  		a = 0.5 * t - b * c;
204  		s1 = (210.0 + a * (140.0 + a * (105.0 + a * (84.0 + a * (70.0 +
205  		    60.0 * a))))) / 420.0;
206  		s2 = (420.0 + a * (735.0 + a * (966.0 + a * (1141.0 + 1278.0 *
207  		    a)))) / 2520.0;
208  		s3 = (210.0 + a * (462.0 + a * (707.0 + 932.0 * a))) / 2520.0;
209  		s4 = (252.0 + a * (672.0 + 1182.0 * a) + c * (294.0 + a *
210  		    (889.0 + 1740.0 * a))) / 5040.0;
211  		s5 = (84.0 + 264.0 * a + c * (175.0 + 606.0 * a)) / 2520.0;
212  		s6 = (120.0 + c * (346.0 + 127.0 * c)) / 5040.0;
213  		ch += t * (1.0 + 0.5 * t * s1 - b * c * (s1 - b * (s2 - b * (s3
</span>214  		    - b * (s4 - b * (s5 - b * s6))))));
215  		if (fabs(q / ch - 1.0) <= e) {
216  			break;
217  		}
218  	}
219  	return ch;
220  }
221  static inline double
222  pt_gamma(double p, double shape, double scale, double ln_gamma_shape) {
223  	return pt_chi2(p, shape * 2.0, ln_gamma_shape) * 0.5 * scale;
224  }
</code></pre>
        </div>
        <div class="column">
            <h3>xmrig-MDEwOlJlcG9zaXRvcnk4ODMyNzQwNg==-flat-document.h</h3>
            <pre><code>1  #ifndef RAPIDJSON_DOCUMENT_H_
2  #define RAPIDJSON_DOCUMENT_H_
3  #include "reader.h"
4  #include "internal/meta.h"
5  #include "internal/strfunc.h"
6  #include "memorystream.h"
7  #include "encodedstream.h"
8  #include <new>      
9  #include <limits>
10  #ifdef __cpp_lib_three_way_comparison
11  #include <compare>
12  #endif
13  RAPIDJSON_DIAG_PUSH
14  #ifdef __clang__
15  RAPIDJSON_DIAG_OFF(padded)
16  RAPIDJSON_DIAG_OFF(switch-enum)
17  RAPIDJSON_DIAG_OFF(c++98-compat)
18  #elif defined(_MSC_VER)
19  RAPIDJSON_DIAG_OFF(4127) 
20  RAPIDJSON_DIAG_OFF(4244) 
21  #endif
22  #ifdef __GNUC__
23  RAPIDJSON_DIAG_OFF(effc++)
24  #endif 
25  #ifdef GetObject
26  #pragma push_macro("GetObject")
27  #define RAPIDJSON_WINDOWS_GETOBJECT_WORKAROUND_APPLIED
28  #undef GetObject
29  #endif
30  #ifndef RAPIDJSON_NOMEMBERITERATORCLASS
31  #include <iterator> 
32  #endif
33  #if RAPIDJSON_USE_MEMBERSMAP
34  #include <map> 
35  #endif
36  RAPIDJSON_NAMESPACE_BEGIN
37  template <typename Encoding, typename Allocator>
38  class GenericValue;
39  template <typename Encoding, typename Allocator, typename StackAllocator>
40  class GenericDocument;
41  #ifndef RAPIDJSON_DEFAULT_ALLOCATOR
42  #define RAPIDJSON_DEFAULT_ALLOCATOR MemoryPoolAllocator<CrtAllocator>
43  #endif
44  #ifndef RAPIDJSON_DEFAULT_STACK_ALLOCATOR
45  #define RAPIDJSON_DEFAULT_STACK_ALLOCATOR CrtAllocator
46  #endif
47  #ifndef RAPIDJSON_VALUE_DEFAULT_OBJECT_CAPACITY
48  #define RAPIDJSON_VALUE_DEFAULT_OBJECT_CAPACITY 16
49  #endif
50  #ifndef RAPIDJSON_VALUE_DEFAULT_ARRAY_CAPACITY
51  #define RAPIDJSON_VALUE_DEFAULT_ARRAY_CAPACITY 16
52  #endif
53  template <typename Encoding, typename Allocator>
54  class GenericMember {
55  public:
56      GenericValue<Encoding, Allocator> name;     
57      GenericValue<Encoding, Allocator> value;    
58  #if RAPIDJSON_HAS_CXX11_RVALUE_REFS
59      GenericMember(GenericMember&& rhs) RAPIDJSON_NOEXCEPT
60          : name(std::move(rhs.name)),
61            value(std::move(rhs.value))
62      {
63      }
64      GenericMember& operator=(GenericMember&& rhs) RAPIDJSON_NOEXCEPT {
65          return *this = static_cast<GenericMember&>(rhs);
66      }
67  #endif
68      GenericMember& operator=(GenericMember& rhs) RAPIDJSON_NOEXCEPT {
69          if (RAPIDJSON_LIKELY(this != &rhs)) {
70              name = rhs.name;
71              value = rhs.value;
72          }
73          return *this;
74      }
75      friend inline void swap(GenericMember& a, GenericMember& b) RAPIDJSON_NOEXCEPT {
76          a.name.Swap(b.name);
77          a.value.Swap(b.value);
78      }
79  private:
80      GenericMember(const GenericMember& rhs);
81  };
82  #ifndef RAPIDJSON_NOMEMBERITERATORCLASS
83  template <bool Const, typename Encoding, typename Allocator>
84  class GenericMemberIterator {
85      friend class GenericValue<Encoding,Allocator>;
86      template <bool, typename, typename> friend class GenericMemberIterator;
87      typedef GenericMember<Encoding,Allocator> PlainType;
88      typedef typename internal::MaybeAddConst<Const,PlainType>::Type ValueType;
89  public:
90      typedef GenericMemberIterator Iterator;
91      typedef GenericMemberIterator<true,Encoding,Allocator>  ConstIterator;
92      typedef GenericMemberIterator<false,Encoding,Allocator> NonConstIterator;
93      typedef ValueType      value_type;
94      typedef ValueType *    pointer;
95      typedef ValueType &    reference;
96      typedef std::ptrdiff_t difference_type;
97      typedef std::random_access_iterator_tag iterator_category;
98      typedef pointer         Pointer;
99      typedef reference       Reference;
100      typedef difference_type DifferenceType;
101      GenericMemberIterator() : ptr_() {}
102      GenericMemberIterator(const NonConstIterator & it) : ptr_(it.ptr_) {}
103      Iterator& operator=(const NonConstIterator & it) { ptr_ = it.ptr_; return *this; }
104      Iterator& operator++(){ ++ptr_; return *this; }
105      Iterator& operator--(){ --ptr_; return *this; }
106      Iterator  operator++(int){ Iterator old(*this); ++ptr_; return old; }
107      Iterator  operator--(int){ Iterator old(*this); --ptr_; return old; }
108      Iterator operator+(DifferenceType n) const { return Iterator(ptr_+n); }
109      Iterator operator-(DifferenceType n) const { return Iterator(ptr_-n); }
110      Iterator& operator+=(DifferenceType n) { ptr_+=n; return *this; }
111      Iterator& operator-=(DifferenceType n) { ptr_-=n; return *this; }
112      template <bool Const_> bool operator==(const GenericMemberIterator<Const_, Encoding, Allocator>& that) const { return ptr_ == that.ptr_; }
113      template <bool Const_> bool operator!=(const GenericMemberIterator<Const_, Encoding, Allocator>& that) const { return ptr_ != that.ptr_; }
114      template <bool Const_> bool operator<=(const GenericMemberIterator<Const_, Encoding, Allocator>& that) const { return ptr_ <= that.ptr_; }
115      template <bool Const_> bool operator>=(const GenericMemberIterator<Const_, Encoding, Allocator>& that) const { return ptr_ >= that.ptr_; }
116      template <bool Const_> bool operator< (const GenericMemberIterator<Const_, Encoding, Allocator>& that) const { return ptr_ < that.ptr_; }
117      template <bool Const_> bool operator> (const GenericMemberIterator<Const_, Encoding, Allocator>& that) const { return ptr_ > that.ptr_; }
118  #ifdef __cpp_lib_three_way_comparison
119      template <bool Const_> std::strong_ordering operator<=>(const GenericMemberIterator<Const_, Encoding, Allocator>& that) const { return ptr_ <=> that.ptr_; }
120  #endif
121      Reference operator*() const { return *ptr_; }
122      Pointer   operator->() const { return ptr_; }
123      Reference operator[](DifferenceType n) const { return ptr_[n]; }
124      DifferenceType operator-(ConstIterator that) const { return ptr_-that.ptr_; }
125  private:
126      explicit GenericMemberIterator(Pointer p) : ptr_(p) {}
127      Pointer ptr_; 
128  };
129  #else 
130  template <bool Const, typename Encoding, typename Allocator>
131  class GenericMemberIterator;
132  template <typename Encoding, typename Allocator>
133  class GenericMemberIterator<false,Encoding,Allocator> {
134  public:
135      typedef GenericMember<Encoding,Allocator>* Iterator;
136  };
137  template <typename Encoding, typename Allocator>
138  class GenericMemberIterator<true,Encoding,Allocator> {
139  public:
140      typedef const GenericMember<Encoding,Allocator>* Iterator;
141  };
142  #endif 
143  template<typename CharType>
144  struct GenericStringRef {
145      typedef CharType Ch; 
146  #ifndef __clang__ 
147  #endif
148      template<SizeType N>
149      GenericStringRef(const CharType (&str)[N]) RAPIDJSON_NOEXCEPT
150          : s(str), length(N-1) {}
151  #ifndef __clang__ 
152  #endif
153      explicit GenericStringRef(const CharType* str)
154          : s(str), length(NotNullStrLen(str)) {}
155  #ifndef __clang__ 
156  #endif
157      GenericStringRef(const CharType* str, SizeType len)
158          : s(RAPIDJSON_LIKELY(str) ? str : emptyString), length(len) { RAPIDJSON_ASSERT(str != 0 || len == 0u); }
159      GenericStringRef(const GenericStringRef& rhs) : s(rhs.s), length(rhs.length) {}
160      operator const Ch *() const { return s; }
161      const Ch* const s; 
162      const SizeType length; 
163  private:
164      SizeType NotNullStrLen(const CharType* str) {
165          RAPIDJSON_ASSERT(str != 0);
166          return internal::StrLen(str);
167      }
168      static const Ch emptyString[];
169      template<SizeType N>
170      GenericStringRef(CharType (&str)[N]) &bsol;* = delete */;
171      GenericStringRef& operator=(const GenericStringRef& rhs) &bsol;* = delete */;
172  };
173  template<typename CharType>
174  const CharType GenericStringRef<CharType>::emptyString[] = { CharType() };
175  template<typename CharType>
176  inline GenericStringRef<CharType> StringRef(const CharType* str) {
177      return GenericStringRef<CharType>(str);
178  }
179  template<typename CharType>
180  inline GenericStringRef<CharType> StringRef(const CharType* str, size_t length) {
181      return GenericStringRef<CharType>(str, SizeType(length));
182  }
183  #if RAPIDJSON_HAS_STDSTRING
184  template<typename CharType>
185  inline GenericStringRef<CharType> StringRef(const std::basic_string<CharType>& str) {
186      return GenericStringRef<CharType>(str.data(), SizeType(str.size()));
187  }
188  #endif
189  namespace internal {
190  template <typename T, typename Encoding = void, typename Allocator = void>
191  struct IsGenericValueImpl : FalseType {};
192  template <typename T> struct IsGenericValueImpl<T, typename Void<typename T::EncodingType>::Type, typename Void<typename T::AllocatorType>::Type>
193      : IsBaseOf<GenericValue<typename T::EncodingType, typename T::AllocatorType>, T>::Type {};
194  template <typename T> struct IsGenericValue : IsGenericValueImpl<T>::Type {};
195  } 
196  namespace internal {
197  template <typename ValueType, typename T>
198  struct TypeHelper {};
199  template<typename ValueType>
200  struct TypeHelper<ValueType, bool> {
201      static bool Is(const ValueType& v) { return v.IsBool(); }
202      static bool Get(const ValueType& v) { return v.GetBool(); }
203      static ValueType& Set(ValueType& v, bool data) { return v.SetBool(data); }
204      static ValueType& Set(ValueType& v, bool data, typename ValueType::AllocatorType&) { return v.SetBool(data); }
205  };
206  template<typename ValueType>
207  struct TypeHelper<ValueType, int> {
208      static bool Is(const ValueType& v) { return v.IsInt(); }
209      static int Get(const ValueType& v) { return v.GetInt(); }
210      static ValueType& Set(ValueType& v, int data) { return v.SetInt(data); }
211      static ValueType& Set(ValueType& v, int data, typename ValueType::AllocatorType&) { return v.SetInt(data); }
212  };
213  template<typename ValueType>
214  struct TypeHelper<ValueType, unsigned> {
215      static bool Is(const ValueType& v) { return v.IsUint(); }
216      static unsigned Get(const ValueType& v) { return v.GetUint(); }
217      static ValueType& Set(ValueType& v, unsigned data) { return v.SetUint(data); }
218      static ValueType& Set(ValueType& v, unsigned data, typename ValueType::AllocatorType&) { return v.SetUint(data); }
219  };
220  #ifdef _MSC_VER
221  RAPIDJSON_STATIC_ASSERT(sizeof(long) == sizeof(int));
222  template<typename ValueType>
223  struct TypeHelper<ValueType, long> {
224      static bool Is(const ValueType& v) { return v.IsInt(); }
225      static long Get(const ValueType& v) { return v.GetInt(); }
226      static ValueType& Set(ValueType& v, long data) { return v.SetInt(data); }
227      static ValueType& Set(ValueType& v, long data, typename ValueType::AllocatorType&) { return v.SetInt(data); }
228  };
229  RAPIDJSON_STATIC_ASSERT(sizeof(unsigned long) == sizeof(unsigned));
230  template<typename ValueType>
231  struct TypeHelper<ValueType, unsigned long> {
232      static bool Is(const ValueType& v) { return v.IsUint(); }
233      static unsigned long Get(const ValueType& v) { return v.GetUint(); }
234      static ValueType& Set(ValueType& v, unsigned long data) { return v.SetUint(data); }
235      static ValueType& Set(ValueType& v, unsigned long data, typename ValueType::AllocatorType&) { return v.SetUint(data); }
236  };
237  #endif
238  template<typename ValueType>
239  struct TypeHelper<ValueType, int64_t> {
240      static bool Is(const ValueType& v) { return v.IsInt64(); }
241      static int64_t Get(const ValueType& v) { return v.GetInt64(); }
242      static ValueType& Set(ValueType& v, int64_t data) { return v.SetInt64(data); }
243      static ValueType& Set(ValueType& v, int64_t data, typename ValueType::AllocatorType&) { return v.SetInt64(data); }
244  };
245  template<typename ValueType>
246  struct TypeHelper<ValueType, uint64_t> {
247      static bool Is(const ValueType& v) { return v.IsUint64(); }
248      static uint64_t Get(const ValueType& v) { return v.GetUint64(); }
249      static ValueType& Set(ValueType& v, uint64_t data) { return v.SetUint64(data); }
250      static ValueType& Set(ValueType& v, uint64_t data, typename ValueType::AllocatorType&) { return v.SetUint64(data); }
251  };
252  template<typename ValueType>
253  struct TypeHelper<ValueType, double> {
254      static bool Is(const ValueType& v) { return v.IsDouble(); }
255      static double Get(const ValueType& v) { return v.GetDouble(); }
256      static ValueType& Set(ValueType& v, double data) { return v.SetDouble(data); }
257      static ValueType& Set(ValueType& v, double data, typename ValueType::AllocatorType&) { return v.SetDouble(data); }
258  };
259  template<typename ValueType>
260  struct TypeHelper<ValueType, float> {
261      static bool Is(const ValueType& v) { return v.IsFloat(); }
262      static float Get(const ValueType& v) { return v.GetFloat(); }
263      static ValueType& Set(ValueType& v, float data) { return v.SetFloat(data); }
264      static ValueType& Set(ValueType& v, float data, typename ValueType::AllocatorType&) { return v.SetFloat(data); }
265  };
266  template<typename ValueType>
267  struct TypeHelper<ValueType, const typename ValueType::Ch*> {
268      typedef const typename ValueType::Ch* StringType;
269      static bool Is(const ValueType& v) { return v.IsString(); }
270      static StringType Get(const ValueType& v) { return v.GetString(); }
271      static ValueType& Set(ValueType& v, const StringType data) { return v.SetString(typename ValueType::StringRefType(data)); }
272      static ValueType& Set(ValueType& v, const StringType data, typename ValueType::AllocatorType& a) { return v.SetString(data, a); }
273  };
274  #if RAPIDJSON_HAS_STDSTRING
275  template<typename ValueType>
276  struct TypeHelper<ValueType, std::basic_string<typename ValueType::Ch> > {
277      typedef std::basic_string<typename ValueType::Ch> StringType;
278      static bool Is(const ValueType& v) { return v.IsString(); }
279      static StringType Get(const ValueType& v) { return StringType(v.GetString(), v.GetStringLength()); }
280      static ValueType& Set(ValueType& v, const StringType& data, typename ValueType::AllocatorType& a) { return v.SetString(data, a); }
281  };
282  #endif
283  template<typename ValueType>
284  struct TypeHelper<ValueType, typename ValueType::Array> {
285      typedef typename ValueType::Array ArrayType;
286      static bool Is(const ValueType& v) { return v.IsArray(); }
287      static ArrayType Get(ValueType& v) { return v.GetArray(); }
288      static ValueType& Set(ValueType& v, ArrayType data) { return v = data; }
289      static ValueType& Set(ValueType& v, ArrayType data, typename ValueType::AllocatorType&) { return v = data; }
290  };
291  template<typename ValueType>
292  struct TypeHelper<ValueType, typename ValueType::ConstArray> {
293      typedef typename ValueType::ConstArray ArrayType;
294      static bool Is(const ValueType& v) { return v.IsArray(); }
295      static ArrayType Get(const ValueType& v) { return v.GetArray(); }
296  };
297  template<typename ValueType>
298  struct TypeHelper<ValueType, typename ValueType::Object> {
299      typedef typename ValueType::Object ObjectType;
300      static bool Is(const ValueType& v) { return v.IsObject(); }
301      static ObjectType Get(ValueType& v) { return v.GetObject(); }
302      static ValueType& Set(ValueType& v, ObjectType data) { return v = data; }
303      static ValueType& Set(ValueType& v, ObjectType data, typename ValueType::AllocatorType&) { return v = data; }
304  };
305  template<typename ValueType>
306  struct TypeHelper<ValueType, typename ValueType::ConstObject> {
307      typedef typename ValueType::ConstObject ObjectType;
308      static bool Is(const ValueType& v) { return v.IsObject(); }
309      static ObjectType Get(const ValueType& v) { return v.GetObject(); }
310  };
311  } 
312  template <bool, typename> class GenericArray;
313  template <bool, typename> class GenericObject;
314  template <typename Encoding, typename Allocator = RAPIDJSON_DEFAULT_ALLOCATOR >
315  class GenericValue {
316  public:
317      typedef GenericMember<Encoding, Allocator> Member;
318      typedef Encoding EncodingType;                  
319      typedef Allocator AllocatorType;                
320      typedef typename Encoding::Ch Ch;               
321      typedef GenericStringRef<Ch> StringRefType;     
322      typedef typename GenericMemberIterator<false,Encoding,Allocator>::Iterator MemberIterator;  
323      typedef typename GenericMemberIterator<true,Encoding,Allocator>::Iterator ConstMemberIterator;  
324      typedef GenericValue* ValueIterator;            
325      typedef const GenericValue* ConstValueIterator; 
326      typedef GenericValue<Encoding, Allocator> ValueType;    
327      typedef GenericArray<false, ValueType> Array;
328      typedef GenericArray<true, ValueType> ConstArray;
329      typedef GenericObject<false, ValueType> Object;
330      typedef GenericObject<true, ValueType> ConstObject;
331      GenericValue() RAPIDJSON_NOEXCEPT : data_() { data_.f.flags = kNullFlag; }
332  #if RAPIDJSON_HAS_CXX11_RVALUE_REFS
333      GenericValue(GenericValue&& rhs) RAPIDJSON_NOEXCEPT : data_(rhs.data_) {
334          rhs.data_.f.flags = kNullFlag; 
335      }
336  #endif
337  private:
338      GenericValue(const GenericValue& rhs);
339  #if RAPIDJSON_HAS_CXX11_RVALUE_REFS
340      template <typename StackAllocator>
341      GenericValue(GenericDocument<Encoding,Allocator,StackAllocator>&& rhs);
342      template <typename StackAllocator>
343      GenericValue& operator=(GenericDocument<Encoding,Allocator,StackAllocator>&& rhs);
344  #endif
345  public:
346      explicit GenericValue(Type type) RAPIDJSON_NOEXCEPT : data_() {
347          static const uint16_t defaultFlags[] = {
348              kNullFlag, kFalseFlag, kTrueFlag, kObjectFlag, kArrayFlag, kShortStringFlag,
349              kNumberAnyFlag
350          };
351          RAPIDJSON_NOEXCEPT_ASSERT(type >= kNullType && type <= kNumberType);
352          data_.f.flags = defaultFlags[type];
353          if (type == kStringType)
354              data_.ss.SetLength(0);
355      }
356      template <typename SourceAllocator>
357      GenericValue(const GenericValue<Encoding,SourceAllocator>& rhs, Allocator& allocator, bool copyConstStrings = false) {
358          switch (rhs.GetType()) {
359          case kObjectType:
360              DoCopyMembers(rhs, allocator, copyConstStrings);
361              break;
362          case kArrayType: {
363                  SizeType count = rhs.data_.a.size;
364                  GenericValue* le = reinterpret_cast<GenericValue*>(allocator.Malloc(count * sizeof(GenericValue)));
365                  const GenericValue<Encoding,SourceAllocator>* re = rhs.GetElementsPointer();
366                  for (SizeType i = 0; i < count; i++)
367                      new (&le[i]) GenericValue(re[i], allocator, copyConstStrings);
368                  data_.f.flags = kArrayFlag;
369                  data_.a.size = data_.a.capacity = count;
370                  SetElementsPointer(le);
371              }
372              break;
373          case kStringType:
374              if (rhs.data_.f.flags == kConstStringFlag && !copyConstStrings) {
375                  data_.f.flags = rhs.data_.f.flags;
376                  data_  = *reinterpret_cast<const Data*>(&rhs.data_);
377              }
378              else
379                  SetStringRaw(StringRef(rhs.GetString(), rhs.GetStringLength()), allocator);
380              break;
381          default:
382              data_.f.flags = rhs.data_.f.flags;
383              data_  = *reinterpret_cast<const Data*>(&rhs.data_);
384              break;
385          }
386      }
387  #ifndef RAPIDJSON_DOXYGEN_RUNNING 
388      template <typename T>
389      explicit GenericValue(T b, RAPIDJSON_ENABLEIF((internal::IsSame<bool, T>))) RAPIDJSON_NOEXCEPT  
390  #else
391      explicit GenericValue(bool b) RAPIDJSON_NOEXCEPT
392  #endif
393          : data_() {
394              RAPIDJSON_STATIC_ASSERT((internal::IsSame<bool,T>::Value));
395              data_.f.flags = b ? kTrueFlag : kFalseFlag;
396      }
397      explicit GenericValue(int i) RAPIDJSON_NOEXCEPT : data_() {
398          data_.n.i64 = i;
399          data_.f.flags = (i >= 0) ? (kNumberIntFlag | kUintFlag | kUint64Flag) : kNumberIntFlag;
400      }
401      explicit GenericValue(unsigned u) RAPIDJSON_NOEXCEPT : data_() {
402          data_.n.u64 = u;
403          data_.f.flags = (u & 0x80000000) ? kNumberUintFlag : (kNumberUintFlag | kIntFlag | kInt64Flag);
404      }
405      explicit GenericValue(int64_t i64) RAPIDJSON_NOEXCEPT : data_() {
406          data_.n.i64 = i64;
407          data_.f.flags = kNumberInt64Flag;
408          if (i64 >= 0) {
409              data_.f.flags |= kNumberUint64Flag;
410              if (!(static_cast<uint64_t>(i64) & RAPIDJSON_UINT64_C2(0xFFFFFFFF, 0x00000000)))
411                  data_.f.flags |= kUintFlag;
412              if (!(static_cast<uint64_t>(i64) & RAPIDJSON_UINT64_C2(0xFFFFFFFF, 0x80000000)))
413                  data_.f.flags |= kIntFlag;
414          }
415          else if (i64 >= static_cast<int64_t>(RAPIDJSON_UINT64_C2(0xFFFFFFFF, 0x80000000)))
416              data_.f.flags |= kIntFlag;
417      }
418      explicit GenericValue(uint64_t u64) RAPIDJSON_NOEXCEPT : data_() {
419          data_.n.u64 = u64;
420          data_.f.flags = kNumberUint64Flag;
421          if (!(u64 & RAPIDJSON_UINT64_C2(0x80000000, 0x00000000)))
422              data_.f.flags |= kInt64Flag;
423          if (!(u64 & RAPIDJSON_UINT64_C2(0xFFFFFFFF, 0x00000000)))
424              data_.f.flags |= kUintFlag;
425          if (!(u64 & RAPIDJSON_UINT64_C2(0xFFFFFFFF, 0x80000000)))
426              data_.f.flags |= kIntFlag;
427      }
428      explicit GenericValue(double d) RAPIDJSON_NOEXCEPT : data_() { data_.n.d = d; data_.f.flags = kNumberDoubleFlag; }
429      explicit GenericValue(float f) RAPIDJSON_NOEXCEPT : data_() { data_.n.d = static_cast<double>(f); data_.f.flags = kNumberDoubleFlag; }
430      GenericValue(const Ch* s, SizeType length) RAPIDJSON_NOEXCEPT : data_() { SetStringRaw(StringRef(s, length)); }
431      explicit GenericValue(StringRefType s) RAPIDJSON_NOEXCEPT : data_() { SetStringRaw(s); }
432      GenericValue(const Ch* s, SizeType length, Allocator& allocator) : data_() { SetStringRaw(StringRef(s, length), allocator); }
433      GenericValue(const Ch*s, Allocator& allocator) : data_() { SetStringRaw(StringRef(s), allocator); }
434  #if RAPIDJSON_HAS_STDSTRING
435      GenericValue(const std::basic_string<Ch>& s, Allocator& allocator) : data_() { SetStringRaw(StringRef(s), allocator); }
436  #endif
437      GenericValue(Array a) RAPIDJSON_NOEXCEPT : data_(a.value_.data_) {
438          a.value_.data_ = Data();
439          a.value_.data_.f.flags = kArrayFlag;
440      }
441      GenericValue(Object o) RAPIDJSON_NOEXCEPT : data_(o.value_.data_) {
442          o.value_.data_ = Data();
443          o.value_.data_.f.flags = kObjectFlag;
444      }
445      ~GenericValue() {
446          if (Allocator::kNeedFree || (RAPIDJSON_USE_MEMBERSMAP+0 &&
447                                       internal::IsRefCounted<Allocator>::Value)) {
448              switch(data_.f.flags) {
449              case kArrayFlag:
450                  {
451                      GenericValue* e = GetElementsPointer();
452                      for (GenericValue* v = e; v != e + data_.a.size; ++v)
453                          v->~GenericValue();
454                      if (Allocator::kNeedFree) { 
455                          Allocator::Free(e);
456                      }
457                  }
458                  break;
459              case kObjectFlag:
460                  DoFreeMembers();
461                  break;
462              case kCopyStringFlag:
463                  if (Allocator::kNeedFree) { 
464                      Allocator::Free(const_cast<Ch*>(GetStringPointer()));
465                  }
466                  break;
467              default:
468                  break;  
469              }
470          }
471      }
472      GenericValue& operator=(GenericValue& rhs) RAPIDJSON_NOEXCEPT {
473          if (RAPIDJSON_LIKELY(this != &rhs)) {
474              GenericValue temp;
475              temp.RawAssign(rhs);
476              this->~GenericValue();
477              RawAssign(temp);
478          }
479          return *this;
480      }
481  #if RAPIDJSON_HAS_CXX11_RVALUE_REFS
482      GenericValue& operator=(GenericValue&& rhs) RAPIDJSON_NOEXCEPT {
483          return *this = rhs.Move();
484      }
485  #endif
486      GenericValue& operator=(StringRefType str) RAPIDJSON_NOEXCEPT {
487          GenericValue s(str);
488          return *this = s;
489      }
490      template <typename T>
491      RAPIDJSON_DISABLEIF_RETURN((internal::IsPointer<T>), (GenericValue&))
492      operator=(T value) {
493          GenericValue v(value);
494          return *this = v;
495      }
496      template <typename SourceAllocator>
497      GenericValue& CopyFrom(const GenericValue<Encoding, SourceAllocator>& rhs, Allocator& allocator, bool copyConstStrings = false) {
498          RAPIDJSON_ASSERT(static_cast<void*>(this) != static_cast<void const*>(&rhs));
499          this->~GenericValue();
500          new (this) GenericValue(rhs, allocator, copyConstStrings);
501          return *this;
502      }
503      GenericValue& Swap(GenericValue& other) RAPIDJSON_NOEXCEPT {
504          GenericValue temp;
505          temp.RawAssign(*this);
506          RawAssign(other);
507          other.RawAssign(temp);
508          return *this;
509      }
510      friend inline void swap(GenericValue& a, GenericValue& b) RAPIDJSON_NOEXCEPT { a.Swap(b); }
511      GenericValue& Move() RAPIDJSON_NOEXCEPT { return *this; }
512      template <typename SourceAllocator>
513      bool operator==(const GenericValue<Encoding, SourceAllocator>& rhs) const {
514          typedef GenericValue<Encoding, SourceAllocator> RhsType;
515          if (GetType() != rhs.GetType())
516              return false;
517          switch (GetType()) {
518          case kObjectType: 
519              if (data_.o.size != rhs.data_.o.size)
520                  return false;
521              for (ConstMemberIterator lhsMemberItr = MemberBegin(); lhsMemberItr != MemberEnd(); ++lhsMemberItr) {
522                  typename RhsType::ConstMemberIterator rhsMemberItr = rhs.FindMember(lhsMemberItr->name);
523                  if (rhsMemberItr == rhs.MemberEnd() || lhsMemberItr->value != rhsMemberItr->value)
524                      return false;
525              }
526              return true;
527          case kArrayType:
528              if (data_.a.size != rhs.data_.a.size)
529                  return false;
530              for (SizeType i = 0; i < data_.a.size; i++)
531                  if ((*this)[i] != rhs[i])
532                      return false;
533              return true;
534          case kStringType:
535              return StringEqual(rhs);
536          case kNumberType:
537              if (IsDouble() || rhs.IsDouble()) {
538                  double a = GetDouble();     
539                  double b = rhs.GetDouble(); 
540                  return a >= b && a <= b;    
541              }
542              else
543                  return data_.n.u64 == rhs.data_.n.u64;
544          default:
545              return true;
546          }
547      }
548      bool operator==(const Ch* rhs) const { return *this == GenericValue(StringRef(rhs)); }
549  #if RAPIDJSON_HAS_STDSTRING
550      bool operator==(const std::basic_string<Ch>& rhs) const { return *this == GenericValue(StringRef(rhs)); }
551  #endif
552      template <typename T> RAPIDJSON_DISABLEIF_RETURN((internal::OrExpr<internal::IsPointer<T>,internal::IsGenericValue<T> >), (bool)) operator==(const T& rhs) const { return *this == GenericValue(rhs); }
553      template <typename SourceAllocator>
554      bool operator!=(const GenericValue<Encoding, SourceAllocator>& rhs) const { return !(*this == rhs); }
555      bool operator!=(const Ch* rhs) const { return !(*this == rhs); }
556      template <typename T> RAPIDJSON_DISABLEIF_RETURN((internal::IsGenericValue<T>), (bool)) operator!=(const T& rhs) const { return !(*this == rhs); }
557  #ifndef __cpp_lib_three_way_comparison
558      template <typename T> friend RAPIDJSON_DISABLEIF_RETURN((internal::IsGenericValue<T>), (bool)) operator==(const T& lhs, const GenericValue& rhs) { return rhs == lhs; }
559      template <typename T> friend RAPIDJSON_DISABLEIF_RETURN((internal::IsGenericValue<T>), (bool)) operator!=(const T& lhs, const GenericValue& rhs) { return !(rhs == lhs); }
560  #endif
561      Type GetType()  const { return static_cast<Type>(data_.f.flags & kTypeMask); }
562      bool IsNull()   const { return data_.f.flags == kNullFlag; }
563      bool IsFalse()  const { return data_.f.flags == kFalseFlag; }
564      bool IsTrue()   const { return data_.f.flags == kTrueFlag; }
565      bool IsBool()   const { return (data_.f.flags & kBoolFlag) != 0; }
566      bool IsObject() const { return data_.f.flags == kObjectFlag; }
567      bool IsArray()  const { return data_.f.flags == kArrayFlag; }
568      bool IsNumber() const { return (data_.f.flags & kNumberFlag) != 0; }
569      bool IsInt()    const { return (data_.f.flags & kIntFlag) != 0; }
570      bool IsUint()   const { return (data_.f.flags & kUintFlag) != 0; }
571      bool IsInt64()  const { return (data_.f.flags & kInt64Flag) != 0; }
572      bool IsUint64() const { return (data_.f.flags & kUint64Flag) != 0; }
573      bool IsDouble() const { return (data_.f.flags & kDoubleFlag) != 0; }
574      bool IsString() const { return (data_.f.flags & kStringFlag) != 0; }
575      bool IsLosslessDouble() const {
576          if (!IsNumber()) return false;
577          if (IsUint64()) {
578              uint64_t u = GetUint64();
579              volatile double d = static_cast<double>(u);
580              return (d >= 0.0)
581                  && (d < static_cast<double>((std::numeric_limits<uint64_t>::max)()))
582                  && (u == static_cast<uint64_t>(d));
583          }
584          if (IsInt64()) {
585              int64_t i = GetInt64();
586              volatile double d = static_cast<double>(i);
587              return (d >= static_cast<double>((std::numeric_limits<int64_t>::min)()))
588                  && (d < static_cast<double>((std::numeric_limits<int64_t>::max)()))
589                  && (i == static_cast<int64_t>(d));
590          }
591          return true; 
592      }
593      bool IsFloat() const  {
594          if ((data_.f.flags & kDoubleFlag) == 0)
595              return false;
596          double d = GetDouble();
597          return d >= -3.4028234e38 && d <= 3.4028234e38;
598      }
599      bool IsLosslessFloat() const {
600          if (!IsNumber()) return false;
601          double a = GetDouble();
602          if (a < static_cast<double>(-(std::numeric_limits<float>::max)())
603                  || a > static_cast<double>((std::numeric_limits<float>::max)()))
604              return false;
605          double b = static_cast<double>(static_cast<float>(a));
606          return a >= b && a <= b;    
607      }
608      GenericValue& SetNull() { this->~GenericValue(); new (this) GenericValue(); return *this; }
609      bool GetBool() const { RAPIDJSON_ASSERT(IsBool()); return data_.f.flags == kTrueFlag; }
610      GenericValue& SetBool(bool b) { this->~GenericValue(); new (this) GenericValue(b); return *this; }
611      GenericValue& SetObject() { this->~GenericValue(); new (this) GenericValue(kObjectType); return *this; }
612      SizeType MemberCount() const { RAPIDJSON_ASSERT(IsObject()); return data_.o.size; }
613      SizeType MemberCapacity() const { RAPIDJSON_ASSERT(IsObject()); return data_.o.capacity; }
614      bool ObjectEmpty() const { RAPIDJSON_ASSERT(IsObject()); return data_.o.size == 0; }
615      template <typename T>
616      RAPIDJSON_DISABLEIF_RETURN((internal::NotExpr<internal::IsSame<typename internal::RemoveConst<T>::Type, Ch> >),(GenericValue&)) operator[](T* name) {
617          GenericValue n(StringRef(name));
618          return (*this)[n];
619      }
620      template <typename T>
621      RAPIDJSON_DISABLEIF_RETURN((internal::NotExpr<internal::IsSame<typename internal::RemoveConst<T>::Type, Ch> >),(const GenericValue&)) operator[](T* name) const { return const_cast<GenericValue&>(*this)[name]; }
622      template <typename SourceAllocator>
623      GenericValue& operator[](const GenericValue<Encoding, SourceAllocator>& name) {
624          MemberIterator member = FindMember(name);
625          if (member != MemberEnd())
626              return member->value;
627          else {
628              RAPIDJSON_ASSERT(false);    
629              static char buffer[sizeof(GenericValue)];
630              return *new (buffer) GenericValue();
631          }
632      }
633      template <typename SourceAllocator>
634      const GenericValue& operator[](const GenericValue<Encoding, SourceAllocator>& name) const { return const_cast<GenericValue&>(*this)[name]; }
635  #if RAPIDJSON_HAS_STDSTRING
636      GenericValue& operator[](const std::basic_string<Ch>& name) { return (*this)[GenericValue(StringRef(name))]; }
637      const GenericValue& operator[](const std::basic_string<Ch>& name) const { return (*this)[GenericValue(StringRef(name))]; }
638  #endif
639      ConstMemberIterator MemberBegin() const { RAPIDJSON_ASSERT(IsObject()); return ConstMemberIterator(GetMembersPointer()); }
640      ConstMemberIterator MemberEnd() const   { RAPIDJSON_ASSERT(IsObject()); return ConstMemberIterator(GetMembersPointer() + data_.o.size); }
641      MemberIterator MemberBegin()            { RAPIDJSON_ASSERT(IsObject()); return MemberIterator(GetMembersPointer()); }
642      MemberIterator MemberEnd()              { RAPIDJSON_ASSERT(IsObject()); return MemberIterator(GetMembersPointer() + data_.o.size); }
643      GenericValue& MemberReserve(SizeType newCapacity, Allocator &allocator) {
644          RAPIDJSON_ASSERT(IsObject());
645          DoReserveMembers(newCapacity, allocator);
646          return *this;
647      }
648      bool HasMember(const Ch* name) const { return FindMember(name) != MemberEnd(); }
649  #if RAPIDJSON_HAS_STDSTRING
650      bool HasMember(const std::basic_string<Ch>& name) const { return FindMember(name) != MemberEnd(); }
651  #endif
652      template <typename SourceAllocator>
653      bool HasMember(const GenericValue<Encoding, SourceAllocator>& name) const { return FindMember(name) != MemberEnd(); }
654      MemberIterator FindMember(const Ch* name) {
655          GenericValue n(StringRef(name));
656          return FindMember(n);
657      }
658      ConstMemberIterator FindMember(const Ch* name) const { return const_cast<GenericValue&>(*this).FindMember(name); }
659      template <typename SourceAllocator>
660      MemberIterator FindMember(const GenericValue<Encoding, SourceAllocator>& name) {
661          RAPIDJSON_ASSERT(IsObject());
662          RAPIDJSON_ASSERT(name.IsString());
663          return DoFindMember(name);
664      }
665      template <typename SourceAllocator> ConstMemberIterator FindMember(const GenericValue<Encoding, SourceAllocator>& name) const { return const_cast<GenericValue&>(*this).FindMember(name); }
666  #if RAPIDJSON_HAS_STDSTRING
667      MemberIterator FindMember(const std::basic_string<Ch>& name) { return FindMember(GenericValue(StringRef(name))); }
668      ConstMemberIterator FindMember(const std::basic_string<Ch>& name) const { return FindMember(GenericValue(StringRef(name))); }
669  #endif
670      GenericValue& AddMember(GenericValue& name, GenericValue& value, Allocator& allocator) {
671          RAPIDJSON_ASSERT(IsObject());
672          RAPIDJSON_ASSERT(name.IsString());
673          DoAddMember(name, value, allocator);
674          return *this;
675      }
676      GenericValue& AddMember(GenericValue& name, StringRefType value, Allocator& allocator) {
677          GenericValue v(value);
678          return AddMember(name, v, allocator);
679      }
680  #if RAPIDJSON_HAS_STDSTRING
681      GenericValue& AddMember(GenericValue& name, std::basic_string<Ch>& value, Allocator& allocator) {
682          GenericValue v(value, allocator);
683          return AddMember(name, v, allocator);
684      }
685  #endif
686      template <typename T>
687      RAPIDJSON_DISABLEIF_RETURN((internal::OrExpr<internal::IsPointer<T>, internal::IsGenericValue<T> >), (GenericValue&))
688      AddMember(GenericValue& name, T value, Allocator& allocator) {
689          GenericValue v(value);
690          return AddMember(name, v, allocator);
691      }
692  #if RAPIDJSON_HAS_CXX11_RVALUE_REFS
693      GenericValue& AddMember(GenericValue&& name, GenericValue&& value, Allocator& allocator) {
694          return AddMember(name, value, allocator);
695      }
696      GenericValue& AddMember(GenericValue&& name, GenericValue& value, Allocator& allocator) {
697          return AddMember(name, value, allocator);
698      }
699      GenericValue& AddMember(GenericValue& name, GenericValue&& value, Allocator& allocator) {
700          return AddMember(name, value, allocator);
701      }
702      GenericValue& AddMember(StringRefType name, GenericValue&& value, Allocator& allocator) {
703          GenericValue n(name);
704          return AddMember(n, value, allocator);
705      }
706  #endif 
707      GenericValue& AddMember(StringRefType name, GenericValue& value, Allocator& allocator) {
708          GenericValue n(name);
709          return AddMember(n, value, allocator);
710      }
711      GenericValue& AddMember(StringRefType name, StringRefType value, Allocator& allocator) {
712          GenericValue v(value);
713          return AddMember(name, v, allocator);
714      }
715      template <typename T>
716      RAPIDJSON_DISABLEIF_RETURN((internal::OrExpr<internal::IsPointer<T>, internal::IsGenericValue<T> >), (GenericValue&))
717      AddMember(StringRefType name, T value, Allocator& allocator) {
718          GenericValue n(name);
719          return AddMember(n, value, allocator);
720      }
721      void RemoveAllMembers() {
722          RAPIDJSON_ASSERT(IsObject());
723          DoClearMembers();
724      }
725      bool RemoveMember(const Ch* name) {
726          GenericValue n(StringRef(name));
727          return RemoveMember(n);
728      }
729  #if RAPIDJSON_HAS_STDSTRING
730      bool RemoveMember(const std::basic_string<Ch>& name) { return RemoveMember(GenericValue(StringRef(name))); }
731  #endif
732      template <typename SourceAllocator>
733      bool RemoveMember(const GenericValue<Encoding, SourceAllocator>& name) {
734          MemberIterator m = FindMember(name);
735          if (m != MemberEnd()) {
736              RemoveMember(m);
737              return true;
738          }
739          else
740              return false;
741      }
742      MemberIterator RemoveMember(MemberIterator m) {
743          RAPIDJSON_ASSERT(IsObject());
744          RAPIDJSON_ASSERT(data_.o.size > 0);
745          RAPIDJSON_ASSERT(GetMembersPointer() != 0);
746          RAPIDJSON_ASSERT(m >= MemberBegin() && m < MemberEnd());
747          return DoRemoveMember(m);
748      }
749      MemberIterator EraseMember(ConstMemberIterator pos) {
750          return EraseMember(pos, pos +1);
751      }
752      MemberIterator EraseMember(ConstMemberIterator first, ConstMemberIterator last) {
753          RAPIDJSON_ASSERT(IsObject());
754          RAPIDJSON_ASSERT(data_.o.size > 0);
755          RAPIDJSON_ASSERT(GetMembersPointer() != 0);
756          RAPIDJSON_ASSERT(first >= MemberBegin());
757          RAPIDJSON_ASSERT(first <= last);
758          RAPIDJSON_ASSERT(last <= MemberEnd());
759          return DoEraseMembers(first, last);
760      }
761      bool EraseMember(const Ch* name) {
762          GenericValue n(StringRef(name));
763          return EraseMember(n);
764      }
765  #if RAPIDJSON_HAS_STDSTRING
766      bool EraseMember(const std::basic_string<Ch>& name) { return EraseMember(GenericValue(StringRef(name))); }
767  #endif
768      template <typename SourceAllocator>
769      bool EraseMember(const GenericValue<Encoding, SourceAllocator>& name) {
770          MemberIterator m = FindMember(name);
771          if (m != MemberEnd()) {
772              EraseMember(m);
773              return true;
774          }
775          else
776              return false;
777      }
778      Object GetObject() { RAPIDJSON_ASSERT(IsObject()); return Object(*this); }
779      Object GetObj() { RAPIDJSON_ASSERT(IsObject()); return Object(*this); }
780      ConstObject GetObject() const { RAPIDJSON_ASSERT(IsObject()); return ConstObject(*this); }
781      ConstObject GetObj() const { RAPIDJSON_ASSERT(IsObject()); return ConstObject(*this); }
782      GenericValue& SetArray() { this->~GenericValue(); new (this) GenericValue(kArrayType); return *this; }
783      SizeType Size() const { RAPIDJSON_ASSERT(IsArray()); return data_.a.size; }
784      SizeType Capacity() const { RAPIDJSON_ASSERT(IsArray()); return data_.a.capacity; }
785      bool Empty() const { RAPIDJSON_ASSERT(IsArray()); return data_.a.size == 0; }
786      void Clear() {
787          RAPIDJSON_ASSERT(IsArray());
788          GenericValue* e = GetElementsPointer();
789          for (GenericValue* v = e; v != e + data_.a.size; ++v)
790              v->~GenericValue();
791          data_.a.size = 0;
792      }
793      GenericValue& operator[](SizeType index) {
794          RAPIDJSON_ASSERT(IsArray());
795          RAPIDJSON_ASSERT(index < data_.a.size);
796          return GetElementsPointer()[index];
797      }
798      const GenericValue& operator[](SizeType index) const { return const_cast<GenericValue&>(*this)[index]; }
799      ValueIterator Begin() { RAPIDJSON_ASSERT(IsArray()); return GetElementsPointer(); }
800      ValueIterator End() { RAPIDJSON_ASSERT(IsArray()); return GetElementsPointer() + data_.a.size; }
801      ConstValueIterator Begin() const { return const_cast<GenericValue&>(*this).Begin(); }
802      ConstValueIterator End() const { return const_cast<GenericValue&>(*this).End(); }
803      GenericValue& Reserve(SizeType newCapacity, Allocator &allocator) {
804          RAPIDJSON_ASSERT(IsArray());
805          if (newCapacity > data_.a.capacity) {
806              SetElementsPointer(reinterpret_cast<GenericValue*>(allocator.Realloc(GetElementsPointer(), data_.a.capacity * sizeof(GenericValue), newCapacity * sizeof(GenericValue))));
807              data_.a.capacity = newCapacity;
808          }
809          return *this;
810      }
811      GenericValue& PushBack(GenericValue& value, Allocator& allocator) {
812          RAPIDJSON_ASSERT(IsArray());
813          if (data_.a.size >= data_.a.capacity)
814              Reserve(data_.a.capacity == 0 ? kDefaultArrayCapacity : (data_.a.capacity + (data_.a.capacity + 1) / 2), allocator);
815          GetElementsPointer()[data_.a.size++].RawAssign(value);
816          return *this;
817      }
818  #if RAPIDJSON_HAS_CXX11_RVALUE_REFS
819      GenericValue& PushBack(GenericValue&& value, Allocator& allocator) {
820          return PushBack(value, allocator);
821      }
822  #endif 
823      GenericValue& PushBack(StringRefType value, Allocator& allocator) {
824          return (*this).template PushBack<StringRefType>(value, allocator);
825      }
826      template <typename T>
827      RAPIDJSON_DISABLEIF_RETURN((internal::OrExpr<internal::IsPointer<T>, internal::IsGenericValue<T> >), (GenericValue&))
828      PushBack(T value, Allocator& allocator) {
829          GenericValue v(value);
830          return PushBack(v, allocator);
831      }
832      GenericValue& PopBack() {
833          RAPIDJSON_ASSERT(IsArray());
834          RAPIDJSON_ASSERT(!Empty());
835          GetElementsPointer()[--data_.a.size].~GenericValue();
836          return *this;
837      }
838      ValueIterator Erase(ConstValueIterator pos) {
839          return Erase(pos, pos + 1);
840      }
841      ValueIterator Erase(ConstValueIterator first, ConstValueIterator last) {
842          RAPIDJSON_ASSERT(IsArray());
843          RAPIDJSON_ASSERT(data_.a.size > 0);
844          RAPIDJSON_ASSERT(GetElementsPointer() != 0);
845          RAPIDJSON_ASSERT(first >= Begin());
846          RAPIDJSON_ASSERT(first <= last);
847          RAPIDJSON_ASSERT(last <= End());
848          ValueIterator pos = Begin() + (first - Begin());
849          for (ValueIterator itr = pos; itr != last; ++itr)
850              itr->~GenericValue();
851          std::memmove(static_cast<void*>(pos), last, static_cast<size_t>(End() - last) * sizeof(GenericValue));
852          data_.a.size -= static_cast<SizeType>(last - first);
853          return pos;
854      }
855      Array GetArray() { RAPIDJSON_ASSERT(IsArray()); return Array(*this); }
856      ConstArray GetArray() const { RAPIDJSON_ASSERT(IsArray()); return ConstArray(*this); }
857      int GetInt() const          { RAPIDJSON_ASSERT(data_.f.flags & kIntFlag);   return data_.n.i.i;   }
858      unsigned GetUint() const    { RAPIDJSON_ASSERT(data_.f.flags & kUintFlag);  return data_.n.u.u;   }
859      int64_t GetInt64() const    { RAPIDJSON_ASSERT(data_.f.flags & kInt64Flag); return data_.n.i64; }
860      uint64_t GetUint64() const  { RAPIDJSON_ASSERT(data_.f.flags & kUint64Flag); return data_.n.u64; }
861      double GetDouble() const {
862          RAPIDJSON_ASSERT(IsNumber());
863          if ((data_.f.flags & kDoubleFlag) != 0)                return data_.n.d;   
864          if ((data_.f.flags & kIntFlag) != 0)                   return data_.n.i.i; 
865          if ((data_.f.flags & kUintFlag) != 0)                  return data_.n.u.u; 
866          if ((data_.f.flags & kInt64Flag) != 0)                 return static_cast<double>(data_.n.i64); 
867          RAPIDJSON_ASSERT((data_.f.flags & kUint64Flag) != 0);  return static_cast<double>(data_.n.u64); 
868      }
869      float GetFloat() const {
870          return static_cast<float>(GetDouble());
871      }
872      GenericValue& SetInt(int i)             { this->~GenericValue(); new (this) GenericValue(i);    return *this; }
873      GenericValue& SetUint(unsigned u)       { this->~GenericValue(); new (this) GenericValue(u);    return *this; }
874      GenericValue& SetInt64(int64_t i64)     { this->~GenericValue(); new (this) GenericValue(i64);  return *this; }
875      GenericValue& SetUint64(uint64_t u64)   { this->~GenericValue(); new (this) GenericValue(u64);  return *this; }
876      GenericValue& SetDouble(double d)       { this->~GenericValue(); new (this) GenericValue(d);    return *this; }
877      GenericValue& SetFloat(float f)         { this->~GenericValue(); new (this) GenericValue(static_cast<double>(f)); return *this; }
878      const Ch* GetString() const { RAPIDJSON_ASSERT(IsString()); return DataString(data_); }
879      SizeType GetStringLength() const { RAPIDJSON_ASSERT(IsString()); return DataStringLength(data_); }
880      GenericValue& SetString(const Ch* s, SizeType length) { return SetString(StringRef(s, length)); }
881      GenericValue& SetString(StringRefType s) { this->~GenericValue(); SetStringRaw(s); return *this; }
882      GenericValue& SetString(const Ch* s, SizeType length, Allocator& allocator) { return SetString(StringRef(s, length), allocator); }
883      GenericValue& SetString(const Ch* s, Allocator& allocator) { return SetString(StringRef(s), allocator); }
884      GenericValue& SetString(StringRefType s, Allocator& allocator) { this->~GenericValue(); SetStringRaw(s, allocator); return *this; }
885  #if RAPIDJSON_HAS_STDSTRING
886      GenericValue& SetString(const std::basic_string<Ch>& s, Allocator& allocator) { return SetString(StringRef(s), allocator); }
887  #endif
888      template <typename T>
889      bool Is() const { return internal::TypeHelper<ValueType, T>::Is(*this); }
890      template <typename T>
891      T Get() const { return internal::TypeHelper<ValueType, T>::Get(*this); }
892      template <typename T>
893      T Get() { return internal::TypeHelper<ValueType, T>::Get(*this); }
894      template<typename T>
895      ValueType& Set(const T& data) { return internal::TypeHelper<ValueType, T>::Set(*this, data); }
896      template<typename T>
897      ValueType& Set(const T& data, AllocatorType& allocator) { return internal::TypeHelper<ValueType, T>::Set(*this, data, allocator); }
898      template <typename Handler>
899      bool Accept(Handler& handler) const {
900          switch(GetType()) {
901          case kNullType:     return handler.Null();
902          case kFalseType:    return handler.Bool(false);
903          case kTrueType:     return handler.Bool(true);
904          case kObjectType:
905              if (RAPIDJSON_UNLIKELY(!handler.StartObject()))
906                  return false;
907              for (ConstMemberIterator m = MemberBegin(); m != MemberEnd(); ++m) {
908                  RAPIDJSON_ASSERT(m->name.IsString()); 
909                  if (RAPIDJSON_UNLIKELY(!handler.Key(m->name.GetString(), m->name.GetStringLength(), (m->name.data_.f.flags & kCopyFlag) != 0)))
910                      return false;
911                  if (RAPIDJSON_UNLIKELY(!m->value.Accept(handler)))
912                      return false;
913              }
914              return handler.EndObject(data_.o.size);
915          case kArrayType:
916              if (RAPIDJSON_UNLIKELY(!handler.StartArray()))
917                  return false;
918              for (ConstValueIterator v = Begin(); v != End(); ++v)
919                  if (RAPIDJSON_UNLIKELY(!v->Accept(handler)))
920                      return false;
921              return handler.EndArray(data_.a.size);
922          case kStringType:
923              return handler.String(GetString(), GetStringLength(), (data_.f.flags & kCopyFlag) != 0);
924          default:
925              RAPIDJSON_ASSERT(GetType() == kNumberType);
926              if (IsDouble())         return handler.Double(data_.n.d);
927              else if (IsInt())       return handler.Int(data_.n.i.i);
928              else if (IsUint())      return handler.Uint(data_.n.u.u);
929              else if (IsInt64())     return handler.Int64(data_.n.i64);
930              else                    return handler.Uint64(data_.n.u64);
931          }
932      }
933  private:
934      template <typename, typename> friend class GenericValue;
935      template <typename, typename, typename> friend class GenericDocument;
936      enum {
<span onclick='openModal()' class='match'>937          kBoolFlag       = 0x0008,
938          kNumberFlag     = 0x0010,
939          kIntFlag        = 0x0020,
940          kUintFlag       = 0x0040,
941          kInt64Flag      = 0x0080,
942          kUint64Flag     = 0x0100,
943          kDoubleFlag     = 0x0200,
944          kStringFlag     = 0x0400,
945          kCopyFlag       = 0x0800,
946          kInlineStrFlag  = 0x1000,
947          kNullFlag = kNullType,
</span>948          kTrueFlag = static_cast<int>(kTrueType) | static_cast<int>(kBoolFlag),
949          kFalseFlag = static_cast<int>(kFalseType) | static_cast<int>(kBoolFlag),
950          kNumberIntFlag = static_cast<int>(kNumberType) | static_cast<int>(kNumberFlag | kIntFlag | kInt64Flag),
951          kNumberUintFlag = static_cast<int>(kNumberType) | static_cast<int>(kNumberFlag | kUintFlag | kUint64Flag | kInt64Flag),
952          kNumberInt64Flag = static_cast<int>(kNumberType) | static_cast<int>(kNumberFlag | kInt64Flag),
953          kNumberUint64Flag = static_cast<int>(kNumberType) | static_cast<int>(kNumberFlag | kUint64Flag),
954          kNumberDoubleFlag = static_cast<int>(kNumberType) | static_cast<int>(kNumberFlag | kDoubleFlag),
955          kNumberAnyFlag = static_cast<int>(kNumberType) | static_cast<int>(kNumberFlag | kIntFlag | kInt64Flag | kUintFlag | kUint64Flag | kDoubleFlag),
956          kConstStringFlag = static_cast<int>(kStringType) | static_cast<int>(kStringFlag),
957          kCopyStringFlag = static_cast<int>(kStringType) | static_cast<int>(kStringFlag | kCopyFlag),
958          kShortStringFlag = static_cast<int>(kStringType) | static_cast<int>(kStringFlag | kCopyFlag | kInlineStrFlag),
959          kObjectFlag = kObjectType,
960          kArrayFlag = kArrayType,
961          kTypeMask = 0x07
962      };
963      static const SizeType kDefaultArrayCapacity = RAPIDJSON_VALUE_DEFAULT_ARRAY_CAPACITY;
964      static const SizeType kDefaultObjectCapacity = RAPIDJSON_VALUE_DEFAULT_OBJECT_CAPACITY;
965      struct Flag {
966  #if RAPIDJSON_48BITPOINTER_OPTIMIZATION
967          char payload[sizeof(SizeType) * 2 + 6];     
968  #elif RAPIDJSON_64BIT
969          char payload[sizeof(SizeType) * 2 + sizeof(void*) + 6]; 
970  #else
971          char payload[sizeof(SizeType) * 2 + sizeof(void*) + 2]; 
972  #endif
973          uint16_t flags;
974      };
975      struct String {
976          SizeType length;
977          SizeType hashcode;  
978          const Ch* str;
979      };  
980      struct ShortString {
981          enum { MaxChars = sizeof(static_cast<Flag*>(0)->payload) / sizeof(Ch), MaxSize = MaxChars - 1, LenPos = MaxSize };
982          Ch str[MaxChars];
983          inline static bool Usable(SizeType len) { return                       (MaxSize >= len); }
984          inline void     SetLength(SizeType len) { str[LenPos] = static_cast<Ch>(MaxSize -  len); }
985          inline SizeType GetLength() const       { return  static_cast<SizeType>(MaxSize -  str[LenPos]); }
986      };  
987      union Number {
988  #if RAPIDJSON_ENDIAN == RAPIDJSON_LITTLEENDIAN
989          struct I {
990              int i;
991              char padding[4];
992          }i;
993          struct U {
994              unsigned u;
995              char padding2[4];
996          }u;
997  #else
998          struct I {
999              char padding[4];
1000              int i;
1001          }i;
1002          struct U {
1003              char padding2[4];
1004              unsigned u;
1005          }u;
1006  #endif
1007          int64_t i64;
1008          uint64_t u64;
1009          double d;
1010      };  
1011      struct ObjectData {
1012          SizeType size;
1013          SizeType capacity;
1014          Member* members;
1015      };  
1016      struct ArrayData {
1017          SizeType size;
1018          SizeType capacity;
1019          GenericValue* elements;
1020      };  
1021      union Data {
1022          String s;
1023          ShortString ss;
1024          Number n;
1025          ObjectData o;
1026          ArrayData a;
1027          Flag f;
1028      };  
1029      static RAPIDJSON_FORCEINLINE const Ch* DataString(const Data& data) {
1030          return (data.f.flags & kInlineStrFlag) ? data.ss.str : RAPIDJSON_GETPOINTER(Ch, data.s.str);
1031      }
1032      static RAPIDJSON_FORCEINLINE SizeType DataStringLength(const Data& data) {
1033          return (data.f.flags & kInlineStrFlag) ? data.ss.GetLength() : data.s.length;
1034      }
1035      RAPIDJSON_FORCEINLINE const Ch* GetStringPointer() const { return RAPIDJSON_GETPOINTER(Ch, data_.s.str); }
1036      RAPIDJSON_FORCEINLINE const Ch* SetStringPointer(const Ch* str) { return RAPIDJSON_SETPOINTER(Ch, data_.s.str, str); }
1037      RAPIDJSON_FORCEINLINE GenericValue* GetElementsPointer() const { return RAPIDJSON_GETPOINTER(GenericValue, data_.a.elements); }
1038      RAPIDJSON_FORCEINLINE GenericValue* SetElementsPointer(GenericValue* elements) { return RAPIDJSON_SETPOINTER(GenericValue, data_.a.elements, elements); }
1039      RAPIDJSON_FORCEINLINE Member* GetMembersPointer() const { return RAPIDJSON_GETPOINTER(Member, data_.o.members); }
1040      RAPIDJSON_FORCEINLINE Member* SetMembersPointer(Member* members) { return RAPIDJSON_SETPOINTER(Member, data_.o.members, members); }
1041  #if RAPIDJSON_USE_MEMBERSMAP
1042      struct MapTraits {
1043          struct Less {
1044              bool operator()(const Data& s1, const Data& s2) const {
1045                  SizeType n1 = DataStringLength(s1), n2 = DataStringLength(s2);
1046                  int cmp = std::memcmp(DataString(s1), DataString(s2), sizeof(Ch) * (n1 < n2 ? n1 : n2));
1047                  return cmp < 0 || (cmp == 0 && n1 < n2);
1048              }
1049          };
1050          typedef std::pair<const Data, SizeType> Pair;
1051          typedef std::multimap<Data, SizeType, Less, StdAllocator<Pair, Allocator> > Map;
1052          typedef typename Map::iterator Iterator;
1053      };
1054      typedef typename MapTraits::Map         Map;
1055      typedef typename MapTraits::Less        MapLess;
1056      typedef typename MapTraits::Pair        MapPair;
1057      typedef typename MapTraits::Iterator    MapIterator;
1058      static RAPIDJSON_FORCEINLINE size_t GetMapLayoutSize(SizeType capacity) {
1059          return RAPIDJSON_ALIGN(sizeof(Map*)) +
1060                 RAPIDJSON_ALIGN(sizeof(SizeType)) +
1061                 RAPIDJSON_ALIGN(capacity * sizeof(Member)) +
1062                 capacity * sizeof(MapIterator);
1063      }
1064      static RAPIDJSON_FORCEINLINE SizeType &GetMapCapacity(Map* &map) {
1065          return *reinterpret_cast<SizeType*>(reinterpret_cast<uintptr_t>(&map) +
1066                                              RAPIDJSON_ALIGN(sizeof(Map*)));
1067      }
1068      static RAPIDJSON_FORCEINLINE Member* GetMapMembers(Map* &map) {
1069          return reinterpret_cast<Member*>(reinterpret_cast<uintptr_t>(&map) +
1070                                           RAPIDJSON_ALIGN(sizeof(Map*)) +
1071                                           RAPIDJSON_ALIGN(sizeof(SizeType)));
1072      }
1073      static RAPIDJSON_FORCEINLINE MapIterator* GetMapIterators(Map* &map) {
1074          return reinterpret_cast<MapIterator*>(reinterpret_cast<uintptr_t>(&map) +
1075                                                RAPIDJSON_ALIGN(sizeof(Map*)) +
1076                                                RAPIDJSON_ALIGN(sizeof(SizeType)) +
1077                                                RAPIDJSON_ALIGN(GetMapCapacity(map) * sizeof(Member)));
1078      }
1079      static RAPIDJSON_FORCEINLINE Map* &GetMap(Member* members) {
1080          RAPIDJSON_ASSERT(members != 0);
1081          return *reinterpret_cast<Map**>(reinterpret_cast<uintptr_t>(members) -
1082                                          RAPIDJSON_ALIGN(sizeof(SizeType)) -
1083                                          RAPIDJSON_ALIGN(sizeof(Map*)));
1084      }
1085      RAPIDJSON_FORCEINLINE MapIterator DropMapIterator(MapIterator& rhs) {
1086  #if RAPIDJSON_HAS_CXX11
1087          MapIterator ret = std::move(rhs);
1088  #else
1089          MapIterator ret = rhs;
1090  #endif
1091          rhs.~MapIterator();
1092          return ret;
1093      }
1094      Map* &DoReallocMap(Map** oldMap, SizeType newCapacity, Allocator& allocator) {
1095          Map **newMap = static_cast<Map**>(allocator.Malloc(GetMapLayoutSize(newCapacity)));
1096          GetMapCapacity(*newMap) = newCapacity;
1097          if (!oldMap) {
1098              *newMap = new (allocator.Malloc(sizeof(Map))) Map(MapLess(), allocator);
1099          }
1100          else {
1101              *newMap = *oldMap;
1102              size_t count = (*oldMap)->size();
1103              std::memcpy(static_cast<void*>(GetMapMembers(*newMap)),
1104                          static_cast<void*>(GetMapMembers(*oldMap)),
1105                          count * sizeof(Member));
1106              MapIterator *oldIt = GetMapIterators(*oldMap),
1107                          *newIt = GetMapIterators(*newMap);
1108              while (count--) {
1109                  new (&newIt[count]) MapIterator(DropMapIterator(oldIt[count]));
1110              }
1111              Allocator::Free(oldMap);
1112          }
1113          return *newMap;
1114      }
1115      RAPIDJSON_FORCEINLINE Member* DoAllocMembers(SizeType capacity, Allocator& allocator) {
1116          return GetMapMembers(DoReallocMap(0, capacity, allocator));
1117      }
1118      void DoReserveMembers(SizeType newCapacity, Allocator& allocator) {
1119          ObjectData& o = data_.o;
1120          if (newCapacity > o.capacity) {
1121              Member* oldMembers = GetMembersPointer();
1122              Map **oldMap = oldMembers ? &GetMap(oldMembers) : 0,
1123                  *&newMap = DoReallocMap(oldMap, newCapacity, allocator);
1124              RAPIDJSON_SETPOINTER(Member, o.members, GetMapMembers(newMap));
1125              o.capacity = newCapacity;
1126          }
1127      }
1128      template <typename SourceAllocator>
1129      MemberIterator DoFindMember(const GenericValue<Encoding, SourceAllocator>& name) {
1130          if (Member* members = GetMembersPointer()) {
1131              Map* &map = GetMap(members);
1132              MapIterator mit = map->find(reinterpret_cast<const Data&>(name.data_));
1133              if (mit != map->end()) {
1134                  return MemberIterator(&members[mit->second]);
1135              }
1136          }
1137          return MemberEnd();
1138      }
1139      void DoClearMembers() {
1140          if (Member* members = GetMembersPointer()) {
1141              Map* &map = GetMap(members);
1142              MapIterator* mit = GetMapIterators(map);
1143              for (SizeType i = 0; i < data_.o.size; i++) {
1144                  map->erase(DropMapIterator(mit[i]));
1145                  members[i].~Member();
1146              }
1147              data_.o.size = 0;
1148          }
1149      }
1150      void DoFreeMembers() {
1151          if (Member* members = GetMembersPointer()) {
1152              GetMap(members)->~Map();
1153              for (SizeType i = 0; i < data_.o.size; i++) {
1154                  members[i].~Member();
1155              }
1156              if (Allocator::kNeedFree) { 
1157                  Map** map = &GetMap(members);
1158                  Allocator::Free(*map);
1159                  Allocator::Free(map);
1160              }
1161          }
1162      }
1163  #else 
1164      RAPIDJSON_FORCEINLINE Member* DoAllocMembers(SizeType capacity, Allocator& allocator) {
1165          return Malloc<Member>(allocator, capacity);
1166      }
1167      void DoReserveMembers(SizeType newCapacity, Allocator& allocator) {
1168          ObjectData& o = data_.o;
1169          if (newCapacity > o.capacity) {
1170              Member* newMembers = Realloc<Member>(allocator, GetMembersPointer(), o.capacity, newCapacity);
1171              RAPIDJSON_SETPOINTER(Member, o.members, newMembers);
1172              o.capacity = newCapacity;
1173          }
1174      }
1175      template <typename SourceAllocator>
1176      MemberIterator DoFindMember(const GenericValue<Encoding, SourceAllocator>& name) {
1177          MemberIterator member = MemberBegin();
1178          for ( ; member != MemberEnd(); ++member)
1179              if (name.StringEqual(member->name))
1180                  break;
1181          return member;
1182      }
1183      void DoClearMembers() {
1184          for (MemberIterator m = MemberBegin(); m != MemberEnd(); ++m)
1185              m->~Member();
1186          data_.o.size = 0;
1187      }
1188      void DoFreeMembers() {
1189          for (MemberIterator m = MemberBegin(); m != MemberEnd(); ++m)
1190              m->~Member();
1191          Allocator::Free(GetMembersPointer());
1192      }
1193  #endif 
1194      void DoAddMember(GenericValue& name, GenericValue& value, Allocator& allocator) {
1195          ObjectData& o = data_.o;
1196          if (o.size >= o.capacity)
1197              DoReserveMembers(o.capacity ? (o.capacity + (o.capacity + 1) / 2) : kDefaultObjectCapacity, allocator);
1198          Member* members = GetMembersPointer();
1199          Member* m = members + o.size;
1200          m->name.RawAssign(name);
1201          m->value.RawAssign(value);
1202  #if RAPIDJSON_USE_MEMBERSMAP
1203          Map* &map = GetMap(members);
1204          MapIterator* mit = GetMapIterators(map);
1205          new (&mit[o.size]) MapIterator(map->insert(MapPair(m->name.data_, o.size)));
1206  #endif
1207          ++o.size;
1208      }
1209      MemberIterator DoRemoveMember(MemberIterator m) {
1210          ObjectData& o = data_.o;
1211          Member* members = GetMembersPointer();
1212  #if RAPIDJSON_USE_MEMBERSMAP
1213          Map* &map = GetMap(members);
1214          MapIterator* mit = GetMapIterators(map);
1215          SizeType mpos = static_cast<SizeType>(&*m - members);
1216          map->erase(DropMapIterator(mit[mpos]));
1217  #endif
1218          MemberIterator last(members + (o.size - 1));
1219          if (o.size > 1 && m != last) {
1220  #if RAPIDJSON_USE_MEMBERSMAP
1221              new (&mit[mpos]) MapIterator(DropMapIterator(mit[&*last - members]));
1222              mit[mpos]->second = mpos;
1223  #endif
1224              *m = *last; 
1225          }
1226          else {
1227              m->~Member(); 
1228          }
1229          --o.size;
1230          return m;
1231      }
1232      MemberIterator DoEraseMembers(ConstMemberIterator first, ConstMemberIterator last) {
1233          ObjectData& o = data_.o;
1234          MemberIterator beg = MemberBegin(),
1235                         pos = beg + (first - beg),
1236                         end = MemberEnd();
1237  #if RAPIDJSON_USE_MEMBERSMAP
1238          Map* &map = GetMap(GetMembersPointer());
1239          MapIterator* mit = GetMapIterators(map);
1240  #endif
1241          for (MemberIterator itr = pos; itr != last; ++itr) {
1242  #if RAPIDJSON_USE_MEMBERSMAP
1243              map->erase(DropMapIterator(mit[itr - beg]));
1244  #endif
1245              itr->~Member();
1246          }
1247  #if RAPIDJSON_USE_MEMBERSMAP
1248          if (first != last) {
1249              MemberIterator next = pos + (last - first);
1250              for (MemberIterator itr = pos; next != end; ++itr, ++next) {
1251                  std::memcpy(static_cast<void*>(&*itr), &*next, sizeof(Member));
1252                  SizeType mpos = static_cast<SizeType>(itr - beg);
1253                  new (&mit[mpos]) MapIterator(DropMapIterator(mit[next - beg]));
1254                  mit[mpos]->second = mpos;
1255              }
1256          }
1257  #else
1258          std::memmove(static_cast<void*>(&*pos), &*last,
1259                       static_cast<size_t>(end - last) * sizeof(Member));
1260  #endif
1261          o.size -= static_cast<SizeType>(last - first);
1262          return pos;
1263      }
1264      template <typename SourceAllocator>
1265      void DoCopyMembers(const GenericValue<Encoding,SourceAllocator>& rhs, Allocator& allocator, bool copyConstStrings) {
1266          RAPIDJSON_ASSERT(rhs.GetType() == kObjectType);
1267          data_.f.flags = kObjectFlag;
1268          SizeType count = rhs.data_.o.size;
1269          Member* lm = DoAllocMembers(count, allocator);
1270          const typename GenericValue<Encoding,SourceAllocator>::Member* rm = rhs.GetMembersPointer();
1271  #if RAPIDJSON_USE_MEMBERSMAP
1272          Map* &map = GetMap(lm);
1273          MapIterator* mit = GetMapIterators(map);
1274  #endif
1275          for (SizeType i = 0; i < count; i++) {
1276              new (&lm[i].name) GenericValue(rm[i].name, allocator, copyConstStrings);
1277              new (&lm[i].value) GenericValue(rm[i].value, allocator, copyConstStrings);
1278  #if RAPIDJSON_USE_MEMBERSMAP
1279              new (&mit[i]) MapIterator(map->insert(MapPair(lm[i].name.data_, i)));
1280  #endif
1281          }
1282          data_.o.size = data_.o.capacity = count;
1283          SetMembersPointer(lm);
1284      }
1285      void SetArrayRaw(GenericValue* values, SizeType count, Allocator& allocator) {
1286          data_.f.flags = kArrayFlag;
1287          if (count) {
1288              GenericValue* e = static_cast<GenericValue*>(allocator.Malloc(count * sizeof(GenericValue)));
1289              SetElementsPointer(e);
1290              std::memcpy(static_cast<void*>(e), values, count * sizeof(GenericValue));
1291          }
1292          else
1293              SetElementsPointer(0);
1294          data_.a.size = data_.a.capacity = count;
1295      }
1296      void SetObjectRaw(Member* members, SizeType count, Allocator& allocator) {
1297          data_.f.flags = kObjectFlag;
1298          if (count) {
1299              Member* m = DoAllocMembers(count, allocator);
1300              SetMembersPointer(m);
1301              std::memcpy(static_cast<void*>(m), members, count * sizeof(Member));
1302  #if RAPIDJSON_USE_MEMBERSMAP
1303              Map* &map = GetMap(m);
1304              MapIterator* mit = GetMapIterators(map);
1305              for (SizeType i = 0; i < count; i++) {
1306                  new (&mit[i]) MapIterator(map->insert(MapPair(m[i].name.data_, i)));
1307              }
1308  #endif
1309          }
1310          else
1311              SetMembersPointer(0);
1312          data_.o.size = data_.o.capacity = count;
1313      }
1314      void SetStringRaw(StringRefType s) RAPIDJSON_NOEXCEPT {
1315          data_.f.flags = kConstStringFlag;
1316          SetStringPointer(s);
1317          data_.s.length = s.length;
1318      }
1319      void SetStringRaw(StringRefType s, Allocator& allocator) {
1320          Ch* str = 0;
1321          if (ShortString::Usable(s.length)) {
1322              data_.f.flags = kShortStringFlag;
1323              data_.ss.SetLength(s.length);
1324              str = data_.ss.str;
1325          } else {
1326              data_.f.flags = kCopyStringFlag;
1327              data_.s.length = s.length;
1328              str = static_cast<Ch *>(allocator.Malloc((s.length + 1) * sizeof(Ch)));
1329              SetStringPointer(str);
1330          }
1331          std::memcpy(str, s, s.length * sizeof(Ch));
1332          str[s.length] = '\0';
1333      }
1334      void RawAssign(GenericValue& rhs) RAPIDJSON_NOEXCEPT {
1335          data_ = rhs.data_;
1336          rhs.data_.f.flags = kNullFlag;
1337      }
1338      template <typename SourceAllocator>
1339      bool StringEqual(const GenericValue<Encoding, SourceAllocator>& rhs) const {
1340          RAPIDJSON_ASSERT(IsString());
1341          RAPIDJSON_ASSERT(rhs.IsString());
1342          const SizeType len1 = GetStringLength();
1343          const SizeType len2 = rhs.GetStringLength();
1344          if(len1 != len2) { return false; }
1345          const Ch* const str1 = GetString();
1346          const Ch* const str2 = rhs.GetString();
1347          if(str1 == str2) { return true; } 
1348          return (std::memcmp(str1, str2, sizeof(Ch) * len1) == 0);
1349      }
1350      Data data_;
1351  };
1352  typedef GenericValue<UTF8<> > Value;
1353  template <typename Encoding, typename Allocator = RAPIDJSON_DEFAULT_ALLOCATOR, typename StackAllocator = RAPIDJSON_DEFAULT_STACK_ALLOCATOR >
1354  class GenericDocument : public GenericValue<Encoding, Allocator> {
1355  public:
1356      typedef typename Encoding::Ch Ch;                       
1357      typedef GenericValue<Encoding, Allocator> ValueType;    
1358      typedef Allocator AllocatorType;                        
1359      explicit GenericDocument(Type type, Allocator* allocator = 0, size_t stackCapacity = kDefaultStackCapacity, StackAllocator* stackAllocator = 0) :
1360          GenericValue<Encoding, Allocator>(type),  allocator_(allocator), ownAllocator_(0), stack_(stackAllocator, stackCapacity), parseResult_()
1361      {
1362          if (!allocator_)
1363              ownAllocator_ = allocator_ = RAPIDJSON_NEW(Allocator)();
1364      }
1365      GenericDocument(Allocator* allocator = 0, size_t stackCapacity = kDefaultStackCapacity, StackAllocator* stackAllocator = 0) :
1366          allocator_(allocator), ownAllocator_(0), stack_(stackAllocator, stackCapacity), parseResult_()
1367      {
1368          if (!allocator_)
1369              ownAllocator_ = allocator_ = RAPIDJSON_NEW(Allocator)();
1370      }
1371  #if RAPIDJSON_HAS_CXX11_RVALUE_REFS
1372      GenericDocument(GenericDocument&& rhs) RAPIDJSON_NOEXCEPT
1373          : ValueType(std::forward<ValueType>(rhs)), 
1374            allocator_(rhs.allocator_),
1375            ownAllocator_(rhs.ownAllocator_),
1376            stack_(std::move(rhs.stack_)),
1377            parseResult_(rhs.parseResult_)
1378      {
1379          rhs.allocator_ = 0;
1380          rhs.ownAllocator_ = 0;
1381          rhs.parseResult_ = ParseResult();
1382      }
1383  #endif
1384      ~GenericDocument() {
1385          if (ownAllocator_) {
1386              ValueType::SetNull();
1387          }
1388          Destroy();
1389      }
1390  #if RAPIDJSON_HAS_CXX11_RVALUE_REFS
1391      GenericDocument& operator=(GenericDocument&& rhs) RAPIDJSON_NOEXCEPT
1392      {
1393          ValueType::operator=(std::forward<ValueType>(rhs));
1394          Destroy();
1395          allocator_ = rhs.allocator_;
1396          ownAllocator_ = rhs.ownAllocator_;
1397          stack_ = std::move(rhs.stack_);
1398          parseResult_ = rhs.parseResult_;
1399          rhs.allocator_ = 0;
1400          rhs.ownAllocator_ = 0;
1401          rhs.parseResult_ = ParseResult();
1402          return *this;
1403      }
1404  #endif
1405      GenericDocument& Swap(GenericDocument& rhs) RAPIDJSON_NOEXCEPT {
1406          ValueType::Swap(rhs);
1407          stack_.Swap(rhs.stack_);
1408          internal::Swap(allocator_, rhs.allocator_);
1409          internal::Swap(ownAllocator_, rhs.ownAllocator_);
1410          internal::Swap(parseResult_, rhs.parseResult_);
1411          return *this;
1412      }
1413      using ValueType::Swap;
1414      friend inline void swap(GenericDocument& a, GenericDocument& b) RAPIDJSON_NOEXCEPT { a.Swap(b); }
1415      template <typename Generator>
1416      GenericDocument& Populate(Generator& g) {
1417          ClearStackOnExit scope(*this);
1418          if (g(*this)) {
1419              RAPIDJSON_ASSERT(stack_.GetSize() == sizeof(ValueType)); 
1420              ValueType::operator=(*stack_.template Pop<ValueType>(1));
1421          }
1422          return *this;
1423      }
1424      template <unsigned parseFlags, typename SourceEncoding, typename InputStream>
1425      GenericDocument& ParseStream(InputStream& is) {
1426          GenericReader<SourceEncoding, Encoding, StackAllocator> reader(
1427              stack_.HasAllocator() ? &stack_.GetAllocator() : 0);
1428          ClearStackOnExit scope(*this);
1429          parseResult_ = reader.template Parse<parseFlags>(is, *this);
1430          if (parseResult_) {
1431              RAPIDJSON_ASSERT(stack_.GetSize() == sizeof(ValueType)); 
1432              ValueType::operator=(*stack_.template Pop<ValueType>(1));
1433          }
1434          return *this;
1435      }
1436      template <unsigned parseFlags, typename InputStream>
1437      GenericDocument& ParseStream(InputStream& is) {
1438          return ParseStream<parseFlags, Encoding, InputStream>(is);
1439      }
1440      template <typename InputStream>
1441      GenericDocument& ParseStream(InputStream& is) {
1442          return ParseStream<kParseDefaultFlags, Encoding, InputStream>(is);
1443      }
1444      template <unsigned parseFlags>
1445      GenericDocument& ParseInsitu(Ch* str) {
1446          GenericInsituStringStream<Encoding> s(str);
1447          return ParseStream<parseFlags | kParseInsituFlag>(s);
1448      }
1449      GenericDocument& ParseInsitu(Ch* str) {
1450          return ParseInsitu<kParseDefaultFlags>(str);
1451      }
1452      template <unsigned parseFlags, typename SourceEncoding>
1453      GenericDocument& Parse(const typename SourceEncoding::Ch* str) {
1454          RAPIDJSON_ASSERT(!(parseFlags & kParseInsituFlag));
1455          GenericStringStream<SourceEncoding> s(str);
1456          return ParseStream<parseFlags, SourceEncoding>(s);
1457      }
1458      template <unsigned parseFlags>
1459      GenericDocument& Parse(const Ch* str) {
1460          return Parse<parseFlags, Encoding>(str);
1461      }
1462      GenericDocument& Parse(const Ch* str) {
1463          return Parse<kParseDefaultFlags>(str);
1464      }
1465      template <unsigned parseFlags, typename SourceEncoding>
1466      GenericDocument& Parse(const typename SourceEncoding::Ch* str, size_t length) {
1467          RAPIDJSON_ASSERT(!(parseFlags & kParseInsituFlag));
1468          MemoryStream ms(reinterpret_cast<const char*>(str), length * sizeof(typename SourceEncoding::Ch));
1469          EncodedInputStream<SourceEncoding, MemoryStream> is(ms);
1470          ParseStream<parseFlags, SourceEncoding>(is);
1471          return *this;
1472      }
1473      template <unsigned parseFlags>
1474      GenericDocument& Parse(const Ch* str, size_t length) {
1475          return Parse<parseFlags, Encoding>(str, length);
1476      }
1477      GenericDocument& Parse(const Ch* str, size_t length) {
1478          return Parse<kParseDefaultFlags>(str, length);
1479      }
1480  #if RAPIDJSON_HAS_STDSTRING
1481      template <unsigned parseFlags, typename SourceEncoding>
1482      GenericDocument& Parse(const std::basic_string<typename SourceEncoding::Ch>& str) {
1483          return Parse<parseFlags, SourceEncoding>(str.c_str());
1484      }
1485      template <unsigned parseFlags>
1486      GenericDocument& Parse(const std::basic_string<Ch>& str) {
1487          return Parse<parseFlags, Encoding>(str.c_str());
1488      }
1489      GenericDocument& Parse(const std::basic_string<Ch>& str) {
1490          return Parse<kParseDefaultFlags>(str);
1491      }
1492  #endif 
1493      bool HasParseError() const { return parseResult_.IsError(); }
1494      ParseErrorCode GetParseError() const { return parseResult_.Code(); }
1495      size_t GetErrorOffset() const { return parseResult_.Offset(); }
1496  #ifndef __clang 
1497  #endif
1498      operator ParseResult() const { return parseResult_; }
1499      Allocator& GetAllocator() {
1500          RAPIDJSON_ASSERT(allocator_);
1501          return *allocator_;
1502      }
1503      size_t GetStackCapacity() const { return stack_.GetCapacity(); }
1504  private:
1505      struct ClearStackOnExit {
1506          explicit ClearStackOnExit(GenericDocument& d) : d_(d) {}
1507          ~ClearStackOnExit() { d_.ClearStack(); }
1508      private:
1509          ClearStackOnExit(const ClearStackOnExit&);
1510          ClearStackOnExit& operator=(const ClearStackOnExit&);
1511          GenericDocument& d_;
1512      };
1513      template <typename, typename> friend class GenericValue; 
1514  public:
1515      bool Null() { new (stack_.template Push<ValueType>()) ValueType(); return true; }
1516      bool Bool(bool b) { new (stack_.template Push<ValueType>()) ValueType(b); return true; }
1517      bool Int(int i) { new (stack_.template Push<ValueType>()) ValueType(i); return true; }
1518      bool Uint(unsigned i) { new (stack_.template Push<ValueType>()) ValueType(i); return true; }
1519      bool Int64(int64_t i) { new (stack_.template Push<ValueType>()) ValueType(i); return true; }
1520      bool Uint64(uint64_t i) { new (stack_.template Push<ValueType>()) ValueType(i); return true; }
1521      bool Double(double d) { new (stack_.template Push<ValueType>()) ValueType(d); return true; }
1522      bool RawNumber(const Ch* str, SizeType length, bool copy) {
1523          if (copy)
1524              new (stack_.template Push<ValueType>()) ValueType(str, length, GetAllocator());
1525          else
1526              new (stack_.template Push<ValueType>()) ValueType(str, length);
1527          return true;
1528      }
1529      bool String(const Ch* str, SizeType length, bool copy) {
1530          if (copy)
1531              new (stack_.template Push<ValueType>()) ValueType(str, length, GetAllocator());
1532          else
1533              new (stack_.template Push<ValueType>()) ValueType(str, length);
1534          return true;
1535      }
1536      bool StartObject() { new (stack_.template Push<ValueType>()) ValueType(kObjectType); return true; }
1537      bool Key(const Ch* str, SizeType length, bool copy) { return String(str, length, copy); }
1538      bool EndObject(SizeType memberCount) {
1539          typename ValueType::Member* members = stack_.template Pop<typename ValueType::Member>(memberCount);
1540          stack_.template Top<ValueType>()->SetObjectRaw(members, memberCount, GetAllocator());
1541          return true;
1542      }
1543      bool StartArray() { new (stack_.template Push<ValueType>()) ValueType(kArrayType); return true; }
1544      bool EndArray(SizeType elementCount) {
1545          ValueType* elements = stack_.template Pop<ValueType>(elementCount);
1546          stack_.template Top<ValueType>()->SetArrayRaw(elements, elementCount, GetAllocator());
1547          return true;
1548      }
1549  private:
1550      GenericDocument(const GenericDocument&);
1551      GenericDocument& operator=(const GenericDocument&);
1552      void ClearStack() {
1553          if (Allocator::kNeedFree)
1554              while (stack_.GetSize() > 0)    
1555                  (stack_.template Pop<ValueType>(1))->~ValueType();
1556          else
1557              stack_.Clear();
1558          stack_.ShrinkToFit();
1559      }
1560      void Destroy() {
1561          RAPIDJSON_DELETE(ownAllocator_);
1562      }
1563      static const size_t kDefaultStackCapacity = 1024;
1564      Allocator* allocator_;
1565      Allocator* ownAllocator_;
1566      internal::Stack<StackAllocator> stack_;
1567      ParseResult parseResult_;
1568  };
1569  typedef GenericDocument<UTF8<> > Document;
1570  template <bool Const, typename ValueT>
1571  class GenericArray {
1572  public:
1573      typedef GenericArray<true, ValueT> ConstArray;
1574      typedef GenericArray<false, ValueT> Array;
1575      typedef ValueT PlainType;
1576      typedef typename internal::MaybeAddConst<Const,PlainType>::Type ValueType;
1577      typedef ValueType* ValueIterator;  
1578      typedef const ValueT* ConstValueIterator;
1579      typedef typename ValueType::AllocatorType AllocatorType;
1580      typedef typename ValueType::StringRefType StringRefType;
1581      template <typename, typename>
1582      friend class GenericValue;
1583      GenericArray(const GenericArray& rhs) : value_(rhs.value_) {}
1584      GenericArray& operator=(const GenericArray& rhs) { value_ = rhs.value_; return *this; }
1585      ~GenericArray() {}
1586      operator ValueType&() const { return value_; }
1587      SizeType Size() const { return value_.Size(); }
1588      SizeType Capacity() const { return value_.Capacity(); }
1589      bool Empty() const { return value_.Empty(); }
1590      void Clear() const { value_.Clear(); }
1591      ValueType& operator[](SizeType index) const {  return value_[index]; }
1592      ValueIterator Begin() const { return value_.Begin(); }
1593      ValueIterator End() const { return value_.End(); }
1594      GenericArray Reserve(SizeType newCapacity, AllocatorType &allocator) const { value_.Reserve(newCapacity, allocator); return *this; }
1595      GenericArray PushBack(ValueType& value, AllocatorType& allocator) const { value_.PushBack(value, allocator); return *this; }
1596  #if RAPIDJSON_HAS_CXX11_RVALUE_REFS
1597      GenericArray PushBack(ValueType&& value, AllocatorType& allocator) const { value_.PushBack(value, allocator); return *this; }
1598  #endif 
1599      GenericArray PushBack(StringRefType value, AllocatorType& allocator) const { value_.PushBack(value, allocator); return *this; }
1600      template <typename T> RAPIDJSON_DISABLEIF_RETURN((internal::OrExpr<internal::IsPointer<T>, internal::IsGenericValue<T> >), (const GenericArray&)) PushBack(T value, AllocatorType& allocator) const { value_.PushBack(value, allocator); return *this; }
1601      GenericArray PopBack() const { value_.PopBack(); return *this; }
1602      ValueIterator Erase(ConstValueIterator pos) const { return value_.Erase(pos); }
1603      ValueIterator Erase(ConstValueIterator first, ConstValueIterator last) const { return value_.Erase(first, last); }
1604  #if RAPIDJSON_HAS_CXX11_RANGE_FOR
1605      ValueIterator begin() const { return value_.Begin(); }
1606      ValueIterator end() const { return value_.End(); }
1607  #endif
1608  private:
1609      GenericArray();
1610      GenericArray(ValueType& value) : value_(value) {}
1611      ValueType& value_;
1612  };
1613  template <bool Const, typename ValueT>
1614  class GenericObject {
1615  public:
1616      typedef GenericObject<true, ValueT> ConstObject;
1617      typedef GenericObject<false, ValueT> Object;
1618      typedef ValueT PlainType;
1619      typedef typename internal::MaybeAddConst<Const,PlainType>::Type ValueType;
1620      typedef GenericMemberIterator<Const, typename ValueT::EncodingType, typename ValueT::AllocatorType> MemberIterator;  
1621      typedef GenericMemberIterator<true, typename ValueT::EncodingType, typename ValueT::AllocatorType> ConstMemberIterator;
1622      typedef typename ValueType::AllocatorType AllocatorType;
1623      typedef typename ValueType::StringRefType StringRefType;
1624      typedef typename ValueType::EncodingType EncodingType;
1625      typedef typename ValueType::Ch Ch;
1626      template <typename, typename>
1627      friend class GenericValue;
1628      GenericObject(const GenericObject& rhs) : value_(rhs.value_) {}
1629      GenericObject& operator=(const GenericObject& rhs) { value_ = rhs.value_; return *this; }
1630      ~GenericObject() {}
1631      operator ValueType&() const { return value_; }
1632      SizeType MemberCount() const { return value_.MemberCount(); }
1633      SizeType MemberCapacity() const { return value_.MemberCapacity(); }
1634      bool ObjectEmpty() const { return value_.ObjectEmpty(); }
1635      template <typename T> ValueType& operator[](T* name) const { return value_[name]; }
1636      template <typename SourceAllocator> ValueType& operator[](const GenericValue<EncodingType, SourceAllocator>& name) const { return value_[name]; }
1637  #if RAPIDJSON_HAS_STDSTRING
1638      ValueType& operator[](const std::basic_string<Ch>& name) const { return value_[name]; }
1639  #endif
1640      MemberIterator MemberBegin() const { return value_.MemberBegin(); }
1641      MemberIterator MemberEnd() const { return value_.MemberEnd(); }
1642      GenericObject MemberReserve(SizeType newCapacity, AllocatorType &allocator) const { value_.MemberReserve(newCapacity, allocator); return *this; }
1643      bool HasMember(const Ch* name) const { return value_.HasMember(name); }
1644  #if RAPIDJSON_HAS_STDSTRING
1645      bool HasMember(const std::basic_string<Ch>& name) const { return value_.HasMember(name); }
1646  #endif
1647      template <typename SourceAllocator> bool HasMember(const GenericValue<EncodingType, SourceAllocator>& name) const { return value_.HasMember(name); }
1648      MemberIterator FindMember(const Ch* name) const { return value_.FindMember(name); }
1649      template <typename SourceAllocator> MemberIterator FindMember(const GenericValue<EncodingType, SourceAllocator>& name) const { return value_.FindMember(name); }
1650  #if RAPIDJSON_HAS_STDSTRING
1651      MemberIterator FindMember(const std::basic_string<Ch>& name) const { return value_.FindMember(name); }
1652  #endif
1653      GenericObject AddMember(ValueType& name, ValueType& value, AllocatorType& allocator) const { value_.AddMember(name, value, allocator); return *this; }
1654      GenericObject AddMember(ValueType& name, StringRefType value, AllocatorType& allocator) const { value_.AddMember(name, value, allocator); return *this; }
1655  #if RAPIDJSON_HAS_STDSTRING
1656      GenericObject AddMember(ValueType& name, std::basic_string<Ch>& value, AllocatorType& allocator) const { value_.AddMember(name, value, allocator); return *this; }
1657  #endif
1658      template <typename T> RAPIDJSON_DISABLEIF_RETURN((internal::OrExpr<internal::IsPointer<T>, internal::IsGenericValue<T> >), (ValueType&)) AddMember(ValueType& name, T value, AllocatorType& allocator) const { value_.AddMember(name, value, allocator); return *this; }
1659  #if RAPIDJSON_HAS_CXX11_RVALUE_REFS
1660      GenericObject AddMember(ValueType&& name, ValueType&& value, AllocatorType& allocator) const { value_.AddMember(name, value, allocator); return *this; }
1661      GenericObject AddMember(ValueType&& name, ValueType& value, AllocatorType& allocator) const { value_.AddMember(name, value, allocator); return *this; }
1662      GenericObject AddMember(ValueType& name, ValueType&& value, AllocatorType& allocator) const { value_.AddMember(name, value, allocator); return *this; }
1663      GenericObject AddMember(StringRefType name, ValueType&& value, AllocatorType& allocator) const { value_.AddMember(name, value, allocator); return *this; }
1664  #endif 
1665      GenericObject AddMember(StringRefType name, ValueType& value, AllocatorType& allocator) const { value_.AddMember(name, value, allocator); return *this; }
1666      GenericObject AddMember(StringRefType name, StringRefType value, AllocatorType& allocator) const { value_.AddMember(name, value, allocator); return *this; }
1667      template <typename T> RAPIDJSON_DISABLEIF_RETURN((internal::OrExpr<internal::IsPointer<T>, internal::IsGenericValue<T> >), (GenericObject)) AddMember(StringRefType name, T value, AllocatorType& allocator) const { value_.AddMember(name, value, allocator); return *this; }
1668      void RemoveAllMembers() { value_.RemoveAllMembers(); }
1669      bool RemoveMember(const Ch* name) const { return value_.RemoveMember(name); }
1670  #if RAPIDJSON_HAS_STDSTRING
1671      bool RemoveMember(const std::basic_string<Ch>& name) const { return value_.RemoveMember(name); }
1672  #endif
1673      template <typename SourceAllocator> bool RemoveMember(const GenericValue<EncodingType, SourceAllocator>& name) const { return value_.RemoveMember(name); }
1674      MemberIterator RemoveMember(MemberIterator m) const { return value_.RemoveMember(m); }
1675      MemberIterator EraseMember(ConstMemberIterator pos) const { return value_.EraseMember(pos); }
1676      MemberIterator EraseMember(ConstMemberIterator first, ConstMemberIterator last) const { return value_.EraseMember(first, last); }
1677      bool EraseMember(const Ch* name) const { return value_.EraseMember(name); }
1678  #if RAPIDJSON_HAS_STDSTRING
1679      bool EraseMember(const std::basic_string<Ch>& name) const { return EraseMember(ValueType(StringRef(name))); }
1680  #endif
1681      template <typename SourceAllocator> bool EraseMember(const GenericValue<EncodingType, SourceAllocator>& name) const { return value_.EraseMember(name); }
1682  #if RAPIDJSON_HAS_CXX11_RANGE_FOR
1683      MemberIterator begin() const { return value_.MemberBegin(); }
1684      MemberIterator end() const { return value_.MemberEnd(); }
1685  #endif
1686  private:
1687      GenericObject();
1688      GenericObject(ValueType& value) : value_(value) {}
1689      ValueType& value_;
1690  };
1691  RAPIDJSON_NAMESPACE_END
1692  RAPIDJSON_DIAG_POP
1693  #ifdef RAPIDJSON_WINDOWS_GETOBJECT_WORKAROUND_APPLIED
1694  #pragma pop_macro("GetObject")
1695  #undef RAPIDJSON_WINDOWS_GETOBJECT_WORKAROUND_APPLIED
1696  #endif
1697  #endif 
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from redis-MDEwOlJlcG9zaXRvcnkxMDgxMTA3MDY=-flat-math.h</div>
                <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from xmrig-MDEwOlJlcG9zaXRvcnk4ODMyNzQwNg==-flat-document.h</div>
                <div class="column column_space"><pre><code>200  		p2 = p - i_gamma(p1, xx, ln_gamma_df_2);
201  		t = p2 * exp(xx * aa + ln_gamma_df_2 + p1 - c * log(ch));
202  		b = t / ch;
203  		a = 0.5 * t - b * c;
204  		s1 = (210.0 + a * (140.0 + a * (105.0 + a * (84.0 + a * (70.0 +
205  		    60.0 * a))))) / 420.0;
206  		s2 = (420.0 + a * (735.0 + a * (966.0 + a * (1141.0 + 1278.0 *
207  		    a)))) / 2520.0;
208  		s3 = (210.0 + a * (462.0 + a * (707.0 + 932.0 * a))) / 2520.0;
209  		s4 = (252.0 + a * (672.0 + 1182.0 * a) + c * (294.0 + a *
210  		    (889.0 + 1740.0 * a))) / 5040.0;
211  		s5 = (84.0 + 264.0 * a + c * (175.0 + 606.0 * a)) / 2520.0;
212  		s6 = (120.0 + c * (346.0 + 127.0 * c)) / 5040.0;
213  		ch += t * (1.0 + 0.5 * t * s1 - b * c * (s1 - b * (s2 - b * (s3
</pre></code></div>
                <div class="column column_space"><pre><code>937          kBoolFlag       = 0x0008,
938          kNumberFlag     = 0x0010,
939          kIntFlag        = 0x0020,
940          kUintFlag       = 0x0040,
941          kInt64Flag      = 0x0080,
942          kUint64Flag     = 0x0100,
943          kDoubleFlag     = 0x0200,
944          kStringFlag     = 0x0400,
945          kCopyFlag       = 0x0800,
946          kInlineStrFlag  = 0x1000,
947          kNullFlag = kNullType,
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    