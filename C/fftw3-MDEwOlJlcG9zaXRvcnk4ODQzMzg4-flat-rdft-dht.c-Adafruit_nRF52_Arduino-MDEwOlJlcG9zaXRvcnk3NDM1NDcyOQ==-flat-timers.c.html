
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 15, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>fftw3-MDEwOlJlcG9zaXRvcnk4ODQzMzg4-flat-rdft-dht.c</h3>
            <pre><code>1  #include "rdft/rdft.h"
2  typedef struct {
3       solver super;
4  } S;
5  typedef struct {
<span onclick='openModal()' class='match'>6       plan_rdft super;
7       plan *cld;
8       INT is, os;
9       INT n;
10  } P;
</span>11  static void apply_r2hc(const plan *ego_, R *I, R *O)
12  {
13       const P *ego = (const P *) ego_;
14       INT os;
15       INT i, n;
16       {
17  	  plan_rdft *cld = (plan_rdft *) ego->cld;
18  	  cld->apply((plan *) cld, I, O);
19       }
20       n = ego->n;
21       os = ego->os;
22       for (i = 1; i < n - i; ++i) {
23  	  E a, b;
24  	  a = K(0.5) * O[os * i];
25  	  b = K(0.5) * O[os * (n - i)];
26  	  O[os * i] = a + b;
27  #if FFT_SIGN == -1
28  	  O[os * (n - i)] = b - a;
29  #else
30  	  O[os * (n - i)] = a - b;
31  #endif
32       }
33  }
34  static void apply_hc2r(const plan *ego_, R *I, R *O)
35  {
36       const P *ego = (const P *) ego_;
37       INT is = ego->is;
38       INT i, n = ego->n;
39       for (i = 1; i < n - i; ++i) {
40  	  E a, b;
41  	  a = I[is * i];
42  	  b = I[is * (n - i)];
43  #if FFT_SIGN == -1
44  	  I[is * i] = a - b;
45  	  I[is * (n - i)] = a + b;
46  #else
47  	  I[is * i] = a + b;
48  	  I[is * (n - i)] = a - b;
49  #endif
50       }
51       {
52  	  plan_rdft *cld = (plan_rdft *) ego->cld;
53  	  cld->apply((plan *) cld, I, O);
54       }
55  }
56  static void apply_hc2r_save(const plan *ego_, R *I, R *O)
57  {
58       const P *ego = (const P *) ego_;
59       INT is = ego->is, os = ego->os;
60       INT i, n = ego->n;
61       O[0] = I[0];
62       for (i = 1; i < n - i; ++i) {
63  	  E a, b;
64  	  a = I[is * i];
65  	  b = I[is * (n - i)];
66  #if FFT_SIGN == -1
67  	  O[os * i] = a - b;
68  	  O[os * (n - i)] = a + b;
69  #else
70  	  O[os * i] = a + b;
71  	  O[os * (n - i)] = a - b;
72  #endif
73       }
74       if (i == n - i)
75  	  O[os * i] = I[is * i];
76       {
77  	  plan_rdft *cld = (plan_rdft *) ego->cld;
78  	  cld->apply((plan *) cld, O, O);
79       }
80  }
81  static void awake(plan *ego_, enum wakefulness wakefulness)
82  {
83       P *ego = (P *) ego_;
84       X(plan_awake)(ego->cld, wakefulness);
85  }
86  static void destroy(plan *ego_)
87  {
88       P *ego = (P *) ego_;
89       X(plan_destroy_internal)(ego->cld);
90  }
91  static void print(const plan *ego_, printer *p)
92  {
93       const P *ego = (const P *) ego_;
94       p->print(p, "(%s-dht-%D%(%p%))", 
95  	      ego->super.apply == apply_r2hc ? "r2hc" : "hc2r",
96  	      ego->n, ego->cld);
97  }
98  static int applicable0(const solver *ego_, const problem *p_)
99  {
100       const problem_rdft *p = (const problem_rdft *) p_;
101       UNUSED(ego_);
102       return (1
103  	     && p->sz->rnk == 1
104  	     && p->vecsz->rnk == 0
105  	     && (p->kind[0] == R2HC || p->kind[0] == HC2R)
106  	     && p->sz->dims[0].n > 2
107  	  );
108  }
109  static int applicable(const solver *ego, const problem *p_, 
110  		      const planner *plnr)
111  {
112       return (!NO_SLOWP(plnr) && applicable0(ego, p_));
113  }
114  static plan *mkplan(const solver *ego_, const problem *p_, planner *plnr)
115  {
116       P *pln;
117       const problem_rdft *p;
118       problem *cldp;
119       plan *cld;
120       static const plan_adt padt = {
121  	  X(rdft_solve), awake, print, destroy
122       };
123       if (!applicable(ego_, p_, plnr))
124            return (plan *)0;
125       p = (const problem_rdft *) p_;
126       if (p->kind[0] == R2HC || !NO_DESTROY_INPUTP(plnr))
127  	  cldp = X(mkproblem_rdft_1)(p->sz, p->vecsz, p->I, p->O, DHT);
128       else {
129  	  tensor *sz = X(tensor_copy_inplace)(p->sz, INPLACE_OS);
130  	  cldp = X(mkproblem_rdft_1)(sz, p->vecsz, p->O, p->O, DHT);
131  	  X(tensor_destroy)(sz);
132       }
133       cld = X(mkplan_d)(plnr, cldp);
134       if (!cld) return (plan *)0;
135       pln = MKPLAN_RDFT(P, &padt, p->kind[0] == R2HC ? 
136  		       apply_r2hc : (NO_DESTROY_INPUTP(plnr) ?
137  				     apply_hc2r_save : apply_hc2r));
138       pln->n = p->sz->dims[0].n;
139       pln->is = p->sz->dims[0].is;
140       pln->os = p->sz->dims[0].os;
141       pln->cld = cld;
142       pln->super.super.ops = cld->ops;
143       pln->super.super.ops.other += 4 * ((pln->n - 1)/2);
144       pln->super.super.ops.add += 2 * ((pln->n - 1)/2);
145       if (p->kind[0] == R2HC)
146  	  pln->super.super.ops.mul += 2 * ((pln->n - 1)/2);
147       if (pln->super.apply == apply_hc2r_save)
148  	  pln->super.super.ops.other += 2 + (pln->n % 2 ? 0 : 2);
149       return &(pln->super.super);
150  }
151  static solver *mksolver(void)
152  {
153       static const solver_adt sadt = { PROBLEM_RDFT, mkplan, 0 };
154       S *slv = MKSOLVER(S, &sadt);
155       return &(slv->super);
156  }
157  void X(rdft_dht_register)(planner *p)
158  {
159       REGISTER_SOLVER(p, mksolver());
160  }
</code></pre>
        </div>
        <div class="column">
            <h3>Adafruit_nRF52_Arduino-MDEwOlJlcG9zaXRvcnk3NDM1NDcyOQ==-flat-timers.c</h3>
            <pre><code>1  #include <stdlib.h>
2  #define MPU_WRAPPERS_INCLUDED_FROM_API_FILE
3  #include "FreeRTOS.h"
4  #include "task.h"
5  #include "queue.h"
6  #include "timers.h"
7  #if ( INCLUDE_xTimerPendFunctionCall == 1 ) && ( configUSE_TIMERS == 0 )
8  	#error configUSE_TIMERS must be set to 1 to make the xTimerPendFunctionCall() function available.
9  #endif
10  #undef MPU_WRAPPERS_INCLUDED_FROM_API_FILE &bsol;*lint !e961 !e750. */
11  #if ( configUSE_TIMERS == 1 )
12  #define tmrNO_DELAY		( TickType_t ) 0U
13  #ifndef configTIMER_SERVICE_TASK_NAME
14  	#define configTIMER_SERVICE_TASK_NAME "Tmr Svc"
15  #endif
16  typedef struct tmrTimerControl
17  {
18  	const char				*pcTimerName;		&bsol;*<< Text name.  This is not used by the kernel, it is included simply to make debugging easier. */ &bsol;*lint !e971 Unqualified char types are allowed for strings and single characters only. */
19  	ListItem_t				xTimerListItem;		&bsol;*<< Standard linked list item as used by all kernel features for event management. */
20  	TickType_t				xTimerPeriodInTicks;&bsol;*<< How quickly and often the timer expires. */
21  	UBaseType_t				uxAutoReload;		&bsol;*<< Set to pdTRUE if the timer should be automatically restarted once expired.  Set to pdFALSE if the timer is, in effect, a one-shot timer. */
22  	void 					*pvTimerID;			&bsol;*<< An ID to identify the timer.  This allows the timer to be identified when the same callback is used for multiple timers. */
23  	TimerCallbackFunction_t	pxCallbackFunction;	&bsol;*<< The function that will be called when the timer expires. */
24  	#if( configUSE_TRACE_FACILITY == 1 )
25  		UBaseType_t			uxTimerNumber;		&bsol;*<< An ID assigned by trace tools such as FreeRTOS+Trace */
26  	#endif
27  	#if( ( configSUPPORT_STATIC_ALLOCATION == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) )
28  		uint8_t 			ucStaticallyAllocated; &bsol;*<< Set to pdTRUE if the timer was created statically so no attempt is made to free the memory again if the timer is later deleted. */
29  	#endif
30  } xTIMER;
31  typedef xTIMER Timer_t;
32  typedef struct tmrTimerParameters
33  {
34  	TickType_t			xMessageValue;		&bsol;*<< An optional value used by a subset of commands, for example, when changing the period of a timer. */
35  	Timer_t *			pxTimer;			&bsol;*<< The timer to which the command will be applied. */
36  } TimerParameter_t;
37  typedef struct tmrCallbackParameters
38  {
39  	PendedFunction_t	pxCallbackFunction;	&bsol;* << The callback function to execute. */
40  	void *pvParameter1;						&bsol;* << The value that will be used as the callback functions first parameter. */
41  	uint32_t ulParameter2;					&bsol;* << The value that will be used as the callback functions second parameter. */
42  } CallbackParameters_t;
43  typedef struct tmrTimerQueueMessage
44  {
45  	BaseType_t			xMessageID;			&bsol;*<< The command being sent to the timer service task. */
46  	union
47  	{
48  		TimerParameter_t xTimerParameters;
49  		#if ( INCLUDE_xTimerPendFunctionCall == 1 )
50  			CallbackParameters_t xCallbackParameters;
51  		#endif &bsol;* INCLUDE_xTimerPendFunctionCall */
52  	} u;
53  } DaemonTaskMessage_t;
54  PRIVILEGED_DATA static List_t xActiveTimerList1;
55  PRIVILEGED_DATA static List_t xActiveTimerList2;
56  PRIVILEGED_DATA static List_t *pxCurrentTimerList;
57  PRIVILEGED_DATA static List_t *pxOverflowTimerList;
58  PRIVILEGED_DATA static QueueHandle_t xTimerQueue = NULL;
59  PRIVILEGED_DATA static TaskHandle_t xTimerTaskHandle = NULL;
60  #if( configSUPPORT_STATIC_ALLOCATION == 1 )
61  	extern void vApplicationGetTimerTaskMemory( StaticTask_t **ppxTimerTaskTCBBuffer, StackType_t **ppxTimerTaskStackBuffer, uint32_t *pulTimerTaskStackSize );
62  #endif
63  static void prvCheckForValidListAndQueue( void ) PRIVILEGED_FUNCTION;
64  static void prvTimerTask( void *pvParameters ) PRIVILEGED_FUNCTION;
65  static void prvProcessReceivedCommands( void ) PRIVILEGED_FUNCTION;
66  static BaseType_t prvInsertTimerInActiveList( Timer_t * const pxTimer, const TickType_t xNextExpiryTime, const TickType_t xTimeNow, const TickType_t xCommandTime ) PRIVILEGED_FUNCTION;
67  static void prvProcessExpiredTimer( const TickType_t xNextExpireTime, const TickType_t xTimeNow ) PRIVILEGED_FUNCTION;
68  static void prvSwitchTimerLists( void ) PRIVILEGED_FUNCTION;
69  static TickType_t prvSampleTimeNow( BaseType_t * const pxTimerListsWereSwitched ) PRIVILEGED_FUNCTION;
70  static TickType_t prvGetNextExpireTime( BaseType_t * const pxListWasEmpty ) PRIVILEGED_FUNCTION;
71  static void prvProcessTimerOrBlockTask( const TickType_t xNextExpireTime, BaseType_t xListWasEmpty ) PRIVILEGED_FUNCTION;
72  static void prvInitialiseNewTimer(	const char * const pcTimerName,			&bsol;*lint !e971 Unqualified char types are allowed for strings and single characters only. */
73  									const TickType_t xTimerPeriodInTicks,
74  									const UBaseType_t uxAutoReload,
75  									void * const pvTimerID,
76  									TimerCallbackFunction_t pxCallbackFunction,
77  									Timer_t *pxNewTimer ) PRIVILEGED_FUNCTION;
78  BaseType_t xTimerCreateTimerTask( void )
79  {
80  BaseType_t xReturn = pdFAIL;
81  	prvCheckForValidListAndQueue();
82  	if( xTimerQueue != NULL )
83  	{
84  		#if( configSUPPORT_STATIC_ALLOCATION == 1 )
85  		{
86  			StaticTask_t *pxTimerTaskTCBBuffer = NULL;
87  			StackType_t *pxTimerTaskStackBuffer = NULL;
88  			uint32_t ulTimerTaskStackSize;
89  			vApplicationGetTimerTaskMemory( &pxTimerTaskTCBBuffer, &pxTimerTaskStackBuffer, &ulTimerTaskStackSize );
90  			xTimerTaskHandle = xTaskCreateStatic(	prvTimerTask,
91  													configTIMER_SERVICE_TASK_NAME,
92  													ulTimerTaskStackSize,
93  													NULL,
94  													( ( UBaseType_t ) configTIMER_TASK_PRIORITY ) | portPRIVILEGE_BIT,
95  													pxTimerTaskStackBuffer,
96  													pxTimerTaskTCBBuffer );
97  			if( xTimerTaskHandle != NULL )
98  			{
99  				xReturn = pdPASS;
100  			}
101  		}
102  		#else
103  		{
104  			xReturn = xTaskCreate(	prvTimerTask,
105  									configTIMER_SERVICE_TASK_NAME,
106  									configTIMER_TASK_STACK_DEPTH,
107  									NULL,
108  									( ( UBaseType_t ) configTIMER_TASK_PRIORITY ) | portPRIVILEGE_BIT,
109  									&xTimerTaskHandle );
110  		}
111  		#endif &bsol;* configSUPPORT_STATIC_ALLOCATION */
112  	}
113  	else
114  	{
115  		mtCOVERAGE_TEST_MARKER();
116  	}
117  	configASSERT( xReturn );
118  	return xReturn;
119  }
120  #if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )
121  	TimerHandle_t xTimerCreate(	const char * const pcTimerName,			&bsol;*lint !e971 Unqualified char types are allowed for strings and single characters only. */
122  								const TickType_t xTimerPeriodInTicks,
123  								const UBaseType_t uxAutoReload,
124  								void * const pvTimerID,
125  								TimerCallbackFunction_t pxCallbackFunction )
126  	{
127  	Timer_t *pxNewTimer;
128  		pxNewTimer = ( Timer_t * ) pvPortMalloc( sizeof( Timer_t ) );
129  		if( pxNewTimer != NULL )
130  		{
131  			prvInitialiseNewTimer( pcTimerName, xTimerPeriodInTicks, uxAutoReload, pvTimerID, pxCallbackFunction, pxNewTimer );
132  			#if( configSUPPORT_STATIC_ALLOCATION == 1 )
133  			{
134  				pxNewTimer->ucStaticallyAllocated = pdFALSE;
135  			}
136  			#endif &bsol;* configSUPPORT_STATIC_ALLOCATION */
137  		}
138  		return pxNewTimer;
139  	}
140  #endif &bsol;* configSUPPORT_STATIC_ALLOCATION */
141  #if( configSUPPORT_STATIC_ALLOCATION == 1 )
142  	TimerHandle_t xTimerCreateStatic(	const char * const pcTimerName,		&bsol;*lint !e971 Unqualified char types are allowed for strings and single characters only. */
143  										const TickType_t xTimerPeriodInTicks,
144  										const UBaseType_t uxAutoReload,
145  										void * const pvTimerID,
146  										TimerCallbackFunction_t pxCallbackFunction,
147  										StaticTimer_t *pxTimerBuffer )
148  	{
149  	Timer_t *pxNewTimer;
150  		#if( configASSERT_DEFINED == 1 )
151  		{
152  			volatile size_t xSize = sizeof( StaticTimer_t );
153  			configASSERT( xSize == sizeof( Timer_t ) );
154  		}
155  		#endif &bsol;* configASSERT_DEFINED */
156  		configASSERT( pxTimerBuffer );
157  		pxNewTimer = ( Timer_t * ) pxTimerBuffer; &bsol;*lint !e740 Unusual cast is ok as the structures are designed to have the same alignment, and the size is checked by an assert. */
158  		if( pxNewTimer != NULL )
159  		{
160  			prvInitialiseNewTimer( pcTimerName, xTimerPeriodInTicks, uxAutoReload, pvTimerID, pxCallbackFunction, pxNewTimer );
161  			#if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )
162  			{
163  				pxNewTimer->ucStaticallyAllocated = pdTRUE;
164  			}
165  			#endif &bsol;* configSUPPORT_DYNAMIC_ALLOCATION */
166  		}
167  		return pxNewTimer;
168  	}
169  #endif &bsol;* configSUPPORT_STATIC_ALLOCATION */
170  static void prvInitialiseNewTimer(	const char * const pcTimerName,			&bsol;*lint !e971 Unqualified char types are allowed for strings and single characters only. */
171  									const TickType_t xTimerPeriodInTicks,
172  									const UBaseType_t uxAutoReload,
173  									void * const pvTimerID,
174  									TimerCallbackFunction_t pxCallbackFunction,
175  									Timer_t *pxNewTimer )
176  {
177  	configASSERT( ( xTimerPeriodInTicks > 0 ) );
178  	if( pxNewTimer != NULL )
179  	{
180  		prvCheckForValidListAndQueue();
181  		pxNewTimer->pcTimerName = pcTimerName;
182  		pxNewTimer->xTimerPeriodInTicks = xTimerPeriodInTicks;
183  		pxNewTimer->uxAutoReload = uxAutoReload;
184  		pxNewTimer->pvTimerID = pvTimerID;
185  		pxNewTimer->pxCallbackFunction = pxCallbackFunction;
186  		vListInitialiseItem( &( pxNewTimer->xTimerListItem ) );
187  		traceTIMER_CREATE( pxNewTimer );
188  	}
189  }
190  BaseType_t xTimerGenericCommand( TimerHandle_t xTimer, const BaseType_t xCommandID, const TickType_t xOptionalValue, BaseType_t * const pxHigherPriorityTaskWoken, const TickType_t xTicksToWait )
191  {
192  BaseType_t xReturn = pdFAIL;
193  DaemonTaskMessage_t xMessage;
194  	configASSERT( xTimer );
195  	if( xTimerQueue != NULL )
196  	{
197  		xMessage.xMessageID = xCommandID;
198  		xMessage.u.xTimerParameters.xMessageValue = xOptionalValue;
199  		xMessage.u.xTimerParameters.pxTimer = ( Timer_t * ) xTimer;
200  		if( xCommandID < tmrFIRST_FROM_ISR_COMMAND )
201  		{
202  			if( xTaskGetSchedulerState() == taskSCHEDULER_RUNNING )
203  			{
204  				xReturn = xQueueSendToBack( xTimerQueue, &xMessage, xTicksToWait );
205  			}
206  			else
207  			{
208  				xReturn = xQueueSendToBack( xTimerQueue, &xMessage, tmrNO_DELAY );
209  			}
210  		}
211  		else
212  		{
213  			xReturn = xQueueSendToBackFromISR( xTimerQueue, &xMessage, pxHigherPriorityTaskWoken );
214  		}
215  		traceTIMER_COMMAND_SEND( xTimer, xCommandID, xOptionalValue, xReturn );
216  	}
217  	else
218  	{
219  		mtCOVERAGE_TEST_MARKER();
220  	}
221  	return xReturn;
222  }
223  TaskHandle_t xTimerGetTimerDaemonTaskHandle( void )
224  {
225  	configASSERT( ( xTimerTaskHandle != NULL ) );
226  	return xTimerTaskHandle;
227  }
228  TickType_t xTimerGetPeriod( TimerHandle_t xTimer )
229  {
230  Timer_t *pxTimer = ( Timer_t * ) xTimer;
231  	configASSERT( xTimer );
232  	return pxTimer->xTimerPeriodInTicks;
233  }
234  TickType_t xTimerGetExpiryTime( TimerHandle_t xTimer )
235  {
236  Timer_t * pxTimer = ( Timer_t * ) xTimer;
237  TickType_t xReturn;
238  	configASSERT( xTimer );
239  	xReturn = listGET_LIST_ITEM_VALUE( &( pxTimer->xTimerListItem ) );
240  	return xReturn;
241  }
242  const char * pcTimerGetName( TimerHandle_t xTimer ) &bsol;*lint !e971 Unqualified char types are allowed for strings and single characters only. */
243  {
244  Timer_t *pxTimer = ( Timer_t * ) xTimer;
245  	configASSERT( xTimer );
246  	return pxTimer->pcTimerName;
247  }
248  static void prvProcessExpiredTimer( const TickType_t xNextExpireTime, const TickType_t xTimeNow )
249  {
250  BaseType_t xResult;
251  Timer_t * const pxTimer = ( Timer_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxCurrentTimerList );
252  	( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
253  	traceTIMER_EXPIRED( pxTimer );
254  	if( pxTimer->uxAutoReload == ( UBaseType_t ) pdTRUE )
255  	{
256  		if( prvInsertTimerInActiveList( pxTimer, ( xNextExpireTime + pxTimer->xTimerPeriodInTicks ), xTimeNow, xNextExpireTime ) != pdFALSE )
257  		{
258  			xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xNextExpireTime, NULL, tmrNO_DELAY );
259  			configASSERT( xResult );
260  			( void ) xResult;
261  		}
262  		else
263  		{
264  			mtCOVERAGE_TEST_MARKER();
265  		}
266  	}
267  	else
268  	{
269  		mtCOVERAGE_TEST_MARKER();
270  	}
271  	pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
272  }
273  static void prvTimerTask( void *pvParameters )
274  {
275  TickType_t xNextExpireTime;
276  BaseType_t xListWasEmpty;
277  	( void ) pvParameters;
278  	#if( configUSE_DAEMON_TASK_STARTUP_HOOK == 1 )
279  	{
280  		extern void vApplicationDaemonTaskStartupHook( void );
281  		vApplicationDaemonTaskStartupHook();
282  	}
283  	#endif &bsol;* configUSE_DAEMON_TASK_STARTUP_HOOK */
284  	for( ;; )
285  	{
286  		xNextExpireTime = prvGetNextExpireTime( &xListWasEmpty );
287  		prvProcessTimerOrBlockTask( xNextExpireTime, xListWasEmpty );
288  		prvProcessReceivedCommands();
289  	}
290  }
291  static void prvProcessTimerOrBlockTask( const TickType_t xNextExpireTime, BaseType_t xListWasEmpty )
292  {
293  TickType_t xTimeNow;
294  BaseType_t xTimerListsWereSwitched;
295  	vTaskSuspendAll();
296  	{
297  		xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
298  		if( xTimerListsWereSwitched == pdFALSE )
299  		{
300  			if( ( xListWasEmpty == pdFALSE ) && ( xNextExpireTime <= xTimeNow ) )
301  			{
302  				( void ) xTaskResumeAll();
303  				prvProcessExpiredTimer( xNextExpireTime, xTimeNow );
304  			}
305  			else
306  			{
307  				if( xListWasEmpty != pdFALSE )
308  				{
309  					xListWasEmpty = listLIST_IS_EMPTY( pxOverflowTimerList );
310  				}
311  				vQueueWaitForMessageRestricted( xTimerQueue, ( xNextExpireTime - xTimeNow ), xListWasEmpty );
312  				if( xTaskResumeAll() == pdFALSE )
313  				{
314  					portYIELD_WITHIN_API();
315  				}
316  				else
317  				{
318  					mtCOVERAGE_TEST_MARKER();
319  				}
320  			}
321  		}
322  		else
323  		{
324  			( void ) xTaskResumeAll();
325  		}
326  	}
327  }
328  static TickType_t prvGetNextExpireTime( BaseType_t * const pxListWasEmpty )
329  {
330  TickType_t xNextExpireTime;
331  	*pxListWasEmpty = listLIST_IS_EMPTY( pxCurrentTimerList );
332  	if( *pxListWasEmpty == pdFALSE )
333  	{
334  		xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
335  	}
336  	else
337  	{
338  		xNextExpireTime = ( TickType_t ) 0U;
339  	}
340  	return xNextExpireTime;
341  }
342  static TickType_t prvSampleTimeNow( BaseType_t * const pxTimerListsWereSwitched )
343  {
344  TickType_t xTimeNow;
345  PRIVILEGED_DATA static TickType_t xLastTime = ( TickType_t ) 0U; &bsol;*lint !e956 Variable is only accessible to one task. */
346  	xTimeNow = xTaskGetTickCount();
347  	if( xTimeNow < xLastTime )
348  	{
349  		prvSwitchTimerLists();
350  		*pxTimerListsWereSwitched = pdTRUE;
351  	}
352  	else
353  	{
354  		*pxTimerListsWereSwitched = pdFALSE;
355  	}
356  	xLastTime = xTimeNow;
357  	return xTimeNow;
358  }
359  static BaseType_t prvInsertTimerInActiveList( Timer_t * const pxTimer, const TickType_t xNextExpiryTime, const TickType_t xTimeNow, const TickType_t xCommandTime )
360  {
361  BaseType_t xProcessTimerNow = pdFALSE;
362  	listSET_LIST_ITEM_VALUE( &( pxTimer->xTimerListItem ), xNextExpiryTime );
363  	listSET_LIST_ITEM_OWNER( &( pxTimer->xTimerListItem ), pxTimer );
364  	if( xNextExpiryTime <= xTimeNow )
365  	{
366  		if( ( ( TickType_t ) ( xTimeNow - xCommandTime ) ) >= pxTimer->xTimerPeriodInTicks ) &bsol;*lint !e961 MISRA exception as the casts are only redundant for some ports. */
367  		{
368  			xProcessTimerNow = pdTRUE;
369  		}
370  		else
371  		{
372  			vListInsert( pxOverflowTimerList, &( pxTimer->xTimerListItem ) );
373  		}
374  	}
375  	else
376  	{
377  		if( ( xTimeNow < xCommandTime ) && ( xNextExpiryTime >= xCommandTime ) )
378  		{
379  			xProcessTimerNow = pdTRUE;
380  		}
381  		else
382  		{
383  			vListInsert( pxCurrentTimerList, &( pxTimer->xTimerListItem ) );
384  		}
385  	}
386  	return xProcessTimerNow;
387  }
388  static void	prvProcessReceivedCommands( void )
389  {
<span onclick='openModal()' class='match'>390  DaemonTaskMessage_t xMessage;
391  Timer_t *pxTimer;
392  BaseType_t xTimerListsWereSwitched, xResult;
393  TickType_t xTimeNow;
394  	while( xQueueReceive( xTimerQueue, &xMessage, tmrNO_DELAY ) != pdFAIL ) &bsol;*lint !e603 xMessage does not have to be initialised as it is passed out, not in, and it is not used unless xQueueReceive() returns pdTRUE. */
</span>395  	{
396  		#if ( INCLUDE_xTimerPendFunctionCall == 1 )
397  		{
398  			if( xMessage.xMessageID < ( BaseType_t ) 0 )
399  			{
400  				const CallbackParameters_t * const pxCallback = &( xMessage.u.xCallbackParameters );
401  				configASSERT( pxCallback );
402  				pxCallback->pxCallbackFunction( pxCallback->pvParameter1, pxCallback->ulParameter2 );
403  			}
404  			else
405  			{
406  				mtCOVERAGE_TEST_MARKER();
407  			}
408  		}
409  		#endif &bsol;* INCLUDE_xTimerPendFunctionCall */
410  		if( xMessage.xMessageID >= ( BaseType_t ) 0 )
411  		{
412  			pxTimer = xMessage.u.xTimerParameters.pxTimer;
413  			if( listIS_CONTAINED_WITHIN( NULL, &( pxTimer->xTimerListItem ) ) == pdFALSE ) &bsol;*lint !e961. The cast is only redundant when NULL is passed into the macro. */
414  			{
415  				( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
416  			}
417  			else
418  			{
419  				mtCOVERAGE_TEST_MARKER();
420  			}
421  			traceTIMER_COMMAND_RECEIVED( pxTimer, xMessage.xMessageID, xMessage.u.xTimerParameters.xMessageValue );
422  			xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
423  			switch( xMessage.xMessageID )
424  			{
425  				case tmrCOMMAND_START :
426  			    case tmrCOMMAND_START_FROM_ISR :
427  			    case tmrCOMMAND_RESET :
428  			    case tmrCOMMAND_RESET_FROM_ISR :
429  				case tmrCOMMAND_START_DONT_TRACE :
430  					if( prvInsertTimerInActiveList( pxTimer,  xMessage.u.xTimerParameters.xMessageValue + pxTimer->xTimerPeriodInTicks, xTimeNow, xMessage.u.xTimerParameters.xMessageValue ) != pdFALSE )
431  					{
432  						pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
433  						traceTIMER_EXPIRED( pxTimer );
434  						if( pxTimer->uxAutoReload == ( UBaseType_t ) pdTRUE )
435  						{
436  							xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xMessage.u.xTimerParameters.xMessageValue + pxTimer->xTimerPeriodInTicks, NULL, tmrNO_DELAY );
437  							configASSERT( xResult );
438  							( void ) xResult;
439  						}
440  						else
441  						{
442  							mtCOVERAGE_TEST_MARKER();
443  						}
444  					}
445  					else
446  					{
447  						mtCOVERAGE_TEST_MARKER();
448  					}
449  					break;
450  				case tmrCOMMAND_STOP :
451  				case tmrCOMMAND_STOP_FROM_ISR :
452  					break;
453  				case tmrCOMMAND_CHANGE_PERIOD :
454  				case tmrCOMMAND_CHANGE_PERIOD_FROM_ISR :
455  					pxTimer->xTimerPeriodInTicks = xMessage.u.xTimerParameters.xMessageValue;
456  					configASSERT( ( pxTimer->xTimerPeriodInTicks > 0 ) );
457  					( void ) prvInsertTimerInActiveList( pxTimer, ( xTimeNow + pxTimer->xTimerPeriodInTicks ), xTimeNow, xTimeNow );
458  					break;
459  				case tmrCOMMAND_DELETE :
460  					#if( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) )
461  					{
462  						vPortFree( pxTimer );
463  					}
464  					#elif( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 1 ) )
465  					{
466  						if( pxTimer->ucStaticallyAllocated == ( uint8_t ) pdFALSE )
467  						{
468  							vPortFree( pxTimer );
469  						}
470  						else
471  						{
472  							mtCOVERAGE_TEST_MARKER();
473  						}
474  					}
475  					#endif &bsol;* configSUPPORT_DYNAMIC_ALLOCATION */
476  					break;
477  				default	:
478  					break;
479  			}
480  		}
481  	}
482  }
483  static void prvSwitchTimerLists( void )
484  {
485  TickType_t xNextExpireTime, xReloadTime;
486  List_t *pxTemp;
487  Timer_t *pxTimer;
488  BaseType_t xResult;
489  	while( listLIST_IS_EMPTY( pxCurrentTimerList ) == pdFALSE )
490  	{
491  		xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
492  		pxTimer = ( Timer_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxCurrentTimerList );
493  		( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
494  		traceTIMER_EXPIRED( pxTimer );
495  		pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
496  		if( pxTimer->uxAutoReload == ( UBaseType_t ) pdTRUE )
497  		{
498  			xReloadTime = ( xNextExpireTime + pxTimer->xTimerPeriodInTicks );
499  			if( xReloadTime > xNextExpireTime )
500  			{
501  				listSET_LIST_ITEM_VALUE( &( pxTimer->xTimerListItem ), xReloadTime );
502  				listSET_LIST_ITEM_OWNER( &( pxTimer->xTimerListItem ), pxTimer );
503  				vListInsert( pxCurrentTimerList, &( pxTimer->xTimerListItem ) );
504  			}
505  			else
506  			{
507  				xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xNextExpireTime, NULL, tmrNO_DELAY );
508  				configASSERT( xResult );
509  				( void ) xResult;
510  			}
511  		}
512  		else
513  		{
514  			mtCOVERAGE_TEST_MARKER();
515  		}
516  	}
517  	pxTemp = pxCurrentTimerList;
518  	pxCurrentTimerList = pxOverflowTimerList;
519  	pxOverflowTimerList = pxTemp;
520  }
521  static void prvCheckForValidListAndQueue( void )
522  {
523  	taskENTER_CRITICAL();
524  	{
525  		if( xTimerQueue == NULL )
526  		{
527  			vListInitialise( &xActiveTimerList1 );
528  			vListInitialise( &xActiveTimerList2 );
529  			pxCurrentTimerList = &xActiveTimerList1;
530  			pxOverflowTimerList = &xActiveTimerList2;
531  			#if( configSUPPORT_STATIC_ALLOCATION == 1 )
532  			{
533  				static StaticQueue_t xStaticTimerQueue; &bsol;*lint !e956 Ok to declare in this manner to prevent additional conditional compilation guards in other locations. */
534  				static uint8_t ucStaticTimerQueueStorage[ ( size_t ) configTIMER_QUEUE_LENGTH * sizeof( DaemonTaskMessage_t ) ]; &bsol;*lint !e956 Ok to declare in this manner to prevent additional conditional compilation guards in other locations. */
535  				xTimerQueue = xQueueCreateStatic( ( UBaseType_t ) configTIMER_QUEUE_LENGTH, ( UBaseType_t ) sizeof( DaemonTaskMessage_t ), &( ucStaticTimerQueueStorage[ 0 ] ), &xStaticTimerQueue );
536  			}
537  			#else
538  			{
539  				xTimerQueue = xQueueCreate( ( UBaseType_t ) configTIMER_QUEUE_LENGTH, sizeof( DaemonTaskMessage_t ) );
540  			}
541  			#endif
542  			#if ( configQUEUE_REGISTRY_SIZE > 0 )
543  			{
544  				if( xTimerQueue != NULL )
545  				{
546  					vQueueAddToRegistry( xTimerQueue, "TmrQ" );
547  				}
548  				else
549  				{
550  					mtCOVERAGE_TEST_MARKER();
551  				}
552  			}
553  			#endif &bsol;* configQUEUE_REGISTRY_SIZE */
554  		}
555  		else
556  		{
557  			mtCOVERAGE_TEST_MARKER();
558  		}
559  	}
560  	taskEXIT_CRITICAL();
561  }
562  BaseType_t xTimerIsTimerActive( TimerHandle_t xTimer )
563  {
564  BaseType_t xTimerIsInActiveList;
565  Timer_t *pxTimer = ( Timer_t * ) xTimer;
566  	configASSERT( xTimer );
567  	taskENTER_CRITICAL();
568  	{
569  		xTimerIsInActiveList = ( BaseType_t ) !( listIS_CONTAINED_WITHIN( NULL, &( pxTimer->xTimerListItem ) ) ); &bsol;*lint !e961. Cast is only redundant when NULL is passed into the macro. */
570  	}
571  	taskEXIT_CRITICAL();
572  	return xTimerIsInActiveList;
573  } &bsol;*lint !e818 Can't be pointer to const due to the typedef. */
574  void *pvTimerGetTimerID( const TimerHandle_t xTimer )
575  {
576  Timer_t * const pxTimer = ( Timer_t * ) xTimer;
577  void *pvReturn;
578  	configASSERT( xTimer );
579  	taskENTER_CRITICAL();
580  	{
581  		pvReturn = pxTimer->pvTimerID;
582  	}
583  	taskEXIT_CRITICAL();
584  	return pvReturn;
585  }
586  void vTimerSetTimerID( TimerHandle_t xTimer, void *pvNewID )
587  {
588  Timer_t * const pxTimer = ( Timer_t * ) xTimer;
589  	configASSERT( xTimer );
590  	taskENTER_CRITICAL();
591  	{
592  		pxTimer->pvTimerID = pvNewID;
593  	}
594  	taskEXIT_CRITICAL();
595  }
596  #if( INCLUDE_xTimerPendFunctionCall == 1 )
597  	BaseType_t xTimerPendFunctionCallFromISR( PendedFunction_t xFunctionToPend, void *pvParameter1, uint32_t ulParameter2, BaseType_t *pxHigherPriorityTaskWoken )
598  	{
599  	DaemonTaskMessage_t xMessage;
600  	BaseType_t xReturn;
601  		xMessage.xMessageID = tmrCOMMAND_EXECUTE_CALLBACK_FROM_ISR;
602  		xMessage.u.xCallbackParameters.pxCallbackFunction = xFunctionToPend;
603  		xMessage.u.xCallbackParameters.pvParameter1 = pvParameter1;
604  		xMessage.u.xCallbackParameters.ulParameter2 = ulParameter2;
605  		xReturn = xQueueSendFromISR( xTimerQueue, &xMessage, pxHigherPriorityTaskWoken );
606  		tracePEND_FUNC_CALL_FROM_ISR( xFunctionToPend, pvParameter1, ulParameter2, xReturn );
607  		return xReturn;
608  	}
609  #endif &bsol;* INCLUDE_xTimerPendFunctionCall */
610  #if( INCLUDE_xTimerPendFunctionCall == 1 )
611  	BaseType_t xTimerPendFunctionCall( PendedFunction_t xFunctionToPend, void *pvParameter1, uint32_t ulParameter2, TickType_t xTicksToWait )
612  	{
613  	DaemonTaskMessage_t xMessage;
614  	BaseType_t xReturn;
615  		configASSERT( xTimerQueue );
616  		xMessage.xMessageID = tmrCOMMAND_EXECUTE_CALLBACK;
617  		xMessage.u.xCallbackParameters.pxCallbackFunction = xFunctionToPend;
618  		xMessage.u.xCallbackParameters.pvParameter1 = pvParameter1;
619  		xMessage.u.xCallbackParameters.ulParameter2 = ulParameter2;
620  		xReturn = xQueueSendToBack( xTimerQueue, &xMessage, xTicksToWait );
621  		tracePEND_FUNC_CALL( xFunctionToPend, pvParameter1, ulParameter2, xReturn );
622  		return xReturn;
623  	}
624  #endif &bsol;* INCLUDE_xTimerPendFunctionCall */
625  #if ( configUSE_TRACE_FACILITY == 1 )
626  	UBaseType_t uxTimerGetTimerNumber( TimerHandle_t xTimer )
627  	{
628  		return ( ( Timer_t * ) xTimer )->uxTimerNumber;
629  	}
630  #endif &bsol;* configUSE_TRACE_FACILITY */
631  #if ( configUSE_TRACE_FACILITY == 1 )
632  	void vTimerSetTimerNumber( TimerHandle_t xTimer, UBaseType_t uxTimerNumber )
633  	{
634  		( ( Timer_t * ) xTimer )->uxTimerNumber = uxTimerNumber;
635  	}
636  #endif &bsol;* configUSE_TRACE_FACILITY */
637  #endif &bsol;* configUSE_TIMERS == 1 */
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from fftw3-MDEwOlJlcG9zaXRvcnk4ODQzMzg4-flat-rdft-dht.c</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from Adafruit_nRF52_Arduino-MDEwOlJlcG9zaXRvcnk3NDM1NDcyOQ==-flat-timers.c</div>
                </div>
                <div class="column column_space"><pre><code>6       plan_rdft super;
7       plan *cld;
8       INT is, os;
9       INT n;
10  } P;
</pre></code></div>
                <div class="column column_space"><pre><code>390  DaemonTaskMessage_t xMessage;
391  Timer_t *pxTimer;
392  BaseType_t xTimerListsWereSwitched, xResult;
393  TickType_t xTimeNow;
394  	while( xQueueReceive( xTimerQueue, &xMessage, tmrNO_DELAY ) != pdFAIL ) &bsol;*lint !e603 xMessage does not have to be initialised as it is passed out, not in, and it is not used unless xQueueReceive() returns pdTRUE. */
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    