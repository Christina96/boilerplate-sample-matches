
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 20, <button onclick='openModal()' class='match'>CODE CLONE</button></h2>
        <div class="column">
            <h3>redis-MDEwOlJlcG9zaXRvcnkxMDgxMTA3MDY=-flat-replication.c</h3>
            <pre><code>1  #ifdef _WIN32
2  #include &quot;Win32_Interop/Win32_Portability.h&quot;
3  #include &quot;Win32_Interop/Win32_FDAPI.h&quot;
4  #include &quot;Win32_Interop/Win32_ThreadControl.h&quot;
5  #include &quot;Win32_Interop/Win32_QFork.h&quot;
6  #include &quot;Win32_Interop/win32_types.h&quot;
7  #include &quot;Win32_Interop/Win32_Time.h&quot;
8  #include &quot;Win32_Interop/Win32_Error.h&quot;
9  #endif
10  #include &quot;server.h&quot;
11  #include &quot;cluster.h&quot;
12  POSIX_ONLY(#include &lt;sys/time.h&gt;)
13  POSIX_ONLY(#include &lt;unistd.h&gt;)
14  #include &lt;fcntl.h&gt;
15  POSIX_ONLY(#include &lt;sys/socket.h&gt;)
16  #include &lt;sys/stat.h&gt;
17  void replicationDiscardCachedMaster(void);
18  void replicationResurrectCachedMaster(int newfd);
19  void replicationSendAck(void);
20  void putSlaveOnline(client *slave);
21  int cancelReplicationHandshake(void);
22  char *replicationGetSlaveName(client *c) {
23      static char buf[NET_PEER_ID_LEN];
24      char ip[NET_IP_STR_LEN];
25      ip[0] = &#x27;\0&#x27;;
26      buf[0] = &#x27;\0&#x27;;
27      if (c-&gt;slave_ip[0] != &#x27;\0&#x27; ||
28          anetPeerToString(c-&gt;fd,ip,sizeof(ip),NULL) != -1)
29      {
30          if (c-&gt;slave_ip[0] != &#x27;\0&#x27;) memcpy(ip,c-&gt;slave_ip,sizeof(c-&gt;slave_ip));
31          if (c-&gt;slave_listening_port)
32              anetFormatAddr(buf,sizeof(buf),ip,c-&gt;slave_listening_port);
33          else
34              snprintf(buf,sizeof(buf),&quot;%s:&lt;unknown-replica-port&gt;&quot;,ip);
35      } else {
36          snprintf(buf,sizeof(buf),&quot;client id #%llu&quot;,
37              (PORT_ULONGLONG) c-&gt;id);
38      }
39      return buf;
40  }
41  void createReplicationBacklog(void) {
42      serverAssert(server.repl_backlog == NULL);
43      server.repl_backlog = zmalloc(server.repl_backlog_size);
44      server.repl_backlog_histlen = 0;
45      server.repl_backlog_idx = 0;
46      server.repl_backlog_off = server.master_repl_offset+1;
47  }
48  void resizeReplicationBacklog(PORT_LONGLONG newsize) {
49      if (newsize &lt; CONFIG_REPL_BACKLOG_MIN_SIZE)
50          newsize = CONFIG_REPL_BACKLOG_MIN_SIZE;
51      if (server.repl_backlog_size == newsize) return;
52      server.repl_backlog_size = newsize;
53      if (server.repl_backlog != NULL) {
54          zfree(server.repl_backlog);
55          server.repl_backlog = zmalloc(server.repl_backlog_size);
56          server.repl_backlog_histlen = 0;
57          server.repl_backlog_idx = 0;
58          server.repl_backlog_off = server.master_repl_offset+1;
59      }
60  }
61  void freeReplicationBacklog(void) {
62      serverAssert(listLength(server.slaves) == 0);
63      zfree(server.repl_backlog);
64      server.repl_backlog = NULL;
65  }
66  void feedReplicationBacklog(void *ptr, size_t len) {
67      unsigned char *p = ptr;
68      server.master_repl_offset += len;
69      while(len) {
70          size_t thislen = server.repl_backlog_size - server.repl_backlog_idx;
71          if (thislen &gt; len) thislen = len;
72          memcpy(server.repl_backlog+server.repl_backlog_idx,p,thislen);
73          server.repl_backlog_idx += thislen;
74          if (server.repl_backlog_idx == server.repl_backlog_size)
75              server.repl_backlog_idx = 0;
76          len -= thislen;
77          p += thislen;
78          server.repl_backlog_histlen += thislen;
79      }
80      if (server.repl_backlog_histlen &gt; server.repl_backlog_size)
81          server.repl_backlog_histlen = server.repl_backlog_size;
82      server.repl_backlog_off = server.master_repl_offset -
83                                server.repl_backlog_histlen + 1;
84  }
85  void feedReplicationBacklogWithObject(robj *o) {
86      char llstr[LONG_STR_SIZE];
87      void *p;
88      size_t len;
89      if (o-&gt;encoding == OBJ_ENCODING_INT) {
90          len = ll2string(llstr,sizeof(llstr),(PORT_LONG)o-&gt;ptr);
91          p = llstr;
92      } else {
93          len = sdslen(o-&gt;ptr);
94          p = o-&gt;ptr;
95      }
96      feedReplicationBacklog(p,len);
97  }
98  void replicationFeedSlaves(list *slaves, int dictid, robj **argv, int argc) {
99      listNode *ln;
100      listIter li;
101      int j, len;
102      char llstr[LONG_STR_SIZE];
103      if (server.masterhost != NULL) return;
104      if (server.repl_backlog == NULL &amp;&amp; listLength(slaves) == 0) return;
105      serverAssert(!(listLength(slaves) != 0 &amp;&amp; server.repl_backlog == NULL));
106      if (server.slaveseldb != dictid) {
107          robj *selectcmd;
108          if (dictid &gt;= 0 &amp;&amp; dictid &lt; PROTO_SHARED_SELECT_CMDS) {
109              selectcmd = shared.select[dictid];
110          } else {
111              int dictid_len;
112              dictid_len = ll2string(llstr,sizeof(llstr),dictid);
113              selectcmd = createObject(OBJ_STRING,
114                  sdscatprintf(sdsempty(),
115                  &quot;*2\r\n$6\r\nSELECT\r\n$%d\r\n%s\r\n&quot;,
116                  dictid_len, llstr));
117          }
118          if (server.repl_backlog) feedReplicationBacklogWithObject(selectcmd);
119          listRewind(slaves,&amp;li);
120          while((ln = listNext(&amp;li))) {
121              client *slave = ln-&gt;value;
122              if (slave-&gt;replstate == SLAVE_STATE_WAIT_BGSAVE_START) continue;
123              addReply(slave,selectcmd);
124          }
125          if (dictid &lt; 0 || dictid &gt;= PROTO_SHARED_SELECT_CMDS)
126              decrRefCount(selectcmd);
127      }
128      server.slaveseldb = dictid;
129      if (server.repl_backlog) {
130          char aux[LONG_STR_SIZE+3];
131          aux[0] = &#x27;*&#x27;;
132          len = ll2string(aux+1,sizeof(aux)-1,argc);
133          aux[len+1] = &#x27;\r&#x27;;
134          aux[len+2] = &#x27;\n&#x27;;
135          feedReplicationBacklog(aux,(size_t)len+3);  WIN_PORT_FIX &amp;bsol;* cast (size_t) */
136          for (j = 0; j &lt; argc; j++) {
137              PORT_LONG objlen = (PORT_LONG) stringObjectLen(argv[j]);            WIN_PORT_FIX &amp;bsol;* cast (PORT_LONG) */
138              aux[0] = &#x27;$&#x27;;
139              len = ll2string(aux+1,sizeof(aux)-1,objlen);
140              aux[len+1] = &#x27;\r&#x27;;
141              aux[len+2] = &#x27;\n&#x27;;
142              feedReplicationBacklog(aux,(size_t)len+3);  WIN_PORT_FIX &amp;bsol;* cast (size_t) */
143              feedReplicationBacklogWithObject(argv[j]);
144              feedReplicationBacklog(aux+len+1,2);
145          }
146      }
147      listRewind(slaves,&amp;li);
148      while((ln = listNext(&amp;li))) {
149          client *slave = ln-&gt;value;
150          if (slave-&gt;replstate == SLAVE_STATE_WAIT_BGSAVE_START) continue;
151          addReplyMultiBulkLen(slave,argc);
152          for (j = 0; j &lt; argc; j++)
153              addReplyBulk(slave,argv[j]);
154      }
155  }
156  #include &lt;ctype.h&gt;
157  void replicationFeedSlavesFromMasterStream(list *slaves, char *buf, size_t buflen) {
158      listNode *ln;
159      listIter li;
160      if (0) {
161          printf(&quot;%Iu:&quot;,buflen);                                        WIN_PORT_FIX &amp;bsol;* %zu -&gt; %Iu */
162          for (size_t j = 0; j &lt; buflen; j++) {
163              printf(&quot;%c&quot;, isprint(buf[j]) ? buf[j] : &#x27;.&#x27;);
164          }
165          printf(&quot;\n&quot;);
166      }
167      if (server.repl_backlog) feedReplicationBacklog(buf,buflen);
168      listRewind(slaves,&amp;li);
169      while((ln = listNext(&amp;li))) {
170          client *slave = ln-&gt;value;
171          if (slave-&gt;replstate == SLAVE_STATE_WAIT_BGSAVE_START) continue;
172          addReplyString(slave,buf,buflen);
173      }
174  }
175  void replicationFeedMonitors(client *c, list *monitors, int dictid, robj **argv, int argc) {
176      listNode *ln;
177      listIter li;
178      int j;
179      sds cmdrepr = sdsnew(&quot;+&quot;);
180      robj *cmdobj;
181      struct timeval tv;
182      gettimeofday(&amp;tv,NULL);
183      cmdrepr = sdscatprintf(cmdrepr,&quot;%Id.%06Id &quot;,(PORT_LONG)tv.tv_sec,(PORT_LONG)tv.tv_usec);           WIN_PORT_FIX &amp;bsol;* %ld -&gt; %Id */
184      if (c-&gt;flags &amp; CLIENT_LUA) {
185          cmdrepr = sdscatprintf(cmdrepr,&quot;[%d lua] &quot;,dictid);
186      } else if (c-&gt;flags &amp; CLIENT_UNIX_SOCKET) {
187          cmdrepr = sdscatprintf(cmdrepr,&quot;[%d unix:%s] &quot;,dictid,server.unixsocket);
188      } else {
189          cmdrepr = sdscatprintf(cmdrepr,&quot;[%d %s] &quot;,dictid,getClientPeerId(c));
190      }
191      for (j = 0; j &lt; argc; j++) {
192          if (argv[j]-&gt;encoding == OBJ_ENCODING_INT) {
193              cmdrepr = sdscatprintf(cmdrepr, &quot;\&quot;%Id\&quot;&quot;, (PORT_LONG) argv[j]-&gt;ptr);   WIN_PORT_FIX &amp;bsol;* %ld -&gt; %Id */
194          } else {
195              cmdrepr = sdscatrepr(cmdrepr,(char*)argv[j]-&gt;ptr,
196                          sdslen(argv[j]-&gt;ptr));
197          }
198          if (j != argc-1)
199              cmdrepr = sdscatlen(cmdrepr,&quot; &quot;,1);
200      }
201      cmdrepr = sdscatlen(cmdrepr,&quot;\r\n&quot;,2);
202      cmdobj = createObject(OBJ_STRING,cmdrepr);
203      listRewind(monitors,&amp;li);
204      while((ln = listNext(&amp;li))) {
205          client *monitor = ln-&gt;value;
206          addReply(monitor,cmdobj);
207      }
208      decrRefCount(cmdobj);
209  }
210  PORT_LONGLONG addReplyReplicationBacklog(client *c, PORT_LONGLONG offset) {
211      PORT_LONGLONG j, skip, len;
212      serverLog(LL_DEBUG, &quot;[PSYNC] Replica request offset: %lld&quot;, offset);
213      if (server.repl_backlog_histlen == 0) {
214          serverLog(LL_DEBUG, &quot;[PSYNC] Backlog history len is zero&quot;);
215          return 0;
216      }
217      serverLog(LL_DEBUG, &quot;[PSYNC] Backlog size: %lld&quot;,
218               server.repl_backlog_size);
219      serverLog(LL_DEBUG, &quot;[PSYNC] First byte: %lld&quot;,
220               server.repl_backlog_off);
221      serverLog(LL_DEBUG, &quot;[PSYNC] History len: %lld&quot;,
222               server.repl_backlog_histlen);
223      serverLog(LL_DEBUG, &quot;[PSYNC] Current index: %lld&quot;,
224               server.repl_backlog_idx);
225      skip = offset - server.repl_backlog_off;
226      serverLog(LL_DEBUG, &quot;[PSYNC] Skipping: %lld&quot;, skip);
227      j = (server.repl_backlog_idx +
228          (server.repl_backlog_size-server.repl_backlog_histlen)) %
229          server.repl_backlog_size;
230      serverLog(LL_DEBUG, &quot;[PSYNC] Index of first byte: %lld&quot;, j);
231      j = (j + skip) % server.repl_backlog_size;
232      len = server.repl_backlog_histlen - skip;
233      serverLog(LL_DEBUG, &quot;[PSYNC] Reply total length: %lld&quot;, len);
234      while(len) {
235          PORT_LONGLONG thislen =
236              ((server.repl_backlog_size - j) &lt; len) ?
237              (server.repl_backlog_size - j) : len;
238          serverLog(LL_DEBUG, &quot;[PSYNC] addReply() length: %lld&quot;, thislen);
239          addReplySds(c,sdsnewlen(server.repl_backlog + j, thislen));
240          len -= thislen;
241          j = 0;
242      }
243      return server.repl_backlog_histlen - skip;
244  }
245  PORT_LONGLONG getPsyncInitialOffset(void) {
246      return server.master_repl_offset;
247  }
248  int replicationSetupSlaveForFullResync(client *slave, PORT_LONGLONG offset) {
249      char buf[128];
250      int buflen;
251      slave-&gt;psync_initial_offset = offset;
252      slave-&gt;replstate = SLAVE_STATE_WAIT_BGSAVE_END;
253      server.slaveseldb = -1;
254      if (!(slave-&gt;flags &amp; CLIENT_PRE_PSYNC)) {
255          buflen = snprintf(buf,sizeof(buf),&quot;+FULLRESYNC %s %lld\r\n&quot;,
256                            server.replid,offset);
257          if (write(slave-&gt;fd,buf,buflen) != buflen) {
258              freeClientAsync(slave);
259              return C_ERR;
260          }
261      }
262      return C_OK;
263  }
264  int masterTryPartialResynchronization(client *c) {
265      PORT_LONGLONG psync_offset, psync_len;
266      char *master_replid = c-&gt;argv[1]-&gt;ptr;
267      char buf[128];
268      int buflen;
269      if (getLongLongFromObjectOrReply(c,c-&gt;argv[2],&amp;psync_offset,NULL) !=
270         C_OK) goto need_full_resync;
271      if (strcasecmp(master_replid, server.replid) &amp;&amp;
272          (strcasecmp(master_replid, server.replid2) ||
273           psync_offset &gt; server.second_replid_offset))
274      {
275          if (master_replid[0] != &#x27;?&#x27;) {
276              if (strcasecmp(master_replid, server.replid) &amp;&amp;
277                  strcasecmp(master_replid, server.replid2))
278              {
279                  serverLog(LL_NOTICE,&quot;Partial resynchronization not accepted: &quot;
280                      &quot;Replication ID mismatch (Replica asked for &#x27;%s&#x27;, my &quot;
281                      &quot;replication IDs are &#x27;%s&#x27; and &#x27;%s&#x27;)&quot;,
282                      master_replid, server.replid, server.replid2);
283              } else {
284                  serverLog(LL_NOTICE,&quot;Partial resynchronization not accepted: &quot;
285                      &quot;Requested offset for second ID was %lld, but I can reply &quot;
286                      &quot;up to %lld&quot;, psync_offset, server.second_replid_offset);
287              }
288          } else {
289              serverLog(LL_NOTICE,&quot;Full resync requested by replica %s&quot;,
290                  replicationGetSlaveName(c));
291          }
292          goto need_full_resync;
293      }
294      if (!server.repl_backlog ||
295          psync_offset &lt; server.repl_backlog_off ||
296          psync_offset &gt; (server.repl_backlog_off + server.repl_backlog_histlen))
297      {
298          serverLog(LL_NOTICE,
299              &quot;Unable to partial resync with replica %s for lack of backlog (Replica request was: %lld).&quot;, replicationGetSlaveName(c), psync_offset);
300          if (psync_offset &gt; server.master_repl_offset) {
301              serverLog(LL_WARNING,
302                  &quot;Warning: replica %s tried to PSYNC with an offset that is greater than the master replication offset.&quot;, replicationGetSlaveName(c));
303          }
304          goto need_full_resync;
305      }
306      c-&gt;flags |= CLIENT_SLAVE;
307      c-&gt;replstate = SLAVE_STATE_ONLINE;
308      c-&gt;repl_ack_time = server.unixtime;
309      c-&gt;repl_put_online_on_ack = 0;
310      listAddNodeTail(server.slaves,c);
311      if (c-&gt;slave_capa &amp; SLAVE_CAPA_PSYNC2) {
312          buflen = snprintf(buf,sizeof(buf),&quot;+CONTINUE %s\r\n&quot;, server.replid);
313      } else {
314          buflen = snprintf(buf,sizeof(buf),&quot;+CONTINUE\r\n&quot;);
315      }
316      if (write(c-&gt;fd,buf,buflen) != buflen) {
317          freeClientAsync(c);
318          return C_OK;
319      }
320      psync_len = addReplyReplicationBacklog(c,psync_offset);
321      serverLog(LL_NOTICE,
322          &quot;Partial resynchronization request from %s accepted. Sending %lld bytes of backlog starting from offset %lld.&quot;,
323              replicationGetSlaveName(c),
324              psync_len, psync_offset);
325      refreshGoodSlavesCount();
326      return C_OK; &amp;bsol;* The caller can return, no full resync needed. */
327  need_full_resync:
328      return C_ERR;
329  }
330  int startBgsaveForReplication(int mincapa) {
331      int retval;
332      int socket_target = server.repl_diskless_sync &amp;&amp; (mincapa &amp; SLAVE_CAPA_EOF);
333      listIter li;
334      listNode *ln;
335      serverLog(LL_NOTICE,&quot;Starting BGSAVE for SYNC with target: %s&quot;,
336          socket_target ? &quot;replicas sockets&quot; : &quot;disk&quot;);
337      rdbSaveInfo rsi, *rsiptr;
338      rsiptr = rdbPopulateSaveInfo(&amp;rsi);
339      if (rsiptr) {
340          if (socket_target)
341              retval = rdbSaveToSlavesSockets(rsiptr);
342          else
343              retval = rdbSaveBackground(server.rdb_filename,rsiptr);
344      } else {
345          serverLog(LL_WARNING,&quot;BGSAVE for replication: replication information not available, can&#x27;t generate the RDB file right now. Try later.&quot;);
346          retval = C_ERR;
347      }
348      if (retval == C_ERR) {
349          serverLog(LL_WARNING,&quot;BGSAVE for replication failed&quot;);
350          listRewind(server.slaves,&amp;li);
351          while((ln = listNext(&amp;li))) {
352              client *slave = ln-&gt;value;
353              if (slave-&gt;replstate == SLAVE_STATE_WAIT_BGSAVE_START) {
354                  slave-&gt;replstate = REPL_STATE_NONE;
355                  slave-&gt;flags &amp;= ~CLIENT_SLAVE;
356                  listDelNode(server.slaves,ln);
357                  addReplyError(slave,
358                      &quot;BGSAVE failed, replication can&#x27;t continue&quot;);
359                  slave-&gt;flags |= CLIENT_CLOSE_AFTER_REPLY;
360              }
361          }
362          return retval;
363      }
364      if (!socket_target) {
365          listRewind(server.slaves,&amp;li);
366          while((ln = listNext(&amp;li))) {
367              client *slave = ln-&gt;value;
368              if (slave-&gt;replstate == SLAVE_STATE_WAIT_BGSAVE_START) {
369                      replicationSetupSlaveForFullResync(slave,
370                              getPsyncInitialOffset());
371              }
372          }
373      }
374      if (retval == C_OK) replicationScriptCacheFlush();
375      return retval;
376  }
377  void syncCommand(client *c) {
378      if (c-&gt;flags &amp; CLIENT_SLAVE) return;
379      if (server.masterhost &amp;&amp; server.repl_state != REPL_STATE_CONNECTED) {
380          addReplySds(c,sdsnew(&quot;-NOMASTERLINK Can&#x27;t SYNC while not connected with my master\r\n&quot;));
381          return;
382      }
383      if (clientHasPendingReplies(c)) {
384          addReplyError(c,&quot;SYNC and PSYNC are invalid with pending output&quot;);
385          return;
386      }
387      serverLog(LL_NOTICE,&quot;Replica %s asks for synchronization&quot;,
388          replicationGetSlaveName(c));
389      if (!strcasecmp(c-&gt;argv[0]-&gt;ptr,&quot;psync&quot;)) {
390          if (masterTryPartialResynchronization(c) == C_OK) {
391              server.stat_sync_partial_ok++;
392              return; &amp;bsol;* No full resync needed, return. */
393          } else {
394              char *master_replid = c-&gt;argv[1]-&gt;ptr;
395              if (master_replid[0] != &#x27;?&#x27;) server.stat_sync_partial_err++;
396          }
397      } else {
398          c-&gt;flags |= CLIENT_PRE_PSYNC;
399      }
400      server.stat_sync_full++;
401      c-&gt;replstate = SLAVE_STATE_WAIT_BGSAVE_START;
402      if (server.repl_disable_tcp_nodelay)
403          anetDisableTcpNoDelay(NULL, c-&gt;fd); &amp;bsol;* Non critical if it fails. */
404      c-&gt;repldbfd = -1;
405      c-&gt;flags |= CLIENT_SLAVE;
406      listAddNodeTail(server.slaves,c);
407      if (listLength(server.slaves) == 1 &amp;&amp; server.repl_backlog == NULL) {
408          changeReplicationId();
409          clearReplicationId2();
410          createReplicationBacklog();
411      }
412      if (server.rdb_child_pid != -1 &amp;&amp;
413          server.rdb_child_type == RDB_CHILD_TYPE_DISK)
414      {
415          client *slave;
416          listNode *ln;
417          listIter li;
418          listRewind(server.slaves,&amp;li);
419          while((ln = listNext(&amp;li))) {
420              slave = ln-&gt;value;
421              if (slave-&gt;replstate == SLAVE_STATE_WAIT_BGSAVE_END) break;
422          }
423          if (ln &amp;&amp; ((c-&gt;slave_capa &amp; slave-&gt;slave_capa) == slave-&gt;slave_capa)) {
424              copyClientOutputBuffer(c,slave);
425              replicationSetupSlaveForFullResync(c,slave-&gt;psync_initial_offset);
426              serverLog(LL_NOTICE,&quot;Waiting for end of BGSAVE for SYNC&quot;);
427          } else {
428              serverLog(LL_NOTICE,&quot;Can&#x27;t attach the replica to the current BGSAVE. Waiting for next BGSAVE for SYNC&quot;);
429          }
430      } else if (server.rdb_child_pid != -1 &amp;&amp;
431                 server.rdb_child_type == RDB_CHILD_TYPE_SOCKET)
432      {
433          serverLog(LL_NOTICE,&quot;Current BGSAVE has socket target. Waiting for next BGSAVE for SYNC&quot;);
434      } else {
435          if (server.repl_diskless_sync &amp;&amp; (c-&gt;slave_capa &amp; SLAVE_CAPA_EOF)) {
436              if (server.repl_diskless_sync_delay)
437                  serverLog(LL_NOTICE,&quot;Delay next BGSAVE for diskless SYNC&quot;);
438          } else {
439              if (server.aof_child_pid == -1) {
440                  startBgsaveForReplication(c-&gt;slave_capa);
441              } else {
442                  serverLog(LL_NOTICE,
443                      &quot;No BGSAVE in progress, but an AOF rewrite is active. &quot;
444                      &quot;BGSAVE for replication delayed&quot;);
445              }
446          }
447      }
448      return;
449  }
450  void replconfCommand(client *c) {
451      int j;
452      if ((c-&gt;argc % 2) == 0) {
453          addReply(c,shared.syntaxerr);
454          return;
455      }
456      for (j = 1; j &lt; c-&gt;argc; j+=2) {
457          if (!strcasecmp(c-&gt;argv[j]-&gt;ptr,&quot;listening-port&quot;)) {
458              PORT_LONG port;
459              if ((getLongFromObjectOrReply(c,c-&gt;argv[j+1],
460                      &amp;port,NULL) != C_OK))
461                  return;
462              c-&gt;slave_listening_port = (int) port;                               WIN_PORT_FIX &amp;bsol;* cast (int) */
463          } else if (!strcasecmp(c-&gt;argv[j]-&gt;ptr,&quot;ip-address&quot;)) {
464              sds ip = c-&gt;argv[j+1]-&gt;ptr;
465              if (sdslen(ip) &lt; sizeof(c-&gt;slave_ip)) {
466                  memcpy(c-&gt;slave_ip,ip,sdslen(ip)+1);
467              } else {
468                  addReplyErrorFormat(c,&quot;REPLCONF ip-address provided by &quot;
469                      &quot;replica instance is too long: %zd bytes&quot;, sdslen(ip));
470                  return;
471              }
472          } else if (!strcasecmp(c-&gt;argv[j]-&gt;ptr,&quot;capa&quot;)) {
473              if (!strcasecmp(c-&gt;argv[j+1]-&gt;ptr,&quot;eof&quot;))
474                  c-&gt;slave_capa |= SLAVE_CAPA_EOF;
475              else if (!strcasecmp(c-&gt;argv[j+1]-&gt;ptr,&quot;psync2&quot;))
476                  c-&gt;slave_capa |= SLAVE_CAPA_PSYNC2;
477          } else if (!strcasecmp(c-&gt;argv[j]-&gt;ptr,&quot;ack&quot;)) {
478              PORT_LONGLONG offset;
479              if (!(c-&gt;flags &amp; CLIENT_SLAVE)) return;
480              if ((getLongLongFromObject(c-&gt;argv[j+1], &amp;offset) != C_OK))
481                  return;
482              if (offset &gt; c-&gt;repl_ack_off)
483                  c-&gt;repl_ack_off = offset;
484              c-&gt;repl_ack_time = server.unixtime;
485              if (c-&gt;repl_put_online_on_ack &amp;&amp; c-&gt;replstate == SLAVE_STATE_ONLINE)
486                  putSlaveOnline(c);
487              return;
488          } else if (!strcasecmp(c-&gt;argv[j]-&gt;ptr,&quot;getack&quot;)) {
489              if (server.masterhost &amp;&amp; server.master) replicationSendAck();
490              return;
491          } else {
492              addReplyErrorFormat(c,&quot;Unrecognized REPLCONF option: %s&quot;,
493                  (char*)c-&gt;argv[j]-&gt;ptr);
494              return;
495          }
496      }
497      addReply(c,shared.ok);
498  }
499  void putSlaveOnline(client *slave) {
500      slave-&gt;replstate = SLAVE_STATE_ONLINE;
501      slave-&gt;repl_put_online_on_ack = 0;
502      slave-&gt;repl_ack_time = server.unixtime; &amp;bsol;* Prevent false timeout. */
503      if (aeCreateFileEvent(server.el, slave-&gt;fd, AE_WRITABLE,
504          sendReplyToClient, slave) == AE_ERR) {
505          serverLog(LL_WARNING,&quot;Unable to register writable event for replica bulk transfer: %s&quot;, IF_WIN32(wsa_strerror(errno),strerror(errno)));
506          freeClient(slave);
507          return;
508      }
509      refreshGoodSlavesCount();
510      serverLog(LL_NOTICE,&quot;Synchronization with replica %s succeeded&quot;,
511          replicationGetSlaveName(slave));
512  }
513  #ifdef _WIN32
514  void sendBulkToSlaveLenDone(aeEventLoop *el, int fd, void *privdata, int written) {
515      WSIOCP_Request *req = (WSIOCP_Request *) privdata;
516      UNUSED(el);
517      UNUSED(fd);
518      sdsfree((sds) req-&gt;buf);
519  }
520  void sendBulkToSlaveDataDone(aeEventLoop *el, int fd, void *privdata, int nwritten) {
521      WSIOCP_Request *req = (WSIOCP_Request *) privdata;
522      client *slave = (client *) req-&gt;client;
523      UNUSED(el);
524      UNUSED(fd);
525      zfree(req-&gt;data);
526      slave-&gt;repldboff += nwritten;
527      if (slave-&gt;repldboff == slave-&gt;repldbsize) {
528          close(slave-&gt;repldbfd);
529          DeleteFileA(slave-&gt;replFileCopy);
530          memset(slave-&gt;replFileCopy, 0, MAX_PATH);
531          slave-&gt;repldbfd = -1;
532          aeDeleteFileEvent(server.el, slave-&gt;fd, AE_WRITABLE);
533          putSlaveOnline(slave);
534      }
535  }
536  void sendBulkToSlave(aeEventLoop *el, int fd, void *privdata, int mask) {
537      client *slave = privdata;
538      UNUSED(el);
539      UNUSED(mask);
540      char *buf;
541      ssize_t result, buflen;
542      if (slave-&gt;repldboff == 0) {
543          sds bulkcount;
544          bulkcount = sdscatprintf(sdsempty(),&quot;$%lld\r\n&quot;,(PORT_ULONGLONG)
545              slave-&gt;repldbsize);
546          result = WSIOCP_SocketSend(fd, bulkcount, (int) sdslen(bulkcount), el,
547                                     slave, bulkcount, sendBulkToSlaveLenDone);
548          if (result == SOCKET_ERROR &amp;&amp; errno != WSA_IO_PENDING) {
549              sdsfree(bulkcount);
550              freeClient(slave);
551              return;
552          }
553      }
554      lseek64(slave-&gt;repldbfd,slave-&gt;repldboff,SEEK_SET);
555      buf = (char *)zmalloc(PROTO_IOBUF_LEN);
556      buflen = read(slave-&gt;repldbfd,buf,PROTO_IOBUF_LEN);
557      if (buflen &lt;= 0) {
558          serverLog(LL_WARNING,&quot;Read error sending DB to slave: %s&quot;,
559              (buflen == 0) ? &quot;premature EOF&quot; : IF_WIN32(wsa_strerror(errno),strerror(errno)));
560          freeClient(slave);
561          return;
562      }
563      result = WSIOCP_SocketSend(fd, buf, (int) buflen, el, slave, buf,
564                                 sendBulkToSlaveDataDone);
565      if (result == SOCKET_ERROR &amp;&amp; errno != WSA_IO_PENDING) {
566          serverLog(LL_VERBOSE,&quot;Write error sending DB to slave: %s&quot;,
567              IF_WIN32(wsa_strerror(errno),strerror(errno)));
568          freeClient(slave);
569          return;
570      }
571  }
572  #else
573  void sendBulkToSlave(aeEventLoop *el, int fd, void *privdata, int mask) {
574      client *slave = privdata;
575      UNUSED(el);
576      UNUSED(mask);
577      char buf[PROTO_IOBUF_LEN];
578      ssize_t nwritten, buflen;
579      if (slave-&gt;replpreamble) {
580          nwritten = write(fd,slave-&gt;replpreamble,sdslen(slave-&gt;replpreamble));
581          if (nwritten == -1) {
582              serverLog(LL_VERBOSE,&quot;Write error sending RDB preamble to replica: %s&quot;,
583                  strerror(errno));
584              freeClient(slave);
585              return;
586          }
587          server.stat_net_output_bytes += nwritten;
588          sdsrange(slave-&gt;replpreamble,nwritten,-1);
589          if (sdslen(slave-&gt;replpreamble) == 0) {
590              sdsfree(slave-&gt;replpreamble);
591              slave-&gt;replpreamble = NULL;
592          } else {
593              return;
594          }
595      }
596      lseek(slave-&gt;repldbfd,slave-&gt;repldboff,SEEK_SET);
597      buflen = read(slave-&gt;repldbfd,buf,PROTO_IOBUF_LEN);
598      if (buflen &lt;= 0) {
599          serverLog(LL_WARNING,&quot;Read error sending DB to replica: %s&quot;,
600              (buflen == 0) ? &quot;premature EOF&quot; : strerror(errno));
601          freeClient(slave);
602          return;
603      }
604      if ((nwritten = write(fd,buf,buflen)) == -1) {
605          if (errno != EAGAIN) {
606              serverLog(LL_WARNING,&quot;Write error sending DB to replica: %s&quot;,
607                  strerror(errno));
608              freeClient(slave);
609          }
610          return;
611      }
612      slave-&gt;repldboff += nwritten;
613      server.stat_net_output_bytes += nwritten;
614      if (slave-&gt;repldboff == slave-&gt;repldbsize) {
615          close(slave-&gt;repldbfd);
616          slave-&gt;repldbfd = -1;
617          aeDeleteFileEvent(server.el,slave-&gt;fd,AE_WRITABLE);
618          putSlaveOnline(slave);
619      }
620  }
621  #endif
622  void updateSlavesWaitingBgsave(int bgsaveerr, int type) {
623      listNode *ln;
624      int startbgsave = 0;
625      int mincapa = -1;
626      listIter li;
627      listRewind(server.slaves,&amp;li);
628      while((ln = listNext(&amp;li))) {
629          client *slave = ln-&gt;value;
630          if (slave-&gt;replstate == SLAVE_STATE_WAIT_BGSAVE_START) {
631              startbgsave = 1;
632              mincapa = (mincapa == -1) ? slave-&gt;slave_capa :
633                                          (mincapa &amp; slave-&gt;slave_capa);
634          } else if (slave-&gt;replstate == SLAVE_STATE_WAIT_BGSAVE_END) {
635              struct redis_stat buf;
636              if (type == RDB_CHILD_TYPE_SOCKET) {
637                  serverLog(LL_NOTICE,
638                      &quot;Streamed RDB transfer with replica %s succeeded (socket). Waiting for REPLCONF ACK from slave to enable streaming&quot;,
639                          replicationGetSlaveName(slave));
640                  slave-&gt;replstate = SLAVE_STATE_ONLINE;
641                  slave-&gt;repl_put_online_on_ack = 1;
642                  slave-&gt;repl_ack_time = server.unixtime; &amp;bsol;* Timeout otherwise. */
643              } else {
644                  if (bgsaveerr != C_OK) {
645                      freeClient(slave);
646                      serverLog(LL_WARNING,&quot;SYNC failed. BGSAVE child returned an error&quot;);
647                      continue;
648                  }
649  #ifdef _WIN32
650                  sprintf(slave-&gt;replFileCopy,&quot;%d_%s&quot;,  slave-&gt;fd, server.rdb_filename);
651                  if(CopyFileA( server.rdb_filename, slave-&gt;replFileCopy, FALSE) == FALSE) {
652                      freeClient(slave);
653                      serverLog(LL_WARNING,&quot;Failed to duplicate RDB file. Failing SYNC: %d&quot;, GetLastError());
654                      continue;
655                  }
656                  if ((slave-&gt;repldbfd = open(slave-&gt;replFileCopy,O_RDONLY|_O_BINARY,0)) == -1 ||
657  #else
658                  if ((slave-&gt;repldbfd = open(server.rdb_filename,O_RDONLY)) == -1 ||
659  #endif
660                      redis_fstat(slave-&gt;repldbfd,&amp;buf) == -1) {
661                      freeClient(slave);
662                      serverLog(LL_WARNING,&quot;SYNC failed. Can&#x27;t open/stat DB after BGSAVE: %s&quot;, IF_WIN32(wsa_strerror(errno),strerror(errno)));
663                      continue;
664                  }
665                  slave-&gt;repldboff = 0;
666                  slave-&gt;repldbsize = buf.st_size;
667                  slave-&gt;replstate = SLAVE_STATE_SEND_BULK;
668                  slave-&gt;replpreamble = sdscatprintf(sdsempty(),&quot;$%lld\r\n&quot;,
669                      (PORT_ULONGLONG) slave-&gt;repldbsize);
670                  aeDeleteFileEvent(server.el,slave-&gt;fd,AE_WRITABLE);
671                  if (aeCreateFileEvent(server.el, slave-&gt;fd, AE_WRITABLE, sendBulkToSlave, slave) == AE_ERR) {
672                      freeClient(slave);
673                      continue;
674                  }
675              }
676          }
677      }
678      if (startbgsave) startBgsaveForReplication(mincapa);
679  }
680  void changeReplicationId(void) {
681      getRandomHexChars(server.replid,CONFIG_RUN_ID_SIZE);
682      server.replid[CONFIG_RUN_ID_SIZE] = &#x27;\0&#x27;;
683  }
684  void clearReplicationId2(void) {
685      memset(server.replid2,&#x27;0&#x27;,sizeof(server.replid));
686      server.replid2[CONFIG_RUN_ID_SIZE] = &#x27;\0&#x27;;
687      server.second_replid_offset = -1;
688  }
689  void shiftReplicationId(void) {
690      memcpy(server.replid2,server.replid,sizeof(server.replid));
691      server.second_replid_offset = server.master_repl_offset+1;
692      changeReplicationId();
693      serverLog(LL_WARNING,&quot;Setting secondary replication ID to %s, valid up to offset: %lld. New replication ID is %s&quot;, server.replid2, server.second_replid_offset, server.replid);
694  }
695  int slaveIsInHandshakeState(void) {
696      return server.repl_state &gt;= REPL_STATE_RECEIVE_PONG &amp;&amp;
697             server.repl_state &lt;= REPL_STATE_RECEIVE_PSYNC;
698  }
699  void replicationSendNewlineToMaster(void) {
700      static time_t newline_sent;
701      if (time(NULL) != newline_sent) {
702          newline_sent = time(NULL);
703          if (write(server.repl_transfer_s,&quot;\n&quot;,1) == -1) {
704          }
705      }
706  }
707  void replicationEmptyDbCallback(void *privdata) {
708      UNUSED(privdata);
709      replicationSendNewlineToMaster();
710  }
711  void replicationCreateMasterClient(int fd, int dbid) {
712      server.master = createClient(fd);
713      server.master-&gt;flags |= CLIENT_MASTER;
714      server.master-&gt;authenticated = 1;
715      server.master-&gt;reploff = server.master_initial_offset;
716      server.master-&gt;read_reploff = server.master-&gt;reploff;
717      memcpy(server.master-&gt;replid, server.master_replid,
718          sizeof(server.master_replid));
719      if (server.master-&gt;reploff == -1)
720          server.master-&gt;flags |= CLIENT_PRE_PSYNC;
721      if (dbid != -1) selectDb(server.master,dbid);
722  }
723  void restartAOFAfterSYNC() {
724      unsigned int tries, max_tries = 10;
725      for (tries = 0; tries &lt; max_tries; ++tries) {
726          if (startAppendOnly() == C_OK) break;
727          serverLog(LL_WARNING,
728              &quot;Failed enabling the AOF after successful master synchronization! &quot;
729              &quot;Trying it again in one second.&quot;);
730          sleep(1);
731      }
732      if (tries == max_tries) {
733          serverLog(LL_WARNING,
734              &quot;FATAL: this replica instance finished the synchronization with &quot;
735              &quot;its master, but the AOF can&#x27;t be turned on. Exiting now.&quot;);
736          exit(1);
737      }
738  }
739  #define REPL_MAX_WRITTEN_BEFORE_FSYNC (1024*1024*8) &amp;bsol;* 8 MB */
740  void readSyncBulkPayload(aeEventLoop *el, int fd, void *privdata, int mask) {
741      char buf[4096];
742      ssize_t nread, readlen, nwritten;
743      off_t left;
744      UNUSED(el);
745      UNUSED(privdata);
746      UNUSED(mask);
747      static char eofmark[CONFIG_RUN_ID_SIZE];
748      static char lastbytes[CONFIG_RUN_ID_SIZE];
749      static int usemark = 0;
750      if (server.repl_transfer_size == -1) {
751          if (syncReadLine(fd,buf,1024,(PORT_LONGLONG)server.repl_syncio_timeout*1000) == -1) {  WIN_PORT_FIX &amp;bsol;* cast (PORT_LONGLONG) */
752              serverLog(LL_WARNING,
753                  &quot;I/O error reading bulk count from MASTER: %s&quot;,
754                  IF_WIN32(wsa_strerror(errno),strerror(errno)));
755              goto error;
756          }
757          WIN32_ONLY(WSIOCP_QueueNextRead(fd);)
758          if (buf[0] == &#x27;-&#x27;) {
759              serverLog(LL_WARNING,
760                  &quot;MASTER aborted replication with an error: %s&quot;,
761                  buf+1);
762              goto error;
763          } else if (buf[0] == &#x27;\0&#x27;) {
764              server.repl_transfer_lastio = server.unixtime;
765              return;
766          } else if (buf[0] != &#x27;$&#x27;) {
767              serverLog(LL_WARNING,&quot;Bad protocol from MASTER, the first byte is not &#x27;$&#x27; (we received &#x27;%s&#x27;), are you sure the host and port are right?&quot;, buf);
768              goto error;
769          }
770          if (strncmp(buf+1,&quot;EOF:&quot;,4) == 0 &amp;&amp; strlen(buf+5) &gt;= CONFIG_RUN_ID_SIZE) {
771              usemark = 1;
772              memcpy(eofmark,buf+5,CONFIG_RUN_ID_SIZE);
773              memset(lastbytes,0,CONFIG_RUN_ID_SIZE);
774              server.repl_transfer_size = 0;
775              serverLog(LL_NOTICE,
776                  &quot;MASTER &lt;-&gt; REPLICA sync: receiving streamed RDB from master&quot;);
777          } else {
778              usemark = 0;
779              server.repl_transfer_size = strtol(buf+1,NULL,10);
780              serverLog(LL_NOTICE,
781                  &quot;MASTER &lt;-&gt; REPLICA sync: receiving %lld bytes from master&quot;,
782                  (PORT_LONGLONG) server.repl_transfer_size);
783          }
784          return;
785      }
786      if (usemark) {
787          readlen = sizeof(buf);
788      } else {
789          left = server.repl_transfer_size - server.repl_transfer_read;
790          readlen = (left &lt; (signed)sizeof(buf)) ? left : (signed)sizeof(buf);
791      }
792      nread = read(fd,buf,readlen);
793      if (nread &lt;= 0) {
794  #ifdef _WIN32
795          if (server.repl_transfer_size) {
796              serverLog(LL_WARNING,&quot;I/O error %d (left %Iu) trying to sync with MASTER: %s&quot;,
797                  errno, server.repl_transfer_size,
798                  (nread == -1) ? wsa_strerror(errno) : &quot;connection lost&quot;);
799          }
800  #else
801          serverLog(LL_WARNING,&quot;I/O error trying to sync with MASTER: %s&quot;,
802              (nread == -1) ? strerror(errno) : &quot;connection lost&quot;);
803  #endif
804          cancelReplicationHandshake();
805          return;
806      }
807      WIN32_ONLY(WSIOCP_QueueNextRead(fd);)
808      server.stat_net_input_bytes += nread;
809      int eof_reached = 0;
810      if (usemark) {
811          if (nread &gt;= CONFIG_RUN_ID_SIZE) {
812              memcpy(lastbytes,buf+nread-CONFIG_RUN_ID_SIZE,CONFIG_RUN_ID_SIZE);
813          } else {
814              int rem = (int)(CONFIG_RUN_ID_SIZE-nread);                           WIN_PORT_FIX &amp;bsol;* cast (int) */
815              memmove(lastbytes,lastbytes+nread,rem);
816              memcpy(lastbytes+rem,buf,nread);
817          }
818  #ifdef _WIN32
819          #pragma warning( suppress: 6385 ))
820  #endif
821          if (memcmp(lastbytes,eofmark,CONFIG_RUN_ID_SIZE) == 0) eof_reached = 1;
822      }
823      server.repl_transfer_lastio = server.unixtime;
824      if ((nwritten = write(server.repl_transfer_fd,buf,nread)) != nread) {
825          serverLog(LL_WARNING,&quot;Write error or short write writing to the DB dump file needed for MASTER &lt;-&gt; REPLICA synchronization: %s&quot;,
826              (nwritten == -1) ? IF_WIN32(wsa_strerror(errno), strerror(errno)) : &quot;short write&quot;);
827          goto error;
828      }
829      server.repl_transfer_read += nread;
830      if (usemark &amp;&amp; eof_reached) {
831          if (ftruncate(server.repl_transfer_fd,
832              server.repl_transfer_read - CONFIG_RUN_ID_SIZE) == -1)
833          {
834              serverLog(LL_WARNING,&quot;Error truncating the RDB file received from the master for SYNC: %s&quot;, IF_WIN32(wsa_strerror(errno),strerror(errno)));
835              goto error;
836          }
837      }
838      if (server.repl_transfer_read &gt;=
839          server.repl_transfer_last_fsync_off + REPL_MAX_WRITTEN_BEFORE_FSYNC)
840      {
841          off_t sync_size = server.repl_transfer_read -
842                            server.repl_transfer_last_fsync_off;
843          rdb_fsync_range(server.repl_transfer_fd,
844              server.repl_transfer_last_fsync_off, sync_size);
845          server.repl_transfer_last_fsync_off += sync_size;
846      }
847      if (!usemark) {
848          if (server.repl_transfer_read == server.repl_transfer_size)
849              eof_reached = 1;
850      }
851      if (eof_reached) {
852          int aof_is_enabled = server.aof_state != AOF_OFF;
853  #ifdef _WIN32
854          close(server.repl_transfer_fd);
855          server.repl_transfer_fd = -1;
856  #endif
857          if (server.rdb_child_pid != -1) {
858              serverLog(LL_NOTICE,
859                  &quot;Replica is about to load the RDB file received from the &quot;
860                  &quot;master, but there is a pending RDB child running. &quot;
861                  &quot;Killing process %ld and removing its temp file to avoid &quot;
862                  &quot;any race&quot;,
863                      (PORT_LONG) server.rdb_child_pid);
864              IF_WIN32(AbortForkOperation(), kill(server.rdb_child_pid,SIGUSR1));
865              rdbRemoveTempFile(server.rdb_child_pid);
866          }
867          if (fsync(server.repl_transfer_fd) == -1) {
868              serverLog(LL_WARNING,
869                  &quot;Failed trying to sync the temp DB to disk in &quot;
870                  &quot;MASTER &lt;-&gt; REPLICA synchronization: %s&quot;,
871                  strerror(errno));
872              cancelReplicationHandshake();
873              return;
874          }
875          if (rename(server.repl_transfer_tmpfile,server.rdb_filename) == -1) {
876              serverLog(LL_WARNING,&quot;Failed trying to rename the temp DB into dump.rdb in MASTER &lt;-&gt; REPLICA synchronization: %s&quot;, IF_WIN32(wsa_strerror(errno),strerror(errno)));
877              cancelReplicationHandshake();
878              return;
879          }
880          serverLog(LL_NOTICE, &quot;MASTER &lt;-&gt; REPLICA sync: Flushing old data&quot;);
881          if(aof_is_enabled) stopAppendOnly();
882          signalFlushedDb(-1);
883          emptyDb(
884              -1,
885              server.repl_slave_lazy_flush ? EMPTYDB_ASYNC : EMPTYDB_NO_FLAGS,
886              replicationEmptyDbCallback);
887          aeDeleteFileEvent(server.el,server.repl_transfer_s,AE_READABLE);
888          serverLog(LL_NOTICE, &quot;MASTER &lt;-&gt; REPLICA sync: Loading DB in memory&quot;);
889          rdbSaveInfo rsi = RDB_SAVE_INFO_INIT;
890          if (rdbLoad(server.rdb_filename,&amp;rsi) != C_OK) {
891              serverLog(LL_WARNING,&quot;Failed trying to load the MASTER synchronization DB from disk&quot;);
892              cancelReplicationHandshake();
893              if (aof_is_enabled) restartAOFAfterSYNC();
894              return;
895          }
896          zfree(server.repl_transfer_tmpfile);
897  #ifdef _WIN32
898          server.repl_transfer_tmpfile = NULL;
899  #else
900          close(server.repl_transfer_fd);
901  #endif
902          replicationCreateMasterClient(server.repl_transfer_s,rsi.repl_stream_db);
903          server.repl_state = REPL_STATE_CONNECTED;
904          server.repl_down_since = 0;
<span onclick='openModal()' class='match'>905          memcpy(server.replid,server.master-&gt;replid,sizeof(server.replid));
906          server.master_repl_offset = server.master-&gt;reploff;
</span>907          clearReplicationId2();
908          if (server.repl_backlog == NULL) createReplicationBacklog();
909          serverLog(LL_NOTICE, &quot;MASTER &lt;-&gt; REPLICA sync: Finished with success&quot;);
910          if (aof_is_enabled) restartAOFAfterSYNC();
911      }
912      return;
913  error:
914      cancelReplicationHandshake();
915      return;
916  }
917  #define SYNC_CMD_READ (1&lt;&lt;0)
918  #define SYNC_CMD_WRITE (1&lt;&lt;1)
919  #define SYNC_CMD_FULL (SYNC_CMD_READ|SYNC_CMD_WRITE)
920  char *sendSynchronousCommand(int flags, int fd, ...) {
921      if (flags &amp; SYNC_CMD_WRITE) {
922          char *arg;
923          va_list ap;
924          sds cmd = sdsempty();
925          sds cmdargs = sdsempty();
926          size_t argslen = 0;
927          va_start(ap,fd);
928          while(1) {
929              arg = va_arg(ap, char*);
930              if (arg == NULL) break;
931              cmdargs = sdscatprintf(cmdargs,&quot;$%Iu\r\n%s\r\n&quot;,strlen(arg),arg); WIN_PORT_FIX &amp;bsol;* zu-&gt;Iu */
932              argslen++;
933          }
934          va_end(ap);
935          cmd = sdscatprintf(cmd,&quot;*%Iu\r\n&quot;,argslen); WIN_PORT_FIX &amp;bsol;* zu-&gt;Iu */
936          cmd = sdscatsds(cmd,cmdargs);
937          sdsfree(cmdargs);
938          if (syncWrite(fd,cmd,(ssize_t)sdslen(cmd),(PORT_LONGLONG)server.repl_syncio_timeout*1000)      WIN_PORT_FIX &amp;bsol;* cast (ssize_t), cast (PORT_LONGLONG) */
939              == -1)
940          {
941              sdsfree(cmd);
942              return sdscatprintf(sdsempty(),&quot;-Writing to master: %s&quot;,
943                      IF_WIN32(wsa_strerror(errno),strerror(errno)));
944          }
945          sdsfree(cmd);
946      }
947      if (flags &amp; SYNC_CMD_READ) {
948          char buf[256];
949          if (syncReadLine(fd,buf,sizeof(buf),(PORT_LONGLONG)server.repl_syncio_timeout*1000)  WIN_PORT_FIX &amp;bsol;* cast (PORT_LONGLONG) */
950              == -1)
951          {
952              return sdscatprintf(sdsempty(),&quot;-Reading from master: %s&quot;,
953                      IF_WIN32(wsa_strerror(errno),strerror(errno)));
954          }
955          server.repl_transfer_lastio = server.unixtime;
956          return sdsnew(buf);
957      }
958      return NULL;
959  }
960  #define PSYNC_WRITE_ERROR 0
961  #define PSYNC_WAIT_REPLY 1
962  #define PSYNC_CONTINUE 2
963  #define PSYNC_FULLRESYNC 3
964  #define PSYNC_NOT_SUPPORTED 4
965  #define PSYNC_TRY_LATER 5
966  int slaveTryPartialResynchronization(int fd, int read_reply) {
967      char *psync_replid;
968      char psync_offset[32];
969      sds reply;
970      if (!read_reply) {
971          server.master_initial_offset = -1;
972          if (server.cached_master) {
973              psync_replid = server.cached_master-&gt;replid;
974              snprintf(psync_offset,sizeof(psync_offset),&quot;%lld&quot;, server.cached_master-&gt;reploff+1);
975              serverLog(LL_NOTICE,&quot;Trying a partial resynchronization (request %s:%s).&quot;, psync_replid, psync_offset);
976          } else {
977              serverLog(LL_NOTICE,&quot;Partial resynchronization not possible (no cached master)&quot;);
978              psync_replid = &quot;?&quot;;
979              memcpy(psync_offset,&quot;-1&quot;,3);
980          }
981          reply = sendSynchronousCommand(SYNC_CMD_WRITE,fd,&quot;PSYNC&quot;,psync_replid,psync_offset,NULL);
982          if (reply != NULL) {
983              serverLog(LL_WARNING,&quot;Unable to send PSYNC to master: %s&quot;,reply);
984              sdsfree(reply);
985              aeDeleteFileEvent(server.el,fd,AE_READABLE);
986              return PSYNC_WRITE_ERROR;
987          }
988          WIN32_ONLY(WSIOCP_QueueNextRead(fd);)
989          return PSYNC_WAIT_REPLY;
990      }
991      reply = sendSynchronousCommand(SYNC_CMD_READ,fd,NULL);
992      if (sdslen(reply) == 0) {
993          sdsfree(reply);
994          WIN32_ONLY(WSIOCP_QueueNextRead(fd);)
995          return PSYNC_WAIT_REPLY;
996      }
997      aeDeleteFileEvent(server.el,fd,AE_READABLE);
998      if (!strncmp(reply,&quot;+FULLRESYNC&quot;,11)) {
999          char *replid = NULL, *offset = NULL;
1000          replid = strchr(reply,&#x27; &#x27;);
1001          if (replid) {
1002              replid++;
1003              offset = strchr(replid,&#x27; &#x27;);
1004              if (offset) offset++;
1005          }
1006          if (!replid || !offset || (offset-replid-1) != CONFIG_RUN_ID_SIZE) {
1007              serverLog(LL_WARNING,
1008                  &quot;Master replied with wrong +FULLRESYNC syntax.&quot;);
1009              memset(server.master_replid,0,CONFIG_RUN_ID_SIZE+1);
1010          } else {
1011              memcpy(server.master_replid, replid, offset-replid-1);
1012              server.master_replid[CONFIG_RUN_ID_SIZE] = &#x27;\0&#x27;;
1013              server.master_initial_offset = strtoll(offset,NULL,10);
1014              serverLog(LL_NOTICE,&quot;Full resync from master: %s:%lld&quot;,
1015                  server.master_replid,
1016                  server.master_initial_offset);
1017          }
1018          replicationDiscardCachedMaster();
1019          sdsfree(reply);
1020          return PSYNC_FULLRESYNC;
1021      }
1022      if (!strncmp(reply,&quot;+CONTINUE&quot;,9)) {
1023          serverLog(LL_NOTICE,
1024              &quot;Successful partial resynchronization with master.&quot;);
1025          char *start = reply+10;
1026          char *end = reply+9;
1027          while(end[0] != &#x27;\r&#x27; &amp;&amp; end[0] != &#x27;\n&#x27; &amp;&amp; end[0] != &#x27;\0&#x27;) end++;
1028          if (end-start == CONFIG_RUN_ID_SIZE) {
1029              char new[CONFIG_RUN_ID_SIZE+1];
1030              memcpy(new,start,CONFIG_RUN_ID_SIZE);
1031              new[CONFIG_RUN_ID_SIZE] = &#x27;\0&#x27;;
1032              if (strcmp(new,server.cached_master-&gt;replid)) {
1033                  serverLog(LL_WARNING,&quot;Master replication ID changed to %s&quot;,new);
1034                  memcpy(server.replid2,server.cached_master-&gt;replid,
1035                      sizeof(server.replid2));
1036                  server.second_replid_offset = server.master_repl_offset+1;
1037                  memcpy(server.replid,new,sizeof(server.replid));
1038                  memcpy(server.cached_master-&gt;replid,new,sizeof(server.replid));
1039                  disconnectSlaves();
1040              }
1041          }
1042          sdsfree(reply);
1043          replicationResurrectCachedMaster(fd);
1044          if (server.repl_backlog == NULL) createReplicationBacklog();
1045          return PSYNC_CONTINUE;
1046      }
1047      if (!strncmp(reply,&quot;-NOMASTERLINK&quot;,13) ||
1048          !strncmp(reply,&quot;-LOADING&quot;,8))
1049      {
1050          serverLog(LL_NOTICE,
1051              &quot;Master is currently unable to PSYNC &quot;
1052              &quot;but should be in the future: %s&quot;, reply);
1053          sdsfree(reply);
1054          return PSYNC_TRY_LATER;
1055      }
1056      if (strncmp(reply,&quot;-ERR&quot;,4)) {
1057          serverLog(LL_WARNING,
1058              &quot;Unexpected reply to PSYNC from master: %s&quot;, reply);
1059      } else {
1060          serverLog(LL_NOTICE,
1061              &quot;Master does not support PSYNC or is in &quot;
1062              &quot;error state (reply: %s)&quot;, reply);
1063      }
1064      sdsfree(reply);
1065      replicationDiscardCachedMaster();
1066      return PSYNC_NOT_SUPPORTED;
1067  }
1068  void syncWithMaster(aeEventLoop *el, int fd, void *privdata, int mask) {
1069      char tmpfile[256], *err = NULL;
1070      int dfd = -1, maxtries = 5;
1071      int sockerr = 0, psync_result;
1072      socklen_t errlen = sizeof(sockerr);
1073      UNUSED(el);
1074      UNUSED(privdata);
1075      UNUSED(mask);
1076      if (server.repl_state == REPL_STATE_NONE) {
1077          close(fd);
1078          return;
1079      }
1080      if (getsockopt(fd, SOL_SOCKET, SO_ERROR, &amp;sockerr, &amp;errlen) == -1)
1081          sockerr = errno;
1082      if (sockerr) {
1083          serverLog(LL_WARNING,&quot;Error condition on socket for SYNC: %s&quot;,
1084              strerror(sockerr));
1085          goto error;
1086      }
1087      if (server.repl_state == REPL_STATE_CONNECTING) {
1088          serverLog(LL_NOTICE,&quot;Non blocking connect for SYNC fired the event.&quot;);
1089          aeDeleteFileEvent(server.el,fd,AE_WRITABLE);
1090          server.repl_state = REPL_STATE_RECEIVE_PONG;
1091          err = sendSynchronousCommand(SYNC_CMD_WRITE,fd,&quot;PING&quot;,NULL);
1092          if (err) goto write_error;
1093          WIN32_ONLY(WSIOCP_QueueNextRead(fd);)
1094          return;
1095      }
1096      if (server.repl_state == REPL_STATE_RECEIVE_PONG) {
1097          err = sendSynchronousCommand(SYNC_CMD_READ,fd,NULL);
1098          if (err[0] != &#x27;+&#x27; &amp;&amp;
1099              strncmp(err,&quot;-NOAUTH&quot;,7) != 0 &amp;&amp;
1100              strncmp(err,&quot;-ERR operation not permitted&quot;,28) != 0)
1101          {
1102              serverLog(LL_WARNING,&quot;Error reply to PING from master: &#x27;%s&#x27;&quot;,err);
1103              sdsfree(err);
1104              goto error;
1105          } else {
1106              serverLog(LL_NOTICE,
1107                  &quot;Master replied to PING, replication can continue...&quot;);
1108          }
1109          sdsfree(err);
1110          server.repl_state = REPL_STATE_SEND_AUTH;
1111      }
1112      if (server.repl_state == REPL_STATE_SEND_AUTH) {
1113          if (server.masterauth) {
1114              err = sendSynchronousCommand(SYNC_CMD_WRITE,fd,&quot;AUTH&quot;,server.masterauth,NULL);
1115              if (err) goto write_error;
1116              server.repl_state = REPL_STATE_RECEIVE_AUTH;
1117              WIN32_ONLY(WSIOCP_QueueNextRead(fd);)
1118              return;
1119          } else {
1120              server.repl_state = REPL_STATE_SEND_PORT;
1121          }
1122      }
1123      if (server.repl_state == REPL_STATE_RECEIVE_AUTH) {
1124          err = sendSynchronousCommand(SYNC_CMD_READ,fd,NULL);
1125          if (err[0] == &#x27;-&#x27;) {
1126              serverLog(LL_WARNING,&quot;Unable to AUTH to MASTER: %s&quot;,err);
1127              sdsfree(err);
1128              goto error;
1129          }
1130          sdsfree(err);
1131          server.repl_state = REPL_STATE_SEND_PORT;
1132      }
1133      if (server.repl_state == REPL_STATE_SEND_PORT) {
1134          sds port = sdsfromlonglong(server.slave_announce_port ?
1135              server.slave_announce_port : server.port);
1136          err = sendSynchronousCommand(SYNC_CMD_WRITE,fd,&quot;REPLCONF&quot;,
1137                  &quot;listening-port&quot;,port, NULL);
1138          sdsfree(port);
1139          if (err) goto write_error;
1140          sdsfree(err);
1141          server.repl_state = REPL_STATE_RECEIVE_PORT;
1142          return;
1143      }
1144      if (server.repl_state == REPL_STATE_RECEIVE_PORT) {
1145          err = sendSynchronousCommand(SYNC_CMD_READ,fd,NULL);
1146          if (err[0] == &#x27;-&#x27;) {
1147              serverLog(LL_NOTICE,&quot;(Non critical) Master does not understand &quot;
1148                                  &quot;REPLCONF listening-port: %s&quot;, err);
1149          }
1150          sdsfree(err);
1151          server.repl_state = REPL_STATE_SEND_IP;
1152      }
1153      if (server.repl_state == REPL_STATE_SEND_IP &amp;&amp;
1154          server.slave_announce_ip == NULL)
1155      {
1156              server.repl_state = REPL_STATE_SEND_CAPA;
1157      }
1158      if (server.repl_state == REPL_STATE_SEND_IP) {
1159          err = sendSynchronousCommand(SYNC_CMD_WRITE,fd,&quot;REPLCONF&quot;,
1160                  &quot;ip-address&quot;,server.slave_announce_ip, NULL);
1161          if (err) goto write_error;
1162          sdsfree(err);
1163          server.repl_state = REPL_STATE_RECEIVE_IP;
1164          return;
1165      }
1166      if (server.repl_state == REPL_STATE_RECEIVE_IP) {
1167          err = sendSynchronousCommand(SYNC_CMD_READ,fd,NULL);
1168          if (err[0] == &#x27;-&#x27;) {
1169              serverLog(LL_NOTICE,&quot;(Non critical) Master does not understand &quot;
1170                                  &quot;REPLCONF ip-address: %s&quot;, err);
1171          }
1172          sdsfree(err);
1173          server.repl_state = REPL_STATE_SEND_CAPA;
1174      }
1175      if (server.repl_state == REPL_STATE_SEND_CAPA) {
1176          err = sendSynchronousCommand(SYNC_CMD_WRITE,fd,&quot;REPLCONF&quot;,
1177                  &quot;capa&quot;,&quot;eof&quot;,&quot;capa&quot;,&quot;psync2&quot;,NULL);
1178          if (err) goto write_error;
1179          sdsfree(err);
1180          server.repl_state = REPL_STATE_RECEIVE_CAPA;
1181          WIN32_ONLY(WSIOCP_QueueNextRead(fd);)
1182          return;
1183      }
1184      if (server.repl_state == REPL_STATE_RECEIVE_CAPA) {
1185          err = sendSynchronousCommand(SYNC_CMD_READ,fd,NULL);
1186          if (err[0] == &#x27;-&#x27;) {
1187              serverLog(LL_NOTICE,&quot;(Non critical) Master does not understand &quot;
1188                                    &quot;REPLCONF capa: %s&quot;, err);
1189          }
1190          sdsfree(err);
1191          server.repl_state = REPL_STATE_SEND_PSYNC;
1192      }
1193      if (server.repl_state == REPL_STATE_SEND_PSYNC) {
1194          if (slaveTryPartialResynchronization(fd,0) == PSYNC_WRITE_ERROR) {
1195              err = sdsnew(&quot;Write error sending the PSYNC command.&quot;);
1196              goto write_error;
1197          }
1198          server.repl_state = REPL_STATE_RECEIVE_PSYNC;
1199          return;
1200      }
1201      if (server.repl_state != REPL_STATE_RECEIVE_PSYNC) {
1202          serverLog(LL_WARNING,&quot;syncWithMaster(): state machine error, &quot;
1203                               &quot;state should be RECEIVE_PSYNC but is %d&quot;,
1204                               server.repl_state);
1205          goto error;
1206      }
1207      psync_result = slaveTryPartialResynchronization(fd,1);
1208      if (psync_result == PSYNC_WAIT_REPLY) return; &amp;bsol;* Try again later... */
1209      if (psync_result == PSYNC_TRY_LATER) goto error;
1210      if (psync_result == PSYNC_CONTINUE) {
1211          serverLog(LL_NOTICE, &quot;MASTER &lt;-&gt; REPLICA sync: Master accepted a Partial Resynchronization.&quot;);
1212          return;
1213      }
1214      disconnectSlaves(); &amp;bsol;* Force our slaves to resync with us as well. */
1215      freeReplicationBacklog(); &amp;bsol;* Don&#x27;t allow our chained slaves to PSYNC. */
1216      if (psync_result == PSYNC_NOT_SUPPORTED) {
1217          serverLog(LL_NOTICE,&quot;Retrying with SYNC...&quot;);
1218          if (syncWrite(fd,&quot;SYNC\r\n&quot;,6,(PORT_LONGLONG)server.repl_syncio_timeout*1000) == -1) {  WIN_PORT_FIX &amp;bsol;* cast (PORT_LONGLONG) */
1219              serverLog(LL_WARNING,&quot;I/O error writing to MASTER: %s&quot;,
1220                  IF_WIN32(wsa_strerror(errno),strerror(errno)));
1221              goto error;
1222          }
1223      }
1224      while(maxtries--) {
1225  #ifdef _WIN32
1226          snprintf(tmpfile,256,
1227              &quot;temp-%d.%d.rdb&quot;,(int)server.unixtime,(int)getpid());
1228          dfd = open(tmpfile,O_CREAT|O_WRONLY|O_EXCL|O_BINARY,_S_IREAD|_S_IWRITE);
1229  #else
1230          snprintf(tmpfile,256,
1231              &quot;temp-%d.%ld.rdb&quot;,(int)server.unixtime,(long int)getpid());
1232          dfd = open(tmpfile,O_CREAT|O_WRONLY|O_EXCL,0644);
1233  #endif
1234          if (dfd != -1) break;
1235          sleep(1);
1236      }
1237      if (dfd == -1) {
1238          serverLog(LL_WARNING,&quot;Opening the temp file needed for MASTER &lt;-&gt; REPLICA synchronization: %s&quot;,strerror(errno));
1239          goto error;
1240      }
1241      if (aeCreateFileEvent(server.el,fd, AE_READABLE,readSyncBulkPayload,NULL)
1242              == AE_ERR)
1243      {
1244          serverLog(LL_WARNING,
1245              &quot;Can&#x27;t create readable event for SYNC: %s (fd=%d)&quot;,
1246              IF_WIN32(wsa_strerror(errno),strerror(errno)),fd);
1247          goto error;
1248      }
1249      server.repl_state = REPL_STATE_TRANSFER;
1250      server.repl_transfer_size = -1;
1251      server.repl_transfer_read = 0;
1252      server.repl_transfer_last_fsync_off = 0;
1253      server.repl_transfer_fd = dfd;
1254      server.repl_transfer_lastio = server.unixtime;
1255      server.repl_transfer_tmpfile = zstrdup(tmpfile);
1256      return;
1257  error:
1258      aeDeleteFileEvent(server.el,fd,AE_READABLE|AE_WRITABLE);
1259      if (dfd != -1) close(dfd);
1260      close(fd);
1261      server.repl_transfer_s = -1;
1262      server.repl_state = REPL_STATE_CONNECT;
1263      return;
1264  write_error: &amp;bsol;* Handle sendSynchronousCommand(SYNC_CMD_WRITE) errors. */
1265      serverLog(LL_WARNING,&quot;Sending command to master in replication handshake: %s&quot;, err);
1266      sdsfree(err);
1267      goto error;
1268  }
1269  int connectWithMaster(void) {
1270      int fd;
1271      fd = anetTcpNonBlockBestEffortBindConnect(NULL,
1272          server.masterhost,server.masterport,NET_FIRST_BIND_ADDR);
1273      if (fd == -1) {
1274          serverLog(LL_WARNING,&quot;Unable to connect to MASTER: %s&quot;,
1275              IF_WIN32(wsa_strerror(errno),strerror(errno)));
1276          return C_ERR;
1277      }
1278      if (aeCreateFileEvent(server.el,fd,AE_READABLE|AE_WRITABLE,syncWithMaster,NULL) ==
1279              AE_ERR)
1280      {
1281          close(fd);
1282          serverLog(LL_WARNING,&quot;Can&#x27;t create readable event for SYNC&quot;);
1283          return C_ERR;
1284      }
1285      server.repl_transfer_lastio = server.unixtime;
1286      server.repl_transfer_s = fd;
1287      server.repl_state = REPL_STATE_CONNECTING;
1288      return C_OK;
1289  }
1290  void undoConnectWithMaster(void) {
1291      int fd = server.repl_transfer_s;
1292      aeDeleteFileEvent(server.el,fd,AE_READABLE|AE_WRITABLE);
1293      close(fd);
1294      server.repl_transfer_s = -1;
1295  }
1296  void replicationAbortSyncTransfer(void) {
1297      serverAssert(server.repl_state == REPL_STATE_TRANSFER);
1298      undoConnectWithMaster();
1299      close(server.repl_transfer_fd);
1300      unlink(server.repl_transfer_tmpfile);
1301      zfree(server.repl_transfer_tmpfile);
1302  }
1303  int cancelReplicationHandshake(void) {
1304      if (server.repl_state == REPL_STATE_TRANSFER) {
1305          replicationAbortSyncTransfer();
1306          server.repl_state = REPL_STATE_CONNECT;
1307      } else if (server.repl_state == REPL_STATE_CONNECTING ||
1308                 slaveIsInHandshakeState())
1309      {
1310          undoConnectWithMaster();
1311          server.repl_state = REPL_STATE_CONNECT;
1312      } else {
1313          return 0;
1314      }
1315      return 1;
1316  }
1317  void replicationSetMaster(char *ip, int port) {
1318      int was_master = server.masterhost == NULL;
1319      sdsfree(server.masterhost);
1320      server.masterhost = sdsnew(ip);
1321      server.masterport = port;
1322      if (server.master) {
1323          freeClient(server.master);
1324      }
1325      disconnectAllBlockedClients(); &amp;bsol;* Clients blocked in master, now slave. */
1326      disconnectSlaves();
1327      cancelReplicationHandshake();
1328      if (was_master) {
1329          replicationDiscardCachedMaster();
1330          replicationCacheMasterUsingMyself();
1331      }
1332      server.repl_state = REPL_STATE_CONNECT;
1333  }
1334  void replicationUnsetMaster(void) {
1335      if (server.masterhost == NULL) return; &amp;bsol;* Nothing to do. */
1336      sdsfree(server.masterhost);
1337      server.masterhost = NULL;
1338      shiftReplicationId();
1339      if (server.master) freeClient(server.master);
1340      replicationDiscardCachedMaster();
1341      cancelReplicationHandshake();
1342      disconnectSlaves();
1343      server.repl_state = REPL_STATE_NONE;
1344      server.slaveseldb = -1;
1345      server.repl_no_slaves_since = server.unixtime;
1346  }
1347  void replicationHandleMasterDisconnection(void) {
1348      server.master = NULL;
1349      server.repl_state = REPL_STATE_CONNECT;
1350      server.repl_down_since = server.unixtime;
1351  }
1352  void replicaofCommand(client *c) {
1353      if (server.cluster_enabled) {
1354          addReplyError(c,&quot;REPLICAOF not allowed in cluster mode.&quot;);
1355          return;
1356      }
1357      if (!strcasecmp(c-&gt;argv[1]-&gt;ptr,&quot;no&quot;) &amp;&amp;
1358          !strcasecmp(c-&gt;argv[2]-&gt;ptr,&quot;one&quot;)) {
1359          if (server.masterhost) {
1360              replicationUnsetMaster();
1361              sds client = catClientInfoString(sdsempty(),c);
1362              serverLog(LL_NOTICE,&quot;MASTER MODE enabled (user request from &#x27;%s&#x27;)&quot;,
1363                  client);
1364              sdsfree(client);
1365          }
1366      } else {
1367          PORT_LONG port;
1368          if (c-&gt;flags &amp; CLIENT_SLAVE)
1369          {
1370              addReplyError(c, &quot;Command is not valid when client is a replica.&quot;);
1371              return;
1372          }
1373          if ((getLongFromObjectOrReply(c, c-&gt;argv[2], &amp;port, NULL) != C_OK))
1374              return;
1375          if (server.masterhost &amp;&amp; !strcasecmp(server.masterhost,c-&gt;argv[1]-&gt;ptr)
1376              &amp;&amp; server.masterport == port) {
1377              serverLog(LL_NOTICE,&quot;REPLICAOF would result into synchronization with the master we are already connected with. No operation performed.&quot;);
1378              addReplySds(c,sdsnew(&quot;+OK Already connected to specified master\r\n&quot;));
1379              return;
1380          }
1381          replicationSetMaster(c-&gt;argv[1]-&gt;ptr, (int)port);                       WIN_PORT_FIX &amp;bsol;* cast (int) */
1382          sds client = catClientInfoString(sdsempty(),c);
1383          serverLog(LL_NOTICE,&quot;REPLICAOF %s:%d enabled (user request from &#x27;%s&#x27;)&quot;,
1384              server.masterhost, server.masterport, client);
1385          sdsfree(client);
1386      }
1387      addReply(c,shared.ok);
1388  }
1389  void roleCommand(client *c) {
1390      if (server.masterhost == NULL) {
1391          listIter li;
1392          listNode *ln;
1393          void *mbcount;
1394          int slaves = 0;
1395          addReplyMultiBulkLen(c,3);
1396          addReplyBulkCBuffer(c,&quot;master&quot;,6);
1397          addReplyLongLong(c,server.master_repl_offset);
1398          mbcount = addDeferredMultiBulkLength(c);
1399          listRewind(server.slaves,&amp;li);
1400          while((ln = listNext(&amp;li))) {
1401              client *slave = ln-&gt;value;
1402              char ip[NET_IP_STR_LEN], *slaveip = slave-&gt;slave_ip;
1403              if (slaveip[0] == &#x27;\0&#x27;) {
1404                  if (anetPeerToString(slave-&gt;fd,ip,sizeof(ip),NULL) == -1)
1405                      continue;
1406                  slaveip = ip;
1407              }
1408              if (slave-&gt;replstate != SLAVE_STATE_ONLINE) continue;
1409              addReplyMultiBulkLen(c,3);
1410              addReplyBulkCString(c,slaveip);
1411              addReplyBulkLongLong(c,slave-&gt;slave_listening_port);
1412              addReplyBulkLongLong(c,slave-&gt;repl_ack_off);
1413              slaves++;
1414          }
1415          setDeferredMultiBulkLength(c,mbcount,slaves);
1416      } else {
1417          char *slavestate = NULL;
1418          addReplyMultiBulkLen(c,5);
1419          addReplyBulkCBuffer(c,&quot;slave&quot;,5);
1420          addReplyBulkCString(c,server.masterhost);
1421          addReplyLongLong(c,server.masterport);
1422          if (slaveIsInHandshakeState()) {
1423              slavestate = &quot;handshake&quot;;
1424          } else {
1425              switch(server.repl_state) {
1426              case REPL_STATE_NONE: slavestate = &quot;none&quot;; break;
1427              case REPL_STATE_CONNECT: slavestate = &quot;connect&quot;; break;
1428              case REPL_STATE_CONNECTING: slavestate = &quot;connecting&quot;; break;
1429              case REPL_STATE_TRANSFER: slavestate = &quot;sync&quot;; break;
1430              case REPL_STATE_CONNECTED: slavestate = &quot;connected&quot;; break;
1431              default: slavestate = &quot;unknown&quot;; break;
1432              }
1433          }
1434          addReplyBulkCString(c,slavestate);
1435          addReplyLongLong(c,server.master ? server.master-&gt;reploff : -1);
1436      }
1437  }
1438  void replicationSendAck(void) {
1439      client *c = server.master;
1440      if (c != NULL) {
1441          c-&gt;flags |= CLIENT_MASTER_FORCE_REPLY;
1442          addReplyMultiBulkLen(c,3);
1443          addReplyBulkCString(c,&quot;REPLCONF&quot;);
1444          addReplyBulkCString(c,&quot;ACK&quot;);
1445          addReplyBulkLongLong(c,c-&gt;reploff);
1446          c-&gt;flags &amp;= ~CLIENT_MASTER_FORCE_REPLY;
1447      }
1448  }
1449  void replicationCacheMaster(client *c) {
1450      serverAssert(server.master != NULL &amp;&amp; server.cached_master == NULL);
1451      serverLog(LL_NOTICE,&quot;Caching the disconnected master state.&quot;);
1452      unlinkClient(c);
1453      sdsclear(server.master-&gt;querybuf);
1454      sdsclear(server.master-&gt;pending_querybuf);
1455      server.master-&gt;read_reploff = server.master-&gt;reploff;
1456      if (c-&gt;flags &amp; CLIENT_MULTI) discardTransaction(c);
1457      listEmpty(c-&gt;reply);
1458      c-&gt;sentlen = 0;
1459      c-&gt;reply_bytes = 0;
1460      c-&gt;bufpos = 0;
1461      resetClient(c);
1462      server.cached_master = server.master;
1463      if (c-&gt;peerid) {
1464          sdsfree(c-&gt;peerid);
1465          c-&gt;peerid = NULL;
1466      }
1467      replicationHandleMasterDisconnection();
1468  }
1469  void replicationCacheMasterUsingMyself(void) {
1470      server.master_initial_offset = server.master_repl_offset;
1471      replicationCreateMasterClient(-1,-1);
1472      memcpy(server.master-&gt;replid, server.replid, sizeof(server.replid));
1473      unlinkClient(server.master);
1474      server.cached_master = server.master;
1475      server.master = NULL;
1476      serverLog(LL_NOTICE,&quot;Before turning into a replica, using my master parameters to synthesize a cached master: I may be able to synchronize with the new master with just a partial transfer.&quot;);
1477  }
1478  void replicationDiscardCachedMaster(void) {
1479      if (server.cached_master == NULL) return;
1480      serverLog(LL_NOTICE,&quot;Discarding previously cached master state.&quot;);
1481      server.cached_master-&gt;flags &amp;= ~CLIENT_MASTER;
1482      freeClient(server.cached_master);
1483      server.cached_master = NULL;
1484  }
1485  void replicationResurrectCachedMaster(int newfd) {
1486      server.master = server.cached_master;
1487      server.cached_master = NULL;
1488      server.master-&gt;fd = newfd;
1489      server.master-&gt;flags &amp;= ~(CLIENT_CLOSE_AFTER_REPLY|CLIENT_CLOSE_ASAP);
1490      server.master-&gt;authenticated = 1;
1491      server.master-&gt;lastinteraction = server.unixtime;
1492      server.repl_state = REPL_STATE_CONNECTED;
1493      server.repl_down_since = 0;
1494      linkClient(server.master);
1495      if (aeCreateFileEvent(server.el, newfd, AE_READABLE,
1496                            readQueryFromClient, server.master)) {
1497          serverLog(LL_WARNING,&quot;Error resurrecting the cached master, impossible to add the readable handler: %s&quot;, IF_WIN32(wsa_strerror(errno),strerror(errno)));
1498          freeClientAsync(server.master); &amp;bsol;* Close ASAP. */
1499      }
1500      if (clientHasPendingReplies(server.master)) {
1501          if (aeCreateFileEvent(server.el, newfd, AE_WRITABLE,
1502                            sendReplyToClient, server.master)) {
1503              serverLog(LL_WARNING,&quot;Error resurrecting the cached master, impossible to add the writable handler: %s&quot;, IF_WIN32(wsa_strerror(errno),strerror(errno)));
1504              freeClientAsync(server.master); &amp;bsol;* Close ASAP. */
1505          }
1506      }
1507  }
1508  void refreshGoodSlavesCount(void) {
1509      listIter li;
1510      listNode *ln;
1511      int good = 0;
1512      if (!server.repl_min_slaves_to_write ||
1513          !server.repl_min_slaves_max_lag) return;
1514      listRewind(server.slaves,&amp;li);
1515      while((ln = listNext(&amp;li))) {
1516          client *slave = ln-&gt;value;
1517          time_t lag = server.unixtime - slave-&gt;repl_ack_time;
1518          if (slave-&gt;replstate == SLAVE_STATE_ONLINE &amp;&amp;
1519              lag &lt;= server.repl_min_slaves_max_lag) good++;
1520      }
1521      server.repl_good_slaves_count = good;
1522  }
1523  void replicationScriptCacheInit(void) {
1524      server.repl_scriptcache_size = 10000;
1525      server.repl_scriptcache_dict = dictCreate(&amp;replScriptCacheDictType,NULL);
1526      server.repl_scriptcache_fifo = listCreate();
1527  }
1528  void replicationScriptCacheFlush(void) {
1529      dictEmpty(server.repl_scriptcache_dict,NULL);
1530      listRelease(server.repl_scriptcache_fifo);
1531      server.repl_scriptcache_fifo = listCreate();
1532  }
1533  void replicationScriptCacheAdd(sds sha1) {
1534      int retval;
1535      sds key = sdsdup(sha1);
1536      if (listLength(server.repl_scriptcache_fifo) == server.repl_scriptcache_size)
1537      {
1538          listNode *ln = listLast(server.repl_scriptcache_fifo);
1539          sds oldest = listNodeValue(ln);
1540          retval = dictDelete(server.repl_scriptcache_dict,oldest);
1541          serverAssert(retval == DICT_OK);
1542          listDelNode(server.repl_scriptcache_fifo,ln);
1543      }
1544      retval = dictAdd(server.repl_scriptcache_dict,key,NULL);
1545      listAddNodeHead(server.repl_scriptcache_fifo,key);
1546      serverAssert(retval == DICT_OK);
1547  }
1548  int replicationScriptCacheExists(sds sha1) {
1549      return dictFind(server.repl_scriptcache_dict,sha1) != NULL;
1550  }
1551  void replicationRequestAckFromSlaves(void) {
1552      server.get_ack_from_slaves = 1;
1553  }
1554  int replicationCountAcksByOffset(PORT_LONGLONG offset) {
1555      listIter li;
1556      listNode *ln;
1557      int count = 0;
1558      listRewind(server.slaves,&amp;li);
1559      while((ln = listNext(&amp;li))) {
1560          client *slave = ln-&gt;value;
1561          if (slave-&gt;replstate != SLAVE_STATE_ONLINE) continue;
1562          if (slave-&gt;repl_ack_off &gt;= offset) count++;
1563      }
1564      return count;
1565  }
1566  void waitCommand(client *c) {
1567      mstime_t timeout;
1568      PORT_LONG numreplicas, ackreplicas;
1569      PORT_LONGLONG offset = c-&gt;woff;
1570      if (server.masterhost) {
1571          addReplyError(c,&quot;WAIT cannot be used with replica instances. Please also note that since Redis 4.0 if a replica is configured to be writable (which is not the default) writes to replicas are just local and are not propagated.&quot;);
1572          return;
1573      }
1574      if (getLongFromObjectOrReply(c,c-&gt;argv[1],&amp;numreplicas,NULL) != C_OK)
1575          return;
1576      if (getTimeoutFromObjectOrReply(c,c-&gt;argv[2],&amp;timeout,UNIT_MILLISECONDS)
1577          != C_OK) return;
1578      ackreplicas = replicationCountAcksByOffset(c-&gt;woff);
1579      if (ackreplicas &gt;= numreplicas || c-&gt;flags &amp; CLIENT_MULTI) {
1580          addReplyLongLong(c,ackreplicas);
1581          return;
1582      }
1583      c-&gt;bpop.timeout = timeout;
1584      c-&gt;bpop.reploffset = offset;
1585      c-&gt;bpop.numreplicas = (int) numreplicas;                                    WIN_PORT_FIX &amp;bsol;* cast (int) */
1586      listAddNodeTail(server.clients_waiting_acks,c);
1587      blockClient(c,BLOCKED_WAIT);
1588      replicationRequestAckFromSlaves();
1589  }
1590  void unblockClientWaitingReplicas(client *c) {
1591      listNode *ln = listSearchKey(server.clients_waiting_acks,c);
1592      serverAssert(ln != NULL);
1593      listDelNode(server.clients_waiting_acks,ln);
1594  }
1595  void processClientsWaitingReplicas(void) {
1596      PORT_LONGLONG last_offset = 0;
1597      int last_numreplicas = 0;
1598      listIter li;
1599      listNode *ln;
1600      listRewind(server.clients_waiting_acks,&amp;li);
1601      while((ln = listNext(&amp;li))) {
1602          client *c = ln-&gt;value;
1603          if (last_offset &amp;&amp; last_offset &gt; c-&gt;bpop.reploffset &amp;&amp;
1604                             last_numreplicas &gt; c-&gt;bpop.numreplicas)
1605          {
1606              unblockClient(c);
1607              addReplyLongLong(c,last_numreplicas);
1608          } else {
1609              int numreplicas = replicationCountAcksByOffset(c-&gt;bpop.reploffset);
1610              if (numreplicas &gt;= c-&gt;bpop.numreplicas) {
1611                  last_offset = c-&gt;bpop.reploffset;
1612                  last_numreplicas = numreplicas;
1613                  unblockClient(c);
1614                  addReplyLongLong(c,numreplicas);
1615              }
1616          }
1617      }
1618  }
1619  PORT_LONGLONG replicationGetSlaveOffset(void) {
1620      PORT_LONGLONG offset = 0;
1621      if (server.masterhost != NULL) {
1622          if (server.master) {
1623              offset = server.master-&gt;reploff;
1624          } else if (server.cached_master) {
1625              offset = server.cached_master-&gt;reploff;
1626          }
1627      }
1628      if (offset &lt; 0) offset = 0;
1629      return offset;
1630  }
1631  void replicationCron(void) {
1632      static PORT_LONGLONG replication_cron_loops = 0;
1633      if (server.masterhost &amp;&amp;
1634          (server.repl_state == REPL_STATE_CONNECTING ||
1635           slaveIsInHandshakeState()) &amp;&amp;
1636           (time(NULL)-server.repl_transfer_lastio) &gt; server.repl_timeout)
1637      {
1638          serverLog(LL_WARNING,&quot;Timeout connecting to the MASTER...&quot;);
1639          cancelReplicationHandshake();
1640      }
1641      if (server.masterhost &amp;&amp; server.repl_state == REPL_STATE_TRANSFER &amp;&amp;
1642          (time(NULL)-server.repl_transfer_lastio) &gt; server.repl_timeout)
1643      {
1644          serverLog(LL_WARNING,&quot;Timeout receiving bulk data from MASTER... If the problem persists try to set the &#x27;repl-timeout&#x27; parameter in redis.conf to a larger value.&quot;);
1645          cancelReplicationHandshake();
1646      }
1647      if (server.masterhost &amp;&amp; server.repl_state == REPL_STATE_CONNECTED &amp;&amp;
1648          (time(NULL)-server.master-&gt;lastinteraction) &gt; server.repl_timeout)
1649      {
1650          serverLog(LL_WARNING,&quot;MASTER timeout: no data nor PING received...&quot;);
1651          freeClient(server.master);
1652      }
1653      if (server.repl_state == REPL_STATE_CONNECT) {
1654          serverLog(LL_NOTICE,&quot;Connecting to MASTER %s:%d&quot;,
1655              server.masterhost, server.masterport);
1656          if (connectWithMaster() == C_OK) {
1657              serverLog(LL_NOTICE,&quot;MASTER &lt;-&gt; REPLICA sync started&quot;);
1658          }
1659      }
1660      if (server.masterhost &amp;&amp; server.master &amp;&amp;
1661          !(server.master-&gt;flags &amp; CLIENT_PRE_PSYNC))
1662          replicationSendAck();
1663      listIter li;
1664      listNode *ln;
1665      robj *ping_argv[1];
1666      if ((replication_cron_loops % server.repl_ping_slave_period) == 0 &amp;&amp;
1667          listLength(server.slaves))
1668      {
1669          int manual_failover_in_progress =
1670              server.cluster_enabled &amp;&amp;
1671              server.cluster-&gt;mf_end &amp;&amp;
1672              clientsArePaused();
1673          if (!manual_failover_in_progress) {
1674              ping_argv[0] = createStringObject(&quot;PING&quot;,4);
1675              replicationFeedSlaves(server.slaves, server.slaveseldb,
1676                  ping_argv, 1);
1677              decrRefCount(ping_argv[0]);
1678          }
1679      }
1680      listRewind(server.slaves,&amp;li);
1681      while((ln = listNext(&amp;li))) {
1682          client *slave = ln-&gt;value;
1683          int is_presync =
1684              (slave-&gt;replstate == SLAVE_STATE_WAIT_BGSAVE_START ||
1685              (slave-&gt;replstate == SLAVE_STATE_WAIT_BGSAVE_END &amp;&amp;
1686               server.rdb_child_type != RDB_CHILD_TYPE_SOCKET));
1687          if (is_presync) {
1688  #ifdef _WIN32
1689              if (WSIOCP_SocketSend(slave-&gt;fd, &quot;\n&quot;, 1, server.el,
1690                                    NULL, NULL, NULL) == -1) {
1691  #else
1692              if (write(slave-&gt;fd, &quot;\n&quot;, 1) == -1) {
1693  #endif
1694              }
1695          }
1696      }
1697      if (listLength(server.slaves)) {
1698          listIter li;
1699          listNode *ln;
1700          listRewind(server.slaves,&amp;li);
1701          while((ln = listNext(&amp;li))) {
1702              client *slave = ln-&gt;value;
1703              if (slave-&gt;replstate != SLAVE_STATE_ONLINE) continue;
1704              if (slave-&gt;flags &amp; CLIENT_PRE_PSYNC) continue;
1705              if ((server.unixtime - slave-&gt;repl_ack_time) &gt; server.repl_timeout)
1706              {
1707                  serverLog(LL_WARNING, &quot;Disconnecting timedout replica: %s&quot;,
1708                      replicationGetSlaveName(slave));
1709                  freeClient(slave);
1710              }
1711          }
1712      }
1713      if (listLength(server.slaves) == 0 &amp;&amp; server.repl_backlog_time_limit &amp;&amp;
1714          server.repl_backlog &amp;&amp; server.masterhost == NULL)
1715      {
1716          time_t idle = server.unixtime - server.repl_no_slaves_since;
1717          if (idle &gt; server.repl_backlog_time_limit) {
1718              changeReplicationId();
1719              clearReplicationId2();
1720              freeReplicationBacklog();
1721              serverLog(LL_NOTICE,
1722                  &quot;Replication backlog freed after %d seconds &quot;
1723                  &quot;without connected replicas.&quot;,
1724                  (int) server.repl_backlog_time_limit);
1725          }
1726      }
1727      if (listLength(server.slaves) == 0 &amp;&amp;
1728          server.aof_state == AOF_OFF &amp;&amp;
1729          listLength(server.repl_scriptcache_fifo) != 0)
1730      {
1731          replicationScriptCacheFlush();
1732      }
1733      if (server.rdb_child_pid == -1 &amp;&amp; server.aof_child_pid == -1) {
1734          time_t idle, max_idle = 0;
1735          int slaves_waiting = 0;
1736          int mincapa = -1;
1737          listNode *ln;
1738          listIter li;
1739          listRewind(server.slaves,&amp;li);
1740          while((ln = listNext(&amp;li))) {
1741              client *slave = ln-&gt;value;
1742              if (slave-&gt;replstate == SLAVE_STATE_WAIT_BGSAVE_START) {
1743                  idle = server.unixtime - slave-&gt;lastinteraction;
1744                  if (idle &gt; max_idle) max_idle = idle;
1745                  slaves_waiting++;
1746                  mincapa = (mincapa == -1) ? slave-&gt;slave_capa :
1747                                              (mincapa &amp; slave-&gt;slave_capa);
1748              }
1749          }
1750          if (slaves_waiting &amp;&amp;
1751              (!server.repl_diskless_sync ||
1752               max_idle &gt; server.repl_diskless_sync_delay))
1753          {
1754              startBgsaveForReplication(mincapa);
1755          }
1756      }
1757      refreshGoodSlavesCount();
1758      replication_cron_loops++; &amp;bsol;* Incremented with frequency 1 HZ. */
1759  }
</code></pre>
        </div>
        <div class="column">
            <h3>redis-MDEwOlJlcG9zaXRvcnkxMDgxMTA3MDY=-flat-replication.c</h3>
            <pre><code>1  #ifdef _WIN32
2  #include &quot;Win32_Interop/Win32_Portability.h&quot;
3  #include &quot;Win32_Interop/Win32_FDAPI.h&quot;
4  #include &quot;Win32_Interop/Win32_ThreadControl.h&quot;
5  #include &quot;Win32_Interop/Win32_QFork.h&quot;
6  #include &quot;Win32_Interop/win32_types.h&quot;
7  #include &quot;Win32_Interop/Win32_Time.h&quot;
8  #include &quot;Win32_Interop/Win32_Error.h&quot;
9  #endif
10  #include &quot;server.h&quot;
11  #include &quot;cluster.h&quot;
12  POSIX_ONLY(#include &lt;sys/time.h&gt;)
13  POSIX_ONLY(#include &lt;unistd.h&gt;)
14  #include &lt;fcntl.h&gt;
15  POSIX_ONLY(#include &lt;sys/socket.h&gt;)
16  #include &lt;sys/stat.h&gt;
17  void replicationDiscardCachedMaster(void);
18  void replicationResurrectCachedMaster(int newfd);
19  void replicationSendAck(void);
20  void putSlaveOnline(client *slave);
21  int cancelReplicationHandshake(void);
22  char *replicationGetSlaveName(client *c) {
23      static char buf[NET_PEER_ID_LEN];
24      char ip[NET_IP_STR_LEN];
25      ip[0] = &#x27;\0&#x27;;
26      buf[0] = &#x27;\0&#x27;;
27      if (c-&gt;slave_ip[0] != &#x27;\0&#x27; ||
28          anetPeerToString(c-&gt;fd,ip,sizeof(ip),NULL) != -1)
29      {
30          if (c-&gt;slave_ip[0] != &#x27;\0&#x27;) memcpy(ip,c-&gt;slave_ip,sizeof(c-&gt;slave_ip));
31          if (c-&gt;slave_listening_port)
32              anetFormatAddr(buf,sizeof(buf),ip,c-&gt;slave_listening_port);
33          else
34              snprintf(buf,sizeof(buf),&quot;%s:&lt;unknown-replica-port&gt;&quot;,ip);
35      } else {
36          snprintf(buf,sizeof(buf),&quot;client id #%llu&quot;,
37              (PORT_ULONGLONG) c-&gt;id);
38      }
39      return buf;
40  }
41  void createReplicationBacklog(void) {
42      serverAssert(server.repl_backlog == NULL);
43      server.repl_backlog = zmalloc(server.repl_backlog_size);
44      server.repl_backlog_histlen = 0;
45      server.repl_backlog_idx = 0;
46      server.repl_backlog_off = server.master_repl_offset+1;
47  }
48  void resizeReplicationBacklog(PORT_LONGLONG newsize) {
49      if (newsize &lt; CONFIG_REPL_BACKLOG_MIN_SIZE)
50          newsize = CONFIG_REPL_BACKLOG_MIN_SIZE;
51      if (server.repl_backlog_size == newsize) return;
52      server.repl_backlog_size = newsize;
53      if (server.repl_backlog != NULL) {
54          zfree(server.repl_backlog);
55          server.repl_backlog = zmalloc(server.repl_backlog_size);
56          server.repl_backlog_histlen = 0;
57          server.repl_backlog_idx = 0;
58          server.repl_backlog_off = server.master_repl_offset+1;
59      }
60  }
61  void freeReplicationBacklog(void) {
62      serverAssert(listLength(server.slaves) == 0);
63      zfree(server.repl_backlog);
64      server.repl_backlog = NULL;
65  }
66  void feedReplicationBacklog(void *ptr, size_t len) {
67      unsigned char *p = ptr;
68      server.master_repl_offset += len;
69      while(len) {
70          size_t thislen = server.repl_backlog_size - server.repl_backlog_idx;
71          if (thislen &gt; len) thislen = len;
72          memcpy(server.repl_backlog+server.repl_backlog_idx,p,thislen);
73          server.repl_backlog_idx += thislen;
74          if (server.repl_backlog_idx == server.repl_backlog_size)
75              server.repl_backlog_idx = 0;
76          len -= thislen;
77          p += thislen;
78          server.repl_backlog_histlen += thislen;
79      }
80      if (server.repl_backlog_histlen &gt; server.repl_backlog_size)
81          server.repl_backlog_histlen = server.repl_backlog_size;
82      server.repl_backlog_off = server.master_repl_offset -
83                                server.repl_backlog_histlen + 1;
84  }
85  void feedReplicationBacklogWithObject(robj *o) {
86      char llstr[LONG_STR_SIZE];
87      void *p;
88      size_t len;
89      if (o-&gt;encoding == OBJ_ENCODING_INT) {
90          len = ll2string(llstr,sizeof(llstr),(PORT_LONG)o-&gt;ptr);
91          p = llstr;
92      } else {
93          len = sdslen(o-&gt;ptr);
94          p = o-&gt;ptr;
95      }
96      feedReplicationBacklog(p,len);
97  }
98  void replicationFeedSlaves(list *slaves, int dictid, robj **argv, int argc) {
99      listNode *ln;
100      listIter li;
101      int j, len;
102      char llstr[LONG_STR_SIZE];
103      if (server.masterhost != NULL) return;
104      if (server.repl_backlog == NULL &amp;&amp; listLength(slaves) == 0) return;
105      serverAssert(!(listLength(slaves) != 0 &amp;&amp; server.repl_backlog == NULL));
106      if (server.slaveseldb != dictid) {
107          robj *selectcmd;
108          if (dictid &gt;= 0 &amp;&amp; dictid &lt; PROTO_SHARED_SELECT_CMDS) {
109              selectcmd = shared.select[dictid];
110          } else {
111              int dictid_len;
112              dictid_len = ll2string(llstr,sizeof(llstr),dictid);
113              selectcmd = createObject(OBJ_STRING,
114                  sdscatprintf(sdsempty(),
115                  &quot;*2\r\n$6\r\nSELECT\r\n$%d\r\n%s\r\n&quot;,
116                  dictid_len, llstr));
117          }
118          if (server.repl_backlog) feedReplicationBacklogWithObject(selectcmd);
119          listRewind(slaves,&amp;li);
120          while((ln = listNext(&amp;li))) {
121              client *slave = ln-&gt;value;
122              if (slave-&gt;replstate == SLAVE_STATE_WAIT_BGSAVE_START) continue;
123              addReply(slave,selectcmd);
124          }
125          if (dictid &lt; 0 || dictid &gt;= PROTO_SHARED_SELECT_CMDS)
126              decrRefCount(selectcmd);
127      }
128      server.slaveseldb = dictid;
129      if (server.repl_backlog) {
130          char aux[LONG_STR_SIZE+3];
131          aux[0] = &#x27;*&#x27;;
132          len = ll2string(aux+1,sizeof(aux)-1,argc);
133          aux[len+1] = &#x27;\r&#x27;;
134          aux[len+2] = &#x27;\n&#x27;;
135          feedReplicationBacklog(aux,(size_t)len+3);  WIN_PORT_FIX &amp;bsol;* cast (size_t) */
136          for (j = 0; j &lt; argc; j++) {
137              PORT_LONG objlen = (PORT_LONG) stringObjectLen(argv[j]);            WIN_PORT_FIX &amp;bsol;* cast (PORT_LONG) */
138              aux[0] = &#x27;$&#x27;;
139              len = ll2string(aux+1,sizeof(aux)-1,objlen);
140              aux[len+1] = &#x27;\r&#x27;;
141              aux[len+2] = &#x27;\n&#x27;;
142              feedReplicationBacklog(aux,(size_t)len+3);  WIN_PORT_FIX &amp;bsol;* cast (size_t) */
143              feedReplicationBacklogWithObject(argv[j]);
144              feedReplicationBacklog(aux+len+1,2);
145          }
146      }
147      listRewind(slaves,&amp;li);
148      while((ln = listNext(&amp;li))) {
149          client *slave = ln-&gt;value;
150          if (slave-&gt;replstate == SLAVE_STATE_WAIT_BGSAVE_START) continue;
151          addReplyMultiBulkLen(slave,argc);
152          for (j = 0; j &lt; argc; j++)
153              addReplyBulk(slave,argv[j]);
154      }
155  }
156  #include &lt;ctype.h&gt;
157  void replicationFeedSlavesFromMasterStream(list *slaves, char *buf, size_t buflen) {
158      listNode *ln;
159      listIter li;
160      if (0) {
161          printf(&quot;%Iu:&quot;,buflen);                                        WIN_PORT_FIX &amp;bsol;* %zu -&gt; %Iu */
162          for (size_t j = 0; j &lt; buflen; j++) {
163              printf(&quot;%c&quot;, isprint(buf[j]) ? buf[j] : &#x27;.&#x27;);
164          }
165          printf(&quot;\n&quot;);
166      }
167      if (server.repl_backlog) feedReplicationBacklog(buf,buflen);
168      listRewind(slaves,&amp;li);
169      while((ln = listNext(&amp;li))) {
170          client *slave = ln-&gt;value;
171          if (slave-&gt;replstate == SLAVE_STATE_WAIT_BGSAVE_START) continue;
172          addReplyString(slave,buf,buflen);
173      }
174  }
175  void replicationFeedMonitors(client *c, list *monitors, int dictid, robj **argv, int argc) {
176      listNode *ln;
177      listIter li;
178      int j;
179      sds cmdrepr = sdsnew(&quot;+&quot;);
180      robj *cmdobj;
181      struct timeval tv;
182      gettimeofday(&amp;tv,NULL);
183      cmdrepr = sdscatprintf(cmdrepr,&quot;%Id.%06Id &quot;,(PORT_LONG)tv.tv_sec,(PORT_LONG)tv.tv_usec);           WIN_PORT_FIX &amp;bsol;* %ld -&gt; %Id */
184      if (c-&gt;flags &amp; CLIENT_LUA) {
185          cmdrepr = sdscatprintf(cmdrepr,&quot;[%d lua] &quot;,dictid);
186      } else if (c-&gt;flags &amp; CLIENT_UNIX_SOCKET) {
187          cmdrepr = sdscatprintf(cmdrepr,&quot;[%d unix:%s] &quot;,dictid,server.unixsocket);
188      } else {
189          cmdrepr = sdscatprintf(cmdrepr,&quot;[%d %s] &quot;,dictid,getClientPeerId(c));
190      }
191      for (j = 0; j &lt; argc; j++) {
192          if (argv[j]-&gt;encoding == OBJ_ENCODING_INT) {
193              cmdrepr = sdscatprintf(cmdrepr, &quot;\&quot;%Id\&quot;&quot;, (PORT_LONG) argv[j]-&gt;ptr);   WIN_PORT_FIX &amp;bsol;* %ld -&gt; %Id */
194          } else {
195              cmdrepr = sdscatrepr(cmdrepr,(char*)argv[j]-&gt;ptr,
196                          sdslen(argv[j]-&gt;ptr));
197          }
198          if (j != argc-1)
199              cmdrepr = sdscatlen(cmdrepr,&quot; &quot;,1);
200      }
201      cmdrepr = sdscatlen(cmdrepr,&quot;\r\n&quot;,2);
202      cmdobj = createObject(OBJ_STRING,cmdrepr);
203      listRewind(monitors,&amp;li);
204      while((ln = listNext(&amp;li))) {
205          client *monitor = ln-&gt;value;
206          addReply(monitor,cmdobj);
207      }
208      decrRefCount(cmdobj);
209  }
210  PORT_LONGLONG addReplyReplicationBacklog(client *c, PORT_LONGLONG offset) {
211      PORT_LONGLONG j, skip, len;
212      serverLog(LL_DEBUG, &quot;[PSYNC] Replica request offset: %lld&quot;, offset);
213      if (server.repl_backlog_histlen == 0) {
214          serverLog(LL_DEBUG, &quot;[PSYNC] Backlog history len is zero&quot;);
215          return 0;
216      }
217      serverLog(LL_DEBUG, &quot;[PSYNC] Backlog size: %lld&quot;,
218               server.repl_backlog_size);
219      serverLog(LL_DEBUG, &quot;[PSYNC] First byte: %lld&quot;,
220               server.repl_backlog_off);
221      serverLog(LL_DEBUG, &quot;[PSYNC] History len: %lld&quot;,
222               server.repl_backlog_histlen);
223      serverLog(LL_DEBUG, &quot;[PSYNC] Current index: %lld&quot;,
224               server.repl_backlog_idx);
225      skip = offset - server.repl_backlog_off;
226      serverLog(LL_DEBUG, &quot;[PSYNC] Skipping: %lld&quot;, skip);
227      j = (server.repl_backlog_idx +
228          (server.repl_backlog_size-server.repl_backlog_histlen)) %
229          server.repl_backlog_size;
230      serverLog(LL_DEBUG, &quot;[PSYNC] Index of first byte: %lld&quot;, j);
231      j = (j + skip) % server.repl_backlog_size;
232      len = server.repl_backlog_histlen - skip;
233      serverLog(LL_DEBUG, &quot;[PSYNC] Reply total length: %lld&quot;, len);
234      while(len) {
235          PORT_LONGLONG thislen =
236              ((server.repl_backlog_size - j) &lt; len) ?
237              (server.repl_backlog_size - j) : len;
238          serverLog(LL_DEBUG, &quot;[PSYNC] addReply() length: %lld&quot;, thislen);
239          addReplySds(c,sdsnewlen(server.repl_backlog + j, thislen));
240          len -= thislen;
241          j = 0;
242      }
243      return server.repl_backlog_histlen - skip;
244  }
245  PORT_LONGLONG getPsyncInitialOffset(void) {
246      return server.master_repl_offset;
247  }
248  int replicationSetupSlaveForFullResync(client *slave, PORT_LONGLONG offset) {
249      char buf[128];
250      int buflen;
251      slave-&gt;psync_initial_offset = offset;
252      slave-&gt;replstate = SLAVE_STATE_WAIT_BGSAVE_END;
253      server.slaveseldb = -1;
254      if (!(slave-&gt;flags &amp; CLIENT_PRE_PSYNC)) {
255          buflen = snprintf(buf,sizeof(buf),&quot;+FULLRESYNC %s %lld\r\n&quot;,
256                            server.replid,offset);
257          if (write(slave-&gt;fd,buf,buflen) != buflen) {
258              freeClientAsync(slave);
259              return C_ERR;
260          }
261      }
262      return C_OK;
263  }
264  int masterTryPartialResynchronization(client *c) {
265      PORT_LONGLONG psync_offset, psync_len;
266      char *master_replid = c-&gt;argv[1]-&gt;ptr;
267      char buf[128];
268      int buflen;
269      if (getLongLongFromObjectOrReply(c,c-&gt;argv[2],&amp;psync_offset,NULL) !=
270         C_OK) goto need_full_resync;
271      if (strcasecmp(master_replid, server.replid) &amp;&amp;
272          (strcasecmp(master_replid, server.replid2) ||
273           psync_offset &gt; server.second_replid_offset))
274      {
275          if (master_replid[0] != &#x27;?&#x27;) {
276              if (strcasecmp(master_replid, server.replid) &amp;&amp;
277                  strcasecmp(master_replid, server.replid2))
278              {
279                  serverLog(LL_NOTICE,&quot;Partial resynchronization not accepted: &quot;
280                      &quot;Replication ID mismatch (Replica asked for &#x27;%s&#x27;, my &quot;
281                      &quot;replication IDs are &#x27;%s&#x27; and &#x27;%s&#x27;)&quot;,
282                      master_replid, server.replid, server.replid2);
283              } else {
284                  serverLog(LL_NOTICE,&quot;Partial resynchronization not accepted: &quot;
285                      &quot;Requested offset for second ID was %lld, but I can reply &quot;
286                      &quot;up to %lld&quot;, psync_offset, server.second_replid_offset);
287              }
288          } else {
289              serverLog(LL_NOTICE,&quot;Full resync requested by replica %s&quot;,
290                  replicationGetSlaveName(c));
291          }
292          goto need_full_resync;
293      }
294      if (!server.repl_backlog ||
295          psync_offset &lt; server.repl_backlog_off ||
296          psync_offset &gt; (server.repl_backlog_off + server.repl_backlog_histlen))
297      {
298          serverLog(LL_NOTICE,
299              &quot;Unable to partial resync with replica %s for lack of backlog (Replica request was: %lld).&quot;, replicationGetSlaveName(c), psync_offset);
300          if (psync_offset &gt; server.master_repl_offset) {
301              serverLog(LL_WARNING,
302                  &quot;Warning: replica %s tried to PSYNC with an offset that is greater than the master replication offset.&quot;, replicationGetSlaveName(c));
303          }
304          goto need_full_resync;
305      }
306      c-&gt;flags |= CLIENT_SLAVE;
307      c-&gt;replstate = SLAVE_STATE_ONLINE;
308      c-&gt;repl_ack_time = server.unixtime;
309      c-&gt;repl_put_online_on_ack = 0;
310      listAddNodeTail(server.slaves,c);
311      if (c-&gt;slave_capa &amp; SLAVE_CAPA_PSYNC2) {
312          buflen = snprintf(buf,sizeof(buf),&quot;+CONTINUE %s\r\n&quot;, server.replid);
313      } else {
314          buflen = snprintf(buf,sizeof(buf),&quot;+CONTINUE\r\n&quot;);
315      }
316      if (write(c-&gt;fd,buf,buflen) != buflen) {
317          freeClientAsync(c);
318          return C_OK;
319      }
320      psync_len = addReplyReplicationBacklog(c,psync_offset);
321      serverLog(LL_NOTICE,
322          &quot;Partial resynchronization request from %s accepted. Sending %lld bytes of backlog starting from offset %lld.&quot;,
323              replicationGetSlaveName(c),
324              psync_len, psync_offset);
325      refreshGoodSlavesCount();
326      return C_OK; &amp;bsol;* The caller can return, no full resync needed. */
327  need_full_resync:
328      return C_ERR;
329  }
330  int startBgsaveForReplication(int mincapa) {
331      int retval;
332      int socket_target = server.repl_diskless_sync &amp;&amp; (mincapa &amp; SLAVE_CAPA_EOF);
333      listIter li;
334      listNode *ln;
335      serverLog(LL_NOTICE,&quot;Starting BGSAVE for SYNC with target: %s&quot;,
336          socket_target ? &quot;replicas sockets&quot; : &quot;disk&quot;);
337      rdbSaveInfo rsi, *rsiptr;
338      rsiptr = rdbPopulateSaveInfo(&amp;rsi);
339      if (rsiptr) {
340          if (socket_target)
341              retval = rdbSaveToSlavesSockets(rsiptr);
342          else
343              retval = rdbSaveBackground(server.rdb_filename,rsiptr);
344      } else {
345          serverLog(LL_WARNING,&quot;BGSAVE for replication: replication information not available, can&#x27;t generate the RDB file right now. Try later.&quot;);
346          retval = C_ERR;
347      }
348      if (retval == C_ERR) {
349          serverLog(LL_WARNING,&quot;BGSAVE for replication failed&quot;);
350          listRewind(server.slaves,&amp;li);
351          while((ln = listNext(&amp;li))) {
352              client *slave = ln-&gt;value;
353              if (slave-&gt;replstate == SLAVE_STATE_WAIT_BGSAVE_START) {
354                  slave-&gt;replstate = REPL_STATE_NONE;
355                  slave-&gt;flags &amp;= ~CLIENT_SLAVE;
356                  listDelNode(server.slaves,ln);
357                  addReplyError(slave,
358                      &quot;BGSAVE failed, replication can&#x27;t continue&quot;);
359                  slave-&gt;flags |= CLIENT_CLOSE_AFTER_REPLY;
360              }
361          }
362          return retval;
363      }
364      if (!socket_target) {
365          listRewind(server.slaves,&amp;li);
366          while((ln = listNext(&amp;li))) {
367              client *slave = ln-&gt;value;
368              if (slave-&gt;replstate == SLAVE_STATE_WAIT_BGSAVE_START) {
369                      replicationSetupSlaveForFullResync(slave,
370                              getPsyncInitialOffset());
371              }
372          }
373      }
374      if (retval == C_OK) replicationScriptCacheFlush();
375      return retval;
376  }
377  void syncCommand(client *c) {
378      if (c-&gt;flags &amp; CLIENT_SLAVE) return;
379      if (server.masterhost &amp;&amp; server.repl_state != REPL_STATE_CONNECTED) {
380          addReplySds(c,sdsnew(&quot;-NOMASTERLINK Can&#x27;t SYNC while not connected with my master\r\n&quot;));
381          return;
382      }
383      if (clientHasPendingReplies(c)) {
384          addReplyError(c,&quot;SYNC and PSYNC are invalid with pending output&quot;);
385          return;
386      }
387      serverLog(LL_NOTICE,&quot;Replica %s asks for synchronization&quot;,
388          replicationGetSlaveName(c));
389      if (!strcasecmp(c-&gt;argv[0]-&gt;ptr,&quot;psync&quot;)) {
390          if (masterTryPartialResynchronization(c) == C_OK) {
391              server.stat_sync_partial_ok++;
392              return; &amp;bsol;* No full resync needed, return. */
393          } else {
394              char *master_replid = c-&gt;argv[1]-&gt;ptr;
395              if (master_replid[0] != &#x27;?&#x27;) server.stat_sync_partial_err++;
396          }
397      } else {
398          c-&gt;flags |= CLIENT_PRE_PSYNC;
399      }
400      server.stat_sync_full++;
401      c-&gt;replstate = SLAVE_STATE_WAIT_BGSAVE_START;
402      if (server.repl_disable_tcp_nodelay)
403          anetDisableTcpNoDelay(NULL, c-&gt;fd); &amp;bsol;* Non critical if it fails. */
404      c-&gt;repldbfd = -1;
405      c-&gt;flags |= CLIENT_SLAVE;
406      listAddNodeTail(server.slaves,c);
407      if (listLength(server.slaves) == 1 &amp;&amp; server.repl_backlog == NULL) {
408          changeReplicationId();
409          clearReplicationId2();
410          createReplicationBacklog();
411      }
412      if (server.rdb_child_pid != -1 &amp;&amp;
413          server.rdb_child_type == RDB_CHILD_TYPE_DISK)
414      {
415          client *slave;
416          listNode *ln;
417          listIter li;
418          listRewind(server.slaves,&amp;li);
419          while((ln = listNext(&amp;li))) {
420              slave = ln-&gt;value;
421              if (slave-&gt;replstate == SLAVE_STATE_WAIT_BGSAVE_END) break;
422          }
423          if (ln &amp;&amp; ((c-&gt;slave_capa &amp; slave-&gt;slave_capa) == slave-&gt;slave_capa)) {
424              copyClientOutputBuffer(c,slave);
425              replicationSetupSlaveForFullResync(c,slave-&gt;psync_initial_offset);
426              serverLog(LL_NOTICE,&quot;Waiting for end of BGSAVE for SYNC&quot;);
427          } else {
428              serverLog(LL_NOTICE,&quot;Can&#x27;t attach the replica to the current BGSAVE. Waiting for next BGSAVE for SYNC&quot;);
429          }
430      } else if (server.rdb_child_pid != -1 &amp;&amp;
431                 server.rdb_child_type == RDB_CHILD_TYPE_SOCKET)
432      {
433          serverLog(LL_NOTICE,&quot;Current BGSAVE has socket target. Waiting for next BGSAVE for SYNC&quot;);
434      } else {
435          if (server.repl_diskless_sync &amp;&amp; (c-&gt;slave_capa &amp; SLAVE_CAPA_EOF)) {
436              if (server.repl_diskless_sync_delay)
437                  serverLog(LL_NOTICE,&quot;Delay next BGSAVE for diskless SYNC&quot;);
438          } else {
439              if (server.aof_child_pid == -1) {
440                  startBgsaveForReplication(c-&gt;slave_capa);
441              } else {
442                  serverLog(LL_NOTICE,
443                      &quot;No BGSAVE in progress, but an AOF rewrite is active. &quot;
444                      &quot;BGSAVE for replication delayed&quot;);
445              }
446          }
447      }
448      return;
449  }
450  void replconfCommand(client *c) {
451      int j;
452      if ((c-&gt;argc % 2) == 0) {
453          addReply(c,shared.syntaxerr);
454          return;
455      }
456      for (j = 1; j &lt; c-&gt;argc; j+=2) {
457          if (!strcasecmp(c-&gt;argv[j]-&gt;ptr,&quot;listening-port&quot;)) {
458              PORT_LONG port;
459              if ((getLongFromObjectOrReply(c,c-&gt;argv[j+1],
460                      &amp;port,NULL) != C_OK))
461                  return;
462              c-&gt;slave_listening_port = (int) port;                               WIN_PORT_FIX &amp;bsol;* cast (int) */
463          } else if (!strcasecmp(c-&gt;argv[j]-&gt;ptr,&quot;ip-address&quot;)) {
464              sds ip = c-&gt;argv[j+1]-&gt;ptr;
465              if (sdslen(ip) &lt; sizeof(c-&gt;slave_ip)) {
466                  memcpy(c-&gt;slave_ip,ip,sdslen(ip)+1);
467              } else {
468                  addReplyErrorFormat(c,&quot;REPLCONF ip-address provided by &quot;
469                      &quot;replica instance is too long: %zd bytes&quot;, sdslen(ip));
470                  return;
471              }
472          } else if (!strcasecmp(c-&gt;argv[j]-&gt;ptr,&quot;capa&quot;)) {
473              if (!strcasecmp(c-&gt;argv[j+1]-&gt;ptr,&quot;eof&quot;))
474                  c-&gt;slave_capa |= SLAVE_CAPA_EOF;
475              else if (!strcasecmp(c-&gt;argv[j+1]-&gt;ptr,&quot;psync2&quot;))
476                  c-&gt;slave_capa |= SLAVE_CAPA_PSYNC2;
477          } else if (!strcasecmp(c-&gt;argv[j]-&gt;ptr,&quot;ack&quot;)) {
478              PORT_LONGLONG offset;
479              if (!(c-&gt;flags &amp; CLIENT_SLAVE)) return;
480              if ((getLongLongFromObject(c-&gt;argv[j+1], &amp;offset) != C_OK))
481                  return;
482              if (offset &gt; c-&gt;repl_ack_off)
483                  c-&gt;repl_ack_off = offset;
484              c-&gt;repl_ack_time = server.unixtime;
485              if (c-&gt;repl_put_online_on_ack &amp;&amp; c-&gt;replstate == SLAVE_STATE_ONLINE)
486                  putSlaveOnline(c);
487              return;
488          } else if (!strcasecmp(c-&gt;argv[j]-&gt;ptr,&quot;getack&quot;)) {
489              if (server.masterhost &amp;&amp; server.master) replicationSendAck();
490              return;
491          } else {
492              addReplyErrorFormat(c,&quot;Unrecognized REPLCONF option: %s&quot;,
493                  (char*)c-&gt;argv[j]-&gt;ptr);
494              return;
495          }
496      }
497      addReply(c,shared.ok);
498  }
499  void putSlaveOnline(client *slave) {
500      slave-&gt;replstate = SLAVE_STATE_ONLINE;
501      slave-&gt;repl_put_online_on_ack = 0;
502      slave-&gt;repl_ack_time = server.unixtime; &amp;bsol;* Prevent false timeout. */
503      if (aeCreateFileEvent(server.el, slave-&gt;fd, AE_WRITABLE,
504          sendReplyToClient, slave) == AE_ERR) {
505          serverLog(LL_WARNING,&quot;Unable to register writable event for replica bulk transfer: %s&quot;, IF_WIN32(wsa_strerror(errno),strerror(errno)));
506          freeClient(slave);
507          return;
508      }
509      refreshGoodSlavesCount();
510      serverLog(LL_NOTICE,&quot;Synchronization with replica %s succeeded&quot;,
511          replicationGetSlaveName(slave));
512  }
513  #ifdef _WIN32
514  void sendBulkToSlaveLenDone(aeEventLoop *el, int fd, void *privdata, int written) {
515      WSIOCP_Request *req = (WSIOCP_Request *) privdata;
516      UNUSED(el);
517      UNUSED(fd);
518      sdsfree((sds) req-&gt;buf);
519  }
520  void sendBulkToSlaveDataDone(aeEventLoop *el, int fd, void *privdata, int nwritten) {
521      WSIOCP_Request *req = (WSIOCP_Request *) privdata;
522      client *slave = (client *) req-&gt;client;
523      UNUSED(el);
524      UNUSED(fd);
525      zfree(req-&gt;data);
526      slave-&gt;repldboff += nwritten;
527      if (slave-&gt;repldboff == slave-&gt;repldbsize) {
528          close(slave-&gt;repldbfd);
529          DeleteFileA(slave-&gt;replFileCopy);
530          memset(slave-&gt;replFileCopy, 0, MAX_PATH);
531          slave-&gt;repldbfd = -1;
532          aeDeleteFileEvent(server.el, slave-&gt;fd, AE_WRITABLE);
533          putSlaveOnline(slave);
534      }
535  }
536  void sendBulkToSlave(aeEventLoop *el, int fd, void *privdata, int mask) {
537      client *slave = privdata;
538      UNUSED(el);
539      UNUSED(mask);
540      char *buf;
541      ssize_t result, buflen;
542      if (slave-&gt;repldboff == 0) {
543          sds bulkcount;
544          bulkcount = sdscatprintf(sdsempty(),&quot;$%lld\r\n&quot;,(PORT_ULONGLONG)
545              slave-&gt;repldbsize);
546          result = WSIOCP_SocketSend(fd, bulkcount, (int) sdslen(bulkcount), el,
547                                     slave, bulkcount, sendBulkToSlaveLenDone);
548          if (result == SOCKET_ERROR &amp;&amp; errno != WSA_IO_PENDING) {
549              sdsfree(bulkcount);
550              freeClient(slave);
551              return;
552          }
553      }
554      lseek64(slave-&gt;repldbfd,slave-&gt;repldboff,SEEK_SET);
555      buf = (char *)zmalloc(PROTO_IOBUF_LEN);
556      buflen = read(slave-&gt;repldbfd,buf,PROTO_IOBUF_LEN);
557      if (buflen &lt;= 0) {
558          serverLog(LL_WARNING,&quot;Read error sending DB to slave: %s&quot;,
559              (buflen == 0) ? &quot;premature EOF&quot; : IF_WIN32(wsa_strerror(errno),strerror(errno)));
560          freeClient(slave);
561          return;
562      }
563      result = WSIOCP_SocketSend(fd, buf, (int) buflen, el, slave, buf,
564                                 sendBulkToSlaveDataDone);
565      if (result == SOCKET_ERROR &amp;&amp; errno != WSA_IO_PENDING) {
566          serverLog(LL_VERBOSE,&quot;Write error sending DB to slave: %s&quot;,
567              IF_WIN32(wsa_strerror(errno),strerror(errno)));
568          freeClient(slave);
569          return;
570      }
571  }
572  #else
573  void sendBulkToSlave(aeEventLoop *el, int fd, void *privdata, int mask) {
574      client *slave = privdata;
575      UNUSED(el);
576      UNUSED(mask);
577      char buf[PROTO_IOBUF_LEN];
578      ssize_t nwritten, buflen;
579      if (slave-&gt;replpreamble) {
580          nwritten = write(fd,slave-&gt;replpreamble,sdslen(slave-&gt;replpreamble));
581          if (nwritten == -1) {
582              serverLog(LL_VERBOSE,&quot;Write error sending RDB preamble to replica: %s&quot;,
583                  strerror(errno));
584              freeClient(slave);
585              return;
586          }
587          server.stat_net_output_bytes += nwritten;
588          sdsrange(slave-&gt;replpreamble,nwritten,-1);
589          if (sdslen(slave-&gt;replpreamble) == 0) {
590              sdsfree(slave-&gt;replpreamble);
591              slave-&gt;replpreamble = NULL;
592          } else {
593              return;
594          }
595      }
596      lseek(slave-&gt;repldbfd,slave-&gt;repldboff,SEEK_SET);
597      buflen = read(slave-&gt;repldbfd,buf,PROTO_IOBUF_LEN);
598      if (buflen &lt;= 0) {
599          serverLog(LL_WARNING,&quot;Read error sending DB to replica: %s&quot;,
600              (buflen == 0) ? &quot;premature EOF&quot; : strerror(errno));
601          freeClient(slave);
602          return;
603      }
604      if ((nwritten = write(fd,buf,buflen)) == -1) {
605          if (errno != EAGAIN) {
606              serverLog(LL_WARNING,&quot;Write error sending DB to replica: %s&quot;,
607                  strerror(errno));
608              freeClient(slave);
609          }
610          return;
611      }
612      slave-&gt;repldboff += nwritten;
613      server.stat_net_output_bytes += nwritten;
614      if (slave-&gt;repldboff == slave-&gt;repldbsize) {
615          close(slave-&gt;repldbfd);
616          slave-&gt;repldbfd = -1;
617          aeDeleteFileEvent(server.el,slave-&gt;fd,AE_WRITABLE);
618          putSlaveOnline(slave);
619      }
620  }
621  #endif
622  void updateSlavesWaitingBgsave(int bgsaveerr, int type) {
623      listNode *ln;
624      int startbgsave = 0;
625      int mincapa = -1;
626      listIter li;
627      listRewind(server.slaves,&amp;li);
628      while((ln = listNext(&amp;li))) {
629          client *slave = ln-&gt;value;
630          if (slave-&gt;replstate == SLAVE_STATE_WAIT_BGSAVE_START) {
631              startbgsave = 1;
632              mincapa = (mincapa == -1) ? slave-&gt;slave_capa :
633                                          (mincapa &amp; slave-&gt;slave_capa);
634          } else if (slave-&gt;replstate == SLAVE_STATE_WAIT_BGSAVE_END) {
635              struct redis_stat buf;
636              if (type == RDB_CHILD_TYPE_SOCKET) {
637                  serverLog(LL_NOTICE,
638                      &quot;Streamed RDB transfer with replica %s succeeded (socket). Waiting for REPLCONF ACK from slave to enable streaming&quot;,
639                          replicationGetSlaveName(slave));
640                  slave-&gt;replstate = SLAVE_STATE_ONLINE;
641                  slave-&gt;repl_put_online_on_ack = 1;
642                  slave-&gt;repl_ack_time = server.unixtime; &amp;bsol;* Timeout otherwise. */
643              } else {
644                  if (bgsaveerr != C_OK) {
645                      freeClient(slave);
646                      serverLog(LL_WARNING,&quot;SYNC failed. BGSAVE child returned an error&quot;);
647                      continue;
648                  }
649  #ifdef _WIN32
650                  sprintf(slave-&gt;replFileCopy,&quot;%d_%s&quot;,  slave-&gt;fd, server.rdb_filename);
651                  if(CopyFileA( server.rdb_filename, slave-&gt;replFileCopy, FALSE) == FALSE) {
652                      freeClient(slave);
653                      serverLog(LL_WARNING,&quot;Failed to duplicate RDB file. Failing SYNC: %d&quot;, GetLastError());
654                      continue;
655                  }
656                  if ((slave-&gt;repldbfd = open(slave-&gt;replFileCopy,O_RDONLY|_O_BINARY,0)) == -1 ||
657  #else
658                  if ((slave-&gt;repldbfd = open(server.rdb_filename,O_RDONLY)) == -1 ||
659  #endif
660                      redis_fstat(slave-&gt;repldbfd,&amp;buf) == -1) {
661                      freeClient(slave);
662                      serverLog(LL_WARNING,&quot;SYNC failed. Can&#x27;t open/stat DB after BGSAVE: %s&quot;, IF_WIN32(wsa_strerror(errno),strerror(errno)));
663                      continue;
664                  }
665                  slave-&gt;repldboff = 0;
666                  slave-&gt;repldbsize = buf.st_size;
667                  slave-&gt;replstate = SLAVE_STATE_SEND_BULK;
668                  slave-&gt;replpreamble = sdscatprintf(sdsempty(),&quot;$%lld\r\n&quot;,
669                      (PORT_ULONGLONG) slave-&gt;repldbsize);
670                  aeDeleteFileEvent(server.el,slave-&gt;fd,AE_WRITABLE);
671                  if (aeCreateFileEvent(server.el, slave-&gt;fd, AE_WRITABLE, sendBulkToSlave, slave) == AE_ERR) {
672                      freeClient(slave);
673                      continue;
674                  }
675              }
676          }
677      }
678      if (startbgsave) startBgsaveForReplication(mincapa);
679  }
680  void changeReplicationId(void) {
681      getRandomHexChars(server.replid,CONFIG_RUN_ID_SIZE);
682      server.replid[CONFIG_RUN_ID_SIZE] = &#x27;\0&#x27;;
683  }
684  void clearReplicationId2(void) {
685      memset(server.replid2,&#x27;0&#x27;,sizeof(server.replid));
686      server.replid2[CONFIG_RUN_ID_SIZE] = &#x27;\0&#x27;;
687      server.second_replid_offset = -1;
688  }
689  void shiftReplicationId(void) {
690      memcpy(server.replid2,server.replid,sizeof(server.replid));
691      server.second_replid_offset = server.master_repl_offset+1;
692      changeReplicationId();
693      serverLog(LL_WARNING,&quot;Setting secondary replication ID to %s, valid up to offset: %lld. New replication ID is %s&quot;, server.replid2, server.second_replid_offset, server.replid);
694  }
695  int slaveIsInHandshakeState(void) {
696      return server.repl_state &gt;= REPL_STATE_RECEIVE_PONG &amp;&amp;
697             server.repl_state &lt;= REPL_STATE_RECEIVE_PSYNC;
698  }
699  void replicationSendNewlineToMaster(void) {
700      static time_t newline_sent;
701      if (time(NULL) != newline_sent) {
702          newline_sent = time(NULL);
703          if (write(server.repl_transfer_s,&quot;\n&quot;,1) == -1) {
704          }
705      }
706  }
707  void replicationEmptyDbCallback(void *privdata) {
708      UNUSED(privdata);
709      replicationSendNewlineToMaster();
710  }
711  void replicationCreateMasterClient(int fd, int dbid) {
712      server.master = createClient(fd);
713      server.master-&gt;flags |= CLIENT_MASTER;
714      server.master-&gt;authenticated = 1;
715      server.master-&gt;reploff = server.master_initial_offset;
716      server.master-&gt;read_reploff = server.master-&gt;reploff;
717      memcpy(server.master-&gt;replid, server.master_replid,
718          sizeof(server.master_replid));
719      if (server.master-&gt;reploff == -1)
720          server.master-&gt;flags |= CLIENT_PRE_PSYNC;
721      if (dbid != -1) selectDb(server.master,dbid);
722  }
723  void restartAOFAfterSYNC() {
724      unsigned int tries, max_tries = 10;
725      for (tries = 0; tries &lt; max_tries; ++tries) {
726          if (startAppendOnly() == C_OK) break;
727          serverLog(LL_WARNING,
728              &quot;Failed enabling the AOF after successful master synchronization! &quot;
729              &quot;Trying it again in one second.&quot;);
730          sleep(1);
731      }
732      if (tries == max_tries) {
733          serverLog(LL_WARNING,
734              &quot;FATAL: this replica instance finished the synchronization with &quot;
735              &quot;its master, but the AOF can&#x27;t be turned on. Exiting now.&quot;);
736          exit(1);
737      }
738  }
739  #define REPL_MAX_WRITTEN_BEFORE_FSYNC (1024*1024*8) &amp;bsol;* 8 MB */
740  void readSyncBulkPayload(aeEventLoop *el, int fd, void *privdata, int mask) {
741      char buf[4096];
742      ssize_t nread, readlen, nwritten;
743      off_t left;
744      UNUSED(el);
745      UNUSED(privdata);
746      UNUSED(mask);
747      static char eofmark[CONFIG_RUN_ID_SIZE];
748      static char lastbytes[CONFIG_RUN_ID_SIZE];
749      static int usemark = 0;
750      if (server.repl_transfer_size == -1) {
751          if (syncReadLine(fd,buf,1024,(PORT_LONGLONG)server.repl_syncio_timeout*1000) == -1) {  WIN_PORT_FIX &amp;bsol;* cast (PORT_LONGLONG) */
752              serverLog(LL_WARNING,
753                  &quot;I/O error reading bulk count from MASTER: %s&quot;,
754                  IF_WIN32(wsa_strerror(errno),strerror(errno)));
755              goto error;
756          }
757          WIN32_ONLY(WSIOCP_QueueNextRead(fd);)
758          if (buf[0] == &#x27;-&#x27;) {
759              serverLog(LL_WARNING,
760                  &quot;MASTER aborted replication with an error: %s&quot;,
761                  buf+1);
762              goto error;
763          } else if (buf[0] == &#x27;\0&#x27;) {
764              server.repl_transfer_lastio = server.unixtime;
765              return;
766          } else if (buf[0] != &#x27;$&#x27;) {
767              serverLog(LL_WARNING,&quot;Bad protocol from MASTER, the first byte is not &#x27;$&#x27; (we received &#x27;%s&#x27;), are you sure the host and port are right?&quot;, buf);
768              goto error;
769          }
770          if (strncmp(buf+1,&quot;EOF:&quot;,4) == 0 &amp;&amp; strlen(buf+5) &gt;= CONFIG_RUN_ID_SIZE) {
771              usemark = 1;
772              memcpy(eofmark,buf+5,CONFIG_RUN_ID_SIZE);
773              memset(lastbytes,0,CONFIG_RUN_ID_SIZE);
774              server.repl_transfer_size = 0;
775              serverLog(LL_NOTICE,
776                  &quot;MASTER &lt;-&gt; REPLICA sync: receiving streamed RDB from master&quot;);
777          } else {
778              usemark = 0;
779              server.repl_transfer_size = strtol(buf+1,NULL,10);
780              serverLog(LL_NOTICE,
781                  &quot;MASTER &lt;-&gt; REPLICA sync: receiving %lld bytes from master&quot;,
782                  (PORT_LONGLONG) server.repl_transfer_size);
783          }
784          return;
785      }
786      if (usemark) {
787          readlen = sizeof(buf);
788      } else {
789          left = server.repl_transfer_size - server.repl_transfer_read;
790          readlen = (left &lt; (signed)sizeof(buf)) ? left : (signed)sizeof(buf);
791      }
792      nread = read(fd,buf,readlen);
793      if (nread &lt;= 0) {
794  #ifdef _WIN32
795          if (server.repl_transfer_size) {
796              serverLog(LL_WARNING,&quot;I/O error %d (left %Iu) trying to sync with MASTER: %s&quot;,
797                  errno, server.repl_transfer_size,
798                  (nread == -1) ? wsa_strerror(errno) : &quot;connection lost&quot;);
799          }
800  #else
801          serverLog(LL_WARNING,&quot;I/O error trying to sync with MASTER: %s&quot;,
802              (nread == -1) ? strerror(errno) : &quot;connection lost&quot;);
803  #endif
804          cancelReplicationHandshake();
805          return;
806      }
807      WIN32_ONLY(WSIOCP_QueueNextRead(fd);)
808      server.stat_net_input_bytes += nread;
809      int eof_reached = 0;
810      if (usemark) {
811          if (nread &gt;= CONFIG_RUN_ID_SIZE) {
812              memcpy(lastbytes,buf+nread-CONFIG_RUN_ID_SIZE,CONFIG_RUN_ID_SIZE);
813          } else {
814              int rem = (int)(CONFIG_RUN_ID_SIZE-nread);                           WIN_PORT_FIX &amp;bsol;* cast (int) */
815              memmove(lastbytes,lastbytes+nread,rem);
816              memcpy(lastbytes+rem,buf,nread);
817          }
818  #ifdef _WIN32
819          #pragma warning( suppress: 6385 ))
820  #endif
821          if (memcmp(lastbytes,eofmark,CONFIG_RUN_ID_SIZE) == 0) eof_reached = 1;
822      }
823      server.repl_transfer_lastio = server.unixtime;
824      if ((nwritten = write(server.repl_transfer_fd,buf,nread)) != nread) {
825          serverLog(LL_WARNING,&quot;Write error or short write writing to the DB dump file needed for MASTER &lt;-&gt; REPLICA synchronization: %s&quot;,
826              (nwritten == -1) ? IF_WIN32(wsa_strerror(errno), strerror(errno)) : &quot;short write&quot;);
827          goto error;
828      }
829      server.repl_transfer_read += nread;
830      if (usemark &amp;&amp; eof_reached) {
831          if (ftruncate(server.repl_transfer_fd,
832              server.repl_transfer_read - CONFIG_RUN_ID_SIZE) == -1)
833          {
834              serverLog(LL_WARNING,&quot;Error truncating the RDB file received from the master for SYNC: %s&quot;, IF_WIN32(wsa_strerror(errno),strerror(errno)));
835              goto error;
836          }
837      }
838      if (server.repl_transfer_read &gt;=
839          server.repl_transfer_last_fsync_off + REPL_MAX_WRITTEN_BEFORE_FSYNC)
840      {
841          off_t sync_size = server.repl_transfer_read -
842                            server.repl_transfer_last_fsync_off;
843          rdb_fsync_range(server.repl_transfer_fd,
844              server.repl_transfer_last_fsync_off, sync_size);
845          server.repl_transfer_last_fsync_off += sync_size;
846      }
847      if (!usemark) {
848          if (server.repl_transfer_read == server.repl_transfer_size)
849              eof_reached = 1;
850      }
851      if (eof_reached) {
852          int aof_is_enabled = server.aof_state != AOF_OFF;
853  #ifdef _WIN32
854          close(server.repl_transfer_fd);
855          server.repl_transfer_fd = -1;
856  #endif
857          if (server.rdb_child_pid != -1) {
858              serverLog(LL_NOTICE,
859                  &quot;Replica is about to load the RDB file received from the &quot;
860                  &quot;master, but there is a pending RDB child running. &quot;
861                  &quot;Killing process %ld and removing its temp file to avoid &quot;
862                  &quot;any race&quot;,
863                      (PORT_LONG) server.rdb_child_pid);
864              IF_WIN32(AbortForkOperation(), kill(server.rdb_child_pid,SIGUSR1));
865              rdbRemoveTempFile(server.rdb_child_pid);
866          }
867          if (fsync(server.repl_transfer_fd) == -1) {
868              serverLog(LL_WARNING,
869                  &quot;Failed trying to sync the temp DB to disk in &quot;
870                  &quot;MASTER &lt;-&gt; REPLICA synchronization: %s&quot;,
871                  strerror(errno));
872              cancelReplicationHandshake();
873              return;
874          }
875          if (rename(server.repl_transfer_tmpfile,server.rdb_filename) == -1) {
876              serverLog(LL_WARNING,&quot;Failed trying to rename the temp DB into dump.rdb in MASTER &lt;-&gt; REPLICA synchronization: %s&quot;, IF_WIN32(wsa_strerror(errno),strerror(errno)));
877              cancelReplicationHandshake();
878              return;
879          }
880          serverLog(LL_NOTICE, &quot;MASTER &lt;-&gt; REPLICA sync: Flushing old data&quot;);
881          if(aof_is_enabled) stopAppendOnly();
882          signalFlushedDb(-1);
883          emptyDb(
884              -1,
885              server.repl_slave_lazy_flush ? EMPTYDB_ASYNC : EMPTYDB_NO_FLAGS,
886              replicationEmptyDbCallback);
887          aeDeleteFileEvent(server.el,server.repl_transfer_s,AE_READABLE);
888          serverLog(LL_NOTICE, &quot;MASTER &lt;-&gt; REPLICA sync: Loading DB in memory&quot;);
889          rdbSaveInfo rsi = RDB_SAVE_INFO_INIT;
890          if (rdbLoad(server.rdb_filename,&amp;rsi) != C_OK) {
891              serverLog(LL_WARNING,&quot;Failed trying to load the MASTER synchronization DB from disk&quot;);
892              cancelReplicationHandshake();
893              if (aof_is_enabled) restartAOFAfterSYNC();
894              return;
895          }
896          zfree(server.repl_transfer_tmpfile);
897  #ifdef _WIN32
898          server.repl_transfer_tmpfile = NULL;
899  #else
900          close(server.repl_transfer_fd);
901  #endif
902          replicationCreateMasterClient(server.repl_transfer_s,rsi.repl_stream_db);
903          server.repl_state = REPL_STATE_CONNECTED;
904          server.repl_down_since = 0;
905          memcpy(server.replid,server.master-&gt;replid,sizeof(server.replid));
906          server.master_repl_offset = server.master-&gt;reploff;
907          clearReplicationId2();
908          if (server.repl_backlog == NULL) createReplicationBacklog();
909          serverLog(LL_NOTICE, &quot;MASTER &lt;-&gt; REPLICA sync: Finished with success&quot;);
910          if (aof_is_enabled) restartAOFAfterSYNC();
911      }
912      return;
913  error:
914      cancelReplicationHandshake();
915      return;
916  }
917  #define SYNC_CMD_READ (1&lt;&lt;0)
918  #define SYNC_CMD_WRITE (1&lt;&lt;1)
919  #define SYNC_CMD_FULL (SYNC_CMD_READ|SYNC_CMD_WRITE)
920  char *sendSynchronousCommand(int flags, int fd, ...) {
921      if (flags &amp; SYNC_CMD_WRITE) {
922          char *arg;
923          va_list ap;
924          sds cmd = sdsempty();
925          sds cmdargs = sdsempty();
926          size_t argslen = 0;
927          va_start(ap,fd);
928          while(1) {
929              arg = va_arg(ap, char*);
930              if (arg == NULL) break;
931              cmdargs = sdscatprintf(cmdargs,&quot;$%Iu\r\n%s\r\n&quot;,strlen(arg),arg); WIN_PORT_FIX &amp;bsol;* zu-&gt;Iu */
932              argslen++;
933          }
934          va_end(ap);
935          cmd = sdscatprintf(cmd,&quot;*%Iu\r\n&quot;,argslen); WIN_PORT_FIX &amp;bsol;* zu-&gt;Iu */
936          cmd = sdscatsds(cmd,cmdargs);
937          sdsfree(cmdargs);
938          if (syncWrite(fd,cmd,(ssize_t)sdslen(cmd),(PORT_LONGLONG)server.repl_syncio_timeout*1000)      WIN_PORT_FIX &amp;bsol;* cast (ssize_t), cast (PORT_LONGLONG) */
939              == -1)
940          {
941              sdsfree(cmd);
942              return sdscatprintf(sdsempty(),&quot;-Writing to master: %s&quot;,
943                      IF_WIN32(wsa_strerror(errno),strerror(errno)));
944          }
945          sdsfree(cmd);
946      }
947      if (flags &amp; SYNC_CMD_READ) {
948          char buf[256];
949          if (syncReadLine(fd,buf,sizeof(buf),(PORT_LONGLONG)server.repl_syncio_timeout*1000)  WIN_PORT_FIX &amp;bsol;* cast (PORT_LONGLONG) */
950              == -1)
951          {
952              return sdscatprintf(sdsempty(),&quot;-Reading from master: %s&quot;,
953                      IF_WIN32(wsa_strerror(errno),strerror(errno)));
954          }
955          server.repl_transfer_lastio = server.unixtime;
956          return sdsnew(buf);
957      }
958      return NULL;
959  }
960  #define PSYNC_WRITE_ERROR 0
961  #define PSYNC_WAIT_REPLY 1
962  #define PSYNC_CONTINUE 2
963  #define PSYNC_FULLRESYNC 3
964  #define PSYNC_NOT_SUPPORTED 4
965  #define PSYNC_TRY_LATER 5
966  int slaveTryPartialResynchronization(int fd, int read_reply) {
967      char *psync_replid;
968      char psync_offset[32];
969      sds reply;
970      if (!read_reply) {
971          server.master_initial_offset = -1;
972          if (server.cached_master) {
973              psync_replid = server.cached_master-&gt;replid;
974              snprintf(psync_offset,sizeof(psync_offset),&quot;%lld&quot;, server.cached_master-&gt;reploff+1);
975              serverLog(LL_NOTICE,&quot;Trying a partial resynchronization (request %s:%s).&quot;, psync_replid, psync_offset);
976          } else {
977              serverLog(LL_NOTICE,&quot;Partial resynchronization not possible (no cached master)&quot;);
978              psync_replid = &quot;?&quot;;
979              memcpy(psync_offset,&quot;-1&quot;,3);
980          }
981          reply = sendSynchronousCommand(SYNC_CMD_WRITE,fd,&quot;PSYNC&quot;,psync_replid,psync_offset,NULL);
982          if (reply != NULL) {
983              serverLog(LL_WARNING,&quot;Unable to send PSYNC to master: %s&quot;,reply);
984              sdsfree(reply);
985              aeDeleteFileEvent(server.el,fd,AE_READABLE);
986              return PSYNC_WRITE_ERROR;
987          }
988          WIN32_ONLY(WSIOCP_QueueNextRead(fd);)
989          return PSYNC_WAIT_REPLY;
990      }
991      reply = sendSynchronousCommand(SYNC_CMD_READ,fd,NULL);
992      if (sdslen(reply) == 0) {
993          sdsfree(reply);
994          WIN32_ONLY(WSIOCP_QueueNextRead(fd);)
995          return PSYNC_WAIT_REPLY;
996      }
997      aeDeleteFileEvent(server.el,fd,AE_READABLE);
998      if (!strncmp(reply,&quot;+FULLRESYNC&quot;,11)) {
999          char *replid = NULL, *offset = NULL;
1000          replid = strchr(reply,&#x27; &#x27;);
1001          if (replid) {
1002              replid++;
1003              offset = strchr(replid,&#x27; &#x27;);
1004              if (offset) offset++;
1005          }
1006          if (!replid || !offset || (offset-replid-1) != CONFIG_RUN_ID_SIZE) {
1007              serverLog(LL_WARNING,
1008                  &quot;Master replied with wrong +FULLRESYNC syntax.&quot;);
1009              memset(server.master_replid,0,CONFIG_RUN_ID_SIZE+1);
1010          } else {
1011              memcpy(server.master_replid, replid, offset-replid-1);
1012              server.master_replid[CONFIG_RUN_ID_SIZE] = &#x27;\0&#x27;;
1013              server.master_initial_offset = strtoll(offset,NULL,10);
1014              serverLog(LL_NOTICE,&quot;Full resync from master: %s:%lld&quot;,
1015                  server.master_replid,
1016                  server.master_initial_offset);
1017          }
1018          replicationDiscardCachedMaster();
1019          sdsfree(reply);
1020          return PSYNC_FULLRESYNC;
1021      }
1022      if (!strncmp(reply,&quot;+CONTINUE&quot;,9)) {
1023          serverLog(LL_NOTICE,
1024              &quot;Successful partial resynchronization with master.&quot;);
1025          char *start = reply+10;
1026          char *end = reply+9;
1027          while(end[0] != &#x27;\r&#x27; &amp;&amp; end[0] != &#x27;\n&#x27; &amp;&amp; end[0] != &#x27;\0&#x27;) end++;
1028          if (end-start == CONFIG_RUN_ID_SIZE) {
1029              char new[CONFIG_RUN_ID_SIZE+1];
1030              memcpy(new,start,CONFIG_RUN_ID_SIZE);
1031              new[CONFIG_RUN_ID_SIZE] = &#x27;\0&#x27;;
1032              if (strcmp(new,server.cached_master-&gt;replid)) {
1033                  serverLog(LL_WARNING,&quot;Master replication ID changed to %s&quot;,new);
<span onclick='openModal()' class='match'>1034                  memcpy(server.replid2,server.cached_master-&gt;replid,
1035                      sizeof(server.replid2));
1036                  server.second_replid_offset = server.master_repl_offset+1;
</span>1037                  memcpy(server.replid,new,sizeof(server.replid));
1038                  memcpy(server.cached_master-&gt;replid,new,sizeof(server.replid));
1039                  disconnectSlaves();
1040              }
1041          }
1042          sdsfree(reply);
1043          replicationResurrectCachedMaster(fd);
1044          if (server.repl_backlog == NULL) createReplicationBacklog();
1045          return PSYNC_CONTINUE;
1046      }
1047      if (!strncmp(reply,&quot;-NOMASTERLINK&quot;,13) ||
1048          !strncmp(reply,&quot;-LOADING&quot;,8))
1049      {
1050          serverLog(LL_NOTICE,
1051              &quot;Master is currently unable to PSYNC &quot;
1052              &quot;but should be in the future: %s&quot;, reply);
1053          sdsfree(reply);
1054          return PSYNC_TRY_LATER;
1055      }
1056      if (strncmp(reply,&quot;-ERR&quot;,4)) {
1057          serverLog(LL_WARNING,
1058              &quot;Unexpected reply to PSYNC from master: %s&quot;, reply);
1059      } else {
1060          serverLog(LL_NOTICE,
1061              &quot;Master does not support PSYNC or is in &quot;
1062              &quot;error state (reply: %s)&quot;, reply);
1063      }
1064      sdsfree(reply);
1065      replicationDiscardCachedMaster();
1066      return PSYNC_NOT_SUPPORTED;
1067  }
1068  void syncWithMaster(aeEventLoop *el, int fd, void *privdata, int mask) {
1069      char tmpfile[256], *err = NULL;
1070      int dfd = -1, maxtries = 5;
1071      int sockerr = 0, psync_result;
1072      socklen_t errlen = sizeof(sockerr);
1073      UNUSED(el);
1074      UNUSED(privdata);
1075      UNUSED(mask);
1076      if (server.repl_state == REPL_STATE_NONE) {
1077          close(fd);
1078          return;
1079      }
1080      if (getsockopt(fd, SOL_SOCKET, SO_ERROR, &amp;sockerr, &amp;errlen) == -1)
1081          sockerr = errno;
1082      if (sockerr) {
1083          serverLog(LL_WARNING,&quot;Error condition on socket for SYNC: %s&quot;,
1084              strerror(sockerr));
1085          goto error;
1086      }
1087      if (server.repl_state == REPL_STATE_CONNECTING) {
1088          serverLog(LL_NOTICE,&quot;Non blocking connect for SYNC fired the event.&quot;);
1089          aeDeleteFileEvent(server.el,fd,AE_WRITABLE);
1090          server.repl_state = REPL_STATE_RECEIVE_PONG;
1091          err = sendSynchronousCommand(SYNC_CMD_WRITE,fd,&quot;PING&quot;,NULL);
1092          if (err) goto write_error;
1093          WIN32_ONLY(WSIOCP_QueueNextRead(fd);)
1094          return;
1095      }
1096      if (server.repl_state == REPL_STATE_RECEIVE_PONG) {
1097          err = sendSynchronousCommand(SYNC_CMD_READ,fd,NULL);
1098          if (err[0] != &#x27;+&#x27; &amp;&amp;
1099              strncmp(err,&quot;-NOAUTH&quot;,7) != 0 &amp;&amp;
1100              strncmp(err,&quot;-ERR operation not permitted&quot;,28) != 0)
1101          {
1102              serverLog(LL_WARNING,&quot;Error reply to PING from master: &#x27;%s&#x27;&quot;,err);
1103              sdsfree(err);
1104              goto error;
1105          } else {
1106              serverLog(LL_NOTICE,
1107                  &quot;Master replied to PING, replication can continue...&quot;);
1108          }
1109          sdsfree(err);
1110          server.repl_state = REPL_STATE_SEND_AUTH;
1111      }
1112      if (server.repl_state == REPL_STATE_SEND_AUTH) {
1113          if (server.masterauth) {
1114              err = sendSynchronousCommand(SYNC_CMD_WRITE,fd,&quot;AUTH&quot;,server.masterauth,NULL);
1115              if (err) goto write_error;
1116              server.repl_state = REPL_STATE_RECEIVE_AUTH;
1117              WIN32_ONLY(WSIOCP_QueueNextRead(fd);)
1118              return;
1119          } else {
1120              server.repl_state = REPL_STATE_SEND_PORT;
1121          }
1122      }
1123      if (server.repl_state == REPL_STATE_RECEIVE_AUTH) {
1124          err = sendSynchronousCommand(SYNC_CMD_READ,fd,NULL);
1125          if (err[0] == &#x27;-&#x27;) {
1126              serverLog(LL_WARNING,&quot;Unable to AUTH to MASTER: %s&quot;,err);
1127              sdsfree(err);
1128              goto error;
1129          }
1130          sdsfree(err);
1131          server.repl_state = REPL_STATE_SEND_PORT;
1132      }
1133      if (server.repl_state == REPL_STATE_SEND_PORT) {
1134          sds port = sdsfromlonglong(server.slave_announce_port ?
1135              server.slave_announce_port : server.port);
1136          err = sendSynchronousCommand(SYNC_CMD_WRITE,fd,&quot;REPLCONF&quot;,
1137                  &quot;listening-port&quot;,port, NULL);
1138          sdsfree(port);
1139          if (err) goto write_error;
1140          sdsfree(err);
1141          server.repl_state = REPL_STATE_RECEIVE_PORT;
1142          return;
1143      }
1144      if (server.repl_state == REPL_STATE_RECEIVE_PORT) {
1145          err = sendSynchronousCommand(SYNC_CMD_READ,fd,NULL);
1146          if (err[0] == &#x27;-&#x27;) {
1147              serverLog(LL_NOTICE,&quot;(Non critical) Master does not understand &quot;
1148                                  &quot;REPLCONF listening-port: %s&quot;, err);
1149          }
1150          sdsfree(err);
1151          server.repl_state = REPL_STATE_SEND_IP;
1152      }
1153      if (server.repl_state == REPL_STATE_SEND_IP &amp;&amp;
1154          server.slave_announce_ip == NULL)
1155      {
1156              server.repl_state = REPL_STATE_SEND_CAPA;
1157      }
1158      if (server.repl_state == REPL_STATE_SEND_IP) {
1159          err = sendSynchronousCommand(SYNC_CMD_WRITE,fd,&quot;REPLCONF&quot;,
1160                  &quot;ip-address&quot;,server.slave_announce_ip, NULL);
1161          if (err) goto write_error;
1162          sdsfree(err);
1163          server.repl_state = REPL_STATE_RECEIVE_IP;
1164          return;
1165      }
1166      if (server.repl_state == REPL_STATE_RECEIVE_IP) {
1167          err = sendSynchronousCommand(SYNC_CMD_READ,fd,NULL);
1168          if (err[0] == &#x27;-&#x27;) {
1169              serverLog(LL_NOTICE,&quot;(Non critical) Master does not understand &quot;
1170                                  &quot;REPLCONF ip-address: %s&quot;, err);
1171          }
1172          sdsfree(err);
1173          server.repl_state = REPL_STATE_SEND_CAPA;
1174      }
1175      if (server.repl_state == REPL_STATE_SEND_CAPA) {
1176          err = sendSynchronousCommand(SYNC_CMD_WRITE,fd,&quot;REPLCONF&quot;,
1177                  &quot;capa&quot;,&quot;eof&quot;,&quot;capa&quot;,&quot;psync2&quot;,NULL);
1178          if (err) goto write_error;
1179          sdsfree(err);
1180          server.repl_state = REPL_STATE_RECEIVE_CAPA;
1181          WIN32_ONLY(WSIOCP_QueueNextRead(fd);)
1182          return;
1183      }
1184      if (server.repl_state == REPL_STATE_RECEIVE_CAPA) {
1185          err = sendSynchronousCommand(SYNC_CMD_READ,fd,NULL);
1186          if (err[0] == &#x27;-&#x27;) {
1187              serverLog(LL_NOTICE,&quot;(Non critical) Master does not understand &quot;
1188                                    &quot;REPLCONF capa: %s&quot;, err);
1189          }
1190          sdsfree(err);
1191          server.repl_state = REPL_STATE_SEND_PSYNC;
1192      }
1193      if (server.repl_state == REPL_STATE_SEND_PSYNC) {
1194          if (slaveTryPartialResynchronization(fd,0) == PSYNC_WRITE_ERROR) {
1195              err = sdsnew(&quot;Write error sending the PSYNC command.&quot;);
1196              goto write_error;
1197          }
1198          server.repl_state = REPL_STATE_RECEIVE_PSYNC;
1199          return;
1200      }
1201      if (server.repl_state != REPL_STATE_RECEIVE_PSYNC) {
1202          serverLog(LL_WARNING,&quot;syncWithMaster(): state machine error, &quot;
1203                               &quot;state should be RECEIVE_PSYNC but is %d&quot;,
1204                               server.repl_state);
1205          goto error;
1206      }
1207      psync_result = slaveTryPartialResynchronization(fd,1);
1208      if (psync_result == PSYNC_WAIT_REPLY) return; &amp;bsol;* Try again later... */
1209      if (psync_result == PSYNC_TRY_LATER) goto error;
1210      if (psync_result == PSYNC_CONTINUE) {
1211          serverLog(LL_NOTICE, &quot;MASTER &lt;-&gt; REPLICA sync: Master accepted a Partial Resynchronization.&quot;);
1212          return;
1213      }
1214      disconnectSlaves(); &amp;bsol;* Force our slaves to resync with us as well. */
1215      freeReplicationBacklog(); &amp;bsol;* Don&#x27;t allow our chained slaves to PSYNC. */
1216      if (psync_result == PSYNC_NOT_SUPPORTED) {
1217          serverLog(LL_NOTICE,&quot;Retrying with SYNC...&quot;);
1218          if (syncWrite(fd,&quot;SYNC\r\n&quot;,6,(PORT_LONGLONG)server.repl_syncio_timeout*1000) == -1) {  WIN_PORT_FIX &amp;bsol;* cast (PORT_LONGLONG) */
1219              serverLog(LL_WARNING,&quot;I/O error writing to MASTER: %s&quot;,
1220                  IF_WIN32(wsa_strerror(errno),strerror(errno)));
1221              goto error;
1222          }
1223      }
1224      while(maxtries--) {
1225  #ifdef _WIN32
1226          snprintf(tmpfile,256,
1227              &quot;temp-%d.%d.rdb&quot;,(int)server.unixtime,(int)getpid());
1228          dfd = open(tmpfile,O_CREAT|O_WRONLY|O_EXCL|O_BINARY,_S_IREAD|_S_IWRITE);
1229  #else
1230          snprintf(tmpfile,256,
1231              &quot;temp-%d.%ld.rdb&quot;,(int)server.unixtime,(long int)getpid());
1232          dfd = open(tmpfile,O_CREAT|O_WRONLY|O_EXCL,0644);
1233  #endif
1234          if (dfd != -1) break;
1235          sleep(1);
1236      }
1237      if (dfd == -1) {
1238          serverLog(LL_WARNING,&quot;Opening the temp file needed for MASTER &lt;-&gt; REPLICA synchronization: %s&quot;,strerror(errno));
1239          goto error;
1240      }
1241      if (aeCreateFileEvent(server.el,fd, AE_READABLE,readSyncBulkPayload,NULL)
1242              == AE_ERR)
1243      {
1244          serverLog(LL_WARNING,
1245              &quot;Can&#x27;t create readable event for SYNC: %s (fd=%d)&quot;,
1246              IF_WIN32(wsa_strerror(errno),strerror(errno)),fd);
1247          goto error;
1248      }
1249      server.repl_state = REPL_STATE_TRANSFER;
1250      server.repl_transfer_size = -1;
1251      server.repl_transfer_read = 0;
1252      server.repl_transfer_last_fsync_off = 0;
1253      server.repl_transfer_fd = dfd;
1254      server.repl_transfer_lastio = server.unixtime;
1255      server.repl_transfer_tmpfile = zstrdup(tmpfile);
1256      return;
1257  error:
1258      aeDeleteFileEvent(server.el,fd,AE_READABLE|AE_WRITABLE);
1259      if (dfd != -1) close(dfd);
1260      close(fd);
1261      server.repl_transfer_s = -1;
1262      server.repl_state = REPL_STATE_CONNECT;
1263      return;
1264  write_error: &amp;bsol;* Handle sendSynchronousCommand(SYNC_CMD_WRITE) errors. */
1265      serverLog(LL_WARNING,&quot;Sending command to master in replication handshake: %s&quot;, err);
1266      sdsfree(err);
1267      goto error;
1268  }
1269  int connectWithMaster(void) {
1270      int fd;
1271      fd = anetTcpNonBlockBestEffortBindConnect(NULL,
1272          server.masterhost,server.masterport,NET_FIRST_BIND_ADDR);
1273      if (fd == -1) {
1274          serverLog(LL_WARNING,&quot;Unable to connect to MASTER: %s&quot;,
1275              IF_WIN32(wsa_strerror(errno),strerror(errno)));
1276          return C_ERR;
1277      }
1278      if (aeCreateFileEvent(server.el,fd,AE_READABLE|AE_WRITABLE,syncWithMaster,NULL) ==
1279              AE_ERR)
1280      {
1281          close(fd);
1282          serverLog(LL_WARNING,&quot;Can&#x27;t create readable event for SYNC&quot;);
1283          return C_ERR;
1284      }
1285      server.repl_transfer_lastio = server.unixtime;
1286      server.repl_transfer_s = fd;
1287      server.repl_state = REPL_STATE_CONNECTING;
1288      return C_OK;
1289  }
1290  void undoConnectWithMaster(void) {
1291      int fd = server.repl_transfer_s;
1292      aeDeleteFileEvent(server.el,fd,AE_READABLE|AE_WRITABLE);
1293      close(fd);
1294      server.repl_transfer_s = -1;
1295  }
1296  void replicationAbortSyncTransfer(void) {
1297      serverAssert(server.repl_state == REPL_STATE_TRANSFER);
1298      undoConnectWithMaster();
1299      close(server.repl_transfer_fd);
1300      unlink(server.repl_transfer_tmpfile);
1301      zfree(server.repl_transfer_tmpfile);
1302  }
1303  int cancelReplicationHandshake(void) {
1304      if (server.repl_state == REPL_STATE_TRANSFER) {
1305          replicationAbortSyncTransfer();
1306          server.repl_state = REPL_STATE_CONNECT;
1307      } else if (server.repl_state == REPL_STATE_CONNECTING ||
1308                 slaveIsInHandshakeState())
1309      {
1310          undoConnectWithMaster();
1311          server.repl_state = REPL_STATE_CONNECT;
1312      } else {
1313          return 0;
1314      }
1315      return 1;
1316  }
1317  void replicationSetMaster(char *ip, int port) {
1318      int was_master = server.masterhost == NULL;
1319      sdsfree(server.masterhost);
1320      server.masterhost = sdsnew(ip);
1321      server.masterport = port;
1322      if (server.master) {
1323          freeClient(server.master);
1324      }
1325      disconnectAllBlockedClients(); &amp;bsol;* Clients blocked in master, now slave. */
1326      disconnectSlaves();
1327      cancelReplicationHandshake();
1328      if (was_master) {
1329          replicationDiscardCachedMaster();
1330          replicationCacheMasterUsingMyself();
1331      }
1332      server.repl_state = REPL_STATE_CONNECT;
1333  }
1334  void replicationUnsetMaster(void) {
1335      if (server.masterhost == NULL) return; &amp;bsol;* Nothing to do. */
1336      sdsfree(server.masterhost);
1337      server.masterhost = NULL;
1338      shiftReplicationId();
1339      if (server.master) freeClient(server.master);
1340      replicationDiscardCachedMaster();
1341      cancelReplicationHandshake();
1342      disconnectSlaves();
1343      server.repl_state = REPL_STATE_NONE;
1344      server.slaveseldb = -1;
1345      server.repl_no_slaves_since = server.unixtime;
1346  }
1347  void replicationHandleMasterDisconnection(void) {
1348      server.master = NULL;
1349      server.repl_state = REPL_STATE_CONNECT;
1350      server.repl_down_since = server.unixtime;
1351  }
1352  void replicaofCommand(client *c) {
1353      if (server.cluster_enabled) {
1354          addReplyError(c,&quot;REPLICAOF not allowed in cluster mode.&quot;);
1355          return;
1356      }
1357      if (!strcasecmp(c-&gt;argv[1]-&gt;ptr,&quot;no&quot;) &amp;&amp;
1358          !strcasecmp(c-&gt;argv[2]-&gt;ptr,&quot;one&quot;)) {
1359          if (server.masterhost) {
1360              replicationUnsetMaster();
1361              sds client = catClientInfoString(sdsempty(),c);
1362              serverLog(LL_NOTICE,&quot;MASTER MODE enabled (user request from &#x27;%s&#x27;)&quot;,
1363                  client);
1364              sdsfree(client);
1365          }
1366      } else {
1367          PORT_LONG port;
1368          if (c-&gt;flags &amp; CLIENT_SLAVE)
1369          {
1370              addReplyError(c, &quot;Command is not valid when client is a replica.&quot;);
1371              return;
1372          }
1373          if ((getLongFromObjectOrReply(c, c-&gt;argv[2], &amp;port, NULL) != C_OK))
1374              return;
1375          if (server.masterhost &amp;&amp; !strcasecmp(server.masterhost,c-&gt;argv[1]-&gt;ptr)
1376              &amp;&amp; server.masterport == port) {
1377              serverLog(LL_NOTICE,&quot;REPLICAOF would result into synchronization with the master we are already connected with. No operation performed.&quot;);
1378              addReplySds(c,sdsnew(&quot;+OK Already connected to specified master\r\n&quot;));
1379              return;
1380          }
1381          replicationSetMaster(c-&gt;argv[1]-&gt;ptr, (int)port);                       WIN_PORT_FIX &amp;bsol;* cast (int) */
1382          sds client = catClientInfoString(sdsempty(),c);
1383          serverLog(LL_NOTICE,&quot;REPLICAOF %s:%d enabled (user request from &#x27;%s&#x27;)&quot;,
1384              server.masterhost, server.masterport, client);
1385          sdsfree(client);
1386      }
1387      addReply(c,shared.ok);
1388  }
1389  void roleCommand(client *c) {
1390      if (server.masterhost == NULL) {
1391          listIter li;
1392          listNode *ln;
1393          void *mbcount;
1394          int slaves = 0;
1395          addReplyMultiBulkLen(c,3);
1396          addReplyBulkCBuffer(c,&quot;master&quot;,6);
1397          addReplyLongLong(c,server.master_repl_offset);
1398          mbcount = addDeferredMultiBulkLength(c);
1399          listRewind(server.slaves,&amp;li);
1400          while((ln = listNext(&amp;li))) {
1401              client *slave = ln-&gt;value;
1402              char ip[NET_IP_STR_LEN], *slaveip = slave-&gt;slave_ip;
1403              if (slaveip[0] == &#x27;\0&#x27;) {
1404                  if (anetPeerToString(slave-&gt;fd,ip,sizeof(ip),NULL) == -1)
1405                      continue;
1406                  slaveip = ip;
1407              }
1408              if (slave-&gt;replstate != SLAVE_STATE_ONLINE) continue;
1409              addReplyMultiBulkLen(c,3);
1410              addReplyBulkCString(c,slaveip);
1411              addReplyBulkLongLong(c,slave-&gt;slave_listening_port);
1412              addReplyBulkLongLong(c,slave-&gt;repl_ack_off);
1413              slaves++;
1414          }
1415          setDeferredMultiBulkLength(c,mbcount,slaves);
1416      } else {
1417          char *slavestate = NULL;
1418          addReplyMultiBulkLen(c,5);
1419          addReplyBulkCBuffer(c,&quot;slave&quot;,5);
1420          addReplyBulkCString(c,server.masterhost);
1421          addReplyLongLong(c,server.masterport);
1422          if (slaveIsInHandshakeState()) {
1423              slavestate = &quot;handshake&quot;;
1424          } else {
1425              switch(server.repl_state) {
1426              case REPL_STATE_NONE: slavestate = &quot;none&quot;; break;
1427              case REPL_STATE_CONNECT: slavestate = &quot;connect&quot;; break;
1428              case REPL_STATE_CONNECTING: slavestate = &quot;connecting&quot;; break;
1429              case REPL_STATE_TRANSFER: slavestate = &quot;sync&quot;; break;
1430              case REPL_STATE_CONNECTED: slavestate = &quot;connected&quot;; break;
1431              default: slavestate = &quot;unknown&quot;; break;
1432              }
1433          }
1434          addReplyBulkCString(c,slavestate);
1435          addReplyLongLong(c,server.master ? server.master-&gt;reploff : -1);
1436      }
1437  }
1438  void replicationSendAck(void) {
1439      client *c = server.master;
1440      if (c != NULL) {
1441          c-&gt;flags |= CLIENT_MASTER_FORCE_REPLY;
1442          addReplyMultiBulkLen(c,3);
1443          addReplyBulkCString(c,&quot;REPLCONF&quot;);
1444          addReplyBulkCString(c,&quot;ACK&quot;);
1445          addReplyBulkLongLong(c,c-&gt;reploff);
1446          c-&gt;flags &amp;= ~CLIENT_MASTER_FORCE_REPLY;
1447      }
1448  }
1449  void replicationCacheMaster(client *c) {
1450      serverAssert(server.master != NULL &amp;&amp; server.cached_master == NULL);
1451      serverLog(LL_NOTICE,&quot;Caching the disconnected master state.&quot;);
1452      unlinkClient(c);
1453      sdsclear(server.master-&gt;querybuf);
1454      sdsclear(server.master-&gt;pending_querybuf);
1455      server.master-&gt;read_reploff = server.master-&gt;reploff;
1456      if (c-&gt;flags &amp; CLIENT_MULTI) discardTransaction(c);
1457      listEmpty(c-&gt;reply);
1458      c-&gt;sentlen = 0;
1459      c-&gt;reply_bytes = 0;
1460      c-&gt;bufpos = 0;
1461      resetClient(c);
1462      server.cached_master = server.master;
1463      if (c-&gt;peerid) {
1464          sdsfree(c-&gt;peerid);
1465          c-&gt;peerid = NULL;
1466      }
1467      replicationHandleMasterDisconnection();
1468  }
1469  void replicationCacheMasterUsingMyself(void) {
1470      server.master_initial_offset = server.master_repl_offset;
1471      replicationCreateMasterClient(-1,-1);
1472      memcpy(server.master-&gt;replid, server.replid, sizeof(server.replid));
1473      unlinkClient(server.master);
1474      server.cached_master = server.master;
1475      server.master = NULL;
1476      serverLog(LL_NOTICE,&quot;Before turning into a replica, using my master parameters to synthesize a cached master: I may be able to synchronize with the new master with just a partial transfer.&quot;);
1477  }
1478  void replicationDiscardCachedMaster(void) {
1479      if (server.cached_master == NULL) return;
1480      serverLog(LL_NOTICE,&quot;Discarding previously cached master state.&quot;);
1481      server.cached_master-&gt;flags &amp;= ~CLIENT_MASTER;
1482      freeClient(server.cached_master);
1483      server.cached_master = NULL;
1484  }
1485  void replicationResurrectCachedMaster(int newfd) {
1486      server.master = server.cached_master;
1487      server.cached_master = NULL;
1488      server.master-&gt;fd = newfd;
1489      server.master-&gt;flags &amp;= ~(CLIENT_CLOSE_AFTER_REPLY|CLIENT_CLOSE_ASAP);
1490      server.master-&gt;authenticated = 1;
1491      server.master-&gt;lastinteraction = server.unixtime;
1492      server.repl_state = REPL_STATE_CONNECTED;
1493      server.repl_down_since = 0;
1494      linkClient(server.master);
1495      if (aeCreateFileEvent(server.el, newfd, AE_READABLE,
1496                            readQueryFromClient, server.master)) {
1497          serverLog(LL_WARNING,&quot;Error resurrecting the cached master, impossible to add the readable handler: %s&quot;, IF_WIN32(wsa_strerror(errno),strerror(errno)));
1498          freeClientAsync(server.master); &amp;bsol;* Close ASAP. */
1499      }
1500      if (clientHasPendingReplies(server.master)) {
1501          if (aeCreateFileEvent(server.el, newfd, AE_WRITABLE,
1502                            sendReplyToClient, server.master)) {
1503              serverLog(LL_WARNING,&quot;Error resurrecting the cached master, impossible to add the writable handler: %s&quot;, IF_WIN32(wsa_strerror(errno),strerror(errno)));
1504              freeClientAsync(server.master); &amp;bsol;* Close ASAP. */
1505          }
1506      }
1507  }
1508  void refreshGoodSlavesCount(void) {
1509      listIter li;
1510      listNode *ln;
1511      int good = 0;
1512      if (!server.repl_min_slaves_to_write ||
1513          !server.repl_min_slaves_max_lag) return;
1514      listRewind(server.slaves,&amp;li);
1515      while((ln = listNext(&amp;li))) {
1516          client *slave = ln-&gt;value;
1517          time_t lag = server.unixtime - slave-&gt;repl_ack_time;
1518          if (slave-&gt;replstate == SLAVE_STATE_ONLINE &amp;&amp;
1519              lag &lt;= server.repl_min_slaves_max_lag) good++;
1520      }
1521      server.repl_good_slaves_count = good;
1522  }
1523  void replicationScriptCacheInit(void) {
1524      server.repl_scriptcache_size = 10000;
1525      server.repl_scriptcache_dict = dictCreate(&amp;replScriptCacheDictType,NULL);
1526      server.repl_scriptcache_fifo = listCreate();
1527  }
1528  void replicationScriptCacheFlush(void) {
1529      dictEmpty(server.repl_scriptcache_dict,NULL);
1530      listRelease(server.repl_scriptcache_fifo);
1531      server.repl_scriptcache_fifo = listCreate();
1532  }
1533  void replicationScriptCacheAdd(sds sha1) {
1534      int retval;
1535      sds key = sdsdup(sha1);
1536      if (listLength(server.repl_scriptcache_fifo) == server.repl_scriptcache_size)
1537      {
1538          listNode *ln = listLast(server.repl_scriptcache_fifo);
1539          sds oldest = listNodeValue(ln);
1540          retval = dictDelete(server.repl_scriptcache_dict,oldest);
1541          serverAssert(retval == DICT_OK);
1542          listDelNode(server.repl_scriptcache_fifo,ln);
1543      }
1544      retval = dictAdd(server.repl_scriptcache_dict,key,NULL);
1545      listAddNodeHead(server.repl_scriptcache_fifo,key);
1546      serverAssert(retval == DICT_OK);
1547  }
1548  int replicationScriptCacheExists(sds sha1) {
1549      return dictFind(server.repl_scriptcache_dict,sha1) != NULL;
1550  }
1551  void replicationRequestAckFromSlaves(void) {
1552      server.get_ack_from_slaves = 1;
1553  }
1554  int replicationCountAcksByOffset(PORT_LONGLONG offset) {
1555      listIter li;
1556      listNode *ln;
1557      int count = 0;
1558      listRewind(server.slaves,&amp;li);
1559      while((ln = listNext(&amp;li))) {
1560          client *slave = ln-&gt;value;
1561          if (slave-&gt;replstate != SLAVE_STATE_ONLINE) continue;
1562          if (slave-&gt;repl_ack_off &gt;= offset) count++;
1563      }
1564      return count;
1565  }
1566  void waitCommand(client *c) {
1567      mstime_t timeout;
1568      PORT_LONG numreplicas, ackreplicas;
1569      PORT_LONGLONG offset = c-&gt;woff;
1570      if (server.masterhost) {
1571          addReplyError(c,&quot;WAIT cannot be used with replica instances. Please also note that since Redis 4.0 if a replica is configured to be writable (which is not the default) writes to replicas are just local and are not propagated.&quot;);
1572          return;
1573      }
1574      if (getLongFromObjectOrReply(c,c-&gt;argv[1],&amp;numreplicas,NULL) != C_OK)
1575          return;
1576      if (getTimeoutFromObjectOrReply(c,c-&gt;argv[2],&amp;timeout,UNIT_MILLISECONDS)
1577          != C_OK) return;
1578      ackreplicas = replicationCountAcksByOffset(c-&gt;woff);
1579      if (ackreplicas &gt;= numreplicas || c-&gt;flags &amp; CLIENT_MULTI) {
1580          addReplyLongLong(c,ackreplicas);
1581          return;
1582      }
1583      c-&gt;bpop.timeout = timeout;
1584      c-&gt;bpop.reploffset = offset;
1585      c-&gt;bpop.numreplicas = (int) numreplicas;                                    WIN_PORT_FIX &amp;bsol;* cast (int) */
1586      listAddNodeTail(server.clients_waiting_acks,c);
1587      blockClient(c,BLOCKED_WAIT);
1588      replicationRequestAckFromSlaves();
1589  }
1590  void unblockClientWaitingReplicas(client *c) {
1591      listNode *ln = listSearchKey(server.clients_waiting_acks,c);
1592      serverAssert(ln != NULL);
1593      listDelNode(server.clients_waiting_acks,ln);
1594  }
1595  void processClientsWaitingReplicas(void) {
1596      PORT_LONGLONG last_offset = 0;
1597      int last_numreplicas = 0;
1598      listIter li;
1599      listNode *ln;
1600      listRewind(server.clients_waiting_acks,&amp;li);
1601      while((ln = listNext(&amp;li))) {
1602          client *c = ln-&gt;value;
1603          if (last_offset &amp;&amp; last_offset &gt; c-&gt;bpop.reploffset &amp;&amp;
1604                             last_numreplicas &gt; c-&gt;bpop.numreplicas)
1605          {
1606              unblockClient(c);
1607              addReplyLongLong(c,last_numreplicas);
1608          } else {
1609              int numreplicas = replicationCountAcksByOffset(c-&gt;bpop.reploffset);
1610              if (numreplicas &gt;= c-&gt;bpop.numreplicas) {
1611                  last_offset = c-&gt;bpop.reploffset;
1612                  last_numreplicas = numreplicas;
1613                  unblockClient(c);
1614                  addReplyLongLong(c,numreplicas);
1615              }
1616          }
1617      }
1618  }
1619  PORT_LONGLONG replicationGetSlaveOffset(void) {
1620      PORT_LONGLONG offset = 0;
1621      if (server.masterhost != NULL) {
1622          if (server.master) {
1623              offset = server.master-&gt;reploff;
1624          } else if (server.cached_master) {
1625              offset = server.cached_master-&gt;reploff;
1626          }
1627      }
1628      if (offset &lt; 0) offset = 0;
1629      return offset;
1630  }
1631  void replicationCron(void) {
1632      static PORT_LONGLONG replication_cron_loops = 0;
1633      if (server.masterhost &amp;&amp;
1634          (server.repl_state == REPL_STATE_CONNECTING ||
1635           slaveIsInHandshakeState()) &amp;&amp;
1636           (time(NULL)-server.repl_transfer_lastio) &gt; server.repl_timeout)
1637      {
1638          serverLog(LL_WARNING,&quot;Timeout connecting to the MASTER...&quot;);
1639          cancelReplicationHandshake();
1640      }
1641      if (server.masterhost &amp;&amp; server.repl_state == REPL_STATE_TRANSFER &amp;&amp;
1642          (time(NULL)-server.repl_transfer_lastio) &gt; server.repl_timeout)
1643      {
1644          serverLog(LL_WARNING,&quot;Timeout receiving bulk data from MASTER... If the problem persists try to set the &#x27;repl-timeout&#x27; parameter in redis.conf to a larger value.&quot;);
1645          cancelReplicationHandshake();
1646      }
1647      if (server.masterhost &amp;&amp; server.repl_state == REPL_STATE_CONNECTED &amp;&amp;
1648          (time(NULL)-server.master-&gt;lastinteraction) &gt; server.repl_timeout)
1649      {
1650          serverLog(LL_WARNING,&quot;MASTER timeout: no data nor PING received...&quot;);
1651          freeClient(server.master);
1652      }
1653      if (server.repl_state == REPL_STATE_CONNECT) {
1654          serverLog(LL_NOTICE,&quot;Connecting to MASTER %s:%d&quot;,
1655              server.masterhost, server.masterport);
1656          if (connectWithMaster() == C_OK) {
1657              serverLog(LL_NOTICE,&quot;MASTER &lt;-&gt; REPLICA sync started&quot;);
1658          }
1659      }
1660      if (server.masterhost &amp;&amp; server.master &amp;&amp;
1661          !(server.master-&gt;flags &amp; CLIENT_PRE_PSYNC))
1662          replicationSendAck();
1663      listIter li;
1664      listNode *ln;
1665      robj *ping_argv[1];
1666      if ((replication_cron_loops % server.repl_ping_slave_period) == 0 &amp;&amp;
1667          listLength(server.slaves))
1668      {
1669          int manual_failover_in_progress =
1670              server.cluster_enabled &amp;&amp;
1671              server.cluster-&gt;mf_end &amp;&amp;
1672              clientsArePaused();
1673          if (!manual_failover_in_progress) {
1674              ping_argv[0] = createStringObject(&quot;PING&quot;,4);
1675              replicationFeedSlaves(server.slaves, server.slaveseldb,
1676                  ping_argv, 1);
1677              decrRefCount(ping_argv[0]);
1678          }
1679      }
1680      listRewind(server.slaves,&amp;li);
1681      while((ln = listNext(&amp;li))) {
1682          client *slave = ln-&gt;value;
1683          int is_presync =
1684              (slave-&gt;replstate == SLAVE_STATE_WAIT_BGSAVE_START ||
1685              (slave-&gt;replstate == SLAVE_STATE_WAIT_BGSAVE_END &amp;&amp;
1686               server.rdb_child_type != RDB_CHILD_TYPE_SOCKET));
1687          if (is_presync) {
1688  #ifdef _WIN32
1689              if (WSIOCP_SocketSend(slave-&gt;fd, &quot;\n&quot;, 1, server.el,
1690                                    NULL, NULL, NULL) == -1) {
1691  #else
1692              if (write(slave-&gt;fd, &quot;\n&quot;, 1) == -1) {
1693  #endif
1694              }
1695          }
1696      }
1697      if (listLength(server.slaves)) {
1698          listIter li;
1699          listNode *ln;
1700          listRewind(server.slaves,&amp;li);
1701          while((ln = listNext(&amp;li))) {
1702              client *slave = ln-&gt;value;
1703              if (slave-&gt;replstate != SLAVE_STATE_ONLINE) continue;
1704              if (slave-&gt;flags &amp; CLIENT_PRE_PSYNC) continue;
1705              if ((server.unixtime - slave-&gt;repl_ack_time) &gt; server.repl_timeout)
1706              {
1707                  serverLog(LL_WARNING, &quot;Disconnecting timedout replica: %s&quot;,
1708                      replicationGetSlaveName(slave));
1709                  freeClient(slave);
1710              }
1711          }
1712      }
1713      if (listLength(server.slaves) == 0 &amp;&amp; server.repl_backlog_time_limit &amp;&amp;
1714          server.repl_backlog &amp;&amp; server.masterhost == NULL)
1715      {
1716          time_t idle = server.unixtime - server.repl_no_slaves_since;
1717          if (idle &gt; server.repl_backlog_time_limit) {
1718              changeReplicationId();
1719              clearReplicationId2();
1720              freeReplicationBacklog();
1721              serverLog(LL_NOTICE,
1722                  &quot;Replication backlog freed after %d seconds &quot;
1723                  &quot;without connected replicas.&quot;,
1724                  (int) server.repl_backlog_time_limit);
1725          }
1726      }
1727      if (listLength(server.slaves) == 0 &amp;&amp;
1728          server.aof_state == AOF_OFF &amp;&amp;
1729          listLength(server.repl_scriptcache_fifo) != 0)
1730      {
1731          replicationScriptCacheFlush();
1732      }
1733      if (server.rdb_child_pid == -1 &amp;&amp; server.aof_child_pid == -1) {
1734          time_t idle, max_idle = 0;
1735          int slaves_waiting = 0;
1736          int mincapa = -1;
1737          listNode *ln;
1738          listIter li;
1739          listRewind(server.slaves,&amp;li);
1740          while((ln = listNext(&amp;li))) {
1741              client *slave = ln-&gt;value;
1742              if (slave-&gt;replstate == SLAVE_STATE_WAIT_BGSAVE_START) {
1743                  idle = server.unixtime - slave-&gt;lastinteraction;
1744                  if (idle &gt; max_idle) max_idle = idle;
1745                  slaves_waiting++;
1746                  mincapa = (mincapa == -1) ? slave-&gt;slave_capa :
1747                                              (mincapa &amp; slave-&gt;slave_capa);
1748              }
1749          }
1750          if (slaves_waiting &amp;&amp;
1751              (!server.repl_diskless_sync ||
1752               max_idle &gt; server.repl_diskless_sync_delay))
1753          {
1754              startBgsaveForReplication(mincapa);
1755          }
1756      }
1757      refreshGoodSlavesCount();
1758      replication_cron_loops++; &amp;bsol;* Incremented with frequency 1 HZ. */
1759  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from redis-MDEwOlJlcG9zaXRvcnkxMDgxMTA3MDY=-flat-replication.c</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from redis-MDEwOlJlcG9zaXRvcnkxMDgxMTA3MDY=-flat-replication.c</div>
                </div>
                <div class="column column_space"><pre><code>905          memcpy(server.replid,server.master-&gt;replid,sizeof(server.replid));
906          server.master_repl_offset = server.master-&gt;reploff;
</pre></code></div>
                <div class="column column_space"><pre><code>1034                  memcpy(server.replid2,server.cached_master-&gt;replid,
1035                      sizeof(server.replid2));
1036                  server.second_replid_offset = server.master_repl_offset+1;
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    