<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for imhiredis.c &amp; imfile.c</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for imhiredis.c &amp; imfile.c
      </h3>
<h1 align="center">
        7.1%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>imhiredis.c (11.775701%)<th>imfile.c (5.176664%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(137-153)<td><a href="#" name="0">(312-328)</a><td align="center"><font color="#ff0000">29</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(317-336)<td><a href="#" name="1">(1924-1943)</a><td align="center"><font color="#ed0000">27</font>
<tr onclick='openModal("#980517")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#980517"><font color="#980517">-</font><td><a href="#" name="2">(339-344)<td><a href="#" name="2">(1946-1951)</a><td align="center"><font color="#8c0000">16</font>
<tr onclick='openModal("#53858b")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#53858b"><font color="#53858b">-</font><td><a href="#" name="3">(403-416)<td><a href="#" name="3">(2094-2107)</a><td align="center"><font color="#7b0000">14</font>
<tr onclick='openModal("#6cc417")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#6cc417"><font color="#6cc417">-</font><td><a href="#" name="4">(220-234)<td><a href="#" name="4">(1755-1771)</a><td align="center"><font color="#7b0000">14</font>
<tr onclick='openModal("#151b8d")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#151b8d"><font color="#151b8d">-</font><td><a href="#" name="5">(728-739)<td><a href="#" name="5">(1954-1958)</a><td align="center"><font color="#720000">13</font>
<tr onclick='openModal("#8c8774")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#8c8774"><font color="#8c8774">-</font><td><a href="#" name="6">(270-290)<td><a href="#" name="6">(1038-1060)</a><td align="center"><font color="#720000">13</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>imhiredis.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 #include "config.h"
2 #include &lt;stdio.h&gt;
3 #include &lt;stdarg.h&gt;
4 #include &lt;stdlib.h&gt;
5 #include &lt;string.h&gt;
6 #include &lt;assert.h&gt;
7 #include &lt;errno.h&gt;
8 #include &lt;fcntl.h&gt;
9 #include &lt;pthread.h&gt;
10 #include &lt;sys/uio.h&gt;
11 #include &lt;hiredis/hiredis.h&gt;
12 #include &lt;hiredis/async.h&gt;
13 #include &lt;hiredis/adapters/libevent.h&gt;
14 #include &lt;event2/thread.h&gt;
15 #include "rsyslog.h"
16 #include "conf.h"
17 #include "syslogd-types.h"
18 #include "srUtils.h"
19 #include "template.h"
20 #include "module-template.h"
21 #include "errmsg.h"
22 #include "atomic.h"
23 #include "statsobj.h"
24 #include "unicode-helper.h"
25 #include "prop.h"
26 #include "ruleset.h"
27 #include "glbl.h"
28 #include "cfsysline.h"
29 #include "msg.h"
30 #include "dirty.h"
31 MODULE_TYPE_INPUT
32 MODULE_TYPE_NOKEEP
33 MODULE_CNFNAME("imhiredis")
34 DEF_IMOD_STATIC_DATA
35 #define QUEUE_BATCH_SIZE 10
36 #define IMHIREDIS_MODE_QUEUE 1
37 #define IMHIREDIS_MODE_SUBSCRIBE 2
38 DEFobjCurrIf(prop)
39 DEFobjCurrIf(ruleset)
40 DEFobjCurrIf(glbl)
41 DEFobjCurrIf(statsobj)
42 typedef struct redisNode_s {
43 	sbool isMaster;
44 	sbool usesSocket;
45 	uchar *socketPath;
46 	uchar *server;
47 	int port;
48 	struct redisNode_s *next;
49 } redisNode;
50 struct instanceConf_s {
51 	uchar *password;
52 	uchar *key;
53 	uchar *modeDescription;
54 	int mode;
55 	sbool useLPop;
56 	ruleset_t *pBindRuleset;		uchar *pszBindRuleset;		
57 	redisContext *conn;
58 	redisAsyncContext *aconn;
59 	struct event_base *evtBase;
60 	redisNode *redisNodesList;
61 	struct instanceConf_s *next;
62 };
63 struct modConfData_s {
64 	rsconf_t *pConf;			instanceConf_t *root, *tail;
65 };
66 static struct imhiredisWrkrInfo_s {
67 	pthread_t tid;			instanceConf_t *inst;	} *imhiredisWrkrInfo;
68 pthread_attr_t wrkrThrdAttr;	
69 static int activeHiredisworkers = 0;
70 static char *redis_replies[] = {"unknown", "string", "array", "integer", "nil", "status", "error"};
71 static modConfData_t *loadModConf = NULL;static modConfData_t *runModConf = NULL;
72 static prop_t *pInputName = NULL;
73 <a name="0"></a>
74 <font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>static struct cnfparamdescr modpdescr[] = {};
75 static struct cnfparamblk modpblk =
76 	{ CNFPARAMBLK_VERSION,
77 	  sizeof(modpdescr)/sizeof(struct cnfparamdescr),
78 	  modpdescr
79 	};
80 static struct cnfparamdescr inppdescr[] = {
81 	{ "socketPath", eCmdHdlrGetWord, 0 },
82 	{ "server", eCmdHdlrGetWord, 0 },
83 	{ "port", eCmdHdlrInt, 0 },
84 	{ "password", eCmdHdlrGetWord, 0 },
85 	{ "mode", eCmdHdlrGetWord, 0 },
86 	{ "key", eCmdHdlrGetWord, 0 },
87 	{ "uselpop", eCmdHdlrBinary, 0 },
88 	{ "ruleset", eCmdHdlrString, 0 },</b></font>
89 };
90 static struct cnfparamblk inppblk =
91 	{ CNFPARAMBLK_VERSION,
92 	  sizeof(inppdescr)/sizeof(struct cnfparamdescr),
93 	  inppdescr
94 	};
95 struct timeval glblRedisConnectTimeout = { 3, 0 }; 
96 #include "im-helper.h" 
97 static void redisAsyncRecvCallback (redisAsyncContext __attribute__((unused)) *c, void *reply, void *inst_obj);
98 static void redisAsyncConnectCallback (const redisAsyncContext *c, int status);
99 static void redisAsyncDisconnectCallback (const redisAsyncContext *c, int status);
100 static rsRetVal enqMsg(instanceConf_t *const inst, const char *message);
101 rsRetVal redisAuthentSynchronous(redisContext *conn, uchar *password);
102 rsRetVal redisAuthentAsynchronous(redisAsyncContext *aconn, uchar *password);
103 rsRetVal redisActualizeCurrentNode(instanceConf_t *inst);
104 rsRetVal redisGetServersList(redisNode *node, uchar *password, redisNode **result);
105 rsRetVal redisAuthenticate(instanceConf_t *inst);
106 rsRetVal redisConnectSync(redisContext **conn, redisNode *node);
107 rsRetVal redisConnectAsync(redisAsyncContext **aconn, redisNode *node);
108 rsRetVal redisDequeue(instanceConf_t *inst);
109 void workerLoopSubscribe(struct imhiredisWrkrInfo_s *me);
110 void workerLoopQueue(struct imhiredisWrkrInfo_s *me);
111 static void *imhirediswrkr(void *myself);
112 static rsRetVal createRedisNode(redisNode **root);
113 rsRetVal copyNode(redisNode *src, redisNode **dst);
114 redisNode *freeNode(redisNode *node);
115 void insertNodeAfter(redisNode *root, redisNode *elem);
116 void dbgPrintNode(redisNode *node);
117 static rsRetVal
118 createInstance(instanceConf_t **pinst)
119 {
120 	DEFiRet;
121 	instanceConf_t *inst;
122 	CHKmalloc(inst = malloc(sizeof(instanceConf_t)));
123 	inst-&gt;next = NULL;
124 	inst-&gt;password = NULL;
125 	inst-&gt;key = NULL;
126 	inst-&gt;mode = 0;
127 	inst-&gt;useLPop = 0;
128 	inst-&gt;pszBindRuleset = NULL;
129 	inst-&gt;pBindRuleset = NULL;
130 	inst-&gt;conn = NULL;
131 	inst-&gt;aconn = NULL;
132 	CHKiRet(createRedisNode(&amp;(inst-&gt;redisNodesList)));
133 	inst-&gt;currentNode = inst-&gt;redisNodesList;
134 <a name="4"></a>	inst-&gt;evtBase = NULL;
135 <font color="#6cc417"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>	if(loadModConf-&gt;tail == NULL) {
136 		loadModConf-&gt;tail = loadModConf-&gt;root = inst;
137 	} else {
138 		loadModConf-&gt;tail-&gt;next = inst;
139 		loadModConf-&gt;tail = inst;
140 	}
141 	*pinst = inst;
142 finalize_it:
143 	RETiRet;
144 }
145 static rsRetVal ATTR_NONNULL()</b></font>
146 checkInstance(instanceConf_t *const inst)
147 {
148 	DEFiRet;
149 	assert(inst-&gt;redisNodesList != NULL);
150 	if (inst-&gt;redisNodesList-&gt;server != NULL &amp;&amp; inst-&gt;redisNodesList-&gt;socketPath != NULL) {
151 		LogMsg(0, RS_RET_CONFIG_ERROR, LOG_WARNING,"imhiredis: both 'server' and 'socketPath' are given, "
152 								"ignoring 'socketPath'.");
153 		free(inst-&gt;redisNodesList-&gt;socketPath);
154 		inst-&gt;redisNodesList-&gt;socketPath = NULL;
155 	}
156 	if(inst-&gt;redisNodesList-&gt;server != NULL &amp;&amp; inst-&gt;redisNodesList-&gt;server[0] != '\0') {
157 		if (inst-&gt;redisNodesList-&gt;port == 0) {
158 			LogMsg(0, RS_RET_OK_WARN, LOG_WARNING, "imhiredis: port not set, setting default 6379");
159 			inst-&gt;redisNodesList-&gt;port = 6379;
160 		}
161 		DBGPRINTF("imhiredis: preferred server is %s (%d)\n",
162 			inst-&gt;redisNodesList-&gt;server,
163 			inst-&gt;redisNodesList-&gt;port);
164 		inst-&gt;redisNodesList-&gt;usesSocket = 0;
165 	}
166 	else if(inst-&gt;redisNodesList-&gt;socketPath != NULL &amp;&amp; inst-&gt;redisNodesList-&gt;socketPath[0] != '\0') {
167 		DBGPRINTF("imhiredis: preferred server is %s\n",
168 			inst-&gt;redisNodesList-&gt;socketPath);
169 		inst-&gt;redisNodesList-&gt;usesSocket = 1;
170 	} else {
171 		LogError(0, RS_RET_CONFIG_ERROR, "imhiredis: neither 'server' nor 'socketPath' are defined!");
172 		ABORT_FINALIZE(RS_RET_CONFIG_ERROR);
173 	}
174 <a name="6"></a>
175 	if (inst-&gt;key != NULL) {
176 		DBGPRINTF("imhiredis: key/channel is '%s'\n", inst-&gt;key);
177 <font color="#8c8774"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>	} else {
178 		LogError(0, RS_RET_CONFIG_ERROR, "imhiredis: no key defined !");
179 		ABORT_FINALIZE(RS_RET_CONFIG_ERROR);
180 	}
181 	if (inst-&gt;mode != IMHIREDIS_MODE_QUEUE &amp;&amp; inst-&gt;mode != IMHIREDIS_MODE_SUBSCRIBE) {
182 		LogError(0, RS_RET_CONFIG_ERROR, "imhiredis: invalid mode, please choose 'subscribe' or 'queue' mode.");
183 		ABORT_FINALIZE(RS_RET_CONFIG_ERROR);
184 	}
185 	if (inst-&gt;mode == IMHIREDIS_MODE_SUBSCRIBE &amp;&amp; inst-&gt;useLPop) {
186 		LogMsg(0, RS_RET_CONFIG_ERROR, LOG_WARNING,"imhiredis: 'uselpop' set with mode = subscribe : ignored.");
187 	}
188 	if (inst-&gt;password != NULL) {
189 		DBGPRINTF("imhiredis: password is '%s'\n", inst-&gt;password);
190 	}
191 	inst-&gt;currentNode = inst-&gt;redisNodesList;</b></font>
192 	if (RS_RET_OK != redisActualizeCurrentNode(inst) || inst-&gt;currentNode == NULL) {
193 		LogMsg(0, RS_RET_REDIS_ERROR, LOG_WARNING, "imhiredis: could not connect to a valid master!");
194 	}
195 finalize_it:
196 	RETiRet;
197 }
198 static inline void
199 std_checkRuleset_genErrMsg(__attribute__((unused)) modConfData_t *modConf, instanceConf_t *inst)
200 {
201 	LogError(0, NO_ERRCODE, "imhiredis: ruleset '%s' not found - "
202 		"using default ruleset instead",
203 		inst-&gt;pszBindRuleset);
204 }
205 BEGINnewInpInst
206 	struct cnfparamvals *pvals;
207 	instanceConf_t *inst;
208 	int i;
209 <a name="1"></a>CODESTARTnewInpInst
210 	DBGPRINTF("newInpInst (imhiredis)\n");
211 <font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>	if((pvals = nvlstGetParams(lst, &amp;inppblk, NULL)) == NULL) {
212 		ABORT_FINALIZE(RS_RET_MISSING_CNFPARAMS);
213 	}
214 	if(Debug) {
215 		dbgprintf("input param blk in imhiredis:\n");
216 		cnfparamsPrint(&amp;inppblk, pvals);
217 	}
218 	CHKiRet(createInstance(&amp;inst));
219 	for(i = 0 ; i &lt; inppblk.nParams ; ++i) {
220 		if(!pvals[i].bUsed)
221 			continue;
222 		if(!strcmp(inppblk.descr[i].name, "server")) {
223 			inst-&gt;redisNodesList-&gt;server = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
224 		} else if(!strcmp(inppblk.descr[i].name, "socketPath")) {
225 			inst-&gt;redisNodesList-&gt;socketPath = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
226 		} else if(!strcmp(inppblk.descr[i].name, "ruleset")) {
227 <a name="2"></a>			inst-&gt;pszBindRuleset = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);</b></font>
228 		} else if(!strcmp(inppblk.descr[i].name, "port")) {
229 			inst-&gt;redisNodesList-&gt;port = (int) pvals[i].val.d.n;
230 <font color="#980517"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>		} else if(!strcmp(inppblk.descr[i].name, "password")) {
231 			inst-&gt;password = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
232 		} else if(!strcmp(inppblk.descr[i].name, "uselpop")) {
233 			inst-&gt;useLPop = pvals[i].val.d.n;
234 		} else if(!strcmp(inppblk.descr[i].name, "mode")) {
235 			inst-&gt;modeDescription = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);</b></font>
236 			if (!strcmp((const char*)inst-&gt;modeDescription, "queue")) {
237 				inst-&gt;mode = IMHIREDIS_MODE_QUEUE;
238 			} else if (!strcmp((const char*)inst-&gt;modeDescription, "subscribe")) {
239 				inst-&gt;mode = IMHIREDIS_MODE_SUBSCRIBE;
240 			} else {
241 				LogMsg(0, RS_RET_PARAM_ERROR, LOG_ERR, "imhiredis: unsupported mode "
242 					"'%s'", inppblk.descr[i].name);
243 				ABORT_FINALIZE(RS_RET_PARAM_ERROR);
244 			}
245 		} else if(!strcmp(inppblk.descr[i].name, "key")) {
246 			inst-&gt;key = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
247 		} else {
248 			dbgprintf("imhiredis: program error, non-handled "
249 				"param '%s'\n", inppblk.descr[i].name);
250 		}
251 	}
252 	DBGPRINTF("imhiredis: checking config sanity\n");
253 	if (inst-&gt;modeDescription == NULL) {
254 		CHKmalloc(inst-&gt;modeDescription = (uchar*)strdup("subscribe"));
255 		inst-&gt;mode = IMHIREDIS_MODE_SUBSCRIBE;
256 		LogMsg(0, RS_RET_OK_WARN, LOG_WARNING, "imhiredis: \"mode\" parameter not specified "
257 			"using default redis 'subscribe' mode -- this may not be what you want!");
258 	}
259 	if (inst-&gt;key == NULL) {
260 		LogMsg(0, RS_RET_PARAM_ERROR, LOG_ERR, "imhiredis: \"key\" required parameter not specified!");
261 		ABORT_FINALIZE(RS_RET_PARAM_ERROR);
262 	}
263 	if(inst-&gt;redisNodesList-&gt;server == NULL &amp;&amp; inst-&gt;redisNodesList-&gt;socketPath == NULL) {
264 		CHKmalloc(inst-&gt;redisNodesList-&gt;server = (uchar *)strdup("127.0.0.1"));
265 		inst-&gt;redisNodesList-&gt;port = 6379;
266 		LogMsg(0, RS_RET_OK_WARN, LOG_WARNING, "imhiredis: no server parameter specified "
267 			"using default 127.0.0.1:6379 -- this may not be what you want!");
268 	}
269 	if (inst-&gt;password == NULL) {
270 		LogMsg(0, RS_RET_OK, LOG_INFO, "imhiredis: no password specified");
271 	}
272 	DBGPRINTF("imhiredis: newInpInst key=%s, mode=%s, uselpop=%d\n",
273 		inst-&gt;key, inst-&gt;modeDescription, inst-&gt;useLPop);
274 finalize_it:
275 CODE_STD_FINALIZERnewInpInst
276 	cnfparamvalsDestruct(pvals, &amp;inppblk);
277 ENDnewInpInst
278 BEGINbeginCnfLoad
279 CODESTARTbeginCnfLoad
280 	loadModConf = pModConf;
281 	pModConf-&gt;pConf = pConf;
282 ENDbeginCnfLoad
283 BEGINsetModCnf
284 <a name="3"></a>	struct cnfparamvals *pvals = NULL;
285 	int i;
286 CODESTARTsetModCnf
287 <font color="#53858b"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>	pvals = nvlstGetParams(lst, &amp;modpblk, NULL);
288 	if(pvals == NULL) {
289 		LogError(0, RS_RET_MISSING_CNFPARAMS, "imhiredis: error processing module "
290 			"config parameters [module(...)]");
291 		ABORT_FINALIZE(RS_RET_MISSING_CNFPARAMS);
292 	}
293 	if(Debug) {
294 		dbgprintf("module (global) param blk for imhiredis:\n");
295 		cnfparamsPrint(&amp;modpblk, pvals);
296 	}
297 	for(i = 0 ; i &lt; modpblk.nParams ; ++i) {
298 		if(!pvals[i].bUsed) {</b></font>
299 			continue;
300 		} else {
301 			dbgprintf("imhiredis: program error, non-handled "
302 			  "param '%s' in beginCnfLoad\n", modpblk.descr[i].name);
303 		}
304 	}
305 finalize_it:
306 	if(pvals != NULL)
307 		cnfparamvalsDestruct(pvals, &amp;modpblk);
308 ENDsetModCnf
309 BEGINendCnfLoad
310 CODESTARTendCnfLoad
311 ENDendCnfLoad
312 BEGINcheckCnf
313 	instanceConf_t *inst;
314 CODESTARTcheckCnf
315 	for(inst = pModConf-&gt;root ; inst != NULL ; inst = inst-&gt;next) {
316 		std_checkRuleset(pModConf, inst);
317 	}
318 ENDcheckCnf
319 BEGINactivateCnfPrePrivDrop
320 CODESTARTactivateCnfPrePrivDrop
321 	runModConf = pModConf;
322 ENDactivateCnfPrePrivDrop
323 BEGINactivateCnf
324 CODESTARTactivateCnf
325 	for(instanceConf_t *inst = pModConf-&gt;root ; inst != NULL ; inst = inst-&gt;next) {
326 		iRet = checkInstance(inst);
327 		if (inst-&gt;mode == IMHIREDIS_MODE_SUBSCRIBE)
328 			inst-&gt;evtBase = event_base_new();
329 	}
330 ENDactivateCnf
331 BEGINfreeCnf
332 	instanceConf_t *inst, *del;
333 	redisNode *node;
334 CODESTARTfreeCnf
335 	for(inst = pModConf-&gt;root ; inst != NULL ; ) {
336 		if (inst-&gt;evtBase)
337 			event_base_free(inst-&gt;evtBase);
338 		if (inst-&gt;password != NULL)
339 			free(inst-&gt;password);
340 		free(inst-&gt;modeDescription);
341 		free(inst-&gt;key);
342 		free(inst-&gt;pszBindRuleset);
343 		if(inst-&gt;conn != NULL) {
344 			redisFree(inst-&gt;conn);
345 			inst-&gt;conn = NULL;
346 		}
347 		if(inst-&gt;aconn != NULL) {
348 			redisAsyncFree(inst-&gt;aconn);
349 			inst-&gt;aconn = NULL;
350 		}
351 		for (node = inst-&gt;redisNodesList; node != NULL; node = freeNode(node)) {;}
352 		del = inst;
353 		inst = inst-&gt;next;
354 		free(del);
355 	}
356 ENDfreeCnf
357 static void
358 shutdownImhiredisWorkers(void)
359 {
360 	int i;
361 	instanceConf_t *inst;
362 	assert(imhiredisWrkrInfo != NULL);
363 	for(inst = runModConf-&gt;root ; inst != NULL ; inst = inst-&gt;next) {
364 		if (inst-&gt;mode == IMHIREDIS_MODE_SUBSCRIBE &amp;&amp; inst-&gt;aconn) {
365 			DBGPRINTF("imhiredis: disconnecting async worker\n");
366 			redisAsyncDisconnect(inst-&gt;aconn);
367 		}
368 	}
369 	DBGPRINTF("imhiredis: waiting on imhiredis workerthread termination\n");
370 	for(i = 0 ; i &lt; activeHiredisworkers ; ++i) {
371 		pthread_join(imhiredisWrkrInfo[i].tid, NULL);
372 		DBGPRINTF("imhiredis: Stopped worker %d\n", i);
373 	}
374 	free(imhiredisWrkrInfo);
375 	imhiredisWrkrInfo = NULL;
376 	return;
377 }
378 BEGINrunInput
379 	int i;
380 	instanceConf_t *inst;
381 CODESTARTrunInput
382 	DBGPRINTF("imhiredis: runInput loop started ...\n");
383 	activeHiredisworkers = 0;
384 	for(inst = runModConf-&gt;root ; inst != NULL ; inst = inst-&gt;next) {
385 		++activeHiredisworkers;
386 	}
387 	if(activeHiredisworkers == 0) {
388 		LogError(0, RS_RET_ERR, "imhiredis: no active inputs, input does "
389 			"not run - there should have been additional error "
390 			"messages given previously");
391 		ABORT_FINALIZE(RS_RET_ERR);
392 	}
393 	DBGPRINTF("imhiredis: Starting %d imhiredis workerthreads\n", activeHiredisworkers);
394 	imhiredisWrkrInfo = calloc(activeHiredisworkers, sizeof(struct imhiredisWrkrInfo_s));
395 	if (imhiredisWrkrInfo == NULL) {
396 		LogError(errno, RS_RET_OUT_OF_MEMORY, "imhiredis: worker-info array allocation failed.");
397 		ABORT_FINALIZE(RS_RET_OUT_OF_MEMORY);
398 	}
399 	i = 0;
400 	for(inst = runModConf-&gt;root ; inst != NULL ; inst = inst-&gt;next) {
401 		imhiredisWrkrInfo[i].inst = inst; 		pthread_create(&amp;imhiredisWrkrInfo[i].tid, &amp;wrkrThrdAttr, imhirediswrkr, &amp;(imhiredisWrkrInfo[i]));
402 		i++;
403 	}
404 	while(glbl.GetGlobalInputTermState() == 0) {
405 		if(glbl.GetGlobalInputTermState() == 0)
406 			srSleep(0, 100000);
407 	}
408 	DBGPRINTF("imhiredis: terminating upon request of rsyslog core\n");
409 	shutdownImhiredisWorkers();
410 finalize_it:
411 ENDrunInput
412 BEGINwillRun
413 CODESTARTwillRun
414 	CHKiRet(prop.Construct(&amp;pInputName));
415 	CHKiRet(prop.SetString(pInputName, UCHAR_CONSTANT("imhiredis"), sizeof("imhiredis") - 1));
416 	CHKiRet(prop.ConstructFinalize(pInputName));
417 finalize_it:
418 ENDwillRun
419 BEGINafterRun
420 CODESTARTafterRun
421 	if(pInputName != NULL)
422 		prop.Destruct(&amp;pInputName);
423 ENDafterRun
424 BEGINmodExit
425 CODESTARTmodExit
426 	pthread_attr_destroy(&amp;wrkrThrdAttr);
427 	libevent_global_shutdown();
428 	objRelease(statsobj, CORE_COMPONENT);
429 	objRelease(ruleset, CORE_COMPONENT);
430 	objRelease(glbl, CORE_COMPONENT);
431 	objRelease(prop, CORE_COMPONENT);
432 ENDmodExit
433 BEGINisCompatibleWithFeature
434 CODESTARTisCompatibleWithFeature
435 	if(eFeat == sFEATURENonCancelInputTermination)
436 		iRet = RS_RET_OK;
437 ENDisCompatibleWithFeature
438 BEGINqueryEtryPt
439 CODESTARTqueryEtryPt
440 CODEqueryEtryPt_STD_IMOD_QUERIES
441 CODEqueryEtryPt_STD_CONF2_QUERIES
442 CODEqueryEtryPt_STD_CONF2_PREPRIVDROP_QUERIES
443 CODEqueryEtryPt_STD_CONF2_IMOD_QUERIES
444 CODEqueryEtryPt_STD_CONF2_setModCnf_QUERIES
445 CODEqueryEtryPt_IsCompatibleWithFeature_IF_OMOD_QUERIES
446 ENDqueryEtryPt
447 BEGINmodInit()
448 CODESTARTmodInit
449 	*ipIFVersProvided = CURR_MOD_IF_VERSION;
450 CODEmodInit_QueryRegCFSLineHdlr
451 	CHKiRet(objUse(glbl, CORE_COMPONENT));
452 	CHKiRet(objUse(prop, CORE_COMPONENT));
453 	CHKiRet(objUse(ruleset, CORE_COMPONENT));
454 	CHKiRet(objUse(statsobj, CORE_COMPONENT));
455 	pthread_attr_init(&amp;wrkrThrdAttr);
456 	pthread_attr_setstacksize(&amp;wrkrThrdAttr, 4096*1024);
457 	evthread_use_pthreads();
458 ENDmodInit
459 static void redisAsyncRecvCallback (redisAsyncContext *aconn, void *reply, void __attribute__((unused)) *unused) {
460 	instanceConf_t *const inst = (instanceConf_t *) aconn-&gt;data;
461 	redisReply * r = (redisReply *) reply;
462 	if (r == NULL) return;
463 	if (r-&gt;elements &lt; 3 || r-&gt;element[2]-&gt;str == NULL) {
464 		return;
465 	}
466 	enqMsg(inst, r-&gt;element[2]-&gt;str);
467 	return;
468 }
469 static void redisAsyncConnectCallback (const redisAsyncContext *c, int status) {
470 	if (status != REDIS_OK) {
471 		LogMsg(0, RS_RET_REDIS_ERROR, LOG_ERR, "imhiredis (async): could not connect to redis: "
472 			"%s", c-&gt;errstr);
473 		instanceConf_t *inst = (instanceConf_t *) c-&gt;data;
474 		assert(inst != NULL);
475 		inst-&gt;aconn = NULL;
476 		return;
477 	}
478 	DBGPRINTF("imhiredis (async): successfully connected!\n");
479 	return;
480 }
481 static void redisAsyncDisconnectCallback (const redisAsyncContext *c, int status) {
482 	instanceConf_t *inst = (instanceConf_t *) c-&gt;data;
483 	assert(inst != NULL);
484 	inst-&gt;aconn = NULL;
485 	inst-&gt;currentNode = NULL;
486 	if (status != REDIS_OK) {
487 		LogMsg(0, RS_RET_REDIS_ERROR, LOG_ERR, "imhiredis (async): got disconnected from redis: "
488 			"%s", c-&gt;errstr);
489 		return;
490 	}
491 	DBGPRINTF("imhiredis (async): successfully disconnected!\n");
492 	return;
493 }
494 redisReply *getRole(redisContext *c) {
495 	redisReply *reply;
496 	assert(c != NULL);
497 <a name="5"></a>	reply = redisCommand(c, "ROLE");
498 	if (reply == NULL) {
499 		DBGPRINTF("imhiredis: could not get reply from ROLE command\n");
500 <font color="#151b8d"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>	}
501 	else if (reply-&gt;type == REDIS_REPLY_ERROR) {
502 		LogMsg(0, RS_RET_REDIS_ERROR, LOG_WARNING, "imhiredis got an error while querying role -&gt; "
503 			"%s\n", reply-&gt;str);
504 		freeReplyObject(reply);
505 		reply = NULL;
506 	}
507 	else if (reply-&gt;type != REDIS_REPLY_ARRAY) {
508 		LogMsg(0, RS_RET_REDIS_ERROR, LOG_ERR, "imhiredis: did not get an array from ROLE command");
509 		freeReplyObject(reply);
510 		reply = NULL;
511 	}</b></font>
512 	return reply;
513 }
514 static rsRetVal enqMsg(instanceConf_t *const inst, const char *message) {
515 	DEFiRet;
516 	smsg_t *pMsg;
517 	if (message == NULL || message[0] == '\0') {
518 		FINALIZE;
519 	}
520 	DBGPRINTF("imhiredis: enqMsg: Msg -&gt; '%s'\n", message);
521 	CHKiRet(msgConstruct(&amp;pMsg));
522 	MsgSetInputName(pMsg, pInputName);
523 	MsgSetRawMsg(pMsg, message, strlen(message));
524 	MsgSetFlowControlType(pMsg, eFLOWCTL_LIGHT_DELAY);
525 	MsgSetRuleset(pMsg, inst-&gt;pBindRuleset);
526 	MsgSetMSGoffs(pMsg, 0);		CHKiRet(submitMsg2(pMsg));
527 finalize_it:
528 	RETiRet;
529 }
530 rsRetVal redisAuthentSynchronous(redisContext *conn, uchar *password) {
531 	DEFiRet;
532 	redisReply *reply = NULL;
533 	assert(conn != NULL);
534 	assert(password != NULL);
535 	assert(password[0] != '\0');
536 	reply = (redisReply *) redisCommand(conn, "AUTH %s", password);
537 	if (reply == NULL) {
538 		LogError(0, RS_RET_REDIS_ERROR, "imhiredis: Could not authenticate!\n");
539 		ABORT_FINALIZE(RS_RET_REDIS_ERROR);
540 	} else if (strncmp(reply-&gt;str, "OK", 2)) {
541 		LogError(0, RS_RET_REDIS_AUTH_FAILED, "imhiredis: Authentication failure -&gt; %s\n", reply-&gt;str);
542 		ABORT_FINALIZE(RS_RET_REDIS_AUTH_FAILED);
543 	}
544 finalize_it:
545 	if(reply)
546 		freeReplyObject(reply);
547 	RETiRet;
548 }
549 rsRetVal redisAuthentAsynchronous(redisAsyncContext *aconn, uchar *password) {
550 	DEFiRet;
551 	assert(aconn != NULL);
552 	assert(password != NULL);
553 	assert(password[0] != '\0');
554 	if (REDIS_OK != redisAsyncCommand(aconn, NULL, NULL, "AUTH %s", password)) {
555 		LogError(0, RS_RET_REDIS_ERROR, "imhiredis: error while authenticating asynchronously -&gt; %s\n",
556 			aconn-&gt;errstr);
557 		ABORT_FINALIZE(RS_RET_REDIS_ERROR);
558 	}
559 finalize_it:
560 	RETiRet;
561 }
562 rsRetVal redisGetServersList(redisNode *node, uchar *password, redisNode **result) {
563 	DEFiRet;
564 	redisContext *context;
565 	redisReply *reply = NULL, *replica;
566 	unsigned int i;
567 	assert(node != NULL);
568 	CHKiRet(redisConnectSync(&amp;context, node));
569 	if(password != NULL &amp;&amp; password[0] != '\0') {
570 		CHKiRet(redisAuthentSynchronous(context, password));
571 	}
572 	reply = getRole(context);
573 	if(reply == NULL) {
574 		LogMsg(0, RS_RET_REDIS_ERROR, LOG_WARNING, "imhiredis: did not get the role of the server");
575 		ABORT_FINALIZE(RS_RET_REDIS_ERROR);
576 	}
577 	if (	reply-&gt;elements == 5 &amp;&amp;
578 		strncmp(reply-&gt;element[0]-&gt;str, "slave", 5) == 0) {
579 		CHKiRet(createRedisNode(result));
580 		(*result)-&gt;server = (uchar *) strdup((const char *)reply-&gt;element[1]-&gt;str);
581 		(*result)-&gt;port = reply-&gt;element[2]-&gt;integer;
582 		(*result)-&gt;isMaster = 1;
583 	}
584 	else if (	reply-&gt;elements == 3 &amp;&amp;
585 			reply-&gt;element[2]-&gt;type == REDIS_REPLY_ARRAY &amp;&amp;
586 			strncmp(reply-&gt;element[0]-&gt;str, "master", 6) == 0) {
587 		for (i = 0; i &lt; reply-&gt;element[2]-&gt;elements; i++) {
588 			replica = reply-&gt;element[2]-&gt;element[i];
589 			if (replica-&gt;type == REDIS_REPLY_ARRAY &amp;&amp; replica-&gt;elements == 3) {
590 				CHKiRet(createRedisNode(result));
591 				(*result)-&gt;server = (uchar *) strdup((const char *)replica-&gt;element[0]-&gt;str);
592 				(*result)-&gt;port = atoi(replica-&gt;element[1]-&gt;str);
593 			}
594 		}
595 	} else {
596 		ABORT_FINALIZE(RS_RET_NOT_FOUND);
597 	}
598 finalize_it:
599 	if (reply != NULL)
600 		freeReplyObject(reply);
601 	if (context != NULL)
602 		redisFree(context);
603 	RETiRet;
604 }
605 rsRetVal redisActualizeCurrentNode(instanceConf_t *inst) {
606 	DEFiRet;
607 	redisReply *reply = NULL;
608 	redisNode *node, *tmp, *newList = NULL;
609 	assert(inst != NULL);
610 	assert(inst-&gt;redisNodesList != NULL);
611 	inst-&gt;currentNode = NULL;
612 	copyNode(inst-&gt;redisNodesList, &amp;newList);
613 	newList-&gt;next = NULL;
614 	for (node = inst-&gt;redisNodesList; node != NULL; node = node-&gt;next) {
615 		tmp = NULL;
616 		DBGPRINTF("imhiredis: trying to connect to node to get info...\n");
617 		dbgPrintNode(node);
618 		if (RS_RET_OK == redisGetServersList(node, inst-&gt;password, &amp;tmp)) {
619 			if (tmp &amp;&amp; tmp-&gt;isMaster) {
620 				DBGPRINTF("imhiredis: node replied with a master node, is a replica\n");
621 				inst-&gt;currentNode = tmp;
622 				tmp = NULL;
623 				if(RS_RET_OK != redisGetServersList(inst-&gt;currentNode, inst-&gt;password, &amp;tmp)) {
624 					DBGPRINTF("imhiredis: had a master but cannot connect, keeping in list\n");
625 					dbgPrintNode(inst-&gt;currentNode);
626 					insertNodeAfter(newList, inst-&gt;currentNode);
627 					inst-&gt;currentNode = NULL;
628 					continue;
629 				}
630 			} else {
631 				DBGPRINTF("imhiredis: node replied with a list of replicas, is a master\n");
632 				node-&gt;isMaster = 1;
633 				copyNode(node, &amp;(inst-&gt;currentNode));
634 				inst-&gt;currentNode-&gt;next = NULL;
635 			}
636 			if (tmp) {
637 				insertNodeAfter(newList, tmp);
638 				DBGPRINTF("imhiredis: inserting replicas to list\n");
639 				for (tmp = newList-&gt;next; tmp != NULL; tmp = tmp-&gt;next) {
640 					dbgPrintNode(tmp);
641 				}
642 			}
643 			DBGPRINTF("imhiredis: inserting new master node in list\n");
644 			dbgPrintNode(inst-&gt;currentNode);
645 			insertNodeAfter(newList, inst-&gt;currentNode);
646 			tmp = newList;
647 			newList = inst-&gt;redisNodesList;
648 			inst-&gt;redisNodesList = tmp;
649 			FINALIZE;
650 		}
651 	}
652 	DBGPRINTF("imhiredis: did not find a valid master");
653 	iRet = RS_RET_NOT_FOUND;
654 	inst-&gt;currentNode = NULL;
655 finalize_it:
656 	if (reply != NULL)
657 		freeReplyObject(reply);
658 	for (node = newList; node != NULL; ) {
659 		node = freeNode(node);
660 	}
661 	RETiRet;
662 }
663 rsRetVal redisAuthenticate(instanceConf_t *inst) {
664 	DEFiRet;
665 	redisContext *usedContext = NULL;
666 	redisReply *reply = NULL;
667 	assert(inst != NULL);
668 	assert(inst-&gt;currentNode != NULL);
669 	assert(inst-&gt;password != NULL);
670 	assert(inst-&gt;password[0] != '\0');
671 	DBGPRINTF("imhiredis: authenticating...\n");
672 	if (inst-&gt;mode == IMHIREDIS_MODE_SUBSCRIBE) {
673 		if (RS_RET_OK != redisConnectSync(&amp;usedContext, inst-&gt;currentNode)) {
674 			LogMsg(0, RS_RET_REDIS_ERROR, LOG_WARNING, "imhiredis: could not connect to current "
675 				"active node synchronously to validate authentication");
676 			ABORT_FINALIZE(RS_RET_REDIS_ERROR);
677 		}
678 	} else {
679 		usedContext = inst-&gt;conn;
680 	}
681 	CHKiRet(redisAuthentSynchronous(usedContext, inst-&gt;password));
682 	if (inst-&gt;mode == IMHIREDIS_MODE_SUBSCRIBE) {
683 		CHKiRet(redisAuthentAsynchronous(inst-&gt;aconn, inst-&gt;password));
684 	}
685 	DBGPRINTF("imhiredis: authentication successful\n");
686 finalize_it:
687 	if(inst-&gt;mode == IMHIREDIS_MODE_SUBSCRIBE &amp;&amp; usedContext)
688 		redisFree(usedContext);
689 	if(reply)
690 		freeReplyObject(reply);
691 	RETiRet;
692 }
693 rsRetVal redisConnectSync(redisContext **conn, redisNode *node) {
694 	DEFiRet;
695 	assert(node != NULL);
696 	if (node-&gt;usesSocket)
697 		*conn = redisConnectUnixWithTimeout((const char *)node-&gt;socketPath, glblRedisConnectTimeout);
698 	else
699 		*conn = redisConnectWithTimeout((const char *)node-&gt;server, node-&gt;port, glblRedisConnectTimeout);
700 	if (*conn == NULL) {
701 		if (node-&gt;usesSocket) {
702 			LogError(0, RS_RET_REDIS_ERROR, "imhiredis: can not connect to redis server '%s' "
703 				"-&gt; could not allocate context!\n", node-&gt;socketPath);
704 		} else {
705 			LogError(0, RS_RET_REDIS_ERROR, "imhiredis: can not connect to redis server '%s', "
706 				"port %d -&gt; could not allocate context!\n", node-&gt;server, node-&gt;port);
707 		}
708 		ABORT_FINALIZE(RS_RET_REDIS_ERROR);
709 	}
710 	else if ((*conn)-&gt;err) {
711 		if (node-&gt;usesSocket) {
712 			LogError(0, RS_RET_REDIS_ERROR, "imhiredis: can not connect to redis server '%s' "
713 				"-&gt; %s\n", node-&gt;socketPath, (*conn)-&gt;errstr);
714 		} else {
715 			LogError(0, RS_RET_REDIS_ERROR, "imhiredis: can not connect to redis server '%s', "
716 				"port %d -&gt; %s\n", node-&gt;server, node-&gt;port, (*conn)-&gt;errstr);
717 		}
718 		ABORT_FINALIZE(RS_RET_REDIS_ERROR);
719 	}
720 finalize_it:
721 	if (iRet != RS_RET_OK) {
722 		if (*conn)
723 			redisFree(*conn);
724 		*conn = NULL;
725 	}
726 	RETiRet;
727 }
728 rsRetVal redisConnectAsync(redisAsyncContext **aconn, redisNode *node) {
729 	DEFiRet;
730 	assert(node != NULL);
731 	if (node-&gt;usesSocket)
732 		*aconn = redisAsyncConnectUnix((const char*)node-&gt;socketPath);
733 	else
734 		*aconn = redisAsyncConnect((const char *)node-&gt;server, node-&gt;port);
735 	if(*aconn == NULL) {
736 		LogError(0, RS_RET_REDIS_ERROR, "imhiredis (async): could not allocate context!\n");
737 		ABORT_FINALIZE(RS_RET_REDIS_ERROR);
738 	} else if ((*aconn)-&gt;err) {
739 		if (node-&gt;usesSocket) {
740 			LogError(0, RS_RET_REDIS_ERROR, "imhiredis (async): cannot connect to server '%s' "
741 				"-&gt; %s\n", node-&gt;socketPath, (*aconn)-&gt;errstr);
742 		} else {
743 			LogError(0, RS_RET_REDIS_ERROR, "imhiredis (async): cannot connect to server '%s', port '%d' "
744 				"-&gt; %s\n", node-&gt;server, node-&gt;port, (*aconn)-&gt;errstr);
745 		}
746 		ABORT_FINALIZE(RS_RET_REDIS_ERROR);
747 	}
748 finalize_it:
749 	if (iRet != RS_RET_OK) {
750 		if(*aconn)
751 			redisAsyncFree(*aconn);
752 		*aconn = NULL;
753 	}
754 	RETiRet;
755 }
756 rsRetVal redisDequeue(instanceConf_t *inst) {
757 	DEFiRet;
758 	redisReply *reply = NULL;
759 	uint replyType = 0, i;
760 	assert(inst != NULL);
761 	DBGPRINTF("imhiredis: beginning to dequeue key '%s'\n", inst-&gt;key);
762 	do {
763 		if (inst-&gt;useLPop == 1) {
764 			DBGPRINTF("imhiredis: Queuing #%d LPOP commands on key '%s' \n",
765 					QUEUE_BATCH_SIZE,
766 					inst-&gt;key);
767 			for (i=0; i&lt;QUEUE_BATCH_SIZE; ++i ) {
768 				if (REDIS_OK != redisAppendCommand(inst-&gt;conn, "LPOP %s", inst-&gt;key))
769 					break;
770 			}
771 		} else {
772 			DBGPRINTF("imhiredis: Queuing #%d RPOP commands on key '%s' \n",
773 					QUEUE_BATCH_SIZE,
774 					inst-&gt;key);
775 			for (i=0; i&lt;QUEUE_BATCH_SIZE; i++) {
776 				if (REDIS_OK != redisAppendCommand(inst-&gt;conn, "RPOP %s", inst-&gt;key))
777 					break;
778 			}
779 		}
780 		do {
781 			if (REDIS_OK != redisGetReply(inst-&gt;conn, (void **) &amp;reply)) {
782 				LogError(0, RS_RET_REDIS_ERROR, "imhiredis: Error reading reply after POP #%d on key "
783 								"'%s'", (QUEUE_BATCH_SIZE - i), inst-&gt;key);
784 				ABORT_FINALIZE(RS_RET_REDIS_ERROR);
785 			} else {
786 				if (reply != NULL) {
787 					replyType = reply-&gt;type;
788 					switch(replyType) {
789 						case REDIS_REPLY_STRING:
790 							enqMsg(inst, reply-&gt;str);
791 							break;
792 						case REDIS_REPLY_NIL:
793 							break;
794 						case REDIS_REPLY_ERROR:
795 							LogMsg(0, RS_RET_REDIS_ERROR, LOG_ERR, "imhiredis: error "
796 							"while POP'ing key '%s' -&gt; %s", inst-&gt;key, reply-&gt;str);
797 							ABORT_FINALIZE(RS_RET_REDIS_ERROR);
798 						default:
799 							LogMsg(0, RS_RET_OK_WARN, LOG_WARNING, "imhiredis: unexpected "
800 							"reply type: %s", redis_replies[replyType%7]);
801 					}
802 					freeReplyObject(reply);
803 					reply = NULL;
804 				} else { 					LogMsg(0, RS_RET_REDIS_ERROR, LOG_ERR, "imhiredis: unexpected empty reply "
805 						"for successful return");
806 					ABORT_FINALIZE(RS_RET_REDIS_ERROR);
807 				}
808 			}
809 		} while (--i &gt; 0);
810 	} while (replyType == REDIS_REPLY_STRING &amp;&amp; glbl.GetGlobalInputTermState() == 0);
811 	DBGPRINTF("imhiredis: finished to dequeue key '%s'\n", inst-&gt;key);
812 finalize_it:
813 	if (reply)
814 		freeReplyObject(reply);
815 	RETiRet;
816 }
817 void workerLoopSubscribe(struct imhiredisWrkrInfo_s *me) {
818 	uint i;
819 	DBGPRINTF("imhiredis (async): beginning of subscribe worker loop...\n");
820 	if (me-&gt;inst-&gt;currentNode != NULL) {
821 		if(RS_RET_OK != redisConnectAsync(&amp;(me-&gt;inst-&gt;aconn), me-&gt;inst-&gt;currentNode)) {
822 			me-&gt;inst-&gt;currentNode = NULL;
823 		}
824 		if(	me-&gt;inst-&gt;password != NULL &amp;&amp;
825 			me-&gt;inst-&gt;password[0] != '\0' &amp;&amp;
826 			RS_RET_OK != redisAuthenticate(me-&gt;inst)) {
827 			redisAsyncFree(me-&gt;inst-&gt;aconn);
828 			me-&gt;inst-&gt;aconn = NULL;
829 			me-&gt;inst-&gt;currentNode = NULL;
830 		}
831 		me-&gt;inst-&gt;aconn-&gt;data = (void *)me-&gt;inst;
832 		redisAsyncSetConnectCallback(me-&gt;inst-&gt;aconn, redisAsyncConnectCallback);
833 		redisAsyncSetDisconnectCallback(me-&gt;inst-&gt;aconn, redisAsyncDisconnectCallback);
834 		redisLibeventAttach(me-&gt;inst-&gt;aconn, me-&gt;inst-&gt;evtBase);
835 	}
836 	while(glbl.GetGlobalInputTermState() == 0) {
837 		if (me-&gt;inst-&gt;aconn == NULL) {
838 			DBGPRINTF("imhiredis: no valid connection, sleeping 10 seconds before retrying...\n");
839 			for(i = 0; i &lt; 100; i++) {
840 				if (glbl.GetGlobalInputTermState() != 0)
841 					goto end_loop;
842 				srSleep(0, 100000);
843 			}
844 			if (me-&gt;inst-&gt;currentNode == NULL) {
845 				if(RS_RET_OK != redisActualizeCurrentNode(me-&gt;inst))
846 					continue;
847 			}
848 			if(me-&gt;inst-&gt;currentNode != NULL) {
849 				if(RS_RET_OK != redisConnectAsync(&amp;(me-&gt;inst-&gt;aconn), me-&gt;inst-&gt;currentNode)) {
850 					me-&gt;inst-&gt;currentNode = NULL;
851 					continue;
852 				}
853 				if(	me-&gt;inst-&gt;password != NULL &amp;&amp;
854 					me-&gt;inst-&gt;password[0] != '\0' &amp;&amp;
855 					RS_RET_OK != redisAuthenticate(me-&gt;inst)) {
856 					redisAsyncFree(me-&gt;inst-&gt;aconn);
857 					me-&gt;inst-&gt;aconn = NULL;
858 					me-&gt;inst-&gt;currentNode = NULL;
859 					continue;
860 				}
861 			}
862 			me-&gt;inst-&gt;aconn-&gt;data = (void *)me-&gt;inst;
863 			redisAsyncSetConnectCallback(me-&gt;inst-&gt;aconn, redisAsyncConnectCallback);
864 			redisAsyncSetDisconnectCallback(me-&gt;inst-&gt;aconn, redisAsyncDisconnectCallback);
865 			redisLibeventAttach(me-&gt;inst-&gt;aconn, me-&gt;inst-&gt;evtBase);
866 		}
867 		if (me-&gt;inst-&gt;aconn != NULL) {
868 			DBGPRINTF("imhiredis (async): subscribing to channel '%s'\n", me-&gt;inst-&gt;key);
869 			redisAsyncCommand(
870 				me-&gt;inst-&gt;aconn,
871 				redisAsyncRecvCallback,
872 				NULL,
873 				"SUBSCRIBE %s",
874 				me-&gt;inst-&gt;key);
875 			event_base_dispatch(me-&gt;inst-&gt;evtBase);
876 		}
877 	}
878 end_loop:
879 	return;
880 }
881 void workerLoopQueue(struct imhiredisWrkrInfo_s *me) {
882 	uint i;
883 	DBGPRINTF("imhiredis: beginning of queue worker loop...\n");
884 	if (me-&gt;inst-&gt;currentNode != NULL) {
885 		if(RS_RET_OK != redisConnectSync(&amp;(me-&gt;inst-&gt;conn), me-&gt;inst-&gt;currentNode)) {
886 			me-&gt;inst-&gt;currentNode = NULL;
887 		}
888 		if(	me-&gt;inst-&gt;password != NULL &amp;&amp;
889 			me-&gt;inst-&gt;password[0] != '\0' &amp;&amp;
890 			RS_RET_OK != redisAuthenticate(me-&gt;inst)) {
891 			redisFree(me-&gt;inst-&gt;conn);
892 			me-&gt;inst-&gt;conn = NULL;
893 			me-&gt;inst-&gt;currentNode = NULL;
894 		}
895 	}
896 	while(glbl.GetGlobalInputTermState() == 0) {
897 		if (me-&gt;inst-&gt;conn == NULL) {
898 			DBGPRINTF("imhiredis: no valid connection, sleeping 10 seconds before retrying...\n");
899 			for(i = 0; i &lt; 100; i++) {
900 				if (glbl.GetGlobalInputTermState() != 0)
901 					goto end_loop;
902 				srSleep(0, 100000);
903 			}
904 			if (me-&gt;inst-&gt;currentNode == NULL) {
905 				if(RS_RET_OK != redisActualizeCurrentNode(me-&gt;inst))
906 					continue;
907 			}
908 			if(me-&gt;inst-&gt;currentNode != NULL) {
909 				if(RS_RET_OK != redisConnectSync(&amp;(me-&gt;inst-&gt;conn), me-&gt;inst-&gt;currentNode)) {
910 					me-&gt;inst-&gt;currentNode = NULL;
911 					continue;
912 				}
913 				if(	me-&gt;inst-&gt;password != NULL &amp;&amp;
914 					me-&gt;inst-&gt;password[0] != '\0' &amp;&amp;
915 					RS_RET_OK != redisAuthenticate(me-&gt;inst)) {
916 					redisFree(me-&gt;inst-&gt;conn);
917 					me-&gt;inst-&gt;conn = NULL;
918 					me-&gt;inst-&gt;currentNode = NULL;
919 					continue;
920 				}
921 			}
922 		}
923 		if (me-&gt;inst-&gt;conn != NULL) {
924 			if (redisDequeue(me-&gt;inst) == RS_RET_REDIS_ERROR) {
925 				DBGPRINTF("imhiredis: current connection invalidated\n");
926 				redisFree(me-&gt;inst-&gt;conn);
927 				me-&gt;inst-&gt;currentNode = NULL;
928 				me-&gt;inst-&gt;conn = NULL;
929 			}
930 			if(glbl.GetGlobalInputTermState() == 0) {
931 				for(i = 0; i &lt; 10; i++) {
932 					if (glbl.GetGlobalInputTermState() != 0)
933 						goto end_loop;
934 					srSleep(0, 100000);
935 				}
936 			}
937 		}
938 	}
939 end_loop:
940 	return;
941 }
942 static void *
943 imhirediswrkr(void *myself)
944 {
945 	struct imhiredisWrkrInfo_s *me = (struct imhiredisWrkrInfo_s*) myself;
946 	DBGPRINTF("imhiredis: started hiredis consumer workerthread\n");
947 	dbgPrintNode(me-&gt;inst-&gt;currentNode);
948 	if(me-&gt;inst-&gt;mode == IMHIREDIS_MODE_QUEUE)
949 		workerLoopQueue(me);
950 	else if (me-&gt;inst-&gt;mode == IMHIREDIS_MODE_SUBSCRIBE)
951 		workerLoopSubscribe(me);
952 	DBGPRINTF("imhiredis: stopped hiredis consumer workerthread\n");
953 	return NULL;
954 }
955 static rsRetVal
956 createRedisNode(redisNode **root) {
957 	redisNode *node;
958 	DEFiRet;
959 	CHKmalloc(node = malloc(sizeof(redisNode)));
960 	node-&gt;port = 0;
961 	node-&gt;server = NULL;
962 	node-&gt;socketPath = NULL;
963 	node-&gt;usesSocket = 0;
964 	node-&gt;isMaster = 0;
965 	node-&gt;next = NULL;
966 	if (!root) {
967 		*root = node;
968 	} else {
969 		node-&gt;next = (*root);
970 		*root = node;
971 	}
972 finalize_it:
973 	RETiRet;
974 }
975 rsRetVal copyNode(redisNode *src, redisNode **dst) {
976 	DEFiRet;
977 	assert(src != NULL);
978 	CHKiRet(createRedisNode(dst));
979 	(*dst)-&gt;isMaster = src-&gt;isMaster;
980 	(*dst)-&gt;next = src-&gt;next;
981 	(*dst)-&gt;port = src-&gt;port;
982 	(*dst)-&gt;usesSocket = src-&gt;usesSocket;
983 	if (src-&gt;server)
984 		(*dst)-&gt;server = (uchar *) strdup((const char *)src-&gt;server);
985 	if (src-&gt;socketPath)
986 		(*dst)-&gt;socketPath = (uchar *) strdup((const char *)src-&gt;socketPath);
987 finalize_it:
988 	RETiRet;
989 }
990 redisNode *freeNode(redisNode *node) {
991 	redisNode *ret = NULL;
992 	if (node != NULL) {
993 		if (node-&gt;next != NULL)
994 			ret = node-&gt;next;
995 		if(node-&gt;server != NULL)
996 			free(node-&gt;server);
997 		if(node-&gt;socketPath != NULL)
998 			free(node-&gt;socketPath);
999 		free(node);
1000 	}
1001 	return ret;
1002 }
1003 void insertNodeAfter(redisNode *root, redisNode *elem) {
1004 	assert(root != NULL);
1005 	assert(elem != NULL);
1006 	if(root-&gt;next != NULL) {
1007 		elem-&gt;next = root-&gt;next;
1008 	}
1009 	root-&gt;next = elem;
1010 	return;
1011 }
1012 void dbgPrintNode(redisNode *node) {
1013 	if (node != NULL) {
1014 		if (node-&gt;usesSocket) {
1015 			if (node-&gt;isMaster) {
1016 				DBGPRINTF("imhiredis: node is %s (master)\n", node-&gt;socketPath);
1017 			} else {
1018 				DBGPRINTF("imhiredis: node is %s (replica)\n", node-&gt;socketPath);
1019 			}
1020 		} else {
1021 			if (node-&gt;isMaster) {
1022 				DBGPRINTF("imhiredis: node is %s:%d (master)\n", node-&gt;server, node-&gt;port);
1023 			} else {
1024 				DBGPRINTF("imhiredis: node is %s:%d (replica)\n", node-&gt;server, node-&gt;port);
1025 			}
1026 		}
1027 	}
1028 	return;
1029 }
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>imfile.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 #include "config.h"
2 #include &lt;stdio.h&gt;
3 #include &lt;stdlib.h&gt;
4 #include &lt;assert.h&gt;
5 #include &lt;string.h&gt;
6 #include &lt;errno.h&gt;
7 #include &lt;fcntl.h&gt;
8 #include &lt;pthread.h&gt;
9 #include &lt;sys/types.h&gt;
10 #include &lt;unistd.h&gt;
11 #include &lt;time.h&gt;
12 #include &lt;glob.h&gt;
13 #include &lt;poll.h&gt;
14 #include &lt;json.h&gt;
15 #include &lt;fnmatch.h&gt;
16 #ifdef HAVE_SYS_INOTIFY_H
17 #include &lt;sys/inotify.h&gt;
18 #include &lt;linux/types.h&gt;
19 #endif
20 #ifdef HAVE_SYS_STAT_H
21 #	include &lt;sys/stat.h&gt;
22 #endif
23 #if defined(OS_SOLARIS) &amp;&amp; defined (HAVE_PORT_SOURCE_FILE)
24 #include &lt;port.h&gt;
25 #include &lt;sys/port.h&gt;
26 #endif
27 #include "rsyslog.h"		#include "dirty.h"
28 #include "cfsysline.h"		#include "module-template.h"	#include "srUtils.h"		#include "msg.h"
29 #include "stream.h"
30 #include "errmsg.h"
31 #include "glbl.h"
32 #include "unicode-helper.h"
33 #include "prop.h"
34 #include "stringbuf.h"
35 #include "ruleset.h"
36 #include "ratelimit.h"
37 #include "srUtils.h"
38 #include "parserif.h"
39 #include "datetime.h"
40 #include &lt;regex.h&gt;
41 #ifndef O_LARGEFILE
42 #  define O_LARGEFILE 0
43 #endif
44 #ifndef HAVE_LSEEK64
45 #  define lseek64(fd, offset, whence) lseek(fd, offset, whence)
46 #endif
47 MODULE_TYPE_INPUT
48 MODULE_TYPE_NOKEEP
49 MODULE_CNFNAME("imfile")
50 #define FILE_ID_HASH_SIZE 20	#define FILE_ID_SIZE	512	
51 DEF_IMOD_STATIC_DATA	DEFobjCurrIf(glbl)
52 DEFobjCurrIf(strm)
53 DEFobjCurrIf(prop)
54 DEFobjCurrIf(ruleset)
55 DEFobjCurrIf(datetime)
56 extern int rs_siphash(const uint8_t *in, const size_t inlen, const uint8_t *k,
57 	uint8_t *out, const size_t outlen); 
58 static int bLegacyCnfModGlobalsPermitted;
59 #define NUM_MULTISUB 1024 #define DFLT_PollInterval 10
60 #define INIT_WDMAP_TAB_SIZE 1 #define ADD_METADATA_UNSPECIFIED -1
61 #define ULTRA_DEBUG 0
62 #ifndef GLOB_BRACE
63 	#define GLOB_BRACE 0
64 #endif
65 typedef struct per_minute_rate_limit_s per_minute_rate_limit_t;
66 struct per_minute_rate_limit_s {
67 	uint64_t maxBytesPerMinute;
68 	uint32_t maxLinesPerMinute;
69 	uint64_t bytesThisMinute; 	uint32_t linesThisMinute; 	time_t rateLimitingMinute; };
70 static struct configSettings_s {
71 	uchar *pszFileName;
72 	uchar *pszFileTag;
73 	uchar *pszStateFile;
74 	uchar *pszBindRuleset;
75 	int iPollInterval;
76 	int iPersistStateInterval;		int bPersistStateAfterSubmission;	int iFacility; 	int iSeverity;  	int readMode;  	int64 maxLinesAtOnce;		uint64_t maxBytesPerMinute; 	uint64_t maxLinesPerMinute; 	uint32_t trimLineOverBytes;  } cs;
77 struct instanceConf_s {
78 	uchar *pszFileName;
79 	uchar *pszFileName_forOldStateFile; 	uchar *pszDirName;
80 	uchar *pszFileBaseName;
81 	uchar *pszTag;
82 	size_t lenTag;
83 	uchar *pszStateFile;
84 	uchar *pszBindRuleset;
85 	int nMultiSub;
86 	per_minute_rate_limit_t perMinuteRateLimits;
87 	int iPersistStateInterval;
88 	int bPersistStateAfterSubmission;
89 	int iFacility;
90 	int iSeverity;
91 	int readTimeout;
92 	unsigned delay_perMsg;
93 	sbool bRMStateOnDel;
94 	uint8_t readMode;
95 	uchar *startRegex;
96 	uchar *endRegex;
97 	regex_t start_preg;		regex_t end_preg;		sbool discardTruncatedMsg;
98 	sbool msgDiscardingError;
99 	sbool escapeLF;
100 	sbool reopenOnTruncate;
101 	sbool addCeeTag;
102 	sbool addMetadata;
103 	sbool freshStartTail;
104 	sbool fileNotFoundError;
105 	int maxLinesAtOnce;
106 	uint32_t trimLineOverBytes;
107 	uint32_t ignoreOlderThan;
108 	int msgFlag;
109 	uchar *escapeLFString;
110 	ruleset_t *pBindRuleset;		struct instanceConf_s *next;
111 };
112 typedef struct fs_edge_s fs_edge_t;
113 typedef struct fs_node_s fs_node_t;
114 typedef struct act_obj_s act_obj_t;
115 struct act_obj_s {
116 	act_obj_t *prev;
117 	act_obj_t *next;
118 	fs_edge_t *edge;		char *name;			char *basename;			char *source_name;		int wd;
119 #if defined(OS_SOLARIS) &amp;&amp; defined (HAVE_PORT_SOURCE_FILE)
120 	struct fileinfo *pfinf;
121 	sbool bPortAssociated;
122 	int is_deleted;	#endif
123 	ratelimit_t *ratelimiter;
124 	multi_submit_t multiSub;
125 	int is_symlink;
126 };
127 struct fs_edge_s {
128 	fs_node_t *parent;		fs_node_t *node;		fs_edge_t *next;
129 	uchar *name;
130 	uchar *path;
131 	act_obj_t *active;
132 	int is_file;
133 	int ninst;			instanceConf_t **instarr;
134 };
135 struct fs_node_s {
136 	fs_edge_t *edges;		fs_node_t *root;	};
137 static rsRetVal persistStrmState(act_obj_t *);
138 static rsRetVal resetConfigVariables(uchar __attribute__((unused)) *pp, void __attribute__((unused)) *pVal);
139 static rsRetVal ATTR_NONNULL(1) pollFile(act_obj_t *act);
140 static int ATTR_NONNULL() getBasename(uchar *const __restrict__ basen, uchar *const __restrict__ path);
141 static void ATTR_NONNULL() act_obj_unlink(act_obj_t *act);
142 static uchar * ATTR_NONNULL(1, 2) getStateFileName(const act_obj_t *, uchar *, const size_t);
143 static int ATTR_NONNULL() getFullStateFileName(const uchar *const, const char *const,
144 	uchar *const pszout, const size_t ilenout);
145 #define OPMODE_POLLING 0
146 #define OPMODE_INOTIFY 1
147 #define OPMODE_FEN 2
148 struct modConfData_s {
149 	rsconf_t *pConf;		int iPollInterval;		int readTimeout;
150 	int timeoutGranularity;			instanceConf_t *root, *tail;
151 	fs_node_t *conf_tree;
152 	uint8_t opMode;
153 	sbool configSetViaV2Method;
154 	uchar *stateFileDirectory;
155 	sbool sortFiles;
156 };
157 static modConfData_t *loadModConf = NULL;static modConfData_t *runModConf = NULL;static modConfData_t *currModConf = NULL;
158 #ifdef HAVE_INOTIFY_INIT
159 struct wd_map_s {
160 	int wd;			act_obj_t *act; };
161 typedef struct wd_map_s wd_map_t;
162 static wd_map_t *wdmap = NULL;
163 static int nWdmap;
164 static int allocMaxWdmap;
165 static int ino_fd;	#endif 
166 #if defined(OS_SOLARIS) &amp;&amp; defined (HAVE_PORT_SOURCE_FILE)
167 struct fileinfo {
168 	struct file_obj fobj;
169 	int events;
170 	int port;
171 };
172 #endif 
173 static prop_t *pInputName = NULL;
174 static struct cnfparamdescr modpdescr[] = {
175 	{ "pollinginterval", eCmdHdlrPositiveInt, 0 },
176 	{ "readtimeout", eCmdHdlrNonNegInt, 0 },
177 	{ "timeoutgranularity", eCmdHdlrPositiveInt, 0 },
178 	{ "sortfiles", eCmdHdlrBinary, 0 },
179 <a name="0"></a>	{ "statefile.directory", eCmdHdlrString, 0 },
180 	{ "normalizepath", eCmdHdlrBinary, 0 },
181 	{ "mode", eCmdHdlrGetWord, 0 }
182 <font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>};
183 static struct cnfparamblk modpblk =
184 	{ CNFPARAMBLK_VERSION,
185 	  sizeof(modpdescr)/sizeof(struct cnfparamdescr),
186 	  modpdescr
187 	};
188 static struct cnfparamdescr inppdescr[] = {
189 	{ "file", eCmdHdlrString, CNFPARAM_REQUIRED },
190 	{ "tag", eCmdHdlrString, CNFPARAM_REQUIRED },
191 	{ "severity", eCmdHdlrSeverity, 0 },
192 	{ "facility", eCmdHdlrFacility, 0 },
193 	{ "ruleset", eCmdHdlrString, 0 },
194 	{ "readmode", eCmdHdlrInt, 0 },
195 	{ "startmsg.regex", eCmdHdlrString, 0 },
196 	{ "endmsg.regex", eCmdHdlrString, 0 },</b></font>
197 	{ "discardtruncatedmsg", eCmdHdlrBinary, 0 },
198 	{ "msgdiscardingerror", eCmdHdlrBinary, 0 },
199 	{ "escapelf", eCmdHdlrBinary, 0 },
200 	{ "escapelf.replacement", eCmdHdlrString, 0 },
201 	{ "reopenontruncate", eCmdHdlrBinary, 0 },
202 	{ "maxlinesatonce", eCmdHdlrInt, 0 },
203 	{ "trimlineoverbytes", eCmdHdlrInt, 0 },
204 	{ "maxsubmitatonce", eCmdHdlrInt, 0 },
205 	{ "removestateondelete", eCmdHdlrBinary, 0 },
206 	{ "persiststateinterval", eCmdHdlrInt, 0 },
207 	{ "persiststateaftersubmission", eCmdHdlrBinary, 0 },
208 	{ "deletestateonfiledelete", eCmdHdlrBinary, 0 },
209 	{ "delay.message", eCmdHdlrNonNegInt, 0 },
210 	{ "addmetadata", eCmdHdlrBinary, 0 },
211 	{ "addceetag", eCmdHdlrBinary, 0 },
212 	{ "statefile", eCmdHdlrString, CNFPARAM_DEPRECATED },
213 	{ "readtimeout", eCmdHdlrNonNegInt, 0 },
214 	{ "freshstarttail", eCmdHdlrBinary, 0},
215 	{ "filenotfounderror", eCmdHdlrBinary, 0},
216 	{ "needparse", eCmdHdlrBinary, 0},
217 	{ "ignoreolderthan", eCmdHdlrInt, 0},
218 	{ "maxbytesperminute", eCmdHdlrInt, 0},
219 	{ "maxlinesperminute", eCmdHdlrInt, 0}
220 };
221 static struct cnfparamblk inppblk =
222 	{ CNFPARAMBLK_VERSION,
223 	  sizeof(inppdescr)/sizeof(struct cnfparamdescr),
224 	  inppdescr
225 	};
226 #include "im-helper.h" 
227 #define ENABLE_V1_STATE_FILE_FORMAT_SUPPORT 1
228 #ifdef ENABLE_V1_STATE_FILE_FORMAT_SUPPORT
229 static uchar * ATTR_NONNULL(1, 2)
230 OLD_getStateFileName(const instanceConf_t *const inst,
231 	 uchar *const __restrict__ buf,
232 	 const size_t lenbuf)
233 {
234 	DBGPRINTF("OLD_getStateFileName trying '%s'\n", inst-&gt;pszFileName_forOldStateFile);
235 	snprintf((char*)buf, lenbuf - 1, "imfile-state:%s", inst-&gt;pszFileName_forOldStateFile);
236 	buf[lenbuf-1] = '\0'; 	uchar *p = buf;
237 	for( ; *p ; ++p) {
238 		if(*p == '/')
239 			*p = '-';
240 	}
241 	return buf;
242 }
243 static const uchar *
244 getStateFileDir(void)
245 {
246 	const uchar *wrkdir;
247 	assert(currModConf != NULL);
248 	if(currModConf-&gt;stateFileDirectory == NULL) {
249 		wrkdir = glblGetWorkDirRaw(currModConf-&gt;pConf);
250 	} else {
251 		wrkdir = currModConf-&gt;stateFileDirectory;
252 	}
253 	return(wrkdir);
254 }
255 static rsRetVal ATTR_NONNULL(1)
256 OLD_openFileWithStateFile(act_obj_t *const act)
257 {
258 	DEFiRet;
259 	strm_t *psSF = NULL;
260 	uchar pszSFNam[MAXFNAME];
261 	size_t lenSFNam;
262 	struct stat stat_buf;
263 	uchar statefile[MAXFNAME];
264 	const instanceConf_t *const inst = act-&gt;edge-&gt;instarr[0];
265 	uchar *const statefn = OLD_getStateFileName(inst, statefile, sizeof(statefile));
266 	DBGPRINTF("OLD_openFileWithStateFile: trying to open state for '%s', state file '%s'\n",
267 		  act-&gt;name, statefn);
268 	lenSFNam = getFullStateFileName(statefn, "", pszSFNam, sizeof(pszSFNam));
269 	if(stat((char*) pszSFNam, &amp;stat_buf) == -1) {
270 		if(errno == ENOENT) {
271 			DBGPRINTF("OLD_openFileWithStateFile: NO state file (%s) exists for '%s'\n",
272 				pszSFNam, act-&gt;name);
273 			ABORT_FINALIZE(RS_RET_FILE_NOT_FOUND);
274 		} else {
275 			char errStr[1024];
276 			rs_strerror_r(errno, errStr, sizeof(errStr));
277 			DBGPRINTF("OLD_openFileWithStateFile: error trying to access state "
278 				"file for '%s':%s\n", act-&gt;name, errStr);
279 			ABORT_FINALIZE(RS_RET_IO_ERROR);
280 		}
281 	}
282 	DBGPRINTF("old state file found - instantiating from it\n");
283 	CHKiRet(strm.Construct(&amp;psSF));
284 	CHKiRet(strm.SettOperationsMode(psSF, STREAMMODE_READ));
285 	CHKiRet(strm.SetsType(psSF, STREAMTYPE_FILE_SINGLE));
286 	CHKiRet(strm.SetFName(psSF, pszSFNam, lenSFNam));
287 	CHKiRet(strm.SetFileNotFoundError(psSF, inst-&gt;fileNotFoundError));
288 	CHKiRet(strm.ConstructFinalize(psSF));
289 	CHKiRet(obj.Deserialize(&amp;act-&gt;pStrm, (uchar*) "strm", psSF, NULL, act));
290 	free(act-&gt;pStrm-&gt;pszFName);
291 	CHKmalloc(act-&gt;pStrm-&gt;pszFName = ustrdup(act-&gt;name));
292 	strm.CheckFileChange(act-&gt;pStrm);
293 	CHKiRet(strm.SeekCurrOffs(act-&gt;pStrm));
294 	persistStrmState(act);
295 	unlink((char*)pszSFNam);
296 finalize_it:
297 	if(psSF != NULL)
298 		strm.Destruct(&amp;psSF);
299 	RETiRet;
300 }
301 #endif 
302 #if 0 static const char * ATTR_NONNULL()
303 gen_full_name(const char *const dirname, const char *const name)
304 {
305 	const size_t len_full_name = strlen(dirname) + 1 + strlen(name) + 1;
306 	char *const full_name = malloc(len_full_name);
307 	if(full_name == NULL)
308 		return NULL;
309 	snprintf(full_name, len_full_name, "%s/%s", dirname, name);
310 	return full_name;
311 }
312 #endif
313 #ifdef HAVE_INOTIFY_INIT
314 #if ULTRA_DEBUG == 1
315 static void
316 dbg_wdmapPrint(const char *msg)
317 {
318 	int i;
319 	DBGPRINTF("%s\n", msg);
320 	for(i = 0 ; i &lt; nWdmap ; ++i)
321 		DBGPRINTF("wdmap[%d]: wd: %d, act %p, name: %s\n",
322 			i, wdmap[i].wd, wdmap[i].act, wdmap[i].act-&gt;name);
323 }
324 #endif
325 static rsRetVal
326 wdmapInit(void)
327 {
328 	DEFiRet;
329 	free(wdmap);
330 	CHKmalloc(wdmap = malloc(sizeof(wd_map_t) * INIT_WDMAP_TAB_SIZE));
331 	allocMaxWdmap = INIT_WDMAP_TAB_SIZE;
332 	nWdmap = 0;
333 finalize_it:
334 	RETiRet;
335 }
336 static rsRetVal
337 wdmapAdd(int wd, act_obj_t *const act)
338 {
339 	wd_map_t *newmap;
340 	int newmapsize;
341 	int i;
342 	DEFiRet;
343 	for(i = nWdmap-1 ; i &gt;= 0 &amp;&amp; wdmap[i].wd &gt; wd ; --i)
344 		; 		if(i &gt;= 0 &amp;&amp; wdmap[i].wd == wd) {
345 		LogError(0, RS_RET_INTERNAL_ERROR, "imfile: wd %d already in wdmap!", wd);
346 		ABORT_FINALIZE(RS_RET_FILE_ALREADY_IN_TABLE);
347 	}
348 	++i;
349 	if(nWdmap == allocMaxWdmap) {
350 		newmapsize = 2 * allocMaxWdmap;
351 		CHKmalloc(newmap = realloc(wdmap, sizeof(wd_map_t) * newmapsize));
352 		wdmap = newmap;
353 		allocMaxWdmap = newmapsize;
354 	}
355 	if(i &lt; nWdmap) {
356 		memmove(wdmap + i + 1, wdmap + i, sizeof(wd_map_t) * (nWdmap - i));
357 	}
358 	wdmap[i].wd = wd;
359 	wdmap[i].act = act;
360 	++nWdmap;
361 	DBGPRINTF("add wdmap[%d]: wd %d, act obj %p, path %s\n", i, wd, act, act-&gt;name);
362 finalize_it:
363 	RETiRet;
364 }
365 static int
366 in_setupWatch(act_obj_t *const act, const int is_file)
367 {
368 	int wd = -1;
369 	if(runModConf-&gt;opMode != OPMODE_INOTIFY)
370 		goto done;
371 	wd = inotify_add_watch(ino_fd, act-&gt;name,
372 		(is_file) ? IN_MODIFY|IN_DONT_FOLLOW : IN_CREATE|IN_DELETE|IN_MOVED_FROM|IN_MOVED_TO);
373 	if(wd &lt; 0) {
374 		if (errno == EACCES) { 			DBGPRINTF("imfile: permission denied when adding watch for '%s'\n", act-&gt;name);
375 		} else {
376 			LogError(errno, RS_RET_IO_ERROR, "imfile: cannot watch object '%s'", act-&gt;name);
377 		}
378 		goto done;
379 	}
380 	wdmapAdd(wd, act);
381 	DBGPRINTF("in_setupWatch: watch %d added for %s(object %p)\n", wd, act-&gt;name, act);
382 done:	return wd;
383 }
384 static int
385 wdmap_cmp(const void *k, const void *a)
386 {
387 	int key = *((int*) k);
388 	wd_map_t *etry = (wd_map_t*) a;
389 	if(key &lt; etry-&gt;wd)
390 		return -1;
391 	else if(key &gt; etry-&gt;wd)
392 		return 1;
393 	else
394 		return 0;
395 }
396 static wd_map_t *
397 wdmapLookup(int wd)
398 {
399 	return bsearch(&amp;wd, wdmap, nWdmap, sizeof(wd_map_t), wdmap_cmp);
400 }
401 static rsRetVal
402 wdmapDel(const int wd)
403 {
404 	int i;
405 	DEFiRet;
406 	for(i = 0 ; i &lt; nWdmap &amp;&amp; wdmap[i].wd &lt; wd ; ++i)
407 		; 		if(i == nWdmap ||  wdmap[i].wd != wd) {
408 		DBGPRINTF("wd %d shall be deleted but not in wdmap!\n", wd);
409 		FINALIZE;
410 	}
411 	if(i &lt; nWdmap-1) {
412 		memmove(wdmap + i, wdmap + i + 1, sizeof(wd_map_t) * (nWdmap - i - 1));
413 	}
414 	--nWdmap;
415 	DBGPRINTF("wd %d deleted, was idx %d\n", wd, i);
416 finalize_it:
417 	RETiRet;
418 }
419 #endif 
420 #if defined(OS_SOLARIS) &amp;&amp; defined (HAVE_PORT_SOURCE_FILE)
421 static void ATTR_NONNULL()
422 fen_setupWatch(act_obj_t *const act)
423 {
424 	DBGPRINTF("fen_setupWatch: enter, opMode %d\n", runModConf-&gt;opMode);
425 	if(runModConf-&gt;opMode != OPMODE_FEN)
426 		goto done;
427 	DBGPRINTF("fen_setupWatch: %s\n", act-&gt;name);
428 	if(act-&gt;pfinf == NULL) {
429 		act-&gt;pfinf = malloc(sizeof(struct fileinfo));
430 		if (act-&gt;pfinf == NULL) {
431 			LogError(errno, RS_RET_OUT_OF_MEMORY, "imfile: fen_setupWatch alloc memory "
432 				"for fileinfo failed ");
433 			goto done;
434 		}
435 		if ((act-&gt;pfinf-&gt;fobj.fo_name = strdup(act-&gt;name)) == NULL) {
436 			LogError(errno, RS_RET_OUT_OF_MEMORY, "imfile: fen_setupWatch alloc memory "
437 				"for strdup failed ");
438 			free(act-&gt;pfinf);
439 			act-&gt;pfinf = NULL;
440 			goto done;
441 		}
442 		act-&gt;pfinf-&gt;events = FILE_MODIFIED;
443 		act-&gt;pfinf-&gt;port = glport;
444 		act-&gt;bPortAssociated = 0;
445 	}
446 	DBGPRINTF("fen_setupWatch: bPortAssociated %d\n", act-&gt;bPortAssociated);
447 	if(act-&gt;bPortAssociated) {
448 		goto done;
449 	}
450 	struct stat fileInfo;
451 	const int r = stat(act-&gt;name, &amp;fileInfo);
452 	if(r == -1) { 		DBGPRINTF("fen_setupWatch: file gone away, no watch: '%s'\n", act-&gt;name);
453 		goto done;
454 	}
455 	act-&gt;pfinf-&gt;fobj.fo_atime = fileInfo.st_atim;
456 	act-&gt;pfinf-&gt;fobj.fo_mtime = fileInfo.st_mtim;
457 	act-&gt;pfinf-&gt;fobj.fo_ctime = fileInfo.st_ctim;
458 	if(port_associate(glport, PORT_SOURCE_FILE, (uintptr_t)&amp;(act-&gt;pfinf-&gt;fobj),
459 				act-&gt;pfinf-&gt;events, (void *)act) == -1) {
460 		LogError(errno, RS_RET_SYS_ERR, "fen_setupWatch: Failed to associate port for file "
461 			": %s\n", act-&gt;pfinf-&gt;fobj.fo_name);
462 		goto done;
463 	} else {
464 		DBGPRINTF("fen_setupWatch: associated port for file %s\n", act-&gt;name);
465 		act-&gt;bPortAssociated = 1;
466 	}
467 	DBGPRINTF("in_setupWatch: fen association added for %s\n", act-&gt;name);
468 done:	return;
469 }
470 #else
471 static void ATTR_NONNULL()
472 fen_setupWatch(act_obj_t *const act __attribute__((unused)))
473 {
474 	DBGPRINTF("fen_setupWatch: DUMMY CALLED - not on Solaris?\n");
475 }
476 #endif 
477 static void
478 fs_node_print(const fs_node_t *const node, const int level)
479 {
480 	fs_edge_t *chld;
481 	act_obj_t *act;
482 	dbgprintf("node print[%2.2d]: %p edges:\n", level, node);
483 	for(chld = node-&gt;edges ; chld != NULL ; chld = chld-&gt;next) {
484 		dbgprintf("node print[%2.2d]:     child %p '%s' isFile %d, path: '%s'\n",
485 			level, chld-&gt;node, chld-&gt;name, chld-&gt;is_file, chld-&gt;path);
486 		for(int i = 0 ; i &lt; chld-&gt;ninst ; ++i) {
487 			dbgprintf("\tinst: %p\n", chld-&gt;instarr[i]);
488 		}
489 		for(act = chld-&gt;active ; act != NULL ; act = act-&gt;next) {
490 			dbgprintf("\tact : %p\n", act);
491 			dbgprintf("\tact : %p: name '%s', wd: %d\n",
492 				act, act-&gt;name, act-&gt;wd);
493 		}
494 	}
495 	for(chld = node-&gt;edges ; chld != NULL ; chld = chld-&gt;next) {
496 		fs_node_print(chld-&gt;node, level+1);
497 	}
498 }
499 static sbool
500 isIgnoreOlderFile(const instanceConf_t *const inst, const char *const name)
501 {
502 	if (inst-&gt;ignoreOlderThan)
503 	{
504 		struct stat stat_buf;
505 		time_t tt;
506 		datetime.GetTime(&amp;tt);
507 		if (stat((char *)name, &amp;stat_buf) == 0 &amp;&amp; difftime(tt, stat_buf.st_mtime) &gt; inst-&gt;ignoreOlderThan) {
508 			return 1;
509 		}
510 	}
511 	return 0;
512 }
513 static rsRetVal ATTR_NONNULL(1,2)
514 act_obj_add(fs_edge_t *const edge, const char *const name, const int is_file,
515 	const ino_t ino, const int is_symlink, const char *const source)
516 {
517 	act_obj_t *act = NULL;
518 	char basename[MAXFNAME];
519 	DEFiRet;
520 	int fd = -1;
521 	DBGPRINTF("act_obj_add: edge %p, name '%s' (source '%s')\n", edge, name, source? source : "---");
522 	if (isIgnoreOlderFile(edge-&gt;instarr[0], name)) {
523 		ABORT_FINALIZE(RS_RET_ERR);
524 	}
525 	for(act = edge-&gt;active ; act != NULL ; act = act-&gt;next) {
526 		if(!strcmp(act-&gt;name, name)) {
527 			if (!source || !act-&gt;source_name || !strcmp(act-&gt;source_name, source)) {
528 				DBGPRINTF("active object '%s' already exists in '%s' - no need to add\n",
529 					name, edge-&gt;path);
530 				FINALIZE;
531 			}
532 		}
533 	}
534 	DBGPRINTF("need to add new active object '%s' in '%s' - checking if accessible\n", name, edge-&gt;path);
535 	fd = open(name, O_RDONLY | O_CLOEXEC);
536 	if(fd &lt; 0) {
537 		if (is_file) {
538 			LogError(errno, RS_RET_ERR, "imfile: error accessing file '%s'", name);
539 		} else { 			DBGPRINTF("imfile: error accessing directory '%s'", name);
540 		}
541 		ABORT_FINALIZE(RS_RET_NO_FILE_ACCESS);
542 	}
543 	DBGPRINTF("add new active object '%s' in '%s'\n", name, edge-&gt;path);
544 	CHKmalloc(act = calloc(sizeof(act_obj_t), 1));
545 	CHKmalloc(act-&gt;name = strdup(name));
546 	if (-1 == getBasename((uchar*)basename, (uchar*)name)) {
547 		CHKmalloc(act-&gt;basename = strdup(name)); 	} else {
548 		CHKmalloc(act-&gt;basename = strdup(basename));
549 	}
550 	act-&gt;edge = edge;
551 	act-&gt;ino = ino;
552 	act-&gt;fd = fd;
553 	act-&gt;file_id[0] = '\0';
554 	act-&gt;file_id_prev[0] = '\0';
555 	act-&gt;is_symlink = is_symlink;
556 	act-&gt;ratelimiter = NULL;
557 	if (source) { 		CHKmalloc(act-&gt;source_name = strdup(source));
558 	} else {
559 		act-&gt;source_name = NULL;
560 	}
561 	#ifdef HAVE_INOTIFY_INIT
562 	act-&gt;wd = in_setupWatch(act, is_file);
563 	#endif
564 	fen_setupWatch(act);
565 	if(is_file &amp;&amp; !is_symlink) {
566 		const instanceConf_t *const inst = edge-&gt;instarr[0];		CHKiRet(ratelimitNew(&amp;act-&gt;ratelimiter, "imfile", name));
567 		CHKmalloc(act-&gt;multiSub.ppMsgs = malloc(inst-&gt;nMultiSub * sizeof(smsg_t *)));
568 		act-&gt;multiSub.maxElem = inst-&gt;nMultiSub;
569 		act-&gt;multiSub.nElem = 0;
570 		pollFile(act);
571 	}
572 	if(edge-&gt;active != NULL) {
573 		edge-&gt;active-&gt;prev = act;
574 	}
575 	act-&gt;next = edge-&gt;active;
576 	edge-&gt;active = act;
577 finalize_it:
578 	if(iRet != RS_RET_OK) {
579 		if(act != NULL) {
580 			if (act-&gt;ratelimiter != NULL)
581 				ratelimitDestruct(act-&gt;ratelimiter);
582 			free(act-&gt;name);
583 			free(act);
584 		}
585 		if(fd != -1) {
586 			close(fd);
587 		}
588 	}
589 	RETiRet;
590 }
591 static void
592 detect_updates(fs_edge_t *const edge)
593 {
594 	act_obj_t *act;
595 	struct stat fileInfo;
596 	int restart = 0;
597 	for(act = edge-&gt;active ; act != NULL ; act = act-&gt;next) {
598 		DBGPRINTF("detect_updates checking active obj '%s'\n", act-&gt;name);
599 		const int r = lstat(act-&gt;name, &amp;fileInfo);
600 		if(r == -1) { 			DBGPRINTF("object gone away, unlinking: '%s'\n", act-&gt;name);
601 			act_obj_unlink(act);
602 			restart = 1;
603 			break;
604 		} else if(fileInfo.st_ino != act-&gt;ino) {
605 			DBGPRINTF("file '%s' inode changed from %llu to %llu, unlinking from "
606 				"internal lists\n", act-&gt;name, (long long unsigned) act-&gt;ino,
607 				(long long unsigned) fileInfo.st_ino);
608 			if(act-&gt;pStrm != NULL) {
609 				strmSet_checkRotation(act-&gt;pStrm, STRM_ROTATION_DO_NOT_CHECK);
610 			}
611 			act_obj_unlink(act);
612 			restart = 1;
613 			break;
614 		}
615 	}
616 	if (restart) {
617 		detect_updates(edge);
618 	}
619 }
620 static void ATTR_NONNULL()
621 poll_active_files(fs_edge_t *const edge)
622 {
623 	if(   runModConf-&gt;opMode != OPMODE_POLLING
624 	   || !edge-&gt;is_file
625 	   || glbl.GetGlobalInputTermState() != 0) {
626 		return;
627 	}
628 	act_obj_t *act;
629 	for(act = edge-&gt;active ; act != NULL ; act = act-&gt;next) {
630 		fen_setupWatch(act);
631 		DBGPRINTF("poll_active_files: polling '%s'\n", act-&gt;name);
632 		pollFile(act);
633 	}
634 }
635 static rsRetVal ATTR_NONNULL()
636 process_symlink(fs_edge_t *const chld, const char *symlink)
637 {
638 	DEFiRet;
639 	char *target;
640 	CHKmalloc(target = realpath(symlink, NULL));
641 	struct stat fileInfo;
642 	if(lstat(target, &amp;fileInfo) != 0) {
643 		LogError(errno, RS_RET_ERR,	"imfile: process_symlink: cannot stat file '%s' - ignored", target);
644 		FINALIZE;
645 	}
646 	const int is_file = (S_ISREG(fileInfo.st_mode));
647 	DBGPRINTF("process_symlink:  found '%s', File: %d (config file: %d), symlink: %d\n",
648 		target, is_file, chld-&gt;is_file, 0);
649 	if (act_obj_add(chld, target, is_file, fileInfo.st_ino, 0, symlink) == RS_RET_OK) {
650 		uint idx = ustrlen(chld-&gt;active-&gt;name) - ustrlen(chld-&gt;active-&gt;basename);
651 		if (idx) { 			char parent[MAXFNAME];
652 			idx--; 			memcpy(parent, chld-&gt;active-&gt;name, idx);
653 			parent[idx] = '\0';
654 			if(lstat(parent, &amp;fileInfo) != 0) {
655 				LogError(errno, RS_RET_ERR,
656 					"imfile: process_symlink: cannot stat directory '%s' - ignored", parent);
657 				FINALIZE;
658 			}
659 			if (chld-&gt;parent-&gt;root-&gt;edges) {
660 				DBGPRINTF("process_symlink: adding parent '%s' of target '%s'\n", parent, target);
661 				act_obj_add(chld-&gt;parent-&gt;root-&gt;edges, parent, 0, fileInfo.st_ino, 0, NULL);
662 			}
663 		}
664 	}
665 finalize_it:
666 	free(target);
667 	RETiRet;
668 }
669 static void ATTR_NONNULL()
670 poll_tree(fs_edge_t *const chld)
671 {
672 	struct stat fileInfo;
673 	glob_t files;
674 	int need_globfree = 0;
675 	int issymlink;
676 	DBGPRINTF("poll_tree: chld %p, name '%s', path: %s\n", chld, chld-&gt;name, chld-&gt;path);
677 	detect_updates(chld);
678 	const int ret = glob((char*)chld-&gt;path, runModConf-&gt;sortFiles|GLOB_BRACE, NULL, &amp;files);
679 	need_globfree = 1;
680 	DBGPRINTF("poll_tree: glob returned %d\n", ret);
681 	if(ret == 0) {
682 		DBGPRINTF("poll_tree: processing %d files\n", (int) files.gl_pathc);
683 		for(unsigned i = 0 ; i &lt; files.gl_pathc ; i++) {
684 			if(glbl.GetGlobalInputTermState() != 0) {
685 				goto done;
686 			}
687 			char *const file = files.gl_pathv[i];
688 			if(lstat(file, &amp;fileInfo) != 0) {
689 				LogError(errno, RS_RET_ERR,
690 					"imfile: poll_tree cannot stat file '%s' - ignored", file);
691 				continue;
692 			}
693 			if (S_ISLNK(fileInfo.st_mode)) {
694 				rsRetVal slink_ret = process_symlink(chld, file);
695 				if (slink_ret != RS_RET_OK) {
696 					continue;
697 				}
698 				issymlink = 1;
699 			} else {
700 				issymlink = 0;
701 			}
702 			const int is_file = (S_ISREG(fileInfo.st_mode) || issymlink);
703 			DBGPRINTF("poll_tree:  found '%s', File: %d (config file: %d), symlink: %d\n",
704 				file, is_file, chld-&gt;is_file, issymlink);
705 			if(!is_file &amp;&amp; S_ISREG(fileInfo.st_mode)) {
706 				LogMsg(0, RS_RET_ERR, LOG_WARNING,
707 					"imfile: '%s' is neither a regular file, symlink, nor a "
708 					"directory - ignored", file);
709 				continue;
710 			}
711 			if(!issymlink &amp;&amp; (chld-&gt;is_file != is_file)) {
712 				LogMsg(0, RS_RET_ERR, LOG_WARNING,
713 					"imfile: '%s' is %s but %s expected - ignored",
714 					file, (is_file) ? "FILE" : "DIRECTORY",
715 					(chld-&gt;is_file) ? "FILE" : "DIRECTORY");
716 				continue;
717 			}
718 			act_obj_add(chld, file, is_file, fileInfo.st_ino, issymlink, NULL);
719 		}
720 	}
721 	poll_active_files(chld);
722 done:
723 	if(need_globfree) {
724 		globfree(&amp;files);
725 	}
726 	return;
727 }
728 #ifdef HAVE_INOTIFY_INIT static void ATTR_NONNULL()
729 poll_timeouts(fs_edge_t *const edge)
730 {
731 	if(edge-&gt;is_file) {
732 		act_obj_t *act;
733 		for(act = edge-&gt;active ; act != NULL ; act = act-&gt;next) {
734 			if(act-&gt;pStrm &amp;&amp; strmReadMultiLine_isTimedOut(act-&gt;pStrm)) {
735 				DBGPRINTF("timeout occurred on %s\n", act-&gt;name);
736 				pollFile(act);
737 			}
738 		}
739 	}
740 }
741 #endif
742 static void
743 act_obj_destroy(act_obj_t *const act, const int is_deleted)
744 {
745 	uchar *statefn;
746 	uchar statefile[MAXFNAME];
747 	uchar toDel[MAXFNAME];
748 	if(act == NULL)
749 		return;
750 	DBGPRINTF("act_obj_destroy: act %p '%s' (source '%s'), wd %d, pStrm %p, is_deleted %d, in_move %d\n",
751 		act, act-&gt;name, act-&gt;source_name? act-&gt;source_name : "---", act-&gt;wd, act-&gt;pStrm, is_deleted,
752 		act-&gt;in_move);
753 	if(act-&gt;is_symlink &amp;&amp; is_deleted) {
754 		act_obj_t *target_act;
755 		for(target_act = act-&gt;edge-&gt;active ; target_act != NULL ; target_act = target_act-&gt;next) {
756 			if(target_act-&gt;source_name &amp;&amp; !strcmp(target_act-&gt;source_name, act-&gt;name)) {
757 				DBGPRINTF("act_obj_destroy: unlinking slink target %s of %s "
758 						"symlink\n", target_act-&gt;name, act-&gt;name);
759 				act_obj_unlink(target_act);
760 				break;
761 			}
762 		}
763 	}
764 	if(act-&gt;pStrm != NULL) {
765 		const instanceConf_t *const inst = act-&gt;edge-&gt;instarr[0];		pollFile(act); 		if(inst-&gt;bRMStateOnDel) {
766 			statefn = getStateFileName(act, statefile, sizeof(statefile));
767 			getFullStateFileName(statefn, act-&gt;file_id, toDel, sizeof(toDel)); 			statefn = toDel;
768 		}
769 		persistStrmState(act);
770 		strm.Destruct(&amp;act-&gt;pStrm);
771 		if(is_deleted &amp;&amp; !act-&gt;in_move &amp;&amp; inst-&gt;bRMStateOnDel) {
772 			DBGPRINTF("act_obj_destroy: deleting state file %s\n", statefn);
773 <a name="6"></a>			unlink((char*)statefn);
774 		}
775 	}
776 <font color="#8c8774"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>	if(act-&gt;ratelimiter != NULL) {
777 		ratelimitDestruct(act-&gt;ratelimiter);
778 	}
779 	#ifdef HAVE_INOTIFY_INIT
780 	if(act-&gt;wd != -1) {
781 		inotify_rm_watch(ino_fd, act-&gt;wd);
782 		wdmapDel(act-&gt;wd);
783 	}
784 	#endif
785 	if(act-&gt;fd &gt;= 0) {
786 		close(act-&gt;fd);
787 	}
788 	#if defined(OS_SOLARIS) &amp;&amp; defined (HAVE_PORT_SOURCE_FILE)
789 	if(act-&gt;pfinf != NULL) {
790 		free(act-&gt;pfinf-&gt;fobj.fo_name);
791 		free(act-&gt;pfinf);
792 	}
793 	#endif
794 	free(act-&gt;basename);
795 	free(act-&gt;source_name);
796 	free(act-&gt;multiSub.ppMsgs);
797 	#if defined(OS_SOLARIS) &amp;&amp; defined (HAVE_PORT_SOURCE_FILE)
798 		act-&gt;is_deleted = 1;</b></font>
799 	#else
800 		free(act-&gt;name);
801 		free(act);
802 	#endif
803 }
804 static void
805 act_obj_destroy_all(act_obj_t *act)
806 {
807 	if(act == NULL)
808 		return;
809 	DBGPRINTF("act_obj_destroy_all: act %p '%s', wd %d, pStrm %p\n", act, act-&gt;name, act-&gt;wd, act-&gt;pStrm);
810 	while(act != NULL) {
811 		act_obj_t *const toDel = act;
812 		act = act-&gt;next;
813 		act_obj_destroy(toDel, 0);
814 	}
815 }
816 #if 0
817 static void
818 chk_active(const act_obj_t *act, const act_obj_t *const deleted)
819 {
820 	while(act != NULL) {
821 		DBGPRINTF("chk_active %p vs %p\n", act, deleted);
822 		if(act-&gt;prev == deleted)
823 			DBGPRINTF("chk_active %p prev points to %p\n", act, deleted);
824 		if(act-&gt;next == deleted)
825 			DBGPRINTF("chk_active %p next points to %p\n", act, deleted);
826 		act = act-&gt;next;
827 		DBGPRINTF("chk_active next %p\n", act);
828 	}
829 }
830 #endif
831 static void ATTR_NONNULL()
832 act_obj_unlink(act_obj_t *act)
833 {
834 	DBGPRINTF("act_obj_unlink %p: %s, pStrm %p\n", act, act-&gt;name, act-&gt;pStrm);
835 	if(act-&gt;prev == NULL) {
836 		act-&gt;edge-&gt;active = act-&gt;next;
837 	} else {
838 		act-&gt;prev-&gt;next = act-&gt;next;
839 	}
840 	if(act-&gt;next != NULL) {
841 		act-&gt;next-&gt;prev = act-&gt;prev;
842 	}
843 	act_obj_destroy(act, 1);
844 	act = NULL;
845 }
846 static void
847 fs_node_destroy(fs_node_t *const node)
848 {
849 	fs_edge_t *edge;
850 	DBGPRINTF("node destroy: %p edges:\n", node);
851 	for(edge = node-&gt;edges ; edge != NULL ; ) {
852 		fs_node_destroy(edge-&gt;node);
853 		fs_edge_t *const toDel = edge;
854 		edge = edge-&gt;next;
855 		act_obj_destroy_all(toDel-&gt;active);
856 		free(toDel-&gt;name);
857 		free(toDel-&gt;path);
858 		free(toDel-&gt;instarr);
859 		free(toDel);
860 	}
861 	free(node);
862 }
863 static void ATTR_NONNULL(1, 2)
864 fs_node_walk(fs_node_t *const node,
865 	void (*f_usr)(fs_edge_t*const))
866 {
867 	DBGPRINTF("node walk: %p edges:\n", node);
868 	fs_edge_t *edge;
869 	for(edge = node-&gt;edges ; edge != NULL ; edge = edge-&gt;next) {
870 		DBGPRINTF("node walk: child %p '%s'\n", edge-&gt;node, edge-&gt;name);
871 		f_usr(edge);
872 		fs_node_walk(edge-&gt;node, f_usr);
873 	}
874 }
875 static rsRetVal
876 fs_node_add(fs_node_t *const node,
877 	fs_node_t *const source,
878 	const uchar *const toFind,
879 	const size_t pathIdx,
880 	instanceConf_t *const inst)
881 {
882 	DEFiRet;
883 	fs_edge_t *newchld = NULL;
884 	int i;
885 	DBGPRINTF("fs_node_add(%p, '%s') enter, idx %zd\n",
886 		node, toFind+pathIdx, pathIdx);
887 	assert(toFind[0] != '\0');
888 	for(i = pathIdx ; (toFind[i] != '\0') &amp;&amp; (toFind[i] != '/') ; ++i)
889 	const int isFile = (toFind[i] == '\0') ? 1 : 0;
890 	uchar ourPath[PATH_MAX];
891 	if(i == 0) {
892 		ourPath[0] = '/';
893 		ourPath[1] = '\0';
894 	} else {
895 		memcpy(ourPath, toFind, i);
896 		ourPath[i] = '\0';
897 	}
898 	const size_t nextPathIdx = i+1;
899 	const size_t len = i - pathIdx;
900 	uchar name[PATH_MAX];
901 	memcpy(name, toFind+pathIdx, len);
902 	name[len] = '\0';
903 	DBGPRINTF("fs_node_add: name '%s'\n", name);
904 	node-&gt;root = source;
905 	fs_edge_t *chld;
906 	for(chld = node-&gt;edges ; chld != NULL ; chld = chld-&gt;next) {
907 		if(!ustrcmp(chld-&gt;name, name)) {
908 			DBGPRINTF("fs_node_add(%p, '%s') found '%s'\n", chld-&gt;node, toFind, name);
909 			instanceConf_t **instarr_new = realloc(chld-&gt;instarr,
910 							sizeof(instanceConf_t*) * (chld-&gt;ninst+1));
911 			CHKmalloc(instarr_new);
912 			chld-&gt;instarr = instarr_new;
913 			chld-&gt;ninst++;
914 			chld-&gt;instarr[chld-&gt;ninst-1] = inst;
915 			if(!isFile) {
916 				CHKiRet(fs_node_add(chld-&gt;node, node, toFind, nextPathIdx, inst));
917 			}
918 			FINALIZE;
919 		}
920 	}
921 	DBGPRINTF("fs_node_add(%p, '%s') did not find '%s' - adding it\n",
922 		node, toFind, name);
923 	CHKmalloc(newchld = calloc(sizeof(fs_edge_t), 1));
924 	CHKmalloc(newchld-&gt;name = ustrdup(name));
925 	CHKmalloc(newchld-&gt;node = calloc(sizeof(fs_node_t), 1));
926 	CHKmalloc(newchld-&gt;path = ustrdup(ourPath));
927 	CHKmalloc(newchld-&gt;instarr = calloc(sizeof(instanceConf_t*), 1));
928 	newchld-&gt;instarr[0] = inst;
929 	newchld-&gt;is_file = isFile;
930 	newchld-&gt;ninst = 1;
931 	newchld-&gt;parent = node;
932 	DBGPRINTF("fs_node_add(%p, '%s') returns %p\n", node, toFind, newchld-&gt;node);
933 	if(!isFile) {
934 		CHKiRet(fs_node_add(newchld-&gt;node, node, toFind, nextPathIdx, inst));
935 	}
936 	newchld-&gt;next = node-&gt;edges;
937 	node-&gt;edges = newchld;
938 finalize_it:
939 	if(iRet != RS_RET_OK) {
940 		if(newchld != NULL) {
941 		free(newchld-&gt;name);
942 		free(newchld-&gt;node);
943 		free(newchld-&gt;path);
944 		free(newchld-&gt;instarr);
945 		free(newchld);
946 		}
947 	}
948 	RETiRet;
949 }
950 static int ATTR_NONNULL()
951 getFullStateFileName(const uchar *const pszstatefile,
952 	const char *const file_id,
953 	uchar *const pszout,
954 	const size_t ilenout)
955 {
956 	int lenout;
957 	const uchar* pszstatedir;
958 	pszstatedir = getStateFileDir();
959 	lenout = snprintf((char*)pszout, ilenout, "%s/%s%s%s",
960 		(char*) (pszstatedir == NULL ? "." : (char*) pszstatedir), (char*)pszstatefile,
961 		(*file_id == '\0') ? "" : ":", file_id);
962 	return lenout;
963 }
964 #if defined(__clang__)
965 #pragma GCC diagnostic ignored "-Wunknown-attributes"
966 #endif
967 static void __attribute__((nonnull(1,3)))
968 #if defined(__clang__)
969 __attribute__((no_sanitize("unsigned-integer-overflow")))
970 #endif
971 get_file_id_hash(const char *data, size_t lendata,
972 	char *const hash_str, const size_t len_hash_str)
973 {
974 	assert(len_hash_str &gt;= 17); 
975 	size_t i;
976 	uint8_t out[8], k[16];
977 	for (i = 0; i &lt; 16; ++i)
978 		k[i] = i;
979 	memset(out, 0, sizeof(out));
980 	rs_siphash((const uint8_t *)data, lendata, k, out, 8);
981 	for(i = 0 ; i &lt; 8 ; ++i) {
982 		if(2 * i+1 &gt;= len_hash_str)
983 			break;
984 		snprintf(hash_str+(2*i), 3, "%2.2x", out[i]);
985 	}
986 }
987 static void ATTR_NONNULL(1)
988 getFileID(act_obj_t *const act)
989 {
990 	char tmp_id[FILE_ID_HASH_SIZE];
991 	strncpy(tmp_id, (const char*)act-&gt;file_id, FILE_ID_HASH_SIZE);
992 	act-&gt;file_id[0] = '\0';
993 	assert(act-&gt;fd &gt;= 0); 	char filedata[FILE_ID_SIZE];
994 	lseek(act-&gt;fd, 0, SEEK_SET); 	const int r = read(act-&gt;fd, filedata, FILE_ID_SIZE);
995 	if(r == FILE_ID_SIZE) {
996 		get_file_id_hash(filedata, sizeof(filedata), act-&gt;file_id, sizeof(act-&gt;file_id));
997 	} else {
998 		DBGPRINTF("getFileID partial or error read, ret %d\n", r);
999 	}
1000 	if (strncmp(tmp_id, act-&gt;file_id, FILE_ID_HASH_SIZE)) {		strncpy(act-&gt;file_id_prev, tmp_id, FILE_ID_HASH_SIZE);
1001 	}
1002 	DBGPRINTF("getFileID for '%s', file_id_hash '%s'\n", act-&gt;name, act-&gt;file_id);
1003 }
1004 static uchar * ATTR_NONNULL(1, 2)
1005 getStateFileName(const act_obj_t *const act,
1006 	 	 uchar *const __restrict__ buf,
1007 		 const size_t lenbuf)
1008 {
1009 	DBGPRINTF("getStateFileName for '%s'\n", act-&gt;name);
1010 	snprintf((char*)buf, lenbuf - 1, "imfile-state:%lld", (long long) act-&gt;ino);
1011 	DBGPRINTF("getStateFileName:  state file name now is %s\n", buf);
1012 	return buf;
1013 }
1014 static rsRetVal
1015 checkPerMinuteRateLimits(per_minute_rate_limit_t *per_minute_rate_limits,
1016 			     const size_t msgLen)
1017 {
1018 	DEFiRet;
1019 	time_t current_minute = time(NULL)/60;
1020 	if(per_minute_rate_limits-&gt;maxBytesPerMinute) {
1021 		if (per_minute_rate_limits-&gt;rateLimitingMinute == current_minute) {
1022 			per_minute_rate_limits-&gt;bytesThisMinute += msgLen;
1023 			if (per_minute_rate_limits-&gt;bytesThisMinute &gt; per_minute_rate_limits-&gt;maxBytesPerMinute) {
1024 				ABORT_FINALIZE(RS_RET_RATE_LIMITED);
1025 			}
1026 		} else {
1027 			per_minute_rate_limits-&gt;rateLimitingMinute = current_minute;
1028 			per_minute_rate_limits-&gt;bytesThisMinute = msgLen; 		}
1029 	}
1030 	if(per_minute_rate_limits-&gt;maxLinesPerMinute) {
1031 		if (per_minute_rate_limits-&gt;rateLimitingMinute == current_minute) {
1032 			per_minute_rate_limits-&gt;linesThisMinute++;
1033 			if (per_minute_rate_limits-&gt;linesThisMinute &gt; per_minute_rate_limits-&gt;maxLinesPerMinute) {
1034 				ABORT_FINALIZE(RS_RET_RATE_LIMITED);
1035 			}
1036 		} else {
1037 			per_minute_rate_limits-&gt;rateLimitingMinute = current_minute;
1038 			per_minute_rate_limits-&gt;linesThisMinute = 1; 		}
1039 	}
1040 finalize_it:
1041 	RETiRet;
1042 }
1043 #define MAX_OFFSET_REPRESENTATION_NUM_BYTES 20
1044 static rsRetVal ATTR_NONNULL(1,2)
1045 enqLine(act_obj_t *const act,
1046 	cstr_t *const __restrict__ cstrLine,
1047 	const int64 strtOffs)
1048 {
1049 	DEFiRet;
1050 	const instanceConf_t *const inst = act-&gt;edge-&gt;instarr[0];	smsg_t *pMsg;
1051 	uchar file_offset[MAX_OFFSET_REPRESENTATION_NUM_BYTES+1];
1052 	const uchar *metadata_names[2] = {(uchar *)"filename",(uchar *)"fileoffset"} ;
1053 	const uchar *metadata_values[2] ;
1054 	const size_t msgLen = cstrLen(cstrLine);
1055 	if(msgLen == 0) {
1056 		FINALIZE;
1057 	}
1058 	CHKiRet(msgConstruct(&amp;pMsg));
1059 	MsgSetFlowControlType(pMsg, eFLOWCTL_FULL_DELAY);
1060 	MsgSetInputName(pMsg, pInputName);
1061 	if(inst-&gt;addCeeTag) {
1062 		size_t ceeMsgSize = msgLen + CONST_LEN_CEE_COOKIE + 1;
1063 		char *ceeMsg;
1064 		CHKmalloc(ceeMsg = malloc(ceeMsgSize));
1065 		strcpy(ceeMsg, CONST_CEE_COOKIE);
1066 		strcat(ceeMsg, (char*)rsCStrGetSzStrNoNULL(cstrLine));
1067 		MsgSetRawMsg(pMsg, ceeMsg, ceeMsgSize);
1068 		free(ceeMsg);
1069 	} else {
1070 		MsgSetRawMsg(pMsg, (char*)rsCStrGetSzStrNoNULL(cstrLine), msgLen);
1071 	}
1072 	MsgSetMSGoffs(pMsg, 0);		MsgSetHOSTNAME(pMsg, glbl.GetLocalHostName(), ustrlen(glbl.GetLocalHostName()));
1073 	MsgSetTAG(pMsg, inst-&gt;pszTag, inst-&gt;lenTag);
1074 	msgSetPRI(pMsg, inst-&gt;iFacility | inst-&gt;iSeverity);
1075 	MsgSetRuleset(pMsg, inst-&gt;pBindRuleset);
1076 	if(inst-&gt;addMetadata) {
1077 		if (act-&gt;source_name) {
1078 			metadata_values[0] = (const uchar*)act-&gt;source_name;
1079 		} else {
1080 			metadata_values[0] = (const uchar*)act-&gt;name;
1081 		}
1082 		snprintf((char *)file_offset, MAX_OFFSET_REPRESENTATION_NUM_BYTES+1, "%lld", strtOffs);
1083 		metadata_values[1] = file_offset;
1084 		msgAddMultiMetadata(pMsg, metadata_names, metadata_values, 2);
1085 	}
1086 	if(inst-&gt;perMinuteRateLimits.maxBytesPerMinute || inst-&gt;perMinuteRateLimits.maxLinesPerMinute) {
1087 		CHKiRet(checkPerMinuteRateLimits((per_minute_rate_limit_t *)&amp;inst-&gt;perMinuteRateLimits, msgLen));
1088 	}
1089 	if(inst-&gt;delay_perMsg) {
1090 		srSleep(inst-&gt;delay_perMsg % 1000000, inst-&gt;delay_perMsg / 1000000);
1091 	}
1092 	pMsg-&gt;msgFlags = pMsg-&gt;msgFlags | inst-&gt;msgFlag;
1093 	ratelimitAddMsg(act-&gt;ratelimiter, &amp;act-&gt;multiSub, pMsg);
1094 finalize_it:
1095 	RETiRet;
1096 }
1097 static rsRetVal ATTR_NONNULL(1)
1098 openFileWithStateFile(act_obj_t *const act)
1099 {
1100 	DEFiRet;
1101 	uchar pszSFNam[MAXFNAME];
1102 	uchar statefile[MAXFNAME];
1103 	int fd = -1;
1104 	const instanceConf_t *const inst = act-&gt;edge-&gt;instarr[0];
1105 	uchar *const statefn = getStateFileName(act, statefile, sizeof(statefile));
1106 	getFileID(act);
1107 	getFullStateFileName(statefn, act-&gt;file_id, pszSFNam, sizeof(pszSFNam));
1108 	DBGPRINTF("trying to open state for '%s', state file '%s'\n", act-&gt;name, pszSFNam);
1109 	fd = open((char*)pszSFNam, O_CLOEXEC | O_NOCTTY | O_RDONLY, 0600);
1110 	if(fd &lt; 0) {
1111 		if(errno == ENOENT) {
1112 			if(act-&gt;file_id[0] != '\0') {
1113 				DBGPRINTF("state file %s for %s does not exist - trying to see if "
1114 					"inode-only file exists\n", pszSFNam, act-&gt;name);
1115 				getFullStateFileName(statefn, "", pszSFNam, sizeof(pszSFNam));
1116 				fd = open((char*)pszSFNam, O_CLOEXEC | O_NOCTTY | O_RDONLY, 0600);
1117 				if(fd &gt;= 0) {
1118 					dbgprintf("found inode-only state file, will be renamed at next persist\n");
1119 				}
1120 			}
1121 			if(fd &lt; 0) {
1122 				DBGPRINTF("state file %s for %s does not exist - trying to see if "
1123 					"old-style file exists\n", pszSFNam, act-&gt;name);
1124 				CHKiRet(OLD_openFileWithStateFile(act));
1125 				FINALIZE;
1126 			}
1127 		} else {
1128 			LogError(errno, RS_RET_IO_ERROR,
1129 				"imfile error trying to access state file for '%s'",
1130 			        act-&gt;name);
1131 			ABORT_FINALIZE(RS_RET_IO_ERROR);
1132 		}
1133 	}
1134 	DBGPRINTF("opened state file %s for %s\n", pszSFNam, act-&gt;name);
1135 	CHKiRet(strm.Construct(&amp;act-&gt;pStrm));
1136 	struct json_object *jval;
1137 	struct json_object *json = fjson_object_from_fd(fd);
1138 	if(json == NULL) {
1139 		LogError(0, RS_RET_ERR, "imfile: error reading state file for '%s'", act-&gt;name);
1140 	}
1141 	fjson_object_object_get_ex(json, "prev_was_nl", &amp;jval);
1142 	act-&gt;pStrm-&gt;bPrevWasNL = fjson_object_get_int(jval);
1143 	fjson_object_object_get_ex(json, "curr_offs", &amp;jval);
1144 	act-&gt;pStrm-&gt;iCurrOffs = fjson_object_get_int64(jval);
1145 	fjson_object_object_get_ex(json, "strt_offs", &amp;jval);
1146 	act-&gt;pStrm-&gt;strtOffs = fjson_object_get_int64(jval);
1147 	fjson_object_object_get_ex(json, "prev_line_segment", &amp;jval);
1148 	const uchar *const prev_line_segment = (const uchar*)fjson_object_get_string(jval);
1149 	if(jval != NULL) {
1150 		CHKiRet(rsCStrConstructFromszStr(&amp;act-&gt;pStrm-&gt;prevLineSegment, prev_line_segment));
1151 		cstrFinalize(act-&gt;pStrm-&gt;prevLineSegment);
1152 		uchar *ret = rsCStrGetSzStrNoNULL(act-&gt;pStrm-&gt;prevLineSegment);
1153 		DBGPRINTF("prev_line_segment present in state file 2, is: %s\n", ret);
1154 	}
1155 	fjson_object_object_get_ex(json, "prev_msg_segment", &amp;jval);
1156 	const uchar *const prev_msg_segment = (const uchar*)fjson_object_get_string(jval);
1157 	if(jval != NULL) {
1158 		CHKiRet(rsCStrConstructFromszStr(&amp;act-&gt;pStrm-&gt;prevMsgSegment, prev_msg_segment));
1159 		cstrFinalize(act-&gt;pStrm-&gt;prevMsgSegment);
1160 		uchar *ret = rsCStrGetSzStrNoNULL(act-&gt;pStrm-&gt;prevMsgSegment);
1161 		DBGPRINTF("prev_msg_segment present in state file 2, is: %s\n", ret);
1162 	}
1163 	fjson_object_put(json);
1164 	CHKiRet(strm.SetFName(act-&gt;pStrm, (uchar*)act-&gt;name, strlen(act-&gt;name)));
1165 	CHKiRet(strm.SettOperationsMode(act-&gt;pStrm, STREAMMODE_READ));
1166 	CHKiRet(strm.SetsType(act-&gt;pStrm, STREAMTYPE_FILE_MONITOR));
1167 	CHKiRet(strm.SetFileNotFoundError(act-&gt;pStrm, inst-&gt;fileNotFoundError));
1168 	CHKiRet(strm.ConstructFinalize(act-&gt;pStrm));
1169 	CHKiRet(strm.SeekCurrOffs(act-&gt;pStrm));
1170 finalize_it:
1171 	if(fd &gt;= 0) {
1172 		close(fd);
1173 	}
1174 	RETiRet;
1175 }
1176 static rsRetVal
1177 openFileWithoutStateFile(act_obj_t *const act)
1178 {
1179 	DEFiRet;
1180 	const instanceConf_t *const inst = act-&gt;edge-&gt;instarr[0];
1181 	DBGPRINTF("clean startup withOUT state file for '%s'\n", act-&gt;name);
1182 	if(act-&gt;pStrm != NULL)
1183 		strm.Destruct(&amp;act-&gt;pStrm);
1184 	CHKiRet(strm.Construct(&amp;act-&gt;pStrm));
1185 	CHKiRet(strm.SettOperationsMode(act-&gt;pStrm, STREAMMODE_READ));
1186 	CHKiRet(strm.SetsType(act-&gt;pStrm, STREAMTYPE_FILE_MONITOR));
1187 	CHKiRet(strm.SetFName(act-&gt;pStrm, (uchar*)act-&gt;name, strlen(act-&gt;name)));
1188 	CHKiRet(strm.SetFileNotFoundError(act-&gt;pStrm, inst-&gt;fileNotFoundError));
1189 	CHKiRet(strm.ConstructFinalize(act-&gt;pStrm));
1190 	if(inst-&gt;freshStartTail) {
1191 		const int fd = open(act-&gt;name, O_RDONLY | O_CLOEXEC);
1192 		if(fd &gt;= 0) {
1193 			act-&gt;pStrm-&gt;iCurrOffs = lseek64(fd, 0, SEEK_END);
1194 			close(fd);
1195 			if(act-&gt;pStrm-&gt;iCurrOffs &lt; 0) {
1196 				act-&gt;pStrm-&gt;iCurrOffs = 0;
1197 				LogError(errno, RS_RET_ERR, "imfile: could not query current "
1198 					"file size for %s - 'freshStartTail' option will "
1199 					"be ignored, starting at begin of file", inst-&gt;pszFileName);
1200 			}
1201 			CHKiRet(strm.SeekCurrOffs(act-&gt;pStrm));
1202 		}
1203 	}
1204 finalize_it:
1205 	RETiRet;
1206 }
1207 static rsRetVal
1208 openFile(act_obj_t *const act)
1209 {
1210 	DEFiRet;
1211 	const instanceConf_t *const inst = act-&gt;edge-&gt;instarr[0];
1212 	CHKiRet_Hdlr(openFileWithStateFile(act)) {
1213 		CHKiRet(openFileWithoutStateFile(act));
1214 	}
1215 	DBGPRINTF("breopenOnTruncate %d for '%s'\n", inst-&gt;reopenOnTruncate, act-&gt;name);
1216 	CHKiRet(strm.SetbReopenOnTruncate(act-&gt;pStrm, inst-&gt;reopenOnTruncate));
1217 	strmSetReadTimeout(act-&gt;pStrm, inst-&gt;readTimeout);
1218 finalize_it:
1219 	RETiRet;
1220 }
1221 static void pollFileCancelCleanup(void *pArg)
1222 {
1223 	cstr_t **ppCStr = (cstr_t**) pArg;
1224 	if(*ppCStr != NULL)
1225 		rsCStrDestruct(ppCStr);
1226 }
1227 static rsRetVal ATTR_NONNULL()
1228 pollFileReal(act_obj_t *act, cstr_t **pCStr)
1229 {
1230 	int64 strtOffs;
1231 	DEFiRet;
1232 	int64_t startOffs = 0;
1233 	int nProcessed = 0;
1234 	regex_t *start_preg = NULL, *end_preg = NULL;
1235 	DBGPRINTF("pollFileReal enter, act %p, pStrm %p, name '%s'\n", act, act-&gt;pStrm, act-&gt;name);
1236 	DBGPRINTF("pollFileReal enter, edge %p\n", act-&gt;edge);
1237 	DBGPRINTF("pollFileReal enter, edge-&gt;instarr %p\n", act-&gt;edge-&gt;instarr);
1238 	instanceConf_t *const inst = act-&gt;edge-&gt;instarr[0];
1239 	if(act-&gt;pStrm == NULL) {
1240 		CHKiRet(openFile(act)); 	}
1241 	start_preg = (inst-&gt;startRegex == NULL) ? NULL : &amp;inst-&gt;start_preg;
1242 	end_preg = (inst-&gt;endRegex == NULL) ? NULL : &amp;inst-&gt;end_preg;
1243 	startOffs = act-&gt;pStrm-&gt;iCurrOffs;
1244 	while(glbl.GetGlobalInputTermState() == 0) {
1245 		if(inst-&gt;maxLinesAtOnce != 0 &amp;&amp; nProcessed &gt;= inst-&gt;maxLinesAtOnce)
1246 			break;
1247 		if((start_preg == NULL) &amp;&amp; (end_preg == NULL)) {
1248 			CHKiRet(strm.ReadLine(act-&gt;pStrm, pCStr, inst-&gt;readMode, inst-&gt;escapeLF, inst-&gt;escapeLFString,
1249 				inst-&gt;trimLineOverBytes, &amp;strtOffs));
1250 		} else {
1251 			CHKiRet(strmReadMultiLine(act-&gt;pStrm, pCStr, start_preg, end_preg,
1252 				inst-&gt;escapeLF, inst-&gt;escapeLFString, inst-&gt;discardTruncatedMsg,
1253 				inst-&gt;msgDiscardingError, &amp;strtOffs));
1254 		}
1255 		++nProcessed;
1256 		if(startOffs &lt; FILE_ID_SIZE &amp;&amp; act-&gt;pStrm-&gt;iCurrOffs &gt;= FILE_ID_SIZE) {
1257 			dbgprintf("initiating state file write as sufficient data is now present; file=%s\n",
1258 				act-&gt;name);
1259 			persistStrmState(act);
1260 			startOffs = act-&gt;pStrm-&gt;iCurrOffs; 		}
1261 		runModConf-&gt;bHadFileData = 1; 		CHKiRet(enqLine(act, *pCStr, strtOffs)); 		rsCStrDestruct(pCStr); 		if(inst-&gt;iPersistStateInterval &gt; 0 &amp;&amp; ++act-&gt;nRecords &gt;= inst-&gt;iPersistStateInterval) {
1262 			persistStrmState(act);
1263 			act-&gt;nRecords = 0;
1264 		}
1265 	}
1266 finalize_it:
1267 	multiSubmitFlush(&amp;act-&gt;multiSub);
1268 	if(inst-&gt;bPersistStateAfterSubmission) {
1269 		persistStrmState(act);
1270 	}
1271 	if(*pCStr != NULL) {
1272 		rsCStrDestruct(pCStr);
1273 	}
1274 	RETiRet;
1275 }
1276 static rsRetVal ATTR_NONNULL(1)
1277 pollFile(act_obj_t *const act)
1278 {
1279 	cstr_t *pCStr = NULL;
1280 	DEFiRet;
1281 	if (act-&gt;is_symlink) {
1282 		FINALIZE;    	}
1283 	pthread_cleanup_push(pollFileCancelCleanup, &amp;pCStr);
1284 	iRet = pollFileReal(act, &amp;pCStr);
1285 	pthread_cleanup_pop(0);
1286 finalize_it: RETiRet;
1287 }
1288 static rsRetVal ATTR_NONNULL(1)
1289 createInstance(instanceConf_t **const pinst)
1290 {
1291 	instanceConf_t *inst;
1292 	DEFiRet;
1293 	CHKmalloc(inst = malloc(sizeof(instanceConf_t)));
1294 	inst-&gt;next = NULL;
1295 	inst-&gt;pBindRuleset = NULL;
1296 	inst-&gt;pszBindRuleset = NULL;
1297 	inst-&gt;pszFileName = NULL;
1298 	inst-&gt;pszTag = NULL;
1299 	inst-&gt;pszStateFile = NULL;
1300 	inst-&gt;nMultiSub = NUM_MULTISUB;
1301 	inst-&gt;iSeverity = 5;
1302 	inst-&gt;iFacility = 128;
1303 	inst-&gt;maxLinesAtOnce = 0;
1304 	inst-&gt;trimLineOverBytes = 0;
1305 	inst-&gt;iPersistStateInterval = 0;
1306 	inst-&gt;perMinuteRateLimits.maxBytesPerMinute = 0;
1307 	inst-&gt;perMinuteRateLimits.maxLinesPerMinute = 0;
1308 	inst-&gt;perMinuteRateLimits.rateLimitingMinute = 0;
1309 	inst-&gt;perMinuteRateLimits.linesThisMinute = 0;
1310 	inst-&gt;perMinuteRateLimits.bytesThisMinute = 0;
1311 	inst-&gt;bPersistStateAfterSubmission = 0;
1312 	inst-&gt;readMode = 0;
1313 	inst-&gt;startRegex = NULL;
1314 	inst-&gt;endRegex = NULL;
1315 	inst-&gt;discardTruncatedMsg = 0;
1316 	inst-&gt;msgDiscardingError = 1;
1317 	inst-&gt;bRMStateOnDel = 1;
1318 	inst-&gt;escapeLF = 1;
1319 	inst-&gt;escapeLFString = NULL;
1320 	inst-&gt;reopenOnTruncate = 0;
1321 	inst-&gt;addMetadata = ADD_METADATA_UNSPECIFIED;
1322 	inst-&gt;addCeeTag = 0;
1323 	inst-&gt;freshStartTail = 0;
1324 	inst-&gt;fileNotFoundError = 1;
1325 	inst-&gt;readTimeout = loadModConf-&gt;readTimeout;
1326 	inst-&gt;delay_perMsg = 0;
1327 	inst-&gt;msgFlag = 0;
1328 <a name="4"></a>	inst-&gt;ignoreOlderThan = 0;
1329 <font color="#6cc417"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>	if(loadModConf-&gt;tail == NULL) {
1330 		loadModConf-&gt;tail = loadModConf-&gt;root = inst;
1331 	} else {
1332 		loadModConf-&gt;tail-&gt;next = inst;
1333 		loadModConf-&gt;tail = inst;
1334 	}
1335 	*pinst = inst;
1336 finalize_it:
1337 	RETiRet;
1338 }
1339 static int ATTR_NONNULL()</b></font>
1340 getBasename(uchar *const __restrict__ basen, uchar *const __restrict__ path)
1341 {
1342 	int i;
1343 	int found = 0;
1344 	const int lenName = ustrlen(path);
1345 	for(i = lenName ; i &gt;= 0 ; --i) {
1346 		if(path[i] == '/') {
1347 			found = 1;
1348 			if(i == lenName)
1349 				basen[0] = '\0';
1350 			else {
1351 				memcpy(basen, path+i+1, lenName-i);
1352 			}
1353 			break;
1354 		}
1355 	}
1356 	if (found == 1)
1357 		return i;
1358 	else {
1359 		return -1;
1360 	}
1361 }
1362 static rsRetVal ATTR_NONNULL()
1363 checkInstance(instanceConf_t *const inst)
1364 {
1365 	uchar curr_wd[MAXFNAME];
1366 	DEFiRet;
1367 	if(inst-&gt;pszFileName == NULL)
1368 		ABORT_FINALIZE(RS_RET_INTERNAL_ERROR);
1369 	CHKmalloc(inst-&gt;pszFileName_forOldStateFile = ustrdup(inst-&gt;pszFileName));
1370 	if(loadModConf-&gt;normalizePath) {
1371 		if(inst-&gt;pszFileName[0] == '.' &amp;&amp; inst-&gt;pszFileName[1] == '/') {
1372 			DBGPRINTF("imfile: removing heading './' from name '%s'\n", inst-&gt;pszFileName);
1373 			memmove(inst-&gt;pszFileName, inst-&gt;pszFileName+2, ustrlen(inst-&gt;pszFileName) - 1);
1374 		}
1375 		if(inst-&gt;pszFileName[0] != '/') {
1376 			if(getcwd((char*)curr_wd, MAXFNAME) == NULL || curr_wd[0] != '/') {
1377 				LogError(errno, RS_RET_ERR, "imfile: error querying current working "
1378 					"directory - can not continue with %s", inst-&gt;pszFileName);
1379 				ABORT_FINALIZE(RS_RET_ERR);
1380 			}
1381 			const size_t len_curr_wd = ustrlen(curr_wd);
1382 			if(len_curr_wd + ustrlen(inst-&gt;pszFileName) + 1 &gt;= MAXFNAME) {
1383 				LogError(0, RS_RET_ERR, "imfile: length of configured file and current "
1384 					"working directory exceeds permitted size - ignoring %s",
1385 					inst-&gt;pszFileName);
1386 				ABORT_FINALIZE(RS_RET_ERR);
1387 			}
1388 			curr_wd[len_curr_wd] = '/';
1389 			strcpy((char*)curr_wd+len_curr_wd+1, (char*)inst-&gt;pszFileName);
1390 			free(inst-&gt;pszFileName);
1391 			CHKmalloc(inst-&gt;pszFileName = ustrdup(curr_wd));
1392 		}
1393 	}
1394 	dbgprintf("imfile: adding file monitor for '%s'\n", inst-&gt;pszFileName);
1395 	if(inst-&gt;pszTag != NULL) {
1396 		inst-&gt;lenTag = ustrlen(inst-&gt;pszTag);
1397 	}
1398 finalize_it:
1399 	RETiRet;
1400 }
1401 static rsRetVal
1402 addInstance(void __attribute__((unused)) *pVal, uchar *pNewVal)
1403 {
1404 	instanceConf_t *inst;
1405 	DEFiRet;
1406 	if(cs.pszFileName == NULL) {
1407 		LogError(0, RS_RET_CONFIG_ERROR, "imfile error: no file name given, file monitor can "
1408 					"not be created");
1409 		ABORT_FINALIZE(RS_RET_CONFIG_ERROR);
1410 	}
1411 	if(cs.pszFileTag == NULL) {
1412 		LogError(0, RS_RET_CONFIG_ERROR, "imfile error: no tag value given, file monitor can "
1413 					"not be created");
1414 		ABORT_FINALIZE(RS_RET_CONFIG_ERROR);
1415 	}
1416 	CHKiRet(createInstance(&amp;inst));
1417 	if((cs.pszBindRuleset == NULL) || (cs.pszBindRuleset[0] == '\0')) {
1418 		inst-&gt;pszBindRuleset = NULL;
1419 	} else {
1420 		CHKmalloc(inst-&gt;pszBindRuleset = ustrdup(cs.pszBindRuleset));
1421 	}
1422 	CHKmalloc(inst-&gt;pszFileName = ustrdup((char*) cs.pszFileName));
1423 	CHKmalloc(inst-&gt;pszTag = ustrdup((char*) cs.pszFileTag));
1424 	if(cs.pszStateFile == NULL) {
1425 		inst-&gt;pszStateFile = NULL;
1426 	} else {
1427 		CHKmalloc(inst-&gt;pszStateFile = ustrdup(cs.pszStateFile));
1428 	}
1429 	inst-&gt;iSeverity = cs.iSeverity;
1430 	inst-&gt;iFacility = cs.iFacility;
1431 	if(cs.maxLinesAtOnce) {
1432 		if(loadModConf-&gt;opMode == OPMODE_INOTIFY) {
1433 			LogError(0, RS_RET_PARAM_NOT_PERMITTED,
1434 				"parameter \"maxLinesAtOnce\" not "
1435 				"permited in inotify mode - ignored");
1436 		} else {
1437 			inst-&gt;maxLinesAtOnce = cs.maxLinesAtOnce;
1438 		}
1439 	}
1440 	inst-&gt;trimLineOverBytes = cs.trimLineOverBytes;
1441 	inst-&gt;ignoreOlderThan = 0;
1442 	inst-&gt;iPersistStateInterval = cs.iPersistStateInterval;
1443 	inst-&gt;perMinuteRateLimits.maxBytesPerMinute = cs.maxBytesPerMinute;
1444 	inst-&gt;perMinuteRateLimits.maxLinesPerMinute = cs.maxLinesPerMinute;
1445 	inst-&gt;bPersistStateAfterSubmission = 0;
1446 	inst-&gt;readMode = cs.readMode;
1447 	inst-&gt;escapeLF = 0;
1448 	inst-&gt;escapeLFString = NULL;
1449 	inst-&gt;reopenOnTruncate = 0;
1450 	inst-&gt;addMetadata = 0;
1451 	inst-&gt;addCeeTag = 0;
1452 	inst-&gt;bRMStateOnDel = 0;
1453 	inst-&gt;readTimeout = loadModConf-&gt;readTimeout;
1454 	inst-&gt;msgFlag = 0;
1455 	CHKiRet(checkInstance(inst));
1456 	cs.iPersistStateInterval = 0;
1457 	resetConfigVariables(NULL, NULL); 
1458 finalize_it:
1459 	free(pNewVal); 	RETiRet;
1460 }
1461 BEGINnewInpInst
1462 	struct cnfparamvals *pvals;
1463 	instanceConf_t *inst;
1464 	int i;
1465 CODESTARTnewInpInst
1466 <a name="1"></a>	DBGPRINTF("newInpInst (imfile)\n");
1467 	pvals = nvlstGetParams(lst, &amp;inppblk, NULL);
1468 <font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>	if(pvals == NULL) {
1469 		ABORT_FINALIZE(RS_RET_MISSING_CNFPARAMS);
1470 	}
1471 	if(Debug) {
1472 		DBGPRINTF("input param blk in imfile:\n");
1473 		cnfparamsPrint(&amp;inppblk, pvals);
1474 	}
1475 	CHKiRet(createInstance(&amp;inst));
1476 	for(i = 0 ; i &lt; inppblk.nParams ; ++i) {
1477 		if(!pvals[i].bUsed)
1478 			continue;
1479 		if(!strcmp(inppblk.descr[i].name, "file")) {
1480 			inst-&gt;pszFileName = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
1481 		} else if(!strcmp(inppblk.descr[i].name, "statefile")) {
1482 			inst-&gt;pszStateFile = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
1483 		} else if(!strcmp(inppblk.descr[i].name, "removestateondelete")) {
1484 <a name="2"></a>			inst-&gt;bRMStateOnDel = (uint8_t) pvals[i].val.d.n; 		} else if(!strcmp(inppblk.descr[i].name, "tag")) {
1485 			inst-&gt;pszTag = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
1486 <font color="#980517"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>		} else if(!strcmp(inppblk.descr[i].name, "ruleset")) {
1487 			inst-&gt;pszBindRuleset = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
1488 		} else if(!strcmp(inppblk.descr[i].name, "severity")) {
1489 			inst-&gt;iSeverity = pvals[i].val.d.n;
1490 		} else if(!strcmp(inppblk.descr[i].name, "facility")) {
1491 <a name="5"></a>			inst-&gt;iFacility = pvals[i].val.d.n;</b></font>
1492 		} else if(!strcmp(inppblk.descr[i].name, "readmode")) {
1493 			inst-&gt;readMode = (sbool) pvals[i].val.d.n;
1494 <font color="#151b8d"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>		} else if(!strcmp(inppblk.descr[i].name, "startmsg.regex")) {
1495 			inst-&gt;startRegex = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
1496 		} else if(!strcmp(inppblk.descr[i].name, "endmsg.regex")) {
1497 			inst-&gt;endRegex = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
1498 		} else if(!strcmp(inppblk.descr[i].name, "discardtruncatedmsg")) {</b></font>
1499 			inst-&gt;discardTruncatedMsg = (sbool) pvals[i].val.d.n;
1500 		} else if(!strcmp(inppblk.descr[i].name, "msgdiscardingerror")) {
1501 			inst-&gt;msgDiscardingError = (sbool) pvals[i].val.d.n;
1502 		} else if(!strcmp(inppblk.descr[i].name, "deletestateonfiledelete")) {
1503 			inst-&gt;bRMStateOnDel = (sbool) pvals[i].val.d.n; 		} else if(!strcmp(inppblk.descr[i].name, "addmetadata")) {
1504 			inst-&gt;addMetadata = (sbool) pvals[i].val.d.n;
1505 		} else if(!strcmp(inppblk.descr[i].name, "delay.message")) {
1506 			inst-&gt;delay_perMsg = (unsigned) pvals[i].val.d.n;
1507 		} else if (!strcmp(inppblk.descr[i].name, "addceetag")) {
1508 			inst-&gt;addCeeTag = (sbool) pvals[i].val.d.n;
1509 		} else if(!strcmp(inppblk.descr[i].name, "freshstarttail")) {
1510 			inst-&gt;freshStartTail = (sbool) pvals[i].val.d.n;
1511 		} else if(!strcmp(inppblk.descr[i].name, "filenotfounderror")) {
1512 			inst-&gt;fileNotFoundError = (sbool) pvals[i].val.d.n;
1513 		} else if(!strcmp(inppblk.descr[i].name, "escapelf")) {
1514 			inst-&gt;escapeLF = (sbool) pvals[i].val.d.n;
1515 		} else if(!strcmp(inppblk.descr[i].name, "escapelf.replacement")) {
1516 			inst-&gt;escapeLFString = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
1517 		} else if(!strcmp(inppblk.descr[i].name, "reopenontruncate")) {
1518 			inst-&gt;reopenOnTruncate = (sbool) pvals[i].val.d.n;
1519 		} else if(!strcmp(inppblk.descr[i].name, "maxlinesatonce")) {
1520 			if(   loadModConf-&gt;opMode == OPMODE_INOTIFY
1521 			   &amp;&amp; pvals[i].val.d.n &gt; 0) {
1522 				LogError(0, RS_RET_PARAM_NOT_PERMITTED,
1523 					"parameter \"maxLinesAtOnce\" not "
1524 					"permited in inotify mode - ignored");
1525 			} else {
1526 				inst-&gt;maxLinesAtOnce = pvals[i].val.d.n;
1527 			}
1528 		} else if(!strcmp(inppblk.descr[i].name, "trimlineoverbytes")) {
1529 			inst-&gt;trimLineOverBytes = pvals[i].val.d.n;
1530 		} else if(!strcmp(inppblk.descr[i].name, "ignoreolderthan")) {
1531 			inst-&gt;ignoreOlderThan = pvals[i].val.d.n;
1532 		} else if(!strcmp(inppblk.descr[i].name, "persiststateinterval")) {
1533 			inst-&gt;iPersistStateInterval = pvals[i].val.d.n;
1534 		} else if(!strcmp(inppblk.descr[i].name, "maxbytesperminute")) {
1535 			DBGPRINTF("imfile: enabling maxbytesperminute ratelimiting\n");
1536 			inst-&gt;perMinuteRateLimits.maxBytesPerMinute = pvals[i].val.d.n;
1537 		} else if(!strcmp(inppblk.descr[i].name, "maxlinesperminute")) {
1538 			DBGPRINTF("imfile: enabling maxlinesperminute ratelimiting\n");
1539 			inst-&gt;perMinuteRateLimits.maxLinesPerMinute = pvals[i].val.d.n;
1540 		} else if(!strcmp(inppblk.descr[i].name, "persiststateaftersubmission")) {
1541 			inst-&gt;bPersistStateAfterSubmission = pvals[i].val.d.n;
1542 		} else if(!strcmp(inppblk.descr[i].name, "maxsubmitatonce")) {
1543 			inst-&gt;nMultiSub = pvals[i].val.d.n;
1544 		} else if(!strcmp(inppblk.descr[i].name, "readtimeout")) {
1545 			inst-&gt;readTimeout = pvals[i].val.d.n;
1546 		} else if(!strcmp(inppblk.descr[i].name, "needparse")) {
1547 			inst-&gt;msgFlag = pvals[i].val.d.n ? NEEDS_PARSING : 0;
1548 		} else {
1549 			DBGPRINTF("program error, non-handled "
1550 			  "param '%s'\n", inppblk.descr[i].name);
1551 		}
1552 	}
1553 	i = (inst-&gt;readMode &gt; 0) ? 1 : 0;
1554 	i = (NULL != inst-&gt;startRegex) ? (i+1) : i;
1555 	i = (NULL != inst-&gt;endRegex) ? (i+1) : i;
1556 	if(i &gt; 1) {
1557 		LogError(0, RS_RET_PARAM_NOT_PERMITTED,
1558 			"only one of readMode or startmsg.regex or endmsg.regex can be set "
1559 			"at the same time");
1560 			ABORT_FINALIZE(RS_RET_PARAM_NOT_PERMITTED);
1561 	}
1562 	if(inst-&gt;startRegex != NULL) {
1563 		const int errcode = regcomp(&amp;inst-&gt;start_preg, (char*)inst-&gt;startRegex, REG_EXTENDED);
1564 		if(errcode != 0) {
1565 			char errbuff[512];
1566 			regerror(errcode, &amp;inst-&gt;start_preg, errbuff, sizeof(errbuff));
1567 			parser_errmsg("imfile: error in startmsg.regex expansion: %s", errbuff);
1568 			ABORT_FINALIZE(RS_RET_ERR);
1569 		}
1570 	}
1571 	if(inst-&gt;endRegex != NULL) {
1572 		const int errcode = regcomp(&amp;inst-&gt;end_preg, (char*)inst-&gt;endRegex, REG_EXTENDED);
1573 		if(errcode != 0) {
1574 			char errbuff[512];
1575 			regerror(errcode, &amp;inst-&gt;end_preg, errbuff, sizeof(errbuff));
1576 			parser_errmsg("imfile: error in endmsg.regex expansion: %s", errbuff);
1577 			ABORT_FINALIZE(RS_RET_ERR);
1578 		}
1579 	}
1580 	if(inst-&gt;readTimeout != 0)
1581 		loadModConf-&gt;haveReadTimeouts = 1;
1582 	iRet = checkInstance(inst);
1583 finalize_it:
1584 CODE_STD_FINALIZERnewInpInst
1585 	cnfparamvalsDestruct(pvals, &amp;inppblk);
1586 ENDnewInpInst
1587 BEGINbeginCnfLoad
1588 CODESTARTbeginCnfLoad
1589 	loadModConf = pModConf;
1590 	currModConf = pModConf;
1591 	pModConf-&gt;pConf = pConf;
1592 	loadModConf-&gt;opMode = OPMODE_POLLING;
1593 	loadModConf-&gt;iPollInterval = DFLT_PollInterval;
1594 	loadModConf-&gt;configSetViaV2Method = 0;
1595 	loadModConf-&gt;readTimeout = 0; 	loadModConf-&gt;timeoutGranularity = 1000; 	loadModConf-&gt;haveReadTimeouts = 0; 	loadModConf-&gt;normalizePath = 1;
1596 	loadModConf-&gt;sortFiles = GLOB_NOSORT;
1597 	loadModConf-&gt;stateFileDirectory = NULL;
1598 	loadModConf-&gt;conf_tree = calloc(sizeof(fs_node_t), 1);
1599 	loadModConf-&gt;conf_tree-&gt;edges = NULL;
1600 	bLegacyCnfModGlobalsPermitted = 1;
1601 	cs.pszFileName = NULL;
1602 	cs.pszFileTag = NULL;
1603 	cs.pszStateFile = NULL;
1604 	cs.iPollInterval = DFLT_PollInterval;
1605 	cs.iPersistStateInterval = 0;
1606 	cs.iFacility = 128;
1607 	cs.iSeverity = 5;
1608 	cs.readMode = 0;
1609 	cs.maxLinesAtOnce = 10240;
1610 	cs.trimLineOverBytes = 0;
1611 ENDbeginCnfLoad
1612 BEGINsetModCnf
1613 	struct cnfparamvals *pvals = NULL;
1614 	int i;
1615 CODESTARTsetModCnf
1616 	#if defined(HAVE_PORT_SOURCE_FILE)
1617 		loadModConf-&gt;opMode = OPMODE_FEN;
1618 	#elif defined(HAVE_INOTIFY_INIT)
1619 		loadModConf-&gt;opMode = OPMODE_INOTIFY;
1620 <a name="3"></a>	#else
1621 		loadModConf-&gt;opMode = OPMODE_POLLING;
1622 	#endif
1623 <font color="#53858b"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>	pvals = nvlstGetParams(lst, &amp;modpblk, NULL);
1624 	if(pvals == NULL) {
1625 		LogError(0, RS_RET_MISSING_CNFPARAMS, "imfile: error processing module "
1626 				"config parameters [module(...)]");
1627 		ABORT_FINALIZE(RS_RET_MISSING_CNFPARAMS);
1628 	}
1629 	if(Debug) {
1630 		DBGPRINTF("module (global) param blk for imfile:\n");
1631 		cnfparamsPrint(&amp;modpblk, pvals);
1632 	}
1633 	for(i = 0 ; i &lt; modpblk.nParams ; ++i) {
1634 		if(!pvals[i].bUsed)</b></font>
1635 			continue;
1636 		if(!strcmp(modpblk.descr[i].name, "pollinginterval")) {
1637 			loadModConf-&gt;iPollInterval = (int) pvals[i].val.d.n;
1638 		} else if(!strcmp(modpblk.descr[i].name, "readtimeout")) {
1639 			loadModConf-&gt;readTimeout = (int) pvals[i].val.d.n;
1640 		} else if(!strcmp(modpblk.descr[i].name, "timeoutgranularity")) {
1641 			loadModConf-&gt;timeoutGranularity = (int) pvals[i].val.d.n * 1000;
1642 		} else if(!strcmp(modpblk.descr[i].name, "sortfiles")) {
1643 			loadModConf-&gt;sortFiles = ((sbool) pvals[i].val.d.n) ? 0 : GLOB_NOSORT;
1644 		} else if(!strcmp(modpblk.descr[i].name, "statefile.directory")) {
1645 			loadModConf-&gt;stateFileDirectory = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
1646 		} else if(!strcmp(modpblk.descr[i].name, "normalizepath")) {
1647 			loadModConf-&gt;normalizePath = (sbool) pvals[i].val.d.n;
1648 		} else if(!strcmp(modpblk.descr[i].name, "mode")) {
1649 			if(!es_strconstcmp(pvals[i].val.d.estr, "polling"))
1650 				loadModConf-&gt;opMode = OPMODE_POLLING;
1651 			else if(!es_strconstcmp(pvals[i].val.d.estr, "inotify")) {
1652 #if defined(OS_SOLARIS) &amp;&amp; defined (HAVE_PORT_SOURCE_FILE) 				loadModConf-&gt;opMode = OPMODE_FEN;
1653 				DBGPRINTF("inotify mode configured, but only FEN "
1654 					"is available on OS SOLARIS. Switching to FEN "
1655 					"Mode automatically\n");
1656 #else
1657 				#if defined(HAVE_INOTIFY_INIT)
1658 					loadModConf-&gt;opMode = OPMODE_INOTIFY;
1659 				#else
1660 					loadModConf-&gt;opMode = OPMODE_POLLING;
1661 				#endif
1662 #endif
1663 			} else if(!es_strconstcmp(pvals[i].val.d.estr, "fen"))
1664 				loadModConf-&gt;opMode = OPMODE_FEN;
1665 			else {
1666 				char *cstr = es_str2cstr(pvals[i].val.d.estr, NULL);
1667 				LogError(0, RS_RET_PARAM_ERROR, "imfile: unknown "
1668 					"mode '%s'", cstr);
1669 				free(cstr);
1670 			}
1671 		} else {
1672 			DBGPRINTF("program error, non-handled "
1673 			  "param '%s' in beginCnfLoad\n", modpblk.descr[i].name);
1674 		}
1675 	}
1676 	bLegacyCnfModGlobalsPermitted = 0;
1677 	loadModConf-&gt;configSetViaV2Method = 1;
1678 finalize_it:
1679 	if(pvals != NULL)
1680 		cnfparamvalsDestruct(pvals, &amp;modpblk);
1681 ENDsetModCnf
1682 BEGINendCnfLoad
1683 CODESTARTendCnfLoad
1684 	if(!loadModConf-&gt;configSetViaV2Method) {
1685 		loadModConf-&gt;iPollInterval = cs.iPollInterval;
1686 	}
1687 	DBGPRINTF("opmode is %d, polling interval is %d\n",
1688 		  loadModConf-&gt;opMode,
1689 		  loadModConf-&gt;iPollInterval);
1690 	loadModConf = NULL; 	free(cs.pszFileName);
1691 	free(cs.pszFileTag);
1692 	free(cs.pszStateFile);
1693 ENDendCnfLoad
1694 BEGINcheckCnf
1695 	instanceConf_t *inst;
1696 CODESTARTcheckCnf
1697 	if(getStateFileDir() == NULL) {
1698 		LogError(0, RS_RET_NO_WRKDIR_SET,
1699 			"imfile: no working or state file directory set, imfile will create "
1700 			"state files in the current working directory (probably "
1701 			"the root dir). Use global(workDirectory=\"/some/path\") "
1702 			"to set the working directory");
1703 	}
1704 	for(inst = pModConf-&gt;root ; inst != NULL ; inst = inst-&gt;next) {
1705 		std_checkRuleset(pModConf, inst);
1706 	}
1707 	if(pModConf-&gt;root == NULL) {
1708 		LogError(0, RS_RET_NO_LISTNERS,
1709 				"imfile: no files configured to be monitored - "
1710 				"no input will be gathered");
1711 		iRet = RS_RET_NO_LISTNERS;
1712 	}
1713 ENDcheckCnf
1714 BEGINactivateCnf
1715 	instanceConf_t *inst;
1716 CODESTARTactivateCnf
1717 	runModConf = pModConf;
1718 	currModConf = pModConf;
1719 	if(runModConf-&gt;root == NULL) {
1720 		LogError(0, NO_ERRCODE, "imfile: no file monitors configured, "
1721 				"input not activated.\n");
1722 		ABORT_FINALIZE(RS_RET_NO_RUN);
1723 	}
1724 	for(inst = runModConf-&gt;root ; inst != NULL ; inst = inst-&gt;next) {
1725 		if(!containsGlobWildcard((char*)inst-&gt;pszFileName)) {
1726 			if(access((char*)inst-&gt;pszFileName, R_OK) != 0) {
1727 				LogError(errno, RS_RET_ERR,
1728 					"imfile: on startup file '%s' does not exist "
1729 					"but is configured in static file monitor - this "
1730 					"may indicate a misconfiguration. If the file "
1731 					"appears at a later time, it will automatically "
1732 					"be processed. Reason", inst-&gt;pszFileName);
1733 			}
1734 		}
1735 		fs_node_add(runModConf-&gt;conf_tree, NULL, inst-&gt;pszFileName, 0, inst);
1736 	}
1737 	if(Debug) {
1738 		fs_node_print(runModConf-&gt;conf_tree, 0);
1739 	}
1740 finalize_it:
1741 ENDactivateCnf
1742 BEGINfreeCnf
1743 	instanceConf_t *inst, *del;
1744 CODESTARTfreeCnf
1745 	fs_node_destroy(pModConf-&gt;conf_tree);
1746 	for(inst = pModConf-&gt;root ; inst != NULL ; ) {
1747 		free(inst-&gt;pszBindRuleset);
1748 		free(inst-&gt;pszFileName);
1749 		free(inst-&gt;pszTag);
1750 		free(inst-&gt;pszStateFile);
1751 		free(inst-&gt;pszFileName_forOldStateFile);
1752 		if(inst-&gt;startRegex != NULL) {
1753 			regfree(&amp;inst-&gt;start_preg);
1754 			free(inst-&gt;startRegex);
1755 		}
1756 		if(inst-&gt;endRegex != NULL) {
1757 			regfree(&amp;inst-&gt;end_preg);
1758 			free(inst-&gt;endRegex);
1759 		}
1760 		del = inst;
1761 		inst = inst-&gt;next;
1762 		free(del);
1763 	}
1764 ENDfreeCnf
1765 static void
1766 do_initial_poll_run(void)
1767 {
1768 	fs_node_walk(runModConf-&gt;conf_tree, poll_tree);
1769 	for(instanceConf_t *inst = runModConf-&gt;root ; inst != NULL ; inst = inst-&gt;next) {
1770 		inst-&gt;freshStartTail = 0;
1771 	}
1772 }
1773 static rsRetVal
1774 doPolling(void)
1775 {
1776 	DEFiRet;
1777 	do_initial_poll_run();
1778 	while(glbl.GetGlobalInputTermState() == 0) {
1779 		DBGPRINTF("doPolling: new poll run\n");
1780 		do {
1781 			runModConf-&gt;bHadFileData = 0;
1782 			fs_node_walk(runModConf-&gt;conf_tree, poll_tree);
1783 			DBGPRINTF("doPolling: end poll walk, hadData %d\n", runModConf-&gt;bHadFileData);
1784 		} while(runModConf-&gt;bHadFileData); 
1785 		DBGPRINTF("doPolling: poll going to sleep\n");
1786 		if(glbl.GetGlobalInputTermState() == 0)
1787 			srSleep(runModConf-&gt;iPollInterval, 10);
1788 	}
1789 	RETiRet;
1790 }
1791 #if defined(HAVE_INOTIFY_INIT)
1792 static void ATTR_NONNULL(1)
1793 in_dbg_showEv(const struct inotify_event *ev)
1794 {
1795 	if(!Debug)
1796 		return;
1797 	if(ev-&gt;mask &amp; IN_IGNORED) {
1798 		dbgprintf("INOTIFY event: watch was REMOVED\n");
1799 	}
1800 	if(ev-&gt;mask &amp; IN_MODIFY) {
1801 		dbgprintf("INOTIFY event: watch was MODIFID\n");
1802 	}
1803 	if(ev-&gt;mask &amp; IN_ACCESS) {
1804 		dbgprintf("INOTIFY event: watch IN_ACCESS\n");
1805 	}
1806 	if(ev-&gt;mask &amp; IN_ATTRIB) {
1807 		dbgprintf("INOTIFY event: watch IN_ATTRIB\n");
1808 	}
1809 	if(ev-&gt;mask &amp; IN_CLOSE_WRITE) {
1810 		dbgprintf("INOTIFY event: watch IN_CLOSE_WRITE\n");
1811 	}
1812 	if(ev-&gt;mask &amp; IN_CLOSE_NOWRITE) {
1813 		dbgprintf("INOTIFY event: watch IN_CLOSE_NOWRITE\n");
1814 	}
1815 	if(ev-&gt;mask &amp; IN_CREATE) {
1816 		dbgprintf("INOTIFY event: file was CREATED: %s\n", ev-&gt;name);
1817 	}
1818 	if(ev-&gt;mask &amp; IN_DELETE) {
1819 		dbgprintf("INOTIFY event: watch IN_DELETE\n");
1820 	}
1821 	if(ev-&gt;mask &amp; IN_DELETE_SELF) {
1822 		dbgprintf("INOTIFY event: watch IN_DELETE_SELF\n");
1823 	}
1824 	if(ev-&gt;mask &amp; IN_MOVE_SELF) {
1825 		dbgprintf("INOTIFY event: watch IN_MOVE_SELF\n");
1826 	}
1827 	if(ev-&gt;mask &amp; IN_MOVED_FROM) {
1828 		dbgprintf("INOTIFY event: watch IN_MOVED_FROM, cookie %u, name '%s'\n", ev-&gt;cookie, ev-&gt;name);
1829 	}
1830 	if(ev-&gt;mask &amp; IN_MOVED_TO) {
1831 		dbgprintf("INOTIFY event: watch IN_MOVED_TO, cookie %u, name '%s'\n", ev-&gt;cookie, ev-&gt;name);
1832 	}
1833 	if(ev-&gt;mask &amp; IN_OPEN) {
1834 		dbgprintf("INOTIFY event: watch IN_OPEN\n");
1835 	}
1836 	if(ev-&gt;mask &amp; IN_ISDIR) {
1837 		dbgprintf("INOTIFY event: watch IN_ISDIR\n");
1838 	}
1839 }
1840 static void ATTR_NONNULL(1, 2)
1841 in_handleFileEvent(struct inotify_event *ev, const wd_map_t *const etry)
1842 {
1843 	if(ev-&gt;mask &amp; IN_MODIFY) {
1844 		DBGPRINTF("fs_node_notify_file_update: act-&gt;name '%s'\n", etry-&gt;act-&gt;name);
1845 		pollFile(etry-&gt;act);
1846 	} else {
1847 		DBGPRINTF("got non-expected inotify event:\n");
1848 		in_dbg_showEv(ev);
1849 	}
1850 }
1851 static void
1852 flag_in_move(fs_edge_t *const edge, const char *name_moved)
1853 {
1854 	act_obj_t *act;
1855 	for(act = edge-&gt;active ; act != NULL ; act = act-&gt;next) {
1856 		DBGPRINTF("checking active object %s\n", act-&gt;basename);
1857 		if(!strcmp(act-&gt;basename, name_moved)){
1858 			DBGPRINTF("found file\n");
1859 			act-&gt;in_move = 1;
1860 			break;
1861 		} else {
1862 			DBGPRINTF("name check fails, '%s' != '%s'\n", act-&gt;basename, name_moved);
1863 		}
1864 	}
1865 	if (!act &amp;&amp; edge-&gt;next) {
1866 		flag_in_move(edge-&gt;next, name_moved);
1867 	}
1868 }
1869 static void ATTR_NONNULL(1)
1870 in_processEvent(struct inotify_event *ev)
1871 {
1872 	if(ev-&gt;mask &amp; IN_IGNORED) {
1873 		DBGPRINTF("imfile: got IN_IGNORED event\n");
1874 		goto done;
1875 	}
1876 	DBGPRINTF("in_processEvent process Event %x for %s\n", ev-&gt;mask, ev-&gt;name);
1877 	const wd_map_t *const etry =  wdmapLookup(ev-&gt;wd);
1878 	if(etry == NULL) {
1879 		LogMsg(0, RS_RET_INTERNAL_ERROR, LOG_WARNING, "imfile: internal error? "
1880 			"inotify provided watch descriptor %d which we could not find "
1881 			"in our tables - ignored", ev-&gt;wd);
1882 		goto done;
1883 	}
1884 	DBGPRINTF("in_processEvent process Event %x is_file %d, act-&gt;name '%s'\n",
1885 		ev-&gt;mask, etry-&gt;act-&gt;edge-&gt;is_file, etry-&gt;act-&gt;name);
1886 	if((ev-&gt;mask &amp; IN_MOVED_FROM)) {
1887 		flag_in_move(etry-&gt;act-&gt;edge-&gt;node-&gt;edges, ev-&gt;name);
1888 	}
1889 	if(ev-&gt;mask &amp; (IN_MOVED_FROM | IN_MOVED_TO))  {
1890 		fs_node_walk(etry-&gt;act-&gt;edge-&gt;node, poll_tree);
1891 	} else if(etry-&gt;act-&gt;edge-&gt;is_file &amp;&amp; !(etry-&gt;act-&gt;is_symlink)) {
1892 		in_handleFileEvent(ev, etry); 	} else {
1893 		fs_node_walk(etry-&gt;act-&gt;edge-&gt;node, poll_tree);
1894 	}
1895 done:	return;
1896 }
1897 static rsRetVal
1898 do_inotify(void)
1899 {
1900 	char iobuf[8192];
1901 	int rd;
1902 	int currev;
1903 	static int last_timeout = 0;
1904 	struct pollfd pollfd;
1905 	DEFiRet;
1906 	CHKiRet(wdmapInit());
1907 	ino_fd = inotify_init1(IN_NONBLOCK);
1908 	if(ino_fd &lt; 0) {
1909 		LogError(errno, RS_RET_INOTIFY_INIT_FAILED, "imfile: Init inotify "
1910 			"instance failed ");
1911 		return RS_RET_INOTIFY_INIT_FAILED;
1912 	}
1913 	DBGPRINTF("inotify fd %d\n", ino_fd);
1914 	do_initial_poll_run();
1915 	while(glbl.GetGlobalInputTermState() == 0) {
1916 		int r;
1917 		pollfd.fd = ino_fd;
1918 		pollfd.events = POLLIN;
1919 		if (runModConf-&gt;haveReadTimeouts)
1920 			r = poll(&amp;pollfd, 1, runModConf-&gt;timeoutGranularity);
1921 		else
1922 			r = poll(&amp;pollfd, 1, -1);
1923 		if (r  == -1 &amp;&amp; errno == EINTR) {
1924 			DBGPRINTF("do_inotify interrupted while polling on ino_fd\n");
1925 			continue;
1926 		}
1927 		if(r == 0) {
1928 			DBGPRINTF("readTimeouts are configured, checking if some apply\n");
1929 			if (runModConf-&gt;haveReadTimeouts) {
1930 				fs_node_walk(runModConf-&gt;conf_tree, poll_timeouts);
1931 				last_timeout = time(NULL);
1932 			}
1933 			continue;
1934 		} else if (r == -1) {
1935 			LogError(errno, RS_RET_INTERNAL_ERROR,
1936 					"%s:%d: unexpected error during poll timeout wait",
1937 					__FILE__, __LINE__);
1938 			continue;
1939 		} else if(r != 1) {
1940 			LogError(errno, RS_RET_INTERNAL_ERROR,
1941 					"%s:%d: ERROR: poll returned more fds (%d) than given to it (1)",
1942 					__FILE__, __LINE__, r);
1943 			continue;
1944 		}
1945 		else {
1946 			if(runModConf-&gt;haveReadTimeouts) {
1947 				int now = time(NULL);
1948 				if(last_timeout + (runModConf-&gt;timeoutGranularity / 1000) &gt; now) {
1949 					fs_node_walk(runModConf-&gt;conf_tree, poll_timeouts);
1950 					last_timeout = time(NULL);
1951 				}
1952 			}
1953 			rd = read(ino_fd, iobuf, sizeof(iobuf));
1954 			if(rd == -1 &amp;&amp; errno == EINTR) {
1955 				DBGPRINTF("EINTR received during inotify, restarting poll\n");
1956 				continue;
1957 			}
1958 			if (rd == -1 &amp;&amp; errno == EWOULDBLOCK) {
1959 				continue;
1960 			}
1961 			if(rd &lt; 0) {
1962 				LogError(errno, RS_RET_IO_ERROR, "imfile: error during inotify - ignored");
1963 				continue;
1964 			}
1965 			currev = 0;
1966 			while(currev &lt; rd) {
1967 				union {
1968 					char *buf;
1969 					struct inotify_event *ev;
1970 				} savecast;
1971 				savecast.buf = iobuf+currev;
1972 				in_dbg_showEv(savecast.ev);
1973 				in_processEvent(savecast.ev);
1974 				currev += sizeof(struct inotify_event) + savecast.ev-&gt;len;
1975 			}
1976 		}
1977 	}
1978 finalize_it:
1979 	close(ino_fd);
1980 	RETiRet;
1981 }
1982 #else static rsRetVal
1983 do_inotify(void)
1984 {
1985 	LogError(0, RS_RET_NOT_IMPLEMENTED, "imfile: mode set to inotify, but the "
1986 			"platform does not support inotify");
1987 	return RS_RET_NOT_IMPLEMENTED;
1988 }
1989 #endif 
1990 #if defined(OS_SOLARIS) &amp;&amp; defined (HAVE_PORT_SOURCE_FILE) static void
1991 fen_printevent(int event)
1992 {
1993 	if (event &amp; FILE_ACCESS) {
1994 		DBGPRINTF(" FILE_ACCESS");
1995 	}
1996 	if (event &amp; FILE_MODIFIED) {
1997 		DBGPRINTF(" FILE_MODIFIED");
1998 	}
1999 	if (event &amp; FILE_ATTRIB) {
2000 		DBGPRINTF(" FILE_ATTRIB");
2001 	}
2002 	if (event &amp; FILE_DELETE) {
2003 		DBGPRINTF(" FILE_DELETE");
2004 	}
2005 	if (event &amp; FILE_RENAME_TO) {
2006 		DBGPRINTF(" FILE_RENAME_TO");
2007 	}
2008 	if (event &amp; FILE_RENAME_FROM) {
2009 		DBGPRINTF(" FILE_RENAME_FROM");
2010 	}
2011 	if (event &amp; UNMOUNTED) {
2012 		DBGPRINTF(" UNMOUNTED");
2013 	}
2014 	if (event &amp; MOUNTEDOVER) {
2015 		DBGPRINTF(" MOUNTEDOVER");
2016 	}
2017 }
2018 static rsRetVal
2019 do_fen(void)
2020 {
2021 	port_event_t portEvent;
2022 	struct timespec timeout;
2023 	DEFiRet;
2024 	timeout.tv_sec = 300;
2025 	timeout.tv_nsec = 0;
2026 	if((glport = port_create()) == -1) {
2027 		LogError(errno, RS_RET_FEN_INIT_FAILED, "do_fen INIT Port failed ");
2028 		return RS_RET_FEN_INIT_FAILED;
2029 	}
2030 	do_initial_poll_run();
2031 	DBGPRINTF("do_fen ENTER monitoring loop \n");
2032 	while(glbl.GetGlobalInputTermState() == 0) {
2033 		DBGPRINTF("do_fen loop begin... \n");
2034 		while (!port_get(glport, &amp;portEvent, &amp;timeout)) { 			DBGPRINTF("do_fen: received port event with ");
2035 			fen_printevent((int) portEvent.portev_events);
2036 			DBGPRINTF("\n");
2037 			if(portEvent.portev_source != PORT_SOURCE_FILE) {
2038 				LogError(errno, RS_RET_SYS_ERR, "do_fen: Event from unexpected source "
2039 					": %d\n", portEvent.portev_source);
2040 				continue;
2041 			}
2042 			act_obj_t *const act = (act_obj_t*) portEvent.portev_user;
2043 			DBGPRINTF("do_fen event received: deleted %d, is_file %d, name '%s' foname '%s'\n",
2044 				act-&gt;is_deleted, act-&gt;edge-&gt;is_file, act-&gt;name,
2045 				((struct file_obj*)portEvent.portev_object)-&gt;fo_name);
2046 			if(act-&gt;is_deleted) {
2047 				free(act-&gt;name);
2048 				free(act);
2049 				continue;
2050 			}
2051 			act-&gt;bPortAssociated = 0;
2052 			fen_setupWatch(act);
2053 			if(act-&gt;edge-&gt;is_file) {
2054 				pollFile(act);
2055 			} else {
2056 				fs_node_walk(act-&gt;edge-&gt;node, poll_tree);
2057 			}
2058 		}
2059 	}
2060 	close(glport);
2061 	RETiRet;
2062 }
2063 #else static rsRetVal
2064 do_fen(void)
2065 {
2066 	LogError(0, RS_RET_NOT_IMPLEMENTED, "do_fen: mode set to fen, but the "
2067 			"platform does not support fen");
2068 	return RS_RET_NOT_IMPLEMENTED;
2069 }
2070 #endif 
2071 BEGINrunInput
2072 CODESTARTrunInput
2073 	#if defined(OS_SOLARIS) &amp;&amp; defined (HAVE_PORT_SOURCE_FILE) 	if(runModConf-&gt;opMode == OPMODE_INOTIFY) {
2074 		DBGPRINTF("auto-adjusting 'inotify' mode to 'fen' on Solaris\n");
2075 		runModConf-&gt;opMode = OPMODE_FEN;
2076 	}
2077 	#endif
2078 	DBGPRINTF("working in %s mode\n",
2079 		 (runModConf-&gt;opMode == OPMODE_POLLING) ? "polling" :
2080 			((runModConf-&gt;opMode == OPMODE_INOTIFY) ?"inotify" : "fen"));
2081 	if(runModConf-&gt;opMode == OPMODE_POLLING)
2082 		iRet = doPolling();
2083 	else if(runModConf-&gt;opMode == OPMODE_INOTIFY)
2084 		iRet = do_inotify();
2085 	else if(runModConf-&gt;opMode == OPMODE_FEN)
2086 		iRet = do_fen();
2087 	else {
2088 		LogError(0, RS_RET_NOT_IMPLEMENTED, "imfile: unknown mode %d set",
2089 			runModConf-&gt;opMode);
2090 		return RS_RET_NOT_IMPLEMENTED;
2091 	}
2092 	DBGPRINTF("terminating upon request of rsyslog core\n");
2093 ENDrunInput
2094 BEGINwillRun
2095 CODESTARTwillRun
2096 	CHKiRet(prop.Construct(&amp;pInputName));
2097 	CHKiRet(prop.SetString(pInputName, UCHAR_CONSTANT("imfile"), sizeof("imfile") - 1));
2098 	CHKiRet(prop.ConstructFinalize(pInputName));
2099 finalize_it:
2100 ENDwillRun
2101 static rsRetVal ATTR_NONNULL()
2102 atomicWriteStateFile(const char *fn, const char *content)
2103 {
2104 	DEFiRet;
2105 	const int fd = open(fn, O_CLOEXEC | O_NOCTTY | O_WRONLY | O_CREAT | O_TRUNC, 0600);
2106 	if(fd &lt; 0) {
2107 		LogError(errno, RS_RET_IO_ERROR, "imfile: cannot open state file '%s' for "
2108 			"persisting file state - some data will probably be duplicated "
2109 			"on next startup", fn);
2110 		ABORT_FINALIZE(RS_RET_IO_ERROR);
2111 	}
2112 	const size_t toWrite = strlen(content);
2113 	const ssize_t w = write(fd, content, toWrite);
2114 	if(w != (ssize_t) toWrite) {
2115 		LogError(errno, RS_RET_IO_ERROR, "imfile: partial write to state file '%s' "
2116 			"this may cause trouble in the future. We will try to delete the "
2117 			"state file, as this provides most consistent state", fn);
2118 		unlink(fn);
2119 		ABORT_FINALIZE(RS_RET_IO_ERROR);
2120 	}
2121 finalize_it:
2122 	if(fd &gt;= 0) {
2123 		close(fd);
2124 	}
2125 	RETiRet;
2126 }
2127 static void
2128 removeOldStatefile(const uchar *statefn, const char *hashToDelete)
2129 {
2130 	int ret;
2131 	uchar statefname[MAXFNAME];
2132 	getFullStateFileName(statefn, hashToDelete, statefname, sizeof(statefname));
2133 	DBGPRINTF("removing old state file: '%s'\n", statefname);
2134 	ret = unlink((const char*)statefname);
2135 	if(ret != 0) {
2136 		if (errno != ENOENT) {
2137 			LogError(errno, RS_RET_IO_ERROR,
2138 				"imfile error trying to delete old state file: '%s' - ignoring this "
2139 				"error, usually this means a file no longer file is left over, but "
2140 				"this may also cause some real trouble. Still the best we can do ",
2141 				statefname);
2142 		} else {
2143 			DBGPRINTF("trying to delete no longer valid statefile '%s' which no "
2144 					  "longer exists (probably already deleted)\n", statefname);
2145 		}
2146 	}
2147 }
2148 static rsRetVal ATTR_NONNULL()
2149 persistStrmState(act_obj_t *const act)
2150 {
2151 	DEFiRet;
2152 	uchar statefile[MAXFNAME];
2153 	uchar statefname[MAXFNAME];
2154 	uchar *const statefn = getStateFileName(act, statefile, sizeof(statefile));
2155 	getFileID(act);
2156 	getFullStateFileName(statefn, act-&gt;file_id, statefname, sizeof(statefname));
2157 	DBGPRINTF("persisting state for '%s', state file '%s'\n", act-&gt;name, statefname);
2158 	struct json_object *jval = NULL;
2159 	struct json_object *json = NULL;
2160 	CHKmalloc(json = json_object_new_object());
2161 	jval = json_object_new_string((char*) act-&gt;name);
2162 	json_object_object_add(json, "filename", jval);
2163 	jval = json_object_new_int(strmGetPrevWasNL(act-&gt;pStrm));
2164 	json_object_object_add(json, "prev_was_nl", jval);
2165 	jval = json_object_new_int64(act-&gt;pStrm-&gt;iCurrOffs);
2166 	json_object_object_add(json, "curr_offs", jval);
2167 	jval = json_object_new_int64(act-&gt;pStrm-&gt;strtOffs);
2168 	json_object_object_add(json, "strt_offs", jval);
2169 	const uchar *const prevLineSegment = strmGetPrevLineSegment(act-&gt;pStrm);
2170 	if(prevLineSegment != NULL) {
2171 		jval = json_object_new_string((const char*) prevLineSegment);
2172 		json_object_object_add(json, "prev_line_segment", jval);
2173 	}
2174 	const uchar *const prevMsgSegment = strmGetPrevMsgSegment(act-&gt;pStrm);
2175 	if(prevMsgSegment != NULL) {
2176 		jval = json_object_new_string((const char*) prevMsgSegment);
2177 		json_object_object_add(json, "prev_msg_segment", jval);
2178 	}
2179 	const char *jstr =  json_object_to_json_string_ext(json, JSON_C_TO_STRING_SPACED);
2180 	CHKiRet(atomicWriteStateFile((const char*)statefname, jstr));
2181 	json_object_put(json);
2182 	if (strncmp((const char *)act-&gt;file_id_prev, (const char *)act-&gt;file_id, FILE_ID_HASH_SIZE)) {
2183 		removeOldStatefile(statefn, act-&gt;file_id_prev);
2184 	}
2185 finalize_it:
2186 	if(iRet != RS_RET_OK) {
2187 		LogError(0, iRet, "imfile: could not persist state "
2188 				"file %s - data may be repeated on next "
2189 				"startup. Is WorkDirectory set?",
2190 				statefname);
2191 	}
2192 	RETiRet;
2193 }
2194 BEGINafterRun
2195 CODESTARTafterRun
2196 	if(pInputName != NULL)
2197 		prop.Destruct(&amp;pInputName);
2198 ENDafterRun
2199 BEGINisCompatibleWithFeature
2200 CODESTARTisCompatibleWithFeature
2201 	if(eFeat == sFEATURENonCancelInputTermination)
2202 		iRet = RS_RET_OK;
2203 ENDisCompatibleWithFeature
2204 BEGINmodExit
2205 CODESTARTmodExit
2206 	objRelease(strm, CORE_COMPONENT);
2207 	objRelease(glbl, CORE_COMPONENT);
2208 	objRelease(prop, CORE_COMPONENT);
2209 	objRelease(ruleset, CORE_COMPONENT);
2210 	objRelease(datetime, CORE_COMPONENT);
2211 	#ifdef HAVE_INOTIFY_INIT
2212 	free(wdmap);
2213 	#endif
2214 ENDmodExit
2215 BEGINqueryEtryPt
2216 CODESTARTqueryEtryPt
2217 CODEqueryEtryPt_STD_IMOD_QUERIES
2218 CODEqueryEtryPt_STD_CONF2_QUERIES
2219 CODEqueryEtryPt_STD_CONF2_setModCnf_QUERIES
2220 CODEqueryEtryPt_STD_CONF2_IMOD_QUERIES
2221 CODEqueryEtryPt_IsCompatibleWithFeature_IF_OMOD_QUERIES
2222 ENDqueryEtryPt
2223 static rsRetVal
2224 resetConfigVariables(uchar __attribute__((unused)) *pp, void __attribute__((unused)) *pVal)
2225 {
2226 	DEFiRet;
2227 	free(cs.pszFileName);
2228 	cs.pszFileName = NULL;
2229 	free(cs.pszFileTag);
2230 	cs.pszFileTag = NULL;
2231 	free(cs.pszStateFile);
2232 	cs.pszStateFile = NULL;
2233 	cs.iPollInterval = DFLT_PollInterval;
2234 	cs.iFacility = 128; 	cs.iSeverity = 5;  	cs.readMode = 0;
2235 	cs.maxLinesAtOnce = 10240;
2236 	cs.trimLineOverBytes = 0;
2237 	RETiRet;
2238 }
2239 static inline void
2240 std_checkRuleset_genErrMsg(__attribute__((unused)) modConfData_t *modConf, instanceConf_t *inst)
2241 {
2242 	LogError(0, NO_ERRCODE, "imfile: ruleset '%s' for %s not found - "
2243 			"using default ruleset instead", inst-&gt;pszBindRuleset,
2244 			inst-&gt;pszFileName);
2245 }
2246 BEGINmodInit()
2247 CODESTARTmodInit
2248 	*ipIFVersProvided = CURR_MOD_IF_VERSION; CODEmodInit_QueryRegCFSLineHdlr
2249 	CHKiRet(objUse(glbl, CORE_COMPONENT));
2250 	CHKiRet(objUse(strm, CORE_COMPONENT));
2251 	CHKiRet(objUse(ruleset, CORE_COMPONENT));
2252 	CHKiRet(objUse(prop, CORE_COMPONENT));
2253 	CHKiRet(objUse(datetime, CORE_COMPONENT));
2254 	DBGPRINTF("version %s initializing\n", VERSION);
2255 	CHKiRet(omsdRegCFSLineHdlr((uchar *)"inputfilename", 0, eCmdHdlrGetWord,
2256 	  	NULL, &amp;cs.pszFileName, STD_LOADABLE_MODULE_ID));
2257 	CHKiRet(omsdRegCFSLineHdlr((uchar *)"inputfiletag", 0, eCmdHdlrGetWord,
2258 	  	NULL, &amp;cs.pszFileTag, STD_LOADABLE_MODULE_ID));
2259 	CHKiRet(omsdRegCFSLineHdlr((uchar *)"inputfilestatefile", 0, eCmdHdlrGetWord,
2260 	  	NULL, &amp;cs.pszStateFile, STD_LOADABLE_MODULE_ID));
2261 	CHKiRet(omsdRegCFSLineHdlr((uchar *)"inputfileseverity", 0, eCmdHdlrSeverity,
2262 	  	NULL, &amp;cs.iSeverity, STD_LOADABLE_MODULE_ID));
2263 	CHKiRet(omsdRegCFSLineHdlr((uchar *)"inputfilefacility", 0, eCmdHdlrFacility,
2264 	  	NULL, &amp;cs.iFacility, STD_LOADABLE_MODULE_ID));
2265 	CHKiRet(omsdRegCFSLineHdlr((uchar *)"inputfilereadmode", 0, eCmdHdlrInt,
2266 	  	NULL, &amp;cs.readMode, STD_LOADABLE_MODULE_ID));
2267 	CHKiRet(omsdRegCFSLineHdlr((uchar *)"inputfilemaxlinesatonce", 0, eCmdHdlrSize,
2268 	  	NULL, &amp;cs.maxLinesAtOnce, STD_LOADABLE_MODULE_ID));
2269 	CHKiRet(omsdRegCFSLineHdlr((uchar *)"inputfiletrimlineoverbytes", 0, eCmdHdlrSize,
2270 	  	NULL, &amp;cs.trimLineOverBytes, STD_LOADABLE_MODULE_ID));
2271 	CHKiRet(omsdRegCFSLineHdlr((uchar *)"inputfilepersiststateinterval", 0, eCmdHdlrInt,
2272 	  	NULL, &amp;cs.iPersistStateInterval, STD_LOADABLE_MODULE_ID));
2273 	CHKiRet(omsdRegCFSLineHdlr((uchar *)"inputfilebindruleset", 0, eCmdHdlrGetWord,
2274 		NULL, &amp;cs.pszBindRuleset, STD_LOADABLE_MODULE_ID));
2275 	CHKiRet(omsdRegCFSLineHdlr((uchar *)"inputrunfilemonitor", 0, eCmdHdlrGetWord,
2276 		addInstance, NULL, STD_LOADABLE_MODULE_ID));
2277 	CHKiRet(regCfSysLineHdlr2((uchar *)"inputfilepollinterval", 0, eCmdHdlrInt,
2278 	  	NULL, &amp;cs.iPollInterval, STD_LOADABLE_MODULE_ID, &amp;bLegacyCnfModGlobalsPermitted));
2279 	CHKiRet(omsdRegCFSLineHdlr((uchar *)"resetconfigvariables", 1, eCmdHdlrCustomHandler,
2280 		resetConfigVariables, NULL, STD_LOADABLE_MODULE_ID));
2281 ENDmodInit
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
