<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for imhiredis.c &amp; imfile.c</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for imhiredis.c &amp; imfile.c
      </h3>
<h1 align="center">
        7.1%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>imhiredis.c (11.775701%)<th>imfile.c (5.176664%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(137-153)<td><a href="#" name="0">(312-328)</a><td align="center"><font color="#ff0000">29</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(317-336)<td><a href="#" name="1">(1924-1943)</a><td align="center"><font color="#ed0000">27</font>
<tr onclick='openModal("#980517")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#980517"><font color="#980517">-</font><td><a href="#" name="2">(339-344)<td><a href="#" name="2">(1946-1951)</a><td align="center"><font color="#8c0000">16</font>
<tr onclick='openModal("#53858b")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#53858b"><font color="#53858b">-</font><td><a href="#" name="3">(403-416)<td><a href="#" name="3">(2094-2107)</a><td align="center"><font color="#7b0000">14</font>
<tr onclick='openModal("#6cc417")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#6cc417"><font color="#6cc417">-</font><td><a href="#" name="4">(220-234)<td><a href="#" name="4">(1755-1771)</a><td align="center"><font color="#7b0000">14</font>
<tr onclick='openModal("#151b8d")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#151b8d"><font color="#151b8d">-</font><td><a href="#" name="5">(728-739)<td><a href="#" name="5">(1954-1958)</a><td align="center"><font color="#720000">13</font>
<tr onclick='openModal("#8c8774")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#8c8774"><font color="#8c8774">-</font><td><a href="#" name="6">(270-290)<td><a href="#" name="6">(1038-1060)</a><td align="center"><font color="#720000">13</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>imhiredis.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
#include "config.h"
#include &lt;stdio.h&gt;
#include &lt;stdarg.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;assert.h&gt;
#include &lt;errno.h&gt;
#include &lt;fcntl.h&gt;
#include &lt;pthread.h&gt;
#include &lt;sys/uio.h&gt;
#include &lt;hiredis/hiredis.h&gt;
#include &lt;hiredis/async.h&gt;
#include &lt;hiredis/adapters/libevent.h&gt;
#include &lt;event2/thread.h&gt;
#include "rsyslog.h"
#include "conf.h"
#include "syslogd-types.h"
#include "srUtils.h"
#include "template.h"
#include "module-template.h"
#include "errmsg.h"
#include "atomic.h"
#include "statsobj.h"
#include "unicode-helper.h"
#include "prop.h"
#include "ruleset.h"
#include "glbl.h"
#include "cfsysline.h"
#include "msg.h"
#include "dirty.h"
MODULE_TYPE_INPUT
MODULE_TYPE_NOKEEP
MODULE_CNFNAME("imhiredis")
DEF_IMOD_STATIC_DATA
#define QUEUE_BATCH_SIZE 10
#define IMHIREDIS_MODE_QUEUE 1
#define IMHIREDIS_MODE_SUBSCRIBE 2
DEFobjCurrIf(prop)
DEFobjCurrIf(ruleset)
DEFobjCurrIf(glbl)
DEFobjCurrIf(statsobj)
typedef struct redisNode_s {
	sbool isMaster;
	sbool usesSocket;
	uchar *socketPath;
	uchar *server;
	int port;
	struct redisNode_s *next;
} redisNode;
struct instanceConf_s {
	uchar *password;
	uchar *key;
	uchar *modeDescription;
	int mode;
	sbool useLPop;
	ruleset_t *pBindRuleset;		uchar *pszBindRuleset;		
	redisContext *conn;
	redisAsyncContext *aconn;
	struct event_base *evtBase;
	redisNode *redisNodesList;
	struct instanceConf_s *next;
};
struct modConfData_s {
	rsconf_t *pConf;			instanceConf_t *root, *tail;
};
static struct imhiredisWrkrInfo_s {
	pthread_t tid;			instanceConf_t *inst;	} *imhiredisWrkrInfo;
pthread_attr_t wrkrThrdAttr;	
static int activeHiredisworkers = 0;
static char *redis_replies[] = {"unknown", "string", "array", "integer", "nil", "status", "error"};
static modConfData_t *loadModConf = NULL;static modConfData_t *runModConf = NULL;
static prop_t *pInputName = NULL;
<a name="0"></a>
<font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>static struct cnfparamdescr modpdescr[] = {};
static struct cnfparamblk modpblk =
	{ CNFPARAMBLK_VERSION,
	  sizeof(modpdescr)/sizeof(struct cnfparamdescr),
	  modpdescr
	};
static struct cnfparamdescr inppdescr[] = {
	{ "socketPath", eCmdHdlrGetWord, 0 },
	{ "server", eCmdHdlrGetWord, 0 },
	{ "port", eCmdHdlrInt, 0 },
	{ "password", eCmdHdlrGetWord, 0 },
	{ "mode", eCmdHdlrGetWord, 0 },
	{ "key", eCmdHdlrGetWord, 0 },
	{ "uselpop", eCmdHdlrBinary, 0 },
	{ "ruleset", eCmdHdlrString, 0 },</b></font>
};
static struct cnfparamblk inppblk =
	{ CNFPARAMBLK_VERSION,
	  sizeof(inppdescr)/sizeof(struct cnfparamdescr),
	  inppdescr
	};
struct timeval glblRedisConnectTimeout = { 3, 0 }; 
#include "im-helper.h" 
static void redisAsyncRecvCallback (redisAsyncContext __attribute__((unused)) *c, void *reply, void *inst_obj);
static void redisAsyncConnectCallback (const redisAsyncContext *c, int status);
static void redisAsyncDisconnectCallback (const redisAsyncContext *c, int status);
static rsRetVal enqMsg(instanceConf_t *const inst, const char *message);
rsRetVal redisAuthentSynchronous(redisContext *conn, uchar *password);
rsRetVal redisAuthentAsynchronous(redisAsyncContext *aconn, uchar *password);
rsRetVal redisActualizeCurrentNode(instanceConf_t *inst);
rsRetVal redisGetServersList(redisNode *node, uchar *password, redisNode **result);
rsRetVal redisAuthenticate(instanceConf_t *inst);
rsRetVal redisConnectSync(redisContext **conn, redisNode *node);
rsRetVal redisConnectAsync(redisAsyncContext **aconn, redisNode *node);
rsRetVal redisDequeue(instanceConf_t *inst);
void workerLoopSubscribe(struct imhiredisWrkrInfo_s *me);
void workerLoopQueue(struct imhiredisWrkrInfo_s *me);
static void *imhirediswrkr(void *myself);
static rsRetVal createRedisNode(redisNode **root);
rsRetVal copyNode(redisNode *src, redisNode **dst);
redisNode *freeNode(redisNode *node);
void insertNodeAfter(redisNode *root, redisNode *elem);
void dbgPrintNode(redisNode *node);
static rsRetVal
createInstance(instanceConf_t **pinst)
{
	DEFiRet;
	instanceConf_t *inst;
	CHKmalloc(inst = malloc(sizeof(instanceConf_t)));
	inst-&gt;next = NULL;
	inst-&gt;password = NULL;
	inst-&gt;key = NULL;
	inst-&gt;mode = 0;
	inst-&gt;useLPop = 0;
	inst-&gt;pszBindRuleset = NULL;
	inst-&gt;pBindRuleset = NULL;
	inst-&gt;conn = NULL;
	inst-&gt;aconn = NULL;
	CHKiRet(createRedisNode(&amp;(inst-&gt;redisNodesList)));
	inst-&gt;currentNode = inst-&gt;redisNodesList;
<a name="4"></a>	inst-&gt;evtBase = NULL;
<font color="#6cc417"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>	if(loadModConf-&gt;tail == NULL) {
		loadModConf-&gt;tail = loadModConf-&gt;root = inst;
	} else {
		loadModConf-&gt;tail-&gt;next = inst;
		loadModConf-&gt;tail = inst;
	}
	*pinst = inst;
finalize_it:
	RETiRet;
}
static rsRetVal ATTR_NONNULL()</b></font>
checkInstance(instanceConf_t *const inst)
{
	DEFiRet;
	assert(inst-&gt;redisNodesList != NULL);
	if (inst-&gt;redisNodesList-&gt;server != NULL &amp;&amp; inst-&gt;redisNodesList-&gt;socketPath != NULL) {
		LogMsg(0, RS_RET_CONFIG_ERROR, LOG_WARNING,"imhiredis: both 'server' and 'socketPath' are given, "
								"ignoring 'socketPath'.");
		free(inst-&gt;redisNodesList-&gt;socketPath);
		inst-&gt;redisNodesList-&gt;socketPath = NULL;
	}
	if(inst-&gt;redisNodesList-&gt;server != NULL &amp;&amp; inst-&gt;redisNodesList-&gt;server[0] != '\0') {
		if (inst-&gt;redisNodesList-&gt;port == 0) {
			LogMsg(0, RS_RET_OK_WARN, LOG_WARNING, "imhiredis: port not set, setting default 6379");
			inst-&gt;redisNodesList-&gt;port = 6379;
		}
		DBGPRINTF("imhiredis: preferred server is %s (%d)\n",
			inst-&gt;redisNodesList-&gt;server,
			inst-&gt;redisNodesList-&gt;port);
		inst-&gt;redisNodesList-&gt;usesSocket = 0;
	}
	else if(inst-&gt;redisNodesList-&gt;socketPath != NULL &amp;&amp; inst-&gt;redisNodesList-&gt;socketPath[0] != '\0') {
		DBGPRINTF("imhiredis: preferred server is %s\n",
			inst-&gt;redisNodesList-&gt;socketPath);
		inst-&gt;redisNodesList-&gt;usesSocket = 1;
	} else {
		LogError(0, RS_RET_CONFIG_ERROR, "imhiredis: neither 'server' nor 'socketPath' are defined!");
		ABORT_FINALIZE(RS_RET_CONFIG_ERROR);
	}
<a name="6"></a>
	if (inst-&gt;key != NULL) {
		DBGPRINTF("imhiredis: key/channel is '%s'\n", inst-&gt;key);
<font color="#8c8774"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>	} else {
		LogError(0, RS_RET_CONFIG_ERROR, "imhiredis: no key defined !");
		ABORT_FINALIZE(RS_RET_CONFIG_ERROR);
	}
	if (inst-&gt;mode != IMHIREDIS_MODE_QUEUE &amp;&amp; inst-&gt;mode != IMHIREDIS_MODE_SUBSCRIBE) {
		LogError(0, RS_RET_CONFIG_ERROR, "imhiredis: invalid mode, please choose 'subscribe' or 'queue' mode.");
		ABORT_FINALIZE(RS_RET_CONFIG_ERROR);
	}
	if (inst-&gt;mode == IMHIREDIS_MODE_SUBSCRIBE &amp;&amp; inst-&gt;useLPop) {
		LogMsg(0, RS_RET_CONFIG_ERROR, LOG_WARNING,"imhiredis: 'uselpop' set with mode = subscribe : ignored.");
	}
	if (inst-&gt;password != NULL) {
		DBGPRINTF("imhiredis: password is '%s'\n", inst-&gt;password);
	}
	inst-&gt;currentNode = inst-&gt;redisNodesList;</b></font>
	if (RS_RET_OK != redisActualizeCurrentNode(inst) || inst-&gt;currentNode == NULL) {
		LogMsg(0, RS_RET_REDIS_ERROR, LOG_WARNING, "imhiredis: could not connect to a valid master!");
	}
finalize_it:
	RETiRet;
}
static inline void
std_checkRuleset_genErrMsg(__attribute__((unused)) modConfData_t *modConf, instanceConf_t *inst)
{
	LogError(0, NO_ERRCODE, "imhiredis: ruleset '%s' not found - "
		"using default ruleset instead",
		inst-&gt;pszBindRuleset);
}
BEGINnewInpInst
	struct cnfparamvals *pvals;
	instanceConf_t *inst;
	int i;
<a name="1"></a>CODESTARTnewInpInst
	DBGPRINTF("newInpInst (imhiredis)\n");
<font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>	if((pvals = nvlstGetParams(lst, &amp;inppblk, NULL)) == NULL) {
		ABORT_FINALIZE(RS_RET_MISSING_CNFPARAMS);
	}
	if(Debug) {
		dbgprintf("input param blk in imhiredis:\n");
		cnfparamsPrint(&amp;inppblk, pvals);
	}
	CHKiRet(createInstance(&amp;inst));
	for(i = 0 ; i &lt; inppblk.nParams ; ++i) {
		if(!pvals[i].bUsed)
			continue;
		if(!strcmp(inppblk.descr[i].name, "server")) {
			inst-&gt;redisNodesList-&gt;server = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
		} else if(!strcmp(inppblk.descr[i].name, "socketPath")) {
			inst-&gt;redisNodesList-&gt;socketPath = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
		} else if(!strcmp(inppblk.descr[i].name, "ruleset")) {
<a name="2"></a>			inst-&gt;pszBindRuleset = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);</b></font>
		} else if(!strcmp(inppblk.descr[i].name, "port")) {
			inst-&gt;redisNodesList-&gt;port = (int) pvals[i].val.d.n;
<font color="#980517"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>		} else if(!strcmp(inppblk.descr[i].name, "password")) {
			inst-&gt;password = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
		} else if(!strcmp(inppblk.descr[i].name, "uselpop")) {
			inst-&gt;useLPop = pvals[i].val.d.n;
		} else if(!strcmp(inppblk.descr[i].name, "mode")) {
			inst-&gt;modeDescription = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);</b></font>
			if (!strcmp((const char*)inst-&gt;modeDescription, "queue")) {
				inst-&gt;mode = IMHIREDIS_MODE_QUEUE;
			} else if (!strcmp((const char*)inst-&gt;modeDescription, "subscribe")) {
				inst-&gt;mode = IMHIREDIS_MODE_SUBSCRIBE;
			} else {
				LogMsg(0, RS_RET_PARAM_ERROR, LOG_ERR, "imhiredis: unsupported mode "
					"'%s'", inppblk.descr[i].name);
				ABORT_FINALIZE(RS_RET_PARAM_ERROR);
			}
		} else if(!strcmp(inppblk.descr[i].name, "key")) {
			inst-&gt;key = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
		} else {
			dbgprintf("imhiredis: program error, non-handled "
				"param '%s'\n", inppblk.descr[i].name);
		}
	}
	DBGPRINTF("imhiredis: checking config sanity\n");
	if (inst-&gt;modeDescription == NULL) {
		CHKmalloc(inst-&gt;modeDescription = (uchar*)strdup("subscribe"));
		inst-&gt;mode = IMHIREDIS_MODE_SUBSCRIBE;
		LogMsg(0, RS_RET_OK_WARN, LOG_WARNING, "imhiredis: \"mode\" parameter not specified "
			"using default redis 'subscribe' mode -- this may not be what you want!");
	}
	if (inst-&gt;key == NULL) {
		LogMsg(0, RS_RET_PARAM_ERROR, LOG_ERR, "imhiredis: \"key\" required parameter not specified!");
		ABORT_FINALIZE(RS_RET_PARAM_ERROR);
	}
	if(inst-&gt;redisNodesList-&gt;server == NULL &amp;&amp; inst-&gt;redisNodesList-&gt;socketPath == NULL) {
		CHKmalloc(inst-&gt;redisNodesList-&gt;server = (uchar *)strdup("127.0.0.1"));
		inst-&gt;redisNodesList-&gt;port = 6379;
		LogMsg(0, RS_RET_OK_WARN, LOG_WARNING, "imhiredis: no server parameter specified "
			"using default 127.0.0.1:6379 -- this may not be what you want!");
	}
	if (inst-&gt;password == NULL) {
		LogMsg(0, RS_RET_OK, LOG_INFO, "imhiredis: no password specified");
	}
	DBGPRINTF("imhiredis: newInpInst key=%s, mode=%s, uselpop=%d\n",
		inst-&gt;key, inst-&gt;modeDescription, inst-&gt;useLPop);
finalize_it:
CODE_STD_FINALIZERnewInpInst
	cnfparamvalsDestruct(pvals, &amp;inppblk);
ENDnewInpInst
BEGINbeginCnfLoad
CODESTARTbeginCnfLoad
	loadModConf = pModConf;
	pModConf-&gt;pConf = pConf;
ENDbeginCnfLoad
BEGINsetModCnf
<a name="3"></a>	struct cnfparamvals *pvals = NULL;
	int i;
CODESTARTsetModCnf
<font color="#53858b"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>	pvals = nvlstGetParams(lst, &amp;modpblk, NULL);
	if(pvals == NULL) {
		LogError(0, RS_RET_MISSING_CNFPARAMS, "imhiredis: error processing module "
			"config parameters [module(...)]");
		ABORT_FINALIZE(RS_RET_MISSING_CNFPARAMS);
	}
	if(Debug) {
		dbgprintf("module (global) param blk for imhiredis:\n");
		cnfparamsPrint(&amp;modpblk, pvals);
	}
	for(i = 0 ; i &lt; modpblk.nParams ; ++i) {
		if(!pvals[i].bUsed) {</b></font>
			continue;
		} else {
			dbgprintf("imhiredis: program error, non-handled "
			  "param '%s' in beginCnfLoad\n", modpblk.descr[i].name);
		}
	}
finalize_it:
	if(pvals != NULL)
		cnfparamvalsDestruct(pvals, &amp;modpblk);
ENDsetModCnf
BEGINendCnfLoad
CODESTARTendCnfLoad
ENDendCnfLoad
BEGINcheckCnf
	instanceConf_t *inst;
CODESTARTcheckCnf
	for(inst = pModConf-&gt;root ; inst != NULL ; inst = inst-&gt;next) {
		std_checkRuleset(pModConf, inst);
	}
ENDcheckCnf
BEGINactivateCnfPrePrivDrop
CODESTARTactivateCnfPrePrivDrop
	runModConf = pModConf;
ENDactivateCnfPrePrivDrop
BEGINactivateCnf
CODESTARTactivateCnf
	for(instanceConf_t *inst = pModConf-&gt;root ; inst != NULL ; inst = inst-&gt;next) {
		iRet = checkInstance(inst);
		if (inst-&gt;mode == IMHIREDIS_MODE_SUBSCRIBE)
			inst-&gt;evtBase = event_base_new();
	}
ENDactivateCnf
BEGINfreeCnf
	instanceConf_t *inst, *del;
	redisNode *node;
CODESTARTfreeCnf
	for(inst = pModConf-&gt;root ; inst != NULL ; ) {
		if (inst-&gt;evtBase)
			event_base_free(inst-&gt;evtBase);
		if (inst-&gt;password != NULL)
			free(inst-&gt;password);
		free(inst-&gt;modeDescription);
		free(inst-&gt;key);
		free(inst-&gt;pszBindRuleset);
		if(inst-&gt;conn != NULL) {
			redisFree(inst-&gt;conn);
			inst-&gt;conn = NULL;
		}
		if(inst-&gt;aconn != NULL) {
			redisAsyncFree(inst-&gt;aconn);
			inst-&gt;aconn = NULL;
		}
		for (node = inst-&gt;redisNodesList; node != NULL; node = freeNode(node)) {;}
		del = inst;
		inst = inst-&gt;next;
		free(del);
	}
ENDfreeCnf
static void
shutdownImhiredisWorkers(void)
{
	int i;
	instanceConf_t *inst;
	assert(imhiredisWrkrInfo != NULL);
	for(inst = runModConf-&gt;root ; inst != NULL ; inst = inst-&gt;next) {
		if (inst-&gt;mode == IMHIREDIS_MODE_SUBSCRIBE &amp;&amp; inst-&gt;aconn) {
			DBGPRINTF("imhiredis: disconnecting async worker\n");
			redisAsyncDisconnect(inst-&gt;aconn);
		}
	}
	DBGPRINTF("imhiredis: waiting on imhiredis workerthread termination\n");
	for(i = 0 ; i &lt; activeHiredisworkers ; ++i) {
		pthread_join(imhiredisWrkrInfo[i].tid, NULL);
		DBGPRINTF("imhiredis: Stopped worker %d\n", i);
	}
	free(imhiredisWrkrInfo);
	imhiredisWrkrInfo = NULL;
	return;
}
BEGINrunInput
	int i;
	instanceConf_t *inst;
CODESTARTrunInput
	DBGPRINTF("imhiredis: runInput loop started ...\n");
	activeHiredisworkers = 0;
	for(inst = runModConf-&gt;root ; inst != NULL ; inst = inst-&gt;next) {
		++activeHiredisworkers;
	}
	if(activeHiredisworkers == 0) {
		LogError(0, RS_RET_ERR, "imhiredis: no active inputs, input does "
			"not run - there should have been additional error "
			"messages given previously");
		ABORT_FINALIZE(RS_RET_ERR);
	}
	DBGPRINTF("imhiredis: Starting %d imhiredis workerthreads\n", activeHiredisworkers);
	imhiredisWrkrInfo = calloc(activeHiredisworkers, sizeof(struct imhiredisWrkrInfo_s));
	if (imhiredisWrkrInfo == NULL) {
		LogError(errno, RS_RET_OUT_OF_MEMORY, "imhiredis: worker-info array allocation failed.");
		ABORT_FINALIZE(RS_RET_OUT_OF_MEMORY);
	}
	i = 0;
	for(inst = runModConf-&gt;root ; inst != NULL ; inst = inst-&gt;next) {
		imhiredisWrkrInfo[i].inst = inst; 		pthread_create(&amp;imhiredisWrkrInfo[i].tid, &amp;wrkrThrdAttr, imhirediswrkr, &amp;(imhiredisWrkrInfo[i]));
		i++;
	}
	while(glbl.GetGlobalInputTermState() == 0) {
		if(glbl.GetGlobalInputTermState() == 0)
			srSleep(0, 100000);
	}
	DBGPRINTF("imhiredis: terminating upon request of rsyslog core\n");
	shutdownImhiredisWorkers();
finalize_it:
ENDrunInput
BEGINwillRun
CODESTARTwillRun
	CHKiRet(prop.Construct(&amp;pInputName));
	CHKiRet(prop.SetString(pInputName, UCHAR_CONSTANT("imhiredis"), sizeof("imhiredis") - 1));
	CHKiRet(prop.ConstructFinalize(pInputName));
finalize_it:
ENDwillRun
BEGINafterRun
CODESTARTafterRun
	if(pInputName != NULL)
		prop.Destruct(&amp;pInputName);
ENDafterRun
BEGINmodExit
CODESTARTmodExit
	pthread_attr_destroy(&amp;wrkrThrdAttr);
	libevent_global_shutdown();
	objRelease(statsobj, CORE_COMPONENT);
	objRelease(ruleset, CORE_COMPONENT);
	objRelease(glbl, CORE_COMPONENT);
	objRelease(prop, CORE_COMPONENT);
ENDmodExit
BEGINisCompatibleWithFeature
CODESTARTisCompatibleWithFeature
	if(eFeat == sFEATURENonCancelInputTermination)
		iRet = RS_RET_OK;
ENDisCompatibleWithFeature
BEGINqueryEtryPt
CODESTARTqueryEtryPt
CODEqueryEtryPt_STD_IMOD_QUERIES
CODEqueryEtryPt_STD_CONF2_QUERIES
CODEqueryEtryPt_STD_CONF2_PREPRIVDROP_QUERIES
CODEqueryEtryPt_STD_CONF2_IMOD_QUERIES
CODEqueryEtryPt_STD_CONF2_setModCnf_QUERIES
CODEqueryEtryPt_IsCompatibleWithFeature_IF_OMOD_QUERIES
ENDqueryEtryPt
BEGINmodInit()
CODESTARTmodInit
	*ipIFVersProvided = CURR_MOD_IF_VERSION;
CODEmodInit_QueryRegCFSLineHdlr
	CHKiRet(objUse(glbl, CORE_COMPONENT));
	CHKiRet(objUse(prop, CORE_COMPONENT));
	CHKiRet(objUse(ruleset, CORE_COMPONENT));
	CHKiRet(objUse(statsobj, CORE_COMPONENT));
	pthread_attr_init(&amp;wrkrThrdAttr);
	pthread_attr_setstacksize(&amp;wrkrThrdAttr, 4096*1024);
	evthread_use_pthreads();
ENDmodInit
static void redisAsyncRecvCallback (redisAsyncContext *aconn, void *reply, void __attribute__((unused)) *unused) {
	instanceConf_t *const inst = (instanceConf_t *) aconn-&gt;data;
	redisReply * r = (redisReply *) reply;
	if (r == NULL) return;
	if (r-&gt;elements &lt; 3 || r-&gt;element[2]-&gt;str == NULL) {
		return;
	}
	enqMsg(inst, r-&gt;element[2]-&gt;str);
	return;
}
static void redisAsyncConnectCallback (const redisAsyncContext *c, int status) {
	if (status != REDIS_OK) {
		LogMsg(0, RS_RET_REDIS_ERROR, LOG_ERR, "imhiredis (async): could not connect to redis: "
			"%s", c-&gt;errstr);
		instanceConf_t *inst = (instanceConf_t *) c-&gt;data;
		assert(inst != NULL);
		inst-&gt;aconn = NULL;
		return;
	}
	DBGPRINTF("imhiredis (async): successfully connected!\n");
	return;
}
static void redisAsyncDisconnectCallback (const redisAsyncContext *c, int status) {
	instanceConf_t *inst = (instanceConf_t *) c-&gt;data;
	assert(inst != NULL);
	inst-&gt;aconn = NULL;
	inst-&gt;currentNode = NULL;
	if (status != REDIS_OK) {
		LogMsg(0, RS_RET_REDIS_ERROR, LOG_ERR, "imhiredis (async): got disconnected from redis: "
			"%s", c-&gt;errstr);
		return;
	}
	DBGPRINTF("imhiredis (async): successfully disconnected!\n");
	return;
}
redisReply *getRole(redisContext *c) {
	redisReply *reply;
	assert(c != NULL);
<a name="5"></a>	reply = redisCommand(c, "ROLE");
	if (reply == NULL) {
		DBGPRINTF("imhiredis: could not get reply from ROLE command\n");
<font color="#151b8d"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>	}
	else if (reply-&gt;type == REDIS_REPLY_ERROR) {
		LogMsg(0, RS_RET_REDIS_ERROR, LOG_WARNING, "imhiredis got an error while querying role -&gt; "
			"%s\n", reply-&gt;str);
		freeReplyObject(reply);
		reply = NULL;
	}
	else if (reply-&gt;type != REDIS_REPLY_ARRAY) {
		LogMsg(0, RS_RET_REDIS_ERROR, LOG_ERR, "imhiredis: did not get an array from ROLE command");
		freeReplyObject(reply);
		reply = NULL;
	}</b></font>
	return reply;
}
static rsRetVal enqMsg(instanceConf_t *const inst, const char *message) {
	DEFiRet;
	smsg_t *pMsg;
	if (message == NULL || message[0] == '\0') {
		FINALIZE;
	}
	DBGPRINTF("imhiredis: enqMsg: Msg -&gt; '%s'\n", message);
	CHKiRet(msgConstruct(&amp;pMsg));
	MsgSetInputName(pMsg, pInputName);
	MsgSetRawMsg(pMsg, message, strlen(message));
	MsgSetFlowControlType(pMsg, eFLOWCTL_LIGHT_DELAY);
	MsgSetRuleset(pMsg, inst-&gt;pBindRuleset);
	MsgSetMSGoffs(pMsg, 0);		CHKiRet(submitMsg2(pMsg));
finalize_it:
	RETiRet;
}
rsRetVal redisAuthentSynchronous(redisContext *conn, uchar *password) {
	DEFiRet;
	redisReply *reply = NULL;
	assert(conn != NULL);
	assert(password != NULL);
	assert(password[0] != '\0');
	reply = (redisReply *) redisCommand(conn, "AUTH %s", password);
	if (reply == NULL) {
		LogError(0, RS_RET_REDIS_ERROR, "imhiredis: Could not authenticate!\n");
		ABORT_FINALIZE(RS_RET_REDIS_ERROR);
	} else if (strncmp(reply-&gt;str, "OK", 2)) {
		LogError(0, RS_RET_REDIS_AUTH_FAILED, "imhiredis: Authentication failure -&gt; %s\n", reply-&gt;str);
		ABORT_FINALIZE(RS_RET_REDIS_AUTH_FAILED);
	}
finalize_it:
	if(reply)
		freeReplyObject(reply);
	RETiRet;
}
rsRetVal redisAuthentAsynchronous(redisAsyncContext *aconn, uchar *password) {
	DEFiRet;
	assert(aconn != NULL);
	assert(password != NULL);
	assert(password[0] != '\0');
	if (REDIS_OK != redisAsyncCommand(aconn, NULL, NULL, "AUTH %s", password)) {
		LogError(0, RS_RET_REDIS_ERROR, "imhiredis: error while authenticating asynchronously -&gt; %s\n",
			aconn-&gt;errstr);
		ABORT_FINALIZE(RS_RET_REDIS_ERROR);
	}
finalize_it:
	RETiRet;
}
rsRetVal redisGetServersList(redisNode *node, uchar *password, redisNode **result) {
	DEFiRet;
	redisContext *context;
	redisReply *reply = NULL, *replica;
	unsigned int i;
	assert(node != NULL);
	CHKiRet(redisConnectSync(&amp;context, node));
	if(password != NULL &amp;&amp; password[0] != '\0') {
		CHKiRet(redisAuthentSynchronous(context, password));
	}
	reply = getRole(context);
	if(reply == NULL) {
		LogMsg(0, RS_RET_REDIS_ERROR, LOG_WARNING, "imhiredis: did not get the role of the server");
		ABORT_FINALIZE(RS_RET_REDIS_ERROR);
	}
	if (	reply-&gt;elements == 5 &amp;&amp;
		strncmp(reply-&gt;element[0]-&gt;str, "slave", 5) == 0) {
		CHKiRet(createRedisNode(result));
		(*result)-&gt;server = (uchar *) strdup((const char *)reply-&gt;element[1]-&gt;str);
		(*result)-&gt;port = reply-&gt;element[2]-&gt;integer;
		(*result)-&gt;isMaster = 1;
	}
	else if (	reply-&gt;elements == 3 &amp;&amp;
			reply-&gt;element[2]-&gt;type == REDIS_REPLY_ARRAY &amp;&amp;
			strncmp(reply-&gt;element[0]-&gt;str, "master", 6) == 0) {
		for (i = 0; i &lt; reply-&gt;element[2]-&gt;elements; i++) {
			replica = reply-&gt;element[2]-&gt;element[i];
			if (replica-&gt;type == REDIS_REPLY_ARRAY &amp;&amp; replica-&gt;elements == 3) {
				CHKiRet(createRedisNode(result));
				(*result)-&gt;server = (uchar *) strdup((const char *)replica-&gt;element[0]-&gt;str);
				(*result)-&gt;port = atoi(replica-&gt;element[1]-&gt;str);
			}
		}
	} else {
		ABORT_FINALIZE(RS_RET_NOT_FOUND);
	}
finalize_it:
	if (reply != NULL)
		freeReplyObject(reply);
	if (context != NULL)
		redisFree(context);
	RETiRet;
}
rsRetVal redisActualizeCurrentNode(instanceConf_t *inst) {
	DEFiRet;
	redisReply *reply = NULL;
	redisNode *node, *tmp, *newList = NULL;
	assert(inst != NULL);
	assert(inst-&gt;redisNodesList != NULL);
	inst-&gt;currentNode = NULL;
	copyNode(inst-&gt;redisNodesList, &amp;newList);
	newList-&gt;next = NULL;
	for (node = inst-&gt;redisNodesList; node != NULL; node = node-&gt;next) {
		tmp = NULL;
		DBGPRINTF("imhiredis: trying to connect to node to get info...\n");
		dbgPrintNode(node);
		if (RS_RET_OK == redisGetServersList(node, inst-&gt;password, &amp;tmp)) {
			if (tmp &amp;&amp; tmp-&gt;isMaster) {
				DBGPRINTF("imhiredis: node replied with a master node, is a replica\n");
				inst-&gt;currentNode = tmp;
				tmp = NULL;
				if(RS_RET_OK != redisGetServersList(inst-&gt;currentNode, inst-&gt;password, &amp;tmp)) {
					DBGPRINTF("imhiredis: had a master but cannot connect, keeping in list\n");
					dbgPrintNode(inst-&gt;currentNode);
					insertNodeAfter(newList, inst-&gt;currentNode);
					inst-&gt;currentNode = NULL;
					continue;
				}
			} else {
				DBGPRINTF("imhiredis: node replied with a list of replicas, is a master\n");
				node-&gt;isMaster = 1;
				copyNode(node, &amp;(inst-&gt;currentNode));
				inst-&gt;currentNode-&gt;next = NULL;
			}
			if (tmp) {
				insertNodeAfter(newList, tmp);
				DBGPRINTF("imhiredis: inserting replicas to list\n");
				for (tmp = newList-&gt;next; tmp != NULL; tmp = tmp-&gt;next) {
					dbgPrintNode(tmp);
				}
			}
			DBGPRINTF("imhiredis: inserting new master node in list\n");
			dbgPrintNode(inst-&gt;currentNode);
			insertNodeAfter(newList, inst-&gt;currentNode);
			tmp = newList;
			newList = inst-&gt;redisNodesList;
			inst-&gt;redisNodesList = tmp;
			FINALIZE;
		}
	}
	DBGPRINTF("imhiredis: did not find a valid master");
	iRet = RS_RET_NOT_FOUND;
	inst-&gt;currentNode = NULL;
finalize_it:
	if (reply != NULL)
		freeReplyObject(reply);
	for (node = newList; node != NULL; ) {
		node = freeNode(node);
	}
	RETiRet;
}
rsRetVal redisAuthenticate(instanceConf_t *inst) {
	DEFiRet;
	redisContext *usedContext = NULL;
	redisReply *reply = NULL;
	assert(inst != NULL);
	assert(inst-&gt;currentNode != NULL);
	assert(inst-&gt;password != NULL);
	assert(inst-&gt;password[0] != '\0');
	DBGPRINTF("imhiredis: authenticating...\n");
	if (inst-&gt;mode == IMHIREDIS_MODE_SUBSCRIBE) {
		if (RS_RET_OK != redisConnectSync(&amp;usedContext, inst-&gt;currentNode)) {
			LogMsg(0, RS_RET_REDIS_ERROR, LOG_WARNING, "imhiredis: could not connect to current "
				"active node synchronously to validate authentication");
			ABORT_FINALIZE(RS_RET_REDIS_ERROR);
		}
	} else {
		usedContext = inst-&gt;conn;
	}
	CHKiRet(redisAuthentSynchronous(usedContext, inst-&gt;password));
	if (inst-&gt;mode == IMHIREDIS_MODE_SUBSCRIBE) {
		CHKiRet(redisAuthentAsynchronous(inst-&gt;aconn, inst-&gt;password));
	}
	DBGPRINTF("imhiredis: authentication successful\n");
finalize_it:
	if(inst-&gt;mode == IMHIREDIS_MODE_SUBSCRIBE &amp;&amp; usedContext)
		redisFree(usedContext);
	if(reply)
		freeReplyObject(reply);
	RETiRet;
}
rsRetVal redisConnectSync(redisContext **conn, redisNode *node) {
	DEFiRet;
	assert(node != NULL);
	if (node-&gt;usesSocket)
		*conn = redisConnectUnixWithTimeout((const char *)node-&gt;socketPath, glblRedisConnectTimeout);
	else
		*conn = redisConnectWithTimeout((const char *)node-&gt;server, node-&gt;port, glblRedisConnectTimeout);
	if (*conn == NULL) {
		if (node-&gt;usesSocket) {
			LogError(0, RS_RET_REDIS_ERROR, "imhiredis: can not connect to redis server '%s' "
				"-&gt; could not allocate context!\n", node-&gt;socketPath);
		} else {
			LogError(0, RS_RET_REDIS_ERROR, "imhiredis: can not connect to redis server '%s', "
				"port %d -&gt; could not allocate context!\n", node-&gt;server, node-&gt;port);
		}
		ABORT_FINALIZE(RS_RET_REDIS_ERROR);
	}
	else if ((*conn)-&gt;err) {
		if (node-&gt;usesSocket) {
			LogError(0, RS_RET_REDIS_ERROR, "imhiredis: can not connect to redis server '%s' "
				"-&gt; %s\n", node-&gt;socketPath, (*conn)-&gt;errstr);
		} else {
			LogError(0, RS_RET_REDIS_ERROR, "imhiredis: can not connect to redis server '%s', "
				"port %d -&gt; %s\n", node-&gt;server, node-&gt;port, (*conn)-&gt;errstr);
		}
		ABORT_FINALIZE(RS_RET_REDIS_ERROR);
	}
finalize_it:
	if (iRet != RS_RET_OK) {
		if (*conn)
			redisFree(*conn);
		*conn = NULL;
	}
	RETiRet;
}
rsRetVal redisConnectAsync(redisAsyncContext **aconn, redisNode *node) {
	DEFiRet;
	assert(node != NULL);
	if (node-&gt;usesSocket)
		*aconn = redisAsyncConnectUnix((const char*)node-&gt;socketPath);
	else
		*aconn = redisAsyncConnect((const char *)node-&gt;server, node-&gt;port);
	if(*aconn == NULL) {
		LogError(0, RS_RET_REDIS_ERROR, "imhiredis (async): could not allocate context!\n");
		ABORT_FINALIZE(RS_RET_REDIS_ERROR);
	} else if ((*aconn)-&gt;err) {
		if (node-&gt;usesSocket) {
			LogError(0, RS_RET_REDIS_ERROR, "imhiredis (async): cannot connect to server '%s' "
				"-&gt; %s\n", node-&gt;socketPath, (*aconn)-&gt;errstr);
		} else {
			LogError(0, RS_RET_REDIS_ERROR, "imhiredis (async): cannot connect to server '%s', port '%d' "
				"-&gt; %s\n", node-&gt;server, node-&gt;port, (*aconn)-&gt;errstr);
		}
		ABORT_FINALIZE(RS_RET_REDIS_ERROR);
	}
finalize_it:
	if (iRet != RS_RET_OK) {
		if(*aconn)
			redisAsyncFree(*aconn);
		*aconn = NULL;
	}
	RETiRet;
}
rsRetVal redisDequeue(instanceConf_t *inst) {
	DEFiRet;
	redisReply *reply = NULL;
	uint replyType = 0, i;
	assert(inst != NULL);
	DBGPRINTF("imhiredis: beginning to dequeue key '%s'\n", inst-&gt;key);
	do {
		if (inst-&gt;useLPop == 1) {
			DBGPRINTF("imhiredis: Queuing #%d LPOP commands on key '%s' \n",
					QUEUE_BATCH_SIZE,
					inst-&gt;key);
			for (i=0; i&lt;QUEUE_BATCH_SIZE; ++i ) {
				if (REDIS_OK != redisAppendCommand(inst-&gt;conn, "LPOP %s", inst-&gt;key))
					break;
			}
		} else {
			DBGPRINTF("imhiredis: Queuing #%d RPOP commands on key '%s' \n",
					QUEUE_BATCH_SIZE,
					inst-&gt;key);
			for (i=0; i&lt;QUEUE_BATCH_SIZE; i++) {
				if (REDIS_OK != redisAppendCommand(inst-&gt;conn, "RPOP %s", inst-&gt;key))
					break;
			}
		}
		do {
			if (REDIS_OK != redisGetReply(inst-&gt;conn, (void **) &amp;reply)) {
				LogError(0, RS_RET_REDIS_ERROR, "imhiredis: Error reading reply after POP #%d on key "
								"'%s'", (QUEUE_BATCH_SIZE - i), inst-&gt;key);
				ABORT_FINALIZE(RS_RET_REDIS_ERROR);
			} else {
				if (reply != NULL) {
					replyType = reply-&gt;type;
					switch(replyType) {
						case REDIS_REPLY_STRING:
							enqMsg(inst, reply-&gt;str);
							break;
						case REDIS_REPLY_NIL:
							break;
						case REDIS_REPLY_ERROR:
							LogMsg(0, RS_RET_REDIS_ERROR, LOG_ERR, "imhiredis: error "
							"while POP'ing key '%s' -&gt; %s", inst-&gt;key, reply-&gt;str);
							ABORT_FINALIZE(RS_RET_REDIS_ERROR);
						default:
							LogMsg(0, RS_RET_OK_WARN, LOG_WARNING, "imhiredis: unexpected "
							"reply type: %s", redis_replies[replyType%7]);
					}
					freeReplyObject(reply);
					reply = NULL;
				} else { 					LogMsg(0, RS_RET_REDIS_ERROR, LOG_ERR, "imhiredis: unexpected empty reply "
						"for successful return");
					ABORT_FINALIZE(RS_RET_REDIS_ERROR);
				}
			}
		} while (--i &gt; 0);
	} while (replyType == REDIS_REPLY_STRING &amp;&amp; glbl.GetGlobalInputTermState() == 0);
	DBGPRINTF("imhiredis: finished to dequeue key '%s'\n", inst-&gt;key);
finalize_it:
	if (reply)
		freeReplyObject(reply);
	RETiRet;
}
void workerLoopSubscribe(struct imhiredisWrkrInfo_s *me) {
	uint i;
	DBGPRINTF("imhiredis (async): beginning of subscribe worker loop...\n");
	if (me-&gt;inst-&gt;currentNode != NULL) {
		if(RS_RET_OK != redisConnectAsync(&amp;(me-&gt;inst-&gt;aconn), me-&gt;inst-&gt;currentNode)) {
			me-&gt;inst-&gt;currentNode = NULL;
		}
		if(	me-&gt;inst-&gt;password != NULL &amp;&amp;
			me-&gt;inst-&gt;password[0] != '\0' &amp;&amp;
			RS_RET_OK != redisAuthenticate(me-&gt;inst)) {
			redisAsyncFree(me-&gt;inst-&gt;aconn);
			me-&gt;inst-&gt;aconn = NULL;
			me-&gt;inst-&gt;currentNode = NULL;
		}
		me-&gt;inst-&gt;aconn-&gt;data = (void *)me-&gt;inst;
		redisAsyncSetConnectCallback(me-&gt;inst-&gt;aconn, redisAsyncConnectCallback);
		redisAsyncSetDisconnectCallback(me-&gt;inst-&gt;aconn, redisAsyncDisconnectCallback);
		redisLibeventAttach(me-&gt;inst-&gt;aconn, me-&gt;inst-&gt;evtBase);
	}
	while(glbl.GetGlobalInputTermState() == 0) {
		if (me-&gt;inst-&gt;aconn == NULL) {
			DBGPRINTF("imhiredis: no valid connection, sleeping 10 seconds before retrying...\n");
			for(i = 0; i &lt; 100; i++) {
				if (glbl.GetGlobalInputTermState() != 0)
					goto end_loop;
				srSleep(0, 100000);
			}
			if (me-&gt;inst-&gt;currentNode == NULL) {
				if(RS_RET_OK != redisActualizeCurrentNode(me-&gt;inst))
					continue;
			}
			if(me-&gt;inst-&gt;currentNode != NULL) {
				if(RS_RET_OK != redisConnectAsync(&amp;(me-&gt;inst-&gt;aconn), me-&gt;inst-&gt;currentNode)) {
					me-&gt;inst-&gt;currentNode = NULL;
					continue;
				}
				if(	me-&gt;inst-&gt;password != NULL &amp;&amp;
					me-&gt;inst-&gt;password[0] != '\0' &amp;&amp;
					RS_RET_OK != redisAuthenticate(me-&gt;inst)) {
					redisAsyncFree(me-&gt;inst-&gt;aconn);
					me-&gt;inst-&gt;aconn = NULL;
					me-&gt;inst-&gt;currentNode = NULL;
					continue;
				}
			}
			me-&gt;inst-&gt;aconn-&gt;data = (void *)me-&gt;inst;
			redisAsyncSetConnectCallback(me-&gt;inst-&gt;aconn, redisAsyncConnectCallback);
			redisAsyncSetDisconnectCallback(me-&gt;inst-&gt;aconn, redisAsyncDisconnectCallback);
			redisLibeventAttach(me-&gt;inst-&gt;aconn, me-&gt;inst-&gt;evtBase);
		}
		if (me-&gt;inst-&gt;aconn != NULL) {
			DBGPRINTF("imhiredis (async): subscribing to channel '%s'\n", me-&gt;inst-&gt;key);
			redisAsyncCommand(
				me-&gt;inst-&gt;aconn,
				redisAsyncRecvCallback,
				NULL,
				"SUBSCRIBE %s",
				me-&gt;inst-&gt;key);
			event_base_dispatch(me-&gt;inst-&gt;evtBase);
		}
	}
end_loop:
	return;
}
void workerLoopQueue(struct imhiredisWrkrInfo_s *me) {
	uint i;
	DBGPRINTF("imhiredis: beginning of queue worker loop...\n");
	if (me-&gt;inst-&gt;currentNode != NULL) {
		if(RS_RET_OK != redisConnectSync(&amp;(me-&gt;inst-&gt;conn), me-&gt;inst-&gt;currentNode)) {
			me-&gt;inst-&gt;currentNode = NULL;
		}
		if(	me-&gt;inst-&gt;password != NULL &amp;&amp;
			me-&gt;inst-&gt;password[0] != '\0' &amp;&amp;
			RS_RET_OK != redisAuthenticate(me-&gt;inst)) {
			redisFree(me-&gt;inst-&gt;conn);
			me-&gt;inst-&gt;conn = NULL;
			me-&gt;inst-&gt;currentNode = NULL;
		}
	}
	while(glbl.GetGlobalInputTermState() == 0) {
		if (me-&gt;inst-&gt;conn == NULL) {
			DBGPRINTF("imhiredis: no valid connection, sleeping 10 seconds before retrying...\n");
			for(i = 0; i &lt; 100; i++) {
				if (glbl.GetGlobalInputTermState() != 0)
					goto end_loop;
				srSleep(0, 100000);
			}
			if (me-&gt;inst-&gt;currentNode == NULL) {
				if(RS_RET_OK != redisActualizeCurrentNode(me-&gt;inst))
					continue;
			}
			if(me-&gt;inst-&gt;currentNode != NULL) {
				if(RS_RET_OK != redisConnectSync(&amp;(me-&gt;inst-&gt;conn), me-&gt;inst-&gt;currentNode)) {
					me-&gt;inst-&gt;currentNode = NULL;
					continue;
				}
				if(	me-&gt;inst-&gt;password != NULL &amp;&amp;
					me-&gt;inst-&gt;password[0] != '\0' &amp;&amp;
					RS_RET_OK != redisAuthenticate(me-&gt;inst)) {
					redisFree(me-&gt;inst-&gt;conn);
					me-&gt;inst-&gt;conn = NULL;
					me-&gt;inst-&gt;currentNode = NULL;
					continue;
				}
			}
		}
		if (me-&gt;inst-&gt;conn != NULL) {
			if (redisDequeue(me-&gt;inst) == RS_RET_REDIS_ERROR) {
				DBGPRINTF("imhiredis: current connection invalidated\n");
				redisFree(me-&gt;inst-&gt;conn);
				me-&gt;inst-&gt;currentNode = NULL;
				me-&gt;inst-&gt;conn = NULL;
			}
			if(glbl.GetGlobalInputTermState() == 0) {
				for(i = 0; i &lt; 10; i++) {
					if (glbl.GetGlobalInputTermState() != 0)
						goto end_loop;
					srSleep(0, 100000);
				}
			}
		}
	}
end_loop:
	return;
}
static void *
imhirediswrkr(void *myself)
{
	struct imhiredisWrkrInfo_s *me = (struct imhiredisWrkrInfo_s*) myself;
	DBGPRINTF("imhiredis: started hiredis consumer workerthread\n");
	dbgPrintNode(me-&gt;inst-&gt;currentNode);
	if(me-&gt;inst-&gt;mode == IMHIREDIS_MODE_QUEUE)
		workerLoopQueue(me);
	else if (me-&gt;inst-&gt;mode == IMHIREDIS_MODE_SUBSCRIBE)
		workerLoopSubscribe(me);
	DBGPRINTF("imhiredis: stopped hiredis consumer workerthread\n");
	return NULL;
}
static rsRetVal
createRedisNode(redisNode **root) {
	redisNode *node;
	DEFiRet;
	CHKmalloc(node = malloc(sizeof(redisNode)));
	node-&gt;port = 0;
	node-&gt;server = NULL;
	node-&gt;socketPath = NULL;
	node-&gt;usesSocket = 0;
	node-&gt;isMaster = 0;
	node-&gt;next = NULL;
	if (!root) {
		*root = node;
	} else {
		node-&gt;next = (*root);
		*root = node;
	}
finalize_it:
	RETiRet;
}
rsRetVal copyNode(redisNode *src, redisNode **dst) {
	DEFiRet;
	assert(src != NULL);
	CHKiRet(createRedisNode(dst));
	(*dst)-&gt;isMaster = src-&gt;isMaster;
	(*dst)-&gt;next = src-&gt;next;
	(*dst)-&gt;port = src-&gt;port;
	(*dst)-&gt;usesSocket = src-&gt;usesSocket;
	if (src-&gt;server)
		(*dst)-&gt;server = (uchar *) strdup((const char *)src-&gt;server);
	if (src-&gt;socketPath)
		(*dst)-&gt;socketPath = (uchar *) strdup((const char *)src-&gt;socketPath);
finalize_it:
	RETiRet;
}
redisNode *freeNode(redisNode *node) {
	redisNode *ret = NULL;
	if (node != NULL) {
		if (node-&gt;next != NULL)
			ret = node-&gt;next;
		if(node-&gt;server != NULL)
			free(node-&gt;server);
		if(node-&gt;socketPath != NULL)
			free(node-&gt;socketPath);
		free(node);
	}
	return ret;
}
void insertNodeAfter(redisNode *root, redisNode *elem) {
	assert(root != NULL);
	assert(elem != NULL);
	if(root-&gt;next != NULL) {
		elem-&gt;next = root-&gt;next;
	}
	root-&gt;next = elem;
	return;
}
void dbgPrintNode(redisNode *node) {
	if (node != NULL) {
		if (node-&gt;usesSocket) {
			if (node-&gt;isMaster) {
				DBGPRINTF("imhiredis: node is %s (master)\n", node-&gt;socketPath);
			} else {
				DBGPRINTF("imhiredis: node is %s (replica)\n", node-&gt;socketPath);
			}
		} else {
			if (node-&gt;isMaster) {
				DBGPRINTF("imhiredis: node is %s:%d (master)\n", node-&gt;server, node-&gt;port);
			} else {
				DBGPRINTF("imhiredis: node is %s:%d (replica)\n", node-&gt;server, node-&gt;port);
			}
		}
	}
	return;
}
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>imfile.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
#include "config.h"
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;assert.h&gt;
#include &lt;string.h&gt;
#include &lt;errno.h&gt;
#include &lt;fcntl.h&gt;
#include &lt;pthread.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;unistd.h&gt;
#include &lt;time.h&gt;
#include &lt;glob.h&gt;
#include &lt;poll.h&gt;
#include &lt;json.h&gt;
#include &lt;fnmatch.h&gt;
#ifdef HAVE_SYS_INOTIFY_H
#include &lt;sys/inotify.h&gt;
#include &lt;linux/types.h&gt;
#endif
#ifdef HAVE_SYS_STAT_H
#	include &lt;sys/stat.h&gt;
#endif
#if defined(OS_SOLARIS) &amp;&amp; defined (HAVE_PORT_SOURCE_FILE)
#include &lt;port.h&gt;
#include &lt;sys/port.h&gt;
#endif
#include "rsyslog.h"		#include "dirty.h"
#include "cfsysline.h"		#include "module-template.h"	#include "srUtils.h"		#include "msg.h"
#include "stream.h"
#include "errmsg.h"
#include "glbl.h"
#include "unicode-helper.h"
#include "prop.h"
#include "stringbuf.h"
#include "ruleset.h"
#include "ratelimit.h"
#include "srUtils.h"
#include "parserif.h"
#include "datetime.h"
#include &lt;regex.h&gt;
#ifndef O_LARGEFILE
#  define O_LARGEFILE 0
#endif
#ifndef HAVE_LSEEK64
#  define lseek64(fd, offset, whence) lseek(fd, offset, whence)
#endif
MODULE_TYPE_INPUT
MODULE_TYPE_NOKEEP
MODULE_CNFNAME("imfile")
#define FILE_ID_HASH_SIZE 20	#define FILE_ID_SIZE	512	
DEF_IMOD_STATIC_DATA	DEFobjCurrIf(glbl)
DEFobjCurrIf(strm)
DEFobjCurrIf(prop)
DEFobjCurrIf(ruleset)
DEFobjCurrIf(datetime)
extern int rs_siphash(const uint8_t *in, const size_t inlen, const uint8_t *k,
	uint8_t *out, const size_t outlen); 
static int bLegacyCnfModGlobalsPermitted;
#define NUM_MULTISUB 1024 #define DFLT_PollInterval 10
#define INIT_WDMAP_TAB_SIZE 1 #define ADD_METADATA_UNSPECIFIED -1
#define ULTRA_DEBUG 0
#ifndef GLOB_BRACE
	#define GLOB_BRACE 0
#endif
typedef struct per_minute_rate_limit_s per_minute_rate_limit_t;
struct per_minute_rate_limit_s {
	uint64_t maxBytesPerMinute;
	uint32_t maxLinesPerMinute;
	uint64_t bytesThisMinute; 	uint32_t linesThisMinute; 	time_t rateLimitingMinute; };
static struct configSettings_s {
	uchar *pszFileName;
	uchar *pszFileTag;
	uchar *pszStateFile;
	uchar *pszBindRuleset;
	int iPollInterval;
	int iPersistStateInterval;		int bPersistStateAfterSubmission;	int iFacility; 	int iSeverity;  	int readMode;  	int64 maxLinesAtOnce;		uint64_t maxBytesPerMinute; 	uint64_t maxLinesPerMinute; 	uint32_t trimLineOverBytes;  } cs;
struct instanceConf_s {
	uchar *pszFileName;
	uchar *pszFileName_forOldStateFile; 	uchar *pszDirName;
	uchar *pszFileBaseName;
	uchar *pszTag;
	size_t lenTag;
	uchar *pszStateFile;
	uchar *pszBindRuleset;
	int nMultiSub;
	per_minute_rate_limit_t perMinuteRateLimits;
	int iPersistStateInterval;
	int bPersistStateAfterSubmission;
	int iFacility;
	int iSeverity;
	int readTimeout;
	unsigned delay_perMsg;
	sbool bRMStateOnDel;
	uint8_t readMode;
	uchar *startRegex;
	uchar *endRegex;
	regex_t start_preg;		regex_t end_preg;		sbool discardTruncatedMsg;
	sbool msgDiscardingError;
	sbool escapeLF;
	sbool reopenOnTruncate;
	sbool addCeeTag;
	sbool addMetadata;
	sbool freshStartTail;
	sbool fileNotFoundError;
	int maxLinesAtOnce;
	uint32_t trimLineOverBytes;
	uint32_t ignoreOlderThan;
	int msgFlag;
	uchar *escapeLFString;
	ruleset_t *pBindRuleset;		struct instanceConf_s *next;
};
typedef struct fs_edge_s fs_edge_t;
typedef struct fs_node_s fs_node_t;
typedef struct act_obj_s act_obj_t;
struct act_obj_s {
	act_obj_t *prev;
	act_obj_t *next;
	fs_edge_t *edge;		char *name;			char *basename;			char *source_name;		int wd;
#if defined(OS_SOLARIS) &amp;&amp; defined (HAVE_PORT_SOURCE_FILE)
	struct fileinfo *pfinf;
	sbool bPortAssociated;
	int is_deleted;	#endif
	ratelimit_t *ratelimiter;
	multi_submit_t multiSub;
	int is_symlink;
};
struct fs_edge_s {
	fs_node_t *parent;		fs_node_t *node;		fs_edge_t *next;
	uchar *name;
	uchar *path;
	act_obj_t *active;
	int is_file;
	int ninst;			instanceConf_t **instarr;
};
struct fs_node_s {
	fs_edge_t *edges;		fs_node_t *root;	};
static rsRetVal persistStrmState(act_obj_t *);
static rsRetVal resetConfigVariables(uchar __attribute__((unused)) *pp, void __attribute__((unused)) *pVal);
static rsRetVal ATTR_NONNULL(1) pollFile(act_obj_t *act);
static int ATTR_NONNULL() getBasename(uchar *const __restrict__ basen, uchar *const __restrict__ path);
static void ATTR_NONNULL() act_obj_unlink(act_obj_t *act);
static uchar * ATTR_NONNULL(1, 2) getStateFileName(const act_obj_t *, uchar *, const size_t);
static int ATTR_NONNULL() getFullStateFileName(const uchar *const, const char *const,
	uchar *const pszout, const size_t ilenout);
#define OPMODE_POLLING 0
#define OPMODE_INOTIFY 1
#define OPMODE_FEN 2
struct modConfData_s {
	rsconf_t *pConf;		int iPollInterval;		int readTimeout;
	int timeoutGranularity;			instanceConf_t *root, *tail;
	fs_node_t *conf_tree;
	uint8_t opMode;
	sbool configSetViaV2Method;
	uchar *stateFileDirectory;
	sbool sortFiles;
};
static modConfData_t *loadModConf = NULL;static modConfData_t *runModConf = NULL;static modConfData_t *currModConf = NULL;
#ifdef HAVE_INOTIFY_INIT
struct wd_map_s {
	int wd;			act_obj_t *act; };
typedef struct wd_map_s wd_map_t;
static wd_map_t *wdmap = NULL;
static int nWdmap;
static int allocMaxWdmap;
static int ino_fd;	#endif 
#if defined(OS_SOLARIS) &amp;&amp; defined (HAVE_PORT_SOURCE_FILE)
struct fileinfo {
	struct file_obj fobj;
	int events;
	int port;
};
#endif 
static prop_t *pInputName = NULL;
static struct cnfparamdescr modpdescr[] = {
	{ "pollinginterval", eCmdHdlrPositiveInt, 0 },
	{ "readtimeout", eCmdHdlrNonNegInt, 0 },
	{ "timeoutgranularity", eCmdHdlrPositiveInt, 0 },
	{ "sortfiles", eCmdHdlrBinary, 0 },
<a name="0"></a>	{ "statefile.directory", eCmdHdlrString, 0 },
	{ "normalizepath", eCmdHdlrBinary, 0 },
	{ "mode", eCmdHdlrGetWord, 0 }
<font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>};
static struct cnfparamblk modpblk =
	{ CNFPARAMBLK_VERSION,
	  sizeof(modpdescr)/sizeof(struct cnfparamdescr),
	  modpdescr
	};
static struct cnfparamdescr inppdescr[] = {
	{ "file", eCmdHdlrString, CNFPARAM_REQUIRED },
	{ "tag", eCmdHdlrString, CNFPARAM_REQUIRED },
	{ "severity", eCmdHdlrSeverity, 0 },
	{ "facility", eCmdHdlrFacility, 0 },
	{ "ruleset", eCmdHdlrString, 0 },
	{ "readmode", eCmdHdlrInt, 0 },
	{ "startmsg.regex", eCmdHdlrString, 0 },
	{ "endmsg.regex", eCmdHdlrString, 0 },</b></font>
	{ "discardtruncatedmsg", eCmdHdlrBinary, 0 },
	{ "msgdiscardingerror", eCmdHdlrBinary, 0 },
	{ "escapelf", eCmdHdlrBinary, 0 },
	{ "escapelf.replacement", eCmdHdlrString, 0 },
	{ "reopenontruncate", eCmdHdlrBinary, 0 },
	{ "maxlinesatonce", eCmdHdlrInt, 0 },
	{ "trimlineoverbytes", eCmdHdlrInt, 0 },
	{ "maxsubmitatonce", eCmdHdlrInt, 0 },
	{ "removestateondelete", eCmdHdlrBinary, 0 },
	{ "persiststateinterval", eCmdHdlrInt, 0 },
	{ "persiststateaftersubmission", eCmdHdlrBinary, 0 },
	{ "deletestateonfiledelete", eCmdHdlrBinary, 0 },
	{ "delay.message", eCmdHdlrNonNegInt, 0 },
	{ "addmetadata", eCmdHdlrBinary, 0 },
	{ "addceetag", eCmdHdlrBinary, 0 },
	{ "statefile", eCmdHdlrString, CNFPARAM_DEPRECATED },
	{ "readtimeout", eCmdHdlrNonNegInt, 0 },
	{ "freshstarttail", eCmdHdlrBinary, 0},
	{ "filenotfounderror", eCmdHdlrBinary, 0},
	{ "needparse", eCmdHdlrBinary, 0},
	{ "ignoreolderthan", eCmdHdlrInt, 0},
	{ "maxbytesperminute", eCmdHdlrInt, 0},
	{ "maxlinesperminute", eCmdHdlrInt, 0}
};
static struct cnfparamblk inppblk =
	{ CNFPARAMBLK_VERSION,
	  sizeof(inppdescr)/sizeof(struct cnfparamdescr),
	  inppdescr
	};
#include "im-helper.h" 
#define ENABLE_V1_STATE_FILE_FORMAT_SUPPORT 1
#ifdef ENABLE_V1_STATE_FILE_FORMAT_SUPPORT
static uchar * ATTR_NONNULL(1, 2)
OLD_getStateFileName(const instanceConf_t *const inst,
	 uchar *const __restrict__ buf,
	 const size_t lenbuf)
{
	DBGPRINTF("OLD_getStateFileName trying '%s'\n", inst-&gt;pszFileName_forOldStateFile);
	snprintf((char*)buf, lenbuf - 1, "imfile-state:%s", inst-&gt;pszFileName_forOldStateFile);
	buf[lenbuf-1] = '\0'; 	uchar *p = buf;
	for( ; *p ; ++p) {
		if(*p == '/')
			*p = '-';
	}
	return buf;
}
static const uchar *
getStateFileDir(void)
{
	const uchar *wrkdir;
	assert(currModConf != NULL);
	if(currModConf-&gt;stateFileDirectory == NULL) {
		wrkdir = glblGetWorkDirRaw(currModConf-&gt;pConf);
	} else {
		wrkdir = currModConf-&gt;stateFileDirectory;
	}
	return(wrkdir);
}
static rsRetVal ATTR_NONNULL(1)
OLD_openFileWithStateFile(act_obj_t *const act)
{
	DEFiRet;
	strm_t *psSF = NULL;
	uchar pszSFNam[MAXFNAME];
	size_t lenSFNam;
	struct stat stat_buf;
	uchar statefile[MAXFNAME];
	const instanceConf_t *const inst = act-&gt;edge-&gt;instarr[0];
	uchar *const statefn = OLD_getStateFileName(inst, statefile, sizeof(statefile));
	DBGPRINTF("OLD_openFileWithStateFile: trying to open state for '%s', state file '%s'\n",
		  act-&gt;name, statefn);
	lenSFNam = getFullStateFileName(statefn, "", pszSFNam, sizeof(pszSFNam));
	if(stat((char*) pszSFNam, &amp;stat_buf) == -1) {
		if(errno == ENOENT) {
			DBGPRINTF("OLD_openFileWithStateFile: NO state file (%s) exists for '%s'\n",
				pszSFNam, act-&gt;name);
			ABORT_FINALIZE(RS_RET_FILE_NOT_FOUND);
		} else {
			char errStr[1024];
			rs_strerror_r(errno, errStr, sizeof(errStr));
			DBGPRINTF("OLD_openFileWithStateFile: error trying to access state "
				"file for '%s':%s\n", act-&gt;name, errStr);
			ABORT_FINALIZE(RS_RET_IO_ERROR);
		}
	}
	DBGPRINTF("old state file found - instantiating from it\n");
	CHKiRet(strm.Construct(&amp;psSF));
	CHKiRet(strm.SettOperationsMode(psSF, STREAMMODE_READ));
	CHKiRet(strm.SetsType(psSF, STREAMTYPE_FILE_SINGLE));
	CHKiRet(strm.SetFName(psSF, pszSFNam, lenSFNam));
	CHKiRet(strm.SetFileNotFoundError(psSF, inst-&gt;fileNotFoundError));
	CHKiRet(strm.ConstructFinalize(psSF));
	CHKiRet(obj.Deserialize(&amp;act-&gt;pStrm, (uchar*) "strm", psSF, NULL, act));
	free(act-&gt;pStrm-&gt;pszFName);
	CHKmalloc(act-&gt;pStrm-&gt;pszFName = ustrdup(act-&gt;name));
	strm.CheckFileChange(act-&gt;pStrm);
	CHKiRet(strm.SeekCurrOffs(act-&gt;pStrm));
	persistStrmState(act);
	unlink((char*)pszSFNam);
finalize_it:
	if(psSF != NULL)
		strm.Destruct(&amp;psSF);
	RETiRet;
}
#endif 
#if 0 static const char * ATTR_NONNULL()
gen_full_name(const char *const dirname, const char *const name)
{
	const size_t len_full_name = strlen(dirname) + 1 + strlen(name) + 1;
	char *const full_name = malloc(len_full_name);
	if(full_name == NULL)
		return NULL;
	snprintf(full_name, len_full_name, "%s/%s", dirname, name);
	return full_name;
}
#endif
#ifdef HAVE_INOTIFY_INIT
#if ULTRA_DEBUG == 1
static void
dbg_wdmapPrint(const char *msg)
{
	int i;
	DBGPRINTF("%s\n", msg);
	for(i = 0 ; i &lt; nWdmap ; ++i)
		DBGPRINTF("wdmap[%d]: wd: %d, act %p, name: %s\n",
			i, wdmap[i].wd, wdmap[i].act, wdmap[i].act-&gt;name);
}
#endif
static rsRetVal
wdmapInit(void)
{
	DEFiRet;
	free(wdmap);
	CHKmalloc(wdmap = malloc(sizeof(wd_map_t) * INIT_WDMAP_TAB_SIZE));
	allocMaxWdmap = INIT_WDMAP_TAB_SIZE;
	nWdmap = 0;
finalize_it:
	RETiRet;
}
static rsRetVal
wdmapAdd(int wd, act_obj_t *const act)
{
	wd_map_t *newmap;
	int newmapsize;
	int i;
	DEFiRet;
	for(i = nWdmap-1 ; i &gt;= 0 &amp;&amp; wdmap[i].wd &gt; wd ; --i)
		; 		if(i &gt;= 0 &amp;&amp; wdmap[i].wd == wd) {
		LogError(0, RS_RET_INTERNAL_ERROR, "imfile: wd %d already in wdmap!", wd);
		ABORT_FINALIZE(RS_RET_FILE_ALREADY_IN_TABLE);
	}
	++i;
	if(nWdmap == allocMaxWdmap) {
		newmapsize = 2 * allocMaxWdmap;
		CHKmalloc(newmap = realloc(wdmap, sizeof(wd_map_t) * newmapsize));
		wdmap = newmap;
		allocMaxWdmap = newmapsize;
	}
	if(i &lt; nWdmap) {
		memmove(wdmap + i + 1, wdmap + i, sizeof(wd_map_t) * (nWdmap - i));
	}
	wdmap[i].wd = wd;
	wdmap[i].act = act;
	++nWdmap;
	DBGPRINTF("add wdmap[%d]: wd %d, act obj %p, path %s\n", i, wd, act, act-&gt;name);
finalize_it:
	RETiRet;
}
static int
in_setupWatch(act_obj_t *const act, const int is_file)
{
	int wd = -1;
	if(runModConf-&gt;opMode != OPMODE_INOTIFY)
		goto done;
	wd = inotify_add_watch(ino_fd, act-&gt;name,
		(is_file) ? IN_MODIFY|IN_DONT_FOLLOW : IN_CREATE|IN_DELETE|IN_MOVED_FROM|IN_MOVED_TO);
	if(wd &lt; 0) {
		if (errno == EACCES) { 			DBGPRINTF("imfile: permission denied when adding watch for '%s'\n", act-&gt;name);
		} else {
			LogError(errno, RS_RET_IO_ERROR, "imfile: cannot watch object '%s'", act-&gt;name);
		}
		goto done;
	}
	wdmapAdd(wd, act);
	DBGPRINTF("in_setupWatch: watch %d added for %s(object %p)\n", wd, act-&gt;name, act);
done:	return wd;
}
static int
wdmap_cmp(const void *k, const void *a)
{
	int key = *((int*) k);
	wd_map_t *etry = (wd_map_t*) a;
	if(key &lt; etry-&gt;wd)
		return -1;
	else if(key &gt; etry-&gt;wd)
		return 1;
	else
		return 0;
}
static wd_map_t *
wdmapLookup(int wd)
{
	return bsearch(&amp;wd, wdmap, nWdmap, sizeof(wd_map_t), wdmap_cmp);
}
static rsRetVal
wdmapDel(const int wd)
{
	int i;
	DEFiRet;
	for(i = 0 ; i &lt; nWdmap &amp;&amp; wdmap[i].wd &lt; wd ; ++i)
		; 		if(i == nWdmap ||  wdmap[i].wd != wd) {
		DBGPRINTF("wd %d shall be deleted but not in wdmap!\n", wd);
		FINALIZE;
	}
	if(i &lt; nWdmap-1) {
		memmove(wdmap + i, wdmap + i + 1, sizeof(wd_map_t) * (nWdmap - i - 1));
	}
	--nWdmap;
	DBGPRINTF("wd %d deleted, was idx %d\n", wd, i);
finalize_it:
	RETiRet;
}
#endif 
#if defined(OS_SOLARIS) &amp;&amp; defined (HAVE_PORT_SOURCE_FILE)
static void ATTR_NONNULL()
fen_setupWatch(act_obj_t *const act)
{
	DBGPRINTF("fen_setupWatch: enter, opMode %d\n", runModConf-&gt;opMode);
	if(runModConf-&gt;opMode != OPMODE_FEN)
		goto done;
	DBGPRINTF("fen_setupWatch: %s\n", act-&gt;name);
	if(act-&gt;pfinf == NULL) {
		act-&gt;pfinf = malloc(sizeof(struct fileinfo));
		if (act-&gt;pfinf == NULL) {
			LogError(errno, RS_RET_OUT_OF_MEMORY, "imfile: fen_setupWatch alloc memory "
				"for fileinfo failed ");
			goto done;
		}
		if ((act-&gt;pfinf-&gt;fobj.fo_name = strdup(act-&gt;name)) == NULL) {
			LogError(errno, RS_RET_OUT_OF_MEMORY, "imfile: fen_setupWatch alloc memory "
				"for strdup failed ");
			free(act-&gt;pfinf);
			act-&gt;pfinf = NULL;
			goto done;
		}
		act-&gt;pfinf-&gt;events = FILE_MODIFIED;
		act-&gt;pfinf-&gt;port = glport;
		act-&gt;bPortAssociated = 0;
	}
	DBGPRINTF("fen_setupWatch: bPortAssociated %d\n", act-&gt;bPortAssociated);
	if(act-&gt;bPortAssociated) {
		goto done;
	}
	struct stat fileInfo;
	const int r = stat(act-&gt;name, &amp;fileInfo);
	if(r == -1) { 		DBGPRINTF("fen_setupWatch: file gone away, no watch: '%s'\n", act-&gt;name);
		goto done;
	}
	act-&gt;pfinf-&gt;fobj.fo_atime = fileInfo.st_atim;
	act-&gt;pfinf-&gt;fobj.fo_mtime = fileInfo.st_mtim;
	act-&gt;pfinf-&gt;fobj.fo_ctime = fileInfo.st_ctim;
	if(port_associate(glport, PORT_SOURCE_FILE, (uintptr_t)&amp;(act-&gt;pfinf-&gt;fobj),
				act-&gt;pfinf-&gt;events, (void *)act) == -1) {
		LogError(errno, RS_RET_SYS_ERR, "fen_setupWatch: Failed to associate port for file "
			": %s\n", act-&gt;pfinf-&gt;fobj.fo_name);
		goto done;
	} else {
		DBGPRINTF("fen_setupWatch: associated port for file %s\n", act-&gt;name);
		act-&gt;bPortAssociated = 1;
	}
	DBGPRINTF("in_setupWatch: fen association added for %s\n", act-&gt;name);
done:	return;
}
#else
static void ATTR_NONNULL()
fen_setupWatch(act_obj_t *const act __attribute__((unused)))
{
	DBGPRINTF("fen_setupWatch: DUMMY CALLED - not on Solaris?\n");
}
#endif 
static void
fs_node_print(const fs_node_t *const node, const int level)
{
	fs_edge_t *chld;
	act_obj_t *act;
	dbgprintf("node print[%2.2d]: %p edges:\n", level, node);
	for(chld = node-&gt;edges ; chld != NULL ; chld = chld-&gt;next) {
		dbgprintf("node print[%2.2d]:     child %p '%s' isFile %d, path: '%s'\n",
			level, chld-&gt;node, chld-&gt;name, chld-&gt;is_file, chld-&gt;path);
		for(int i = 0 ; i &lt; chld-&gt;ninst ; ++i) {
			dbgprintf("\tinst: %p\n", chld-&gt;instarr[i]);
		}
		for(act = chld-&gt;active ; act != NULL ; act = act-&gt;next) {
			dbgprintf("\tact : %p\n", act);
			dbgprintf("\tact : %p: name '%s', wd: %d\n",
				act, act-&gt;name, act-&gt;wd);
		}
	}
	for(chld = node-&gt;edges ; chld != NULL ; chld = chld-&gt;next) {
		fs_node_print(chld-&gt;node, level+1);
	}
}
static sbool
isIgnoreOlderFile(const instanceConf_t *const inst, const char *const name)
{
	if (inst-&gt;ignoreOlderThan)
	{
		struct stat stat_buf;
		time_t tt;
		datetime.GetTime(&amp;tt);
		if (stat((char *)name, &amp;stat_buf) == 0 &amp;&amp; difftime(tt, stat_buf.st_mtime) &gt; inst-&gt;ignoreOlderThan) {
			return 1;
		}
	}
	return 0;
}
static rsRetVal ATTR_NONNULL(1,2)
act_obj_add(fs_edge_t *const edge, const char *const name, const int is_file,
	const ino_t ino, const int is_symlink, const char *const source)
{
	act_obj_t *act = NULL;
	char basename[MAXFNAME];
	DEFiRet;
	int fd = -1;
	DBGPRINTF("act_obj_add: edge %p, name '%s' (source '%s')\n", edge, name, source? source : "---");
	if (isIgnoreOlderFile(edge-&gt;instarr[0], name)) {
		ABORT_FINALIZE(RS_RET_ERR);
	}
	for(act = edge-&gt;active ; act != NULL ; act = act-&gt;next) {
		if(!strcmp(act-&gt;name, name)) {
			if (!source || !act-&gt;source_name || !strcmp(act-&gt;source_name, source)) {
				DBGPRINTF("active object '%s' already exists in '%s' - no need to add\n",
					name, edge-&gt;path);
				FINALIZE;
			}
		}
	}
	DBGPRINTF("need to add new active object '%s' in '%s' - checking if accessible\n", name, edge-&gt;path);
	fd = open(name, O_RDONLY | O_CLOEXEC);
	if(fd &lt; 0) {
		if (is_file) {
			LogError(errno, RS_RET_ERR, "imfile: error accessing file '%s'", name);
		} else { 			DBGPRINTF("imfile: error accessing directory '%s'", name);
		}
		ABORT_FINALIZE(RS_RET_NO_FILE_ACCESS);
	}
	DBGPRINTF("add new active object '%s' in '%s'\n", name, edge-&gt;path);
	CHKmalloc(act = calloc(sizeof(act_obj_t), 1));
	CHKmalloc(act-&gt;name = strdup(name));
	if (-1 == getBasename((uchar*)basename, (uchar*)name)) {
		CHKmalloc(act-&gt;basename = strdup(name)); 	} else {
		CHKmalloc(act-&gt;basename = strdup(basename));
	}
	act-&gt;edge = edge;
	act-&gt;ino = ino;
	act-&gt;fd = fd;
	act-&gt;file_id[0] = '\0';
	act-&gt;file_id_prev[0] = '\0';
	act-&gt;is_symlink = is_symlink;
	act-&gt;ratelimiter = NULL;
	if (source) { 		CHKmalloc(act-&gt;source_name = strdup(source));
	} else {
		act-&gt;source_name = NULL;
	}
	#ifdef HAVE_INOTIFY_INIT
	act-&gt;wd = in_setupWatch(act, is_file);
	#endif
	fen_setupWatch(act);
	if(is_file &amp;&amp; !is_symlink) {
		const instanceConf_t *const inst = edge-&gt;instarr[0];		CHKiRet(ratelimitNew(&amp;act-&gt;ratelimiter, "imfile", name));
		CHKmalloc(act-&gt;multiSub.ppMsgs = malloc(inst-&gt;nMultiSub * sizeof(smsg_t *)));
		act-&gt;multiSub.maxElem = inst-&gt;nMultiSub;
		act-&gt;multiSub.nElem = 0;
		pollFile(act);
	}
	if(edge-&gt;active != NULL) {
		edge-&gt;active-&gt;prev = act;
	}
	act-&gt;next = edge-&gt;active;
	edge-&gt;active = act;
finalize_it:
	if(iRet != RS_RET_OK) {
		if(act != NULL) {
			if (act-&gt;ratelimiter != NULL)
				ratelimitDestruct(act-&gt;ratelimiter);
			free(act-&gt;name);
			free(act);
		}
		if(fd != -1) {
			close(fd);
		}
	}
	RETiRet;
}
static void
detect_updates(fs_edge_t *const edge)
{
	act_obj_t *act;
	struct stat fileInfo;
	int restart = 0;
	for(act = edge-&gt;active ; act != NULL ; act = act-&gt;next) {
		DBGPRINTF("detect_updates checking active obj '%s'\n", act-&gt;name);
		const int r = lstat(act-&gt;name, &amp;fileInfo);
		if(r == -1) { 			DBGPRINTF("object gone away, unlinking: '%s'\n", act-&gt;name);
			act_obj_unlink(act);
			restart = 1;
			break;
		} else if(fileInfo.st_ino != act-&gt;ino) {
			DBGPRINTF("file '%s' inode changed from %llu to %llu, unlinking from "
				"internal lists\n", act-&gt;name, (long long unsigned) act-&gt;ino,
				(long long unsigned) fileInfo.st_ino);
			if(act-&gt;pStrm != NULL) {
				strmSet_checkRotation(act-&gt;pStrm, STRM_ROTATION_DO_NOT_CHECK);
			}
			act_obj_unlink(act);
			restart = 1;
			break;
		}
	}
	if (restart) {
		detect_updates(edge);
	}
}
static void ATTR_NONNULL()
poll_active_files(fs_edge_t *const edge)
{
	if(   runModConf-&gt;opMode != OPMODE_POLLING
	   || !edge-&gt;is_file
	   || glbl.GetGlobalInputTermState() != 0) {
		return;
	}
	act_obj_t *act;
	for(act = edge-&gt;active ; act != NULL ; act = act-&gt;next) {
		fen_setupWatch(act);
		DBGPRINTF("poll_active_files: polling '%s'\n", act-&gt;name);
		pollFile(act);
	}
}
static rsRetVal ATTR_NONNULL()
process_symlink(fs_edge_t *const chld, const char *symlink)
{
	DEFiRet;
	char *target;
	CHKmalloc(target = realpath(symlink, NULL));
	struct stat fileInfo;
	if(lstat(target, &amp;fileInfo) != 0) {
		LogError(errno, RS_RET_ERR,	"imfile: process_symlink: cannot stat file '%s' - ignored", target);
		FINALIZE;
	}
	const int is_file = (S_ISREG(fileInfo.st_mode));
	DBGPRINTF("process_symlink:  found '%s', File: %d (config file: %d), symlink: %d\n",
		target, is_file, chld-&gt;is_file, 0);
	if (act_obj_add(chld, target, is_file, fileInfo.st_ino, 0, symlink) == RS_RET_OK) {
		uint idx = ustrlen(chld-&gt;active-&gt;name) - ustrlen(chld-&gt;active-&gt;basename);
		if (idx) { 			char parent[MAXFNAME];
			idx--; 			memcpy(parent, chld-&gt;active-&gt;name, idx);
			parent[idx] = '\0';
			if(lstat(parent, &amp;fileInfo) != 0) {
				LogError(errno, RS_RET_ERR,
					"imfile: process_symlink: cannot stat directory '%s' - ignored", parent);
				FINALIZE;
			}
			if (chld-&gt;parent-&gt;root-&gt;edges) {
				DBGPRINTF("process_symlink: adding parent '%s' of target '%s'\n", parent, target);
				act_obj_add(chld-&gt;parent-&gt;root-&gt;edges, parent, 0, fileInfo.st_ino, 0, NULL);
			}
		}
	}
finalize_it:
	free(target);
	RETiRet;
}
static void ATTR_NONNULL()
poll_tree(fs_edge_t *const chld)
{
	struct stat fileInfo;
	glob_t files;
	int need_globfree = 0;
	int issymlink;
	DBGPRINTF("poll_tree: chld %p, name '%s', path: %s\n", chld, chld-&gt;name, chld-&gt;path);
	detect_updates(chld);
	const int ret = glob((char*)chld-&gt;path, runModConf-&gt;sortFiles|GLOB_BRACE, NULL, &amp;files);
	need_globfree = 1;
	DBGPRINTF("poll_tree: glob returned %d\n", ret);
	if(ret == 0) {
		DBGPRINTF("poll_tree: processing %d files\n", (int) files.gl_pathc);
		for(unsigned i = 0 ; i &lt; files.gl_pathc ; i++) {
			if(glbl.GetGlobalInputTermState() != 0) {
				goto done;
			}
			char *const file = files.gl_pathv[i];
			if(lstat(file, &amp;fileInfo) != 0) {
				LogError(errno, RS_RET_ERR,
					"imfile: poll_tree cannot stat file '%s' - ignored", file);
				continue;
			}
			if (S_ISLNK(fileInfo.st_mode)) {
				rsRetVal slink_ret = process_symlink(chld, file);
				if (slink_ret != RS_RET_OK) {
					continue;
				}
				issymlink = 1;
			} else {
				issymlink = 0;
			}
			const int is_file = (S_ISREG(fileInfo.st_mode) || issymlink);
			DBGPRINTF("poll_tree:  found '%s', File: %d (config file: %d), symlink: %d\n",
				file, is_file, chld-&gt;is_file, issymlink);
			if(!is_file &amp;&amp; S_ISREG(fileInfo.st_mode)) {
				LogMsg(0, RS_RET_ERR, LOG_WARNING,
					"imfile: '%s' is neither a regular file, symlink, nor a "
					"directory - ignored", file);
				continue;
			}
			if(!issymlink &amp;&amp; (chld-&gt;is_file != is_file)) {
				LogMsg(0, RS_RET_ERR, LOG_WARNING,
					"imfile: '%s' is %s but %s expected - ignored",
					file, (is_file) ? "FILE" : "DIRECTORY",
					(chld-&gt;is_file) ? "FILE" : "DIRECTORY");
				continue;
			}
			act_obj_add(chld, file, is_file, fileInfo.st_ino, issymlink, NULL);
		}
	}
	poll_active_files(chld);
done:
	if(need_globfree) {
		globfree(&amp;files);
	}
	return;
}
#ifdef HAVE_INOTIFY_INIT static void ATTR_NONNULL()
poll_timeouts(fs_edge_t *const edge)
{
	if(edge-&gt;is_file) {
		act_obj_t *act;
		for(act = edge-&gt;active ; act != NULL ; act = act-&gt;next) {
			if(act-&gt;pStrm &amp;&amp; strmReadMultiLine_isTimedOut(act-&gt;pStrm)) {
				DBGPRINTF("timeout occurred on %s\n", act-&gt;name);
				pollFile(act);
			}
		}
	}
}
#endif
static void
act_obj_destroy(act_obj_t *const act, const int is_deleted)
{
	uchar *statefn;
	uchar statefile[MAXFNAME];
	uchar toDel[MAXFNAME];
	if(act == NULL)
		return;
	DBGPRINTF("act_obj_destroy: act %p '%s' (source '%s'), wd %d, pStrm %p, is_deleted %d, in_move %d\n",
		act, act-&gt;name, act-&gt;source_name? act-&gt;source_name : "---", act-&gt;wd, act-&gt;pStrm, is_deleted,
		act-&gt;in_move);
	if(act-&gt;is_symlink &amp;&amp; is_deleted) {
		act_obj_t *target_act;
		for(target_act = act-&gt;edge-&gt;active ; target_act != NULL ; target_act = target_act-&gt;next) {
			if(target_act-&gt;source_name &amp;&amp; !strcmp(target_act-&gt;source_name, act-&gt;name)) {
				DBGPRINTF("act_obj_destroy: unlinking slink target %s of %s "
						"symlink\n", target_act-&gt;name, act-&gt;name);
				act_obj_unlink(target_act);
				break;
			}
		}
	}
	if(act-&gt;pStrm != NULL) {
		const instanceConf_t *const inst = act-&gt;edge-&gt;instarr[0];		pollFile(act); 		if(inst-&gt;bRMStateOnDel) {
			statefn = getStateFileName(act, statefile, sizeof(statefile));
			getFullStateFileName(statefn, act-&gt;file_id, toDel, sizeof(toDel)); 			statefn = toDel;
		}
		persistStrmState(act);
		strm.Destruct(&amp;act-&gt;pStrm);
		if(is_deleted &amp;&amp; !act-&gt;in_move &amp;&amp; inst-&gt;bRMStateOnDel) {
			DBGPRINTF("act_obj_destroy: deleting state file %s\n", statefn);
<a name="6"></a>			unlink((char*)statefn);
		}
	}
<font color="#8c8774"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>	if(act-&gt;ratelimiter != NULL) {
		ratelimitDestruct(act-&gt;ratelimiter);
	}
	#ifdef HAVE_INOTIFY_INIT
	if(act-&gt;wd != -1) {
		inotify_rm_watch(ino_fd, act-&gt;wd);
		wdmapDel(act-&gt;wd);
	}
	#endif
	if(act-&gt;fd &gt;= 0) {
		close(act-&gt;fd);
	}
	#if defined(OS_SOLARIS) &amp;&amp; defined (HAVE_PORT_SOURCE_FILE)
	if(act-&gt;pfinf != NULL) {
		free(act-&gt;pfinf-&gt;fobj.fo_name);
		free(act-&gt;pfinf);
	}
	#endif
	free(act-&gt;basename);
	free(act-&gt;source_name);
	free(act-&gt;multiSub.ppMsgs);
	#if defined(OS_SOLARIS) &amp;&amp; defined (HAVE_PORT_SOURCE_FILE)
		act-&gt;is_deleted = 1;</b></font>
	#else
		free(act-&gt;name);
		free(act);
	#endif
}
static void
act_obj_destroy_all(act_obj_t *act)
{
	if(act == NULL)
		return;
	DBGPRINTF("act_obj_destroy_all: act %p '%s', wd %d, pStrm %p\n", act, act-&gt;name, act-&gt;wd, act-&gt;pStrm);
	while(act != NULL) {
		act_obj_t *const toDel = act;
		act = act-&gt;next;
		act_obj_destroy(toDel, 0);
	}
}
#if 0
static void
chk_active(const act_obj_t *act, const act_obj_t *const deleted)
{
	while(act != NULL) {
		DBGPRINTF("chk_active %p vs %p\n", act, deleted);
		if(act-&gt;prev == deleted)
			DBGPRINTF("chk_active %p prev points to %p\n", act, deleted);
		if(act-&gt;next == deleted)
			DBGPRINTF("chk_active %p next points to %p\n", act, deleted);
		act = act-&gt;next;
		DBGPRINTF("chk_active next %p\n", act);
	}
}
#endif
static void ATTR_NONNULL()
act_obj_unlink(act_obj_t *act)
{
	DBGPRINTF("act_obj_unlink %p: %s, pStrm %p\n", act, act-&gt;name, act-&gt;pStrm);
	if(act-&gt;prev == NULL) {
		act-&gt;edge-&gt;active = act-&gt;next;
	} else {
		act-&gt;prev-&gt;next = act-&gt;next;
	}
	if(act-&gt;next != NULL) {
		act-&gt;next-&gt;prev = act-&gt;prev;
	}
	act_obj_destroy(act, 1);
	act = NULL;
}
static void
fs_node_destroy(fs_node_t *const node)
{
	fs_edge_t *edge;
	DBGPRINTF("node destroy: %p edges:\n", node);
	for(edge = node-&gt;edges ; edge != NULL ; ) {
		fs_node_destroy(edge-&gt;node);
		fs_edge_t *const toDel = edge;
		edge = edge-&gt;next;
		act_obj_destroy_all(toDel-&gt;active);
		free(toDel-&gt;name);
		free(toDel-&gt;path);
		free(toDel-&gt;instarr);
		free(toDel);
	}
	free(node);
}
static void ATTR_NONNULL(1, 2)
fs_node_walk(fs_node_t *const node,
	void (*f_usr)(fs_edge_t*const))
{
	DBGPRINTF("node walk: %p edges:\n", node);
	fs_edge_t *edge;
	for(edge = node-&gt;edges ; edge != NULL ; edge = edge-&gt;next) {
		DBGPRINTF("node walk: child %p '%s'\n", edge-&gt;node, edge-&gt;name);
		f_usr(edge);
		fs_node_walk(edge-&gt;node, f_usr);
	}
}
static rsRetVal
fs_node_add(fs_node_t *const node,
	fs_node_t *const source,
	const uchar *const toFind,
	const size_t pathIdx,
	instanceConf_t *const inst)
{
	DEFiRet;
	fs_edge_t *newchld = NULL;
	int i;
	DBGPRINTF("fs_node_add(%p, '%s') enter, idx %zd\n",
		node, toFind+pathIdx, pathIdx);
	assert(toFind[0] != '\0');
	for(i = pathIdx ; (toFind[i] != '\0') &amp;&amp; (toFind[i] != '/') ; ++i)
	const int isFile = (toFind[i] == '\0') ? 1 : 0;
	uchar ourPath[PATH_MAX];
	if(i == 0) {
		ourPath[0] = '/';
		ourPath[1] = '\0';
	} else {
		memcpy(ourPath, toFind, i);
		ourPath[i] = '\0';
	}
	const size_t nextPathIdx = i+1;
	const size_t len = i - pathIdx;
	uchar name[PATH_MAX];
	memcpy(name, toFind+pathIdx, len);
	name[len] = '\0';
	DBGPRINTF("fs_node_add: name '%s'\n", name);
	node-&gt;root = source;
	fs_edge_t *chld;
	for(chld = node-&gt;edges ; chld != NULL ; chld = chld-&gt;next) {
		if(!ustrcmp(chld-&gt;name, name)) {
			DBGPRINTF("fs_node_add(%p, '%s') found '%s'\n", chld-&gt;node, toFind, name);
			instanceConf_t **instarr_new = realloc(chld-&gt;instarr,
							sizeof(instanceConf_t*) * (chld-&gt;ninst+1));
			CHKmalloc(instarr_new);
			chld-&gt;instarr = instarr_new;
			chld-&gt;ninst++;
			chld-&gt;instarr[chld-&gt;ninst-1] = inst;
			if(!isFile) {
				CHKiRet(fs_node_add(chld-&gt;node, node, toFind, nextPathIdx, inst));
			}
			FINALIZE;
		}
	}
	DBGPRINTF("fs_node_add(%p, '%s') did not find '%s' - adding it\n",
		node, toFind, name);
	CHKmalloc(newchld = calloc(sizeof(fs_edge_t), 1));
	CHKmalloc(newchld-&gt;name = ustrdup(name));
	CHKmalloc(newchld-&gt;node = calloc(sizeof(fs_node_t), 1));
	CHKmalloc(newchld-&gt;path = ustrdup(ourPath));
	CHKmalloc(newchld-&gt;instarr = calloc(sizeof(instanceConf_t*), 1));
	newchld-&gt;instarr[0] = inst;
	newchld-&gt;is_file = isFile;
	newchld-&gt;ninst = 1;
	newchld-&gt;parent = node;
	DBGPRINTF("fs_node_add(%p, '%s') returns %p\n", node, toFind, newchld-&gt;node);
	if(!isFile) {
		CHKiRet(fs_node_add(newchld-&gt;node, node, toFind, nextPathIdx, inst));
	}
	newchld-&gt;next = node-&gt;edges;
	node-&gt;edges = newchld;
finalize_it:
	if(iRet != RS_RET_OK) {
		if(newchld != NULL) {
		free(newchld-&gt;name);
		free(newchld-&gt;node);
		free(newchld-&gt;path);
		free(newchld-&gt;instarr);
		free(newchld);
		}
	}
	RETiRet;
}
static int ATTR_NONNULL()
getFullStateFileName(const uchar *const pszstatefile,
	const char *const file_id,
	uchar *const pszout,
	const size_t ilenout)
{
	int lenout;
	const uchar* pszstatedir;
	pszstatedir = getStateFileDir();
	lenout = snprintf((char*)pszout, ilenout, "%s/%s%s%s",
		(char*) (pszstatedir == NULL ? "." : (char*) pszstatedir), (char*)pszstatefile,
		(*file_id == '\0') ? "" : ":", file_id);
	return lenout;
}
#if defined(__clang__)
#pragma GCC diagnostic ignored "-Wunknown-attributes"
#endif
static void __attribute__((nonnull(1,3)))
#if defined(__clang__)
__attribute__((no_sanitize("unsigned-integer-overflow")))
#endif
get_file_id_hash(const char *data, size_t lendata,
	char *const hash_str, const size_t len_hash_str)
{
	assert(len_hash_str &gt;= 17); 
	size_t i;
	uint8_t out[8], k[16];
	for (i = 0; i &lt; 16; ++i)
		k[i] = i;
	memset(out, 0, sizeof(out));
	rs_siphash((const uint8_t *)data, lendata, k, out, 8);
	for(i = 0 ; i &lt; 8 ; ++i) {
		if(2 * i+1 &gt;= len_hash_str)
			break;
		snprintf(hash_str+(2*i), 3, "%2.2x", out[i]);
	}
}
static void ATTR_NONNULL(1)
getFileID(act_obj_t *const act)
{
	char tmp_id[FILE_ID_HASH_SIZE];
	strncpy(tmp_id, (const char*)act-&gt;file_id, FILE_ID_HASH_SIZE);
	act-&gt;file_id[0] = '\0';
	assert(act-&gt;fd &gt;= 0); 	char filedata[FILE_ID_SIZE];
	lseek(act-&gt;fd, 0, SEEK_SET); 	const int r = read(act-&gt;fd, filedata, FILE_ID_SIZE);
	if(r == FILE_ID_SIZE) {
		get_file_id_hash(filedata, sizeof(filedata), act-&gt;file_id, sizeof(act-&gt;file_id));
	} else {
		DBGPRINTF("getFileID partial or error read, ret %d\n", r);
	}
	if (strncmp(tmp_id, act-&gt;file_id, FILE_ID_HASH_SIZE)) {		strncpy(act-&gt;file_id_prev, tmp_id, FILE_ID_HASH_SIZE);
	}
	DBGPRINTF("getFileID for '%s', file_id_hash '%s'\n", act-&gt;name, act-&gt;file_id);
}
static uchar * ATTR_NONNULL(1, 2)
getStateFileName(const act_obj_t *const act,
	 	 uchar *const __restrict__ buf,
		 const size_t lenbuf)
{
	DBGPRINTF("getStateFileName for '%s'\n", act-&gt;name);
	snprintf((char*)buf, lenbuf - 1, "imfile-state:%lld", (long long) act-&gt;ino);
	DBGPRINTF("getStateFileName:  state file name now is %s\n", buf);
	return buf;
}
static rsRetVal
checkPerMinuteRateLimits(per_minute_rate_limit_t *per_minute_rate_limits,
			     const size_t msgLen)
{
	DEFiRet;
	time_t current_minute = time(NULL)/60;
	if(per_minute_rate_limits-&gt;maxBytesPerMinute) {
		if (per_minute_rate_limits-&gt;rateLimitingMinute == current_minute) {
			per_minute_rate_limits-&gt;bytesThisMinute += msgLen;
			if (per_minute_rate_limits-&gt;bytesThisMinute &gt; per_minute_rate_limits-&gt;maxBytesPerMinute) {
				ABORT_FINALIZE(RS_RET_RATE_LIMITED);
			}
		} else {
			per_minute_rate_limits-&gt;rateLimitingMinute = current_minute;
			per_minute_rate_limits-&gt;bytesThisMinute = msgLen; 		}
	}
	if(per_minute_rate_limits-&gt;maxLinesPerMinute) {
		if (per_minute_rate_limits-&gt;rateLimitingMinute == current_minute) {
			per_minute_rate_limits-&gt;linesThisMinute++;
			if (per_minute_rate_limits-&gt;linesThisMinute &gt; per_minute_rate_limits-&gt;maxLinesPerMinute) {
				ABORT_FINALIZE(RS_RET_RATE_LIMITED);
			}
		} else {
			per_minute_rate_limits-&gt;rateLimitingMinute = current_minute;
			per_minute_rate_limits-&gt;linesThisMinute = 1; 		}
	}
finalize_it:
	RETiRet;
}
#define MAX_OFFSET_REPRESENTATION_NUM_BYTES 20
static rsRetVal ATTR_NONNULL(1,2)
enqLine(act_obj_t *const act,
	cstr_t *const __restrict__ cstrLine,
	const int64 strtOffs)
{
	DEFiRet;
	const instanceConf_t *const inst = act-&gt;edge-&gt;instarr[0];	smsg_t *pMsg;
	uchar file_offset[MAX_OFFSET_REPRESENTATION_NUM_BYTES+1];
	const uchar *metadata_names[2] = {(uchar *)"filename",(uchar *)"fileoffset"} ;
	const uchar *metadata_values[2] ;
	const size_t msgLen = cstrLen(cstrLine);
	if(msgLen == 0) {
		FINALIZE;
	}
	CHKiRet(msgConstruct(&amp;pMsg));
	MsgSetFlowControlType(pMsg, eFLOWCTL_FULL_DELAY);
	MsgSetInputName(pMsg, pInputName);
	if(inst-&gt;addCeeTag) {
		size_t ceeMsgSize = msgLen + CONST_LEN_CEE_COOKIE + 1;
		char *ceeMsg;
		CHKmalloc(ceeMsg = malloc(ceeMsgSize));
		strcpy(ceeMsg, CONST_CEE_COOKIE);
		strcat(ceeMsg, (char*)rsCStrGetSzStrNoNULL(cstrLine));
		MsgSetRawMsg(pMsg, ceeMsg, ceeMsgSize);
		free(ceeMsg);
	} else {
		MsgSetRawMsg(pMsg, (char*)rsCStrGetSzStrNoNULL(cstrLine), msgLen);
	}
	MsgSetMSGoffs(pMsg, 0);		MsgSetHOSTNAME(pMsg, glbl.GetLocalHostName(), ustrlen(glbl.GetLocalHostName()));
	MsgSetTAG(pMsg, inst-&gt;pszTag, inst-&gt;lenTag);
	msgSetPRI(pMsg, inst-&gt;iFacility | inst-&gt;iSeverity);
	MsgSetRuleset(pMsg, inst-&gt;pBindRuleset);
	if(inst-&gt;addMetadata) {
		if (act-&gt;source_name) {
			metadata_values[0] = (const uchar*)act-&gt;source_name;
		} else {
			metadata_values[0] = (const uchar*)act-&gt;name;
		}
		snprintf((char *)file_offset, MAX_OFFSET_REPRESENTATION_NUM_BYTES+1, "%lld", strtOffs);
		metadata_values[1] = file_offset;
		msgAddMultiMetadata(pMsg, metadata_names, metadata_values, 2);
	}
	if(inst-&gt;perMinuteRateLimits.maxBytesPerMinute || inst-&gt;perMinuteRateLimits.maxLinesPerMinute) {
		CHKiRet(checkPerMinuteRateLimits((per_minute_rate_limit_t *)&amp;inst-&gt;perMinuteRateLimits, msgLen));
	}
	if(inst-&gt;delay_perMsg) {
		srSleep(inst-&gt;delay_perMsg % 1000000, inst-&gt;delay_perMsg / 1000000);
	}
	pMsg-&gt;msgFlags = pMsg-&gt;msgFlags | inst-&gt;msgFlag;
	ratelimitAddMsg(act-&gt;ratelimiter, &amp;act-&gt;multiSub, pMsg);
finalize_it:
	RETiRet;
}
static rsRetVal ATTR_NONNULL(1)
openFileWithStateFile(act_obj_t *const act)
{
	DEFiRet;
	uchar pszSFNam[MAXFNAME];
	uchar statefile[MAXFNAME];
	int fd = -1;
	const instanceConf_t *const inst = act-&gt;edge-&gt;instarr[0];
	uchar *const statefn = getStateFileName(act, statefile, sizeof(statefile));
	getFileID(act);
	getFullStateFileName(statefn, act-&gt;file_id, pszSFNam, sizeof(pszSFNam));
	DBGPRINTF("trying to open state for '%s', state file '%s'\n", act-&gt;name, pszSFNam);
	fd = open((char*)pszSFNam, O_CLOEXEC | O_NOCTTY | O_RDONLY, 0600);
	if(fd &lt; 0) {
		if(errno == ENOENT) {
			if(act-&gt;file_id[0] != '\0') {
				DBGPRINTF("state file %s for %s does not exist - trying to see if "
					"inode-only file exists\n", pszSFNam, act-&gt;name);
				getFullStateFileName(statefn, "", pszSFNam, sizeof(pszSFNam));
				fd = open((char*)pszSFNam, O_CLOEXEC | O_NOCTTY | O_RDONLY, 0600);
				if(fd &gt;= 0) {
					dbgprintf("found inode-only state file, will be renamed at next persist\n");
				}
			}
			if(fd &lt; 0) {
				DBGPRINTF("state file %s for %s does not exist - trying to see if "
					"old-style file exists\n", pszSFNam, act-&gt;name);
				CHKiRet(OLD_openFileWithStateFile(act));
				FINALIZE;
			}
		} else {
			LogError(errno, RS_RET_IO_ERROR,
				"imfile error trying to access state file for '%s'",
			        act-&gt;name);
			ABORT_FINALIZE(RS_RET_IO_ERROR);
		}
	}
	DBGPRINTF("opened state file %s for %s\n", pszSFNam, act-&gt;name);
	CHKiRet(strm.Construct(&amp;act-&gt;pStrm));
	struct json_object *jval;
	struct json_object *json = fjson_object_from_fd(fd);
	if(json == NULL) {
		LogError(0, RS_RET_ERR, "imfile: error reading state file for '%s'", act-&gt;name);
	}
	fjson_object_object_get_ex(json, "prev_was_nl", &amp;jval);
	act-&gt;pStrm-&gt;bPrevWasNL = fjson_object_get_int(jval);
	fjson_object_object_get_ex(json, "curr_offs", &amp;jval);
	act-&gt;pStrm-&gt;iCurrOffs = fjson_object_get_int64(jval);
	fjson_object_object_get_ex(json, "strt_offs", &amp;jval);
	act-&gt;pStrm-&gt;strtOffs = fjson_object_get_int64(jval);
	fjson_object_object_get_ex(json, "prev_line_segment", &amp;jval);
	const uchar *const prev_line_segment = (const uchar*)fjson_object_get_string(jval);
	if(jval != NULL) {
		CHKiRet(rsCStrConstructFromszStr(&amp;act-&gt;pStrm-&gt;prevLineSegment, prev_line_segment));
		cstrFinalize(act-&gt;pStrm-&gt;prevLineSegment);
		uchar *ret = rsCStrGetSzStrNoNULL(act-&gt;pStrm-&gt;prevLineSegment);
		DBGPRINTF("prev_line_segment present in state file 2, is: %s\n", ret);
	}
	fjson_object_object_get_ex(json, "prev_msg_segment", &amp;jval);
	const uchar *const prev_msg_segment = (const uchar*)fjson_object_get_string(jval);
	if(jval != NULL) {
		CHKiRet(rsCStrConstructFromszStr(&amp;act-&gt;pStrm-&gt;prevMsgSegment, prev_msg_segment));
		cstrFinalize(act-&gt;pStrm-&gt;prevMsgSegment);
		uchar *ret = rsCStrGetSzStrNoNULL(act-&gt;pStrm-&gt;prevMsgSegment);
		DBGPRINTF("prev_msg_segment present in state file 2, is: %s\n", ret);
	}
	fjson_object_put(json);
	CHKiRet(strm.SetFName(act-&gt;pStrm, (uchar*)act-&gt;name, strlen(act-&gt;name)));
	CHKiRet(strm.SettOperationsMode(act-&gt;pStrm, STREAMMODE_READ));
	CHKiRet(strm.SetsType(act-&gt;pStrm, STREAMTYPE_FILE_MONITOR));
	CHKiRet(strm.SetFileNotFoundError(act-&gt;pStrm, inst-&gt;fileNotFoundError));
	CHKiRet(strm.ConstructFinalize(act-&gt;pStrm));
	CHKiRet(strm.SeekCurrOffs(act-&gt;pStrm));
finalize_it:
	if(fd &gt;= 0) {
		close(fd);
	}
	RETiRet;
}
static rsRetVal
openFileWithoutStateFile(act_obj_t *const act)
{
	DEFiRet;
	const instanceConf_t *const inst = act-&gt;edge-&gt;instarr[0];
	DBGPRINTF("clean startup withOUT state file for '%s'\n", act-&gt;name);
	if(act-&gt;pStrm != NULL)
		strm.Destruct(&amp;act-&gt;pStrm);
	CHKiRet(strm.Construct(&amp;act-&gt;pStrm));
	CHKiRet(strm.SettOperationsMode(act-&gt;pStrm, STREAMMODE_READ));
	CHKiRet(strm.SetsType(act-&gt;pStrm, STREAMTYPE_FILE_MONITOR));
	CHKiRet(strm.SetFName(act-&gt;pStrm, (uchar*)act-&gt;name, strlen(act-&gt;name)));
	CHKiRet(strm.SetFileNotFoundError(act-&gt;pStrm, inst-&gt;fileNotFoundError));
	CHKiRet(strm.ConstructFinalize(act-&gt;pStrm));
	if(inst-&gt;freshStartTail) {
		const int fd = open(act-&gt;name, O_RDONLY | O_CLOEXEC);
		if(fd &gt;= 0) {
			act-&gt;pStrm-&gt;iCurrOffs = lseek64(fd, 0, SEEK_END);
			close(fd);
			if(act-&gt;pStrm-&gt;iCurrOffs &lt; 0) {
				act-&gt;pStrm-&gt;iCurrOffs = 0;
				LogError(errno, RS_RET_ERR, "imfile: could not query current "
					"file size for %s - 'freshStartTail' option will "
					"be ignored, starting at begin of file", inst-&gt;pszFileName);
			}
			CHKiRet(strm.SeekCurrOffs(act-&gt;pStrm));
		}
	}
finalize_it:
	RETiRet;
}
static rsRetVal
openFile(act_obj_t *const act)
{
	DEFiRet;
	const instanceConf_t *const inst = act-&gt;edge-&gt;instarr[0];
	CHKiRet_Hdlr(openFileWithStateFile(act)) {
		CHKiRet(openFileWithoutStateFile(act));
	}
	DBGPRINTF("breopenOnTruncate %d for '%s'\n", inst-&gt;reopenOnTruncate, act-&gt;name);
	CHKiRet(strm.SetbReopenOnTruncate(act-&gt;pStrm, inst-&gt;reopenOnTruncate));
	strmSetReadTimeout(act-&gt;pStrm, inst-&gt;readTimeout);
finalize_it:
	RETiRet;
}
static void pollFileCancelCleanup(void *pArg)
{
	cstr_t **ppCStr = (cstr_t**) pArg;
	if(*ppCStr != NULL)
		rsCStrDestruct(ppCStr);
}
static rsRetVal ATTR_NONNULL()
pollFileReal(act_obj_t *act, cstr_t **pCStr)
{
	int64 strtOffs;
	DEFiRet;
	int64_t startOffs = 0;
	int nProcessed = 0;
	regex_t *start_preg = NULL, *end_preg = NULL;
	DBGPRINTF("pollFileReal enter, act %p, pStrm %p, name '%s'\n", act, act-&gt;pStrm, act-&gt;name);
	DBGPRINTF("pollFileReal enter, edge %p\n", act-&gt;edge);
	DBGPRINTF("pollFileReal enter, edge-&gt;instarr %p\n", act-&gt;edge-&gt;instarr);
	instanceConf_t *const inst = act-&gt;edge-&gt;instarr[0];
	if(act-&gt;pStrm == NULL) {
		CHKiRet(openFile(act)); 	}
	start_preg = (inst-&gt;startRegex == NULL) ? NULL : &amp;inst-&gt;start_preg;
	end_preg = (inst-&gt;endRegex == NULL) ? NULL : &amp;inst-&gt;end_preg;
	startOffs = act-&gt;pStrm-&gt;iCurrOffs;
	while(glbl.GetGlobalInputTermState() == 0) {
		if(inst-&gt;maxLinesAtOnce != 0 &amp;&amp; nProcessed &gt;= inst-&gt;maxLinesAtOnce)
			break;
		if((start_preg == NULL) &amp;&amp; (end_preg == NULL)) {
			CHKiRet(strm.ReadLine(act-&gt;pStrm, pCStr, inst-&gt;readMode, inst-&gt;escapeLF, inst-&gt;escapeLFString,
				inst-&gt;trimLineOverBytes, &amp;strtOffs));
		} else {
			CHKiRet(strmReadMultiLine(act-&gt;pStrm, pCStr, start_preg, end_preg,
				inst-&gt;escapeLF, inst-&gt;escapeLFString, inst-&gt;discardTruncatedMsg,
				inst-&gt;msgDiscardingError, &amp;strtOffs));
		}
		++nProcessed;
		if(startOffs &lt; FILE_ID_SIZE &amp;&amp; act-&gt;pStrm-&gt;iCurrOffs &gt;= FILE_ID_SIZE) {
			dbgprintf("initiating state file write as sufficient data is now present; file=%s\n",
				act-&gt;name);
			persistStrmState(act);
			startOffs = act-&gt;pStrm-&gt;iCurrOffs; 		}
		runModConf-&gt;bHadFileData = 1; 		CHKiRet(enqLine(act, *pCStr, strtOffs)); 		rsCStrDestruct(pCStr); 		if(inst-&gt;iPersistStateInterval &gt; 0 &amp;&amp; ++act-&gt;nRecords &gt;= inst-&gt;iPersistStateInterval) {
			persistStrmState(act);
			act-&gt;nRecords = 0;
		}
	}
finalize_it:
	multiSubmitFlush(&amp;act-&gt;multiSub);
	if(inst-&gt;bPersistStateAfterSubmission) {
		persistStrmState(act);
	}
	if(*pCStr != NULL) {
		rsCStrDestruct(pCStr);
	}
	RETiRet;
}
static rsRetVal ATTR_NONNULL(1)
pollFile(act_obj_t *const act)
{
	cstr_t *pCStr = NULL;
	DEFiRet;
	if (act-&gt;is_symlink) {
		FINALIZE;    	}
	pthread_cleanup_push(pollFileCancelCleanup, &amp;pCStr);
	iRet = pollFileReal(act, &amp;pCStr);
	pthread_cleanup_pop(0);
finalize_it: RETiRet;
}
static rsRetVal ATTR_NONNULL(1)
createInstance(instanceConf_t **const pinst)
{
	instanceConf_t *inst;
	DEFiRet;
	CHKmalloc(inst = malloc(sizeof(instanceConf_t)));
	inst-&gt;next = NULL;
	inst-&gt;pBindRuleset = NULL;
	inst-&gt;pszBindRuleset = NULL;
	inst-&gt;pszFileName = NULL;
	inst-&gt;pszTag = NULL;
	inst-&gt;pszStateFile = NULL;
	inst-&gt;nMultiSub = NUM_MULTISUB;
	inst-&gt;iSeverity = 5;
	inst-&gt;iFacility = 128;
	inst-&gt;maxLinesAtOnce = 0;
	inst-&gt;trimLineOverBytes = 0;
	inst-&gt;iPersistStateInterval = 0;
	inst-&gt;perMinuteRateLimits.maxBytesPerMinute = 0;
	inst-&gt;perMinuteRateLimits.maxLinesPerMinute = 0;
	inst-&gt;perMinuteRateLimits.rateLimitingMinute = 0;
	inst-&gt;perMinuteRateLimits.linesThisMinute = 0;
	inst-&gt;perMinuteRateLimits.bytesThisMinute = 0;
	inst-&gt;bPersistStateAfterSubmission = 0;
	inst-&gt;readMode = 0;
	inst-&gt;startRegex = NULL;
	inst-&gt;endRegex = NULL;
	inst-&gt;discardTruncatedMsg = 0;
	inst-&gt;msgDiscardingError = 1;
	inst-&gt;bRMStateOnDel = 1;
	inst-&gt;escapeLF = 1;
	inst-&gt;escapeLFString = NULL;
	inst-&gt;reopenOnTruncate = 0;
	inst-&gt;addMetadata = ADD_METADATA_UNSPECIFIED;
	inst-&gt;addCeeTag = 0;
	inst-&gt;freshStartTail = 0;
	inst-&gt;fileNotFoundError = 1;
	inst-&gt;readTimeout = loadModConf-&gt;readTimeout;
	inst-&gt;delay_perMsg = 0;
	inst-&gt;msgFlag = 0;
<a name="4"></a>	inst-&gt;ignoreOlderThan = 0;
<font color="#6cc417"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>	if(loadModConf-&gt;tail == NULL) {
		loadModConf-&gt;tail = loadModConf-&gt;root = inst;
	} else {
		loadModConf-&gt;tail-&gt;next = inst;
		loadModConf-&gt;tail = inst;
	}
	*pinst = inst;
finalize_it:
	RETiRet;
}
static int ATTR_NONNULL()</b></font>
getBasename(uchar *const __restrict__ basen, uchar *const __restrict__ path)
{
	int i;
	int found = 0;
	const int lenName = ustrlen(path);
	for(i = lenName ; i &gt;= 0 ; --i) {
		if(path[i] == '/') {
			found = 1;
			if(i == lenName)
				basen[0] = '\0';
			else {
				memcpy(basen, path+i+1, lenName-i);
			}
			break;
		}
	}
	if (found == 1)
		return i;
	else {
		return -1;
	}
}
static rsRetVal ATTR_NONNULL()
checkInstance(instanceConf_t *const inst)
{
	uchar curr_wd[MAXFNAME];
	DEFiRet;
	if(inst-&gt;pszFileName == NULL)
		ABORT_FINALIZE(RS_RET_INTERNAL_ERROR);
	CHKmalloc(inst-&gt;pszFileName_forOldStateFile = ustrdup(inst-&gt;pszFileName));
	if(loadModConf-&gt;normalizePath) {
		if(inst-&gt;pszFileName[0] == '.' &amp;&amp; inst-&gt;pszFileName[1] == '/') {
			DBGPRINTF("imfile: removing heading './' from name '%s'\n", inst-&gt;pszFileName);
			memmove(inst-&gt;pszFileName, inst-&gt;pszFileName+2, ustrlen(inst-&gt;pszFileName) - 1);
		}
		if(inst-&gt;pszFileName[0] != '/') {
			if(getcwd((char*)curr_wd, MAXFNAME) == NULL || curr_wd[0] != '/') {
				LogError(errno, RS_RET_ERR, "imfile: error querying current working "
					"directory - can not continue with %s", inst-&gt;pszFileName);
				ABORT_FINALIZE(RS_RET_ERR);
			}
			const size_t len_curr_wd = ustrlen(curr_wd);
			if(len_curr_wd + ustrlen(inst-&gt;pszFileName) + 1 &gt;= MAXFNAME) {
				LogError(0, RS_RET_ERR, "imfile: length of configured file and current "
					"working directory exceeds permitted size - ignoring %s",
					inst-&gt;pszFileName);
				ABORT_FINALIZE(RS_RET_ERR);
			}
			curr_wd[len_curr_wd] = '/';
			strcpy((char*)curr_wd+len_curr_wd+1, (char*)inst-&gt;pszFileName);
			free(inst-&gt;pszFileName);
			CHKmalloc(inst-&gt;pszFileName = ustrdup(curr_wd));
		}
	}
	dbgprintf("imfile: adding file monitor for '%s'\n", inst-&gt;pszFileName);
	if(inst-&gt;pszTag != NULL) {
		inst-&gt;lenTag = ustrlen(inst-&gt;pszTag);
	}
finalize_it:
	RETiRet;
}
static rsRetVal
addInstance(void __attribute__((unused)) *pVal, uchar *pNewVal)
{
	instanceConf_t *inst;
	DEFiRet;
	if(cs.pszFileName == NULL) {
		LogError(0, RS_RET_CONFIG_ERROR, "imfile error: no file name given, file monitor can "
					"not be created");
		ABORT_FINALIZE(RS_RET_CONFIG_ERROR);
	}
	if(cs.pszFileTag == NULL) {
		LogError(0, RS_RET_CONFIG_ERROR, "imfile error: no tag value given, file monitor can "
					"not be created");
		ABORT_FINALIZE(RS_RET_CONFIG_ERROR);
	}
	CHKiRet(createInstance(&amp;inst));
	if((cs.pszBindRuleset == NULL) || (cs.pszBindRuleset[0] == '\0')) {
		inst-&gt;pszBindRuleset = NULL;
	} else {
		CHKmalloc(inst-&gt;pszBindRuleset = ustrdup(cs.pszBindRuleset));
	}
	CHKmalloc(inst-&gt;pszFileName = ustrdup((char*) cs.pszFileName));
	CHKmalloc(inst-&gt;pszTag = ustrdup((char*) cs.pszFileTag));
	if(cs.pszStateFile == NULL) {
		inst-&gt;pszStateFile = NULL;
	} else {
		CHKmalloc(inst-&gt;pszStateFile = ustrdup(cs.pszStateFile));
	}
	inst-&gt;iSeverity = cs.iSeverity;
	inst-&gt;iFacility = cs.iFacility;
	if(cs.maxLinesAtOnce) {
		if(loadModConf-&gt;opMode == OPMODE_INOTIFY) {
			LogError(0, RS_RET_PARAM_NOT_PERMITTED,
				"parameter \"maxLinesAtOnce\" not "
				"permited in inotify mode - ignored");
		} else {
			inst-&gt;maxLinesAtOnce = cs.maxLinesAtOnce;
		}
	}
	inst-&gt;trimLineOverBytes = cs.trimLineOverBytes;
	inst-&gt;ignoreOlderThan = 0;
	inst-&gt;iPersistStateInterval = cs.iPersistStateInterval;
	inst-&gt;perMinuteRateLimits.maxBytesPerMinute = cs.maxBytesPerMinute;
	inst-&gt;perMinuteRateLimits.maxLinesPerMinute = cs.maxLinesPerMinute;
	inst-&gt;bPersistStateAfterSubmission = 0;
	inst-&gt;readMode = cs.readMode;
	inst-&gt;escapeLF = 0;
	inst-&gt;escapeLFString = NULL;
	inst-&gt;reopenOnTruncate = 0;
	inst-&gt;addMetadata = 0;
	inst-&gt;addCeeTag = 0;
	inst-&gt;bRMStateOnDel = 0;
	inst-&gt;readTimeout = loadModConf-&gt;readTimeout;
	inst-&gt;msgFlag = 0;
	CHKiRet(checkInstance(inst));
	cs.iPersistStateInterval = 0;
	resetConfigVariables(NULL, NULL); 
finalize_it:
	free(pNewVal); 	RETiRet;
}
BEGINnewInpInst
	struct cnfparamvals *pvals;
	instanceConf_t *inst;
	int i;
CODESTARTnewInpInst
<a name="1"></a>	DBGPRINTF("newInpInst (imfile)\n");
	pvals = nvlstGetParams(lst, &amp;inppblk, NULL);
<font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>	if(pvals == NULL) {
		ABORT_FINALIZE(RS_RET_MISSING_CNFPARAMS);
	}
	if(Debug) {
		DBGPRINTF("input param blk in imfile:\n");
		cnfparamsPrint(&amp;inppblk, pvals);
	}
	CHKiRet(createInstance(&amp;inst));
	for(i = 0 ; i &lt; inppblk.nParams ; ++i) {
		if(!pvals[i].bUsed)
			continue;
		if(!strcmp(inppblk.descr[i].name, "file")) {
			inst-&gt;pszFileName = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
		} else if(!strcmp(inppblk.descr[i].name, "statefile")) {
			inst-&gt;pszStateFile = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
		} else if(!strcmp(inppblk.descr[i].name, "removestateondelete")) {
<a name="2"></a>			inst-&gt;bRMStateOnDel = (uint8_t) pvals[i].val.d.n; 		} else if(!strcmp(inppblk.descr[i].name, "tag")) {
			inst-&gt;pszTag = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
<font color="#980517"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>		} else if(!strcmp(inppblk.descr[i].name, "ruleset")) {
			inst-&gt;pszBindRuleset = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
		} else if(!strcmp(inppblk.descr[i].name, "severity")) {
			inst-&gt;iSeverity = pvals[i].val.d.n;
		} else if(!strcmp(inppblk.descr[i].name, "facility")) {
<a name="5"></a>			inst-&gt;iFacility = pvals[i].val.d.n;</b></font>
		} else if(!strcmp(inppblk.descr[i].name, "readmode")) {
			inst-&gt;readMode = (sbool) pvals[i].val.d.n;
<font color="#151b8d"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>		} else if(!strcmp(inppblk.descr[i].name, "startmsg.regex")) {
			inst-&gt;startRegex = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
		} else if(!strcmp(inppblk.descr[i].name, "endmsg.regex")) {
			inst-&gt;endRegex = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
		} else if(!strcmp(inppblk.descr[i].name, "discardtruncatedmsg")) {</b></font>
			inst-&gt;discardTruncatedMsg = (sbool) pvals[i].val.d.n;
		} else if(!strcmp(inppblk.descr[i].name, "msgdiscardingerror")) {
			inst-&gt;msgDiscardingError = (sbool) pvals[i].val.d.n;
		} else if(!strcmp(inppblk.descr[i].name, "deletestateonfiledelete")) {
			inst-&gt;bRMStateOnDel = (sbool) pvals[i].val.d.n; 		} else if(!strcmp(inppblk.descr[i].name, "addmetadata")) {
			inst-&gt;addMetadata = (sbool) pvals[i].val.d.n;
		} else if(!strcmp(inppblk.descr[i].name, "delay.message")) {
			inst-&gt;delay_perMsg = (unsigned) pvals[i].val.d.n;
		} else if (!strcmp(inppblk.descr[i].name, "addceetag")) {
			inst-&gt;addCeeTag = (sbool) pvals[i].val.d.n;
		} else if(!strcmp(inppblk.descr[i].name, "freshstarttail")) {
			inst-&gt;freshStartTail = (sbool) pvals[i].val.d.n;
		} else if(!strcmp(inppblk.descr[i].name, "filenotfounderror")) {
			inst-&gt;fileNotFoundError = (sbool) pvals[i].val.d.n;
		} else if(!strcmp(inppblk.descr[i].name, "escapelf")) {
			inst-&gt;escapeLF = (sbool) pvals[i].val.d.n;
		} else if(!strcmp(inppblk.descr[i].name, "escapelf.replacement")) {
			inst-&gt;escapeLFString = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
		} else if(!strcmp(inppblk.descr[i].name, "reopenontruncate")) {
			inst-&gt;reopenOnTruncate = (sbool) pvals[i].val.d.n;
		} else if(!strcmp(inppblk.descr[i].name, "maxlinesatonce")) {
			if(   loadModConf-&gt;opMode == OPMODE_INOTIFY
			   &amp;&amp; pvals[i].val.d.n &gt; 0) {
				LogError(0, RS_RET_PARAM_NOT_PERMITTED,
					"parameter \"maxLinesAtOnce\" not "
					"permited in inotify mode - ignored");
			} else {
				inst-&gt;maxLinesAtOnce = pvals[i].val.d.n;
			}
		} else if(!strcmp(inppblk.descr[i].name, "trimlineoverbytes")) {
			inst-&gt;trimLineOverBytes = pvals[i].val.d.n;
		} else if(!strcmp(inppblk.descr[i].name, "ignoreolderthan")) {
			inst-&gt;ignoreOlderThan = pvals[i].val.d.n;
		} else if(!strcmp(inppblk.descr[i].name, "persiststateinterval")) {
			inst-&gt;iPersistStateInterval = pvals[i].val.d.n;
		} else if(!strcmp(inppblk.descr[i].name, "maxbytesperminute")) {
			DBGPRINTF("imfile: enabling maxbytesperminute ratelimiting\n");
			inst-&gt;perMinuteRateLimits.maxBytesPerMinute = pvals[i].val.d.n;
		} else if(!strcmp(inppblk.descr[i].name, "maxlinesperminute")) {
			DBGPRINTF("imfile: enabling maxlinesperminute ratelimiting\n");
			inst-&gt;perMinuteRateLimits.maxLinesPerMinute = pvals[i].val.d.n;
		} else if(!strcmp(inppblk.descr[i].name, "persiststateaftersubmission")) {
			inst-&gt;bPersistStateAfterSubmission = pvals[i].val.d.n;
		} else if(!strcmp(inppblk.descr[i].name, "maxsubmitatonce")) {
			inst-&gt;nMultiSub = pvals[i].val.d.n;
		} else if(!strcmp(inppblk.descr[i].name, "readtimeout")) {
			inst-&gt;readTimeout = pvals[i].val.d.n;
		} else if(!strcmp(inppblk.descr[i].name, "needparse")) {
			inst-&gt;msgFlag = pvals[i].val.d.n ? NEEDS_PARSING : 0;
		} else {
			DBGPRINTF("program error, non-handled "
			  "param '%s'\n", inppblk.descr[i].name);
		}
	}
	i = (inst-&gt;readMode &gt; 0) ? 1 : 0;
	i = (NULL != inst-&gt;startRegex) ? (i+1) : i;
	i = (NULL != inst-&gt;endRegex) ? (i+1) : i;
	if(i &gt; 1) {
		LogError(0, RS_RET_PARAM_NOT_PERMITTED,
			"only one of readMode or startmsg.regex or endmsg.regex can be set "
			"at the same time");
			ABORT_FINALIZE(RS_RET_PARAM_NOT_PERMITTED);
	}
	if(inst-&gt;startRegex != NULL) {
		const int errcode = regcomp(&amp;inst-&gt;start_preg, (char*)inst-&gt;startRegex, REG_EXTENDED);
		if(errcode != 0) {
			char errbuff[512];
			regerror(errcode, &amp;inst-&gt;start_preg, errbuff, sizeof(errbuff));
			parser_errmsg("imfile: error in startmsg.regex expansion: %s", errbuff);
			ABORT_FINALIZE(RS_RET_ERR);
		}
	}
	if(inst-&gt;endRegex != NULL) {
		const int errcode = regcomp(&amp;inst-&gt;end_preg, (char*)inst-&gt;endRegex, REG_EXTENDED);
		if(errcode != 0) {
			char errbuff[512];
			regerror(errcode, &amp;inst-&gt;end_preg, errbuff, sizeof(errbuff));
			parser_errmsg("imfile: error in endmsg.regex expansion: %s", errbuff);
			ABORT_FINALIZE(RS_RET_ERR);
		}
	}
	if(inst-&gt;readTimeout != 0)
		loadModConf-&gt;haveReadTimeouts = 1;
	iRet = checkInstance(inst);
finalize_it:
CODE_STD_FINALIZERnewInpInst
	cnfparamvalsDestruct(pvals, &amp;inppblk);
ENDnewInpInst
BEGINbeginCnfLoad
CODESTARTbeginCnfLoad
	loadModConf = pModConf;
	currModConf = pModConf;
	pModConf-&gt;pConf = pConf;
	loadModConf-&gt;opMode = OPMODE_POLLING;
	loadModConf-&gt;iPollInterval = DFLT_PollInterval;
	loadModConf-&gt;configSetViaV2Method = 0;
	loadModConf-&gt;readTimeout = 0; 	loadModConf-&gt;timeoutGranularity = 1000; 	loadModConf-&gt;haveReadTimeouts = 0; 	loadModConf-&gt;normalizePath = 1;
	loadModConf-&gt;sortFiles = GLOB_NOSORT;
	loadModConf-&gt;stateFileDirectory = NULL;
	loadModConf-&gt;conf_tree = calloc(sizeof(fs_node_t), 1);
	loadModConf-&gt;conf_tree-&gt;edges = NULL;
	bLegacyCnfModGlobalsPermitted = 1;
	cs.pszFileName = NULL;
	cs.pszFileTag = NULL;
	cs.pszStateFile = NULL;
	cs.iPollInterval = DFLT_PollInterval;
	cs.iPersistStateInterval = 0;
	cs.iFacility = 128;
	cs.iSeverity = 5;
	cs.readMode = 0;
	cs.maxLinesAtOnce = 10240;
	cs.trimLineOverBytes = 0;
ENDbeginCnfLoad
BEGINsetModCnf
	struct cnfparamvals *pvals = NULL;
	int i;
CODESTARTsetModCnf
	#if defined(HAVE_PORT_SOURCE_FILE)
		loadModConf-&gt;opMode = OPMODE_FEN;
	#elif defined(HAVE_INOTIFY_INIT)
		loadModConf-&gt;opMode = OPMODE_INOTIFY;
<a name="3"></a>	#else
		loadModConf-&gt;opMode = OPMODE_POLLING;
	#endif
<font color="#53858b"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>	pvals = nvlstGetParams(lst, &amp;modpblk, NULL);
	if(pvals == NULL) {
		LogError(0, RS_RET_MISSING_CNFPARAMS, "imfile: error processing module "
				"config parameters [module(...)]");
		ABORT_FINALIZE(RS_RET_MISSING_CNFPARAMS);
	}
	if(Debug) {
		DBGPRINTF("module (global) param blk for imfile:\n");
		cnfparamsPrint(&amp;modpblk, pvals);
	}
	for(i = 0 ; i &lt; modpblk.nParams ; ++i) {
		if(!pvals[i].bUsed)</b></font>
			continue;
		if(!strcmp(modpblk.descr[i].name, "pollinginterval")) {
			loadModConf-&gt;iPollInterval = (int) pvals[i].val.d.n;
		} else if(!strcmp(modpblk.descr[i].name, "readtimeout")) {
			loadModConf-&gt;readTimeout = (int) pvals[i].val.d.n;
		} else if(!strcmp(modpblk.descr[i].name, "timeoutgranularity")) {
			loadModConf-&gt;timeoutGranularity = (int) pvals[i].val.d.n * 1000;
		} else if(!strcmp(modpblk.descr[i].name, "sortfiles")) {
			loadModConf-&gt;sortFiles = ((sbool) pvals[i].val.d.n) ? 0 : GLOB_NOSORT;
		} else if(!strcmp(modpblk.descr[i].name, "statefile.directory")) {
			loadModConf-&gt;stateFileDirectory = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
		} else if(!strcmp(modpblk.descr[i].name, "normalizepath")) {
			loadModConf-&gt;normalizePath = (sbool) pvals[i].val.d.n;
		} else if(!strcmp(modpblk.descr[i].name, "mode")) {
			if(!es_strconstcmp(pvals[i].val.d.estr, "polling"))
				loadModConf-&gt;opMode = OPMODE_POLLING;
			else if(!es_strconstcmp(pvals[i].val.d.estr, "inotify")) {
#if defined(OS_SOLARIS) &amp;&amp; defined (HAVE_PORT_SOURCE_FILE) 				loadModConf-&gt;opMode = OPMODE_FEN;
				DBGPRINTF("inotify mode configured, but only FEN "
					"is available on OS SOLARIS. Switching to FEN "
					"Mode automatically\n");
#else
				#if defined(HAVE_INOTIFY_INIT)
					loadModConf-&gt;opMode = OPMODE_INOTIFY;
				#else
					loadModConf-&gt;opMode = OPMODE_POLLING;
				#endif
#endif
			} else if(!es_strconstcmp(pvals[i].val.d.estr, "fen"))
				loadModConf-&gt;opMode = OPMODE_FEN;
			else {
				char *cstr = es_str2cstr(pvals[i].val.d.estr, NULL);
				LogError(0, RS_RET_PARAM_ERROR, "imfile: unknown "
					"mode '%s'", cstr);
				free(cstr);
			}
		} else {
			DBGPRINTF("program error, non-handled "
			  "param '%s' in beginCnfLoad\n", modpblk.descr[i].name);
		}
	}
	bLegacyCnfModGlobalsPermitted = 0;
	loadModConf-&gt;configSetViaV2Method = 1;
finalize_it:
	if(pvals != NULL)
		cnfparamvalsDestruct(pvals, &amp;modpblk);
ENDsetModCnf
BEGINendCnfLoad
CODESTARTendCnfLoad
	if(!loadModConf-&gt;configSetViaV2Method) {
		loadModConf-&gt;iPollInterval = cs.iPollInterval;
	}
	DBGPRINTF("opmode is %d, polling interval is %d\n",
		  loadModConf-&gt;opMode,
		  loadModConf-&gt;iPollInterval);
	loadModConf = NULL; 	free(cs.pszFileName);
	free(cs.pszFileTag);
	free(cs.pszStateFile);
ENDendCnfLoad
BEGINcheckCnf
	instanceConf_t *inst;
CODESTARTcheckCnf
	if(getStateFileDir() == NULL) {
		LogError(0, RS_RET_NO_WRKDIR_SET,
			"imfile: no working or state file directory set, imfile will create "
			"state files in the current working directory (probably "
			"the root dir). Use global(workDirectory=\"/some/path\") "
			"to set the working directory");
	}
	for(inst = pModConf-&gt;root ; inst != NULL ; inst = inst-&gt;next) {
		std_checkRuleset(pModConf, inst);
	}
	if(pModConf-&gt;root == NULL) {
		LogError(0, RS_RET_NO_LISTNERS,
				"imfile: no files configured to be monitored - "
				"no input will be gathered");
		iRet = RS_RET_NO_LISTNERS;
	}
ENDcheckCnf
BEGINactivateCnf
	instanceConf_t *inst;
CODESTARTactivateCnf
	runModConf = pModConf;
	currModConf = pModConf;
	if(runModConf-&gt;root == NULL) {
		LogError(0, NO_ERRCODE, "imfile: no file monitors configured, "
				"input not activated.\n");
		ABORT_FINALIZE(RS_RET_NO_RUN);
	}
	for(inst = runModConf-&gt;root ; inst != NULL ; inst = inst-&gt;next) {
		if(!containsGlobWildcard((char*)inst-&gt;pszFileName)) {
			if(access((char*)inst-&gt;pszFileName, R_OK) != 0) {
				LogError(errno, RS_RET_ERR,
					"imfile: on startup file '%s' does not exist "
					"but is configured in static file monitor - this "
					"may indicate a misconfiguration. If the file "
					"appears at a later time, it will automatically "
					"be processed. Reason", inst-&gt;pszFileName);
			}
		}
		fs_node_add(runModConf-&gt;conf_tree, NULL, inst-&gt;pszFileName, 0, inst);
	}
	if(Debug) {
		fs_node_print(runModConf-&gt;conf_tree, 0);
	}
finalize_it:
ENDactivateCnf
BEGINfreeCnf
	instanceConf_t *inst, *del;
CODESTARTfreeCnf
	fs_node_destroy(pModConf-&gt;conf_tree);
	for(inst = pModConf-&gt;root ; inst != NULL ; ) {
		free(inst-&gt;pszBindRuleset);
		free(inst-&gt;pszFileName);
		free(inst-&gt;pszTag);
		free(inst-&gt;pszStateFile);
		free(inst-&gt;pszFileName_forOldStateFile);
		if(inst-&gt;startRegex != NULL) {
			regfree(&amp;inst-&gt;start_preg);
			free(inst-&gt;startRegex);
		}
		if(inst-&gt;endRegex != NULL) {
			regfree(&amp;inst-&gt;end_preg);
			free(inst-&gt;endRegex);
		}
		del = inst;
		inst = inst-&gt;next;
		free(del);
	}
ENDfreeCnf
static void
do_initial_poll_run(void)
{
	fs_node_walk(runModConf-&gt;conf_tree, poll_tree);
	for(instanceConf_t *inst = runModConf-&gt;root ; inst != NULL ; inst = inst-&gt;next) {
		inst-&gt;freshStartTail = 0;
	}
}
static rsRetVal
doPolling(void)
{
	DEFiRet;
	do_initial_poll_run();
	while(glbl.GetGlobalInputTermState() == 0) {
		DBGPRINTF("doPolling: new poll run\n");
		do {
			runModConf-&gt;bHadFileData = 0;
			fs_node_walk(runModConf-&gt;conf_tree, poll_tree);
			DBGPRINTF("doPolling: end poll walk, hadData %d\n", runModConf-&gt;bHadFileData);
		} while(runModConf-&gt;bHadFileData); 
		DBGPRINTF("doPolling: poll going to sleep\n");
		if(glbl.GetGlobalInputTermState() == 0)
			srSleep(runModConf-&gt;iPollInterval, 10);
	}
	RETiRet;
}
#if defined(HAVE_INOTIFY_INIT)
static void ATTR_NONNULL(1)
in_dbg_showEv(const struct inotify_event *ev)
{
	if(!Debug)
		return;
	if(ev-&gt;mask &amp; IN_IGNORED) {
		dbgprintf("INOTIFY event: watch was REMOVED\n");
	}
	if(ev-&gt;mask &amp; IN_MODIFY) {
		dbgprintf("INOTIFY event: watch was MODIFID\n");
	}
	if(ev-&gt;mask &amp; IN_ACCESS) {
		dbgprintf("INOTIFY event: watch IN_ACCESS\n");
	}
	if(ev-&gt;mask &amp; IN_ATTRIB) {
		dbgprintf("INOTIFY event: watch IN_ATTRIB\n");
	}
	if(ev-&gt;mask &amp; IN_CLOSE_WRITE) {
		dbgprintf("INOTIFY event: watch IN_CLOSE_WRITE\n");
	}
	if(ev-&gt;mask &amp; IN_CLOSE_NOWRITE) {
		dbgprintf("INOTIFY event: watch IN_CLOSE_NOWRITE\n");
	}
	if(ev-&gt;mask &amp; IN_CREATE) {
		dbgprintf("INOTIFY event: file was CREATED: %s\n", ev-&gt;name);
	}
	if(ev-&gt;mask &amp; IN_DELETE) {
		dbgprintf("INOTIFY event: watch IN_DELETE\n");
	}
	if(ev-&gt;mask &amp; IN_DELETE_SELF) {
		dbgprintf("INOTIFY event: watch IN_DELETE_SELF\n");
	}
	if(ev-&gt;mask &amp; IN_MOVE_SELF) {
		dbgprintf("INOTIFY event: watch IN_MOVE_SELF\n");
	}
	if(ev-&gt;mask &amp; IN_MOVED_FROM) {
		dbgprintf("INOTIFY event: watch IN_MOVED_FROM, cookie %u, name '%s'\n", ev-&gt;cookie, ev-&gt;name);
	}
	if(ev-&gt;mask &amp; IN_MOVED_TO) {
		dbgprintf("INOTIFY event: watch IN_MOVED_TO, cookie %u, name '%s'\n", ev-&gt;cookie, ev-&gt;name);
	}
	if(ev-&gt;mask &amp; IN_OPEN) {
		dbgprintf("INOTIFY event: watch IN_OPEN\n");
	}
	if(ev-&gt;mask &amp; IN_ISDIR) {
		dbgprintf("INOTIFY event: watch IN_ISDIR\n");
	}
}
static void ATTR_NONNULL(1, 2)
in_handleFileEvent(struct inotify_event *ev, const wd_map_t *const etry)
{
	if(ev-&gt;mask &amp; IN_MODIFY) {
		DBGPRINTF("fs_node_notify_file_update: act-&gt;name '%s'\n", etry-&gt;act-&gt;name);
		pollFile(etry-&gt;act);
	} else {
		DBGPRINTF("got non-expected inotify event:\n");
		in_dbg_showEv(ev);
	}
}
static void
flag_in_move(fs_edge_t *const edge, const char *name_moved)
{
	act_obj_t *act;
	for(act = edge-&gt;active ; act != NULL ; act = act-&gt;next) {
		DBGPRINTF("checking active object %s\n", act-&gt;basename);
		if(!strcmp(act-&gt;basename, name_moved)){
			DBGPRINTF("found file\n");
			act-&gt;in_move = 1;
			break;
		} else {
			DBGPRINTF("name check fails, '%s' != '%s'\n", act-&gt;basename, name_moved);
		}
	}
	if (!act &amp;&amp; edge-&gt;next) {
		flag_in_move(edge-&gt;next, name_moved);
	}
}
static void ATTR_NONNULL(1)
in_processEvent(struct inotify_event *ev)
{
	if(ev-&gt;mask &amp; IN_IGNORED) {
		DBGPRINTF("imfile: got IN_IGNORED event\n");
		goto done;
	}
	DBGPRINTF("in_processEvent process Event %x for %s\n", ev-&gt;mask, ev-&gt;name);
	const wd_map_t *const etry =  wdmapLookup(ev-&gt;wd);
	if(etry == NULL) {
		LogMsg(0, RS_RET_INTERNAL_ERROR, LOG_WARNING, "imfile: internal error? "
			"inotify provided watch descriptor %d which we could not find "
			"in our tables - ignored", ev-&gt;wd);
		goto done;
	}
	DBGPRINTF("in_processEvent process Event %x is_file %d, act-&gt;name '%s'\n",
		ev-&gt;mask, etry-&gt;act-&gt;edge-&gt;is_file, etry-&gt;act-&gt;name);
	if((ev-&gt;mask &amp; IN_MOVED_FROM)) {
		flag_in_move(etry-&gt;act-&gt;edge-&gt;node-&gt;edges, ev-&gt;name);
	}
	if(ev-&gt;mask &amp; (IN_MOVED_FROM | IN_MOVED_TO))  {
		fs_node_walk(etry-&gt;act-&gt;edge-&gt;node, poll_tree);
	} else if(etry-&gt;act-&gt;edge-&gt;is_file &amp;&amp; !(etry-&gt;act-&gt;is_symlink)) {
		in_handleFileEvent(ev, etry); 	} else {
		fs_node_walk(etry-&gt;act-&gt;edge-&gt;node, poll_tree);
	}
done:	return;
}
static rsRetVal
do_inotify(void)
{
	char iobuf[8192];
	int rd;
	int currev;
	static int last_timeout = 0;
	struct pollfd pollfd;
	DEFiRet;
	CHKiRet(wdmapInit());
	ino_fd = inotify_init1(IN_NONBLOCK);
	if(ino_fd &lt; 0) {
		LogError(errno, RS_RET_INOTIFY_INIT_FAILED, "imfile: Init inotify "
			"instance failed ");
		return RS_RET_INOTIFY_INIT_FAILED;
	}
	DBGPRINTF("inotify fd %d\n", ino_fd);
	do_initial_poll_run();
	while(glbl.GetGlobalInputTermState() == 0) {
		int r;
		pollfd.fd = ino_fd;
		pollfd.events = POLLIN;
		if (runModConf-&gt;haveReadTimeouts)
			r = poll(&amp;pollfd, 1, runModConf-&gt;timeoutGranularity);
		else
			r = poll(&amp;pollfd, 1, -1);
		if (r  == -1 &amp;&amp; errno == EINTR) {
			DBGPRINTF("do_inotify interrupted while polling on ino_fd\n");
			continue;
		}
		if(r == 0) {
			DBGPRINTF("readTimeouts are configured, checking if some apply\n");
			if (runModConf-&gt;haveReadTimeouts) {
				fs_node_walk(runModConf-&gt;conf_tree, poll_timeouts);
				last_timeout = time(NULL);
			}
			continue;
		} else if (r == -1) {
			LogError(errno, RS_RET_INTERNAL_ERROR,
					"%s:%d: unexpected error during poll timeout wait",
					__FILE__, __LINE__);
			continue;
		} else if(r != 1) {
			LogError(errno, RS_RET_INTERNAL_ERROR,
					"%s:%d: ERROR: poll returned more fds (%d) than given to it (1)",
					__FILE__, __LINE__, r);
			continue;
		}
		else {
			if(runModConf-&gt;haveReadTimeouts) {
				int now = time(NULL);
				if(last_timeout + (runModConf-&gt;timeoutGranularity / 1000) &gt; now) {
					fs_node_walk(runModConf-&gt;conf_tree, poll_timeouts);
					last_timeout = time(NULL);
				}
			}
			rd = read(ino_fd, iobuf, sizeof(iobuf));
			if(rd == -1 &amp;&amp; errno == EINTR) {
				DBGPRINTF("EINTR received during inotify, restarting poll\n");
				continue;
			}
			if (rd == -1 &amp;&amp; errno == EWOULDBLOCK) {
				continue;
			}
			if(rd &lt; 0) {
				LogError(errno, RS_RET_IO_ERROR, "imfile: error during inotify - ignored");
				continue;
			}
			currev = 0;
			while(currev &lt; rd) {
				union {
					char *buf;
					struct inotify_event *ev;
				} savecast;
				savecast.buf = iobuf+currev;
				in_dbg_showEv(savecast.ev);
				in_processEvent(savecast.ev);
				currev += sizeof(struct inotify_event) + savecast.ev-&gt;len;
			}
		}
	}
finalize_it:
	close(ino_fd);
	RETiRet;
}
#else static rsRetVal
do_inotify(void)
{
	LogError(0, RS_RET_NOT_IMPLEMENTED, "imfile: mode set to inotify, but the "
			"platform does not support inotify");
	return RS_RET_NOT_IMPLEMENTED;
}
#endif 
#if defined(OS_SOLARIS) &amp;&amp; defined (HAVE_PORT_SOURCE_FILE) static void
fen_printevent(int event)
{
	if (event &amp; FILE_ACCESS) {
		DBGPRINTF(" FILE_ACCESS");
	}
	if (event &amp; FILE_MODIFIED) {
		DBGPRINTF(" FILE_MODIFIED");
	}
	if (event &amp; FILE_ATTRIB) {
		DBGPRINTF(" FILE_ATTRIB");
	}
	if (event &amp; FILE_DELETE) {
		DBGPRINTF(" FILE_DELETE");
	}
	if (event &amp; FILE_RENAME_TO) {
		DBGPRINTF(" FILE_RENAME_TO");
	}
	if (event &amp; FILE_RENAME_FROM) {
		DBGPRINTF(" FILE_RENAME_FROM");
	}
	if (event &amp; UNMOUNTED) {
		DBGPRINTF(" UNMOUNTED");
	}
	if (event &amp; MOUNTEDOVER) {
		DBGPRINTF(" MOUNTEDOVER");
	}
}
static rsRetVal
do_fen(void)
{
	port_event_t portEvent;
	struct timespec timeout;
	DEFiRet;
	timeout.tv_sec = 300;
	timeout.tv_nsec = 0;
	if((glport = port_create()) == -1) {
		LogError(errno, RS_RET_FEN_INIT_FAILED, "do_fen INIT Port failed ");
		return RS_RET_FEN_INIT_FAILED;
	}
	do_initial_poll_run();
	DBGPRINTF("do_fen ENTER monitoring loop \n");
	while(glbl.GetGlobalInputTermState() == 0) {
		DBGPRINTF("do_fen loop begin... \n");
		while (!port_get(glport, &amp;portEvent, &amp;timeout)) { 			DBGPRINTF("do_fen: received port event with ");
			fen_printevent((int) portEvent.portev_events);
			DBGPRINTF("\n");
			if(portEvent.portev_source != PORT_SOURCE_FILE) {
				LogError(errno, RS_RET_SYS_ERR, "do_fen: Event from unexpected source "
					": %d\n", portEvent.portev_source);
				continue;
			}
			act_obj_t *const act = (act_obj_t*) portEvent.portev_user;
			DBGPRINTF("do_fen event received: deleted %d, is_file %d, name '%s' foname '%s'\n",
				act-&gt;is_deleted, act-&gt;edge-&gt;is_file, act-&gt;name,
				((struct file_obj*)portEvent.portev_object)-&gt;fo_name);
			if(act-&gt;is_deleted) {
				free(act-&gt;name);
				free(act);
				continue;
			}
			act-&gt;bPortAssociated = 0;
			fen_setupWatch(act);
			if(act-&gt;edge-&gt;is_file) {
				pollFile(act);
			} else {
				fs_node_walk(act-&gt;edge-&gt;node, poll_tree);
			}
		}
	}
	close(glport);
	RETiRet;
}
#else static rsRetVal
do_fen(void)
{
	LogError(0, RS_RET_NOT_IMPLEMENTED, "do_fen: mode set to fen, but the "
			"platform does not support fen");
	return RS_RET_NOT_IMPLEMENTED;
}
#endif 
BEGINrunInput
CODESTARTrunInput
	#if defined(OS_SOLARIS) &amp;&amp; defined (HAVE_PORT_SOURCE_FILE) 	if(runModConf-&gt;opMode == OPMODE_INOTIFY) {
		DBGPRINTF("auto-adjusting 'inotify' mode to 'fen' on Solaris\n");
		runModConf-&gt;opMode = OPMODE_FEN;
	}
	#endif
	DBGPRINTF("working in %s mode\n",
		 (runModConf-&gt;opMode == OPMODE_POLLING) ? "polling" :
			((runModConf-&gt;opMode == OPMODE_INOTIFY) ?"inotify" : "fen"));
	if(runModConf-&gt;opMode == OPMODE_POLLING)
		iRet = doPolling();
	else if(runModConf-&gt;opMode == OPMODE_INOTIFY)
		iRet = do_inotify();
	else if(runModConf-&gt;opMode == OPMODE_FEN)
		iRet = do_fen();
	else {
		LogError(0, RS_RET_NOT_IMPLEMENTED, "imfile: unknown mode %d set",
			runModConf-&gt;opMode);
		return RS_RET_NOT_IMPLEMENTED;
	}
	DBGPRINTF("terminating upon request of rsyslog core\n");
ENDrunInput
BEGINwillRun
CODESTARTwillRun
	CHKiRet(prop.Construct(&amp;pInputName));
	CHKiRet(prop.SetString(pInputName, UCHAR_CONSTANT("imfile"), sizeof("imfile") - 1));
	CHKiRet(prop.ConstructFinalize(pInputName));
finalize_it:
ENDwillRun
static rsRetVal ATTR_NONNULL()
atomicWriteStateFile(const char *fn, const char *content)
{
	DEFiRet;
	const int fd = open(fn, O_CLOEXEC | O_NOCTTY | O_WRONLY | O_CREAT | O_TRUNC, 0600);
	if(fd &lt; 0) {
		LogError(errno, RS_RET_IO_ERROR, "imfile: cannot open state file '%s' for "
			"persisting file state - some data will probably be duplicated "
			"on next startup", fn);
		ABORT_FINALIZE(RS_RET_IO_ERROR);
	}
	const size_t toWrite = strlen(content);
	const ssize_t w = write(fd, content, toWrite);
	if(w != (ssize_t) toWrite) {
		LogError(errno, RS_RET_IO_ERROR, "imfile: partial write to state file '%s' "
			"this may cause trouble in the future. We will try to delete the "
			"state file, as this provides most consistent state", fn);
		unlink(fn);
		ABORT_FINALIZE(RS_RET_IO_ERROR);
	}
finalize_it:
	if(fd &gt;= 0) {
		close(fd);
	}
	RETiRet;
}
static void
removeOldStatefile(const uchar *statefn, const char *hashToDelete)
{
	int ret;
	uchar statefname[MAXFNAME];
	getFullStateFileName(statefn, hashToDelete, statefname, sizeof(statefname));
	DBGPRINTF("removing old state file: '%s'\n", statefname);
	ret = unlink((const char*)statefname);
	if(ret != 0) {
		if (errno != ENOENT) {
			LogError(errno, RS_RET_IO_ERROR,
				"imfile error trying to delete old state file: '%s' - ignoring this "
				"error, usually this means a file no longer file is left over, but "
				"this may also cause some real trouble. Still the best we can do ",
				statefname);
		} else {
			DBGPRINTF("trying to delete no longer valid statefile '%s' which no "
					  "longer exists (probably already deleted)\n", statefname);
		}
	}
}
static rsRetVal ATTR_NONNULL()
persistStrmState(act_obj_t *const act)
{
	DEFiRet;
	uchar statefile[MAXFNAME];
	uchar statefname[MAXFNAME];
	uchar *const statefn = getStateFileName(act, statefile, sizeof(statefile));
	getFileID(act);
	getFullStateFileName(statefn, act-&gt;file_id, statefname, sizeof(statefname));
	DBGPRINTF("persisting state for '%s', state file '%s'\n", act-&gt;name, statefname);
	struct json_object *jval = NULL;
	struct json_object *json = NULL;
	CHKmalloc(json = json_object_new_object());
	jval = json_object_new_string((char*) act-&gt;name);
	json_object_object_add(json, "filename", jval);
	jval = json_object_new_int(strmGetPrevWasNL(act-&gt;pStrm));
	json_object_object_add(json, "prev_was_nl", jval);
	jval = json_object_new_int64(act-&gt;pStrm-&gt;iCurrOffs);
	json_object_object_add(json, "curr_offs", jval);
	jval = json_object_new_int64(act-&gt;pStrm-&gt;strtOffs);
	json_object_object_add(json, "strt_offs", jval);
	const uchar *const prevLineSegment = strmGetPrevLineSegment(act-&gt;pStrm);
	if(prevLineSegment != NULL) {
		jval = json_object_new_string((const char*) prevLineSegment);
		json_object_object_add(json, "prev_line_segment", jval);
	}
	const uchar *const prevMsgSegment = strmGetPrevMsgSegment(act-&gt;pStrm);
	if(prevMsgSegment != NULL) {
		jval = json_object_new_string((const char*) prevMsgSegment);
		json_object_object_add(json, "prev_msg_segment", jval);
	}
	const char *jstr =  json_object_to_json_string_ext(json, JSON_C_TO_STRING_SPACED);
	CHKiRet(atomicWriteStateFile((const char*)statefname, jstr));
	json_object_put(json);
	if (strncmp((const char *)act-&gt;file_id_prev, (const char *)act-&gt;file_id, FILE_ID_HASH_SIZE)) {
		removeOldStatefile(statefn, act-&gt;file_id_prev);
	}
finalize_it:
	if(iRet != RS_RET_OK) {
		LogError(0, iRet, "imfile: could not persist state "
				"file %s - data may be repeated on next "
				"startup. Is WorkDirectory set?",
				statefname);
	}
	RETiRet;
}
BEGINafterRun
CODESTARTafterRun
	if(pInputName != NULL)
		prop.Destruct(&amp;pInputName);
ENDafterRun
BEGINisCompatibleWithFeature
CODESTARTisCompatibleWithFeature
	if(eFeat == sFEATURENonCancelInputTermination)
		iRet = RS_RET_OK;
ENDisCompatibleWithFeature
BEGINmodExit
CODESTARTmodExit
	objRelease(strm, CORE_COMPONENT);
	objRelease(glbl, CORE_COMPONENT);
	objRelease(prop, CORE_COMPONENT);
	objRelease(ruleset, CORE_COMPONENT);
	objRelease(datetime, CORE_COMPONENT);
	#ifdef HAVE_INOTIFY_INIT
	free(wdmap);
	#endif
ENDmodExit
BEGINqueryEtryPt
CODESTARTqueryEtryPt
CODEqueryEtryPt_STD_IMOD_QUERIES
CODEqueryEtryPt_STD_CONF2_QUERIES
CODEqueryEtryPt_STD_CONF2_setModCnf_QUERIES
CODEqueryEtryPt_STD_CONF2_IMOD_QUERIES
CODEqueryEtryPt_IsCompatibleWithFeature_IF_OMOD_QUERIES
ENDqueryEtryPt
static rsRetVal
resetConfigVariables(uchar __attribute__((unused)) *pp, void __attribute__((unused)) *pVal)
{
	DEFiRet;
	free(cs.pszFileName);
	cs.pszFileName = NULL;
	free(cs.pszFileTag);
	cs.pszFileTag = NULL;
	free(cs.pszStateFile);
	cs.pszStateFile = NULL;
	cs.iPollInterval = DFLT_PollInterval;
	cs.iFacility = 128; 	cs.iSeverity = 5;  	cs.readMode = 0;
	cs.maxLinesAtOnce = 10240;
	cs.trimLineOverBytes = 0;
	RETiRet;
}
static inline void
std_checkRuleset_genErrMsg(__attribute__((unused)) modConfData_t *modConf, instanceConf_t *inst)
{
	LogError(0, NO_ERRCODE, "imfile: ruleset '%s' for %s not found - "
			"using default ruleset instead", inst-&gt;pszBindRuleset,
			inst-&gt;pszFileName);
}
BEGINmodInit()
CODESTARTmodInit
	*ipIFVersProvided = CURR_MOD_IF_VERSION; CODEmodInit_QueryRegCFSLineHdlr
	CHKiRet(objUse(glbl, CORE_COMPONENT));
	CHKiRet(objUse(strm, CORE_COMPONENT));
	CHKiRet(objUse(ruleset, CORE_COMPONENT));
	CHKiRet(objUse(prop, CORE_COMPONENT));
	CHKiRet(objUse(datetime, CORE_COMPONENT));
	DBGPRINTF("version %s initializing\n", VERSION);
	CHKiRet(omsdRegCFSLineHdlr((uchar *)"inputfilename", 0, eCmdHdlrGetWord,
	  	NULL, &amp;cs.pszFileName, STD_LOADABLE_MODULE_ID));
	CHKiRet(omsdRegCFSLineHdlr((uchar *)"inputfiletag", 0, eCmdHdlrGetWord,
	  	NULL, &amp;cs.pszFileTag, STD_LOADABLE_MODULE_ID));
	CHKiRet(omsdRegCFSLineHdlr((uchar *)"inputfilestatefile", 0, eCmdHdlrGetWord,
	  	NULL, &amp;cs.pszStateFile, STD_LOADABLE_MODULE_ID));
	CHKiRet(omsdRegCFSLineHdlr((uchar *)"inputfileseverity", 0, eCmdHdlrSeverity,
	  	NULL, &amp;cs.iSeverity, STD_LOADABLE_MODULE_ID));
	CHKiRet(omsdRegCFSLineHdlr((uchar *)"inputfilefacility", 0, eCmdHdlrFacility,
	  	NULL, &amp;cs.iFacility, STD_LOADABLE_MODULE_ID));
	CHKiRet(omsdRegCFSLineHdlr((uchar *)"inputfilereadmode", 0, eCmdHdlrInt,
	  	NULL, &amp;cs.readMode, STD_LOADABLE_MODULE_ID));
	CHKiRet(omsdRegCFSLineHdlr((uchar *)"inputfilemaxlinesatonce", 0, eCmdHdlrSize,
	  	NULL, &amp;cs.maxLinesAtOnce, STD_LOADABLE_MODULE_ID));
	CHKiRet(omsdRegCFSLineHdlr((uchar *)"inputfiletrimlineoverbytes", 0, eCmdHdlrSize,
	  	NULL, &amp;cs.trimLineOverBytes, STD_LOADABLE_MODULE_ID));
	CHKiRet(omsdRegCFSLineHdlr((uchar *)"inputfilepersiststateinterval", 0, eCmdHdlrInt,
	  	NULL, &amp;cs.iPersistStateInterval, STD_LOADABLE_MODULE_ID));
	CHKiRet(omsdRegCFSLineHdlr((uchar *)"inputfilebindruleset", 0, eCmdHdlrGetWord,
		NULL, &amp;cs.pszBindRuleset, STD_LOADABLE_MODULE_ID));
	CHKiRet(omsdRegCFSLineHdlr((uchar *)"inputrunfilemonitor", 0, eCmdHdlrGetWord,
		addInstance, NULL, STD_LOADABLE_MODULE_ID));
	CHKiRet(regCfSysLineHdlr2((uchar *)"inputfilepollinterval", 0, eCmdHdlrInt,
	  	NULL, &amp;cs.iPollInterval, STD_LOADABLE_MODULE_ID, &amp;bLegacyCnfModGlobalsPermitted));
	CHKiRet(omsdRegCFSLineHdlr((uchar *)"resetconfigvariables", 1, eCmdHdlrCustomHandler,
		resetConfigVariables, NULL, STD_LOADABLE_MODULE_ID));
ENDmodInit
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
