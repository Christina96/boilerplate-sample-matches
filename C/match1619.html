<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html><head><title>Matches for imhiredis.c &amp; imfile.c</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for imhiredis.c &amp; imfile.c
      </h3>
<h1 align="center">
        7.1%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>imhiredis.c (11.775701%)<th>imfile.c (5.176664%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(137-153)<td><a href="#" name="0">(312-328)</a><td align="center"><font color="#ff0000">29</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(317-336)<td><a href="#" name="1">(1924-1943)</a><td align="center"><font color="#ed0000">27</font>
<tr onclick='openModal("#980517")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#980517"><font color="#980517">-</font><td><a href="#" name="2">(339-344)<td><a href="#" name="2">(1946-1951)</a><td align="center"><font color="#8c0000">16</font>
<tr onclick='openModal("#53858b")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#53858b"><font color="#53858b">-</font><td><a href="#" name="3">(403-416)<td><a href="#" name="3">(2094-2107)</a><td align="center"><font color="#7b0000">14</font>
<tr onclick='openModal("#6cc417")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#6cc417"><font color="#6cc417">-</font><td><a href="#" name="4">(220-234)<td><a href="#" name="4">(1755-1771)</a><td align="center"><font color="#7b0000">14</font>
<tr onclick='openModal("#151b8d")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#151b8d"><font color="#151b8d">-</font><td><a href="#" name="5">(728-739)<td><a href="#" name="5">(1954-1958)</a><td align="center"><font color="#720000">13</font>
<tr onclick='openModal("#8c8774")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#8c8774"><font color="#8c8774">-</font><td><a href="#" name="6">(270-290)<td><a href="#" name="6">(1038-1060)</a><td align="center"><font color="#720000">13</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>imhiredis.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
/* imhiredis.c
* Copyright 2021 aDvens
*
* This file is contrib for rsyslog.
* This input plugin is a log consumer from REDIS
* See README for doc
*
*
* This program is free software: you can redistribute it and/or
* modify it under the terms of the GNU Lesser General Public License
* as published by the Free Software Foundation, either version 3 of
* the License, or (at your option) any later version.
*
* This program is distributed in the hope that it will be useful, but
* WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
* Lesser General Public License for more details.
*
* You should have received a copy of the GNU Lesser General Public
* License along with this program. If not, see
* &lt;http://www.gnu.org/licenses/&gt;.
*
* Author: Jérémie Jourdin
* &lt;jeremie.jourdin@advens.fr&gt;
*/

#include "config.h"
#include &lt;stdio.h&gt;
#include &lt;stdarg.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;assert.h&gt;
#include &lt;errno.h&gt;
#include &lt;fcntl.h&gt;
#include &lt;pthread.h&gt;
#include &lt;sys/uio.h&gt;
#include &lt;hiredis/hiredis.h&gt;
#include &lt;hiredis/async.h&gt;
#include &lt;hiredis/adapters/libevent.h&gt;
#include &lt;event2/thread.h&gt;

#include "rsyslog.h"
#include "conf.h"
#include "syslogd-types.h"
#include "srUtils.h"
#include "template.h"
#include "module-template.h"
#include "errmsg.h"
#include "atomic.h"
#include "statsobj.h"
#include "unicode-helper.h"
#include "prop.h"
#include "ruleset.h"
#include "glbl.h"
#include "cfsysline.h"
#include "msg.h"
#include "dirty.h"

MODULE_TYPE_INPUT
MODULE_TYPE_NOKEEP
MODULE_CNFNAME("imhiredis")

/* static data */
DEF_IMOD_STATIC_DATA
#define QUEUE_BATCH_SIZE 10
#define IMHIREDIS_MODE_QUEUE 1
#define IMHIREDIS_MODE_SUBSCRIBE 2
DEFobjCurrIf(prop)
DEFobjCurrIf(ruleset)
DEFobjCurrIf(glbl)
DEFobjCurrIf(statsobj)


typedef struct redisNode_s {
	sbool isMaster;
	sbool usesSocket;
	uchar *socketPath;
	uchar *server;
	int port;
	struct redisNode_s *next;
} redisNode;


struct instanceConf_s {
	uchar *password;
	uchar *key;
	uchar *modeDescription;
	int mode;
	sbool useLPop;
	ruleset_t *pBindRuleset;	/* ruleset to bind listener to (use system default if unspecified) */
	uchar *pszBindRuleset;		/* default name of Ruleset to bind to */

	redisContext *conn;
	redisAsyncContext *aconn;
	struct event_base *evtBase;

	redisNode *currentNode; /* currently used redis node, can be any of the nodes in the redisNodesList list */
	/* the list of seen nodes
	 * the preferred node (the one from configuration) will always be the first element
	 * second one is a master (if preferred one is unavailable/replica) or a replica, others are replicas
	 * the preferred node may appear twice, but it is accepted
	 */
	redisNode *redisNodesList;

	struct instanceConf_s *next;
};


struct modConfData_s {
	rsconf_t *pConf;		/* our overall config object */
	instanceConf_t *root, *tail;
};

/* The following structure controls the worker threads. Global data is
 * needed for their access.
 */
static struct imhiredisWrkrInfo_s {
	pthread_t tid;		/* the worker's thread ID */
	instanceConf_t *inst;	/* Pointer to imhiredis instance */
} *imhiredisWrkrInfo;


/* GLOBAL DATA */
pthread_attr_t wrkrThrdAttr;	/* Attribute for worker threads ; read only after startup */

static int activeHiredisworkers = 0;
static char *redis_replies[] = {"unknown", "string", "array", "integer", "nil", "status", "error"};

static modConfData_t *loadModConf = NULL;/* modConf ptr to use for the current load process */
static modConfData_t *runModConf = NULL;/* modConf ptr to use for the current load process */

static prop_t *pInputName = NULL;
/* there is only one global inputName for all messages generated by this input */
<a name="0"></a>

/* module-global parameters */
<font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>static struct cnfparamdescr modpdescr[] = {};
static struct cnfparamblk modpblk =
	{ CNFPARAMBLK_VERSION,
	  sizeof(modpdescr)/sizeof(struct cnfparamdescr),
	  modpdescr
	};

/* input instance parameters */
static struct cnfparamdescr inppdescr[] = {
	{ "socketPath", eCmdHdlrGetWord, 0 },
	{ "server", eCmdHdlrGetWord, 0 },
	{ "port", eCmdHdlrInt, 0 },
	{ "password", eCmdHdlrGetWord, 0 },
	{ "mode", eCmdHdlrGetWord, 0 },
	{ "key", eCmdHdlrGetWord, 0 },
	{ "uselpop", eCmdHdlrBinary, 0 },
	{ "ruleset", eCmdHdlrString, 0 },</b></font>
};
static struct cnfparamblk inppblk =
	{ CNFPARAMBLK_VERSION,
	  sizeof(inppdescr)/sizeof(struct cnfparamdescr),
	  inppdescr
	};

struct timeval glblRedisConnectTimeout = { 3, 0 }; /* 3 seconds */


#include "im-helper.h" /* must be included AFTER the type definitions! */


/* forward references */
static void redisAsyncRecvCallback (redisAsyncContext __attribute__((unused)) *c, void *reply, void *inst_obj);
static void redisAsyncConnectCallback (const redisAsyncContext *c, int status);
static void redisAsyncDisconnectCallback (const redisAsyncContext *c, int status);
static rsRetVal enqMsg(instanceConf_t *const inst, const char *message);
rsRetVal redisAuthentSynchronous(redisContext *conn, uchar *password);
rsRetVal redisAuthentAsynchronous(redisAsyncContext *aconn, uchar *password);
rsRetVal redisActualizeCurrentNode(instanceConf_t *inst);
rsRetVal redisGetServersList(redisNode *node, uchar *password, redisNode **result);
rsRetVal redisAuthenticate(instanceConf_t *inst);
rsRetVal redisConnectSync(redisContext **conn, redisNode *node);
rsRetVal redisConnectAsync(redisAsyncContext **aconn, redisNode *node);
rsRetVal redisDequeue(instanceConf_t *inst);
void workerLoopSubscribe(struct imhiredisWrkrInfo_s *me);
void workerLoopQueue(struct imhiredisWrkrInfo_s *me);
static void *imhirediswrkr(void *myself);
static rsRetVal createRedisNode(redisNode **root);
rsRetVal copyNode(redisNode *src, redisNode **dst);
redisNode *freeNode(redisNode *node);
void insertNodeAfter(redisNode *root, redisNode *elem);
void dbgPrintNode(redisNode *node);


/* create input instance, set default parameters, and
 * add it to the list of instances.
 */
static rsRetVal
createInstance(instanceConf_t **pinst)
{
	DEFiRet;
	instanceConf_t *inst;
	CHKmalloc(inst = malloc(sizeof(instanceConf_t)));

	inst-&gt;next = NULL;
	inst-&gt;password = NULL;
	inst-&gt;key = NULL;
	inst-&gt;mode = 0;
	inst-&gt;useLPop = 0;
	inst-&gt;pszBindRuleset = NULL;
	inst-&gt;pBindRuleset = NULL;

	/* Redis objects */
	inst-&gt;conn = NULL;
	inst-&gt;aconn = NULL;

	/* redis nodes list */
	CHKiRet(createRedisNode(&amp;(inst-&gt;redisNodesList)));
	inst-&gt;currentNode = inst-&gt;redisNodesList;

	/* libevent base for async connection */
<a name="4"></a>	inst-&gt;evtBase = NULL;

	/* node created, let's add to config */
<font color="#6cc417"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>	if(loadModConf-&gt;tail == NULL) {
		loadModConf-&gt;tail = loadModConf-&gt;root = inst;
	} else {
		loadModConf-&gt;tail-&gt;next = inst;
		loadModConf-&gt;tail = inst;
	}

	*pinst = inst;
finalize_it:
	RETiRet;
}

/* this function checks instance parameters and does some required pre-processing
 */
static rsRetVal ATTR_NONNULL()</b></font>
checkInstance(instanceConf_t *const inst)
{
	DEFiRet;
	/* first node should be created from configuration */
	assert(inst-&gt;redisNodesList != NULL);

	/* check and print redis connection settings */
	if (inst-&gt;redisNodesList-&gt;server != NULL &amp;&amp; inst-&gt;redisNodesList-&gt;socketPath != NULL) {
		LogMsg(0, RS_RET_CONFIG_ERROR, LOG_WARNING,"imhiredis: both 'server' and 'socketPath' are given, "
								"ignoring 'socketPath'.");
		free(inst-&gt;redisNodesList-&gt;socketPath);
		inst-&gt;redisNodesList-&gt;socketPath = NULL;
	}

	if(inst-&gt;redisNodesList-&gt;server != NULL &amp;&amp; inst-&gt;redisNodesList-&gt;server[0] != '\0') {
		if (inst-&gt;redisNodesList-&gt;port == 0) {
			LogMsg(0, RS_RET_OK_WARN, LOG_WARNING, "imhiredis: port not set, setting default 6379");
			inst-&gt;redisNodesList-&gt;port = 6379;
		}
		DBGPRINTF("imhiredis: preferred server is %s (%d)\n",
			inst-&gt;redisNodesList-&gt;server,
			inst-&gt;redisNodesList-&gt;port);
		inst-&gt;redisNodesList-&gt;usesSocket = 0;
	}
	else if(inst-&gt;redisNodesList-&gt;socketPath != NULL &amp;&amp; inst-&gt;redisNodesList-&gt;socketPath[0] != '\0') {
		DBGPRINTF("imhiredis: preferred server is %s\n",
			inst-&gt;redisNodesList-&gt;socketPath);
		inst-&gt;redisNodesList-&gt;usesSocket = 1;
	} else {
		LogError(0, RS_RET_CONFIG_ERROR, "imhiredis: neither 'server' nor 'socketPath' are defined!");
		ABORT_FINALIZE(RS_RET_CONFIG_ERROR);
	}
<a name="6"></a>
	if (inst-&gt;key != NULL) {
		DBGPRINTF("imhiredis: key/channel is '%s'\n", inst-&gt;key);
<font color="#8c8774"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>	} else {
		LogError(0, RS_RET_CONFIG_ERROR, "imhiredis: no key defined !");
		ABORT_FINALIZE(RS_RET_CONFIG_ERROR);
	}

	if (inst-&gt;mode != IMHIREDIS_MODE_QUEUE &amp;&amp; inst-&gt;mode != IMHIREDIS_MODE_SUBSCRIBE) {
		LogError(0, RS_RET_CONFIG_ERROR, "imhiredis: invalid mode, please choose 'subscribe' or 'queue' mode.");
		ABORT_FINALIZE(RS_RET_CONFIG_ERROR);
	}

	if (inst-&gt;mode == IMHIREDIS_MODE_SUBSCRIBE &amp;&amp; inst-&gt;useLPop) {
		LogMsg(0, RS_RET_CONFIG_ERROR, LOG_WARNING,"imhiredis: 'uselpop' set with mode = subscribe : ignored.");

	}

	if (inst-&gt;password != NULL) {
		DBGPRINTF("imhiredis: password is '%s'\n", inst-&gt;password);
	}

	// set default current node as first node in list (preferred node)
	inst-&gt;currentNode = inst-&gt;redisNodesList;</b></font>
	// search master node (should be either preferred node or its master)
	if (RS_RET_OK != redisActualizeCurrentNode(inst) || inst-&gt;currentNode == NULL) {
		LogMsg(0, RS_RET_REDIS_ERROR, LOG_WARNING, "imhiredis: could not connect to a valid master!");
	}

finalize_it:
	RETiRet;
}

/* function to generate an error message if the ruleset cannot be found */
static inline void
std_checkRuleset_genErrMsg(__attribute__((unused)) modConfData_t *modConf, instanceConf_t *inst)
{
	LogError(0, NO_ERRCODE, "imhiredis: ruleset '%s' not found - "
		"using default ruleset instead",
		inst-&gt;pszBindRuleset);
}


BEGINnewInpInst
	struct cnfparamvals *pvals;
	instanceConf_t *inst;
	int i;
<a name="1"></a>CODESTARTnewInpInst
	DBGPRINTF("newInpInst (imhiredis)\n");

<font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>	if((pvals = nvlstGetParams(lst, &amp;inppblk, NULL)) == NULL) {
		ABORT_FINALIZE(RS_RET_MISSING_CNFPARAMS);
	}

	if(Debug) {
		dbgprintf("input param blk in imhiredis:\n");
		cnfparamsPrint(&amp;inppblk, pvals);
	}

	CHKiRet(createInstance(&amp;inst));
	for(i = 0 ; i &lt; inppblk.nParams ; ++i) {
		if(!pvals[i].bUsed)
			continue;

		if(!strcmp(inppblk.descr[i].name, "server")) {
			inst-&gt;redisNodesList-&gt;server = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
		} else if(!strcmp(inppblk.descr[i].name, "socketPath")) {
			inst-&gt;redisNodesList-&gt;socketPath = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
		} else if(!strcmp(inppblk.descr[i].name, "ruleset")) {
<a name="2"></a>			inst-&gt;pszBindRuleset = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);</b></font>
		} else if(!strcmp(inppblk.descr[i].name, "port")) {
			inst-&gt;redisNodesList-&gt;port = (int) pvals[i].val.d.n;
<font color="#980517"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>		} else if(!strcmp(inppblk.descr[i].name, "password")) {
			inst-&gt;password = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
		} else if(!strcmp(inppblk.descr[i].name, "uselpop")) {
			inst-&gt;useLPop = pvals[i].val.d.n;
		} else if(!strcmp(inppblk.descr[i].name, "mode")) {
			inst-&gt;modeDescription = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);</b></font>
			if (!strcmp((const char*)inst-&gt;modeDescription, "queue")) {
				inst-&gt;mode = IMHIREDIS_MODE_QUEUE;
			} else if (!strcmp((const char*)inst-&gt;modeDescription, "subscribe")) {
				inst-&gt;mode = IMHIREDIS_MODE_SUBSCRIBE;
			} else {
				LogMsg(0, RS_RET_PARAM_ERROR, LOG_ERR, "imhiredis: unsupported mode "
					"'%s'", inppblk.descr[i].name);
				ABORT_FINALIZE(RS_RET_PARAM_ERROR);
			}
		} else if(!strcmp(inppblk.descr[i].name, "key")) {
			inst-&gt;key = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
		} else {
			dbgprintf("imhiredis: program error, non-handled "
				"param '%s'\n", inppblk.descr[i].name);
		}
	}

	DBGPRINTF("imhiredis: checking config sanity\n");
	if (inst-&gt;modeDescription == NULL) {
		CHKmalloc(inst-&gt;modeDescription = (uchar*)strdup("subscribe"));
		inst-&gt;mode = IMHIREDIS_MODE_SUBSCRIBE;
		LogMsg(0, RS_RET_OK_WARN, LOG_WARNING, "imhiredis: \"mode\" parameter not specified "
			"using default redis 'subscribe' mode -- this may not be what you want!");
	}
	if (inst-&gt;key == NULL) {
		LogMsg(0, RS_RET_PARAM_ERROR, LOG_ERR, "imhiredis: \"key\" required parameter not specified!");
		ABORT_FINALIZE(RS_RET_PARAM_ERROR);
	}
	if(inst-&gt;redisNodesList-&gt;server == NULL &amp;&amp; inst-&gt;redisNodesList-&gt;socketPath == NULL) {
		CHKmalloc(inst-&gt;redisNodesList-&gt;server = (uchar *)strdup("127.0.0.1"));
		inst-&gt;redisNodesList-&gt;port = 6379;
		LogMsg(0, RS_RET_OK_WARN, LOG_WARNING, "imhiredis: no server parameter specified "
			"using default 127.0.0.1:6379 -- this may not be what you want!");
	}
	if (inst-&gt;password == NULL) {
		LogMsg(0, RS_RET_OK, LOG_INFO, "imhiredis: no password specified");
	}

	DBGPRINTF("imhiredis: newInpInst key=%s, mode=%s, uselpop=%d\n",
		inst-&gt;key, inst-&gt;modeDescription, inst-&gt;useLPop);

finalize_it:
CODE_STD_FINALIZERnewInpInst
	cnfparamvalsDestruct(pvals, &amp;inppblk);
ENDnewInpInst


BEGINbeginCnfLoad
CODESTARTbeginCnfLoad
	loadModConf = pModConf;
	pModConf-&gt;pConf = pConf;
ENDbeginCnfLoad


BEGINsetModCnf
<a name="3"></a>	struct cnfparamvals *pvals = NULL;
	int i;
CODESTARTsetModCnf
<font color="#53858b"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>	pvals = nvlstGetParams(lst, &amp;modpblk, NULL);
	if(pvals == NULL) {
		LogError(0, RS_RET_MISSING_CNFPARAMS, "imhiredis: error processing module "
			"config parameters [module(...)]");
		ABORT_FINALIZE(RS_RET_MISSING_CNFPARAMS);
	}

	if(Debug) {
		dbgprintf("module (global) param blk for imhiredis:\n");
		cnfparamsPrint(&amp;modpblk, pvals);
	}

	for(i = 0 ; i &lt; modpblk.nParams ; ++i) {
		if(!pvals[i].bUsed) {</b></font>
			continue;
		} else {
			dbgprintf("imhiredis: program error, non-handled "
			  "param '%s' in beginCnfLoad\n", modpblk.descr[i].name);
		}
	}
finalize_it:
	if(pvals != NULL)
		cnfparamvalsDestruct(pvals, &amp;modpblk);
ENDsetModCnf

BEGINendCnfLoad
CODESTARTendCnfLoad
ENDendCnfLoad

BEGINcheckCnf
	instanceConf_t *inst;
CODESTARTcheckCnf
	for(inst = pModConf-&gt;root ; inst != NULL ; inst = inst-&gt;next) {
		std_checkRuleset(pModConf, inst);
	}
ENDcheckCnf


BEGINactivateCnfPrePrivDrop
CODESTARTactivateCnfPrePrivDrop
	runModConf = pModConf;
ENDactivateCnfPrePrivDrop

BEGINactivateCnf
CODESTARTactivateCnf
	for(instanceConf_t *inst = pModConf-&gt;root ; inst != NULL ; inst = inst-&gt;next) {
		iRet = checkInstance(inst);
		if (inst-&gt;mode == IMHIREDIS_MODE_SUBSCRIBE)
			inst-&gt;evtBase = event_base_new();
	}
ENDactivateCnf


BEGINfreeCnf
	instanceConf_t *inst, *del;
	redisNode *node;
CODESTARTfreeCnf
	for(inst = pModConf-&gt;root ; inst != NULL ; ) {
		if (inst-&gt;evtBase)
			event_base_free(inst-&gt;evtBase);
		if (inst-&gt;password != NULL)
			free(inst-&gt;password);
		free(inst-&gt;modeDescription);
		free(inst-&gt;key);
		free(inst-&gt;pszBindRuleset);
		if(inst-&gt;conn != NULL) {
			redisFree(inst-&gt;conn);
			inst-&gt;conn = NULL;
		}
		if(inst-&gt;aconn != NULL) {
			redisAsyncFree(inst-&gt;aconn);
			inst-&gt;aconn = NULL;
		}

		for (node = inst-&gt;redisNodesList; node != NULL; node = freeNode(node)) {;}

		del = inst;
		inst = inst-&gt;next;
		free(del);
	}
ENDfreeCnf


/* Cleanup imhiredis worker threads */
static void
shutdownImhiredisWorkers(void)
{
	int i;
	instanceConf_t *inst;

	assert(imhiredisWrkrInfo != NULL);

	for(inst = runModConf-&gt;root ; inst != NULL ; inst = inst-&gt;next) {
		if (inst-&gt;mode == IMHIREDIS_MODE_SUBSCRIBE &amp;&amp; inst-&gt;aconn) {
			DBGPRINTF("imhiredis: disconnecting async worker\n");
			redisAsyncDisconnect(inst-&gt;aconn);
		}
	}

	// event_base_loopbreak(runModConf-&gt;evtBase);

	DBGPRINTF("imhiredis: waiting on imhiredis workerthread termination\n");
	for(i = 0 ; i &lt; activeHiredisworkers ; ++i) {
		pthread_join(imhiredisWrkrInfo[i].tid, NULL);
		DBGPRINTF("imhiredis: Stopped worker %d\n", i);
	}
	free(imhiredisWrkrInfo);
	imhiredisWrkrInfo = NULL;

	return;
}


/* This function is called to gather input.  */
BEGINrunInput
	int i;
	instanceConf_t *inst;
CODESTARTrunInput
	DBGPRINTF("imhiredis: runInput loop started ...\n");
	activeHiredisworkers = 0;
	for(inst = runModConf-&gt;root ; inst != NULL ; inst = inst-&gt;next) {
		++activeHiredisworkers;
	}

	if(activeHiredisworkers == 0) {
		LogError(0, RS_RET_ERR, "imhiredis: no active inputs, input does "
			"not run - there should have been additional error "
			"messages given previously");
		ABORT_FINALIZE(RS_RET_ERR);
	}


	DBGPRINTF("imhiredis: Starting %d imhiredis workerthreads\n", activeHiredisworkers);
	imhiredisWrkrInfo = calloc(activeHiredisworkers, sizeof(struct imhiredisWrkrInfo_s));
	if (imhiredisWrkrInfo == NULL) {
		LogError(errno, RS_RET_OUT_OF_MEMORY, "imhiredis: worker-info array allocation failed.");
		ABORT_FINALIZE(RS_RET_OUT_OF_MEMORY);
	}

	/* Start worker threads for each imhiredis input source
	*/
	i = 0;
	for(inst = runModConf-&gt;root ; inst != NULL ; inst = inst-&gt;next) {
		/* init worker info structure! */
		imhiredisWrkrInfo[i].inst = inst; /* Set reference pointer */
		pthread_create(&amp;imhiredisWrkrInfo[i].tid, &amp;wrkrThrdAttr, imhirediswrkr, &amp;(imhiredisWrkrInfo[i]));
		i++;
	}

	// This thread simply runs the various threads, then waits for Rsyslog to stop
	while(glbl.GetGlobalInputTermState() == 0) {
		if(glbl.GetGlobalInputTermState() == 0)
			/* Check termination state every 100ms
			 * should be sufficient to grant fast response to shutdown while not hogging CPU
			 */
			srSleep(0, 100000);
	}
	DBGPRINTF("imhiredis: terminating upon request of rsyslog core\n");

	shutdownImhiredisWorkers();
finalize_it:
ENDrunInput


BEGINwillRun
CODESTARTwillRun
	/* we need to create the inputName property (only once during our lifetime) */
	CHKiRet(prop.Construct(&amp;pInputName));
	CHKiRet(prop.SetString(pInputName, UCHAR_CONSTANT("imhiredis"), sizeof("imhiredis") - 1));
	CHKiRet(prop.ConstructFinalize(pInputName));
finalize_it:
ENDwillRun


BEGINafterRun
CODESTARTafterRun
	if(pInputName != NULL)
		prop.Destruct(&amp;pInputName);

ENDafterRun


BEGINmodExit
CODESTARTmodExit
	pthread_attr_destroy(&amp;wrkrThrdAttr);

	/* force cleaning of all libevent-related structures
	 * (clean shutdowns are not always guaranteed without it)
	 */
	libevent_global_shutdown();

	/* release objects we used */
	objRelease(statsobj, CORE_COMPONENT);
	objRelease(ruleset, CORE_COMPONENT);
	objRelease(glbl, CORE_COMPONENT);
	objRelease(prop, CORE_COMPONENT);
ENDmodExit


BEGINisCompatibleWithFeature
CODESTARTisCompatibleWithFeature
	if(eFeat == sFEATURENonCancelInputTermination)
		iRet = RS_RET_OK;
ENDisCompatibleWithFeature


BEGINqueryEtryPt
CODESTARTqueryEtryPt
CODEqueryEtryPt_STD_IMOD_QUERIES
CODEqueryEtryPt_STD_CONF2_QUERIES
CODEqueryEtryPt_STD_CONF2_PREPRIVDROP_QUERIES
CODEqueryEtryPt_STD_CONF2_IMOD_QUERIES
CODEqueryEtryPt_STD_CONF2_setModCnf_QUERIES
CODEqueryEtryPt_IsCompatibleWithFeature_IF_OMOD_QUERIES
ENDqueryEtryPt


BEGINmodInit()
CODESTARTmodInit
	*ipIFVersProvided = CURR_MOD_IF_VERSION;
CODEmodInit_QueryRegCFSLineHdlr
	/* request objects we use */
	CHKiRet(objUse(glbl, CORE_COMPONENT));
	CHKiRet(objUse(prop, CORE_COMPONENT));
	CHKiRet(objUse(ruleset, CORE_COMPONENT));
	CHKiRet(objUse(statsobj, CORE_COMPONENT));

	/* initialize "read-only" thread attributes */
	pthread_attr_init(&amp;wrkrThrdAttr);
	pthread_attr_setstacksize(&amp;wrkrThrdAttr, 4096*1024);

	/* activate libevent for (p)threads support */
	evthread_use_pthreads();

ENDmodInit


/* ------------------------------ callbacks ------------------------------ */


/**
 *	Asynchronous subscribe callback handler
 */
static void redisAsyncRecvCallback (redisAsyncContext *aconn, void *reply, void __attribute__((unused)) *unused) {
	/*
		redisReply is supposed to be an array of three elements: [''message', &lt;channel&gt;, &lt;message&gt;]


		JJO: For future reference (https://github.com/redis/hiredis/blob/master/README.md)

		Important: the current version of hiredis (1.0.0) frees replies when the asynchronous API is used.
		This means you should not call freeReplyObject when you use this API.
		The reply is cleaned up by hiredis after the callback returns.
		TODO We may have to change this function in the future to free replies.
	*/
	instanceConf_t *const inst = (instanceConf_t *) aconn-&gt;data;
	redisReply * r = (redisReply *) reply;
	if (r == NULL) return;

	if (r-&gt;elements &lt; 3 || r-&gt;element[2]-&gt;str == NULL) {
		return;
	}
	enqMsg(inst, r-&gt;element[2]-&gt;str);

	return;
}


/**
 *	Asynchronous connection callback handler
 */
static void redisAsyncConnectCallback (const redisAsyncContext *c, int status) {
	if (status != REDIS_OK) {
		LogMsg(0, RS_RET_REDIS_ERROR, LOG_ERR, "imhiredis (async): could not connect to redis: "
			"%s", c-&gt;errstr);
		// remove async context from instance config object, still contained in context's 'data' field
		instanceConf_t *inst = (instanceConf_t *) c-&gt;data;
		assert(inst != NULL);
		inst-&gt;aconn = NULL;
		return;
	}
	DBGPRINTF("imhiredis (async): successfully connected!\n");

	return;
}


/**
 *	Asynchronous disconnection callback handler
 */
static void redisAsyncDisconnectCallback (const redisAsyncContext *c, int status) {

	// remove context from instance config object (which is stored in the context 'data' field by us)
	// context will be freed by the library, so it's only set to NULL here
	instanceConf_t *inst = (instanceConf_t *) c-&gt;data;
	assert(inst != NULL);
	inst-&gt;aconn = NULL;
	inst-&gt;currentNode = NULL;

	if (status != REDIS_OK) {
		LogMsg(0, RS_RET_REDIS_ERROR, LOG_ERR, "imhiredis (async): got disconnected from redis: "
			"%s", c-&gt;errstr);
		return;
	}
	DBGPRINTF("imhiredis (async): successfully disconnected!\n");

	return;
}


/* ------------------------------ end callbacks ------------------------------ */

/*
 *	sends a ROLE command to the redis pointed by context
 *	context should be a valid redis context
 *	returns a valid redisReply pointer if an array reply was received, NULL otherwise
 */
redisReply *getRole(redisContext *c) {
	redisReply *reply;

	assert(c != NULL);

<a name="5"></a>	reply = redisCommand(c, "ROLE");
	if (reply == NULL) {
		DBGPRINTF("imhiredis: could not get reply from ROLE command\n");
<font color="#151b8d"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>	}
	else if (reply-&gt;type == REDIS_REPLY_ERROR) {
		LogMsg(0, RS_RET_REDIS_ERROR, LOG_WARNING, "imhiredis got an error while querying role -&gt; "
			"%s\n", reply-&gt;str);
		freeReplyObject(reply);
		reply = NULL;
	}
	else if (reply-&gt;type != REDIS_REPLY_ARRAY) {
		LogMsg(0, RS_RET_REDIS_ERROR, LOG_ERR, "imhiredis: did not get an array from ROLE command");
		freeReplyObject(reply);
		reply = NULL;
	}</b></font>

	return reply;
}


/*
 *	enqueue the hiredis message. The provided string is
 *	not freed - this must be done by the caller.
 */
static rsRetVal enqMsg(instanceConf_t *const inst, const char *message) {
	DEFiRet;
	smsg_t *pMsg;

	if (message == NULL || message[0] == '\0') {
		/* we do not process empty lines */
		FINALIZE;
	}

	DBGPRINTF("imhiredis: enqMsg: Msg -&gt; '%s'\n", message);

	CHKiRet(msgConstruct(&amp;pMsg));
	MsgSetInputName(pMsg, pInputName);
	MsgSetRawMsg(pMsg, message, strlen(message));
	MsgSetFlowControlType(pMsg, eFLOWCTL_LIGHT_DELAY);
	MsgSetRuleset(pMsg, inst-&gt;pBindRuleset);
	MsgSetMSGoffs(pMsg, 0);	/* we do not have a header... */
	CHKiRet(submitMsg2(pMsg));

finalize_it:
	RETiRet;
}


/*
 *	execute a synchronous authentication using the context conn
 *	conn and password should be non-NULL
 *	conn should be a valid context
 */
rsRetVal redisAuthentSynchronous(redisContext *conn, uchar *password) {
	DEFiRet;
	redisReply *reply = NULL;

	assert(conn != NULL);
	assert(password != NULL);
	assert(password[0] != '\0');

	reply = (redisReply *) redisCommand(conn, "AUTH %s", password);
	if (reply == NULL) {
		LogError(0, RS_RET_REDIS_ERROR, "imhiredis: Could not authenticate!\n");
		ABORT_FINALIZE(RS_RET_REDIS_ERROR);
	} else if (strncmp(reply-&gt;str, "OK", 2)) {
		LogError(0, RS_RET_REDIS_AUTH_FAILED, "imhiredis: Authentication failure -&gt; %s\n", reply-&gt;str);
		ABORT_FINALIZE(RS_RET_REDIS_AUTH_FAILED);
	}

finalize_it:
	if(reply)
		freeReplyObject(reply);
	RETiRet;
}


/*
 *	execute an asynchronous authentication using the context aconn
 *	aconn and password should be non-NULL
 *	aconn should be a valid (async) context
 */
rsRetVal redisAuthentAsynchronous(redisAsyncContext *aconn, uchar *password) {
	DEFiRet;

	assert(aconn != NULL);
	assert(password != NULL);
	assert(password[0] != '\0');

	if (REDIS_OK != redisAsyncCommand(aconn, NULL, NULL, "AUTH %s", password)) {
		LogError(0, RS_RET_REDIS_ERROR, "imhiredis: error while authenticating asynchronously -&gt; %s\n",
			aconn-&gt;errstr);
		ABORT_FINALIZE(RS_RET_REDIS_ERROR);
	}

finalize_it:
	RETiRet;
}


/*
 *	connect to node, authenticate (if necessary), get role, then get all node information provided by ROLE
 *	node should be a non-NULL valid redisNode pointer
 *	password can be NULL, meaning no authentication will be done
 *	result will hold the result of the ROLE command executed on the node:
 *		- NULL if the node was a single master instance
 *		- a single (master) node if the provided node was a replica
 *		- a list of (replica) nodes if the provided node was a master
 */
rsRetVal redisGetServersList(redisNode *node, uchar *password, redisNode **result) {
	DEFiRet;
	redisContext *context;
	redisReply *reply = NULL, *replica;
	unsigned int i;

	assert(node != NULL);

	CHKiRet(redisConnectSync(&amp;context, node));

	if(password != NULL &amp;&amp; password[0] != '\0') {
		CHKiRet(redisAuthentSynchronous(context, password));
	}

	reply = getRole(context);

	if(reply == NULL) {
		LogMsg(0, RS_RET_REDIS_ERROR, LOG_WARNING, "imhiredis: did not get the role of the server");
		ABORT_FINALIZE(RS_RET_REDIS_ERROR);
	}

	/*
	* string comparisons for ROLE could be skipped
	* as each role returns a different number of elements,
	* but lets keep it as a security...
	*/
	if (	reply-&gt;elements == 5 &amp;&amp;
		strncmp(reply-&gt;element[0]-&gt;str, "slave", 5) == 0) {

		CHKiRet(createRedisNode(result));
		(*result)-&gt;server = (uchar *) strdup((const char *)reply-&gt;element[1]-&gt;str);
		(*result)-&gt;port = reply-&gt;element[2]-&gt;integer;
		(*result)-&gt;isMaster = 1;
	}
	else if (	reply-&gt;elements == 3 &amp;&amp;
			reply-&gt;element[2]-&gt;type == REDIS_REPLY_ARRAY &amp;&amp;
			strncmp(reply-&gt;element[0]-&gt;str, "master", 6) == 0) {

		// iterate on all replicas given in the reply (if any)
		for (i = 0; i &lt; reply-&gt;element[2]-&gt;elements; i++) {
			replica = reply-&gt;element[2]-&gt;element[i];

			if (replica-&gt;type == REDIS_REPLY_ARRAY &amp;&amp; replica-&gt;elements == 3) {
				/* node will be a new node every time
				* with old ones shifted in the list
				*/
				CHKiRet(createRedisNode(result));
				(*result)-&gt;server = (uchar *) strdup((const char *)replica-&gt;element[0]-&gt;str);
				// yes, the value in that case is a string and NOT an integer!
				(*result)-&gt;port = atoi(replica-&gt;element[1]-&gt;str);
			}
		}
	} else {
		// we have a sentinel, or a problem
		ABORT_FINALIZE(RS_RET_NOT_FOUND);
	}

finalize_it:
	if (reply != NULL)
		freeReplyObject(reply);
	if (context != NULL)
		redisFree(context);
	RETiRet;
}



/*
 *	actualize the current master node to use during connection for instance inst
 *	inst should be a valid, non-NULL instanceConf object
 *	inst should also possess at least a single node in inst-&gt;redisNodeList
 *	if the function returns RS_RET_OK, inst-&gt;currentNode and inst-&gt;redisNodeList have been both updated
 *	to reflect new master and potential replicas
 *	the first configured node (called preferred node) is always kept as the first entry in redisNodeList
 */
rsRetVal redisActualizeCurrentNode(instanceConf_t *inst) {
	DEFiRet;
	redisReply *reply = NULL;
	redisNode *node, *tmp, *newList = NULL;

	assert(inst != NULL);
	assert(inst-&gt;redisNodesList != NULL);

	inst-&gt;currentNode = NULL;
	// keep first node in list = preferred node (comes from configuration)
	copyNode(inst-&gt;redisNodesList, &amp;newList);
	newList-&gt;next = NULL;

	for (node = inst-&gt;redisNodesList; node != NULL; node = node-&gt;next) {
		tmp = NULL;

		DBGPRINTF("imhiredis: trying to connect to node to get info...\n");
		dbgPrintNode(node);

		if (RS_RET_OK == redisGetServersList(node, inst-&gt;password, &amp;tmp)) {
			// server replied

			if (tmp &amp;&amp; tmp-&gt;isMaster) {
				DBGPRINTF("imhiredis: node replied with a master node, is a replica\n");
				// master node, keep it as potential new active node
				inst-&gt;currentNode = tmp;
				tmp = NULL;

				// try to connect to the master and get replicas
				if(RS_RET_OK != redisGetServersList(inst-&gt;currentNode, inst-&gt;password, &amp;tmp)) {

					/* had a master, but cannot connect
					* save suspected master in new list but keep searching with other nodes
					*/
					DBGPRINTF("imhiredis: had a master but cannot connect, keeping in list\n");
					dbgPrintNode(inst-&gt;currentNode);
					insertNodeAfter(newList, inst-&gt;currentNode);
					inst-&gt;currentNode = NULL;
					continue;
				}
			} else {
				DBGPRINTF("imhiredis: node replied with a list of replicas, is a master\n");
				// copy the node to the new currentNode, list owning node will be freed
				node-&gt;isMaster = 1;
				copyNode(node, &amp;(inst-&gt;currentNode));
				inst-&gt;currentNode-&gt;next = NULL;
			}

			/*
			 * here, tmp is a list of replicas or NULL (single node)
			 * inst-&gt;currentNode is the new active master
			 */

			// add the replicas to the list
			if (tmp) {
				insertNodeAfter(newList, tmp);
				DBGPRINTF("imhiredis: inserting replicas to list\n");
				for (tmp = newList-&gt;next; tmp != NULL; tmp = tmp-&gt;next) {
					dbgPrintNode(tmp);
				}
			}
			// insert the master after the preferred node (configuration)
			DBGPRINTF("imhiredis: inserting new master node in list\n");
			dbgPrintNode(inst-&gt;currentNode);
			insertNodeAfter(newList, inst-&gt;currentNode);

			// swap newList and redisNodesList to free old list at the end of the function
			tmp = newList;
			newList = inst-&gt;redisNodesList;
			inst-&gt;redisNodesList = tmp;
			FINALIZE;
		}
	}

	DBGPRINTF("imhiredis: did not find a valid master");
	iRet = RS_RET_NOT_FOUND;
	inst-&gt;currentNode = NULL;

finalize_it:
	if (reply != NULL)
		freeReplyObject(reply);
	// newList is always completely freed
	for (node = newList; node != NULL; ) {
		node = freeNode(node);
	}

	RETiRet;
}


/*
 *	authentication function, for both synchronous and asynchronous modes (queue or subscribe)
 *	inst, inst-&gt;curentMode and inst-&gt;password should not be NULL
 */
rsRetVal redisAuthenticate(instanceConf_t *inst) {
	DEFiRet;
	redisContext *usedContext = NULL;
	redisReply *reply = NULL;

	assert(inst != NULL);
	assert(inst-&gt;currentNode != NULL);
	assert(inst-&gt;password != NULL);
	assert(inst-&gt;password[0] != '\0');

	DBGPRINTF("imhiredis: authenticating...\n");

	// Create a temporary context for synchronous connection, used to validate AUTH command in asynchronous contexts
	if (inst-&gt;mode == IMHIREDIS_MODE_SUBSCRIBE) {
		if (RS_RET_OK != redisConnectSync(&amp;usedContext, inst-&gt;currentNode)) {
			LogMsg(0, RS_RET_REDIS_ERROR, LOG_WARNING, "imhiredis: could not connect to current "
				"active node synchronously to validate authentication");
			ABORT_FINALIZE(RS_RET_REDIS_ERROR);
		}
	} else {
		usedContext = inst-&gt;conn;
	}

	/*
	 * Try synchronous connection, whatever the method for the instance
	 * This is also done for the asynchronous mode, to validate the successful authentication
	 */
	CHKiRet(redisAuthentSynchronous(usedContext, inst-&gt;password));

	if (inst-&gt;mode == IMHIREDIS_MODE_SUBSCRIBE) {
		CHKiRet(redisAuthentAsynchronous(inst-&gt;aconn, inst-&gt;password));
	}

	DBGPRINTF("imhiredis: authentication successful\n");

finalize_it:
	if(inst-&gt;mode == IMHIREDIS_MODE_SUBSCRIBE &amp;&amp; usedContext)
		redisFree(usedContext);
	if(reply)
		freeReplyObject(reply);
	RETiRet;
}


/*
 *	connection function for synchronous (queue) mode
 *	node should not be NULL
 */
rsRetVal redisConnectSync(redisContext **conn, redisNode *node) {
	DEFiRet;

	assert(node != NULL);

	if (node-&gt;usesSocket)
		*conn = redisConnectUnixWithTimeout((const char *)node-&gt;socketPath, glblRedisConnectTimeout);
	else
		*conn = redisConnectWithTimeout((const char *)node-&gt;server, node-&gt;port, glblRedisConnectTimeout);

	if (*conn == NULL) {
		if (node-&gt;usesSocket) {
			LogError(0, RS_RET_REDIS_ERROR, "imhiredis: can not connect to redis server '%s' "
				"-&gt; could not allocate context!\n", node-&gt;socketPath);
		} else {
			LogError(0, RS_RET_REDIS_ERROR, "imhiredis: can not connect to redis server '%s', "
				"port %d -&gt; could not allocate context!\n", node-&gt;server, node-&gt;port);
		}
		ABORT_FINALIZE(RS_RET_REDIS_ERROR);
	}
	else if ((*conn)-&gt;err) {
		if (node-&gt;usesSocket) {
			LogError(0, RS_RET_REDIS_ERROR, "imhiredis: can not connect to redis server '%s' "
				"-&gt; %s\n", node-&gt;socketPath, (*conn)-&gt;errstr);
		} else {
			LogError(0, RS_RET_REDIS_ERROR, "imhiredis: can not connect to redis server '%s', "
				"port %d -&gt; %s\n", node-&gt;server, node-&gt;port, (*conn)-&gt;errstr);
		}
		ABORT_FINALIZE(RS_RET_REDIS_ERROR);
	}

finalize_it:
	if (iRet != RS_RET_OK) {
		if (*conn)
			redisFree(*conn);
		*conn = NULL;
	}
	RETiRet;
}


/*
 *	connection function for asynchronous (subscribe) mode
 *	node should not be NULL
 */
rsRetVal redisConnectAsync(redisAsyncContext **aconn, redisNode *node) {
	DEFiRet;

	assert(node != NULL);

	if (node-&gt;usesSocket)
		*aconn = redisAsyncConnectUnix((const char*)node-&gt;socketPath);
	else
		*aconn = redisAsyncConnect((const char *)node-&gt;server, node-&gt;port);

	if(*aconn == NULL) {
		LogError(0, RS_RET_REDIS_ERROR, "imhiredis (async): could not allocate context!\n");
		ABORT_FINALIZE(RS_RET_REDIS_ERROR);
	} else if ((*aconn)-&gt;err) {
		if (node-&gt;usesSocket) {
			LogError(0, RS_RET_REDIS_ERROR, "imhiredis (async): cannot connect to server '%s' "
				"-&gt; %s\n", node-&gt;socketPath, (*aconn)-&gt;errstr);
		} else {
			LogError(0, RS_RET_REDIS_ERROR, "imhiredis (async): cannot connect to server '%s', port '%d' "
				"-&gt; %s\n", node-&gt;server, node-&gt;port, (*aconn)-&gt;errstr);
		}
		ABORT_FINALIZE(RS_RET_REDIS_ERROR);
	}

finalize_it:
	if (iRet != RS_RET_OK) {
		if(*aconn)
			redisAsyncFree(*aconn);
		*aconn = NULL;
	}
	RETiRet;
}

/*
 *	dequeue all entries in the redis list, using batches of 10 commands
 */
rsRetVal redisDequeue(instanceConf_t *inst) {
	DEFiRet;
	redisReply *reply = NULL;
	uint replyType = 0, i;

	assert(inst != NULL);

	DBGPRINTF("imhiredis: beginning to dequeue key '%s'\n", inst-&gt;key);

	do {
		// append a batch of QUEUE_BATCH_SIZE POP commands (either LPOP or RPOP depending on conf)
		if (inst-&gt;useLPop == 1) {
			DBGPRINTF("imhiredis: Queuing #%d LPOP commands on key '%s' \n",
					QUEUE_BATCH_SIZE,
					inst-&gt;key);
			for (i=0; i&lt;QUEUE_BATCH_SIZE; ++i ) {
				if (REDIS_OK != redisAppendCommand(inst-&gt;conn, "LPOP %s", inst-&gt;key))
					break;
			}
		} else {
			DBGPRINTF("imhiredis: Queuing #%d RPOP commands on key '%s' \n",
					QUEUE_BATCH_SIZE,
					inst-&gt;key);
			for (i=0; i&lt;QUEUE_BATCH_SIZE; i++) {
				if (REDIS_OK != redisAppendCommand(inst-&gt;conn, "RPOP %s", inst-&gt;key))
					break;
			}
		}

		// parse responses from appended commands
		do {
			if (REDIS_OK != redisGetReply(inst-&gt;conn, (void **) &amp;reply)) {
				// error getting reply, must stop
				LogError(0, RS_RET_REDIS_ERROR, "imhiredis: Error reading reply after POP #%d on key "
								"'%s'", (QUEUE_BATCH_SIZE - i), inst-&gt;key);
				ABORT_FINALIZE(RS_RET_REDIS_ERROR);
			} else {
				if (reply != NULL) {
					replyType = reply-&gt;type;
					switch(replyType) {
						case REDIS_REPLY_STRING:
							enqMsg(inst, reply-&gt;str);
							break;
						case REDIS_REPLY_NIL:
							// replies are dequeued but are empty = end of list
							break;
						case REDIS_REPLY_ERROR:
							// There is a problem with the key or the Redis instance
							LogMsg(0, RS_RET_REDIS_ERROR, LOG_ERR, "imhiredis: error "
							"while POP'ing key '%s' -&gt; %s", inst-&gt;key, reply-&gt;str);
							ABORT_FINALIZE(RS_RET_REDIS_ERROR);
						default:
							LogMsg(0, RS_RET_OK_WARN, LOG_WARNING, "imhiredis: unexpected "
							"reply type: %s", redis_replies[replyType%7]);
					}
					freeReplyObject(reply);
					reply = NULL;
				} else { /* reply == NULL */
					LogMsg(0, RS_RET_REDIS_ERROR, LOG_ERR, "imhiredis: unexpected empty reply "
						"for successful return");
					ABORT_FINALIZE(RS_RET_REDIS_ERROR);
				}
			}

		// while there are replies to unpack, continue
		} while (--i &gt; 0);

	// while input can run and last reply was a string, continue with a new batch
	} while (replyType == REDIS_REPLY_STRING &amp;&amp; glbl.GetGlobalInputTermState() == 0);

	DBGPRINTF("imhiredis: finished to dequeue key '%s'\n", inst-&gt;key);

finalize_it:
	if (reply)
		freeReplyObject(reply);
	RETiRet;
}


/*
 *	worker function for asynchronous (subscribe) mode
 */
void workerLoopSubscribe(struct imhiredisWrkrInfo_s *me) {
	uint i;
	DBGPRINTF("imhiredis (async): beginning of subscribe worker loop...\n");

	// Connect first time without delay
	if (me-&gt;inst-&gt;currentNode != NULL) {
		if(RS_RET_OK != redisConnectAsync(&amp;(me-&gt;inst-&gt;aconn), me-&gt;inst-&gt;currentNode)) {
			me-&gt;inst-&gt;currentNode = NULL;
		}
		if(	me-&gt;inst-&gt;password != NULL &amp;&amp;
			me-&gt;inst-&gt;password[0] != '\0' &amp;&amp;
			RS_RET_OK != redisAuthenticate(me-&gt;inst)) {

			redisAsyncFree(me-&gt;inst-&gt;aconn);
			me-&gt;inst-&gt;aconn = NULL;
			me-&gt;inst-&gt;currentNode = NULL;
		}

		// finalize context creation
		me-&gt;inst-&gt;aconn-&gt;data = (void *)me-&gt;inst;
		redisAsyncSetConnectCallback(me-&gt;inst-&gt;aconn, redisAsyncConnectCallback);
		redisAsyncSetDisconnectCallback(me-&gt;inst-&gt;aconn, redisAsyncDisconnectCallback);
		redisLibeventAttach(me-&gt;inst-&gt;aconn, me-&gt;inst-&gt;evtBase);
	}

	while(glbl.GetGlobalInputTermState() == 0) {
		if (me-&gt;inst-&gt;aconn == NULL) {
			/*
			 * Sleep 10 seconds before attempting to resume a broken connexion
			 * (sleep small amounts to avoid missing termination status)
			 */
			DBGPRINTF("imhiredis: no valid connection, sleeping 10 seconds before retrying...\n");
			for(i = 0; i &lt; 100; i++) {
				// Rsyslog asked for shutdown, thread should be stopped
				if (glbl.GetGlobalInputTermState() != 0)
					goto end_loop;
				// 100ms sleeps
				srSleep(0, 100000);
			}

			// search the current master node
			if (me-&gt;inst-&gt;currentNode == NULL) {
				if(RS_RET_OK != redisActualizeCurrentNode(me-&gt;inst))
					continue;
			}

			// connect to current master
			if(me-&gt;inst-&gt;currentNode != NULL) {
				if(RS_RET_OK != redisConnectAsync(&amp;(me-&gt;inst-&gt;aconn), me-&gt;inst-&gt;currentNode)) {
					me-&gt;inst-&gt;currentNode = NULL;
					continue;
				}
				if(	me-&gt;inst-&gt;password != NULL &amp;&amp;
					me-&gt;inst-&gt;password[0] != '\0' &amp;&amp;
					RS_RET_OK != redisAuthenticate(me-&gt;inst)) {

					redisAsyncFree(me-&gt;inst-&gt;aconn);
					me-&gt;inst-&gt;aconn = NULL;
					me-&gt;inst-&gt;currentNode = NULL;
					continue;
				}
			}

			// finalize context creation
			me-&gt;inst-&gt;aconn-&gt;data = (void *)me-&gt;inst;
			redisAsyncSetConnectCallback(me-&gt;inst-&gt;aconn, redisAsyncConnectCallback);
			redisAsyncSetDisconnectCallback(me-&gt;inst-&gt;aconn, redisAsyncDisconnectCallback);
			redisLibeventAttach(me-&gt;inst-&gt;aconn, me-&gt;inst-&gt;evtBase);
		}
		if (me-&gt;inst-&gt;aconn != NULL) {
			DBGPRINTF("imhiredis (async): subscribing to channel '%s'\n", me-&gt;inst-&gt;key);
			redisAsyncCommand(
				me-&gt;inst-&gt;aconn,
				redisAsyncRecvCallback,
				NULL,
				"SUBSCRIBE %s",
				me-&gt;inst-&gt;key);
			event_base_dispatch(me-&gt;inst-&gt;evtBase);
		}
	}

end_loop:
	return;
}


/*
 *	worker function for synchronous (queue) mode
 */
void workerLoopQueue(struct imhiredisWrkrInfo_s *me) {
	uint i;
	DBGPRINTF("imhiredis: beginning of queue worker loop...\n");
	// Connect first time without delay
	if (me-&gt;inst-&gt;currentNode != NULL) {
		if(RS_RET_OK != redisConnectSync(&amp;(me-&gt;inst-&gt;conn), me-&gt;inst-&gt;currentNode)) {
			me-&gt;inst-&gt;currentNode = NULL;
		}
		if(	me-&gt;inst-&gt;password != NULL &amp;&amp;
			me-&gt;inst-&gt;password[0] != '\0' &amp;&amp;
			RS_RET_OK != redisAuthenticate(me-&gt;inst)) {

			redisFree(me-&gt;inst-&gt;conn);
			me-&gt;inst-&gt;conn = NULL;
			me-&gt;inst-&gt;currentNode = NULL;
		}
	}

	while(glbl.GetGlobalInputTermState() == 0) {
		if (me-&gt;inst-&gt;conn == NULL) {
			/* Sleep 10 seconds before attempting to resume a broken connexion
			 * (sleep small amounts to avoid missing termination status)
			 */
			DBGPRINTF("imhiredis: no valid connection, sleeping 10 seconds before retrying...\n");
			for(i = 0; i &lt; 100; i++) {
				// Time to stop the thread
				if (glbl.GetGlobalInputTermState() != 0)
					goto end_loop;
				// 100ms sleeps
				srSleep(0, 100000);
			}

			// search the current master node
			if (me-&gt;inst-&gt;currentNode == NULL) {
				if(RS_RET_OK != redisActualizeCurrentNode(me-&gt;inst))
					continue;
			}

			// connect to current master
			if(me-&gt;inst-&gt;currentNode != NULL) {
				if(RS_RET_OK != redisConnectSync(&amp;(me-&gt;inst-&gt;conn), me-&gt;inst-&gt;currentNode)) {
					me-&gt;inst-&gt;currentNode = NULL;
					continue;
				}
				if(	me-&gt;inst-&gt;password != NULL &amp;&amp;
					me-&gt;inst-&gt;password[0] != '\0' &amp;&amp;
					RS_RET_OK != redisAuthenticate(me-&gt;inst)) {

					redisFree(me-&gt;inst-&gt;conn);
					me-&gt;inst-&gt;conn = NULL;
					me-&gt;inst-&gt;currentNode = NULL;
					continue;
				}
			}
		}
		if (me-&gt;inst-&gt;conn != NULL) {
			if (redisDequeue(me-&gt;inst) == RS_RET_REDIS_ERROR) {
				DBGPRINTF("imhiredis: current connection invalidated\n");
				redisFree(me-&gt;inst-&gt;conn);
				me-&gt;inst-&gt;currentNode = NULL;
				me-&gt;inst-&gt;conn = NULL;
			}
			if(glbl.GetGlobalInputTermState() == 0) {
				/* sleep 1s between 2 POP tries
				* this does NOT limit dequeing rate, but prevents the input from polling Redis too often
				*/
				for(i = 0; i &lt; 10; i++) {
					// Time to stop the thread
					if (glbl.GetGlobalInputTermState() != 0)
						goto end_loop;
					// 100ms sleeps
					srSleep(0, 100000);
				}
			}
		}
	}

end_loop:
	return;
}


/*
 *	Workerthread function for a single hiredis consumer
 */
static void *
imhirediswrkr(void *myself)
{
	struct imhiredisWrkrInfo_s *me = (struct imhiredisWrkrInfo_s*) myself;
	DBGPRINTF("imhiredis: started hiredis consumer workerthread\n");
	dbgPrintNode(me-&gt;inst-&gt;currentNode);

	if(me-&gt;inst-&gt;mode == IMHIREDIS_MODE_QUEUE)
		workerLoopQueue(me);
	else if (me-&gt;inst-&gt;mode == IMHIREDIS_MODE_SUBSCRIBE)
		workerLoopSubscribe(me);

	DBGPRINTF("imhiredis: stopped hiredis consumer workerthread\n");
	return NULL;
}



// -------------------------- redisNode functions -----------------------------------

/*
 *	create a redisNode and set default values
 *	if a valid node is given as parameter, the new node is inserted as the new head of the linked list
 */
static rsRetVal
createRedisNode(redisNode **root) {
	redisNode *node;
	DEFiRet;
	CHKmalloc(node = malloc(sizeof(redisNode)));
	node-&gt;port = 0;
	node-&gt;server = NULL;
	node-&gt;socketPath = NULL;
	node-&gt;usesSocket = 0;
	node-&gt;isMaster = 0;
	node-&gt;next = NULL;

	if (!root) {
		*root = node;
	} else {
		node-&gt;next = (*root);
		*root = node;
	}

finalize_it:
	RETiRet;
}

/*
 *	make a complete copy of the src node into the newly-created node in dst
 *	if dst already contains a node, the new node will be added as the new head of the provided list
 *	src should not be NULL
 */
rsRetVal copyNode(redisNode *src, redisNode **dst) {
	DEFiRet;

	assert(src != NULL);

	CHKiRet(createRedisNode(dst));

	(*dst)-&gt;isMaster = src-&gt;isMaster;
	(*dst)-&gt;next = src-&gt;next;
	(*dst)-&gt;port = src-&gt;port;
	(*dst)-&gt;usesSocket = src-&gt;usesSocket;

	if (src-&gt;server)
		(*dst)-&gt;server = (uchar *) strdup((const char *)src-&gt;server);
	if (src-&gt;socketPath)
		(*dst)-&gt;socketPath = (uchar *) strdup((const char *)src-&gt;socketPath);

finalize_it:
	RETiRet;
}

/*
 *	free all ressources of the node
 *	will return next node if one is present, NULL otherwise
 */
redisNode *freeNode(redisNode *node) {
	redisNode *ret = NULL;
	if (node != NULL) {
		if (node-&gt;next != NULL)
			ret = node-&gt;next;

		if(node-&gt;server != NULL)
			free(node-&gt;server);
		if(node-&gt;socketPath != NULL)
			free(node-&gt;socketPath);
		free(node);
	}

	return ret;
}

/*
 *	insert node 'elem' after node 'root' in the linked list
 *	both root and elem should not be NULL
 */
void insertNodeAfter(redisNode *root, redisNode *elem) {
	assert(root != NULL);
	assert(elem != NULL);

	if(root-&gt;next != NULL) {
		elem-&gt;next = root-&gt;next;
	}
	root-&gt;next = elem;

	return;
}

void dbgPrintNode(redisNode *node) {
	if (node != NULL) {
		if (node-&gt;usesSocket) {
			if (node-&gt;isMaster) {
				DBGPRINTF("imhiredis: node is %s (master)\n", node-&gt;socketPath);
			} else {
				DBGPRINTF("imhiredis: node is %s (replica)\n", node-&gt;socketPath);
			}
		} else {
			if (node-&gt;isMaster) {
				DBGPRINTF("imhiredis: node is %s:%d (master)\n", node-&gt;server, node-&gt;port);
			} else {
				DBGPRINTF("imhiredis: node is %s:%d (replica)\n", node-&gt;server, node-&gt;port);
			}
		}
	}
	return;
}
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>imfile.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
/* imfile.c
 *
 * This is the input module for reading text file data. A text file is a
 * non-binary file who's lines are delemited by the \n character.
 *
 * Work originally begun on 2008-02-01 by Rainer Gerhards
 *
 * Copyright 2008-2019 Adiscon GmbH.
 *
 * This file is part of rsyslog.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *       -or-
 *       see COPYING.ASL20 in the source distribution
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#include "config.h"
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;assert.h&gt;
#include &lt;string.h&gt;
#include &lt;errno.h&gt;
#include &lt;fcntl.h&gt;
#include &lt;pthread.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;unistd.h&gt;
#include &lt;time.h&gt;
#include &lt;glob.h&gt;
#include &lt;poll.h&gt;
#include &lt;json.h&gt;
#include &lt;fnmatch.h&gt;
#ifdef HAVE_SYS_INOTIFY_H
#include &lt;sys/inotify.h&gt;
#include &lt;linux/types.h&gt;
#endif
#ifdef HAVE_SYS_STAT_H
#	include &lt;sys/stat.h&gt;
#endif
#if defined(OS_SOLARIS) &amp;&amp; defined (HAVE_PORT_SOURCE_FILE)
#include &lt;port.h&gt;
#include &lt;sys/port.h&gt;
#endif
#include "rsyslog.h"		/* error codes etc... */
#include "dirty.h"
#include "cfsysline.h"		/* access to config file objects */
#include "module-template.h"	/* generic module interface code - very important, read it! */
#include "srUtils.h"		/* some utility functions */
#include "msg.h"
#include "stream.h"
#include "errmsg.h"
#include "glbl.h"
#include "unicode-helper.h"
#include "prop.h"
#include "stringbuf.h"
#include "ruleset.h"
#include "ratelimit.h"
#include "srUtils.h"
#include "parserif.h"
#include "datetime.h"

#include &lt;regex.h&gt;

/* some platforms do not have large file support :( */
#ifndef O_LARGEFILE
#  define O_LARGEFILE 0
#endif
#ifndef HAVE_LSEEK64
#  define lseek64(fd, offset, whence) lseek(fd, offset, whence)
#endif

MODULE_TYPE_INPUT
MODULE_TYPE_NOKEEP
MODULE_CNFNAME("imfile")

/* defines */
#define FILE_ID_HASH_SIZE 20	/* max size of a file_id hash */
#define FILE_ID_SIZE	512	/* how many bytes are used for file-id? */

/* Module static data */
DEF_IMOD_STATIC_DATA	/* must be present, starts static data */
DEFobjCurrIf(glbl)
DEFobjCurrIf(strm)
DEFobjCurrIf(prop)
DEFobjCurrIf(ruleset)
DEFobjCurrIf(datetime)

extern int rs_siphash(const uint8_t *in, const size_t inlen, const uint8_t *k,
	uint8_t *out, const size_t outlen); /* see siphash.c */

static int bLegacyCnfModGlobalsPermitted;/* are legacy module-global config parameters permitted? */

#define NUM_MULTISUB 1024 /* default max number of submits */
#define DFLT_PollInterval 10
#define INIT_WDMAP_TAB_SIZE 1 /* default wdMap table size - is extended as needed, use 2^x value */
#define ADD_METADATA_UNSPECIFIED -1

/* If set to 1, fileTableDisplay will be compiled and used for debugging */
#define ULTRA_DEBUG 0

/* Setting GLOB_BRACE to ZERO which disables support for GLOB_BRACE if not available on current platform */
#ifndef GLOB_BRACE
	#define GLOB_BRACE 0
#endif

typedef struct per_minute_rate_limit_s per_minute_rate_limit_t;

struct per_minute_rate_limit_s {
	uint64_t maxBytesPerMinute;
	uint32_t maxLinesPerMinute;
	uint64_t bytesThisMinute; /* bytes sent so far this minute */
	uint32_t linesThisMinute; /* lines sent to far this minute */
	time_t rateLimitingMinute; /* minute we are currently rate limiting for */
};

static struct configSettings_s {
	uchar *pszFileName;
	uchar *pszFileTag;
	uchar *pszStateFile;
	uchar *pszBindRuleset;
	int iPollInterval;
	int iPersistStateInterval;	/* how often if state file to be persisted? (default 0-&gt;never) */
	int bPersistStateAfterSubmission;/* persist state file after messages have been submitted */
	int iFacility; /* local0 */
	int iSeverity;  /* notice, as of rfc 3164 */
	int readMode;  /* mode to use for ReadMultiLine call */
	int64 maxLinesAtOnce;	/* how many lines to process in a row? */
	uint64_t maxBytesPerMinute; /* maximum bytes per minute to send before rate limiting */
	uint64_t maxLinesPerMinute; /* maximum lines per minute to send before rate limiting */
	uint32_t trimLineOverBytes;  /* 0: never trim line, positive number: trim line if over bytes */
} cs;

struct instanceConf_s {
	uchar *pszFileName;
	uchar *pszFileName_forOldStateFile; /* we unfortunately needs this to read old state files */
	uchar *pszDirName;
	uchar *pszFileBaseName;
	uchar *pszTag;
	size_t lenTag;
	uchar *pszStateFile;
	uchar *pszBindRuleset;
	int nMultiSub;
	per_minute_rate_limit_t perMinuteRateLimits;
	int iPersistStateInterval;
	int bPersistStateAfterSubmission;
	int iFacility;
	int iSeverity;
	int readTimeout;
	unsigned delay_perMsg;
	sbool bRMStateOnDel;
	uint8_t readMode;
	uchar *startRegex;
	uchar *endRegex;
	regex_t start_preg;	/* compiled version of startRegex */
	regex_t end_preg;	/* compiled version of endRegex */
	sbool discardTruncatedMsg;
	sbool msgDiscardingError;
	sbool escapeLF;
	sbool reopenOnTruncate;
	sbool addCeeTag;
	sbool addMetadata;
	sbool freshStartTail;
	sbool fileNotFoundError;
	int maxLinesAtOnce;
	uint32_t trimLineOverBytes;
	uint32_t ignoreOlderThan;
	int msgFlag;
	uchar *escapeLFString;
	ruleset_t *pBindRuleset;	/* ruleset to bind listener to (use system default if unspecified) */
	struct instanceConf_s *next;
};


/* file system objects */
typedef struct fs_edge_s fs_edge_t;
typedef struct fs_node_s fs_node_t;
typedef struct act_obj_s act_obj_t;
struct act_obj_s {
	act_obj_t *prev;
	act_obj_t *next;
	fs_edge_t *edge;	/* edge which this object belongs to */
	char *name;		/* full path name of active object */
	char *basename;		/* only basename */ //TODO: remove when refactoring rename support
	char *source_name;	/* if this object is target of a symlink, source_name is its name (else NULL) */
	//char *statefile;	/* base name of state file (for move operations) */
	int wd;
#if defined(OS_SOLARIS) &amp;&amp; defined (HAVE_PORT_SOURCE_FILE)
	struct fileinfo *pfinf;
	sbool bPortAssociated;
	int is_deleted;	/* debugging: entry deleted? */
#endif
	time_t timeoutBase; /* what time to calculate the timeout against? */
	/* file dynamic data */
	char file_id[FILE_ID_HASH_SIZE]; /* file id for this entry, once we could obtain it */
	char file_id_prev[FILE_ID_HASH_SIZE]; /* previous file id for this entry, set if changed */
	int in_move;	/* workaround for inotify move: if set, state file must not be deleted */
	ino_t ino;	/* current inode nbr */
	int fd;		/* fd to file in order to obtain file_id (needs to be preserved across move) */
	strm_t *pStrm;	/* its stream (NULL if not assigned) */
	int nRecords; /**&lt; How many records did we process before persisting the stream? */
	ratelimit_t *ratelimiter;
	multi_submit_t multiSub;
	int is_symlink;
};
struct fs_edge_s {
	fs_node_t *parent;	/* node pointing to this edge */
	fs_node_t *node;	/* node this edge points to */
	fs_edge_t *next;
	uchar *name;
	uchar *path;
	act_obj_t *active;
	int is_file;
	int ninst;		/* nbr of instances in instarr */
	instanceConf_t **instarr;
};
struct fs_node_s {
	fs_edge_t *edges;	/* NULL in leaf nodes */
	fs_node_t *root;	/* node one level up (NULL for file system root) */
};


/* forward definitions */
static rsRetVal persistStrmState(act_obj_t *);
static rsRetVal resetConfigVariables(uchar __attribute__((unused)) *pp, void __attribute__((unused)) *pVal);
static rsRetVal ATTR_NONNULL(1) pollFile(act_obj_t *act);
static int ATTR_NONNULL() getBasename(uchar *const __restrict__ basen, uchar *const __restrict__ path);
static void ATTR_NONNULL() act_obj_unlink(act_obj_t *act);
static uchar * ATTR_NONNULL(1, 2) getStateFileName(const act_obj_t *, uchar *, const size_t);
static int ATTR_NONNULL() getFullStateFileName(const uchar *const, const char *const,
	uchar *const pszout, const size_t ilenout);


#define OPMODE_POLLING 0
#define OPMODE_INOTIFY 1
#define OPMODE_FEN 2

/* config variables */
struct modConfData_s {
	rsconf_t *pConf;	/* our overall config object */
	int iPollInterval;	/* number of seconds to sleep when there was no file activity */
	int readTimeout;
	int timeoutGranularity;		/* value in ms */
	instanceConf_t *root, *tail;
	fs_node_t *conf_tree;
	uint8_t opMode;
	sbool configSetViaV2Method;
	uchar *stateFileDirectory;
	sbool sortFiles;
	sbool normalizePath;	/* normalize file system pathes (all start with root dir) */
	sbool haveReadTimeouts;	/* use special processing if read timeouts exist */
	sbool bHadFileData;	/* actually a global variable:
				   1 - last call to pollFile() had data
				   0 - last call to pollFile() had NO data
				   Must be manually reset to 0 if desired. Helper for
				   polling mode.
				 */
};
static modConfData_t *loadModConf = NULL;/* modConf ptr to use for the current load process */
static modConfData_t *runModConf = NULL;/* modConf ptr to use for run process */
static modConfData_t *currModConf = NULL;/* modConf ptr to CURRENT mod conf (run or load) */


#ifdef HAVE_INOTIFY_INIT
/* We need to map watch descriptors to our actual objects. Unfortunately, the
 * inotify API does not provide us with any cookie, so a simple O(1) algorithm
 * cannot be done (what a shame...). We assume that maintaining the array is much
 * less often done than looking it up, so we keep the array sorted by watch descriptor
 * and do a binary search on the wd we get back. This is at least O(log n), which
 * is not too bad for the anticipated use case.
 */
struct wd_map_s {
	int wd;		/* ascending sort key */
	act_obj_t *act; /* point to related active object */
};
typedef struct wd_map_s wd_map_t;
static wd_map_t *wdmap = NULL;
static int nWdmap;
static int allocMaxWdmap;
static int ino_fd;	/* fd for inotify calls */
#endif /* #if HAVE_INOTIFY_INIT -------------------------------------------------- */

#if defined(OS_SOLARIS) &amp;&amp; defined (HAVE_PORT_SOURCE_FILE)
struct fileinfo {
	struct file_obj fobj;
	int events;
	int port;
};

static int glport; /* Static port handle for FEN api*/
#endif /* #if OS_SOLARIS -------------------------------------------------- */

static prop_t *pInputName = NULL;
/* there is only one global inputName for all messages generated by this input */

/* module-global parameters */
static struct cnfparamdescr modpdescr[] = {
	{ "pollinginterval", eCmdHdlrPositiveInt, 0 },
	{ "readtimeout", eCmdHdlrNonNegInt, 0 },
	{ "timeoutgranularity", eCmdHdlrPositiveInt, 0 },
	{ "sortfiles", eCmdHdlrBinary, 0 },
<a name="0"></a>	{ "statefile.directory", eCmdHdlrString, 0 },
	{ "normalizepath", eCmdHdlrBinary, 0 },
	{ "mode", eCmdHdlrGetWord, 0 }
<font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>};
static struct cnfparamblk modpblk =
	{ CNFPARAMBLK_VERSION,
	  sizeof(modpdescr)/sizeof(struct cnfparamdescr),
	  modpdescr
	};

/* input instance parameters */
static struct cnfparamdescr inppdescr[] = {
	{ "file", eCmdHdlrString, CNFPARAM_REQUIRED },
	{ "tag", eCmdHdlrString, CNFPARAM_REQUIRED },
	{ "severity", eCmdHdlrSeverity, 0 },
	{ "facility", eCmdHdlrFacility, 0 },
	{ "ruleset", eCmdHdlrString, 0 },
	{ "readmode", eCmdHdlrInt, 0 },
	{ "startmsg.regex", eCmdHdlrString, 0 },
	{ "endmsg.regex", eCmdHdlrString, 0 },</b></font>
	{ "discardtruncatedmsg", eCmdHdlrBinary, 0 },
	{ "msgdiscardingerror", eCmdHdlrBinary, 0 },
	{ "escapelf", eCmdHdlrBinary, 0 },
	{ "escapelf.replacement", eCmdHdlrString, 0 },
	{ "reopenontruncate", eCmdHdlrBinary, 0 },
	{ "maxlinesatonce", eCmdHdlrInt, 0 },
	{ "trimlineoverbytes", eCmdHdlrInt, 0 },
	{ "maxsubmitatonce", eCmdHdlrInt, 0 },
	{ "removestateondelete", eCmdHdlrBinary, 0 },
	{ "persiststateinterval", eCmdHdlrInt, 0 },
	{ "persiststateaftersubmission", eCmdHdlrBinary, 0 },
	{ "deletestateonfiledelete", eCmdHdlrBinary, 0 },
	{ "delay.message", eCmdHdlrNonNegInt, 0 },
	{ "addmetadata", eCmdHdlrBinary, 0 },
	{ "addceetag", eCmdHdlrBinary, 0 },
	{ "statefile", eCmdHdlrString, CNFPARAM_DEPRECATED },
	{ "readtimeout", eCmdHdlrNonNegInt, 0 },
	{ "freshstarttail", eCmdHdlrBinary, 0},
	{ "filenotfounderror", eCmdHdlrBinary, 0},
	{ "needparse", eCmdHdlrBinary, 0},
	{ "ignoreolderthan", eCmdHdlrInt, 0},
	{ "maxbytesperminute", eCmdHdlrInt, 0},
	{ "maxlinesperminute", eCmdHdlrInt, 0}
};
static struct cnfparamblk inppblk =
	{ CNFPARAMBLK_VERSION,
	  sizeof(inppdescr)/sizeof(struct cnfparamdescr),
	  inppdescr
	};

#include "im-helper.h" /* must be included AFTER the type definitions! */


/* Support for "old cruft" state files will potentially become optional in the
 * future (hopefully). To prepare so, we use conditional compilation with a
 * fixed-true condition ;-) -- rgerhards, 2018-03-28
 * reason: https://github.com/rsyslog/rsyslog/issues/2231#issuecomment-376862280
 */
#define ENABLE_V1_STATE_FILE_FORMAT_SUPPORT 1
#ifdef ENABLE_V1_STATE_FILE_FORMAT_SUPPORT
static uchar * ATTR_NONNULL(1, 2)
OLD_getStateFileName(const instanceConf_t *const inst,
	 uchar *const __restrict__ buf,
	 const size_t lenbuf)
{
	DBGPRINTF("OLD_getStateFileName trying '%s'\n", inst-&gt;pszFileName_forOldStateFile);
	snprintf((char*)buf, lenbuf - 1, "imfile-state:%s", inst-&gt;pszFileName_forOldStateFile);
	buf[lenbuf-1] = '\0'; /* be on the safe side... */
	uchar *p = buf;
	for( ; *p ; ++p) {
		if(*p == '/')
			*p = '-';
	}
	return buf;
}


static const uchar *
getStateFileDir(void)
{
	const uchar *wrkdir;
	assert(currModConf != NULL);
	if(currModConf-&gt;stateFileDirectory == NULL) {
		wrkdir = glblGetWorkDirRaw(currModConf-&gt;pConf);
	} else {
		wrkdir = currModConf-&gt;stateFileDirectory;
	}
	return(wrkdir);
}


/* try to open an old-style state file for given file. If the state file does not
 * exist or cannot be read, an error is returned.
 */
static rsRetVal ATTR_NONNULL(1)
OLD_openFileWithStateFile(act_obj_t *const act)
{
	DEFiRet;
	strm_t *psSF = NULL;
	uchar pszSFNam[MAXFNAME];
	size_t lenSFNam;
	struct stat stat_buf;
	uchar statefile[MAXFNAME];
	const instanceConf_t *const inst = act-&gt;edge-&gt;instarr[0];// TODO: same file, multiple instances?

	uchar *const statefn = OLD_getStateFileName(inst, statefile, sizeof(statefile));
	DBGPRINTF("OLD_openFileWithStateFile: trying to open state for '%s', state file '%s'\n",
		  act-&gt;name, statefn);

	/* Get full path and file name */
	lenSFNam = getFullStateFileName(statefn, "", pszSFNam, sizeof(pszSFNam));

	/* check if the file exists */
	if(stat((char*) pszSFNam, &amp;stat_buf) == -1) {
		if(errno == ENOENT) {
			DBGPRINTF("OLD_openFileWithStateFile: NO state file (%s) exists for '%s'\n",
				pszSFNam, act-&gt;name);
			ABORT_FINALIZE(RS_RET_FILE_NOT_FOUND);
		} else {
			char errStr[1024];
			rs_strerror_r(errno, errStr, sizeof(errStr));
			DBGPRINTF("OLD_openFileWithStateFile: error trying to access state "
				"file for '%s':%s\n", act-&gt;name, errStr);
			ABORT_FINALIZE(RS_RET_IO_ERROR);
		}
	}

	/* If we reach this point, we have a state file */

	DBGPRINTF("old state file found - instantiating from it\n");
	CHKiRet(strm.Construct(&amp;psSF));
	CHKiRet(strm.SettOperationsMode(psSF, STREAMMODE_READ));
	CHKiRet(strm.SetsType(psSF, STREAMTYPE_FILE_SINGLE));
	CHKiRet(strm.SetFName(psSF, pszSFNam, lenSFNam));
	CHKiRet(strm.SetFileNotFoundError(psSF, inst-&gt;fileNotFoundError));
	CHKiRet(strm.ConstructFinalize(psSF));

	/* read back in the object */
	CHKiRet(obj.Deserialize(&amp;act-&gt;pStrm, (uchar*) "strm", psSF, NULL, act));
	free(act-&gt;pStrm-&gt;pszFName);
	CHKmalloc(act-&gt;pStrm-&gt;pszFName = ustrdup(act-&gt;name));

	strm.CheckFileChange(act-&gt;pStrm);
	CHKiRet(strm.SeekCurrOffs(act-&gt;pStrm));

	/* we now persist the new state file and delete the old one, so we will
	 * never have to deal with the old one. */
	persistStrmState(act);
	unlink((char*)pszSFNam);

finalize_it:
	if(psSF != NULL)
		strm.Destruct(&amp;psSF);
	RETiRet;
}
#endif /* #ifdef ENABLE_V1_STATE_FILE_FORMAT_SUPPORT */



#if 0 // Code we can potentially use for new functionality // TODO: use or remove
//TODO add a kind of portable asprintf:
static const char * ATTR_NONNULL()
gen_full_name(const char *const dirname, const char *const name)
{
	const size_t len_full_name = strlen(dirname) + 1 + strlen(name) + 1;
	char *const full_name = malloc(len_full_name);
	if(full_name == NULL)
		return NULL;

	snprintf(full_name, len_full_name, "%s/%s", dirname, name);
	return full_name;
}
#endif


#ifdef HAVE_INOTIFY_INIT
#if ULTRA_DEBUG == 1
static void
dbg_wdmapPrint(const char *msg)
{
	int i;
	DBGPRINTF("%s\n", msg);
	for(i = 0 ; i &lt; nWdmap ; ++i)
		DBGPRINTF("wdmap[%d]: wd: %d, act %p, name: %s\n",
			i, wdmap[i].wd, wdmap[i].act, wdmap[i].act-&gt;name);
}
#endif

static rsRetVal
wdmapInit(void)
{
	DEFiRet;
	free(wdmap);
	CHKmalloc(wdmap = malloc(sizeof(wd_map_t) * INIT_WDMAP_TAB_SIZE));
	allocMaxWdmap = INIT_WDMAP_TAB_SIZE;
	nWdmap = 0;
finalize_it:
	RETiRet;
}


/* note: we search backwards, as inotify tends to return increasing wd's */
static rsRetVal
wdmapAdd(int wd, act_obj_t *const act)
{
	wd_map_t *newmap;
	int newmapsize;
	int i;
	DEFiRet;

	for(i = nWdmap-1 ; i &gt;= 0 &amp;&amp; wdmap[i].wd &gt; wd ; --i)
		; 	/* just scan */
	if(i &gt;= 0 &amp;&amp; wdmap[i].wd == wd) {
		LogError(0, RS_RET_INTERNAL_ERROR, "imfile: wd %d already in wdmap!", wd);
		ABORT_FINALIZE(RS_RET_FILE_ALREADY_IN_TABLE);
	}
	++i;
	/* i now points to the entry that is to be moved upwards (or end of map) */
	if(nWdmap == allocMaxWdmap) {
		newmapsize = 2 * allocMaxWdmap;
		CHKmalloc(newmap = realloc(wdmap, sizeof(wd_map_t) * newmapsize));
		// TODO: handle the error more intelligently? At all possible? -- 2013-10-15
		wdmap = newmap;
		allocMaxWdmap = newmapsize;
	}
	if(i &lt; nWdmap) {
		/* we need to shift to make room for new entry */
		memmove(wdmap + i + 1, wdmap + i, sizeof(wd_map_t) * (nWdmap - i));
	}
	wdmap[i].wd = wd;
	wdmap[i].act = act;
	++nWdmap;
	DBGPRINTF("add wdmap[%d]: wd %d, act obj %p, path %s\n", i, wd, act, act-&gt;name);

finalize_it:
	RETiRet;
}

/* return wd or -1 on error */
static int
in_setupWatch(act_obj_t *const act, const int is_file)
{
	int wd = -1;
	if(runModConf-&gt;opMode != OPMODE_INOTIFY)
		goto done;

	wd = inotify_add_watch(ino_fd, act-&gt;name,
		(is_file) ? IN_MODIFY|IN_DONT_FOLLOW : IN_CREATE|IN_DELETE|IN_MOVED_FROM|IN_MOVED_TO);
	if(wd &lt; 0) {
		if (errno == EACCES) { /* There is high probability of selinux denial on top-level paths */
			DBGPRINTF("imfile: permission denied when adding watch for '%s'\n", act-&gt;name);
		} else {
			LogError(errno, RS_RET_IO_ERROR, "imfile: cannot watch object '%s'", act-&gt;name);
		}
		goto done;
	}
	wdmapAdd(wd, act);
	DBGPRINTF("in_setupWatch: watch %d added for %s(object %p)\n", wd, act-&gt;name, act);
done:	return wd;
}

/* compare function for bsearch() */
static int
wdmap_cmp(const void *k, const void *a)
{
	int key = *((int*) k);
	wd_map_t *etry = (wd_map_t*) a;
	if(key &lt; etry-&gt;wd)
		return -1;
	else if(key &gt; etry-&gt;wd)
		return 1;
	else
		return 0;
}
/* looks up a wdmap entry and returns it's index if found
 * or -1 if not found.
 */
static wd_map_t *
wdmapLookup(int wd)
{
	return bsearch(&amp;wd, wdmap, nWdmap, sizeof(wd_map_t), wdmap_cmp);
}


static rsRetVal
wdmapDel(const int wd)
{
	int i;
	DEFiRet;

	for(i = 0 ; i &lt; nWdmap &amp;&amp; wdmap[i].wd &lt; wd ; ++i)
		; 	/* just scan */
	if(i == nWdmap ||  wdmap[i].wd != wd) {
		DBGPRINTF("wd %d shall be deleted but not in wdmap!\n", wd);
		FINALIZE;
	}

	if(i &lt; nWdmap-1) {
		/* we need to shift to delete it (see comment at wdmap definition) */
		memmove(wdmap + i, wdmap + i + 1, sizeof(wd_map_t) * (nWdmap - i - 1));
	}
	--nWdmap;
	DBGPRINTF("wd %d deleted, was idx %d\n", wd, i);

finalize_it:
	RETiRet;
}

#endif // #ifdef HAVE_INOTIFY_INIT

#if defined(OS_SOLARIS) &amp;&amp; defined (HAVE_PORT_SOURCE_FILE)
static void ATTR_NONNULL()
fen_setupWatch(act_obj_t *const act)
{
	DBGPRINTF("fen_setupWatch: enter, opMode %d\n", runModConf-&gt;opMode);
	if(runModConf-&gt;opMode != OPMODE_FEN)
		goto done;

	DBGPRINTF("fen_setupWatch: %s\n", act-&gt;name);
	if(act-&gt;pfinf == NULL) {
		act-&gt;pfinf = malloc(sizeof(struct fileinfo));
		if (act-&gt;pfinf == NULL) {
			LogError(errno, RS_RET_OUT_OF_MEMORY, "imfile: fen_setupWatch alloc memory "
				"for fileinfo failed ");
			goto done;
		}
		if ((act-&gt;pfinf-&gt;fobj.fo_name = strdup(act-&gt;name)) == NULL) {
			LogError(errno, RS_RET_OUT_OF_MEMORY, "imfile: fen_setupWatch alloc memory "
				"for strdup failed ");
			free(act-&gt;pfinf);
			act-&gt;pfinf = NULL;
			goto done;
		}
		act-&gt;pfinf-&gt;events = FILE_MODIFIED;
		act-&gt;pfinf-&gt;port = glport;
		act-&gt;bPortAssociated = 0;
	}

	DBGPRINTF("fen_setupWatch: bPortAssociated %d\n", act-&gt;bPortAssociated);
	if(act-&gt;bPortAssociated) {
		goto done;
	}

	struct stat fileInfo;
	const int r = stat(act-&gt;name, &amp;fileInfo);
	if(r == -1) { /* object gone away? */
		DBGPRINTF("fen_setupWatch: file gone away, no watch: '%s'\n", act-&gt;name);
		goto done;
	}

	/* note: FEN watch must be re-registered each time - this is what we do now */
	act-&gt;pfinf-&gt;fobj.fo_atime = fileInfo.st_atim;
	act-&gt;pfinf-&gt;fobj.fo_mtime = fileInfo.st_mtim;
	act-&gt;pfinf-&gt;fobj.fo_ctime = fileInfo.st_ctim;
	if(port_associate(glport, PORT_SOURCE_FILE, (uintptr_t)&amp;(act-&gt;pfinf-&gt;fobj),
				act-&gt;pfinf-&gt;events, (void *)act) == -1) {
		LogError(errno, RS_RET_SYS_ERR, "fen_setupWatch: Failed to associate port for file "
			": %s\n", act-&gt;pfinf-&gt;fobj.fo_name);
		goto done;
	} else {
		/* Port successfull listening now*/
		DBGPRINTF("fen_setupWatch: associated port for file %s\n", act-&gt;name);
		act-&gt;bPortAssociated = 1;
	}

	DBGPRINTF("in_setupWatch: fen association added for %s\n", act-&gt;name);
done:	return;
}
#else
static void ATTR_NONNULL()
fen_setupWatch(act_obj_t *const act __attribute__((unused)))
{
	DBGPRINTF("fen_setupWatch: DUMMY CALLED - not on Solaris?\n");
}
#endif /* FEN */

static void
fs_node_print(const fs_node_t *const node, const int level)
{
	fs_edge_t *chld;
	act_obj_t *act;
	dbgprintf("node print[%2.2d]: %p edges:\n", level, node);

	for(chld = node-&gt;edges ; chld != NULL ; chld = chld-&gt;next) {
		dbgprintf("node print[%2.2d]:     child %p '%s' isFile %d, path: '%s'\n",
			level, chld-&gt;node, chld-&gt;name, chld-&gt;is_file, chld-&gt;path);
		for(int i = 0 ; i &lt; chld-&gt;ninst ; ++i) {
			dbgprintf("\tinst: %p\n", chld-&gt;instarr[i]);
		}
		for(act = chld-&gt;active ; act != NULL ; act = act-&gt;next) {
			dbgprintf("\tact : %p\n", act);
			dbgprintf("\tact : %p: name '%s', wd: %d\n",
				act, act-&gt;name, act-&gt;wd);
		}
	}
	for(chld = node-&gt;edges ; chld != NULL ; chld = chld-&gt;next) {
		fs_node_print(chld-&gt;node, level+1);
	}
}

static sbool
isIgnoreOlderFile(const instanceConf_t *const inst, const char *const name)
{
	if (inst-&gt;ignoreOlderThan)
	{
		struct stat stat_buf;
		time_t tt;
		/* skip old files */
		datetime.GetTime(&amp;tt);
		if (stat((char *)name, &amp;stat_buf) == 0 &amp;&amp; difftime(tt, stat_buf.st_mtime) &gt; inst-&gt;ignoreOlderThan) {
			return 1;
		}
	}
	return 0;
}

/* add a new file system object if it not yet exists, ignore call
 * if it already does.
 */
static rsRetVal ATTR_NONNULL(1,2)
act_obj_add(fs_edge_t *const edge, const char *const name, const int is_file,
	const ino_t ino, const int is_symlink, const char *const source)
{
	act_obj_t *act = NULL;
	char basename[MAXFNAME];
	DEFiRet;
	int fd = -1;

	DBGPRINTF("act_obj_add: edge %p, name '%s' (source '%s')\n", edge, name, source? source : "---");

	if (isIgnoreOlderFile(edge-&gt;instarr[0], name)) {
		ABORT_FINALIZE(RS_RET_ERR);
	}

	for(act = edge-&gt;active ; act != NULL ; act = act-&gt;next) {
		if(!strcmp(act-&gt;name, name)) {
			if (!source || !act-&gt;source_name || !strcmp(act-&gt;source_name, source)) {
				DBGPRINTF("active object '%s' already exists in '%s' - no need to add\n",
					name, edge-&gt;path);
				FINALIZE;
			}
		}
	}
	DBGPRINTF("need to add new active object '%s' in '%s' - checking if accessible\n", name, edge-&gt;path);
	fd = open(name, O_RDONLY | O_CLOEXEC);
	if(fd &lt; 0) {
		if (is_file) {
			LogError(errno, RS_RET_ERR, "imfile: error accessing file '%s'", name);
		} else { /* reporting only in debug for dirs as higher lvl paths are likely blocked by selinux */
			DBGPRINTF("imfile: error accessing directory '%s'", name);
		}
		ABORT_FINALIZE(RS_RET_NO_FILE_ACCESS);
	}
	DBGPRINTF("add new active object '%s' in '%s'\n", name, edge-&gt;path);
	CHKmalloc(act = calloc(sizeof(act_obj_t), 1));
	CHKmalloc(act-&gt;name = strdup(name));
	if (-1 == getBasename((uchar*)basename, (uchar*)name)) {
		CHKmalloc(act-&gt;basename = strdup(name)); /* assume basename is same as name */
	} else {
		CHKmalloc(act-&gt;basename = strdup(basename));
	}
	act-&gt;edge = edge;
	act-&gt;ino = ino;
	act-&gt;fd = fd;
	act-&gt;file_id[0] = '\0';
	act-&gt;file_id_prev[0] = '\0';
	act-&gt;is_symlink = is_symlink;
	act-&gt;ratelimiter = NULL;
	if (source) { /* we are target of symlink */
		CHKmalloc(act-&gt;source_name = strdup(source));
	} else {
		act-&gt;source_name = NULL;
	}
	#ifdef HAVE_INOTIFY_INIT
	act-&gt;wd = in_setupWatch(act, is_file);
	#endif
	fen_setupWatch(act);
	if(is_file &amp;&amp; !is_symlink) {
		const instanceConf_t *const inst = edge-&gt;instarr[0];// TODO: same file, multiple instances?
		CHKiRet(ratelimitNew(&amp;act-&gt;ratelimiter, "imfile", name));
		CHKmalloc(act-&gt;multiSub.ppMsgs = malloc(inst-&gt;nMultiSub * sizeof(smsg_t *)));
		act-&gt;multiSub.maxElem = inst-&gt;nMultiSub;
		act-&gt;multiSub.nElem = 0;
		pollFile(act);
	}

	/* all well, add to active list */
	if(edge-&gt;active != NULL) {
		edge-&gt;active-&gt;prev = act;
	}
	act-&gt;next = edge-&gt;active;
	edge-&gt;active = act;
finalize_it:
	if(iRet != RS_RET_OK) {
		if(act != NULL) {
			if (act-&gt;ratelimiter != NULL)
				ratelimitDestruct(act-&gt;ratelimiter);
			free(act-&gt;name);
			free(act);
		}
		if(fd != -1) {
			close(fd);
		}
	}
	RETiRet;
}


/* this walks an edges active list and detects and acts on any changes
 * seen there. It does NOT detect newly appeared files, as they are not
 * inside the active list!
 */
static void
detect_updates(fs_edge_t *const edge)
{
	act_obj_t *act;
	struct stat fileInfo;
	int restart = 0;

	for(act = edge-&gt;active ; act != NULL ; act = act-&gt;next) {
		DBGPRINTF("detect_updates checking active obj '%s'\n", act-&gt;name);
		const int r = lstat(act-&gt;name, &amp;fileInfo);
		if(r == -1) { /* object gone away? */
			DBGPRINTF("object gone away, unlinking: '%s'\n", act-&gt;name);
			act_obj_unlink(act);
			restart = 1;
			break;
		} else if(fileInfo.st_ino != act-&gt;ino) {
			DBGPRINTF("file '%s' inode changed from %llu to %llu, unlinking from "
				"internal lists\n", act-&gt;name, (long long unsigned) act-&gt;ino,
				(long long unsigned) fileInfo.st_ino);
			if(act-&gt;pStrm != NULL) {
				/* we do no need to re-set later, as act_obj_unlink
				 * will destroy the strm obj */
				strmSet_checkRotation(act-&gt;pStrm, STRM_ROTATION_DO_NOT_CHECK);
			}
			act_obj_unlink(act);
			restart = 1;
			break;
		}

	}

	if (restart) {
		detect_updates(edge);
	}
}


/* check if active files need to be processed. This is only needed in
 * polling mode.
 */
static void ATTR_NONNULL()
poll_active_files(fs_edge_t *const edge)
{
	if(   runModConf-&gt;opMode != OPMODE_POLLING
	   || !edge-&gt;is_file
	   || glbl.GetGlobalInputTermState() != 0) {
		return;
	}

	act_obj_t *act;
	for(act = edge-&gt;active ; act != NULL ; act = act-&gt;next) {
		fen_setupWatch(act);
		DBGPRINTF("poll_active_files: polling '%s'\n", act-&gt;name);
		pollFile(act);
	}
}

static rsRetVal ATTR_NONNULL()
process_symlink(fs_edge_t *const chld, const char *symlink)
{
	DEFiRet;
	char *target;
	CHKmalloc(target = realpath(symlink, NULL));
	struct stat fileInfo;
	if(lstat(target, &amp;fileInfo) != 0) {
		LogError(errno, RS_RET_ERR,	"imfile: process_symlink: cannot stat file '%s' - ignored", target);
		FINALIZE;
	}
	const int is_file = (S_ISREG(fileInfo.st_mode));
	DBGPRINTF("process_symlink:  found '%s', File: %d (config file: %d), symlink: %d\n",
		target, is_file, chld-&gt;is_file, 0);
	if (act_obj_add(chld, target, is_file, fileInfo.st_ino, 0, symlink) == RS_RET_OK) {
		/* need to watch parent target as well for proper rotation support */
		uint idx = ustrlen(chld-&gt;active-&gt;name) - ustrlen(chld-&gt;active-&gt;basename);
		if (idx) { /* basename is different from name */
			char parent[MAXFNAME];
			idx--; /* move past trailing slash */
			memcpy(parent, chld-&gt;active-&gt;name, idx);
			parent[idx] = '\0';
			if(lstat(parent, &amp;fileInfo) != 0) {
				LogError(errno, RS_RET_ERR,
					"imfile: process_symlink: cannot stat directory '%s' - ignored", parent);
				FINALIZE;
			}
			if (chld-&gt;parent-&gt;root-&gt;edges) {
				DBGPRINTF("process_symlink: adding parent '%s' of target '%s'\n", parent, target);
				act_obj_add(chld-&gt;parent-&gt;root-&gt;edges, parent, 0, fileInfo.st_ino, 0, NULL);
			}
		}
	}

finalize_it:
	free(target);
	RETiRet;
}

static void ATTR_NONNULL()
poll_tree(fs_edge_t *const chld)
{
	struct stat fileInfo;
	glob_t files;
	int need_globfree = 0;
	int issymlink;
	DBGPRINTF("poll_tree: chld %p, name '%s', path: %s\n", chld, chld-&gt;name, chld-&gt;path);
	detect_updates(chld);
	const int ret = glob((char*)chld-&gt;path, runModConf-&gt;sortFiles|GLOB_BRACE, NULL, &amp;files);
	need_globfree = 1;
	DBGPRINTF("poll_tree: glob returned %d\n", ret);
	if(ret == 0) {
		DBGPRINTF("poll_tree: processing %d files\n", (int) files.gl_pathc);
		for(unsigned i = 0 ; i &lt; files.gl_pathc ; i++) {
			if(glbl.GetGlobalInputTermState() != 0) {
				goto done;
			}
			char *const file = files.gl_pathv[i];
			if(lstat(file, &amp;fileInfo) != 0) {
				LogError(errno, RS_RET_ERR,
					"imfile: poll_tree cannot stat file '%s' - ignored", file);
				continue;
			}

			if (S_ISLNK(fileInfo.st_mode)) {
				rsRetVal slink_ret = process_symlink(chld, file);
				if (slink_ret != RS_RET_OK) {
					continue;
				}
				issymlink = 1;
			} else {
				issymlink = 0;
			}
			const int is_file = (S_ISREG(fileInfo.st_mode) || issymlink);
			DBGPRINTF("poll_tree:  found '%s', File: %d (config file: %d), symlink: %d\n",
				file, is_file, chld-&gt;is_file, issymlink);
			if(!is_file &amp;&amp; S_ISREG(fileInfo.st_mode)) {
				LogMsg(0, RS_RET_ERR, LOG_WARNING,
					"imfile: '%s' is neither a regular file, symlink, nor a "
					"directory - ignored", file);
				continue;
			}
			if(!issymlink &amp;&amp; (chld-&gt;is_file != is_file)) {
				LogMsg(0, RS_RET_ERR, LOG_WARNING,
					"imfile: '%s' is %s but %s expected - ignored",
					file, (is_file) ? "FILE" : "DIRECTORY",
					(chld-&gt;is_file) ? "FILE" : "DIRECTORY");
				continue;
			}
			act_obj_add(chld, file, is_file, fileInfo.st_ino, issymlink, NULL);
		}
	}

	poll_active_files(chld);

done:
	if(need_globfree) {
		globfree(&amp;files);
	}
	return;
}

#ifdef HAVE_INOTIFY_INIT // TODO: shouldn't we use that in polling as well?
static void ATTR_NONNULL()
poll_timeouts(fs_edge_t *const edge)
{
	if(edge-&gt;is_file) {
		act_obj_t *act;
		for(act = edge-&gt;active ; act != NULL ; act = act-&gt;next) {
			if(act-&gt;pStrm &amp;&amp; strmReadMultiLine_isTimedOut(act-&gt;pStrm)) {
				DBGPRINTF("timeout occurred on %s\n", act-&gt;name);
				pollFile(act);
			}
		}
	}
}
#endif


/* destruct a single act_obj object */
static void
act_obj_destroy(act_obj_t *const act, const int is_deleted)
{
	uchar *statefn;
	uchar statefile[MAXFNAME];
	uchar toDel[MAXFNAME];

	if(act == NULL)
		return;

	DBGPRINTF("act_obj_destroy: act %p '%s' (source '%s'), wd %d, pStrm %p, is_deleted %d, in_move %d\n",
		act, act-&gt;name, act-&gt;source_name? act-&gt;source_name : "---", act-&gt;wd, act-&gt;pStrm, is_deleted,
		act-&gt;in_move);
	if(act-&gt;is_symlink &amp;&amp; is_deleted) {
		act_obj_t *target_act;
		for(target_act = act-&gt;edge-&gt;active ; target_act != NULL ; target_act = target_act-&gt;next) {
			if(target_act-&gt;source_name &amp;&amp; !strcmp(target_act-&gt;source_name, act-&gt;name)) {
				DBGPRINTF("act_obj_destroy: unlinking slink target %s of %s "
						"symlink\n", target_act-&gt;name, act-&gt;name);
				act_obj_unlink(target_act);
				break;
			}
		}
	}
	if(act-&gt;pStrm != NULL) {
		const instanceConf_t *const inst = act-&gt;edge-&gt;instarr[0];// TODO: same file, multiple instances?
		pollFile(act); /* get any left-over data */
		if(inst-&gt;bRMStateOnDel) {
			statefn = getStateFileName(act, statefile, sizeof(statefile));
			getFullStateFileName(statefn, act-&gt;file_id, toDel, sizeof(toDel)); // TODO: check!
			statefn = toDel;
		}
		persistStrmState(act);
		strm.Destruct(&amp;act-&gt;pStrm);
		/* we delete state file after destruct in case strm obj initiated a write */
		if(is_deleted &amp;&amp; !act-&gt;in_move &amp;&amp; inst-&gt;bRMStateOnDel) {
			DBGPRINTF("act_obj_destroy: deleting state file %s\n", statefn);
<a name="6"></a>			unlink((char*)statefn);
		}
	}
<font color="#8c8774"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>	if(act-&gt;ratelimiter != NULL) {
		ratelimitDestruct(act-&gt;ratelimiter);
	}
	#ifdef HAVE_INOTIFY_INIT
	if(act-&gt;wd != -1) {
		inotify_rm_watch(ino_fd, act-&gt;wd);
		wdmapDel(act-&gt;wd);
	}
	#endif
	if(act-&gt;fd &gt;= 0) {
		close(act-&gt;fd);
	}
	#if defined(OS_SOLARIS) &amp;&amp; defined (HAVE_PORT_SOURCE_FILE)
	if(act-&gt;pfinf != NULL) {
		free(act-&gt;pfinf-&gt;fobj.fo_name);
		free(act-&gt;pfinf);
	}
	#endif
	free(act-&gt;basename);
	free(act-&gt;source_name);
	free(act-&gt;multiSub.ppMsgs);
	#if defined(OS_SOLARIS) &amp;&amp; defined (HAVE_PORT_SOURCE_FILE)
		act-&gt;is_deleted = 1;</b></font>
	#else
		free(act-&gt;name);
		free(act);
	#endif
}


/* destroy complete act list starting at given node */
static void
act_obj_destroy_all(act_obj_t *act)
{
	if(act == NULL)
		return;

	DBGPRINTF("act_obj_destroy_all: act %p '%s', wd %d, pStrm %p\n", act, act-&gt;name, act-&gt;wd, act-&gt;pStrm);
	while(act != NULL) {
		act_obj_t *const toDel = act;
		act = act-&gt;next;
		act_obj_destroy(toDel, 0);
	}
}

#if 0
/* debug: find if ptr is still present in list */
static void
chk_active(const act_obj_t *act, const act_obj_t *const deleted)
{
	while(act != NULL) {
		DBGPRINTF("chk_active %p vs %p\n", act, deleted);
		if(act-&gt;prev == deleted)
			DBGPRINTF("chk_active %p prev points to %p\n", act, deleted);
		if(act-&gt;next == deleted)
			DBGPRINTF("chk_active %p next points to %p\n", act, deleted);
		act = act-&gt;next;
		DBGPRINTF("chk_active next %p\n", act);
	}
}
#endif

/* unlink act object from linked list and then
 * destruct it.
 */
static void ATTR_NONNULL()
act_obj_unlink(act_obj_t *act)
{
	DBGPRINTF("act_obj_unlink %p: %s, pStrm %p\n", act, act-&gt;name, act-&gt;pStrm);
	if(act-&gt;prev == NULL) {
		act-&gt;edge-&gt;active = act-&gt;next;
	} else {
		act-&gt;prev-&gt;next = act-&gt;next;
	}
	if(act-&gt;next != NULL) {
		act-&gt;next-&gt;prev = act-&gt;prev;
	}
	act_obj_destroy(act, 1);
	act = NULL;
}

static void
fs_node_destroy(fs_node_t *const node)
{
	fs_edge_t *edge;
	DBGPRINTF("node destroy: %p edges:\n", node);

	for(edge = node-&gt;edges ; edge != NULL ; ) {
		fs_node_destroy(edge-&gt;node);
		fs_edge_t *const toDel = edge;
		edge = edge-&gt;next;
		act_obj_destroy_all(toDel-&gt;active);
		free(toDel-&gt;name);
		free(toDel-&gt;path);
		free(toDel-&gt;instarr);
		free(toDel);
	}
	free(node);
}

static void ATTR_NONNULL(1, 2)
fs_node_walk(fs_node_t *const node,
	void (*f_usr)(fs_edge_t*const))
{
	DBGPRINTF("node walk: %p edges:\n", node);

	fs_edge_t *edge;
	for(edge = node-&gt;edges ; edge != NULL ; edge = edge-&gt;next) {
		DBGPRINTF("node walk: child %p '%s'\n", edge-&gt;node, edge-&gt;name);
		f_usr(edge);
		fs_node_walk(edge-&gt;node, f_usr);
	}
}



/* add a file system object to config tree (or update existing node with new monitor)
 */
static rsRetVal
fs_node_add(fs_node_t *const node,
	fs_node_t *const source,
	const uchar *const toFind,
	const size_t pathIdx,
	instanceConf_t *const inst)
{
	DEFiRet;
	fs_edge_t *newchld = NULL;
	int i;

	DBGPRINTF("fs_node_add(%p, '%s') enter, idx %zd\n",
		node, toFind+pathIdx, pathIdx);
	assert(toFind[0] != '\0');
	for(i = pathIdx ; (toFind[i] != '\0') &amp;&amp; (toFind[i] != '/') ; ++i)
		/*JUST SKIP*/;
	const int isFile = (toFind[i] == '\0') ? 1 : 0;
	uchar ourPath[PATH_MAX];
	if(i == 0) {
		ourPath[0] = '/';
		ourPath[1] = '\0';
	} else {
		memcpy(ourPath, toFind, i);
		ourPath[i] = '\0';
	}
	const size_t nextPathIdx = i+1;
	const size_t len = i - pathIdx;
	uchar name[PATH_MAX];
	memcpy(name, toFind+pathIdx, len);
	name[len] = '\0';
	DBGPRINTF("fs_node_add: name '%s'\n", name);
	node-&gt;root = source;

	fs_edge_t *chld;
	for(chld = node-&gt;edges ; chld != NULL ; chld = chld-&gt;next) {
		if(!ustrcmp(chld-&gt;name, name)) {
			DBGPRINTF("fs_node_add(%p, '%s') found '%s'\n", chld-&gt;node, toFind, name);
			/* add new instance */
			instanceConf_t **instarr_new = realloc(chld-&gt;instarr,
							sizeof(instanceConf_t*) * (chld-&gt;ninst+1));
			CHKmalloc(instarr_new);
			chld-&gt;instarr = instarr_new;
			chld-&gt;ninst++;
			chld-&gt;instarr[chld-&gt;ninst-1] = inst;
			/* recurse */
			if(!isFile) {
				CHKiRet(fs_node_add(chld-&gt;node, node, toFind, nextPathIdx, inst));
			}
			FINALIZE;
		}
	}

	/* could not find node --&gt; add it */
	DBGPRINTF("fs_node_add(%p, '%s') did not find '%s' - adding it\n",
		node, toFind, name);
	CHKmalloc(newchld = calloc(sizeof(fs_edge_t), 1));
	CHKmalloc(newchld-&gt;name = ustrdup(name));
	CHKmalloc(newchld-&gt;node = calloc(sizeof(fs_node_t), 1));
	CHKmalloc(newchld-&gt;path = ustrdup(ourPath));
	CHKmalloc(newchld-&gt;instarr = calloc(sizeof(instanceConf_t*), 1));
	newchld-&gt;instarr[0] = inst;
	newchld-&gt;is_file = isFile;
	newchld-&gt;ninst = 1;
	newchld-&gt;parent = node;

	DBGPRINTF("fs_node_add(%p, '%s') returns %p\n", node, toFind, newchld-&gt;node);

	if(!isFile) {
		CHKiRet(fs_node_add(newchld-&gt;node, node, toFind, nextPathIdx, inst));
	}

	/* link to list */
	newchld-&gt;next = node-&gt;edges;
	node-&gt;edges = newchld;
finalize_it:
	if(iRet != RS_RET_OK) {
		if(newchld != NULL) {
		free(newchld-&gt;name);
		free(newchld-&gt;node);
		free(newchld-&gt;path);
		free(newchld-&gt;instarr);
		free(newchld);
		}
	}
	RETiRet;
}


/* Helper function to combine statefile and state file directory
 * This function is guranteed to work only on config data and DOES NOT
 * open or otherwise modify disk file state.
 */
static int ATTR_NONNULL()
getFullStateFileName(const uchar *const pszstatefile,
	const char *const file_id,
	uchar *const pszout,
	const size_t ilenout)
{
	int lenout;
	const uchar* pszstatedir;

	/* Get Raw Workdir, if it is NULL we need to propper handle it */
	pszstatedir = getStateFileDir();

	/* Construct file name */
	lenout = snprintf((char*)pszout, ilenout, "%s/%s%s%s",
		(char*) (pszstatedir == NULL ? "." : (char*) pszstatedir), (char*)pszstatefile,
		(*file_id == '\0') ? "" : ":", file_id);

	/* return out length */
	return lenout;
}


/* hash function for file-id
 * Takes a block of data and returns a string with the hash value.
 *
 * Currently one provided by Aaaron Wiebe based on perl's hashing algorithm
 * (so probably pretty generic). Not for excessively large strings!
 * TODO: re-think the hash function!
 */
#if defined(__clang__)
#pragma GCC diagnostic ignored "-Wunknown-attributes"
#endif
static void __attribute__((nonnull(1,3)))
#if defined(__clang__)
__attribute__((no_sanitize("unsigned-integer-overflow")))
#endif
get_file_id_hash(const char *data, size_t lendata,
	char *const hash_str, const size_t len_hash_str)
{
	assert(len_hash_str &gt;= 17); /* we always generate 8-byte strings */

	size_t i;
	uint8_t out[8], k[16];
	for (i = 0; i &lt; 16; ++i)
		k[i] = i;
	memset(out, 0, sizeof(out));
	rs_siphash((const uint8_t *)data, lendata, k, out, 8);

	for(i = 0 ; i &lt; 8 ; ++i) {
		if(2 * i+1 &gt;= len_hash_str)
			break;
		snprintf(hash_str+(2*i), 3, "%2.2x", out[i]);
	}
}


/* this returns the file-id for a given file
 */
static void ATTR_NONNULL(1)
getFileID(act_obj_t *const act)
{
	char tmp_id[FILE_ID_HASH_SIZE];
	strncpy(tmp_id, (const char*)act-&gt;file_id, FILE_ID_HASH_SIZE);
	act-&gt;file_id[0] = '\0';
	assert(act-&gt;fd &gt;= 0); /* fd must have been opened at act_obj_t creation! */
	char filedata[FILE_ID_SIZE];
	lseek(act-&gt;fd, 0, SEEK_SET); /* Seek to beginning of file so we have correct id */
	const int r = read(act-&gt;fd, filedata, FILE_ID_SIZE);
	if(r == FILE_ID_SIZE) {
		get_file_id_hash(filedata, sizeof(filedata), act-&gt;file_id, sizeof(act-&gt;file_id));
	} else {
		DBGPRINTF("getFileID partial or error read, ret %d\n", r);
	}
	if (strncmp(tmp_id, act-&gt;file_id, FILE_ID_HASH_SIZE)) {/* save the old id for cleaning purposes */
		strncpy(act-&gt;file_id_prev, tmp_id, FILE_ID_HASH_SIZE);
	}
	DBGPRINTF("getFileID for '%s', file_id_hash '%s'\n", act-&gt;name, act-&gt;file_id);
}

/* this generates a state file name suitable for the given file. To avoid
 * malloc calls, it must be passed a buffer which should be MAXFNAME large.
 * Note: the buffer is not necessarily populated ... always ONLY use the
 * RETURN VALUE!
 * This function is guranteed to work only on config data and DOES NOT
 * open or otherwise modify disk file state.
 */
static uchar * ATTR_NONNULL(1, 2)
getStateFileName(const act_obj_t *const act,
	 	 uchar *const __restrict__ buf,
		 const size_t lenbuf)
{
	DBGPRINTF("getStateFileName for '%s'\n", act-&gt;name);
	snprintf((char*)buf, lenbuf - 1, "imfile-state:%lld", (long long) act-&gt;ino);
	DBGPRINTF("getStateFileName:  state file name now is %s\n", buf);
	return buf;
}

static rsRetVal
checkPerMinuteRateLimits(per_minute_rate_limit_t *per_minute_rate_limits,
			     const size_t msgLen)
{
	DEFiRet;
	time_t current_minute = time(NULL)/60;
	if(per_minute_rate_limits-&gt;maxBytesPerMinute) {
		if (per_minute_rate_limits-&gt;rateLimitingMinute == current_minute) {
			per_minute_rate_limits-&gt;bytesThisMinute += msgLen;
			/* if we would breach our rate limit then do not send the message. */
			if (per_minute_rate_limits-&gt;bytesThisMinute &gt; per_minute_rate_limits-&gt;maxBytesPerMinute) {
				ABORT_FINALIZE(RS_RET_RATE_LIMITED);
			}
		} else {
			per_minute_rate_limits-&gt;rateLimitingMinute = current_minute;
			per_minute_rate_limits-&gt;bytesThisMinute = msgLen; /* Update count as message will be sent */
		}
	}
	if(per_minute_rate_limits-&gt;maxLinesPerMinute) {
		if (per_minute_rate_limits-&gt;rateLimitingMinute == current_minute) {
			per_minute_rate_limits-&gt;linesThisMinute++;
			/* if we would breach our rate limit then do not send the message. */
			if (per_minute_rate_limits-&gt;linesThisMinute &gt; per_minute_rate_limits-&gt;maxLinesPerMinute) {
				ABORT_FINALIZE(RS_RET_RATE_LIMITED);
			}
		} else {
			per_minute_rate_limits-&gt;rateLimitingMinute = current_minute;
			per_minute_rate_limits-&gt;linesThisMinute = 1; /* Update count as message will be sent */
		}
	}
finalize_it:
	RETiRet;
}

/* enqueue the read file line as a message. The provided string is
 * not freed - this must be done by the caller.
 */
#define MAX_OFFSET_REPRESENTATION_NUM_BYTES 20
static rsRetVal ATTR_NONNULL(1,2)
enqLine(act_obj_t *const act,
	cstr_t *const __restrict__ cstrLine,
	const int64 strtOffs)
{
	DEFiRet;
	const instanceConf_t *const inst = act-&gt;edge-&gt;instarr[0];// TODO: same file, multiple instances?
	smsg_t *pMsg;
	uchar file_offset[MAX_OFFSET_REPRESENTATION_NUM_BYTES+1];
	const uchar *metadata_names[2] = {(uchar *)"filename",(uchar *)"fileoffset"} ;
	const uchar *metadata_values[2] ;
	const size_t msgLen = cstrLen(cstrLine);

	if(msgLen == 0) {
		/* we do not process empty lines */
		FINALIZE;
	}

	CHKiRet(msgConstruct(&amp;pMsg));
	MsgSetFlowControlType(pMsg, eFLOWCTL_FULL_DELAY);
	MsgSetInputName(pMsg, pInputName);
	if(inst-&gt;addCeeTag) {
		/* Make sure we account for terminating null byte */
		size_t ceeMsgSize = msgLen + CONST_LEN_CEE_COOKIE + 1;
		char *ceeMsg;
		CHKmalloc(ceeMsg = malloc(ceeMsgSize));
		strcpy(ceeMsg, CONST_CEE_COOKIE);
		strcat(ceeMsg, (char*)rsCStrGetSzStrNoNULL(cstrLine));
		MsgSetRawMsg(pMsg, ceeMsg, ceeMsgSize);
		free(ceeMsg);
	} else {
		MsgSetRawMsg(pMsg, (char*)rsCStrGetSzStrNoNULL(cstrLine), msgLen);
	}
	MsgSetMSGoffs(pMsg, 0);	/* we do not have a header... */
	MsgSetHOSTNAME(pMsg, glbl.GetLocalHostName(), ustrlen(glbl.GetLocalHostName()));
	MsgSetTAG(pMsg, inst-&gt;pszTag, inst-&gt;lenTag);
	msgSetPRI(pMsg, inst-&gt;iFacility | inst-&gt;iSeverity);
	MsgSetRuleset(pMsg, inst-&gt;pBindRuleset);
	if(inst-&gt;addMetadata) {
		if (act-&gt;source_name) {
			metadata_values[0] = (const uchar*)act-&gt;source_name;
		} else {
			metadata_values[0] = (const uchar*)act-&gt;name;
		}
		snprintf((char *)file_offset, MAX_OFFSET_REPRESENTATION_NUM_BYTES+1, "%lld", strtOffs);
		metadata_values[1] = file_offset;
		msgAddMultiMetadata(pMsg, metadata_names, metadata_values, 2);
	}

	if(inst-&gt;perMinuteRateLimits.maxBytesPerMinute || inst-&gt;perMinuteRateLimits.maxLinesPerMinute) {
		CHKiRet(checkPerMinuteRateLimits((per_minute_rate_limit_t *)&amp;inst-&gt;perMinuteRateLimits, msgLen));
	}

	if(inst-&gt;delay_perMsg) {
		srSleep(inst-&gt;delay_perMsg % 1000000, inst-&gt;delay_perMsg / 1000000);
	}

	pMsg-&gt;msgFlags = pMsg-&gt;msgFlags | inst-&gt;msgFlag;

	ratelimitAddMsg(act-&gt;ratelimiter, &amp;act-&gt;multiSub, pMsg);
finalize_it:
	RETiRet;
}
/* try to open a file which has a state file. If the state file does not
 * exist or cannot be read, an error is returned.
 */
static rsRetVal ATTR_NONNULL(1)
openFileWithStateFile(act_obj_t *const act)
{
	DEFiRet;
	uchar pszSFNam[MAXFNAME];
	uchar statefile[MAXFNAME];
	int fd = -1;
	const instanceConf_t *const inst = act-&gt;edge-&gt;instarr[0];// TODO: same file, multiple instances?

	uchar *const statefn = getStateFileName(act, statefile, sizeof(statefile));
	getFileID(act);

	getFullStateFileName(statefn, act-&gt;file_id, pszSFNam, sizeof(pszSFNam));
	DBGPRINTF("trying to open state for '%s', state file '%s'\n", act-&gt;name, pszSFNam);

	/* check if the file exists */
	fd = open((char*)pszSFNam, O_CLOEXEC | O_NOCTTY | O_RDONLY, 0600);
	if(fd &lt; 0) {
		if(errno == ENOENT) {
			if(act-&gt;file_id[0] != '\0') {
				DBGPRINTF("state file %s for %s does not exist - trying to see if "
					"inode-only file exists\n", pszSFNam, act-&gt;name);
				getFullStateFileName(statefn, "", pszSFNam, sizeof(pszSFNam));
				fd = open((char*)pszSFNam, O_CLOEXEC | O_NOCTTY | O_RDONLY, 0600);
				if(fd &gt;= 0) {
					dbgprintf("found inode-only state file, will be renamed at next persist\n");
				}
			}
			if(fd &lt; 0) {
				DBGPRINTF("state file %s for %s does not exist - trying to see if "
					"old-style file exists\n", pszSFNam, act-&gt;name);
				CHKiRet(OLD_openFileWithStateFile(act));
				FINALIZE;
			}
		} else {
			LogError(errno, RS_RET_IO_ERROR,
				"imfile error trying to access state file for '%s'",
			        act-&gt;name);
			ABORT_FINALIZE(RS_RET_IO_ERROR);
		}
	}

	DBGPRINTF("opened state file %s for %s\n", pszSFNam, act-&gt;name);
	CHKiRet(strm.Construct(&amp;act-&gt;pStrm));

	struct json_object *jval;
	struct json_object *json = fjson_object_from_fd(fd);
	if(json == NULL) {
		LogError(0, RS_RET_ERR, "imfile: error reading state file for '%s'", act-&gt;name);
	}

	/* we access some data items a bit dirty, as we need to refactor the whole
	 * thing in any case - TODO
	 */
	/* Note: we ignore filname property - it is just an aid to the user. Most
	 * importantly it *is wrong* after a file move!
	 */
	fjson_object_object_get_ex(json, "prev_was_nl", &amp;jval);
	act-&gt;pStrm-&gt;bPrevWasNL = fjson_object_get_int(jval);

	fjson_object_object_get_ex(json, "curr_offs", &amp;jval);
	act-&gt;pStrm-&gt;iCurrOffs = fjson_object_get_int64(jval);

	fjson_object_object_get_ex(json, "strt_offs", &amp;jval);
	act-&gt;pStrm-&gt;strtOffs = fjson_object_get_int64(jval);

	fjson_object_object_get_ex(json, "prev_line_segment", &amp;jval);
	const uchar *const prev_line_segment = (const uchar*)fjson_object_get_string(jval);
	if(jval != NULL) {
		CHKiRet(rsCStrConstructFromszStr(&amp;act-&gt;pStrm-&gt;prevLineSegment, prev_line_segment));
		cstrFinalize(act-&gt;pStrm-&gt;prevLineSegment);
		uchar *ret = rsCStrGetSzStrNoNULL(act-&gt;pStrm-&gt;prevLineSegment);
		DBGPRINTF("prev_line_segment present in state file 2, is: %s\n", ret);
	}

	fjson_object_object_get_ex(json, "prev_msg_segment", &amp;jval);
	const uchar *const prev_msg_segment = (const uchar*)fjson_object_get_string(jval);
	if(jval != NULL) {
		CHKiRet(rsCStrConstructFromszStr(&amp;act-&gt;pStrm-&gt;prevMsgSegment, prev_msg_segment));
		cstrFinalize(act-&gt;pStrm-&gt;prevMsgSegment);
		uchar *ret = rsCStrGetSzStrNoNULL(act-&gt;pStrm-&gt;prevMsgSegment);
		DBGPRINTF("prev_msg_segment present in state file 2, is: %s\n", ret);
	}
	fjson_object_put(json);

	CHKiRet(strm.SetFName(act-&gt;pStrm, (uchar*)act-&gt;name, strlen(act-&gt;name)));
	CHKiRet(strm.SettOperationsMode(act-&gt;pStrm, STREAMMODE_READ));
	CHKiRet(strm.SetsType(act-&gt;pStrm, STREAMTYPE_FILE_MONITOR));
	CHKiRet(strm.SetFileNotFoundError(act-&gt;pStrm, inst-&gt;fileNotFoundError));
	CHKiRet(strm.ConstructFinalize(act-&gt;pStrm));

	CHKiRet(strm.SeekCurrOffs(act-&gt;pStrm));

finalize_it:
	if(fd &gt;= 0) {
		close(fd);
	}
	RETiRet;
}

/* try to open a file for which no state file exists. This function does NOT
 * check if a state file actually exists or not -- this must have been
 * checked before calling it.
 */
static rsRetVal
openFileWithoutStateFile(act_obj_t *const act)
{
	DEFiRet;
	const instanceConf_t *const inst = act-&gt;edge-&gt;instarr[0];// TODO: same file, multiple instances?

	DBGPRINTF("clean startup withOUT state file for '%s'\n", act-&gt;name);
	if(act-&gt;pStrm != NULL)
		strm.Destruct(&amp;act-&gt;pStrm);
	CHKiRet(strm.Construct(&amp;act-&gt;pStrm));
	CHKiRet(strm.SettOperationsMode(act-&gt;pStrm, STREAMMODE_READ));
	CHKiRet(strm.SetsType(act-&gt;pStrm, STREAMTYPE_FILE_MONITOR));
	CHKiRet(strm.SetFName(act-&gt;pStrm, (uchar*)act-&gt;name, strlen(act-&gt;name)));
	CHKiRet(strm.SetFileNotFoundError(act-&gt;pStrm, inst-&gt;fileNotFoundError));
	CHKiRet(strm.ConstructFinalize(act-&gt;pStrm));

	/* As a state file not exist, this is a fresh start. seek to file end
	 * when freshStartTail is on.
	 */
	if(inst-&gt;freshStartTail) {
		const int fd = open(act-&gt;name, O_RDONLY | O_CLOEXEC);
		if(fd &gt;= 0) {
			act-&gt;pStrm-&gt;iCurrOffs = lseek64(fd, 0, SEEK_END);
			close(fd);
			if(act-&gt;pStrm-&gt;iCurrOffs &lt; 0) {
				act-&gt;pStrm-&gt;iCurrOffs = 0;
				LogError(errno, RS_RET_ERR, "imfile: could not query current "
					"file size for %s - 'freshStartTail' option will "
					"be ignored, starting at begin of file", inst-&gt;pszFileName);
			}
			CHKiRet(strm.SeekCurrOffs(act-&gt;pStrm));
		}
	}

finalize_it:
	RETiRet;
}

/* try to open a file. This involves checking if there is a status file and,
 * if so, reading it in. Processing continues from the last known location.
 */
static rsRetVal
openFile(act_obj_t *const act)
{
	DEFiRet;
	const instanceConf_t *const inst = act-&gt;edge-&gt;instarr[0];// TODO: same file, multiple instances?

	CHKiRet_Hdlr(openFileWithStateFile(act)) {
		CHKiRet(openFileWithoutStateFile(act));
	}

	DBGPRINTF("breopenOnTruncate %d for '%s'\n", inst-&gt;reopenOnTruncate, act-&gt;name);
	CHKiRet(strm.SetbReopenOnTruncate(act-&gt;pStrm, inst-&gt;reopenOnTruncate));
	strmSetReadTimeout(act-&gt;pStrm, inst-&gt;readTimeout);

finalize_it:
	RETiRet;
}


/* The following is a cancel cleanup handler for strmReadLine(). It is necessary in case
 * strmReadLine() is cancelled while processing the stream. -- rgerhards, 2008-03-27
 */
static void pollFileCancelCleanup(void *pArg)
{
	cstr_t **ppCStr = (cstr_t**) pArg;
	if(*ppCStr != NULL)
		rsCStrDestruct(ppCStr);
}


/* pollFile needs to be split due to the unfortunate pthread_cancel_push() macros. */
static rsRetVal ATTR_NONNULL()
pollFileReal(act_obj_t *act, cstr_t **pCStr)
{
	int64 strtOffs;
	DEFiRet;
	int64_t startOffs = 0;
	int nProcessed = 0;
	regex_t *start_preg = NULL, *end_preg = NULL;

	DBGPRINTF("pollFileReal enter, act %p, pStrm %p, name '%s'\n", act, act-&gt;pStrm, act-&gt;name);
	DBGPRINTF("pollFileReal enter, edge %p\n", act-&gt;edge);
	DBGPRINTF("pollFileReal enter, edge-&gt;instarr %p\n", act-&gt;edge-&gt;instarr);

	instanceConf_t *const inst = act-&gt;edge-&gt;instarr[0];// TODO: same file, multiple instances?

	if(act-&gt;pStrm == NULL) {
		CHKiRet(openFile(act)); /* open file */
	}

	start_preg = (inst-&gt;startRegex == NULL) ? NULL : &amp;inst-&gt;start_preg;
	end_preg = (inst-&gt;endRegex == NULL) ? NULL : &amp;inst-&gt;end_preg;

	startOffs = act-&gt;pStrm-&gt;iCurrOffs;
	/* loop below will be exited when strmReadLine() returns EOF */
	while(glbl.GetGlobalInputTermState() == 0) {
		if(inst-&gt;maxLinesAtOnce != 0 &amp;&amp; nProcessed &gt;= inst-&gt;maxLinesAtOnce)
			break;
		if((start_preg == NULL) &amp;&amp; (end_preg == NULL)) {
			CHKiRet(strm.ReadLine(act-&gt;pStrm, pCStr, inst-&gt;readMode, inst-&gt;escapeLF, inst-&gt;escapeLFString,
				inst-&gt;trimLineOverBytes, &amp;strtOffs));
		} else {
			CHKiRet(strmReadMultiLine(act-&gt;pStrm, pCStr, start_preg, end_preg,
				inst-&gt;escapeLF, inst-&gt;escapeLFString, inst-&gt;discardTruncatedMsg,
				inst-&gt;msgDiscardingError, &amp;strtOffs));
		}
		++nProcessed;
		if(startOffs &lt; FILE_ID_SIZE &amp;&amp; act-&gt;pStrm-&gt;iCurrOffs &gt;= FILE_ID_SIZE) {
			dbgprintf("initiating state file write as sufficient data is now present; file=%s\n",
				act-&gt;name);
			persistStrmState(act);
			startOffs = act-&gt;pStrm-&gt;iCurrOffs; /* disable check */
		}
		runModConf-&gt;bHadFileData = 1; /* this is just a flag, so set it and forget it */
		CHKiRet(enqLine(act, *pCStr, strtOffs)); /* process line */
		rsCStrDestruct(pCStr); /* discard string (must be done by us!) */
		if(inst-&gt;iPersistStateInterval &gt; 0 &amp;&amp; ++act-&gt;nRecords &gt;= inst-&gt;iPersistStateInterval) {
			persistStrmState(act);
			act-&gt;nRecords = 0;
		}
	}

finalize_it:
	multiSubmitFlush(&amp;act-&gt;multiSub);
	if(inst-&gt;bPersistStateAfterSubmission) {
		persistStrmState(act);
	}

	if(*pCStr != NULL) {
		rsCStrDestruct(pCStr);
	}

	RETiRet;
}

/* poll a file, need to check file rollover etc. open file if not open */
static rsRetVal ATTR_NONNULL(1)
pollFile(act_obj_t *const act)
{
	cstr_t *pCStr = NULL;
	DEFiRet;
	if (act-&gt;is_symlink) {
		FINALIZE;    /* no reason to poll symlink file */
	}
	/* Note: we must do pthread_cleanup_push() immediately, because the POSIX macros
	 * otherwise do not work if I include the _cleanup_pop() inside an if... -- rgerhards, 2008-08-14
	 */
	pthread_cleanup_push(pollFileCancelCleanup, &amp;pCStr);
	iRet = pollFileReal(act, &amp;pCStr);
	pthread_cleanup_pop(0);
finalize_it: RETiRet;
}


/* create input instance, set default parameters, and
 * add it to the list of instances.
 */
static rsRetVal ATTR_NONNULL(1)
createInstance(instanceConf_t **const pinst)
{
	instanceConf_t *inst;
	DEFiRet;
	CHKmalloc(inst = malloc(sizeof(instanceConf_t)));
	inst-&gt;next = NULL;
	inst-&gt;pBindRuleset = NULL;

	inst-&gt;pszBindRuleset = NULL;
	inst-&gt;pszFileName = NULL;
	inst-&gt;pszTag = NULL;
	inst-&gt;pszStateFile = NULL;
	inst-&gt;nMultiSub = NUM_MULTISUB;
	inst-&gt;iSeverity = 5;
	inst-&gt;iFacility = 128;
	inst-&gt;maxLinesAtOnce = 0;
	inst-&gt;trimLineOverBytes = 0;
	inst-&gt;iPersistStateInterval = 0;
	inst-&gt;perMinuteRateLimits.maxBytesPerMinute = 0;
	inst-&gt;perMinuteRateLimits.maxLinesPerMinute = 0;
	inst-&gt;perMinuteRateLimits.rateLimitingMinute = 0;
	inst-&gt;perMinuteRateLimits.linesThisMinute = 0;
	inst-&gt;perMinuteRateLimits.bytesThisMinute = 0;
	inst-&gt;bPersistStateAfterSubmission = 0;
	inst-&gt;readMode = 0;
	inst-&gt;startRegex = NULL;
	inst-&gt;endRegex = NULL;
	inst-&gt;discardTruncatedMsg = 0;
	inst-&gt;msgDiscardingError = 1;
	inst-&gt;bRMStateOnDel = 1;
	inst-&gt;escapeLF = 1;
	inst-&gt;escapeLFString = NULL;
	inst-&gt;reopenOnTruncate = 0;
	inst-&gt;addMetadata = ADD_METADATA_UNSPECIFIED;
	inst-&gt;addCeeTag = 0;
	inst-&gt;freshStartTail = 0;
	inst-&gt;fileNotFoundError = 1;
	inst-&gt;readTimeout = loadModConf-&gt;readTimeout;
	inst-&gt;delay_perMsg = 0;
	inst-&gt;msgFlag = 0;
<a name="4"></a>	inst-&gt;ignoreOlderThan = 0;

	/* node created, let's add to config */
<font color="#6cc417"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>	if(loadModConf-&gt;tail == NULL) {
		loadModConf-&gt;tail = loadModConf-&gt;root = inst;
	} else {
		loadModConf-&gt;tail-&gt;next = inst;
		loadModConf-&gt;tail = inst;
	}

	*pinst = inst;
finalize_it:
	RETiRet;
}


/* the basen(ame) buffer must be of size MAXFNAME
 * returns the index of the slash in front of basename
 */
static int ATTR_NONNULL()</b></font>
getBasename(uchar *const __restrict__ basen, uchar *const __restrict__ path)
{
	int i;
	int found = 0;
	const int lenName = ustrlen(path);
	for(i = lenName ; i &gt;= 0 ; --i) {
		if(path[i] == '/') {
			/* found basename component */
			found = 1;
			if(i == lenName)
				basen[0] = '\0';
			else {
				memcpy(basen, path+i+1, lenName-i);
			}
			break;
		}
	}
	if (found == 1)
		return i;
	else {
		return -1;
	}
}

/* this function checks instance parameters and does some required pre-processing
 */
static rsRetVal ATTR_NONNULL()
checkInstance(instanceConf_t *const inst)
{
	uchar curr_wd[MAXFNAME];
	DEFiRet;

	/* this is primarily for the clang static analyzer, but also
	 * guards against logic errors in the config handler.
	 */
	if(inst-&gt;pszFileName == NULL)
		ABORT_FINALIZE(RS_RET_INTERNAL_ERROR);

	CHKmalloc(inst-&gt;pszFileName_forOldStateFile = ustrdup(inst-&gt;pszFileName));
	if(loadModConf-&gt;normalizePath) {
		if(inst-&gt;pszFileName[0] == '.' &amp;&amp; inst-&gt;pszFileName[1] == '/') {
			DBGPRINTF("imfile: removing heading './' from name '%s'\n", inst-&gt;pszFileName);
			memmove(inst-&gt;pszFileName, inst-&gt;pszFileName+2, ustrlen(inst-&gt;pszFileName) - 1);
		}

		if(inst-&gt;pszFileName[0] != '/') {
			if(getcwd((char*)curr_wd, MAXFNAME) == NULL || curr_wd[0] != '/') {
				LogError(errno, RS_RET_ERR, "imfile: error querying current working "
					"directory - can not continue with %s", inst-&gt;pszFileName);
				ABORT_FINALIZE(RS_RET_ERR);
			}
			const size_t len_curr_wd = ustrlen(curr_wd);
			if(len_curr_wd + ustrlen(inst-&gt;pszFileName) + 1 &gt;= MAXFNAME) {
				LogError(0, RS_RET_ERR, "imfile: length of configured file and current "
					"working directory exceeds permitted size - ignoring %s",
					inst-&gt;pszFileName);
				ABORT_FINALIZE(RS_RET_ERR);
			}
			curr_wd[len_curr_wd] = '/';
			strcpy((char*)curr_wd+len_curr_wd+1, (char*)inst-&gt;pszFileName);
			free(inst-&gt;pszFileName);
			CHKmalloc(inst-&gt;pszFileName = ustrdup(curr_wd));
		}
	}
	dbgprintf("imfile: adding file monitor for '%s'\n", inst-&gt;pszFileName);

	if(inst-&gt;pszTag != NULL) {
		inst-&gt;lenTag = ustrlen(inst-&gt;pszTag);
	}
finalize_it:
	RETiRet;
}


/* add a new monitor */
static rsRetVal
addInstance(void __attribute__((unused)) *pVal, uchar *pNewVal)
{
	instanceConf_t *inst;
	DEFiRet;

	if(cs.pszFileName == NULL) {
		LogError(0, RS_RET_CONFIG_ERROR, "imfile error: no file name given, file monitor can "
					"not be created");
		ABORT_FINALIZE(RS_RET_CONFIG_ERROR);
	}
	if(cs.pszFileTag == NULL) {
		LogError(0, RS_RET_CONFIG_ERROR, "imfile error: no tag value given, file monitor can "
					"not be created");
		ABORT_FINALIZE(RS_RET_CONFIG_ERROR);
	}

	CHKiRet(createInstance(&amp;inst));
	if((cs.pszBindRuleset == NULL) || (cs.pszBindRuleset[0] == '\0')) {
		inst-&gt;pszBindRuleset = NULL;
	} else {
		CHKmalloc(inst-&gt;pszBindRuleset = ustrdup(cs.pszBindRuleset));
	}
	CHKmalloc(inst-&gt;pszFileName = ustrdup((char*) cs.pszFileName));
	CHKmalloc(inst-&gt;pszTag = ustrdup((char*) cs.pszFileTag));
	if(cs.pszStateFile == NULL) {
		inst-&gt;pszStateFile = NULL;
	} else {
		CHKmalloc(inst-&gt;pszStateFile = ustrdup(cs.pszStateFile));
	}
	inst-&gt;iSeverity = cs.iSeverity;
	inst-&gt;iFacility = cs.iFacility;
	if(cs.maxLinesAtOnce) {
		if(loadModConf-&gt;opMode == OPMODE_INOTIFY) {
			LogError(0, RS_RET_PARAM_NOT_PERMITTED,
				"parameter \"maxLinesAtOnce\" not "
				"permited in inotify mode - ignored");
		} else {
			inst-&gt;maxLinesAtOnce = cs.maxLinesAtOnce;
		}
	}
	inst-&gt;trimLineOverBytes = cs.trimLineOverBytes;
	inst-&gt;ignoreOlderThan = 0;
	inst-&gt;iPersistStateInterval = cs.iPersistStateInterval;
	inst-&gt;perMinuteRateLimits.maxBytesPerMinute = cs.maxBytesPerMinute;
	inst-&gt;perMinuteRateLimits.maxLinesPerMinute = cs.maxLinesPerMinute;
	inst-&gt;bPersistStateAfterSubmission = 0;
	inst-&gt;readMode = cs.readMode;
	inst-&gt;escapeLF = 0;
	inst-&gt;escapeLFString = NULL;
	inst-&gt;reopenOnTruncate = 0;
	inst-&gt;addMetadata = 0;
	inst-&gt;addCeeTag = 0;
	inst-&gt;bRMStateOnDel = 0;
	inst-&gt;readTimeout = loadModConf-&gt;readTimeout;
	inst-&gt;msgFlag = 0;

	CHKiRet(checkInstance(inst));

	/* reset legacy system */
	cs.iPersistStateInterval = 0;
	resetConfigVariables(NULL, NULL); /* values are both dummies */

finalize_it:
	free(pNewVal); /* we do not need it, but we must free it! */
	RETiRet;
}


BEGINnewInpInst
	struct cnfparamvals *pvals;
	instanceConf_t *inst;
	int i;
CODESTARTnewInpInst
<a name="1"></a>	DBGPRINTF("newInpInst (imfile)\n");

	pvals = nvlstGetParams(lst, &amp;inppblk, NULL);
<font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>	if(pvals == NULL) {
		ABORT_FINALIZE(RS_RET_MISSING_CNFPARAMS);
	}

	if(Debug) {
		DBGPRINTF("input param blk in imfile:\n");
		cnfparamsPrint(&amp;inppblk, pvals);
	}

	CHKiRet(createInstance(&amp;inst));

	for(i = 0 ; i &lt; inppblk.nParams ; ++i) {
		if(!pvals[i].bUsed)
			continue;
		if(!strcmp(inppblk.descr[i].name, "file")) {
			inst-&gt;pszFileName = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
		} else if(!strcmp(inppblk.descr[i].name, "statefile")) {
			inst-&gt;pszStateFile = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
		} else if(!strcmp(inppblk.descr[i].name, "removestateondelete")) {
<a name="2"></a>			inst-&gt;bRMStateOnDel = (uint8_t) pvals[i].val.d.n; // TODO: duplicate!</b></font>
		} else if(!strcmp(inppblk.descr[i].name, "tag")) {
			inst-&gt;pszTag = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
<font color="#980517"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>		} else if(!strcmp(inppblk.descr[i].name, "ruleset")) {
			inst-&gt;pszBindRuleset = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
		} else if(!strcmp(inppblk.descr[i].name, "severity")) {
			inst-&gt;iSeverity = pvals[i].val.d.n;
		} else if(!strcmp(inppblk.descr[i].name, "facility")) {
<a name="5"></a>			inst-&gt;iFacility = pvals[i].val.d.n;</b></font>
		} else if(!strcmp(inppblk.descr[i].name, "readmode")) {
			inst-&gt;readMode = (sbool) pvals[i].val.d.n;
<font color="#151b8d"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>		} else if(!strcmp(inppblk.descr[i].name, "startmsg.regex")) {
			inst-&gt;startRegex = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
		} else if(!strcmp(inppblk.descr[i].name, "endmsg.regex")) {
			inst-&gt;endRegex = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
		} else if(!strcmp(inppblk.descr[i].name, "discardtruncatedmsg")) {</b></font>
			inst-&gt;discardTruncatedMsg = (sbool) pvals[i].val.d.n;
		} else if(!strcmp(inppblk.descr[i].name, "msgdiscardingerror")) {
			inst-&gt;msgDiscardingError = (sbool) pvals[i].val.d.n;
		} else if(!strcmp(inppblk.descr[i].name, "deletestateonfiledelete")) {
			inst-&gt;bRMStateOnDel = (sbool) pvals[i].val.d.n; // TODO: duplicate!
		} else if(!strcmp(inppblk.descr[i].name, "addmetadata")) {
			inst-&gt;addMetadata = (sbool) pvals[i].val.d.n;
		} else if(!strcmp(inppblk.descr[i].name, "delay.message")) {
			inst-&gt;delay_perMsg = (unsigned) pvals[i].val.d.n;
		} else if (!strcmp(inppblk.descr[i].name, "addceetag")) {
			inst-&gt;addCeeTag = (sbool) pvals[i].val.d.n;
		} else if(!strcmp(inppblk.descr[i].name, "freshstarttail")) {
			inst-&gt;freshStartTail = (sbool) pvals[i].val.d.n;
		} else if(!strcmp(inppblk.descr[i].name, "filenotfounderror")) {
			inst-&gt;fileNotFoundError = (sbool) pvals[i].val.d.n;
		} else if(!strcmp(inppblk.descr[i].name, "escapelf")) {
			inst-&gt;escapeLF = (sbool) pvals[i].val.d.n;
		} else if(!strcmp(inppblk.descr[i].name, "escapelf.replacement")) {
			inst-&gt;escapeLFString = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
		} else if(!strcmp(inppblk.descr[i].name, "reopenontruncate")) {
			inst-&gt;reopenOnTruncate = (sbool) pvals[i].val.d.n;
		} else if(!strcmp(inppblk.descr[i].name, "maxlinesatonce")) {
			if(   loadModConf-&gt;opMode == OPMODE_INOTIFY
			   &amp;&amp; pvals[i].val.d.n &gt; 0) {
				LogError(0, RS_RET_PARAM_NOT_PERMITTED,
					"parameter \"maxLinesAtOnce\" not "
					"permited in inotify mode - ignored");
			} else {
				inst-&gt;maxLinesAtOnce = pvals[i].val.d.n;
			}
		} else if(!strcmp(inppblk.descr[i].name, "trimlineoverbytes")) {
			inst-&gt;trimLineOverBytes = pvals[i].val.d.n;
		} else if(!strcmp(inppblk.descr[i].name, "ignoreolderthan")) {
			inst-&gt;ignoreOlderThan = pvals[i].val.d.n;
		} else if(!strcmp(inppblk.descr[i].name, "persiststateinterval")) {
			inst-&gt;iPersistStateInterval = pvals[i].val.d.n;
		} else if(!strcmp(inppblk.descr[i].name, "maxbytesperminute")) {
			DBGPRINTF("imfile: enabling maxbytesperminute ratelimiting\n");
			inst-&gt;perMinuteRateLimits.maxBytesPerMinute = pvals[i].val.d.n;
		} else if(!strcmp(inppblk.descr[i].name, "maxlinesperminute")) {
			DBGPRINTF("imfile: enabling maxlinesperminute ratelimiting\n");
			inst-&gt;perMinuteRateLimits.maxLinesPerMinute = pvals[i].val.d.n;
		} else if(!strcmp(inppblk.descr[i].name, "persiststateaftersubmission")) {
			inst-&gt;bPersistStateAfterSubmission = pvals[i].val.d.n;
		} else if(!strcmp(inppblk.descr[i].name, "maxsubmitatonce")) {
			inst-&gt;nMultiSub = pvals[i].val.d.n;
		} else if(!strcmp(inppblk.descr[i].name, "readtimeout")) {
			inst-&gt;readTimeout = pvals[i].val.d.n;
		} else if(!strcmp(inppblk.descr[i].name, "needparse")) {
			inst-&gt;msgFlag = pvals[i].val.d.n ? NEEDS_PARSING : 0;
		} else {
			DBGPRINTF("program error, non-handled "
			  "param '%s'\n", inppblk.descr[i].name);
		}
	}
	i = (inst-&gt;readMode &gt; 0) ? 1 : 0;
	i = (NULL != inst-&gt;startRegex) ? (i+1) : i;
	i = (NULL != inst-&gt;endRegex) ? (i+1) : i;
	if(i &gt; 1) {
		LogError(0, RS_RET_PARAM_NOT_PERMITTED,
			"only one of readMode or startmsg.regex or endmsg.regex can be set "
			"at the same time");
			ABORT_FINALIZE(RS_RET_PARAM_NOT_PERMITTED);
	}

	if(inst-&gt;startRegex != NULL) {
		const int errcode = regcomp(&amp;inst-&gt;start_preg, (char*)inst-&gt;startRegex, REG_EXTENDED);
		if(errcode != 0) {
			char errbuff[512];
			regerror(errcode, &amp;inst-&gt;start_preg, errbuff, sizeof(errbuff));
			parser_errmsg("imfile: error in startmsg.regex expansion: %s", errbuff);
			ABORT_FINALIZE(RS_RET_ERR);
		}
	}
	if(inst-&gt;endRegex != NULL) {
		const int errcode = regcomp(&amp;inst-&gt;end_preg, (char*)inst-&gt;endRegex, REG_EXTENDED);
		if(errcode != 0) {
			char errbuff[512];
			regerror(errcode, &amp;inst-&gt;end_preg, errbuff, sizeof(errbuff));
			parser_errmsg("imfile: error in endmsg.regex expansion: %s", errbuff);
			ABORT_FINALIZE(RS_RET_ERR);
		}
	}
	if(inst-&gt;readTimeout != 0)
		loadModConf-&gt;haveReadTimeouts = 1;
	iRet = checkInstance(inst);
finalize_it:
CODE_STD_FINALIZERnewInpInst
	cnfparamvalsDestruct(pvals, &amp;inppblk);
ENDnewInpInst

BEGINbeginCnfLoad
CODESTARTbeginCnfLoad
	loadModConf = pModConf;
	currModConf = pModConf;
	pModConf-&gt;pConf = pConf;
	/* init our settings */
	loadModConf-&gt;opMode = OPMODE_POLLING;
	loadModConf-&gt;iPollInterval = DFLT_PollInterval;
	loadModConf-&gt;configSetViaV2Method = 0;
	loadModConf-&gt;readTimeout = 0; /* default: no timeout */
	loadModConf-&gt;timeoutGranularity = 1000; /* default: 1 second */
	loadModConf-&gt;haveReadTimeouts = 0; /* default: no timeout */
	loadModConf-&gt;normalizePath = 1;
	loadModConf-&gt;sortFiles = GLOB_NOSORT;
	loadModConf-&gt;stateFileDirectory = NULL;
	loadModConf-&gt;conf_tree = calloc(sizeof(fs_node_t), 1);
	loadModConf-&gt;conf_tree-&gt;edges = NULL;
	bLegacyCnfModGlobalsPermitted = 1;
	/* init legacy config vars */
	cs.pszFileName = NULL;
	cs.pszFileTag = NULL;
	cs.pszStateFile = NULL;
	cs.iPollInterval = DFLT_PollInterval;
	cs.iPersistStateInterval = 0;
	cs.iFacility = 128;
	cs.iSeverity = 5;
	cs.readMode = 0;
	cs.maxLinesAtOnce = 10240;
	cs.trimLineOverBytes = 0;
ENDbeginCnfLoad


BEGINsetModCnf
	struct cnfparamvals *pvals = NULL;
	int i;
CODESTARTsetModCnf
	#if defined(HAVE_PORT_SOURCE_FILE)
		/* this means we are on Solaris, so inotify is not there */
		loadModConf-&gt;opMode = OPMODE_FEN;
	#elif defined(HAVE_INOTIFY_INIT)
		loadModConf-&gt;opMode = OPMODE_INOTIFY;
<a name="3"></a>	#else
		loadModConf-&gt;opMode = OPMODE_POLLING;
	#endif
<font color="#53858b"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>	pvals = nvlstGetParams(lst, &amp;modpblk, NULL);
	if(pvals == NULL) {
		LogError(0, RS_RET_MISSING_CNFPARAMS, "imfile: error processing module "
				"config parameters [module(...)]");
		ABORT_FINALIZE(RS_RET_MISSING_CNFPARAMS);
	}

	if(Debug) {
		DBGPRINTF("module (global) param blk for imfile:\n");
		cnfparamsPrint(&amp;modpblk, pvals);
	}

	for(i = 0 ; i &lt; modpblk.nParams ; ++i) {
		if(!pvals[i].bUsed)</b></font>
			continue;
		if(!strcmp(modpblk.descr[i].name, "pollinginterval")) {
			loadModConf-&gt;iPollInterval = (int) pvals[i].val.d.n;
		} else if(!strcmp(modpblk.descr[i].name, "readtimeout")) {
			loadModConf-&gt;readTimeout = (int) pvals[i].val.d.n;
		} else if(!strcmp(modpblk.descr[i].name, "timeoutgranularity")) {
			/* note: we need ms, thus "* 1000" */
			loadModConf-&gt;timeoutGranularity = (int) pvals[i].val.d.n * 1000;
		} else if(!strcmp(modpblk.descr[i].name, "sortfiles")) {
			loadModConf-&gt;sortFiles = ((sbool) pvals[i].val.d.n) ? 0 : GLOB_NOSORT;
		} else if(!strcmp(modpblk.descr[i].name, "statefile.directory")) {
			loadModConf-&gt;stateFileDirectory = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
		} else if(!strcmp(modpblk.descr[i].name, "normalizepath")) {
			loadModConf-&gt;normalizePath = (sbool) pvals[i].val.d.n;
		} else if(!strcmp(modpblk.descr[i].name, "mode")) {
			if(!es_strconstcmp(pvals[i].val.d.estr, "polling"))
				loadModConf-&gt;opMode = OPMODE_POLLING;
			else if(!es_strconstcmp(pvals[i].val.d.estr, "inotify")) {
#if defined(OS_SOLARIS) &amp;&amp; defined (HAVE_PORT_SOURCE_FILE) /* use FEN on Solaris! */
				loadModConf-&gt;opMode = OPMODE_FEN;
				DBGPRINTF("inotify mode configured, but only FEN "
					"is available on OS SOLARIS. Switching to FEN "
					"Mode automatically\n");
#else
				#if defined(HAVE_INOTIFY_INIT)
					loadModConf-&gt;opMode = OPMODE_INOTIFY;
				#else
					loadModConf-&gt;opMode = OPMODE_POLLING;
				#endif
#endif
			} else if(!es_strconstcmp(pvals[i].val.d.estr, "fen"))
				loadModConf-&gt;opMode = OPMODE_FEN;
			else {
				char *cstr = es_str2cstr(pvals[i].val.d.estr, NULL);
				LogError(0, RS_RET_PARAM_ERROR, "imfile: unknown "
					"mode '%s'", cstr);
				free(cstr);
			}
		} else {
			DBGPRINTF("program error, non-handled "
			  "param '%s' in beginCnfLoad\n", modpblk.descr[i].name);
		}
	}

	/* remove all of our legacy handlers, as they can not used in addition
	 * the the new-style config method.
	 */
	bLegacyCnfModGlobalsPermitted = 0;
	loadModConf-&gt;configSetViaV2Method = 1;

finalize_it:
	if(pvals != NULL)
		cnfparamvalsDestruct(pvals, &amp;modpblk);
ENDsetModCnf


BEGINendCnfLoad
CODESTARTendCnfLoad
	if(!loadModConf-&gt;configSetViaV2Method) {
		/* persist module-specific settings from legacy config system */
		loadModConf-&gt;iPollInterval = cs.iPollInterval;
	}
	DBGPRINTF("opmode is %d, polling interval is %d\n",
		  loadModConf-&gt;opMode,
		  loadModConf-&gt;iPollInterval);

	loadModConf = NULL; /* done loading */
	/* free legacy config vars */
	free(cs.pszFileName);
	free(cs.pszFileTag);
	free(cs.pszStateFile);
ENDendCnfLoad


BEGINcheckCnf
	instanceConf_t *inst;
CODESTARTcheckCnf
	if(getStateFileDir() == NULL) {
		/* this intentionally is an error message */
		LogError(0, RS_RET_NO_WRKDIR_SET,
			"imfile: no working or state file directory set, imfile will create "
			"state files in the current working directory (probably "
			"the root dir). Use global(workDirectory=\"/some/path\") "
			"to set the working directory");
	}
	for(inst = pModConf-&gt;root ; inst != NULL ; inst = inst-&gt;next) {
		std_checkRuleset(pModConf, inst);
	}
	if(pModConf-&gt;root == NULL) {
		LogError(0, RS_RET_NO_LISTNERS,
				"imfile: no files configured to be monitored - "
				"no input will be gathered");
		iRet = RS_RET_NO_LISTNERS;
	}
ENDcheckCnf


/* note: we do access files AFTER we have dropped privileges. This is
 * intentional, user must make sure the files have the right permissions.
 */
BEGINactivateCnf
	instanceConf_t *inst;
CODESTARTactivateCnf
	runModConf = pModConf;
	currModConf = pModConf;
	if(runModConf-&gt;root == NULL) {
		LogError(0, NO_ERRCODE, "imfile: no file monitors configured, "
				"input not activated.\n");
		ABORT_FINALIZE(RS_RET_NO_RUN);
	}

	for(inst = runModConf-&gt;root ; inst != NULL ; inst = inst-&gt;next) {
		// TODO: provide switch to turn off this warning?
		if(!containsGlobWildcard((char*)inst-&gt;pszFileName)) {
			if(access((char*)inst-&gt;pszFileName, R_OK) != 0) {
				LogError(errno, RS_RET_ERR,
					"imfile: on startup file '%s' does not exist "
					"but is configured in static file monitor - this "
					"may indicate a misconfiguration. If the file "
					"appears at a later time, it will automatically "
					"be processed. Reason", inst-&gt;pszFileName);
			}
		}
		fs_node_add(runModConf-&gt;conf_tree, NULL, inst-&gt;pszFileName, 0, inst);
	}

	if(Debug) {
		fs_node_print(runModConf-&gt;conf_tree, 0);
	}

finalize_it:
ENDactivateCnf


BEGINfreeCnf
	instanceConf_t *inst, *del;
CODESTARTfreeCnf
	fs_node_destroy(pModConf-&gt;conf_tree);
	for(inst = pModConf-&gt;root ; inst != NULL ; ) {
		free(inst-&gt;pszBindRuleset);
		free(inst-&gt;pszFileName);
		free(inst-&gt;pszTag);
		free(inst-&gt;pszStateFile);
		free(inst-&gt;pszFileName_forOldStateFile);
		if(inst-&gt;startRegex != NULL) {
			regfree(&amp;inst-&gt;start_preg);
			free(inst-&gt;startRegex);
		}
		if(inst-&gt;endRegex != NULL) {
			regfree(&amp;inst-&gt;end_preg);
			free(inst-&gt;endRegex);
		}
		del = inst;
		inst = inst-&gt;next;
		free(del);
	}
ENDfreeCnf


/* initial poll run, to be used for all modes. Depending on mode, it does some
 * further initializations (e.g. watches in inotify mode). Most importantly,
 * it processes already-existing files, which would not otherwise be picked
 * up in notifcation modes (inotfiy, FEN). Also, when freshStartTail is set,
 * this run assumes that all previous existing data exists and needs not
 * to be considered.
 * Note: there is a race on files created *during* the run, but that race is
 * inevitable (and thus freshStartTail is actually broken, but users still seem
 * to want it...).
 * rgerhards, 2018-05-17
 */
static void
do_initial_poll_run(void)
{
	fs_node_walk(runModConf-&gt;conf_tree, poll_tree);

	/* fresh start done, so disable freshStartTail for files that now will be created */
	for(instanceConf_t *inst = runModConf-&gt;root ; inst != NULL ; inst = inst-&gt;next) {
		inst-&gt;freshStartTail = 0;
	}
}


/* Monitor files in polling mode. */
static rsRetVal
doPolling(void)
{
	DEFiRet;
	do_initial_poll_run();
	while(glbl.GetGlobalInputTermState() == 0) {
		DBGPRINTF("doPolling: new poll run\n");
		do {
			runModConf-&gt;bHadFileData = 0;
			fs_node_walk(runModConf-&gt;conf_tree, poll_tree);
			DBGPRINTF("doPolling: end poll walk, hadData %d\n", runModConf-&gt;bHadFileData);
		} while(runModConf-&gt;bHadFileData); /* warning: do...while()! */

		/* Note: the additional 10ns wait is vitally important. It guards rsyslog
		 * against totally hogging the CPU if the users selects a polling interval
		 * of 0 seconds. It doesn't hurt any other valid scenario. So do not remove.
		 * rgerhards, 2008-02-14
		 */
		DBGPRINTF("doPolling: poll going to sleep\n");
		if(glbl.GetGlobalInputTermState() == 0)
			srSleep(runModConf-&gt;iPollInterval, 10);
	}

	RETiRet;
}

#if defined(HAVE_INOTIFY_INIT)

static void ATTR_NONNULL(1)
in_dbg_showEv(const struct inotify_event *ev)
{
	if(!Debug)
		return;
	if(ev-&gt;mask &amp; IN_IGNORED) {
		dbgprintf("INOTIFY event: watch was REMOVED\n");
	}
	if(ev-&gt;mask &amp; IN_MODIFY) {
		dbgprintf("INOTIFY event: watch was MODIFID\n");
	}
	if(ev-&gt;mask &amp; IN_ACCESS) {
		dbgprintf("INOTIFY event: watch IN_ACCESS\n");
	}
	if(ev-&gt;mask &amp; IN_ATTRIB) {
		dbgprintf("INOTIFY event: watch IN_ATTRIB\n");
	}
	if(ev-&gt;mask &amp; IN_CLOSE_WRITE) {
		dbgprintf("INOTIFY event: watch IN_CLOSE_WRITE\n");
	}
	if(ev-&gt;mask &amp; IN_CLOSE_NOWRITE) {
		dbgprintf("INOTIFY event: watch IN_CLOSE_NOWRITE\n");
	}
	if(ev-&gt;mask &amp; IN_CREATE) {
		dbgprintf("INOTIFY event: file was CREATED: %s\n", ev-&gt;name);
	}
	if(ev-&gt;mask &amp; IN_DELETE) {
		dbgprintf("INOTIFY event: watch IN_DELETE\n");
	}
	if(ev-&gt;mask &amp; IN_DELETE_SELF) {
		dbgprintf("INOTIFY event: watch IN_DELETE_SELF\n");
	}
	if(ev-&gt;mask &amp; IN_MOVE_SELF) {
		dbgprintf("INOTIFY event: watch IN_MOVE_SELF\n");
	}
	if(ev-&gt;mask &amp; IN_MOVED_FROM) {
		dbgprintf("INOTIFY event: watch IN_MOVED_FROM, cookie %u, name '%s'\n", ev-&gt;cookie, ev-&gt;name);
	}
	if(ev-&gt;mask &amp; IN_MOVED_TO) {
		dbgprintf("INOTIFY event: watch IN_MOVED_TO, cookie %u, name '%s'\n", ev-&gt;cookie, ev-&gt;name);
	}
	if(ev-&gt;mask &amp; IN_OPEN) {
		dbgprintf("INOTIFY event: watch IN_OPEN\n");
	}
	if(ev-&gt;mask &amp; IN_ISDIR) {
		dbgprintf("INOTIFY event: watch IN_ISDIR\n");
	}
}


static void ATTR_NONNULL(1, 2)
in_handleFileEvent(struct inotify_event *ev, const wd_map_t *const etry)
{
	if(ev-&gt;mask &amp; IN_MODIFY) {
		DBGPRINTF("fs_node_notify_file_update: act-&gt;name '%s'\n", etry-&gt;act-&gt;name);
		pollFile(etry-&gt;act);
	} else {
		DBGPRINTF("got non-expected inotify event:\n");
		in_dbg_showEv(ev);
	}
}


/* workaround for IN_MOVED: walk active list and prevent state file deletion of
 * IN_MOVED_IN active object
 * TODO: replace by a more generic solution.
 */
static void
flag_in_move(fs_edge_t *const edge, const char *name_moved)
{
	act_obj_t *act;

	for(act = edge-&gt;active ; act != NULL ; act = act-&gt;next) {
		DBGPRINTF("checking active object %s\n", act-&gt;basename);
		if(!strcmp(act-&gt;basename, name_moved)){
			DBGPRINTF("found file\n");
			act-&gt;in_move = 1;
			break;
		} else {
			DBGPRINTF("name check fails, '%s' != '%s'\n", act-&gt;basename, name_moved);
		}
	}
	if (!act &amp;&amp; edge-&gt;next) {
		flag_in_move(edge-&gt;next, name_moved);
	}
}

static void ATTR_NONNULL(1)
in_processEvent(struct inotify_event *ev)
{
	if(ev-&gt;mask &amp; IN_IGNORED) {
		DBGPRINTF("imfile: got IN_IGNORED event\n");
		goto done;
	}

	DBGPRINTF("in_processEvent process Event %x for %s\n", ev-&gt;mask, ev-&gt;name);
	const wd_map_t *const etry =  wdmapLookup(ev-&gt;wd);
	if(etry == NULL) {
		LogMsg(0, RS_RET_INTERNAL_ERROR, LOG_WARNING, "imfile: internal error? "
			"inotify provided watch descriptor %d which we could not find "
			"in our tables - ignored", ev-&gt;wd);
		goto done;
	}
	DBGPRINTF("in_processEvent process Event %x is_file %d, act-&gt;name '%s'\n",
		ev-&gt;mask, etry-&gt;act-&gt;edge-&gt;is_file, etry-&gt;act-&gt;name);

	if((ev-&gt;mask &amp; IN_MOVED_FROM)) {
		flag_in_move(etry-&gt;act-&gt;edge-&gt;node-&gt;edges, ev-&gt;name);
	}
	if(ev-&gt;mask &amp; (IN_MOVED_FROM | IN_MOVED_TO))  {
		fs_node_walk(etry-&gt;act-&gt;edge-&gt;node, poll_tree);
	} else if(etry-&gt;act-&gt;edge-&gt;is_file &amp;&amp; !(etry-&gt;act-&gt;is_symlink)) {
		in_handleFileEvent(ev, etry); // esentially poll_file()!
	} else {
		fs_node_walk(etry-&gt;act-&gt;edge-&gt;node, poll_tree);
	}
done:	return;
}


/* Monitor files in inotify mode */
static rsRetVal
do_inotify(void)
{
	char iobuf[8192];
	int rd;
	int currev;
	static int last_timeout = 0;
	struct pollfd pollfd;
	DEFiRet;

	CHKiRet(wdmapInit());
	ino_fd = inotify_init1(IN_NONBLOCK);
	if(ino_fd &lt; 0) {
		LogError(errno, RS_RET_INOTIFY_INIT_FAILED, "imfile: Init inotify "
			"instance failed ");
		return RS_RET_INOTIFY_INIT_FAILED;
	}
	DBGPRINTF("inotify fd %d\n", ino_fd);

	do_initial_poll_run();

	while(glbl.GetGlobalInputTermState() == 0) {
		int r;

		pollfd.fd = ino_fd;
		pollfd.events = POLLIN;

		if (runModConf-&gt;haveReadTimeouts)
			r = poll(&amp;pollfd, 1, runModConf-&gt;timeoutGranularity);
		else
			r = poll(&amp;pollfd, 1, -1);

		if (r  == -1 &amp;&amp; errno == EINTR) {
			DBGPRINTF("do_inotify interrupted while polling on ino_fd\n");
			continue;
		}
		if(r == 0) {
			DBGPRINTF("readTimeouts are configured, checking if some apply\n");
			if (runModConf-&gt;haveReadTimeouts) {
				fs_node_walk(runModConf-&gt;conf_tree, poll_timeouts);
				last_timeout = time(NULL);
			}
			continue;
		} else if (r == -1) {
			LogError(errno, RS_RET_INTERNAL_ERROR,
					"%s:%d: unexpected error during poll timeout wait",
					__FILE__, __LINE__);
			/* we do not abort, as this would render the whole input defunct */
			continue;
		} else if(r != 1) {
			LogError(errno, RS_RET_INTERNAL_ERROR,
					"%s:%d: ERROR: poll returned more fds (%d) than given to it (1)",
					__FILE__, __LINE__, r);
			/* we do not abort, as this would render the whole input defunct */
			continue;
		}
		else {
			// process timeouts always, ino_fd may be too busy to ever have timeout occur from poll
			if(runModConf-&gt;haveReadTimeouts) {
				int now = time(NULL);
				if(last_timeout + (runModConf-&gt;timeoutGranularity / 1000) &gt; now) {
					fs_node_walk(runModConf-&gt;conf_tree, poll_timeouts);
					last_timeout = time(NULL);
				}
			}
			rd = read(ino_fd, iobuf, sizeof(iobuf));
			if(rd == -1 &amp;&amp; errno == EINTR) {
				/* This might have been our termination signal! */
				DBGPRINTF("EINTR received during inotify, restarting poll\n");
				continue;
			}
			if (rd == -1 &amp;&amp; errno == EWOULDBLOCK) {
				continue;
			}
			if(rd &lt; 0) {
				LogError(errno, RS_RET_IO_ERROR, "imfile: error during inotify - ignored");
				continue;
			}
			currev = 0;
			while(currev &lt; rd) {
				union {
					char *buf;
					struct inotify_event *ev;
				} savecast;
				savecast.buf = iobuf+currev;
				in_dbg_showEv(savecast.ev);
				in_processEvent(savecast.ev);
				currev += sizeof(struct inotify_event) + savecast.ev-&gt;len;
			}
		}
	}

finalize_it:
	close(ino_fd);
	RETiRet;
}

#else /* #if HAVE_INOTIFY_INIT */
static rsRetVal
do_inotify(void)
{
	LogError(0, RS_RET_NOT_IMPLEMENTED, "imfile: mode set to inotify, but the "
			"platform does not support inotify");
	return RS_RET_NOT_IMPLEMENTED;
}
#endif /* #if HAVE_INOTIFY_INIT */


/* --- Monitor files in FEN mode (OS_SOLARIS)*/
#if defined(OS_SOLARIS) &amp;&amp; defined (HAVE_PORT_SOURCE_FILE) /* use FEN on Solaris! */
static void
fen_printevent(int event)
{
	if (event &amp; FILE_ACCESS) {
		DBGPRINTF(" FILE_ACCESS");
	}
	if (event &amp; FILE_MODIFIED) {
		DBGPRINTF(" FILE_MODIFIED");
	}
	if (event &amp; FILE_ATTRIB) {
		DBGPRINTF(" FILE_ATTRIB");
	}
	if (event &amp; FILE_DELETE) {
		DBGPRINTF(" FILE_DELETE");
	}
	if (event &amp; FILE_RENAME_TO) {
		DBGPRINTF(" FILE_RENAME_TO");
	}
	if (event &amp; FILE_RENAME_FROM) {
		DBGPRINTF(" FILE_RENAME_FROM");
	}
	if (event &amp; UNMOUNTED) {
		DBGPRINTF(" UNMOUNTED");
	}
	if (event &amp; MOUNTEDOVER) {
		DBGPRINTF(" MOUNTEDOVER");
	}
}


/* https://docs.oracle.com/cd/E19253-01/816-5168/port-get-3c/index.html */
static rsRetVal
do_fen(void)
{
	port_event_t portEvent;
	struct timespec timeout;
	DEFiRet;

	/* Set port timeout to 1 second. We need to check for unmonitored files during meantime */
	// TODO: do we need this timeout at all for equality to old code?
	// TODO: do we need it to support the timeout feature!
	timeout.tv_sec = 300;
	timeout.tv_nsec = 0;

	/* create port instance */
	if((glport = port_create()) == -1) {
		LogError(errno, RS_RET_FEN_INIT_FAILED, "do_fen INIT Port failed ");
		return RS_RET_FEN_INIT_FAILED;
	}

	do_initial_poll_run();

	DBGPRINTF("do_fen ENTER monitoring loop \n");
	while(glbl.GetGlobalInputTermState() == 0) {
		DBGPRINTF("do_fen loop begin... \n");
		/* Loop through events, if there are any */
		while (!port_get(glport, &amp;portEvent, &amp;timeout)) { // wie inotify-wait
			DBGPRINTF("do_fen: received port event with ");
			fen_printevent((int) portEvent.portev_events);
			DBGPRINTF("\n");
			if(portEvent.portev_source != PORT_SOURCE_FILE) {
				LogError(errno, RS_RET_SYS_ERR, "do_fen: Event from unexpected source "
					": %d\n", portEvent.portev_source);
				continue;
			}
			act_obj_t *const act = (act_obj_t*) portEvent.portev_user;
			DBGPRINTF("do_fen event received: deleted %d, is_file %d, name '%s' foname '%s'\n",
				act-&gt;is_deleted, act-&gt;edge-&gt;is_file, act-&gt;name,
				((struct file_obj*)portEvent.portev_object)-&gt;fo_name);
			if(act-&gt;is_deleted) {
				free(act-&gt;name);
				free(act);
				continue;
			}

			/* we need to re-associate the object */
			act-&gt;bPortAssociated = 0;
			fen_setupWatch(act);

			if(act-&gt;edge-&gt;is_file) {
				pollFile(act);
			} else {
				fs_node_walk(act-&gt;edge-&gt;node, poll_tree);
			}
		}
	}

	/* close port, will de-activate all file events watches associated
	 * with the port.
	 */
	close(glport);
	RETiRet;
}
#else /* #if OS_SOLARIS */
static rsRetVal
do_fen(void)
{
	LogError(0, RS_RET_NOT_IMPLEMENTED, "do_fen: mode set to fen, but the "
			"platform does not support fen");
	return RS_RET_NOT_IMPLEMENTED;
}
#endif /* #if OS_SOLARIS */


/* This function is called by the framework to gather the input. The module stays
 * most of its lifetime inside this function. It MUST NEVER exit this function. Doing
 * so would end module processing and rsyslog would NOT reschedule the module. If
 * you exit from this function, you violate the interface specification!
 */
BEGINrunInput
CODESTARTrunInput
	#if defined(OS_SOLARIS) &amp;&amp; defined (HAVE_PORT_SOURCE_FILE) /* use FEN on Solaris! */
	if(runModConf-&gt;opMode == OPMODE_INOTIFY) {
		DBGPRINTF("auto-adjusting 'inotify' mode to 'fen' on Solaris\n");
		runModConf-&gt;opMode = OPMODE_FEN;
	}
	#endif
	DBGPRINTF("working in %s mode\n",
		 (runModConf-&gt;opMode == OPMODE_POLLING) ? "polling" :
			((runModConf-&gt;opMode == OPMODE_INOTIFY) ?"inotify" : "fen"));
	if(runModConf-&gt;opMode == OPMODE_POLLING)
		iRet = doPolling();
	else if(runModConf-&gt;opMode == OPMODE_INOTIFY)
		iRet = do_inotify();
	else if(runModConf-&gt;opMode == OPMODE_FEN)
		iRet = do_fen();
	else {
		LogError(0, RS_RET_NOT_IMPLEMENTED, "imfile: unknown mode %d set",
			runModConf-&gt;opMode);
		return RS_RET_NOT_IMPLEMENTED;
	}
	DBGPRINTF("terminating upon request of rsyslog core\n");
ENDrunInput


/* The function is called by rsyslog before runInput() is called. It is a last chance
 * to set up anything specific. Most importantly, it can be used to tell rsyslog if the
 * input shall run or not. The idea is that if some config settings (or similiar things)
 * are not OK, the input can tell rsyslog it will not execute. To do so, return
 * RS_RET_NO_RUN or a specific error code. If RS_RET_OK is returned, rsyslog will
 * proceed and call the runInput() entry point.
 */
BEGINwillRun
CODESTARTwillRun
	/* we need to create the inputName property (only once during our lifetime) */
	CHKiRet(prop.Construct(&amp;pInputName));
	CHKiRet(prop.SetString(pInputName, UCHAR_CONSTANT("imfile"), sizeof("imfile") - 1));
	CHKiRet(prop.ConstructFinalize(pInputName));
finalize_it:
ENDwillRun

// TODO: refactor this into a generically-usable "atomic file creation" utility for
// all kinds of "state files"
static rsRetVal ATTR_NONNULL()
atomicWriteStateFile(const char *fn, const char *content)
{
	DEFiRet;
	const int fd = open(fn, O_CLOEXEC | O_NOCTTY | O_WRONLY | O_CREAT | O_TRUNC, 0600);
	if(fd &lt; 0) {
		LogError(errno, RS_RET_IO_ERROR, "imfile: cannot open state file '%s' for "
			"persisting file state - some data will probably be duplicated "
			"on next startup", fn);
		ABORT_FINALIZE(RS_RET_IO_ERROR);
	}

	const size_t toWrite = strlen(content);
	const ssize_t w = write(fd, content, toWrite);
	if(w != (ssize_t) toWrite) {
		LogError(errno, RS_RET_IO_ERROR, "imfile: partial write to state file '%s' "
			"this may cause trouble in the future. We will try to delete the "
			"state file, as this provides most consistent state", fn);
		unlink(fn);
		ABORT_FINALIZE(RS_RET_IO_ERROR);
	}

finalize_it:
	if(fd &gt;= 0) {
		close(fd);
	}
	RETiRet;
}

/* This function should be called after any file ID change - that is if
 * file grown from hash-only statefile, or was truncated, this will ensure
 * we delete the old file so we do not make garbage in our working dir and
 * there are no leftover statefiles which can in theory later bind to something
 * and cause data loss.
 * jvymazal 2019-11-27
 */
static void
removeOldStatefile(const uchar *statefn, const char *hashToDelete)
{
	int ret;
	uchar statefname[MAXFNAME];

	getFullStateFileName(statefn, hashToDelete, statefname, sizeof(statefname));
	DBGPRINTF("removing old state file: '%s'\n", statefname);
	ret = unlink((const char*)statefname);
	if(ret != 0) {
		if (errno != ENOENT) {
			LogError(errno, RS_RET_IO_ERROR,
				"imfile error trying to delete old state file: '%s' - ignoring this "
				"error, usually this means a file no longer file is left over, but "
				"this may also cause some real trouble. Still the best we can do ",
				statefname);
		} else {
			DBGPRINTF("trying to delete no longer valid statefile '%s' which no "
					  "longer exists (probably already deleted)\n", statefname);
		}
	}
}


/* This function persists information for a specific file being monitored.
 * To do so, it simply persists the stream object. We do NOT abort on error
 * iRet as that makes matters worse (at least we can try persisting the others...).
 * rgerhards, 2008-02-13
 */
static rsRetVal ATTR_NONNULL()
persistStrmState(act_obj_t *const act)
{
	DEFiRet;
	uchar statefile[MAXFNAME];
	uchar statefname[MAXFNAME];

	uchar *const statefn = getStateFileName(act, statefile, sizeof(statefile));
	getFileID(act);
	getFullStateFileName(statefn, act-&gt;file_id, statefname, sizeof(statefname));
	DBGPRINTF("persisting state for '%s', state file '%s'\n", act-&gt;name, statefname);

	struct json_object *jval = NULL;
	struct json_object *json = NULL;
	CHKmalloc(json = json_object_new_object());
	jval = json_object_new_string((char*) act-&gt;name);
	json_object_object_add(json, "filename", jval);
	jval = json_object_new_int(strmGetPrevWasNL(act-&gt;pStrm));
	json_object_object_add(json, "prev_was_nl", jval);

	/* we access some data items a bit dirty, as we need to refactor the whole
	 * thing in any case - TODO
	 */
	jval = json_object_new_int64(act-&gt;pStrm-&gt;iCurrOffs);
	json_object_object_add(json, "curr_offs", jval);
	jval = json_object_new_int64(act-&gt;pStrm-&gt;strtOffs);
	json_object_object_add(json, "strt_offs", jval);

	const uchar *const prevLineSegment = strmGetPrevLineSegment(act-&gt;pStrm);
	if(prevLineSegment != NULL) {
		jval = json_object_new_string((const char*) prevLineSegment);
		json_object_object_add(json, "prev_line_segment", jval);
	}

	const uchar *const prevMsgSegment = strmGetPrevMsgSegment(act-&gt;pStrm);
	if(prevMsgSegment != NULL) {
		jval = json_object_new_string((const char*) prevMsgSegment);
		json_object_object_add(json, "prev_msg_segment", jval);
	}

	const char *jstr =  json_object_to_json_string_ext(json, JSON_C_TO_STRING_SPACED);

	CHKiRet(atomicWriteStateFile((const char*)statefname, jstr));
	json_object_put(json);

	/* file-id changed remove the old statefile */
	if (strncmp((const char *)act-&gt;file_id_prev, (const char *)act-&gt;file_id, FILE_ID_HASH_SIZE)) {
		removeOldStatefile(statefn, act-&gt;file_id_prev);
	}

finalize_it:
	if(iRet != RS_RET_OK) {
		LogError(0, iRet, "imfile: could not persist state "
				"file %s - data may be repeated on next "
				"startup. Is WorkDirectory set?",
				statefname);
	}

	RETiRet;
}

/* This function is called by the framework after runInput() has been terminated. It
 * shall free any resources and prepare the module for unload.
 */
BEGINafterRun
CODESTARTafterRun
	if(pInputName != NULL)
		prop.Destruct(&amp;pInputName);
ENDafterRun


BEGINisCompatibleWithFeature
CODESTARTisCompatibleWithFeature
	if(eFeat == sFEATURENonCancelInputTermination)
		iRet = RS_RET_OK;
ENDisCompatibleWithFeature


/* The following entry points are defined in module-template.h.
 * In general, they need to be present, but you do NOT need to provide
 * any code here.
 */
BEGINmodExit
CODESTARTmodExit
	/* release objects we used */
	objRelease(strm, CORE_COMPONENT);
	objRelease(glbl, CORE_COMPONENT);
	objRelease(prop, CORE_COMPONENT);
	objRelease(ruleset, CORE_COMPONENT);
	objRelease(datetime, CORE_COMPONENT);

	#ifdef HAVE_INOTIFY_INIT
	free(wdmap);
	#endif
ENDmodExit


BEGINqueryEtryPt
CODESTARTqueryEtryPt
CODEqueryEtryPt_STD_IMOD_QUERIES
CODEqueryEtryPt_STD_CONF2_QUERIES
CODEqueryEtryPt_STD_CONF2_setModCnf_QUERIES
CODEqueryEtryPt_STD_CONF2_IMOD_QUERIES
CODEqueryEtryPt_IsCompatibleWithFeature_IF_OMOD_QUERIES
ENDqueryEtryPt


/* The following function shall reset all configuration variables to their
 * default values. The code provided in modInit() below registers it to be
 * called on "$ResetConfigVariables". You may also call it from other places,
 * but in general this is not necessary. Once runInput() has been called, this
 * function here is never again called.
 */
static rsRetVal
resetConfigVariables(uchar __attribute__((unused)) *pp, void __attribute__((unused)) *pVal)
{
	DEFiRet;

	free(cs.pszFileName);
	cs.pszFileName = NULL;
	free(cs.pszFileTag);
	cs.pszFileTag = NULL;
	free(cs.pszStateFile);
	cs.pszStateFile = NULL;

	/* set defaults... */
	cs.iPollInterval = DFLT_PollInterval;
	cs.iFacility = 128; /* local0 */
	cs.iSeverity = 5;  /* notice, as of rfc 3164 */
	cs.readMode = 0;
	cs.maxLinesAtOnce = 10240;
	cs.trimLineOverBytes = 0;

	RETiRet;
}

static inline void
std_checkRuleset_genErrMsg(__attribute__((unused)) modConfData_t *modConf, instanceConf_t *inst)
{
	LogError(0, NO_ERRCODE, "imfile: ruleset '%s' for %s not found - "
			"using default ruleset instead", inst-&gt;pszBindRuleset,
			inst-&gt;pszFileName);
}

/* modInit() is called once the module is loaded. It must perform all module-wide
 * initialization tasks. There are also a number of housekeeping tasks that the
 * framework requires. These are handled by the macros. Please note that the
 * complexity of processing is depending on the actual module. However, only
 * thing absolutely necessary should be done here. Actual app-level processing
 * is to be performed in runInput(). A good sample of what to do here may be to
 * set some variable defaults.
 */
BEGINmodInit()
CODESTARTmodInit
	*ipIFVersProvided = CURR_MOD_IF_VERSION; /* we only support the current interface specification */
CODEmodInit_QueryRegCFSLineHdlr
	CHKiRet(objUse(glbl, CORE_COMPONENT));
	CHKiRet(objUse(strm, CORE_COMPONENT));
	CHKiRet(objUse(ruleset, CORE_COMPONENT));
	CHKiRet(objUse(prop, CORE_COMPONENT));
	CHKiRet(objUse(datetime, CORE_COMPONENT));

	DBGPRINTF("version %s initializing\n", VERSION);
	CHKiRet(omsdRegCFSLineHdlr((uchar *)"inputfilename", 0, eCmdHdlrGetWord,
	  	NULL, &amp;cs.pszFileName, STD_LOADABLE_MODULE_ID));
	CHKiRet(omsdRegCFSLineHdlr((uchar *)"inputfiletag", 0, eCmdHdlrGetWord,
	  	NULL, &amp;cs.pszFileTag, STD_LOADABLE_MODULE_ID));
	CHKiRet(omsdRegCFSLineHdlr((uchar *)"inputfilestatefile", 0, eCmdHdlrGetWord,
	  	NULL, &amp;cs.pszStateFile, STD_LOADABLE_MODULE_ID));
	CHKiRet(omsdRegCFSLineHdlr((uchar *)"inputfileseverity", 0, eCmdHdlrSeverity,
	  	NULL, &amp;cs.iSeverity, STD_LOADABLE_MODULE_ID));
	CHKiRet(omsdRegCFSLineHdlr((uchar *)"inputfilefacility", 0, eCmdHdlrFacility,
	  	NULL, &amp;cs.iFacility, STD_LOADABLE_MODULE_ID));
	CHKiRet(omsdRegCFSLineHdlr((uchar *)"inputfilereadmode", 0, eCmdHdlrInt,
	  	NULL, &amp;cs.readMode, STD_LOADABLE_MODULE_ID));
	CHKiRet(omsdRegCFSLineHdlr((uchar *)"inputfilemaxlinesatonce", 0, eCmdHdlrSize,
	  	NULL, &amp;cs.maxLinesAtOnce, STD_LOADABLE_MODULE_ID));
	CHKiRet(omsdRegCFSLineHdlr((uchar *)"inputfiletrimlineoverbytes", 0, eCmdHdlrSize,
	  	NULL, &amp;cs.trimLineOverBytes, STD_LOADABLE_MODULE_ID));
	CHKiRet(omsdRegCFSLineHdlr((uchar *)"inputfilepersiststateinterval", 0, eCmdHdlrInt,
	  	NULL, &amp;cs.iPersistStateInterval, STD_LOADABLE_MODULE_ID));
	CHKiRet(omsdRegCFSLineHdlr((uchar *)"inputfilebindruleset", 0, eCmdHdlrGetWord,
		NULL, &amp;cs.pszBindRuleset, STD_LOADABLE_MODULE_ID));
	/* that command ads a new file! */
	CHKiRet(omsdRegCFSLineHdlr((uchar *)"inputrunfilemonitor", 0, eCmdHdlrGetWord,
		addInstance, NULL, STD_LOADABLE_MODULE_ID));
	/* module-global config params - will be disabled in configs that are loaded
	 * via module(...).
	 */
	CHKiRet(regCfSysLineHdlr2((uchar *)"inputfilepollinterval", 0, eCmdHdlrInt,
	  	NULL, &amp;cs.iPollInterval, STD_LOADABLE_MODULE_ID, &amp;bLegacyCnfModGlobalsPermitted));
	CHKiRet(omsdRegCFSLineHdlr((uchar *)"resetconfigvariables", 1, eCmdHdlrCustomHandler,
		resetConfigVariables, NULL, STD_LOADABLE_MODULE_ID));
ENDmodInit
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
