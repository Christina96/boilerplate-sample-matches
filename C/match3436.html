<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for omhttpfs.c &amp; ruleset.c</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for omhttpfs.c &amp; ruleset.c
      </h3>
<h1 align="center">
        2.4%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>omhttpfs.c (3.3096926%)<th>ruleset.c (1.9774011%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(135-151)<td><a href="#" name="0">(61-71)</a><td align="center"><font color="#ff0000">14</font>
</td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>omhttpfs.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
#include "config.h"
#include "rsyslog.h"
#include &lt;stdio.h&gt;
#include &lt;stdarg.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;assert.h&gt;
#include &lt;signal.h&gt;
#include &lt;errno.h&gt;
#include &lt;unistd.h&gt;
#include &lt;curl/curl.h&gt;
#include &lt;json.h&gt;
#include &lt;json_object.h&gt;
#include "conf.h"
#include "syslogd-types.h"
#include "srUtils.h"
#include "template.h"
#include "module-template.h"
#include "errmsg.h"
#include "cfsysline.h"
#include "datetime.h"
#include "statsobj.h"
#include "unicode-helper.h"
MODULE_TYPE_OUTPUT
MODULE_TYPE_NOKEEP
MODULE_CNFNAME("omhttpfs")
DEF_OMOD_STATIC_DATA
DEFobjCurrIf(glbl)
DEFobjCurrIf(datetime)
#define OMHTTPFS_VERSION "1.0"
#define OMHTTPFS_DEFAULT_PORT 14000
#define OMHTTPFS_DEFAULT_USER "hdfs"
#define OMHTTPFS_DEFAULT_HOST "127.0.0.1"
#define HTTPFS_URL_PREFIX_V1     "/webhdfs/v1"
#define HTTPFS_URL_PREFIX_V1_SSL "/swebhdfs/v1"
#define HTTPFS_CONTENT_TYPE      "Content-Type: application/octet-stream"
#define HTTPFS_USER_AGENT        "omhttpfs by sskaje/" OMHTTPFS_VERSION
#define HTTPFS_CONTENT_TYPE_JSON "application/json"
#define HTTPFS_JSON_BOOLEAN_TRUE "{\"boolean\":true}"
#define HTTPFS_FILEALREADYEXISTSEXCEPTION "FileAlreadyExistsException"
#define HTTPFS_URL_BUFFER_LENGTH 2048
#define DPP(x) DBGPRINTF("OMHTTPFS: %s:%d %s(): %s\n", __FILE__, __LINE__, __FUNCTION__, x)
typedef struct _HTTPFS_JSON_REMOTE_EXCEPTION {
	char message[1024];
	char exception[256];
	char class[256];
} httpfs_json_remote_exception;
typedef struct _instanceData {
	sbool https;
	uchar* host;
	uchar* ip;
	int  port;
	uchar* user;
	int timeout;
	uchar* file;
	sbool isDynFile;
	uchar* tplName;
} instanceData;
typedef struct wrkrInstanceData {
	instanceData *pData;
	CURL* curl;
	uchar* file;
	int replyLen;
	char* reply;
} wrkrInstanceData_t;
static struct cnfparamdescr actpdescr[] = {
	{ "host", eCmdHdlrGetWord, 0 },
	{ "port", eCmdHdlrInt, 0 },
<a name="0"></a>	{ "user", eCmdHdlrGetWord, 0 },
	{ "https", eCmdHdlrBinary, 0 },
	{ "file", eCmdHdlrGetWord, CNFPARAM_REQUIRED },
<font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>	{ "isdynfile", eCmdHdlrBinary, 0 },
	{ "template", eCmdHdlrGetWord, 0 },
};
static struct cnfparamblk actpblk = {
	CNFPARAMBLK_VERSION,
	sizeof(actpdescr)/sizeof(struct cnfparamdescr),
	actpdescr
};
static rsRetVal</b></font>
httpfs_init_curl(wrkrInstanceData_t *pWrkrData, instanceData *pData)
{
	CURL *curl = NULL;
	curl = curl_easy_init();
	if (curl) {
		curl_easy_setopt(curl, CURLOPT_VERBOSE, 0L);
		curl_easy_setopt(curl, CURLOPT_FOLLOWLOCATION, 1L);
		if (pData-&gt;https) {
			DBGPRINTF("%s(): Enable HTTPS\n", __FUNCTION__);
			curl_easy_setopt(curl, CURLOPT_SSL_VERIFYPEER, 0L);
			curl_easy_setopt(curl, CURLOPT_SSL_VERIFYHOST, 0L);
		}
	} else {
		LogError(0, RS_RET_OBJ_CREATION_FAILED, "omhttpfs: failed to init cURL\n");
		return RS_RET_OBJ_CREATION_FAILED;
	}
	curl_easy_setopt(curl, CURLOPT_USERAGENT, HTTPFS_USER_AGENT);
	pWrkrData-&gt;curl = curl;
	return RS_RET_OK;
}
static rsRetVal
httpfs_build_url(wrkrInstanceData_t *pWrkrData, const char* op, es_str_t** url_buf)
{
	*url_buf = es_newStr(HTTPFS_URL_BUFFER_LENGTH);
	if (pWrkrData-&gt;pData-&gt;https) {
	    es_addBuf(url_buf, "https://", sizeof("https://")-1);
	} else {
	    es_addBuf(url_buf, "http://", sizeof("http://")-1);
	}
	es_addBuf(url_buf, (char* )pWrkrData-&gt;pData-&gt;host, strlen((char*)pWrkrData-&gt;pData-&gt;host));
	es_addChar(url_buf, ':');
	char portBuf[6];
	snprintf(portBuf, sizeof(portBuf), "%d", pWrkrData-&gt;pData-&gt;port);
	es_addBuf(url_buf, portBuf, strlen(portBuf));
	es_addBuf(url_buf, HTTPFS_URL_PREFIX_V1, sizeof(HTTPFS_URL_PREFIX_V1)-1);
	if (pWrkrData-&gt;file[0] != '/') {
	    es_addChar(url_buf, '/');
	}
	es_addBuf(url_buf, (char* )pWrkrData-&gt;file, strlen((char* )pWrkrData-&gt;file));
	es_addBuf(url_buf, "?user.name=", sizeof("?user.name=")-1);
	es_addBuf(url_buf, (char* )pWrkrData-&gt;pData-&gt;user, strlen((char* )pWrkrData-&gt;pData-&gt;user));
	es_addBuf(url_buf, op, strlen(op));
	return RS_RET_OK;
}
static void httpfs_set_url(wrkrInstanceData_t *pWrkrData, const char* op)
{
	es_str_t* url;
	char* url_cstr;
	httpfs_build_url(pWrkrData, op, &amp;url);
	url_cstr = es_str2cstr(url, NULL);
	curl_easy_setopt(pWrkrData-&gt;curl, CURLOPT_URL, url_cstr);
	free(url_cstr);
}
static void httpfs_curl_set_put(CURL* curl)
{
	curl_easy_setopt(curl, CURLOPT_HTTPGET, 0L);
	curl_easy_setopt(curl, CURLOPT_NOBODY, 0L);
	curl_easy_setopt(curl, CURLOPT_POST, 0L);
	curl_easy_setopt(curl, CURLOPT_PUT, 0L);
	curl_easy_setopt(curl, CURLOPT_UPLOAD, 0L);
	curl_easy_setopt(curl, CURLOPT_CUSTOMREQUEST, "PUT");
}
static void httpfs_curl_set_post(CURL* curl)
{
	curl_easy_setopt(curl, CURLOPT_HTTPGET, 0L);
	curl_easy_setopt(curl, CURLOPT_NOBODY, 0L);
	curl_easy_setopt(curl, CURLOPT_PUT, 0L);
	curl_easy_setopt(curl, CURLOPT_UPLOAD, 0L);
	curl_easy_setopt(curl, CURLOPT_POST, 1L);
	curl_easy_setopt(curl, CURLOPT_CUSTOMREQUEST, "POST");
}
static struct curl_slist*
httpfs_curl_add_header(struct curl_slist* headers, int hdr_count, ...)
{
	const char* hdr;
	va_list ar;
	va_start(ar, hdr_count);
	for (; hdr_count &gt; 0; hdr_count--) {
	    hdr = va_arg(ar, const char*);
	    if (hdr != NULL
	            &amp;&amp; hdr[0] != 0) {
	        headers = curl_slist_append(headers, hdr);
	    } else {
	        break;
	    }
	}
	va_end(ar);
	headers = curl_slist_append(headers, "Expect:");
	headers = curl_slist_append(headers, "Transfer-Encoding:");
	return headers;
}
static size_t
httpfs_curl_result_callback(void *contents, size_t size, size_t nmemb, void *userp)
{
	size_t realsize = size * nmemb;
	char *newreply = NULL;
	wrkrInstanceData_t *mem = (wrkrInstanceData_t *)userp;
	newreply = realloc(mem-&gt;reply, mem-&gt;replyLen + realsize + 1);
	if (newreply == NULL) {
	    dbgprintf("not enough memory (realloc returned NULL)\n");
	    if (mem-&gt;reply != NULL)
	        free(mem-&gt;reply);
	    mem-&gt;reply = NULL;
	    mem-&gt;replyLen = 0;
	    return 0;
	}
	mem-&gt;reply = newreply;
	memcpy(&amp;(mem-&gt;reply[mem-&gt;replyLen]), contents, realsize);
	mem-&gt;replyLen += realsize;
	mem-&gt;reply[mem-&gt;replyLen] = 0;
	return realsize;
}
#define HTTPFS_CURL_VARS_INIT \
	struct curl_slist* headers = NULL; \
	long response_code; \
	CURLcode res; \
	char* content_type;
#define HTTPFS_CURL_VARS_RELEASE \
	curl_slist_free_all(headers);
#define HTTPFS_CURL_EXEC \
	pWrkrData-&gt;reply = NULL; \
	pWrkrData-&gt;replyLen = 0; \
	curl_easy_setopt(pWrkrData-&gt;curl, CURLOPT_WRITEDATA, pWrkrData); \
	curl_easy_setopt(pWrkrData-&gt;curl, CURLOPT_WRITEFUNCTION, httpfs_curl_result_callback); \
	res = curl_easy_perform(pWrkrData-&gt;curl); \
	if (res == CURLE_OK) { \
	    curl_easy_getinfo(pWrkrData-&gt;curl, CURLINFO_CONTENT_TYPE, &amp;content_type); \
	    if (strncmp(content_type, HTTPFS_CONTENT_TYPE_JSON, strlen(HTTPFS_CONTENT_TYPE_JSON))) { \
	    } \
	    curl_easy_getinfo(pWrkrData-&gt;curl, CURLINFO_RESPONSE_CODE, &amp;response_code); \
	    if (pWrkrData-&gt;reply != NULL) { \
	        pWrkrData-&gt;reply[pWrkrData-&gt;replyLen] = '\0'; \
	    } \
	} else { \
	LogError(0, RS_RET_ERR, "CURL request fail, code=%d, error string=%s\n", res, curl_easy_strerror(res)); \
	    return -1; \
	}
static rsRetVal
httpfs_parse_exception(char* buf, int length, httpfs_json_remote_exception* jre)
{
	DEFiRet;
	if (!length) {
	    return RS_RET_JSON_PARSE_ERR;
	}
	struct json_tokener* jt = json_tokener_new();
	json_tokener_reset(jt);
	struct json_object *json;
	json = json_tokener_parse_ex(jt, buf, length);
	if (!json_object_is_type(json, json_type_object)) {
		ABORT_FINALIZE(RS_RET_JSON_PARSE_ERR);
	}
	if (!json_object_object_get_ex(json, "RemoteException", &amp;json)) {
	ABORT_FINALIZE(RS_RET_JSON_PARSE_ERR);
	}
	struct json_object *jobj;
	memset(jre, 0, sizeof(*jre));
	const char *str;
	json_object_object_get_ex(json, "javaClassName", &amp;jobj);
	str = json_object_get_string(jobj);
	strncpy(jre-&gt;class, str, sizeof(jre-&gt;class));
	jre-&gt;class[sizeof(jre-&gt;class)-1] = '\0';
	json_object_object_get_ex(json, "exception", &amp;jobj);
	str = json_object_get_string(jobj);
	strncpy(jre-&gt;exception, str, sizeof(jre-&gt;exception));
	jre-&gt;exception[sizeof(jre-&gt;exception)-1] = '\0';
	json_object_object_get_ex(json, "message", &amp;jobj);
	str = json_object_get_string(jobj);
	strncpy(jre-&gt;message, str, sizeof(jre-&gt;message));
	jre-&gt;message[sizeof(jre-&gt;message)-1] = '\0';
finalize_it:
	if(jt != NULL)
		json_tokener_free(jt);
	if(json != NULL)
		json_object_put(json);
	RETiRet;
}
static rsRetVal
httpfs_create_file(wrkrInstanceData_t *pWrkrData, uchar* buf)
{
HTTPFS_CURL_VARS_INIT
	DBGPRINTF("%s(): file=%s\n", __FUNCTION__, pWrkrData-&gt;file);
	httpfs_curl_set_put(pWrkrData-&gt;curl);
	httpfs_set_url(pWrkrData, "&amp;op=create&amp;overwrite=false&amp;data=true");
	curl_easy_setopt(pWrkrData-&gt;curl, CURLOPT_POSTFIELDS, (char*)buf);
	curl_easy_setopt(pWrkrData-&gt;curl, CURLOPT_POSTFIELDSIZE, strlen((char*) buf));
	DBGPRINTF("%s(): msg=%s\n", __FUNCTION__, buf);
	headers = httpfs_curl_add_header(headers, 1, HTTPFS_CONTENT_TYPE);
	curl_easy_setopt(pWrkrData-&gt;curl, CURLOPT_HTTPHEADER, headers);
HTTPFS_CURL_EXEC
	int success = 0;
	if (response_code == 201) {
	    success = 1;
	}
HTTPFS_CURL_VARS_RELEASE
	if (success) {
	    return RS_RET_OK;
	} else {
	    return RS_RET_FALSE;
	}
}
static rsRetVal
httpfs_append_file(wrkrInstanceData_t *pWrkrData, uchar* buf)
{
HTTPFS_CURL_VARS_INIT
	DBGPRINTF("%s(): file=%s\n", __FUNCTION__, pWrkrData-&gt;file);
	httpfs_curl_set_post(pWrkrData-&gt;curl);
	httpfs_set_url(pWrkrData, "&amp;op=append&amp;data=true");
	curl_easy_setopt(pWrkrData-&gt;curl, CURLOPT_POSTFIELDS, (char*)buf);
	curl_easy_setopt(pWrkrData-&gt;curl, CURLOPT_POSTFIELDSIZE, strlen((char*) buf));
	headers = httpfs_curl_add_header(headers, 1, HTTPFS_CONTENT_TYPE);
	curl_easy_setopt(pWrkrData-&gt;curl, CURLOPT_HTTPHEADER, headers);
	DBGPRINTF("%s(): msg=%s\n", __FUNCTION__, buf);
HTTPFS_CURL_EXEC
	int success = 0;
	if (response_code == 200) {
	    success = 1;
	} else if (response_code == 404) {
	}
HTTPFS_CURL_VARS_RELEASE
	if (success) {
	    return RS_RET_OK;
	} else {
	    return RS_RET_FALSE;
	}
}
static rsRetVal
httpfs_log(wrkrInstanceData_t *pWrkrData, uchar* buf)
{
	DEFiRet;
	long response_code;
	httpfs_json_remote_exception jre;
	iRet = httpfs_append_file(pWrkrData, buf);
	if (iRet == RS_RET_OK) {
	    DBGPRINTF("omhttpfs: Append success: %s\n", pWrkrData-&gt;file);
	    return RS_RET_OK;
	}
	curl_easy_getinfo(pWrkrData-&gt;curl, CURLINFO_RESPONSE_CODE, &amp;response_code);
	if (response_code != 404) {
	    DBGPRINTF("omhttpfs: Append fail HTTP %ld: %s\n", response_code, pWrkrData-&gt;file);
	    return RS_RET_FALSE;
	}
	iRet = httpfs_create_file(pWrkrData, buf);
	if (iRet == RS_RET_OK) {
	    DBGPRINTF("omhttpfs: Create file success: %s\n", pWrkrData-&gt;file);
	    return RS_RET_OK;
	}
	curl_easy_getinfo(pWrkrData-&gt;curl, CURLINFO_RESPONSE_CODE, &amp;response_code);
	if (response_code == 201) {
	    DBGPRINTF("omhttpfs: Create file success HTTP 201: %s\n", pWrkrData-&gt;file);
	    return RS_RET_OK;
	}
	if (response_code == 500) {
	    DBGPRINTF("omhttpfs: Create file failed HTTP %ld: %s\n", response_code, pWrkrData-&gt;file);
	    httpfs_parse_exception(pWrkrData-&gt;reply, pWrkrData-&gt;replyLen, &amp;jre);
	    if (!strncmp(jre.exception, HTTPFS_FILEALREADYEXISTSEXCEPTION, strlen(HTTPFS_FILEALREADYEXISTSEXCEPTION))) {
	        DBGPRINTF("omhttpfs: File already exists, append again: %s\n", pWrkrData-&gt;file);
	        iRet = httpfs_append_file(pWrkrData, buf);
	        if (iRet == RS_RET_OK) {
	            DBGPRINTF("omhttpfs: Re-Append success: %s\n", pWrkrData-&gt;file);
	            return RS_RET_OK;
	        } else {
	            DBGPRINTF("omhttpfs: Re-Append failed: %s\n", pWrkrData-&gt;file);
	        }
	    } else {
	        DBGPRINTF("omhttpfs: Create file failed: %s %s\n", pWrkrData-&gt;file, pWrkrData-&gt;reply);
	    }
	} else {
	    DBGPRINTF("omhttpfs: Create file failed: %s %s\n", pWrkrData-&gt;file, pWrkrData-&gt;reply);
	}
	return RS_RET_FALSE;
}
BEGINinitConfVars
	CODESTARTinitConfVars
ENDinitConfVars
BEGINcreateInstance
CODESTARTcreateInstance
	DBGPRINTF("omhttpfs: createInstance\n");
ENDcreateInstance
BEGINcreateWrkrInstance
CODESTARTcreateWrkrInstance
	DBGPRINTF("omhttpfs: createWrkrInstance\n");
	pWrkrData-&gt;curl = NULL;
	iRet = httpfs_init_curl(pWrkrData, pWrkrData-&gt;pData);
	DBGPRINTF("omhttpfs: createWrkrInstance,pData %p/%p, pWrkrData %p\n",
	pData, pWrkrData-&gt;pData, pWrkrData);
ENDcreateWrkrInstance
BEGINisCompatibleWithFeature
CODESTARTisCompatibleWithFeature
	if(eFeat == sFEATURERepeatedMsgReduction)
	    iRet = RS_RET_OK;
ENDisCompatibleWithFeature
BEGINfreeInstance
CODESTARTfreeInstance
	free(pData-&gt;file);
	free(pData-&gt;tplName);
	free(pData-&gt;host);
	free(pData-&gt;user);
ENDfreeInstance
BEGINfreeWrkrInstance
CODESTARTfreeWrkrInstance
	free(pWrkrData-&gt;file);
	if(pWrkrData-&gt;curl) {
	    curl_easy_cleanup(pWrkrData-&gt;curl);
	    pWrkrData-&gt;curl = NULL;
	}
ENDfreeWrkrInstance
BEGINdbgPrintInstInfo
CODESTARTdbgPrintInstInfo
	DBGPRINTF("OmHTTPFS\n");
	DBGPRINTF("Version: %s\n", OMHTTPFS_VERSION);
	DBGPRINTF("\tHost: %s\n", pData-&gt;host);
	DBGPRINTF("\tPort: %d\n", pData-&gt;port);
	DBGPRINTF("\tUser: %s\n", pData-&gt;user);
	DBGPRINTF("\tFile: %s\n", pData-&gt;file);
ENDdbgPrintInstInfo
BEGINtryResume
CODESTARTtryResume
	DBGPRINTF("omhttpfs: tryResume called\n");
	iRet = RS_RET_OK;
ENDtryResume
BEGINdoAction
CODESTARTdoAction
	DBGPRINTF("omhttpfs: doAction\n");
	if (pWrkrData-&gt;pData-&gt;isDynFile) {
	    pWrkrData-&gt;file = ustrdup(ppString[1]);
	} else {
	    pWrkrData-&gt;file = ustrdup(pWrkrData-&gt;pData-&gt;file);
	}
	iRet = httpfs_log(pWrkrData, ppString[0]);
	if(iRet != RS_RET_OK) {
	    DBGPRINTF("omhttpfs: error writing httpfs, suspending\n");
	    iRet = RS_RET_SUSPENDED;
	}
ENDdoAction
static void
setInstParamDefaults(instanceData *pData)
{
	pData-&gt;host = (uchar*) strdup(OMHTTPFS_DEFAULT_HOST);
	pData-&gt;port = OMHTTPFS_DEFAULT_PORT;
	pData-&gt;user = (uchar*) strdup(OMHTTPFS_DEFAULT_USER);
	pData-&gt;https = 0;
	pData-&gt;file = NULL;
	pData-&gt;isDynFile = 0;
	pData-&gt;tplName = NULL;
}
BEGINnewActInst
	struct cnfparamvals *pvals;
	int i;
	uchar *tplToUse;
CODESTARTnewActInst
	if((pvals = nvlstGetParams(lst, &amp;actpblk, NULL)) == NULL) {
	    ABORT_FINALIZE(RS_RET_MISSING_CNFPARAMS);
	}
	CHKiRet(createInstance(&amp;pData));
	setInstParamDefaults(pData);
	for(i = 0 ; i &lt; actpblk.nParams ; ++i) {
	    if(!pvals[i].bUsed)
	        continue;
	    if(!strcmp(actpblk.descr[i].name, "host")) {
	        pData-&gt;host = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
	    } else if(!strcmp(actpblk.descr[i].name, "port")) {
	        pData-&gt;port = (int) pvals[i].val.d.n;
	    } else if(!strcmp(actpblk.descr[i].name, "user")) {
	        pData-&gt;user = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
	    } else if(!strcmp(actpblk.descr[i].name, "https")) {
	        pData-&gt;https = pvals[i].val.d.n ? 1 : 0;
	    } else if(!strcmp(actpblk.descr[i].name, "file")) {
	        pData-&gt;file = (uchar *) es_str2cstr(pvals[i].val.d.estr, NULL);
	    } else if(!strcmp(actpblk.descr[i].name, "isdynfile")) {
	        pData-&gt;isDynFile = pvals[i].val.d.n ? 1 : 0;
	    } else if(!strcmp(actpblk.descr[i].name, "template")) {
	        pData-&gt;tplName = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
	    } else {
	        DBGPRINTF("omhttpfs: program error, non-handled param '%s'\n", actpblk.descr[i].name);
	    }
	}
	if(pData-&gt;file == NULL) {
	    LogError(0, RS_RET_INTERNAL_ERROR, "omhttpfs: file is not set "
		"[this should not be possible]\n");
	ABORT_FINALIZE(RS_RET_INTERNAL_ERROR);
	}
	if(pData-&gt;user == NULL || pData-&gt;user[0] == '\0') {
	    pData-&gt;user = ustrdup((uchar*) OMHTTPFS_DEFAULT_USER);
	}
	if(pData-&gt;host == NULL || pData-&gt;host[0] == '\0') {
	    pData-&gt;host = ustrdup((uchar*) OMHTTPFS_DEFAULT_HOST);
	}
	if (pData-&gt;isDynFile) {
	    CODE_STD_STRING_REQUESTparseSelectorAct(2)
	    CHKiRet(OMSRsetEntry(*ppOMSR, 1, ustrdup(pData-&gt;file), OMSR_NO_RQD_TPL_OPTS));
	} else {
	    CODE_STD_STRING_REQUESTparseSelectorAct(1)
	}
	tplToUse = ustrdup((pData-&gt;tplName == NULL) ? (uchar* ) "RSYSLOG_FileFormat" : pData-&gt;tplName);
	iRet = OMSRsetEntry(*ppOMSR, 0, tplToUse, OMSR_NO_RQD_TPL_OPTS);
CODE_STD_FINALIZERnewActInst
	cnfparamvalsDestruct(pvals, &amp;actpblk);
ENDnewActInst
NO_LEGACY_CONF_parseSelectorAct
BEGINmodExit
CODESTARTmodExit
	curl_global_cleanup();
	objRelease(datetime, CORE_COMPONENT);
	objRelease(glbl, CORE_COMPONENT);
ENDmodExit
BEGINqueryEtryPt
CODESTARTqueryEtryPt
	CODEqueryEtryPt_STD_OMOD_QUERIES
	CODEqueryEtryPt_STD_CONF2_OMOD_QUERIES
	CODEqueryEtryPt_STD_OMOD8_QUERIES
	CODEqueryEtryPt_STD_CONF2_CNFNAME_QUERIES
ENDqueryEtryPt
BEGINmodInit()
CODESTARTmodInit
INITLegCnfVars
	*ipIFVersProvided = CURR_MOD_IF_VERSION; CODEmodInit_QueryRegCFSLineHdlr
	CHKiRet(objUse(glbl, CORE_COMPONENT));
	CHKiRet(objUse(datetime, CORE_COMPONENT));
	if (curl_global_init(CURL_GLOBAL_ALL) != 0) {
	    LogError(0, RS_RET_OBJ_CREATION_FAILED, "CURL fail. -httpfs module init failed");
	    ABORT_FINALIZE(RS_RET_OBJ_CREATION_FAILED);
	}
	DBGPRINTF("omhttpfs version %s is initializing\n", OMHTTPFS_VERSION);
ENDmodInit
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>ruleset.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
#include "config.h"
#include &lt;stdlib.h&gt;
#include &lt;assert.h&gt;
#include &lt;ctype.h&gt;
#include "rsyslog.h"
#include "obj.h"
#include "cfsysline.h"
#include "msg.h"
#include "ruleset.h"
#include "errmsg.h"
#include "parser.h"
#include "batch.h"
#include "unicode-helper.h"
#include "rsconf.h"
#include "action.h"
#include "rainerscript.h"
#include "srUtils.h"
#include "modules.h"
#include "wti.h"
#include "dirty.h" 
DEFobjStaticHelpers
DEFobjCurrIf(parser)
<a name="0"></a>
static struct cnfparamdescr rspdescr[] = {
<font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>	{ "name", eCmdHdlrString, CNFPARAM_REQUIRED },
	{ "parser", eCmdHdlrArray, 0 }
};
static struct cnfparamblk rspblk =
	{ CNFPARAMBLK_VERSION,
	  sizeof(rspdescr)/sizeof(struct cnfparamdescr),
	  rspdescr
	};
static rsRetVal processBatch(batch_t *pBatch, wti_t *pWti);</b></font>
static rsRetVal scriptExec(struct cnfstmt *root, smsg_t *pMsg, wti_t *pWti);
rsRetVal
rulesetKeyDestruct(void __attribute__((unused)) *pData)
{
	free(pData);
	return RS_RET_OK;
}
static void
scriptIterateAllActions(struct cnfstmt *root, rsRetVal (*pFunc)(void*, void*), void* pParam)
{
	struct cnfstmt *stmt;
	for(stmt = root ; stmt != NULL ; stmt = stmt-&gt;next) {
		switch(stmt-&gt;nodetype) {
		case S_NOP:
		case S_STOP:
		case S_SET:
		case S_UNSET:
		case S_CALL_INDIRECT:
		case S_CALL:			break;
		case S_ACT:
			DBGPRINTF("iterateAllActions calling into action %p\n", stmt-&gt;d.act);
			pFunc(stmt-&gt;d.act, pParam);
			break;
		case S_IF:
			if(stmt-&gt;d.s_if.t_then != NULL)
				scriptIterateAllActions(stmt-&gt;d.s_if.t_then,
							pFunc, pParam);
			if(stmt-&gt;d.s_if.t_else != NULL)
				scriptIterateAllActions(stmt-&gt;d.s_if.t_else,
							pFunc, pParam);
			break;
		case S_FOREACH:
			if(stmt-&gt;d.s_foreach.body != NULL)
				scriptIterateAllActions(stmt-&gt;d.s_foreach.body,
							pFunc, pParam);
			break;
		case S_PRIFILT:
			if(stmt-&gt;d.s_prifilt.t_then != NULL)
				scriptIterateAllActions(stmt-&gt;d.s_prifilt.t_then,
							pFunc, pParam);
			if(stmt-&gt;d.s_prifilt.t_else != NULL)
				scriptIterateAllActions(stmt-&gt;d.s_prifilt.t_else,
							pFunc, pParam);
			break;
		case S_PROPFILT:
			scriptIterateAllActions(stmt-&gt;d.s_propfilt.t_then,
						pFunc, pParam);
			break;
		case S_RELOAD_LOOKUP_TABLE: 			break;
		default:
			dbgprintf("error: unknown stmt type %u during iterateAll\n",
				(unsigned) stmt-&gt;nodetype);
			#ifndef NDEBUG
				fprintf(stderr, "error: unknown stmt type %u during iterateAll\n",
					(unsigned) stmt-&gt;nodetype);
			#endif
			assert(0); 			break;
		}
	}
}
typedef struct iterateAllActions_s {
	rsRetVal (*pFunc)(void*, void*);
	void *pParam;
} iterateAllActions_t;
DEFFUNC_llExecFunc(doIterateAllActions)
{
	DEFiRet;
	ruleset_t* pThis = (ruleset_t*) pData;
	iterateAllActions_t *pMyParam = (iterateAllActions_t*) pParam;
	scriptIterateAllActions(pThis-&gt;root, pMyParam-&gt;pFunc, pMyParam-&gt;pParam);
	RETiRet;
}
static rsRetVal
iterateAllActions(rsconf_t *conf, rsRetVal (*pFunc)(void*, void*), void* pParam)
{
	iterateAllActions_t params;
	DEFiRet;
	assert(pFunc != NULL);
	params.pFunc = pFunc;
	params.pParam = pParam;
	CHKiRet(llExecFunc(&amp;(conf-&gt;rulesets.llRulesets), doIterateAllActions, &amp;params));
finalize_it:
	RETiRet;
}
DEFFUNC_llExecFunc(doActivateRulesetQueues)
{
	DEFiRet;
	ruleset_t* pThis = (ruleset_t*) pData;
	dbgprintf("Activating Ruleset Queue[%p] for Ruleset %s\n",
		  pThis-&gt;pQueue, pThis-&gt;pszName);
	if(pThis-&gt;pQueue != NULL)
		startMainQueue(runConf, pThis-&gt;pQueue);
	RETiRet;
}
rsRetVal
activateRulesetQueues(void)
{
	llExecFunc(&amp;(runConf-&gt;rulesets.llRulesets), doActivateRulesetQueues, NULL);
	return RS_RET_OK;
}
static rsRetVal
execAct(struct cnfstmt *stmt, smsg_t *pMsg, wti_t *pWti)
{
	DEFiRet;
	if(stmt-&gt;d.act-&gt;bDisabled) {
		DBGPRINTF("action %d died, do NOT execute\n", stmt-&gt;d.act-&gt;iActionNbr);
		FINALIZE;
	}
	DBGPRINTF("executing action %d\n", stmt-&gt;d.act-&gt;iActionNbr);
	stmt-&gt;d.act-&gt;submitToActQ(stmt-&gt;d.act, pWti, pMsg);
	if(iRet != RS_RET_DISCARDMSG) {
		iRet = RS_RET_OK;
	}
finalize_it:
	RETiRet;
}
static rsRetVal ATTR_NONNULL()
execSet(const struct cnfstmt *const stmt,
	smsg_t *const pMsg,
	wti_t *const __restrict__ pWti)
{
	struct svar result;
	DEFiRet;
	cnfexprEval(stmt-&gt;d.s_set.expr, &amp;result, pMsg, pWti);
	msgSetJSONFromVar(pMsg, stmt-&gt;d.s_set.varname, &amp;result, stmt-&gt;d.s_set.force_reset);
	varDelete(&amp;result);
	RETiRet;
}
static rsRetVal
execUnset(struct cnfstmt *stmt, smsg_t *pMsg)
{
	DEFiRet;
	msgDelJSON(pMsg, stmt-&gt;d.s_unset.varname);
	RETiRet;
}
static rsRetVal
execCallIndirect(struct cnfstmt *const __restrict__ stmt,
	smsg_t *pMsg,
	wti_t *const __restrict__ pWti)
{
	ruleset_t *pRuleset;
	struct svar result;
	int bMustFree; 	DEFiRet;
	assert(stmt-&gt;d.s_call_ind.expr != NULL);
	cnfexprEval(stmt-&gt;d.s_call_ind.expr, &amp;result, pMsg, pWti);
	uchar *const rsName = (uchar*) var2CString(&amp;result, &amp;bMustFree);
	const rsRetVal localRet = rulesetGetRuleset(runConf, &amp;pRuleset, rsName);
	if(localRet != RS_RET_OK) {
		LogError(0, RS_RET_RULESET_NOT_FOUND, "error: CALL_INDIRECT: "
			"ruleset '%s' cannot be found, treating as NOP\n", rsName);
		FINALIZE;
	}
	DBGPRINTF("CALL_INDIRECT obtained ruleset ptr %p for ruleset '%s' [hasQueue:%d]\n",
		  pRuleset, rsName, rulesetHasQueue(pRuleset));
	if(rulesetHasQueue(pRuleset)) {
		CHKmalloc(pMsg = MsgDup((smsg_t*) pMsg));
		DBGPRINTF("CALL_INDIRECT: forwarding message to async ruleset %p\n",
			  pRuleset-&gt;pQueue);
		MsgSetFlowControlType(pMsg, eFLOWCTL_NO_DELAY);
		MsgSetRuleset(pMsg, pRuleset);
		submitMsg2(pMsg);
	} else {
		CHKiRet(scriptExec(pRuleset-&gt;root, pMsg, pWti));
	}
finalize_it:
	varDelete(&amp;result);
	free(rsName);
	RETiRet;
}
static rsRetVal
execCall(struct cnfstmt *stmt, smsg_t *pMsg, wti_t *pWti)
{
	DEFiRet;
	if(stmt-&gt;d.s_call.ruleset == NULL) {
		CHKiRet(scriptExec(stmt-&gt;d.s_call.stmt, pMsg, pWti));
	} else {
		CHKmalloc(pMsg = MsgDup((smsg_t*) pMsg));
		DBGPRINTF("CALL: forwarding message to async ruleset %p\n",
			  stmt-&gt;d.s_call.ruleset-&gt;pQueue);
		MsgSetFlowControlType(pMsg, eFLOWCTL_NO_DELAY);
		MsgSetRuleset(pMsg, stmt-&gt;d.s_call.ruleset);
		submitMsg2(pMsg);
	}
finalize_it:
	RETiRet;
}
static rsRetVal
execIf(struct cnfstmt *const stmt, smsg_t *const pMsg, wti_t *const pWti)
{
	sbool bRet;
	DEFiRet;
	bRet = cnfexprEvalBool(stmt-&gt;d.s_if.expr, pMsg, pWti);
	DBGPRINTF("if condition result is %d\n", bRet);
	if(bRet) {
		if(stmt-&gt;d.s_if.t_then != NULL)
			CHKiRet(scriptExec(stmt-&gt;d.s_if.t_then, pMsg, pWti));
	} else {
		if(stmt-&gt;d.s_if.t_else != NULL)
			CHKiRet(scriptExec(stmt-&gt;d.s_if.t_else, pMsg, pWti));
	}
finalize_it:
	RETiRet;
}
static rsRetVal
invokeForeachBodyWith(struct cnfstmt *stmt, json_object *o, smsg_t *pMsg, wti_t *pWti) {
	struct svar v;
	v.datatype = 'J';
	v.d.json = o;
	DEFiRet;
	CHKiRet(msgSetJSONFromVar(pMsg, (uchar*)stmt-&gt;d.s_foreach.iter-&gt;var, &amp;v, 1));
	CHKiRet(scriptExec(stmt-&gt;d.s_foreach.body, pMsg, pWti));
finalize_it:
	RETiRet;
}
static rsRetVal
callForeachArray(struct cnfstmt *stmt, json_object *arr, smsg_t *pMsg, wti_t *pWti) {
	DEFiRet;
	int len = json_object_array_length(arr);
	json_object *curr;
	for (int i = 0; i &lt; len; i++) {
		curr = json_object_array_get_idx(arr, i);
		CHKiRet(invokeForeachBodyWith(stmt, curr, pMsg, pWti));
	}
finalize_it:
	RETiRet;
}
static rsRetVal
callForeachObject(struct cnfstmt *stmt, json_object *arr, smsg_t *pMsg, wti_t *pWti) {
	json_object *entry = NULL;
	json_object *key = NULL;
	const char **keys = NULL;
	json_object *curr = NULL;
	const char **curr_key;
	struct json_object_iterator it;
	struct json_object_iterator itEnd;
	DEFiRet;
	int len = json_object_object_length(arr);
	CHKmalloc(keys = calloc(len, sizeof(char*)));
	curr_key = keys;
	it = json_object_iter_begin(arr);
	itEnd = json_object_iter_end(arr);
	while (!json_object_iter_equal(&amp;it, &amp;itEnd)) {
		*curr_key = json_object_iter_peek_name(&amp;it);
		curr_key++;
		json_object_iter_next(&amp;it);
	}
	CHKmalloc(entry = json_object_new_object());
	for (int i = 0; i &lt; len; i++) {
		if (json_object_object_get_ex(arr, keys[i], &amp;curr)) {
			CHKmalloc(key = json_object_new_string(keys[i]));
			json_object_object_add(entry, "key", key);
			key = NULL;
			json_object_object_add(entry, "value", json_object_get(curr));
			CHKiRet(invokeForeachBodyWith(stmt, entry, pMsg, pWti));
		}
	}
finalize_it:
	if (keys != NULL) free(keys);
	if (entry != NULL) json_object_put(entry);
	assert(key == NULL);
	RETiRet;
}
static rsRetVal ATTR_NONNULL()
execForeach(struct cnfstmt *const stmt, smsg_t *const pMsg, wti_t *const pWti)
{
	json_object *arr = NULL;
	DEFiRet;
	arr = cnfexprEvalCollection(stmt-&gt;d.s_foreach.iter-&gt;collection, pMsg, pWti);
	if (arr == NULL) {
		DBGPRINTF("foreach loop skipped, as object to iterate upon is empty\n");
		FINALIZE;
	} else if (json_object_is_type(arr, json_type_array) &amp;&amp; json_object_array_length(arr) &gt; 0) {
		CHKiRet(callForeachArray(stmt, arr, pMsg, pWti));
	} else if (json_object_is_type(arr, json_type_object) &amp;&amp; json_object_object_length(arr) &gt; 0) {
		CHKiRet(callForeachObject(stmt, arr, pMsg, pWti));
	} else {
		DBGPRINTF("foreach loop skipped, as object to iterate upon is empty or is not an array\n");
		FINALIZE;
	}
	CHKiRet(msgDelJSON(pMsg, (uchar*)stmt-&gt;d.s_foreach.iter-&gt;var));
finalize_it:
	if (arr != NULL) json_object_put(arr);
	RETiRet;
}
static rsRetVal
execPRIFILT(struct cnfstmt *stmt, smsg_t *pMsg, wti_t *pWti)
{
	int bRet;
	DEFiRet;
	if( (stmt-&gt;d.s_prifilt.pmask[pMsg-&gt;iFacility] == TABLE_NOPRI) ||
	   ((stmt-&gt;d.s_prifilt.pmask[pMsg-&gt;iFacility]
		    &amp; (1&lt;&lt;pMsg-&gt;iSeverity)) == 0) )
		bRet = 0;
	else
		bRet = 1;
	DBGPRINTF("PRIFILT condition result is %d\n", bRet);
	if(bRet) {
		if(stmt-&gt;d.s_prifilt.t_then != NULL)
			CHKiRet(scriptExec(stmt-&gt;d.s_prifilt.t_then, pMsg, pWti));
	} else {
		if(stmt-&gt;d.s_prifilt.t_else != NULL)
			CHKiRet(scriptExec(stmt-&gt;d.s_prifilt.t_else, pMsg, pWti));
	}
finalize_it:
	RETiRet;
}
static int
evalPROPFILT(struct cnfstmt *stmt, smsg_t *pMsg)
{
	unsigned short pbMustBeFreed;
	uchar *pszPropVal;
	int bRet = 0;
	rs_size_t propLen;
	if(stmt-&gt;d.s_propfilt.prop.id == PROP_INVALID)
		goto done;
	pszPropVal = MsgGetProp(pMsg, NULL, &amp;stmt-&gt;d.s_propfilt.prop,
				&amp;propLen, &amp;pbMustBeFreed, NULL);
	switch(stmt-&gt;d.s_propfilt.operation ) {
	case FIOP_CONTAINS:
		if(rsCStrLocateInSzStr(stmt-&gt;d.s_propfilt.pCSCompValue, (uchar*) pszPropVal) != -1)
			bRet = 1;
		break;
	case FIOP_ISEMPTY:
		if(propLen == 0)
			bRet = 1; 		break;
	case FIOP_ISEQUAL:
		if(rsCStrSzStrCmp(stmt-&gt;d.s_propfilt.pCSCompValue,
				  pszPropVal, propLen) == 0)
			bRet = 1; 		break;
	case FIOP_STARTSWITH:
		if(rsCStrSzStrStartsWithCStr(stmt-&gt;d.s_propfilt.pCSCompValue,
				  pszPropVal, propLen) == 0)
			bRet = 1; 		break;
	case FIOP_REGEX:
		if(rsCStrSzStrMatchRegex(stmt-&gt;d.s_propfilt.pCSCompValue,
				(unsigned char*) pszPropVal, 0, &amp;stmt-&gt;d.s_propfilt.regex_cache) == RS_RET_OK)
			bRet = 1;
		break;
	case FIOP_EREREGEX:
		if(rsCStrSzStrMatchRegex(stmt-&gt;d.s_propfilt.pCSCompValue,
				  (unsigned char*) pszPropVal, 1, &amp;stmt-&gt;d.s_propfilt.regex_cache) == RS_RET_OK)
			bRet = 1;
		break;
	case FIOP_NOP:
	default:
		assert(stmt-&gt;d.s_propfilt.operation == FIOP_NOP);
		bRet = 1; 		break;
	}
	if(stmt-&gt;d.s_propfilt.isNegated)
		bRet = (bRet == 1) ?  0 : 1;
	if(Debug) {
		if(stmt-&gt;d.s_propfilt.prop.id == PROP_CEE) {
			DBGPRINTF("Filter: check for CEE property '%s' (value '%s') ",
				stmt-&gt;d.s_propfilt.prop.name, pszPropVal);
		} else if(stmt-&gt;d.s_propfilt.prop.id == PROP_LOCAL_VAR) {
			DBGPRINTF("Filter: check for local var '%s' (value '%s') ",
				stmt-&gt;d.s_propfilt.prop.name, pszPropVal);
		} else if(stmt-&gt;d.s_propfilt.prop.id == PROP_GLOBAL_VAR) {
			DBGPRINTF("Filter: check for global var '%s' (value '%s') ",
				stmt-&gt;d.s_propfilt.prop.name, pszPropVal);
		} else {
			DBGPRINTF("Filter: check for property '%s' (value '%s') ",
				propIDToName(stmt-&gt;d.s_propfilt.prop.id), pszPropVal);
		}
		if(stmt-&gt;d.s_propfilt.isNegated)
			DBGPRINTF("NOT ");
		if(stmt-&gt;d.s_propfilt.operation == FIOP_ISEMPTY) {
			DBGPRINTF("%s : %s\n",
			       getFIOPName(stmt-&gt;d.s_propfilt.operation),
			       bRet ? "TRUE" : "FALSE");
		} else {
			DBGPRINTF("%s '%s': %s\n",
			       getFIOPName(stmt-&gt;d.s_propfilt.operation),
			       rsCStrGetSzStrNoNULL(stmt-&gt;d.s_propfilt.pCSCompValue),
			       bRet ? "TRUE" : "FALSE");
		}
	}
	if(pbMustBeFreed)
		free(pszPropVal);
done:
	return bRet;
}
static rsRetVal
execPROPFILT(struct cnfstmt *stmt, smsg_t *pMsg, wti_t *pWti)
{
	sbool bRet;
	DEFiRet;
	bRet = evalPROPFILT(stmt, pMsg);
	DBGPRINTF("PROPFILT condition result is %d\n", bRet);
	if(bRet)
		CHKiRet(scriptExec(stmt-&gt;d.s_propfilt.t_then, pMsg, pWti));
finalize_it:
	RETiRet;
}
static rsRetVal ATTR_NONNULL()
execReloadLookupTable(struct cnfstmt *stmt)
{
	assert(stmt != NULL);
	lookup_ref_t *t;
	DEFiRet;
	t = stmt-&gt;d.s_reload_lookup_table.table;
	if (t == NULL) {
		ABORT_FINALIZE(RS_RET_NONE);
	}
	iRet = lookupReload(t, stmt-&gt;d.s_reload_lookup_table.stub_value);
finalize_it:
	RETiRet;
}
static rsRetVal ATTR_NONNULL(2, 3)
scriptExec(struct cnfstmt *const root, smsg_t *const pMsg, wti_t *const pWti)
{
	struct cnfstmt *stmt;
	DEFiRet;
	for(stmt = root ; stmt != NULL ; stmt = stmt-&gt;next) {
		if(*pWti-&gt;pbShutdownImmediate) {
			DBGPRINTF("scriptExec: ShutdownImmediate set, "
				  "force terminating\n");
			ABORT_FINALIZE(RS_RET_FORCE_TERM);
		}
		if(Debug) {
			cnfstmtPrintOnly(stmt, 2, 0);
		}
		switch(stmt-&gt;nodetype) {
		case S_NOP:
			break;
		case S_STOP:
			ABORT_FINALIZE(RS_RET_DISCARDMSG);
			break;
		case S_ACT:
			CHKiRet(execAct(stmt, pMsg, pWti));
			break;
		case S_SET:
			CHKiRet(execSet(stmt, pMsg, pWti));
			break;
		case S_UNSET:
			CHKiRet(execUnset(stmt, pMsg));
			break;
		case S_CALL:
			CHKiRet(execCall(stmt, pMsg, pWti));
			break;
		case S_CALL_INDIRECT:
			CHKiRet(execCallIndirect(stmt, pMsg, pWti));
			break;
		case S_IF:
			CHKiRet(execIf(stmt, pMsg, pWti));
			break;
		case S_FOREACH:
			CHKiRet(execForeach(stmt, pMsg, pWti));
			break;
		case S_PRIFILT:
			CHKiRet(execPRIFILT(stmt, pMsg, pWti));
			break;
		case S_PROPFILT:
			CHKiRet(execPROPFILT(stmt, pMsg, pWti));
			break;
		case S_RELOAD_LOOKUP_TABLE:
			CHKiRet(execReloadLookupTable(stmt));
			break;
		default:
			dbgprintf("error: unknown stmt type %u during exec\n",
				(unsigned) stmt-&gt;nodetype);
			break;
		}
	}
finalize_it:
	RETiRet;
}
static rsRetVal
processBatch(batch_t *pBatch, wti_t *pWti)
{
	int i;
	smsg_t *pMsg;
	ruleset_t *pRuleset;
	rsRetVal localRet;
	DEFiRet;
	DBGPRINTF("processBATCH: batch of %d elements must be processed\n", pBatch-&gt;nElem);
	wtiResetExecState(pWti, pBatch);
	for(i = 0 ; i &lt; batchNumMsgs(pBatch) &amp;&amp; !*(pWti-&gt;pbShutdownImmediate) ; ++i) {
		pMsg = pBatch-&gt;pElem[i].pMsg;
		DBGPRINTF("processBATCH: next msg %d: %.128s\n", i, pMsg-&gt;pszRawMsg);
		pRuleset = (pMsg-&gt;pRuleset == NULL) ? runConf-&gt;rulesets.pDflt : pMsg-&gt;pRuleset;
		localRet = scriptExec(pRuleset-&gt;root, pMsg, pWti);
		if(localRet == RS_RET_OK)
			batchSetElemState(pBatch, i, BATCH_STATE_COMM);
		else if(localRet == RS_RET_SUSPENDED)
			--i;
	}
	DBGPRINTF("END batch execution phase, entering to commit phase "
		"[processed %d of %d messages]\n", i, batchNumMsgs(pBatch));
	actionCommitAllDirect(pWti);
	DBGPRINTF("processBATCH: batch of %d elements has been processed\n", pBatch-&gt;nElem);
	RETiRet;
}
static parserList_t*
GetParserList(rsconf_t *conf, smsg_t *pMsg)
{
	return (pMsg-&gt;pRuleset == NULL) ? conf-&gt;rulesets.pDflt-&gt;pParserLst : pMsg-&gt;pRuleset-&gt;pParserLst;
}
static void ATTR_NONNULL(1)
addScript(ruleset_t *const pThis, struct cnfstmt *const script)
{
	if(script == NULL) 		return;
	if(pThis-&gt;last == NULL)
		pThis-&gt;root = pThis-&gt;last = script;
	else {
		pThis-&gt;last-&gt;next = script;
		pThis-&gt;last = script;
	}
}
static rsRetVal rulesetSetName(ruleset_t *pThis, uchar *pszName)
{
	DEFiRet;
	free(pThis-&gt;pszName);
	CHKmalloc(pThis-&gt;pszName = ustrdup(pszName));
finalize_it:
	RETiRet;
}
static ruleset_t*
GetCurrent(rsconf_t *conf)
{
	return conf-&gt;rulesets.pCurr;
}
static qqueue_t*
GetRulesetQueue(ruleset_t *pThis)
{
	ISOBJ_TYPE_assert(pThis, ruleset);
	return (pThis-&gt;pQueue == NULL) ? runConf-&gt;pMsgQueue : pThis-&gt;pQueue;
}
rsRetVal
rulesetGetRuleset(rsconf_t *conf, ruleset_t **ppRuleset, uchar *pszName)
{
	DEFiRet;
	assert(ppRuleset != NULL);
	assert(pszName != NULL);
	CHKiRet(llFind(&amp;(conf-&gt;rulesets.llRulesets), pszName, (void*) ppRuleset));
finalize_it:
	RETiRet;
}
static rsRetVal
SetDefaultRuleset(rsconf_t *conf, uchar *pszName)
{
	ruleset_t *pRuleset;
	DEFiRet;
	assert(pszName != NULL);
	CHKiRet(rulesetGetRuleset(conf, &amp;pRuleset, pszName));
	conf-&gt;rulesets.pDflt = pRuleset;
	DBGPRINTF("default rule set changed to %p: '%s'\n", pRuleset, pszName);
finalize_it:
	RETiRet;
}
static rsRetVal
SetCurrRuleset(rsconf_t *conf, uchar *pszName)
{
	ruleset_t *pRuleset;
	DEFiRet;
	assert(pszName != NULL);
	CHKiRet(rulesetGetRuleset(conf, &amp;pRuleset, pszName));
	conf-&gt;rulesets.pCurr = pRuleset;
	DBGPRINTF("current rule set changed to %p: '%s'\n", pRuleset, pszName);
finalize_it:
	RETiRet;
}
BEGINobjConstruct(ruleset) 	pThis-&gt;root = NULL;
	pThis-&gt;last = NULL;
ENDobjConstruct(ruleset)
static rsRetVal
rulesetConstructFinalize(rsconf_t *conf, ruleset_t *pThis)
{
	uchar *keyName;
	DEFiRet;
	ISOBJ_TYPE_assert(pThis, ruleset);
	CHKmalloc(keyName = ustrdup(pThis-&gt;pszName));
	CHKiRet(llAppend(&amp;(conf-&gt;rulesets.llRulesets), keyName, pThis));
	if(conf-&gt;rulesets.pDflt == NULL)
		conf-&gt;rulesets.pDflt = pThis;
finalize_it:
	RETiRet;
}
BEGINobjDestruct(ruleset) CODESTARTobjDestruct(ruleset)
	DBGPRINTF("destructing ruleset %p, name %p\n", pThis, pThis-&gt;pszName);
	if(pThis-&gt;pQueue != NULL) {
		qqueueDestruct(&amp;pThis-&gt;pQueue);
	}
	if(pThis-&gt;pParserLst != NULL) {
		parser.DestructParserList(&amp;pThis-&gt;pParserLst);
	}
	free(pThis-&gt;pszName);
ENDobjDestruct(ruleset)
DEFFUNC_llExecFunc(doShutdownQueueWorkers)
{
	DEFiRet;
	ruleset_t *const pThis = (ruleset_t*) pData;
	DBGPRINTF("shutting down queue workers for ruleset %p, name %s, queue %p\n",
		pThis, pThis-&gt;pszName, pThis-&gt;pQueue);
	ISOBJ_TYPE_assert(pThis, ruleset);
	if(pThis-&gt;pQueue != NULL) {
		qqueueShutdownWorkers(pThis-&gt;pQueue);
	}
	RETiRet;
}
DEFFUNC_llExecFunc(doDestructCnfStmt)
{
	DEFiRet;
	ruleset_t *const pThis = (ruleset_t*) pData;
	DBGPRINTF("shutting down actions and conf stmts for ruleset %p, name %s\n",
		pThis, pThis-&gt;pszName);
	ISOBJ_TYPE_assert(pThis, ruleset);
	cnfstmtDestructLst(pThis-&gt;root);
	RETiRet;
}
static rsRetVal
destructAllActions(rsconf_t *conf)
{
	DEFiRet;
	DBGPRINTF("rulesetDestructAllActions\n");
	DBGPRINTF("destructAllActions: queue shutdown\n");
	llExecFunc(&amp;(conf-&gt;rulesets.llRulesets), doShutdownQueueWorkers, NULL);
	DBGPRINTF("destructAllActions: action and conf stmt shutdown\n");
	llExecFunc(&amp;(conf-&gt;rulesets.llRulesets), doDestructCnfStmt, NULL);
	CHKiRet(llDestroy(&amp;(conf-&gt;rulesets.llRulesets)));
	CHKiRet(llInit(&amp;(conf-&gt;rulesets.llRulesets), rulesetDestructForLinkedList,
		rulesetKeyDestruct, strcasecmp));
	conf-&gt;rulesets.pDflt = NULL;
finalize_it:
	RETiRet;
}
rsRetVal
rulesetDestructForLinkedList(void *pData)
{
	ruleset_t *pThis = (ruleset_t*) pData;
	return rulesetDestruct(&amp;pThis);
}
BEGINobjDebugPrint(ruleset) CODESTARTobjDebugPrint(ruleset)
	dbgoprint((obj_t*) pThis, "rsyslog ruleset %s:\n", pThis-&gt;pszName);
	cnfstmtPrint(pThis-&gt;root, 0);
	dbgoprint((obj_t*) pThis, "ruleset %s assigned parser list:\n", pThis-&gt;pszName);
	printParserList(pThis-&gt;pParserLst);
ENDobjDebugPrint(ruleset)
DEFFUNC_llExecFunc(doDebugPrintAll)
{
	return rulesetDebugPrint((ruleset_t*) pData);
}
static rsRetVal
debugPrintAll(rsconf_t *conf)
{
	DEFiRet;
	dbgprintf("All Rulesets:\n");
	llExecFunc(&amp;(conf-&gt;rulesets.llRulesets), doDebugPrintAll, NULL);
	dbgprintf("End of Rulesets.\n");
	RETiRet;
}
struct cnfstmt * removeNOPs(struct cnfstmt *root);
static void
rulesetOptimize(ruleset_t *pRuleset)
{
	if(Debug) {
		dbgprintf("ruleset '%s' before optimization:\n",
			  pRuleset-&gt;pszName);
		rulesetDebugPrint((ruleset_t*) pRuleset);
	}
	pRuleset-&gt;root = cnfstmtOptimize(pRuleset-&gt;root);
	if(Debug) {
		dbgprintf("ruleset '%s' after optimization:\n",
			  pRuleset-&gt;pszName);
		rulesetDebugPrint((ruleset_t*) pRuleset);
	}
}
DEFFUNC_llExecFunc(doRulesetOptimizeAll)
{
	rulesetOptimize((ruleset_t*) pData);
	return RS_RET_OK;
}
rsRetVal
rulesetOptimizeAll(rsconf_t *conf)
{
	DEFiRet;
	dbgprintf("begin ruleset optimization phase\n");
	llExecFunc(&amp;(conf-&gt;rulesets.llRulesets), doRulesetOptimizeAll, NULL);
	dbgprintf("ruleset optimization phase finished.\n");
	RETiRet;
}
static rsRetVal
doRulesetCreateQueue(rsconf_t *conf, int *pNewVal)
{
	uchar *rsname;
	DEFiRet;
	if(conf-&gt;rulesets.pCurr == NULL) {
		LogError(0, RS_RET_NO_CURR_RULESET, "error: currently no specific ruleset specified, thus a "
				"queue can not be added to it");
		ABORT_FINALIZE(RS_RET_NO_CURR_RULESET);
	}
	if(conf-&gt;rulesets.pCurr-&gt;pQueue != NULL) {
		LogError(0, RS_RET_RULES_QUEUE_EXISTS, "error: ruleset already has a main queue, can not "
				"add another one");
		ABORT_FINALIZE(RS_RET_RULES_QUEUE_EXISTS);
	}
	if(pNewVal == 0)
		FINALIZE; 
	rsname = (conf-&gt;rulesets.pCurr-&gt;pszName == NULL) ? (uchar*) "[ruleset]" : conf-&gt;rulesets.pCurr-&gt;pszName;
	DBGPRINTF("adding a ruleset-specific \"main\" queue for ruleset '%s'\n", rsname);
	CHKiRet(createMainQueue(&amp;conf-&gt;rulesets.pCurr-&gt;pQueue, rsname, NULL));
finalize_it:
	RETiRet;
}
static rsRetVal
rulesetCreateQueue(void __attribute__((unused)) *pVal, int *pNewVal)
{
	return doRulesetCreateQueue(ourConf, pNewVal);
}
static rsRetVal
doRulesetAddParser(ruleset_t *pRuleset, uchar *pName)
{
	parser_t *pParser;
	DEFiRet;
	CHKiRet(objUse(parser, CORE_COMPONENT));
	iRet = parser.FindParser(loadConf-&gt;parsers.pParsLstRoot, &amp;pParser, pName);
	if(iRet == RS_RET_PARSER_NOT_FOUND) {
		LogError(0, RS_RET_PARSER_NOT_FOUND, "error: parser '%s' unknown at this time "
			  	"(maybe defined too late in rsyslog.conf?)", pName);
		ABORT_FINALIZE(RS_RET_NO_CURR_RULESET);
	} else if(iRet != RS_RET_OK) {
		LogError(0, iRet, "error trying to find parser '%s'\n", pName);
		FINALIZE;
	}
	CHKiRet(parser.AddParserToList(&amp;pRuleset-&gt;pParserLst, pParser));
	DBGPRINTF("added parser '%s' to ruleset '%s'\n", pName, pRuleset-&gt;pszName);
finalize_it:
	free(pName); 
	RETiRet;
}
static rsRetVal
rulesetAddParser(void __attribute__((unused)) *pVal, uchar *pName)
{
	return doRulesetAddParser(loadConf-&gt;rulesets.pCurr, pName);
}
rsRetVal
rulesetProcessCnf(struct cnfobj *o)
{
	struct cnfparamvals *pvals;
	rsRetVal localRet;
	uchar *rsName = NULL;
	uchar *parserName;
	int nameIdx, parserIdx;
	ruleset_t *pRuleset;
	struct cnfarray *ar;
	int i;
	int qtype;
	uchar *rsname;
	DEFiRet;
	pvals = nvlstGetParams(o-&gt;nvlst, &amp;rspblk, NULL);
	if(pvals == NULL) {
		ABORT_FINALIZE(RS_RET_CONFIG_ERROR);
	}
	DBGPRINTF("ruleset param blk after rulesetProcessCnf:\n");
	cnfparamsPrint(&amp;rspblk, pvals);
	nameIdx = cnfparamGetIdx(&amp;rspblk, "name");
	rsName = (uchar*)es_str2cstr(pvals[nameIdx].val.d.estr, NULL);
	localRet = rulesetGetRuleset(loadConf, &amp;pRuleset, rsName);
	if(localRet == RS_RET_OK) {
		LogError(0, RS_RET_RULESET_EXISTS,
			"error: ruleset '%s' specified more than once",
			rsName);
		cnfstmtDestructLst(o-&gt;script);
		ABORT_FINALIZE(RS_RET_RULESET_EXISTS);
	} else if(localRet != RS_RET_NOT_FOUND) {
		ABORT_FINALIZE(localRet);
	}
	CHKiRet(rulesetConstruct(&amp;pRuleset));
	if((localRet = rulesetSetName(pRuleset, rsName)) != RS_RET_OK) {
		rulesetDestruct(&amp;pRuleset);
		ABORT_FINALIZE(localRet);
	}
	if((localRet = rulesetConstructFinalize(loadConf, pRuleset)) != RS_RET_OK) {
		rulesetDestruct(&amp;pRuleset);
		ABORT_FINALIZE(localRet);
	}
	addScript(pRuleset, o-&gt;script);
	parserIdx = cnfparamGetIdx(&amp;rspblk, "parser");
	if(parserIdx != -1  &amp;&amp; pvals[parserIdx].bUsed) {
		ar = pvals[parserIdx].val.d.ar;
		for(i = 0 ; i &lt;  ar-&gt;nmemb ; ++i) {
			parserName = (uchar*)es_str2cstr(ar-&gt;arr[i], NULL);
			doRulesetAddParser(pRuleset, parserName);
		}
	}
	if(queueCnfParamsSet(o-&gt;nvlst)) {
		if(pRuleset-&gt;pszName == NULL) {
			rsname = (uchar*) "[ruleset]";
			qtype = pRuleset-&gt;pQueue-&gt;qType;
		} else {
			rsname = pRuleset-&gt;pszName;
			qtype = 3;
		}
		DBGPRINTF("adding a ruleset-specific \"main\" queue for ruleset '%s', mode %d\n",
			rsname, qtype);
		CHKiRet(createMainQueue(&amp;pRuleset-&gt;pQueue, rsname, o-&gt;nvlst));
	}
finalize_it:
	free(rsName);
	cnfparamvalsDestruct(pvals, &amp;rspblk);
	RETiRet;
}
BEGINobjQueryInterface(ruleset)
CODESTARTobjQueryInterface(ruleset)
	if(pIf-&gt;ifVersion != rulesetCURR_IF_VERSION) { 		ABORT_FINALIZE(RS_RET_INTERFACE_NOT_SUPPORTED);
	}
	pIf-&gt;Construct = rulesetConstruct;
	pIf-&gt;ConstructFinalize = rulesetConstructFinalize;
	pIf-&gt;Destruct = rulesetDestruct;
	pIf-&gt;DebugPrint = rulesetDebugPrint;
	pIf-&gt;IterateAllActions = iterateAllActions;
	pIf-&gt;DestructAllActions = destructAllActions;
	pIf-&gt;AddScript = addScript;
	pIf-&gt;ProcessBatch = processBatch;
	pIf-&gt;SetName = rulesetSetName;
	pIf-&gt;DebugPrintAll = debugPrintAll;
	pIf-&gt;GetCurrent = GetCurrent;
	pIf-&gt;GetRuleset = rulesetGetRuleset;
	pIf-&gt;SetDefaultRuleset = SetDefaultRuleset;
	pIf-&gt;SetCurrRuleset = SetCurrRuleset;
	pIf-&gt;GetRulesetQueue = GetRulesetQueue;
	pIf-&gt;GetParserList = GetParserList;
finalize_it:
ENDobjQueryInterface(ruleset)
BEGINObjClassExit(ruleset, OBJ_IS_CORE_MODULE) 	objRelease(parser, CORE_COMPONENT);
ENDObjClassExit(ruleset)
BEGINObjClassInit(ruleset, 1, OBJ_IS_CORE_MODULE) 
	OBJSetMethodHandler(objMethod_DEBUGPRINT, rulesetDebugPrint);
	OBJSetMethodHandler(objMethod_CONSTRUCTION_FINALIZER, rulesetConstructFinalize);
	CHKiRet(regCfSysLineHdlr((uchar *)"rulesetparser", 0, eCmdHdlrGetWord, rulesetAddParser, NULL, NULL));
	CHKiRet(regCfSysLineHdlr((uchar *)"rulesetcreatemainqueue", 0, eCmdHdlrBinary, rulesetCreateQueue,
		NULL, NULL));
ENDObjClassInit(ruleset)
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
