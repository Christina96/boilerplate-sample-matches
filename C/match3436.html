<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML><HEAD><TITLE>Matches for omhttpfs.c & ruleset.c</TITLE>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
</HEAD>
<body>
  <div style="align-items: center; display: flex; justify-content: space-around;">
    <div>
      <h3 align="center">
Matches for omhttpfs.c & ruleset.c
      </h3>
      <h1 align="center">
        2.4%
      </h1>
      <center>
        <a href="index.html" target="_top">
          INDEX
        </a>
        <span>-</span>
        <a href="help-en.html" target="_top">
          HELP
        </a>
      </center>
    </div>
    <div>
<TABLE BORDER="1" CELLSPACING="0" BGCOLOR="#d0d0d0">
<TR><TH><TH>omhttpfs.c (3.3096926%)<TH>ruleset.c (1.9774011%)<TH>Tokens
<TR><TD BGCOLOR="#0000ff"><FONT COLOR="#0000ff">-</FONT><TD><A HREF="javascript:ZweiFrames('match3436-0.html#0',2,'match3436-1.html#0',3)" NAME="0">(135-151)<TD><A HREF="javascript:ZweiFrames('match3436-0.html#0',2,'match3436-1.html#0',3)" NAME="0">(61-71)</A><TD ALIGN=center><FONT COLOR="#ff0000">14</FONT>
</TABLE>
    </div>
  </div>
  <hr>
  <div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>omhttpfs.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
/* omhttpfs.c
 * Send all output to HDFS via httpfs
 *
 * Author: sskaje (sskaje@gmail.com, http://sskaje.me/)
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *       -or-
 *       see COPYING.ASL20 in the source distribution
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#include &quot;config.h&quot;
#include &quot;rsyslog.h&quot;
#include &lt;stdio.h&gt;
#include &lt;stdarg.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;assert.h&gt;
#include &lt;signal.h&gt;
#include &lt;errno.h&gt;
#include &lt;unistd.h&gt;
#include &lt;curl/curl.h&gt;
#include &lt;json.h&gt;
#include &lt;json_object.h&gt;


#include &quot;conf.h&quot;
#include &quot;syslogd-types.h&quot;
#include &quot;srUtils.h&quot;
#include &quot;template.h&quot;
#include &quot;module-template.h&quot;
#include &quot;errmsg.h&quot;
#include &quot;cfsysline.h&quot;
#include &quot;datetime.h&quot;
#include &quot;statsobj.h&quot;
#include &quot;unicode-helper.h&quot;

MODULE_TYPE_OUTPUT
MODULE_TYPE_NOKEEP
MODULE_CNFNAME(&quot;omhttpfs&quot;)

/* internal structures
 */
DEF_OMOD_STATIC_DATA
DEFobjCurrIf(glbl)
DEFobjCurrIf(datetime)

/* local definitions */
#define OMHTTPFS_VERSION &quot;1.0&quot;
#define OMHTTPFS_DEFAULT_PORT 14000
#define OMHTTPFS_DEFAULT_USER &quot;hdfs&quot;
#define OMHTTPFS_DEFAULT_HOST &quot;127.0.0.1&quot;

#define HTTPFS_URL_PREFIX_V1     &quot;/webhdfs/v1&quot;
#define HTTPFS_URL_PREFIX_V1_SSL &quot;/swebhdfs/v1&quot;
#define HTTPFS_CONTENT_TYPE      &quot;Content-Type: application/octet-stream&quot;
#define HTTPFS_USER_AGENT        &quot;omhttpfs by sskaje/&quot; OMHTTPFS_VERSION

#define HTTPFS_CONTENT_TYPE_JSON &quot;application/json&quot;
#define HTTPFS_JSON_BOOLEAN_TRUE &quot;{\&quot;boolean\&quot;:true}&quot;

#define HTTPFS_FILEALREADYEXISTSEXCEPTION &quot;FileAlreadyExistsException&quot;

#define HTTPFS_URL_BUFFER_LENGTH 2048


/*
Examples:

module(load=&quot;omhttpfs&quot;)
template(name=&quot;hdfs_tmp_file&quot; type=&quot;string&quot; string=&quot;/tmp/%$YEAR%/test.log&quot;)
template(name=&quot;hdfs_tmp_filecontent&quot; type=&quot;string&quot; string=&quot;%$YEAR%-%$MONTH%-%$DAY% %MSG% ==\n&quot;)
local4.*    action(type=&quot;omhttpfs&quot; host=&quot;10.1.1.161&quot; port=&quot;14000&quot; https=&quot;off&quot; file=&quot;hdfs_tmp_file&quot; isDynFile=&quot;on&quot;)
local5.*    action(type=&quot;omhttpfs&quot; host=&quot;10.1.1.161&quot; port=&quot;14000&quot; https=&quot;off&quot; file=&quot;hdfs_tmp_file&quot; isDynFile=&quot;on&quot;
template=&quot;hdfs_tmp_filecontent&quot;)

*/

#define DPP(x) DBGPRINTF(&quot;OMHTTPFS: %s:%d %s(): %s\n&quot;, __FILE__, __LINE__, __FUNCTION__, x)

/**
 * Exception object
 *
 */
typedef struct _HTTPFS_JSON_REMOTE_EXCEPTION {
	char message[1024];
	char exception[256];
	char class[256];
} httpfs_json_remote_exception;


typedef struct _instanceData {
	sbool https;
	uchar* host;
	uchar* ip;
	int  port;
	uchar* user;

	int timeout;
	uchar* file;
	sbool isDynFile;

	uchar* tplName;
} instanceData;


typedef struct wrkrInstanceData {
	instanceData *pData;

	CURL* curl;

	uchar* file;

	int replyLen;
	char* reply;
} wrkrInstanceData_t;


/* tables for interfacing with the v6 config system */
/* action (instance) parameters */
static struct cnfparamdescr actpdescr[] = {
	{ &quot;host&quot;, eCmdHdlrGetWord, 0 },
	{ &quot;port&quot;, eCmdHdlrInt, 0 },
<A NAME="0"></A>	{ &quot;user&quot;, eCmdHdlrGetWord, 0 },
	{ &quot;https&quot;, eCmdHdlrBinary, 0 },
	{ &quot;file&quot;, eCmdHdlrGetWord, CNFPARAM_REQUIRED },
<FONT color="#0000ff"><A HREF="javascript:ZweiFrames('match3436-1.html#0',3,'match3436-top.html#0',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>	{ &quot;isdynfile&quot;, eCmdHdlrBinary, 0 },
	{ &quot;template&quot;, eCmdHdlrGetWord, 0 },
};
static struct cnfparamblk actpblk = {
	CNFPARAMBLK_VERSION,
	sizeof(actpdescr)/sizeof(struct cnfparamdescr),
	actpdescr
};

/**
 * curl init
 *
 * @param wrkrInstanceData_t *pWrkrData
 * @param instanceData *pData
 * @return rsRetVal
 */
static rsRetVal</B></FONT>
httpfs_init_curl(wrkrInstanceData_t *pWrkrData, instanceData *pData)
{
	CURL *curl = NULL;

	curl = curl_easy_init();

	if (curl) {
		curl_easy_setopt(curl, CURLOPT_VERBOSE, 0L);

		curl_easy_setopt(curl, CURLOPT_FOLLOWLOCATION, 1L);

		if (pData-&gt;https) {
			DBGPRINTF(&quot;%s(): Enable HTTPS\n&quot;, __FUNCTION__);
			/* for ssl */
			curl_easy_setopt(curl, CURLOPT_SSL_VERIFYPEER, 0L);
			curl_easy_setopt(curl, CURLOPT_SSL_VERIFYHOST, 0L);
		}
	} else {
		/* LOG */
		LogError(0, RS_RET_OBJ_CREATION_FAILED, &quot;omhttpfs: failed to init cURL\n&quot;);

		return RS_RET_OBJ_CREATION_FAILED;
	}

	curl_easy_setopt(curl, CURLOPT_USERAGENT, HTTPFS_USER_AGENT);

	pWrkrData-&gt;curl = curl;
	return RS_RET_OK;
}

/**
 * Build HTTPFS URL
 *
 * @param wrkrInstanceData_t *pWrkrData
 * @param char* op
 * @param es_str_t** url_buf
 * @return rsRetVal
 */
static rsRetVal
httpfs_build_url(wrkrInstanceData_t *pWrkrData, const char* op, es_str_t** url_buf)
{
	*url_buf = es_newStr(HTTPFS_URL_BUFFER_LENGTH);

	if (pWrkrData-&gt;pData-&gt;https) {
	    es_addBuf(url_buf, &quot;https://&quot;, sizeof(&quot;https://&quot;)-1);
	} else {
	    es_addBuf(url_buf, &quot;http://&quot;, sizeof(&quot;http://&quot;)-1);
	}

	/* host */
	es_addBuf(url_buf, (char* )pWrkrData-&gt;pData-&gt;host, strlen((char*)pWrkrData-&gt;pData-&gt;host));

	/* port */
	es_addChar(url_buf, ':');
	char portBuf[6];
	snprintf(portBuf, sizeof(portBuf), &quot;%d&quot;, pWrkrData-&gt;pData-&gt;port);
	es_addBuf(url_buf, portBuf, strlen(portBuf));

	/* prefix */
	es_addBuf(url_buf, HTTPFS_URL_PREFIX_V1, sizeof(HTTPFS_URL_PREFIX_V1)-1);

	/* path */
	if (pWrkrData-&gt;file[0] != '/') {
	    es_addChar(url_buf, '/');
	}
	es_addBuf(url_buf, (char* )pWrkrData-&gt;file, strlen((char* )pWrkrData-&gt;file));

	/* queries */
	/* user */
	es_addBuf(url_buf, &quot;?user.name=&quot;, sizeof(&quot;?user.name=&quot;)-1);
	es_addBuf(url_buf, (char* )pWrkrData-&gt;pData-&gt;user, strlen((char* )pWrkrData-&gt;pData-&gt;user));

	/* extra parameters */
	es_addBuf(url_buf, op, strlen(op));

	return RS_RET_OK;
}

/**
 * curl set URL
 *
 * @param wrkrInstanceData_t *pWrkrData
 * @param char* op
 * @return void
 */
static void httpfs_set_url(wrkrInstanceData_t *pWrkrData, const char* op)
{
	es_str_t* url;
	char* url_cstr;
	httpfs_build_url(pWrkrData, op, &amp;url);
	url_cstr = es_str2cstr(url, NULL);

	curl_easy_setopt(pWrkrData-&gt;curl, CURLOPT_URL, url_cstr);
	free(url_cstr);
}
/**
 * Set http method to PUT
 *
 * @param CURL* curl
 * @return void
 */
static void httpfs_curl_set_put(CURL* curl)
{
	curl_easy_setopt(curl, CURLOPT_HTTPGET, 0L);
	curl_easy_setopt(curl, CURLOPT_NOBODY, 0L);
	curl_easy_setopt(curl, CURLOPT_POST, 0L);
	curl_easy_setopt(curl, CURLOPT_PUT, 0L);
	curl_easy_setopt(curl, CURLOPT_UPLOAD, 0L);

	curl_easy_setopt(curl, CURLOPT_CUSTOMREQUEST, &quot;PUT&quot;);
}
/**
 * Set http method to POST
 *
 * @param CURL* curl
 * @return void
 */
static void httpfs_curl_set_post(CURL* curl)
{
	curl_easy_setopt(curl, CURLOPT_HTTPGET, 0L);
	curl_easy_setopt(curl, CURLOPT_NOBODY, 0L);
	curl_easy_setopt(curl, CURLOPT_PUT, 0L);
	curl_easy_setopt(curl, CURLOPT_UPLOAD, 0L);
	curl_easy_setopt(curl, CURLOPT_POST, 1L);

	curl_easy_setopt(curl, CURLOPT_CUSTOMREQUEST, &quot;POST&quot;);
}

/**
 * Build curl slist
 *
 * @param struct curl_slist* headers
 * @param int hdr_count
 * @param ...
 * @return struct curl_slist*
 */
static struct curl_slist*
httpfs_curl_add_header(struct curl_slist* headers, int hdr_count, ...)
{
	const char* hdr;

	va_list ar;
	va_start(ar, hdr_count);
	for (; hdr_count &gt; 0; hdr_count--) {
	    hdr = va_arg(ar, const char*);

	    if (hdr != NULL
	            &amp;&amp; hdr[0] != 0) {
	        /* non-empty string */
	        headers = curl_slist_append(headers, hdr);
	    } else {
	        break;
	    }
	}
	va_end(ar);

	headers = curl_slist_append(headers, &quot;Expect:&quot;);
	headers = curl_slist_append(headers, &quot;Transfer-Encoding:&quot;);

	return headers;
}

/**
 * Callback function for CURLOPT_WRITEFUNCTION
 *
 * @param void* contents
 * @param size_t size
 * @param size_t nmemb
 * @param void *userp
 * @return size_t
 */
static size_t
httpfs_curl_result_callback(void *contents, size_t size, size_t nmemb, void *userp)
{
	size_t realsize = size * nmemb;
	char *newreply = NULL;
	wrkrInstanceData_t *mem = (wrkrInstanceData_t *)userp;

	newreply = realloc(mem-&gt;reply, mem-&gt;replyLen + realsize + 1);
	if (newreply == NULL) {
	    /* out of memory! */
	    dbgprintf(&quot;not enough memory (realloc returned NULL)\n&quot;);

	    if (mem-&gt;reply != NULL)
	        free(mem-&gt;reply);

	    mem-&gt;reply = NULL;
	    mem-&gt;replyLen = 0;

	    return 0;
	}

	mem-&gt;reply = newreply;
	memcpy(&amp;(mem-&gt;reply[mem-&gt;replyLen]), contents, realsize);
	mem-&gt;replyLen += realsize;
	mem-&gt;reply[mem-&gt;replyLen] = 0;

	return realsize;
}

/**
 * Variables declaration
 * used in httpfs related operation
 */
#define HTTPFS_CURL_VARS_INIT \
	struct curl_slist* headers = NULL; \
	long response_code; \
	CURLcode res; \
	char* content_type;

/**
 * Resource release
 * used in httpfs related operation
 */
#define HTTPFS_CURL_VARS_RELEASE \
	curl_slist_free_all(headers);

/**
 * Curl execution
 * used in httpfs related operation
 */
#define HTTPFS_CURL_EXEC \
	pWrkrData-&gt;reply = NULL; \
	pWrkrData-&gt;replyLen = 0; \
	curl_easy_setopt(pWrkrData-&gt;curl, CURLOPT_WRITEDATA, pWrkrData); \
	curl_easy_setopt(pWrkrData-&gt;curl, CURLOPT_WRITEFUNCTION, httpfs_curl_result_callback); \
	res = curl_easy_perform(pWrkrData-&gt;curl); \
	if (res == CURLE_OK) { \
	    curl_easy_getinfo(pWrkrData-&gt;curl, CURLINFO_CONTENT_TYPE, &amp;content_type); \
	    if (strncmp(content_type, HTTPFS_CONTENT_TYPE_JSON, strlen(HTTPFS_CONTENT_TYPE_JSON))) { \
	    } \
	    curl_easy_getinfo(pWrkrData-&gt;curl, CURLINFO_RESPONSE_CODE, &amp;response_code); \
	    if (pWrkrData-&gt;reply != NULL) { \
	        pWrkrData-&gt;reply[pWrkrData-&gt;replyLen] = '\0'; \
	    } \
	} else { \
	LogError(0, RS_RET_ERR, &quot;CURL request fail, code=%d, error string=%s\n&quot;, res, curl_easy_strerror(res)); \
	    return -1; \
	}

/**
 * Parse remote exception json string
 *
 * @param char* buf
 * @param int   length
 * @param httpfs_json_remote_exception* jre
 * @return rsRetVal
 */
static rsRetVal
httpfs_parse_exception(char* buf, int length, httpfs_json_remote_exception* jre)
{
	DEFiRet;
	
	if (!length) {
	    return RS_RET_JSON_PARSE_ERR;
	}

	struct json_tokener* jt = json_tokener_new();
	json_tokener_reset(jt);

	struct json_object *json;
	json = json_tokener_parse_ex(jt, buf, length);
	if (!json_object_is_type(json, json_type_object)) {
		ABORT_FINALIZE(RS_RET_JSON_PARSE_ERR);
	}

	if (!json_object_object_get_ex(json, &quot;RemoteException&quot;, &amp;json)) {
	ABORT_FINALIZE(RS_RET_JSON_PARSE_ERR);
	}

	struct json_object *jobj;

	memset(jre, 0, sizeof(*jre));

	const char *str;

	json_object_object_get_ex(json, &quot;javaClassName&quot;, &amp;jobj);
	str = json_object_get_string(jobj);
	strncpy(jre-&gt;class, str, sizeof(jre-&gt;class));
	jre-&gt;class[sizeof(jre-&gt;class)-1] = '\0';

	json_object_object_get_ex(json, &quot;exception&quot;, &amp;jobj);
	str = json_object_get_string(jobj);
	strncpy(jre-&gt;exception, str, sizeof(jre-&gt;exception));
	jre-&gt;exception[sizeof(jre-&gt;exception)-1] = '\0';

	json_object_object_get_ex(json, &quot;message&quot;, &amp;jobj);
	str = json_object_get_string(jobj);
	strncpy(jre-&gt;message, str, sizeof(jre-&gt;message));
	jre-&gt;message[sizeof(jre-&gt;message)-1] = '\0';

finalize_it:
	if(jt != NULL)
		json_tokener_free(jt);
	if(json != NULL)
		json_object_put(json);
	RETiRet;
}



/**
 * Create a file
 * op=CREATE
 * overwrite is turned off
 *
 * @param wrkrInstanceData_t *pWrkrData
 * @param char*   buf
 * @return rsRetVal
 */
static rsRetVal
httpfs_create_file(wrkrInstanceData_t *pWrkrData, uchar* buf)
{
	/* httpfs.create automatically create folders, no mkdirs needed. */

	/*
	curl -b /tmp/c.tmp -c /tmp/c.tmp  -d 'aaaaabbbbb' -i -H 'Content-Type: application/octet-stream' -X PUT \
	       'http://172.16.3.20:14000/webhdfs/v1/tmp/a/b?user.name=hdfs&amp;op=create&amp;data=true'
	*/
HTTPFS_CURL_VARS_INIT
	DBGPRINTF(&quot;%s(): file=%s\n&quot;, __FUNCTION__, pWrkrData-&gt;file);
	httpfs_curl_set_put(pWrkrData-&gt;curl);

	/*
overwrite - if a file with this name already exists, then if true, the file will be overwritten, and if
false an error will be thrown.
bufferSize - the size of the buffer to be used.
replication - required block replication for the file.
	 */
	httpfs_set_url(pWrkrData, &quot;&amp;op=create&amp;overwrite=false&amp;data=true&quot;);

	curl_easy_setopt(pWrkrData-&gt;curl, CURLOPT_POSTFIELDS, (char*)buf);
	curl_easy_setopt(pWrkrData-&gt;curl, CURLOPT_POSTFIELDSIZE, strlen((char*) buf));

	DBGPRINTF(&quot;%s(): msg=%s\n&quot;, __FUNCTION__, buf);

	headers = httpfs_curl_add_header(headers, 1, HTTPFS_CONTENT_TYPE);
	curl_easy_setopt(pWrkrData-&gt;curl, CURLOPT_HTTPHEADER, headers);

HTTPFS_CURL_EXEC

	int success = 0;

	if (response_code == 201) {
	    success = 1;
	}

HTTPFS_CURL_VARS_RELEASE
	if (success) {
	    return RS_RET_OK;
	} else {
	    return RS_RET_FALSE;
	}
}

/**
 * Append to file
 * op=APPEND
 *
 * @param wrkrInstanceData_t *pWrkrData
 * @param char*   buf
 * @return rsRetVal
 */
static rsRetVal
httpfs_append_file(wrkrInstanceData_t *pWrkrData, uchar* buf)
{
	/*
	curl -b /tmp/c.tmp -c /tmp/c.tmp  -d 'aaaaabbbbb' -i -H 'Content-Type: application/octet-stream' \
	       'http://172.16.3.20:14000/webhdfs/v1/tmp/a/b?user.name=hdfs&amp;op=append&amp;data=true'
	*/
HTTPFS_CURL_VARS_INIT
	DBGPRINTF(&quot;%s(): file=%s\n&quot;, __FUNCTION__, pWrkrData-&gt;file);
	httpfs_curl_set_post(pWrkrData-&gt;curl);
	httpfs_set_url(pWrkrData, &quot;&amp;op=append&amp;data=true&quot;);

	curl_easy_setopt(pWrkrData-&gt;curl, CURLOPT_POSTFIELDS, (char*)buf);
	curl_easy_setopt(pWrkrData-&gt;curl, CURLOPT_POSTFIELDSIZE, strlen((char*) buf));

	headers = httpfs_curl_add_header(headers, 1, HTTPFS_CONTENT_TYPE);
	curl_easy_setopt(pWrkrData-&gt;curl, CURLOPT_HTTPHEADER, headers);
	DBGPRINTF(&quot;%s(): msg=%s\n&quot;, __FUNCTION__, buf);

HTTPFS_CURL_EXEC

	int success = 0;

	if (response_code == 200) {
	    success = 1;
	} else if (response_code == 404) {
	    /* TODO: 404 ? */

	}
HTTPFS_CURL_VARS_RELEASE
	if (success) {
	    return RS_RET_OK;
	} else {
	    return RS_RET_FALSE;
	}
}


/**
 * httpfs log
 *
 * @param wrkrInstanceData_t *pWrkrData
 * @param uchar* buf
 * @return rsRetVal
 */
static rsRetVal
httpfs_log(wrkrInstanceData_t *pWrkrData, uchar* buf)
{
	/**
	append ? 200/end : (404 || ?)
	    create &amp; ~overwrite ? 201/200/end :
	        append ? 200/end : error ?


	*/
	DEFiRet;

	long response_code;
	httpfs_json_remote_exception jre;

	iRet = httpfs_append_file(pWrkrData, buf);
	if (iRet == RS_RET_OK) {
	    DBGPRINTF(&quot;omhttpfs: Append success: %s\n&quot;, pWrkrData-&gt;file);
	    return RS_RET_OK;
	}

	curl_easy_getinfo(pWrkrData-&gt;curl, CURLINFO_RESPONSE_CODE, &amp;response_code);
	if (response_code != 404) {
	    /* TODO: log error */
	    DBGPRINTF(&quot;omhttpfs: Append fail HTTP %ld: %s\n&quot;, response_code, pWrkrData-&gt;file);
	    return RS_RET_FALSE;
	}

	iRet = httpfs_create_file(pWrkrData, buf);
	if (iRet == RS_RET_OK) {
	    DBGPRINTF(&quot;omhttpfs: Create file success: %s\n&quot;, pWrkrData-&gt;file);
	    return RS_RET_OK;
	}

	curl_easy_getinfo(pWrkrData-&gt;curl, CURLINFO_RESPONSE_CODE, &amp;response_code);
	if (response_code == 201) {
	    DBGPRINTF(&quot;omhttpfs: Create file success HTTP 201: %s\n&quot;, pWrkrData-&gt;file);
	    return RS_RET_OK;
	}

	if (response_code == 500) {
	    DBGPRINTF(&quot;omhttpfs: Create file failed HTTP %ld: %s\n&quot;, response_code, pWrkrData-&gt;file);
	    httpfs_parse_exception(pWrkrData-&gt;reply, pWrkrData-&gt;replyLen, &amp;jre);
	    if (!strncmp(jre.exception, HTTPFS_FILEALREADYEXISTSEXCEPTION, strlen(HTTPFS_FILEALREADYEXISTSEXCEPTION))) {
	        /* file exists, go to append */
	        DBGPRINTF(&quot;omhttpfs: File already exists, append again: %s\n&quot;, pWrkrData-&gt;file);

	        iRet = httpfs_append_file(pWrkrData, buf);
	        if (iRet == RS_RET_OK) {
	            DBGPRINTF(&quot;omhttpfs: Re-Append success: %s\n&quot;, pWrkrData-&gt;file);
	            return RS_RET_OK;
	        } else {
	            DBGPRINTF(&quot;omhttpfs: Re-Append failed: %s\n&quot;, pWrkrData-&gt;file);
	            /* error
	               exit */
	        }

	    } else {
	        DBGPRINTF(&quot;omhttpfs: Create file failed: %s %s\n&quot;, pWrkrData-&gt;file, pWrkrData-&gt;reply);
	    }
	} else {
	    DBGPRINTF(&quot;omhttpfs: Create file failed: %s %s\n&quot;, pWrkrData-&gt;file, pWrkrData-&gt;reply);
	}

	return RS_RET_FALSE;
}


BEGINinitConfVars
	CODESTARTinitConfVars
ENDinitConfVars


BEGINcreateInstance
CODESTARTcreateInstance
	DBGPRINTF(&quot;omhttpfs: createInstance\n&quot;);
ENDcreateInstance


BEGINcreateWrkrInstance
CODESTARTcreateWrkrInstance
	DBGPRINTF(&quot;omhttpfs: createWrkrInstance\n&quot;);
	pWrkrData-&gt;curl = NULL;
	iRet = httpfs_init_curl(pWrkrData, pWrkrData-&gt;pData);
	DBGPRINTF(&quot;omhttpfs: createWrkrInstance,pData %p/%p, pWrkrData %p\n&quot;,
	pData, pWrkrData-&gt;pData, pWrkrData);
ENDcreateWrkrInstance


BEGINisCompatibleWithFeature
CODESTARTisCompatibleWithFeature
	if(eFeat == sFEATURERepeatedMsgReduction)
	    iRet = RS_RET_OK;
ENDisCompatibleWithFeature


BEGINfreeInstance
CODESTARTfreeInstance
	free(pData-&gt;file);
	free(pData-&gt;tplName);
	free(pData-&gt;host);
	free(pData-&gt;user);
ENDfreeInstance


BEGINfreeWrkrInstance
CODESTARTfreeWrkrInstance
	free(pWrkrData-&gt;file);

	if(pWrkrData-&gt;curl) {
	    curl_easy_cleanup(pWrkrData-&gt;curl);
	    pWrkrData-&gt;curl = NULL;
	}
ENDfreeWrkrInstance


BEGINdbgPrintInstInfo
CODESTARTdbgPrintInstInfo
	DBGPRINTF(&quot;OmHTTPFS\n&quot;);
	DBGPRINTF(&quot;Version: %s\n&quot;, OMHTTPFS_VERSION);
	DBGPRINTF(&quot;\tHost: %s\n&quot;, pData-&gt;host);
	DBGPRINTF(&quot;\tPort: %d\n&quot;, pData-&gt;port);
	DBGPRINTF(&quot;\tUser: %s\n&quot;, pData-&gt;user);
	DBGPRINTF(&quot;\tFile: %s\n&quot;, pData-&gt;file);
ENDdbgPrintInstInfo


BEGINtryResume
CODESTARTtryResume
	DBGPRINTF(&quot;omhttpfs: tryResume called\n&quot;);
	/* TODO: test networking */
	iRet = RS_RET_OK;
ENDtryResume

/**
* Do Action
*/
BEGINdoAction
CODESTARTdoAction
	DBGPRINTF(&quot;omhttpfs: doAction\n&quot;);
	/* dynamic file name */
	if (pWrkrData-&gt;pData-&gt;isDynFile) {
	    pWrkrData-&gt;file = ustrdup(ppString[1]);
	} else {
	    pWrkrData-&gt;file = ustrdup(pWrkrData-&gt;pData-&gt;file);
	}

	/* ppString[0] -&gt; log content */
	iRet = httpfs_log(pWrkrData, ppString[0]);

	if(iRet != RS_RET_OK) {
	    DBGPRINTF(&quot;omhttpfs: error writing httpfs, suspending\n&quot;);
	    iRet = RS_RET_SUSPENDED;
	}
ENDdoAction



/**
 * Set default parameters
 *
 * @param instanceData *pData
 * @return void
 */
static void
setInstParamDefaults(instanceData *pData)
{
	pData-&gt;host = (uchar*) strdup(OMHTTPFS_DEFAULT_HOST);
	pData-&gt;port = OMHTTPFS_DEFAULT_PORT;
	pData-&gt;user = (uchar*) strdup(OMHTTPFS_DEFAULT_USER);
	pData-&gt;https = 0;

	pData-&gt;file = NULL;
	pData-&gt;isDynFile = 0;
	pData-&gt;tplName = NULL;
}


BEGINnewActInst
	struct cnfparamvals *pvals;
	int i;
	uchar *tplToUse;
CODESTARTnewActInst
	if((pvals = nvlstGetParams(lst, &amp;actpblk, NULL)) == NULL) {
	    ABORT_FINALIZE(RS_RET_MISSING_CNFPARAMS);
	}

	CHKiRet(createInstance(&amp;pData));
	setInstParamDefaults(pData);

	for(i = 0 ; i &lt; actpblk.nParams ; ++i) {
	    if(!pvals[i].bUsed)
	        continue;
	    if(!strcmp(actpblk.descr[i].name, &quot;host&quot;)) {
	        pData-&gt;host = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
	    } else if(!strcmp(actpblk.descr[i].name, &quot;port&quot;)) {
	        pData-&gt;port = (int) pvals[i].val.d.n;
	    } else if(!strcmp(actpblk.descr[i].name, &quot;user&quot;)) {
	        pData-&gt;user = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);

	    } else if(!strcmp(actpblk.descr[i].name, &quot;https&quot;)) {
	        pData-&gt;https = pvals[i].val.d.n ? 1 : 0;

	    } else if(!strcmp(actpblk.descr[i].name, &quot;file&quot;)) {
	        pData-&gt;file = (uchar *) es_str2cstr(pvals[i].val.d.estr, NULL);

	    } else if(!strcmp(actpblk.descr[i].name, &quot;isdynfile&quot;)) {
	        pData-&gt;isDynFile = pvals[i].val.d.n ? 1 : 0;

	    } else if(!strcmp(actpblk.descr[i].name, &quot;template&quot;)) {
	        pData-&gt;tplName = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
	    } else {
	        DBGPRINTF(&quot;omhttpfs: program error, non-handled param '%s'\n&quot;, actpblk.descr[i].name);
	    }
	}
	if(pData-&gt;file == NULL) {
	/* Note: this is primarily to make clang static analyzer happy, as we
	 * request via pblk that file is a mandatory parameter. However, this is
	 * also a guard against something going really wrong...
	 */
	    LogError(0, RS_RET_INTERNAL_ERROR, &quot;omhttpfs: file is not set &quot;
		&quot;[this should not be possible]\n&quot;);
	ABORT_FINALIZE(RS_RET_INTERNAL_ERROR);
	}
	if(pData-&gt;user == NULL || pData-&gt;user[0] == '\0') {
	    pData-&gt;user = ustrdup((uchar*) OMHTTPFS_DEFAULT_USER);
	}
	if(pData-&gt;host == NULL || pData-&gt;host[0] == '\0') {
	    pData-&gt;host = ustrdup((uchar*) OMHTTPFS_DEFAULT_HOST);
	}

	if (pData-&gt;isDynFile) {
	    CODE_STD_STRING_REQUESTparseSelectorAct(2)

	    CHKiRet(OMSRsetEntry(*ppOMSR, 1, ustrdup(pData-&gt;file), OMSR_NO_RQD_TPL_OPTS));
	} else {
	    CODE_STD_STRING_REQUESTparseSelectorAct(1)
	}

	tplToUse = ustrdup((pData-&gt;tplName == NULL) ? (uchar* ) &quot;RSYSLOG_FileFormat&quot; : pData-&gt;tplName);
	iRet = OMSRsetEntry(*ppOMSR, 0, tplToUse, OMSR_NO_RQD_TPL_OPTS);

CODE_STD_FINALIZERnewActInst
	cnfparamvalsDestruct(pvals, &amp;actpblk);
ENDnewActInst


NO_LEGACY_CONF_parseSelectorAct


/**
* Module Exit
*/
BEGINmodExit
CODESTARTmodExit
	/*  */
	curl_global_cleanup();

	/* release what we no longer need */
	objRelease(datetime, CORE_COMPONENT);
	objRelease(glbl, CORE_COMPONENT);

ENDmodExit

/**
* Query Entry Point
*/
BEGINqueryEtryPt
CODESTARTqueryEtryPt
	CODEqueryEtryPt_STD_OMOD_QUERIES
	CODEqueryEtryPt_STD_CONF2_OMOD_QUERIES
	CODEqueryEtryPt_STD_OMOD8_QUERIES
	CODEqueryEtryPt_STD_CONF2_CNFNAME_QUERIES
ENDqueryEtryPt


/**
* Module Init
*/
BEGINmodInit()
CODESTARTmodInit
INITLegCnfVars
	*ipIFVersProvided = CURR_MOD_IF_VERSION; /* we only support the current interface specification */
CODEmodInit_QueryRegCFSLineHdlr
	/* tell which objects we need */
	CHKiRet(objUse(glbl, CORE_COMPONENT));
	CHKiRet(objUse(datetime, CORE_COMPONENT));

	if (curl_global_init(CURL_GLOBAL_ALL) != 0) {
	    LogError(0, RS_RET_OBJ_CREATION_FAILED, &quot;CURL fail. -httpfs module init failed&quot;);
	    ABORT_FINALIZE(RS_RET_OBJ_CREATION_FAILED);
	}

	DBGPRINTF(&quot;omhttpfs version %s is initializing\n&quot;, OMHTTPFS_VERSION);

ENDmodInit
</PRE>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>ruleset.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
/* ruleset.c - rsyslog's ruleset object
 *
 * We have a two-way structure of linked lists: one config-specifc linked list
 * (conf-&gt;rulesets.llRulesets) hold alls rule sets that we know. Included in each
 * list is a list of rules (which contain a list of actions, but that's
 * a different story).
 *
 * Usually, only a single rule set is executed. However, there exist some
 * situations where all rules must be iterated over, for example on HUP. Thus,
 * we also provide interfaces to do that.
 *
 * Module begun 2009-06-10 by Rainer Gerhards
 *
 * Copyright 2009-2021 Rainer Gerhards and Adiscon GmbH.
 *
 * This file is part of the rsyslog runtime library.
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *       -or-
 *       see COPYING.ASL20 in the source distribution
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#include &quot;config.h&quot;
#include &lt;stdlib.h&gt;
#include &lt;assert.h&gt;
#include &lt;ctype.h&gt;

#include &quot;rsyslog.h&quot;
#include &quot;obj.h&quot;
#include &quot;cfsysline.h&quot;
#include &quot;msg.h&quot;
#include &quot;ruleset.h&quot;
#include &quot;errmsg.h&quot;
#include &quot;parser.h&quot;
#include &quot;batch.h&quot;
#include &quot;unicode-helper.h&quot;
#include &quot;rsconf.h&quot;
#include &quot;action.h&quot;
#include &quot;rainerscript.h&quot;
#include &quot;srUtils.h&quot;
#include &quot;modules.h&quot;
#include &quot;wti.h&quot;
#include &quot;dirty.h&quot; /* for main ruleset queue creation */


/* static data */
DEFobjStaticHelpers
DEFobjCurrIf(parser)
<A NAME="0"></A>
/* tables for interfacing with the v6 config system (as far as we need to) */
static struct cnfparamdescr rspdescr[] = {
<FONT color="#0000ff"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match3436-0.html#0',2,'match3436-top.html#0',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>	{ &quot;name&quot;, eCmdHdlrString, CNFPARAM_REQUIRED },
	{ &quot;parser&quot;, eCmdHdlrArray, 0 }
};
static struct cnfparamblk rspblk =
	{ CNFPARAMBLK_VERSION,
	  sizeof(rspdescr)/sizeof(struct cnfparamdescr),
	  rspdescr
	};

/* forward definitions */
static rsRetVal processBatch(batch_t *pBatch, wti_t *pWti);</B></FONT>
static rsRetVal scriptExec(struct cnfstmt *root, smsg_t *pMsg, wti_t *pWti);


/* ---------- linked-list key handling functions (ruleset) ---------- */

/* destructor for linked list keys.
 */
rsRetVal
rulesetKeyDestruct(void __attribute__((unused)) *pData)
{
	free(pData);
	return RS_RET_OK;
}
/* ---------- END linked-list key handling functions (ruleset) ---------- */


/* iterate over all actions in a script (stmt subtree) */
static void
scriptIterateAllActions(struct cnfstmt *root, rsRetVal (*pFunc)(void*, void*), void* pParam)
{
	struct cnfstmt *stmt;
	for(stmt = root ; stmt != NULL ; stmt = stmt-&gt;next) {
		switch(stmt-&gt;nodetype) {
		case S_NOP:
		case S_STOP:
		case S_SET:
		case S_UNSET:
		case S_CALL_INDIRECT:
		case S_CALL:/* call does not need to do anything - done in called ruleset! */
			break;
		case S_ACT:
			DBGPRINTF(&quot;iterateAllActions calling into action %p\n&quot;, stmt-&gt;d.act);
			pFunc(stmt-&gt;d.act, pParam);
			break;
		case S_IF:
			if(stmt-&gt;d.s_if.t_then != NULL)
				scriptIterateAllActions(stmt-&gt;d.s_if.t_then,
							pFunc, pParam);
			if(stmt-&gt;d.s_if.t_else != NULL)
				scriptIterateAllActions(stmt-&gt;d.s_if.t_else,
							pFunc, pParam);
			break;
		case S_FOREACH:
			if(stmt-&gt;d.s_foreach.body != NULL)
				scriptIterateAllActions(stmt-&gt;d.s_foreach.body,
							pFunc, pParam);
			break;
		case S_PRIFILT:
			if(stmt-&gt;d.s_prifilt.t_then != NULL)
				scriptIterateAllActions(stmt-&gt;d.s_prifilt.t_then,
							pFunc, pParam);
			if(stmt-&gt;d.s_prifilt.t_else != NULL)
				scriptIterateAllActions(stmt-&gt;d.s_prifilt.t_else,
							pFunc, pParam);
			break;
		case S_PROPFILT:
			scriptIterateAllActions(stmt-&gt;d.s_propfilt.t_then,
						pFunc, pParam);
			break;
		case S_RELOAD_LOOKUP_TABLE: /* this is a NOP */
			break;
		default:
			dbgprintf(&quot;error: unknown stmt type %u during iterateAll\n&quot;,
				(unsigned) stmt-&gt;nodetype);
			#ifndef NDEBUG
				fprintf(stderr, &quot;error: unknown stmt type %u during iterateAll\n&quot;,
					(unsigned) stmt-&gt;nodetype);
			#endif
			assert(0); /* abort under debugging */
			break;
		}
	}
}

/* driver to iterate over all of this ruleset actions */
typedef struct iterateAllActions_s {
	rsRetVal (*pFunc)(void*, void*);
	void *pParam;
} iterateAllActions_t;
/* driver to iterate over all actions */
DEFFUNC_llExecFunc(doIterateAllActions)
{
	DEFiRet;
	ruleset_t* pThis = (ruleset_t*) pData;
	iterateAllActions_t *pMyParam = (iterateAllActions_t*) pParam;
	scriptIterateAllActions(pThis-&gt;root, pMyParam-&gt;pFunc, pMyParam-&gt;pParam);
	RETiRet;
}
/* iterate over ALL actions present in the WHOLE system.
 * this is often needed, for example when HUP processing
 * must be done or a shutdown is pending.
 */
static rsRetVal
iterateAllActions(rsconf_t *conf, rsRetVal (*pFunc)(void*, void*), void* pParam)
{
	iterateAllActions_t params;
	DEFiRet;
	assert(pFunc != NULL);

	params.pFunc = pFunc;
	params.pParam = pParam;
	CHKiRet(llExecFunc(&amp;(conf-&gt;rulesets.llRulesets), doIterateAllActions, &amp;params));

finalize_it:
	RETiRet;
}

/* driver to iterate over all rulesets */
DEFFUNC_llExecFunc(doActivateRulesetQueues)
{
	DEFiRet;
	ruleset_t* pThis = (ruleset_t*) pData;
	dbgprintf(&quot;Activating Ruleset Queue[%p] for Ruleset %s\n&quot;,
		  pThis-&gt;pQueue, pThis-&gt;pszName);
	if(pThis-&gt;pQueue != NULL)
		startMainQueue(runConf, pThis-&gt;pQueue);
	RETiRet;
}
/* activate all ruleset queues */
rsRetVal
activateRulesetQueues(void)
{
	llExecFunc(&amp;(runConf-&gt;rulesets.llRulesets), doActivateRulesetQueues, NULL);
	return RS_RET_OK;
}


static rsRetVal
execAct(struct cnfstmt *stmt, smsg_t *pMsg, wti_t *pWti)
{
	DEFiRet;
	if(stmt-&gt;d.act-&gt;bDisabled) {
		DBGPRINTF(&quot;action %d died, do NOT execute\n&quot;, stmt-&gt;d.act-&gt;iActionNbr);
		FINALIZE;
	}

	DBGPRINTF(&quot;executing action %d\n&quot;, stmt-&gt;d.act-&gt;iActionNbr);
	stmt-&gt;d.act-&gt;submitToActQ(stmt-&gt;d.act, pWti, pMsg);
	if(iRet != RS_RET_DISCARDMSG) {
		/* note: we ignore the error code here, as we do NEVER want to
		 * stop script execution due to action return code
		 */
		iRet = RS_RET_OK;
	}
finalize_it:
	RETiRet;
}

static rsRetVal ATTR_NONNULL()
execSet(const struct cnfstmt *const stmt,
	smsg_t *const pMsg,
	wti_t *const __restrict__ pWti)
{
	struct svar result;
	DEFiRet;
	cnfexprEval(stmt-&gt;d.s_set.expr, &amp;result, pMsg, pWti);
	msgSetJSONFromVar(pMsg, stmt-&gt;d.s_set.varname, &amp;result, stmt-&gt;d.s_set.force_reset);
	varDelete(&amp;result);
	RETiRet;
}

static rsRetVal
execUnset(struct cnfstmt *stmt, smsg_t *pMsg)
{
	DEFiRet;
	msgDelJSON(pMsg, stmt-&gt;d.s_unset.varname);
	RETiRet;
}

static rsRetVal
execCallIndirect(struct cnfstmt *const __restrict__ stmt,
	smsg_t *pMsg,
	wti_t *const __restrict__ pWti)
{
	ruleset_t *pRuleset;
	struct svar result;
	int bMustFree; /* dummy parameter */
	DEFiRet;

	assert(stmt-&gt;d.s_call_ind.expr != NULL);

	cnfexprEval(stmt-&gt;d.s_call_ind.expr, &amp;result, pMsg, pWti);
	uchar *const rsName = (uchar*) var2CString(&amp;result, &amp;bMustFree);
	const rsRetVal localRet = rulesetGetRuleset(runConf, &amp;pRuleset, rsName);
	if(localRet != RS_RET_OK) {
		/* in that case, we accept that a NOP will &quot;survive&quot; */
		LogError(0, RS_RET_RULESET_NOT_FOUND, &quot;error: CALL_INDIRECT: &quot;
			&quot;ruleset '%s' cannot be found, treating as NOP\n&quot;, rsName);
		FINALIZE;
	}
	DBGPRINTF(&quot;CALL_INDIRECT obtained ruleset ptr %p for ruleset '%s' [hasQueue:%d]\n&quot;,
		  pRuleset, rsName, rulesetHasQueue(pRuleset));
	if(rulesetHasQueue(pRuleset)) {
		CHKmalloc(pMsg = MsgDup((smsg_t*) pMsg));
		DBGPRINTF(&quot;CALL_INDIRECT: forwarding message to async ruleset %p\n&quot;,
			  pRuleset-&gt;pQueue);
		MsgSetFlowControlType(pMsg, eFLOWCTL_NO_DELAY);
		MsgSetRuleset(pMsg, pRuleset);
		/* Note: we intentionally use submitMsg2() here, as we process messages
		 * that were already run through the rate-limiter.
		 */
		submitMsg2(pMsg);
	} else {
		CHKiRet(scriptExec(pRuleset-&gt;root, pMsg, pWti));
	}
finalize_it:
	varDelete(&amp;result);
	free(rsName);
	RETiRet;
}

static rsRetVal
execCall(struct cnfstmt *stmt, smsg_t *pMsg, wti_t *pWti)
{
	DEFiRet;
	if(stmt-&gt;d.s_call.ruleset == NULL) {
		CHKiRet(scriptExec(stmt-&gt;d.s_call.stmt, pMsg, pWti));
	} else {
		CHKmalloc(pMsg = MsgDup((smsg_t*) pMsg));
		DBGPRINTF(&quot;CALL: forwarding message to async ruleset %p\n&quot;,
			  stmt-&gt;d.s_call.ruleset-&gt;pQueue);
		MsgSetFlowControlType(pMsg, eFLOWCTL_NO_DELAY);
		MsgSetRuleset(pMsg, stmt-&gt;d.s_call.ruleset);
		/* Note: we intentionally use submitMsg2() here, as we process messages
		 * that were already run through the rate-limiter.
		 */
		submitMsg2(pMsg);
	}
finalize_it:
	RETiRet;
}

static rsRetVal
execIf(struct cnfstmt *const stmt, smsg_t *const pMsg, wti_t *const pWti)
{
	sbool bRet;
	DEFiRet;
	bRet = cnfexprEvalBool(stmt-&gt;d.s_if.expr, pMsg, pWti);
	DBGPRINTF(&quot;if condition result is %d\n&quot;, bRet);
	if(bRet) {
		if(stmt-&gt;d.s_if.t_then != NULL)
			CHKiRet(scriptExec(stmt-&gt;d.s_if.t_then, pMsg, pWti));
	} else {
		if(stmt-&gt;d.s_if.t_else != NULL)
			CHKiRet(scriptExec(stmt-&gt;d.s_if.t_else, pMsg, pWti));
	}
finalize_it:
	RETiRet;
}

static rsRetVal
invokeForeachBodyWith(struct cnfstmt *stmt, json_object *o, smsg_t *pMsg, wti_t *pWti) {
	struct svar v;
	v.datatype = 'J';
	v.d.json = o;
	DEFiRet;
	CHKiRet(msgSetJSONFromVar(pMsg, (uchar*)stmt-&gt;d.s_foreach.iter-&gt;var, &amp;v, 1));
	CHKiRet(scriptExec(stmt-&gt;d.s_foreach.body, pMsg, pWti));
finalize_it:
	RETiRet;
}

static rsRetVal
callForeachArray(struct cnfstmt *stmt, json_object *arr, smsg_t *pMsg, wti_t *pWti) {
	DEFiRet;
	int len = json_object_array_length(arr);
	json_object *curr;
	for (int i = 0; i &lt; len; i++) {
		curr = json_object_array_get_idx(arr, i);
		CHKiRet(invokeForeachBodyWith(stmt, curr, pMsg, pWti));
	}
finalize_it:
	RETiRet;
}


static rsRetVal
callForeachObject(struct cnfstmt *stmt, json_object *arr, smsg_t *pMsg, wti_t *pWti) {
	json_object *entry = NULL;
	json_object *key = NULL;
	const char **keys = NULL;
	json_object *curr = NULL;
	const char **curr_key;
	struct json_object_iterator it;
	struct json_object_iterator itEnd;
	DEFiRet;

	int len = json_object_object_length(arr);
	CHKmalloc(keys = calloc(len, sizeof(char*)));
	curr_key = keys;
	it = json_object_iter_begin(arr);
	itEnd = json_object_iter_end(arr);
	while (!json_object_iter_equal(&amp;it, &amp;itEnd)) {
		*curr_key = json_object_iter_peek_name(&amp;it);
		curr_key++;
		json_object_iter_next(&amp;it);
	}
	CHKmalloc(entry = json_object_new_object());
	for (int i = 0; i &lt; len; i++) {
		if (json_object_object_get_ex(arr, keys[i], &amp;curr)) {
			CHKmalloc(key = json_object_new_string(keys[i]));
			json_object_object_add(entry, &quot;key&quot;, key);
			key = NULL;
			json_object_object_add(entry, &quot;value&quot;, json_object_get(curr));
			CHKiRet(invokeForeachBodyWith(stmt, entry, pMsg, pWti));
		}
	}
finalize_it:
	if (keys != NULL) free(keys);
	if (entry != NULL) json_object_put(entry);
	/* &quot;fix&quot; Coverity scan issue CID 185393: key currently can NOT be NULL
	 * However, instead of just removing the
	 *   if (key != NULL) json_object_put(key);
	 * we put an assertion in its place.
	 */
	assert(key == NULL);

	RETiRet;
}

static rsRetVal ATTR_NONNULL()
execForeach(struct cnfstmt *const stmt, smsg_t *const pMsg, wti_t *const pWti)
{
	json_object *arr = NULL;
	DEFiRet;

	/* arr can either be an array or an associative-array (obj) */
	arr = cnfexprEvalCollection(stmt-&gt;d.s_foreach.iter-&gt;collection, pMsg, pWti);

	if (arr == NULL) {
		DBGPRINTF(&quot;foreach loop skipped, as object to iterate upon is empty\n&quot;);
		FINALIZE;
	} else if (json_object_is_type(arr, json_type_array) &amp;&amp; json_object_array_length(arr) &gt; 0) {
		CHKiRet(callForeachArray(stmt, arr, pMsg, pWti));
	} else if (json_object_is_type(arr, json_type_object) &amp;&amp; json_object_object_length(arr) &gt; 0) {
		CHKiRet(callForeachObject(stmt, arr, pMsg, pWti));
	} else {
		DBGPRINTF(&quot;foreach loop skipped, as object to iterate upon is empty or is not an array\n&quot;);
		FINALIZE;
	}
	CHKiRet(msgDelJSON(pMsg, (uchar*)stmt-&gt;d.s_foreach.iter-&gt;var));

finalize_it:
	if (arr != NULL) json_object_put(arr);

	RETiRet;
}

static rsRetVal
execPRIFILT(struct cnfstmt *stmt, smsg_t *pMsg, wti_t *pWti)
{
	int bRet;
	DEFiRet;
	if( (stmt-&gt;d.s_prifilt.pmask[pMsg-&gt;iFacility] == TABLE_NOPRI) ||
	   ((stmt-&gt;d.s_prifilt.pmask[pMsg-&gt;iFacility]
		    &amp; (1&lt;&lt;pMsg-&gt;iSeverity)) == 0) )
		bRet = 0;
	else
		bRet = 1;

	DBGPRINTF(&quot;PRIFILT condition result is %d\n&quot;, bRet);
	if(bRet) {
		if(stmt-&gt;d.s_prifilt.t_then != NULL)
			CHKiRet(scriptExec(stmt-&gt;d.s_prifilt.t_then, pMsg, pWti));
	} else {
		if(stmt-&gt;d.s_prifilt.t_else != NULL)
			CHKiRet(scriptExec(stmt-&gt;d.s_prifilt.t_else, pMsg, pWti));
	}
finalize_it:
	RETiRet;
}


/* helper to execPROPFILT(), as the evaluation itself is quite lengthy */
static int
evalPROPFILT(struct cnfstmt *stmt, smsg_t *pMsg)
{
	unsigned short pbMustBeFreed;
	uchar *pszPropVal;
	int bRet = 0;
	rs_size_t propLen;

	if(stmt-&gt;d.s_propfilt.prop.id == PROP_INVALID)
		goto done;

	pszPropVal = MsgGetProp(pMsg, NULL, &amp;stmt-&gt;d.s_propfilt.prop,
				&amp;propLen, &amp;pbMustBeFreed, NULL);

	/* Now do the compares (short list currently ;)) */
	switch(stmt-&gt;d.s_propfilt.operation ) {
	case FIOP_CONTAINS:
		if(rsCStrLocateInSzStr(stmt-&gt;d.s_propfilt.pCSCompValue, (uchar*) pszPropVal) != -1)
			bRet = 1;
		break;
	case FIOP_ISEMPTY:
		if(propLen == 0)
			bRet = 1; /* process message! */
		break;
	case FIOP_ISEQUAL:
		if(rsCStrSzStrCmp(stmt-&gt;d.s_propfilt.pCSCompValue,
				  pszPropVal, propLen) == 0)
			bRet = 1; /* process message! */
		break;
	case FIOP_STARTSWITH:
		if(rsCStrSzStrStartsWithCStr(stmt-&gt;d.s_propfilt.pCSCompValue,
				  pszPropVal, propLen) == 0)
			bRet = 1; /* process message! */
		break;
	case FIOP_REGEX:
		if(rsCStrSzStrMatchRegex(stmt-&gt;d.s_propfilt.pCSCompValue,
				(unsigned char*) pszPropVal, 0, &amp;stmt-&gt;d.s_propfilt.regex_cache) == RS_RET_OK)
			bRet = 1;
		break;
	case FIOP_EREREGEX:
		if(rsCStrSzStrMatchRegex(stmt-&gt;d.s_propfilt.pCSCompValue,
				  (unsigned char*) pszPropVal, 1, &amp;stmt-&gt;d.s_propfilt.regex_cache) == RS_RET_OK)
			bRet = 1;
		break;
	case FIOP_NOP:
	default:
		/* here, it handles NOP (for performance reasons) */
		assert(stmt-&gt;d.s_propfilt.operation == FIOP_NOP);
		bRet = 1; /* as good as any other default ;) */
		break;
	}

	/* now check if the value must be negated */
	if(stmt-&gt;d.s_propfilt.isNegated)
		bRet = (bRet == 1) ?  0 : 1;

	if(Debug) {
		if(stmt-&gt;d.s_propfilt.prop.id == PROP_CEE) {
			DBGPRINTF(&quot;Filter: check for CEE property '%s' (value '%s') &quot;,
				stmt-&gt;d.s_propfilt.prop.name, pszPropVal);
		} else if(stmt-&gt;d.s_propfilt.prop.id == PROP_LOCAL_VAR) {
			DBGPRINTF(&quot;Filter: check for local var '%s' (value '%s') &quot;,
				stmt-&gt;d.s_propfilt.prop.name, pszPropVal);
		} else if(stmt-&gt;d.s_propfilt.prop.id == PROP_GLOBAL_VAR) {
			DBGPRINTF(&quot;Filter: check for global var '%s' (value '%s') &quot;,
				stmt-&gt;d.s_propfilt.prop.name, pszPropVal);
		} else {
			DBGPRINTF(&quot;Filter: check for property '%s' (value '%s') &quot;,
				propIDToName(stmt-&gt;d.s_propfilt.prop.id), pszPropVal);
		}
		if(stmt-&gt;d.s_propfilt.isNegated)
			DBGPRINTF(&quot;NOT &quot;);
		if(stmt-&gt;d.s_propfilt.operation == FIOP_ISEMPTY) {
			DBGPRINTF(&quot;%s : %s\n&quot;,
			       getFIOPName(stmt-&gt;d.s_propfilt.operation),
			       bRet ? &quot;TRUE&quot; : &quot;FALSE&quot;);
		} else {
			DBGPRINTF(&quot;%s '%s': %s\n&quot;,
			       getFIOPName(stmt-&gt;d.s_propfilt.operation),
			       rsCStrGetSzStrNoNULL(stmt-&gt;d.s_propfilt.pCSCompValue),
			       bRet ? &quot;TRUE&quot; : &quot;FALSE&quot;);
		}
	}

	/* cleanup */
	if(pbMustBeFreed)
		free(pszPropVal);
done:
	return bRet;
}

static rsRetVal
execPROPFILT(struct cnfstmt *stmt, smsg_t *pMsg, wti_t *pWti)
{
	sbool bRet;
	DEFiRet;

	bRet = evalPROPFILT(stmt, pMsg);
	DBGPRINTF(&quot;PROPFILT condition result is %d\n&quot;, bRet);
	if(bRet)
		CHKiRet(scriptExec(stmt-&gt;d.s_propfilt.t_then, pMsg, pWti));
finalize_it:
	RETiRet;
}

static rsRetVal ATTR_NONNULL()
execReloadLookupTable(struct cnfstmt *stmt)
{
	assert(stmt != NULL);
	lookup_ref_t *t;
	DEFiRet;
	t = stmt-&gt;d.s_reload_lookup_table.table;
	if (t == NULL) {
		ABORT_FINALIZE(RS_RET_NONE);
	}

	iRet = lookupReload(t, stmt-&gt;d.s_reload_lookup_table.stub_value);
	/* Note that reload dispatched above is performed asynchronously,
	   on a different thread. So rsRetVal it returns means it was triggered
	   successfully, and not that it was reloaded successfully. */

finalize_it:
	RETiRet;
}

/* The rainerscript execution engine. It is debatable if that would be better
 * contained in grammer/rainerscript.c, HOWEVER, that file focusses primarily
 * on the parsing and object creation part. So as an actual executor, it is
 * better suited here.
 * rgerhards, 2012-09-04
 */
static rsRetVal ATTR_NONNULL(2, 3)
scriptExec(struct cnfstmt *const root, smsg_t *const pMsg, wti_t *const pWti)
{
	struct cnfstmt *stmt;
	DEFiRet;

	for(stmt = root ; stmt != NULL ; stmt = stmt-&gt;next) {
		if(*pWti-&gt;pbShutdownImmediate) {
			DBGPRINTF(&quot;scriptExec: ShutdownImmediate set, &quot;
				  &quot;force terminating\n&quot;);
			ABORT_FINALIZE(RS_RET_FORCE_TERM);
		}
		if(Debug) {
			cnfstmtPrintOnly(stmt, 2, 0);
		}
		switch(stmt-&gt;nodetype) {
		case S_NOP:
			break;
		case S_STOP:
			ABORT_FINALIZE(RS_RET_DISCARDMSG);
			break;
		case S_ACT:
			CHKiRet(execAct(stmt, pMsg, pWti));
			break;
		case S_SET:
			CHKiRet(execSet(stmt, pMsg, pWti));
			break;
		case S_UNSET:
			CHKiRet(execUnset(stmt, pMsg));
			break;
		case S_CALL:
			CHKiRet(execCall(stmt, pMsg, pWti));
			break;
		case S_CALL_INDIRECT:
			CHKiRet(execCallIndirect(stmt, pMsg, pWti));
			break;
		case S_IF:
			CHKiRet(execIf(stmt, pMsg, pWti));
			break;
		case S_FOREACH:
			CHKiRet(execForeach(stmt, pMsg, pWti));
			break;
		case S_PRIFILT:
			CHKiRet(execPRIFILT(stmt, pMsg, pWti));
			break;
		case S_PROPFILT:
			CHKiRet(execPROPFILT(stmt, pMsg, pWti));
			break;
		case S_RELOAD_LOOKUP_TABLE:
			CHKiRet(execReloadLookupTable(stmt));
			break;
		default:
			dbgprintf(&quot;error: unknown stmt type %u during exec\n&quot;,
				(unsigned) stmt-&gt;nodetype);
			break;
		}
	}
finalize_it:
	RETiRet;
}


/* Process (consume) a batch of messages. Calls the actions configured.
 * This is called by MAIN queues.
 */
static rsRetVal
processBatch(batch_t *pBatch, wti_t *pWti)
{
	int i;
	smsg_t *pMsg;
	ruleset_t *pRuleset;
	rsRetVal localRet;
	DEFiRet;

	DBGPRINTF(&quot;processBATCH: batch of %d elements must be processed\n&quot;, pBatch-&gt;nElem);

	wtiResetExecState(pWti, pBatch);

	/* execution phase */
	for(i = 0 ; i &lt; batchNumMsgs(pBatch) &amp;&amp; !*(pWti-&gt;pbShutdownImmediate) ; ++i) {
		pMsg = pBatch-&gt;pElem[i].pMsg;
		DBGPRINTF(&quot;processBATCH: next msg %d: %.128s\n&quot;, i, pMsg-&gt;pszRawMsg);
		pRuleset = (pMsg-&gt;pRuleset == NULL) ? runConf-&gt;rulesets.pDflt : pMsg-&gt;pRuleset;
		localRet = scriptExec(pRuleset-&gt;root, pMsg, pWti);
		/* the most important case here is that processing may be aborted
		 * due to pbShutdownImmediate, in which case we MUST NOT flag this
		 * message as committed. If we would do so, the message would
		 * potentially be lost.
		 */
		if(localRet == RS_RET_OK)
			batchSetElemState(pBatch, i, BATCH_STATE_COMM);
		else if(localRet == RS_RET_SUSPENDED)
			--i;
	}

	/* commit phase */
	DBGPRINTF(&quot;END batch execution phase, entering to commit phase &quot;
		&quot;[processed %d of %d messages]\n&quot;, i, batchNumMsgs(pBatch));
	actionCommitAllDirect(pWti);

	DBGPRINTF(&quot;processBATCH: batch of %d elements has been processed\n&quot;, pBatch-&gt;nElem);
	RETiRet;
}


/* return the ruleset-assigned parser list. NULL means use the default
 * parser list.
 * rgerhards, 2009-11-04
 */
static parserList_t*
GetParserList(rsconf_t *conf, smsg_t *pMsg)
{
	return (pMsg-&gt;pRuleset == NULL) ? conf-&gt;rulesets.pDflt-&gt;pParserLst : pMsg-&gt;pRuleset-&gt;pParserLst;
}


/* Add a script block to the current ruleset */
static void ATTR_NONNULL(1)
addScript(ruleset_t *const pThis, struct cnfstmt *const script)
{
	if(script == NULL) /* happens for include() */
		return;
	if(pThis-&gt;last == NULL)
		pThis-&gt;root = pThis-&gt;last = script;
	else {
		pThis-&gt;last-&gt;next = script;
		pThis-&gt;last = script;
	}
}


/* set name for ruleset */
static rsRetVal rulesetSetName(ruleset_t *pThis, uchar *pszName)
{
	DEFiRet;
	free(pThis-&gt;pszName);
	CHKmalloc(pThis-&gt;pszName = ustrdup(pszName));

finalize_it:
	RETiRet;
}


/* get current ruleset
 * We use a non-standard calling interface, as nothing can go wrong and it
 * is really much more natural to return the pointer directly.
 */
static ruleset_t*
GetCurrent(rsconf_t *conf)
{
	return conf-&gt;rulesets.pCurr;
}


/* get main queue associated with ruleset. If no ruleset-specifc main queue
 * is set, the primary main message queue is returned.
 * We use a non-standard calling interface, as nothing can go wrong and it
 * is really much more natural to return the pointer directly.
 */
static qqueue_t*
GetRulesetQueue(ruleset_t *pThis)
{
	ISOBJ_TYPE_assert(pThis, ruleset);
	return (pThis-&gt;pQueue == NULL) ? runConf-&gt;pMsgQueue : pThis-&gt;pQueue;
}


/* Find the ruleset with the given name and return a pointer to its object.
 */
rsRetVal
rulesetGetRuleset(rsconf_t *conf, ruleset_t **ppRuleset, uchar *pszName)
{
	DEFiRet;
	assert(ppRuleset != NULL);
	assert(pszName != NULL);

	CHKiRet(llFind(&amp;(conf-&gt;rulesets.llRulesets), pszName, (void*) ppRuleset));

finalize_it:
	RETiRet;
}


/* Set a new default rule set. If the default can not be found, no change happens.
 */
static rsRetVal
SetDefaultRuleset(rsconf_t *conf, uchar *pszName)
{
	ruleset_t *pRuleset;
	DEFiRet;
	assert(pszName != NULL);

	CHKiRet(rulesetGetRuleset(conf, &amp;pRuleset, pszName));
	conf-&gt;rulesets.pDflt = pRuleset;
	DBGPRINTF(&quot;default rule set changed to %p: '%s'\n&quot;, pRuleset, pszName);

finalize_it:
	RETiRet;
}


/* Set a new current rule set. If the ruleset can not be found, no change happens */
static rsRetVal
SetCurrRuleset(rsconf_t *conf, uchar *pszName)
{
	ruleset_t *pRuleset;
	DEFiRet;
	assert(pszName != NULL);

	CHKiRet(rulesetGetRuleset(conf, &amp;pRuleset, pszName));
	conf-&gt;rulesets.pCurr = pRuleset;
	DBGPRINTF(&quot;current rule set changed to %p: '%s'\n&quot;, pRuleset, pszName);

finalize_it:
	RETiRet;
}


/* Standard-Constructor
 */
BEGINobjConstruct(ruleset) /* be sure to specify the object type also in END macro! */
	pThis-&gt;root = NULL;
	pThis-&gt;last = NULL;
ENDobjConstruct(ruleset)


/* ConstructionFinalizer
 * This also adds the rule set to the list of all known rulesets.
 */
static rsRetVal
rulesetConstructFinalize(rsconf_t *conf, ruleset_t *pThis)
{
	uchar *keyName;
	DEFiRet;
	ISOBJ_TYPE_assert(pThis, ruleset);

	/* we must duplicate our name, as the key destructer would also
	 * free it, resulting in a double-free. It's also cleaner to have
	 * two separate copies.
	 */
	CHKmalloc(keyName = ustrdup(pThis-&gt;pszName));
	CHKiRet(llAppend(&amp;(conf-&gt;rulesets.llRulesets), keyName, pThis));

	/* and also the default, if so far none has been set */
	if(conf-&gt;rulesets.pDflt == NULL)
		conf-&gt;rulesets.pDflt = pThis;

finalize_it:
	RETiRet;
}


/* destructor for the ruleset object */
BEGINobjDestruct(ruleset) /* be sure to specify the object type also in END and CODESTART macros! */
CODESTARTobjDestruct(ruleset)
	DBGPRINTF(&quot;destructing ruleset %p, name %p\n&quot;, pThis, pThis-&gt;pszName);
	if(pThis-&gt;pQueue != NULL) {
		qqueueDestruct(&amp;pThis-&gt;pQueue);
	}
	if(pThis-&gt;pParserLst != NULL) {
		parser.DestructParserList(&amp;pThis-&gt;pParserLst);
	}
	free(pThis-&gt;pszName);
ENDobjDestruct(ruleset)


/* helper for Destructor, shut down queue workers */
DEFFUNC_llExecFunc(doShutdownQueueWorkers)
{
	DEFiRet;
	ruleset_t *const pThis = (ruleset_t*) pData;
	DBGPRINTF(&quot;shutting down queue workers for ruleset %p, name %s, queue %p\n&quot;,
		pThis, pThis-&gt;pszName, pThis-&gt;pQueue);
	ISOBJ_TYPE_assert(pThis, ruleset);
	if(pThis-&gt;pQueue != NULL) {
		qqueueShutdownWorkers(pThis-&gt;pQueue);
	}
	RETiRet;
}
/* helper for Destructor, shut down actions (cnfstmt's in general) */
DEFFUNC_llExecFunc(doDestructCnfStmt)
{
	DEFiRet;
	ruleset_t *const pThis = (ruleset_t*) pData;
	DBGPRINTF(&quot;shutting down actions and conf stmts for ruleset %p, name %s\n&quot;,
		pThis, pThis-&gt;pszName);
	ISOBJ_TYPE_assert(pThis, ruleset);
	cnfstmtDestructLst(pThis-&gt;root);
	RETiRet;
}
/* destruct ALL rule sets that reside in the system. This must
 * be callable before unloading this module as the module may
 * not be unloaded before unload of the actions is required. This is
 * kind of a left-over from previous logic and may be optimized one
 * everything runs stable again. -- rgerhards, 2009-06-10
 */
static rsRetVal
destructAllActions(rsconf_t *conf)
{
	DEFiRet;

	DBGPRINTF(&quot;rulesetDestructAllActions\n&quot;);
	/* we first need to stop all queue workers, else we
	 * may run into trouble with &quot;call&quot; statements calling
	 * into then-destroyed rulesets.
	 * see: https://github.com/rsyslog/rsyslog/issues/1122
	 */
	DBGPRINTF(&quot;destructAllActions: queue shutdown\n&quot;);
	llExecFunc(&amp;(conf-&gt;rulesets.llRulesets), doShutdownQueueWorkers, NULL);
	DBGPRINTF(&quot;destructAllActions: action and conf stmt shutdown\n&quot;);
	llExecFunc(&amp;(conf-&gt;rulesets.llRulesets), doDestructCnfStmt, NULL);

	CHKiRet(llDestroy(&amp;(conf-&gt;rulesets.llRulesets)));
	CHKiRet(llInit(&amp;(conf-&gt;rulesets.llRulesets), rulesetDestructForLinkedList,
		rulesetKeyDestruct, strcasecmp));
	conf-&gt;rulesets.pDflt = NULL;

finalize_it:
	RETiRet;
}

/* this is a special destructor for the linkedList class. LinkedList does NOT
 * provide a pointer to the pointer, but rather the raw pointer itself. So we
 * must map this, otherwise the destructor will abort.
 */
rsRetVal
rulesetDestructForLinkedList(void *pData)
{
	ruleset_t *pThis = (ruleset_t*) pData;
	return rulesetDestruct(&amp;pThis);
}

/* debugprint for the ruleset object */
BEGINobjDebugPrint(ruleset) /* be sure to specify the object type also in END and CODESTART macros! */
CODESTARTobjDebugPrint(ruleset)
	dbgoprint((obj_t*) pThis, &quot;rsyslog ruleset %s:\n&quot;, pThis-&gt;pszName);
	cnfstmtPrint(pThis-&gt;root, 0);
	dbgoprint((obj_t*) pThis, &quot;ruleset %s assigned parser list:\n&quot;, pThis-&gt;pszName);
	printParserList(pThis-&gt;pParserLst);
ENDobjDebugPrint(ruleset)


/* helper for debugPrintAll(), prints a single ruleset */
DEFFUNC_llExecFunc(doDebugPrintAll)
{
	return rulesetDebugPrint((ruleset_t*) pData);
}
/* debug print all rulesets
 */
static rsRetVal
debugPrintAll(rsconf_t *conf)
{
	DEFiRet;
	dbgprintf(&quot;All Rulesets:\n&quot;);
	llExecFunc(&amp;(conf-&gt;rulesets.llRulesets), doDebugPrintAll, NULL);
	dbgprintf(&quot;End of Rulesets.\n&quot;);
	RETiRet;
}

struct cnfstmt * removeNOPs(struct cnfstmt *root);
static void
rulesetOptimize(ruleset_t *pRuleset)
{
	if(Debug) {
		dbgprintf(&quot;ruleset '%s' before optimization:\n&quot;,
			  pRuleset-&gt;pszName);
		rulesetDebugPrint((ruleset_t*) pRuleset);
	}
	pRuleset-&gt;root = cnfstmtOptimize(pRuleset-&gt;root);
	if(Debug) {
		dbgprintf(&quot;ruleset '%s' after optimization:\n&quot;,
			  pRuleset-&gt;pszName);
		rulesetDebugPrint((ruleset_t*) pRuleset);
	}
}

/* helper for rulsetOptimizeAll(), optimizes a single ruleset */
DEFFUNC_llExecFunc(doRulesetOptimizeAll)
{
	rulesetOptimize((ruleset_t*) pData);
	return RS_RET_OK;
}
/* optimize all rulesets
 */
rsRetVal
rulesetOptimizeAll(rsconf_t *conf)
{
	DEFiRet;
	dbgprintf(&quot;begin ruleset optimization phase\n&quot;);
	llExecFunc(&amp;(conf-&gt;rulesets.llRulesets), doRulesetOptimizeAll, NULL);
	dbgprintf(&quot;ruleset optimization phase finished.\n&quot;);
	RETiRet;
}


/* Create a ruleset-specific &quot;main&quot; queue for this ruleset. If one is already
 * defined, an error message is emitted but nothing else is done.
 * Note: we use the main message queue parameters for queue creation and access
 * syslogd.c directly to obtain these. This is far from being perfect, but
 * considered acceptable for the time being.
 * rgerhards, 2009-10-27
 */
static rsRetVal
doRulesetCreateQueue(rsconf_t *conf, int *pNewVal)
{
	uchar *rsname;
	DEFiRet;

	if(conf-&gt;rulesets.pCurr == NULL) {
		LogError(0, RS_RET_NO_CURR_RULESET, &quot;error: currently no specific ruleset specified, thus a &quot;
				&quot;queue can not be added to it&quot;);
		ABORT_FINALIZE(RS_RET_NO_CURR_RULESET);
	}

	if(conf-&gt;rulesets.pCurr-&gt;pQueue != NULL) {
		LogError(0, RS_RET_RULES_QUEUE_EXISTS, &quot;error: ruleset already has a main queue, can not &quot;
				&quot;add another one&quot;);
		ABORT_FINALIZE(RS_RET_RULES_QUEUE_EXISTS);
	}

	if(pNewVal == 0)
		FINALIZE; /* if it is turned off, we do not need to change anything ;) */

	rsname = (conf-&gt;rulesets.pCurr-&gt;pszName == NULL) ? (uchar*) &quot;[ruleset]&quot; : conf-&gt;rulesets.pCurr-&gt;pszName;
	DBGPRINTF(&quot;adding a ruleset-specific \&quot;main\&quot; queue for ruleset '%s'\n&quot;, rsname);
	CHKiRet(createMainQueue(&amp;conf-&gt;rulesets.pCurr-&gt;pQueue, rsname, NULL));

finalize_it:
	RETiRet;
}

static rsRetVal
rulesetCreateQueue(void __attribute__((unused)) *pVal, int *pNewVal)
{
	return doRulesetCreateQueue(ourConf, pNewVal);
}

/* Add a ruleset specific parser to the ruleset. Note that adding the first
 * parser automatically disables the default parsers. If they are needed as well,
 * the must be added via explicit config directives.
 * Note: this is the only spot in the code that requires the parser object. In order
 * to solve some class init bootstrap sequence problems, we get the object handle here
 * instead of during module initialization. Note that objUse() is capable of being
 * called multiple times.
 * rgerhards, 2009-11-04
 */
static rsRetVal
doRulesetAddParser(ruleset_t *pRuleset, uchar *pName)
{
	parser_t *pParser;
	DEFiRet;

	CHKiRet(objUse(parser, CORE_COMPONENT));
	iRet = parser.FindParser(loadConf-&gt;parsers.pParsLstRoot, &amp;pParser, pName);
	if(iRet == RS_RET_PARSER_NOT_FOUND) {
		LogError(0, RS_RET_PARSER_NOT_FOUND, &quot;error: parser '%s' unknown at this time &quot;
			  	&quot;(maybe defined too late in rsyslog.conf?)&quot;, pName);
		ABORT_FINALIZE(RS_RET_NO_CURR_RULESET);
	} else if(iRet != RS_RET_OK) {
		LogError(0, iRet, &quot;error trying to find parser '%s'\n&quot;, pName);
		FINALIZE;
	}

	CHKiRet(parser.AddParserToList(&amp;pRuleset-&gt;pParserLst, pParser));

	DBGPRINTF(&quot;added parser '%s' to ruleset '%s'\n&quot;, pName, pRuleset-&gt;pszName);

finalize_it:
	free(pName); /* no longer needed */

	RETiRet;
}

static rsRetVal
rulesetAddParser(void __attribute__((unused)) *pVal, uchar *pName)
{
	return doRulesetAddParser(loadConf-&gt;rulesets.pCurr, pName);
}


/* Process ruleset() objects */
rsRetVal
rulesetProcessCnf(struct cnfobj *o)
{
	struct cnfparamvals *pvals;
	rsRetVal localRet;
	uchar *rsName = NULL;
	uchar *parserName;
	int nameIdx, parserIdx;
	ruleset_t *pRuleset;
	struct cnfarray *ar;
	int i;
	int qtype;
	uchar *rsname;
	DEFiRet;

	pvals = nvlstGetParams(o-&gt;nvlst, &amp;rspblk, NULL);
	if(pvals == NULL) {
		ABORT_FINALIZE(RS_RET_CONFIG_ERROR);
	}
	DBGPRINTF(&quot;ruleset param blk after rulesetProcessCnf:\n&quot;);
	cnfparamsPrint(&amp;rspblk, pvals);
	nameIdx = cnfparamGetIdx(&amp;rspblk, &quot;name&quot;);
	rsName = (uchar*)es_str2cstr(pvals[nameIdx].val.d.estr, NULL);

	localRet = rulesetGetRuleset(loadConf, &amp;pRuleset, rsName);
	if(localRet == RS_RET_OK) {
		LogError(0, RS_RET_RULESET_EXISTS,
			&quot;error: ruleset '%s' specified more than once&quot;,
			rsName);
		cnfstmtDestructLst(o-&gt;script);
		ABORT_FINALIZE(RS_RET_RULESET_EXISTS);
	} else if(localRet != RS_RET_NOT_FOUND) {
		ABORT_FINALIZE(localRet);
	}

	CHKiRet(rulesetConstruct(&amp;pRuleset));
	if((localRet = rulesetSetName(pRuleset, rsName)) != RS_RET_OK) {
		rulesetDestruct(&amp;pRuleset);
		ABORT_FINALIZE(localRet);
	}
	if((localRet = rulesetConstructFinalize(loadConf, pRuleset)) != RS_RET_OK) {
		rulesetDestruct(&amp;pRuleset);
		ABORT_FINALIZE(localRet);
	}
	addScript(pRuleset, o-&gt;script);

	/* we have only two params, so we do NOT do the usual param loop */
	parserIdx = cnfparamGetIdx(&amp;rspblk, &quot;parser&quot;);
	if(parserIdx != -1  &amp;&amp; pvals[parserIdx].bUsed) {
		ar = pvals[parserIdx].val.d.ar;
		for(i = 0 ; i &lt;  ar-&gt;nmemb ; ++i) {
			parserName = (uchar*)es_str2cstr(ar-&gt;arr[i], NULL);
			doRulesetAddParser(pRuleset, parserName);
			/* note parserName is freed in doRulesetAddParser()! */
		}
	}

	/* pick up ruleset queue parameters */
	if(queueCnfParamsSet(o-&gt;nvlst)) {
		if(pRuleset-&gt;pszName == NULL) {
			rsname = (uchar*) &quot;[ruleset]&quot;;
			qtype = pRuleset-&gt;pQueue-&gt;qType;
		} else {
			rsname = pRuleset-&gt;pszName;
			qtype = 3;
		}
		DBGPRINTF(&quot;adding a ruleset-specific \&quot;main\&quot; queue for ruleset '%s', mode %d\n&quot;,
			rsname, qtype);
		CHKiRet(createMainQueue(&amp;pRuleset-&gt;pQueue, rsname, o-&gt;nvlst));
	}

finalize_it:
	free(rsName);
	cnfparamvalsDestruct(pvals, &amp;rspblk);
	RETiRet;
}


/* queryInterface function
 * rgerhards, 2008-02-21
 */
BEGINobjQueryInterface(ruleset)
CODESTARTobjQueryInterface(ruleset)
	if(pIf-&gt;ifVersion != rulesetCURR_IF_VERSION) { /* check for current version, increment on each change */
		ABORT_FINALIZE(RS_RET_INTERFACE_NOT_SUPPORTED);
	}

	/* ok, we have the right interface, so let's fill it
	 * Please note that we may also do some backwards-compatibility
	 * work here (if we can support an older interface version - that,
	 * of course, also affects the &quot;if&quot; above).
	 */
	pIf-&gt;Construct = rulesetConstruct;
	pIf-&gt;ConstructFinalize = rulesetConstructFinalize;
	pIf-&gt;Destruct = rulesetDestruct;
	pIf-&gt;DebugPrint = rulesetDebugPrint;

	pIf-&gt;IterateAllActions = iterateAllActions;
	pIf-&gt;DestructAllActions = destructAllActions;
	pIf-&gt;AddScript = addScript;
	pIf-&gt;ProcessBatch = processBatch;
	pIf-&gt;SetName = rulesetSetName;
	pIf-&gt;DebugPrintAll = debugPrintAll;
	pIf-&gt;GetCurrent = GetCurrent;
	pIf-&gt;GetRuleset = rulesetGetRuleset;
	pIf-&gt;SetDefaultRuleset = SetDefaultRuleset;
	pIf-&gt;SetCurrRuleset = SetCurrRuleset;
	pIf-&gt;GetRulesetQueue = GetRulesetQueue;
	pIf-&gt;GetParserList = GetParserList;
finalize_it:
ENDobjQueryInterface(ruleset)


/* Exit the ruleset class.
 * rgerhards, 2009-04-06
 */
BEGINObjClassExit(ruleset, OBJ_IS_CORE_MODULE) /* class, version */
	objRelease(parser, CORE_COMPONENT);
ENDObjClassExit(ruleset)


/* Initialize the ruleset class. Must be called as the very first method
 * before anything else is called inside this class.
 * rgerhards, 2008-02-19
 */
BEGINObjClassInit(ruleset, 1, OBJ_IS_CORE_MODULE) /* class, version */
	/* request objects we use */

	/* set our own handlers */
	OBJSetMethodHandler(objMethod_DEBUGPRINT, rulesetDebugPrint);
	OBJSetMethodHandler(objMethod_CONSTRUCTION_FINALIZER, rulesetConstructFinalize);

	/* config file handlers */
	CHKiRet(regCfSysLineHdlr((uchar *)&quot;rulesetparser&quot;, 0, eCmdHdlrGetWord, rulesetAddParser, NULL, NULL));
	CHKiRet(regCfSysLineHdlr((uchar *)&quot;rulesetcreatemainqueue&quot;, 0, eCmdHdlrBinary, rulesetCreateQueue,
		NULL, NULL));
ENDObjClassInit(ruleset)
</PRE>
</div>
  </div>
</body>
</html>
