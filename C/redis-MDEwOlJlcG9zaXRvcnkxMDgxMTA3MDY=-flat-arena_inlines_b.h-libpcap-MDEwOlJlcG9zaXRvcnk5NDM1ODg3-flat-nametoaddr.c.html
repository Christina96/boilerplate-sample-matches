
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 1.9277108433734942%, Tokens: 8</h2>
        <div class="column">
            <h3>redis-MDEwOlJlcG9zaXRvcnkxMDgxMTA3MDY=-flat-arena_inlines_b.h</h3>
            <pre><code>1  #ifndef JEMALLOC_INTERNAL_ARENA_INLINES_B_H
2  #define JEMALLOC_INTERNAL_ARENA_INLINES_B_H
3  #include "jemalloc/internal/jemalloc_internal_types.h"
4  #include "jemalloc/internal/mutex.h"
5  #include "jemalloc/internal/rtree.h"
6  #include "jemalloc/internal/sc.h"
7  #include "jemalloc/internal/sz.h"
8  #include "jemalloc/internal/ticker.h"
9  JEMALLOC_ALWAYS_INLINE bool
10  arena_has_default_hooks(arena_t *arena) {
11  	return (extent_hooks_get(arena) == &extent_hooks_default);
12  }
13  JEMALLOC_ALWAYS_INLINE arena_t *
14  arena_choose_maybe_huge(tsd_t *tsd, arena_t *arena, size_t size) {
15  	if (arena != NULL) {
16  		return arena;
17  	}
<span onclick='openModal()' class='match'>18  	if (unlikely(size >= oversize_threshold)) {
19  		arena_t *tsd_arena = tsd_arena_get(tsd);
20  		if (tsd_arena == NULL || arena_is_auto(tsd_arena)) {
21  			return arena_choose_huge(tsd);
22  		}
</span>23  	}
24  	return arena_choose(tsd, NULL);
25  }
26  JEMALLOC_ALWAYS_INLINE prof_tctx_t *
27  arena_prof_tctx_get(tsdn_t *tsdn, const void *ptr, alloc_ctx_t *alloc_ctx) {
28  	cassert(config_prof);
29  	assert(ptr != NULL);
30  	if (alloc_ctx == NULL) {
31  		const extent_t *extent = iealloc(tsdn, ptr);
32  		if (unlikely(!extent_slab_get(extent))) {
33  			return large_prof_tctx_get(tsdn, extent);
34  		}
35  	} else {
36  		if (unlikely(!alloc_ctx->slab)) {
37  			return large_prof_tctx_get(tsdn, iealloc(tsdn, ptr));
38  		}
39  	}
40  	return (prof_tctx_t *)(uintptr_t)1U;
41  }
42  JEMALLOC_ALWAYS_INLINE void
43  arena_prof_tctx_set(tsdn_t *tsdn, const void *ptr, size_t usize,
44      alloc_ctx_t *alloc_ctx, prof_tctx_t *tctx) {
45  	cassert(config_prof);
46  	assert(ptr != NULL);
47  	if (alloc_ctx == NULL) {
48  		extent_t *extent = iealloc(tsdn, ptr);
49  		if (unlikely(!extent_slab_get(extent))) {
50  			large_prof_tctx_set(tsdn, extent, tctx);
51  		}
52  	} else {
53  		if (unlikely(!alloc_ctx->slab)) {
54  			large_prof_tctx_set(tsdn, iealloc(tsdn, ptr), tctx);
55  		}
56  	}
57  }
58  static inline void
59  arena_prof_tctx_reset(tsdn_t *tsdn, const void *ptr, prof_tctx_t *tctx) {
60  	cassert(config_prof);
61  	assert(ptr != NULL);
62  	extent_t *extent = iealloc(tsdn, ptr);
63  	assert(!extent_slab_get(extent));
64  	large_prof_tctx_reset(tsdn, extent);
65  }
66  JEMALLOC_ALWAYS_INLINE nstime_t
67  arena_prof_alloc_time_get(tsdn_t *tsdn, const void *ptr,
68      alloc_ctx_t *alloc_ctx) {
69  	cassert(config_prof);
70  	assert(ptr != NULL);
71  	extent_t *extent = iealloc(tsdn, ptr);
72  	assert(!extent_slab_get(extent));
73  	return large_prof_alloc_time_get(extent);
74  }
75  JEMALLOC_ALWAYS_INLINE void
76  arena_prof_alloc_time_set(tsdn_t *tsdn, const void *ptr, alloc_ctx_t *alloc_ctx,
77      nstime_t t) {
78  	cassert(config_prof);
79  	assert(ptr != NULL);
80  	extent_t *extent = iealloc(tsdn, ptr);
81  	assert(!extent_slab_get(extent));
82  	large_prof_alloc_time_set(extent, t);
83  }
84  JEMALLOC_ALWAYS_INLINE void
85  arena_decay_ticks(tsdn_t *tsdn, arena_t *arena, unsigned nticks) {
86  	tsd_t *tsd;
87  	ticker_t *decay_ticker;
88  	if (unlikely(tsdn_null(tsdn))) {
89  		return;
90  	}
91  	tsd = tsdn_tsd(tsdn);
92  	decay_ticker = decay_ticker_get(tsd, arena_ind_get(arena));
93  	if (unlikely(decay_ticker == NULL)) {
94  		return;
95  	}
96  	if (unlikely(ticker_ticks(decay_ticker, nticks))) {
97  		arena_decay(tsdn, arena, false, false);
98  	}
99  }
100  JEMALLOC_ALWAYS_INLINE void
101  arena_decay_tick(tsdn_t *tsdn, arena_t *arena) {
102  	malloc_mutex_assert_not_owner(tsdn, &arena->decay_dirty.mtx);
103  	malloc_mutex_assert_not_owner(tsdn, &arena->decay_muzzy.mtx);
104  	arena_decay_ticks(tsdn, arena, 1);
105  }
106  JEMALLOC_ALWAYS_INLINE void
107  arena_decay_extent(tsdn_t *tsdn,arena_t *arena, extent_hooks_t **r_extent_hooks,
108      extent_t *extent) {
109  	size_t extent_size = extent_size_get(extent);
110  	extent_dalloc_wrapper(tsdn, arena,
111  	    r_extent_hooks, extent);
112  	if (config_stats) {
113  		arena_stats_lock(tsdn, &arena->stats);
114  		arena_stats_add_u64(tsdn, &arena->stats,
115  		    &arena->decay_dirty.stats->nmadvise, 1);
116  		arena_stats_add_u64(tsdn, &arena->stats,
117  		    &arena->decay_dirty.stats->purged, extent_size >> LG_PAGE);
118  		arena_stats_sub_zu(tsdn, &arena->stats, &arena->stats.mapped,
119  		    extent_size);
120  		arena_stats_unlock(tsdn, &arena->stats);
121  	}
122  }
123  JEMALLOC_ALWAYS_INLINE void *
124  arena_malloc(tsdn_t *tsdn, arena_t *arena, size_t size, szind_t ind, bool zero,
125      tcache_t *tcache, bool slow_path) {
126  	assert(!tsdn_null(tsdn) || tcache == NULL);
127  	if (likely(tcache != NULL)) {
128  		if (likely(size <= SC_SMALL_MAXCLASS)) {
129  			return tcache_alloc_small(tsdn_tsd(tsdn), arena,
130  			    tcache, size, ind, zero, slow_path);
131  		}
132  		if (likely(size <= tcache_maxclass)) {
133  			return tcache_alloc_large(tsdn_tsd(tsdn), arena,
134  			    tcache, size, ind, zero, slow_path);
135  		}
136  		assert(size > tcache_maxclass);
137  	}
138  	return arena_malloc_hard(tsdn, arena, size, ind, zero);
139  }
140  JEMALLOC_ALWAYS_INLINE arena_t *
141  arena_aalloc(tsdn_t *tsdn, const void *ptr) {
142  	return extent_arena_get(iealloc(tsdn, ptr));
143  }
144  JEMALLOC_ALWAYS_INLINE size_t
145  arena_salloc(tsdn_t *tsdn, const void *ptr) {
146  	assert(ptr != NULL);
147  	rtree_ctx_t rtree_ctx_fallback;
148  	rtree_ctx_t *rtree_ctx = tsdn_rtree_ctx(tsdn, &rtree_ctx_fallback);
149  	szind_t szind = rtree_szind_read(tsdn, &extents_rtree, rtree_ctx,
150  	    (uintptr_t)ptr, true);
151  	assert(szind != SC_NSIZES);
152  	return sz_index2size(szind);
153  }
154  JEMALLOC_ALWAYS_INLINE size_t
155  arena_vsalloc(tsdn_t *tsdn, const void *ptr) {
156  	rtree_ctx_t rtree_ctx_fallback;
157  	rtree_ctx_t *rtree_ctx = tsdn_rtree_ctx(tsdn, &rtree_ctx_fallback);
158  	extent_t *extent;
159  	szind_t szind;
160  	if (rtree_extent_szind_read(tsdn, &extents_rtree, rtree_ctx,
161  	    (uintptr_t)ptr, false, &extent, &szind)) {
162  		return 0;
163  	}
164  	if (extent == NULL) {
165  		return 0;
166  	}
167  	assert(extent_state_get(extent) == extent_state_active);
168  	assert(extent_addr_get(extent) == ptr || extent_slab_get(extent));
169  	assert(szind != SC_NSIZES);
170  	return sz_index2size(szind);
171  }
172  static inline void
173  arena_dalloc_large_no_tcache(tsdn_t *tsdn, void *ptr, szind_t szind) {
174  	if (config_prof && unlikely(szind < SC_NBINS)) {
175  		arena_dalloc_promoted(tsdn, ptr, NULL, true);
176  	} else {
177  		extent_t *extent = iealloc(tsdn, ptr);
178  		large_dalloc(tsdn, extent);
179  	}
180  }
181  static inline void
182  arena_dalloc_no_tcache(tsdn_t *tsdn, void *ptr) {
183  	assert(ptr != NULL);
184  	rtree_ctx_t rtree_ctx_fallback;
185  	rtree_ctx_t *rtree_ctx = tsdn_rtree_ctx(tsdn, &rtree_ctx_fallback);
186  	szind_t szind;
187  	bool slab;
188  	rtree_szind_slab_read(tsdn, &extents_rtree, rtree_ctx, (uintptr_t)ptr,
189  	    true, &szind, &slab);
190  	if (config_debug) {
191  		extent_t *extent = rtree_extent_read(tsdn, &extents_rtree,
192  		    rtree_ctx, (uintptr_t)ptr, true);
193  		assert(szind == extent_szind_get(extent));
194  		assert(szind < SC_NSIZES);
195  		assert(slab == extent_slab_get(extent));
196  	}
197  	if (likely(slab)) {
198  		arena_dalloc_small(tsdn, ptr);
199  	} else {
200  		arena_dalloc_large_no_tcache(tsdn, ptr, szind);
201  	}
202  }
203  JEMALLOC_ALWAYS_INLINE void
204  arena_dalloc_large(tsdn_t *tsdn, void *ptr, tcache_t *tcache, szind_t szind,
205      bool slow_path) {
206  	if (szind < nhbins) {
207  		if (config_prof && unlikely(szind < SC_NBINS)) {
208  			arena_dalloc_promoted(tsdn, ptr, tcache, slow_path);
209  		} else {
210  			tcache_dalloc_large(tsdn_tsd(tsdn), tcache, ptr, szind,
211  			    slow_path);
212  		}
213  	} else {
214  		extent_t *extent = iealloc(tsdn, ptr);
215  		large_dalloc(tsdn, extent);
216  	}
217  }
218  JEMALLOC_ALWAYS_INLINE void
219  arena_dalloc(tsdn_t *tsdn, void *ptr, tcache_t *tcache,
220      alloc_ctx_t *alloc_ctx, bool slow_path) {
221  	assert(!tsdn_null(tsdn) || tcache == NULL);
222  	assert(ptr != NULL);
223  	if (unlikely(tcache == NULL)) {
224  		arena_dalloc_no_tcache(tsdn, ptr);
225  		return;
226  	}
227  	szind_t szind;
228  	bool slab;
229  	rtree_ctx_t *rtree_ctx;
230  	if (alloc_ctx != NULL) {
231  		szind = alloc_ctx->szind;
232  		slab = alloc_ctx->slab;
233  		assert(szind != SC_NSIZES);
234  	} else {
235  		rtree_ctx = tsd_rtree_ctx(tsdn_tsd(tsdn));
236  		rtree_szind_slab_read(tsdn, &extents_rtree, rtree_ctx,
237  		    (uintptr_t)ptr, true, &szind, &slab);
238  	}
239  	if (config_debug) {
240  		rtree_ctx = tsd_rtree_ctx(tsdn_tsd(tsdn));
241  		extent_t *extent = rtree_extent_read(tsdn, &extents_rtree,
242  		    rtree_ctx, (uintptr_t)ptr, true);
243  		assert(szind == extent_szind_get(extent));
244  		assert(szind < SC_NSIZES);
245  		assert(slab == extent_slab_get(extent));
246  	}
247  	if (likely(slab)) {
248  		tcache_dalloc_small(tsdn_tsd(tsdn), tcache, ptr, szind,
249  		    slow_path);
250  	} else {
251  		arena_dalloc_large(tsdn, ptr, tcache, szind, slow_path);
252  	}
253  }
254  static inline void
255  arena_sdalloc_no_tcache(tsdn_t *tsdn, void *ptr, size_t size) {
256  	assert(ptr != NULL);
257  	assert(size <= SC_LARGE_MAXCLASS);
258  	szind_t szind;
259  	bool slab;
260  	if (!config_prof || !opt_prof) {
261  		szind = sz_size2index(size);
262  		slab = (szind < SC_NBINS);
263  	}
264  	if ((config_prof && opt_prof) || config_debug) {
265  		rtree_ctx_t rtree_ctx_fallback;
266  		rtree_ctx_t *rtree_ctx = tsdn_rtree_ctx(tsdn,
267  		    &rtree_ctx_fallback);
268  		rtree_szind_slab_read(tsdn, &extents_rtree, rtree_ctx,
269  		    (uintptr_t)ptr, true, &szind, &slab);
270  		assert(szind == sz_size2index(size));
271  		assert((config_prof && opt_prof) || slab == (szind < SC_NBINS));
272  		if (config_debug) {
273  			extent_t *extent = rtree_extent_read(tsdn,
274  			    &extents_rtree, rtree_ctx, (uintptr_t)ptr, true);
275  			assert(szind == extent_szind_get(extent));
276  			assert(slab == extent_slab_get(extent));
277  		}
278  	}
279  	if (likely(slab)) {
280  		arena_dalloc_small(tsdn, ptr);
281  	} else {
282  		arena_dalloc_large_no_tcache(tsdn, ptr, szind);
283  	}
284  }
285  JEMALLOC_ALWAYS_INLINE void
286  arena_sdalloc(tsdn_t *tsdn, void *ptr, size_t size, tcache_t *tcache,
287      alloc_ctx_t *alloc_ctx, bool slow_path) {
288  	assert(!tsdn_null(tsdn) || tcache == NULL);
289  	assert(ptr != NULL);
290  	assert(size <= SC_LARGE_MAXCLASS);
291  	if (unlikely(tcache == NULL)) {
292  		arena_sdalloc_no_tcache(tsdn, ptr, size);
293  		return;
294  	}
295  	szind_t szind;
296  	bool slab;
297  	alloc_ctx_t local_ctx;
298  	if (config_prof && opt_prof) {
299  		if (alloc_ctx == NULL) {
300  			rtree_ctx_t rtree_ctx_fallback;
301  			rtree_ctx_t *rtree_ctx = tsdn_rtree_ctx(tsdn,
302  			    &rtree_ctx_fallback);
303  			rtree_szind_slab_read(tsdn, &extents_rtree, rtree_ctx,
304  			    (uintptr_t)ptr, true, &local_ctx.szind,
305  			    &local_ctx.slab);
306  			assert(local_ctx.szind == sz_size2index(size));
307  			alloc_ctx = &local_ctx;
308  		}
309  		slab = alloc_ctx->slab;
310  		szind = alloc_ctx->szind;
311  	} else {
312  		szind = sz_size2index(size);
313  		slab = (szind < SC_NBINS);
314  	}
315  	if (config_debug) {
316  		rtree_ctx_t *rtree_ctx = tsd_rtree_ctx(tsdn_tsd(tsdn));
317  		rtree_szind_slab_read(tsdn, &extents_rtree, rtree_ctx,
318  		    (uintptr_t)ptr, true, &szind, &slab);
319  		extent_t *extent = rtree_extent_read(tsdn,
320  		    &extents_rtree, rtree_ctx, (uintptr_t)ptr, true);
321  		assert(szind == extent_szind_get(extent));
322  		assert(slab == extent_slab_get(extent));
323  	}
324  	if (likely(slab)) {
325  		tcache_dalloc_small(tsdn_tsd(tsdn), tcache, ptr, szind,
326  		    slow_path);
327  	} else {
328  		arena_dalloc_large(tsdn, ptr, tcache, szind, slow_path);
329  	}
330  }
331  #endif &bsol;* JEMALLOC_INTERNAL_ARENA_INLINES_B_H */
</code></pre>
        </div>
        <div class="column">
            <h3>libpcap-MDEwOlJlcG9zaXRvcnk5NDM1ODg3-flat-nametoaddr.c</h3>
            <pre><code>1  #ifdef HAVE_CONFIG_H
2  #include <config.h>
3  #endif
4  #ifdef _WIN32
5    #include <winsock2.h>
6    #include <ws2tcpip.h>
7    #ifdef INET6
8      #include <wspiapi.h>
9    #endif &bsol;* INET6 */
10  #else &bsol;* _WIN32 */
11    #include <sys/param.h>
12    #include <sys/types.h>
13    #include <sys/socket.h>
14    #include <sys/time.h>
15    #include <netinet/in.h>
16    #ifdef HAVE_ETHER_HOSTTON
17      #if defined(NET_ETHERNET_H_DECLARES_ETHER_HOSTTON)
18        #include <net/ethernet.h>
19      #elif defined(NETINET_ETHER_H_DECLARES_ETHER_HOSTTON)
20        #include <netinet/ether.h>
21      #elif defined(SYS_ETHERNET_H_DECLARES_ETHER_HOSTTON)
22        #include <sys/ethernet.h>
23      #elif defined(ARPA_INET_H_DECLARES_ETHER_HOSTTON)
24        #include <arpa/inet.h>
25      #elif defined(NETINET_IF_ETHER_H_DECLARES_ETHER_HOSTTON)
26        #define NEED_NETINET_IF_ETHER_H
27      #else
28        #ifdef HAVE_STRUCT_ETHER_ADDR
29          #define NEED_NETINET_IF_ETHER_H
30        #else &bsol;* HAVE_STRUCT_ETHER_ADDR */
31  	struct ether_addr {
32  		unsigned char ether_addr_octet[6];
33  	};
34        #endif &bsol;* HAVE_STRUCT_ETHER_ADDR */
35      #endif &bsol;* what declares ether_hostton() */
36      #ifdef NEED_NETINET_IF_ETHER_H
37        #include <net/if.h>	&bsol;* Needed on some platforms */
38        #include <netinet/in.h>	&bsol;* Needed on some platforms */
39        #include <netinet/if_ether.h>
40      #endif &bsol;* NEED_NETINET_IF_ETHER_H */
41      #ifndef HAVE_DECL_ETHER_HOSTTON
42        extern int ether_hostton(const char *, struct ether_addr *);
43      #endif &bsol;* !defined(HAVE_DECL_ETHER_HOSTTON) */
44    #endif &bsol;* HAVE_ETHER_HOSTTON */
45    #include <arpa/inet.h>
46    #include <netdb.h>
47  #endif &bsol;* _WIN32 */
48  #include <errno.h>
49  #include <stdlib.h>
50  #include <string.h>
51  #include <stdio.h>
52  #include "pcap-int.h"
53  #include "diag-control.h"
54  #include "gencode.h"
55  #include <pcap/namedb.h>
56  #include "nametoaddr.h"
57  #include "thread-local.h"
58  #ifdef HAVE_OS_PROTO_H
59  #include "os-proto.h"
60  #endif
61  #ifndef NTOHL
62  #define NTOHL(x) (x) = ntohl(x)
63  #define NTOHS(x) (x) = ntohs(x)
64  #endif
65  bpf_u_int32 **
66  pcap_nametoaddr(const char *name)
67  {
68  #ifndef h_addr
69  	static bpf_u_int32 *hlist[2];
70  #endif
71  	bpf_u_int32 **p;
72  	struct hostent *hp;
73  DIAG_OFF_DEPRECATION
74  	if ((hp = gethostbyname(name)) != NULL) {
75  DIAG_ON_DEPRECATION
76  #ifndef h_addr
77  		hlist[0] = (bpf_u_int32 *)hp->h_addr;
78  		NTOHL(hp->h_addr);
79  		return hlist;
80  #else
81  		for (p = (bpf_u_int32 **)hp->h_addr_list; *p; ++p)
82  			NTOHL(**p);
83  		return (bpf_u_int32 **)hp->h_addr_list;
84  #endif
85  	}
86  	else
87  		return 0;
88  }
89  struct addrinfo *
90  pcap_nametoaddrinfo(const char *name)
91  {
92  	struct addrinfo hints, *res;
93  	int error;
94  	memset(&hints, 0, sizeof(hints));
95  	hints.ai_family = PF_UNSPEC;
96  	hints.ai_socktype = SOCK_STREAM;	&bsol;*not really*/
97  	hints.ai_protocol = IPPROTO_TCP;	&bsol;*not really*/
98  	error = getaddrinfo(name, NULL, &hints, &res);
99  	if (error)
100  		return NULL;
101  	else
102  		return res;
103  }
104  #if defined(_WIN32) || defined(__CYGWIN__)
105  bpf_u_int32
106  pcap_nametonetaddr(const char *name _U_)
107  {
108  	return 0;
109  }
110  #else &bsol;* _WIN32 */
111  bpf_u_int32
112  pcap_nametonetaddr(const char *name)
113  {
114  	struct netent *np;
115    #if defined(HAVE_LINUX_GETNETBYNAME_R)
116  	struct netent result_buf;
117  	char buf[1024];	&bsol;* arbitrary size */
118  	int h_errnoval;
119  	int err;
120  	np = NULL;
121  	err = getnetbyname_r(name, &result_buf, buf, sizeof buf, &np,
122  	    &h_errnoval);
123  	if (err != 0) {
124  		return 0;
125  	}
126    #elif defined(HAVE_SOLARIS_IRIX_GETNETBYNAME_R)
127  	struct netent result_buf;
128  	char buf[1024];	&bsol;* arbitrary size */
129  	np = getnetbyname_r(name, &result_buf, buf, (int)sizeof buf);
130    #elif defined(HAVE_AIX_GETNETBYNAME_R)
131  	struct netent result_buf;
132  	struct netent_data net_data;
133  	if (getnetbyname_r(name, &result_buf, &net_data) == -1)
134  		np = NULL;
135  	else
136  		np = &result_buf;
137    #else
138  	np = getnetbyname(name);
139    #endif
140  	if (np != NULL)
141  		return np->n_net;
142  	else
143  		return 0;
144  }
145  #endif &bsol;* _WIN32 */
146  int
147  pcap_nametoport(const char *name, int *port, int *proto)
148  {
149  	struct addrinfo hints, *res, *ai;
150  	int error;
151  	struct sockaddr_in *in4;
152  #ifdef INET6
153  	struct sockaddr_in6 *in6;
154  #endif
155  	int tcp_port = -1;
156  	int udp_port = -1;
157  	memset(&hints, 0, sizeof(hints));
158  	hints.ai_family = PF_UNSPEC;
159  	hints.ai_socktype = SOCK_STREAM;
160  	hints.ai_protocol = IPPROTO_TCP;
161  	error = getaddrinfo(NULL, name, &hints, &res);
162  	if (error != 0) {
163  		if (error != EAI_NONAME &&
164  		    error != EAI_SERVICE) {
165  			return 0;
166  		}
167  	} else {
168  		for (ai = res; ai != NULL; ai = ai->ai_next) {
169  			if (ai->ai_addr != NULL) {
170  				if (ai->ai_addr->sa_family == AF_INET) {
171  					in4 = (struct sockaddr_in *)ai->ai_addr;
172  					tcp_port = ntohs(in4->sin_port);
173  					break;
174  				}
175  #ifdef INET6
176  				if (ai->ai_addr->sa_family == AF_INET6) {
177  					in6 = (struct sockaddr_in6 *)ai->ai_addr;
178  					tcp_port = ntohs(in6->sin6_port);
179  					break;
180  				}
181  #endif
182  			}
183  		}
184  		freeaddrinfo(res);
185  	}
186  	memset(&hints, 0, sizeof(hints));
187  	hints.ai_family = PF_UNSPEC;
188  	hints.ai_socktype = SOCK_DGRAM;
189  	hints.ai_protocol = IPPROTO_UDP;
190  	error = getaddrinfo(NULL, name, &hints, &res);
191  	if (error != 0) {
192  		if (error != EAI_NONAME &&
193  		    error != EAI_SERVICE) {
194  			return 0;
195  		}
196  	} else {
197  		for (ai = res; ai != NULL; ai = ai->ai_next) {
198  			if (ai->ai_addr != NULL) {
199  				if (ai->ai_addr->sa_family == AF_INET) {
200  					in4 = (struct sockaddr_in *)ai->ai_addr;
201  					udp_port = ntohs(in4->sin_port);
202  					break;
203  				}
204  #ifdef INET6
205  				if (ai->ai_addr->sa_family == AF_INET6) {
206  					in6 = (struct sockaddr_in6 *)ai->ai_addr;
207  					udp_port = ntohs(in6->sin6_port);
208  					break;
209  				}
210  #endif
211  			}
212  		}
213  		freeaddrinfo(res);
214  	}
215  	if (tcp_port >= 0) {
216  		*port = tcp_port;
217  		*proto = IPPROTO_TCP;
218  		if (udp_port >= 0) {
219  			if (udp_port == tcp_port)
220  				*proto = PROTO_UNDEF;
221  #ifdef notdef
222  			else
223  				warning("ambiguous port %s in /etc/services",
224  					name);
225  #endif
226  		}
227  		return 1;
228  	}
229  	if (udp_port >= 0) {
230  		*port = udp_port;
231  		*proto = IPPROTO_UDP;
232  		return 1;
233  	}
234  #if defined(ultrix) || defined(__osf__)
235  	if (strcmp(name, "nfs") == 0) {
236  		*port = 2049;
237  		*proto = PROTO_UNDEF;
238  		return 1;
239  	}
240  #endif
241  	return 0;
242  }
243  int
244  pcap_nametoportrange(const char *name, int *port1, int *port2, int *proto)
245  {
246  	char *off, *cpy;
247  	int save_proto;
248  	if ((cpy = strdup(name)) == NULL)
249  		return 0;
250  	if ((off = strchr(cpy, '-')) == NULL) {
251  		free(cpy);
252  		return 0;
253  	}
254  	*off = '\0';
255  	if (pcap_nametoport(cpy, port1, proto) == 0) {
256  		free(cpy);
257  		return 0;
258  	}
259  	save_proto = *proto;
260  	if (pcap_nametoport(off + 1, port2, proto) == 0) {
261  		free(cpy);
262  		return 0;
263  	}
264  	free(cpy);
265  	if (*proto != save_proto)
266  		*proto = PROTO_UNDEF;
267  	return 1;
268  }
269  int
270  pcap_nametoproto(const char *str)
271  {
272  	struct protoent *p;
273    #if defined(HAVE_LINUX_GETNETBYNAME_R)
274  	struct protoent result_buf;
275  	char buf[1024];	&bsol;* arbitrary size */
276  	int err;
277  	err = getprotobyname_r(str, &result_buf, buf, sizeof buf, &p);
278  	if (err != 0) {
279  		return 0;
280  	}
281    #elif defined(HAVE_SOLARIS_IRIX_GETNETBYNAME_R)
282  	struct protoent result_buf;
283  	char buf[1024];	&bsol;* arbitrary size */
284  	p = getprotobyname_r(str, &result_buf, buf, (int)sizeof buf);
285    #elif defined(HAVE_AIX_GETNETBYNAME_R)
286  	struct protoent result_buf;
287  	struct protoent_data proto_data;
288  	if (getprotobyname_r(str, &result_buf, &proto_data) == -1)
289  		p = NULL;
290  	else
291  		p = &result_buf;
292    #else
293  	p = getprotobyname(str);
294    #endif
295  	if (p != 0)
296  		return p->p_proto;
297  	else
298  		return PROTO_UNDEF;
299  }
300  #include "ethertype.h"
301  struct eproto {
302  	const char *s;
303  	u_short p;
304  };
305  PCAP_API struct eproto eproto_db[];
306  PCAP_API_DEF struct eproto eproto_db[] = {
307  	{ "aarp", ETHERTYPE_AARP },
308  	{ "arp", ETHERTYPE_ARP },
309  	{ "atalk", ETHERTYPE_ATALK },
310  	{ "decnet", ETHERTYPE_DN },
311  	{ "ip", ETHERTYPE_IP },
312  #ifdef INET6
313  	{ "ip6", ETHERTYPE_IPV6 },
314  #endif
315  	{ "lat", ETHERTYPE_LAT },
316  	{ "loopback", ETHERTYPE_LOOPBACK },
317  	{ "mopdl", ETHERTYPE_MOPDL },
318  	{ "moprc", ETHERTYPE_MOPRC },
319  	{ "rarp", ETHERTYPE_REVARP },
320  	{ "sca", ETHERTYPE_SCA },
321  	{ (char *)0, 0 }
322  };
323  int
324  pcap_nametoeproto(const char *s)
325  {
326  	struct eproto *p = eproto_db;
327  	while (p->s != 0) {
328  		if (strcmp(p->s, s) == 0)
329  			return p->p;
330  		p += 1;
331  	}
332  	return PROTO_UNDEF;
333  }
334  #include "llc.h"
335  static struct eproto llc_db[] = {
336  	{ "iso", LLCSAP_ISONS },
337  	{ "stp", LLCSAP_8021D },
338  	{ "ipx", LLCSAP_IPX },
339  	{ "netbeui", LLCSAP_NETBEUI },
340  	{ (char *)0, 0 }
341  };
342  int
343  pcap_nametollc(const char *s)
344  {
345  	struct eproto *p = llc_db;
346  	while (p->s != 0) {
347  		if (strcmp(p->s, s) == 0)
348  			return p->p;
349  		p += 1;
350  	}
351  	return PROTO_UNDEF;
352  }
353  static inline u_char
354  xdtoi(u_char c)
355  {
356  	if (c >= '0' && c <= '9')
357  		return (u_char)(c - '0');
358  	else if (c >= 'a' && c <= 'f')
359  		return (u_char)(c - 'a' + 10);
360  	else
361  		return (u_char)(c - 'A' + 10);
362  }
363  int
364  __pcap_atoin(const char *s, bpf_u_int32 *addr)
365  {
366  	u_int n;
367  	int len;
368  	*addr = 0;
369  	len = 0;
370  	for (;;) {
371  		n = 0;
372  		while (*s && *s != '.') {
373  			if (n > 25) {
374  				return -1;
375  			}
376  			n = n * 10 + *s++ - '0';
377  		}
378  		if (n > 255)
379  			return -1;
380  		*addr <<= 8;
381  		*addr |= n & 0xff;
382  		len += 8;
383  		if (*s == '\0')
384  			return len;
385  		++s;
386  	}
387  }
388  int
389  __pcap_atodn(const char *s, bpf_u_int32 *addr)
390  {
391  #define AREASHIFT 10
392  #define AREAMASK 0176000
393  #define NODEMASK 01777
394  	u_int node = 0, area = 0;
395  	enum {
396  		START,
397  		AREA,
398  		DOT,
399  		NODE,
400  		INVALID
401  	} fsm_state = START;
402  	while (*s) {
403  		switch (fsm_state) {
404  		case START:
405  			if (PCAP_ISDIGIT(*s)) {
406  				area = *s - '0';
407  				fsm_state = AREA;
408  				break;
409  			}
410  			fsm_state = INVALID;
411  			break;
412  		case AREA:
413  			if (*s == '.') {
414  				fsm_state = DOT;
415  				break;
416  			}
417  			if (PCAP_ISDIGIT(*s)) {
418  				area = area * 10 + *s - '0';
419  				if (area <= AREAMASK >> AREASHIFT)
420  					break;
421  			}
422  			fsm_state = INVALID;
423  			break;
424  		case DOT:
425  			if (PCAP_ISDIGIT(*s)) {
426  				node = *s - '0';
427  				fsm_state = NODE;
428  				break;
429  			}
430  			fsm_state = INVALID;
431  			break;
432  		case NODE:
433  			if (PCAP_ISDIGIT(*s)) {
434  				node = node * 10 + *s - '0';
435  				if (node <= NODEMASK)
436  					break;
437  			}
438  			fsm_state = INVALID;
439  			break;
440  		case INVALID:
441  			return 0;
442  		} &bsol;* switch */
443  		s++;
444  	} &bsol;* while */
445  	if (fsm_state != NODE)
446  		return 0;
447  	*addr = area << AREASHIFT | node;
448  	return(32);
449  }
450  u_char *
451  pcap_ether_aton(const char *s)
452  {
453  	register u_char *ep, *e;
454  	register u_char d;
455  	e = ep = (u_char *)malloc(6);
456  	if (e == NULL)
457  		return (NULL);
458  	while (*s) {
459  		if (*s == ':' || *s == '.' || *s == '-')
460  			s += 1;
461  		d = xdtoi(*s++);
462  		if (PCAP_ISXDIGIT(*s)) {
463  			d <<= 4;
464  			d |= xdtoi(*s++);
465  		}
466  		*ep++ = d;
467  	}
468  	return (e);
469  }
470  #ifndef HAVE_ETHER_HOSTTON
471  u_char *
472  pcap_ether_hostton(const char *name)
473  {
474  	register struct pcap_etherent *ep;
475  	register u_char *ap;
476  	static thread_local FILE *fp = NULL;
477  	static thread_local int init = 0;
478  	if (!init) {
479  		fp = fopen(PCAP_ETHERS_FILE, "r");
480  		++init;
481  		if (fp == NULL)
482  			return (NULL);
483  	} else if (fp == NULL)
484  		return (NULL);
485  	else
486  		rewind(fp);
487  	while ((ep = pcap_next_etherent(fp)) != NULL) {
<span onclick='openModal()' class='match'>488  		if (strcmp(ep->name, name) == 0) {
489  			ap = (u_char *)malloc(6);
490  			if (ap != NULL) {
491  				memcpy(ap, ep->addr, 6);
492  				return (ap);
493  			}
</span>494  			break;
495  		}
496  	}
497  	return (NULL);
498  }
499  #else
500  u_char *
501  pcap_ether_hostton(const char *name)
502  {
503  	register u_char *ap;
504  	u_char a[6];
505  	char namebuf[1024];
506  	pcap_strlcpy(namebuf, name, sizeof(namebuf));
507  	ap = NULL;
508  	if (ether_hostton(namebuf, (struct ether_addr *)a) == 0) {
509  		ap = (u_char *)malloc(6);
510  		if (ap != NULL)
511  			memcpy((char *)ap, (char *)a, 6);
512  	}
513  	return (ap);
514  }
515  #endif
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from redis-MDEwOlJlcG9zaXRvcnkxMDgxMTA3MDY=-flat-arena_inlines_b.h</div>
                <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from libpcap-MDEwOlJlcG9zaXRvcnk5NDM1ODg3-flat-nametoaddr.c</div>
                <div class="column column_space"><pre><code>18  	if (unlikely(size >= oversize_threshold)) {
19  		arena_t *tsd_arena = tsd_arena_get(tsd);
20  		if (tsd_arena == NULL || arena_is_auto(tsd_arena)) {
21  			return arena_choose_huge(tsd);
22  		}
</pre></code></div>
                <div class="column column_space"><pre><code>488  		if (strcmp(ep->name, name) == 0) {
489  			ap = (u_char *)malloc(6);
490  			if (ap != NULL) {
491  				memcpy(ap, ep->addr, 6);
492  				return (ap);
493  			}
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    