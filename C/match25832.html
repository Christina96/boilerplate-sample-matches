<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for find_trim.c &amp; operation.c</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for find_trim.c &amp; operation.c
      </h3>
<h1 align="center">
        3.7%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>find_trim.c (11.0236225%)<th>operation.c (2.2913258%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(165-178)<td><a href="#" name="0">(556-569)</a><td align="center"><font color="#ff0000">14</font>
</td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>find_trim.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 #ifdef HAVE_CONFIG_H
2 #include &lt;config.h&gt;
3 #include &lt;vips/intl.h&gt;
4 #include &lt;stdio.h&gt;
5 #include &lt;stdlib.h&gt;
6 #include &lt;math.h&gt;
7 #include &lt;vips/vips.h&gt;
8 typedef struct _VipsFindTrim {
9 	VipsOperation parent_instance;
10 	VipsImage *in;
11 	double threshold;
12 	VipsArrayDouble *background;
13 	int left;
14 	int top;
15 	int width;
16 	int height;
17 } VipsFindTrim;
18 typedef VipsOperationClass VipsFindTrimClass;
19 G_DEFINE_TYPE( VipsFindTrim, vips_find_trim, VIPS_TYPE_OPERATION );
20 static int
21 vips_find_trim_build( VipsObject *object )
22 {
23 	VipsFindTrim *find_trim = (VipsFindTrim *) object;
24 	VipsImage **t = (VipsImage **) vips_object_local_array( object, 20 );
25 	VipsImage *in;
26 	double *background;
27 	int n;
28 	double *neg_bg;
29 	double *ones;
30 	int i;
31 	double left;
32 	double top;
33 	double right;
34 	double bottom;
35 	if( VIPS_OBJECT_CLASS( vips_find_trim_parent_class )-&gt;build( object ) )
36 		return( -1 );
37 	if( !vips_object_argument_isset( object, "background" ) ) 
38 		if( find_trim-&gt;in-&gt;Type == VIPS_INTERPRETATION_GREY16 ||
39 			find_trim-&gt;in-&gt;Type == VIPS_INTERPRETATION_RGB16 ) {
40 			vips_area_unref( VIPS_AREA( find_trim-&gt;background ) );
41 			find_trim-&gt;background = 
42 				vips_array_double_newv( 1, 65535.0 );
43 		}
44 	in = find_trim-&gt;in;
45 	if( vips_image_hasalpha( in ) ) {
46 		if( vips_flatten( in, &amp;t[0], 
47 			"background", find_trim-&gt;background,
48 			NULL ) )
49 			return( -1 ); 
50 		in = t[0];
51 	}
52 	background = vips_array_double_get( find_trim-&gt;background, &amp;n );
53 	if( !(neg_bg = VIPS_ARRAY( find_trim, n, double )) ||
54 		!(ones = VIPS_ARRAY( find_trim, n, double )) )
55 		return( -1 ); 
56 	for( i = 0; i &lt; n; i++ ) {
57 		neg_bg[i] = -1 * background[i];
58 		ones[i] = 1.0;
59 	}
60 	if( vips_median( in, &amp;t[1], 3, NULL ) ||
61 		vips_linear( t[1], &amp;t[2], ones, neg_bg, n, NULL ) ||
62 		vips_abs( t[2], &amp;t[3], NULL ) ||
63 		vips_more_const1( t[3], &amp;t[4], find_trim-&gt;threshold, NULL ) ||
64 		vips_bandor( t[4], &amp;t[5], NULL ) )
65 		return( -1 ); 
66 	in = t[5];
67 	if( vips_project( in, &amp;t[6], &amp;t[7], NULL ) )
68 		return( -1 );
69 	if( vips_profile( t[6], &amp;t[8], &amp;t[9], NULL ) ||
70 		vips_avg( t[9], &amp;left, NULL ) )
71 		return( -1 );
72 	if( vips_flip( t[6], &amp;t[10], VIPS_DIRECTION_HORIZONTAL, NULL ) ||
73 		vips_profile( t[10], &amp;t[11], &amp;t[12], NULL ) ||
74 		vips_avg( t[12], &amp;right, NULL ) )
75 		return( -1 );
76 	if( vips_profile( t[7], &amp;t[13], &amp;t[14], NULL ) ||
77 		vips_avg( t[13], &amp;top, NULL ) )
78 		return( -1 );
79 	if( vips_flip( t[7], &amp;t[15], VIPS_DIRECTION_VERTICAL, NULL ) ||
80 		vips_profile( t[15], &amp;t[16], &amp;t[17], NULL ) ||
81 		vips_avg( t[16], &amp;bottom, NULL ) )
82 		return( -1 );
83 	g_object_set( find_trim,
84 		"left", (int) left,
85 		"top", (int) top,
86 		"width", (int) VIPS_MAX( 0, (t[6]-&gt;Xsize - right) - left ),
87 		"height", (int) VIPS_MAX( 0, (t[7]-&gt;Ysize - bottom) - top ),
88 <a name="0"></a>		NULL ); 
89 	return( 0 );
90 <font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>}
91 static void
92 vips_find_trim_class_init( VipsFindTrimClass *class )
93 {
94 	GObjectClass *gobject_class = (GObjectClass *) class;
95 	VipsObjectClass *object_class = (VipsObjectClass *) class;
96 	gobject_class-&gt;set_property = vips_object_set_property;
97 	gobject_class-&gt;get_property = vips_object_get_property;
98 	object_class-&gt;nickname = "find_trim";
99 	object_class-&gt;description = _( "search an image for non-edge areas" );
100 	object_class-&gt;build = vips_find_trim_build;</b></font>
101 	VIPS_ARG_IMAGE( class, "in", 1,
102 		_( "in" ), 
103 		_( "Image to find_trim" ),
104 		VIPS_ARGUMENT_REQUIRED_INPUT,
105 		G_STRUCT_OFFSET( VipsFindTrim, in ) );
106 	VIPS_ARG_DOUBLE( class, "threshold", 2, 
107 		_( "Threshold" ), 
108 		_( "Object threshold" ),
109 		VIPS_ARGUMENT_OPTIONAL_INPUT,
110 		G_STRUCT_OFFSET( VipsFindTrim, threshold ),
111 		0, INFINITY, 10.0 );
112 	VIPS_ARG_BOXED( class, "background", 3, 
113 		_( "Background" ), 
114 		_( "Color for background pixels" ),
115 		VIPS_ARGUMENT_OPTIONAL_INPUT,
116 		G_STRUCT_OFFSET( VipsFindTrim, background ),
117 		VIPS_TYPE_ARRAY_DOUBLE );
118 	VIPS_ARG_INT( class, "left", 5, 
119 		_( "Left" ), 
120 		_( "Left edge of image" ),
121 		VIPS_ARGUMENT_REQUIRED_OUTPUT,
122 		G_STRUCT_OFFSET( VipsFindTrim, left ),
123 		0, VIPS_MAX_COORD, 1 );
124 	VIPS_ARG_INT( class, "top", 11, 
125 		_( "Top" ), 
126 		_( "Top edge of extract area" ),
127 		VIPS_ARGUMENT_REQUIRED_OUTPUT,
128 		G_STRUCT_OFFSET( VipsFindTrim, top ),
129 		0, VIPS_MAX_COORD, 0 );
130 	VIPS_ARG_INT( class, "width", 12, 
131 		_( "Width" ), 
132 		_( "Width of extract area" ),
133 		VIPS_ARGUMENT_REQUIRED_OUTPUT,
134 		G_STRUCT_OFFSET( VipsFindTrim, width ),
135 		0, VIPS_MAX_COORD, 1 );
136 	VIPS_ARG_INT( class, "height", 13, 
137 		_( "Height" ), 
138 		_( "Height of extract area" ),
139 		VIPS_ARGUMENT_REQUIRED_OUTPUT,
140 		G_STRUCT_OFFSET( VipsFindTrim, height ),
141 		0, VIPS_MAX_COORD, 1 );
142 }
143 static void
144 vips_find_trim_init( VipsFindTrim *find_trim )
145 {
146 	find_trim-&gt;threshold = 10;
147 	find_trim-&gt;background = vips_array_double_newv( 1, 255.0 );
148 }
149 int
150 vips_find_trim( VipsImage *in, 
151 	int *left, int *top, int *width, int *height, ... )
152 {
153 	va_list ap;
154 	int result;
155 	va_start( ap, height );
156 	result = vips_call_split( "find_trim", ap, in, 
157 		left, top, width, height );
158 	va_end( ap );
159 	return( result );
160 }
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>operation.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 #ifdef HAVE_CONFIG_H
2 #include &lt;config.h&gt;
3 #include &lt;vips/intl.h&gt;
4 #include &lt;stdio.h&gt;
5 #include &lt;stdlib.h&gt;
6 #include &lt;string.h&gt;
7 #include &lt;math.h&gt;
8 #include &lt;vips/vips.h&gt;
9 #include &lt;vips/internal.h&gt;
10 #include &lt;vips/debug.h&gt;
11 #include &lt;gobject/gvaluecollector.h&gt;
12 enum {
13 	SIG_INVALIDATE,		
14 	SIG_LAST
15 };
16 static guint vips_operation_signals[SIG_LAST] = { 0 };
17 G_DEFINE_ABSTRACT_TYPE( VipsOperation, vips_operation, VIPS_TYPE_OBJECT );
18 static void
19 vips_operation_finalize( GObject *gobject )
20 {
21 	VipsOperation *operation = VIPS_OPERATION( gobject );
22 	VIPS_DEBUG_MSG( "vips_operation_finalize: %p\n", gobject );
23 	if( operation-&gt;pixels ) 
24 		g_info( _( "%d pixels calculated" ), operation-&gt;pixels ); 
25 	G_OBJECT_CLASS( vips_operation_parent_class )-&gt;finalize( gobject );
26 }
27 static void
28 vips_operation_dispose( GObject *gobject )
29 {
30 	VIPS_DEBUG_MSG( "vips_operation_dispose: %p\n", gobject );
31 	G_OBJECT_CLASS( vips_operation_parent_class )-&gt;dispose( gobject );
32 }
33 typedef enum {
34 	USAGE_INPUTS,
35 	USAGE_NOARG_OUTPUT,
36 	USAGE_OPTIONS,
37 	USAGE_NONE
38 } UsageType; 
39 typedef struct {
40 	char *message;			UsageType type; 		gboolean oftype;		int n;			} VipsOperationClassUsage;
41 static UsageType
42 vips_operation_class_usage_classify( VipsArgumentClass *argument_class )
43 {
44 	if( !(argument_class-&gt;flags &amp; VIPS_ARGUMENT_CONSTRUCT) ||
45 		(argument_class-&gt;flags &amp; VIPS_ARGUMENT_DEPRECATED) ) 
46 		return( USAGE_NONE ); 
47 	if( !(argument_class-&gt;flags &amp; VIPS_ARGUMENT_REQUIRED) )
48 		return( USAGE_OPTIONS ); 
49 	if( vips_argument_class_needsstring( argument_class ) )
50 		return( USAGE_INPUTS ); 
51 	if( (argument_class-&gt;flags &amp; VIPS_ARGUMENT_OUTPUT) &amp;&amp;
52 		!vips_argument_class_needsstring( argument_class ) )
53 		return( USAGE_NOARG_OUTPUT ); 
54 	return( USAGE_NONE ); 
55 }
56 static void
57 vips_operation_pspec_usage( VipsBuf *buf, GParamSpec *pspec )
58 {
59 	GType type = G_PARAM_SPEC_VALUE_TYPE( pspec );
60 	if( G_IS_PARAM_SPEC_ENUM( pspec ) ) {
61 		GTypeClass *class = g_type_class_ref( type );
62 		GParamSpecEnum *pspec_enum = (GParamSpecEnum *) pspec;
63 		GEnumClass *genum;
64 		int i; 
65 		if( !class )
66 			return;
67 		genum = G_ENUM_CLASS( class );
68 		vips_buf_appendf( buf, "\t\t\t" ); 
69 		vips_buf_appendf( buf, "%s", _( "default" ) );
70 		vips_buf_appendf( buf, ": %s\n", 
71 			vips_enum_nick( type, pspec_enum-&gt;default_value ) ); 
72 		vips_buf_appendf( buf, "\t\t\t" ); 
73 		vips_buf_appendf( buf, "%s", _( "allowed" ) );
74 		vips_buf_appendf( buf, ": " ); 
75 		for( i = 0; i &lt; genum-&gt;n_values - 1; i++ ) {
76 			if( i &gt; 0 )
77 				vips_buf_appends( buf, ", " );
78 			vips_buf_appends( buf, genum-&gt;values[i].value_nick );
79 		}
80 		vips_buf_appendf( buf, "\n" ); 
81 	}
82 	else if( G_IS_PARAM_SPEC_BOOLEAN( pspec ) ) {
83 		GParamSpecBoolean *pspec_boolean = (GParamSpecBoolean *) pspec;
84 		vips_buf_appendf( buf, "\t\t\t" ); 
85 		vips_buf_appendf( buf, "%s", _( "default" ) );
86 		vips_buf_appendf( buf, ": %s\n", 
87 			pspec_boolean-&gt;default_value ? "true" : "false" ); 
88 	}
89 	else if( G_IS_PARAM_SPEC_DOUBLE( pspec ) ) {
90 		GParamSpecDouble *pspec_double = (GParamSpecDouble *) pspec;
91 		vips_buf_appendf( buf, "\t\t\t" ); 
92 		vips_buf_appendf( buf, "%s", _( "default" ) );
93 		vips_buf_appendf( buf, ": %g\n", pspec_double-&gt;default_value ); 
94 		vips_buf_appendf( buf, "\t\t\t" ); 
95 		vips_buf_appendf( buf, "%s", _( "min" ) );
96 		vips_buf_appendf( buf, ": %g, ", pspec_double-&gt;minimum ); 
97 		vips_buf_appendf( buf, "%s", _( "max" ) );
98 		vips_buf_appendf( buf, ": %g\n", pspec_double-&gt;maximum ); 
99 	}
100 	else if( G_IS_PARAM_SPEC_INT( pspec ) ) {
101 		GParamSpecInt *pspec_int = (GParamSpecInt *) pspec;
102 		vips_buf_appendf( buf, "\t\t\t" ); 
103 		vips_buf_appendf( buf, "%s", _( "default" ) );
104 		vips_buf_appendf( buf, ": %d\n", pspec_int-&gt;default_value ); 
105 		vips_buf_appendf( buf, "\t\t\t" ); 
106 		vips_buf_appendf( buf, "%s", _( "min" ) );
107 		vips_buf_appendf( buf, ": %d, ", pspec_int-&gt;minimum ); 
108 		vips_buf_appendf( buf, "%s", _( "max" ) );
109 		vips_buf_appendf( buf, ": %d\n", pspec_int-&gt;maximum ); 
110 	}
111 }
112 static void *
113 vips_operation_class_usage_arg( VipsObjectClass *object_class, 
114 	GParamSpec *pspec, VipsArgumentClass *argument_class,
115 	VipsBuf *buf, VipsOperationClassUsage *usage )
116 {
117 	if( usage-&gt;type == 
118 		vips_operation_class_usage_classify( argument_class ) ) { 
119 		if( usage-&gt;message &amp;&amp; 
120 			usage-&gt;n == 0 ) 
121 			vips_buf_appendf( buf, "%s\n", usage-&gt;message );
122 		if( usage-&gt;oftype ) {
123 			vips_buf_appendf( buf, "   %-12s - %s, %s %s\n",
124 				g_param_spec_get_name( pspec ), 
125 				g_param_spec_get_blurb( pspec ), 
126 				(argument_class-&gt;flags &amp; VIPS_ARGUMENT_INPUT) ?
127 					_( "input" ) : _( "output" ),
128 				g_type_name( 
129 					G_PARAM_SPEC_VALUE_TYPE( pspec ) ) );
130 			vips_operation_pspec_usage( buf, pspec );
131 		}
132 		else {
133 				if( usage-&gt;n &gt; 0 )
134 					vips_buf_appends( buf, " " );
135 				vips_buf_appends( buf, 
136 					g_param_spec_get_name( pspec ) );
137 		}
138 		usage-&gt;n += 1;
139 	}
140 	return( NULL );
141 }
142 static void
143 vips_operation_usage( VipsOperationClass *class, VipsBuf *buf )
144 {
145 	VipsObjectClass *object_class = VIPS_OBJECT_CLASS( class );
146 	VipsOperationClassUsage usage;
147 	vips_buf_appendf( buf, "%s\n", object_class-&gt;description );
148 	vips_buf_appendf( buf, "usage:\n" ); 
149 	vips_buf_appendf( buf, "   %s ", object_class-&gt;nickname );
150 	usage.message = NULL;
151 	usage.type = USAGE_INPUTS;
152 	usage.oftype = FALSE;
153 	usage.n = 0;
154 	vips_argument_class_map( object_class,
155 		(VipsArgumentClassMapFn) vips_operation_class_usage_arg, 
156 			buf, &amp;usage );
157 	vips_buf_appends( buf, " [--option-name option-value ...]\n" );
158 	usage.message = "where:";
159 	usage.type = USAGE_INPUTS;
160 	usage.oftype = TRUE;
161 	usage.n = 0;
162 	vips_argument_class_map( object_class,
163 		(VipsArgumentClassMapFn) vips_operation_class_usage_arg, 
164 			buf, &amp;usage );
165 	usage.message = "outputs:";
166 	usage.type = USAGE_NOARG_OUTPUT;
167 	usage.oftype = TRUE;
168 	usage.n = 0;
169 	vips_argument_class_map( object_class,
170 		(VipsArgumentClassMapFn) vips_operation_class_usage_arg, 
171 			buf, &amp;usage );
172 	usage.message = "optional arguments:";
173 	usage.type = USAGE_OPTIONS;
174 	usage.oftype = TRUE;
175 	usage.n = 0;
176 	vips_argument_class_map( object_class,
177 		(VipsArgumentClassMapFn) vips_operation_class_usage_arg, 
178 			buf, &amp;usage );
179 	if( class-&gt;flags ) {
180 		GFlagsValue *value;
181 		VipsOperationFlags flags;
182 		GFlagsClass *flags_class = 
183 			g_type_class_ref( VIPS_TYPE_OPERATION_FLAGS );
184 		vips_buf_appendf( buf, "operation flags: " );
185 		flags = class-&gt;flags; 
186 		while( flags &amp;&amp; (value = 
187 			g_flags_get_first_value( flags_class, flags )) ) {
188 			vips_buf_appendf( buf, "%s ", value-&gt;value_nick );
189 			flags &amp;= ~value-&gt;value;
190 		}
191 		vips_buf_appends( buf, "\n" );
192 	}
193 }
194 static void *
195 vips_operation_call_argument( VipsObject *object, GParamSpec *pspec,
196 	VipsArgumentClass *argument_class,
197 	VipsArgumentInstance *argument_instance,
198 	void *a, void *b )
199 {
200 	VipsArgument *argument = (VipsArgument *) argument_class;
201 	printf( "   %s: offset = %d ", 
202 		g_param_spec_get_name( argument-&gt;pspec ),
203 		argument_class-&gt;offset );
204 	if( argument_class-&gt;flags &amp; VIPS_ARGUMENT_REQUIRED )
205 		printf ("required " );
206 	if( argument_class-&gt;flags &amp; VIPS_ARGUMENT_CONSTRUCT )
207 		printf ("construct " );
208 	if( argument_class-&gt;flags &amp; VIPS_ARGUMENT_SET_ONCE )
209 		printf ("set-once " );
210 	if( argument_instance-&gt;assigned )
211 		printf ("assigned " );
212 	printf( "\n" );
213 	return( NULL );
214 }
215 static void
216 vips_operation_dump( VipsObject *object, VipsBuf *buf )
217 {
218 	VipsOperation *operation = VIPS_OPERATION( object );
219 	VipsObjectClass *object_class = VIPS_OBJECT_GET_CLASS( object );
220 	if( operation-&gt;found_hash )
221 		printf( "hash = %x\n", operation-&gt;hash ); 
222 	printf( "%s args:\n", object_class-&gt;nickname );
223 	vips_argument_map( VIPS_OBJECT( operation ),
224 		vips_operation_call_argument, NULL, NULL );
225 	VIPS_OBJECT_CLASS( vips_operation_parent_class )-&gt;dump( object, buf );
226 }
227 static void *
228 vips_operation_vips_operation_print_summary_arg( VipsObject *object, 
229 	GParamSpec *pspec,
230 	VipsArgumentClass *argument_class,
231 	VipsArgumentInstance *argument_instance,
232 	void *a, void *b )
233 {
234 	VipsBuf *buf = (VipsBuf *) a;
235 	if( ((argument_class-&gt;flags &amp; VIPS_ARGUMENT_INPUT) ||
236 		 (argument_class-&gt;flags &amp; VIPS_ARGUMENT_OUTPUT)) &amp;&amp;
237 		(argument_class-&gt;flags &amp; VIPS_ARGUMENT_CONSTRUCT) &amp;&amp;
238 		argument_instance-&gt;assigned ) {
239 		const char *name = g_param_spec_get_name( pspec );
240 		GType type = G_PARAM_SPEC_VALUE_TYPE( pspec );
241 		GValue gvalue = { 0, };
242 		char *str;
243 		g_value_init( &amp;gvalue, type );
244 		g_object_get_property( G_OBJECT( object ), name, &amp;gvalue ); 
245 		str = g_strdup_value_contents( &amp;gvalue );
246 		vips_buf_appendf( buf, " %s=%s", name, str );
247 		g_free( str );
248 		g_value_unset( &amp;gvalue ); 
249 	}
250 	return( NULL );
251 }
252 static void
253 vips_operation_summary( VipsObject *object, VipsBuf *buf )
254 {
255 	VipsOperation *operation = VIPS_OPERATION( object );
256 	VipsObjectClass *object_class = VIPS_OBJECT_GET_CLASS( object );
257 	vips_buf_appendf( buf, "%s", object_class-&gt;nickname ); 
258 	vips_argument_map( VIPS_OBJECT( operation ),
259 		vips_operation_vips_operation_print_summary_arg, buf, NULL );
260 	vips_buf_appends( buf, " -" );
261 	VIPS_OBJECT_CLASS( vips_operation_parent_class )-&gt;
262 		summary( object, buf );
263 }
264 static VipsOperationFlags
265 vips_operation_real_get_flags( VipsOperation *operation ) 
266 {
267 <a name="0"></a>	VipsOperationClass *class = VIPS_OPERATION_GET_CLASS( operation );
268 	return( class-&gt;flags );
269 <font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>}
270 static void
271 vips_operation_class_init( VipsOperationClass *class )
272 {
273 	GObjectClass *gobject_class = G_OBJECT_CLASS( class );
274 	VipsObjectClass *vobject_class = VIPS_OBJECT_CLASS( class );
275 	gobject_class-&gt;finalize = vips_operation_finalize;
276 	gobject_class-&gt;dispose = vips_operation_dispose;
277 	vobject_class-&gt;nickname = "operation";
278 	vobject_class-&gt;description = _( "operations" );
279 	vobject_class-&gt;summary = vips_operation_summary;</b></font>
280 	vobject_class-&gt;dump = vips_operation_dump;
281 	class-&gt;usage = vips_operation_usage;
282 	class-&gt;get_flags = vips_operation_real_get_flags;
283 	vips_operation_signals[SIG_INVALIDATE] = g_signal_new( "invalidate",
284 		G_TYPE_FROM_CLASS( class ),
285 		G_SIGNAL_RUN_LAST,
286 		G_STRUCT_OFFSET( VipsOperationClass, invalidate ), 
287 		NULL, NULL,
288 		g_cclosure_marshal_VOID__VOID,
289 		G_TYPE_NONE, 0 );
290 }
291 static void
292 vips_operation_init( VipsOperation *operation )
293 {
294 }
295 VipsOperationFlags
296 vips_operation_get_flags( VipsOperation *operation ) 
297 {
298 	VipsOperationClass *class = VIPS_OPERATION_GET_CLASS( operation );
299 	return( class-&gt;get_flags( operation ) );
300 }
301 void
302 vips_operation_class_print_usage( VipsOperationClass *operation_class )
303 {
304 	char str[4096];
305 	VipsBuf buf = VIPS_BUF_STATIC( str );
306 	operation_class-&gt;usage( operation_class, &amp;buf );
307 	printf( "%s", vips_buf_all( &amp;buf ) );
308 }
309 void
310 vips_operation_invalidate( VipsOperation *operation )
311 {
312 #ifdef VIPS_DEBUG
313 	printf( "vips_operation_invalidate: %p\n", operation ); 
314 	vips_object_print_summary( VIPS_OBJECT( operation ) ); 
315 	g_signal_emit( operation, vips_operation_signals[SIG_INVALIDATE], 0 );
316 }
317 VipsOperation *
318 vips_operation_new( const char *name )
319 {
320 	GType type;
321 	VipsObject *object;
322 	VipsOperation *operation;
323 	vips_check_init();
324 	if( !(type = vips_type_find( "VipsOperation", name )) ) {
325 		vips_error( "VipsOperation", 
326 			_( "class \"%s\" not found" ), name );
327 		return( NULL );
328 	}
329 	if( !(object = g_object_new( type, NULL )) ) {
330 		vips_error( "VipsOperation", 
331 			_( "\"%s\" is not an instantiable class" ), name );
332 		return( NULL );
333 	}
334 	operation = VIPS_OPERATION( object );
335 	VIPS_DEBUG_MSG( "vips_operation_new: %s (%p)\n", name, operation );
336 	return( operation );
337 }
338 #ifndef va_copy
339 #define va_copy(d,s) ((d) = (s))
340 #endif
341 static int
342 vips_operation_set_valist_required( VipsOperation *operation, va_list ap )
343 {
344 	VIPS_DEBUG_MSG( "vips_operation_set_valist_required:\n" );
345 	VIPS_ARGUMENT_FOR_ALL( operation, 
346 		pspec, argument_class, argument_instance ) {
347 		g_assert( argument_instance );
348 		if( (argument_class-&gt;flags &amp; VIPS_ARGUMENT_REQUIRED) &amp;&amp;
349 			!(argument_class-&gt;flags &amp; VIPS_ARGUMENT_DEPRECATED) ) {
350 			VIPS_ARGUMENT_COLLECT_SET( pspec, argument_class, ap );
351 #ifdef VIPS_DEBUG
352 			{
353 				char *str;
354 				str = g_strdup_value_contents( &amp;value );
355 				VIPS_DEBUG_MSG( "\t%s = %s\n", 
356 					g_param_spec_get_name( pspec ), str );
357 				g_free( str );
358 			}
359 			g_object_set_property( G_OBJECT( operation ),
360 				g_param_spec_get_name( pspec ), &amp;value );
361 			VIPS_ARGUMENT_COLLECT_GET( pspec, argument_class, ap );
362 #ifdef VIPS_DEBUG
363 			printf( "\tskipping arg %p for %s\n", 
364 				arg, g_param_spec_get_name( pspec ) );
365 			VIPS_ARGUMENT_COLLECT_END
366 		}
367 	} VIPS_ARGUMENT_FOR_ALL_END
368 	return( 0 );
369 }
370 static int
371 vips_operation_get_valist_required( VipsOperation *operation, va_list ap )
372 {
373 	VIPS_DEBUG_MSG( "vips_operation_get_valist_required:\n" );
374 	VIPS_ARGUMENT_FOR_ALL( operation, 
375 		pspec, argument_class, argument_instance ) {
376 		if( (argument_class-&gt;flags &amp; VIPS_ARGUMENT_REQUIRED) ) {
377 			VIPS_ARGUMENT_COLLECT_SET( pspec, argument_class, ap );
378 			VIPS_ARGUMENT_COLLECT_GET( pspec, argument_class, ap );
379 			if( !argument_instance-&gt;assigned ) 
380 				continue;
381 #ifdef VIPS_DEBUG
382 			printf( "\twriting %s to %p\n", 
383 				g_param_spec_get_name( pspec ), arg );
384 			g_object_get( G_OBJECT( operation ), 
385 				g_param_spec_get_name( pspec ), arg, NULL );
386 			if( G_IS_PARAM_SPEC_OBJECT( pspec ) ) {
387 				GObject *object;
388 				object = *((GObject **) arg);
389 				g_object_unref( object ); 
390 			}
391 			VIPS_ARGUMENT_COLLECT_END
392 		}
393 	} VIPS_ARGUMENT_FOR_ALL_END
394 	return( 0 );
395 }
396 static int
397 vips_operation_get_valist_optional( VipsOperation *operation, va_list ap )
398 {
399 	char *name;
400 	VIPS_DEBUG_MSG( "vips_operation_get_valist_optional:\n" );
401 	for( name = va_arg( ap, char * ); name; name = va_arg( ap, char * ) ) { 
402 		GParamSpec *pspec;
403 		VipsArgumentClass *argument_class;
404 		VipsArgumentInstance *argument_instance;
405 		VIPS_DEBUG_MSG( "\tname = '%s' (%p)\n", name, name );
406 		if( vips_object_get_argument( VIPS_OBJECT( operation ), name,
407 			&amp;pspec, &amp;argument_class, &amp;argument_instance ) )
408 			return( -1 );
409 		VIPS_ARGUMENT_COLLECT_SET( pspec, argument_class, ap );
410 		VIPS_ARGUMENT_COLLECT_GET( pspec, argument_class, ap );
411 #ifdef VIPS_DEBUG
412 		printf( "\twriting %s to %p\n", 
413 			g_param_spec_get_name( pspec ), arg );
414 		if( arg ) {
415 			g_object_get( G_OBJECT( operation ), 
416 				g_param_spec_get_name( pspec ), arg, 
417 				NULL );
418 			if( G_IS_PARAM_SPEC_OBJECT( pspec ) ) {
419 				GObject *object;
420 				object = *((GObject **) arg);
421 				g_object_unref( object ); 
422 			}
423 		}
424 		VIPS_ARGUMENT_COLLECT_END
425 	}
426 	return( 0 );
427 }
428 int
429 vips_call_required_optional( VipsOperation **operation,
430 	va_list required, va_list optional ) 
431 {
432 	int result;
433 	va_list a;
434 	va_list b;
435 	va_copy( a, required );
436 	va_copy( b, optional );
437 	result = vips_operation_set_valist_required( *operation, a ) ||
438 		vips_object_set_valist( VIPS_OBJECT( *operation ), b );
439 	va_end( a );
440 	va_end( b );
441 	if( result )
442 		return( -1 );
443 	if( vips_cache_operation_buildp( operation ) )
444 		return( -1 );
445 	va_copy( a, required );
446 	va_copy( b, optional );
447 	result = vips_operation_get_valist_required( *operation, required ) ||
448 		vips_operation_get_valist_optional( *operation, optional );
449 	va_end( a );
450 	va_end( b );
451 	return( result );
452 }
453 static int
454 vips_call_by_name( const char *operation_name, 
455 	const char *option_string, va_list required, va_list optional )
456 {
457 	VipsOperation *operation;
458 	int result;
459 	VIPS_DEBUG_MSG( "vips_call_by_name: starting for %s ...\n", 
460 		operation_name );
461 	if( !(operation = vips_operation_new( operation_name )) )
462 		return( -1 );
463 	if( option_string &amp;&amp;
464 		vips_object_set_from_string( VIPS_OBJECT( operation ), 
465 			option_string ) ) {
466 		vips_object_unref_outputs( VIPS_OBJECT( operation ) );
467 		g_object_unref( operation ); 
468 		return( -1 ); 
469 	}
470 	result = vips_call_required_optional( &amp;operation, required, optional );
471 	if( result ) {
472 		vips_object_unref_outputs( VIPS_OBJECT( operation ) );
473 		g_object_unref( operation );
474 		return( -1 );
475 	}
476 	g_object_unref( operation );
477 	return( result );
478 }
479 int
480 vips_call( const char *operation_name, ... )
481 {
482 	VipsOperation *operation;
483 	int result;
484 	va_list required;
485 	va_list optional;
486 	if( !(operation = vips_operation_new( operation_name )) )
487 		return( -1 );
488 	va_start( required, operation_name );
489 	va_copy( optional, required );
490 	VIPS_ARGUMENT_FOR_ALL( operation, 
491 		pspec, argument_class, argument_instance ) {
492 		g_assert( argument_instance );
493 		if( (argument_class-&gt;flags &amp; VIPS_ARGUMENT_REQUIRED) ) {
494 			VIPS_ARGUMENT_COLLECT_SET( pspec, argument_class, 
495 				optional );
496 			VIPS_ARGUMENT_COLLECT_GET( pspec, argument_class, 
497 				optional );
498 			VIPS_ARGUMENT_COLLECT_END
499 		}
500 	} VIPS_ARGUMENT_FOR_ALL_END
501 	g_object_unref( operation ); 
502 	result = vips_call_by_name( operation_name, NULL, required, optional ); 
503 	va_end( required );
504 	va_end( optional );
505 	return( result );
506 }
507 int
508 vips_call_split( const char *operation_name, va_list optional, ... ) 
509 {
510 	int result;
511 	va_list required;
512 	va_start( required, optional );
513 	result = vips_call_by_name( operation_name, NULL, 
514 		required, optional );
515 	va_end( required );
516 	return( result );
517 }
518 int
519 vips_call_split_option_string( const char *operation_name, 
520 	const char *option_string, va_list optional, ... ) 
521 {
522 	int result;
523 	va_list required;
524 	va_start( required, optional );
525 	result = vips_call_by_name( operation_name, option_string, 
526 		required, optional );
527 	va_end( required );
528 	return( result );
529 }
530 static void *
531 vips_call_find_pspec( VipsObject *object,
532 	GParamSpec *pspec,
533 	VipsArgumentClass *argument_class,
534 	VipsArgumentInstance *argument_instance,
535 	void *a, void *b )
536 {
537 	const char *name = (const char *) a;
538 	if( !(argument_class-&gt;flags &amp; VIPS_ARGUMENT_REQUIRED) &amp;&amp;
539 		(argument_class-&gt;flags &amp; VIPS_ARGUMENT_CONSTRUCT) &amp;&amp;
540 		!argument_instance-&gt;assigned ) 
541 		if( (strlen( name ) == 1 &amp;&amp; 
542 			g_param_spec_get_name( pspec )[0] == name[0]) ||
543 			strcmp( g_param_spec_get_name( pspec ), name  ) == 0 ) 
544 			return( argument_instance );
545 	return( NULL );
546 }
547 typedef struct _VipsCallOptionOutput {
548 	VipsArgumentInstance *argument_instance;
549 	char *value;
550 } VipsCallOptionOutput;
551 static int
552 vips_call_option_output( VipsObject *object,
553 	VipsCallOptionOutput *output )
554 {
555 	VipsArgumentInstance *argument_instance = output-&gt;argument_instance;
556 	GParamSpec *pspec = ((VipsArgument *) argument_instance)-&gt;pspec;
557 	int result;
558 	result = 0;
559 	if( object-&gt;constructed )
560 		result = vips_object_get_argument_to_string( object, 
561 			g_param_spec_get_name( pspec ), output-&gt;value );
562 	return( result ); 
563 }
564 static void
565 vips_call_option_output_free( VipsObject *object, VipsCallOptionOutput *output )
566 {
567 	VIPS_FREE( output-&gt;value ); 
568 	g_free( output );
569 }
570 static gboolean
571 vips_call_options_set( const gchar *option_name, const gchar *value, 
572 	gpointer data, GError **error )
573 {
574 	VipsOperation *operation = (VipsOperation *) data;
575 	const char *name;
576 	VipsArgumentInstance *argument_instance;
577 	VipsArgumentClass *argument_class;
578 	GParamSpec *pspec;
579 	VIPS_DEBUG_MSG( "vips_call_options_set: %s = %s\n", 
580 		option_name, value );
581 	for( name = option_name; *name == '-'; name++ )
582 		;
583 	if( !(argument_instance = (VipsArgumentInstance *) 
584 		vips_argument_map( 
585 			VIPS_OBJECT( operation ),
586 			vips_call_find_pspec, (void *) name, NULL )) ) {
587 		vips_error( VIPS_OBJECT_GET_CLASS( operation )-&gt;nickname, 
588 			_( "unknown argument '%s'" ), name );
589 		vips_error_g( error );
590 		return( FALSE );
591 	}
592 	argument_class = argument_instance-&gt;argument_class;
593 	pspec = ((VipsArgument *) argument_instance)-&gt;pspec;
594 	if( (argument_class-&gt;flags &amp; VIPS_ARGUMENT_INPUT) ) {
595 		if( vips_object_set_argument_from_string( 
596 			VIPS_OBJECT( operation ),
597 			g_param_spec_get_name( pspec ), value ) ) {
598 			vips_error_g( error );
599 			return( FALSE );
600 		}
601 #ifdef VIPS_DEBUG
602 {
603 		GType type = G_PARAM_SPEC_VALUE_TYPE( pspec );
604 		GValue gvalue = { 0, };
605 		char *str;
606 		g_value_init( &amp;gvalue, type );
607 		g_object_get_property( G_OBJECT( operation ), 
608 			g_param_spec_get_name( pspec ), &amp;gvalue ); 
609 		str = g_strdup_value_contents( &amp;gvalue );
610 		VIPS_DEBUG_MSG( "\tGValue %s = %s\n", 
611 			g_param_spec_get_name( pspec ), str );
612 		g_free( str );
613 		g_value_unset( &amp;gvalue ); 
614 }
615 	}
616 	else if( (argument_class-&gt;flags &amp; VIPS_ARGUMENT_OUTPUT) ) {
617 		VipsCallOptionOutput *output;
618 		output = g_new( VipsCallOptionOutput, 1 );
619 		output-&gt;argument_instance = argument_instance;
620 		output-&gt;value = g_strdup( value );
621 		g_signal_connect( operation, "postbuild",
622 			G_CALLBACK( vips_call_option_output ),
623 			output );
624 		g_signal_connect( operation, "close",
625 			G_CALLBACK( vips_call_option_output_free ),
626 			output );
627 	}
628 	return( TRUE );
629 }
630 static void *
631 vips_call_options_add( VipsObject *object,
632 	GParamSpec *pspec,
633 	VipsArgumentClass *argument_class,
634 	VipsArgumentInstance *argument_instance,
635 	void *a, void *b )
636 {
637 	GOptionGroup *group = (GOptionGroup *) a;
638 	if( !(argument_class-&gt;flags &amp; VIPS_ARGUMENT_REQUIRED) &amp;&amp;
639 		(argument_class-&gt;flags &amp; VIPS_ARGUMENT_CONSTRUCT) &amp;&amp;
640 		!argument_instance-&gt;assigned ) {
641 		const char *name = g_param_spec_get_name( pspec );
642 		gboolean needs_string = 
643 			vips_object_argument_needsstring( object, name );
644 		GOptionEntry entry[2];
645 		entry[0].long_name = name;
646 		entry[0].description = g_param_spec_get_blurb( pspec );
647 		if( argument_class-&gt;flags &amp; VIPS_ARGUMENT_DEPRECATED ) 
648 			entry[0].short_name = '\0';
649 		else
650 			entry[0].short_name = name[0];
651 		entry[0].flags = 0;
652 		if( !needs_string ) 
653 			entry[0].flags |= G_OPTION_FLAG_NO_ARG;
654 		if( argument_class-&gt;flags &amp; VIPS_ARGUMENT_DEPRECATED ) 
655 			entry[0].flags |= G_OPTION_FLAG_HIDDEN;
656 		entry[0].arg = G_OPTION_ARG_CALLBACK;
657 		entry[0].arg_data = (gpointer) vips_call_options_set;
658 		if( needs_string ) 
659 			entry[0].arg_description = 
660 				g_type_name( G_PARAM_SPEC_VALUE_TYPE( pspec ) );
661 		else
662 			entry[0].arg_description = NULL;
663 		entry[1].long_name = NULL;
664 		VIPS_DEBUG_MSG( "vips_call_options_add: adding %s\n", name );
665 		g_option_group_add_entries( group, &amp;entry[0] );
666 	}
667 	return( NULL );
668 }
669 void
670 vips_call_options( GOptionGroup *group, VipsOperation *operation )
671 {
672 	(void) vips_argument_map( VIPS_OBJECT( operation ),
673 		vips_call_options_add, group, NULL );
674 }
675 typedef struct _VipsCall {
676 	VipsOperation *operation;
677 	int argc;
678 	char **argv;
679 	int i;
680 } VipsCall;
681 static const char *
682 vips_call_get_arg( VipsCall *call, int i )
683 {
684 	if( i &lt; 0 || 
685 		i &gt;= call-&gt;argc ) {
686 		vips_error( VIPS_OBJECT_GET_CLASS( call-&gt;operation )-&gt;nickname, 
687 			"%s", _( "too few arguments" ) );
688 		return( NULL );
689 	}
690 	return( call-&gt;argv[i] );
691 }
692 static void *
693 vips_call_argv_input( VipsObject *object,
694 	GParamSpec *pspec,
695 	VipsArgumentClass *argument_class,
696 	VipsArgumentInstance *argument_instance,
697 	void *a, void *b )
698 {
699 	VipsCall *call = (VipsCall *) a;
700 	if( (argument_class-&gt;flags &amp; VIPS_ARGUMENT_REQUIRED) &amp;&amp;
701 		(argument_class-&gt;flags &amp; VIPS_ARGUMENT_CONSTRUCT) &amp;&amp;
702 		!(argument_class-&gt;flags &amp; VIPS_ARGUMENT_DEPRECATED) ) { 
703 		const char *name = g_param_spec_get_name( pspec );
704 		if( (argument_class-&gt;flags &amp; VIPS_ARGUMENT_INPUT) ) {
705 			const char *arg;
706 			if( !(arg = vips_call_get_arg( call, call-&gt;i )) ||
707 				vips_object_set_argument_from_string( object, 
708 					name, arg ) ) 
709 				return( pspec );
710 			call-&gt;i += 1;
711 		}
712 		else if( (argument_class-&gt;flags &amp; VIPS_ARGUMENT_OUTPUT) ) {
713 			if( vips_object_argument_needsstring( object, name ) )
714 				call-&gt;i += 1;
715 		}
716 	}
717 	return( NULL );
718 }
719 static void *
720 vips_call_argv_output( VipsObject *object,
721 	GParamSpec *pspec,
722 	VipsArgumentClass *argument_class,
723 	VipsArgumentInstance *argument_instance,
724 	void *a, void *b )
725 {
726 	VipsCall *call = (VipsCall *) a;
727 	if( (argument_class-&gt;flags &amp; VIPS_ARGUMENT_REQUIRED) &amp;&amp;
728 		(argument_class-&gt;flags &amp; VIPS_ARGUMENT_CONSTRUCT) &amp;&amp;
729 		!(argument_class-&gt;flags &amp; VIPS_ARGUMENT_DEPRECATED) ) { 
730 		if( (argument_class-&gt;flags &amp; VIPS_ARGUMENT_INPUT) ) 
731 			call-&gt;i += 1;
732 		else if( (argument_class-&gt;flags &amp; VIPS_ARGUMENT_OUTPUT) ) {
733 			const char *name = g_param_spec_get_name( pspec );
734 			const char *arg;
735 			arg = NULL;
736 			if( vips_object_argument_needsstring( object, name ) ) {
737 				arg = vips_call_get_arg( call, call-&gt;i );
738 				if( !arg )
739 					return( pspec );
740 				call-&gt;i += 1;
741 			}
742 			if( vips_object_get_argument_to_string( object, 
743 				name, arg ) ) 
744 				return( pspec );
745 		}
746 	}
747 	return( NULL );
748 }
749 int
750 vips_call_argv( VipsOperation *operation, int argc, char **argv )
751 {
752 	VipsCall call;
753 	g_assert( argc &gt;= 0 );
754 #ifdef VIPS_DEBUG
755 	printf( "vips_call_argv: " );
756 	vips_object_print_name( VIPS_OBJECT( operation ) );
757 	printf( "\n" );
758 {
759 	int i;
760 	for( i = 0; i &lt; argc; i++ )
761 		printf( "%d) %s\n", i, argv[i] );
762 }
763 	call.operation = operation;
764 	call.argc = argc;
765 	call.argv = argv;
766 	call.i = 0;
767 	if( vips_argument_map( VIPS_OBJECT( operation ),
768 		vips_call_argv_input, &amp;call, NULL ) ) 
769 		return( -1 );
770 	if( argc &gt; call.i ) {
771 		vips_error( VIPS_OBJECT_GET_CLASS( operation )-&gt;nickname, 
772 			"%s", _( "too many arguments" ) );
773 		return( -1 );
774 	}
775 	if( vips_object_build( VIPS_OBJECT( operation ) ) ) 
776 		return( -1 );
777 	if( vips__cache_trace ) {
778 		printf( "vips cache : " );
779 		vips_object_print_summary( VIPS_OBJECT( operation ) );
780 	}
781 	call.i = 0;
782 	if( vips_argument_map( VIPS_OBJECT( operation ),
783 		vips_call_argv_output, &amp;call, NULL ) ) 
784 		return( -1 );
785 	return( 0 );
786 }
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
