<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for find_trim.c &amp; operation.c</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for find_trim.c &amp; operation.c
      </h3>
<h1 align="center">
        3.7%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>find_trim.c (11.0236225%)<th>operation.c (2.2913258%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(165-178)<td><a href="#" name="0">(556-569)</a><td align="center"><font color="#ff0000">14</font>
</td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>find_trim.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
#ifdef HAVE_CONFIG_H
#include &lt;config.h&gt;
#include &lt;vips/intl.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;math.h&gt;
#include &lt;vips/vips.h&gt;
typedef struct _VipsFindTrim {
	VipsOperation parent_instance;
	VipsImage *in;
	double threshold;
	VipsArrayDouble *background;
	int left;
	int top;
	int width;
	int height;
} VipsFindTrim;
typedef VipsOperationClass VipsFindTrimClass;
G_DEFINE_TYPE( VipsFindTrim, vips_find_trim, VIPS_TYPE_OPERATION );
static int
vips_find_trim_build( VipsObject *object )
{
	VipsFindTrim *find_trim = (VipsFindTrim *) object;
	VipsImage **t = (VipsImage **) vips_object_local_array( object, 20 );
	VipsImage *in;
	double *background;
	int n;
	double *neg_bg;
	double *ones;
	int i;
	double left;
	double top;
	double right;
	double bottom;
	if( VIPS_OBJECT_CLASS( vips_find_trim_parent_class )-&gt;build( object ) )
		return( -1 );
	if( !vips_object_argument_isset( object, "background" ) ) 
		if( find_trim-&gt;in-&gt;Type == VIPS_INTERPRETATION_GREY16 ||
			find_trim-&gt;in-&gt;Type == VIPS_INTERPRETATION_RGB16 ) {
			vips_area_unref( VIPS_AREA( find_trim-&gt;background ) );
			find_trim-&gt;background = 
				vips_array_double_newv( 1, 65535.0 );
		}
	in = find_trim-&gt;in;
	if( vips_image_hasalpha( in ) ) {
		if( vips_flatten( in, &amp;t[0], 
			"background", find_trim-&gt;background,
			NULL ) )
			return( -1 ); 
		in = t[0];
	}
	background = vips_array_double_get( find_trim-&gt;background, &amp;n );
	if( !(neg_bg = VIPS_ARRAY( find_trim, n, double )) ||
		!(ones = VIPS_ARRAY( find_trim, n, double )) )
		return( -1 ); 
	for( i = 0; i &lt; n; i++ ) {
		neg_bg[i] = -1 * background[i];
		ones[i] = 1.0;
	}
	if( vips_median( in, &amp;t[1], 3, NULL ) ||
		vips_linear( t[1], &amp;t[2], ones, neg_bg, n, NULL ) ||
		vips_abs( t[2], &amp;t[3], NULL ) ||
		vips_more_const1( t[3], &amp;t[4], find_trim-&gt;threshold, NULL ) ||
		vips_bandor( t[4], &amp;t[5], NULL ) )
		return( -1 ); 
	in = t[5];
	if( vips_project( in, &amp;t[6], &amp;t[7], NULL ) )
		return( -1 );
	if( vips_profile( t[6], &amp;t[8], &amp;t[9], NULL ) ||
		vips_avg( t[9], &amp;left, NULL ) )
		return( -1 );
	if( vips_flip( t[6], &amp;t[10], VIPS_DIRECTION_HORIZONTAL, NULL ) ||
		vips_profile( t[10], &amp;t[11], &amp;t[12], NULL ) ||
		vips_avg( t[12], &amp;right, NULL ) )
		return( -1 );
	if( vips_profile( t[7], &amp;t[13], &amp;t[14], NULL ) ||
		vips_avg( t[13], &amp;top, NULL ) )
		return( -1 );
	if( vips_flip( t[7], &amp;t[15], VIPS_DIRECTION_VERTICAL, NULL ) ||
		vips_profile( t[15], &amp;t[16], &amp;t[17], NULL ) ||
		vips_avg( t[16], &amp;bottom, NULL ) )
		return( -1 );
	g_object_set( find_trim,
		"left", (int) left,
		"top", (int) top,
		"width", (int) VIPS_MAX( 0, (t[6]-&gt;Xsize - right) - left ),
		"height", (int) VIPS_MAX( 0, (t[7]-&gt;Ysize - bottom) - top ),
<a name="0"></a>		NULL ); 
	return( 0 );
<font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>}
static void
vips_find_trim_class_init( VipsFindTrimClass *class )
{
	GObjectClass *gobject_class = (GObjectClass *) class;
	VipsObjectClass *object_class = (VipsObjectClass *) class;
	gobject_class-&gt;set_property = vips_object_set_property;
	gobject_class-&gt;get_property = vips_object_get_property;
	object_class-&gt;nickname = "find_trim";
	object_class-&gt;description = _( "search an image for non-edge areas" );
	object_class-&gt;build = vips_find_trim_build;</b></font>
	VIPS_ARG_IMAGE( class, "in", 1,
		_( "in" ), 
		_( "Image to find_trim" ),
		VIPS_ARGUMENT_REQUIRED_INPUT,
		G_STRUCT_OFFSET( VipsFindTrim, in ) );
	VIPS_ARG_DOUBLE( class, "threshold", 2, 
		_( "Threshold" ), 
		_( "Object threshold" ),
		VIPS_ARGUMENT_OPTIONAL_INPUT,
		G_STRUCT_OFFSET( VipsFindTrim, threshold ),
		0, INFINITY, 10.0 );
	VIPS_ARG_BOXED( class, "background", 3, 
		_( "Background" ), 
		_( "Color for background pixels" ),
		VIPS_ARGUMENT_OPTIONAL_INPUT,
		G_STRUCT_OFFSET( VipsFindTrim, background ),
		VIPS_TYPE_ARRAY_DOUBLE );
	VIPS_ARG_INT( class, "left", 5, 
		_( "Left" ), 
		_( "Left edge of image" ),
		VIPS_ARGUMENT_REQUIRED_OUTPUT,
		G_STRUCT_OFFSET( VipsFindTrim, left ),
		0, VIPS_MAX_COORD, 1 );
	VIPS_ARG_INT( class, "top", 11, 
		_( "Top" ), 
		_( "Top edge of extract area" ),
		VIPS_ARGUMENT_REQUIRED_OUTPUT,
		G_STRUCT_OFFSET( VipsFindTrim, top ),
		0, VIPS_MAX_COORD, 0 );
	VIPS_ARG_INT( class, "width", 12, 
		_( "Width" ), 
		_( "Width of extract area" ),
		VIPS_ARGUMENT_REQUIRED_OUTPUT,
		G_STRUCT_OFFSET( VipsFindTrim, width ),
		0, VIPS_MAX_COORD, 1 );
	VIPS_ARG_INT( class, "height", 13, 
		_( "Height" ), 
		_( "Height of extract area" ),
		VIPS_ARGUMENT_REQUIRED_OUTPUT,
		G_STRUCT_OFFSET( VipsFindTrim, height ),
		0, VIPS_MAX_COORD, 1 );
}
static void
vips_find_trim_init( VipsFindTrim *find_trim )
{
	find_trim-&gt;threshold = 10;
	find_trim-&gt;background = vips_array_double_newv( 1, 255.0 );
}
int
vips_find_trim( VipsImage *in, 
	int *left, int *top, int *width, int *height, ... )
{
	va_list ap;
	int result;
	va_start( ap, height );
	result = vips_call_split( "find_trim", ap, in, 
		left, top, width, height );
	va_end( ap );
	return( result );
}
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>operation.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
#ifdef HAVE_CONFIG_H
#include &lt;config.h&gt;
#include &lt;vips/intl.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;math.h&gt;
#include &lt;vips/vips.h&gt;
#include &lt;vips/internal.h&gt;
#include &lt;vips/debug.h&gt;
#include &lt;gobject/gvaluecollector.h&gt;
enum {
	SIG_INVALIDATE,		
	SIG_LAST
};
static guint vips_operation_signals[SIG_LAST] = { 0 };
G_DEFINE_ABSTRACT_TYPE( VipsOperation, vips_operation, VIPS_TYPE_OBJECT );
static void
vips_operation_finalize( GObject *gobject )
{
	VipsOperation *operation = VIPS_OPERATION( gobject );
	VIPS_DEBUG_MSG( "vips_operation_finalize: %p\n", gobject );
	if( operation-&gt;pixels ) 
		g_info( _( "%d pixels calculated" ), operation-&gt;pixels ); 
	G_OBJECT_CLASS( vips_operation_parent_class )-&gt;finalize( gobject );
}
static void
vips_operation_dispose( GObject *gobject )
{
	VIPS_DEBUG_MSG( "vips_operation_dispose: %p\n", gobject );
	G_OBJECT_CLASS( vips_operation_parent_class )-&gt;dispose( gobject );
}
typedef enum {
	USAGE_INPUTS,
	USAGE_NOARG_OUTPUT,
	USAGE_OPTIONS,
	USAGE_NONE
} UsageType; 
typedef struct {
	char *message;			UsageType type; 		gboolean oftype;		int n;			} VipsOperationClassUsage;
static UsageType
vips_operation_class_usage_classify( VipsArgumentClass *argument_class )
{
	if( !(argument_class-&gt;flags &amp; VIPS_ARGUMENT_CONSTRUCT) ||
		(argument_class-&gt;flags &amp; VIPS_ARGUMENT_DEPRECATED) ) 
		return( USAGE_NONE ); 
	if( !(argument_class-&gt;flags &amp; VIPS_ARGUMENT_REQUIRED) )
		return( USAGE_OPTIONS ); 
	if( vips_argument_class_needsstring( argument_class ) )
		return( USAGE_INPUTS ); 
	if( (argument_class-&gt;flags &amp; VIPS_ARGUMENT_OUTPUT) &amp;&amp;
		!vips_argument_class_needsstring( argument_class ) )
		return( USAGE_NOARG_OUTPUT ); 
	return( USAGE_NONE ); 
}
static void
vips_operation_pspec_usage( VipsBuf *buf, GParamSpec *pspec )
{
	GType type = G_PARAM_SPEC_VALUE_TYPE( pspec );
	if( G_IS_PARAM_SPEC_ENUM( pspec ) ) {
		GTypeClass *class = g_type_class_ref( type );
		GParamSpecEnum *pspec_enum = (GParamSpecEnum *) pspec;
		GEnumClass *genum;
		int i; 
		if( !class )
			return;
		genum = G_ENUM_CLASS( class );
		vips_buf_appendf( buf, "\t\t\t" ); 
		vips_buf_appendf( buf, "%s", _( "default" ) );
		vips_buf_appendf( buf, ": %s\n", 
			vips_enum_nick( type, pspec_enum-&gt;default_value ) ); 
		vips_buf_appendf( buf, "\t\t\t" ); 
		vips_buf_appendf( buf, "%s", _( "allowed" ) );
		vips_buf_appendf( buf, ": " ); 
		for( i = 0; i &lt; genum-&gt;n_values - 1; i++ ) {
			if( i &gt; 0 )
				vips_buf_appends( buf, ", " );
			vips_buf_appends( buf, genum-&gt;values[i].value_nick );
		}
		vips_buf_appendf( buf, "\n" ); 
	}
	else if( G_IS_PARAM_SPEC_BOOLEAN( pspec ) ) {
		GParamSpecBoolean *pspec_boolean = (GParamSpecBoolean *) pspec;
		vips_buf_appendf( buf, "\t\t\t" ); 
		vips_buf_appendf( buf, "%s", _( "default" ) );
		vips_buf_appendf( buf, ": %s\n", 
			pspec_boolean-&gt;default_value ? "true" : "false" ); 
	}
	else if( G_IS_PARAM_SPEC_DOUBLE( pspec ) ) {
		GParamSpecDouble *pspec_double = (GParamSpecDouble *) pspec;
		vips_buf_appendf( buf, "\t\t\t" ); 
		vips_buf_appendf( buf, "%s", _( "default" ) );
		vips_buf_appendf( buf, ": %g\n", pspec_double-&gt;default_value ); 
		vips_buf_appendf( buf, "\t\t\t" ); 
		vips_buf_appendf( buf, "%s", _( "min" ) );
		vips_buf_appendf( buf, ": %g, ", pspec_double-&gt;minimum ); 
		vips_buf_appendf( buf, "%s", _( "max" ) );
		vips_buf_appendf( buf, ": %g\n", pspec_double-&gt;maximum ); 
	}
	else if( G_IS_PARAM_SPEC_INT( pspec ) ) {
		GParamSpecInt *pspec_int = (GParamSpecInt *) pspec;
		vips_buf_appendf( buf, "\t\t\t" ); 
		vips_buf_appendf( buf, "%s", _( "default" ) );
		vips_buf_appendf( buf, ": %d\n", pspec_int-&gt;default_value ); 
		vips_buf_appendf( buf, "\t\t\t" ); 
		vips_buf_appendf( buf, "%s", _( "min" ) );
		vips_buf_appendf( buf, ": %d, ", pspec_int-&gt;minimum ); 
		vips_buf_appendf( buf, "%s", _( "max" ) );
		vips_buf_appendf( buf, ": %d\n", pspec_int-&gt;maximum ); 
	}
}
static void *
vips_operation_class_usage_arg( VipsObjectClass *object_class, 
	GParamSpec *pspec, VipsArgumentClass *argument_class,
	VipsBuf *buf, VipsOperationClassUsage *usage )
{
	if( usage-&gt;type == 
		vips_operation_class_usage_classify( argument_class ) ) { 
		if( usage-&gt;message &amp;&amp; 
			usage-&gt;n == 0 ) 
			vips_buf_appendf( buf, "%s\n", usage-&gt;message );
		if( usage-&gt;oftype ) {
			vips_buf_appendf( buf, "   %-12s - %s, %s %s\n",
				g_param_spec_get_name( pspec ), 
				g_param_spec_get_blurb( pspec ), 
				(argument_class-&gt;flags &amp; VIPS_ARGUMENT_INPUT) ?
					_( "input" ) : _( "output" ),
				g_type_name( 
					G_PARAM_SPEC_VALUE_TYPE( pspec ) ) );
			vips_operation_pspec_usage( buf, pspec );
		}
		else {
				if( usage-&gt;n &gt; 0 )
					vips_buf_appends( buf, " " );
				vips_buf_appends( buf, 
					g_param_spec_get_name( pspec ) );
		}
		usage-&gt;n += 1;
	}
	return( NULL );
}
static void
vips_operation_usage( VipsOperationClass *class, VipsBuf *buf )
{
	VipsObjectClass *object_class = VIPS_OBJECT_CLASS( class );
	VipsOperationClassUsage usage;
	vips_buf_appendf( buf, "%s\n", object_class-&gt;description );
	vips_buf_appendf( buf, "usage:\n" ); 
	vips_buf_appendf( buf, "   %s ", object_class-&gt;nickname );
	usage.message = NULL;
	usage.type = USAGE_INPUTS;
	usage.oftype = FALSE;
	usage.n = 0;
	vips_argument_class_map( object_class,
		(VipsArgumentClassMapFn) vips_operation_class_usage_arg, 
			buf, &amp;usage );
	vips_buf_appends( buf, " [--option-name option-value ...]\n" );
	usage.message = "where:";
	usage.type = USAGE_INPUTS;
	usage.oftype = TRUE;
	usage.n = 0;
	vips_argument_class_map( object_class,
		(VipsArgumentClassMapFn) vips_operation_class_usage_arg, 
			buf, &amp;usage );
	usage.message = "outputs:";
	usage.type = USAGE_NOARG_OUTPUT;
	usage.oftype = TRUE;
	usage.n = 0;
	vips_argument_class_map( object_class,
		(VipsArgumentClassMapFn) vips_operation_class_usage_arg, 
			buf, &amp;usage );
	usage.message = "optional arguments:";
	usage.type = USAGE_OPTIONS;
	usage.oftype = TRUE;
	usage.n = 0;
	vips_argument_class_map( object_class,
		(VipsArgumentClassMapFn) vips_operation_class_usage_arg, 
			buf, &amp;usage );
	if( class-&gt;flags ) {
		GFlagsValue *value;
		VipsOperationFlags flags;
		GFlagsClass *flags_class = 
			g_type_class_ref( VIPS_TYPE_OPERATION_FLAGS );
		vips_buf_appendf( buf, "operation flags: " );
		flags = class-&gt;flags; 
		while( flags &amp;&amp; (value = 
			g_flags_get_first_value( flags_class, flags )) ) {
			vips_buf_appendf( buf, "%s ", value-&gt;value_nick );
			flags &amp;= ~value-&gt;value;
		}
		vips_buf_appends( buf, "\n" );
	}
}
static void *
vips_operation_call_argument( VipsObject *object, GParamSpec *pspec,
	VipsArgumentClass *argument_class,
	VipsArgumentInstance *argument_instance,
	void *a, void *b )
{
	VipsArgument *argument = (VipsArgument *) argument_class;
	printf( "   %s: offset = %d ", 
		g_param_spec_get_name( argument-&gt;pspec ),
		argument_class-&gt;offset );
	if( argument_class-&gt;flags &amp; VIPS_ARGUMENT_REQUIRED )
		printf ("required " );
	if( argument_class-&gt;flags &amp; VIPS_ARGUMENT_CONSTRUCT )
		printf ("construct " );
	if( argument_class-&gt;flags &amp; VIPS_ARGUMENT_SET_ONCE )
		printf ("set-once " );
	if( argument_instance-&gt;assigned )
		printf ("assigned " );
	printf( "\n" );
	return( NULL );
}
static void
vips_operation_dump( VipsObject *object, VipsBuf *buf )
{
	VipsOperation *operation = VIPS_OPERATION( object );
	VipsObjectClass *object_class = VIPS_OBJECT_GET_CLASS( object );
	if( operation-&gt;found_hash )
		printf( "hash = %x\n", operation-&gt;hash ); 
	printf( "%s args:\n", object_class-&gt;nickname );
	vips_argument_map( VIPS_OBJECT( operation ),
		vips_operation_call_argument, NULL, NULL );
	VIPS_OBJECT_CLASS( vips_operation_parent_class )-&gt;dump( object, buf );
}
static void *
vips_operation_vips_operation_print_summary_arg( VipsObject *object, 
	GParamSpec *pspec,
	VipsArgumentClass *argument_class,
	VipsArgumentInstance *argument_instance,
	void *a, void *b )
{
	VipsBuf *buf = (VipsBuf *) a;
	if( ((argument_class-&gt;flags &amp; VIPS_ARGUMENT_INPUT) ||
		 (argument_class-&gt;flags &amp; VIPS_ARGUMENT_OUTPUT)) &amp;&amp;
		(argument_class-&gt;flags &amp; VIPS_ARGUMENT_CONSTRUCT) &amp;&amp;
		argument_instance-&gt;assigned ) {
		const char *name = g_param_spec_get_name( pspec );
		GType type = G_PARAM_SPEC_VALUE_TYPE( pspec );
		GValue gvalue = { 0, };
		char *str;
		g_value_init( &amp;gvalue, type );
		g_object_get_property( G_OBJECT( object ), name, &amp;gvalue ); 
		str = g_strdup_value_contents( &amp;gvalue );
		vips_buf_appendf( buf, " %s=%s", name, str );
		g_free( str );
		g_value_unset( &amp;gvalue ); 
	}
	return( NULL );
}
static void
vips_operation_summary( VipsObject *object, VipsBuf *buf )
{
	VipsOperation *operation = VIPS_OPERATION( object );
	VipsObjectClass *object_class = VIPS_OBJECT_GET_CLASS( object );
	vips_buf_appendf( buf, "%s", object_class-&gt;nickname ); 
	vips_argument_map( VIPS_OBJECT( operation ),
		vips_operation_vips_operation_print_summary_arg, buf, NULL );
	vips_buf_appends( buf, " -" );
	VIPS_OBJECT_CLASS( vips_operation_parent_class )-&gt;
		summary( object, buf );
}
static VipsOperationFlags
vips_operation_real_get_flags( VipsOperation *operation ) 
{
<a name="0"></a>	VipsOperationClass *class = VIPS_OPERATION_GET_CLASS( operation );
	return( class-&gt;flags );
<font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>}
static void
vips_operation_class_init( VipsOperationClass *class )
{
	GObjectClass *gobject_class = G_OBJECT_CLASS( class );
	VipsObjectClass *vobject_class = VIPS_OBJECT_CLASS( class );
	gobject_class-&gt;finalize = vips_operation_finalize;
	gobject_class-&gt;dispose = vips_operation_dispose;
	vobject_class-&gt;nickname = "operation";
	vobject_class-&gt;description = _( "operations" );
	vobject_class-&gt;summary = vips_operation_summary;</b></font>
	vobject_class-&gt;dump = vips_operation_dump;
	class-&gt;usage = vips_operation_usage;
	class-&gt;get_flags = vips_operation_real_get_flags;
	vips_operation_signals[SIG_INVALIDATE] = g_signal_new( "invalidate",
		G_TYPE_FROM_CLASS( class ),
		G_SIGNAL_RUN_LAST,
		G_STRUCT_OFFSET( VipsOperationClass, invalidate ), 
		NULL, NULL,
		g_cclosure_marshal_VOID__VOID,
		G_TYPE_NONE, 0 );
}
static void
vips_operation_init( VipsOperation *operation )
{
}
VipsOperationFlags
vips_operation_get_flags( VipsOperation *operation ) 
{
	VipsOperationClass *class = VIPS_OPERATION_GET_CLASS( operation );
	return( class-&gt;get_flags( operation ) );
}
void
vips_operation_class_print_usage( VipsOperationClass *operation_class )
{
	char str[4096];
	VipsBuf buf = VIPS_BUF_STATIC( str );
	operation_class-&gt;usage( operation_class, &amp;buf );
	printf( "%s", vips_buf_all( &amp;buf ) );
}
void
vips_operation_invalidate( VipsOperation *operation )
{
#ifdef VIPS_DEBUG
	printf( "vips_operation_invalidate: %p\n", operation ); 
	vips_object_print_summary( VIPS_OBJECT( operation ) ); 
	g_signal_emit( operation, vips_operation_signals[SIG_INVALIDATE], 0 );
}
VipsOperation *
vips_operation_new( const char *name )
{
	GType type;
	VipsObject *object;
	VipsOperation *operation;
	vips_check_init();
	if( !(type = vips_type_find( "VipsOperation", name )) ) {
		vips_error( "VipsOperation", 
			_( "class \"%s\" not found" ), name );
		return( NULL );
	}
	if( !(object = g_object_new( type, NULL )) ) {
		vips_error( "VipsOperation", 
			_( "\"%s\" is not an instantiable class" ), name );
		return( NULL );
	}
	operation = VIPS_OPERATION( object );
	VIPS_DEBUG_MSG( "vips_operation_new: %s (%p)\n", name, operation );
	return( operation );
}
#ifndef va_copy
#define va_copy(d,s) ((d) = (s))
#endif
static int
vips_operation_set_valist_required( VipsOperation *operation, va_list ap )
{
	VIPS_DEBUG_MSG( "vips_operation_set_valist_required:\n" );
	VIPS_ARGUMENT_FOR_ALL( operation, 
		pspec, argument_class, argument_instance ) {
		g_assert( argument_instance );
		if( (argument_class-&gt;flags &amp; VIPS_ARGUMENT_REQUIRED) &amp;&amp;
			!(argument_class-&gt;flags &amp; VIPS_ARGUMENT_DEPRECATED) ) {
			VIPS_ARGUMENT_COLLECT_SET( pspec, argument_class, ap );
#ifdef VIPS_DEBUG
			{
				char *str;
				str = g_strdup_value_contents( &amp;value );
				VIPS_DEBUG_MSG( "\t%s = %s\n", 
					g_param_spec_get_name( pspec ), str );
				g_free( str );
			}
			g_object_set_property( G_OBJECT( operation ),
				g_param_spec_get_name( pspec ), &amp;value );
			VIPS_ARGUMENT_COLLECT_GET( pspec, argument_class, ap );
#ifdef VIPS_DEBUG
			printf( "\tskipping arg %p for %s\n", 
				arg, g_param_spec_get_name( pspec ) );
			VIPS_ARGUMENT_COLLECT_END
		}
	} VIPS_ARGUMENT_FOR_ALL_END
	return( 0 );
}
static int
vips_operation_get_valist_required( VipsOperation *operation, va_list ap )
{
	VIPS_DEBUG_MSG( "vips_operation_get_valist_required:\n" );
	VIPS_ARGUMENT_FOR_ALL( operation, 
		pspec, argument_class, argument_instance ) {
		if( (argument_class-&gt;flags &amp; VIPS_ARGUMENT_REQUIRED) ) {
			VIPS_ARGUMENT_COLLECT_SET( pspec, argument_class, ap );
			VIPS_ARGUMENT_COLLECT_GET( pspec, argument_class, ap );
			if( !argument_instance-&gt;assigned ) 
				continue;
#ifdef VIPS_DEBUG
			printf( "\twriting %s to %p\n", 
				g_param_spec_get_name( pspec ), arg );
			g_object_get( G_OBJECT( operation ), 
				g_param_spec_get_name( pspec ), arg, NULL );
			if( G_IS_PARAM_SPEC_OBJECT( pspec ) ) {
				GObject *object;
				object = *((GObject **) arg);
				g_object_unref( object ); 
			}
			VIPS_ARGUMENT_COLLECT_END
		}
	} VIPS_ARGUMENT_FOR_ALL_END
	return( 0 );
}
static int
vips_operation_get_valist_optional( VipsOperation *operation, va_list ap )
{
	char *name;
	VIPS_DEBUG_MSG( "vips_operation_get_valist_optional:\n" );
	for( name = va_arg( ap, char * ); name; name = va_arg( ap, char * ) ) { 
		GParamSpec *pspec;
		VipsArgumentClass *argument_class;
		VipsArgumentInstance *argument_instance;
		VIPS_DEBUG_MSG( "\tname = '%s' (%p)\n", name, name );
		if( vips_object_get_argument( VIPS_OBJECT( operation ), name,
			&amp;pspec, &amp;argument_class, &amp;argument_instance ) )
			return( -1 );
		VIPS_ARGUMENT_COLLECT_SET( pspec, argument_class, ap );
		VIPS_ARGUMENT_COLLECT_GET( pspec, argument_class, ap );
#ifdef VIPS_DEBUG
		printf( "\twriting %s to %p\n", 
			g_param_spec_get_name( pspec ), arg );
		if( arg ) {
			g_object_get( G_OBJECT( operation ), 
				g_param_spec_get_name( pspec ), arg, 
				NULL );
			if( G_IS_PARAM_SPEC_OBJECT( pspec ) ) {
				GObject *object;
				object = *((GObject **) arg);
				g_object_unref( object ); 
			}
		}
		VIPS_ARGUMENT_COLLECT_END
	}
	return( 0 );
}
int
vips_call_required_optional( VipsOperation **operation,
	va_list required, va_list optional ) 
{
	int result;
	va_list a;
	va_list b;
	va_copy( a, required );
	va_copy( b, optional );
	result = vips_operation_set_valist_required( *operation, a ) ||
		vips_object_set_valist( VIPS_OBJECT( *operation ), b );
	va_end( a );
	va_end( b );
	if( result )
		return( -1 );
	if( vips_cache_operation_buildp( operation ) )
		return( -1 );
	va_copy( a, required );
	va_copy( b, optional );
	result = vips_operation_get_valist_required( *operation, required ) ||
		vips_operation_get_valist_optional( *operation, optional );
	va_end( a );
	va_end( b );
	return( result );
}
static int
vips_call_by_name( const char *operation_name, 
	const char *option_string, va_list required, va_list optional )
{
	VipsOperation *operation;
	int result;
	VIPS_DEBUG_MSG( "vips_call_by_name: starting for %s ...\n", 
		operation_name );
	if( !(operation = vips_operation_new( operation_name )) )
		return( -1 );
	if( option_string &amp;&amp;
		vips_object_set_from_string( VIPS_OBJECT( operation ), 
			option_string ) ) {
		vips_object_unref_outputs( VIPS_OBJECT( operation ) );
		g_object_unref( operation ); 
		return( -1 ); 
	}
	result = vips_call_required_optional( &amp;operation, required, optional );
	if( result ) {
		vips_object_unref_outputs( VIPS_OBJECT( operation ) );
		g_object_unref( operation );
		return( -1 );
	}
	g_object_unref( operation );
	return( result );
}
int
vips_call( const char *operation_name, ... )
{
	VipsOperation *operation;
	int result;
	va_list required;
	va_list optional;
	if( !(operation = vips_operation_new( operation_name )) )
		return( -1 );
	va_start( required, operation_name );
	va_copy( optional, required );
	VIPS_ARGUMENT_FOR_ALL( operation, 
		pspec, argument_class, argument_instance ) {
		g_assert( argument_instance );
		if( (argument_class-&gt;flags &amp; VIPS_ARGUMENT_REQUIRED) ) {
			VIPS_ARGUMENT_COLLECT_SET( pspec, argument_class, 
				optional );
			VIPS_ARGUMENT_COLLECT_GET( pspec, argument_class, 
				optional );
			VIPS_ARGUMENT_COLLECT_END
		}
	} VIPS_ARGUMENT_FOR_ALL_END
	g_object_unref( operation ); 
	result = vips_call_by_name( operation_name, NULL, required, optional ); 
	va_end( required );
	va_end( optional );
	return( result );
}
int
vips_call_split( const char *operation_name, va_list optional, ... ) 
{
	int result;
	va_list required;
	va_start( required, optional );
	result = vips_call_by_name( operation_name, NULL, 
		required, optional );
	va_end( required );
	return( result );
}
int
vips_call_split_option_string( const char *operation_name, 
	const char *option_string, va_list optional, ... ) 
{
	int result;
	va_list required;
	va_start( required, optional );
	result = vips_call_by_name( operation_name, option_string, 
		required, optional );
	va_end( required );
	return( result );
}
static void *
vips_call_find_pspec( VipsObject *object,
	GParamSpec *pspec,
	VipsArgumentClass *argument_class,
	VipsArgumentInstance *argument_instance,
	void *a, void *b )
{
	const char *name = (const char *) a;
	if( !(argument_class-&gt;flags &amp; VIPS_ARGUMENT_REQUIRED) &amp;&amp;
		(argument_class-&gt;flags &amp; VIPS_ARGUMENT_CONSTRUCT) &amp;&amp;
		!argument_instance-&gt;assigned ) 
		if( (strlen( name ) == 1 &amp;&amp; 
			g_param_spec_get_name( pspec )[0] == name[0]) ||
			strcmp( g_param_spec_get_name( pspec ), name  ) == 0 ) 
			return( argument_instance );
	return( NULL );
}
typedef struct _VipsCallOptionOutput {
	VipsArgumentInstance *argument_instance;
	char *value;
} VipsCallOptionOutput;
static int
vips_call_option_output( VipsObject *object,
	VipsCallOptionOutput *output )
{
	VipsArgumentInstance *argument_instance = output-&gt;argument_instance;
	GParamSpec *pspec = ((VipsArgument *) argument_instance)-&gt;pspec;
	int result;
	result = 0;
	if( object-&gt;constructed )
		result = vips_object_get_argument_to_string( object, 
			g_param_spec_get_name( pspec ), output-&gt;value );
	return( result ); 
}
static void
vips_call_option_output_free( VipsObject *object, VipsCallOptionOutput *output )
{
	VIPS_FREE( output-&gt;value ); 
	g_free( output );
}
static gboolean
vips_call_options_set( const gchar *option_name, const gchar *value, 
	gpointer data, GError **error )
{
	VipsOperation *operation = (VipsOperation *) data;
	const char *name;
	VipsArgumentInstance *argument_instance;
	VipsArgumentClass *argument_class;
	GParamSpec *pspec;
	VIPS_DEBUG_MSG( "vips_call_options_set: %s = %s\n", 
		option_name, value );
	for( name = option_name; *name == '-'; name++ )
		;
	if( !(argument_instance = (VipsArgumentInstance *) 
		vips_argument_map( 
			VIPS_OBJECT( operation ),
			vips_call_find_pspec, (void *) name, NULL )) ) {
		vips_error( VIPS_OBJECT_GET_CLASS( operation )-&gt;nickname, 
			_( "unknown argument '%s'" ), name );
		vips_error_g( error );
		return( FALSE );
	}
	argument_class = argument_instance-&gt;argument_class;
	pspec = ((VipsArgument *) argument_instance)-&gt;pspec;
	if( (argument_class-&gt;flags &amp; VIPS_ARGUMENT_INPUT) ) {
		if( vips_object_set_argument_from_string( 
			VIPS_OBJECT( operation ),
			g_param_spec_get_name( pspec ), value ) ) {
			vips_error_g( error );
			return( FALSE );
		}
#ifdef VIPS_DEBUG
{
		GType type = G_PARAM_SPEC_VALUE_TYPE( pspec );
		GValue gvalue = { 0, };
		char *str;
		g_value_init( &amp;gvalue, type );
		g_object_get_property( G_OBJECT( operation ), 
			g_param_spec_get_name( pspec ), &amp;gvalue ); 
		str = g_strdup_value_contents( &amp;gvalue );
		VIPS_DEBUG_MSG( "\tGValue %s = %s\n", 
			g_param_spec_get_name( pspec ), str );
		g_free( str );
		g_value_unset( &amp;gvalue ); 
}
	}
	else if( (argument_class-&gt;flags &amp; VIPS_ARGUMENT_OUTPUT) ) {
		VipsCallOptionOutput *output;
		output = g_new( VipsCallOptionOutput, 1 );
		output-&gt;argument_instance = argument_instance;
		output-&gt;value = g_strdup( value );
		g_signal_connect( operation, "postbuild",
			G_CALLBACK( vips_call_option_output ),
			output );
		g_signal_connect( operation, "close",
			G_CALLBACK( vips_call_option_output_free ),
			output );
	}
	return( TRUE );
}
static void *
vips_call_options_add( VipsObject *object,
	GParamSpec *pspec,
	VipsArgumentClass *argument_class,
	VipsArgumentInstance *argument_instance,
	void *a, void *b )
{
	GOptionGroup *group = (GOptionGroup *) a;
	if( !(argument_class-&gt;flags &amp; VIPS_ARGUMENT_REQUIRED) &amp;&amp;
		(argument_class-&gt;flags &amp; VIPS_ARGUMENT_CONSTRUCT) &amp;&amp;
		!argument_instance-&gt;assigned ) {
		const char *name = g_param_spec_get_name( pspec );
		gboolean needs_string = 
			vips_object_argument_needsstring( object, name );
		GOptionEntry entry[2];
		entry[0].long_name = name;
		entry[0].description = g_param_spec_get_blurb( pspec );
		if( argument_class-&gt;flags &amp; VIPS_ARGUMENT_DEPRECATED ) 
			entry[0].short_name = '\0';
		else
			entry[0].short_name = name[0];
		entry[0].flags = 0;
		if( !needs_string ) 
			entry[0].flags |= G_OPTION_FLAG_NO_ARG;
		if( argument_class-&gt;flags &amp; VIPS_ARGUMENT_DEPRECATED ) 
			entry[0].flags |= G_OPTION_FLAG_HIDDEN;
		entry[0].arg = G_OPTION_ARG_CALLBACK;
		entry[0].arg_data = (gpointer) vips_call_options_set;
		if( needs_string ) 
			entry[0].arg_description = 
				g_type_name( G_PARAM_SPEC_VALUE_TYPE( pspec ) );
		else
			entry[0].arg_description = NULL;
		entry[1].long_name = NULL;
		VIPS_DEBUG_MSG( "vips_call_options_add: adding %s\n", name );
		g_option_group_add_entries( group, &amp;entry[0] );
	}
	return( NULL );
}
void
vips_call_options( GOptionGroup *group, VipsOperation *operation )
{
	(void) vips_argument_map( VIPS_OBJECT( operation ),
		vips_call_options_add, group, NULL );
}
typedef struct _VipsCall {
	VipsOperation *operation;
	int argc;
	char **argv;
	int i;
} VipsCall;
static const char *
vips_call_get_arg( VipsCall *call, int i )
{
	if( i &lt; 0 || 
		i &gt;= call-&gt;argc ) {
		vips_error( VIPS_OBJECT_GET_CLASS( call-&gt;operation )-&gt;nickname, 
			"%s", _( "too few arguments" ) );
		return( NULL );
	}
	return( call-&gt;argv[i] );
}
static void *
vips_call_argv_input( VipsObject *object,
	GParamSpec *pspec,
	VipsArgumentClass *argument_class,
	VipsArgumentInstance *argument_instance,
	void *a, void *b )
{
	VipsCall *call = (VipsCall *) a;
	if( (argument_class-&gt;flags &amp; VIPS_ARGUMENT_REQUIRED) &amp;&amp;
		(argument_class-&gt;flags &amp; VIPS_ARGUMENT_CONSTRUCT) &amp;&amp;
		!(argument_class-&gt;flags &amp; VIPS_ARGUMENT_DEPRECATED) ) { 
		const char *name = g_param_spec_get_name( pspec );
		if( (argument_class-&gt;flags &amp; VIPS_ARGUMENT_INPUT) ) {
			const char *arg;
			if( !(arg = vips_call_get_arg( call, call-&gt;i )) ||
				vips_object_set_argument_from_string( object, 
					name, arg ) ) 
				return( pspec );
			call-&gt;i += 1;
		}
		else if( (argument_class-&gt;flags &amp; VIPS_ARGUMENT_OUTPUT) ) {
			if( vips_object_argument_needsstring( object, name ) )
				call-&gt;i += 1;
		}
	}
	return( NULL );
}
static void *
vips_call_argv_output( VipsObject *object,
	GParamSpec *pspec,
	VipsArgumentClass *argument_class,
	VipsArgumentInstance *argument_instance,
	void *a, void *b )
{
	VipsCall *call = (VipsCall *) a;
	if( (argument_class-&gt;flags &amp; VIPS_ARGUMENT_REQUIRED) &amp;&amp;
		(argument_class-&gt;flags &amp; VIPS_ARGUMENT_CONSTRUCT) &amp;&amp;
		!(argument_class-&gt;flags &amp; VIPS_ARGUMENT_DEPRECATED) ) { 
		if( (argument_class-&gt;flags &amp; VIPS_ARGUMENT_INPUT) ) 
			call-&gt;i += 1;
		else if( (argument_class-&gt;flags &amp; VIPS_ARGUMENT_OUTPUT) ) {
			const char *name = g_param_spec_get_name( pspec );
			const char *arg;
			arg = NULL;
			if( vips_object_argument_needsstring( object, name ) ) {
				arg = vips_call_get_arg( call, call-&gt;i );
				if( !arg )
					return( pspec );
				call-&gt;i += 1;
			}
			if( vips_object_get_argument_to_string( object, 
				name, arg ) ) 
				return( pspec );
		}
	}
	return( NULL );
}
int
vips_call_argv( VipsOperation *operation, int argc, char **argv )
{
	VipsCall call;
	g_assert( argc &gt;= 0 );
#ifdef VIPS_DEBUG
	printf( "vips_call_argv: " );
	vips_object_print_name( VIPS_OBJECT( operation ) );
	printf( "\n" );
{
	int i;
	for( i = 0; i &lt; argc; i++ )
		printf( "%d) %s\n", i, argv[i] );
}
	call.operation = operation;
	call.argc = argc;
	call.argv = argv;
	call.i = 0;
	if( vips_argument_map( VIPS_OBJECT( operation ),
		vips_call_argv_input, &amp;call, NULL ) ) 
		return( -1 );
	if( argc &gt; call.i ) {
		vips_error( VIPS_OBJECT_GET_CLASS( operation )-&gt;nickname, 
			"%s", _( "too many arguments" ) );
		return( -1 );
	}
	if( vips_object_build( VIPS_OBJECT( operation ) ) ) 
		return( -1 );
	if( vips__cache_trace ) {
		printf( "vips cache : " );
		vips_object_print_summary( VIPS_OBJECT( operation ) );
	}
	call.i = 0;
	if( vips_argument_map( VIPS_OBJECT( operation ),
		vips_call_argv_output, &amp;call, NULL ) ) 
		return( -1 );
	return( 0 );
}
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
