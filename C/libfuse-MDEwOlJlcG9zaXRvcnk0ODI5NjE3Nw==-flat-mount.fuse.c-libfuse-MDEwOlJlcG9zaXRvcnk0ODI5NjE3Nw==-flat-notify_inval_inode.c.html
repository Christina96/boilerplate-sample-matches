
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 24, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>libfuse-MDEwOlJlcG9zaXRvcnk0ODI5NjE3Nw==-flat-mount.fuse.c</h3>
            <pre><code>1  #include "fuse_config.h"
2  #include <stdio.h>
3  #include <stdlib.h>
4  #include <string.h>
5  #include <unistd.h>
6  #include <errno.h>
7  #include <stdint.h>
8  #include <fcntl.h>
9  #include <pwd.h>
10  #include <sys/wait.h>
11  #ifdef linux
12  #include <sys/prctl.h>
13  #include <sys/syscall.h>
14  #include <linux/capability.h>
15  #include <linux/securebits.h>
16  #if !defined(SECBIT_KEEP_CAPS) && defined(SECURE_KEEP_CAPS)
17  #define SECBIT_KEEP_CAPS (issecure_mask(SECURE_KEEP_CAPS))
18  #endif
19  #if !defined(SECBIT_KEEP_CAPS_LOCKED) && defined(SECURE_KEEP_CAPS_LOCKED)
20  #define SECBIT_KEEP_CAPS_LOCKED (issecure_mask(SECURE_KEEP_CAPS_LOCKED))
21  #endif
22  #if !defined(SECBIT_NO_SETUID_FIXUP) && defined(SECURE_NO_SETUID_FIXUP)
23  #define SECBIT_NO_SETUID_FIXUP (issecure_mask(SECURE_NO_SETUID_FIXUP))
24  #endif
25  #if !defined(SECBIT_NO_SETUID_FIXUP_LOCKED) && defined(SECURE_NO_SETUID_FIXUP_LOCKED)
26  #define SECBIT_NO_SETUID_FIXUP_LOCKED (issecure_mask(SECURE_NO_SETUID_FIXUP_LOCKED))
27  #endif
28  #if !defined(SECBIT_NOROOT) && defined(SECURE_NOROOT)
29  #define SECBIT_NOROOT (issecure_mask(SECURE_NOROOT))
30  #endif
31  #if !defined(SECBIT_NOROOT_LOCKED) && defined(SECURE_NOROOT_LOCKED)
32  #define SECBIT_NOROOT_LOCKED (issecure_mask(SECURE_NOROOT_LOCKED))
33  #endif
34  #endif
35  #ifndef PR_SET_NO_NEW_PRIVS
36  #define PR_SET_NO_NEW_PRIVS 38
37  #endif
38  #include "fuse.h"
39  static char *progname;
40  static char *xstrdup(const char *s)
41  {
42  	char *t = strdup(s);
43  	if (!t) {
44  		fprintf(stderr, "%s: failed to allocate memory\n", progname);
45  		exit(1);
46  	}
47  	return t;
48  }
49  static void *xrealloc(void *oldptr, size_t size)
50  {
51  	void *ptr = realloc(oldptr, size);
52  	if (!ptr) {
53  		fprintf(stderr, "%s: failed to allocate memory\n", progname);
54  		exit(1);
55  	}
56  	return ptr;
57  }
58  static void add_arg(char **cmdp, const char *opt)
59  {
60  	size_t optlen = strlen(opt);
61  	size_t cmdlen = *cmdp ? strlen(*cmdp) : 0;
62  	if (optlen >= (SIZE_MAX - cmdlen - 4)/4) {
63  		fprintf(stderr, "%s: argument too long\n", progname);
64  		exit(1);
65  	}
66  	char *cmd = xrealloc(*cmdp, cmdlen + optlen * 4 + 4);
67  	char *s;
68  	s = cmd + cmdlen;
69  	if (*cmdp)
70  		*s++ = ' ';
71  	*s++ = '\'';
72  	for (; *opt; opt++) {
73  		if (*opt == '\'') {
74  			*s++ = '\'';
75  			*s++ = '\\';
76  			*s++ = '\'';
77  			*s++ = '\'';
78  		} else
79  			*s++ = *opt;
80  	}
81  	*s++ = '\'';
82  	*s = '\0';
83  	*cmdp = cmd;
84  }
85  static char *add_option(const char *opt, char *options)
86  {
87  	int oldlen = options ? strlen(options) : 0;
88  	options = xrealloc(options, oldlen + 1 + strlen(opt) + 1);
89  	if (!oldlen)
<span onclick='openModal()' class='match'>90  		strcpy(options, opt);
91  	else {
92  		strcat(options, ",");
93  		strcat(options, opt);
94  	}
95  	return options;
</span>96  }
97  static int prepare_fuse_fd(const char *mountpoint, const char* subtype,
98  			   const char *options)
99  {
100  	int fuse_fd = -1;
101  	int flags = -1;
102  	int subtype_len = strlen(subtype) + 9;
103  	char* options_copy = xrealloc(NULL, subtype_len);
104  	snprintf(options_copy, subtype_len, "subtype=%s", subtype);
105  	options_copy = add_option(options, options_copy);
106  	fuse_fd = fuse_open_channel(mountpoint, options_copy);
107  	if (fuse_fd == -1) {
108  		exit(1);
109  	}
110  	flags = fcntl(fuse_fd, F_GETFD);
111  	if (flags == -1 || fcntl(fuse_fd, F_SETFD, flags & ~FD_CLOEXEC) == 1) {
112  		fprintf(stderr, "%s: Failed to clear CLOEXEC: %s\n",
113  			progname, strerror(errno));
114  		exit(1);
115  	}
116  	return fuse_fd;
117  }
118  #ifdef linux
119  static uint64_t get_capabilities(void)
120  {
121  	struct __user_cap_header_struct header = {
122  		.version = _LINUX_CAPABILITY_VERSION_3,
123  		.pid = 0,
124  	};
125  	struct __user_cap_data_struct data[2];
126  	memset(data, 0, sizeof(data));
127  	if (syscall(SYS_capget, &header, data) == -1) {
128  		fprintf(stderr, "%s: Failed to get capabilities: %s\n",
129  			progname, strerror(errno));
130  		exit(1);
131  	}
132  	return data[0].effective | ((uint64_t) data[1].effective << 32);
133  }
134  static void set_capabilities(uint64_t caps)
135  {
136  	struct __user_cap_header_struct header = {
137  		.version = _LINUX_CAPABILITY_VERSION_3,
138  		.pid = 0,
139  	};
140  	struct __user_cap_data_struct data[2];
141  	memset(data, 0, sizeof(data));
142  	data[0].effective = data[0].permitted = caps;
143  	data[1].effective = data[1].permitted = caps >> 32;
144  	if (syscall(SYS_capset, &header, data) == -1) {
145  		fprintf(stderr, "%s: Failed to set capabilities: %s\n",
146  			progname, strerror(errno));
147  		exit(1);
148  	}
149  }
150  static void drop_and_lock_capabilities(void)
151  {
152  	if (prctl(PR_SET_SECUREBITS,
153  		  SECBIT_KEEP_CAPS_LOCKED |
154  		  SECBIT_NO_SETUID_FIXUP |
155  		  SECBIT_NO_SETUID_FIXUP_LOCKED |
156  		  SECBIT_NOROOT |
157  		  SECBIT_NOROOT_LOCKED) == -1) {
158  		fprintf(stderr, "%s: Failed to set securebits %s\n",
159  			progname, strerror(errno));
160  		exit(1);
161  	}
162  	int cap;
163  	for (cap = 0; ; cap++) {
164  		int cap_status = prctl(PR_CAPBSET_READ, cap);
165  		if (cap_status == 0) {
166  			continue;
167  		}
168  		if (cap_status == -1 && errno == EINVAL) {
169  			break;
170  		}
171  		if (cap_status != 1) {
172  			fprintf(stderr,
173  				"%s: Failed to get capability %u: %s\n",
174  				progname, cap, strerror(errno));
175  			exit(1);
176  		}
177  		if (prctl(PR_CAPBSET_DROP, cap) == -1) {
178  			fprintf(stderr,
179  				"%s: Failed to drop capability %u: %s\n",
180  				progname, cap, strerror(errno));
181  		}
182  	}
183  	set_capabilities(0);
184  	if (prctl(PR_SET_NO_NEW_PRIVS, 1, 0, 0, 0) == -1) {
185  		fprintf(stderr, "%s: Failed to set no_new_privs: %s\n",
186  			progname, strerror(errno));
187  		exit(1);
188  	}
189  }
190  #endif
191  int main(int argc, char *argv[])
192  {
193  	char *type = NULL;
194  	char *source;
195  	char *dup_source = NULL;
196  	const char *mountpoint;
197  	char *basename;
198  	char *options = NULL;
199  	char *command = NULL;
200  	char *setuid_name = NULL;
201  	int i;
202  	int dev = 1;
203  	int suid = 1;
204  	int pass_fuse_fd = 0;
205  	int fuse_fd = 0;
206  	int drop_privileges = 0;
207  	char *dev_fd_mountpoint = NULL;
208  	progname = argv[0];
209  	basename = strrchr(argv[0], '/');
210  	if (basename)
211  		basename++;
212  	else
213  		basename = argv[0];
214  	if (strncmp(basename, "mount.fuse.", 11) == 0)
215  		type = basename + 11;
216  	if (strncmp(basename, "mount.fuseblk.", 14) == 0)
217  		type = basename + 14;
218  	if (type && !type[0])
219  		type = NULL;
220  	if (argc < 3) {
221  		fprintf(stderr,
222  			"usage: %s %s destination [-t type] [-o opt[,opts...]]\n",
223  			progname, type ? "source" : "type#[source]");
224  		exit(1);
225  	}
226  	source = argv[1];
227  	if (!source[0])
228  		source = NULL;
229  	mountpoint = argv[2];
230  	for (i = 3; i < argc; i++) {
231  		if (strcmp(argv[i], "-v") == 0) {
232  			continue;
233  		} else if (strcmp(argv[i], "-t") == 0) {
234  			i++;
235  			if (i == argc) {
236  				fprintf(stderr,
237  					"%s: missing argument to option '-t'\n",
238  					progname);
239  				exit(1);
240  			}
241  			type = argv[i];
242  			if (strncmp(type, "fuse.", 5) == 0)
243  				type += 5;
244  			else if (strncmp(type, "fuseblk.", 8) == 0)
245  				type += 8;
246  			if (!type[0]) {
247  				fprintf(stderr,
248  					"%s: empty type given as argument to option '-t'\n",
249  					progname);
250  				exit(1);
251  			}
252  		} else	if (strcmp(argv[i], "-o") == 0) {
253  			char *opts;
254  			char *opt;
255  			i++;
256  			if (i == argc)
257  				break;
258  			opts = xstrdup(argv[i]);
259  			opt = strtok(opts, ",");
260  			while (opt) {
261  				int j;
262  				int ignore = 0;
263  				const char *ignore_opts[] = { "",
264  							      "user",
265  							      "nofail",
266  							      "nouser",
267  							      "users",
268  							      "auto",
269  							      "noauto",
270  							      "_netdev",
271  							      NULL};
272  				if (strncmp(opt, "setuid=", 7) == 0) {
273  					setuid_name = xstrdup(opt + 7);
274  					ignore = 1;
275  				} else if (strcmp(opt,
276  						  "drop_privileges") == 0) {
277  					pass_fuse_fd = 1;
278  					drop_privileges = 1;
279  					ignore = 1;
280  				}
281  				for (j = 0; ignore_opts[j]; j++)
282  					if (strcmp(opt, ignore_opts[j]) == 0)
283  						ignore = 1;
284  				if (!ignore) {
285  					if (strcmp(opt, "nodev") == 0)
286  						dev = 0;
287  					else if (strcmp(opt, "nosuid") == 0)
288  						suid = 0;
289  					options = add_option(opt, options);
290  				}
291  				opt = strtok(NULL, ",");
292  			}
293  			free(opts);
294  		}
295  	}
296  	if (drop_privileges) {
297  		uint64_t required_caps = CAP_TO_MASK(CAP_SETPCAP) |
298  				CAP_TO_MASK(CAP_SYS_ADMIN);
299  		if ((get_capabilities() & required_caps) != required_caps) {
300  			fprintf(stderr, "%s: drop_privileges was requested, which launches the FUSE file system fully unprivileged. In order to do so %s must be run with privileges, please invoke with CAP_SYS_ADMIN and CAP_SETPCAP (e.g. as root).\n",
301  			progname, progname);
302  			exit(1);
303  		}
304  	}
305  	if (dev)
306  		options = add_option("dev", options);
307  	if (suid)
308  		options = add_option("suid", options);
309  	if (!type) {
310  		if (source) {
311  			dup_source = xstrdup(source);
312  			type = dup_source;
313  			source = strchr(type, '#');
314  			if (source)
315  				*source++ = '\0';
316  			if (!type[0]) {
317  				fprintf(stderr, "%s: empty filesystem type\n",
318  					progname);
319  				exit(1);
320  			}
321  		} else {
322  			fprintf(stderr, "%s: empty source\n", progname);
323  			exit(1);
324  		}
325  	}
326  	if (setuid_name && setuid_name[0]) {
327  #ifdef linux
328  		if (drop_privileges) {
329  			if (prctl(PR_SET_SECUREBITS,
330  				  SECBIT_KEEP_CAPS |
331  				  SECBIT_NO_SETUID_FIXUP) == -1) {
332  				fprintf(stderr,
333  					"%s: Failed to set securebits %s\n",
334  					progname, strerror(errno));
335  				exit(1);
336  			}
337  		}
338  #endif
339  		struct passwd *pwd = getpwnam(setuid_name);
340  		if (!pwd || setgid(pwd->pw_gid) == -1 || setuid(pwd->pw_uid) == -1) {
341  			fprintf(stderr, "%s: Failed to setuid to %s: %s\n",
342  				progname, setuid_name, strerror(errno));
343  			exit(1);
344  		}
345  	} else if (!getenv("HOME")) {
346  		setenv("HOME", "/root", 0);
347  	}
348  	if (pass_fuse_fd)  {
349  		fuse_fd = prepare_fuse_fd(mountpoint, type, options);
350  		dev_fd_mountpoint = xrealloc(NULL, 20);
351  		snprintf(dev_fd_mountpoint, 20, "/dev/fd/%u", fuse_fd);
352  		mountpoint = dev_fd_mountpoint;
353  	}
354  #ifdef linux
355  	if (drop_privileges) {
356  		drop_and_lock_capabilities();
357  	}
358  #endif
359  	add_arg(&command, type);
360  	if (source)
361  		add_arg(&command, source);
362  	add_arg(&command, mountpoint);
363  	if (options) {
364  		add_arg(&command, "-o");
365  		add_arg(&command, options);
366  	}
367  	free(options);
368  	free(dev_fd_mountpoint);
369  	free(dup_source);
370  	free(setuid_name);
371  	execl("/bin/sh", "/bin/sh", "-c", command, NULL);
372  	fprintf(stderr, "%s: failed to execute /bin/sh: %s\n", progname,
373  		strerror(errno));
374  	if (pass_fuse_fd)
375  		close(fuse_fd);
376  	free(command);
377  	return 1;
378  }
</code></pre>
        </div>
        <div class="column">
            <h3>libfuse-MDEwOlJlcG9zaXRvcnk0ODI5NjE3Nw==-flat-notify_inval_inode.c</h3>
            <pre><code>1  #define FUSE_USE_VERSION 34
2  #include <fuse_lowlevel.h>
3  #include <stdio.h>
4  #include <stdlib.h>
5  #include <string.h>
6  #include <errno.h>
7  #include <fcntl.h>
8  #include <assert.h>
9  #include <stddef.h>
10  #include <unistd.h>
11  #include <pthread.h>
12  #define NO_TIMEOUT 500000
13  #define MAX_STR_LEN 128
14  #define FILE_INO 2
15  #define FILE_NAME "current_time"
16  static char file_contents[MAX_STR_LEN];
17  static int lookup_cnt = 0;
18  static size_t file_size;
19  struct options {
20      int no_notify;
21      int update_interval;
22  };
23  static struct options options = {
24      .no_notify = 0,
25      .update_interval = 1,
26  };
27  #define OPTION(t, p)                           \
28      { t, offsetof(struct options, p), 1 }
29  static const struct fuse_opt option_spec[] = {
30      OPTION("--no-notify", no_notify),
31      OPTION("--update-interval=%d", update_interval),
32      FUSE_OPT_END
33  };
34  static int tfs_stat(fuse_ino_t ino, struct stat *stbuf) {
35      stbuf->st_ino = ino;
36      if (ino == FUSE_ROOT_ID) {
37          stbuf->st_mode = S_IFDIR | 0755;
38          stbuf->st_nlink = 1;
39      }
40      else if (ino == FILE_INO) {
41          stbuf->st_mode = S_IFREG | 0444;
42          stbuf->st_nlink = 1;
43          stbuf->st_size = file_size;
44      }
45      else
46          return -1;
47      return 0;
48  }
49  static void tfs_lookup(fuse_req_t req, fuse_ino_t parent,
50                         const char *name) {
51      struct fuse_entry_param e;
52      memset(&e, 0, sizeof(e));
53      if (parent != FUSE_ROOT_ID)
54          goto err_out;
55      else if (strcmp(name, FILE_NAME) == 0) {
56          e.ino = FILE_INO;
57          lookup_cnt++;
58      } else
59          goto err_out;
60      e.attr_timeout = NO_TIMEOUT;
61      e.entry_timeout = NO_TIMEOUT;
62      if (tfs_stat(e.ino, &e.attr) != 0)
63          goto err_out;
64      fuse_reply_entry(req, &e);
65      return;
66  err_out:
67      fuse_reply_err(req, ENOENT);
68  }
69  static void tfs_forget (fuse_req_t req, fuse_ino_t ino,
70                          uint64_t nlookup) {
71      (void) req;
72      if(ino == FILE_INO)
73          lookup_cnt -= nlookup;
74      else
75          assert(ino == FUSE_ROOT_ID);
76      fuse_reply_none(req);
77  }
78  static void tfs_getattr(fuse_req_t req, fuse_ino_t ino,
79                          struct fuse_file_info *fi) {
80      struct stat stbuf;
81      (void) fi;
82      memset(&stbuf, 0, sizeof(stbuf));
83      if (tfs_stat(ino, &stbuf) != 0)
84          fuse_reply_err(req, ENOENT);
85      else
86          fuse_reply_attr(req, &stbuf, NO_TIMEOUT);
87  }
88  struct dirbuf {
89      char *p;
90      size_t size;
91  };
92  static void dirbuf_add(fuse_req_t req, struct dirbuf *b, const char *name,
93                         fuse_ino_t ino) {
94      struct stat stbuf;
95      size_t oldsize = b->size;
96      b->size += fuse_add_direntry(req, NULL, 0, name, NULL, 0);
97      b->p = (char *) realloc(b->p, b->size);
98      memset(&stbuf, 0, sizeof(stbuf));
99      stbuf.st_ino = ino;
100      fuse_add_direntry(req, b->p + oldsize, b->size - oldsize, name, &stbuf,
101                        b->size);
102  }
103  #define min(x, y) ((x) < (y) ? (x) : (y))
104  static int reply_buf_limited(fuse_req_t req, const char *buf, size_t bufsize,
105                               off_t off, size_t maxsize) {
106      if (off < bufsize)
107          return fuse_reply_buf(req, buf + off,
108                                min(bufsize - off, maxsize));
109      else
110          return fuse_reply_buf(req, NULL, 0);
111  }
112  static void tfs_readdir(fuse_req_t req, fuse_ino_t ino, size_t size,
113                          off_t off, struct fuse_file_info *fi) {
114      (void) fi;
115      if (ino != FUSE_ROOT_ID)
116          fuse_reply_err(req, ENOTDIR);
117      else {
118          struct dirbuf b;
119          memset(&b, 0, sizeof(b));
120          dirbuf_add(req, &b, FILE_NAME, FILE_INO);
121          reply_buf_limited(req, b.p, b.size, off, size);
122          free(b.p);
123      }
124  }
125  static void tfs_open(fuse_req_t req, fuse_ino_t ino,
126                       struct fuse_file_info *fi) {
127      fi->keep_cache = 1;
128      if (ino == FUSE_ROOT_ID)
129          fuse_reply_err(req, EISDIR);
130      else if ((fi->flags & O_ACCMODE) != O_RDONLY)
131          fuse_reply_err(req, EACCES);
132      else if (ino == FILE_INO)
<span onclick='openModal()' class='match'>133          fuse_reply_open(req, fi);
134      else {
135          fprintf(stderr, "Got open for non-existing inode!\n");
136          fuse_reply_err(req, ENOENT);
137      }
138  }
</span>139  static void tfs_read(fuse_req_t req, fuse_ino_t ino, size_t size,
140                       off_t off, struct fuse_file_info *fi) {
141      (void) fi;
142      assert(ino == FILE_INO);
143      reply_buf_limited(req, file_contents, file_size, off, size);
144  }
145  static const struct fuse_lowlevel_ops tfs_oper = {
146      .lookup	= tfs_lookup,
147      .getattr	= tfs_getattr,
148      .readdir	= tfs_readdir,
149      .open	= tfs_open,
150      .read	= tfs_read,
151      .forget     = tfs_forget,
152  };
153  static void update_fs(void) {
154      struct tm *now;
155      time_t t;
156      t = time(NULL);
157      now = localtime(&t);
158      assert(now != NULL);
159      file_size = strftime(file_contents, MAX_STR_LEN,
160                           "The current time is %H:%M:%S\n", now);
161      assert(file_size != 0);
162  }
163  static void* update_fs_loop(void *data) {
164      struct fuse_session *se = (struct fuse_session*) data;
165      while(1) {
166          update_fs();
167          if (!options.no_notify && lookup_cnt) {
168              assert(fuse_lowlevel_notify_inval_inode
169                     (se, FILE_INO, 0, 0) == 0);
170          }
171          sleep(options.update_interval);
172      }
173      return NULL;
174  }
175  static void show_help(const char *progname)
176  {
177      printf("usage: %s [options] <mountpoint>\n\n", progname);
178      printf("File-system specific options:\n"
179                 "    --update-interval=<secs>  Update-rate of file system contents\n"
180                 "    --no-notify            Disable kernel notifications\n"
181                 "\n");
182  }
183  int main(int argc, char *argv[]) {
184      struct fuse_args args = FUSE_ARGS_INIT(argc, argv);
185      struct fuse_session *se;
186      struct fuse_cmdline_opts opts;
187      struct fuse_loop_config config;
188      pthread_t updater;
189      int ret = -1;
190      if (fuse_opt_parse(&args, &options, option_spec, NULL) == -1)
191          return 1;
192      if (fuse_parse_cmdline(&args, &opts) != 0) {
193          ret = 1;
194          goto err_out1;
195      }
196      if (opts.show_help) {
197          show_help(argv[0]);
198          fuse_cmdline_help();
199          fuse_lowlevel_help();
200          ret = 0;
201          goto err_out1;
202      } else if (opts.show_version) {
203          printf("FUSE library version %s\n", fuse_pkgversion());
204          fuse_lowlevel_version();
205          ret = 0;
206          goto err_out1;
207      }
208      update_fs();
209      se = fuse_session_new(&args, &tfs_oper,
210                            sizeof(tfs_oper), NULL);
211      if (se == NULL)
212          goto err_out1;
213      if (fuse_set_signal_handlers(se) != 0)
214          goto err_out2;
215      if (fuse_session_mount(se, opts.mountpoint) != 0)
216          goto err_out3;
217      fuse_daemonize(opts.foreground);
218      ret = pthread_create(&updater, NULL, update_fs_loop, (void *)se);
219      if (ret != 0) {
220          fprintf(stderr, "pthread_create failed with %s\n",
221                  strerror(ret));
222          goto err_out3;
223      }
224      if (opts.singlethread)
225          ret = fuse_session_loop(se);
226      else {
227          config.clone_fd = opts.clone_fd;
228          config.max_idle_threads = opts.max_idle_threads;
229          ret = fuse_session_loop_mt(se, &config);
230      }
231      fuse_session_unmount(se);
232  err_out3:
233      fuse_remove_signal_handlers(se);
234  err_out2:
235      fuse_session_destroy(se);
236  err_out1:
237      fuse_opt_free_args(&args);
238      free(opts.mountpoint);
239      return ret ? 1 : 0;
240  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from libfuse-MDEwOlJlcG9zaXRvcnk0ODI5NjE3Nw==-flat-mount.fuse.c</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from libfuse-MDEwOlJlcG9zaXRvcnk0ODI5NjE3Nw==-flat-notify_inval_inode.c</div>
                </div>
                <div class="column column_space"><pre><code>90  		strcpy(options, opt);
91  	else {
92  		strcat(options, ",");
93  		strcat(options, opt);
94  	}
95  	return options;
</pre></code></div>
                <div class="column column_space"><pre><code>133          fuse_reply_open(req, fi);
134      else {
135          fprintf(stderr, "Got open for non-existing inode!\n");
136          fuse_reply_err(req, ENOENT);
137      }
138  }
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    