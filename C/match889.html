<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for vector.c &amp; wall_util.c</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for vector.c &amp; wall_util.c
      </h3>
<h1 align="center">
        7.3%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>vector.c (21.288013%)<th>wall_util.c (4.433681%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(190-217)<td><a href="#" name="0">(1269-1307)</a><td align="center"><font color="#ff0000">26</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(163-183)<td><a href="#" name="1">(398-423)</a><td align="center"><font color="#c40000">20</font>
<tr onclick='openModal("#980517")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#980517"><font color="#980517">-</font><td><a href="#" name="2">(319-335)<td><a href="#" name="2">(1116-1136)</a><td align="center"><font color="#9c0000">16</font>
<tr onclick='openModal("#53858b")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#53858b"><font color="#53858b">-</font><td><a href="#" name="3">(220-239)<td><a href="#" name="3">(889-909)</a><td align="center"><font color="#9c0000">16</font>
<tr onclick='openModal("#6cc417")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#6cc417"><font color="#6cc417">-</font><td><a href="#" name="4">(72-87)<td><a href="#" name="4">(1243-1262)</a><td align="center"><font color="#930000">15</font>
<tr onclick='openModal("#151b8d")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#151b8d"><font color="#151b8d">-</font><td><a href="#" name="5">(302-315)<td><a href="#" name="5">(779-796)</a><td align="center"><font color="#890000">14</font>
<tr onclick='openModal("#8c8774")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#8c8774"><font color="#8c8774">-</font><td><a href="#" name="6">(750-759)<td><a href="#" name="6">(1684-1699)</a><td align="center"><font color="#750000">12</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>vector.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 #include "config.h"
2 #include &lt;math.h&gt;
3 #include &lt;float.h&gt;
4 #include "vector.h"
5 #include "mcell_structs.h"
6 #define MY_PI 3.14159265358979323846
7 void mult_matrix(double (*m1)[4], double (*m2)[4], double (*om)[4],
8                  short unsigned int l, short unsigned int m,
9                  short unsigned int n) {
10   double tm[4][4];
11   unsigned short i, j, k;
12   for (i = 0; i &lt; l; i++) {
13     for (j = 0; j &lt; n; j++) {
14       tm[i][j] = 0;
15       for (k = 0; k &lt; m; k++) {
16         tm[i][j] = tm[i][j] + (m1[i][k]) * (m2[k][j]);
17       }
18     }
19   }
20   for (i = 0; i &lt; l; i++) {
21     for (j = 0; j &lt; n; j++) {
22       om[i][j] = tm[i][j];
23     }
24   }
25 }
26 void normalize(struct vector3 *v) {
27   double length;
28   length = vect_length(v);
29   v-&gt;x = v-&gt;x / length;
30   v-&gt;y = v-&gt;y / length;
31   v-&gt;z = v-&gt;z / length;
32 }
33 <font color="#6cc417"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>void init_matrix(double (*im)[4]) {
34   im[0][0] = 1;
35   im[0][1] = 0;
36   im[0][2] = 0;
37   im[0][3] = 0;
38   im[1][0] = 0;
39   im[1][1] = 1;
40   im[1][2] = 0;
41   im[1][3] = 0;
42   im[2][0] = 0;
43   im[2][1] = 0;
44   im[2][2] = 1;
45   im[2][3] = 0;
46   im[3][0] = 0;
47   im[3][1] = 0;</b></font>
48   im[3][2] = 0;
49   im[3][3] = 1;
50 }
51 void scale_matrix(double (*im)[4], double (*om)[4], struct vector3 *scale) {
52   double sc[4][4];
53   unsigned short l, m, n;
54   sc[0][0] = scale-&gt;x;
55   sc[0][1] = 0;
56   sc[0][2] = 0;
57   sc[0][3] = 0;
58   sc[1][0] = 0;
59   sc[1][1] = scale-&gt;y;
60   sc[1][2] = 0;
61   sc[1][3] = 0;
62   sc[2][0] = 0;
63   sc[2][1] = 0;
64   sc[2][2] = scale-&gt;z;
65   sc[2][3] = 0;
66   sc[3][0] = 0;
67   sc[3][1] = 0;
68   sc[3][2] = 0;
69   sc[3][3] = 1;
70   l = 4;
71   m = 4;
72   n = 4;
73   mult_matrix(im, sc, om, l, m, n);
74 }
75 void translate_matrix(double (*im)[4], double (*om)[4],
76                       struct vector3 *translate) {
77   double tm[4][4];
78   unsigned short l, m, n;
79   tm[0][0] = 1;
80   tm[0][1] = 0;
81   tm[0][2] = 0;
82   tm[0][3] = 0;
83   tm[1][0] = 0;
84   tm[1][1] = 1;
85   tm[1][2] = 0;
86   tm[1][3] = 0;
87   tm[2][0] = 0;
88   tm[2][1] = 0;
89   tm[2][2] = 1;
90   tm[2][3] = 0;
91   tm[3][0] = translate-&gt;x;
92   tm[3][1] = translate-&gt;y;
93   tm[3][2] = translate-&gt;z;
94   tm[3][3] = 1;
95   l = 4;
96   m = 4;
97   n = 4;
98   mult_matrix(im, tm, om, l, m, n);
99 }
100 void rotate_matrix(double (*im)[4], double (*om)[4], struct vector3 *axis,
101                    double angle) {
102   double r1[4][4], r2[4][4], r3[4][4], rm[4][4];
103   double a, b, c, v;
104   double rad;
105 <a name="1"></a>  unsigned short l, m, n;
106   normalize(axis);
107 <font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>  a = axis-&gt;x;
108   b = axis-&gt;y;
109   c = axis-&gt;z;
110   v = sqrt(b * b + c * c);
111   r1[0][0] = 1;
112   r1[0][1] = 0;
113   r1[0][2] = 0;
114   r1[0][3] = 0;
115   r1[1][0] = 0;
116   r1[1][1] = 1;
117   r1[1][2] = 0;
118   r1[1][3] = 0;
119   r1[2][0] = 0;
120   r1[2][1] = 0;
121   r1[2][2] = 1;
122   r1[2][3] = 0;
123   r1[3][0] = 0;
124   r1[3][1] = 0;
125   r1[3][2] = 0;
126   r1[3][3] = 1;</b></font>
127   if (v != 0.0) {
128     r1[1][1] = c / v;
129 <a name="0"></a>    r1[1][2] = b / v;
130     r1[2][1] = -b / v;
131     r1[2][2] = c / v;
132 <font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>  }
133   r2[0][0] = v;
134   r2[0][1] = 0;
135   r2[0][2] = a;
136   r2[0][3] = 0;
137   r2[1][0] = 0;
138   r2[1][1] = 1;
139   r2[1][2] = 0;
140   r2[1][3] = 0;
141   r2[2][0] = -a;
142   r2[2][1] = 0;
143   r2[2][2] = v;
144   r2[2][3] = 0;
145   r2[3][0] = 0;
146   r2[3][1] = 0;
147   r2[3][2] = 0;
148   r2[3][3] = 1;
149   rad = MY_PI / 180.0;
150   r3[0][0] = cos(angle * rad);
151   r3[0][1] = sin(angle * rad);
152   r3[0][2] = 0;
153   r3[0][3] = 0;
154   r3[1][0] = -sin(angle * rad);
155   r3[1][1] = cos(angle * rad);
156   r3[1][2] = 0;
157 <a name="3"></a>  r3[1][3] = 0;</b></font>
158   r3[2][0] = 0;
159   r3[2][1] = 0;
160 <font color="#53858b"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>  r3[2][2] = 1;
161   r3[2][3] = 0;
162   r3[3][0] = 0;
163   r3[3][1] = 0;
164   r3[3][2] = 0;
165   r3[3][3] = 1;
166   l = 4;
167   m = 4;
168   n = 4;
169   mult_matrix(r1, r2, rm, l, m, n);
170   mult_matrix(rm, r3, rm, l, m, n);
171   r2[0][2] = -a;
172   r2[2][0] = a;
173   if (v != 0.0) {
174     r1[1][2] = -b / v;
175     r1[2][1] = b / v;
176   }</b></font>
177   mult_matrix(rm, r2, rm, l, m, n);
178   mult_matrix(rm, r1, rm, l, m, n);
179   mult_matrix(im, rm, om, l, m, n);
180 }
181 void tform_matrix(struct vector3 *scale, struct vector3 *translate,
182                   struct vector3 *axis, double angle, double (*om)[4]) {
183   double sc[4][4];
184   double tm[4][4];
185   double r1[4][4], r2[4][4], r3[4][4];
186   double a, b, c, v;
187   double rad;
188   unsigned short l, m, n;
189   init_matrix(om);
190   sc[0][0] = scale-&gt;x;
191   sc[0][1] = 0;
192   sc[0][2] = 0;
193   sc[0][3] = 0;
194   sc[1][0] = 0;
195   sc[1][1] = scale-&gt;y;
196   sc[1][2] = 0;
197   sc[1][3] = 0;
198   sc[2][0] = 0;
199   sc[2][1] = 0;
200   sc[2][2] = scale-&gt;z;
201   sc[2][3] = 0;
202   sc[3][0] = 0;
203   sc[3][1] = 0;
204   sc[3][2] = 0;
205   sc[3][3] = 1;
206   tm[0][0] = 1;
207   tm[0][1] = 0;
208   tm[0][2] = 0;
209   tm[0][3] = 0;
210   tm[1][0] = 0;
211   tm[1][1] = 1;
212   tm[1][2] = 0;
213   tm[1][3] = 0;
214   tm[2][0] = 0;
215   tm[2][1] = 0;
216   tm[2][2] = 1;
217   tm[2][3] = 0;
218   tm[3][0] = translate-&gt;x;
219   tm[3][1] = translate-&gt;y;
220   tm[3][2] = translate-&gt;z;
221   tm[3][3] = 1;
222   normalize(axis);
223   a = axis-&gt;x;
224   b = axis-&gt;y;
225   c = axis-&gt;z;
226   v = sqrt(b * b + c * c);
227   r1[0][0] = 1;
228   r1[0][1] = 0;
229 <a name="5"></a>  r1[0][2] = 0;
230   r1[0][3] = 0;
231   r1[1][0] = 0;
232 <font color="#151b8d"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>  r1[1][1] = 1;
233   r1[1][2] = 0;
234   r1[1][3] = 0;
235   r1[2][0] = 0;
236   r1[2][1] = 0;
237   r1[2][2] = 1;
238   r1[2][3] = 0;
239   r1[3][0] = 0;
240   r1[3][1] = 0;
241   r1[3][2] = 0;
242   r1[3][3] = 1;
243   if (v != 0.0) {
244     r1[1][1] = c / v;</b></font>
245 <a name="2"></a>    r1[1][2] = b / v;
246     r1[2][1] = -b / v;
247     r1[2][2] = c / v;
248 <font color="#980517"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>  }
249   r2[0][0] = v;
250   r2[0][1] = 0;
251   r2[0][2] = a;
252   r2[0][3] = 0;
253   r2[1][0] = 0;
254   r2[1][1] = 1;
255   r2[1][2] = 0;
256   r2[1][3] = 0;
257   r2[2][0] = -a;
258   r2[2][1] = 0;
259   r2[2][2] = v;
260   r2[2][3] = 0;
261   r2[3][0] = 0;
262   r2[3][1] = 0;
263   r2[3][2] = 0;</b></font>
264   r2[3][3] = 1;
265   rad = MY_PI / 180.0;
266   r3[0][0] = cos(angle * rad);
267   r3[0][1] = sin(angle * rad);
268   r3[0][2] = 0;
269   r3[0][3] = 0;
270   r3[1][0] = -sin(angle * rad);
271   r3[1][1] = cos(angle * rad);
272   r3[1][2] = 0;
273   r3[1][3] = 0;
274   r3[2][0] = 0;
275   r3[2][1] = 0;
276   r3[2][2] = 1;
277   r3[2][3] = 0;
278   r3[3][0] = 0;
279   r3[3][1] = 0;
280   r3[3][2] = 0;
281   r3[3][3] = 1;
282   l = 4;
283   m = 4;
284   n = 4;
285   mult_matrix(r1, r2, om, l, m, n);
286   mult_matrix(om, r3, om, l, m, n);
287   r2[0][2] = -a;
288   r2[2][0] = a;
289   if (v != 0.0) {
290     r1[1][2] = -b / v;
291     r1[2][1] = b / v;
292   }
293   mult_matrix(om, r2, om, l, m, n);
294   mult_matrix(om, r1, om, l, m, n);
295   mult_matrix(om, sc, om, l, m, n);
296   mult_matrix(om, tm, om, l, m, n);
297 }
298 void vectorize(struct vector3 *p1, struct vector3 *p2, struct vector3 *v) {
299   v-&gt;x = p2-&gt;x - p1-&gt;x;
300   v-&gt;y = p2-&gt;y - p1-&gt;y;
301   v-&gt;z = p2-&gt;z - p1-&gt;z;
302 }
303 double vect_length(struct vector3 *v) {
304   double length;
305   length = sqrt((v-&gt;x) * (v-&gt;x) + (v-&gt;y) * (v-&gt;y) + (v-&gt;z) * (v-&gt;z));
306   return (length);
307 }
308 double dot_prod(struct vector3 *v1, struct vector3 *v2) {
309   double dot;
310   dot = (v1-&gt;x) * (v2-&gt;x) + (v1-&gt;y) * (v2-&gt;y) + (v1-&gt;z) * (v2-&gt;z);
311   return (dot);
312 }
313 void cross_prod(struct vector3 *v1, struct vector3 *v2, struct vector3 *v3) {
314   v3-&gt;x = (v1-&gt;y) * (v2-&gt;z) - (v1-&gt;z) * (v2-&gt;y);
315   v3-&gt;y = (v1-&gt;z) * (v2-&gt;x) - (v1-&gt;x) * (v2-&gt;z);
316   v3-&gt;z = (v1-&gt;x) * (v2-&gt;y) - (v1-&gt;y) * (v2-&gt;x);
317 }
318 void vect_sum(struct vector3 *v1, struct vector3 *v2, struct vector3 *v3) {
319   v3-&gt;x = v1-&gt;x + v2-&gt;x;
320   v3-&gt;y = v1-&gt;y + v2-&gt;y;
321   v3-&gt;z = v1-&gt;z + v2-&gt;z;
322 }
323 void scalar_prod(struct vector3 *v1, double a, struct vector3 *result) {
324   result-&gt;x = a * v1-&gt;x;
325   result-&gt;y = a * v1-&gt;y;
326   result-&gt;z = a * v1-&gt;z;
327 }
328 int distinguishable_vec3(struct vector3 *a, struct vector3 *b, double eps) {
329   double c, cc, d;
330   c = fabs(a-&gt;x);
331   d = fabs(a-&gt;y);
332   if (d &gt; c)
333     c = d;
334   d = fabs(a-&gt;z);
335   if (d &gt; c)
336     c = d;
337   d = fabs(b-&gt;x);
338   if (d &gt; c)
339     c = d;
340   d = fabs(b-&gt;y);
341   if (d &gt; c)
342     c = d;
343   d = fabs(b-&gt;z);
344   if (d &gt; c)
345     c = d;
346   cc = fabs(a-&gt;x - b-&gt;x);
347   d = fabs(a-&gt;y - b-&gt;y);
348   if (d &gt; cc)
349     cc = d;
350   d = fabs(a-&gt;z - b-&gt;z);
351   if (d &gt; cc)
352     cc = d;
353   if (c &lt; eps)
354     c = eps;
355   return (c * eps &lt; cc);
356 }
357 int distinguishable_vec2(struct vector2 *a, struct vector2 *b, double eps) {
358   double c, cc, d;
359   c = fabs(a-&gt;u);
360   d = fabs(a-&gt;v);
361   if (d &gt; c)
362     c = d;
363   d = fabs(b-&gt;u);
364   if (d &gt; c)
365     c = d;
366   d = fabs(b-&gt;v);
367   if (d &gt; c)
368     c = d;
369   cc = fabs(a-&gt;u - b-&gt;u);
370   d = fabs(a-&gt;v - b-&gt;v);
371   if (d &gt; cc)
372     cc = d;
373   if (c &lt; eps)
374     c = eps;
375   return (c * eps &lt; cc);
376 }
377 double distance_vec3(struct vector3 *a, struct vector3 *b) {
378   double dist;
379   dist = sqrt((a-&gt;x - b-&gt;x) * (a-&gt;x - b-&gt;x) + (a-&gt;y - b-&gt;y) * (a-&gt;y - b-&gt;y) +
380               (a-&gt;z - b-&gt;z) * (a-&gt;z - b-&gt;z));
381   return dist;
382 }
383 int parallel_segments(struct vector3 *A, struct vector3 *B, struct vector3 *R,
384                       struct vector3 *S) {
385   double length;
386   struct vector3 prod;   struct vector3 ba, sr;
387   vectorize(A, B, &amp;ba);
388   vectorize(S, R, &amp;sr);
389   cross_prod(&amp;ba, &amp;sr, &amp;prod);
390   length = vect_length(&amp;prod);
391   if (!distinguishable(length, 0, EPS_C))
392     return 1;
393   return 0;
394 }
395 int same_side(struct vector3 *p1, struct vector3 *p2, struct vector3 *a,
396               struct vector3 *b) {
397   struct vector3 cp1, cp2, b_a, p1_a, p2_a;
398   vectorize(a, b, &amp;b_a);
399   vectorize(a, p1, &amp;p1_a);
400   vectorize(a, p2, &amp;p2_a);
401   cross_prod(&amp;b_a, &amp;p1_a, &amp;cp1);
402   cross_prod(&amp;b_a, &amp;p2_a, &amp;cp2);
403   if (dot_prod(&amp;cp1, &amp;cp2) &gt;= 0) {
404     return 1;
405   } else
406     return 0;
407 }
408 int point_in_triangle(struct vector3 *p, struct vector3 *a, struct vector3 *b,
409                       struct vector3 *c) {
410   if (same_side(p, a, b, c) &amp;&amp; same_side(p, b, a, c) &amp;&amp; same_side(p, c, a, b)) {
411     return 1;
412   }
413   if (((!distinguishable(p-&gt;x, a-&gt;x, EPS_C)) &amp;&amp;
414        (!distinguishable(p-&gt;y, a-&gt;y, EPS_C)) &amp;&amp;
415        (!distinguishable(p-&gt;z, a-&gt;z, EPS_C))) ||
416       ((!distinguishable(p-&gt;x, b-&gt;x, EPS_C)) &amp;&amp;
417        (!distinguishable(p-&gt;y, b-&gt;y, EPS_C)) &amp;&amp;
418        (!distinguishable(p-&gt;z, b-&gt;z, EPS_C))) ||
419       ((!distinguishable(p-&gt;x, c-&gt;x, EPS_C)) &amp;&amp;
420        (!distinguishable(p-&gt;y, c-&gt;y, EPS_C)) &amp;&amp;
421        (!distinguishable(p-&gt;z, c-&gt;z, EPS_C)))) {
422     return 1;
423   }
424   return 0;
425 }
426 #undef MY_PI
427 double cross2D(struct vector2 *a, struct vector2 *b) {
428   return ((a-&gt;v) * (b-&gt;u) - (a-&gt;u) * (b-&gt;v));
429 }
430 void vectorize2D(struct vector2 *p1, struct vector2 *p2, struct vector2 *p3) {
431   p3-&gt;u = p2-&gt;u - p1-&gt;u;
432   p3-&gt;v = p2-&gt;v - p1-&gt;v;
433 }
434 int point_in_triangle_2D(struct vector2 *p, struct vector2 *a,
435                          struct vector2 *b, struct vector2 *c) {
436   struct vector2 p_minus_a, b_minus_a, p_minus_b, c_minus_b, p_minus_c,
437       a_minus_c;
438   double pab, pbc, pca;
439   vectorize2D(a, p, &amp;p_minus_a);
440   vectorize2D(a, b, &amp;b_minus_a);
441   vectorize2D(b, p, &amp;p_minus_b);
442   vectorize2D(b, c, &amp;c_minus_b);
443   vectorize2D(c, p, &amp;p_minus_c);
444   vectorize2D(c, a, &amp;a_minus_c);
445   pab = cross2D(&amp;p_minus_a, &amp;b_minus_a);
446   pbc = cross2D(&amp;p_minus_b, &amp;c_minus_b);
447   if (((pab &gt; 0) &amp;&amp; (pbc &lt; 0)) || ((pab &lt; 0) &amp;&amp; (pbc &gt; 0)))
448     return 0;
449   pca = cross2D(&amp;p_minus_c, &amp;a_minus_c);
450   if (((pab &gt; 0) &amp;&amp; (pca &lt; 0)) || ((pab &lt; 0) &amp;&amp; (pca &gt; 0)))
451     return 0;
452   return 1;
453 }
454 int intersect_point_segment(struct vector3 *P, struct vector3 *A,
455                             struct vector3 *B) {
456   struct vector3 ba, pa;
457   double t;                      double ba_length, pa_length;   double cosine_angle;         
458   if (!distinguishable_vec3(P, A, EPS_C))
459     return 1;
460   if (!distinguishable_vec3(P, B, EPS_C))
461     return 1;
462   vectorize(A, B, &amp;ba);
463   vectorize(A, P, &amp;pa);
464   ba_length = vect_length(&amp;ba);
465   pa_length = vect_length(&amp;pa);
466   cosine_angle = dot_prod(&amp;ba, &amp;pa) / (ba_length * pa_length);
467   if (distinguishable(cosine_angle, 1.0, EPS_C)) {
468     return 0;
469   }
470   t = dot_prod(&amp;pa, &amp;ba) / dot_prod(&amp;ba, &amp;ba);
471   if ((t &gt; 0) &amp;&amp; (t &lt; 1))
472     return 1;
473   return 0;
474 }
475 <font color="#8c8774"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>int point_in_box(struct vector3 *low_left, struct vector3 *up_right,
476                  struct vector3 *point) {
477   if ((up_right-&gt;x &lt; point-&gt;x) || (low_left-&gt;x &gt; point-&gt;x))
478     return 0;
479   if ((up_right-&gt;y &lt; point-&gt;y) || (low_left-&gt;y &gt; point-&gt;y))
480     return 0;
481   if ((up_right-&gt;z &lt; point-&gt;z) || (low_left-&gt;z &gt; point-&gt;z))
482     return 0;
483   return 1;
484 }</b></font>
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>wall_util.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 #include "config.h"
2 #include &lt;math.h&gt;
3 #include &lt;string.h&gt;
4 #include &lt;stdlib.h&gt;
5 #include &lt;assert.h&gt;
6 #include "rng.h"
7 #include "logging.h"
8 #include "vector.h"
9 #include "util.h"
10 #include "init.h"
11 #include "sym_table.h"
12 #include "vol_util.h"
13 #include "mdlparse_util.h"
14 #include "grid_util.h"
15 #include "count_util.h"
16 #include "wall_util.h"
17 #include "react.h"
18 #include "nfsim_func.h"
19 #include "strfunc.h"
20 #include "debug_config.h"
21 #include "dump_state.h"
22 static double tetrahedralVol(struct vector3 *a, struct vector3 *b,
23                              struct vector3 *c, struct vector3 *d) {
24   return 1.0 / 6.0 * (-1 * (a-&gt;z - d-&gt;z) * (b-&gt;y - d-&gt;y) * (c-&gt;x - d-&gt;x) +
25                       (a-&gt;y - d-&gt;y) * (b-&gt;z - d-&gt;z) * (c-&gt;x - d-&gt;x) +
26                       (a-&gt;z - d-&gt;z) * (b-&gt;x - d-&gt;x) * (c-&gt;y - d-&gt;y) -
27                       (a-&gt;x - d-&gt;x) * (b-&gt;z - d-&gt;z) * (c-&gt;y - d-&gt;y) -
28                       (a-&gt;y - d-&gt;y) * (b-&gt;x - d-&gt;x) * (c-&gt;z - d-&gt;z) +
29                       (a-&gt;x - d-&gt;x) * (b-&gt;y - d-&gt;y) * (c-&gt;z - d-&gt;z));
30 }
31 static inline double abs_max_2vec(struct vector3 *v1, struct vector3 *v2) {
32   return max2d(max3d(fabs(v1-&gt;x), fabs(v1-&gt;y), fabs(v1-&gt;z)),
33                max3d(fabs(v2-&gt;x), fabs(v2-&gt;y), fabs(v2-&gt;z)));
34 }
35 static bool have_common_region(struct geom_object *obj, int wall1, int wall2);
36 static int compatible_edges(struct wall **faces, int wA, int eA, int wB,
37                             int eB) {
38   struct vector3 *vA0, *vA1, *vA2, *vB0, *vB1, *vB2;
39   if ((wA &lt; 0) || (eA &lt; 0) || (wB &lt; 0) || (eB &lt; 0))
40     return 0;
41   vA0 = faces[wA]-&gt;vert[eA];
42   if (eA == 2)
43     vA1 = faces[wA]-&gt;vert[0];
44   else
45     vA1 = faces[wA]-&gt;vert[eA + 1];
46   if (eA == 0)
47     vA2 = faces[wA]-&gt;vert[2];
48   else
49     vA2 = faces[wA]-&gt;vert[eA - 1];
50   vB0 = faces[wB]-&gt;vert[eB];
51   if (eB == 2)
52     vB1 = faces[wB]-&gt;vert[0];
53   else
54     vB1 = faces[wB]-&gt;vert[eB + 1];
55   if (eB == 0)
56     vB2 = faces[wB]-&gt;vert[2];
57   else
58     vB2 = faces[wB]-&gt;vert[eB - 1];
59   return ((vA0 == vB1 &amp;&amp; vA1 == vB0 &amp;&amp; vA2 != vB2) ||
60           (vA0-&gt;x == vB1-&gt;x &amp;&amp; vA0-&gt;y == vB1-&gt;y &amp;&amp; vA0-&gt;z == vB1-&gt;z &amp;&amp;
61            vA1-&gt;x == vB0-&gt;x &amp;&amp; vA1-&gt;y == vB0-&gt;y &amp;&amp; vA1-&gt;z == vB0-&gt;z &amp;&amp;
62            !(vA2-&gt;x == vB2-&gt;x &amp;&amp; vA2-&gt;y == vB2-&gt;y &amp;&amp; vA2-&gt;z == vB2-&gt;z)));
63 }
64 bool have_common_region(struct geom_object *obj, int wall1, int wall2) {
65   struct region_list *rl = obj-&gt;regions;
66   bool common_region = false;
67   while (rl != NULL) {
68     struct region *r = rl-&gt;reg;
69     if (strcmp(r-&gt;region_last_name, "ALL") == 0) {
70       rl = rl-&gt;next;
71       continue;
72     }
73     if (get_bit(r-&gt;membership, wall1) &amp;&amp; get_bit(r-&gt;membership, wall2)) {
74       common_region = true;
75       break;
76     }
77     rl = rl-&gt;next;
78   }
79   return common_region;
80 }
81 static void refine_edge_pairs(struct poly_edge *p, struct wall **faces) {
82 #define TSWAP(x, y)                                                            \
83   temp = (x);                                                                  \
84   (x) = (y);                                                                   \
85   (y) = temp
86   int temp;
87   double best_align = 2;
88   bool share_region = false;
89   struct poly_edge *best_p1 = p, *best_p2 = p;
90   int best_n1 = 1;
91   int best_n2 = 2;
92   struct poly_edge *p1 = p;
93   int n1 = 1;
94   while (p1 != NULL &amp;&amp; p1-&gt;n &gt;= n1) {
95     int wA, eA;
96     if (n1 == 1) {
97       wA = p1-&gt;face[0];
98       eA = p1-&gt;edge[0];
99     } else {
100       wA = p1-&gt;face[1];
101       eA = p1-&gt;edge[1];
102     }
103     struct poly_edge *p2;
104     int n2;
105     if (n1 == 1) {
106       n2 = n1 + 1;
107       p2 = p1;
108     } else {
109       n2 = 1;
110       p2 = p1-&gt;next;
111     }
112     while (p2 != NULL &amp;&amp; p2-&gt;n &gt;= n2) {
113       int wB, eB;
114       if (n2 == 1) {
115         wB = p2-&gt;face[0];
116         eB = p2-&gt;edge[0];
117       } else {
118         wB = p2-&gt;face[1];
119         eB = p2-&gt;edge[1];
120       }
121       if (compatible_edges(faces, wA, eA, wB, eB)) {
122         double align = faces[wA]-&gt;normal.x * faces[wB]-&gt;normal.x +
123                        faces[wA]-&gt;normal.y * faces[wB]-&gt;normal.y +
124                        faces[wA]-&gt;normal.z * faces[wB]-&gt;normal.z;
125         bool common_region = have_common_region(faces[wA]-&gt;parent_object, wA, wB);
126         if (common_region) {
127           if (!share_region) {
128             best_align = 2;
129           }
130           share_region = true;
131         }
132         if (common_region || !share_region) {
133           if (align &lt; best_align) {
134             best_p1 = p1;
135             best_p2 = p2;
136             best_n1 = n1;
137             best_n2 = n2;
138             best_align = align;
139           }
140         }
141       } else {
142         break;
143       }
144       if (n2 == 1)
145         n2++;
146       else {
147         p2 = p2-&gt;next;
148         n2 = 1;
149       }
150     }
151     if (n1 == 1)
152       n1++;
153     else {
154       p1 = p1-&gt;next;
155       n1 = 1;
156     }
157   }
158   if (best_align &gt; 1.0)
159     return; 
160   TSWAP(best_p1-&gt;face[best_n1-1], p-&gt;face[0]);
161   TSWAP(best_p1-&gt;edge[best_n1-1], p-&gt;edge[0]);
162   TSWAP(best_p2-&gt;face[best_n2-1], p-&gt;face[1]);
163   TSWAP(best_p2-&gt;edge[best_n2-1], p-&gt;edge[1]);
164 #undef TSWAP
165 }
166 int surface_net(struct wall **facelist, int nfaces) {
167   struct edge *e;
168   int is_closed = 1;
169   struct edge_hashtable eht;
170   int nkeys = (3 * nfaces) / 2;
171   if (ehtable_init(&amp;eht, nkeys))
172     return 1;
173   for (int i = 0; i &lt; nfaces; i++) {
174     if (facelist[i] == NULL)
175       continue;
176     int k;
177     int nedge = 3;
178     for (int j = 0; j &lt; nedge; j++) {
179       if (j + 1 &lt; nedge)
180         k = j + 1;
181       else
182         k = 0;
183       struct poly_edge pe;
184       pe.v1x = facelist[i]-&gt;vert[j]-&gt;x;
185       pe.v1y = facelist[i]-&gt;vert[j]-&gt;y;
186       pe.v1z = facelist[i]-&gt;vert[j]-&gt;z;
187       pe.v2x = facelist[i]-&gt;vert[k]-&gt;x;
188       pe.v2y = facelist[i]-&gt;vert[k]-&gt;y;
189       pe.v2z = facelist[i]-&gt;vert[k]-&gt;z;
190       pe.face[0] = i;
191       pe.edge[0] = j;
192       if (ehtable_add(&amp;eht, &amp;pe))
193         return 1;
194     }
195   }
196   for (int i = 0; i &lt; nkeys; i++) {
197     struct poly_edge *pep = (eht.data + i);
198 #ifdef DEBUG_GEOM_OBJ_INITIALIZATION
199     dump_poly_edge(i, pep);
200 #endif
201     while (pep != NULL) {
202       if (pep-&gt;n &gt; 2) {
203         refine_edge_pairs(pep, facelist);
204       }
205       if (pep-&gt;n &gt;= 2) {
206         if (pep-&gt;face[0] != -1 &amp;&amp; pep-&gt;face[1] != -1) {
207           if (compatible_edges(facelist, pep-&gt;face[0], pep-&gt;edge[0], pep-&gt;face[1],
208                                pep-&gt;edge[1])) {
209             facelist[pep-&gt;face[0]]-&gt;nb_walls[pep-&gt;edge[0]] = facelist[pep-&gt;face[1]];
210             facelist[pep-&gt;face[1]]-&gt;nb_walls[pep-&gt;edge[1]] = facelist[pep-&gt;face[0]];
211             e = (struct edge *)CHECKED_MEM_GET_NODIE(
212                 facelist[pep-&gt;face[0]]-&gt;birthplace-&gt;join, "edge");
213             if (e == NULL)
214               return 1;
215             e-&gt;forward = facelist[pep-&gt;face[0]];
216             e-&gt;backward = facelist[pep-&gt;face[1]];
217             init_edge_transform(e, pep-&gt;edge[0]);
218             facelist[pep-&gt;face[0]]-&gt;edges[pep-&gt;edge[0]] = e;
219             facelist[pep-&gt;face[1]]-&gt;edges[pep-&gt;edge[1]] = e;
220           }
221         } else {
222           is_closed = 0;
223         }
224       } else if (pep-&gt;n == 1) {
225         is_closed = 0;
226         e = (struct edge *)CHECKED_MEM_GET_NODIE(
227             facelist[pep-&gt;face[0]]-&gt;birthplace-&gt;join, "edge");
228         if (e == NULL)
229           return 1;
230         e-&gt;forward = facelist[pep-&gt;face[0]];
231         e-&gt;backward = NULL;
232         facelist[pep-&gt;face[0]]-&gt;edges[pep-&gt;edge[0]] = e;
233       }
234       pep = pep-&gt;next;
235     }
236   }
237   ehtable_kill(&amp;eht);
238   return -is_closed; }
239 void init_edge_transform(struct edge *e, int edgenum) {
240   struct vector2 O_f, O_b;
241   struct vector2 ehat_f, ehat_b;
242   struct vector2 fhat_f, fhat_b;
243   struct wall *wf = e-&gt;forward;
244   struct wall *wb = e-&gt;backward;
245   int i = edgenum;
246   int j = i + 1;
247   if (j &gt; 2)
248     j = 0;
249 #ifdef DEBUG_EDGE_INITIALIZATION
250   std::cout &lt;&lt; "Edge initialization, edgenum: " &lt;&lt; edgenum &lt;&lt; "\n";
251   dump_wall(wf, "", true);
252   dump_wall(wb, "", true);
253 #endif
254   e-&gt;edge_num_used_for_init = edgenum;
255   struct vector3 temp3d;
256   temp3d.x = wf-&gt;vert[i]-&gt;x - wf-&gt;vert[0]-&gt;x;
257   temp3d.y = wf-&gt;vert[i]-&gt;y - wf-&gt;vert[0]-&gt;y;
258   temp3d.z = wf-&gt;vert[i]-&gt;z - wf-&gt;vert[0]-&gt;z;
259   O_f.u = dot_prod(&amp;temp3d, &amp;(wf-&gt;unit_u));
260   O_f.v = dot_prod(&amp;temp3d, &amp;(wf-&gt;unit_v)); 
261   temp3d.x = wf-&gt;vert[j]-&gt;x - wf-&gt;vert[0]-&gt;x;
262   temp3d.y = wf-&gt;vert[j]-&gt;y - wf-&gt;vert[0]-&gt;y;
263   temp3d.z = wf-&gt;vert[j]-&gt;z - wf-&gt;vert[0]-&gt;z;
264   struct vector2 temp;
265   temp.u = dot_prod(&amp;temp3d, &amp;(wf-&gt;unit_u)) - O_f.u;
266 <a name="1"></a>  temp.v = dot_prod(&amp;temp3d, &amp;(wf-&gt;unit_v)) - O_f.v; 
267   assert(temp.u * temp.u + temp.v * temp.v != 0);
268 <font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>  double d = 1.0 / sqrt(temp.u * temp.u + temp.v * temp.v);
269   ehat_f.u = temp.u * d;
270   ehat_f.v = temp.v * d;   fhat_f.u = -ehat_f.v;
271   fhat_f.v = ehat_f.u; 
272   temp3d.x = wf-&gt;vert[i]-&gt;x - wb-&gt;vert[0]-&gt;x;
273   temp3d.y = wf-&gt;vert[i]-&gt;y - wb-&gt;vert[0]-&gt;y;
274   temp3d.z = wf-&gt;vert[i]-&gt;z - wb-&gt;vert[0]-&gt;z;
275   O_b.u = dot_prod(&amp;temp3d, &amp;(wb-&gt;unit_u));
276   O_b.v = dot_prod(&amp;temp3d, &amp;(wb-&gt;unit_v)); 
277   temp3d.x = wf-&gt;vert[j]-&gt;x - wb-&gt;vert[0]-&gt;x;
278   temp3d.y = wf-&gt;vert[j]-&gt;y - wb-&gt;vert[0]-&gt;y;
279   temp3d.z = wf-&gt;vert[j]-&gt;z - wb-&gt;vert[0]-&gt;z;
280   temp.u = dot_prod(&amp;temp3d, &amp;(wb-&gt;unit_u)) - O_b.u;
281   temp.v = dot_prod(&amp;temp3d, &amp;(wb-&gt;unit_v)) - O_b.v; 
282   assert(temp.u * temp.u + temp.v * temp.v != 0);
283   d = 1.0 / sqrt(temp.u * temp.u + temp.v * temp.v);
284   ehat_b.u = temp.u * d;
285   ehat_b.v = temp.v * d;   fhat_b.u = -ehat_b.v;
286   fhat_b.v = ehat_b.u; 
287   double mtx[2][2];
288   mtx[0][0] = ehat_f.u * ehat_b.u + fhat_f.u * fhat_b.u;
289   mtx[0][1] = ehat_f.v * ehat_b.u + fhat_f.v * fhat_b.u;
290   mtx[1][0] = ehat_f.u * ehat_b.v + fhat_f.u * fhat_b.v;
291   mtx[1][1] = ehat_f.v * ehat_b.v + fhat_f.v * fhat_b.v;
292   struct vector2 q;
293   q.u = O_b.u;
294   q.v = O_b.v;
295   q.u -= mtx[0][0] * O_f.u + mtx[0][1] * O_f.v;
296   q.v -= mtx[1][0] * O_f.u + mtx[1][1] * O_f.v;
297   e-&gt;cos_theta = mtx[0][0];
298   e-&gt;sin_theta = mtx[0][1];
299   e-&gt;translate.u = q.u;
300   e-&gt;translate.v = q.v;
301 #ifdef DEBUG_EDGE_INITIALIZATION
302   dump_edge(e, "", true);
303 #endif
304 }
305 int sharpen_object(struct geom_object *parent) {
306   if (parent-&gt;object_type == POLY_OBJ || parent-&gt;object_type == BOX_OBJ) {
307     int i = surface_net(parent-&gt;wall_p, parent-&gt;n_walls);
308     if (i == 1) {
309       mcell_allocfailed(
310           "Failed to connect walls of object %s along shared edges.",
311           parent-&gt;sym-&gt;name);
312     }
313     else {
314       parent-&gt;is_closed = -i; 
315     }
316   } else if (parent-&gt;object_type == META_OBJ) {
317     for (struct geom_object *o = parent-&gt;first_child; o != NULL; o = o-&gt;next) {
318       if (sharpen_object(o))
319         return 1;
320     }
321   }
322   return 0;
323 }
324 int sharpen_world(struct volume *world) {
325   for (struct geom_object *o = world-&gt;root_instance; o != NULL; o = o-&gt;next) {
326     if (sharpen_object(o))
327       return 1;
328   }
329   return 0;
330 }
331 double closest_interior_point(struct vector3 *pt, struct wall *w,
332                               struct vector2 *ip, double r2) {
333   UNUSED(r2);
334 #ifdef DEBUG_CLOSEST_INTERIOR_POINT
335   std::cout &lt;&lt; "closest_interior_point: " &lt;&lt; *pt &lt;&lt; "\n";
336   dump_wall(w, "", true);
337 #endif
338   struct vector3 v;
339   closest_pt_point_triangle(pt, w-&gt;vert[0], w-&gt;vert[1], w-&gt;vert[2], &amp;v);
340   xyz2uv(&amp;v, w, ip);
341   int give_up_ctr = 0;
342   int give_up = 10;
343   double a1 = ip-&gt;u * w-&gt;uv_vert2.v - ip-&gt;v * w-&gt;uv_vert2.u;
344   double a2 = w-&gt;uv_vert1_u * ip-&gt;v;
345   struct vector2 vert_0 = {0, 0};
346   struct vector2 vert_1 = {w-&gt;uv_vert1_u, 0};
347   while (give_up_ctr &lt; give_up &amp;&amp;
348          (!distinguishable(ip-&gt;v, 0, EPS_C) ||
349           !distinguishable(a1, 0, EPS_C) ||
350           !distinguishable(a1 + a2, 2.0 * w-&gt;area, EPS_C) ||
351           !point_in_triangle_2D(ip, &amp;vert_0, &amp;vert_1, &amp;w-&gt;uv_vert2))) {
352     ip-&gt;u = (1.0 - 5 * EPS_C) * ip-&gt;u +
353             5 * EPS_C * 0.333333333333333 * (w-&gt;uv_vert1_u + w-&gt;uv_vert2.u);
354     ip-&gt;v = (1.0 - 5 * EPS_C) * ip-&gt;v +
355             5 * EPS_C * 0.333333333333333 * w-&gt;uv_vert2.v;
356     a1 = ip-&gt;u * w-&gt;uv_vert2.v - ip-&gt;v * w-&gt;uv_vert2.u;
357     a2 = w-&gt;uv_vert1_u * ip-&gt;v;
358     give_up_ctr++;
359   }
360   double res = (v.x - pt-&gt;x) * (v.x - pt-&gt;x) + (v.y - pt-&gt;y) * (v.y - pt-&gt;y) +
361       (v.z - pt-&gt;z) * (v.z - pt-&gt;z);
362 #ifdef DEBUG_CLOSEST_INTERIOR_POINT
363   std::cout &lt;&lt; "res: " &lt;&lt; res &lt;&lt; ", ip: " &lt;&lt; *ip &lt;&lt; "\n";
364 #endif
365   return res;
366 }
367 int find_edge_point(struct wall *here,
368                     struct vector2 *loc,
369                     struct vector2 *disp,
370                     struct vector2 *edgept) {
371   double f, s, t;
372   double lxd = loc-&gt;u * disp-&gt;v - loc-&gt;v * disp-&gt;u;
373   double lxc1 = -loc-&gt;v * here-&gt;uv_vert1_u;
374   double dxc1 = -disp-&gt;v * here-&gt;uv_vert1_u;
375   if (dxc1 &lt; -EPS_C || dxc1 &gt; EPS_C) {
376     f = 1.0 / dxc1;     s = -lxd * f;
377     if (0.0 &lt; s &amp;&amp; s &lt; 1.0 &amp;&amp; f &gt; 0.0) {
378       t = -lxc1 * f;
379       if (EPS_C &lt; t &amp;&amp; t &lt; 1.0) {
380         edgept-&gt;u = loc-&gt;u + t * disp-&gt;u;
381         edgept-&gt;v = loc-&gt;v + t * disp-&gt;v;
382         return 0;
383       } else if (t &gt; 1.0 + EPS_C)
384         return -1;
385     }
386   }
387   double lxc2 = loc-&gt;u * here-&gt;uv_vert2.v - loc-&gt;v * here-&gt;uv_vert2.u;
388   double dxc2 = disp-&gt;u * here-&gt;uv_vert2.v - disp-&gt;v * here-&gt;uv_vert2.u;
389   if (dxc2 &lt; -EPS_C || dxc2 &gt; EPS_C) {
390     f = 1.0 / dxc2;     s = 1.0 + lxd * f;
391     if (0.0 &lt; s &amp;&amp; s &lt; 1.0 &amp;&amp; f &lt; 0.0) {
392       t = -lxc2 * f;
393       if (EPS_C &lt; t &amp;&amp; t &lt; 1.0) {
394         edgept-&gt;u = loc-&gt;u + t * disp-&gt;u;
395         edgept-&gt;v = loc-&gt;v + t * disp-&gt;v;
396         return 2;
397       } else if (t &gt; 1.0 + EPS_C)
398         return -1;
399     }
400   }
401   f = dxc2 - dxc1;
402   if (f &lt; -EPS_C || f &gt; EPS_C) {
403     f = 1.0 / f;     s = -(lxd + dxc1) * f;
404     if (0.0 &lt; s &amp;&amp; s &lt; 1.0 &amp;&amp; f &gt; 0.0) {
405       t = (here-&gt;uv_vert1_u * here-&gt;uv_vert2.v + lxc1 - lxc2) * f;
406       if (EPS_C &lt; t &amp;&amp; t &lt; 1.0) {
407         edgept-&gt;u = loc-&gt;u + t * disp-&gt;u;
408         edgept-&gt;v = loc-&gt;v + t * disp-&gt;v;
409         return 1;
410       } else if (t &gt; 1.0 + EPS_C)
411         return -1;
412     }
413   }
414 }
415 struct wall *traverse_surface(struct wall *here, struct vector2 *loc, int which,
416   struct vector2 *newloc) {
417   struct wall *there;
418   double u, v;
419   struct edge *e = here-&gt;edges[which];
420   if (e == NULL)
421     return NULL;
422   if (e-&gt;forward == here) {
423     there = e-&gt;backward;
424     u = e-&gt;cos_theta * loc-&gt;u + e-&gt;sin_theta * loc-&gt;v;
425     v = -e-&gt;sin_theta * loc-&gt;u + e-&gt;cos_theta * loc-&gt;v;
426     newloc-&gt;u = u + e-&gt;translate.u;
427     newloc-&gt;v = v + e-&gt;translate.v;
428     return there;
429   } else {
430     there = e-&gt;forward;
431     u = loc-&gt;u - e-&gt;translate.u;
432     v = loc-&gt;v - e-&gt;translate.v;
433     newloc-&gt;u = e-&gt;cos_theta * u - e-&gt;sin_theta * v;
434     newloc-&gt;v = e-&gt;sin_theta * u + e-&gt;cos_theta * v;
435     return there;
436   }
437 }
438 int is_manifold(struct region *r, int count_regions_flag) {
439   struct wall **wall_array = NULL, *w = NULL;
440   struct region_list *rl = NULL;
441   if (r-&gt;bbox == NULL)
442     r-&gt;bbox = create_region_bbox(r);
443   wall_array = r-&gt;parent-&gt;wall_p;
444   if (wall_array == NULL) {
445     mcell_internal_error("Region '%s' has NULL wall array!", r-&gt;sym-&gt;name);
446   }
447   struct vector3 llc = r-&gt;bbox[0];
448   struct vector3 urc = r-&gt;bbox[1];
449   struct vector3 d;
450   d.x = (llc.x + 0.5 * urc.x);
451   d.y = (llc.y + 0.5 * urc.y);
452   d.z = (llc.z + 0.5 * urc.z);
453   r-&gt;volume = 0.0;
454   for (int n_wall = 0; n_wall &lt; r-&gt;parent-&gt;n_walls; n_wall++) {
455     if (!get_bit(r-&gt;membership, n_wall))
456       continue;     w = wall_array[n_wall];
457     if (count_regions_flag) {
458       for (int nb = 0; nb &lt; 3; nb++) {
459         if (w-&gt;nb_walls[nb] == NULL) {
460           mcell_error_nodie("BARE EDGE on wall %u edge %d.", n_wall, nb);
461           return 0;         }
462         for (rl = w-&gt;nb_walls[nb]-&gt;counting_regions; rl != NULL; rl = rl-&gt;next) {
463           if (rl-&gt;reg == r)
464             break;
465         }
466         if (rl == NULL) {
467           mcell_error_nodie("Wall %u edge %d leaves region!", n_wall, nb);
468           return 0;         }
469       }
470     }
471     r-&gt;volume += tetrahedralVol(w-&gt;vert[0], w-&gt;vert[1], w-&gt;vert[2], &amp;d);
472   }
473   return 1;
474 }
475 void jump_away_line(struct vector3 *p, struct vector3 *v, double k,
476                     struct vector3 *A, struct vector3 *B, struct vector3 *n,
477                     struct rng_state *rng) {
478   ASSERT_FOR_MCELL4(false &amp;&amp; "Called jump_away_line");
479 <a name="5"></a>  struct vector3 e, f;
480   double le_1, tiny;
481 <font color="#151b8d"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>  e.x = B-&gt;x - A-&gt;x;
482   e.y = B-&gt;y - A-&gt;y;
483   e.z = B-&gt;z - A-&gt;z;
484   le_1 = 1.0 / sqrt(e.x * e.x + e.y * e.y + e.z * e.z);
485   e.x *= le_1;
486   e.y *= le_1;
487   e.z *= le_1;
488   f.x = n-&gt;y * e.z - n-&gt;z * e.y;
489   f.y = n-&gt;z * e.x - n-&gt;x * e.z;
490   f.z = n-&gt;x * e.y - n-&gt;y * e.x;
491   tiny = EPS_C * (abs_max_2vec(p, v) + 1.0) /
492          (k * max3d(fabs(f.x), fabs(f.y), fabs(f.z)));
493   if ((rng_uint(rng) &amp; 1) == 0) {
494     tiny = -tiny;</b></font>
495   }
496   v-&gt;x -= tiny * f.x;
497   v-&gt;y -= tiny * f.y;
498   v-&gt;z -= tiny * f.z;
499 }
500 int collide_wall(struct vector3 *point, struct vector3 *move, struct wall *face,
501                  double *t, struct vector3 *hitpt, int update_move,
502                  struct rng_state *rng, struct notifications *notify,
503                  long long *ray_polygon_tests) {
504   double dp, dv, dd;
505   double nx, ny, nz;
506   double a, b, c;
507   double f, g, h;
508   double d_eps;
509   struct vector3 local;
510   if (notify-&gt;final_summary == NOTIFY_FULL) {
511     (*ray_polygon_tests)++;
512   }
513   nx = face-&gt;normal.x;
514   ny = face-&gt;normal.y;
515   nz = face-&gt;normal.z;
516   dp = nx * point-&gt;x + ny * point-&gt;y + nz * point-&gt;z;
517   dv = nx * move-&gt;x + ny * move-&gt;y + nz * move-&gt;z;
518   dd = dp - face-&gt;d;
519   if (dd &gt; 0.0) {
520     d_eps = EPS_C;
521     if (dd &lt; d_eps)
522       d_eps = 0.5 * dd;
523     if (dd + dv &gt; d_eps)
524       return COLLIDE_MISS;
525   } else {
526     d_eps = -EPS_C;
527     if (dd &gt; d_eps)
528       d_eps = 0.5 * dd;
529     if (dd &lt; 0.0 &amp;&amp; dd + dv &lt; d_eps)
530       return COLLIDE_MISS;
531   }
532   if (dd == 0.0) {
533     if (dv != 0.0)
534       return COLLIDE_MISS;
535     if (update_move) {
536       a = (abs_max_2vec(point, move) + 1.0) * EPS_C;
537       if ((rng_uint(rng) &amp; 1) == 0)
538         a = -a;
539       if (dd == 0.0) {
540         move-&gt;x -= a * nx;
541         move-&gt;y -= a * ny;
542         move-&gt;z -= a * nz;
543       } else {
544         move-&gt;x *= (1.0 - a);
545         move-&gt;y *= (1.0 - a);
546         move-&gt;z *= (1.0 - a);
547       }
548       return COLLIDE_REDO;
549     } else
550 <a name="3"></a>      return COLLIDE_MISS;
551   }
552 <font color="#53858b"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>  a = 1.0 / dv;
553   a *= -dd;   *t = a;
554   hitpt-&gt;x = point-&gt;x + a * move-&gt;x;
555   hitpt-&gt;y = point-&gt;y + a * move-&gt;y;
556   hitpt-&gt;z = point-&gt;z + a * move-&gt;z;
557   local.x = hitpt-&gt;x - face-&gt;vert[0]-&gt;x;
558   local.y = hitpt-&gt;y - face-&gt;vert[0]-&gt;y;
559   local.z = hitpt-&gt;z - face-&gt;vert[0]-&gt;z;
560   b = local.x * face-&gt;unit_u.x + local.y * face-&gt;unit_u.y +
561       local.z * face-&gt;unit_u.z;
562   c = local.x * face-&gt;unit_v.x + local.y * face-&gt;unit_v.y +
563       local.z * face-&gt;unit_v.z;
564   if (face-&gt;uv_vert2.v &lt; 0.0) {
565     c = -c;
566     f = -face-&gt;uv_vert2.v;
567   } else</b></font>
568     f = face-&gt;uv_vert2.v;
569   if (c &gt; 0) {
570     g = b * f;
571     h = c * face-&gt;uv_vert2.u;
572     if (g &gt; h) {
573       if (c * face-&gt;uv_vert1_u + g &lt; h + face-&gt;uv_vert1_u * face-&gt;uv_vert2.v) {
574         if (dv &gt; 0)
575           return COLLIDE_BACK;
576         else
577           return COLLIDE_FRONT;
578       } else if ((!distinguishable(
579           c * face-&gt;uv_vert1_u + g,
580           h + face-&gt;uv_vert1_u * face-&gt;uv_vert2.v,
581           EPS_C))) {
582         if (update_move) {
583           jump_away_line(point, move, a, face-&gt;vert[1], face-&gt;vert[2],
584                          &amp;(face-&gt;normal), rng);
585           return COLLIDE_REDO;
586         } else
587           return COLLIDE_MISS;
588       } else
589         return COLLIDE_MISS;
590     } else if (!distinguishable(g, h, EPS_C)) {
591       if (update_move) {
592         jump_away_line(point, move, a, face-&gt;vert[2], face-&gt;vert[0],
593                        &amp;(face-&gt;normal), rng);
594         return COLLIDE_REDO;
595       } else
596         return COLLIDE_MISS;
597     } else
598       return COLLIDE_MISS;
599   } else if (!distinguishable(c, 0, EPS_C))   {
600     if (update_move) {
601       jump_away_line(point, move, a, face-&gt;vert[0], face-&gt;vert[1],
602                      &amp;(face-&gt;normal), rng);
603       return COLLIDE_REDO;
604     } else
605       return COLLIDE_MISS;
606   } else
607     return COLLIDE_MISS;
608 }
609 int collide_mol(struct vector3 *point, struct vector3 *move,
610                 struct abstract_molecule *a, double *t, struct vector3 *hitpt,
611                 double rx_radius_3d) {
612   struct vector3 dir;    struct vector3 *pos; 
613   double movelen2;   double dirlen2;    double d;          double sigma2;   
614   if ((a-&gt;properties-&gt;flags &amp; ON_GRID) != 0)
615     return COLLIDE_MISS; 
616   pos = &amp;(((struct volume_molecule *)a)-&gt;pos);
617   sigma2 = rx_radius_3d * rx_radius_3d;
618   dir.x = pos-&gt;x - point-&gt;x;
619   dir.y = pos-&gt;y - point-&gt;y;
620   dir.z = pos-&gt;z - point-&gt;z;
621   d = dir.x * move-&gt;x + dir.y * move-&gt;y + dir.z * move-&gt;z;
622   if (d &lt; 0)
623     return COLLIDE_MISS;
624   movelen2 = move-&gt;x * move-&gt;x + move-&gt;y * move-&gt;y + move-&gt;z * move-&gt;z;
625   if (d &gt; movelen2)
626     return COLLIDE_MISS;
627   dirlen2 = dir.x * dir.x + dir.y * dir.y + dir.z * dir.z;
628   if (movelen2 * dirlen2 - d * d &gt; movelen2 * sigma2)
629     return COLLIDE_MISS;
630   *t = d / movelen2;
631   hitpt-&gt;x = point-&gt;x + (*t) * move-&gt;x;
632   hitpt-&gt;y = point-&gt;y + (*t) * move-&gt;y;
633   hitpt-&gt;z = point-&gt;z + (*t) * move-&gt;z;
634   return COLLIDE_VOL_M;
635 }
636 static int wall_in_box(struct vector3 **vert, struct vector3 *normal, double d,
637                        struct vector3 *b0, struct vector3 *b1) {
638 #define n_vert 3
639   int temp;
640   int i, j, k;
641   struct vector3 *v1, *v2;
642   struct vector3 n, u, v;
643   struct vector3 ba, bb, c;
644   double r, a1, a2, a3, a4, cu, cv;
645   double vu_[6];   double *vv_;
646   double d_box[8];
647   int n_opposite;
648   int which_x1[12] = { 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 1 };
649   int which_y1[12] = { 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 1, 0 };
650   int which_z1[12] = { 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0 };
651   int which_x2[12] = { 0, 0, 0, 1, 1, 1, 1, 0, 0, 1, 1, 0 };
652   int which_y2[12] = { 0, 1, 1, 1, 1, 0, 0, 0, 1, 0, 1, 1 };
653   int which_z2[12] = { 1, 1, 0, 0, 1, 1, 0, 0, 0, 1, 1, 0 };
654   int edge1_vt[12] = { 0, 1, 3, 2, 6, 7, 5, 4, 0, 1, 3, 4 };
655   int edge2_vt[12] = { 1, 3, 2, 6, 7, 5, 4, 0, 2, 5, 7, 2 };
656   for (i = 0; i &lt; n_vert; i++) {
657     v2 = vert[i];
658     if (v2-&gt;x &gt;= b0-&gt;x &amp;&amp; v2-&gt;x &lt;= b1-&gt;x &amp;&amp; v2-&gt;y &gt;= b0-&gt;y &amp;&amp; v2-&gt;y &lt;= b1-&gt;y &amp;&amp;
659         v2-&gt;z &gt;= b0-&gt;z &amp;&amp; v2-&gt;z &lt;= b1-&gt;z)
660       return 1;
661   }
662   for (i = 0; i &lt; n_vert; i++) {
663     v2 = vert[i];
664     v1 = (i == 0) ? vert[n_vert - 1] : vert[i - 1];
665     if ((v1-&gt;x &lt;= b0-&gt;x &amp;&amp; b0-&gt;x &lt; v2-&gt;x) ||
666         (v1-&gt;x &gt; b0-&gt;x &amp;&amp; b0-&gt;x &gt;= v2-&gt;x)) {
667       r = (b0-&gt;x - v1-&gt;x) / (v2-&gt;x - v1-&gt;x);
668       a3 = v1-&gt;y + r * (v2-&gt;y - v1-&gt;y);
669       a4 = v1-&gt;z + r * (v2-&gt;z - v1-&gt;z);
670       if (b0-&gt;y &lt;= a3 &amp;&amp; a3 &lt;= b1-&gt;y &amp;&amp; b0-&gt;z &lt;= a4 &amp;&amp; a4 &lt;= b1-&gt;z)
671         return 2;
672     }
673     if ((v1-&gt;x &lt;= b1-&gt;x &amp;&amp; b1-&gt;x &lt; v2-&gt;x) ||
674         (v1-&gt;x &gt; b1-&gt;x &amp;&amp; b1-&gt;x &gt;= v2-&gt;x)) {
675       r = (b1-&gt;x - v1-&gt;x) / (v2-&gt;x - v1-&gt;x);
676       a3 = v1-&gt;y + r * (v2-&gt;y - v1-&gt;y);
677       a4 = v1-&gt;z + r * (v2-&gt;z - v1-&gt;z);
678       if (b0-&gt;y &lt;= a3 &amp;&amp; a3 &lt;= b1-&gt;y &amp;&amp; b0-&gt;z &lt;= a4 &amp;&amp; a4 &lt;= b1-&gt;z)
679         return 3;
680     }
681     if ((v1-&gt;y &lt;= b0-&gt;y &amp;&amp; b0-&gt;y &lt; v2-&gt;y) ||
682         (v1-&gt;y &gt; b0-&gt;y &amp;&amp; b0-&gt;y &gt;= v2-&gt;y)) {
683       r = (b0-&gt;y - v1-&gt;y) / (v2-&gt;y - v1-&gt;y);
684       a3 = v1-&gt;x + r * (v2-&gt;x - v1-&gt;x);
685       a4 = v1-&gt;z + r * (v2-&gt;z - v1-&gt;z);
686       if (b0-&gt;x &lt;= a3 &amp;&amp; a3 &lt;= b1-&gt;x &amp;&amp; b0-&gt;z &lt;= a4 &amp;&amp; a4 &lt;= b1-&gt;z)
687         return 4;
688     }
689     if ((v1-&gt;y &lt;= b1-&gt;y &amp;&amp; b1-&gt;y &lt; v2-&gt;y) ||
690         (v1-&gt;y &gt; b1-&gt;y &amp;&amp; b1-&gt;y &gt;= v2-&gt;y)) {
691       r = (b1-&gt;y - v1-&gt;y) / (v2-&gt;y - v1-&gt;y);
692       a3 = v1-&gt;x + r * (v2-&gt;x - v1-&gt;x);
693       a4 = v1-&gt;z + r * (v2-&gt;z - v1-&gt;z);
694       if (b0-&gt;x &lt;= a3 &amp;&amp; a3 &lt;= b1-&gt;x &amp;&amp; b0-&gt;z &lt;= a4 &amp;&amp; a4 &lt;= b1-&gt;z)
695         return 5;
696     }
697     if ((v1-&gt;z &lt;= b0-&gt;z &amp;&amp; b0-&gt;z &lt; v2-&gt;z) ||
698         (v1-&gt;z &gt; b0-&gt;z &amp;&amp; b0-&gt;z &gt;= v2-&gt;z)) {
699       r = (b0-&gt;z - v1-&gt;z) / (v2-&gt;z - v1-&gt;z);
700       a3 = v1-&gt;y + r * (v2-&gt;y - v1-&gt;y);
701       a4 = v1-&gt;x + r * (v2-&gt;x - v1-&gt;x);
702       if (b0-&gt;y &lt;= a3 &amp;&amp; a3 &lt;= b1-&gt;y &amp;&amp; b0-&gt;x &lt;= a4 &amp;&amp; a4 &lt;= b1-&gt;x)
703         return 6;
704     }
705     if ((v1-&gt;z &lt;= b1-&gt;z &amp;&amp; b1-&gt;z &lt; v2-&gt;z) ||
706         (v1-&gt;z &gt; b1-&gt;z &amp;&amp; b1-&gt;z &gt;= v2-&gt;z)) {
707       r = (b1-&gt;z - v1-&gt;z) / (v2-&gt;z - v1-&gt;z);
708       a3 = v1-&gt;y + r * (v2-&gt;y - v1-&gt;y);
709       a4 = v1-&gt;x + r * (v2-&gt;x - v1-&gt;x);
710 <a name="2"></a>      if (b0-&gt;y &lt;= a3 &amp;&amp; a3 &lt;= b1-&gt;y &amp;&amp; b0-&gt;x &lt;= a4 &amp;&amp; a4 &lt;= b1-&gt;x)
711         return 7;
712     }
713 <font color="#980517"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>  }
714   n_opposite = 0;
715   vv_ = &amp;(vu_[n_vert]);
716   n.x = normal-&gt;x;
717   n.y = normal-&gt;y;
718   n.z = normal-&gt;z;
719   u.x = vert[1]-&gt;x - vert[0]-&gt;x;
720   u.y = vert[1]-&gt;y - vert[0]-&gt;y;
721   u.z = vert[1]-&gt;z - vert[0]-&gt;z;
722   r = 1 / sqrt(u.x * u.x + u.y * u.y + u.z * u.z);
723   u.x *= r;
724   u.y *= r;
725   u.z *= r;
726   v.x = n.y * u.z - n.z * u.y;
727   v.y = -(n.x * u.z - n.z * u.x);
728   v.z = n.x * u.y - n.y * u.x;</b></font>
729   for (j = 0; j &lt; n_vert; j++) {
730     vu_[j] = vert[j]-&gt;x * u.x + vert[j]-&gt;y * u.y + vert[j]-&gt;z * u.z;
731     vv_[j] = vert[j]-&gt;x * v.x + vert[j]-&gt;y * v.y + vert[j]-&gt;z * v.z;
732   }
733   bb.x = b0-&gt;x;
734   bb.y = b0-&gt;y;
735   bb.z = b0-&gt;z;
736   d_box[0] = bb.x * n.x + bb.y * n.y + bb.z * n.z;
737   for (i = 0; i &lt; 12; i++) {
738     if (i &lt; 7)     {
739       ba.x = bb.x;
740       ba.y = bb.y;
741       ba.z = bb.z;
742       bb.x = (which_x2[i]) ? b1-&gt;x : b0-&gt;x;
743       bb.y = (which_y2[i]) ? b1-&gt;y : b0-&gt;y;
744       bb.z = (which_z2[i]) ? b1-&gt;z : b0-&gt;z;
745       a2 = d_box[edge2_vt[i]] = bb.x * n.x + bb.y * n.y + bb.z * n.z;
746       a1 = d_box[edge1_vt[i]];
747       if ((a1 - d &lt; 0 &amp;&amp; a2 - d &lt; 0) || (a1 - d &gt; 0 &amp;&amp; a2 - d &gt; 0))
748         continue;
749       else
750         n_opposite++;
751     } else     {
752       a1 = d_box[edge1_vt[i]];
753       a2 = d_box[edge2_vt[i]];
754       if ((a1 - d &lt; 0 &amp;&amp; a2 - d &lt; 0) || (a1 - d &gt; 0 &amp;&amp; a2 - d &gt; 0))
755         continue;
756       n_opposite++;
757       ba.x = (which_x1[i]) ? b1-&gt;x : b0-&gt;x;
758       ba.y = (which_y1[i]) ? b1-&gt;y : b0-&gt;y;
759       ba.z = (which_z1[i]) ? b1-&gt;z : b0-&gt;z;
760       bb.x = (which_x2[i]) ? b1-&gt;x : b0-&gt;x;
761       bb.y = (which_y2[i]) ? b1-&gt;y : b0-&gt;y;
762       bb.z = (which_z2[i]) ? b1-&gt;z : b0-&gt;z;
763     }
764     r = (d - a1) / (a2 - a1);
765     c.x = ba.x + r * (bb.x - ba.x);
766     c.y = ba.y + r * (bb.y - ba.y);
767     c.z = ba.z + r * (bb.z - ba.z);
768     cu = c.x * u.x + c.y * u.y + c.z * u.z;
769     cv = c.x * v.x + c.y * v.y + c.z * v.z;
770     temp = 0;
771     for (j = 0; j &lt; n_vert; j++) {
772       k = (j == 0) ? n_vert - 1 : j - 1;
773       if ((vu_[k] &lt; cu &amp;&amp; cu &lt;= vu_[j]) || (vu_[k] &gt;= cu &amp;&amp; cu &gt; vu_[j])) {
774         r = (cu - vu_[k]) / (vu_[j] - vu_[k]);
775         if ((vv_[k] + r * (vv_[j] - vv_[k])) &gt; cv)
776           temp++;
777       }
778     }
779     if (temp &amp; 1)
780       return 8 + i;
781   }
782   return 0;
783 #undef n_vert
784 }
785 void init_tri_wall(struct geom_object *objp, int side, struct vector3 *v0,
786                    struct vector3 *v1, struct vector3 *v2) {
787   struct wall *w;   double f, fx, fy, fz;
788   struct vector3 vA, vB, vX;
789   w = &amp;objp-&gt;walls[side];
790   w-&gt;next = NULL;
791   w-&gt;surf_class_head = NULL;
792   w-&gt;num_surf_classes = 0;
793   w-&gt;side = side;
794   w-&gt;vert[0] = v0;
795   w-&gt;vert[1] = v1;
796   w-&gt;vert[2] = v2;
797   w-&gt;edges[0] = NULL;
798   w-&gt;edges[1] = NULL;
799   w-&gt;edges[2] = NULL;
800   w-&gt;nb_walls[0] = NULL;
801   w-&gt;nb_walls[1] = NULL;
802   w-&gt;nb_walls[2] = NULL;
803   vectorize(v0, v1, &amp;vA);
804   vectorize(v0, v2, &amp;vB);
805 <a name="4"></a>  cross_prod(&amp;vA, &amp;vB, &amp;vX);
806   w-&gt;area = 0.5 * vect_length(&amp;vX);
807 <font color="#6cc417"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>  if (!distinguishable(w-&gt;area, 0, EPS_C)) {
808     w-&gt;unit_u.x = 0;
809     w-&gt;unit_u.y = 0;
810     w-&gt;unit_u.z = 0;
811     w-&gt;normal.x = 0;
812     w-&gt;normal.y = 0;
813     w-&gt;normal.z = 0;
814     w-&gt;unit_v.x = 0;
815     w-&gt;unit_v.y = 0;
816     w-&gt;unit_v.z = 0;
817     w-&gt;d = 0;
818     w-&gt;uv_vert1_u = 0;
819     w-&gt;uv_vert2.u = 0;
820     w-&gt;uv_vert2.v = 0;
821     w-&gt;grid = NULL;</b></font>
822     w-&gt;parent_object = objp;
823     w-&gt;flags = 0;
824 <a name="0"></a>    w-&gt;counting_regions = NULL;
825     return;
826 <font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>  }
827   fx = (v1-&gt;x - v0-&gt;x);
828   fy = (v1-&gt;y - v0-&gt;y);
829   fz = (v1-&gt;z - v0-&gt;z);
830   f = 1 / sqrt(fx * fx + fy * fy + fz * fz);
831   w-&gt;unit_u.x = fx * f;
832   w-&gt;unit_u.y = fy * f;
833   w-&gt;unit_u.z = fz * f;
834   fx = (v2-&gt;x - v0-&gt;x);
835   fy = (v2-&gt;y - v0-&gt;y);
836   fz = (v2-&gt;z - v0-&gt;z);
837   w-&gt;normal.x = w-&gt;unit_u.y * fz - w-&gt;unit_u.z * fy;
838   w-&gt;normal.y = w-&gt;unit_u.z * fx - w-&gt;unit_u.x * fz;
839   w-&gt;normal.z = w-&gt;unit_u.x * fy - w-&gt;unit_u.y * fx;
840   f = 1 / sqrt(w-&gt;normal.x * w-&gt;normal.x + w-&gt;normal.y * w-&gt;normal.y +
841                w-&gt;normal.z * w-&gt;normal.z);
842   w-&gt;normal.x *= f;
843   w-&gt;normal.y *= f;
844   w-&gt;normal.z *= f;
845   w-&gt;unit_v.x = w-&gt;normal.y * w-&gt;unit_u.z - w-&gt;normal.z * w-&gt;unit_u.y;
846   w-&gt;unit_v.y = w-&gt;normal.z * w-&gt;unit_u.x - w-&gt;normal.x * w-&gt;unit_u.z;
847   w-&gt;unit_v.z = w-&gt;normal.x * w-&gt;unit_u.y - w-&gt;normal.y * w-&gt;unit_u.x;
848   w-&gt;d = v0-&gt;x * w-&gt;normal.x + v0-&gt;y * w-&gt;normal.y + v0-&gt;z * w-&gt;normal.z;
849   w-&gt;uv_vert1_u = (w-&gt;vert[1]-&gt;x - w-&gt;vert[0]-&gt;x) * w-&gt;unit_u.x +
850                   (w-&gt;vert[1]-&gt;y - w-&gt;vert[0]-&gt;y) * w-&gt;unit_u.y +
851                   (w-&gt;vert[1]-&gt;z - w-&gt;vert[0]-&gt;z) * w-&gt;unit_u.z;
852   w-&gt;uv_vert2.u = (w-&gt;vert[2]-&gt;x - w-&gt;vert[0]-&gt;x) * w-&gt;unit_u.x +
853                   (w-&gt;vert[2]-&gt;y - w-&gt;vert[0]-&gt;y) * w-&gt;unit_u.y +
854                   (w-&gt;vert[2]-&gt;z - w-&gt;vert[0]-&gt;z) * w-&gt;unit_u.z;
855   w-&gt;uv_vert2.v = (w-&gt;vert[2]-&gt;x - w-&gt;vert[0]-&gt;x) * w-&gt;unit_v.x +
856                   (w-&gt;vert[2]-&gt;y - w-&gt;vert[0]-&gt;y) * w-&gt;unit_v.y +
857                   (w-&gt;vert[2]-&gt;z - w-&gt;vert[0]-&gt;z) * w-&gt;unit_v.z;
858   w-&gt;grid = NULL;</b></font>
859   w-&gt;parent_object = objp;
860   w-&gt;flags = 0;
861   w-&gt;counting_regions = NULL;
862 }
863 static void wall_bounding_box(struct wall *w, struct vector3 *llf,
864                               struct vector3 *urb) {
865   llf-&gt;x = urb-&gt;x = w-&gt;vert[0]-&gt;x;
866   llf-&gt;y = urb-&gt;y = w-&gt;vert[0]-&gt;y;
867   llf-&gt;z = urb-&gt;z = w-&gt;vert[0]-&gt;z;
868   if (w-&gt;vert[1]-&gt;x &lt; llf-&gt;x)
869     llf-&gt;x = w-&gt;vert[1]-&gt;x;
870   else if (w-&gt;vert[1]-&gt;x &gt; urb-&gt;x)
871     urb-&gt;x = w-&gt;vert[1]-&gt;x;
872   if (w-&gt;vert[2]-&gt;x &lt; llf-&gt;x)
873     llf-&gt;x = w-&gt;vert[2]-&gt;x;
874   else if (w-&gt;vert[2]-&gt;x &gt; urb-&gt;x)
875     urb-&gt;x = w-&gt;vert[2]-&gt;x;
876   if (w-&gt;vert[1]-&gt;y &lt; llf-&gt;y)
877     llf-&gt;y = w-&gt;vert[1]-&gt;y;
878   else if (w-&gt;vert[1]-&gt;y &gt; urb-&gt;y)
879     urb-&gt;y = w-&gt;vert[1]-&gt;y;
880   if (w-&gt;vert[2]-&gt;y &lt; llf-&gt;y)
881     llf-&gt;y = w-&gt;vert[2]-&gt;y;
882   else if (w-&gt;vert[2]-&gt;y &gt; urb-&gt;y)
883     urb-&gt;y = w-&gt;vert[2]-&gt;y;
884   if (w-&gt;vert[1]-&gt;z &lt; llf-&gt;z)
885     llf-&gt;z = w-&gt;vert[1]-&gt;z;
886   else if (w-&gt;vert[1]-&gt;z &gt; urb-&gt;z)
887     urb-&gt;z = w-&gt;vert[1]-&gt;z;
888   if (w-&gt;vert[2]-&gt;z &lt; llf-&gt;z)
889     llf-&gt;z = w-&gt;vert[2]-&gt;z;
890   else if (w-&gt;vert[2]-&gt;z &gt; urb-&gt;z)
891     urb-&gt;z = w-&gt;vert[2]-&gt;z;
892 }
893 struct wall_list *wall_to_vol(struct wall *w, struct subvolume *sv) {
894   struct wall_list *wl =
895       (struct wall_list *)CHECKED_MEM_GET_NODIE(sv-&gt;local_storage-&gt;list, "wall list");
896   if (wl == NULL)
897     return NULL;
898   wl-&gt;this_wall = w;
899   wl-&gt;next = sv-&gt;wall_head;
900   sv-&gt;wall_head = wl;
901   return wl;
902 }
903 struct wall *localize_wall(struct wall *w, struct storage *stor) {
904   struct wall *ww;
905   ww = (struct wall *)CHECKED_MEM_GET_NODIE(stor-&gt;face, "wall");
906   if (ww == NULL)
907     return NULL;
908   memcpy(ww, w, sizeof(struct wall));
909   ww-&gt;next = stor-&gt;wall_head;
910   stor-&gt;wall_head = ww;
911   stor-&gt;wall_count++;
912   ww-&gt;birthplace = stor;
913   return ww;
914 }
915 static struct wall *distribute_wall(struct volume *world, struct wall *w) {
916   struct wall *where_am_i;         struct vector3 llf, urb, cent;   int x_max, x_min, y_max, y_min, z_max,
917       z_min;             int h, i, j, k;        double leeway = 1.0; 
918   wall_bounding_box(w, &amp;llf, &amp;urb);
919   if (llf.x &lt; -leeway)
920     leeway = -llf.x;
921   if (llf.y &lt; -leeway)
922     leeway = -llf.y;
923   if (llf.z &lt; -leeway)
924     leeway = -llf.z;
925   if (urb.x &gt; leeway)
926     leeway = urb.x;
927   if (urb.y &gt; leeway)
928     leeway = urb.y;
929   if (urb.z &gt; leeway)
930     leeway = urb.z;
931   leeway = EPS_C + leeway * EPS_C;
932   if (world-&gt;use_expanded_list) {
933     leeway += world-&gt;rx_radius_3d;
934   }
935   llf.x -= leeway;
936   llf.y -= leeway;
937   llf.z -= leeway;
938   urb.x += leeway;
939   urb.y += leeway;
940   urb.z += leeway;
941   cent.x = 0.33333333333 * (w-&gt;vert[0]-&gt;x + w-&gt;vert[1]-&gt;x + w-&gt;vert[2]-&gt;x);
942   cent.y = 0.33333333333 * (w-&gt;vert[0]-&gt;y + w-&gt;vert[1]-&gt;y + w-&gt;vert[2]-&gt;y);
943   cent.z = 0.33333333333 * (w-&gt;vert[0]-&gt;z + w-&gt;vert[1]-&gt;z + w-&gt;vert[2]-&gt;z);
944   x_min = bisect(world-&gt;x_partitions, world-&gt;nx_parts, llf.x);
945   if (urb.x &lt; world-&gt;x_partitions[x_min + 1])
946     x_max = x_min + 1;
947   else
948     x_max = bisect(world-&gt;x_partitions, world-&gt;nx_parts, urb.x) + 1;
949   y_min = bisect(world-&gt;y_partitions, world-&gt;ny_parts, llf.y);
950   if (urb.y &lt; world-&gt;y_partitions[y_min + 1])
951     y_max = y_min + 1;
952   else
953     y_max = bisect(world-&gt;y_partitions, world-&gt;ny_parts, urb.y) + 1;
954   z_min = bisect(world-&gt;z_partitions, world-&gt;nz_parts, llf.z);
955   if (urb.z &lt; world-&gt;z_partitions[z_min + 1])
956     z_max = z_min + 1;
957   else
958     z_max = bisect(world-&gt;z_partitions, world-&gt;nz_parts, urb.z) + 1;
959   if ((z_max - z_min) * (y_max - y_min) * (x_max - x_min) == 1) {
960     h = z_min + (world-&gt;nz_parts - 1) * (y_min + (world-&gt;ny_parts - 1) * x_min);
961     where_am_i = localize_wall(w, world-&gt;subvol[h].local_storage);
962     if (where_am_i == NULL)
963       return NULL;
964     if (wall_to_vol(where_am_i, &amp;(world-&gt;subvol[h])) == NULL)
965       return NULL;
966     return where_am_i;
967   }
968   for (i = x_min; i &lt; x_max; i++) {
969     if (cent.x &lt; world-&gt;x_partitions[i])
970       break;
971   }
972   for (j = y_min; j &lt; y_max; j++) {
973     if (cent.y &lt; world-&gt;y_partitions[j])
974       break;
975   }
976   for (k = z_min; k &lt; z_max; k++) {
977     if (cent.z &lt; world-&gt;z_partitions[k])
978       break;
979   }
980   h = (k - 1) +
981       (world-&gt;nz_parts - 1) * ((j - 1) + (world-&gt;ny_parts - 1) * (i - 1));
982   where_am_i = localize_wall(w, world-&gt;subvol[h].local_storage);
983   if (where_am_i == NULL)
984     return NULL;
985   for (k = z_min; k &lt; z_max; k++) {
986     for (j = y_min; j &lt; y_max; j++) {
987       for (i = x_min; i &lt; x_max; i++) {
988         h = k + (world-&gt;nz_parts - 1) * (j + (world-&gt;ny_parts - 1) * i);
989         llf.x = world-&gt;x_fineparts[world-&gt;subvol[h].llf.x] - leeway;
990         llf.y = world-&gt;y_fineparts[world-&gt;subvol[h].llf.y] - leeway;
991         llf.z = world-&gt;z_fineparts[world-&gt;subvol[h].llf.z] - leeway;
992         urb.x = world-&gt;x_fineparts[world-&gt;subvol[h].urb.x] + leeway;
993         urb.y = world-&gt;y_fineparts[world-&gt;subvol[h].urb.y] + leeway;
994         urb.z = world-&gt;z_fineparts[world-&gt;subvol[h].urb.z] + leeway;
995         if (wall_in_box(w-&gt;vert, &amp;(w-&gt;normal), w-&gt;d, &amp;llf, &amp;urb)) {
996           if (wall_to_vol(where_am_i, &amp;(world-&gt;subvol[h])) == NULL)
997             return NULL;
998         }
999       }
1000     }
1001   }
1002   return where_am_i;
1003 }
1004 int distribute_object(struct volume *world, struct geom_object *parent) {
1005   struct geom_object *o;   int i;
1006   if (parent-&gt;object_type == BOX_OBJ || parent-&gt;object_type == POLY_OBJ) {
1007     for (i = 0; i &lt; parent-&gt;n_walls; i++) {
1008       if (parent-&gt;wall_p[i] == NULL)
1009         continue; 
1010       parent-&gt;wall_p[i] = distribute_wall(world, parent-&gt;wall_p[i]);
1011       if (parent-&gt;wall_p[i] == NULL)
1012         mcell_allocfailed("Failed to distribute wall %d on object %s.", i,
1013                           parent-&gt;sym-&gt;name);
1014       if (world-&gt;create_shared_walls_info_flag) {
1015         vert_index = (long long)(parent-&gt;wall_p[i]-&gt;vert[0] - world-&gt;all_vertices);
1016         push_wall_to_list(&amp;(world-&gt;walls_using_vertex[vert_index]),
1017                           parent-&gt;wall_p[i]);
1018         vert_index = (long long)(parent-&gt;wall_p[i]-&gt;vert[1] - world-&gt;all_vertices);
1019         push_wall_to_list(&amp;(world-&gt;walls_using_vertex[vert_index]),
1020                           parent-&gt;wall_p[i]);
1021         vert_index = (long long)(parent-&gt;wall_p[i]-&gt;vert[2] - world-&gt;all_vertices);
1022         push_wall_to_list(&amp;(world-&gt;walls_using_vertex[vert_index]),
1023                           parent-&gt;wall_p[i]);
1024       }
1025     }
1026     if (parent-&gt;walls != NULL) {
1027       free(parent-&gt;walls);
1028       parent-&gt;walls = NULL;     }
1029   } else if (parent-&gt;object_type == META_OBJ) {
1030     for (o = parent-&gt;first_child; o != NULL; o = o-&gt;next) {
1031       if (distribute_object(world, o) != 0)
1032         return 1;
1033     }
1034   }
1035   return 0;
1036 }
1037 int distribute_world(struct volume *world) {
1038   struct geom_object *o; 
1039   for (o = world-&gt;root_instance; o != NULL; o = o-&gt;next) {
1040     if (distribute_object(world, o) != 0)
1041       return 1;
1042   }
1043   return 0;
1044 }
1045 void closest_pt_point_triangle(struct vector3 *p, struct vector3 *a,
1046                                struct vector3 *b, struct vector3 *c,
1047                                struct vector3 *final_result) {
1048   struct vector3 ab, ac, ap, bp, cp, result1;
1049   double d1, d2, d3, d4, vc, d5, d6, vb, va, denom, v, w;
1050   vectorize(a, b, &amp;ab);
1051   vectorize(a, c, &amp;ac);
1052   vectorize(a, p, &amp;ap);
1053   d1 = dot_prod(&amp;ab, &amp;ap);
1054   d2 = dot_prod(&amp;ac, &amp;ap);
1055   if (d1 &lt;= 0.0f &amp;&amp; d2 &lt;= 0.0f) {
1056     memcpy(final_result, a,
1057            sizeof(struct vector3));     return;
1058   }
1059   vectorize(b, p, &amp;bp);
1060   d3 = dot_prod(&amp;ab, &amp;bp);
1061   d4 = dot_prod(&amp;ac, &amp;bp);
1062   if (d3 &gt;= 0.0f &amp;&amp; d4 &lt;= d3) {
1063     memcpy(final_result, b,
1064            sizeof(struct vector3));     return;
1065   }
1066   vc = d1 * d4 - d3 * d2;
1067   if (vc &lt;= 0.0f &amp;&amp; d1 &gt;= 0.0f &amp;&amp; d3 &lt;= 0.0f) {
1068     v = d1 / (d1 - d3);
1069     scalar_prod(&amp;ab, v, &amp;result1);
1070     vect_sum(a, &amp;result1, final_result);
1071     return;   }
1072   vectorize(c, p, &amp;cp);
1073   d5 = dot_prod(&amp;ab, &amp;cp);
1074   d6 = dot_prod(&amp;ac, &amp;cp);
1075   if (d6 &gt;= 0.0f &amp;&amp; d5 &lt;= d6) {
1076     memcpy(final_result, c,
1077            sizeof(struct vector3));     return;
1078   }
1079   vb = d5 * d2 - d1 * d6;
1080   if (vb &lt;= 0.0f &amp;&amp; d2 &gt;= 0.0f &amp;&amp; d6 &lt;= 0.0f) {
1081     w = d2 / (d2 - d6);
1082     scalar_prod(&amp;ac, w, &amp;result1);
1083     vect_sum(a, &amp;result1, final_result);
1084     return;   }
1085   va = d3 * d6 - d5 * d4;
1086   if (va &lt;= 0.0f &amp;&amp; (d4 - d3) &gt;= 0.0f &amp;&amp; (d5 - d6) &gt;= 0.0f) {
1087     w = (d4 - d3) / ((d4 - d3) + (d5 - d6));
1088     vectorize(b, c, &amp;result1);
1089     scalar_prod(&amp;result1, w, &amp;result1);
1090     vect_sum(b, &amp;result1, final_result);
1091   }
1092   denom = 1.0f / (va + vb + vc);
1093   v = vb * denom;
1094   w = vc * denom;
1095   scalar_prod(&amp;ab, v, &amp;ab);
1096   scalar_prod(&amp;ac, w, &amp;ac);
1097   vect_sum(&amp;ab, &amp;ac, &amp;result1);
1098   vect_sum(a, &amp;result1, final_result);
1099   return; }
1100 <font color="#8c8774"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>int test_bounding_boxes(struct vector3 *llf1, struct vector3 *urb1,
1101                         struct vector3 *llf2, struct vector3 *urb2) {
1102   if ((urb1-&gt;x &lt; llf2-&gt;x) || (llf1-&gt;x &gt; urb2-&gt;x))
1103     return 0;
1104   if ((urb1-&gt;y &lt; llf2-&gt;y) || (llf1-&gt;y &gt; urb2-&gt;y))
1105     return 0;
1106   if ((urb1-&gt;z &lt; llf2-&gt;z) || (llf1-&gt;z &gt; urb2-&gt;z))
1107     return 0;
1108   return 1;
1109 }</b></font>
1110 struct reg_rel_helper_data {
1111   struct reg_rel_helper_data *next;
1112   struct surface_grid *grid;
1113   unsigned int index;
1114   double my_area;
1115 };
1116 static int vacuum_from_regions(struct volume *world,
1117                                struct release_site_obj *rso,
1118                                struct surface_molecule *sm, int n) {
1119   struct release_region_data *rrd;
1120   struct mem_helper *mh;
1121   struct reg_rel_helper_data *rrhd_head, *p;
1122   int n_rrhd;
1123   struct wall *w;
1124   struct surface_molecule *smp;
1125   rrd = rso-&gt;region_data;
1126   mh = create_mem(sizeof(struct reg_rel_helper_data), 1024);
1127   if (mh == NULL)
1128     return 1;
1129   rrhd_head = NULL;
1130   n_rrhd = 0;
1131   for (int n_object = 0; n_object &lt; rrd-&gt;n_objects; n_object++) {
1132     if (rrd-&gt;walls_per_obj[n_object] == 0)
1133       continue;
1134     for (int n_wall = 0; n_wall &lt; rrd-&gt;in_release[n_object]-&gt;nbits; n_wall++) {
1135       if (!get_bit(rrd-&gt;in_release[n_object], n_wall))
1136         continue;
1137       w = rrd-&gt;owners[n_object]-&gt;wall_p[n_wall];
1138       if (w-&gt;grid == NULL)
1139         continue;
1140       for (unsigned int n_tile = 0; n_tile &lt; w-&gt;grid-&gt;n_tiles; n_tile++) {
1141         struct surface_molecule_list *sm_list = w-&gt;grid-&gt;sm_list[n_tile];
1142         if (sm_list &amp;&amp; sm_list-&gt;sm) {
1143           smp = w-&gt;grid-&gt;sm_list[n_tile]-&gt;sm;
1144           if (smp != NULL) {
1145             if (smp-&gt;properties == sm-&gt;properties) {
1146               p = (struct reg_rel_helper_data *)CHECKED_MEM_GET_NODIE(mh, "release region helper data");
1147               if (p == NULL)
1148                 return 1;
1149               p-&gt;next = rrhd_head;
1150               p-&gt;grid = w-&gt;grid;
1151               p-&gt;index = n_tile;
1152               rrhd_head = p;
1153               n_rrhd++;
1154             }
1155           }
1156         }
1157       }
1158     }
1159   }
1160   for (p = rrhd_head; n &lt; 0 &amp;&amp; n_rrhd &gt; 0 &amp;&amp; p != NULL; p = p-&gt;next, n_rrhd--) {
1161     if (rng_dbl(world-&gt;rng) &lt; ((double)(-n)) / ((double)n_rrhd)) {
1162       smp = p-&gt;grid-&gt;sm_list[p-&gt;index]-&gt;sm;
1163       smp-&gt;properties-&gt;population--;
1164       if ((smp-&gt;properties-&gt;flags &amp; (COUNT_CONTENTS | COUNT_ENCLOSED)) != 0)
1165         count_region_from_scratch(world, (struct abstract_molecule *)smp, NULL,
1166                                   -1, NULL, smp-&gt;grid-&gt;surface, smp-&gt;t, NULL);
1167       smp-&gt;properties = NULL;
1168       p-&gt;grid-&gt;sm_list[p-&gt;index]-&gt;sm = NULL;
1169       p-&gt;grid-&gt;n_occupied--;
1170       if (smp-&gt;flags &amp; IN_SCHEDULE) {
1171       }
1172       n++;
1173     }
1174   }
1175   delete_mem(mh);
1176   return 0;
1177 }
1178 int release_onto_regions(struct volume *world, struct release_site_obj *rso,
1179                          struct surface_molecule *sm, int n) {
1180   struct mem_helper *mh;
1181   int i;
1182   unsigned int grid_index;
1183   double A, num_to_release;
1184   struct wall *w;
1185   struct release_region_data *rrd = rso-&gt;region_data;
1186   int success = 0, failure = 0;
1187   double seek_cost = 0;
1188   double max_A = rrd-&gt;cum_area_list[rrd-&gt;n_walls_included - 1];
1189   double est_sites_avail = (int)max_A;
1190   const double rel_list_gen_cost = 10.0;   double pick_cost = rel_list_gen_cost * est_sites_avail;
1191   if (rso-&gt;release_number_method == DENSITYNUM) {
1192     num_to_release = rso-&gt;concentration * est_sites_avail / world-&gt;grid_density;
1193     if (num_to_release &gt; (double)INT_MAX)
1194       mcell_error("Release site \"%s\" tries to release more than INT_MAX "
1195                   "(2147483647) molecules.",
1196                   rso-&gt;name);
1197     n = (int)(num_to_release);
1198   }
1199   if (n &lt; 0)
1200     return vacuum_from_regions(world, rso, sm, n);
1201   const int too_many_failures = 10;   while (n &gt; 0) {
1202     if (failure &gt;= success + too_many_failures) {
1203       seek_cost =
1204           n * (((double)(success + failure + 2)) / ((double)(success + 1)));
1205     }
1206     if (seek_cost &lt; pick_cost) {
1207       A = rng_dbl(world-&gt;rng) * max_A;
1208       i = bisect_high(rrd-&gt;cum_area_list, rrd-&gt;n_walls_included, A);
1209       w = rrd-&gt;owners[rrd-&gt;obj_index[i]]-&gt;wall_p[rrd-&gt;wall_index[i]];
1210       if (w-&gt;grid == NULL) {
1211         if (create_grid(world, w, NULL))
1212           return 1;
1213       }
1214       if (i)
1215         A -= rrd-&gt;cum_area_list[i - 1];
1216       grid_index = (unsigned int)((w-&gt;grid-&gt;n * w-&gt;grid-&gt;n) * (A / w-&gt;area));
1217       if (grid_index &gt;= w-&gt;grid-&gt;n_tiles) {
1218         grid_index = w-&gt;grid-&gt;n_tiles - 1;
1219       }
1220       struct surface_molecule_list *sm_list = w-&gt;grid-&gt;sm_list[grid_index];
1221       if (sm_list &amp;&amp; sm_list-&gt;sm) {
1222         failure++;
1223       }
1224       else {
1225         struct vector3 pos3d = {0, 0, 0};
1226         if (place_single_molecule(world, w, grid_index, sm-&gt;properties,
1227                                   sm-&gt;graph_data, sm-&gt;flags, rso-&gt;orientation, sm-&gt;t, sm-&gt;t2,
1228                                   sm-&gt;birthday, sm-&gt;periodic_box, &amp;pos3d) == NULL) {
1229           if (world-&gt;periodic_box_obj) {
1230             struct polygon_object *p = (struct polygon_object*)(world-&gt;periodic_box_obj-&gt;contents);
1231             struct subdivided_box *sb = p-&gt;sb;
1232             struct vector3 llf = {sb-&gt;x[0], sb-&gt;y[0], sb-&gt;z[0]};
1233             struct vector3 urb = {sb-&gt;x[1], sb-&gt;y[1], sb-&gt;z[1]};
1234             if (!point_in_box(&amp;llf, &amp;urb, &amp;pos3d)) {
1235               mcell_log("Cannot release '%s' outside of periodic boundaries.",
1236                         sm-&gt;properties-&gt;sym-&gt;name);
1237               failure++;
1238               continue;
1239             }
1240           }
1241           return 1;
1242         }
1243         success++;
1244         n--;
1245       }
1246     } else {
1247       if (world-&gt;periodic_box_obj) {
1248         return 1;
1249       }
1250       mh = create_mem(sizeof(struct reg_rel_helper_data), 1024);
1251       if (mh == NULL)
1252         return 1;
1253       struct reg_rel_helper_data *rrhd_head = NULL;
1254       int n_rrhd = 0;
1255       max_A = 0;
1256       for (int n_object = 0; n_object &lt; rrd-&gt;n_objects; n_object++) {
1257         if (rrd-&gt;walls_per_obj[n_object] == 0)
1258           continue;
1259         for (int n_wall = 0; n_wall &lt; rrd-&gt;in_release[n_object]-&gt;nbits;
1260              n_wall++) {
1261           if (!get_bit(rrd-&gt;in_release[n_object], n_wall))
1262             continue;
1263           w = rrd-&gt;owners[n_object]-&gt;wall_p[n_wall];
1264           if (w-&gt;grid == NULL) {
1265             if (create_grid(world, w, NULL)) {
1266               delete_mem(mh);
1267               return 1;
1268             }
1269           } else if (w-&gt;grid-&gt;n_occupied == w-&gt;grid-&gt;n_tiles)
1270             continue;
1271           A = w-&gt;area / (w-&gt;grid-&gt;n_tiles);
1272           for (unsigned int n_tile = 0; n_tile &lt; w-&gt;grid-&gt;n_tiles; n_tile++) {
1273             if (w-&gt;grid-&gt;sm_list[n_tile] == NULL || w-&gt;grid-&gt;sm_list[n_tile]-&gt;sm == NULL) {
1274               struct reg_rel_helper_data *new_rrd =
1275                   (struct reg_rel_helper_data *)CHECKED_MEM_GET_NODIE(mh, "release region helper data");
1276               if (new_rrd == NULL)
1277                 return 1;
1278               new_rrd-&gt;next = rrhd_head;
1279               new_rrd-&gt;grid = w-&gt;grid;
1280               new_rrd-&gt;index = n_tile;
1281               new_rrd-&gt;my_area = A;
1282               max_A += A;
1283               rrhd_head = new_rrd;
1284               n_rrhd++;
1285             }
1286           }
1287         }
1288       }
1289       for (struct reg_rel_helper_data *this_rrd = rrhd_head;
1290            this_rrd != NULL &amp;&amp; n &gt; 0; this_rrd = this_rrd-&gt;next) {
1291         if (n &gt;= n_rrhd ||
1292             rng_dbl(world-&gt;rng) &lt; (this_rrd-&gt;my_area / max_A) * ((double)n)) {
1293           struct vector3 pos3d = {0, 0, 0};
1294           if (place_single_molecule(world, this_rrd-&gt;grid-&gt;surface,
1295                                     this_rrd-&gt;index, sm-&gt;properties, sm-&gt;graph_data, sm-&gt;flags,
1296                                     rso-&gt;orientation, sm-&gt;t, sm-&gt;t2,
1297                                     sm-&gt;birthday, sm-&gt;periodic_box, &amp;pos3d) == NULL) {
1298             return 1;
1299             }
1300           n--;
1301           n_rrhd--;
1302         }
1303         max_A -= this_rrd-&gt;my_area;
1304       }
1305       delete_mem(mh);
1306       if (n &gt; 0) {
1307         switch (world-&gt;notify-&gt;mol_placement_failure) {
1308         case WARN_COPE:
1309           break;
1310         case WARN_WARN:
1311           mcell_warn("Could not release %d of %s (surface full).", n,
1312                      sm-&gt;properties-&gt;sym-&gt;name);
1313           break;
1314         case WARN_ERROR:
1315           mcell_error("Could not release %d of %s (surface full).", n,
1316                       sm-&gt;properties-&gt;sym-&gt;name);
1317         default:
1318           UNHANDLED_CASE(world-&gt;notify-&gt;mol_placement_failure);
1319         }
1320         break;
1321       }
1322     }
1323   }
1324   return 0;
1325 }
1326 struct surface_molecule *place_single_molecule(struct volume *state,
1327                                                struct wall *w,
1328                                                unsigned int grid_index,
1329                                                struct species *spec,
1330                                                struct graph_data* graph,
1331                                                short flags, short orientation,
1332                                                double t, double t2,
1333                                                double birthday,
1334                                                struct periodic_image *periodic_box,
1335                                                struct vector3 *pos3d) {
1336   struct vector2 s_pos;
1337   if (state-&gt;randomize_smol_pos)
1338     grid2uv_random(w-&gt;grid, grid_index, &amp;s_pos, state-&gt;rng);
1339   else
1340     grid2uv(w-&gt;grid, grid_index, &amp;s_pos);
1341   uv2xyz(&amp;s_pos, w, pos3d);
1342   if (state-&gt;periodic_box_obj) {
1343     struct polygon_object *p = (struct polygon_object*)(state-&gt;periodic_box_obj-&gt;contents);
1344     struct subdivided_box *sb = p-&gt;sb;
1345     struct vector3 llf = {sb-&gt;x[0], sb-&gt;y[0], sb-&gt;z[0]};
1346     struct vector3 urb = {sb-&gt;x[1], sb-&gt;y[1], sb-&gt;z[1]};
1347     if (!point_in_box(&amp;llf, &amp;urb, pos3d)) {
1348       mcell_log("Cannot release '%s' outside of periodic boundaries.",
1349               spec-&gt;sym-&gt;name);
1350       return NULL;
1351     }
1352   }
1353   struct subvolume *gsv = NULL;
1354   gsv = find_subvolume(state, pos3d, gsv);
1355   struct surface_molecule *new_sm;
1356   new_sm = (struct surface_molecule *)CHECKED_MEM_GET(gsv-&gt;local_storage-&gt;smol,
1357                                                       "surface molecule");
1358   if (new_sm == NULL)
1359     return NULL;
1360   new_sm-&gt;t = t;
1361   new_sm-&gt;t2 = t2;
1362   new_sm-&gt;birthday = birthday;
1363   new_sm-&gt;birthplace = w-&gt;birthplace-&gt;smol;
1364   new_sm-&gt;id = state-&gt;current_mol_id++;
1365   new_sm-&gt;grid_index = grid_index;
1366   new_sm-&gt;s_pos.u = s_pos.u;
1367   new_sm-&gt;s_pos.v = s_pos.v;
1368   new_sm-&gt;properties = spec;
1369   new_sm-&gt;graph_data = graph;
1370   initialize_diffusion_function((struct abstract_molecule *)new_sm);
1371   new_sm-&gt;periodic_box = CHECKED_MALLOC_STRUCT(struct periodic_image,
1372     "periodic image descriptor");
1373   new_sm-&gt;periodic_box-&gt;x = periodic_box-&gt;x;
1374   new_sm-&gt;periodic_box-&gt;y = periodic_box-&gt;y;
1375   new_sm-&gt;periodic_box-&gt;z = periodic_box-&gt;z;
1376   if (orientation == 0)
1377     new_sm-&gt;orient = (rng_uint(state-&gt;rng) &amp; 1) ? 1 : -1;
1378   else
1379     new_sm-&gt;orient = orientation;
1380   new_sm-&gt;grid = w-&gt;grid;
1381   if (w-&gt;grid-&gt;sm_list[grid_index] == NULL) {
1382     struct surface_molecule_list *sm_entry = CHECKED_MALLOC_STRUCT(
1383       struct surface_molecule_list, "surface molecule list");
1384     sm_entry-&gt;next = NULL;
1385     w-&gt;grid-&gt;sm_list[grid_index] = sm_entry;
1386   }
1387   w-&gt;grid-&gt;sm_list[grid_index]-&gt;sm = new_sm;
1388   w-&gt;grid-&gt;n_occupied++;
1389   new_sm-&gt;properties-&gt;population++;
1390   new_sm-&gt;flags = flags;
1391   if (new_sm-&gt;get_space_step(new_sm) &gt; 0)
1392     new_sm-&gt;flags |= ACT_DIFFUSE;
1393   if ((new_sm-&gt;properties-&gt;flags &amp; COUNT_ENCLOSED) != 0)
1394     new_sm-&gt;flags |= COUNT_ME;
1395   if (new_sm-&gt;properties-&gt;flags &amp; (COUNT_CONTENTS | COUNT_ENCLOSED))
1396     count_region_from_scratch(state, (struct abstract_molecule *)new_sm, NULL,
1397                               1, NULL, new_sm-&gt;grid-&gt;surface, new_sm-&gt;t,
1398                               new_sm-&gt;periodic_box);
1399   if (schedule_add_mol(gsv-&gt;local_storage-&gt;timer, new_sm)) {
1400     mcell_allocfailed("Failed to add volume molecule '%s' to scheduler.",
1401                       new_sm-&gt;properties-&gt;sym-&gt;name);
1402     return NULL;
1403   }
1404   return new_sm;
1405 }
1406 void push_wall_to_list(struct wall_list **wall_nbr_head, struct wall *w) {
1407   struct wall_list *old_head, *wlp;
1408   old_head = *wall_nbr_head;
1409   wlp = CHECKED_MALLOC_STRUCT(struct wall_list, "wall_list");
1410   wlp-&gt;this_wall = w;
1411   if (old_head == NULL) {
1412     wlp-&gt;next = NULL;
1413     old_head = wlp;
1414   } else {
1415     wlp-&gt;next = old_head;
1416     old_head = wlp;
1417   }
1418   *wall_nbr_head = old_head;
1419 }
1420 void delete_wall_list(struct wall_list *wl_head) {
1421   struct wall_list *nnext;
1422   while (wl_head != NULL) {
1423     nnext = wl_head-&gt;next;
1424     free(wl_head);
1425     wl_head = nnext;
1426   }
1427 }
1428 struct wall_list *find_nbr_walls_shared_one_vertex(struct volume *world,
1429                                                    struct wall *origin,
1430                                                    long long int *shared_vert) {
1431   int i;
1432   struct wall_list *wl;
1433   struct wall_list *head = NULL;
1434   if (!world-&gt;create_shared_walls_info_flag)
1435     mcell_internal_error("Function 'find_nbr_walls_shared_one_vertex()' is "
1436                          "called but shared walls information is not created.");
1437   for (i = 0; i &lt; 3; i++) {
1438     if (shared_vert[i] &gt;= 0) {
1439       for (wl = world-&gt;walls_using_vertex[shared_vert[i]]; wl != NULL;
1440            wl = wl-&gt;next) {
1441         if (wl-&gt;this_wall == origin)
1442           continue;
1443         if (!walls_share_full_edge(origin, wl-&gt;this_wall)) {
1444           push_wall_to_list(&amp;head, wl-&gt;this_wall);
1445         }
1446       }
1447     }
1448   }
1449   return head;
1450 }
1451 int walls_share_full_edge(struct wall *w1, struct wall *w2) {
1452   int i, k;
1453   int count = 0; 
1454   for (i = 0; i &lt; 3; i++) {
1455     for (k = 0; k &lt; 3; k++) {
1456       if (!distinguishable_vec3(w1-&gt;vert[i], w2-&gt;vert[k], EPS_C))
1457         count++;
1458     }
1459   }
1460   if (count == 2)
1461     return 1;
1462   return 0;
1463 }
1464 struct region_list *find_region_by_wall(struct wall *this_wall) {
1465   struct region_list *rlp_head = NULL;
1466   for (struct region_list *rlp = this_wall-&gt;parent_object-&gt;regions; rlp != NULL;
1467     rlp = rlp-&gt;next) {
1468     struct region *rp = rlp-&gt;reg;
1469     if ((strcmp(rp-&gt;region_last_name, "ALL") == 0) ||
1470         (rp-&gt;region_has_all_elements))
1471       continue;
1472     if (rp-&gt;membership == NULL)
1473       mcell_internal_error("Missing region membership for '%s'.",
1474                            rp-&gt;sym-&gt;name);
1475     if (get_bit(rp-&gt;membership, this_wall-&gt;side)) {
1476       struct region_list *rlps = CHECKED_MALLOC_STRUCT(struct region_list,
1477         "region_list");
1478       rlps-&gt;reg = rp;
1479       if (rlp_head == NULL) {
1480         rlps-&gt;next = NULL;
1481         rlp_head = rlps;
1482       } else {
1483         rlps-&gt;next = rlp_head;
1484         rlp_head = rlps;
1485       }
1486     }
1487   }
1488   return rlp_head;
1489 }
1490 struct name_list *find_regions_names_by_wall(
1491     struct wall *w, struct string_buffer *ignore_regs)
1492 {
1493   struct name_list *nl_head = NULL;
1494   struct region_list *reg_list_ptr_head = find_region_by_wall(w);
1495   struct region_list *reg_list_ptr;
1496   for (reg_list_ptr = reg_list_ptr_head; reg_list_ptr != NULL;) {
1497     struct region *reg_ptr = reg_list_ptr-&gt;reg;
1498     if ((ignore_regs) &amp;&amp; (is_string_present_in_string_array(
1499         reg_ptr-&gt;sym-&gt;name, ignore_regs-&gt;strings, ignore_regs-&gt;n_strings))) {
1500       reg_list_ptr_head = reg_list_ptr-&gt;next;
1501       free(reg_list_ptr);
1502       reg_list_ptr = reg_list_ptr_head;
1503       continue;
1504     }
1505     struct name_list *nl = CHECKED_MALLOC_STRUCT(struct name_list, "name_list");
1506     nl-&gt;name = alloc_sprintf("%s", reg_ptr-&gt;sym-&gt;name);   
1507     nl-&gt;prev = NULL;
1508     if (nl_head == NULL) {
1509       nl-&gt;next = NULL;
1510       nl_head = nl;
1511     }
1512     else {
1513       nl-&gt;next = nl_head;
1514       nl_head = nl;
1515     }
1516     reg_list_ptr_head = reg_list_ptr-&gt;next;
1517     free(reg_list_ptr);
1518     reg_list_ptr = reg_list_ptr_head;
1519   }
1520   return nl_head;
1521 }
1522 struct region_list *
1523 find_restricted_regions_by_wall(struct volume *world, struct wall *this_wall,
1524                                 struct surface_molecule *sm) {
1525   if ((sm-&gt;properties-&gt;flags &amp; CAN_REGION_BORDER) == 0)
1526     return NULL;
1527   struct rxn *matching_rxns[MAX_MATCHING_RXNS];
1528   for (int kk = 0; kk &lt; MAX_MATCHING_RXNS; kk++) {
1529     matching_rxns[kk] = NULL;
1530   }
1531   int num_matching_rxns = trigger_intersect(
1532       world-&gt;reaction_hash, world-&gt;rx_hashsize, world-&gt;all_mols,
1533       world-&gt;all_volume_mols, world-&gt;all_surface_mols, sm-&gt;properties-&gt;hashval,
1534       (struct abstract_molecule *)sm, sm-&gt;orient, this_wall, matching_rxns, 1,
1535       1, 1);
1536   struct species *restricted_surf_class[MAX_MATCHING_RXNS];
1537   int num_res = 0;
1538   for (int kk = 0; kk &lt; num_matching_rxns; kk++) {
1539     if ((matching_rxns[kk]-&gt;n_pathways == RX_REFLEC) ||
1540         (matching_rxns[kk]-&gt;n_pathways == RX_ABSORB_REGION_BORDER)) {
1541       restricted_surf_class[num_res++] = matching_rxns[kk]-&gt;players[1];
1542     }
1543   }
1544   struct region *rp;
1545   struct region_list *rlp_head = NULL;
1546   for (struct region_list *rlp = this_wall-&gt;parent_object-&gt;regions; rlp != NULL;
1547     rlp = rlp-&gt;next) {
1548     rp = rlp-&gt;reg;
1549     if (rp-&gt;membership == NULL) {
1550       mcell_internal_error("Missing region membership for '%s'.", rp-&gt;sym-&gt;name);
1551     }
1552     if (rp-&gt;surf_class == NULL) {
1553       continue;
1554     }
1555     if ((strcmp(rp-&gt;region_last_name, "ALL") == 0) ||
1556         (rp-&gt;region_has_all_elements)) {
1557       continue;
1558     }
1559     if (get_bit(rp-&gt;membership, this_wall-&gt;side)) {
1560       for (int i = 0; i &lt; num_res; ++i) {
1561         if (rp-&gt;surf_class == restricted_surf_class[i]) {
1562           struct region_list *rlps = CHECKED_MALLOC_STRUCT(struct region_list,
1563             "region_list");
1564           rlps-&gt;reg = rp;
1565           if (rlp_head == NULL) {
1566             rlps-&gt;next = NULL;
1567             rlp_head = rlps;
1568           } else {
1569             rlps-&gt;next = rlp_head;
1570             rlp_head = rlps;
1571           }
1572           break;
1573         }
1574       }
1575     }
1576   }
1577   return rlp_head;
1578 }
1579 struct region_list *
1580 find_restricted_regions_by_object(struct volume *world, struct geom_object *obj,
1581                                   struct surface_molecule *sm) {
1582   struct region *rp;
1583   struct region_list *rlp, *rlps, *rlp_head = NULL;
1584   int kk, i, wall_idx = INT_MIN;
1585   struct rxn *matching_rxns[MAX_MATCHING_RXNS];
1586   if ((sm-&gt;properties-&gt;flags &amp; CAN_REGION_BORDER) == 0)
1587     return NULL;
1588   for (kk = 0; kk &lt; MAX_MATCHING_RXNS; kk++) {
1589     matching_rxns[kk] = NULL;
1590   }
1591   for (rlp = obj-&gt;regions; rlp != NULL; rlp = rlp-&gt;next) {
1592     rp = rlp-&gt;reg;
1593     if ((strcmp(rp-&gt;region_last_name, "ALL") == 0) ||
1594         (rp-&gt;region_has_all_elements)) {
1595       continue;
1596     }
1597     for (i = 0; i &lt; obj-&gt;n_walls; i++) {
1598       if (get_bit(rp-&gt;membership, i)) {
1599         wall_idx = i;
1600         break;
1601       }
1602     }
1603     if (wall_idx &lt; 0)
1604       mcell_internal_error("Cannot find wall in the region.");
1605     int num_matching_rxns = 0;
1606     if (rp-&gt;surf_class) {
1607       num_matching_rxns = find_unimol_reactions_with_surf_classes(
1608           world-&gt;reaction_hash, world-&gt;rx_hashsize,
1609           (struct abstract_molecule *)sm, obj-&gt;wall_p[wall_idx],
1610           sm-&gt;properties-&gt;hashval, sm-&gt;orient, num_matching_rxns, 1, 1, 1,
1611           matching_rxns);
1612       num_matching_rxns = find_surface_mol_reactions_with_surf_classes(
1613           world-&gt;reaction_hash, world-&gt;rx_hashsize, world-&gt;all_mols,
1614           world-&gt;all_surface_mols, sm-&gt;orient, rp-&gt;surf_class,
1615           num_matching_rxns, 1, 1, 1, matching_rxns);
1616     }
1617     for (kk = 0; kk &lt; num_matching_rxns; kk++) {
1618       if ((matching_rxns[kk]-&gt;n_pathways == RX_REFLEC) ||
1619           (matching_rxns[kk]-&gt;n_pathways == RX_ABSORB_REGION_BORDER)) {
1620         rlps = CHECKED_MALLOC_STRUCT(struct region_list, "region_list");
1621         rlps-&gt;reg = rp;
1622         if (rlp_head == NULL) {
1623           rlps-&gt;next = NULL;
1624           rlp_head = rlps;
1625         } else {
1626           rlps-&gt;next = rlp_head;
1627           rlp_head = rlps;
1628         }
1629       }
1630     }
1631   }
1632   return rlp_head;
1633 }
1634 int are_restricted_regions_for_species_on_object(struct volume *world,
1635                                                  struct geom_object *obj,
1636                                                  struct surface_molecule *sm) {
1637   int wall_idx = INT_MIN;
1638   struct rxn *matching_rxns[MAX_MATCHING_RXNS];
1639   if ((sm-&gt;properties-&gt;flags &amp; CAN_REGION_BORDER) == 0)
1640     return 0;
1641   for (int kk = 0; kk &lt; MAX_MATCHING_RXNS; kk++) {
1642     matching_rxns[kk] = NULL;
1643   }
1644   for (struct region_list *rlp = obj-&gt;regions; rlp != NULL; rlp = rlp-&gt;next) {
1645     struct region *rp = rlp-&gt;reg;
1646     if ((strcmp(rp-&gt;region_last_name, "ALL") == 0) ||
1647         (rp-&gt;region_has_all_elements)) {
1648       continue;
1649     }
1650     for (int i = 0; i &lt; obj-&gt;n_walls; i++) {
1651       if (get_bit(rp-&gt;membership, i)) {
1652         wall_idx = i;
1653         break;
1654       }
1655     }
1656     if (wall_idx &lt; 0) {
1657       mcell_internal_error("Cannot find wall in the region.");
1658     }
1659     int num_matching_rxns = trigger_intersect(
1660         world-&gt;reaction_hash, world-&gt;rx_hashsize, world-&gt;all_mols,
1661         world-&gt;all_volume_mols, world-&gt;all_surface_mols,
1662         sm-&gt;properties-&gt;hashval, (struct abstract_molecule *)sm, sm-&gt;orient,
1663         obj-&gt;wall_p[wall_idx], matching_rxns, 1, 1, 1);
1664     if (num_matching_rxns &gt; 0) {
1665       for (int kk = 0; kk &lt; num_matching_rxns; kk++) {
1666         if ((matching_rxns[kk]-&gt;n_pathways == RX_REFLEC) ||
1667             (matching_rxns[kk]-&gt;n_pathways == RX_ABSORB_REGION_BORDER)) {
1668           return 1;
1669         }
1670       }
1671     }
1672   }
1673   return 0;
1674 }
1675 int is_wall_edge_region_border(struct wall *this_wall, struct edge *this_edge) {
1676   struct region_list *rlp, *rlp_head;
1677   struct region *rp;
1678   void *key;
1679   unsigned int keyhash;
1680   int is_region_border = 0; 
1681   rlp_head = find_region_by_wall(this_wall);
1682   if (rlp_head == NULL)
1683     return is_region_border;
1684   for (rlp = rlp_head; rlp != NULL; rlp = rlp-&gt;next) {
1685     rp = rlp-&gt;reg;
1686     if (rp-&gt;boundaries == NULL)
1687       mcell_internal_error("Region '%s' of the object '%s' has no boundaries.",
1688                            rp-&gt;region_last_name,
1689                            this_wall-&gt;parent_object-&gt;sym-&gt;name);
1690     keyhash = (unsigned int)(intptr_t)(this_edge);
1691     key = (void *)(this_edge);
1692     if (pointer_hash_lookup(rp-&gt;boundaries, key, keyhash)) {
1693       is_region_border = 1;
1694       break;
1695     }
1696   }
1697   if (rlp_head != NULL)
1698     delete_void_list((struct void_list *)rlp_head);
1699   return is_region_border;
1700 }
1701 int is_wall_edge_restricted_region_border(struct volume *world,
1702                                           struct wall *this_wall,
1703                                           struct edge *this_edge,
1704                                           struct surface_molecule *sm) {
1705   struct region_list *rlp, *rlp_head;
1706   struct region *rp;
1707   void *key;
1708   unsigned int keyhash;
1709   int is_region_border = 0; 
1710   rlp_head = find_restricted_regions_by_wall(world, this_wall, sm);
1711   if (rlp_head == NULL)
1712     return is_region_border;
1713   for (rlp = rlp_head; rlp != NULL; rlp = rlp-&gt;next) {
1714     rp = rlp-&gt;reg;
1715     if (rp-&gt;boundaries == NULL)
1716       mcell_internal_error("Region '%s' of the object '%s' has no boundaries.",
1717                            rp-&gt;region_last_name,
1718                            this_wall-&gt;parent_object-&gt;sym-&gt;name);
1719     keyhash = (unsigned int)(intptr_t)(this_edge);
1720     key = (void *)(this_edge);
1721     if (pointer_hash_lookup(rp-&gt;boundaries, key, keyhash)) {
1722       is_region_border = 1;
1723       break;
1724     }
1725   }
1726   if (rlp_head != NULL)
1727     delete_void_list((struct void_list *)rlp_head);
1728   return is_region_border;
1729 }
1730 int find_shared_edge_index_of_neighbor_wall(struct wall *orig_wall,
1731                                             struct wall *nbr_wall) {
1732   int nbr_edge_ind = -1;
1733   int shared_vert_ind_1 = -1, shared_vert_ind_2 = -1;
1734   find_shared_vertices_for_neighbor_walls(
1735       orig_wall, nbr_wall, &amp;shared_vert_ind_1, &amp;shared_vert_ind_2);
1736   if ((shared_vert_ind_1 + shared_vert_ind_2) == 1) {
1737     nbr_edge_ind = 0;
1738   } else if ((shared_vert_ind_1 + shared_vert_ind_2) == 2) {
1739     nbr_edge_ind = 2;
1740   } else if ((shared_vert_ind_1 + shared_vert_ind_2) == 3) {
1741     nbr_edge_ind = 1;
1742   } else {
1743     mcell_internal_error(
1744         "Error in the function 'find_shared_edge_index_of_neighbor_wall()");
1745   }
1746   return nbr_edge_ind;
1747 }
1748 void find_neighbor_wall_and_edge(struct wall *orig_wall, int orig_edge_ind,
1749                                  struct wall **nbr_wall, int *nbr_edge_ind) {
1750   struct wall *w;
1751   struct vector3 *vert_A = NULL, *vert_B = NULL;
1752   switch (orig_edge_ind) {
1753   case 0:
1754     vert_A = orig_wall-&gt;vert[0];
1755     vert_B = orig_wall-&gt;vert[1];
1756     break;
1757   case 1:
1758     vert_A = orig_wall-&gt;vert[1];
1759     vert_B = orig_wall-&gt;vert[2];
1760     break;
1761   case 2:
1762     vert_A = orig_wall-&gt;vert[2];
1763     vert_B = orig_wall-&gt;vert[0];
1764     break;
1765   default:
1766     mcell_internal_error("Error in function 'find_neighbor_wall_and_edge()'.");
1767   }
1768   for (int ii = 0; ii &lt; 3; ii++) {
1769     w = orig_wall-&gt;nb_walls[ii];
1770     if (w == NULL)
1771       continue;
1772     if (wall_contains_both_vertices(w, vert_A, vert_B)) {
1773       *nbr_wall = w;
1774       *nbr_edge_ind = find_shared_edge_index_of_neighbor_wall(orig_wall, w);
1775       break;
1776     }
1777   }
1778 }
1779 int wall_contains_both_vertices(struct wall *w, struct vector3 *vert_A,
1780                                 struct vector3 *vert_B) {
1781   int count = 0;
1782   for (int ii = 0; ii &lt; 3; ii++) {
1783     struct vector3 *v = w-&gt;vert[ii];
1784     if ((!distinguishable_vec3(v, vert_A, EPS_C)) ||
1785         (!(distinguishable_vec3(v, vert_B, EPS_C)))) {
1786       count++;
1787     }
1788   }
1789   if (count == 2)
1790     return 1;
1791   else
1792     return 0;
1793 }
1794 int are_walls_coincident(struct wall *w1, struct wall *w2, double eps) {
1795   if ((w1 == NULL) || (w2 == NULL))
1796     return 0;
1797   int count = 0;
1798   if (!distinguishable_vec3(w1-&gt;vert[0], w2-&gt;vert[0], eps))
1799     count++;
1800   if (!distinguishable_vec3(w1-&gt;vert[0], w2-&gt;vert[1], eps))
1801     count++;
1802   if (!distinguishable_vec3(w1-&gt;vert[0], w2-&gt;vert[2], eps))
1803     count++;
1804   if (!distinguishable_vec3(w1-&gt;vert[1], w2-&gt;vert[0], eps))
1805     count++;
1806   if (!distinguishable_vec3(w1-&gt;vert[1], w2-&gt;vert[1], eps))
1807     count++;
1808   if (!distinguishable_vec3(w1-&gt;vert[1], w2-&gt;vert[2], eps))
1809     count++;
1810   if (!distinguishable_vec3(w1-&gt;vert[2], w2-&gt;vert[0], eps))
1811     count++;
1812   if (!distinguishable_vec3(w1-&gt;vert[2], w2-&gt;vert[1], eps))
1813     count++;
1814   if (!distinguishable_vec3(w1-&gt;vert[2], w2-&gt;vert[2], eps))
1815     count++;
1816   if (count &gt;= 3)
1817     return 1;
1818   return 0;
1819 }
1820 int are_walls_coplanar(struct wall *w1, struct wall *w2, double eps) {
1821   double d2, d1_0, d1_1, d1_2;
1822   d2 = -dot_prod(&amp;(w2-&gt;normal), w2-&gt;vert[0]);
1823   d1_0 = dot_prod(&amp;(w2-&gt;normal), w1-&gt;vert[0]) + d2;
1824   d1_1 = dot_prod(&amp;(w2-&gt;normal), w1-&gt;vert[1]) + d2;
1825   d1_2 = dot_prod(&amp;(w2-&gt;normal), w1-&gt;vert[2]) + d2;
1826   if ((!distinguishable(d1_0, 0, eps)) &amp;&amp; (!distinguishable(d1_1, 0, eps)) &amp;&amp;
1827       (!distinguishable(d1_2, 0, eps))) {
1828     return 1;
1829   }
1830   return 0;
1831 }
1832 void sorted_insert_wall_aux_list(struct wall_aux_list **headRef,
1833                                  struct wall_aux_list *newNode) {
1834   if (*headRef == NULL || (*headRef)-&gt;d_prod &gt;= newNode-&gt;d_prod) {
1835     newNode-&gt;next = *headRef;
1836     *headRef = newNode;
1837   } else {
1838     struct wall_aux_list *curr = *headRef;
1839     while (curr-&gt;next != NULL &amp;&amp; curr-&gt;next-&gt;d_prod &lt; newNode-&gt;d_prod) {
1840       curr = curr-&gt;next;
1841     }
1842     newNode-&gt;next = curr-&gt;next;
1843     curr-&gt;next = newNode;
1844   }
1845 }
1846 void delete_wall_aux_list(struct wall_aux_list *head) {
1847   struct wall_aux_list *nnext;
1848   while (head != NULL) {
1849     nnext = head-&gt;next;
1850     free(head);
1851     head = nnext;
1852   }
1853 }
1854 int walls_belong_to_at_least_one_different_restricted_region(
1855     struct volume *world, struct wall *w1, struct surface_molecule *sm1,
1856     struct wall *w2, struct surface_molecule *sm2) {
1857   if ((w1 == NULL) || (w2 == NULL))
1858     return 0;
1859   struct region_list *rl_1 = find_restricted_regions_by_wall(world, w1, sm1);
1860   struct region_list *rl_2 = find_restricted_regions_by_wall(world, w2, sm2);
1861   if ((rl_1 == NULL) &amp;&amp; (rl_2 == NULL))
1862     return 0;
1863   int error_code = 0;
1864   if (rl_1 == NULL) {
1865     if (wall_belongs_to_all_regions_in_region_list(w1, rl_2))
1866       error_code = 0;
1867     else
1868       error_code = 1;
1869     delete_region_list(rl_2);
1870     return error_code;
1871   }
1872   if (rl_2 == NULL) {
1873     if (wall_belongs_to_all_regions_in_region_list(w2, rl_1))
1874       error_code = 0;
1875     else
1876       error_code = 1;
1877     delete_region_list(rl_1);
1878     return error_code;
1879   }
1880   for (struct region_list *rl_t1 = rl_1; rl_t1 != NULL; rl_t1 = rl_t1-&gt;next) {
1881     struct region *rp_1 = rl_t1-&gt;reg;
1882     if (!region_belongs_to_region_list(rp_1, rl_2)) {
1883       error_code = 1;
1884       break;
1885     }
1886   }
1887   delete_region_list(rl_1);
1888   delete_region_list(rl_2);
1889   return error_code;
1890 }
1891 int region_belongs_to_region_list(struct region *rp, struct region_list *head) {
1892   int found = 0;
1893   for (struct region_list *rlp = head; rlp != NULL; rlp = rlp-&gt;next) {
1894     if (rlp-&gt;reg == rp)
1895       found = 1;
1896   }
1897   if (!found)
1898     return 0;
1899   return 1;
1900 }
1901 int wall_belongs_to_all_regions_in_region_list(struct wall *this_wall,
1902                                                struct region_list *rlp_head) {
1903   struct region_list *rlp;
1904   struct region *rp;
1905   if (rlp_head == NULL)
1906     return 0;
1907   for (rlp = rlp_head; rlp != NULL; rlp = rlp-&gt;next) {
1908     rp = rlp-&gt;reg;
1909     if (!get_bit(rp-&gt;membership, this_wall-&gt;side))
1910       return 0;
1911   }
1912   return 1;
1913 }
1914 int wall_belongs_to_any_region_in_region_list(struct wall *this_wall,
1915                                               struct region_list *rlp_head) {
1916   struct region_list *rlp;
1917   struct region *rp;
1918   if (rlp_head == NULL)
1919     return 0;
1920   for (rlp = rlp_head; rlp != NULL; rlp = rlp-&gt;next) {
1921     rp = rlp-&gt;reg;
1922     if (get_bit(rp-&gt;membership, this_wall-&gt;side))
1923       return 1;
1924   }
1925   return 0;
1926 }
1927 void find_wall_center(struct wall *w, struct vector3 *center)
1928 {
1929   if(center == NULL) {
1930     mcell_internal_error("Error in function 'find_wall_center()'.");
1931   }
1932   center-&gt;x = (w-&gt;vert[0]-&gt;x + w-&gt;vert[1]-&gt;x + w-&gt;vert[2]-&gt;x) / 3;
1933   center-&gt;y = (w-&gt;vert[0]-&gt;y + w-&gt;vert[1]-&gt;y + w-&gt;vert[2]-&gt;y) / 3;
1934   center-&gt;z = (w-&gt;vert[0]-&gt;z + w-&gt;vert[1]-&gt;z + w-&gt;vert[2]-&gt;z) / 3;
1935 }
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
