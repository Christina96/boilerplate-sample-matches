
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 27, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>PINRemoteImage-MDEwOlJlcG9zaXRvcnkzOTUzNzEwMw==-flat-libwebp_go_wrap.c</h3>
            <pre><code>1  #define SWIGMODULE libwebp
2  #ifndef SWIGTEMPLATEDISAMBIGUATOR
3  # if defined(__SUNPRO_CC) && (__SUNPRO_CC <= 0x560)
4  #  define SWIGTEMPLATEDISAMBIGUATOR template
5  # elif defined(__HP_aCC)
6  #  define SWIGTEMPLATEDISAMBIGUATOR template
7  # else
8  #  define SWIGTEMPLATEDISAMBIGUATOR
9  # endif
10  #endif
11  #ifndef SWIGINLINE
12  # if defined(__cplusplus) || (defined(__GNUC__) && !defined(__STRICT_ANSI__))
13  #   define SWIGINLINE inline
14  # else
15  #   define SWIGINLINE
16  # endif
17  #endif
18  #ifndef SWIGUNUSED
19  # if defined(__GNUC__)
20  #   if !(defined(__cplusplus)) || (__GNUC__ > 3 || (__GNUC__ == 3 && __GNUC_MINOR__ >= 4))
21  #     define SWIGUNUSED __attribute__ ((__unused__))
22  #   else
23  #     define SWIGUNUSED
24  #   endif
25  # elif defined(__ICC)
26  #   define SWIGUNUSED __attribute__ ((__unused__))
27  # else
28  #   define SWIGUNUSED
29  # endif
30  #endif
31  #ifndef SWIG_MSC_UNSUPPRESS_4505
32  # if defined(_MSC_VER)
33  #   pragma warning(disable : 4505) &bsol;* unreferenced local function has been removed */
34  # endif
35  #endif
36  #ifndef SWIGUNUSEDPARM
37  # ifdef __cplusplus
38  #   define SWIGUNUSEDPARM(p)
39  # else
40  #   define SWIGUNUSEDPARM(p) p SWIGUNUSED
41  # endif
42  #endif
43  #ifndef SWIGINTERN
44  # define SWIGINTERN static SWIGUNUSED
45  #endif
46  #ifndef SWIGINTERNINLINE
47  # define SWIGINTERNINLINE SWIGINTERN SWIGINLINE
48  #endif
49  #if (__GNUC__ >= 4) || (__GNUC__ == 3 && __GNUC_MINOR__ >= 4)
50  #  ifndef GCC_HASCLASSVISIBILITY
51  #    define GCC_HASCLASSVISIBILITY
52  #  endif
53  #endif
54  #ifndef SWIGEXPORT
55  # if defined(_WIN32) || defined(__WIN32__) || defined(__CYGWIN__)
56  #   if defined(STATIC_LINKED)
57  #     define SWIGEXPORT
58  #   else
59  #     define SWIGEXPORT __declspec(dllexport)
60  #   endif
61  # else
62  #   if defined(__GNUC__) && defined(GCC_HASCLASSVISIBILITY)
63  #     define SWIGEXPORT __attribute__ ((visibility("default")))
64  #   else
65  #     define SWIGEXPORT
66  #   endif
67  # endif
68  #endif
69  #ifndef SWIGSTDCALL
70  # if defined(_WIN32) || defined(__WIN32__) || defined(__CYGWIN__)
71  #   define SWIGSTDCALL __stdcall
72  # else
73  #   define SWIGSTDCALL
74  # endif
75  #endif
76  #if !defined(SWIG_NO_CRT_SECURE_NO_DEPRECATE) && defined(_MSC_VER) && !defined(_CRT_SECURE_NO_DEPRECATE)
77  # define _CRT_SECURE_NO_DEPRECATE
78  #endif
79  #if !defined(SWIG_NO_SCL_SECURE_NO_DEPRECATE) && defined(_MSC_VER) && !defined(_SCL_SECURE_NO_DEPRECATE)
80  # define _SCL_SECURE_NO_DEPRECATE
81  #endif
82  #include <stddef.h>
83  #include <stdio.h>
84  #include <stdlib.h>
85  #include <string.h>
86  #include <sys/types.h>
87  typedef long long intgo;
88  typedef unsigned long long uintgo;
89  typedef struct { char *p; intgo n; } _gostring_;
90  typedef struct { void* array; intgo len; intgo cap; } _goslice_;
91  #define swiggo_size_assert_eq(x, y, name) typedef char name[(x-y)*(x-y)*-2+1];
92  #define swiggo_size_assert(t, n) swiggo_size_assert_eq(sizeof(t), n, swiggo_sizeof_##t##_is_not_##n)
93  swiggo_size_assert(char, 1)
94  swiggo_size_assert(short, 2)
95  swiggo_size_assert(int, 4)
96  typedef long long swiggo_long_long;
97  swiggo_size_assert(swiggo_long_long, 8)
98  swiggo_size_assert(float, 4)
99  swiggo_size_assert(double, 8)
100  #ifdef __cplusplus
101  extern "C" {
102  #endif
103  extern void crosscall2(void (*fn)(void *, int), void *, int);
104  extern void _cgo_allocate(void *, int);
105  extern void _cgo_panic(void *, int);
106  #ifdef __cplusplus
107  }
108  #endif
109  static void *_swig_goallocate(size_t len) {
110    struct {
111      size_t len;
112      void *ret;
113    } a;
114    a.len = len;
115    crosscall2(_cgo_allocate, &a, (int) sizeof a);
116    return a.ret;
117  }
118  static void _swig_gopanic(const char *p) {
119    struct {
120      const char *p;
121    } a;
122    a.p = p;
123    crosscall2(_cgo_panic, &a, (int) sizeof a);
124  }
125  static _gostring_ _swig_makegostring(const char *p, size_t l) {
126    _gostring_ ret;
127    ret.p = (char*)_swig_goallocate(l + 1);
128    memcpy(ret.p, p, l);
129    ret.n = l;
130    return ret;
131  }
132  #define SWIG_contract_assert(expr, msg) \
133    if (!(expr)) { _swig_gopanic(msg); } else
134  #define SWIG_exception(code, msg) _swig_gopanic(msg)
135  #include "webp/decode.h"
136  #include "webp/encode.h"
137  #ifdef __cplusplus
138  extern "C" {
139  #endif
140  void
141  _wrap_WebPGetDecoderVersion(void *swig_v)
142  {
143    int result;
144    struct swigargs {
145      long : 0;
146      intgo result;
147    } *swig_a = (struct swigargs *) swig_v;
148    result = (int)WebPGetDecoderVersion();
149    swig_a->result = result;
150  }
151  void
152  _wrap_wrapped_WebPGetInfo(void *swig_v)
153  {
154    uint8_t *arg1 = (uint8_t *) 0 ;
155    size_t arg2 ;
156    int *arg3 = (int *) 0 ;
157    int *arg4 = (int *) 0 ;
158    int temp3 ;
159    int temp4 ;
160    int result;
161    struct swigargs {
162      _gostring_ arg1;
163      _goslice_ arg3;
164      _goslice_ arg4;
165      long : 0;
166      intgo result;
167    } *swig_a = (struct swigargs *) swig_v;
168    arg1 = (uint8_t *)swig_a->arg1.p;
169    arg2 = (size_t)swig_a->arg1.n;
170    {
171      if (swig_a->arg3.len == 0) {
172        _swig_gopanic("array must contain at least 1 element");
173      }
174      arg3 = &temp3;
175    }
176    {
177      if (swig_a->arg4.len == 0) {
178        _swig_gopanic("array must contain at least 1 element");
179      }
<span onclick='openModal()' class='match'>180      arg4 = &temp4;
181    }
182    result = (int)WebPGetInfo((uint8_t const *)arg1,arg2,arg3,arg4);
183    swig_a->result = result;
</span>184    {
185      int* a = (int *) swig_a->arg3.array;
186      a[0] = temp3;
187    }
188    {
189      int* a = (int *) swig_a->arg4.array;
190      a[0] = temp4;
191    }
192  }
193  #ifdef __cplusplus
194  }
195  #endif
</code></pre>
        </div>
        <div class="column">
            <h3>PINRemoteImage-MDEwOlJlcG9zaXRvcnkzOTUzNzEwMw==-flat-libwebp_java_wrap.c</h3>
            <pre><code>1  #define SWIGJAVA
2  #ifndef SWIGTEMPLATEDISAMBIGUATOR
3  # if defined(__SUNPRO_CC) && (__SUNPRO_CC <= 0x560)
4  #  define SWIGTEMPLATEDISAMBIGUATOR template
5  # elif defined(__HP_aCC)
6  #  define SWIGTEMPLATEDISAMBIGUATOR template
7  # else
8  #  define SWIGTEMPLATEDISAMBIGUATOR
9  # endif
10  #endif
11  #ifndef SWIGINLINE
12  # if defined(__cplusplus) || (defined(__GNUC__) && !defined(__STRICT_ANSI__))
13  #   define SWIGINLINE inline
14  # else
15  #   define SWIGINLINE
16  # endif
17  #endif
18  #ifndef SWIGUNUSED
19  # if defined(__GNUC__)
20  #   if !(defined(__cplusplus)) || (__GNUC__ > 3 || (__GNUC__ == 3 && __GNUC_MINOR__ >= 4))
21  #     define SWIGUNUSED __attribute__ ((__unused__))
22  #   else
23  #     define SWIGUNUSED
24  #   endif
25  # elif defined(__ICC)
26  #   define SWIGUNUSED __attribute__ ((__unused__))
27  # else
28  #   define SWIGUNUSED
29  # endif
30  #endif
31  #ifndef SWIG_MSC_UNSUPPRESS_4505
32  # if defined(_MSC_VER)
33  #   pragma warning(disable : 4505) &bsol;* unreferenced local function has been removed */
34  # endif
35  #endif
36  #ifndef SWIGUNUSEDPARM
37  # ifdef __cplusplus
38  #   define SWIGUNUSEDPARM(p)
39  # else
40  #   define SWIGUNUSEDPARM(p) p SWIGUNUSED
41  # endif
42  #endif
43  #ifndef SWIGINTERN
44  # define SWIGINTERN static SWIGUNUSED
45  #endif
46  #ifndef SWIGINTERNINLINE
47  # define SWIGINTERNINLINE SWIGINTERN SWIGINLINE
48  #endif
49  #if (__GNUC__ >= 4) || (__GNUC__ == 3 && __GNUC_MINOR__ >= 4)
50  #  ifndef GCC_HASCLASSVISIBILITY
51  #    define GCC_HASCLASSVISIBILITY
52  #  endif
53  #endif
54  #ifndef SWIGEXPORT
55  # if defined(_WIN32) || defined(__WIN32__) || defined(__CYGWIN__)
56  #   if defined(STATIC_LINKED)
57  #     define SWIGEXPORT
58  #   else
59  #     define SWIGEXPORT __declspec(dllexport)
60  #   endif
61  # else
62  #   if defined(__GNUC__) && defined(GCC_HASCLASSVISIBILITY)
63  #     define SWIGEXPORT __attribute__ ((visibility("default")))
64  #   else
65  #     define SWIGEXPORT
66  #   endif
67  # endif
68  #endif
69  #ifndef SWIGSTDCALL
70  # if defined(_WIN32) || defined(__WIN32__) || defined(__CYGWIN__)
71  #   define SWIGSTDCALL __stdcall
72  # else
73  #   define SWIGSTDCALL
74  # endif
75  #endif
76  #if !defined(SWIG_NO_CRT_SECURE_NO_DEPRECATE) && defined(_MSC_VER) && !defined(_CRT_SECURE_NO_DEPRECATE)
77  # define _CRT_SECURE_NO_DEPRECATE
78  #endif
79  #if !defined(SWIG_NO_SCL_SECURE_NO_DEPRECATE) && defined(_MSC_VER) && !defined(_SCL_SECURE_NO_DEPRECATE)
80  # define _SCL_SECURE_NO_DEPRECATE
81  #endif
82  #if defined(__GNUC__) && !defined(__INTEL_COMPILER)
83    typedef long long __int64;
84  #endif
85  #if defined(__x86_64)
86  # ifdef _LP64
87  #   undef _LP64
88  # endif
89  #endif
90  #include <jni.h>
91  #include <stdlib.h>
92  #include <string.h>
93  typedef enum {
94    SWIG_JavaOutOfMemoryError = 1,
95    SWIG_JavaIOException,
96    SWIG_JavaRuntimeException,
97    SWIG_JavaIndexOutOfBoundsException,
98    SWIG_JavaArithmeticException,
99    SWIG_JavaIllegalArgumentException,
100    SWIG_JavaNullPointerException,
101    SWIG_JavaDirectorPureVirtual,
102    SWIG_JavaUnknownError
103  } SWIG_JavaExceptionCodes;
104  typedef struct {
105    SWIG_JavaExceptionCodes code;
106    const char *java_exception;
107  } SWIG_JavaExceptions_t;
108  static void SWIGUNUSED SWIG_JavaThrowException(JNIEnv *jenv, SWIG_JavaExceptionCodes code, const char *msg) {
109    jclass excep;
110    static const SWIG_JavaExceptions_t java_exceptions[] = {
111      { SWIG_JavaOutOfMemoryError, "java/lang/OutOfMemoryError" },
112      { SWIG_JavaIOException, "java/io/IOException" },
113      { SWIG_JavaRuntimeException, "java/lang/RuntimeException" },
114      { SWIG_JavaIndexOutOfBoundsException, "java/lang/IndexOutOfBoundsException" },
115      { SWIG_JavaArithmeticException, "java/lang/ArithmeticException" },
116      { SWIG_JavaIllegalArgumentException, "java/lang/IllegalArgumentException" },
117      { SWIG_JavaNullPointerException, "java/lang/NullPointerException" },
118      { SWIG_JavaDirectorPureVirtual, "java/lang/RuntimeException" },
119      { SWIG_JavaUnknownError,  "java/lang/UnknownError" },
120      { (SWIG_JavaExceptionCodes)0,  "java/lang/UnknownError" }
121    };
122    const SWIG_JavaExceptions_t *except_ptr = java_exceptions;
123    while (except_ptr->code != code && except_ptr->code)
124      except_ptr++;
125    (*jenv)->ExceptionClear(jenv);
126    excep = (*jenv)->FindClass(jenv, except_ptr->java_exception);
127    if (excep)
128      (*jenv)->ThrowNew(jenv, excep, msg);
129  }
130  #define SWIG_contract_assert(nullreturn, expr, msg) if (!(expr)) {SWIG_JavaThrowException(jenv, SWIG_JavaIllegalArgumentException, msg); return nullreturn; } else
131  #define  SWIG_UnknownError         -1
132  #define  SWIG_IOError              -2
133  #define  SWIG_RuntimeError         -3
134  #define  SWIG_IndexError           -4
135  #define  SWIG_TypeError            -5
136  #define  SWIG_DivisionByZero       -6
137  #define  SWIG_OverflowError        -7
138  #define  SWIG_SyntaxError          -8
139  #define  SWIG_ValueError           -9
140  #define  SWIG_SystemError          -10
141  #define  SWIG_AttributeError       -11
142  #define  SWIG_MemoryError          -12
143  #define  SWIG_NullReferenceError   -13
144  SWIGINTERN void SWIG_JavaException(JNIEnv *jenv, int code, const char *msg) {
145    SWIG_JavaExceptionCodes exception_code = SWIG_JavaUnknownError;
146    switch(code) {
147    case SWIG_MemoryError:
148      exception_code = SWIG_JavaOutOfMemoryError;
149      break;
150    case SWIG_IOError:
151      exception_code = SWIG_JavaIOException;
152      break;
153    case SWIG_SystemError:
154    case SWIG_RuntimeError:
155      exception_code = SWIG_JavaRuntimeException;
156      break;
157    case SWIG_OverflowError:
158    case SWIG_IndexError:
159      exception_code = SWIG_JavaIndexOutOfBoundsException;
160      break;
161    case SWIG_DivisionByZero:
162      exception_code = SWIG_JavaArithmeticException;
163      break;
164    case SWIG_SyntaxError:
165    case SWIG_ValueError:
166    case SWIG_TypeError:
167      exception_code = SWIG_JavaIllegalArgumentException;
168      break;
169    case SWIG_UnknownError:
170    default:
171      exception_code = SWIG_JavaUnknownError;
172      break;
173    }
174    SWIG_JavaThrowException(jenv, exception_code, msg);
175  }
176  #if defined(SWIG_NOINCLUDE) || defined(SWIG_NOARRAYS)
177  int SWIG_JavaArrayInSchar (JNIEnv *jenv, jbyte **jarr, signed char **carr, jbyteArray input);
178  void SWIG_JavaArrayArgoutSchar (JNIEnv *jenv, jbyte *jarr, signed char *carr, jbyteArray input);
179  jbyteArray SWIG_JavaArrayOutSchar (JNIEnv *jenv, signed char *result, jsize sz);
180  int SWIG_JavaArrayInUchar (JNIEnv *jenv, jshort **jarr, unsigned char **carr, jshortArray input);
181  void SWIG_JavaArrayArgoutUchar (JNIEnv *jenv, jshort *jarr, unsigned char *carr, jshortArray input);
182  jshortArray SWIG_JavaArrayOutUchar (JNIEnv *jenv, unsigned char *result, jsize sz);
183  int SWIG_JavaArrayInShort (JNIEnv *jenv, jshort **jarr, short **carr, jshortArray input);
184  void SWIG_JavaArrayArgoutShort (JNIEnv *jenv, jshort *jarr, short *carr, jshortArray input);
185  jshortArray SWIG_JavaArrayOutShort (JNIEnv *jenv, short *result, jsize sz);
186  int SWIG_JavaArrayInUshort (JNIEnv *jenv, jint **jarr, unsigned short **carr, jintArray input);
187  void SWIG_JavaArrayArgoutUshort (JNIEnv *jenv, jint *jarr, unsigned short *carr, jintArray input);
188  jintArray SWIG_JavaArrayOutUshort (JNIEnv *jenv, unsigned short *result, jsize sz);
189  int SWIG_JavaArrayInInt (JNIEnv *jenv, jint **jarr, int **carr, jintArray input);
190  void SWIG_JavaArrayArgoutInt (JNIEnv *jenv, jint *jarr, int *carr, jintArray input);
191  jintArray SWIG_JavaArrayOutInt (JNIEnv *jenv, int *result, jsize sz);
192  int SWIG_JavaArrayInUint (JNIEnv *jenv, jlong **jarr, unsigned int **carr, jlongArray input);
193  void SWIG_JavaArrayArgoutUint (JNIEnv *jenv, jlong *jarr, unsigned int *carr, jlongArray input);
194  jlongArray SWIG_JavaArrayOutUint (JNIEnv *jenv, unsigned int *result, jsize sz);
195  int SWIG_JavaArrayInLong (JNIEnv *jenv, jint **jarr, long **carr, jintArray input);
196  void SWIG_JavaArrayArgoutLong (JNIEnv *jenv, jint *jarr, long *carr, jintArray input);
197  jintArray SWIG_JavaArrayOutLong (JNIEnv *jenv, long *result, jsize sz);
198  int SWIG_JavaArrayInUlong (JNIEnv *jenv, jlong **jarr, unsigned long **carr, jlongArray input);
199  void SWIG_JavaArrayArgoutUlong (JNIEnv *jenv, jlong *jarr, unsigned long *carr, jlongArray input);
200  jlongArray SWIG_JavaArrayOutUlong (JNIEnv *jenv, unsigned long *result, jsize sz);
201  int SWIG_JavaArrayInLonglong (JNIEnv *jenv, jlong **jarr, jlong **carr, jlongArray input);
202  void SWIG_JavaArrayArgoutLonglong (JNIEnv *jenv, jlong *jarr, jlong *carr, jlongArray input);
203  jlongArray SWIG_JavaArrayOutLonglong (JNIEnv *jenv, jlong *result, jsize sz);
204  int SWIG_JavaArrayInFloat (JNIEnv *jenv, jfloat **jarr, float **carr, jfloatArray input);
205  void SWIG_JavaArrayArgoutFloat (JNIEnv *jenv, jfloat *jarr, float *carr, jfloatArray input);
206  jfloatArray SWIG_JavaArrayOutFloat (JNIEnv *jenv, float *result, jsize sz);
207  int SWIG_JavaArrayInDouble (JNIEnv *jenv, jdouble **jarr, double **carr, jdoubleArray input);
208  void SWIG_JavaArrayArgoutDouble (JNIEnv *jenv, jdouble *jarr, double *carr, jdoubleArray input);
209  jdoubleArray SWIG_JavaArrayOutDouble (JNIEnv *jenv, double *result, jsize sz);
210  #else
211  int SWIG_JavaArrayInSchar (JNIEnv *jenv, jbyte **jarr, signed char **carr, jbyteArray input) {
212    int i;
213    jsize sz;
214    if (!input) {
215      SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "null array");
216      return 0;
217    }
218    sz = (*jenv)->GetArrayLength(jenv, input);
219    *jarr = (*jenv)->GetByteArrayElements(jenv, input, 0);
220    if (!*jarr)
221      return 0;
222    *carr = (signed char*) calloc(sz, sizeof(signed char));
223    if (!*carr) {
224      SWIG_JavaThrowException(jenv, SWIG_JavaOutOfMemoryError, "array memory allocation failed");
225      return 0;
226    }
227    for (i=0; i<sz; i++)
228      (*carr)[i] = (signed char)(*jarr)[i];
229    return 1;
230  }
231  void SWIG_JavaArrayArgoutSchar (JNIEnv *jenv, jbyte *jarr, signed char *carr, jbyteArray input) {
232    int i;
233    jsize sz = (*jenv)->GetArrayLength(jenv, input);
234    for (i=0; i<sz; i++)
235      jarr[i] = (jbyte)carr[i];
236    (*jenv)->ReleaseByteArrayElements(jenv, input, jarr, 0);
237  }
238  jbyteArray SWIG_JavaArrayOutSchar (JNIEnv *jenv, signed char *result, jsize sz) {
239    jbyte *arr;
240    int i;
241    jbyteArray jresult = (*jenv)->NewByteArray(jenv, sz);
242    if (!jresult)
243      return NULL;
244    arr = (*jenv)->GetByteArrayElements(jenv, jresult, 0);
245    if (!arr)
246      return NULL;
247    for (i=0; i<sz; i++)
248      arr[i] = (jbyte)result[i];
249    (*jenv)->ReleaseByteArrayElements(jenv, jresult, arr, 0);
250    return jresult;
251  }
252  int SWIG_JavaArrayInUchar (JNIEnv *jenv, jshort **jarr, unsigned char **carr, jshortArray input) {
253    int i;
254    jsize sz;
255    if (!input) {
256      SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "null array");
257      return 0;
258    }
259    sz = (*jenv)->GetArrayLength(jenv, input);
260    *jarr = (*jenv)->GetShortArrayElements(jenv, input, 0);
261    if (!*jarr)
262      return 0;
263    *carr = (unsigned char*) calloc(sz, sizeof(unsigned char));
264    if (!*carr) {
265      SWIG_JavaThrowException(jenv, SWIG_JavaOutOfMemoryError, "array memory allocation failed");
266      return 0;
267    }
268    for (i=0; i<sz; i++)
269      (*carr)[i] = (unsigned char)(*jarr)[i];
270    return 1;
271  }
272  void SWIG_JavaArrayArgoutUchar (JNIEnv *jenv, jshort *jarr, unsigned char *carr, jshortArray input) {
273    int i;
274    jsize sz = (*jenv)->GetArrayLength(jenv, input);
275    for (i=0; i<sz; i++)
276      jarr[i] = (jshort)carr[i];
277    (*jenv)->ReleaseShortArrayElements(jenv, input, jarr, 0);
278  }
279  jshortArray SWIG_JavaArrayOutUchar (JNIEnv *jenv, unsigned char *result, jsize sz) {
280    jshort *arr;
281    int i;
282    jshortArray jresult = (*jenv)->NewShortArray(jenv, sz);
283    if (!jresult)
284      return NULL;
285    arr = (*jenv)->GetShortArrayElements(jenv, jresult, 0);
286    if (!arr)
287      return NULL;
288    for (i=0; i<sz; i++)
289      arr[i] = (jshort)result[i];
290    (*jenv)->ReleaseShortArrayElements(jenv, jresult, arr, 0);
291    return jresult;
292  }
293  int SWIG_JavaArrayInShort (JNIEnv *jenv, jshort **jarr, short **carr, jshortArray input) {
294    int i;
295    jsize sz;
296    if (!input) {
297      SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "null array");
298      return 0;
299    }
300    sz = (*jenv)->GetArrayLength(jenv, input);
301    *jarr = (*jenv)->GetShortArrayElements(jenv, input, 0);
302    if (!*jarr)
303      return 0;
304    *carr = (short*) calloc(sz, sizeof(short));
305    if (!*carr) {
306      SWIG_JavaThrowException(jenv, SWIG_JavaOutOfMemoryError, "array memory allocation failed");
307      return 0;
308    }
309    for (i=0; i<sz; i++)
310      (*carr)[i] = (short)(*jarr)[i];
311    return 1;
312  }
313  void SWIG_JavaArrayArgoutShort (JNIEnv *jenv, jshort *jarr, short *carr, jshortArray input) {
314    int i;
315    jsize sz = (*jenv)->GetArrayLength(jenv, input);
316    for (i=0; i<sz; i++)
317      jarr[i] = (jshort)carr[i];
318    (*jenv)->ReleaseShortArrayElements(jenv, input, jarr, 0);
319  }
320  jshortArray SWIG_JavaArrayOutShort (JNIEnv *jenv, short *result, jsize sz) {
321    jshort *arr;
322    int i;
323    jshortArray jresult = (*jenv)->NewShortArray(jenv, sz);
324    if (!jresult)
325      return NULL;
326    arr = (*jenv)->GetShortArrayElements(jenv, jresult, 0);
327    if (!arr)
328      return NULL;
329    for (i=0; i<sz; i++)
330      arr[i] = (jshort)result[i];
331    (*jenv)->ReleaseShortArrayElements(jenv, jresult, arr, 0);
332    return jresult;
333  }
334  int SWIG_JavaArrayInUshort (JNIEnv *jenv, jint **jarr, unsigned short **carr, jintArray input) {
335    int i;
336    jsize sz;
337    if (!input) {
338      SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "null array");
339      return 0;
340    }
341    sz = (*jenv)->GetArrayLength(jenv, input);
342    *jarr = (*jenv)->GetIntArrayElements(jenv, input, 0);
343    if (!*jarr)
344      return 0;
345    *carr = (unsigned short*) calloc(sz, sizeof(unsigned short));
346    if (!*carr) {
347      SWIG_JavaThrowException(jenv, SWIG_JavaOutOfMemoryError, "array memory allocation failed");
348      return 0;
349    }
350    for (i=0; i<sz; i++)
351      (*carr)[i] = (unsigned short)(*jarr)[i];
352    return 1;
353  }
354  void SWIG_JavaArrayArgoutUshort (JNIEnv *jenv, jint *jarr, unsigned short *carr, jintArray input) {
355    int i;
356    jsize sz = (*jenv)->GetArrayLength(jenv, input);
357    for (i=0; i<sz; i++)
358      jarr[i] = (jint)carr[i];
359    (*jenv)->ReleaseIntArrayElements(jenv, input, jarr, 0);
360  }
361  jintArray SWIG_JavaArrayOutUshort (JNIEnv *jenv, unsigned short *result, jsize sz) {
362    jint *arr;
363    int i;
364    jintArray jresult = (*jenv)->NewIntArray(jenv, sz);
365    if (!jresult)
366      return NULL;
367    arr = (*jenv)->GetIntArrayElements(jenv, jresult, 0);
368    if (!arr)
369      return NULL;
370    for (i=0; i<sz; i++)
371      arr[i] = (jint)result[i];
372    (*jenv)->ReleaseIntArrayElements(jenv, jresult, arr, 0);
373    return jresult;
374  }
375  int SWIG_JavaArrayInInt (JNIEnv *jenv, jint **jarr, int **carr, jintArray input) {
376    int i;
377    jsize sz;
378    if (!input) {
379      SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "null array");
380      return 0;
381    }
382    sz = (*jenv)->GetArrayLength(jenv, input);
383    *jarr = (*jenv)->GetIntArrayElements(jenv, input, 0);
384    if (!*jarr)
385      return 0;
386    *carr = (int*) calloc(sz, sizeof(int));
387    if (!*carr) {
388      SWIG_JavaThrowException(jenv, SWIG_JavaOutOfMemoryError, "array memory allocation failed");
389      return 0;
390    }
391    for (i=0; i<sz; i++)
392      (*carr)[i] = (int)(*jarr)[i];
393    return 1;
394  }
395  void SWIG_JavaArrayArgoutInt (JNIEnv *jenv, jint *jarr, int *carr, jintArray input) {
396    int i;
397    jsize sz = (*jenv)->GetArrayLength(jenv, input);
398    for (i=0; i<sz; i++)
399      jarr[i] = (jint)carr[i];
400    (*jenv)->ReleaseIntArrayElements(jenv, input, jarr, 0);
401  }
402  jintArray SWIG_JavaArrayOutInt (JNIEnv *jenv, int *result, jsize sz) {
403    jint *arr;
404    int i;
405    jintArray jresult = (*jenv)->NewIntArray(jenv, sz);
406    if (!jresult)
407      return NULL;
408    arr = (*jenv)->GetIntArrayElements(jenv, jresult, 0);
409    if (!arr)
410      return NULL;
411    for (i=0; i<sz; i++)
412      arr[i] = (jint)result[i];
413    (*jenv)->ReleaseIntArrayElements(jenv, jresult, arr, 0);
414    return jresult;
415  }
416  int SWIG_JavaArrayInUint (JNIEnv *jenv, jlong **jarr, unsigned int **carr, jlongArray input) {
417    int i;
418    jsize sz;
419    if (!input) {
420      SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "null array");
421      return 0;
422    }
423    sz = (*jenv)->GetArrayLength(jenv, input);
424    *jarr = (*jenv)->GetLongArrayElements(jenv, input, 0);
425    if (!*jarr)
426      return 0;
427    *carr = (unsigned int*) calloc(sz, sizeof(unsigned int));
428    if (!*carr) {
429      SWIG_JavaThrowException(jenv, SWIG_JavaOutOfMemoryError, "array memory allocation failed");
430      return 0;
431    }
432    for (i=0; i<sz; i++)
433      (*carr)[i] = (unsigned int)(*jarr)[i];
434    return 1;
435  }
436  void SWIG_JavaArrayArgoutUint (JNIEnv *jenv, jlong *jarr, unsigned int *carr, jlongArray input) {
437    int i;
438    jsize sz = (*jenv)->GetArrayLength(jenv, input);
439    for (i=0; i<sz; i++)
440      jarr[i] = (jlong)carr[i];
441    (*jenv)->ReleaseLongArrayElements(jenv, input, jarr, 0);
442  }
443  jlongArray SWIG_JavaArrayOutUint (JNIEnv *jenv, unsigned int *result, jsize sz) {
444    jlong *arr;
445    int i;
446    jlongArray jresult = (*jenv)->NewLongArray(jenv, sz);
447    if (!jresult)
448      return NULL;
449    arr = (*jenv)->GetLongArrayElements(jenv, jresult, 0);
450    if (!arr)
451      return NULL;
452    for (i=0; i<sz; i++)
453      arr[i] = (jlong)result[i];
454    (*jenv)->ReleaseLongArrayElements(jenv, jresult, arr, 0);
455    return jresult;
456  }
457  int SWIG_JavaArrayInLong (JNIEnv *jenv, jint **jarr, long **carr, jintArray input) {
458    int i;
459    jsize sz;
460    if (!input) {
461      SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "null array");
462      return 0;
463    }
464    sz = (*jenv)->GetArrayLength(jenv, input);
465    *jarr = (*jenv)->GetIntArrayElements(jenv, input, 0);
466    if (!*jarr)
467      return 0;
468    *carr = (long*) calloc(sz, sizeof(long));
469    if (!*carr) {
470      SWIG_JavaThrowException(jenv, SWIG_JavaOutOfMemoryError, "array memory allocation failed");
471      return 0;
472    }
473    for (i=0; i<sz; i++)
474      (*carr)[i] = (long)(*jarr)[i];
475    return 1;
476  }
477  void SWIG_JavaArrayArgoutLong (JNIEnv *jenv, jint *jarr, long *carr, jintArray input) {
478    int i;
479    jsize sz = (*jenv)->GetArrayLength(jenv, input);
480    for (i=0; i<sz; i++)
481      jarr[i] = (jint)carr[i];
482    (*jenv)->ReleaseIntArrayElements(jenv, input, jarr, 0);
483  }
484  jintArray SWIG_JavaArrayOutLong (JNIEnv *jenv, long *result, jsize sz) {
485    jint *arr;
486    int i;
487    jintArray jresult = (*jenv)->NewIntArray(jenv, sz);
488    if (!jresult)
489      return NULL;
490    arr = (*jenv)->GetIntArrayElements(jenv, jresult, 0);
491    if (!arr)
492      return NULL;
493    for (i=0; i<sz; i++)
494      arr[i] = (jint)result[i];
495    (*jenv)->ReleaseIntArrayElements(jenv, jresult, arr, 0);
496    return jresult;
497  }
498  int SWIG_JavaArrayInUlong (JNIEnv *jenv, jlong **jarr, unsigned long **carr, jlongArray input) {
499    int i;
500    jsize sz;
501    if (!input) {
502      SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "null array");
503      return 0;
504    }
505    sz = (*jenv)->GetArrayLength(jenv, input);
506    *jarr = (*jenv)->GetLongArrayElements(jenv, input, 0);
507    if (!*jarr)
508      return 0;
509    *carr = (unsigned long*) calloc(sz, sizeof(unsigned long));
510    if (!*carr) {
511      SWIG_JavaThrowException(jenv, SWIG_JavaOutOfMemoryError, "array memory allocation failed");
512      return 0;
513    }
514    for (i=0; i<sz; i++)
515      (*carr)[i] = (unsigned long)(*jarr)[i];
516    return 1;
517  }
518  void SWIG_JavaArrayArgoutUlong (JNIEnv *jenv, jlong *jarr, unsigned long *carr, jlongArray input) {
519    int i;
520    jsize sz = (*jenv)->GetArrayLength(jenv, input);
521    for (i=0; i<sz; i++)
522      jarr[i] = (jlong)carr[i];
523    (*jenv)->ReleaseLongArrayElements(jenv, input, jarr, 0);
524  }
525  jlongArray SWIG_JavaArrayOutUlong (JNIEnv *jenv, unsigned long *result, jsize sz) {
526    jlong *arr;
527    int i;
528    jlongArray jresult = (*jenv)->NewLongArray(jenv, sz);
529    if (!jresult)
530      return NULL;
531    arr = (*jenv)->GetLongArrayElements(jenv, jresult, 0);
532    if (!arr)
533      return NULL;
534    for (i=0; i<sz; i++)
535      arr[i] = (jlong)result[i];
536    (*jenv)->ReleaseLongArrayElements(jenv, jresult, arr, 0);
537    return jresult;
538  }
539  int SWIG_JavaArrayInLonglong (JNIEnv *jenv, jlong **jarr, jlong **carr, jlongArray input) {
540    int i;
541    jsize sz;
542    if (!input) {
543      SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "null array");
544      return 0;
545    }
546    sz = (*jenv)->GetArrayLength(jenv, input);
547    *jarr = (*jenv)->GetLongArrayElements(jenv, input, 0);
548    if (!*jarr)
549      return 0;
550    *carr = (jlong*) calloc(sz, sizeof(jlong));
551    if (!*carr) {
552      SWIG_JavaThrowException(jenv, SWIG_JavaOutOfMemoryError, "array memory allocation failed");
553      return 0;
554    }
555    for (i=0; i<sz; i++)
556      (*carr)[i] = (jlong)(*jarr)[i];
557    return 1;
558  }
559  void SWIG_JavaArrayArgoutLonglong (JNIEnv *jenv, jlong *jarr, jlong *carr, jlongArray input) {
560    int i;
561    jsize sz = (*jenv)->GetArrayLength(jenv, input);
562    for (i=0; i<sz; i++)
563      jarr[i] = (jlong)carr[i];
564    (*jenv)->ReleaseLongArrayElements(jenv, input, jarr, 0);
565  }
566  jlongArray SWIG_JavaArrayOutLonglong (JNIEnv *jenv, jlong *result, jsize sz) {
567    jlong *arr;
568    int i;
569    jlongArray jresult = (*jenv)->NewLongArray(jenv, sz);
570    if (!jresult)
571      return NULL;
572    arr = (*jenv)->GetLongArrayElements(jenv, jresult, 0);
573    if (!arr)
574      return NULL;
575    for (i=0; i<sz; i++)
576      arr[i] = (jlong)result[i];
577    (*jenv)->ReleaseLongArrayElements(jenv, jresult, arr, 0);
578    return jresult;
579  }
580  int SWIG_JavaArrayInFloat (JNIEnv *jenv, jfloat **jarr, float **carr, jfloatArray input) {
581    int i;
582    jsize sz;
583    if (!input) {
584      SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "null array");
585      return 0;
586    }
587    sz = (*jenv)->GetArrayLength(jenv, input);
588    *jarr = (*jenv)->GetFloatArrayElements(jenv, input, 0);
589    if (!*jarr)
590      return 0;
591    *carr = (float*) calloc(sz, sizeof(float));
592    if (!*carr) {
593      SWIG_JavaThrowException(jenv, SWIG_JavaOutOfMemoryError, "array memory allocation failed");
594      return 0;
595    }
596    for (i=0; i<sz; i++)
597      (*carr)[i] = (float)(*jarr)[i];
598    return 1;
599  }
600  void SWIG_JavaArrayArgoutFloat (JNIEnv *jenv, jfloat *jarr, float *carr, jfloatArray input) {
601    int i;
602    jsize sz = (*jenv)->GetArrayLength(jenv, input);
603    for (i=0; i<sz; i++)
604      jarr[i] = (jfloat)carr[i];
605    (*jenv)->ReleaseFloatArrayElements(jenv, input, jarr, 0);
606  }
607  jfloatArray SWIG_JavaArrayOutFloat (JNIEnv *jenv, float *result, jsize sz) {
608    jfloat *arr;
609    int i;
610    jfloatArray jresult = (*jenv)->NewFloatArray(jenv, sz);
611    if (!jresult)
612      return NULL;
613    arr = (*jenv)->GetFloatArrayElements(jenv, jresult, 0);
614    if (!arr)
615      return NULL;
616    for (i=0; i<sz; i++)
617      arr[i] = (jfloat)result[i];
618    (*jenv)->ReleaseFloatArrayElements(jenv, jresult, arr, 0);
619    return jresult;
620  }
621  int SWIG_JavaArrayInDouble (JNIEnv *jenv, jdouble **jarr, double **carr, jdoubleArray input) {
622    int i;
623    jsize sz;
624    if (!input) {
625      SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "null array");
626      return 0;
627    }
628    sz = (*jenv)->GetArrayLength(jenv, input);
629    *jarr = (*jenv)->GetDoubleArrayElements(jenv, input, 0);
630    if (!*jarr)
631      return 0;
632    *carr = (double*) calloc(sz, sizeof(double));
633    if (!*carr) {
634      SWIG_JavaThrowException(jenv, SWIG_JavaOutOfMemoryError, "array memory allocation failed");
635      return 0;
636    }
637    for (i=0; i<sz; i++)
638      (*carr)[i] = (double)(*jarr)[i];
639    return 1;
640  }
641  void SWIG_JavaArrayArgoutDouble (JNIEnv *jenv, jdouble *jarr, double *carr, jdoubleArray input) {
642    int i;
643    jsize sz = (*jenv)->GetArrayLength(jenv, input);
644    for (i=0; i<sz; i++)
645      jarr[i] = (jdouble)carr[i];
646    (*jenv)->ReleaseDoubleArrayElements(jenv, input, jarr, 0);
647  }
648  jdoubleArray SWIG_JavaArrayOutDouble (JNIEnv *jenv, double *result, jsize sz) {
649    jdouble *arr;
650    int i;
651    jdoubleArray jresult = (*jenv)->NewDoubleArray(jenv, sz);
652    if (!jresult)
653      return NULL;
654    arr = (*jenv)->GetDoubleArrayElements(jenv, jresult, 0);
655    if (!arr)
656      return NULL;
657    for (i=0; i<sz; i++)
658      arr[i] = (jdouble)result[i];
659    (*jenv)->ReleaseDoubleArrayElements(jenv, jresult, arr, 0);
660    return jresult;
661  }
662  #endif
663  #include "webp/types.h"
664  int SWIG_JavaArrayInUint8 (JNIEnv *jenv, jbyte **jarr, uint8_t **carr, jbyteArray input);
665  void SWIG_JavaArrayArgoutUint8 (JNIEnv *jenv, jbyte *jarr, uint8_t *carr, jbyteArray input);
666  jbyteArray SWIG_JavaArrayOutUint8 (JNIEnv *jenv, uint8_t *result, jsize sz);
667  int SWIG_JavaArrayInUint8 (JNIEnv *jenv, jbyte **jarr, uint8_t **carr, jbyteArray input) {
668    int i;
669    jsize sz;
670    if (!input) {
671      SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "null array");
672      return 0;
673    }
674    sz = (*jenv)->GetArrayLength(jenv, input);
675    *jarr = (*jenv)->GetByteArrayElements(jenv, input, 0);
676    if (!*jarr)
677      return 0;
678    *carr = (uint8_t*) calloc(sz, sizeof(uint8_t));
679    if (!*carr) {
680      SWIG_JavaThrowException(jenv, SWIG_JavaOutOfMemoryError, "array memory allocation failed");
681      return 0;
682    }
683    for (i=0; i<sz; i++)
684      (*carr)[i] = (uint8_t)(*jarr)[i];
685    return 1;
686  }
687  void SWIG_JavaArrayArgoutUint8 (JNIEnv *jenv, jbyte *jarr, uint8_t *carr, jbyteArray input) {
688    int i;
689    jsize sz = (*jenv)->GetArrayLength(jenv, input);
690    for (i=0; i<sz; i++)
691      jarr[i] = (jbyte)carr[i];
692    (*jenv)->ReleaseByteArrayElements(jenv, input, jarr, 0);
693  }
694  jbyteArray SWIG_JavaArrayOutUint8 (JNIEnv *jenv, uint8_t *result, jsize sz) {
695    jbyte *arr;
696    int i;
697    jbyteArray jresult = (*jenv)->NewByteArray(jenv, sz);
698    if (!jresult)
699      return NULL;
700    arr = (*jenv)->GetByteArrayElements(jenv, jresult, 0);
701    if (!arr)
702      return NULL;
703    for (i=0; i<sz; i++)
704      arr[i] = (jbyte)result[i];
705    (*jenv)->ReleaseByteArrayElements(jenv, jresult, arr, 0);
706    return jresult;
707  }
708  #include "webp/decode.h"
709  #include "webp/encode.h"
710  #define FillMeInAsSizeCannotBeDeterminedAutomatically \
711      (result ? (jint)ReturnedBufferSize(__FUNCTION__, arg3, arg4) : 0)
712  static size_t ReturnedBufferSize(
713      const char* function, int* width, int* height) {
714    static const struct sizemap {
715      const char* function;
716      int size_multiplier;
717    } size_map[] = {
718  #ifdef SWIGJAVA
719      { "Java_com_google_webp_libwebpJNI_WebPDecodeRGB",  3 },
720      { "Java_com_google_webp_libwebpJNI_WebPDecodeRGBA", 4 },
721      { "Java_com_google_webp_libwebpJNI_WebPDecodeARGB", 4 },
722      { "Java_com_google_webp_libwebpJNI_WebPDecodeBGR",  3 },
723      { "Java_com_google_webp_libwebpJNI_WebPDecodeBGRA", 4 },
724      { "Java_com_google_webp_libwebpJNI_wrap_1WebPEncodeRGB",  1 },
725      { "Java_com_google_webp_libwebpJNI_wrap_1WebPEncodeBGR",  1 },
726      { "Java_com_google_webp_libwebpJNI_wrap_1WebPEncodeRGBA", 1 },
727      { "Java_com_google_webp_libwebpJNI_wrap_1WebPEncodeBGRA", 1 },
728      { "Java_com_google_webp_libwebpJNI_wrap_1WebPEncodeLosslessRGB",  1 },
729      { "Java_com_google_webp_libwebpJNI_wrap_1WebPEncodeLosslessBGR",  1 },
730      { "Java_com_google_webp_libwebpJNI_wrap_1WebPEncodeLosslessRGBA", 1 },
731      { "Java_com_google_webp_libwebpJNI_wrap_1WebPEncodeLosslessBGRA", 1 },
732  #endif
733  #ifdef SWIGPYTHON
734      { "WebPDecodeRGB",  3 },
735      { "WebPDecodeRGBA", 4 },
736      { "WebPDecodeARGB", 4 },
737      { "WebPDecodeBGR",  3 },
738      { "WebPDecodeBGRA", 4 },
739      { "wrap_WebPEncodeRGB",  1 },
740      { "wrap_WebPEncodeBGR",  1 },
741      { "wrap_WebPEncodeRGBA", 1 },
742      { "wrap_WebPEncodeBGRA", 1 },
743      { "wrap_WebPEncodeLosslessRGB",  1 },
744      { "wrap_WebPEncodeLosslessBGR",  1 },
745      { "wrap_WebPEncodeLosslessRGBA", 1 },
746      { "wrap_WebPEncodeLosslessBGRA", 1 },
747  #endif
748      { NULL, 0 }
749    };
750    const struct sizemap* p;
751    size_t size = 0;
752    for (p = size_map; p->function; ++p) {
753      if (!strcmp(function, p->function)) {
754        size = *width * *height * p->size_multiplier;
755        break;
756      }
757    }
758    return size;
759  }
760  typedef size_t (*WebPEncodeFunction)(const uint8_t* rgb,
761                                       int width, int height, int stride,
762                                       float quality_factor, uint8_t** output);
763  typedef size_t (*WebPEncodeLosslessFunction)(const uint8_t* rgb,
764                                               int width, int height, int stride,
765                                               uint8_t** output);
766  static uint8_t* EncodeLossy(const uint8_t* rgb,
767                              int width, int height, int stride,
768                              float quality_factor,
769                              WebPEncodeFunction encfn,
770                              int* output_size, int* unused) {
771    uint8_t* output = NULL;
772    const size_t image_size =
773        encfn(rgb, width, height, stride, quality_factor, &output);
774    *output_size = image_size;
775    *unused = 1;
776    return image_size ? output : NULL;
777  }
778  static uint8_t* EncodeLossless(const uint8_t* rgb,
779                                 int width, int height, int stride,
780                                 WebPEncodeLosslessFunction encfn,
781                                 int* output_size, int* unused) {
782    uint8_t* output = NULL;
783    const size_t image_size = encfn(rgb, width, height, stride, &output);
784    *output_size = image_size;
785    *unused = 1;
786    return image_size ? output : NULL;
787  }
788  #define LOSSY_WRAPPER(FUNC)                                             \
789    static uint8_t* wrap_##FUNC(                                          \
790        const uint8_t* rgb, int* unused1, int* unused2, int* output_size, \
791        int width, int height, int stride, float quality_factor) {        \
792      return EncodeLossy(rgb, width, height, stride, quality_factor,      \
793                         FUNC, output_size, unused2);                     \
794    }                                                                     \
795  
796  LOSSY_WRAPPER(WebPEncodeRGB)
797  LOSSY_WRAPPER(WebPEncodeBGR)
798  LOSSY_WRAPPER(WebPEncodeRGBA)
799  LOSSY_WRAPPER(WebPEncodeBGRA)
800  #undef LOSSY_WRAPPER
801  #define LOSSLESS_WRAPPER(FUNC)                                          \
802    static uint8_t* wrap_##FUNC(                                          \
803        const uint8_t* rgb, int* unused1, int* unused2, int* output_size, \
804        int width, int height, int stride) {                              \
805      return EncodeLossless(rgb, width, height, stride,                   \
806                            FUNC, output_size, unused2);                  \
807    }                                                                     \
808  
809  LOSSLESS_WRAPPER(WebPEncodeLosslessRGB)
810  LOSSLESS_WRAPPER(WebPEncodeLosslessBGR)
811  LOSSLESS_WRAPPER(WebPEncodeLosslessRGBA)
812  LOSSLESS_WRAPPER(WebPEncodeLosslessBGRA)
813  #undef LOSSLESS_WRAPPER
814  #ifdef __GCJ_JNI_H__
815  # undef JNIEXPORT
816  # define JNIEXPORT
817  # undef JNICALL
818  # define JNICALL
819  #endif
820  #ifdef __cplusplus
821  extern "C" {
822  #endif
823  SWIGEXPORT jint JNICALL Java_com_google_webp_libwebpJNI_WebPGetDecoderVersion(JNIEnv *jenv, jclass jcls) {
824    jint jresult = 0 ;
825    int result;
826    (void)jenv;
827    (void)jcls;
828    result = (int)WebPGetDecoderVersion();
829    jresult = (jint)result;
830    return jresult;
831  }
832  SWIGEXPORT jint JNICALL Java_com_google_webp_libwebpJNI_WebPGetInfo(JNIEnv *jenv, jclass jcls, jbyteArray jarg1, jlong jarg2, jintArray jarg3, jintArray jarg4) {
833    jint jresult = 0 ;
834    uint8_t *arg1 = (uint8_t *) 0 ;
835    size_t arg2 ;
836    int *arg3 = (int *) 0 ;
837    int *arg4 = (int *) 0 ;
838    jbyte *jarr1 ;
839    int temp3 ;
840    int temp4 ;
841    int result;
842    (void)jenv;
843    (void)jcls;
844    if (!SWIG_JavaArrayInUint8(jenv, &jarr1, &arg1, jarg1)) return 0;
845    arg2 = (size_t)jarg2;
846    {
847      if (!jarg3) {
848        SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "array null");
849        return 0;
850      }
851      if ((*jenv)->GetArrayLength(jenv, jarg3) == 0) {
852        SWIG_JavaThrowException(jenv, SWIG_JavaIndexOutOfBoundsException, "Array must contain at least 1 element");
853        return 0;
854      }
855      arg3 = &temp3;
856    }
857    {
858      if (!jarg4) {
859        SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "array null");
860        return 0;
861      }
862      if ((*jenv)->GetArrayLength(jenv, jarg4) == 0) {
863        SWIG_JavaThrowException(jenv, SWIG_JavaIndexOutOfBoundsException, "Array must contain at least 1 element");
864        return 0;
865      }
<span onclick='openModal()' class='match'>866      arg4 = &temp4;
867    }
868    result = (int)WebPGetInfo((uint8_t const *)arg1,arg2,arg3,arg4);
869    jresult = (jint)result;
</span>870    SWIG_JavaArrayArgoutUint8(jenv, jarr1, arg1, jarg1);
871    {
872      jint jvalue = (jint)temp3;
873      (*jenv)->SetIntArrayRegion(jenv, jarg3, 0, 1, &jvalue);
874    }
875    {
876      jint jvalue = (jint)temp4;
877      (*jenv)->SetIntArrayRegion(jenv, jarg4, 0, 1, &jvalue);
878    }
879    free(arg1);
880    return jresult;
881  }
882  SWIGEXPORT jbyteArray JNICALL Java_com_google_webp_libwebpJNI_WebPDecodeRGB(JNIEnv *jenv, jclass jcls, jbyteArray jarg1, jlong jarg2, jintArray jarg3, jintArray jarg4) {
883    jbyteArray jresult = 0 ;
884    uint8_t *arg1 = (uint8_t *) 0 ;
885    size_t arg2 ;
886    int *arg3 = (int *) 0 ;
887    int *arg4 = (int *) 0 ;
888    jbyte *jarr1 ;
889    int temp3 ;
890    int temp4 ;
891    uint8_t *result = 0 ;
892    (void)jenv;
893    (void)jcls;
894    if (!SWIG_JavaArrayInUint8(jenv, &jarr1, &arg1, jarg1)) return 0;
895    arg2 = (size_t)jarg2;
896    {
897      if (!jarg3) {
898        SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "array null");
899        return 0;
900      }
901      if ((*jenv)->GetArrayLength(jenv, jarg3) == 0) {
902        SWIG_JavaThrowException(jenv, SWIG_JavaIndexOutOfBoundsException, "Array must contain at least 1 element");
903        return 0;
904      }
905      arg3 = &temp3;
906    }
907    {
908      if (!jarg4) {
909        SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "array null");
910        return 0;
911      }
912      if ((*jenv)->GetArrayLength(jenv, jarg4) == 0) {
913        SWIG_JavaThrowException(jenv, SWIG_JavaIndexOutOfBoundsException, "Array must contain at least 1 element");
914        return 0;
915      }
916      arg4 = &temp4;
917    }
918    result = (uint8_t *)WebPDecodeRGB((uint8_t const *)arg1,arg2,arg3,arg4);
919    jresult = SWIG_JavaArrayOutUint8(jenv, result, FillMeInAsSizeCannotBeDeterminedAutomatically);
920    SWIG_JavaArrayArgoutUint8(jenv, jarr1, arg1, jarg1);
921    {
922      jint jvalue = (jint)temp3;
923      (*jenv)->SetIntArrayRegion(jenv, jarg3, 0, 1, &jvalue);
924    }
925    {
926      jint jvalue = (jint)temp4;
927      (*jenv)->SetIntArrayRegion(jenv, jarg4, 0, 1, &jvalue);
928    }
929    free(arg1);
930    free(result);
931    return jresult;
932  }
933  SWIGEXPORT jbyteArray JNICALL Java_com_google_webp_libwebpJNI_WebPDecodeRGBA(JNIEnv *jenv, jclass jcls, jbyteArray jarg1, jlong jarg2, jintArray jarg3, jintArray jarg4) {
934    jbyteArray jresult = 0 ;
935    uint8_t *arg1 = (uint8_t *) 0 ;
936    size_t arg2 ;
937    int *arg3 = (int *) 0 ;
938    int *arg4 = (int *) 0 ;
939    jbyte *jarr1 ;
940    int temp3 ;
941    int temp4 ;
942    uint8_t *result = 0 ;
943    (void)jenv;
944    (void)jcls;
945    if (!SWIG_JavaArrayInUint8(jenv, &jarr1, &arg1, jarg1)) return 0;
946    arg2 = (size_t)jarg2;
947    {
948      if (!jarg3) {
949        SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "array null");
950        return 0;
951      }
952      if ((*jenv)->GetArrayLength(jenv, jarg3) == 0) {
953        SWIG_JavaThrowException(jenv, SWIG_JavaIndexOutOfBoundsException, "Array must contain at least 1 element");
954        return 0;
955      }
956      arg3 = &temp3;
957    }
958    {
959      if (!jarg4) {
960        SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "array null");
961        return 0;
962      }
963      if ((*jenv)->GetArrayLength(jenv, jarg4) == 0) {
964        SWIG_JavaThrowException(jenv, SWIG_JavaIndexOutOfBoundsException, "Array must contain at least 1 element");
965        return 0;
966      }
967      arg4 = &temp4;
968    }
969    result = (uint8_t *)WebPDecodeRGBA((uint8_t const *)arg1,arg2,arg3,arg4);
970    jresult = SWIG_JavaArrayOutUint8(jenv, result, FillMeInAsSizeCannotBeDeterminedAutomatically);
971    SWIG_JavaArrayArgoutUint8(jenv, jarr1, arg1, jarg1);
972    {
973      jint jvalue = (jint)temp3;
974      (*jenv)->SetIntArrayRegion(jenv, jarg3, 0, 1, &jvalue);
975    }
976    {
977      jint jvalue = (jint)temp4;
978      (*jenv)->SetIntArrayRegion(jenv, jarg4, 0, 1, &jvalue);
979    }
980    free(arg1);
981    free(result);
982    return jresult;
983  }
984  SWIGEXPORT jbyteArray JNICALL Java_com_google_webp_libwebpJNI_WebPDecodeARGB(JNIEnv *jenv, jclass jcls, jbyteArray jarg1, jlong jarg2, jintArray jarg3, jintArray jarg4) {
985    jbyteArray jresult = 0 ;
986    uint8_t *arg1 = (uint8_t *) 0 ;
987    size_t arg2 ;
988    int *arg3 = (int *) 0 ;
989    int *arg4 = (int *) 0 ;
990    jbyte *jarr1 ;
991    int temp3 ;
992    int temp4 ;
993    uint8_t *result = 0 ;
994    (void)jenv;
995    (void)jcls;
996    if (!SWIG_JavaArrayInUint8(jenv, &jarr1, &arg1, jarg1)) return 0;
997    arg2 = (size_t)jarg2;
998    {
999      if (!jarg3) {
1000        SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "array null");
1001        return 0;
1002      }
1003      if ((*jenv)->GetArrayLength(jenv, jarg3) == 0) {
1004        SWIG_JavaThrowException(jenv, SWIG_JavaIndexOutOfBoundsException, "Array must contain at least 1 element");
1005        return 0;
1006      }
1007      arg3 = &temp3;
1008    }
1009    {
1010      if (!jarg4) {
1011        SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "array null");
1012        return 0;
1013      }
1014      if ((*jenv)->GetArrayLength(jenv, jarg4) == 0) {
1015        SWIG_JavaThrowException(jenv, SWIG_JavaIndexOutOfBoundsException, "Array must contain at least 1 element");
1016        return 0;
1017      }
1018      arg4 = &temp4;
1019    }
1020    result = (uint8_t *)WebPDecodeARGB((uint8_t const *)arg1,arg2,arg3,arg4);
1021    jresult = SWIG_JavaArrayOutUint8(jenv, result, FillMeInAsSizeCannotBeDeterminedAutomatically);
1022    SWIG_JavaArrayArgoutUint8(jenv, jarr1, arg1, jarg1);
1023    {
1024      jint jvalue = (jint)temp3;
1025      (*jenv)->SetIntArrayRegion(jenv, jarg3, 0, 1, &jvalue);
1026    }
1027    {
1028      jint jvalue = (jint)temp4;
1029      (*jenv)->SetIntArrayRegion(jenv, jarg4, 0, 1, &jvalue);
1030    }
1031    free(arg1);
1032    free(result);
1033    return jresult;
1034  }
1035  SWIGEXPORT jbyteArray JNICALL Java_com_google_webp_libwebpJNI_WebPDecodeBGR(JNIEnv *jenv, jclass jcls, jbyteArray jarg1, jlong jarg2, jintArray jarg3, jintArray jarg4) {
1036    jbyteArray jresult = 0 ;
1037    uint8_t *arg1 = (uint8_t *) 0 ;
1038    size_t arg2 ;
1039    int *arg3 = (int *) 0 ;
1040    int *arg4 = (int *) 0 ;
1041    jbyte *jarr1 ;
1042    int temp3 ;
1043    int temp4 ;
1044    uint8_t *result = 0 ;
1045    (void)jenv;
1046    (void)jcls;
1047    if (!SWIG_JavaArrayInUint8(jenv, &jarr1, &arg1, jarg1)) return 0;
1048    arg2 = (size_t)jarg2;
1049    {
1050      if (!jarg3) {
1051        SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "array null");
1052        return 0;
1053      }
1054      if ((*jenv)->GetArrayLength(jenv, jarg3) == 0) {
1055        SWIG_JavaThrowException(jenv, SWIG_JavaIndexOutOfBoundsException, "Array must contain at least 1 element");
1056        return 0;
1057      }
1058      arg3 = &temp3;
1059    }
1060    {
1061      if (!jarg4) {
1062        SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "array null");
1063        return 0;
1064      }
1065      if ((*jenv)->GetArrayLength(jenv, jarg4) == 0) {
1066        SWIG_JavaThrowException(jenv, SWIG_JavaIndexOutOfBoundsException, "Array must contain at least 1 element");
1067        return 0;
1068      }
1069      arg4 = &temp4;
1070    }
1071    result = (uint8_t *)WebPDecodeBGR((uint8_t const *)arg1,arg2,arg3,arg4);
1072    jresult = SWIG_JavaArrayOutUint8(jenv, result, FillMeInAsSizeCannotBeDeterminedAutomatically);
1073    SWIG_JavaArrayArgoutUint8(jenv, jarr1, arg1, jarg1);
1074    {
1075      jint jvalue = (jint)temp3;
1076      (*jenv)->SetIntArrayRegion(jenv, jarg3, 0, 1, &jvalue);
1077    }
1078    {
1079      jint jvalue = (jint)temp4;
1080      (*jenv)->SetIntArrayRegion(jenv, jarg4, 0, 1, &jvalue);
1081    }
1082    free(arg1);
1083    free(result);
1084    return jresult;
1085  }
1086  SWIGEXPORT jbyteArray JNICALL Java_com_google_webp_libwebpJNI_WebPDecodeBGRA(JNIEnv *jenv, jclass jcls, jbyteArray jarg1, jlong jarg2, jintArray jarg3, jintArray jarg4) {
1087    jbyteArray jresult = 0 ;
1088    uint8_t *arg1 = (uint8_t *) 0 ;
1089    size_t arg2 ;
1090    int *arg3 = (int *) 0 ;
1091    int *arg4 = (int *) 0 ;
1092    jbyte *jarr1 ;
1093    int temp3 ;
1094    int temp4 ;
1095    uint8_t *result = 0 ;
1096    (void)jenv;
1097    (void)jcls;
1098    if (!SWIG_JavaArrayInUint8(jenv, &jarr1, &arg1, jarg1)) return 0;
1099    arg2 = (size_t)jarg2;
1100    {
1101      if (!jarg3) {
1102        SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "array null");
1103        return 0;
1104      }
1105      if ((*jenv)->GetArrayLength(jenv, jarg3) == 0) {
1106        SWIG_JavaThrowException(jenv, SWIG_JavaIndexOutOfBoundsException, "Array must contain at least 1 element");
1107        return 0;
1108      }
1109      arg3 = &temp3;
1110    }
1111    {
1112      if (!jarg4) {
1113        SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "array null");
1114        return 0;
1115      }
1116      if ((*jenv)->GetArrayLength(jenv, jarg4) == 0) {
1117        SWIG_JavaThrowException(jenv, SWIG_JavaIndexOutOfBoundsException, "Array must contain at least 1 element");
1118        return 0;
1119      }
1120      arg4 = &temp4;
1121    }
1122    result = (uint8_t *)WebPDecodeBGRA((uint8_t const *)arg1,arg2,arg3,arg4);
1123    jresult = SWIG_JavaArrayOutUint8(jenv, result, FillMeInAsSizeCannotBeDeterminedAutomatically);
1124    SWIG_JavaArrayArgoutUint8(jenv, jarr1, arg1, jarg1);
1125    {
1126      jint jvalue = (jint)temp3;
1127      (*jenv)->SetIntArrayRegion(jenv, jarg3, 0, 1, &jvalue);
1128    }
1129    {
1130      jint jvalue = (jint)temp4;
1131      (*jenv)->SetIntArrayRegion(jenv, jarg4, 0, 1, &jvalue);
1132    }
1133    free(arg1);
1134    free(result);
1135    return jresult;
1136  }
1137  SWIGEXPORT jint JNICALL Java_com_google_webp_libwebpJNI_WebPGetEncoderVersion(JNIEnv *jenv, jclass jcls) {
1138    jint jresult = 0 ;
1139    int result;
1140    (void)jenv;
1141    (void)jcls;
1142    result = (int)WebPGetEncoderVersion();
1143    jresult = (jint)result;
1144    return jresult;
1145  }
1146  SWIGEXPORT jbyteArray JNICALL Java_com_google_webp_libwebpJNI_wrap_1WebPEncodeRGB(JNIEnv *jenv, jclass jcls, jbyteArray jarg1, jint jarg2, jint jarg3, jintArray jarg4, jint jarg5, jint jarg6, jint jarg7, jfloat jarg8) {
1147    jbyteArray jresult = 0 ;
1148    uint8_t *arg1 = (uint8_t *) 0 ;
1149    int *arg2 = (int *) 0 ;
1150    int *arg3 = (int *) 0 ;
1151    int *arg4 = (int *) 0 ;
1152    int arg5 ;
1153    int arg6 ;
1154    int arg7 ;
1155    float arg8 ;
1156    jbyte *jarr1 ;
1157    int temp4 ;
1158    uint8_t *result = 0 ;
1159    (void)jenv;
1160    (void)jcls;
1161    if (!SWIG_JavaArrayInUint8(jenv, &jarr1, &arg1, jarg1)) return 0;
1162    arg2 = (int *)&jarg2;
1163    arg3 = (int *)&jarg3;
1164    {
1165      if (!jarg4) {
1166        SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "array null");
1167        return 0;
1168      }
1169      if ((*jenv)->GetArrayLength(jenv, jarg4) == 0) {
1170        SWIG_JavaThrowException(jenv, SWIG_JavaIndexOutOfBoundsException, "Array must contain at least 1 element");
1171        return 0;
1172      }
1173      arg4 = &temp4;
1174    }
1175    arg5 = (int)jarg5;
1176    arg6 = (int)jarg6;
1177    arg7 = (int)jarg7;
1178    arg8 = (float)jarg8;
1179    result = (uint8_t *)wrap_WebPEncodeRGB((uint8_t const *)arg1,arg2,arg3,arg4,arg5,arg6,arg7,arg8);
1180    jresult = SWIG_JavaArrayOutUint8(jenv, result, FillMeInAsSizeCannotBeDeterminedAutomatically);
1181    SWIG_JavaArrayArgoutUint8(jenv, jarr1, arg1, jarg1);
1182    {
1183      jint jvalue = (jint)temp4;
1184      (*jenv)->SetIntArrayRegion(jenv, jarg4, 0, 1, &jvalue);
1185    }
1186    free(arg1);
1187    free(result);
1188    return jresult;
1189  }
1190  SWIGEXPORT jbyteArray JNICALL Java_com_google_webp_libwebpJNI_wrap_1WebPEncodeBGR(JNIEnv *jenv, jclass jcls, jbyteArray jarg1, jint jarg2, jint jarg3, jintArray jarg4, jint jarg5, jint jarg6, jint jarg7, jfloat jarg8) {
1191    jbyteArray jresult = 0 ;
1192    uint8_t *arg1 = (uint8_t *) 0 ;
1193    int *arg2 = (int *) 0 ;
1194    int *arg3 = (int *) 0 ;
1195    int *arg4 = (int *) 0 ;
1196    int arg5 ;
1197    int arg6 ;
1198    int arg7 ;
1199    float arg8 ;
1200    jbyte *jarr1 ;
1201    int temp4 ;
1202    uint8_t *result = 0 ;
1203    (void)jenv;
1204    (void)jcls;
1205    if (!SWIG_JavaArrayInUint8(jenv, &jarr1, &arg1, jarg1)) return 0;
1206    arg2 = (int *)&jarg2;
1207    arg3 = (int *)&jarg3;
1208    {
1209      if (!jarg4) {
1210        SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "array null");
1211        return 0;
1212      }
1213      if ((*jenv)->GetArrayLength(jenv, jarg4) == 0) {
1214        SWIG_JavaThrowException(jenv, SWIG_JavaIndexOutOfBoundsException, "Array must contain at least 1 element");
1215        return 0;
1216      }
1217      arg4 = &temp4;
1218    }
1219    arg5 = (int)jarg5;
1220    arg6 = (int)jarg6;
1221    arg7 = (int)jarg7;
1222    arg8 = (float)jarg8;
1223    result = (uint8_t *)wrap_WebPEncodeBGR((uint8_t const *)arg1,arg2,arg3,arg4,arg5,arg6,arg7,arg8);
1224    jresult = SWIG_JavaArrayOutUint8(jenv, result, FillMeInAsSizeCannotBeDeterminedAutomatically);
1225    SWIG_JavaArrayArgoutUint8(jenv, jarr1, arg1, jarg1);
1226    {
1227      jint jvalue = (jint)temp4;
1228      (*jenv)->SetIntArrayRegion(jenv, jarg4, 0, 1, &jvalue);
1229    }
1230    free(arg1);
1231    free(result);
1232    return jresult;
1233  }
1234  SWIGEXPORT jbyteArray JNICALL Java_com_google_webp_libwebpJNI_wrap_1WebPEncodeRGBA(JNIEnv *jenv, jclass jcls, jbyteArray jarg1, jint jarg2, jint jarg3, jintArray jarg4, jint jarg5, jint jarg6, jint jarg7, jfloat jarg8) {
1235    jbyteArray jresult = 0 ;
1236    uint8_t *arg1 = (uint8_t *) 0 ;
1237    int *arg2 = (int *) 0 ;
1238    int *arg3 = (int *) 0 ;
1239    int *arg4 = (int *) 0 ;
1240    int arg5 ;
1241    int arg6 ;
1242    int arg7 ;
1243    float arg8 ;
1244    jbyte *jarr1 ;
1245    int temp4 ;
1246    uint8_t *result = 0 ;
1247    (void)jenv;
1248    (void)jcls;
1249    if (!SWIG_JavaArrayInUint8(jenv, &jarr1, &arg1, jarg1)) return 0;
1250    arg2 = (int *)&jarg2;
1251    arg3 = (int *)&jarg3;
1252    {
1253      if (!jarg4) {
1254        SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "array null");
1255        return 0;
1256      }
1257      if ((*jenv)->GetArrayLength(jenv, jarg4) == 0) {
1258        SWIG_JavaThrowException(jenv, SWIG_JavaIndexOutOfBoundsException, "Array must contain at least 1 element");
1259        return 0;
1260      }
1261      arg4 = &temp4;
1262    }
1263    arg5 = (int)jarg5;
1264    arg6 = (int)jarg6;
1265    arg7 = (int)jarg7;
1266    arg8 = (float)jarg8;
1267    result = (uint8_t *)wrap_WebPEncodeRGBA((uint8_t const *)arg1,arg2,arg3,arg4,arg5,arg6,arg7,arg8);
1268    jresult = SWIG_JavaArrayOutUint8(jenv, result, FillMeInAsSizeCannotBeDeterminedAutomatically);
1269    SWIG_JavaArrayArgoutUint8(jenv, jarr1, arg1, jarg1);
1270    {
1271      jint jvalue = (jint)temp4;
1272      (*jenv)->SetIntArrayRegion(jenv, jarg4, 0, 1, &jvalue);
1273    }
1274    free(arg1);
1275    free(result);
1276    return jresult;
1277  }
1278  SWIGEXPORT jbyteArray JNICALL Java_com_google_webp_libwebpJNI_wrap_1WebPEncodeBGRA(JNIEnv *jenv, jclass jcls, jbyteArray jarg1, jint jarg2, jint jarg3, jintArray jarg4, jint jarg5, jint jarg6, jint jarg7, jfloat jarg8) {
1279    jbyteArray jresult = 0 ;
1280    uint8_t *arg1 = (uint8_t *) 0 ;
1281    int *arg2 = (int *) 0 ;
1282    int *arg3 = (int *) 0 ;
1283    int *arg4 = (int *) 0 ;
1284    int arg5 ;
1285    int arg6 ;
1286    int arg7 ;
1287    float arg8 ;
1288    jbyte *jarr1 ;
1289    int temp4 ;
1290    uint8_t *result = 0 ;
1291    (void)jenv;
1292    (void)jcls;
1293    if (!SWIG_JavaArrayInUint8(jenv, &jarr1, &arg1, jarg1)) return 0;
1294    arg2 = (int *)&jarg2;
1295    arg3 = (int *)&jarg3;
1296    {
1297      if (!jarg4) {
1298        SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "array null");
1299        return 0;
1300      }
1301      if ((*jenv)->GetArrayLength(jenv, jarg4) == 0) {
1302        SWIG_JavaThrowException(jenv, SWIG_JavaIndexOutOfBoundsException, "Array must contain at least 1 element");
1303        return 0;
1304      }
1305      arg4 = &temp4;
1306    }
1307    arg5 = (int)jarg5;
1308    arg6 = (int)jarg6;
1309    arg7 = (int)jarg7;
1310    arg8 = (float)jarg8;
1311    result = (uint8_t *)wrap_WebPEncodeBGRA((uint8_t const *)arg1,arg2,arg3,arg4,arg5,arg6,arg7,arg8);
1312    jresult = SWIG_JavaArrayOutUint8(jenv, result, FillMeInAsSizeCannotBeDeterminedAutomatically);
1313    SWIG_JavaArrayArgoutUint8(jenv, jarr1, arg1, jarg1);
1314    {
1315      jint jvalue = (jint)temp4;
1316      (*jenv)->SetIntArrayRegion(jenv, jarg4, 0, 1, &jvalue);
1317    }
1318    free(arg1);
1319    free(result);
1320    return jresult;
1321  }
1322  SWIGEXPORT jbyteArray JNICALL Java_com_google_webp_libwebpJNI_wrap_1WebPEncodeLosslessRGB(JNIEnv *jenv, jclass jcls, jbyteArray jarg1, jint jarg2, jint jarg3, jintArray jarg4, jint jarg5, jint jarg6, jint jarg7) {
1323    jbyteArray jresult = 0 ;
1324    uint8_t *arg1 = (uint8_t *) 0 ;
1325    int *arg2 = (int *) 0 ;
1326    int *arg3 = (int *) 0 ;
1327    int *arg4 = (int *) 0 ;
1328    int arg5 ;
1329    int arg6 ;
1330    int arg7 ;
1331    jbyte *jarr1 ;
1332    int temp4 ;
1333    uint8_t *result = 0 ;
1334    (void)jenv;
1335    (void)jcls;
1336    if (!SWIG_JavaArrayInUint8(jenv, &jarr1, &arg1, jarg1)) return 0;
1337    arg2 = (int *)&jarg2;
1338    arg3 = (int *)&jarg3;
1339    {
1340      if (!jarg4) {
1341        SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "array null");
1342        return 0;
1343      }
1344      if ((*jenv)->GetArrayLength(jenv, jarg4) == 0) {
1345        SWIG_JavaThrowException(jenv, SWIG_JavaIndexOutOfBoundsException, "Array must contain at least 1 element");
1346        return 0;
1347      }
1348      arg4 = &temp4;
1349    }
1350    arg5 = (int)jarg5;
1351    arg6 = (int)jarg6;
1352    arg7 = (int)jarg7;
1353    result = (uint8_t *)wrap_WebPEncodeLosslessRGB((uint8_t const *)arg1,arg2,arg3,arg4,arg5,arg6,arg7);
1354    jresult = SWIG_JavaArrayOutUint8(jenv, result, FillMeInAsSizeCannotBeDeterminedAutomatically);
1355    SWIG_JavaArrayArgoutUint8(jenv, jarr1, arg1, jarg1);
1356    {
1357      jint jvalue = (jint)temp4;
1358      (*jenv)->SetIntArrayRegion(jenv, jarg4, 0, 1, &jvalue);
1359    }
1360    free(arg1);
1361    free(result);
1362    return jresult;
1363  }
1364  SWIGEXPORT jbyteArray JNICALL Java_com_google_webp_libwebpJNI_wrap_1WebPEncodeLosslessBGR(JNIEnv *jenv, jclass jcls, jbyteArray jarg1, jint jarg2, jint jarg3, jintArray jarg4, jint jarg5, jint jarg6, jint jarg7) {
1365    jbyteArray jresult = 0 ;
1366    uint8_t *arg1 = (uint8_t *) 0 ;
1367    int *arg2 = (int *) 0 ;
1368    int *arg3 = (int *) 0 ;
1369    int *arg4 = (int *) 0 ;
1370    int arg5 ;
1371    int arg6 ;
1372    int arg7 ;
1373    jbyte *jarr1 ;
1374    int temp4 ;
1375    uint8_t *result = 0 ;
1376    (void)jenv;
1377    (void)jcls;
1378    if (!SWIG_JavaArrayInUint8(jenv, &jarr1, &arg1, jarg1)) return 0;
1379    arg2 = (int *)&jarg2;
1380    arg3 = (int *)&jarg3;
1381    {
1382      if (!jarg4) {
1383        SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "array null");
1384        return 0;
1385      }
1386      if ((*jenv)->GetArrayLength(jenv, jarg4) == 0) {
1387        SWIG_JavaThrowException(jenv, SWIG_JavaIndexOutOfBoundsException, "Array must contain at least 1 element");
1388        return 0;
1389      }
1390      arg4 = &temp4;
1391    }
1392    arg5 = (int)jarg5;
1393    arg6 = (int)jarg6;
1394    arg7 = (int)jarg7;
1395    result = (uint8_t *)wrap_WebPEncodeLosslessBGR((uint8_t const *)arg1,arg2,arg3,arg4,arg5,arg6,arg7);
1396    jresult = SWIG_JavaArrayOutUint8(jenv, result, FillMeInAsSizeCannotBeDeterminedAutomatically);
1397    SWIG_JavaArrayArgoutUint8(jenv, jarr1, arg1, jarg1);
1398    {
1399      jint jvalue = (jint)temp4;
1400      (*jenv)->SetIntArrayRegion(jenv, jarg4, 0, 1, &jvalue);
1401    }
1402    free(arg1);
1403    free(result);
1404    return jresult;
1405  }
1406  SWIGEXPORT jbyteArray JNICALL Java_com_google_webp_libwebpJNI_wrap_1WebPEncodeLosslessRGBA(JNIEnv *jenv, jclass jcls, jbyteArray jarg1, jint jarg2, jint jarg3, jintArray jarg4, jint jarg5, jint jarg6, jint jarg7) {
1407    jbyteArray jresult = 0 ;
1408    uint8_t *arg1 = (uint8_t *) 0 ;
1409    int *arg2 = (int *) 0 ;
1410    int *arg3 = (int *) 0 ;
1411    int *arg4 = (int *) 0 ;
1412    int arg5 ;
1413    int arg6 ;
1414    int arg7 ;
1415    jbyte *jarr1 ;
1416    int temp4 ;
1417    uint8_t *result = 0 ;
1418    (void)jenv;
1419    (void)jcls;
1420    if (!SWIG_JavaArrayInUint8(jenv, &jarr1, &arg1, jarg1)) return 0;
1421    arg2 = (int *)&jarg2;
1422    arg3 = (int *)&jarg3;
1423    {
1424      if (!jarg4) {
1425        SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "array null");
1426        return 0;
1427      }
1428      if ((*jenv)->GetArrayLength(jenv, jarg4) == 0) {
1429        SWIG_JavaThrowException(jenv, SWIG_JavaIndexOutOfBoundsException, "Array must contain at least 1 element");
1430        return 0;
1431      }
1432      arg4 = &temp4;
1433    }
1434    arg5 = (int)jarg5;
1435    arg6 = (int)jarg6;
1436    arg7 = (int)jarg7;
1437    result = (uint8_t *)wrap_WebPEncodeLosslessRGBA((uint8_t const *)arg1,arg2,arg3,arg4,arg5,arg6,arg7);
1438    jresult = SWIG_JavaArrayOutUint8(jenv, result, FillMeInAsSizeCannotBeDeterminedAutomatically);
1439    SWIG_JavaArrayArgoutUint8(jenv, jarr1, arg1, jarg1);
1440    {
1441      jint jvalue = (jint)temp4;
1442      (*jenv)->SetIntArrayRegion(jenv, jarg4, 0, 1, &jvalue);
1443    }
1444    free(arg1);
1445    free(result);
1446    return jresult;
1447  }
1448  SWIGEXPORT jbyteArray JNICALL Java_com_google_webp_libwebpJNI_wrap_1WebPEncodeLosslessBGRA(JNIEnv *jenv, jclass jcls, jbyteArray jarg1, jint jarg2, jint jarg3, jintArray jarg4, jint jarg5, jint jarg6, jint jarg7) {
1449    jbyteArray jresult = 0 ;
1450    uint8_t *arg1 = (uint8_t *) 0 ;
1451    int *arg2 = (int *) 0 ;
1452    int *arg3 = (int *) 0 ;
1453    int *arg4 = (int *) 0 ;
1454    int arg5 ;
1455    int arg6 ;
1456    int arg7 ;
1457    jbyte *jarr1 ;
1458    int temp4 ;
1459    uint8_t *result = 0 ;
1460    (void)jenv;
1461    (void)jcls;
1462    if (!SWIG_JavaArrayInUint8(jenv, &jarr1, &arg1, jarg1)) return 0;
1463    arg2 = (int *)&jarg2;
1464    arg3 = (int *)&jarg3;
1465    {
1466      if (!jarg4) {
1467        SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "array null");
1468        return 0;
1469      }
1470      if ((*jenv)->GetArrayLength(jenv, jarg4) == 0) {
1471        SWIG_JavaThrowException(jenv, SWIG_JavaIndexOutOfBoundsException, "Array must contain at least 1 element");
1472        return 0;
1473      }
1474      arg4 = &temp4;
1475    }
1476    arg5 = (int)jarg5;
1477    arg6 = (int)jarg6;
1478    arg7 = (int)jarg7;
1479    result = (uint8_t *)wrap_WebPEncodeLosslessBGRA((uint8_t const *)arg1,arg2,arg3,arg4,arg5,arg6,arg7);
1480    jresult = SWIG_JavaArrayOutUint8(jenv, result, FillMeInAsSizeCannotBeDeterminedAutomatically);
1481    SWIG_JavaArrayArgoutUint8(jenv, jarr1, arg1, jarg1);
1482    {
1483      jint jvalue = (jint)temp4;
1484      (*jenv)->SetIntArrayRegion(jenv, jarg4, 0, 1, &jvalue);
1485    }
1486    free(arg1);
1487    free(result);
1488    return jresult;
1489  }
1490  #ifdef __cplusplus
1491  }
1492  #endif
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from PINRemoteImage-MDEwOlJlcG9zaXRvcnkzOTUzNzEwMw==-flat-libwebp_go_wrap.c</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from PINRemoteImage-MDEwOlJlcG9zaXRvcnkzOTUzNzEwMw==-flat-libwebp_java_wrap.c</div>
                </div>
                <div class="column column_space"><pre><code>180      arg4 = &temp4;
181    }
182    result = (int)WebPGetInfo((uint8_t const *)arg1,arg2,arg3,arg4);
183    swig_a->result = result;
</pre></code></div>
                <div class="column column_space"><pre><code>866      arg4 = &temp4;
867    }
868    result = (int)WebPGetInfo((uint8_t const *)arg1,arg2,arg3,arg4);
869    jresult = (jint)result;
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    