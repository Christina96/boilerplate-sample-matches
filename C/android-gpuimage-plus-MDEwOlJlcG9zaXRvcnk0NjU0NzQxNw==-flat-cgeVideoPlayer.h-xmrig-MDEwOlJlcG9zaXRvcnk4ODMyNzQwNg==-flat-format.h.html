
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 21, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>android-gpuimage-plus-MDEwOlJlcG9zaXRvcnk0NjU0NzQxNw==-flat-cgeVideoPlayer.h</h3>
            <pre><code>1  #if !defined(_CGEVIDEOPLAYER_H_) && defined(CGE_USE_FFMPEG)
2  #define _CGEVIDEOPLAYER_H_
3  #include "cgeGLFunctions.h"
4  #include "cgeVideoDecoder.h"
5  namespace CGE
6  {
7  class CGEVideoPlayerInterface
8  {
9  public:
10      CGEVideoPlayerInterface() {}
11      virtual ~CGEVideoPlayerInterface() {}
12      virtual bool open(const char* filename, CGEVideoDecodeHandler::SamplingStyle s = CGEVideoDecodeHandler::ssFastBilinear) { return false; }
13      virtual void close() {}
14      virtual void play() {}
15      virtual void stop() {}
<span onclick='openModal()' class='match'>16      virtual void pause() {}
17      virtual void resume() {}
18      virtual void render() {}
19      virtual bool update(double time) { return false; }
</span>20      virtual bool updateVideoFrame(CGEVideoFrameBufferData* data = nullptr) { return false; }
21      virtual bool nextVideoFrame() { return false; }
22      virtual bool seek(float position) { return false; }
23  protected:
24  };
25  class CGEVideoPlayerYUV420P : public CGEVideoPlayerInterface
26  {
27  public:
28      CGEVideoPlayerYUV420P();
29      ~CGEVideoPlayerYUV420P();
30      bool open(const char* filename, CGEVideoDecodeHandler::SamplingStyle s = CGEVideoDecodeHandler::ssFastBilinear);
31      bool initWithDecodeHandler(CGEVideoDecodeHandler*);
32      void close();
33      void play();
34      void stop();
35      void pause();
36      void resume();
37      bool update(double time);
38      void render();
39      void setRotation(float rad);
40      void setFlipScale(float x, float y);
41      CGEFrameTypeNext queryNextFrame() { return m_decodeHandler->queryNextFrame(); }
42      bool updateVideoFrame(const CGEVideoFrameBufferData* data = nullptr);
43      bool nextVideoFrame();
44      bool seek(float position);
45      GLuint getTextureY() { return m_texYUV[0]; }
46      GLuint getTextureU() { return m_texYUV[1]; }
47      GLuint getTextureV() { return m_texYUV[2]; }
48      CGEVideoDecodeHandler* getDecodeHandler() { return m_decodeHandler; }
49      int getLinesize() { return m_linesize[0]; }
50  protected:
51      ProgramObject m_program;
52      GLuint m_texYUV[3];
53      GLint m_texYLoc, m_texULoc, m_texVLoc;
54      GLuint m_posAttribLocation;
55      GLuint m_rotLoc, m_flipScaleLoc;
56      CGEVideoDecodeHandler* m_decodeHandler;
57      GLuint m_vertexBuffer;
58      int m_videoWidth, m_videoHeight;
59      int m_linesize[3];
60  };
61  } 
62  #endif
</code></pre>
        </div>
        <div class="column">
            <h3>xmrig-MDEwOlJlcG9zaXRvcnk4ODMyNzQwNg==-flat-format.h</h3>
            <pre><code>1  #ifndef FMT_FORMAT_H_
2  #define FMT_FORMAT_H_
3  #include <algorithm>
4  #include <cerrno>
5  #include <cmath>
6  #include <cstdint>
7  #include <limits>
8  #include <memory>
9  #include <stdexcept>
10  #include "core.h"
11  #ifdef __INTEL_COMPILER
12  #  define FMT_ICC_VERSION __INTEL_COMPILER
13  #elif defined(__ICL)
14  #  define FMT_ICC_VERSION __ICL
15  #else
16  #  define FMT_ICC_VERSION 0
17  #endif
18  #ifdef __NVCC__
19  #  define FMT_CUDA_VERSION (__CUDACC_VER_MAJOR__ * 100 + __CUDACC_VER_MINOR__)
20  #else
21  #  define FMT_CUDA_VERSION 0
22  #endif
23  #ifdef __has_builtin
24  #  define FMT_HAS_BUILTIN(x) __has_builtin(x)
25  #else
26  #  define FMT_HAS_BUILTIN(x) 0
27  #endif
28  #if FMT_GCC_VERSION || FMT_CLANG_VERSION
29  #  define FMT_NOINLINE __attribute__((noinline))
30  #else
31  #  define FMT_NOINLINE
32  #endif
33  #if __cplusplus == 201103L || __cplusplus == 201402L
34  #  if defined(__INTEL_COMPILER) || defined(__PGI)
35  #    define FMT_FALLTHROUGH
36  #  elif defined(__clang__)
37  #    define FMT_FALLTHROUGH [[clang::fallthrough]]
38  #  elif FMT_GCC_VERSION >= 700 && \
39        (!defined(__EDG_VERSION__) || __EDG_VERSION__ >= 520)
40  #    define FMT_FALLTHROUGH [[gnu::fallthrough]]
41  #  else
42  #    define FMT_FALLTHROUGH
43  #  endif
44  #elif FMT_HAS_CPP17_ATTRIBUTE(fallthrough) || \
45      (defined(_MSVC_LANG) && _MSVC_LANG >= 201703L)
46  #  define FMT_FALLTHROUGH [[fallthrough]]
47  #else
48  #  define FMT_FALLTHROUGH
49  #endif
50  #ifndef FMT_MAYBE_UNUSED
51  #  if FMT_HAS_CPP17_ATTRIBUTE(maybe_unused)
52  #    define FMT_MAYBE_UNUSED [[maybe_unused]]
53  #  else
54  #    define FMT_MAYBE_UNUSED
55  #  endif
56  #endif
57  #ifndef FMT_THROW
58  #  if FMT_EXCEPTIONS
59  #    if FMT_MSC_VER || FMT_NVCC
60  FMT_BEGIN_NAMESPACE
61  namespace detail {
62  template <typename Exception> inline void do_throw(const Exception& x) {
63    volatile bool b = true;
64    if (b) throw x;
65  }
66  }  
67  FMT_END_NAMESPACE
68  #      define FMT_THROW(x) detail::do_throw(x)
69  #    else
70  #      define FMT_THROW(x) throw x
71  #    endif
72  #  else
73  #    define FMT_THROW(x)              \
74        do {                            \
75          static_cast<void>(sizeof(x)); \
76          FMT_ASSERT(false, "");        \
77        } while (false)
78  #  endif
79  #endif
80  #if FMT_EXCEPTIONS
81  #  define FMT_TRY try
82  #  define FMT_CATCH(x) catch (x)
83  #else
84  #  define FMT_TRY if (true)
85  #  define FMT_CATCH(x) if (false)
86  #endif
87  #ifndef FMT_USE_USER_DEFINED_LITERALS
88  #  if (FMT_HAS_FEATURE(cxx_user_literals) || FMT_GCC_VERSION >= 407 || \
89         FMT_MSC_VER >= 1900) &&                                         \
90        (!defined(__EDG_VERSION__) || __EDG_VERSION__ >= &bsol;* UDL feature */ 480)
91  #    define FMT_USE_USER_DEFINED_LITERALS 1
92  #  else
93  #    define FMT_USE_USER_DEFINED_LITERALS 0
94  #  endif
95  #endif
96  #ifndef FMT_USE_UDL_TEMPLATE
97  #  if FMT_USE_USER_DEFINED_LITERALS &&                         \
98        (!defined(__EDG_VERSION__) || __EDG_VERSION__ >= 501) && \
99        ((FMT_GCC_VERSION >= 604 && __cplusplus >= 201402L) ||   \
100         FMT_CLANG_VERSION >= 304) &&                            \
101        !defined(__PGI) && !defined(__NVCC__)
102  #    define FMT_USE_UDL_TEMPLATE 1
103  #  else
104  #    define FMT_USE_UDL_TEMPLATE 0
105  #  endif
106  #endif
107  #ifndef FMT_USE_FLOAT
108  #  define FMT_USE_FLOAT 1
109  #endif
110  #ifndef FMT_USE_DOUBLE
111  #  define FMT_USE_DOUBLE 1
112  #endif
113  #ifndef FMT_USE_LONG_DOUBLE
114  #  define FMT_USE_LONG_DOUBLE 1
115  #endif
116  #if !defined(FMT_REDUCE_INT_INSTANTIATIONS)
117  #  define FMT_REDUCE_INT_INSTANTIATIONS 0
118  #endif
119  #if (FMT_GCC_VERSION || FMT_HAS_BUILTIN(__builtin_clz)) && !FMT_MSC_VER
120  #  define FMT_BUILTIN_CLZ(n) __builtin_clz(n)
121  #endif
122  #if (FMT_GCC_VERSION || FMT_HAS_BUILTIN(__builtin_clzll)) && !FMT_MSC_VER
123  #  define FMT_BUILTIN_CLZLL(n) __builtin_clzll(n)
124  #endif
125  #if (FMT_GCC_VERSION || FMT_HAS_BUILTIN(__builtin_ctz))
126  #  define FMT_BUILTIN_CTZ(n) __builtin_ctz(n)
127  #endif
128  #if (FMT_GCC_VERSION || FMT_HAS_BUILTIN(__builtin_ctzll))
129  #  define FMT_BUILTIN_CTZLL(n) __builtin_ctzll(n)
130  #endif
131  #if FMT_MSC_VER
132  #  include <intrin.h>  
133  #endif
134  #if FMT_MSC_VER && !defined(FMT_BUILTIN_CLZLL) && \
135      !defined(FMT_BUILTIN_CTZLL) && !defined(_MANAGED)
136  FMT_BEGIN_NAMESPACE
137  namespace detail {
138  #  ifndef __clang__
139  #    pragma intrinsic(_BitScanForward)
140  #    pragma intrinsic(_BitScanReverse)
141  #  endif
142  #  if defined(_WIN64) && !defined(__clang__)
143  #    pragma intrinsic(_BitScanForward64)
144  #    pragma intrinsic(_BitScanReverse64)
145  #  endif
146  inline int clz(uint32_t x) {
147    unsigned long r = 0;
148    _BitScanReverse(&r, x);
149    FMT_ASSERT(x != 0, "");
150    FMT_SUPPRESS_MSC_WARNING(6102)
151    return 31 ^ static_cast<int>(r);
152  }
153  #  define FMT_BUILTIN_CLZ(n) detail::clz(n)
154  inline int clzll(uint64_t x) {
155    unsigned long r = 0;
156  #  ifdef _WIN64
157    _BitScanReverse64(&r, x);
158  #  else
159    if (_BitScanReverse(&r, static_cast<uint32_t>(x >> 32))) return 63 ^ (r + 32);
160    _BitScanReverse(&r, static_cast<uint32_t>(x));
161  #  endif
162    FMT_ASSERT(x != 0, "");
163    FMT_SUPPRESS_MSC_WARNING(6102)  
164    return 63 ^ static_cast<int>(r);
165  }
166  #  define FMT_BUILTIN_CLZLL(n) detail::clzll(n)
167  inline int ctz(uint32_t x) {
168    unsigned long r = 0;
169    _BitScanForward(&r, x);
170    FMT_ASSERT(x != 0, "");
171    FMT_SUPPRESS_MSC_WARNING(6102)  
172    return static_cast<int>(r);
173  }
174  #  define FMT_BUILTIN_CTZ(n) detail::ctz(n)
175  inline int ctzll(uint64_t x) {
176    unsigned long r = 0;
177    FMT_ASSERT(x != 0, "");
178    FMT_SUPPRESS_MSC_WARNING(6102)  
179  #  ifdef _WIN64
180    _BitScanForward64(&r, x);
181  #  else
182    if (_BitScanForward(&r, static_cast<uint32_t>(x))) return static_cast<int>(r);
183    _BitScanForward(&r, static_cast<uint32_t>(x >> 32));
184    r += 32;
185  #  endif
186    return static_cast<int>(r);
187  }
188  #  define FMT_BUILTIN_CTZLL(n) detail::ctzll(n)
189  }  
190  FMT_END_NAMESPACE
191  #endif
192  #ifndef FMT_DEPRECATED_NUMERIC_ALIGN
193  #  define FMT_DEPRECATED_NUMERIC_ALIGN 0
194  #endif
195  FMT_BEGIN_NAMESPACE
196  namespace detail {
197  template <typename Dest, typename Source>
198  inline Dest bit_cast(const Source& source) {
199    static_assert(sizeof(Dest) == sizeof(Source), "size mismatch");
200    Dest dest;
201    std::memcpy(&dest, &source, sizeof(dest));
202    return dest;
203  }
204  inline bool is_big_endian() {
205    const auto u = 1u;
206    struct bytes {
207      char data[sizeof(u)];
208    };
209    return bit_cast<bytes>(u).data[0] == 0;
210  }
211  struct fallback_uintptr {
212    unsigned char value[sizeof(void*)];
213    fallback_uintptr() = default;
214    explicit fallback_uintptr(const void* p) {
215      *this = bit_cast<fallback_uintptr>(p);
216      if (is_big_endian()) {
217        for (size_t i = 0, j = sizeof(void*) - 1; i < j; ++i, --j)
218          std::swap(value[i], value[j]);
219      }
220    }
221  };
222  #ifdef UINTPTR_MAX
223  using uintptr_t = ::uintptr_t;
224  inline uintptr_t to_uintptr(const void* p) { return bit_cast<uintptr_t>(p); }
225  #else
226  using uintptr_t = fallback_uintptr;
227  inline fallback_uintptr to_uintptr(const void* p) {
228    return fallback_uintptr(p);
229  }
230  #endif
231  template <typename T> constexpr T max_value() {
232    return (std::numeric_limits<T>::max)();
233  }
234  template <typename T> constexpr int num_bits() {
235    return std::numeric_limits<T>::digits;
236  }
237  template <> constexpr int num_bits<int128_t>() { return 128; }
238  template <> constexpr int num_bits<uint128_t>() { return 128; }
239  template <> constexpr int num_bits<fallback_uintptr>() {
240    return static_cast<int>(sizeof(void*) *
241                            std::numeric_limits<unsigned char>::digits);
242  }
243  FMT_INLINE void assume(bool condition) {
244    (void)condition;
245  #if FMT_HAS_BUILTIN(__builtin_assume)
246    __builtin_assume(condition);
247  #endif
248  }
249  template <typename T>
250  using iterator_t = decltype(std::begin(std::declval<T&>()));
251  template <typename T> using sentinel_t = decltype(std::end(std::declval<T&>()));
252  template <typename Char> inline Char* get_data(std::basic_string<Char>& s) {
253    return &s[0];
254  }
255  template <typename Container>
256  inline typename Container::value_type* get_data(Container& c) {
257    return c.data();
258  }
259  #if defined(_SECURE_SCL) && _SECURE_SCL
260  template <typename T> using checked_ptr = stdext::checked_array_iterator<T*>;
261  template <typename T> checked_ptr<T> make_checked(T* p, size_t size) {
262    return {p, size};
263  }
264  #else
265  template <typename T> using checked_ptr = T*;
266  template <typename T> inline T* make_checked(T* p, size_t) { return p; }
267  #endif
268  template <typename Container, FMT_ENABLE_IF(is_contiguous<Container>::value)>
269  #if FMT_CLANG_VERSION
270  __attribute__((no_sanitize("undefined")))
271  #endif
272  inline checked_ptr<typename Container::value_type>
273  reserve(std::back_insert_iterator<Container> it, size_t n) {
274    Container& c = get_container(it);
275    size_t size = c.size();
276    c.resize(size + n);
277    return make_checked(get_data(c) + size, n);
278  }
279  template <typename T>
280  inline buffer_appender<T> reserve(buffer_appender<T> it, size_t n) {
281    buffer<T>& buf = get_container(it);
282    buf.try_reserve(buf.size() + n);
283    return it;
284  }
285  template <typename Iterator> inline Iterator& reserve(Iterator& it, size_t) {
286    return it;
287  }
288  template <typename T, typename OutputIt>
289  constexpr T* to_pointer(OutputIt, size_t) {
290    return nullptr;
291  }
292  template <typename T> T* to_pointer(buffer_appender<T> it, size_t n) {
293    buffer<T>& buf = get_container(it);
294    auto size = buf.size();
295    if (buf.capacity() < size + n) return nullptr;
296    buf.try_resize(size + n);
297    return buf.data() + size;
298  }
299  template <typename Container, FMT_ENABLE_IF(is_contiguous<Container>::value)>
300  inline std::back_insert_iterator<Container> base_iterator(
301      std::back_insert_iterator<Container>& it,
302      checked_ptr<typename Container::value_type>) {
303    return it;
304  }
305  template <typename Iterator>
306  inline Iterator base_iterator(Iterator, Iterator it) {
307    return it;
308  }
309  class counting_iterator {
310   private:
311    size_t count_;
312   public:
313    using iterator_category = std::output_iterator_tag;
314    using difference_type = std::ptrdiff_t;
315    using pointer = void;
316    using reference = void;
317    using _Unchecked_type = counting_iterator;  
318    struct value_type {
319      template <typename T> void operator=(const T&) {}
320    };
321    counting_iterator() : count_(0) {}
322    size_t count() const { return count_; }
323    counting_iterator& operator++() {
324      ++count_;
325      return *this;
326    }
327    counting_iterator operator++(int) {
328      auto it = *this;
329      ++*this;
330      return it;
331    }
332    friend counting_iterator operator+(counting_iterator it, difference_type n) {
333      it.count_ += static_cast<size_t>(n);
334      return it;
335    }
336    value_type operator*() const { return {}; }
337  };
338  template <typename OutputIt> class truncating_iterator_base {
339   protected:
340    OutputIt out_;
341    size_t limit_;
342    size_t count_;
343    truncating_iterator_base(OutputIt out, size_t limit)
344        : out_(out), limit_(limit), count_(0) {}
345   public:
346    using iterator_category = std::output_iterator_tag;
347    using value_type = typename std::iterator_traits<OutputIt>::value_type;
348    using difference_type = void;
349    using pointer = void;
350    using reference = void;
351    using _Unchecked_type =
352        truncating_iterator_base;  
353    OutputIt base() const { return out_; }
354    size_t count() const { return count_; }
355  };
356  template <typename OutputIt,
357            typename Enable = typename std::is_void<
358                typename std::iterator_traits<OutputIt>::value_type>::type>
359  class truncating_iterator;
360  template <typename OutputIt>
361  class truncating_iterator<OutputIt, std::false_type>
362      : public truncating_iterator_base<OutputIt> {
363    mutable typename truncating_iterator_base<OutputIt>::value_type blackhole_;
364   public:
365    using value_type = typename truncating_iterator_base<OutputIt>::value_type;
366    truncating_iterator(OutputIt out, size_t limit)
367        : truncating_iterator_base<OutputIt>(out, limit) {}
368    truncating_iterator& operator++() {
369      if (this->count_++ < this->limit_) ++this->out_;
370      return *this;
371    }
372    truncating_iterator operator++(int) {
373      auto it = *this;
374      ++*this;
375      return it;
376    }
377    value_type& operator*() const {
378      return this->count_ < this->limit_ ? *this->out_ : blackhole_;
379    }
380  };
381  template <typename OutputIt>
382  class truncating_iterator<OutputIt, std::true_type>
383      : public truncating_iterator_base<OutputIt> {
384   public:
385    truncating_iterator(OutputIt out, size_t limit)
386        : truncating_iterator_base<OutputIt>(out, limit) {}
387    template <typename T> truncating_iterator& operator=(T val) {
388      if (this->count_++ < this->limit_) *this->out_++ = val;
389      return *this;
390    }
391    truncating_iterator& operator++() { return *this; }
392    truncating_iterator& operator++(int) { return *this; }
393    truncating_iterator& operator*() { return *this; }
394  };
395  template <typename Char>
396  inline size_t count_code_points(basic_string_view<Char> s) {
397    return s.size();
398  }
399  inline size_t count_code_points(basic_string_view<char> s) {
400    const char* data = s.data();
401    size_t num_code_points = 0;
402    for (size_t i = 0, size = s.size(); i != size; ++i) {
403      if ((data[i] & 0xc0) != 0x80) ++num_code_points;
404    }
405    return num_code_points;
406  }
407  inline size_t count_code_points(basic_string_view<char8_type> s) {
408    return count_code_points(basic_string_view<char>(
409        reinterpret_cast<const char*>(s.data()), s.size()));
410  }
411  template <typename Char>
412  inline size_t code_point_index(basic_string_view<Char> s, size_t n) {
413    size_t size = s.size();
414    return n < size ? n : size;
415  }
416  inline size_t code_point_index(basic_string_view<char8_type> s, size_t n) {
417    const char8_type* data = s.data();
418    size_t num_code_points = 0;
419    for (size_t i = 0, size = s.size(); i != size; ++i) {
420      if ((data[i] & 0xc0) != 0x80 && ++num_code_points > n) {
421        return i;
422      }
423    }
424    return s.size();
425  }
426  template <typename InputIt, typename OutChar>
427  using needs_conversion = bool_constant<
428      std::is_same<typename std::iterator_traits<InputIt>::value_type,
429                   char>::value &&
430      std::is_same<OutChar, char8_type>::value>;
431  template <typename OutChar, typename InputIt, typename OutputIt,
432            FMT_ENABLE_IF(!needs_conversion<InputIt, OutChar>::value)>
433  OutputIt copy_str(InputIt begin, InputIt end, OutputIt it) {
434    return std::copy(begin, end, it);
435  }
436  template <typename OutChar, typename InputIt, typename OutputIt,
437            FMT_ENABLE_IF(needs_conversion<InputIt, OutChar>::value)>
438  OutputIt copy_str(InputIt begin, InputIt end, OutputIt it) {
439    return std::transform(begin, end, it,
440                          [](char c) { return static_cast<char8_type>(c); });
441  }
442  template <typename Char, typename InputIt>
443  inline counting_iterator copy_str(InputIt begin, InputIt end,
444                                    counting_iterator it) {
445    return it + (end - begin);
446  }
447  template <typename T>
448  using is_fast_float = bool_constant<std::numeric_limits<T>::is_iec559 &&
449                                      sizeof(T) <= sizeof(double)>;
450  #ifndef FMT_USE_FULL_CACHE_DRAGONBOX
451  #  define FMT_USE_FULL_CACHE_DRAGONBOX 0
452  #endif
453  template <typename T>
454  template <typename U>
455  void buffer<T>::append(const U* begin, const U* end) {
456    do {
457      auto count = to_unsigned(end - begin);
458      try_reserve(size_ + count);
459      auto free_cap = capacity_ - size_;
460      if (free_cap < count) count = free_cap;
461      std::uninitialized_copy_n(begin, count, make_checked(ptr_ + size_, count));
462      size_ += count;
463      begin += count;
464    } while (begin != end);
465  }
466  template <typename OutputIt, typename T, typename Traits>
467  void iterator_buffer<OutputIt, T, Traits>::flush() {
468    out_ = std::copy_n(data_, this->limit(this->size()), out_);
469    this->clear();
470  }
471  }  
472  enum { inline_buffer_size = 500 };
473  template <typename T, size_t SIZE = inline_buffer_size,
474            typename Allocator = std::allocator<T>>
475  class basic_memory_buffer : public detail::buffer<T> {
476   private:
477    T store_[SIZE];
478    Allocator alloc_;
479    void deallocate() {
480      T* data = this->data();
481      if (data != store_) alloc_.deallocate(data, this->capacity());
482    }
483   protected:
484    void grow(size_t size) final FMT_OVERRIDE;
485   public:
486    using value_type = T;
487    using const_reference = const T&;
488    explicit basic_memory_buffer(const Allocator& alloc = Allocator())
489        : alloc_(alloc) {
490      this->set(store_, SIZE);
491    }
492    ~basic_memory_buffer() { deallocate(); }
493   private:
494    void move(basic_memory_buffer& other) {
495      alloc_ = std::move(other.alloc_);
496      T* data = other.data();
497      size_t size = other.size(), capacity = other.capacity();
498      if (data == other.store_) {
499        this->set(store_, capacity);
500        std::uninitialized_copy(other.store_, other.store_ + size,
501                                detail::make_checked(store_, capacity));
502      } else {
503        this->set(data, capacity);
504        other.set(other.store_, 0);
505      }
506      this->resize(size);
507    }
508   public:
509    basic_memory_buffer(basic_memory_buffer&& other) FMT_NOEXCEPT { move(other); }
510    basic_memory_buffer& operator=(basic_memory_buffer&& other) FMT_NOEXCEPT {
511      FMT_ASSERT(this != &other, "");
512      deallocate();
513      move(other);
514      return *this;
515    }
516    Allocator get_allocator() const { return alloc_; }
517    void resize(size_t count) { this->try_resize(count); }
518    void reserve(size_t new_capacity) { this->try_reserve(new_capacity); }
519    using detail::buffer<T>::append;
520    template <typename ContiguousRange>
521    void append(const ContiguousRange& range) {
522      append(range.data(), range.data() + range.size());
523    }
524  };
525  template <typename T, size_t SIZE, typename Allocator>
526  void basic_memory_buffer<T, SIZE, Allocator>::grow(size_t size) {
527  #ifdef FMT_FUZZ
528    if (size > 5000) throw std::runtime_error("fuzz mode - won't grow that much");
529  #endif
530    size_t old_capacity = this->capacity();
531    size_t new_capacity = old_capacity + old_capacity / 2;
532    if (size > new_capacity) new_capacity = size;
533    T* old_data = this->data();
534    T* new_data =
535        std::allocator_traits<Allocator>::allocate(alloc_, new_capacity);
536    std::uninitialized_copy(old_data, old_data + this->size(),
537                            detail::make_checked(new_data, new_capacity));
538    this->set(new_data, new_capacity);
539    if (old_data != store_) alloc_.deallocate(old_data, old_capacity);
540  }
541  using memory_buffer = basic_memory_buffer<char>;
542  using wmemory_buffer = basic_memory_buffer<wchar_t>;
543  template <typename T, size_t SIZE, typename Allocator>
544  struct is_contiguous<basic_memory_buffer<T, SIZE, Allocator>> : std::true_type {
545  };
546  FMT_CLASS_API
547  class FMT_API format_error : public std::runtime_error {
548   public:
549    explicit format_error(const char* message) : std::runtime_error(message) {}
550    explicit format_error(const std::string& message)
551        : std::runtime_error(message) {}
552    format_error(const format_error&) = default;
553    format_error& operator=(const format_error&) = default;
554    format_error(format_error&&) = default;
555    format_error& operator=(format_error&&) = default;
556    ~format_error() FMT_NOEXCEPT FMT_OVERRIDE;
557  };
558  namespace detail {
559  template <typename T>
560  using is_signed =
561      std::integral_constant<bool, std::numeric_limits<T>::is_signed ||
562                                       std::is_same<T, int128_t>::value>;
563  template <typename T, FMT_ENABLE_IF(is_signed<T>::value)>
564  FMT_CONSTEXPR bool is_negative(T value) {
565    return value < 0;
566  }
567  template <typename T, FMT_ENABLE_IF(!is_signed<T>::value)>
568  FMT_CONSTEXPR bool is_negative(T) {
569    return false;
570  }
571  template <typename T, FMT_ENABLE_IF(std::is_floating_point<T>::value)>
572  FMT_CONSTEXPR bool is_supported_floating_point(T) {
573    return (std::is_same<T, float>::value && FMT_USE_FLOAT) ||
574           (std::is_same<T, double>::value && FMT_USE_DOUBLE) ||
575           (std::is_same<T, long double>::value && FMT_USE_LONG_DOUBLE);
576  }
577  template <typename T>
578  using uint32_or_64_or_128_t =
579      conditional_t<num_bits<T>() <= 32 && !FMT_REDUCE_INT_INSTANTIATIONS,
580                    uint32_t,
581                    conditional_t<num_bits<T>() <= 64, uint64_t, uint128_t>>;
582  struct FMT_EXTERN_TEMPLATE_API uint128_wrapper {
583    uint128_wrapper() = default;
584  #if FMT_USE_INT128
585    uint128_t internal_;
586    uint128_wrapper(uint64_t high, uint64_t low) FMT_NOEXCEPT
587        : internal_{static_cast<uint128_t>(low) |
588                    (static_cast<uint128_t>(high) << 64)} {}
589    uint128_wrapper(uint128_t u) : internal_{u} {}
590    uint64_t high() const FMT_NOEXCEPT { return uint64_t(internal_ >> 64); }
591    uint64_t low() const FMT_NOEXCEPT { return uint64_t(internal_); }
592    uint128_wrapper& operator+=(uint64_t n) & FMT_NOEXCEPT {
593      internal_ += n;
594      return *this;
595    }
596  #else
597    uint64_t high_;
598    uint64_t low_;
599    uint128_wrapper(uint64_t high, uint64_t low) FMT_NOEXCEPT : high_{high},
600                                                                low_{low} {}
601    uint64_t high() const FMT_NOEXCEPT { return high_; }
602    uint64_t low() const FMT_NOEXCEPT { return low_; }
603    uint128_wrapper& operator+=(uint64_t n) & FMT_NOEXCEPT {
604  #  if defined(_MSC_VER) && defined(_M_X64)
605      unsigned char carry = _addcarry_u64(0, low_, n, &low_);
606      _addcarry_u64(carry, high_, 0, &high_);
607      return *this;
608  #  else
609      uint64_t sum = low_ + n;
610      high_ += (sum < low_ ? 1 : 0);
611      low_ = sum;
612      return *this;
613  #  endif
614    }
615  #endif
616  };
617  template <typename T> struct FMT_EXTERN_TEMPLATE_API divtest_table_entry {
618    T mod_inv;
619    T max_quotient;
620  };
621  template <typename T = void> struct FMT_EXTERN_TEMPLATE_API basic_data {
622    static const uint64_t powers_of_10_64[];
623    static const uint32_t zero_or_powers_of_10_32[];
624    static const uint64_t zero_or_powers_of_10_64[];
625    static const uint64_t grisu_pow10_significands[];
626    static const int16_t grisu_pow10_exponents[];
627    static const divtest_table_entry<uint32_t> divtest_table_for_pow5_32[];
628    static const divtest_table_entry<uint64_t> divtest_table_for_pow5_64[];
629    static const uint64_t dragonbox_pow10_significands_64[];
630    static const uint128_wrapper dragonbox_pow10_significands_128[];
631    static const uint64_t log10_2_significand = 0x4d104d427de7fbcc;
632  #if !FMT_USE_FULL_CACHE_DRAGONBOX
633    static const uint64_t powers_of_5_64[];
634    static const uint32_t dragonbox_pow10_recovery_errors[];
635  #endif
636    using digit_pair = char[2];
637    static const digit_pair digits[];
638    static const char hex_digits[];
639    static const char foreground_color[];
640    static const char background_color[];
641    static const char reset_color[5];
642    static const wchar_t wreset_color[5];
643    static const char signs[];
644    static const char left_padding_shifts[5];
645    static const char right_padding_shifts[5];
646  };
647  FMT_INLINE uint16_t bsr2log10(int bsr) {
648    static constexpr uint16_t data[] = {
649        1,  1,  1,  2,  2,  2,  3,  3,  3,  4,  4,  4,  4,  5,  5,  5,
650        6,  6,  6,  7,  7,  7,  7,  8,  8,  8,  9,  9,  9,  10, 10, 10,
651        10, 11, 11, 11, 12, 12, 12, 13, 13, 13, 13, 14, 14, 14, 15, 15,
652        15, 16, 16, 16, 16, 17, 17, 17, 18, 18, 18, 19, 19, 19, 19, 20};
653    return data[bsr];
654  }
655  #ifndef FMT_EXPORTED
656  FMT_EXTERN template struct basic_data<void>;
657  #endif
658  struct data : basic_data<> {};
659  #ifdef FMT_BUILTIN_CLZLL
660  inline int count_digits(uint64_t n) {
661    auto t = bsr2log10(FMT_BUILTIN_CLZLL(n | 1) ^ 63);
662    return t - (n < data::zero_or_powers_of_10_64[t]);
663  }
664  #else
665  inline int count_digits(uint64_t n) {
666    int count = 1;
667    for (;;) {
668      if (n < 10) return count;
669      if (n < 100) return count + 1;
670      if (n < 1000) return count + 2;
671      if (n < 10000) return count + 3;
672      n /= 10000u;
673      count += 4;
674    }
675  }
676  #endif
677  #if FMT_USE_INT128
678  inline int count_digits(uint128_t n) {
679    int count = 1;
680    for (;;) {
681      if (n < 10) return count;
682      if (n < 100) return count + 1;
683      if (n < 1000) return count + 2;
684      if (n < 10000) return count + 3;
685      n /= 10000U;
686      count += 4;
687    }
688  }
689  #endif
690  template <unsigned BITS, typename UInt> inline int count_digits(UInt n) {
691    int num_digits = 0;
692    do {
693      ++num_digits;
694    } while ((n >>= BITS) != 0);
695    return num_digits;
696  }
697  template <> int count_digits<4>(detail::fallback_uintptr n);
698  #if FMT_GCC_VERSION || FMT_CLANG_VERSION
699  #  define FMT_ALWAYS_INLINE inline __attribute__((always_inline))
700  #elif FMT_MSC_VER
701  #  define FMT_ALWAYS_INLINE __forceinline
702  #else
703  #  define FMT_ALWAYS_INLINE inline
704  #endif
705  #if FMT_MSC_VER && !FMT_CLANG_VERSION
706  #  define FMT_SAFEBUFFERS __declspec(safebuffers)
707  #else
708  #  define FMT_SAFEBUFFERS
709  #endif
710  #ifdef FMT_BUILTIN_CLZ
711  inline int count_digits(uint32_t n) {
712    auto t = bsr2log10(FMT_BUILTIN_CLZ(n | 1) ^ 31);
713    return t - (n < data::zero_or_powers_of_10_32[t]);
714  }
715  #endif
716  template <typename Int> constexpr int digits10() FMT_NOEXCEPT {
717    return std::numeric_limits<Int>::digits10;
718  }
719  template <> constexpr int digits10<int128_t>() FMT_NOEXCEPT { return 38; }
720  template <> constexpr int digits10<uint128_t>() FMT_NOEXCEPT { return 38; }
721  template <typename Char> FMT_API std::string grouping_impl(locale_ref loc);
722  template <typename Char> inline std::string grouping(locale_ref loc) {
723    return grouping_impl<char>(loc);
724  }
725  template <> inline std::string grouping<wchar_t>(locale_ref loc) {
726    return grouping_impl<wchar_t>(loc);
727  }
728  template <typename Char> FMT_API Char thousands_sep_impl(locale_ref loc);
729  template <typename Char> inline Char thousands_sep(locale_ref loc) {
730    return Char(thousands_sep_impl<char>(loc));
731  }
732  template <> inline wchar_t thousands_sep(locale_ref loc) {
733    return thousands_sep_impl<wchar_t>(loc);
734  }
735  template <typename Char> FMT_API Char decimal_point_impl(locale_ref loc);
736  template <typename Char> inline Char decimal_point(locale_ref loc) {
737    return Char(decimal_point_impl<char>(loc));
738  }
739  template <> inline wchar_t decimal_point(locale_ref loc) {
740    return decimal_point_impl<wchar_t>(loc);
741  }
742  template <typename Char> bool equal2(const Char* lhs, const char* rhs) {
743    return lhs[0] == rhs[0] && lhs[1] == rhs[1];
744  }
745  inline bool equal2(const char* lhs, const char* rhs) {
746    return memcmp(lhs, rhs, 2) == 0;
747  }
748  template <typename Char> void copy2(Char* dst, const char* src) {
749    *dst++ = static_cast<Char>(*src++);
750    *dst = static_cast<Char>(*src);
751  }
752  inline void copy2(char* dst, const char* src) { memcpy(dst, src, 2); }
753  template <typename Iterator> struct format_decimal_result {
754    Iterator begin;
755    Iterator end;
756  };
757  template <typename Char, typename UInt>
758  inline format_decimal_result<Char*> format_decimal(Char* out, UInt value,
759                                                     int size) {
760    FMT_ASSERT(size >= count_digits(value), "invalid digit count");
761    out += size;
762    Char* end = out;
763    while (value >= 100) {
764      out -= 2;
765      copy2(out, data::digits[value % 100]);
766      value /= 100;
767    }
768    if (value < 10) {
769      *--out = static_cast<Char>('0' + value);
770      return {out, end};
771    }
772    out -= 2;
773    copy2(out, data::digits[value]);
774    return {out, end};
775  }
776  template <typename Char, typename UInt, typename Iterator,
777            FMT_ENABLE_IF(!std::is_pointer<remove_cvref_t<Iterator>>::value)>
778  inline format_decimal_result<Iterator> format_decimal(Iterator out, UInt value,
779                                                        int num_digits) {
780    enum { max_size = digits10<UInt>() + 1 };
781    Char buffer[2 * max_size];
782    auto end = format_decimal(buffer, value, num_digits).end;
783    return {out, detail::copy_str<Char>(buffer, end, out)};
784  }
785  template <unsigned BASE_BITS, typename Char, typename UInt>
786  inline Char* format_uint(Char* buffer, UInt value, int num_digits,
787                           bool upper = false) {
788    buffer += num_digits;
789    Char* end = buffer;
790    do {
791      const char* digits = upper ? "0123456789ABCDEF" : data::hex_digits;
792      unsigned digit = (value & ((1 << BASE_BITS) - 1));
793      *--buffer = static_cast<Char>(BASE_BITS < 4 ? static_cast<char>('0' + digit)
794                                                  : digits[digit]);
795    } while ((value >>= BASE_BITS) != 0);
796    return end;
797  }
798  template <unsigned BASE_BITS, typename Char>
799  Char* format_uint(Char* buffer, detail::fallback_uintptr n, int num_digits,
800                    bool = false) {
801    auto char_digits = std::numeric_limits<unsigned char>::digits / 4;
802    int start = (num_digits + char_digits - 1) / char_digits - 1;
803    if (int start_digits = num_digits % char_digits) {
804      unsigned value = n.value[start--];
805      buffer = format_uint<BASE_BITS>(buffer, value, start_digits);
806    }
807    for (; start >= 0; --start) {
808      unsigned value = n.value[start];
809      buffer += char_digits;
810      auto p = buffer;
811      for (int i = 0; i < char_digits; ++i) {
812        unsigned digit = (value & ((1 << BASE_BITS) - 1));
813        *--p = static_cast<Char>(data::hex_digits[digit]);
814        value >>= BASE_BITS;
815      }
816    }
817    return buffer;
818  }
819  template <unsigned BASE_BITS, typename Char, typename It, typename UInt>
820  inline It format_uint(It out, UInt value, int num_digits, bool upper = false) {
821    char buffer[num_bits<UInt>() / BASE_BITS + 1];
822    format_uint<BASE_BITS>(buffer, value, num_digits, upper);
823    return detail::copy_str<Char>(buffer, buffer + num_digits, out);
824  }
825  class utf8_to_utf16 {
826   private:
827    wmemory_buffer buffer_;
828   public:
829    FMT_API explicit utf8_to_utf16(string_view s);
830    operator wstring_view() const { return {&buffer_[0], size()}; }
831    size_t size() const { return buffer_.size() - 1; }
832    const wchar_t* c_str() const { return &buffer_[0]; }
833    std::wstring str() const { return {&buffer_[0], size()}; }
834  };
835  template <typename T = void> struct null {};
836  template <typename Char> struct fill_t {
837   private:
838    enum { max_size = 4 };
839    Char data_[max_size];
840    unsigned char size_;
841   public:
842    FMT_CONSTEXPR void operator=(basic_string_view<Char> s) {
843      auto size = s.size();
844      if (size > max_size) {
845        FMT_THROW(format_error("invalid fill"));
846        return;
847      }
848      for (size_t i = 0; i < size; ++i) data_[i] = s[i];
849      size_ = static_cast<unsigned char>(size);
850    }
851    size_t size() const { return size_; }
852    const Char* data() const { return data_; }
853    FMT_CONSTEXPR Char& operator[](size_t index) { return data_[index]; }
854    FMT_CONSTEXPR const Char& operator[](size_t index) const {
855      return data_[index];
856    }
857    static FMT_CONSTEXPR fill_t<Char> make() {
858      auto fill = fill_t<Char>();
859      fill[0] = Char(' ');
860      fill.size_ = 1;
861      return fill;
862    }
863  };
864  }  
865  namespace align {
866  enum type { none, left, right, center, numeric };
867  }
868  using align_t = align::type;
869  namespace sign {
870  enum type { none, minus, plus, space };
871  }
872  using sign_t = sign::type;
873  template <typename Char> struct basic_format_specs {
874    int width;
875    int precision;
876    char type;
877    align_t align : 4;
878    sign_t sign : 3;
879    bool alt : 1;  
880    detail::fill_t<Char> fill;
881    constexpr basic_format_specs()
882        : width(0),
883          precision(-1),
884          type(0),
885          align(align::none),
886          sign(sign::none),
887          alt(false),
888          fill(detail::fill_t<Char>::make()) {}
889  };
890  using format_specs = basic_format_specs<char>;
891  namespace detail {
892  namespace dragonbox {
893  template <class T> struct float_info;
894  template <> struct float_info<float> {
895    using carrier_uint = uint32_t;
896    static const int significand_bits = 23;
897    static const int exponent_bits = 8;
898    static const int min_exponent = -126;
899    static const int max_exponent = 127;
900    static const int exponent_bias = -127;
901    static const int decimal_digits = 9;
902    static const int kappa = 1;
903    static const int big_divisor = 100;
904    static const int small_divisor = 10;
905    static const int min_k = -31;
906    static const int max_k = 46;
907    static const int cache_bits = 64;
908    static const int divisibility_check_by_5_threshold = 39;
909    static const int case_fc_pm_half_lower_threshold = -1;
910    static const int case_fc_pm_half_upper_threshold = 6;
911    static const int case_fc_lower_threshold = -2;
912    static const int case_fc_upper_threshold = 6;
913    static const int case_shorter_interval_left_endpoint_lower_threshold = 2;
914    static const int case_shorter_interval_left_endpoint_upper_threshold = 3;
915    static const int shorter_interval_tie_lower_threshold = -35;
916    static const int shorter_interval_tie_upper_threshold = -35;
917    static const int max_trailing_zeros = 7;
918  };
919  template <> struct float_info<double> {
920    using carrier_uint = uint64_t;
921    static const int significand_bits = 52;
922    static const int exponent_bits = 11;
923    static const int min_exponent = -1022;
924    static const int max_exponent = 1023;
925    static const int exponent_bias = -1023;
926    static const int decimal_digits = 17;
927    static const int kappa = 2;
928    static const int big_divisor = 1000;
929    static const int small_divisor = 100;
930    static const int min_k = -292;
931    static const int max_k = 326;
932    static const int cache_bits = 128;
933    static const int divisibility_check_by_5_threshold = 86;
934    static const int case_fc_pm_half_lower_threshold = -2;
935    static const int case_fc_pm_half_upper_threshold = 9;
936    static const int case_fc_lower_threshold = -4;
937    static const int case_fc_upper_threshold = 9;
938    static const int case_shorter_interval_left_endpoint_lower_threshold = 2;
939    static const int case_shorter_interval_left_endpoint_upper_threshold = 3;
940    static const int shorter_interval_tie_lower_threshold = -77;
941    static const int shorter_interval_tie_upper_threshold = -77;
942    static const int max_trailing_zeros = 16;
943  };
944  template <typename T> struct decimal_fp {
945    using significand_type = typename float_info<T>::carrier_uint;
946    significand_type significand;
947    int exponent;
948  };
949  template <typename T> decimal_fp<T> to_decimal(T x) FMT_NOEXCEPT;
950  }  
951  enum class float_format : unsigned char {
952    general,  
953    exp,      
954    fixed,    
955    hex
956  };
957  struct float_specs {
958    int precision;
959    float_format format : 8;
960    sign_t sign : 8;
961    bool upper : 1;
962    bool locale : 1;
963    bool binary32 : 1;
964    bool use_grisu : 1;
965    bool showpoint : 1;
966  };
967  template <typename Char, typename It> It write_exponent(int exp, It it) {
968    FMT_ASSERT(-10000 < exp && exp < 10000, "exponent out of range");
969    if (exp < 0) {
970      *it++ = static_cast<Char>('-');
971      exp = -exp;
972    } else {
973      *it++ = static_cast<Char>('+');
974    }
975    if (exp >= 100) {
976      const char* top = data::digits[exp / 100];
977      if (exp >= 1000) *it++ = static_cast<Char>(top[0]);
978      *it++ = static_cast<Char>(top[1]);
979      exp %= 100;
980    }
981    const char* d = data::digits[exp];
982    *it++ = static_cast<Char>(d[0]);
983    *it++ = static_cast<Char>(d[1]);
984    return it;
985  }
986  template <typename T>
987  int format_float(T value, int precision, float_specs specs, buffer<char>& buf);
988  template <typename T>
989  int snprintf_float(T value, int precision, float_specs specs,
990                     buffer<char>& buf);
991  template <typename T> T promote_float(T value) { return value; }
992  inline double promote_float(float value) { return static_cast<double>(value); }
993  template <typename Handler>
994  FMT_CONSTEXPR void handle_int_type_spec(char spec, Handler&& handler) {
995    switch (spec) {
996    case 0:
997    case 'd':
998      handler.on_dec();
999      break;
1000    case 'x':
1001    case 'X':
1002      handler.on_hex();
1003      break;
1004    case 'b':
1005    case 'B':
1006      handler.on_bin();
1007      break;
1008    case 'o':
1009      handler.on_oct();
1010      break;
1011  #ifdef FMT_DEPRECATED_N_SPECIFIER
1012    case 'n':
1013  #endif
1014    case 'L':
1015      handler.on_num();
1016      break;
1017    case 'c':
1018      handler.on_chr();
1019      break;
1020    default:
1021      handler.on_error();
1022    }
1023  }
1024  template <typename ErrorHandler = error_handler, typename Char>
1025  FMT_CONSTEXPR float_specs parse_float_type_spec(
1026      const basic_format_specs<Char>& specs, ErrorHandler&& eh = {}) {
1027    auto result = float_specs();
1028    result.showpoint = specs.alt;
1029    switch (specs.type) {
1030    case 0:
1031      result.format = float_format::general;
1032      result.showpoint |= specs.precision > 0;
1033      break;
1034    case 'G':
1035      result.upper = true;
1036      FMT_FALLTHROUGH;
1037    case 'g':
1038      result.format = float_format::general;
1039      break;
1040    case 'E':
1041      result.upper = true;
1042      FMT_FALLTHROUGH;
1043    case 'e':
1044      result.format = float_format::exp;
1045      result.showpoint |= specs.precision != 0;
1046      break;
1047    case 'F':
1048      result.upper = true;
1049      FMT_FALLTHROUGH;
1050    case 'f':
1051      result.format = float_format::fixed;
1052      result.showpoint |= specs.precision != 0;
1053      break;
1054    case 'A':
1055      result.upper = true;
1056      FMT_FALLTHROUGH;
1057    case 'a':
1058      result.format = float_format::hex;
1059      break;
1060  #ifdef FMT_DEPRECATED_N_SPECIFIER
1061    case 'n':
1062  #endif
1063    case 'L':
1064      result.locale = true;
1065      break;
1066    default:
1067      eh.on_error("invalid type specifier");
1068      break;
1069    }
1070    return result;
1071  }
1072  template <typename Char, typename Handler>
1073  FMT_CONSTEXPR void handle_char_specs(const basic_format_specs<Char>* specs,
1074                                       Handler&& handler) {
1075    if (!specs) return handler.on_char();
1076    if (specs->type && specs->type != 'c') return handler.on_int();
1077    if (specs->align == align::numeric || specs->sign != sign::none || specs->alt)
1078      handler.on_error("invalid format specifier for char");
1079    handler.on_char();
1080  }
1081  template <typename Char, typename Handler>
1082  FMT_CONSTEXPR void handle_cstring_type_spec(Char spec, Handler&& handler) {
1083    if (spec == 0 || spec == 's')
1084      handler.on_string();
1085    else if (spec == 'p')
1086      handler.on_pointer();
1087    else
1088      handler.on_error("invalid type specifier");
1089  }
1090  template <typename Char, typename ErrorHandler>
1091  FMT_CONSTEXPR void check_string_type_spec(Char spec, ErrorHandler&& eh) {
1092    if (spec != 0 && spec != 's') eh.on_error("invalid type specifier");
1093  }
1094  template <typename Char, typename ErrorHandler>
1095  FMT_CONSTEXPR void check_pointer_type_spec(Char spec, ErrorHandler&& eh) {
1096    if (spec != 0 && spec != 'p') eh.on_error("invalid type specifier");
1097  }
1098  template <typename ErrorHandler> class int_type_checker : private ErrorHandler {
1099   public:
1100    FMT_CONSTEXPR explicit int_type_checker(ErrorHandler eh) : ErrorHandler(eh) {}
1101    FMT_CONSTEXPR void on_dec() {}
1102    FMT_CONSTEXPR void on_hex() {}
<span onclick='openModal()' class='match'>1103    FMT_CONSTEXPR void on_bin() {}
1104    FMT_CONSTEXPR void on_oct() {}
1105    FMT_CONSTEXPR void on_num() {}
1106    FMT_CONSTEXPR void on_chr() {}
</span>1107    FMT_CONSTEXPR void on_error() {
1108      ErrorHandler::on_error("invalid type specifier");
1109    }
1110  };
1111  template <typename ErrorHandler>
1112  class char_specs_checker : public ErrorHandler {
1113   private:
1114    char type_;
1115   public:
1116    FMT_CONSTEXPR char_specs_checker(char type, ErrorHandler eh)
1117        : ErrorHandler(eh), type_(type) {}
1118    FMT_CONSTEXPR void on_int() {
1119      handle_int_type_spec(type_, int_type_checker<ErrorHandler>(*this));
1120    }
1121    FMT_CONSTEXPR void on_char() {}
1122  };
1123  template <typename ErrorHandler>
1124  class cstring_type_checker : public ErrorHandler {
1125   public:
1126    FMT_CONSTEXPR explicit cstring_type_checker(ErrorHandler eh)
1127        : ErrorHandler(eh) {}
1128    FMT_CONSTEXPR void on_string() {}
1129    FMT_CONSTEXPR void on_pointer() {}
1130  };
1131  template <typename OutputIt, typename Char>
1132  FMT_NOINLINE OutputIt fill(OutputIt it, size_t n, const fill_t<Char>& fill) {
1133    auto fill_size = fill.size();
1134    if (fill_size == 1) return std::fill_n(it, n, fill[0]);
1135    for (size_t i = 0; i < n; ++i) it = std::copy_n(fill.data(), fill_size, it);
1136    return it;
1137  }
1138  template <align::type align = align::left, typename OutputIt, typename Char,
1139            typename F>
1140  inline OutputIt write_padded(OutputIt out,
1141                               const basic_format_specs<Char>& specs, size_t size,
1142                               size_t width, const F& f) {
1143    static_assert(align == align::left || align == align::right, "");
1144    unsigned spec_width = to_unsigned(specs.width);
1145    size_t padding = spec_width > width ? spec_width - width : 0;
1146    auto* shifts = align == align::left ? data::left_padding_shifts
1147                                        : data::right_padding_shifts;
1148    size_t left_padding = padding >> shifts[specs.align];
1149    auto it = reserve(out, size + padding * specs.fill.size());
1150    it = fill(it, left_padding, specs.fill);
1151    it = f(it);
1152    it = fill(it, padding - left_padding, specs.fill);
1153    return base_iterator(out, it);
1154  }
1155  template <align::type align = align::left, typename OutputIt, typename Char,
1156            typename F>
1157  inline OutputIt write_padded(OutputIt out,
1158                               const basic_format_specs<Char>& specs, size_t size,
1159                               const F& f) {
1160    return write_padded<align>(out, specs, size, size, f);
1161  }
1162  template <typename Char, typename OutputIt>
1163  OutputIt write_bytes(OutputIt out, string_view bytes,
1164                       const basic_format_specs<Char>& specs) {
1165    using iterator = remove_reference_t<decltype(reserve(out, 0))>;
1166    return write_padded(out, specs, bytes.size(), [bytes](iterator it) {
1167      const char* data = bytes.data();
1168      return copy_str<Char>(data, data + bytes.size(), it);
1169    });
1170  }
1171  template <typename Char> struct write_int_data {
1172    size_t size;
1173    size_t padding;
1174    write_int_data(int num_digits, string_view prefix,
1175                   const basic_format_specs<Char>& specs)
1176        : size(prefix.size() + to_unsigned(num_digits)), padding(0) {
1177      if (specs.align == align::numeric) {
1178        auto width = to_unsigned(specs.width);
1179        if (width > size) {
1180          padding = width - size;
1181          size = width;
1182        }
1183      } else if (specs.precision > num_digits) {
1184        size = prefix.size() + to_unsigned(specs.precision);
1185        padding = to_unsigned(specs.precision - num_digits);
1186      }
1187    }
1188  };
1189  template <typename OutputIt, typename Char, typename F>
1190  OutputIt write_int(OutputIt out, int num_digits, string_view prefix,
1191                     const basic_format_specs<Char>& specs, F f) {
1192    auto data = write_int_data<Char>(num_digits, prefix, specs);
1193    using iterator = remove_reference_t<decltype(reserve(out, 0))>;
1194    return write_padded<align::right>(out, specs, data.size, [=](iterator it) {
1195      if (prefix.size() != 0)
1196        it = copy_str<Char>(prefix.begin(), prefix.end(), it);
1197      it = std::fill_n(it, data.padding, static_cast<Char>('0'));
1198      return f(it);
1199    });
1200  }
1201  template <typename StrChar, typename Char, typename OutputIt>
1202  OutputIt write(OutputIt out, basic_string_view<StrChar> s,
1203                 const basic_format_specs<Char>& specs) {
1204    auto data = s.data();
1205    auto size = s.size();
1206    if (specs.precision >= 0 && to_unsigned(specs.precision) < size)
1207      size = code_point_index(s, to_unsigned(specs.precision));
1208    auto width = specs.width != 0
1209                     ? count_code_points(basic_string_view<StrChar>(data, size))
1210                     : 0;
1211    using iterator = remove_reference_t<decltype(reserve(out, 0))>;
1212    return write_padded(out, specs, size, width, [=](iterator it) {
1213      return copy_str<Char>(data, data + size, it);
1214    });
1215  }
1216  template <typename OutputIt, typename Char, typename UInt> struct int_writer {
1217    OutputIt out;
1218    locale_ref locale;
1219    const basic_format_specs<Char>& specs;
1220    UInt abs_value;
1221    char prefix[4];
1222    unsigned prefix_size;
1223    using iterator =
1224        remove_reference_t<decltype(reserve(std::declval<OutputIt&>(), 0))>;
1225    string_view get_prefix() const { return string_view(prefix, prefix_size); }
1226    template <typename Int>
1227    int_writer(OutputIt output, locale_ref loc, Int value,
1228               const basic_format_specs<Char>& s)
1229        : out(output),
1230          locale(loc),
1231          specs(s),
1232          abs_value(static_cast<UInt>(value)),
1233          prefix_size(0) {
1234      static_assert(std::is_same<uint32_or_64_or_128_t<Int>, UInt>::value, "");
1235      if (is_negative(value)) {
1236        prefix[0] = '-';
1237        ++prefix_size;
1238        abs_value = 0 - abs_value;
1239      } else if (specs.sign != sign::none && specs.sign != sign::minus) {
1240        prefix[0] = specs.sign == sign::plus ? '+' : ' ';
1241        ++prefix_size;
1242      }
1243    }
1244    void on_dec() {
1245      auto num_digits = count_digits(abs_value);
1246      out = write_int(
1247          out, num_digits, get_prefix(), specs, [this, num_digits](iterator it) {
1248            return format_decimal<Char>(it, abs_value, num_digits).end;
1249          });
1250    }
1251    void on_hex() {
1252      if (specs.alt) {
1253        prefix[prefix_size++] = '0';
1254        prefix[prefix_size++] = specs.type;
1255      }
1256      int num_digits = count_digits<4>(abs_value);
1257      out = write_int(out, num_digits, get_prefix(), specs,
1258                      [this, num_digits](iterator it) {
1259                        return format_uint<4, Char>(it, abs_value, num_digits,
1260                                                    specs.type != 'x');
1261                      });
1262    }
1263    void on_bin() {
1264      if (specs.alt) {
1265        prefix[prefix_size++] = '0';
1266        prefix[prefix_size++] = static_cast<char>(specs.type);
1267      }
1268      int num_digits = count_digits<1>(abs_value);
1269      out = write_int(out, num_digits, get_prefix(), specs,
1270                      [this, num_digits](iterator it) {
1271                        return format_uint<1, Char>(it, abs_value, num_digits);
1272                      });
1273    }
1274    void on_oct() {
1275      int num_digits = count_digits<3>(abs_value);
1276      if (specs.alt && specs.precision <= num_digits && abs_value != 0) {
1277        prefix[prefix_size++] = '0';
1278      }
1279      out = write_int(out, num_digits, get_prefix(), specs,
1280                      [this, num_digits](iterator it) {
1281                        return format_uint<3, Char>(it, abs_value, num_digits);
1282                      });
1283    }
1284    enum { sep_size = 1 };
1285    void on_num() {
1286      std::string groups = grouping<Char>(locale);
1287      if (groups.empty()) return on_dec();
1288      auto sep = thousands_sep<Char>(locale);
1289      if (!sep) return on_dec();
1290      int num_digits = count_digits(abs_value);
1291      int size = num_digits, n = num_digits;
1292      std::string::const_iterator group = groups.cbegin();
1293      while (group != groups.cend() && n > *group && *group > 0 &&
1294             *group != max_value<char>()) {
1295        size += sep_size;
1296        n -= *group;
1297        ++group;
1298      }
1299      if (group == groups.cend()) size += sep_size * ((n - 1) / groups.back());
1300      char digits[40];
1301      format_decimal(digits, abs_value, num_digits);
1302      basic_memory_buffer<Char> buffer;
1303      size += static_cast<int>(prefix_size);
1304      const auto usize = to_unsigned(size);
1305      buffer.resize(usize);
1306      basic_string_view<Char> s(&sep, sep_size);
1307      int digit_index = 0;
1308      group = groups.cbegin();
1309      auto p = buffer.data() + size;
1310      for (int i = num_digits - 1; i >= 0; --i) {
1311        *--p = static_cast<Char>(digits[i]);
1312        if (*group <= 0 || ++digit_index % *group != 0 ||
1313            *group == max_value<char>())
1314          continue;
1315        if (group + 1 != groups.cend()) {
1316          digit_index = 0;
1317          ++group;
1318        }
1319        p -= s.size();
1320        std::uninitialized_copy(s.data(), s.data() + s.size(),
1321                                make_checked(p, s.size()));
1322      }
1323      if (prefix_size != 0) p[-1] = static_cast<Char>('-');
1324      auto data = buffer.data();
1325      out = write_padded<align::right>(
1326          out, specs, usize, usize,
1327          [=](iterator it) { return copy_str<Char>(data, data + size, it); });
1328    }
1329    void on_chr() { *out++ = static_cast<Char>(abs_value); }
1330    FMT_NORETURN void on_error() {
1331      FMT_THROW(format_error("invalid type specifier"));
1332    }
1333  };
1334  template <typename Char, typename OutputIt>
1335  OutputIt write_nonfinite(OutputIt out, bool isinf,
1336                           const basic_format_specs<Char>& specs,
1337                           const float_specs& fspecs) {
1338    auto str =
1339        isinf ? (fspecs.upper ? "INF" : "inf") : (fspecs.upper ? "NAN" : "nan");
1340    constexpr size_t str_size = 3;
1341    auto sign = fspecs.sign;
1342    auto size = str_size + (sign ? 1 : 0);
1343    using iterator = remove_reference_t<decltype(reserve(out, 0))>;
1344    return write_padded(out, specs, size, [=](iterator it) {
1345      if (sign) *it++ = static_cast<Char>(data::signs[sign]);
1346      return copy_str<Char>(str, str + str_size, it);
1347    });
1348  }
1349  struct big_decimal_fp {
1350    const char* significand;
1351    int significand_size;
1352    int exp;
1353  };
1354  template <typename OutputIt, typename Char>
1355  OutputIt write_float(OutputIt out, const big_decimal_fp& fp, float_specs specs,
1356                       Char decimal_point) {
1357    const char* digits = fp.significand;
1358    const Char zero = static_cast<Char>('0');
1359    int output_exp = fp.exp + fp.significand_size - 1;
1360    auto use_exp_format = [=]() {
1361      if (specs.format == float_format::exp) return true;
1362      if (specs.format != float_format::general) return false;
1363      const int exp_lower = -4, exp_upper = 16;
1364      return output_exp < exp_lower ||
1365             output_exp >= (specs.precision > 0 ? specs.precision : exp_upper);
1366    };
1367    if (use_exp_format()) {
1368      *out++ = static_cast<Char>(*digits);
1369      int num_zeros = specs.precision - fp.significand_size;
1370      if (fp.significand_size > 1 || specs.showpoint) *out++ = decimal_point;
1371      out = copy_str<Char>(digits + 1, digits + fp.significand_size, out);
1372      if (num_zeros > 0 && specs.showpoint)
1373        out = std::fill_n(out, num_zeros, zero);
1374      *out++ = static_cast<Char>(specs.upper ? 'E' : 'e');
1375      return write_exponent<Char>(output_exp, out);
1376    }
1377    int exp = fp.exp + fp.significand_size;
1378    if (fp.significand_size <= exp) {
1379      out = copy_str<Char>(digits, digits + fp.significand_size, out);
1380      out = std::fill_n(out, exp - fp.significand_size, zero);
1381      if (specs.showpoint) {
1382        *out++ = decimal_point;
1383        int num_zeros = specs.precision - exp;
1384        if (num_zeros <= 0) {
1385          if (specs.format != float_format::fixed) *out++ = zero;
1386          return out;
1387        }
1388  #ifdef FMT_FUZZ
1389        if (num_zeros > 5000)
1390          throw std::runtime_error("fuzz mode - avoiding excessive cpu use");
1391  #endif
1392        out = std::fill_n(out, num_zeros, zero);
1393      }
1394    } else if (exp > 0) {
1395      out = copy_str<Char>(digits, digits + exp, out);
1396      if (!specs.showpoint) {
1397        if (fp.significand_size != exp) *out++ = decimal_point;
1398        return copy_str<Char>(digits + exp, digits + fp.significand_size, out);
1399      }
1400      *out++ = decimal_point;
1401      out = copy_str<Char>(digits + exp, digits + fp.significand_size, out);
1402      if (specs.precision > fp.significand_size)
1403        out = std::fill_n(out, specs.precision - fp.significand_size, zero);
1404    } else {
1405      *out++ = zero;
1406      int num_zeros = -exp;
1407      if (fp.significand_size == 0 && specs.precision >= 0 &&
1408          specs.precision < num_zeros) {
1409        num_zeros = specs.precision;
1410      }
1411      if (num_zeros != 0 || fp.significand_size != 0 || specs.showpoint) {
1412        *out++ = decimal_point;
1413        out = std::fill_n(out, num_zeros, zero);
1414        out = copy_str<Char>(digits, digits + fp.significand_size, out);
1415      }
1416    }
1417    return out;
1418  }
1419  template <typename OutputIt, typename Char>
1420  OutputIt write_float(OutputIt out, const buffer<char>& significand, int exp,
1421                       const basic_format_specs<Char>& specs, float_specs fspecs,
1422                       Char decimal_point) {
1423    auto fp = big_decimal_fp{significand.data(),
1424                             static_cast<int>(significand.size()), exp};
1425    auto size =
1426        write_float(counting_iterator(), fp, fspecs, decimal_point).count();
1427    size += fspecs.sign ? 1 : 0;
1428    using iterator = remove_reference_t<decltype(reserve(out, 0))>;
1429    return write_padded<align::right>(out, specs, size, [&](iterator it) {
1430      if (fspecs.sign) *it++ = static_cast<Char>(data::signs[fspecs.sign]);
1431      return write_float(it, fp, fspecs, decimal_point);
1432    });
1433  }
1434  template <typename Char, typename OutputIt, typename T,
1435            FMT_ENABLE_IF(std::is_floating_point<T>::value)>
1436  OutputIt write(OutputIt out, T value, basic_format_specs<Char> specs,
1437                 locale_ref loc = {}) {
1438    if (const_check(!is_supported_floating_point(value))) return out;
1439    float_specs fspecs = parse_float_type_spec(specs);
1440    fspecs.sign = specs.sign;
1441    if (std::signbit(value)) {  
1442      fspecs.sign = sign::minus;
1443      value = -value;
1444    } else if (fspecs.sign == sign::minus) {
1445      fspecs.sign = sign::none;
1446    }
1447    if (!std::isfinite(value))
1448      return write_nonfinite(out, std::isinf(value), specs, fspecs);
1449    if (specs.align == align::numeric && fspecs.sign) {
1450      auto it = reserve(out, 1);
1451      *it++ = static_cast<Char>(data::signs[fspecs.sign]);
1452      out = base_iterator(out, it);
1453      fspecs.sign = sign::none;
1454      if (specs.width != 0) --specs.width;
1455    }
1456    memory_buffer buffer;
1457    if (fspecs.format == float_format::hex) {
1458      if (fspecs.sign) buffer.push_back(data::signs[fspecs.sign]);
1459      snprintf_float(promote_float(value), specs.precision, fspecs, buffer);
1460      return write_bytes(out, {buffer.data(), buffer.size()}, specs);
1461    }
1462    int precision = specs.precision >= 0 || !specs.type ? specs.precision : 6;
1463    if (fspecs.format == float_format::exp) {
1464      if (precision == max_value<int>())
1465        FMT_THROW(format_error("number is too big"));
1466      else
1467        ++precision;
1468    }
1469    if (const_check(std::is_same<T, float>())) fspecs.binary32 = true;
1470    fspecs.use_grisu = is_fast_float<T>();
1471    int exp = format_float(promote_float(value), precision, fspecs, buffer);
1472    fspecs.precision = precision;
1473    Char point =
1474        fspecs.locale ? decimal_point<Char>(loc) : static_cast<Char>('.');
1475    return write_float(out, buffer, exp, specs, fspecs, point);
1476  }
1477  template <
1478      typename Char, typename OutputIt, typename T,
1479      FMT_ENABLE_IF(std::is_floating_point<T>::value&& is_fast_float<T>::value)>
1480  OutputIt write(OutputIt out, T value) {
1481    if (const_check(!is_supported_floating_point(value))) return out;
1482    auto fspecs = float_specs();
1483    if (std::signbit(value)) {  
1484      fspecs.sign = sign::minus;
1485      value = -value;
1486    }
1487    auto specs = basic_format_specs<Char>();
1488    if (!std::isfinite(value))
1489      return write_nonfinite(out, std::isinf(value), specs, fspecs);
1490    using type = conditional_t<std::is_same<T, long double>::value, double, T>;
1491    auto dec = dragonbox::to_decimal(static_cast<type>(value));
1492    memory_buffer buf;
1493    write<char>(buffer_appender<char>(buf), dec.significand);
1494    return write_float(out, buf, dec.exponent, specs, fspecs,
1495                       static_cast<Char>('.'));
1496  }
1497  template <typename Char, typename OutputIt, typename T,
1498            FMT_ENABLE_IF(std::is_floating_point<T>::value &&
1499                          !is_fast_float<T>::value)>
1500  inline OutputIt write(OutputIt out, T value) {
1501    return write(out, value, basic_format_specs<Char>());
1502  }
1503  template <typename Char, typename OutputIt>
1504  OutputIt write_char(OutputIt out, Char value,
1505                      const basic_format_specs<Char>& specs) {
1506    using iterator = remove_reference_t<decltype(reserve(out, 0))>;
1507    return write_padded(out, specs, 1, [=](iterator it) {
1508      *it++ = value;
1509      return it;
1510    });
1511  }
1512  template <typename Char, typename OutputIt, typename UIntPtr>
1513  OutputIt write_ptr(OutputIt out, UIntPtr value,
1514                     const basic_format_specs<Char>* specs) {
1515    int num_digits = count_digits<4>(value);
1516    auto size = to_unsigned(num_digits) + size_t(2);
1517    using iterator = remove_reference_t<decltype(reserve(out, 0))>;
1518    auto write = [=](iterator it) {
1519      *it++ = static_cast<Char>('0');
1520      *it++ = static_cast<Char>('x');
1521      return format_uint<4, Char>(it, value, num_digits);
1522    };
1523    return specs ? write_padded<align::right>(out, *specs, size, write)
1524                 : base_iterator(out, write(reserve(out, size)));
1525  }
1526  template <typename T> struct is_integral : std::is_integral<T> {};
1527  template <> struct is_integral<int128_t> : std::true_type {};
1528  template <> struct is_integral<uint128_t> : std::true_type {};
1529  template <typename Char, typename OutputIt>
1530  OutputIt write(OutputIt out, monostate) {
1531    FMT_ASSERT(false, "");
1532    return out;
1533  }
1534  template <typename Char, typename OutputIt,
1535            FMT_ENABLE_IF(!std::is_same<Char, char>::value)>
1536  OutputIt write(OutputIt out, string_view value) {
1537    auto it = reserve(out, value.size());
1538    it = copy_str<Char>(value.begin(), value.end(), it);
1539    return base_iterator(out, it);
1540  }
1541  template <typename Char, typename OutputIt>
1542  OutputIt write(OutputIt out, basic_string_view<Char> value) {
1543    auto it = reserve(out, value.size());
1544    it = std::copy(value.begin(), value.end(), it);
1545    return base_iterator(out, it);
1546  }
1547  template <typename Char>
1548  buffer_appender<Char> write(buffer_appender<Char> out,
1549                              basic_string_view<Char> value) {
1550    get_container(out).append(value.begin(), value.end());
1551    return out;
1552  }
1553  template <typename Char, typename OutputIt, typename T,
1554            FMT_ENABLE_IF(is_integral<T>::value &&
1555                          !std::is_same<T, bool>::value &&
1556                          !std::is_same<T, Char>::value)>
1557  OutputIt write(OutputIt out, T value) {
1558    auto abs_value = static_cast<uint32_or_64_or_128_t<T>>(value);
1559    bool negative = is_negative(value);
1560    if (negative) abs_value = ~abs_value + 1;
1561    int num_digits = count_digits(abs_value);
1562    auto size = (negative ? 1 : 0) + static_cast<size_t>(num_digits);
1563    auto it = reserve(out, size);
1564    if (auto ptr = to_pointer<Char>(it, size)) {
1565      if (negative) *ptr++ = static_cast<Char>('-');
1566      format_decimal<Char>(ptr, abs_value, num_digits);
1567      return out;
1568    }
1569    if (negative) *it++ = static_cast<Char>('-');
1570    it = format_decimal<Char>(it, abs_value, num_digits).end;
1571    return base_iterator(out, it);
1572  }
1573  template <typename Char, typename OutputIt>
1574  OutputIt write(OutputIt out, bool value) {
1575    return write<Char>(out, string_view(value ? "true" : "false"));
1576  }
1577  template <typename Char, typename OutputIt>
1578  OutputIt write(OutputIt out, Char value) {
1579    auto it = reserve(out, 1);
1580    *it++ = value;
1581    return base_iterator(out, it);
1582  }
1583  template <typename Char, typename OutputIt>
1584  OutputIt write(OutputIt out, const Char* value) {
1585    if (!value) {
1586      FMT_THROW(format_error("string pointer is null"));
1587    } else {
1588      auto length = std::char_traits<Char>::length(value);
1589      out = write(out, basic_string_view<Char>(value, length));
1590    }
1591    return out;
1592  }
1593  template <typename Char, typename OutputIt>
1594  OutputIt write(OutputIt out, const void* value) {
1595    return write_ptr<Char>(out, to_uintptr(value), nullptr);
1596  }
1597  template <typename Char, typename OutputIt, typename T>
1598  auto write(OutputIt out, const T& value) -> typename std::enable_if<
1599      mapped_type_constant<T, basic_format_context<OutputIt, Char>>::value ==
1600          type::custom_type,
1601      OutputIt>::type {
1602    using context_type = basic_format_context<OutputIt, Char>;
1603    using formatter_type =
1604        conditional_t<has_formatter<T, context_type>::value,
1605                      typename context_type::template formatter_type<T>,
1606                      fallback_formatter<T, Char>>;
1607    context_type ctx(out, {}, {});
1608    return formatter_type().format(value, ctx);
1609  }
1610  template <typename OutputIt, typename Char> struct default_arg_formatter {
1611    using context = basic_format_context<OutputIt, Char>;
1612    OutputIt out;
1613    basic_format_args<context> args;
1614    locale_ref loc;
1615    template <typename T> OutputIt operator()(T value) {
1616      return write<Char>(out, value);
1617    }
1618    OutputIt operator()(typename basic_format_arg<context>::handle handle) {
1619      basic_format_parse_context<Char> parse_ctx({});
1620      basic_format_context<OutputIt, Char> format_ctx(out, args, loc);
1621      handle.format(parse_ctx, format_ctx);
1622      return format_ctx.out();
1623    }
1624  };
1625  template <typename OutputIt, typename Char,
1626            typename ErrorHandler = error_handler>
1627  class arg_formatter_base {
1628   public:
1629    using iterator = OutputIt;
1630    using char_type = Char;
1631    using format_specs = basic_format_specs<Char>;
1632   private:
1633    iterator out_;
1634    locale_ref locale_;
1635    format_specs* specs_;
1636    auto reserve(size_t n) -> decltype(detail::reserve(out_, n)) {
1637      return detail::reserve(out_, n);
1638    }
1639    using reserve_iterator = remove_reference_t<decltype(
1640        detail::reserve(std::declval<iterator&>(), 0))>;
1641    template <typename T> void write_int(T value, const format_specs& spec) {
1642      using uint_type = uint32_or_64_or_128_t<T>;
1643      int_writer<iterator, Char, uint_type> w(out_, locale_, value, spec);
1644      handle_int_type_spec(spec.type, w);
1645      out_ = w.out;
1646    }
1647    void write(char value) {
1648      auto&& it = reserve(1);
1649      *it++ = value;
1650    }
1651    template <typename Ch, FMT_ENABLE_IF(std::is_same<Ch, Char>::value)>
1652    void write(Ch value) {
1653      out_ = detail::write<Char>(out_, value);
1654    }
1655    void write(string_view value) {
1656      auto&& it = reserve(value.size());
1657      it = copy_str<Char>(value.begin(), value.end(), it);
1658    }
1659    void write(wstring_view value) {
1660      static_assert(std::is_same<Char, wchar_t>::value, "");
1661      auto&& it = reserve(value.size());
1662      it = std::copy(value.begin(), value.end(), it);
1663    }
1664    template <typename Ch>
1665    void write(const Ch* s, size_t size, const format_specs& specs) {
1666      auto width = specs.width != 0
1667                       ? count_code_points(basic_string_view<Ch>(s, size))
1668                       : 0;
1669      out_ = write_padded(out_, specs, size, width, [=](reserve_iterator it) {
1670        return copy_str<Char>(s, s + size, it);
1671      });
1672    }
1673    template <typename Ch>
1674    void write(basic_string_view<Ch> s, const format_specs& specs = {}) {
1675      out_ = detail::write(out_, s, specs);
1676    }
1677    void write_pointer(const void* p) {
1678      out_ = write_ptr<char_type>(out_, to_uintptr(p), specs_);
1679    }
1680    struct char_spec_handler : ErrorHandler {
1681      arg_formatter_base& formatter;
1682      Char value;
1683      char_spec_handler(arg_formatter_base& f, Char val)
1684          : formatter(f), value(val) {}
1685      void on_int() {
1686        formatter.write_int(static_cast<int>(value), *formatter.specs_);
1687      }
1688      void on_char() {
1689        if (formatter.specs_)
1690          formatter.out_ = write_char(formatter.out_, value, *formatter.specs_);
1691        else
1692          formatter.write(value);
1693      }
1694    };
1695    struct cstring_spec_handler : error_handler {
1696      arg_formatter_base& formatter;
1697      const Char* value;
1698      cstring_spec_handler(arg_formatter_base& f, const Char* val)
1699          : formatter(f), value(val) {}
1700      void on_string() { formatter.write(value); }
1701      void on_pointer() { formatter.write_pointer(value); }
1702    };
1703   protected:
1704    iterator out() { return out_; }
1705    format_specs* specs() { return specs_; }
1706    void write(bool value) {
1707      if (specs_)
1708        write(string_view(value ? "true" : "false"), *specs_);
1709      else
1710        out_ = detail::write<Char>(out_, value);
1711    }
1712    void write(const Char* value) {
1713      if (!value) {
1714        FMT_THROW(format_error("string pointer is null"));
1715      } else {
1716        auto length = std::char_traits<char_type>::length(value);
1717        basic_string_view<char_type> sv(value, length);
1718        specs_ ? write(sv, *specs_) : write(sv);
1719      }
1720    }
1721   public:
1722    arg_formatter_base(OutputIt out, format_specs* s, locale_ref loc)
1723        : out_(out), locale_(loc), specs_(s) {}
1724    iterator operator()(monostate) {
1725      FMT_ASSERT(false, "invalid argument type");
1726      return out_;
1727    }
1728    template <typename T, FMT_ENABLE_IF(is_integral<T>::value)>
1729    FMT_INLINE iterator operator()(T value) {
1730      if (specs_)
1731        write_int(value, *specs_);
1732      else
1733        out_ = detail::write<Char>(out_, value);
1734      return out_;
1735    }
1736    iterator operator()(Char value) {
1737      handle_char_specs(specs_,
1738                        char_spec_handler(*this, static_cast<Char>(value)));
1739      return out_;
1740    }
1741    iterator operator()(bool value) {
1742      if (specs_ && specs_->type) return (*this)(value ? 1 : 0);
1743      write(value != 0);
1744      return out_;
1745    }
1746    template <typename T, FMT_ENABLE_IF(std::is_floating_point<T>::value)>
1747    iterator operator()(T value) {
1748      auto specs = specs_ ? *specs_ : format_specs();
1749      if (const_check(is_supported_floating_point(value)))
1750        out_ = detail::write(out_, value, specs, locale_);
1751      else
1752        FMT_ASSERT(false, "unsupported float argument type");
1753      return out_;
1754    }
1755    iterator operator()(const Char* value) {
1756      if (!specs_) return write(value), out_;
1757      handle_cstring_type_spec(specs_->type, cstring_spec_handler(*this, value));
1758      return out_;
1759    }
1760    iterator operator()(basic_string_view<Char> value) {
1761      if (specs_) {
1762        check_string_type_spec(specs_->type, error_handler());
1763        write(value, *specs_);
1764      } else {
1765        write(value);
1766      }
1767      return out_;
1768    }
1769    iterator operator()(const void* value) {
1770      if (specs_) check_pointer_type_spec(specs_->type, error_handler());
1771      write_pointer(value);
1772      return out_;
1773    }
1774  };
1775  template <typename Char> FMT_CONSTEXPR bool is_name_start(Char c) {
1776    return ('a' <= c && c <= 'z') || ('A' <= c && c <= 'Z') || '_' == c;
1777  }
1778  template <typename Char, typename ErrorHandler>
1779  FMT_CONSTEXPR int parse_nonnegative_int(const Char*& begin, const Char* end,
1780                                          ErrorHandler&& eh) {
1781    FMT_ASSERT(begin != end && '0' <= *begin && *begin <= '9', "");
1782    unsigned value = 0;
1783    constexpr unsigned max_int = max_value<int>();
1784    unsigned big = max_int / 10;
1785    do {
1786      if (value > big) {
1787        value = max_int + 1;
1788        break;
1789      }
1790      value = value * 10 + unsigned(*begin - '0');
1791      ++begin;
1792    } while (begin != end && '0' <= *begin && *begin <= '9');
1793    if (value > max_int) eh.on_error("number is too big");
1794    return static_cast<int>(value);
1795  }
1796  template <typename Context> class custom_formatter {
1797   private:
1798    using char_type = typename Context::char_type;
1799    basic_format_parse_context<char_type>& parse_ctx_;
1800    Context& ctx_;
1801   public:
1802    explicit custom_formatter(basic_format_parse_context<char_type>& parse_ctx,
1803                              Context& ctx)
1804        : parse_ctx_(parse_ctx), ctx_(ctx) {}
1805    bool operator()(typename basic_format_arg<Context>::handle h) const {
1806      h.format(parse_ctx_, ctx_);
1807      return true;
1808    }
1809    template <typename T> bool operator()(T) const { return false; }
1810  };
1811  template <typename T>
1812  using is_integer =
1813      bool_constant<is_integral<T>::value && !std::is_same<T, bool>::value &&
1814                    !std::is_same<T, char>::value &&
1815                    !std::is_same<T, wchar_t>::value>;
1816  template <typename ErrorHandler> class width_checker {
1817   public:
1818    explicit FMT_CONSTEXPR width_checker(ErrorHandler& eh) : handler_(eh) {}
1819    template <typename T, FMT_ENABLE_IF(is_integer<T>::value)>
1820    FMT_CONSTEXPR unsigned long long operator()(T value) {
1821      if (is_negative(value)) handler_.on_error("negative width");
1822      return static_cast<unsigned long long>(value);
1823    }
1824    template <typename T, FMT_ENABLE_IF(!is_integer<T>::value)>
1825    FMT_CONSTEXPR unsigned long long operator()(T) {
1826      handler_.on_error("width is not integer");
1827      return 0;
1828    }
1829   private:
1830    ErrorHandler& handler_;
1831  };
1832  template <typename ErrorHandler> class precision_checker {
1833   public:
1834    explicit FMT_CONSTEXPR precision_checker(ErrorHandler& eh) : handler_(eh) {}
1835    template <typename T, FMT_ENABLE_IF(is_integer<T>::value)>
1836    FMT_CONSTEXPR unsigned long long operator()(T value) {
1837      if (is_negative(value)) handler_.on_error("negative precision");
1838      return static_cast<unsigned long long>(value);
1839    }
1840    template <typename T, FMT_ENABLE_IF(!is_integer<T>::value)>
1841    FMT_CONSTEXPR unsigned long long operator()(T) {
1842      handler_.on_error("precision is not integer");
1843      return 0;
1844    }
1845   private:
1846    ErrorHandler& handler_;
1847  };
1848  template <typename Char> class specs_setter {
1849   public:
1850    explicit FMT_CONSTEXPR specs_setter(basic_format_specs<Char>& specs)
1851        : specs_(specs) {}
1852    FMT_CONSTEXPR specs_setter(const specs_setter& other)
1853        : specs_(other.specs_) {}
1854    FMT_CONSTEXPR void on_align(align_t align) { specs_.align = align; }
1855    FMT_CONSTEXPR void on_fill(basic_string_view<Char> fill) {
1856      specs_.fill = fill;
1857    }
1858    FMT_CONSTEXPR void on_plus() { specs_.sign = sign::plus; }
1859    FMT_CONSTEXPR void on_minus() { specs_.sign = sign::minus; }
1860    FMT_CONSTEXPR void on_space() { specs_.sign = sign::space; }
1861    FMT_CONSTEXPR void on_hash() { specs_.alt = true; }
1862    FMT_CONSTEXPR void on_zero() {
1863      specs_.align = align::numeric;
1864      specs_.fill[0] = Char('0');
1865    }
1866    FMT_CONSTEXPR void on_width(int width) { specs_.width = width; }
1867    FMT_CONSTEXPR void on_precision(int precision) {
1868      specs_.precision = precision;
1869    }
1870    FMT_CONSTEXPR void end_precision() {}
1871    FMT_CONSTEXPR void on_type(Char type) {
1872      specs_.type = static_cast<char>(type);
1873    }
1874   protected:
1875    basic_format_specs<Char>& specs_;
1876  };
1877  template <typename ErrorHandler> class numeric_specs_checker {
1878   public:
1879    FMT_CONSTEXPR numeric_specs_checker(ErrorHandler& eh, detail::type arg_type)
1880        : error_handler_(eh), arg_type_(arg_type) {}
1881    FMT_CONSTEXPR void require_numeric_argument() {
1882      if (!is_arithmetic_type(arg_type_))
1883        error_handler_.on_error("format specifier requires numeric argument");
1884    }
1885    FMT_CONSTEXPR void check_sign() {
1886      require_numeric_argument();
1887      if (is_integral_type(arg_type_) && arg_type_ != type::int_type &&
1888          arg_type_ != type::long_long_type && arg_type_ != type::char_type) {
1889        error_handler_.on_error("format specifier requires signed argument");
1890      }
1891    }
1892    FMT_CONSTEXPR void check_precision() {
1893      if (is_integral_type(arg_type_) || arg_type_ == type::pointer_type)
1894        error_handler_.on_error("precision not allowed for this argument type");
1895    }
1896   private:
1897    ErrorHandler& error_handler_;
1898    detail::type arg_type_;
1899  };
1900  template <typename Handler> class specs_checker : public Handler {
1901   private:
1902    numeric_specs_checker<Handler> checker_;
1903    FMT_CONSTEXPR Handler& error_handler() { return *this; }
1904   public:
1905    FMT_CONSTEXPR specs_checker(const Handler& handler, detail::type arg_type)
1906        : Handler(handler), checker_(error_handler(), arg_type) {}
1907    FMT_CONSTEXPR specs_checker(const specs_checker& other)
1908        : Handler(other), checker_(error_handler(), other.arg_type_) {}
1909    FMT_CONSTEXPR void on_align(align_t align) {
1910      if (align == align::numeric) checker_.require_numeric_argument();
1911      Handler::on_align(align);
1912    }
1913    FMT_CONSTEXPR void on_plus() {
1914      checker_.check_sign();
1915      Handler::on_plus();
1916    }
1917    FMT_CONSTEXPR void on_minus() {
1918      checker_.check_sign();
1919      Handler::on_minus();
1920    }
1921    FMT_CONSTEXPR void on_space() {
1922      checker_.check_sign();
1923      Handler::on_space();
1924    }
1925    FMT_CONSTEXPR void on_hash() {
1926      checker_.require_numeric_argument();
1927      Handler::on_hash();
1928    }
1929    FMT_CONSTEXPR void on_zero() {
1930      checker_.require_numeric_argument();
1931      Handler::on_zero();
1932    }
1933    FMT_CONSTEXPR void end_precision() { checker_.check_precision(); }
1934  };
1935  template <template <typename> class Handler, typename FormatArg,
1936            typename ErrorHandler>
1937  FMT_CONSTEXPR int get_dynamic_spec(FormatArg arg, ErrorHandler eh) {
1938    unsigned long long value = visit_format_arg(Handler<ErrorHandler>(eh), arg);
1939    if (value > to_unsigned(max_value<int>())) eh.on_error("number is too big");
1940    return static_cast<int>(value);
1941  }
1942  struct auto_id {};
1943  template <typename Context, typename ID>
1944  FMT_CONSTEXPR typename Context::format_arg get_arg(Context& ctx, ID id) {
1945    auto arg = ctx.arg(id);
1946    if (!arg) ctx.on_error("argument not found");
1947    return arg;
1948  }
1949  template <typename ParseContext, typename Context>
1950  class specs_handler : public specs_setter<typename Context::char_type> {
1951   public:
1952    using char_type = typename Context::char_type;
1953    FMT_CONSTEXPR specs_handler(basic_format_specs<char_type>& specs,
1954                                ParseContext& parse_ctx, Context& ctx)
1955        : specs_setter<char_type>(specs),
1956          parse_context_(parse_ctx),
1957          context_(ctx) {}
1958    template <typename Id> FMT_CONSTEXPR void on_dynamic_width(Id arg_id) {
1959      this->specs_.width = get_dynamic_spec<width_checker>(
1960          get_arg(arg_id), context_.error_handler());
1961    }
1962    template <typename Id> FMT_CONSTEXPR void on_dynamic_precision(Id arg_id) {
1963      this->specs_.precision = get_dynamic_spec<precision_checker>(
1964          get_arg(arg_id), context_.error_handler());
1965    }
1966    void on_error(const char* message) { context_.on_error(message); }
1967   private:
1968    using format_arg = typename Context::format_arg;
1969    FMT_CONSTEXPR format_arg get_arg(auto_id) {
1970      return detail::get_arg(context_, parse_context_.next_arg_id());
1971    }
1972    FMT_CONSTEXPR format_arg get_arg(int arg_id) {
1973      parse_context_.check_arg_id(arg_id);
1974      return detail::get_arg(context_, arg_id);
1975    }
1976    FMT_CONSTEXPR format_arg get_arg(basic_string_view<char_type> arg_id) {
1977      parse_context_.check_arg_id(arg_id);
1978      return detail::get_arg(context_, arg_id);
1979    }
1980    ParseContext& parse_context_;
1981    Context& context_;
1982  };
1983  enum class arg_id_kind { none, index, name };
1984  template <typename Char> struct arg_ref {
1985    FMT_CONSTEXPR arg_ref() : kind(arg_id_kind::none), val() {}
1986    FMT_CONSTEXPR explicit arg_ref(int index)
1987        : kind(arg_id_kind::index), val(index) {}
1988    FMT_CONSTEXPR explicit arg_ref(basic_string_view<Char> name)
1989        : kind(arg_id_kind::name), val(name) {}
1990    FMT_CONSTEXPR arg_ref& operator=(int idx) {
1991      kind = arg_id_kind::index;
1992      val.index = idx;
1993      return *this;
1994    }
1995    arg_id_kind kind;
1996    union value {
1997      FMT_CONSTEXPR value(int id = 0) : index{id} {}
1998      FMT_CONSTEXPR value(basic_string_view<Char> n) : name(n) {}
1999      int index;
2000      basic_string_view<Char> name;
2001    } val;
2002  };
2003  template <typename Char>
2004  struct dynamic_format_specs : basic_format_specs<Char> {
2005    arg_ref<Char> width_ref;
2006    arg_ref<Char> precision_ref;
2007  };
2008  template <typename ParseContext>
2009  class dynamic_specs_handler
2010      : public specs_setter<typename ParseContext::char_type> {
2011   public:
2012    using char_type = typename ParseContext::char_type;
2013    FMT_CONSTEXPR dynamic_specs_handler(dynamic_format_specs<char_type>& specs,
2014                                        ParseContext& ctx)
2015        : specs_setter<char_type>(specs), specs_(specs), context_(ctx) {}
2016    FMT_CONSTEXPR dynamic_specs_handler(const dynamic_specs_handler& other)
2017        : specs_setter<char_type>(other),
2018          specs_(other.specs_),
2019          context_(other.context_) {}
2020    template <typename Id> FMT_CONSTEXPR void on_dynamic_width(Id arg_id) {
2021      specs_.width_ref = make_arg_ref(arg_id);
2022    }
2023    template <typename Id> FMT_CONSTEXPR void on_dynamic_precision(Id arg_id) {
2024      specs_.precision_ref = make_arg_ref(arg_id);
2025    }
2026    FMT_CONSTEXPR void on_error(const char* message) {
2027      context_.on_error(message);
2028    }
2029   private:
2030    using arg_ref_type = arg_ref<char_type>;
2031    FMT_CONSTEXPR arg_ref_type make_arg_ref(int arg_id) {
2032      context_.check_arg_id(arg_id);
2033      return arg_ref_type(arg_id);
2034    }
2035    FMT_CONSTEXPR arg_ref_type make_arg_ref(auto_id) {
2036      return arg_ref_type(context_.next_arg_id());
2037    }
2038    FMT_CONSTEXPR arg_ref_type make_arg_ref(basic_string_view<char_type> arg_id) {
2039      context_.check_arg_id(arg_id);
2040      basic_string_view<char_type> format_str(
2041          context_.begin(), to_unsigned(context_.end() - context_.begin()));
2042      return arg_ref_type(arg_id);
2043    }
2044    dynamic_format_specs<char_type>& specs_;
2045    ParseContext& context_;
2046  };
2047  template <typename Char, typename IDHandler>
2048  FMT_CONSTEXPR const Char* parse_arg_id(const Char* begin, const Char* end,
2049                                         IDHandler&& handler) {
2050    FMT_ASSERT(begin != end, "");
2051    Char c = *begin;
2052    if (c == '}' || c == ':') {
2053      handler();
2054      return begin;
2055    }
2056    if (c >= '0' && c <= '9') {
2057      int index = 0;
2058      if (c != '0')
2059        index = parse_nonnegative_int(begin, end, handler);
2060      else
2061        ++begin;
2062      if (begin == end || (*begin != '}' && *begin != ':'))
2063        handler.on_error("invalid format string");
2064      else
2065        handler(index);
2066      return begin;
2067    }
2068    if (!is_name_start(c)) {
2069      handler.on_error("invalid format string");
2070      return begin;
2071    }
2072    auto it = begin;
2073    do {
2074      ++it;
2075    } while (it != end && (is_name_start(c = *it) || ('0' <= c && c <= '9')));
2076    handler(basic_string_view<Char>(begin, to_unsigned(it - begin)));
2077    return it;
2078  }
2079  template <typename SpecHandler, typename Char> struct width_adapter {
2080    explicit FMT_CONSTEXPR width_adapter(SpecHandler& h) : handler(h) {}
2081    FMT_CONSTEXPR void operator()() { handler.on_dynamic_width(auto_id()); }
2082    FMT_CONSTEXPR void operator()(int id) { handler.on_dynamic_width(id); }
2083    FMT_CONSTEXPR void operator()(basic_string_view<Char> id) {
2084      handler.on_dynamic_width(id);
2085    }
2086    FMT_CONSTEXPR void on_error(const char* message) {
2087      handler.on_error(message);
2088    }
2089    SpecHandler& handler;
2090  };
2091  template <typename SpecHandler, typename Char> struct precision_adapter {
2092    explicit FMT_CONSTEXPR precision_adapter(SpecHandler& h) : handler(h) {}
2093    FMT_CONSTEXPR void operator()() { handler.on_dynamic_precision(auto_id()); }
2094    FMT_CONSTEXPR void operator()(int id) { handler.on_dynamic_precision(id); }
2095    FMT_CONSTEXPR void operator()(basic_string_view<Char> id) {
2096      handler.on_dynamic_precision(id);
2097    }
2098    FMT_CONSTEXPR void on_error(const char* message) {
2099      handler.on_error(message);
2100    }
2101    SpecHandler& handler;
2102  };
2103  template <typename Char>
2104  FMT_CONSTEXPR const Char* next_code_point(const Char* begin, const Char* end) {
2105    if (const_check(sizeof(Char) != 1) || (*begin & 0x80) == 0) return begin + 1;
2106    do {
2107      ++begin;
2108    } while (begin != end && (*begin & 0xc0) == 0x80);
2109    return begin;
2110  }
2111  template <typename Char, typename Handler>
2112  FMT_CONSTEXPR const Char* parse_align(const Char* begin, const Char* end,
2113                                        Handler&& handler) {
2114    FMT_ASSERT(begin != end, "");
2115    auto align = align::none;
2116    auto p = next_code_point(begin, end);
2117    if (p == end) p = begin;
2118    for (;;) {
2119      switch (static_cast<int>(*p)) {
2120      case '<':
2121        align = align::left;
2122        break;
2123      case '>':
2124        align = align::right;
2125        break;
2126  #if FMT_DEPRECATED_NUMERIC_ALIGN
2127      case '=':
2128        align = align::numeric;
2129        break;
2130  #endif
2131      case '^':
2132        align = align::center;
2133        break;
2134      }
2135      if (align != align::none) {
2136        if (p != begin) {
2137          auto c = *begin;
2138          if (c == '{')
2139            return handler.on_error("invalid fill character '{'"), begin;
2140          handler.on_fill(basic_string_view<Char>(begin, to_unsigned(p - begin)));
2141          begin = p + 1;
2142        } else
2143          ++begin;
2144        handler.on_align(align);
2145        break;
2146      } else if (p == begin) {
2147        break;
2148      }
2149      p = begin;
2150    }
2151    return begin;
2152  }
2153  template <typename Char, typename Handler>
2154  FMT_CONSTEXPR const Char* parse_width(const Char* begin, const Char* end,
2155                                        Handler&& handler) {
2156    FMT_ASSERT(begin != end, "");
2157    if ('0' <= *begin && *begin <= '9') {
2158      handler.on_width(parse_nonnegative_int(begin, end, handler));
2159    } else if (*begin == '{') {
2160      ++begin;
2161      if (begin != end)
2162        begin = parse_arg_id(begin, end, width_adapter<Handler, Char>(handler));
2163      if (begin == end || *begin != '}')
2164        return handler.on_error("invalid format string"), begin;
2165      ++begin;
2166    }
2167    return begin;
2168  }
2169  template <typename Char, typename Handler>
2170  FMT_CONSTEXPR const Char* parse_precision(const Char* begin, const Char* end,
2171                                            Handler&& handler) {
2172    ++begin;
2173    auto c = begin != end ? *begin : Char();
2174    if ('0' <= c && c <= '9') {
2175      handler.on_precision(parse_nonnegative_int(begin, end, handler));
2176    } else if (c == '{') {
2177      ++begin;
2178      if (begin != end) {
2179        begin =
2180            parse_arg_id(begin, end, precision_adapter<Handler, Char>(handler));
2181      }
2182      if (begin == end || *begin++ != '}')
2183        return handler.on_error("invalid format string"), begin;
2184    } else {
2185      return handler.on_error("missing precision specifier"), begin;
2186    }
2187    handler.end_precision();
2188    return begin;
2189  }
2190  template <typename Char, typename SpecHandler>
2191  FMT_CONSTEXPR const Char* parse_format_specs(const Char* begin, const Char* end,
2192                                               SpecHandler&& handler) {
2193    if (begin == end || *begin == '}') return begin;
2194    begin = parse_align(begin, end, handler);
2195    if (begin == end) return begin;
2196    switch (static_cast<char>(*begin)) {
2197    case '+':
2198      handler.on_plus();
2199      ++begin;
2200      break;
2201    case '-':
2202      handler.on_minus();
2203      ++begin;
2204      break;
2205    case ' ':
2206      handler.on_space();
2207      ++begin;
2208      break;
2209    }
2210    if (begin == end) return begin;
2211    if (*begin == '#') {
2212      handler.on_hash();
2213      if (++begin == end) return begin;
2214    }
2215    if (*begin == '0') {
2216      handler.on_zero();
2217      if (++begin == end) return begin;
2218    }
2219    begin = parse_width(begin, end, handler);
2220    if (begin == end) return begin;
2221    if (*begin == '.') {
2222      begin = parse_precision(begin, end, handler);
2223    }
2224    if (begin != end && *begin != '}') handler.on_type(*begin++);
2225    return begin;
2226  }
2227  template <bool IS_CONSTEXPR, typename T, typename Ptr = const T*>
2228  FMT_CONSTEXPR bool find(Ptr first, Ptr last, T value, Ptr& out) {
2229    for (out = first; out != last; ++out) {
2230      if (*out == value) return true;
2231    }
2232    return false;
2233  }
2234  template <>
2235  inline bool find<false, char>(const char* first, const char* last, char value,
2236                                const char*& out) {
2237    out = static_cast<const char*>(
2238        std::memchr(first, value, detail::to_unsigned(last - first)));
2239    return out != nullptr;
2240  }
2241  template <typename Handler, typename Char> struct id_adapter {
2242    Handler& handler;
2243    int arg_id;
2244    FMT_CONSTEXPR void operator()() { arg_id = handler.on_arg_id(); }
2245    FMT_CONSTEXPR void operator()(int id) { arg_id = handler.on_arg_id(id); }
2246    FMT_CONSTEXPR void operator()(basic_string_view<Char> id) {
2247      arg_id = handler.on_arg_id(id);
2248    }
2249    FMT_CONSTEXPR void on_error(const char* message) {
2250      handler.on_error(message);
2251    }
2252  };
2253  template <typename Char, typename Handler>
2254  FMT_CONSTEXPR const Char* parse_replacement_field(const Char* begin,
2255                                                    const Char* end,
2256                                                    Handler&& handler) {
2257    ++begin;
2258    if (begin == end) return handler.on_error("invalid format string"), end;
2259    if (static_cast<char>(*begin) == '}') {
2260      handler.on_replacement_field(handler.on_arg_id(), begin);
2261    } else if (*begin == '{') {
2262      handler.on_text(begin, begin + 1);
2263    } else {
2264      auto adapter = id_adapter<Handler, Char>{handler, 0};
2265      begin = parse_arg_id(begin, end, adapter);
2266      Char c = begin != end ? *begin : Char();
2267      if (c == '}') {
2268        handler.on_replacement_field(adapter.arg_id, begin);
2269      } else if (c == ':') {
2270        begin = handler.on_format_specs(adapter.arg_id, begin + 1, end);
2271        if (begin == end || *begin != '}')
2272          return handler.on_error("unknown format specifier"), end;
2273      } else {
2274        return handler.on_error("missing '}' in format string"), end;
2275      }
2276    }
2277    return begin + 1;
2278  }
2279  template <bool IS_CONSTEXPR, typename Char, typename Handler>
2280  FMT_CONSTEXPR_DECL FMT_INLINE void parse_format_string(
2281      basic_string_view<Char> format_str, Handler&& handler) {
2282    auto begin = format_str.data();
2283    auto end = begin + format_str.size();
2284    if (end - begin < 32) {
2285      const Char* p = begin;
2286      while (p != end) {
2287        auto c = *p++;
2288        if (c == '{') {
2289          handler.on_text(begin, p - 1);
2290          begin = p = parse_replacement_field(p - 1, end, handler);
2291        } else if (c == '}') {
2292          if (p == end || *p != '}')
2293            return handler.on_error("unmatched '}' in format string");
2294          handler.on_text(begin, p);
2295          begin = ++p;
2296        }
2297      }
2298      handler.on_text(begin, end);
2299      return;
2300    }
2301    struct writer {
2302      FMT_CONSTEXPR void operator()(const Char* pbegin, const Char* pend) {
2303        if (pbegin == pend) return;
2304        for (;;) {
2305          const Char* p = nullptr;
2306          if (!find<IS_CONSTEXPR>(pbegin, pend, '}', p))
2307            return handler_.on_text(pbegin, pend);
2308          ++p;
2309          if (p == pend || *p != '}')
2310            return handler_.on_error("unmatched '}' in format string");
2311          handler_.on_text(pbegin, p);
2312          pbegin = p + 1;
2313        }
2314      }
2315      Handler& handler_;
2316    } write{handler};
2317    while (begin != end) {
2318      const Char* p = begin;
2319      if (*begin != '{' && !find<IS_CONSTEXPR>(begin + 1, end, '{', p))
2320        return write(begin, end);
2321      write(begin, p);
2322      begin = parse_replacement_field(p, end, handler);
2323    }
2324  }
2325  template <typename T, typename ParseContext>
2326  FMT_CONSTEXPR const typename ParseContext::char_type* parse_format_specs(
2327      ParseContext& ctx) {
2328    using char_type = typename ParseContext::char_type;
2329    using context = buffer_context<char_type>;
2330    using mapped_type =
2331        conditional_t<detail::mapped_type_constant<T, context>::value !=
2332                          type::custom_type,
2333                      decltype(arg_mapper<context>().map(std::declval<T>())), T>;
2334    auto f = conditional_t<has_formatter<mapped_type, context>::value,
2335                           formatter<mapped_type, char_type>,
2336                           detail::fallback_formatter<T, char_type>>();
2337    return f.parse(ctx);
2338  }
2339  template <typename ArgFormatter, typename Char, typename Context>
2340  struct format_handler : detail::error_handler {
2341    basic_format_parse_context<Char> parse_context;
2342    Context context;
2343    format_handler(typename ArgFormatter::iterator out,
2344                   basic_string_view<Char> str,
2345                   basic_format_args<Context> format_args, detail::locale_ref loc)
2346        : parse_context(str), context(out, format_args, loc) {}
2347    void on_text(const Char* begin, const Char* end) {
2348      auto size = to_unsigned(end - begin);
2349      auto out = context.out();
2350      auto&& it = reserve(out, size);
2351      it = std::copy_n(begin, size, it);
2352      context.advance_to(out);
2353    }
2354    int on_arg_id() { return parse_context.next_arg_id(); }
2355    int on_arg_id(int id) { return parse_context.check_arg_id(id), id; }
2356    int on_arg_id(basic_string_view<Char> id) {
2357      int arg_id = context.arg_id(id);
2358      if (arg_id < 0) on_error("argument not found");
2359      return arg_id;
2360    }
2361    FMT_INLINE void on_replacement_field(int id, const Char*) {
2362      auto arg = get_arg(context, id);
2363      context.advance_to(visit_format_arg(
2364          default_arg_formatter<typename ArgFormatter::iterator, Char>{
2365              context.out(), context.args(), context.locale()},
2366          arg));
2367    }
2368    const Char* on_format_specs(int id, const Char* begin, const Char* end) {
2369      advance_to(parse_context, begin);
2370      auto arg = get_arg(context, id);
2371      custom_formatter<Context> f(parse_context, context);
2372      if (visit_format_arg(f, arg)) return parse_context.begin();
2373      basic_format_specs<Char> specs;
2374      using parse_context_t = basic_format_parse_context<Char>;
2375      specs_checker<specs_handler<parse_context_t, Context>> handler(
2376          specs_handler<parse_context_t, Context>(specs, parse_context, context),
2377          arg.type());
2378      begin = parse_format_specs(begin, end, handler);
2379      if (begin == end || *begin != '}') on_error("missing '}' in format string");
2380      advance_to(parse_context, begin);
2381      context.advance_to(
2382          visit_format_arg(ArgFormatter(context, &parse_context, &specs), arg));
2383      return begin;
2384    }
2385  };
2386  template <typename Char, typename ErrorHandler = error_handler>
2387  class compile_parse_context
2388      : public basic_format_parse_context<Char, ErrorHandler> {
2389   private:
2390    int num_args_;
2391    using base = basic_format_parse_context<Char, ErrorHandler>;
2392   public:
2393    explicit FMT_CONSTEXPR compile_parse_context(
2394        basic_string_view<Char> format_str, int num_args = max_value<int>(),
2395        ErrorHandler eh = {})
2396        : base(format_str, eh), num_args_(num_args) {}
2397    FMT_CONSTEXPR int next_arg_id() {
2398      int id = base::next_arg_id();
2399      if (id >= num_args_) this->on_error("argument not found");
2400      return id;
2401    }
2402    FMT_CONSTEXPR void check_arg_id(int id) {
2403      base::check_arg_id(id);
2404      if (id >= num_args_) this->on_error("argument not found");
2405    }
2406    using base::check_arg_id;
2407  };
2408  template <typename Char, typename ErrorHandler, typename... Args>
2409  class format_string_checker {
2410   public:
2411    explicit FMT_CONSTEXPR format_string_checker(
2412        basic_string_view<Char> format_str, ErrorHandler eh)
2413        : context_(format_str, num_args, eh),
2414          parse_funcs_{&parse_format_specs<Args, parse_context_type>...} {}
2415    FMT_CONSTEXPR void on_text(const Char*, const Char*) {}
2416    FMT_CONSTEXPR int on_arg_id() { return context_.next_arg_id(); }
2417    FMT_CONSTEXPR int on_arg_id(int id) { return context_.check_arg_id(id), id; }
2418    FMT_CONSTEXPR int on_arg_id(basic_string_view<Char>) {
2419      on_error("compile-time checks don't support named arguments");
2420      return 0;
2421    }
2422    FMT_CONSTEXPR void on_replacement_field(int, const Char*) {}
2423    FMT_CONSTEXPR const Char* on_format_specs(int id, const Char* begin,
2424                                              const Char*) {
2425      advance_to(context_, begin);
2426      return id < num_args ? parse_funcs_[id](context_) : begin;
2427    }
2428    FMT_CONSTEXPR void on_error(const char* message) {
2429      context_.on_error(message);
2430    }
2431   private:
2432    using parse_context_type = compile_parse_context<Char, ErrorHandler>;
2433    enum { num_args = sizeof...(Args) };
2434    using parse_func = const Char* (*)(parse_context_type&);
2435    parse_context_type context_;
2436    parse_func parse_funcs_[num_args > 0 ? num_args : 1];
2437  };
2438  template <typename Char, size_t N>
2439  FMT_CONSTEXPR basic_string_view<Char> compile_string_to_view(
2440      const Char (&s)[N]) {
2441    return {s,
2442            N - ((std::char_traits<Char>::to_int_type(s[N - 1]) == 0) ? 1 : 0)};
2443  }
2444  template <typename Char>
2445  FMT_CONSTEXPR basic_string_view<Char> compile_string_to_view(
2446      const std_string_view<Char>& s) {
2447    return {s.data(), s.size()};
2448  }
2449  #define FMT_STRING_IMPL(s, base)                                  \
2450    [] {                                                            \
2451            \
2452      struct FMT_COMPILE_STRING : base {                            \
2453        using char_type = fmt::remove_cvref_t<decltype(s[0])>;      \
2454        FMT_MAYBE_UNUSED FMT_CONSTEXPR                              \
2455        operator fmt::basic_string_view<char_type>() const {        \
2456          return fmt::detail::compile_string_to_view<char_type>(s); \
2457        }                                                           \
2458      };                                                            \
2459      return FMT_COMPILE_STRING();                                  \
2460    }()
2461  #define FMT_STRING(s) FMT_STRING_IMPL(s, fmt::compile_string)
2462  template <typename... Args, typename S,
2463            enable_if_t<(is_compile_string<S>::value), int>>
2464  void check_format_string(S format_str) {
2465    FMT_CONSTEXPR_DECL auto s = to_string_view(format_str);
2466    using checker = format_string_checker<typename S::char_type, error_handler,
2467                                          remove_cvref_t<Args>...>;
2468    FMT_CONSTEXPR_DECL bool invalid_format =
2469        (parse_format_string<true>(s, checker(s, {})), true);
2470    (void)invalid_format;
2471  }
2472  template <template <typename> class Handler, typename Context>
2473  void handle_dynamic_spec(int& value, arg_ref<typename Context::char_type> ref,
2474                           Context& ctx) {
2475    switch (ref.kind) {
2476    case arg_id_kind::none:
2477      break;
2478    case arg_id_kind::index:
2479      value = detail::get_dynamic_spec<Handler>(ctx.arg(ref.val.index),
2480                                                ctx.error_handler());
2481      break;
2482    case arg_id_kind::name:
2483      value = detail::get_dynamic_spec<Handler>(ctx.arg(ref.val.name),
2484                                                ctx.error_handler());
2485      break;
2486    }
2487  }
2488  using format_func = void (*)(detail::buffer<char>&, int, string_view);
2489  FMT_API void format_error_code(buffer<char>& out, int error_code,
2490                                 string_view message) FMT_NOEXCEPT;
2491  FMT_API void report_error(format_func func, int error_code,
2492                            string_view message) FMT_NOEXCEPT;
2493  template <typename OutputIt, typename Char>
2494  class arg_formatter : public arg_formatter_base<OutputIt, Char> {
2495   private:
2496    using char_type = Char;
2497    using base = arg_formatter_base<OutputIt, Char>;
2498    using context_type = basic_format_context<OutputIt, Char>;
2499    context_type& ctx_;
2500    basic_format_parse_context<char_type>* parse_ctx_;
2501    const Char* ptr_;
2502   public:
2503    using iterator = typename base::iterator;
2504    using format_specs = typename base::format_specs;
2505    explicit arg_formatter(
2506        context_type& ctx,
2507        basic_format_parse_context<char_type>* parse_ctx = nullptr,
2508        format_specs* specs = nullptr, const Char* ptr = nullptr)
2509        : base(ctx.out(), specs, ctx.locale()),
2510          ctx_(ctx),
2511          parse_ctx_(parse_ctx),
2512          ptr_(ptr) {}
2513    using base::operator();
2514    iterator operator()(typename basic_format_arg<context_type>::handle handle) {
2515      if (ptr_) advance_to(*parse_ctx_, ptr_);
2516      handle.format(*parse_ctx_, ctx_);
2517      return ctx_.out();
2518    }
2519  };
2520  }  
2521  template <typename OutputIt, typename Char>
2522  using arg_formatter FMT_DEPRECATED_ALIAS =
2523      detail::arg_formatter<OutputIt, Char>;
2524  FMT_CLASS_API
2525  class FMT_API system_error : public std::runtime_error {
2526   private:
2527    void init(int err_code, string_view format_str, format_args args);
2528   protected:
2529    int error_code_;
2530    system_error() : std::runtime_error(""), error_code_(0) {}
2531   public:
2532    template <typename... Args>
2533    system_error(int error_code, string_view message, const Args&... args)
2534        : std::runtime_error("") {
2535      init(error_code, message, make_format_args(args...));
2536    }
2537    system_error(const system_error&) = default;
2538    system_error& operator=(const system_error&) = default;
2539    system_error(system_error&&) = default;
2540    system_error& operator=(system_error&&) = default;
2541    ~system_error() FMT_NOEXCEPT FMT_OVERRIDE;
2542    int error_code() const { return error_code_; }
2543  };
2544  FMT_API void format_system_error(detail::buffer<char>& out, int error_code,
2545                                   string_view message) FMT_NOEXCEPT;
2546  FMT_API void report_system_error(int error_code,
2547                                   string_view message) FMT_NOEXCEPT;
2548  class format_int {
2549   private:
2550    enum { buffer_size = std::numeric_limits<unsigned long long>::digits10 + 3 };
2551    mutable char buffer_[buffer_size];
2552    char* str_;
2553    template <typename UInt> char* format_unsigned(UInt value) {
2554      auto n = static_cast<detail::uint32_or_64_or_128_t<UInt>>(value);
2555      return detail::format_decimal(buffer_, n, buffer_size - 1).begin;
2556    }
2557    template <typename Int> char* format_signed(Int value) {
2558      auto abs_value = static_cast<detail::uint32_or_64_or_128_t<Int>>(value);
2559      bool negative = value < 0;
2560      if (negative) abs_value = 0 - abs_value;
2561      auto begin = format_unsigned(abs_value);
2562      if (negative) *--begin = '-';
2563      return begin;
2564    }
2565   public:
2566    explicit format_int(int value) : str_(format_signed(value)) {}
2567    explicit format_int(long value) : str_(format_signed(value)) {}
2568    explicit format_int(long long value) : str_(format_signed(value)) {}
2569    explicit format_int(unsigned value) : str_(format_unsigned(value)) {}
2570    explicit format_int(unsigned long value) : str_(format_unsigned(value)) {}
2571    explicit format_int(unsigned long long value)
2572        : str_(format_unsigned(value)) {}
2573    size_t size() const {
2574      return detail::to_unsigned(buffer_ - str_ + buffer_size - 1);
2575    }
2576    const char* data() const { return str_; }
2577    const char* c_str() const {
2578      buffer_[buffer_size - 1] = '\0';
2579      return str_;
2580    }
2581    std::string str() const { return std::string(str_, size()); }
2582  };
2583  template <typename T, typename Char>
2584  struct formatter<T, Char,
2585                   enable_if_t<detail::type_constant<T, Char>::value !=
2586                               detail::type::custom_type>> {
2587    FMT_CONSTEXPR formatter() = default;
2588    template <typename ParseContext>
2589    FMT_CONSTEXPR auto parse(ParseContext& ctx) -> decltype(ctx.begin()) {
2590      using handler_type = detail::dynamic_specs_handler<ParseContext>;
2591      auto type = detail::type_constant<T, Char>::value;
2592      detail::specs_checker<handler_type> handler(handler_type(specs_, ctx),
2593                                                  type);
2594      auto it = parse_format_specs(ctx.begin(), ctx.end(), handler);
2595      auto eh = ctx.error_handler();
2596      switch (type) {
2597      case detail::type::none_type:
2598        FMT_ASSERT(false, "invalid argument type");
2599        break;
2600      case detail::type::int_type:
2601      case detail::type::uint_type:
2602      case detail::type::long_long_type:
2603      case detail::type::ulong_long_type:
2604      case detail::type::int128_type:
2605      case detail::type::uint128_type:
2606      case detail::type::bool_type:
2607        handle_int_type_spec(specs_.type,
2608                             detail::int_type_checker<decltype(eh)>(eh));
2609        break;
2610      case detail::type::char_type:
2611        handle_char_specs(
2612            &specs_, detail::char_specs_checker<decltype(eh)>(specs_.type, eh));
2613        break;
2614      case detail::type::float_type:
2615        if (detail::const_check(FMT_USE_FLOAT))
2616          detail::parse_float_type_spec(specs_, eh);
2617        else
2618          FMT_ASSERT(false, "float support disabled");
2619        break;
2620      case detail::type::double_type:
2621        if (detail::const_check(FMT_USE_DOUBLE))
2622          detail::parse_float_type_spec(specs_, eh);
2623        else
2624          FMT_ASSERT(false, "double support disabled");
2625        break;
2626      case detail::type::long_double_type:
2627        if (detail::const_check(FMT_USE_LONG_DOUBLE))
2628          detail::parse_float_type_spec(specs_, eh);
2629        else
2630          FMT_ASSERT(false, "long double support disabled");
2631        break;
2632      case detail::type::cstring_type:
2633        detail::handle_cstring_type_spec(
2634            specs_.type, detail::cstring_type_checker<decltype(eh)>(eh));
2635        break;
2636      case detail::type::string_type:
2637        detail::check_string_type_spec(specs_.type, eh);
2638        break;
2639      case detail::type::pointer_type:
2640        detail::check_pointer_type_spec(specs_.type, eh);
2641        break;
2642      case detail::type::custom_type:
2643        break;
2644      }
2645      return it;
2646    }
2647    template <typename FormatContext>
2648    auto format(const T& val, FormatContext& ctx) -> decltype(ctx.out()) {
2649      detail::handle_dynamic_spec<detail::width_checker>(specs_.width,
2650                                                         specs_.width_ref, ctx);
2651      detail::handle_dynamic_spec<detail::precision_checker>(
2652          specs_.precision, specs_.precision_ref, ctx);
2653      using af = detail::arg_formatter<typename FormatContext::iterator,
2654                                       typename FormatContext::char_type>;
2655      return visit_format_arg(af(ctx, nullptr, &specs_),
2656                              detail::make_arg<FormatContext>(val));
2657    }
2658   private:
2659    detail::dynamic_format_specs<Char> specs_;
2660  };
2661  #define FMT_FORMAT_AS(Type, Base)                                             \
2662    template <typename Char>                                                    \
2663    struct formatter<Type, Char> : formatter<Base, Char> {                      \
2664      template <typename FormatContext>                                         \
2665      auto format(Type const& val, FormatContext& ctx) -> decltype(ctx.out()) { \
2666        return formatter<Base, Char>::format(val, ctx);                         \
2667      }                                                                         \
2668    }
2669  FMT_FORMAT_AS(signed char, int);
2670  FMT_FORMAT_AS(unsigned char, unsigned);
2671  FMT_FORMAT_AS(short, int);
2672  FMT_FORMAT_AS(unsigned short, unsigned);
2673  FMT_FORMAT_AS(long, long long);
2674  FMT_FORMAT_AS(unsigned long, unsigned long long);
2675  FMT_FORMAT_AS(Char*, const Char*);
2676  FMT_FORMAT_AS(std::basic_string<Char>, basic_string_view<Char>);
2677  FMT_FORMAT_AS(std::nullptr_t, const void*);
2678  FMT_FORMAT_AS(detail::std_string_view<Char>, basic_string_view<Char>);
2679  template <typename Char>
2680  struct formatter<void*, Char> : formatter<const void*, Char> {
2681    template <typename FormatContext>
2682    auto format(void* val, FormatContext& ctx) -> decltype(ctx.out()) {
2683      return formatter<const void*, Char>::format(val, ctx);
2684    }
2685  };
2686  template <typename Char, size_t N>
2687  struct formatter<Char[N], Char> : formatter<basic_string_view<Char>, Char> {
2688    template <typename FormatContext>
2689    auto format(const Char* val, FormatContext& ctx) -> decltype(ctx.out()) {
2690      return formatter<basic_string_view<Char>, Char>::format(val, ctx);
2691    }
2692  };
2693  template <typename Char = char> class dynamic_formatter {
2694   private:
2695    struct null_handler : detail::error_handler {
2696      void on_align(align_t) {}
2697      void on_plus() {}
2698      void on_minus() {}
2699      void on_space() {}
2700      void on_hash() {}
2701    };
2702   public:
2703    template <typename ParseContext>
2704    auto parse(ParseContext& ctx) -> decltype(ctx.begin()) {
2705      format_str_ = ctx.begin();
2706      detail::dynamic_specs_handler<ParseContext> handler(specs_, ctx);
2707      return parse_format_specs(ctx.begin(), ctx.end(), handler);
2708    }
2709    template <typename T, typename FormatContext>
2710    auto format(const T& val, FormatContext& ctx) -> decltype(ctx.out()) {
2711      handle_specs(ctx);
2712      detail::specs_checker<null_handler> checker(
2713          null_handler(), detail::mapped_type_constant<T, FormatContext>::value);
2714      checker.on_align(specs_.align);
2715      switch (specs_.sign) {
2716      case sign::none:
2717        break;
2718      case sign::plus:
2719        checker.on_plus();
2720        break;
2721      case sign::minus:
2722        checker.on_minus();
2723        break;
2724      case sign::space:
2725        checker.on_space();
2726        break;
2727      }
2728      if (specs_.alt) checker.on_hash();
2729      if (specs_.precision >= 0) checker.end_precision();
2730      using af = detail::arg_formatter<typename FormatContext::iterator,
2731                                       typename FormatContext::char_type>;
2732      visit_format_arg(af(ctx, nullptr, &specs_),
2733                       detail::make_arg<FormatContext>(val));
2734      return ctx.out();
2735    }
2736   private:
2737    template <typename Context> void handle_specs(Context& ctx) {
2738      detail::handle_dynamic_spec<detail::width_checker>(specs_.width,
2739                                                         specs_.width_ref, ctx);
2740      detail::handle_dynamic_spec<detail::precision_checker>(
2741          specs_.precision, specs_.precision_ref, ctx);
2742    }
2743    detail::dynamic_format_specs<Char> specs_;
2744    const Char* format_str_;
2745  };
2746  template <typename Char, typename ErrorHandler>
2747  FMT_CONSTEXPR void advance_to(
2748      basic_format_parse_context<Char, ErrorHandler>& ctx, const Char* p) {
2749    ctx.advance_to(ctx.begin() + (p - &*ctx.begin()));
2750  }
2751  template <typename ArgFormatter, typename Char, typename Context>
2752  typename Context::iterator vformat_to(
2753      typename ArgFormatter::iterator out, basic_string_view<Char> format_str,
2754      basic_format_args<Context> args,
2755      detail::locale_ref loc = detail::locale_ref()) {
2756    if (format_str.size() == 2 && detail::equal2(format_str.data(), "{}")) {
2757      auto arg = args.get(0);
2758      if (!arg) detail::error_handler().on_error("argument not found");
2759      using iterator = typename ArgFormatter::iterator;
2760      return visit_format_arg(
2761          detail::default_arg_formatter<iterator, Char>{out, args, loc}, arg);
2762    }
2763    detail::format_handler<ArgFormatter, Char, Context> h(out, format_str, args,
2764                                                          loc);
2765    detail::parse_format_string<false>(format_str, h);
2766    return h.context.out();
2767  }
2768  template <typename T> inline const void* ptr(const T* p) { return p; }
2769  template <typename T> inline const void* ptr(const std::unique_ptr<T>& p) {
2770    return p.get();
2771  }
2772  template <typename T> inline const void* ptr(const std::shared_ptr<T>& p) {
2773    return p.get();
2774  }
2775  class bytes {
2776   private:
2777    string_view data_;
2778    friend struct formatter<bytes>;
2779   public:
2780    explicit bytes(string_view data) : data_(data) {}
2781  };
2782  template <> struct formatter<bytes> {
2783   private:
2784    detail::dynamic_format_specs<char> specs_;
2785   public:
2786    template <typename ParseContext>
2787    FMT_CONSTEXPR auto parse(ParseContext& ctx) -> decltype(ctx.begin()) {
2788      using handler_type = detail::dynamic_specs_handler<ParseContext>;
2789      detail::specs_checker<handler_type> handler(handler_type(specs_, ctx),
2790                                                  detail::type::string_type);
2791      auto it = parse_format_specs(ctx.begin(), ctx.end(), handler);
2792      detail::check_string_type_spec(specs_.type, ctx.error_handler());
2793      return it;
2794    }
2795    template <typename FormatContext>
2796    auto format(bytes b, FormatContext& ctx) -> decltype(ctx.out()) {
2797      detail::handle_dynamic_spec<detail::width_checker>(specs_.width,
2798                                                         specs_.width_ref, ctx);
2799      detail::handle_dynamic_spec<detail::precision_checker>(
2800          specs_.precision, specs_.precision_ref, ctx);
2801      return detail::write_bytes(ctx.out(), b.data_, specs_);
2802    }
2803  };
2804  template <typename It, typename Sentinel, typename Char>
2805  struct arg_join : detail::view {
2806    It begin;
2807    Sentinel end;
2808    basic_string_view<Char> sep;
2809    arg_join(It b, Sentinel e, basic_string_view<Char> s)
2810        : begin(b), end(e), sep(s) {}
2811  };
2812  template <typename It, typename Sentinel, typename Char>
2813  struct formatter<arg_join<It, Sentinel, Char>, Char>
2814      : formatter<typename std::iterator_traits<It>::value_type, Char> {
2815    template <typename FormatContext>
2816    auto format(const arg_join<It, Sentinel, Char>& value, FormatContext& ctx)
2817        -> decltype(ctx.out()) {
2818      using base = formatter<typename std::iterator_traits<It>::value_type, Char>;
2819      auto it = value.begin;
2820      auto out = ctx.out();
2821      if (it != value.end) {
2822        out = base::format(*it++, ctx);
2823        while (it != value.end) {
2824          out = std::copy(value.sep.begin(), value.sep.end(), out);
2825          ctx.advance_to(out);
2826          out = base::format(*it++, ctx);
2827        }
2828      }
2829      return out;
2830    }
2831  };
2832  template <typename It, typename Sentinel>
2833  arg_join<It, Sentinel, char> join(It begin, Sentinel end, string_view sep) {
2834    return {begin, end, sep};
2835  }
2836  template <typename It, typename Sentinel>
2837  arg_join<It, Sentinel, wchar_t> join(It begin, Sentinel end, wstring_view sep) {
2838    return {begin, end, sep};
2839  }
2840  template <typename Range>
2841  arg_join<detail::iterator_t<Range>, detail::sentinel_t<Range>, char> join(
2842      Range&& range, string_view sep) {
2843    return join(std::begin(range), std::end(range), sep);
2844  }
2845  template <typename Range>
2846  arg_join<detail::iterator_t<Range>, detail::sentinel_t<Range>, wchar_t> join(
2847      Range&& range, wstring_view sep) {
2848    return join(std::begin(range), std::end(range), sep);
2849  }
2850  template <typename T, FMT_ENABLE_IF(!std::is_integral<T>::value)>
2851  inline std::string to_string(const T& value) {
2852    std::string result;
2853    detail::write<char>(std::back_inserter(result), value);
2854    return result;
2855  }
2856  template <typename T, FMT_ENABLE_IF(std::is_integral<T>::value)>
2857  inline std::string to_string(T value) {
2858    constexpr int max_size = detail::digits10<T>() + 2;
2859    char buffer[max_size > 5 ? static_cast<unsigned>(max_size) : 5];
2860    char* begin = buffer;
2861    return std::string(begin, detail::write<char>(begin, value));
2862  }
2863  template <typename T> inline std::wstring to_wstring(const T& value) {
2864    return format(L"{}", value);
2865  }
2866  template <typename Char, size_t SIZE>
2867  std::basic_string<Char> to_string(const basic_memory_buffer<Char, SIZE>& buf) {
2868    auto size = buf.size();
2869    detail::assume(size < std::basic_string<Char>().max_size());
2870    return std::basic_string<Char>(buf.data(), size);
2871  }
2872  template <typename Char>
2873  detail::buffer_appender<Char> detail::vformat_to(
2874      detail::buffer<Char>& buf, basic_string_view<Char> format_str,
2875      basic_format_args<buffer_context<type_identity_t<Char>>> args) {
2876    using af = arg_formatter<typename buffer_context<Char>::iterator, Char>;
2877    return vformat_to<af>(buffer_appender<Char>(buf), format_str, args);
2878  }
2879  #ifndef FMT_HEADER_ONLY
2880  extern template format_context::iterator detail::vformat_to(
2881      detail::buffer<char>&, string_view, basic_format_args<format_context>);
2882  namespace detail {
2883  extern template FMT_API std::string grouping_impl<char>(locale_ref loc);
2884  extern template FMT_API std::string grouping_impl<wchar_t>(locale_ref loc);
2885  extern template FMT_API char thousands_sep_impl<char>(locale_ref loc);
2886  extern template FMT_API wchar_t thousands_sep_impl<wchar_t>(locale_ref loc);
2887  extern template FMT_API char decimal_point_impl(locale_ref loc);
2888  extern template FMT_API wchar_t decimal_point_impl(locale_ref loc);
2889  extern template int format_float<double>(double value, int precision,
2890                                           float_specs specs, buffer<char>& buf);
2891  extern template int format_float<long double>(long double value, int precision,
2892                                                float_specs specs,
2893                                                buffer<char>& buf);
2894  int snprintf_float(float value, int precision, float_specs specs,
2895                     buffer<char>& buf) = delete;
2896  extern template int snprintf_float<double>(double value, int precision,
2897                                             float_specs specs,
2898                                             buffer<char>& buf);
2899  extern template int snprintf_float<long double>(long double value,
2900                                                  int precision,
2901                                                  float_specs specs,
2902                                                  buffer<char>& buf);
2903  }  
2904  #endif
2905  template <typename S, typename Char = char_t<S>,
2906            FMT_ENABLE_IF(detail::is_string<S>::value)>
2907  inline typename FMT_BUFFER_CONTEXT(Char)::iterator vformat_to(
2908      detail::buffer<Char>& buf, const S& format_str,
2909      basic_format_args<FMT_BUFFER_CONTEXT(type_identity_t<Char>)> args) {
2910    return detail::vformat_to(buf, to_string_view(format_str), args);
2911  }
2912  template <typename S, typename... Args, size_t SIZE = inline_buffer_size,
2913            typename Char = enable_if_t<detail::is_string<S>::value, char_t<S>>>
2914  inline typename buffer_context<Char>::iterator format_to(
2915      basic_memory_buffer<Char, SIZE>& buf, const S& format_str, Args&&... args) {
2916    const auto& vargs = fmt::make_args_checked<Args...>(format_str, args...);
2917    return detail::vformat_to(buf, to_string_view(format_str), vargs);
2918  }
2919  template <typename OutputIt, typename Char = char>
2920  using format_context_t = basic_format_context<OutputIt, Char>;
2921  template <typename OutputIt, typename Char = char>
2922  using format_args_t = basic_format_args<format_context_t<OutputIt, Char>>;
2923  template <typename OutputIt, typename Char = typename OutputIt::value_type>
2924  using format_to_n_context FMT_DEPRECATED_ALIAS = buffer_context<Char>;
2925  template <typename OutputIt, typename Char = typename OutputIt::value_type>
2926  using format_to_n_args FMT_DEPRECATED_ALIAS =
2927      basic_format_args<buffer_context<Char>>;
2928  template <typename OutputIt, typename Char, typename... Args>
2929  FMT_DEPRECATED format_arg_store<buffer_context<Char>, Args...>
2930  make_format_to_n_args(const Args&... args) {
2931    return format_arg_store<buffer_context<Char>, Args...>(args...);
2932  }
2933  template <typename Char, enable_if_t<(!std::is_same<Char, char>::value), int>>
2934  std::basic_string<Char> detail::vformat(
2935      basic_string_view<Char> format_str,
2936      basic_format_args<buffer_context<type_identity_t<Char>>> args) {
2937    basic_memory_buffer<Char> buffer;
2938    detail::vformat_to(buffer, format_str, args);
2939    return to_string(buffer);
2940  }
2941  template <typename Char, FMT_ENABLE_IF(std::is_same<Char, wchar_t>::value)>
2942  void vprint(std::FILE* f, basic_string_view<Char> format_str,
2943              wformat_args args) {
2944    wmemory_buffer buffer;
2945    detail::vformat_to(buffer, format_str, args);
2946    buffer.push_back(L'\0');
2947    if (std::fputws(buffer.data(), f) == -1)
2948      FMT_THROW(system_error(errno, "cannot write to file"));
2949  }
2950  template <typename Char, FMT_ENABLE_IF(std::is_same<Char, wchar_t>::value)>
2951  void vprint(basic_string_view<Char> format_str, wformat_args args) {
2952    vprint(stdout, format_str, args);
2953  }
2954  #if FMT_USE_USER_DEFINED_LITERALS
2955  namespace detail {
2956  #  if FMT_USE_UDL_TEMPLATE
2957  template <typename Char, Char... CHARS> class udl_formatter {
2958   public:
2959    template <typename... Args>
2960    std::basic_string<Char> operator()(Args&&... args) const {
2961      static FMT_CONSTEXPR_DECL Char s[] = {CHARS..., '\0'};
2962      return format(FMT_STRING(s), std::forward<Args>(args)...);
2963    }
2964  };
2965  #  else
2966  template <typename Char> struct udl_formatter {
2967    basic_string_view<Char> str;
2968    template <typename... Args>
2969    std::basic_string<Char> operator()(Args&&... args) const {
2970      return format(str, std::forward<Args>(args)...);
2971    }
2972  };
2973  #  endif  
2974  template <typename Char> struct udl_arg {
2975    const Char* str;
2976    template <typename T> named_arg<Char, T> operator=(T&& value) const {
2977      return {str, std::forward<T>(value)};
2978    }
2979  };
2980  }  
2981  inline namespace literals {
2982  #  if FMT_USE_UDL_TEMPLATE
2983  #    pragma GCC diagnostic push
2984  #    pragma GCC diagnostic ignored "-Wpedantic"
2985  #    if FMT_CLANG_VERSION
2986  #      pragma GCC diagnostic ignored "-Wgnu-string-literal-operator-template"
2987  #    endif
2988  template <typename Char, Char... CHARS>
2989  FMT_CONSTEXPR detail::udl_formatter<Char, CHARS...> operator""_format() {
2990    return {};
2991  }
2992  #    pragma GCC diagnostic pop
2993  #  else
2994  FMT_CONSTEXPR detail::udl_formatter<char> operator"" _format(const char* s,
2995                                                               size_t n) {
2996    return {{s, n}};
2997  }
2998  FMT_CONSTEXPR detail::udl_formatter<wchar_t> operator"" _format(
2999      const wchar_t* s, size_t n) {
3000    return {{s, n}};
3001  }
3002  #  endif  
3003  FMT_CONSTEXPR detail::udl_arg<char> operator"" _a(const char* s, size_t) {
3004    return {s};
3005  }
3006  FMT_CONSTEXPR detail::udl_arg<wchar_t> operator"" _a(const wchar_t* s, size_t) {
3007    return {s};
3008  }
3009  }  
3010  #endif  
3011  FMT_END_NAMESPACE
3012  #ifdef FMT_HEADER_ONLY
3013  #  define FMT_FUNC inline
3014  #  include "format-inl.h"
3015  #else
3016  #  define FMT_FUNC
3017  #endif
3018  #endif  
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from android-gpuimage-plus-MDEwOlJlcG9zaXRvcnk0NjU0NzQxNw==-flat-cgeVideoPlayer.h</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from xmrig-MDEwOlJlcG9zaXRvcnk4ODMyNzQwNg==-flat-format.h</div>
                </div>
                <div class="column column_space"><pre><code>16      virtual void pause() {}
17      virtual void resume() {}
18      virtual void render() {}
19      virtual bool update(double time) { return false; }
</pre></code></div>
                <div class="column column_space"><pre><code>1103    FMT_CONSTEXPR void on_bin() {}
1104    FMT_CONSTEXPR void on_oct() {}
1105    FMT_CONSTEXPR void on_num() {}
1106    FMT_CONSTEXPR void on_chr() {}
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    