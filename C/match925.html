<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for tiffload.c &amp; csvload.c</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for tiffload.c &amp; csvload.c
      </h3>
<h1 align="center">
        33.1%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>tiffload.c (41.353382%)<th>csvload.c (27.70781%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(226-280)<td><a href="#" name="0">(591-646)</a><td align="center"><font color="#ff0000">38</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(344-361)<td><a href="#" name="1">(555-576)</a><td align="center"><font color="#a10000">24</font>
<tr onclick='openModal("#980517")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#980517"><font color="#980517">-</font><td><a href="#" name="2">(174-225)<td><a href="#" name="2">(468-514)</a><td align="center"><font color="#860000">20</font>
<tr onclick='openModal("#53858b")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#53858b"><font color="#53858b">-</font><td><a href="#" name="3">(443-552)<td><a href="#" name="3">(648-737)</a><td align="center"><font color="#6b0000">16</font>
<tr onclick='openModal("#6cc417")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#6cc417"><font color="#6cc417">-</font><td><a href="#" name="4">(155-163)<td><a href="#" name="4">(458-466)</a><td align="center"><font color="#500000">12</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>tiffload.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 #ifdef HAVE_CONFIG_H
2 #include &lt;config.h&gt;
3 #include &lt;vips/intl.h&gt;
4 #include &lt;stdio.h&gt;
5 #include &lt;stdlib.h&gt;
6 #include &lt;string.h&gt;
7 #include &lt;vips/vips.h&gt;
8 #include &lt;vips/buf.h&gt;
9 #include &lt;vips/internal.h&gt;
10 #include "pforeign.h"
11 #ifdef HAVE_TIFF
12 typedef struct _VipsForeignLoadTiff {
13 	VipsForeignLoad parent_object;
14 	VipsSource *source;
15 	int page;
16 	int n;
17 	int subifd;
18 	gboolean autorotate;
19 } VipsForeignLoadTiff;
20 typedef VipsForeignLoadClass VipsForeignLoadTiffClass;
21 G_DEFINE_ABSTRACT_TYPE( VipsForeignLoadTiff, vips_foreign_load_tiff, 
22 	VIPS_TYPE_FOREIGN_LOAD );
23 static void
24 vips_foreign_load_tiff_dispose( GObject *gobject )
25 {
26 	VipsForeignLoadTiff *tiff = (VipsForeignLoadTiff *) gobject;
27 	VIPS_UNREF( tiff-&gt;source );
28 	G_OBJECT_CLASS( vips_foreign_load_tiff_parent_class )-&gt;
29 		dispose( gobject );
30 }
31 static VipsForeignFlags
32 vips_foreign_load_tiff_get_flags_source( VipsSource *source )
33 {
34 	VipsForeignFlags flags;
35 	flags = 0;
36 	if( vips__istifftiled_source( source ) ) 
37 		flags |= VIPS_FOREIGN_PARTIAL;
38 	else
39 		flags |= VIPS_FOREIGN_SEQUENTIAL;
40 	return( flags );
41 }
42 static VipsForeignFlags
43 vips_foreign_load_tiff_get_flags_filename( const char *filename )
44 {
45 	VipsSource *source;
46 	VipsForeignFlags flags;
47 	if( !(source = vips_source_new_from_file( filename )) )
48 		return( 0 );
49 	flags = vips_foreign_load_tiff_get_flags_source( source );
50 	VIPS_UNREF( source );
51 	return( flags );
52 }
53 static VipsForeignFlags
54 vips_foreign_load_tiff_get_flags( VipsForeignLoad *load )
55 {
56 	VipsForeignLoadTiff *tiff = (VipsForeignLoadTiff *) load;
57 	return( vips_foreign_load_tiff_get_flags_source( tiff-&gt;source ) );
58 }
59 static int
60 vips_foreign_load_tiff_header( VipsForeignLoad *load )
61 {
62 	VipsForeignLoadTiff *tiff = (VipsForeignLoadTiff *) load;
63 	if( vips__tiff_read_header_source( tiff-&gt;source, load-&gt;out, 
64 		tiff-&gt;page, tiff-&gt;n, tiff-&gt;autorotate, tiff-&gt;subifd ) ) 
65 		return( -1 );
66 	return( 0 );
67 }
68 static int
69 vips_foreign_load_tiff_load( VipsForeignLoad *load )
70 {
71 	VipsForeignLoadTiff *tiff = (VipsForeignLoadTiff *) load;
72 	if( vips__tiff_read_source( tiff-&gt;source, load-&gt;real, 
73 <a name="4"></a>		tiff-&gt;page, tiff-&gt;n,  tiff-&gt;autorotate, tiff-&gt;subifd ) ) 
74 		return( -1 );
75 <font color="#6cc417"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>	return( 0 );
76 }
77 static void
78 vips_foreign_load_tiff_class_init( VipsForeignLoadTiffClass *class )
79 {
80 	GObjectClass *gobject_class = G_OBJECT_CLASS( class );
81 	VipsObjectClass *object_class = (VipsObjectClass *) class;
82 	VipsForeignClass *foreign_class = (VipsForeignClass *) class;</b></font>
83 	VipsForeignLoadClass *load_class = (VipsForeignLoadClass *) class;
84 <a name="2"></a>	vips__tiff_init();
85 	gobject_class-&gt;dispose = vips_foreign_load_tiff_dispose;
86 <font color="#980517"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>	gobject_class-&gt;set_property = vips_object_set_property;
87 	gobject_class-&gt;get_property = vips_object_get_property;
88 	object_class-&gt;nickname = "tiffload_base";
89 	object_class-&gt;description = _( "load tiff" );
90 	foreign_class-&gt;priority = 50;
91 	load_class-&gt;get_flags_filename = 
92 		vips_foreign_load_tiff_get_flags_filename;
93 	load_class-&gt;get_flags = vips_foreign_load_tiff_get_flags;
94 	load_class-&gt;header = vips_foreign_load_tiff_header;
95 	load_class-&gt;load = vips_foreign_load_tiff_load;
96 	VIPS_ARG_INT( class, "page", 20, 
97 		_( "Page" ), 
98 		_( "Load this page from the image" ),
99 		VIPS_ARGUMENT_OPTIONAL_INPUT,
100 		G_STRUCT_OFFSET( VipsForeignLoadTiff, page ),
101 		0, 100000, 0 );
102 	VIPS_ARG_INT( class, "n", 21,
103 		_( "n" ),
104 		_( "Load this many pages" ),
105 		VIPS_ARGUMENT_OPTIONAL_INPUT,
106 		G_STRUCT_OFFSET( VipsForeignLoadTiff, n ),
107 		-1, 100000, 1 );
108 	VIPS_ARG_BOOL( class, "autorotate", 22, 
109 		_( "Autorotate" ), 
110 		_( "Rotate image using orientation tag" ),
111 		VIPS_ARGUMENT_OPTIONAL_INPUT,
112 		G_STRUCT_OFFSET( VipsForeignLoadTiff, autorotate ),
113 		FALSE );
114 	VIPS_ARG_INT( class, "subifd", 21,
115 		_( "subifd" ),
116 		_( "Select subifd index" ),
117 		VIPS_ARGUMENT_OPTIONAL_INPUT,
118 		G_STRUCT_OFFSET( VipsForeignLoadTiff, subifd ),
119 		-1, 100000, -1 );
120 }
121 static void
122 vips_foreign_load_tiff_init( VipsForeignLoadTiff *tiff )
123 {
124 <a name="0"></a>	tiff-&gt;page = 0; 
125 	tiff-&gt;n = 1; 
126 	tiff-&gt;subifd = -1; </b></font>
127 <font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>}
128 typedef struct _VipsForeignLoadTiffSource {
129 	VipsForeignLoadTiff parent_object;
130 	VipsSource *source;
131 } VipsForeignLoadTiffSource;
132 typedef VipsForeignLoadTiffClass VipsForeignLoadTiffSourceClass;
133 G_DEFINE_TYPE( VipsForeignLoadTiffSource, vips_foreign_load_tiff_source, 
134 	vips_foreign_load_tiff_get_type() );
135 static int
136 vips_foreign_load_tiff_source_build( VipsObject *object )
137 {
138 	VipsForeignLoadTiff *tiff = (VipsForeignLoadTiff *) object;
139 	VipsForeignLoadTiffSource *source = 
140 		(VipsForeignLoadTiffSource *) object;
141 	if( source-&gt;source ) {
142 		tiff-&gt;source = source-&gt;source;
143 		g_object_ref( tiff-&gt;source );
144 	}
145 	if( VIPS_OBJECT_CLASS( vips_foreign_load_tiff_source_parent_class )-&gt;
146 		build( object ) )
147 		return( -1 );
148 	return( 0 );
149 }
150 static gboolean
151 vips_foreign_load_tiff_source_is_a_source( VipsSource *source )
152 {
153 	return( vips__istiff_source( source ) );
154 }
155 static void
156 vips_foreign_load_tiff_source_class_init( 
157 	VipsForeignLoadTiffSourceClass *class )
158 {
159 	GObjectClass *gobject_class = G_OBJECT_CLASS( class );
160 	VipsObjectClass *object_class = (VipsObjectClass *) class;
161 	VipsForeignLoadClass *load_class = (VipsForeignLoadClass *) class;
162 	gobject_class-&gt;set_property = vips_object_set_property;
163 	gobject_class-&gt;get_property = vips_object_get_property;
164 	object_class-&gt;nickname = "tiffload_source";
165 	object_class-&gt;description = _( "load tiff from source" );
166 	object_class-&gt;build = vips_foreign_load_tiff_source_build;</b></font>
167 	load_class-&gt;is_a_source = vips_foreign_load_tiff_source_is_a_source;
168 	VIPS_ARG_OBJECT( class, "source", 1,
169 		_( "Source" ),
170 		_( "Source to load from" ),
171 		VIPS_ARGUMENT_REQUIRED_INPUT, 
172 		G_STRUCT_OFFSET( VipsForeignLoadTiffSource, source ),
173 		VIPS_TYPE_SOURCE );
174 }
175 static void
176 vips_foreign_load_tiff_source_init( VipsForeignLoadTiffSource *source )
177 {
178 }
179 typedef struct _VipsForeignLoadTiffFile {
180 	VipsForeignLoadTiff parent_object;
181 	char *filename; 
182 } VipsForeignLoadTiffFile;
183 typedef VipsForeignLoadTiffClass VipsForeignLoadTiffFileClass;
184 G_DEFINE_TYPE( VipsForeignLoadTiffFile, vips_foreign_load_tiff_file, 
185 	vips_foreign_load_tiff_get_type() );
186 static int
187 vips_foreign_load_tiff_file_build( VipsObject *object )
188 {
189 	VipsForeignLoadTiff *tiff = (VipsForeignLoadTiff *) object;
190 	VipsForeignLoadTiffFile *file = (VipsForeignLoadTiffFile *) object;
191 	if( file-&gt;filename &amp;&amp;
192 		!(tiff-&gt;source = 
193 			vips_source_new_from_file( file-&gt;filename )) )
194 		return( -1 );
195 	if( VIPS_OBJECT_CLASS( vips_foreign_load_tiff_file_parent_class )-&gt;
196 		build( object ) )
197 		return( -1 );
198 	return( 0 );
199 }
200 static gboolean
201 vips_foreign_load_tiff_file_is_a( const char *filename )
202 {
203 	VipsSource *source;
204 	gboolean result;
205 	if( !(source = vips_source_new_from_file( filename )) )
206 		return( FALSE );
207 	result = vips_foreign_load_tiff_source_is_a_source( source );
208 	VIPS_UNREF( source );
209 <a name="1"></a>	return( result );
210 }
211 <font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>const char *vips__foreign_tiff_suffs[] = { ".tif", ".tiff", NULL };
212 static void
213 vips_foreign_load_tiff_file_class_init( VipsForeignLoadTiffFileClass *class )
214 {
215 	GObjectClass *gobject_class = G_OBJECT_CLASS( class );
216 	VipsObjectClass *object_class = (VipsObjectClass *) class;
217 	VipsForeignClass *foreign_class = (VipsForeignClass *) class;
218 	VipsForeignLoadClass *load_class = (VipsForeignLoadClass *) class;
219 	gobject_class-&gt;set_property = vips_object_set_property;
220 	gobject_class-&gt;get_property = vips_object_get_property;
221 	object_class-&gt;nickname = "tiffload";
222 	object_class-&gt;description = _( "load tiff from file" );
223 	object_class-&gt;build = vips_foreign_load_tiff_file_build;
224 	foreign_class-&gt;suffs = vips__foreign_tiff_suffs;</b></font>
225 	load_class-&gt;is_a = vips_foreign_load_tiff_file_is_a;
226 	VIPS_ARG_STRING( class, "filename", 1, 
227 		_( "Filename" ),
228 		_( "Filename to load from" ),
229 		VIPS_ARGUMENT_REQUIRED_INPUT, 
230 		G_STRUCT_OFFSET( VipsForeignLoadTiffFile, filename ),
231 		NULL );
232 }
233 static void
234 vips_foreign_load_tiff_file_init( VipsForeignLoadTiffFile *file )
235 {
236 }
237 typedef struct _VipsForeignLoadTiffBuffer {
238 	VipsForeignLoadTiff parent_object;
239 	VipsBlob *blob;
240 } VipsForeignLoadTiffBuffer;
241 typedef VipsForeignLoadTiffClass VipsForeignLoadTiffBufferClass;
242 G_DEFINE_TYPE( VipsForeignLoadTiffBuffer, vips_foreign_load_tiff_buffer, 
243 	vips_foreign_load_tiff_get_type() );
244 static int
245 vips_foreign_load_tiff_buffer_build( VipsObject *object )
246 {
247 	VipsForeignLoadTiff *tiff = (VipsForeignLoadTiff *) object;
248 	VipsForeignLoadTiffBuffer *buffer = 
249 		(VipsForeignLoadTiffBuffer *) object;
250 	if( buffer-&gt;blob &amp;&amp;
251 		!(tiff-&gt;source = vips_source_new_from_memory( 
252 			VIPS_AREA( buffer-&gt;blob )-&gt;data, 
253 			VIPS_AREA( buffer-&gt;blob )-&gt;length )) )
254 		return( -1 );
255 	if( VIPS_OBJECT_CLASS( vips_foreign_load_tiff_buffer_parent_class )-&gt;
256 		build( object ) )
257 		return( -1 );
258 	return( 0 );
259 }
260 static gboolean
261 vips_foreign_load_tiff_buffer_is_a_buffer( const void *buf, size_t len )
262 {
263 	VipsSource *source;
264 	gboolean result;
265 	if( !(source = vips_source_new_from_memory( buf, len )) )
266 		return( FALSE );
267 	result = vips_foreign_load_tiff_source_is_a_source( source );
268 	VIPS_UNREF( source );
269 	return( result );
270 }
271 static void
272 vips_foreign_load_tiff_buffer_class_init( 
273 	VipsForeignLoadTiffBufferClass *class )
274 {
275 	GObjectClass *gobject_class = G_OBJECT_CLASS( class );
276 	VipsObjectClass *object_class = (VipsObjectClass *) class;
277 	VipsForeignLoadClass *load_class = (VipsForeignLoadClass *) class;
278 	gobject_class-&gt;set_property = vips_object_set_property;
279 	gobject_class-&gt;get_property = vips_object_get_property;
280 	object_class-&gt;nickname = "tiffload_buffer";
281 	object_class-&gt;description = _( "load tiff from buffer" );
282 	object_class-&gt;build = vips_foreign_load_tiff_buffer_build;
283 <a name="3"></a>
284 	load_class-&gt;is_a_buffer = vips_foreign_load_tiff_buffer_is_a_buffer;
285 <font color="#53858b"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>	VIPS_ARG_BOXED( class, "buffer", 1, 
286 		_( "Buffer" ),
287 		_( "Buffer to load from" ),
288 		VIPS_ARGUMENT_REQUIRED_INPUT, 
289 		G_STRUCT_OFFSET( VipsForeignLoadTiffBuffer, blob ),
290 		VIPS_TYPE_BLOB );
291 }
292 static void
293 vips_foreign_load_tiff_buffer_init( VipsForeignLoadTiffBuffer *buffer )
294 {
295 }
296 int
297 vips_tiffload( const char *filename, VipsImage **out, ... )
298 {
299 	va_list ap;
300 	int result;
301 	va_start( ap, out );
302 	result = vips_call_split( "tiffload", ap, filename, out );
303 	va_end( ap );
304 	return( result );
305 }
306 int</b></font>
307 vips_tiffload_buffer( void *buf, size_t len, VipsImage **out, ... )
308 {
309 	va_list ap;
310 	VipsBlob *blob;
311 	int result;
312 	blob = vips_blob_new( NULL, buf, len );
313 	va_start( ap, out );
314 	result = vips_call_split( "tiffload_buffer", ap, blob, out );
315 	va_end( ap );
316 	vips_area_unref( VIPS_AREA( blob ) );
317 	return( result );
318 }
319 int
320 vips_tiffload_source( VipsSource *source, VipsImage **out, ... )
321 {
322 	va_list ap;
323 	int result;
324 	va_start( ap, out );
325 	result = vips_call_split( "tiffload_source", ap, source, out );
326 	va_end( ap );
327 	return( result );
328 }
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>csvload.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 #ifdef HAVE_CONFIG_H
2 #include &lt;config.h&gt;
3 #include &lt;vips/intl.h&gt;
4 #include &lt;stdio.h&gt;
5 #include &lt;stdlib.h&gt;
6 #include &lt;string.h&gt;
7 #include &lt;errno.h&gt;
8 #include &lt;vips/vips.h&gt;
9 #include &lt;vips/buf.h&gt;
10 #include &lt;vips/internal.h&gt;
11 #include "pforeign.h"
12 #define MAX_ITEM_SIZE (256)
13 typedef struct _VipsForeignLoadCsv {
14 	VipsForeignLoad parent_object;
15 	VipsSource *source;
16 	VipsSbuf *sbuf;
17 	int skip;
18 	int lines;
19 	const char *whitespace;
20 	const char *separator;
21 	int lineno;
22 	int colno;
23 	char whitemap[256];
24 	char sepmap[256];
25 	char item[MAX_ITEM_SIZE];
26 	double *linebuf;
27 } VipsForeignLoadCsv;
28 typedef VipsForeignLoadClass VipsForeignLoadCsvClass;
29 G_DEFINE_ABSTRACT_TYPE( VipsForeignLoadCsv, vips_foreign_load_csv, 
30 	VIPS_TYPE_FOREIGN_LOAD );
31 static void
32 vips_foreign_load_csv_dispose( GObject *gobject )
33 {
34 	VipsForeignLoadCsv *csv = (VipsForeignLoadCsv *) gobject;
35 	VIPS_UNREF( csv-&gt;source );
36 	VIPS_UNREF( csv-&gt;sbuf );
37 	VIPS_FREE( csv-&gt;linebuf );
38 	G_OBJECT_CLASS( vips_foreign_load_csv_parent_class )-&gt;
39 		dispose( gobject );
40 }
41 static int
42 vips_foreign_load_csv_build( VipsObject *object )
43 {
44 	VipsForeignLoadCsv *csv = (VipsForeignLoadCsv *) object;
45 	int i;
46 	const char *p;
47 	if( !(csv-&gt;sbuf = vips_sbuf_new_from_source( csv-&gt;source )) )
48 		return( -1 );
49 	for( i = 0; i &lt; 256; i++ ) {
50 		csv-&gt;whitemap[i] = 0;
51 		csv-&gt;sepmap[i] = 0;
52 	}
53 	for( p = csv-&gt;whitespace; *p; p++ )
54 		csv-&gt;whitemap[(int) *p] = 1;
55 	for( p = csv-&gt;separator; *p; p++ )
56 		csv-&gt;sepmap[(int) *p] = 1;
57 	csv-&gt;sepmap[(int) '\n'] = 0;
58 	csv-&gt;whitemap[(int) '\n'] = 0;
59 	if( VIPS_OBJECT_CLASS( vips_foreign_load_csv_parent_class )-&gt;
60 		build( object ) )
61 		return( -1 );
62 	return( 0 );
63 }
64 static VipsForeignFlags
65 vips_foreign_load_csv_get_flags( VipsForeignLoad *load )
66 {
67 	return( 0 );
68 }
69 static int 
70 vips_foreign_load_csv_skip_white( VipsForeignLoadCsv *csv )
71 {
72         int ch;
73 	do {
74 		ch = VIPS_SBUF_GETC( csv-&gt;sbuf );
75 	} while( ch != EOF &amp;&amp; 
76 		ch != '\n' &amp;&amp; 
77 		csv-&gt;whitemap[ch] );
78 	VIPS_SBUF_UNGETC( csv-&gt;sbuf );
79 	return( ch );
80 }
81 static int 
82 vips_foreign_load_csv_skip_quoted( VipsForeignLoadCsv *csv )
83 {
84         int ch;
85 	do {
86 		ch = VIPS_SBUF_GETC( csv-&gt;sbuf );
87 		if( ch == '\\' ) 
88 			ch = VIPS_SBUF_GETC( csv-&gt;sbuf );
89 		else if( ch == '"' )
90 			break;
91 	} while( ch != EOF &amp;&amp; 
92 		ch != '\n' );
93 	if( ch == '\n' )
94 		VIPS_SBUF_UNGETC( csv-&gt;sbuf );
95 	return( ch );
96 }
97 static const char *
98 vips_foreign_load_csv_fetch_item( VipsForeignLoadCsv *csv )
99 {
100 	int write_point;
101 	int space_remaining;
102 	int ch;
103 	space_remaining = MAX_ITEM_SIZE - 1;
104 	write_point = 0;
105 	while( (ch = VIPS_SBUF_GETC( csv-&gt;sbuf )) != -1 &amp;&amp;
106 		ch != '\n' &amp;&amp;
107 		!csv-&gt;whitemap[ch] &amp;&amp;
108 		!csv-&gt;sepmap[ch] &amp;&amp;
109 		space_remaining &gt; 0 ) {
110 		csv-&gt;item[write_point] = ch;
111 		write_point += 1;
112 		space_remaining -= 1;
113 	}
114 	csv-&gt;item[write_point] = '\0';
115 	if( ch == -1 &amp;&amp; 
116 		write_point == 0 )
117 		return( NULL );
118 	while( ch != -1 &amp;&amp;
119 		ch != '\n' &amp;&amp;
120 		!csv-&gt;whitemap[ch] &amp;&amp;
121 		!csv-&gt;sepmap[ch] ) 
122 		ch = VIPS_SBUF_GETC( csv-&gt;sbuf );
123 	if( ch == '\n' ||
124 		csv-&gt;whitemap[ch] ||
125 		csv-&gt;sepmap[ch] ) 
126 		VIPS_SBUF_UNGETC( csv-&gt;sbuf );
127 	return( csv-&gt;item );
128 }
129 static int
130 vips_foreign_load_csv_read_double( VipsForeignLoadCsv *csv, double *out )
131 {
132 	int ch;
133 	*out = 0;
134 	ch = vips_foreign_load_csv_skip_white( csv );
135 	if( ch == EOF || 
136 		ch == '\n' ) 
137 		return( ch );
138 	if( ch == '"' ) {
139 		(void) VIPS_SBUF_GETC( csv-&gt;sbuf );
140 		ch = vips_foreign_load_csv_skip_quoted( csv );
141 	}
142 	else if( !csv-&gt;sepmap[ch] ) {
143 		const char *item;
144 		item = vips_foreign_load_csv_fetch_item( csv );
145 		if( !item )
146 			return( EOF );
147 		if( vips_strtod( item, out ) ) 
148 			g_warning( _( "bad number, line %d, column %d" ),
149 				csv-&gt;lineno, csv-&gt;colno );
150 	}
151 	ch = vips_foreign_load_csv_skip_white( csv );
152 	if( ch == EOF || 
153 		ch == '\n' ) 
154 		return( ch );
155 	if( csv-&gt;sepmap[ch] ) 
156 		(void) VIPS_SBUF_GETC( csv-&gt;sbuf ); 
157 	return( ch );
158 }
159 static int
160 vips_foreign_load_csv_header( VipsForeignLoad *load )
161 {
162 	VipsObjectClass *class = VIPS_OBJECT_GET_CLASS( load );
163 	VipsForeignLoadCsv *csv = (VipsForeignLoadCsv *) load;
164 	int i;
165 	double value;
166 	int ch;
167 	int width;
168 	int height;
169 	vips_sbuf_unbuffer( csv-&gt;sbuf );
170 	if( vips_source_rewind( csv-&gt;source ) )
171 		return( -1 );
172 	for( i = 0; i &lt; csv-&gt;skip; i++ )
173 		if( !vips_sbuf_get_line( csv-&gt;sbuf ) ) {
174 			vips_error( class-&gt;nickname,
175 				"%s", _( "unexpected end of file" ) );
176 			return( -1 );
177 		}
178 	csv-&gt;lineno = csv-&gt;skip + 1;
179 	csv-&gt;colno = 0;
180 	do {
181 		csv-&gt;colno += 1;
182 		ch = vips_foreign_load_csv_read_double( csv, &amp;value );
183 	} while( ch != '\n' &amp;&amp;
184 		ch != EOF );
185 	width = csv-&gt;colno;
186 	if( !(csv-&gt;linebuf = VIPS_ARRAY( NULL, width, double )) )
187 		return( -1 );
188 	if( csv-&gt;lines == -1 ) 
189 		for( height = 0; vips_sbuf_get_line( csv-&gt;sbuf ); height++ )
190 			;
191 	else 
192 		height = csv-&gt;lines;
193 	vips_image_init_fields( load-&gt;out,
194 		width, height, 1, 
195 		VIPS_FORMAT_DOUBLE, 
196 		VIPS_CODING_NONE, VIPS_INTERPRETATION_B_W, 1.0, 1.0 );
197 	if( vips_image_pipelinev( load-&gt;out, 
198 		VIPS_DEMAND_STYLE_THINSTRIP, NULL ) )
199 		return( -1 );
200 	VIPS_SETSTR( load-&gt;out-&gt;filename, 
201 		vips_connection_filename( VIPS_CONNECTION( csv-&gt;source ) ) );
202 	return( 0 );
203 }
204 static int
205 vips_foreign_load_csv_load( VipsForeignLoad *load )
206 {
207 	VipsObjectClass *class = VIPS_OBJECT_GET_CLASS( load );
208 	VipsForeignLoadCsv *csv = (VipsForeignLoadCsv *) load;
209 	int i;
210 	int x, y;
211 	int ch;
212 	vips_sbuf_unbuffer( csv-&gt;sbuf );
213 	if( vips_source_rewind( csv-&gt;source ) )
214 		return( -1 );
215 	for( i = 0; i &lt; csv-&gt;skip; i++ )
216 		if( !vips_sbuf_get_line( csv-&gt;sbuf ) ) {
217 			vips_error( class-&gt;nickname,
218 				"%s", _( "unexpected end of file" ) );
219 			return( -1 );
220 		}
221 	vips_image_init_fields( load-&gt;real,
222 		load-&gt;out-&gt;Xsize, load-&gt;out-&gt;Ysize, 1, 
223 		VIPS_FORMAT_DOUBLE, 
224 		VIPS_CODING_NONE, VIPS_INTERPRETATION_B_W, 1.0, 1.0 );
225 	if( vips_image_pipelinev( load-&gt;real, 
226 		VIPS_DEMAND_STYLE_THINSTRIP, NULL ) )
227 		return( -1 );
228 	csv-&gt;lineno = csv-&gt;skip + 1;
229 	for( y = 0; y &lt; load-&gt;real-&gt;Ysize; y++ ) {
230 		csv-&gt;colno = 0;
231 		ch = EOF;
232 		for( x = 0; x &lt; load-&gt;real-&gt;Xsize; x++ ) {
233 			double value;
234 			csv-&gt;colno += 1;
235 			ch = vips_foreign_load_csv_read_double( csv, &amp;value );
236 			if( ch == EOF ) {
237 				vips_error( class-&gt;nickname,
238 					"%s", _( "unexpected end of file" ) );
239 				return( -1 );
240 			}
241 			if( ch == '\n' &amp;&amp;
242 				x != load-&gt;real-&gt;Xsize - 1 ) {
243 				vips_error( class-&gt;nickname,
244 					_( "line %d has only %d columns" ),
245 					csv-&gt;lineno, csv-&gt;colno );
246 				if( load-&gt;fail )
247 					return( -1 );
248 			}
249 			csv-&gt;linebuf[x] = value;
250 		}
251 		if( ch == '\n' ) {
252 			(void) VIPS_SBUF_GETC( csv-&gt;sbuf ); 
253 			csv-&gt;lineno += 1;
254 		}
255 		if( vips_image_write_line( load-&gt;real, y, 
256 			(VipsPel *) csv-&gt;linebuf ) )
257 <a name="4"></a>			return( -1 );
258 	}
259 <font color="#6cc417"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>	return( 0 );
260 }
261 static void
262 vips_foreign_load_csv_class_init( VipsForeignLoadCsvClass *class )
263 {
264 	GObjectClass *gobject_class = G_OBJECT_CLASS( class );
265 <a name="2"></a>	VipsObjectClass *object_class = (VipsObjectClass *) class;
266 	VipsForeignLoadClass *load_class = (VipsForeignLoadClass *) class;</b></font>
267 <font color="#980517"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>	gobject_class-&gt;dispose = vips_foreign_load_csv_dispose;
268 	gobject_class-&gt;set_property = vips_object_set_property;
269 	gobject_class-&gt;get_property = vips_object_get_property;
270 	object_class-&gt;nickname = "csvload_base";
271 	object_class-&gt;description = _( "load csv" );
272 	object_class-&gt;build = vips_foreign_load_csv_build;
273 	load_class-&gt;get_flags = vips_foreign_load_csv_get_flags;
274 	load_class-&gt;header = vips_foreign_load_csv_header;
275 	load_class-&gt;load = vips_foreign_load_csv_load;
276 	VIPS_ARG_INT( class, "skip", 20, 
277 		_( "Skip" ), 
278 		_( "Skip this many lines at the start of the file" ),
279 		VIPS_ARGUMENT_OPTIONAL_INPUT,
280 		G_STRUCT_OFFSET( VipsForeignLoadCsv, skip ),
281 		0, 10000000, 0 );
282 	VIPS_ARG_INT( class, "lines", 21, 
283 		_( "Lines" ), 
284 		_( "Read this many lines from the file" ),
285 		VIPS_ARGUMENT_OPTIONAL_INPUT,
286 		G_STRUCT_OFFSET( VipsForeignLoadCsv, lines ),
287 		-1, 10000000, 0 );
288 	VIPS_ARG_STRING( class, "whitespace", 22, 
289 		_( "Whitespace" ), 
290 		_( "Set of whitespace characters" ),
291 		VIPS_ARGUMENT_OPTIONAL_INPUT,
292 		G_STRUCT_OFFSET( VipsForeignLoadCsv, whitespace ),
293 		" " ); 
294 	VIPS_ARG_STRING( class, "separator", 23, 
295 		_( "Separator" ), 
296 		_( "Set of separator characters" ),
297 		VIPS_ARGUMENT_OPTIONAL_INPUT,
298 		G_STRUCT_OFFSET( VipsForeignLoadCsv, separator ),
299 		";,\t" ); 
300 }
301 static void
302 vips_foreign_load_csv_init( VipsForeignLoadCsv *csv )
303 {
304 	csv-&gt;lines = -1;
305 	csv-&gt;whitespace = g_strdup( " " );
306 	csv-&gt;separator = g_strdup( ";,\t" );</b></font>
307 }
308 typedef struct _VipsForeignLoadCsvFile {
309 	VipsForeignLoadCsv parent_object;
310 	char *filename;
311 } VipsForeignLoadCsvFile;
312 typedef VipsForeignLoadCsvClass VipsForeignLoadCsvFileClass;
313 G_DEFINE_TYPE( VipsForeignLoadCsvFile, vips_foreign_load_csv_file,
314 	vips_foreign_load_csv_get_type() );
315 static VipsForeignFlags
316 vips_foreign_load_csv_file_get_flags_filename( const char *filename )
317 {
318 	return( 0 );
319 }
320 static int
321 vips_foreign_load_csv_file_build( VipsObject *object )
322 {
323 	VipsForeignLoadCsv *csv = (VipsForeignLoadCsv *) object;
324 	VipsForeignLoadCsvFile *file = (VipsForeignLoadCsvFile *) object;
325 	if( file-&gt;filename ) 
326 		if( !(csv-&gt;source = 
327 			vips_source_new_from_file( file-&gt;filename )) )
328 			return( -1 );
329 	if( VIPS_OBJECT_CLASS( vips_foreign_load_csv_file_parent_class )-&gt;
330 		build( object ) )
331 		return( -1 );
332 <a name="1"></a>	return( 0 );
333 }
334 <font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>static const char *vips_foreign_load_csv_suffs[] = {
335 	".csv",
336 	NULL
337 };
338 static void
339 vips_foreign_load_csv_file_class_init( VipsForeignLoadCsvFileClass *class )
340 {
341 	GObjectClass *gobject_class = G_OBJECT_CLASS( class );
342 	VipsObjectClass *object_class = (VipsObjectClass *) class;
343 	VipsForeignClass *foreign_class = (VipsForeignClass *) class;
344 	VipsForeignLoadClass *load_class = (VipsForeignLoadClass *) class;
345 	gobject_class-&gt;set_property = vips_object_set_property;
346 	gobject_class-&gt;get_property = vips_object_get_property;
347 	object_class-&gt;nickname = "csvload";
348 	object_class-&gt;build = vips_foreign_load_csv_file_build;
349 	foreign_class-&gt;suffs = vips_foreign_load_csv_suffs;
350 	load_class-&gt;get_flags_filename = </b></font>
351 		vips_foreign_load_csv_file_get_flags_filename;
352 	VIPS_ARG_STRING( class, "filename", 1,
353 		_( "Filename" ),
354 		_( "Filename to load from" ),
355 		VIPS_ARGUMENT_REQUIRED_INPUT,
356 		G_STRUCT_OFFSET( VipsForeignLoadCsvFile, filename ),
357 		NULL );
358 }
359 <a name="0"></a>static void
360 vips_foreign_load_csv_file_init( VipsForeignLoadCsvFile *file )
361 {
362 <font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>}
363 typedef struct _VipsForeignLoadCsvSource {
364 	VipsForeignLoadCsv parent_object;
365 	VipsSource *source;
366 } VipsForeignLoadCsvSource;
367 typedef VipsForeignLoadCsvClass VipsForeignLoadCsvSourceClass;
368 G_DEFINE_TYPE( VipsForeignLoadCsvSource, vips_foreign_load_csv_source,
369 	vips_foreign_load_csv_get_type() );
370 static int
371 vips_foreign_load_csv_source_build( VipsObject *object )
372 {
373 	VipsForeignLoadCsv *csv = (VipsForeignLoadCsv *) object;
374 	VipsForeignLoadCsvSource *source = (VipsForeignLoadCsvSource *) object;
375 	if( source-&gt;source ) {
376 		csv-&gt;source = source-&gt;source;
377 		g_object_ref( csv-&gt;source );
378 	}
379 	if( VIPS_OBJECT_CLASS( vips_foreign_load_csv_source_parent_class )-&gt;
380 		build( object ) )
381 		return( -1 );
382 	return( 0 );
383 }
384 static gboolean
385 vips_foreign_load_csv_source_is_a_source( VipsSource *source )
386 {
387 	return( FALSE );
388 }
389 static void
390 vips_foreign_load_csv_source_class_init( VipsForeignLoadCsvFileClass *class )
391 {
392 	GObjectClass *gobject_class = G_OBJECT_CLASS( class );
393 	VipsObjectClass *object_class = (VipsObjectClass *) class;
394 	VipsForeignLoadClass *load_class = (VipsForeignLoadClass *) class;
395 	gobject_class-&gt;set_property = vips_object_set_property;
396 	gobject_class-&gt;get_property = vips_object_get_property;
397 	object_class-&gt;nickname = "csvload_source";
398 	object_class-&gt;build = vips_foreign_load_csv_source_build;
399 <a name="3"></a>
400 	load_class-&gt;is_a_source = vips_foreign_load_csv_source_is_a_source;</b></font>
401 <font color="#53858b"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>	VIPS_ARG_OBJECT( class, "source", 1,
402 		_( "Source" ),
403 		_( "Source to load from" ),
404 		VIPS_ARGUMENT_REQUIRED_INPUT, 
405 		G_STRUCT_OFFSET( VipsForeignLoadCsvSource, source ),
406 		VIPS_TYPE_SOURCE );
407 }
408 static void
409 vips_foreign_load_csv_source_init( VipsForeignLoadCsvSource *source )
410 {
411 }
412 int
413 vips_csvload( const char *filename, VipsImage **out, ... )
414 {
415 	va_list ap;
416 	int result;
417 	va_start( ap, out );
418 	result = vips_call_split( "csvload", ap, filename, out ); 
419 	va_end( ap );
420 	return( result );
421 }
422 int</b></font>
423 vips_csvload_source( VipsSource *source, VipsImage **out, ... )
424 {
425 	va_list ap;
426 	int result;
427 	va_start( ap, out );
428 	result = vips_call_split( "csvload_source", ap, source, out ); 
429 	va_end( ap );
430 	return( result );
431 }
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
