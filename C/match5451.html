<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for nsgifload.c &amp; jp2ksave.c</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for nsgifload.c &amp; jp2ksave.c
      </h3>
<h1 align="center">
        17.3%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>nsgifload.c (24.186993%)<th>jp2ksave.c (13.584475%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(780-839)<td><a href="#" name="0">(1081-1138)</a><td align="center"><font color="#ff0000">37</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(700-750)<td><a href="#" name="1">(1017-1065)</a><td align="center"><font color="#b30000">26</font>
<tr onclick='openModal("#980517")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#980517"><font color="#980517">-</font><td><a href="#" name="2">(514-540)<td><a href="#" name="2">(901-928)</a><td align="center"><font color="#9e0000">23</font>
<tr onclick='openModal("#53858b")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#53858b"><font color="#53858b">-</font><td><a href="#" name="3">(862-939)<td><a href="#" name="3">(1398-1481)</a><td align="center"><font color="#7c0000">18</font>
<tr onclick='openModal("#6cc417")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#6cc417"><font color="#6cc417">-</font><td><a href="#" name="4">(631-656)<td><a href="#" name="4">(976-1001)</a><td align="center"><font color="#670000">15</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>nsgifload.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 #ifdef HAVE_CONFIG_H
2 #include &lt;config.h&gt;
3 #include &lt;vips/intl.h&gt;
4 #include &lt;stdio.h&gt;
5 #include &lt;stdlib.h&gt;
6 #include &lt;string.h&gt;
7 #include &lt;errno.h&gt;
8 #include &lt;ctype.h&gt;
9 #include &lt;vips/vips.h&gt;
10 #include &lt;vips/buf.h&gt;
11 #include &lt;vips/internal.h&gt;
12 #include &lt;vips/debug.h&gt;
13 #ifdef HAVE_NSGIF
14 #include &lt;libnsgif/libnsgif.h&gt;
15 #define VIPS_TYPE_FOREIGN_LOAD_GIF (vips_foreign_load_nsgif_get_type())
16 #define VIPS_FOREIGN_LOAD_GIF( obj ) \
17 	(G_TYPE_CHECK_INSTANCE_CAST( (obj), \
18 	VIPS_TYPE_FOREIGN_LOAD_GIF, VipsForeignLoadNsgif ))
19 #define VIPS_FOREIGN_LOAD_GIF_CLASS( klass ) \
20 	(G_TYPE_CHECK_CLASS_CAST( (klass), \
21 	VIPS_TYPE_FOREIGN_LOAD_GIF, VipsForeignLoadNsgifClass))
22 #define VIPS_IS_FOREIGN_LOAD_GIF( obj ) \
23 	(G_TYPE_CHECK_INSTANCE_TYPE( (obj), VIPS_TYPE_FOREIGN_LOAD_GIF ))
24 #define VIPS_IS_FOREIGN_LOAD_GIF_CLASS( klass ) \
25 	(G_TYPE_CHECK_CLASS_TYPE( (klass), VIPS_TYPE_FOREIGN_LOAD_GIF ))
26 #define VIPS_FOREIGN_LOAD_GIF_GET_CLASS( obj ) \
27 	(G_TYPE_INSTANCE_GET_CLASS( (obj), \
28 	VIPS_TYPE_FOREIGN_LOAD_GIF, VipsForeignLoadNsgifClass ))
29 typedef struct _VipsForeignLoadNsgif {
30 	VipsForeignLoad parent_object;
31 	int page;
32 	int n;
33 	VipsSource *source;
34 	gif_animation *anim;
35 	unsigned char *data;
36 	size_t size;
37 	int frame_count_displayable;
38 	int *delay;
39 	int gif_delay;
40 	gboolean has_transparency;
41 } VipsForeignLoadNsgif;
42 typedef VipsForeignLoadClass VipsForeignLoadNsgifClass;
43 G_DEFINE_ABSTRACT_TYPE( VipsForeignLoadNsgif, vips_foreign_load_nsgif, 
44 	VIPS_TYPE_FOREIGN_LOAD );
45 static const char *
46 vips_foreign_load_nsgif_errstr( gif_result result )
47 {
48 	switch( result ) {
49 		case GIF_WORKING:
50 		return( _( "Working" ) ); 
51 	case GIF_OK:
52 		return( _( "OK" ) ); 
53 	case GIF_INSUFFICIENT_FRAME_DATA:
54 		return( _( "Insufficient data to complete frame" ) ); 
55 	case GIF_FRAME_DATA_ERROR:
56 		return( _( "GIF frame data error" ) ); 
57 	case GIF_INSUFFICIENT_DATA:
58 		return( _( "Insufficient data to do anything" ) ); 
59 	case GIF_DATA_ERROR:
60 		return( _( "GIF header data error" ) ); 
61 	case GIF_INSUFFICIENT_MEMORY:
62 		return( _( "Insuficient memory to process" ) ); 
63 	case GIF_FRAME_NO_DISPLAY:
64 		return( _( "No display" ) ); 
65 	case GIF_END_OF_FRAME:
66 		return( _( "At end of frame" ) ); 
67 	default:
68 		return( _( "Unknown error" ) ); 
69 	}
70 }
71 static void
72 vips_foreign_load_nsgif_error( VipsForeignLoadNsgif *gif, gif_result result )
73 {
74 	VipsObjectClass *class = VIPS_OBJECT_GET_CLASS( gif );
75 	vips_error( class-&gt;nickname, "%s", 
76 		vips_foreign_load_nsgif_errstr( result ) );
77 }
78 static void
79 vips_foreign_load_nsgif_dispose( GObject *gobject )
80 {
81 	VipsForeignLoadNsgif *gif = (VipsForeignLoadNsgif *) gobject;
82 	VIPS_DEBUG_MSG( "vips_foreign_load_nsgif_dispose:\n" );
83 	if( gif-&gt;anim ) {
84 		gif_finalise( gif-&gt;anim );
85 		VIPS_FREE( gif-&gt;anim );
86 	}
87 	VIPS_UNREF( gif-&gt;source );
88 	VIPS_FREE( gif-&gt;delay );
89 	G_OBJECT_CLASS( vips_foreign_load_nsgif_parent_class )-&gt;
90 		dispose( gobject );
91 }
92 static VipsForeignFlags
93 vips_foreign_load_nsgif_get_flags_filename( const char *filename )
94 {
95 	return( VIPS_FOREIGN_SEQUENTIAL );
96 }
97 static VipsForeignFlags
98 vips_foreign_load_nsgif_get_flags( VipsForeignLoad *load )
99 {
100 	return( VIPS_FOREIGN_SEQUENTIAL );
101 }
102 static gboolean
103 vips_foreign_load_nsgif_is_a_source( VipsSource *source )
104 {
105 	const unsigned char *data;
106 	if( (data = vips_source_sniff( source, 4 )) &amp;&amp;
107 		data[0] == 'G' &amp;&amp;
108 		data[1] == 'I' &amp;&amp;
109 		data[2] == 'F' &amp;&amp;
110 		data[3] == '8' )
111 		return( TRUE );
112 	return( FALSE );
113 }
114 #ifdef VERBOSE
115 static void
116 print_frame( gif_frame *frame )
117 {
118 	printf( "frame:\n" );
119 	printf( "  display = %d\n", frame-&gt;display );
120 	printf( "  frame_delay = %d\n", frame-&gt;frame_delay );
121 	printf( "  virgin = %d\n", frame-&gt;virgin );
122 	printf( "  opaque = %d\n", frame-&gt;opaque );
123 	printf( "  redraw_required = %d\n", frame-&gt;redraw_required );
124 	printf( "  disposal_method = %d\n", frame-&gt;disposal_method );
125 	printf( "  transparency = %d\n", frame-&gt;transparency );
126 	printf( "  transparency_index = %d\n", frame-&gt;transparency_index );
127 	printf( "  redraw_x = %d\n", frame-&gt;redraw_x );
128 	printf( "  redraw_y = %d\n", frame-&gt;redraw_y );
129 	printf( "  redraw_width = %d\n", frame-&gt;redraw_width );
130 	printf( "  redraw_height = %d\n", frame-&gt;redraw_height );
131 }
132 static void
133 print_animation( gif_animation *anim )
134 {
135 	int i;
136 	printf( "animation:\n" );
137 	printf( "  width = %d\n", anim-&gt;width );
138 	printf( "  height = %d\n", anim-&gt;height );
139 	printf( "  frame_count = %d\n", anim-&gt;frame_count );
140 	printf( "  frame_count_partial = %d\n", anim-&gt;frame_count_partial );
141 	printf( "  decoded_frame = %d\n", anim-&gt;decoded_frame );
142 	printf( "  frame_image = %p\n", anim-&gt;frame_image );
143 	printf( "  loop_count = %d\n", anim-&gt;loop_count );
144 	printf( "  frame_holders = %d\n", anim-&gt;frame_holders );
145 	printf( "  background_index = %d\n", anim-&gt;background_index );
146 	printf( "  colour_table_size = %d\n", anim-&gt;colour_table_size );
147 	printf( "  global_colours = %d\n", anim-&gt;global_colours );
148 	printf( "  global_colour_table = %p\n", anim-&gt;global_colour_table );
149 	printf( "  local_colour_table = %p\n", anim-&gt;local_colour_table );
150 	for( i = 0; i &lt; anim-&gt;frame_holders; i++ ) {
151 		printf( "%d ", i );
152 		print_frame( &amp;anim-&gt;frames[i] );
153 	}
154 }
155 static int
156 vips_foreign_load_nsgif_set_header( VipsForeignLoadNsgif *gif, 
157 	VipsImage *image )
158 {
159 	VIPS_DEBUG_MSG( "vips_foreign_load_nsgif_set_header:\n" );
160 	vips_image_init_fields( image,
161 		gif-&gt;anim-&gt;width, gif-&gt;anim-&gt;height * gif-&gt;n, 
162 		gif-&gt;has_transparency ? 4 : 3,
163 		VIPS_FORMAT_UCHAR, VIPS_CODING_NONE,
164 		VIPS_INTERPRETATION_sRGB, 1.0, 1.0 );
165 	vips_image_pipelinev( image, VIPS_DEMAND_STYLE_FATSTRIP, NULL );
166 	if( vips_object_argument_isset( VIPS_OBJECT( gif ), "n" ) )
167 		vips_image_set_int( image,
168 			VIPS_META_PAGE_HEIGHT, gif-&gt;anim-&gt;height );
169 	vips_image_set_int( image, VIPS_META_N_PAGES, 
170 		gif-&gt;frame_count_displayable );
171 	vips_image_set_int( image, "loop", gif-&gt;anim-&gt;loop_count );
172 	vips_image_set_array_int( image, "delay", 
173 		gif-&gt;delay, gif-&gt;frame_count_displayable );
174 	if( gif-&gt;anim-&gt;global_colours &amp;&amp;
175 		gif-&gt;anim-&gt;global_colour_table &amp;&amp;
176 		gif-&gt;anim-&gt;background_index &gt;= 0 &amp;&amp;
177 		gif-&gt;anim-&gt;background_index &lt; gif-&gt;anim-&gt;colour_table_size ) {
178 		int index = gif-&gt;anim-&gt;background_index;
179 		unsigned char *entry = (unsigned char *) 
180 			&amp;gif-&gt;anim-&gt;global_colour_table[index];
181 		double array[3];
182 		array[0] = entry[0];
183 		array[1] = entry[1];
184 		array[2] = entry[2];
185 		vips_image_set_array_double( image, "background", array, 3 );
186 	}
187 	VIPS_SETSTR( image-&gt;filename, 
188 		vips_connection_filename( VIPS_CONNECTION( gif-&gt;source ) ) );
189 	vips_image_set_int( image,
190 		"gif-loop", gif-&gt;anim-&gt;loop_count == 0 ? 
191 			0 : gif-&gt;anim-&gt;loop_count - 1 );
192 	vips_image_set_int( image, "gif-delay", gif-&gt;gif_delay ); 
193 	return( 0 );
194 }
195 static int
196 vips_foreign_load_nsgif_header( VipsForeignLoad *load )
197 {
198 	VipsObjectClass *class = VIPS_OBJECT_GET_CLASS( load );
199 	VipsForeignLoadNsgif *gif = (VipsForeignLoadNsgif *) load;
200 	const void *data;
201 	size_t size;
202 	gif_result result;
203 	int i;
204 	VIPS_DEBUG_MSG( "vips_foreign_load_nsgif_header:\n" );
205 	if( !(data = vips_source_map( gif-&gt;source, &amp;size )) ) 
206 		return( -1 );
207 	vips_source_minimise( gif-&gt;source );
208 	result = gif_initialise( gif-&gt;anim, size, (void *) data );
209 	VIPS_DEBUG_MSG( "gif_initialise() = %d\n", result );
210 #ifdef VERBOSE
211 	print_animation( gif-&gt;anim );
212 	if( result != GIF_OK &amp;&amp; 
213 		result != GIF_WORKING &amp;&amp;
214 		result != GIF_INSUFFICIENT_FRAME_DATA ) {
215 		vips_foreign_load_nsgif_error( gif, result ); 
216 		return( -1 );
217 	}
218 	else if( result == GIF_INSUFFICIENT_FRAME_DATA &amp;&amp;
219 		load-&gt;fail ) {
220 		vips_error( class-&gt;nickname, "%s", _( "truncated GIF" ) );
221 		return( -1 );
222 	}
223 	for( i = gif-&gt;anim-&gt;frame_count - 1; 
224 		i &gt;= 0 &amp;&amp; !gif-&gt;anim-&gt;frames[i].display; i-- ) 
225 		;
226 	gif-&gt;frame_count_displayable = i + 1;
227 #ifdef VERBOSE
228 	if( gif-&gt;frame_count_displayable != gif-&gt;anim-&gt;frame_count )
229 		printf( "vips_foreign_load_nsgif_open: "
230 			"removed %d undisplayable frames\n", 
231 			gif-&gt;anim-&gt;frame_count - gif-&gt;frame_count_displayable );
232 	if( !gif-&gt;frame_count_displayable ) {
233 		vips_error( class-&gt;nickname, "%s", _( "no frames in GIF" ) );
234 		return( -1 );
235 	}
236 	for( i = 0; i &lt; gif-&gt;frame_count_displayable; i++ ) 
237 		if( gif-&gt;anim-&gt;frames[i].transparency ) {
238 			gif-&gt;has_transparency = TRUE;
239 			break;
240 		}
241 	if( gif-&gt;n == -1 )
242 		gif-&gt;n = gif-&gt;frame_count_displayable - gif-&gt;page;
243 	if( gif-&gt;page &lt; 0 ||
244 		gif-&gt;n &lt;= 0 ||
245 		gif-&gt;page + gif-&gt;n &gt; gif-&gt;frame_count_displayable ) {
246 		vips_error( class-&gt;nickname, "%s", _( "bad page number" ) );
247 		return( -1 );
248 	}
249 	VIPS_FREE( gif-&gt;delay );
250 	if( !(gif-&gt;delay = VIPS_ARRAY( NULL, 
251 		gif-&gt;frame_count_displayable, int )) )
252 		return( -1 );
253 	for( i = 0; i &lt; gif-&gt;frame_count_displayable; i++ )
254 		gif-&gt;delay[i] = 10 * gif-&gt;anim-&gt;frames[i].frame_delay;
255 	gif-&gt;gif_delay = gif-&gt;anim-&gt;frames[0].frame_delay;
256 	vips_foreign_load_nsgif_set_header( gif, load-&gt;out );
257 	return( 0 );
258 }
259 static int
260 vips_foreign_load_nsgif_generate( VipsRegion *or,
261 	void *seq, void *a, void *b, gboolean *stop )
262 {
263         VipsRect *r = &amp;or-&gt;valid;
264 	VipsForeignLoadNsgif *gif = (VipsForeignLoadNsgif *) a;
265 	int y;
266 #ifdef VERBOSE
267 	VIPS_DEBUG_MSG( "vips_foreign_load_nsgif_generate: "
268 		"top = %d, height = %d\n", r-&gt;top, r-&gt;height );
269 	for( y = 0; y &lt; r-&gt;height; y++ ) {
270 		int page = (r-&gt;top + y) / gif-&gt;anim-&gt;height + gif-&gt;page;
271 		int line = (r-&gt;top + y) % gif-&gt;anim-&gt;height;
272 		gif_result result;
273 		VipsPel *p, *q;
274 		g_assert( line &gt;= 0 &amp;&amp; line &lt; gif-&gt;anim-&gt;height );
275 		g_assert( page &gt;= 0 &amp;&amp; page &lt; gif-&gt;frame_count_displayable );
276 		if( gif-&gt;anim-&gt;decoded_frame != page ) {
277 			result = gif_decode_frame( gif-&gt;anim, page ); 
278 			VIPS_DEBUG_MSG( "  gif_decode_frame(%d) = %d\n", 
279 				page, result );
280 			if( result != GIF_OK ) {
281 				vips_foreign_load_nsgif_error( gif, result ); 
282 				return( -1 );
283 			}
284 #ifdef VERBOSE
285 			print_animation( gif-&gt;anim );
286 		}
287 		p = gif-&gt;anim-&gt;frame_image + 
288 			line * gif-&gt;anim-&gt;width * sizeof( int );
289 		q = VIPS_REGION_ADDR( or, 0, r-&gt;top + y );
290 		if( gif-&gt;has_transparency )
291 			memcpy( q, p, VIPS_REGION_SIZEOF_LINE( or ) );
292 		else {
293 			int i;
294 			for( i = 0; i &lt; r-&gt;width; i++ ) {
295 				q[0] = p[0];
296 				q[1] = p[1];
297 				q[2] = p[2];
298 				q += 3;
299 				p += 4;
300 			}
301 		}
302 	}
303 	return( 0 );
304 }
305 static int
306 vips_foreign_load_nsgif_load( VipsForeignLoad *load )
307 {
308 	VipsForeignLoadNsgif *gif = (VipsForeignLoadNsgif *) load;
309 	VipsImage **t = (VipsImage **)
310 		vips_object_local_array( VIPS_OBJECT( load ), 4 );
311 	VIPS_DEBUG_MSG( "vips_foreign_load_nsgif_load:\n" );
312 	t[0] = vips_image_new();
313 	if( vips_foreign_load_nsgif_set_header( gif, t[0] ) )
314 		return( -1 );
315 	if( vips_image_generate( t[0],
316 		NULL, vips_foreign_load_nsgif_generate, NULL, gif, NULL ) ||
317 		vips_sequential( t[0], &amp;t[1],
318 <a name="2"></a>			"tile_height", VIPS__FATSTRIP_HEIGHT,
319 			NULL ) ||
320 		vips_image_write( t[1], load-&gt;real ) )
321 <font color="#980517"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>		return( -1 );
322 	return( 0 );
323 }
324 static void
325 vips_foreign_load_nsgif_class_init( VipsForeignLoadNsgifClass *class )
326 {
327 	GObjectClass *gobject_class = G_OBJECT_CLASS( class );
328 	VipsObjectClass *object_class = (VipsObjectClass *) class;
329 	VipsForeignClass *foreign_class = (VipsForeignClass *) class;
330 	VipsForeignLoadClass *load_class = (VipsForeignLoadClass *) class;
331 	gobject_class-&gt;dispose = vips_foreign_load_nsgif_dispose;
332 	gobject_class-&gt;set_property = vips_object_set_property;
333 	gobject_class-&gt;get_property = vips_object_get_property;
334 	object_class-&gt;nickname = "gifload_base";
335 	object_class-&gt;description = _( "load GIF with libnsgif" );
336 	foreign_class-&gt;priority = 50;
337 	load_class-&gt;get_flags_filename = 
338 		vips_foreign_load_nsgif_get_flags_filename;
339 	load_class-&gt;get_flags = vips_foreign_load_nsgif_get_flags;</b></font>
340 	load_class-&gt;header = vips_foreign_load_nsgif_header;
341 	load_class-&gt;load = vips_foreign_load_nsgif_load;
342 	VIPS_ARG_INT( class, "page", 10,
343 		_( "Page" ),
344 		_( "Load this page from the file" ),
345 		VIPS_ARGUMENT_OPTIONAL_INPUT,
346 		G_STRUCT_OFFSET( VipsForeignLoadNsgif, page ),
347 		0, 100000, 0 );
348 	VIPS_ARG_INT( class, "n", 6,
349 		_( "n" ),
350 		_( "Load this many pages" ),
351 		VIPS_ARGUMENT_OPTIONAL_INPUT,
352 		G_STRUCT_OFFSET( VipsForeignLoadNsgif, n ),
353 		-1, 100000, 1 );
354 }
355 static void *
356 vips_foreign_load_nsgif_bitmap_create( int width, int height )
357 {
358 	if( width &lt;= 0 ||
359 		width &gt; 16383 ||
360 		height &lt;= 0 ||
361 		height &gt; 16383 ) {
362 		vips_error( "gifload",
363 			"%s", _( "bad image dimensions") );
364 		return( NULL );
365 	}
366 	return g_malloc0( (gsize) width * height * 4 );
367 }
368 static void 
369 vips_foreign_load_nsgif_bitmap_set_opaque( void *bitmap, bool opaque )
370 {
371         (void) opaque;          (void) bitmap;          g_assert( bitmap );
372 }
373 static bool 
374 vips_foreign_load_nsgif_bitmap_test_opaque( void *bitmap )
375 {
376         (void) bitmap;          g_assert( bitmap );
377         return( false );
378 }
379 static unsigned char *
380 vips_foreign_load_nsgif_bitmap_get_buffer( void *bitmap )
381 {
382         g_assert( bitmap );
383         return( bitmap );
384 }
385 static void 
386 vips_foreign_load_nsgif_bitmap_destroy( void *bitmap )
387 {
388         g_assert( bitmap );
389         g_free( bitmap );
390 }
391 static void 
392 vips_foreign_load_nsgif_bitmap_modified( void *bitmap )
393 {
394         (void) bitmap;          g_assert( bitmap );
395         return;
396 }
397 static gif_bitmap_callback_vt vips_foreign_load_nsgif_bitmap_callbacks = {
398 	vips_foreign_load_nsgif_bitmap_create,
399 	vips_foreign_load_nsgif_bitmap_destroy,
400 	vips_foreign_load_nsgif_bitmap_get_buffer,
401 	vips_foreign_load_nsgif_bitmap_set_opaque,
402 	vips_foreign_load_nsgif_bitmap_test_opaque,
403 	vips_foreign_load_nsgif_bitmap_modified
404 };
405 <a name="4"></a>static void
406 vips_foreign_load_nsgif_init( VipsForeignLoadNsgif *gif )
407 {
408 <font color="#6cc417"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>	gif-&gt;anim = g_new0( gif_animation, 1 );
409 	gif_create( gif-&gt;anim, &amp;vips_foreign_load_nsgif_bitmap_callbacks );
410 	gif-&gt;n = 1;
411 }
412 typedef struct _VipsForeignLoadNsgifFile {
413 	VipsForeignLoadNsgif parent_object;
414 	char *filename; 
415 } VipsForeignLoadNsgifFile;
416 typedef VipsForeignLoadNsgifClass VipsForeignLoadNsgifFileClass;
417 G_DEFINE_TYPE( VipsForeignLoadNsgifFile, vips_foreign_load_nsgif_file, 
418 	vips_foreign_load_nsgif_get_type() );
419 static int
420 vips_foreign_load_gif_file_build( VipsObject *object )
421 {
422 	VipsForeignLoadNsgif *gif = (VipsForeignLoadNsgif *) object;
423 	VipsForeignLoadNsgifFile *file = (VipsForeignLoadNsgifFile *) object;
424 	if( file-&gt;filename )</b></font>
425 		if( !(gif-&gt;source =
426 			vips_source_new_from_file( file-&gt;filename )) )
427 			return( -1 );
428 	if( VIPS_OBJECT_CLASS( vips_foreign_load_nsgif_file_parent_class )-&gt;
429 		build( object ) )
430 		return( -1 );
431 	return( 0 );
432 }
433 static const char *vips_foreign_nsgif_suffs[] = {
434 	".gif",
435 	NULL
436 };
437 static gboolean
438 vips_foreign_load_nsgif_file_is_a( const char *filename )
439 {
440 	VipsSource *source;
441 	gboolean result;
442 	if( !(source = vips_source_new_from_file( filename )) )
443 		return( FALSE );
444 	result = vips_foreign_load_nsgif_is_a_source( source );
445 	VIPS_UNREF( source );
446 	return( result );
447 }
448 static void
449 vips_foreign_load_nsgif_file_class_init( 
450 	VipsForeignLoadNsgifFileClass *class )
451 {
452 	GObjectClass *gobject_class = G_OBJECT_CLASS( class );
453 	VipsObjectClass *object_class = (VipsObjectClass *) class;
454 	VipsForeignClass *foreign_class = (VipsForeignClass *) class;
455 	VipsForeignLoadClass *load_class = (VipsForeignLoadClass *) class;
456 	gobject_class-&gt;set_property = vips_object_set_property;
457 <a name="1"></a>	gobject_class-&gt;get_property = vips_object_get_property;
458 	object_class-&gt;nickname = "gifload";
459 <font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>	object_class-&gt;description = _( "load GIF with libnsgif" );
460 	object_class-&gt;build = vips_foreign_load_gif_file_build;
461 	foreign_class-&gt;suffs = vips_foreign_nsgif_suffs;
462 	load_class-&gt;is_a = vips_foreign_load_nsgif_file_is_a;
463 	VIPS_ARG_STRING( class, "filename", 1, 
464 		_( "Filename" ),
465 		_( "Filename to load from" ),
466 		VIPS_ARGUMENT_REQUIRED_INPUT, 
467 		G_STRUCT_OFFSET( VipsForeignLoadNsgifFile, filename ),
468 		NULL );
469 }
470 static void
471 vips_foreign_load_nsgif_file_init( VipsForeignLoadNsgifFile *file )
472 {
473 }
474 typedef struct _VipsForeignLoadNsgifBuffer {
475 	VipsForeignLoadNsgif parent_object;
476 	VipsArea *blob;
477 } VipsForeignLoadNsgifBuffer;
478 typedef VipsForeignLoadNsgifClass VipsForeignLoadNsgifBufferClass;
479 G_DEFINE_TYPE( VipsForeignLoadNsgifBuffer, vips_foreign_load_nsgif_buffer, 
480 	vips_foreign_load_nsgif_get_type() );
481 static int
482 vips_foreign_load_nsgif_buffer_build( VipsObject *object )
483 {
484 	VipsForeignLoadNsgif *gif = (VipsForeignLoadNsgif *) object;
485 	VipsForeignLoadNsgifBuffer *buffer = 
486 		(VipsForeignLoadNsgifBuffer *) object;
487 	if( buffer-&gt;blob &amp;&amp;
488 		!(gif-&gt;source = vips_source_new_from_memory( 
489 			buffer-&gt;blob-&gt;data, 
490 			buffer-&gt;blob-&gt;length )) )
491 		return( -1 );
492 	if( VIPS_OBJECT_CLASS( vips_foreign_load_nsgif_buffer_parent_class )-&gt;
493 		build( object ) )
494 		return( -1 );</b></font>
495 	return( 0 );
496 }
497 static gboolean
498 vips_foreign_load_nsgif_buffer_is_a_buffer( const void *buf, size_t len )
499 {
500 	VipsSource *source;
501 	gboolean result;
502 	if( !(source = vips_source_new_from_memory( buf, len )) )
503 		return( FALSE );
504 	result = vips_foreign_load_nsgif_is_a_source( source );
505 	VIPS_UNREF( source );
506 	return( result );
507 }
508 static void
509 vips_foreign_load_nsgif_buffer_class_init( 
510 	VipsForeignLoadNsgifBufferClass *class )
511 {
512 	GObjectClass *gobject_class = G_OBJECT_CLASS( class );
513 	VipsObjectClass *object_class = (VipsObjectClass *) class;
514 	VipsForeignLoadClass *load_class = (VipsForeignLoadClass *) class;
515 <a name="0"></a>	gobject_class-&gt;set_property = vips_object_set_property;
516 	gobject_class-&gt;get_property = vips_object_get_property;
517 <font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>	object_class-&gt;nickname = "gifload_buffer";
518 	object_class-&gt;description = _( "load GIF with libnsgif" );
519 	object_class-&gt;build = vips_foreign_load_nsgif_buffer_build;
520 	load_class-&gt;is_a_buffer = vips_foreign_load_nsgif_buffer_is_a_buffer;
521 	VIPS_ARG_BOXED( class, "buffer", 1, 
522 		_( "Buffer" ),
523 		_( "Buffer to load from" ),
524 		VIPS_ARGUMENT_REQUIRED_INPUT, 
525 		G_STRUCT_OFFSET( VipsForeignLoadNsgifBuffer, blob ),
526 		VIPS_TYPE_BLOB );
527 }
528 static void
529 vips_foreign_load_nsgif_buffer_init( VipsForeignLoadNsgifBuffer *buffer )
530 {
531 }
532 typedef struct _VipsForeignLoadNsgifSource {
533 	VipsForeignLoadNsgif parent_object;
534 	VipsSource *source;
535 } VipsForeignLoadNsgifSource;
536 typedef VipsForeignLoadClass VipsForeignLoadNsgifSourceClass;
537 G_DEFINE_TYPE( VipsForeignLoadNsgifSource, vips_foreign_load_nsgif_source, 
538 	vips_foreign_load_nsgif_get_type() );
539 static int
540 vips_foreign_load_nsgif_source_build( VipsObject *object )
541 {
542 	VipsForeignLoadNsgif *gif = (VipsForeignLoadNsgif *) object;
543 	VipsForeignLoadNsgifSource *source = 
544 		(VipsForeignLoadNsgifSource *) object;
545 	if( source-&gt;source ) {
546 		gif-&gt;source = source-&gt;source;
547 		g_object_ref( gif-&gt;source );
548 	}
549 	if( VIPS_OBJECT_CLASS( vips_foreign_load_nsgif_source_parent_class )-&gt;
550 		build( object ) )
551 		return( -1 );
552 	return( 0 );
553 }
554 static void
555 vips_foreign_load_nsgif_source_class_init( 
556 	VipsForeignLoadNsgifSourceClass *class )
557 {
558 	GObjectClass *gobject_class = G_OBJECT_CLASS( class );
559 	VipsObjectClass *object_class = (VipsObjectClass *) class;
560 	VipsForeignLoadClass *load_class = (VipsForeignLoadClass *) class;</b></font>
561 	gobject_class-&gt;set_property = vips_object_set_property;
562 	gobject_class-&gt;get_property = vips_object_get_property;
563 	object_class-&gt;nickname = "gifload_source";
564 	object_class-&gt;description = _( "load gif from source" );
565 	object_class-&gt;build = vips_foreign_load_nsgif_source_build;
566 	load_class-&gt;is_a_source = vips_foreign_load_nsgif_is_a_source;
567 	VIPS_ARG_OBJECT( class, "source", 1,
568 		_( "Source" ),
569 		_( "Source to load from" ),
570 		VIPS_ARGUMENT_REQUIRED_INPUT, 
571 		G_STRUCT_OFFSET( VipsForeignLoadNsgifSource, source ),
572 		VIPS_TYPE_SOURCE );
573 }
574 <a name="3"></a>static void
575 vips_foreign_load_nsgif_source_init( VipsForeignLoadNsgifSource *source )
576 {
577 <font color="#53858b"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>}
578 int
579 vips_gifload( const char *filename, VipsImage **out, ... )
580 {
581 	va_list ap;
582 	int result;
583 	va_start( ap, out );
584 	result = vips_call_split( "gifload", ap, filename, out );
585 	va_end( ap );
586 	return( result );
587 }
588 int
589 vips_gifload_buffer( void *buf, size_t len, VipsImage **out, ... )
590 {
591 	va_list ap;
592 	VipsBlob *blob;
593 	int result;
594 	blob = vips_blob_new( NULL, buf, len );
595 	va_start( ap, out );
596 	result = vips_call_split( "gifload_buffer", ap, blob, out );</b></font>
597 	va_end( ap );
598 	vips_area_unref( VIPS_AREA( blob ) );
599 	return( result );
600 }
601 int
602 vips_gifload_source( VipsSource *source, VipsImage **out, ... )
603 {
604 	va_list ap;
605 	int result;
606 	va_start( ap, out );
607 	result = vips_call_split( "gifload_source", ap, source, out );
608 	va_end( ap );
609 	return( result );
610 }
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>jp2ksave.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 #ifdef HAVE_CONFIG_H
2 #include &lt;config.h&gt;
3 #include &lt;vips/intl.h&gt;
4 #include &lt;stdio.h&gt;
5 #include &lt;stdlib.h&gt;
6 #include &lt;string.h&gt;
7 #include &lt;vips/vips.h&gt;
8 #include &lt;vips/internal.h&gt;
9 #ifdef HAVE_LIBOPENJP2
10 #include &lt;openjpeg.h&gt;
11 #include "pforeign.h"
12 #define MAX_BANDS (100)
13 typedef struct _VipsForeignSaveJp2k {
14 	VipsForeignSave parent_object;
15 	VipsTarget *target;
16 	int tile_width;
17 	int tile_height;
18 	gboolean lossless;
19 	int Q;
20 	VipsForeignSubsample subsample_mode;
21 	opj_stream_t *stream;
22 	opj_codec_t *codec;
23 	opj_cparameters_t parameters;
24 	opj_image_t *image;
25 	VipsRegion *strip;
26 	VipsPel *tile_buffer;
27 	gboolean subsample;
28 	gboolean save_as_ycc;
29 	VipsPel *accumulate;
30 } VipsForeignSaveJp2k;
31 typedef VipsForeignSaveClass VipsForeignSaveJp2kClass;
32 G_DEFINE_ABSTRACT_TYPE( VipsForeignSaveJp2k, vips_foreign_save_jp2k, 
33 	VIPS_TYPE_FOREIGN_SAVE );
34 static void
35 vips_foreign_save_jp2k_dispose( GObject *gobject )
36 {
37 	VipsForeignSaveJp2k *jp2k = (VipsForeignSaveJp2k *) gobject;
38 	VIPS_FREEF( opj_destroy_codec, jp2k-&gt;codec );
39 	VIPS_FREEF( opj_stream_destroy, jp2k-&gt;stream );
40 	VIPS_FREEF( opj_image_destroy, jp2k-&gt;image );
41 	VIPS_UNREF( jp2k-&gt;target );
42 	VIPS_UNREF( jp2k-&gt;strip );
43 	VIPS_FREE( jp2k-&gt;tile_buffer );
44 	VIPS_FREE( jp2k-&gt;accumulate );
45 	G_OBJECT_CLASS( vips_foreign_save_jp2k_parent_class )-&gt;
46 		dispose( gobject );
47 }
48 static OPJ_SIZE_T
49 vips_foreign_save_jp2k_write_target( void *buffer, size_t length, void *client )
50 {
51 	VipsTarget *target = VIPS_TARGET( client );
52 	if( vips_target_write( target, buffer, length ) )
53 		return( 0 );
54 	return( length );
55 }
56 static opj_stream_t *
57 vips_foreign_save_jp2k_target( VipsTarget *target )
58 {
59 	opj_stream_t *stream;
60 	if( !(stream = opj_stream_create( OPJ_J2K_STREAM_CHUNK_SIZE, FALSE )) ) 
61 		return( NULL );
62 	opj_stream_set_user_data( stream, target, NULL );
63 	opj_stream_set_write_function( stream, 
64 		vips_foreign_save_jp2k_write_target );
65 	return( stream );
66 }
67 static void 
68 vips_foreign_save_jp2k_error_callback( const char *msg, void *client )
69 {
70 	vips_error( "jp2ksave", "%s", msg ); 
71 }
72 static void 
73 vips_foreign_save_jp2k_warning_callback( const char *msg, void *client )
74 {
75 #ifdef DEBUG
76 	g_warning( "jp2ksave: %s", msg );
77 }
78 static void 
79 vips_foreign_save_jp2k_info_callback( const char *msg, void *client )
80 {
81 #ifdef DEBUG
82 	g_info( "jp2ksave: %s", msg );
83 }
84 static void
85 vips_foreign_save_jp2k_attach_handlers( opj_codec_t *codec )
86 {
87 	opj_set_info_handler( codec,
88 		vips_foreign_save_jp2k_info_callback, NULL );
89 	opj_set_warning_handler( codec, 
90 		vips_foreign_save_jp2k_warning_callback, NULL );
91 	opj_set_error_handler( codec, 
92 		vips_foreign_save_jp2k_error_callback, NULL );
93 }
94 #define RGB_TO_YCC( TYPE ) { \
95 	TYPE *tq = (TYPE *) q; \
96 	\
97 	for( x = 0; x &lt; tile-&gt;width; x++ ) { \
98 		int r = tq[0]; \
99 		int g = tq[1]; \
100 		int b = tq[2]; \
101 		\
102 		int y, cb, cr; \
103 		\
104 		y = 0.299 * r + 0.587 * g + 0.114 * b; \
105 		tq[0] = VIPS_CLIP( 0, y, upb ); \
106 		\
107 		cb = offset - (int)(0.168736 * r + 0.331264 * g - 0.5 * b); \
108 		tq[1] = VIPS_CLIP( 0, cb, upb ); \
109 		\
110 		cr = offset - (int)(-0.5 * r + 0.418688 * g + 0.081312 * b); \
111 		tq[2] = VIPS_CLIP( 0, cr, upb ); \
112 		\
113 		tq += 3; \
114 	} \
115 }
116 static void
117 vips_foreign_save_jp2k_rgb_to_ycc( VipsRegion *region, 
118 	VipsRect *tile, int prec ) 
119 {
120 	VipsImage *im = region-&gt;im;
121 	int offset = 1 &lt;&lt; (prec - 1);
122 	int upb = (1 &lt;&lt; prec) - 1;
123 	int x, y;
124 	g_assert( im-&gt;Bands == 3 );
125 	for( y = 0; y &lt; tile-&gt;height; y++ ) {
126 		VipsPel *q = VIPS_REGION_ADDR( region, 
127 			tile-&gt;left, tile-&gt;top + y );
128 		switch( im-&gt;BandFmt ) {
129 		case VIPS_FORMAT_CHAR:
130 		case VIPS_FORMAT_UCHAR:
131 			RGB_TO_YCC( unsigned char );
132 			break;
133 		case VIPS_FORMAT_SHORT:
134 		case VIPS_FORMAT_USHORT:
135 			RGB_TO_YCC( unsigned short );
136 			break;
137 		case VIPS_FORMAT_INT:
138 		case VIPS_FORMAT_UINT:
139 			RGB_TO_YCC( unsigned int );
140 			break;
141 		default:
142 			g_assert_not_reached();
143 			break;
144 		}
145 	}
146 }
147 #define SHRINK( OUTPUT_TYPE, ACC_TYPE, PIXEL_TYPE ) { \
148 	ACC_TYPE *acc = (ACC_TYPE *) accumulate; \
149 	OUTPUT_TYPE *tq = (OUTPUT_TYPE *) q; \
150 	const int n_pels = comp-&gt;dx * comp-&gt;dy; \
151 	\
152 	PIXEL_TYPE *tp; \
153 	ACC_TYPE *ap; \
154 	\
155 	tp = (PIXEL_TYPE *) p; \
156 	for( x = 0; x &lt; tile-&gt;width; x++ ) { \
157 		acc[x] = *tp; \
158 		tp += n_bands; \
159 	} \
160 	\
161 	for( z = 1; z &lt; comp-&gt;dy; z++ ) { \
162 		tp = (PIXEL_TYPE *) (p + z * lskip); \
163 		for( x = 0; x &lt; tile-&gt;width; x++ ) { \
164 			acc[x] += *tp; \
165 			tp += n_bands; \
166 		} \
167 	} \
168 	\
169 	ap = acc; \
170 	for( x = 0; x &lt; output_width; x++ ) { \
171 		ACC_TYPE sum; \
172 		\
173 		sum = 0; \
174 		for( z = 0; z &lt; comp-&gt;dx; z++ ) \
175 			sum += ap[z]; \
176 		\
177 		tq[x] = (sum + n_pels / 2) / n_pels; \
178 		ap += comp-&gt;dx; \
179 	} \
180 }
181 static void
182 vips_foreign_save_jp2k_unpack_subsample( VipsRegion *region, VipsRect *tile,
183 	opj_image_t *image, VipsPel *tile_buffer, VipsPel *accumulate )
184 {
185 	VipsImage *im = region-&gt;im;
186 	size_t sizeof_element = VIPS_REGION_SIZEOF_ELEMENT( region );
187 	size_t lskip = VIPS_REGION_LSKIP( region );
188 	int n_bands = im-&gt;Bands;
189 	VipsPel *q;
190 	int x, y, z, i;
191 	q = tile_buffer;
192 	for( i = 0; i &lt; n_bands; i++ ) {
193 		opj_image_comp_t *comp = &amp;image-&gt;comps[i];
194 		int output_width = VIPS_ROUND_UINT( 
195 			(double) tile-&gt;width / comp-&gt;dx );
196 		int output_height = VIPS_ROUND_UINT( 
197 			(double) tile-&gt;height / comp-&gt;dy );;
198 		for( y = 0; y &lt; output_height; y++ ) {
199 			VipsPel *p = i * sizeof_element + 
200 				VIPS_REGION_ADDR( region, 
201 					tile-&gt;left, tile-&gt;top + y * comp-&gt;dy );
202 			switch( im-&gt;BandFmt ) {
203 			case VIPS_FORMAT_CHAR:
204 				SHRINK( signed char, int, signed char );
205 				break;
206 			case VIPS_FORMAT_UCHAR:
207 				SHRINK( unsigned char, int, unsigned char );
208 				break;
209 			case VIPS_FORMAT_SHORT:
210 				SHRINK( signed short, int, signed short );
211 				break;
212 			case VIPS_FORMAT_USHORT:
213 				SHRINK( unsigned short, int, unsigned short );
214 				break;
215 			case VIPS_FORMAT_INT:
216 				SHRINK( signed int, gint64, signed int );
217 				break;
218 			case VIPS_FORMAT_UINT:
219 				SHRINK( unsigned int, gint64, unsigned int );
220 				break;
221 			default:
222 				g_assert_not_reached();
223 				break;
224 			}
225 			q += sizeof_element * output_width;
226 		}
227 	}
228 }
229 #define UNPACK( OUT, IN ) { \
230 	OUT *tq = (OUT *) q; \
231 	IN *tp = (IN *) p + i; \
232 	\
233 	for( x = 0; x &lt; tile-&gt;width; x++ ) { \
234 		tq[x] = *tp; \
235 		tp += b; \
236 	} \
237 }
238 static void
239 vips_foreign_save_jp2k_unpack( VipsRegion *region, VipsRect *tile,
240 	opj_image_t *image, VipsPel *tile_buffer )
241 {
242 	VipsImage *im = region-&gt;im;
243 	size_t sizeof_element = VIPS_REGION_SIZEOF_ELEMENT( region );
244 	size_t sizeof_line = sizeof_element * tile-&gt;width;
245 	size_t sizeof_tile = sizeof_line * tile-&gt;height;
246 	int b = im-&gt;Bands;
247 	int x, y, i;
248 	for( y = 0; y &lt; tile-&gt;height; y++ ) {
249 		VipsPel *p = VIPS_REGION_ADDR( region, 
250 			tile-&gt;left, tile-&gt;top + y );
251 		for( i = 0; i &lt; b; i++ ) {
252 			VipsPel *q = tile_buffer + 
253 				i * sizeof_tile + y * sizeof_line;
254 			switch( im-&gt;BandFmt ) {
255 			case VIPS_FORMAT_CHAR:
256 			case VIPS_FORMAT_UCHAR:
257 				UNPACK( unsigned char, unsigned char );
258 				break;
259 			case VIPS_FORMAT_SHORT:
260 			case VIPS_FORMAT_USHORT:
261 				UNPACK( unsigned short, unsigned short );
262 				break;
263 			case VIPS_FORMAT_INT:
264 			case VIPS_FORMAT_UINT:
265 				UNPACK( unsigned int, unsigned int );
266 				break;
267 			default:
268 				g_assert_not_reached();
269 				break;
270 			}
271 		}
272 	}
273 }
274 static size_t
275 vips_foreign_save_jp2k_sizeof_tile( VipsForeignSaveJp2k *jp2k, VipsRect *tile )
276 {
277 	VipsForeignSave *save = (VipsForeignSave *) jp2k;
278 	size_t sizeof_element = VIPS_IMAGE_SIZEOF_ELEMENT( save-&gt;ready );
279 	size_t size;
280 	int i;
281 	size = 0;
282 	for( i = 0; i &lt; jp2k-&gt;image-&gt;numcomps; i++ ) {
283 		opj_image_comp_t *comp = &amp;jp2k-&gt;image-&gt;comps[i];
284 		int output_width = VIPS_ROUND_UINT( 
285 			(double) tile-&gt;width / comp-&gt;dx );
286 		int output_height = VIPS_ROUND_UINT( 
287 			(double) tile-&gt;height / comp-&gt;dy );;
288 		size += output_width * output_height * sizeof_element;
289 	}
290 	return( size );
291 }
292 static int
293 vips_foreign_save_jp2k_write_tiles( VipsForeignSaveJp2k *jp2k )
294 {
295 	VipsForeignSave *save = (VipsForeignSave *) jp2k;
296 	VipsImage *im = save-&gt;ready;
297 	int tiles_across = VIPS_ROUND_UP( im-&gt;Xsize, jp2k-&gt;tile_width ) /
298 		jp2k-&gt;tile_width;
299 	int x;
300 	for( x = 0; x &lt; im-&gt;Xsize; x += jp2k-&gt;tile_width ) {
301 		VipsRect tile;
302 		size_t sizeof_tile;
303 		int tile_index;
304 		tile.left = x;
305 		tile.top = jp2k-&gt;strip-&gt;valid.top;
306 		tile.width = jp2k-&gt;tile_width;
307 		tile.height = jp2k-&gt;tile_height;
308 		vips_rect_intersectrect( &amp;tile, &amp;jp2k-&gt;strip-&gt;valid, &amp;tile );
309 		if( jp2k-&gt;save_as_ycc ) 
310 			vips_foreign_save_jp2k_rgb_to_ycc( jp2k-&gt;strip, 
311 				&amp;tile, jp2k-&gt;image-&gt;comps[0].prec ); 
312 		if( jp2k-&gt;subsample )
313 			vips_foreign_save_jp2k_unpack_subsample( jp2k-&gt;strip, 
314 				&amp;tile, jp2k-&gt;image, 
315 				jp2k-&gt;tile_buffer, jp2k-&gt;accumulate ); 
316 		else
317 			vips_foreign_save_jp2k_unpack( jp2k-&gt;strip, 
318 				&amp;tile, jp2k-&gt;image, 
319 				jp2k-&gt;tile_buffer );
320 		sizeof_tile = 
321 			vips_foreign_save_jp2k_sizeof_tile( jp2k, &amp;tile );
322 		tile_index = tiles_across * tile.top / jp2k-&gt;tile_height +
323 			x / jp2k-&gt;tile_width;
324 		if( !opj_write_tile( jp2k-&gt;codec, tile_index, 
325 			(VipsPel *) jp2k-&gt;tile_buffer, sizeof_tile, 
326 			jp2k-&gt;stream ) )
327 			return( -1 );
328 	}
329 	return( 0 );
330 }
331 static int
332 vips_foreign_save_jp2k_write_block( VipsRegion *region, VipsRect *area, 
333 	void *a )
334 {
335 	VipsForeignSaveJp2k *jp2k = (VipsForeignSaveJp2k *) a;
336 	VipsForeignSave *save = (VipsForeignSave *) jp2k;
337 #ifdef DEBUG_VERBOSE
338 	printf( "vips_foreign_save_jp2k_write_block: y = %d, nlines = %d\n", 
339 		area-&gt;top, area-&gt;height );
340 	for(;;) {
341 		VipsRect hit;
342 		int y;
343 		VipsRect strip_position;
344 		vips_rect_intersectrect( area, &amp;(jp2k-&gt;strip-&gt;valid), &amp;hit );
345 		for( y = 0; y &lt; hit.height; y++ ) {
346 			VipsPel *p = VIPS_REGION_ADDR( region, 
347 				0, hit.top + y );
348 			VipsPel *q = VIPS_REGION_ADDR( jp2k-&gt;strip, 
349 				0, hit.top + y );
350 			memcpy( q, p, VIPS_IMAGE_SIZEOF_LINE( region-&gt;im ) );
351 		}
352 		if( VIPS_RECT_BOTTOM( &amp;hit ) != 
353 			VIPS_RECT_BOTTOM( &amp;jp2k-&gt;strip-&gt;valid ) ) 
354 			break;
355 		if( vips_foreign_save_jp2k_write_tiles( jp2k ) )
356 			return( -1 );
357 		strip_position.left = 0;
358 		strip_position.top = jp2k-&gt;strip-&gt;valid.top + jp2k-&gt;tile_height;
359 		strip_position.width = save-&gt;ready-&gt;Xsize;
360 		strip_position.height = jp2k-&gt;tile_height;
361 		if( vips_region_buffer( jp2k-&gt;strip, &amp;strip_position ) )
362 			return( -1 );
363 	}
364 	return( 0 );
365 }
366 #define VIPS_OPJ_CALLOC( N, TYPE ) \
367 	((TYPE *) calloc( (N), sizeof( TYPE ) ))
368 static opj_image_t * 
369 vips_opj_image_create( OPJ_UINT32 numcmpts,
370 	opj_image_cmptparm_t *cmptparms, OPJ_COLOR_SPACE clrspc,
371 	gboolean allocate )
372 {
373 	OPJ_UINT32 compno;
374 	opj_image_t *image = NULL;
375 	if( !(image = VIPS_OPJ_CALLOC( 1, opj_image_t )) )
376 		return( NULL );
377         image-&gt;color_space = clrspc;
378         image-&gt;numcomps = numcmpts;
379         image-&gt;comps = VIPS_OPJ_CALLOC( image-&gt;numcomps, opj_image_comp_t );
380         if( !image-&gt;comps ) {
381             opj_image_destroy( image );
382             return( NULL );
383         }
384         for( compno = 0; compno &lt; numcmpts; compno++ ) {
385 		opj_image_comp_t *comp = &amp;image-&gt;comps[compno];
386 		comp-&gt;dx = cmptparms[compno].dx;
387 		comp-&gt;dy = cmptparms[compno].dy;
388 		comp-&gt;w = cmptparms[compno].w;
389 		comp-&gt;h = cmptparms[compno].h;
390 		comp-&gt;x0 = cmptparms[compno].x0;
391 		comp-&gt;y0 = cmptparms[compno].y0;
392 		comp-&gt;prec = cmptparms[compno].prec;
393 		comp-&gt;bpp = cmptparms[compno].bpp;
394 		comp-&gt;sgnd = cmptparms[compno].sgnd;
395 		if( comp-&gt;h != 0 &amp;&amp;
396 			(OPJ_SIZE_T) comp-&gt;w &gt; SIZE_MAX / comp-&gt;h / 
397 				sizeof( OPJ_INT32 ) ) {
398 			opj_image_destroy( image );
399 			return( NULL );
400 		}
401 		if( allocate ) {
402 			size_t bytes = (size_t) comp-&gt;w * comp-&gt;h * 
403                                 sizeof( OPJ_INT32 );
404 			comp-&gt;data = (OPJ_INT32*) opj_image_data_alloc( bytes );
405 			if( !comp-&gt;data ) {
406 				opj_image_destroy( image );
407 				return NULL;
408 			}
409 			memset( comp-&gt;data, 0, bytes );
410 		}
411 	}
412 	return( image );
413 }
414 static opj_image_t *
415 vips_foreign_save_jp2k_new_image( VipsImage *im, 
416 	int width, int height, 
417 	gboolean subsample, gboolean save_as_ycc, gboolean allocate )
418 {
419 	OPJ_COLOR_SPACE color_space;
420 	int expected_bands;
421 	int bits_per_pixel;
422 	opj_image_cmptparm_t comps[MAX_BANDS];
423 	opj_image_t *image;
424 	int i;
425 	if( im-&gt;Bands &gt; MAX_BANDS )
426 		return( NULL );
427 	switch( im-&gt;Type ) {
428 	case VIPS_INTERPRETATION_B_W:
429 	case VIPS_INTERPRETATION_GREY16:
430 		color_space = OPJ_CLRSPC_GRAY;
431 		expected_bands = 1;
432 		break;
433 	case VIPS_INTERPRETATION_sRGB:
434 	case VIPS_INTERPRETATION_RGB16:
435 		color_space = save_as_ycc ? OPJ_CLRSPC_SYCC : OPJ_CLRSPC_SRGB;
436 		expected_bands = 3;
437 		break;
438 	case VIPS_INTERPRETATION_CMYK:
439 		color_space = OPJ_CLRSPC_CMYK;
440 		expected_bands = 4;
441 		break;
442 	default:
443 		color_space = OPJ_CLRSPC_UNSPECIFIED;
444 		expected_bands = im-&gt;Bands;
445 		break;
446 	}
447 	switch( im-&gt;BandFmt ) {
448 	case VIPS_FORMAT_CHAR:
449 	case VIPS_FORMAT_UCHAR:
450 		bits_per_pixel = 8;
451 		break;
452 	case VIPS_FORMAT_SHORT:
453 	case VIPS_FORMAT_USHORT:
454 		bits_per_pixel = 16;
455 		break;
456 	case VIPS_FORMAT_INT:
457 	case VIPS_FORMAT_UINT:
458 		bits_per_pixel = 31;
459 		break;
460 	default:
461 		g_assert_not_reached();
462 		break;
463 	}
464 	for( i = 0; i &lt; im-&gt;Bands; i++ ) {
465 		comps[i].dx = (subsample &amp;&amp; i &gt; 0) ? 2 : 1;
466 		comps[i].dy = (subsample &amp;&amp; i &gt; 0) ? 2 : 1;
467 		comps[i].w = width;
468 		comps[i].h = height;
469 		comps[i].x0 = 0;
470 		comps[i].y0 = 0;
471 		comps[i].prec = bits_per_pixel;
472 		comps[i].bpp = bits_per_pixel;
473 		comps[i].sgnd = !vips_band_format_isuint( im-&gt;BandFmt );
474 	}
475 	image = vips_opj_image_create( im-&gt;Bands, comps, color_space, 
476 		allocate );
477 	image-&gt;x1 = width;
478 	image-&gt;y1 = height;
479 	for( i = 0; i &lt; im-&gt;Bands; i++ )
480 		image-&gt;comps[i].alpha = i &gt;= expected_bands;
481 	return( image );
482 }
483 static void
484 vips_foreign_save_jp2k_set_profile( opj_cparameters_t *parameters, 
485 	gboolean lossless, int Q )
486 {
487 	if( lossless )
488 		parameters-&gt;irreversible = FALSE;
489 	else {
490 		int i;
491 		parameters-&gt;irreversible = TRUE;
492 		parameters-&gt;prog_order = OPJ_RPCL;
493 		parameters-&gt;cblockw_init = 64;
494 		parameters-&gt;cblockh_init = 64;
495 		parameters-&gt;cp_disto_alloc = 1;
496 		parameters-&gt;cp_fixed_quality = TRUE;
497 		parameters-&gt;tcp_numlayers = 1;
498 		parameters-&gt;numresolution = 7;
499 		parameters-&gt;csty = 1;
500 		parameters-&gt;res_spec = 7;
501 		for( i = 0; i &lt; parameters-&gt;res_spec; i++ ) { 
502 			parameters-&gt;prch_init[i] = 256;
503 			parameters-&gt;prcw_init[i] = 256;
504 			parameters-&gt;tcp_distoratio[i] = Q + 10 * i;
505 		}
506 	}
507 }
508 static int
509 vips_foreign_save_jp2k_build( VipsObject *object )
510 {
511 	VipsObjectClass *class = VIPS_OBJECT_GET_CLASS( object );
512 	VipsForeignSave *save = (VipsForeignSave *) object;
513 	VipsForeignSaveJp2k *jp2k = (VipsForeignSaveJp2k *) object;
514 	size_t sizeof_tile;
515 	size_t sizeof_line;
516 	VipsRect strip_position;
517 	if( VIPS_OBJECT_CLASS( vips_foreign_save_jp2k_parent_class )-&gt;
518 		build( object ) )
519 		return( -1 );
520 	if( !vips_band_format_isint( save-&gt;ready-&gt;BandFmt ) ) {
521 		vips_error( class-&gt;nickname,
522 			"%s", _( "not an integer format" ) );
523 		return( -1 );
524 	}
525 	switch( jp2k-&gt;subsample_mode ) {
526 	case VIPS_FOREIGN_SUBSAMPLE_AUTO:
527 		jp2k-&gt;subsample =
528 			!jp2k-&gt;lossless &amp;&amp;
529 			jp2k-&gt;Q &lt; 90 &amp;&amp;
530 			save-&gt;ready-&gt;Xsize % 2 == 0 &amp;&amp;
531 			save-&gt;ready-&gt;Ysize % 2 == 0 &amp;&amp;
532 			(save-&gt;ready-&gt;Type == VIPS_INTERPRETATION_sRGB ||
533 			 save-&gt;ready-&gt;Type == VIPS_INTERPRETATION_RGB16) &amp;&amp;
534 			save-&gt;ready-&gt;Bands == 3;
535 		break;
536 	case VIPS_FOREIGN_SUBSAMPLE_ON:
537 		jp2k-&gt;subsample = TRUE;
538 		break;
539 	case VIPS_FOREIGN_SUBSAMPLE_OFF:
540 		jp2k-&gt;subsample = FALSE;
541 		break;
542 	default:
543 		g_assert_not_reached();
544 		break;
545 	}
546 	if( jp2k-&gt;subsample ) 
547 		jp2k-&gt;save_as_ycc = TRUE;
548 	opj_set_default_encoder_parameters( &amp;jp2k-&gt;parameters );
549 	vips_foreign_save_jp2k_set_profile( &amp;jp2k-&gt;parameters, 
550 		jp2k-&gt;lossless, jp2k-&gt;Q ); 
551 	jp2k-&gt;parameters.tile_size_on = OPJ_TRUE;
552 	jp2k-&gt;parameters.cp_tdx = jp2k-&gt;tile_width;
553 	jp2k-&gt;parameters.cp_tdy = jp2k-&gt;tile_height;
554 	jp2k-&gt;parameters.tcp_mct = save-&gt;ready-&gt;Bands &gt;= 3 &amp;&amp; !jp2k-&gt;subsample;
555 	jp2k-&gt;parameters.numresolution = VIPS_MAX( 1, 
556 		log( VIPS_MIN( save-&gt;ready-&gt;Xsize, save-&gt;ready-&gt;Ysize ) ) / 
557 		log( 2 ) - 5 );
558 #ifdef DEBUG
559 	printf( "vips_foreign_save_jp2k_build: numresolutions = %d\n", 
560 		jp2k-&gt;parameters.numresolution );
561 	jp2k-&gt;codec = opj_create_compress( OPJ_CODEC_J2K );
562 	vips_foreign_save_jp2k_attach_handlers( jp2k-&gt;codec );
563 	if( !(jp2k-&gt;image = vips_foreign_save_jp2k_new_image( save-&gt;ready,
564 		save-&gt;ready-&gt;Xsize, save-&gt;ready-&gt;Ysize, 
565 		jp2k-&gt;subsample, jp2k-&gt;save_as_ycc, FALSE )) )
566 		return( -1 );
567         if( !opj_setup_encoder( jp2k-&gt;codec, &amp;jp2k-&gt;parameters, jp2k-&gt;image ) ) 
568 		return( -1 );
569 	opj_codec_set_threads( jp2k-&gt;codec, vips_concurrency_get() );
570 	if( !(jp2k-&gt;stream = vips_foreign_save_jp2k_target( jp2k-&gt;target )) )
571 		return( -1 );
572 	if( !opj_start_compress( jp2k-&gt;codec, jp2k-&gt;image, jp2k-&gt;stream ) )
573 		return( -1 );
574 	sizeof_tile = VIPS_IMAGE_SIZEOF_PEL( save-&gt;ready ) *
575 		jp2k-&gt;tile_width * jp2k-&gt;tile_height;
576 	if( !(jp2k-&gt;tile_buffer = VIPS_ARRAY( NULL, sizeof_tile, VipsPel )) )
577 		return( -1 );
578 	sizeof_line = sizeof( gint64 ) * jp2k-&gt;tile_width;
579 	if( !(jp2k-&gt;accumulate = VIPS_ARRAY( NULL, sizeof_line, VipsPel )) )
580 		return( -1 );
581 	jp2k-&gt;strip = vips_region_new( save-&gt;ready );
582 	strip_position.left = 0;
583 	strip_position.top = 0;
584 	strip_position.width = save-&gt;ready-&gt;Xsize;
585 	strip_position.height = jp2k-&gt;tile_height;
586 	if( vips_region_buffer( jp2k-&gt;strip, &amp;strip_position ) ) 
587 		return( -1 );
588 	if( vips_sink_disc( save-&gt;ready,
589 		vips_foreign_save_jp2k_write_block, jp2k ) )
590 <font color="#980517"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>		return( -1 );
591 	opj_end_compress( jp2k-&gt;codec, jp2k-&gt;stream );
592 	vips_target_finish( jp2k-&gt;target );
593 	return( 0 );
594 }
595 static void
596 vips_foreign_save_jp2k_class_init( VipsForeignSaveJp2kClass *class )
597 {
598 	GObjectClass *gobject_class = G_OBJECT_CLASS( class );
599 	VipsObjectClass *object_class = (VipsObjectClass *) class;
600 	VipsForeignClass *foreign_class = (VipsForeignClass *) class;
601 	VipsForeignSaveClass *save_class = (VipsForeignSaveClass *) class;
602 	gobject_class-&gt;dispose = vips_foreign_save_jp2k_dispose;
603 	gobject_class-&gt;set_property = vips_object_set_property;
604 	gobject_class-&gt;get_property = vips_object_get_property;
605 	object_class-&gt;nickname = "jp2ksave_base";
606 	object_class-&gt;description = _( "save image in JPEG2000 format" );
607 	object_class-&gt;build = vips_foreign_save_jp2k_build;
608 	foreign_class-&gt;suffs = vips__jp2k_suffs;
609 	save_class-&gt;saveable = VIPS_SAVEABLE_ANY;</b></font>
610 	VIPS_ARG_INT( class, "tile_width", 11, 
611 		_( "Tile width" ), 
612 		_( "Tile width in pixels" ),
613 		VIPS_ARGUMENT_OPTIONAL_INPUT,
614 		G_STRUCT_OFFSET( VipsForeignSaveJp2k, tile_width ),
615 		1, 32768, 512 );
616 	VIPS_ARG_INT( class, "tile_height", 12, 
617 		_( "Tile height" ), 
618 		_( "Tile height in pixels" ),
619 		VIPS_ARGUMENT_OPTIONAL_INPUT,
620 		G_STRUCT_OFFSET( VipsForeignSaveJp2k, tile_height ),
621 		1, 32768, 512 );
622 	VIPS_ARG_BOOL( class, "lossless", 13, 
623 		_( "Lossless" ), 
624 		_( "Enable lossless compression" ),
625 		VIPS_ARGUMENT_OPTIONAL_INPUT,
626 		G_STRUCT_OFFSET( VipsForeignSaveJp2k, lossless ),
627 		FALSE ); 
628 	VIPS_ARG_ENUM( class, "subsample_mode", 19,
629 		_( "Subsample mode" ),
630 		_( "Select chroma subsample operation mode" ),
631 		VIPS_ARGUMENT_OPTIONAL_INPUT,
632 		G_STRUCT_OFFSET( VipsForeignSaveJp2k, subsample_mode ),
633 		VIPS_TYPE_FOREIGN_SUBSAMPLE,
634 		VIPS_FOREIGN_SUBSAMPLE_AUTO );
635 	VIPS_ARG_INT( class, "Q", 14, 
636 		_( "Q" ), 
637 		_( "Q factor" ),
638 		VIPS_ARGUMENT_OPTIONAL_INPUT,
639 		G_STRUCT_OFFSET( VipsForeignSaveJp2k, Q ),
640 		1, 100, 48 );
641 }
642 static void
643 vips_foreign_save_jp2k_init( VipsForeignSaveJp2k *jp2k )
644 {
645 	jp2k-&gt;tile_width = 512;
646 	jp2k-&gt;tile_height = 512;
647 <a name="4"></a>
648 <font color="#6cc417"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>	jp2k-&gt;Q = 48;
649 	jp2k-&gt;subsample_mode = VIPS_FOREIGN_SUBSAMPLE_AUTO;
650 }
651 typedef struct _VipsForeignSaveJp2kFile {
652 	VipsForeignSaveJp2k parent_object;
653 	char *filename; 
654 } VipsForeignSaveJp2kFile;
655 typedef VipsForeignSaveJp2kClass VipsForeignSaveJp2kFileClass;
656 G_DEFINE_TYPE( VipsForeignSaveJp2kFile, vips_foreign_save_jp2k_file, 
657 	vips_foreign_save_jp2k_get_type() );
658 static int
659 vips_foreign_save_jp2k_file_build( VipsObject *object )
660 {
661 	VipsForeignSaveJp2k *jp2k = (VipsForeignSaveJp2k *) object;
662 	VipsForeignSaveJp2kFile *file = (VipsForeignSaveJp2kFile *) object;
663 	if( !(jp2k-&gt;target = vips_target_new_to_file( file-&gt;filename )) )</b></font>
664 		return( -1 );
665 	if( VIPS_OBJECT_CLASS( vips_foreign_save_jp2k_file_parent_class )-&gt;
666 		build( object ) )
667 		return( -1 );
668 	return( 0 );
669 }
670 static void
671 vips_foreign_save_jp2k_file_class_init( VipsForeignSaveJp2kFileClass *class )
672 {
673 <a name="1"></a>	GObjectClass *gobject_class = G_OBJECT_CLASS( class );
674 	VipsObjectClass *object_class = (VipsObjectClass *) class;
675 <font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>	gobject_class-&gt;set_property = vips_object_set_property;
676 	gobject_class-&gt;get_property = vips_object_get_property;
677 	object_class-&gt;nickname = "jp2ksave";
678 	object_class-&gt;build = vips_foreign_save_jp2k_file_build;
679 	VIPS_ARG_STRING( class, "filename", 1, 
680 		_( "Filename" ),
681 		_( "Filename to load from" ),
682 		VIPS_ARGUMENT_REQUIRED_INPUT, 
683 		G_STRUCT_OFFSET( VipsForeignSaveJp2kFile, filename ),
684 		NULL );
685 }
686 static void
687 vips_foreign_save_jp2k_file_init( VipsForeignSaveJp2kFile *file )
688 {
689 }
690 typedef struct _VipsForeignSaveJp2kBuffer {
691 	VipsForeignSaveJp2k parent_object;
692 	VipsArea *buf;
693 } VipsForeignSaveJp2kBuffer;
694 typedef VipsForeignSaveJp2kClass VipsForeignSaveJp2kBufferClass;
695 G_DEFINE_TYPE( VipsForeignSaveJp2kBuffer, vips_foreign_save_jp2k_buffer, 
696 	vips_foreign_save_jp2k_get_type() );
697 static int
698 vips_foreign_save_jp2k_buffer_build( VipsObject *object )
699 {
700 	VipsForeignSaveJp2k *jp2k = (VipsForeignSaveJp2k *) object;
701 	VipsForeignSaveJp2kBuffer *buffer = 
702 		(VipsForeignSaveJp2kBuffer *) object;
703 	VipsBlob *blob;
704 	if( !(jp2k-&gt;target = vips_target_new_to_memory()) )
705 		return( -1 );
706 	if( VIPS_OBJECT_CLASS( vips_foreign_save_jp2k_buffer_parent_class )-&gt;
707 		build( object ) )
708 		return( -1 );</b></font>
709 	g_object_get( jp2k-&gt;target, "blob", &amp;blob, NULL );
710 	g_object_set( buffer, "buffer", blob, NULL );
711 	vips_area_unref( VIPS_AREA( blob ) );
712 	return( 0 );
713 }
714 static void
715 vips_foreign_save_jp2k_buffer_class_init( 
716 	VipsForeignSaveJp2kBufferClass *class )
717 {
718 <a name="0"></a>	GObjectClass *gobject_class = G_OBJECT_CLASS( class );
719 	VipsObjectClass *object_class = (VipsObjectClass *) class;
720 <font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>	gobject_class-&gt;set_property = vips_object_set_property;
721 	gobject_class-&gt;get_property = vips_object_get_property;
722 	object_class-&gt;nickname = "jp2ksave_buffer";
723 	object_class-&gt;build = vips_foreign_save_jp2k_buffer_build;
724 	VIPS_ARG_BOXED( class, "buffer", 1, 
725 		_( "Buffer" ),
726 		_( "Buffer to save to" ),
727 		VIPS_ARGUMENT_REQUIRED_OUTPUT, 
728 		G_STRUCT_OFFSET( VipsForeignSaveJp2kBuffer, buf ),
729 		VIPS_TYPE_BLOB );
730 }
731 static void
732 vips_foreign_save_jp2k_buffer_init( VipsForeignSaveJp2kBuffer *buffer )
733 {
734 }
735 typedef struct _VipsForeignSaveJp2kTarget {
736 	VipsForeignSaveJp2k parent_object;
737 	VipsTarget *target;
738 } VipsForeignSaveJp2kTarget;
739 typedef VipsForeignSaveJp2kClass VipsForeignSaveJp2kTargetClass;
740 G_DEFINE_TYPE( VipsForeignSaveJp2kTarget, vips_foreign_save_jp2k_target, 
741 	vips_foreign_save_jp2k_get_type() );
742 static int
743 vips_foreign_save_jp2k_target_build( VipsObject *object )
744 {
745 	VipsForeignSaveJp2k *jp2k = (VipsForeignSaveJp2k *) object;
746 	VipsForeignSaveJp2kTarget *target = 
747 		(VipsForeignSaveJp2kTarget *) object;
748 	if( target-&gt;target ) {
749 		jp2k-&gt;target = target-&gt;target;
750 		g_object_ref( jp2k-&gt;target );
751 	}
752 	if( VIPS_OBJECT_CLASS( vips_foreign_save_jp2k_target_parent_class )-&gt;
753 		build( object ) )
754 		return( -1 );
755 	return( 0 );
756 }
757 static void
758 vips_foreign_save_jp2k_target_class_init( 
759 	VipsForeignSaveJp2kTargetClass *class )
760 {
761 	GObjectClass *gobject_class = G_OBJECT_CLASS( class );
762 	VipsObjectClass *object_class = (VipsObjectClass *) class;
763 	gobject_class-&gt;set_property = vips_object_set_property;</b></font>
764 	gobject_class-&gt;get_property = vips_object_get_property;
765 	object_class-&gt;nickname = "jp2ksave_target";
766 	object_class-&gt;build = vips_foreign_save_jp2k_target_build;
767 	VIPS_ARG_OBJECT( class, "target", 1,
768 		_( "Target" ),
769 		_( "Target to save to" ),
770 		VIPS_ARGUMENT_REQUIRED_INPUT, 
771 		G_STRUCT_OFFSET( VipsForeignSaveJp2kTarget, target ),
772 		VIPS_TYPE_TARGET );
773 }
774 static void
775 vips_foreign_save_jp2k_target_init( VipsForeignSaveJp2kTarget *target )
776 {
777 }
778 typedef struct _TileCompress {
779         opj_codec_t *codec;
780 	opj_image_t *image;
781 	opj_stream_t *stream;
782 	VipsPel *accumulate;
783 } TileCompress;
784 static void
785 vips_foreign_save_jp2k_unpack_subsample_image( VipsRegion *region, 
786 	VipsRect *tile, opj_image_t *image, VipsPel *accumulate )
787 {
788 	VipsImage *im = region-&gt;im;
789 	size_t sizeof_element = VIPS_REGION_SIZEOF_ELEMENT( region );
790 	size_t lskip = VIPS_REGION_LSKIP( region );
791 	int n_bands = im-&gt;Bands;
792 	int x, y, z, i;
793 	for( i = 0; i &lt; n_bands; i++ ) {
794 		opj_image_comp_t *comp = &amp;image-&gt;comps[i];
795 		int *q = comp-&gt;data;
796 		int output_width = VIPS_ROUND_UINT( 
797 			(double) comp-&gt;w / comp-&gt;dx );
798 		int output_height = VIPS_ROUND_UINT( 
799 			(double) comp-&gt;h / comp-&gt;dy );
800 		for( y = 0; y &lt; output_height; y++ ) {
801 			VipsPel *p = i * sizeof_element + 
802 				VIPS_REGION_ADDR( region, 
803 					tile-&gt;left, tile-&gt;top + y * comp-&gt;dy );
804 			switch( im-&gt;BandFmt ) {
805 			case VIPS_FORMAT_CHAR:
806 				SHRINK( int, int, signed char );
807 				break;
808 			case VIPS_FORMAT_UCHAR:
809 				SHRINK( int, int, unsigned char );
810 				break;
811 			case VIPS_FORMAT_SHORT:
812 				SHRINK( int, int, signed short );
813 				break;
814 			case VIPS_FORMAT_USHORT:
815 				SHRINK( int, int, unsigned short );
816 				break;
817 			case VIPS_FORMAT_INT:
818 				SHRINK( int, gint64, signed int );
819 				break;
820 			case VIPS_FORMAT_UINT:
821 				SHRINK( int, gint64, unsigned int );
822 				break;
823 			default:
824 				g_assert_not_reached();
825 				break;
826 			}
827 			q += output_width;
828 		}
829 	}
830 }
831 static void
832 vips_foreign_save_jp2k_unpack_image( VipsRegion *region, VipsRect *tile,
833 	opj_image_t *image )
834 {
835 	VipsImage *im = region-&gt;im;
836 	int b = im-&gt;Bands;
837 	int x, y, i;
838 	for( y = 0; y &lt; tile-&gt;height; y++ ) {
839 		VipsPel *p = VIPS_REGION_ADDR( region, 
840 			tile-&gt;left, tile-&gt;top + y );
841 		for( i = 0; i &lt; b; i++ ) {
842 			opj_image_comp_t *comp = &amp;image-&gt;comps[i];
843                         int *q = comp-&gt;data + y * comp-&gt;w; 
844 			switch( im-&gt;BandFmt ) {
845 			case VIPS_FORMAT_CHAR:
846 			case VIPS_FORMAT_UCHAR:
847 				UNPACK( int, unsigned char );
848 				break;
849 			case VIPS_FORMAT_SHORT:
850 			case VIPS_FORMAT_USHORT:
851 				UNPACK( int, unsigned short );
852 				break;
853 			case VIPS_FORMAT_INT:
854 			case VIPS_FORMAT_UINT:
855 				UNPACK( int, unsigned int );
856 				break;
857 			default:
858 				g_assert_not_reached();
859 				break;
860 			}
861 		}
862 	}
863 }
864 void
865 vips__foreign_load_jp2k_compress_free( TileCompress *compress )
866 {
867 	VIPS_FREEF( opj_destroy_codec, compress-&gt;codec );
868 	VIPS_FREEF( opj_image_destroy, compress-&gt;image );
869 	VIPS_FREEF( opj_stream_destroy, compress-&gt;stream );
870 	VIPS_FREE( compress-&gt;accumulate );
871 }
872 int
873 vips__foreign_load_jp2k_compress( VipsRegion *region, 
874 	VipsRect *tile, VipsTarget *target,
875 	int tile_width, int tile_height,
876         gboolean save_as_ycc, gboolean subsample, gboolean lossless, int Q )
877 {
878 	TileCompress compress = { 0 };
879 	opj_cparameters_t parameters;
880 	size_t sizeof_line;
881 	save_as_ycc = save_as_ycc &amp;&amp; region-&gt;im-&gt;Bands == 3;
882 	subsample = subsample &amp;&amp; save_as_ycc;
883 	opj_set_default_encoder_parameters( &amp;parameters );
884 	vips_foreign_save_jp2k_set_profile( &amp;parameters, lossless, Q ); 
885 	parameters.tcp_mct = region-&gt;im-&gt;Bands &gt;= 3 ? 1 : 0;
886 	if( !(compress.image = vips_foreign_save_jp2k_new_image( region-&gt;im,
887 		tile_width, tile_height, subsample, save_as_ycc, TRUE )) ) {
888 		vips__foreign_load_jp2k_compress_free( &amp;compress );
889 		return( -1 );
890 	}
891 	sizeof_line = sizeof( gint64 ) * tile-&gt;width;
892 	if( !(compress.accumulate = 
893 		VIPS_ARRAY( NULL, sizeof_line, VipsPel )) ) {
894 		vips__foreign_load_jp2k_compress_free( &amp;compress );
895 		return( -1 );
896 	}
897 	compress.codec = opj_create_compress( OPJ_CODEC_J2K );
898 	vips_foreign_save_jp2k_attach_handlers( compress.codec );
899         if( !opj_setup_encoder( compress.codec, 
900 		&amp;parameters, compress.image ) ) {
901 		vips__foreign_load_jp2k_compress_free( &amp;compress );
902 		return( -1 );
903 	}
904 	opj_codec_set_threads( compress.codec, vips_concurrency_get() );
905 	if( save_as_ycc ) 
906 		vips_foreign_save_jp2k_rgb_to_ycc( region, 
907 			tile, compress.image-&gt;comps[0].prec );
908 	if( subsample )
909 		vips_foreign_save_jp2k_unpack_subsample_image( region,
910 			tile, compress.image, 
911 			compress.accumulate ); 
912 	else
913 		vips_foreign_save_jp2k_unpack_image( region,
914 			tile, compress.image ); 
915 	if( !(compress.stream = vips_foreign_save_jp2k_target( target )) ) {
916 		vips__foreign_load_jp2k_compress_free( &amp;compress );
917 		return( -1 );
918 	}
919 	if( !opj_start_compress( compress.codec, 
920 		compress.image, compress.stream ) ) {
921 		vips__foreign_load_jp2k_compress_free( &amp;compress );
922 		return( -1 );
923 	}
924 	if( !opj_encode( compress.codec, compress.stream ) ) {
925 		vips__foreign_load_jp2k_compress_free( &amp;compress );
926 		return( -1 );
927 	}
928 	opj_end_compress( compress.codec, compress.stream );
929 	vips__foreign_load_jp2k_compress_free( &amp;compress );
930 	return( 0 );
931 }
932 int
933 vips__foreign_load_jp2k_compress( VipsRegion *region, 
934 	VipsRect *tile, VipsTarget *target,
935 	int tile_width, int tile_height,
936         gboolean save_as_ycc, gboolean subsample, gboolean lossless, int Q )
937 {
938 <a name="3"></a>	vips_error( "jp2k", 
939 		"%s", _( "libvips built without JPEG2000 support" ) );
940 	return( -1 );
941 <font color="#53858b"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>}
942 int
943 vips_jp2ksave( VipsImage *in, const char *filename, ... )
944 {
945 	va_list ap;
946 	int result;
947 	va_start( ap, filename );
948 	result = vips_call_split( "jp2ksave", ap, in, filename );
949 	va_end( ap );
950 	return( result );
951 }
952 int
953 vips_jp2ksave_buffer( VipsImage *in, void **buf, size_t *len, ... )
954 {
955 	va_list ap;
956 	VipsArea *area;
957 	int result;
958 	area = NULL; 
959 	va_start( ap, len );
960 	result = vips_call_split( "jp2ksave_buffer", ap, in, &amp;area );</b></font>
961 	va_end( ap );
962 	if( !result &amp;&amp;
963 		area ) { 
964 		if( buf ) {
965 			*buf = area-&gt;data;
966 			area-&gt;free_fn = NULL;
967 		}
968 		if( len ) 
969 			*len = area-&gt;length;
970 		vips_area_unref( area );
971 	}
972 	return( result );
973 }
974 int
975 vips_jp2ksave_target( VipsImage *in, VipsTarget *target, ... )
976 {
977 	va_list ap;
978 	int result;
979 	va_start( ap, target );
980 	result = vips_call_split( "jp2ksave_target", ap, in, target );
981 	va_end( ap );
982 	return( result );
983 }
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
