
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 37, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>Adafruit_nRF52_Arduino-MDEwOlJlcG9zaXRvcnk3NDM1NDcyOQ==-flat-memory_buffer_alloc.c</h3>
            <pre><code>1  #if !defined(POLARSSL_CONFIG_FILE)
2  #include "config.h"
3  #else
4  #include POLARSSL_CONFIG_FILE
5  #endif
6  #if defined(POLARSSL_MEMORY_BUFFER_ALLOC_C)
7  #include "memory_buffer_alloc.h"
8  #include "platform.h"
9  #include <string.h>
10  #if defined(POLARSSL_MEMORY_BACKTRACE)
11  #include <execinfo.h>
12  #endif
13  #if defined(POLARSSL_THREADING_C)
14  #include "polarssl/threading.h"
15  #endif
16  static void polarssl_zeroize( void *v, size_t n ) {
17      volatile unsigned char *p = v; while( n-- ) *p++ = 0;
18  }
19  #define MAGIC1       0xFF00AA55
20  #define MAGIC2       0xEE119966
21  #define MAX_BT 20
22  typedef struct _memory_header memory_header;
23  struct _memory_header
24  {
25      size_t          magic1;
26      size_t          size;
27      size_t          alloc;
28      memory_header   *prev;
29      memory_header   *next;
30      memory_header   *prev_free;
31      memory_header   *next_free;
32  #if defined(POLARSSL_MEMORY_BACKTRACE)
33      char            **trace;
34      size_t          trace_count;
35  #endif
36      size_t          magic2;
37  };
38  typedef struct
39  {
40      unsigned char   *buf;
41      size_t          len;
42      memory_header   *first;
43      memory_header   *first_free;
44      int             verify;
45  #if defined(POLARSSL_MEMORY_DEBUG)
46      size_t          malloc_count;
47      size_t          free_count;
48      size_t          total_used;
49      size_t          maximum_used;
50      size_t          header_count;
51      size_t          maximum_header_count;
52  #endif
53  #if defined(POLARSSL_THREADING_C)
54      threading_mutex_t   mutex;
55  #endif
56  }
57  buffer_alloc_ctx;
58  static buffer_alloc_ctx heap;
59  #if defined(POLARSSL_MEMORY_DEBUG)
60  static void debug_header( memory_header *hdr )
61  {
62  #if defined(POLARSSL_MEMORY_BACKTRACE)
63      size_t i;
64  #endif
65      polarssl_fprintf( stderr, "HDR:  PTR(%10zu), PREV(%10zu), NEXT(%10zu), "
66                                "ALLOC(%zu), SIZE(%10zu)\n",
67                        (size_t) hdr, (size_t) hdr->prev, (size_t) hdr->next,
68                        hdr->alloc, hdr->size );
69      polarssl_fprintf( stderr, "      FPREV(%10zu), FNEXT(%10zu)\n",
70                        (size_t) hdr->prev_free, (size_t) hdr->next_free );
71  #if defined(POLARSSL_MEMORY_BACKTRACE)
72      polarssl_fprintf( stderr, "TRACE: \n" );
73      for( i = 0; i < hdr->trace_count; i++ )
74          polarssl_fprintf( stderr, "%s\n", hdr->trace[i] );
75      polarssl_fprintf( stderr, "\n" );
76  #endif
77  }
78  static void debug_chain()
79  {
80      memory_header *cur = heap.first;
81      polarssl_fprintf( stderr, "\nBlock list\n" );
82      while( cur != NULL )
83      {
84          debug_header( cur );
85          cur = cur->next;
86      }
87      polarssl_fprintf( stderr, "Free list\n" );
88      cur = heap.first_free;
89      while( cur != NULL )
90      {
91          debug_header( cur );
92          cur = cur->next_free;
93      }
94  }
95  #endif &bsol;* POLARSSL_MEMORY_DEBUG */
96  static int verify_header( memory_header *hdr )
97  {
98      if( hdr->magic1 != MAGIC1 )
99      {
100  #if defined(POLARSSL_MEMORY_DEBUG)
101          polarssl_fprintf( stderr, "FATAL: MAGIC1 mismatch\n" );
102  #endif
103          return( 1 );
104      }
105      if( hdr->magic2 != MAGIC2 )
106      {
107  #if defined(POLARSSL_MEMORY_DEBUG)
108          polarssl_fprintf( stderr, "FATAL: MAGIC2 mismatch\n" );
109  #endif
110          return( 1 );
111      }
112      if( hdr->alloc > 1 )
113      {
114  #if defined(POLARSSL_MEMORY_DEBUG)
115          polarssl_fprintf( stderr, "FATAL: alloc has illegal value\n" );
116  #endif
117          return( 1 );
118      }
119      if( hdr->prev != NULL && hdr->prev == hdr->next )
120      {
121  #if defined(POLARSSL_MEMORY_DEBUG)
122          polarssl_fprintf( stderr, "FATAL: prev == next\n" );
123  #endif
124          return( 1 );
125      }
126      if( hdr->prev_free != NULL && hdr->prev_free == hdr->next_free )
127      {
128  #if defined(POLARSSL_MEMORY_DEBUG)
129          polarssl_fprintf( stderr, "FATAL: prev_free == next_free\n" );
130  #endif
131          return( 1 );
132      }
133      return( 0 );
134  }
135  static int verify_chain()
136  {
137      memory_header *prv = heap.first, *cur = heap.first->next;
138      if( verify_header( heap.first ) != 0 )
139      {
140  #if defined(POLARSSL_MEMORY_DEBUG)
141          polarssl_fprintf( stderr, "FATAL: verification of first header "
142                                    "failed\n" );
143  #endif
144          return( 1 );
145      }
146      if( heap.first->prev != NULL )
147      {
148  #if defined(POLARSSL_MEMORY_DEBUG)
149          polarssl_fprintf( stderr, "FATAL: verification failed: "
150                                    "first->prev != NULL\n" );
151  #endif
152          return( 1 );
153      }
154      while( cur != NULL )
155      {
156          if( verify_header( cur ) != 0 )
157          {
158  #if defined(POLARSSL_MEMORY_DEBUG)
159              polarssl_fprintf( stderr, "FATAL: verification of header "
160                                        "failed\n" );
161  #endif
162              return( 1 );
163          }
164          if( cur->prev != prv )
165          {
166  #if defined(POLARSSL_MEMORY_DEBUG)
167              polarssl_fprintf( stderr, "FATAL: verification failed: "
168                                        "cur->prev != prv\n" );
169  #endif
170              return( 1 );
171          }
172          prv = cur;
173          cur = cur->next;
174      }
175      return( 0 );
176  }
177  static void *buffer_alloc_malloc( size_t len )
178  {
179      memory_header *new, *cur = heap.first_free;
180      unsigned char *p;
181  #if defined(POLARSSL_MEMORY_BACKTRACE)
182      void *trace_buffer[MAX_BT];
183      size_t trace_cnt;
184  #endif
185      if( heap.buf == NULL || heap.first == NULL )
186          return( NULL );
187      if( len % POLARSSL_MEMORY_ALIGN_MULTIPLE )
188      {
189          len -= len % POLARSSL_MEMORY_ALIGN_MULTIPLE;
190          len += POLARSSL_MEMORY_ALIGN_MULTIPLE;
191      }
192      while( cur != NULL )
193      {
194          if( cur->size >= len )
195              break;
196          cur = cur->next_free;
197      }
198      if( cur == NULL )
199          return( NULL );
200      if( cur->alloc != 0 )
201      {
202  #if defined(POLARSSL_MEMORY_DEBUG)
203          polarssl_fprintf( stderr, "FATAL: block in free_list but allocated "
204                                    "data\n" );
205  #endif
206          polarssl_exit( 1 );
207      }
208  #if defined(POLARSSL_MEMORY_DEBUG)
209      heap.malloc_count++;
210  #endif
211      if( cur->size - len < sizeof(memory_header) +
212                            POLARSSL_MEMORY_ALIGN_MULTIPLE )
213      {
214          cur->alloc = 1;
215          if( cur->prev_free != NULL )
<span onclick='openModal()' class='match'>216              cur->prev_free->next_free = cur->next_free;
217          else
218              heap.first_free = cur->next_free;
219          if( cur->next_free != NULL )
220              cur->next_free->prev_free = cur->prev_free;
221          cur->prev_free = NULL;
</span>222          cur->next_free = NULL;
223  #if defined(POLARSSL_MEMORY_DEBUG)
224          heap.total_used += cur->size;
225          if( heap.total_used > heap.maximum_used )
226              heap.maximum_used = heap.total_used;
227  #endif
228  #if defined(POLARSSL_MEMORY_BACKTRACE)
229          trace_cnt = backtrace( trace_buffer, MAX_BT );
230          cur->trace = backtrace_symbols( trace_buffer, trace_cnt );
231          cur->trace_count = trace_cnt;
232  #endif
233          if( ( heap.verify & MEMORY_VERIFY_ALLOC ) && verify_chain() != 0 )
234              polarssl_exit( 1 );
235          return( ( (unsigned char *) cur ) + sizeof(memory_header) );
236      }
237      p = ( (unsigned char *) cur ) + sizeof(memory_header) + len;
238      new = (memory_header *) p;
239      new->size = cur->size - len - sizeof(memory_header);
240      new->alloc = 0;
241      new->prev = cur;
242      new->next = cur->next;
243  #if defined(POLARSSL_MEMORY_BACKTRACE)
244      new->trace = NULL;
245      new->trace_count = 0;
246  #endif
247      new->magic1 = MAGIC1;
248      new->magic2 = MAGIC2;
249      if( new->next != NULL )
250          new->next->prev = new;
251      new->prev_free = cur->prev_free;
252      new->next_free = cur->next_free;
253      if( new->prev_free != NULL )
254          new->prev_free->next_free = new;
255      else
256          heap.first_free = new;
257      if( new->next_free != NULL )
258          new->next_free->prev_free = new;
259      cur->alloc = 1;
260      cur->size = len;
261      cur->next = new;
262      cur->prev_free = NULL;
263      cur->next_free = NULL;
264  #if defined(POLARSSL_MEMORY_DEBUG)
265      heap.header_count++;
266      if( heap.header_count > heap.maximum_header_count )
267          heap.maximum_header_count = heap.header_count;
268      heap.total_used += cur->size;
269      if( heap.total_used > heap.maximum_used )
270          heap.maximum_used = heap.total_used;
271  #endif
272  #if defined(POLARSSL_MEMORY_BACKTRACE)
273      trace_cnt = backtrace( trace_buffer, MAX_BT );
274      cur->trace = backtrace_symbols( trace_buffer, trace_cnt );
275      cur->trace_count = trace_cnt;
276  #endif
277      if( ( heap.verify & MEMORY_VERIFY_ALLOC ) && verify_chain() != 0 )
278          polarssl_exit( 1 );
279      return( ( (unsigned char *) cur ) + sizeof(memory_header) );
280  }
281  static void buffer_alloc_free( void *ptr )
282  {
283      memory_header *hdr, *old = NULL;
284      unsigned char *p = (unsigned char *) ptr;
285      if( ptr == NULL || heap.buf == NULL || heap.first == NULL )
286          return;
287      if( p < heap.buf || p > heap.buf + heap.len )
288      {
289  #if defined(POLARSSL_MEMORY_DEBUG)
290          polarssl_fprintf( stderr, "FATAL: polarssl_free() outside of managed "
291                                    "space\n" );
292  #endif
293          polarssl_exit( 1 );
294      }
295      p -= sizeof(memory_header);
296      hdr = (memory_header *) p;
297      if( verify_header( hdr ) != 0 )
298          polarssl_exit( 1 );
299      if( hdr->alloc != 1 )
300      {
301  #if defined(POLARSSL_MEMORY_DEBUG)
302          polarssl_fprintf( stderr, "FATAL: polarssl_free() on unallocated "
303                                    "data\n" );
304  #endif
305          polarssl_exit( 1 );
306      }
307      hdr->alloc = 0;
308  #if defined(POLARSSL_MEMORY_DEBUG)
309      heap.free_count++;
310      heap.total_used -= hdr->size;
311  #endif
312      if( hdr->prev != NULL && hdr->prev->alloc == 0 )
313      {
314  #if defined(POLARSSL_MEMORY_DEBUG)
315          heap.header_count--;
316  #endif
317          hdr->prev->size += sizeof(memory_header) + hdr->size;
318          hdr->prev->next = hdr->next;
319          old = hdr;
320          hdr = hdr->prev;
321          if( hdr->next != NULL )
322              hdr->next->prev = hdr;
323  #if defined(POLARSSL_MEMORY_BACKTRACE)
324          free( old->trace );
325  #endif
326          memset( old, 0, sizeof(memory_header) );
327      }
328      if( hdr->next != NULL && hdr->next->alloc == 0 )
329      {
330  #if defined(POLARSSL_MEMORY_DEBUG)
331          heap.header_count--;
332  #endif
333          hdr->size += sizeof(memory_header) + hdr->next->size;
334          old = hdr->next;
335          hdr->next = hdr->next->next;
336          if( hdr->prev_free != NULL || hdr->next_free != NULL )
337          {
338              if( hdr->prev_free != NULL )
339                  hdr->prev_free->next_free = hdr->next_free;
340              else
341                  heap.first_free = hdr->next_free;
342              if( hdr->next_free != NULL )
343                  hdr->next_free->prev_free = hdr->prev_free;
344          }
345          hdr->prev_free = old->prev_free;
346          hdr->next_free = old->next_free;
347          if( hdr->prev_free != NULL )
348              hdr->prev_free->next_free = hdr;
349          else
350              heap.first_free = hdr;
351          if( hdr->next_free != NULL )
352              hdr->next_free->prev_free = hdr;
353          if( hdr->next != NULL )
354              hdr->next->prev = hdr;
355  #if defined(POLARSSL_MEMORY_BACKTRACE)
356          free( old->trace );
357  #endif
358          memset( old, 0, sizeof(memory_header) );
359      }
360      if( old == NULL )
361      {
362          hdr->next_free = heap.first_free;
363          if( heap.first_free != NULL )
364              heap.first_free->prev_free = hdr;
365          heap.first_free = hdr;
366      }
367  #if defined(POLARSSL_MEMORY_BACKTRACE)
368      hdr->trace = NULL;
369      hdr->trace_count = 0;
370  #endif
371      if( ( heap.verify & MEMORY_VERIFY_FREE ) && verify_chain() != 0 )
372          polarssl_exit( 1 );
373  }
374  void memory_buffer_set_verify( int verify )
375  {
376      heap.verify = verify;
377  }
378  int memory_buffer_alloc_verify()
379  {
380      return verify_chain();
381  }
382  #if defined(POLARSSL_MEMORY_DEBUG)
383  void memory_buffer_alloc_status()
384  {
385      polarssl_fprintf( stderr,
386                        "Current use: %zu blocks / %zu bytes, max: %zu blocks / "
387                        "%zu bytes (total %zu bytes), malloc / free: %zu / %zu\n",
388                        heap.header_count, heap.total_used,
389                        heap.maximum_header_count, heap.maximum_used,
390                        heap.maximum_header_count * sizeof( memory_header )
391                        + heap.maximum_used,
392                        heap.malloc_count, heap.free_count );
393      if( heap.first->next == NULL )
394          polarssl_fprintf( stderr, "All memory de-allocated in stack buffer\n" );
395      else
396      {
397          polarssl_fprintf( stderr, "Memory currently allocated:\n" );
398          debug_chain();
399      }
400  }
401  void memory_buffer_alloc_max_get( size_t *max_used, size_t *max_blocks )
402  {
403      *max_used   = heap.maximum_used;
404      *max_blocks = heap.maximum_header_count;
405  }
406  void memory_buffer_alloc_max_reset( void )
407  {
408      heap.maximum_used = 0;
409      heap.maximum_header_count = 0;
410  }
411  void memory_buffer_alloc_cur_get( size_t *cur_used, size_t *cur_blocks )
412  {
413      *cur_used   = heap.total_used;
414      *cur_blocks = heap.header_count;
415  }
416  #endif &bsol;* POLARSSL_MEMORY_DEBUG */
417  #if defined(POLARSSL_THREADING_C)
418  static void *buffer_alloc_malloc_mutexed( size_t len )
419  {
420      void *buf;
421      polarssl_mutex_lock( &heap.mutex );
422      buf = buffer_alloc_malloc( len );
423      polarssl_mutex_unlock( &heap.mutex );
424      return( buf );
425  }
426  static void buffer_alloc_free_mutexed( void *ptr )
427  {
428      polarssl_mutex_lock( &heap.mutex );
429      buffer_alloc_free( ptr );
430      polarssl_mutex_unlock( &heap.mutex );
431  }
432  #endif &bsol;* POLARSSL_THREADING_C */
433  int memory_buffer_alloc_init( unsigned char *buf, size_t len )
434  {
435      memset( &heap, 0, sizeof(buffer_alloc_ctx) );
436      memset( buf, 0, len );
437  #if defined(POLARSSL_THREADING_C)
438      polarssl_mutex_init( &heap.mutex );
439      platform_set_malloc_free( buffer_alloc_malloc_mutexed,
440                                buffer_alloc_free_mutexed );
441  #else
442      platform_set_malloc_free( buffer_alloc_malloc, buffer_alloc_free );
443  #endif
444      if( (size_t) buf % POLARSSL_MEMORY_ALIGN_MULTIPLE )
445      {
446          len -= POLARSSL_MEMORY_ALIGN_MULTIPLE
447               - (size_t) buf % POLARSSL_MEMORY_ALIGN_MULTIPLE;
448          buf += POLARSSL_MEMORY_ALIGN_MULTIPLE
449               - (size_t) buf % POLARSSL_MEMORY_ALIGN_MULTIPLE;
450      }
451      heap.buf = buf;
452      heap.len = len;
453      heap.first = (memory_header *) buf;
454      heap.first->size = len - sizeof(memory_header);
455      heap.first->magic1 = MAGIC1;
456      heap.first->magic2 = MAGIC2;
457      heap.first_free = heap.first;
458      return( 0 );
459  }
460  void memory_buffer_alloc_free()
461  {
462  #if defined(POLARSSL_THREADING_C)
463      polarssl_mutex_free( &heap.mutex );
464  #endif
465      polarssl_zeroize( &heap, sizeof(buffer_alloc_ctx) );
466  }
467  #if defined(POLARSSL_SELF_TEST)
468  static int check_pointer( void *p )
469  {
470      if( p == NULL )
471          return( -1 );
472      if( (size_t) p % POLARSSL_MEMORY_ALIGN_MULTIPLE != 0 )
473          return( -1 );
474      return( 0 );
475  }
476  static int check_all_free( )
477  {
478      if(
479  #if defined(POLARSSL_MEMORY_DEBUG)
480          heap.total_used != 0 ||
481  #endif
482          heap.first != heap.first_free ||
483          (void *) heap.first != (void *) heap.buf )
484      {
485          return( -1 );
486      }
487      return( 0 );
488  }
489  #define TEST_ASSERT( condition )            \
490      if( ! (condition) )                     \
491      {                                       \
492          if( verbose != 0 )                  \
493              polarssl_printf( "failed\n" );  \
494                                              \
495          ret = 1;                            \
496          goto cleanup;                       \
497      }
498  int memory_buffer_alloc_self_test( int verbose )
499  {
500      unsigned char buf[1024];
501      unsigned char *p, *q, *r, *end;
502      int ret = 0;
503      if( verbose != 0 )
504          polarssl_printf( "  MBA test #1 (basic alloc-free cycle): " );
505      memory_buffer_alloc_init( buf, sizeof( buf ) );
506      p = polarssl_malloc( 1 );
507      q = polarssl_malloc( 128 );
508      r = polarssl_malloc( 16 );
509      TEST_ASSERT( check_pointer( p ) == 0 &&
510                   check_pointer( q ) == 0 &&
511                   check_pointer( r ) == 0 );
512      polarssl_free( r );
513      polarssl_free( q );
514      polarssl_free( p );
515      TEST_ASSERT( check_all_free( ) == 0 );
516      end = heap.buf + heap.len;
517      memory_buffer_alloc_free( );
518      if( verbose != 0 )
519          polarssl_printf( "passed\n" );
520      if( verbose != 0 )
521          polarssl_printf( "  MBA test #2 (buf not aligned): " );
522      memory_buffer_alloc_init( buf + 1, sizeof( buf ) - 1 );
523      TEST_ASSERT( heap.buf + heap.len == end );
524      p = polarssl_malloc( 1 );
525      q = polarssl_malloc( 128 );
526      r = polarssl_malloc( 16 );
527      TEST_ASSERT( check_pointer( p ) == 0 &&
528                   check_pointer( q ) == 0 &&
529                   check_pointer( r ) == 0 );
530      polarssl_free( r );
531      polarssl_free( q );
532      polarssl_free( p );
533      TEST_ASSERT( check_all_free( ) == 0 );
534      memory_buffer_alloc_free( );
535      if( verbose != 0 )
536          polarssl_printf( "passed\n" );
537      if( verbose != 0 )
538          polarssl_printf( "  MBA test #3 (full): " );
539      memory_buffer_alloc_init( buf, sizeof( buf ) );
540      p = polarssl_malloc( sizeof( buf ) - sizeof( memory_header ) );
541      TEST_ASSERT( check_pointer( p ) == 0 );
542      TEST_ASSERT( polarssl_malloc( 1 ) == NULL );
543      polarssl_free( p );
544      p = polarssl_malloc( sizeof( buf ) - 2 * sizeof( memory_header ) - 16 );
545      q = polarssl_malloc( 16 );
546      TEST_ASSERT( check_pointer( p ) == 0 && check_pointer( q ) == 0 );
547      TEST_ASSERT( polarssl_malloc( 1 ) == NULL );
548      polarssl_free( q );
549      TEST_ASSERT( polarssl_malloc( 17 ) == NULL );
550      polarssl_free( p );
551      TEST_ASSERT( check_all_free( ) == 0 );
552      memory_buffer_alloc_free( );
553      if( verbose != 0 )
554          polarssl_printf( "passed\n" );
555  cleanup:
556      memory_buffer_alloc_free( );
557      return( ret );
558  }
559  #endif &bsol;* POLARSSL_SELF_TEST */
560  #endif &bsol;* POLARSSL_MEMORY_BUFFER_ALLOC_C */
</code></pre>
        </div>
        <div class="column">
            <h3>Adafruit_nRF52_Arduino-MDEwOlJlcG9zaXRvcnk3NDM1NDcyOQ==-flat-memory_buffer_alloc.c</h3>
            <pre><code>1  #if !defined(POLARSSL_CONFIG_FILE)
2  #include "config.h"
3  #else
4  #include POLARSSL_CONFIG_FILE
5  #endif
6  #if defined(POLARSSL_MEMORY_BUFFER_ALLOC_C)
7  #include "memory_buffer_alloc.h"
8  #include "platform.h"
9  #include <string.h>
10  #if defined(POLARSSL_MEMORY_BACKTRACE)
11  #include <execinfo.h>
12  #endif
13  #if defined(POLARSSL_THREADING_C)
14  #include "polarssl/threading.h"
15  #endif
16  static void polarssl_zeroize( void *v, size_t n ) {
17      volatile unsigned char *p = v; while( n-- ) *p++ = 0;
18  }
19  #define MAGIC1       0xFF00AA55
20  #define MAGIC2       0xEE119966
21  #define MAX_BT 20
22  typedef struct _memory_header memory_header;
23  struct _memory_header
24  {
25      size_t          magic1;
26      size_t          size;
27      size_t          alloc;
28      memory_header   *prev;
29      memory_header   *next;
30      memory_header   *prev_free;
31      memory_header   *next_free;
32  #if defined(POLARSSL_MEMORY_BACKTRACE)
33      char            **trace;
34      size_t          trace_count;
35  #endif
36      size_t          magic2;
37  };
38  typedef struct
39  {
40      unsigned char   *buf;
41      size_t          len;
42      memory_header   *first;
43      memory_header   *first_free;
44      int             verify;
45  #if defined(POLARSSL_MEMORY_DEBUG)
46      size_t          malloc_count;
47      size_t          free_count;
48      size_t          total_used;
49      size_t          maximum_used;
50      size_t          header_count;
51      size_t          maximum_header_count;
52  #endif
53  #if defined(POLARSSL_THREADING_C)
54      threading_mutex_t   mutex;
55  #endif
56  }
57  buffer_alloc_ctx;
58  static buffer_alloc_ctx heap;
59  #if defined(POLARSSL_MEMORY_DEBUG)
60  static void debug_header( memory_header *hdr )
61  {
62  #if defined(POLARSSL_MEMORY_BACKTRACE)
63      size_t i;
64  #endif
65      polarssl_fprintf( stderr, "HDR:  PTR(%10zu), PREV(%10zu), NEXT(%10zu), "
66                                "ALLOC(%zu), SIZE(%10zu)\n",
67                        (size_t) hdr, (size_t) hdr->prev, (size_t) hdr->next,
68                        hdr->alloc, hdr->size );
69      polarssl_fprintf( stderr, "      FPREV(%10zu), FNEXT(%10zu)\n",
70                        (size_t) hdr->prev_free, (size_t) hdr->next_free );
71  #if defined(POLARSSL_MEMORY_BACKTRACE)
72      polarssl_fprintf( stderr, "TRACE: \n" );
73      for( i = 0; i < hdr->trace_count; i++ )
74          polarssl_fprintf( stderr, "%s\n", hdr->trace[i] );
75      polarssl_fprintf( stderr, "\n" );
76  #endif
77  }
78  static void debug_chain()
79  {
80      memory_header *cur = heap.first;
81      polarssl_fprintf( stderr, "\nBlock list\n" );
82      while( cur != NULL )
83      {
84          debug_header( cur );
85          cur = cur->next;
86      }
87      polarssl_fprintf( stderr, "Free list\n" );
88      cur = heap.first_free;
89      while( cur != NULL )
90      {
91          debug_header( cur );
92          cur = cur->next_free;
93      }
94  }
95  #endif &bsol;* POLARSSL_MEMORY_DEBUG */
96  static int verify_header( memory_header *hdr )
97  {
98      if( hdr->magic1 != MAGIC1 )
99      {
100  #if defined(POLARSSL_MEMORY_DEBUG)
101          polarssl_fprintf( stderr, "FATAL: MAGIC1 mismatch\n" );
102  #endif
103          return( 1 );
104      }
105      if( hdr->magic2 != MAGIC2 )
106      {
107  #if defined(POLARSSL_MEMORY_DEBUG)
108          polarssl_fprintf( stderr, "FATAL: MAGIC2 mismatch\n" );
109  #endif
110          return( 1 );
111      }
112      if( hdr->alloc > 1 )
113      {
114  #if defined(POLARSSL_MEMORY_DEBUG)
115          polarssl_fprintf( stderr, "FATAL: alloc has illegal value\n" );
116  #endif
117          return( 1 );
118      }
119      if( hdr->prev != NULL && hdr->prev == hdr->next )
120      {
121  #if defined(POLARSSL_MEMORY_DEBUG)
122          polarssl_fprintf( stderr, "FATAL: prev == next\n" );
123  #endif
124          return( 1 );
125      }
126      if( hdr->prev_free != NULL && hdr->prev_free == hdr->next_free )
127      {
128  #if defined(POLARSSL_MEMORY_DEBUG)
129          polarssl_fprintf( stderr, "FATAL: prev_free == next_free\n" );
130  #endif
131          return( 1 );
132      }
133      return( 0 );
134  }
135  static int verify_chain()
136  {
137      memory_header *prv = heap.first, *cur = heap.first->next;
138      if( verify_header( heap.first ) != 0 )
139      {
140  #if defined(POLARSSL_MEMORY_DEBUG)
141          polarssl_fprintf( stderr, "FATAL: verification of first header "
142                                    "failed\n" );
143  #endif
144          return( 1 );
145      }
146      if( heap.first->prev != NULL )
147      {
148  #if defined(POLARSSL_MEMORY_DEBUG)
149          polarssl_fprintf( stderr, "FATAL: verification failed: "
150                                    "first->prev != NULL\n" );
151  #endif
152          return( 1 );
153      }
154      while( cur != NULL )
155      {
156          if( verify_header( cur ) != 0 )
157          {
158  #if defined(POLARSSL_MEMORY_DEBUG)
159              polarssl_fprintf( stderr, "FATAL: verification of header "
160                                        "failed\n" );
161  #endif
162              return( 1 );
163          }
164          if( cur->prev != prv )
165          {
166  #if defined(POLARSSL_MEMORY_DEBUG)
167              polarssl_fprintf( stderr, "FATAL: verification failed: "
168                                        "cur->prev != prv\n" );
169  #endif
170              return( 1 );
171          }
172          prv = cur;
173          cur = cur->next;
174      }
175      return( 0 );
176  }
177  static void *buffer_alloc_malloc( size_t len )
178  {
179      memory_header *new, *cur = heap.first_free;
180      unsigned char *p;
181  #if defined(POLARSSL_MEMORY_BACKTRACE)
182      void *trace_buffer[MAX_BT];
183      size_t trace_cnt;
184  #endif
185      if( heap.buf == NULL || heap.first == NULL )
186          return( NULL );
187      if( len % POLARSSL_MEMORY_ALIGN_MULTIPLE )
188      {
189          len -= len % POLARSSL_MEMORY_ALIGN_MULTIPLE;
190          len += POLARSSL_MEMORY_ALIGN_MULTIPLE;
191      }
192      while( cur != NULL )
193      {
194          if( cur->size >= len )
195              break;
196          cur = cur->next_free;
197      }
198      if( cur == NULL )
199          return( NULL );
200      if( cur->alloc != 0 )
201      {
202  #if defined(POLARSSL_MEMORY_DEBUG)
203          polarssl_fprintf( stderr, "FATAL: block in free_list but allocated "
204                                    "data\n" );
205  #endif
206          polarssl_exit( 1 );
207      }
208  #if defined(POLARSSL_MEMORY_DEBUG)
209      heap.malloc_count++;
210  #endif
211      if( cur->size - len < sizeof(memory_header) +
212                            POLARSSL_MEMORY_ALIGN_MULTIPLE )
213      {
214          cur->alloc = 1;
215          if( cur->prev_free != NULL )
216              cur->prev_free->next_free = cur->next_free;
217          else
218              heap.first_free = cur->next_free;
219          if( cur->next_free != NULL )
220              cur->next_free->prev_free = cur->prev_free;
221          cur->prev_free = NULL;
222          cur->next_free = NULL;
223  #if defined(POLARSSL_MEMORY_DEBUG)
224          heap.total_used += cur->size;
225          if( heap.total_used > heap.maximum_used )
226              heap.maximum_used = heap.total_used;
227  #endif
228  #if defined(POLARSSL_MEMORY_BACKTRACE)
229          trace_cnt = backtrace( trace_buffer, MAX_BT );
230          cur->trace = backtrace_symbols( trace_buffer, trace_cnt );
231          cur->trace_count = trace_cnt;
232  #endif
233          if( ( heap.verify & MEMORY_VERIFY_ALLOC ) && verify_chain() != 0 )
234              polarssl_exit( 1 );
235          return( ( (unsigned char *) cur ) + sizeof(memory_header) );
236      }
237      p = ( (unsigned char *) cur ) + sizeof(memory_header) + len;
238      new = (memory_header *) p;
239      new->size = cur->size - len - sizeof(memory_header);
240      new->alloc = 0;
241      new->prev = cur;
242      new->next = cur->next;
243  #if defined(POLARSSL_MEMORY_BACKTRACE)
244      new->trace = NULL;
245      new->trace_count = 0;
246  #endif
247      new->magic1 = MAGIC1;
248      new->magic2 = MAGIC2;
249      if( new->next != NULL )
250          new->next->prev = new;
251      new->prev_free = cur->prev_free;
252      new->next_free = cur->next_free;
253      if( new->prev_free != NULL )
254          new->prev_free->next_free = new;
255      else
256          heap.first_free = new;
257      if( new->next_free != NULL )
258          new->next_free->prev_free = new;
259      cur->alloc = 1;
260      cur->size = len;
261      cur->next = new;
262      cur->prev_free = NULL;
263      cur->next_free = NULL;
264  #if defined(POLARSSL_MEMORY_DEBUG)
265      heap.header_count++;
266      if( heap.header_count > heap.maximum_header_count )
267          heap.maximum_header_count = heap.header_count;
268      heap.total_used += cur->size;
269      if( heap.total_used > heap.maximum_used )
270          heap.maximum_used = heap.total_used;
271  #endif
272  #if defined(POLARSSL_MEMORY_BACKTRACE)
273      trace_cnt = backtrace( trace_buffer, MAX_BT );
274      cur->trace = backtrace_symbols( trace_buffer, trace_cnt );
275      cur->trace_count = trace_cnt;
276  #endif
277      if( ( heap.verify & MEMORY_VERIFY_ALLOC ) && verify_chain() != 0 )
278          polarssl_exit( 1 );
279      return( ( (unsigned char *) cur ) + sizeof(memory_header) );
280  }
281  static void buffer_alloc_free( void *ptr )
282  {
283      memory_header *hdr, *old = NULL;
284      unsigned char *p = (unsigned char *) ptr;
285      if( ptr == NULL || heap.buf == NULL || heap.first == NULL )
286          return;
287      if( p < heap.buf || p > heap.buf + heap.len )
288      {
289  #if defined(POLARSSL_MEMORY_DEBUG)
290          polarssl_fprintf( stderr, "FATAL: polarssl_free() outside of managed "
291                                    "space\n" );
292  #endif
293          polarssl_exit( 1 );
294      }
295      p -= sizeof(memory_header);
296      hdr = (memory_header *) p;
297      if( verify_header( hdr ) != 0 )
298          polarssl_exit( 1 );
299      if( hdr->alloc != 1 )
300      {
301  #if defined(POLARSSL_MEMORY_DEBUG)
302          polarssl_fprintf( stderr, "FATAL: polarssl_free() on unallocated "
303                                    "data\n" );
304  #endif
305          polarssl_exit( 1 );
306      }
307      hdr->alloc = 0;
308  #if defined(POLARSSL_MEMORY_DEBUG)
309      heap.free_count++;
310      heap.total_used -= hdr->size;
311  #endif
312      if( hdr->prev != NULL && hdr->prev->alloc == 0 )
313      {
314  #if defined(POLARSSL_MEMORY_DEBUG)
315          heap.header_count--;
316  #endif
317          hdr->prev->size += sizeof(memory_header) + hdr->size;
318          hdr->prev->next = hdr->next;
319          old = hdr;
320          hdr = hdr->prev;
321          if( hdr->next != NULL )
322              hdr->next->prev = hdr;
323  #if defined(POLARSSL_MEMORY_BACKTRACE)
324          free( old->trace );
325  #endif
326          memset( old, 0, sizeof(memory_header) );
327      }
328      if( hdr->next != NULL && hdr->next->alloc == 0 )
329      {
330  #if defined(POLARSSL_MEMORY_DEBUG)
331          heap.header_count--;
332  #endif
333          hdr->size += sizeof(memory_header) + hdr->next->size;
334          old = hdr->next;
335          hdr->next = hdr->next->next;
336          if( hdr->prev_free != NULL || hdr->next_free != NULL )
337          {
338              if( hdr->prev_free != NULL )
<span onclick='openModal()' class='match'>339                  hdr->prev_free->next_free = hdr->next_free;
340              else
341                  heap.first_free = hdr->next_free;
342              if( hdr->next_free != NULL )
343                  hdr->next_free->prev_free = hdr->prev_free;
344          }
</span>345          hdr->prev_free = old->prev_free;
346          hdr->next_free = old->next_free;
347          if( hdr->prev_free != NULL )
348              hdr->prev_free->next_free = hdr;
349          else
350              heap.first_free = hdr;
351          if( hdr->next_free != NULL )
352              hdr->next_free->prev_free = hdr;
353          if( hdr->next != NULL )
354              hdr->next->prev = hdr;
355  #if defined(POLARSSL_MEMORY_BACKTRACE)
356          free( old->trace );
357  #endif
358          memset( old, 0, sizeof(memory_header) );
359      }
360      if( old == NULL )
361      {
362          hdr->next_free = heap.first_free;
363          if( heap.first_free != NULL )
364              heap.first_free->prev_free = hdr;
365          heap.first_free = hdr;
366      }
367  #if defined(POLARSSL_MEMORY_BACKTRACE)
368      hdr->trace = NULL;
369      hdr->trace_count = 0;
370  #endif
371      if( ( heap.verify & MEMORY_VERIFY_FREE ) && verify_chain() != 0 )
372          polarssl_exit( 1 );
373  }
374  void memory_buffer_set_verify( int verify )
375  {
376      heap.verify = verify;
377  }
378  int memory_buffer_alloc_verify()
379  {
380      return verify_chain();
381  }
382  #if defined(POLARSSL_MEMORY_DEBUG)
383  void memory_buffer_alloc_status()
384  {
385      polarssl_fprintf( stderr,
386                        "Current use: %zu blocks / %zu bytes, max: %zu blocks / "
387                        "%zu bytes (total %zu bytes), malloc / free: %zu / %zu\n",
388                        heap.header_count, heap.total_used,
389                        heap.maximum_header_count, heap.maximum_used,
390                        heap.maximum_header_count * sizeof( memory_header )
391                        + heap.maximum_used,
392                        heap.malloc_count, heap.free_count );
393      if( heap.first->next == NULL )
394          polarssl_fprintf( stderr, "All memory de-allocated in stack buffer\n" );
395      else
396      {
397          polarssl_fprintf( stderr, "Memory currently allocated:\n" );
398          debug_chain();
399      }
400  }
401  void memory_buffer_alloc_max_get( size_t *max_used, size_t *max_blocks )
402  {
403      *max_used   = heap.maximum_used;
404      *max_blocks = heap.maximum_header_count;
405  }
406  void memory_buffer_alloc_max_reset( void )
407  {
408      heap.maximum_used = 0;
409      heap.maximum_header_count = 0;
410  }
411  void memory_buffer_alloc_cur_get( size_t *cur_used, size_t *cur_blocks )
412  {
413      *cur_used   = heap.total_used;
414      *cur_blocks = heap.header_count;
415  }
416  #endif &bsol;* POLARSSL_MEMORY_DEBUG */
417  #if defined(POLARSSL_THREADING_C)
418  static void *buffer_alloc_malloc_mutexed( size_t len )
419  {
420      void *buf;
421      polarssl_mutex_lock( &heap.mutex );
422      buf = buffer_alloc_malloc( len );
423      polarssl_mutex_unlock( &heap.mutex );
424      return( buf );
425  }
426  static void buffer_alloc_free_mutexed( void *ptr )
427  {
428      polarssl_mutex_lock( &heap.mutex );
429      buffer_alloc_free( ptr );
430      polarssl_mutex_unlock( &heap.mutex );
431  }
432  #endif &bsol;* POLARSSL_THREADING_C */
433  int memory_buffer_alloc_init( unsigned char *buf, size_t len )
434  {
435      memset( &heap, 0, sizeof(buffer_alloc_ctx) );
436      memset( buf, 0, len );
437  #if defined(POLARSSL_THREADING_C)
438      polarssl_mutex_init( &heap.mutex );
439      platform_set_malloc_free( buffer_alloc_malloc_mutexed,
440                                buffer_alloc_free_mutexed );
441  #else
442      platform_set_malloc_free( buffer_alloc_malloc, buffer_alloc_free );
443  #endif
444      if( (size_t) buf % POLARSSL_MEMORY_ALIGN_MULTIPLE )
445      {
446          len -= POLARSSL_MEMORY_ALIGN_MULTIPLE
447               - (size_t) buf % POLARSSL_MEMORY_ALIGN_MULTIPLE;
448          buf += POLARSSL_MEMORY_ALIGN_MULTIPLE
449               - (size_t) buf % POLARSSL_MEMORY_ALIGN_MULTIPLE;
450      }
451      heap.buf = buf;
452      heap.len = len;
453      heap.first = (memory_header *) buf;
454      heap.first->size = len - sizeof(memory_header);
455      heap.first->magic1 = MAGIC1;
456      heap.first->magic2 = MAGIC2;
457      heap.first_free = heap.first;
458      return( 0 );
459  }
460  void memory_buffer_alloc_free()
461  {
462  #if defined(POLARSSL_THREADING_C)
463      polarssl_mutex_free( &heap.mutex );
464  #endif
465      polarssl_zeroize( &heap, sizeof(buffer_alloc_ctx) );
466  }
467  #if defined(POLARSSL_SELF_TEST)
468  static int check_pointer( void *p )
469  {
470      if( p == NULL )
471          return( -1 );
472      if( (size_t) p % POLARSSL_MEMORY_ALIGN_MULTIPLE != 0 )
473          return( -1 );
474      return( 0 );
475  }
476  static int check_all_free( )
477  {
478      if(
479  #if defined(POLARSSL_MEMORY_DEBUG)
480          heap.total_used != 0 ||
481  #endif
482          heap.first != heap.first_free ||
483          (void *) heap.first != (void *) heap.buf )
484      {
485          return( -1 );
486      }
487      return( 0 );
488  }
489  #define TEST_ASSERT( condition )            \
490      if( ! (condition) )                     \
491      {                                       \
492          if( verbose != 0 )                  \
493              polarssl_printf( "failed\n" );  \
494                                              \
495          ret = 1;                            \
496          goto cleanup;                       \
497      }
498  int memory_buffer_alloc_self_test( int verbose )
499  {
500      unsigned char buf[1024];
501      unsigned char *p, *q, *r, *end;
502      int ret = 0;
503      if( verbose != 0 )
504          polarssl_printf( "  MBA test #1 (basic alloc-free cycle): " );
505      memory_buffer_alloc_init( buf, sizeof( buf ) );
506      p = polarssl_malloc( 1 );
507      q = polarssl_malloc( 128 );
508      r = polarssl_malloc( 16 );
509      TEST_ASSERT( check_pointer( p ) == 0 &&
510                   check_pointer( q ) == 0 &&
511                   check_pointer( r ) == 0 );
512      polarssl_free( r );
513      polarssl_free( q );
514      polarssl_free( p );
515      TEST_ASSERT( check_all_free( ) == 0 );
516      end = heap.buf + heap.len;
517      memory_buffer_alloc_free( );
518      if( verbose != 0 )
519          polarssl_printf( "passed\n" );
520      if( verbose != 0 )
521          polarssl_printf( "  MBA test #2 (buf not aligned): " );
522      memory_buffer_alloc_init( buf + 1, sizeof( buf ) - 1 );
523      TEST_ASSERT( heap.buf + heap.len == end );
524      p = polarssl_malloc( 1 );
525      q = polarssl_malloc( 128 );
526      r = polarssl_malloc( 16 );
527      TEST_ASSERT( check_pointer( p ) == 0 &&
528                   check_pointer( q ) == 0 &&
529                   check_pointer( r ) == 0 );
530      polarssl_free( r );
531      polarssl_free( q );
532      polarssl_free( p );
533      TEST_ASSERT( check_all_free( ) == 0 );
534      memory_buffer_alloc_free( );
535      if( verbose != 0 )
536          polarssl_printf( "passed\n" );
537      if( verbose != 0 )
538          polarssl_printf( "  MBA test #3 (full): " );
539      memory_buffer_alloc_init( buf, sizeof( buf ) );
540      p = polarssl_malloc( sizeof( buf ) - sizeof( memory_header ) );
541      TEST_ASSERT( check_pointer( p ) == 0 );
542      TEST_ASSERT( polarssl_malloc( 1 ) == NULL );
543      polarssl_free( p );
544      p = polarssl_malloc( sizeof( buf ) - 2 * sizeof( memory_header ) - 16 );
545      q = polarssl_malloc( 16 );
546      TEST_ASSERT( check_pointer( p ) == 0 && check_pointer( q ) == 0 );
547      TEST_ASSERT( polarssl_malloc( 1 ) == NULL );
548      polarssl_free( q );
549      TEST_ASSERT( polarssl_malloc( 17 ) == NULL );
550      polarssl_free( p );
551      TEST_ASSERT( check_all_free( ) == 0 );
552      memory_buffer_alloc_free( );
553      if( verbose != 0 )
554          polarssl_printf( "passed\n" );
555  cleanup:
556      memory_buffer_alloc_free( );
557      return( ret );
558  }
559  #endif &bsol;* POLARSSL_SELF_TEST */
560  #endif &bsol;* POLARSSL_MEMORY_BUFFER_ALLOC_C */
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from Adafruit_nRF52_Arduino-MDEwOlJlcG9zaXRvcnk3NDM1NDcyOQ==-flat-memory_buffer_alloc.c</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from Adafruit_nRF52_Arduino-MDEwOlJlcG9zaXRvcnk3NDM1NDcyOQ==-flat-memory_buffer_alloc.c</div>
                </div>
                <div class="column column_space"><pre><code>216              cur->prev_free->next_free = cur->next_free;
217          else
218              heap.first_free = cur->next_free;
219          if( cur->next_free != NULL )
220              cur->next_free->prev_free = cur->prev_free;
221          cur->prev_free = NULL;
</pre></code></div>
                <div class="column column_space"><pre><code>339                  hdr->prev_free->next_free = hdr->next_free;
340              else
341                  heap.first_free = hdr->next_free;
342              if( hdr->next_free != NULL )
343                  hdr->next_free->prev_free = hdr->prev_free;
344          }
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    