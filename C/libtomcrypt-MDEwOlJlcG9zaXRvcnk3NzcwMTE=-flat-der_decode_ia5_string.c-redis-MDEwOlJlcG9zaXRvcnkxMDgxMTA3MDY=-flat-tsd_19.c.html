
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 4.678362573099415%, Tokens: 8</h2>
        <div class="column">
            <h3>libtomcrypt-MDEwOlJlcG9zaXRvcnk3NzcwMTE=-flat-der_decode_ia5_string.c</h3>
            <pre><code>1  #include "tomcrypt_private.h"
2  #ifdef LTC_DER
3  int der_decode_ia5_string(const unsigned char *in, unsigned long inlen,
4                                  unsigned char *out, unsigned long *outlen)
5  {
6     unsigned long x, y, len;
7     int           t, err;
8     LTC_ARGCHK(in     != NULL);
9     LTC_ARGCHK(out    != NULL);
10     LTC_ARGCHK(outlen != NULL);
<span onclick='openModal()' class='match'>11     if (inlen < 2) {
12        return CRYPT_INVALID_PACKET;
13     }
14     if ((in[0] & 0x1F) != 0x16) {
15        return CRYPT_INVALID_PACKET;
16     }
</span>17     x = 1;
18     y = inlen - x;
19     if ((err = der_decode_asn1_length(in + x, &y, &len)) != CRYPT_OK) {
20        return err;
21     }
22     x += y;
23     if (len > *outlen) {
24        *outlen = len;
25        return CRYPT_BUFFER_OVERFLOW;
26     }
27     if (len > (inlen - x)) {
28        return CRYPT_INVALID_PACKET;
29     }
30     for (y = 0; y < len; y++) {
31         t = der_ia5_value_decode(in[x++]);
32         if (t == -1) {
33             return CRYPT_INVALID_ARG;
34         }
35         out[y] = t;
36     }
37     *outlen = y;
38     return CRYPT_OK;
39  }
40  #endif
</code></pre>
        </div>
        <div class="column">
            <h3>redis-MDEwOlJlcG9zaXRvcnkxMDgxMTA3MDY=-flat-tsd_19.c</h3>
            <pre><code>1  #define JEMALLOC_TSD_C_
2  #include "jemalloc/internal/jemalloc_preamble.h"
3  #include "jemalloc/internal/jemalloc_internal_includes.h"
4  #include "jemalloc/internal/assert.h"
5  #include "jemalloc/internal/mutex.h"
6  #include "jemalloc/internal/rtree.h"
7  static unsigned ncleanups;
8  static malloc_tsd_cleanup_t cleanups[MALLOC_TSD_CLEANUPS_MAX];
9  JEMALLOC_DIAGNOSTIC_PUSH
10  JEMALLOC_DIAGNOSTIC_IGNORE_MISSING_STRUCT_FIELD_INITIALIZERS
11  #ifdef JEMALLOC_MALLOC_THREAD_CLEANUP
12  JEMALLOC_TSD_TYPE_ATTR(tsd_t) tsd_tls = TSD_INITIALIZER;
13  JEMALLOC_TSD_TYPE_ATTR(bool) JEMALLOC_TLS_MODEL tsd_initialized = false;
14  bool tsd_booted = false;
15  #elif (defined(JEMALLOC_TLS))
16  JEMALLOC_TSD_TYPE_ATTR(tsd_t) tsd_tls = TSD_INITIALIZER;
17  pthread_key_t tsd_tsd;
18  bool tsd_booted = false;
19  #elif (defined(_WIN32))
20  DWORD tsd_tsd;
21  tsd_wrapper_t tsd_boot_wrapper = {false, TSD_INITIALIZER};
22  bool tsd_booted = false;
23  #else
24  struct tsd_init_head_s {
25  	ql_head(tsd_init_block_t) blocks;
26  	malloc_mutex_t lock;
27  };
28  pthread_key_t tsd_tsd;
29  tsd_init_head_t	tsd_init_head = {
30  	ql_head_initializer(blocks),
31  	MALLOC_MUTEX_INITIALIZER
32  };
33  tsd_wrapper_t tsd_boot_wrapper = {
34  	false,
35  	TSD_INITIALIZER
36  };
37  bool tsd_booted = false;
38  #endif
39  JEMALLOC_DIAGNOSTIC_POP
40  typedef ql_head(tsd_t) tsd_list_t;
41  static tsd_list_t tsd_nominal_tsds = ql_head_initializer(tsd_nominal_tsds);
42  static malloc_mutex_t tsd_nominal_tsds_lock;
43  static atomic_u32_t tsd_global_slow_count = ATOMIC_INIT(0);
44  static bool
45  tsd_in_nominal_list(tsd_t *tsd) {
46  	tsd_t *tsd_list;
47  	bool found = false;
48  	malloc_mutex_lock(TSDN_NULL, &tsd_nominal_tsds_lock);
49  	ql_foreach(tsd_list, &tsd_nominal_tsds, TSD_MANGLE(tcache).tsd_link) {
50  		if (tsd == tsd_list) {
51  			found = true;
52  			break;
53  		}
54  	}
55  	malloc_mutex_unlock(TSDN_NULL, &tsd_nominal_tsds_lock);
56  	return found;
57  }
58  static void
59  tsd_add_nominal(tsd_t *tsd) {
60  	assert(!tsd_in_nominal_list(tsd));
61  	assert(tsd_state_get(tsd) <= tsd_state_nominal_max);
62  	ql_elm_new(tsd, TSD_MANGLE(tcache).tsd_link);
63  	malloc_mutex_lock(tsd_tsdn(tsd), &tsd_nominal_tsds_lock);
64  	ql_tail_insert(&tsd_nominal_tsds, tsd, TSD_MANGLE(tcache).tsd_link);
65  	malloc_mutex_unlock(tsd_tsdn(tsd), &tsd_nominal_tsds_lock);
66  }
67  static void
68  tsd_remove_nominal(tsd_t *tsd) {
69  	assert(tsd_in_nominal_list(tsd));
70  	assert(tsd_state_get(tsd) <= tsd_state_nominal_max);
71  	malloc_mutex_lock(tsd_tsdn(tsd), &tsd_nominal_tsds_lock);
72  	ql_remove(&tsd_nominal_tsds, tsd, TSD_MANGLE(tcache).tsd_link);
73  	malloc_mutex_unlock(tsd_tsdn(tsd), &tsd_nominal_tsds_lock);
74  }
75  static void
76  tsd_force_recompute(tsdn_t *tsdn) {
77  	atomic_fence(ATOMIC_RELEASE);
78  	malloc_mutex_lock(tsdn, &tsd_nominal_tsds_lock);
79  	tsd_t *remote_tsd;
80  	ql_foreach(remote_tsd, &tsd_nominal_tsds, TSD_MANGLE(tcache).tsd_link) {
81  		assert(tsd_atomic_load(&remote_tsd->state, ATOMIC_RELAXED)
82  		    <= tsd_state_nominal_max);
83  		tsd_atomic_store(&remote_tsd->state, tsd_state_nominal_recompute,
84  		    ATOMIC_RELAXED);
85  	}
86  	malloc_mutex_unlock(tsdn, &tsd_nominal_tsds_lock);
87  }
88  void
89  tsd_global_slow_inc(tsdn_t *tsdn) {
90  	atomic_fetch_add_u32(&tsd_global_slow_count, 1, ATOMIC_RELAXED);
91  	tsd_force_recompute(tsdn);
92  }
93  void tsd_global_slow_dec(tsdn_t *tsdn) {
94  	atomic_fetch_sub_u32(&tsd_global_slow_count, 1, ATOMIC_RELAXED);
95  	tsd_force_recompute(tsdn);
96  }
97  static bool
98  tsd_local_slow(tsd_t *tsd) {
99  	return !tsd_tcache_enabled_get(tsd)
100  	    || tsd_reentrancy_level_get(tsd) > 0;
101  }
102  bool
103  tsd_global_slow() {
104  	return atomic_load_u32(&tsd_global_slow_count, ATOMIC_RELAXED) > 0;
105  }
106  static uint8_t
107  tsd_state_compute(tsd_t *tsd) {
<span onclick='openModal()' class='match'>108  	if (!tsd_nominal(tsd)) {
109  		return tsd_state_get(tsd);
110  	}
111  	if (malloc_slow || tsd_local_slow(tsd) || tsd_global_slow()) {
112  		return tsd_state_nominal_slow;
113  	} else {
</span>114  		return tsd_state_nominal;
115  	}
116  }
117  void
118  tsd_slow_update(tsd_t *tsd) {
119  	uint8_t old_state;
120  	do {
121  		uint8_t new_state = tsd_state_compute(tsd);
122  		old_state = tsd_atomic_exchange(&tsd->state, new_state,
123  		    ATOMIC_ACQUIRE);
124  	} while (old_state == tsd_state_nominal_recompute);
125  }
126  void
127  tsd_state_set(tsd_t *tsd, uint8_t new_state) {
128  	assert(new_state != tsd_state_nominal_recompute);
129  	uint8_t old_state = tsd_atomic_load(&tsd->state, ATOMIC_RELAXED);
130  	if (old_state > tsd_state_nominal_max) {
131  		assert(!tsd_in_nominal_list(tsd));
132  		tsd_atomic_store(&tsd->state, new_state, ATOMIC_RELAXED);
133  		if (new_state <= tsd_state_nominal_max) {
134  			tsd_add_nominal(tsd);
135  		}
136  	} else {
137  		assert(tsd_in_nominal_list(tsd));
138  		if (new_state > tsd_state_nominal_max) {
139  			tsd_remove_nominal(tsd);
140  			tsd_atomic_store(&tsd->state, new_state,
141  			    ATOMIC_RELAXED);
142  		} else {
143  			tsd_slow_update(tsd);
144  		}
145  	}
146  }
147  static bool
148  tsd_data_init(tsd_t *tsd) {
149  	rtree_ctx_data_init(tsd_rtree_ctxp_get_unsafe(tsd));
150  	*tsd_offset_statep_get(tsd) = config_debug ? 0 :
151  	    (uint64_t)(uintptr_t)tsd;
152  	return tsd_tcache_enabled_data_init(tsd);
153  }
154  static void
155  assert_tsd_data_cleanup_done(tsd_t *tsd) {
156  	assert(!tsd_nominal(tsd));
157  	assert(!tsd_in_nominal_list(tsd));
158  	assert(*tsd_arenap_get_unsafe(tsd) == NULL);
159  	assert(*tsd_iarenap_get_unsafe(tsd) == NULL);
160  	assert(*tsd_arenas_tdata_bypassp_get_unsafe(tsd) == true);
161  	assert(*tsd_arenas_tdatap_get_unsafe(tsd) == NULL);
162  	assert(*tsd_tcache_enabledp_get_unsafe(tsd) == false);
163  	assert(*tsd_prof_tdatap_get_unsafe(tsd) == NULL);
164  }
165  static bool
166  tsd_data_init_nocleanup(tsd_t *tsd) {
167  	assert(tsd_state_get(tsd) == tsd_state_reincarnated ||
168  	    tsd_state_get(tsd) == tsd_state_minimal_initialized);
169  	rtree_ctx_data_init(tsd_rtree_ctxp_get_unsafe(tsd));
170  	*tsd_arenas_tdata_bypassp_get(tsd) = true;
171  	*tsd_tcache_enabledp_get_unsafe(tsd) = false;
172  	*tsd_reentrancy_levelp_get(tsd) = 1;
173  	assert_tsd_data_cleanup_done(tsd);
174  	return false;
175  }
176  tsd_t *
177  tsd_fetch_slow(tsd_t *tsd, bool minimal) {
178  	assert(!tsd_fast(tsd));
179  	if (tsd_state_get(tsd) == tsd_state_nominal_slow) {
180  	} else if (tsd_state_get(tsd) == tsd_state_nominal_recompute) {
181  		tsd_slow_update(tsd);
182  	} else if (tsd_state_get(tsd) == tsd_state_uninitialized) {
183  		if (!minimal) {
184  			if (tsd_booted) {
185  				tsd_state_set(tsd, tsd_state_nominal);
186  				tsd_slow_update(tsd);
187  				tsd_set(tsd);
188  				tsd_data_init(tsd);
189  			}
190  		} else {
191  			tsd_state_set(tsd, tsd_state_minimal_initialized);
192  			tsd_set(tsd);
193  			tsd_data_init_nocleanup(tsd);
194  		}
195  	} else if (tsd_state_get(tsd) == tsd_state_minimal_initialized) {
196  		if (!minimal) {
197  			tsd_state_set(tsd, tsd_state_nominal);
198  			assert(*tsd_reentrancy_levelp_get(tsd) >= 1);
199  			(*tsd_reentrancy_levelp_get(tsd))--;
200  			tsd_slow_update(tsd);
201  			tsd_data_init(tsd);
202  		} else {
203  			assert_tsd_data_cleanup_done(tsd);
204  		}
205  	} else if (tsd_state_get(tsd) == tsd_state_purgatory) {
206  		tsd_state_set(tsd, tsd_state_reincarnated);
207  		tsd_set(tsd);
208  		tsd_data_init_nocleanup(tsd);
209  	} else {
210  		assert(tsd_state_get(tsd) == tsd_state_reincarnated);
211  	}
212  	return tsd;
213  }
214  void *
215  malloc_tsd_malloc(size_t size) {
216  	return a0malloc(CACHELINE_CEILING(size));
217  }
218  void
219  malloc_tsd_dalloc(void *wrapper) {
220  	a0dalloc(wrapper);
221  }
222  #if defined(JEMALLOC_MALLOC_THREAD_CLEANUP) || defined(_WIN32)
223  #ifndef _WIN32
224  JEMALLOC_EXPORT
225  #endif
226  void
227  _malloc_thread_cleanup(void) {
228  	bool pending[MALLOC_TSD_CLEANUPS_MAX], again;
229  	unsigned i;
230  	for (i = 0; i < ncleanups; i++) {
231  		pending[i] = true;
232  	}
233  	do {
234  		again = false;
235  		for (i = 0; i < ncleanups; i++) {
236  			if (pending[i]) {
237  				pending[i] = cleanups[i]();
238  				if (pending[i]) {
239  					again = true;
240  				}
241  			}
242  		}
243  	} while (again);
244  }
245  #endif
246  void
247  malloc_tsd_cleanup_register(bool (*f)(void)) {
248  	assert(ncleanups < MALLOC_TSD_CLEANUPS_MAX);
249  	cleanups[ncleanups] = f;
250  	ncleanups++;
251  }
252  static void
253  tsd_do_data_cleanup(tsd_t *tsd) {
254  	prof_tdata_cleanup(tsd);
255  	iarena_cleanup(tsd);
256  	arena_cleanup(tsd);
257  	arenas_tdata_cleanup(tsd);
258  	tcache_cleanup(tsd);
259  	witnesses_cleanup(tsd_witness_tsdp_get_unsafe(tsd));
260  }
261  void
262  tsd_cleanup(void *arg) {
263  	tsd_t *tsd = (tsd_t *)arg;
264  	switch (tsd_state_get(tsd)) {
265  	case tsd_state_uninitialized:
266  		break;
267  	case tsd_state_minimal_initialized:
268  	case tsd_state_reincarnated:
269  		assert_tsd_data_cleanup_done(tsd);
270  	case tsd_state_nominal:
271  	case tsd_state_nominal_slow:
272  		tsd_do_data_cleanup(tsd);
273  		tsd_state_set(tsd, tsd_state_purgatory);
274  		tsd_set(tsd);
275  		break;
276  	case tsd_state_purgatory:
277  		break;
278  	default:
279  		not_reached();
280  	}
281  #ifdef JEMALLOC_JET
282  	test_callback_t test_callback = *tsd_test_callbackp_get_unsafe(tsd);
283  	int *data = tsd_test_datap_get_unsafe(tsd);
284  	if (test_callback != NULL) {
285  		test_callback(data);
286  	}
287  #endif
288  }
289  tsd_t *
290  malloc_tsd_boot0(void) {
291  	tsd_t *tsd;
292  	ncleanups = 0;
293  	if (malloc_mutex_init(&tsd_nominal_tsds_lock, "tsd_nominal_tsds_lock",
294  	    WITNESS_RANK_OMIT, malloc_mutex_rank_exclusive)) {
295  		return NULL;
296  	}
297  	if (tsd_boot0()) {
298  		return NULL;
299  	}
300  	tsd = tsd_fetch();
301  	*tsd_arenas_tdata_bypassp_get(tsd) = true;
302  	return tsd;
303  }
304  void
305  malloc_tsd_boot1(void) {
306  	tsd_boot1();
307  	tsd_t *tsd = tsd_fetch();
308  	tsd_slow_update(tsd);
309  	*tsd_arenas_tdata_bypassp_get(tsd) = false;
310  }
311  #ifdef _WIN32
312  static BOOL WINAPI
313  _tls_callback(HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpvReserved) {
314  	switch (fdwReason) {
315  #ifdef JEMALLOC_LAZY_LOCK
316  	case DLL_THREAD_ATTACH:
317  		isthreaded = true;
318  		break;
319  #endif
320  	case DLL_THREAD_DETACH:
321  		_malloc_thread_cleanup();
322  		break;
323  	default:
324  		break;
325  	}
326  	return true;
327  }
328  #ifdef read
329  #  undef read
330  #endif
331  #ifdef _MSC_VER
332  #  ifdef _M_IX86
333  #    pragma comment(linker, "/INCLUDE:__tls_used")
334  #    pragma comment(linker, "/INCLUDE:_tls_callback")
335  #  else
336  #    pragma comment(linker, "/INCLUDE:_tls_used")
337  #    pragma comment(linker, "/INCLUDE:" STRINGIFY(tls_callback) )
338  #  endif
339  #  pragma section(".CRT$XLY",long,read)
340  #endif
341  JEMALLOC_SECTION(".CRT$XLY") JEMALLOC_ATTR(used)
342  BOOL	(WINAPI *const tls_callback)(HINSTANCE hinstDLL,
343      DWORD fdwReason, LPVOID lpvReserved) = _tls_callback;
344  #endif
345  #if (!defined(JEMALLOC_MALLOC_THREAD_CLEANUP) && !defined(JEMALLOC_TLS) && \
346      !defined(_WIN32))
347  void *
348  tsd_init_check_recursion(tsd_init_head_t *head, tsd_init_block_t *block) {
349  	pthread_t self = pthread_self();
350  	tsd_init_block_t *iter;
351  	malloc_mutex_lock(TSDN_NULL, &head->lock);
352  	ql_foreach(iter, &head->blocks, link) {
353  		if (iter->thread == self) {
354  			malloc_mutex_unlock(TSDN_NULL, &head->lock);
355  			return iter->data;
356  		}
357  	}
358  	ql_elm_new(block, link);
359  	block->thread = self;
360  	ql_tail_insert(&head->blocks, block, link);
361  	malloc_mutex_unlock(TSDN_NULL, &head->lock);
362  	return NULL;
363  }
364  void
365  tsd_init_finish(tsd_init_head_t *head, tsd_init_block_t *block) {
366  	malloc_mutex_lock(TSDN_NULL, &head->lock);
367  	ql_remove(&head->blocks, block, link);
368  	malloc_mutex_unlock(TSDN_NULL, &head->lock);
369  }
370  #endif
371  void
372  tsd_prefork(tsd_t *tsd) {
373  	malloc_mutex_prefork(tsd_tsdn(tsd), &tsd_nominal_tsds_lock);
374  }
375  void
376  tsd_postfork_parent(tsd_t *tsd) {
377  	malloc_mutex_postfork_parent(tsd_tsdn(tsd), &tsd_nominal_tsds_lock);
378  }
379  void
380  tsd_postfork_child(tsd_t *tsd) {
381  	malloc_mutex_postfork_child(tsd_tsdn(tsd), &tsd_nominal_tsds_lock);
382  	ql_new(&tsd_nominal_tsds);
383  	if (tsd_state_get(tsd) <= tsd_state_nominal_max) {
384  		tsd_add_nominal(tsd);
385  	}
386  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from libtomcrypt-MDEwOlJlcG9zaXRvcnk3NzcwMTE=-flat-der_decode_ia5_string.c</div>
                <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from redis-MDEwOlJlcG9zaXRvcnkxMDgxMTA3MDY=-flat-tsd_19.c</div>
                <div class="column column_space"><pre><code>11     if (inlen < 2) {
12        return CRYPT_INVALID_PACKET;
13     }
14     if ((in[0] & 0x1F) != 0x16) {
15        return CRYPT_INVALID_PACKET;
16     }
</pre></code></div>
                <div class="column column_space"><pre><code>108  	if (!tsd_nominal(tsd)) {
109  		return tsd_state_get(tsd);
110  	}
111  	if (malloc_slow || tsd_local_slow(tsd) || tsd_global_slow()) {
112  		return tsd_state_nominal_slow;
113  	} else {
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    