
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 91, <button onclick='openModal()' class='match'>CODE CLONE</button></h2>
        <div class="column">
            <h3>fftw3-MDEwOlJlcG9zaXRvcnk4ODQzMzg4-flat-mpi-bench.c</h3>
            <pre><code>1  #include &lt;math.h&gt;
2  #include &lt;stdio.h&gt;
3  #include &lt;string.h&gt;
4  #include &quot;fftw3-mpi.h&quot;
5  #include &quot;tests/fftw-bench.h&quot;
6  #if defined(BENCHFFT_SINGLE)
7  #  define BENCH_MPI_TYPE MPI_FLOAT
8  #elif defined(BENCHFFT_LDOUBLE)
9  #  define BENCH_MPI_TYPE MPI_LONG_DOUBLE
10  #elif defined(BENCHFFT_QUAD)
11  #  error MPI quad-precision type is unknown
12  #else
13  #  define BENCH_MPI_TYPE MPI_DOUBLE
14  #endif
15  #if SIZEOF_PTRDIFF_T == SIZEOF_INT
16  #  define FFTW_MPI_PTRDIFF_T MPI_INT
17  #elif SIZEOF_PTRDIFF_T == SIZEOF_LONG
18  #  define FFTW_MPI_PTRDIFF_T MPI_LONG
19  #elif SIZEOF_PTRDIFF_T == SIZEOF_LONG_LONG
20  #  define FFTW_MPI_PTRDIFF_T MPI_LONG_LONG
21  #else
22  #  error MPI type for ptrdiff_t is unknown
23  #  define FFTW_MPI_PTRDIFF_T MPI_LONG
24  #endif
25  static const char *mkversion(void) { return FFTW(version); }
26  static const char *mkcc(void) { return FFTW(cc); }
27  static const char *mkcodelet_optim(void) { return FFTW(codelet_optim); }
28  static const char *mknproc(void) {
29       static char buf[32];
30       int ncpus;
31       MPI_Comm_size(MPI_COMM_WORLD, &amp;ncpus);
32  #ifdef HAVE_SNPRINTF
33       snprintf(buf, 32, &quot;%d&quot;, ncpus);
34  #else
35       sprintf(buf, &quot;%d&quot;, ncpus);
36  #endif
37       return buf;
38  }
39  BEGIN_BENCH_DOC
40  BENCH_DOC(&quot;name&quot;, &quot;fftw3_mpi&quot;)
41  BENCH_DOCF(&quot;version&quot;, mkversion)
42  BENCH_DOCF(&quot;cc&quot;, mkcc)
43  BENCH_DOCF(&quot;codelet-optim&quot;, mkcodelet_optim)
44  BENCH_DOCF(&quot;nproc&quot;, mknproc)
45  END_BENCH_DOC 
46  static int n_pes = 1, my_pe = 0;
47  static int rnk;
48  static ptrdiff_t vn, iNtot, oNtot;
49  static ptrdiff_t *local_ni=0, *local_starti=0;
50  static ptrdiff_t *local_no=0, *local_starto=0;
51  static ptrdiff_t *all_local_ni=0, *all_local_starti=0; &amp;bsol;* n_pes x rnk arrays */
52  static ptrdiff_t *all_local_no=0, *all_local_starto=0; &amp;bsol;* n_pes x rnk arrays */
53  static ptrdiff_t *istrides = 0, *ostrides = 0;
54  static ptrdiff_t *total_ni=0, *total_no=0;
55  static int *isend_cnt = 0, *isend_off = 0; &amp;bsol;* for MPI_Scatterv */
56  static int *orecv_cnt = 0, *orecv_off = 0; &amp;bsol;* for MPI_Gatherv */
57  static bench_real *local_in = 0, *local_out = 0;
58  static bench_real *all_local_in = 0, *all_local_out = 0;
59  static int all_local_in_alloc = 0, all_local_out_alloc = 0;
60  static FFTW(plan) plan_scramble_in = 0, plan_unscramble_out = 0;
61  static void alloc_rnk(int rnk_) {
62       rnk = rnk_;
63       bench_free(local_ni);
64       if (rnk == 0)
65  	  local_ni = 0;
66       else
67  	  local_ni = (ptrdiff_t *) bench_malloc(sizeof(ptrdiff_t) * rnk
68  						* (8 + n_pes * 4));
69       local_starti = local_ni + rnk;
70       local_no = local_ni + 2 * rnk;
71       local_starto = local_ni + 3 * rnk;
72       istrides = local_ni + 4 * rnk;
73       ostrides = local_ni + 5 * rnk;
74       total_ni = local_ni + 6 * rnk;
75       total_no = local_ni + 7 * rnk;
76       all_local_ni = local_ni + 8 * rnk;
77       all_local_starti = local_ni + (8 + n_pes) * rnk;
78       all_local_no = local_ni + (8 + 2 * n_pes) * rnk;
79       all_local_starto = local_ni + (8 + 3 * n_pes) * rnk;
80  }
81  static void setup_gather_scatter(void)
82  {
83       int i, j;
84       ptrdiff_t off;
85       MPI_Gather(local_ni, rnk, FFTW_MPI_PTRDIFF_T,
86  		all_local_ni, rnk, FFTW_MPI_PTRDIFF_T,
87  		0, MPI_COMM_WORLD);
88       MPI_Bcast(all_local_ni, rnk*n_pes, FFTW_MPI_PTRDIFF_T, 0, MPI_COMM_WORLD);
89       MPI_Gather(local_starti, rnk, FFTW_MPI_PTRDIFF_T,
90  		all_local_starti, rnk, FFTW_MPI_PTRDIFF_T,
91  		0, MPI_COMM_WORLD);
92       MPI_Bcast(all_local_starti, rnk*n_pes, FFTW_MPI_PTRDIFF_T, 0, MPI_COMM_WORLD);
93       MPI_Gather(local_no, rnk, FFTW_MPI_PTRDIFF_T,
94  		all_local_no, rnk, FFTW_MPI_PTRDIFF_T,
95  		0, MPI_COMM_WORLD);
96       MPI_Bcast(all_local_no, rnk*n_pes, FFTW_MPI_PTRDIFF_T, 0, MPI_COMM_WORLD);
97       MPI_Gather(local_starto, rnk, FFTW_MPI_PTRDIFF_T,
98  		all_local_starto, rnk, FFTW_MPI_PTRDIFF_T,
99  		0, MPI_COMM_WORLD);
100       MPI_Bcast(all_local_starto, rnk*n_pes, FFTW_MPI_PTRDIFF_T, 0, MPI_COMM_WORLD);
101       off = 0;
102       for (i = 0; i &lt; n_pes; ++i) {
103  	  ptrdiff_t N = vn;
104  	  for (j = 0; j &lt; rnk; ++j)
105  	       N *= all_local_ni[i * rnk + j];
106  	  isend_cnt[i] = N;
107  	  isend_off[i] = off;
108  	  off += N;
109       }
110       iNtot = off;
111       all_local_in_alloc = 1;
112       istrides[rnk - 1] = vn;
113       for (j = rnk - 2; j &gt;= 0; --j)
114  	  istrides[j] = total_ni[j + 1] * istrides[j + 1];
115       off = 0;
116       for (i = 0; i &lt; n_pes; ++i) {
117  	  ptrdiff_t N = vn;
118  	  for (j = 0; j &lt; rnk; ++j)
119  	       N *= all_local_no[i * rnk + j];
120  	  orecv_cnt[i] = N;
121  	  orecv_off[i] = off;
122  	  off += N;
123       }
124       oNtot = off;
125       all_local_out_alloc = 1;
126       ostrides[rnk - 1] = vn;
127       for (j = rnk - 2; j &gt;= 0; --j)
128  	  ostrides[j] = total_no[j + 1] * ostrides[j + 1];
129  }
130  static void copy_block_out(const bench_real *in,
131  			   int rnk, ptrdiff_t *n, ptrdiff_t *start, 
132  			   ptrdiff_t is, ptrdiff_t *os, ptrdiff_t vn,
133  			   bench_real *out)
134  {
135       ptrdiff_t i;
136       if (rnk == 0) { 
137  	  for (i = 0; i &lt; vn; ++i)
138  	       out[i] = in[i];
139       }
140       else if (rnk == 1) { &amp;bsol;* this case is just an optimization */
141  	  ptrdiff_t j;
142  	  out += start[0] * os[0];
143  	  for (j = 0; j &lt; n[0]; ++j) {
144  	       for (i = 0; i &lt; vn; ++i)
145  		    out[i] = in[i];
146  	       in += is;
147  	       out += os[0];
148  	  }
149       }
150       else {
151  	  for (i = 0; i &lt; n[rnk - 1]; ++i) 
152  	       copy_block_out(in + i * is,
153  			      rnk - 1, n, start, is * n[rnk - 1], os, vn,
154  			      out + (start[rnk - 1] + i) * os[rnk - 1]);
155       }
156  }
157  static void copy_block_in(bench_real *in,
158  			  int rnk, ptrdiff_t *n, ptrdiff_t *start, 
159  			  ptrdiff_t is, ptrdiff_t *os, ptrdiff_t vn,
160  			  const bench_real *out)
161  {
162       ptrdiff_t i;
163       if (rnk == 0) { 
164  	  for (i = 0; i &lt; vn; ++i)
165  	       in[i] = out[i];
166       }
167       else if (rnk == 1) { &amp;bsol;* this case is just an optimization */
168  	  ptrdiff_t j;
169  	  out += start[0] * os[0];
170  	  for (j = 0; j &lt; n[0]; ++j) {
171  	       for (i = 0; i &lt; vn; ++i)
172  		    in[i] = out[i];
173  	       in += is;
174  	       out += os[0];
175  	  }
176       }
177       else {
178  	  for (i = 0; i &lt; n[rnk - 1]; ++i) 
179  	       copy_block_in(in + i * is,
180  			     rnk - 1, n, start, is * n[rnk - 1], os, vn,
181  			     out + (start[rnk - 1] + i) * os[rnk - 1]);
182       }
183  }
184  static void do_scatter_in(bench_real *in)
185  {
186       bench_real *ali;
187       int i;
188       if (all_local_in_alloc) {
189            bench_free(all_local_in);
190  	  all_local_in = (bench_real*) bench_malloc(iNtot*sizeof(bench_real));
191  	  all_local_in_alloc = 0;
192       }
193       ali = all_local_in;
194       for (i = 0; i &lt; n_pes; ++i) {
195  	  copy_block_in(ali,
196  			rnk, all_local_ni + i * rnk, 
197  			all_local_starti + i * rnk,
198  			vn, istrides, vn,
199  			in);
200  	  ali += isend_cnt[i];
201       }
202       MPI_Scatterv(all_local_in, isend_cnt, isend_off, BENCH_MPI_TYPE,
203  		  local_in, isend_cnt[my_pe], BENCH_MPI_TYPE,
204  		  0, MPI_COMM_WORLD);
205  }
206  static void do_gather_out(bench_real *out)
207  {
208       bench_real *alo;
209       int i;
210       if (all_local_out_alloc) {
211            bench_free(all_local_out);
212  	  all_local_out = (bench_real*) bench_malloc(oNtot*sizeof(bench_real));
213  	  all_local_out_alloc = 0;
214       }
215       MPI_Gatherv(local_out, orecv_cnt[my_pe], BENCH_MPI_TYPE,
216  		 all_local_out, orecv_cnt, orecv_off, BENCH_MPI_TYPE,
217  		 0, MPI_COMM_WORLD);
218       MPI_Bcast(all_local_out, oNtot, BENCH_MPI_TYPE, 0, MPI_COMM_WORLD);
219       alo = all_local_out;
220       for (i = 0; i &lt; n_pes; ++i) {
221  	  copy_block_out(alo,
222  			 rnk, all_local_no + i * rnk, 
223  			 all_local_starto + i * rnk,
224  			 vn, ostrides, vn,
225  			 out);
226  	  alo += orecv_cnt[i];
227       }
228  }
229  static void alloc_local(ptrdiff_t nreal, int inplace)
230  {
231       bench_free(local_in);
232       if (local_out != local_in) bench_free(local_out);
233       local_in = local_out = 0;
234       if (nreal &gt; 0) {
235  	  ptrdiff_t i;
236  	  local_in = (bench_real*) bench_malloc(nreal * sizeof(bench_real));
237  	  if (inplace)
238  	       local_out = local_in;
239  	  else
240  	       local_out = (bench_real*) bench_malloc(nreal * sizeof(bench_real));
241  	  for (i = 0; i &lt; nreal; ++i) local_in[i] = local_out[i] = 0.0;
242       }
243  }
244  void after_problem_rcopy_from(bench_problem *p, bench_real *ri)
245  {
246       UNUSED(p);
247       do_scatter_in(ri);
248       if (plan_scramble_in) FFTW(execute)(plan_scramble_in);
249  }
250  void after_problem_rcopy_to(bench_problem *p, bench_real *ro)
251  {
252       UNUSED(p);
253       if (plan_unscramble_out) FFTW(execute)(plan_unscramble_out);
254       do_gather_out(ro);
255  }
256  void after_problem_ccopy_from(bench_problem *p, bench_real *ri, bench_real *ii)
257  {
258       UNUSED(ii);
259       after_problem_rcopy_from(p, ri);
260  }
261  void after_problem_ccopy_to(bench_problem *p, bench_real *ro, bench_real *io)
262  {
263       UNUSED(io);
264       after_problem_rcopy_to(p, ro);
265  }
266  void after_problem_hccopy_from(bench_problem *p, bench_real *ri, bench_real *ii)
267  {
268       UNUSED(ii);
269       after_problem_rcopy_from(p, ri);
270  }
271  void after_problem_hccopy_to(bench_problem *p, bench_real *ro, bench_real *io)
272  {
273       UNUSED(io);
274       after_problem_rcopy_to(p, ro);
275  }
276  static FFTW(plan) mkplan_transpose_local(ptrdiff_t nx, ptrdiff_t ny, 
277  					 ptrdiff_t vn, 
278  					 bench_real *in, bench_real *out)
279  {
280       FFTW(iodim64) hdims[3];
281       FFTW(r2r_kind) k[3];
282       FFTW(plan) pln;
283       hdims[0].n = nx;
284       hdims[0].is = ny * vn;
285       hdims[0].os = vn;
286       hdims[1].n = ny;
287       hdims[1].is = vn;
288       hdims[1].os = nx * vn;
289       hdims[2].n = vn;
290       hdims[2].is = 1;
291       hdims[2].os = 1;
292       k[0] = k[1] = k[2] = FFTW_R2HC;
293       pln = FFTW(plan_guru64_r2r)(0, 0, 3, hdims, in, out, k, FFTW_ESTIMATE);
294       BENCH_ASSERT(pln != 0);
295       return pln;
296  }
297  static int tensor_rowmajor_transposedp(bench_tensor *t)
298  {
299       bench_iodim *d;
300       int i;
301       BENCH_ASSERT(BENCH_FINITE_RNK(t-&gt;rnk));
302       if (t-&gt;rnk &lt; 2)
303  	  return 0;
304       d = t-&gt;dims;
305       if (d[0].is != d[1].is * d[1].n
306  	 || d[0].os != d[1].is
307  	 || d[1].os != d[0].os * d[0].n)
308  	  return 0;
309       if (t-&gt;rnk &gt; 2 &amp;&amp; d[1].is != d[2].is * d[2].n)
310  	  return 0;
311       for (i = 2; i + 1 &lt; t-&gt;rnk; ++i) {
312            d = t-&gt;dims + i;
313            if (d[0].is != d[1].is * d[1].n
314  	      || d[0].os != d[1].os * d[1].n)
315                 return 0;
316       }
317       if (t-&gt;rnk &gt; 2 &amp;&amp; t-&gt;dims[t-&gt;rnk-1].is != t-&gt;dims[t-&gt;rnk-1].os)
318  	  return 0;
319       return 1;
320  }
321  static int tensor_contiguousp(bench_tensor *t, int s)
322  {
323       return (t-&gt;dims[t-&gt;rnk-1].is == s
324  	     &amp;&amp; ((tensor_rowmajorp(t) &amp;&amp; 
325  		  t-&gt;dims[t-&gt;rnk-1].is == t-&gt;dims[t-&gt;rnk-1].os)
326  		 || tensor_rowmajor_transposedp(t)));
327  }
328  static FFTW(plan) mkplan_complex(bench_problem *p, unsigned flags)
329  {
330       FFTW(plan) pln = 0;
331       int i; 
332       ptrdiff_t ntot;
333       vn = p-&gt;vecsz-&gt;rnk == 1 ? p-&gt;vecsz-&gt;dims[0].n : 1;
334       if (p-&gt;sz-&gt;rnk &lt; 1
335  	 || p-&gt;split
336  	 || !tensor_contiguousp(p-&gt;sz, vn)
337  	 || tensor_rowmajor_transposedp(p-&gt;sz)
338  	 || p-&gt;vecsz-&gt;rnk &gt; 1
339  	 || (p-&gt;vecsz-&gt;rnk == 1 &amp;&amp; (p-&gt;vecsz-&gt;dims[0].is != 1
340  				    || p-&gt;vecsz-&gt;dims[0].os != 1)))
341  	  return 0;
342       alloc_rnk(p-&gt;sz-&gt;rnk);
343       for (i = 0; i &lt; rnk; ++i) {
344  	  total_ni[i] = total_no[i] = p-&gt;sz-&gt;dims[i].n;
345  	  local_ni[i] = local_no[i] = total_ni[i];
346  	  local_starti[i] = local_starto[i] = 0;
347       }
348       if (rnk &gt; 1) {
349  	  ptrdiff_t n, start, nT, startT;
350  	  ntot = FFTW(mpi_local_size_many_transposed)
351  	       (p-&gt;sz-&gt;rnk, total_ni, vn,
352  		FFTW_MPI_DEFAULT_BLOCK, FFTW_MPI_DEFAULT_BLOCK,
353  		MPI_COMM_WORLD,
354  		&amp;n, &amp;start, &amp;nT, &amp;startT);
355  	  if  (flags &amp; FFTW_MPI_TRANSPOSED_IN) {
356  	       local_ni[1] = nT;
357  	       local_starti[1] = startT;
358  	  }
359  	  else {
360  	       local_ni[0] = n;
361  	       local_starti[0] = start;
362  	  }
363  	  if  (flags &amp; FFTW_MPI_TRANSPOSED_OUT) {
364  	       local_no[1] = nT;
365  	       local_starto[1] = startT;
366  	  }
367  	  else {
368  	       local_no[0] = n;
369  	       local_starto[0] = start;
370  	  }
371       }
372       else if (rnk == 1) {
373  	  ntot = FFTW(mpi_local_size_many_1d)
374  	       (total_ni[0], vn, MPI_COMM_WORLD, p-&gt;sign, flags,
375  		local_ni, local_starti, local_no, local_starto);
376       }
377       alloc_local(ntot * 2, p-&gt;in == p-&gt;out);
378       pln = FFTW(mpi_plan_many_dft)(p-&gt;sz-&gt;rnk, total_ni, vn, 
379  				   FFTW_MPI_DEFAULT_BLOCK,
380  				   FFTW_MPI_DEFAULT_BLOCK,
381  				   (FFTW(complex) *) local_in, 
382  				   (FFTW(complex) *) local_out,
383  				   MPI_COMM_WORLD, p-&gt;sign, flags);
384       vn *= 2;
385       if (rnk &gt; 1) {
386  	  ptrdiff_t nrest = 1;
387  	  for (i = 2; i &lt; rnk; ++i) nrest *= p-&gt;sz-&gt;dims[i].n;
388  	  if (flags &amp; FFTW_MPI_TRANSPOSED_IN)
389  	       plan_scramble_in = mkplan_transpose_local(
390  		    p-&gt;sz-&gt;dims[0].n, local_ni[1], vn * nrest,
391  		    local_in, local_in);
392  	  if (flags &amp; FFTW_MPI_TRANSPOSED_OUT)
393  	       plan_unscramble_out = mkplan_transpose_local(
394  		    local_no[1], p-&gt;sz-&gt;dims[0].n, vn * nrest,
395  		    local_out, local_out);
396       }
397       return pln;
398  }
399  static int tensor_real_contiguousp(bench_tensor *t, int sign, int s)
400  {
401       return (t-&gt;dims[t-&gt;rnk-1].is == s
402  	     &amp;&amp; ((tensor_real_rowmajorp(t, sign, 1) &amp;&amp; 
403  		  t-&gt;dims[t-&gt;rnk-1].is == t-&gt;dims[t-&gt;rnk-1].os)));
404  }
405  static FFTW(plan) mkplan_real(bench_problem *p, unsigned flags)
406  {
407       FFTW(plan) pln = 0;
408       int i; 
409       ptrdiff_t ntot;
410       vn = p-&gt;vecsz-&gt;rnk == 1 ? p-&gt;vecsz-&gt;dims[0].n : 1;
411       if (p-&gt;sz-&gt;rnk &lt; 2
412  	 || p-&gt;split
413  	 || !tensor_real_contiguousp(p-&gt;sz, p-&gt;sign, vn)
414  	 || tensor_rowmajor_transposedp(p-&gt;sz)
415  	 || p-&gt;vecsz-&gt;rnk &gt; 1
416  	 || (p-&gt;vecsz-&gt;rnk == 1 &amp;&amp; (p-&gt;vecsz-&gt;dims[0].is != 1
<span onclick='openModal()' class='match'>417  				    || p-&gt;vecsz-&gt;dims[0].os != 1)))
418  	  return 0;
419       alloc_rnk(p-&gt;sz-&gt;rnk);
420       for (i = 0; i &lt; rnk; ++i) {
421  	  total_ni[i] = total_no[i] = p-&gt;sz-&gt;dims[i].n;
422  	  local_ni[i] = local_no[i] = total_ni[i];
423  	  local_starti[i] = local_starto[i] = 0;
424       }
425       local_ni[rnk-1] = local_no[rnk-1] = total_ni[rnk-1] = total_no[rnk-1] 
</span>426  	  = p-&gt;sz-&gt;dims[rnk-1].n / 2 + 1;
427       {
428  	  ptrdiff_t n, start, nT, startT;
429  	  ntot = FFTW(mpi_local_size_many_transposed)
430  	       (p-&gt;sz-&gt;rnk, total_ni, vn,
431  		FFTW_MPI_DEFAULT_BLOCK, FFTW_MPI_DEFAULT_BLOCK,
432  		MPI_COMM_WORLD,
433  		&amp;n, &amp;start, &amp;nT, &amp;startT);
434  	  if  (flags &amp; FFTW_MPI_TRANSPOSED_IN) {
435  	       local_ni[1] = nT;
436  	       local_starti[1] = startT;
437  	  }
438  	  else {
439  	       local_ni[0] = n;
440  	       local_starti[0] = start;
441  	  }
442  	  if  (flags &amp; FFTW_MPI_TRANSPOSED_OUT) {
443  	       local_no[1] = nT;
444  	       local_starto[1] = startT;
445  	  }
446  	  else {
447  	       local_no[0] = n;
448  	       local_starto[0] = start;
449  	  }
450       }
451       alloc_local(ntot * 2, p-&gt;in == p-&gt;out);
452       total_ni[rnk - 1] = p-&gt;sz-&gt;dims[rnk - 1].n;
453       if (p-&gt;sign &lt; 0)
454  	  pln = FFTW(mpi_plan_many_dft_r2c)(p-&gt;sz-&gt;rnk, total_ni, vn, 
455  					    FFTW_MPI_DEFAULT_BLOCK,
456  					    FFTW_MPI_DEFAULT_BLOCK,
457  					    local_in, 
458  					    (FFTW(complex) *) local_out,
459  					    MPI_COMM_WORLD, flags);
460       else
461  	  pln = FFTW(mpi_plan_many_dft_c2r)(p-&gt;sz-&gt;rnk, total_ni, vn, 
462  					    FFTW_MPI_DEFAULT_BLOCK,
463  					    FFTW_MPI_DEFAULT_BLOCK,
464  					    (FFTW(complex) *) local_in, 
465  					    local_out,
466  					    MPI_COMM_WORLD, flags);
467       total_ni[rnk - 1] = p-&gt;sz-&gt;dims[rnk - 1].n / 2 + 1;
468       vn *= 2;
469       {
470  	  ptrdiff_t nrest = 1;
471  	  for (i = 2; i &lt; rnk; ++i) nrest *= total_ni[i];
472  	  if (flags &amp; FFTW_MPI_TRANSPOSED_IN)
473  	       plan_scramble_in = mkplan_transpose_local(
474  		    total_ni[0], local_ni[1], vn * nrest,
475  		    local_in, local_in);
476  	  if (flags &amp; FFTW_MPI_TRANSPOSED_OUT)
477  	       plan_unscramble_out = mkplan_transpose_local(
478  		    local_no[1], total_ni[0], vn * nrest,
479  		    local_out, local_out);
480       }
481       return pln;
482  }
483  static FFTW(plan) mkplan_transpose(bench_problem *p, unsigned flags)
484  {
485       ptrdiff_t ntot, nx, ny;
486       int ix=0, iy=1, i;
487       const bench_iodim *d = p-&gt;vecsz-&gt;dims;
488       FFTW(plan) pln;
489       if (p-&gt;vecsz-&gt;rnk == 3) {
490  	  for (i = 0; i &lt; 3; ++i)
491  	       if (d[i].is == 1 &amp;&amp; d[i].os == 1) {
492  		    vn = d[i].n;
493  		    ix = (i + 1) % 3;
494  		    iy = (i + 2) % 3;
495  		    break;
496  	       }
497  	  if (i == 3) return 0;
498       }
499       else {
500  	  vn = 1;
501  	  ix = 0;
502  	  iy = 1;
503       }
504       if (d[ix].is == d[iy].n * vn &amp;&amp; d[ix].os == vn
505  	 &amp;&amp; d[iy].os == d[ix].n * vn &amp;&amp; d[iy].is == vn) {
506  	  nx = d[ix].n;
507  	  ny = d[iy].n;
508       }
509       else if (d[iy].is == d[ix].n * vn &amp;&amp; d[iy].os == vn
510  	      &amp;&amp; d[ix].os == d[iy].n * vn &amp;&amp; d[ix].is == vn) {
511  	  nx = d[iy].n;
512  	  ny = d[ix].n;
513       }
514       else
515  	  return 0;
516       alloc_rnk(2);
517       ntot = vn * FFTW(mpi_local_size_2d_transposed)(nx, ny, MPI_COMM_WORLD,
518  						    &amp;local_ni[0], 
519  						    &amp;local_starti[0],
520  						    &amp;local_no[0], 
521  						    &amp;local_starto[0]);
522       local_ni[1] = ny;
523       local_starti[1] = 0;
524       local_no[1] = nx;
525       local_starto[1] = 0;
526       total_ni[0] = nx; total_ni[1] = ny;
527       total_no[1] = nx; total_no[0] = ny;
528       alloc_local(ntot, p-&gt;in == p-&gt;out);
529       pln = FFTW(mpi_plan_many_transpose)(nx, ny, vn,
530  					 FFTW_MPI_DEFAULT_BLOCK,
531  					 FFTW_MPI_DEFAULT_BLOCK,
532  					 local_in, local_out,
533  					 MPI_COMM_WORLD, flags);
534       if (flags &amp; FFTW_MPI_TRANSPOSED_IN)
535  	  plan_scramble_in = mkplan_transpose_local(local_ni[0], ny, vn,
536  						    local_in, local_in);
537       if (flags &amp; FFTW_MPI_TRANSPOSED_OUT)
538  	  plan_unscramble_out = mkplan_transpose_local
539  	       (nx, local_no[0], vn, local_out, local_out);
540  #if 0
541       if (pln &amp;&amp; vn == 1) {
542  	  int i, j;
543  	  bench_real *ri = (bench_real *) p-&gt;in;
544  	  bench_real *ro = (bench_real *) p-&gt;out;
545  	  if (!ri || !ro) return pln;
546  	  setup_gather_scatter();
547  	  for (i = 0; i &lt; nx * ny; ++i)
548  	       ri[i] = i;
549  	  after_problem_rcopy_from(p, ri);
550  	  FFTW(execute)(pln);
551  	  after_problem_rcopy_to(p, ro);
552  	  if (my_pe == 0) {
553  	       for (i = 0; i &lt; nx; ++i) {
554  		    for (j = 0; j &lt; ny; ++j)
555  			 printf(&quot;  %3g&quot;, ro[j * nx + i]);
556  		    printf(&quot;\n&quot;);
557  	       }
558  	  }
559       }
560  #endif
561       return pln;
562  }
563  static FFTW(plan) mkplan_r2r(bench_problem *p, unsigned flags)
564  {
565       FFTW(plan) pln = 0;
566       int i; 
567       ptrdiff_t ntot;
568       FFTW(r2r_kind) *k;
569       if ((p-&gt;sz-&gt;rnk == 0 || (p-&gt;sz-&gt;rnk == 1 &amp;&amp; p-&gt;sz-&gt;dims[0].n == 1))
570  	 &amp;&amp; p-&gt;vecsz-&gt;rnk &gt;= 2 &amp;&amp; p-&gt;vecsz-&gt;rnk &lt;= 3)
571  	  return mkplan_transpose(p, flags);
572       vn = p-&gt;vecsz-&gt;rnk == 1 ? p-&gt;vecsz-&gt;dims[0].n : 1;
573       if (p-&gt;sz-&gt;rnk &lt; 1
574  	 || p-&gt;split
575  	 || !tensor_contiguousp(p-&gt;sz, vn)
576  	 || tensor_rowmajor_transposedp(p-&gt;sz)
577  	 || p-&gt;vecsz-&gt;rnk &gt; 1
578  	 || (p-&gt;vecsz-&gt;rnk == 1 &amp;&amp; (p-&gt;vecsz-&gt;dims[0].is != 1
579  				    || p-&gt;vecsz-&gt;dims[0].os != 1)))
580  	  return 0;
581       alloc_rnk(p-&gt;sz-&gt;rnk);
582       for (i = 0; i &lt; rnk; ++i) {
583  	  total_ni[i] = total_no[i] = p-&gt;sz-&gt;dims[i].n;
584  	  local_ni[i] = local_no[i] = total_ni[i];
585  	  local_starti[i] = local_starto[i] = 0;
586       }
587       if (rnk &gt; 1) {
588  	  ptrdiff_t n, start, nT, startT;
589  	  ntot = FFTW(mpi_local_size_many_transposed)
590  	       (p-&gt;sz-&gt;rnk, total_ni, vn,
591  		FFTW_MPI_DEFAULT_BLOCK, FFTW_MPI_DEFAULT_BLOCK,
592  		MPI_COMM_WORLD,
593  		&amp;n, &amp;start, &amp;nT, &amp;startT);
594  	  if  (flags &amp; FFTW_MPI_TRANSPOSED_IN) {
595  	       local_ni[1] = nT;
596  	       local_starti[1] = startT;
597  	  }
598  	  else {
599  	       local_ni[0] = n;
600  	       local_starti[0] = start;
601  	  }
602  	  if  (flags &amp; FFTW_MPI_TRANSPOSED_OUT) {
603  	       local_no[1] = nT;
604  	       local_starto[1] = startT;
605  	  }
606  	  else {
607  	       local_no[0] = n;
608  	       local_starto[0] = start;
609  	  }
610       }
611       else if (rnk == 1) {
612  	  ntot = FFTW(mpi_local_size_many_1d)
613  	       (total_ni[0], vn, MPI_COMM_WORLD, p-&gt;sign, flags,
614  		local_ni, local_starti, local_no, local_starto);
615       }
616       alloc_local(ntot, p-&gt;in == p-&gt;out);
617       k = (FFTW(r2r_kind) *) bench_malloc(sizeof(FFTW(r2r_kind)) * p-&gt;sz-&gt;rnk);
618       for (i = 0; i &lt; p-&gt;sz-&gt;rnk; ++i)
619  	  switch (p-&gt;k[i]) {
620  	      case R2R_R2HC: k[i] = FFTW_R2HC; break;
621  	      case R2R_HC2R: k[i] = FFTW_HC2R; break;
622  	      case R2R_DHT: k[i] = FFTW_DHT; break;
623  	      case R2R_REDFT00: k[i] = FFTW_REDFT00; break;
624  	      case R2R_REDFT01: k[i] = FFTW_REDFT01; break;
625  	      case R2R_REDFT10: k[i] = FFTW_REDFT10; break;
626  	      case R2R_REDFT11: k[i] = FFTW_REDFT11; break;
627  	      case R2R_RODFT00: k[i] = FFTW_RODFT00; break;
628  	      case R2R_RODFT01: k[i] = FFTW_RODFT01; break;
629  	      case R2R_RODFT10: k[i] = FFTW_RODFT10; break;
630  	      case R2R_RODFT11: k[i] = FFTW_RODFT11; break;
631  	      default: BENCH_ASSERT(0);
632  	  }
633       pln = FFTW(mpi_plan_many_r2r)(p-&gt;sz-&gt;rnk, total_ni, vn, 
634  				   FFTW_MPI_DEFAULT_BLOCK,
635  				   FFTW_MPI_DEFAULT_BLOCK,
636  				   local_in, local_out,
637  				   MPI_COMM_WORLD, k, flags);
638       bench_free(k);
639       if (rnk &gt; 1) {
640  	  ptrdiff_t nrest = 1;
641  	  for (i = 2; i &lt; rnk; ++i) nrest *= p-&gt;sz-&gt;dims[i].n;
642  	  if (flags &amp; FFTW_MPI_TRANSPOSED_IN)
643  	       plan_scramble_in = mkplan_transpose_local(
644  		    p-&gt;sz-&gt;dims[0].n, local_ni[1], vn * nrest,
645  		    local_in, local_in);
646  	  if (flags &amp; FFTW_MPI_TRANSPOSED_OUT)
647  	       plan_unscramble_out = mkplan_transpose_local(
648  		    local_no[1], p-&gt;sz-&gt;dims[0].n, vn * nrest,
649  		    local_out, local_out);
650       }
651       return pln;
652  }
653  FFTW(plan) mkplan(bench_problem *p, unsigned flags)
654  {
655       FFTW(plan) pln = 0;
656       FFTW(destroy_plan)(plan_scramble_in); plan_scramble_in = 0;
657       FFTW(destroy_plan)(plan_unscramble_out); plan_unscramble_out = 0;
658       if (p-&gt;scrambled_in) {
659  	  if (p-&gt;sz-&gt;rnk == 1 &amp;&amp; p-&gt;sz-&gt;dims[0].n != 1) 
660  	       flags |= FFTW_MPI_SCRAMBLED_IN;
661  	  else
662  	       flags |= FFTW_MPI_TRANSPOSED_IN;
663       }
664       if (p-&gt;scrambled_out) {
665  	  if (p-&gt;sz-&gt;rnk == 1 &amp;&amp; p-&gt;sz-&gt;dims[0].n != 1) 
666  	       flags |= FFTW_MPI_SCRAMBLED_OUT;
667  	  else
668  	       flags |= FFTW_MPI_TRANSPOSED_OUT;
669       }
670       switch (p-&gt;kind) {
671           case PROBLEM_COMPLEX: 
672  	      pln =mkplan_complex(p, flags);
673  	      break;
674           case PROBLEM_REAL: 
675  	      pln = mkplan_real(p, flags);
676  	      break;
677           case PROBLEM_R2R:
678  	      pln = mkplan_r2r(p, flags);
679  	      break;
680           default: BENCH_ASSERT(0);
681       }
682       if (pln) setup_gather_scatter();
683       return pln;
684  }
685  void main_init(int *argc, char ***argv)
686  {
687  #ifdef HAVE_SMP
688  # if MPI_VERSION &gt;= 2 &amp;bsol;* for MPI_Init_thread */
689       int provided;
690       MPI_Init_thread(argc, argv, MPI_THREAD_FUNNELED, &amp;provided);
691       threads_ok = provided &gt;= MPI_THREAD_FUNNELED;
692  # else
693       MPI_Init(argc, argv);
694       threads_ok = 0;
695  # endif
696  #else
697       MPI_Init(argc, argv);
698  #endif
699       MPI_Comm_rank(MPI_COMM_WORLD, &amp;my_pe);
700       MPI_Comm_size(MPI_COMM_WORLD, &amp;n_pes);
701       if (my_pe != 0) verbose = -999;
702       no_speed_allocation = 1; &amp;bsol;* so we can benchmark transforms &gt; memory */
703       always_pad_real = 1; &amp;bsol;* out-of-place real transforms are padded */
704       isend_cnt = (int *) bench_malloc(sizeof(int) * n_pes);
705       isend_off = (int *) bench_malloc(sizeof(int) * n_pes);
706       orecv_cnt = (int *) bench_malloc(sizeof(int) * n_pes);
707       orecv_off = (int *) bench_malloc(sizeof(int) * n_pes);
708  #ifdef HAVE_SMP
709       if (threads_ok) { BENCH_ASSERT(FFTW(init_threads)()); }
710  #endif
711       FFTW(mpi_init)();
712  }
713  void initial_cleanup(void)
714  {
715       alloc_rnk(0);
716       alloc_local(0, 0);
717       bench_free(all_local_in); all_local_in = 0;
718       bench_free(all_local_out); all_local_out = 0;
719       bench_free(isend_off); isend_off = 0;
720       bench_free(isend_cnt); isend_cnt = 0;
721       bench_free(orecv_off); orecv_off = 0;
722       bench_free(orecv_cnt); orecv_cnt = 0;
723       FFTW(destroy_plan)(plan_scramble_in); plan_scramble_in = 0;
724       FFTW(destroy_plan)(plan_unscramble_out); plan_unscramble_out = 0;
725  }
726  void final_cleanup(void)
727  {
728       MPI_Finalize();
729  }
730  void bench_exit(int status)
731  {
732       MPI_Abort(MPI_COMM_WORLD, status);
733  }
734  double bench_cost_postprocess(double cost)
735  {
736       double cost_max;
737       MPI_Allreduce(&amp;cost, &amp;cost_max, 1, MPI_DOUBLE, MPI_MAX, MPI_COMM_WORLD);
738       return cost_max;
739  }
740  int import_wisdom(FILE *f)
741  {
742       int success = 1, sall;
743       if (my_pe == 0) success = FFTW(import_wisdom_from_file)(f);
744       FFTW(mpi_broadcast_wisdom)(MPI_COMM_WORLD);
745       MPI_Allreduce(&amp;success, &amp;sall, 1, MPI_INT, MPI_LAND, MPI_COMM_WORLD);
746       return sall;
747  }
748  void export_wisdom(FILE *f)
749  {
750       FFTW(mpi_gather_wisdom)(MPI_COMM_WORLD);
751       if (my_pe == 0) FFTW(export_wisdom_to_file)(f);
752  }
</code></pre>
        </div>
        <div class="column">
            <h3>fftw3-MDEwOlJlcG9zaXRvcnk4ODQzMzg4-flat-mpi-bench.c</h3>
            <pre><code>1  #include &lt;math.h&gt;
2  #include &lt;stdio.h&gt;
3  #include &lt;string.h&gt;
4  #include &quot;fftw3-mpi.h&quot;
5  #include &quot;tests/fftw-bench.h&quot;
6  #if defined(BENCHFFT_SINGLE)
7  #  define BENCH_MPI_TYPE MPI_FLOAT
8  #elif defined(BENCHFFT_LDOUBLE)
9  #  define BENCH_MPI_TYPE MPI_LONG_DOUBLE
10  #elif defined(BENCHFFT_QUAD)
11  #  error MPI quad-precision type is unknown
12  #else
13  #  define BENCH_MPI_TYPE MPI_DOUBLE
14  #endif
15  #if SIZEOF_PTRDIFF_T == SIZEOF_INT
16  #  define FFTW_MPI_PTRDIFF_T MPI_INT
17  #elif SIZEOF_PTRDIFF_T == SIZEOF_LONG
18  #  define FFTW_MPI_PTRDIFF_T MPI_LONG
19  #elif SIZEOF_PTRDIFF_T == SIZEOF_LONG_LONG
20  #  define FFTW_MPI_PTRDIFF_T MPI_LONG_LONG
21  #else
22  #  error MPI type for ptrdiff_t is unknown
23  #  define FFTW_MPI_PTRDIFF_T MPI_LONG
24  #endif
25  static const char *mkversion(void) { return FFTW(version); }
26  static const char *mkcc(void) { return FFTW(cc); }
27  static const char *mkcodelet_optim(void) { return FFTW(codelet_optim); }
28  static const char *mknproc(void) {
29       static char buf[32];
30       int ncpus;
31       MPI_Comm_size(MPI_COMM_WORLD, &amp;ncpus);
32  #ifdef HAVE_SNPRINTF
33       snprintf(buf, 32, &quot;%d&quot;, ncpus);
34  #else
35       sprintf(buf, &quot;%d&quot;, ncpus);
36  #endif
37       return buf;
38  }
39  BEGIN_BENCH_DOC
40  BENCH_DOC(&quot;name&quot;, &quot;fftw3_mpi&quot;)
41  BENCH_DOCF(&quot;version&quot;, mkversion)
42  BENCH_DOCF(&quot;cc&quot;, mkcc)
43  BENCH_DOCF(&quot;codelet-optim&quot;, mkcodelet_optim)
44  BENCH_DOCF(&quot;nproc&quot;, mknproc)
45  END_BENCH_DOC 
46  static int n_pes = 1, my_pe = 0;
47  static int rnk;
48  static ptrdiff_t vn, iNtot, oNtot;
49  static ptrdiff_t *local_ni=0, *local_starti=0;
50  static ptrdiff_t *local_no=0, *local_starto=0;
51  static ptrdiff_t *all_local_ni=0, *all_local_starti=0; &amp;bsol;* n_pes x rnk arrays */
52  static ptrdiff_t *all_local_no=0, *all_local_starto=0; &amp;bsol;* n_pes x rnk arrays */
53  static ptrdiff_t *istrides = 0, *ostrides = 0;
54  static ptrdiff_t *total_ni=0, *total_no=0;
55  static int *isend_cnt = 0, *isend_off = 0; &amp;bsol;* for MPI_Scatterv */
56  static int *orecv_cnt = 0, *orecv_off = 0; &amp;bsol;* for MPI_Gatherv */
57  static bench_real *local_in = 0, *local_out = 0;
58  static bench_real *all_local_in = 0, *all_local_out = 0;
59  static int all_local_in_alloc = 0, all_local_out_alloc = 0;
60  static FFTW(plan) plan_scramble_in = 0, plan_unscramble_out = 0;
61  static void alloc_rnk(int rnk_) {
62       rnk = rnk_;
63       bench_free(local_ni);
64       if (rnk == 0)
65  	  local_ni = 0;
66       else
67  	  local_ni = (ptrdiff_t *) bench_malloc(sizeof(ptrdiff_t) * rnk
68  						* (8 + n_pes * 4));
69       local_starti = local_ni + rnk;
70       local_no = local_ni + 2 * rnk;
71       local_starto = local_ni + 3 * rnk;
72       istrides = local_ni + 4 * rnk;
73       ostrides = local_ni + 5 * rnk;
74       total_ni = local_ni + 6 * rnk;
75       total_no = local_ni + 7 * rnk;
76       all_local_ni = local_ni + 8 * rnk;
77       all_local_starti = local_ni + (8 + n_pes) * rnk;
78       all_local_no = local_ni + (8 + 2 * n_pes) * rnk;
79       all_local_starto = local_ni + (8 + 3 * n_pes) * rnk;
80  }
81  static void setup_gather_scatter(void)
82  {
83       int i, j;
84       ptrdiff_t off;
85       MPI_Gather(local_ni, rnk, FFTW_MPI_PTRDIFF_T,
86  		all_local_ni, rnk, FFTW_MPI_PTRDIFF_T,
87  		0, MPI_COMM_WORLD);
88       MPI_Bcast(all_local_ni, rnk*n_pes, FFTW_MPI_PTRDIFF_T, 0, MPI_COMM_WORLD);
89       MPI_Gather(local_starti, rnk, FFTW_MPI_PTRDIFF_T,
90  		all_local_starti, rnk, FFTW_MPI_PTRDIFF_T,
91  		0, MPI_COMM_WORLD);
92       MPI_Bcast(all_local_starti, rnk*n_pes, FFTW_MPI_PTRDIFF_T, 0, MPI_COMM_WORLD);
93       MPI_Gather(local_no, rnk, FFTW_MPI_PTRDIFF_T,
94  		all_local_no, rnk, FFTW_MPI_PTRDIFF_T,
95  		0, MPI_COMM_WORLD);
96       MPI_Bcast(all_local_no, rnk*n_pes, FFTW_MPI_PTRDIFF_T, 0, MPI_COMM_WORLD);
97       MPI_Gather(local_starto, rnk, FFTW_MPI_PTRDIFF_T,
98  		all_local_starto, rnk, FFTW_MPI_PTRDIFF_T,
99  		0, MPI_COMM_WORLD);
100       MPI_Bcast(all_local_starto, rnk*n_pes, FFTW_MPI_PTRDIFF_T, 0, MPI_COMM_WORLD);
101       off = 0;
102       for (i = 0; i &lt; n_pes; ++i) {
103  	  ptrdiff_t N = vn;
104  	  for (j = 0; j &lt; rnk; ++j)
105  	       N *= all_local_ni[i * rnk + j];
106  	  isend_cnt[i] = N;
107  	  isend_off[i] = off;
108  	  off += N;
109       }
110       iNtot = off;
111       all_local_in_alloc = 1;
112       istrides[rnk - 1] = vn;
113       for (j = rnk - 2; j &gt;= 0; --j)
114  	  istrides[j] = total_ni[j + 1] * istrides[j + 1];
115       off = 0;
116       for (i = 0; i &lt; n_pes; ++i) {
117  	  ptrdiff_t N = vn;
118  	  for (j = 0; j &lt; rnk; ++j)
119  	       N *= all_local_no[i * rnk + j];
120  	  orecv_cnt[i] = N;
121  	  orecv_off[i] = off;
122  	  off += N;
123       }
124       oNtot = off;
125       all_local_out_alloc = 1;
126       ostrides[rnk - 1] = vn;
127       for (j = rnk - 2; j &gt;= 0; --j)
128  	  ostrides[j] = total_no[j + 1] * ostrides[j + 1];
129  }
130  static void copy_block_out(const bench_real *in,
131  			   int rnk, ptrdiff_t *n, ptrdiff_t *start, 
132  			   ptrdiff_t is, ptrdiff_t *os, ptrdiff_t vn,
133  			   bench_real *out)
134  {
135       ptrdiff_t i;
136       if (rnk == 0) { 
137  	  for (i = 0; i &lt; vn; ++i)
138  	       out[i] = in[i];
139       }
140       else if (rnk == 1) { &amp;bsol;* this case is just an optimization */
141  	  ptrdiff_t j;
142  	  out += start[0] * os[0];
143  	  for (j = 0; j &lt; n[0]; ++j) {
144  	       for (i = 0; i &lt; vn; ++i)
145  		    out[i] = in[i];
146  	       in += is;
147  	       out += os[0];
148  	  }
149       }
150       else {
151  	  for (i = 0; i &lt; n[rnk - 1]; ++i) 
152  	       copy_block_out(in + i * is,
153  			      rnk - 1, n, start, is * n[rnk - 1], os, vn,
154  			      out + (start[rnk - 1] + i) * os[rnk - 1]);
155       }
156  }
157  static void copy_block_in(bench_real *in,
158  			  int rnk, ptrdiff_t *n, ptrdiff_t *start, 
159  			  ptrdiff_t is, ptrdiff_t *os, ptrdiff_t vn,
160  			  const bench_real *out)
161  {
162       ptrdiff_t i;
163       if (rnk == 0) { 
164  	  for (i = 0; i &lt; vn; ++i)
165  	       in[i] = out[i];
166       }
167       else if (rnk == 1) { &amp;bsol;* this case is just an optimization */
168  	  ptrdiff_t j;
169  	  out += start[0] * os[0];
170  	  for (j = 0; j &lt; n[0]; ++j) {
171  	       for (i = 0; i &lt; vn; ++i)
172  		    in[i] = out[i];
173  	       in += is;
174  	       out += os[0];
175  	  }
176       }
177       else {
178  	  for (i = 0; i &lt; n[rnk - 1]; ++i) 
179  	       copy_block_in(in + i * is,
180  			     rnk - 1, n, start, is * n[rnk - 1], os, vn,
181  			     out + (start[rnk - 1] + i) * os[rnk - 1]);
182       }
183  }
184  static void do_scatter_in(bench_real *in)
185  {
186       bench_real *ali;
187       int i;
188       if (all_local_in_alloc) {
189            bench_free(all_local_in);
190  	  all_local_in = (bench_real*) bench_malloc(iNtot*sizeof(bench_real));
191  	  all_local_in_alloc = 0;
192       }
193       ali = all_local_in;
194       for (i = 0; i &lt; n_pes; ++i) {
195  	  copy_block_in(ali,
196  			rnk, all_local_ni + i * rnk, 
197  			all_local_starti + i * rnk,
198  			vn, istrides, vn,
199  			in);
200  	  ali += isend_cnt[i];
201       }
202       MPI_Scatterv(all_local_in, isend_cnt, isend_off, BENCH_MPI_TYPE,
203  		  local_in, isend_cnt[my_pe], BENCH_MPI_TYPE,
204  		  0, MPI_COMM_WORLD);
205  }
206  static void do_gather_out(bench_real *out)
207  {
208       bench_real *alo;
209       int i;
210       if (all_local_out_alloc) {
211            bench_free(all_local_out);
212  	  all_local_out = (bench_real*) bench_malloc(oNtot*sizeof(bench_real));
213  	  all_local_out_alloc = 0;
214       }
215       MPI_Gatherv(local_out, orecv_cnt[my_pe], BENCH_MPI_TYPE,
216  		 all_local_out, orecv_cnt, orecv_off, BENCH_MPI_TYPE,
217  		 0, MPI_COMM_WORLD);
218       MPI_Bcast(all_local_out, oNtot, BENCH_MPI_TYPE, 0, MPI_COMM_WORLD);
219       alo = all_local_out;
220       for (i = 0; i &lt; n_pes; ++i) {
221  	  copy_block_out(alo,
222  			 rnk, all_local_no + i * rnk, 
223  			 all_local_starto + i * rnk,
224  			 vn, ostrides, vn,
225  			 out);
226  	  alo += orecv_cnt[i];
227       }
228  }
229  static void alloc_local(ptrdiff_t nreal, int inplace)
230  {
231       bench_free(local_in);
232       if (local_out != local_in) bench_free(local_out);
233       local_in = local_out = 0;
234       if (nreal &gt; 0) {
235  	  ptrdiff_t i;
236  	  local_in = (bench_real*) bench_malloc(nreal * sizeof(bench_real));
237  	  if (inplace)
238  	       local_out = local_in;
239  	  else
240  	       local_out = (bench_real*) bench_malloc(nreal * sizeof(bench_real));
241  	  for (i = 0; i &lt; nreal; ++i) local_in[i] = local_out[i] = 0.0;
242       }
243  }
244  void after_problem_rcopy_from(bench_problem *p, bench_real *ri)
245  {
246       UNUSED(p);
247       do_scatter_in(ri);
248       if (plan_scramble_in) FFTW(execute)(plan_scramble_in);
249  }
250  void after_problem_rcopy_to(bench_problem *p, bench_real *ro)
251  {
252       UNUSED(p);
253       if (plan_unscramble_out) FFTW(execute)(plan_unscramble_out);
254       do_gather_out(ro);
255  }
256  void after_problem_ccopy_from(bench_problem *p, bench_real *ri, bench_real *ii)
257  {
258       UNUSED(ii);
259       after_problem_rcopy_from(p, ri);
260  }
261  void after_problem_ccopy_to(bench_problem *p, bench_real *ro, bench_real *io)
262  {
263       UNUSED(io);
264       after_problem_rcopy_to(p, ro);
265  }
266  void after_problem_hccopy_from(bench_problem *p, bench_real *ri, bench_real *ii)
267  {
268       UNUSED(ii);
269       after_problem_rcopy_from(p, ri);
270  }
271  void after_problem_hccopy_to(bench_problem *p, bench_real *ro, bench_real *io)
272  {
273       UNUSED(io);
274       after_problem_rcopy_to(p, ro);
275  }
276  static FFTW(plan) mkplan_transpose_local(ptrdiff_t nx, ptrdiff_t ny, 
277  					 ptrdiff_t vn, 
278  					 bench_real *in, bench_real *out)
279  {
280       FFTW(iodim64) hdims[3];
281       FFTW(r2r_kind) k[3];
282       FFTW(plan) pln;
283       hdims[0].n = nx;
284       hdims[0].is = ny * vn;
285       hdims[0].os = vn;
286       hdims[1].n = ny;
287       hdims[1].is = vn;
288       hdims[1].os = nx * vn;
289       hdims[2].n = vn;
290       hdims[2].is = 1;
291       hdims[2].os = 1;
292       k[0] = k[1] = k[2] = FFTW_R2HC;
293       pln = FFTW(plan_guru64_r2r)(0, 0, 3, hdims, in, out, k, FFTW_ESTIMATE);
294       BENCH_ASSERT(pln != 0);
295       return pln;
296  }
297  static int tensor_rowmajor_transposedp(bench_tensor *t)
298  {
299       bench_iodim *d;
300       int i;
301       BENCH_ASSERT(BENCH_FINITE_RNK(t-&gt;rnk));
302       if (t-&gt;rnk &lt; 2)
303  	  return 0;
304       d = t-&gt;dims;
305       if (d[0].is != d[1].is * d[1].n
306  	 || d[0].os != d[1].is
307  	 || d[1].os != d[0].os * d[0].n)
308  	  return 0;
309       if (t-&gt;rnk &gt; 2 &amp;&amp; d[1].is != d[2].is * d[2].n)
310  	  return 0;
311       for (i = 2; i + 1 &lt; t-&gt;rnk; ++i) {
312            d = t-&gt;dims + i;
313            if (d[0].is != d[1].is * d[1].n
314  	      || d[0].os != d[1].os * d[1].n)
315                 return 0;
316       }
317       if (t-&gt;rnk &gt; 2 &amp;&amp; t-&gt;dims[t-&gt;rnk-1].is != t-&gt;dims[t-&gt;rnk-1].os)
318  	  return 0;
319       return 1;
320  }
321  static int tensor_contiguousp(bench_tensor *t, int s)
322  {
323       return (t-&gt;dims[t-&gt;rnk-1].is == s
324  	     &amp;&amp; ((tensor_rowmajorp(t) &amp;&amp; 
325  		  t-&gt;dims[t-&gt;rnk-1].is == t-&gt;dims[t-&gt;rnk-1].os)
326  		 || tensor_rowmajor_transposedp(t)));
327  }
328  static FFTW(plan) mkplan_complex(bench_problem *p, unsigned flags)
329  {
330       FFTW(plan) pln = 0;
331       int i; 
332       ptrdiff_t ntot;
333       vn = p-&gt;vecsz-&gt;rnk == 1 ? p-&gt;vecsz-&gt;dims[0].n : 1;
334       if (p-&gt;sz-&gt;rnk &lt; 1
335  	 || p-&gt;split
336  	 || !tensor_contiguousp(p-&gt;sz, vn)
337  	 || tensor_rowmajor_transposedp(p-&gt;sz)
338  	 || p-&gt;vecsz-&gt;rnk &gt; 1
339  	 || (p-&gt;vecsz-&gt;rnk == 1 &amp;&amp; (p-&gt;vecsz-&gt;dims[0].is != 1
<span onclick='openModal()' class='match'>340  				    || p-&gt;vecsz-&gt;dims[0].os != 1)))
341  	  return 0;
342       alloc_rnk(p-&gt;sz-&gt;rnk);
343       for (i = 0; i &lt; rnk; ++i) {
344  	  total_ni[i] = total_no[i] = p-&gt;sz-&gt;dims[i].n;
345  	  local_ni[i] = local_no[i] = total_ni[i];
346  	  local_starti[i] = local_starto[i] = 0;
347       }
348       if (rnk &gt; 1) {
</span>349  	  ptrdiff_t n, start, nT, startT;
350  	  ntot = FFTW(mpi_local_size_many_transposed)
351  	       (p-&gt;sz-&gt;rnk, total_ni, vn,
352  		FFTW_MPI_DEFAULT_BLOCK, FFTW_MPI_DEFAULT_BLOCK,
353  		MPI_COMM_WORLD,
354  		&amp;n, &amp;start, &amp;nT, &amp;startT);
355  	  if  (flags &amp; FFTW_MPI_TRANSPOSED_IN) {
356  	       local_ni[1] = nT;
357  	       local_starti[1] = startT;
358  	  }
359  	  else {
360  	       local_ni[0] = n;
361  	       local_starti[0] = start;
362  	  }
363  	  if  (flags &amp; FFTW_MPI_TRANSPOSED_OUT) {
364  	       local_no[1] = nT;
365  	       local_starto[1] = startT;
366  	  }
367  	  else {
368  	       local_no[0] = n;
369  	       local_starto[0] = start;
370  	  }
371       }
372       else if (rnk == 1) {
373  	  ntot = FFTW(mpi_local_size_many_1d)
374  	       (total_ni[0], vn, MPI_COMM_WORLD, p-&gt;sign, flags,
375  		local_ni, local_starti, local_no, local_starto);
376       }
377       alloc_local(ntot * 2, p-&gt;in == p-&gt;out);
378       pln = FFTW(mpi_plan_many_dft)(p-&gt;sz-&gt;rnk, total_ni, vn, 
379  				   FFTW_MPI_DEFAULT_BLOCK,
380  				   FFTW_MPI_DEFAULT_BLOCK,
381  				   (FFTW(complex) *) local_in, 
382  				   (FFTW(complex) *) local_out,
383  				   MPI_COMM_WORLD, p-&gt;sign, flags);
384       vn *= 2;
385       if (rnk &gt; 1) {
386  	  ptrdiff_t nrest = 1;
387  	  for (i = 2; i &lt; rnk; ++i) nrest *= p-&gt;sz-&gt;dims[i].n;
388  	  if (flags &amp; FFTW_MPI_TRANSPOSED_IN)
389  	       plan_scramble_in = mkplan_transpose_local(
390  		    p-&gt;sz-&gt;dims[0].n, local_ni[1], vn * nrest,
391  		    local_in, local_in);
392  	  if (flags &amp; FFTW_MPI_TRANSPOSED_OUT)
393  	       plan_unscramble_out = mkplan_transpose_local(
394  		    local_no[1], p-&gt;sz-&gt;dims[0].n, vn * nrest,
395  		    local_out, local_out);
396       }
397       return pln;
398  }
399  static int tensor_real_contiguousp(bench_tensor *t, int sign, int s)
400  {
401       return (t-&gt;dims[t-&gt;rnk-1].is == s
402  	     &amp;&amp; ((tensor_real_rowmajorp(t, sign, 1) &amp;&amp; 
403  		  t-&gt;dims[t-&gt;rnk-1].is == t-&gt;dims[t-&gt;rnk-1].os)));
404  }
405  static FFTW(plan) mkplan_real(bench_problem *p, unsigned flags)
406  {
407       FFTW(plan) pln = 0;
408       int i; 
409       ptrdiff_t ntot;
410       vn = p-&gt;vecsz-&gt;rnk == 1 ? p-&gt;vecsz-&gt;dims[0].n : 1;
411       if (p-&gt;sz-&gt;rnk &lt; 2
412  	 || p-&gt;split
413  	 || !tensor_real_contiguousp(p-&gt;sz, p-&gt;sign, vn)
414  	 || tensor_rowmajor_transposedp(p-&gt;sz)
415  	 || p-&gt;vecsz-&gt;rnk &gt; 1
416  	 || (p-&gt;vecsz-&gt;rnk == 1 &amp;&amp; (p-&gt;vecsz-&gt;dims[0].is != 1
417  				    || p-&gt;vecsz-&gt;dims[0].os != 1)))
418  	  return 0;
419       alloc_rnk(p-&gt;sz-&gt;rnk);
420       for (i = 0; i &lt; rnk; ++i) {
421  	  total_ni[i] = total_no[i] = p-&gt;sz-&gt;dims[i].n;
422  	  local_ni[i] = local_no[i] = total_ni[i];
423  	  local_starti[i] = local_starto[i] = 0;
424       }
425       local_ni[rnk-1] = local_no[rnk-1] = total_ni[rnk-1] = total_no[rnk-1] 
426  	  = p-&gt;sz-&gt;dims[rnk-1].n / 2 + 1;
427       {
428  	  ptrdiff_t n, start, nT, startT;
429  	  ntot = FFTW(mpi_local_size_many_transposed)
430  	       (p-&gt;sz-&gt;rnk, total_ni, vn,
431  		FFTW_MPI_DEFAULT_BLOCK, FFTW_MPI_DEFAULT_BLOCK,
432  		MPI_COMM_WORLD,
433  		&amp;n, &amp;start, &amp;nT, &amp;startT);
434  	  if  (flags &amp; FFTW_MPI_TRANSPOSED_IN) {
435  	       local_ni[1] = nT;
436  	       local_starti[1] = startT;
437  	  }
438  	  else {
439  	       local_ni[0] = n;
440  	       local_starti[0] = start;
441  	  }
442  	  if  (flags &amp; FFTW_MPI_TRANSPOSED_OUT) {
443  	       local_no[1] = nT;
444  	       local_starto[1] = startT;
445  	  }
446  	  else {
447  	       local_no[0] = n;
448  	       local_starto[0] = start;
449  	  }
450       }
451       alloc_local(ntot * 2, p-&gt;in == p-&gt;out);
452       total_ni[rnk - 1] = p-&gt;sz-&gt;dims[rnk - 1].n;
453       if (p-&gt;sign &lt; 0)
454  	  pln = FFTW(mpi_plan_many_dft_r2c)(p-&gt;sz-&gt;rnk, total_ni, vn, 
455  					    FFTW_MPI_DEFAULT_BLOCK,
456  					    FFTW_MPI_DEFAULT_BLOCK,
457  					    local_in, 
458  					    (FFTW(complex) *) local_out,
459  					    MPI_COMM_WORLD, flags);
460       else
461  	  pln = FFTW(mpi_plan_many_dft_c2r)(p-&gt;sz-&gt;rnk, total_ni, vn, 
462  					    FFTW_MPI_DEFAULT_BLOCK,
463  					    FFTW_MPI_DEFAULT_BLOCK,
464  					    (FFTW(complex) *) local_in, 
465  					    local_out,
466  					    MPI_COMM_WORLD, flags);
467       total_ni[rnk - 1] = p-&gt;sz-&gt;dims[rnk - 1].n / 2 + 1;
468       vn *= 2;
469       {
470  	  ptrdiff_t nrest = 1;
471  	  for (i = 2; i &lt; rnk; ++i) nrest *= total_ni[i];
472  	  if (flags &amp; FFTW_MPI_TRANSPOSED_IN)
473  	       plan_scramble_in = mkplan_transpose_local(
474  		    total_ni[0], local_ni[1], vn * nrest,
475  		    local_in, local_in);
476  	  if (flags &amp; FFTW_MPI_TRANSPOSED_OUT)
477  	       plan_unscramble_out = mkplan_transpose_local(
478  		    local_no[1], total_ni[0], vn * nrest,
479  		    local_out, local_out);
480       }
481       return pln;
482  }
483  static FFTW(plan) mkplan_transpose(bench_problem *p, unsigned flags)
484  {
485       ptrdiff_t ntot, nx, ny;
486       int ix=0, iy=1, i;
487       const bench_iodim *d = p-&gt;vecsz-&gt;dims;
488       FFTW(plan) pln;
489       if (p-&gt;vecsz-&gt;rnk == 3) {
490  	  for (i = 0; i &lt; 3; ++i)
491  	       if (d[i].is == 1 &amp;&amp; d[i].os == 1) {
492  		    vn = d[i].n;
493  		    ix = (i + 1) % 3;
494  		    iy = (i + 2) % 3;
495  		    break;
496  	       }
497  	  if (i == 3) return 0;
498       }
499       else {
500  	  vn = 1;
501  	  ix = 0;
502  	  iy = 1;
503       }
504       if (d[ix].is == d[iy].n * vn &amp;&amp; d[ix].os == vn
505  	 &amp;&amp; d[iy].os == d[ix].n * vn &amp;&amp; d[iy].is == vn) {
506  	  nx = d[ix].n;
507  	  ny = d[iy].n;
508       }
509       else if (d[iy].is == d[ix].n * vn &amp;&amp; d[iy].os == vn
510  	      &amp;&amp; d[ix].os == d[iy].n * vn &amp;&amp; d[ix].is == vn) {
511  	  nx = d[iy].n;
512  	  ny = d[ix].n;
513       }
514       else
515  	  return 0;
516       alloc_rnk(2);
517       ntot = vn * FFTW(mpi_local_size_2d_transposed)(nx, ny, MPI_COMM_WORLD,
518  						    &amp;local_ni[0], 
519  						    &amp;local_starti[0],
520  						    &amp;local_no[0], 
521  						    &amp;local_starto[0]);
522       local_ni[1] = ny;
523       local_starti[1] = 0;
524       local_no[1] = nx;
525       local_starto[1] = 0;
526       total_ni[0] = nx; total_ni[1] = ny;
527       total_no[1] = nx; total_no[0] = ny;
528       alloc_local(ntot, p-&gt;in == p-&gt;out);
529       pln = FFTW(mpi_plan_many_transpose)(nx, ny, vn,
530  					 FFTW_MPI_DEFAULT_BLOCK,
531  					 FFTW_MPI_DEFAULT_BLOCK,
532  					 local_in, local_out,
533  					 MPI_COMM_WORLD, flags);
534       if (flags &amp; FFTW_MPI_TRANSPOSED_IN)
535  	  plan_scramble_in = mkplan_transpose_local(local_ni[0], ny, vn,
536  						    local_in, local_in);
537       if (flags &amp; FFTW_MPI_TRANSPOSED_OUT)
538  	  plan_unscramble_out = mkplan_transpose_local
539  	       (nx, local_no[0], vn, local_out, local_out);
540  #if 0
541       if (pln &amp;&amp; vn == 1) {
542  	  int i, j;
543  	  bench_real *ri = (bench_real *) p-&gt;in;
544  	  bench_real *ro = (bench_real *) p-&gt;out;
545  	  if (!ri || !ro) return pln;
546  	  setup_gather_scatter();
547  	  for (i = 0; i &lt; nx * ny; ++i)
548  	       ri[i] = i;
549  	  after_problem_rcopy_from(p, ri);
550  	  FFTW(execute)(pln);
551  	  after_problem_rcopy_to(p, ro);
552  	  if (my_pe == 0) {
553  	       for (i = 0; i &lt; nx; ++i) {
554  		    for (j = 0; j &lt; ny; ++j)
555  			 printf(&quot;  %3g&quot;, ro[j * nx + i]);
556  		    printf(&quot;\n&quot;);
557  	       }
558  	  }
559       }
560  #endif
561       return pln;
562  }
563  static FFTW(plan) mkplan_r2r(bench_problem *p, unsigned flags)
564  {
565       FFTW(plan) pln = 0;
566       int i; 
567       ptrdiff_t ntot;
568       FFTW(r2r_kind) *k;
569       if ((p-&gt;sz-&gt;rnk == 0 || (p-&gt;sz-&gt;rnk == 1 &amp;&amp; p-&gt;sz-&gt;dims[0].n == 1))
570  	 &amp;&amp; p-&gt;vecsz-&gt;rnk &gt;= 2 &amp;&amp; p-&gt;vecsz-&gt;rnk &lt;= 3)
571  	  return mkplan_transpose(p, flags);
572       vn = p-&gt;vecsz-&gt;rnk == 1 ? p-&gt;vecsz-&gt;dims[0].n : 1;
573       if (p-&gt;sz-&gt;rnk &lt; 1
574  	 || p-&gt;split
575  	 || !tensor_contiguousp(p-&gt;sz, vn)
576  	 || tensor_rowmajor_transposedp(p-&gt;sz)
577  	 || p-&gt;vecsz-&gt;rnk &gt; 1
578  	 || (p-&gt;vecsz-&gt;rnk == 1 &amp;&amp; (p-&gt;vecsz-&gt;dims[0].is != 1
579  				    || p-&gt;vecsz-&gt;dims[0].os != 1)))
580  	  return 0;
581       alloc_rnk(p-&gt;sz-&gt;rnk);
582       for (i = 0; i &lt; rnk; ++i) {
583  	  total_ni[i] = total_no[i] = p-&gt;sz-&gt;dims[i].n;
584  	  local_ni[i] = local_no[i] = total_ni[i];
585  	  local_starti[i] = local_starto[i] = 0;
586       }
587       if (rnk &gt; 1) {
588  	  ptrdiff_t n, start, nT, startT;
589  	  ntot = FFTW(mpi_local_size_many_transposed)
590  	       (p-&gt;sz-&gt;rnk, total_ni, vn,
591  		FFTW_MPI_DEFAULT_BLOCK, FFTW_MPI_DEFAULT_BLOCK,
592  		MPI_COMM_WORLD,
593  		&amp;n, &amp;start, &amp;nT, &amp;startT);
594  	  if  (flags &amp; FFTW_MPI_TRANSPOSED_IN) {
595  	       local_ni[1] = nT;
596  	       local_starti[1] = startT;
597  	  }
598  	  else {
599  	       local_ni[0] = n;
600  	       local_starti[0] = start;
601  	  }
602  	  if  (flags &amp; FFTW_MPI_TRANSPOSED_OUT) {
603  	       local_no[1] = nT;
604  	       local_starto[1] = startT;
605  	  }
606  	  else {
607  	       local_no[0] = n;
608  	       local_starto[0] = start;
609  	  }
610       }
611       else if (rnk == 1) {
612  	  ntot = FFTW(mpi_local_size_many_1d)
613  	       (total_ni[0], vn, MPI_COMM_WORLD, p-&gt;sign, flags,
614  		local_ni, local_starti, local_no, local_starto);
615       }
616       alloc_local(ntot, p-&gt;in == p-&gt;out);
617       k = (FFTW(r2r_kind) *) bench_malloc(sizeof(FFTW(r2r_kind)) * p-&gt;sz-&gt;rnk);
618       for (i = 0; i &lt; p-&gt;sz-&gt;rnk; ++i)
619  	  switch (p-&gt;k[i]) {
620  	      case R2R_R2HC: k[i] = FFTW_R2HC; break;
621  	      case R2R_HC2R: k[i] = FFTW_HC2R; break;
622  	      case R2R_DHT: k[i] = FFTW_DHT; break;
623  	      case R2R_REDFT00: k[i] = FFTW_REDFT00; break;
624  	      case R2R_REDFT01: k[i] = FFTW_REDFT01; break;
625  	      case R2R_REDFT10: k[i] = FFTW_REDFT10; break;
626  	      case R2R_REDFT11: k[i] = FFTW_REDFT11; break;
627  	      case R2R_RODFT00: k[i] = FFTW_RODFT00; break;
628  	      case R2R_RODFT01: k[i] = FFTW_RODFT01; break;
629  	      case R2R_RODFT10: k[i] = FFTW_RODFT10; break;
630  	      case R2R_RODFT11: k[i] = FFTW_RODFT11; break;
631  	      default: BENCH_ASSERT(0);
632  	  }
633       pln = FFTW(mpi_plan_many_r2r)(p-&gt;sz-&gt;rnk, total_ni, vn, 
634  				   FFTW_MPI_DEFAULT_BLOCK,
635  				   FFTW_MPI_DEFAULT_BLOCK,
636  				   local_in, local_out,
637  				   MPI_COMM_WORLD, k, flags);
638       bench_free(k);
639       if (rnk &gt; 1) {
640  	  ptrdiff_t nrest = 1;
641  	  for (i = 2; i &lt; rnk; ++i) nrest *= p-&gt;sz-&gt;dims[i].n;
642  	  if (flags &amp; FFTW_MPI_TRANSPOSED_IN)
643  	       plan_scramble_in = mkplan_transpose_local(
644  		    p-&gt;sz-&gt;dims[0].n, local_ni[1], vn * nrest,
645  		    local_in, local_in);
646  	  if (flags &amp; FFTW_MPI_TRANSPOSED_OUT)
647  	       plan_unscramble_out = mkplan_transpose_local(
648  		    local_no[1], p-&gt;sz-&gt;dims[0].n, vn * nrest,
649  		    local_out, local_out);
650       }
651       return pln;
652  }
653  FFTW(plan) mkplan(bench_problem *p, unsigned flags)
654  {
655       FFTW(plan) pln = 0;
656       FFTW(destroy_plan)(plan_scramble_in); plan_scramble_in = 0;
657       FFTW(destroy_plan)(plan_unscramble_out); plan_unscramble_out = 0;
658       if (p-&gt;scrambled_in) {
659  	  if (p-&gt;sz-&gt;rnk == 1 &amp;&amp; p-&gt;sz-&gt;dims[0].n != 1) 
660  	       flags |= FFTW_MPI_SCRAMBLED_IN;
661  	  else
662  	       flags |= FFTW_MPI_TRANSPOSED_IN;
663       }
664       if (p-&gt;scrambled_out) {
665  	  if (p-&gt;sz-&gt;rnk == 1 &amp;&amp; p-&gt;sz-&gt;dims[0].n != 1) 
666  	       flags |= FFTW_MPI_SCRAMBLED_OUT;
667  	  else
668  	       flags |= FFTW_MPI_TRANSPOSED_OUT;
669       }
670       switch (p-&gt;kind) {
671           case PROBLEM_COMPLEX: 
672  	      pln =mkplan_complex(p, flags);
673  	      break;
674           case PROBLEM_REAL: 
675  	      pln = mkplan_real(p, flags);
676  	      break;
677           case PROBLEM_R2R:
678  	      pln = mkplan_r2r(p, flags);
679  	      break;
680           default: BENCH_ASSERT(0);
681       }
682       if (pln) setup_gather_scatter();
683       return pln;
684  }
685  void main_init(int *argc, char ***argv)
686  {
687  #ifdef HAVE_SMP
688  # if MPI_VERSION &gt;= 2 &amp;bsol;* for MPI_Init_thread */
689       int provided;
690       MPI_Init_thread(argc, argv, MPI_THREAD_FUNNELED, &amp;provided);
691       threads_ok = provided &gt;= MPI_THREAD_FUNNELED;
692  # else
693       MPI_Init(argc, argv);
694       threads_ok = 0;
695  # endif
696  #else
697       MPI_Init(argc, argv);
698  #endif
699       MPI_Comm_rank(MPI_COMM_WORLD, &amp;my_pe);
700       MPI_Comm_size(MPI_COMM_WORLD, &amp;n_pes);
701       if (my_pe != 0) verbose = -999;
702       no_speed_allocation = 1; &amp;bsol;* so we can benchmark transforms &gt; memory */
703       always_pad_real = 1; &amp;bsol;* out-of-place real transforms are padded */
704       isend_cnt = (int *) bench_malloc(sizeof(int) * n_pes);
705       isend_off = (int *) bench_malloc(sizeof(int) * n_pes);
706       orecv_cnt = (int *) bench_malloc(sizeof(int) * n_pes);
707       orecv_off = (int *) bench_malloc(sizeof(int) * n_pes);
708  #ifdef HAVE_SMP
709       if (threads_ok) { BENCH_ASSERT(FFTW(init_threads)()); }
710  #endif
711       FFTW(mpi_init)();
712  }
713  void initial_cleanup(void)
714  {
715       alloc_rnk(0);
716       alloc_local(0, 0);
717       bench_free(all_local_in); all_local_in = 0;
718       bench_free(all_local_out); all_local_out = 0;
719       bench_free(isend_off); isend_off = 0;
720       bench_free(isend_cnt); isend_cnt = 0;
721       bench_free(orecv_off); orecv_off = 0;
722       bench_free(orecv_cnt); orecv_cnt = 0;
723       FFTW(destroy_plan)(plan_scramble_in); plan_scramble_in = 0;
724       FFTW(destroy_plan)(plan_unscramble_out); plan_unscramble_out = 0;
725  }
726  void final_cleanup(void)
727  {
728       MPI_Finalize();
729  }
730  void bench_exit(int status)
731  {
732       MPI_Abort(MPI_COMM_WORLD, status);
733  }
734  double bench_cost_postprocess(double cost)
735  {
736       double cost_max;
737       MPI_Allreduce(&amp;cost, &amp;cost_max, 1, MPI_DOUBLE, MPI_MAX, MPI_COMM_WORLD);
738       return cost_max;
739  }
740  int import_wisdom(FILE *f)
741  {
742       int success = 1, sall;
743       if (my_pe == 0) success = FFTW(import_wisdom_from_file)(f);
744       FFTW(mpi_broadcast_wisdom)(MPI_COMM_WORLD);
745       MPI_Allreduce(&amp;success, &amp;sall, 1, MPI_INT, MPI_LAND, MPI_COMM_WORLD);
746       return sall;
747  }
748  void export_wisdom(FILE *f)
749  {
750       FFTW(mpi_gather_wisdom)(MPI_COMM_WORLD);
751       if (my_pe == 0) FFTW(export_wisdom_to_file)(f);
752  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from fftw3-MDEwOlJlcG9zaXRvcnk4ODQzMzg4-flat-mpi-bench.c</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from fftw3-MDEwOlJlcG9zaXRvcnk4ODQzMzg4-flat-mpi-bench.c</div>
                </div>
                <div class="column column_space"><pre><code>417  				    || p-&gt;vecsz-&gt;dims[0].os != 1)))
418  	  return 0;
419       alloc_rnk(p-&gt;sz-&gt;rnk);
420       for (i = 0; i &lt; rnk; ++i) {
421  	  total_ni[i] = total_no[i] = p-&gt;sz-&gt;dims[i].n;
422  	  local_ni[i] = local_no[i] = total_ni[i];
423  	  local_starti[i] = local_starto[i] = 0;
424       }
425       local_ni[rnk-1] = local_no[rnk-1] = total_ni[rnk-1] = total_no[rnk-1] 
</pre></code></div>
                <div class="column column_space"><pre><code>340  				    || p-&gt;vecsz-&gt;dims[0].os != 1)))
341  	  return 0;
342       alloc_rnk(p-&gt;sz-&gt;rnk);
343       for (i = 0; i &lt; rnk; ++i) {
344  	  total_ni[i] = total_no[i] = p-&gt;sz-&gt;dims[i].n;
345  	  local_ni[i] = local_no[i] = total_ni[i];
346  	  local_starti[i] = local_starto[i] = 0;
347       }
348       if (rnk &gt; 1) {
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    