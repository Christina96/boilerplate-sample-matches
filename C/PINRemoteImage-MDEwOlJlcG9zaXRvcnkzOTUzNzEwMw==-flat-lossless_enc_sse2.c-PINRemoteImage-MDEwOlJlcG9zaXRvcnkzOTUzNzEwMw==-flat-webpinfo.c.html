
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 4.3999999999999995%, Tokens: 9</h2>
        <div class="column">
            <h3>PINRemoteImage-MDEwOlJlcG9zaXRvcnkzOTUzNzEwMw==-flat-lossless_enc_sse2.c</h3>
            <pre><code>1  #include "src/dsp/dsp.h"
2  #if defined(WEBP_USE_SSE2)
3  #include <assert.h>
4  #include <emmintrin.h>
5  #include "src/dsp/lossless.h"
6  #include "src/dsp/common_sse2.h"
7  #include "src/dsp/lossless_common.h"
8  #define CST_5b(X)  (((int16_t)((uint16_t)(X) << 8)) >> 5)
9  static void SubtractGreenFromBlueAndRed_SSE2(uint32_t* argb_data,
10                                               int num_pixels) {
11    int i;
12    for (i = 0; i + 4 <= num_pixels; i += 4) {
13      const __m128i in = _mm_loadu_si128((__m128i*)&argb_data[i]); 
14      const __m128i A = _mm_srli_epi16(in, 8);     
15      const __m128i B = _mm_shufflelo_epi16(A, _MM_SHUFFLE(2, 2, 0, 0));
16      const __m128i C = _mm_shufflehi_epi16(B, _MM_SHUFFLE(2, 2, 0, 0));  
17      const __m128i out = _mm_sub_epi8(in, C);
18      _mm_storeu_si128((__m128i*)&argb_data[i], out);
19    }
20    if (i != num_pixels) {
21      VP8LSubtractGreenFromBlueAndRed_C(argb_data + i, num_pixels - i);
22    }
23  }
24  #define MK_CST_16(HI, LO) \
25    _mm_set1_epi32((int)(((uint32_t)(HI) << 16) | ((LO) & 0xffff)))
26  static void TransformColor_SSE2(const VP8LMultipliers* const m,
27                                  uint32_t* argb_data, int num_pixels) {
28    const __m128i mults_rb = MK_CST_16(CST_5b(m->green_to_red_),
29                                       CST_5b(m->green_to_blue_));
30    const __m128i mults_b2 = MK_CST_16(CST_5b(m->red_to_blue_), 0);
31    const __m128i mask_ag = _mm_set1_epi32(0xff00ff00);  
32    const __m128i mask_rb = _mm_set1_epi32(0x00ff00ff);  
33    int i;
34    for (i = 0; i + 4 <= num_pixels; i += 4) {
35      const __m128i in = _mm_loadu_si128((__m128i*)&argb_data[i]); 
36      const __m128i A = _mm_and_si128(in, mask_ag);     
37      const __m128i B = _mm_shufflelo_epi16(A, _MM_SHUFFLE(2, 2, 0, 0));
38      const __m128i C = _mm_shufflehi_epi16(B, _MM_SHUFFLE(2, 2, 0, 0));  
39      const __m128i D = _mm_mulhi_epi16(C, mults_rb);    
40      const __m128i E = _mm_slli_epi16(in, 8);           
41      const __m128i F = _mm_mulhi_epi16(E, mults_b2);    
42      const __m128i G = _mm_srli_epi32(F, 16);           
43      const __m128i H = _mm_add_epi8(G, D);              
44      const __m128i I = _mm_and_si128(H, mask_rb);       
45      const __m128i out = _mm_sub_epi8(in, I);
46      _mm_storeu_si128((__m128i*)&argb_data[i], out);
47    }
48    if (i != num_pixels) {
49      VP8LTransformColor_C(m, argb_data + i, num_pixels - i);
50    }
51  }
52  #define SPAN 8
53  static void CollectColorBlueTransforms_SSE2(const uint32_t* argb, int stride,
54                                              int tile_width, int tile_height,
55                                              int green_to_blue, int red_to_blue,
56                                              int histo[]) {
57    const __m128i mults_r = MK_CST_16(CST_5b(red_to_blue), 0);
58    const __m128i mults_g = MK_CST_16(0, CST_5b(green_to_blue));
59    const __m128i mask_g = _mm_set1_epi32(0x00ff00);  
60    const __m128i mask_b = _mm_set1_epi32(0x0000ff);  
61    int y;
62    for (y = 0; y < tile_height; ++y) {
63      const uint32_t* const src = argb + y * stride;
64      int i, x;
65      for (x = 0; x + SPAN <= tile_width; x += SPAN) {
66        uint16_t values[SPAN];
67        const __m128i in0 = _mm_loadu_si128((__m128i*)&src[x +        0]);
68        const __m128i in1 = _mm_loadu_si128((__m128i*)&src[x + SPAN / 2]);
69        const __m128i A0 = _mm_slli_epi16(in0, 8);        
70        const __m128i A1 = _mm_slli_epi16(in1, 8);
71        const __m128i B0 = _mm_and_si128(in0, mask_g);    
72        const __m128i B1 = _mm_and_si128(in1, mask_g);
73        const __m128i C0 = _mm_mulhi_epi16(A0, mults_r);  
74        const __m128i C1 = _mm_mulhi_epi16(A1, mults_r);
75        const __m128i D0 = _mm_mulhi_epi16(B0, mults_g);  
76        const __m128i D1 = _mm_mulhi_epi16(B1, mults_g);
77        const __m128i E0 = _mm_sub_epi8(in0, D0);         
78        const __m128i E1 = _mm_sub_epi8(in1, D1);
79        const __m128i F0 = _mm_srli_epi32(C0, 16);        
80        const __m128i F1 = _mm_srli_epi32(C1, 16);
81        const __m128i G0 = _mm_sub_epi8(E0, F0);          
82        const __m128i G1 = _mm_sub_epi8(E1, F1);
83        const __m128i H0 = _mm_and_si128(G0, mask_b);     
84        const __m128i H1 = _mm_and_si128(G1, mask_b);
85        const __m128i I = _mm_packs_epi32(H0, H1);        
86        _mm_storeu_si128((__m128i*)values, I);
87        for (i = 0; i < SPAN; ++i) ++histo[values[i]];
88      }
89    }
90    {
91      const int left_over = tile_width & (SPAN - 1);
92      if (left_over > 0) {
93        VP8LCollectColorBlueTransforms_C(argb + tile_width - left_over, stride,
94                                         left_over, tile_height,
95                                         green_to_blue, red_to_blue, histo);
96      }
97    }
98  }
99  static void CollectColorRedTransforms_SSE2(const uint32_t* argb, int stride,
100                                             int tile_width, int tile_height,
101                                             int green_to_red, int histo[]) {
102    const __m128i mults_g = MK_CST_16(0, CST_5b(green_to_red));
103    const __m128i mask_g = _mm_set1_epi32(0x00ff00);  
104    const __m128i mask = _mm_set1_epi32(0xff);
105    int y;
106    for (y = 0; y < tile_height; ++y) {
107      const uint32_t* const src = argb + y * stride;
108      int i, x;
109      for (x = 0; x + SPAN <= tile_width; x += SPAN) {
110        uint16_t values[SPAN];
111        const __m128i in0 = _mm_loadu_si128((__m128i*)&src[x +        0]);
112        const __m128i in1 = _mm_loadu_si128((__m128i*)&src[x + SPAN / 2]);
113        const __m128i A0 = _mm_and_si128(in0, mask_g);    
114        const __m128i A1 = _mm_and_si128(in1, mask_g);
115        const __m128i B0 = _mm_srli_epi32(in0, 16);       
116        const __m128i B1 = _mm_srli_epi32(in1, 16);
117        const __m128i C0 = _mm_mulhi_epi16(A0, mults_g);  
118        const __m128i C1 = _mm_mulhi_epi16(A1, mults_g);
119        const __m128i E0 = _mm_sub_epi8(B0, C0);          
120        const __m128i E1 = _mm_sub_epi8(B1, C1);
121        const __m128i F0 = _mm_and_si128(E0, mask);       
122        const __m128i F1 = _mm_and_si128(E1, mask);
123        const __m128i I = _mm_packs_epi32(F0, F1);
124        _mm_storeu_si128((__m128i*)values, I);
125        for (i = 0; i < SPAN; ++i) ++histo[values[i]];
126      }
127    }
128    {
129      const int left_over = tile_width & (SPAN - 1);
130      if (left_over > 0) {
131        VP8LCollectColorRedTransforms_C(argb + tile_width - left_over, stride,
132                                        left_over, tile_height,
133                                        green_to_red, histo);
134      }
135    }
136  }
137  #undef SPAN
138  #undef MK_CST_16
139  #define LINE_SIZE 16    
140  static void AddVector_SSE2(const uint32_t* a, const uint32_t* b, uint32_t* out,
141                             int size) {
142    int i;
143    for (i = 0; i + LINE_SIZE <= size; i += LINE_SIZE) {
144      const __m128i a0 = _mm_loadu_si128((const __m128i*)&a[i +  0]);
145      const __m128i a1 = _mm_loadu_si128((const __m128i*)&a[i +  4]);
146  #if (LINE_SIZE == 16)
147      const __m128i a2 = _mm_loadu_si128((const __m128i*)&a[i +  8]);
148      const __m128i a3 = _mm_loadu_si128((const __m128i*)&a[i + 12]);
149  #endif
150      const __m128i b0 = _mm_loadu_si128((const __m128i*)&b[i +  0]);
151      const __m128i b1 = _mm_loadu_si128((const __m128i*)&b[i +  4]);
152  #if (LINE_SIZE == 16)
153      const __m128i b2 = _mm_loadu_si128((const __m128i*)&b[i +  8]);
154      const __m128i b3 = _mm_loadu_si128((const __m128i*)&b[i + 12]);
155  #endif
156      _mm_storeu_si128((__m128i*)&out[i +  0], _mm_add_epi32(a0, b0));
157      _mm_storeu_si128((__m128i*)&out[i +  4], _mm_add_epi32(a1, b1));
158  #if (LINE_SIZE == 16)
159      _mm_storeu_si128((__m128i*)&out[i +  8], _mm_add_epi32(a2, b2));
160      _mm_storeu_si128((__m128i*)&out[i + 12], _mm_add_epi32(a3, b3));
161  #endif
162    }
163    for (; i < size; ++i) {
164      out[i] = a[i] + b[i];
165    }
166  }
167  static void AddVectorEq_SSE2(const uint32_t* a, uint32_t* out, int size) {
168    int i;
169    for (i = 0; i + LINE_SIZE <= size; i += LINE_SIZE) {
170      const __m128i a0 = _mm_loadu_si128((const __m128i*)&a[i +  0]);
171      const __m128i a1 = _mm_loadu_si128((const __m128i*)&a[i +  4]);
172  #if (LINE_SIZE == 16)
173      const __m128i a2 = _mm_loadu_si128((const __m128i*)&a[i +  8]);
174      const __m128i a3 = _mm_loadu_si128((const __m128i*)&a[i + 12]);
175  #endif
176      const __m128i b0 = _mm_loadu_si128((const __m128i*)&out[i +  0]);
177      const __m128i b1 = _mm_loadu_si128((const __m128i*)&out[i +  4]);
178  #if (LINE_SIZE == 16)
179      const __m128i b2 = _mm_loadu_si128((const __m128i*)&out[i +  8]);
180      const __m128i b3 = _mm_loadu_si128((const __m128i*)&out[i + 12]);
181  #endif
182      _mm_storeu_si128((__m128i*)&out[i +  0], _mm_add_epi32(a0, b0));
183      _mm_storeu_si128((__m128i*)&out[i +  4], _mm_add_epi32(a1, b1));
184  #if (LINE_SIZE == 16)
185      _mm_storeu_si128((__m128i*)&out[i +  8], _mm_add_epi32(a2, b2));
186      _mm_storeu_si128((__m128i*)&out[i + 12], _mm_add_epi32(a3, b3));
187  #endif
188    }
189    for (; i < size; ++i) {
190      out[i] += a[i];
191    }
192  }
193  #undef LINE_SIZE
194  #define ANALYZE_X_OR_Y(x_or_y, j)                                           \
195    do {                                                                      \
196      if ((x_or_y)[i + (j)] != 0) retval -= VP8LFastSLog2((x_or_y)[i + (j)]); \
197    } while (0)
198  #define ANALYZE_XY(j)                  \
199    do {                                 \
200      if (tmp[j] != 0) {                 \
201        retval -= VP8LFastSLog2(tmp[j]); \
202        ANALYZE_X_OR_Y(X, j);            \
203      }                                  \
204    } while (0)
205  static float CombinedShannonEntropy_SSE2(const int X[256], const int Y[256]) {
206    int i;
207    double retval = 0.;
208    int sumX, sumXY;
209    int32_t tmp[4];
210    __m128i zero = _mm_setzero_si128();
211    __m128i sumXY_128 = zero;
212    __m128i sumX_128 = zero;
213    for (i = 0; i < 256; i += 4) {
214      const __m128i x = _mm_loadu_si128((const __m128i*)(X + i));
215      const __m128i y = _mm_loadu_si128((const __m128i*)(Y + i));
216      if (_mm_movemask_epi8(_mm_cmpeq_epi32(x, zero)) != 0xFFFF) {
217        const __m128i xy_128 = _mm_add_epi32(x, y);
218        sumXY_128 = _mm_add_epi32(sumXY_128, xy_128);
219        sumX_128 = _mm_add_epi32(sumX_128, x);
220        _mm_storeu_si128((__m128i*)tmp, xy_128);
221        ANALYZE_XY(0);
222        ANALYZE_XY(1);
223        ANALYZE_XY(2);
224        ANALYZE_XY(3);
225      } else {
226        sumXY_128 = _mm_add_epi32(sumXY_128, y);
227        ANALYZE_X_OR_Y(Y, 0);
228        ANALYZE_X_OR_Y(Y, 1);
229        ANALYZE_X_OR_Y(Y, 2);
230        ANALYZE_X_OR_Y(Y, 3);
231      }
232    }
233    _mm_storeu_si128((__m128i*)tmp, sumX_128);
234    sumX = tmp[3] + tmp[2] + tmp[1] + tmp[0];
235    _mm_storeu_si128((__m128i*)tmp, sumXY_128);
236    sumXY = tmp[3] + tmp[2] + tmp[1] + tmp[0];
237    retval += VP8LFastSLog2(sumX) + VP8LFastSLog2(sumXY);
238    return (float)retval;
239  }
240  #undef ANALYZE_X_OR_Y
241  #undef ANALYZE_XY
242  static int VectorMismatch_SSE2(const uint32_t* const array1,
243                                 const uint32_t* const array2, int length) {
244    int match_len;
245    if (length >= 12) {
246      __m128i A0 = _mm_loadu_si128((const __m128i*)&array1[0]);
247      __m128i A1 = _mm_loadu_si128((const __m128i*)&array2[0]);
248      match_len = 0;
249      do {
250        const __m128i cmpA = _mm_cmpeq_epi32(A0, A1);
251        const __m128i B0 =
252            _mm_loadu_si128((const __m128i*)&array1[match_len + 4]);
253        const __m128i B1 =
254            _mm_loadu_si128((const __m128i*)&array2[match_len + 4]);
255        if (_mm_movemask_epi8(cmpA) != 0xffff) break;
256        match_len += 4;
257        {
258          const __m128i cmpB = _mm_cmpeq_epi32(B0, B1);
259          A0 = _mm_loadu_si128((const __m128i*)&array1[match_len + 4]);
260          A1 = _mm_loadu_si128((const __m128i*)&array2[match_len + 4]);
261          if (_mm_movemask_epi8(cmpB) != 0xffff) break;
262          match_len += 4;
263        }
264      } while (match_len + 12 < length);
265    } else {
266      match_len = 0;
267      if (length >= 4 &&
268          _mm_movemask_epi8(_mm_cmpeq_epi32(
269              _mm_loadu_si128((const __m128i*)&array1[0]),
270              _mm_loadu_si128((const __m128i*)&array2[0]))) == 0xffff) {
271        match_len = 4;
272        if (length >= 8 &&
273            _mm_movemask_epi8(_mm_cmpeq_epi32(
274                _mm_loadu_si128((const __m128i*)&array1[4]),
275                _mm_loadu_si128((const __m128i*)&array2[4]))) == 0xffff) {
276          match_len = 8;
277        }
278      }
279    }
280    while (match_len < length && array1[match_len] == array2[match_len]) {
281      ++match_len;
282    }
283    return match_len;
284  }
285  static void BundleColorMap_SSE2(const uint8_t* const row, int width, int xbits,
286                                  uint32_t* dst) {
287    int x;
288    assert(xbits >= 0);
289    assert(xbits <= 3);
290    switch (xbits) {
291      case 0: {
292        const __m128i ff = _mm_set1_epi16((short)0xff00);
293        const __m128i zero = _mm_setzero_si128();
294        for (x = 0; x + 16 <= width; x += 16, dst += 16) {
295          const __m128i in = _mm_loadu_si128((const __m128i*)&row[x]);
296          const __m128i in_lo = _mm_unpacklo_epi8(zero, in);
297          const __m128i dst0 = _mm_unpacklo_epi16(in_lo, ff);
298          const __m128i dst1 = _mm_unpackhi_epi16(in_lo, ff);
299          const __m128i in_hi = _mm_unpackhi_epi8(zero, in);
300          const __m128i dst2 = _mm_unpacklo_epi16(in_hi, ff);
301          const __m128i dst3 = _mm_unpackhi_epi16(in_hi, ff);
302          _mm_storeu_si128((__m128i*)&dst[0], dst0);
303          _mm_storeu_si128((__m128i*)&dst[4], dst1);
304          _mm_storeu_si128((__m128i*)&dst[8], dst2);
305          _mm_storeu_si128((__m128i*)&dst[12], dst3);
306        }
307        break;
308      }
309      case 1: {
310        const __m128i ff = _mm_set1_epi16((short)0xff00);
311        const __m128i mul = _mm_set1_epi16(0x110);
312        for (x = 0; x + 16 <= width; x += 16, dst += 8) {
313          const __m128i in = _mm_loadu_si128((const __m128i*)&row[x]);
314          const __m128i tmp = _mm_mullo_epi16(in, mul);  
315          const __m128i pack = _mm_and_si128(tmp, ff);   
316          const __m128i dst0 = _mm_unpacklo_epi16(pack, ff);
317          const __m128i dst1 = _mm_unpackhi_epi16(pack, ff);
318          _mm_storeu_si128((__m128i*)&dst[0], dst0);
319          _mm_storeu_si128((__m128i*)&dst[4], dst1);
320        }
321        break;
322      }
323      case 2: {
324        const __m128i mask_or = _mm_set1_epi32(0xff000000);
325        const __m128i mul_cst = _mm_set1_epi16(0x0104);
326        const __m128i mask_mul = _mm_set1_epi16(0x0f00);
327        for (x = 0; x + 16 <= width; x += 16, dst += 4) {
328          const __m128i in = _mm_loadu_si128((const __m128i*)&row[x]);
329          const __m128i mul = _mm_mullo_epi16(in, mul_cst);  
330          const __m128i tmp = _mm_and_si128(mul, mask_mul);  
331          const __m128i shift = _mm_srli_epi32(tmp, 12);     
332          const __m128i pack = _mm_or_si128(shift, tmp);     
333          const __m128i res = _mm_or_si128(pack, mask_or);
334          _mm_storeu_si128((__m128i*)dst, res);
335        }
336        break;
337      }
338      default: {
339        assert(xbits == 3);
340        for (x = 0; x + 16 <= width; x += 16, dst += 2) {
341          const __m128i in = _mm_loadu_si128((const __m128i*)&row[x]);
342          const __m128i shift = _mm_slli_epi64(in, 7);
343          const uint32_t move = _mm_movemask_epi8(shift);
344          dst[0] = 0xff000000 | ((move & 0xff) << 8);
345          dst[1] = 0xff000000 | (move & 0xff00);
346        }
347        break;
348      }
349    }
350    if (x != width) {
351      VP8LBundleColorMap_C(row + x, width - x, xbits, dst);
352    }
353  }
354  static WEBP_INLINE void Average2_m128i(const __m128i* const a0,
355                                         const __m128i* const a1,
356                                         __m128i* const avg) {
357    const __m128i ones = _mm_set1_epi8(1);
358    const __m128i avg1 = _mm_avg_epu8(*a0, *a1);
359    const __m128i one = _mm_and_si128(_mm_xor_si128(*a0, *a1), ones);
360    *avg = _mm_sub_epi8(avg1, one);
361  }
362  static void PredictorSub0_SSE2(const uint32_t* in, const uint32_t* upper,
363                                 int num_pixels, uint32_t* out) {
364    int i;
365    const __m128i black = _mm_set1_epi32(ARGB_BLACK);
366    for (i = 0; i + 4 <= num_pixels; i += 4) {
367      const __m128i src = _mm_loadu_si128((const __m128i*)&in[i]);
368      const __m128i res = _mm_sub_epi8(src, black);
369      _mm_storeu_si128((__m128i*)&out[i], res);
370    }
371    if (i != num_pixels) {
372      VP8LPredictorsSub_C[0](in + i, NULL, num_pixels - i, out + i);
373    }
374    (void)upper;
375  }
376  #define GENERATE_PREDICTOR_1(X, IN)                                           \
377  static void PredictorSub##X##_SSE2(const uint32_t* in, const uint32_t* upper, \
378                                     int num_pixels, uint32_t* out) {           \
379    int i;                                                                      \
380    for (i = 0; i + 4 <= num_pixels; i += 4) {                                  \
381      const __m128i src = _mm_loadu_si128((const __m128i*)&in[i]);              \
382      const __m128i pred = _mm_loadu_si128((const __m128i*)&(IN));              \
383      const __m128i res = _mm_sub_epi8(src, pred);                              \
384      _mm_storeu_si128((__m128i*)&out[i], res);                                 \
385    }                                                                           \
386    if (i != num_pixels) {                                                      \
387      VP8LPredictorsSub_C[(X)](in + i, upper + i, num_pixels - i, out + i);     \
388    }                                                                           \
389  }
390  GENERATE_PREDICTOR_1(1, in[i - 1])       
391  GENERATE_PREDICTOR_1(2, upper[i])        
392  GENERATE_PREDICTOR_1(3, upper[i + 1])    
393  GENERATE_PREDICTOR_1(4, upper[i - 1])    
394  #undef GENERATE_PREDICTOR_1
395  static void PredictorSub5_SSE2(const uint32_t* in, const uint32_t* upper,
396                                 int num_pixels, uint32_t* out) {
397    int i;
398    for (i = 0; i + 4 <= num_pixels; i += 4) {
399      const __m128i L = _mm_loadu_si128((const __m128i*)&in[i - 1]);
400      const __m128i T = _mm_loadu_si128((const __m128i*)&upper[i]);
401      const __m128i TR = _mm_loadu_si128((const __m128i*)&upper[i + 1]);
402      const __m128i src = _mm_loadu_si128((const __m128i*)&in[i]);
403      __m128i avg, pred, res;
404      Average2_m128i(&L, &TR, &avg);
405      Average2_m128i(&avg, &T, &pred);
406      res = _mm_sub_epi8(src, pred);
407      _mm_storeu_si128((__m128i*)&out[i], res);
408    }
409    if (i != num_pixels) {
410      VP8LPredictorsSub_C[5](in + i, upper + i, num_pixels - i, out + i);
411    }
412  }
413  #define GENERATE_PREDICTOR_2(X, A, B)                                         \
414  static void PredictorSub##X##_SSE2(const uint32_t* in, const uint32_t* upper, \
415                                     int num_pixels, uint32_t* out) {           \
416    int i;                                                                      \
417    for (i = 0; i + 4 <= num_pixels; i += 4) {                                  \
418      const __m128i tA = _mm_loadu_si128((const __m128i*)&(A));                 \
419      const __m128i tB = _mm_loadu_si128((const __m128i*)&(B));                 \
420      const __m128i src = _mm_loadu_si128((const __m128i*)&in[i]);              \
421      __m128i pred, res;                                                        \
422      Average2_m128i(&tA, &tB, &pred);                                          \
423      res = _mm_sub_epi8(src, pred);                                            \
424      _mm_storeu_si128((__m128i*)&out[i], res);                                 \
425    }                                                                           \
426    if (i != num_pixels) {                                                      \
427      VP8LPredictorsSub_C[(X)](in + i, upper + i, num_pixels - i, out + i);     \
428    }                                                                           \
429  }
430  GENERATE_PREDICTOR_2(6, in[i - 1], upper[i - 1])   
431  GENERATE_PREDICTOR_2(7, in[i - 1], upper[i])       
432  GENERATE_PREDICTOR_2(8, upper[i - 1], upper[i])    
433  GENERATE_PREDICTOR_2(9, upper[i], upper[i + 1])    
434  #undef GENERATE_PREDICTOR_2
435  static void PredictorSub10_SSE2(const uint32_t* in, const uint32_t* upper,
436                                  int num_pixels, uint32_t* out) {
437    int i;
438    for (i = 0; i + 4 <= num_pixels; i += 4) {
439      const __m128i L = _mm_loadu_si128((const __m128i*)&in[i - 1]);
440      const __m128i src = _mm_loadu_si128((const __m128i*)&in[i]);
441      const __m128i TL = _mm_loadu_si128((const __m128i*)&upper[i - 1]);
442      const __m128i T = _mm_loadu_si128((const __m128i*)&upper[i]);
443      const __m128i TR = _mm_loadu_si128((const __m128i*)&upper[i + 1]);
444      __m128i avgTTR, avgLTL, avg, res;
445      Average2_m128i(&T, &TR, &avgTTR);
446      Average2_m128i(&L, &TL, &avgLTL);
447      Average2_m128i(&avgTTR, &avgLTL, &avg);
448      res = _mm_sub_epi8(src, avg);
449      _mm_storeu_si128((__m128i*)&out[i], res);
450    }
451    if (i != num_pixels) {
452      VP8LPredictorsSub_C[10](in + i, upper + i, num_pixels - i, out + i);
453    }
454  }
455  static void GetSumAbsDiff32_SSE2(const __m128i* const A, const __m128i* const B,
456                                   __m128i* const out) {
457    const __m128i A_lo = _mm_unpacklo_epi32(*A, *A);
458    const __m128i B_lo = _mm_unpacklo_epi32(*B, *A);
459    const __m128i A_hi = _mm_unpackhi_epi32(*A, *A);
460    const __m128i B_hi = _mm_unpackhi_epi32(*B, *A);
461    const __m128i s_lo = _mm_sad_epu8(A_lo, B_lo);
462    const __m128i s_hi = _mm_sad_epu8(A_hi, B_hi);
463    *out = _mm_packs_epi32(s_lo, s_hi);
464  }
465  static void PredictorSub11_SSE2(const uint32_t* in, const uint32_t* upper,
466                                  int num_pixels, uint32_t* out) {
467    int i;
468    for (i = 0; i + 4 <= num_pixels; i += 4) {
469      const __m128i L = _mm_loadu_si128((const __m128i*)&in[i - 1]);
470      const __m128i T = _mm_loadu_si128((const __m128i*)&upper[i]);
471      const __m128i TL = _mm_loadu_si128((const __m128i*)&upper[i - 1]);
472      const __m128i src = _mm_loadu_si128((const __m128i*)&in[i]);
473      __m128i pa, pb;
474      GetSumAbsDiff32_SSE2(&T, &TL, &pa);   
475      GetSumAbsDiff32_SSE2(&L, &TL, &pb);   
476      {
477        const __m128i mask = _mm_cmpgt_epi32(pb, pa);
478        const __m128i A = _mm_and_si128(mask, L);
479        const __m128i B = _mm_andnot_si128(mask, T);
480        const __m128i pred = _mm_or_si128(A, B);    
481        const __m128i res = _mm_sub_epi8(src, pred);
482        _mm_storeu_si128((__m128i*)&out[i], res);
483      }
484    }
485    if (i != num_pixels) {
486      VP8LPredictorsSub_C[11](in + i, upper + i, num_pixels - i, out + i);
487    }
488  }
489  static void PredictorSub12_SSE2(const uint32_t* in, const uint32_t* upper,
490                                  int num_pixels, uint32_t* out) {
491    int i;
492    const __m128i zero = _mm_setzero_si128();
493    for (i = 0; i + 4 <= num_pixels; i += 4) {
494      const __m128i src = _mm_loadu_si128((const __m128i*)&in[i]);
495      const __m128i L = _mm_loadu_si128((const __m128i*)&in[i - 1]);
496      const __m128i L_lo = _mm_unpacklo_epi8(L, zero);
497      const __m128i L_hi = _mm_unpackhi_epi8(L, zero);
498      const __m128i T = _mm_loadu_si128((const __m128i*)&upper[i]);
499      const __m128i T_lo = _mm_unpacklo_epi8(T, zero);
500      const __m128i T_hi = _mm_unpackhi_epi8(T, zero);
501      const __m128i TL = _mm_loadu_si128((const __m128i*)&upper[i - 1]);
502      const __m128i TL_lo = _mm_unpacklo_epi8(TL, zero);
503      const __m128i TL_hi = _mm_unpackhi_epi8(TL, zero);
504      const __m128i diff_lo = _mm_sub_epi16(T_lo, TL_lo);
505      const __m128i diff_hi = _mm_sub_epi16(T_hi, TL_hi);
506      const __m128i pred_lo = _mm_add_epi16(L_lo, diff_lo);
507      const __m128i pred_hi = _mm_add_epi16(L_hi, diff_hi);
508      const __m128i pred = _mm_packus_epi16(pred_lo, pred_hi);
509      const __m128i res = _mm_sub_epi8(src, pred);
510      _mm_storeu_si128((__m128i*)&out[i], res);
511    }
512    if (i != num_pixels) {
513      VP8LPredictorsSub_C[12](in + i, upper + i, num_pixels - i, out + i);
514    }
515  }
516  static void PredictorSub13_SSE2(const uint32_t* in, const uint32_t* upper,
517                                  int num_pixels, uint32_t* out) {
518    int i;
519    const __m128i zero = _mm_setzero_si128();
520    for (i = 0; i + 2 <= num_pixels; i += 2) {
521      const __m128i L = _mm_loadl_epi64((const __m128i*)&in[i - 1]);
522      const __m128i src = _mm_loadl_epi64((const __m128i*)&in[i]);
523      const __m128i T = _mm_loadl_epi64((const __m128i*)&upper[i]);
524      const __m128i TL = _mm_loadl_epi64((const __m128i*)&upper[i - 1]);
525      const __m128i L_lo = _mm_unpacklo_epi8(L, zero);
526      const __m128i T_lo = _mm_unpacklo_epi8(T, zero);
527      const __m128i TL_lo = _mm_unpacklo_epi8(TL, zero);
528      const __m128i sum = _mm_add_epi16(T_lo, L_lo);
529      const __m128i avg = _mm_srli_epi16(sum, 1);
530      const __m128i A1 = _mm_sub_epi16(avg, TL_lo);
531      const __m128i bit_fix = _mm_cmpgt_epi16(TL_lo, avg);
532      const __m128i A2 = _mm_sub_epi16(A1, bit_fix);
533      const __m128i A3 = _mm_srai_epi16(A2, 1);
534      const __m128i A4 = _mm_add_epi16(avg, A3);
535      const __m128i pred = _mm_packus_epi16(A4, A4);
536      const __m128i res = _mm_sub_epi8(src, pred);
537      _mm_storel_epi64((__m128i*)&out[i], res);
538    }
539    if (i != num_pixels) {
540      VP8LPredictorsSub_C[13](in + i, upper + i, num_pixels - i, out + i);
541    }
542  }
543  extern void VP8LEncDspInitSSE2(void);
544  WEBP_TSAN_IGNORE_FUNCTION void VP8LEncDspInitSSE2(void) {
<span onclick='openModal()' class='match'>545    VP8LSubtractGreenFromBlueAndRed = SubtractGreenFromBlueAndRed_SSE2;
546    VP8LTransformColor = TransformColor_SSE2;
547    VP8LCollectColorBlueTransforms = CollectColorBlueTransforms_SSE2;
548    VP8LCollectColorRedTransforms = CollectColorRedTransforms_SSE2;
549    VP8LAddVector = AddVector_SSE2;
550    VP8LAddVectorEq = AddVectorEq_SSE2;
551    VP8LCombinedShannonEntropy = CombinedShannonEntropy_SSE2;
552    VP8LVectorMismatch = VectorMismatch_SSE2;
553    VP8LBundleColorMap = BundleColorMap_SSE2;
</span>554    VP8LPredictorsSub[0] = PredictorSub0_SSE2;
555    VP8LPredictorsSub[1] = PredictorSub1_SSE2;
556    VP8LPredictorsSub[2] = PredictorSub2_SSE2;
557    VP8LPredictorsSub[3] = PredictorSub3_SSE2;
558    VP8LPredictorsSub[4] = PredictorSub4_SSE2;
559    VP8LPredictorsSub[5] = PredictorSub5_SSE2;
560    VP8LPredictorsSub[6] = PredictorSub6_SSE2;
561    VP8LPredictorsSub[7] = PredictorSub7_SSE2;
562    VP8LPredictorsSub[8] = PredictorSub8_SSE2;
563    VP8LPredictorsSub[9] = PredictorSub9_SSE2;
564    VP8LPredictorsSub[10] = PredictorSub10_SSE2;
565    VP8LPredictorsSub[11] = PredictorSub11_SSE2;
566    VP8LPredictorsSub[12] = PredictorSub12_SSE2;
567    VP8LPredictorsSub[13] = PredictorSub13_SSE2;
568    VP8LPredictorsSub[14] = PredictorSub0_SSE2;  
569    VP8LPredictorsSub[15] = PredictorSub0_SSE2;
570  }
571  #else  
572  WEBP_DSP_INIT_STUB(VP8LEncDspInitSSE2)
573  #endif  
</code></pre>
        </div>
        <div class="column">
            <h3>PINRemoteImage-MDEwOlJlcG9zaXRvcnkzOTUzNzEwMw==-flat-webpinfo.c</h3>
            <pre><code>1  #include <assert.h>
2  #include <stdio.h>
3  #ifdef HAVE_CONFIG_H
4  #include "webp/config.h"
5  #endif
6  #include "../imageio/imageio_util.h"
7  #include "./unicode.h"
8  #include "webp/decode.h"
9  #include "webp/format_constants.h"
10  #include "webp/mux_types.h"
11  #if defined(_MSC_VER) && _MSC_VER < 1900
12  #define snprintf _snprintf
13  #endif
14  #define LOG_ERROR(MESSAGE)                     \
15    do {                                         \
16      if (webp_info->show_diagnosis_) {          \
17        fprintf(stderr, "Error: %s\n", MESSAGE); \
18      }                                          \
19    } while (0)
20  #define LOG_WARN(MESSAGE)                        \
21    do {                                           \
22      if (webp_info->show_diagnosis_) {            \
23        fprintf(stderr, "Warning: %s\n", MESSAGE); \
24      }                                            \
25    } while (0)
26  static const char* const kFormats[3] = {
27    "Unknown",
28    "Lossy",
29    "Lossless"
30  };
31  static const char* const kLosslessTransforms[4] = {
32    "Predictor",
33    "Cross Color",
34    "Subtract Green",
35    "Color Indexing"
36  };
37  static const char* const kAlphaFilterMethods[4] = {
38    "None",
39    "Horizontal",
40    "Vertical",
41    "Gradient"
42  };
43  typedef enum {
44    WEBP_INFO_OK = 0,
45    WEBP_INFO_TRUNCATED_DATA,
46    WEBP_INFO_PARSE_ERROR,
47    WEBP_INFO_INVALID_PARAM,
48    WEBP_INFO_BITSTREAM_ERROR,
49    WEBP_INFO_MISSING_DATA,
50    WEBP_INFO_INVALID_COMMAND
51  } WebPInfoStatus;
52  typedef enum ChunkID {
53    CHUNK_VP8,
54    CHUNK_VP8L,
55    CHUNK_VP8X,
56    CHUNK_ALPHA,
57    CHUNK_ANIM,
58    CHUNK_ANMF,
59    CHUNK_ICCP,
60    CHUNK_EXIF,
61    CHUNK_XMP,
62    CHUNK_UNKNOWN,
63    CHUNK_TYPES = CHUNK_UNKNOWN
64  } ChunkID;
65  typedef struct {
66    size_t start_;
67    size_t end_;
68    const uint8_t* buf_;
69  } MemBuffer;
70  typedef struct {
71    size_t offset_;
72    size_t size_;
73    const uint8_t* payload_;
74    ChunkID id_;
75  } ChunkData;
76  typedef struct WebPInfo {
77    int canvas_width_;
78    int canvas_height_;
79    int loop_count_;
80    int num_frames_;
81    int chunk_counts_[CHUNK_TYPES];
82    int anmf_subchunk_counts_[3];  
83    uint32_t bgcolor_;
84    int feature_flags_;
85    int has_alpha_;
86    int frame_width_, frame_height_;
87    size_t anim_frame_data_size_;
88    int is_processing_anim_frame_, seen_alpha_subchunk_, seen_image_subchunk_;
89    int quiet_, show_diagnosis_, show_summary_;
90    int parse_bitstream_;
91  } WebPInfo;
92  static void WebPInfoInit(WebPInfo* const webp_info) {
93    memset(webp_info, 0, sizeof(*webp_info));
94  }
95  static const char kWebPChunkTags[CHUNK_TYPES][4] = {
96    { 'V', 'P', '8', ' ' },
97    { 'V', 'P', '8', 'L' },
98    { 'V', 'P', '8', 'X' },
99    { 'A', 'L', 'P', 'H' },
100    { 'A', 'N', 'I', 'M' },
101    { 'A', 'N', 'M', 'F' },
102    { 'I', 'C', 'C', 'P' },
103    { 'E', 'X', 'I', 'F' },
104    { 'X', 'M', 'P', ' ' },
105  };
106  static int GetLE16(const uint8_t* const data) {
107    return (data[0] << 0) | (data[1] << 8);
108  }
109  static int GetLE24(const uint8_t* const data) {
110    return GetLE16(data) | (data[2] << 16);
111  }
112  static uint32_t GetLE32(const uint8_t* const data) {
113    return GetLE16(data) | ((uint32_t)GetLE16(data + 2) << 16);
114  }
115  static int ReadLE16(const uint8_t** data) {
116    const int val = GetLE16(*data);
117    *data += 2;
118    return val;
119  }
120  static int ReadLE24(const uint8_t** data) {
121    const int val = GetLE24(*data);
122    *data += 3;
123    return val;
124  }
125  static uint32_t ReadLE32(const uint8_t** data) {
126    const uint32_t val = GetLE32(*data);
127    *data += 4;
128    return val;
129  }
130  static int ReadFileToWebPData(const char* const filename,
131                                WebPData* const webp_data) {
132    const uint8_t* data;
133    size_t size;
134    if (!ImgIoUtilReadFile(filename, &data, &size)) return 0;
135    webp_data->bytes = data;
136    webp_data->size = size;
137    return 1;
138  }
139  static void InitMemBuffer(MemBuffer* const mem, const WebPData* webp_data) {
140    mem->buf_ = webp_data->bytes;
141    mem->start_ = 0;
142    mem->end_ = webp_data->size;
143  }
144  static size_t MemDataSize(const MemBuffer* const mem) {
145    return (mem->end_ - mem->start_);
146  }
147  static const uint8_t* GetBuffer(MemBuffer* const mem) {
148    return mem->buf_ + mem->start_;
149  }
150  static void Skip(MemBuffer* const mem, size_t size) {
151    mem->start_ += size;
152  }
153  static uint32_t ReadMemBufLE32(MemBuffer* const mem) {
154    const uint8_t* const data = mem->buf_ + mem->start_;
155    const uint32_t val = GetLE32(data);
156    assert(MemDataSize(mem) >= 4);
157    Skip(mem, 4);
158    return val;
159  }
160  static int GetBits(const uint8_t* const data, size_t data_size, size_t nb,
161                     int* val, uint64_t* const bit_pos) {
162    *val = 0;
163    while (nb-- > 0) {
164      const uint64_t p = (*bit_pos)++;
165      if ((p >> 3) >= data_size) {
166        return 0;
167      } else {
168        const int bit = !!(data[p >> 3] & (128 >> ((p & 7))));
169        *val = (*val << 1) | bit;
170      }
171    }
172    return 1;
173  }
174  static int GetSignedBits(const uint8_t* const data, size_t data_size, size_t nb,
175                           int* val, uint64_t* const bit_pos) {
176    int sign;
177    if (!GetBits(data, data_size, nb, val, bit_pos)) return 0;
178    if (!GetBits(data, data_size, 1, &sign, bit_pos)) return 0;
179    if (sign) *val = -(*val);
180    return 1;
181  }
182  #define GET_BITS(v, n)                                 \
183    do {                                                 \
184      if (!GetBits(data, data_size, n, &(v), bit_pos)) { \
185        LOG_ERROR("Truncated lossy bitstream.");         \
186        return WEBP_INFO_TRUNCATED_DATA;                 \
187      }                                                  \
188    } while (0)
189  #define GET_SIGNED_BITS(v, n)                                \
190    do {                                                       \
191      if (!GetSignedBits(data, data_size, n, &(v), bit_pos)) { \
192        LOG_ERROR("Truncated lossy bitstream.");               \
193        return WEBP_INFO_TRUNCATED_DATA;                       \
194      }                                                        \
195    } while (0)
196  static WebPInfoStatus ParseLossySegmentHeader(const WebPInfo* const webp_info,
197                                                const uint8_t* const data,
198                                                size_t data_size,
199                                                uint64_t* const bit_pos) {
200    int use_segment;
201    GET_BITS(use_segment, 1);
202    printf("  Use segment:      %d\n", use_segment);
203    if (use_segment) {
204      int update_map, update_data;
205      GET_BITS(update_map, 1);
206      GET_BITS(update_data, 1);
207      printf("  Update map:       %d\n"
208             "  Update data:      %d\n",
209             update_map, update_data);
210      if (update_data) {
211        int i, a_delta;
212        int quantizer[4] = {0, 0, 0, 0};
213        int filter_strength[4] = {0, 0, 0, 0};
214        GET_BITS(a_delta, 1);
215        printf("  Absolute delta:   %d\n", a_delta);
216        for (i = 0; i < 4; ++i) {
217          int bit;
218          GET_BITS(bit, 1);
219          if (bit) GET_SIGNED_BITS(quantizer[i], 7);
220        }
221        for (i = 0; i < 4; ++i) {
222          int bit;
223          GET_BITS(bit, 1);
224          if (bit) GET_SIGNED_BITS(filter_strength[i], 6);
225        }
226        printf("  Quantizer:        %d %d %d %d\n", quantizer[0], quantizer[1],
227               quantizer[2], quantizer[3]);
228        printf("  Filter strength:  %d %d %d %d\n", filter_strength[0],
229               filter_strength[1], filter_strength[2], filter_strength[3]);
230      }
231      if (update_map) {
232        int i;
233        int prob_segment[3] = {255, 255, 255};
234        for (i = 0; i < 3; ++i) {
235          int bit;
236          GET_BITS(bit, 1);
237          if (bit) GET_BITS(prob_segment[i], 8);
238        }
239        printf("  Prob segment:     %d %d %d\n",
240               prob_segment[0], prob_segment[1], prob_segment[2]);
241      }
242    }
243    return WEBP_INFO_OK;
244  }
245  static WebPInfoStatus ParseLossyFilterHeader(const WebPInfo* const webp_info,
246                                               const uint8_t* const data,
247                                               size_t data_size,
248                                               uint64_t* const bit_pos) {
249    int simple_filter, level, sharpness, use_lf_delta;
250    GET_BITS(simple_filter, 1);
251    GET_BITS(level, 6);
252    GET_BITS(sharpness, 3);
253    GET_BITS(use_lf_delta, 1);
254    printf("  Simple filter:    %d\n", simple_filter);
255    printf("  Level:            %d\n", level);
256    printf("  Sharpness:        %d\n", sharpness);
257    printf("  Use lf delta:     %d\n", use_lf_delta);
258    if (use_lf_delta) {
259      int update;
260      GET_BITS(update, 1);
261      printf("  Update lf delta:  %d\n", update);
262      if (update) {
263        int i;
264        for (i = 0; i < 4 + 4; ++i) {
265          int temp;
266          GET_BITS(temp, 1);
267          if (temp) GET_BITS(temp, 7);
268        }
269      }
270    }
271    return WEBP_INFO_OK;
272  }
273  static WebPInfoStatus ParseLossyHeader(const ChunkData* const chunk_data,
274                                         const WebPInfo* const webp_info) {
275    const uint8_t* data = chunk_data->payload_;
276    size_t data_size = chunk_data->size_ - CHUNK_HEADER_SIZE;
277    const uint32_t bits = (uint32_t)data[0] | (data[1] << 8) | (data[2] << 16);
278    const int key_frame = !(bits & 1);
279    const int profile = (bits >> 1) & 7;
280    const int display = (bits >> 4) & 1;
281    const uint32_t partition0_length = (bits >> 5);
282    WebPInfoStatus status = WEBP_INFO_OK;
283    uint64_t bit_position = 0;
284    uint64_t* const bit_pos = &bit_position;
285    int colorspace, clamp_type;
286    printf("  Parsing lossy bitstream...\n");
287    assert(chunk_data->size_ >= CHUNK_HEADER_SIZE + 10);
288    if (profile > 3) {
289      LOG_ERROR("Unknown profile.");
290      return WEBP_INFO_BITSTREAM_ERROR;
291    }
292    if (!display) {
293      LOG_ERROR("Frame is not displayable.");
294      return WEBP_INFO_BITSTREAM_ERROR;
295    }
296    data += 3;
297    data_size -= 3;
298    printf("  Key frame:        %s\n"
299           "  Profile:          %d\n"
300           "  Display:          %s\n"
301           "  Part. 0 length:   %d\n",
302           key_frame ? "Yes" : "No", profile,
303           display ? "Yes" : "No", partition0_length);
304    if (key_frame) {
305      if (!(data[0] == 0x9d && data[1] == 0x01 && data[2] == 0x2a)) {
306        LOG_ERROR("Invalid lossy bitstream signature.");
307        return WEBP_INFO_BITSTREAM_ERROR;
308      }
309      printf("  Width:            %d\n"
310             "  X scale:          %d\n"
311             "  Height:           %d\n"
312             "  Y scale:          %d\n",
313             ((data[4] << 8) | data[3]) & 0x3fff, data[4] >> 6,
314             ((data[6] << 8) | data[5]) & 0x3fff, data[6] >> 6);
315      data += 7;
316      data_size -= 7;
317    } else {
318      LOG_ERROR("Non-keyframe detected in lossy bitstream.");
319      return WEBP_INFO_BITSTREAM_ERROR;
320    }
321    if (partition0_length >= data_size) {
322      LOG_ERROR("Bad partition length.");
323      return WEBP_INFO_BITSTREAM_ERROR;
324    }
325    GET_BITS(colorspace, 1);
326    GET_BITS(clamp_type, 1);
327    printf("  Color space:      %d\n", colorspace);
328    printf("  Clamp type:       %d\n", clamp_type);
329    status = ParseLossySegmentHeader(webp_info, data, data_size, bit_pos);
330    if (status != WEBP_INFO_OK) return status;
331    status = ParseLossyFilterHeader(webp_info, data, data_size, bit_pos);
332    if (status != WEBP_INFO_OK) return status;
333    {  
334      const uint8_t* part_size = data + partition0_length;
335      int num_parts, i;
336      size_t part_data_size;
337      GET_BITS(num_parts, 2);
338      num_parts = 1 << num_parts;
339      if ((int)(data_size - partition0_length) < (num_parts - 1) * 3) {
340        LOG_ERROR("Truncated lossy bitstream.");
341        return WEBP_INFO_TRUNCATED_DATA;
342      }
343      part_data_size = data_size - partition0_length - (num_parts - 1) * 3;
344      printf("  Total partitions: %d\n", num_parts);
345      for (i = 1; i < num_parts; ++i) {
346        const size_t psize =
347            part_size[0] | (part_size[1] << 8) | (part_size[2] << 16);
348        if (psize > part_data_size) {
349          LOG_ERROR("Truncated partition.");
350          return WEBP_INFO_TRUNCATED_DATA;
351        }
352        printf("  Part. %d length:   %d\n", i, (int)psize);
353        part_data_size -= psize;
354        part_size += 3;
355      }
356    }
357    {
358      int base_q, bit;
359      int dq_y1_dc = 0, dq_y2_dc = 0, dq_y2_ac = 0, dq_uv_dc = 0, dq_uv_ac = 0;
360      GET_BITS(base_q, 7);
361      GET_BITS(bit, 1);
362      if (bit) GET_SIGNED_BITS(dq_y1_dc, 4);
363      GET_BITS(bit, 1);
364      if (bit) GET_SIGNED_BITS(dq_y2_dc, 4);
365      GET_BITS(bit, 1);
366      if (bit) GET_SIGNED_BITS(dq_y2_ac, 4);
367      GET_BITS(bit, 1);
368      if (bit) GET_SIGNED_BITS(dq_uv_dc, 4);
369      GET_BITS(bit, 1);
370      if (bit) GET_SIGNED_BITS(dq_uv_ac, 4);
371      printf("  Base Q:           %d\n", base_q);
372      printf("  DQ Y1 DC:         %d\n", dq_y1_dc);
373      printf("  DQ Y2 DC:         %d\n", dq_y2_dc);
374      printf("  DQ Y2 AC:         %d\n", dq_y2_ac);
375      printf("  DQ UV DC:         %d\n", dq_uv_dc);
376      printf("  DQ UV AC:         %d\n", dq_uv_ac);
377    }
378    if ((*bit_pos >> 3) >= partition0_length) {
379      LOG_ERROR("Truncated lossy bitstream.");
380      return WEBP_INFO_TRUNCATED_DATA;
381    }
382    return WEBP_INFO_OK;
383  }
384  static int LLGetBits(const uint8_t* const data, size_t data_size, size_t nb,
385                       int* val, uint64_t* const bit_pos) {
386    uint32_t i = 0;
387    *val = 0;
388    while (i < nb) {
389      const uint64_t p = (*bit_pos)++;
390      if ((p >> 3) >= data_size) {
391        return 0;
392      } else {
393        const int bit = !!(data[p >> 3] & (1 << ((p & 7))));
394        *val = *val | (bit << i);
395        ++i;
396      }
397    }
398    return 1;
399  }
400  #define LL_GET_BITS(v, n)                                \
401    do {                                                   \
402      if (!LLGetBits(data, data_size, n, &(v), bit_pos)) { \
403        LOG_ERROR("Truncated lossless bitstream.");        \
404        return WEBP_INFO_TRUNCATED_DATA;                   \
405      }                                                    \
406    } while (0)
407  static WebPInfoStatus ParseLosslessTransform(WebPInfo* const webp_info,
408                                               const uint8_t* const data,
409                                               size_t data_size,
410                                               uint64_t* const  bit_pos) {
411    int use_transform, block_size, n_colors;
412    LL_GET_BITS(use_transform, 1);
413    printf("  Use transform:    %s\n", use_transform ? "Yes" : "No");
414    if (use_transform) {
415      int type;
416      LL_GET_BITS(type, 2);
417      printf("  1st transform:    %s (%d)\n", kLosslessTransforms[type], type);
418      switch (type) {
419        case PREDICTOR_TRANSFORM:
420        case CROSS_COLOR_TRANSFORM:
421          LL_GET_BITS(block_size, 3);
422          block_size = 1 << (block_size + 2);
423          printf("  Tran. block size: %d\n", block_size);
424          break;
425        case COLOR_INDEXING_TRANSFORM:
426          LL_GET_BITS(n_colors, 8);
427          n_colors += 1;
428          printf("  No. of colors:    %d\n", n_colors);
429          break;
430        default: break;
431      }
432    }
433    return WEBP_INFO_OK;
434  }
435  static WebPInfoStatus ParseLosslessHeader(const ChunkData* const chunk_data,
436                                            WebPInfo* const webp_info) {
437    const uint8_t* data = chunk_data->payload_;
438    size_t data_size = chunk_data->size_ - CHUNK_HEADER_SIZE;
439    uint64_t bit_position = 0;
440    uint64_t* const bit_pos = &bit_position;
441    WebPInfoStatus status;
442    printf("  Parsing lossless bitstream...\n");
443    if (data_size < VP8L_FRAME_HEADER_SIZE) {
444      LOG_ERROR("Truncated lossless bitstream.");
445      return WEBP_INFO_TRUNCATED_DATA;
446    }
447    if (data[0] != VP8L_MAGIC_BYTE) {
448      LOG_ERROR("Invalid lossless bitstream signature.");
449      return WEBP_INFO_BITSTREAM_ERROR;
450    }
451    data += 1;
452    data_size -= 1;
453    {
454      int width, height, has_alpha, version;
455      LL_GET_BITS(width, 14);
456      LL_GET_BITS(height, 14);
457      LL_GET_BITS(has_alpha, 1);
458      LL_GET_BITS(version, 3);
459      width += 1;
460      height += 1;
461      printf("  Width:            %d\n", width);
462      printf("  Height:           %d\n", height);
463      printf("  Alpha:            %d\n", has_alpha);
464      printf("  Version:          %d\n", version);
465    }
466    status = ParseLosslessTransform(webp_info, data, data_size, bit_pos);
467    if (status != WEBP_INFO_OK) return status;
468    return WEBP_INFO_OK;
469  }
470  static WebPInfoStatus ParseAlphaHeader(const ChunkData* const chunk_data,
471                                         WebPInfo* const webp_info) {
472    const uint8_t* data = chunk_data->payload_;
473    size_t data_size = chunk_data->size_ - CHUNK_HEADER_SIZE;
474    if (data_size <= ALPHA_HEADER_LEN) {
475      LOG_ERROR("Truncated ALPH chunk.");
476      return WEBP_INFO_TRUNCATED_DATA;
477    }
478    printf("  Parsing ALPH chunk...\n");
479    {
480      const int compression_method = (data[0] >> 0) & 0x03;
481      const int filter = (data[0] >> 2) & 0x03;
482      const int pre_processing = (data[0] >> 4) & 0x03;
483      const int reserved_bits = (data[0] >> 6) & 0x03;
484      printf("  Compression:      %d\n", compression_method);
485      printf("  Filter:           %s (%d)\n",
486             kAlphaFilterMethods[filter], filter);
487      printf("  Pre-processing:   %d\n", pre_processing);
488      if (compression_method > ALPHA_LOSSLESS_COMPRESSION) {
489        LOG_ERROR("Invalid Alpha compression method.");
490        return WEBP_INFO_BITSTREAM_ERROR;
491      }
492      if (pre_processing > ALPHA_PREPROCESSED_LEVELS) {
493        LOG_ERROR("Invalid Alpha pre-processing method.");
494        return WEBP_INFO_BITSTREAM_ERROR;
495      }
496      if (reserved_bits != 0) {
497        LOG_WARN("Reserved bits in ALPH chunk header are not all 0.");
498      }
499      data += ALPHA_HEADER_LEN;
500      data_size -= ALPHA_HEADER_LEN;
501      if (compression_method == ALPHA_LOSSLESS_COMPRESSION) {
502        uint64_t bit_pos = 0;
503        WebPInfoStatus status =
504            ParseLosslessTransform(webp_info, data, data_size, &bit_pos);
505        if (status != WEBP_INFO_OK) return status;
506      }
507    }
508    return WEBP_INFO_OK;
509  }
510  static WebPInfoStatus ParseRIFFHeader(const WebPInfo* const webp_info,
511                                        MemBuffer* const mem) {
512    const size_t min_size = RIFF_HEADER_SIZE + CHUNK_HEADER_SIZE;
513    size_t riff_size;
514    if (MemDataSize(mem) < min_size) {
515      LOG_ERROR("Truncated data detected when parsing RIFF header.");
516      return WEBP_INFO_TRUNCATED_DATA;
517    }
518    if (memcmp(GetBuffer(mem), "RIFF", CHUNK_SIZE_BYTES) ||
519        memcmp(GetBuffer(mem) + CHUNK_HEADER_SIZE, "WEBP", CHUNK_SIZE_BYTES)) {
520      LOG_ERROR("Corrupted RIFF header.");
521      return WEBP_INFO_PARSE_ERROR;
522    }
523    riff_size = GetLE32(GetBuffer(mem) + TAG_SIZE);
524    if (riff_size < CHUNK_HEADER_SIZE) {
525      LOG_ERROR("RIFF size is too small.");
526      return WEBP_INFO_PARSE_ERROR;
527    }
528    if (riff_size > MAX_CHUNK_PAYLOAD) {
529      LOG_ERROR("RIFF size is over limit.");
530      return WEBP_INFO_PARSE_ERROR;
531    }
532    riff_size += CHUNK_HEADER_SIZE;
533    if (!webp_info->quiet_) {
534      printf("RIFF HEADER:\n");
535      printf("  File size: %6d\n", (int)riff_size);
536    }
537    if (riff_size < mem->end_) {
538      LOG_WARN("RIFF size is smaller than the file size.");
539      mem->end_ = riff_size;
540    } else if (riff_size > mem->end_) {
541      LOG_ERROR("Truncated data detected when parsing RIFF payload.");
542      return WEBP_INFO_TRUNCATED_DATA;
543    }
544    Skip(mem, RIFF_HEADER_SIZE);
545    return WEBP_INFO_OK;
546  }
547  static WebPInfoStatus ParseChunk(const WebPInfo* const webp_info,
548                                   MemBuffer* const mem,
549                                   ChunkData* const chunk_data) {
550    memset(chunk_data, 0, sizeof(*chunk_data));
551    if (MemDataSize(mem) < CHUNK_HEADER_SIZE) {
552      LOG_ERROR("Truncated data detected when parsing chunk header.");
553      return WEBP_INFO_TRUNCATED_DATA;
554    } else {
555      const size_t chunk_start_offset = mem->start_;
556      const uint32_t fourcc = ReadMemBufLE32(mem);
557      const uint32_t payload_size = ReadMemBufLE32(mem);
558      const uint32_t payload_size_padded = payload_size + (payload_size & 1);
559      const size_t chunk_size = CHUNK_HEADER_SIZE + payload_size_padded;
560      int i;
561      if (payload_size > MAX_CHUNK_PAYLOAD) {
562        LOG_ERROR("Size of chunk payload is over limit.");
563        return WEBP_INFO_INVALID_PARAM;
564      }
565      if (payload_size_padded > MemDataSize(mem)){
566        LOG_ERROR("Truncated data detected when parsing chunk payload.");
567        return WEBP_INFO_TRUNCATED_DATA;
568      }
569      for (i = 0; i < CHUNK_TYPES; ++i) {
570        if (!memcmp(kWebPChunkTags[i], &fourcc, TAG_SIZE)) break;
571      }
572      chunk_data->offset_ = chunk_start_offset;
573      chunk_data->size_ = chunk_size;
574      chunk_data->id_ = (ChunkID)i;
575      chunk_data->payload_ = GetBuffer(mem);
576      if (chunk_data->id_ == CHUNK_ANMF) {
577        if (payload_size != payload_size_padded) {
578          LOG_ERROR("ANMF chunk size should always be even.");
579          return WEBP_INFO_PARSE_ERROR;
580        }
581        Skip(mem, ANMF_CHUNK_SIZE);
582      } else {
583        Skip(mem, payload_size_padded);
584      }
585      return WEBP_INFO_OK;
586    }
587  }
588  static WebPInfoStatus ProcessVP8XChunk(const ChunkData* const chunk_data,
589                                         WebPInfo* const webp_info) {
590    const uint8_t* data = chunk_data->payload_;
591    if (webp_info->chunk_counts_[CHUNK_VP8] ||
592        webp_info->chunk_counts_[CHUNK_VP8L] ||
593        webp_info->chunk_counts_[CHUNK_VP8X]) {
594      LOG_ERROR("Already seen a VP8/VP8L/VP8X chunk when parsing VP8X chunk.");
595      return WEBP_INFO_PARSE_ERROR;
596    }
597    if (chunk_data->size_ != VP8X_CHUNK_SIZE + CHUNK_HEADER_SIZE) {
598      LOG_ERROR("Corrupted VP8X chunk.");
599      return WEBP_INFO_PARSE_ERROR;
600    }
601    ++webp_info->chunk_counts_[CHUNK_VP8X];
602    webp_info->feature_flags_ = *data;
603    data += 4;
604    webp_info->canvas_width_ = 1 + ReadLE24(&data);
605    webp_info->canvas_height_ = 1 + ReadLE24(&data);
606    if (!webp_info->quiet_) {
607      printf("  ICCP: %d\n  Alpha: %d\n  EXIF: %d\n  XMP: %d\n  Animation: %d\n",
608             (webp_info->feature_flags_ & ICCP_FLAG) != 0,
609             (webp_info->feature_flags_ & ALPHA_FLAG) != 0,
610             (webp_info->feature_flags_ & EXIF_FLAG) != 0,
611             (webp_info->feature_flags_ & XMP_FLAG) != 0,
612             (webp_info->feature_flags_ & ANIMATION_FLAG) != 0);
613      printf("  Canvas size %d x %d\n",
614             webp_info->canvas_width_, webp_info->canvas_height_);
615    }
616    if (webp_info->canvas_width_ > MAX_CANVAS_SIZE) {
617      LOG_WARN("Canvas width is out of range in VP8X chunk.");
618    }
619    if (webp_info->canvas_height_ > MAX_CANVAS_SIZE) {
620      LOG_WARN("Canvas height is out of range in VP8X chunk.");
621    }
622    if ((uint64_t)webp_info->canvas_width_ * webp_info->canvas_height_ >
623        MAX_IMAGE_AREA) {
624      LOG_WARN("Canvas area is out of range in VP8X chunk.");
625    }
626    return WEBP_INFO_OK;
627  }
628  static WebPInfoStatus ProcessANIMChunk(const ChunkData* const chunk_data,
629                                         WebPInfo* const webp_info) {
630    const uint8_t* data = chunk_data->payload_;
631    if (!webp_info->chunk_counts_[CHUNK_VP8X]) {
632      LOG_ERROR("ANIM chunk detected before VP8X chunk.");
633      return WEBP_INFO_PARSE_ERROR;
634    }
635    if (chunk_data->size_ != ANIM_CHUNK_SIZE + CHUNK_HEADER_SIZE) {
636      LOG_ERROR("Corrupted ANIM chunk.");
637      return WEBP_INFO_PARSE_ERROR;
638    }
639    webp_info->bgcolor_ = ReadLE32(&data);
640    webp_info->loop_count_ = ReadLE16(&data);
641    ++webp_info->chunk_counts_[CHUNK_ANIM];
642    if (!webp_info->quiet_) {
643      printf("  Background color:(ARGB) %02x %02x %02x %02x\n",
644             (webp_info->bgcolor_ >> 24) & 0xff,
645             (webp_info->bgcolor_ >> 16) & 0xff,
646             (webp_info->bgcolor_ >> 8) & 0xff,
647             webp_info->bgcolor_ & 0xff);
648      printf("  Loop count      : %d\n", webp_info->loop_count_);
649    }
650    if (webp_info->loop_count_ > MAX_LOOP_COUNT) {
651      LOG_WARN("Loop count is out of range in ANIM chunk.");
652    }
653    return WEBP_INFO_OK;
654  }
655  static WebPInfoStatus ProcessANMFChunk(const ChunkData* const chunk_data,
656                                         WebPInfo* const webp_info) {
657    const uint8_t* data = chunk_data->payload_;
658    int offset_x, offset_y, width, height, duration, blend, dispose, temp;
659    if (webp_info->is_processing_anim_frame_) {
660      LOG_ERROR("ANMF chunk detected within another ANMF chunk.");
661      return WEBP_INFO_PARSE_ERROR;
662    }
663    if (!webp_info->chunk_counts_[CHUNK_ANIM]) {
664      LOG_ERROR("ANMF chunk detected before ANIM chunk.");
665      return WEBP_INFO_PARSE_ERROR;
666    }
667    if (chunk_data->size_ <= CHUNK_HEADER_SIZE + ANMF_CHUNK_SIZE) {
668      LOG_ERROR("Truncated data detected when parsing ANMF chunk.");
669      return WEBP_INFO_TRUNCATED_DATA;
670    }
<span onclick='openModal()' class='match'>671    offset_x = 2 * ReadLE24(&data);
672    offset_y = 2 * ReadLE24(&data);
673    width = 1 + ReadLE24(&data);
674    height = 1 + ReadLE24(&data);
675    duration = ReadLE24(&data);
676    temp = *data;
677    dispose = temp & 1;
678    blend = (temp >> 1) & 1;
679    ++webp_info->chunk_counts_[CHUNK_ANMF];
</span>680    if (!webp_info->quiet_) {
681      printf("  Offset_X: %d\n  Offset_Y: %d\n  Width: %d\n  Height: %d\n"
682             "  Duration: %d\n  Dispose: %d\n  Blend: %d\n",
683             offset_x, offset_y, width, height, duration, dispose, blend);
684    }
685    if (duration > MAX_DURATION) {
686      LOG_ERROR("Invalid duration parameter in ANMF chunk.");
687      return WEBP_INFO_INVALID_PARAM;
688    }
689    if (offset_x > MAX_POSITION_OFFSET || offset_y > MAX_POSITION_OFFSET) {
690      LOG_ERROR("Invalid offset parameters in ANMF chunk.");
691      return WEBP_INFO_INVALID_PARAM;
692    }
693    if ((uint64_t)offset_x + width > (uint64_t)webp_info->canvas_width_ ||
694        (uint64_t)offset_y + height > (uint64_t)webp_info->canvas_height_) {
695      LOG_ERROR("Frame exceeds canvas in ANMF chunk.");
696      return WEBP_INFO_INVALID_PARAM;
697    }
698    webp_info->is_processing_anim_frame_ = 1;
699    webp_info->seen_alpha_subchunk_ = 0;
700    webp_info->seen_image_subchunk_ = 0;
701    webp_info->frame_width_ = width;
702    webp_info->frame_height_ = height;
703    webp_info->anim_frame_data_size_ =
704        chunk_data->size_ - CHUNK_HEADER_SIZE - ANMF_CHUNK_SIZE;
705    return WEBP_INFO_OK;
706  }
707  static WebPInfoStatus ProcessImageChunk(const ChunkData* const chunk_data,
708                                          WebPInfo* const webp_info) {
709    const uint8_t* data = chunk_data->payload_ - CHUNK_HEADER_SIZE;
710    WebPBitstreamFeatures features;
711    const VP8StatusCode vp8_status =
712        WebPGetFeatures(data, chunk_data->size_, &features);
713    if (vp8_status != VP8_STATUS_OK) {
714      LOG_ERROR("VP8/VP8L bitstream error.");
715      return WEBP_INFO_BITSTREAM_ERROR;
716    }
717    if (!webp_info->quiet_) {
718      assert(features.format >= 0 && features.format <= 2);
719      printf("  Width: %d\n  Height: %d\n  Alpha: %d\n  Animation: %d\n"
720             "  Format: %s (%d)\n",
721             features.width, features.height, features.has_alpha,
722             features.has_animation, kFormats[features.format], features.format);
723    }
724    if (webp_info->is_processing_anim_frame_) {
725      ++webp_info->anmf_subchunk_counts_[chunk_data->id_ == CHUNK_VP8 ? 0 : 1];
726      if (chunk_data->id_ == CHUNK_VP8L && webp_info->seen_alpha_subchunk_) {
727        LOG_ERROR("Both VP8L and ALPH sub-chunks are present in an ANMF chunk.");
728        return WEBP_INFO_PARSE_ERROR;
729      }
730      if (webp_info->frame_width_ != features.width ||
731          webp_info->frame_height_ != features.height) {
732        LOG_ERROR("Frame size in VP8/VP8L sub-chunk differs from ANMF header.");
733        return WEBP_INFO_PARSE_ERROR;
734      }
735      if (webp_info->seen_image_subchunk_) {
736        LOG_ERROR("Consecutive VP8/VP8L sub-chunks in an ANMF chunk.");
737        return WEBP_INFO_PARSE_ERROR;
738      }
739      webp_info->seen_image_subchunk_ = 1;
740    } else {
741      if (webp_info->chunk_counts_[CHUNK_VP8] ||
742          webp_info->chunk_counts_[CHUNK_VP8L]) {
743        LOG_ERROR("Multiple VP8/VP8L chunks detected.");
744        return WEBP_INFO_PARSE_ERROR;
745      }
746      if (chunk_data->id_ == CHUNK_VP8L &&
747          webp_info->chunk_counts_[CHUNK_ALPHA]) {
748        LOG_WARN("Both VP8L and ALPH chunks are detected.");
749      }
750      if (webp_info->chunk_counts_[CHUNK_ANIM] ||
751          webp_info->chunk_counts_[CHUNK_ANMF]) {
752        LOG_ERROR("VP8/VP8L chunk and ANIM/ANMF chunk are both detected.");
753        return WEBP_INFO_PARSE_ERROR;
754      }
755      if (webp_info->chunk_counts_[CHUNK_VP8X]) {
756        if (webp_info->canvas_width_ != features.width ||
757            webp_info->canvas_height_ != features.height) {
758          LOG_ERROR("Image size in VP8/VP8L chunk differs from VP8X chunk.");
759          return WEBP_INFO_PARSE_ERROR;
760        }
761      } else {
762        webp_info->canvas_width_ = features.width;
763        webp_info->canvas_height_ = features.height;
764        if (webp_info->canvas_width_ < 1 || webp_info->canvas_height_ < 1 ||
765            webp_info->canvas_width_ > MAX_CANVAS_SIZE ||
766            webp_info->canvas_height_ > MAX_CANVAS_SIZE ||
767            (uint64_t)webp_info->canvas_width_ * webp_info->canvas_height_ >
768                MAX_IMAGE_AREA) {
769          LOG_WARN("Invalid parameters in VP8/VP8L chunk.");
770        }
771      }
772      ++webp_info->chunk_counts_[chunk_data->id_];
773    }
774    ++webp_info->num_frames_;
775    webp_info->has_alpha_ |= features.has_alpha;
776    if (webp_info->parse_bitstream_) {
777      const int is_lossy = (chunk_data->id_ == CHUNK_VP8);
778      const WebPInfoStatus status =
779          is_lossy ? ParseLossyHeader(chunk_data, webp_info)
780                   : ParseLosslessHeader(chunk_data, webp_info);
781      if (status != WEBP_INFO_OK) return status;
782    }
783    return WEBP_INFO_OK;
784  }
785  static WebPInfoStatus ProcessALPHChunk(const ChunkData* const chunk_data,
786                                         WebPInfo* const webp_info) {
787    if (webp_info->is_processing_anim_frame_) {
788      ++webp_info->anmf_subchunk_counts_[2];
789      if (webp_info->seen_alpha_subchunk_) {
790        LOG_ERROR("Consecutive ALPH sub-chunks in an ANMF chunk.");
791        return WEBP_INFO_PARSE_ERROR;
792      }
793      webp_info->seen_alpha_subchunk_ = 1;
794      if (webp_info->seen_image_subchunk_) {
795        LOG_ERROR("ALPHA sub-chunk detected after VP8 sub-chunk "
796                  "in an ANMF chunk.");
797        return WEBP_INFO_PARSE_ERROR;
798      }
799    } else {
800      if (webp_info->chunk_counts_[CHUNK_ANIM] ||
801          webp_info->chunk_counts_[CHUNK_ANMF]) {
802        LOG_ERROR("ALPHA chunk and ANIM/ANMF chunk are both detected.");
803        return WEBP_INFO_PARSE_ERROR;
804      }
805      if (!webp_info->chunk_counts_[CHUNK_VP8X]) {
806        LOG_ERROR("ALPHA chunk detected before VP8X chunk.");
807        return WEBP_INFO_PARSE_ERROR;
808      }
809      if (webp_info->chunk_counts_[CHUNK_VP8]) {
810        LOG_ERROR("ALPHA chunk detected after VP8 chunk.");
811        return WEBP_INFO_PARSE_ERROR;
812      }
813      if (webp_info->chunk_counts_[CHUNK_ALPHA]) {
814        LOG_ERROR("Multiple ALPHA chunks detected.");
815        return WEBP_INFO_PARSE_ERROR;
816      }
817      ++webp_info->chunk_counts_[CHUNK_ALPHA];
818    }
819    webp_info->has_alpha_ = 1;
820    if (webp_info->parse_bitstream_) {
821      const WebPInfoStatus status = ParseAlphaHeader(chunk_data, webp_info);
822      if (status != WEBP_INFO_OK) return status;
823    }
824    return WEBP_INFO_OK;
825  }
826  static WebPInfoStatus ProcessICCPChunk(const ChunkData* const chunk_data,
827                                         WebPInfo* const webp_info) {
828    (void)chunk_data;
829    if (!webp_info->chunk_counts_[CHUNK_VP8X]) {
830      LOG_ERROR("ICCP chunk detected before VP8X chunk.");
831      return WEBP_INFO_PARSE_ERROR;
832    }
833    if (webp_info->chunk_counts_[CHUNK_VP8] ||
834        webp_info->chunk_counts_[CHUNK_VP8L] ||
835        webp_info->chunk_counts_[CHUNK_ANIM]) {
836      LOG_ERROR("ICCP chunk detected after image data.");
837      return WEBP_INFO_PARSE_ERROR;
838    }
839    ++webp_info->chunk_counts_[CHUNK_ICCP];
840    return WEBP_INFO_OK;
841  }
842  static WebPInfoStatus ProcessChunk(const ChunkData* const chunk_data,
843                                     WebPInfo* const webp_info) {
844    WebPInfoStatus status = WEBP_INFO_OK;
845    ChunkID id = chunk_data->id_;
846    if (chunk_data->id_ == CHUNK_UNKNOWN) {
847      char error_message[50];
848      snprintf(error_message, 50, "Unknown chunk at offset %6d, length %6d",
849              (int)chunk_data->offset_, (int)chunk_data->size_);
850      LOG_WARN(error_message);
851    } else {
852      if (!webp_info->quiet_) {
853        const char* tag = kWebPChunkTags[chunk_data->id_];
854        printf("Chunk %c%c%c%c at offset %6d, length %6d\n",
855               tag[0], tag[1], tag[2], tag[3], (int)chunk_data->offset_,
856               (int)chunk_data->size_);
857      }
858    }
859    switch (id) {
860      case CHUNK_VP8:
861      case CHUNK_VP8L:
862        status = ProcessImageChunk(chunk_data, webp_info);
863        break;
864      case CHUNK_VP8X:
865        status = ProcessVP8XChunk(chunk_data, webp_info);
866        break;
867      case CHUNK_ALPHA:
868        status = ProcessALPHChunk(chunk_data, webp_info);
869        break;
870      case CHUNK_ANIM:
871        status = ProcessANIMChunk(chunk_data, webp_info);
872        break;
873      case CHUNK_ANMF:
874        status = ProcessANMFChunk(chunk_data, webp_info);
875        break;
876      case CHUNK_ICCP:
877        status = ProcessICCPChunk(chunk_data, webp_info);
878        break;
879      case CHUNK_EXIF:
880      case CHUNK_XMP:
881        ++webp_info->chunk_counts_[id];
882        break;
883      case CHUNK_UNKNOWN:
884      default:
885        break;
886    }
887    if (webp_info->is_processing_anim_frame_ && id != CHUNK_ANMF) {
888      if (webp_info->anim_frame_data_size_ == chunk_data->size_) {
889        if (!webp_info->seen_image_subchunk_) {
890          LOG_ERROR("No VP8/VP8L chunk detected in an ANMF chunk.");
891          return WEBP_INFO_PARSE_ERROR;
892        }
893        webp_info->is_processing_anim_frame_ = 0;
894      } else if (webp_info->anim_frame_data_size_ > chunk_data->size_) {
895        webp_info->anim_frame_data_size_ -= chunk_data->size_;
896      } else {
897        LOG_ERROR("Truncated data detected when parsing ANMF chunk.");
898        return WEBP_INFO_TRUNCATED_DATA;
899      }
900    }
901    return status;
902  }
903  static WebPInfoStatus Validate(const WebPInfo* const webp_info) {
904    if (webp_info->num_frames_ < 1) {
905      LOG_ERROR("No image/frame detected.");
906      return WEBP_INFO_MISSING_DATA;
907    }
908    if (webp_info->chunk_counts_[CHUNK_VP8X]) {
909      const int iccp = !!(webp_info->feature_flags_ & ICCP_FLAG);
910      const int exif = !!(webp_info->feature_flags_ & EXIF_FLAG);
911      const int xmp = !!(webp_info->feature_flags_ & XMP_FLAG);
912      const int animation = !!(webp_info->feature_flags_ & ANIMATION_FLAG);
913      const int alpha = !!(webp_info->feature_flags_ & ALPHA_FLAG);
914      if (!alpha && webp_info->has_alpha_) {
915        LOG_ERROR("Unexpected alpha data detected.");
916        return WEBP_INFO_PARSE_ERROR;
917      }
918      if (alpha && !webp_info->has_alpha_) {
919        LOG_WARN("Alpha flag is set with no alpha data present.");
920      }
921      if (iccp && !webp_info->chunk_counts_[CHUNK_ICCP]) {
922        LOG_ERROR("Missing ICCP chunk.");
923        return WEBP_INFO_MISSING_DATA;
924      }
925      if (exif && !webp_info->chunk_counts_[CHUNK_EXIF]) {
926        LOG_ERROR("Missing EXIF chunk.");
927        return WEBP_INFO_MISSING_DATA;
928      }
929      if (xmp && !webp_info->chunk_counts_[CHUNK_XMP]) {
930        LOG_ERROR("Missing XMP chunk.");
931        return WEBP_INFO_MISSING_DATA;
932      }
933      if (!iccp && webp_info->chunk_counts_[CHUNK_ICCP]) {
934        LOG_ERROR("Unexpected ICCP chunk detected.");
935        return WEBP_INFO_PARSE_ERROR;
936      }
937      if (!exif && webp_info->chunk_counts_[CHUNK_EXIF]) {
938        LOG_ERROR("Unexpected EXIF chunk detected.");
939        return WEBP_INFO_PARSE_ERROR;
940      }
941      if (!xmp && webp_info->chunk_counts_[CHUNK_XMP]) {
942        LOG_ERROR("Unexpected XMP chunk detected.");
943        return WEBP_INFO_PARSE_ERROR;
944      }
945      if (webp_info->is_processing_anim_frame_) return WEBP_INFO_MISSING_DATA;
946      if (!animation && webp_info->num_frames_ > 1) {
947        LOG_ERROR("More than 1 frame detected in non-animation file.");
948        return WEBP_INFO_PARSE_ERROR;
949      }
950      if (animation && (!webp_info->chunk_counts_[CHUNK_ANIM] ||
951          !webp_info->chunk_counts_[CHUNK_ANMF])) {
952        LOG_ERROR("No ANIM/ANMF chunk detected in animation file.");
953        return WEBP_INFO_PARSE_ERROR;
954      }
955    }
956    return WEBP_INFO_OK;
957  }
958  static void ShowSummary(const WebPInfo* const webp_info) {
959    int i;
960    printf("Summary:\n");
961    printf("Number of frames: %d\n", webp_info->num_frames_);
962    printf("Chunk type  :  VP8 VP8L VP8X ALPH ANIM ANMF(VP8 /VP8L/ALPH) ICCP "
963        "EXIF  XMP\n");
964    printf("Chunk counts: ");
965    for (i = 0; i < CHUNK_TYPES; ++i) {
966      printf("%4d ", webp_info->chunk_counts_[i]);
967      if (i == CHUNK_ANMF) {
968        printf("%4d %4d %4d  ",
969               webp_info->anmf_subchunk_counts_[0],
970               webp_info->anmf_subchunk_counts_[1],
971               webp_info->anmf_subchunk_counts_[2]);
972      }
973    }
974    printf("\n");
975  }
976  static WebPInfoStatus AnalyzeWebP(WebPInfo* const webp_info,
977                                    const WebPData* webp_data) {
978    ChunkData chunk_data;
979    MemBuffer mem_buffer;
980    WebPInfoStatus webp_info_status = WEBP_INFO_OK;
981    InitMemBuffer(&mem_buffer, webp_data);
982    webp_info_status = ParseRIFFHeader(webp_info, &mem_buffer);
983    if (webp_info_status != WEBP_INFO_OK) goto Error;
984    while (webp_info_status == WEBP_INFO_OK && MemDataSize(&mem_buffer) > 0) {
985      webp_info_status = ParseChunk(webp_info, &mem_buffer, &chunk_data);
986      if (webp_info_status != WEBP_INFO_OK) goto Error;
987      webp_info_status = ProcessChunk(&chunk_data, webp_info);
988    }
989    if (webp_info_status != WEBP_INFO_OK) goto Error;
990    if (webp_info->show_summary_) ShowSummary(webp_info);
991    webp_info_status = Validate(webp_info);
992   Error:
993    if (!webp_info->quiet_) {
994      if (webp_info_status == WEBP_INFO_OK) {
995        printf("No error detected.\n");
996      } else {
997        printf("Errors detected.\n");
998      }
999    }
1000    return webp_info_status;
1001  }
1002  static void HelpShort(void) {
1003    printf("Usage: webpinfo [options] in_files\n"
1004           "Try -longhelp for an exhaustive list of options.\n");
1005  }
1006  static void HelpLong(void) {
1007    printf("Usage: webpinfo [options] in_files\n"
1008           "Note: there could be multiple input files;\n"
1009           "      options must come before input files.\n"
1010           "Options:\n"
1011           "  -version ........... Print version number and exit.\n"
1012           "  -quiet ............. Do not show chunk parsing information.\n"
1013           "  -diag .............. Show parsing error diagnosis.\n"
1014           "  -summary ........... Show chunk stats summary.\n"
1015           "  -bitstream_info .... Parse bitstream header.\n");
1016  }
1017  int main(int argc, const char* argv[]) {
1018    int c, quiet = 0, show_diag = 0, show_summary = 0;
1019    int parse_bitstream = 0;
1020    WebPInfoStatus webp_info_status = WEBP_INFO_OK;
1021    WebPInfo webp_info;
1022    INIT_WARGV(argc, argv);
1023    if (argc == 1) {
1024      HelpShort();
1025      FREE_WARGV_AND_RETURN(WEBP_INFO_OK);
1026    }
1027    for (c = 1; c < argc; ++c) {
1028      if (!strcmp(argv[c], "-h") || !strcmp(argv[c], "-help")) {
1029        HelpShort();
1030        FREE_WARGV_AND_RETURN(WEBP_INFO_OK);
1031      } else if (!strcmp(argv[c], "-H") || !strcmp(argv[c], "-longhelp")) {
1032        HelpLong();
1033        FREE_WARGV_AND_RETURN(WEBP_INFO_OK);
1034      } else if (!strcmp(argv[c], "-quiet")) {
1035        quiet = 1;
1036      } else if (!strcmp(argv[c], "-diag")) {
1037        show_diag = 1;
1038      } else if (!strcmp(argv[c], "-summary")) {
1039        show_summary = 1;
1040      } else if (!strcmp(argv[c], "-bitstream_info")) {
1041        parse_bitstream = 1;
1042      } else if (!strcmp(argv[c], "-version")) {
1043        const int version = WebPGetDecoderVersion();
1044        printf("WebP Decoder version: %d.%d.%d\n",
1045               (version >> 16) & 0xff, (version >> 8) & 0xff, version & 0xff);
1046        FREE_WARGV_AND_RETURN(0);
1047      } else {  
1048        break;
1049      }
1050    }
1051    if (c == argc) {
1052      HelpShort();
1053      FREE_WARGV_AND_RETURN(WEBP_INFO_INVALID_COMMAND);
1054    }
1055    for (; c < argc; ++c) {
1056      WebPData webp_data;
1057      const W_CHAR* in_file = NULL;
1058      WebPInfoInit(&webp_info);
1059      webp_info.quiet_ = quiet;
1060      webp_info.show_diagnosis_ = show_diag;
1061      webp_info.show_summary_ = show_summary;
1062      webp_info.parse_bitstream_ = parse_bitstream;
1063      in_file = GET_WARGV(argv, c);
1064      if (in_file == NULL ||
1065          !ReadFileToWebPData((const char*)in_file, &webp_data)) {
1066        webp_info_status = WEBP_INFO_INVALID_COMMAND;
1067        WFPRINTF(stderr, "Failed to open input file %s.\n", in_file);
1068        continue;
1069      }
1070      if (!webp_info.quiet_) WPRINTF("File: %s\n", in_file);
1071      webp_info_status = AnalyzeWebP(&webp_info, &webp_data);
1072      WebPDataClear(&webp_data);
1073    }
1074    FREE_WARGV_AND_RETURN(webp_info_status);
1075  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from PINRemoteImage-MDEwOlJlcG9zaXRvcnkzOTUzNzEwMw==-flat-lossless_enc_sse2.c</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from PINRemoteImage-MDEwOlJlcG9zaXRvcnkzOTUzNzEwMw==-flat-webpinfo.c</div>
                </div>
                <div class="column column_space"><pre><code>545    VP8LSubtractGreenFromBlueAndRed = SubtractGreenFromBlueAndRed_SSE2;
546    VP8LTransformColor = TransformColor_SSE2;
547    VP8LCollectColorBlueTransforms = CollectColorBlueTransforms_SSE2;
548    VP8LCollectColorRedTransforms = CollectColorRedTransforms_SSE2;
549    VP8LAddVector = AddVector_SSE2;
550    VP8LAddVectorEq = AddVectorEq_SSE2;
551    VP8LCombinedShannonEntropy = CombinedShannonEntropy_SSE2;
552    VP8LVectorMismatch = VectorMismatch_SSE2;
553    VP8LBundleColorMap = BundleColorMap_SSE2;
</pre></code></div>
                <div class="column column_space"><pre><code>671    offset_x = 2 * ReadLE24(&data);
672    offset_y = 2 * ReadLE24(&data);
673    width = 1 + ReadLE24(&data);
674    height = 1 + ReadLE24(&data);
675    duration = ReadLE24(&data);
676    temp = *data;
677    dispose = temp & 1;
678    blend = (temp >> 1) & 1;
679    ++webp_info->chunk_counts_[CHUNK_ANMF];
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    