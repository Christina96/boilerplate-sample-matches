
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 63, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>redis-MDEwOlJlcG9zaXRvcnkxMDgxMTA3MDY=-flat-bitmap.c</h3>
            <pre><code>1  #include "test/jemalloc_test.h"
2  #define NBITS_TAB \
3      NB( 1) \
4      NB( 2) \
5      NB( 3) \
6      NB( 4) \
7      NB( 5) \
8      NB( 6) \
9      NB( 7) \
10      NB( 8) \
11      NB( 9) \
12      NB(10) \
13      NB(11) \
14      NB(12) \
15      NB(13) \
16      NB(14) \
17      NB(15) \
18      NB(16) \
19      NB(17) \
20      NB(18) \
21      NB(19) \
22      NB(20) \
23      NB(21) \
24      NB(22) \
25      NB(23) \
26      NB(24) \
27      NB(25) \
28      NB(26) \
29      NB(27) \
30      NB(28) \
31      NB(29) \
32      NB(30) \
33      NB(31) \
34      NB(32) \
35      \
36      NB(33) \
37      NB(34) \
38      NB(35) \
39      NB(36) \
40      NB(37) \
41      NB(38) \
42      NB(39) \
43      NB(40) \
44      NB(41) \
45      NB(42) \
46      NB(43) \
47      NB(44) \
48      NB(45) \
49      NB(46) \
50      NB(47) \
51      NB(48) \
52      NB(49) \
53      NB(50) \
54      NB(51) \
55      NB(52) \
56      NB(53) \
57      NB(54) \
58      NB(55) \
59      NB(56) \
60      NB(57) \
61      NB(58) \
62      NB(59) \
63      NB(60) \
64      NB(61) \
65      NB(62) \
66      NB(63) \
67      NB(64) \
68      NB(65) \
69      \
70      NB(126) \
71      NB(127) \
72      NB(128) \
73      NB(129) \
74      NB(130) \
75      \
76      NB(254) \
77      NB(255) \
78      NB(256) \
79      NB(257) \
80      NB(258) \
81      \
82      NB(510) \
83      NB(511) \
84      NB(512) \
85      NB(513) \
86      NB(514) \
87      \
88      NB(1024) \
89      NB(2048) \
90      NB(4096) \
91      NB(8192) \
92      NB(16384) \
93  
94  static void
95  test_bitmap_initializer_body(const bitmap_info_t *binfo, size_t nbits) {
96  	bitmap_info_t binfo_dyn;
97  	bitmap_info_init(&binfo_dyn, nbits);
98  	assert_zu_eq(bitmap_size(binfo), bitmap_size(&binfo_dyn),
99  	    "Unexpected difference between static and dynamic initialization, "
100  	    "nbits=%zu", nbits);
101  	assert_zu_eq(binfo->nbits, binfo_dyn.nbits,
102  	    "Unexpected difference between static and dynamic initialization, "
103  	    "nbits=%zu", nbits);
104  #ifdef BITMAP_USE_TREE
105  	assert_u_eq(binfo->nlevels, binfo_dyn.nlevels,
106  	    "Unexpected difference between static and dynamic initialization, "
107  	    "nbits=%zu", nbits);
108  	{
109  		unsigned i;
110  		for (i = 0; i < binfo->nlevels; i++) {
111  			assert_zu_eq(binfo->levels[i].group_offset,
112  			    binfo_dyn.levels[i].group_offset,
113  			    "Unexpected difference between static and dynamic "
114  			    "initialization, nbits=%zu, level=%u", nbits, i);
115  		}
116  	}
117  #else
118  	assert_zu_eq(binfo->ngroups, binfo_dyn.ngroups,
119  	    "Unexpected difference between static and dynamic initialization");
120  #endif
121  }
122  TEST_BEGIN(test_bitmap_initializer) {
123  #define NB(nbits) {							\
124  		if (nbits <= BITMAP_MAXBITS) {				\
125  			bitmap_info_t binfo =				\
126  			    BITMAP_INFO_INITIALIZER(nbits);		\
127  			test_bitmap_initializer_body(&binfo, nbits);	\
128  		}							\
129  	}
130  	NBITS_TAB
131  #undef NB
132  }
133  TEST_END
134  static size_t
135  test_bitmap_size_body(const bitmap_info_t *binfo, size_t nbits,
136      size_t prev_size) {
137  	size_t size = bitmap_size(binfo);
138  	assert_zu_ge(size, (nbits >> 3),
139  	    "Bitmap size is smaller than expected");
140  	assert_zu_ge(size, prev_size, "Bitmap size is smaller than expected");
141  	return size;
142  }
143  TEST_BEGIN(test_bitmap_size) {
144  	size_t nbits, prev_size;
145  	prev_size = 0;
146  	for (nbits = 1; nbits <= BITMAP_MAXBITS; nbits++) {
147  		bitmap_info_t binfo;
148  		bitmap_info_init(&binfo, nbits);
149  		prev_size = test_bitmap_size_body(&binfo, nbits, prev_size);
150  	}
151  #define NB(nbits) {							\
152  		bitmap_info_t binfo = BITMAP_INFO_INITIALIZER(nbits);	\
153  		prev_size = test_bitmap_size_body(&binfo, nbits,	\
154  		    prev_size);						\
155  	}
156  	prev_size = 0;
157  	NBITS_TAB
158  #undef NB
159  }
160  TEST_END
161  static void
162  test_bitmap_init_body(const bitmap_info_t *binfo, size_t nbits) {
163  	size_t i;
164  	bitmap_t *bitmap = (bitmap_t *)malloc(bitmap_size(binfo));
165  	assert_ptr_not_null(bitmap, "Unexpected malloc() failure");
166  	bitmap_init(bitmap, binfo, false);
167  	for (i = 0; i < nbits; i++) {
168  		assert_false(bitmap_get(bitmap, binfo, i),
169  		    "Bit should be unset");
170  	}
171  	bitmap_init(bitmap, binfo, true);
172  	for (i = 0; i < nbits; i++) {
173  		assert_true(bitmap_get(bitmap, binfo, i), "Bit should be set");
174  	}
175  	free(bitmap);
176  }
177  TEST_BEGIN(test_bitmap_init) {
178  	size_t nbits;
179  	for (nbits = 1; nbits <= BITMAP_MAXBITS; nbits++) {
180  		bitmap_info_t binfo;
181  		bitmap_info_init(&binfo, nbits);
182  		test_bitmap_init_body(&binfo, nbits);
183  	}
184  #define NB(nbits) {							\
185  		bitmap_info_t binfo = BITMAP_INFO_INITIALIZER(nbits);	\
186  		test_bitmap_init_body(&binfo, nbits);			\
187  	}
188  	NBITS_TAB
189  #undef NB
190  }
191  TEST_END
192  static void
193  test_bitmap_set_body(const bitmap_info_t *binfo, size_t nbits) {
194  	size_t i;
195  	bitmap_t *bitmap = (bitmap_t *)malloc(bitmap_size(binfo));
196  	assert_ptr_not_null(bitmap, "Unexpected malloc() failure");
197  	bitmap_init(bitmap, binfo, false);
198  	for (i = 0; i < nbits; i++) {
199  		bitmap_set(bitmap, binfo, i);
200  	}
201  	assert_true(bitmap_full(bitmap, binfo), "All bits should be set");
202  	free(bitmap);
203  }
204  TEST_BEGIN(test_bitmap_set) {
205  	size_t nbits;
206  	for (nbits = 1; nbits <= BITMAP_MAXBITS; nbits++) {
207  		bitmap_info_t binfo;
208  		bitmap_info_init(&binfo, nbits);
209  		test_bitmap_set_body(&binfo, nbits);
210  	}
211  #define NB(nbits) {							\
212  		bitmap_info_t binfo = BITMAP_INFO_INITIALIZER(nbits);	\
213  		test_bitmap_set_body(&binfo, nbits);			\
214  	}
215  	NBITS_TAB
216  #undef NB
217  }
218  TEST_END
219  static void
220  test_bitmap_unset_body(const bitmap_info_t *binfo, size_t nbits) {
221  	size_t i;
222  	bitmap_t *bitmap = (bitmap_t *)malloc(bitmap_size(binfo));
223  	assert_ptr_not_null(bitmap, "Unexpected malloc() failure");
224  	bitmap_init(bitmap, binfo, false);
225  	for (i = 0; i < nbits; i++) {
226  		bitmap_set(bitmap, binfo, i);
227  	}
228  	assert_true(bitmap_full(bitmap, binfo), "All bits should be set");
229  	for (i = 0; i < nbits; i++) {
230  		bitmap_unset(bitmap, binfo, i);
231  	}
232  	for (i = 0; i < nbits; i++) {
233  		bitmap_set(bitmap, binfo, i);
234  	}
235  	assert_true(bitmap_full(bitmap, binfo), "All bits should be set");
236  	free(bitmap);
237  }
238  TEST_BEGIN(test_bitmap_unset) {
239  	size_t nbits;
240  	for (nbits = 1; nbits <= BITMAP_MAXBITS; nbits++) {
241  		bitmap_info_t binfo;
242  		bitmap_info_init(&binfo, nbits);
243  		test_bitmap_unset_body(&binfo, nbits);
244  	}
245  #define NB(nbits) {							\
246  		bitmap_info_t binfo = BITMAP_INFO_INITIALIZER(nbits);	\
247  		test_bitmap_unset_body(&binfo, nbits);			\
248  	}
249  	NBITS_TAB
250  #undef NB
251  }
252  TEST_END
253  static void
254  test_bitmap_xfu_body(const bitmap_info_t *binfo, size_t nbits) {
255  	bitmap_t *bitmap = (bitmap_t *)malloc(bitmap_size(binfo));
256  	assert_ptr_not_null(bitmap, "Unexpected malloc() failure");
257  	bitmap_init(bitmap, binfo, false);
258  	for (size_t i = 0; i < nbits; i++) {
259  		assert_zu_eq(bitmap_ffu(bitmap, binfo, 0), i,
260  		    "First unset bit should be just after previous first unset "
261  		    "bit");
262  		assert_zu_eq(bitmap_ffu(bitmap, binfo, (i > 0) ? i-1 : i), i,
263  		    "First unset bit should be just after previous first unset "
264  		    "bit");
265  		assert_zu_eq(bitmap_ffu(bitmap, binfo, i), i,
266  		    "First unset bit should be just after previous first unset "
267  		    "bit");
268  		assert_zu_eq(bitmap_sfu(bitmap, binfo), i,
269  		    "First unset bit should be just after previous first unset "
270  		    "bit");
271  	}
272  	assert_true(bitmap_full(bitmap, binfo), "All bits should be set");
273  	for (size_t i = nbits - 1; i < nbits; i--) { &bsol;* (nbits..0] */
274  		bitmap_unset(bitmap, binfo, i);
275  		assert_zu_eq(bitmap_ffu(bitmap, binfo, 0), i,
276  		    "First unset bit should the bit previously unset");
277  		assert_zu_eq(bitmap_ffu(bitmap, binfo, (i > 0) ? i-1 : i), i,
278  		    "First unset bit should the bit previously unset");
279  		assert_zu_eq(bitmap_ffu(bitmap, binfo, i), i,
280  		    "First unset bit should the bit previously unset");
281  		assert_zu_eq(bitmap_sfu(bitmap, binfo), i,
282  		    "First unset bit should the bit previously unset");
283  		bitmap_unset(bitmap, binfo, i);
284  	}
285  	assert_false(bitmap_get(bitmap, binfo, 0), "Bit should be unset");
286  	for (size_t i = 1; i < nbits; i++) {
287  		bitmap_set(bitmap, binfo, i - 1);
288  		assert_zu_eq(bitmap_ffu(bitmap, binfo, 0), i,
<span onclick='openModal()' class='match'>289  		    "First unset bit should be just after the bit previously "
290  		    "set");
291  		assert_zu_eq(bitmap_ffu(bitmap, binfo, (i > 0) ? i-1 : i), i,
292  		    "First unset bit should be just after the bit previously "
293  		    "set");
294  		assert_zu_eq(bitmap_ffu(bitmap, binfo, i), i,
295  		    "First unset bit should be just after the bit previously "
296  		    "set");
297  		assert_zu_eq(bitmap_sfu(bitmap, binfo), i,
298  		    "First unset bit should be just after the bit previously "
299  		    "set");
300  		bitmap_unset(bitmap, binfo, i);
</span>301  	}
302  	assert_zu_eq(bitmap_ffu(bitmap, binfo, 0), nbits - 1,
303  	    "First unset bit should be the last bit");
304  	assert_zu_eq(bitmap_ffu(bitmap, binfo, (nbits > 1) ? nbits-2 : nbits-1),
305  	    nbits - 1, "First unset bit should be the last bit");
306  	assert_zu_eq(bitmap_ffu(bitmap, binfo, nbits - 1), nbits - 1,
307  	    "First unset bit should be the last bit");
308  	assert_zu_eq(bitmap_sfu(bitmap, binfo), nbits - 1,
309  	    "First unset bit should be the last bit");
310  	assert_true(bitmap_full(bitmap, binfo), "All bits should be set");
311  	if (nbits >= 3) {
312  		for (size_t i = 0; i < nbits-2; i++) {
313  			bitmap_unset(bitmap, binfo, i);
314  			bitmap_unset(bitmap, binfo, i+2);
315  			if (i > 0) {
316  				assert_zu_eq(bitmap_ffu(bitmap, binfo, i-1), i,
317  				    "Unexpected first unset bit");
318  			}
319  			assert_zu_eq(bitmap_ffu(bitmap, binfo, i), i,
320  			    "Unexpected first unset bit");
321  			assert_zu_eq(bitmap_ffu(bitmap, binfo, i+1), i+2,
322  			    "Unexpected first unset bit");
323  			assert_zu_eq(bitmap_ffu(bitmap, binfo, i+2), i+2,
324  			    "Unexpected first unset bit");
325  			if (i + 3 < nbits) {
326  				assert_zu_eq(bitmap_ffu(bitmap, binfo, i+3),
327  				    nbits, "Unexpected first unset bit");
328  			}
329  			assert_zu_eq(bitmap_sfu(bitmap, binfo), i,
330  			    "Unexpected first unset bit");
331  			assert_zu_eq(bitmap_sfu(bitmap, binfo), i+2,
332  			    "Unexpected first unset bit");
333  		}
334  	}
335  	if (nbits >= 3) {
336  		bitmap_unset(bitmap, binfo, nbits-1);
337  		for (size_t i = 0; i < nbits-1; i++) {
338  			bitmap_unset(bitmap, binfo, i);
339  			if (i > 0) {
340  				assert_zu_eq(bitmap_ffu(bitmap, binfo, i-1), i,
341  				    "Unexpected first unset bit");
342  			}
343  			assert_zu_eq(bitmap_ffu(bitmap, binfo, i), i,
344  			    "Unexpected first unset bit");
345  			assert_zu_eq(bitmap_ffu(bitmap, binfo, i+1), nbits-1,
346  			    "Unexpected first unset bit");
347  			assert_zu_eq(bitmap_ffu(bitmap, binfo, nbits-1),
348  			    nbits-1, "Unexpected first unset bit");
349  			assert_zu_eq(bitmap_sfu(bitmap, binfo), i,
350  			    "Unexpected first unset bit");
351  		}
352  		assert_zu_eq(bitmap_sfu(bitmap, binfo), nbits-1,
353  		    "Unexpected first unset bit");
354  	}
355  	free(bitmap);
356  }
357  TEST_BEGIN(test_bitmap_xfu) {
358  	size_t nbits;
359  	for (nbits = 1; nbits <= BITMAP_MAXBITS; nbits++) {
360  		bitmap_info_t binfo;
361  		bitmap_info_init(&binfo, nbits);
362  		test_bitmap_xfu_body(&binfo, nbits);
363  	}
364  #define NB(nbits) {							\
365  		bitmap_info_t binfo = BITMAP_INFO_INITIALIZER(nbits);	\
366  		test_bitmap_xfu_body(&binfo, nbits);			\
367  	}
368  	NBITS_TAB
369  #undef NB
370  }
371  TEST_END
372  int
373  main(void) {
374  	return test(
375  	    test_bitmap_initializer,
376  	    test_bitmap_size,
377  	    test_bitmap_init,
378  	    test_bitmap_set,
379  	    test_bitmap_unset,
380  	    test_bitmap_xfu);
381  }
</code></pre>
        </div>
        <div class="column">
            <h3>redis-MDEwOlJlcG9zaXRvcnkxMDgxMTA3MDY=-flat-bitmap.c</h3>
            <pre><code>1  #include "test/jemalloc_test.h"
2  #define NBITS_TAB \
3      NB( 1) \
4      NB( 2) \
5      NB( 3) \
6      NB( 4) \
7      NB( 5) \
8      NB( 6) \
9      NB( 7) \
10      NB( 8) \
11      NB( 9) \
12      NB(10) \
13      NB(11) \
14      NB(12) \
15      NB(13) \
16      NB(14) \
17      NB(15) \
18      NB(16) \
19      NB(17) \
20      NB(18) \
21      NB(19) \
22      NB(20) \
23      NB(21) \
24      NB(22) \
25      NB(23) \
26      NB(24) \
27      NB(25) \
28      NB(26) \
29      NB(27) \
30      NB(28) \
31      NB(29) \
32      NB(30) \
33      NB(31) \
34      NB(32) \
35      \
36      NB(33) \
37      NB(34) \
38      NB(35) \
39      NB(36) \
40      NB(37) \
41      NB(38) \
42      NB(39) \
43      NB(40) \
44      NB(41) \
45      NB(42) \
46      NB(43) \
47      NB(44) \
48      NB(45) \
49      NB(46) \
50      NB(47) \
51      NB(48) \
52      NB(49) \
53      NB(50) \
54      NB(51) \
55      NB(52) \
56      NB(53) \
57      NB(54) \
58      NB(55) \
59      NB(56) \
60      NB(57) \
61      NB(58) \
62      NB(59) \
63      NB(60) \
64      NB(61) \
65      NB(62) \
66      NB(63) \
67      NB(64) \
68      NB(65) \
69      \
70      NB(126) \
71      NB(127) \
72      NB(128) \
73      NB(129) \
74      NB(130) \
75      \
76      NB(254) \
77      NB(255) \
78      NB(256) \
79      NB(257) \
80      NB(258) \
81      \
82      NB(510) \
83      NB(511) \
84      NB(512) \
85      NB(513) \
86      NB(514) \
87      \
88      NB(1024) \
89      NB(2048) \
90      NB(4096) \
91      NB(8192) \
92      NB(16384) \
93  
94  static void
95  test_bitmap_initializer_body(const bitmap_info_t *binfo, size_t nbits) {
96  	bitmap_info_t binfo_dyn;
97  	bitmap_info_init(&binfo_dyn, nbits);
98  	assert_zu_eq(bitmap_size(binfo), bitmap_size(&binfo_dyn),
99  	    "Unexpected difference between static and dynamic initialization, "
100  	    "nbits=%zu", nbits);
101  	assert_zu_eq(binfo->nbits, binfo_dyn.nbits,
102  	    "Unexpected difference between static and dynamic initialization, "
103  	    "nbits=%zu", nbits);
104  #ifdef BITMAP_USE_TREE
105  	assert_u_eq(binfo->nlevels, binfo_dyn.nlevels,
106  	    "Unexpected difference between static and dynamic initialization, "
107  	    "nbits=%zu", nbits);
108  	{
109  		unsigned i;
110  		for (i = 0; i < binfo->nlevels; i++) {
111  			assert_zu_eq(binfo->levels[i].group_offset,
112  			    binfo_dyn.levels[i].group_offset,
113  			    "Unexpected difference between static and dynamic "
114  			    "initialization, nbits=%zu, level=%u", nbits, i);
115  		}
116  	}
117  #else
118  	assert_zu_eq(binfo->ngroups, binfo_dyn.ngroups,
119  	    "Unexpected difference between static and dynamic initialization");
120  #endif
121  }
122  TEST_BEGIN(test_bitmap_initializer) {
123  #define NB(nbits) {							\
124  		if (nbits <= BITMAP_MAXBITS) {				\
125  			bitmap_info_t binfo =				\
126  			    BITMAP_INFO_INITIALIZER(nbits);		\
127  			test_bitmap_initializer_body(&binfo, nbits);	\
128  		}							\
129  	}
130  	NBITS_TAB
131  #undef NB
132  }
133  TEST_END
134  static size_t
135  test_bitmap_size_body(const bitmap_info_t *binfo, size_t nbits,
136      size_t prev_size) {
137  	size_t size = bitmap_size(binfo);
138  	assert_zu_ge(size, (nbits >> 3),
139  	    "Bitmap size is smaller than expected");
140  	assert_zu_ge(size, prev_size, "Bitmap size is smaller than expected");
141  	return size;
142  }
143  TEST_BEGIN(test_bitmap_size) {
144  	size_t nbits, prev_size;
145  	prev_size = 0;
146  	for (nbits = 1; nbits <= BITMAP_MAXBITS; nbits++) {
147  		bitmap_info_t binfo;
148  		bitmap_info_init(&binfo, nbits);
149  		prev_size = test_bitmap_size_body(&binfo, nbits, prev_size);
150  	}
151  #define NB(nbits) {							\
152  		bitmap_info_t binfo = BITMAP_INFO_INITIALIZER(nbits);	\
153  		prev_size = test_bitmap_size_body(&binfo, nbits,	\
154  		    prev_size);						\
155  	}
156  	prev_size = 0;
157  	NBITS_TAB
158  #undef NB
159  }
160  TEST_END
161  static void
162  test_bitmap_init_body(const bitmap_info_t *binfo, size_t nbits) {
163  	size_t i;
164  	bitmap_t *bitmap = (bitmap_t *)malloc(bitmap_size(binfo));
165  	assert_ptr_not_null(bitmap, "Unexpected malloc() failure");
166  	bitmap_init(bitmap, binfo, false);
167  	for (i = 0; i < nbits; i++) {
168  		assert_false(bitmap_get(bitmap, binfo, i),
169  		    "Bit should be unset");
170  	}
171  	bitmap_init(bitmap, binfo, true);
172  	for (i = 0; i < nbits; i++) {
173  		assert_true(bitmap_get(bitmap, binfo, i), "Bit should be set");
174  	}
175  	free(bitmap);
176  }
177  TEST_BEGIN(test_bitmap_init) {
178  	size_t nbits;
179  	for (nbits = 1; nbits <= BITMAP_MAXBITS; nbits++) {
180  		bitmap_info_t binfo;
181  		bitmap_info_init(&binfo, nbits);
182  		test_bitmap_init_body(&binfo, nbits);
183  	}
184  #define NB(nbits) {							\
185  		bitmap_info_t binfo = BITMAP_INFO_INITIALIZER(nbits);	\
186  		test_bitmap_init_body(&binfo, nbits);			\
187  	}
188  	NBITS_TAB
189  #undef NB
190  }
191  TEST_END
192  static void
193  test_bitmap_set_body(const bitmap_info_t *binfo, size_t nbits) {
194  	size_t i;
195  	bitmap_t *bitmap = (bitmap_t *)malloc(bitmap_size(binfo));
196  	assert_ptr_not_null(bitmap, "Unexpected malloc() failure");
197  	bitmap_init(bitmap, binfo, false);
198  	for (i = 0; i < nbits; i++) {
199  		bitmap_set(bitmap, binfo, i);
200  	}
201  	assert_true(bitmap_full(bitmap, binfo), "All bits should be set");
202  	free(bitmap);
203  }
204  TEST_BEGIN(test_bitmap_set) {
205  	size_t nbits;
206  	for (nbits = 1; nbits <= BITMAP_MAXBITS; nbits++) {
207  		bitmap_info_t binfo;
208  		bitmap_info_init(&binfo, nbits);
209  		test_bitmap_set_body(&binfo, nbits);
210  	}
211  #define NB(nbits) {							\
212  		bitmap_info_t binfo = BITMAP_INFO_INITIALIZER(nbits);	\
213  		test_bitmap_set_body(&binfo, nbits);			\
214  	}
215  	NBITS_TAB
216  #undef NB
217  }
218  TEST_END
219  static void
220  test_bitmap_unset_body(const bitmap_info_t *binfo, size_t nbits) {
221  	size_t i;
222  	bitmap_t *bitmap = (bitmap_t *)malloc(bitmap_size(binfo));
223  	assert_ptr_not_null(bitmap, "Unexpected malloc() failure");
224  	bitmap_init(bitmap, binfo, false);
225  	for (i = 0; i < nbits; i++) {
226  		bitmap_set(bitmap, binfo, i);
227  	}
228  	assert_true(bitmap_full(bitmap, binfo), "All bits should be set");
229  	for (i = 0; i < nbits; i++) {
230  		bitmap_unset(bitmap, binfo, i);
231  	}
232  	for (i = 0; i < nbits; i++) {
233  		bitmap_set(bitmap, binfo, i);
234  	}
235  	assert_true(bitmap_full(bitmap, binfo), "All bits should be set");
236  	free(bitmap);
237  }
238  TEST_BEGIN(test_bitmap_unset) {
239  	size_t nbits;
240  	for (nbits = 1; nbits <= BITMAP_MAXBITS; nbits++) {
241  		bitmap_info_t binfo;
242  		bitmap_info_init(&binfo, nbits);
243  		test_bitmap_unset_body(&binfo, nbits);
244  	}
245  #define NB(nbits) {							\
246  		bitmap_info_t binfo = BITMAP_INFO_INITIALIZER(nbits);	\
247  		test_bitmap_unset_body(&binfo, nbits);			\
248  	}
249  	NBITS_TAB
250  #undef NB
251  }
252  TEST_END
253  static void
254  test_bitmap_xfu_body(const bitmap_info_t *binfo, size_t nbits) {
255  	bitmap_t *bitmap = (bitmap_t *)malloc(bitmap_size(binfo));
256  	assert_ptr_not_null(bitmap, "Unexpected malloc() failure");
257  	bitmap_init(bitmap, binfo, false);
258  	for (size_t i = 0; i < nbits; i++) {
259  		assert_zu_eq(bitmap_ffu(bitmap, binfo, 0), i,
<span onclick='openModal()' class='match'>260  		    "First unset bit should be just after previous first unset "
261  		    "bit");
262  		assert_zu_eq(bitmap_ffu(bitmap, binfo, (i > 0) ? i-1 : i), i,
263  		    "First unset bit should be just after previous first unset "
264  		    "bit");
265  		assert_zu_eq(bitmap_ffu(bitmap, binfo, i), i,
266  		    "First unset bit should be just after previous first unset "
267  		    "bit");
268  		assert_zu_eq(bitmap_sfu(bitmap, binfo), i,
269  		    "First unset bit should be just after previous first unset "
270  		    "bit");
271  	}
</span>272  	assert_true(bitmap_full(bitmap, binfo), "All bits should be set");
273  	for (size_t i = nbits - 1; i < nbits; i--) { &bsol;* (nbits..0] */
274  		bitmap_unset(bitmap, binfo, i);
275  		assert_zu_eq(bitmap_ffu(bitmap, binfo, 0), i,
276  		    "First unset bit should the bit previously unset");
277  		assert_zu_eq(bitmap_ffu(bitmap, binfo, (i > 0) ? i-1 : i), i,
278  		    "First unset bit should the bit previously unset");
279  		assert_zu_eq(bitmap_ffu(bitmap, binfo, i), i,
280  		    "First unset bit should the bit previously unset");
281  		assert_zu_eq(bitmap_sfu(bitmap, binfo), i,
282  		    "First unset bit should the bit previously unset");
283  		bitmap_unset(bitmap, binfo, i);
284  	}
285  	assert_false(bitmap_get(bitmap, binfo, 0), "Bit should be unset");
286  	for (size_t i = 1; i < nbits; i++) {
287  		bitmap_set(bitmap, binfo, i - 1);
288  		assert_zu_eq(bitmap_ffu(bitmap, binfo, 0), i,
289  		    "First unset bit should be just after the bit previously "
290  		    "set");
291  		assert_zu_eq(bitmap_ffu(bitmap, binfo, (i > 0) ? i-1 : i), i,
292  		    "First unset bit should be just after the bit previously "
293  		    "set");
294  		assert_zu_eq(bitmap_ffu(bitmap, binfo, i), i,
295  		    "First unset bit should be just after the bit previously "
296  		    "set");
297  		assert_zu_eq(bitmap_sfu(bitmap, binfo), i,
298  		    "First unset bit should be just after the bit previously "
299  		    "set");
300  		bitmap_unset(bitmap, binfo, i);
301  	}
302  	assert_zu_eq(bitmap_ffu(bitmap, binfo, 0), nbits - 1,
303  	    "First unset bit should be the last bit");
304  	assert_zu_eq(bitmap_ffu(bitmap, binfo, (nbits > 1) ? nbits-2 : nbits-1),
305  	    nbits - 1, "First unset bit should be the last bit");
306  	assert_zu_eq(bitmap_ffu(bitmap, binfo, nbits - 1), nbits - 1,
307  	    "First unset bit should be the last bit");
308  	assert_zu_eq(bitmap_sfu(bitmap, binfo), nbits - 1,
309  	    "First unset bit should be the last bit");
310  	assert_true(bitmap_full(bitmap, binfo), "All bits should be set");
311  	if (nbits >= 3) {
312  		for (size_t i = 0; i < nbits-2; i++) {
313  			bitmap_unset(bitmap, binfo, i);
314  			bitmap_unset(bitmap, binfo, i+2);
315  			if (i > 0) {
316  				assert_zu_eq(bitmap_ffu(bitmap, binfo, i-1), i,
317  				    "Unexpected first unset bit");
318  			}
319  			assert_zu_eq(bitmap_ffu(bitmap, binfo, i), i,
320  			    "Unexpected first unset bit");
321  			assert_zu_eq(bitmap_ffu(bitmap, binfo, i+1), i+2,
322  			    "Unexpected first unset bit");
323  			assert_zu_eq(bitmap_ffu(bitmap, binfo, i+2), i+2,
324  			    "Unexpected first unset bit");
325  			if (i + 3 < nbits) {
326  				assert_zu_eq(bitmap_ffu(bitmap, binfo, i+3),
327  				    nbits, "Unexpected first unset bit");
328  			}
329  			assert_zu_eq(bitmap_sfu(bitmap, binfo), i,
330  			    "Unexpected first unset bit");
331  			assert_zu_eq(bitmap_sfu(bitmap, binfo), i+2,
332  			    "Unexpected first unset bit");
333  		}
334  	}
335  	if (nbits >= 3) {
336  		bitmap_unset(bitmap, binfo, nbits-1);
337  		for (size_t i = 0; i < nbits-1; i++) {
338  			bitmap_unset(bitmap, binfo, i);
339  			if (i > 0) {
340  				assert_zu_eq(bitmap_ffu(bitmap, binfo, i-1), i,
341  				    "Unexpected first unset bit");
342  			}
343  			assert_zu_eq(bitmap_ffu(bitmap, binfo, i), i,
344  			    "Unexpected first unset bit");
345  			assert_zu_eq(bitmap_ffu(bitmap, binfo, i+1), nbits-1,
346  			    "Unexpected first unset bit");
347  			assert_zu_eq(bitmap_ffu(bitmap, binfo, nbits-1),
348  			    nbits-1, "Unexpected first unset bit");
349  			assert_zu_eq(bitmap_sfu(bitmap, binfo), i,
350  			    "Unexpected first unset bit");
351  		}
352  		assert_zu_eq(bitmap_sfu(bitmap, binfo), nbits-1,
353  		    "Unexpected first unset bit");
354  	}
355  	free(bitmap);
356  }
357  TEST_BEGIN(test_bitmap_xfu) {
358  	size_t nbits;
359  	for (nbits = 1; nbits <= BITMAP_MAXBITS; nbits++) {
360  		bitmap_info_t binfo;
361  		bitmap_info_init(&binfo, nbits);
362  		test_bitmap_xfu_body(&binfo, nbits);
363  	}
364  #define NB(nbits) {							\
365  		bitmap_info_t binfo = BITMAP_INFO_INITIALIZER(nbits);	\
366  		test_bitmap_xfu_body(&binfo, nbits);			\
367  	}
368  	NBITS_TAB
369  #undef NB
370  }
371  TEST_END
372  int
373  main(void) {
374  	return test(
375  	    test_bitmap_initializer,
376  	    test_bitmap_size,
377  	    test_bitmap_init,
378  	    test_bitmap_set,
379  	    test_bitmap_unset,
380  	    test_bitmap_xfu);
381  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from redis-MDEwOlJlcG9zaXRvcnkxMDgxMTA3MDY=-flat-bitmap.c</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from redis-MDEwOlJlcG9zaXRvcnkxMDgxMTA3MDY=-flat-bitmap.c</div>
                </div>
                <div class="column column_space"><pre><code>289  		    "First unset bit should be just after the bit previously "
290  		    "set");
291  		assert_zu_eq(bitmap_ffu(bitmap, binfo, (i > 0) ? i-1 : i), i,
292  		    "First unset bit should be just after the bit previously "
293  		    "set");
294  		assert_zu_eq(bitmap_ffu(bitmap, binfo, i), i,
295  		    "First unset bit should be just after the bit previously "
296  		    "set");
297  		assert_zu_eq(bitmap_sfu(bitmap, binfo), i,
298  		    "First unset bit should be just after the bit previously "
299  		    "set");
300  		bitmap_unset(bitmap, binfo, i);
</pre></code></div>
                <div class="column column_space"><pre><code>260  		    "First unset bit should be just after previous first unset "
261  		    "bit");
262  		assert_zu_eq(bitmap_ffu(bitmap, binfo, (i > 0) ? i-1 : i), i,
263  		    "First unset bit should be just after previous first unset "
264  		    "bit");
265  		assert_zu_eq(bitmap_ffu(bitmap, binfo, i), i,
266  		    "First unset bit should be just after previous first unset "
267  		    "bit");
268  		assert_zu_eq(bitmap_sfu(bitmap, binfo), i,
269  		    "First unset bit should be just after previous first unset "
270  		    "bit");
271  	}
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    