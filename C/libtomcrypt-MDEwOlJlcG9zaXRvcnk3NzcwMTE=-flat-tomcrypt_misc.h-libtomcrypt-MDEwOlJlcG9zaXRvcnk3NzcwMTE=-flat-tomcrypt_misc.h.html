
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 27, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>libtomcrypt-MDEwOlJlcG9zaXRvcnk3NzcwMTE=-flat-tomcrypt_misc.h</h3>
            <pre><code>1  #ifdef LTC_BASE64
2  int base64_encode(const unsigned char *in,  unsigned long inlen,
3                                   char *out, unsigned long *outlen);
4  int base64_decode(const char *in,  unsigned long inlen,
5                          unsigned char *out, unsigned long *outlen);
6  int base64_strict_decode(const char *in,  unsigned long inlen,
7                          unsigned char *out, unsigned long *outlen);
8  int base64_sane_decode(const char *in,  unsigned long inlen,
9                          unsigned char *out, unsigned long *outlen);
10  #endif
11  #ifdef LTC_BASE64_URL
12  int base64url_encode(const unsigned char *in,  unsigned long inlen,
13                                      char *out, unsigned long *outlen);
14  int base64url_strict_encode(const unsigned char *in,  unsigned long inlen,
15                                             char *out, unsigned long *outlen);
16  int base64url_decode(const char *in,  unsigned long inlen,
17                          unsigned char *out, unsigned long *outlen);
18  int base64url_strict_decode(const char *in,  unsigned long inlen,
19                          unsigned char *out, unsigned long *outlen);
20  int base64url_sane_decode(const char *in,  unsigned long inlen,
21                          unsigned char *out, unsigned long *outlen);
22  #endif
23  #ifdef LTC_BASE32
24  typedef enum {
25     BASE32_RFC4648   = 0,
26     BASE32_BASE32HEX = 1,
27     BASE32_ZBASE32   = 2,
28     BASE32_CROCKFORD = 3
29  } base32_alphabet;
30  int base32_encode(const unsigned char *in,  unsigned long inlen,
31                                   char *out, unsigned long *outlen,
32                          base32_alphabet id);
33  int base32_decode(const          char *in,  unsigned long inlen,
34                          unsigned char *out, unsigned long *outlen,
35                          base32_alphabet id);
36  #endif
37  #ifdef LTC_BASE16
38  int base16_encode(const unsigned char *in,  unsigned long  inlen,
39                                   char *out, unsigned long *outlen,
40                          unsigned int   options);
41  int base16_decode(const          char *in,  unsigned long  inlen,
42                          unsigned char *out, unsigned long *outlen);
43  #endif
44  #ifdef LTC_BCRYPT
45  int bcrypt_pbkdf_openbsd(const          void *secret, unsigned long secret_len,
46                           const unsigned char *salt,   unsigned long salt_len,
47                                 unsigned int  rounds,            int hash_idx,
48                                 unsigned char *out,    unsigned long *outlen);
49  #endif
50  #ifdef LTC_HKDF
51  int hkdf_test(void);
52  int hkdf_extract(int hash_idx,
53                   const unsigned char *salt, unsigned long saltlen,
54                   const unsigned char *in,   unsigned long inlen,
55                         unsigned char *out,  unsigned long *outlen);
56  int hkdf_expand(int hash_idx,
57                  const unsigned char *info, unsigned long infolen,
58                  const unsigned char *in,   unsigned long inlen,
59                        unsigned char *out,  unsigned long outlen);
60  int hkdf(int hash_idx,
61           const unsigned char *salt, unsigned long saltlen,
62           const unsigned char *info, unsigned long infolen,
63           const unsigned char *in,   unsigned long inlen,
64                 unsigned char *out,  unsigned long outlen);
65  #endif  &bsol;* LTC_HKDF */
66  int mem_neq(const void *a, const void *b, size_t len);
67  void zeromem(volatile void *out, size_t outlen);
68  void burn_stack(unsigned long len);
69  const char *error_to_string(int err);
70  extern const char *crypt_build_settings;
71  int crypt_fsa(void *mp, ...) LTC_NULL_TERMINATED;
72  int crypt_get_constant(const char* namein, int *valueout);
73  int crypt_list_all_constants(char *names_list, unsigned int *names_list_size);
74  int crypt_get_size(const char* namein, unsigned int *sizeout);
75  int crypt_list_all_sizes(char *names_list, unsigned int *names_list_size);
76  #ifdef LTM_DESC
<span onclick='openModal()' class='match'>77  LTC_DEPRECATED(crypt_mp_init) void init_LTM(void);
78  #endif
79  #ifdef TFM_DESC
80  LTC_DEPRECATED(crypt_mp_init) void init_TFM(void);
81  #endif
82  #ifdef GMP_DESC
</span>83  LTC_DEPRECATED(crypt_mp_init) void init_GMP(void);
84  #endif
85  int crypt_mp_init(const char* mpi);
86  #ifdef LTC_ADLER32
87  typedef struct adler32_state_s
88  {
89     unsigned short s[2];
90  } adler32_state;
91  void adler32_init(adler32_state *ctx);
92  void adler32_update(adler32_state *ctx, const unsigned char *input, unsigned long length);
93  void adler32_finish(const adler32_state *ctx, void *hash, unsigned long size);
94  int adler32_test(void);
95  #endif
96  #ifdef LTC_CRC32
97  typedef struct crc32_state_s
98  {
99     ulong32 crc;
100  } crc32_state;
101  void crc32_init(crc32_state *ctx);
102  void crc32_update(crc32_state *ctx, const unsigned char *input, unsigned long length);
103  void crc32_finish(const crc32_state *ctx, void *hash, unsigned long size);
104  int crc32_test(void);
105  #endif
106  #ifdef LTC_PADDING
107  enum padding_type {
108     LTC_PAD_PKCS7        = 0x0000U,
109  #ifdef LTC_RNG_GET_BYTES
110     LTC_PAD_ISO_10126    = 0x1000U,
111  #endif
112     LTC_PAD_ANSI_X923    = 0x2000U,
113     LTC_PAD_SSH          = 0x3000U,
114     LTC_PAD_ONE_AND_ZERO = 0x8000U,
115     LTC_PAD_ZERO         = 0x9000U,
116     LTC_PAD_ZERO_ALWAYS  = 0xA000U,
117  };
118  int padding_pad(unsigned char *data, unsigned long length, unsigned long* padded_length, unsigned long mode);
119  int padding_depad(const unsigned char *data, unsigned long *length, unsigned long mode);
120  #endif  &bsol;* LTC_PADDING */
121  #ifdef LTC_SSH
122  typedef enum ssh_data_type_ {
123     LTC_SSHDATA_EOL,
124     LTC_SSHDATA_BYTE,
125     LTC_SSHDATA_BOOLEAN,
126     LTC_SSHDATA_UINT32,
127     LTC_SSHDATA_UINT64,
128     LTC_SSHDATA_STRING,
129     LTC_SSHDATA_MPINT,
130     LTC_SSHDATA_NAMELIST,
131  } ssh_data_type;
132  int ssh_encode_sequence_multi(unsigned char *out, unsigned long *outlen, ...) LTC_NULL_TERMINATED;
133  int ssh_decode_sequence_multi(const unsigned char *in, unsigned long *inlen, ...) LTC_NULL_TERMINATED;
134  #endif &bsol;* LTC_SSH */
135  int compare_testvector(const void* is, const unsigned long is_len, const void* should, const unsigned long should_len, const char* what, int which);
</code></pre>
        </div>
        <div class="column">
            <h3>libtomcrypt-MDEwOlJlcG9zaXRvcnk3NzcwMTE=-flat-tomcrypt_misc.h</h3>
            <pre><code>1  #ifdef LTC_BASE64
2  int base64_encode(const unsigned char *in,  unsigned long inlen,
3                                   char *out, unsigned long *outlen);
4  int base64_decode(const char *in,  unsigned long inlen,
5                          unsigned char *out, unsigned long *outlen);
6  int base64_strict_decode(const char *in,  unsigned long inlen,
7                          unsigned char *out, unsigned long *outlen);
8  int base64_sane_decode(const char *in,  unsigned long inlen,
9                          unsigned char *out, unsigned long *outlen);
10  #endif
11  #ifdef LTC_BASE64_URL
12  int base64url_encode(const unsigned char *in,  unsigned long inlen,
13                                      char *out, unsigned long *outlen);
14  int base64url_strict_encode(const unsigned char *in,  unsigned long inlen,
15                                             char *out, unsigned long *outlen);
16  int base64url_decode(const char *in,  unsigned long inlen,
17                          unsigned char *out, unsigned long *outlen);
18  int base64url_strict_decode(const char *in,  unsigned long inlen,
19                          unsigned char *out, unsigned long *outlen);
20  int base64url_sane_decode(const char *in,  unsigned long inlen,
21                          unsigned char *out, unsigned long *outlen);
22  #endif
23  #ifdef LTC_BASE32
24  typedef enum {
25     BASE32_RFC4648   = 0,
26     BASE32_BASE32HEX = 1,
27     BASE32_ZBASE32   = 2,
28     BASE32_CROCKFORD = 3
29  } base32_alphabet;
30  int base32_encode(const unsigned char *in,  unsigned long inlen,
31                                   char *out, unsigned long *outlen,
32                          base32_alphabet id);
33  int base32_decode(const          char *in,  unsigned long inlen,
34                          unsigned char *out, unsigned long *outlen,
35                          base32_alphabet id);
36  #endif
37  #ifdef LTC_BASE16
38  int base16_encode(const unsigned char *in,  unsigned long  inlen,
39                                   char *out, unsigned long *outlen,
40                          unsigned int   options);
41  int base16_decode(const          char *in,  unsigned long  inlen,
42                          unsigned char *out, unsigned long *outlen);
43  #endif
44  #ifdef LTC_BCRYPT
45  int bcrypt_pbkdf_openbsd(const          void *secret, unsigned long secret_len,
46                           const unsigned char *salt,   unsigned long salt_len,
47                                 unsigned int  rounds,            int hash_idx,
48                                 unsigned char *out,    unsigned long *outlen);
49  #endif
50  #ifdef LTC_HKDF
51  int hkdf_test(void);
52  int hkdf_extract(int hash_idx,
53                   const unsigned char *salt, unsigned long saltlen,
54                   const unsigned char *in,   unsigned long inlen,
55                         unsigned char *out,  unsigned long *outlen);
56  int hkdf_expand(int hash_idx,
57                  const unsigned char *info, unsigned long infolen,
58                  const unsigned char *in,   unsigned long inlen,
59                        unsigned char *out,  unsigned long outlen);
60  int hkdf(int hash_idx,
61           const unsigned char *salt, unsigned long saltlen,
62           const unsigned char *info, unsigned long infolen,
63           const unsigned char *in,   unsigned long inlen,
64                 unsigned char *out,  unsigned long outlen);
65  #endif  &bsol;* LTC_HKDF */
66  int mem_neq(const void *a, const void *b, size_t len);
67  void zeromem(volatile void *out, size_t outlen);
68  void burn_stack(unsigned long len);
69  const char *error_to_string(int err);
70  extern const char *crypt_build_settings;
71  int crypt_fsa(void *mp, ...) LTC_NULL_TERMINATED;
72  int crypt_get_constant(const char* namein, int *valueout);
73  int crypt_list_all_constants(char *names_list, unsigned int *names_list_size);
74  int crypt_get_size(const char* namein, unsigned int *sizeout);
75  int crypt_list_all_sizes(char *names_list, unsigned int *names_list_size);
76  #ifdef LTM_DESC
77  LTC_DEPRECATED(crypt_mp_init) void init_LTM(void);
78  #endif
79  #ifdef TFM_DESC
<span onclick='openModal()' class='match'>80  LTC_DEPRECATED(crypt_mp_init) void init_TFM(void);
81  #endif
82  #ifdef GMP_DESC
83  LTC_DEPRECATED(crypt_mp_init) void init_GMP(void);
84  #endif
85  int crypt_mp_init(const char* mpi);
</span>86  #ifdef LTC_ADLER32
87  typedef struct adler32_state_s
88  {
89     unsigned short s[2];
90  } adler32_state;
91  void adler32_init(adler32_state *ctx);
92  void adler32_update(adler32_state *ctx, const unsigned char *input, unsigned long length);
93  void adler32_finish(const adler32_state *ctx, void *hash, unsigned long size);
94  int adler32_test(void);
95  #endif
96  #ifdef LTC_CRC32
97  typedef struct crc32_state_s
98  {
99     ulong32 crc;
100  } crc32_state;
101  void crc32_init(crc32_state *ctx);
102  void crc32_update(crc32_state *ctx, const unsigned char *input, unsigned long length);
103  void crc32_finish(const crc32_state *ctx, void *hash, unsigned long size);
104  int crc32_test(void);
105  #endif
106  #ifdef LTC_PADDING
107  enum padding_type {
108     LTC_PAD_PKCS7        = 0x0000U,
109  #ifdef LTC_RNG_GET_BYTES
110     LTC_PAD_ISO_10126    = 0x1000U,
111  #endif
112     LTC_PAD_ANSI_X923    = 0x2000U,
113     LTC_PAD_SSH          = 0x3000U,
114     LTC_PAD_ONE_AND_ZERO = 0x8000U,
115     LTC_PAD_ZERO         = 0x9000U,
116     LTC_PAD_ZERO_ALWAYS  = 0xA000U,
117  };
118  int padding_pad(unsigned char *data, unsigned long length, unsigned long* padded_length, unsigned long mode);
119  int padding_depad(const unsigned char *data, unsigned long *length, unsigned long mode);
120  #endif  &bsol;* LTC_PADDING */
121  #ifdef LTC_SSH
122  typedef enum ssh_data_type_ {
123     LTC_SSHDATA_EOL,
124     LTC_SSHDATA_BYTE,
125     LTC_SSHDATA_BOOLEAN,
126     LTC_SSHDATA_UINT32,
127     LTC_SSHDATA_UINT64,
128     LTC_SSHDATA_STRING,
129     LTC_SSHDATA_MPINT,
130     LTC_SSHDATA_NAMELIST,
131  } ssh_data_type;
132  int ssh_encode_sequence_multi(unsigned char *out, unsigned long *outlen, ...) LTC_NULL_TERMINATED;
133  int ssh_decode_sequence_multi(const unsigned char *in, unsigned long *inlen, ...) LTC_NULL_TERMINATED;
134  #endif &bsol;* LTC_SSH */
135  int compare_testvector(const void* is, const unsigned long is_len, const void* should, const unsigned long should_len, const char* what, int which);
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from libtomcrypt-MDEwOlJlcG9zaXRvcnk3NzcwMTE=-flat-tomcrypt_misc.h</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from libtomcrypt-MDEwOlJlcG9zaXRvcnk3NzcwMTE=-flat-tomcrypt_misc.h</div>
                </div>
                <div class="column column_space"><pre><code>77  LTC_DEPRECATED(crypt_mp_init) void init_LTM(void);
78  #endif
79  #ifdef TFM_DESC
80  LTC_DEPRECATED(crypt_mp_init) void init_TFM(void);
81  #endif
82  #ifdef GMP_DESC
</pre></code></div>
                <div class="column column_space"><pre><code>80  LTC_DEPRECATED(crypt_mp_init) void init_TFM(void);
81  #endif
82  #ifdef GMP_DESC
83  LTC_DEPRECATED(crypt_mp_init) void init_GMP(void);
84  #endif
85  int crypt_mp_init(const char* mpi);
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    