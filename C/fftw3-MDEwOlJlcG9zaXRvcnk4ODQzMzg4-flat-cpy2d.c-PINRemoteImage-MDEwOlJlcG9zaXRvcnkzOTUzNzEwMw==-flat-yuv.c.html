
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 9.542743538767395%, Tokens: 8</h2>
        <div class="column">
            <h3>fftw3-MDEwOlJlcG9zaXRvcnk4ODQzMzg4-flat-cpy2d.c</h3>
            <pre><code>1  #include "kernel/ifftw.h"
2  #if defined(__x86_64__) || defined(_M_X64) || defined(_M_AMD64)
3  #  ifdef HAVE_XMMINTRIN_H
4  #    include <xmmintrin.h>
5  #    define WIDE_TYPE __m128
6  #  endif
7  #endif
8  #ifndef WIDE_TYPE
9  #  define WIDE_TYPE double
10  #endif
11  void X(cpy2d)(R *I, R *O,
12  	      INT n0, INT is0, INT os0,
13  	      INT n1, INT is1, INT os1,
14  	      INT vl)
15  {
16       INT i0, i1, v;
17       switch (vl) {
18  	 case 1:
19  	      for (i1 = 0; i1 < n1; ++i1)
20  		   for (i0 = 0; i0 < n0; ++i0) {
21  			R x0 = I[i0 * is0 + i1 * is1];
22  			O[i0 * os0 + i1 * os1] = x0;
23  		   }
24  	      break;
25  	 case 2:
26  	      if (1
27  		  && (2 * sizeof(R) == sizeof(WIDE_TYPE))
28  		  && (sizeof(WIDE_TYPE) > sizeof(double))
29  		  && (((size_t)I) % sizeof(WIDE_TYPE) == 0)
30  		  && (((size_t)O) % sizeof(WIDE_TYPE) == 0)
31  		  && ((is0 & 1) == 0)
32  		  && ((is1 & 1) == 0)
33  		  && ((os0 & 1) == 0)
34  		  && ((os1 & 1) == 0)) {
35  		   for (i1 = 0; i1 < n1; ++i1)
36  			for (i0 = 0; i0 < n0; ++i0) {
37  			     *(WIDE_TYPE *)&O[i0 * os0 + i1 * os1] =
38  				  *(WIDE_TYPE *)&I[i0 * is0 + i1 * is1];
39  			}
40  	      } else if (1
41  		  && (2 * sizeof(R) == sizeof(double))
42  		  && (((size_t)I) % sizeof(double) == 0)
43  		  && (((size_t)O) % sizeof(double) == 0)
44  		  && ((is0 & 1) == 0)
45  		  && ((is1 & 1) == 0)
46  		  && ((os0 & 1) == 0)
47  		  && ((os1 & 1) == 0)) {
48  		   for (i1 = 0; i1 < n1; ++i1)
49  			for (i0 = 0; i0 < n0; ++i0) {
50  			     *(double *)&O[i0 * os0 + i1 * os1] =
51  				  *(double *)&I[i0 * is0 + i1 * is1];
52  			}
53  	      } else {
54  		   for (i1 = 0; i1 < n1; ++i1)
55  			for (i0 = 0; i0 < n0; ++i0) {
56  			     R x0 = I[i0 * is0 + i1 * is1];
57  			     R x1 = I[i0 * is0 + i1 * is1 + 1];
58  			     O[i0 * os0 + i1 * os1] = x0;
59   			     O[i0 * os0 + i1 * os1 + 1] = x1;
60  			}
61  	      }
62  	      break;
63  	 default:
64  	      for (i1 = 0; i1 < n1; ++i1)
65  		   for (i0 = 0; i0 < n0; ++i0)
66  			for (v = 0; v < vl; ++v) {
67  			     R x0 = I[i0 * is0 + i1 * is1 + v];
68  			     O[i0 * os0 + i1 * os1 + v] = x0;
69  			}
70  	      break;
71       }
72  }
73  void X(cpy2d_ci)(R *I, R *O,
74  		 INT n0, INT is0, INT os0,
75  		 INT n1, INT is1, INT os1,
76  		 INT vl)
77  {
78       if (IABS(is0) < IABS(is1))	&bsol;* inner loop is for n0 */
79  	  X(cpy2d) (I, O, n0, is0, os0, n1, is1, os1, vl);
80       else
81  	  X(cpy2d) (I, O, n1, is1, os1, n0, is0, os0, vl);
82  }
83  void X(cpy2d_co)(R *I, R *O,
84  		 INT n0, INT is0, INT os0,
85  		 INT n1, INT is1, INT os1,
86  		 INT vl)
87  {
88       if (IABS(os0) < IABS(os1))	&bsol;* inner loop is for n0 */
89  	  X(cpy2d) (I, O, n0, is0, os0, n1, is1, os1, vl);
90       else
91  	  X(cpy2d) (I, O, n1, is1, os1, n0, is0, os0, vl);
92  }
93  struct cpy2d_closure {
94       R *I, *O;
95       INT is0, os0, is1, os1, vl;
96       R *buf;
97  };
98  static void dotile(INT n0l, INT n0u, INT n1l, INT n1u, void *args)
99  {
100       struct cpy2d_closure *k = (struct cpy2d_closure *)args;
101       X(cpy2d)(k->I + n0l * k->is0 + n1l * k->is1,
102  	      k->O + n0l * k->os0 + n1l * k->os1,
103  	      n0u - n0l, k->is0, k->os0,
104  	      n1u - n1l, k->is1, k->os1,
105  	      k->vl);
106  }
107  static void dotile_buf(INT n0l, INT n0u, INT n1l, INT n1u, void *args)
108  {
109       struct cpy2d_closure *k = (struct cpy2d_closure *)args;
110       X(cpy2d_ci)(k->I + n0l * k->is0 + n1l * k->is1,
111  		 k->buf,
112  		 n0u - n0l, k->is0, k->vl,
113  		 n1u - n1l, k->is1, k->vl * (n0u - n0l),
114  		 k->vl);
115       X(cpy2d_co)(k->buf,
116  		 k->O + n0l * k->os0 + n1l * k->os1,
117  		 n0u - n0l, k->vl, k->os0,
118  		 n1u - n1l, k->vl * (n0u - n0l), k->os1,
119  		 k->vl);
120  }
121  void X(cpy2d_tiled)(R *I, R *O,
122  		    INT n0, INT is0, INT os0,
123  		    INT n1, INT is1, INT os1, INT vl)
124  {
125       INT tilesz = X(compute_tilesz)(vl,
126  				    1 &bsol;* input array */
127  				    + 1 &bsol;* ouput array */);
128       struct cpy2d_closure k;
<span onclick='openModal()' class='match'>129       k.I = I;
130       k.O = O;
131       k.is0 = is0;
132       k.os0 = os0;
133       k.is1 = is1;
134       k.os1 = os1;
135       k.vl = vl;
136       k.buf = 0; &bsol;* unused */
</span>137       X(tile2d)(0, n0, 0, n1, tilesz, dotile, &k);
138  }
139  void X(cpy2d_tiledbuf)(R *I, R *O,
140  		       INT n0, INT is0, INT os0,
141  		       INT n1, INT is1, INT os1, INT vl)
142  {
143       R buf[CACHESIZE / (2 * sizeof(R))];
144       INT tilesz = X(compute_tilesz)(vl, 2);
145       struct cpy2d_closure k;
146       k.I = I;
147       k.O = O;
148       k.is0 = is0;
149       k.os0 = os0;
150       k.is1 = is1;
151       k.os1 = os1;
152       k.vl = vl;
153       k.buf = buf;
154       A(tilesz * tilesz * vl * sizeof(R) <= sizeof(buf));
155       X(tile2d)(0, n0, 0, n1, tilesz, dotile_buf, &k);
156  }
</code></pre>
        </div>
        <div class="column">
            <h3>PINRemoteImage-MDEwOlJlcG9zaXRvcnkzOTUzNzEwMw==-flat-yuv.c</h3>
            <pre><code>1  #include "src/dsp/yuv.h"
2  #include <assert.h>
3  #include <stdlib.h>
4  #define ROW_FUNC(FUNC_NAME, FUNC, XSTEP)                                       \
5  static void FUNC_NAME(const uint8_t* y,                                        \
6                        const uint8_t* u, const uint8_t* v,                      \
7                        uint8_t* dst, int len) {                                 \
8    const uint8_t* const end = dst + (len & ~1) * (XSTEP);                       \
9    while (dst != end) {                                                         \
10      FUNC(y[0], u[0], v[0], dst);                                               \
11      FUNC(y[1], u[0], v[0], dst + (XSTEP));                                     \
12      y += 2;                                                                    \
13      ++u;                                                                       \
14      ++v;                                                                       \
15      dst += 2 * (XSTEP);                                                        \
16    }                                                                            \
17    if (len & 1) {                                                               \
18      FUNC(y[0], u[0], v[0], dst);                                               \
19    }                                                                            \
20  }                                                                              \
21  
22  ROW_FUNC(YuvToRgbRow,      VP8YuvToRgb,  3)
23  ROW_FUNC(YuvToBgrRow,      VP8YuvToBgr,  3)
24  ROW_FUNC(YuvToRgbaRow,     VP8YuvToRgba, 4)
25  ROW_FUNC(YuvToBgraRow,     VP8YuvToBgra, 4)
26  ROW_FUNC(YuvToArgbRow,     VP8YuvToArgb, 4)
27  ROW_FUNC(YuvToRgba4444Row, VP8YuvToRgba4444, 2)
28  ROW_FUNC(YuvToRgb565Row,   VP8YuvToRgb565, 2)
29  #undef ROW_FUNC
30  void WebPSamplerProcessPlane(const uint8_t* y, int y_stride,
31                               const uint8_t* u, const uint8_t* v, int uv_stride,
32                               uint8_t* dst, int dst_stride,
33                               int width, int height, WebPSamplerRowFunc func) {
34    int j;
35    for (j = 0; j < height; ++j) {
36      func(y, u, v, dst, width);
37      y += y_stride;
38      if (j & 1) {
39        u += uv_stride;
40        v += uv_stride;
41      }
42      dst += dst_stride;
43    }
44  }
45  WebPSamplerRowFunc WebPSamplers[MODE_LAST];
46  extern void WebPInitSamplersSSE2(void);
47  extern void WebPInitSamplersSSE41(void);
48  extern void WebPInitSamplersMIPS32(void);
49  extern void WebPInitSamplersMIPSdspR2(void);
50  WEBP_DSP_INIT_FUNC(WebPInitSamplers) {
<span onclick='openModal()' class='match'>51    WebPSamplers[MODE_RGB]       = YuvToRgbRow;
52    WebPSamplers[MODE_RGBA]      = YuvToRgbaRow;
53    WebPSamplers[MODE_BGR]       = YuvToBgrRow;
54    WebPSamplers[MODE_BGRA]      = YuvToBgraRow;
55    WebPSamplers[MODE_ARGB]      = YuvToArgbRow;
56    WebPSamplers[MODE_RGBA_4444] = YuvToRgba4444Row;
57    WebPSamplers[MODE_RGB_565]   = YuvToRgb565Row;
58    WebPSamplers[MODE_rgbA]      = YuvToRgbaRow;
</span>59    WebPSamplers[MODE_bgrA]      = YuvToBgraRow;
60    WebPSamplers[MODE_Argb]      = YuvToArgbRow;
61    WebPSamplers[MODE_rgbA_4444] = YuvToRgba4444Row;
62    if (VP8GetCPUInfo != NULL) {
63  #if defined(WEBP_USE_SSE2)
64      if (VP8GetCPUInfo(kSSE2)) {
65        WebPInitSamplersSSE2();
66      }
67  #endif  
68  #if defined(WEBP_USE_SSE41)
69      if (VP8GetCPUInfo(kSSE4_1)) {
70        WebPInitSamplersSSE41();
71      }
72  #endif  
73  #if defined(WEBP_USE_MIPS32)
74      if (VP8GetCPUInfo(kMIPS32)) {
75        WebPInitSamplersMIPS32();
76      }
77  #endif  
78  #if defined(WEBP_USE_MIPS_DSP_R2)
79      if (VP8GetCPUInfo(kMIPSdspR2)) {
80        WebPInitSamplersMIPSdspR2();
81      }
82  #endif  
83    }
84  }
85  static void ConvertARGBToY_C(const uint32_t* argb, uint8_t* y, int width) {
86    int i;
87    for (i = 0; i < width; ++i) {
88      const uint32_t p = argb[i];
89      y[i] = VP8RGBToY((p >> 16) & 0xff, (p >> 8) & 0xff, (p >>  0) & 0xff,
90                       YUV_HALF);
91    }
92  }
93  void WebPConvertARGBToUV_C(const uint32_t* argb, uint8_t* u, uint8_t* v,
94                             int src_width, int do_store) {
95    const int uv_width = src_width >> 1;
96    int i;
97    for (i = 0; i < uv_width; ++i) {
98      const uint32_t v0 = argb[2 * i + 0];
99      const uint32_t v1 = argb[2 * i + 1];
100      const int r = ((v0 >> 15) & 0x1fe) + ((v1 >> 15) & 0x1fe);
101      const int g = ((v0 >>  7) & 0x1fe) + ((v1 >>  7) & 0x1fe);
102      const int b = ((v0 <<  1) & 0x1fe) + ((v1 <<  1) & 0x1fe);
103      const int tmp_u = VP8RGBToU(r, g, b, YUV_HALF << 2);
104      const int tmp_v = VP8RGBToV(r, g, b, YUV_HALF << 2);
105      if (do_store) {
106        u[i] = tmp_u;
107        v[i] = tmp_v;
108      } else {
109        u[i] = (u[i] + tmp_u + 1) >> 1;
110        v[i] = (v[i] + tmp_v + 1) >> 1;
111      }
112    }
113    if (src_width & 1) {       
114      const uint32_t v0 = argb[2 * i + 0];
115      const int r = (v0 >> 14) & 0x3fc;
116      const int g = (v0 >>  6) & 0x3fc;
117      const int b = (v0 <<  2) & 0x3fc;
118      const int tmp_u = VP8RGBToU(r, g, b, YUV_HALF << 2);
119      const int tmp_v = VP8RGBToV(r, g, b, YUV_HALF << 2);
120      if (do_store) {
121        u[i] = tmp_u;
122        v[i] = tmp_v;
123      } else {
124        u[i] = (u[i] + tmp_u + 1) >> 1;
125        v[i] = (v[i] + tmp_v + 1) >> 1;
126      }
127    }
128  }
129  static void ConvertRGB24ToY_C(const uint8_t* rgb, uint8_t* y, int width) {
130    int i;
131    for (i = 0; i < width; ++i, rgb += 3) {
132      y[i] = VP8RGBToY(rgb[0], rgb[1], rgb[2], YUV_HALF);
133    }
134  }
135  static void ConvertBGR24ToY_C(const uint8_t* bgr, uint8_t* y, int width) {
136    int i;
137    for (i = 0; i < width; ++i, bgr += 3) {
138      y[i] = VP8RGBToY(bgr[2], bgr[1], bgr[0], YUV_HALF);
139    }
140  }
141  void WebPConvertRGBA32ToUV_C(const uint16_t* rgb,
142                               uint8_t* u, uint8_t* v, int width) {
143    int i;
144    for (i = 0; i < width; i += 1, rgb += 4) {
145      const int r = rgb[0], g = rgb[1], b = rgb[2];
146      u[i] = VP8RGBToU(r, g, b, YUV_HALF << 2);
147      v[i] = VP8RGBToV(r, g, b, YUV_HALF << 2);
148    }
149  }
150  #if !WEBP_NEON_OMIT_C_CODE
151  #define MAX_Y ((1 << 10) - 1)    
152  static uint16_t clip_y(int v) {
153    return (v < 0) ? 0 : (v > MAX_Y) ? MAX_Y : (uint16_t)v;
154  }
155  static uint64_t SharpYUVUpdateY_C(const uint16_t* ref, const uint16_t* src,
156                                    uint16_t* dst, int len) {
157    uint64_t diff = 0;
158    int i;
159    for (i = 0; i < len; ++i) {
160      const int diff_y = ref[i] - src[i];
161      const int new_y = (int)dst[i] + diff_y;
162      dst[i] = clip_y(new_y);
163      diff += (uint64_t)abs(diff_y);
164    }
165    return diff;
166  }
167  static void SharpYUVUpdateRGB_C(const int16_t* ref, const int16_t* src,
168                                  int16_t* dst, int len) {
169    int i;
170    for (i = 0; i < len; ++i) {
171      const int diff_uv = ref[i] - src[i];
172      dst[i] += diff_uv;
173    }
174  }
175  static void SharpYUVFilterRow_C(const int16_t* A, const int16_t* B, int len,
176                                  const uint16_t* best_y, uint16_t* out) {
177    int i;
178    for (i = 0; i < len; ++i, ++A, ++B) {
179      const int v0 = (A[0] * 9 + A[1] * 3 + B[0] * 3 + B[1] + 8) >> 4;
180      const int v1 = (A[1] * 9 + A[0] * 3 + B[1] * 3 + B[0] + 8) >> 4;
181      out[2 * i + 0] = clip_y(best_y[2 * i + 0] + v0);
182      out[2 * i + 1] = clip_y(best_y[2 * i + 1] + v1);
183    }
184  }
185  #endif  
186  #undef MAX_Y
187  void (*WebPConvertRGB24ToY)(const uint8_t* rgb, uint8_t* y, int width);
188  void (*WebPConvertBGR24ToY)(const uint8_t* bgr, uint8_t* y, int width);
189  void (*WebPConvertRGBA32ToUV)(const uint16_t* rgb,
190                                uint8_t* u, uint8_t* v, int width);
191  void (*WebPConvertARGBToY)(const uint32_t* argb, uint8_t* y, int width);
192  void (*WebPConvertARGBToUV)(const uint32_t* argb, uint8_t* u, uint8_t* v,
193                              int src_width, int do_store);
194  uint64_t (*WebPSharpYUVUpdateY)(const uint16_t* ref, const uint16_t* src,
195                                  uint16_t* dst, int len);
196  void (*WebPSharpYUVUpdateRGB)(const int16_t* ref, const int16_t* src,
197                                int16_t* dst, int len);
198  void (*WebPSharpYUVFilterRow)(const int16_t* A, const int16_t* B, int len,
199                                const uint16_t* best_y, uint16_t* out);
200  extern void WebPInitConvertARGBToYUVSSE2(void);
201  extern void WebPInitConvertARGBToYUVSSE41(void);
202  extern void WebPInitConvertARGBToYUVNEON(void);
203  extern void WebPInitSharpYUVSSE2(void);
204  extern void WebPInitSharpYUVNEON(void);
205  WEBP_DSP_INIT_FUNC(WebPInitConvertARGBToYUV) {
206    WebPConvertARGBToY = ConvertARGBToY_C;
207    WebPConvertARGBToUV = WebPConvertARGBToUV_C;
208    WebPConvertRGB24ToY = ConvertRGB24ToY_C;
209    WebPConvertBGR24ToY = ConvertBGR24ToY_C;
210    WebPConvertRGBA32ToUV = WebPConvertRGBA32ToUV_C;
211  #if !WEBP_NEON_OMIT_C_CODE
212    WebPSharpYUVUpdateY = SharpYUVUpdateY_C;
213    WebPSharpYUVUpdateRGB = SharpYUVUpdateRGB_C;
214    WebPSharpYUVFilterRow = SharpYUVFilterRow_C;
215  #endif
216    if (VP8GetCPUInfo != NULL) {
217  #if defined(WEBP_USE_SSE2)
218      if (VP8GetCPUInfo(kSSE2)) {
219        WebPInitConvertARGBToYUVSSE2();
220        WebPInitSharpYUVSSE2();
221      }
222  #endif  
223  #if defined(WEBP_USE_SSE41)
224      if (VP8GetCPUInfo(kSSE4_1)) {
225        WebPInitConvertARGBToYUVSSE41();
226      }
227  #endif  
228    }
229  #if defined(WEBP_USE_NEON)
230    if (WEBP_NEON_OMIT_C_CODE ||
231        (VP8GetCPUInfo != NULL && VP8GetCPUInfo(kNEON))) {
232      WebPInitConvertARGBToYUVNEON();
233      WebPInitSharpYUVNEON();
234    }
235  #endif  
236    assert(WebPConvertARGBToY != NULL);
237    assert(WebPConvertARGBToUV != NULL);
238    assert(WebPConvertRGB24ToY != NULL);
239    assert(WebPConvertBGR24ToY != NULL);
240    assert(WebPConvertRGBA32ToUV != NULL);
241    assert(WebPSharpYUVUpdateY != NULL);
242    assert(WebPSharpYUVUpdateRGB != NULL);
243    assert(WebPSharpYUVFilterRow != NULL);
244  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from fftw3-MDEwOlJlcG9zaXRvcnk4ODQzMzg4-flat-cpy2d.c</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from PINRemoteImage-MDEwOlJlcG9zaXRvcnkzOTUzNzEwMw==-flat-yuv.c</div>
                </div>
                <div class="column column_space"><pre><code>129       k.I = I;
130       k.O = O;
131       k.is0 = is0;
132       k.os0 = os0;
133       k.is1 = is1;
134       k.os1 = os1;
135       k.vl = vl;
136       k.buf = 0; &bsol;* unused */
</pre></code></div>
                <div class="column column_space"><pre><code>51    WebPSamplers[MODE_RGB]       = YuvToRgbRow;
52    WebPSamplers[MODE_RGBA]      = YuvToRgbaRow;
53    WebPSamplers[MODE_BGR]       = YuvToBgrRow;
54    WebPSamplers[MODE_BGRA]      = YuvToBgraRow;
55    WebPSamplers[MODE_ARGB]      = YuvToArgbRow;
56    WebPSamplers[MODE_RGBA_4444] = YuvToRgba4444Row;
57    WebPSamplers[MODE_RGB_565]   = YuvToRgb565Row;
58    WebPSamplers[MODE_rgbA]      = YuvToRgbaRow;
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    