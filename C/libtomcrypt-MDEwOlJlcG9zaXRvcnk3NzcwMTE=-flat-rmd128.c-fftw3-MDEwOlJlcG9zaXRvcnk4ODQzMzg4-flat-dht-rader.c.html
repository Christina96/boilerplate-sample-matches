
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 4.054054054054054%, Tokens: 9, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>libtomcrypt-MDEwOlJlcG9zaXRvcnk3NzcwMTE=-flat-rmd128.c</h3>
            <pre><code>1  #include "tomcrypt_private.h"
2  #ifdef LTC_RIPEMD128
3  const struct ltc_hash_descriptor rmd128_desc =
4  {
5      "rmd128",
6      8,
7      16,
8      64,
9     { 1, 0, 10118, 3, 0, 50 },
10     6,
11      &rmd128_init,
12      &rmd128_process,
13      &rmd128_done,
14      &rmd128_test,
15      NULL
16  };
17  #define F(x, y, z)        ((x) ^ (y) ^ (z))
18  #define G(x, y, z)        (((x) & (y)) | (~(x) & (z)))
19  #define H(x, y, z)        (((x) | ~(y)) ^ (z))
20  #define I(x, y, z)        (((x) & (z)) | ((y) & ~(z)))
21  #define FF(a, b, c, d, x, s)        \
22        (a) += F((b), (c), (d)) + (x);\
23        (a) = ROLc((a), (s));
24  #define GG(a, b, c, d, x, s)        \
25        (a) += G((b), (c), (d)) + (x) + 0x5a827999UL;\
26        (a) = ROLc((a), (s));
27  #define HH(a, b, c, d, x, s)        \
28        (a) += H((b), (c), (d)) + (x) + 0x6ed9eba1UL;\
29        (a) = ROLc((a), (s));
30  #define II(a, b, c, d, x, s)        \
31        (a) += I((b), (c), (d)) + (x) + 0x8f1bbcdcUL;\
32        (a) = ROLc((a), (s));
33  #define FFF(a, b, c, d, x, s)        \
34        (a) += F((b), (c), (d)) + (x);\
35        (a) = ROLc((a), (s));
36  #define GGG(a, b, c, d, x, s)        \
37        (a) += G((b), (c), (d)) + (x) + 0x6d703ef3UL;\
38        (a) = ROLc((a), (s));
39  #define HHH(a, b, c, d, x, s)        \
40        (a) += H((b), (c), (d)) + (x) + 0x5c4dd124UL;\
41        (a) = ROLc((a), (s));
42  #define III(a, b, c, d, x, s)        \
43        (a) += I((b), (c), (d)) + (x) + 0x50a28be6UL;\
44        (a) = ROLc((a), (s));
45  #ifdef LTC_CLEAN_STACK
46  static int ss_rmd128_compress(hash_state *md, const unsigned char *buf)
47  #else
48  static int  s_rmd128_compress(hash_state *md, const unsigned char *buf)
49  #endif
50  {
51     ulong32 aa,bb,cc,dd,aaa,bbb,ccc,ddd,X[16];
52     int i;
53     for (i = 0; i < 16; i++){
54        LOAD32L(X[i], buf + (4 * i));
55     }
<span onclick='openModal()' class='match'>56     aa = aaa = md->rmd128.state[0];
57     bb = bbb = md->rmd128.state[1];
58     cc = ccc = md->rmd128.state[2];
59     dd = ddd = md->rmd128.state[3];
60     FF(aa, bb, cc, dd, X[ 0], 11);
61     FF(dd, aa, bb, cc, X[ 1], 14);
62     FF(cc, dd, aa, bb, X[ 2], 15);
63     FF(bb, cc, dd, aa, X[ 3], 12);
64     FF(aa, bb, cc, dd, X[ 4],  5);
65     FF(dd, aa, bb, cc, X[ 5],  8);
66     FF(cc, dd, aa, bb, X[ 6],  7);
67     FF(bb, cc, dd, aa, X[ 7],  9);
68     FF(aa, bb, cc, dd, X[ 8], 11);
69     FF(dd, aa, bb, cc, X[ 9], 13);
70     FF(cc, dd, aa, bb, X[10], 14);
71     FF(bb, cc, dd, aa, X[11], 15);
72     FF(aa, bb, cc, dd, X[12],  6);
73     FF(dd, aa, bb, cc, X[13],  7);
74     FF(cc, dd, aa, bb, X[14],  9);
75     FF(bb, cc, dd, aa, X[15],  8);
76     GG(aa, bb, cc, dd, X[ 7],  7);
77     GG(dd, aa, bb, cc, X[ 4],  6);
78     GG(cc, dd, aa, bb, X[13],  8);
79     GG(bb, cc, dd, aa, X[ 1], 13);
80     GG(aa, bb, cc, dd, X[10], 11);
81     GG(dd, aa, bb, cc, X[ 6],  9);
82     GG(cc, dd, aa, bb, X[15],  7);
83     GG(bb, cc, dd, aa, X[ 3], 15);
84     GG(aa, bb, cc, dd, X[12],  7);
85     GG(dd, aa, bb, cc, X[ 0], 12);
86     GG(cc, dd, aa, bb, X[ 9], 15);
87     GG(bb, cc, dd, aa, X[ 5],  9);
88     GG(aa, bb, cc, dd, X[ 2], 11);
89     GG(dd, aa, bb, cc, X[14],  7);
90     GG(cc, dd, aa, bb, X[11], 13);
91     GG(bb, cc, dd, aa, X[ 8], 12);
92     HH(aa, bb, cc, dd, X[ 3], 11);
93     HH(dd, aa, bb, cc, X[10], 13);
94     HH(cc, dd, aa, bb, X[14],  6);
95     HH(bb, cc, dd, aa, X[ 4],  7);
96     HH(aa, bb, cc, dd, X[ 9], 14);
97     HH(dd, aa, bb, cc, X[15],  9);
98     HH(cc, dd, aa, bb, X[ 8], 13);
99     HH(bb, cc, dd, aa, X[ 1], 15);
100     HH(aa, bb, cc, dd, X[ 2], 14);
101     HH(dd, aa, bb, cc, X[ 7],  8);
102     HH(cc, dd, aa, bb, X[ 0], 13);
103     HH(bb, cc, dd, aa, X[ 6],  6);
104     HH(aa, bb, cc, dd, X[13],  5);
105     HH(dd, aa, bb, cc, X[11], 12);
106     HH(cc, dd, aa, bb, X[ 5],  7);
107     HH(bb, cc, dd, aa, X[12],  5);
108     II(aa, bb, cc, dd, X[ 1], 11);
109     II(dd, aa, bb, cc, X[ 9], 12);
110     II(cc, dd, aa, bb, X[11], 14);
111     II(bb, cc, dd, aa, X[10], 15);
112     II(aa, bb, cc, dd, X[ 0], 14);
113     II(dd, aa, bb, cc, X[ 8], 15);
114     II(cc, dd, aa, bb, X[12],  9);
115     II(bb, cc, dd, aa, X[ 4],  8);
116     II(aa, bb, cc, dd, X[13],  9);
117     II(dd, aa, bb, cc, X[ 3], 14);
118     II(cc, dd, aa, bb, X[ 7],  5);
119     II(bb, cc, dd, aa, X[15],  6);
120     II(aa, bb, cc, dd, X[14],  8);
121     II(dd, aa, bb, cc, X[ 5],  6);
122     II(cc, dd, aa, bb, X[ 6],  5);
123     II(bb, cc, dd, aa, X[ 2], 12);
124     III(aaa, bbb, ccc, ddd, X[ 5],  8);
125     III(ddd, aaa, bbb, ccc, X[14],  9);
126     III(ccc, ddd, aaa, bbb, X[ 7],  9);
127     III(bbb, ccc, ddd, aaa, X[ 0], 11);
128     III(aaa, bbb, ccc, ddd, X[ 9], 13);
129     III(ddd, aaa, bbb, ccc, X[ 2], 15);
130     III(ccc, ddd, aaa, bbb, X[11], 15);
131     III(bbb, ccc, ddd, aaa, X[ 4],  5);
132     III(aaa, bbb, ccc, ddd, X[13],  7);
133     III(ddd, aaa, bbb, ccc, X[ 6],  7);
134     III(ccc, ddd, aaa, bbb, X[15],  8);
135     III(bbb, ccc, ddd, aaa, X[ 8], 11);
136     III(aaa, bbb, ccc, ddd, X[ 1], 14);
137     III(ddd, aaa, bbb, ccc, X[10], 14);
138     III(ccc, ddd, aaa, bbb, X[ 3], 12);
139     III(bbb, ccc, ddd, aaa, X[12],  6);
140     HHH(aaa, bbb, ccc, ddd, X[ 6],  9);
141     HHH(ddd, aaa, bbb, ccc, X[11], 13);
142     HHH(ccc, ddd, aaa, bbb, X[ 3], 15);
143     HHH(bbb, ccc, ddd, aaa, X[ 7],  7);
144     HHH(aaa, bbb, ccc, ddd, X[ 0], 12);
145     HHH(ddd, aaa, bbb, ccc, X[13],  8);
146     HHH(ccc, ddd, aaa, bbb, X[ 5],  9);
147     HHH(bbb, ccc, ddd, aaa, X[10], 11);
148     HHH(aaa, bbb, ccc, ddd, X[14],  7);
149     HHH(ddd, aaa, bbb, ccc, X[15],  7);
150     HHH(ccc, ddd, aaa, bbb, X[ 8], 12);
151     HHH(bbb, ccc, ddd, aaa, X[12],  7);
152     HHH(aaa, bbb, ccc, ddd, X[ 4],  6);
153     HHH(ddd, aaa, bbb, ccc, X[ 9], 15);
154     HHH(ccc, ddd, aaa, bbb, X[ 1], 13);
155     HHH(bbb, ccc, ddd, aaa, X[ 2], 11);
156     GGG(aaa, bbb, ccc, ddd, X[15],  9);
157     GGG(ddd, aaa, bbb, ccc, X[ 5],  7);
158     GGG(ccc, ddd, aaa, bbb, X[ 1], 15);
159     GGG(bbb, ccc, ddd, aaa, X[ 3], 11);
160     GGG(aaa, bbb, ccc, ddd, X[ 7],  8);
161     GGG(ddd, aaa, bbb, ccc, X[14],  6);
162     GGG(ccc, ddd, aaa, bbb, X[ 6],  6);
163     GGG(bbb, ccc, ddd, aaa, X[ 9], 14);
164     GGG(aaa, bbb, ccc, ddd, X[11], 12);
165     GGG(ddd, aaa, bbb, ccc, X[ 8], 13);
166     GGG(ccc, ddd, aaa, bbb, X[12],  5);
167     GGG(bbb, ccc, ddd, aaa, X[ 2], 14);
168     GGG(aaa, bbb, ccc, ddd, X[10], 13);
169     GGG(ddd, aaa, bbb, ccc, X[ 0], 13);
170     GGG(ccc, ddd, aaa, bbb, X[ 4],  7);
171     GGG(bbb, ccc, ddd, aaa, X[13],  5);
172     FFF(aaa, bbb, ccc, ddd, X[ 8], 15);
173     FFF(ddd, aaa, bbb, ccc, X[ 6],  5);
174     FFF(ccc, ddd, aaa, bbb, X[ 4],  8);
175     FFF(bbb, ccc, ddd, aaa, X[ 1], 11);
176     FFF(aaa, bbb, ccc, ddd, X[ 3], 14);
177     FFF(ddd, aaa, bbb, ccc, X[11], 14);
178     FFF(ccc, ddd, aaa, bbb, X[15],  6);
179     FFF(bbb, ccc, ddd, aaa, X[ 0], 14);
180     FFF(aaa, bbb, ccc, ddd, X[ 5],  6);
181     FFF(ddd, aaa, bbb, ccc, X[12],  9);
182     FFF(ccc, ddd, aaa, bbb, X[ 2], 12);
183     FFF(bbb, ccc, ddd, aaa, X[13],  9);
184     FFF(aaa, bbb, ccc, ddd, X[ 9], 12);
185     FFF(ddd, aaa, bbb, ccc, X[ 7],  5);
186     FFF(ccc, ddd, aaa, bbb, X[10], 15);
187     FFF(bbb, ccc, ddd, aaa, X[14],  8);
188     ddd += cc + md->rmd128.state[1];               &bsol;* final result for MDbuf[0] */
</span>189     md->rmd128.state[1] = md->rmd128.state[2] + dd + aaa;
190     md->rmd128.state[2] = md->rmd128.state[3] + aa + bbb;
191     md->rmd128.state[3] = md->rmd128.state[0] + bb + ccc;
192     md->rmd128.state[0] = ddd;
193     return CRYPT_OK;
194  }
195  #ifdef LTC_CLEAN_STACK
196  static int s_rmd128_compress(hash_state *md, const unsigned char *buf)
197  {
198     int err;
199     err = ss_rmd128_compress(md, buf);
200     burn_stack(sizeof(ulong32) * 24 + sizeof(int));
201     return err;
202  }
203  #endif
204  int rmd128_init(hash_state * md)
205  {
206     LTC_ARGCHK(md != NULL);
207     md->rmd128.state[0] = 0x67452301UL;
208     md->rmd128.state[1] = 0xefcdab89UL;
209     md->rmd128.state[2] = 0x98badcfeUL;
210     md->rmd128.state[3] = 0x10325476UL;
211     md->rmd128.curlen   = 0;
212     md->rmd128.length   = 0;
213     return CRYPT_OK;
214  }
215  HASH_PROCESS(rmd128_process, s_rmd128_compress, rmd128, 64)
216  int rmd128_done(hash_state * md, unsigned char *out)
217  {
218      int i;
219      LTC_ARGCHK(md  != NULL);
220      LTC_ARGCHK(out != NULL);
221      if (md->rmd128.curlen >= sizeof(md->rmd128.buf)) {
222         return CRYPT_INVALID_ARG;
223      }
224      md->rmd128.length += md->rmd128.curlen * 8;
225      md->rmd128.buf[md->rmd128.curlen++] = (unsigned char)0x80;
226      if (md->rmd128.curlen > 56) {
227          while (md->rmd128.curlen < 64) {
228              md->rmd128.buf[md->rmd128.curlen++] = (unsigned char)0;
229          }
230          s_rmd128_compress(md, md->rmd128.buf);
231          md->rmd128.curlen = 0;
232      }
233      while (md->rmd128.curlen < 56) {
234          md->rmd128.buf[md->rmd128.curlen++] = (unsigned char)0;
235      }
236      STORE64L(md->rmd128.length, md->rmd128.buf+56);
237      s_rmd128_compress(md, md->rmd128.buf);
238      for (i = 0; i < 4; i++) {
239          STORE32L(md->rmd128.state[i], out+(4*i));
240      }
241  #ifdef LTC_CLEAN_STACK
242      zeromem(md, sizeof(hash_state));
243  #endif
244     return CRYPT_OK;
245  }
246  int rmd128_test(void)
247  {
248  #ifndef LTC_TEST
249     return CRYPT_NOP;
250  #else
251     static const struct {
252          const char *msg;
253          unsigned char hash[16];
254     } tests[] = {
255     { "",
256       { 0xcd, 0xf2, 0x62, 0x13, 0xa1, 0x50, 0xdc, 0x3e,
257         0xcb, 0x61, 0x0f, 0x18, 0xf6, 0xb3, 0x8b, 0x46 }
258     },
259     { "a",
260       { 0x86, 0xbe, 0x7a, 0xfa, 0x33, 0x9d, 0x0f, 0xc7,
261         0xcf, 0xc7, 0x85, 0xe7, 0x2f, 0x57, 0x8d, 0x33 }
262     },
263     { "abc",
264       { 0xc1, 0x4a, 0x12, 0x19, 0x9c, 0x66, 0xe4, 0xba,
265         0x84, 0x63, 0x6b, 0x0f, 0x69, 0x14, 0x4c, 0x77 }
266     },
267     { "message digest",
268       { 0x9e, 0x32, 0x7b, 0x3d, 0x6e, 0x52, 0x30, 0x62,
269         0xaf, 0xc1, 0x13, 0x2d, 0x7d, 0xf9, 0xd1, 0xb8 }
270     },
271     { "abcdefghijklmnopqrstuvwxyz",
272       { 0xfd, 0x2a, 0xa6, 0x07, 0xf7, 0x1d, 0xc8, 0xf5,
273         0x10, 0x71, 0x49, 0x22, 0xb3, 0x71, 0x83, 0x4e }
274     },
275     { "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789",
276       { 0xd1, 0xe9, 0x59, 0xeb, 0x17, 0x9c, 0x91, 0x1f,
277         0xae, 0xa4, 0x62, 0x4c, 0x60, 0xc5, 0xc7, 0x02 }
278     }
279     };
280     int i;
281     unsigned char tmp[16];
282     hash_state md;
283     for (i = 0; i < (int)(sizeof(tests)/sizeof(tests[0])); i++) {
284         rmd128_init(&md);
285         rmd128_process(&md, (unsigned char *)tests[i].msg, XSTRLEN(tests[i].msg));
286         rmd128_done(&md, tmp);
287         if (compare_testvector(tmp, sizeof(tmp), tests[i].hash, sizeof(tests[i].hash), "RIPEMD128", i)) {
288            return CRYPT_FAIL_TESTVECTOR;
289         }
290     }
291     return CRYPT_OK;
292  #endif
293  }
294  #endif
</code></pre>
        </div>
        <div class="column">
            <h3>fftw3-MDEwOlJlcG9zaXRvcnk4ODQzMzg4-flat-dht-rader.c</h3>
            <pre><code>1  #include "rdft/rdft.h"
2  typedef struct {
3       solver super;
4       int pad;
5  } S;
6  typedef struct {
7       plan_rdft super;
8       plan *cld1, *cld2;
9       R *omega;
10       INT n, npad, g, ginv;
11       INT is, os;
12       plan *cld_omega;
13  } P;
14  static rader_tl *omegas = 0;
15  #define R2HC_ONLY_CONV 1
16  static void apply(const plan *ego_, R *I, R *O)
17  {
18       const P *ego = (const P *) ego_;
19       INT n = ego->n; &bsol;* prime */
20       INT npad = ego->npad; &bsol;* == n - 1 for unpadded Rader; always even */
21       INT is = ego->is, os;
22       INT k, gpower, g;
23       R *buf, *omega;
24       R r0;
25       buf = (R *) MALLOC(sizeof(R) * npad, BUFFERS);
26       g = ego->g; 
27       for (gpower = 1, k = 0; k < n - 1; ++k, gpower = MULMOD(gpower, g, n)) {
28  	  buf[k] = I[gpower * is];
29       }
30       ;
31       A(n - 1 <= npad);
32       for (k = n - 1; k < npad; ++k) &bsol;* optionally, zero-pad convolution */
33  	  buf[k] = 0;
34       os = ego->os;
35       {
36  	    plan_rdft *cld = (plan_rdft *) ego->cld1;
37  	    cld->apply((plan *) cld, buf, buf);
38       }
39       O[0] = (r0 = I[0]) + buf[0];
40       omega = ego->omega;
41       buf[0] *= omega[0];
42       for (k = 1; k < npad/2; ++k) {
43  	  E rB, iB, rW, iW, a, b;
<span onclick='openModal()' class='match'>44  	  rW = omega[k];
45  	  iW = omega[npad - k];
46  	  rB = buf[k];
47  	  iB = buf[npad - k];
48  	  a = rW * rB - iW * iB;
49  	  b = rW * iB + iW * rB;
50  #if R2HC_ONLY_CONV
51  	  buf[k] = a + b;
52  	  buf[npad - k] = a - b;
53  #else
54  	  buf[k] = a;
</span>55  	  buf[npad - k] = b;
56  #endif
57       }
58       A(k + k == npad); &bsol;* since npad is even */
59       buf[k] *= omega[k];
60       buf[0] += r0;
61       {
62  	    plan_rdft *cld = (plan_rdft *) ego->cld2;
63  	    cld->apply((plan *) cld, buf, buf);
64       }
65       A(gpower == 1);
66  #if R2HC_ONLY_CONV
67       O[os] = buf[0];
68       gpower = g = ego->ginv;
69       A(npad == n - 1 || npad/2 >= n - 1);
70       if (npad == n - 1) {
71  	  for (k = 1; k < npad/2; ++k, gpower = MULMOD(gpower, g, n)) {
72  	       O[gpower * os] = buf[k] + buf[npad - k];
73  	  }
74  	  O[gpower * os] = buf[k];
75  	  ++k, gpower = MULMOD(gpower, g, n);
76  	  for (; k < npad; ++k, gpower = MULMOD(gpower, g, n)) {
77  	       O[gpower * os] = buf[npad - k] - buf[k];
78  	  }
79       }
80       else {
81  	  for (k = 1; k < n - 1; ++k, gpower = MULMOD(gpower, g, n)) {
82  	       O[gpower * os] = buf[k] + buf[npad - k];
83  	  }
84       }
85  #else
86       g = ego->ginv;
87       for (k = 0; k < n - 1; ++k, gpower = MULMOD(gpower, g, n)) {
88  	  O[gpower * os] = buf[k];
89       }
90  #endif
91       A(gpower == 1);
92       X(ifree)(buf);
93  }
94  static R *mkomega(enum wakefulness wakefulness,
95  		  plan *p_, INT n, INT npad, INT ginv)
96  {
97       plan_rdft *p = (plan_rdft *) p_;
98       R *omega;
99       INT i, gpower;
100       trigreal scale;
101       triggen *t;
102       if ((omega = X(rader_tl_find)(n, npad + 1, ginv, omegas))) 
103  	  return omega;
104       omega = (R *)MALLOC(sizeof(R) * npad, TWIDDLES);
105       scale = npad; &bsol;* normalization for convolution */
106       t = X(mktriggen)(wakefulness, n);
107       for (i = 0, gpower = 1; i < n-1; ++i, gpower = MULMOD(gpower, ginv, n)) {
108  	  trigreal w[2];
109  	  t->cexpl(t, gpower, w);
110  	  omega[i] = (w[0] + w[1]) / scale;
111       }
112       X(triggen_destroy)(t);
113       A(gpower == 1);
114       A(npad == n - 1 || npad >= 2*(n - 1) - 1);
115       for (; i < npad; ++i)
116  	  omega[i] = K(0.0);
117       if (npad > n - 1)
118  	  for (i = 1; i < n-1; ++i)
119  	       omega[npad - i] = omega[n - 1 - i];
120       p->apply(p_, omega, omega);
121       X(rader_tl_insert)(n, npad + 1, ginv, omega, &omegas);
122       return omega;
123  }
124  static void free_omega(R *omega)
125  {
126       X(rader_tl_delete)(omega, &omegas);
127  }
128  static void awake(plan *ego_, enum wakefulness wakefulness)
129  {
130       P *ego = (P *) ego_;
131       X(plan_awake)(ego->cld1, wakefulness);
132       X(plan_awake)(ego->cld2, wakefulness);
133       X(plan_awake)(ego->cld_omega, wakefulness);
134       switch (wakefulness) {
135  	 case SLEEPY:
136  	      free_omega(ego->omega);
137  	      ego->omega = 0;
138  	      break;
139  	 default:
140  	      ego->g = X(find_generator)(ego->n);
141  	      ego->ginv = X(power_mod)(ego->g, ego->n - 2, ego->n);
142  	      A(MULMOD(ego->g, ego->ginv, ego->n) == 1);
143  	      A(!ego->omega);
144  	      ego->omega = mkomega(wakefulness, 
145  				   ego->cld_omega,ego->n,ego->npad,ego->ginv);
146  	      break;
147       }
148  }
149  static void destroy(plan *ego_)
150  {
151       P *ego = (P *) ego_;
152       X(plan_destroy_internal)(ego->cld_omega);
153       X(plan_destroy_internal)(ego->cld2);
154       X(plan_destroy_internal)(ego->cld1);
155  }
156  static void print(const plan *ego_, printer *p)
157  {
158       const P *ego = (const P *) ego_;
159       p->print(p, "(dht-rader-%D/%D%ois=%oos=%(%p%)",
160                ego->n, ego->npad, ego->is, ego->os, ego->cld1);
161       if (ego->cld2 != ego->cld1)
162            p->print(p, "%(%p%)", ego->cld2);
163       if (ego->cld_omega != ego->cld1 && ego->cld_omega != ego->cld2)
164            p->print(p, "%(%p%)", ego->cld_omega);
165       p->putchr(p, ')');
166  }
167  static int applicable(const solver *ego, const problem *p_, const planner *plnr)
168  {
169       const problem_rdft *p = (const problem_rdft *) p_;
170       UNUSED(ego);
171       return (1
172  	     && p->sz->rnk == 1
173  	     && p->vecsz->rnk == 0
174  	     && p->kind[0] == DHT
175  	     && X(is_prime)(p->sz->dims[0].n)
176  	     && p->sz->dims[0].n > 2
177  	     && CIMPLIES(NO_SLOWP(plnr), p->sz->dims[0].n > RADER_MAX_SLOW)
178  	     && CIMPLIES(NO_SLOWP(plnr), X(factors_into_small_primes)(p->sz->dims[0].n - 1))
179  	  );
180  }
181  static INT choose_transform_size(INT minsz)
182  {
183       static const INT primes[] = { 2, 3, 5, 0 };
184       while (!X(factors_into)(minsz, primes) || minsz % 2)
185  	  ++minsz;
186       return minsz;
187  }
188  static plan *mkplan(const solver *ego_, const problem *p_, planner *plnr)
189  {
190       const S *ego = (const S *) ego_;
191       const problem_rdft *p = (const problem_rdft *) p_;
192       P *pln;
193       INT n, npad;
194       INT is, os;
195       plan *cld1 = (plan *) 0;
196       plan *cld2 = (plan *) 0;
197       plan *cld_omega = (plan *) 0;
198       R *buf = (R *) 0;
199       problem *cldp;
200       static const plan_adt padt = {
201  	  X(rdft_solve), awake, print, destroy
202       };
203       if (!applicable(ego_, p_, plnr))
204  	  return (plan *) 0;
205       n = p->sz->dims[0].n;
206       is = p->sz->dims[0].is;
207       os = p->sz->dims[0].os;
208       if (ego->pad)
209  	  npad = choose_transform_size(2 * (n - 1) - 1);
210       else
211  	  npad = n - 1;
212       buf = (R *) MALLOC(sizeof(R) * npad, BUFFERS);
213       cld1 = X(mkplan_f_d)(plnr, 
214  			  X(mkproblem_rdft_1_d)(X(mktensor_1d)(npad, 1, 1),
215  						X(mktensor_1d)(1, 0, 0),
216  						buf, buf,
217  						R2HC),
218  			  NO_SLOW, 0, 0);
219       if (!cld1) goto nada;
220       cldp =
221            X(mkproblem_rdft_1_d)(
222                 X(mktensor_1d)(npad, 1, 1),
223                 X(mktensor_1d)(1, 0, 0),
224  	       buf, buf, 
225  #if R2HC_ONLY_CONV
226  	       R2HC
227  #else
228  	       HC2R
229  #endif
230  	       );
231       if (!(cld2 = X(mkplan_f_d)(plnr, cldp, NO_SLOW, 0, 0)))
232  	  goto nada;
233       cld_omega = X(mkplan_f_d)(plnr, 
234  			       X(mkproblem_rdft_1_d)(
235  				    X(mktensor_1d)(npad, 1, 1),
236  				    X(mktensor_1d)(1, 0, 0),
237  				    buf, buf, R2HC),
238  			       NO_SLOW, ESTIMATE, 0);
239       if (!cld_omega) goto nada;
240       X(ifree)(buf);
241       buf = 0;
242       pln = MKPLAN_RDFT(P, &padt, apply);
243       pln->cld1 = cld1;
244       pln->cld2 = cld2;
245       pln->cld_omega = cld_omega;
246       pln->omega = 0;
247       pln->n = n;
248       pln->npad = npad;
249       pln->is = is;
250       pln->os = os;
251       X(ops_add)(&cld1->ops, &cld2->ops, &pln->super.super.ops);
252       pln->super.super.ops.other += (npad/2-1)*6 + npad + n + (n-1) * ego->pad;
253       pln->super.super.ops.add += (npad/2-1)*2 + 2 + (n-1) * ego->pad;
254       pln->super.super.ops.mul += (npad/2-1)*4 + 2 + ego->pad;
255  #if R2HC_ONLY_CONV
256       pln->super.super.ops.other += n-2 - ego->pad;
257       pln->super.super.ops.add += (npad/2-1)*2 + (n-2) - ego->pad;
258  #endif
259       return &(pln->super.super);
260   nada:
261       X(ifree0)(buf);
262       X(plan_destroy_internal)(cld_omega);
263       X(plan_destroy_internal)(cld2);
264       X(plan_destroy_internal)(cld1);
265       return 0;
266  }
267  static solver *mksolver(int pad)
268  {
269       static const solver_adt sadt = { PROBLEM_RDFT, mkplan, 0 };
270       S *slv = MKSOLVER(S, &sadt);
271       slv->pad = pad;
272       return &(slv->super);
273  }
274  void X(dht_rader_register)(planner *p)
275  {
276       REGISTER_SOLVER(p, mksolver(0));
277       REGISTER_SOLVER(p, mksolver(1));
278  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from libtomcrypt-MDEwOlJlcG9zaXRvcnk3NzcwMTE=-flat-rmd128.c</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from fftw3-MDEwOlJlcG9zaXRvcnk4ODQzMzg4-flat-dht-rader.c</div>
                </div>
                <div class="column column_space"><pre><code>56     aa = aaa = md->rmd128.state[0];
57     bb = bbb = md->rmd128.state[1];
58     cc = ccc = md->rmd128.state[2];
59     dd = ddd = md->rmd128.state[3];
60     FF(aa, bb, cc, dd, X[ 0], 11);
61     FF(dd, aa, bb, cc, X[ 1], 14);
62     FF(cc, dd, aa, bb, X[ 2], 15);
63     FF(bb, cc, dd, aa, X[ 3], 12);
64     FF(aa, bb, cc, dd, X[ 4],  5);
65     FF(dd, aa, bb, cc, X[ 5],  8);
66     FF(cc, dd, aa, bb, X[ 6],  7);
67     FF(bb, cc, dd, aa, X[ 7],  9);
68     FF(aa, bb, cc, dd, X[ 8], 11);
69     FF(dd, aa, bb, cc, X[ 9], 13);
70     FF(cc, dd, aa, bb, X[10], 14);
71     FF(bb, cc, dd, aa, X[11], 15);
72     FF(aa, bb, cc, dd, X[12],  6);
73     FF(dd, aa, bb, cc, X[13],  7);
74     FF(cc, dd, aa, bb, X[14],  9);
75     FF(bb, cc, dd, aa, X[15],  8);
76     GG(aa, bb, cc, dd, X[ 7],  7);
77     GG(dd, aa, bb, cc, X[ 4],  6);
78     GG(cc, dd, aa, bb, X[13],  8);
79     GG(bb, cc, dd, aa, X[ 1], 13);
80     GG(aa, bb, cc, dd, X[10], 11);
81     GG(dd, aa, bb, cc, X[ 6],  9);
82     GG(cc, dd, aa, bb, X[15],  7);
83     GG(bb, cc, dd, aa, X[ 3], 15);
84     GG(aa, bb, cc, dd, X[12],  7);
85     GG(dd, aa, bb, cc, X[ 0], 12);
86     GG(cc, dd, aa, bb, X[ 9], 15);
87     GG(bb, cc, dd, aa, X[ 5],  9);
88     GG(aa, bb, cc, dd, X[ 2], 11);
89     GG(dd, aa, bb, cc, X[14],  7);
90     GG(cc, dd, aa, bb, X[11], 13);
91     GG(bb, cc, dd, aa, X[ 8], 12);
92     HH(aa, bb, cc, dd, X[ 3], 11);
93     HH(dd, aa, bb, cc, X[10], 13);
94     HH(cc, dd, aa, bb, X[14],  6);
95     HH(bb, cc, dd, aa, X[ 4],  7);
96     HH(aa, bb, cc, dd, X[ 9], 14);
97     HH(dd, aa, bb, cc, X[15],  9);
98     HH(cc, dd, aa, bb, X[ 8], 13);
99     HH(bb, cc, dd, aa, X[ 1], 15);
100     HH(aa, bb, cc, dd, X[ 2], 14);
101     HH(dd, aa, bb, cc, X[ 7],  8);
102     HH(cc, dd, aa, bb, X[ 0], 13);
103     HH(bb, cc, dd, aa, X[ 6],  6);
104     HH(aa, bb, cc, dd, X[13],  5);
105     HH(dd, aa, bb, cc, X[11], 12);
106     HH(cc, dd, aa, bb, X[ 5],  7);
107     HH(bb, cc, dd, aa, X[12],  5);
108     II(aa, bb, cc, dd, X[ 1], 11);
109     II(dd, aa, bb, cc, X[ 9], 12);
110     II(cc, dd, aa, bb, X[11], 14);
111     II(bb, cc, dd, aa, X[10], 15);
112     II(aa, bb, cc, dd, X[ 0], 14);
113     II(dd, aa, bb, cc, X[ 8], 15);
114     II(cc, dd, aa, bb, X[12],  9);
115     II(bb, cc, dd, aa, X[ 4],  8);
116     II(aa, bb, cc, dd, X[13],  9);
117     II(dd, aa, bb, cc, X[ 3], 14);
118     II(cc, dd, aa, bb, X[ 7],  5);
119     II(bb, cc, dd, aa, X[15],  6);
120     II(aa, bb, cc, dd, X[14],  8);
121     II(dd, aa, bb, cc, X[ 5],  6);
122     II(cc, dd, aa, bb, X[ 6],  5);
123     II(bb, cc, dd, aa, X[ 2], 12);
124     III(aaa, bbb, ccc, ddd, X[ 5],  8);
125     III(ddd, aaa, bbb, ccc, X[14],  9);
126     III(ccc, ddd, aaa, bbb, X[ 7],  9);
127     III(bbb, ccc, ddd, aaa, X[ 0], 11);
128     III(aaa, bbb, ccc, ddd, X[ 9], 13);
129     III(ddd, aaa, bbb, ccc, X[ 2], 15);
130     III(ccc, ddd, aaa, bbb, X[11], 15);
131     III(bbb, ccc, ddd, aaa, X[ 4],  5);
132     III(aaa, bbb, ccc, ddd, X[13],  7);
133     III(ddd, aaa, bbb, ccc, X[ 6],  7);
134     III(ccc, ddd, aaa, bbb, X[15],  8);
135     III(bbb, ccc, ddd, aaa, X[ 8], 11);
136     III(aaa, bbb, ccc, ddd, X[ 1], 14);
137     III(ddd, aaa, bbb, ccc, X[10], 14);
138     III(ccc, ddd, aaa, bbb, X[ 3], 12);
139     III(bbb, ccc, ddd, aaa, X[12],  6);
140     HHH(aaa, bbb, ccc, ddd, X[ 6],  9);
141     HHH(ddd, aaa, bbb, ccc, X[11], 13);
142     HHH(ccc, ddd, aaa, bbb, X[ 3], 15);
143     HHH(bbb, ccc, ddd, aaa, X[ 7],  7);
144     HHH(aaa, bbb, ccc, ddd, X[ 0], 12);
145     HHH(ddd, aaa, bbb, ccc, X[13],  8);
146     HHH(ccc, ddd, aaa, bbb, X[ 5],  9);
147     HHH(bbb, ccc, ddd, aaa, X[10], 11);
148     HHH(aaa, bbb, ccc, ddd, X[14],  7);
149     HHH(ddd, aaa, bbb, ccc, X[15],  7);
150     HHH(ccc, ddd, aaa, bbb, X[ 8], 12);
151     HHH(bbb, ccc, ddd, aaa, X[12],  7);
152     HHH(aaa, bbb, ccc, ddd, X[ 4],  6);
153     HHH(ddd, aaa, bbb, ccc, X[ 9], 15);
154     HHH(ccc, ddd, aaa, bbb, X[ 1], 13);
155     HHH(bbb, ccc, ddd, aaa, X[ 2], 11);
156     GGG(aaa, bbb, ccc, ddd, X[15],  9);
157     GGG(ddd, aaa, bbb, ccc, X[ 5],  7);
158     GGG(ccc, ddd, aaa, bbb, X[ 1], 15);
159     GGG(bbb, ccc, ddd, aaa, X[ 3], 11);
160     GGG(aaa, bbb, ccc, ddd, X[ 7],  8);
161     GGG(ddd, aaa, bbb, ccc, X[14],  6);
162     GGG(ccc, ddd, aaa, bbb, X[ 6],  6);
163     GGG(bbb, ccc, ddd, aaa, X[ 9], 14);
164     GGG(aaa, bbb, ccc, ddd, X[11], 12);
165     GGG(ddd, aaa, bbb, ccc, X[ 8], 13);
166     GGG(ccc, ddd, aaa, bbb, X[12],  5);
167     GGG(bbb, ccc, ddd, aaa, X[ 2], 14);
168     GGG(aaa, bbb, ccc, ddd, X[10], 13);
169     GGG(ddd, aaa, bbb, ccc, X[ 0], 13);
170     GGG(ccc, ddd, aaa, bbb, X[ 4],  7);
171     GGG(bbb, ccc, ddd, aaa, X[13],  5);
172     FFF(aaa, bbb, ccc, ddd, X[ 8], 15);
173     FFF(ddd, aaa, bbb, ccc, X[ 6],  5);
174     FFF(ccc, ddd, aaa, bbb, X[ 4],  8);
175     FFF(bbb, ccc, ddd, aaa, X[ 1], 11);
176     FFF(aaa, bbb, ccc, ddd, X[ 3], 14);
177     FFF(ddd, aaa, bbb, ccc, X[11], 14);
178     FFF(ccc, ddd, aaa, bbb, X[15],  6);
179     FFF(bbb, ccc, ddd, aaa, X[ 0], 14);
180     FFF(aaa, bbb, ccc, ddd, X[ 5],  6);
181     FFF(ddd, aaa, bbb, ccc, X[12],  9);
182     FFF(ccc, ddd, aaa, bbb, X[ 2], 12);
183     FFF(bbb, ccc, ddd, aaa, X[13],  9);
184     FFF(aaa, bbb, ccc, ddd, X[ 9], 12);
185     FFF(ddd, aaa, bbb, ccc, X[ 7],  5);
186     FFF(ccc, ddd, aaa, bbb, X[10], 15);
187     FFF(bbb, ccc, ddd, aaa, X[14],  8);
188     ddd += cc + md->rmd128.state[1];               &bsol;* final result for MDbuf[0] */
</pre></code></div>
                <div class="column column_space"><pre><code>44  	  rW = omega[k];
45  	  iW = omega[npad - k];
46  	  rB = buf[k];
47  	  iB = buf[npad - k];
48  	  a = rW * rB - iW * iB;
49  	  b = rW * iB + iW * rB;
50  #if R2HC_ONLY_CONV
51  	  buf[k] = a + b;
52  	  buf[npad - k] = a - b;
53  #else
54  	  buf[k] = a;
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    